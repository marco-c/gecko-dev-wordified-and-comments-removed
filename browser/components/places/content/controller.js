function
PlacesInsertionPoint
(
{
parentId
parentGuid
index
=
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
orientation
=
Ci
.
nsITreeView
.
DROP_ON
tagName
=
null
dropNearNode
=
null
}
)
{
this
.
itemId
=
parentId
;
this
.
guid
=
parentGuid
;
this
.
_index
=
index
;
this
.
orientation
=
orientation
;
this
.
tagName
=
tagName
;
this
.
dropNearNode
=
dropNearNode
;
}
PlacesInsertionPoint
.
prototype
=
{
set
index
(
val
)
{
return
this
.
_index
=
val
;
}
async
getIndex
(
)
{
if
(
this
.
dropNearNode
)
{
let
index
=
(
await
PlacesUtils
.
bookmarks
.
fetch
(
this
.
dropNearNode
.
bookmarkGuid
)
)
.
index
;
return
this
.
orientation
=
=
Ci
.
nsITreeView
.
DROP_BEFORE
?
index
:
index
+
1
;
}
return
this
.
_index
;
}
get
isTag
(
)
{
return
typeof
(
this
.
tagName
)
=
=
"
string
"
;
}
}
;
function
PlacesController
(
aView
)
{
this
.
_view
=
aView
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
clipboard
"
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
"
nsIClipboard
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
profileName
"
function
(
)
{
return
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
leafName
;
}
)
;
}
PlacesController
.
prototype
=
{
_view
:
null
disableUserActions
:
false
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIClipboardOwner
]
)
LosingOwnership
:
function
PC_LosingOwnership
(
aXferable
)
{
this
.
cutNodes
=
[
]
;
}
terminate
:
function
PC_terminate
(
)
{
this
.
_releaseClipboardOwnership
(
)
;
}
supportsCommand
:
function
PC_supportsCommand
(
aCommand
)
{
if
(
this
.
disableUserActions
)
{
return
false
;
}
switch
(
aCommand
)
{
case
"
cmd_undo
"
:
case
"
cmd_redo
"
:
case
"
cmd_cut
"
:
case
"
cmd_copy
"
:
case
"
cmd_paste
"
:
case
"
cmd_delete
"
:
case
"
cmd_selectAll
"
:
return
true
;
}
const
CMD_PREFIX
=
"
placesCmd_
"
;
return
(
aCommand
.
substr
(
0
CMD_PREFIX
.
length
)
=
=
CMD_PREFIX
)
;
}
isCommandEnabled
:
function
PC_isCommandEnabled
(
aCommand
)
{
switch
(
aCommand
)
{
case
"
cmd_undo
"
:
return
PlacesTransactions
.
topUndoEntry
!
=
null
;
case
"
cmd_redo
"
:
return
PlacesTransactions
.
topRedoEntry
!
=
null
;
case
"
cmd_cut
"
:
case
"
placesCmd_cut
"
:
for
(
let
node
of
this
.
_view
.
selectedNodes
)
{
if
(
node
.
itemId
=
=
-
1
|
|
(
node
.
parent
&
&
PlacesUtils
.
nodeIsTagQuery
(
node
.
parent
)
)
)
{
return
false
;
}
}
case
"
cmd_delete
"
:
case
"
placesCmd_delete
"
:
case
"
placesCmd_deleteDataHost
"
:
return
this
.
_hasRemovableSelection
(
)
;
case
"
cmd_copy
"
:
case
"
placesCmd_copy
"
:
return
this
.
_view
.
hasSelection
;
case
"
cmd_paste
"
:
case
"
placesCmd_paste
"
:
return
this
.
_canInsert
(
true
)
&
&
this
.
_isClipboardDataPasteable
(
)
;
case
"
cmd_selectAll
"
:
if
(
this
.
_view
.
selType
!
=
"
single
"
)
{
let
rootNode
=
this
.
_view
.
result
.
root
;
if
(
rootNode
.
containerOpen
&
&
rootNode
.
childCount
>
0
)
return
true
;
}
return
false
;
case
"
placesCmd_open
"
:
case
"
placesCmd_open
:
window
"
:
case
"
placesCmd_open
:
privatewindow
"
:
case
"
placesCmd_open
:
tab
"
:
{
let
selectedNode
=
this
.
_view
.
selectedNode
;
return
selectedNode
&
&
PlacesUtils
.
nodeIsURI
(
selectedNode
)
;
}
case
"
placesCmd_new
:
folder
"
:
return
this
.
_canInsert
(
)
;
case
"
placesCmd_new
:
bookmark
"
:
return
this
.
_canInsert
(
)
;
case
"
placesCmd_new
:
separator
"
:
return
this
.
_canInsert
(
)
&
&
!
PlacesUtils
.
asQuery
(
this
.
_view
.
result
.
root
)
.
queryOptions
.
excludeItems
&
&
this
.
_view
.
result
.
sortingMode
=
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_NONE
;
case
"
placesCmd_show
:
info
"
:
{
let
selectedNode
=
this
.
_view
.
selectedNode
;
return
selectedNode
&
&
(
PlacesUtils
.
nodeIsTagQuery
(
selectedNode
)
|
|
PlacesUtils
.
nodeIsBookmark
(
selectedNode
)
|
|
(
PlacesUtils
.
nodeIsFolder
(
selectedNode
)
&
&
!
PlacesUtils
.
isQueryGeneratedFolder
(
selectedNode
)
)
)
;
}
case
"
placesCmd_sortBy
:
name
"
:
{
let
selectedNode
=
this
.
_view
.
selectedNode
;
return
selectedNode
&
&
PlacesUtils
.
nodeIsFolder
(
selectedNode
)
&
&
!
PlacesUIUtils
.
isFolderReadOnly
(
selectedNode
)
&
&
this
.
_view
.
result
.
sortingMode
=
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_NONE
;
}
case
"
placesCmd_createBookmark
"
:
var
node
=
this
.
_view
.
selectedNode
;
return
node
&
&
PlacesUtils
.
nodeIsURI
(
node
)
&
&
node
.
itemId
=
=
-
1
;
default
:
return
false
;
}
}
doCommand
:
function
PC_doCommand
(
aCommand
)
{
switch
(
aCommand
)
{
case
"
cmd_undo
"
:
PlacesTransactions
.
undo
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
cmd_redo
"
:
PlacesTransactions
.
redo
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
cmd_cut
"
:
case
"
placesCmd_cut
"
:
this
.
cut
(
)
;
break
;
case
"
cmd_copy
"
:
case
"
placesCmd_copy
"
:
this
.
copy
(
)
;
break
;
case
"
cmd_paste
"
:
case
"
placesCmd_paste
"
:
this
.
paste
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
cmd_delete
"
:
case
"
placesCmd_delete
"
:
this
.
remove
(
"
Remove
Selection
"
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
placesCmd_deleteDataHost
"
:
let
host
;
if
(
PlacesUtils
.
nodeIsHost
(
this
.
_view
.
selectedNode
)
)
{
host
=
this
.
_view
.
selectedNode
.
query
.
domain
;
}
else
{
host
=
Services
.
io
.
newURI
(
this
.
_view
.
selectedNode
.
uri
)
.
host
;
}
let
{
ForgetAboutSite
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ForgetAboutSite
.
jsm
"
)
;
ForgetAboutSite
.
removeDataFromDomain
(
host
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
cmd_selectAll
"
:
this
.
selectAll
(
)
;
break
;
case
"
placesCmd_open
"
:
PlacesUIUtils
.
openNodeIn
(
this
.
_view
.
selectedNode
"
current
"
this
.
_view
)
;
break
;
case
"
placesCmd_open
:
window
"
:
PlacesUIUtils
.
openNodeIn
(
this
.
_view
.
selectedNode
"
window
"
this
.
_view
)
;
break
;
case
"
placesCmd_open
:
privatewindow
"
:
PlacesUIUtils
.
openNodeIn
(
this
.
_view
.
selectedNode
"
window
"
this
.
_view
true
)
;
break
;
case
"
placesCmd_open
:
tab
"
:
PlacesUIUtils
.
openNodeIn
(
this
.
_view
.
selectedNode
"
tab
"
this
.
_view
)
;
break
;
case
"
placesCmd_new
:
folder
"
:
this
.
newItem
(
"
folder
"
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
placesCmd_new
:
bookmark
"
:
this
.
newItem
(
"
bookmark
"
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
placesCmd_new
:
separator
"
:
this
.
newSeparator
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
placesCmd_show
:
info
"
:
this
.
showBookmarkPropertiesForSelection
(
)
;
break
;
case
"
placesCmd_sortBy
:
name
"
:
this
.
sortFolderByName
(
)
.
catch
(
Cu
.
reportError
)
;
break
;
case
"
placesCmd_createBookmark
"
:
let
node
=
this
.
_view
.
selectedNode
;
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
"
bookmark
"
hiddenRows
:
[
"
keyword
"
"
location
"
]
uri
:
Services
.
io
.
newURI
(
node
.
uri
)
title
:
node
.
title
}
window
.
top
)
;
break
;
}
}
onEvent
:
function
PC_onEvent
(
eventName
)
{
}
_hasRemovableSelection
(
)
{
var
ranges
=
this
.
_view
.
removableSelectionRanges
;
if
(
!
ranges
.
length
)
return
false
;
var
root
=
this
.
_view
.
result
.
root
;
for
(
var
j
=
0
;
j
<
ranges
.
length
;
j
+
+
)
{
var
nodes
=
ranges
[
j
]
;
for
(
var
i
=
0
;
i
<
nodes
.
length
;
+
+
i
)
{
if
(
nodes
[
i
]
=
=
root
)
return
false
;
if
(
!
PlacesUIUtils
.
canUserRemove
(
nodes
[
i
]
)
)
return
false
;
}
}
return
true
;
}
_canInsert
:
function
PC__canInsert
(
isPaste
)
{
var
ip
=
this
.
_view
.
insertionPoint
;
return
ip
!
=
null
&
&
(
isPaste
|
|
!
ip
.
isTag
)
;
}
_isClipboardDataPasteable
:
function
PC__isClipboardDataPasteable
(
)
{
var
flavors
=
PlacesUIUtils
.
PLACES_FLAVORS
;
var
clipboard
=
this
.
clipboard
;
var
hasPlacesData
=
clipboard
.
hasDataMatchingFlavors
(
flavors
flavors
.
length
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
if
(
hasPlacesData
)
return
this
.
_view
.
insertionPoint
!
=
null
;
var
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
null
)
;
xferable
.
addDataFlavor
(
PlacesUtils
.
TYPE_X_MOZ_URL
)
;
xferable
.
addDataFlavor
(
PlacesUtils
.
TYPE_UNICODE
)
;
clipboard
.
getData
(
xferable
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
try
{
var
data
=
{
}
type
=
{
}
;
xferable
.
getAnyTransferData
(
type
data
)
;
data
=
data
.
value
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
;
if
(
type
.
value
!
=
PlacesUtils
.
TYPE_X_MOZ_URL
&
&
type
.
value
!
=
PlacesUtils
.
TYPE_UNICODE
)
return
false
;
PlacesUtils
.
unwrapNodes
(
data
type
.
value
)
;
return
this
.
_view
.
insertionPoint
!
=
null
;
}
catch
(
e
)
{
return
false
;
}
}
_buildSelectionMetadata
:
function
PC__buildSelectionMetadata
(
)
{
var
metadata
=
[
]
;
var
nodes
=
this
.
_view
.
selectedNodes
;
for
(
var
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
var
nodeData
=
{
}
;
var
node
=
nodes
[
i
]
;
var
nodeType
=
node
.
type
;
switch
(
nodeType
)
{
case
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
:
nodeData
.
query
=
true
;
if
(
node
.
parent
)
{
switch
(
PlacesUtils
.
asQuery
(
node
.
parent
)
.
queryOptions
.
resultType
)
{
case
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_SITE_QUERY
:
nodeData
.
host
=
true
;
break
;
case
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_DATE_SITE_QUERY
:
case
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_DATE_QUERY
:
nodeData
.
day
=
true
;
break
;
}
}
break
;
case
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
:
case
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
:
nodeData
.
folder
=
true
;
break
;
case
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_SEPARATOR
:
nodeData
.
separator
=
true
;
break
;
case
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_URI
:
nodeData
.
link
=
true
;
if
(
PlacesUtils
.
nodeIsBookmark
(
node
)
)
{
nodeData
.
bookmark
=
true
;
var
parentNode
=
node
.
parent
;
if
(
parentNode
&
&
PlacesUtils
.
nodeIsTagQuery
(
parentNode
)
)
{
nodeData
.
tagChild
=
true
;
}
}
break
;
}
metadata
.
push
(
nodeData
)
;
}
return
metadata
;
}
_shouldShowMenuItem
:
function
PC__shouldShowMenuItem
(
aMenuItem
aMetaData
)
{
if
(
aMenuItem
.
hasAttribute
(
"
hideifprivatebrowsing
"
)
&
&
!
PrivateBrowsingUtils
.
enabled
)
{
return
false
;
}
var
selectiontype
=
aMenuItem
.
getAttribute
(
"
selectiontype
"
)
;
if
(
!
selectiontype
)
{
selectiontype
=
"
single
|
multiple
"
;
}
var
selectionTypes
=
selectiontype
.
split
(
"
|
"
)
;
if
(
selectionTypes
.
includes
(
"
any
"
)
)
{
return
true
;
}
var
count
=
aMetaData
.
length
;
if
(
count
>
1
&
&
!
selectionTypes
.
includes
(
"
multiple
"
)
)
return
false
;
if
(
count
=
=
1
&
&
!
selectionTypes
.
includes
(
"
single
"
)
)
return
false
;
if
(
count
=
=
0
)
return
selectionTypes
.
includes
(
"
none
"
)
;
var
forceHideAttr
=
aMenuItem
.
getAttribute
(
"
forcehideselection
"
)
;
if
(
forceHideAttr
)
{
var
forceHideRules
=
forceHideAttr
.
split
(
"
|
"
)
;
for
(
let
i
=
0
;
i
<
aMetaData
.
length
;
+
+
i
)
{
for
(
let
j
=
0
;
j
<
forceHideRules
.
length
;
+
+
j
)
{
if
(
forceHideRules
[
j
]
in
aMetaData
[
i
]
)
return
false
;
}
}
}
var
selectionAttr
=
aMenuItem
.
getAttribute
(
"
selection
"
)
;
if
(
!
selectionAttr
)
{
return
!
aMenuItem
.
hidden
;
}
if
(
selectionAttr
=
=
"
any
"
)
return
true
;
var
showRules
=
selectionAttr
.
split
(
"
|
"
)
;
var
anyMatched
=
false
;
function
metaDataNodeMatches
(
metaDataNode
rules
)
{
for
(
var
i
=
0
;
i
<
rules
.
length
;
i
+
+
)
{
if
(
rules
[
i
]
in
metaDataNode
)
return
true
;
}
return
false
;
}
for
(
var
i
=
0
;
i
<
aMetaData
.
length
;
+
+
i
)
{
if
(
metaDataNodeMatches
(
aMetaData
[
i
]
showRules
)
)
anyMatched
=
true
;
else
return
false
;
}
return
anyMatched
;
}
buildContextMenu
:
function
PC_buildContextMenu
(
aPopup
)
{
var
metadata
=
this
.
_buildSelectionMetadata
(
)
;
var
ip
=
this
.
_view
.
insertionPoint
;
var
noIp
=
!
ip
|
|
ip
.
isTag
;
var
separator
=
null
;
var
visibleItemsBeforeSep
=
false
;
var
usableItemCount
=
0
;
for
(
var
i
=
0
;
i
<
aPopup
.
children
.
length
;
+
+
i
)
{
var
item
=
aPopup
.
children
[
i
]
;
if
(
item
.
getAttribute
(
"
ignoreitem
"
)
=
=
"
true
"
)
{
continue
;
}
if
(
item
.
localName
!
=
"
menuseparator
"
)
{
var
hideIfNoIP
=
item
.
getAttribute
(
"
hideifnoinsertionpoint
"
)
=
=
"
true
"
&
&
noIp
&
&
!
(
ip
&
&
ip
.
isTag
&
&
item
.
id
=
=
"
placesContext_paste
"
)
;
var
hideIfPrivate
=
item
.
getAttribute
(
"
hideifprivatebrowsing
"
)
=
=
"
true
"
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
var
shouldHideItem
=
hideIfNoIP
|
|
hideIfPrivate
|
|
!
this
.
_shouldShowMenuItem
(
item
metadata
)
;
item
.
hidden
=
item
.
disabled
=
shouldHideItem
;
if
(
!
item
.
hidden
)
{
visibleItemsBeforeSep
=
true
;
usableItemCount
+
+
;
if
(
separator
)
{
separator
.
hidden
=
false
;
separator
=
null
;
}
}
}
else
{
item
.
hidden
=
true
;
if
(
visibleItemsBeforeSep
)
separator
=
item
;
visibleItemsBeforeSep
=
false
;
}
}
if
(
usableItemCount
>
0
)
{
var
openContainerInTabsItem
=
document
.
getElementById
(
"
placesContext_openContainer
:
tabs
"
)
;
if
(
!
openContainerInTabsItem
.
hidden
)
{
var
containerToUse
=
this
.
_view
.
selectedNode
|
|
this
.
_view
.
result
.
root
;
if
(
PlacesUtils
.
nodeIsContainer
(
containerToUse
)
)
{
if
(
!
PlacesUtils
.
hasChildURIs
(
containerToUse
)
)
{
openContainerInTabsItem
.
disabled
=
true
;
usableItemCount
-
-
;
}
}
}
}
let
stringId
=
metadata
.
length
=
=
=
1
?
"
SinglePage
"
:
"
MultiplePages
"
;
let
deleteHistoryItem
=
document
.
getElementById
(
"
placesContext_delete_history
"
)
;
deleteHistoryItem
.
label
=
PlacesUIUtils
.
getString
(
cmd
.
delete
{
stringId
}
.
label
)
;
deleteHistoryItem
.
accessKey
=
PlacesUIUtils
.
getString
(
cmd
.
delete
{
stringId
}
.
accesskey
)
;
let
createBookmarkItem
=
document
.
getElementById
(
"
placesContext_createBookmark
"
)
;
createBookmarkItem
.
label
=
PlacesUIUtils
.
getString
(
cmd
.
bookmark
{
stringId
}
.
label
)
;
createBookmarkItem
.
accessKey
=
PlacesUIUtils
.
getString
(
cmd
.
bookmark
{
stringId
}
.
accesskey
)
;
return
usableItemCount
>
0
;
}
selectAll
:
function
PC_selectAll
(
)
{
this
.
_view
.
selectAll
(
)
;
}
showBookmarkPropertiesForSelection
(
)
{
let
node
=
this
.
_view
.
selectedNode
;
if
(
!
node
)
return
;
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
edit
"
node
hiddenRows
:
[
"
folderPicker
"
]
}
window
.
top
)
;
}
openSelectionInTabs
:
function
PC_openLinksInTabs
(
aEvent
)
{
var
node
=
this
.
_view
.
selectedNode
;
var
nodes
=
this
.
_view
.
selectedNodes
;
if
(
!
node
&
&
!
nodes
.
length
)
{
node
=
this
.
_view
.
result
.
root
;
}
PlacesUIUtils
.
openMultipleLinksInTabs
(
node
?
node
:
nodes
aEvent
this
.
_view
)
;
}
async
newItem
(
aType
)
{
let
ip
=
this
.
_view
.
insertionPoint
;
if
(
!
ip
)
throw
Cr
.
NS_ERROR_NOT_AVAILABLE
;
let
bookmarkGuid
=
PlacesUIUtils
.
showBookmarkDialog
(
{
action
:
"
add
"
type
:
aType
defaultInsertionPoint
:
ip
hiddenRows
:
[
"
folderPicker
"
]
}
window
.
top
)
;
if
(
bookmarkGuid
)
{
this
.
_view
.
selectItems
(
[
bookmarkGuid
]
false
)
;
}
}
async
newSeparator
(
)
{
var
ip
=
this
.
_view
.
insertionPoint
;
if
(
!
ip
)
throw
Cr
.
NS_ERROR_NOT_AVAILABLE
;
let
index
=
await
ip
.
getIndex
(
)
;
let
txn
=
PlacesTransactions
.
NewSeparator
(
{
parentGuid
:
ip
.
guid
index
}
)
;
let
guid
=
await
txn
.
transact
(
)
;
this
.
_view
.
selectItems
(
[
guid
]
false
)
;
}
async
sortFolderByName
(
)
{
let
guid
=
PlacesUtils
.
getConcreteItemGuid
(
this
.
_view
.
selectedNode
)
;
await
PlacesTransactions
.
SortByName
(
guid
)
.
transact
(
)
;
}
_shouldSkipNode
:
function
PC_shouldSkipNode
(
node
pastFolders
)
{
function
isNodeContainedBy
(
parent
)
{
var
cursor
=
node
.
parent
;
while
(
cursor
)
{
if
(
cursor
=
=
parent
)
return
true
;
cursor
=
cursor
.
parent
;
}
return
false
;
}
for
(
var
j
=
0
;
j
<
pastFolders
.
length
;
+
+
j
)
{
if
(
isNodeContainedBy
(
pastFolders
[
j
]
)
)
return
true
;
}
return
false
;
}
async
_removeRange
(
range
transactions
removedFolders
)
{
if
(
!
(
transactions
instanceof
Array
)
)
throw
new
Error
(
"
Must
pass
a
transactions
array
"
)
;
if
(
!
removedFolders
)
removedFolders
=
[
]
;
let
bmGuidsToRemove
=
[
]
;
let
totalItems
=
0
;
for
(
var
i
=
0
;
i
<
range
.
length
;
+
+
i
)
{
var
node
=
range
[
i
]
;
if
(
this
.
_shouldSkipNode
(
node
removedFolders
)
)
continue
;
totalItems
+
+
;
if
(
PlacesUtils
.
nodeIsTagQuery
(
node
.
parent
)
)
{
let
tag
=
node
.
parent
.
title
|
|
"
"
;
if
(
!
tag
)
{
tag
=
node
.
parent
.
query
.
tags
[
0
]
;
}
transactions
.
push
(
PlacesTransactions
.
Untag
(
{
urls
:
[
node
.
uri
]
tag
}
)
)
;
}
else
if
(
PlacesUtils
.
nodeIsTagQuery
(
node
)
&
&
node
.
parent
&
&
PlacesUtils
.
nodeIsQuery
(
node
.
parent
)
&
&
PlacesUtils
.
asQuery
(
node
.
parent
)
.
queryOptions
.
resultType
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAGS_ROOT
)
{
let
tag
=
node
.
title
;
let
urls
=
new
Set
(
)
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
tags
:
[
tag
]
}
b
=
>
urls
.
add
(
b
.
url
)
)
;
transactions
.
push
(
PlacesTransactions
.
Untag
(
{
tag
urls
:
Array
.
from
(
urls
)
}
)
)
;
}
else
if
(
PlacesUtils
.
nodeIsURI
(
node
)
&
&
PlacesUtils
.
nodeIsQuery
(
node
.
parent
)
&
&
PlacesUtils
.
asQuery
(
node
.
parent
)
.
queryOptions
.
queryType
=
=
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_HISTORY
)
{
await
PlacesUtils
.
history
.
remove
(
node
.
uri
)
.
catch
(
Cu
.
reportError
)
;
}
else
if
(
node
.
itemId
=
=
-
1
&
&
PlacesUtils
.
nodeIsQuery
(
node
)
&
&
PlacesUtils
.
asQuery
(
node
)
.
queryOptions
.
queryType
=
=
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_HISTORY
)
{
await
this
.
_removeHistoryContainer
(
node
)
.
catch
(
Cu
.
reportError
)
;
}
else
{
if
(
PlacesUtils
.
nodeIsFolder
(
node
)
)
{
removedFolders
.
push
(
node
)
;
}
bmGuidsToRemove
.
push
(
node
.
bookmarkGuid
)
;
}
}
if
(
bmGuidsToRemove
.
length
)
{
transactions
.
push
(
PlacesTransactions
.
Remove
(
{
guids
:
bmGuidsToRemove
}
)
)
;
}
return
totalItems
;
}
async
_removeRowsFromBookmarks
(
)
{
let
ranges
=
this
.
_view
.
removableSelectionRanges
;
let
transactions
=
[
]
;
let
removedFolders
=
[
]
;
let
totalItems
=
0
;
for
(
let
range
of
ranges
)
{
totalItems
+
=
await
this
.
_removeRange
(
range
transactions
removedFolders
)
;
}
if
(
transactions
.
length
>
0
)
{
await
PlacesUIUtils
.
batchUpdatesForNode
(
this
.
_view
.
result
totalItems
async
(
)
=
>
{
await
PlacesTransactions
.
batch
(
transactions
)
;
}
)
;
}
}
async
_removeRowsFromHistory
(
)
{
let
nodes
=
this
.
_view
.
selectedNodes
;
let
URIs
=
new
Set
(
)
;
for
(
let
i
=
0
;
i
<
nodes
.
length
;
+
+
i
)
{
let
node
=
nodes
[
i
]
;
if
(
PlacesUtils
.
nodeIsURI
(
node
)
)
{
URIs
.
add
(
node
.
uri
)
;
}
else
if
(
PlacesUtils
.
nodeIsQuery
(
node
)
&
&
PlacesUtils
.
asQuery
(
node
)
.
queryOptions
.
queryType
=
=
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_HISTORY
)
{
await
this
.
_removeHistoryContainer
(
node
)
.
catch
(
Cu
.
reportError
)
;
}
}
if
(
URIs
.
size
)
{
await
PlacesUtils
.
history
.
remove
(
[
.
.
.
URIs
]
)
;
}
}
async
_removeHistoryContainer
(
aContainerNode
)
{
if
(
PlacesUtils
.
nodeIsHost
(
aContainerNode
)
)
{
let
host
=
"
.
"
+
(
aContainerNode
.
title
=
=
PlacesUtils
.
getString
(
"
localhost
"
)
?
"
"
:
aContainerNode
.
title
)
;
await
PlacesUtils
.
history
.
removeByFilter
(
{
host
}
)
;
}
else
if
(
PlacesUtils
.
nodeIsDay
(
aContainerNode
)
)
{
let
query
=
aContainerNode
.
query
;
let
beginTime
=
query
.
beginTime
;
let
endTime
=
query
.
endTime
;
if
(
!
query
|
|
!
beginTime
|
|
!
endTime
)
throw
new
Error
(
"
A
valid
date
container
query
should
exist
!
"
)
;
await
PlacesUtils
.
history
.
removeByFilter
(
{
beginDate
:
PlacesUtils
.
toDate
(
beginTime
+
1000
)
endDate
:
PlacesUtils
.
toDate
(
endTime
)
}
)
;
}
}
async
remove
(
)
{
if
(
!
this
.
_hasRemovableSelection
(
)
)
return
;
var
root
=
this
.
_view
.
result
.
root
;
if
(
PlacesUtils
.
nodeIsFolder
(
root
)
)
{
await
this
.
_removeRowsFromBookmarks
(
)
;
}
else
if
(
PlacesUtils
.
nodeIsQuery
(
root
)
)
{
var
queryType
=
PlacesUtils
.
asQuery
(
root
)
.
queryOptions
.
queryType
;
if
(
queryType
=
=
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_BOOKMARKS
)
{
await
this
.
_removeRowsFromBookmarks
(
)
;
}
else
if
(
queryType
=
=
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_HISTORY
)
{
await
this
.
_removeRowsFromHistory
(
)
;
}
else
{
throw
new
Error
(
"
implement
support
for
QUERY_TYPE_UNIFIED
"
)
;
}
}
else
{
throw
new
Error
(
"
unexpected
root
"
)
;
}
}
setDataTransfer
:
function
PC_setDataTransfer
(
aEvent
)
{
let
dt
=
aEvent
.
dataTransfer
;
let
result
=
this
.
_view
.
result
;
let
didSuppressNotifications
=
result
.
suppressNotifications
;
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
true
;
function
addData
(
type
index
)
{
let
wrapNode
=
PlacesUtils
.
wrapNode
(
node
type
)
;
dt
.
mozSetDataAt
(
type
wrapNode
index
)
;
}
function
addURIData
(
index
)
{
addData
(
PlacesUtils
.
TYPE_X_MOZ_URL
index
)
;
addData
(
PlacesUtils
.
TYPE_UNICODE
index
)
;
addData
(
PlacesUtils
.
TYPE_HTML
index
)
;
}
try
{
let
nodes
=
this
.
_view
.
draggableSelection
;
for
(
let
i
=
0
;
i
<
nodes
.
length
;
+
+
i
)
{
var
node
=
nodes
[
i
]
;
addData
(
PlacesUtils
.
TYPE_X_MOZ_PLACE
i
)
;
if
(
node
.
uri
)
{
addURIData
(
i
)
;
}
}
}
finally
{
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
false
;
}
}
get
clipboardAction
(
)
{
let
action
=
{
}
;
let
actionOwner
;
try
{
let
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
null
)
;
xferable
.
addDataFlavor
(
PlacesUtils
.
TYPE_X_MOZ_PLACE_ACTION
)
;
this
.
clipboard
.
getData
(
xferable
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
xferable
.
getTransferData
(
PlacesUtils
.
TYPE_X_MOZ_PLACE_ACTION
action
)
;
[
action
actionOwner
]
=
action
.
value
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
.
split
(
"
"
)
;
}
catch
(
ex
)
{
return
"
copy
"
;
}
if
(
action
=
=
"
cut
"
&
&
actionOwner
!
=
this
.
profileName
)
action
=
"
copy
"
;
return
action
;
}
_releaseClipboardOwnership
:
function
PC__releaseClipboardOwnership
(
)
{
if
(
this
.
cutNodes
.
length
>
0
)
{
this
.
clipboard
.
emptyClipboard
(
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
}
}
_clearClipboard
:
function
PC__clearClipboard
(
)
{
let
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
null
)
;
const
TYPE
=
"
text
/
x
-
moz
-
place
-
empty
"
;
xferable
.
addDataFlavor
(
TYPE
)
;
xferable
.
setTransferData
(
TYPE
PlacesUtils
.
toISupportsString
(
"
"
)
0
)
;
this
.
clipboard
.
setData
(
xferable
null
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
}
_populateClipboard
:
function
PC__populateClipboard
(
aNodes
aAction
)
{
let
contents
=
[
{
type
:
PlacesUtils
.
TYPE_X_MOZ_PLACE
entries
:
[
]
}
{
type
:
PlacesUtils
.
TYPE_X_MOZ_URL
entries
:
[
]
}
{
type
:
PlacesUtils
.
TYPE_HTML
entries
:
[
]
}
{
type
:
PlacesUtils
.
TYPE_UNICODE
entries
:
[
]
}
]
;
let
copiedFolders
=
[
]
;
aNodes
.
forEach
(
function
(
node
)
{
if
(
this
.
_shouldSkipNode
(
node
copiedFolders
)
)
return
;
if
(
PlacesUtils
.
nodeIsFolder
(
node
)
)
copiedFolders
.
push
(
node
)
;
contents
.
forEach
(
function
(
content
)
{
content
.
entries
.
push
(
PlacesUtils
.
wrapNode
(
node
content
.
type
)
)
;
}
)
;
}
this
)
;
function
addData
(
type
data
)
{
xferable
.
addDataFlavor
(
type
)
;
xferable
.
setTransferData
(
type
PlacesUtils
.
toISupportsString
(
data
)
data
.
length
*
2
)
;
}
let
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
null
)
;
let
hasData
=
false
;
contents
.
forEach
(
function
(
content
)
{
if
(
content
.
entries
.
length
>
0
)
{
hasData
=
true
;
let
glue
=
content
.
type
=
=
PlacesUtils
.
TYPE_X_MOZ_PLACE
?
"
"
:
PlacesUtils
.
endl
;
addData
(
content
.
type
content
.
entries
.
join
(
glue
)
)
;
}
}
)
;
addData
(
PlacesUtils
.
TYPE_X_MOZ_PLACE_ACTION
aAction
+
"
"
+
this
.
profileName
)
;
if
(
hasData
)
{
this
.
clipboard
.
setData
(
xferable
aAction
=
=
"
cut
"
?
this
:
null
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
}
}
_cutNodes
:
[
]
get
cutNodes
(
)
{
return
this
.
_cutNodes
;
}
set
cutNodes
(
aNodes
)
{
let
self
=
this
;
function
updateCutNodes
(
aValue
)
{
self
.
_cutNodes
.
forEach
(
function
(
aNode
)
{
self
.
_view
.
toggleCutNode
(
aNode
aValue
)
;
}
)
;
}
updateCutNodes
(
false
)
;
this
.
_cutNodes
=
aNodes
;
updateCutNodes
(
true
)
;
return
aNodes
;
}
copy
:
function
PC_copy
(
)
{
let
result
=
this
.
_view
.
result
;
let
didSuppressNotifications
=
result
.
suppressNotifications
;
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
true
;
try
{
this
.
_populateClipboard
(
this
.
_view
.
selectedNodes
"
copy
"
)
;
}
finally
{
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
false
;
}
}
cut
:
function
PC_cut
(
)
{
let
result
=
this
.
_view
.
result
;
let
didSuppressNotifications
=
result
.
suppressNotifications
;
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
true
;
try
{
this
.
_populateClipboard
(
this
.
_view
.
selectedNodes
"
cut
"
)
;
this
.
cutNodes
=
this
.
_view
.
selectedNodes
;
}
finally
{
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
false
;
}
}
async
paste
(
)
{
let
ip
=
this
.
_view
.
insertionPoint
;
if
(
!
ip
)
throw
Cr
.
NS_ERROR_NOT_AVAILABLE
;
let
action
=
this
.
clipboardAction
;
let
xferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
xferable
.
init
(
null
)
;
[
PlacesUtils
.
TYPE_X_MOZ_PLACE
PlacesUtils
.
TYPE_X_MOZ_URL
PlacesUtils
.
TYPE_UNICODE
]
.
forEach
(
type
=
>
xferable
.
addDataFlavor
(
type
)
)
;
this
.
clipboard
.
getData
(
xferable
Ci
.
nsIClipboard
.
kGlobalClipboard
)
;
let
data
=
{
}
type
=
{
}
items
=
[
]
;
try
{
xferable
.
getAnyTransferData
(
type
data
)
;
data
=
data
.
value
.
QueryInterface
(
Ci
.
nsISupportsString
)
.
data
;
type
=
type
.
value
;
items
=
PlacesUtils
.
unwrapNodes
(
data
type
)
;
}
catch
(
ex
)
{
return
;
}
let
doCopy
=
action
=
=
"
copy
"
;
let
itemsToSelect
=
await
PlacesUIUtils
.
handleTransferItems
(
items
ip
doCopy
this
.
_view
)
;
if
(
action
=
=
"
cut
"
)
{
this
.
_clearClipboard
(
)
;
}
if
(
itemsToSelect
.
length
>
0
)
this
.
_view
.
selectItems
(
itemsToSelect
false
)
;
}
disallowInsertion
(
container
)
{
if
(
!
container
)
throw
new
Error
(
"
empty
container
"
)
;
return
!
PlacesUtils
.
nodeIsTagQuery
(
container
)
&
&
(
!
PlacesUtils
.
nodeIsFolder
(
container
)
|
|
PlacesUIUtils
.
isFolderReadOnly
(
container
)
)
;
}
canMoveNode
(
node
)
{
if
(
node
.
itemId
=
=
-
1
)
return
false
;
let
parentNode
=
node
.
parent
;
return
parentNode
!
=
null
&
&
PlacesUtils
.
nodeIsFolder
(
parentNode
)
&
&
!
PlacesUIUtils
.
isFolderReadOnly
(
parentNode
)
&
&
!
PlacesUtils
.
nodeIsTagQuery
(
parentNode
)
;
}
}
;
var
PlacesControllerDragHelper
=
{
currentDropTarget
:
null
draggingOverChildNode
:
function
PCDH_draggingOverChildNode
(
node
)
{
let
currentNode
=
this
.
currentDropTarget
;
while
(
currentNode
)
{
if
(
currentNode
=
=
node
)
return
true
;
currentNode
=
currentNode
.
parentNode
;
}
return
false
;
}
getSession
:
function
PCDH__getSession
(
)
{
return
this
.
dragService
.
getCurrentSession
(
)
;
}
getFirstValidFlavor
:
function
PCDH_getFirstValidFlavor
(
aFlavors
)
{
for
(
let
i
=
0
;
i
<
aFlavors
.
length
;
i
+
+
)
{
if
(
PlacesUIUtils
.
SUPPORTED_FLAVORS
.
includes
(
aFlavors
[
i
]
)
)
return
aFlavors
[
i
]
;
}
if
(
aFlavors
.
contains
(
"
text
/
plain
"
)
)
{
return
PlacesUtils
.
TYPE_UNICODE
;
}
return
null
;
}
canDrop
:
function
PCDH_canDrop
(
ip
dt
)
{
let
dropCount
=
dt
.
mozItemCount
;
for
(
let
i
=
0
;
i
<
dropCount
;
i
+
+
)
{
let
flavor
=
this
.
getFirstValidFlavor
(
dt
.
mozTypesAt
(
i
)
)
;
if
(
!
flavor
)
return
false
;
if
(
flavor
=
=
TAB_DROP_TYPE
)
continue
;
let
data
=
dt
.
mozGetDataAt
(
flavor
i
)
;
let
nodes
;
try
{
nodes
=
PlacesUtils
.
unwrapNodes
(
data
flavor
)
;
}
catch
(
e
)
{
return
false
;
}
for
(
let
dragged
of
nodes
)
{
if
(
ip
.
isTag
&
&
dragged
.
type
!
=
PlacesUtils
.
TYPE_X_MOZ_URL
&
&
(
dragged
.
type
!
=
PlacesUtils
.
TYPE_X_MOZ_PLACE
|
|
(
dragged
.
uri
&
&
dragged
.
uri
.
startsWith
(
"
place
:
"
)
)
)
)
return
false
;
if
(
dragged
.
type
=
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
|
|
(
dragged
.
uri
&
&
dragged
.
uri
.
startsWith
(
"
place
:
"
)
)
)
{
let
parentId
=
ip
.
itemId
;
while
(
parentId
!
=
PlacesUtils
.
placesRootId
)
{
if
(
dragged
.
concreteId
=
=
parentId
|
|
dragged
.
id
=
=
parentId
)
return
false
;
parentId
=
PlacesUtils
.
bookmarks
.
getFolderIdForItem
(
parentId
)
;
}
}
}
}
return
true
;
}
async
onDrop
(
insertionPoint
dt
view
)
{
let
doCopy
=
[
"
copy
"
"
link
"
]
.
includes
(
dt
.
dropEffect
)
;
let
dropCount
=
dt
.
mozItemCount
;
let
duplicable
=
new
Map
(
)
;
duplicable
.
set
(
PlacesUtils
.
TYPE_UNICODE
new
Set
(
)
)
;
duplicable
.
set
(
PlacesUtils
.
TYPE_X_MOZ_URL
new
Set
(
)
)
;
let
nodes
=
[
]
;
for
(
let
i
=
0
;
i
<
dropCount
;
+
+
i
)
{
let
flavor
=
this
.
getFirstValidFlavor
(
dt
.
mozTypesAt
(
i
)
)
;
if
(
!
flavor
)
return
;
let
data
=
dt
.
mozGetDataAt
(
flavor
i
)
;
if
(
duplicable
.
has
(
flavor
)
)
{
let
handled
=
duplicable
.
get
(
flavor
)
;
if
(
handled
.
has
(
data
)
)
continue
;
handled
.
add
(
data
)
;
}
if
(
flavor
!
=
TAB_DROP_TYPE
)
{
nodes
=
[
.
.
.
nodes
.
.
.
PlacesUtils
.
unwrapNodes
(
data
flavor
)
]
;
}
else
if
(
data
instanceof
XULElement
&
&
data
.
localName
=
=
"
tab
"
&
&
data
.
ownerGlobal
.
isChromeWindow
)
{
let
uri
=
data
.
linkedBrowser
.
currentURI
;
let
spec
=
uri
?
uri
.
spec
:
"
about
:
blank
"
;
nodes
.
push
(
{
uri
:
spec
title
:
data
.
label
type
:
PlacesUtils
.
TYPE_X_MOZ_URL
}
)
;
}
else
{
throw
new
Error
(
"
bogus
data
was
passed
as
a
tab
"
)
;
}
}
await
PlacesUIUtils
.
handleTransferItems
(
nodes
insertionPoint
doCopy
view
)
;
}
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
PlacesControllerDragHelper
"
dragService
"
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
"
nsIDragService
"
)
;
