{
class
MozPlacesTree
extends
customElements
.
get
(
"
tree
"
)
{
constructor
(
)
{
super
(
)
;
this
.
addEventListener
(
"
focus
"
event
=
>
{
this
.
_cachedInsertionPoint
=
undefined
;
document
.
commandDispatcher
.
updateCommands
(
"
focus
"
)
;
}
)
;
this
.
addEventListener
(
"
select
"
event
=
>
{
this
.
_cachedInsertionPoint
=
undefined
;
var
win
=
window
;
while
(
true
)
{
win
.
document
.
commandDispatcher
.
updateCommands
(
"
focus
"
)
;
if
(
win
=
=
window
.
top
)
{
break
;
}
win
=
win
.
parent
;
}
}
)
;
this
.
addEventListener
(
"
dragstart
"
event
=
>
{
if
(
event
.
target
.
localName
!
=
"
treechildren
"
)
{
return
;
}
if
(
this
.
disableUserActions
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
let
nodes
=
this
.
selectedNodes
;
for
(
let
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
let
node
=
nodes
[
i
]
;
if
(
!
node
.
parent
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
if
(
!
this
.
controller
.
canMoveNode
(
node
)
)
{
event
.
dataTransfer
.
effectAllowed
=
"
copyLink
"
;
break
;
}
}
this
.
_controller
.
setDataTransfer
(
event
)
;
event
.
stopPropagation
(
)
;
}
)
;
this
.
addEventListener
(
"
dragover
"
event
=
>
{
if
(
event
.
target
.
localName
!
=
"
treechildren
"
)
{
return
;
}
let
cell
=
this
.
getCellAt
(
event
.
clientX
event
.
clientY
)
;
let
node
=
cell
.
row
!
=
-
1
?
this
.
view
.
nodeForTreeIndex
(
cell
.
row
)
:
this
.
result
.
root
;
PlacesControllerDragHelper
.
currentDropTarget
=
node
;
let
rowHeight
=
this
.
rowHeight
;
let
eventY
=
event
.
clientY
-
this
.
treeBody
.
getBoundingClientRect
(
)
.
y
-
rowHeight
*
(
cell
.
row
-
this
.
getFirstVisibleRow
(
)
)
;
let
orientation
=
Ci
.
nsITreeView
.
DROP_BEFORE
;
if
(
cell
.
row
=
=
-
1
)
{
orientation
=
Ci
.
nsITreeView
.
DROP_ON
;
}
else
if
(
PlacesUtils
.
nodeIsContainer
(
node
)
&
&
eventY
>
rowHeight
*
0
.
75
)
{
orientation
=
Ci
.
nsITreeView
.
DROP_AFTER
;
}
else
if
(
PlacesUtils
.
nodeIsContainer
(
node
)
&
&
eventY
>
rowHeight
*
0
.
25
)
{
orientation
=
Ci
.
nsITreeView
.
DROP_ON
;
}
if
(
!
this
.
view
.
canDrop
(
cell
.
row
orientation
event
.
dataTransfer
)
)
{
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
)
;
this
.
addEventListener
(
"
dragend
"
event
=
>
{
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
}
)
;
}
connectedCallback
(
)
{
if
(
this
.
delayConnectedCallback
(
)
)
{
return
;
}
super
.
connectedCallback
(
)
;
this
.
_contextMenuShown
=
false
;
this
.
_active
=
true
;
if
(
this
.
place
)
{
this
.
place
=
this
.
place
;
}
}
get
controller
(
)
{
return
this
.
_controller
;
}
set
disableUserActions
(
val
)
{
if
(
val
)
{
this
.
setAttribute
(
"
disableUserActions
"
"
true
"
)
;
}
else
{
this
.
removeAttribute
(
"
disableUserActions
"
)
;
}
}
get
disableUserActions
(
)
{
return
this
.
getAttribute
(
"
disableUserActions
"
)
=
=
"
true
"
;
}
set
view
(
val
)
{
this
.
_view
=
val
;
Object
.
getOwnPropertyDescriptor
(
XULTreeElement
.
prototype
"
view
"
)
.
set
.
call
(
this
val
)
;
}
get
view
(
)
{
return
this
.
_view
;
}
get
associatedElement
(
)
{
return
this
;
}
set
flatList
(
val
)
{
if
(
this
.
flatList
!
=
val
)
{
this
.
setAttribute
(
"
flatList
"
val
)
;
if
(
this
.
place
)
{
this
.
place
=
this
.
place
;
}
}
}
get
flatList
(
)
{
return
this
.
getAttribute
(
"
flatList
"
)
=
=
"
true
"
;
}
get
result
(
)
{
try
{
return
this
.
view
.
QueryInterface
(
Ci
.
nsINavHistoryResultObserver
)
.
result
;
}
catch
(
e
)
{
return
null
;
}
}
set
place
(
val
)
{
this
.
setAttribute
(
"
place
"
val
)
;
let
query
=
{
}
options
=
{
}
;
PlacesUtils
.
history
.
queryStringToQuery
(
val
query
options
)
;
this
.
load
(
query
.
value
options
.
value
)
;
}
get
place
(
)
{
return
this
.
getAttribute
(
"
place
"
)
;
}
get
hasSelection
(
)
{
return
this
.
view
&
&
this
.
view
.
selection
.
count
>
=
1
;
}
get
selectedNodes
(
)
{
let
nodes
=
[
]
;
if
(
!
this
.
hasSelection
)
{
return
nodes
;
}
let
selection
=
this
.
view
.
selection
;
let
rc
=
selection
.
getRangeCount
(
)
;
let
resultview
=
this
.
view
;
for
(
let
i
=
0
;
i
<
rc
;
+
+
i
)
{
let
min
=
{
}
max
=
{
}
;
selection
.
getRangeAt
(
i
min
max
)
;
for
(
let
j
=
min
.
value
;
j
<
=
max
.
value
;
+
+
j
)
{
nodes
.
push
(
resultview
.
nodeForTreeIndex
(
j
)
)
;
}
}
return
nodes
;
}
get
removableSelectionRanges
(
)
{
let
nodes
=
[
]
;
if
(
!
this
.
hasSelection
)
{
return
nodes
;
}
var
selection
=
this
.
view
.
selection
;
var
rc
=
selection
.
getRangeCount
(
)
;
var
resultview
=
this
.
view
;
var
containers
=
{
}
;
for
(
var
i
=
0
;
i
<
rc
;
+
+
i
)
{
var
range
=
[
]
;
var
min
=
{
}
max
=
{
}
;
selection
.
getRangeAt
(
i
min
max
)
;
for
(
var
j
=
min
.
value
;
j
<
=
max
.
value
;
+
+
j
)
{
if
(
this
.
view
.
isContainer
(
j
)
)
{
containers
[
j
]
=
true
;
}
if
(
!
(
this
.
view
.
getParentIndex
(
j
)
in
containers
)
)
{
range
.
push
(
resultview
.
nodeForTreeIndex
(
j
)
)
;
}
}
nodes
.
push
(
range
)
;
}
return
nodes
;
}
get
draggableSelection
(
)
{
return
this
.
selectedNodes
;
}
get
selectedNode
(
)
{
var
view
=
this
.
view
;
if
(
!
view
|
|
view
.
selection
.
count
!
=
1
)
{
return
null
;
}
var
selection
=
view
.
selection
;
var
min
=
{
}
max
=
{
}
;
selection
.
getRangeAt
(
0
min
max
)
;
return
this
.
view
.
nodeForTreeIndex
(
min
.
value
)
;
}
get
singleClickOpens
(
)
{
return
this
.
getAttribute
(
"
singleclickopens
"
)
=
=
"
true
"
;
}
get
insertionPoint
(
)
{
if
(
this
.
_cachedInsertionPoint
!
=
=
undefined
)
{
return
this
.
_cachedInsertionPoint
;
}
var
resultNode
=
this
.
result
.
root
;
if
(
PlacesUtils
.
nodeIsQuery
(
resultNode
)
&
&
PlacesUtils
.
asQuery
(
resultNode
)
.
queryOptions
.
queryType
=
=
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_HISTORY
)
{
return
(
this
.
_cachedInsertionPoint
=
null
)
;
}
var
orientation
=
Ci
.
nsITreeView
.
DROP_BEFORE
;
if
(
!
this
.
hasSelection
)
{
var
index
=
this
.
view
.
rowCount
-
1
;
this
.
_cachedInsertionPoint
=
this
.
_getInsertionPoint
(
index
orientation
)
;
return
this
.
_cachedInsertionPoint
;
}
var
resultView
=
this
.
view
;
var
selection
=
resultView
.
selection
;
var
rc
=
selection
.
getRangeCount
(
)
;
var
min
=
{
}
max
=
{
}
;
selection
.
getRangeAt
(
rc
-
1
min
max
)
;
if
(
selection
.
count
=
=
1
&
&
resultView
.
isContainer
(
max
.
value
)
&
&
!
this
.
flatList
)
{
orientation
=
Ci
.
nsITreeView
.
DROP_ON
;
}
this
.
_cachedInsertionPoint
=
this
.
_getInsertionPoint
(
max
.
value
orientation
)
;
return
this
.
_cachedInsertionPoint
;
}
get
ownerWindow
(
)
{
return
window
;
}
set
active
(
val
)
{
this
.
_active
=
val
;
}
get
active
(
)
{
return
this
.
_active
;
}
applyFilter
(
filterString
folderRestrict
includeHidden
)
{
var
queryNode
=
PlacesUtils
.
asQuery
(
this
.
result
.
root
)
;
var
options
=
queryNode
.
queryOptions
.
clone
(
)
;
if
(
PlacesUtils
.
nodeIsHistoryContainer
(
queryNode
)
|
|
PlacesUtils
.
nodeIsTagQuery
(
queryNode
)
|
|
options
.
resultType
=
=
options
.
RESULTS_AS_TAGS_ROOT
|
|
options
.
resultType
=
=
options
.
RESULTS_AS_ROOTS_QUERY
)
{
options
.
resultType
=
options
.
RESULTS_AS_URI
;
}
var
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
query
.
searchTerms
=
filterString
;
if
(
folderRestrict
)
{
query
.
setParents
(
folderRestrict
)
;
options
.
queryType
=
options
.
QUERY_TYPE_BOOKMARKS
;
Services
.
telemetry
.
keyedScalarAdd
(
"
sidebar
.
search
"
"
bookmarks
"
1
)
;
}
options
.
includeHidden
=
!
!
includeHidden
;
this
.
load
(
query
options
)
;
}
load
(
query
options
)
{
let
result
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
;
if
(
!
this
.
_controller
)
{
this
.
_controller
=
new
PlacesController
(
this
)
;
this
.
_controller
.
disableUserActions
=
this
.
disableUserActions
;
this
.
controllers
.
appendController
(
this
.
_controller
)
;
}
let
treeView
=
new
PlacesTreeView
(
this
)
;
result
.
addObserver
(
treeView
)
;
this
.
view
=
treeView
;
if
(
this
.
getAttribute
(
"
selectfirstnode
"
)
=
=
"
true
"
&
&
treeView
.
rowCount
>
0
)
{
treeView
.
selection
.
select
(
0
)
;
}
this
.
_cachedInsertionPoint
=
undefined
;
}
selectPlaceURI
(
placeURI
)
{
if
(
this
.
hasSelection
&
&
this
.
selectedNode
.
uri
=
=
placeURI
)
{
return
;
}
function
findNode
(
container
nodesURIChecked
)
{
var
containerURI
=
container
.
uri
;
if
(
containerURI
=
=
placeURI
)
{
return
container
;
}
if
(
nodesURIChecked
.
includes
(
containerURI
)
)
{
return
null
;
}
nodesURIChecked
.
push
(
containerURI
)
;
var
wasOpen
=
container
.
containerOpen
;
if
(
!
wasOpen
)
{
container
.
containerOpen
=
true
;
}
for
(
var
i
=
0
;
i
<
container
.
childCount
;
+
+
i
)
{
var
child
=
container
.
getChild
(
i
)
;
var
childURI
=
child
.
uri
;
if
(
childURI
=
=
placeURI
)
{
return
child
;
}
else
if
(
PlacesUtils
.
nodeIsContainer
(
child
)
)
{
var
nested
=
findNode
(
PlacesUtils
.
asContainer
(
child
)
nodesURIChecked
)
;
if
(
nested
)
{
return
nested
;
}
}
}
if
(
!
wasOpen
)
{
container
.
containerOpen
=
false
;
}
return
null
;
}
var
container
=
this
.
result
.
root
;
console
.
assert
(
container
"
No
result
cannot
select
place
URI
!
"
)
;
if
(
!
container
)
{
return
;
}
var
child
=
findNode
(
container
[
]
)
;
if
(
child
)
{
this
.
selectNode
(
child
)
;
}
else
{
var
selection
=
this
.
view
.
selection
;
selection
.
clearSelection
(
)
;
}
}
selectNode
(
node
)
{
var
view
=
this
.
view
;
var
parent
=
node
.
parent
;
if
(
parent
&
&
!
parent
.
containerOpen
)
{
var
parents
=
[
]
;
var
root
=
this
.
result
.
root
;
while
(
parent
&
&
parent
!
=
root
)
{
parents
.
push
(
parent
)
;
parent
=
parent
.
parent
;
}
for
(
var
i
=
parents
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
index
=
view
.
treeIndexForNode
(
parents
[
i
]
)
;
if
(
index
!
=
-
1
&
&
view
.
isContainer
(
index
)
&
&
!
view
.
isContainerOpen
(
index
)
)
{
view
.
toggleOpenState
(
index
)
;
}
}
}
let
index
=
view
.
treeIndexForNode
(
node
)
;
if
(
index
=
=
-
1
)
{
return
;
}
view
.
selection
.
select
(
index
)
;
this
.
ensureRowIsVisible
(
index
)
;
}
toggleCutNode
(
aNode
aValue
)
{
this
.
view
.
toggleCutNode
(
aNode
aValue
)
;
}
_getInsertionPoint
(
index
orientation
)
{
var
result
=
this
.
result
;
var
resultview
=
this
.
view
;
var
container
=
result
.
root
;
var
dropNearNode
=
null
;
console
.
assert
(
container
"
null
container
"
)
;
if
(
index
!
=
-
1
)
{
var
lastSelected
=
resultview
.
nodeForTreeIndex
(
index
)
;
if
(
resultview
.
isContainer
(
index
)
&
&
orientation
=
=
Ci
.
nsITreeView
.
DROP_ON
)
{
container
=
lastSelected
;
index
=
-
1
;
}
else
if
(
lastSelected
.
containerOpen
&
&
orientation
=
=
Ci
.
nsITreeView
.
DROP_AFTER
&
&
lastSelected
.
hasChildren
)
{
container
=
lastSelected
;
orientation
=
Ci
.
nsITreeView
.
DROP_ON
;
index
=
0
;
}
else
{
container
=
lastSelected
.
parent
;
if
(
!
container
|
|
!
container
.
containerOpen
)
{
return
null
;
}
if
(
this
.
controller
.
disallowInsertion
(
container
)
)
{
return
null
;
}
var
queryOptions
=
PlacesUtils
.
asQuery
(
result
.
root
)
.
queryOptions
;
if
(
queryOptions
.
sortingMode
!
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_NONE
)
{
index
=
-
1
;
}
else
if
(
queryOptions
.
excludeItems
|
|
queryOptions
.
excludeQueries
)
{
index
=
-
1
;
dropNearNode
=
lastSelected
;
}
else
{
var
lsi
=
container
.
getChildIndex
(
lastSelected
)
;
index
=
orientation
=
=
Ci
.
nsITreeView
.
DROP_BEFORE
?
lsi
:
lsi
+
1
;
}
}
}
if
(
this
.
controller
.
disallowInsertion
(
container
)
)
{
return
null
;
}
let
tagName
=
PlacesUtils
.
nodeIsTagQuery
(
container
)
?
PlacesUtils
.
asQuery
(
container
)
.
query
.
tags
[
0
]
:
null
;
return
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
container
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
container
)
index
orientation
tagName
dropNearNode
}
)
;
}
selectAll
(
)
{
this
.
view
.
selection
.
selectAll
(
)
;
}
selectItems
(
aGuids
aOpenContainers
)
{
if
(
this
.
flatList
)
{
aOpenContainers
=
false
;
}
if
(
aOpenContainers
=
=
=
undefined
)
{
aOpenContainers
=
true
;
}
var
guids
=
aGuids
;
var
nodes
=
[
]
;
var
nodesToOpen
=
[
]
;
var
checkedGuidsSet
=
new
Set
(
)
;
function
findNodes
(
node
)
{
var
foundOne
=
false
;
var
index
=
guids
.
indexOf
(
node
.
bookmarkGuid
)
;
if
(
index
=
=
-
1
)
{
let
concreteGuid
=
PlacesUtils
.
getConcreteItemGuid
(
node
)
;
if
(
concreteGuid
!
=
node
.
bookmarkGuid
)
{
index
=
guids
.
indexOf
(
concreteGuid
)
;
}
}
if
(
index
!
=
-
1
)
{
nodes
.
push
(
node
)
;
foundOne
=
true
;
guids
.
splice
(
index
1
)
;
}
var
concreteGuid
=
PlacesUtils
.
getConcreteItemGuid
(
node
)
;
if
(
!
guids
.
length
|
|
!
PlacesUtils
.
nodeIsContainer
(
node
)
|
|
checkedGuidsSet
.
has
(
concreteGuid
)
)
{
return
foundOne
;
}
let
shouldOpen
=
aOpenContainers
&
&
(
PlacesUtils
.
nodeIsFolder
(
node
)
|
|
(
PlacesUtils
.
nodeIsQuery
(
node
)
&
&
node
.
bookmarkGuid
=
=
PlacesUIUtils
.
virtualAllBookmarksGuid
)
)
;
PlacesUtils
.
asContainer
(
node
)
;
if
(
!
node
.
containerOpen
&
&
!
shouldOpen
)
{
return
foundOne
;
}
checkedGuidsSet
.
add
(
concreteGuid
)
;
var
previousOpenness
=
node
.
containerOpen
;
node
.
containerOpen
=
true
;
for
(
var
child
=
0
;
child
<
node
.
childCount
&
&
guids
.
length
;
child
+
+
)
{
var
childNode
=
node
.
getChild
(
child
)
;
var
found
=
findNodes
(
childNode
)
;
if
(
!
foundOne
)
{
foundOne
=
found
;
}
}
if
(
foundOne
)
{
nodesToOpen
.
unshift
(
node
)
;
}
node
.
containerOpen
=
previousOpenness
;
return
foundOne
;
}
let
result
=
this
.
result
;
let
didSuppressNotifications
=
result
.
suppressNotifications
;
if
(
!
didSuppressNotifications
)
{
result
.
suppressNotifications
=
true
;
}
try
{
findNodes
(
this
.
result
.
root
)
;
}
finally
{
if
(
!
didSuppressNotifications
)
{
result
.
suppressNotifications
=
false
;
}
}
var
resultview
=
this
.
view
;
var
selection
=
this
.
view
.
selection
;
selection
.
selectEventsSuppressed
=
true
;
selection
.
clearSelection
(
)
;
for
(
let
i
=
0
;
i
<
nodesToOpen
.
length
;
i
+
+
)
{
nodesToOpen
[
i
]
.
containerOpen
=
true
;
}
for
(
let
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
var
index
=
resultview
.
treeIndexForNode
(
nodes
[
i
]
)
;
if
(
index
=
=
-
1
)
{
continue
;
}
selection
.
rangedSelect
(
index
index
true
)
;
}
selection
.
selectEventsSuppressed
=
false
;
}
buildContextMenu
(
aPopup
)
{
this
.
_contextMenuShown
=
true
;
return
this
.
controller
.
buildContextMenu
(
aPopup
)
;
}
destroyContextMenu
(
aPopup
)
{
}
disconnectedCallback
(
)
{
if
(
this
.
_controller
)
{
this
.
_controller
.
terminate
(
)
;
this
.
controllers
.
removeController
(
this
.
_controller
)
;
}
if
(
this
.
view
)
{
this
.
view
.
uninit
(
)
;
}
this
.
view
=
null
;
}
}
customElements
.
define
(
"
places
-
tree
"
MozPlacesTree
{
extends
:
"
tree
"
}
)
;
}
