var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PlacesUIUtils
:
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
PlacesTransactions
:
"
resource
:
/
/
gre
/
modules
/
PlacesTransactions
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
PlacesTreeView
"
"
chrome
:
/
/
browser
/
content
/
places
/
treeView
.
js
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
[
"
PlacesInsertionPoint
"
"
PlacesController
"
"
PlacesControllerDragHelper
"
]
"
chrome
:
/
/
browser
/
content
/
places
/
controller
.
js
"
)
;
var
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MigrationUtils
"
"
resource
:
/
/
/
modules
/
MigrationUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BookmarkJSONUtils
"
"
resource
:
/
/
gre
/
modules
/
BookmarkJSONUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesBackups
"
"
resource
:
/
/
gre
/
modules
/
PlacesBackups
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadUtils
"
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
)
;
const
RESTORE_FILEPICKER_FILTER_EXT
=
"
*
.
json
;
*
.
jsonlz4
"
;
const
HISTORY_LIBRARY_SEARCH_TELEMETRY
=
"
PLACES_HISTORY_LIBRARY_SEARCH_TIME_MS
"
;
var
PlacesOrganizer
=
{
_places
:
null
_initFolderTree
(
)
{
this
.
_places
.
place
=
place
:
type
=
{
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_LEFT_PANE_QUERY
}
&
excludeItems
=
1
&
expandQueries
=
0
;
}
selectLeftPaneBuiltIn
(
item
)
{
switch
(
item
)
{
case
"
AllBookmarks
"
:
this
.
_places
.
selectItems
(
[
PlacesUtils
.
virtualAllBookmarksGuid
]
)
;
PlacesUtils
.
asContainer
(
this
.
_places
.
selectedNode
)
.
containerOpen
=
true
;
break
;
case
"
History
"
:
this
.
_places
.
selectItems
(
[
PlacesUtils
.
virtualHistoryGuid
]
)
;
PlacesUtils
.
asContainer
(
this
.
_places
.
selectedNode
)
.
containerOpen
=
true
;
break
;
case
"
Downloads
"
:
this
.
_places
.
selectItems
(
[
PlacesUtils
.
virtualDownloadsGuid
]
)
;
break
;
case
"
Tags
"
:
this
.
_places
.
selectItems
(
[
PlacesUtils
.
virtualTagsGuid
]
)
;
break
;
case
"
BookmarksMenu
"
:
this
.
selectLeftPaneContainerByHierarchy
(
[
PlacesUtils
.
virtualAllBookmarksGuid
PlacesUtils
.
bookmarks
.
virtualMenuGuid
]
)
;
break
;
case
"
BookmarksToolbar
"
:
this
.
selectLeftPaneContainerByHierarchy
(
[
PlacesUtils
.
virtualAllBookmarksGuid
PlacesUtils
.
bookmarks
.
virtualToolbarGuid
]
)
;
break
;
case
"
UnfiledBookmarks
"
:
this
.
selectLeftPaneContainerByHierarchy
(
[
PlacesUtils
.
virtualAllBookmarksGuid
PlacesUtils
.
bookmarks
.
virtualUnfiledGuid
]
)
;
break
;
default
:
throw
new
Error
(
Unrecognized
item
{
item
}
passed
to
selectLeftPaneRootItem
)
;
}
}
selectLeftPaneContainerByHierarchy
(
aHierarchy
)
{
if
(
!
aHierarchy
)
throw
new
Error
(
"
Containers
hierarchy
not
specified
"
)
;
let
hierarchy
=
[
]
.
concat
(
aHierarchy
)
;
let
selectWasSuppressed
=
this
.
_places
.
view
.
selection
.
selectEventsSuppressed
;
if
(
!
selectWasSuppressed
)
this
.
_places
.
view
.
selection
.
selectEventsSuppressed
=
true
;
try
{
for
(
let
container
of
hierarchy
)
{
if
(
typeof
container
!
=
"
string
"
)
{
throw
new
Error
(
"
Invalid
container
type
found
:
"
+
container
)
;
}
try
{
this
.
selectLeftPaneBuiltIn
(
container
)
;
}
catch
(
ex
)
{
if
(
container
.
substr
(
0
6
)
=
=
"
place
:
"
)
{
this
.
_places
.
selectPlaceURI
(
container
)
;
}
else
{
this
.
_places
.
selectItems
(
[
container
]
false
)
;
}
}
PlacesUtils
.
asContainer
(
this
.
_places
.
selectedNode
)
.
containerOpen
=
true
;
}
}
finally
{
if
(
!
selectWasSuppressed
)
this
.
_places
.
view
.
selection
.
selectEventsSuppressed
=
false
;
}
}
init
:
function
PO_init
(
)
{
const
DOWNLOADS_QUERY
=
"
place
:
transition
=
"
+
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
+
"
&
sort
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATE_DESCENDING
;
ContentArea
.
setContentViewForQueryString
(
DOWNLOADS_QUERY
(
)
=
>
new
DownloadsPlacesView
(
document
.
getElementById
(
"
downloadsRichListBox
"
)
false
)
{
showDetailsPane
:
false
toolbarSet
:
"
back
-
button
forward
-
button
organizeButton
clearDownloadsButton
libraryToolbarSpacer
searchFilter
"
}
)
;
ContentArea
.
init
(
)
;
this
.
_places
=
document
.
getElementById
(
"
placesList
"
)
;
this
.
_initFolderTree
(
)
;
var
leftPaneSelection
=
"
AllBookmarks
"
;
if
(
window
.
arguments
&
&
window
.
arguments
[
0
]
)
leftPaneSelection
=
window
.
arguments
[
0
]
;
this
.
selectLeftPaneContainerByHierarchy
(
leftPaneSelection
)
;
if
(
leftPaneSelection
=
=
=
"
History
"
)
{
let
historyNode
=
this
.
_places
.
selectedNode
;
if
(
historyNode
.
childCount
>
0
)
this
.
_places
.
selectNode
(
historyNode
.
getChild
(
0
)
)
;
}
this
.
_backHistory
.
splice
(
0
this
.
_backHistory
.
length
)
;
document
.
getElementById
(
"
OrganizerCommand
:
Back
"
)
.
setAttribute
(
"
disabled
"
true
)
;
PlacesSearchBox
.
init
(
)
;
window
.
addEventListener
(
"
AppCommand
"
this
true
)
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
let
findMenuItem
=
document
.
getElementById
(
"
menu_find
"
)
;
findMenuItem
.
setAttribute
(
"
command
"
"
OrganizerCommand_find
:
all
"
)
;
let
findKey
=
document
.
getElementById
(
"
key_find
"
)
;
findKey
.
setAttribute
(
"
command
"
"
OrganizerCommand_find
:
all
"
)
;
let
elements
=
[
"
cmd_handleBackspace
"
"
cmd_handleShiftBackspace
"
]
;
for
(
let
i
=
0
;
i
<
elements
.
length
;
i
+
+
)
{
document
.
getElementById
(
elements
[
i
]
)
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
document
.
getElementById
(
"
placesContext
"
)
.
removeChild
(
document
.
getElementById
(
"
placesContext_show
:
info
"
)
)
;
if
(
!
Services
.
policies
.
isAllowed
(
"
profileImport
"
)
)
{
document
.
getElementById
(
"
OrganizerCommand_browserImport
"
)
.
setAttribute
(
"
disabled
"
true
)
;
}
ContentArea
.
focus
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
]
)
handleEvent
:
function
PO_handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
!
=
"
AppCommand
"
)
return
;
aEvent
.
stopPropagation
(
)
;
switch
(
aEvent
.
command
)
{
case
"
Back
"
:
if
(
this
.
_backHistory
.
length
>
0
)
this
.
back
(
)
;
break
;
case
"
Forward
"
:
if
(
this
.
_forwardHistory
.
length
>
0
)
this
.
forward
(
)
;
break
;
case
"
Search
"
:
PlacesSearchBox
.
findAll
(
)
;
break
;
}
}
destroy
:
function
PO_destroy
(
)
{
}
_location
:
null
get
location
(
)
{
return
this
.
_location
;
}
set
location
(
aLocation
)
{
if
(
!
aLocation
|
|
this
.
_location
=
=
aLocation
)
return
aLocation
;
if
(
this
.
location
)
{
this
.
_backHistory
.
unshift
(
this
.
location
)
;
this
.
_forwardHistory
.
splice
(
0
this
.
_forwardHistory
.
length
)
;
}
this
.
_location
=
aLocation
;
this
.
_places
.
selectPlaceURI
(
aLocation
)
;
if
(
!
this
.
_places
.
hasSelection
)
{
ContentArea
.
currentPlace
=
aLocation
;
}
this
.
updateDetailsPane
(
)
;
if
(
this
.
_backHistory
.
length
=
=
0
)
document
.
getElementById
(
"
OrganizerCommand
:
Back
"
)
.
setAttribute
(
"
disabled
"
true
)
;
else
document
.
getElementById
(
"
OrganizerCommand
:
Back
"
)
.
removeAttribute
(
"
disabled
"
)
;
if
(
this
.
_forwardHistory
.
length
=
=
0
)
document
.
getElementById
(
"
OrganizerCommand
:
Forward
"
)
.
setAttribute
(
"
disabled
"
true
)
;
else
document
.
getElementById
(
"
OrganizerCommand
:
Forward
"
)
.
removeAttribute
(
"
disabled
"
)
;
return
aLocation
;
}
_backHistory
:
[
]
_forwardHistory
:
[
]
back
:
function
PO_back
(
)
{
this
.
_forwardHistory
.
unshift
(
this
.
location
)
;
var
historyEntry
=
this
.
_backHistory
.
shift
(
)
;
this
.
_location
=
null
;
this
.
location
=
historyEntry
;
}
forward
:
function
PO_forward
(
)
{
this
.
_backHistory
.
unshift
(
this
.
location
)
;
var
historyEntry
=
this
.
_forwardHistory
.
shift
(
)
;
this
.
_location
=
null
;
this
.
location
=
historyEntry
;
}
_cachedLeftPaneSelectedURI
:
null
onPlaceSelected
:
function
PO_onPlaceSelected
(
resetSearchBox
)
{
if
(
!
this
.
_places
.
hasSelection
)
return
;
let
node
=
this
.
_places
.
selectedNode
;
let
placeURI
=
node
.
uri
;
if
(
ContentArea
.
currentPlace
!
=
placeURI
|
|
!
resetSearchBox
)
{
ContentArea
.
currentPlace
=
placeURI
;
this
.
location
=
placeURI
;
}
if
(
placeURI
=
=
this
.
_cachedLeftPaneSelectedURI
)
return
;
this
.
_cachedLeftPaneSelectedURI
=
placeURI
;
PlacesSearchBox
.
searchFilter
.
reset
(
)
;
this
.
_setSearchScopeForNode
(
node
)
;
this
.
updateDetailsPane
(
)
;
}
_setSearchScopeForNode
:
function
PO__setScopeForNode
(
aNode
)
{
let
itemGuid
=
aNode
.
bookmarkGuid
;
if
(
PlacesUtils
.
nodeIsHistoryContainer
(
aNode
)
|
|
itemGuid
=
=
PlacesUtils
.
virtualHistoryGuid
)
{
PlacesQueryBuilder
.
setScope
(
"
history
"
)
;
}
else
if
(
itemGuid
=
=
PlacesUtils
.
virtualDownloadsGuid
)
{
PlacesQueryBuilder
.
setScope
(
"
downloads
"
)
;
}
else
{
PlacesQueryBuilder
.
setScope
(
"
bookmarks
"
)
;
}
}
onPlacesListClick
:
function
PO_onPlacesListClick
(
aEvent
)
{
if
(
aEvent
.
target
.
localName
!
=
"
treechildren
"
)
return
;
let
node
=
this
.
_places
.
selectedNode
;
if
(
node
)
{
let
middleClick
=
aEvent
.
button
=
=
1
&
&
aEvent
.
detail
=
=
1
;
if
(
middleClick
&
&
PlacesUtils
.
nodeIsContainer
(
node
)
)
{
PlacesUIUtils
.
openMultipleLinksInTabs
(
node
aEvent
this
.
_places
)
;
}
}
}
updateDetailsPane
:
function
PO_updateDetailsPane
(
)
{
if
(
!
ContentArea
.
currentViewOptions
.
showDetailsPane
)
return
;
let
view
=
PlacesUIUtils
.
getViewForNode
(
document
.
activeElement
)
;
if
(
view
)
{
let
selectedNodes
=
view
.
selectedNode
?
[
view
.
selectedNode
]
:
view
.
selectedNodes
;
this
.
_fillDetailsPane
(
selectedNodes
)
;
}
}
openFlatContainer
(
aContainer
)
{
if
(
aContainer
.
bookmarkGuid
)
{
PlacesUtils
.
asContainer
(
this
.
_places
.
selectedNode
)
.
containerOpen
=
true
;
this
.
_places
.
selectItems
(
[
aContainer
.
bookmarkGuid
]
false
)
;
}
else
if
(
PlacesUtils
.
nodeIsQuery
(
aContainer
)
)
{
this
.
_places
.
selectPlaceURI
(
aContainer
.
uri
)
;
}
}
getCurrentOptions
:
function
PO_getCurrentOptions
(
)
{
return
PlacesUtils
.
asQuery
(
ContentArea
.
currentView
.
result
.
root
)
.
queryOptions
;
}
importFromBrowser
:
function
PO_importFromBrowser
(
)
{
MigrationUtils
.
showMigrationWizard
(
window
[
MigrationUtils
.
MIGRATION_ENTRYPOINT_PLACES
]
)
;
}
importFromFile
:
function
PO_importFromFile
(
)
{
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
fpCallback
=
function
fpCallback_done
(
aResult
)
{
if
(
aResult
!
=
Ci
.
nsIFilePicker
.
returnCancel
&
&
fp
.
fileURL
)
{
var
{
BookmarkHTMLUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BookmarkHTMLUtils
.
jsm
"
)
;
BookmarkHTMLUtils
.
importFromURL
(
fp
.
fileURL
.
spec
)
.
catch
(
Cu
.
reportError
)
;
}
}
;
fp
.
init
(
window
PlacesUIUtils
.
getString
(
"
SelectImport
"
)
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterHTML
)
;
fp
.
open
(
fpCallback
)
;
}
exportBookmarks
:
function
PO_exportBookmarks
(
)
{
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
fpCallback
=
function
fpCallback_done
(
aResult
)
{
if
(
aResult
!
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
var
{
BookmarkHTMLUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BookmarkHTMLUtils
.
jsm
"
)
;
BookmarkHTMLUtils
.
exportToFile
(
fp
.
file
.
path
)
.
catch
(
Cu
.
reportError
)
;
}
}
;
fp
.
init
(
window
PlacesUIUtils
.
getString
(
"
EnterExport
"
)
Ci
.
nsIFilePicker
.
modeSave
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterHTML
)
;
fp
.
defaultString
=
"
bookmarks
.
html
"
;
fp
.
open
(
fpCallback
)
;
}
populateRestoreMenu
:
function
PO_populateRestoreMenu
(
)
{
let
restorePopup
=
document
.
getElementById
(
"
fileRestorePopup
"
)
;
const
dtOptions
=
{
dateStyle
:
"
long
"
}
;
let
dateFormatter
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
dtOptions
)
;
while
(
restorePopup
.
childNodes
.
length
>
1
)
restorePopup
.
firstChild
.
remove
(
)
;
(
async
function
(
)
{
let
backupFiles
=
await
PlacesBackups
.
getBackupFiles
(
)
;
if
(
backupFiles
.
length
=
=
0
)
return
;
for
(
let
i
=
0
;
i
<
backupFiles
.
length
;
i
+
+
)
{
let
fileSize
=
(
await
OS
.
File
.
stat
(
backupFiles
[
i
]
)
)
.
size
;
let
[
size
unit
]
=
DownloadUtils
.
convertByteUnits
(
fileSize
)
;
let
sizeString
=
PlacesUtils
.
getFormattedString
(
"
backupFileSizeText
"
[
size
unit
]
)
;
let
sizeInfo
;
let
bookmarkCount
=
PlacesBackups
.
getBookmarkCountForFile
(
backupFiles
[
i
]
)
;
if
(
bookmarkCount
!
=
null
)
{
sizeInfo
=
"
(
"
+
sizeString
+
"
-
"
+
PlacesUIUtils
.
getPluralString
(
"
detailsPane
.
itemsCountLabel
"
bookmarkCount
[
bookmarkCount
]
)
+
"
)
"
;
}
else
{
sizeInfo
=
"
(
"
+
sizeString
+
"
)
"
;
}
let
backupDate
=
PlacesBackups
.
getDateForFile
(
backupFiles
[
i
]
)
;
let
m
=
restorePopup
.
insertBefore
(
document
.
createElement
(
"
menuitem
"
)
document
.
getElementById
(
"
restoreFromFile
"
)
)
;
m
.
setAttribute
(
"
label
"
dateFormatter
.
format
(
backupDate
)
+
sizeInfo
)
;
m
.
setAttribute
(
"
value
"
OS
.
Path
.
basename
(
backupFiles
[
i
]
)
)
;
m
.
setAttribute
(
"
oncommand
"
"
PlacesOrganizer
.
onRestoreMenuItemClick
(
this
)
;
"
)
;
}
restorePopup
.
insertBefore
(
document
.
createElement
(
"
menuseparator
"
)
document
.
getElementById
(
"
restoreFromFile
"
)
)
;
}
)
(
)
;
}
async
onRestoreMenuItemClick
(
aMenuItem
)
{
let
backupName
=
aMenuItem
.
getAttribute
(
"
value
"
)
;
let
backupFilePaths
=
await
PlacesBackups
.
getBackupFiles
(
)
;
for
(
let
backupFilePath
of
backupFilePaths
)
{
if
(
OS
.
Path
.
basename
(
backupFilePath
)
=
=
backupName
)
{
PlacesOrganizer
.
restoreBookmarksFromFile
(
backupFilePath
)
;
break
;
}
}
}
onRestoreBookmarksFromFile
:
function
PO_onRestoreBookmarksFromFile
(
)
{
let
backupsDir
=
Services
.
dirsvc
.
get
(
"
Desk
"
Ci
.
nsIFile
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
fpCallback
=
aResult
=
>
{
if
(
aResult
!
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
this
.
restoreBookmarksFromFile
(
fp
.
file
.
path
)
;
}
}
;
fp
.
init
(
window
PlacesUIUtils
.
getString
(
"
bookmarksRestoreTitle
"
)
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilter
(
PlacesUIUtils
.
getString
(
"
bookmarksRestoreFilterName
"
)
RESTORE_FILEPICKER_FILTER_EXT
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterAll
)
;
fp
.
displayDirectory
=
backupsDir
;
fp
.
open
(
fpCallback
)
;
}
restoreBookmarksFromFile
:
function
PO_restoreBookmarksFromFile
(
aFilePath
)
{
if
(
!
aFilePath
.
toLowerCase
(
)
.
endsWith
(
"
json
"
)
&
&
!
aFilePath
.
toLowerCase
(
)
.
endsWith
(
"
jsonlz4
"
)
)
{
this
.
_showErrorAlert
(
PlacesUIUtils
.
getString
(
"
bookmarksRestoreFormatError
"
)
)
;
return
;
}
if
(
!
Services
.
prompt
.
confirm
(
null
PlacesUIUtils
.
getString
(
"
bookmarksRestoreAlertTitle
"
)
PlacesUIUtils
.
getString
(
"
bookmarksRestoreAlert
"
)
)
)
return
;
(
async
function
(
)
{
try
{
await
BookmarkJSONUtils
.
importFromFile
(
aFilePath
{
replace
:
true
}
)
;
}
catch
(
ex
)
{
PlacesOrganizer
.
_showErrorAlert
(
PlacesUIUtils
.
getString
(
"
bookmarksRestoreParseError
"
)
)
;
}
}
)
(
)
;
}
_showErrorAlert
:
function
PO__showErrorAlert
(
aMsg
)
{
var
brandShortName
=
document
.
getElementById
(
"
brandStrings
"
)
.
getString
(
"
brandShortName
"
)
;
Services
.
prompt
.
alert
(
window
brandShortName
aMsg
)
;
}
backupBookmarks
:
function
PO_backupBookmarks
(
)
{
let
backupsDir
=
Services
.
dirsvc
.
get
(
"
Desk
"
Ci
.
nsIFile
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
fpCallback
=
function
fpCallback_done
(
aResult
)
{
if
(
aResult
!
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
PlacesBackups
.
saveBookmarksToJSONFile
(
fp
.
file
.
path
)
.
catch
(
Cu
.
reportError
)
;
}
}
;
fp
.
init
(
window
PlacesUIUtils
.
getString
(
"
bookmarksBackupTitle
"
)
Ci
.
nsIFilePicker
.
modeSave
)
;
fp
.
appendFilter
(
PlacesUIUtils
.
getString
(
"
bookmarksRestoreFilterName
"
)
RESTORE_FILEPICKER_FILTER_EXT
)
;
fp
.
defaultString
=
PlacesBackups
.
getFilenameForDate
(
)
;
fp
.
defaultExtension
=
"
json
"
;
fp
.
displayDirectory
=
backupsDir
;
fp
.
open
(
fpCallback
)
;
}
_fillDetailsPane
:
function
PO__fillDetailsPane
(
aNodeList
)
{
var
infoBox
=
document
.
getElementById
(
"
infoBox
"
)
;
var
detailsDeck
=
document
.
getElementById
(
"
detailsDeck
"
)
;
infoBox
.
hidden
=
false
;
let
selectedNode
=
aNodeList
.
length
=
=
1
?
aNodeList
[
0
]
:
null
;
if
(
gEditItemOverlay
.
itemId
!
=
-
1
)
{
var
focusedElement
=
document
.
commandDispatcher
.
focusedElement
;
if
(
(
focusedElement
instanceof
HTMLInputElement
|
|
focusedElement
instanceof
HTMLTextAreaElement
)
&
&
/
^
editBMPanel
.
*
/
.
test
(
focusedElement
.
parentNode
.
parentNode
.
id
)
)
focusedElement
.
blur
(
)
;
if
(
selectedNode
)
{
let
concreteId
=
PlacesUtils
.
getConcreteItemId
(
selectedNode
)
;
var
nodeIsSame
=
gEditItemOverlay
.
itemId
=
=
selectedNode
.
itemId
|
|
gEditItemOverlay
.
itemId
=
=
concreteId
|
|
(
selectedNode
.
itemId
=
=
-
1
&
&
gEditItemOverlay
.
uri
&
&
gEditItemOverlay
.
uri
=
=
selectedNode
.
uri
)
;
if
(
nodeIsSame
&
&
detailsDeck
.
selectedIndex
=
=
1
&
&
!
gEditItemOverlay
.
multiEdit
)
return
;
}
}
gEditItemOverlay
.
uninitPanel
(
false
)
;
if
(
selectedNode
&
&
!
PlacesUtils
.
nodeIsSeparator
(
selectedNode
)
)
{
detailsDeck
.
selectedIndex
=
1
;
gEditItemOverlay
.
initPanel
(
{
node
:
selectedNode
hiddenRows
:
[
"
folderPicker
"
]
}
)
;
}
else
if
(
!
selectedNode
&
&
aNodeList
[
0
]
)
{
if
(
aNodeList
.
every
(
PlacesUtils
.
nodeIsURI
)
)
{
let
uris
=
aNodeList
.
map
(
node
=
>
Services
.
io
.
newURI
(
node
.
uri
)
)
;
detailsDeck
.
selectedIndex
=
1
;
gEditItemOverlay
.
initPanel
(
{
uris
hiddenRows
:
[
"
folderPicker
"
"
location
"
"
keyword
"
"
name
"
]
}
)
;
}
else
{
detailsDeck
.
selectedIndex
=
0
;
let
selectItemDesc
=
document
.
getElementById
(
"
selectItemDescription
"
)
;
let
itemsCountLabel
=
document
.
getElementById
(
"
itemsCountText
"
)
;
selectItemDesc
.
hidden
=
false
;
itemsCountLabel
.
value
=
PlacesUIUtils
.
getPluralString
(
"
detailsPane
.
itemsCountLabel
"
aNodeList
.
length
[
aNodeList
.
length
]
)
;
infoBox
.
hidden
=
true
;
}
}
else
{
detailsDeck
.
selectedIndex
=
0
;
infoBox
.
hidden
=
true
;
let
selectItemDesc
=
document
.
getElementById
(
"
selectItemDescription
"
)
;
let
itemsCountLabel
=
document
.
getElementById
(
"
itemsCountText
"
)
;
let
itemsCount
=
0
;
if
(
ContentArea
.
currentView
.
result
)
{
let
rootNode
=
ContentArea
.
currentView
.
result
.
root
;
if
(
rootNode
.
containerOpen
)
itemsCount
=
rootNode
.
childCount
;
}
if
(
itemsCount
=
=
0
)
{
selectItemDesc
.
hidden
=
true
;
itemsCountLabel
.
value
=
PlacesUIUtils
.
getString
(
"
detailsPane
.
noItems
"
)
;
}
else
{
selectItemDesc
.
hidden
=
false
;
itemsCountLabel
.
value
=
PlacesUIUtils
.
getPluralString
(
"
detailsPane
.
itemsCountLabel
"
itemsCount
[
itemsCount
]
)
;
}
}
}
}
;
var
PlacesSearchBox
=
{
get
searchFilter
(
)
{
return
document
.
getElementById
(
"
searchFilter
"
)
;
}
_folders
:
[
]
get
folders
(
)
{
if
(
this
.
_folders
.
length
=
=
0
)
{
this
.
_folders
=
PlacesUtils
.
bookmarks
.
userContentRoots
;
}
return
this
.
_folders
;
}
set
folders
(
aFolders
)
{
this
.
_folders
=
aFolders
;
return
aFolders
;
}
search
:
function
PSB_search
(
filterString
)
{
var
PO
=
PlacesOrganizer
;
if
(
filterString
=
=
"
"
)
{
PO
.
onPlaceSelected
(
false
)
;
return
;
}
let
currentView
=
ContentArea
.
currentView
;
switch
(
PlacesSearchBox
.
filterCollection
)
{
case
"
bookmarks
"
:
currentView
.
applyFilter
(
filterString
this
.
folders
)
;
break
;
case
"
history
"
:
{
let
currentOptions
=
PO
.
getCurrentOptions
(
)
;
if
(
currentOptions
.
queryType
!
=
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_HISTORY
)
{
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
query
.
searchTerms
=
filterString
;
let
options
=
currentOptions
.
clone
(
)
;
options
.
resultType
=
currentOptions
.
RESULTS_AS_URI
;
options
.
queryType
=
Ci
.
nsINavHistoryQueryOptions
.
QUERY_TYPE_HISTORY
;
options
.
includeHidden
=
true
;
currentView
.
load
(
[
query
]
options
)
;
}
else
{
TelemetryStopwatch
.
start
(
HISTORY_LIBRARY_SEARCH_TELEMETRY
)
;
currentView
.
applyFilter
(
filterString
null
true
)
;
TelemetryStopwatch
.
finish
(
HISTORY_LIBRARY_SEARCH_TELEMETRY
)
;
}
break
;
}
case
"
downloads
"
:
{
currentView
.
searchTerm
=
filterString
;
break
;
}
default
:
throw
"
Invalid
filterCollection
on
search
"
;
}
PlacesOrganizer
.
updateDetailsPane
(
)
;
}
findAll
:
function
PSB_findAll
(
)
{
switch
(
this
.
filterCollection
)
{
case
"
history
"
:
PlacesQueryBuilder
.
setScope
(
"
history
"
)
;
break
;
case
"
downloads
"
:
PlacesQueryBuilder
.
setScope
(
"
downloads
"
)
;
break
;
default
:
PlacesQueryBuilder
.
setScope
(
"
bookmarks
"
)
;
break
;
}
this
.
focus
(
)
;
}
updateCollectionTitle
:
function
PSB_updateCollectionTitle
(
aTitle
)
{
let
title
=
"
"
;
switch
(
this
.
filterCollection
)
{
case
"
history
"
:
title
=
PlacesUIUtils
.
getString
(
"
searchHistory
"
)
;
break
;
case
"
downloads
"
:
title
=
PlacesUIUtils
.
getString
(
"
searchDownloads
"
)
;
break
;
default
:
title
=
PlacesUIUtils
.
getString
(
"
searchBookmarks
"
)
;
}
this
.
searchFilter
.
placeholder
=
title
;
}
get
filterCollection
(
)
{
return
this
.
searchFilter
.
getAttribute
(
"
collection
"
)
;
}
set
filterCollection
(
collectionName
)
{
if
(
collectionName
=
=
this
.
filterCollection
)
return
collectionName
;
this
.
searchFilter
.
setAttribute
(
"
collection
"
collectionName
)
;
this
.
updateCollectionTitle
(
)
;
return
collectionName
;
}
focus
:
function
PSB_focus
(
)
{
this
.
searchFilter
.
focus
(
)
;
}
init
:
function
PSB_init
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
clickSelectsAll
"
false
)
)
{
this
.
searchFilter
.
setAttribute
(
"
clickSelectsAll
"
true
)
;
}
this
.
updateCollectionTitle
(
)
;
}
get
value
(
)
{
return
this
.
searchFilter
.
value
;
}
set
value
(
value
)
{
return
this
.
searchFilter
.
value
=
value
;
}
}
;
var
PlacesQueryBuilder
=
{
queries
:
[
]
queryOptions
:
null
setScope
:
function
PQB_setScope
(
aScope
)
{
var
filterCollection
;
var
folders
=
[
]
;
switch
(
aScope
)
{
case
"
history
"
:
filterCollection
=
"
history
"
;
break
;
case
"
bookmarks
"
:
filterCollection
=
"
bookmarks
"
;
folders
=
PlacesUtils
.
bookmarks
.
userContentRoots
;
break
;
case
"
downloads
"
:
filterCollection
=
"
downloads
"
;
break
;
default
:
throw
"
Invalid
search
scope
"
;
}
PlacesSearchBox
.
filterCollection
=
filterCollection
;
PlacesSearchBox
.
folders
=
folders
;
var
searchStr
=
PlacesSearchBox
.
searchFilter
.
value
;
if
(
searchStr
)
PlacesSearchBox
.
search
(
searchStr
)
;
}
}
;
var
ViewMenu
=
{
_clean
:
function
VM__clean
(
popup
startID
endID
)
{
if
(
endID
&
&
!
startID
)
throw
new
Error
(
"
meaningless
to
have
valid
endID
and
null
startID
"
)
;
if
(
startID
)
{
var
startElement
=
document
.
getElementById
(
startID
)
;
if
(
startElement
.
parentNode
!
=
popup
)
throw
new
Error
(
"
startElement
is
not
in
popup
"
)
;
if
(
!
startElement
)
throw
new
Error
(
"
startID
does
not
correspond
to
an
existing
element
"
)
;
var
endElement
=
null
;
if
(
endID
)
{
endElement
=
document
.
getElementById
(
endID
)
;
if
(
endElement
.
parentNode
!
=
popup
)
throw
new
Error
(
"
endElement
is
not
in
popup
"
)
;
if
(
!
endElement
)
throw
new
Error
(
"
endID
does
not
correspond
to
an
existing
element
"
)
;
}
while
(
startElement
.
nextSibling
!
=
endElement
)
popup
.
removeChild
(
startElement
.
nextSibling
)
;
return
endElement
;
}
while
(
popup
.
hasChildNodes
(
)
)
{
popup
.
firstChild
.
remove
(
)
;
}
return
null
;
}
fillWithColumns
:
function
VM_fillWithColumns
(
event
startID
endID
type
propertyPrefix
)
{
var
popup
=
event
.
target
;
var
pivot
=
this
.
_clean
(
popup
startID
endID
)
;
var
content
=
document
.
getElementById
(
"
placeContent
"
)
;
var
columns
=
content
.
columns
;
for
(
var
i
=
0
;
i
<
columns
.
count
;
+
+
i
)
{
var
column
=
columns
.
getColumnAt
(
i
)
.
element
;
var
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
id
=
"
menucol_
"
+
column
.
id
;
menuitem
.
column
=
column
;
var
label
=
column
.
getAttribute
(
"
label
"
)
;
if
(
propertyPrefix
)
{
var
menuitemPrefix
=
propertyPrefix
;
var
columnId
=
column
.
getAttribute
(
"
anonid
"
)
;
menuitemPrefix
+
=
columnId
=
=
"
title
"
?
"
name
"
:
columnId
;
label
=
PlacesUIUtils
.
getString
(
menuitemPrefix
+
"
.
label
"
)
;
var
accesskey
=
PlacesUIUtils
.
getString
(
menuitemPrefix
+
"
.
accesskey
"
)
;
menuitem
.
setAttribute
(
"
accesskey
"
accesskey
)
;
}
menuitem
.
setAttribute
(
"
label
"
label
)
;
if
(
type
=
=
"
radio
"
)
{
menuitem
.
setAttribute
(
"
type
"
"
radio
"
)
;
menuitem
.
setAttribute
(
"
name
"
"
columns
"
)
;
if
(
column
.
getAttribute
(
"
sortDirection
"
)
!
=
"
"
)
{
menuitem
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
}
else
if
(
type
=
=
"
checkbox
"
)
{
menuitem
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
if
(
column
.
getAttribute
(
"
primary
"
)
=
=
"
true
"
)
menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
if
(
!
column
.
hidden
)
menuitem
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
if
(
pivot
)
popup
.
insertBefore
(
menuitem
pivot
)
;
else
popup
.
appendChild
(
menuitem
)
;
}
event
.
stopPropagation
(
)
;
}
populateSortMenu
:
function
VM_populateSortMenu
(
event
)
{
this
.
fillWithColumns
(
event
"
viewUnsorted
"
"
directionSeparator
"
"
radio
"
"
view
.
sortBy
.
1
.
"
)
;
var
sortColumn
=
this
.
_getSortColumn
(
)
;
var
viewSortAscending
=
document
.
getElementById
(
"
viewSortAscending
"
)
;
var
viewSortDescending
=
document
.
getElementById
(
"
viewSortDescending
"
)
;
var
viewUnsorted
=
document
.
getElementById
(
"
viewUnsorted
"
)
;
if
(
!
sortColumn
)
{
viewSortAscending
.
removeAttribute
(
"
checked
"
)
;
viewSortDescending
.
removeAttribute
(
"
checked
"
)
;
viewUnsorted
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
if
(
sortColumn
.
getAttribute
(
"
sortDirection
"
)
=
=
"
ascending
"
)
{
viewSortAscending
.
setAttribute
(
"
checked
"
"
true
"
)
;
viewSortDescending
.
removeAttribute
(
"
checked
"
)
;
viewUnsorted
.
removeAttribute
(
"
checked
"
)
;
}
else
if
(
sortColumn
.
getAttribute
(
"
sortDirection
"
)
=
=
"
descending
"
)
{
viewSortDescending
.
setAttribute
(
"
checked
"
"
true
"
)
;
viewSortAscending
.
removeAttribute
(
"
checked
"
)
;
viewUnsorted
.
removeAttribute
(
"
checked
"
)
;
}
}
showHideColumn
:
function
VM_showHideColumn
(
element
)
{
var
column
=
element
.
column
;
var
splitter
=
column
.
nextSibling
;
if
(
splitter
&
&
splitter
.
localName
!
=
"
splitter
"
)
splitter
=
null
;
if
(
element
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
)
{
column
.
setAttribute
(
"
hidden
"
"
false
"
)
;
if
(
splitter
)
splitter
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
column
.
setAttribute
(
"
hidden
"
"
true
"
)
;
if
(
splitter
)
splitter
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
_getSortColumn
:
function
VM__getSortColumn
(
)
{
var
content
=
document
.
getElementById
(
"
placeContent
"
)
;
var
cols
=
content
.
columns
;
for
(
var
i
=
0
;
i
<
cols
.
count
;
+
+
i
)
{
var
column
=
cols
.
getColumnAt
(
i
)
.
element
;
var
sortDirection
=
column
.
getAttribute
(
"
sortDirection
"
)
;
if
(
sortDirection
=
=
"
ascending
"
|
|
sortDirection
=
=
"
descending
"
)
return
column
;
}
return
null
;
}
setSortColumn
:
function
VM_setSortColumn
(
aColumn
aDirection
)
{
var
result
=
document
.
getElementById
(
"
placeContent
"
)
.
result
;
if
(
!
aColumn
&
&
!
aDirection
)
{
result
.
sortingMode
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_NONE
;
return
;
}
var
columnId
;
if
(
aColumn
)
{
columnId
=
aColumn
.
getAttribute
(
"
anonid
"
)
;
if
(
!
aDirection
)
{
let
sortColumn
=
this
.
_getSortColumn
(
)
;
if
(
sortColumn
)
aDirection
=
sortColumn
.
getAttribute
(
"
sortDirection
"
)
;
}
}
else
{
let
sortColumn
=
this
.
_getSortColumn
(
)
;
columnId
=
sortColumn
?
sortColumn
.
getAttribute
(
"
anonid
"
)
:
"
title
"
;
}
const
colLookupTable
=
{
title
:
{
key
:
"
TITLE
"
dir
:
"
ascending
"
}
tags
:
{
key
:
"
TAGS
"
dir
:
"
ascending
"
}
url
:
{
key
:
"
URI
"
dir
:
"
ascending
"
}
date
:
{
key
:
"
DATE
"
dir
:
"
descending
"
}
visitCount
:
{
key
:
"
VISITCOUNT
"
dir
:
"
descending
"
}
dateAdded
:
{
key
:
"
DATEADDED
"
dir
:
"
descending
"
}
lastModified
:
{
key
:
"
LASTMODIFIED
"
dir
:
"
descending
"
}
}
;
if
(
!
colLookupTable
.
hasOwnProperty
(
columnId
)
)
throw
new
Error
(
"
Invalid
column
"
)
;
aDirection
=
(
aDirection
|
|
colLookupTable
[
columnId
]
.
dir
)
.
toUpperCase
(
)
;
var
sortConst
=
"
SORT_BY_
"
+
colLookupTable
[
columnId
]
.
key
+
"
_
"
+
aDirection
;
result
.
sortingMode
=
Ci
.
nsINavHistoryQueryOptions
[
sortConst
]
;
}
}
;
var
ContentArea
=
{
_specialViews
:
new
Map
(
)
init
:
function
CA_init
(
)
{
this
.
_deck
=
document
.
getElementById
(
"
placesViewsDeck
"
)
;
this
.
_toolbar
=
document
.
getElementById
(
"
placesToolbar
"
)
;
ContentTree
.
init
(
)
;
this
.
_setupView
(
)
;
}
getContentViewForQueryString
:
function
CA_getContentViewForQueryString
(
aQueryString
)
{
try
{
if
(
this
.
_specialViews
.
has
(
aQueryString
)
)
{
let
{
view
options
}
=
this
.
_specialViews
.
get
(
aQueryString
)
;
if
(
typeof
view
=
=
"
function
"
)
{
view
=
view
(
)
;
this
.
_specialViews
.
set
(
aQueryString
{
view
options
}
)
;
}
return
view
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
ContentTree
.
view
;
}
setContentViewForQueryString
:
function
CA_setContentViewForQueryString
(
aQueryString
aView
aOptions
)
{
if
(
!
aQueryString
|
|
typeof
aView
!
=
"
object
"
&
&
typeof
aView
!
=
"
function
"
)
throw
new
Error
(
"
Invalid
arguments
"
)
;
this
.
_specialViews
.
set
(
aQueryString
{
view
:
aView
options
:
aOptions
|
|
{
}
}
)
;
}
get
currentView
(
)
{
return
PlacesUIUtils
.
getViewForNode
(
this
.
_deck
.
selectedPanel
)
;
}
set
currentView
(
aNewView
)
{
let
oldView
=
this
.
currentView
;
if
(
oldView
!
=
aNewView
)
{
this
.
_deck
.
selectedPanel
=
aNewView
.
associatedElement
;
if
(
document
.
activeElement
=
=
oldView
.
associatedElement
)
aNewView
.
associatedElement
.
focus
(
)
;
}
return
aNewView
;
}
get
currentPlace
(
)
{
return
this
.
currentView
.
place
;
}
set
currentPlace
(
aQueryString
)
{
let
oldView
=
this
.
currentView
;
let
newView
=
this
.
getContentViewForQueryString
(
aQueryString
)
;
newView
.
place
=
aQueryString
;
if
(
oldView
!
=
newView
)
{
oldView
.
active
=
false
;
this
.
currentView
=
newView
;
this
.
_setupView
(
)
;
newView
.
active
=
true
;
}
return
aQueryString
;
}
_setupView
:
function
CA__setupView
(
)
{
let
options
=
this
.
currentViewOptions
;
let
detailsDeck
=
document
.
getElementById
(
"
detailsDeck
"
)
;
detailsDeck
.
hidden
=
!
options
.
showDetailsPane
;
for
(
let
elt
of
this
.
_toolbar
.
childNodes
)
{
if
(
elt
.
id
=
=
"
placesMenu
"
)
{
for
(
let
menuElt
of
elt
.
childNodes
)
{
menuElt
.
hidden
=
!
options
.
toolbarSet
.
includes
(
menuElt
.
id
)
;
}
}
else
{
elt
.
hidden
=
!
options
.
toolbarSet
.
includes
(
elt
.
id
)
;
}
}
}
get
currentViewOptions
(
)
{
let
viewOptions
=
ContentTree
.
viewOptions
;
if
(
this
.
_specialViews
.
has
(
this
.
currentPlace
)
)
{
let
{
options
}
=
this
.
_specialViews
.
get
(
this
.
currentPlace
)
;
for
(
let
option
in
options
)
{
viewOptions
[
option
]
=
options
[
option
]
;
}
}
return
viewOptions
;
}
focus
(
)
{
this
.
_deck
.
selectedPanel
.
focus
(
)
;
}
}
;
var
ContentTree
=
{
init
:
function
CT_init
(
)
{
this
.
_view
=
document
.
getElementById
(
"
placeContent
"
)
;
}
get
view
(
)
{
return
this
.
_view
;
}
get
viewOptions
(
)
{
return
Object
.
seal
(
{
showDetailsPane
:
true
toolbarSet
:
"
back
-
button
forward
-
button
organizeButton
viewMenu
maintenanceButton
libraryToolbarSpacer
searchFilter
"
}
)
;
}
openSelectedNode
:
function
CT_openSelectedNode
(
aEvent
)
{
let
view
=
this
.
view
;
PlacesUIUtils
.
openNodeWithEvent
(
view
.
selectedNode
aEvent
)
;
}
onClick
:
function
CT_onClick
(
aEvent
)
{
let
node
=
this
.
view
.
selectedNode
;
if
(
node
)
{
let
doubleClick
=
aEvent
.
button
=
=
0
&
&
aEvent
.
detail
=
=
2
;
let
middleClick
=
aEvent
.
button
=
=
1
&
&
aEvent
.
detail
=
=
1
;
if
(
PlacesUtils
.
nodeIsURI
(
node
)
&
&
(
doubleClick
|
|
middleClick
)
)
{
this
.
openSelectedNode
(
aEvent
)
;
}
else
if
(
middleClick
&
&
PlacesUtils
.
nodeIsContainer
(
node
)
)
{
PlacesUIUtils
.
openMultipleLinksInTabs
(
node
aEvent
this
.
view
)
;
}
}
}
onKeyPress
:
function
CT_onKeyPress
(
aEvent
)
{
if
(
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_RETURN
)
this
.
openSelectedNode
(
aEvent
)
;
}
}
;
