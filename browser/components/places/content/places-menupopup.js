"
use
strict
"
;
{
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
class
MozPlacesPopup
extends
MozElements
.
MozMenuPopup
{
constructor
(
)
{
super
(
)
;
const
event_names
=
[
"
DOMMenuItemActive
"
"
DOMMenuItemInactive
"
"
dragstart
"
"
drop
"
"
dragover
"
"
dragexit
"
"
dragend
"
]
;
for
(
let
event_name
of
event_names
)
{
this
.
addEventListener
(
event_name
ev
=
>
this
[
on_
{
event_name
}
]
(
ev
)
)
;
}
this
.
attachShadow
(
{
mode
:
"
open
"
}
)
;
}
get
commonStyles
(
)
{
let
s
=
"
"
;
if
(
this
.
closest
(
"
#
BMB_bookmarksPopup
"
)
)
{
s
=
/
*
Remove
padding
on
xul
:
arrowscrollbox
to
avoid
extra
padding
on
footer
*
/
arrowscrollbox
.
popup
-
internal
-
box
{
padding
-
bottom
:
0px
;
}
.
panel
-
arrowcontainer
>
.
panel
-
arrowcontent
>
.
popup
-
internal
-
box
>
.
scrollbutton
-
up
.
panel
-
arrowcontainer
>
.
panel
-
arrowcontent
>
.
popup
-
internal
-
box
>
.
scrollbutton
-
down
{
-
moz
-
appearance
:
none
;
margin
-
top
:
0
;
margin
-
bottom
:
0
;
}
;
}
switch
(
AppConstants
.
platform
)
{
case
"
macosx
"
:
return
{
s
}
.
menupopup
-
drop
-
indicator
-
bar
{
position
:
relative
;
/
*
these
two
margins
must
together
compensate
the
indicator
'
s
height
*
/
margin
-
top
:
-
1px
;
margin
-
bottom
:
-
1px
;
}
.
menupopup
-
drop
-
indicator
{
list
-
style
-
image
:
none
;
height
:
2px
;
margin
-
inline
-
end
:
-
4em
;
background
-
color
:
Highlight
;
}
;
case
"
linux
"
:
return
{
s
}
.
menupopup
-
drop
-
indicator
-
bar
{
position
:
relative
;
/
*
these
two
margins
must
together
compensate
the
indicator
'
s
height
*
/
margin
-
top
:
-
1px
;
margin
-
bottom
:
-
1px
;
}
.
menupopup
-
drop
-
indicator
{
list
-
style
-
image
:
none
;
height
:
2px
;
margin
-
inline
-
end
:
-
4em
;
background
-
color
:
Highlight
;
}
;
case
"
win
"
:
return
{
s
}
.
menupopup
-
drop
-
indicator
-
bar
{
position
:
relative
;
/
*
these
two
margins
must
together
compensate
the
indicator
'
s
height
*
/
margin
-
top
:
-
1px
;
margin
-
bottom
:
-
1px
;
}
.
menupopup
-
drop
-
indicator
{
list
-
style
-
image
:
none
;
height
:
2px
;
margin
-
inline
-
end
:
-
4em
;
background
-
color
:
Highlight
;
}
;
default
:
return
s
;
}
}
get
styles
(
)
{
if
(
!
this
.
closest
(
"
#
BMB_bookmarksPopup
"
)
)
{
return
"
"
;
}
let
s
=
/
*
Popups
with
only
one
item
don
'
t
have
a
footer
*
/
:
host
(
[
singleitempopup
=
true
]
)
>
hbox
>
.
popup
-
internal
-
box
>
.
arrowscrollbox
-
scrollbox
/
*
These
popups
never
have
a
footer
*
/
:
host
(
#
BMB_bookmarksToolbarPopup
)
>
hbox
>
.
popup
-
internal
-
box
>
.
arrowscrollbox
-
scrollbox
:
host
(
#
BMB_unsortedBookmarksPopup
)
>
hbox
>
.
popup
-
internal
-
box
>
.
arrowscrollbox
-
scrollbox
:
host
(
#
BMB_mobileBookmarksPopup
)
>
hbox
>
.
popup
-
internal
-
box
>
.
arrowscrollbox
-
scrollbox
{
/
*
And
so
they
need
some
bottom
padding
:
*
/
padding
-
bottom
:
4px
;
}
;
switch
(
AppConstants
.
platform
)
{
case
"
linux
"
:
case
"
win
"
:
return
{
s
}
/
*
Add
some
space
at
the
top
because
there
are
no
headers
:
*
/
:
host
>
hbox
>
.
popup
-
internal
-
box
>
.
arrowscrollbox
-
scrollbox
{
padding
-
top
:
4px
;
}
;
default
:
return
s
;
}
}
get
markup
(
)
{
return
<
html
:
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
global
/
skin
/
global
.
css
"
/
>
<
html
:
style
>
{
this
.
commonStyles
}
{
this
.
styles
}
<
/
html
:
style
>
<
hbox
flex
=
"
1
"
part
=
"
innerbox
"
>
<
vbox
class
=
"
menupopup
-
drop
-
indicator
-
bar
"
hidden
=
"
true
"
>
<
image
class
=
"
menupopup
-
drop
-
indicator
"
mousethrough
=
"
always
"
>
<
/
image
>
<
/
vbox
>
<
arrowscrollbox
class
=
"
popup
-
internal
-
box
"
flex
=
"
1
"
orient
=
"
vertical
"
smoothscroll
=
"
false
"
>
<
html
:
slot
>
<
/
html
:
slot
>
<
/
arrowscrollbox
>
<
/
hbox
>
;
}
connectedCallback
(
)
{
if
(
this
.
delayConnectedCallback
(
)
)
{
return
;
}
this
.
shadowRoot
.
textContent
=
"
"
;
this
.
shadowRoot
.
appendChild
(
MozXULElement
.
parseXULToFragment
(
this
.
markup
)
)
;
this
.
_indicatorBar
=
this
.
shadowRoot
.
querySelector
(
"
.
menupopup
-
drop
-
indicator
-
bar
"
)
;
this
.
_scrollBox
=
this
.
shadowRoot
.
querySelector
(
"
.
popup
-
internal
-
box
"
)
;
this
.
_overFolder
=
{
_self
:
this
_folder
:
{
elt
:
null
openTimer
:
null
hoverTime
:
350
closeTimer
:
null
}
_closeMenuTimer
:
null
get
elt
(
)
{
return
this
.
_folder
.
elt
;
}
set
elt
(
val
)
{
return
(
this
.
_folder
.
elt
=
val
)
;
}
get
openTimer
(
)
{
return
this
.
_folder
.
openTimer
;
}
set
openTimer
(
val
)
{
return
(
this
.
_folder
.
openTimer
=
val
)
;
}
get
hoverTime
(
)
{
return
this
.
_folder
.
hoverTime
;
}
set
hoverTime
(
val
)
{
return
(
this
.
_folder
.
hoverTime
=
val
)
;
}
get
closeTimer
(
)
{
return
this
.
_folder
.
closeTimer
;
}
set
closeTimer
(
val
)
{
return
(
this
.
_folder
.
closeTimer
=
val
)
;
}
get
closeMenuTimer
(
)
{
return
this
.
_closeMenuTimer
;
}
set
closeMenuTimer
(
val
)
{
return
(
this
.
_closeMenuTimer
=
val
)
;
}
setTimer
:
function
OF__setTimer
(
aTime
)
{
var
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
this
aTime
timer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
notify
:
function
OF__notify
(
aTimer
)
{
if
(
aTimer
=
=
this
.
_folder
.
openTimer
)
{
this
.
_folder
.
elt
.
lastElementChild
.
setAttribute
(
"
autoopened
"
"
true
"
)
;
this
.
_folder
.
elt
.
lastElementChild
.
openPopup
(
)
;
this
.
_folder
.
openTimer
=
null
;
}
else
if
(
aTimer
=
=
this
.
_folder
.
closeTimer
)
{
var
draggingOverChild
=
PlacesControllerDragHelper
.
draggingOverChildNode
(
this
.
_folder
.
elt
)
;
if
(
draggingOverChild
)
{
this
.
_folder
.
elt
=
null
;
}
this
.
clear
(
)
;
if
(
!
draggingOverChild
)
{
this
.
closeParentMenus
(
)
;
}
}
else
if
(
aTimer
=
=
this
.
closeMenuTimer
)
{
var
popup
=
this
.
_self
;
if
(
PlacesControllerDragHelper
.
getSession
(
)
&
&
!
PlacesControllerDragHelper
.
draggingOverChildNode
(
popup
.
parentNode
)
)
{
popup
.
hidePopup
(
)
;
this
.
closeParentMenus
(
)
;
}
this
.
_closeMenuTimer
=
null
;
}
}
closeParentMenus
:
function
OF__closeParentMenus
(
)
{
var
popup
=
this
.
_self
;
var
parent
=
popup
.
parentNode
;
while
(
parent
)
{
if
(
parent
.
localName
=
=
"
menupopup
"
&
&
parent
.
_placesNode
)
{
if
(
PlacesControllerDragHelper
.
draggingOverChildNode
(
parent
.
parentNode
)
)
{
break
;
}
parent
.
hidePopup
(
)
;
}
parent
=
parent
.
parentNode
;
}
}
clear
:
function
OF__clear
(
)
{
if
(
this
.
_folder
.
elt
&
&
this
.
_folder
.
elt
.
lastElementChild
)
{
if
(
!
this
.
_folder
.
elt
.
lastElementChild
.
hasAttribute
(
"
dragover
"
)
)
{
this
.
_folder
.
elt
.
lastElementChild
.
hidePopup
(
)
;
}
this
.
_folder
.
elt
.
removeAttribute
(
"
_moz
-
menuactive
"
)
;
this
.
_folder
.
elt
=
null
;
}
if
(
this
.
_folder
.
openTimer
)
{
this
.
_folder
.
openTimer
.
cancel
(
)
;
this
.
_folder
.
openTimer
=
null
;
}
if
(
this
.
_folder
.
closeTimer
)
{
this
.
_folder
.
closeTimer
.
cancel
(
)
;
this
.
_folder
.
closeTimer
=
null
;
}
}
}
;
}
get
_rootView
(
)
{
if
(
!
this
.
__rootView
)
{
this
.
__rootView
=
PlacesUIUtils
.
getViewForNode
(
this
)
;
}
return
this
.
__rootView
;
}
_hideDropIndicator
(
aEvent
)
{
let
target
=
aEvent
.
target
;
let
betweenMarkers
=
this
.
_startMarker
.
compareDocumentPosition
(
target
)
&
Node
.
DOCUMENT_POSITION_FOLLOWING
&
&
this
.
_endMarker
.
compareDocumentPosition
(
target
)
&
Node
.
DOCUMENT_POSITION_PRECEDING
;
return
!
(
target
&
&
target
.
_placesNode
&
&
betweenMarkers
)
;
}
_getDropPoint
(
aEvent
)
{
let
resultNode
=
this
.
_placesNode
;
if
(
!
PlacesUtils
.
nodeIsFolder
(
resultNode
)
|
|
this
.
_rootView
.
controller
.
disallowInsertion
(
resultNode
)
)
{
return
null
;
}
var
dropPoint
=
{
ip
:
null
folderElt
:
null
}
;
let
elt
=
aEvent
.
target
;
if
(
elt
.
localName
=
=
"
menupopup
"
)
{
elt
=
elt
.
parentNode
;
}
let
eventY
=
aEvent
.
clientY
;
let
{
y
:
eltY
height
:
eltHeight
}
=
elt
.
getBoundingClientRect
(
)
;
if
(
!
elt
.
_placesNode
)
{
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
resultNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
resultNode
)
}
)
;
let
isMenu
=
elt
.
localName
=
=
"
menu
"
|
|
(
elt
.
localName
=
=
"
toolbarbutton
"
&
&
elt
.
getAttribute
(
"
type
"
)
=
=
"
menu
"
)
;
if
(
isMenu
&
&
elt
.
lastElementChild
&
&
elt
.
lastElementChild
.
hasAttribute
(
"
placespopup
"
)
)
{
dropPoint
.
folderElt
=
elt
;
}
return
dropPoint
;
}
let
tagName
=
PlacesUtils
.
nodeIsTagQuery
(
elt
.
_placesNode
)
?
elt
.
_placesNode
.
title
:
null
;
if
(
(
PlacesUtils
.
nodeIsFolder
(
elt
.
_placesNode
)
&
&
!
PlacesUIUtils
.
isFolderReadOnly
(
elt
.
_placesNode
)
)
|
|
PlacesUtils
.
nodeIsTagQuery
(
elt
.
_placesNode
)
)
{
if
(
eventY
-
eltY
<
eltHeight
*
0
.
2
)
{
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
resultNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
resultNode
)
orientation
:
Ci
.
nsITreeView
.
DROP_BEFORE
tagName
dropNearNode
:
elt
.
_placesNode
}
)
;
return
dropPoint
;
}
else
if
(
eventY
-
eltY
<
eltHeight
*
0
.
8
)
{
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
elt
.
_placesNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
elt
.
_placesNode
)
tagName
}
)
;
dropPoint
.
folderElt
=
elt
;
return
dropPoint
;
}
}
else
if
(
eventY
-
eltY
<
=
eltHeight
/
2
)
{
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
resultNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
resultNode
)
orientation
:
Ci
.
nsITreeView
.
DROP_BEFORE
tagName
dropNearNode
:
elt
.
_placesNode
}
)
;
return
dropPoint
;
}
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
resultNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
resultNode
)
orientation
:
Ci
.
nsITreeView
.
DROP_AFTER
tagName
dropNearNode
:
elt
.
_placesNode
}
)
;
return
dropPoint
;
}
_cleanupDragDetails
(
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
this
.
_rootView
.
_draggedElt
=
null
;
this
.
removeAttribute
(
"
dragover
"
)
;
this
.
removeAttribute
(
"
dragstart
"
)
;
this
.
_indicatorBar
.
hidden
=
true
;
}
on_DOMMenuItemActive
(
event
)
{
let
elt
=
event
.
target
;
if
(
elt
.
parentNode
!
=
this
)
{
return
;
}
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
let
parentElt
=
elt
.
parent
;
while
(
parentElt
)
{
if
(
parentElt
.
id
=
=
"
bookmarksMenuPopup
"
|
|
parentElt
.
id
=
=
"
goPopup
"
)
{
return
;
}
parentElt
=
parentElt
.
parentNode
;
}
}
if
(
window
.
XULBrowserWindow
)
{
let
placesNode
=
elt
.
_placesNode
;
var
linkURI
;
if
(
placesNode
&
&
PlacesUtils
.
nodeIsURI
(
placesNode
)
)
{
linkURI
=
placesNode
.
uri
;
}
else
if
(
elt
.
hasAttribute
(
"
targetURI
"
)
)
{
linkURI
=
elt
.
getAttribute
(
"
targetURI
"
)
;
}
if
(
linkURI
)
{
window
.
XULBrowserWindow
.
setOverLink
(
linkURI
null
)
;
}
}
}
on_DOMMenuItemInactive
(
event
)
{
let
elt
=
event
.
target
;
if
(
elt
.
parentNode
!
=
this
)
{
return
;
}
if
(
window
.
XULBrowserWindow
)
{
window
.
XULBrowserWindow
.
setOverLink
(
"
"
null
)
;
}
}
on_dragstart
(
event
)
{
let
elt
=
event
.
target
;
if
(
!
elt
.
_placesNode
)
{
return
;
}
let
draggedElt
=
elt
.
_placesNode
;
if
(
!
this
.
_rootView
.
controller
.
canMoveNode
(
draggedElt
)
)
{
event
.
dataTransfer
.
effectAllowed
=
"
copyLink
"
;
}
this
.
_rootView
.
_draggedElt
=
draggedElt
;
this
.
_rootView
.
controller
.
setDataTransfer
(
event
)
;
this
.
setAttribute
(
"
dragstart
"
"
true
"
)
;
event
.
stopPropagation
(
)
;
}
on_drop
(
event
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
event
.
target
;
let
dropPoint
=
this
.
_getDropPoint
(
event
)
;
if
(
dropPoint
&
&
dropPoint
.
ip
)
{
PlacesControllerDragHelper
.
onDrop
(
dropPoint
.
ip
event
.
dataTransfer
)
.
catch
(
Cu
.
reportError
)
;
event
.
preventDefault
(
)
;
}
this
.
_cleanupDragDetails
(
)
;
event
.
stopPropagation
(
)
;
}
on_dragover
(
event
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
event
.
target
;
let
dt
=
event
.
dataTransfer
;
let
dropPoint
=
this
.
_getDropPoint
(
event
)
;
if
(
!
dropPoint
|
|
!
dropPoint
.
ip
|
|
!
PlacesControllerDragHelper
.
canDrop
(
dropPoint
.
ip
dt
)
)
{
this
.
_indicatorBar
.
hidden
=
true
;
event
.
stopPropagation
(
)
;
return
;
}
this
.
setAttribute
(
"
dragover
"
"
true
"
)
;
if
(
dropPoint
.
folderElt
)
{
if
(
this
.
_overFolder
.
elt
&
&
this
.
_overFolder
.
elt
!
=
dropPoint
.
folderElt
)
{
this
.
_overFolder
.
clear
(
)
;
}
if
(
!
this
.
_overFolder
.
elt
)
{
this
.
_overFolder
.
elt
=
dropPoint
.
folderElt
;
this
.
_overFolder
.
openTimer
=
this
.
_overFolder
.
setTimer
(
this
.
_overFolder
.
hoverTime
)
;
}
dropPoint
.
folderElt
.
setAttribute
(
"
_moz
-
menuactive
"
true
)
;
}
else
{
this
.
_overFolder
.
clear
(
)
;
}
let
anonid
=
event
.
originalTarget
.
getAttribute
(
"
anonid
"
)
;
let
scrollDir
=
0
;
if
(
anonid
=
=
"
scrollbutton
-
up
"
)
{
scrollDir
=
-
1
;
}
else
if
(
anonid
=
=
"
scrollbutton
-
down
"
)
{
scrollDir
=
1
;
}
if
(
scrollDir
!
=
0
)
{
this
.
_scrollBox
.
scrollByIndex
(
scrollDir
true
)
;
}
if
(
dropPoint
.
folderElt
|
|
this
.
_hideDropIndicator
(
event
)
)
{
this
.
_indicatorBar
.
hidden
=
true
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
let
scrollRect
=
this
.
_scrollBox
.
getBoundingClientRect
(
)
;
let
newMarginTop
=
0
;
if
(
scrollDir
=
=
0
)
{
let
elt
=
this
.
firstElementChild
;
while
(
elt
&
&
event
.
screenY
>
elt
.
screenY
+
elt
.
getBoundingClientRect
(
)
.
height
/
2
)
{
elt
=
elt
.
nextElementSibling
;
}
newMarginTop
=
elt
?
elt
.
screenY
-
this
.
_scrollBox
.
screenY
:
scrollRect
.
height
;
}
else
if
(
scrollDir
=
=
1
)
{
newMarginTop
=
scrollRect
.
height
;
}
newMarginTop
+
=
scrollRect
.
y
-
this
.
_scrollBox
.
getBoundingClientRect
(
)
.
y
;
this
.
_indicatorBar
.
firstElementChild
.
style
.
marginTop
=
newMarginTop
+
"
px
"
;
this
.
_indicatorBar
.
hidden
=
false
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
on_dragexit
(
event
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
this
.
removeAttribute
(
"
dragover
"
)
;
let
target
=
event
.
relatedTarget
;
if
(
!
target
|
|
!
this
.
contains
(
target
)
)
{
this
.
_indicatorBar
.
hidden
=
true
;
}
if
(
this
.
_overFolder
.
elt
)
{
this
.
_overFolder
.
closeTimer
=
this
.
_overFolder
.
setTimer
(
this
.
_overFolder
.
hoverTime
)
;
}
if
(
this
.
hasAttribute
(
"
autoopened
"
)
|
|
this
.
hasAttribute
(
"
dragstart
"
)
)
{
this
.
_overFolder
.
closeMenuTimer
=
this
.
_overFolder
.
setTimer
(
this
.
_overFolder
.
hoverTime
)
;
}
event
.
stopPropagation
(
)
;
}
on_dragend
(
event
)
{
this
.
_cleanupDragDetails
(
)
;
}
}
customElements
.
define
(
"
places
-
popup
"
MozPlacesPopup
{
extends
:
"
menupopup
"
}
)
;
class
MozPlacesPopupArrow
extends
MozPlacesPopup
{
constructor
(
)
{
super
(
)
;
const
event_names
=
[
"
popupshowing
"
"
popupshown
"
"
transitionend
"
"
popuphiding
"
"
popuphidden
"
"
dragexit
"
"
dragend
"
]
;
for
(
let
event_name
of
event_names
)
{
this
.
addEventListener
(
event_name
ev
=
>
this
[
on_
{
event_name
}
]
(
ev
)
)
;
}
}
static
get
inheritedAttributes
(
)
{
return
{
"
.
panel
-
arrowcontainer
"
:
"
side
panelopen
"
"
.
panel
-
arrow
"
:
"
side
"
"
.
panel
-
arrowcontent
"
:
"
side
align
dir
orient
pack
"
}
;
}
get
markup
(
)
{
return
<
html
:
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
global
/
skin
/
global
.
css
"
/
>
<
html
:
style
>
{
this
.
commonStyles
}
<
/
html
:
style
>
<
vbox
class
=
"
panel
-
arrowcontainer
"
flex
=
"
1
"
>
<
box
class
=
"
panel
-
arrowbox
"
>
<
image
class
=
"
panel
-
arrow
"
>
<
/
image
>
<
/
box
>
<
box
class
=
"
panel
-
arrowcontent
"
part
=
"
arrowcontent
"
flex
=
"
1
"
>
<
vbox
class
=
"
menupopup
-
drop
-
indicator
-
bar
"
hidden
=
"
true
"
>
<
image
class
=
"
menupopup
-
drop
-
indicator
"
mousethrough
=
"
always
"
>
<
/
image
>
<
/
vbox
>
<
arrowscrollbox
class
=
"
popup
-
internal
-
box
"
flex
=
"
1
"
orient
=
"
vertical
"
smoothscroll
=
"
false
"
part
=
"
popupbox
"
>
<
html
:
slot
>
<
/
html
:
slot
>
<
/
arrowscrollbox
>
<
/
box
>
<
/
vbox
>
;
}
connectedCallback
(
)
{
if
(
this
.
delayConnectedCallback
(
)
)
{
return
;
}
super
.
connectedCallback
(
)
;
this
.
initializeAttributeInheritance
(
)
;
this
.
setAttribute
(
"
flip
"
"
both
"
)
;
this
.
setAttribute
(
"
side
"
"
top
"
)
;
this
.
setAttribute
(
"
position
"
"
bottomcenter
topright
"
)
;
this
.
style
.
pointerEvents
=
"
none
"
;
}
get
container
(
)
{
return
this
.
shadowRoot
.
querySelector
(
"
.
panel
-
arrowcontainer
"
)
;
}
get
arrowbox
(
)
{
return
this
.
shadowRoot
.
querySelector
(
"
.
panel
-
arrowbox
"
)
;
}
get
arrow
(
)
{
return
this
.
shadowRoot
.
querySelector
(
"
.
panel
-
arrow
"
)
;
}
adjustArrowPosition
(
)
{
let
arrow
=
this
.
arrow
;
let
anchor
=
this
.
anchorNode
;
if
(
!
anchor
)
{
arrow
.
hidden
=
true
;
return
;
}
let
container
=
this
.
container
;
let
arrowbox
=
this
.
arrowbox
;
var
position
=
this
.
alignmentPosition
;
var
offset
=
this
.
alignmentOffset
;
this
.
setAttribute
(
"
arrowposition
"
position
)
;
arrowbox
.
style
.
removeProperty
(
"
transform
"
)
;
if
(
position
.
indexOf
(
"
start_
"
)
=
=
0
|
|
position
.
indexOf
(
"
end_
"
)
=
=
0
)
{
container
.
orient
=
"
horizontal
"
;
arrowbox
.
orient
=
"
vertical
"
;
if
(
position
.
indexOf
(
"
_after
"
)
>
0
)
{
arrowbox
.
pack
=
"
end
"
;
}
else
{
arrowbox
.
pack
=
"
start
"
;
}
arrowbox
.
style
.
transform
=
"
translate
(
0
"
+
-
offset
+
"
px
)
"
;
let
isRTL
=
this
.
matches
(
"
:
-
moz
-
locale
-
dir
(
rtl
)
"
)
;
if
(
position
.
indexOf
(
"
start_
"
)
=
=
0
)
{
container
.
dir
=
"
reverse
"
;
this
.
setAttribute
(
"
side
"
isRTL
?
"
left
"
:
"
right
"
)
;
}
else
{
container
.
dir
=
"
"
;
this
.
setAttribute
(
"
side
"
isRTL
?
"
right
"
:
"
left
"
)
;
}
}
else
if
(
position
.
indexOf
(
"
before_
"
)
=
=
0
|
|
position
.
indexOf
(
"
after_
"
)
=
=
0
)
{
container
.
orient
=
"
"
;
arrowbox
.
orient
=
"
"
;
if
(
position
.
indexOf
(
"
_end
"
)
>
0
)
{
arrowbox
.
pack
=
"
end
"
;
}
else
{
arrowbox
.
pack
=
"
start
"
;
}
arrowbox
.
style
.
transform
=
"
translate
(
"
+
-
offset
+
"
px
0
)
"
;
if
(
position
.
indexOf
(
"
before_
"
)
=
=
0
)
{
container
.
dir
=
"
reverse
"
;
this
.
setAttribute
(
"
side
"
"
bottom
"
)
;
}
else
{
container
.
dir
=
"
"
;
this
.
setAttribute
(
"
side
"
"
top
"
)
;
}
}
arrow
.
hidden
=
false
;
}
on_popupshowing
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
adjustArrowPosition
(
)
;
this
.
setAttribute
(
"
animate
"
"
open
"
)
;
}
}
on_popupshown
(
event
)
{
if
(
event
.
target
!
=
this
)
{
return
;
}
this
.
setAttribute
(
"
panelopen
"
"
true
"
)
;
let
disablePointerEvents
;
if
(
!
this
.
hasAttribute
(
"
disablepointereventsfortransition
"
)
)
{
let
cs
=
getComputedStyle
(
this
.
container
)
;
let
transitionProp
=
cs
.
transitionProperty
;
let
transitionTime
=
parseFloat
(
cs
.
transitionDuration
)
;
disablePointerEvents
=
(
transitionProp
.
includes
(
"
transform
"
)
|
|
transitionProp
=
=
"
all
"
)
&
&
transitionTime
>
0
;
this
.
setAttribute
(
"
disablepointereventsfortransition
"
disablePointerEvents
)
;
}
else
{
disablePointerEvents
=
this
.
getAttribute
(
"
disablepointereventsfortransition
"
)
=
=
"
true
"
;
}
if
(
!
disablePointerEvents
)
{
this
.
style
.
removeProperty
(
"
pointer
-
events
"
)
;
}
}
on_transitionend
(
event
)
{
if
(
event
.
originalTarget
.
classList
.
contains
(
"
panel
-
arrowcontainer
"
)
&
&
(
event
.
propertyName
=
=
"
transform
"
|
|
event
.
propertyName
=
=
"
-
moz
-
window
-
transform
"
)
)
{
this
.
style
.
removeProperty
(
"
pointer
-
events
"
)
;
}
}
on_popuphiding
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
setAttribute
(
"
animate
"
"
cancel
"
)
;
}
}
on_popuphidden
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
removeAttribute
(
"
panelopen
"
)
;
if
(
this
.
getAttribute
(
"
disablepointereventsfortransition
"
)
=
=
"
true
"
)
{
this
.
style
.
pointerEvents
=
"
none
"
;
}
this
.
removeAttribute
(
"
animate
"
)
;
}
}
}
customElements
.
define
(
"
places
-
popup
-
arrow
"
MozPlacesPopupArrow
{
extends
:
"
menupopup
"
}
)
;
}
