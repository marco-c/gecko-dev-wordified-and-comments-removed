"
use
strict
"
;
{
class
MozPlacesPopup
extends
MozElements
.
MozMenuPopup
{
constructor
(
)
{
super
(
)
;
const
event_names
=
[
"
DOMMenuItemActive
"
"
DOMMenuItemInactive
"
"
dragstart
"
"
drop
"
"
dragover
"
"
dragleave
"
"
dragend
"
]
;
for
(
let
event_name
of
event_names
)
{
this
.
addEventListener
(
event_name
this
)
;
}
}
get
markup
(
)
{
return
<
html
:
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
global
/
skin
/
global
.
css
"
/
>
<
hbox
flex
=
"
1
"
>
<
vbox
part
=
"
drop
-
indicator
-
bar
"
hidden
=
"
true
"
>
<
image
part
=
"
drop
-
indicator
"
/
>
<
/
vbox
>
<
arrowscrollbox
class
=
"
menupopup
-
arrowscrollbox
"
flex
=
"
1
"
orient
=
"
vertical
"
exportparts
=
"
scrollbox
:
arrowscrollbox
-
scrollbox
"
smoothscroll
=
"
false
"
part
=
"
arrowscrollbox
content
"
>
<
html
:
slot
/
>
<
/
arrowscrollbox
>
<
/
hbox
>
;
}
connectedCallback
(
)
{
if
(
this
.
delayConnectedCallback
(
)
)
{
return
;
}
this
.
_overFolder
=
{
_self
:
this
_folder
:
{
elt
:
null
openTimer
:
null
hoverTime
:
350
closeTimer
:
null
}
_closeMenuTimer
:
null
get
elt
(
)
{
return
this
.
_folder
.
elt
;
}
set
elt
(
val
)
{
this
.
_folder
.
elt
=
val
;
}
get
openTimer
(
)
{
return
this
.
_folder
.
openTimer
;
}
set
openTimer
(
val
)
{
this
.
_folder
.
openTimer
=
val
;
}
get
hoverTime
(
)
{
return
this
.
_folder
.
hoverTime
;
}
set
hoverTime
(
val
)
{
this
.
_folder
.
hoverTime
=
val
;
}
get
closeTimer
(
)
{
return
this
.
_folder
.
closeTimer
;
}
set
closeTimer
(
val
)
{
this
.
_folder
.
closeTimer
=
val
;
}
get
closeMenuTimer
(
)
{
return
this
.
_closeMenuTimer
;
}
set
closeMenuTimer
(
val
)
{
this
.
_closeMenuTimer
=
val
;
}
setTimer
:
function
OF__setTimer
(
aTime
)
{
var
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
this
aTime
timer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
notify
:
function
OF__notify
(
aTimer
)
{
if
(
aTimer
=
=
this
.
_folder
.
openTimer
)
{
this
.
_folder
.
elt
.
lastElementChild
.
setAttribute
(
"
autoopened
"
"
true
"
)
;
this
.
_folder
.
elt
.
lastElementChild
.
openPopup
(
)
;
this
.
_folder
.
openTimer
=
null
;
}
else
if
(
aTimer
=
=
this
.
_folder
.
closeTimer
)
{
var
draggingOverChild
=
PlacesControllerDragHelper
.
draggingOverChildNode
(
this
.
_folder
.
elt
)
;
if
(
draggingOverChild
)
{
this
.
_folder
.
elt
=
null
;
}
this
.
clear
(
)
;
if
(
!
draggingOverChild
)
{
this
.
closeParentMenus
(
)
;
}
}
else
if
(
aTimer
=
=
this
.
closeMenuTimer
)
{
var
popup
=
this
.
_self
;
if
(
PlacesControllerDragHelper
.
getSession
(
)
&
&
!
PlacesControllerDragHelper
.
draggingOverChildNode
(
popup
.
parentNode
)
)
{
popup
.
hidePopup
(
)
;
this
.
closeParentMenus
(
)
;
}
this
.
_closeMenuTimer
=
null
;
}
}
closeParentMenus
:
function
OF__closeParentMenus
(
)
{
var
popup
=
this
.
_self
;
var
parent
=
popup
.
parentNode
;
while
(
parent
)
{
if
(
parent
.
localName
=
=
"
menupopup
"
&
&
parent
.
_placesNode
)
{
if
(
PlacesControllerDragHelper
.
draggingOverChildNode
(
parent
.
parentNode
)
)
{
break
;
}
parent
.
hidePopup
(
)
;
}
parent
=
parent
.
parentNode
;
}
}
clear
:
function
OF__clear
(
)
{
if
(
this
.
_folder
.
elt
&
&
this
.
_folder
.
elt
.
lastElementChild
)
{
if
(
!
this
.
_folder
.
elt
.
lastElementChild
.
hasAttribute
(
"
dragover
"
)
)
{
this
.
_folder
.
elt
.
lastElementChild
.
hidePopup
(
)
;
}
this
.
_folder
.
elt
.
removeAttribute
(
"
_moz
-
menuactive
"
)
;
this
.
_folder
.
elt
=
null
;
}
if
(
this
.
_folder
.
openTimer
)
{
this
.
_folder
.
openTimer
.
cancel
(
)
;
this
.
_folder
.
openTimer
=
null
;
}
if
(
this
.
_folder
.
closeTimer
)
{
this
.
_folder
.
closeTimer
.
cancel
(
)
;
this
.
_folder
.
closeTimer
=
null
;
}
}
}
;
}
get
_indicatorBar
(
)
{
if
(
!
this
.
__indicatorBar
)
{
this
.
__indicatorBar
=
this
.
shadowRoot
.
querySelector
(
"
[
part
=
drop
-
indicator
-
bar
]
"
)
;
}
return
this
.
__indicatorBar
;
}
get
_rootView
(
)
{
if
(
!
this
.
__rootView
)
{
this
.
__rootView
=
PlacesUIUtils
.
getViewForNode
(
this
)
;
}
return
this
.
__rootView
;
}
_hideDropIndicator
(
aEvent
)
{
let
target
=
aEvent
.
target
;
let
betweenMarkers
=
this
.
_startMarker
.
compareDocumentPosition
(
target
)
&
Node
.
DOCUMENT_POSITION_FOLLOWING
&
&
this
.
_endMarker
.
compareDocumentPosition
(
target
)
&
Node
.
DOCUMENT_POSITION_PRECEDING
;
return
!
(
target
&
&
target
.
_placesNode
&
&
betweenMarkers
)
;
}
_getDropPoint
(
aEvent
)
{
let
resultNode
=
this
.
_placesNode
;
if
(
!
PlacesUtils
.
nodeIsFolder
(
resultNode
)
|
|
this
.
_rootView
.
controller
.
disallowInsertion
(
resultNode
)
)
{
return
null
;
}
var
dropPoint
=
{
ip
:
null
folderElt
:
null
}
;
let
elt
=
aEvent
.
target
;
if
(
elt
.
localName
=
=
"
menupopup
"
)
{
elt
=
elt
.
parentNode
;
}
let
eventY
=
aEvent
.
clientY
;
let
{
y
:
eltY
height
:
eltHeight
}
=
elt
.
getBoundingClientRect
(
)
;
if
(
!
elt
.
_placesNode
)
{
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
resultNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
resultNode
)
}
)
;
let
isMenu
=
elt
.
localName
=
=
"
menu
"
|
|
(
elt
.
localName
=
=
"
toolbarbutton
"
&
&
elt
.
getAttribute
(
"
type
"
)
=
=
"
menu
"
)
;
if
(
isMenu
&
&
elt
.
lastElementChild
&
&
elt
.
lastElementChild
.
hasAttribute
(
"
placespopup
"
)
)
{
dropPoint
.
folderElt
=
elt
;
}
return
dropPoint
;
}
let
tagName
=
PlacesUtils
.
nodeIsTagQuery
(
elt
.
_placesNode
)
?
elt
.
_placesNode
.
title
:
null
;
if
(
(
PlacesUtils
.
nodeIsFolder
(
elt
.
_placesNode
)
&
&
!
PlacesUIUtils
.
isFolderReadOnly
(
elt
.
_placesNode
)
)
|
|
PlacesUtils
.
nodeIsTagQuery
(
elt
.
_placesNode
)
)
{
if
(
eventY
-
eltY
<
eltHeight
*
0
.
2
)
{
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
resultNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
resultNode
)
orientation
:
Ci
.
nsITreeView
.
DROP_BEFORE
tagName
dropNearNode
:
elt
.
_placesNode
}
)
;
return
dropPoint
;
}
else
if
(
eventY
-
eltY
<
eltHeight
*
0
.
8
)
{
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
elt
.
_placesNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
elt
.
_placesNode
)
tagName
}
)
;
dropPoint
.
folderElt
=
elt
;
return
dropPoint
;
}
}
else
if
(
eventY
-
eltY
<
=
eltHeight
/
2
)
{
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
resultNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
resultNode
)
orientation
:
Ci
.
nsITreeView
.
DROP_BEFORE
tagName
dropNearNode
:
elt
.
_placesNode
}
)
;
return
dropPoint
;
}
dropPoint
.
ip
=
new
PlacesInsertionPoint
(
{
parentId
:
PlacesUtils
.
getConcreteItemId
(
resultNode
)
parentGuid
:
PlacesUtils
.
getConcreteItemGuid
(
resultNode
)
orientation
:
Ci
.
nsITreeView
.
DROP_AFTER
tagName
dropNearNode
:
elt
.
_placesNode
}
)
;
return
dropPoint
;
}
_cleanupDragDetails
(
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
this
.
_rootView
.
_draggedElt
=
null
;
this
.
removeAttribute
(
"
dragover
"
)
;
this
.
removeAttribute
(
"
dragstart
"
)
;
this
.
_indicatorBar
.
hidden
=
true
;
}
on_DOMMenuItemActive
(
event
)
{
if
(
super
.
on_DOMMenuItemActive
)
{
super
.
on_DOMMenuItemActive
(
event
)
;
}
let
elt
=
event
.
target
;
if
(
elt
.
parentNode
!
=
this
)
{
return
;
}
if
(
window
.
XULBrowserWindow
)
{
let
placesNode
=
elt
.
_placesNode
;
var
linkURI
;
if
(
placesNode
&
&
PlacesUtils
.
nodeIsURI
(
placesNode
)
)
{
linkURI
=
placesNode
.
uri
;
}
else
if
(
elt
.
hasAttribute
(
"
targetURI
"
)
)
{
linkURI
=
elt
.
getAttribute
(
"
targetURI
"
)
;
}
if
(
linkURI
)
{
window
.
XULBrowserWindow
.
setOverLink
(
linkURI
)
;
}
}
}
on_DOMMenuItemInactive
(
event
)
{
let
elt
=
event
.
target
;
if
(
elt
.
parentNode
!
=
this
)
{
return
;
}
if
(
window
.
XULBrowserWindow
)
{
window
.
XULBrowserWindow
.
setOverLink
(
"
"
)
;
}
}
on_dragstart
(
event
)
{
let
elt
=
event
.
target
;
if
(
!
elt
.
_placesNode
)
{
return
;
}
let
draggedElt
=
elt
.
_placesNode
;
if
(
!
this
.
_rootView
.
controller
.
canMoveNode
(
draggedElt
)
)
{
event
.
dataTransfer
.
effectAllowed
=
"
copyLink
"
;
}
this
.
_rootView
.
_draggedElt
=
draggedElt
;
this
.
_rootView
.
controller
.
setDataTransfer
(
event
)
;
this
.
setAttribute
(
"
dragstart
"
"
true
"
)
;
event
.
stopPropagation
(
)
;
}
on_drop
(
event
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
event
.
target
;
let
dropPoint
=
this
.
_getDropPoint
(
event
)
;
if
(
dropPoint
&
&
dropPoint
.
ip
)
{
PlacesControllerDragHelper
.
onDrop
(
dropPoint
.
ip
event
.
dataTransfer
)
.
catch
(
Cu
.
reportError
)
;
event
.
preventDefault
(
)
;
}
this
.
_cleanupDragDetails
(
)
;
event
.
stopPropagation
(
)
;
}
on_dragover
(
event
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
event
.
target
;
let
dt
=
event
.
dataTransfer
;
let
dropPoint
=
this
.
_getDropPoint
(
event
)
;
if
(
!
dropPoint
|
|
!
dropPoint
.
ip
|
|
!
PlacesControllerDragHelper
.
canDrop
(
dropPoint
.
ip
dt
)
)
{
this
.
_indicatorBar
.
hidden
=
true
;
event
.
stopPropagation
(
)
;
return
;
}
this
.
setAttribute
(
"
dragover
"
"
true
"
)
;
if
(
dropPoint
.
folderElt
)
{
if
(
this
.
_overFolder
.
elt
&
&
this
.
_overFolder
.
elt
!
=
dropPoint
.
folderElt
)
{
this
.
_overFolder
.
clear
(
)
;
}
if
(
!
this
.
_overFolder
.
elt
)
{
this
.
_overFolder
.
elt
=
dropPoint
.
folderElt
;
this
.
_overFolder
.
openTimer
=
this
.
_overFolder
.
setTimer
(
this
.
_overFolder
.
hoverTime
)
;
}
dropPoint
.
folderElt
.
setAttribute
(
"
_moz
-
menuactive
"
true
)
;
}
else
{
this
.
_overFolder
.
clear
(
)
;
}
let
scrollDir
=
0
;
if
(
event
.
originalTarget
=
=
this
.
scrollBox
.
_scrollButtonUp
)
{
scrollDir
=
-
1
;
}
else
if
(
event
.
originalTarget
=
=
this
.
scrollBox
.
_scrollButtonDown
)
{
scrollDir
=
1
;
}
if
(
scrollDir
!
=
0
)
{
this
.
scrollBox
.
scrollByIndex
(
scrollDir
true
)
;
}
if
(
dropPoint
.
folderElt
|
|
this
.
_hideDropIndicator
(
event
)
)
{
this
.
_indicatorBar
.
hidden
=
true
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
let
scrollRect
=
this
.
scrollBox
.
getBoundingClientRect
(
)
;
let
newMarginTop
=
0
;
if
(
scrollDir
=
=
0
)
{
let
elt
=
this
.
firstElementChild
;
while
(
elt
&
&
event
.
screenY
>
elt
.
screenY
+
elt
.
getBoundingClientRect
(
)
.
height
/
2
)
{
elt
=
elt
.
nextElementSibling
;
}
newMarginTop
=
elt
?
elt
.
screenY
-
this
.
scrollBox
.
screenY
:
scrollRect
.
height
;
}
else
if
(
scrollDir
=
=
1
)
{
newMarginTop
=
scrollRect
.
height
;
}
newMarginTop
+
=
scrollRect
.
y
-
this
.
_indicatorBar
.
parentNode
.
getBoundingClientRect
(
)
.
y
;
this
.
_indicatorBar
.
firstElementChild
.
style
.
marginTop
=
newMarginTop
+
"
px
"
;
this
.
_indicatorBar
.
hidden
=
false
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
on_dragleave
(
event
)
{
PlacesControllerDragHelper
.
currentDropTarget
=
null
;
this
.
removeAttribute
(
"
dragover
"
)
;
let
target
=
event
.
relatedTarget
;
if
(
!
target
|
|
!
this
.
contains
(
target
)
)
{
this
.
_indicatorBar
.
hidden
=
true
;
}
if
(
this
.
_overFolder
.
elt
)
{
this
.
_overFolder
.
closeTimer
=
this
.
_overFolder
.
setTimer
(
this
.
_overFolder
.
hoverTime
)
;
}
if
(
this
.
hasAttribute
(
"
autoopened
"
)
|
|
this
.
hasAttribute
(
"
dragstart
"
)
)
{
this
.
_overFolder
.
closeMenuTimer
=
this
.
_overFolder
.
setTimer
(
this
.
_overFolder
.
hoverTime
)
;
}
event
.
stopPropagation
(
)
;
}
on_dragend
(
event
)
{
this
.
_cleanupDragDetails
(
)
;
}
}
customElements
.
define
(
"
places
-
popup
"
MozPlacesPopup
{
extends
:
"
menupopup
"
}
)
;
class
MozPlacesPopupArrow
extends
MozPlacesPopup
{
constructor
(
)
{
super
(
)
;
const
event_names
=
[
"
popupshowing
"
"
popuppositioned
"
"
popupshown
"
"
popuphiding
"
"
popuphidden
"
]
;
for
(
let
event_name
of
event_names
)
{
this
.
addEventListener
(
event_name
this
)
;
}
}
connectedCallback
(
)
{
if
(
this
.
delayConnectedCallback
(
)
)
{
return
;
}
super
.
connectedCallback
(
)
;
this
.
initializeAttributeInheritance
(
)
;
this
.
setAttribute
(
"
flip
"
"
both
"
)
;
this
.
setAttribute
(
"
side
"
"
top
"
)
;
this
.
setAttribute
(
"
position
"
"
bottomcenter
topright
"
)
;
}
_setSideAttribute
(
event
)
{
if
(
!
this
.
anchorNode
)
{
return
;
}
var
position
=
event
.
alignmentPosition
;
if
(
position
.
indexOf
(
"
start_
"
)
=
=
0
|
|
position
.
indexOf
(
"
end_
"
)
=
=
0
)
{
let
isRTL
=
this
.
matches
(
"
:
-
moz
-
locale
-
dir
(
rtl
)
"
)
;
if
(
position
.
indexOf
(
"
start_
"
)
=
=
0
)
{
this
.
setAttribute
(
"
side
"
isRTL
?
"
left
"
:
"
right
"
)
;
}
else
{
this
.
setAttribute
(
"
side
"
isRTL
?
"
right
"
:
"
left
"
)
;
}
}
else
if
(
position
.
indexOf
(
"
before_
"
)
=
=
0
|
|
position
.
indexOf
(
"
after_
"
)
=
=
0
)
{
if
(
position
.
indexOf
(
"
before_
"
)
=
=
0
)
{
this
.
setAttribute
(
"
side
"
"
bottom
"
)
;
}
else
{
this
.
setAttribute
(
"
side
"
"
top
"
)
;
}
}
}
on_popupshowing
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
setAttribute
(
"
animate
"
"
open
"
)
;
this
.
style
.
pointerEvents
=
"
none
"
;
}
}
on_popuppositioned
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
_setSideAttribute
(
event
)
;
}
}
on_popupshown
(
event
)
{
if
(
event
.
target
!
=
this
)
{
return
;
}
this
.
setAttribute
(
"
panelopen
"
"
true
"
)
;
this
.
style
.
removeProperty
(
"
pointer
-
events
"
)
;
}
on_popuphiding
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
setAttribute
(
"
animate
"
"
cancel
"
)
;
}
}
on_popuphidden
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
removeAttribute
(
"
panelopen
"
)
;
this
.
removeAttribute
(
"
animate
"
)
;
}
}
}
customElements
.
define
(
"
places
-
popup
-
arrow
"
MozPlacesPopupArrow
{
extends
:
"
menupopup
"
}
)
;
}
