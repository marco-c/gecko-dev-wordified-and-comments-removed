const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Interactions
:
"
resource
:
/
/
/
modules
/
Interactions
.
jsm
"
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
SnapshotGroups
:
"
resource
:
/
/
/
modules
/
SnapshotGroups
.
jsm
"
Snapshots
:
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
SnapshotMonitor
:
"
resource
:
/
/
/
modules
/
SnapshotMonitor
.
jsm
"
SnapshotScorer
:
"
resource
:
/
/
/
modules
/
SnapshotScorer
.
jsm
"
SnapshotSelector
:
"
resource
:
/
/
/
modules
/
SnapshotSelector
.
jsm
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
}
)
;
var
gProfD
=
do_get_profile
(
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
pagethumbnails
.
capturing_disabled
"
true
)
;
const
TOPIC_ADDED
=
"
places
-
snapshots
-
added
"
;
const
TOPIC_DELETED
=
"
places
-
snapshots
-
deleted
"
;
async
function
addInteractions
(
interactions
)
{
await
PlacesTestUtils
.
addVisits
(
interactions
.
map
(
i
=
>
i
.
url
)
)
;
for
(
let
interaction
of
interactions
)
{
await
Interactions
.
store
.
add
(
{
url
:
interaction
.
url
title
:
interaction
.
title
documentType
:
interaction
.
documentType
?
?
Interactions
.
DOCUMENT_TYPE
.
GENERIC
totalViewTime
:
interaction
.
totalViewTime
?
?
0
typingTime
:
interaction
.
typingTime
?
?
0
keypresses
:
interaction
.
keypresses
?
?
0
scrollingTime
:
interaction
.
scrollingTime
?
?
0
scrollingDistance
:
interaction
.
scrollingDistance
?
?
0
created_at
:
interaction
.
created_at
|
|
Date
.
now
(
)
updated_at
:
interaction
.
updated_at
|
|
Date
.
now
(
)
referrer
:
interaction
.
referrer
|
|
"
"
}
)
;
}
await
Interactions
.
store
.
flush
(
)
;
}
async
function
getInteractions
(
)
{
const
columns
=
[
"
id
"
"
place_id
"
"
url
"
"
updated_at
"
"
total_view_time
"
"
typing_time
"
"
key_presses
"
]
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
m
.
id
AS
id
h
.
id
AS
place_id
h
.
url
AS
url
updated_at
total_view_time
typing_time
key_presses
FROM
moz_places_metadata
m
JOIN
moz_places
h
ON
h
.
id
=
m
.
place_id
ORDER
BY
updated_at
DESC
)
;
return
rows
.
map
(
r
=
>
{
let
result
=
{
}
;
for
(
let
column
of
columns
)
{
result
[
column
]
=
r
.
getResultByName
(
column
)
;
}
return
result
;
}
)
;
}
async
function
assertUrlNotification
(
topic
expected
task
)
{
let
seen
=
false
;
let
listener
=
(
subject
_
data
)
=
>
{
try
{
let
arr
=
JSON
.
parse
(
data
)
;
if
(
arr
.
length
!
=
expected
.
length
)
{
return
;
}
if
(
expected
.
every
(
url
=
>
arr
.
includes
(
url
)
)
)
{
seen
=
true
;
}
}
catch
(
e
)
{
Assert
.
ok
(
false
e
)
;
}
}
;
Services
.
obs
.
addObserver
(
listener
topic
)
;
await
task
(
)
;
Services
.
obs
.
removeObserver
(
listener
topic
)
;
Assert
.
ok
(
seen
Should
have
seen
{
topic
}
notification
.
)
;
}
async
function
assertTopicNotObserved
(
topic
task
)
{
let
seen
=
false
;
let
listener
=
(
)
=
>
{
seen
=
true
;
}
;
Services
.
obs
.
addObserver
(
listener
topic
)
;
await
task
(
)
;
Services
.
obs
.
removeObserver
(
listener
topic
)
;
Assert
.
ok
(
!
seen
Should
not
have
seen
{
topic
}
notification
.
)
;
}
function
assertRecentDate
(
date
)
{
Assert
.
greater
(
date
.
getTime
(
)
Date
.
now
(
)
-
1000
*
60
*
60
*
24
"
Should
have
a
reasonable
value
for
the
date
"
)
;
}
function
assertSnapshot
(
actual
expected
)
{
Assert
.
equal
(
actual
.
url
expected
.
url
"
Should
have
the
expected
URL
"
)
;
let
expectedTitle
=
test
visit
for
{
expected
.
url
}
;
if
(
expected
.
hasOwnProperty
(
"
title
"
)
)
{
expectedTitle
=
expected
.
title
;
}
Assert
.
equal
(
actual
.
title
expectedTitle
"
Should
have
the
expected
title
"
)
;
Assert
.
strictEqual
(
actual
.
userPersisted
expected
.
userPersisted
?
?
Snapshots
.
USER_PERSISTED
.
NO
"
Should
have
the
expected
user
persisted
value
"
)
;
Assert
.
strictEqual
(
actual
.
documentType
expected
.
documentType
?
?
Interactions
.
DOCUMENT_TYPE
.
GENERIC
"
Should
have
the
expected
document
type
"
)
;
assertRecentDate
(
actual
.
createdAt
)
;
assertRecentDate
(
actual
.
lastInteractionAt
)
;
if
(
actual
.
firstInteractionAt
|
|
!
actual
.
userPersisted
)
{
assertRecentDate
(
actual
.
firstInteractionAt
)
;
}
if
(
expected
.
lastUpdated
)
{
Assert
.
greaterOrEqual
(
actual
.
lastInteractionAt
expected
.
lastUpdated
"
Should
have
a
last
interaction
time
greater
than
or
equal
to
the
expected
last
updated
time
"
)
;
}
if
(
expected
.
commonName
)
{
Assert
.
equal
(
actual
.
commonName
expected
.
commonName
"
Should
have
the
Snapshot
URL
'
s
common
name
.
"
)
;
}
if
(
expected
.
overlappingVisitScoreIs
!
=
null
)
{
Assert
.
equal
(
actual
.
overlappingVisitScore
expected
.
overlappingVisitScoreIs
"
Should
have
an
overlappingVisitScore
equal
to
the
expected
score
"
)
;
}
if
(
expected
.
overlappingVisitScoreGreaterThan
!
=
null
)
{
Assert
.
greater
(
actual
.
overlappingVisitScore
expected
.
overlappingVisitScoreGreaterThan
"
Should
have
an
overlappingVisitScore
greater
than
the
expected
score
"
)
;
}
if
(
expected
.
overlappingVisitScoreLessThan
!
=
null
)
{
Assert
.
less
(
actual
.
overlappingVisitScore
expected
.
overlappingVisitScoreLessThan
"
Should
have
an
overlappingVisitScore
less
than
the
expected
score
"
)
;
}
if
(
expected
.
overlappingVisitScoreLessThanEqualTo
!
=
null
)
{
Assert
.
lessOrEqual
(
actual
.
overlappingVisitScore
expected
.
overlappingVisitScoreLessThanEqualTo
"
Should
have
an
overlappingVisitScore
less
than
or
equal
to
the
expected
score
"
)
;
}
if
(
expected
.
removedAt
)
{
Assert
.
greaterOrEqual
(
actual
.
removedAt
.
getTime
(
)
expected
.
removedAt
.
getTime
(
)
"
Should
have
the
removed
at
time
greater
than
or
equal
to
the
expected
removed
at
time
"
)
;
}
else
{
Assert
.
strictEqual
(
actual
.
removedAt
null
"
Should
not
have
a
removed
at
time
"
)
;
}
if
(
expected
.
commonReferrerScoreEqualTo
!
=
null
)
{
Assert
.
equal
(
actual
.
commonReferrerScore
expected
.
commonReferrerScoreEqualTo
"
Should
have
a
commonReferrerScore
equal
to
the
expected
score
"
)
;
}
}
async
function
assertSnapshotList
(
received
expected
)
{
info
(
Found
{
received
.
length
}
snapshots
:
\
n
{
JSON
.
stringify
(
received
)
}
)
;
Assert
.
equal
(
received
.
length
expected
.
length
"
Should
have
the
expected
number
of
snapshots
"
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
i
+
+
)
{
assertSnapshot
(
received
[
i
]
expected
[
i
]
)
;
}
}
async
function
assertSnapshots
(
expected
options
)
{
let
snapshots
=
await
Snapshots
.
query
(
options
)
;
await
assertSnapshotList
(
snapshots
expected
)
;
}
function
assertSnapshotGroup
(
group
expected
)
{
if
(
expected
.
title
!
=
null
)
{
Assert
.
equal
(
group
.
title
expected
.
title
"
Should
have
the
expected
title
"
)
;
}
if
(
expected
.
builder
!
=
null
)
{
Assert
.
equal
(
group
.
builder
expected
.
builder
"
Should
have
the
expected
builder
"
)
;
}
if
(
expected
.
builderMetadata
!
=
null
)
{
Assert
.
deepEqual
(
group
.
builderMetadata
expected
.
builderMetadata
"
Should
have
the
expected
builderMetadata
"
)
;
}
if
(
expected
.
snapshotCount
!
=
null
)
{
Assert
.
equal
(
group
.
snapshotCount
expected
.
snapshotCount
"
Should
have
the
expected
snapshotCount
"
)
;
}
if
(
expected
.
lastAccessed
!
=
null
)
{
Assert
.
equal
(
group
.
lastAccessed
expected
.
lastAccessed
"
Should
have
the
expected
lastAccessed
value
"
)
;
}
}
async
function
assertOverlappingSnapshots
(
expected
context
)
{
let
snapshots
=
await
Snapshots
.
queryOverlapping
(
context
.
url
)
;
await
assertSnapshotList
(
snapshots
expected
)
;
}
async
function
assertCommonReferrerSnapshots
(
expected
context
)
{
let
snapshots
=
await
Snapshots
.
queryCommonReferrer
(
context
.
url
)
;
await
assertSnapshotList
(
snapshots
expected
)
;
}
async
function
reset
(
)
{
await
Snapshots
.
reset
(
)
;
await
Interactions
.
reset
(
)
;
}
function
assertSnapshotScores
(
combinedSnapshots
expectedSnapshots
)
{
Assert
.
equal
(
combinedSnapshots
.
length
expectedSnapshots
.
length
"
Should
have
returned
the
correct
amount
of
snapshots
"
)
;
for
(
let
i
=
0
;
i
<
combinedSnapshots
.
length
;
i
+
+
)
{
Assert
.
equal
(
combinedSnapshots
[
i
]
.
url
expectedSnapshots
[
i
]
.
url
"
Should
have
returned
the
expected
URL
for
the
snapshot
"
)
;
Assert
.
equal
(
combinedSnapshots
[
i
]
.
relevancyScore
expectedSnapshots
[
i
]
.
score
Should
have
set
the
expected
score
for
{
expectedSnapshots
[
i
]
.
url
}
)
;
}
}
