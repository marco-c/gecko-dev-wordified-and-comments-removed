var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
commonFile
=
do_get_file
(
"
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
toolkit
/
components
/
places
/
tests
/
head_common
.
js
"
false
)
;
if
(
commonFile
)
{
let
uri
=
Services
.
io
.
newFileURI
(
commonFile
)
;
Services
.
scriptloader
.
loadSubScript
(
uri
.
spec
this
)
;
}
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUIUtils
"
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
)
;
const
{
updateAppInfo
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
)
;
updateAppInfo
(
{
name
:
"
PlacesTest
"
ID
:
"
{
230de50e
-
4cd1
-
11dc
-
8314
-
0800200c9a66
}
"
version
:
"
1
"
platformVersion
:
"
"
}
)
;
const
DEFAULT_BOOKMARKS_ON_TOOLBAR
=
1
;
const
DEFAULT_BOOKMARKS_ON_MENU
=
1
;
function
checkItemHasAnnotation
(
guid
name
)
{
return
PlacesUtils
.
promiseItemId
(
guid
)
.
then
(
id
=
>
{
let
hasAnnotation
=
PlacesUtils
.
annotations
.
itemHasAnnotation
(
id
name
)
;
Assert
.
ok
(
hasAnnotation
Expected
annotation
{
name
}
)
;
}
)
;
}
var
createCorruptDB
=
async
function
(
)
{
let
dbPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
places
.
sqlite
"
)
;
await
IOUtils
.
remove
(
dbPath
)
;
let
src
=
OS
.
Path
.
join
(
do_get_cwd
(
)
.
path
"
corruptDB
.
sqlite
"
)
;
await
IOUtils
.
copy
(
src
dbPath
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
dbPath
)
"
should
have
a
DB
now
"
)
;
}
;
const
SINGLE_TRY_TIMEOUT
=
100
;
const
NUMBER_OF_TRIES
=
30
;
var
waitForResolvedPromise
=
async
function
(
promiseFn
timeoutMsg
tryCount
=
NUMBER_OF_TRIES
)
{
let
tries
=
0
;
do
{
try
{
let
value
=
await
promiseFn
(
)
;
return
value
;
}
catch
(
ex
)
{
}
await
new
Promise
(
resolve
=
>
do_timeout
(
SINGLE_TRY_TIMEOUT
resolve
)
)
;
}
while
(
+
+
tries
<
=
tryCount
)
;
throw
new
Error
(
timeoutMsg
)
;
}
;
