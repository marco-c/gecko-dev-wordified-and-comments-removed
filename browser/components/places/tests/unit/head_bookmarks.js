var
Ci
=
Components
.
interfaces
;
var
Cc
=
Components
.
classes
;
var
Cr
=
Components
.
results
;
var
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoadContextInfo
.
jsm
"
)
;
var
commonFile
=
do_get_file
(
"
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
toolkit
/
components
/
places
/
tests
/
head_common
.
js
"
false
)
;
if
(
commonFile
)
{
let
uri
=
Services
.
io
.
newFileURI
(
commonFile
)
;
Services
.
scriptloader
.
loadSubScript
(
uri
.
spec
this
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
PlacesUIUtils
"
function
(
)
{
Cu
.
import
(
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
)
;
return
PlacesUIUtils
;
}
)
;
const
ORGANIZER_FOLDER_ANNO
=
"
PlacesOrganizer
/
OrganizerFolder
"
;
const
ORGANIZER_QUERY_ANNO
=
"
PlacesOrganizer
/
OrganizerQuery
"
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
this
)
;
updateAppInfo
(
{
name
:
"
PlacesTest
"
ID
:
"
{
230de50e
-
4cd1
-
11dc
-
8314
-
0800200c9a66
}
"
version
:
"
1
"
platformVersion
:
"
"
}
)
;
const
SMART_BOOKMARKS_VERSION
=
8
;
const
SMART_BOOKMARKS_ON_TOOLBAR
=
1
;
const
SMART_BOOKMARKS_ON_MENU
=
2
;
const
DEFAULT_BOOKMARKS_ON_TOOLBAR
=
1
;
const
DEFAULT_BOOKMARKS_ON_MENU
=
1
;
const
SMART_BOOKMARKS_ANNO
=
"
Places
/
SmartBookmark
"
;
function
checkItemHasAnnotation
(
guid
name
)
{
return
PlacesUtils
.
promiseItemId
(
guid
)
.
then
(
id
=
>
{
let
hasAnnotation
=
PlacesUtils
.
annotations
.
itemHasAnnotation
(
id
name
)
;
Assert
.
ok
(
hasAnnotation
Expected
annotation
{
name
}
)
;
}
)
;
}
var
createCorruptDB
=
Task
.
async
(
function
*
(
)
{
let
dbPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
places
.
sqlite
"
)
;
yield
OS
.
File
.
remove
(
dbPath
)
;
let
dir
=
yield
OS
.
File
.
getCurrentDirectory
(
)
;
let
src
=
OS
.
Path
.
join
(
dir
"
corruptDB
.
sqlite
"
)
;
yield
OS
.
File
.
copy
(
src
dbPath
)
;
Assert
.
ok
(
(
yield
OS
.
File
.
exists
(
dbPath
)
)
"
should
have
a
DB
now
"
)
;
}
)
;
function
rebuildSmartBookmarks
(
)
{
let
consoleListener
=
{
observe
(
aMsg
)
{
do_throw
(
"
Got
console
message
:
"
+
aMsg
.
message
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIConsoleListener
]
)
}
;
Services
.
console
.
reset
(
)
;
Services
.
console
.
registerListener
(
consoleListener
)
;
do_register_cleanup
(
(
)
=
>
{
try
{
Services
.
console
.
unregisterListener
(
consoleListener
)
;
}
catch
(
ex
)
{
}
}
)
;
Cc
[
"
mozilla
.
org
/
browser
/
browserglue
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
observe
(
null
"
browser
-
glue
-
test
"
"
smart
-
bookmarks
-
init
"
)
;
return
promiseTopicObserved
(
"
test
-
smart
-
bookmarks
-
done
"
)
.
then
(
(
)
=
>
{
Services
.
console
.
unregisterListener
(
consoleListener
)
;
}
)
;
}
const
SINGLE_TRY_TIMEOUT
=
100
;
const
NUMBER_OF_TRIES
=
30
;
var
waitForResolvedPromise
=
Task
.
async
(
function
*
(
promiseFn
timeoutMsg
tryCount
=
NUMBER_OF_TRIES
)
{
let
tries
=
0
;
do
{
try
{
let
value
=
yield
promiseFn
(
)
;
return
value
;
}
catch
(
ex
)
{
}
yield
new
Promise
(
resolve
=
>
do_timeout
(
SINGLE_TRY_TIMEOUT
resolve
)
)
;
}
while
(
+
+
tries
<
=
tryCount
)
;
throw
new
Error
(
timeoutMsg
)
;
}
)
;
