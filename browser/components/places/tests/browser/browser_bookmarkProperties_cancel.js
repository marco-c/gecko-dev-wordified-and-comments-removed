"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
testing
-
common
/
sinon
-
2
.
3
.
2
.
js
"
)
;
const
sandbox
=
sinon
.
sandbox
.
create
(
)
;
registerCleanupFunction
(
async
function
(
)
{
sandbox
.
restore
(
)
;
delete
window
.
sinon
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesTestUtils
.
clearHistory
(
)
;
}
)
;
let
bookmarks
;
let
bookmarkIds
;
add_task
(
async
function
setup
(
)
{
bookmarks
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
[
{
title
:
"
bm1
"
url
:
"
http
:
/
/
example
.
com
"
}
{
title
:
"
bm2
"
url
:
"
http
:
/
/
example
.
com
/
2
"
}
]
}
)
;
bookmarkIds
=
await
PlacesUtils
.
promiseManyItemIds
(
[
bookmarks
[
0
]
.
guid
bookmarks
[
1
]
.
guid
]
)
;
sandbox
.
stub
(
PlacesTransactions
"
undo
"
)
.
returns
(
Promise
.
resolve
(
)
)
;
}
)
;
add_task
(
async
function
test_cancel_with_no_changes
(
)
{
if
(
!
PlacesUIUtils
.
useAsyncTransactions
)
{
Assert
.
ok
(
true
"
Skipping
test
as
async
transactions
are
turned
off
"
)
;
return
;
}
await
withSidebarTree
(
"
bookmarks
"
async
(
tree
)
=
>
{
tree
.
selectItems
(
[
bookmarkIds
.
get
(
bookmarks
[
0
]
.
guid
)
]
)
;
await
tree
.
controller
.
remove
(
"
Remove
Selection
"
)
;
tree
.
selectItems
(
[
bookmarkIds
.
get
(
bookmarks
[
1
]
.
guid
)
]
)
;
await
withBookmarksDialog
(
true
function
openDialog
(
)
{
tree
.
controller
.
doCommand
(
"
placesCmd_show
:
info
"
)
;
}
async
function
test
(
dialogWin
)
{
let
acceptButton
=
dialogWin
.
document
.
documentElement
.
getButton
(
"
accept
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
acceptButton
.
disabled
"
The
accept
button
should
be
enabled
"
)
;
}
)
;
Assert
.
ok
(
!
(
await
PlacesUtils
.
bookmarks
.
fetch
(
bookmarks
[
0
]
.
guid
)
)
"
The
originally
removed
bookmark
should
not
exist
.
"
)
;
Assert
.
ok
(
await
PlacesUtils
.
bookmarks
.
fetch
(
bookmarks
[
1
]
.
guid
)
"
The
second
bookmark
should
still
exist
"
)
;
Assert
.
ok
(
PlacesTransactions
.
undo
.
notCalled
"
undo
should
not
have
been
called
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_cancel_with_changes
(
)
{
if
(
!
PlacesUIUtils
.
useAsyncTransactions
)
{
Assert
.
ok
(
true
"
Skipping
test
as
async
transactions
are
turned
off
"
)
;
return
;
}
await
withSidebarTree
(
"
bookmarks
"
async
(
tree
)
=
>
{
tree
.
selectItems
(
[
bookmarkIds
.
get
(
bookmarks
[
1
]
.
guid
)
]
)
;
await
withBookmarksDialog
(
true
function
openDialog
(
)
{
tree
.
controller
.
doCommand
(
"
placesCmd_show
:
info
"
)
;
}
async
function
test
(
dialogWin
)
{
let
acceptButton
=
dialogWin
.
document
.
documentElement
.
getButton
(
"
accept
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
acceptButton
.
disabled
"
The
accept
button
should
be
enabled
"
)
;
let
promiseTitleChangeNotification
=
PlacesTestUtils
.
waitForNotification
(
"
onItemChanged
"
(
itemId
prop
isAnno
val
)
=
>
prop
=
=
"
title
"
&
&
val
=
=
"
n
"
)
;
fillBookmarkTextField
(
"
editBMPanel_namePicker
"
"
n
"
dialogWin
)
;
await
promiseTitleChangeNotification
;
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
}
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
PlacesTransactions
.
undo
.
calledOnce
"
undo
should
have
been
called
once
.
"
)
;
}
)
;
}
)
;
