"
use
strict
"
;
const
{
sinon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
jsm
"
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
registerCleanupFunction
(
async
function
(
)
{
sandbox
.
restore
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
let
bookmarks
;
add_task
(
async
function
setup
(
)
{
bookmarks
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
[
{
title
:
"
bm1
"
url
:
"
http
:
/
/
example
.
com
"
}
{
title
:
"
bm2
"
url
:
"
http
:
/
/
example
.
com
/
2
"
}
]
}
)
;
sandbox
.
stub
(
PlacesTransactions
"
undo
"
)
.
returns
(
Promise
.
resolve
(
)
)
;
}
)
;
add_task
(
async
function
test_cancel_with_no_changes
(
)
{
await
withSidebarTree
(
"
bookmarks
"
async
tree
=
>
{
tree
.
selectItems
(
[
bookmarks
[
0
]
.
guid
]
)
;
await
tree
.
controller
.
remove
(
"
Remove
Selection
"
)
;
tree
.
selectItems
(
[
bookmarks
[
1
]
.
guid
]
)
;
await
withBookmarksDialog
(
true
function
openDialog
(
)
{
tree
.
controller
.
doCommand
(
"
placesCmd_show
:
info
"
)
;
}
async
function
test
(
dialogWin
)
{
let
acceptButton
=
dialogWin
.
document
.
getElementById
(
"
bookmarkproperties
"
)
.
getButton
(
"
accept
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
acceptButton
.
disabled
"
The
accept
button
should
be
enabled
"
)
;
}
)
;
Assert
.
ok
(
!
(
await
PlacesUtils
.
bookmarks
.
fetch
(
bookmarks
[
0
]
.
guid
)
)
"
The
originally
removed
bookmark
should
not
exist
.
"
)
;
Assert
.
ok
(
await
PlacesUtils
.
bookmarks
.
fetch
(
bookmarks
[
1
]
.
guid
)
"
The
second
bookmark
should
still
exist
"
)
;
Assert
.
ok
(
PlacesTransactions
.
undo
.
notCalled
"
undo
should
not
have
been
called
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_cancel_with_changes
(
)
{
await
withSidebarTree
(
"
bookmarks
"
async
tree
=
>
{
tree
.
selectItems
(
[
bookmarks
[
1
]
.
guid
]
)
;
await
withBookmarksDialog
(
true
function
openDialog
(
)
{
tree
.
controller
.
doCommand
(
"
placesCmd_show
:
info
"
)
;
}
async
function
test
(
dialogWin
)
{
let
acceptButton
=
dialogWin
.
document
.
getElementById
(
"
bookmarkproperties
"
)
.
getButton
(
"
accept
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
acceptButton
.
disabled
"
The
accept
button
should
be
enabled
"
)
;
let
promiseTitleChangeNotification
=
PlacesTestUtils
.
waitForNotification
(
"
onItemChanged
"
(
itemId
prop
isAnno
val
)
=
>
prop
=
=
"
title
"
&
&
val
=
=
"
n
"
)
;
fillBookmarkTextField
(
"
editBMPanel_namePicker
"
"
n
"
dialogWin
)
;
await
promiseTitleChangeNotification
;
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
}
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
PlacesTransactions
.
undo
.
calledOnce
"
undo
should
have
been
called
once
.
"
)
;
}
)
;
}
)
;
