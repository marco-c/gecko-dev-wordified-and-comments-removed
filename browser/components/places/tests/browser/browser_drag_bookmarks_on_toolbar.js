const
TEST_URL
=
"
http
:
/
/
www
.
mozilla
.
org
"
;
const
TEST_TITLE
=
"
example_title
"
;
var
gBookmarksToolbar
=
window
.
document
.
getElementById
(
"
PlacesToolbar
"
)
;
var
dragDirections
=
{
LEFT
:
0
UP
:
1
RIGHT
:
2
DOWN
:
3
}
;
function
synthesizeDragWithDirection
(
aElement
aExpectedDragData
aDirection
)
{
let
promise
=
new
Promise
(
resolve
=
>
{
gBookmarksToolbar
.
addEventListener
(
"
dragstart
"
function
listener
(
event
)
{
info
(
"
A
dragstart
event
has
been
trapped
.
"
)
;
var
dataTransfer
=
event
.
dataTransfer
;
is
(
dataTransfer
.
mozItemCount
aExpectedDragData
.
length
"
Number
of
dragged
items
should
be
the
same
.
"
)
;
for
(
var
t
=
0
;
t
<
dataTransfer
.
mozItemCount
;
t
+
+
)
{
var
types
=
dataTransfer
.
mozTypesAt
(
t
)
;
var
expecteditem
=
aExpectedDragData
[
t
]
;
is
(
types
.
length
expecteditem
.
length
"
Number
of
flavors
for
item
"
+
t
+
"
should
be
the
same
.
"
)
;
for
(
var
f
=
0
;
f
<
types
.
length
;
f
+
+
)
{
is
(
types
[
f
]
expecteditem
[
f
]
.
substring
(
0
types
[
f
]
.
length
)
"
Flavor
"
+
types
[
f
]
+
"
for
item
"
+
t
+
"
should
be
the
same
.
"
)
;
is
(
dataTransfer
.
mozGetDataAt
(
types
[
f
]
t
)
expecteditem
[
f
]
.
substring
(
types
[
f
]
.
length
+
2
)
"
Contents
for
item
"
+
t
+
"
with
flavor
"
+
types
[
f
]
+
"
should
be
the
same
.
"
)
;
}
}
if
(
!
aExpectedDragData
.
length
)
{
ok
(
event
.
defaultPrevented
"
Drag
has
been
canceled
.
"
)
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
gBookmarksToolbar
.
removeEventListener
(
"
dragstart
"
listener
)
;
aElement
.
addEventListener
(
"
click
"
prevent
)
;
EventUtils
.
synthesizeMouse
(
aElement
startingPoint
.
x
+
xIncrement
*
9
startingPoint
.
y
+
yIncrement
*
9
{
type
:
"
mouseup
"
}
)
;
aElement
.
removeEventListener
(
"
click
"
prevent
)
;
if
(
aElement
.
localName
=
=
"
menu
"
&
&
aElement
.
open
)
{
aElement
.
open
=
false
;
}
resolve
(
)
;
}
)
;
}
)
;
var
prevent
=
function
(
aEvent
)
{
aEvent
.
preventDefault
(
)
;
}
;
var
xIncrement
=
0
;
var
yIncrement
=
0
;
switch
(
aDirection
)
{
case
dragDirections
.
LEFT
:
xIncrement
=
-
1
;
break
;
case
dragDirections
.
RIGHT
:
xIncrement
=
+
1
;
break
;
case
dragDirections
.
UP
:
yIncrement
=
-
1
;
break
;
case
dragDirections
.
DOWN
:
yIncrement
=
+
1
;
break
;
}
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
var
startingPoint
=
{
x
:
(
rect
.
right
-
rect
.
left
)
/
2
y
:
(
rect
.
bottom
-
rect
.
top
)
/
2
}
;
EventUtils
.
synthesizeMouse
(
aElement
startingPoint
.
x
startingPoint
.
y
{
type
:
"
mousedown
"
}
)
;
EventUtils
.
synthesizeMouse
(
aElement
startingPoint
.
x
+
xIncrement
*
1
startingPoint
.
y
+
yIncrement
*
1
{
type
:
"
mousemove
"
}
)
;
EventUtils
.
synthesizeMouse
(
aElement
startingPoint
.
x
+
xIncrement
*
9
startingPoint
.
y
+
yIncrement
*
9
{
type
:
"
mousemove
"
}
)
;
return
promise
;
}
function
getToolbarNodeForItemId
(
itemGuid
)
{
var
children
=
document
.
getElementById
(
"
PlacesToolbarItems
"
)
.
children
;
for
(
let
child
of
children
)
{
if
(
itemGuid
=
=
child
.
_placesNode
.
bookmarkGuid
)
{
return
child
;
}
}
return
null
;
}
function
getExpectedDataForPlacesNode
(
aNode
)
{
var
wrappedNode
=
[
]
;
var
flavors
=
[
"
text
/
x
-
moz
-
place
"
"
text
/
x
-
moz
-
url
"
"
text
/
plain
"
"
text
/
html
"
]
;
flavors
.
forEach
(
function
(
aFlavor
)
{
var
wrappedFlavor
=
aFlavor
+
"
:
"
+
PlacesUtils
.
wrapNode
(
aNode
aFlavor
)
;
wrappedNode
.
push
(
wrappedFlavor
)
;
}
)
;
return
[
wrappedNode
]
;
}
add_task
(
async
function
setup
(
)
{
var
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
var
wasCollapsed
=
toolbar
.
collapsed
;
if
(
wasCollapsed
)
{
await
promiseSetToolbarVisibility
(
toolbar
true
)
;
}
registerCleanupFunction
(
async
(
)
=
>
{
await
promiseSetToolbarVisibility
(
toolbar
false
)
;
}
)
;
}
)
;
add_task
(
async
function
test_drag_folder_on_toolbar
(
)
{
let
folder
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
title
:
TEST_TITLE
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
var
element
=
getToolbarNodeForItemId
(
folder
.
guid
)
;
isnot
(
element
null
"
Found
node
on
toolbar
"
)
;
isnot
(
element
.
_placesNode
null
"
Toolbar
node
has
an
associated
Places
node
.
"
)
;
var
expectedData
=
getExpectedDataForPlacesNode
(
element
.
_placesNode
)
;
info
(
"
Dragging
left
"
)
;
await
synthesizeDragWithDirection
(
element
expectedData
dragDirections
.
LEFT
)
;
info
(
"
Dragging
right
"
)
;
await
synthesizeDragWithDirection
(
element
expectedData
dragDirections
.
RIGHT
)
;
info
(
"
Dragging
up
"
)
;
await
synthesizeDragWithDirection
(
element
expectedData
dragDirections
.
UP
)
;
info
(
"
Dragging
down
"
)
;
await
synthesizeDragWithDirection
(
element
[
]
dragDirections
.
DOWN
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
folder
)
;
}
)
;
add_task
(
async
function
test_drag_bookmark_on_toolbar
(
)
{
var
bookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
title
:
TEST_TITLE
url
:
TEST_URL
}
)
;
var
element
=
getToolbarNodeForItemId
(
bookmark
.
guid
)
;
isnot
(
element
null
"
Found
node
on
toolbar
"
)
;
isnot
(
element
.
_placesNode
null
"
Toolbar
node
has
an
associated
Places
node
.
"
)
;
var
expectedData
=
getExpectedDataForPlacesNode
(
element
.
_placesNode
)
;
info
(
"
Dragging
left
"
)
;
await
synthesizeDragWithDirection
(
element
expectedData
dragDirections
.
LEFT
)
;
info
(
"
Dragging
right
"
)
;
await
synthesizeDragWithDirection
(
element
expectedData
dragDirections
.
RIGHT
)
;
info
(
"
Dragging
up
"
)
;
await
synthesizeDragWithDirection
(
element
expectedData
dragDirections
.
UP
)
;
info
(
"
Dragging
down
"
)
;
synthesizeDragWithDirection
(
element
expectedData
dragDirections
.
DOWN
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
)
;
}
)
;
