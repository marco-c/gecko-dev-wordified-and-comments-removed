var
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
var
wasCollapsed
=
toolbar
.
collapsed
;
function
fakeOpenPopup
(
aPopup
)
{
var
popupEvent
=
document
.
createEvent
(
"
MouseEvent
"
)
;
popupEvent
.
initMouseEvent
(
"
popupshowing
"
true
true
window
0
0
0
0
0
false
false
false
false
0
null
)
;
aPopup
.
dispatchEvent
(
popupEvent
)
;
}
async
function
testInFolder
(
folderGuid
prefix
)
{
let
addedBookmarks
=
[
]
;
let
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
1
url
:
http
:
/
/
{
prefix
}
1
.
mozilla
.
org
/
}
)
;
item
.
title
=
{
prefix
}
1_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
2
url
:
"
place
:
"
}
)
;
item
.
title
=
{
prefix
}
2_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
type
:
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
}
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
f
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
item
.
title
=
{
prefix
}
f_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
item
.
guid
title
:
{
prefix
}
f1
url
:
http
:
/
/
{
prefix
}
f1
.
mozilla
.
org
/
}
)
;
addedBookmarks
.
push
(
item
)
;
item
.
index
=
0
;
item
.
parentGuid
=
folderGuid
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
return
addedBookmarks
;
}
add_task
(
async
function
test
(
)
{
if
(
wasCollapsed
)
{
await
promiseSetToolbarVisibility
(
toolbar
true
)
;
}
var
popup
=
document
.
getElementById
(
"
bookmarksMenuPopup
"
)
;
ok
(
popup
"
Menu
popup
element
exists
"
)
;
fakeOpenPopup
(
popup
)
;
await
withSidebarTree
(
"
bookmarks
"
async
(
)
=
>
{
PlacesUtils
.
bookmarks
.
addObserver
(
bookmarksObserver
)
;
var
addedBookmarks
=
[
]
;
info
(
"
*
*
*
Acting
on
menu
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
menuGuid
"
bm
"
)
)
;
info
(
"
*
*
*
Acting
on
toolbar
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
toolbarGuid
"
tb
"
)
)
;
info
(
"
*
*
*
Acting
on
unsorted
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
unfiledGuid
"
ub
"
)
)
;
for
(
let
bm
of
addedBookmarks
)
{
try
{
await
PlacesUtils
.
bookmarks
.
remove
(
bm
)
;
}
catch
(
ex
)
{
}
}
PlacesUtils
.
bookmarks
.
removeObserver
(
bookmarksObserver
)
;
}
)
;
if
(
wasCollapsed
)
{
await
promiseSetToolbarVisibility
(
toolbar
false
)
;
}
}
)
;
var
bookmarksObserver
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsINavBookmarkObserver
]
)
onItemAdded
:
function
PSB_onItemAdded
(
aItemId
aFolderId
aIndex
aItemType
aURI
)
{
var
views
=
getViewsForFolder
(
aFolderId
)
;
ok
(
views
.
length
>
0
"
Found
affected
views
(
"
+
views
.
length
+
"
)
:
"
+
views
)
;
for
(
var
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
var
[
node
index
]
=
searchItemInView
(
aItemId
views
[
i
]
)
;
isnot
(
node
null
"
Found
new
Places
node
in
"
+
views
[
i
]
)
;
is
(
index
aIndex
"
Node
is
at
index
"
+
index
)
;
}
}
onItemRemoved
:
function
PSB_onItemRemoved
(
aItemId
aFolderId
aIndex
aItemType
url
aGuid
)
{
var
views
=
getViewsForFolder
(
aFolderId
)
;
ok
(
views
.
length
>
0
"
Found
affected
views
(
"
+
views
.
length
+
"
)
:
"
+
views
)
;
for
(
var
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
var
node
=
null
;
[
node
]
=
searchItemInView
(
aItemId
views
[
i
]
)
;
is
(
node
null
"
Places
node
should
not
be
found
in
"
+
views
[
i
]
)
;
}
}
onItemMoved
(
aItemId
aOldFolderId
aOldIndex
aNewFolderId
aNewIndex
aItemType
)
{
var
views
=
getViewsForFolder
(
aNewFolderId
)
;
ok
(
views
.
length
>
0
"
Found
affected
views
:
"
+
views
)
;
for
(
var
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
var
node
=
null
;
var
index
=
null
;
[
node
index
]
=
searchItemInView
(
aItemId
views
[
i
]
)
;
isnot
(
node
null
"
Found
new
Places
node
in
"
+
views
[
i
]
)
;
is
(
index
aNewIndex
"
Node
is
at
index
"
+
index
)
;
}
}
onBeginUpdateBatch
:
function
PSB_onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
:
function
PSB_onEndUpdateBatch
(
)
{
}
onItemVisited
(
)
{
}
onItemChanged
:
function
PSB_onItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
aLastModified
aItemType
aParentId
)
{
if
(
aProperty
!
=
=
"
title
"
)
return
;
var
views
=
getViewsForFolder
(
aParentId
)
;
ok
(
views
.
length
>
0
"
Found
affected
views
(
"
+
views
.
length
+
"
)
:
"
+
views
)
;
let
validator
=
function
(
aElementOrTreeIndex
)
{
if
(
typeof
(
aElementOrTreeIndex
)
=
=
"
number
"
)
{
var
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
var
tree
=
sidebar
.
contentDocument
.
getElementById
(
"
bookmarks
-
view
"
)
;
let
cellText
=
tree
.
view
.
getCellText
(
aElementOrTreeIndex
tree
.
columns
.
getColumnAt
(
0
)
)
;
if
(
!
aNewValue
)
return
cellText
=
=
PlacesUIUtils
.
getBestTitle
(
tree
.
view
.
nodeForTreeIndex
(
aElementOrTreeIndex
)
true
)
;
return
cellText
=
=
aNewValue
;
}
if
(
!
aNewValue
&
&
aElementOrTreeIndex
.
localName
!
=
"
toolbarbutton
"
)
{
return
aElementOrTreeIndex
.
getAttribute
(
"
label
"
)
=
=
PlacesUIUtils
.
getBestTitle
(
aElementOrTreeIndex
.
_placesNode
)
;
}
return
aElementOrTreeIndex
.
getAttribute
(
"
label
"
)
=
=
aNewValue
;
}
;
for
(
var
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
var
[
node
valid
]
=
searchItemInView
(
aItemId
views
[
i
]
validator
)
;
isnot
(
node
null
"
Found
changed
Places
node
in
"
+
views
[
i
]
)
;
is
(
node
.
title
aNewValue
"
Node
has
correct
title
:
"
+
aNewValue
)
;
ok
(
valid
"
Node
element
has
correct
label
:
"
+
aNewValue
)
;
}
}
}
;
function
searchItemInView
(
aItemId
aView
aValidator
)
{
switch
(
aView
)
{
case
"
toolbar
"
:
return
getNodeForToolbarItem
(
aItemId
aValidator
)
;
case
"
menu
"
:
return
getNodeForMenuItem
(
aItemId
aValidator
)
;
case
"
sidebar
"
:
return
getNodeForSidebarItem
(
aItemId
aValidator
)
;
}
return
[
null
null
false
]
;
}
function
getNodeForToolbarItem
(
aItemId
aValidator
)
{
var
placesToolbarItems
=
document
.
getElementById
(
"
PlacesToolbarItems
"
)
;
function
findNode
(
aContainer
)
{
var
children
=
aContainer
.
childNodes
;
for
(
var
i
=
0
staticNodes
=
0
;
i
<
children
.
length
;
i
+
+
)
{
var
child
=
children
[
i
]
;
if
(
!
child
.
_placesNode
)
{
staticNodes
+
+
;
continue
;
}
if
(
child
.
_placesNode
.
itemId
=
=
aItemId
)
{
let
valid
=
aValidator
?
aValidator
(
child
)
:
true
;
return
[
child
.
_placesNode
i
-
staticNodes
valid
]
;
}
if
(
PlacesUtils
.
nodeIsFolder
(
child
.
_placesNode
)
)
{
var
popup
=
child
.
lastChild
;
popup
.
openPopup
(
)
;
var
foundNode
=
findNode
(
popup
)
;
popup
.
hidePopup
(
)
;
if
(
foundNode
[
0
]
!
=
null
)
return
foundNode
;
}
}
return
[
null
null
]
;
}
return
findNode
(
placesToolbarItems
)
;
}
function
getNodeForMenuItem
(
aItemId
aValidator
)
{
var
menu
=
document
.
getElementById
(
"
bookmarksMenu
"
)
;
function
findNode
(
aContainer
)
{
var
children
=
aContainer
.
childNodes
;
for
(
var
i
=
0
staticNodes
=
0
;
i
<
children
.
length
;
i
+
+
)
{
var
child
=
children
[
i
]
;
if
(
!
child
.
_placesNode
)
{
staticNodes
+
+
;
continue
;
}
if
(
child
.
_placesNode
.
itemId
=
=
aItemId
)
{
let
valid
=
aValidator
?
aValidator
(
child
)
:
true
;
return
[
child
.
_placesNode
i
-
staticNodes
valid
]
;
}
if
(
PlacesUtils
.
nodeIsFolder
(
child
.
_placesNode
)
)
{
var
popup
=
child
.
lastChild
;
fakeOpenPopup
(
popup
)
;
var
foundNode
=
findNode
(
popup
)
;
child
.
open
=
false
;
if
(
foundNode
[
0
]
!
=
null
)
return
foundNode
;
}
}
return
[
null
null
false
]
;
}
return
findNode
(
menu
.
lastChild
)
;
}
function
getNodeForSidebarItem
(
aItemId
aValidator
)
{
var
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
var
tree
=
sidebar
.
contentDocument
.
getElementById
(
"
bookmarks
-
view
"
)
;
function
findNode
(
aContainerIndex
)
{
if
(
tree
.
view
.
isContainerEmpty
(
aContainerIndex
)
)
return
[
null
null
false
]
;
for
(
var
i
=
aContainerIndex
+
1
;
i
<
tree
.
view
.
rowCount
;
i
+
+
)
{
var
node
=
tree
.
view
.
nodeForTreeIndex
(
i
)
;
if
(
node
.
itemId
=
=
aItemId
)
{
let
valid
=
aValidator
?
aValidator
(
i
)
:
true
;
return
[
node
i
-
tree
.
view
.
getParentIndex
(
i
)
-
1
valid
]
;
}
if
(
PlacesUtils
.
nodeIsFolder
(
node
)
)
{
tree
.
view
.
toggleOpenState
(
i
)
;
var
foundNode
=
findNode
(
i
)
;
tree
.
view
.
toggleOpenState
(
i
)
;
if
(
foundNode
[
0
]
!
=
null
)
return
foundNode
;
}
if
(
!
tree
.
view
.
hasNextSibling
(
aContainerIndex
+
1
i
)
)
break
;
}
return
[
null
null
false
]
;
}
for
(
var
i
=
0
;
i
<
tree
.
view
.
rowCount
;
i
+
+
)
{
tree
.
view
.
toggleOpenState
(
i
)
;
var
foundNode
=
findNode
(
i
)
;
tree
.
view
.
toggleOpenState
(
i
)
;
if
(
foundNode
[
0
]
!
=
null
)
return
foundNode
;
}
return
[
null
null
false
]
;
}
function
getViewsForFolder
(
aFolderId
)
{
var
rootId
=
aFolderId
;
while
(
!
PlacesUtils
.
isRootItem
(
rootId
)
)
rootId
=
PlacesUtils
.
bookmarks
.
getFolderIdForItem
(
rootId
)
;
switch
(
rootId
)
{
case
PlacesUtils
.
toolbarFolderId
:
return
[
"
toolbar
"
"
sidebar
"
]
;
case
PlacesUtils
.
bookmarksMenuFolderId
:
return
[
"
menu
"
"
sidebar
"
]
;
case
PlacesUtils
.
unfiledBookmarksFolderId
:
return
[
"
sidebar
"
]
;
}
return
[
]
;
}
