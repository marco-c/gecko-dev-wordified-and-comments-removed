var
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
var
wasCollapsed
=
toolbar
.
collapsed
;
function
fakeOpenPopup
(
aPopup
)
{
var
popupEvent
=
document
.
createEvent
(
"
MouseEvent
"
)
;
popupEvent
.
initMouseEvent
(
"
popupshowing
"
true
true
window
0
0
0
0
0
false
false
false
false
0
null
)
;
aPopup
.
dispatchEvent
(
popupEvent
)
;
}
async
function
testInFolder
(
folderGuid
prefix
)
{
let
addedBookmarks
=
[
]
;
let
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
1
url
:
http
:
/
/
{
prefix
}
1
.
mozilla
.
org
/
}
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
item
.
title
=
{
prefix
}
1_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
2
url
:
"
place
:
"
}
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
item
.
title
=
{
prefix
}
2_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
type
:
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
}
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
f
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
item
.
title
=
{
prefix
}
f_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
item
.
guid
title
:
{
prefix
}
f1
url
:
http
:
/
/
{
prefix
}
f1
.
mozilla
.
org
/
}
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
addedBookmarks
.
push
(
item
)
;
item
.
index
=
0
;
item
.
parentGuid
=
folderGuid
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
return
addedBookmarks
;
}
add_task
(
async
function
test
(
)
{
if
(
wasCollapsed
)
{
await
promiseSetToolbarVisibility
(
toolbar
true
)
;
}
var
popup
=
document
.
getElementById
(
"
bookmarksMenuPopup
"
)
;
ok
(
popup
"
Menu
popup
element
exists
"
)
;
fakeOpenPopup
(
popup
)
;
await
withSidebarTree
(
"
bookmarks
"
async
(
)
=
>
{
bookmarksObserver
.
handlePlacesEvents
=
bookmarksObserver
.
handlePlacesEvents
.
bind
(
bookmarksObserver
)
;
PlacesUtils
.
bookmarks
.
addObserver
(
bookmarksObserver
)
;
PlacesUtils
.
observers
.
addListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
]
bookmarksObserver
.
handlePlacesEvents
)
;
var
addedBookmarks
=
[
]
;
info
(
"
*
*
*
Acting
on
menu
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
menuGuid
"
bm
"
)
)
;
info
(
"
*
*
*
Acting
on
toolbar
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
toolbarGuid
"
tb
"
)
)
;
info
(
"
*
*
*
Acting
on
unsorted
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
unfiledGuid
"
ub
"
)
)
;
for
(
let
bm
of
addedBookmarks
)
{
try
{
await
PlacesUtils
.
bookmarks
.
remove
(
bm
)
;
}
catch
(
ex
)
{
}
await
bookmarksObserver
.
assertViewsUpdatedCorrectly
(
)
;
}
PlacesUtils
.
bookmarks
.
removeObserver
(
bookmarksObserver
)
;
PlacesUtils
.
observers
.
removeListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
]
bookmarksObserver
.
handlePlacesEvents
)
;
}
)
;
if
(
wasCollapsed
)
{
await
promiseSetToolbarVisibility
(
toolbar
false
)
;
}
}
)
;
var
bookmarksObserver
=
{
_notifications
:
[
]
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsINavBookmarkObserver
"
]
)
handlePlacesEvents
(
events
)
{
for
(
let
{
type
parentGuid
guid
index
}
of
events
)
{
switch
(
type
)
{
case
"
bookmark
-
added
"
:
this
.
_notifications
.
push
(
[
"
assertItemAdded
"
parentGuid
guid
index
]
)
;
break
;
case
"
bookmark
-
removed
"
:
this
.
_notifications
.
push
(
[
"
assertItemRemoved
"
parentGuid
guid
]
)
;
break
;
}
}
}
onItemMoved
(
itemId
oldFolderId
oldIndex
newFolderId
newIndex
itemType
guid
oldParentGuid
newParentGuid
)
{
this
.
_notifications
.
push
(
[
"
assertItemMoved
"
newParentGuid
guid
newIndex
]
)
;
}
onItemChanged
(
itemId
property
annoProperty
newValue
lastModified
itemType
parentId
guid
parentGuid
)
{
if
(
property
!
=
=
"
title
"
)
{
return
;
}
this
.
_notifications
.
push
(
[
"
assertItemChanged
"
parentGuid
guid
newValue
]
)
;
}
async
assertViewsUpdatedCorrectly
(
)
{
for
(
let
notification
of
this
.
_notifications
)
{
let
assertFunction
=
notification
.
shift
(
)
;
let
views
=
await
getViewsForFolder
(
notification
.
shift
(
)
)
;
Assert
.
greater
(
views
.
length
0
"
Should
have
found
one
or
more
views
for
the
parent
folder
.
"
)
;
await
this
[
assertFunction
]
(
views
.
.
.
notification
)
;
}
this
.
_notifications
=
[
]
;
}
async
assertItemAdded
(
views
guid
expectedIndex
)
{
for
(
let
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
let
[
node
index
]
=
searchItemInView
(
guid
views
[
i
]
)
;
Assert
.
notEqual
(
node
null
"
Should
have
found
the
view
in
"
+
views
[
i
]
)
;
Assert
.
equal
(
index
expectedIndex
"
Should
have
found
the
node
at
the
expected
index
"
)
;
}
}
async
assertItemRemoved
(
views
guid
)
{
for
(
let
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
let
[
node
]
=
searchItemInView
(
guid
views
[
i
]
)
;
Assert
.
equal
(
node
null
"
Should
not
have
found
the
node
"
)
;
}
}
async
assertItemMoved
(
views
guid
newIndex
)
{
for
(
let
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
let
[
node
index
]
=
searchItemInView
(
guid
views
[
i
]
)
;
Assert
.
notEqual
(
node
null
"
Should
have
found
the
view
in
"
+
views
[
i
]
)
;
Assert
.
equal
(
index
newIndex
"
Should
have
found
the
node
at
the
expected
index
"
)
;
}
}
async
assertItemChanged
(
views
guid
newValue
)
{
let
validator
=
function
(
aElementOrTreeIndex
)
{
if
(
typeof
aElementOrTreeIndex
=
=
"
number
"
)
{
let
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
let
tree
=
sidebar
.
contentDocument
.
getElementById
(
"
bookmarks
-
view
"
)
;
let
cellText
=
tree
.
view
.
getCellText
(
aElementOrTreeIndex
tree
.
columns
.
getColumnAt
(
0
)
)
;
if
(
!
newValue
)
{
return
(
cellText
=
=
PlacesUIUtils
.
getBestTitle
(
tree
.
view
.
nodeForTreeIndex
(
aElementOrTreeIndex
)
true
)
)
;
}
return
cellText
=
=
newValue
;
}
if
(
!
newValue
&
&
aElementOrTreeIndex
.
localName
!
=
"
toolbarbutton
"
)
{
return
(
aElementOrTreeIndex
.
getAttribute
(
"
label
"
)
=
=
PlacesUIUtils
.
getBestTitle
(
aElementOrTreeIndex
.
_placesNode
)
)
;
}
return
aElementOrTreeIndex
.
getAttribute
(
"
label
"
)
=
=
newValue
;
}
;
for
(
let
i
=
0
;
i
<
views
.
length
;
i
+
+
)
{
let
[
node
valid
]
=
searchItemInView
(
guid
views
[
i
]
validator
)
;
Assert
.
notEqual
(
node
null
"
Should
have
found
the
view
in
"
+
views
[
i
]
)
;
Assert
.
equal
(
node
.
title
newValue
"
Node
should
have
the
correct
new
title
"
)
;
Assert
.
ok
(
valid
"
Node
element
should
have
the
correct
label
"
)
;
}
}
}
;
function
searchItemInView
(
itemGuid
view
validator
)
{
switch
(
view
)
{
case
"
toolbar
"
:
return
getNodeForToolbarItem
(
itemGuid
validator
)
;
case
"
menu
"
:
return
getNodeForMenuItem
(
itemGuid
validator
)
;
case
"
sidebar
"
:
return
getNodeForSidebarItem
(
itemGuid
validator
)
;
}
return
[
null
null
false
]
;
}
function
getNodeForToolbarItem
(
itemGuid
validator
)
{
var
placesToolbarItems
=
document
.
getElementById
(
"
PlacesToolbarItems
"
)
;
function
findNode
(
aContainer
)
{
var
children
=
aContainer
.
children
;
for
(
var
i
=
0
staticNodes
=
0
;
i
<
children
.
length
;
i
+
+
)
{
var
child
=
children
[
i
]
;
if
(
!
child
.
_placesNode
)
{
staticNodes
+
+
;
continue
;
}
if
(
child
.
_placesNode
.
bookmarkGuid
=
=
itemGuid
)
{
let
valid
=
validator
?
validator
(
child
)
:
true
;
return
[
child
.
_placesNode
i
-
staticNodes
valid
]
;
}
if
(
PlacesUtils
.
nodeIsFolder
(
child
.
_placesNode
)
)
{
var
popup
=
child
.
menupopup
;
popup
.
openPopup
(
)
;
var
foundNode
=
findNode
(
popup
)
;
popup
.
hidePopup
(
)
;
if
(
foundNode
[
0
]
!
=
null
)
{
return
foundNode
;
}
}
}
return
[
null
null
]
;
}
return
findNode
(
placesToolbarItems
)
;
}
function
getNodeForMenuItem
(
itemGuid
validator
)
{
var
menu
=
document
.
getElementById
(
"
bookmarksMenu
"
)
;
function
findNode
(
aContainer
)
{
var
children
=
aContainer
.
children
;
for
(
var
i
=
0
staticNodes
=
0
;
i
<
children
.
length
;
i
+
+
)
{
var
child
=
children
[
i
]
;
if
(
!
child
.
_placesNode
)
{
staticNodes
+
+
;
continue
;
}
if
(
child
.
_placesNode
.
bookmarkGuid
=
=
itemGuid
)
{
let
valid
=
validator
?
validator
(
child
)
:
true
;
return
[
child
.
_placesNode
i
-
staticNodes
valid
]
;
}
if
(
PlacesUtils
.
nodeIsFolder
(
child
.
_placesNode
)
)
{
var
popup
=
child
.
lastElementChild
;
fakeOpenPopup
(
popup
)
;
var
foundNode
=
findNode
(
popup
)
;
child
.
open
=
false
;
if
(
foundNode
[
0
]
!
=
null
)
{
return
foundNode
;
}
}
}
return
[
null
null
false
]
;
}
return
findNode
(
menu
.
lastElementChild
)
;
}
function
getNodeForSidebarItem
(
itemGuid
validator
)
{
var
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
var
tree
=
sidebar
.
contentDocument
.
getElementById
(
"
bookmarks
-
view
"
)
;
function
findNode
(
aContainerIndex
)
{
if
(
tree
.
view
.
isContainerEmpty
(
aContainerIndex
)
)
{
return
[
null
null
false
]
;
}
for
(
var
i
=
aContainerIndex
+
1
;
i
<
tree
.
view
.
rowCount
;
i
+
+
)
{
var
node
=
tree
.
view
.
nodeForTreeIndex
(
i
)
;
if
(
node
.
bookmarkGuid
=
=
itemGuid
)
{
let
valid
=
validator
?
validator
(
i
)
:
true
;
return
[
node
i
-
tree
.
view
.
getParentIndex
(
i
)
-
1
valid
]
;
}
if
(
PlacesUtils
.
nodeIsFolder
(
node
)
)
{
tree
.
view
.
toggleOpenState
(
i
)
;
var
foundNode
=
findNode
(
i
)
;
tree
.
view
.
toggleOpenState
(
i
)
;
if
(
foundNode
[
0
]
!
=
null
)
{
return
foundNode
;
}
}
if
(
!
tree
.
view
.
hasNextSibling
(
aContainerIndex
+
1
i
)
)
{
break
;
}
}
return
[
null
null
false
]
;
}
for
(
var
i
=
0
;
i
<
tree
.
view
.
rowCount
;
i
+
+
)
{
tree
.
view
.
toggleOpenState
(
i
)
;
var
foundNode
=
findNode
(
i
)
;
tree
.
view
.
toggleOpenState
(
i
)
;
if
(
foundNode
[
0
]
!
=
null
)
{
return
foundNode
;
}
}
return
[
null
null
false
]
;
}
async
function
getViewsForFolder
(
folderGuid
)
{
let
rootGuid
=
folderGuid
;
while
(
!
PlacesUtils
.
isRootItem
(
rootGuid
)
)
{
let
itemData
=
await
PlacesUtils
.
bookmarks
.
fetch
(
rootGuid
)
;
rootGuid
=
itemData
.
parentGuid
;
}
switch
(
rootGuid
)
{
case
PlacesUtils
.
bookmarks
.
toolbarGuid
:
return
[
"
toolbar
"
"
sidebar
"
]
;
case
PlacesUtils
.
bookmarks
.
menuGuid
:
return
[
"
menu
"
"
sidebar
"
]
;
case
PlacesUtils
.
bookmarks
.
unfiledGuid
:
return
[
"
sidebar
"
]
;
}
return
[
]
;
}
