"
use
strict
"
;
const
TEST_URIs
=
[
"
http
:
/
/
www
.
mozilla
.
org
/
test1
"
"
http
:
/
/
www
.
mozilla
.
org
/
test2
"
]
;
add_task
(
async
function
(
)
{
ok
(
PlacesUtils
"
checking
PlacesUtils
running
in
chrome
context
?
"
)
;
let
places
=
[
]
;
let
transition
=
PlacesUtils
.
history
.
TRANSITION_TYPED
;
TEST_URIs
.
forEach
(
uri
=
>
places
.
push
(
{
uri
:
Services
.
io
.
newURI
(
uri
)
transition
}
)
)
;
await
PlacesTestUtils
.
addVisits
(
places
)
;
await
testForgetThisSiteVisibility
(
1
)
;
await
testForgetThisSiteVisibility
(
2
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
var
testForgetThisSiteVisibility
=
async
function
(
selectionCount
)
{
let
organizer
=
await
promiseLibrary
(
)
;
organizer
.
PlacesOrganizer
.
selectLeftPaneBuiltIn
(
"
History
"
)
;
let
PO
=
organizer
.
PlacesOrganizer
;
let
histContainer
=
PO
.
_places
.
selectedNode
.
QueryInterface
(
Ci
.
nsINavHistoryContainerResultNode
)
;
histContainer
.
containerOpen
=
true
;
PO
.
_places
.
selectNode
(
histContainer
.
getChild
(
0
)
)
;
let
doc
=
organizer
.
document
;
let
tree
=
doc
.
getElementById
(
"
placeContent
"
)
;
let
selection
=
tree
.
view
.
selection
;
selection
.
clearSelection
(
)
;
selection
.
rangedSelect
(
0
selectionCount
-
1
true
)
;
is
(
selection
.
count
selectionCount
"
The
selected
range
is
as
big
as
expected
"
)
;
let
contextmenu
=
doc
.
getElementById
(
"
placesContext
"
)
;
let
popupShown
=
promisePopupShown
(
contextmenu
)
;
let
rect
=
tree
.
getCoordsForCellItem
(
0
tree
.
columns
[
0
]
"
text
"
)
;
EventUtils
.
synthesizeMouse
(
tree
.
body
rect
.
x
+
rect
.
width
/
2
rect
.
y
+
rect
.
height
/
2
{
type
:
"
contextmenu
"
button
:
2
}
organizer
)
;
await
popupShown
;
let
forgetThisSite
=
doc
.
getElementById
(
"
placesContext_deleteHost
"
)
;
let
hideForgetThisSite
=
selectionCount
!
=
1
;
is
(
forgetThisSite
.
hidden
hideForgetThisSite
The
Forget
this
site
menu
item
should
{
hideForgetThisSite
?
"
"
:
"
not
"
}
be
hidden
with
{
selectionCount
}
items
selected
)
;
contextmenu
.
hidePopup
(
)
;
await
promiseLibraryClosed
(
organizer
)
;
}
;
function
promisePopupShown
(
popup
)
{
return
new
Promise
(
resolve
=
>
{
popup
.
addEventListener
(
"
popupshown
"
function
(
)
{
resolve
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
}
