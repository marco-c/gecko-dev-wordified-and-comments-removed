var
sidebar
;
add_task
(
async
function
test_sidebarpanels_click
(
)
{
ignoreAllUncaughtExceptions
(
)
;
const
BOOKMARKS_SIDEBAR_ID
=
"
viewBookmarksSidebar
"
;
const
BOOKMARKS_SIDEBAR_TREE_ID
=
"
bookmarks
-
view
"
;
const
HISTORY_SIDEBAR_ID
=
"
viewHistorySidebar
"
;
const
HISTORY_SIDEBAR_TREE_ID
=
"
historyTree
"
;
const
TEST_URL
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
browser
/
components
/
places
/
tests
/
browser
/
sidebarpanels_click_test_page
.
html
"
;
if
(
!
document
.
getElementById
(
"
sidebar
-
box
"
)
.
hidden
)
{
ok
(
false
"
Unexpected
sidebar
found
-
a
previous
test
failed
to
cleanup
correctly
"
)
;
SidebarUI
.
hide
(
)
;
}
await
PlacesUtils
.
history
.
clear
(
)
;
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
let
tests
=
[
]
;
tests
.
push
(
{
_bookmark
:
null
async
init
(
)
{
this
.
_bookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
test
"
url
:
TEST_URL
}
)
;
}
prepare
(
)
{
}
async
selectNode
(
tree
)
{
tree
.
selectItems
(
[
this
.
_bookmark
.
guid
]
)
;
}
cleanup
(
aCallback
)
{
return
PlacesUtils
.
bookmarks
.
remove
(
this
.
_bookmark
)
;
}
sidebarName
:
BOOKMARKS_SIDEBAR_ID
treeName
:
BOOKMARKS_SIDEBAR_TREE_ID
desc
:
"
Bookmarks
sidebar
test
"
}
)
;
tests
.
push
(
{
async
init
(
)
{
let
uri
=
Services
.
io
.
newURI
(
TEST_URL
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
visitDate
:
Date
.
now
(
)
*
1000
transition
:
PlacesUtils
.
history
.
TRANSITION_TYPED
}
)
;
}
prepare
(
)
{
sidebar
.
contentDocument
.
getElementById
(
"
byvisited
"
)
.
doCommand
(
)
;
}
selectNode
(
tree
)
{
tree
.
selectNode
(
tree
.
view
.
nodeForTreeIndex
(
0
)
)
;
is
(
tree
.
selectedNode
.
uri
TEST_URL
"
The
correct
visit
has
been
selected
"
)
;
is
(
tree
.
selectedNode
.
itemId
-
1
"
The
selected
node
is
not
bookmarked
"
)
;
}
cleanup
(
aCallback
)
{
return
PlacesUtils
.
history
.
clear
(
)
;
}
sidebarName
:
HISTORY_SIDEBAR_ID
treeName
:
HISTORY_SIDEBAR_TREE_ID
desc
:
"
History
sidebar
test
"
}
)
;
for
(
let
test
of
tests
)
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
)
;
await
testPlacesPanel
(
test
(
)
=
>
{
changeSidebarDirection
(
"
ltr
"
)
;
info
(
"
Running
"
+
test
.
desc
+
"
in
LTR
mode
"
)
;
}
)
;
await
testPlacesPanel
(
test
(
)
=
>
{
changeSidebarDirection
(
"
rtl
"
)
;
info
(
"
Running
"
+
test
.
desc
+
"
in
RTL
mode
"
)
;
}
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeTab
(
gBrowser
.
tabContainer
.
lastElementChild
)
;
}
}
}
)
;
async
function
testPlacesPanel
(
testInfo
preFunc
)
{
await
testInfo
.
init
(
)
;
let
promise
=
new
Promise
(
resolve
=
>
{
sidebar
.
addEventListener
(
"
load
"
function
(
)
{
executeSoon
(
async
function
(
)
{
testInfo
.
prepare
(
)
;
preFunc
(
)
;
let
tree
=
sidebar
.
contentDocument
.
getElementById
(
testInfo
.
treeName
)
;
await
testInfo
.
selectNode
(
tree
)
;
let
promiseAlert
=
promiseAlertDialogObserved
(
)
;
synthesizeClickOnSelectedTreeCell
(
tree
)
;
await
promiseAlert
;
executeSoon
(
async
function
(
)
{
SidebarUI
.
hide
(
)
;
await
testInfo
.
cleanup
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
SidebarUI
.
show
(
testInfo
.
sidebarName
)
;
return
promise
;
}
function
promiseAlertDialogObserved
(
)
{
return
new
Promise
(
resolve
=
>
{
function
observer
(
subject
)
{
info
(
"
alert
dialog
observed
as
expected
"
)
;
Services
.
obs
.
removeObserver
(
observer
"
common
-
dialog
-
loaded
"
)
;
Services
.
obs
.
removeObserver
(
observer
"
tabmodal
-
dialog
-
loaded
"
)
;
if
(
subject
.
Dialog
)
{
subject
.
Dialog
.
ui
.
button0
.
click
(
)
;
}
else
{
subject
.
querySelector
(
"
.
tabmodalprompt
-
button0
"
)
.
click
(
)
;
}
resolve
(
)
;
}
Services
.
obs
.
addObserver
(
observer
"
common
-
dialog
-
loaded
"
)
;
Services
.
obs
.
addObserver
(
observer
"
tabmodal
-
dialog
-
loaded
"
)
;
}
)
;
}
function
changeSidebarDirection
(
aDirection
)
{
sidebar
.
contentDocument
.
documentElement
.
style
.
direction
=
aDirection
;
}
