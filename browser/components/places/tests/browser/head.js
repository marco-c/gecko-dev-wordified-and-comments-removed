XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesTestUtils
"
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
TestUtils
"
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
let
leftPaneGetters
=
new
Map
(
[
[
"
leftPaneFolderId
"
null
]
[
"
allBookmarksFolderId
"
null
]
]
)
;
for
(
let
[
key
val
]
of
leftPaneGetters
)
{
if
(
!
val
)
{
let
getter
=
Object
.
getOwnPropertyDescriptor
(
PlacesUIUtils
key
)
.
get
;
if
(
typeof
getter
=
=
"
function
"
)
{
leftPaneGetters
.
set
(
key
getter
)
;
}
}
}
function
restoreLeftPaneGetters
(
)
{
for
(
let
[
key
getter
]
of
leftPaneGetters
)
{
Object
.
defineProperty
(
PlacesUIUtils
key
{
enumerable
:
true
configurable
:
true
get
:
getter
}
)
;
}
}
registerCleanupFunction
(
restoreLeftPaneGetters
)
;
function
openLibrary
(
callback
aLeftPaneRoot
)
{
let
library
=
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xul
"
"
"
"
chrome
toolbar
=
yes
dialog
=
no
resizable
"
aLeftPaneRoot
)
;
waitForFocus
(
function
(
)
{
callback
(
library
)
;
}
library
)
;
return
library
;
}
function
promiseLibrary
(
aLeftPaneRoot
)
{
return
new
Promise
(
resolve
=
>
{
let
library
=
Services
.
wm
.
getMostRecentWindow
(
"
Places
:
Organizer
"
)
;
if
(
library
&
&
!
library
.
closed
)
{
if
(
aLeftPaneRoot
)
{
library
.
PlacesOrganizer
.
selectLeftPaneContainerByHierarchy
(
aLeftPaneRoot
)
;
}
resolve
(
library
)
;
}
else
{
openLibrary
(
resolve
aLeftPaneRoot
)
;
}
}
)
;
}
function
promiseLibraryClosed
(
organizer
)
{
return
new
Promise
(
resolve
=
>
{
organizer
.
addEventListener
(
"
unload
"
function
(
)
{
executeSoon
(
resolve
)
;
}
{
once
:
true
}
)
;
organizer
.
close
(
)
;
}
)
;
}
function
promiseClipboard
(
aPopulateClipboardFn
aFlavor
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
waitForClipboard
(
data
=
>
!
!
data
aPopulateClipboardFn
resolve
reject
aFlavor
)
;
}
)
;
}
function
waitForAsyncUpdates
(
aCallback
aScope
aArguments
)
{
let
scope
=
aScope
|
|
this
;
let
args
=
aArguments
|
|
[
]
;
let
db
=
PlacesUtils
.
history
.
QueryInterface
(
Ci
.
nsPIPlacesDatabase
)
.
DBConnection
;
let
begin
=
db
.
createAsyncStatement
(
"
BEGIN
EXCLUSIVE
"
)
;
begin
.
executeAsync
(
)
;
begin
.
finalize
(
)
;
let
commit
=
db
.
createAsyncStatement
(
"
COMMIT
"
)
;
commit
.
executeAsync
(
{
handleResult
(
)
{
}
handleError
(
)
{
}
handleCompletion
(
aReason
)
{
aCallback
.
apply
(
scope
args
)
;
}
}
)
;
commit
.
finalize
(
)
;
}
function
synthesizeClickOnSelectedTreeCell
(
aTree
aOptions
)
{
let
tbo
=
aTree
.
treeBoxObject
;
if
(
tbo
.
view
.
selection
.
count
!
=
1
)
throw
new
Error
(
"
The
test
node
should
be
successfully
selected
"
)
;
let
min
=
{
}
max
=
{
}
;
tbo
.
view
.
selection
.
getRangeAt
(
0
min
max
)
;
let
rowID
=
min
.
value
;
tbo
.
ensureRowIsVisible
(
rowID
)
;
var
rect
=
tbo
.
getCoordsForCellItem
(
rowID
aTree
.
columns
[
0
]
"
text
"
)
;
var
x
=
rect
.
x
+
rect
.
width
/
2
;
var
y
=
rect
.
y
+
rect
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
aTree
.
body
x
y
aOptions
|
|
{
}
aTree
.
ownerGlobal
)
;
}
function
promiseSetToolbarVisibility
(
aToolbar
aVisible
aCallback
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
listener
(
event
)
{
if
(
event
.
propertyName
=
=
"
max
-
height
"
)
{
aToolbar
.
removeEventListener
(
"
transitionend
"
listener
)
;
resolve
(
)
;
}
}
let
transitionProperties
=
window
.
getComputedStyle
(
aToolbar
)
.
transitionProperty
.
split
(
"
"
)
;
if
(
isToolbarVisible
(
aToolbar
)
!
=
aVisible
&
&
transitionProperties
.
some
(
prop
=
>
prop
=
=
"
max
-
height
"
|
|
prop
=
=
"
all
"
)
)
{
aToolbar
.
addEventListener
(
"
transitionend
"
listener
)
;
setToolbarVisibility
(
aToolbar
aVisible
)
;
return
;
}
setToolbarVisibility
(
aToolbar
aVisible
)
;
resolve
(
)
;
}
)
;
}
function
isToolbarVisible
(
aToolbar
)
{
let
hidingAttribute
=
aToolbar
.
getAttribute
(
"
type
"
)
=
=
"
menubar
"
?
"
autohide
"
:
"
collapsed
"
;
let
hidingValue
=
aToolbar
.
getAttribute
(
hidingAttribute
)
.
toLowerCase
(
)
;
return
hidingValue
!
=
=
"
true
"
&
&
hidingValue
!
=
=
hidingAttribute
;
}
var
withBookmarksDialog
=
async
function
(
autoCancel
openFn
taskFn
closeFn
dialogUrl
=
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties
"
skipOverlayWait
=
false
)
{
let
closed
=
false
;
let
dialogPromise
=
new
Promise
(
resolve
=
>
{
Services
.
ww
.
registerNotification
(
function
winObserver
(
subject
topic
data
)
{
if
(
topic
=
=
"
domwindowopened
"
)
{
let
win
=
subject
.
QueryInterface
(
Ci
.
nsIDOMWindow
)
;
win
.
addEventListener
(
"
load
"
function
(
)
{
ok
(
win
.
location
.
href
.
startsWith
(
dialogUrl
)
"
The
bookmark
properties
dialog
is
open
"
)
;
waitForFocus
(
(
)
=
>
{
resolve
(
win
)
;
}
win
)
;
}
{
once
:
true
}
)
;
}
else
if
(
topic
=
=
"
domwindowclosed
"
)
{
Services
.
ww
.
unregisterNotification
(
winObserver
)
;
closed
=
true
;
}
}
)
;
}
)
;
info
(
"
withBookmarksDialog
:
opening
the
dialog
"
)
;
executeSoon
(
openFn
)
;
info
(
"
withBookmarksDialog
:
waiting
for
the
dialog
"
)
;
let
dialogWin
=
await
dialogPromise
;
if
(
!
skipOverlayWait
)
{
info
(
"
waiting
for
the
overlay
to
be
loaded
"
)
;
await
waitForCondition
(
(
)
=
>
dialogWin
.
gEditItemOverlay
.
initialized
"
EditItemOverlay
should
be
initialized
"
)
;
}
let
doc
=
dialogWin
.
document
;
let
elt
=
doc
.
querySelector
(
"
textbox
:
not
(
[
collapsed
=
true
]
)
"
)
;
if
(
elt
)
{
info
(
"
waiting
for
focus
on
the
first
textfield
"
)
;
await
waitForCondition
(
(
)
=
>
doc
.
activeElement
=
=
elt
.
inputField
"
The
first
non
collapsed
textbox
should
have
been
focused
"
)
;
}
info
(
"
withBookmarksDialog
:
executing
the
task
"
)
;
let
closePromise
=
(
)
=
>
Promise
.
resolve
(
)
;
if
(
closeFn
)
{
closePromise
=
closeFn
(
dialogWin
)
;
}
try
{
await
taskFn
(
dialogWin
)
;
}
finally
{
if
(
!
closed
&
&
!
autoCancel
)
{
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
closed
"
The
test
should
have
closed
the
dialog
!
"
)
;
}
if
(
!
closed
)
{
info
(
"
withBookmarksDialog
:
canceling
the
dialog
"
)
;
doc
.
documentElement
.
cancelDialog
(
)
;
await
closePromise
;
}
}
}
;
var
openContextMenuForContentSelector
=
async
function
(
browser
selector
)
{
info
(
"
wait
for
the
context
menu
"
)
;
let
contextPromise
=
BrowserTestUtils
.
waitForEvent
(
document
.
getElementById
(
"
contentAreaContextMenu
"
)
"
popupshown
"
)
;
await
ContentTask
.
spawn
(
browser
{
selector
}
async
function
(
args
)
{
let
doc
=
content
.
document
;
let
elt
=
doc
.
querySelector
(
args
.
selector
)
;
dump
(
openContextMenuForContentSelector
:
found
{
elt
}
\
n
)
;
const
domWindowUtils
=
content
.
QueryInterface
(
Components
.
interfaces
.
nsIInterfaceRequestor
)
.
getInterface
(
Components
.
interfaces
.
nsIDOMWindowUtils
)
;
let
rect
=
elt
.
getBoundingClientRect
(
)
;
let
left
=
rect
.
left
+
rect
.
width
/
2
;
let
top
=
rect
.
top
+
rect
.
height
/
2
;
domWindowUtils
.
sendMouseEvent
(
"
contextmenu
"
left
top
2
1
0
false
0
0
true
)
;
}
)
;
await
contextPromise
;
}
;
var
waitForCondition
=
async
function
(
conditionFn
errorMsg
)
{
for
(
let
tries
=
0
;
tries
<
100
;
+
+
tries
)
{
if
(
(
await
conditionFn
(
)
)
)
return
;
await
new
Promise
(
resolve
=
>
{
if
(
!
waitForCondition
.
_timers
)
{
waitForCondition
.
_timers
=
new
Set
(
)
;
registerCleanupFunction
(
(
)
=
>
{
is
(
waitForCondition
.
_timers
.
size
0
"
All
the
wait
timers
have
been
removed
"
)
;
delete
waitForCondition
.
_timers
;
}
)
;
}
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
waitForCondition
.
_timers
.
add
(
timer
)
;
timer
.
init
(
(
)
=
>
{
waitForCondition
.
_timers
.
delete
(
timer
)
;
resolve
(
)
;
}
100
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
)
;
}
ok
(
false
errorMsg
)
;
}
;
function
fillBookmarkTextField
(
id
text
win
blur
=
true
)
{
let
elt
=
win
.
document
.
getElementById
(
id
)
;
elt
.
focus
(
)
;
elt
.
select
(
)
;
if
(
!
text
)
{
EventUtils
.
synthesizeKey
(
"
VK_DELETE
"
{
}
win
)
;
}
else
{
for
(
let
c
of
text
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
c
{
}
win
)
;
}
}
if
(
blur
)
elt
.
blur
(
)
;
}
var
withSidebarTree
=
async
function
(
type
taskFn
)
{
let
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
info
(
"
withSidebarTree
:
waiting
sidebar
load
"
)
;
let
sidebarLoadedPromise
=
new
Promise
(
resolve
=
>
{
sidebar
.
addEventListener
(
"
load
"
function
(
)
{
executeSoon
(
resolve
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
let
sidebarId
=
type
=
=
"
bookmarks
"
?
"
viewBookmarksSidebar
"
:
"
viewHistorySidebar
"
;
SidebarUI
.
show
(
sidebarId
)
;
await
sidebarLoadedPromise
;
let
treeId
=
type
=
=
"
bookmarks
"
?
"
bookmarks
-
view
"
:
"
historyTree
"
;
let
tree
=
sidebar
.
contentDocument
.
getElementById
(
treeId
)
;
info
(
"
withSidebarTree
:
executing
the
task
"
)
;
try
{
await
taskFn
(
tree
)
;
}
finally
{
SidebarUI
.
hide
(
)
;
}
}
;
function
promisePlacesInitComplete
(
)
{
const
gBrowserGlue
=
Cc
[
"
mozilla
.
org
/
browser
/
browserglue
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
let
placesInitCompleteObserved
=
TestUtils
.
topicObserved
(
"
places
-
browser
-
init
-
complete
"
)
;
gBrowserGlue
.
observe
(
null
"
browser
-
glue
-
test
"
"
places
-
browser
-
init
-
complete
"
)
;
return
placesInitCompleteObserved
;
}
function
promisePopupShown
(
popup
)
{
return
new
Promise
(
resolve
=
>
{
if
(
popup
.
state
=
=
"
open
"
)
{
resolve
(
)
;
}
else
{
let
onPopupShown
=
event
=
>
{
popup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
resolve
(
)
;
}
;
popup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
}
}
)
;
}
function
promisePopupHidden
(
popup
)
{
return
new
Promise
(
resolve
=
>
{
let
onPopupHidden
=
event
=
>
{
popup
.
removeEventListener
(
"
popuphidden
"
onPopupHidden
)
;
resolve
(
)
;
}
;
popup
.
addEventListener
(
"
popuphidden
"
onPopupHidden
)
;
}
)
;
}
