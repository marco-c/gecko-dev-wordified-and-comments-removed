ChromeUtils
.
defineModuleGetter
(
this
"
PlacesTestUtils
"
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TestUtils
"
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gFluentStrings
"
function
(
)
{
return
new
Localization
(
[
"
branding
/
brand
.
ftl
"
"
browser
/
browser
.
ftl
"
]
true
)
;
}
)
;
function
openLibrary
(
callback
aLeftPaneRoot
)
{
let
library
=
window
.
openDialog
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xhtml
"
"
"
"
chrome
toolbar
=
yes
dialog
=
no
resizable
"
aLeftPaneRoot
)
;
waitForFocus
(
function
(
)
{
checkLibraryPaneVisibility
(
library
aLeftPaneRoot
)
;
callback
(
library
)
;
}
library
)
;
return
library
;
}
function
promiseLibrary
(
aLeftPaneRoot
)
{
return
new
Promise
(
resolve
=
>
{
let
library
=
Services
.
wm
.
getMostRecentWindow
(
"
Places
:
Organizer
"
)
;
if
(
library
&
&
!
library
.
closed
)
{
if
(
aLeftPaneRoot
)
{
library
.
PlacesOrganizer
.
selectLeftPaneContainerByHierarchy
(
aLeftPaneRoot
)
;
}
checkLibraryPaneVisibility
(
library
aLeftPaneRoot
)
;
resolve
(
library
)
;
}
else
{
openLibrary
(
resolve
aLeftPaneRoot
)
;
}
}
)
;
}
function
promiseLibraryClosed
(
organizer
)
{
return
new
Promise
(
resolve
=
>
{
if
(
organizer
.
closed
)
{
resolve
(
)
;
return
;
}
organizer
.
addEventListener
(
"
unload
"
function
(
)
{
executeSoon
(
resolve
)
;
}
{
once
:
true
}
)
;
organizer
.
close
(
)
;
}
)
;
}
function
checkLibraryPaneVisibility
(
library
selectedPane
)
{
if
(
selectedPane
=
=
"
Downloads
"
)
{
Assert
.
ok
(
library
.
ContentTree
.
view
.
hidden
"
Bookmark
/
History
tree
is
hidden
"
)
;
Assert
.
ok
(
!
library
.
document
.
getElementById
(
"
downloadsListBox
"
)
.
hidden
"
Downloads
are
shown
"
)
;
}
else
{
Assert
.
ok
(
!
library
.
ContentTree
.
view
.
hidden
"
Bookmark
/
History
tree
is
shown
"
)
;
Assert
.
ok
(
library
.
document
.
getElementById
(
"
downloadsListBox
"
)
.
hidden
"
Downloads
are
hidden
"
)
;
}
Assert
.
ok
(
!
library
.
ContentArea
.
currentView
.
hidden
"
Current
view
is
shown
"
)
;
}
function
promiseClipboard
(
aPopulateClipboardFn
aFlavor
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
waitForClipboard
(
data
=
>
!
!
data
aPopulateClipboardFn
resolve
reject
aFlavor
)
;
}
)
;
}
function
synthesizeClickOnSelectedTreeCell
(
aTree
aOptions
)
{
if
(
aTree
.
view
.
selection
.
count
<
1
)
{
throw
new
Error
(
"
The
test
node
should
be
successfully
selected
"
)
;
}
let
min
=
{
}
max
=
{
}
;
aTree
.
view
.
selection
.
getRangeAt
(
0
min
max
)
;
let
rowID
=
min
.
value
;
aTree
.
ensureRowIsVisible
(
rowID
)
;
var
rect
=
aTree
.
getCoordsForCellItem
(
rowID
aTree
.
columns
[
0
]
"
text
"
)
;
var
x
=
rect
.
x
+
rect
.
width
/
2
;
var
y
=
rect
.
y
+
rect
.
height
/
2
;
EventUtils
.
synthesizeMouse
(
aTree
.
body
x
y
aOptions
|
|
{
}
aTree
.
ownerGlobal
)
;
}
function
promiseSetToolbarVisibility
(
aToolbar
aVisible
aCallback
)
{
if
(
isToolbarVisible
(
aToolbar
)
!
=
aVisible
)
{
let
visibilityChanged
=
TestUtils
.
waitForCondition
(
(
)
=
>
aToolbar
.
collapsed
!
=
aVisible
)
;
setToolbarVisibility
(
aToolbar
aVisible
undefined
false
)
;
return
visibilityChanged
;
}
return
Promise
.
resolve
(
)
;
}
function
isToolbarVisible
(
aToolbar
)
{
let
hidingAttribute
=
aToolbar
.
getAttribute
(
"
type
"
)
=
=
"
menubar
"
?
"
autohide
"
:
"
collapsed
"
;
let
hidingValue
=
aToolbar
.
getAttribute
(
hidingAttribute
)
.
toLowerCase
(
)
;
return
hidingValue
!
=
=
"
true
"
&
&
hidingValue
!
=
=
hidingAttribute
;
}
var
withBookmarksDialog
=
async
function
(
autoCancel
openFn
taskFn
closeFn
dialogUrl
=
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties
"
skipOverlayWait
=
false
)
{
let
closed
=
false
;
let
hasDialogBox
=
!
!
Services
.
wm
.
getMostRecentWindow
(
"
"
)
.
gDialogBox
;
let
dialogPromise
;
if
(
hasDialogBox
)
{
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
null
dialogUrl
{
isSubDialog
:
true
}
)
;
}
else
{
dialogPromise
=
BrowserTestUtils
.
domWindowOpenedAndLoaded
(
null
win
=
>
{
return
win
.
document
.
documentURI
.
startsWith
(
dialogUrl
)
;
}
)
.
then
(
win
=
>
{
ok
(
win
.
location
.
href
.
startsWith
(
dialogUrl
)
"
The
bookmark
properties
dialog
is
open
:
"
+
win
.
location
.
href
)
;
return
SimpleTest
.
promiseFocus
(
win
)
.
then
(
(
)
=
>
win
)
;
}
)
;
}
let
dialogClosePromise
=
dialogPromise
.
then
(
win
=
>
{
if
(
!
hasDialogBox
)
{
return
BrowserTestUtils
.
domWindowClosed
(
win
)
;
}
let
container
=
win
.
top
.
document
.
getElementById
(
"
window
-
modal
-
dialog
"
)
;
return
BrowserTestUtils
.
waitForEvent
(
container
"
close
"
)
.
then
(
(
)
=
>
{
return
BrowserTestUtils
.
waitForMutationCondition
(
container
{
childList
:
true
attributes
:
true
}
(
)
=
>
!
container
.
hasChildNodes
(
)
&
&
!
container
.
open
)
;
}
)
;
}
)
;
dialogClosePromise
.
then
(
(
)
=
>
{
closed
=
true
;
}
)
;
info
(
"
withBookmarksDialog
:
opening
the
dialog
"
)
;
executeSoon
(
openFn
)
;
info
(
"
withBookmarksDialog
:
waiting
for
the
dialog
"
)
;
let
dialogWin
=
await
dialogPromise
;
if
(
!
skipOverlayWait
)
{
info
(
"
waiting
for
the
overlay
to
be
loaded
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
dialogWin
.
gEditItemOverlay
.
initialized
"
EditItemOverlay
should
be
initialized
"
)
;
}
let
doc
=
dialogWin
.
document
;
let
elt
=
doc
.
querySelector
(
"
vbox
:
not
(
[
collapsed
=
true
]
)
>
input
"
)
;
ok
(
elt
"
There
should
be
an
input
to
focus
.
"
)
;
if
(
elt
)
{
info
(
"
waiting
for
focus
on
the
first
textfield
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
doc
.
activeElement
=
=
elt
"
The
first
non
collapsed
input
should
have
been
focused
"
)
;
}
info
(
"
withBookmarksDialog
:
executing
the
task
"
)
;
let
closePromise
=
(
)
=
>
Promise
.
resolve
(
)
;
if
(
closeFn
)
{
closePromise
=
closeFn
(
dialogWin
)
;
}
let
guid
;
try
{
await
taskFn
(
dialogWin
)
;
}
finally
{
if
(
!
closed
&
&
autoCancel
)
{
info
(
"
withBookmarksDialog
:
canceling
the
dialog
"
)
;
doc
.
getElementById
(
"
bookmarkpropertiesdialog
"
)
.
cancelDialog
(
)
;
await
closePromise
;
}
guid
=
await
PlacesUIUtils
.
lastBookmarkDialogDeferred
.
promise
;
await
dialogClosePromise
;
}
return
guid
;
}
;
var
openContextMenuForContentSelector
=
async
function
(
browser
selector
)
{
info
(
"
wait
for
the
context
menu
"
)
;
let
contextPromise
=
BrowserTestUtils
.
waitForEvent
(
document
.
getElementById
(
"
contentAreaContextMenu
"
)
"
popupshown
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
{
selector
}
]
async
function
(
args
)
{
let
doc
=
content
.
document
;
let
elt
=
doc
.
querySelector
(
args
.
selector
)
;
dump
(
openContextMenuForContentSelector
:
found
{
elt
}
\
n
)
;
const
domWindowUtils
=
content
.
windowUtils
;
let
rect
=
elt
.
getBoundingClientRect
(
)
;
let
left
=
rect
.
left
+
rect
.
width
/
2
;
let
top
=
rect
.
top
+
rect
.
height
/
2
;
domWindowUtils
.
sendMouseEvent
(
"
contextmenu
"
left
top
2
1
0
false
0
0
true
)
;
}
)
;
await
contextPromise
;
}
;
function
fillBookmarkTextField
(
id
text
win
blur
=
true
)
{
let
elt
=
win
.
document
.
getElementById
(
id
)
;
elt
.
focus
(
)
;
elt
.
select
(
)
;
if
(
!
text
)
{
EventUtils
.
synthesizeKey
(
"
VK_DELETE
"
{
}
win
)
;
}
else
{
for
(
let
c
of
text
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
c
{
}
win
)
;
}
}
if
(
blur
)
{
elt
.
blur
(
)
;
}
}
var
withSidebarTree
=
async
function
(
type
taskFn
)
{
let
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
info
(
"
withSidebarTree
:
waiting
sidebar
load
"
)
;
let
sidebarLoadedPromise
=
new
Promise
(
resolve
=
>
{
sidebar
.
addEventListener
(
"
load
"
function
(
)
{
executeSoon
(
resolve
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
let
sidebarId
=
type
=
=
"
bookmarks
"
?
"
viewBookmarksSidebar
"
:
"
viewHistorySidebar
"
;
SidebarUI
.
show
(
sidebarId
)
;
await
sidebarLoadedPromise
;
let
treeId
=
type
=
=
"
bookmarks
"
?
"
bookmarks
-
view
"
:
"
historyTree
"
;
let
tree
=
sidebar
.
contentDocument
.
getElementById
(
treeId
)
;
info
(
"
withSidebarTree
:
executing
the
task
"
)
;
try
{
await
taskFn
(
tree
)
;
}
finally
{
SidebarUI
.
hide
(
)
;
}
}
;
var
withLibraryWindow
=
async
function
(
hierarchy
taskFn
)
{
let
library
=
await
promiseLibrary
(
hierarchy
)
;
let
left
=
library
.
document
.
getElementById
(
"
placesList
"
)
;
let
right
=
library
.
document
.
getElementById
(
"
placeContent
"
)
;
info
(
"
withLibrary
:
executing
the
task
"
)
;
try
{
await
taskFn
(
{
left
right
}
)
;
}
finally
{
await
promiseLibraryClosed
(
library
)
;
}
}
;
function
promisePlacesInitComplete
(
)
{
const
gBrowserGlue
=
Cc
[
"
mozilla
.
org
/
browser
/
browserglue
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
let
placesInitCompleteObserved
=
TestUtils
.
topicObserved
(
"
places
-
browser
-
init
-
complete
"
)
;
gBrowserGlue
.
observe
(
null
"
browser
-
glue
-
test
"
"
places
-
browser
-
init
-
complete
"
)
;
return
placesInitCompleteObserved
;
}
function
promisePopupShown
(
popup
)
{
return
new
Promise
(
resolve
=
>
{
if
(
popup
.
state
=
=
"
open
"
)
{
resolve
(
)
;
}
else
{
let
onPopupShown
=
event
=
>
{
popup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
resolve
(
)
;
}
;
popup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
}
}
)
;
}
function
promisePopupHidden
(
popup
)
{
return
new
Promise
(
resolve
=
>
{
let
onPopupHidden
=
event
=
>
{
popup
.
removeEventListener
(
"
popuphidden
"
onPopupHidden
)
;
resolve
(
)
;
}
;
popup
.
addEventListener
(
"
popuphidden
"
onPopupHidden
)
;
}
)
;
}
function
getToolbarNodeForItemGuid
(
itemGuid
)
{
let
children
=
document
.
getElementById
(
"
PlacesToolbarItems
"
)
.
childNodes
;
for
(
let
child
of
children
)
{
if
(
itemGuid
=
=
=
child
.
_placesNode
.
bookmarkGuid
)
{
return
child
;
}
}
return
null
;
}
async
function
clickBookmarkStar
(
win
=
window
)
{
let
shownPromise
=
promisePopupShown
(
win
.
document
.
getElementById
(
"
editBookmarkPanel
"
)
)
;
win
.
BookmarkingUI
.
star
.
click
(
)
;
await
shownPromise
;
let
menuList
=
win
.
document
.
getElementById
(
"
editBMPanel_folderMenuList
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
menuList
{
attributes
:
true
}
(
)
=
>
!
!
menuList
.
getAttribute
(
"
selectedGuid
"
)
"
Should
select
the
menu
folder
item
"
)
;
}
async
function
hideBookmarksPanel
(
win
=
window
)
{
let
hiddenPromise
=
promisePopupHidden
(
win
.
document
.
getElementById
(
"
editBookmarkPanel
"
)
)
;
win
.
document
.
getElementById
(
"
editBookmarkPanelDoneButton
"
)
.
click
(
)
;
await
hiddenPromise
;
}
async
function
createAndRemoveDefaultFolder
(
)
{
let
tempFolder
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
[
{
title
:
"
temp
folder
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
]
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
bookmarks
.
defaultLocation
"
tempFolder
[
0
]
.
guid
]
]
}
)
;
let
defaultGUID
=
await
PlacesUIUtils
.
defaultParentGuid
;
is
(
defaultGUID
tempFolder
[
0
]
.
guid
"
check
default
guid
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
tempFolder
)
;
}
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
bookmarks
.
defaultLocation
"
)
;
}
)
;
