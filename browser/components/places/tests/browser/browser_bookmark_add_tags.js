"
use
strict
"
;
let
bookmarkPanel
;
let
bookmarkStar
;
async
function
clickBookmarkStar
(
)
{
let
shownPromise
=
promisePopupShown
(
bookmarkPanel
)
;
bookmarkStar
.
click
(
)
;
await
shownPromise
;
}
async
function
hideBookmarksPanel
(
callback
)
{
let
hiddenPromise
=
promisePopupHidden
(
bookmarkPanel
)
;
callback
(
)
;
await
hiddenPromise
;
}
registerCleanupFunction
(
async
(
)
=
>
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
)
;
add_task
(
async
function
test_add_bookmark_tags_from_bookmarkProperties
(
)
{
const
TEST_URL
=
"
about
:
robots
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
bookmarks
.
editDialog
.
delayedApply
.
enabled
"
false
]
]
}
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
:
win
.
gBrowser
opening
:
TEST_URL
waitForStateStop
:
true
}
)
;
win
.
StarUI
.
_createPanelIfNeeded
(
)
;
win
.
StarUI
.
_autoCloseTimeout
=
1000
;
bookmarkPanel
=
win
.
document
.
getElementById
(
"
editBookmarkPanel
"
)
;
bookmarkPanel
.
setAttribute
(
"
animate
"
false
)
;
bookmarkStar
=
win
.
BookmarkingUI
.
star
;
registerCleanupFunction
(
async
function
(
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
let
bookmarkPanelTitle
=
win
.
document
.
getElementById
(
"
editBookmarkPanelTitle
"
)
;
await
hideBookmarksPanel
(
async
(
)
=
>
{
await
clickBookmarkStar
(
)
;
Assert
.
equal
(
bookmarkPanelTitle
.
dataset
.
l10nId
"
bookmarks
-
add
-
bookmark
"
"
Bookmark
title
is
correct
"
)
;
Assert
.
equal
(
bookmarkStar
.
getAttribute
(
"
starred
"
)
"
true
"
"
Page
is
starred
"
)
;
}
)
;
await
clickBookmarkStar
(
)
;
Assert
.
equal
(
bookmarkPanelTitle
.
dataset
.
l10nId
"
bookmarks
-
edit
-
bookmark
"
"
Bookmark
title
is
correct
"
)
;
let
promiseNotification
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
added
"
events
=
>
events
.
some
(
(
{
url
}
)
=
>
!
url
|
|
url
=
=
TEST_URL
)
)
;
await
fillBookmarkTextField
(
"
editBMPanel_tagsField
"
"
tag1
"
win
)
;
await
promiseNotification
;
let
bookmarks
=
[
]
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
:
TEST_URL
}
bm
=
>
bookmarks
.
push
(
bm
)
)
;
Assert
.
equal
(
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
.
length
1
"
Found
the
right
number
of
tags
"
)
;
Assert
.
deepEqual
(
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
[
"
tag1
"
]
)
;
let
doneButton
=
win
.
document
.
getElementById
(
"
editBookmarkPanelDoneButton
"
)
;
await
hideBookmarksPanel
(
(
)
=
>
doneButton
.
click
(
)
)
;
await
clickBookmarkStar
(
)
;
promiseNotification
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
tags
-
changed
"
)
;
await
fillBookmarkTextField
(
"
editBMPanel_tagsField
"
"
tag1
tag2
tag3
"
win
)
;
await
promiseNotification
;
await
hideBookmarksPanel
(
(
)
=
>
doneButton
.
click
(
)
)
;
bookmarks
=
[
]
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
:
TEST_URL
}
bm
=
>
bookmarks
.
push
(
bm
)
)
;
Assert
.
equal
(
bookmarks
.
length
1
"
Only
one
bookmark
should
exist
"
)
;
Assert
.
equal
(
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
.
length
3
"
Found
the
right
number
of
tags
"
)
;
Assert
.
deepEqual
(
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
[
"
tag1
"
"
tag2
"
"
tag3
"
]
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
)
;
add_task
(
async
function
test_add_bookmark_tags_from_bookmarkProperties_delayed_apply
(
)
{
const
TEST_URL
=
"
about
:
robots
"
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
bookmarks
.
editDialog
.
delayedApply
.
enabled
"
true
]
]
}
)
;
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
win
.
gBrowser
url
:
TEST_URL
}
async
(
)
=
>
{
win
.
StarUI
.
_createPanelIfNeeded
(
)
;
const
panel
=
win
.
document
.
getElementById
(
"
editBookmarkPanel
"
)
;
const
star
=
win
.
BookmarkingUI
.
star
;
let
shownPromise
=
promisePopupShown
(
panel
)
;
star
.
click
(
)
;
await
shownPromise
;
await
fillBookmarkTextField
(
"
editBMPanel_tagsField
"
"
tag1
"
win
)
;
const
doneButton
=
win
.
document
.
getElementById
(
"
editBookmarkPanelDoneButton
"
)
;
const
bookmarkAddedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
added
"
events
=
>
events
.
some
(
(
{
url
}
)
=
>
!
url
|
|
url
=
=
TEST_URL
)
)
;
doneButton
.
click
(
)
;
await
bookmarkAddedPromise
;
Assert
.
deepEqual
(
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
[
"
tag1
"
]
"
The
initial
set
of
tags
is
correct
.
"
)
;
shownPromise
=
promisePopupShown
(
panel
)
;
star
.
click
(
)
;
await
shownPromise
;
await
fillBookmarkTextField
(
"
editBMPanel_tagsField
"
"
tag1
tag2
tag3
"
win
)
;
const
tagsChangedPromise
=
PlacesTestUtils
.
waitForNotification
(
"
bookmark
-
tags
-
changed
"
)
;
doneButton
.
click
(
)
;
await
tagsChangedPromise
;
Assert
.
deepEqual
(
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
[
"
tag1
"
"
tag2
"
"
tag3
"
]
"
The
updated
set
of
tags
is
correct
.
"
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_add_bookmark_tags_from_library
(
)
{
const
uri
=
"
http
:
/
/
example
.
com
/
"
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
url
:
uri
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
}
)
;
let
library
=
await
promiseLibrary
(
"
UnfiledBookmarks
"
)
;
registerCleanupFunction
(
async
function
(
)
{
await
promiseLibraryClosed
(
library
)
;
}
)
;
let
bookmarkNode
=
library
.
ContentTree
.
view
.
selectedNode
;
Assert
.
equal
(
bookmarkNode
.
uri
"
http
:
/
/
example
.
com
/
"
"
Found
the
expected
bookmark
"
)
;
fillBookmarkTextField
(
"
editBMPanel_tagsField
"
"
tag1
"
library
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
bookmarkNode
.
tags
=
=
=
"
tag1
"
"
Node
tag
is
correct
"
)
;
fillBookmarkTextField
(
"
editBMPanel_tagsField
"
"
tag1
tag2
"
library
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
bookmarkNode
.
tags
=
=
=
"
tag1
tag2
"
"
Node
tag
is
correct
"
)
;
let
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
uri
)
)
;
Assert
.
equal
(
tags
.
length
2
"
Found
the
right
number
of
tags
"
)
;
Assert
.
deepEqual
(
tags
[
"
tag1
"
"
tag2
"
]
"
Found
the
expected
tags
"
)
;
await
promiseLibraryClosed
(
library
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
)
;
add_task
(
async
function
test_add_bookmark_tags_from_sidebar
(
)
{
const
TEST_URL
=
"
about
:
buildconfig
"
;
let
bookmarks
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
TEST_URL
title
:
"
Bookmark
Title
"
}
)
;
await
withSidebarTree
(
"
bookmarks
"
async
function
(
tree
)
{
tree
.
selectItems
(
[
bookmarks
.
guid
]
)
;
await
addTags
(
[
"
tag1
"
]
tree
[
"
tag1
"
]
)
;
await
addTags
(
[
"
tag2
"
"
tag3
"
]
tree
[
"
tag1
"
"
tag2
"
"
tag3
"
]
)
;
}
)
;
async
function
addTags
(
tagValue
tree
expected
)
{
await
withBookmarksDialog
(
false
function
openPropertiesDialog
(
)
{
tree
.
controller
.
doCommand
(
"
placesCmd_show
:
info
"
)
;
}
async
function
test
(
dialogWin
)
{
PlacesUtils
.
tagging
.
tagURI
(
makeURI
(
TEST_URL
)
tagValue
)
;
let
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
;
Assert
.
deepEqual
(
tags
expected
"
Tags
field
is
correctly
populated
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
dialogWin
)
;
}
)
;
}
registerCleanupFunction
(
async
(
)
=
>
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
)
;
}
)
;
