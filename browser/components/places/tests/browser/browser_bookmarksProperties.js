const
IS_REVAMP
=
Services
.
prefs
.
getBoolPref
(
"
sidebar
.
revamp
"
)
;
const
SIDEBAR_HISTORY_TREE_ID
=
"
historyTree
"
;
const
SIDEBAR_BOOKMARKS_TREE_ID
=
"
bookmarks
-
view
"
;
const
SIDEBAR_HISTORY_ID
=
"
viewHistorySidebar
"
;
const
SIDEBAR_BOOKMARKS_ID
=
"
viewBookmarksSidebar
"
;
const
SIDEBAR_HISTORY_BYLASTVISITED_VIEW
=
IS_REVAMP
?
"
sidebar
-
history
-
sort
-
by
-
last
-
visited
"
:
"
bylastvisited
"
;
const
SIDEBAR_HISTORY_BYMOSTVISITED_VIEW
=
"
byvisited
"
;
const
SIDEBAR_HISTORY_BYDATE_VIEW
=
"
byday
"
;
const
SIDEBAR_HISTORY_BYSITE_VIEW
=
"
bysite
"
;
const
SIDEBAR_HISTORY_BYDATEANDSITE_VIEW
=
"
bydateandsite
"
;
const
ACTION_EDIT
=
0
;
const
ACTION_ADD
=
1
;
const
TYPE_FOLDER
=
0
;
const
TYPE_BOOKMARK
=
1
;
const
TEST_URL
=
"
https
:
/
/
www
.
example
.
com
/
"
;
const
DIALOG_URL
=
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarkProperties
.
xhtml
"
;
function
add_bookmark
(
url
)
{
return
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
title
:
bookmark
/
{
url
}
}
)
;
}
var
gTests
=
[
]
;
gTests
.
push
(
{
desc
:
"
Bug
462662
-
Pressing
Enter
to
select
tag
from
autocomplete
closes
bookmarks
properties
dialog
"
sidebar
:
SIDEBAR_BOOKMARKS_ID
action
:
ACTION_EDIT
itemType
:
null
window
:
null
_bookmark
:
null
_cleanShutdown
:
false
async
setup
(
)
{
this
.
_bookmark
=
await
add_bookmark
(
TEST_URL
)
;
Assert
.
ok
(
this
.
_bookmark
"
Correctly
added
a
bookmark
"
)
;
PlacesUtils
.
tagging
.
tagURI
(
Services
.
io
.
newURI
(
TEST_URL
)
[
"
testTag
"
]
)
;
var
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
;
Assert
.
equal
(
tags
[
0
]
"
testTag
"
"
Correctly
added
a
tag
"
)
;
}
selectNode
(
tree
)
{
tree
.
selectItems
(
[
PlacesUtils
.
bookmarks
.
unfiledGuid
]
)
;
PlacesUtils
.
asContainer
(
tree
.
selectedNode
)
.
containerOpen
=
true
;
tree
.
selectItems
(
[
this
.
_bookmark
.
guid
]
)
;
Assert
.
equal
(
tree
.
selectedNode
.
bookmarkGuid
this
.
_bookmark
.
guid
"
Bookmark
has
been
selected
"
)
;
}
async
run
(
)
{
var
tagsField
=
this
.
window
.
document
.
getElementById
(
"
editBMPanel_tagsField
"
)
;
var
self
=
this
;
let
unloadPromise
=
new
Promise
(
resolve
=
>
{
this
.
window
.
addEventListener
(
"
unload
"
function
(
)
{
tagsField
.
popup
.
removeEventListener
(
"
popuphidden
"
popupListener
true
)
;
Assert
.
ok
(
self
.
_cleanShutdown
"
Dialog
window
should
not
be
closed
by
pressing
Enter
on
the
autocomplete
popup
"
)
;
executeSoon
(
function
(
)
{
resolve
(
)
;
}
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
var
popupListener
=
{
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
popuphidden
"
:
self
.
_cleanShutdown
=
true
;
self
.
window
.
document
.
getElementById
(
"
bookmarkpropertiesdialog
"
)
.
cancelDialog
(
)
;
break
;
case
"
popupshown
"
:
tagsField
.
popup
.
removeEventListener
(
"
popupshown
"
this
true
)
;
let
richlistbox
=
tagsField
.
popup
.
richlistbox
;
Assert
.
equal
(
richlistbox
.
itemCount
1
"
We
have
1
autocomplete
result
"
)
;
tagsField
.
popup
.
selectedIndex
=
0
;
Assert
.
equal
(
richlistbox
.
selectedItems
.
length
1
"
We
have
selected
a
tag
from
the
autocomplete
popup
"
)
;
info
(
"
About
to
focus
the
autocomplete
results
"
)
;
richlistbox
.
focus
(
)
;
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
{
}
self
.
window
)
;
break
;
default
:
Assert
.
ok
(
false
"
unknown
event
:
"
+
aEvent
.
type
)
;
}
}
}
;
tagsField
.
popup
.
addEventListener
(
"
popupshown
"
popupListener
true
)
;
tagsField
.
popup
.
addEventListener
(
"
popuphidden
"
popupListener
true
)
;
info
(
"
About
to
focus
the
tagsField
"
)
;
executeSoon
(
(
)
=
>
{
tagsField
.
focus
(
)
;
tagsField
.
value
=
"
"
;
EventUtils
.
synthesizeKey
(
"
t
"
{
}
this
.
window
)
;
}
)
;
await
unloadPromise
;
}
finish
(
)
{
SidebarController
.
hide
(
)
;
}
async
cleanup
(
)
{
var
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
;
Assert
.
equal
(
tags
[
0
]
"
testTag
"
"
Tag
on
node
has
not
changed
"
)
;
PlacesUtils
.
tagging
.
untagURI
(
Services
.
io
.
newURI
(
TEST_URL
)
[
"
testTag
"
]
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
this
.
_bookmark
)
;
let
bm
=
await
PlacesUtils
.
bookmarks
.
fetch
(
this
.
_bookmark
.
guid
)
;
Assert
.
ok
(
!
bm
"
should
have
been
removed
"
)
;
}
}
)
;
gTests
.
push
(
{
desc
:
"
Bug
476020
-
Pressing
Esc
while
having
the
tag
autocomplete
open
closes
the
bookmarks
panel
"
sidebar
:
SIDEBAR_BOOKMARKS_ID
action
:
ACTION_EDIT
itemType
:
null
window
:
null
_bookmark
:
null
_cleanShutdown
:
false
async
setup
(
)
{
this
.
_bookmark
=
await
add_bookmark
(
TEST_URL
)
;
Assert
.
ok
(
this
.
_bookmark
"
Correctly
added
a
bookmark
"
)
;
PlacesUtils
.
tagging
.
tagURI
(
Services
.
io
.
newURI
(
TEST_URL
)
[
"
testTag
"
]
)
;
var
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
;
Assert
.
equal
(
tags
[
0
]
"
testTag
"
"
Correctly
added
a
tag
"
)
;
}
selectNode
(
tree
)
{
tree
.
selectItems
(
[
PlacesUtils
.
bookmarks
.
unfiledGuid
]
)
;
PlacesUtils
.
asContainer
(
tree
.
selectedNode
)
.
containerOpen
=
true
;
tree
.
selectItems
(
[
this
.
_bookmark
.
guid
]
)
;
Assert
.
equal
(
tree
.
selectedNode
.
bookmarkGuid
this
.
_bookmark
.
guid
"
Bookmark
has
been
selected
"
)
;
}
async
run
(
)
{
var
tagsField
=
this
.
window
.
document
.
getElementById
(
"
editBMPanel_tagsField
"
)
;
var
self
=
this
;
let
hiddenPromise
=
new
Promise
(
resolve
=
>
{
this
.
window
.
addEventListener
(
"
unload
"
function
(
)
{
tagsField
.
popup
.
removeEventListener
(
"
popuphidden
"
popupListener
true
)
;
Assert
.
ok
(
self
.
_cleanShutdown
"
Dialog
window
should
not
be
closed
by
pressing
Escape
on
the
autocomplete
popup
"
)
;
executeSoon
(
function
(
)
{
resolve
(
)
;
}
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
var
popupListener
=
{
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
popuphidden
"
:
self
.
_cleanShutdown
=
true
;
self
.
window
.
document
.
getElementById
(
"
bookmarkpropertiesdialog
"
)
.
cancelDialog
(
)
;
break
;
case
"
popupshown
"
:
tagsField
.
popup
.
removeEventListener
(
"
popupshown
"
this
true
)
;
let
richlistbox
=
tagsField
.
popup
.
richlistbox
;
Assert
.
equal
(
richlistbox
.
itemCount
1
"
We
have
1
autocomplete
result
"
)
;
tagsField
.
popup
.
selectedIndex
=
0
;
Assert
.
equal
(
richlistbox
.
selectedItems
.
length
1
"
We
have
selected
a
tag
from
the
autocomplete
popup
"
)
;
info
(
"
About
to
focus
the
autocomplete
results
"
)
;
richlistbox
.
focus
(
)
;
EventUtils
.
synthesizeKey
(
"
VK_ESCAPE
"
{
}
self
.
window
)
;
break
;
default
:
Assert
.
ok
(
false
"
unknown
event
:
"
+
aEvent
.
type
)
;
}
}
}
;
tagsField
.
popup
.
addEventListener
(
"
popupshown
"
popupListener
true
)
;
tagsField
.
popup
.
addEventListener
(
"
popuphidden
"
popupListener
true
)
;
info
(
"
About
to
focus
the
tagsField
"
)
;
tagsField
.
focus
(
)
;
tagsField
.
value
=
"
"
;
EventUtils
.
synthesizeKey
(
"
t
"
{
}
this
.
window
)
;
await
hiddenPromise
;
}
finish
(
)
{
SidebarController
.
hide
(
)
;
}
async
cleanup
(
)
{
var
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
Services
.
io
.
newURI
(
TEST_URL
)
)
;
Assert
.
equal
(
tags
[
0
]
"
testTag
"
"
Tag
on
node
has
not
changed
"
)
;
PlacesUtils
.
tagging
.
untagURI
(
Services
.
io
.
newURI
(
TEST_URL
)
[
"
testTag
"
]
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
this
.
_bookmark
)
;
let
bm
=
await
PlacesUtils
.
bookmarks
.
fetch
(
this
.
_bookmark
.
guid
)
;
Assert
.
ok
(
!
bm
"
should
have
been
removed
"
)
;
}
}
)
;
gTests
.
push
(
{
desc
:
Bug
491269
-
Test
that
editing
folder
name
in
bookmarks
properties
dialog
does
not
accept
the
dialog
sidebar
:
SIDEBAR_HISTORY_ID
dialogUrl
:
DIALOG_URL
action
:
ACTION_ADD
historyView
:
SIDEBAR_HISTORY_BYLASTVISITED_VIEW
window
:
null
async
setup
(
)
{
await
PlacesTestUtils
.
addVisits
(
TEST_URL
)
;
}
selectNode
(
tree
)
{
let
selectedNode
;
if
(
IS_REVAMP
)
{
const
itemList
=
tree
;
itemList
.
focusIndex
(
0
)
;
selectedNode
=
itemList
.
rowEls
[
0
]
;
}
else
{
let
visitNode
=
tree
.
view
.
nodeForTreeIndex
(
0
)
;
tree
.
selectNode
(
visitNode
)
;
selectedNode
=
tree
.
selectedNode
;
}
Assert
.
equal
(
selectedNode
.
uri
TEST_URL
"
The
correct
visit
has
been
selected
"
)
;
if
(
!
IS_REVAMP
)
{
Assert
.
equal
(
selectedNode
.
itemId
-
1
"
The
selected
node
is
not
bookmarked
"
)
;
}
return
selectedNode
;
}
async
run
(
)
{
var
foldersExpander
=
this
.
window
.
document
.
getElementById
(
"
editBMPanel_foldersExpander
"
)
;
var
folderTree
=
this
.
window
.
gEditItemOverlay
.
_folderTree
;
var
self
=
this
;
let
unloadPromise
=
new
Promise
(
resolve
=
>
{
this
.
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Assert
.
ok
(
self
.
_cleanShutdown
"
Dialog
window
should
not
be
closed
by
pressing
ESC
in
folder
name
textbox
"
)
;
executeSoon
(
(
)
=
>
{
resolve
(
)
;
}
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
const
observer
=
new
this
.
window
.
MutationObserver
(
(
aMutationList
aObserver
)
=
>
{
for
(
const
mutation
of
aMutationList
)
{
if
(
mutation
.
type
!
=
"
attributes
"
|
|
mutation
.
attributeName
!
=
"
place
"
)
{
continue
;
}
aObserver
.
disconnect
(
)
;
executeSoon
(
async
function
(
)
{
var
newFolderButton
=
self
.
window
.
document
.
getElementById
(
"
editBMPanel_newFolderButton
"
)
;
newFolderButton
.
doCommand
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
folderTree
.
hasAttribute
(
"
editing
"
)
"
We
are
editing
new
folder
name
in
folder
tree
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_ESCAPE
"
{
}
self
.
window
)
;
Assert
.
ok
(
!
folderTree
.
hasAttribute
(
"
editing
"
)
"
We
have
finished
editing
folder
name
in
folder
tree
"
)
;
self
.
_cleanShutdown
=
true
;
self
.
window
.
document
.
getElementById
(
"
bookmarkpropertiesdialog
"
)
.
cancelDialog
(
)
;
}
)
;
break
;
}
}
)
;
observer
.
observe
(
folderTree
{
attributes
:
true
}
)
;
foldersExpander
.
doCommand
(
)
;
await
unloadPromise
;
}
finish
(
)
{
SidebarController
.
hide
(
)
;
}
async
cleanup
(
)
{
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
}
)
;
add_setup
(
async
function
test_setup
(
)
{
requestLongerTimeout
(
2
)
;
}
)
;
add_task
(
async
function
test_run
(
)
{
for
(
let
test
of
gTests
)
{
info
(
Start
of
test
:
{
test
.
desc
}
)
;
await
test
.
setup
(
)
;
await
execute_test_in_sidebar
(
test
)
;
await
test
.
run
(
)
;
await
test
.
cleanup
(
)
;
await
test
.
finish
(
)
;
info
(
End
of
test
:
{
test
.
desc
}
)
;
}
}
)
;
function
execute_test_in_sidebar
(
test
)
{
return
new
Promise
(
resolve
=
>
{
var
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
sidebar
.
addEventListener
(
"
load
"
function
(
)
{
executeSoon
(
async
(
)
=
>
{
if
(
IS_REVAMP
&
&
test
.
sidebar
=
=
SIDEBAR_HISTORY_ID
)
{
await
open_properties_dialog_from_revamp_list
(
test
)
;
}
else
{
await
open_properties_dialog_from_tree
(
test
)
;
}
resolve
(
)
;
}
)
;
}
{
capture
:
true
once
:
true
}
)
;
SidebarController
.
show
(
test
.
sidebar
)
;
}
)
;
}
async
function
promise_properties_window
(
dialogUrl
=
DIALOG_URL
)
{
let
win
=
await
BrowserTestUtils
.
promiseAlertDialogOpen
(
null
dialogUrl
{
isSubDialog
:
true
}
)
;
await
SimpleTest
.
promiseFocus
(
win
)
;
await
win
.
document
.
mozSubdialogReady
;
return
win
;
}
async
function
open_properties_dialog_from_tree
(
test
)
{
var
sidebar
=
document
.
getElementById
(
"
sidebar
"
)
;
if
(
test
.
sidebar
=
=
SIDEBAR_HISTORY_ID
)
{
sidebar
.
contentDocument
.
getElementById
(
test
.
historyView
)
.
doCommand
(
)
;
}
var
sidebarTreeID
=
test
.
sidebar
=
=
SIDEBAR_BOOKMARKS_ID
?
SIDEBAR_BOOKMARKS_TREE_ID
:
SIDEBAR_HISTORY_TREE_ID
;
var
tree
=
sidebar
.
contentDocument
.
getElementById
(
sidebarTreeID
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
tree
"
Sidebar
tree
has
been
loaded
"
)
;
test
.
selectNode
(
tree
)
;
Assert
.
ok
(
tree
.
selectedNode
"
We
have
a
places
node
selected
:
"
+
tree
.
selectedNode
.
title
)
;
return
new
Promise
(
resolve
=
>
{
var
command
=
null
;
switch
(
test
.
action
)
{
case
ACTION_EDIT
:
command
=
"
placesCmd_show
:
info
"
;
break
;
case
ACTION_ADD
:
if
(
test
.
sidebar
=
=
SIDEBAR_BOOKMARKS_ID
)
{
if
(
test
.
itemType
=
=
TYPE_FOLDER
)
{
command
=
"
placesCmd_new
:
folder
"
;
}
else
if
(
test
.
itemType
=
=
TYPE_BOOKMARK
)
{
command
=
"
placesCmd_new
:
bookmark
"
;
}
else
{
Assert
.
ok
(
false
"
You
didn
'
t
set
a
valid
itemType
for
adding
an
item
"
)
;
}
}
else
{
command
=
"
placesCmd_createBookmark
"
;
}
break
;
default
:
Assert
.
ok
(
false
"
You
didn
'
t
set
a
valid
action
for
this
test
"
)
;
}
Assert
.
ok
(
tree
.
controller
.
isCommandEnabled
(
command
)
"
command
'
"
+
command
+
"
'
on
current
selected
node
is
enabled
"
)
;
promise_properties_window
(
test
.
dialogUrl
)
.
then
(
win
=
>
{
test
.
window
=
win
;
resolve
(
)
;
}
)
;
executeSoon
(
(
)
=
>
{
tree
.
controller
.
doCommand
(
command
)
;
}
)
;
}
)
;
}
async
function
open_properties_dialog_from_revamp_list
(
test
)
{
const
{
contentDocument
}
=
document
.
getElementById
(
"
sidebar
"
)
;
const
sidebarComponent
=
contentDocument
.
querySelector
(
"
sidebar
-
history
"
)
;
if
(
test
.
sidebar
=
=
SIDEBAR_HISTORY_ID
)
{
info
(
selecting
correct
history
view
:
{
test
.
historyView
}
)
;
let
menuItem
=
document
.
getElementById
(
test
.
historyView
)
;
menuItem
.
doCommand
(
)
;
await
sidebarComponent
.
updateComplete
;
}
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
!
sidebarComponent
.
cards
[
0
]
.
firstElementChild
.
rowEls
.
length
)
;
const
list
=
sidebarComponent
.
cards
[
0
]
.
firstElementChild
;
Assert
.
ok
(
list
&
&
BrowserTestUtils
.
isVisible
(
list
)
"
Sidebar
list
has
been
loaded
"
)
;
const
selectedNode
=
test
.
selectNode
(
list
)
;
Assert
.
ok
(
selectedNode
"
We
have
a
places
node
selected
:
"
+
selectedNode
)
;
return
new
Promise
(
resolve
=
>
{
promise_properties_window
(
test
.
dialogUrl
)
.
then
(
win
=
>
{
test
.
window
=
win
;
resolve
(
)
;
}
)
;
executeSoon
(
(
)
=
>
{
window
.
PlacesCommandHook
.
bookmarkLink
(
selectedNode
.
url
selectedNode
.
title
)
;
}
)
;
}
)
;
}
