let
gLibrary
=
null
;
async
function
testInFolder
(
folderGuid
prefix
)
{
let
addedBookmarks
=
[
]
;
let
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
1
url
:
http
:
/
/
{
prefix
}
1
.
mozilla
.
org
/
}
)
;
item
.
title
=
{
prefix
}
1_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
2
url
:
"
place
:
"
}
)
;
item
.
title
=
{
prefix
}
2_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
type
:
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
}
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
title
:
{
prefix
}
f
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
item
.
title
=
{
prefix
}
f_edited
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
addedBookmarks
.
push
(
item
)
;
item
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
item
.
guid
title
:
{
prefix
}
f1
url
:
http
:
/
/
{
prefix
}
f1
.
mozilla
.
org
/
}
)
;
addedBookmarks
.
push
(
item
)
;
item
.
index
=
0
;
await
PlacesUtils
.
bookmarks
.
update
(
item
)
;
return
addedBookmarks
;
}
add_task
(
async
function
test
(
)
{
requestLongerTimeout
(
2
)
;
gLibrary
=
await
promiseLibrary
(
)
;
PlacesUtils
.
bookmarks
.
addObserver
(
bookmarksObserver
)
;
PlacesUtils
.
annotations
.
addObserver
(
bookmarksObserver
)
;
let
addedBookmarks
=
[
]
;
ok
(
true
"
*
*
*
Acting
on
menu
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
menuGuid
"
bm
"
)
)
;
ok
(
true
"
*
*
*
Acting
on
toolbar
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
toolbarGuid
"
tb
"
)
)
;
ok
(
true
"
*
*
*
Acting
on
unsorted
bookmarks
"
)
;
addedBookmarks
=
addedBookmarks
.
concat
(
await
testInFolder
(
PlacesUtils
.
bookmarks
.
unfiledGuid
"
ub
"
)
)
;
for
(
let
i
=
0
;
i
<
addedBookmarks
.
length
;
i
+
+
)
{
try
{
await
PlacesUtils
.
bookmarks
.
remove
(
addedBookmarks
[
i
]
)
;
}
catch
(
ex
)
{
}
}
PlacesUtils
.
bookmarks
.
removeObserver
(
bookmarksObserver
)
;
PlacesUtils
.
annotations
.
removeObserver
(
bookmarksObserver
)
;
await
promiseLibraryClosed
(
gLibrary
)
;
}
)
;
let
bookmarksObserver
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsINavBookmarkObserver
Ci
.
nsIAnnotationObserver
]
)
onItemAnnotationSet
(
)
{
}
onItemAnnotationRemoved
(
)
{
}
onPageAnnotationSet
(
)
{
}
onPageAnnotationRemoved
(
)
{
}
onItemAdded
:
function
PSB_onItemAdded
(
aItemId
aFolderId
aIndex
aItemType
aURI
)
{
let
node
=
null
;
let
index
=
null
;
[
node
index
]
=
getNodeForTreeItem
(
aItemId
gLibrary
.
PlacesOrganizer
.
_places
)
;
switch
(
aItemType
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
let
uriString
=
aURI
.
spec
;
let
isQuery
=
uriString
.
substr
(
0
6
)
=
=
"
place
:
"
;
if
(
isQuery
)
{
isnot
(
node
null
"
Found
new
Places
node
in
left
pane
"
)
;
ok
(
index
>
=
0
"
Node
is
at
index
"
+
index
)
;
break
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
is
(
node
null
"
New
Places
node
not
added
in
left
pane
"
)
;
break
;
default
:
isnot
(
node
null
"
Found
new
Places
node
in
left
pane
"
)
;
ok
(
index
>
=
0
"
Node
is
at
index
"
+
index
)
;
}
}
onItemRemoved
:
function
PSB_onItemRemoved
(
aItemId
aFolder
aIndex
)
{
let
node
=
null
;
[
node
]
=
getNodeForTreeItem
(
aItemId
gLibrary
.
PlacesOrganizer
.
_places
)
;
is
(
node
null
"
Places
node
not
found
in
left
pane
"
)
;
}
onItemMoved
(
aItemId
aOldFolderId
aOldIndex
aNewFolderId
aNewIndex
aItemType
)
{
let
node
=
null
;
let
index
=
null
;
[
node
index
]
=
getNodeForTreeItem
(
aItemId
gLibrary
.
PlacesOrganizer
.
_places
)
;
switch
(
aItemType
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
let
uriString
=
PlacesUtils
.
bookmarks
.
getBookmarkURI
(
aItemId
)
.
spec
;
let
isQuery
=
uriString
.
substr
(
0
6
)
=
=
"
place
:
"
;
if
(
isQuery
)
{
isnot
(
node
null
"
Found
new
Places
node
in
left
pane
"
)
;
ok
(
index
>
=
0
"
Node
is
at
index
"
+
index
)
;
break
;
}
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
is
(
node
null
"
New
Places
node
not
added
in
left
pane
"
)
;
break
;
default
:
isnot
(
node
null
"
Found
new
Places
node
in
left
pane
"
)
;
ok
(
index
>
=
0
"
Node
is
at
index
"
+
index
)
;
}
}
onBeginUpdateBatch
:
function
PSB_onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
:
function
PSB_onEndUpdateBatch
(
)
{
}
onItemVisited
(
)
{
}
onItemChanged
:
function
PSB_onItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
)
{
if
(
aProperty
=
=
"
title
"
)
{
let
validator
=
function
(
aTreeRowIndex
)
{
let
tree
=
gLibrary
.
PlacesOrganizer
.
_places
;
let
cellText
=
tree
.
view
.
getCellText
(
aTreeRowIndex
tree
.
columns
.
getColumnAt
(
0
)
)
;
return
cellText
=
=
aNewValue
;
}
let
[
node
valid
]
=
getNodeForTreeItem
(
aItemId
gLibrary
.
PlacesOrganizer
.
_places
validator
)
;
if
(
node
)
ok
(
valid
"
Title
cell
value
has
been
correctly
updated
"
)
;
}
}
}
;
function
getNodeForTreeItem
(
aItemId
aTree
aValidator
)
{
function
findNode
(
aContainerIndex
)
{
if
(
aTree
.
view
.
isContainerEmpty
(
aContainerIndex
)
)
return
[
null
null
false
]
;
for
(
let
i
=
aContainerIndex
+
1
;
i
<
aTree
.
view
.
rowCount
;
i
+
+
)
{
let
node
=
aTree
.
view
.
nodeForTreeIndex
(
i
)
;
if
(
node
.
itemId
=
=
aItemId
)
{
let
valid
=
aValidator
?
aValidator
(
i
)
:
true
;
return
[
node
i
-
aTree
.
view
.
getParentIndex
(
i
)
-
1
valid
]
;
}
if
(
PlacesUtils
.
nodeIsFolder
(
node
)
)
{
aTree
.
view
.
toggleOpenState
(
i
)
;
let
foundNode
=
findNode
(
i
)
;
aTree
.
view
.
toggleOpenState
(
i
)
;
if
(
foundNode
[
0
]
!
=
null
)
return
foundNode
;
}
if
(
!
aTree
.
view
.
hasNextSibling
(
aContainerIndex
+
1
i
)
)
break
;
}
return
[
null
null
false
]
}
for
(
let
i
=
0
;
i
<
aTree
.
view
.
rowCount
;
i
+
+
)
{
aTree
.
view
.
toggleOpenState
(
i
)
;
let
foundNode
=
findNode
(
i
)
;
aTree
.
view
.
toggleOpenState
(
i
)
;
if
(
foundNode
[
0
]
!
=
null
)
return
foundNode
;
}
return
[
null
null
false
]
;
}
