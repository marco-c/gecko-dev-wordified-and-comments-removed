const
BASE_URL
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
browser
/
components
/
places
/
tests
/
browser
"
;
const
PAGE_URL
=
BASE_URL
+
"
/
framedPage
.
html
"
;
const
LEFT_URL
=
BASE_URL
+
"
/
frameLeft
.
html
"
;
const
RIGHT_URL
=
BASE_URL
+
"
/
frameRight
.
html
"
;
add_task
(
async
function
test
(
)
{
let
deferredLeftFrameVisit
=
PromiseUtils
.
defer
(
)
;
let
deferredRightFrameVisit
=
PromiseUtils
.
defer
(
)
;
Services
.
obs
.
addObserver
(
function
observe
(
subject
)
{
(
async
function
(
)
{
let
url
=
subject
.
QueryInterface
(
Ci
.
nsIURI
)
.
spec
;
if
(
url
=
=
LEFT_URL
)
{
is
(
await
getTransitionForUrl
(
url
)
null
"
Embed
visits
should
not
get
a
database
entry
.
"
)
;
deferredLeftFrameVisit
.
resolve
(
)
;
}
else
if
(
url
=
=
RIGHT_URL
)
{
is
(
await
getTransitionForUrl
(
url
)
PlacesUtils
.
history
.
TRANSITION_FRAMED_LINK
"
User
activated
visits
should
get
a
FRAMED_LINK
transition
.
"
)
;
Services
.
obs
.
removeObserver
(
observe
"
uri
-
visit
-
saved
"
)
;
deferredRightFrameVisit
.
resolve
(
)
;
}
}
)
(
)
;
}
"
uri
-
visit
-
saved
"
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
PAGE_URL
)
;
info
(
"
Waiting
left
frame
visit
"
)
;
await
deferredLeftFrameVisit
.
promise
;
info
(
"
Clicking
link
"
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
async
function
(
)
{
content
.
frames
[
0
]
.
document
.
getElementById
(
"
clickme
"
)
.
click
(
)
;
}
)
;
info
(
"
Waiting
right
frame
visit
"
)
;
await
deferredRightFrameVisit
.
promise
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
function
getTransitionForUrl
(
url
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
browser_markPageAsFollowedLink
"
async
db
=
>
{
let
rows
=
await
db
.
execute
(
SELECT
visit_type
FROM
moz_historyvisits
JOIN
moz_places
h
ON
place_id
=
h
.
id
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
}
)
;
return
rows
.
length
?
rows
[
0
]
.
getResultByName
(
"
visit_type
"
)
:
null
;
}
)
;
}
