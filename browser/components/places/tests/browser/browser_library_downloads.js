var
now
=
Date
.
now
(
)
;
function
test
(
)
{
waitForExplicitFinish
(
)
;
let
onLibraryReady
=
function
(
win
)
{
let
places
=
[
{
uri
:
NetUtil
.
newURI
(
"
http
:
/
/
mozilla
.
com
"
)
visits
:
[
new
VisitInfo
(
PlacesUtils
.
history
.
TRANSITION_TYPED
)
]
}
{
uri
:
NetUtil
.
newURI
(
"
http
:
/
/
google
.
com
"
)
visits
:
[
new
VisitInfo
(
PlacesUtils
.
history
.
TRANSITION_DOWNLOAD
)
]
}
{
uri
:
NetUtil
.
newURI
(
"
http
:
/
/
en
.
wikipedia
.
org
"
)
visits
:
[
new
VisitInfo
(
PlacesUtils
.
history
.
TRANSITION_TYPED
)
]
}
{
uri
:
NetUtil
.
newURI
(
"
http
:
/
/
ubuntu
.
org
"
)
visits
:
[
new
VisitInfo
(
PlacesUtils
.
history
.
TRANSITION_DOWNLOAD
)
]
}
]
;
PlacesUtils
.
asyncHistory
.
updatePlaces
(
places
{
handleResult
(
)
{
}
handleError
(
)
{
ok
(
false
"
gHistory
.
updatePlaces
(
)
failed
"
)
;
}
handleCompletion
(
)
{
isnot
(
win
.
PlacesOrganizer
.
_places
.
selectedNode
null
"
Downloads
is
present
and
selected
"
)
;
let
testURIs
=
[
"
http
:
/
/
ubuntu
.
org
/
"
"
http
:
/
/
google
.
com
/
"
]
;
for
(
let
element
of
win
.
ContentArea
.
currentView
.
associatedElement
.
children
)
{
is
(
element
.
_shell
.
download
.
source
.
url
testURIs
.
shift
(
)
"
URI
matches
"
)
;
}
win
.
close
(
)
;
PlacesTestUtils
.
clearHistory
(
)
.
then
(
finish
)
;
}
}
)
;
}
;
openLibrary
(
onLibraryReady
"
Downloads
"
)
;
}
function
VisitInfo
(
aTransitionType
)
{
this
.
transitionType
=
aTransitionType
=
=
=
undefined
?
PlacesUtils
.
history
.
TRANSITION_LINK
:
aTransitionType
;
this
.
visitDate
=
now
+
+
*
1000
;
}
VisitInfo
.
prototype
=
{
}
;
