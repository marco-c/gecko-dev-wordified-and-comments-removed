"
use
strict
"
;
const
{
PromptTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PromptTestUtils
.
sys
.
mjs
"
)
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
const
{
ForgetAboutSite
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ForgetAboutSite
.
sys
.
mjs
"
)
;
const
TEST_URIs
=
[
{
title
:
"
0
"
uri
:
"
https
:
/
/
example
.
com
"
}
{
title
:
"
1
"
uri
:
"
https
:
/
/
www
.
mozilla
.
org
/
test1
"
}
{
title
:
"
2
"
uri
:
"
https
:
/
/
www
.
mozilla
.
org
/
test2
"
}
{
title
:
"
3
"
uri
:
"
https
:
/
/
192
.
168
.
200
.
1
/
login
.
html
"
}
]
;
async
function
setup
(
)
{
registerCleanupFunction
(
async
function
(
)
{
sinon
.
restore
(
)
;
}
)
;
let
places
=
[
]
;
let
transition
=
PlacesUtils
.
history
.
TRANSITION_TYPED
;
TEST_URIs
.
forEach
(
(
{
title
uri
}
)
=
>
places
.
push
(
{
uri
:
Services
.
io
.
newURI
(
uri
)
transition
title
}
)
)
;
await
PlacesTestUtils
.
addVisits
(
places
)
;
}
async
function
teardown
(
organizer
)
{
await
promiseLibraryClosed
(
organizer
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
async
function
testForgetAboutThisSite
(
sitesToSelect
shouldForget
removedEntries
cancelConfirmWithEsc
=
false
)
{
if
(
cancelConfirmWithEsc
)
{
ok
(
!
shouldForget
"
If
cancelConfirmWithEsc
is
set
we
don
'
t
expect
to
clear
entries
.
"
)
;
}
ok
(
PlacesUtils
"
checking
PlacesUtils
running
in
chrome
context
?
"
)
;
await
setup
(
)
;
let
organizer
=
await
promiseHistoryView
(
)
;
let
doc
=
organizer
.
document
;
let
tree
=
doc
.
getElementById
(
"
placeContent
"
)
;
tree
.
view
.
_result
.
sortingMode
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_TITLE_ASCENDING
;
let
selection
=
tree
.
view
.
selection
;
selection
.
clearSelection
(
)
;
sitesToSelect
.
forEach
(
index
=
>
selection
.
rangedSelect
(
index
index
true
)
)
;
let
selectionCount
=
sitesToSelect
.
length
;
is
(
selection
.
count
selectionCount
"
The
selected
range
is
as
big
as
expected
"
)
;
let
contextmenu
=
doc
.
getElementById
(
"
placesContext
"
)
;
let
popupShown
=
promisePopupShown
(
contextmenu
)
;
let
rect
=
tree
.
getCoordsForCellItem
(
sitesToSelect
[
0
]
tree
.
columns
[
0
]
"
text
"
)
;
EventUtils
.
synthesizeMouse
(
tree
.
body
rect
.
x
+
rect
.
width
/
2
rect
.
y
+
rect
.
height
/
2
{
type
:
"
contextmenu
"
button
:
2
}
organizer
)
;
await
popupShown
;
let
forgetThisSite
=
doc
.
getElementById
(
"
placesContext_deleteHost
"
)
;
let
hideForgetThisSite
=
selectionCount
>
1
;
is
(
forgetThisSite
.
hidden
hideForgetThisSite
The
Forget
this
site
menu
item
should
{
hideForgetThisSite
?
"
"
:
"
not
"
}
be
hidden
with
{
selectionCount
}
items
selected
)
;
if
(
hideForgetThisSite
)
{
contextmenu
.
hidePopup
(
)
;
await
teardown
(
organizer
)
;
return
;
}
let
dialogPromise
;
if
(
cancelConfirmWithEsc
)
{
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
null
"
chrome
:
/
/
browser
/
content
/
places
/
clearDataForSite
.
xhtml
"
)
.
then
(
dialog
=
>
{
let
dialogClosedPromise
=
BrowserTestUtils
.
waitForEvent
(
dialog
"
unload
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
undefined
dialog
)
;
return
dialogClosedPromise
;
}
)
;
}
else
{
dialogPromise
=
BrowserTestUtils
.
promiseAlertDialog
(
shouldForget
?
"
accept
"
:
"
cancel
"
"
chrome
:
/
/
browser
/
content
/
places
/
clearDataForSite
.
xhtml
"
)
;
}
if
(
!
shouldForget
)
{
sinon
.
stub
(
ForgetAboutSite
"
removeDataFromBaseDomain
"
)
.
resolves
(
)
;
}
let
pageRemovedEventPromise
;
if
(
shouldForget
)
{
pageRemovedEventPromise
=
PlacesTestUtils
.
waitForNotification
(
"
page
-
removed
"
)
;
}
contextmenu
.
activateItem
(
forgetThisSite
)
;
await
dialogPromise
;
await
pageRemovedEventPromise
;
if
(
!
shouldForget
)
{
ok
(
ForgetAboutSite
.
removeDataFromBaseDomain
.
notCalled
"
Should
not
call
ForgetAboutSite
when
the
confirmation
prompt
is
cancelled
.
"
)
;
sinon
.
restore
(
)
;
}
await
Promise
.
all
(
removedEntries
.
map
(
async
(
{
uri
}
)
=
>
{
Assert
.
ok
(
!
(
await
PlacesUtils
.
history
.
fetch
(
uri
)
)
History
entry
for
{
uri
}
has
been
correctly
removed
)
;
}
)
)
;
await
Promise
.
all
(
TEST_URIs
.
filter
(
x
=
>
!
removedEntries
.
includes
(
x
)
)
.
map
(
async
(
{
uri
}
)
=
>
{
Assert
.
ok
(
await
PlacesUtils
.
history
.
fetch
(
uri
)
History
entry
for
{
uri
}
has
been
kept
)
;
}
)
)
;
await
teardown
(
organizer
)
;
}
async
function
promiseHistoryView
(
)
{
let
organizer
=
await
promiseLibrary
(
)
;
let
po
=
organizer
.
PlacesOrganizer
;
po
.
selectLeftPaneBuiltIn
(
"
History
"
)
;
let
histContainer
=
po
.
_places
.
selectedNode
.
QueryInterface
(
Ci
.
nsINavHistoryContainerResultNode
)
;
histContainer
.
containerOpen
=
true
;
po
.
_places
.
selectNode
(
histContainer
.
getChild
(
0
)
)
;
return
organizer
;
}
function
promisePopupShown
(
popup
)
{
return
new
Promise
(
resolve
=
>
{
popup
.
addEventListener
(
"
popupshown
"
function
(
)
{
resolve
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
}
add_task
(
async
function
selectMultiple
(
)
{
await
testForgetAboutThisSite
(
[
0
1
]
)
;
}
)
;
add_task
(
async
function
forgettingBasedomain
(
)
{
await
testForgetAboutThisSite
(
[
1
]
true
TEST_URIs
.
slice
(
1
3
)
)
;
}
)
;
add_task
(
async
function
forgettingIPAddress
(
)
{
await
testForgetAboutThisSite
(
[
3
]
true
TEST_URIs
.
slice
(
3
4
)
)
;
}
)
;
add_task
(
async
function
dontAlwaysForget
(
)
{
await
testForgetAboutThisSite
(
[
0
]
false
[
]
)
;
}
)
;
add_task
(
async
function
cancelConfirmWithEsc
(
)
{
await
testForgetAboutThisSite
(
[
0
]
false
[
]
true
)
;
}
)
;
