const
ENABLE_HISTORY_PREF
=
"
places
.
history
.
enabled
"
;
var
gLibrary
=
null
;
var
gTests
=
[
]
;
var
gCurrentTest
=
null
;
var
gTabsListener
=
{
_loadedURIs
:
[
]
_openTabsCount
:
0
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
!
=
"
TabOpen
"
)
return
;
if
(
+
+
this
.
_openTabsCount
=
=
gCurrentTest
.
URIs
.
length
)
{
is
(
gBrowser
.
tabs
.
length
gCurrentTest
.
URIs
.
length
+
1
"
We
have
opened
"
+
gCurrentTest
.
URIs
.
length
+
"
new
tab
(
s
)
"
)
;
}
var
tab
=
aEvent
.
target
;
is
(
tab
.
ownerGlobal
window
"
Tab
has
been
opened
in
current
browser
window
"
)
;
}
onLocationChange
(
aBrowser
aWebProgress
aRequest
aLocationURI
aFlags
)
{
var
spec
=
aLocationURI
.
spec
;
ok
(
true
spec
)
;
if
(
spec
=
=
"
about
:
blank
"
|
|
this
.
_loadedURIs
.
includes
(
spec
)
)
return
;
ok
(
gCurrentTest
.
URIs
.
includes
(
spec
)
"
Opened
URI
found
in
list
:
"
+
spec
)
;
if
(
gCurrentTest
.
URIs
.
includes
(
spec
)
)
this
.
_loadedURIs
.
push
(
spec
)
;
if
(
this
.
_loadedURIs
.
length
=
=
gCurrentTest
.
URIs
.
length
)
{
this
.
_loadedURIs
.
length
=
0
;
this
.
_openTabsCount
=
0
;
executeSoon
(
function
(
)
{
while
(
gBrowser
.
tabs
.
length
>
1
)
gBrowser
.
removeCurrentTab
(
)
;
waitForFocus
(
gCurrentTest
.
finish
gBrowser
.
ownerGlobal
)
;
}
)
;
}
}
}
gTests
.
push
(
{
desc
:
"
Open
a
folder
in
tabs
.
"
URIs
:
[
"
about
:
buildconfig
"
"
about
:
"
]
_folderId
:
-
1
setup
(
)
{
var
bs
=
PlacesUtils
.
bookmarks
;
var
folderId
=
bs
.
createFolder
(
bs
.
unfiledBookmarksFolder
"
Folder
"
bs
.
DEFAULT_INDEX
)
;
this
.
_folderId
=
folderId
;
this
.
URIs
.
forEach
(
function
(
aURI
)
{
bs
.
insertBookmark
(
folderId
PlacesUtils
.
_uri
(
aURI
)
bs
.
DEFAULT_INDEX
"
Title
"
)
;
}
)
;
gLibrary
.
PlacesOrganizer
.
selectLeftPaneQuery
(
"
UnfiledBookmarks
"
)
;
isnot
(
gLibrary
.
PlacesOrganizer
.
_places
.
selectedNode
null
"
We
correctly
have
selection
in
the
Library
left
pane
"
)
;
var
folderNode
=
gLibrary
.
ContentTree
.
view
.
view
.
nodeForTreeIndex
(
0
)
;
is
(
folderNode
.
title
"
Folder
"
"
Found
folder
in
the
right
pane
"
)
;
}
finish
(
)
{
setTimeout
(
runNextTest
0
)
;
}
cleanup
(
)
{
PlacesUtils
.
bookmarks
.
removeItem
(
this
.
_folderId
)
;
}
}
)
;
function
test
(
)
{
waitForExplicitFinish
(
)
;
ok
(
PlacesUtils
"
PlacesUtils
in
context
"
)
;
ok
(
PlacesUIUtils
"
PlacesUIUtils
in
context
"
)
;
gBrowser
.
tabContainer
.
addEventListener
(
"
TabOpen
"
gTabsListener
)
;
gBrowser
.
addTabsProgressListener
(
gTabsListener
)
;
gPrefService
.
setBoolPref
(
ENABLE_HISTORY_PREF
false
)
;
openLibrary
(
function
(
library
)
{
gLibrary
=
library
;
runNextTest
(
)
;
}
)
;
}
function
runNextTest
(
)
{
if
(
gCurrentTest
)
gCurrentTest
.
cleanup
(
)
;
if
(
gTests
.
length
>
0
)
{
gCurrentTest
=
gTests
.
shift
(
)
;
info
(
"
Start
of
test
:
"
+
gCurrentTest
.
desc
)
;
gCurrentTest
.
setup
(
)
;
gLibrary
.
focus
(
)
;
waitForFocus
(
function
(
)
{
mouseEventOnCell
(
gLibrary
.
PlacesOrganizer
.
_places
6
0
{
button
:
0
clickCount
:
2
}
gLibrary
.
PlacesOrganizer
.
_places
.
ownerGlobal
)
;
mouseEventOnCell
(
gLibrary
.
PlacesOrganizer
.
_places
7
0
{
button
:
1
}
)
;
}
gLibrary
)
;
}
else
{
gLibrary
.
close
(
)
;
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabOpen
"
gTabsListener
)
;
gBrowser
.
removeTabsProgressListener
(
gTabsListener
)
;
try
{
gPrefService
.
clearUserPref
(
ENABLE_HISTORY_PREF
)
;
}
catch
(
ex
)
{
}
finish
(
)
;
}
}
function
mouseEventOnCell
(
aTree
aRowIndex
aColumnIndex
aEventDetails
)
{
var
selection
=
aTree
.
view
.
selection
;
selection
.
select
(
aRowIndex
)
;
aTree
.
treeBoxObject
.
ensureRowIsVisible
(
aRowIndex
)
;
var
column
=
aTree
.
columns
[
aColumnIndex
]
;
var
rect
=
aTree
.
treeBoxObject
.
getCoordsForCellItem
(
aRowIndex
column
"
text
"
)
;
EventUtils
.
synthesizeMouse
(
aTree
.
body
rect
.
x
rect
.
y
aEventDetails
gLibrary
)
;
}
