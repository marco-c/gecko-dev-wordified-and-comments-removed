"
use
strict
"
;
const
bookmarksInfo
=
[
{
title
:
"
firefox
"
url
:
"
http
:
/
/
example
.
com
"
}
{
title
:
"
rules
"
url
:
"
http
:
/
/
example
.
com
/
2
"
}
{
title
:
"
yo
"
url
:
"
http
:
/
/
example
.
com
/
2
"
}
]
;
add_setup
(
async
function
(
)
{
if
(
navigator
.
platform
.
indexOf
(
"
Win
"
)
=
=
0
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
widget
.
windows
.
window_occlusion_tracking
.
enabled
"
false
]
]
}
)
;
}
let
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
let
wasCollapsed
=
toolbar
.
collapsed
;
await
setupBookmarksToolbar
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
if
(
wasCollapsed
)
{
await
promiseSetToolbarVisibility
(
toolbar
false
)
;
}
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
)
;
}
)
;
add_task
(
async
function
testShowingOtherBookmarksInToolbar
(
)
{
info
(
"
Check
the
initial
state
of
the
Other
Bookmarks
folder
.
"
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
setupBookmarksToolbar
(
win
)
;
ok
(
!
win
.
document
.
getElementById
(
"
OtherBookmarks
"
)
"
Shouldn
'
t
have
an
Other
Bookmarks
button
.
"
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
info
(
"
Check
visibility
of
an
empty
Other
Bookmarks
folder
.
"
)
;
await
testIsOtherBookmarksHidden
(
true
)
;
info
(
"
Ensure
folder
appears
in
toolbar
when
a
new
bookmark
is
added
.
"
)
;
let
bookmarks
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
bookmarksInfo
}
)
;
await
testIsOtherBookmarksHidden
(
false
)
;
info
(
"
Ensure
folder
disappears
from
toolbar
when
no
bookmarks
are
present
.
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmarks
)
;
await
testIsOtherBookmarksHidden
(
true
)
;
}
)
;
add_task
(
async
function
testOtherBookmarksVisibilityWhenMovingBookmarks
(
)
{
info
(
"
Add
bookmarks
to
Bookmarks
Toolbar
.
"
)
;
let
bookmarks
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
children
:
bookmarksInfo
}
)
;
await
testIsOtherBookmarksHidden
(
true
)
;
info
(
"
Move
toolbar
bookmarks
to
Other
Bookmarks
folder
.
"
)
;
await
PlacesUtils
.
bookmarks
.
moveToFolder
(
bookmarks
.
map
(
b
=
>
b
.
guid
)
PlacesUtils
.
bookmarks
.
unfiledGuid
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
)
;
await
testIsOtherBookmarksHidden
(
false
)
;
info
(
"
Move
bookmarks
from
Other
Bookmarks
back
to
the
toolbar
.
"
)
;
await
PlacesUtils
.
bookmarks
.
moveToFolder
(
bookmarks
.
map
(
b
=
>
b
.
guid
)
PlacesUtils
.
bookmarks
.
toolbarGuid
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
)
;
await
testIsOtherBookmarksHidden
(
true
)
;
}
)
;
add_task
(
async
function
testOtherBookmarksMenuPopup
(
)
{
info
(
"
Add
bookmarks
to
Other
Bookmarks
folder
.
"
)
;
let
bookmarks
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
bookmarksInfo
}
)
;
await
testIsOtherBookmarksHidden
(
false
)
;
info
(
"
Check
the
popup
menu
has
correct
number
of
children
.
"
)
;
await
openMenuPopup
(
"
#
OtherBookmarksPopup
"
"
#
OtherBookmarks
"
)
;
testNumberOfMenuPopupChildren
(
"
#
OtherBookmarksPopup
"
3
)
;
await
closeMenuPopup
(
"
#
OtherBookmarksPopup
"
)
;
info
(
"
Remove
a
bookmark
.
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmarks
[
0
]
)
;
await
openMenuPopup
(
"
#
OtherBookmarksPopup
"
"
#
OtherBookmarks
"
)
;
testNumberOfMenuPopupChildren
(
"
#
OtherBookmarksPopup
"
2
)
;
await
closeMenuPopup
(
"
#
OtherBookmarksPopup
"
)
;
}
)
;
add_task
(
async
function
testFolderPopup
(
)
{
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
[
{
title
:
"
folder
"
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
children
:
[
{
title
:
"
example
"
url
:
"
http
:
/
/
example
.
com
/
3
"
}
]
}
]
}
)
;
info
(
"
Check
for
popup
showing
event
when
folder
menuitem
is
selected
.
"
)
;
await
openMenuPopup
(
"
#
OtherBookmarksPopup
"
"
#
OtherBookmarks
"
)
;
await
openMenuPopup
(
"
#
OtherBookmarksPopup
menu
menupopup
"
"
#
OtherBookmarksPopup
menu
"
)
;
ok
(
true
"
Folder
menu
stored
in
Other
Bookmarks
expands
.
"
)
;
testNumberOfMenuPopupChildren
(
"
#
OtherBookmarksPopup
menu
menupopup
"
1
)
;
await
closeMenuPopup
(
"
#
OtherBookmarksPopup
"
)
;
}
)
;
add_task
(
async
function
testOnlyShowOtherFolderInBookmarksToolbar
(
)
{
await
setupBookmarksToolbar
(
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
bookmarksInfo
}
)
;
await
testIsOtherBookmarksHidden
(
false
)
;
let
widgetId
=
"
personal
-
bookmarks
"
;
CustomizableUI
.
addWidgetToArea
(
widgetId
CustomizableUI
.
AREA_NAVBAR
)
;
await
testIsOtherBookmarksHidden
(
true
)
;
CustomizableUI
.
reset
(
)
;
await
testIsOtherBookmarksHidden
(
false
)
;
}
)
;
add_task
(
async
function
testDeletingMenuItems
(
)
{
await
setupBookmarksToolbar
(
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
bookmarksInfo
}
)
;
await
testIsOtherBookmarksHidden
(
false
)
;
await
openMenuPopup
(
"
#
OtherBookmarksPopup
"
"
#
OtherBookmarks
"
)
;
testNumberOfMenuPopupChildren
(
"
#
OtherBookmarksPopup
"
3
)
;
info
(
"
Open
context
menu
for
popup
.
"
)
;
let
placesContext
=
document
.
getElementById
(
"
placesContext
"
)
;
let
popupEventPromise
=
BrowserTestUtils
.
waitForPopupEvent
(
placesContext
"
shown
"
)
;
let
menuitem
=
document
.
querySelector
(
"
#
OtherBookmarksPopup
menuitem
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuitem
{
type
:
"
contextmenu
"
}
)
;
await
popupEventPromise
;
info
(
"
Delete
bookmark
menu
item
from
popup
.
"
)
;
let
deleteMenuBookmark
=
document
.
getElementById
(
"
placesContext_deleteBookmark
"
)
;
placesContext
.
activateItem
(
deleteMenuBookmark
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
popup
=
document
.
querySelector
(
"
#
OtherBookmarksPopup
"
)
;
let
items
=
popup
.
querySelectorAll
(
"
menuitem
"
)
;
return
items
.
length
=
=
=
2
;
}
"
Failed
to
delete
bookmark
menuitem
.
Expected
2
menu
items
after
deletion
.
"
)
;
ok
(
true
"
Menu
item
was
removed
from
the
popup
.
"
)
;
await
closeMenuPopup
(
"
#
OtherBookmarksPopup
"
)
;
}
)
;
add_task
(
async
function
no_errors_when_bookmarks_placed_in_palette
(
)
{
CustomizableUI
.
removeWidgetFromArea
(
"
personal
-
bookmarks
"
)
;
let
consoleErrors
=
0
;
let
errorListener
=
{
observe
(
error
)
{
ok
(
false
{
error
.
message
}
{
error
.
stack
}
{
JSON
.
stringify
(
error
)
}
)
;
consoleErrors
+
+
;
}
}
;
Services
.
console
.
registerListener
(
errorListener
)
;
let
bookmarks
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
bookmarksInfo
}
)
;
is
(
consoleErrors
0
"
There
should
be
no
console
errors
"
)
;
Services
.
console
.
unregisterListener
(
errorListener
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmarks
)
;
CustomizableUI
.
reset
(
)
;
}
)
;
add_task
(
async
function
testShowingOtherBookmarksContextMenuItem
(
)
{
await
setupBookmarksToolbar
(
)
;
info
(
"
Add
bookmark
to
Other
Bookmarks
.
"
)
;
let
bookmark
=
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
[
{
title
:
"
firefox
"
url
:
"
http
:
/
/
example
.
com
"
}
]
}
)
;
info
(
"
'
Show
Other
Bookmarks
'
menu
item
should
be
checked
by
default
.
"
)
;
await
testOtherBookmarksCheckedState
(
true
)
;
info
(
"
Toggle
off
showing
the
Other
Bookmarks
folder
.
"
)
;
await
selectShowOtherBookmarksMenuItem
(
)
;
await
testOtherBookmarksCheckedState
(
false
)
;
await
testIsOtherBookmarksHidden
(
true
)
;
info
(
"
Toggle
on
showing
the
Other
Bookmarks
folder
.
"
)
;
await
selectShowOtherBookmarksMenuItem
(
)
;
await
testOtherBookmarksCheckedState
(
true
)
;
await
testIsOtherBookmarksHidden
(
false
)
;
info
(
"
Ensure
'
Show
Other
Bookmarks
'
isn
'
t
shown
when
Other
Bookmarks
is
empty
.
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
)
;
await
testIsOtherBookmarksMenuItemEnabled
(
false
)
;
info
(
"
Add
a
bookmark
to
the
empty
Other
Bookmarks
folder
.
"
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
[
{
title
:
"
firefox
"
url
:
"
http
:
/
/
example
.
com
"
}
]
}
)
;
await
testIsOtherBookmarksMenuItemEnabled
(
true
)
;
info
(
"
Ensure
that
displaying
Other
Bookmarks
is
consistent
across
separate
windows
.
"
)
;
let
newWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
otherBookmarks
=
newWin
.
document
.
getElementById
(
"
OtherBookmarks
"
)
;
return
otherBookmarks
&
&
!
otherBookmarks
.
hidden
;
}
"
Other
Bookmarks
folder
failed
to
show
in
other
window
.
"
)
;
info
(
"
Hide
the
Other
Bookmarks
folder
from
the
original
window
.
"
)
;
await
selectShowOtherBookmarksMenuItem
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
otherBookmarks
=
newWin
.
document
.
getElementById
(
"
OtherBookmarks
"
)
;
return
!
otherBookmarks
|
|
otherBookmarks
.
hidden
;
}
"
Other
Bookmarks
folder
failed
to
be
hidden
in
other
window
.
"
)
;
ok
(
true
"
Other
Bookmarks
was
successfully
hidden
in
other
window
.
"
)
;
info
(
"
Show
the
Other
Bookmarks
folder
from
the
original
window
.
"
)
;
await
selectShowOtherBookmarksMenuItem
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
otherBookmarks
=
newWin
.
document
.
getElementById
(
"
OtherBookmarks
"
)
;
return
otherBookmarks
&
&
!
otherBookmarks
.
hidden
;
}
"
Other
Bookmarks
folder
failed
to
be
shown
in
other
window
.
"
)
;
ok
(
true
"
Other
Bookmarks
was
successfully
shown
in
other
window
.
"
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
}
)
;
add_task
(
async
function
showOtherBookmarksMenuItemPrefDisabled
(
)
{
await
setupBookmarksToolbar
(
)
;
await
testIsOtherBookmarksMenuItemEnabled
(
false
)
;
}
)
;
add_task
(
async
function
testOtherBookmarksToolbarOverFlow
(
)
{
await
setupBookmarksToolbar
(
)
;
info
(
"
Ensure
that
visible
nodes
when
showing
/
hiding
Other
Bookmarks
is
consistent
across
separate
windows
.
"
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
children
:
[
{
title
:
"
firefox
"
url
:
"
http
:
/
/
example
.
com
"
}
]
}
)
;
let
newWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
PlacesUtils
.
bookmarks
.
insertTree
(
{
guid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
children
:
Array
(
100
)
.
fill
(
"
"
)
.
map
(
(
_
i
)
=
>
(
{
title
:
test
{
i
}
url
:
http
:
example
.
com
/
{
i
}
}
)
)
}
)
;
info
(
"
Hide
the
Other
Bookmarks
folder
from
the
original
window
.
"
)
;
await
selectShowOtherBookmarksMenuItem
(
"
#
OtherBookmarks
"
)
;
await
BrowserTestUtils
.
waitForEvent
(
document
.
getElementById
(
"
PersonalToolbar
"
)
"
BookmarksToolbarVisibilityUpdated
"
)
;
ok
(
true
"
Nodes
successfully
updated
for
both
windows
.
"
)
;
await
testUpdatedNodeVisibility
(
newWin
)
;
info
(
"
Show
the
Other
Bookmarks
folder
from
the
original
window
.
"
)
;
await
selectShowOtherBookmarksMenuItem
(
"
#
PlacesChevron
"
)
;
await
BrowserTestUtils
.
waitForEvent
(
document
.
getElementById
(
"
PersonalToolbar
"
)
"
BookmarksToolbarVisibilityUpdated
"
)
;
ok
(
true
"
Nodes
successfully
updated
for
both
windows
.
"
)
;
await
testUpdatedNodeVisibility
(
newWin
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
}
)
;
async
function
testIsOtherBookmarksHidden
(
expected
)
{
info
(
"
Test
whether
or
not
the
'
Other
Bookmarks
'
folder
is
visible
.
"
)
;
let
toolbar
=
document
.
getElementById
(
"
PersonalToolbar
"
)
;
await
promiseSetToolbarVisibility
(
toolbar
true
)
;
let
otherBookmarks
=
document
.
getElementById
(
"
OtherBookmarks
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
otherBookmarks
=
document
.
getElementById
(
"
OtherBookmarks
"
)
;
let
isHidden
=
!
otherBookmarks
|
|
otherBookmarks
.
hidden
;
return
isHidden
=
=
=
expected
;
}
"
Other
Bookmarks
folder
failed
to
change
hidden
state
.
"
)
;
ok
(
true
Other
Bookmarks
folder
"
hidden
"
state
should
be
{
expected
}
.
)
;
}
function
testNumberOfMenuPopupChildren
(
selector
expected
)
{
let
popup
=
document
.
querySelector
(
selector
)
;
let
items
=
popup
.
querySelectorAll
(
"
menuitem
"
)
;
is
(
items
.
length
expected
Number
of
menu
items
for
{
selector
}
should
be
{
expected
}
.
)
;
}
async
function
testOtherBookmarksCheckedState
(
expectedCheckedState
)
{
info
(
"
Check
'
Show
Other
Bookmarks
'
menu
item
state
"
)
;
await
openToolbarContextMenu
(
)
;
let
otherBookmarksMenuItem
=
document
.
querySelector
(
"
#
show
-
other
-
bookmarks_PersonalToolbar
"
)
;
is
(
otherBookmarksMenuItem
.
getAttribute
(
"
checked
"
)
{
expectedCheckedState
}
Other
Bookmarks
item
'
s
checked
state
should
be
{
expectedCheckedState
}
)
;
await
closeToolbarContextMenu
(
)
;
}
async
function
testIsOtherBookmarksMenuItemEnabled
(
expected
)
{
await
openToolbarContextMenu
(
)
;
let
otherBookmarksMenuItem
=
document
.
querySelector
(
"
#
show
-
other
-
bookmarks_PersonalToolbar
"
)
;
is
(
!
otherBookmarksMenuItem
.
disabled
expected
"
'
Show
Other
Bookmarks
'
menu
item
appearance
state
is
correct
.
"
)
;
await
closeToolbarContextMenu
(
)
;
}
async
function
openMenuPopup
(
popupSelector
targetSelector
)
{
let
popup
=
document
.
querySelector
(
popupSelector
)
;
let
target
=
document
.
querySelector
(
targetSelector
)
;
EventUtils
.
synthesizeMouseAtCenter
(
target
{
}
)
;
await
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
shown
"
)
;
}
async
function
closeMenuPopup
(
popupSelector
)
{
let
popup
=
document
.
querySelector
(
popupSelector
)
;
info
(
"
Closing
menu
popup
.
"
)
;
popup
.
hidePopup
(
)
;
await
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
hidden
"
)
;
}
async
function
openToolbarContextMenu
(
toolbarSelector
=
"
#
PlacesToolbarItems
"
)
{
let
contextMenu
=
document
.
getElementById
(
"
placesContext
"
)
;
let
toolbar
=
document
.
querySelector
(
toolbarSelector
)
;
let
openToolbarContextMenuPromise
=
BrowserTestUtils
.
waitForPopupEvent
(
contextMenu
"
shown
"
)
;
let
bounds
=
toolbar
.
getBoundingClientRect
(
)
;
EventUtils
.
synthesizeMouse
(
toolbar
bounds
.
width
-
5
5
{
type
:
"
contextmenu
"
}
)
;
await
openToolbarContextMenuPromise
;
}
async
function
closeToolbarContextMenu
(
)
{
let
contextMenu
=
document
.
getElementById
(
"
placesContext
"
)
;
let
closeToolbarContextMenuPromise
=
BrowserTestUtils
.
waitForPopupEvent
(
contextMenu
"
hidden
"
)
;
contextMenu
.
hidePopup
(
)
;
await
closeToolbarContextMenuPromise
;
}
async
function
setupBookmarksToolbar
(
win
=
window
)
{
let
toolbar
=
win
.
document
.
getElementById
(
"
PersonalToolbar
"
)
;
let
wasCollapsed
=
toolbar
.
collapsed
;
if
(
wasCollapsed
)
{
await
promiseSetToolbarVisibility
(
toolbar
true
)
;
}
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
async
function
selectShowOtherBookmarksMenuItem
(
selector
)
{
info
(
"
Select
'
Show
Other
Bookmarks
'
menu
item
"
)
;
await
openToolbarContextMenu
(
selector
)
;
let
otherBookmarksMenuItem
=
document
.
querySelector
(
"
#
show
-
other
-
bookmarks_PersonalToolbar
"
)
;
let
contextMenu
=
document
.
getElementById
(
"
placesContext
"
)
;
contextMenu
.
activateItem
(
otherBookmarksMenuItem
)
;
await
BrowserTestUtils
.
waitForPopupEvent
(
contextMenu
"
hidden
"
)
;
await
closeToolbarContextMenu
(
)
;
}
function
testUpdatedNodeVisibility
(
otherWin
)
{
let
toolbarItems
=
document
.
getElementById
(
"
PlacesToolbarItems
"
)
;
let
currentVisibleNodes
=
[
]
;
for
(
let
node
of
toolbarItems
.
children
)
{
if
(
node
.
style
.
visibility
=
=
=
"
visible
"
)
{
currentVisibleNodes
.
push
(
node
)
;
}
}
let
otherToolbarItems
=
otherWin
.
document
.
getElementById
(
"
PlacesToolbarItems
"
)
;
let
otherVisibleNodes
=
[
]
;
for
(
let
node
of
otherToolbarItems
.
children
)
{
if
(
node
.
style
.
visibility
=
=
=
"
visible
"
)
{
otherVisibleNodes
.
push
(
node
)
;
}
}
let
lastIdx
=
otherVisibleNodes
.
length
-
1
;
is
(
currentVisibleNodes
[
lastIdx
]
?
.
bookmarkGuid
otherVisibleNodes
[
lastIdx
]
?
.
bookmarkGuid
"
Last
visible
toolbar
bookmark
is
the
same
in
both
windows
.
"
)
;
}
