"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SnapshotGroups
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
Snapshots
:
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
MIN_GROUP_SIZE
"
"
browser
.
places
.
snapshots
.
minGroupSize
"
5
)
;
const
SnapshotGroups
=
new
(
class
SnapshotGroups
{
constructor
(
)
{
}
async
add
(
group
urls
)
{
let
id
=
-
1
;
await
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
add
"
async
db
=
>
{
let
row
=
await
db
.
executeCached
(
INSERT
INTO
moz_places_metadata_snapshots_groups
(
title
builder
builder_data
)
VALUES
(
:
title
:
builder
:
builder_data
)
RETURNING
id
{
title
:
group
.
title
builder
:
group
.
builder
builder_data
:
JSON
.
stringify
(
group
.
builderMetadata
)
}
)
;
id
=
row
[
0
]
.
getResultByIndex
(
0
)
;
await
this
.
#
insertUrls
(
db
id
urls
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
added
"
)
;
return
id
;
}
async
updateMetadata
(
group
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
updateMetadata
"
db
=
>
{
return
db
.
executeCached
(
UPDATE
moz_places_metadata_snapshots_groups
SET
title
=
:
title
builder
=
:
builder
builder_data
=
:
builder_data
WHERE
id
=
:
id
{
id
:
group
.
id
title
:
group
.
title
builder
:
group
.
builder
builder_data
:
JSON
.
stringify
(
group
.
builderMetadata
)
}
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
updated
"
)
;
}
async
updateUrls
(
id
urls
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
updateUrls
"
async
db
=
>
{
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_groups_to_snapshots
WHERE
group_id
=
:
id
{
id
}
)
;
await
this
.
#
insertUrls
(
db
id
urls
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
updated
"
)
;
}
async
delete
(
id
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
delete
"
async
db
=
>
{
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_snapshots_groups
WHERE
id
=
:
id
;
{
id
}
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
deleted
"
)
;
}
async
query
(
{
limit
=
50
builder
=
"
"
skipMinimum
=
false
}
=
{
}
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
params
=
{
builder
}
;
let
sizeFragment
=
"
"
;
let
limitFragment
=
"
"
;
if
(
!
skipMinimum
)
{
sizeFragment
=
"
HAVING
snapshot_count
>
=
:
minGroupSize
"
;
params
.
minGroupSize
=
MIN_GROUP_SIZE
;
}
if
(
limit
!
=
-
1
)
{
params
.
limit
=
limit
;
limitFragment
=
"
LIMIT
:
limit
"
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
g
.
id
g
.
title
g
.
builder
g
.
builder_data
COUNT
(
s
.
group_id
)
AS
snapshot_count
MAX
(
sn
.
last_interaction_at
)
AS
last_access
FROM
moz_places_metadata_snapshots_groups
g
LEFT
JOIN
moz_places_metadata_groups_to_snapshots
s
ON
s
.
group_id
=
g
.
id
LEFT
JOIN
moz_places_metadata_snapshots
sn
ON
sn
.
place_id
=
s
.
place_id
WHERE
builder
=
:
builder
OR
:
builder
=
"
"
GROUP
BY
g
.
id
{
sizeFragment
}
ORDER
BY
last_access
DESC
{
limitFragment
}
params
)
;
return
rows
.
map
(
row
=
>
this
.
#
translateSnapshotGroupRow
(
row
)
)
;
}
async
getUrls
(
{
id
}
)
{
let
params
=
{
group_id
:
id
}
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
urlRows
=
await
db
.
executeCached
(
SELECT
h
.
url
FROM
moz_places_metadata_groups_to_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
WHERE
s
.
group_id
=
:
group_id
ORDER
BY
h
.
last_visit_date
DESC
params
)
;
return
urlRows
.
map
(
row
=
>
row
.
getResultByName
(
"
url
"
)
)
;
}
async
getSnapshots
(
{
id
startIndex
=
0
count
=
50
sortDescending
=
true
sortBy
=
"
last_interaction_at
"
}
=
{
}
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
urlRows
=
await
db
.
executeCached
(
SELECT
h
.
url
FROM
moz_places_metadata_groups_to_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
WHERE
s
.
group_id
=
:
group_id
ORDER
BY
h
.
last_visit_date
DESC
{
group_id
:
id
}
)
;
let
snapshots
=
[
]
;
let
urls
=
urlRows
.
map
(
row
=
>
row
.
getResultByName
(
"
url
"
)
)
;
let
start
=
Math
.
max
(
0
startIndex
)
;
let
end
=
Math
.
min
(
urls
.
length
count
+
start
)
;
for
(
let
i
=
start
;
i
<
end
;
i
+
+
)
{
let
snapShot
=
await
Snapshots
.
get
(
urls
[
i
]
)
;
snapshots
.
push
(
snapShot
)
;
}
return
snapshots
;
}
async
#
insertUrls
(
db
id
urls
)
{
let
params
=
{
}
;
let
SQLInFragment
=
[
]
;
let
i
=
0
;
for
(
let
url
of
urls
)
{
params
[
url
{
i
}
]
=
url
;
SQLInFragment
.
push
(
hash
(
:
url
{
i
}
)
)
;
i
+
+
;
}
params
.
id
=
id
;
await
db
.
execute
(
INSERT
INTO
moz_places_metadata_groups_to_snapshots
(
group_id
place_id
)
SELECT
:
id
s
.
place_id
FROM
moz_places
h
JOIN
moz_places_metadata_snapshots
s
ON
h
.
id
=
s
.
place_id
WHERE
h
.
url_hash
IN
(
{
SQLInFragment
.
join
(
"
"
)
}
)
params
)
;
}
#
translateSnapshotGroupRow
(
row
)
{
let
snapshotGroup
=
{
id
:
row
.
getResultByName
(
"
id
"
)
title
:
row
.
getResultByName
(
"
title
"
)
builder
:
row
.
getResultByName
(
"
builder
"
)
builderMetadata
:
JSON
.
parse
(
row
.
getResultByName
(
"
builder_data
"
)
)
snapshotCount
:
row
.
getResultByName
(
"
snapshot_count
"
)
lastAccessed
:
row
.
getResultByName
(
"
last_access
"
)
}
;
return
snapshotGroup
;
}
}
)
(
)
;
