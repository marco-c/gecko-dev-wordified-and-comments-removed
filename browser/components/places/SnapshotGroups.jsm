"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SnapshotGroups
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
BackgroundPageThumbs
:
"
resource
:
/
/
gre
/
modules
/
BackgroundPageThumbs
.
jsm
"
PageThumbs
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
PlacesPreviews
:
"
resource
:
/
/
gre
/
modules
/
PlacesPreviews
.
jsm
"
PlacesUIUtils
:
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Snapshots
:
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
SnapshotMonitor
:
"
resource
:
/
/
/
modules
/
SnapshotMonitor
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
MIN_GROUP_SIZE
"
"
browser
.
places
.
snapshots
.
minGroupSize
"
5
)
;
const
SnapshotGroups
=
new
(
class
SnapshotGroups
{
constructor
(
)
{
}
async
add
(
group
urls
)
{
let
id
=
-
1
;
if
(
group
.
title
&
&
!
group
.
builderMetadata
?
.
title
)
{
if
(
!
group
.
builderMetadata
)
{
group
.
builderMetadata
=
{
}
;
}
group
.
builderMetadata
.
title
=
group
.
title
;
}
await
lazy
.
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
add
"
async
db
=
>
{
let
row
=
await
db
.
executeCached
(
INSERT
INTO
moz_places_metadata_snapshots_groups
(
builder
builder_data
)
VALUES
(
:
builder
:
builder_data
)
RETURNING
id
{
builder
:
group
.
builder
builder_data
:
JSON
.
stringify
(
group
.
builderMetadata
)
}
)
;
id
=
row
[
0
]
.
getResultByIndex
(
0
)
;
await
this
.
#
insertUrls
(
db
id
urls
)
;
}
)
;
this
.
#
prefetchScreenshotForGroup
(
id
)
.
catch
(
console
.
error
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
added
"
)
;
return
id
;
}
async
updateMetadata
(
group
)
{
let
params
=
{
id
:
group
.
id
}
;
let
setters
=
[
]
;
if
(
group
.
builderMetadata
)
{
params
.
builder_data
=
JSON
.
stringify
(
group
.
builderMetadata
)
;
setters
.
push
(
"
builder_data
=
json_patch
(
builder_data
:
builder_data
)
"
)
;
}
if
(
"
title
"
in
group
)
{
params
.
title
=
group
.
title
|
|
null
;
setters
.
push
(
"
title
=
:
title
"
)
;
}
if
(
"
hidden
"
in
group
)
{
params
.
hidden
=
group
.
hidden
?
1
:
0
;
setters
.
push
(
"
hidden
=
:
hidden
"
)
;
}
if
(
!
setters
.
length
)
{
return
;
}
await
lazy
.
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
updateMetadata
"
async
db
=
>
{
await
db
.
executeCached
(
UPDATE
moz_places_metadata_snapshots_groups
SET
{
setters
.
join
(
"
"
)
}
WHERE
id
=
:
id
params
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
updated
"
)
;
}
async
updateUrls
(
id
urls
)
{
await
lazy
.
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
updateUrls
"
async
db
=
>
{
let
params
=
{
id
}
;
let
SQLInFragment
=
[
.
.
.
urls
]
.
map
(
(
url
i
)
=
>
{
params
[
url
{
i
}
]
=
url
;
return
hash
(
:
url
{
i
}
)
;
}
)
.
join
(
"
"
)
;
await
db
.
executeTransaction
(
async
(
)
=
>
{
await
db
.
execute
(
CREATE
TEMP
TABLE
__groups_to_snapshots__
AS
SELECT
s
.
group_id
s
.
place_id
s
.
hidden
FROM
moz_places_metadata_groups_to_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
WHERE
s
.
group_id
=
:
id
AND
h
.
url_hash
IN
(
{
SQLInFragment
}
)
params
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_groups_to_snapshots
WHERE
group_id
=
:
id
{
id
}
)
;
await
db
.
executeCached
(
INSERT
INTO
moz_places_metadata_groups_to_snapshots
(
group_id
place_id
hidden
)
SELECT
group_id
place_id
hidden
FROM
__groups_to_snapshots__
)
;
await
this
.
#
insertUrls
(
db
id
urls
)
;
await
db
.
executeCached
(
DROP
TABLE
__groups_to_snapshots__
)
;
}
)
;
}
)
;
this
.
#
prefetchScreenshotForGroup
(
id
)
.
catch
(
console
.
error
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
updated
"
)
;
}
async
setUrlHidden
(
id
url
hidden
)
{
await
lazy
.
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
hideUrl
"
async
db
=
>
{
await
db
.
executeCached
(
UPDATE
moz_places_metadata_groups_to_snapshots
SET
hidden
=
:
hidden
WHERE
group_id
=
:
id
AND
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
{
id
url
hidden
}
)
;
}
)
;
this
.
#
prefetchScreenshotForGroup
(
id
)
.
catch
(
console
.
error
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
updated
"
)
;
}
async
delete
(
id
)
{
await
lazy
.
PlacesUtils
.
withConnectionWrapper
(
"
SnapshotsGroups
.
jsm
:
delete
"
async
db
=
>
{
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_snapshots_groups
WHERE
id
=
:
id
;
{
id
}
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
group
-
deleted
"
)
;
}
async
query
(
{
limit
=
50
builder
=
undefined
hidden
=
false
countHidden
=
false
skipMinimum
=
false
}
=
{
}
)
{
let
db
=
await
lazy
.
PlacesUtils
.
promiseDBConnection
(
)
;
let
params
=
{
}
;
let
sizeFragment
=
[
]
;
let
limitFragment
=
"
"
;
let
joinFragment
=
"
"
;
if
(
!
skipMinimum
)
{
sizeFragment
.
push
(
"
HAVING
snapshot_count
>
=
:
minGroupSize
"
)
;
params
.
minGroupSize
=
lazy
.
MIN_GROUP_SIZE
;
for
(
let
[
i
name
]
of
lazy
.
SnapshotMonitor
.
skipMinimumSizeBuilders
.
entries
(
)
)
{
params
[
name
{
i
}
]
=
name
;
sizeFragment
.
push
(
OR
(
builder
=
:
name
{
i
}
AND
snapshot_count
>
=
1
)
)
;
}
}
if
(
limit
!
=
-
1
)
{
params
.
limit
=
limit
;
limitFragment
=
"
LIMIT
:
limit
"
;
}
let
whereTerms
=
[
]
;
if
(
builder
)
{
whereTerms
.
push
(
"
builder
=
:
builder
"
)
;
params
.
builder
=
builder
;
}
if
(
!
hidden
)
{
whereTerms
.
push
(
"
g
.
hidden
=
0
"
)
;
}
if
(
!
countHidden
)
{
joinFragment
=
"
AND
s
.
hidden
=
0
"
;
}
let
where
=
whereTerms
.
length
?
WHERE
{
whereTerms
.
join
(
"
AND
"
)
}
:
"
"
;
let
rows
=
await
db
.
executeCached
(
SELECT
g
.
id
IFNULL
(
g
.
title
g
.
builder_data
-
>
>
'
title
'
)
AS
title
g
.
hidden
g
.
builder
g
.
builder_data
COUNT
(
s
.
group_id
)
AS
snapshot_count
MAX
(
sn
.
last_interaction_at
)
AS
last_access
(
SELECT
group_concat
(
IFNULL
(
preview_image_url
'
'
)
'
|
'
)
|
|
'
|
'
|
|
group_concat
(
url
'
|
'
)
FROM
(
SELECT
preview_image_url
url
FROM
moz_places_metadata_snapshots
sns
JOIN
moz_places_metadata_groups_to_snapshots
gs
USING
(
place_id
)
JOIN
moz_places
h
ON
h
.
id
=
gs
.
place_id
AND
gs
.
hidden
=
0
WHERE
gs
.
group_id
=
g
.
id
ORDER
BY
sns
.
last_interaction_at
ASC
LIMIT
2
)
)
AS
image_urls
FROM
moz_places_metadata_snapshots_groups
g
LEFT
JOIN
moz_places_metadata_groups_to_snapshots
s
ON
s
.
group_id
=
g
.
id
{
joinFragment
}
LEFT
JOIN
moz_places_metadata_snapshots
sn
ON
sn
.
place_id
=
s
.
place_id
{
where
}
GROUP
BY
g
.
id
{
sizeFragment
.
join
(
"
"
)
}
ORDER
BY
last_access
DESC
{
limitFragment
}
params
)
;
return
Promise
.
all
(
rows
.
map
(
row
=
>
this
.
#
translateSnapshotGroupRow
(
row
)
)
)
;
}
async
getUrls
(
{
id
hidden
}
)
{
let
db
=
await
lazy
.
PlacesUtils
.
promiseDBConnection
(
)
;
let
whereClause
=
"
"
;
if
(
!
hidden
)
{
whereClause
=
AND
s
.
hidden
=
0
;
}
let
urlRows
=
await
db
.
executeCached
(
SELECT
h
.
url
FROM
moz_places_metadata_groups_to_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
WHERE
s
.
group_id
=
:
group_id
{
whereClause
}
ORDER
BY
h
.
last_visit_date
DESC
{
group_id
:
id
}
)
;
return
urlRows
.
map
(
row
=
>
row
.
getResultByName
(
"
url
"
)
)
;
}
async
getSnapshots
(
{
id
startIndex
=
0
count
=
50
hidden
=
false
sortDescending
=
true
sortBy
=
"
last_interaction_at
"
}
=
{
}
)
{
if
(
!
[
"
last_visit_date
"
"
last_interaction_at
"
]
.
includes
(
sortBy
)
)
{
throw
new
Error
(
"
Unknown
sortBy
value
"
)
;
}
let
start
=
Math
.
max
(
0
startIndex
)
;
let
snapshots
=
await
lazy
.
Snapshots
.
query
(
{
limit
:
start
+
count
group
:
id
includeHiddenInGroup
:
hidden
sortBy
sortDescending
}
)
;
let
end
=
Math
.
min
(
snapshots
.
length
count
+
start
)
;
snapshots
=
snapshots
.
slice
(
start
end
)
;
lazy
.
PlacesUIUtils
.
insertTitleStartDiffs
(
snapshots
)
;
return
snapshots
;
}
async
#
insertUrls
(
db
id
urls
)
{
let
params
=
{
}
;
let
SQLInFragment
=
[
]
;
let
i
=
0
;
for
(
let
url
of
urls
)
{
params
[
url
{
i
}
]
=
url
;
SQLInFragment
.
push
(
hash
(
:
url
{
i
}
)
)
;
i
+
+
;
}
params
.
id
=
id
;
await
db
.
execute
(
INSERT
OR
IGNORE
INTO
moz_places_metadata_groups_to_snapshots
(
group_id
place_id
)
SELECT
:
id
s
.
place_id
FROM
moz_places
h
JOIN
moz_places_metadata_snapshots
s
ON
h
.
id
=
s
.
place_id
WHERE
h
.
url_hash
IN
(
{
SQLInFragment
.
join
(
"
"
)
}
)
params
)
;
}
async
#
translateSnapshotGroupRow
(
row
)
{
let
imageUrls
=
row
.
getResultByName
(
"
image_urls
"
)
?
.
split
(
"
|
"
)
;
let
imageUrl
faviconDataUrl
imagePageUrl
;
if
(
imageUrls
)
{
imageUrl
=
imageUrls
[
0
]
|
|
imageUrls
[
1
]
;
if
(
!
imageUrl
&
&
imageUrls
[
2
]
)
{
imageUrl
=
imageUrls
[
2
]
;
if
(
lazy
.
PlacesPreviews
.
enabled
)
{
imageUrl
=
lazy
.
PlacesPreviews
.
getPageThumbURL
(
imageUrl
)
;
}
else
{
imageUrl
=
lazy
.
PageThumbs
.
getThumbnailURL
(
imageUrl
)
;
}
}
imagePageUrl
=
imageUrls
[
2
]
&
&
!
imageUrls
[
0
]
&
&
imageUrls
[
1
]
?
imageUrls
[
3
]
:
imageUrls
[
2
]
;
if
(
imagePageUrl
)
{
faviconDataUrl
=
await
new
Promise
(
resolve
=
>
{
lazy
.
PlacesUtils
.
favicons
.
getFaviconDataForPage
(
Services
.
io
.
newURI
(
imagePageUrl
)
(
uri
dataLength
data
mimeType
)
=
>
{
if
(
dataLength
)
{
let
b64
=
btoa
(
data
.
reduce
(
(
d
byte
)
=
>
d
+
String
.
fromCharCode
(
byte
)
"
"
)
)
;
resolve
(
data
:
{
mimeType
}
;
base64
{
b64
}
)
;
return
;
}
resolve
(
undefined
)
;
}
)
;
}
)
;
}
}
let
snapshotGroup
=
{
id
:
row
.
getResultByName
(
"
id
"
)
faviconDataUrl
imageUrl
imagePageUrl
title
:
row
.
getResultByName
(
"
title
"
)
|
|
"
"
hidden
:
row
.
getResultByName
(
"
hidden
"
)
=
=
1
builder
:
row
.
getResultByName
(
"
builder
"
)
builderMetadata
:
JSON
.
parse
(
row
.
getResultByName
(
"
builder_data
"
)
)
snapshotCount
:
row
.
getResultByName
(
"
snapshot_count
"
)
lastAccessed
:
row
.
getResultByName
(
"
last_access
"
)
}
;
return
snapshotGroup
;
}
async
#
prefetchScreenshotForGroup
(
id
)
{
let
snapshots
=
await
this
.
getSnapshots
(
{
id
start
:
0
count
:
1
sortBy
:
"
last_interaction_at
"
sortDescending
:
false
}
)
;
if
(
!
snapshots
.
length
)
{
return
;
}
let
url
=
snapshots
[
0
]
.
url
;
if
(
lazy
.
PlacesPreviews
.
enabled
)
{
await
lazy
.
PlacesPreviews
.
update
(
url
)
;
}
else
{
await
lazy
.
BackgroundPageThumbs
.
captureIfMissing
(
url
)
;
}
}
}
)
(
)
;
