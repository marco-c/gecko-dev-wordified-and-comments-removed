const
{
Interactions
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
Interactions
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Snapshots
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
{
PlacesDBUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesDBUtils
.
jsm
"
)
;
class
TableViewer
{
maxRows
=
100
;
#
lastFilledRows
=
0
;
columnMap
;
#
timer
;
async
start
(
)
{
this
.
setupUI
(
)
;
await
this
.
updateDisplay
(
)
;
this
.
#
timer
=
setInterval
(
this
.
updateDisplay
.
bind
(
this
)
10000
)
;
}
pause
(
)
{
if
(
this
.
#
timer
)
{
clearInterval
(
this
.
#
timer
)
;
this
.
#
timer
=
null
;
}
}
setupUI
(
)
{
document
.
getElementById
(
"
title
"
)
.
textContent
=
this
.
title
;
let
viewer
=
document
.
getElementById
(
"
tableViewer
"
)
;
viewer
.
textContent
=
"
"
;
let
existingStyle
=
document
.
getElementById
(
"
tableStyle
"
)
;
let
numColumns
=
this
.
columnMap
.
size
;
let
styleText
=
#
tableViewer
{
display
:
grid
;
grid
-
template
-
columns
:
{
this
.
cssGridTemplateColumns
}
}
/
*
Sets
the
first
row
of
elements
to
bold
.
The
number
is
the
number
of
columns
*
/
#
tableViewer
>
div
:
nth
-
child
(
-
n
+
{
numColumns
}
)
{
font
-
weight
:
bold
;
}
/
*
Highlights
every
other
row
to
make
visual
scanning
of
the
table
easier
.
The
numbers
need
to
be
adapted
if
the
number
of
columns
changes
.
*
/
;
for
(
let
i
=
numColumns
+
1
;
i
<
=
numColumns
*
2
-
1
;
i
+
+
)
{
styleText
+
=
#
tableViewer
>
div
:
nth
-
child
(
{
numColumns
}
n
+
{
i
}
)
:
nth
-
child
(
{
numColumns
*
2
}
n
+
{
i
}
)
\
n
;
}
styleText
+
=
#
tableViewer
>
div
:
nth
-
child
(
{
numColumns
}
n
+
{
numColumns
*
2
}
)
:
nth
-
child
(
{
numColumns
*
2
}
n
+
{
numColumns
*
2
}
)
\
n
{
background
:
var
(
-
-
in
-
content
-
box
-
background
-
odd
)
;
}
;
existingStyle
.
innerText
=
styleText
;
let
tableBody
=
document
.
createDocumentFragment
(
)
;
let
header
=
document
.
createDocumentFragment
(
)
;
for
(
let
details
of
this
.
columnMap
.
values
(
)
)
{
let
columnDiv
=
document
.
createElement
(
"
div
"
)
;
columnDiv
.
textContent
=
details
.
header
;
header
.
appendChild
(
columnDiv
)
;
}
tableBody
.
appendChild
(
header
)
;
for
(
let
i
=
0
;
i
<
this
.
maxRows
;
i
+
+
)
{
let
row
=
document
.
createDocumentFragment
(
)
;
for
(
let
j
=
0
;
j
<
this
.
columnMap
.
size
;
j
+
+
)
{
row
.
appendChild
(
document
.
createElement
(
"
div
"
)
)
;
}
tableBody
.
appendChild
(
row
)
;
}
viewer
.
appendChild
(
tableBody
)
;
let
limit
=
document
.
getElementById
(
"
tableLimit
"
)
;
limit
.
textContent
=
Maximum
rows
displayed
:
{
this
.
maxRows
}
.
;
this
.
#
lastFilledRows
=
0
;
}
displayData
(
rows
)
{
if
(
gCurrentHandler
!
=
this
)
{
return
;
}
let
viewer
=
document
.
getElementById
(
"
tableViewer
"
)
;
let
index
=
this
.
columnMap
.
size
;
for
(
let
row
of
rows
)
{
for
(
let
[
column
details
]
of
this
.
columnMap
.
entries
(
)
)
{
let
value
=
row
[
column
]
;
if
(
details
.
includeTitle
)
{
viewer
.
children
[
index
]
.
setAttribute
(
"
title
"
value
)
;
}
viewer
.
children
[
index
]
.
textContent
=
details
.
modifier
?
details
.
modifier
(
value
)
:
value
;
index
+
+
;
}
}
let
numRows
=
rows
.
length
;
if
(
numRows
<
this
.
#
lastFilledRows
)
{
for
(
let
r
=
numRows
;
r
<
this
.
#
lastFilledRows
;
r
+
+
)
{
for
(
let
c
=
0
;
c
<
this
.
columnMap
.
size
;
c
+
+
)
{
viewer
.
children
[
index
]
.
textContent
=
"
"
;
viewer
.
children
[
index
]
.
removeAttribute
(
"
title
"
)
;
index
+
+
;
}
}
}
this
.
#
lastFilledRows
=
numRows
;
}
}
const
metadataHandler
=
new
(
class
extends
TableViewer
{
title
=
"
Interactions
"
;
cssGridTemplateColumns
=
"
max
-
content
fit
-
content
(
100
%
)
repeat
(
5
max
-
content
)
;
"
;
columnMap
=
new
Map
(
[
[
"
id
"
{
header
:
"
ID
"
}
]
[
"
url
"
{
header
:
"
URL
"
includeTitle
:
true
}
]
[
"
updated_at
"
{
header
:
"
Updated
"
modifier
:
updatedAt
=
>
new
Date
(
updatedAt
)
.
toLocaleString
(
)
}
]
[
"
total_view_time
"
{
header
:
"
View
Time
(
s
)
"
modifier
:
totalViewTime
=
>
(
totalViewTime
/
1000
)
.
toFixed
(
2
)
}
]
[
"
typing_time
"
{
header
:
"
Typing
Time
(
s
)
"
modifier
:
typingTime
=
>
(
typingTime
/
1000
)
.
toFixed
(
2
)
}
]
[
"
key_presses
"
{
header
:
"
Key
Presses
"
}
]
[
"
referrer
"
{
header
:
"
Referrer
"
includeTitle
:
true
}
]
]
)
;
#
db
=
null
;
async
#
getRows
(
query
columns
=
[
.
.
.
this
.
columnMap
.
keys
(
)
]
)
{
if
(
!
this
.
#
db
)
{
this
.
#
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
}
let
rows
=
await
this
.
#
db
.
executeCached
(
query
)
;
return
rows
.
map
(
r
=
>
{
let
result
=
{
}
;
for
(
let
column
of
columns
)
{
result
[
column
]
=
r
.
getResultByName
(
column
)
;
}
return
result
;
}
)
;
}
async
updateDisplay
(
)
{
let
rows
=
await
this
.
#
getRows
(
SELECT
m
.
id
AS
id
h
.
url
AS
url
updated_at
total_view_time
typing_time
key_presses
h2
.
url
as
referrer
FROM
moz_places_metadata
m
JOIN
moz_places
h
ON
h
.
id
=
m
.
place_id
LEFT
JOIN
moz_places
h2
ON
h2
.
id
=
m
.
referrer_place_id
ORDER
BY
updated_at
DESC
LIMIT
{
this
.
maxRows
}
)
;
this
.
displayData
(
rows
)
;
}
export
(
)
{
return
this
.
#
getRows
(
SELECT
m
.
id
AS
id
url_hash
updated_at
total_view_time
visit_count
frecency
typing_time
key_presses
last_visit_date
FROM
moz_places_metadata
m
JOIN
moz_places
h
ON
h
.
id
=
m
.
place_id
ORDER
BY
updated_at
DESC
[
"
id
"
"
url_hash
"
"
visit_count
"
"
frecency
"
"
last_visit_date
"
"
updated_at
"
"
total_view_time
"
"
typing_time
"
"
key_presses
"
]
)
;
}
}
)
(
)
;
const
snapshotHandler
=
new
(
class
extends
TableViewer
{
title
=
"
Snapshots
"
;
cssGridTemplateColumns
=
"
fit
-
content
(
100
%
)
repeat
(
6
max
-
content
)
;
"
;
columnMap
=
new
Map
(
[
[
"
url
"
{
header
:
"
URL
"
includeTitle
:
true
}
]
[
"
createdAt
"
{
header
:
"
Created
"
modifier
:
c
=
>
c
.
toLocaleString
(
)
}
]
[
"
removedAt
"
{
header
:
"
Removed
"
modifier
:
r
=
>
r
?
.
toLocaleString
(
)
?
?
"
"
}
]
[
"
firstInteractionAt
"
{
header
:
"
First
Interaction
"
modifier
:
f
=
>
f
.
toLocaleString
(
)
}
]
[
"
lastInteractionAt
"
{
header
:
"
Latest
Interaction
"
modifier
:
l
=
>
l
.
toLocaleString
(
)
}
]
[
"
documentType
"
{
header
:
"
Doc
Type
"
modifier
:
d
=
>
d
=
=
Interactions
.
DOCUMENT_TYPE
.
MEDIA
?
"
Media
"
:
"
Generic
"
}
]
[
"
userPersisted
"
{
header
:
"
User
Persisted
"
modifier
:
u
=
>
(
u
?
"
Yes
"
:
"
"
)
}
]
]
)
;
async
updateDisplay
(
)
{
this
.
displayData
(
await
Snapshots
.
query
(
{
includeTombstones
:
true
}
)
)
;
}
}
)
(
)
;
const
placesStatsHandler
=
new
(
class
extends
TableViewer
{
title
=
"
Places
Database
Statistics
"
;
cssGridTemplateColumns
=
"
fit
-
content
(
100
%
)
repeat
(
5
max
-
content
)
;
"
;
columnMap
=
new
Map
(
[
[
"
entity
"
{
header
:
"
Entity
"
}
]
[
"
count
"
{
header
:
"
Count
"
}
]
[
"
sizeBytes
"
{
header
:
"
Size
(
KiB
)
"
modifier
:
c
=
>
c
/
1024
}
]
[
"
sizePerc
"
{
header
:
"
Size
(
Perc
.
)
"
}
]
[
"
efficiencyPerc
"
{
header
:
"
Space
Eff
.
(
Perc
.
)
"
}
]
[
"
sequentialityPerc
"
{
header
:
"
Sequentiality
(
Perc
.
)
"
}
]
]
)
;
async
updateDisplay
(
)
{
let
stats
=
await
PlacesDBUtils
.
getEntitiesStats
(
)
;
let
data
=
[
]
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
for
(
let
[
entity
value
]
of
stats
)
{
let
count
=
"
-
"
;
try
{
if
(
entity
.
startsWith
(
"
moz_
"
)
&
&
!
entity
.
endsWith
(
"
index
"
)
&
&
entity
!
=
"
moz_places_visitcount
"
)
{
count
=
(
await
db
.
execute
(
SELECT
count
(
*
)
FROM
{
entity
}
)
)
[
0
]
.
getResultByIndex
(
0
)
;
}
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
data
.
push
(
Object
.
assign
(
value
{
entity
count
}
)
)
;
}
this
.
displayData
(
data
)
;
}
}
)
(
)
;
function
checkPrefs
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
enabled
"
false
)
)
{
let
warning
=
document
.
getElementById
(
"
enabledWarning
"
)
;
warning
.
hidden
=
false
;
}
}
function
show
(
selectedButton
)
{
let
currentButton
=
document
.
querySelector
(
"
.
category
.
selected
"
)
;
if
(
currentButton
=
=
selectedButton
)
{
return
;
}
gCurrentHandler
.
pause
(
)
;
currentButton
.
classList
.
remove
(
"
selected
"
)
;
selectedButton
.
classList
.
add
(
"
selected
"
)
;
switch
(
selectedButton
.
getAttribute
(
"
value
"
)
)
{
case
"
snapshots
"
:
(
gCurrentHandler
=
snapshotHandler
)
.
start
(
)
;
break
;
case
"
metadata
"
:
(
gCurrentHandler
=
metadataHandler
)
.
start
(
)
;
metadataHandler
.
start
(
)
;
break
;
case
"
places
-
stats
"
:
(
gCurrentHandler
=
placesStatsHandler
)
.
start
(
)
;
break
;
}
}
function
setupListeners
(
)
{
let
menu
=
document
.
getElementById
(
"
categories
"
)
;
menu
.
addEventListener
(
"
click
"
e
=
>
{
if
(
e
.
target
&
&
e
.
target
.
parentNode
=
=
menu
)
{
show
(
e
.
target
)
;
}
}
)
;
document
.
getElementById
(
"
export
"
)
.
addEventListener
(
"
click
"
async
e
=
>
{
e
.
preventDefault
(
)
;
const
data
=
await
metadataHandler
.
export
(
)
;
const
blob
=
new
Blob
(
[
JSON
.
stringify
(
data
)
]
{
type
:
"
text
/
json
;
charset
=
utf
-
8
"
}
)
;
const
a
=
document
.
createElement
(
"
a
"
)
;
a
.
setAttribute
(
"
download
"
places
-
{
Date
.
now
(
)
}
.
json
)
;
a
.
setAttribute
(
"
href
"
window
.
URL
.
createObjectURL
(
blob
)
)
;
a
.
click
(
)
;
a
.
remove
(
)
;
}
)
;
}
checkPrefs
(
)
;
let
gCurrentHandler
=
snapshotHandler
;
gCurrentHandler
.
start
(
)
.
catch
(
console
.
error
)
;
setupListeners
(
)
;
