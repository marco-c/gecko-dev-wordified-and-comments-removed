const
EXPORTED_SYMBOLS
=
[
"
SnapshotSelector
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
FilterAdult
:
"
resource
:
/
/
activity
-
stream
/
lib
/
FilterAdult
.
jsm
"
PlacesUIUtils
:
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
Snapshots
:
"
resource
:
/
/
/
modules
/
Snapshots
.
jsm
"
SnapshotScorer
:
"
resource
:
/
/
/
modules
/
SnapshotScorer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
SnapshotSelector
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
class
SnapshotSelector
extends
EventEmitter
{
static
#
selectors
=
new
Set
(
)
;
static
rebuildAll
(
)
{
for
(
let
selector
of
SnapshotSelector
.
#
selectors
)
{
selector
.
rebuild
(
)
;
}
}
#
context
=
{
count
:
undefined
filterAdult
:
false
sourceWeights
:
null
url
:
undefined
time
:
Date
.
now
(
)
type
:
undefined
getCurrentSessionUrls
:
undefined
}
;
#
task
=
null
;
constructor
(
{
count
=
5
filterAdult
=
false
sourceWeights
=
undefined
getCurrentSessionUrls
=
(
)
=
>
new
Set
(
)
}
)
{
super
(
)
;
this
.
#
task
=
new
lazy
.
DeferredTask
(
(
)
=
>
this
.
#
buildSnapshots
(
)
.
catch
(
console
.
error
)
500
)
;
this
.
#
context
.
count
=
count
;
this
.
#
context
.
filterAdult
=
filterAdult
;
if
(
sourceWeights
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
pinebuild
.
snapshots
.
relevancy
.
enabled
"
false
)
)
{
let
branch
=
Services
.
prefs
.
getBranch
(
"
browser
.
snapshots
.
source
.
"
)
;
let
weights
=
Object
.
fromEntries
(
branch
.
getChildList
(
"
"
)
.
map
(
name
=
>
[
name
branch
.
getIntPref
(
name
0
)
]
)
)
;
Object
.
assign
(
weights
sourceWeights
?
?
{
}
)
;
this
.
#
context
.
sourceWeights
=
new
Map
(
Object
.
entries
(
weights
)
)
;
}
this
.
#
context
.
getCurrentSessionUrls
=
getCurrentSessionUrls
;
SnapshotSelector
.
#
selectors
.
add
(
this
)
;
}
destroy
(
)
{
this
.
#
task
.
disarm
(
)
;
this
.
#
task
.
finalize
(
)
;
this
.
#
task
=
null
;
SnapshotSelector
.
#
selectors
.
delete
(
this
)
;
}
rebuild
(
)
{
if
(
!
this
.
#
task
)
{
return
;
}
this
.
#
task
.
arm
(
)
;
}
#
snapshotsGenerated
(
recommendations
)
{
if
(
!
this
.
#
task
)
{
return
;
}
lazy
.
logConsole
.
debug
(
"
Generated
recommendations
"
recommendations
.
map
(
s
=
>
s
.
snapshot
.
url
)
)
;
this
.
emit
(
"
snapshots
-
updated
"
recommendations
)
;
}
async
#
buildSnapshots
(
)
{
if
(
this
.
#
context
.
sourceWeights
)
{
await
this
.
#
buildRelevancySnapshots
(
)
;
return
;
}
if
(
!
this
.
#
task
)
{
return
;
}
let
context
=
{
.
.
.
this
.
#
context
}
;
lazy
.
logConsole
.
debug
(
"
Building
snapshots
"
context
)
;
let
snapshots
=
await
lazy
.
Snapshots
.
query
(
{
limit
:
context
.
count
*
4
type
:
context
.
type
}
)
;
snapshots
=
snapshots
.
filter
(
snapshot
=
>
{
if
(
snapshot
.
url
=
=
context
.
url
)
{
return
false
;
}
return
!
context
.
filterAdult
|
|
!
lazy
.
FilterAdult
.
isAdultUrl
(
snapshot
.
url
)
;
}
)
;
let
recommendations
=
snapshots
.
map
(
(
snapshot
index
)
=
>
(
{
source
:
"
recent
"
score
:
snapshots
.
length
-
index
snapshot
}
)
)
;
recommendations
=
lazy
.
SnapshotScorer
.
dedupeSnapshots
(
recommendations
)
.
slice
(
0
context
.
count
)
;
lazy
.
PlacesUIUtils
.
insertTitleStartDiffs
(
recommendations
.
map
(
s
=
>
s
.
snapshot
)
)
;
this
.
#
snapshotsGenerated
(
recommendations
)
;
}
async
#
buildRelevancySnapshots
(
)
{
if
(
!
this
.
#
task
)
{
return
;
}
let
context
=
{
.
.
.
this
.
#
context
}
;
lazy
.
logConsole
.
debug
(
"
Building
relevant
snapshots
"
context
)
;
let
recommendationGroups
=
await
Promise
.
all
(
Object
.
entries
(
lazy
.
Snapshots
.
recommendationSources
)
.
map
(
async
(
[
key
source
]
)
=
>
{
let
weight
=
context
.
sourceWeights
.
get
(
key
)
?
?
0
;
if
(
weight
=
=
0
)
{
return
{
recommendations
:
[
]
weight
}
;
}
let
recommendations
=
await
source
(
context
)
;
lazy
.
logConsole
.
debug
(
Found
{
key
}
recommendations
:
recommendations
.
map
(
r
=
>
{
r
.
snapshot
.
url
}
(
score
:
{
r
.
score
}
{
r
.
data
?
"
data
:
"
+
JSON
.
stringify
(
r
.
data
)
:
"
"
}
)
)
)
;
return
{
source
:
key
recommendations
weight
}
;
}
)
)
;
let
recommendations
=
lazy
.
SnapshotScorer
.
combineAndScore
(
context
.
.
.
recommendationGroups
)
;
recommendations
=
recommendations
.
slice
(
0
context
.
count
)
;
lazy
.
PlacesUIUtils
.
insertTitleStartDiffs
(
recommendations
.
map
(
r
=
>
r
.
snapshot
)
)
;
this
.
#
snapshotsGenerated
(
recommendations
)
;
}
updateDetailsAndRebuild
(
{
url
time
type
sessionStartTime
rebuildImmediately
=
false
}
)
{
let
rebuild
=
false
;
if
(
url
!
=
=
undefined
)
{
url
=
lazy
.
Snapshots
.
stripFragments
(
url
)
;
if
(
url
!
=
this
.
#
context
.
url
)
{
this
.
#
context
.
url
=
url
;
rebuild
=
true
;
}
}
if
(
time
!
=
=
undefined
&
&
time
!
=
this
.
#
context
.
time
)
{
this
.
#
context
.
time
=
time
;
rebuild
=
true
;
}
if
(
type
!
=
=
undefined
&
&
type
!
=
this
.
#
context
.
type
)
{
this
.
#
context
.
type
=
type
;
rebuild
=
true
;
}
if
(
sessionStartTime
!
=
undefined
&
&
sessionStartTime
!
=
this
.
#
context
.
sessionStartTime
)
{
this
.
#
context
.
sessionStartTime
=
sessionStartTime
;
rebuild
=
true
;
}
if
(
rebuild
)
{
if
(
rebuildImmediately
)
{
this
.
#
buildSnapshots
(
)
;
}
else
{
this
.
rebuild
(
)
;
}
}
}
}
Services
.
obs
.
addObserver
(
SnapshotSelector
.
rebuildAll
"
places
-
snapshots
-
added
"
)
;
Services
.
obs
.
addObserver
(
SnapshotSelector
.
rebuildAll
"
places
-
snapshots
-
deleted
"
)
;
Services
.
obs
.
addObserver
(
SnapshotSelector
.
rebuildAll
"
places
-
metadata
-
updated
"
)
;
