"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Snapshots
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BackgroundPageThumbs
:
"
resource
:
/
/
gre
/
modules
/
BackgroundPageThumbs
.
jsm
"
CommonNames
:
"
resource
:
/
/
/
modules
/
CommonNames
.
jsm
"
Interactions
:
"
resource
:
/
/
/
modules
/
Interactions
.
jsm
"
InteractionsBlocklist
:
"
resource
:
/
/
/
modules
/
InteractionsBlocklist
.
jsm
"
PageDataService
:
"
resource
:
/
/
/
modules
/
pagedata
/
PageDataService
.
jsm
"
PageThumbs
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
PageThumbsStorage
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PlacesPreviews
:
"
resource
:
/
/
gre
/
modules
/
PlacesPreviews
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
SnapshotsManager
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshot_overlap_limit
"
"
browser
.
places
.
interactions
.
snapshotOverlapLimit
"
1800000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshot_timeofday_interval_seconds
"
"
browser
.
places
.
interactions
.
snapshotTimeOfDayIntervalSeconds
"
3600
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshot_timeofday_limit_days
"
"
browser
.
places
.
interactions
.
snapshotTimeOfDayLimitDays
"
45
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshot_timeofday_expected_interactions
"
"
browser
.
places
.
interactions
.
snapshotTimeOfDayExpectedInteractions
"
10
)
;
const
DEFAULT_CRITERIA
=
[
{
property
:
"
total_view_time
"
aggregator
:
"
max
"
cutoff
:
30000
}
{
property
:
"
total_view_time
"
aggregator
:
"
sum
"
cutoff
:
120000
interactionCount
:
5
}
{
property
:
"
key_presses
"
aggregator
:
"
sum
"
cutoff
:
250
interactionCount
:
10
}
]
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshotCriteria
"
"
browser
.
places
.
interactions
.
snapshotCriteria
"
JSON
.
stringify
(
DEFAULT_CRITERIA
)
)
;
const
Snapshots
=
new
(
class
Snapshots
{
USER_PERSISTED
=
{
NO
:
0
MANUAL
:
1
PINNED
:
2
}
;
REMOVED_REASON
=
{
DISMISS
:
0
NOT_RELEVANT
:
1
PERSONAL
:
2
EXPIRED
:
3
}
;
constructor
(
)
{
if
(
!
PlacesPreviews
.
enabled
)
{
PageThumbs
.
addExpirationFilter
(
this
)
;
}
this
.
recommendationSources
=
{
Overlapping
:
this
.
#
queryOverlapping
.
bind
(
this
)
CommonReferrer
:
this
.
#
queryCommonReferrer
.
bind
(
this
)
TimeOfDay
:
this
.
#
queryTimeOfDay
.
bind
(
this
)
}
;
}
#
notify
(
topic
urls
)
{
Services
.
obs
.
notifyObservers
(
null
topic
JSON
.
stringify
(
urls
)
)
;
}
async
filterForThumbnailExpiration
(
callback
)
{
let
snapshots
=
await
this
.
query
(
)
;
let
urls
=
[
]
;
for
(
let
snapshot
of
snapshots
)
{
urls
.
push
(
snapshot
.
url
)
;
}
callback
(
urls
)
;
}
async
#
addPageData
(
urls
)
{
let
pageDataIndex
=
0
;
let
pageDataValues
=
[
]
;
let
pageDataBindings
=
{
}
;
let
placesIndex
=
0
;
let
placesValues
=
[
]
;
let
placesBindings
=
{
}
;
for
(
let
{
placeId
url
}
of
urls
)
{
let
pageData
=
PageDataService
.
getCached
(
url
)
;
if
(
pageData
)
{
for
(
let
[
type
data
]
of
Object
.
entries
(
pageData
.
data
)
)
{
pageDataBindings
[
id
{
pageDataIndex
}
]
=
placeId
;
pageDataBindings
[
type
{
pageDataIndex
}
]
=
type
;
pageDataBindings
[
data
{
pageDataIndex
}
]
=
JSON
.
stringify
(
data
)
;
pageDataValues
.
push
(
(
:
id
{
pageDataIndex
}
:
type
{
pageDataIndex
}
:
data
{
pageDataIndex
}
)
)
;
pageDataIndex
+
+
;
}
let
{
siteName
description
image
:
previewImageURL
}
=
pageData
;
let
pageInfo
=
PlacesUtils
.
validateItemProperties
(
"
PageInfo
"
PlacesUtils
.
PAGEINFO_VALIDATORS
{
siteName
description
previewImageURL
}
)
;
placesBindings
[
id
{
placesIndex
}
]
=
placeId
;
placesBindings
[
desc
{
placesIndex
}
]
=
pageInfo
.
description
?
?
null
;
placesBindings
[
site
{
placesIndex
}
]
=
pageInfo
.
siteName
?
?
null
;
placesBindings
[
image
{
placesIndex
}
]
=
pageInfo
.
previewImageURL
?
.
toString
(
)
?
?
null
;
placesValues
.
push
(
(
:
id
{
placesIndex
}
:
desc
{
placesIndex
}
:
site
{
placesIndex
}
:
image
{
placesIndex
}
)
)
;
placesIndex
+
+
;
}
else
{
PageDataService
.
queueFetch
(
url
)
;
}
this
.
#
downloadPageImage
(
url
pageData
?
.
image
)
;
}
logConsole
.
debug
(
Inserting
{
pageDataIndex
}
page
data
for
:
{
urls
.
map
(
u
=
>
u
.
url
)
}
.
)
;
if
(
pageDataIndex
=
=
0
&
&
placesIndex
=
=
0
)
{
return
;
}
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
addPageData
"
async
db
=
>
{
if
(
placesIndex
)
{
await
db
.
execute
(
WITH
pd
(
"
place_id
"
"
description
"
"
siteName
"
"
image
"
)
AS
(
VALUES
{
placesValues
.
join
(
"
"
)
}
)
UPDATE
moz_places
SET
description
=
pd
.
description
site_name
=
pd
.
siteName
preview_image_url
=
pd
.
image
FROM
pd
WHERE
moz_places
.
id
=
pd
.
place_id
;
placesBindings
)
;
}
if
(
pageDataIndex
)
{
await
db
.
execute
(
INSERT
OR
REPLACE
INTO
moz_places_metadata_snapshots_extra
(
place_id
type
data
)
VALUES
{
pageDataValues
.
join
(
"
"
)
}
pageDataBindings
)
;
}
}
)
;
}
#
downloadPageImage
(
url
metaDataImageURL
=
null
)
{
if
(
!
metaDataImageURL
)
{
if
(
PlacesPreviews
.
enabled
)
{
PlacesPreviews
.
update
(
url
)
.
catch
(
console
.
error
)
;
}
else
{
BackgroundPageThumbs
.
captureIfMissing
(
url
)
.
catch
(
console
.
error
)
;
}
}
}
stripFragments
(
url
)
{
return
url
?
.
split
(
"
#
"
)
[
0
]
;
}
async
add
(
{
url
title
userPersisted
=
this
.
USER_PERSISTED
.
NO
}
)
{
if
(
!
url
)
{
throw
new
Error
(
"
Missing
url
parameter
to
Snapshots
.
add
(
)
"
)
;
}
url
=
this
.
stripFragments
(
url
)
;
if
(
!
InteractionsBlocklist
.
canRecordUrl
(
url
)
)
{
throw
new
Error
(
"
This
url
cannot
be
added
to
snapshots
"
)
;
}
let
placeId
=
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
:
add
"
async
db
=
>
{
let
now
=
Date
.
now
(
)
;
await
this
.
#
maybeInsertPlace
(
db
new
URL
(
url
)
)
;
let
updateTitleFragment
=
title
!
=
=
undefined
?
"
title
=
:
title
"
:
"
"
;
if
(
title
!
=
=
undefined
)
{
userPersisted
=
this
.
USER_PERSISTED
.
MANUAL
;
}
let
rows
=
await
db
.
executeCached
(
INSERT
INTO
moz_places_metadata_snapshots
(
place_id
first_interaction_at
last_interaction_at
document_type
created_at
user_persisted
title
)
SELECT
h
.
id
IFNULL
(
min
(
m
.
created_at
)
CASE
WHEN
:
userPersisted
THEN
0
ELSE
NULL
END
)
IFNULL
(
max
(
m
.
created_at
)
CASE
WHEN
:
userPersisted
THEN
:
createdAt
ELSE
NULL
END
)
IFNULL
(
first_value
(
m
.
document_type
)
OVER
(
PARTITION
BY
h
.
id
ORDER
BY
m
.
created_at
DESC
)
:
documentFallback
)
:
createdAt
:
userPersisted
:
title
FROM
moz_places
h
LEFT
JOIN
moz_places_metadata
m
ON
m
.
place_id
=
h
.
id
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
GROUP
BY
h
.
id
ON
CONFLICT
DO
UPDATE
SET
user_persisted
=
MAX
(
:
userPersisted
user_persisted
)
removed_at
=
NULL
{
updateTitleFragment
}
WHERE
:
userPersisted
<
>
0
RETURNING
place_id
created_at
user_persisted
{
createdAt
:
now
url
userPersisted
documentFallback
:
Interactions
.
DOCUMENT_TYPE
.
GENERIC
title
:
title
|
|
null
}
)
;
if
(
rows
.
length
)
{
if
(
rows
[
0
]
.
getResultByName
(
"
created_at
"
)
!
=
now
&
&
rows
[
0
]
.
getResultByName
(
"
user_persisted
"
)
=
=
this
.
USER_PERSISTED
.
NO
)
{
return
null
;
}
return
rows
[
0
]
.
getResultByName
(
"
place_id
"
)
;
}
return
null
;
}
)
;
if
(
placeId
)
{
await
this
.
#
addPageData
(
[
{
placeId
url
}
]
)
;
this
.
#
notify
(
"
places
-
snapshots
-
added
"
[
{
url
userPersisted
}
]
)
;
}
}
async
delete
(
urls
reason
=
0
)
{
if
(
typeof
reason
!
=
"
number
"
|
|
!
Object
.
values
(
this
.
REMOVED_REASON
)
.
includes
(
reason
)
)
{
throw
new
TypeError
(
"
Invalid
value
for
'
reason
'
"
)
;
}
if
(
!
Array
.
isArray
(
urls
)
)
{
urls
=
[
urls
]
;
}
urls
=
urls
.
map
(
this
.
stripFragments
)
;
let
placeIdsSQLFragment
=
SELECT
id
FROM
moz_places
WHERE
url_hash
IN
(
{
PlacesUtils
.
sqlBindPlaceholders
(
urls
"
hash
(
"
"
)
"
)
}
)
AND
url
IN
(
{
PlacesUtils
.
sqlBindPlaceholders
(
urls
)
}
)
;
let
queryArgs
=
reason
=
=
this
.
REMOVED_REASON
.
EXPIRED
?
[
DELETE
FROM
moz_places_metadata_snapshots
WHERE
place_id
IN
(
{
placeIdsSQLFragment
}
)
RETURNING
place_id
[
.
.
.
urls
.
.
.
urls
]
]
:
[
UPDATE
moz_places_metadata_snapshots
SET
removed_at
=
?
removed_reason
=
?
WHERE
place_id
IN
(
{
placeIdsSQLFragment
}
)
RETURNING
place_id
[
Date
.
now
(
)
reason
.
.
.
urls
.
.
.
urls
]
]
;
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
:
delete
"
async
db
=
>
{
let
placeIds
=
(
await
db
.
executeCached
(
.
.
.
queryArgs
)
)
.
map
(
r
=
>
r
.
getResultByName
(
"
place_id
"
)
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_snapshots_extra
WHERE
place_id
IN
(
{
PlacesUtils
.
sqlBindPlaceholders
(
placeIds
)
}
)
placeIds
)
;
}
)
;
this
.
#
notify
(
"
places
-
snapshots
-
deleted
"
urls
)
;
}
async
get
(
url
includeTombstones
=
false
)
{
url
=
this
.
stripFragments
(
url
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
extraWhereCondition
=
"
"
;
if
(
!
includeTombstones
)
{
extraWhereCondition
=
"
AND
removed_at
IS
NULL
"
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
AS
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
AS
page_data
h
.
visit_count
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
{
extraWhereCondition
}
GROUP
BY
s
.
place_id
{
url
}
)
;
if
(
!
rows
.
length
)
{
return
null
;
}
return
this
.
#
translateRow
(
rows
[
0
]
)
;
}
async
query
(
{
limit
=
100
includeTombstones
=
false
type
=
undefined
group
=
undefined
includeSnapshotsInUserManagedGroups
=
true
includeHiddenInGroup
=
false
includeUserPersisted
=
true
lastInteractionBefore
=
undefined
sortDescending
=
true
sortBy
=
"
last_interaction_at
"
}
=
{
}
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
clauses
=
[
]
;
let
bindings
=
{
}
;
let
joins
=
[
]
;
let
limitStatement
=
"
"
;
if
(
!
includeTombstones
)
{
clauses
.
push
(
"
removed_at
IS
NULL
"
)
;
}
if
(
!
includeUserPersisted
)
{
clauses
.
push
(
"
user_persisted
=
:
user_persisted
"
)
;
bindings
.
user_persisted
=
this
.
USER_PERSISTED
.
NO
;
}
if
(
lastInteractionBefore
)
{
clauses
.
push
(
"
last_interaction_at
<
:
last_interaction_before
"
)
;
bindings
.
last_interaction_before
=
lastInteractionBefore
;
}
if
(
type
)
{
clauses
.
push
(
"
type
=
:
type
"
)
;
bindings
.
type
=
type
;
}
if
(
group
)
{
clauses
.
push
(
"
group_id
=
:
group
"
)
;
if
(
!
includeHiddenInGroup
)
{
clauses
.
push
(
"
gs
.
hidden
=
0
"
)
;
}
bindings
.
group
=
group
;
joins
.
push
(
"
LEFT
JOIN
moz_places_metadata_groups_to_snapshots
gs
USING
(
place_id
)
"
)
;
}
else
if
(
!
includeSnapshotsInUserManagedGroups
)
{
clauses
.
push
(
NOT
EXISTS
(
SELECT
1
FROM
moz_places_metadata_snapshots_groups
g
JOIN
moz_places_metadata_groups_to_snapshots
gs
ON
g
.
id
=
gs
.
group_id
WHERE
gs
.
place_id
=
h
.
id
AND
builder
=
=
'
user
'
)
)
;
}
if
(
limit
!
=
-
1
)
{
limitStatement
=
"
LIMIT
:
limit
"
;
bindings
.
limit
=
limit
;
}
let
whereStatement
=
clauses
.
length
?
WHERE
{
clauses
.
join
(
"
AND
"
)
}
:
"
"
;
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
AS
page_data
h
.
visit_count
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
USING
(
place_id
)
{
joins
.
join
(
"
"
)
}
{
whereStatement
}
GROUP
BY
s
.
place_id
ORDER
BY
{
sortBy
}
{
sortDescending
?
"
DESC
"
:
"
ASC
"
}
{
limitStatement
}
bindings
)
;
return
rows
.
map
(
row
=
>
this
.
#
translateRow
(
row
)
)
;
}
async
queryPlaceIdFromUrl
(
url
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
id
from
moz_places
p
WHERE
p
.
url
=
:
url
{
url
}
)
;
if
(
!
rows
.
length
)
{
return
-
1
;
}
return
rows
[
0
]
.
getResultByName
(
"
id
"
)
;
}
async
#
queryOverlapping
(
selectionContext
)
{
let
current_id
=
await
this
.
queryPlaceIdFromUrl
(
selectionContext
.
url
)
;
if
(
current_id
=
=
-
1
)
{
logConsole
.
debug
(
PlaceId
not
found
for
url
{
selectionContext
.
url
}
)
;
return
[
]
;
}
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
AS
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
o
.
overlappingVisitScore
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
AS
page_data
h
.
visit_count
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
JOIN
(
SELECT
place_id
MIN
(
SUM
(
CASE
WHEN
(
page_start
>
snapshot_end
)
>
0
THEN
MAX
(
1
.
0
-
(
page_start
-
snapshot_end
)
/
CAST
(
:
snapshot_overlap_limit
as
float
)
0
.
0
)
WHEN
(
page_end
<
snapshot_start
)
>
0
THEN
MAX
(
1
.
0
-
(
snapshot_start
-
page_end
)
/
CAST
(
:
snapshot_overlap_limit
as
float
)
0
.
0
)
ELSE
1
.
0
END
)
1
.
0
)
overlappingVisitScore
FROM
(
SELECT
created_at
AS
page_start
created_at
-
:
snapshot_overlap_limit
AS
page_start_limit
updated_at
AS
page_end
updated_at
+
:
snapshot_overlap_limit
AS
page_end_limit
FROM
moz_places_metadata
WHERE
place_id
=
:
current_id
)
AS
current_page
JOIN
(
SELECT
place_id
created_at
AS
snapshot_start
updated_at
AS
snapshot_end
FROM
moz_places_metadata
WHERE
place_id
!
=
:
current_id
)
AS
suggestion
WHERE
snapshot_start
BETWEEN
page_start_limit
AND
page_end_limit
OR
snapshot_end
BETWEEN
page_start_limit
AND
page_end_limit
OR
(
snapshot_start
<
page_start_limit
AND
snapshot_end
>
page_end_limit
)
GROUP
BY
place_id
)
o
ON
s
.
place_id
=
o
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
GROUP
BY
s
.
place_id
ORDER
BY
o
.
overlappingVisitScore
DESC
;
{
current_id
snapshot_overlap_limit
}
)
;
if
(
!
rows
.
length
)
{
logConsole
.
debug
(
"
No
overlapping
snapshots
"
)
;
}
return
rows
.
map
(
row
=
>
(
{
snapshot
:
this
.
#
translateRow
(
row
)
score
:
row
.
getResultByName
(
"
overlappingVisitScore
"
)
}
)
)
;
}
async
#
queryCommonReferrer
(
selectionContext
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
context_place_id
=
await
this
.
queryPlaceIdFromUrl
(
selectionContext
.
url
)
;
if
(
context_place_id
=
=
-
1
)
{
return
[
]
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
id
h
.
url
AS
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
s
.
created_at
removed_at
s
.
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
h
.
visit_count
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
AS
page_data
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
WHERE
s
.
place_id
IN
(
SELECT
p1
.
place_id
FROM
moz_places_metadata
p1
JOIN
moz_places_metadata
p2
USING
(
referrer_place_id
)
WHERE
p2
.
place_id
=
:
context_place_id
AND
p1
.
place_id
<
>
:
context_place_id
)
GROUP
BY
s
.
place_id
{
context_place_id
}
)
;
if
(
!
rows
.
length
)
{
logConsole
.
debug
(
"
No
common
referrer
snapshots
"
)
;
}
return
rows
.
map
(
row
=
>
(
{
snapshot
:
this
.
#
translateRow
(
row
)
score
:
1
.
0
}
)
)
;
}
async
#
queryTimeOfDay
(
selectionContext
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
WITH
times
AS
(
SELECT
time
(
:
context_time_s
'
unixepoch
'
)
AS
time
)
SELECT
h
.
id
h
.
url
AS
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
s
.
created_at
removed_at
s
.
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
h
.
visit_count
(
SELECT
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
FROM
moz_places_metadata_snapshots
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
USING
(
place_id
)
WHERE
place_id
=
h
.
id
)
AS
page_data
count
(
*
)
AS
interactions
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
times
JOIN
moz_places_metadata
i
USING
(
place_id
)
WHERE
url_hash
<
>
hash
(
:
context_url
)
AND
i
.
created_at
BETWEEN
unixepoch
(
'
now
'
'
utc
'
'
start
of
day
'
'
-
'
|
|
:
days_limit
|
|
'
days
'
)
*
1000
AND
(
:
context_time_s
-
:
interval_s
/
2
)
*
1000
/
*
don
'
t
match
the
current
interval
*
/
AND
i
.
created_at
BETWEEN
(
unixepoch
(
date
(
i
.
created_at
/
1000
'
unixepoch
'
)
|
|
"
"
|
|
time
)
-
:
interval_s
/
2
)
*
1000
AND
(
unixepoch
(
date
(
i
.
created_at
/
1000
'
unixepoch
'
)
|
|
"
"
|
|
time
)
+
:
interval_s
/
2
)
*
1000
GROUP
BY
s
.
place_id
{
context_url
:
selectionContext
.
url
context_time_s
:
parseInt
(
selectionContext
.
time
/
1000
)
interval_s
:
snapshot_timeofday_interval_seconds
days_limit
:
snapshot_timeofday_limit_days
}
)
;
if
(
!
rows
.
length
)
{
logConsole
.
debug
(
"
No
timeOfDay
snapshots
"
)
;
}
let
interactionCounts
=
{
min
:
1
max
:
1
}
;
let
entries
=
rows
.
map
(
row
=
>
{
let
interactions
=
row
.
getResultByName
(
"
interactions
"
)
;
interactionCounts
.
max
=
Math
.
max
(
interactionCounts
.
max
interactions
)
;
interactionCounts
.
min
=
Math
.
min
(
interactionCounts
.
min
interactions
)
;
return
{
snapshot
:
this
.
#
translateRow
(
row
)
interactions
}
;
}
)
;
entries
.
forEach
(
e
=
>
{
e
.
score
=
this
.
timeOfDayScore
(
e
.
interactions
interactionCounts
)
;
}
)
;
return
entries
;
}
timeOfDayScore
(
interactions
{
min
max
}
)
{
let
score
=
1
.
0
;
if
(
interactions
<
max
/
2
)
{
score
=
0
.
5
*
(
1
+
(
interactions
-
min
)
/
(
max
-
min
)
)
;
}
if
(
interactions
<
snapshot_timeofday_expected_interactions
)
{
score
*
=
0
.
5
*
(
1
+
(
interactions
-
1
)
/
(
snapshot_timeofday_expected_interactions
-
1
)
)
;
}
return
Math
.
round
(
score
*
1e2
)
/
1e2
;
}
#
translateRow
(
row
)
{
let
pageData
;
let
pageDataStr
=
row
.
getResultByName
(
"
page_data
"
)
;
if
(
pageDataStr
)
{
try
{
let
dataArray
=
JSON
.
parse
(
[
{
pageDataStr
}
]
)
;
pageData
=
new
Map
(
dataArray
)
;
}
catch
(
e
)
{
logConsole
.
error
(
e
)
;
}
}
let
snapshot
=
{
url
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
siteName
:
row
.
getResultByName
(
"
site_name
"
)
description
:
row
.
getResultByName
(
"
description
"
)
image
:
row
.
getResultByName
(
"
preview_image_url
"
)
createdAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
created_at
"
)
)
removedAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
removed_at
"
)
)
firstInteractionAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
first_interaction_at
"
)
)
lastInteractionAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
last_interaction_at
"
)
)
documentType
:
row
.
getResultByName
(
"
document_type
"
)
userPersisted
:
row
.
getResultByName
(
"
user_persisted
"
)
pageData
:
pageData
?
?
new
Map
(
)
visitCount
:
row
.
getResultByName
(
"
visit_count
"
)
}
;
snapshot
.
commonName
=
CommonNames
.
getName
(
snapshot
)
;
return
snapshot
;
}
async
getSnapshotImageURL
(
snapshot
)
{
if
(
snapshot
.
image
)
{
return
snapshot
.
image
;
}
const
url
=
snapshot
.
url
;
if
(
PlacesPreviews
.
enabled
)
{
if
(
await
PlacesPreviews
.
update
(
url
)
.
catch
(
console
.
error
)
)
{
return
PlacesPreviews
.
getPageThumbURL
(
url
)
;
}
}
else
{
await
BackgroundPageThumbs
.
captureIfMissing
(
url
)
.
catch
(
console
.
error
)
;
if
(
await
PageThumbsStorage
.
fileExistsForURL
(
url
)
)
{
return
PageThumbs
.
getThumbnailURL
(
url
)
;
}
}
return
null
;
}
#
toDate
(
value
)
{
if
(
value
)
{
return
new
Date
(
value
)
;
}
return
null
;
}
async
updateSnapshots
(
urls
=
undefined
)
{
if
(
urls
!
=
=
undefined
&
&
!
urls
.
length
)
{
return
;
}
logConsole
.
debug
(
Testing
{
urls
?
urls
.
length
:
"
all
"
}
potential
snapshots
)
;
let
model
;
try
{
model
=
JSON
.
parse
(
snapshotCriteria
)
;
if
(
!
model
.
length
)
{
logConsole
.
debug
(
No
snapshot
criteria
provided
falling
back
to
default
)
;
model
=
DEFAULT_CRITERIA
;
}
}
catch
(
e
)
{
logConsole
.
error
(
"
Invalid
snapshot
criteria
falling
back
to
default
.
"
e
)
;
model
=
DEFAULT_CRITERIA
;
}
let
insertedUrls
=
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
updateSnapshots
"
async
db
=
>
{
let
bindings
=
{
}
;
let
urlFilter
=
"
"
;
if
(
urls
=
=
undefined
)
{
let
filters
=
[
]
;
for
(
let
protocol
of
InteractionsBlocklist
.
urlRequirements
.
keys
(
)
)
{
filters
.
push
(
(
url_hash
BETWEEN
hash
(
'
{
protocol
}
'
'
prefix_lo
'
)
AND
hash
(
'
{
protocol
}
'
'
prefix_hi
'
)
)
)
;
}
urlFilter
=
"
WHERE
"
+
filters
.
join
(
"
OR
"
)
;
}
else
{
let
urlMatches
=
[
]
;
urls
.
forEach
(
(
url
idx
)
=
>
{
if
(
!
InteractionsBlocklist
.
canRecordUrl
(
url
)
)
{
logConsole
.
debug
(
Url
can
'
t
be
added
to
snapshots
:
{
url
}
)
;
return
;
}
bindings
[
url
{
idx
}
]
=
url
;
urlMatches
.
push
(
(
url_hash
=
hash
(
:
url
{
idx
}
)
AND
url
=
:
url
{
idx
}
)
)
;
}
)
;
if
(
!
urlMatches
.
length
)
{
return
[
]
;
}
urlFilter
=
WHERE
{
urlMatches
.
join
(
"
OR
"
)
}
;
}
let
modelQueries
=
[
]
;
model
.
forEach
(
(
criteria
idx
)
=
>
{
let
wheres
=
[
]
;
if
(
criteria
.
interactionCount
)
{
wheres
.
push
(
row
<
=
:
count
{
idx
}
)
;
bindings
[
count
{
idx
}
]
=
criteria
.
interactionCount
;
}
if
(
criteria
.
interactionRecency
)
{
wheres
.
push
(
created_at
>
=
:
recency
{
idx
}
)
;
bindings
[
recency
{
idx
}
]
=
Date
.
now
(
)
-
criteria
.
interactionRecency
;
}
let
where
=
wheres
.
length
?
WHERE
{
wheres
.
join
(
"
AND
"
)
}
:
"
"
;
modelQueries
.
push
(
SELECT
place_id
min
(
created_at
)
AS
first_interaction_at
max
(
created_at
)
AS
last_interaction_at
doc_type
:
createdAt
FROM
metadata
{
where
}
GROUP
BY
place_id
HAVING
{
criteria
.
aggregator
}
(
{
criteria
.
property
}
)
>
=
:
cutoff
{
idx
}
)
;
bindings
[
cutoff
{
idx
}
]
=
criteria
.
cutoff
;
}
)
;
let
query
=
WITH
metadata
AS
(
SELECT
moz_places_metadata
.
*
row_number
(
)
OVER
(
PARTITION
BY
place_id
ORDER
BY
created_at
DESC
)
AS
row
first_value
(
document_type
)
OVER
(
PARTITION
BY
place_id
ORDER
BY
created_at
DESC
)
AS
doc_type
FROM
moz_places_metadata
JOIN
moz_places
h
ON
moz_places_metadata
.
place_id
=
h
.
id
{
urlFilter
}
)
INSERT
OR
IGNORE
INTO
moz_places_metadata_snapshots
(
place_id
first_interaction_at
last_interaction_at
document_type
created_at
)
{
modelQueries
.
join
(
"
UNION
"
)
}
RETURNING
place_id
(
SELECT
url
FROM
moz_places
WHERE
id
=
place_id
)
AS
url
created_at
;
let
now
=
Date
.
now
(
)
;
let
results
=
await
db
.
execute
(
query
{
.
.
.
bindings
createdAt
:
now
}
)
;
logConsole
.
debug
(
Inserted
{
results
.
length
}
snapshots
)
;
let
newUrls
=
[
]
;
for
(
let
row
of
results
)
{
if
(
row
.
getResultByName
(
"
created_at
"
)
=
=
now
)
{
newUrls
.
push
(
{
placeId
:
row
.
getResultByName
(
"
place_id
"
)
url
:
row
.
getResultByName
(
"
url
"
)
}
)
;
}
}
return
newUrls
;
}
)
;
if
(
insertedUrls
.
length
)
{
logConsole
.
debug
(
{
insertedUrls
.
length
}
snapshots
created
)
;
await
this
.
#
addPageData
(
insertedUrls
)
;
this
.
#
notify
(
"
places
-
snapshots
-
added
"
insertedUrls
.
map
(
result
=
>
{
return
{
url
:
result
.
url
userPersisted
:
this
.
USER_PERSISTED
.
NO
}
;
}
)
)
;
}
}
async
reset
(
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
reset
"
async
db
=
>
{
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_snapshots
)
;
}
)
;
}
async
#
maybeInsertPlace
(
db
url
)
{
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
VALUES
(
:
url
hash
(
:
url
)
:
rev_host
1
-
1
IFNULL
(
(
SELECT
guid
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
)
{
url
:
url
.
href
rev_host
:
PlacesUtils
.
getReversedHost
(
url
)
}
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_updateoriginsinsert_temp
"
)
;
}
}
)
(
)
;
