"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Snapshots
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
Snapshots
=
new
(
class
Snapshots
{
#
snapshots
=
new
Map
(
)
;
async
add
(
{
url
userPersisted
=
false
}
)
{
if
(
!
url
)
{
throw
new
Error
(
"
Missing
url
parameter
to
Snapshots
.
add
(
)
"
)
;
}
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
:
add
"
async
db
=
>
{
await
db
.
executeCached
(
INSERT
INTO
moz_places_metadata_snapshots
(
place_id
first_interaction_at
last_interaction_at
document_type
created_at
user_persisted
)
SELECT
place_id
min
(
created_at
)
max
(
created_at
)
first_value
(
document_type
)
OVER
(
PARTITION
BY
place_id
ORDER
BY
created_at
DESC
)
:
createdAt
:
userPersisted
FROM
moz_places_metadata
WHERE
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
ON
CONFLICT
DO
UPDATE
SET
user_persisted
=
:
userPersisted
removed_at
=
NULL
WHERE
:
userPersisted
=
1
{
createdAt
:
Date
.
now
(
)
url
userPersisted
}
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
added
"
url
)
;
}
async
delete
(
url
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
:
delete
"
async
db
=
>
{
await
db
.
executeCached
(
UPDATE
moz_places_metadata_snapshots
SET
removed_at
=
:
removedAt
WHERE
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
{
removedAt
:
Date
.
now
(
)
url
}
)
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
deleted
"
url
)
;
}
async
get
(
url
includeTombstones
=
false
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
extraWhereCondition
=
"
"
;
if
(
!
includeTombstones
)
{
extraWhereCondition
=
"
AND
removed_at
IS
NULL
"
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
AS
url
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
{
extraWhereCondition
}
{
url
}
)
;
if
(
!
rows
.
length
)
{
return
null
;
}
return
this
.
#
translateRow
(
rows
[
0
]
)
;
}
async
query
(
{
limit
=
100
includeTombstones
=
false
}
=
{
}
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
whereStatement
=
"
"
;
if
(
!
includeTombstones
)
{
whereStatement
=
"
WHERE
removed_at
IS
NULL
"
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
AS
url
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
{
whereStatement
}
ORDER
BY
last_interaction_at
DESC
LIMIT
:
limit
{
limit
}
)
;
return
rows
.
map
(
row
=
>
this
.
#
translateRow
(
row
)
)
;
}
#
translateRow
(
row
)
{
return
{
url
:
row
.
getResultByName
(
"
url
"
)
createdAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
created_at
"
)
)
removedAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
removed_at
"
)
)
firstInteractionAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
first_interaction_at
"
)
)
lastInteractionAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
last_interaction_at
"
)
)
documentType
:
row
.
getResultByName
(
"
document_type
"
)
userPersisted
:
!
!
row
.
getResultByName
(
"
user_persisted
"
)
}
;
}
#
toDate
(
value
)
{
if
(
value
)
{
return
new
Date
(
value
)
;
}
return
null
;
}
}
)
(
)
;
