"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Snapshots
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
VERSION_PREF
=
"
browser
.
places
.
snapshots
.
version
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CommonNames
:
"
resource
:
/
/
/
modules
/
CommonNames
.
jsm
"
Interactions
:
"
resource
:
/
/
/
modules
/
Interactions
.
jsm
"
PageDataCollector
:
"
resource
:
/
/
/
modules
/
pagedata
/
PageDataCollector
.
jsm
"
PageDataService
:
"
resource
:
/
/
/
modules
/
pagedata
/
PageDataService
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
SnapshotsManager
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
const
DEFAULT_CRITERIA
=
[
{
property
:
"
total_view_time
"
aggregator
:
"
max
"
cutoff
:
30000
}
{
property
:
"
total_view_time
"
aggregator
:
"
sum
"
cutoff
:
120000
interactionCount
:
5
}
{
property
:
"
key_presses
"
aggregator
:
"
sum
"
cutoff
:
250
interactionCount
:
10
}
]
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshotCriteria
"
"
browser
.
places
.
interactions
.
snapshotCriteria
"
JSON
.
stringify
(
DEFAULT_CRITERIA
)
)
;
const
Snapshots
=
new
(
class
Snapshots
{
constructor
(
)
{
}
get
urlRequirements
(
)
{
return
new
Map
(
[
[
"
http
:
"
{
}
]
[
"
https
:
"
{
}
]
[
"
file
:
"
{
extension
:
"
pdf
"
}
]
]
)
;
}
#
notify
(
topic
urls
)
{
Services
.
obs
.
notifyObservers
(
null
topic
JSON
.
stringify
(
urls
)
)
;
}
async
#
addPageData
(
urls
)
{
let
index
=
0
;
let
values
=
[
]
;
let
bindings
=
{
}
;
for
(
let
{
placeId
url
}
of
urls
)
{
let
pageData
=
PageDataService
.
getCached
(
url
)
;
if
(
pageData
?
.
data
.
length
)
{
for
(
let
data
of
pageData
.
data
)
{
if
(
Object
.
values
(
PageDataCollector
.
DATA_TYPE
)
.
includes
(
data
.
type
)
)
{
bindings
[
id
{
index
}
]
=
placeId
;
bindings
[
type
{
index
}
]
=
data
.
type
;
bindings
[
data
{
index
}
]
=
JSON
.
stringify
(
data
)
;
values
.
push
(
(
:
id
{
index
}
:
type
{
index
}
:
data
{
index
}
)
)
;
index
+
+
;
}
}
}
else
{
PageDataService
.
queueFetch
(
url
)
.
catch
(
console
.
error
)
;
}
}
logConsole
.
debug
(
Inserting
{
index
}
page
data
for
:
{
urls
.
map
(
u
=
>
u
.
url
)
}
.
)
;
if
(
index
=
=
0
)
{
return
;
}
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
addPageData
"
async
db
=
>
{
await
db
.
execute
(
INSERT
OR
REPLACE
INTO
moz_places_metadata_snapshots_extra
(
place_id
type
data
)
VALUES
{
values
.
join
(
"
"
)
}
bindings
)
;
}
)
;
}
canSnapshotUrl
(
url
)
{
let
protocol
pathname
;
if
(
typeof
url
=
=
"
string
"
)
{
url
=
new
URL
(
url
)
;
}
if
(
url
instanceof
Ci
.
nsIURI
)
{
protocol
=
url
.
scheme
+
"
:
"
;
pathname
=
url
.
filePath
;
}
else
{
protocol
=
url
.
protocol
;
pathname
=
url
.
pathname
;
}
let
requirements
=
this
.
urlRequirements
.
get
(
protocol
)
;
return
(
requirements
&
&
(
!
requirements
.
extension
|
|
pathname
.
endsWith
(
requirements
.
extension
)
)
)
;
}
/
*
*
*
Adds
a
new
snapshot
.
*
*
If
the
snapshot
already
exists
and
this
is
a
user
-
persisted
addition
*
then
the
userPersisted
flag
will
be
set
and
the
removed_at
flag
will
be
*
cleared
.
*
*
param
{
object
}
details
*
param
{
string
}
details
.
url
*
The
url
associated
with
the
snapshot
.
*
param
{
boolean
}
[
details
.
userPersisted
]
*
True
if
the
user
created
or
persisted
the
snapshot
in
some
way
defaults
to
*
false
.
*
/
async
add
(
{
url
userPersisted
=
false
}
)
{
if
(
!
url
)
{
throw
new
Error
(
"
Missing
url
parameter
to
Snapshots
.
add
(
)
"
)
;
}
if
(
!
this
.
canSnapshotUrl
(
url
)
)
{
throw
new
Error
(
"
This
url
cannot
be
added
to
snapshots
"
)
;
}
let
placeId
=
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
:
add
"
async
db
=
>
{
let
now
=
Date
.
now
(
)
;
await
this
.
#
maybeInsertPlace
(
db
new
URL
(
url
)
)
;
/
/
When
the
user
asks
for
a
snapshot
to
be
created
we
may
not
yet
have
/
/
a
corresponding
interaction
.
We
create
a
snapshot
with
0
as
the
value
/
/
for
first_interaction_at
to
flag
it
as
missing
a
corresponding
/
/
interaction
.
We
have
a
database
trigger
that
will
update
this
/
/
snapshot
with
real
values
from
the
corresponding
interaction
when
the
/
/
latter
is
created
.
let
rows
=
await
db
.
executeCached
(
INSERT
INTO
moz_places_metadata_snapshots
(
place_id
first_interaction_at
last_interaction_at
document_type
created_at
user_persisted
)
SELECT
h
.
id
IFNULL
(
min
(
m
.
created_at
)
CASE
WHEN
:
userPersisted
THEN
0
ELSE
NULL
END
)
IFNULL
(
max
(
m
.
created_at
)
CASE
WHEN
:
userPersisted
THEN
:
createdAt
ELSE
NULL
END
)
IFNULL
(
first_value
(
m
.
document_type
)
OVER
(
PARTITION
BY
h
.
id
ORDER
BY
m
.
created_at
DESC
)
:
documentFallback
)
:
createdAt
:
userPersisted
FROM
moz_places
h
LEFT
JOIN
moz_places_metadata
m
ON
m
.
place_id
=
h
.
id
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
GROUP
BY
h
.
id
ON
CONFLICT
DO
UPDATE
SET
user_persisted
=
:
userPersisted
removed_at
=
NULL
WHERE
:
userPersisted
=
1
RETURNING
place_id
created_at
user_persisted
{
createdAt
:
now
url
userPersisted
documentFallback
:
Interactions
.
DOCUMENT_TYPE
.
GENERIC
}
)
;
if
(
rows
.
length
)
{
/
/
If
created_at
doesn
'
t
match
then
this
url
was
already
a
snapshot
/
/
and
we
only
overwrite
it
when
the
new
request
is
user_persisted
.
if
(
rows
[
0
]
.
getResultByName
(
"
created_at
"
)
!
=
now
&
&
!
rows
[
0
]
.
getResultByName
(
"
user_persisted
"
)
)
{
return
null
;
}
return
rows
[
0
]
.
getResultByName
(
"
place_id
"
)
;
}
return
null
;
}
)
;
if
(
placeId
)
{
await
this
.
#
addPageData
(
[
{
placeId
url
}
]
)
;
this
.
#
notify
(
"
places
-
snapshots
-
added
"
[
url
]
)
;
}
}
async
delete
(
url
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
:
delete
"
async
db
=
>
{
let
placeId
=
(
await
db
.
executeCached
(
UPDATE
moz_places_metadata_snapshots
SET
removed_at
=
:
removedAt
WHERE
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
RETURNING
place_id
{
removedAt
:
Date
.
now
(
)
url
}
)
)
[
0
]
.
getResultByName
(
"
place_id
"
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_snapshots_extra
WHERE
place_id
=
:
placeId
{
placeId
}
)
;
}
)
;
this
.
#
notify
(
"
places
-
snapshots
-
deleted
"
[
url
]
)
;
}
async
get
(
url
includeTombstones
=
false
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
extraWhereCondition
=
"
"
;
if
(
!
includeTombstones
)
{
extraWhereCondition
=
"
AND
removed_at
IS
NULL
"
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
AS
url
h
.
title
AS
title
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
group_concat
(
e
.
data
"
"
)
AS
page_data
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
{
extraWhereCondition
}
GROUP
BY
s
.
place_id
{
url
}
)
;
if
(
!
rows
.
length
)
{
return
null
;
}
return
this
.
#
translateRow
(
rows
[
0
]
)
;
}
async
query
(
{
limit
=
100
includeTombstones
=
false
type
=
undefined
}
=
{
}
)
{
await
this
.
#
ensureVersionUpdates
(
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
clauses
=
[
]
;
let
bindings
=
{
limit
}
;
if
(
!
includeTombstones
)
{
clauses
.
push
(
"
removed_at
IS
NULL
"
)
;
}
if
(
type
)
{
clauses
.
push
(
"
type
=
:
type
"
)
;
bindings
.
type
=
type
;
}
let
whereStatement
=
clauses
.
length
?
WHERE
{
clauses
.
join
(
"
AND
"
)
}
:
"
"
;
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
AS
url
h
.
title
AS
title
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
group_concat
(
e
.
data
"
"
)
AS
page_data
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
{
whereStatement
}
GROUP
BY
s
.
place_id
ORDER
BY
last_interaction_at
DESC
LIMIT
:
limit
bindings
)
;
return
rows
.
map
(
row
=
>
this
.
#
translateRow
(
row
)
)
;
}
async
#
ensureVersionUpdates
(
)
{
let
dbVersion
=
Services
.
prefs
.
getIntPref
(
VERSION_PREF
0
)
;
try
{
if
(
dbVersion
<
1
)
{
try
{
let
profileDir
=
await
PathUtils
.
getProfileDir
(
)
;
let
pathToKeyframes
=
PathUtils
.
join
(
profileDir
"
keyframes
.
sqlite
"
)
;
await
IOUtils
.
remove
(
pathToKeyframes
)
;
}
catch
(
ex
)
{
console
.
warn
(
Failed
to
delete
keyframes
.
sqlite
:
{
ex
}
)
;
}
}
}
finally
{
Services
.
prefs
.
setIntPref
(
VERSION_PREF
this
.
currentVersion
)
;
}
}
get
currentVersion
(
)
{
return
1
;
}
#
translateRow
(
row
)
{
let
pageData
=
new
Map
(
)
;
let
pageDataStr
=
row
.
getResultByName
(
"
page_data
"
)
;
if
(
pageDataStr
)
{
try
{
let
dataArray
=
JSON
.
parse
(
[
{
pageDataStr
}
]
)
;
dataArray
.
forEach
(
d
=
>
pageData
.
set
(
d
.
type
d
.
data
)
)
;
}
catch
(
e
)
{
logConsole
.
error
(
e
)
;
}
}
let
snapshot
=
{
url
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
createdAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
created_at
"
)
)
removedAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
removed_at
"
)
)
firstInteractionAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
first_interaction_at
"
)
)
lastInteractionAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
last_interaction_at
"
)
)
documentType
:
row
.
getResultByName
(
"
document_type
"
)
userPersisted
:
!
!
row
.
getResultByName
(
"
user_persisted
"
)
pageData
}
;
snapshot
.
commonName
=
CommonNames
.
getName
(
snapshot
)
;
return
snapshot
;
}
#
toDate
(
value
)
{
if
(
value
)
{
return
new
Date
(
value
)
;
}
return
null
;
}
async
updateSnapshots
(
urls
=
undefined
)
{
if
(
urls
!
=
=
undefined
&
&
!
urls
.
length
)
{
return
;
}
logConsole
.
debug
(
Testing
{
urls
?
urls
.
length
:
"
all
"
}
potential
snapshots
)
;
let
model
;
try
{
model
=
JSON
.
parse
(
snapshotCriteria
)
;
if
(
!
model
.
length
)
{
logConsole
.
debug
(
No
snapshot
criteria
provided
falling
back
to
default
)
;
model
=
DEFAULT_CRITERIA
;
}
}
catch
(
e
)
{
logConsole
.
error
(
"
Invalid
snapshot
criteria
falling
back
to
default
.
"
e
)
;
model
=
DEFAULT_CRITERIA
;
}
let
insertedUrls
=
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
updateSnapshots
"
async
db
=
>
{
let
bindings
=
{
}
;
let
urlFilter
=
"
"
;
if
(
urls
=
=
undefined
)
{
let
filters
=
[
]
;
for
(
let
protocol
of
this
.
urlRequirements
.
keys
(
)
)
{
filters
.
push
(
(
url_hash
BETWEEN
hash
(
'
{
protocol
}
'
'
prefix_lo
'
)
AND
hash
(
'
{
protocol
}
'
'
prefix_hi
'
)
)
)
;
}
urlFilter
=
"
WHERE
"
+
filters
.
join
(
"
OR
"
)
;
}
else
{
let
urlMatches
=
[
]
;
urls
.
forEach
(
(
url
idx
)
=
>
{
if
(
!
this
.
canSnapshotUrl
(
url
)
)
{
logConsole
.
debug
(
Url
can
'
t
be
added
to
snapshots
:
{
url
}
)
;
return
;
}
bindings
[
url
{
idx
}
]
=
url
;
urlMatches
.
push
(
(
url_hash
=
hash
(
:
url
{
idx
}
)
AND
url
=
:
url
{
idx
}
)
)
;
}
)
;
if
(
!
urlMatches
.
length
)
{
return
[
]
;
}
urlFilter
=
WHERE
{
urlMatches
.
join
(
"
OR
"
)
}
;
}
let
modelQueries
=
[
]
;
model
.
forEach
(
(
criteria
idx
)
=
>
{
let
wheres
=
[
]
;
if
(
criteria
.
interactionCount
)
{
wheres
.
push
(
row
<
=
:
count
{
idx
}
)
;
bindings
[
count
{
idx
}
]
=
criteria
.
interactionCount
;
}
if
(
criteria
.
interactionRecency
)
{
wheres
.
push
(
created_at
>
=
:
recency
{
idx
}
)
;
bindings
[
recency
{
idx
}
]
=
Date
.
now
(
)
-
criteria
.
interactionCount
;
}
let
where
=
wheres
.
length
?
WHERE
{
wheres
.
join
(
"
AND
"
)
}
:
"
"
;
modelQueries
.
push
(
SELECT
place_id
min
(
created_at
)
AS
first_interaction_at
max
(
created_at
)
AS
last_interaction_at
doc_type
:
createdAt
FROM
metadata
{
where
}
GROUP
BY
place_id
HAVING
{
criteria
.
aggregator
}
(
{
criteria
.
property
}
)
>
=
:
cutoff
{
idx
}
)
;
bindings
[
cutoff
{
idx
}
]
=
criteria
.
cutoff
;
}
)
;
let
query
=
WITH
metadata
AS
(
SELECT
moz_places_metadata
.
*
row_number
(
)
OVER
(
PARTITION
BY
place_id
ORDER
BY
created_at
DESC
)
AS
row
first_value
(
document_type
)
OVER
(
PARTITION
BY
place_id
ORDER
BY
created_at
DESC
)
AS
doc_type
FROM
moz_places_metadata
JOIN
moz_places
h
ON
moz_places_metadata
.
place_id
=
h
.
id
{
urlFilter
}
)
INSERT
OR
IGNORE
INTO
moz_places_metadata_snapshots
(
place_id
first_interaction_at
last_interaction_at
document_type
created_at
)
{
modelQueries
.
join
(
"
UNION
"
)
}
RETURNING
place_id
(
SELECT
url
FROM
moz_places
WHERE
id
=
place_id
)
AS
url
created_at
;
let
now
=
Date
.
now
(
)
;
let
results
=
await
db
.
execute
(
query
{
.
.
.
bindings
createdAt
:
now
}
)
;
logConsole
.
debug
(
Inserted
{
results
.
length
}
snapshots
)
;
let
newUrls
=
[
]
;
for
(
let
row
of
results
)
{
if
(
row
.
getResultByName
(
"
created_at
"
)
=
=
now
)
{
newUrls
.
push
(
{
placeId
:
row
.
getResultByName
(
"
place_id
"
)
url
:
row
.
getResultByName
(
"
url
"
)
}
)
;
}
}
return
newUrls
;
}
)
;
if
(
insertedUrls
.
length
)
{
logConsole
.
debug
(
{
insertedUrls
.
length
}
snapshots
created
)
;
await
this
.
#
addPageData
(
insertedUrls
)
;
this
.
#
notify
(
"
places
-
snapshots
-
added
"
insertedUrls
.
map
(
result
=
>
result
.
url
)
)
;
}
}
async
reset
(
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
reset
"
async
db
=
>
{
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_snapshots
)
;
}
)
;
}
async
#
maybeInsertPlace
(
db
url
)
{
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
VALUES
(
:
url
hash
(
:
url
)
:
rev_host
1
-
1
IFNULL
(
(
SELECT
guid
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
)
{
url
:
url
.
href
rev_host
:
PlacesUtils
.
getReversedHost
(
url
)
}
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_updateoriginsinsert_temp
"
)
;
}
}
)
(
)
;
