"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Snapshots
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
Snapshots
=
new
(
class
Snapshots
{
#
snapshots
=
new
Map
(
)
;
async
add
(
{
url
userPersisted
=
false
}
)
{
let
now
=
new
Date
(
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
WITH
places
(
place_id
)
AS
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
inserts
(
created_at
updated_at
document_type
)
AS
(
VALUES
(
(
SELECT
min
(
created_at
)
FROM
moz_places_metadata
WHERE
place_id
in
places
)
(
SELECT
max
(
updated_at
)
FROM
moz_places_metadata
WHERE
place_id
in
places
)
(
SELECT
document_type
FROM
moz_places_metadata
WHERE
place_id
in
places
ORDER
BY
updated_at
DESC
LIMIT
1
)
)
)
SELECT
*
from
inserts
WHERE
created_at
is
not
null
{
url
}
)
;
if
(
!
rows
.
length
)
{
throw
new
Error
(
"
Could
not
find
existing
interactions
"
)
;
}
this
.
#
snapshots
.
set
(
url
{
url
userPersisted
createdAt
:
now
removedAt
:
null
documentType
:
rows
[
0
]
.
getResultByName
(
"
document_type
"
)
firstInteractionAt
:
new
Date
(
rows
[
0
]
.
getResultByName
(
"
created_at
"
)
)
lastInteractionAt
:
new
Date
(
rows
[
0
]
.
getResultByName
(
"
updated_at
"
)
)
}
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
added
"
url
)
;
}
async
delete
(
url
)
{
let
snapshot
=
this
.
#
snapshots
.
get
(
url
)
;
if
(
snapshot
)
{
snapshot
.
removedAt
=
new
Date
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
snapshot
-
deleted
"
url
)
;
}
}
async
get
(
url
includeTombstones
=
false
)
{
let
snapshot
=
this
.
#
snapshots
.
get
(
url
)
;
if
(
!
snapshot
|
|
(
snapshot
.
removedAt
&
&
!
includeTombstones
)
)
{
return
null
;
}
return
snapshot
;
}
async
query
(
{
limit
=
100
includeTombstones
=
false
}
=
{
}
)
{
let
snapshots
=
Array
.
from
(
this
.
#
snapshots
.
values
(
)
)
;
if
(
!
includeTombstones
)
{
return
snapshots
.
filter
(
s
=
>
!
s
.
removedAt
)
.
slice
(
0
limit
)
;
}
return
snapshots
.
slice
(
0
limit
)
;
}
}
)
(
)
;
