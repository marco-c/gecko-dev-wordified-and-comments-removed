"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Snapshots
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
VERSION_PREF
=
"
browser
.
places
.
snapshots
.
version
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BackgroundPageThumbs
:
"
resource
:
/
/
gre
/
modules
/
BackgroundPageThumbs
.
jsm
"
CommonNames
:
"
resource
:
/
/
/
modules
/
CommonNames
.
jsm
"
Interactions
:
"
resource
:
/
/
/
modules
/
Interactions
.
jsm
"
InteractionsBlocklist
:
"
resource
:
/
/
/
modules
/
InteractionsBlocklist
.
jsm
"
PageDataService
:
"
resource
:
/
/
/
modules
/
pagedata
/
PageDataService
.
jsm
"
PageThumbs
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
PageThumbsStorage
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PlacesPreviews
:
"
resource
:
/
/
gre
/
modules
/
PlacesPreviews
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
function
(
)
{
return
console
.
createInstance
(
{
prefix
:
"
SnapshotsManager
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
interactions
.
log
"
false
)
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshot_overlap_limit
"
"
browser
.
places
.
interactions
.
snapshotOverlapLimit
"
1800000
)
;
const
DEFAULT_CRITERIA
=
[
{
property
:
"
total_view_time
"
aggregator
:
"
max
"
cutoff
:
30000
}
{
property
:
"
total_view_time
"
aggregator
:
"
sum
"
cutoff
:
120000
interactionCount
:
5
}
{
property
:
"
key_presses
"
aggregator
:
"
sum
"
cutoff
:
250
interactionCount
:
10
}
]
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snapshotCriteria
"
"
browser
.
places
.
interactions
.
snapshotCriteria
"
JSON
.
stringify
(
DEFAULT_CRITERIA
)
)
;
const
Snapshots
=
new
(
class
Snapshots
{
USER_PERSISTED
=
{
NO
:
0
MANUAL
:
1
PINNED
:
2
}
;
constructor
(
)
{
if
(
!
PlacesPreviews
.
enabled
)
{
PageThumbs
.
addExpirationFilter
(
this
)
;
}
}
#
notify
(
topic
urls
)
{
Services
.
obs
.
notifyObservers
(
null
topic
JSON
.
stringify
(
urls
)
)
;
}
async
filterForThumbnailExpiration
(
callback
)
{
let
snapshots
=
await
this
.
query
(
)
;
let
urls
=
[
]
;
for
(
let
snapshot
of
snapshots
)
{
urls
.
push
(
snapshot
.
url
)
;
}
callback
(
urls
)
;
}
async
#
addPageData
(
urls
)
{
let
pageDataIndex
=
0
;
let
pageDataValues
=
[
]
;
let
pageDataBindings
=
{
}
;
let
placesIndex
=
0
;
let
placesValues
=
[
]
;
let
placesBindings
=
{
}
;
for
(
let
{
placeId
url
}
of
urls
)
{
let
pageData
=
PageDataService
.
getCached
(
url
)
;
if
(
pageData
)
{
for
(
let
[
type
data
]
of
Object
.
entries
(
pageData
.
data
)
)
{
pageDataBindings
[
id
{
pageDataIndex
}
]
=
placeId
;
pageDataBindings
[
type
{
pageDataIndex
}
]
=
type
;
pageDataBindings
[
data
{
pageDataIndex
}
]
=
JSON
.
stringify
(
data
)
;
pageDataValues
.
push
(
(
:
id
{
pageDataIndex
}
:
type
{
pageDataIndex
}
:
data
{
pageDataIndex
}
)
)
;
pageDataIndex
+
+
;
}
let
{
siteName
description
image
:
previewImageURL
}
=
pageData
;
let
pageInfo
=
PlacesUtils
.
validateItemProperties
(
"
PageInfo
"
PlacesUtils
.
PAGEINFO_VALIDATORS
{
siteName
description
previewImageURL
}
)
;
placesBindings
[
id
{
placesIndex
}
]
=
placeId
;
placesBindings
[
desc
{
placesIndex
}
]
=
pageInfo
.
description
?
?
null
;
placesBindings
[
site
{
placesIndex
}
]
=
pageInfo
.
siteName
?
?
null
;
placesBindings
[
image
{
placesIndex
}
]
=
pageInfo
.
previewImageURL
?
.
toString
(
)
?
?
null
;
placesValues
.
push
(
(
:
id
{
placesIndex
}
:
desc
{
placesIndex
}
:
site
{
placesIndex
}
:
image
{
placesIndex
}
)
)
;
placesIndex
+
+
;
}
else
{
PageDataService
.
queueFetch
(
url
)
;
}
this
.
#
downloadPageImage
(
url
pageData
?
.
image
)
;
}
logConsole
.
debug
(
Inserting
{
pageDataIndex
}
page
data
for
:
{
urls
.
map
(
u
=
>
u
.
url
)
}
.
)
;
if
(
pageDataIndex
=
=
0
&
&
placesIndex
=
=
0
)
{
return
;
}
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
addPageData
"
async
db
=
>
{
if
(
placesIndex
)
{
await
db
.
execute
(
WITH
pd
(
"
place_id
"
"
description
"
"
siteName
"
"
image
"
)
AS
(
VALUES
{
placesValues
.
join
(
"
"
)
}
)
UPDATE
moz_places
SET
description
=
pd
.
description
site_name
=
pd
.
siteName
preview_image_url
=
pd
.
image
FROM
pd
WHERE
moz_places
.
id
=
pd
.
place_id
;
placesBindings
)
;
}
if
(
pageDataIndex
)
{
await
db
.
execute
(
INSERT
OR
REPLACE
INTO
moz_places_metadata_snapshots_extra
(
place_id
type
data
)
VALUES
{
pageDataValues
.
join
(
"
"
)
}
pageDataBindings
)
;
}
}
)
;
}
#
downloadPageImage
(
url
metaDataImageURL
=
null
)
{
if
(
!
metaDataImageURL
)
{
if
(
PlacesPreviews
.
enabled
)
{
PlacesPreviews
.
update
(
url
)
.
catch
(
console
.
error
)
;
}
else
{
BackgroundPageThumbs
.
captureIfMissing
(
url
)
.
catch
(
console
.
error
)
;
}
}
}
async
add
(
{
url
title
userPersisted
=
this
.
USER_PERSISTED
.
NO
}
)
{
if
(
!
url
)
{
throw
new
Error
(
"
Missing
url
parameter
to
Snapshots
.
add
(
)
"
)
;
}
if
(
!
InteractionsBlocklist
.
canRecordUrl
(
url
)
)
{
throw
new
Error
(
"
This
url
cannot
be
added
to
snapshots
"
)
;
}
let
placeId
=
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
:
add
"
async
db
=
>
{
let
now
=
Date
.
now
(
)
;
await
this
.
#
maybeInsertPlace
(
db
new
URL
(
url
)
)
;
let
updateTitleFragment
=
title
!
=
=
undefined
?
"
title
=
:
title
"
:
"
"
;
if
(
title
!
=
=
undefined
)
{
userPersisted
=
this
.
USER_PERSISTED
.
MANUAL
;
}
let
rows
=
await
db
.
executeCached
(
INSERT
INTO
moz_places_metadata_snapshots
(
place_id
first_interaction_at
last_interaction_at
document_type
created_at
user_persisted
title
)
SELECT
h
.
id
IFNULL
(
min
(
m
.
created_at
)
CASE
WHEN
:
userPersisted
THEN
0
ELSE
NULL
END
)
IFNULL
(
max
(
m
.
created_at
)
CASE
WHEN
:
userPersisted
THEN
:
createdAt
ELSE
NULL
END
)
IFNULL
(
first_value
(
m
.
document_type
)
OVER
(
PARTITION
BY
h
.
id
ORDER
BY
m
.
created_at
DESC
)
:
documentFallback
)
:
createdAt
:
userPersisted
:
title
FROM
moz_places
h
LEFT
JOIN
moz_places_metadata
m
ON
m
.
place_id
=
h
.
id
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
GROUP
BY
h
.
id
ON
CONFLICT
DO
UPDATE
SET
user_persisted
=
MAX
(
:
userPersisted
user_persisted
)
removed_at
=
NULL
{
updateTitleFragment
}
WHERE
:
userPersisted
<
>
0
RETURNING
place_id
created_at
user_persisted
{
createdAt
:
now
url
userPersisted
documentFallback
:
Interactions
.
DOCUMENT_TYPE
.
GENERIC
title
:
title
|
|
null
}
)
;
if
(
rows
.
length
)
{
if
(
rows
[
0
]
.
getResultByName
(
"
created_at
"
)
!
=
now
&
&
rows
[
0
]
.
getResultByName
(
"
user_persisted
"
)
=
=
this
.
USER_PERSISTED
.
NO
)
{
return
null
;
}
return
rows
[
0
]
.
getResultByName
(
"
place_id
"
)
;
}
return
null
;
}
)
;
if
(
placeId
)
{
await
this
.
#
addPageData
(
[
{
placeId
url
}
]
)
;
this
.
#
notify
(
"
places
-
snapshots
-
added
"
[
{
url
userPersisted
}
]
)
;
}
}
async
delete
(
url
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
:
delete
"
async
db
=
>
{
let
placeId
=
(
await
db
.
executeCached
(
UPDATE
moz_places_metadata_snapshots
SET
removed_at
=
:
removedAt
WHERE
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
RETURNING
place_id
{
removedAt
:
Date
.
now
(
)
url
}
)
)
[
0
]
.
getResultByName
(
"
place_id
"
)
;
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_snapshots_extra
WHERE
place_id
=
:
placeId
{
placeId
}
)
;
}
)
;
this
.
#
notify
(
"
places
-
snapshots
-
deleted
"
[
url
]
)
;
}
async
get
(
url
includeTombstones
=
false
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
extraWhereCondition
=
"
"
;
if
(
!
includeTombstones
)
{
extraWhereCondition
=
"
AND
removed_at
IS
NULL
"
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
AS
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
AS
page_data
h
.
visit_count
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
{
extraWhereCondition
}
GROUP
BY
s
.
place_id
{
url
}
)
;
if
(
!
rows
.
length
)
{
return
null
;
}
return
this
.
#
translateRow
(
rows
[
0
]
)
;
}
async
query
(
{
limit
=
100
includeTombstones
=
false
type
=
undefined
group
=
undefined
sortDescending
=
true
sortBy
=
"
last_interaction_at
"
}
=
{
}
)
{
await
this
.
#
ensureVersionUpdates
(
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
clauses
=
[
]
;
let
bindings
=
{
}
;
let
joins
=
[
]
;
let
limitStatement
=
"
"
;
if
(
!
includeTombstones
)
{
clauses
.
push
(
"
removed_at
IS
NULL
"
)
;
}
if
(
type
)
{
clauses
.
push
(
"
type
=
:
type
"
)
;
bindings
.
type
=
type
;
}
if
(
group
)
{
clauses
.
push
(
"
group_id
=
:
group
"
)
;
bindings
.
group
=
group
;
joins
.
push
(
"
LEFT
JOIN
moz_places_metadata_groups_to_snapshots
USING
(
place_id
)
"
)
;
}
if
(
limit
!
=
-
1
)
{
limitStatement
=
"
LIMIT
:
limit
"
;
bindings
.
limit
=
limit
;
}
let
whereStatement
=
clauses
.
length
?
WHERE
{
clauses
.
join
(
"
AND
"
)
}
:
"
"
;
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
AS
page_data
h
.
visit_count
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
{
joins
.
join
(
"
"
)
}
{
whereStatement
}
GROUP
BY
s
.
place_id
ORDER
BY
{
sortBy
}
{
sortDescending
?
"
DESC
"
:
"
ASC
"
}
{
limitStatement
}
bindings
)
;
return
rows
.
map
(
row
=
>
this
.
#
translateRow
(
row
)
)
;
}
async
queryPlaceIdFromUrl
(
url
)
{
await
this
.
#
ensureVersionUpdates
(
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
id
from
moz_places
p
WHERE
p
.
url
=
:
url
{
url
}
)
;
if
(
!
rows
.
length
)
{
return
-
1
;
}
return
rows
[
0
]
.
getResultByName
(
"
id
"
)
;
}
async
queryOverlapping
(
context_url
)
{
await
this
.
#
ensureVersionUpdates
(
)
;
let
current_id
=
await
this
.
queryPlaceIdFromUrl
(
context_url
)
;
if
(
current_id
=
=
-
1
)
{
logConsole
.
debug
(
PlaceId
not
found
for
url
{
context_url
}
)
;
return
[
]
;
}
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
url
AS
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
o
.
overlappingVisitScore
created_at
removed_at
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
AS
page_data
h
.
visit_count
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
JOIN
(
SELECT
place_id
MIN
(
SUM
(
CASE
WHEN
(
page_start
>
snapshot_end
)
>
0
THEN
MAX
(
1
.
0
-
(
page_start
-
snapshot_end
)
/
CAST
(
:
snapshot_overlap_limit
as
float
)
0
.
0
)
WHEN
(
page_end
<
snapshot_start
)
>
0
THEN
MAX
(
1
.
0
-
(
snapshot_start
-
page_end
)
/
CAST
(
:
snapshot_overlap_limit
as
float
)
0
.
0
)
ELSE
1
.
0
END
)
1
.
0
)
overlappingVisitScore
FROM
(
SELECT
created_at
AS
page_start
created_at
-
:
snapshot_overlap_limit
AS
page_start_limit
updated_at
AS
page_end
updated_at
+
:
snapshot_overlap_limit
AS
page_end_limit
FROM
moz_places_metadata
WHERE
place_id
=
:
current_id
)
AS
current_page
JOIN
(
SELECT
place_id
created_at
AS
snapshot_start
updated_at
AS
snapshot_end
FROM
moz_places_metadata
WHERE
place_id
!
=
:
current_id
)
AS
suggestion
WHERE
snapshot_start
BETWEEN
page_start_limit
AND
page_end_limit
OR
snapshot_end
BETWEEN
page_start_limit
AND
page_end_limit
OR
(
snapshot_start
<
page_start_limit
AND
snapshot_end
>
page_end_limit
)
GROUP
BY
place_id
)
o
ON
s
.
place_id
=
o
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
GROUP
BY
s
.
place_id
ORDER
BY
o
.
overlappingVisitScore
DESC
;
{
current_id
snapshot_overlap_limit
}
)
;
if
(
!
rows
.
length
)
{
logConsole
.
debug
(
"
No
overlapping
snapshots
"
)
;
return
[
]
;
}
return
rows
.
map
(
row
=
>
this
.
#
translateRow
(
row
{
includeOverlappingVisitScore
:
true
}
)
)
;
}
async
queryCommonReferrer
(
context_url
)
{
await
this
.
#
ensureVersionUpdates
(
)
;
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
context_place_id
=
await
this
.
queryPlaceIdFromUrl
(
context_url
)
;
if
(
context_place_id
=
=
-
1
)
{
return
[
]
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
h
.
id
h
.
url
AS
url
IFNULL
(
s
.
title
h
.
title
)
AS
title
s
.
created_at
removed_at
s
.
document_type
first_interaction_at
last_interaction_at
user_persisted
description
site_name
preview_image_url
h
.
visit_count
group_concat
(
'
[
'
|
|
e
.
type
|
|
'
'
|
|
e
.
data
|
|
'
]
'
)
AS
page_data
FROM
moz_places_metadata_snapshots
s
JOIN
moz_places
h
ON
h
.
id
=
s
.
place_id
LEFT
JOIN
moz_places_metadata_snapshots_extra
e
ON
e
.
place_id
=
s
.
place_id
WHERE
s
.
place_id
IN
(
SELECT
p1
.
place_id
FROM
moz_places_metadata
p1
JOIN
moz_places_metadata
p2
USING
(
referrer_place_id
)
WHERE
p2
.
place_id
=
:
context_place_id
AND
p1
.
place_id
<
>
:
context_place_id
)
GROUP
BY
s
.
place_id
{
context_place_id
}
)
;
return
rows
.
map
(
row
=
>
{
let
snapshot
=
this
.
#
translateRow
(
row
)
;
snapshot
.
commonReferrerScore
=
1
.
0
;
return
snapshot
;
}
)
;
}
async
#
ensureVersionUpdates
(
)
{
let
dbVersion
=
Services
.
prefs
.
getIntPref
(
VERSION_PREF
0
)
;
try
{
if
(
dbVersion
<
1
)
{
try
{
let
profileDir
=
await
PathUtils
.
getProfileDir
(
)
;
let
pathToKeyframes
=
PathUtils
.
join
(
profileDir
"
keyframes
.
sqlite
"
)
;
await
IOUtils
.
remove
(
pathToKeyframes
)
;
}
catch
(
ex
)
{
console
.
warn
(
Failed
to
delete
keyframes
.
sqlite
:
{
ex
}
)
;
}
}
}
finally
{
Services
.
prefs
.
setIntPref
(
VERSION_PREF
this
.
currentVersion
)
;
}
}
get
currentVersion
(
)
{
return
1
;
}
#
translateRow
(
row
{
includeOverlappingVisitScore
=
false
}
=
{
}
)
{
let
pageData
;
let
pageDataStr
=
row
.
getResultByName
(
"
page_data
"
)
;
if
(
pageDataStr
)
{
try
{
let
dataArray
=
JSON
.
parse
(
[
{
pageDataStr
}
]
)
;
pageData
=
new
Map
(
dataArray
)
;
}
catch
(
e
)
{
logConsole
.
error
(
e
)
;
}
}
let
overlappingVisitScore
=
0
;
if
(
includeOverlappingVisitScore
)
{
overlappingVisitScore
=
row
.
getResultByName
(
"
overlappingVisitScore
"
)
;
}
let
snapshot
=
{
url
:
row
.
getResultByName
(
"
url
"
)
title
:
row
.
getResultByName
(
"
title
"
)
siteName
:
row
.
getResultByName
(
"
site_name
"
)
description
:
row
.
getResultByName
(
"
description
"
)
image
:
row
.
getResultByName
(
"
preview_image_url
"
)
createdAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
created_at
"
)
)
removedAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
removed_at
"
)
)
firstInteractionAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
first_interaction_at
"
)
)
lastInteractionAt
:
this
.
#
toDate
(
row
.
getResultByName
(
"
last_interaction_at
"
)
)
documentType
:
row
.
getResultByName
(
"
document_type
"
)
userPersisted
:
row
.
getResultByName
(
"
user_persisted
"
)
overlappingVisitScore
pageData
:
pageData
?
?
new
Map
(
)
visitCount
:
row
.
getResultByName
(
"
visit_count
"
)
}
;
snapshot
.
commonName
=
CommonNames
.
getName
(
snapshot
)
;
return
snapshot
;
}
async
getSnapshotImageURL
(
snapshot
)
{
if
(
snapshot
.
image
)
{
return
snapshot
.
image
;
}
const
url
=
snapshot
.
url
;
if
(
PlacesPreviews
.
enabled
)
{
if
(
await
PlacesPreviews
.
update
(
url
)
.
catch
(
console
.
error
)
)
{
return
PlacesPreviews
.
getPageThumbURL
(
url
)
;
}
}
else
{
await
BackgroundPageThumbs
.
captureIfMissing
(
url
)
.
catch
(
console
.
error
)
;
if
(
await
PageThumbsStorage
.
fileExistsForURL
(
url
)
)
{
return
PageThumbs
.
getThumbnailURL
(
url
)
;
}
}
return
null
;
}
#
toDate
(
value
)
{
if
(
value
)
{
return
new
Date
(
value
)
;
}
return
null
;
}
async
updateSnapshots
(
urls
=
undefined
)
{
if
(
urls
!
=
=
undefined
&
&
!
urls
.
length
)
{
return
;
}
logConsole
.
debug
(
Testing
{
urls
?
urls
.
length
:
"
all
"
}
potential
snapshots
)
;
let
model
;
try
{
model
=
JSON
.
parse
(
snapshotCriteria
)
;
if
(
!
model
.
length
)
{
logConsole
.
debug
(
No
snapshot
criteria
provided
falling
back
to
default
)
;
model
=
DEFAULT_CRITERIA
;
}
}
catch
(
e
)
{
logConsole
.
error
(
"
Invalid
snapshot
criteria
falling
back
to
default
.
"
e
)
;
model
=
DEFAULT_CRITERIA
;
}
let
insertedUrls
=
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
updateSnapshots
"
async
db
=
>
{
let
bindings
=
{
}
;
let
urlFilter
=
"
"
;
if
(
urls
=
=
undefined
)
{
let
filters
=
[
]
;
for
(
let
protocol
of
InteractionsBlocklist
.
urlRequirements
.
keys
(
)
)
{
filters
.
push
(
(
url_hash
BETWEEN
hash
(
'
{
protocol
}
'
'
prefix_lo
'
)
AND
hash
(
'
{
protocol
}
'
'
prefix_hi
'
)
)
)
;
}
urlFilter
=
"
WHERE
"
+
filters
.
join
(
"
OR
"
)
;
}
else
{
let
urlMatches
=
[
]
;
urls
.
forEach
(
(
url
idx
)
=
>
{
if
(
!
InteractionsBlocklist
.
canRecordUrl
(
url
)
)
{
logConsole
.
debug
(
Url
can
'
t
be
added
to
snapshots
:
{
url
}
)
;
return
;
}
bindings
[
url
{
idx
}
]
=
url
;
urlMatches
.
push
(
(
url_hash
=
hash
(
:
url
{
idx
}
)
AND
url
=
:
url
{
idx
}
)
)
;
}
)
;
if
(
!
urlMatches
.
length
)
{
return
[
]
;
}
urlFilter
=
WHERE
{
urlMatches
.
join
(
"
OR
"
)
}
;
}
let
modelQueries
=
[
]
;
model
.
forEach
(
(
criteria
idx
)
=
>
{
let
wheres
=
[
]
;
if
(
criteria
.
interactionCount
)
{
wheres
.
push
(
row
<
=
:
count
{
idx
}
)
;
bindings
[
count
{
idx
}
]
=
criteria
.
interactionCount
;
}
if
(
criteria
.
interactionRecency
)
{
wheres
.
push
(
created_at
>
=
:
recency
{
idx
}
)
;
bindings
[
recency
{
idx
}
]
=
Date
.
now
(
)
-
criteria
.
interactionRecency
;
}
let
where
=
wheres
.
length
?
WHERE
{
wheres
.
join
(
"
AND
"
)
}
:
"
"
;
modelQueries
.
push
(
SELECT
place_id
min
(
created_at
)
AS
first_interaction_at
max
(
created_at
)
AS
last_interaction_at
doc_type
:
createdAt
FROM
metadata
{
where
}
GROUP
BY
place_id
HAVING
{
criteria
.
aggregator
}
(
{
criteria
.
property
}
)
>
=
:
cutoff
{
idx
}
)
;
bindings
[
cutoff
{
idx
}
]
=
criteria
.
cutoff
;
}
)
;
let
query
=
WITH
metadata
AS
(
SELECT
moz_places_metadata
.
*
row_number
(
)
OVER
(
PARTITION
BY
place_id
ORDER
BY
created_at
DESC
)
AS
row
first_value
(
document_type
)
OVER
(
PARTITION
BY
place_id
ORDER
BY
created_at
DESC
)
AS
doc_type
FROM
moz_places_metadata
JOIN
moz_places
h
ON
moz_places_metadata
.
place_id
=
h
.
id
{
urlFilter
}
)
INSERT
OR
IGNORE
INTO
moz_places_metadata_snapshots
(
place_id
first_interaction_at
last_interaction_at
document_type
created_at
)
{
modelQueries
.
join
(
"
UNION
"
)
}
RETURNING
place_id
(
SELECT
url
FROM
moz_places
WHERE
id
=
place_id
)
AS
url
created_at
;
let
now
=
Date
.
now
(
)
;
let
results
=
await
db
.
execute
(
query
{
.
.
.
bindings
createdAt
:
now
}
)
;
logConsole
.
debug
(
Inserted
{
results
.
length
}
snapshots
)
;
let
newUrls
=
[
]
;
for
(
let
row
of
results
)
{
if
(
row
.
getResultByName
(
"
created_at
"
)
=
=
now
)
{
newUrls
.
push
(
{
placeId
:
row
.
getResultByName
(
"
place_id
"
)
url
:
row
.
getResultByName
(
"
url
"
)
}
)
;
}
}
return
newUrls
;
}
)
;
if
(
insertedUrls
.
length
)
{
logConsole
.
debug
(
{
insertedUrls
.
length
}
snapshots
created
)
;
await
this
.
#
addPageData
(
insertedUrls
)
;
this
.
#
notify
(
"
places
-
snapshots
-
added
"
insertedUrls
.
map
(
result
=
>
{
return
{
url
:
result
.
url
userPersisted
:
this
.
USER_PERSISTED
.
NO
}
;
}
)
)
;
}
}
async
reset
(
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
Snapshots
.
jsm
:
:
reset
"
async
db
=
>
{
await
db
.
executeCached
(
DELETE
FROM
moz_places_metadata_snapshots
)
;
}
)
;
}
async
#
maybeInsertPlace
(
db
url
)
{
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
VALUES
(
:
url
hash
(
:
url
)
:
rev_host
1
-
1
IFNULL
(
(
SELECT
guid
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
)
{
url
:
url
.
href
rev_host
:
PlacesUtils
.
getReversedHost
(
url
)
}
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_updateoriginsinsert_temp
"
)
;
}
}
)
(
)
;
