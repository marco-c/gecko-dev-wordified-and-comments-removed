"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
RemoteNewTabUtils
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PageThumbs
"
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BinarySearch
"
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gPrincipal
"
function
(
)
{
let
uri
=
Services
.
io
.
newURI
(
"
about
:
newtab
"
null
null
)
;
return
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
uri
{
}
)
;
}
)
;
const
HISTORY_RESULTS_LIMIT
=
100
;
const
LINKS_GET_LINKS_LIMIT
=
100
;
let
PlacesProvider
=
{
_batchProcessingDepth
:
0
_batchCalledFrecencyChanged
:
false
maxNumLinks
:
HISTORY_RESULTS_LIMIT
init
:
function
PlacesProvider_init
(
)
{
PlacesUtils
.
history
.
addObserver
(
this
true
)
;
}
getLinks
:
function
PlacesProvider_getLinks
(
aCallback
)
{
let
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
maxResults
=
this
.
maxNumLinks
;
options
.
sortingMode
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_FRECENCY_DESCENDING
let
links
=
[
]
;
let
callback
=
{
handleResult
:
function
(
aResultSet
)
{
let
row
;
while
(
(
row
=
aResultSet
.
getNextRow
(
)
)
)
{
let
url
=
row
.
getResultByIndex
(
1
)
;
if
(
LinkChecker
.
checkLoadURI
(
url
)
)
{
let
title
=
row
.
getResultByIndex
(
2
)
;
let
frecency
=
row
.
getResultByIndex
(
12
)
;
let
lastVisitDate
=
row
.
getResultByIndex
(
5
)
;
links
.
push
(
{
url
:
url
title
:
title
frecency
:
frecency
lastVisitDate
:
lastVisitDate
type
:
"
history
"
}
)
;
}
}
}
handleError
:
function
(
aError
)
{
aCallback
(
[
]
)
;
}
handleCompletion
:
function
(
aReason
)
{
let
i
=
1
;
let
outOfOrder
=
[
]
;
while
(
i
<
links
.
length
)
{
if
(
Links
.
compareLinks
(
links
[
i
-
1
]
links
[
i
]
)
>
0
)
outOfOrder
.
push
(
links
.
splice
(
i
1
)
[
0
]
)
;
else
i
+
+
;
}
for
(
let
link
of
outOfOrder
)
{
i
=
BinarySearch
.
insertionIndexOf
(
Links
.
compareLinks
links
link
)
;
links
.
splice
(
i
0
link
)
;
}
aCallback
(
links
)
;
}
}
;
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
let
db
=
PlacesUtils
.
history
.
QueryInterface
(
Ci
.
nsPIPlacesDatabase
)
;
db
.
asyncExecuteLegacyQueries
(
[
query
]
1
options
callback
)
;
}
addObserver
:
function
PlacesProvider_addObserver
(
aObserver
)
{
this
.
_observers
.
push
(
aObserver
)
;
}
_observers
:
[
]
onBeginUpdateBatch
:
function
(
)
{
this
.
_batchProcessingDepth
+
=
1
;
}
onEndUpdateBatch
:
function
(
)
{
this
.
_batchProcessingDepth
-
=
1
;
if
(
this
.
_batchProcessingDepth
=
=
0
&
&
this
.
_batchCalledFrecencyChanged
)
{
this
.
onManyFrecenciesChanged
(
)
;
this
.
_batchCalledFrecencyChanged
=
false
;
}
}
onDeleteURI
:
function
PlacesProvider_onDeleteURI
(
aURI
aGUID
aReason
)
{
this
.
_callObservers
(
"
onDeleteURI
"
{
url
:
aURI
.
spec
}
)
;
}
onClearHistory
:
function
(
)
{
this
.
_callObservers
(
"
onClearHistory
"
)
}
onFrecencyChanged
:
function
PlacesProvider_onFrecencyChanged
(
aURI
aNewFrecency
aGUID
aHidden
aLastVisitDate
)
{
if
(
this
.
_batchProcessingDepth
>
0
)
{
this
.
_batchCalledFrecencyChanged
=
true
;
return
;
}
if
(
!
aHidden
&
&
aLastVisitDate
)
{
this
.
_callObservers
(
"
onLinkChanged
"
{
url
:
aURI
.
spec
frecency
:
aNewFrecency
lastVisitDate
:
aLastVisitDate
type
:
"
history
"
}
)
;
}
}
onManyFrecenciesChanged
:
function
PlacesProvider_onManyFrecenciesChanged
(
)
{
this
.
_callObservers
(
"
onManyLinksChanged
"
)
;
}
onTitleChanged
:
function
PlacesProvider_onTitleChanged
(
aURI
aNewTitle
aGUID
)
{
this
.
_callObservers
(
"
onLinkChanged
"
{
url
:
aURI
.
spec
title
:
aNewTitle
}
)
;
}
_callObservers
:
function
PlacesProvider__callObservers
(
aMethodName
aArg
)
{
for
(
let
obs
of
this
.
_observers
)
{
if
(
obs
[
aMethodName
]
)
{
try
{
obs
[
aMethodName
]
(
this
aArg
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsINavHistoryObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
let
Links
=
{
maxNumLinks
:
LINKS_GET_LINKS_LIMIT
_providers
:
new
Map
(
)
_sortProperties
:
[
"
frecency
"
"
lastVisitDate
"
"
url
"
]
_populateCallbacks
:
[
]
_observers
:
[
]
addObserver
:
function
(
aObserver
)
{
this
.
_observers
.
push
(
aObserver
)
;
}
addProvider
:
function
Links_addProvider
(
aProvider
)
{
this
.
_providers
.
set
(
aProvider
null
)
;
aProvider
.
addObserver
(
this
)
;
}
removeProvider
:
function
Links_removeProvider
(
aProvider
)
{
if
(
!
this
.
_providers
.
delete
(
aProvider
)
)
throw
new
Error
(
"
Unknown
provider
"
)
;
}
populateCache
:
function
Links_populateCache
(
aCallback
aForce
)
{
let
callbacks
=
this
.
_populateCallbacks
;
callbacks
.
push
(
aCallback
)
;
if
(
callbacks
.
length
>
1
)
return
;
function
executeCallbacks
(
)
{
while
(
callbacks
.
length
)
{
let
callback
=
callbacks
.
shift
(
)
;
if
(
callback
)
{
try
{
callback
(
)
;
}
catch
(
e
)
{
}
}
}
}
let
numProvidersRemaining
=
this
.
_providers
.
size
;
for
(
let
[
provider
links
]
of
this
.
_providers
)
{
this
.
_populateProviderCache
(
provider
(
)
=
>
{
if
(
-
-
numProvidersRemaining
=
=
0
)
executeCallbacks
(
)
;
}
aForce
)
;
}
}
getLinks
:
function
Links_getLinks
(
)
{
let
links
=
this
.
_getMergedProviderLinks
(
)
;
let
sites
=
new
Set
(
)
;
links
=
links
.
filter
(
function
(
link
)
{
let
site
=
RemoteNewTabUtils
.
extractSite
(
link
.
url
)
;
link
.
baseDomain
=
site
;
if
(
site
=
=
null
|
|
sites
.
has
(
site
)
)
return
false
;
sites
.
add
(
site
)
;
return
true
;
}
)
;
return
links
;
}
resetCache
:
function
Links_resetCache
(
)
{
for
(
let
provider
of
this
.
_providers
.
keys
(
)
)
{
this
.
_providers
.
set
(
provider
null
)
;
}
}
compareLinks
:
function
Links_compareLinks
(
aLink1
aLink2
)
{
for
(
let
prop
of
this
.
_sortProperties
)
{
if
(
!
(
prop
in
aLink1
)
|
|
!
(
prop
in
aLink2
)
)
throw
new
Error
(
"
Comparable
link
missing
required
property
:
"
+
prop
)
;
}
return
aLink2
.
frecency
-
aLink1
.
frecency
|
|
aLink2
.
lastVisitDate
-
aLink1
.
lastVisitDate
|
|
aLink1
.
url
.
localeCompare
(
aLink2
.
url
)
;
}
_incrementSiteMap
:
function
(
map
link
)
{
let
site
=
RemoteNewTabUtils
.
extractSite
(
link
.
url
)
;
map
.
set
(
site
(
map
.
get
(
site
)
|
|
0
)
+
1
)
;
}
_decrementSiteMap
:
function
(
map
link
)
{
let
site
=
RemoteNewTabUtils
.
extractSite
(
link
.
url
)
;
let
previousURLCount
=
map
.
get
(
site
)
;
if
(
previousURLCount
=
=
=
1
)
{
map
.
delete
(
site
)
;
}
else
{
map
.
set
(
site
previousURLCount
-
1
)
;
}
}
_adjustSiteMapAndNotify
:
function
(
aLink
increment
=
true
)
{
for
(
let
[
provider
cache
]
of
this
.
_providers
)
{
if
(
cache
.
linkMap
.
get
(
aLink
.
url
)
)
{
if
(
increment
)
{
this
.
_incrementSiteMap
(
cache
.
siteMap
aLink
)
;
continue
;
}
this
.
_decrementSiteMap
(
cache
.
siteMap
aLink
)
;
}
}
this
.
_callObservers
(
"
onLinkChanged
"
aLink
)
;
}
populateProviderCache
:
function
(
provider
callback
)
{
if
(
!
this
.
_providers
.
has
(
provider
)
)
{
throw
new
Error
(
"
Can
only
populate
provider
cache
for
existing
provider
.
"
)
;
}
return
this
.
_populateProviderCache
(
provider
callback
false
)
;
}
_populateProviderCache
:
function
(
aProvider
aCallback
aForce
)
{
let
cache
=
this
.
_providers
.
get
(
aProvider
)
;
let
createCache
=
!
cache
;
if
(
createCache
)
{
cache
=
{
populatePromise
:
new
Promise
(
resolve
=
>
resolve
(
)
)
}
;
this
.
_providers
.
set
(
aProvider
cache
)
;
}
cache
.
populatePromise
=
cache
.
populatePromise
.
then
(
(
)
=
>
{
return
new
Promise
(
resolve
=
>
{
if
(
!
createCache
&
&
!
aForce
)
{
aCallback
(
)
;
resolve
(
)
;
return
;
}
aProvider
.
getLinks
(
links
=
>
{
links
=
links
.
filter
(
(
link
)
=
>
!
!
link
)
;
cache
.
sortedLinks
=
links
;
cache
.
siteMap
=
links
.
reduce
(
(
map
link
)
=
>
{
this
.
_incrementSiteMap
(
map
link
)
;
return
map
;
}
new
Map
(
)
)
;
cache
.
linkMap
=
links
.
reduce
(
(
map
link
)
=
>
{
map
.
set
(
link
.
url
link
)
;
return
map
;
}
new
Map
(
)
)
;
aCallback
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
}
_getMergedProviderLinks
:
function
Links__getMergedProviderLinks
(
)
{
let
linkLists
=
[
]
;
for
(
let
provider
of
this
.
_providers
.
keys
(
)
)
{
let
links
=
this
.
_providers
.
get
(
provider
)
;
if
(
links
&
&
links
.
sortedLinks
)
{
linkLists
.
push
(
links
.
sortedLinks
.
slice
(
)
)
;
}
}
function
getNextLink
(
)
{
let
minLinks
=
null
;
for
(
let
links
of
linkLists
)
{
if
(
links
.
length
&
&
(
!
minLinks
|
|
Links
.
compareLinks
(
links
[
0
]
minLinks
[
0
]
)
<
0
)
)
minLinks
=
links
;
}
return
minLinks
?
minLinks
.
shift
(
)
:
null
;
}
let
finalLinks
=
[
]
;
for
(
let
nextLink
=
getNextLink
(
)
;
nextLink
&
&
finalLinks
.
length
<
this
.
maxNumLinks
;
nextLink
=
getNextLink
(
)
)
{
finalLinks
.
push
(
nextLink
)
;
}
return
finalLinks
;
}
onLinkChanged
:
function
Links_onLinkChanged
(
aProvider
aLink
aIndex
=
-
1
aDeleted
=
false
)
{
if
(
!
(
"
url
"
in
aLink
)
)
throw
new
Error
(
"
Changed
links
must
have
a
url
property
"
)
;
let
links
=
this
.
_providers
.
get
(
aProvider
)
;
if
(
!
links
)
return
;
let
{
sortedLinks
siteMap
linkMap
}
=
links
;
let
existingLink
=
linkMap
.
get
(
aLink
.
url
)
;
let
insertionLink
=
null
;
if
(
existingLink
)
{
if
(
this
.
_sortProperties
.
some
(
prop
=
>
prop
in
aLink
)
)
{
let
idx
=
aIndex
;
if
(
idx
<
0
)
{
idx
=
this
.
_indexOf
(
sortedLinks
existingLink
)
;
}
else
if
(
this
.
compareLinks
(
aLink
sortedLinks
[
idx
]
)
!
=
0
)
{
throw
new
Error
(
"
aLink
should
be
the
same
as
sortedLinks
[
idx
]
"
)
;
}
if
(
idx
<
0
)
{
throw
new
Error
(
"
Link
should
be
in
_sortedLinks
if
in
_linkMap
"
)
;
}
sortedLinks
.
splice
(
idx
1
)
;
if
(
aDeleted
)
{
linkMap
.
delete
(
existingLink
.
url
)
;
this
.
_decrementSiteMap
(
siteMap
existingLink
)
;
}
else
{
Object
.
assign
(
existingLink
aLink
)
;
insertionLink
=
existingLink
;
}
}
if
(
"
title
"
in
aLink
&
&
aLink
.
title
!
=
existingLink
.
title
)
{
existingLink
.
title
=
aLink
.
title
;
}
}
else
if
(
this
.
_sortProperties
.
every
(
prop
=
>
prop
in
aLink
)
)
{
if
(
sortedLinks
.
length
&
&
sortedLinks
.
length
=
=
aProvider
.
maxNumLinks
)
{
let
lastLink
=
sortedLinks
[
sortedLinks
.
length
-
1
]
;
if
(
this
.
compareLinks
(
lastLink
aLink
)
<
0
)
{
return
;
}
}
insertionLink
=
{
}
;
for
(
let
prop
in
aLink
)
{
insertionLink
[
prop
]
=
aLink
[
prop
]
;
}
linkMap
.
set
(
aLink
.
url
insertionLink
)
;
this
.
_incrementSiteMap
(
siteMap
aLink
)
;
}
if
(
insertionLink
)
{
let
idx
=
this
.
_insertionIndexOf
(
sortedLinks
insertionLink
)
;
sortedLinks
.
splice
(
idx
0
insertionLink
)
;
if
(
sortedLinks
.
length
>
aProvider
.
maxNumLinks
)
{
let
lastLink
=
sortedLinks
.
pop
(
)
;
linkMap
.
delete
(
lastLink
.
url
)
;
this
.
_decrementSiteMap
(
siteMap
lastLink
)
;
}
}
}
onManyLinksChanged
:
function
Links_onManyLinksChanged
(
aProvider
)
{
this
.
_populateProviderCache
(
aProvider
(
)
=
>
{
}
true
)
;
}
_indexOf
:
function
Links__indexOf
(
aArray
aLink
)
{
return
this
.
_binsearch
(
aArray
aLink
"
indexOf
"
)
;
}
_insertionIndexOf
:
function
Links__insertionIndexOf
(
aArray
aLink
)
{
return
this
.
_binsearch
(
aArray
aLink
"
insertionIndexOf
"
)
;
}
_binsearch
:
function
Links__binsearch
(
aArray
aLink
aMethod
)
{
return
BinarySearch
[
aMethod
]
(
this
.
compareLinks
aArray
aLink
)
;
}
_callObservers
(
methodName
.
.
.
args
)
{
for
(
let
obs
of
this
.
_observers
)
{
if
(
typeof
(
obs
[
methodName
]
)
=
=
"
function
"
)
{
try
{
obs
[
methodName
]
(
this
.
.
.
args
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
}
;
Links
.
compareLinks
=
Links
.
compareLinks
.
bind
(
Links
)
;
let
LinkChecker
=
{
_cache
:
{
}
get
flags
(
)
{
return
Ci
.
nsIScriptSecurityManager
.
DISALLOW_INHERIT_PRINCIPAL
|
Ci
.
nsIScriptSecurityManager
.
DONT_REPORT_ERRORS
;
}
checkLoadURI
:
function
LinkChecker_checkLoadURI
(
aURI
)
{
if
(
!
(
aURI
in
this
.
_cache
)
)
this
.
_cache
[
aURI
]
=
this
.
_doCheckLoadURI
(
aURI
)
;
return
this
.
_cache
[
aURI
]
;
}
_doCheckLoadURI
:
function
Links_doCheckLoadURI
(
aURI
)
{
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
gPrincipal
aURI
this
.
flags
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
}
;
let
ExpirationFilter
=
{
init
:
function
ExpirationFilter_init
(
)
{
PageThumbs
.
addExpirationFilter
(
this
)
;
}
filterForThumbnailExpiration
:
function
ExpirationFilter_filterForThumbnailExpiration
(
aCallback
)
{
Links
.
populateCache
(
function
(
)
{
let
urls
=
[
]
;
for
(
let
link
of
Links
.
getLinks
(
)
.
slice
(
0
25
)
)
{
if
(
link
&
&
link
.
url
)
urls
.
push
(
link
.
url
)
;
}
aCallback
(
urls
)
;
}
)
;
}
}
;
this
.
RemoteNewTabUtils
=
{
_initialized
:
false
extractSite
:
function
Links_extractSite
(
url
)
{
let
host
;
try
{
host
=
Services
.
io
.
newURI
(
url
null
null
)
.
asciiHost
;
}
catch
(
ex
)
{
return
null
;
}
return
host
.
replace
(
/
^
(
m
|
mobile
|
www
\
d
*
)
\
.
/
"
"
)
;
}
init
:
function
RemoteNewTabUtils_init
(
)
{
if
(
this
.
initWithoutProviders
(
)
)
{
PlacesProvider
.
init
(
)
;
Links
.
addProvider
(
PlacesProvider
)
;
}
}
initWithoutProviders
:
function
RemoteNewTabUtils_initWithoutProviders
(
)
{
if
(
!
this
.
_initialized
)
{
this
.
_initialized
=
true
;
ExpirationFilter
.
init
(
)
;
return
true
;
}
return
false
;
}
getProviderLinks
:
function
(
aProvider
)
{
let
cache
=
Links
.
_providers
.
get
(
aProvider
)
;
if
(
cache
&
&
cache
.
sortedLinks
)
{
return
cache
.
sortedLinks
;
}
return
[
]
;
}
isTopSiteGivenProvider
:
function
(
aSite
aProvider
)
{
let
cache
=
Links
.
_providers
.
get
(
aProvider
)
;
if
(
cache
&
&
cache
.
siteMap
)
{
return
cache
.
siteMap
.
has
(
aSite
)
;
}
return
false
;
}
isTopPlacesSite
:
function
(
aSite
)
{
return
this
.
isTopSiteGivenProvider
(
aSite
PlacesProvider
)
;
}
links
:
Links
linkChecker
:
LinkChecker
placesProvider
:
PlacesProvider
}
;
