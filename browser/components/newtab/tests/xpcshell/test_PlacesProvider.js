"
use
strict
"
;
const
{
utils
:
Cu
interfaces
:
Ci
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesProvider
"
"
resource
:
/
/
/
modules
/
PlacesProvider
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesTestUtils
"
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
do_get_profile
(
)
;
function
run_test
(
)
{
run_next_test
(
)
;
}
const
TEST_URL
=
"
https
:
/
/
mozilla
.
com
/
"
;
const
TIME_NOW
=
(
new
Date
(
)
)
.
getTime
(
)
;
function
timeDaysAgo
(
numDays
)
{
return
TIME_NOW
-
(
numDays
*
24
*
60
*
60
*
1000
)
;
}
function
makeVisit
(
index
daysAgo
isTyped
domain
=
TEST_URL
)
{
let
{
TRANSITION_TYPED
TRANSITION_LINK
}
=
PlacesUtils
.
history
;
return
{
uri
:
NetUtil
.
newURI
(
{
domain
}
{
index
}
)
visitDate
:
timeDaysAgo
(
daysAgo
)
transition
:
(
isTyped
)
?
TRANSITION_TYPED
:
TRANSITION_LINK
}
;
}
add_task
(
function
test_LinkChecker_securityCheck
(
)
{
let
urls
=
[
{
url
:
"
file
:
/
/
home
/
file
/
image
.
png
"
expected
:
false
}
{
url
:
"
resource
:
/
/
/
modules
/
PlacesProvider
.
jsm
"
expected
:
false
}
{
url
:
"
javascript
:
alert
(
'
hello
'
)
"
expected
:
false
}
{
url
:
"
data
:
image
/
png
;
base64
XXX
"
expected
:
false
}
{
url
:
"
about
:
newtab
"
expected
:
true
}
{
url
:
"
https
:
/
/
example
.
com
"
expected
:
true
}
{
url
:
"
ftp
:
/
/
example
.
com
"
expected
:
true
}
]
;
for
(
let
{
url
expected
}
of
urls
)
{
let
observed
=
PlacesProvider
.
LinkChecker
.
checkLoadURI
(
url
)
;
equal
(
observed
expected
can
load
"
{
url
}
"
?
)
;
}
}
)
;
add_task
(
function
*
test_Links_getLinks
(
)
{
yield
PlacesTestUtils
.
clearHistory
(
)
;
let
provider
=
PlacesProvider
.
links
;
let
links
=
yield
provider
.
getLinks
(
)
;
equal
(
links
.
length
0
"
empty
history
yields
empty
links
"
)
;
let
testURI
=
NetUtil
.
newURI
(
"
http
:
/
/
mozilla
.
com
"
)
;
yield
PlacesTestUtils
.
addVisits
(
testURI
)
;
links
=
yield
provider
.
getLinks
(
)
;
equal
(
links
.
length
1
"
adding
a
visit
yields
a
link
"
)
;
equal
(
links
[
0
]
.
url
testURI
.
spec
"
added
visit
corresponds
to
added
url
"
)
;
}
)
;
add_task
(
function
*
test_Links_getLinks_Order
(
)
{
yield
PlacesTestUtils
.
clearHistory
(
)
;
let
provider
=
PlacesProvider
.
links
;
let
visits
=
[
makeVisit
(
0
0
true
"
http
:
/
/
bar
.
com
/
"
)
makeVisit
(
1
0
true
"
http
:
/
/
foo
.
com
/
"
)
makeVisit
(
2
2
true
"
http
:
/
/
buz
.
com
/
"
)
makeVisit
(
3
2
false
"
http
:
/
/
aaa
.
com
/
"
)
]
;
let
links
=
yield
provider
.
getLinks
(
)
;
equal
(
links
.
length
0
"
empty
history
yields
empty
links
"
)
;
yield
PlacesTestUtils
.
addVisits
(
visits
)
;
links
=
yield
provider
.
getLinks
(
)
;
equal
(
links
.
length
visits
.
length
"
number
of
links
added
is
the
same
as
obtain
by
getLinks
"
)
;
for
(
let
i
=
0
;
i
<
links
.
length
;
i
+
+
)
{
equal
(
links
[
i
]
.
url
visits
[
i
]
.
uri
.
spec
"
links
are
obtained
in
the
expected
order
"
)
;
}
}
)
;
add_task
(
function
*
test_Links_getLinks_Deduplication
(
)
{
yield
PlacesTestUtils
.
clearHistory
(
)
;
let
provider
=
PlacesProvider
.
links
;
let
visits
=
[
makeVisit
(
0
2
true
"
http
:
/
/
bar
.
com
/
"
)
makeVisit
(
1
0
true
"
http
:
/
/
bar
.
com
/
"
)
makeVisit
(
2
0
false
"
http
:
/
/
foo
.
com
/
"
)
makeVisit
(
3
0
true
"
http
:
/
/
foo
.
com
/
"
)
]
;
let
links
=
yield
provider
.
getLinks
(
)
;
equal
(
links
.
length
0
"
empty
history
yields
empty
links
"
)
;
yield
PlacesTestUtils
.
addVisits
(
visits
)
;
links
=
yield
provider
.
getLinks
(
)
;
equal
(
links
.
length
2
"
only
two
links
must
be
left
after
deduplication
"
)
;
equal
(
links
[
0
]
.
url
visits
[
1
]
.
uri
.
spec
"
earliest
link
is
present
"
)
;
equal
(
links
[
1
]
.
url
visits
[
3
]
.
uri
.
spec
"
most
fresent
link
is
present
"
)
;
}
)
;
add_task
(
function
*
test_Links_onLinkChanged
(
)
{
let
provider
=
PlacesProvider
.
links
;
provider
.
init
(
)
;
let
url
=
"
https
:
/
/
example
.
com
/
onFrecencyChanged1
"
;
let
linkChangedMsgCount
=
0
;
let
linkChangedPromise
=
new
Promise
(
resolve
=
>
{
let
handler
=
(
_
link
)
=
>
{
if
(
link
.
url
=
=
=
url
)
{
equal
(
link
.
url
url
expected
url
on
linkChanged
event
)
;
linkChangedMsgCount
+
=
1
;
if
(
linkChangedMsgCount
=
=
=
3
)
{
ok
(
true
all
linkChanged
events
captured
)
;
provider
.
off
(
"
linkChanged
"
this
)
;
resolve
(
)
;
}
}
}
;
provider
.
on
(
"
linkChanged
"
handler
)
;
}
)
;
let
testURI
=
NetUtil
.
newURI
(
url
)
;
yield
PlacesTestUtils
.
addVisits
(
testURI
)
;
yield
linkChangedPromise
;
yield
PlacesTestUtils
.
clearHistory
(
)
;
provider
.
destroy
(
)
;
}
)
;
add_task
(
function
*
test_Links_onClearHistory
(
)
{
let
provider
=
PlacesProvider
.
links
;
provider
.
init
(
)
;
let
clearHistoryPromise
=
new
Promise
(
resolve
=
>
{
let
handler
=
(
)
=
>
{
ok
(
true
clearHistory
event
captured
)
;
provider
.
off
(
"
clearHistory
"
handler
)
;
resolve
(
)
;
}
;
provider
.
on
(
"
clearHistory
"
handler
)
;
}
)
;
for
(
let
i
=
0
;
i
<
=
10
;
i
+
+
)
{
let
url
=
https
:
/
/
example
.
com
/
onClearHistory
{
i
}
;
let
testURI
=
NetUtil
.
newURI
(
url
)
;
yield
PlacesTestUtils
.
addVisits
(
testURI
)
;
}
yield
PlacesTestUtils
.
clearHistory
(
)
;
yield
clearHistoryPromise
;
provider
.
destroy
(
)
;
}
)
;
add_task
(
function
*
test_Links_onDeleteURI
(
)
{
let
provider
=
PlacesProvider
.
links
;
provider
.
init
(
)
;
let
testURL
=
"
https
:
/
/
example
.
com
/
toDelete
"
;
let
deleteURIPromise
=
new
Promise
(
resolve
=
>
{
let
handler
=
(
_
{
url
}
)
=
>
{
equal
(
testURL
url
"
deleted
url
and
expected
url
are
the
same
"
)
;
provider
.
off
(
"
deleteURI
"
handler
)
;
resolve
(
)
;
}
;
provider
.
on
(
"
deleteURI
"
handler
)
;
}
)
;
let
testURI
=
NetUtil
.
newURI
(
testURL
)
;
yield
PlacesTestUtils
.
addVisits
(
testURI
)
;
yield
PlacesUtils
.
history
.
remove
(
testURL
)
;
yield
deleteURIPromise
;
provider
.
destroy
(
)
;
}
)
;
add_task
(
function
*
test_Links_onManyLinksChanged
(
)
{
let
provider
=
PlacesProvider
.
links
;
provider
.
init
(
)
;
let
promise
=
new
Promise
(
resolve
=
>
{
let
handler
=
(
)
=
>
{
ok
(
true
)
;
provider
.
off
(
"
manyLinksChanged
"
handler
)
;
resolve
(
)
;
}
;
provider
.
on
(
"
manyLinksChanged
"
handler
)
;
}
)
;
let
testURL
=
"
https
:
/
/
example
.
com
/
toDelete
"
;
let
testURI
=
NetUtil
.
newURI
(
testURL
)
;
yield
PlacesTestUtils
.
addVisits
(
testURI
)
;
PlacesUtils
.
history
.
QueryInterface
(
Ci
.
nsIObserver
)
.
observe
(
null
"
idle
-
daily
"
"
"
)
;
yield
promise
;
provider
.
destroy
(
)
;
}
)
;
add_task
(
function
*
test_Links_execute_query
(
)
{
yield
PlacesTestUtils
.
clearHistory
(
)
;
let
provider
=
PlacesProvider
.
links
;
let
visits
=
[
makeVisit
(
0
0
true
)
makeVisit
(
1
0
true
)
makeVisit
(
2
2
true
)
makeVisit
(
3
2
false
)
]
;
yield
PlacesTestUtils
.
addVisits
(
visits
)
;
function
testItemValue
(
results
index
value
)
{
equal
(
results
[
index
]
[
0
]
{
TEST_URL
}
{
value
}
"
raw
url
"
)
;
equal
(
results
[
index
]
[
1
]
test
visit
for
{
TEST_URL
}
{
value
}
"
raw
title
"
)
;
}
function
testItemObject
(
results
index
columnValues
)
{
Object
.
keys
(
columnValues
)
.
forEach
(
name
=
>
{
equal
(
results
[
index
]
[
name
]
columnValues
[
name
]
"
object
name
"
+
name
)
;
}
)
;
}
let
results
=
yield
provider
.
executePlacesQuery
(
"
select
url
title
from
moz_places
"
)
;
equal
(
results
.
length
4
"
expect
4
items
"
)
;
for
(
let
i
=
0
;
i
<
results
.
length
;
i
+
+
)
{
testItemValue
(
results
i
i
)
;
}
results
=
yield
provider
.
executePlacesQuery
(
"
select
url
title
from
moz_places
limit
:
limit
"
{
params
:
{
limit
:
2
}
}
)
;
equal
(
results
.
length
2
"
expect
2
items
"
)
;
for
(
let
i
=
0
;
i
<
results
.
length
;
i
+
+
)
{
testItemValue
(
results
i
i
)
;
}
results
=
yield
provider
.
executePlacesQuery
(
"
select
url
title
from
moz_places
limit
:
limit
"
{
columns
:
[
"
url
"
"
title
"
]
params
:
{
limit
:
4
}
}
)
;
equal
(
results
.
length
4
"
expect
4
items
"
)
;
for
(
let
i
=
0
;
i
<
results
.
length
;
i
+
+
)
{
testItemObject
(
results
i
{
"
url
"
:
{
TEST_URL
}
{
i
}
"
title
"
:
test
visit
for
{
TEST_URL
}
{
i
}
}
)
;
}
results
=
yield
provider
.
executePlacesQuery
(
"
select
url
title
last_visit_date
frecency
from
moz_places
"
+
"
order
by
frecency
DESC
last_visit_date
DESC
url
DESC
limit
:
limit
"
{
columns
:
[
"
url
"
"
title
"
"
last_visit_date
"
"
frecency
"
]
params
:
{
limit
:
4
}
}
)
;
equal
(
results
.
length
4
"
expect
4
items
"
)
;
testItemObject
(
results
0
{
url
:
{
TEST_URL
}
1
}
)
;
testItemObject
(
results
1
{
url
:
{
TEST_URL
}
0
}
)
;
testItemObject
(
results
2
{
url
:
{
TEST_URL
}
2
}
)
;
testItemObject
(
results
3
{
url
:
{
TEST_URL
}
3
}
)
;
results
=
[
]
;
function
handleRow
(
aRow
)
{
results
.
push
(
{
url
:
aRow
.
getResultByName
(
"
url
"
)
title
:
aRow
.
getResultByName
(
"
title
"
)
last_visit_date
:
aRow
.
getResultByName
(
"
last_visit_date
"
)
frecency
:
aRow
.
getResultByName
(
"
frecency
"
)
}
)
;
}
yield
provider
.
executePlacesQuery
(
"
select
url
title
last_visit_date
frecency
from
moz_places
"
+
"
order
by
frecency
DESC
last_visit_date
DESC
url
DESC
"
{
callback
:
handleRow
}
)
;
equal
(
results
.
length
4
"
expect
4
items
"
)
;
testItemObject
(
results
0
{
url
:
{
TEST_URL
}
1
}
)
;
testItemObject
(
results
1
{
url
:
{
TEST_URL
}
0
}
)
;
testItemObject
(
results
2
{
url
:
{
TEST_URL
}
2
}
)
;
testItemObject
(
results
3
{
url
:
{
TEST_URL
}
3
}
)
;
try
{
yield
provider
.
executePlacesQuery
(
"
select
from
moz
"
)
;
do_throw
(
"
bad
sql
should
'
ve
thrown
"
)
;
}
catch
(
e
)
{
do_check_true
(
"
expected
failure
-
bad
sql
"
)
;
}
try
{
yield
provider
.
executePlacesQuery
(
"
select
*
from
moz_places
limit
:
limit
"
)
;
do_throw
(
"
bad
sql
should
'
ve
thrown
"
)
;
}
catch
(
e
)
{
do_check_true
(
"
expected
failure
-
missing
bidning
"
)
;
}
try
{
yield
provider
.
executePlacesQuery
(
"
select
*
from
moz_places
limit
:
limit
"
{
columns
:
[
"
no
-
such
-
column
"
]
params
:
{
limit
:
4
}
}
)
;
do_throw
(
"
bad
sql
should
'
ve
thrown
"
)
;
}
catch
(
e
)
{
do_check_true
(
"
expected
failure
-
wrong
column
name
"
)
;
}
yield
PlacesTestUtils
.
clearHistory
(
)
;
}
)
;
