export
const
selectLayoutRender
=
(
state
prefs
rickRollCache
)
=
>
{
const
{
layout
feeds
spocs
}
=
state
;
let
spocIndex
=
0
;
let
bufferRollCache
=
[
]
;
let
chosenSpocs
=
new
Set
(
)
;
let
unchosenSpocs
=
new
Set
(
)
;
const
isFirstRun
=
!
rickRollCache
.
length
;
function
maybeInjectSpocs
(
data
spocsConfig
)
{
if
(
data
&
&
spocsConfig
&
&
spocsConfig
.
positions
&
&
spocsConfig
.
positions
.
length
&
&
spocs
.
data
.
spocs
&
&
spocs
.
data
.
spocs
.
length
)
{
const
recommendations
=
[
.
.
.
data
.
recommendations
]
;
for
(
let
position
of
spocsConfig
.
positions
)
{
const
spoc
=
spocs
.
data
.
spocs
[
spocIndex
]
;
if
(
!
spoc
)
{
break
;
}
let
rickRoll
;
if
(
isFirstRun
)
{
rickRoll
=
Math
.
random
(
)
;
rickRollCache
.
push
(
rickRoll
)
;
}
else
{
rickRoll
=
rickRollCache
.
shift
(
)
;
bufferRollCache
.
push
(
rickRoll
)
;
}
if
(
rickRoll
<
=
spocsConfig
.
probability
)
{
spocIndex
+
+
;
recommendations
.
splice
(
position
.
index
0
spoc
)
;
chosenSpocs
.
add
(
spoc
)
;
}
else
{
unchosenSpocs
.
add
(
spoc
)
;
}
}
return
{
.
.
.
data
recommendations
}
;
}
return
data
;
}
const
positions
=
{
}
;
const
DS_COMPONENTS
=
[
"
Message
"
"
SectionTitle
"
"
Navigation
"
"
CardGrid
"
"
Hero
"
"
HorizontalRule
"
"
List
"
]
;
const
filterArray
=
[
]
;
if
(
!
prefs
[
"
feeds
.
topsites
"
]
)
{
filterArray
.
push
(
"
TopSites
"
)
;
}
if
(
!
prefs
[
"
feeds
.
section
.
topstories
"
]
)
{
filterArray
.
push
(
.
.
.
DS_COMPONENTS
)
;
}
const
layoutRender
=
layout
.
map
(
row
=
>
(
{
.
.
.
row
components
:
row
.
components
.
filter
(
c
=
>
!
filterArray
.
includes
(
c
.
type
)
)
.
map
(
component
=
>
{
if
(
!
component
.
feed
|
|
!
feeds
.
data
[
component
.
feed
.
url
]
)
{
return
component
;
}
positions
[
component
.
type
]
=
positions
[
component
.
type
]
|
|
0
;
let
{
data
}
=
feeds
.
data
[
component
.
feed
.
url
]
;
if
(
component
&
&
component
.
properties
&
&
component
.
properties
.
offset
)
{
data
=
{
.
.
.
data
recommendations
:
data
.
recommendations
.
slice
(
component
.
properties
.
offset
)
}
;
}
data
=
maybeInjectSpocs
(
data
component
.
spocs
)
;
if
(
!
rickRollCache
.
length
)
{
rickRollCache
.
push
(
.
.
.
bufferRollCache
)
;
}
let
items
=
0
;
if
(
component
.
properties
&
&
component
.
properties
.
items
)
{
items
=
Math
.
min
(
component
.
properties
.
items
data
.
recommendations
.
length
)
;
}
for
(
let
i
=
0
;
i
<
items
;
i
+
+
)
{
data
.
recommendations
[
i
]
.
pos
=
positions
[
component
.
type
]
+
+
;
}
return
{
.
.
.
component
data
}
;
}
)
}
)
)
.
filter
(
row
=
>
row
.
components
.
length
)
;
let
spocsFill
=
[
]
;
if
(
spocs
.
data
&
&
spocs
.
data
.
spocs
)
{
const
chosenSpocsFill
=
[
.
.
.
chosenSpocs
]
.
map
(
spoc
=
>
(
{
id
:
spoc
.
id
reason
:
"
n
/
a
"
displayed
:
1
full_recalc
:
0
}
)
)
;
const
unchosenSpocsFill
=
[
.
.
.
unchosenSpocs
]
.
filter
(
spoc
=
>
!
chosenSpocs
.
has
(
spoc
)
)
.
map
(
spoc
=
>
(
{
id
:
spoc
.
id
reason
:
"
probability_selection
"
displayed
:
0
full_recalc
:
0
}
)
)
;
const
outOfPositionSpocsFill
=
spocs
.
data
.
spocs
.
slice
(
spocIndex
)
.
filter
(
spoc
=
>
!
unchosenSpocs
.
has
(
spoc
)
)
.
map
(
spoc
=
>
(
{
id
:
spoc
.
id
reason
:
"
out_of_position
"
displayed
:
0
full_recalc
:
0
}
)
)
;
spocsFill
=
[
.
.
.
chosenSpocsFill
.
.
.
unchosenSpocsFill
.
.
.
outOfPositionSpocsFill
]
;
}
return
{
spocsFill
layoutRender
}
;
}
;
