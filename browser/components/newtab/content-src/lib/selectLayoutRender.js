export
const
selectLayoutRender
=
(
{
state
=
{
}
prefs
=
{
}
locale
=
"
"
}
)
=
>
{
const
{
layout
feeds
spocs
}
=
state
;
let
spocIndexPlacementMap
=
{
}
;
function
fillSpocPositionsForPlacement
(
data
spocsConfig
spocsData
placementName
)
{
if
(
!
spocIndexPlacementMap
[
placementName
]
&
&
spocIndexPlacementMap
[
placementName
]
!
=
=
0
)
{
spocIndexPlacementMap
[
placementName
]
=
0
;
}
const
results
=
[
.
.
.
data
]
;
for
(
let
position
of
spocsConfig
.
positions
)
{
const
spoc
=
spocsData
[
spocIndexPlacementMap
[
placementName
]
]
;
if
(
!
spoc
)
{
break
;
}
spocIndexPlacementMap
[
placementName
]
+
+
;
if
(
!
spocs
.
blocked
.
includes
(
spoc
.
url
)
)
{
results
.
splice
(
position
.
index
0
spoc
)
;
}
}
return
results
;
}
const
positions
=
{
}
;
const
DS_COMPONENTS
=
[
"
Message
"
"
TextPromo
"
"
SectionTitle
"
"
Signup
"
"
Navigation
"
"
CardGrid
"
"
CollectionCardGrid
"
"
Hero
"
"
HorizontalRule
"
"
List
"
"
PrivacyLink
"
]
;
const
filterArray
=
[
]
;
if
(
!
prefs
[
"
feeds
.
topsites
"
]
)
{
filterArray
.
push
(
"
TopSites
"
)
;
}
const
pocketEnabled
=
prefs
[
"
feeds
.
section
.
topstories
"
]
&
&
prefs
[
"
feeds
.
system
.
topstories
"
]
;
if
(
!
pocketEnabled
)
{
filterArray
.
push
(
.
.
.
DS_COMPONENTS
)
;
}
const
placeholderComponent
=
component
=
>
{
if
(
!
component
.
feed
)
{
return
{
.
.
.
component
data
:
{
spocs
:
[
]
}
}
;
}
const
data
=
{
recommendations
:
[
]
}
;
let
items
=
0
;
if
(
component
.
properties
&
&
component
.
properties
.
items
)
{
items
=
component
.
properties
.
items
;
}
for
(
let
i
=
0
;
i
<
items
;
i
+
+
)
{
data
.
recommendations
.
push
(
{
placeholder
:
true
}
)
;
}
return
{
.
.
.
component
data
}
;
}
;
const
handleSpocs
=
(
data
component
)
=
>
{
let
result
=
[
.
.
.
data
]
;
if
(
component
.
spocs
&
&
component
.
spocs
.
positions
&
&
component
.
spocs
.
positions
.
length
)
{
const
placement
=
component
.
placement
|
|
{
}
;
const
placementName
=
placement
.
name
|
|
"
spocs
"
;
const
spocsData
=
spocs
.
data
[
placementName
]
;
if
(
spocs
.
loaded
&
&
spocsData
&
&
spocsData
.
items
&
&
spocsData
.
items
.
length
)
{
result
=
fillSpocPositionsForPlacement
(
result
component
.
spocs
spocsData
.
items
placementName
)
;
}
}
return
result
;
}
;
const
handleComponent
=
component
=
>
{
if
(
component
.
spocs
&
&
component
.
spocs
.
positions
&
&
component
.
spocs
.
positions
.
length
)
{
const
placement
=
component
.
placement
|
|
{
}
;
const
placementName
=
placement
.
name
|
|
"
spocs
"
;
const
spocsData
=
spocs
.
data
[
placementName
]
;
if
(
spocs
.
loaded
&
&
spocsData
&
&
spocsData
.
items
&
&
spocsData
.
items
.
length
)
{
return
{
.
.
.
component
data
:
{
spocs
:
spocsData
.
items
.
filter
(
spoc
=
>
spoc
&
&
!
spocs
.
blocked
.
includes
(
spoc
.
url
)
)
.
map
(
(
spoc
index
)
=
>
(
{
.
.
.
spoc
pos
:
index
}
)
)
}
}
;
}
}
return
{
.
.
.
component
data
:
{
spocs
:
[
]
}
}
;
}
;
const
handleComponentWithFeed
=
component
=
>
{
positions
[
component
.
type
]
=
positions
[
component
.
type
]
|
|
0
;
let
data
=
{
recommendations
:
[
]
}
;
const
feed
=
feeds
.
data
[
component
.
feed
.
url
]
;
if
(
feed
&
&
feed
.
data
)
{
data
=
{
.
.
.
feed
.
data
recommendations
:
[
.
.
.
(
feed
.
data
.
recommendations
|
|
[
]
)
]
}
;
}
if
(
component
&
&
component
.
properties
&
&
component
.
properties
.
offset
)
{
data
=
{
.
.
.
data
recommendations
:
data
.
recommendations
.
slice
(
component
.
properties
.
offset
)
}
;
}
data
=
{
.
.
.
data
recommendations
:
handleSpocs
(
data
.
recommendations
component
)
}
;
let
items
=
0
;
if
(
component
.
properties
&
&
component
.
properties
.
items
)
{
items
=
Math
.
min
(
component
.
properties
.
items
data
.
recommendations
.
length
)
;
}
for
(
let
i
=
0
;
i
<
items
;
i
+
+
)
{
data
.
recommendations
[
i
]
=
{
.
.
.
data
.
recommendations
[
i
]
pos
:
positions
[
component
.
type
]
+
+
}
;
}
return
{
.
.
.
component
data
}
;
}
;
const
renderLayout
=
(
)
=
>
{
const
renderedLayoutArray
=
[
]
;
for
(
const
row
of
layout
.
filter
(
r
=
>
r
.
components
.
filter
(
c
=
>
!
filterArray
.
includes
(
c
.
type
)
)
.
length
)
)
{
let
components
=
[
]
;
renderedLayoutArray
.
push
(
{
.
.
.
row
components
}
)
;
for
(
const
component
of
row
.
components
.
filter
(
c
=
>
!
filterArray
.
includes
(
c
.
type
)
)
)
{
const
spocsConfig
=
component
.
spocs
;
if
(
spocsConfig
|
|
component
.
feed
)
{
if
(
(
component
.
feed
&
&
!
feeds
.
data
[
component
.
feed
.
url
]
)
|
|
(
spocsConfig
&
&
spocsConfig
.
positions
&
&
spocsConfig
.
positions
.
length
&
&
!
spocs
.
loaded
)
)
{
components
.
push
(
placeholderComponent
(
component
)
)
;
return
renderedLayoutArray
;
}
if
(
component
.
feed
)
{
components
.
push
(
handleComponentWithFeed
(
component
)
)
;
}
else
{
components
.
push
(
handleComponent
(
component
)
)
;
}
}
else
{
components
.
push
(
component
)
;
}
}
}
return
renderedLayoutArray
;
}
;
const
layoutRender
=
renderLayout
(
)
;
return
{
layoutRender
}
;
}
;
