export
class
GlobalOverrider
{
constructor
(
)
{
this
.
originalGlobals
=
new
Map
(
)
;
this
.
sandbox
=
sinon
.
createSandbox
(
)
;
}
_override
(
key
value
)
{
if
(
!
this
.
originalGlobals
.
has
(
key
)
)
{
this
.
originalGlobals
.
set
(
key
global
[
key
]
)
;
}
global
[
key
]
=
value
;
}
set
(
key
value
)
{
if
(
!
value
&
&
typeof
key
=
=
=
"
object
"
)
{
const
overrides
=
key
;
Object
.
keys
(
overrides
)
.
forEach
(
k
=
>
this
.
_override
(
k
overrides
[
k
]
)
)
;
}
else
{
this
.
_override
(
key
value
)
;
}
return
value
;
}
reset
(
)
{
this
.
sandbox
.
reset
(
)
;
}
restore
(
)
{
this
.
sandbox
.
restore
(
)
;
this
.
originalGlobals
.
forEach
(
(
value
key
)
=
>
{
global
[
key
]
=
value
;
}
)
;
}
}
export
const
FAKE_GLOBAL_PREFS
=
new
Map
(
)
;
export
class
FakensIPrefBranch
{
PREF_INVALID
=
"
invalid
"
;
PREF_INT
=
"
integer
"
;
PREF_BOOL
=
"
boolean
"
;
PREF_STRING
=
"
string
"
;
constructor
(
args
)
{
if
(
args
)
{
if
(
"
initHook
"
in
args
)
{
args
.
initHook
.
call
(
this
)
;
}
if
(
args
.
defaultBranch
)
{
this
.
prefs
=
new
Map
(
)
;
}
else
{
this
.
prefs
=
FAKE_GLOBAL_PREFS
;
}
}
else
{
this
.
prefs
=
FAKE_GLOBAL_PREFS
;
}
this
.
_prefBranch
=
{
}
;
this
.
observers
=
new
Map
(
)
;
}
addObserver
(
prefix
callback
)
{
this
.
observers
.
set
(
prefix
callback
)
;
}
removeObserver
(
prefix
callback
)
{
this
.
observers
.
delete
(
prefix
callback
)
;
}
setStringPref
(
prefName
value
)
{
this
.
set
(
prefName
value
)
;
}
getStringPref
(
prefName
)
{
return
this
.
get
(
prefName
)
;
}
setBoolPref
(
prefName
value
)
{
this
.
set
(
prefName
value
)
;
}
getBoolPref
(
prefName
)
{
return
this
.
get
(
prefName
)
;
}
setIntPref
(
prefName
value
)
{
this
.
set
(
prefName
value
)
;
}
getIntPref
(
prefName
)
{
return
this
.
get
(
prefName
)
;
}
setCharPref
(
prefName
value
)
{
this
.
set
(
prefName
value
)
;
}
getCharPref
(
prefName
)
{
return
this
.
get
(
prefName
)
;
}
clearUserPref
(
prefName
)
{
this
.
prefs
.
delete
(
prefName
)
;
}
get
(
prefName
)
{
return
this
.
prefs
.
get
(
prefName
)
;
}
getPrefType
(
prefName
)
{
let
value
=
this
.
prefs
.
get
(
prefName
)
;
switch
(
typeof
value
)
{
case
"
number
"
:
return
this
.
PREF_INT
;
case
"
boolean
"
:
return
this
.
PREF_BOOL
;
case
"
string
"
:
return
this
.
PREF_STRING
;
default
:
return
this
.
PREF_INVALID
;
}
}
set
(
prefName
value
)
{
this
.
prefs
.
set
(
prefName
value
)
;
let
observerPrefixes
=
[
.
.
.
this
.
observers
.
keys
(
)
]
.
filter
(
prefix
=
>
prefName
.
startsWith
(
prefix
)
)
;
for
(
let
observerPrefix
of
observerPrefixes
)
{
this
.
observers
.
get
(
observerPrefix
)
(
"
"
"
"
prefName
)
;
}
}
getChildList
(
prefix
)
{
return
[
.
.
.
this
.
prefs
.
keys
(
)
]
.
filter
(
prefName
=
>
prefName
.
startsWith
(
prefix
)
)
;
}
prefHasUserValue
(
prefName
)
{
return
this
.
prefs
.
has
(
prefName
)
;
}
prefIsLocked
(
prefName
)
{
return
false
;
}
}
export
class
FakensIPrefService
extends
FakensIPrefBranch
{
getBranch
(
)
{
}
getDefaultBranch
(
prefix
)
{
return
{
setBoolPref
(
)
{
}
setIntPref
(
)
{
}
setStringPref
(
)
{
}
clearUserPref
(
)
{
}
}
;
}
}
export
class
FakePrefs
extends
FakensIPrefBranch
{
observe
(
prefName
callback
)
{
super
.
addObserver
(
prefName
callback
)
;
}
ignore
(
prefName
callback
)
{
super
.
removeObserver
(
prefName
callback
)
;
}
observeBranch
(
listener
)
{
}
ignoreBranch
(
listener
)
{
}
set
(
prefName
value
)
{
this
.
prefs
.
set
(
prefName
value
)
;
if
(
this
.
observers
.
has
(
prefName
)
)
{
this
.
observers
.
get
(
prefName
)
(
value
)
;
}
}
}
export
function
EventEmitter
(
)
{
}
EventEmitter
.
decorate
=
function
(
objectToDecorate
)
{
let
emitter
=
new
EventEmitter
(
)
;
objectToDecorate
.
on
=
emitter
.
on
.
bind
(
emitter
)
;
objectToDecorate
.
off
=
emitter
.
off
.
bind
(
emitter
)
;
objectToDecorate
.
once
=
emitter
.
once
.
bind
(
emitter
)
;
objectToDecorate
.
emit
=
emitter
.
emit
.
bind
(
emitter
)
;
}
;
EventEmitter
.
prototype
=
{
on
(
event
listener
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
this
.
_eventEmitterListeners
=
new
Map
(
)
;
}
if
(
!
this
.
_eventEmitterListeners
.
has
(
event
)
)
{
this
.
_eventEmitterListeners
.
set
(
event
[
]
)
;
}
this
.
_eventEmitterListeners
.
get
(
event
)
.
push
(
listener
)
;
}
off
(
event
listener
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
return
;
}
let
listeners
=
this
.
_eventEmitterListeners
.
get
(
event
)
;
if
(
listeners
)
{
this
.
_eventEmitterListeners
.
set
(
event
listeners
.
filter
(
l
=
>
l
!
=
=
listener
&
&
l
.
_originalListener
!
=
=
listener
)
)
;
}
}
once
(
event
listener
)
{
return
new
Promise
(
resolve
=
>
{
let
handler
=
(
_
first
.
.
.
rest
)
=
>
{
this
.
off
(
event
handler
)
;
if
(
listener
)
{
listener
(
event
first
.
.
.
rest
)
;
}
resolve
(
first
)
;
}
;
handler
.
_originalListener
=
listener
;
this
.
on
(
event
handler
)
;
}
)
;
}
emit
(
event
.
.
.
args
)
{
if
(
!
this
.
_eventEmitterListeners
|
|
!
this
.
_eventEmitterListeners
.
has
(
event
)
)
{
return
;
}
let
originalListeners
=
this
.
_eventEmitterListeners
.
get
(
event
)
;
for
(
let
listener
of
this
.
_eventEmitterListeners
.
get
(
event
)
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
break
;
}
if
(
originalListeners
=
=
=
this
.
_eventEmitterListeners
.
get
(
event
)
|
|
this
.
_eventEmitterListeners
.
get
(
event
)
.
some
(
l
=
>
l
=
=
=
listener
)
)
{
try
{
listener
(
event
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
}
}
;
export
function
FakePerformance
(
)
{
}
FakePerformance
.
prototype
=
{
marks
:
new
Map
(
)
now
(
)
{
return
window
.
performance
.
now
(
)
;
}
timing
:
{
navigationStart
:
222222
.
123
}
get
timeOrigin
(
)
{
return
10000
.
234
;
}
getEntriesByName
(
name
type
)
{
if
(
this
.
marks
.
has
(
name
)
)
{
return
this
.
marks
.
get
(
name
)
;
}
return
[
]
;
}
callsToMark
:
0
mark
(
name
)
{
let
markObj
=
{
name
entryType
:
"
mark
"
startTime
:
+
+
this
.
callsToMark
duration
:
0
}
;
if
(
this
.
marks
.
has
(
name
)
)
{
this
.
marks
.
get
(
name
)
.
push
(
markObj
)
;
return
;
}
this
.
marks
.
set
(
name
[
markObj
]
)
;
}
}
;
export
function
addNumberReducer
(
prevState
=
0
action
)
{
return
action
.
type
=
=
=
"
ADD
"
?
prevState
+
action
.
data
:
prevState
;
}
export
class
FakeConsoleAPI
{
static
LOG_LEVELS
=
{
all
:
Number
.
MIN_VALUE
debug
:
2
log
:
3
info
:
3
clear
:
3
trace
:
3
timeEnd
:
3
time
:
3
assert
:
3
group
:
3
groupEnd
:
3
profile
:
3
profileEnd
:
3
dir
:
3
dirxml
:
3
warn
:
4
error
:
5
off
:
Number
.
MAX_VALUE
}
;
constructor
(
{
prefix
=
"
"
maxLogLevel
=
"
all
"
}
=
{
}
)
{
this
.
prefix
=
prefix
;
this
.
prefixStr
=
prefix
?
{
prefix
}
:
:
"
"
;
this
.
maxLogLevel
=
maxLogLevel
;
for
(
const
level
of
Object
.
keys
(
FakeConsoleAPI
.
LOG_LEVELS
)
)
{
if
(
typeof
console
[
level
]
=
=
=
"
function
"
)
{
this
[
level
]
=
this
.
shouldLog
(
level
)
?
this
.
_log
.
bind
(
this
level
)
:
(
)
=
>
{
}
;
}
}
}
shouldLog
(
level
)
{
return
(
FakeConsoleAPI
.
LOG_LEVELS
[
this
.
maxLogLevel
]
<
=
FakeConsoleAPI
.
LOG_LEVELS
[
level
]
)
;
}
_log
(
level
.
.
.
args
)
{
console
[
level
]
(
this
.
prefixStr
.
.
.
args
)
;
}
}
export
class
FakeLogger
extends
FakeConsoleAPI
{
constructor
(
)
{
super
(
{
maxLogLevel
:
"
off
"
}
)
;
}
}
