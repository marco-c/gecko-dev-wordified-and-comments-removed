"
use
strict
"
;
const
{
AboutHomeStartupCache
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
AboutHomeStartupCache
.
sys
.
mjs
"
)
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
const
{
FirstStartup
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FirstStartup
.
sys
.
mjs
"
)
;
const
{
updateAppInfo
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
)
;
const
PREF_CATEGORY_TASKS
=
"
first
-
startup
.
category
-
tasks
-
enabled
"
;
const
CATEGORY_NAME
=
"
first
-
startup
-
new
-
profile
"
;
add_setup
(
async
(
)
=
>
{
Services
.
fog
.
testResetFOG
(
)
;
updateAppInfo
(
)
;
}
)
;
add_task
(
async
function
test_is_firstStartupNewProfile_registered
(
)
{
const
entry
=
Services
.
catMan
.
getCategoryEntry
(
CATEGORY_NAME
"
resource
:
/
/
/
modules
/
AboutNewTabResourceMapping
.
sys
.
mjs
"
)
;
Assert
.
ok
(
entry
"
An
entry
should
exist
for
resource
:
/
/
/
modules
/
AboutNewTabResourceMapping
.
sys
.
mjs
"
)
;
Assert
.
equal
(
entry
"
AboutNewTabResourceMapping
.
firstStartupNewProfile
"
"
Entry
value
should
point
to
the
firstStartupNewProfile
method
"
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
test_firstStartup_trainhop_restartless_install
(
)
{
Services
.
prefs
.
setBoolPref
(
PREF_CATEGORY_TASKS
true
)
;
FirstStartup
.
resetForTesting
(
)
;
mockAboutNewTabUninit
(
)
;
assertNewTabResourceMapping
(
)
;
await
asyncAssertNewTabAddon
(
{
locationName
:
BUILTIN_LOCATION_NAME
}
)
;
assertTrainhopAddonNimbusExposure
(
{
expectedExposure
:
false
}
)
;
const
updateAddonVersion
=
{
BUILTIN_ADDON_VERSION
}
.
123
;
const
{
nimbusFeatureCleanup
}
=
await
setupNimbusTrainhopAddon
(
{
updateAddonVersion
}
)
;
assertTrainhopAddonVersionPref
(
updateAddonVersion
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
firstStartupNewProfileSpy
=
sandbox
.
spy
(
AboutNewTabResourceMapping
"
firstStartupNewProfile
"
)
;
let
aboutHomeStartupClearCacheStub
=
sandbox
.
stub
(
AboutHomeStartupCache
"
clearCacheAndUninit
"
)
;
let
submissionPromise
=
new
Promise
(
resolve
=
>
{
GleanPings
.
firstStartup
.
testBeforeNextSubmit
(
(
)
=
>
{
Assert
.
equal
(
FirstStartup
.
state
FirstStartup
.
SUCCESS
)
;
resolve
(
)
;
}
)
;
}
)
;
FirstStartup
.
init
(
true
)
;
await
submissionPromise
;
Assert
.
ok
(
firstStartupNewProfileSpy
.
calledOnce
"
firstStartupNewProfile
should
have
been
called
"
)
;
Assert
.
ok
(
aboutHomeStartupClearCacheStub
.
calledOnce
"
AboutHomeStartupCache
.
clearCacheAndUninit
called
after
installing
train
-
hop
"
)
;
let
addon
=
await
asyncAssertNewTabAddon
(
{
locationName
:
PROFILE_LOCATION_NAME
version
:
updateAddonVersion
}
)
;
Assert
.
ok
(
addon
"
Train
-
hop
add
-
on
should
be
installed
"
)
;
Assert
.
deepEqual
(
await
AddonManager
.
getAllInstalls
(
)
[
]
"
Expect
no
pending
install
for
restartless
install
"
)
;
sandbox
.
restore
(
)
;
await
addon
.
uninstall
(
)
;
await
nimbusFeatureCleanup
(
)
;
assertTrainhopAddonVersionPref
(
"
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_CATEGORY_TASKS
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
test_firstStartup_after_initialization
(
)
{
AboutNewTabResourceMapping
.
init
(
)
;
Assert
.
ok
(
AboutNewTabResourceMapping
.
initialized
"
AboutNewTabResourceMapping
should
be
initialized
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_CATEGORY_TASKS
true
)
;
FirstStartup
.
resetForTesting
(
)
;
const
updateAddonVersion
=
{
BUILTIN_ADDON_VERSION
}
.
456
;
const
{
nimbusFeatureCleanup
}
=
await
setupNimbusTrainhopAddon
(
{
updateAddonVersion
}
)
;
let
errorLogged
=
false
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
AboutNewTabResourceMapping
.
logger
"
error
"
)
.
callsFake
(
(
)
=
>
{
errorLogged
=
true
;
}
)
;
let
submissionPromise
=
new
Promise
(
resolve
=
>
{
GleanPings
.
firstStartup
.
testBeforeNextSubmit
(
(
)
=
>
{
resolve
(
)
;
}
)
;
}
)
;
FirstStartup
.
init
(
true
)
;
await
submissionPromise
;
Assert
.
ok
(
errorLogged
"
An
error
should
have
been
logged
when
trying
to
run
after
initialization
"
)
;
await
asyncAssertNewTabAddon
(
{
locationName
:
BUILTIN_LOCATION_NAME
version
:
BUILTIN_ADDON_VERSION
}
)
;
sandbox
.
restore
(
)
;
await
nimbusFeatureCleanup
(
)
;
Services
.
prefs
.
clearUserPref
(
PREF_CATEGORY_TASKS
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
test_firstStartup_category_disabled
(
)
{
Services
.
prefs
.
setBoolPref
(
PREF_CATEGORY_TASKS
false
)
;
FirstStartup
.
resetForTesting
(
)
;
mockAboutNewTabUninit
(
)
;
const
updateAddonVersion
=
{
BUILTIN_ADDON_VERSION
}
.
789
;
const
{
nimbusFeatureCleanup
}
=
await
setupNimbusTrainhopAddon
(
{
updateAddonVersion
}
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
firstStartupNewProfileSpy
=
sandbox
.
spy
(
AboutNewTabResourceMapping
"
firstStartupNewProfile
"
)
;
let
submissionPromise
=
new
Promise
(
resolve
=
>
{
GleanPings
.
firstStartup
.
testBeforeNextSubmit
(
(
)
=
>
{
resolve
(
)
;
}
)
;
}
)
;
FirstStartup
.
init
(
true
)
;
await
submissionPromise
;
Assert
.
ok
(
!
firstStartupNewProfileSpy
.
called
"
firstStartupNewProfile
should
not
have
been
called
when
pref
is
disabled
"
)
;
await
asyncAssertNewTabAddon
(
{
locationName
:
BUILTIN_LOCATION_NAME
version
:
BUILTIN_ADDON_VERSION
}
)
;
sandbox
.
restore
(
)
;
await
nimbusFeatureCleanup
(
)
;
Services
.
prefs
.
clearUserPref
(
PREF_CATEGORY_TASKS
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
test_firstStartup_init_during_download
(
)
{
Services
.
prefs
.
setBoolPref
(
PREF_CATEGORY_TASKS
true
)
;
FirstStartup
.
resetForTesting
(
)
;
mockAboutNewTabUninit
(
)
;
assertNewTabResourceMapping
(
)
;
await
asyncAssertNewTabAddon
(
{
locationName
:
BUILTIN_LOCATION_NAME
}
)
;
const
updateAddonVersion
=
{
BUILTIN_ADDON_VERSION
}
.
999
;
const
{
nimbusFeatureCleanup
}
=
await
setupNimbusTrainhopAddon
(
{
updateAddonVersion
}
)
;
assertTrainhopAddonVersionPref
(
updateAddonVersion
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
aboutNewTabInitSpy
=
sandbox
.
spy
(
AboutNewTabResourceMapping
"
init
"
)
;
let
originalUpdateTrainhopAddonState
=
AboutNewTabResourceMapping
.
updateTrainhopAddonState
.
bind
(
AboutNewTabResourceMapping
)
;
let
updateTrainhopStarted
=
false
;
sandbox
.
stub
(
AboutNewTabResourceMapping
"
updateTrainhopAddonState
"
)
.
callsFake
(
async
function
(
forceRestartlessInstall
)
{
updateTrainhopStarted
=
true
;
let
updatePromise
=
originalUpdateTrainhopAddonState
(
forceRestartlessInstall
)
;
info
(
"
Calling
AboutNewTabResourceMapping
.
init
(
)
during
updateTrainhopAddonState
"
)
;
AboutNewTabResourceMapping
.
init
(
)
;
await
updatePromise
;
}
)
;
let
submissionPromise
=
new
Promise
(
resolve
=
>
{
GleanPings
.
firstStartup
.
testBeforeNextSubmit
(
(
)
=
>
{
Assert
.
equal
(
FirstStartup
.
state
FirstStartup
.
SUCCESS
)
;
resolve
(
)
;
}
)
;
}
)
;
FirstStartup
.
init
(
true
)
;
await
submissionPromise
;
Assert
.
ok
(
updateTrainhopStarted
"
updateTrainhopAddonState
should
have
started
"
)
;
Assert
.
ok
(
aboutNewTabInitSpy
.
calledOnce
"
AboutNewTabResourceMapping
.
init
should
have
been
called
"
)
;
await
asyncAssertNewTabAddon
(
{
locationName
:
BUILTIN_LOCATION_NAME
version
:
BUILTIN_ADDON_VERSION
}
)
;
const
pendingInstall
=
(
await
AddonManager
.
getAllInstalls
(
)
)
.
find
(
install
=
>
install
.
addon
.
id
=
=
=
BUILTIN_ADDON_ID
)
;
Assert
.
ok
(
pendingInstall
"
Should
have
a
pending
install
"
)
;
Assert
.
equal
(
pendingInstall
.
state
AddonManager
.
STATE_POSTPONED
"
Install
should
be
postponed
"
)
;
Assert
.
equal
(
pendingInstall
.
addon
.
version
updateAddonVersion
"
Pending
install
should
be
for
the
train
-
hop
version
"
)
;
await
cancelPendingInstall
(
pendingInstall
)
;
sandbox
.
restore
(
)
;
await
nimbusFeatureCleanup
(
)
;
assertTrainhopAddonVersionPref
(
"
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_CATEGORY_TASKS
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
AppConstants
.
MOZ_NORMANDY
}
async
function
test_firstStartup_remote_disable
(
)
{
Services
.
prefs
.
setBoolPref
(
PREF_CATEGORY_TASKS
true
)
;
FirstStartup
.
resetForTesting
(
)
;
mockAboutNewTabUninit
(
)
;
assertNewTabResourceMapping
(
)
;
await
asyncAssertNewTabAddon
(
{
locationName
:
BUILTIN_LOCATION_NAME
}
)
;
assertTrainhopAddonNimbusExposure
(
{
expectedExposure
:
false
}
)
;
const
updateAddonVersion
=
{
BUILTIN_ADDON_VERSION
}
.
123
;
const
{
nimbusFeatureCleanup
}
=
await
setupNimbusTrainhopAddon
(
{
updateAddonVersion
}
)
;
assertTrainhopAddonVersionPref
(
updateAddonVersion
)
;
const
firstStartupFeatureCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
TRAINHOP_NIMBUS_FIRST_STARTUP_FEATURE_ID
value
:
{
enabled
:
false
}
}
{
isRollout
:
true
}
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
firstStartupNewProfileSpy
=
sandbox
.
spy
(
AboutNewTabResourceMapping
"
firstStartupNewProfile
"
)
;
let
submissionPromise
=
new
Promise
(
resolve
=
>
{
GleanPings
.
firstStartup
.
testBeforeNextSubmit
(
(
)
=
>
{
Assert
.
equal
(
FirstStartup
.
state
FirstStartup
.
SUCCESS
)
;
resolve
(
)
;
}
)
;
}
)
;
FirstStartup
.
init
(
true
)
;
await
submissionPromise
;
Assert
.
ok
(
firstStartupNewProfileSpy
.
calledOnce
"
firstStartupNewProfile
should
have
been
called
"
)
;
await
asyncAssertNewTabAddon
(
{
locationName
:
BUILTIN_LOCATION_NAME
version
:
BUILTIN_ADDON_VERSION
}
)
;
sandbox
.
restore
(
)
;
await
nimbusFeatureCleanup
(
)
;
await
firstStartupFeatureCleanup
(
)
;
assertTrainhopAddonVersionPref
(
"
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_CATEGORY_TASKS
)
;
}
)
;
