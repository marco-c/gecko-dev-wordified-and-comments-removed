"
use
strict
"
;
const
{
AboutNewTabResourceMapping
BUILTIN_ADDON_ID
TRAINHOP_NIMBUS_FEATURE_ID
TRAINHOP_XPI_BASE_URL_PREF
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
AboutNewTabResourceMapping
.
sys
.
mjs
"
)
;
const
{
ExperimentAPI
NimbusFeatures
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
)
;
const
{
NimbusTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
sys
.
mjs
"
)
;
const
BUILTIN_LOCATION_NAME
=
"
app
-
builtin
-
addons
"
;
const
PROFILE_LOCATION_NAME
=
"
app
-
profile
"
;
let
BUILTIN_ADDON_VERSION
;
NimbusTestUtils
.
init
(
this
)
;
const
server
=
AddonTestUtils
.
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
Services
.
prefs
.
setStringPref
(
TRAINHOP_XPI_BASE_URL_PREF
"
http
:
/
/
example
.
com
/
"
)
;
add_setup
(
async
function
nimbusTestsSetup
(
)
{
const
{
cleanup
:
nimbusTestCleanup
}
=
await
NimbusTestUtils
.
setupTest
(
)
;
registerCleanupFunction
(
nimbusTestCleanup
)
;
const
builtinAddon
=
await
asyncAssertNewTabAddon
(
{
locationName
:
"
app
-
builtin
-
addons
"
}
)
;
Assert
.
ok
(
builtinAddon
?
.
version
"
Got
a
builtin
add
-
on
version
"
)
;
BUILTIN_ADDON_VERSION
=
builtinAddon
.
version
;
registerCleanupFunction
(
(
)
=
>
{
const
profileDir
=
do_get_profile
(
)
;
const
stagingDir
=
profileDir
.
clone
(
)
;
stagingDir
.
append
(
"
extensions
"
)
;
stagingDir
.
append
(
"
staged
"
)
;
stagingDir
.
exists
(
)
&
&
stagingDir
.
remove
(
false
)
;
}
)
;
}
)
;
async
function
setupNimbusTrainhopAddon
(
{
updateAddonVersion
}
)
{
info
(
Setting
up
simulated
train
-
hop
add
-
on
version
{
updateAddonVersion
}
)
;
let
fakeNewTabXPI
=
AddonTestUtils
.
createTempWebExtensionFile
(
{
manifest
:
{
version
:
updateAddonVersion
browser_specific_settings
:
{
gecko
:
{
id
:
BUILTIN_ADDON_ID
}
}
}
files
:
{
"
lib
/
NewTabGleanUtils
.
sys
.
mjs
"
:
export
const
NewTabGleanUtils
=
{
registerMetricsAndPings
(
)
{
}
}
;
}
}
)
;
const
xpi_download_path
=
"
data
/
newtab
.
xpi
"
;
server
.
registerFile
(
/
{
xpi_download_path
}
fakeNewTabXPI
(
)
=
>
{
info
(
Server
got
request
for
{
xpi_download_path
}
)
;
}
)
;
const
fakeNimbusVariables
=
{
xpi_download_path
addon_version
:
updateAddonVersion
}
;
await
ExperimentAPI
.
ready
(
)
;
const
nimbusFeatureCleanup
=
await
NimbusTestUtils
.
enrollWithFeatureConfig
(
{
featureId
:
TRAINHOP_NIMBUS_FEATURE_ID
value
:
fakeNimbusVariables
}
{
isRollout
:
true
}
)
;
Assert
.
deepEqual
(
NimbusFeatures
[
TRAINHOP_NIMBUS_FEATURE_ID
]
.
getAllVariables
(
)
fakeNimbusVariables
"
Got
the
expected
variables
from
the
nimbus
feature
"
)
;
return
{
fakeNimbusVariables
nimbusFeatureCleanup
}
;
}
async
function
asyncAssertNewTabAddon
(
{
locationName
version
}
)
{
const
newtabAddon
=
await
AddonManager
.
getAddonByID
(
BUILTIN_ADDON_ID
)
;
Assert
.
equal
(
newtabAddon
?
.
locationName
locationName
"
Got
the
expected
newtab
add
-
on
locationName
"
)
;
if
(
version
)
{
Assert
.
equal
(
newtabAddon
?
.
version
version
"
Got
the
expected
newtab
add
-
on
version
"
)
;
}
return
newtabAddon
;
}
async
function
asyncAssertNimbusTrainhopAddonStaged
(
{
updateAddonVersion
}
)
{
const
pendingInstall
=
(
await
AddonManager
.
getAllInstalls
(
)
)
.
find
(
install
=
>
install
.
addon
.
id
=
=
=
BUILTIN_ADDON_ID
)
;
Assert
.
equal
(
pendingInstall
?
.
state
AddonManager
.
STATE_POSTPONED
"
Expect
a
pending
install
for
the
newtab
add
-
on
to
be
found
"
)
;
Assert
.
deepEqual
(
{
existingVersion
:
pendingInstall
.
existingAddon
.
version
existingLocationName
:
pendingInstall
.
existingAddon
.
locationName
updateVersion
:
pendingInstall
.
addon
.
version
updateLocationName
:
pendingInstall
.
addon
.
locationName
}
{
existingVersion
:
BUILTIN_ADDON_VERSION
existingLocationName
:
BUILTIN_LOCATION_NAME
updateVersion
:
updateAddonVersion
updateLocationName
:
PROFILE_LOCATION_NAME
}
"
Got
the
expected
version
and
locationName
pendingInstall
existing
and
updated
add
-
on
"
)
;
return
{
pendingInstall
}
;
}
function
assertTrainhopAddonNimbusExposure
(
{
expectedExposure
}
)
{
const
enrollmentMetadata
=
NimbusFeatures
[
TRAINHOP_NIMBUS_FEATURE_ID
]
.
getEnrollmentMetadata
(
)
;
Assert
.
deepEqual
(
Glean
.
nimbusEvents
.
exposure
.
testGetValue
(
"
events
"
)
?
.
map
(
ev
=
>
ev
.
extra
)
.
filter
(
ev
=
>
ev
.
feature_id
=
=
TRAINHOP_NIMBUS_FEATURE_ID
)
?
?
[
]
expectedExposure
?
[
{
feature_id
:
TRAINHOP_NIMBUS_FEATURE_ID
branch
:
enrollmentMetadata
.
branch
experiment
:
enrollmentMetadata
.
slug
}
]
:
[
]
expectedExposure
?
"
Got
the
expected
exposure
Glean
event
for
the
newtabTrainhopAddon
Nimbus
feature
"
:
"
Got
no
exposure
Glean
event
for
the
newtabTrainhopAddon
as
expected
"
)
;
}
async
function
cancelPendingInstall
(
pendingInstall
)
{
const
cancelDeferred
=
Promise
.
withResolvers
(
)
;
pendingInstall
.
addListener
(
{
onInstallCancelled
(
)
{
cancelDeferred
.
resolve
(
)
;
}
}
)
;
pendingInstall
.
cancel
(
)
;
await
cancelDeferred
.
promise
;
}
