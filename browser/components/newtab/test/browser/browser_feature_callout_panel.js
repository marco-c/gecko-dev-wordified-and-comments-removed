"
use
strict
"
;
function
getTestMessage
(
)
{
return
{
id
:
"
TEST_PANEL_FEATURE_CALLOUT
"
template
:
"
feature_callout
"
groups
:
[
]
content
:
{
id
:
"
TEST_PANEL_FEATURE_CALLOUT
"
template
:
"
multistage
"
backdrop
:
"
transparent
"
transitions
:
false
disableHistoryUpdates
:
true
screens
:
[
{
id
:
"
TEST_PANEL_FEATURE_CALLOUT
"
anchors
:
[
{
selector
:
"
#
PanelUI
-
menu
-
button
"
panel_position
:
{
anchor_attachment
:
"
bottomcenter
"
callout_attachment
:
"
topright
"
}
}
]
content
:
{
position
:
"
callout
"
title
:
{
raw
:
"
Panel
Feature
Callout
"
}
dismiss_button
:
{
action
:
{
dismiss
:
true
}
}
}
}
]
}
}
;
}
async
function
showFeatureCallout
(
browser
message
)
{
let
resolveClosed
;
let
closed
=
new
Promise
(
resolve
=
>
{
resolveClosed
=
resolve
;
}
)
;
const
config
=
{
win
:
browser
.
ownerGlobal
location
:
"
chrome
"
context
:
"
chrome
"
browser
theme
:
{
preset
:
"
chrome
"
}
listener
:
(
_
event
)
=
>
{
if
(
event
=
=
=
"
end
"
)
{
resolveClosed
(
)
;
}
}
}
;
const
featureCallout
=
new
FeatureCallout
(
config
)
;
let
showing
=
await
featureCallout
.
showFeatureCallout
(
message
)
;
return
{
featureCallout
showing
closed
}
;
}
async
function
testCalloutHiddenIf
(
hideFn
afterCloseFn
message
=
getTestMessage
(
)
)
{
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
doc
=
win
.
document
;
const
browser
=
win
.
gBrowser
.
selectedBrowser
;
const
{
featureCallout
showing
closed
}
=
await
showFeatureCallout
(
browser
message
)
;
await
waitForCalloutScreen
(
doc
message
.
content
.
screens
[
0
]
.
id
)
;
let
calloutContainer
=
featureCallout
.
_container
;
ok
(
showing
&
&
calloutContainer
"
Feature
callout
should
be
showing
"
)
;
await
hideFn
(
win
calloutContainer
featureCallout
)
;
await
closed
;
await
waitForCalloutRemoved
(
doc
)
;
ok
(
!
doc
.
querySelector
(
calloutSelector
)
"
Feature
callout
should
be
hidden
"
)
;
await
afterCloseFn
?
.
(
win
calloutContainer
featureCallout
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
add_task
(
async
function
panel_feature_callout
(
)
{
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
is
(
calloutContainer
.
localName
"
panel
"
"
Callout
container
is
a
panel
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
calloutContainer
{
attributeFilter
:
[
"
arrow
-
position
"
]
}
(
)
=
>
calloutContainer
.
getAttribute
(
"
arrow
-
position
"
)
=
=
=
"
top
-
end
"
)
;
is
(
calloutContainer
.
anchorNode
.
id
"
PanelUI
-
menu
-
button
"
"
Callout
container
is
anchored
to
the
app
menu
button
"
)
;
is
(
calloutContainer
.
getAttribute
(
"
arrow
-
position
"
)
"
top
-
end
"
"
Callout
container
arrow
is
positioned
correctly
"
)
;
win
.
document
.
querySelector
(
calloutDismissSelector
)
.
click
(
)
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_hidden_on_popupshowing
(
)
{
await
testCalloutHiddenIf
(
async
win
=
>
{
win
.
document
.
querySelector
(
"
#
PanelUI
-
menu
-
button
"
)
.
click
(
)
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_hidden_on_anchor_hidden
(
)
{
await
testCalloutHiddenIf
(
async
win
=
>
{
win
.
document
.
querySelector
(
"
#
PanelUI
-
menu
-
button
"
)
.
hidden
=
true
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_follows_anchor
(
)
{
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
let
startingX
=
calloutContainer
.
getBoundingClientRect
(
)
.
x
;
calloutContainer
.
anchorNode
.
style
.
marginInlineEnd
=
"
100px
"
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
calloutContainer
.
getBoundingClientRect
(
)
.
x
!
=
=
startingX
"
Callout
should
reposition
itself
"
)
;
win
.
document
.
querySelector
(
calloutDismissSelector
)
.
click
(
)
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_anchor_open_attr
(
)
{
let
anchor
;
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
anchor
=
calloutContainer
.
anchorNode
;
ok
(
anchor
.
hasAttribute
(
"
open
"
)
"
Callout
container
'
s
anchor
node
should
have
its
[
open
]
attribute
set
"
)
;
win
.
document
.
querySelector
(
calloutDismissSelector
)
.
click
(
)
;
}
(
win
calloutContainer
)
=
>
{
ok
(
!
anchor
.
hasAttribute
(
"
open
"
)
"
Callout
container
'
s
anchor
node
should
not
have
its
[
open
]
attribute
set
"
)
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_no_anchor_open_attr
(
)
{
let
message
=
getTestMessage
(
)
;
message
.
content
.
screens
[
0
]
.
anchors
[
0
]
.
no_open_on_anchor
=
true
;
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
let
anchor
=
calloutContainer
.
anchorNode
;
ok
(
!
anchor
.
hasAttribute
(
"
open
"
)
"
Callout
container
'
s
anchor
node
should
not
have
its
[
open
]
attribute
set
"
)
;
win
.
document
.
querySelector
(
calloutDismissSelector
)
.
click
(
)
;
}
null
message
)
;
}
)
;
add_task
(
async
function
feature_callout_split_dismiss_button
(
)
{
let
message
=
getTestMessage
(
)
;
message
.
content
.
screens
[
0
]
.
content
.
secondary_button
=
{
label
:
{
raw
:
"
Advance
"
}
action
:
{
navigate
:
true
}
}
;
message
.
content
.
screens
[
0
]
.
content
.
submenu_button
=
{
submenu
:
[
{
type
:
"
action
"
label
:
{
raw
:
"
Item
1
"
}
action
:
{
navigate
:
true
}
id
:
"
item1
"
}
{
type
:
"
action
"
label
:
{
raw
:
"
Item
2
"
}
action
:
{
navigate
:
true
}
id
:
"
item2
"
}
{
type
:
"
menu
"
label
:
{
raw
:
"
Menu
1
"
}
submenu
:
[
{
type
:
"
action
"
label
:
{
raw
:
"
Item
3
"
}
action
:
{
navigate
:
true
}
id
:
"
item3
"
}
{
type
:
"
action
"
label
:
{
raw
:
"
Item
4
"
}
action
:
{
navigate
:
true
}
id
:
"
item4
"
}
]
id
:
"
menu1
"
}
]
attached_to
:
"
secondary_button
"
}
;
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
let
splitButtonContainer
=
calloutContainer
.
querySelector
(
#
{
calloutId
}
.
split
-
button
-
container
)
;
let
secondaryButton
=
calloutContainer
.
querySelector
(
#
{
calloutId
}
.
secondary
:
not
(
.
submenu
-
button
)
)
;
let
submenuButton
=
calloutContainer
.
querySelector
(
#
{
calloutId
}
.
submenu
-
button
)
;
let
submenu
=
calloutContainer
.
querySelector
(
#
{
calloutId
}
.
fxms
-
multi
-
stage
-
submenu
)
;
ok
(
splitButtonContainer
"
Callout
should
have
a
split
button
container
"
)
;
ok
(
secondaryButton
"
Callout
should
have
a
split
secondary
button
"
)
;
ok
(
submenuButton
"
Callout
should
have
a
split
submenu
button
"
)
;
ok
(
submenu
"
Callout
should
have
a
submenu
"
)
;
let
opened
=
BrowserTestUtils
.
waitForEvent
(
submenu
"
popupshown
"
)
;
submenuButton
.
click
(
)
;
await
opened
;
async
function
recursiveTestMenuItems
(
items
popup
)
{
let
children
=
[
.
.
.
popup
.
children
]
;
for
(
let
element
of
children
)
{
let
index
=
children
.
indexOf
(
element
)
;
let
itemAtIndex
=
items
[
index
]
;
switch
(
element
.
localName
)
{
case
"
menuitem
"
:
is
(
itemAtIndex
.
type
"
action
"
Menu
item
{
itemAtIndex
.
id
}
should
be
an
action
)
;
is
(
JSON
.
stringify
(
element
.
config
)
JSON
.
stringify
(
itemAtIndex
)
Menu
item
{
itemAtIndex
.
id
}
should
have
correct
config
)
;
is
(
element
.
value
itemAtIndex
.
id
Menu
item
{
itemAtIndex
.
id
}
should
have
correct
value
)
;
break
;
case
"
menu
"
:
is
(
itemAtIndex
.
type
"
menu
"
Menu
item
{
itemAtIndex
.
id
}
should
be
a
menu
)
;
is
(
element
.
value
itemAtIndex
.
id
Menu
item
{
itemAtIndex
.
id
}
should
have
correct
value
)
;
info
(
Testing
submenu
{
itemAtIndex
.
id
}
)
;
await
recursiveTestMenuItems
(
itemAtIndex
.
submenu
element
.
querySelector
(
"
menupopup
"
)
)
;
break
;
case
"
menuseparator
"
:
is
(
itemAtIndex
.
type
"
separator
"
Menu
item
{
index
}
should
be
a
separator
)
;
break
;
default
:
ok
(
false
"
Child
of
unknown
type
in
submenu
"
)
;
}
}
}
info
(
"
Testing
main
menu
"
)
;
await
recursiveTestMenuItems
(
message
.
content
.
screens
[
0
]
.
content
.
submenu_button
.
submenu
submenu
)
;
submenu
.
querySelector
(
menuitem
[
value
=
"
item1
"
]
)
.
click
(
)
;
}
null
message
)
;
}
)
;
