"
use
strict
"
;
function
getTestMessage
(
)
{
return
{
id
:
"
TEST_PANEL_FEATURE_CALLOUT
"
template
:
"
feature_callout
"
groups
:
[
]
content
:
{
id
:
"
TEST_PANEL_FEATURE_CALLOUT
"
template
:
"
multistage
"
backdrop
:
"
transparent
"
transitions
:
false
disableHistoryUpdates
:
true
screens
:
[
{
id
:
"
TEST_PANEL_FEATURE_CALLOUT
"
anchors
:
[
{
selector
:
"
#
PanelUI
-
menu
-
button
"
panel_position
:
{
anchor_attachment
:
"
bottomcenter
"
callout_attachment
:
"
topright
"
}
}
]
content
:
{
position
:
"
callout
"
title
:
{
raw
:
"
Panel
Feature
Callout
"
}
dismiss_button
:
{
action
:
{
dismiss
:
true
}
}
}
}
]
}
}
;
}
async
function
showFeatureCallout
(
browser
message
)
{
let
resolveClosed
;
let
closed
=
new
Promise
(
resolve
=
>
{
resolveClosed
=
resolve
;
}
)
;
const
config
=
{
win
:
browser
.
ownerGlobal
location
:
"
chrome
"
context
:
"
chrome
"
browser
theme
:
{
preset
:
"
chrome
"
}
listener
:
(
_
event
)
=
>
{
if
(
event
=
=
=
"
end
"
)
{
resolveClosed
(
)
;
}
}
}
;
const
featureCallout
=
new
FeatureCallout
(
config
)
;
let
showing
=
await
featureCallout
.
showFeatureCallout
(
message
)
;
return
{
featureCallout
showing
closed
}
;
}
async
function
testCalloutHiddenIf
(
hideFn
afterCloseFn
message
=
getTestMessage
(
)
)
{
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
doc
=
win
.
document
;
const
browser
=
win
.
gBrowser
.
selectedBrowser
;
const
{
featureCallout
showing
closed
}
=
await
showFeatureCallout
(
browser
message
)
;
await
waitForCalloutScreen
(
doc
message
.
content
.
screens
[
0
]
.
id
)
;
let
calloutContainer
=
featureCallout
.
_container
;
ok
(
showing
&
&
calloutContainer
"
Feature
callout
should
be
showing
"
)
;
await
hideFn
(
win
calloutContainer
featureCallout
)
;
await
closed
;
await
waitForCalloutRemoved
(
doc
)
;
ok
(
!
doc
.
querySelector
(
calloutSelector
)
"
Feature
callout
should
be
hidden
"
)
;
await
afterCloseFn
?
.
(
win
calloutContainer
featureCallout
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
add_task
(
async
function
panel_feature_callout
(
)
{
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
is
(
calloutContainer
.
localName
"
panel
"
"
Callout
container
is
a
panel
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
calloutContainer
{
attributeFilter
:
[
"
arrow
-
position
"
]
}
(
)
=
>
calloutContainer
.
getAttribute
(
"
arrow
-
position
"
)
=
=
=
"
top
-
end
"
)
;
is
(
calloutContainer
.
anchorNode
.
id
"
PanelUI
-
menu
-
button
"
"
Callout
container
is
anchored
to
the
app
menu
button
"
)
;
is
(
calloutContainer
.
getAttribute
(
"
arrow
-
position
"
)
"
top
-
end
"
"
Callout
container
arrow
is
positioned
correctly
"
)
;
win
.
document
.
querySelector
(
calloutDismissSelector
)
.
click
(
)
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_hidden_on_popupshowing
(
)
{
await
testCalloutHiddenIf
(
async
win
=
>
{
win
.
document
.
querySelector
(
"
#
PanelUI
-
menu
-
button
"
)
.
click
(
)
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_hidden_on_anchor_hidden
(
)
{
await
testCalloutHiddenIf
(
async
win
=
>
{
win
.
document
.
querySelector
(
"
#
PanelUI
-
menu
-
button
"
)
.
hidden
=
true
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_follows_anchor
(
)
{
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
let
startingX
=
calloutContainer
.
getBoundingClientRect
(
)
.
x
;
calloutContainer
.
anchorNode
.
style
.
marginInlineEnd
=
"
100px
"
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
calloutContainer
.
getBoundingClientRect
(
)
.
x
!
=
=
startingX
"
Callout
should
reposition
itself
"
)
;
win
.
document
.
querySelector
(
calloutDismissSelector
)
.
click
(
)
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_anchor_open_attr
(
)
{
let
anchor
;
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
anchor
=
calloutContainer
.
anchorNode
;
ok
(
anchor
.
hasAttribute
(
"
open
"
)
"
Callout
container
'
s
anchor
node
should
have
its
[
open
]
attribute
set
"
)
;
win
.
document
.
querySelector
(
calloutDismissSelector
)
.
click
(
)
;
}
(
win
calloutContainer
)
=
>
{
ok
(
!
anchor
.
hasAttribute
(
"
open
"
)
"
Callout
container
'
s
anchor
node
should
not
have
its
[
open
]
attribute
set
"
)
;
}
)
;
}
)
;
add_task
(
async
function
panel_feature_callout_no_anchor_open_attr
(
)
{
let
message
=
getTestMessage
(
)
;
message
.
content
.
screens
[
0
]
.
anchors
[
0
]
.
no_open_on_anchor
=
true
;
await
testCalloutHiddenIf
(
async
(
win
calloutContainer
)
=
>
{
let
anchor
=
calloutContainer
.
anchorNode
;
ok
(
!
anchor
.
hasAttribute
(
"
open
"
)
"
Callout
container
'
s
anchor
node
should
not
have
its
[
open
]
attribute
set
"
)
;
win
.
document
.
querySelector
(
calloutDismissSelector
)
.
click
(
)
;
}
null
message
)
;
}
)
;
