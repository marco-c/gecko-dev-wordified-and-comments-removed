"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
DiscoveryStreamFeed
:
"
resource
:
/
/
activity
-
stream
/
lib
/
DiscoveryStreamFeed
.
sys
.
mjs
"
FeatureCallout
:
"
resource
:
/
/
/
modules
/
FeatureCallout
.
sys
.
mjs
"
FeatureCalloutBroker
:
"
resource
:
/
/
activity
-
stream
/
lib
/
FeatureCalloutBroker
.
sys
.
mjs
"
FeatureCalloutMessages
:
"
resource
:
/
/
activity
-
stream
/
lib
/
FeatureCalloutMessages
.
sys
.
mjs
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
sys
.
mjs
"
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ASRouter
:
"
resource
:
/
/
/
modules
/
asrouter
/
ASRouter
.
jsm
"
QueryCache
:
"
resource
:
/
/
/
modules
/
asrouter
/
ASRouterTargeting
.
jsm
"
}
)
;
const
{
FxAccounts
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
sys
.
mjs
"
)
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
const
calloutId
=
"
feature
-
callout
"
;
const
calloutSelector
=
#
{
calloutId
}
.
featureCallout
;
const
calloutCTASelector
=
#
{
calloutId
}
:
is
(
.
primary
.
secondary
)
;
const
calloutDismissSelector
=
#
{
calloutId
}
.
dismiss
-
button
;
function
popPrefs
(
)
{
return
SpecialPowers
.
popPrefEnv
(
)
;
}
function
pushPrefs
(
.
.
.
prefs
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
prefs
}
)
;
}
async
function
toggleTopsitesPref
(
)
{
await
pushPrefs
(
[
"
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
system
.
topsites
"
false
]
)
;
await
pushPrefs
(
[
"
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
system
.
topsites
"
true
]
)
;
}
async
function
setDefaultTopSites
(
)
{
await
pushPrefs
(
[
"
browser
.
newtabpage
.
activity
-
stream
.
default
.
sites
"
"
https
:
/
/
www
.
youtube
.
com
/
https
:
/
/
www
.
facebook
.
com
/
https
:
/
/
www
.
amazon
.
com
/
https
:
/
/
www
.
reddit
.
com
/
https
:
/
/
www
.
wikipedia
.
org
/
https
:
/
/
twitter
.
com
/
"
]
)
;
await
toggleTopsitesPref
(
)
;
await
pushPrefs
(
[
"
browser
.
newtabpage
.
activity
-
stream
.
improvesearch
.
topSiteSearchShortcuts
"
true
]
)
;
}
async
function
setTestTopSites
(
)
{
await
pushPrefs
(
[
"
browser
.
newtabpage
.
activity
-
stream
.
improvesearch
.
topSiteSearchShortcuts
"
false
]
)
;
await
pushPrefs
(
[
"
browser
.
newtabpage
.
activity
-
stream
.
default
.
sites
"
"
https
:
/
/
example
.
com
/
"
]
)
;
await
toggleTopsitesPref
(
)
;
}
async
function
clearHistoryAndBookmarks
(
)
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
QueryCache
.
expireAll
(
)
;
}
async
function
waitForPreloaded
(
browser
)
{
let
readyState
=
await
ContentTask
.
spawn
(
browser
null
(
)
=
>
content
.
document
.
readyState
)
;
if
(
readyState
!
=
=
"
complete
"
)
{
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
}
}
async
function
waitForUrlLoad
(
url
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
BrowserTestUtils
.
startLoadingURIString
(
browser
url
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
url
)
;
}
function
refreshHighlightsFeed
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
section
.
highlights
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
section
.
highlights
"
true
)
;
}
async
function
addHighlightsBookmarks
(
count
)
{
const
bookmarks
=
new
Array
(
count
)
.
fill
(
null
)
.
map
(
(
entry
i
)
=
>
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
foo
"
url
:
https
:
/
/
mozilla
{
i
}
.
com
/
nowNew
}
)
)
;
for
(
let
placeInfo
of
bookmarks
)
{
await
PlacesUtils
.
bookmarks
.
insert
(
placeInfo
)
;
await
PlacesTestUtils
.
addVisits
(
placeInfo
.
url
)
;
}
refreshHighlightsFeed
(
)
;
}
function
addContentHelpers
(
)
{
const
{
document
}
=
content
;
Object
.
assign
(
content
{
async
openContextMenuAndGetOptions
(
selector
)
{
const
item
=
document
.
querySelector
(
selector
)
;
const
contextButton
=
item
.
querySelector
(
"
.
context
-
menu
-
button
"
)
;
contextButton
.
click
(
)
;
await
new
Promise
(
r
=
>
content
.
requestAnimationFrame
(
r
)
)
;
const
contextMenu
=
item
.
querySelector
(
"
.
context
-
menu
"
)
;
const
contextMenuList
=
contextMenu
.
querySelector
(
"
.
context
-
menu
-
list
"
)
;
return
[
.
.
.
contextMenuList
.
getElementsByClassName
(
"
context
-
menu
-
item
"
)
]
;
}
}
)
;
}
function
test_newtab
(
testInfo
browserURL
=
"
about
:
newtab
"
)
{
let
{
before
test
:
contentTask
after
}
=
testInfo
;
if
(
!
before
)
{
before
=
(
)
=
>
(
{
}
)
;
}
if
(
!
contentTask
)
{
contentTask
=
testInfo
;
}
if
(
!
after
)
{
after
=
(
)
=
>
{
}
;
}
let
needPopPrefs
=
false
;
let
scopedPushPrefs
=
async
(
.
.
.
args
)
=
>
{
needPopPrefs
=
true
;
await
pushPrefs
(
.
.
.
args
)
;
}
;
let
scopedPopPrefs
=
async
(
)
=
>
{
if
(
needPopPrefs
)
{
await
popPrefs
(
)
;
}
}
;
let
testTask
=
async
(
)
=
>
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
browserURL
false
)
;
let
browser
=
tab
.
linkedBrowser
;
await
waitForPreloaded
(
browser
)
;
SpecialPowers
.
spawn
(
browser
[
]
addContentHelpers
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
content
.
document
.
getElementById
(
"
root
"
)
.
children
.
length
)
"
Should
render
activity
stream
content
"
)
;
try
{
let
contentArg
=
await
before
(
{
pushPrefs
:
scopedPushPrefs
tab
}
)
;
let
contentResult
=
await
SpecialPowers
.
spawn
(
browser
[
contentArg
]
contentTask
)
;
await
after
(
contentResult
)
;
}
finally
{
BrowserTestUtils
.
removeTab
(
tab
)
;
await
scopedPopPrefs
(
)
;
}
}
;
Object
.
defineProperty
(
testTask
"
name
"
{
value
:
contentTask
.
name
}
)
;
add_task
(
testTask
)
;
}
async
function
waitForCalloutScreen
(
target
screenId
)
{
await
BrowserTestUtils
.
waitForMutationCondition
(
target
{
childList
:
true
subtree
:
true
attributeFilter
:
[
"
class
"
]
}
(
)
=
>
target
.
querySelector
(
{
calloutSelector
}
:
not
(
.
hidden
)
.
{
screenId
}
)
)
;
}
async
function
waitForCalloutRemoved
(
target
)
{
await
BrowserTestUtils
.
waitForMutationCondition
(
target
{
childList
:
true
subtree
:
true
}
(
)
=
>
!
target
.
querySelector
(
calloutSelector
)
)
;
}
