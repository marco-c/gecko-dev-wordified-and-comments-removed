'
use
strict
'
;
(
function
(
global
factory
)
{
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
!
=
=
'
undefined
'
?
module
.
exports
=
factory
(
require
(
'
react
'
)
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
[
'
react
'
]
factory
)
:
(
global
.
ReactDOM
=
factory
(
global
.
React
)
)
;
}
(
this
(
function
(
React
)
{
'
use
strict
'
;
if
(
!
React
)
{
{
throw
Error
(
"
ReactDOM
was
loaded
before
React
.
Make
sure
you
load
the
React
package
before
loading
ReactDOM
.
"
)
;
}
}
var
eventPluginOrder
=
null
;
var
namesToPlugins
=
{
}
;
function
recomputePluginOrdering
(
)
{
if
(
!
eventPluginOrder
)
{
return
;
}
for
(
var
pluginName
in
namesToPlugins
)
{
var
pluginModule
=
namesToPlugins
[
pluginName
]
;
var
pluginIndex
=
eventPluginOrder
.
indexOf
(
pluginName
)
;
if
(
!
(
pluginIndex
>
-
1
)
)
{
{
throw
Error
(
"
EventPluginRegistry
:
Cannot
inject
event
plugins
that
do
not
exist
in
the
plugin
ordering
"
+
pluginName
+
"
.
"
)
;
}
}
if
(
plugins
[
pluginIndex
]
)
{
continue
;
}
if
(
!
pluginModule
.
extractEvents
)
{
{
throw
Error
(
"
EventPluginRegistry
:
Event
plugins
must
implement
an
extractEvents
method
but
"
+
pluginName
+
"
does
not
.
"
)
;
}
}
plugins
[
pluginIndex
]
=
pluginModule
;
var
publishedEvents
=
pluginModule
.
eventTypes
;
for
(
var
eventName
in
publishedEvents
)
{
if
(
!
publishEventForPlugin
(
publishedEvents
[
eventName
]
pluginModule
eventName
)
)
{
{
throw
Error
(
"
EventPluginRegistry
:
Failed
to
publish
event
"
+
eventName
+
"
for
plugin
"
+
pluginName
+
"
.
"
)
;
}
}
}
}
}
function
publishEventForPlugin
(
dispatchConfig
pluginModule
eventName
)
{
if
(
!
!
eventNameDispatchConfigs
.
hasOwnProperty
(
eventName
)
)
{
{
throw
Error
(
"
EventPluginHub
:
More
than
one
plugin
attempted
to
publish
the
same
event
name
"
+
eventName
+
"
.
"
)
;
}
}
eventNameDispatchConfigs
[
eventName
]
=
dispatchConfig
;
var
phasedRegistrationNames
=
dispatchConfig
.
phasedRegistrationNames
;
if
(
phasedRegistrationNames
)
{
for
(
var
phaseName
in
phasedRegistrationNames
)
{
if
(
phasedRegistrationNames
.
hasOwnProperty
(
phaseName
)
)
{
var
phasedRegistrationName
=
phasedRegistrationNames
[
phaseName
]
;
publishRegistrationName
(
phasedRegistrationName
pluginModule
eventName
)
;
}
}
return
true
;
}
else
if
(
dispatchConfig
.
registrationName
)
{
publishRegistrationName
(
dispatchConfig
.
registrationName
pluginModule
eventName
)
;
return
true
;
}
return
false
;
}
function
publishRegistrationName
(
registrationName
pluginModule
eventName
)
{
if
(
!
!
registrationNameModules
[
registrationName
]
)
{
{
throw
Error
(
"
EventPluginHub
:
More
than
one
plugin
attempted
to
publish
the
same
registration
name
"
+
registrationName
+
"
.
"
)
;
}
}
registrationNameModules
[
registrationName
]
=
pluginModule
;
registrationNameDependencies
[
registrationName
]
=
pluginModule
.
eventTypes
[
eventName
]
.
dependencies
;
{
var
lowerCasedName
=
registrationName
.
toLowerCase
(
)
;
possibleRegistrationNames
[
lowerCasedName
]
=
registrationName
;
if
(
registrationName
=
=
=
'
onDoubleClick
'
)
{
possibleRegistrationNames
.
ondblclick
=
registrationName
;
}
}
}
var
plugins
=
[
]
;
var
eventNameDispatchConfigs
=
{
}
;
var
registrationNameModules
=
{
}
;
var
registrationNameDependencies
=
{
}
;
var
possibleRegistrationNames
=
{
}
;
function
injectEventPluginOrder
(
injectedEventPluginOrder
)
{
if
(
!
!
eventPluginOrder
)
{
{
throw
Error
(
"
EventPluginRegistry
:
Cannot
inject
event
plugin
ordering
more
than
once
.
You
are
likely
trying
to
load
more
than
one
copy
of
React
.
"
)
;
}
}
eventPluginOrder
=
Array
.
prototype
.
slice
.
call
(
injectedEventPluginOrder
)
;
recomputePluginOrdering
(
)
;
}
function
injectEventPluginsByName
(
injectedNamesToPlugins
)
{
var
isOrderingDirty
=
false
;
for
(
var
pluginName
in
injectedNamesToPlugins
)
{
if
(
!
injectedNamesToPlugins
.
hasOwnProperty
(
pluginName
)
)
{
continue
;
}
var
pluginModule
=
injectedNamesToPlugins
[
pluginName
]
;
if
(
!
namesToPlugins
.
hasOwnProperty
(
pluginName
)
|
|
namesToPlugins
[
pluginName
]
!
=
=
pluginModule
)
{
if
(
!
!
namesToPlugins
[
pluginName
]
)
{
{
throw
Error
(
"
EventPluginRegistry
:
Cannot
inject
two
different
event
plugins
using
the
same
name
"
+
pluginName
+
"
.
"
)
;
}
}
namesToPlugins
[
pluginName
]
=
pluginModule
;
isOrderingDirty
=
true
;
}
}
if
(
isOrderingDirty
)
{
recomputePluginOrdering
(
)
;
}
}
var
invokeGuardedCallbackImpl
=
function
(
name
func
context
a
b
c
d
e
f
)
{
var
funcArgs
=
Array
.
prototype
.
slice
.
call
(
arguments
3
)
;
try
{
func
.
apply
(
context
funcArgs
)
;
}
catch
(
error
)
{
this
.
onError
(
error
)
;
}
}
;
{
if
(
typeof
window
!
=
=
'
undefined
'
&
&
typeof
window
.
dispatchEvent
=
=
=
'
function
'
&
&
typeof
document
!
=
=
'
undefined
'
&
&
typeof
document
.
createEvent
=
=
=
'
function
'
)
{
var
fakeNode
=
document
.
createElement
(
'
react
'
)
;
var
invokeGuardedCallbackDev
=
function
(
name
func
context
a
b
c
d
e
f
)
{
if
(
!
(
typeof
document
!
=
=
'
undefined
'
)
)
{
{
throw
Error
(
"
The
document
global
was
defined
when
React
was
initialized
but
is
not
defined
anymore
.
This
can
happen
in
a
test
environment
if
a
component
schedules
an
update
from
an
asynchronous
callback
but
the
test
has
already
finished
running
.
To
solve
this
you
can
either
unmount
the
component
at
the
end
of
your
test
(
and
ensure
that
any
asynchronous
operations
get
canceled
in
componentWillUnmount
)
or
you
can
change
the
test
itself
to
be
asynchronous
.
"
)
;
}
}
var
evt
=
document
.
createEvent
(
'
Event
'
)
;
var
didError
=
true
;
var
windowEvent
=
window
.
event
;
var
windowEventDescriptor
=
Object
.
getOwnPropertyDescriptor
(
window
'
event
'
)
;
var
funcArgs
=
Array
.
prototype
.
slice
.
call
(
arguments
3
)
;
function
callCallback
(
)
{
fakeNode
.
removeEventListener
(
evtType
callCallback
false
)
;
if
(
typeof
window
.
event
!
=
=
'
undefined
'
&
&
window
.
hasOwnProperty
(
'
event
'
)
)
{
window
.
event
=
windowEvent
;
}
func
.
apply
(
context
funcArgs
)
;
didError
=
false
;
}
var
error
;
var
didSetError
=
false
;
var
isCrossOriginError
=
false
;
function
handleWindowError
(
event
)
{
error
=
event
.
error
;
didSetError
=
true
;
if
(
error
=
=
=
null
&
&
event
.
colno
=
=
=
0
&
&
event
.
lineno
=
=
=
0
)
{
isCrossOriginError
=
true
;
}
if
(
event
.
defaultPrevented
)
{
if
(
error
!
=
null
&
&
typeof
error
=
=
=
'
object
'
)
{
try
{
error
.
_suppressLogging
=
true
;
}
catch
(
inner
)
{
}
}
}
}
var
evtType
=
"
react
-
"
+
(
name
?
name
:
'
invokeguardedcallback
'
)
;
window
.
addEventListener
(
'
error
'
handleWindowError
)
;
fakeNode
.
addEventListener
(
evtType
callCallback
false
)
;
evt
.
initEvent
(
evtType
false
false
)
;
fakeNode
.
dispatchEvent
(
evt
)
;
if
(
windowEventDescriptor
)
{
Object
.
defineProperty
(
window
'
event
'
windowEventDescriptor
)
;
}
if
(
didError
)
{
if
(
!
didSetError
)
{
error
=
new
Error
(
'
An
error
was
thrown
inside
one
of
your
components
but
React
'
+
"
doesn
'
t
know
what
it
was
.
This
is
likely
due
to
browser
"
+
'
flakiness
.
React
does
its
best
to
preserve
the
"
Pause
on
'
+
'
exceptions
"
behavior
of
the
DevTools
which
requires
some
'
+
"
DEV
-
mode
only
tricks
.
It
'
s
possible
that
these
don
'
t
work
in
"
+
'
your
browser
.
Try
triggering
the
error
in
production
mode
'
+
'
or
switching
to
a
modern
browser
.
If
you
suspect
that
this
is
'
+
'
actually
an
issue
with
React
please
file
an
issue
.
'
)
;
}
else
if
(
isCrossOriginError
)
{
error
=
new
Error
(
"
A
cross
-
origin
error
was
thrown
.
React
doesn
'
t
have
access
to
"
+
'
the
actual
error
object
in
development
.
'
+
'
See
https
:
/
/
fb
.
me
/
react
-
crossorigin
-
error
for
more
information
.
'
)
;
}
this
.
onError
(
error
)
;
}
window
.
removeEventListener
(
'
error
'
handleWindowError
)
;
}
;
invokeGuardedCallbackImpl
=
invokeGuardedCallbackDev
;
}
}
var
invokeGuardedCallbackImpl
1
=
invokeGuardedCallbackImpl
;
var
hasError
=
false
;
var
caughtError
=
null
;
var
hasRethrowError
=
false
;
var
rethrowError
=
null
;
var
reporter
=
{
onError
:
function
(
error
)
{
hasError
=
true
;
caughtError
=
error
;
}
}
;
function
invokeGuardedCallback
(
name
func
context
a
b
c
d
e
f
)
{
hasError
=
false
;
caughtError
=
null
;
invokeGuardedCallbackImpl
1
.
apply
(
reporter
arguments
)
;
}
function
invokeGuardedCallbackAndCatchFirstError
(
name
func
context
a
b
c
d
e
f
)
{
invokeGuardedCallback
.
apply
(
this
arguments
)
;
if
(
hasError
)
{
var
error
=
clearCaughtError
(
)
;
if
(
!
hasRethrowError
)
{
hasRethrowError
=
true
;
rethrowError
=
error
;
}
}
}
function
rethrowCaughtError
(
)
{
if
(
hasRethrowError
)
{
var
error
=
rethrowError
;
hasRethrowError
=
false
;
rethrowError
=
null
;
throw
error
;
}
}
function
hasCaughtError
(
)
{
return
hasError
;
}
function
clearCaughtError
(
)
{
if
(
hasError
)
{
var
error
=
caughtError
;
hasError
=
false
;
caughtError
=
null
;
return
error
;
}
else
{
{
{
throw
Error
(
"
clearCaughtError
was
called
but
no
error
was
captured
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
}
var
warningWithoutStack
=
function
(
)
{
}
;
{
warningWithoutStack
=
function
(
condition
format
)
{
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
2
]
=
arguments
[
_key
]
;
}
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
warningWithoutStack
(
condition
format
.
.
.
args
)
requires
a
warning
'
+
'
message
argument
'
)
;
}
if
(
args
.
length
>
8
)
{
throw
new
Error
(
'
warningWithoutStack
(
)
currently
supports
at
most
8
arguments
.
'
)
;
}
if
(
condition
)
{
return
;
}
if
(
typeof
console
!
=
=
'
undefined
'
)
{
var
argsWithFormat
=
args
.
map
(
function
(
item
)
{
return
'
'
+
item
;
}
)
;
argsWithFormat
.
unshift
(
'
Warning
:
'
+
format
)
;
Function
.
prototype
.
apply
.
call
(
console
.
error
console
argsWithFormat
)
;
}
try
{
var
argIndex
=
0
;
var
message
=
'
Warning
:
'
+
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
;
throw
new
Error
(
message
)
;
}
catch
(
x
)
{
}
}
;
}
var
warningWithoutStack
1
=
warningWithoutStack
;
var
getFiberCurrentPropsFromNode
=
null
;
var
getInstanceFromNode
=
null
;
var
getNodeFromInstance
=
null
;
function
setComponentTree
(
getFiberCurrentPropsFromNodeImpl
getInstanceFromNodeImpl
getNodeFromInstanceImpl
)
{
getFiberCurrentPropsFromNode
=
getFiberCurrentPropsFromNodeImpl
;
getInstanceFromNode
=
getInstanceFromNodeImpl
;
getNodeFromInstance
=
getNodeFromInstanceImpl
;
{
!
(
getNodeFromInstance
&
&
getInstanceFromNode
)
?
warningWithoutStack
1
(
false
'
EventPluginUtils
.
setComponentTree
(
.
.
.
)
:
Injected
'
+
'
module
is
missing
getNodeFromInstance
or
getInstanceFromNode
.
'
)
:
void
0
;
}
}
var
validateEventDispatches
;
{
validateEventDispatches
=
function
(
event
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchInstances
=
event
.
_dispatchInstances
;
var
listenersIsArr
=
Array
.
isArray
(
dispatchListeners
)
;
var
listenersLen
=
listenersIsArr
?
dispatchListeners
.
length
:
dispatchListeners
?
1
:
0
;
var
instancesIsArr
=
Array
.
isArray
(
dispatchInstances
)
;
var
instancesLen
=
instancesIsArr
?
dispatchInstances
.
length
:
dispatchInstances
?
1
:
0
;
!
(
instancesIsArr
=
=
=
listenersIsArr
&
&
instancesLen
=
=
=
listenersLen
)
?
warningWithoutStack
1
(
false
'
EventPluginUtils
:
Invalid
event
.
'
)
:
void
0
;
}
;
}
function
executeDispatch
(
event
listener
inst
)
{
var
type
=
event
.
type
|
|
'
unknown
-
event
'
;
event
.
currentTarget
=
getNodeFromInstance
(
inst
)
;
invokeGuardedCallbackAndCatchFirstError
(
type
listener
undefined
event
)
;
event
.
currentTarget
=
null
;
}
function
executeDispatchesInOrder
(
event
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchInstances
=
event
.
_dispatchInstances
;
{
validateEventDispatches
(
event
)
;
}
if
(
Array
.
isArray
(
dispatchListeners
)
)
{
for
(
var
i
=
0
;
i
<
dispatchListeners
.
length
;
i
+
+
)
{
if
(
event
.
isPropagationStopped
(
)
)
{
break
;
}
executeDispatch
(
event
dispatchListeners
[
i
]
dispatchInstances
[
i
]
)
;
}
}
else
if
(
dispatchListeners
)
{
executeDispatch
(
event
dispatchListeners
dispatchInstances
)
;
}
event
.
_dispatchListeners
=
null
;
event
.
_dispatchInstances
=
null
;
}
function
accumulateInto
(
current
next
)
{
if
(
!
(
next
!
=
null
)
)
{
{
throw
Error
(
"
accumulateInto
(
.
.
.
)
:
Accumulated
items
must
not
be
null
or
undefined
.
"
)
;
}
}
if
(
current
=
=
null
)
{
return
next
;
}
if
(
Array
.
isArray
(
current
)
)
{
if
(
Array
.
isArray
(
next
)
)
{
current
.
push
.
apply
(
current
next
)
;
return
current
;
}
current
.
push
(
next
)
;
return
current
;
}
if
(
Array
.
isArray
(
next
)
)
{
return
[
current
]
.
concat
(
next
)
;
}
return
[
current
next
]
;
}
function
forEachAccumulated
(
arr
cb
scope
)
{
if
(
Array
.
isArray
(
arr
)
)
{
arr
.
forEach
(
cb
scope
)
;
}
else
if
(
arr
)
{
cb
.
call
(
scope
arr
)
;
}
}
var
eventQueue
=
null
;
var
executeDispatchesAndRelease
=
function
(
event
)
{
if
(
event
)
{
executeDispatchesInOrder
(
event
)
;
if
(
!
event
.
isPersistent
(
)
)
{
event
.
constructor
.
release
(
event
)
;
}
}
}
;
var
executeDispatchesAndReleaseTopLevel
=
function
(
e
)
{
return
executeDispatchesAndRelease
(
e
)
;
}
;
function
runEventsInBatch
(
events
)
{
if
(
events
!
=
=
null
)
{
eventQueue
=
accumulateInto
(
eventQueue
events
)
;
}
var
processingEventQueue
=
eventQueue
;
eventQueue
=
null
;
if
(
!
processingEventQueue
)
{
return
;
}
forEachAccumulated
(
processingEventQueue
executeDispatchesAndReleaseTopLevel
)
;
if
(
!
!
eventQueue
)
{
{
throw
Error
(
"
processEventQueue
(
)
:
Additional
events
were
enqueued
while
processing
an
event
queue
.
Support
for
this
has
not
yet
been
implemented
.
"
)
;
}
}
rethrowCaughtError
(
)
;
}
function
isInteractive
(
tag
)
{
return
tag
=
=
=
'
button
'
|
|
tag
=
=
=
'
input
'
|
|
tag
=
=
=
'
select
'
|
|
tag
=
=
=
'
textarea
'
;
}
function
shouldPreventMouseEvent
(
name
type
props
)
{
switch
(
name
)
{
case
'
onClick
'
:
case
'
onClickCapture
'
:
case
'
onDoubleClick
'
:
case
'
onDoubleClickCapture
'
:
case
'
onMouseDown
'
:
case
'
onMouseDownCapture
'
:
case
'
onMouseMove
'
:
case
'
onMouseMoveCapture
'
:
case
'
onMouseUp
'
:
case
'
onMouseUpCapture
'
:
return
!
!
(
props
.
disabled
&
&
isInteractive
(
type
)
)
;
default
:
return
false
;
}
}
var
injection
=
{
injectEventPluginOrder
:
injectEventPluginOrder
injectEventPluginsByName
:
injectEventPluginsByName
}
;
function
getListener
(
inst
registrationName
)
{
var
listener
;
var
stateNode
=
inst
.
stateNode
;
if
(
!
stateNode
)
{
return
null
;
}
var
props
=
getFiberCurrentPropsFromNode
(
stateNode
)
;
if
(
!
props
)
{
return
null
;
}
listener
=
props
[
registrationName
]
;
if
(
shouldPreventMouseEvent
(
registrationName
inst
.
type
props
)
)
{
return
null
;
}
if
(
!
(
!
listener
|
|
typeof
listener
=
=
=
'
function
'
)
)
{
{
throw
Error
(
"
Expected
"
+
registrationName
+
"
listener
to
be
a
function
instead
got
a
value
of
"
+
typeof
listener
+
"
type
.
"
)
;
}
}
return
listener
;
}
function
extractPluginEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
var
events
=
null
;
for
(
var
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
var
possiblePlugin
=
plugins
[
i
]
;
if
(
possiblePlugin
)
{
var
extractedEvents
=
possiblePlugin
.
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
;
if
(
extractedEvents
)
{
events
=
accumulateInto
(
events
extractedEvents
)
;
}
}
}
return
events
;
}
function
runExtractedPluginEventsInBatch
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
var
events
=
extractPluginEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
;
runEventsInBatch
(
events
)
;
}
var
FunctionComponent
=
0
;
var
ClassComponent
=
1
;
var
IndeterminateComponent
=
2
;
var
HostRoot
=
3
;
var
HostPortal
=
4
;
var
HostComponent
=
5
;
var
HostText
=
6
;
var
Fragment
=
7
;
var
Mode
=
8
;
var
ContextConsumer
=
9
;
var
ContextProvider
=
10
;
var
ForwardRef
=
11
;
var
Profiler
=
12
;
var
SuspenseComponent
=
13
;
var
MemoComponent
=
14
;
var
SimpleMemoComponent
=
15
;
var
LazyComponent
=
16
;
var
IncompleteClassComponent
=
17
;
var
DehydratedFragment
=
18
;
var
SuspenseListComponent
=
19
;
var
FundamentalComponent
=
20
;
var
ScopeComponent
=
21
;
var
ReactSharedInternals
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
if
(
!
ReactSharedInternals
.
hasOwnProperty
(
'
ReactCurrentDispatcher
'
)
)
{
ReactSharedInternals
.
ReactCurrentDispatcher
=
{
current
:
null
}
;
}
if
(
!
ReactSharedInternals
.
hasOwnProperty
(
'
ReactCurrentBatchConfig
'
)
)
{
ReactSharedInternals
.
ReactCurrentBatchConfig
=
{
suspense
:
null
}
;
}
var
BEFORE_SLASH_RE
=
/
^
(
.
*
)
[
\
\
\
/
]
/
;
var
describeComponentFrame
=
function
(
name
source
ownerName
)
{
var
sourceInfo
=
'
'
;
if
(
source
)
{
var
path
=
source
.
fileName
;
var
fileName
=
path
.
replace
(
BEFORE_SLASH_RE
'
'
)
;
{
if
(
/
^
index
\
.
/
.
test
(
fileName
)
)
{
var
match
=
path
.
match
(
BEFORE_SLASH_RE
)
;
if
(
match
)
{
var
pathBeforeSlash
=
match
[
1
]
;
if
(
pathBeforeSlash
)
{
var
folderName
=
pathBeforeSlash
.
replace
(
BEFORE_SLASH_RE
'
'
)
;
fileName
=
folderName
+
'
/
'
+
fileName
;
}
}
}
}
sourceInfo
=
'
(
at
'
+
fileName
+
'
:
'
+
source
.
lineNumber
+
'
)
'
;
}
else
if
(
ownerName
)
{
sourceInfo
=
'
(
created
by
'
+
ownerName
+
'
)
'
;
}
return
'
\
n
in
'
+
(
name
|
|
'
Unknown
'
)
+
sourceInfo
;
}
;
var
hasSymbol
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
for
;
var
REACT_ELEMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
element
'
)
:
0xeac7
;
var
REACT_PORTAL_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
portal
'
)
:
0xeaca
;
var
REACT_FRAGMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
fragment
'
)
:
0xeacb
;
var
REACT_STRICT_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
strict_mode
'
)
:
0xeacc
;
var
REACT_PROFILER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
profiler
'
)
:
0xead2
;
var
REACT_PROVIDER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
provider
'
)
:
0xeacd
;
var
REACT_CONTEXT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
context
'
)
:
0xeace
;
var
REACT_CONCURRENT_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
concurrent_mode
'
)
:
0xeacf
;
var
REACT_FORWARD_REF_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
forward_ref
'
)
:
0xead0
;
var
REACT_SUSPENSE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
suspense
'
)
:
0xead1
;
var
REACT_SUSPENSE_LIST_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
suspense_list
'
)
:
0xead8
;
var
REACT_MEMO_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
memo
'
)
:
0xead3
;
var
REACT_LAZY_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
lazy
'
)
:
0xead4
;
var
REACT_FUNDAMENTAL_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
fundamental
'
)
:
0xead5
;
var
REACT_RESPONDER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
responder
'
)
:
0xead6
;
var
REACT_SCOPE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
scope
'
)
:
0xead7
;
var
MAYBE_ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
function
getIteratorFn
(
maybeIterable
)
{
if
(
maybeIterable
=
=
=
null
|
|
typeof
maybeIterable
!
=
=
'
object
'
)
{
return
null
;
}
var
maybeIterator
=
MAYBE_ITERATOR_SYMBOL
&
&
maybeIterable
[
MAYBE_ITERATOR_SYMBOL
]
|
|
maybeIterable
[
FAUX_ITERATOR_SYMBOL
]
;
if
(
typeof
maybeIterator
=
=
=
'
function
'
)
{
return
maybeIterator
;
}
return
null
;
}
var
warning
=
warningWithoutStack
1
;
{
warning
=
function
(
condition
format
)
{
if
(
condition
)
{
return
;
}
var
ReactDebugCurrentFrame
=
ReactSharedInternals
.
ReactDebugCurrentFrame
;
var
stack
=
ReactDebugCurrentFrame
.
getStackAddendum
(
)
;
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
2
]
=
arguments
[
_key
]
;
}
warningWithoutStack
1
.
apply
(
void
0
[
false
format
+
'
%
s
'
]
.
concat
(
args
[
stack
]
)
)
;
}
;
}
var
warning
1
=
warning
;
var
Uninitialized
=
-
1
;
var
Pending
=
0
;
var
Resolved
=
1
;
var
Rejected
=
2
;
function
refineResolvedLazyComponent
(
lazyComponent
)
{
return
lazyComponent
.
_status
=
=
=
Resolved
?
lazyComponent
.
_result
:
null
;
}
function
initializeLazyComponentType
(
lazyComponent
)
{
if
(
lazyComponent
.
_status
=
=
=
Uninitialized
)
{
lazyComponent
.
_status
=
Pending
;
var
ctor
=
lazyComponent
.
_ctor
;
var
thenable
=
ctor
(
)
;
lazyComponent
.
_result
=
thenable
;
thenable
.
then
(
function
(
moduleObject
)
{
if
(
lazyComponent
.
_status
=
=
=
Pending
)
{
var
defaultExport
=
moduleObject
.
default
;
{
if
(
defaultExport
=
=
=
undefined
)
{
warning
1
(
false
'
lazy
:
Expected
the
result
of
a
dynamic
import
(
)
call
.
'
+
'
Instead
received
:
%
s
\
n
\
nYour
code
should
look
like
:
\
n
'
+
"
const
MyComponent
=
lazy
(
(
)
=
>
import
(
'
.
/
MyComponent
'
)
)
"
moduleObject
)
;
}
}
lazyComponent
.
_status
=
Resolved
;
lazyComponent
.
_result
=
defaultExport
;
}
}
function
(
error
)
{
if
(
lazyComponent
.
_status
=
=
=
Pending
)
{
lazyComponent
.
_status
=
Rejected
;
lazyComponent
.
_result
=
error
;
}
}
)
;
}
}
function
getWrappedName
(
outerType
innerType
wrapperName
)
{
var
functionName
=
innerType
.
displayName
|
|
innerType
.
name
|
|
'
'
;
return
outerType
.
displayName
|
|
(
functionName
!
=
=
'
'
?
wrapperName
+
"
(
"
+
functionName
+
"
)
"
:
wrapperName
)
;
}
function
getComponentName
(
type
)
{
if
(
type
=
=
null
)
{
return
null
;
}
{
if
(
typeof
type
.
tag
=
=
=
'
number
'
)
{
warningWithoutStack
1
(
false
'
Received
an
unexpected
object
in
getComponentName
(
)
.
'
+
'
This
is
likely
a
bug
in
React
.
Please
file
an
issue
.
'
)
;
}
}
if
(
typeof
type
=
=
=
'
function
'
)
{
return
type
.
displayName
|
|
type
.
name
|
|
null
;
}
if
(
typeof
type
=
=
=
'
string
'
)
{
return
type
;
}
switch
(
type
)
{
case
REACT_FRAGMENT_TYPE
:
return
'
Fragment
'
;
case
REACT_PORTAL_TYPE
:
return
'
Portal
'
;
case
REACT_PROFILER_TYPE
:
return
"
Profiler
"
;
case
REACT_STRICT_MODE_TYPE
:
return
'
StrictMode
'
;
case
REACT_SUSPENSE_TYPE
:
return
'
Suspense
'
;
case
REACT_SUSPENSE_LIST_TYPE
:
return
'
SuspenseList
'
;
}
if
(
typeof
type
=
=
=
'
object
'
)
{
switch
(
type
.
typeof
)
{
case
REACT_CONTEXT_TYPE
:
return
'
Context
.
Consumer
'
;
case
REACT_PROVIDER_TYPE
:
return
'
Context
.
Provider
'
;
case
REACT_FORWARD_REF_TYPE
:
return
getWrappedName
(
type
type
.
render
'
ForwardRef
'
)
;
case
REACT_MEMO_TYPE
:
return
getComponentName
(
type
.
type
)
;
case
REACT_LAZY_TYPE
:
{
var
thenable
=
type
;
var
resolvedThenable
=
refineResolvedLazyComponent
(
thenable
)
;
if
(
resolvedThenable
)
{
return
getComponentName
(
resolvedThenable
)
;
}
break
;
}
}
}
return
null
;
}
var
ReactDebugCurrentFrame
=
ReactSharedInternals
.
ReactDebugCurrentFrame
;
function
describeFiber
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
HostRoot
:
case
HostPortal
:
case
HostText
:
case
Fragment
:
case
ContextProvider
:
case
ContextConsumer
:
return
'
'
;
default
:
var
owner
=
fiber
.
_debugOwner
;
var
source
=
fiber
.
_debugSource
;
var
name
=
getComponentName
(
fiber
.
type
)
;
var
ownerName
=
null
;
if
(
owner
)
{
ownerName
=
getComponentName
(
owner
.
type
)
;
}
return
describeComponentFrame
(
name
source
ownerName
)
;
}
}
function
getStackByFiberInDevAndProd
(
workInProgress
)
{
var
info
=
'
'
;
var
node
=
workInProgress
;
do
{
info
+
=
describeFiber
(
node
)
;
node
=
node
.
return
;
}
while
(
node
)
;
return
info
;
}
var
current
=
null
;
var
phase
=
null
;
function
getCurrentFiberOwnerNameInDevOrNull
(
)
{
{
if
(
current
=
=
=
null
)
{
return
null
;
}
var
owner
=
current
.
_debugOwner
;
if
(
owner
!
=
=
null
&
&
typeof
owner
!
=
=
'
undefined
'
)
{
return
getComponentName
(
owner
.
type
)
;
}
}
return
null
;
}
function
getCurrentFiberStackInDev
(
)
{
{
if
(
current
=
=
=
null
)
{
return
'
'
;
}
return
getStackByFiberInDevAndProd
(
current
)
;
}
return
'
'
;
}
function
resetCurrentFiber
(
)
{
{
ReactDebugCurrentFrame
.
getCurrentStack
=
null
;
current
=
null
;
phase
=
null
;
}
}
function
setCurrentFiber
(
fiber
)
{
{
ReactDebugCurrentFrame
.
getCurrentStack
=
getCurrentFiberStackInDev
;
current
=
fiber
;
phase
=
null
;
}
}
function
setCurrentPhase
(
lifeCyclePhase
)
{
{
phase
=
lifeCyclePhase
;
}
}
var
canUseDOM
=
!
!
(
typeof
window
!
=
=
'
undefined
'
&
&
typeof
window
.
document
!
=
=
'
undefined
'
&
&
typeof
window
.
document
.
createElement
!
=
=
'
undefined
'
)
;
function
endsWith
(
subject
search
)
{
var
length
=
subject
.
length
;
return
subject
.
substring
(
length
-
search
.
length
length
)
=
=
=
search
;
}
var
ReactInternals
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_assign
=
ReactInternals
.
assign
;
var
PLUGIN_EVENT_SYSTEM
=
1
;
var
RESPONDER_EVENT_SYSTEM
=
1
<
<
1
;
var
IS_PASSIVE
=
1
<
<
2
;
var
IS_ACTIVE
=
1
<
<
3
;
var
PASSIVE_NOT_SUPPORTED
=
1
<
<
4
;
var
IS_REPLAYED
=
1
<
<
5
;
var
restoreImpl
=
null
;
var
restoreTarget
=
null
;
var
restoreQueue
=
null
;
function
restoreStateOfTarget
(
target
)
{
var
internalInstance
=
getInstanceFromNode
(
target
)
;
if
(
!
internalInstance
)
{
return
;
}
if
(
!
(
typeof
restoreImpl
=
=
=
'
function
'
)
)
{
{
throw
Error
(
"
setRestoreImplementation
(
)
needs
to
be
called
to
handle
a
target
for
controlled
events
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
var
props
=
getFiberCurrentPropsFromNode
(
internalInstance
.
stateNode
)
;
restoreImpl
(
internalInstance
.
stateNode
internalInstance
.
type
props
)
;
}
function
setRestoreImplementation
(
impl
)
{
restoreImpl
=
impl
;
}
function
enqueueStateRestore
(
target
)
{
if
(
restoreTarget
)
{
if
(
restoreQueue
)
{
restoreQueue
.
push
(
target
)
;
}
else
{
restoreQueue
=
[
target
]
;
}
}
else
{
restoreTarget
=
target
;
}
}
function
needsStateRestore
(
)
{
return
restoreTarget
!
=
=
null
|
|
restoreQueue
!
=
=
null
;
}
function
restoreStateIfNeeded
(
)
{
if
(
!
restoreTarget
)
{
return
;
}
var
target
=
restoreTarget
;
var
queuedTargets
=
restoreQueue
;
restoreTarget
=
null
;
restoreQueue
=
null
;
restoreStateOfTarget
(
target
)
;
if
(
queuedTargets
)
{
for
(
var
i
=
0
;
i
<
queuedTargets
.
length
;
i
+
+
)
{
restoreStateOfTarget
(
queuedTargets
[
i
]
)
;
}
}
}
var
enableUserTimingAPI
=
true
;
var
debugRenderPhaseSideEffectsForStrictMode
=
true
;
var
replayFailedUnitOfWorkWithInvokeGuardedCallback
=
true
;
var
warnAboutDeprecatedLifecycles
=
true
;
var
enableProfilerTimer
=
true
;
var
enableSchedulerTracing
=
true
;
var
enableSuspenseServerRenderer
=
false
;
var
enableSelectiveHydration
=
false
;
var
disableJavaScriptURLs
=
false
;
var
disableInputAttributeSyncing
=
false
;
var
exposeConcurrentModeAPIs
=
false
;
var
warnAboutShorthandPropertyCollision
=
false
;
var
enableFlareAPI
=
false
;
var
enableFundamentalAPI
=
false
;
var
enableScopeAPI
=
false
;
var
warnAboutUnmockedScheduler
=
false
;
var
flushSuspenseFallbacksInTests
=
true
;
var
enableSuspenseCallback
=
false
;
var
warnAboutDefaultPropsOnFunctionComponents
=
false
;
var
warnAboutStringRefs
=
false
;
var
disableLegacyContext
=
false
;
var
disableSchedulerTimeoutBasedOnReactExpirationTime
=
false
;
var
enableTrustedTypesIntegration
=
false
;
var
batchedUpdatesImpl
=
function
(
fn
bookkeeping
)
{
return
fn
(
bookkeeping
)
;
}
;
var
discreteUpdatesImpl
=
function
(
fn
a
b
c
)
{
return
fn
(
a
b
c
)
;
}
;
var
flushDiscreteUpdatesImpl
=
function
(
)
{
}
;
var
batchedEventUpdatesImpl
=
batchedUpdatesImpl
;
var
isInsideEventHandler
=
false
;
var
isBatchingEventUpdates
=
false
;
function
finishEventHandler
(
)
{
var
controlledComponentsHavePendingUpdates
=
needsStateRestore
(
)
;
if
(
controlledComponentsHavePendingUpdates
)
{
flushDiscreteUpdatesImpl
(
)
;
restoreStateIfNeeded
(
)
;
}
}
function
batchedUpdates
(
fn
bookkeeping
)
{
if
(
isInsideEventHandler
)
{
return
fn
(
bookkeeping
)
;
}
isInsideEventHandler
=
true
;
try
{
return
batchedUpdatesImpl
(
fn
bookkeeping
)
;
}
finally
{
isInsideEventHandler
=
false
;
finishEventHandler
(
)
;
}
}
function
batchedEventUpdates
(
fn
a
b
)
{
if
(
isBatchingEventUpdates
)
{
return
fn
(
a
b
)
;
}
isBatchingEventUpdates
=
true
;
try
{
return
batchedEventUpdatesImpl
(
fn
a
b
)
;
}
finally
{
isBatchingEventUpdates
=
false
;
finishEventHandler
(
)
;
}
}
function
executeUserEventHandler
(
fn
value
)
{
var
previouslyInEventHandler
=
isInsideEventHandler
;
try
{
isInsideEventHandler
=
true
;
var
type
=
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
?
value
.
type
:
'
'
;
invokeGuardedCallbackAndCatchFirstError
(
type
fn
undefined
value
)
;
}
finally
{
isInsideEventHandler
=
previouslyInEventHandler
;
}
}
function
discreteUpdates
(
fn
a
b
c
)
{
var
prevIsInsideEventHandler
=
isInsideEventHandler
;
isInsideEventHandler
=
true
;
try
{
return
discreteUpdatesImpl
(
fn
a
b
c
)
;
}
finally
{
isInsideEventHandler
=
prevIsInsideEventHandler
;
if
(
!
isInsideEventHandler
)
{
finishEventHandler
(
)
;
}
}
}
var
lastFlushedEventTimeStamp
=
0
;
function
flushDiscreteUpdatesIfNeeded
(
timeStamp
)
{
if
(
!
isInsideEventHandler
&
&
(
!
enableFlareAPI
|
|
timeStamp
=
=
=
0
|
|
lastFlushedEventTimeStamp
!
=
=
timeStamp
)
)
{
lastFlushedEventTimeStamp
=
timeStamp
;
flushDiscreteUpdatesImpl
(
)
;
}
}
function
setBatchingImplementation
(
_batchedUpdatesImpl
_discreteUpdatesImpl
_flushDiscreteUpdatesImpl
_batchedEventUpdatesImpl
)
{
batchedUpdatesImpl
=
_batchedUpdatesImpl
;
discreteUpdatesImpl
=
_discreteUpdatesImpl
;
flushDiscreteUpdatesImpl
=
_flushDiscreteUpdatesImpl
;
batchedEventUpdatesImpl
=
_batchedEventUpdatesImpl
;
}
var
DiscreteEvent
=
0
;
var
UserBlockingEvent
=
1
;
var
ContinuousEvent
=
2
;
var
ReactInternals
1
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_ReactInternals
Sched
=
ReactInternals
1
.
Scheduler
;
var
unstable_cancelCallback
=
_ReactInternals
Sched
.
unstable_cancelCallback
;
var
unstable_now
=
_ReactInternals
Sched
.
unstable_now
;
var
unstable_scheduleCallback
=
_ReactInternals
Sched
.
unstable_scheduleCallback
;
var
unstable_shouldYield
=
_ReactInternals
Sched
.
unstable_shouldYield
;
var
unstable_requestPaint
=
_ReactInternals
Sched
.
unstable_requestPaint
;
var
unstable_getFirstCallbackNode
=
_ReactInternals
Sched
.
unstable_getFirstCallbackNode
;
var
unstable_runWithPriority
=
_ReactInternals
Sched
.
unstable_runWithPriority
;
var
unstable_next
=
_ReactInternals
Sched
.
unstable_next
;
var
unstable_continueExecution
=
_ReactInternals
Sched
.
unstable_continueExecution
;
var
unstable_pauseExecution
=
_ReactInternals
Sched
.
unstable_pauseExecution
;
var
unstable_getCurrentPriorityLevel
=
_ReactInternals
Sched
.
unstable_getCurrentPriorityLevel
;
var
unstable_ImmediatePriority
=
_ReactInternals
Sched
.
unstable_ImmediatePriority
;
var
unstable_UserBlockingPriority
=
_ReactInternals
Sched
.
unstable_UserBlockingPriority
;
var
unstable_NormalPriority
=
_ReactInternals
Sched
.
unstable_NormalPriority
;
var
unstable_LowPriority
=
_ReactInternals
Sched
.
unstable_LowPriority
;
var
unstable_IdlePriority
=
_ReactInternals
Sched
.
unstable_IdlePriority
;
var
unstable_forceFrameRate
=
_ReactInternals
Sched
.
unstable_forceFrameRate
;
var
unstable_flushAllWithoutAsserting
=
_ReactInternals
Sched
.
unstable_flushAllWithoutAsserting
;
var
UserBlockingPriority
=
unstable_UserBlockingPriority
;
var
runWithPriority
=
unstable_runWithPriority
;
var
listenToResponderEventTypesImpl
;
function
setListenToResponderEventTypes
(
_listenToResponderEventTypesImpl
)
{
listenToResponderEventTypesImpl
=
_listenToResponderEventTypesImpl
;
}
var
rootEventTypesToEventResponderInstances
=
new
Map
(
)
;
var
DoNotPropagateToNextResponder
=
0
;
var
PropagateToNextResponder
=
1
;
var
currentTimeStamp
=
0
;
var
currentInstance
=
null
;
var
currentDocument
=
null
;
var
currentPropagationBehavior
=
DoNotPropagateToNextResponder
;
var
eventResponderContext
=
{
dispatchEvent
:
function
(
eventValue
eventListener
eventPriority
)
{
validateResponderContext
(
)
;
validateEventValue
(
eventValue
)
;
switch
(
eventPriority
)
{
case
DiscreteEvent
:
{
flushDiscreteUpdatesIfNeeded
(
currentTimeStamp
)
;
discreteUpdates
(
function
(
)
{
return
executeUserEventHandler
(
eventListener
eventValue
)
;
}
)
;
break
;
}
case
UserBlockingEvent
:
{
runWithPriority
(
UserBlockingPriority
function
(
)
{
return
executeUserEventHandler
(
eventListener
eventValue
)
;
}
)
;
break
;
}
case
ContinuousEvent
:
{
executeUserEventHandler
(
eventListener
eventValue
)
;
break
;
}
}
}
isTargetWithinResponder
:
function
(
target
)
{
validateResponderContext
(
)
;
if
(
target
!
=
null
)
{
var
fiber
=
getClosestInstanceFromNode
(
target
)
;
var
responderFiber
=
currentInstance
.
fiber
;
while
(
fiber
!
=
=
null
)
{
if
(
fiber
=
=
=
responderFiber
|
|
fiber
.
alternate
=
=
=
responderFiber
)
{
return
true
;
}
fiber
=
fiber
.
return
;
}
}
return
false
;
}
isTargetWithinResponderScope
:
function
(
target
)
{
validateResponderContext
(
)
;
var
componentInstance
=
currentInstance
;
var
responder
=
componentInstance
.
responder
;
if
(
target
!
=
null
)
{
var
fiber
=
getClosestInstanceFromNode
(
target
)
;
var
responderFiber
=
currentInstance
.
fiber
;
while
(
fiber
!
=
=
null
)
{
if
(
fiber
=
=
=
responderFiber
|
|
fiber
.
alternate
=
=
=
responderFiber
)
{
return
true
;
}
if
(
doesFiberHaveResponder
(
fiber
responder
)
)
{
return
false
;
}
fiber
=
fiber
.
return
;
}
}
return
false
;
}
isTargetWithinNode
:
function
(
childTarget
parentTarget
)
{
validateResponderContext
(
)
;
var
childFiber
=
getClosestInstanceFromNode
(
childTarget
)
;
var
parentFiber
=
getClosestInstanceFromNode
(
parentTarget
)
;
if
(
childFiber
!
=
null
&
&
parentFiber
!
=
null
)
{
var
parentAlternateFiber
=
parentFiber
.
alternate
;
var
node
=
childFiber
;
while
(
node
!
=
=
null
)
{
if
(
node
=
=
=
parentFiber
|
|
node
=
=
=
parentAlternateFiber
)
{
return
true
;
}
node
=
node
.
return
;
}
return
false
;
}
return
parentTarget
.
contains
(
childTarget
)
;
}
addRootEventTypes
:
function
(
rootEventTypes
)
{
validateResponderContext
(
)
;
listenToResponderEventTypesImpl
(
rootEventTypes
currentDocument
)
;
for
(
var
i
=
0
;
i
<
rootEventTypes
.
length
;
i
+
+
)
{
var
rootEventType
=
rootEventTypes
[
i
]
;
var
eventResponderInstance
=
currentInstance
;
registerRootEventType
(
rootEventType
eventResponderInstance
)
;
}
}
removeRootEventTypes
:
function
(
rootEventTypes
)
{
validateResponderContext
(
)
;
for
(
var
i
=
0
;
i
<
rootEventTypes
.
length
;
i
+
+
)
{
var
rootEventType
=
rootEventTypes
[
i
]
;
var
rootEventResponders
=
rootEventTypesToEventResponderInstances
.
get
(
rootEventType
)
;
var
rootEventTypesSet
=
currentInstance
.
rootEventTypes
;
if
(
rootEventTypesSet
!
=
=
null
)
{
rootEventTypesSet
.
delete
(
rootEventType
)
;
}
if
(
rootEventResponders
!
=
=
undefined
)
{
rootEventResponders
.
delete
(
currentInstance
)
;
}
}
}
getActiveDocument
:
getActiveDocument
objectAssign
:
_assign
getTimeStamp
:
function
(
)
{
validateResponderContext
(
)
;
return
currentTimeStamp
;
}
isTargetWithinHostComponent
:
function
(
target
elementType
)
{
validateResponderContext
(
)
;
var
fiber
=
getClosestInstanceFromNode
(
target
)
;
while
(
fiber
!
=
=
null
)
{
if
(
fiber
.
tag
=
=
=
HostComponent
&
&
fiber
.
type
=
=
=
elementType
)
{
return
true
;
}
fiber
=
fiber
.
return
;
}
return
false
;
}
continuePropagation
:
function
(
)
{
currentPropagationBehavior
=
PropagateToNextResponder
;
}
enqueueStateRestore
:
enqueueStateRestore
getResponderNode
:
function
(
)
{
validateResponderContext
(
)
;
var
responderFiber
=
currentInstance
.
fiber
;
if
(
responderFiber
.
tag
=
=
=
ScopeComponent
)
{
return
null
;
}
return
responderFiber
.
stateNode
;
}
}
;
function
validateEventValue
(
eventValue
)
{
if
(
typeof
eventValue
=
=
=
'
object
'
&
&
eventValue
!
=
=
null
)
{
var
target
=
eventValue
.
target
type
=
eventValue
.
type
timeStamp
=
eventValue
.
timeStamp
;
if
(
target
=
=
null
|
|
type
=
=
null
|
|
timeStamp
=
=
null
)
{
throw
new
Error
(
'
context
.
dispatchEvent
:
"
target
"
"
timeStamp
"
and
"
type
"
fields
on
event
object
are
required
.
'
)
;
}
var
showWarning
=
function
(
name
)
{
{
warning
1
(
false
'
%
s
is
not
available
on
event
objects
created
from
event
responder
modules
(
React
Flare
)
.
'
+
'
Try
wrapping
in
a
conditional
i
.
e
.
if
(
event
.
type
!
=
=
"
press
"
)
{
event
.
%
s
}
'
name
name
)
;
}
}
;
eventValue
.
isDefaultPrevented
=
function
(
)
{
{
showWarning
(
'
isDefaultPrevented
(
)
'
)
;
}
}
;
eventValue
.
isPropagationStopped
=
function
(
)
{
{
showWarning
(
'
isPropagationStopped
(
)
'
)
;
}
}
;
Object
.
defineProperty
(
eventValue
'
nativeEvent
'
{
get
:
function
(
)
{
{
showWarning
(
'
nativeEvent
'
)
;
}
}
}
)
;
}
}
function
doesFiberHaveResponder
(
fiber
responder
)
{
var
tag
=
fiber
.
tag
;
if
(
tag
=
=
=
HostComponent
|
|
tag
=
=
=
ScopeComponent
)
{
var
dependencies
=
fiber
.
dependencies
;
if
(
dependencies
!
=
=
null
)
{
var
respondersMap
=
dependencies
.
responders
;
if
(
respondersMap
!
=
=
null
&
&
respondersMap
.
has
(
responder
)
)
{
return
true
;
}
}
}
return
false
;
}
function
getActiveDocument
(
)
{
return
currentDocument
;
}
function
createDOMResponderEvent
(
topLevelType
nativeEvent
nativeEventTarget
passive
passiveSupported
)
{
var
_ref
=
nativeEvent
buttons
=
_ref
.
buttons
pointerType
=
_ref
.
pointerType
;
var
eventPointerType
=
'
'
;
if
(
pointerType
!
=
=
undefined
)
{
eventPointerType
=
pointerType
;
}
else
if
(
nativeEvent
.
key
!
=
=
undefined
)
{
eventPointerType
=
'
keyboard
'
;
}
else
if
(
buttons
!
=
=
undefined
)
{
eventPointerType
=
'
mouse
'
;
}
else
if
(
nativeEvent
.
changedTouches
!
=
=
undefined
)
{
eventPointerType
=
'
touch
'
;
}
return
{
nativeEvent
:
nativeEvent
passive
:
passive
passiveSupported
:
passiveSupported
pointerType
:
eventPointerType
target
:
nativeEventTarget
type
:
topLevelType
}
;
}
function
responderEventTypesContainType
(
eventTypes
type
)
{
for
(
var
i
=
0
len
=
eventTypes
.
length
;
i
<
len
;
i
+
+
)
{
if
(
eventTypes
[
i
]
=
=
=
type
)
{
return
true
;
}
}
return
false
;
}
function
validateResponderTargetEventTypes
(
eventType
responder
)
{
var
targetEventTypes
=
responder
.
targetEventTypes
;
if
(
targetEventTypes
!
=
=
null
)
{
return
responderEventTypesContainType
(
targetEventTypes
eventType
)
;
}
return
false
;
}
function
traverseAndHandleEventResponderInstances
(
topLevelType
targetFiber
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
var
isPassiveEvent
=
(
eventSystemFlags
&
IS_PASSIVE
)
!
=
=
0
;
var
isPassiveSupported
=
(
eventSystemFlags
&
PASSIVE_NOT_SUPPORTED
)
=
=
=
0
;
var
isPassive
=
isPassiveEvent
|
|
!
isPassiveSupported
;
var
eventType
=
isPassive
?
topLevelType
:
topLevelType
+
'
_active
'
;
var
visitedResponders
=
new
Set
(
)
;
var
responderEvent
=
createDOMResponderEvent
(
topLevelType
nativeEvent
nativeEventTarget
isPassiveEvent
isPassiveSupported
)
;
var
node
=
targetFiber
;
var
insidePortal
=
false
;
while
(
node
!
=
=
null
)
{
var
_node
=
node
dependencies
=
_node
.
dependencies
tag
=
_node
.
tag
;
if
(
tag
=
=
=
HostPortal
)
{
insidePortal
=
true
;
}
else
if
(
(
tag
=
=
=
HostComponent
|
|
tag
=
=
=
ScopeComponent
)
&
&
dependencies
!
=
=
null
)
{
var
respondersMap
=
dependencies
.
responders
;
if
(
respondersMap
!
=
=
null
)
{
var
responderInstances
=
Array
.
from
(
respondersMap
.
values
(
)
)
;
for
(
var
i
=
0
length
=
responderInstances
.
length
;
i
<
length
;
i
+
+
)
{
var
responderInstance
=
responderInstances
[
i
]
;
var
props
=
responderInstance
.
props
responder
=
responderInstance
.
responder
state
=
responderInstance
.
state
;
if
(
!
visitedResponders
.
has
(
responder
)
&
&
validateResponderTargetEventTypes
(
eventType
responder
)
&
&
(
!
insidePortal
|
|
responder
.
targetPortalPropagation
)
)
{
visitedResponders
.
add
(
responder
)
;
var
onEvent
=
responder
.
onEvent
;
if
(
onEvent
!
=
=
null
)
{
currentInstance
=
responderInstance
;
onEvent
(
responderEvent
eventResponderContext
props
state
)
;
if
(
currentPropagationBehavior
=
=
=
PropagateToNextResponder
)
{
visitedResponders
.
delete
(
responder
)
;
currentPropagationBehavior
=
DoNotPropagateToNextResponder
;
}
}
}
}
}
}
node
=
node
.
return
;
}
var
rootEventResponderInstances
=
rootEventTypesToEventResponderInstances
.
get
(
eventType
)
;
if
(
rootEventResponderInstances
!
=
=
undefined
)
{
var
_responderInstances
=
Array
.
from
(
rootEventResponderInstances
)
;
for
(
var
_i
=
0
;
_i
<
_responderInstances
.
length
;
_i
+
+
)
{
var
_responderInstance
=
_responderInstances
[
_i
]
;
var
props
=
_responderInstance
.
props
responder
=
_responderInstance
.
responder
state
=
_responderInstance
.
state
;
var
onRootEvent
=
responder
.
onRootEvent
;
if
(
onRootEvent
!
=
=
null
)
{
currentInstance
=
_responderInstance
;
onRootEvent
(
responderEvent
eventResponderContext
props
state
)
;
}
}
}
}
function
mountEventResponder
(
responder
responderInstance
props
state
)
{
var
onMount
=
responder
.
onMount
;
if
(
onMount
!
=
=
null
)
{
var
previousInstance
=
currentInstance
;
currentInstance
=
responderInstance
;
try
{
batchedEventUpdates
(
function
(
)
{
onMount
(
eventResponderContext
props
state
)
;
}
)
;
}
finally
{
currentInstance
=
previousInstance
;
}
}
}
function
unmountEventResponder
(
responderInstance
)
{
var
responder
=
responderInstance
.
responder
;
var
onUnmount
=
responder
.
onUnmount
;
if
(
onUnmount
!
=
=
null
)
{
var
props
=
responderInstance
.
props
state
=
responderInstance
.
state
;
var
previousInstance
=
currentInstance
;
currentInstance
=
responderInstance
;
try
{
batchedEventUpdates
(
function
(
)
{
onUnmount
(
eventResponderContext
props
state
)
;
}
)
;
}
finally
{
currentInstance
=
previousInstance
;
}
}
var
rootEventTypesSet
=
responderInstance
.
rootEventTypes
;
if
(
rootEventTypesSet
!
=
=
null
)
{
var
rootEventTypes
=
Array
.
from
(
rootEventTypesSet
)
;
for
(
var
i
=
0
;
i
<
rootEventTypes
.
length
;
i
+
+
)
{
var
topLevelEventType
=
rootEventTypes
[
i
]
;
var
rootEventResponderInstances
=
rootEventTypesToEventResponderInstances
.
get
(
topLevelEventType
)
;
if
(
rootEventResponderInstances
!
=
=
undefined
)
{
rootEventResponderInstances
.
delete
(
responderInstance
)
;
}
}
}
}
function
validateResponderContext
(
)
{
if
(
!
(
currentInstance
!
=
=
null
)
)
{
{
throw
Error
(
"
An
event
responder
context
was
used
outside
of
an
event
cycle
.
"
)
;
}
}
}
function
dispatchEventForResponderEventSystem
(
topLevelType
targetFiber
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
if
(
enableFlareAPI
)
{
var
previousInstance
=
currentInstance
;
var
previousTimeStamp
=
currentTimeStamp
;
var
previousDocument
=
currentDocument
;
var
previousPropagationBehavior
=
currentPropagationBehavior
;
currentPropagationBehavior
=
DoNotPropagateToNextResponder
;
currentDocument
=
nativeEventTarget
.
nodeType
=
=
=
9
?
nativeEventTarget
:
nativeEventTarget
.
ownerDocument
;
currentTimeStamp
=
nativeEvent
.
timeStamp
;
try
{
batchedEventUpdates
(
function
(
)
{
traverseAndHandleEventResponderInstances
(
topLevelType
targetFiber
nativeEvent
nativeEventTarget
eventSystemFlags
)
;
}
)
;
}
finally
{
currentInstance
=
previousInstance
;
currentTimeStamp
=
previousTimeStamp
;
currentDocument
=
previousDocument
;
currentPropagationBehavior
=
previousPropagationBehavior
;
}
}
}
function
addRootEventTypesForResponderInstance
(
responderInstance
rootEventTypes
)
{
for
(
var
i
=
0
;
i
<
rootEventTypes
.
length
;
i
+
+
)
{
var
rootEventType
=
rootEventTypes
[
i
]
;
registerRootEventType
(
rootEventType
responderInstance
)
;
}
}
function
registerRootEventType
(
rootEventType
eventResponderInstance
)
{
var
rootEventResponderInstances
=
rootEventTypesToEventResponderInstances
.
get
(
rootEventType
)
;
if
(
rootEventResponderInstances
=
=
=
undefined
)
{
rootEventResponderInstances
=
new
Set
(
)
;
rootEventTypesToEventResponderInstances
.
set
(
rootEventType
rootEventResponderInstances
)
;
}
var
rootEventTypesSet
=
eventResponderInstance
.
rootEventTypes
;
if
(
rootEventTypesSet
=
=
=
null
)
{
rootEventTypesSet
=
eventResponderInstance
.
rootEventTypes
=
new
Set
(
)
;
}
if
(
!
!
rootEventTypesSet
.
has
(
rootEventType
)
)
{
{
throw
Error
(
"
addRootEventTypes
(
)
found
a
duplicate
root
event
type
of
\
"
"
+
rootEventType
+
"
\
"
.
This
might
be
because
the
event
type
exists
in
the
event
responder
\
"
rootEventTypes
\
"
array
or
because
of
a
previous
addRootEventTypes
(
)
using
this
root
event
type
.
"
)
;
}
}
rootEventTypesSet
.
add
(
rootEventType
)
;
rootEventResponderInstances
.
add
(
eventResponderInstance
)
;
}
var
RESERVED
=
0
;
var
STRING
=
1
;
var
BOOLEANISH_STRING
=
2
;
var
BOOLEAN
=
3
;
var
OVERLOADED_BOOLEAN
=
4
;
var
NUMERIC
=
5
;
var
POSITIVE_NUMERIC
=
6
;
var
ATTRIBUTE_NAME_START_CHAR
=
"
:
A
-
Z_a
-
z
\
\
u00C0
-
\
\
u00D6
\
\
u00D8
-
\
\
u00F6
\
\
u00F8
-
\
\
u02FF
\
\
u0370
-
\
\
u037D
\
\
u037F
-
\
\
u1FFF
\
\
u200C
-
\
\
u200D
\
\
u2070
-
\
\
u218F
\
\
u2C00
-
\
\
u2FEF
\
\
u3001
-
\
\
uD7FF
\
\
uF900
-
\
\
uFDCF
\
\
uFDF0
-
\
\
uFFFD
"
;
var
ATTRIBUTE_NAME_CHAR
=
ATTRIBUTE_NAME_START_CHAR
+
"
\
\
-
.
0
-
9
\
\
u00B7
\
\
u0300
-
\
\
u036F
\
\
u203F
-
\
\
u2040
"
;
var
ROOT_ATTRIBUTE_NAME
=
'
data
-
reactroot
'
;
var
VALID_ATTRIBUTE_NAME_REGEX
=
new
RegExp
(
'
^
[
'
+
ATTRIBUTE_NAME_START_CHAR
+
'
]
[
'
+
ATTRIBUTE_NAME_CHAR
+
'
]
*
'
)
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
var
illegalAttributeNameCache
=
{
}
;
var
validatedAttributeNameCache
=
{
}
;
function
isAttributeNameSafe
(
attributeName
)
{
if
(
hasOwnProperty
.
call
(
validatedAttributeNameCache
attributeName
)
)
{
return
true
;
}
if
(
hasOwnProperty
.
call
(
illegalAttributeNameCache
attributeName
)
)
{
return
false
;
}
if
(
VALID_ATTRIBUTE_NAME_REGEX
.
test
(
attributeName
)
)
{
validatedAttributeNameCache
[
attributeName
]
=
true
;
return
true
;
}
illegalAttributeNameCache
[
attributeName
]
=
true
;
{
warning
1
(
false
'
Invalid
attribute
name
:
%
s
'
attributeName
)
;
}
return
false
;
}
function
shouldIgnoreAttribute
(
name
propertyInfo
isCustomComponentTag
)
{
if
(
propertyInfo
!
=
=
null
)
{
return
propertyInfo
.
type
=
=
=
RESERVED
;
}
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
name
.
length
>
2
&
&
(
name
[
0
]
=
=
=
'
o
'
|
|
name
[
0
]
=
=
=
'
O
'
)
&
&
(
name
[
1
]
=
=
=
'
n
'
|
|
name
[
1
]
=
=
=
'
N
'
)
)
{
return
true
;
}
return
false
;
}
function
shouldRemoveAttributeWithWarning
(
name
value
propertyInfo
isCustomComponentTag
)
{
if
(
propertyInfo
!
=
=
null
&
&
propertyInfo
.
type
=
=
=
RESERVED
)
{
return
false
;
}
switch
(
typeof
value
)
{
case
'
function
'
:
case
'
symbol
'
:
return
true
;
case
'
boolean
'
:
{
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
propertyInfo
!
=
=
null
)
{
return
!
propertyInfo
.
acceptsBooleans
;
}
else
{
var
prefix
=
name
.
toLowerCase
(
)
.
slice
(
0
5
)
;
return
prefix
!
=
=
'
data
-
'
&
&
prefix
!
=
=
'
aria
-
'
;
}
}
default
:
return
false
;
}
}
function
shouldRemoveAttribute
(
name
value
propertyInfo
isCustomComponentTag
)
{
if
(
value
=
=
=
null
|
|
typeof
value
=
=
=
'
undefined
'
)
{
return
true
;
}
if
(
shouldRemoveAttributeWithWarning
(
name
value
propertyInfo
isCustomComponentTag
)
)
{
return
true
;
}
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
propertyInfo
!
=
=
null
)
{
switch
(
propertyInfo
.
type
)
{
case
BOOLEAN
:
return
!
value
;
case
OVERLOADED_BOOLEAN
:
return
value
=
=
=
false
;
case
NUMERIC
:
return
isNaN
(
value
)
;
case
POSITIVE_NUMERIC
:
return
isNaN
(
value
)
|
|
value
<
1
;
}
}
return
false
;
}
function
getPropertyInfo
(
name
)
{
return
properties
.
hasOwnProperty
(
name
)
?
properties
[
name
]
:
null
;
}
function
PropertyInfoRecord
(
name
type
mustUseProperty
attributeName
attributeNamespace
sanitizeURL
)
{
this
.
acceptsBooleans
=
type
=
=
=
BOOLEANISH_STRING
|
|
type
=
=
=
BOOLEAN
|
|
type
=
=
=
OVERLOADED_BOOLEAN
;
this
.
attributeName
=
attributeName
;
this
.
attributeNamespace
=
attributeNamespace
;
this
.
mustUseProperty
=
mustUseProperty
;
this
.
propertyName
=
name
;
this
.
type
=
type
;
this
.
sanitizeURL
=
sanitizeURL
;
}
var
properties
=
{
}
;
[
'
children
'
'
dangerouslySetInnerHTML
'
'
defaultValue
'
'
defaultChecked
'
'
innerHTML
'
'
suppressContentEditableWarning
'
'
suppressHydrationWarning
'
'
style
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
RESERVED
false
name
null
false
)
;
}
)
;
[
[
'
acceptCharset
'
'
accept
-
charset
'
]
[
'
className
'
'
class
'
]
[
'
htmlFor
'
'
for
'
]
[
'
httpEquiv
'
'
http
-
equiv
'
]
]
.
forEach
(
function
(
_ref
)
{
var
name
=
_ref
[
0
]
attributeName
=
_ref
[
1
]
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
null
false
)
;
}
)
;
[
'
contentEditable
'
'
draggable
'
'
spellCheck
'
'
value
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEANISH_STRING
false
name
.
toLowerCase
(
)
null
false
)
;
}
)
;
[
'
autoReverse
'
'
externalResourcesRequired
'
'
focusable
'
'
preserveAlpha
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEANISH_STRING
false
name
null
false
)
;
}
)
;
[
'
allowFullScreen
'
'
async
'
'
autoFocus
'
'
autoPlay
'
'
controls
'
'
default
'
'
defer
'
'
disabled
'
'
disablePictureInPicture
'
'
formNoValidate
'
'
hidden
'
'
loop
'
'
noModule
'
'
noValidate
'
'
open
'
'
playsInline
'
'
readOnly
'
'
required
'
'
reversed
'
'
scoped
'
'
seamless
'
'
itemScope
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEAN
false
name
.
toLowerCase
(
)
null
false
)
;
}
)
;
[
'
checked
'
'
multiple
'
'
muted
'
'
selected
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEAN
true
name
null
false
)
;
}
)
;
[
'
capture
'
'
download
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
OVERLOADED_BOOLEAN
false
name
null
false
)
;
}
)
;
[
'
cols
'
'
rows
'
'
size
'
'
span
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
POSITIVE_NUMERIC
false
name
null
false
)
;
}
)
;
[
'
rowSpan
'
'
start
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
NUMERIC
false
name
.
toLowerCase
(
)
null
false
)
;
}
)
;
var
CAMELIZE
=
/
[
\
-
\
:
]
(
[
a
-
z
]
)
/
g
;
var
capitalize
=
function
(
token
)
{
return
token
[
1
]
.
toUpperCase
(
)
;
}
;
[
'
accent
-
height
'
'
alignment
-
baseline
'
'
arabic
-
form
'
'
baseline
-
shift
'
'
cap
-
height
'
'
clip
-
path
'
'
clip
-
rule
'
'
color
-
interpolation
'
'
color
-
interpolation
-
filters
'
'
color
-
profile
'
'
color
-
rendering
'
'
dominant
-
baseline
'
'
enable
-
background
'
'
fill
-
opacity
'
'
fill
-
rule
'
'
flood
-
color
'
'
flood
-
opacity
'
'
font
-
family
'
'
font
-
size
'
'
font
-
size
-
adjust
'
'
font
-
stretch
'
'
font
-
style
'
'
font
-
variant
'
'
font
-
weight
'
'
glyph
-
name
'
'
glyph
-
orientation
-
horizontal
'
'
glyph
-
orientation
-
vertical
'
'
horiz
-
adv
-
x
'
'
horiz
-
origin
-
x
'
'
image
-
rendering
'
'
letter
-
spacing
'
'
lighting
-
color
'
'
marker
-
end
'
'
marker
-
mid
'
'
marker
-
start
'
'
overline
-
position
'
'
overline
-
thickness
'
'
paint
-
order
'
'
panose
-
1
'
'
pointer
-
events
'
'
rendering
-
intent
'
'
shape
-
rendering
'
'
stop
-
color
'
'
stop
-
opacity
'
'
strikethrough
-
position
'
'
strikethrough
-
thickness
'
'
stroke
-
dasharray
'
'
stroke
-
dashoffset
'
'
stroke
-
linecap
'
'
stroke
-
linejoin
'
'
stroke
-
miterlimit
'
'
stroke
-
opacity
'
'
stroke
-
width
'
'
text
-
anchor
'
'
text
-
decoration
'
'
text
-
rendering
'
'
underline
-
position
'
'
underline
-
thickness
'
'
unicode
-
bidi
'
'
unicode
-
range
'
'
units
-
per
-
em
'
'
v
-
alphabetic
'
'
v
-
hanging
'
'
v
-
ideographic
'
'
v
-
mathematical
'
'
vector
-
effect
'
'
vert
-
adv
-
y
'
'
vert
-
origin
-
x
'
'
vert
-
origin
-
y
'
'
word
-
spacing
'
'
writing
-
mode
'
'
xmlns
:
xlink
'
'
x
-
height
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
null
false
)
;
}
)
;
[
'
xlink
:
actuate
'
'
xlink
:
arcrole
'
'
xlink
:
role
'
'
xlink
:
show
'
'
xlink
:
title
'
'
xlink
:
type
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
'
false
)
;
}
)
;
[
'
xml
:
base
'
'
xml
:
lang
'
'
xml
:
space
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
false
)
;
}
)
;
[
'
tabIndex
'
'
crossOrigin
'
]
.
forEach
(
function
(
attributeName
)
{
properties
[
attributeName
]
=
new
PropertyInfoRecord
(
attributeName
STRING
false
attributeName
.
toLowerCase
(
)
null
false
)
;
}
)
;
var
xlinkHref
=
'
xlinkHref
'
;
properties
[
xlinkHref
]
=
new
PropertyInfoRecord
(
'
xlinkHref
'
STRING
false
'
xlink
:
href
'
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
'
true
)
;
[
'
src
'
'
href
'
'
action
'
'
formAction
'
]
.
forEach
(
function
(
attributeName
)
{
properties
[
attributeName
]
=
new
PropertyInfoRecord
(
attributeName
STRING
false
attributeName
.
toLowerCase
(
)
null
true
)
;
}
)
;
var
ReactDebugCurrentFrame
1
=
null
;
{
ReactDebugCurrentFrame
1
=
ReactSharedInternals
.
ReactDebugCurrentFrame
;
}
var
isJavaScriptProtocol
=
/
^
[
\
u0000
-
\
u001F
]
*
j
[
\
r
\
n
\
t
]
*
a
[
\
r
\
n
\
t
]
*
v
[
\
r
\
n
\
t
]
*
a
[
\
r
\
n
\
t
]
*
s
[
\
r
\
n
\
t
]
*
c
[
\
r
\
n
\
t
]
*
r
[
\
r
\
n
\
t
]
*
i
[
\
r
\
n
\
t
]
*
p
[
\
r
\
n
\
t
]
*
t
[
\
r
\
n
\
t
]
*
\
:
/
i
;
var
didWarn
=
false
;
function
sanitizeURL
(
url
)
{
if
(
disableJavaScriptURLs
)
{
if
(
!
!
isJavaScriptProtocol
.
test
(
url
)
)
{
{
throw
Error
(
"
React
has
blocked
a
javascript
:
URL
as
a
security
precaution
.
"
+
(
ReactDebugCurrentFrame
1
.
getStackAddendum
(
)
)
)
;
}
}
}
else
if
(
true
&
&
!
didWarn
&
&
isJavaScriptProtocol
.
test
(
url
)
)
{
didWarn
=
true
;
warning
1
(
false
'
A
future
version
of
React
will
block
javascript
:
URLs
as
a
security
precaution
.
'
+
'
Use
event
handlers
instead
if
you
can
.
If
you
need
to
generate
unsafe
HTML
try
'
+
'
using
dangerouslySetInnerHTML
instead
.
React
was
passed
%
s
.
'
JSON
.
stringify
(
url
)
)
;
}
}
function
toString
(
value
)
{
return
'
'
+
value
;
}
function
getToStringValue
(
value
)
{
switch
(
typeof
value
)
{
case
'
boolean
'
:
case
'
number
'
:
case
'
object
'
:
case
'
string
'
:
case
'
undefined
'
:
return
value
;
default
:
return
'
'
;
}
}
var
toStringOrTrustedType
=
toString
;
if
(
enableTrustedTypesIntegration
&
&
typeof
trustedTypes
!
=
=
'
undefined
'
)
{
toStringOrTrustedType
=
function
(
value
)
{
if
(
typeof
value
=
=
=
'
object
'
&
&
(
trustedTypes
.
isHTML
(
value
)
|
|
trustedTypes
.
isScript
(
value
)
|
|
trustedTypes
.
isScriptURL
(
value
)
|
|
trustedTypes
.
isURL
&
&
trustedTypes
.
isURL
(
value
)
)
)
{
return
value
;
}
return
toString
(
value
)
;
}
;
}
function
setAttribute
(
node
attributeName
attributeValue
)
{
node
.
setAttribute
(
attributeName
attributeValue
)
;
}
function
setAttributeNS
(
node
attributeNamespace
attributeName
attributeValue
)
{
node
.
setAttributeNS
(
attributeNamespace
attributeName
attributeValue
)
;
}
function
getValueForProperty
(
node
name
expected
propertyInfo
)
{
{
if
(
propertyInfo
.
mustUseProperty
)
{
var
propertyName
=
propertyInfo
.
propertyName
;
return
node
[
propertyName
]
;
}
else
{
if
(
!
disableJavaScriptURLs
&
&
propertyInfo
.
sanitizeURL
)
{
sanitizeURL
(
'
'
+
expected
)
;
}
var
attributeName
=
propertyInfo
.
attributeName
;
var
stringValue
=
null
;
if
(
propertyInfo
.
type
=
=
=
OVERLOADED_BOOLEAN
)
{
if
(
node
.
hasAttribute
(
attributeName
)
)
{
var
value
=
node
.
getAttribute
(
attributeName
)
;
if
(
value
=
=
=
'
'
)
{
return
true
;
}
if
(
shouldRemoveAttribute
(
name
expected
propertyInfo
false
)
)
{
return
value
;
}
if
(
value
=
=
=
'
'
+
expected
)
{
return
expected
;
}
return
value
;
}
}
else
if
(
node
.
hasAttribute
(
attributeName
)
)
{
if
(
shouldRemoveAttribute
(
name
expected
propertyInfo
false
)
)
{
return
node
.
getAttribute
(
attributeName
)
;
}
if
(
propertyInfo
.
type
=
=
=
BOOLEAN
)
{
return
expected
;
}
stringValue
=
node
.
getAttribute
(
attributeName
)
;
}
if
(
shouldRemoveAttribute
(
name
expected
propertyInfo
false
)
)
{
return
stringValue
=
=
=
null
?
expected
:
stringValue
;
}
else
if
(
stringValue
=
=
=
'
'
+
expected
)
{
return
expected
;
}
else
{
return
stringValue
;
}
}
}
}
function
getValueForAttribute
(
node
name
expected
)
{
{
if
(
!
isAttributeNameSafe
(
name
)
)
{
return
;
}
if
(
!
node
.
hasAttribute
(
name
)
)
{
return
expected
=
=
=
undefined
?
undefined
:
null
;
}
var
value
=
node
.
getAttribute
(
name
)
;
if
(
value
=
=
=
'
'
+
expected
)
{
return
expected
;
}
return
value
;
}
}
function
setValueForProperty
(
node
name
value
isCustomComponentTag
)
{
var
propertyInfo
=
getPropertyInfo
(
name
)
;
if
(
shouldIgnoreAttribute
(
name
propertyInfo
isCustomComponentTag
)
)
{
return
;
}
if
(
shouldRemoveAttribute
(
name
value
propertyInfo
isCustomComponentTag
)
)
{
value
=
null
;
}
if
(
isCustomComponentTag
|
|
propertyInfo
=
=
=
null
)
{
if
(
isAttributeNameSafe
(
name
)
)
{
var
_attributeName
=
name
;
if
(
value
=
=
=
null
)
{
node
.
removeAttribute
(
_attributeName
)
;
}
else
{
setAttribute
(
node
_attributeName
toStringOrTrustedType
(
value
)
)
;
}
}
return
;
}
var
mustUseProperty
=
propertyInfo
.
mustUseProperty
;
if
(
mustUseProperty
)
{
var
propertyName
=
propertyInfo
.
propertyName
;
if
(
value
=
=
=
null
)
{
var
type
=
propertyInfo
.
type
;
node
[
propertyName
]
=
type
=
=
=
BOOLEAN
?
false
:
'
'
;
}
else
{
node
[
propertyName
]
=
value
;
}
return
;
}
var
attributeName
=
propertyInfo
.
attributeName
attributeNamespace
=
propertyInfo
.
attributeNamespace
;
if
(
value
=
=
=
null
)
{
node
.
removeAttribute
(
attributeName
)
;
}
else
{
var
_type
=
propertyInfo
.
type
;
var
attributeValue
;
if
(
_type
=
=
=
BOOLEAN
|
|
_type
=
=
=
OVERLOADED_BOOLEAN
&
&
value
=
=
=
true
)
{
attributeValue
=
'
'
;
}
else
{
attributeValue
=
toStringOrTrustedType
(
value
)
;
if
(
propertyInfo
.
sanitizeURL
)
{
sanitizeURL
(
attributeValue
.
toString
(
)
)
;
}
}
if
(
attributeNamespace
)
{
setAttributeNS
(
node
attributeNamespace
attributeName
attributeValue
)
;
}
else
{
setAttribute
(
node
attributeName
attributeValue
)
;
}
}
}
var
ReactPropTypesSecret
1
=
'
SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED
'
;
var
ReactPropTypesSecret_1
=
ReactPropTypesSecret
1
;
var
printWarning
=
function
(
)
{
}
;
{
var
ReactPropTypesSecret
=
ReactPropTypesSecret_1
;
var
loggedTypeFailures
=
{
}
;
var
has
=
Function
.
call
.
bind
(
Object
.
prototype
.
hasOwnProperty
)
;
printWarning
=
function
(
text
)
{
var
message
=
'
Warning
:
'
+
text
;
if
(
typeof
console
!
=
=
'
undefined
'
)
{
console
.
error
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
x
)
{
}
}
;
}
function
checkPropTypes
(
typeSpecs
values
location
componentName
getStack
)
{
{
for
(
var
typeSpecName
in
typeSpecs
)
{
if
(
has
(
typeSpecs
typeSpecName
)
)
{
var
error
;
try
{
if
(
typeof
typeSpecs
[
typeSpecName
]
!
=
=
'
function
'
)
{
var
err
=
Error
(
(
componentName
|
|
'
React
class
'
)
+
'
:
'
+
location
+
'
type
'
+
typeSpecName
+
'
is
invalid
;
'
+
'
it
must
be
a
function
usually
from
the
prop
-
types
package
but
received
'
+
typeof
typeSpecs
[
typeSpecName
]
+
'
.
'
)
;
err
.
name
=
'
Invariant
Violation
'
;
throw
err
;
}
error
=
typeSpecs
[
typeSpecName
]
(
values
typeSpecName
componentName
location
null
ReactPropTypesSecret
)
;
}
catch
(
ex
)
{
error
=
ex
;
}
if
(
error
&
&
!
(
error
instanceof
Error
)
)
{
printWarning
(
(
componentName
|
|
'
React
class
'
)
+
'
:
type
specification
of
'
+
location
+
'
'
+
typeSpecName
+
'
is
invalid
;
the
type
checker
'
+
'
function
must
return
null
or
an
Error
but
returned
a
'
+
typeof
error
+
'
.
'
+
'
You
may
have
forgotten
to
pass
an
argument
to
the
type
checker
'
+
'
creator
(
arrayOf
instanceOf
objectOf
oneOf
oneOfType
and
'
+
'
shape
all
require
an
argument
)
.
'
)
;
}
if
(
error
instanceof
Error
&
&
!
(
error
.
message
in
loggedTypeFailures
)
)
{
loggedTypeFailures
[
error
.
message
]
=
true
;
var
stack
=
getStack
?
getStack
(
)
:
'
'
;
printWarning
(
'
Failed
'
+
location
+
'
type
:
'
+
error
.
message
+
(
stack
!
=
null
?
stack
:
'
'
)
)
;
}
}
}
}
}
checkPropTypes
.
resetWarningCache
=
function
(
)
{
{
loggedTypeFailures
=
{
}
;
}
}
;
var
checkPropTypes_1
=
checkPropTypes
;
var
ReactDebugCurrentFrame
2
=
null
;
var
ReactControlledValuePropTypes
=
{
checkPropTypes
:
null
}
;
{
ReactDebugCurrentFrame
2
=
ReactSharedInternals
.
ReactDebugCurrentFrame
;
var
hasReadOnlyValue
=
{
button
:
true
checkbox
:
true
image
:
true
hidden
:
true
radio
:
true
reset
:
true
submit
:
true
}
;
var
propTypes
=
{
value
:
function
(
props
propName
componentName
)
{
if
(
hasReadOnlyValue
[
props
.
type
]
|
|
props
.
onChange
|
|
props
.
readOnly
|
|
props
.
disabled
|
|
props
[
propName
]
=
=
null
|
|
enableFlareAPI
&
&
props
.
listeners
)
{
return
null
;
}
return
new
Error
(
'
You
provided
a
value
prop
to
a
form
field
without
an
'
+
'
onChange
handler
.
This
will
render
a
read
-
only
field
.
If
'
+
'
the
field
should
be
mutable
use
defaultValue
.
Otherwise
'
+
'
set
either
onChange
or
readOnly
.
'
)
;
}
checked
:
function
(
props
propName
componentName
)
{
if
(
props
.
onChange
|
|
props
.
readOnly
|
|
props
.
disabled
|
|
props
[
propName
]
=
=
null
|
|
enableFlareAPI
&
&
props
.
listeners
)
{
return
null
;
}
return
new
Error
(
'
You
provided
a
checked
prop
to
a
form
field
without
an
'
+
'
onChange
handler
.
This
will
render
a
read
-
only
field
.
If
'
+
'
the
field
should
be
mutable
use
defaultChecked
.
Otherwise
'
+
'
set
either
onChange
or
readOnly
.
'
)
;
}
}
;
ReactControlledValuePropTypes
.
checkPropTypes
=
function
(
tagName
props
)
{
checkPropTypes_1
(
propTypes
props
'
prop
'
tagName
ReactDebugCurrentFrame
2
.
getStackAddendum
)
;
}
;
}
function
isCheckable
(
elem
)
{
var
type
=
elem
.
type
;
var
nodeName
=
elem
.
nodeName
;
return
nodeName
&
&
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
type
=
=
=
'
checkbox
'
|
|
type
=
=
=
'
radio
'
)
;
}
function
getTracker
(
node
)
{
return
node
.
_valueTracker
;
}
function
detachTracker
(
node
)
{
node
.
_valueTracker
=
null
;
}
function
getValueFromNode
(
node
)
{
var
value
=
'
'
;
if
(
!
node
)
{
return
value
;
}
if
(
isCheckable
(
node
)
)
{
value
=
node
.
checked
?
'
true
'
:
'
false
'
;
}
else
{
value
=
node
.
value
;
}
return
value
;
}
function
trackValueOnNode
(
node
)
{
var
valueField
=
isCheckable
(
node
)
?
'
checked
'
:
'
value
'
;
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
node
.
constructor
.
prototype
valueField
)
;
var
currentValue
=
'
'
+
node
[
valueField
]
;
if
(
node
.
hasOwnProperty
(
valueField
)
|
|
typeof
descriptor
=
=
=
'
undefined
'
|
|
typeof
descriptor
.
get
!
=
=
'
function
'
|
|
typeof
descriptor
.
set
!
=
=
'
function
'
)
{
return
;
}
var
get
=
descriptor
.
get
set
=
descriptor
.
set
;
Object
.
defineProperty
(
node
valueField
{
configurable
:
true
get
:
function
(
)
{
return
get
.
call
(
this
)
;
}
set
:
function
(
value
)
{
currentValue
=
'
'
+
value
;
set
.
call
(
this
value
)
;
}
}
)
;
Object
.
defineProperty
(
node
valueField
{
enumerable
:
descriptor
.
enumerable
}
)
;
var
tracker
=
{
getValue
:
function
(
)
{
return
currentValue
;
}
setValue
:
function
(
value
)
{
currentValue
=
'
'
+
value
;
}
stopTracking
:
function
(
)
{
detachTracker
(
node
)
;
delete
node
[
valueField
]
;
}
}
;
return
tracker
;
}
function
track
(
node
)
{
if
(
getTracker
(
node
)
)
{
return
;
}
node
.
_valueTracker
=
trackValueOnNode
(
node
)
;
}
function
updateValueIfChanged
(
node
)
{
if
(
!
node
)
{
return
false
;
}
var
tracker
=
getTracker
(
node
)
;
if
(
!
tracker
)
{
return
true
;
}
var
lastValue
=
tracker
.
getValue
(
)
;
var
nextValue
=
getValueFromNode
(
node
)
;
if
(
nextValue
!
=
=
lastValue
)
{
tracker
.
setValue
(
nextValue
)
;
return
true
;
}
return
false
;
}
var
didWarnValueDefaultValue
=
false
;
var
didWarnCheckedDefaultChecked
=
false
;
var
didWarnControlledToUncontrolled
=
false
;
var
didWarnUncontrolledToControlled
=
false
;
function
isControlled
(
props
)
{
var
usesChecked
=
props
.
type
=
=
=
'
checkbox
'
|
|
props
.
type
=
=
=
'
radio
'
;
return
usesChecked
?
props
.
checked
!
=
null
:
props
.
value
!
=
null
;
}
function
getHostProps
(
element
props
)
{
var
node
=
element
;
var
checked
=
props
.
checked
;
var
hostProps
=
_assign
(
{
}
props
{
defaultChecked
:
undefined
defaultValue
:
undefined
value
:
undefined
checked
:
checked
!
=
null
?
checked
:
node
.
_wrapperState
.
initialChecked
}
)
;
return
hostProps
;
}
function
initWrapperState
(
element
props
)
{
{
ReactControlledValuePropTypes
.
checkPropTypes
(
'
input
'
props
)
;
if
(
props
.
checked
!
=
=
undefined
&
&
props
.
defaultChecked
!
=
=
undefined
&
&
!
didWarnCheckedDefaultChecked
)
{
warning
1
(
false
'
%
s
contains
an
input
of
type
%
s
with
both
checked
and
defaultChecked
props
.
'
+
'
Input
elements
must
be
either
controlled
or
uncontrolled
'
+
'
(
specify
either
the
checked
prop
or
the
defaultChecked
prop
but
not
'
+
'
both
)
.
Decide
between
using
a
controlled
or
uncontrolled
input
'
+
'
element
and
remove
one
of
these
props
.
More
info
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
controlled
-
components
'
getCurrentFiberOwnerNameInDevOrNull
(
)
|
|
'
A
component
'
props
.
type
)
;
didWarnCheckedDefaultChecked
=
true
;
}
if
(
props
.
value
!
=
=
undefined
&
&
props
.
defaultValue
!
=
=
undefined
&
&
!
didWarnValueDefaultValue
)
{
warning
1
(
false
'
%
s
contains
an
input
of
type
%
s
with
both
value
and
defaultValue
props
.
'
+
'
Input
elements
must
be
either
controlled
or
uncontrolled
'
+
'
(
specify
either
the
value
prop
or
the
defaultValue
prop
but
not
'
+
'
both
)
.
Decide
between
using
a
controlled
or
uncontrolled
input
'
+
'
element
and
remove
one
of
these
props
.
More
info
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
controlled
-
components
'
getCurrentFiberOwnerNameInDevOrNull
(
)
|
|
'
A
component
'
props
.
type
)
;
didWarnValueDefaultValue
=
true
;
}
}
var
node
=
element
;
var
defaultValue
=
props
.
defaultValue
=
=
null
?
'
'
:
props
.
defaultValue
;
node
.
_wrapperState
=
{
initialChecked
:
props
.
checked
!
=
null
?
props
.
checked
:
props
.
defaultChecked
initialValue
:
getToStringValue
(
props
.
value
!
=
null
?
props
.
value
:
defaultValue
)
controlled
:
isControlled
(
props
)
}
;
}
function
updateChecked
(
element
props
)
{
var
node
=
element
;
var
checked
=
props
.
checked
;
if
(
checked
!
=
null
)
{
setValueForProperty
(
node
'
checked
'
checked
false
)
;
}
}
function
updateWrapper
(
element
props
)
{
var
node
=
element
;
{
var
controlled
=
isControlled
(
props
)
;
if
(
!
node
.
_wrapperState
.
controlled
&
&
controlled
&
&
!
didWarnUncontrolledToControlled
)
{
warning
1
(
false
'
A
component
is
changing
an
uncontrolled
input
of
type
%
s
to
be
controlled
.
'
+
'
Input
elements
should
not
switch
from
uncontrolled
to
controlled
(
or
vice
versa
)
.
'
+
'
Decide
between
using
a
controlled
or
uncontrolled
input
'
+
'
element
for
the
lifetime
of
the
component
.
More
info
:
https
:
/
/
fb
.
me
/
react
-
controlled
-
components
'
props
.
type
)
;
didWarnUncontrolledToControlled
=
true
;
}
if
(
node
.
_wrapperState
.
controlled
&
&
!
controlled
&
&
!
didWarnControlledToUncontrolled
)
{
warning
1
(
false
'
A
component
is
changing
a
controlled
input
of
type
%
s
to
be
uncontrolled
.
'
+
'
Input
elements
should
not
switch
from
controlled
to
uncontrolled
(
or
vice
versa
)
.
'
+
'
Decide
between
using
a
controlled
or
uncontrolled
input
'
+
'
element
for
the
lifetime
of
the
component
.
More
info
:
https
:
/
/
fb
.
me
/
react
-
controlled
-
components
'
props
.
type
)
;
didWarnControlledToUncontrolled
=
true
;
}
}
updateChecked
(
element
props
)
;
var
value
=
getToStringValue
(
props
.
value
)
;
var
type
=
props
.
type
;
if
(
value
!
=
null
)
{
if
(
type
=
=
=
'
number
'
)
{
if
(
value
=
=
=
0
&
&
node
.
value
=
=
=
'
'
|
|
node
.
value
!
=
value
)
{
node
.
value
=
toString
(
value
)
;
}
}
else
if
(
node
.
value
!
=
=
toString
(
value
)
)
{
node
.
value
=
toString
(
value
)
;
}
}
else
if
(
type
=
=
=
'
submit
'
|
|
type
=
=
=
'
reset
'
)
{
node
.
removeAttribute
(
'
value
'
)
;
return
;
}
if
(
disableInputAttributeSyncing
)
{
if
(
props
.
hasOwnProperty
(
'
defaultValue
'
)
)
{
setDefaultValue
(
node
props
.
type
getToStringValue
(
props
.
defaultValue
)
)
;
}
}
else
{
if
(
props
.
hasOwnProperty
(
'
value
'
)
)
{
setDefaultValue
(
node
props
.
type
value
)
;
}
else
if
(
props
.
hasOwnProperty
(
'
defaultValue
'
)
)
{
setDefaultValue
(
node
props
.
type
getToStringValue
(
props
.
defaultValue
)
)
;
}
}
if
(
disableInputAttributeSyncing
)
{
if
(
props
.
defaultChecked
=
=
null
)
{
node
.
removeAttribute
(
'
checked
'
)
;
}
else
{
node
.
defaultChecked
=
!
!
props
.
defaultChecked
;
}
}
else
{
if
(
props
.
checked
=
=
null
&
&
props
.
defaultChecked
!
=
null
)
{
node
.
defaultChecked
=
!
!
props
.
defaultChecked
;
}
}
}
function
postMountWrapper
(
element
props
isHydrating
)
{
var
node
=
element
;
if
(
props
.
hasOwnProperty
(
'
value
'
)
|
|
props
.
hasOwnProperty
(
'
defaultValue
'
)
)
{
var
type
=
props
.
type
;
var
isButton
=
type
=
=
=
'
submit
'
|
|
type
=
=
=
'
reset
'
;
if
(
isButton
&
&
(
props
.
value
=
=
=
undefined
|
|
props
.
value
=
=
=
null
)
)
{
return
;
}
var
initialValue
=
toString
(
node
.
_wrapperState
.
initialValue
)
;
if
(
!
isHydrating
)
{
if
(
disableInputAttributeSyncing
)
{
var
value
=
getToStringValue
(
props
.
value
)
;
if
(
value
!
=
null
)
{
if
(
isButton
|
|
value
!
=
=
node
.
value
)
{
node
.
value
=
toString
(
value
)
;
}
}
}
else
{
if
(
initialValue
!
=
=
node
.
value
)
{
node
.
value
=
initialValue
;
}
}
}
if
(
disableInputAttributeSyncing
)
{
var
defaultValue
=
getToStringValue
(
props
.
defaultValue
)
;
if
(
defaultValue
!
=
null
)
{
node
.
defaultValue
=
toString
(
defaultValue
)
;
}
}
else
{
node
.
defaultValue
=
initialValue
;
}
}
var
name
=
node
.
name
;
if
(
name
!
=
=
'
'
)
{
node
.
name
=
'
'
;
}
if
(
disableInputAttributeSyncing
)
{
if
(
!
isHydrating
)
{
updateChecked
(
element
props
)
;
}
if
(
props
.
hasOwnProperty
(
'
defaultChecked
'
)
)
{
node
.
defaultChecked
=
!
node
.
defaultChecked
;
node
.
defaultChecked
=
!
!
props
.
defaultChecked
;
}
}
else
{
node
.
defaultChecked
=
!
node
.
defaultChecked
;
node
.
defaultChecked
=
!
!
node
.
_wrapperState
.
initialChecked
;
}
if
(
name
!
=
=
'
'
)
{
node
.
name
=
name
;
}
}
function
restoreControlledState
1
(
element
props
)
{
var
node
=
element
;
updateWrapper
(
node
props
)
;
updateNamedCousins
(
node
props
)
;
}
function
updateNamedCousins
(
rootNode
props
)
{
var
name
=
props
.
name
;
if
(
props
.
type
=
=
=
'
radio
'
&
&
name
!
=
null
)
{
var
queryRoot
=
rootNode
;
while
(
queryRoot
.
parentNode
)
{
queryRoot
=
queryRoot
.
parentNode
;
}
var
group
=
queryRoot
.
querySelectorAll
(
'
input
[
name
=
'
+
JSON
.
stringify
(
'
'
+
name
)
+
'
]
[
type
=
"
radio
"
]
'
)
;
for
(
var
i
=
0
;
i
<
group
.
length
;
i
+
+
)
{
var
otherNode
=
group
[
i
]
;
if
(
otherNode
=
=
=
rootNode
|
|
otherNode
.
form
!
=
=
rootNode
.
form
)
{
continue
;
}
var
otherProps
=
getFiberCurrentPropsFromNode
1
(
otherNode
)
;
if
(
!
otherProps
)
{
{
throw
Error
(
"
ReactDOMInput
:
Mixing
React
and
non
-
React
radio
inputs
with
the
same
name
is
not
supported
.
"
)
;
}
}
updateValueIfChanged
(
otherNode
)
;
updateWrapper
(
otherNode
otherProps
)
;
}
}
}
function
setDefaultValue
(
node
type
value
)
{
if
(
type
!
=
=
'
number
'
|
|
node
.
ownerDocument
.
activeElement
!
=
=
node
)
{
if
(
value
=
=
null
)
{
node
.
defaultValue
=
toString
(
node
.
_wrapperState
.
initialValue
)
;
}
else
if
(
node
.
defaultValue
!
=
=
toString
(
value
)
)
{
node
.
defaultValue
=
toString
(
value
)
;
}
}
}
var
didWarnSelectedSetOnOption
=
false
;
var
didWarnInvalidChild
=
false
;
function
flattenChildren
(
children
)
{
var
content
=
'
'
;
React
.
Children
.
forEach
(
children
function
(
child
)
{
if
(
child
=
=
null
)
{
return
;
}
content
+
=
child
;
}
)
;
return
content
;
}
function
validateProps
(
element
props
)
{
{
if
(
typeof
props
.
children
=
=
=
'
object
'
&
&
props
.
children
!
=
=
null
)
{
React
.
Children
.
forEach
(
props
.
children
function
(
child
)
{
if
(
child
=
=
null
)
{
return
;
}
if
(
typeof
child
=
=
=
'
string
'
|
|
typeof
child
=
=
=
'
number
'
)
{
return
;
}
if
(
typeof
child
.
type
!
=
=
'
string
'
)
{
return
;
}
if
(
!
didWarnInvalidChild
)
{
didWarnInvalidChild
=
true
;
warning
1
(
false
'
Only
strings
and
numbers
are
supported
as
<
option
>
children
.
'
)
;
}
}
)
;
}
if
(
props
.
selected
!
=
null
&
&
!
didWarnSelectedSetOnOption
)
{
warning
1
(
false
'
Use
the
defaultValue
or
value
props
on
<
select
>
instead
of
'
+
'
setting
selected
on
<
option
>
.
'
)
;
didWarnSelectedSetOnOption
=
true
;
}
}
}
function
postMountWrapper
1
(
element
props
)
{
if
(
props
.
value
!
=
null
)
{
element
.
setAttribute
(
'
value
'
toString
(
getToStringValue
(
props
.
value
)
)
)
;
}
}
function
getHostProps
1
(
element
props
)
{
var
hostProps
=
_assign
(
{
children
:
undefined
}
props
)
;
var
content
=
flattenChildren
(
props
.
children
)
;
if
(
content
)
{
hostProps
.
children
=
content
;
}
return
hostProps
;
}
var
didWarnValueDefaultValue
1
;
{
didWarnValueDefaultValue
1
=
false
;
}
function
getDeclarationErrorAddendum
(
)
{
var
ownerName
=
getCurrentFiberOwnerNameInDevOrNull
(
)
;
if
(
ownerName
)
{
return
'
\
n
\
nCheck
the
render
method
of
'
+
ownerName
+
'
.
'
;
}
return
'
'
;
}
var
valuePropNames
=
[
'
value
'
'
defaultValue
'
]
;
function
checkSelectPropTypes
(
props
)
{
ReactControlledValuePropTypes
.
checkPropTypes
(
'
select
'
props
)
;
for
(
var
i
=
0
;
i
<
valuePropNames
.
length
;
i
+
+
)
{
var
propName
=
valuePropNames
[
i
]
;
if
(
props
[
propName
]
=
=
null
)
{
continue
;
}
var
isArray
=
Array
.
isArray
(
props
[
propName
]
)
;
if
(
props
.
multiple
&
&
!
isArray
)
{
warning
1
(
false
'
The
%
s
prop
supplied
to
<
select
>
must
be
an
array
if
'
+
'
multiple
is
true
.
%
s
'
propName
getDeclarationErrorAddendum
(
)
)
;
}
else
if
(
!
props
.
multiple
&
&
isArray
)
{
warning
1
(
false
'
The
%
s
prop
supplied
to
<
select
>
must
be
a
scalar
'
+
'
value
if
multiple
is
false
.
%
s
'
propName
getDeclarationErrorAddendum
(
)
)
;
}
}
}
function
updateOptions
(
node
multiple
propValue
setDefaultSelected
)
{
var
options
=
node
.
options
;
if
(
multiple
)
{
var
selectedValues
=
propValue
;
var
selectedValue
=
{
}
;
for
(
var
i
=
0
;
i
<
selectedValues
.
length
;
i
+
+
)
{
selectedValue
[
'
'
+
selectedValues
[
i
]
]
=
true
;
}
for
(
var
_i
=
0
;
_i
<
options
.
length
;
_i
+
+
)
{
var
selected
=
selectedValue
.
hasOwnProperty
(
'
'
+
options
[
_i
]
.
value
)
;
if
(
options
[
_i
]
.
selected
!
=
=
selected
)
{
options
[
_i
]
.
selected
=
selected
;
}
if
(
selected
&
&
setDefaultSelected
)
{
options
[
_i
]
.
defaultSelected
=
true
;
}
}
}
else
{
var
_selectedValue
=
toString
(
getToStringValue
(
propValue
)
)
;
var
defaultSelected
=
null
;
for
(
var
_i2
=
0
;
_i2
<
options
.
length
;
_i2
+
+
)
{
if
(
options
[
_i2
]
.
value
=
=
=
_selectedValue
)
{
options
[
_i2
]
.
selected
=
true
;
if
(
setDefaultSelected
)
{
options
[
_i2
]
.
defaultSelected
=
true
;
}
return
;
}
if
(
defaultSelected
=
=
=
null
&
&
!
options
[
_i2
]
.
disabled
)
{
defaultSelected
=
options
[
_i2
]
;
}
}
if
(
defaultSelected
!
=
=
null
)
{
defaultSelected
.
selected
=
true
;
}
}
}
function
getHostProps
2
(
element
props
)
{
return
_assign
(
{
}
props
{
value
:
undefined
}
)
;
}
function
initWrapperState
1
(
element
props
)
{
var
node
=
element
;
{
checkSelectPropTypes
(
props
)
;
}
node
.
_wrapperState
=
{
wasMultiple
:
!
!
props
.
multiple
}
;
{
if
(
props
.
value
!
=
=
undefined
&
&
props
.
defaultValue
!
=
=
undefined
&
&
!
didWarnValueDefaultValue
1
)
{
warning
1
(
false
'
Select
elements
must
be
either
controlled
or
uncontrolled
'
+
'
(
specify
either
the
value
prop
or
the
defaultValue
prop
but
not
'
+
'
both
)
.
Decide
between
using
a
controlled
or
uncontrolled
select
'
+
'
element
and
remove
one
of
these
props
.
More
info
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
controlled
-
components
'
)
;
didWarnValueDefaultValue
1
=
true
;
}
}
}
function
postMountWrapper
2
(
element
props
)
{
var
node
=
element
;
node
.
multiple
=
!
!
props
.
multiple
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
else
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
props
.
defaultValue
true
)
;
}
}
function
postUpdateWrapper
(
element
props
)
{
var
node
=
element
;
var
wasMultiple
=
node
.
_wrapperState
.
wasMultiple
;
node
.
_wrapperState
.
wasMultiple
=
!
!
props
.
multiple
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
else
if
(
wasMultiple
!
=
=
!
!
props
.
multiple
)
{
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
props
.
defaultValue
true
)
;
}
else
{
updateOptions
(
node
!
!
props
.
multiple
props
.
multiple
?
[
]
:
'
'
false
)
;
}
}
}
function
restoreControlledState
2
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
}
var
didWarnValDefaultVal
=
false
;
function
getHostProps
3
(
element
props
)
{
var
node
=
element
;
if
(
!
(
props
.
dangerouslySetInnerHTML
=
=
null
)
)
{
{
throw
Error
(
"
dangerouslySetInnerHTML
does
not
make
sense
on
<
textarea
>
.
"
)
;
}
}
var
hostProps
=
_assign
(
{
}
props
{
value
:
undefined
defaultValue
:
undefined
children
:
toString
(
node
.
_wrapperState
.
initialValue
)
}
)
;
return
hostProps
;
}
function
initWrapperState
2
(
element
props
)
{
var
node
=
element
;
{
ReactControlledValuePropTypes
.
checkPropTypes
(
'
textarea
'
props
)
;
if
(
props
.
value
!
=
=
undefined
&
&
props
.
defaultValue
!
=
=
undefined
&
&
!
didWarnValDefaultVal
)
{
warning
1
(
false
'
%
s
contains
a
textarea
with
both
value
and
defaultValue
props
.
'
+
'
Textarea
elements
must
be
either
controlled
or
uncontrolled
'
+
'
(
specify
either
the
value
prop
or
the
defaultValue
prop
but
not
'
+
'
both
)
.
Decide
between
using
a
controlled
or
uncontrolled
textarea
'
+
'
and
remove
one
of
these
props
.
More
info
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
controlled
-
components
'
getCurrentFiberOwnerNameInDevOrNull
(
)
|
|
'
A
component
'
)
;
didWarnValDefaultVal
=
true
;
}
}
var
initialValue
=
props
.
value
;
if
(
initialValue
=
=
null
)
{
var
defaultValue
=
props
.
defaultValue
;
var
children
=
props
.
children
;
if
(
children
!
=
null
)
{
{
warning
1
(
false
'
Use
the
defaultValue
or
value
props
instead
of
setting
'
+
'
children
on
<
textarea
>
.
'
)
;
}
if
(
!
(
defaultValue
=
=
null
)
)
{
{
throw
Error
(
"
If
you
supply
defaultValue
on
a
<
textarea
>
do
not
pass
children
.
"
)
;
}
}
if
(
Array
.
isArray
(
children
)
)
{
if
(
!
(
children
.
length
<
=
1
)
)
{
{
throw
Error
(
"
<
textarea
>
can
only
have
at
most
one
child
.
"
)
;
}
}
children
=
children
[
0
]
;
}
defaultValue
=
children
;
}
if
(
defaultValue
=
=
null
)
{
defaultValue
=
'
'
;
}
initialValue
=
defaultValue
;
}
node
.
_wrapperState
=
{
initialValue
:
getToStringValue
(
initialValue
)
}
;
}
function
updateWrapper
1
(
element
props
)
{
var
node
=
element
;
var
value
=
getToStringValue
(
props
.
value
)
;
var
defaultValue
=
getToStringValue
(
props
.
defaultValue
)
;
if
(
value
!
=
null
)
{
var
newValue
=
toString
(
value
)
;
if
(
newValue
!
=
=
node
.
value
)
{
node
.
value
=
newValue
;
}
if
(
props
.
defaultValue
=
=
null
&
&
node
.
defaultValue
!
=
=
newValue
)
{
node
.
defaultValue
=
newValue
;
}
}
if
(
defaultValue
!
=
null
)
{
node
.
defaultValue
=
toString
(
defaultValue
)
;
}
}
function
postMountWrapper
3
(
element
props
)
{
var
node
=
element
;
var
textContent
=
node
.
textContent
;
if
(
textContent
=
=
=
node
.
_wrapperState
.
initialValue
)
{
if
(
textContent
!
=
=
'
'
&
&
textContent
!
=
=
null
)
{
node
.
value
=
textContent
;
}
}
}
function
restoreControlledState
3
(
element
props
)
{
updateWrapper
1
(
element
props
)
;
}
var
HTML_NAMESPACE
1
=
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
;
var
MATH_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
'
;
var
SVG_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
;
var
Namespaces
=
{
html
:
HTML_NAMESPACE
1
mathml
:
MATH_NAMESPACE
svg
:
SVG_NAMESPACE
}
;
function
getIntrinsicNamespace
(
type
)
{
switch
(
type
)
{
case
'
svg
'
:
return
SVG_NAMESPACE
;
case
'
math
'
:
return
MATH_NAMESPACE
;
default
:
return
HTML_NAMESPACE
1
;
}
}
function
getChildNamespace
(
parentNamespace
type
)
{
if
(
parentNamespace
=
=
null
|
|
parentNamespace
=
=
=
HTML_NAMESPACE
1
)
{
return
getIntrinsicNamespace
(
type
)
;
}
if
(
parentNamespace
=
=
=
SVG_NAMESPACE
&
&
type
=
=
=
'
foreignObject
'
)
{
return
HTML_NAMESPACE
1
;
}
return
parentNamespace
;
}
var
createMicrosoftUnsafeLocalFunction
=
function
(
func
)
{
if
(
typeof
MSApp
!
=
=
'
undefined
'
&
&
MSApp
.
execUnsafeLocalFunction
)
{
return
function
(
arg0
arg1
arg2
arg3
)
{
MSApp
.
execUnsafeLocalFunction
(
function
(
)
{
return
func
(
arg0
arg1
arg2
arg3
)
;
}
)
;
}
;
}
else
{
return
func
;
}
}
;
var
reusableSVGContainer
;
var
setInnerHTML
=
createMicrosoftUnsafeLocalFunction
(
function
(
node
html
)
{
if
(
node
.
namespaceURI
=
=
=
Namespaces
.
svg
)
{
{
if
(
enableTrustedTypesIntegration
)
{
!
(
typeof
trustedTypes
=
=
=
'
undefined
'
)
?
warning
1
(
false
"
Using
'
dangerouslySetInnerHTML
'
in
an
svg
element
with
"
+
'
Trusted
Types
enabled
in
an
Internet
Explorer
will
cause
'
+
'
the
trusted
value
to
be
converted
to
string
.
Assigning
string
'
+
"
to
'
innerHTML
'
will
throw
an
error
if
Trusted
Types
are
enforced
.
"
+
"
You
can
try
to
wrap
your
svg
element
inside
a
div
and
use
'
dangerouslySetInnerHTML
'
"
+
'
on
the
enclosing
div
instead
.
'
)
:
void
0
;
}
}
if
(
!
(
'
innerHTML
'
in
node
)
)
{
reusableSVGContainer
=
reusableSVGContainer
|
|
document
.
createElement
(
'
div
'
)
;
reusableSVGContainer
.
innerHTML
=
'
<
svg
>
'
+
html
.
valueOf
(
)
.
toString
(
)
+
'
<
/
svg
>
'
;
var
svgNode
=
reusableSVGContainer
.
firstChild
;
while
(
node
.
firstChild
)
{
node
.
removeChild
(
node
.
firstChild
)
;
}
while
(
svgNode
.
firstChild
)
{
node
.
appendChild
(
svgNode
.
firstChild
)
;
}
return
;
}
}
node
.
innerHTML
=
html
;
}
)
;
var
ELEMENT_NODE
=
1
;
var
TEXT_NODE
=
3
;
var
COMMENT_NODE
=
8
;
var
DOCUMENT_NODE
=
9
;
var
DOCUMENT_FRAGMENT_NODE
=
11
;
var
setTextContent
=
function
(
node
text
)
{
if
(
text
)
{
var
firstChild
=
node
.
firstChild
;
if
(
firstChild
&
&
firstChild
=
=
=
node
.
lastChild
&
&
firstChild
.
nodeType
=
=
=
TEXT_NODE
)
{
firstChild
.
nodeValue
=
text
;
return
;
}
}
node
.
textContent
=
text
;
}
;
function
unsafeCastStringToDOMTopLevelType
(
topLevelType
)
{
return
topLevelType
;
}
function
unsafeCastDOMTopLevelTypeToString
(
topLevelType
)
{
return
topLevelType
;
}
function
makePrefixMap
(
styleProp
eventName
)
{
var
prefixes
=
{
}
;
prefixes
[
styleProp
.
toLowerCase
(
)
]
=
eventName
.
toLowerCase
(
)
;
prefixes
[
'
Webkit
'
+
styleProp
]
=
'
webkit
'
+
eventName
;
prefixes
[
'
Moz
'
+
styleProp
]
=
'
moz
'
+
eventName
;
return
prefixes
;
}
var
vendorPrefixes
=
{
animationend
:
makePrefixMap
(
'
Animation
'
'
AnimationEnd
'
)
animationiteration
:
makePrefixMap
(
'
Animation
'
'
AnimationIteration
'
)
animationstart
:
makePrefixMap
(
'
Animation
'
'
AnimationStart
'
)
transitionend
:
makePrefixMap
(
'
Transition
'
'
TransitionEnd
'
)
}
;
var
prefixedEventNames
=
{
}
;
var
style
=
{
}
;
if
(
canUseDOM
)
{
style
=
document
.
createElement
(
'
div
'
)
.
style
;
if
(
!
(
'
AnimationEvent
'
in
window
)
)
{
delete
vendorPrefixes
.
animationend
.
animation
;
delete
vendorPrefixes
.
animationiteration
.
animation
;
delete
vendorPrefixes
.
animationstart
.
animation
;
}
if
(
!
(
'
TransitionEvent
'
in
window
)
)
{
delete
vendorPrefixes
.
transitionend
.
transition
;
}
}
function
getVendorPrefixedEventName
(
eventName
)
{
if
(
prefixedEventNames
[
eventName
]
)
{
return
prefixedEventNames
[
eventName
]
;
}
else
if
(
!
vendorPrefixes
[
eventName
]
)
{
return
eventName
;
}
var
prefixMap
=
vendorPrefixes
[
eventName
]
;
for
(
var
styleProp
in
prefixMap
)
{
if
(
prefixMap
.
hasOwnProperty
(
styleProp
)
&
&
styleProp
in
style
)
{
return
prefixedEventNames
[
eventName
]
=
prefixMap
[
styleProp
]
;
}
}
return
eventName
;
}
var
TOP_ABORT
=
unsafeCastStringToDOMTopLevelType
(
'
abort
'
)
;
var
TOP_ANIMATION_END
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationend
'
)
)
;
var
TOP_ANIMATION_ITERATION
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationiteration
'
)
)
;
var
TOP_ANIMATION_START
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationstart
'
)
)
;
var
TOP_BLUR
=
unsafeCastStringToDOMTopLevelType
(
'
blur
'
)
;
var
TOP_CAN_PLAY
=
unsafeCastStringToDOMTopLevelType
(
'
canplay
'
)
;
var
TOP_CAN_PLAY_THROUGH
=
unsafeCastStringToDOMTopLevelType
(
'
canplaythrough
'
)
;
var
TOP_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
cancel
'
)
;
var
TOP_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
change
'
)
;
var
TOP_CLICK
=
unsafeCastStringToDOMTopLevelType
(
'
click
'
)
;
var
TOP_CLOSE
=
unsafeCastStringToDOMTopLevelType
(
'
close
'
)
;
var
TOP_COMPOSITION_END
=
unsafeCastStringToDOMTopLevelType
(
'
compositionend
'
)
;
var
TOP_COMPOSITION_START
=
unsafeCastStringToDOMTopLevelType
(
'
compositionstart
'
)
;
var
TOP_COMPOSITION_UPDATE
=
unsafeCastStringToDOMTopLevelType
(
'
compositionupdate
'
)
;
var
TOP_CONTEXT_MENU
=
unsafeCastStringToDOMTopLevelType
(
'
contextmenu
'
)
;
var
TOP_COPY
=
unsafeCastStringToDOMTopLevelType
(
'
copy
'
)
;
var
TOP_CUT
=
unsafeCastStringToDOMTopLevelType
(
'
cut
'
)
;
var
TOP_DOUBLE_CLICK
=
unsafeCastStringToDOMTopLevelType
(
'
dblclick
'
)
;
var
TOP_AUX_CLICK
=
unsafeCastStringToDOMTopLevelType
(
'
auxclick
'
)
;
var
TOP_DRAG
=
unsafeCastStringToDOMTopLevelType
(
'
drag
'
)
;
var
TOP_DRAG_END
=
unsafeCastStringToDOMTopLevelType
(
'
dragend
'
)
;
var
TOP_DRAG_ENTER
=
unsafeCastStringToDOMTopLevelType
(
'
dragenter
'
)
;
var
TOP_DRAG_EXIT
=
unsafeCastStringToDOMTopLevelType
(
'
dragexit
'
)
;
var
TOP_DRAG_LEAVE
=
unsafeCastStringToDOMTopLevelType
(
'
dragleave
'
)
;
var
TOP_DRAG_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
dragover
'
)
;
var
TOP_DRAG_START
=
unsafeCastStringToDOMTopLevelType
(
'
dragstart
'
)
;
var
TOP_DROP
=
unsafeCastStringToDOMTopLevelType
(
'
drop
'
)
;
var
TOP_DURATION_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
durationchange
'
)
;
var
TOP_EMPTIED
=
unsafeCastStringToDOMTopLevelType
(
'
emptied
'
)
;
var
TOP_ENCRYPTED
=
unsafeCastStringToDOMTopLevelType
(
'
encrypted
'
)
;
var
TOP_ENDED
=
unsafeCastStringToDOMTopLevelType
(
'
ended
'
)
;
var
TOP_ERROR
=
unsafeCastStringToDOMTopLevelType
(
'
error
'
)
;
var
TOP_FOCUS
=
unsafeCastStringToDOMTopLevelType
(
'
focus
'
)
;
var
TOP_GOT_POINTER_CAPTURE
=
unsafeCastStringToDOMTopLevelType
(
'
gotpointercapture
'
)
;
var
TOP_INPUT
=
unsafeCastStringToDOMTopLevelType
(
'
input
'
)
;
var
TOP_INVALID
=
unsafeCastStringToDOMTopLevelType
(
'
invalid
'
)
;
var
TOP_KEY_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
keydown
'
)
;
var
TOP_KEY_PRESS
=
unsafeCastStringToDOMTopLevelType
(
'
keypress
'
)
;
var
TOP_KEY_UP
=
unsafeCastStringToDOMTopLevelType
(
'
keyup
'
)
;
var
TOP_LOAD
=
unsafeCastStringToDOMTopLevelType
(
'
load
'
)
;
var
TOP_LOAD_START
=
unsafeCastStringToDOMTopLevelType
(
'
loadstart
'
)
;
var
TOP_LOADED_DATA
=
unsafeCastStringToDOMTopLevelType
(
'
loadeddata
'
)
;
var
TOP_LOADED_METADATA
=
unsafeCastStringToDOMTopLevelType
(
'
loadedmetadata
'
)
;
var
TOP_LOST_POINTER_CAPTURE
=
unsafeCastStringToDOMTopLevelType
(
'
lostpointercapture
'
)
;
var
TOP_MOUSE_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
mousedown
'
)
;
var
TOP_MOUSE_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
mousemove
'
)
;
var
TOP_MOUSE_OUT
=
unsafeCastStringToDOMTopLevelType
(
'
mouseout
'
)
;
var
TOP_MOUSE_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
mouseover
'
)
;
var
TOP_MOUSE_UP
=
unsafeCastStringToDOMTopLevelType
(
'
mouseup
'
)
;
var
TOP_PASTE
=
unsafeCastStringToDOMTopLevelType
(
'
paste
'
)
;
var
TOP_PAUSE
=
unsafeCastStringToDOMTopLevelType
(
'
pause
'
)
;
var
TOP_PLAY
=
unsafeCastStringToDOMTopLevelType
(
'
play
'
)
;
var
TOP_PLAYING
=
unsafeCastStringToDOMTopLevelType
(
'
playing
'
)
;
var
TOP_POINTER_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
pointercancel
'
)
;
var
TOP_POINTER_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
pointerdown
'
)
;
var
TOP_POINTER_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
pointermove
'
)
;
var
TOP_POINTER_OUT
=
unsafeCastStringToDOMTopLevelType
(
'
pointerout
'
)
;
var
TOP_POINTER_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
pointerover
'
)
;
var
TOP_POINTER_UP
=
unsafeCastStringToDOMTopLevelType
(
'
pointerup
'
)
;
var
TOP_PROGRESS
=
unsafeCastStringToDOMTopLevelType
(
'
progress
'
)
;
var
TOP_RATE_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
ratechange
'
)
;
var
TOP_RESET
=
unsafeCastStringToDOMTopLevelType
(
'
reset
'
)
;
var
TOP_SCROLL
=
unsafeCastStringToDOMTopLevelType
(
'
scroll
'
)
;
var
TOP_SEEKED
=
unsafeCastStringToDOMTopLevelType
(
'
seeked
'
)
;
var
TOP_SEEKING
=
unsafeCastStringToDOMTopLevelType
(
'
seeking
'
)
;
var
TOP_SELECTION_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
selectionchange
'
)
;
var
TOP_STALLED
=
unsafeCastStringToDOMTopLevelType
(
'
stalled
'
)
;
var
TOP_SUBMIT
=
unsafeCastStringToDOMTopLevelType
(
'
submit
'
)
;
var
TOP_SUSPEND
=
unsafeCastStringToDOMTopLevelType
(
'
suspend
'
)
;
var
TOP_TEXT_INPUT
=
unsafeCastStringToDOMTopLevelType
(
'
textInput
'
)
;
var
TOP_TIME_UPDATE
=
unsafeCastStringToDOMTopLevelType
(
'
timeupdate
'
)
;
var
TOP_TOGGLE
=
unsafeCastStringToDOMTopLevelType
(
'
toggle
'
)
;
var
TOP_TOUCH_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
touchcancel
'
)
;
var
TOP_TOUCH_END
=
unsafeCastStringToDOMTopLevelType
(
'
touchend
'
)
;
var
TOP_TOUCH_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
touchmove
'
)
;
var
TOP_TOUCH_START
=
unsafeCastStringToDOMTopLevelType
(
'
touchstart
'
)
;
var
TOP_TRANSITION_END
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
transitionend
'
)
)
;
var
TOP_VOLUME_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
volumechange
'
)
;
var
TOP_WAITING
=
unsafeCastStringToDOMTopLevelType
(
'
waiting
'
)
;
var
TOP_WHEEL
=
unsafeCastStringToDOMTopLevelType
(
'
wheel
'
)
;
var
mediaEventTypes
=
[
TOP_ABORT
TOP_CAN_PLAY
TOP_CAN_PLAY_THROUGH
TOP_DURATION_CHANGE
TOP_EMPTIED
TOP_ENCRYPTED
TOP_ENDED
TOP_ERROR
TOP_LOADED_DATA
TOP_LOADED_METADATA
TOP_LOAD_START
TOP_PAUSE
TOP_PLAY
TOP_PLAYING
TOP_PROGRESS
TOP_RATE_CHANGE
TOP_SEEKED
TOP_SEEKING
TOP_STALLED
TOP_SUSPEND
TOP_TIME_UPDATE
TOP_VOLUME_CHANGE
TOP_WAITING
]
;
function
getRawEventName
(
topLevelType
)
{
return
unsafeCastDOMTopLevelTypeToString
(
topLevelType
)
;
}
function
get
(
key
)
{
return
key
.
_reactInternalFiber
;
}
function
has
1
(
key
)
{
return
key
.
_reactInternalFiber
!
=
=
undefined
;
}
function
set
(
key
value
)
{
key
.
_reactInternalFiber
=
value
;
}
var
NoEffect
=
0
;
var
PerformedWork
=
1
;
var
Placement
=
2
;
var
Update
=
4
;
var
PlacementAndUpdate
=
6
;
var
Deletion
=
8
;
var
ContentReset
=
16
;
var
Callback
=
32
;
var
DidCapture
=
64
;
var
Ref
=
128
;
var
Snapshot
=
256
;
var
Passive
=
512
;
var
Hydrating
=
1024
;
var
HydratingAndUpdate
=
1028
;
var
LifecycleEffectMask
=
932
;
var
HostEffectMask
=
2047
;
var
Incomplete
=
2048
;
var
ShouldCapture
=
4096
;
var
ReactCurrentOwner
=
ReactSharedInternals
.
ReactCurrentOwner
;
function
getNearestMountedFiber
(
fiber
)
{
var
node
=
fiber
;
var
nearestMounted
=
fiber
;
if
(
!
fiber
.
alternate
)
{
var
nextNode
=
node
;
do
{
node
=
nextNode
;
if
(
(
node
.
effectTag
&
(
Placement
|
Hydrating
)
)
!
=
=
NoEffect
)
{
nearestMounted
=
node
.
return
;
}
nextNode
=
node
.
return
;
}
while
(
nextNode
)
;
}
else
{
while
(
node
.
return
)
{
node
=
node
.
return
;
}
}
if
(
node
.
tag
=
=
=
HostRoot
)
{
return
nearestMounted
;
}
return
null
;
}
function
getSuspenseInstanceFromFiber
(
fiber
)
{
if
(
fiber
.
tag
=
=
=
SuspenseComponent
)
{
var
suspenseState
=
fiber
.
memoizedState
;
if
(
suspenseState
=
=
=
null
)
{
var
current
=
fiber
.
alternate
;
if
(
current
!
=
=
null
)
{
suspenseState
=
current
.
memoizedState
;
}
}
if
(
suspenseState
!
=
=
null
)
{
return
suspenseState
.
dehydrated
;
}
}
return
null
;
}
function
getContainerFromFiber
(
fiber
)
{
return
fiber
.
tag
=
=
=
HostRoot
?
fiber
.
stateNode
.
containerInfo
:
null
;
}
function
isFiberMounted
(
fiber
)
{
return
getNearestMountedFiber
(
fiber
)
=
=
=
fiber
;
}
function
isMounted
(
component
)
{
{
var
owner
=
ReactCurrentOwner
.
current
;
if
(
owner
!
=
=
null
&
&
owner
.
tag
=
=
=
ClassComponent
)
{
var
ownerFiber
=
owner
;
var
instance
=
ownerFiber
.
stateNode
;
!
instance
.
_warnedAboutRefsInRender
?
warningWithoutStack
1
(
false
'
%
s
is
accessing
isMounted
inside
its
render
(
)
function
.
'
+
'
render
(
)
should
be
a
pure
function
of
props
and
state
.
It
should
'
+
'
never
access
something
that
requires
stale
data
from
the
previous
'
+
'
render
such
as
refs
.
Move
this
logic
to
componentDidMount
and
'
+
'
componentDidUpdate
instead
.
'
getComponentName
(
ownerFiber
.
type
)
|
|
'
A
component
'
)
:
void
0
;
instance
.
_warnedAboutRefsInRender
=
true
;
}
}
var
fiber
=
get
(
component
)
;
if
(
!
fiber
)
{
return
false
;
}
return
getNearestMountedFiber
(
fiber
)
=
=
=
fiber
;
}
function
assertIsMounted
(
fiber
)
{
if
(
!
(
getNearestMountedFiber
(
fiber
)
=
=
=
fiber
)
)
{
{
throw
Error
(
"
Unable
to
find
node
on
an
unmounted
component
.
"
)
;
}
}
}
function
findCurrentFiberUsingSlowPath
(
fiber
)
{
var
alternate
=
fiber
.
alternate
;
if
(
!
alternate
)
{
var
nearestMounted
=
getNearestMountedFiber
(
fiber
)
;
if
(
!
(
nearestMounted
!
=
=
null
)
)
{
{
throw
Error
(
"
Unable
to
find
node
on
an
unmounted
component
.
"
)
;
}
}
if
(
nearestMounted
!
=
=
fiber
)
{
return
null
;
}
return
fiber
;
}
var
a
=
fiber
;
var
b
=
alternate
;
while
(
true
)
{
var
parentA
=
a
.
return
;
if
(
parentA
=
=
=
null
)
{
break
;
}
var
parentB
=
parentA
.
alternate
;
if
(
parentB
=
=
=
null
)
{
var
nextParent
=
parentA
.
return
;
if
(
nextParent
!
=
=
null
)
{
a
=
b
=
nextParent
;
continue
;
}
break
;
}
if
(
parentA
.
child
=
=
=
parentB
.
child
)
{
var
child
=
parentA
.
child
;
while
(
child
)
{
if
(
child
=
=
=
a
)
{
assertIsMounted
(
parentA
)
;
return
fiber
;
}
if
(
child
=
=
=
b
)
{
assertIsMounted
(
parentA
)
;
return
alternate
;
}
child
=
child
.
sibling
;
}
{
{
throw
Error
(
"
Unable
to
find
node
on
an
unmounted
component
.
"
)
;
}
}
}
if
(
a
.
return
!
=
=
b
.
return
)
{
a
=
parentA
;
b
=
parentB
;
}
else
{
var
didFindChild
=
false
;
var
_child
=
parentA
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentA
;
b
=
parentB
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentA
;
a
=
parentB
;
break
;
}
_child
=
_child
.
sibling
;
}
if
(
!
didFindChild
)
{
_child
=
parentB
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentB
;
b
=
parentA
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentB
;
a
=
parentA
;
break
;
}
_child
=
_child
.
sibling
;
}
if
(
!
didFindChild
)
{
{
throw
Error
(
"
Child
was
not
found
in
either
parent
set
.
This
indicates
a
bug
in
React
related
to
the
return
pointer
.
Please
file
an
issue
.
"
)
;
}
}
}
}
if
(
!
(
a
.
alternate
=
=
=
b
)
)
{
{
throw
Error
(
"
Return
fibers
should
always
be
each
others
'
alternates
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
if
(
!
(
a
.
tag
=
=
=
HostRoot
)
)
{
{
throw
Error
(
"
Unable
to
find
node
on
an
unmounted
component
.
"
)
;
}
}
if
(
a
.
stateNode
.
current
=
=
=
a
)
{
return
fiber
;
}
return
alternate
;
}
function
findCurrentHostFiber
(
parent
)
{
var
currentParent
=
findCurrentFiberUsingSlowPath
(
parent
)
;
if
(
!
currentParent
)
{
return
null
;
}
var
node
=
currentParent
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
return
node
;
}
else
if
(
node
.
child
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
currentParent
)
{
return
null
;
}
while
(
!
node
.
sibling
)
{
if
(
!
node
.
return
|
|
node
.
return
=
=
=
currentParent
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
return
null
;
}
function
findCurrentHostFiberWithNoPortals
(
parent
)
{
var
currentParent
=
findCurrentFiberUsingSlowPath
(
parent
)
;
if
(
!
currentParent
)
{
return
null
;
}
var
node
=
currentParent
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
|
|
enableFundamentalAPI
&
&
node
.
tag
=
=
=
FundamentalComponent
)
{
return
node
;
}
else
if
(
node
.
child
&
&
node
.
tag
!
=
=
HostPortal
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
currentParent
)
{
return
null
;
}
while
(
!
node
.
sibling
)
{
if
(
!
node
.
return
|
|
node
.
return
=
=
=
currentParent
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
return
null
;
}
var
attemptSynchronousHydration
;
function
setAttemptSynchronousHydration
(
fn
)
{
attemptSynchronousHydration
=
fn
;
}
var
attemptUserBlockingHydration
;
function
setAttemptUserBlockingHydration
(
fn
)
{
attemptUserBlockingHydration
=
fn
;
}
var
attemptContinuousHydration
;
function
setAttemptContinuousHydration
(
fn
)
{
attemptContinuousHydration
=
fn
;
}
var
attemptHydrationAtCurrentPriority
;
function
setAttemptHydrationAtCurrentPriority
(
fn
)
{
attemptHydrationAtCurrentPriority
=
fn
;
}
var
hasScheduledReplayAttempt
=
false
;
var
queuedDiscreteEvents
=
[
]
;
var
queuedFocus
=
null
;
var
queuedDrag
=
null
;
var
queuedMouse
=
null
;
var
queuedPointers
=
new
Map
(
)
;
var
queuedPointerCaptures
=
new
Map
(
)
;
var
queuedExplicitHydrationTargets
=
[
]
;
function
hasQueuedDiscreteEvents
(
)
{
return
queuedDiscreteEvents
.
length
>
0
;
}
var
discreteReplayableEvents
=
[
TOP_MOUSE_DOWN
TOP_MOUSE_UP
TOP_TOUCH_CANCEL
TOP_TOUCH_END
TOP_TOUCH_START
TOP_AUX_CLICK
TOP_DOUBLE_CLICK
TOP_POINTER_CANCEL
TOP_POINTER_DOWN
TOP_POINTER_UP
TOP_DRAG_END
TOP_DRAG_START
TOP_DROP
TOP_COMPOSITION_END
TOP_COMPOSITION_START
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_INPUT
TOP_TEXT_INPUT
TOP_CLOSE
TOP_CANCEL
TOP_COPY
TOP_CUT
TOP_PASTE
TOP_CLICK
TOP_CHANGE
TOP_CONTEXT_MENU
TOP_RESET
TOP_SUBMIT
]
;
var
continuousReplayableEvents
=
[
TOP_FOCUS
TOP_BLUR
TOP_DRAG_ENTER
TOP_DRAG_LEAVE
TOP_MOUSE_OVER
TOP_MOUSE_OUT
TOP_POINTER_OVER
TOP_POINTER_OUT
TOP_GOT_POINTER_CAPTURE
TOP_LOST_POINTER_CAPTURE
]
;
function
isReplayableDiscreteEvent
(
eventType
)
{
return
discreteReplayableEvents
.
indexOf
(
eventType
)
>
-
1
;
}
function
trapReplayableEvent
(
topLevelType
document
listeningSet
)
{
listenToTopLevel
(
topLevelType
document
listeningSet
)
;
if
(
enableFlareAPI
)
{
var
passiveEventKey
=
unsafeCastDOMTopLevelTypeToString
(
topLevelType
)
+
'
_passive
'
;
if
(
!
listeningSet
.
has
(
passiveEventKey
)
)
{
trapEventForResponderEventSystem
(
document
topLevelType
true
)
;
listeningSet
.
add
(
passiveEventKey
)
;
}
var
activeEventKey
=
unsafeCastDOMTopLevelTypeToString
(
topLevelType
)
+
'
_active
'
;
if
(
!
listeningSet
.
has
(
activeEventKey
)
)
{
trapEventForResponderEventSystem
(
document
topLevelType
false
)
;
listeningSet
.
add
(
activeEventKey
)
;
}
}
}
function
eagerlyTrapReplayableEvents
(
document
)
{
var
listeningSet
=
getListeningSetForElement
(
document
)
;
discreteReplayableEvents
.
forEach
(
function
(
topLevelType
)
{
trapReplayableEvent
(
topLevelType
document
listeningSet
)
;
}
)
;
continuousReplayableEvents
.
forEach
(
function
(
topLevelType
)
{
trapReplayableEvent
(
topLevelType
document
listeningSet
)
;
}
)
;
}
function
createQueuedReplayableEvent
(
blockedOn
topLevelType
eventSystemFlags
nativeEvent
)
{
return
{
blockedOn
:
blockedOn
topLevelType
:
topLevelType
eventSystemFlags
:
eventSystemFlags
|
IS_REPLAYED
nativeEvent
:
nativeEvent
}
;
}
function
queueDiscreteEvent
(
blockedOn
topLevelType
eventSystemFlags
nativeEvent
)
{
var
queuedEvent
=
createQueuedReplayableEvent
(
blockedOn
topLevelType
eventSystemFlags
nativeEvent
)
;
queuedDiscreteEvents
.
push
(
queuedEvent
)
;
if
(
enableSelectiveHydration
)
{
if
(
queuedDiscreteEvents
.
length
=
=
=
1
)
{
while
(
queuedEvent
.
blockedOn
!
=
=
null
)
{
var
_fiber
=
getInstanceFromNode
1
(
queuedEvent
.
blockedOn
)
;
if
(
_fiber
=
=
=
null
)
{
break
;
}
attemptSynchronousHydration
(
_fiber
)
;
if
(
queuedEvent
.
blockedOn
=
=
=
null
)
{
replayUnblockedEvents
(
)
;
continue
;
}
else
{
break
;
}
}
}
}
}
function
clearIfContinuousEvent
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
TOP_FOCUS
:
case
TOP_BLUR
:
queuedFocus
=
null
;
break
;
case
TOP_DRAG_ENTER
:
case
TOP_DRAG_LEAVE
:
queuedDrag
=
null
;
break
;
case
TOP_MOUSE_OVER
:
case
TOP_MOUSE_OUT
:
queuedMouse
=
null
;
break
;
case
TOP_POINTER_OVER
:
case
TOP_POINTER_OUT
:
{
var
pointerId
=
nativeEvent
.
pointerId
;
queuedPointers
.
delete
(
pointerId
)
;
break
;
}
case
TOP_GOT_POINTER_CAPTURE
:
case
TOP_LOST_POINTER_CAPTURE
:
{
var
_pointerId
=
nativeEvent
.
pointerId
;
queuedPointerCaptures
.
delete
(
_pointerId
)
;
break
;
}
}
}
function
accumulateOrCreateContinuousQueuedReplayableEvent
(
existingQueuedEvent
blockedOn
topLevelType
eventSystemFlags
nativeEvent
)
{
if
(
existingQueuedEvent
=
=
=
null
|
|
existingQueuedEvent
.
nativeEvent
!
=
=
nativeEvent
)
{
var
queuedEvent
=
createQueuedReplayableEvent
(
blockedOn
topLevelType
eventSystemFlags
nativeEvent
)
;
if
(
blockedOn
!
=
=
null
)
{
var
_fiber2
=
getInstanceFromNode
1
(
blockedOn
)
;
if
(
_fiber2
!
=
=
null
)
{
attemptContinuousHydration
(
_fiber2
)
;
}
}
return
queuedEvent
;
}
existingQueuedEvent
.
eventSystemFlags
|
=
eventSystemFlags
;
return
existingQueuedEvent
;
}
function
queueIfContinuousEvent
(
blockedOn
topLevelType
eventSystemFlags
nativeEvent
)
{
switch
(
topLevelType
)
{
case
TOP_FOCUS
:
{
var
focusEvent
=
nativeEvent
;
queuedFocus
=
accumulateOrCreateContinuousQueuedReplayableEvent
(
queuedFocus
blockedOn
topLevelType
eventSystemFlags
focusEvent
)
;
return
true
;
}
case
TOP_DRAG_ENTER
:
{
var
dragEvent
=
nativeEvent
;
queuedDrag
=
accumulateOrCreateContinuousQueuedReplayableEvent
(
queuedDrag
blockedOn
topLevelType
eventSystemFlags
dragEvent
)
;
return
true
;
}
case
TOP_MOUSE_OVER
:
{
var
mouseEvent
=
nativeEvent
;
queuedMouse
=
accumulateOrCreateContinuousQueuedReplayableEvent
(
queuedMouse
blockedOn
topLevelType
eventSystemFlags
mouseEvent
)
;
return
true
;
}
case
TOP_POINTER_OVER
:
{
var
pointerEvent
=
nativeEvent
;
var
pointerId
=
pointerEvent
.
pointerId
;
queuedPointers
.
set
(
pointerId
accumulateOrCreateContinuousQueuedReplayableEvent
(
queuedPointers
.
get
(
pointerId
)
|
|
null
blockedOn
topLevelType
eventSystemFlags
pointerEvent
)
)
;
return
true
;
}
case
TOP_GOT_POINTER_CAPTURE
:
{
var
_pointerEvent
=
nativeEvent
;
var
_pointerId2
=
_pointerEvent
.
pointerId
;
queuedPointerCaptures
.
set
(
_pointerId2
accumulateOrCreateContinuousQueuedReplayableEvent
(
queuedPointerCaptures
.
get
(
_pointerId2
)
|
|
null
blockedOn
topLevelType
eventSystemFlags
_pointerEvent
)
)
;
return
true
;
}
}
return
false
;
}
function
attemptExplicitHydrationTarget
(
queuedTarget
)
{
var
targetInst
=
getClosestInstanceFromNode
(
queuedTarget
.
target
)
;
if
(
targetInst
!
=
=
null
)
{
var
nearestMounted
=
getNearestMountedFiber
(
targetInst
)
;
if
(
nearestMounted
!
=
=
null
)
{
var
tag
=
nearestMounted
.
tag
;
if
(
tag
=
=
=
SuspenseComponent
)
{
var
instance
=
getSuspenseInstanceFromFiber
(
nearestMounted
)
;
if
(
instance
!
=
=
null
)
{
queuedTarget
.
blockedOn
=
instance
;
unstable_runWithPriority
(
queuedTarget
.
priority
function
(
)
{
attemptHydrationAtCurrentPriority
(
nearestMounted
)
;
}
)
;
return
;
}
}
else
if
(
tag
=
=
=
HostRoot
)
{
var
root
=
nearestMounted
.
stateNode
;
if
(
root
.
hydrate
)
{
queuedTarget
.
blockedOn
=
getContainerFromFiber
(
nearestMounted
)
;
return
;
}
}
}
}
queuedTarget
.
blockedOn
=
null
;
}
function
queueExplicitHydrationTarget
(
target
)
{
if
(
enableSelectiveHydration
)
{
var
priority
=
unstable_getCurrentPriorityLevel
(
)
;
var
queuedTarget
=
{
blockedOn
:
null
target
:
target
priority
:
priority
}
;
var
i
=
0
;
for
(
;
i
<
queuedExplicitHydrationTargets
.
length
;
i
+
+
)
{
if
(
priority
<
=
queuedExplicitHydrationTargets
[
i
]
.
priority
)
{
break
;
}
}
queuedExplicitHydrationTargets
.
splice
(
i
0
queuedTarget
)
;
if
(
i
=
=
=
0
)
{
attemptExplicitHydrationTarget
(
queuedTarget
)
;
}
}
}
function
attemptReplayContinuousQueuedEvent
(
queuedEvent
)
{
if
(
queuedEvent
.
blockedOn
!
=
=
null
)
{
return
false
;
}
var
nextBlockedOn
=
attemptToDispatchEvent
(
queuedEvent
.
topLevelType
queuedEvent
.
eventSystemFlags
queuedEvent
.
nativeEvent
)
;
if
(
nextBlockedOn
!
=
=
null
)
{
var
_fiber3
=
getInstanceFromNode
1
(
nextBlockedOn
)
;
if
(
_fiber3
!
=
=
null
)
{
attemptContinuousHydration
(
_fiber3
)
;
}
queuedEvent
.
blockedOn
=
nextBlockedOn
;
return
false
;
}
return
true
;
}
function
attemptReplayContinuousQueuedEventInMap
(
queuedEvent
key
map
)
{
if
(
attemptReplayContinuousQueuedEvent
(
queuedEvent
)
)
{
map
.
delete
(
key
)
;
}
}
function
replayUnblockedEvents
(
)
{
hasScheduledReplayAttempt
=
false
;
while
(
queuedDiscreteEvents
.
length
>
0
)
{
var
nextDiscreteEvent
=
queuedDiscreteEvents
[
0
]
;
if
(
nextDiscreteEvent
.
blockedOn
!
=
=
null
)
{
var
_fiber4
=
getInstanceFromNode
1
(
nextDiscreteEvent
.
blockedOn
)
;
if
(
_fiber4
!
=
=
null
)
{
attemptUserBlockingHydration
(
_fiber4
)
;
}
break
;
}
var
nextBlockedOn
=
attemptToDispatchEvent
(
nextDiscreteEvent
.
topLevelType
nextDiscreteEvent
.
eventSystemFlags
nextDiscreteEvent
.
nativeEvent
)
;
if
(
nextBlockedOn
!
=
=
null
)
{
nextDiscreteEvent
.
blockedOn
=
nextBlockedOn
;
}
else
{
queuedDiscreteEvents
.
shift
(
)
;
}
}
if
(
queuedFocus
!
=
=
null
&
&
attemptReplayContinuousQueuedEvent
(
queuedFocus
)
)
{
queuedFocus
=
null
;
}
if
(
queuedDrag
!
=
=
null
&
&
attemptReplayContinuousQueuedEvent
(
queuedDrag
)
)
{
queuedDrag
=
null
;
}
if
(
queuedMouse
!
=
=
null
&
&
attemptReplayContinuousQueuedEvent
(
queuedMouse
)
)
{
queuedMouse
=
null
;
}
queuedPointers
.
forEach
(
attemptReplayContinuousQueuedEventInMap
)
;
queuedPointerCaptures
.
forEach
(
attemptReplayContinuousQueuedEventInMap
)
;
}
function
scheduleCallbackIfUnblocked
(
queuedEvent
unblocked
)
{
if
(
queuedEvent
.
blockedOn
=
=
=
unblocked
)
{
queuedEvent
.
blockedOn
=
null
;
if
(
!
hasScheduledReplayAttempt
)
{
hasScheduledReplayAttempt
=
true
;
unstable_scheduleCallback
(
unstable_NormalPriority
replayUnblockedEvents
)
;
}
}
}
function
retryIfBlockedOn
(
unblocked
)
{
if
(
queuedDiscreteEvents
.
length
>
0
)
{
scheduleCallbackIfUnblocked
(
queuedDiscreteEvents
[
0
]
unblocked
)
;
for
(
var
i
=
1
;
i
<
queuedDiscreteEvents
.
length
;
i
+
+
)
{
var
queuedEvent
=
queuedDiscreteEvents
[
i
]
;
if
(
queuedEvent
.
blockedOn
=
=
=
unblocked
)
{
queuedEvent
.
blockedOn
=
null
;
}
}
}
if
(
queuedFocus
!
=
=
null
)
{
scheduleCallbackIfUnblocked
(
queuedFocus
unblocked
)
;
}
if
(
queuedDrag
!
=
=
null
)
{
scheduleCallbackIfUnblocked
(
queuedDrag
unblocked
)
;
}
if
(
queuedMouse
!
=
=
null
)
{
scheduleCallbackIfUnblocked
(
queuedMouse
unblocked
)
;
}
var
unblock
=
function
(
queuedEvent
)
{
return
scheduleCallbackIfUnblocked
(
queuedEvent
unblocked
)
;
}
;
queuedPointers
.
forEach
(
unblock
)
;
queuedPointerCaptures
.
forEach
(
unblock
)
;
for
(
var
_i
=
0
;
_i
<
queuedExplicitHydrationTargets
.
length
;
_i
+
+
)
{
var
queuedTarget
=
queuedExplicitHydrationTargets
[
_i
]
;
if
(
queuedTarget
.
blockedOn
=
=
=
unblocked
)
{
queuedTarget
.
blockedOn
=
null
;
}
}
while
(
queuedExplicitHydrationTargets
.
length
>
0
)
{
var
nextExplicitTarget
=
queuedExplicitHydrationTargets
[
0
]
;
if
(
nextExplicitTarget
.
blockedOn
!
=
=
null
)
{
break
;
}
else
{
attemptExplicitHydrationTarget
(
nextExplicitTarget
)
;
if
(
nextExplicitTarget
.
blockedOn
=
=
=
null
)
{
queuedExplicitHydrationTargets
.
shift
(
)
;
}
}
}
}
function
addEventBubbleListener
(
element
eventType
listener
)
{
element
.
addEventListener
(
eventType
listener
false
)
;
}
function
addEventCaptureListener
(
element
eventType
listener
)
{
element
.
addEventListener
(
eventType
listener
true
)
;
}
function
addEventCaptureListenerWithPassiveFlag
(
element
eventType
listener
passive
)
{
element
.
addEventListener
(
eventType
listener
{
capture
:
true
passive
:
passive
}
)
;
}
function
getEventTarget
(
nativeEvent
)
{
var
target
=
nativeEvent
.
target
|
|
nativeEvent
.
srcElement
|
|
window
;
if
(
target
.
correspondingUseElement
)
{
target
=
target
.
correspondingUseElement
;
}
return
target
.
nodeType
=
=
=
TEXT_NODE
?
target
.
parentNode
:
target
;
}
function
getParent
(
inst
)
{
do
{
inst
=
inst
.
return
;
}
while
(
inst
&
&
inst
.
tag
!
=
=
HostComponent
)
;
if
(
inst
)
{
return
inst
;
}
return
null
;
}
function
getLowestCommonAncestor
(
instA
instB
)
{
var
depthA
=
0
;
for
(
var
tempA
=
instA
;
tempA
;
tempA
=
getParent
(
tempA
)
)
{
depthA
+
+
;
}
var
depthB
=
0
;
for
(
var
tempB
=
instB
;
tempB
;
tempB
=
getParent
(
tempB
)
)
{
depthB
+
+
;
}
while
(
depthA
-
depthB
>
0
)
{
instA
=
getParent
(
instA
)
;
depthA
-
-
;
}
while
(
depthB
-
depthA
>
0
)
{
instB
=
getParent
(
instB
)
;
depthB
-
-
;
}
var
depth
=
depthA
;
while
(
depth
-
-
)
{
if
(
instA
=
=
=
instB
|
|
instA
=
=
=
instB
.
alternate
)
{
return
instA
;
}
instA
=
getParent
(
instA
)
;
instB
=
getParent
(
instB
)
;
}
return
null
;
}
function
traverseTwoPhase
(
inst
fn
arg
)
{
var
path
=
[
]
;
while
(
inst
)
{
path
.
push
(
inst
)
;
inst
=
getParent
(
inst
)
;
}
var
i
;
for
(
i
=
path
.
length
;
i
-
-
>
0
;
)
{
fn
(
path
[
i
]
'
captured
'
arg
)
;
}
for
(
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
fn
(
path
[
i
]
'
bubbled
'
arg
)
;
}
}
function
traverseEnterLeave
(
from
to
fn
argFrom
argTo
)
{
var
common
=
from
&
&
to
?
getLowestCommonAncestor
(
from
to
)
:
null
;
var
pathFrom
=
[
]
;
while
(
true
)
{
if
(
!
from
)
{
break
;
}
if
(
from
=
=
=
common
)
{
break
;
}
var
alternate
=
from
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
=
=
=
common
)
{
break
;
}
pathFrom
.
push
(
from
)
;
from
=
getParent
(
from
)
;
}
var
pathTo
=
[
]
;
while
(
true
)
{
if
(
!
to
)
{
break
;
}
if
(
to
=
=
=
common
)
{
break
;
}
var
_alternate
=
to
.
alternate
;
if
(
_alternate
!
=
=
null
&
&
_alternate
=
=
=
common
)
{
break
;
}
pathTo
.
push
(
to
)
;
to
=
getParent
(
to
)
;
}
for
(
var
i
=
0
;
i
<
pathFrom
.
length
;
i
+
+
)
{
fn
(
pathFrom
[
i
]
'
bubbled
'
argFrom
)
;
}
for
(
var
_i
=
pathTo
.
length
;
_i
-
-
>
0
;
)
{
fn
(
pathTo
[
_i
]
'
captured
'
argTo
)
;
}
}
function
listenerAtPhase
(
inst
event
propagationPhase
)
{
var
registrationName
=
event
.
dispatchConfig
.
phasedRegistrationNames
[
propagationPhase
]
;
return
getListener
(
inst
registrationName
)
;
}
function
accumulateDirectionalDispatches
(
inst
phase
event
)
{
{
!
inst
?
warningWithoutStack
1
(
false
'
Dispatching
inst
must
not
be
null
'
)
:
void
0
;
}
var
listener
=
listenerAtPhase
(
inst
event
phase
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchInstances
=
accumulateInto
(
event
.
_dispatchInstances
inst
)
;
}
}
function
accumulateTwoPhaseDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
traverseTwoPhase
(
event
.
_targetInst
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateDispatches
(
inst
ignoredDirection
event
)
{
if
(
inst
&
&
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
var
registrationName
=
event
.
dispatchConfig
.
registrationName
;
var
listener
=
getListener
(
inst
registrationName
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchInstances
=
accumulateInto
(
event
.
_dispatchInstances
inst
)
;
}
}
}
function
accumulateDirectDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
accumulateDispatches
(
event
.
_targetInst
null
event
)
;
}
}
function
accumulateTwoPhaseDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingle
)
;
}
function
accumulateEnterLeaveDispatches
(
leave
enter
from
to
)
{
traverseEnterLeave
(
from
to
accumulateDispatches
leave
enter
)
;
}
function
accumulateDirectDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateDirectDispatchesSingle
)
;
}
var
EVENT_POOL_SIZE
=
10
;
var
EventInterface
=
{
type
:
null
target
:
null
currentTarget
:
function
(
)
{
return
null
;
}
eventPhase
:
null
bubbles
:
null
cancelable
:
null
timeStamp
:
function
(
event
)
{
return
event
.
timeStamp
|
|
Date
.
now
(
)
;
}
defaultPrevented
:
null
isTrusted
:
null
}
;
function
functionThatReturnsTrue
(
)
{
return
true
;
}
function
functionThatReturnsFalse
(
)
{
return
false
;
}
function
SyntheticEvent
(
dispatchConfig
targetInst
nativeEvent
nativeEventTarget
)
{
{
delete
this
.
nativeEvent
;
delete
this
.
preventDefault
;
delete
this
.
stopPropagation
;
delete
this
.
isDefaultPrevented
;
delete
this
.
isPropagationStopped
;
}
this
.
dispatchConfig
=
dispatchConfig
;
this
.
_targetInst
=
targetInst
;
this
.
nativeEvent
=
nativeEvent
;
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
if
(
!
Interface
.
hasOwnProperty
(
propName
)
)
{
continue
;
}
{
delete
this
[
propName
]
;
}
var
normalize
=
Interface
[
propName
]
;
if
(
normalize
)
{
this
[
propName
]
=
normalize
(
nativeEvent
)
;
}
else
{
if
(
propName
=
=
=
'
target
'
)
{
this
.
target
=
nativeEventTarget
;
}
else
{
this
[
propName
]
=
nativeEvent
[
propName
]
;
}
}
}
var
defaultPrevented
=
nativeEvent
.
defaultPrevented
!
=
null
?
nativeEvent
.
defaultPrevented
:
nativeEvent
.
returnValue
=
=
=
false
;
if
(
defaultPrevented
)
{
this
.
isDefaultPrevented
=
functionThatReturnsTrue
;
}
else
{
this
.
isDefaultPrevented
=
functionThatReturnsFalse
;
}
this
.
isPropagationStopped
=
functionThatReturnsFalse
;
return
this
;
}
_assign
(
SyntheticEvent
.
prototype
{
preventDefault
:
function
(
)
{
this
.
defaultPrevented
=
true
;
var
event
=
this
.
nativeEvent
;
if
(
!
event
)
{
return
;
}
if
(
event
.
preventDefault
)
{
event
.
preventDefault
(
)
;
}
else
if
(
typeof
event
.
returnValue
!
=
=
'
unknown
'
)
{
event
.
returnValue
=
false
;
}
this
.
isDefaultPrevented
=
functionThatReturnsTrue
;
}
stopPropagation
:
function
(
)
{
var
event
=
this
.
nativeEvent
;
if
(
!
event
)
{
return
;
}
if
(
event
.
stopPropagation
)
{
event
.
stopPropagation
(
)
;
}
else
if
(
typeof
event
.
cancelBubble
!
=
=
'
unknown
'
)
{
event
.
cancelBubble
=
true
;
}
this
.
isPropagationStopped
=
functionThatReturnsTrue
;
}
persist
:
function
(
)
{
this
.
isPersistent
=
functionThatReturnsTrue
;
}
isPersistent
:
functionThatReturnsFalse
destructor
:
function
(
)
{
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
{
Object
.
defineProperty
(
this
propName
getPooledWarningPropertyDefinition
(
propName
Interface
[
propName
]
)
)
;
}
}
this
.
dispatchConfig
=
null
;
this
.
_targetInst
=
null
;
this
.
nativeEvent
=
null
;
this
.
isDefaultPrevented
=
functionThatReturnsFalse
;
this
.
isPropagationStopped
=
functionThatReturnsFalse
;
this
.
_dispatchListeners
=
null
;
this
.
_dispatchInstances
=
null
;
{
Object
.
defineProperty
(
this
'
nativeEvent
'
getPooledWarningPropertyDefinition
(
'
nativeEvent
'
null
)
)
;
Object
.
defineProperty
(
this
'
isDefaultPrevented
'
getPooledWarningPropertyDefinition
(
'
isDefaultPrevented
'
functionThatReturnsFalse
)
)
;
Object
.
defineProperty
(
this
'
isPropagationStopped
'
getPooledWarningPropertyDefinition
(
'
isPropagationStopped
'
functionThatReturnsFalse
)
)
;
Object
.
defineProperty
(
this
'
preventDefault
'
getPooledWarningPropertyDefinition
(
'
preventDefault
'
function
(
)
{
}
)
)
;
Object
.
defineProperty
(
this
'
stopPropagation
'
getPooledWarningPropertyDefinition
(
'
stopPropagation
'
function
(
)
{
}
)
)
;
}
}
}
)
;
SyntheticEvent
.
Interface
=
EventInterface
;
SyntheticEvent
.
extend
=
function
(
Interface
)
{
var
Super
=
this
;
var
E
=
function
(
)
{
}
;
E
.
prototype
=
Super
.
prototype
;
var
prototype
=
new
E
(
)
;
function
Class
(
)
{
return
Super
.
apply
(
this
arguments
)
;
}
_assign
(
prototype
Class
.
prototype
)
;
Class
.
prototype
=
prototype
;
Class
.
prototype
.
constructor
=
Class
;
Class
.
Interface
=
_assign
(
{
}
Super
.
Interface
Interface
)
;
Class
.
extend
=
Super
.
extend
;
addEventPoolingTo
(
Class
)
;
return
Class
;
}
;
addEventPoolingTo
(
SyntheticEvent
)
;
function
getPooledWarningPropertyDefinition
(
propName
getVal
)
{
var
isFunction
=
typeof
getVal
=
=
=
'
function
'
;
return
{
configurable
:
true
set
:
set
get
:
get
}
;
function
set
(
val
)
{
var
action
=
isFunction
?
'
setting
the
method
'
:
'
setting
the
property
'
;
warn
(
action
'
This
is
effectively
a
no
-
op
'
)
;
return
val
;
}
function
get
(
)
{
var
action
=
isFunction
?
'
accessing
the
method
'
:
'
accessing
the
property
'
;
var
result
=
isFunction
?
'
This
is
a
no
-
op
function
'
:
'
This
is
set
to
null
'
;
warn
(
action
result
)
;
return
getVal
;
}
function
warn
(
action
result
)
{
var
warningCondition
=
false
;
!
warningCondition
?
warningWithoutStack
1
(
false
"
This
synthetic
event
is
reused
for
performance
reasons
.
If
you
'
re
seeing
this
"
+
"
you
'
re
%
s
%
s
on
a
released
/
nullified
synthetic
event
.
%
s
.
"
+
'
If
you
must
keep
the
original
synthetic
event
around
use
event
.
persist
(
)
.
'
+
'
See
https
:
/
/
fb
.
me
/
react
-
event
-
pooling
for
more
information
.
'
action
propName
result
)
:
void
0
;
}
}
function
getPooledEvent
(
dispatchConfig
targetInst
nativeEvent
nativeInst
)
{
var
EventConstructor
=
this
;
if
(
EventConstructor
.
eventPool
.
length
)
{
var
instance
=
EventConstructor
.
eventPool
.
pop
(
)
;
EventConstructor
.
call
(
instance
dispatchConfig
targetInst
nativeEvent
nativeInst
)
;
return
instance
;
}
return
new
EventConstructor
(
dispatchConfig
targetInst
nativeEvent
nativeInst
)
;
}
function
releasePooledEvent
(
event
)
{
var
EventConstructor
=
this
;
if
(
!
(
event
instanceof
EventConstructor
)
)
{
{
throw
Error
(
"
Trying
to
release
an
event
instance
into
a
pool
of
a
different
type
.
"
)
;
}
}
event
.
destructor
(
)
;
if
(
EventConstructor
.
eventPool
.
length
<
EVENT_POOL_SIZE
)
{
EventConstructor
.
eventPool
.
push
(
event
)
;
}
}
function
addEventPoolingTo
(
EventConstructor
)
{
EventConstructor
.
eventPool
=
[
]
;
EventConstructor
.
getPooled
=
getPooledEvent
;
EventConstructor
.
release
=
releasePooledEvent
;
}
var
SyntheticAnimationEvent
=
SyntheticEvent
.
extend
(
{
animationName
:
null
elapsedTime
:
null
pseudoElement
:
null
}
)
;
var
SyntheticClipboardEvent
=
SyntheticEvent
.
extend
(
{
clipboardData
:
function
(
event
)
{
return
'
clipboardData
'
in
event
?
event
.
clipboardData
:
window
.
clipboardData
;
}
}
)
;
var
SyntheticUIEvent
=
SyntheticEvent
.
extend
(
{
view
:
null
detail
:
null
}
)
;
var
SyntheticFocusEvent
=
SyntheticUIEvent
.
extend
(
{
relatedTarget
:
null
}
)
;
function
getEventCharCode
(
nativeEvent
)
{
var
charCode
;
var
keyCode
=
nativeEvent
.
keyCode
;
if
(
'
charCode
'
in
nativeEvent
)
{
charCode
=
nativeEvent
.
charCode
;
if
(
charCode
=
=
=
0
&
&
keyCode
=
=
=
13
)
{
charCode
=
13
;
}
}
else
{
charCode
=
keyCode
;
}
if
(
charCode
=
=
=
10
)
{
charCode
=
13
;
}
if
(
charCode
>
=
32
|
|
charCode
=
=
=
13
)
{
return
charCode
;
}
return
0
;
}
var
normalizeKey
=
{
Esc
:
'
Escape
'
Spacebar
:
'
'
Left
:
'
ArrowLeft
'
Up
:
'
ArrowUp
'
Right
:
'
ArrowRight
'
Down
:
'
ArrowDown
'
Del
:
'
Delete
'
Win
:
'
OS
'
Menu
:
'
ContextMenu
'
Apps
:
'
ContextMenu
'
Scroll
:
'
ScrollLock
'
MozPrintableKey
:
'
Unidentified
'
}
;
var
translateToKey
=
{
'
8
'
:
'
Backspace
'
'
9
'
:
'
Tab
'
'
12
'
:
'
Clear
'
'
13
'
:
'
Enter
'
'
16
'
:
'
Shift
'
'
17
'
:
'
Control
'
'
18
'
:
'
Alt
'
'
19
'
:
'
Pause
'
'
20
'
:
'
CapsLock
'
'
27
'
:
'
Escape
'
'
32
'
:
'
'
'
33
'
:
'
PageUp
'
'
34
'
:
'
PageDown
'
'
35
'
:
'
End
'
'
36
'
:
'
Home
'
'
37
'
:
'
ArrowLeft
'
'
38
'
:
'
ArrowUp
'
'
39
'
:
'
ArrowRight
'
'
40
'
:
'
ArrowDown
'
'
45
'
:
'
Insert
'
'
46
'
:
'
Delete
'
'
112
'
:
'
F1
'
'
113
'
:
'
F2
'
'
114
'
:
'
F3
'
'
115
'
:
'
F4
'
'
116
'
:
'
F5
'
'
117
'
:
'
F6
'
'
118
'
:
'
F7
'
'
119
'
:
'
F8
'
'
120
'
:
'
F9
'
'
121
'
:
'
F10
'
'
122
'
:
'
F11
'
'
123
'
:
'
F12
'
'
144
'
:
'
NumLock
'
'
145
'
:
'
ScrollLock
'
'
224
'
:
'
Meta
'
}
;
function
getEventKey
(
nativeEvent
)
{
if
(
nativeEvent
.
key
)
{
var
key
=
normalizeKey
[
nativeEvent
.
key
]
|
|
nativeEvent
.
key
;
if
(
key
!
=
=
'
Unidentified
'
)
{
return
key
;
}
}
if
(
nativeEvent
.
type
=
=
=
'
keypress
'
)
{
var
charCode
=
getEventCharCode
(
nativeEvent
)
;
return
charCode
=
=
=
13
?
'
Enter
'
:
String
.
fromCharCode
(
charCode
)
;
}
if
(
nativeEvent
.
type
=
=
=
'
keydown
'
|
|
nativeEvent
.
type
=
=
=
'
keyup
'
)
{
return
translateToKey
[
nativeEvent
.
keyCode
]
|
|
'
Unidentified
'
;
}
return
'
'
;
}
var
modifierKeyToProp
=
{
Alt
:
'
altKey
'
Control
:
'
ctrlKey
'
Meta
:
'
metaKey
'
Shift
:
'
shiftKey
'
}
;
function
modifierStateGetter
(
keyArg
)
{
var
syntheticEvent
=
this
;
var
nativeEvent
=
syntheticEvent
.
nativeEvent
;
if
(
nativeEvent
.
getModifierState
)
{
return
nativeEvent
.
getModifierState
(
keyArg
)
;
}
var
keyProp
=
modifierKeyToProp
[
keyArg
]
;
return
keyProp
?
!
!
nativeEvent
[
keyProp
]
:
false
;
}
function
getEventModifierState
(
nativeEvent
)
{
return
modifierStateGetter
;
}
var
SyntheticKeyboardEvent
=
SyntheticUIEvent
.
extend
(
{
key
:
getEventKey
location
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
repeat
:
null
locale
:
null
getModifierState
:
getEventModifierState
charCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
return
0
;
}
keyCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
which
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
}
)
;
var
previousScreenX
=
0
;
var
previousScreenY
=
0
;
var
isMovementXSet
=
false
;
var
isMovementYSet
=
false
;
var
SyntheticMouseEvent
=
SyntheticUIEvent
.
extend
(
{
screenX
:
null
screenY
:
null
clientX
:
null
clientY
:
null
pageX
:
null
pageY
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
getModifierState
:
getEventModifierState
button
:
null
buttons
:
null
relatedTarget
:
function
(
event
)
{
return
event
.
relatedTarget
|
|
(
event
.
fromElement
=
=
=
event
.
srcElement
?
event
.
toElement
:
event
.
fromElement
)
;
}
movementX
:
function
(
event
)
{
if
(
'
movementX
'
in
event
)
{
return
event
.
movementX
;
}
var
screenX
=
previousScreenX
;
previousScreenX
=
event
.
screenX
;
if
(
!
isMovementXSet
)
{
isMovementXSet
=
true
;
return
0
;
}
return
event
.
type
=
=
=
'
mousemove
'
?
event
.
screenX
-
screenX
:
0
;
}
movementY
:
function
(
event
)
{
if
(
'
movementY
'
in
event
)
{
return
event
.
movementY
;
}
var
screenY
=
previousScreenY
;
previousScreenY
=
event
.
screenY
;
if
(
!
isMovementYSet
)
{
isMovementYSet
=
true
;
return
0
;
}
return
event
.
type
=
=
=
'
mousemove
'
?
event
.
screenY
-
screenY
:
0
;
}
}
)
;
var
SyntheticPointerEvent
=
SyntheticMouseEvent
.
extend
(
{
pointerId
:
null
width
:
null
height
:
null
pressure
:
null
tangentialPressure
:
null
tiltX
:
null
tiltY
:
null
twist
:
null
pointerType
:
null
isPrimary
:
null
}
)
;
var
SyntheticDragEvent
=
SyntheticMouseEvent
.
extend
(
{
dataTransfer
:
null
}
)
;
var
SyntheticTouchEvent
=
SyntheticUIEvent
.
extend
(
{
touches
:
null
targetTouches
:
null
changedTouches
:
null
altKey
:
null
metaKey
:
null
ctrlKey
:
null
shiftKey
:
null
getModifierState
:
getEventModifierState
}
)
;
var
SyntheticTransitionEvent
=
SyntheticEvent
.
extend
(
{
propertyName
:
null
elapsedTime
:
null
pseudoElement
:
null
}
)
;
var
SyntheticWheelEvent
=
SyntheticMouseEvent
.
extend
(
{
deltaX
:
function
(
event
)
{
return
'
deltaX
'
in
event
?
event
.
deltaX
:
'
wheelDeltaX
'
in
event
?
-
event
.
wheelDeltaX
:
0
;
}
deltaY
:
function
(
event
)
{
return
'
deltaY
'
in
event
?
event
.
deltaY
:
'
wheelDeltaY
'
in
event
?
-
event
.
wheelDeltaY
:
'
wheelDelta
'
in
event
?
-
event
.
wheelDelta
:
0
;
}
deltaZ
:
null
deltaMode
:
null
}
)
;
var
eventTuples
=
[
[
TOP_BLUR
'
blur
'
DiscreteEvent
]
[
TOP_CANCEL
'
cancel
'
DiscreteEvent
]
[
TOP_CLICK
'
click
'
DiscreteEvent
]
[
TOP_CLOSE
'
close
'
DiscreteEvent
]
[
TOP_CONTEXT_MENU
'
contextMenu
'
DiscreteEvent
]
[
TOP_COPY
'
copy
'
DiscreteEvent
]
[
TOP_CUT
'
cut
'
DiscreteEvent
]
[
TOP_AUX_CLICK
'
auxClick
'
DiscreteEvent
]
[
TOP_DOUBLE_CLICK
'
doubleClick
'
DiscreteEvent
]
[
TOP_DRAG_END
'
dragEnd
'
DiscreteEvent
]
[
TOP_DRAG_START
'
dragStart
'
DiscreteEvent
]
[
TOP_DROP
'
drop
'
DiscreteEvent
]
[
TOP_FOCUS
'
focus
'
DiscreteEvent
]
[
TOP_INPUT
'
input
'
DiscreteEvent
]
[
TOP_INVALID
'
invalid
'
DiscreteEvent
]
[
TOP_KEY_DOWN
'
keyDown
'
DiscreteEvent
]
[
TOP_KEY_PRESS
'
keyPress
'
DiscreteEvent
]
[
TOP_KEY_UP
'
keyUp
'
DiscreteEvent
]
[
TOP_MOUSE_DOWN
'
mouseDown
'
DiscreteEvent
]
[
TOP_MOUSE_UP
'
mouseUp
'
DiscreteEvent
]
[
TOP_PASTE
'
paste
'
DiscreteEvent
]
[
TOP_PAUSE
'
pause
'
DiscreteEvent
]
[
TOP_PLAY
'
play
'
DiscreteEvent
]
[
TOP_POINTER_CANCEL
'
pointerCancel
'
DiscreteEvent
]
[
TOP_POINTER_DOWN
'
pointerDown
'
DiscreteEvent
]
[
TOP_POINTER_UP
'
pointerUp
'
DiscreteEvent
]
[
TOP_RATE_CHANGE
'
rateChange
'
DiscreteEvent
]
[
TOP_RESET
'
reset
'
DiscreteEvent
]
[
TOP_SEEKED
'
seeked
'
DiscreteEvent
]
[
TOP_SUBMIT
'
submit
'
DiscreteEvent
]
[
TOP_TOUCH_CANCEL
'
touchCancel
'
DiscreteEvent
]
[
TOP_TOUCH_END
'
touchEnd
'
DiscreteEvent
]
[
TOP_TOUCH_START
'
touchStart
'
DiscreteEvent
]
[
TOP_VOLUME_CHANGE
'
volumeChange
'
DiscreteEvent
]
[
TOP_DRAG
'
drag
'
UserBlockingEvent
]
[
TOP_DRAG_ENTER
'
dragEnter
'
UserBlockingEvent
]
[
TOP_DRAG_EXIT
'
dragExit
'
UserBlockingEvent
]
[
TOP_DRAG_LEAVE
'
dragLeave
'
UserBlockingEvent
]
[
TOP_DRAG_OVER
'
dragOver
'
UserBlockingEvent
]
[
TOP_MOUSE_MOVE
'
mouseMove
'
UserBlockingEvent
]
[
TOP_MOUSE_OUT
'
mouseOut
'
UserBlockingEvent
]
[
TOP_MOUSE_OVER
'
mouseOver
'
UserBlockingEvent
]
[
TOP_POINTER_MOVE
'
pointerMove
'
UserBlockingEvent
]
[
TOP_POINTER_OUT
'
pointerOut
'
UserBlockingEvent
]
[
TOP_POINTER_OVER
'
pointerOver
'
UserBlockingEvent
]
[
TOP_SCROLL
'
scroll
'
UserBlockingEvent
]
[
TOP_TOGGLE
'
toggle
'
UserBlockingEvent
]
[
TOP_TOUCH_MOVE
'
touchMove
'
UserBlockingEvent
]
[
TOP_WHEEL
'
wheel
'
UserBlockingEvent
]
[
TOP_ABORT
'
abort
'
ContinuousEvent
]
[
TOP_ANIMATION_END
'
animationEnd
'
ContinuousEvent
]
[
TOP_ANIMATION_ITERATION
'
animationIteration
'
ContinuousEvent
]
[
TOP_ANIMATION_START
'
animationStart
'
ContinuousEvent
]
[
TOP_CAN_PLAY
'
canPlay
'
ContinuousEvent
]
[
TOP_CAN_PLAY_THROUGH
'
canPlayThrough
'
ContinuousEvent
]
[
TOP_DURATION_CHANGE
'
durationChange
'
ContinuousEvent
]
[
TOP_EMPTIED
'
emptied
'
ContinuousEvent
]
[
TOP_ENCRYPTED
'
encrypted
'
ContinuousEvent
]
[
TOP_ENDED
'
ended
'
ContinuousEvent
]
[
TOP_ERROR
'
error
'
ContinuousEvent
]
[
TOP_GOT_POINTER_CAPTURE
'
gotPointerCapture
'
ContinuousEvent
]
[
TOP_LOAD
'
load
'
ContinuousEvent
]
[
TOP_LOADED_DATA
'
loadedData
'
ContinuousEvent
]
[
TOP_LOADED_METADATA
'
loadedMetadata
'
ContinuousEvent
]
[
TOP_LOAD_START
'
loadStart
'
ContinuousEvent
]
[
TOP_LOST_POINTER_CAPTURE
'
lostPointerCapture
'
ContinuousEvent
]
[
TOP_PLAYING
'
playing
'
ContinuousEvent
]
[
TOP_PROGRESS
'
progress
'
ContinuousEvent
]
[
TOP_SEEKING
'
seeking
'
ContinuousEvent
]
[
TOP_STALLED
'
stalled
'
ContinuousEvent
]
[
TOP_SUSPEND
'
suspend
'
ContinuousEvent
]
[
TOP_TIME_UPDATE
'
timeUpdate
'
ContinuousEvent
]
[
TOP_TRANSITION_END
'
transitionEnd
'
ContinuousEvent
]
[
TOP_WAITING
'
waiting
'
ContinuousEvent
]
]
;
var
eventTypes
=
{
}
;
var
topLevelEventsToDispatchConfig
=
{
}
;
for
(
var
i
=
0
;
i
<
eventTuples
.
length
;
i
+
+
)
{
var
eventTuple
=
eventTuples
[
i
]
;
var
topEvent
=
eventTuple
[
0
]
;
var
event
=
eventTuple
[
1
]
;
var
eventPriority
=
eventTuple
[
2
]
;
var
capitalizedEvent
=
event
[
0
]
.
toUpperCase
(
)
+
event
.
slice
(
1
)
;
var
onEvent
=
'
on
'
+
capitalizedEvent
;
var
config
=
{
phasedRegistrationNames
:
{
bubbled
:
onEvent
captured
:
onEvent
+
'
Capture
'
}
dependencies
:
[
topEvent
]
eventPriority
:
eventPriority
}
;
eventTypes
[
event
]
=
config
;
topLevelEventsToDispatchConfig
[
topEvent
]
=
config
;
}
var
knownHTMLTopLevelTypes
=
[
TOP_ABORT
TOP_CANCEL
TOP_CAN_PLAY
TOP_CAN_PLAY_THROUGH
TOP_CLOSE
TOP_DURATION_CHANGE
TOP_EMPTIED
TOP_ENCRYPTED
TOP_ENDED
TOP_ERROR
TOP_INPUT
TOP_INVALID
TOP_LOAD
TOP_LOADED_DATA
TOP_LOADED_METADATA
TOP_LOAD_START
TOP_PAUSE
TOP_PLAY
TOP_PLAYING
TOP_PROGRESS
TOP_RATE_CHANGE
TOP_RESET
TOP_SEEKED
TOP_SEEKING
TOP_STALLED
TOP_SUBMIT
TOP_SUSPEND
TOP_TIME_UPDATE
TOP_TOGGLE
TOP_VOLUME_CHANGE
TOP_WAITING
]
;
var
SimpleEventPlugin
=
{
eventTypes
:
eventTypes
getEventPriority
:
function
(
topLevelType
)
{
var
config
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
return
config
!
=
=
undefined
?
config
.
eventPriority
:
ContinuousEvent
;
}
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
var
dispatchConfig
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
if
(
!
dispatchConfig
)
{
return
null
;
}
var
EventConstructor
;
switch
(
topLevelType
)
{
case
TOP_KEY_PRESS
:
if
(
getEventCharCode
(
nativeEvent
)
=
=
=
0
)
{
return
null
;
}
case
TOP_KEY_DOWN
:
case
TOP_KEY_UP
:
EventConstructor
=
SyntheticKeyboardEvent
;
break
;
case
TOP_BLUR
:
case
TOP_FOCUS
:
EventConstructor
=
SyntheticFocusEvent
;
break
;
case
TOP_CLICK
:
if
(
nativeEvent
.
button
=
=
=
2
)
{
return
null
;
}
case
TOP_AUX_CLICK
:
case
TOP_DOUBLE_CLICK
:
case
TOP_MOUSE_DOWN
:
case
TOP_MOUSE_MOVE
:
case
TOP_MOUSE_UP
:
case
TOP_MOUSE_OUT
:
case
TOP_MOUSE_OVER
:
case
TOP_CONTEXT_MENU
:
EventConstructor
=
SyntheticMouseEvent
;
break
;
case
TOP_DRAG
:
case
TOP_DRAG_END
:
case
TOP_DRAG_ENTER
:
case
TOP_DRAG_EXIT
:
case
TOP_DRAG_LEAVE
:
case
TOP_DRAG_OVER
:
case
TOP_DRAG_START
:
case
TOP_DROP
:
EventConstructor
=
SyntheticDragEvent
;
break
;
case
TOP_TOUCH_CANCEL
:
case
TOP_TOUCH_END
:
case
TOP_TOUCH_MOVE
:
case
TOP_TOUCH_START
:
EventConstructor
=
SyntheticTouchEvent
;
break
;
case
TOP_ANIMATION_END
:
case
TOP_ANIMATION_ITERATION
:
case
TOP_ANIMATION_START
:
EventConstructor
=
SyntheticAnimationEvent
;
break
;
case
TOP_TRANSITION_END
:
EventConstructor
=
SyntheticTransitionEvent
;
break
;
case
TOP_SCROLL
:
EventConstructor
=
SyntheticUIEvent
;
break
;
case
TOP_WHEEL
:
EventConstructor
=
SyntheticWheelEvent
;
break
;
case
TOP_COPY
:
case
TOP_CUT
:
case
TOP_PASTE
:
EventConstructor
=
SyntheticClipboardEvent
;
break
;
case
TOP_GOT_POINTER_CAPTURE
:
case
TOP_LOST_POINTER_CAPTURE
:
case
TOP_POINTER_CANCEL
:
case
TOP_POINTER_DOWN
:
case
TOP_POINTER_MOVE
:
case
TOP_POINTER_OUT
:
case
TOP_POINTER_OVER
:
case
TOP_POINTER_UP
:
EventConstructor
=
SyntheticPointerEvent
;
break
;
default
:
{
if
(
knownHTMLTopLevelTypes
.
indexOf
(
topLevelType
)
=
=
=
-
1
)
{
warningWithoutStack
1
(
false
'
SimpleEventPlugin
:
Unhandled
event
type
%
s
.
This
warning
'
+
'
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
'
topLevelType
)
;
}
}
EventConstructor
=
SyntheticEvent
;
break
;
}
var
event
=
EventConstructor
.
getPooled
(
dispatchConfig
targetInst
nativeEvent
nativeEventTarget
)
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
}
;
var
passiveBrowserEventsSupported
=
false
;
if
(
enableFlareAPI
&
&
canUseDOM
)
{
try
{
var
options
=
{
}
;
Object
.
defineProperty
(
options
'
passive
'
{
get
:
function
(
)
{
passiveBrowserEventsSupported
=
true
;
}
}
)
;
window
.
addEventListener
(
'
test
'
options
options
)
;
window
.
removeEventListener
(
'
test
'
options
options
)
;
}
catch
(
e
)
{
passiveBrowserEventsSupported
=
false
;
}
}
var
UserBlockingPriority
1
=
unstable_UserBlockingPriority
;
var
runWithPriority
1
=
unstable_runWithPriority
;
var
getEventPriority
=
SimpleEventPlugin
.
getEventPriority
;
var
CALLBACK_BOOKKEEPING_POOL_SIZE
=
10
;
var
callbackBookkeepingPool
=
[
]
;
function
findRootContainerNode
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostRoot
)
{
return
inst
.
stateNode
.
containerInfo
;
}
while
(
inst
.
return
)
{
inst
=
inst
.
return
;
}
if
(
inst
.
tag
!
=
=
HostRoot
)
{
return
null
;
}
return
inst
.
stateNode
.
containerInfo
;
}
function
getTopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
targetInst
eventSystemFlags
)
{
if
(
callbackBookkeepingPool
.
length
)
{
var
instance
=
callbackBookkeepingPool
.
pop
(
)
;
instance
.
topLevelType
=
topLevelType
;
instance
.
eventSystemFlags
=
eventSystemFlags
;
instance
.
nativeEvent
=
nativeEvent
;
instance
.
targetInst
=
targetInst
;
return
instance
;
}
return
{
topLevelType
:
topLevelType
eventSystemFlags
:
eventSystemFlags
nativeEvent
:
nativeEvent
targetInst
:
targetInst
ancestors
:
[
]
}
;
}
function
releaseTopLevelCallbackBookKeeping
(
instance
)
{
instance
.
topLevelType
=
null
;
instance
.
nativeEvent
=
null
;
instance
.
targetInst
=
null
;
instance
.
ancestors
.
length
=
0
;
if
(
callbackBookkeepingPool
.
length
<
CALLBACK_BOOKKEEPING_POOL_SIZE
)
{
callbackBookkeepingPool
.
push
(
instance
)
;
}
}
function
handleTopLevel
(
bookKeeping
)
{
var
targetInst
=
bookKeeping
.
targetInst
;
var
ancestor
=
targetInst
;
do
{
if
(
!
ancestor
)
{
var
ancestors
=
bookKeeping
.
ancestors
;
ancestors
.
push
(
ancestor
)
;
break
;
}
var
root
=
findRootContainerNode
(
ancestor
)
;
if
(
!
root
)
{
break
;
}
var
tag
=
ancestor
.
tag
;
if
(
tag
=
=
=
HostComponent
|
|
tag
=
=
=
HostText
)
{
bookKeeping
.
ancestors
.
push
(
ancestor
)
;
}
ancestor
=
getClosestInstanceFromNode
(
root
)
;
}
while
(
ancestor
)
;
for
(
var
i
=
0
;
i
<
bookKeeping
.
ancestors
.
length
;
i
+
+
)
{
targetInst
=
bookKeeping
.
ancestors
[
i
]
;
var
eventTarget
=
getEventTarget
(
bookKeeping
.
nativeEvent
)
;
var
topLevelType
=
bookKeeping
.
topLevelType
;
var
nativeEvent
=
bookKeeping
.
nativeEvent
;
runExtractedPluginEventsInBatch
(
topLevelType
targetInst
nativeEvent
eventTarget
bookKeeping
.
eventSystemFlags
)
;
}
}
var
_enabled
=
true
;
function
setEnabled
(
enabled
)
{
_enabled
=
!
!
enabled
;
}
function
isEnabled
(
)
{
return
_enabled
;
}
function
trapBubbledEvent
(
topLevelType
element
)
{
trapEventForPluginEventSystem
(
element
topLevelType
false
)
;
}
function
trapCapturedEvent
(
topLevelType
element
)
{
trapEventForPluginEventSystem
(
element
topLevelType
true
)
;
}
function
trapEventForResponderEventSystem
(
element
topLevelType
passive
)
{
if
(
enableFlareAPI
)
{
var
rawEventName
=
getRawEventName
(
topLevelType
)
;
var
eventFlags
=
RESPONDER_EVENT_SYSTEM
;
if
(
passive
)
{
if
(
passiveBrowserEventsSupported
)
{
eventFlags
|
=
IS_PASSIVE
;
}
else
{
eventFlags
|
=
IS_ACTIVE
;
eventFlags
|
=
PASSIVE_NOT_SUPPORTED
;
passive
=
false
;
}
}
else
{
eventFlags
|
=
IS_ACTIVE
;
}
var
listener
=
dispatchEvent
.
bind
(
null
topLevelType
eventFlags
)
;
if
(
passiveBrowserEventsSupported
)
{
addEventCaptureListenerWithPassiveFlag
(
element
rawEventName
listener
passive
)
;
}
else
{
addEventCaptureListener
(
element
rawEventName
listener
)
;
}
}
}
function
trapEventForPluginEventSystem
(
element
topLevelType
capture
)
{
var
listener
;
switch
(
getEventPriority
(
topLevelType
)
)
{
case
DiscreteEvent
:
listener
=
dispatchDiscreteEvent
.
bind
(
null
topLevelType
PLUGIN_EVENT_SYSTEM
)
;
break
;
case
UserBlockingEvent
:
listener
=
dispatchUserBlockingUpdate
.
bind
(
null
topLevelType
PLUGIN_EVENT_SYSTEM
)
;
break
;
case
ContinuousEvent
:
default
:
listener
=
dispatchEvent
.
bind
(
null
topLevelType
PLUGIN_EVENT_SYSTEM
)
;
break
;
}
var
rawEventName
=
getRawEventName
(
topLevelType
)
;
if
(
capture
)
{
addEventCaptureListener
(
element
rawEventName
listener
)
;
}
else
{
addEventBubbleListener
(
element
rawEventName
listener
)
;
}
}
function
dispatchDiscreteEvent
(
topLevelType
eventSystemFlags
nativeEvent
)
{
flushDiscreteUpdatesIfNeeded
(
nativeEvent
.
timeStamp
)
;
discreteUpdates
(
dispatchEvent
topLevelType
eventSystemFlags
nativeEvent
)
;
}
function
dispatchUserBlockingUpdate
(
topLevelType
eventSystemFlags
nativeEvent
)
{
runWithPriority
1
(
UserBlockingPriority
1
dispatchEvent
.
bind
(
null
topLevelType
eventSystemFlags
nativeEvent
)
)
;
}
function
dispatchEventForPluginEventSystem
(
topLevelType
eventSystemFlags
nativeEvent
targetInst
)
{
var
bookKeeping
=
getTopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
targetInst
eventSystemFlags
)
;
try
{
batchedEventUpdates
(
handleTopLevel
bookKeeping
)
;
}
finally
{
releaseTopLevelCallbackBookKeeping
(
bookKeeping
)
;
}
}
function
dispatchEvent
(
topLevelType
eventSystemFlags
nativeEvent
)
{
if
(
!
_enabled
)
{
return
;
}
if
(
hasQueuedDiscreteEvents
(
)
&
&
isReplayableDiscreteEvent
(
topLevelType
)
)
{
queueDiscreteEvent
(
null
topLevelType
eventSystemFlags
nativeEvent
)
;
return
;
}
var
blockedOn
=
attemptToDispatchEvent
(
topLevelType
eventSystemFlags
nativeEvent
)
;
if
(
blockedOn
=
=
=
null
)
{
clearIfContinuousEvent
(
topLevelType
nativeEvent
)
;
return
;
}
if
(
isReplayableDiscreteEvent
(
topLevelType
)
)
{
queueDiscreteEvent
(
blockedOn
topLevelType
eventSystemFlags
nativeEvent
)
;
return
;
}
if
(
queueIfContinuousEvent
(
blockedOn
topLevelType
eventSystemFlags
nativeEvent
)
)
{
return
;
}
clearIfContinuousEvent
(
topLevelType
nativeEvent
)
;
if
(
enableFlareAPI
)
{
if
(
eventSystemFlags
&
PLUGIN_EVENT_SYSTEM
)
{
dispatchEventForPluginEventSystem
(
topLevelType
eventSystemFlags
nativeEvent
null
)
;
}
if
(
eventSystemFlags
&
RESPONDER_EVENT_SYSTEM
)
{
dispatchEventForResponderEventSystem
(
topLevelType
null
nativeEvent
getEventTarget
(
nativeEvent
)
eventSystemFlags
)
;
}
}
else
{
dispatchEventForPluginEventSystem
(
topLevelType
eventSystemFlags
nativeEvent
null
)
;
}
}
function
attemptToDispatchEvent
(
topLevelType
eventSystemFlags
nativeEvent
)
{
var
nativeEventTarget
=
getEventTarget
(
nativeEvent
)
;
var
targetInst
=
getClosestInstanceFromNode
(
nativeEventTarget
)
;
if
(
targetInst
!
=
=
null
)
{
var
nearestMounted
=
getNearestMountedFiber
(
targetInst
)
;
if
(
nearestMounted
=
=
=
null
)
{
targetInst
=
null
;
}
else
{
var
tag
=
nearestMounted
.
tag
;
if
(
tag
=
=
=
SuspenseComponent
)
{
var
instance
=
getSuspenseInstanceFromFiber
(
nearestMounted
)
;
if
(
instance
!
=
=
null
)
{
return
instance
;
}
targetInst
=
null
;
}
else
if
(
tag
=
=
=
HostRoot
)
{
var
root
=
nearestMounted
.
stateNode
;
if
(
root
.
hydrate
)
{
return
getContainerFromFiber
(
nearestMounted
)
;
}
targetInst
=
null
;
}
else
if
(
nearestMounted
!
=
=
targetInst
)
{
targetInst
=
null
;
}
}
}
if
(
enableFlareAPI
)
{
if
(
eventSystemFlags
&
PLUGIN_EVENT_SYSTEM
)
{
dispatchEventForPluginEventSystem
(
topLevelType
eventSystemFlags
nativeEvent
targetInst
)
;
}
if
(
eventSystemFlags
&
RESPONDER_EVENT_SYSTEM
)
{
dispatchEventForResponderEventSystem
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
;
}
}
else
{
dispatchEventForPluginEventSystem
(
topLevelType
eventSystemFlags
nativeEvent
targetInst
)
;
}
return
null
;
}
function
isEventSupported
(
eventNameSuffix
)
{
if
(
!
canUseDOM
)
{
return
false
;
}
var
eventName
=
'
on
'
+
eventNameSuffix
;
var
isSupported
=
eventName
in
document
;
if
(
!
isSupported
)
{
var
element
=
document
.
createElement
(
'
div
'
)
;
element
.
setAttribute
(
eventName
'
return
;
'
)
;
isSupported
=
typeof
element
[
eventName
]
=
=
=
'
function
'
;
}
return
isSupported
;
}
var
PossiblyWeakMap
=
typeof
WeakMap
=
=
=
'
function
'
?
WeakMap
:
Map
;
var
elementListeningSets
=
new
PossiblyWeakMap
(
)
;
function
getListeningSetForElement
(
element
)
{
var
listeningSet
=
elementListeningSets
.
get
(
element
)
;
if
(
listeningSet
=
=
=
undefined
)
{
listeningSet
=
new
Set
(
)
;
elementListeningSets
.
set
(
element
listeningSet
)
;
}
return
listeningSet
;
}
function
listenTo
(
registrationName
mountAt
)
{
var
listeningSet
=
getListeningSetForElement
(
mountAt
)
;
var
dependencies
=
registrationNameDependencies
[
registrationName
]
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
listenToTopLevel
(
dependency
mountAt
listeningSet
)
;
}
}
function
listenToTopLevel
(
topLevelType
mountAt
listeningSet
)
{
if
(
!
listeningSet
.
has
(
topLevelType
)
)
{
switch
(
topLevelType
)
{
case
TOP_SCROLL
:
trapCapturedEvent
(
TOP_SCROLL
mountAt
)
;
break
;
case
TOP_FOCUS
:
case
TOP_BLUR
:
trapCapturedEvent
(
TOP_FOCUS
mountAt
)
;
trapCapturedEvent
(
TOP_BLUR
mountAt
)
;
listeningSet
.
add
(
TOP_BLUR
)
;
listeningSet
.
add
(
TOP_FOCUS
)
;
break
;
case
TOP_CANCEL
:
case
TOP_CLOSE
:
if
(
isEventSupported
(
getRawEventName
(
topLevelType
)
)
)
{
trapCapturedEvent
(
topLevelType
mountAt
)
;
}
break
;
case
TOP_INVALID
:
case
TOP_SUBMIT
:
case
TOP_RESET
:
break
;
default
:
var
isMediaEvent
=
mediaEventTypes
.
indexOf
(
topLevelType
)
!
=
=
-
1
;
if
(
!
isMediaEvent
)
{
trapBubbledEvent
(
topLevelType
mountAt
)
;
}
break
;
}
listeningSet
.
add
(
topLevelType
)
;
}
}
function
isListeningToAllDependencies
(
registrationName
mountAt
)
{
var
listeningSet
=
getListeningSetForElement
(
mountAt
)
;
var
dependencies
=
registrationNameDependencies
[
registrationName
]
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
if
(
!
listeningSet
.
has
(
dependency
)
)
{
return
false
;
}
}
return
true
;
}
var
shorthandToLonghand
=
{
animation
:
[
'
animationDelay
'
'
animationDirection
'
'
animationDuration
'
'
animationFillMode
'
'
animationIterationCount
'
'
animationName
'
'
animationPlayState
'
'
animationTimingFunction
'
]
background
:
[
'
backgroundAttachment
'
'
backgroundClip
'
'
backgroundColor
'
'
backgroundImage
'
'
backgroundOrigin
'
'
backgroundPositionX
'
'
backgroundPositionY
'
'
backgroundRepeat
'
'
backgroundSize
'
]
backgroundPosition
:
[
'
backgroundPositionX
'
'
backgroundPositionY
'
]
border
:
[
'
borderBottomColor
'
'
borderBottomStyle
'
'
borderBottomWidth
'
'
borderImageOutset
'
'
borderImageRepeat
'
'
borderImageSlice
'
'
borderImageSource
'
'
borderImageWidth
'
'
borderLeftColor
'
'
borderLeftStyle
'
'
borderLeftWidth
'
'
borderRightColor
'
'
borderRightStyle
'
'
borderRightWidth
'
'
borderTopColor
'
'
borderTopStyle
'
'
borderTopWidth
'
]
borderBlockEnd
:
[
'
borderBlockEndColor
'
'
borderBlockEndStyle
'
'
borderBlockEndWidth
'
]
borderBlockStart
:
[
'
borderBlockStartColor
'
'
borderBlockStartStyle
'
'
borderBlockStartWidth
'
]
borderBottom
:
[
'
borderBottomColor
'
'
borderBottomStyle
'
'
borderBottomWidth
'
]
borderColor
:
[
'
borderBottomColor
'
'
borderLeftColor
'
'
borderRightColor
'
'
borderTopColor
'
]
borderImage
:
[
'
borderImageOutset
'
'
borderImageRepeat
'
'
borderImageSlice
'
'
borderImageSource
'
'
borderImageWidth
'
]
borderInlineEnd
:
[
'
borderInlineEndColor
'
'
borderInlineEndStyle
'
'
borderInlineEndWidth
'
]
borderInlineStart
:
[
'
borderInlineStartColor
'
'
borderInlineStartStyle
'
'
borderInlineStartWidth
'
]
borderLeft
:
[
'
borderLeftColor
'
'
borderLeftStyle
'
'
borderLeftWidth
'
]
borderRadius
:
[
'
borderBottomLeftRadius
'
'
borderBottomRightRadius
'
'
borderTopLeftRadius
'
'
borderTopRightRadius
'
]
borderRight
:
[
'
borderRightColor
'
'
borderRightStyle
'
'
borderRightWidth
'
]
borderStyle
:
[
'
borderBottomStyle
'
'
borderLeftStyle
'
'
borderRightStyle
'
'
borderTopStyle
'
]
borderTop
:
[
'
borderTopColor
'
'
borderTopStyle
'
'
borderTopWidth
'
]
borderWidth
:
[
'
borderBottomWidth
'
'
borderLeftWidth
'
'
borderRightWidth
'
'
borderTopWidth
'
]
columnRule
:
[
'
columnRuleColor
'
'
columnRuleStyle
'
'
columnRuleWidth
'
]
columns
:
[
'
columnCount
'
'
columnWidth
'
]
flex
:
[
'
flexBasis
'
'
flexGrow
'
'
flexShrink
'
]
flexFlow
:
[
'
flexDirection
'
'
flexWrap
'
]
font
:
[
'
fontFamily
'
'
fontFeatureSettings
'
'
fontKerning
'
'
fontLanguageOverride
'
'
fontSize
'
'
fontSizeAdjust
'
'
fontStretch
'
'
fontStyle
'
'
fontVariant
'
'
fontVariantAlternates
'
'
fontVariantCaps
'
'
fontVariantEastAsian
'
'
fontVariantLigatures
'
'
fontVariantNumeric
'
'
fontVariantPosition
'
'
fontWeight
'
'
lineHeight
'
]
fontVariant
:
[
'
fontVariantAlternates
'
'
fontVariantCaps
'
'
fontVariantEastAsian
'
'
fontVariantLigatures
'
'
fontVariantNumeric
'
'
fontVariantPosition
'
]
gap
:
[
'
columnGap
'
'
rowGap
'
]
grid
:
[
'
gridAutoColumns
'
'
gridAutoFlow
'
'
gridAutoRows
'
'
gridTemplateAreas
'
'
gridTemplateColumns
'
'
gridTemplateRows
'
]
gridArea
:
[
'
gridColumnEnd
'
'
gridColumnStart
'
'
gridRowEnd
'
'
gridRowStart
'
]
gridColumn
:
[
'
gridColumnEnd
'
'
gridColumnStart
'
]
gridColumnGap
:
[
'
columnGap
'
]
gridGap
:
[
'
columnGap
'
'
rowGap
'
]
gridRow
:
[
'
gridRowEnd
'
'
gridRowStart
'
]
gridRowGap
:
[
'
rowGap
'
]
gridTemplate
:
[
'
gridTemplateAreas
'
'
gridTemplateColumns
'
'
gridTemplateRows
'
]
listStyle
:
[
'
listStyleImage
'
'
listStylePosition
'
'
listStyleType
'
]
margin
:
[
'
marginBottom
'
'
marginLeft
'
'
marginRight
'
'
marginTop
'
]
marker
:
[
'
markerEnd
'
'
markerMid
'
'
markerStart
'
]
mask
:
[
'
maskClip
'
'
maskComposite
'
'
maskImage
'
'
maskMode
'
'
maskOrigin
'
'
maskPositionX
'
'
maskPositionY
'
'
maskRepeat
'
'
maskSize
'
]
maskPosition
:
[
'
maskPositionX
'
'
maskPositionY
'
]
outline
:
[
'
outlineColor
'
'
outlineStyle
'
'
outlineWidth
'
]
overflow
:
[
'
overflowX
'
'
overflowY
'
]
padding
:
[
'
paddingBottom
'
'
paddingLeft
'
'
paddingRight
'
'
paddingTop
'
]
placeContent
:
[
'
alignContent
'
'
justifyContent
'
]
placeItems
:
[
'
alignItems
'
'
justifyItems
'
]
placeSelf
:
[
'
alignSelf
'
'
justifySelf
'
]
textDecoration
:
[
'
textDecorationColor
'
'
textDecorationLine
'
'
textDecorationStyle
'
]
textEmphasis
:
[
'
textEmphasisColor
'
'
textEmphasisStyle
'
]
transition
:
[
'
transitionDelay
'
'
transitionDuration
'
'
transitionProperty
'
'
transitionTimingFunction
'
]
wordWrap
:
[
'
overflowWrap
'
]
}
;
var
isUnitlessNumber
=
{
animationIterationCount
:
true
borderImageOutset
:
true
borderImageSlice
:
true
borderImageWidth
:
true
boxFlex
:
true
boxFlexGroup
:
true
boxOrdinalGroup
:
true
columnCount
:
true
columns
:
true
flex
:
true
flexGrow
:
true
flexPositive
:
true
flexShrink
:
true
flexNegative
:
true
flexOrder
:
true
gridArea
:
true
gridRow
:
true
gridRowEnd
:
true
gridRowSpan
:
true
gridRowStart
:
true
gridColumn
:
true
gridColumnEnd
:
true
gridColumnSpan
:
true
gridColumnStart
:
true
fontWeight
:
true
lineClamp
:
true
lineHeight
:
true
opacity
:
true
order
:
true
orphans
:
true
tabSize
:
true
widows
:
true
zIndex
:
true
zoom
:
true
fillOpacity
:
true
floodOpacity
:
true
stopOpacity
:
true
strokeDasharray
:
true
strokeDashoffset
:
true
strokeMiterlimit
:
true
strokeOpacity
:
true
strokeWidth
:
true
}
;
function
prefixKey
(
prefix
key
)
{
return
prefix
+
key
.
charAt
(
0
)
.
toUpperCase
(
)
+
key
.
substring
(
1
)
;
}
var
prefixes
=
[
'
Webkit
'
'
ms
'
'
Moz
'
'
O
'
]
;
Object
.
keys
(
isUnitlessNumber
)
.
forEach
(
function
(
prop
)
{
prefixes
.
forEach
(
function
(
prefix
)
{
isUnitlessNumber
[
prefixKey
(
prefix
prop
)
]
=
isUnitlessNumber
[
prop
]
;
}
)
;
}
)
;
function
dangerousStyleValue
(
name
value
isCustomProperty
)
{
var
isEmpty
=
value
=
=
null
|
|
typeof
value
=
=
=
'
boolean
'
|
|
value
=
=
=
'
'
;
if
(
isEmpty
)
{
return
'
'
;
}
if
(
!
isCustomProperty
&
&
typeof
value
=
=
=
'
number
'
&
&
value
!
=
=
0
&
&
!
(
isUnitlessNumber
.
hasOwnProperty
(
name
)
&
&
isUnitlessNumber
[
name
]
)
)
{
return
value
+
'
px
'
;
}
return
(
'
'
+
value
)
.
trim
(
)
;
}
var
uppercasePattern
=
/
(
[
A
-
Z
]
)
/
g
;
var
msPattern
=
/
^
ms
-
/
;
function
hyphenateStyleName
(
name
)
{
return
name
.
replace
(
uppercasePattern
'
-
1
'
)
.
toLowerCase
(
)
.
replace
(
msPattern
'
-
ms
-
'
)
;
}
var
warnValidStyle
=
function
(
)
{
}
;
{
var
badVendoredStyleNamePattern
=
/
^
(
?
:
webkit
|
moz
|
o
)
[
A
-
Z
]
/
;
var
msPattern
1
=
/
^
-
ms
-
/
;
var
hyphenPattern
=
/
-
(
.
)
/
g
;
var
badStyleValueWithSemicolonPattern
=
/
;
\
s
*
/
;
var
warnedStyleNames
=
{
}
;
var
warnedStyleValues
=
{
}
;
var
warnedForNaNValue
=
false
;
var
warnedForInfinityValue
=
false
;
var
camelize
=
function
(
string
)
{
return
string
.
replace
(
hyphenPattern
function
(
_
character
)
{
return
character
.
toUpperCase
(
)
;
}
)
;
}
;
var
warnHyphenatedStyleName
=
function
(
name
)
{
if
(
warnedStyleNames
.
hasOwnProperty
(
name
)
&
&
warnedStyleNames
[
name
]
)
{
return
;
}
warnedStyleNames
[
name
]
=
true
;
warning
1
(
false
'
Unsupported
style
property
%
s
.
Did
you
mean
%
s
?
'
name
camelize
(
name
.
replace
(
msPattern
1
'
ms
-
'
)
)
)
;
}
;
var
warnBadVendoredStyleName
=
function
(
name
)
{
if
(
warnedStyleNames
.
hasOwnProperty
(
name
)
&
&
warnedStyleNames
[
name
]
)
{
return
;
}
warnedStyleNames
[
name
]
=
true
;
warning
1
(
false
'
Unsupported
vendor
-
prefixed
style
property
%
s
.
Did
you
mean
%
s
?
'
name
name
.
charAt
(
0
)
.
toUpperCase
(
)
+
name
.
slice
(
1
)
)
;
}
;
var
warnStyleValueWithSemicolon
=
function
(
name
value
)
{
if
(
warnedStyleValues
.
hasOwnProperty
(
value
)
&
&
warnedStyleValues
[
value
]
)
{
return
;
}
warnedStyleValues
[
value
]
=
true
;
warning
1
(
false
"
Style
property
values
shouldn
'
t
contain
a
semicolon
.
"
+
'
Try
"
%
s
:
%
s
"
instead
.
'
name
value
.
replace
(
badStyleValueWithSemicolonPattern
'
'
)
)
;
}
;
var
warnStyleValueIsNaN
=
function
(
name
value
)
{
if
(
warnedForNaNValue
)
{
return
;
}
warnedForNaNValue
=
true
;
warning
1
(
false
'
NaN
is
an
invalid
value
for
the
%
s
css
style
property
.
'
name
)
;
}
;
var
warnStyleValueIsInfinity
=
function
(
name
value
)
{
if
(
warnedForInfinityValue
)
{
return
;
}
warnedForInfinityValue
=
true
;
warning
1
(
false
'
Infinity
is
an
invalid
value
for
the
%
s
css
style
property
.
'
name
)
;
}
;
warnValidStyle
=
function
(
name
value
)
{
if
(
name
.
indexOf
(
'
-
'
)
>
-
1
)
{
warnHyphenatedStyleName
(
name
)
;
}
else
if
(
badVendoredStyleNamePattern
.
test
(
name
)
)
{
warnBadVendoredStyleName
(
name
)
;
}
else
if
(
badStyleValueWithSemicolonPattern
.
test
(
value
)
)
{
warnStyleValueWithSemicolon
(
name
value
)
;
}
if
(
typeof
value
=
=
=
'
number
'
)
{
if
(
isNaN
(
value
)
)
{
warnStyleValueIsNaN
(
name
value
)
;
}
else
if
(
!
isFinite
(
value
)
)
{
warnStyleValueIsInfinity
(
name
value
)
;
}
}
}
;
}
var
warnValidStyle
1
=
warnValidStyle
;
function
createDangerousStringForStyles
(
styles
)
{
{
var
serialized
=
'
'
;
var
delimiter
=
'
'
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
var
styleValue
=
styles
[
styleName
]
;
if
(
styleValue
!
=
null
)
{
var
isCustomProperty
=
styleName
.
indexOf
(
'
-
-
'
)
=
=
=
0
;
serialized
+
=
delimiter
+
(
isCustomProperty
?
styleName
:
hyphenateStyleName
(
styleName
)
)
+
'
:
'
;
serialized
+
=
dangerousStyleValue
(
styleName
styleValue
isCustomProperty
)
;
delimiter
=
'
;
'
;
}
}
return
serialized
|
|
null
;
}
}
function
setValueForStyles
(
node
styles
)
{
var
style
=
node
.
style
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
var
isCustomProperty
=
styleName
.
indexOf
(
'
-
-
'
)
=
=
=
0
;
{
if
(
!
isCustomProperty
)
{
warnValidStyle
1
(
styleName
styles
[
styleName
]
)
;
}
}
var
styleValue
=
dangerousStyleValue
(
styleName
styles
[
styleName
]
isCustomProperty
)
;
if
(
styleName
=
=
=
'
float
'
)
{
styleName
=
'
cssFloat
'
;
}
if
(
isCustomProperty
)
{
style
.
setProperty
(
styleName
styleValue
)
;
}
else
{
style
[
styleName
]
=
styleValue
;
}
}
}
function
isValueEmpty
(
value
)
{
return
value
=
=
null
|
|
typeof
value
=
=
=
'
boolean
'
|
|
value
=
=
=
'
'
;
}
function
expandShorthandMap
(
styles
)
{
var
expanded
=
{
}
;
for
(
var
key
in
styles
)
{
var
longhands
=
shorthandToLonghand
[
key
]
|
|
[
key
]
;
for
(
var
i
=
0
;
i
<
longhands
.
length
;
i
+
+
)
{
expanded
[
longhands
[
i
]
]
=
key
;
}
}
return
expanded
;
}
function
validateShorthandPropertyCollisionInDev
(
styleUpdates
nextStyles
)
{
if
(
!
warnAboutShorthandPropertyCollision
)
{
return
;
}
if
(
!
nextStyles
)
{
return
;
}
var
expandedUpdates
=
expandShorthandMap
(
styleUpdates
)
;
var
expandedStyles
=
expandShorthandMap
(
nextStyles
)
;
var
warnedAbout
=
{
}
;
for
(
var
key
in
expandedUpdates
)
{
var
originalKey
=
expandedUpdates
[
key
]
;
var
correctOriginalKey
=
expandedStyles
[
key
]
;
if
(
correctOriginalKey
&
&
originalKey
!
=
=
correctOriginalKey
)
{
var
warningKey
=
originalKey
+
'
'
+
correctOriginalKey
;
if
(
warnedAbout
[
warningKey
]
)
{
continue
;
}
warnedAbout
[
warningKey
]
=
true
;
warning
1
(
false
'
%
s
a
style
property
during
rerender
(
%
s
)
when
a
'
+
'
conflicting
property
is
set
(
%
s
)
can
lead
to
styling
bugs
.
To
'
+
"
avoid
this
don
'
t
mix
shorthand
and
non
-
shorthand
properties
"
+
'
for
the
same
value
;
instead
replace
the
shorthand
with
'
+
'
separate
values
.
'
isValueEmpty
(
styleUpdates
[
originalKey
]
)
?
'
Removing
'
:
'
Updating
'
originalKey
correctOriginalKey
)
;
}
}
}
var
omittedCloseTags
=
{
area
:
true
base
:
true
br
:
true
col
:
true
embed
:
true
hr
:
true
img
:
true
input
:
true
keygen
:
true
link
:
true
meta
:
true
param
:
true
source
:
true
track
:
true
wbr
:
true
}
;
var
voidElementTags
=
_assign
(
{
menuitem
:
true
}
omittedCloseTags
)
;
var
HTML
1
=
'
__html
'
;
var
ReactDebugCurrentFrame
3
=
null
;
{
ReactDebugCurrentFrame
3
=
ReactSharedInternals
.
ReactDebugCurrentFrame
;
}
function
assertValidProps
(
tag
props
)
{
if
(
!
props
)
{
return
;
}
if
(
voidElementTags
[
tag
]
)
{
if
(
!
(
props
.
children
=
=
null
&
&
props
.
dangerouslySetInnerHTML
=
=
null
)
)
{
{
throw
Error
(
tag
+
"
is
a
void
element
tag
and
must
neither
have
children
nor
use
dangerouslySetInnerHTML
.
"
+
(
ReactDebugCurrentFrame
3
.
getStackAddendum
(
)
)
)
;
}
}
}
if
(
props
.
dangerouslySetInnerHTML
!
=
null
)
{
if
(
!
(
props
.
children
=
=
null
)
)
{
{
throw
Error
(
"
Can
only
set
one
of
children
or
props
.
dangerouslySetInnerHTML
.
"
)
;
}
}
if
(
!
(
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
HTML
1
in
props
.
dangerouslySetInnerHTML
)
)
{
{
throw
Error
(
"
props
.
dangerouslySetInnerHTML
must
be
in
the
form
{
__html
:
.
.
.
}
.
Please
visit
https
:
/
/
fb
.
me
/
react
-
invariant
-
dangerously
-
set
-
inner
-
html
for
more
information
.
"
)
;
}
}
}
{
!
(
props
.
suppressContentEditableWarning
|
|
!
props
.
contentEditable
|
|
props
.
children
=
=
null
)
?
warning
1
(
false
'
A
component
is
contentEditable
and
contains
children
managed
by
'
+
'
React
.
It
is
now
your
responsibility
to
guarantee
that
none
of
'
+
'
those
nodes
are
unexpectedly
modified
or
duplicated
.
This
is
'
+
'
probably
not
intentional
.
'
)
:
void
0
;
}
if
(
!
(
props
.
style
=
=
null
|
|
typeof
props
.
style
=
=
=
'
object
'
)
)
{
{
throw
Error
(
"
The
style
prop
expects
a
mapping
from
style
properties
to
values
not
a
string
.
For
example
style
=
{
{
marginRight
:
spacing
+
'
em
'
}
}
when
using
JSX
.
"
+
(
ReactDebugCurrentFrame
3
.
getStackAddendum
(
)
)
)
;
}
}
}
function
isCustomComponent
(
tagName
props
)
{
if
(
tagName
.
indexOf
(
'
-
'
)
=
=
=
-
1
)
{
return
typeof
props
.
is
=
=
=
'
string
'
;
}
switch
(
tagName
)
{
case
'
annotation
-
xml
'
:
case
'
color
-
profile
'
:
case
'
font
-
face
'
:
case
'
font
-
face
-
src
'
:
case
'
font
-
face
-
uri
'
:
case
'
font
-
face
-
format
'
:
case
'
font
-
face
-
name
'
:
case
'
missing
-
glyph
'
:
return
false
;
default
:
return
true
;
}
}
var
possibleStandardNames
=
{
accept
:
'
accept
'
acceptcharset
:
'
acceptCharset
'
'
accept
-
charset
'
:
'
acceptCharset
'
accesskey
:
'
accessKey
'
action
:
'
action
'
allowfullscreen
:
'
allowFullScreen
'
alt
:
'
alt
'
as
:
'
as
'
async
:
'
async
'
autocapitalize
:
'
autoCapitalize
'
autocomplete
:
'
autoComplete
'
autocorrect
:
'
autoCorrect
'
autofocus
:
'
autoFocus
'
autoplay
:
'
autoPlay
'
autosave
:
'
autoSave
'
capture
:
'
capture
'
cellpadding
:
'
cellPadding
'
cellspacing
:
'
cellSpacing
'
challenge
:
'
challenge
'
charset
:
'
charSet
'
checked
:
'
checked
'
children
:
'
children
'
cite
:
'
cite
'
class
:
'
className
'
classid
:
'
classID
'
classname
:
'
className
'
cols
:
'
cols
'
colspan
:
'
colSpan
'
content
:
'
content
'
contenteditable
:
'
contentEditable
'
contextmenu
:
'
contextMenu
'
controls
:
'
controls
'
controlslist
:
'
controlsList
'
coords
:
'
coords
'
crossorigin
:
'
crossOrigin
'
dangerouslysetinnerhtml
:
'
dangerouslySetInnerHTML
'
data
:
'
data
'
datetime
:
'
dateTime
'
default
:
'
default
'
defaultchecked
:
'
defaultChecked
'
defaultvalue
:
'
defaultValue
'
defer
:
'
defer
'
dir
:
'
dir
'
disabled
:
'
disabled
'
disablepictureinpicture
:
'
disablePictureInPicture
'
download
:
'
download
'
draggable
:
'
draggable
'
enctype
:
'
encType
'
for
:
'
htmlFor
'
form
:
'
form
'
formmethod
:
'
formMethod
'
formaction
:
'
formAction
'
formenctype
:
'
formEncType
'
formnovalidate
:
'
formNoValidate
'
formtarget
:
'
formTarget
'
frameborder
:
'
frameBorder
'
headers
:
'
headers
'
height
:
'
height
'
hidden
:
'
hidden
'
high
:
'
high
'
href
:
'
href
'
hreflang
:
'
hrefLang
'
htmlfor
:
'
htmlFor
'
httpequiv
:
'
httpEquiv
'
'
http
-
equiv
'
:
'
httpEquiv
'
icon
:
'
icon
'
id
:
'
id
'
innerhtml
:
'
innerHTML
'
inputmode
:
'
inputMode
'
integrity
:
'
integrity
'
is
:
'
is
'
itemid
:
'
itemID
'
itemprop
:
'
itemProp
'
itemref
:
'
itemRef
'
itemscope
:
'
itemScope
'
itemtype
:
'
itemType
'
keyparams
:
'
keyParams
'
keytype
:
'
keyType
'
kind
:
'
kind
'
label
:
'
label
'
lang
:
'
lang
'
list
:
'
list
'
loop
:
'
loop
'
low
:
'
low
'
manifest
:
'
manifest
'
marginwidth
:
'
marginWidth
'
marginheight
:
'
marginHeight
'
max
:
'
max
'
maxlength
:
'
maxLength
'
media
:
'
media
'
mediagroup
:
'
mediaGroup
'
method
:
'
method
'
min
:
'
min
'
minlength
:
'
minLength
'
multiple
:
'
multiple
'
muted
:
'
muted
'
name
:
'
name
'
nomodule
:
'
noModule
'
nonce
:
'
nonce
'
novalidate
:
'
noValidate
'
open
:
'
open
'
optimum
:
'
optimum
'
pattern
:
'
pattern
'
placeholder
:
'
placeholder
'
playsinline
:
'
playsInline
'
poster
:
'
poster
'
preload
:
'
preload
'
profile
:
'
profile
'
radiogroup
:
'
radioGroup
'
readonly
:
'
readOnly
'
referrerpolicy
:
'
referrerPolicy
'
rel
:
'
rel
'
required
:
'
required
'
reversed
:
'
reversed
'
role
:
'
role
'
rows
:
'
rows
'
rowspan
:
'
rowSpan
'
sandbox
:
'
sandbox
'
scope
:
'
scope
'
scoped
:
'
scoped
'
scrolling
:
'
scrolling
'
seamless
:
'
seamless
'
selected
:
'
selected
'
shape
:
'
shape
'
size
:
'
size
'
sizes
:
'
sizes
'
span
:
'
span
'
spellcheck
:
'
spellCheck
'
src
:
'
src
'
srcdoc
:
'
srcDoc
'
srclang
:
'
srcLang
'
srcset
:
'
srcSet
'
start
:
'
start
'
step
:
'
step
'
style
:
'
style
'
summary
:
'
summary
'
tabindex
:
'
tabIndex
'
target
:
'
target
'
title
:
'
title
'
type
:
'
type
'
usemap
:
'
useMap
'
value
:
'
value
'
width
:
'
width
'
wmode
:
'
wmode
'
wrap
:
'
wrap
'
about
:
'
about
'
accentheight
:
'
accentHeight
'
'
accent
-
height
'
:
'
accentHeight
'
accumulate
:
'
accumulate
'
additive
:
'
additive
'
alignmentbaseline
:
'
alignmentBaseline
'
'
alignment
-
baseline
'
:
'
alignmentBaseline
'
allowreorder
:
'
allowReorder
'
alphabetic
:
'
alphabetic
'
amplitude
:
'
amplitude
'
arabicform
:
'
arabicForm
'
'
arabic
-
form
'
:
'
arabicForm
'
ascent
:
'
ascent
'
attributename
:
'
attributeName
'
attributetype
:
'
attributeType
'
autoreverse
:
'
autoReverse
'
azimuth
:
'
azimuth
'
basefrequency
:
'
baseFrequency
'
baselineshift
:
'
baselineShift
'
'
baseline
-
shift
'
:
'
baselineShift
'
baseprofile
:
'
baseProfile
'
bbox
:
'
bbox
'
begin
:
'
begin
'
bias
:
'
bias
'
by
:
'
by
'
calcmode
:
'
calcMode
'
capheight
:
'
capHeight
'
'
cap
-
height
'
:
'
capHeight
'
clip
:
'
clip
'
clippath
:
'
clipPath
'
'
clip
-
path
'
:
'
clipPath
'
clippathunits
:
'
clipPathUnits
'
cliprule
:
'
clipRule
'
'
clip
-
rule
'
:
'
clipRule
'
color
:
'
color
'
colorinterpolation
:
'
colorInterpolation
'
'
color
-
interpolation
'
:
'
colorInterpolation
'
colorinterpolationfilters
:
'
colorInterpolationFilters
'
'
color
-
interpolation
-
filters
'
:
'
colorInterpolationFilters
'
colorprofile
:
'
colorProfile
'
'
color
-
profile
'
:
'
colorProfile
'
colorrendering
:
'
colorRendering
'
'
color
-
rendering
'
:
'
colorRendering
'
contentscripttype
:
'
contentScriptType
'
contentstyletype
:
'
contentStyleType
'
cursor
:
'
cursor
'
cx
:
'
cx
'
cy
:
'
cy
'
d
:
'
d
'
datatype
:
'
datatype
'
decelerate
:
'
decelerate
'
descent
:
'
descent
'
diffuseconstant
:
'
diffuseConstant
'
direction
:
'
direction
'
display
:
'
display
'
divisor
:
'
divisor
'
dominantbaseline
:
'
dominantBaseline
'
'
dominant
-
baseline
'
:
'
dominantBaseline
'
dur
:
'
dur
'
dx
:
'
dx
'
dy
:
'
dy
'
edgemode
:
'
edgeMode
'
elevation
:
'
elevation
'
enablebackground
:
'
enableBackground
'
'
enable
-
background
'
:
'
enableBackground
'
end
:
'
end
'
exponent
:
'
exponent
'
externalresourcesrequired
:
'
externalResourcesRequired
'
fill
:
'
fill
'
fillopacity
:
'
fillOpacity
'
'
fill
-
opacity
'
:
'
fillOpacity
'
fillrule
:
'
fillRule
'
'
fill
-
rule
'
:
'
fillRule
'
filter
:
'
filter
'
filterres
:
'
filterRes
'
filterunits
:
'
filterUnits
'
floodopacity
:
'
floodOpacity
'
'
flood
-
opacity
'
:
'
floodOpacity
'
floodcolor
:
'
floodColor
'
'
flood
-
color
'
:
'
floodColor
'
focusable
:
'
focusable
'
fontfamily
:
'
fontFamily
'
'
font
-
family
'
:
'
fontFamily
'
fontsize
:
'
fontSize
'
'
font
-
size
'
:
'
fontSize
'
fontsizeadjust
:
'
fontSizeAdjust
'
'
font
-
size
-
adjust
'
:
'
fontSizeAdjust
'
fontstretch
:
'
fontStretch
'
'
font
-
stretch
'
:
'
fontStretch
'
fontstyle
:
'
fontStyle
'
'
font
-
style
'
:
'
fontStyle
'
fontvariant
:
'
fontVariant
'
'
font
-
variant
'
:
'
fontVariant
'
fontweight
:
'
fontWeight
'
'
font
-
weight
'
:
'
fontWeight
'
format
:
'
format
'
from
:
'
from
'
fx
:
'
fx
'
fy
:
'
fy
'
g1
:
'
g1
'
g2
:
'
g2
'
glyphname
:
'
glyphName
'
'
glyph
-
name
'
:
'
glyphName
'
glyphorientationhorizontal
:
'
glyphOrientationHorizontal
'
'
glyph
-
orientation
-
horizontal
'
:
'
glyphOrientationHorizontal
'
glyphorientationvertical
:
'
glyphOrientationVertical
'
'
glyph
-
orientation
-
vertical
'
:
'
glyphOrientationVertical
'
glyphref
:
'
glyphRef
'
gradienttransform
:
'
gradientTransform
'
gradientunits
:
'
gradientUnits
'
hanging
:
'
hanging
'
horizadvx
:
'
horizAdvX
'
'
horiz
-
adv
-
x
'
:
'
horizAdvX
'
horizoriginx
:
'
horizOriginX
'
'
horiz
-
origin
-
x
'
:
'
horizOriginX
'
ideographic
:
'
ideographic
'
imagerendering
:
'
imageRendering
'
'
image
-
rendering
'
:
'
imageRendering
'
in2
:
'
in2
'
in
:
'
in
'
inlist
:
'
inlist
'
intercept
:
'
intercept
'
k1
:
'
k1
'
k2
:
'
k2
'
k3
:
'
k3
'
k4
:
'
k4
'
k
:
'
k
'
kernelmatrix
:
'
kernelMatrix
'
kernelunitlength
:
'
kernelUnitLength
'
kerning
:
'
kerning
'
keypoints
:
'
keyPoints
'
keysplines
:
'
keySplines
'
keytimes
:
'
keyTimes
'
lengthadjust
:
'
lengthAdjust
'
letterspacing
:
'
letterSpacing
'
'
letter
-
spacing
'
:
'
letterSpacing
'
lightingcolor
:
'
lightingColor
'
'
lighting
-
color
'
:
'
lightingColor
'
limitingconeangle
:
'
limitingConeAngle
'
local
:
'
local
'
markerend
:
'
markerEnd
'
'
marker
-
end
'
:
'
markerEnd
'
markerheight
:
'
markerHeight
'
markermid
:
'
markerMid
'
'
marker
-
mid
'
:
'
markerMid
'
markerstart
:
'
markerStart
'
'
marker
-
start
'
:
'
markerStart
'
markerunits
:
'
markerUnits
'
markerwidth
:
'
markerWidth
'
mask
:
'
mask
'
maskcontentunits
:
'
maskContentUnits
'
maskunits
:
'
maskUnits
'
mathematical
:
'
mathematical
'
mode
:
'
mode
'
numoctaves
:
'
numOctaves
'
offset
:
'
offset
'
opacity
:
'
opacity
'
operator
:
'
operator
'
order
:
'
order
'
orient
:
'
orient
'
orientation
:
'
orientation
'
origin
:
'
origin
'
overflow
:
'
overflow
'
overlineposition
:
'
overlinePosition
'
'
overline
-
position
'
:
'
overlinePosition
'
overlinethickness
:
'
overlineThickness
'
'
overline
-
thickness
'
:
'
overlineThickness
'
paintorder
:
'
paintOrder
'
'
paint
-
order
'
:
'
paintOrder
'
panose1
:
'
panose1
'
'
panose
-
1
'
:
'
panose1
'
pathlength
:
'
pathLength
'
patterncontentunits
:
'
patternContentUnits
'
patterntransform
:
'
patternTransform
'
patternunits
:
'
patternUnits
'
pointerevents
:
'
pointerEvents
'
'
pointer
-
events
'
:
'
pointerEvents
'
points
:
'
points
'
pointsatx
:
'
pointsAtX
'
pointsaty
:
'
pointsAtY
'
pointsatz
:
'
pointsAtZ
'
prefix
:
'
prefix
'
preservealpha
:
'
preserveAlpha
'
preserveaspectratio
:
'
preserveAspectRatio
'
primitiveunits
:
'
primitiveUnits
'
property
:
'
property
'
r
:
'
r
'
radius
:
'
radius
'
refx
:
'
refX
'
refy
:
'
refY
'
renderingintent
:
'
renderingIntent
'
'
rendering
-
intent
'
:
'
renderingIntent
'
repeatcount
:
'
repeatCount
'
repeatdur
:
'
repeatDur
'
requiredextensions
:
'
requiredExtensions
'
requiredfeatures
:
'
requiredFeatures
'
resource
:
'
resource
'
restart
:
'
restart
'
result
:
'
result
'
results
:
'
results
'
rotate
:
'
rotate
'
rx
:
'
rx
'
ry
:
'
ry
'
scale
:
'
scale
'
security
:
'
security
'
seed
:
'
seed
'
shaperendering
:
'
shapeRendering
'
'
shape
-
rendering
'
:
'
shapeRendering
'
slope
:
'
slope
'
spacing
:
'
spacing
'
specularconstant
:
'
specularConstant
'
specularexponent
:
'
specularExponent
'
speed
:
'
speed
'
spreadmethod
:
'
spreadMethod
'
startoffset
:
'
startOffset
'
stddeviation
:
'
stdDeviation
'
stemh
:
'
stemh
'
stemv
:
'
stemv
'
stitchtiles
:
'
stitchTiles
'
stopcolor
:
'
stopColor
'
'
stop
-
color
'
:
'
stopColor
'
stopopacity
:
'
stopOpacity
'
'
stop
-
opacity
'
:
'
stopOpacity
'
strikethroughposition
:
'
strikethroughPosition
'
'
strikethrough
-
position
'
:
'
strikethroughPosition
'
strikethroughthickness
:
'
strikethroughThickness
'
'
strikethrough
-
thickness
'
:
'
strikethroughThickness
'
string
:
'
string
'
stroke
:
'
stroke
'
strokedasharray
:
'
strokeDasharray
'
'
stroke
-
dasharray
'
:
'
strokeDasharray
'
strokedashoffset
:
'
strokeDashoffset
'
'
stroke
-
dashoffset
'
:
'
strokeDashoffset
'
strokelinecap
:
'
strokeLinecap
'
'
stroke
-
linecap
'
:
'
strokeLinecap
'
strokelinejoin
:
'
strokeLinejoin
'
'
stroke
-
linejoin
'
:
'
strokeLinejoin
'
strokemiterlimit
:
'
strokeMiterlimit
'
'
stroke
-
miterlimit
'
:
'
strokeMiterlimit
'
strokewidth
:
'
strokeWidth
'
'
stroke
-
width
'
:
'
strokeWidth
'
strokeopacity
:
'
strokeOpacity
'
'
stroke
-
opacity
'
:
'
strokeOpacity
'
suppresscontenteditablewarning
:
'
suppressContentEditableWarning
'
suppresshydrationwarning
:
'
suppressHydrationWarning
'
surfacescale
:
'
surfaceScale
'
systemlanguage
:
'
systemLanguage
'
tablevalues
:
'
tableValues
'
targetx
:
'
targetX
'
targety
:
'
targetY
'
textanchor
:
'
textAnchor
'
'
text
-
anchor
'
:
'
textAnchor
'
textdecoration
:
'
textDecoration
'
'
text
-
decoration
'
:
'
textDecoration
'
textlength
:
'
textLength
'
textrendering
:
'
textRendering
'
'
text
-
rendering
'
:
'
textRendering
'
to
:
'
to
'
transform
:
'
transform
'
typeof
:
'
typeof
'
u1
:
'
u1
'
u2
:
'
u2
'
underlineposition
:
'
underlinePosition
'
'
underline
-
position
'
:
'
underlinePosition
'
underlinethickness
:
'
underlineThickness
'
'
underline
-
thickness
'
:
'
underlineThickness
'
unicode
:
'
unicode
'
unicodebidi
:
'
unicodeBidi
'
'
unicode
-
bidi
'
:
'
unicodeBidi
'
unicoderange
:
'
unicodeRange
'
'
unicode
-
range
'
:
'
unicodeRange
'
unitsperem
:
'
unitsPerEm
'
'
units
-
per
-
em
'
:
'
unitsPerEm
'
unselectable
:
'
unselectable
'
valphabetic
:
'
vAlphabetic
'
'
v
-
alphabetic
'
:
'
vAlphabetic
'
values
:
'
values
'
vectoreffect
:
'
vectorEffect
'
'
vector
-
effect
'
:
'
vectorEffect
'
version
:
'
version
'
vertadvy
:
'
vertAdvY
'
'
vert
-
adv
-
y
'
:
'
vertAdvY
'
vertoriginx
:
'
vertOriginX
'
'
vert
-
origin
-
x
'
:
'
vertOriginX
'
vertoriginy
:
'
vertOriginY
'
'
vert
-
origin
-
y
'
:
'
vertOriginY
'
vhanging
:
'
vHanging
'
'
v
-
hanging
'
:
'
vHanging
'
videographic
:
'
vIdeographic
'
'
v
-
ideographic
'
:
'
vIdeographic
'
viewbox
:
'
viewBox
'
viewtarget
:
'
viewTarget
'
visibility
:
'
visibility
'
vmathematical
:
'
vMathematical
'
'
v
-
mathematical
'
:
'
vMathematical
'
vocab
:
'
vocab
'
widths
:
'
widths
'
wordspacing
:
'
wordSpacing
'
'
word
-
spacing
'
:
'
wordSpacing
'
writingmode
:
'
writingMode
'
'
writing
-
mode
'
:
'
writingMode
'
x1
:
'
x1
'
x2
:
'
x2
'
x
:
'
x
'
xchannelselector
:
'
xChannelSelector
'
xheight
:
'
xHeight
'
'
x
-
height
'
:
'
xHeight
'
xlinkactuate
:
'
xlinkActuate
'
'
xlink
:
actuate
'
:
'
xlinkActuate
'
xlinkarcrole
:
'
xlinkArcrole
'
'
xlink
:
arcrole
'
:
'
xlinkArcrole
'
xlinkhref
:
'
xlinkHref
'
'
xlink
:
href
'
:
'
xlinkHref
'
xlinkrole
:
'
xlinkRole
'
'
xlink
:
role
'
:
'
xlinkRole
'
xlinkshow
:
'
xlinkShow
'
'
xlink
:
show
'
:
'
xlinkShow
'
xlinktitle
:
'
xlinkTitle
'
'
xlink
:
title
'
:
'
xlinkTitle
'
xlinktype
:
'
xlinkType
'
'
xlink
:
type
'
:
'
xlinkType
'
xmlbase
:
'
xmlBase
'
'
xml
:
base
'
:
'
xmlBase
'
xmllang
:
'
xmlLang
'
'
xml
:
lang
'
:
'
xmlLang
'
xmlns
:
'
xmlns
'
'
xml
:
space
'
:
'
xmlSpace
'
xmlnsxlink
:
'
xmlnsXlink
'
'
xmlns
:
xlink
'
:
'
xmlnsXlink
'
xmlspace
:
'
xmlSpace
'
y1
:
'
y1
'
y2
:
'
y2
'
y
:
'
y
'
ychannelselector
:
'
yChannelSelector
'
z
:
'
z
'
zoomandpan
:
'
zoomAndPan
'
}
;
var
ariaProperties
=
{
'
aria
-
current
'
:
0
'
aria
-
details
'
:
0
'
aria
-
disabled
'
:
0
'
aria
-
hidden
'
:
0
'
aria
-
invalid
'
:
0
'
aria
-
keyshortcuts
'
:
0
'
aria
-
label
'
:
0
'
aria
-
roledescription
'
:
0
'
aria
-
autocomplete
'
:
0
'
aria
-
checked
'
:
0
'
aria
-
expanded
'
:
0
'
aria
-
haspopup
'
:
0
'
aria
-
level
'
:
0
'
aria
-
modal
'
:
0
'
aria
-
multiline
'
:
0
'
aria
-
multiselectable
'
:
0
'
aria
-
orientation
'
:
0
'
aria
-
placeholder
'
:
0
'
aria
-
pressed
'
:
0
'
aria
-
readonly
'
:
0
'
aria
-
required
'
:
0
'
aria
-
selected
'
:
0
'
aria
-
sort
'
:
0
'
aria
-
valuemax
'
:
0
'
aria
-
valuemin
'
:
0
'
aria
-
valuenow
'
:
0
'
aria
-
valuetext
'
:
0
'
aria
-
atomic
'
:
0
'
aria
-
busy
'
:
0
'
aria
-
live
'
:
0
'
aria
-
relevant
'
:
0
'
aria
-
dropeffect
'
:
0
'
aria
-
grabbed
'
:
0
'
aria
-
activedescendant
'
:
0
'
aria
-
colcount
'
:
0
'
aria
-
colindex
'
:
0
'
aria
-
colspan
'
:
0
'
aria
-
controls
'
:
0
'
aria
-
describedby
'
:
0
'
aria
-
errormessage
'
:
0
'
aria
-
flowto
'
:
0
'
aria
-
labelledby
'
:
0
'
aria
-
owns
'
:
0
'
aria
-
posinset
'
:
0
'
aria
-
rowcount
'
:
0
'
aria
-
rowindex
'
:
0
'
aria
-
rowspan
'
:
0
'
aria
-
setsize
'
:
0
}
;
var
warnedProperties
=
{
}
;
var
rARIA
=
new
RegExp
(
'
^
(
aria
)
-
[
'
+
ATTRIBUTE_NAME_CHAR
+
'
]
*
'
)
;
var
rARIACamel
=
new
RegExp
(
'
^
(
aria
)
[
A
-
Z
]
[
'
+
ATTRIBUTE_NAME_CHAR
+
'
]
*
'
)
;
var
hasOwnProperty
1
=
Object
.
prototype
.
hasOwnProperty
;
function
validateProperty
(
tagName
name
)
{
if
(
hasOwnProperty
1
.
call
(
warnedProperties
name
)
&
&
warnedProperties
[
name
]
)
{
return
true
;
}
if
(
rARIACamel
.
test
(
name
)
)
{
var
ariaName
=
'
aria
-
'
+
name
.
slice
(
4
)
.
toLowerCase
(
)
;
var
correctName
=
ariaProperties
.
hasOwnProperty
(
ariaName
)
?
ariaName
:
null
;
if
(
correctName
=
=
null
)
{
warning
1
(
false
'
Invalid
ARIA
attribute
%
s
.
ARIA
attributes
follow
the
pattern
aria
-
*
and
must
be
lowercase
.
'
name
)
;
warnedProperties
[
name
]
=
true
;
return
true
;
}
if
(
name
!
=
=
correctName
)
{
warning
1
(
false
'
Invalid
ARIA
attribute
%
s
.
Did
you
mean
%
s
?
'
name
correctName
)
;
warnedProperties
[
name
]
=
true
;
return
true
;
}
}
if
(
rARIA
.
test
(
name
)
)
{
var
lowerCasedName
=
name
.
toLowerCase
(
)
;
var
standardName
=
ariaProperties
.
hasOwnProperty
(
lowerCasedName
)
?
lowerCasedName
:
null
;
if
(
standardName
=
=
null
)
{
warnedProperties
[
name
]
=
true
;
return
false
;
}
if
(
name
!
=
=
standardName
)
{
warning
1
(
false
'
Unknown
ARIA
attribute
%
s
.
Did
you
mean
%
s
?
'
name
standardName
)
;
warnedProperties
[
name
]
=
true
;
return
true
;
}
}
return
true
;
}
function
warnInvalidARIAProps
(
type
props
)
{
var
invalidProps
=
[
]
;
for
(
var
key
in
props
)
{
var
isValid
=
validateProperty
(
type
key
)
;
if
(
!
isValid
)
{
invalidProps
.
push
(
key
)
;
}
}
var
unknownPropString
=
invalidProps
.
map
(
function
(
prop
)
{
return
'
'
+
prop
+
'
'
;
}
)
.
join
(
'
'
)
;
if
(
invalidProps
.
length
=
=
=
1
)
{
warning
1
(
false
'
Invalid
aria
prop
%
s
on
<
%
s
>
tag
.
'
+
'
For
details
see
https
:
/
/
fb
.
me
/
invalid
-
aria
-
prop
'
unknownPropString
type
)
;
}
else
if
(
invalidProps
.
length
>
1
)
{
warning
1
(
false
'
Invalid
aria
props
%
s
on
<
%
s
>
tag
.
'
+
'
For
details
see
https
:
/
/
fb
.
me
/
invalid
-
aria
-
prop
'
unknownPropString
type
)
;
}
}
function
validateProperties
(
type
props
)
{
if
(
isCustomComponent
(
type
props
)
)
{
return
;
}
warnInvalidARIAProps
(
type
props
)
;
}
var
didWarnValueNull
=
false
;
function
validateProperties
1
(
type
props
)
{
if
(
type
!
=
=
'
input
'
&
&
type
!
=
=
'
textarea
'
&
&
type
!
=
=
'
select
'
)
{
return
;
}
if
(
props
!
=
null
&
&
props
.
value
=
=
=
null
&
&
!
didWarnValueNull
)
{
didWarnValueNull
=
true
;
if
(
type
=
=
=
'
select
'
&
&
props
.
multiple
)
{
warning
1
(
false
'
value
prop
on
%
s
should
not
be
null
.
'
+
'
Consider
using
an
empty
array
when
multiple
is
set
to
true
'
+
'
to
clear
the
component
or
undefined
for
uncontrolled
components
.
'
type
)
;
}
else
{
warning
1
(
false
'
value
prop
on
%
s
should
not
be
null
.
'
+
'
Consider
using
an
empty
string
to
clear
the
component
or
undefined
'
+
'
for
uncontrolled
components
.
'
type
)
;
}
}
}
var
validateProperty
1
=
function
(
)
{
}
;
{
var
warnedProperties
1
=
{
}
;
var
_hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
var
EVENT_NAME_REGEX
=
/
^
on
.
/
;
var
INVALID_EVENT_NAME_REGEX
=
/
^
on
[
^
A
-
Z
]
/
;
var
rARIA
1
=
new
RegExp
(
'
^
(
aria
)
-
[
'
+
ATTRIBUTE_NAME_CHAR
+
'
]
*
'
)
;
var
rARIACamel
1
=
new
RegExp
(
'
^
(
aria
)
[
A
-
Z
]
[
'
+
ATTRIBUTE_NAME_CHAR
+
'
]
*
'
)
;
validateProperty
1
=
function
(
tagName
name
value
canUseEventSystem
)
{
if
(
_hasOwnProperty
.
call
(
warnedProperties
1
name
)
&
&
warnedProperties
1
[
name
]
)
{
return
true
;
}
var
lowerCasedName
=
name
.
toLowerCase
(
)
;
if
(
lowerCasedName
=
=
=
'
onfocusin
'
|
|
lowerCasedName
=
=
=
'
onfocusout
'
)
{
warning
1
(
false
'
React
uses
onFocus
and
onBlur
instead
of
onFocusIn
and
onFocusOut
.
'
+
'
All
React
events
are
normalized
to
bubble
so
onFocusIn
and
onFocusOut
'
+
'
are
not
needed
/
supported
by
React
.
'
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
if
(
canUseEventSystem
)
{
if
(
registrationNameModules
.
hasOwnProperty
(
name
)
)
{
return
true
;
}
var
registrationName
=
possibleRegistrationNames
.
hasOwnProperty
(
lowerCasedName
)
?
possibleRegistrationNames
[
lowerCasedName
]
:
null
;
if
(
registrationName
!
=
null
)
{
warning
1
(
false
'
Invalid
event
handler
property
%
s
.
Did
you
mean
%
s
?
'
name
registrationName
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
if
(
EVENT_NAME_REGEX
.
test
(
name
)
)
{
warning
1
(
false
'
Unknown
event
handler
property
%
s
.
It
will
be
ignored
.
'
name
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
}
else
if
(
EVENT_NAME_REGEX
.
test
(
name
)
)
{
if
(
INVALID_EVENT_NAME_REGEX
.
test
(
name
)
)
{
warning
1
(
false
'
Invalid
event
handler
property
%
s
.
'
+
'
React
events
use
the
camelCase
naming
convention
for
example
onClick
.
'
name
)
;
}
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
if
(
rARIA
1
.
test
(
name
)
|
|
rARIACamel
1
.
test
(
name
)
)
{
return
true
;
}
if
(
lowerCasedName
=
=
=
'
innerhtml
'
)
{
warning
1
(
false
'
Directly
setting
property
innerHTML
is
not
permitted
.
'
+
'
For
more
information
lookup
documentation
on
dangerouslySetInnerHTML
.
'
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
if
(
lowerCasedName
=
=
=
'
aria
'
)
{
warning
1
(
false
'
The
aria
attribute
is
reserved
for
future
use
in
React
.
'
+
'
Pass
individual
aria
-
attributes
instead
.
'
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
if
(
lowerCasedName
=
=
=
'
is
'
&
&
value
!
=
=
null
&
&
value
!
=
=
undefined
&
&
typeof
value
!
=
=
'
string
'
)
{
warning
1
(
false
'
Received
a
%
s
for
a
string
attribute
is
.
If
this
is
expected
cast
'
+
'
the
value
to
a
string
.
'
typeof
value
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
if
(
typeof
value
=
=
=
'
number
'
&
&
isNaN
(
value
)
)
{
warning
1
(
false
'
Received
NaN
for
the
%
s
attribute
.
If
this
is
expected
cast
'
+
'
the
value
to
a
string
.
'
name
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
var
propertyInfo
=
getPropertyInfo
(
name
)
;
var
isReserved
=
propertyInfo
!
=
=
null
&
&
propertyInfo
.
type
=
=
=
RESERVED
;
if
(
possibleStandardNames
.
hasOwnProperty
(
lowerCasedName
)
)
{
var
standardName
=
possibleStandardNames
[
lowerCasedName
]
;
if
(
standardName
!
=
=
name
)
{
warning
1
(
false
'
Invalid
DOM
property
%
s
.
Did
you
mean
%
s
?
'
name
standardName
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
}
else
if
(
!
isReserved
&
&
name
!
=
=
lowerCasedName
)
{
warning
1
(
false
'
React
does
not
recognize
the
%
s
prop
on
a
DOM
element
.
If
you
'
+
'
intentionally
want
it
to
appear
in
the
DOM
as
a
custom
'
+
'
attribute
spell
it
as
lowercase
%
s
instead
.
'
+
'
If
you
accidentally
passed
it
from
a
parent
component
remove
'
+
'
it
from
the
DOM
element
.
'
name
lowerCasedName
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
if
(
typeof
value
=
=
=
'
boolean
'
&
&
shouldRemoveAttributeWithWarning
(
name
value
propertyInfo
false
)
)
{
if
(
value
)
{
warning
1
(
false
'
Received
%
s
for
a
non
-
boolean
attribute
%
s
.
\
n
\
n
'
+
'
If
you
want
to
write
it
to
the
DOM
pass
a
string
instead
:
'
+
'
%
s
=
"
%
s
"
or
%
s
=
{
value
.
toString
(
)
}
.
'
value
name
name
value
name
)
;
}
else
{
warning
1
(
false
'
Received
%
s
for
a
non
-
boolean
attribute
%
s
.
\
n
\
n
'
+
'
If
you
want
to
write
it
to
the
DOM
pass
a
string
instead
:
'
+
'
%
s
=
"
%
s
"
or
%
s
=
{
value
.
toString
(
)
}
.
\
n
\
n
'
+
'
If
you
used
to
conditionally
omit
it
with
%
s
=
{
condition
&
&
value
}
'
+
'
pass
%
s
=
{
condition
?
value
:
undefined
}
instead
.
'
value
name
name
value
name
name
name
)
;
}
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
if
(
isReserved
)
{
return
true
;
}
if
(
shouldRemoveAttributeWithWarning
(
name
value
propertyInfo
false
)
)
{
warnedProperties
1
[
name
]
=
true
;
return
false
;
}
if
(
(
value
=
=
=
'
false
'
|
|
value
=
=
=
'
true
'
)
&
&
propertyInfo
!
=
=
null
&
&
propertyInfo
.
type
=
=
=
BOOLEAN
)
{
warning
1
(
false
'
Received
the
string
%
s
for
the
boolean
attribute
%
s
.
'
+
'
%
s
'
+
'
Did
you
mean
%
s
=
{
%
s
}
?
'
value
name
value
=
=
=
'
false
'
?
'
The
browser
will
interpret
it
as
a
truthy
value
.
'
:
'
Although
this
works
it
will
not
work
as
expected
if
you
pass
the
string
"
false
"
.
'
name
value
)
;
warnedProperties
1
[
name
]
=
true
;
return
true
;
}
return
true
;
}
;
}
var
warnUnknownProperties
=
function
(
type
props
canUseEventSystem
)
{
var
unknownProps
=
[
]
;
for
(
var
key
in
props
)
{
var
isValid
=
validateProperty
1
(
type
key
props
[
key
]
canUseEventSystem
)
;
if
(
!
isValid
)
{
unknownProps
.
push
(
key
)
;
}
}
var
unknownPropString
=
unknownProps
.
map
(
function
(
prop
)
{
return
'
'
+
prop
+
'
'
;
}
)
.
join
(
'
'
)
;
if
(
unknownProps
.
length
=
=
=
1
)
{
warning
1
(
false
'
Invalid
value
for
prop
%
s
on
<
%
s
>
tag
.
Either
remove
it
from
the
element
'
+
'
or
pass
a
string
or
number
value
to
keep
it
in
the
DOM
.
'
+
'
For
details
see
https
:
/
/
fb
.
me
/
react
-
attribute
-
behavior
'
unknownPropString
type
)
;
}
else
if
(
unknownProps
.
length
>
1
)
{
warning
1
(
false
'
Invalid
values
for
props
%
s
on
<
%
s
>
tag
.
Either
remove
them
from
the
element
'
+
'
or
pass
a
string
or
number
value
to
keep
them
in
the
DOM
.
'
+
'
For
details
see
https
:
/
/
fb
.
me
/
react
-
attribute
-
behavior
'
unknownPropString
type
)
;
}
}
;
function
validateProperties
2
(
type
props
canUseEventSystem
)
{
if
(
isCustomComponent
(
type
props
)
)
{
return
;
}
warnUnknownProperties
(
type
props
canUseEventSystem
)
;
}
var
didWarnInvalidHydration
=
false
;
var
didWarnShadyDOM
=
false
;
var
didWarnScriptTags
=
false
;
var
DANGEROUSLY_SET_INNER_HTML
=
'
dangerouslySetInnerHTML
'
;
var
SUPPRESS_CONTENT_EDITABLE_WARNING
=
'
suppressContentEditableWarning
'
;
var
SUPPRESS_HYDRATION_WARNING
1
=
'
suppressHydrationWarning
'
;
var
AUTOFOCUS
=
'
autoFocus
'
;
var
CHILDREN
=
'
children
'
;
var
STYLE
1
=
'
style
'
;
var
HTML
=
'
__html
'
;
var
LISTENERS
=
'
listeners
'
;
var
HTML_NAMESPACE
=
Namespaces
.
html
;
var
warnedUnknownTags
;
var
suppressHydrationWarning
;
var
validatePropertiesInDevelopment
;
var
warnForTextDifference
;
var
warnForPropDifference
;
var
warnForExtraAttributes
;
var
warnForInvalidEventListener
;
var
canDiffStyleForHydrationWarning
;
var
normalizeMarkupForTextOrAttribute
;
var
normalizeHTML
;
{
warnedUnknownTags
=
{
time
:
true
dialog
:
true
webview
:
true
}
;
validatePropertiesInDevelopment
=
function
(
type
props
)
{
validateProperties
(
type
props
)
;
validateProperties
1
(
type
props
)
;
validateProperties
2
(
type
props
true
)
;
}
;
canDiffStyleForHydrationWarning
=
canUseDOM
&
&
!
document
.
documentMode
;
var
NORMALIZE_NEWLINES_REGEX
=
/
\
r
\
n
?
/
g
;
var
NORMALIZE_NULL_AND_REPLACEMENT_REGEX
=
/
\
u0000
|
\
uFFFD
/
g
;
normalizeMarkupForTextOrAttribute
=
function
(
markup
)
{
var
markupString
=
typeof
markup
=
=
=
'
string
'
?
markup
:
'
'
+
markup
;
return
markupString
.
replace
(
NORMALIZE_NEWLINES_REGEX
'
\
n
'
)
.
replace
(
NORMALIZE_NULL_AND_REPLACEMENT_REGEX
'
'
)
;
}
;
warnForTextDifference
=
function
(
serverText
clientText
)
{
if
(
didWarnInvalidHydration
)
{
return
;
}
var
normalizedClientText
=
normalizeMarkupForTextOrAttribute
(
clientText
)
;
var
normalizedServerText
=
normalizeMarkupForTextOrAttribute
(
serverText
)
;
if
(
normalizedServerText
=
=
=
normalizedClientText
)
{
return
;
}
didWarnInvalidHydration
=
true
;
warningWithoutStack
1
(
false
'
Text
content
did
not
match
.
Server
:
"
%
s
"
Client
:
"
%
s
"
'
normalizedServerText
normalizedClientText
)
;
}
;
warnForPropDifference
=
function
(
propName
serverValue
clientValue
)
{
if
(
didWarnInvalidHydration
)
{
return
;
}
var
normalizedClientValue
=
normalizeMarkupForTextOrAttribute
(
clientValue
)
;
var
normalizedServerValue
=
normalizeMarkupForTextOrAttribute
(
serverValue
)
;
if
(
normalizedServerValue
=
=
=
normalizedClientValue
)
{
return
;
}
didWarnInvalidHydration
=
true
;
warningWithoutStack
1
(
false
'
Prop
%
s
did
not
match
.
Server
:
%
s
Client
:
%
s
'
propName
JSON
.
stringify
(
normalizedServerValue
)
JSON
.
stringify
(
normalizedClientValue
)
)
;
}
;
warnForExtraAttributes
=
function
(
attributeNames
)
{
if
(
didWarnInvalidHydration
)
{
return
;
}
didWarnInvalidHydration
=
true
;
var
names
=
[
]
;
attributeNames
.
forEach
(
function
(
name
)
{
names
.
push
(
name
)
;
}
)
;
warningWithoutStack
1
(
false
'
Extra
attributes
from
the
server
:
%
s
'
names
)
;
}
;
warnForInvalidEventListener
=
function
(
registrationName
listener
)
{
if
(
listener
=
=
=
false
)
{
warning
1
(
false
'
Expected
%
s
listener
to
be
a
function
instead
got
false
.
\
n
\
n
'
+
'
If
you
used
to
conditionally
omit
it
with
%
s
=
{
condition
&
&
value
}
'
+
'
pass
%
s
=
{
condition
?
value
:
undefined
}
instead
.
'
registrationName
registrationName
registrationName
)
;
}
else
{
warning
1
(
false
'
Expected
%
s
listener
to
be
a
function
instead
got
a
value
of
%
s
type
.
'
registrationName
typeof
listener
)
;
}
}
;
normalizeHTML
=
function
(
parent
html
)
{
var
testElement
=
parent
.
namespaceURI
=
=
=
HTML_NAMESPACE
?
parent
.
ownerDocument
.
createElement
(
parent
.
tagName
)
:
parent
.
ownerDocument
.
createElementNS
(
parent
.
namespaceURI
parent
.
tagName
)
;
testElement
.
innerHTML
=
html
;
return
testElement
.
innerHTML
;
}
;
}
function
ensureListeningTo
(
rootContainerElement
registrationName
)
{
var
isDocumentOrFragment
=
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_NODE
|
|
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE
;
var
doc
=
isDocumentOrFragment
?
rootContainerElement
:
rootContainerElement
.
ownerDocument
;
listenTo
(
registrationName
doc
)
;
}
function
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
{
return
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_NODE
?
rootContainerElement
:
rootContainerElement
.
ownerDocument
;
}
function
noop
(
)
{
}
function
trapClickOnNonInteractiveElement
(
node
)
{
node
.
onclick
=
noop
;
}
function
setInitialDOMProperties
(
tag
domElement
rootContainerElement
nextProps
isCustomComponentTag
)
{
for
(
var
propKey
in
nextProps
)
{
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
nextProp
=
nextProps
[
propKey
]
;
if
(
propKey
=
=
=
STYLE
1
)
{
{
if
(
nextProp
)
{
Object
.
freeze
(
nextProp
)
;
}
}
setValueForStyles
(
domElement
nextProp
)
;
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
if
(
nextHtml
!
=
null
)
{
setInnerHTML
(
domElement
nextHtml
)
;
}
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
typeof
nextProp
=
=
=
'
string
'
)
{
var
canSetTextContent
=
tag
!
=
=
'
textarea
'
|
|
nextProp
!
=
=
'
'
;
if
(
canSetTextContent
)
{
setTextContent
(
domElement
nextProp
)
;
}
}
else
if
(
typeof
nextProp
=
=
=
'
number
'
)
{
setTextContent
(
domElement
'
'
+
nextProp
)
;
}
}
else
if
(
enableFlareAPI
&
&
propKey
=
=
=
LISTENERS
|
|
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
propKey
=
=
=
AUTOFOCUS
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
if
(
true
&
&
typeof
nextProp
!
=
=
'
function
'
)
{
warnForInvalidEventListener
(
propKey
nextProp
)
;
}
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
}
else
if
(
nextProp
!
=
null
)
{
setValueForProperty
(
domElement
propKey
nextProp
isCustomComponentTag
)
;
}
}
}
function
updateDOMProperties
(
domElement
updatePayload
wasCustomComponentTag
isCustomComponentTag
)
{
for
(
var
i
=
0
;
i
<
updatePayload
.
length
;
i
+
=
2
)
{
var
propKey
=
updatePayload
[
i
]
;
var
propValue
=
updatePayload
[
i
+
1
]
;
if
(
propKey
=
=
=
STYLE
1
)
{
setValueForStyles
(
domElement
propValue
)
;
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
setInnerHTML
(
domElement
propValue
)
;
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
setTextContent
(
domElement
propValue
)
;
}
else
{
setValueForProperty
(
domElement
propKey
propValue
isCustomComponentTag
)
;
}
}
}
function
createElement
(
type
props
rootContainerElement
parentNamespace
)
{
var
isCustomComponentTag
;
var
ownerDocument
=
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
;
var
domElement
;
var
namespaceURI
=
parentNamespace
;
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
namespaceURI
=
getIntrinsicNamespace
(
type
)
;
}
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
{
isCustomComponentTag
=
isCustomComponent
(
type
props
)
;
!
(
isCustomComponentTag
|
|
type
=
=
=
type
.
toLowerCase
(
)
)
?
warning
1
(
false
'
<
%
s
/
>
is
using
incorrect
casing
.
'
+
'
Use
PascalCase
for
React
components
'
+
'
or
lowercase
for
HTML
elements
.
'
type
)
:
void
0
;
}
if
(
type
=
=
=
'
script
'
)
{
var
div
=
ownerDocument
.
createElement
(
'
div
'
)
;
{
if
(
enableTrustedTypesIntegration
&
&
!
didWarnScriptTags
)
{
warning
1
(
false
'
Encountered
a
script
tag
while
rendering
React
component
.
'
+
'
Scripts
inside
React
components
are
never
executed
when
rendering
'
+
'
on
the
client
.
Consider
using
template
tag
instead
'
+
'
(
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
Web
/
HTML
/
Element
/
template
)
.
'
)
;
didWarnScriptTags
=
true
;
}
}
div
.
innerHTML
=
'
<
script
>
<
'
+
'
/
script
>
'
;
var
firstChild
=
div
.
firstChild
;
domElement
=
div
.
removeChild
(
firstChild
)
;
}
else
if
(
typeof
props
.
is
=
=
=
'
string
'
)
{
domElement
=
ownerDocument
.
createElement
(
type
{
is
:
props
.
is
}
)
;
}
else
{
domElement
=
ownerDocument
.
createElement
(
type
)
;
if
(
type
=
=
=
'
select
'
)
{
var
node
=
domElement
;
if
(
props
.
multiple
)
{
node
.
multiple
=
true
;
}
else
if
(
props
.
size
)
{
node
.
size
=
props
.
size
;
}
}
}
}
else
{
domElement
=
ownerDocument
.
createElementNS
(
namespaceURI
type
)
;
}
{
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
if
(
!
isCustomComponentTag
&
&
Object
.
prototype
.
toString
.
call
(
domElement
)
=
=
=
'
[
object
HTMLUnknownElement
]
'
&
&
!
Object
.
prototype
.
hasOwnProperty
.
call
(
warnedUnknownTags
type
)
)
{
warnedUnknownTags
[
type
]
=
true
;
warning
1
(
false
'
The
tag
<
%
s
>
is
unrecognized
in
this
browser
.
'
+
'
If
you
meant
to
render
a
React
component
start
its
name
with
'
+
'
an
uppercase
letter
.
'
type
)
;
}
}
}
return
domElement
;
}
function
createTextNode
(
text
rootContainerElement
)
{
return
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
.
createTextNode
(
text
)
;
}
function
setInitialProperties
(
domElement
tag
rawProps
rootContainerElement
)
{
var
isCustomComponentTag
=
isCustomComponent
(
tag
rawProps
)
;
{
validatePropertiesInDevelopment
(
tag
rawProps
)
;
if
(
isCustomComponentTag
&
&
!
didWarnShadyDOM
&
&
domElement
.
shadyRoot
)
{
warning
1
(
false
'
%
s
is
using
shady
DOM
.
Using
shady
DOM
with
React
can
'
+
'
cause
things
to
break
subtly
.
'
getCurrentFiberOwnerNameInDevOrNull
(
)
|
|
'
A
component
'
)
;
didWarnShadyDOM
=
true
;
}
}
var
props
;
switch
(
tag
)
{
case
'
iframe
'
:
case
'
object
'
:
case
'
embed
'
:
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
props
=
rawProps
;
break
;
case
'
video
'
:
case
'
audio
'
:
for
(
var
i
=
0
;
i
<
mediaEventTypes
.
length
;
i
+
+
)
{
trapBubbledEvent
(
mediaEventTypes
[
i
]
domElement
)
;
}
props
=
rawProps
;
break
;
case
'
source
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
props
=
rawProps
;
break
;
case
'
img
'
:
case
'
image
'
:
case
'
link
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
props
=
rawProps
;
break
;
case
'
form
'
:
trapBubbledEvent
(
TOP_RESET
domElement
)
;
trapBubbledEvent
(
TOP_SUBMIT
domElement
)
;
props
=
rawProps
;
break
;
case
'
details
'
:
trapBubbledEvent
(
TOP_TOGGLE
domElement
)
;
props
=
rawProps
;
break
;
case
'
input
'
:
initWrapperState
(
domElement
rawProps
)
;
props
=
getHostProps
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
option
'
:
validateProps
(
domElement
rawProps
)
;
props
=
getHostProps
1
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
initWrapperState
1
(
domElement
rawProps
)
;
props
=
getHostProps
2
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
textarea
'
:
initWrapperState
2
(
domElement
rawProps
)
;
props
=
getHostProps
3
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
default
:
props
=
rawProps
;
}
assertValidProps
(
tag
props
)
;
setInitialDOMProperties
(
tag
domElement
rootContainerElement
props
isCustomComponentTag
)
;
switch
(
tag
)
{
case
'
input
'
:
track
(
domElement
)
;
postMountWrapper
(
domElement
rawProps
false
)
;
break
;
case
'
textarea
'
:
track
(
domElement
)
;
postMountWrapper
3
(
domElement
rawProps
)
;
break
;
case
'
option
'
:
postMountWrapper
1
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
postMountWrapper
2
(
domElement
rawProps
)
;
break
;
default
:
if
(
typeof
props
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
}
function
diffProperties
(
domElement
tag
lastRawProps
nextRawProps
rootContainerElement
)
{
{
validatePropertiesInDevelopment
(
tag
nextRawProps
)
;
}
var
updatePayload
=
null
;
var
lastProps
;
var
nextProps
;
switch
(
tag
)
{
case
'
input
'
:
lastProps
=
getHostProps
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
option
'
:
lastProps
=
getHostProps
1
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
1
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
select
'
:
lastProps
=
getHostProps
2
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
2
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
textarea
'
:
lastProps
=
getHostProps
3
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
3
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
default
:
lastProps
=
lastRawProps
;
nextProps
=
nextRawProps
;
if
(
typeof
lastProps
.
onClick
!
=
=
'
function
'
&
&
typeof
nextProps
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
assertValidProps
(
tag
nextProps
)
;
var
propKey
;
var
styleName
;
var
styleUpdates
=
null
;
for
(
propKey
in
lastProps
)
{
if
(
nextProps
.
hasOwnProperty
(
propKey
)
|
|
!
lastProps
.
hasOwnProperty
(
propKey
)
|
|
lastProps
[
propKey
]
=
=
null
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
1
)
{
var
lastStyle
=
lastProps
[
propKey
]
;
for
(
styleName
in
lastStyle
)
{
if
(
lastStyle
.
hasOwnProperty
(
styleName
)
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
'
'
;
}
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
|
|
propKey
=
=
=
CHILDREN
)
{
}
else
if
(
enableFlareAPI
&
&
propKey
=
=
=
LISTENERS
|
|
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
propKey
=
=
=
AUTOFOCUS
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
!
updatePayload
)
{
updatePayload
=
[
]
;
}
}
else
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
null
)
;
}
}
for
(
propKey
in
nextProps
)
{
var
nextProp
=
nextProps
[
propKey
]
;
var
lastProp
=
lastProps
!
=
null
?
lastProps
[
propKey
]
:
undefined
;
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
|
|
nextProp
=
=
=
lastProp
|
|
nextProp
=
=
null
&
&
lastProp
=
=
null
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
1
)
{
{
if
(
nextProp
)
{
Object
.
freeze
(
nextProp
)
;
}
}
if
(
lastProp
)
{
for
(
styleName
in
lastProp
)
{
if
(
lastProp
.
hasOwnProperty
(
styleName
)
&
&
(
!
nextProp
|
|
!
nextProp
.
hasOwnProperty
(
styleName
)
)
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
'
'
;
}
}
for
(
styleName
in
nextProp
)
{
if
(
nextProp
.
hasOwnProperty
(
styleName
)
&
&
lastProp
[
styleName
]
!
=
=
nextProp
[
styleName
]
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
nextProp
[
styleName
]
;
}
}
}
else
{
if
(
!
styleUpdates
)
{
if
(
!
updatePayload
)
{
updatePayload
=
[
]
;
}
updatePayload
.
push
(
propKey
styleUpdates
)
;
}
styleUpdates
=
nextProp
;
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
var
lastHtml
=
lastProp
?
lastProp
[
HTML
]
:
undefined
;
if
(
nextHtml
!
=
null
)
{
if
(
lastHtml
!
=
=
nextHtml
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
toStringOrTrustedType
(
nextHtml
)
)
;
}
}
else
{
}
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
lastProp
!
=
=
nextProp
&
&
(
typeof
nextProp
=
=
=
'
string
'
|
|
typeof
nextProp
=
=
=
'
number
'
)
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
'
'
+
nextProp
)
;
}
}
else
if
(
enableFlareAPI
&
&
propKey
=
=
=
LISTENERS
|
|
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
if
(
true
&
&
typeof
nextProp
!
=
=
'
function
'
)
{
warnForInvalidEventListener
(
propKey
nextProp
)
;
}
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
if
(
!
updatePayload
&
&
lastProp
!
=
=
nextProp
)
{
updatePayload
=
[
]
;
}
}
else
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
nextProp
)
;
}
}
if
(
styleUpdates
)
{
{
validateShorthandPropertyCollisionInDev
(
styleUpdates
nextProps
[
STYLE
1
]
)
;
}
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
STYLE
1
styleUpdates
)
;
}
return
updatePayload
;
}
function
updateProperties
(
domElement
updatePayload
tag
lastRawProps
nextRawProps
)
{
if
(
tag
=
=
=
'
input
'
&
&
nextRawProps
.
type
=
=
=
'
radio
'
&
&
nextRawProps
.
name
!
=
null
)
{
updateChecked
(
domElement
nextRawProps
)
;
}
var
wasCustomComponentTag
=
isCustomComponent
(
tag
lastRawProps
)
;
var
isCustomComponentTag
=
isCustomComponent
(
tag
nextRawProps
)
;
updateDOMProperties
(
domElement
updatePayload
wasCustomComponentTag
isCustomComponentTag
)
;
switch
(
tag
)
{
case
'
input
'
:
updateWrapper
(
domElement
nextRawProps
)
;
break
;
case
'
textarea
'
:
updateWrapper
1
(
domElement
nextRawProps
)
;
break
;
case
'
select
'
:
postUpdateWrapper
(
domElement
nextRawProps
)
;
break
;
}
}
function
getPossibleStandardName
(
propName
)
{
{
var
lowerCasedName
=
propName
.
toLowerCase
(
)
;
if
(
!
possibleStandardNames
.
hasOwnProperty
(
lowerCasedName
)
)
{
return
null
;
}
return
possibleStandardNames
[
lowerCasedName
]
|
|
null
;
}
return
null
;
}
function
diffHydratedProperties
(
domElement
tag
rawProps
parentNamespace
rootContainerElement
)
{
var
isCustomComponentTag
;
var
extraAttributeNames
;
{
suppressHydrationWarning
=
rawProps
[
SUPPRESS_HYDRATION_WARNING
1
]
=
=
=
true
;
isCustomComponentTag
=
isCustomComponent
(
tag
rawProps
)
;
validatePropertiesInDevelopment
(
tag
rawProps
)
;
if
(
isCustomComponentTag
&
&
!
didWarnShadyDOM
&
&
domElement
.
shadyRoot
)
{
warning
1
(
false
'
%
s
is
using
shady
DOM
.
Using
shady
DOM
with
React
can
'
+
'
cause
things
to
break
subtly
.
'
getCurrentFiberOwnerNameInDevOrNull
(
)
|
|
'
A
component
'
)
;
didWarnShadyDOM
=
true
;
}
}
switch
(
tag
)
{
case
'
iframe
'
:
case
'
object
'
:
case
'
embed
'
:
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
break
;
case
'
video
'
:
case
'
audio
'
:
for
(
var
i
=
0
;
i
<
mediaEventTypes
.
length
;
i
+
+
)
{
trapBubbledEvent
(
mediaEventTypes
[
i
]
domElement
)
;
}
break
;
case
'
source
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
break
;
case
'
img
'
:
case
'
image
'
:
case
'
link
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
break
;
case
'
form
'
:
trapBubbledEvent
(
TOP_RESET
domElement
)
;
trapBubbledEvent
(
TOP_SUBMIT
domElement
)
;
break
;
case
'
details
'
:
trapBubbledEvent
(
TOP_TOGGLE
domElement
)
;
break
;
case
'
input
'
:
initWrapperState
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
option
'
:
validateProps
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
initWrapperState
1
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
textarea
'
:
initWrapperState
2
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
}
assertValidProps
(
tag
rawProps
)
;
{
extraAttributeNames
=
new
Set
(
)
;
var
attributes
=
domElement
.
attributes
;
for
(
var
_i
=
0
;
_i
<
attributes
.
length
;
_i
+
+
)
{
var
name
=
attributes
[
_i
]
.
name
.
toLowerCase
(
)
;
switch
(
name
)
{
case
'
data
-
reactroot
'
:
break
;
case
'
value
'
:
break
;
case
'
checked
'
:
break
;
case
'
selected
'
:
break
;
default
:
extraAttributeNames
.
add
(
attributes
[
_i
]
.
name
)
;
}
}
}
var
updatePayload
=
null
;
for
(
var
propKey
in
rawProps
)
{
if
(
!
rawProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
nextProp
=
rawProps
[
propKey
]
;
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
typeof
nextProp
=
=
=
'
string
'
)
{
if
(
domElement
.
textContent
!
=
=
nextProp
)
{
if
(
true
&
&
!
suppressHydrationWarning
)
{
warnForTextDifference
(
domElement
.
textContent
nextProp
)
;
}
updatePayload
=
[
CHILDREN
nextProp
]
;
}
}
else
if
(
typeof
nextProp
=
=
=
'
number
'
)
{
if
(
domElement
.
textContent
!
=
=
'
'
+
nextProp
)
{
if
(
true
&
&
!
suppressHydrationWarning
)
{
warnForTextDifference
(
domElement
.
textContent
nextProp
)
;
}
updatePayload
=
[
CHILDREN
'
'
+
nextProp
]
;
}
}
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
if
(
true
&
&
typeof
nextProp
!
=
=
'
function
'
)
{
warnForInvalidEventListener
(
propKey
nextProp
)
;
}
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
}
else
if
(
true
&
&
typeof
isCustomComponentTag
=
=
=
'
boolean
'
)
{
var
serverValue
=
void
0
;
var
propertyInfo
=
getPropertyInfo
(
propKey
)
;
if
(
suppressHydrationWarning
)
{
}
else
if
(
enableFlareAPI
&
&
propKey
=
=
=
LISTENERS
|
|
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
|
|
propKey
=
=
=
'
value
'
|
|
propKey
=
=
=
'
checked
'
|
|
propKey
=
=
=
'
selected
'
)
{
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
serverHTML
=
domElement
.
innerHTML
;
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
var
expectedHTML
=
normalizeHTML
(
domElement
nextHtml
!
=
null
?
nextHtml
:
'
'
)
;
if
(
expectedHTML
!
=
=
serverHTML
)
{
warnForPropDifference
(
propKey
serverHTML
expectedHTML
)
;
}
}
else
if
(
propKey
=
=
=
STYLE
1
)
{
extraAttributeNames
.
delete
(
propKey
)
;
if
(
canDiffStyleForHydrationWarning
)
{
var
expectedStyle
=
createDangerousStringForStyles
(
nextProp
)
;
serverValue
=
domElement
.
getAttribute
(
'
style
'
)
;
if
(
expectedStyle
!
=
=
serverValue
)
{
warnForPropDifference
(
propKey
serverValue
expectedStyle
)
;
}
}
}
else
if
(
isCustomComponentTag
)
{
extraAttributeNames
.
delete
(
propKey
.
toLowerCase
(
)
)
;
serverValue
=
getValueForAttribute
(
domElement
propKey
nextProp
)
;
if
(
nextProp
!
=
=
serverValue
)
{
warnForPropDifference
(
propKey
serverValue
nextProp
)
;
}
}
else
if
(
!
shouldIgnoreAttribute
(
propKey
propertyInfo
isCustomComponentTag
)
&
&
!
shouldRemoveAttribute
(
propKey
nextProp
propertyInfo
isCustomComponentTag
)
)
{
var
isMismatchDueToBadCasing
=
false
;
if
(
propertyInfo
!
=
=
null
)
{
extraAttributeNames
.
delete
(
propertyInfo
.
attributeName
)
;
serverValue
=
getValueForProperty
(
domElement
propKey
nextProp
propertyInfo
)
;
}
else
{
var
ownNamespace
=
parentNamespace
;
if
(
ownNamespace
=
=
=
HTML_NAMESPACE
)
{
ownNamespace
=
getIntrinsicNamespace
(
tag
)
;
}
if
(
ownNamespace
=
=
=
HTML_NAMESPACE
)
{
extraAttributeNames
.
delete
(
propKey
.
toLowerCase
(
)
)
;
}
else
{
var
standardName
=
getPossibleStandardName
(
propKey
)
;
if
(
standardName
!
=
=
null
&
&
standardName
!
=
=
propKey
)
{
isMismatchDueToBadCasing
=
true
;
extraAttributeNames
.
delete
(
standardName
)
;
}
extraAttributeNames
.
delete
(
propKey
)
;
}
serverValue
=
getValueForAttribute
(
domElement
propKey
nextProp
)
;
}
if
(
nextProp
!
=
=
serverValue
&
&
!
isMismatchDueToBadCasing
)
{
warnForPropDifference
(
propKey
serverValue
nextProp
)
;
}
}
}
}
{
if
(
extraAttributeNames
.
size
>
0
&
&
!
suppressHydrationWarning
)
{
warnForExtraAttributes
(
extraAttributeNames
)
;
}
}
switch
(
tag
)
{
case
'
input
'
:
track
(
domElement
)
;
postMountWrapper
(
domElement
rawProps
true
)
;
break
;
case
'
textarea
'
:
track
(
domElement
)
;
postMountWrapper
3
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
case
'
option
'
:
break
;
default
:
if
(
typeof
rawProps
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
return
updatePayload
;
}
function
diffHydratedText
(
textNode
text
)
{
var
isDifferent
=
textNode
.
nodeValue
!
=
=
text
;
return
isDifferent
;
}
function
warnForUnmatchedText
(
textNode
text
)
{
{
warnForTextDifference
(
textNode
.
nodeValue
text
)
;
}
}
function
warnForDeletedHydratableElement
(
parentNode
child
)
{
{
if
(
didWarnInvalidHydration
)
{
return
;
}
didWarnInvalidHydration
=
true
;
warningWithoutStack
1
(
false
'
Did
not
expect
server
HTML
to
contain
a
<
%
s
>
in
<
%
s
>
.
'
child
.
nodeName
.
toLowerCase
(
)
parentNode
.
nodeName
.
toLowerCase
(
)
)
;
}
}
function
warnForDeletedHydratableText
(
parentNode
child
)
{
{
if
(
didWarnInvalidHydration
)
{
return
;
}
didWarnInvalidHydration
=
true
;
warningWithoutStack
1
(
false
'
Did
not
expect
server
HTML
to
contain
the
text
node
"
%
s
"
in
<
%
s
>
.
'
child
.
nodeValue
parentNode
.
nodeName
.
toLowerCase
(
)
)
;
}
}
function
warnForInsertedHydratedElement
(
parentNode
tag
props
)
{
{
if
(
didWarnInvalidHydration
)
{
return
;
}
didWarnInvalidHydration
=
true
;
warningWithoutStack
1
(
false
'
Expected
server
HTML
to
contain
a
matching
<
%
s
>
in
<
%
s
>
.
'
tag
parentNode
.
nodeName
.
toLowerCase
(
)
)
;
}
}
function
warnForInsertedHydratedText
(
parentNode
text
)
{
{
if
(
text
=
=
=
'
'
)
{
return
;
}
if
(
didWarnInvalidHydration
)
{
return
;
}
didWarnInvalidHydration
=
true
;
warningWithoutStack
1
(
false
'
Expected
server
HTML
to
contain
a
matching
text
node
for
"
%
s
"
in
<
%
s
>
.
'
text
parentNode
.
nodeName
.
toLowerCase
(
)
)
;
}
}
function
restoreControlledState
1
(
domElement
tag
props
)
{
switch
(
tag
)
{
case
'
input
'
:
restoreControlledState
1
(
domElement
props
)
;
return
;
case
'
textarea
'
:
restoreControlledState
3
(
domElement
props
)
;
return
;
case
'
select
'
:
restoreControlledState
2
(
domElement
props
)
;
return
;
}
}
function
listenToEventResponderEventTypes
(
eventTypes
element
)
{
if
(
enableFlareAPI
)
{
var
listeningSet
=
getListeningSetForElement
(
element
)
;
for
(
var
i
=
0
length
=
eventTypes
.
length
;
i
<
length
;
+
+
i
)
{
var
eventType
=
eventTypes
[
i
]
;
var
isPassive
=
!
endsWith
(
eventType
'
_active
'
)
;
var
eventKey
=
isPassive
?
eventType
+
'
_passive
'
:
eventType
;
var
targetEventType
=
isPassive
?
eventType
:
eventType
.
substring
(
0
eventType
.
length
-
7
)
;
if
(
!
listeningSet
.
has
(
eventKey
)
)
{
trapEventForResponderEventSystem
(
element
targetEventType
isPassive
)
;
listeningSet
.
add
(
eventKey
)
;
}
}
}
}
if
(
enableFlareAPI
)
{
setListenToResponderEventTypes
(
listenToEventResponderEventTypes
)
;
}
function
getActiveElement
(
doc
)
{
doc
=
doc
|
|
(
typeof
document
!
=
=
'
undefined
'
?
document
:
undefined
)
;
if
(
typeof
doc
=
=
=
'
undefined
'
)
{
return
null
;
}
try
{
return
doc
.
activeElement
|
|
doc
.
body
;
}
catch
(
e
)
{
return
doc
.
body
;
}
}
function
getLeafNode
(
node
)
{
while
(
node
&
&
node
.
firstChild
)
{
node
=
node
.
firstChild
;
}
return
node
;
}
function
getSiblingNode
(
node
)
{
while
(
node
)
{
if
(
node
.
nextSibling
)
{
return
node
.
nextSibling
;
}
node
=
node
.
parentNode
;
}
}
function
getNodeForCharacterOffset
(
root
offset
)
{
var
node
=
getLeafNode
(
root
)
;
var
nodeStart
=
0
;
var
nodeEnd
=
0
;
while
(
node
)
{
if
(
node
.
nodeType
=
=
=
TEXT_NODE
)
{
nodeEnd
=
nodeStart
+
node
.
textContent
.
length
;
if
(
nodeStart
<
=
offset
&
&
nodeEnd
>
=
offset
)
{
return
{
node
:
node
offset
:
offset
-
nodeStart
}
;
}
nodeStart
=
nodeEnd
;
}
node
=
getLeafNode
(
getSiblingNode
(
node
)
)
;
}
}
function
getOffsets
(
outerNode
)
{
var
ownerDocument
=
outerNode
.
ownerDocument
;
var
win
=
ownerDocument
&
&
ownerDocument
.
defaultView
|
|
window
;
var
selection
=
win
.
getSelection
&
&
win
.
getSelection
(
)
;
if
(
!
selection
|
|
selection
.
rangeCount
=
=
=
0
)
{
return
null
;
}
var
anchorNode
=
selection
.
anchorNode
anchorOffset
=
selection
.
anchorOffset
focusNode
=
selection
.
focusNode
focusOffset
=
selection
.
focusOffset
;
try
{
anchorNode
.
nodeType
;
focusNode
.
nodeType
;
}
catch
(
e
)
{
return
null
;
}
return
getModernOffsetsFromPoints
(
outerNode
anchorNode
anchorOffset
focusNode
focusOffset
)
;
}
function
getModernOffsetsFromPoints
(
outerNode
anchorNode
anchorOffset
focusNode
focusOffset
)
{
var
length
=
0
;
var
start
=
-
1
;
var
end
=
-
1
;
var
indexWithinAnchor
=
0
;
var
indexWithinFocus
=
0
;
var
node
=
outerNode
;
var
parentNode
=
null
;
outer
:
while
(
true
)
{
var
next
=
null
;
while
(
true
)
{
if
(
node
=
=
=
anchorNode
&
&
(
anchorOffset
=
=
=
0
|
|
node
.
nodeType
=
=
=
TEXT_NODE
)
)
{
start
=
length
+
anchorOffset
;
}
if
(
node
=
=
=
focusNode
&
&
(
focusOffset
=
=
=
0
|
|
node
.
nodeType
=
=
=
TEXT_NODE
)
)
{
end
=
length
+
focusOffset
;
}
if
(
node
.
nodeType
=
=
=
TEXT_NODE
)
{
length
+
=
node
.
nodeValue
.
length
;
}
if
(
(
next
=
node
.
firstChild
)
=
=
=
null
)
{
break
;
}
parentNode
=
node
;
node
=
next
;
}
while
(
true
)
{
if
(
node
=
=
=
outerNode
)
{
break
outer
;
}
if
(
parentNode
=
=
=
anchorNode
&
&
+
+
indexWithinAnchor
=
=
=
anchorOffset
)
{
start
=
length
;
}
if
(
parentNode
=
=
=
focusNode
&
&
+
+
indexWithinFocus
=
=
=
focusOffset
)
{
end
=
length
;
}
if
(
(
next
=
node
.
nextSibling
)
!
=
=
null
)
{
break
;
}
node
=
parentNode
;
parentNode
=
node
.
parentNode
;
}
node
=
next
;
}
if
(
start
=
=
=
-
1
|
|
end
=
=
=
-
1
)
{
return
null
;
}
return
{
start
:
start
end
:
end
}
;
}
function
setOffsets
(
node
offsets
)
{
var
doc
=
node
.
ownerDocument
|
|
document
;
var
win
=
doc
&
&
doc
.
defaultView
|
|
window
;
if
(
!
win
.
getSelection
)
{
return
;
}
var
selection
=
win
.
getSelection
(
)
;
var
length
=
node
.
textContent
.
length
;
var
start
=
Math
.
min
(
offsets
.
start
length
)
;
var
end
=
offsets
.
end
=
=
=
undefined
?
start
:
Math
.
min
(
offsets
.
end
length
)
;
if
(
!
selection
.
extend
&
&
start
>
end
)
{
var
temp
=
end
;
end
=
start
;
start
=
temp
;
}
var
startMarker
=
getNodeForCharacterOffset
(
node
start
)
;
var
endMarker
=
getNodeForCharacterOffset
(
node
end
)
;
if
(
startMarker
&
&
endMarker
)
{
if
(
selection
.
rangeCount
=
=
=
1
&
&
selection
.
anchorNode
=
=
=
startMarker
.
node
&
&
selection
.
anchorOffset
=
=
=
startMarker
.
offset
&
&
selection
.
focusNode
=
=
=
endMarker
.
node
&
&
selection
.
focusOffset
=
=
=
endMarker
.
offset
)
{
return
;
}
var
range
=
doc
.
createRange
(
)
;
range
.
setStart
(
startMarker
.
node
startMarker
.
offset
)
;
selection
.
removeAllRanges
(
)
;
if
(
start
>
end
)
{
selection
.
addRange
(
range
)
;
selection
.
extend
(
endMarker
.
node
endMarker
.
offset
)
;
}
else
{
range
.
setEnd
(
endMarker
.
node
endMarker
.
offset
)
;
selection
.
addRange
(
range
)
;
}
}
}
function
isTextNode
(
node
)
{
return
node
&
&
node
.
nodeType
=
=
=
TEXT_NODE
;
}
function
containsNode
(
outerNode
innerNode
)
{
if
(
!
outerNode
|
|
!
innerNode
)
{
return
false
;
}
else
if
(
outerNode
=
=
=
innerNode
)
{
return
true
;
}
else
if
(
isTextNode
(
outerNode
)
)
{
return
false
;
}
else
if
(
isTextNode
(
innerNode
)
)
{
return
containsNode
(
outerNode
innerNode
.
parentNode
)
;
}
else
if
(
'
contains
'
in
outerNode
)
{
return
outerNode
.
contains
(
innerNode
)
;
}
else
if
(
outerNode
.
compareDocumentPosition
)
{
return
!
!
(
outerNode
.
compareDocumentPosition
(
innerNode
)
&
16
)
;
}
else
{
return
false
;
}
}
function
isInDocument
(
node
)
{
return
node
&
&
node
.
ownerDocument
&
&
containsNode
(
node
.
ownerDocument
.
documentElement
node
)
;
}
function
isSameOriginFrame
(
iframe
)
{
try
{
return
typeof
iframe
.
contentWindow
.
location
.
href
=
=
=
'
string
'
;
}
catch
(
err
)
{
return
false
;
}
}
function
getActiveElementDeep
(
)
{
var
win
=
window
;
var
element
=
getActiveElement
(
)
;
while
(
element
instanceof
win
.
HTMLIFrameElement
)
{
if
(
isSameOriginFrame
(
element
)
)
{
win
=
element
.
contentWindow
;
}
else
{
return
element
;
}
element
=
getActiveElement
(
win
.
document
)
;
}
return
element
;
}
function
hasSelectionCapabilities
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
&
&
(
nodeName
=
=
=
'
input
'
&
&
(
elem
.
type
=
=
=
'
text
'
|
|
elem
.
type
=
=
=
'
search
'
|
|
elem
.
type
=
=
=
'
tel
'
|
|
elem
.
type
=
=
=
'
url
'
|
|
elem
.
type
=
=
=
'
password
'
)
|
|
nodeName
=
=
=
'
textarea
'
|
|
elem
.
contentEditable
=
=
=
'
true
'
)
;
}
function
getSelectionInformation
(
)
{
var
focusedElem
=
getActiveElementDeep
(
)
;
return
{
focusedElem
:
focusedElem
selectionRange
:
hasSelectionCapabilities
(
focusedElem
)
?
getSelection
(
focusedElem
)
:
null
}
;
}
function
restoreSelection
(
priorSelectionInformation
)
{
var
curFocusedElem
=
getActiveElementDeep
(
)
;
var
priorFocusedElem
=
priorSelectionInformation
.
focusedElem
;
var
priorSelectionRange
=
priorSelectionInformation
.
selectionRange
;
if
(
curFocusedElem
!
=
=
priorFocusedElem
&
&
isInDocument
(
priorFocusedElem
)
)
{
if
(
priorSelectionRange
!
=
=
null
&
&
hasSelectionCapabilities
(
priorFocusedElem
)
)
{
setSelection
(
priorFocusedElem
priorSelectionRange
)
;
}
var
ancestors
=
[
]
;
var
ancestor
=
priorFocusedElem
;
while
(
ancestor
=
ancestor
.
parentNode
)
{
if
(
ancestor
.
nodeType
=
=
=
ELEMENT_NODE
)
{
ancestors
.
push
(
{
element
:
ancestor
left
:
ancestor
.
scrollLeft
top
:
ancestor
.
scrollTop
}
)
;
}
}
if
(
typeof
priorFocusedElem
.
focus
=
=
=
'
function
'
)
{
priorFocusedElem
.
focus
(
)
;
}
for
(
var
i
=
0
;
i
<
ancestors
.
length
;
i
+
+
)
{
var
info
=
ancestors
[
i
]
;
info
.
element
.
scrollLeft
=
info
.
left
;
info
.
element
.
scrollTop
=
info
.
top
;
}
}
}
function
getSelection
(
input
)
{
var
selection
;
if
(
'
selectionStart
'
in
input
)
{
selection
=
{
start
:
input
.
selectionStart
end
:
input
.
selectionEnd
}
;
}
else
{
selection
=
getOffsets
(
input
)
;
}
return
selection
|
|
{
start
:
0
end
:
0
}
;
}
function
setSelection
(
input
offsets
)
{
var
start
=
offsets
.
start
end
=
offsets
.
end
;
if
(
end
=
=
=
undefined
)
{
end
=
start
;
}
if
(
'
selectionStart
'
in
input
)
{
input
.
selectionStart
=
start
;
input
.
selectionEnd
=
Math
.
min
(
end
input
.
value
.
length
)
;
}
else
{
setOffsets
(
input
offsets
)
;
}
}
var
validateDOMNesting
=
function
(
)
{
}
;
var
updatedAncestorInfo
=
function
(
)
{
}
;
{
var
specialTags
=
[
'
address
'
'
applet
'
'
area
'
'
article
'
'
aside
'
'
base
'
'
basefont
'
'
bgsound
'
'
blockquote
'
'
body
'
'
br
'
'
button
'
'
caption
'
'
center
'
'
col
'
'
colgroup
'
'
dd
'
'
details
'
'
dir
'
'
div
'
'
dl
'
'
dt
'
'
embed
'
'
fieldset
'
'
figcaption
'
'
figure
'
'
footer
'
'
form
'
'
frame
'
'
frameset
'
'
h1
'
'
h2
'
'
h3
'
'
h4
'
'
h5
'
'
h6
'
'
head
'
'
header
'
'
hgroup
'
'
hr
'
'
html
'
'
iframe
'
'
img
'
'
input
'
'
isindex
'
'
li
'
'
link
'
'
listing
'
'
main
'
'
marquee
'
'
menu
'
'
menuitem
'
'
meta
'
'
nav
'
'
noembed
'
'
noframes
'
'
noscript
'
'
object
'
'
ol
'
'
p
'
'
param
'
'
plaintext
'
'
pre
'
'
script
'
'
section
'
'
select
'
'
source
'
'
style
'
'
summary
'
'
table
'
'
tbody
'
'
td
'
'
template
'
'
textarea
'
'
tfoot
'
'
th
'
'
thead
'
'
title
'
'
tr
'
'
track
'
'
ul
'
'
wbr
'
'
xmp
'
]
;
var
inScopeTags
=
[
'
applet
'
'
caption
'
'
html
'
'
table
'
'
td
'
'
th
'
'
marquee
'
'
object
'
'
template
'
'
foreignObject
'
'
desc
'
'
title
'
]
;
var
buttonScopeTags
=
inScopeTags
.
concat
(
[
'
button
'
]
)
;
var
impliedEndTags
=
[
'
dd
'
'
dt
'
'
li
'
'
option
'
'
optgroup
'
'
p
'
'
rp
'
'
rt
'
]
;
var
emptyAncestorInfo
=
{
current
:
null
formTag
:
null
aTagInScope
:
null
buttonTagInScope
:
null
nobrTagInScope
:
null
pTagInButtonScope
:
null
listItemTagAutoclosing
:
null
dlItemTagAutoclosing
:
null
}
;
updatedAncestorInfo
=
function
(
oldInfo
tag
)
{
var
ancestorInfo
=
_assign
(
{
}
oldInfo
|
|
emptyAncestorInfo
)
;
var
info
=
{
tag
:
tag
}
;
if
(
inScopeTags
.
indexOf
(
tag
)
!
=
=
-
1
)
{
ancestorInfo
.
aTagInScope
=
null
;
ancestorInfo
.
buttonTagInScope
=
null
;
ancestorInfo
.
nobrTagInScope
=
null
;
}
if
(
buttonScopeTags
.
indexOf
(
tag
)
!
=
=
-
1
)
{
ancestorInfo
.
pTagInButtonScope
=
null
;
}
if
(
specialTags
.
indexOf
(
tag
)
!
=
=
-
1
&
&
tag
!
=
=
'
address
'
&
&
tag
!
=
=
'
div
'
&
&
tag
!
=
=
'
p
'
)
{
ancestorInfo
.
listItemTagAutoclosing
=
null
;
ancestorInfo
.
dlItemTagAutoclosing
=
null
;
}
ancestorInfo
.
current
=
info
;
if
(
tag
=
=
=
'
form
'
)
{
ancestorInfo
.
formTag
=
info
;
}
if
(
tag
=
=
=
'
a
'
)
{
ancestorInfo
.
aTagInScope
=
info
;
}
if
(
tag
=
=
=
'
button
'
)
{
ancestorInfo
.
buttonTagInScope
=
info
;
}
if
(
tag
=
=
=
'
nobr
'
)
{
ancestorInfo
.
nobrTagInScope
=
info
;
}
if
(
tag
=
=
=
'
p
'
)
{
ancestorInfo
.
pTagInButtonScope
=
info
;
}
if
(
tag
=
=
=
'
li
'
)
{
ancestorInfo
.
listItemTagAutoclosing
=
info
;
}
if
(
tag
=
=
=
'
dd
'
|
|
tag
=
=
=
'
dt
'
)
{
ancestorInfo
.
dlItemTagAutoclosing
=
info
;
}
return
ancestorInfo
;
}
;
var
isTagValidWithParent
=
function
(
tag
parentTag
)
{
switch
(
parentTag
)
{
case
'
select
'
:
return
tag
=
=
=
'
option
'
|
|
tag
=
=
=
'
optgroup
'
|
|
tag
=
=
=
'
#
text
'
;
case
'
optgroup
'
:
return
tag
=
=
=
'
option
'
|
|
tag
=
=
=
'
#
text
'
;
case
'
option
'
:
return
tag
=
=
=
'
#
text
'
;
case
'
tr
'
:
return
tag
=
=
=
'
th
'
|
|
tag
=
=
=
'
td
'
|
|
tag
=
=
=
'
style
'
|
|
tag
=
=
=
'
script
'
|
|
tag
=
=
=
'
template
'
;
case
'
tbody
'
:
case
'
thead
'
:
case
'
tfoot
'
:
return
tag
=
=
=
'
tr
'
|
|
tag
=
=
=
'
style
'
|
|
tag
=
=
=
'
script
'
|
|
tag
=
=
=
'
template
'
;
case
'
colgroup
'
:
return
tag
=
=
=
'
col
'
|
|
tag
=
=
=
'
template
'
;
case
'
table
'
:
return
tag
=
=
=
'
caption
'
|
|
tag
=
=
=
'
colgroup
'
|
|
tag
=
=
=
'
tbody
'
|
|
tag
=
=
=
'
tfoot
'
|
|
tag
=
=
=
'
thead
'
|
|
tag
=
=
=
'
style
'
|
|
tag
=
=
=
'
script
'
|
|
tag
=
=
=
'
template
'
;
case
'
head
'
:
return
tag
=
=
=
'
base
'
|
|
tag
=
=
=
'
basefont
'
|
|
tag
=
=
=
'
bgsound
'
|
|
tag
=
=
=
'
link
'
|
|
tag
=
=
=
'
meta
'
|
|
tag
=
=
=
'
title
'
|
|
tag
=
=
=
'
noscript
'
|
|
tag
=
=
=
'
noframes
'
|
|
tag
=
=
=
'
style
'
|
|
tag
=
=
=
'
script
'
|
|
tag
=
=
=
'
template
'
;
case
'
html
'
:
return
tag
=
=
=
'
head
'
|
|
tag
=
=
=
'
body
'
|
|
tag
=
=
=
'
frameset
'
;
case
'
frameset
'
:
return
tag
=
=
=
'
frame
'
;
case
'
#
document
'
:
return
tag
=
=
=
'
html
'
;
}
switch
(
tag
)
{
case
'
h1
'
:
case
'
h2
'
:
case
'
h3
'
:
case
'
h4
'
:
case
'
h5
'
:
case
'
h6
'
:
return
parentTag
!
=
=
'
h1
'
&
&
parentTag
!
=
=
'
h2
'
&
&
parentTag
!
=
=
'
h3
'
&
&
parentTag
!
=
=
'
h4
'
&
&
parentTag
!
=
=
'
h5
'
&
&
parentTag
!
=
=
'
h6
'
;
case
'
rp
'
:
case
'
rt
'
:
return
impliedEndTags
.
indexOf
(
parentTag
)
=
=
=
-
1
;
case
'
body
'
:
case
'
caption
'
:
case
'
col
'
:
case
'
colgroup
'
:
case
'
frameset
'
:
case
'
frame
'
:
case
'
head
'
:
case
'
html
'
:
case
'
tbody
'
:
case
'
td
'
:
case
'
tfoot
'
:
case
'
th
'
:
case
'
thead
'
:
case
'
tr
'
:
return
parentTag
=
=
null
;
}
return
true
;
}
;
var
findInvalidAncestorForTag
=
function
(
tag
ancestorInfo
)
{
switch
(
tag
)
{
case
'
address
'
:
case
'
article
'
:
case
'
aside
'
:
case
'
blockquote
'
:
case
'
center
'
:
case
'
details
'
:
case
'
dialog
'
:
case
'
dir
'
:
case
'
div
'
:
case
'
dl
'
:
case
'
fieldset
'
:
case
'
figcaption
'
:
case
'
figure
'
:
case
'
footer
'
:
case
'
header
'
:
case
'
hgroup
'
:
case
'
main
'
:
case
'
menu
'
:
case
'
nav
'
:
case
'
ol
'
:
case
'
p
'
:
case
'
section
'
:
case
'
summary
'
:
case
'
ul
'
:
case
'
pre
'
:
case
'
listing
'
:
case
'
table
'
:
case
'
hr
'
:
case
'
xmp
'
:
case
'
h1
'
:
case
'
h2
'
:
case
'
h3
'
:
case
'
h4
'
:
case
'
h5
'
:
case
'
h6
'
:
return
ancestorInfo
.
pTagInButtonScope
;
case
'
form
'
:
return
ancestorInfo
.
formTag
|
|
ancestorInfo
.
pTagInButtonScope
;
case
'
li
'
:
return
ancestorInfo
.
listItemTagAutoclosing
;
case
'
dd
'
:
case
'
dt
'
:
return
ancestorInfo
.
dlItemTagAutoclosing
;
case
'
button
'
:
return
ancestorInfo
.
buttonTagInScope
;
case
'
a
'
:
return
ancestorInfo
.
aTagInScope
;
case
'
nobr
'
:
return
ancestorInfo
.
nobrTagInScope
;
}
return
null
;
}
;
var
didWarn
1
=
{
}
;
validateDOMNesting
=
function
(
childTag
childText
ancestorInfo
)
{
ancestorInfo
=
ancestorInfo
|
|
emptyAncestorInfo
;
var
parentInfo
=
ancestorInfo
.
current
;
var
parentTag
=
parentInfo
&
&
parentInfo
.
tag
;
if
(
childText
!
=
null
)
{
!
(
childTag
=
=
null
)
?
warningWithoutStack
1
(
false
'
validateDOMNesting
:
when
childText
is
passed
childTag
should
be
null
'
)
:
void
0
;
childTag
=
'
#
text
'
;
}
var
invalidParent
=
isTagValidWithParent
(
childTag
parentTag
)
?
null
:
parentInfo
;
var
invalidAncestor
=
invalidParent
?
null
:
findInvalidAncestorForTag
(
childTag
ancestorInfo
)
;
var
invalidParentOrAncestor
=
invalidParent
|
|
invalidAncestor
;
if
(
!
invalidParentOrAncestor
)
{
return
;
}
var
ancestorTag
=
invalidParentOrAncestor
.
tag
;
var
addendum
=
getCurrentFiberStackInDev
(
)
;
var
warnKey
=
!
!
invalidParent
+
'
|
'
+
childTag
+
'
|
'
+
ancestorTag
+
'
|
'
+
addendum
;
if
(
didWarn
1
[
warnKey
]
)
{
return
;
}
didWarn
1
[
warnKey
]
=
true
;
var
tagDisplayName
=
childTag
;
var
whitespaceInfo
=
'
'
;
if
(
childTag
=
=
=
'
#
text
'
)
{
if
(
/
\
S
/
.
test
(
childText
)
)
{
tagDisplayName
=
'
Text
nodes
'
;
}
else
{
tagDisplayName
=
'
Whitespace
text
nodes
'
;
whitespaceInfo
=
"
Make
sure
you
don
'
t
have
any
extra
whitespace
between
tags
on
"
+
'
each
line
of
your
source
code
.
'
;
}
}
else
{
tagDisplayName
=
'
<
'
+
childTag
+
'
>
'
;
}
if
(
invalidParent
)
{
var
info
=
'
'
;
if
(
ancestorTag
=
=
=
'
table
'
&
&
childTag
=
=
=
'
tr
'
)
{
info
+
=
'
Add
a
<
tbody
>
<
thead
>
or
<
tfoot
>
to
your
code
to
match
the
DOM
tree
generated
by
'
+
'
the
browser
.
'
;
}
warningWithoutStack
1
(
false
'
validateDOMNesting
(
.
.
.
)
:
%
s
cannot
appear
as
a
child
of
<
%
s
>
.
%
s
%
s
%
s
'
tagDisplayName
ancestorTag
whitespaceInfo
info
addendum
)
;
}
else
{
warningWithoutStack
1
(
false
'
validateDOMNesting
(
.
.
.
)
:
%
s
cannot
appear
as
a
descendant
of
'
+
'
<
%
s
>
.
%
s
'
tagDisplayName
ancestorTag
addendum
)
;
}
}
;
}
function
shim
(
)
{
{
{
throw
Error
(
"
The
current
renderer
does
not
support
persistence
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
var
supportsPersistence
=
false
;
var
cloneInstance
=
shim
;
var
cloneFundamentalInstance
=
shim
;
var
createContainerChildSet
=
shim
;
var
appendChildToContainerChildSet
=
shim
;
var
finalizeContainerChildren
=
shim
;
var
replaceContainerChildren
=
shim
;
var
cloneHiddenInstance
=
shim
;
var
cloneHiddenTextInstance
=
shim
;
var
SUPPRESS_HYDRATION_WARNING
;
{
SUPPRESS_HYDRATION_WARNING
=
'
suppressHydrationWarning
'
;
}
var
SUSPENSE_START_DATA
=
'
'
;
var
SUSPENSE_END_DATA
=
'
/
'
;
var
SUSPENSE_PENDING_START_DATA
=
'
?
'
;
var
SUSPENSE_FALLBACK_START_DATA
=
'
!
'
;
var
STYLE
=
'
style
'
;
var
eventsEnabled
=
null
;
var
selectionInformation
=
null
;
function
shouldAutoFocusHostComponent
(
type
props
)
{
switch
(
type
)
{
case
'
button
'
:
case
'
input
'
:
case
'
select
'
:
case
'
textarea
'
:
return
!
!
props
.
autoFocus
;
}
return
false
;
}
function
getRootHostContext
(
rootContainerInstance
)
{
var
type
;
var
namespace
;
var
nodeType
=
rootContainerInstance
.
nodeType
;
switch
(
nodeType
)
{
case
DOCUMENT_NODE
:
case
DOCUMENT_FRAGMENT_NODE
:
{
type
=
nodeType
=
=
=
DOCUMENT_NODE
?
'
#
document
'
:
'
#
fragment
'
;
var
root
=
rootContainerInstance
.
documentElement
;
namespace
=
root
?
root
.
namespaceURI
:
getChildNamespace
(
null
'
'
)
;
break
;
}
default
:
{
var
container
=
nodeType
=
=
=
COMMENT_NODE
?
rootContainerInstance
.
parentNode
:
rootContainerInstance
;
var
ownNamespace
=
container
.
namespaceURI
|
|
null
;
type
=
container
.
tagName
;
namespace
=
getChildNamespace
(
ownNamespace
type
)
;
break
;
}
}
{
var
validatedTag
=
type
.
toLowerCase
(
)
;
var
ancestorInfo
=
updatedAncestorInfo
(
null
validatedTag
)
;
return
{
namespace
:
namespace
ancestorInfo
:
ancestorInfo
}
;
}
return
namespace
;
}
function
getChildHostContext
(
parentHostContext
type
rootContainerInstance
)
{
{
var
parentHostContextDev
=
parentHostContext
;
var
namespace
=
getChildNamespace
(
parentHostContextDev
.
namespace
type
)
;
var
ancestorInfo
=
updatedAncestorInfo
(
parentHostContextDev
.
ancestorInfo
type
)
;
return
{
namespace
:
namespace
ancestorInfo
:
ancestorInfo
}
;
}
var
parentNamespace
=
parentHostContext
;
return
getChildNamespace
(
parentNamespace
type
)
;
}
function
getPublicInstance
(
instance
)
{
return
instance
;
}
function
prepareForCommit
(
containerInfo
)
{
eventsEnabled
=
isEnabled
(
)
;
selectionInformation
=
getSelectionInformation
(
)
;
setEnabled
(
false
)
;
}
function
resetAfterCommit
(
containerInfo
)
{
restoreSelection
(
selectionInformation
)
;
selectionInformation
=
null
;
setEnabled
(
eventsEnabled
)
;
eventsEnabled
=
null
;
}
function
createInstance
(
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
var
parentNamespace
;
{
var
hostContextDev
=
hostContext
;
validateDOMNesting
(
type
null
hostContextDev
.
ancestorInfo
)
;
if
(
typeof
props
.
children
=
=
=
'
string
'
|
|
typeof
props
.
children
=
=
=
'
number
'
)
{
var
string
=
'
'
+
props
.
children
;
var
ownAncestorInfo
=
updatedAncestorInfo
(
hostContextDev
.
ancestorInfo
type
)
;
validateDOMNesting
(
null
string
ownAncestorInfo
)
;
}
parentNamespace
=
hostContextDev
.
namespace
;
}
var
domElement
=
createElement
(
type
props
rootContainerInstance
parentNamespace
)
;
precacheFiberNode
(
internalInstanceHandle
domElement
)
;
updateFiberProps
(
domElement
props
)
;
return
domElement
;
}
function
appendInitialChild
(
parentInstance
child
)
{
parentInstance
.
appendChild
(
child
)
;
}
function
finalizeInitialChildren
(
domElement
type
props
rootContainerInstance
hostContext
)
{
setInitialProperties
(
domElement
type
props
rootContainerInstance
)
;
return
shouldAutoFocusHostComponent
(
type
props
)
;
}
function
prepareUpdate
(
domElement
type
oldProps
newProps
rootContainerInstance
hostContext
)
{
{
var
hostContextDev
=
hostContext
;
if
(
typeof
newProps
.
children
!
=
=
typeof
oldProps
.
children
&
&
(
typeof
newProps
.
children
=
=
=
'
string
'
|
|
typeof
newProps
.
children
=
=
=
'
number
'
)
)
{
var
string
=
'
'
+
newProps
.
children
;
var
ownAncestorInfo
=
updatedAncestorInfo
(
hostContextDev
.
ancestorInfo
type
)
;
validateDOMNesting
(
null
string
ownAncestorInfo
)
;
}
}
return
diffProperties
(
domElement
type
oldProps
newProps
rootContainerInstance
)
;
}
function
shouldSetTextContent
(
type
props
)
{
return
type
=
=
=
'
textarea
'
|
|
type
=
=
=
'
option
'
|
|
type
=
=
=
'
noscript
'
|
|
typeof
props
.
children
=
=
=
'
string
'
|
|
typeof
props
.
children
=
=
=
'
number
'
|
|
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
props
.
dangerouslySetInnerHTML
!
=
=
null
&
&
props
.
dangerouslySetInnerHTML
.
__html
!
=
null
;
}
function
shouldDeprioritizeSubtree
(
type
props
)
{
return
!
!
props
.
hidden
;
}
function
createTextInstance
(
text
rootContainerInstance
hostContext
internalInstanceHandle
)
{
{
var
hostContextDev
=
hostContext
;
validateDOMNesting
(
null
text
hostContextDev
.
ancestorInfo
)
;
}
var
textNode
=
createTextNode
(
text
rootContainerInstance
)
;
precacheFiberNode
(
internalInstanceHandle
textNode
)
;
return
textNode
;
}
var
isPrimaryRenderer
=
true
;
var
warnsIfNotActing
=
true
;
var
scheduleTimeout
=
typeof
setTimeout
=
=
=
'
function
'
?
setTimeout
:
undefined
;
var
cancelTimeout
=
typeof
clearTimeout
=
=
=
'
function
'
?
clearTimeout
:
undefined
;
var
noTimeout
=
-
1
;
var
supportsMutation
=
true
;
function
commitMount
(
domElement
type
newProps
internalInstanceHandle
)
{
if
(
shouldAutoFocusHostComponent
(
type
newProps
)
)
{
domElement
.
focus
(
)
;
}
}
function
commitUpdate
(
domElement
updatePayload
type
oldProps
newProps
internalInstanceHandle
)
{
updateFiberProps
(
domElement
newProps
)
;
updateProperties
(
domElement
updatePayload
type
oldProps
newProps
)
;
}
function
resetTextContent
(
domElement
)
{
setTextContent
(
domElement
'
'
)
;
}
function
commitTextUpdate
(
textInstance
oldText
newText
)
{
textInstance
.
nodeValue
=
newText
;
}
function
appendChild
(
parentInstance
child
)
{
parentInstance
.
appendChild
(
child
)
;
}
function
appendChildToContainer
(
container
child
)
{
var
parentNode
;
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
parentNode
=
container
.
parentNode
;
parentNode
.
insertBefore
(
child
container
)
;
}
else
{
parentNode
=
container
;
parentNode
.
appendChild
(
child
)
;
}
var
reactRootContainer
=
container
.
_reactRootContainer
;
if
(
(
reactRootContainer
=
=
=
null
|
|
reactRootContainer
=
=
=
undefined
)
&
&
parentNode
.
onclick
=
=
=
null
)
{
trapClickOnNonInteractiveElement
(
parentNode
)
;
}
}
function
insertBefore
(
parentInstance
child
beforeChild
)
{
parentInstance
.
insertBefore
(
child
beforeChild
)
;
}
function
insertInContainerBefore
(
container
child
beforeChild
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
insertBefore
(
child
beforeChild
)
;
}
else
{
container
.
insertBefore
(
child
beforeChild
)
;
}
}
function
dispatchDetachedVisibleNodeEvent
(
child
)
{
if
(
enableFlareAPI
&
&
selectionInformation
&
&
child
=
=
=
selectionInformation
.
focusedElem
)
{
var
targetFiber
=
getClosestInstanceFromNode
(
child
)
;
dispatchEventForResponderEventSystem
(
'
detachedvisiblenode
'
targetFiber
{
target
:
child
timeStamp
:
Date
.
now
(
)
}
child
RESPONDER_EVENT_SYSTEM
|
IS_PASSIVE
)
;
}
}
function
removeChild
(
parentInstance
child
)
{
dispatchDetachedVisibleNodeEvent
(
child
)
;
parentInstance
.
removeChild
(
child
)
;
}
function
removeChildFromContainer
(
container
child
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
removeChild
(
child
)
;
}
else
{
dispatchDetachedVisibleNodeEvent
(
child
)
;
container
.
removeChild
(
child
)
;
}
}
function
clearSuspenseBoundary
(
parentInstance
suspenseInstance
)
{
var
node
=
suspenseInstance
;
var
depth
=
0
;
do
{
var
nextNode
=
node
.
nextSibling
;
parentInstance
.
removeChild
(
node
)
;
if
(
nextNode
&
&
nextNode
.
nodeType
=
=
=
COMMENT_NODE
)
{
var
data
=
nextNode
.
data
;
if
(
data
=
=
=
SUSPENSE_END_DATA
)
{
if
(
depth
=
=
=
0
)
{
parentInstance
.
removeChild
(
nextNode
)
;
retryIfBlockedOn
(
suspenseInstance
)
;
return
;
}
else
{
depth
-
-
;
}
}
else
if
(
data
=
=
=
SUSPENSE_START_DATA
|
|
data
=
=
=
SUSPENSE_PENDING_START_DATA
|
|
data
=
=
=
SUSPENSE_FALLBACK_START_DATA
)
{
depth
+
+
;
}
}
node
=
nextNode
;
}
while
(
node
)
;
retryIfBlockedOn
(
suspenseInstance
)
;
}
function
clearSuspenseBoundaryFromContainer
(
container
suspenseInstance
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
clearSuspenseBoundary
(
container
.
parentNode
suspenseInstance
)
;
}
else
if
(
container
.
nodeType
=
=
=
ELEMENT_NODE
)
{
clearSuspenseBoundary
(
container
suspenseInstance
)
;
}
else
{
}
retryIfBlockedOn
(
container
)
;
}
function
hideInstance
(
instance
)
{
instance
=
instance
;
var
style
=
instance
.
style
;
if
(
typeof
style
.
setProperty
=
=
=
'
function
'
)
{
style
.
setProperty
(
'
display
'
'
none
'
'
important
'
)
;
}
else
{
style
.
display
=
'
none
'
;
}
}
function
hideTextInstance
(
textInstance
)
{
textInstance
.
nodeValue
=
'
'
;
}
function
unhideInstance
(
instance
props
)
{
instance
=
instance
;
var
styleProp
=
props
[
STYLE
]
;
var
display
=
styleProp
!
=
=
undefined
&
&
styleProp
!
=
=
null
&
&
styleProp
.
hasOwnProperty
(
'
display
'
)
?
styleProp
.
display
:
null
;
instance
.
style
.
display
=
dangerousStyleValue
(
'
display
'
display
)
;
}
function
unhideTextInstance
(
textInstance
text
)
{
textInstance
.
nodeValue
=
text
;
}
var
supportsHydration
=
true
;
function
canHydrateInstance
(
instance
type
props
)
{
if
(
instance
.
nodeType
!
=
=
ELEMENT_NODE
|
|
type
.
toLowerCase
(
)
!
=
=
instance
.
nodeName
.
toLowerCase
(
)
)
{
return
null
;
}
return
instance
;
}
function
canHydrateTextInstance
(
instance
text
)
{
if
(
text
=
=
=
'
'
|
|
instance
.
nodeType
!
=
=
TEXT_NODE
)
{
return
null
;
}
return
instance
;
}
function
canHydrateSuspenseInstance
(
instance
)
{
if
(
instance
.
nodeType
!
=
=
COMMENT_NODE
)
{
return
null
;
}
return
instance
;
}
function
isSuspenseInstancePending
(
instance
)
{
return
instance
.
data
=
=
=
SUSPENSE_PENDING_START_DATA
;
}
function
isSuspenseInstanceFallback
(
instance
)
{
return
instance
.
data
=
=
=
SUSPENSE_FALLBACK_START_DATA
;
}
function
registerSuspenseInstanceRetry
(
instance
callback
)
{
instance
.
_reactRetry
=
callback
;
}
function
getNextHydratable
(
node
)
{
for
(
;
node
!
=
null
;
node
=
node
.
nextSibling
)
{
var
nodeType
=
node
.
nodeType
;
if
(
nodeType
=
=
=
ELEMENT_NODE
|
|
nodeType
=
=
=
TEXT_NODE
)
{
break
;
}
if
(
enableSuspenseServerRenderer
)
{
if
(
nodeType
=
=
=
COMMENT_NODE
)
{
var
nodeData
=
node
.
data
;
if
(
nodeData
=
=
=
SUSPENSE_START_DATA
|
|
nodeData
=
=
=
SUSPENSE_FALLBACK_START_DATA
|
|
nodeData
=
=
=
SUSPENSE_PENDING_START_DATA
)
{
break
;
}
}
}
}
return
node
;
}
function
getNextHydratableSibling
(
instance
)
{
return
getNextHydratable
(
instance
.
nextSibling
)
;
}
function
getFirstHydratableChild
(
parentInstance
)
{
return
getNextHydratable
(
parentInstance
.
firstChild
)
;
}
function
hydrateInstance
(
instance
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
precacheFiberNode
(
internalInstanceHandle
instance
)
;
updateFiberProps
(
instance
props
)
;
var
parentNamespace
;
{
var
hostContextDev
=
hostContext
;
parentNamespace
=
hostContextDev
.
namespace
;
}
return
diffHydratedProperties
(
instance
type
props
parentNamespace
rootContainerInstance
)
;
}
function
hydrateTextInstance
(
textInstance
text
internalInstanceHandle
)
{
precacheFiberNode
(
internalInstanceHandle
textInstance
)
;
return
diffHydratedText
(
textInstance
text
)
;
}
function
hydrateSuspenseInstance
(
suspenseInstance
internalInstanceHandle
)
{
precacheFiberNode
(
internalInstanceHandle
suspenseInstance
)
;
}
function
getNextHydratableInstanceAfterSuspenseInstance
(
suspenseInstance
)
{
var
node
=
suspenseInstance
.
nextSibling
;
var
depth
=
0
;
while
(
node
)
{
if
(
node
.
nodeType
=
=
=
COMMENT_NODE
)
{
var
data
=
node
.
data
;
if
(
data
=
=
=
SUSPENSE_END_DATA
)
{
if
(
depth
=
=
=
0
)
{
return
getNextHydratableSibling
(
node
)
;
}
else
{
depth
-
-
;
}
}
else
if
(
data
=
=
=
SUSPENSE_START_DATA
|
|
data
=
=
=
SUSPENSE_FALLBACK_START_DATA
|
|
data
=
=
=
SUSPENSE_PENDING_START_DATA
)
{
depth
+
+
;
}
}
node
=
node
.
nextSibling
;
}
return
null
;
}
function
getParentSuspenseInstance
(
targetInstance
)
{
var
node
=
targetInstance
.
previousSibling
;
var
depth
=
0
;
while
(
node
)
{
if
(
node
.
nodeType
=
=
=
COMMENT_NODE
)
{
var
data
=
node
.
data
;
if
(
data
=
=
=
SUSPENSE_START_DATA
|
|
data
=
=
=
SUSPENSE_FALLBACK_START_DATA
|
|
data
=
=
=
SUSPENSE_PENDING_START_DATA
)
{
if
(
depth
=
=
=
0
)
{
return
node
;
}
else
{
depth
-
-
;
}
}
else
if
(
data
=
=
=
SUSPENSE_END_DATA
)
{
depth
+
+
;
}
}
node
=
node
.
previousSibling
;
}
return
null
;
}
function
commitHydratedContainer
(
container
)
{
retryIfBlockedOn
(
container
)
;
}
function
commitHydratedSuspenseInstance
(
suspenseInstance
)
{
retryIfBlockedOn
(
suspenseInstance
)
;
}
function
didNotMatchHydratedContainerTextInstance
(
parentContainer
textInstance
text
)
{
{
warnForUnmatchedText
(
textInstance
text
)
;
}
}
function
didNotMatchHydratedTextInstance
(
parentType
parentProps
parentInstance
textInstance
text
)
{
if
(
true
&
&
parentProps
[
SUPPRESS_HYDRATION_WARNING
]
!
=
=
true
)
{
warnForUnmatchedText
(
textInstance
text
)
;
}
}
function
didNotHydrateContainerInstance
(
parentContainer
instance
)
{
{
if
(
instance
.
nodeType
=
=
=
ELEMENT_NODE
)
{
warnForDeletedHydratableElement
(
parentContainer
instance
)
;
}
else
if
(
instance
.
nodeType
=
=
=
COMMENT_NODE
)
{
}
else
{
warnForDeletedHydratableText
(
parentContainer
instance
)
;
}
}
}
function
didNotHydrateInstance
(
parentType
parentProps
parentInstance
instance
)
{
if
(
true
&
&
parentProps
[
SUPPRESS_HYDRATION_WARNING
]
!
=
=
true
)
{
if
(
instance
.
nodeType
=
=
=
ELEMENT_NODE
)
{
warnForDeletedHydratableElement
(
parentInstance
instance
)
;
}
else
if
(
instance
.
nodeType
=
=
=
COMMENT_NODE
)
{
}
else
{
warnForDeletedHydratableText
(
parentInstance
instance
)
;
}
}
}
function
didNotFindHydratableContainerInstance
(
parentContainer
type
props
)
{
{
warnForInsertedHydratedElement
(
parentContainer
type
props
)
;
}
}
function
didNotFindHydratableContainerTextInstance
(
parentContainer
text
)
{
{
warnForInsertedHydratedText
(
parentContainer
text
)
;
}
}
function
didNotFindHydratableInstance
(
parentType
parentProps
parentInstance
type
props
)
{
if
(
true
&
&
parentProps
[
SUPPRESS_HYDRATION_WARNING
]
!
=
=
true
)
{
warnForInsertedHydratedElement
(
parentInstance
type
props
)
;
}
}
function
didNotFindHydratableTextInstance
(
parentType
parentProps
parentInstance
text
)
{
if
(
true
&
&
parentProps
[
SUPPRESS_HYDRATION_WARNING
]
!
=
=
true
)
{
warnForInsertedHydratedText
(
parentInstance
text
)
;
}
}
function
didNotFindHydratableSuspenseInstance
(
parentType
parentProps
parentInstance
)
{
if
(
true
&
&
parentProps
[
SUPPRESS_HYDRATION_WARNING
]
!
=
=
true
)
{
}
}
function
mountResponderInstance
(
responder
responderInstance
responderProps
responderState
instance
)
{
var
doc
=
instance
.
ownerDocument
;
var
_ref
=
responder
rootEventTypes
=
_ref
.
rootEventTypes
targetEventTypes
=
_ref
.
targetEventTypes
;
if
(
targetEventTypes
!
=
=
null
)
{
listenToEventResponderEventTypes
(
targetEventTypes
doc
)
;
}
if
(
rootEventTypes
!
=
=
null
)
{
addRootEventTypesForResponderInstance
(
responderInstance
rootEventTypes
)
;
listenToEventResponderEventTypes
(
rootEventTypes
doc
)
;
}
mountEventResponder
(
responder
responderInstance
responderProps
responderState
)
;
return
responderInstance
;
}
function
unmountResponderInstance
(
responderInstance
)
{
if
(
enableFlareAPI
)
{
unmountEventResponder
(
responderInstance
)
;
}
}
function
getFundamentalComponentInstance
(
fundamentalInstance
)
{
if
(
enableFundamentalAPI
)
{
var
currentFiber
=
fundamentalInstance
.
currentFiber
impl
=
fundamentalInstance
.
impl
props
=
fundamentalInstance
.
props
state
=
fundamentalInstance
.
state
;
var
instance
=
impl
.
getInstance
(
null
props
state
)
;
precacheFiberNode
(
currentFiber
instance
)
;
return
instance
;
}
return
null
;
}
function
mountFundamentalComponent
(
fundamentalInstance
)
{
if
(
enableFundamentalAPI
)
{
var
impl
=
fundamentalInstance
.
impl
instance
=
fundamentalInstance
.
instance
props
=
fundamentalInstance
.
props
state
=
fundamentalInstance
.
state
;
var
onMount
=
impl
.
onMount
;
if
(
onMount
!
=
=
undefined
)
{
onMount
(
null
instance
props
state
)
;
}
}
}
function
shouldUpdateFundamentalComponent
(
fundamentalInstance
)
{
if
(
enableFundamentalAPI
)
{
var
impl
=
fundamentalInstance
.
impl
prevProps
=
fundamentalInstance
.
prevProps
props
=
fundamentalInstance
.
props
state
=
fundamentalInstance
.
state
;
var
shouldUpdate
=
impl
.
shouldUpdate
;
if
(
shouldUpdate
!
=
=
undefined
)
{
return
shouldUpdate
(
null
prevProps
props
state
)
;
}
}
return
true
;
}
function
updateFundamentalComponent
(
fundamentalInstance
)
{
if
(
enableFundamentalAPI
)
{
var
impl
=
fundamentalInstance
.
impl
instance
=
fundamentalInstance
.
instance
prevProps
=
fundamentalInstance
.
prevProps
props
=
fundamentalInstance
.
props
state
=
fundamentalInstance
.
state
;
var
onUpdate
=
impl
.
onUpdate
;
if
(
onUpdate
!
=
=
undefined
)
{
onUpdate
(
null
instance
prevProps
props
state
)
;
}
}
}
function
unmountFundamentalComponent
(
fundamentalInstance
)
{
if
(
enableFundamentalAPI
)
{
var
impl
=
fundamentalInstance
.
impl
instance
=
fundamentalInstance
.
instance
props
=
fundamentalInstance
.
props
state
=
fundamentalInstance
.
state
;
var
onUnmount
=
impl
.
onUnmount
;
if
(
onUnmount
!
=
=
undefined
)
{
onUnmount
(
null
instance
props
state
)
;
}
}
}
function
getInstanceFromNode
2
(
node
)
{
return
getClosestInstanceFromNode
(
node
)
|
|
null
;
}
var
randomKey
=
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
var
internalInstanceKey
=
'
__reactInternalInstance
'
+
randomKey
;
var
internalEventHandlersKey
=
'
__reactEventHandlers
'
+
randomKey
;
var
internalContainerInstanceKey
=
'
__reactContainere
'
+
randomKey
;
function
precacheFiberNode
(
hostInst
node
)
{
node
[
internalInstanceKey
]
=
hostInst
;
}
function
markContainerAsRoot
(
hostRoot
node
)
{
node
[
internalContainerInstanceKey
]
=
hostRoot
;
}
function
unmarkContainerAsRoot
(
node
)
{
node
[
internalContainerInstanceKey
]
=
null
;
}
function
isContainerMarkedAsRoot
(
node
)
{
return
!
!
node
[
internalContainerInstanceKey
]
;
}
function
getClosestInstanceFromNode
(
targetNode
)
{
var
targetInst
=
targetNode
[
internalInstanceKey
]
;
if
(
targetInst
)
{
return
targetInst
;
}
var
parentNode
=
targetNode
.
parentNode
;
while
(
parentNode
)
{
targetInst
=
parentNode
[
internalContainerInstanceKey
]
|
|
parentNode
[
internalInstanceKey
]
;
if
(
targetInst
)
{
var
alternate
=
targetInst
.
alternate
;
if
(
targetInst
.
child
!
=
=
null
|
|
alternate
!
=
=
null
&
&
alternate
.
child
!
=
=
null
)
{
var
suspenseInstance
=
getParentSuspenseInstance
(
targetNode
)
;
while
(
suspenseInstance
!
=
=
null
)
{
var
targetSuspenseInst
=
suspenseInstance
[
internalInstanceKey
]
;
if
(
targetSuspenseInst
)
{
return
targetSuspenseInst
;
}
suspenseInstance
=
getParentSuspenseInstance
(
suspenseInstance
)
;
}
}
return
targetInst
;
}
targetNode
=
parentNode
;
parentNode
=
targetNode
.
parentNode
;
}
return
null
;
}
function
getInstanceFromNode
1
(
node
)
{
var
inst
=
node
[
internalInstanceKey
]
|
|
node
[
internalContainerInstanceKey
]
;
if
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
|
|
inst
.
tag
=
=
=
SuspenseComponent
|
|
inst
.
tag
=
=
=
HostRoot
)
{
return
inst
;
}
else
{
return
null
;
}
}
return
null
;
}
function
getNodeFromInstance
1
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
.
stateNode
;
}
{
{
throw
Error
(
"
getNodeFromInstance
:
Invalid
argument
.
"
)
;
}
}
}
function
getFiberCurrentPropsFromNode
1
(
node
)
{
return
node
[
internalEventHandlersKey
]
|
|
null
;
}
function
updateFiberProps
(
node
props
)
{
node
[
internalEventHandlersKey
]
=
props
;
}
var
root
=
null
;
var
startText
=
null
;
var
fallbackText
=
null
;
function
initialize
(
nativeEventTarget
)
{
root
=
nativeEventTarget
;
startText
=
getText
(
)
;
return
true
;
}
function
reset
(
)
{
root
=
null
;
startText
=
null
;
fallbackText
=
null
;
}
function
getData
(
)
{
if
(
fallbackText
)
{
return
fallbackText
;
}
var
start
;
var
startValue
=
startText
;
var
startLength
=
startValue
.
length
;
var
end
;
var
endValue
=
getText
(
)
;
var
endLength
=
endValue
.
length
;
for
(
start
=
0
;
start
<
startLength
;
start
+
+
)
{
if
(
startValue
[
start
]
!
=
=
endValue
[
start
]
)
{
break
;
}
}
var
minEnd
=
startLength
-
start
;
for
(
end
=
1
;
end
<
=
minEnd
;
end
+
+
)
{
if
(
startValue
[
startLength
-
end
]
!
=
=
endValue
[
endLength
-
end
]
)
{
break
;
}
}
var
sliceTail
=
end
>
1
?
1
-
end
:
undefined
;
fallbackText
=
endValue
.
slice
(
start
sliceTail
)
;
return
fallbackText
;
}
function
getText
(
)
{
if
(
'
value
'
in
root
)
{
return
root
.
value
;
}
return
root
.
textContent
;
}
var
SyntheticCompositionEvent
=
SyntheticEvent
.
extend
(
{
data
:
null
}
)
;
var
SyntheticInputEvent
=
SyntheticEvent
.
extend
(
{
data
:
null
}
)
;
var
END_KEYCODES
=
[
9
13
27
32
]
;
var
START_KEYCODE
=
229
;
var
canUseCompositionEvent
=
canUseDOM
&
&
'
CompositionEvent
'
in
window
;
var
documentMode
=
null
;
if
(
canUseDOM
&
&
'
documentMode
'
in
document
)
{
documentMode
=
document
.
documentMode
;
}
var
canUseTextInputEvent
=
canUseDOM
&
&
'
TextEvent
'
in
window
&
&
!
documentMode
;
var
useFallbackCompositionData
=
canUseDOM
&
&
(
!
canUseCompositionEvent
|
|
documentMode
&
&
documentMode
>
8
&
&
documentMode
<
=
11
)
;
var
SPACEBAR_CODE
=
32
;
var
SPACEBAR_CHAR
=
String
.
fromCharCode
(
SPACEBAR_CODE
)
;
var
eventTypes
1
=
{
beforeInput
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onBeforeInput
'
captured
:
'
onBeforeInputCapture
'
}
dependencies
:
[
TOP_COMPOSITION_END
TOP_KEY_PRESS
TOP_TEXT_INPUT
TOP_PASTE
]
}
compositionEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionEnd
'
captured
:
'
onCompositionEndCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_END
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
compositionStart
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionStart
'
captured
:
'
onCompositionStartCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_START
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
compositionUpdate
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionUpdate
'
captured
:
'
onCompositionUpdateCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_UPDATE
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
}
;
var
hasSpaceKeypress
=
false
;
function
isKeypressCommand
(
nativeEvent
)
{
return
(
nativeEvent
.
ctrlKey
|
|
nativeEvent
.
altKey
|
|
nativeEvent
.
metaKey
)
&
&
!
(
nativeEvent
.
ctrlKey
&
&
nativeEvent
.
altKey
)
;
}
function
getCompositionEventType
(
topLevelType
)
{
switch
(
topLevelType
)
{
case
TOP_COMPOSITION_START
:
return
eventTypes
1
.
compositionStart
;
case
TOP_COMPOSITION_END
:
return
eventTypes
1
.
compositionEnd
;
case
TOP_COMPOSITION_UPDATE
:
return
eventTypes
1
.
compositionUpdate
;
}
}
function
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
{
return
topLevelType
=
=
=
TOP_KEY_DOWN
&
&
nativeEvent
.
keyCode
=
=
=
START_KEYCODE
;
}
function
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
TOP_KEY_UP
:
return
END_KEYCODES
.
indexOf
(
nativeEvent
.
keyCode
)
!
=
=
-
1
;
case
TOP_KEY_DOWN
:
return
nativeEvent
.
keyCode
!
=
=
START_KEYCODE
;
case
TOP_KEY_PRESS
:
case
TOP_MOUSE_DOWN
:
case
TOP_BLUR
:
return
true
;
default
:
return
false
;
}
}
function
getDataFromCustomEvent
(
nativeEvent
)
{
var
detail
=
nativeEvent
.
detail
;
if
(
typeof
detail
=
=
=
'
object
'
&
&
'
data
'
in
detail
)
{
return
detail
.
data
;
}
return
null
;
}
function
isUsingKoreanIME
(
nativeEvent
)
{
return
nativeEvent
.
locale
=
=
=
'
ko
'
;
}
var
isComposing
=
false
;
function
extractCompositionEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
eventType
;
var
fallbackData
;
if
(
canUseCompositionEvent
)
{
eventType
=
getCompositionEventType
(
topLevelType
)
;
}
else
if
(
!
isComposing
)
{
if
(
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
1
.
compositionStart
;
}
}
else
if
(
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
1
.
compositionEnd
;
}
if
(
!
eventType
)
{
return
null
;
}
if
(
useFallbackCompositionData
&
&
!
isUsingKoreanIME
(
nativeEvent
)
)
{
if
(
!
isComposing
&
&
eventType
=
=
=
eventTypes
1
.
compositionStart
)
{
isComposing
=
initialize
(
nativeEventTarget
)
;
}
else
if
(
eventType
=
=
=
eventTypes
1
.
compositionEnd
)
{
if
(
isComposing
)
{
fallbackData
=
getData
(
)
;
}
}
}
var
event
=
SyntheticCompositionEvent
.
getPooled
(
eventType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
fallbackData
)
{
event
.
data
=
fallbackData
;
}
else
{
var
customData
=
getDataFromCustomEvent
(
nativeEvent
)
;
if
(
customData
!
=
=
null
)
{
event
.
data
=
customData
;
}
}
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
function
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
TOP_COMPOSITION_END
:
return
getDataFromCustomEvent
(
nativeEvent
)
;
case
TOP_KEY_PRESS
:
var
which
=
nativeEvent
.
which
;
if
(
which
!
=
=
SPACEBAR_CODE
)
{
return
null
;
}
hasSpaceKeypress
=
true
;
return
SPACEBAR_CHAR
;
case
TOP_TEXT_INPUT
:
var
chars
=
nativeEvent
.
data
;
if
(
chars
=
=
=
SPACEBAR_CHAR
&
&
hasSpaceKeypress
)
{
return
null
;
}
return
chars
;
default
:
return
null
;
}
}
function
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
{
if
(
isComposing
)
{
if
(
topLevelType
=
=
=
TOP_COMPOSITION_END
|
|
!
canUseCompositionEvent
&
&
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
var
chars
=
getData
(
)
;
reset
(
)
;
isComposing
=
false
;
return
chars
;
}
return
null
;
}
switch
(
topLevelType
)
{
case
TOP_PASTE
:
return
null
;
case
TOP_KEY_PRESS
:
if
(
!
isKeypressCommand
(
nativeEvent
)
)
{
if
(
nativeEvent
.
char
&
&
nativeEvent
.
char
.
length
>
1
)
{
return
nativeEvent
.
char
;
}
else
if
(
nativeEvent
.
which
)
{
return
String
.
fromCharCode
(
nativeEvent
.
which
)
;
}
}
return
null
;
case
TOP_COMPOSITION_END
:
return
useFallbackCompositionData
&
&
!
isUsingKoreanIME
(
nativeEvent
)
?
null
:
nativeEvent
.
data
;
default
:
return
null
;
}
}
function
extractBeforeInputEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
chars
;
if
(
canUseTextInputEvent
)
{
chars
=
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
else
{
chars
=
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
if
(
!
chars
)
{
return
null
;
}
var
event
=
SyntheticInputEvent
.
getPooled
(
eventTypes
1
.
beforeInput
targetInst
nativeEvent
nativeEventTarget
)
;
event
.
data
=
chars
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
BeforeInputEventPlugin
=
{
eventTypes
:
eventTypes
1
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
var
composition
=
extractCompositionEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
var
beforeInput
=
extractBeforeInputEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
composition
=
=
=
null
)
{
return
beforeInput
;
}
if
(
beforeInput
=
=
=
null
)
{
return
composition
;
}
return
[
composition
beforeInput
]
;
}
}
;
var
supportedInputTypes
=
{
color
:
true
date
:
true
datetime
:
true
'
datetime
-
local
'
:
true
email
:
true
month
:
true
number
:
true
password
:
true
range
:
true
search
:
true
tel
:
true
text
:
true
time
:
true
url
:
true
week
:
true
}
;
function
isTextInputElement
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
if
(
nodeName
=
=
=
'
input
'
)
{
return
!
!
supportedInputTypes
[
elem
.
type
]
;
}
if
(
nodeName
=
=
=
'
textarea
'
)
{
return
true
;
}
return
false
;
}
var
eventTypes
2
=
{
change
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onChange
'
captured
:
'
onChangeCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_CHANGE
TOP_CLICK
TOP_FOCUS
TOP_INPUT
TOP_KEY_DOWN
TOP_KEY_UP
TOP_SELECTION_CHANGE
]
}
}
;
function
createAndAccumulateChangeEvent
(
inst
nativeEvent
target
)
{
var
event
=
SyntheticEvent
.
getPooled
(
eventTypes
2
.
change
inst
nativeEvent
target
)
;
event
.
type
=
'
change
'
;
enqueueStateRestore
(
target
)
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
activeElement
=
null
;
var
activeElementInst
=
null
;
function
shouldUseChangeEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
=
=
=
'
select
'
|
|
nodeName
=
=
=
'
input
'
&
&
elem
.
type
=
=
=
'
file
'
;
}
function
manualDispatchChangeEvent
(
nativeEvent
)
{
var
event
=
createAndAccumulateChangeEvent
(
activeElementInst
nativeEvent
getEventTarget
(
nativeEvent
)
)
;
batchedUpdates
(
runEventInBatch
event
)
;
}
function
runEventInBatch
(
event
)
{
runEventsInBatch
(
event
)
;
}
function
getInstIfValueChanged
(
targetInst
)
{
var
targetNode
=
getNodeFromInstance
1
(
targetInst
)
;
if
(
updateValueIfChanged
(
targetNode
)
)
{
return
targetInst
;
}
}
function
getTargetInstForChangeEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_CHANGE
)
{
return
targetInst
;
}
}
var
isInputEventSupported
=
false
;
if
(
canUseDOM
)
{
isInputEventSupported
=
isEventSupported
(
'
input
'
)
&
&
(
!
document
.
documentMode
|
|
document
.
documentMode
>
9
)
;
}
function
startWatchingForValueChange
(
target
targetInst
)
{
activeElement
=
target
;
activeElementInst
=
targetInst
;
activeElement
.
attachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
}
function
stopWatchingForValueChange
(
)
{
if
(
!
activeElement
)
{
return
;
}
activeElement
.
detachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
activeElement
=
null
;
activeElementInst
=
null
;
}
function
handlePropertyChange
(
nativeEvent
)
{
if
(
nativeEvent
.
propertyName
!
=
=
'
value
'
)
{
return
;
}
if
(
getInstIfValueChanged
(
activeElementInst
)
)
{
manualDispatchChangeEvent
(
nativeEvent
)
;
}
}
function
handleEventsForInputEventPolyfill
(
topLevelType
target
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_FOCUS
)
{
stopWatchingForValueChange
(
)
;
startWatchingForValueChange
(
target
targetInst
)
;
}
else
if
(
topLevelType
=
=
=
TOP_BLUR
)
{
stopWatchingForValueChange
(
)
;
}
}
function
getTargetInstForInputEventPolyfill
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_SELECTION_CHANGE
|
|
topLevelType
=
=
=
TOP_KEY_UP
|
|
topLevelType
=
=
=
TOP_KEY_DOWN
)
{
return
getInstIfValueChanged
(
activeElementInst
)
;
}
}
function
shouldUseClickEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
;
return
nodeName
&
&
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
elem
.
type
=
=
=
'
checkbox
'
|
|
elem
.
type
=
=
=
'
radio
'
)
;
}
function
getTargetInstForClickEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_CLICK
)
{
return
getInstIfValueChanged
(
targetInst
)
;
}
}
function
getTargetInstForInputOrChangeEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_INPUT
|
|
topLevelType
=
=
=
TOP_CHANGE
)
{
return
getInstIfValueChanged
(
targetInst
)
;
}
}
function
handleControlledInputBlur
(
node
)
{
var
state
=
node
.
_wrapperState
;
if
(
!
state
|
|
!
state
.
controlled
|
|
node
.
type
!
=
=
'
number
'
)
{
return
;
}
if
(
!
disableInputAttributeSyncing
)
{
setDefaultValue
(
node
'
number
'
node
.
value
)
;
}
}
var
ChangeEventPlugin
=
{
eventTypes
:
eventTypes
2
_isInputEventSupported
:
isInputEventSupported
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
var
targetNode
=
targetInst
?
getNodeFromInstance
1
(
targetInst
)
:
window
;
var
getTargetInstFunc
handleEventFunc
;
if
(
shouldUseChangeEvent
(
targetNode
)
)
{
getTargetInstFunc
=
getTargetInstForChangeEvent
;
}
else
if
(
isTextInputElement
(
targetNode
)
)
{
if
(
isInputEventSupported
)
{
getTargetInstFunc
=
getTargetInstForInputOrChangeEvent
;
}
else
{
getTargetInstFunc
=
getTargetInstForInputEventPolyfill
;
handleEventFunc
=
handleEventsForInputEventPolyfill
;
}
}
else
if
(
shouldUseClickEvent
(
targetNode
)
)
{
getTargetInstFunc
=
getTargetInstForClickEvent
;
}
if
(
getTargetInstFunc
)
{
var
inst
=
getTargetInstFunc
(
topLevelType
targetInst
)
;
if
(
inst
)
{
var
event
=
createAndAccumulateChangeEvent
(
inst
nativeEvent
nativeEventTarget
)
;
return
event
;
}
}
if
(
handleEventFunc
)
{
handleEventFunc
(
topLevelType
targetNode
targetInst
)
;
}
if
(
topLevelType
=
=
=
TOP_BLUR
)
{
handleControlledInputBlur
(
targetNode
)
;
}
}
}
;
var
DOMEventPluginOrder
=
[
'
ResponderEventPlugin
'
'
SimpleEventPlugin
'
'
EnterLeaveEventPlugin
'
'
ChangeEventPlugin
'
'
SelectEventPlugin
'
'
BeforeInputEventPlugin
'
]
;
var
eventTypes
3
=
{
mouseEnter
:
{
registrationName
:
'
onMouseEnter
'
dependencies
:
[
TOP_MOUSE_OUT
TOP_MOUSE_OVER
]
}
mouseLeave
:
{
registrationName
:
'
onMouseLeave
'
dependencies
:
[
TOP_MOUSE_OUT
TOP_MOUSE_OVER
]
}
pointerEnter
:
{
registrationName
:
'
onPointerEnter
'
dependencies
:
[
TOP_POINTER_OUT
TOP_POINTER_OVER
]
}
pointerLeave
:
{
registrationName
:
'
onPointerLeave
'
dependencies
:
[
TOP_POINTER_OUT
TOP_POINTER_OVER
]
}
}
;
var
lastNativeEvent
;
var
EnterLeaveEventPlugin
=
{
eventTypes
:
eventTypes
3
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
var
isOverEvent
=
topLevelType
=
=
=
TOP_MOUSE_OVER
|
|
topLevelType
=
=
=
TOP_POINTER_OVER
;
var
isOutEvent
=
topLevelType
=
=
=
TOP_MOUSE_OUT
|
|
topLevelType
=
=
=
TOP_POINTER_OUT
;
if
(
isOverEvent
&
&
(
eventSystemFlags
&
IS_REPLAYED
)
=
=
=
0
&
&
(
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
fromElement
)
)
{
return
null
;
}
if
(
!
isOutEvent
&
&
!
isOverEvent
)
{
return
null
;
}
var
win
;
if
(
nativeEventTarget
.
window
=
=
=
nativeEventTarget
)
{
win
=
nativeEventTarget
;
}
else
{
var
doc
=
nativeEventTarget
.
ownerDocument
;
if
(
doc
)
{
win
=
doc
.
defaultView
|
|
doc
.
parentWindow
;
}
else
{
win
=
window
;
}
}
var
from
;
var
to
;
if
(
isOutEvent
)
{
from
=
targetInst
;
var
related
=
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
toElement
;
to
=
related
?
getClosestInstanceFromNode
(
related
)
:
null
;
if
(
to
!
=
=
null
)
{
var
nearestMounted
=
getNearestMountedFiber
(
to
)
;
if
(
to
!
=
=
nearestMounted
|
|
to
.
tag
!
=
=
HostComponent
&
&
to
.
tag
!
=
=
HostText
)
{
to
=
null
;
}
}
}
else
{
from
=
null
;
to
=
targetInst
;
}
if
(
from
=
=
=
to
)
{
return
null
;
}
var
eventInterface
leaveEventType
enterEventType
eventTypePrefix
;
if
(
topLevelType
=
=
=
TOP_MOUSE_OUT
|
|
topLevelType
=
=
=
TOP_MOUSE_OVER
)
{
eventInterface
=
SyntheticMouseEvent
;
leaveEventType
=
eventTypes
3
.
mouseLeave
;
enterEventType
=
eventTypes
3
.
mouseEnter
;
eventTypePrefix
=
'
mouse
'
;
}
else
if
(
topLevelType
=
=
=
TOP_POINTER_OUT
|
|
topLevelType
=
=
=
TOP_POINTER_OVER
)
{
eventInterface
=
SyntheticPointerEvent
;
leaveEventType
=
eventTypes
3
.
pointerLeave
;
enterEventType
=
eventTypes
3
.
pointerEnter
;
eventTypePrefix
=
'
pointer
'
;
}
var
fromNode
=
from
=
=
null
?
win
:
getNodeFromInstance
1
(
from
)
;
var
toNode
=
to
=
=
null
?
win
:
getNodeFromInstance
1
(
to
)
;
var
leave
=
eventInterface
.
getPooled
(
leaveEventType
from
nativeEvent
nativeEventTarget
)
;
leave
.
type
=
eventTypePrefix
+
'
leave
'
;
leave
.
target
=
fromNode
;
leave
.
relatedTarget
=
toNode
;
var
enter
=
eventInterface
.
getPooled
(
enterEventType
to
nativeEvent
nativeEventTarget
)
;
enter
.
type
=
eventTypePrefix
+
'
enter
'
;
enter
.
target
=
toNode
;
enter
.
relatedTarget
=
fromNode
;
accumulateEnterLeaveDispatches
(
leave
enter
from
to
)
;
if
(
nativeEvent
=
=
=
lastNativeEvent
)
{
lastNativeEvent
=
null
;
return
[
leave
]
;
}
lastNativeEvent
=
nativeEvent
;
return
[
leave
enter
]
;
}
}
;
function
is
(
x
y
)
{
return
x
=
=
=
y
&
&
(
x
!
=
=
0
|
|
1
/
x
=
=
=
1
/
y
)
|
|
x
!
=
=
x
&
&
y
!
=
=
y
;
}
var
is
1
=
typeof
Object
.
is
=
=
=
'
function
'
?
Object
.
is
:
is
;
var
hasOwnProperty
2
=
Object
.
prototype
.
hasOwnProperty
;
function
shallowEqual
(
objA
objB
)
{
if
(
is
1
(
objA
objB
)
)
{
return
true
;
}
if
(
typeof
objA
!
=
=
'
object
'
|
|
objA
=
=
=
null
|
|
typeof
objB
!
=
=
'
object
'
|
|
objB
=
=
=
null
)
{
return
false
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwnProperty
2
.
call
(
objB
keysA
[
i
]
)
|
|
!
is
1
(
objA
[
keysA
[
i
]
]
objB
[
keysA
[
i
]
]
)
)
{
return
false
;
}
}
return
true
;
}
var
skipSelectionChangeEvent
=
canUseDOM
&
&
'
documentMode
'
in
document
&
&
document
.
documentMode
<
=
11
;
var
eventTypes
4
=
{
select
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onSelect
'
captured
:
'
onSelectCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_CONTEXT_MENU
TOP_DRAG_END
TOP_FOCUS
TOP_KEY_DOWN
TOP_KEY_UP
TOP_MOUSE_DOWN
TOP_MOUSE_UP
TOP_SELECTION_CHANGE
]
}
}
;
var
activeElement
1
=
null
;
var
activeElementInst
1
=
null
;
var
lastSelection
=
null
;
var
mouseDown
=
false
;
function
getSelection
1
(
node
)
{
if
(
'
selectionStart
'
in
node
&
&
hasSelectionCapabilities
(
node
)
)
{
return
{
start
:
node
.
selectionStart
end
:
node
.
selectionEnd
}
;
}
else
{
var
win
=
node
.
ownerDocument
&
&
node
.
ownerDocument
.
defaultView
|
|
window
;
var
selection
=
win
.
getSelection
(
)
;
return
{
anchorNode
:
selection
.
anchorNode
anchorOffset
:
selection
.
anchorOffset
focusNode
:
selection
.
focusNode
focusOffset
:
selection
.
focusOffset
}
;
}
}
function
getEventTargetDocument
(
eventTarget
)
{
return
eventTarget
.
window
=
=
=
eventTarget
?
eventTarget
.
document
:
eventTarget
.
nodeType
=
=
=
DOCUMENT_NODE
?
eventTarget
:
eventTarget
.
ownerDocument
;
}
function
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
{
var
doc
=
getEventTargetDocument
(
nativeEventTarget
)
;
if
(
mouseDown
|
|
activeElement
1
=
=
null
|
|
activeElement
1
!
=
=
getActiveElement
(
doc
)
)
{
return
null
;
}
var
currentSelection
=
getSelection
1
(
activeElement
1
)
;
if
(
!
lastSelection
|
|
!
shallowEqual
(
lastSelection
currentSelection
)
)
{
lastSelection
=
currentSelection
;
var
syntheticEvent
=
SyntheticEvent
.
getPooled
(
eventTypes
4
.
select
activeElementInst
1
nativeEvent
nativeEventTarget
)
;
syntheticEvent
.
type
=
'
select
'
;
syntheticEvent
.
target
=
activeElement
1
;
accumulateTwoPhaseDispatches
(
syntheticEvent
)
;
return
syntheticEvent
;
}
return
null
;
}
var
SelectEventPlugin
=
{
eventTypes
:
eventTypes
4
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
eventSystemFlags
)
{
var
doc
=
getEventTargetDocument
(
nativeEventTarget
)
;
if
(
!
doc
|
|
!
isListeningToAllDependencies
(
'
onSelect
'
doc
)
)
{
return
null
;
}
var
targetNode
=
targetInst
?
getNodeFromInstance
1
(
targetInst
)
:
window
;
switch
(
topLevelType
)
{
case
TOP_FOCUS
:
if
(
isTextInputElement
(
targetNode
)
|
|
targetNode
.
contentEditable
=
=
=
'
true
'
)
{
activeElement
1
=
targetNode
;
activeElementInst
1
=
targetInst
;
lastSelection
=
null
;
}
break
;
case
TOP_BLUR
:
activeElement
1
=
null
;
activeElementInst
1
=
null
;
lastSelection
=
null
;
break
;
case
TOP_MOUSE_DOWN
:
mouseDown
=
true
;
break
;
case
TOP_CONTEXT_MENU
:
case
TOP_MOUSE_UP
:
case
TOP_DRAG_END
:
mouseDown
=
false
;
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
case
TOP_SELECTION_CHANGE
:
if
(
skipSelectionChangeEvent
)
{
break
;
}
case
TOP_KEY_DOWN
:
case
TOP_KEY_UP
:
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
}
return
null
;
}
}
;
injection
.
injectEventPluginOrder
(
DOMEventPluginOrder
)
;
setComponentTree
(
getFiberCurrentPropsFromNode
1
getInstanceFromNode
1
getNodeFromInstance
1
)
;
injection
.
injectEventPluginsByName
(
{
SimpleEventPlugin
:
SimpleEventPlugin
EnterLeaveEventPlugin
:
EnterLeaveEventPlugin
ChangeEventPlugin
:
ChangeEventPlugin
SelectEventPlugin
:
SelectEventPlugin
BeforeInputEventPlugin
:
BeforeInputEventPlugin
}
)
;
var
reactEmoji
=
"
\
u269B
"
;
var
warningEmoji
=
"
\
u26D4
"
;
var
supportsUserTiming
=
typeof
performance
!
=
=
'
undefined
'
&
&
typeof
performance
.
mark
=
=
=
'
function
'
&
&
typeof
performance
.
clearMarks
=
=
=
'
function
'
&
&
typeof
performance
.
measure
=
=
=
'
function
'
&
&
typeof
performance
.
clearMeasures
=
=
=
'
function
'
;
var
currentFiber
=
null
;
var
currentPhase
=
null
;
var
currentPhaseFiber
=
null
;
var
isCommitting
=
false
;
var
hasScheduledUpdateInCurrentCommit
=
false
;
var
hasScheduledUpdateInCurrentPhase
=
false
;
var
commitCountInCurrentWorkLoop
=
0
;
var
effectCountInCurrentCommit
=
0
;
var
labelsInCurrentCommit
=
new
Set
(
)
;
var
formatMarkName
=
function
(
markName
)
{
return
reactEmoji
+
"
"
+
markName
;
}
;
var
formatLabel
=
function
(
label
warning
)
{
var
prefix
=
warning
?
warningEmoji
+
"
"
:
reactEmoji
+
"
"
;
var
suffix
=
warning
?
"
Warning
:
"
+
warning
:
'
'
;
return
"
"
+
prefix
+
label
+
suffix
;
}
;
var
beginMark
=
function
(
markName
)
{
performance
.
mark
(
formatMarkName
(
markName
)
)
;
}
;
var
clearMark
=
function
(
markName
)
{
performance
.
clearMarks
(
formatMarkName
(
markName
)
)
;
}
;
var
endMark
=
function
(
label
markName
warning
)
{
var
formattedMarkName
=
formatMarkName
(
markName
)
;
var
formattedLabel
=
formatLabel
(
label
warning
)
;
try
{
performance
.
measure
(
formattedLabel
formattedMarkName
)
;
}
catch
(
err
)
{
}
performance
.
clearMarks
(
formattedMarkName
)
;
performance
.
clearMeasures
(
formattedLabel
)
;
}
;
var
getFiberMarkName
=
function
(
label
debugID
)
{
return
label
+
"
(
#
"
+
debugID
+
"
)
"
;
}
;
var
getFiberLabel
=
function
(
componentName
isMounted
phase
)
{
if
(
phase
=
=
=
null
)
{
return
componentName
+
"
[
"
+
(
isMounted
?
'
update
'
:
'
mount
'
)
+
"
]
"
;
}
else
{
return
componentName
+
"
.
"
+
phase
;
}
}
;
var
beginFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
.
type
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
if
(
isCommitting
&
&
labelsInCurrentCommit
.
has
(
label
)
)
{
return
false
;
}
labelsInCurrentCommit
.
add
(
label
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
beginMark
(
markName
)
;
return
true
;
}
;
var
clearFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
.
type
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
clearMark
(
markName
)
;
}
;
var
endFiberMark
=
function
(
fiber
phase
warning
)
{
var
componentName
=
getComponentName
(
fiber
.
type
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
endMark
(
label
markName
warning
)
;
}
;
var
shouldIgnoreFiber
=
function
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
case
Fragment
:
case
ContextProvider
:
case
ContextConsumer
:
case
Mode
:
return
true
;
default
:
return
false
;
}
}
;
var
clearPendingPhaseMeasurement
=
function
(
)
{
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
clearFiberMark
(
currentPhaseFiber
currentPhase
)
;
}
currentPhaseFiber
=
null
;
currentPhase
=
null
;
hasScheduledUpdateInCurrentPhase
=
false
;
}
;
var
pauseTimers
=
function
(
)
{
var
fiber
=
currentFiber
;
while
(
fiber
)
{
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
endFiberMark
(
fiber
null
null
)
;
}
fiber
=
fiber
.
return
;
}
}
;
var
resumeTimersRecursively
=
function
(
fiber
)
{
if
(
fiber
.
return
!
=
=
null
)
{
resumeTimersRecursively
(
fiber
.
return
)
;
}
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
beginFiberMark
(
fiber
null
)
;
}
}
;
var
resumeTimers
=
function
(
)
{
if
(
currentFiber
!
=
=
null
)
{
resumeTimersRecursively
(
currentFiber
)
;
}
}
;
function
recordEffect
(
)
{
if
(
enableUserTimingAPI
)
{
effectCountInCurrentCommit
+
+
;
}
}
function
recordScheduleUpdate
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
isCommitting
)
{
hasScheduledUpdateInCurrentCommit
=
true
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhase
!
=
=
'
componentWillMount
'
&
&
currentPhase
!
=
=
'
componentWillReceiveProps
'
)
{
hasScheduledUpdateInCurrentPhase
=
true
;
}
}
}
function
startWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
;
if
(
!
beginFiberMark
(
fiber
null
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
true
;
}
}
function
cancelWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
clearFiberMark
(
fiber
null
)
;
}
}
function
stopWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
.
return
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
endFiberMark
(
fiber
null
null
)
;
}
}
function
stopFailedWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
.
return
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
var
warning
=
fiber
.
tag
=
=
=
SuspenseComponent
?
'
Rendering
was
suspended
'
:
'
An
error
was
thrown
inside
this
error
boundary
'
;
endFiberMark
(
fiber
null
warning
)
;
}
}
function
startPhaseTimer
(
fiber
phase
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
clearPendingPhaseMeasurement
(
)
;
if
(
!
beginFiberMark
(
fiber
phase
)
)
{
return
;
}
currentPhaseFiber
=
fiber
;
currentPhase
=
phase
;
}
}
function
stopPhaseTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
var
warning
=
hasScheduledUpdateInCurrentPhase
?
'
Scheduled
a
cascading
update
'
:
null
;
endFiberMark
(
currentPhaseFiber
currentPhase
warning
)
;
}
currentPhase
=
null
;
currentPhaseFiber
=
null
;
}
}
function
startWorkLoopTimer
(
nextUnitOfWork
)
{
if
(
enableUserTimingAPI
)
{
currentFiber
=
nextUnitOfWork
;
if
(
!
supportsUserTiming
)
{
return
;
}
commitCountInCurrentWorkLoop
=
0
;
beginMark
(
'
(
React
Tree
Reconciliation
)
'
)
;
resumeTimers
(
)
;
}
}
function
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
interruptedBy
!
=
=
null
)
{
if
(
interruptedBy
.
tag
=
=
=
HostRoot
)
{
warning
=
'
A
top
-
level
update
interrupted
the
previous
render
'
;
}
else
{
var
componentName
=
getComponentName
(
interruptedBy
.
type
)
|
|
'
Unknown
'
;
warning
=
"
An
update
to
"
+
componentName
+
"
interrupted
the
previous
render
"
;
}
}
else
if
(
commitCountInCurrentWorkLoop
>
1
)
{
warning
=
'
There
were
cascading
updates
'
;
}
commitCountInCurrentWorkLoop
=
0
;
var
label
=
didCompleteRoot
?
'
(
React
Tree
Reconciliation
:
Completed
Root
)
'
:
'
(
React
Tree
Reconciliation
:
Yielded
)
'
;
pauseTimers
(
)
;
endMark
(
label
'
(
React
Tree
Reconciliation
)
'
warning
)
;
}
}
function
startCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
isCommitting
=
true
;
hasScheduledUpdateInCurrentCommit
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
beginMark
(
'
(
Committing
Changes
)
'
)
;
}
}
function
stopCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
hasScheduledUpdateInCurrentCommit
)
{
warning
=
'
Lifecycle
hook
scheduled
a
cascading
update
'
;
}
else
if
(
commitCountInCurrentWorkLoop
>
0
)
{
warning
=
'
Caused
by
a
cascading
update
in
earlier
commit
'
;
}
hasScheduledUpdateInCurrentCommit
=
false
;
commitCountInCurrentWorkLoop
+
+
;
isCommitting
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
endMark
(
'
(
Committing
Changes
)
'
'
(
Committing
Changes
)
'
warning
)
;
}
}
function
startCommitSnapshotEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Snapshot
Effects
)
'
)
;
}
}
function
stopCommitSnapshotEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
"
(
Committing
Snapshot
Effects
:
"
+
count
+
"
Total
)
"
'
(
Committing
Snapshot
Effects
)
'
null
)
;
}
}
function
startCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Host
Effects
)
'
)
;
}
}
function
stopCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
"
(
Committing
Host
Effects
:
"
+
count
+
"
Total
)
"
'
(
Committing
Host
Effects
)
'
null
)
;
}
}
function
startCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Calling
Lifecycle
Methods
)
'
)
;
}
}
function
stopCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
"
(
Calling
Lifecycle
Methods
:
"
+
count
+
"
Total
)
"
'
(
Calling
Lifecycle
Methods
)
'
null
)
;
}
}
var
valueStack
=
[
]
;
var
fiberStack
;
{
fiberStack
=
[
]
;
}
var
index
=
-
1
;
function
createCursor
(
defaultValue
)
{
return
{
current
:
defaultValue
}
;
}
function
pop
(
cursor
fiber
)
{
if
(
index
<
0
)
{
{
warningWithoutStack
1
(
false
'
Unexpected
pop
.
'
)
;
}
return
;
}
{
if
(
fiber
!
=
=
fiberStack
[
index
]
)
{
warningWithoutStack
1
(
false
'
Unexpected
Fiber
popped
.
'
)
;
}
}
cursor
.
current
=
valueStack
[
index
]
;
valueStack
[
index
]
=
null
;
{
fiberStack
[
index
]
=
null
;
}
index
-
-
;
}
function
push
(
cursor
value
fiber
)
{
index
+
+
;
valueStack
[
index
]
=
cursor
.
current
;
{
fiberStack
[
index
]
=
fiber
;
}
cursor
.
current
=
value
;
}
var
warnedAboutMissingGetChildContext
;
{
warnedAboutMissingGetChildContext
=
{
}
;
}
var
emptyContextObject
=
{
}
;
{
Object
.
freeze
(
emptyContextObject
)
;
}
var
contextStackCursor
=
createCursor
(
emptyContextObject
)
;
var
didPerformWorkStackCursor
=
createCursor
(
false
)
;
var
previousContext
=
emptyContextObject
;
function
getUnmaskedContext
(
workInProgress
Component
didPushOwnContextIfProvider
)
{
if
(
disableLegacyContext
)
{
return
emptyContextObject
;
}
else
{
if
(
didPushOwnContextIfProvider
&
&
isContextProvider
(
Component
)
)
{
return
previousContext
;
}
return
contextStackCursor
.
current
;
}
}
function
cacheContext
(
workInProgress
unmaskedContext
maskedContext
)
{
if
(
disableLegacyContext
)
{
return
;
}
else
{
var
instance
=
workInProgress
.
stateNode
;
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
unmaskedContext
;
instance
.
__reactInternalMemoizedMaskedChildContext
=
maskedContext
;
}
}
function
getMaskedContext
(
workInProgress
unmaskedContext
)
{
if
(
disableLegacyContext
)
{
return
emptyContextObject
;
}
else
{
var
type
=
workInProgress
.
type
;
var
contextTypes
=
type
.
contextTypes
;
if
(
!
contextTypes
)
{
return
emptyContextObject
;
}
var
instance
=
workInProgress
.
stateNode
;
if
(
instance
&
&
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
=
=
unmaskedContext
)
{
return
instance
.
__reactInternalMemoizedMaskedChildContext
;
}
var
context
=
{
}
;
for
(
var
key
in
contextTypes
)
{
context
[
key
]
=
unmaskedContext
[
key
]
;
}
{
var
name
=
getComponentName
(
type
)
|
|
'
Unknown
'
;
checkPropTypes_1
(
contextTypes
context
'
context
'
name
getCurrentFiberStackInDev
)
;
}
if
(
instance
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
context
;
}
}
function
hasContextChanged
(
)
{
if
(
disableLegacyContext
)
{
return
false
;
}
else
{
return
didPerformWorkStackCursor
.
current
;
}
}
function
isContextProvider
(
type
)
{
if
(
disableLegacyContext
)
{
return
false
;
}
else
{
var
childContextTypes
=
type
.
childContextTypes
;
return
childContextTypes
!
=
=
null
&
&
childContextTypes
!
=
=
undefined
;
}
}
function
popContext
(
fiber
)
{
if
(
disableLegacyContext
)
{
return
;
}
else
{
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
}
function
popTopLevelContextObject
(
fiber
)
{
if
(
disableLegacyContext
)
{
return
;
}
else
{
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
}
function
pushTopLevelContextObject
(
fiber
context
didChange
)
{
if
(
disableLegacyContext
)
{
return
;
}
else
{
if
(
!
(
contextStackCursor
.
current
=
=
=
emptyContextObject
)
)
{
{
throw
Error
(
"
Unexpected
context
found
on
stack
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
push
(
contextStackCursor
context
fiber
)
;
push
(
didPerformWorkStackCursor
didChange
fiber
)
;
}
}
function
processChildContext
(
fiber
type
parentContext
)
{
if
(
disableLegacyContext
)
{
return
parentContext
;
}
else
{
var
instance
=
fiber
.
stateNode
;
var
childContextTypes
=
type
.
childContextTypes
;
if
(
typeof
instance
.
getChildContext
!
=
=
'
function
'
)
{
{
var
componentName
=
getComponentName
(
type
)
|
|
'
Unknown
'
;
if
(
!
warnedAboutMissingGetChildContext
[
componentName
]
)
{
warnedAboutMissingGetChildContext
[
componentName
]
=
true
;
warningWithoutStack
1
(
false
'
%
s
.
childContextTypes
is
specified
but
there
is
no
getChildContext
(
)
method
'
+
'
on
the
instance
.
You
can
either
define
getChildContext
(
)
on
%
s
or
remove
'
+
'
childContextTypes
from
it
.
'
componentName
componentName
)
;
}
}
return
parentContext
;
}
var
childContext
;
{
setCurrentPhase
(
'
getChildContext
'
)
;
}
startPhaseTimer
(
fiber
'
getChildContext
'
)
;
childContext
=
instance
.
getChildContext
(
)
;
stopPhaseTimer
(
)
;
{
setCurrentPhase
(
null
)
;
}
for
(
var
contextKey
in
childContext
)
{
if
(
!
(
contextKey
in
childContextTypes
)
)
{
{
throw
Error
(
(
getComponentName
(
type
)
|
|
'
Unknown
'
)
+
"
.
getChildContext
(
)
:
key
\
"
"
+
contextKey
+
"
\
"
is
not
defined
in
childContextTypes
.
"
)
;
}
}
}
{
var
name
=
getComponentName
(
type
)
|
|
'
Unknown
'
;
checkPropTypes_1
(
childContextTypes
childContext
'
child
context
'
name
getCurrentFiberStackInDev
)
;
}
return
_assign
(
{
}
parentContext
{
}
childContext
)
;
}
}
function
pushContextProvider
(
workInProgress
)
{
if
(
disableLegacyContext
)
{
return
false
;
}
else
{
var
instance
=
workInProgress
.
stateNode
;
var
memoizedMergedChildContext
=
instance
&
&
instance
.
__reactInternalMemoizedMergedChildContext
|
|
emptyContextObject
;
previousContext
=
contextStackCursor
.
current
;
push
(
contextStackCursor
memoizedMergedChildContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didPerformWorkStackCursor
.
current
workInProgress
)
;
return
true
;
}
}
function
invalidateContextProvider
(
workInProgress
type
didChange
)
{
if
(
disableLegacyContext
)
{
return
;
}
else
{
var
instance
=
workInProgress
.
stateNode
;
if
(
!
instance
)
{
{
throw
Error
(
"
Expected
to
have
an
instance
by
this
point
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
if
(
didChange
)
{
var
mergedContext
=
processChildContext
(
workInProgress
type
previousContext
)
;
instance
.
__reactInternalMemoizedMergedChildContext
=
mergedContext
;
pop
(
didPerformWorkStackCursor
workInProgress
)
;
pop
(
contextStackCursor
workInProgress
)
;
push
(
contextStackCursor
mergedContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
else
{
pop
(
didPerformWorkStackCursor
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
}
}
function
findCurrentUnmaskedContext
(
fiber
)
{
if
(
disableLegacyContext
)
{
return
emptyContextObject
;
}
else
{
if
(
!
(
isFiberMounted
(
fiber
)
&
&
fiber
.
tag
=
=
=
ClassComponent
)
)
{
{
throw
Error
(
"
Expected
subtree
parent
to
be
a
mounted
class
component
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
var
node
=
fiber
;
do
{
switch
(
node
.
tag
)
{
case
HostRoot
:
return
node
.
stateNode
.
context
;
case
ClassComponent
:
{
var
Component
=
node
.
type
;
if
(
isContextProvider
(
Component
)
)
{
return
node
.
stateNode
.
__reactInternalMemoizedMergedChildContext
;
}
break
;
}
}
node
=
node
.
return
;
}
while
(
node
!
=
=
null
)
;
{
{
throw
Error
(
"
Found
unexpected
detached
subtree
parent
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
}
var
LegacyRoot
=
0
;
var
BlockingRoot
=
1
;
var
ConcurrentRoot
=
2
;
var
ReactInternals
2
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_ReactInternals
Sched
1
=
ReactInternals
2
.
SchedulerTracing
;
var
__interactionsRef
=
_ReactInternals
Sched
1
.
__interactionsRef
;
var
__subscriberRef
=
_ReactInternals
Sched
1
.
__subscriberRef
;
var
unstable_clear
=
_ReactInternals
Sched
1
.
unstable_clear
;
var
unstable_getCurrent
=
_ReactInternals
Sched
1
.
unstable_getCurrent
;
var
unstable_getThreadID
=
_ReactInternals
Sched
1
.
unstable_getThreadID
;
var
unstable_subscribe
=
_ReactInternals
Sched
1
.
unstable_subscribe
;
var
unstable_trace
=
_ReactInternals
Sched
1
.
unstable_trace
;
var
unstable_unsubscribe
=
_ReactInternals
Sched
1
.
unstable_unsubscribe
;
var
unstable_wrap
=
_ReactInternals
Sched
1
.
unstable_wrap
;
var
Scheduler_runWithPriority
=
unstable_runWithPriority
;
var
Scheduler_scheduleCallback
=
unstable_scheduleCallback
;
var
Scheduler_cancelCallback
=
unstable_cancelCallback
;
var
Scheduler_shouldYield
=
unstable_shouldYield
;
var
Scheduler_requestPaint
=
unstable_requestPaint
;
var
Scheduler_now
=
unstable_now
;
var
Scheduler_getCurrentPriorityLevel
=
unstable_getCurrentPriorityLevel
;
var
Scheduler_ImmediatePriority
=
unstable_ImmediatePriority
;
var
Scheduler_UserBlockingPriority
=
unstable_UserBlockingPriority
;
var
Scheduler_NormalPriority
=
unstable_NormalPriority
;
var
Scheduler_LowPriority
=
unstable_LowPriority
;
var
Scheduler_IdlePriority
=
unstable_IdlePriority
;
if
(
enableSchedulerTracing
)
{
if
(
!
(
__interactionsRef
!
=
null
&
&
__interactionsRef
.
current
!
=
null
)
)
{
{
throw
Error
(
"
It
is
not
supported
to
run
the
profiling
version
of
a
renderer
(
for
example
react
-
dom
/
profiling
)
without
also
replacing
the
scheduler
/
tracing
module
with
scheduler
/
tracing
-
profiling
.
Your
bundler
might
have
a
setting
for
aliasing
both
modules
.
Learn
more
at
http
:
/
/
fb
.
me
/
react
-
profiling
"
)
;
}
}
}
var
fakeCallbackNode
=
{
}
;
var
ImmediatePriority
=
99
;
var
UserBlockingPriority
2
=
98
;
var
NormalPriority
=
97
;
var
LowPriority
=
96
;
var
IdlePriority
=
95
;
var
NoPriority
=
90
;
var
shouldYield
=
Scheduler_shouldYield
;
var
requestPaint
=
Scheduler_requestPaint
!
=
=
undefined
?
Scheduler_requestPaint
:
function
(
)
{
}
;
var
syncQueue
=
null
;
var
immediateQueueCallbackNode
=
null
;
var
isFlushingSyncQueue
=
false
;
var
initialTimeMs
=
Scheduler_now
(
)
;
var
now
=
initialTimeMs
<
10000
?
Scheduler_now
:
function
(
)
{
return
Scheduler_now
(
)
-
initialTimeMs
;
}
;
function
getCurrentPriorityLevel
(
)
{
switch
(
Scheduler_getCurrentPriorityLevel
(
)
)
{
case
Scheduler_ImmediatePriority
:
return
ImmediatePriority
;
case
Scheduler_UserBlockingPriority
:
return
UserBlockingPriority
2
;
case
Scheduler_NormalPriority
:
return
NormalPriority
;
case
Scheduler_LowPriority
:
return
LowPriority
;
case
Scheduler_IdlePriority
:
return
IdlePriority
;
default
:
{
{
throw
Error
(
"
Unknown
priority
level
.
"
)
;
}
}
}
}
function
reactPriorityToSchedulerPriority
(
reactPriorityLevel
)
{
switch
(
reactPriorityLevel
)
{
case
ImmediatePriority
:
return
Scheduler_ImmediatePriority
;
case
UserBlockingPriority
2
:
return
Scheduler_UserBlockingPriority
;
case
NormalPriority
:
return
Scheduler_NormalPriority
;
case
LowPriority
:
return
Scheduler_LowPriority
;
case
IdlePriority
:
return
Scheduler_IdlePriority
;
default
:
{
{
throw
Error
(
"
Unknown
priority
level
.
"
)
;
}
}
}
}
function
runWithPriority
2
(
reactPriorityLevel
fn
)
{
var
priorityLevel
=
reactPriorityToSchedulerPriority
(
reactPriorityLevel
)
;
return
Scheduler_runWithPriority
(
priorityLevel
fn
)
;
}
function
scheduleCallback
(
reactPriorityLevel
callback
options
)
{
var
priorityLevel
=
reactPriorityToSchedulerPriority
(
reactPriorityLevel
)
;
return
Scheduler_scheduleCallback
(
priorityLevel
callback
options
)
;
}
function
scheduleSyncCallback
(
callback
)
{
if
(
syncQueue
=
=
=
null
)
{
syncQueue
=
[
callback
]
;
immediateQueueCallbackNode
=
Scheduler_scheduleCallback
(
Scheduler_ImmediatePriority
flushSyncCallbackQueueImpl
)
;
}
else
{
syncQueue
.
push
(
callback
)
;
}
return
fakeCallbackNode
;
}
function
cancelCallback
(
callbackNode
)
{
if
(
callbackNode
!
=
=
fakeCallbackNode
)
{
Scheduler_cancelCallback
(
callbackNode
)
;
}
}
function
flushSyncCallbackQueue
(
)
{
if
(
immediateQueueCallbackNode
!
=
=
null
)
{
var
node
=
immediateQueueCallbackNode
;
immediateQueueCallbackNode
=
null
;
Scheduler_cancelCallback
(
node
)
;
}
flushSyncCallbackQueueImpl
(
)
;
}
function
flushSyncCallbackQueueImpl
(
)
{
if
(
!
isFlushingSyncQueue
&
&
syncQueue
!
=
=
null
)
{
isFlushingSyncQueue
=
true
;
var
i
=
0
;
try
{
var
_isSync
=
true
;
var
queue
=
syncQueue
;
runWithPriority
2
(
ImmediatePriority
function
(
)
{
for
(
;
i
<
queue
.
length
;
i
+
+
)
{
var
callback
=
queue
[
i
]
;
do
{
callback
=
callback
(
_isSync
)
;
}
while
(
callback
!
=
=
null
)
;
}
}
)
;
syncQueue
=
null
;
}
catch
(
error
)
{
if
(
syncQueue
!
=
=
null
)
{
syncQueue
=
syncQueue
.
slice
(
i
+
1
)
;
}
Scheduler_scheduleCallback
(
Scheduler_ImmediatePriority
flushSyncCallbackQueue
)
;
throw
error
;
}
finally
{
isFlushingSyncQueue
=
false
;
}
}
}
var
NoMode
=
0
;
var
StrictMode
=
1
;
var
BlockingMode
=
2
;
var
ConcurrentMode
=
4
;
var
ProfileMode
=
8
;
var
MAX_SIGNED_31_BIT_INT
=
1073741823
;
var
NoWork
=
0
;
var
Never
=
1
;
var
Idle
=
2
;
var
ContinuousHydration
=
3
;
var
Sync
=
MAX_SIGNED_31_BIT_INT
;
var
Batched
=
Sync
-
1
;
var
UNIT_SIZE
=
10
;
var
MAGIC_NUMBER_OFFSET
=
Batched
-
1
;
function
msToExpirationTime
(
ms
)
{
return
MAGIC_NUMBER_OFFSET
-
(
ms
/
UNIT_SIZE
|
0
)
;
}
function
expirationTimeToMs
(
expirationTime
)
{
return
(
MAGIC_NUMBER_OFFSET
-
expirationTime
)
*
UNIT_SIZE
;
}
function
ceiling
(
num
precision
)
{
return
(
(
num
/
precision
|
0
)
+
1
)
*
precision
;
}
function
computeExpirationBucket
(
currentTime
expirationInMs
bucketSizeMs
)
{
return
MAGIC_NUMBER_OFFSET
-
ceiling
(
MAGIC_NUMBER_OFFSET
-
currentTime
+
expirationInMs
/
UNIT_SIZE
bucketSizeMs
/
UNIT_SIZE
)
;
}
var
LOW_PRIORITY_EXPIRATION
=
5000
;
var
LOW_PRIORITY_BATCH_SIZE
=
250
;
function
computeAsyncExpiration
(
currentTime
)
{
return
computeExpirationBucket
(
currentTime
LOW_PRIORITY_EXPIRATION
LOW_PRIORITY_BATCH_SIZE
)
;
}
function
computeSuspenseExpiration
(
currentTime
timeoutMs
)
{
return
computeExpirationBucket
(
currentTime
timeoutMs
LOW_PRIORITY_BATCH_SIZE
)
;
}
var
HIGH_PRIORITY_EXPIRATION
=
500
;
var
HIGH_PRIORITY_BATCH_SIZE
=
100
;
function
computeInteractiveExpiration
(
currentTime
)
{
return
computeExpirationBucket
(
currentTime
HIGH_PRIORITY_EXPIRATION
HIGH_PRIORITY_BATCH_SIZE
)
;
}
function
computeContinuousHydrationExpiration
(
currentTime
)
{
return
ContinuousHydration
+
+
;
}
function
inferPriorityFromExpirationTime
(
currentTime
expirationTime
)
{
if
(
expirationTime
=
=
=
Sync
)
{
return
ImmediatePriority
;
}
if
(
expirationTime
=
=
=
Never
|
|
expirationTime
=
=
=
Idle
)
{
return
IdlePriority
;
}
var
msUntil
=
expirationTimeToMs
(
expirationTime
)
-
expirationTimeToMs
(
currentTime
)
;
if
(
msUntil
<
=
0
)
{
return
ImmediatePriority
;
}
if
(
msUntil
<
=
HIGH_PRIORITY_EXPIRATION
+
HIGH_PRIORITY_BATCH_SIZE
)
{
return
UserBlockingPriority
2
;
}
if
(
msUntil
<
=
LOW_PRIORITY_EXPIRATION
+
LOW_PRIORITY_BATCH_SIZE
)
{
return
NormalPriority
;
}
return
IdlePriority
;
}
var
lowPriorityWarningWithoutStack
=
function
(
)
{
}
;
{
var
printWarning
1
=
function
(
format
)
{
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
var
argIndex
=
0
;
var
message
=
'
Warning
:
'
+
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
;
if
(
typeof
console
!
=
=
'
undefined
'
)
{
console
.
warn
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
x
)
{
}
}
;
lowPriorityWarningWithoutStack
=
function
(
condition
format
)
{
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
lowPriorityWarningWithoutStack
(
condition
format
.
.
.
args
)
requires
a
warning
'
+
'
message
argument
'
)
;
}
if
(
!
condition
)
{
for
(
var
_len2
=
arguments
.
length
args
=
new
Array
(
_len2
>
2
?
_len2
-
2
:
0
)
_key2
=
2
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
-
2
]
=
arguments
[
_key2
]
;
}
printWarning
1
.
apply
(
void
0
[
format
]
.
concat
(
args
)
)
;
}
}
;
}
var
lowPriorityWarningWithoutStack
1
=
lowPriorityWarningWithoutStack
;
var
ReactStrictModeWarnings
=
{
recordUnsafeLifecycleWarnings
:
function
(
fiber
instance
)
{
}
flushPendingUnsafeLifecycleWarnings
:
function
(
)
{
}
recordLegacyContextWarning
:
function
(
fiber
instance
)
{
}
flushLegacyContextWarning
:
function
(
)
{
}
discardPendingWarnings
:
function
(
)
{
}
}
;
{
var
findStrictRoot
=
function
(
fiber
)
{
var
maybeStrictRoot
=
null
;
var
node
=
fiber
;
while
(
node
!
=
=
null
)
{
if
(
node
.
mode
&
StrictMode
)
{
maybeStrictRoot
=
node
;
}
node
=
node
.
return
;
}
return
maybeStrictRoot
;
}
;
var
setToSortedString
=
function
(
set
)
{
var
array
=
[
]
;
set
.
forEach
(
function
(
value
)
{
array
.
push
(
value
)
;
}
)
;
return
array
.
sort
(
)
.
join
(
'
'
)
;
}
;
var
pendingComponentWillMountWarnings
=
[
]
;
var
pendingUNSAFE_ComponentWillMountWarnings
=
[
]
;
var
pendingComponentWillReceivePropsWarnings
=
[
]
;
var
pendingUNSAFE_ComponentWillReceivePropsWarnings
=
[
]
;
var
pendingComponentWillUpdateWarnings
=
[
]
;
var
pendingUNSAFE_ComponentWillUpdateWarnings
=
[
]
;
var
didWarnAboutUnsafeLifecycles
=
new
Set
(
)
;
ReactStrictModeWarnings
.
recordUnsafeLifecycleWarnings
=
function
(
fiber
instance
)
{
if
(
didWarnAboutUnsafeLifecycles
.
has
(
fiber
.
type
)
)
{
return
;
}
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
&
&
instance
.
componentWillMount
.
__suppressDeprecationWarning
!
=
=
true
)
{
pendingComponentWillMountWarnings
.
push
(
fiber
)
;
}
if
(
fiber
.
mode
&
StrictMode
&
&
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
pendingUNSAFE_ComponentWillMountWarnings
.
push
(
fiber
)
;
}
if
(
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
&
&
instance
.
componentWillReceiveProps
.
__suppressDeprecationWarning
!
=
=
true
)
{
pendingComponentWillReceivePropsWarnings
.
push
(
fiber
)
;
}
if
(
fiber
.
mode
&
StrictMode
&
&
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
)
{
pendingUNSAFE_ComponentWillReceivePropsWarnings
.
push
(
fiber
)
;
}
if
(
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
&
&
instance
.
componentWillUpdate
.
__suppressDeprecationWarning
!
=
=
true
)
{
pendingComponentWillUpdateWarnings
.
push
(
fiber
)
;
}
if
(
fiber
.
mode
&
StrictMode
&
&
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
)
{
pendingUNSAFE_ComponentWillUpdateWarnings
.
push
(
fiber
)
;
}
}
;
ReactStrictModeWarnings
.
flushPendingUnsafeLifecycleWarnings
=
function
(
)
{
var
componentWillMountUniqueNames
=
new
Set
(
)
;
if
(
pendingComponentWillMountWarnings
.
length
>
0
)
{
pendingComponentWillMountWarnings
.
forEach
(
function
(
fiber
)
{
componentWillMountUniqueNames
.
add
(
getComponentName
(
fiber
.
type
)
|
|
'
Component
'
)
;
didWarnAboutUnsafeLifecycles
.
add
(
fiber
.
type
)
;
}
)
;
pendingComponentWillMountWarnings
=
[
]
;
}
var
UNSAFE_componentWillMountUniqueNames
=
new
Set
(
)
;
if
(
pendingUNSAFE_ComponentWillMountWarnings
.
length
>
0
)
{
pendingUNSAFE_ComponentWillMountWarnings
.
forEach
(
function
(
fiber
)
{
UNSAFE_componentWillMountUniqueNames
.
add
(
getComponentName
(
fiber
.
type
)
|
|
'
Component
'
)
;
didWarnAboutUnsafeLifecycles
.
add
(
fiber
.
type
)
;
}
)
;
pendingUNSAFE_ComponentWillMountWarnings
=
[
]
;
}
var
componentWillReceivePropsUniqueNames
=
new
Set
(
)
;
if
(
pendingComponentWillReceivePropsWarnings
.
length
>
0
)
{
pendingComponentWillReceivePropsWarnings
.
forEach
(
function
(
fiber
)
{
componentWillReceivePropsUniqueNames
.
add
(
getComponentName
(
fiber
.
type
)
|
|
'
Component
'
)
;
didWarnAboutUnsafeLifecycles
.
add
(
fiber
.
type
)
;
}
)
;
pendingComponentWillReceivePropsWarnings
=
[
]
;
}
var
UNSAFE_componentWillReceivePropsUniqueNames
=
new
Set
(
)
;
if
(
pendingUNSAFE_ComponentWillReceivePropsWarnings
.
length
>
0
)
{
pendingUNSAFE_ComponentWillReceivePropsWarnings
.
forEach
(
function
(
fiber
)
{
UNSAFE_componentWillReceivePropsUniqueNames
.
add
(
getComponentName
(
fiber
.
type
)
|
|
'
Component
'
)
;
didWarnAboutUnsafeLifecycles
.
add
(
fiber
.
type
)
;
}
)
;
pendingUNSAFE_ComponentWillReceivePropsWarnings
=
[
]
;
}
var
componentWillUpdateUniqueNames
=
new
Set
(
)
;
if
(
pendingComponentWillUpdateWarnings
.
length
>
0
)
{
pendingComponentWillUpdateWarnings
.
forEach
(
function
(
fiber
)
{
componentWillUpdateUniqueNames
.
add
(
getComponentName
(
fiber
.
type
)
|
|
'
Component
'
)
;
didWarnAboutUnsafeLifecycles
.
add
(
fiber
.
type
)
;
}
)
;
pendingComponentWillUpdateWarnings
=
[
]
;
}
var
UNSAFE_componentWillUpdateUniqueNames
=
new
Set
(
)
;
if
(
pendingUNSAFE_ComponentWillUpdateWarnings
.
length
>
0
)
{
pendingUNSAFE_ComponentWillUpdateWarnings
.
forEach
(
function
(
fiber
)
{
UNSAFE_componentWillUpdateUniqueNames
.
add
(
getComponentName
(
fiber
.
type
)
|
|
'
Component
'
)
;
didWarnAboutUnsafeLifecycles
.
add
(
fiber
.
type
)
;
}
)
;
pendingUNSAFE_ComponentWillUpdateWarnings
=
[
]
;
}
if
(
UNSAFE_componentWillMountUniqueNames
.
size
>
0
)
{
var
sortedNames
=
setToSortedString
(
UNSAFE_componentWillMountUniqueNames
)
;
warningWithoutStack
1
(
false
'
Using
UNSAFE_componentWillMount
in
strict
mode
is
not
recommended
and
may
indicate
bugs
in
your
code
.
'
+
'
See
https
:
/
/
fb
.
me
/
react
-
unsafe
-
component
-
lifecycles
for
details
.
\
n
\
n
'
+
'
*
Move
code
with
side
effects
to
componentDidMount
and
set
initial
state
in
the
constructor
.
\
n
'
+
'
\
nPlease
update
the
following
components
:
%
s
'
sortedNames
)
;
}
if
(
UNSAFE_componentWillReceivePropsUniqueNames
.
size
>
0
)
{
var
_sortedNames
=
setToSortedString
(
UNSAFE_componentWillReceivePropsUniqueNames
)
;
warningWithoutStack
1
(
false
'
Using
UNSAFE_componentWillReceiveProps
in
strict
mode
is
not
recommended
'
+
'
and
may
indicate
bugs
in
your
code
.
'
+
'
See
https
:
/
/
fb
.
me
/
react
-
unsafe
-
component
-
lifecycles
for
details
.
\
n
\
n
'
+
'
*
Move
data
fetching
code
or
side
effects
to
componentDidUpdate
.
\
n
'
+
"
*
If
you
'
re
updating
state
whenever
props
change
"
+
'
refactor
your
code
to
use
memoization
techniques
or
move
it
to
'
+
'
static
getDerivedStateFromProps
.
Learn
more
at
:
https
:
/
/
fb
.
me
/
react
-
derived
-
state
\
n
'
+
'
\
nPlease
update
the
following
components
:
%
s
'
_sortedNames
)
;
}
if
(
UNSAFE_componentWillUpdateUniqueNames
.
size
>
0
)
{
var
_sortedNames2
=
setToSortedString
(
UNSAFE_componentWillUpdateUniqueNames
)
;
warningWithoutStack
1
(
false
'
Using
UNSAFE_componentWillUpdate
in
strict
mode
is
not
recommended
'
+
'
and
may
indicate
bugs
in
your
code
.
'
+
'
See
https
:
/
/
fb
.
me
/
react
-
unsafe
-
component
-
lifecycles
for
details
.
\
n
\
n
'
+
'
*
Move
data
fetching
code
or
side
effects
to
componentDidUpdate
.
\
n
'
+
'
\
nPlease
update
the
following
components
:
%
s
'
_sortedNames2
)
;
}
if
(
componentWillMountUniqueNames
.
size
>
0
)
{
var
_sortedNames3
=
setToSortedString
(
componentWillMountUniqueNames
)
;
lowPriorityWarningWithoutStack
1
(
false
'
componentWillMount
has
been
renamed
and
is
not
recommended
for
use
.
'
+
'
See
https
:
/
/
fb
.
me
/
react
-
unsafe
-
component
-
lifecycles
for
details
.
\
n
\
n
'
+
'
*
Move
code
with
side
effects
to
componentDidMount
and
set
initial
state
in
the
constructor
.
\
n
'
+
'
*
Rename
componentWillMount
to
UNSAFE_componentWillMount
to
suppress
'
+
'
this
warning
in
non
-
strict
mode
.
In
React
17
.
x
only
the
UNSAFE_
name
will
work
.
'
+
'
To
rename
all
deprecated
lifecycles
to
their
new
names
you
can
run
'
+
'
npx
react
-
codemod
rename
-
unsafe
-
lifecycles
in
your
project
source
folder
.
\
n
'
+
'
\
nPlease
update
the
following
components
:
%
s
'
_sortedNames3
)
;
}
if
(
componentWillReceivePropsUniqueNames
.
size
>
0
)
{
var
_sortedNames4
=
setToSortedString
(
componentWillReceivePropsUniqueNames
)
;
lowPriorityWarningWithoutStack
1
(
false
'
componentWillReceiveProps
has
been
renamed
and
is
not
recommended
for
use
.
'
+
'
See
https
:
/
/
fb
.
me
/
react
-
unsafe
-
component
-
lifecycles
for
details
.
\
n
\
n
'
+
'
*
Move
data
fetching
code
or
side
effects
to
componentDidUpdate
.
\
n
'
+
"
*
If
you
'
re
updating
state
whenever
props
change
refactor
your
"
+
'
code
to
use
memoization
techniques
or
move
it
to
'
+
'
static
getDerivedStateFromProps
.
Learn
more
at
:
https
:
/
/
fb
.
me
/
react
-
derived
-
state
\
n
'
+
'
*
Rename
componentWillReceiveProps
to
UNSAFE_componentWillReceiveProps
to
suppress
'
+
'
this
warning
in
non
-
strict
mode
.
In
React
17
.
x
only
the
UNSAFE_
name
will
work
.
'
+
'
To
rename
all
deprecated
lifecycles
to
their
new
names
you
can
run
'
+
'
npx
react
-
codemod
rename
-
unsafe
-
lifecycles
in
your
project
source
folder
.
\
n
'
+
'
\
nPlease
update
the
following
components
:
%
s
'
_sortedNames4
)
;
}
if
(
componentWillUpdateUniqueNames
.
size
>
0
)
{
var
_sortedNames5
=
setToSortedString
(
componentWillUpdateUniqueNames
)
;
lowPriorityWarningWithoutStack
1
(
false
'
componentWillUpdate
has
been
renamed
and
is
not
recommended
for
use
.
'
+
'
See
https
:
/
/
fb
.
me
/
react
-
unsafe
-
component
-
lifecycles
for
details
.
\
n
\
n
'
+
'
*
Move
data
fetching
code
or
side
effects
to
componentDidUpdate
.
\
n
'
+
'
*
Rename
componentWillUpdate
to
UNSAFE_componentWillUpdate
to
suppress
'
+
'
this
warning
in
non
-
strict
mode
.
In
React
17
.
x
only
the
UNSAFE_
name
will
work
.
'
+
'
To
rename
all
deprecated
lifecycles
to
their
new
names
you
can
run
'
+
'
npx
react
-
codemod
rename
-
unsafe
-
lifecycles
in
your
project
source
folder
.
\
n
'
+
'
\
nPlease
update
the
following
components
:
%
s
'
_sortedNames5
)
;
}
}
;
var
pendingLegacyContextWarning
=
new
Map
(
)
;
var
didWarnAboutLegacyContext
=
new
Set
(
)
;
ReactStrictModeWarnings
.
recordLegacyContextWarning
=
function
(
fiber
instance
)
{
var
strictRoot
=
findStrictRoot
(
fiber
)
;
if
(
strictRoot
=
=
=
null
)
{
warningWithoutStack
1
(
false
'
Expected
to
find
a
StrictMode
component
in
a
strict
mode
tree
.
'
+
'
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
'
)
;
return
;
}
if
(
didWarnAboutLegacyContext
.
has
(
fiber
.
type
)
)
{
return
;
}
var
warningsForRoot
=
pendingLegacyContextWarning
.
get
(
strictRoot
)
;
if
(
fiber
.
type
.
contextTypes
!
=
null
|
|
fiber
.
type
.
childContextTypes
!
=
null
|
|
instance
!
=
=
null
&
&
typeof
instance
.
getChildContext
=
=
=
'
function
'
)
{
if
(
warningsForRoot
=
=
=
undefined
)
{
warningsForRoot
=
[
]
;
pendingLegacyContextWarning
.
set
(
strictRoot
warningsForRoot
)
;
}
warningsForRoot
.
push
(
fiber
)
;
}
}
;
ReactStrictModeWarnings
.
flushLegacyContextWarning
=
function
(
)
{
pendingLegacyContextWarning
.
forEach
(
function
(
fiberArray
strictRoot
)
{
var
uniqueNames
=
new
Set
(
)
;
fiberArray
.
forEach
(
function
(
fiber
)
{
uniqueNames
.
add
(
getComponentName
(
fiber
.
type
)
|
|
'
Component
'
)
;
didWarnAboutLegacyContext
.
add
(
fiber
.
type
)
;
}
)
;
var
sortedNames
=
setToSortedString
(
uniqueNames
)
;
var
strictRootComponentStack
=
getStackByFiberInDevAndProd
(
strictRoot
)
;
warningWithoutStack
1
(
false
'
Legacy
context
API
has
been
detected
within
a
strict
-
mode
tree
.
'
+
'
\
n
\
nThe
old
API
will
be
supported
in
all
16
.
x
releases
but
applications
'
+
'
using
it
should
migrate
to
the
new
version
.
'
+
'
\
n
\
nPlease
update
the
following
components
:
%
s
'
+
'
\
n
\
nLearn
more
about
this
warning
here
:
https
:
/
/
fb
.
me
/
react
-
legacy
-
context
'
+
'
%
s
'
sortedNames
strictRootComponentStack
)
;
}
)
;
}
;
ReactStrictModeWarnings
.
discardPendingWarnings
=
function
(
)
{
pendingComponentWillMountWarnings
=
[
]
;
pendingUNSAFE_ComponentWillMountWarnings
=
[
]
;
pendingComponentWillReceivePropsWarnings
=
[
]
;
pendingUNSAFE_ComponentWillReceivePropsWarnings
=
[
]
;
pendingComponentWillUpdateWarnings
=
[
]
;
pendingUNSAFE_ComponentWillUpdateWarnings
=
[
]
;
pendingLegacyContextWarning
=
new
Map
(
)
;
}
;
}
var
resolveFamily
=
null
;
var
failedBoundaries
=
null
;
var
setRefreshHandler
=
function
(
handler
)
{
{
resolveFamily
=
handler
;
}
}
;
function
resolveFunctionForHotReloading
(
type
)
{
{
if
(
resolveFamily
=
=
=
null
)
{
return
type
;
}
var
family
=
resolveFamily
(
type
)
;
if
(
family
=
=
=
undefined
)
{
return
type
;
}
return
family
.
current
;
}
}
function
resolveClassForHotReloading
(
type
)
{
return
resolveFunctionForHotReloading
(
type
)
;
}
function
resolveForwardRefForHotReloading
(
type
)
{
{
if
(
resolveFamily
=
=
=
null
)
{
return
type
;
}
var
family
=
resolveFamily
(
type
)
;
if
(
family
=
=
=
undefined
)
{
if
(
type
!
=
=
null
&
&
type
!
=
=
undefined
&
&
typeof
type
.
render
=
=
=
'
function
'
)
{
var
currentRender
=
resolveFunctionForHotReloading
(
type
.
render
)
;
if
(
type
.
render
!
=
=
currentRender
)
{
var
syntheticType
=
{
typeof
:
REACT_FORWARD_REF_TYPE
render
:
currentRender
}
;
if
(
type
.
displayName
!
=
=
undefined
)
{
syntheticType
.
displayName
=
type
.
displayName
;
}
return
syntheticType
;
}
}
return
type
;
}
return
family
.
current
;
}
}
function
isCompatibleFamilyForHotReloading
(
fiber
element
)
{
{
if
(
resolveFamily
=
=
=
null
)
{
return
false
;
}
var
prevType
=
fiber
.
elementType
;
var
nextType
=
element
.
type
;
var
needsCompareFamilies
=
false
;
var
typeofNextType
=
typeof
nextType
=
=
=
'
object
'
&
&
nextType
!
=
=
null
?
nextType
.
typeof
:
null
;
switch
(
fiber
.
tag
)
{
case
ClassComponent
:
{
if
(
typeof
nextType
=
=
=
'
function
'
)
{
needsCompareFamilies
=
true
;
}
break
;
}
case
FunctionComponent
:
{
if
(
typeof
nextType
=
=
=
'
function
'
)
{
needsCompareFamilies
=
true
;
}
else
if
(
typeofNextType
=
=
=
REACT_LAZY_TYPE
)
{
needsCompareFamilies
=
true
;
}
break
;
}
case
ForwardRef
:
{
if
(
typeofNextType
=
=
=
REACT_FORWARD_REF_TYPE
)
{
needsCompareFamilies
=
true
;
}
else
if
(
typeofNextType
=
=
=
REACT_LAZY_TYPE
)
{
needsCompareFamilies
=
true
;
}
break
;
}
case
MemoComponent
:
case
SimpleMemoComponent
:
{
if
(
typeofNextType
=
=
=
REACT_MEMO_TYPE
)
{
needsCompareFamilies
=
true
;
}
else
if
(
typeofNextType
=
=
=
REACT_LAZY_TYPE
)
{
needsCompareFamilies
=
true
;
}
break
;
}
default
:
return
false
;
}
if
(
needsCompareFamilies
)
{
var
prevFamily
=
resolveFamily
(
prevType
)
;
if
(
prevFamily
!
=
=
undefined
&
&
prevFamily
=
=
=
resolveFamily
(
nextType
)
)
{
return
true
;
}
}
return
false
;
}
}
function
markFailedErrorBoundaryForHotReloading
(
fiber
)
{
{
if
(
resolveFamily
=
=
=
null
)
{
return
;
}
if
(
typeof
WeakSet
!
=
=
'
function
'
)
{
return
;
}
if
(
failedBoundaries
=
=
=
null
)
{
failedBoundaries
=
new
WeakSet
(
)
;
}
failedBoundaries
.
add
(
fiber
)
;
}
}
var
scheduleRefresh
=
function
(
root
update
)
{
{
if
(
resolveFamily
=
=
=
null
)
{
return
;
}
var
staleFamilies
=
update
.
staleFamilies
updatedFamilies
=
update
.
updatedFamilies
;
flushPassiveEffects
(
)
;
flushSync
(
function
(
)
{
scheduleFibersWithFamiliesRecursively
(
root
.
current
updatedFamilies
staleFamilies
)
;
}
)
;
}
}
;
var
scheduleRoot
=
function
(
root
element
)
{
{
if
(
root
.
context
!
=
=
emptyContextObject
)
{
return
;
}
flushPassiveEffects
(
)
;
syncUpdates
(
function
(
)
{
updateContainer
(
element
root
null
null
)
;
}
)
;
}
}
;
function
scheduleFibersWithFamiliesRecursively
(
fiber
updatedFamilies
staleFamilies
)
{
{
var
alternate
=
fiber
.
alternate
child
=
fiber
.
child
sibling
=
fiber
.
sibling
tag
=
fiber
.
tag
type
=
fiber
.
type
;
var
candidateType
=
null
;
switch
(
tag
)
{
case
FunctionComponent
:
case
SimpleMemoComponent
:
case
ClassComponent
:
candidateType
=
type
;
break
;
case
ForwardRef
:
candidateType
=
type
.
render
;
break
;
default
:
break
;
}
if
(
resolveFamily
=
=
=
null
)
{
throw
new
Error
(
'
Expected
resolveFamily
to
be
set
during
hot
reload
.
'
)
;
}
var
needsRender
=
false
;
var
needsRemount
=
false
;
if
(
candidateType
!
=
=
null
)
{
var
family
=
resolveFamily
(
candidateType
)
;
if
(
family
!
=
=
undefined
)
{
if
(
staleFamilies
.
has
(
family
)
)
{
needsRemount
=
true
;
}
else
if
(
updatedFamilies
.
has
(
family
)
)
{
if
(
tag
=
=
=
ClassComponent
)
{
needsRemount
=
true
;
}
else
{
needsRender
=
true
;
}
}
}
}
if
(
failedBoundaries
!
=
=
null
)
{
if
(
failedBoundaries
.
has
(
fiber
)
|
|
alternate
!
=
=
null
&
&
failedBoundaries
.
has
(
alternate
)
)
{
needsRemount
=
true
;
}
}
if
(
needsRemount
)
{
fiber
.
_debugNeedsRemount
=
true
;
}
if
(
needsRemount
|
|
needsRender
)
{
scheduleWork
(
fiber
Sync
)
;
}
if
(
child
!
=
=
null
&
&
!
needsRemount
)
{
scheduleFibersWithFamiliesRecursively
(
child
updatedFamilies
staleFamilies
)
;
}
if
(
sibling
!
=
=
null
)
{
scheduleFibersWithFamiliesRecursively
(
sibling
updatedFamilies
staleFamilies
)
;
}
}
}
var
findHostInstancesForRefresh
=
function
(
root
families
)
{
{
var
hostInstances
=
new
Set
(
)
;
var
types
=
new
Set
(
families
.
map
(
function
(
family
)
{
return
family
.
current
;
}
)
)
;
findHostInstancesForMatchingFibersRecursively
(
root
.
current
types
hostInstances
)
;
return
hostInstances
;
}
}
;
function
findHostInstancesForMatchingFibersRecursively
(
fiber
types
hostInstances
)
{
{
var
child
=
fiber
.
child
sibling
=
fiber
.
sibling
tag
=
fiber
.
tag
type
=
fiber
.
type
;
var
candidateType
=
null
;
switch
(
tag
)
{
case
FunctionComponent
:
case
SimpleMemoComponent
:
case
ClassComponent
:
candidateType
=
type
;
break
;
case
ForwardRef
:
candidateType
=
type
.
render
;
break
;
default
:
break
;
}
var
didMatch
=
false
;
if
(
candidateType
!
=
=
null
)
{
if
(
types
.
has
(
candidateType
)
)
{
didMatch
=
true
;
}
}
if
(
didMatch
)
{
findHostInstancesForFiberShallowly
(
fiber
hostInstances
)
;
}
else
{
if
(
child
!
=
=
null
)
{
findHostInstancesForMatchingFibersRecursively
(
child
types
hostInstances
)
;
}
}
if
(
sibling
!
=
=
null
)
{
findHostInstancesForMatchingFibersRecursively
(
sibling
types
hostInstances
)
;
}
}
}
function
findHostInstancesForFiberShallowly
(
fiber
hostInstances
)
{
{
var
foundHostInstances
=
findChildHostInstancesForFiberShallowly
(
fiber
hostInstances
)
;
if
(
foundHostInstances
)
{
return
;
}
var
node
=
fiber
;
while
(
true
)
{
switch
(
node
.
tag
)
{
case
HostComponent
:
hostInstances
.
add
(
node
.
stateNode
)
;
return
;
case
HostPortal
:
hostInstances
.
add
(
node
.
stateNode
.
containerInfo
)
;
return
;
case
HostRoot
:
hostInstances
.
add
(
node
.
stateNode
.
containerInfo
)
;
return
;
}
if
(
node
.
return
=
=
=
null
)
{
throw
new
Error
(
'
Expected
to
reach
root
first
.
'
)
;
}
node
=
node
.
return
;
}
}
}
function
findChildHostInstancesForFiberShallowly
(
fiber
hostInstances
)
{
{
var
node
=
fiber
;
var
foundHostInstances
=
false
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
)
{
foundHostInstances
=
true
;
hostInstances
.
add
(
node
.
stateNode
)
;
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
fiber
)
{
return
foundHostInstances
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
fiber
)
{
return
foundHostInstances
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
return
false
;
}
function
resolveDefaultProps
(
Component
baseProps
)
{
if
(
Component
&
&
Component
.
defaultProps
)
{
var
props
=
_assign
(
{
}
baseProps
)
;
var
defaultProps
=
Component
.
defaultProps
;
for
(
var
propName
in
defaultProps
)
{
if
(
props
[
propName
]
=
=
=
undefined
)
{
props
[
propName
]
=
defaultProps
[
propName
]
;
}
}
return
props
;
}
return
baseProps
;
}
function
readLazyComponentType
(
lazyComponent
)
{
initializeLazyComponentType
(
lazyComponent
)
;
if
(
lazyComponent
.
_status
!
=
=
Resolved
)
{
throw
lazyComponent
.
_result
;
}
return
lazyComponent
.
_result
;
}
var
valueCursor
=
createCursor
(
null
)
;
var
rendererSigil
;
{
rendererSigil
=
{
}
;
}
var
currentlyRenderingFiber
=
null
;
var
lastContextDependency
=
null
;
var
lastContextWithAllBitsObserved
=
null
;
var
isDisallowedContextReadInDEV
=
false
;
function
resetContextDependencies
(
)
{
currentlyRenderingFiber
=
null
;
lastContextDependency
=
null
;
lastContextWithAllBitsObserved
=
null
;
{
isDisallowedContextReadInDEV
=
false
;
}
}
function
enterDisallowedContextReadInDEV
(
)
{
{
isDisallowedContextReadInDEV
=
true
;
}
}
function
exitDisallowedContextReadInDEV
(
)
{
{
isDisallowedContextReadInDEV
=
false
;
}
}
function
pushProvider
(
providerFiber
nextValue
)
{
var
context
=
providerFiber
.
type
.
_context
;
if
(
isPrimaryRenderer
)
{
push
(
valueCursor
context
.
_currentValue
providerFiber
)
;
context
.
_currentValue
=
nextValue
;
{
!
(
context
.
_currentRenderer
=
=
=
undefined
|
|
context
.
_currentRenderer
=
=
=
null
|
|
context
.
_currentRenderer
=
=
=
rendererSigil
)
?
warningWithoutStack
1
(
false
'
Detected
multiple
renderers
concurrently
rendering
the
'
+
'
same
context
provider
.
This
is
currently
unsupported
.
'
)
:
void
0
;
context
.
_currentRenderer
=
rendererSigil
;
}
}
else
{
push
(
valueCursor
context
.
_currentValue2
providerFiber
)
;
context
.
_currentValue2
=
nextValue
;
{
!
(
context
.
_currentRenderer2
=
=
=
undefined
|
|
context
.
_currentRenderer2
=
=
=
null
|
|
context
.
_currentRenderer2
=
=
=
rendererSigil
)
?
warningWithoutStack
1
(
false
'
Detected
multiple
renderers
concurrently
rendering
the
'
+
'
same
context
provider
.
This
is
currently
unsupported
.
'
)
:
void
0
;
context
.
_currentRenderer2
=
rendererSigil
;
}
}
}
function
popProvider
(
providerFiber
)
{
var
currentValue
=
valueCursor
.
current
;
pop
(
valueCursor
providerFiber
)
;
var
context
=
providerFiber
.
type
.
_context
;
if
(
isPrimaryRenderer
)
{
context
.
_currentValue
=
currentValue
;
}
else
{
context
.
_currentValue2
=
currentValue
;
}
}
function
calculateChangedBits
(
context
newValue
oldValue
)
{
if
(
is
1
(
oldValue
newValue
)
)
{
return
0
;
}
else
{
var
changedBits
=
typeof
context
.
_calculateChangedBits
=
=
=
'
function
'
?
context
.
_calculateChangedBits
(
oldValue
newValue
)
:
MAX_SIGNED_31_BIT_INT
;
{
!
(
(
changedBits
&
MAX_SIGNED_31_BIT_INT
)
=
=
=
changedBits
)
?
warning
1
(
false
'
calculateChangedBits
:
Expected
the
return
value
to
be
a
'
+
'
31
-
bit
integer
.
Instead
received
:
%
s
'
changedBits
)
:
void
0
;
}
return
changedBits
|
0
;
}
}
function
scheduleWorkOnParentPath
(
parent
renderExpirationTime
)
{
var
node
=
parent
;
while
(
node
!
=
=
null
)
{
var
alternate
=
node
.
alternate
;
if
(
node
.
childExpirationTime
<
renderExpirationTime
)
{
node
.
childExpirationTime
=
renderExpirationTime
;
if
(
alternate
!
=
=
null
&
&
alternate
.
childExpirationTime
<
renderExpirationTime
)
{
alternate
.
childExpirationTime
=
renderExpirationTime
;
}
}
else
if
(
alternate
!
=
=
null
&
&
alternate
.
childExpirationTime
<
renderExpirationTime
)
{
alternate
.
childExpirationTime
=
renderExpirationTime
;
}
else
{
break
;
}
node
=
node
.
return
;
}
}
function
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
{
var
fiber
=
workInProgress
.
child
;
if
(
fiber
!
=
=
null
)
{
fiber
.
return
=
workInProgress
;
}
while
(
fiber
!
=
=
null
)
{
var
nextFiber
=
void
0
;
var
list
=
fiber
.
dependencies
;
if
(
list
!
=
=
null
)
{
nextFiber
=
fiber
.
child
;
var
dependency
=
list
.
firstContext
;
while
(
dependency
!
=
=
null
)
{
if
(
dependency
.
context
=
=
=
context
&
&
(
dependency
.
observedBits
&
changedBits
)
!
=
=
0
)
{
if
(
fiber
.
tag
=
=
=
ClassComponent
)
{
var
update
=
createUpdate
(
renderExpirationTime
null
)
;
update
.
tag
=
ForceUpdate
;
enqueueUpdate
(
fiber
update
)
;
}
if
(
fiber
.
expirationTime
<
renderExpirationTime
)
{
fiber
.
expirationTime
=
renderExpirationTime
;
}
var
alternate
=
fiber
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
.
expirationTime
<
renderExpirationTime
)
{
alternate
.
expirationTime
=
renderExpirationTime
;
}
scheduleWorkOnParentPath
(
fiber
.
return
renderExpirationTime
)
;
if
(
list
.
expirationTime
<
renderExpirationTime
)
{
list
.
expirationTime
=
renderExpirationTime
;
}
break
;
}
dependency
=
dependency
.
next
;
}
}
else
if
(
fiber
.
tag
=
=
=
ContextProvider
)
{
nextFiber
=
fiber
.
type
=
=
=
workInProgress
.
type
?
null
:
fiber
.
child
;
}
else
if
(
enableSuspenseServerRenderer
&
&
fiber
.
tag
=
=
=
DehydratedFragment
)
{
var
parentSuspense
=
fiber
.
return
;
if
(
!
(
parentSuspense
!
=
=
null
)
)
{
{
throw
Error
(
"
We
just
came
from
a
parent
so
we
must
have
had
a
parent
.
This
is
a
bug
in
React
.
"
)
;
}
}
if
(
parentSuspense
.
expirationTime
<
renderExpirationTime
)
{
parentSuspense
.
expirationTime
=
renderExpirationTime
;
}
var
_alternate
=
parentSuspense
.
alternate
;
if
(
_alternate
!
=
=
null
&
&
_alternate
.
expirationTime
<
renderExpirationTime
)
{
_alternate
.
expirationTime
=
renderExpirationTime
;
}
scheduleWorkOnParentPath
(
parentSuspense
renderExpirationTime
)
;
nextFiber
=
fiber
.
sibling
;
}
else
{
nextFiber
=
fiber
.
child
;
}
if
(
nextFiber
!
=
=
null
)
{
nextFiber
.
return
=
fiber
;
}
else
{
nextFiber
=
fiber
;
while
(
nextFiber
!
=
=
null
)
{
if
(
nextFiber
=
=
=
workInProgress
)
{
nextFiber
=
null
;
break
;
}
var
sibling
=
nextFiber
.
sibling
;
if
(
sibling
!
=
=
null
)
{
sibling
.
return
=
nextFiber
.
return
;
nextFiber
=
sibling
;
break
;
}
nextFiber
=
nextFiber
.
return
;
}
}
fiber
=
nextFiber
;
}
}
function
prepareToReadContext
(
workInProgress
renderExpirationTime
)
{
currentlyRenderingFiber
=
workInProgress
;
lastContextDependency
=
null
;
lastContextWithAllBitsObserved
=
null
;
var
dependencies
=
workInProgress
.
dependencies
;
if
(
dependencies
!
=
=
null
)
{
var
firstContext
=
dependencies
.
firstContext
;
if
(
firstContext
!
=
=
null
)
{
if
(
dependencies
.
expirationTime
>
=
renderExpirationTime
)
{
markWorkInProgressReceivedUpdate
(
)
;
}
dependencies
.
firstContext
=
null
;
}
}
}
function
readContext
(
context
observedBits
)
{
{
!
!
isDisallowedContextReadInDEV
?
warning
1
(
false
'
Context
can
only
be
read
while
React
is
rendering
.
'
+
'
In
classes
you
can
read
it
in
the
render
method
or
getDerivedStateFromProps
.
'
+
'
In
function
components
you
can
read
it
directly
in
the
function
body
but
not
'
+
'
inside
Hooks
like
useReducer
(
)
or
useMemo
(
)
.
'
)
:
void
0
;
}
if
(
lastContextWithAllBitsObserved
=
=
=
context
)
{
}
else
if
(
observedBits
=
=
=
false
|
|
observedBits
=
=
=
0
)
{
}
else
{
var
resolvedObservedBits
;
if
(
typeof
observedBits
!
=
=
'
number
'
|
|
observedBits
=
=
=
MAX_SIGNED_31_BIT_INT
)
{
lastContextWithAllBitsObserved
=
context
;
resolvedObservedBits
=
MAX_SIGNED_31_BIT_INT
;
}
else
{
resolvedObservedBits
=
observedBits
;
}
var
contextItem
=
{
context
:
context
observedBits
:
resolvedObservedBits
next
:
null
}
;
if
(
lastContextDependency
=
=
=
null
)
{
if
(
!
(
currentlyRenderingFiber
!
=
=
null
)
)
{
{
throw
Error
(
"
Context
can
only
be
read
while
React
is
rendering
.
In
classes
you
can
read
it
in
the
render
method
or
getDerivedStateFromProps
.
In
function
components
you
can
read
it
directly
in
the
function
body
but
not
inside
Hooks
like
useReducer
(
)
or
useMemo
(
)
.
"
)
;
}
}
lastContextDependency
=
contextItem
;
currentlyRenderingFiber
.
dependencies
=
{
expirationTime
:
NoWork
firstContext
:
contextItem
responders
:
null
}
;
}
else
{
lastContextDependency
=
lastContextDependency
.
next
=
contextItem
;
}
}
return
isPrimaryRenderer
?
context
.
_currentValue
:
context
.
_currentValue2
;
}
var
UpdateState
=
0
;
var
ReplaceState
=
1
;
var
ForceUpdate
=
2
;
var
CaptureUpdate
=
3
;
var
hasForceUpdate
=
false
;
var
didWarnUpdateInsideUpdate
;
var
currentlyProcessingQueue
;
{
didWarnUpdateInsideUpdate
=
false
;
currentlyProcessingQueue
=
null
;
}
function
createUpdateQueue
(
baseState
)
{
var
queue
=
{
baseState
:
baseState
firstUpdate
:
null
lastUpdate
:
null
firstCapturedUpdate
:
null
lastCapturedUpdate
:
null
firstEffect
:
null
lastEffect
:
null
firstCapturedEffect
:
null
lastCapturedEffect
:
null
}
;
return
queue
;
}
function
cloneUpdateQueue
(
currentQueue
)
{
var
queue
=
{
baseState
:
currentQueue
.
baseState
firstUpdate
:
currentQueue
.
firstUpdate
lastUpdate
:
currentQueue
.
lastUpdate
firstCapturedUpdate
:
null
lastCapturedUpdate
:
null
firstEffect
:
null
lastEffect
:
null
firstCapturedEffect
:
null
lastCapturedEffect
:
null
}
;
return
queue
;
}
function
createUpdate
(
expirationTime
suspenseConfig
)
{
var
update
=
{
expirationTime
:
expirationTime
suspenseConfig
:
suspenseConfig
tag
:
UpdateState
payload
:
null
callback
:
null
next
:
null
nextEffect
:
null
}
;
{
update
.
priority
=
getCurrentPriorityLevel
(
)
;
}
return
update
;
}
function
appendUpdateToQueue
(
queue
update
)
{
if
(
queue
.
lastUpdate
=
=
=
null
)
{
queue
.
firstUpdate
=
queue
.
lastUpdate
=
update
;
}
else
{
queue
.
lastUpdate
.
next
=
update
;
queue
.
lastUpdate
=
update
;
}
}
function
enqueueUpdate
(
fiber
update
)
{
var
alternate
=
fiber
.
alternate
;
var
queue1
;
var
queue2
;
if
(
alternate
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
;
queue2
=
null
;
if
(
queue1
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
fiber
.
memoizedState
)
;
}
}
else
{
queue1
=
fiber
.
updateQueue
;
queue2
=
alternate
.
updateQueue
;
if
(
queue1
=
=
=
null
)
{
if
(
queue2
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
fiber
.
memoizedState
)
;
queue2
=
alternate
.
updateQueue
=
createUpdateQueue
(
alternate
.
memoizedState
)
;
}
else
{
queue1
=
fiber
.
updateQueue
=
cloneUpdateQueue
(
queue2
)
;
}
}
else
{
if
(
queue2
=
=
=
null
)
{
queue2
=
alternate
.
updateQueue
=
cloneUpdateQueue
(
queue1
)
;
}
else
{
}
}
}
if
(
queue2
=
=
=
null
|
|
queue1
=
=
=
queue2
)
{
appendUpdateToQueue
(
queue1
update
)
;
}
else
{
if
(
queue1
.
lastUpdate
=
=
=
null
|
|
queue2
.
lastUpdate
=
=
=
null
)
{
appendUpdateToQueue
(
queue1
update
)
;
appendUpdateToQueue
(
queue2
update
)
;
}
else
{
appendUpdateToQueue
(
queue1
update
)
;
queue2
.
lastUpdate
=
update
;
}
}
{
if
(
fiber
.
tag
=
=
=
ClassComponent
&
&
(
currentlyProcessingQueue
=
=
=
queue1
|
|
queue2
!
=
=
null
&
&
currentlyProcessingQueue
=
=
=
queue2
)
&
&
!
didWarnUpdateInsideUpdate
)
{
warningWithoutStack
1
(
false
'
An
update
(
setState
replaceState
or
forceUpdate
)
was
scheduled
'
+
'
from
inside
an
update
function
.
Update
functions
should
be
pure
'
+
'
with
zero
side
-
effects
.
Consider
using
componentDidUpdate
or
a
'
+
'
callback
.
'
)
;
didWarnUpdateInsideUpdate
=
true
;
}
}
}
function
enqueueCapturedUpdate
(
workInProgress
update
)
{
var
workInProgressQueue
=
workInProgress
.
updateQueue
;
if
(
workInProgressQueue
=
=
=
null
)
{
workInProgressQueue
=
workInProgress
.
updateQueue
=
createUpdateQueue
(
workInProgress
.
memoizedState
)
;
}
else
{
workInProgressQueue
=
ensureWorkInProgressQueueIsAClone
(
workInProgress
workInProgressQueue
)
;
}
if
(
workInProgressQueue
.
lastCapturedUpdate
=
=
=
null
)
{
workInProgressQueue
.
firstCapturedUpdate
=
workInProgressQueue
.
lastCapturedUpdate
=
update
;
}
else
{
workInProgressQueue
.
lastCapturedUpdate
.
next
=
update
;
workInProgressQueue
.
lastCapturedUpdate
=
update
;
}
}
function
ensureWorkInProgressQueueIsAClone
(
workInProgress
queue
)
{
var
current
=
workInProgress
.
alternate
;
if
(
current
!
=
=
null
)
{
if
(
queue
=
=
=
current
.
updateQueue
)
{
queue
=
workInProgress
.
updateQueue
=
cloneUpdateQueue
(
queue
)
;
}
}
return
queue
;
}
function
getStateFromUpdate
(
workInProgress
queue
update
prevState
nextProps
instance
)
{
switch
(
update
.
tag
)
{
case
ReplaceState
:
{
var
payload
=
update
.
payload
;
if
(
typeof
payload
=
=
=
'
function
'
)
{
{
enterDisallowedContextReadInDEV
(
)
;
if
(
debugRenderPhaseSideEffectsForStrictMode
&
&
workInProgress
.
mode
&
StrictMode
)
{
payload
.
call
(
instance
prevState
nextProps
)
;
}
}
var
nextState
=
payload
.
call
(
instance
prevState
nextProps
)
;
{
exitDisallowedContextReadInDEV
(
)
;
}
return
nextState
;
}
return
payload
;
}
case
CaptureUpdate
:
{
workInProgress
.
effectTag
=
workInProgress
.
effectTag
&
~
ShouldCapture
|
DidCapture
;
}
case
UpdateState
:
{
var
_payload
=
update
.
payload
;
var
partialState
;
if
(
typeof
_payload
=
=
=
'
function
'
)
{
{
enterDisallowedContextReadInDEV
(
)
;
if
(
debugRenderPhaseSideEffectsForStrictMode
&
&
workInProgress
.
mode
&
StrictMode
)
{
_payload
.
call
(
instance
prevState
nextProps
)
;
}
}
partialState
=
_payload
.
call
(
instance
prevState
nextProps
)
;
{
exitDisallowedContextReadInDEV
(
)
;
}
}
else
{
partialState
=
_payload
;
}
if
(
partialState
=
=
=
null
|
|
partialState
=
=
=
undefined
)
{
return
prevState
;
}
return
_assign
(
{
}
prevState
partialState
)
;
}
case
ForceUpdate
:
{
hasForceUpdate
=
true
;
return
prevState
;
}
}
return
prevState
;
}
function
processUpdateQueue
(
workInProgress
queue
props
instance
renderExpirationTime
)
{
hasForceUpdate
=
false
;
queue
=
ensureWorkInProgressQueueIsAClone
(
workInProgress
queue
)
;
{
currentlyProcessingQueue
=
queue
;
}
var
newBaseState
=
queue
.
baseState
;
var
newFirstUpdate
=
null
;
var
newExpirationTime
=
NoWork
;
var
update
=
queue
.
firstUpdate
;
var
resultState
=
newBaseState
;
while
(
update
!
=
=
null
)
{
var
updateExpirationTime
=
update
.
expirationTime
;
if
(
updateExpirationTime
<
renderExpirationTime
)
{
if
(
newFirstUpdate
=
=
=
null
)
{
newFirstUpdate
=
update
;
newBaseState
=
resultState
;
}
if
(
newExpirationTime
<
updateExpirationTime
)
{
newExpirationTime
=
updateExpirationTime
;
}
}
else
{
markRenderEventTimeAndConfig
(
updateExpirationTime
update
.
suspenseConfig
)
;
resultState
=
getStateFromUpdate
(
workInProgress
queue
update
resultState
props
instance
)
;
var
callback
=
update
.
callback
;
if
(
callback
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
update
.
nextEffect
=
null
;
if
(
queue
.
lastEffect
=
=
=
null
)
{
queue
.
firstEffect
=
queue
.
lastEffect
=
update
;
}
else
{
queue
.
lastEffect
.
nextEffect
=
update
;
queue
.
lastEffect
=
update
;
}
}
}
update
=
update
.
next
;
}
var
newFirstCapturedUpdate
=
null
;
update
=
queue
.
firstCapturedUpdate
;
while
(
update
!
=
=
null
)
{
var
_updateExpirationTime
=
update
.
expirationTime
;
if
(
_updateExpirationTime
<
renderExpirationTime
)
{
if
(
newFirstCapturedUpdate
=
=
=
null
)
{
newFirstCapturedUpdate
=
update
;
if
(
newFirstUpdate
=
=
=
null
)
{
newBaseState
=
resultState
;
}
}
if
(
newExpirationTime
<
_updateExpirationTime
)
{
newExpirationTime
=
_updateExpirationTime
;
}
}
else
{
resultState
=
getStateFromUpdate
(
workInProgress
queue
update
resultState
props
instance
)
;
var
_callback
=
update
.
callback
;
if
(
_callback
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
update
.
nextEffect
=
null
;
if
(
queue
.
lastCapturedEffect
=
=
=
null
)
{
queue
.
firstCapturedEffect
=
queue
.
lastCapturedEffect
=
update
;
}
else
{
queue
.
lastCapturedEffect
.
nextEffect
=
update
;
queue
.
lastCapturedEffect
=
update
;
}
}
}
update
=
update
.
next
;
}
if
(
newFirstUpdate
=
=
=
null
)
{
queue
.
lastUpdate
=
null
;
}
if
(
newFirstCapturedUpdate
=
=
=
null
)
{
queue
.
lastCapturedUpdate
=
null
;
}
else
{
workInProgress
.
effectTag
|
=
Callback
;
}
if
(
newFirstUpdate
=
=
=
null
&
&
newFirstCapturedUpdate
=
=
=
null
)
{
newBaseState
=
resultState
;
}
queue
.
baseState
=
newBaseState
;
queue
.
firstUpdate
=
newFirstUpdate
;
queue
.
firstCapturedUpdate
=
newFirstCapturedUpdate
;
markUnprocessedUpdateTime
(
newExpirationTime
)
;
workInProgress
.
expirationTime
=
newExpirationTime
;
workInProgress
.
memoizedState
=
resultState
;
{
currentlyProcessingQueue
=
null
;
}
}
function
callCallback
(
callback
context
)
{
if
(
!
(
typeof
callback
=
=
=
'
function
'
)
)
{
{
throw
Error
(
"
Invalid
argument
passed
as
callback
.
Expected
a
function
.
Instead
received
:
"
+
callback
)
;
}
}
callback
.
call
(
context
)
;
}
function
resetHasForceUpdateBeforeProcessing
(
)
{
hasForceUpdate
=
false
;
}
function
checkHasForceUpdateAfterProcessing
(
)
{
return
hasForceUpdate
;
}
function
commitUpdateQueue
(
finishedWork
finishedQueue
instance
renderExpirationTime
)
{
if
(
finishedQueue
.
firstCapturedUpdate
!
=
=
null
)
{
if
(
finishedQueue
.
lastUpdate
!
=
=
null
)
{
finishedQueue
.
lastUpdate
.
next
=
finishedQueue
.
firstCapturedUpdate
;
finishedQueue
.
lastUpdate
=
finishedQueue
.
lastCapturedUpdate
;
}
finishedQueue
.
firstCapturedUpdate
=
finishedQueue
.
lastCapturedUpdate
=
null
;
}
commitUpdateEffects
(
finishedQueue
.
firstEffect
instance
)
;
finishedQueue
.
firstEffect
=
finishedQueue
.
lastEffect
=
null
;
commitUpdateEffects
(
finishedQueue
.
firstCapturedEffect
instance
)
;
finishedQueue
.
firstCapturedEffect
=
finishedQueue
.
lastCapturedEffect
=
null
;
}
function
commitUpdateEffects
(
effect
instance
)
{
while
(
effect
!
=
=
null
)
{
var
callback
=
effect
.
callback
;
if
(
callback
!
=
=
null
)
{
effect
.
callback
=
null
;
callCallback
(
callback
instance
)
;
}
effect
=
effect
.
nextEffect
;
}
}
var
ReactCurrentBatchConfig
=
ReactSharedInternals
.
ReactCurrentBatchConfig
;
function
requestCurrentSuspenseConfig
(
)
{
return
ReactCurrentBatchConfig
.
suspense
;
}
var
fakeInternalInstance
=
{
}
;
var
isArray
1
=
Array
.
isArray
;
var
emptyRefsObject
=
new
React
.
Component
(
)
.
refs
;
var
didWarnAboutStateAssignmentForComponent
;
var
didWarnAboutUninitializedState
;
var
didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
;
var
didWarnAboutLegacyLifecyclesAndDerivedState
;
var
didWarnAboutUndefinedDerivedState
;
var
warnOnUndefinedDerivedState
;
var
warnOnInvalidCallback
1
;
var
didWarnAboutDirectlyAssigningPropsToState
;
var
didWarnAboutContextTypeAndContextTypes
;
var
didWarnAboutInvalidateContextType
;
{
didWarnAboutStateAssignmentForComponent
=
new
Set
(
)
;
didWarnAboutUninitializedState
=
new
Set
(
)
;
didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
=
new
Set
(
)
;
didWarnAboutLegacyLifecyclesAndDerivedState
=
new
Set
(
)
;
didWarnAboutDirectlyAssigningPropsToState
=
new
Set
(
)
;
didWarnAboutUndefinedDerivedState
=
new
Set
(
)
;
didWarnAboutContextTypeAndContextTypes
=
new
Set
(
)
;
didWarnAboutInvalidateContextType
=
new
Set
(
)
;
var
didWarnOnInvalidCallback
=
new
Set
(
)
;
warnOnInvalidCallback
1
=
function
(
callback
callerName
)
{
if
(
callback
=
=
=
null
|
|
typeof
callback
=
=
=
'
function
'
)
{
return
;
}
var
key
=
callerName
+
"
_
"
+
callback
;
if
(
!
didWarnOnInvalidCallback
.
has
(
key
)
)
{
didWarnOnInvalidCallback
.
add
(
key
)
;
warningWithoutStack
1
(
false
'
%
s
(
.
.
.
)
:
Expected
the
last
optional
callback
argument
to
be
a
'
+
'
function
.
Instead
received
:
%
s
.
'
callerName
callback
)
;
}
}
;
warnOnUndefinedDerivedState
=
function
(
type
partialState
)
{
if
(
partialState
=
=
=
undefined
)
{
var
componentName
=
getComponentName
(
type
)
|
|
'
Component
'
;
if
(
!
didWarnAboutUndefinedDerivedState
.
has
(
componentName
)
)
{
didWarnAboutUndefinedDerivedState
.
add
(
componentName
)
;
warningWithoutStack
1
(
false
'
%
s
.
getDerivedStateFromProps
(
)
:
A
valid
state
object
(
or
null
)
must
be
returned
.
'
+
'
You
have
returned
undefined
.
'
componentName
)
;
}
}
}
;
Object
.
defineProperty
(
fakeInternalInstance
'
_processChildContext
'
{
enumerable
:
false
value
:
function
(
)
{
{
{
throw
Error
(
"
_processChildContext
is
not
available
in
React
16
+
.
This
likely
means
you
have
multiple
copies
of
React
and
are
attempting
to
nest
a
React
15
tree
inside
a
React
16
tree
using
unstable_renderSubtreeIntoContainer
which
isn
'
t
supported
.
Try
to
make
sure
you
have
only
one
copy
of
React
(
and
ideally
switch
to
ReactDOM
.
createPortal
)
.
"
)
;
}
}
}
}
)
;
Object
.
freeze
(
fakeInternalInstance
)
;
}
function
applyDerivedStateFromProps
(
workInProgress
ctor
getDerivedStateFromProps
nextProps
)
{
var
prevState
=
workInProgress
.
memoizedState
;
{
if
(
debugRenderPhaseSideEffectsForStrictMode
&
&
workInProgress
.
mode
&
StrictMode
)
{
getDerivedStateFromProps
(
nextProps
prevState
)
;
}
}
var
partialState
=
getDerivedStateFromProps
(
nextProps
prevState
)
;
{
warnOnUndefinedDerivedState
(
ctor
partialState
)
;
}
var
memoizedState
=
partialState
=
=
=
null
|
|
partialState
=
=
=
undefined
?
prevState
:
_assign
(
{
}
prevState
partialState
)
;
workInProgress
.
memoizedState
=
memoizedState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
&
&
workInProgress
.
expirationTime
=
=
=
NoWork
)
{
updateQueue
.
baseState
=
memoizedState
;
}
}
var
classComponentUpdater
=
{
isMounted
:
isMounted
enqueueSetState
:
function
(
inst
payload
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
var
suspenseConfig
=
requestCurrentSuspenseConfig
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
suspenseConfig
)
;
var
update
=
createUpdate
(
expirationTime
suspenseConfig
)
;
update
.
payload
=
payload
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
{
warnOnInvalidCallback
1
(
callback
'
setState
'
)
;
}
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
enqueueReplaceState
:
function
(
inst
payload
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
var
suspenseConfig
=
requestCurrentSuspenseConfig
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
suspenseConfig
)
;
var
update
=
createUpdate
(
expirationTime
suspenseConfig
)
;
update
.
tag
=
ReplaceState
;
update
.
payload
=
payload
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
{
warnOnInvalidCallback
1
(
callback
'
replaceState
'
)
;
}
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
enqueueForceUpdate
:
function
(
inst
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
var
suspenseConfig
=
requestCurrentSuspenseConfig
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
suspenseConfig
)
;
var
update
=
createUpdate
(
expirationTime
suspenseConfig
)
;
update
.
tag
=
ForceUpdate
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
{
warnOnInvalidCallback
1
(
callback
'
forceUpdate
'
)
;
}
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
}
;
function
checkShouldComponentUpdate
(
workInProgress
ctor
oldProps
newProps
oldState
newState
nextContext
)
{
var
instance
=
workInProgress
.
stateNode
;
if
(
typeof
instance
.
shouldComponentUpdate
=
=
=
'
function
'
)
{
startPhaseTimer
(
workInProgress
'
shouldComponentUpdate
'
)
;
var
shouldUpdate
=
instance
.
shouldComponentUpdate
(
newProps
newState
nextContext
)
;
stopPhaseTimer
(
)
;
{
!
(
shouldUpdate
!
=
=
undefined
)
?
warningWithoutStack
1
(
false
'
%
s
.
shouldComponentUpdate
(
)
:
Returned
undefined
instead
of
a
'
+
'
boolean
value
.
Make
sure
to
return
true
or
false
.
'
getComponentName
(
ctor
)
|
|
'
Component
'
)
:
void
0
;
}
return
shouldUpdate
;
}
if
(
ctor
.
prototype
&
&
ctor
.
prototype
.
isPureReactComponent
)
{
return
!
shallowEqual
(
oldProps
newProps
)
|
|
!
shallowEqual
(
oldState
newState
)
;
}
return
true
;
}
function
checkClassInstance
(
workInProgress
ctor
newProps
)
{
var
instance
=
workInProgress
.
stateNode
;
{
var
name
=
getComponentName
(
ctor
)
|
|
'
Component
'
;
var
renderPresent
=
instance
.
render
;
if
(
!
renderPresent
)
{
if
(
ctor
.
prototype
&
&
typeof
ctor
.
prototype
.
render
=
=
=
'
function
'
)
{
warningWithoutStack
1
(
false
'
%
s
(
.
.
.
)
:
No
render
method
found
on
the
returned
component
'
+
'
instance
:
did
you
accidentally
return
an
object
from
the
constructor
?
'
name
)
;
}
else
{
warningWithoutStack
1
(
false
'
%
s
(
.
.
.
)
:
No
render
method
found
on
the
returned
component
'
+
'
instance
:
you
may
have
forgotten
to
define
render
.
'
name
)
;
}
}
var
noGetInitialStateOnES6
=
!
instance
.
getInitialState
|
|
instance
.
getInitialState
.
isReactClassApproved
|
|
instance
.
state
;
!
noGetInitialStateOnES6
?
warningWithoutStack
1
(
false
'
getInitialState
was
defined
on
%
s
a
plain
JavaScript
class
.
'
+
'
This
is
only
supported
for
classes
created
using
React
.
createClass
.
'
+
'
Did
you
mean
to
define
a
state
property
instead
?
'
name
)
:
void
0
;
var
noGetDefaultPropsOnES6
=
!
instance
.
getDefaultProps
|
|
instance
.
getDefaultProps
.
isReactClassApproved
;
!
noGetDefaultPropsOnES6
?
warningWithoutStack
1
(
false
'
getDefaultProps
was
defined
on
%
s
a
plain
JavaScript
class
.
'
+
'
This
is
only
supported
for
classes
created
using
React
.
createClass
.
'
+
'
Use
a
static
property
to
define
defaultProps
instead
.
'
name
)
:
void
0
;
var
noInstancePropTypes
=
!
instance
.
propTypes
;
!
noInstancePropTypes
?
warningWithoutStack
1
(
false
'
propTypes
was
defined
as
an
instance
property
on
%
s
.
Use
a
static
'
+
'
property
to
define
propTypes
instead
.
'
name
)
:
void
0
;
var
noInstanceContextType
=
!
instance
.
contextType
;
!
noInstanceContextType
?
warningWithoutStack
1
(
false
'
contextType
was
defined
as
an
instance
property
on
%
s
.
Use
a
static
'
+
'
property
to
define
contextType
instead
.
'
name
)
:
void
0
;
if
(
disableLegacyContext
)
{
if
(
ctor
.
childContextTypes
)
{
warningWithoutStack
1
(
false
'
%
s
uses
the
legacy
childContextTypes
API
which
is
no
longer
supported
.
'
+
'
Use
React
.
createContext
(
)
instead
.
'
name
)
;
}
if
(
ctor
.
contextTypes
)
{
warningWithoutStack
1
(
false
'
%
s
uses
the
legacy
contextTypes
API
which
is
no
longer
supported
.
'
+
'
Use
React
.
createContext
(
)
with
static
contextType
instead
.
'
name
)
;
}
}
else
{
var
noInstanceContextTypes
=
!
instance
.
contextTypes
;
!
noInstanceContextTypes
?
warningWithoutStack
1
(
false
'
contextTypes
was
defined
as
an
instance
property
on
%
s
.
Use
a
static
'
+
'
property
to
define
contextTypes
instead
.
'
name
)
:
void
0
;
if
(
ctor
.
contextType
&
&
ctor
.
contextTypes
&
&
!
didWarnAboutContextTypeAndContextTypes
.
has
(
ctor
)
)
{
didWarnAboutContextTypeAndContextTypes
.
add
(
ctor
)
;
warningWithoutStack
1
(
false
'
%
s
declares
both
contextTypes
and
contextType
static
properties
.
'
+
'
The
legacy
contextTypes
property
will
be
ignored
.
'
name
)
;
}
}
var
noComponentShouldUpdate
=
typeof
instance
.
componentShouldUpdate
!
=
=
'
function
'
;
!
noComponentShouldUpdate
?
warningWithoutStack
1
(
false
'
%
s
has
a
method
called
'
+
'
componentShouldUpdate
(
)
.
Did
you
mean
shouldComponentUpdate
(
)
?
'
+
'
The
name
is
phrased
as
a
question
because
the
function
is
'
+
'
expected
to
return
a
value
.
'
name
)
:
void
0
;
if
(
ctor
.
prototype
&
&
ctor
.
prototype
.
isPureReactComponent
&
&
typeof
instance
.
shouldComponentUpdate
!
=
=
'
undefined
'
)
{
warningWithoutStack
1
(
false
'
%
s
has
a
method
called
shouldComponentUpdate
(
)
.
'
+
'
shouldComponentUpdate
should
not
be
used
when
extending
React
.
PureComponent
.
'
+
'
Please
extend
React
.
Component
if
shouldComponentUpdate
is
used
.
'
getComponentName
(
ctor
)
|
|
'
A
pure
component
'
)
;
}
var
noComponentDidUnmount
=
typeof
instance
.
componentDidUnmount
!
=
=
'
function
'
;
!
noComponentDidUnmount
?
warningWithoutStack
1
(
false
'
%
s
has
a
method
called
'
+
'
componentDidUnmount
(
)
.
But
there
is
no
such
lifecycle
method
.
'
+
'
Did
you
mean
componentWillUnmount
(
)
?
'
name
)
:
void
0
;
var
noComponentDidReceiveProps
=
typeof
instance
.
componentDidReceiveProps
!
=
=
'
function
'
;
!
noComponentDidReceiveProps
?
warningWithoutStack
1
(
false
'
%
s
has
a
method
called
'
+
'
componentDidReceiveProps
(
)
.
But
there
is
no
such
lifecycle
method
.
'
+
'
If
you
meant
to
update
the
state
in
response
to
changing
props
'
+
'
use
componentWillReceiveProps
(
)
.
If
you
meant
to
fetch
data
or
'
+
'
run
side
-
effects
or
mutations
after
React
has
updated
the
UI
use
componentDidUpdate
(
)
.
'
name
)
:
void
0
;
var
noComponentWillRecieveProps
=
typeof
instance
.
componentWillRecieveProps
!
=
=
'
function
'
;
!
noComponentWillRecieveProps
?
warningWithoutStack
1
(
false
'
%
s
has
a
method
called
'
+
'
componentWillRecieveProps
(
)
.
Did
you
mean
componentWillReceiveProps
(
)
?
'
name
)
:
void
0
;
var
noUnsafeComponentWillRecieveProps
=
typeof
instance
.
UNSAFE_componentWillRecieveProps
!
=
=
'
function
'
;
!
noUnsafeComponentWillRecieveProps
?
warningWithoutStack
1
(
false
'
%
s
has
a
method
called
'
+
'
UNSAFE_componentWillRecieveProps
(
)
.
Did
you
mean
UNSAFE_componentWillReceiveProps
(
)
?
'
name
)
:
void
0
;
var
hasMutatedProps
=
instance
.
props
!
=
=
newProps
;
!
(
instance
.
props
=
=
=
undefined
|
|
!
hasMutatedProps
)
?
warningWithoutStack
1
(
false
'
%
s
(
.
.
.
)
:
When
calling
super
(
)
in
%
s
make
sure
to
pass
'
+
"
up
the
same
props
that
your
component
'
s
constructor
was
passed
.
"
name
name
)
:
void
0
;
var
noInstanceDefaultProps
=
!
instance
.
defaultProps
;
!
noInstanceDefaultProps
?
warningWithoutStack
1
(
false
'
Setting
defaultProps
as
an
instance
property
on
%
s
is
not
supported
and
will
be
ignored
.
'
+
'
Instead
define
defaultProps
as
a
static
property
on
%
s
.
'
name
name
)
:
void
0
;
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
&
&
typeof
instance
.
componentDidUpdate
!
=
=
'
function
'
&
&
!
didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
.
has
(
ctor
)
)
{
didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
.
add
(
ctor
)
;
warningWithoutStack
1
(
false
'
%
s
:
getSnapshotBeforeUpdate
(
)
should
be
used
with
componentDidUpdate
(
)
.
'
+
'
This
component
defines
getSnapshotBeforeUpdate
(
)
only
.
'
getComponentName
(
ctor
)
)
;
}
var
noInstanceGetDerivedStateFromProps
=
typeof
instance
.
getDerivedStateFromProps
!
=
=
'
function
'
;
!
noInstanceGetDerivedStateFromProps
?
warningWithoutStack
1
(
false
'
%
s
:
getDerivedStateFromProps
(
)
is
defined
as
an
instance
method
'
+
'
and
will
be
ignored
.
Instead
declare
it
as
a
static
method
.
'
name
)
:
void
0
;
var
noInstanceGetDerivedStateFromCatch
=
typeof
instance
.
getDerivedStateFromError
!
=
=
'
function
'
;
!
noInstanceGetDerivedStateFromCatch
?
warningWithoutStack
1
(
false
'
%
s
:
getDerivedStateFromError
(
)
is
defined
as
an
instance
method
'
+
'
and
will
be
ignored
.
Instead
declare
it
as
a
static
method
.
'
name
)
:
void
0
;
var
noStaticGetSnapshotBeforeUpdate
=
typeof
ctor
.
getSnapshotBeforeUpdate
!
=
=
'
function
'
;
!
noStaticGetSnapshotBeforeUpdate
?
warningWithoutStack
1
(
false
'
%
s
:
getSnapshotBeforeUpdate
(
)
is
defined
as
a
static
method
'
+
'
and
will
be
ignored
.
Instead
declare
it
as
an
instance
method
.
'
name
)
:
void
0
;
var
_state
=
instance
.
state
;
if
(
_state
&
&
(
typeof
_state
!
=
=
'
object
'
|
|
isArray
1
(
_state
)
)
)
{
warningWithoutStack
1
(
false
'
%
s
.
state
:
must
be
set
to
an
object
or
null
'
name
)
;
}
if
(
typeof
instance
.
getChildContext
=
=
=
'
function
'
)
{
!
(
typeof
ctor
.
childContextTypes
=
=
=
'
object
'
)
?
warningWithoutStack
1
(
false
'
%
s
.
getChildContext
(
)
:
childContextTypes
must
be
defined
in
order
to
'
+
'
use
getChildContext
(
)
.
'
name
)
:
void
0
;
}
}
}
function
adoptClassInstance
(
workInProgress
instance
)
{
instance
.
updater
=
classComponentUpdater
;
workInProgress
.
stateNode
=
instance
;
set
(
instance
workInProgress
)
;
{
instance
.
_reactInternalInstance
=
fakeInternalInstance
;
}
}
function
constructClassInstance
(
workInProgress
ctor
props
renderExpirationTime
)
{
var
isLegacyContextConsumer
=
false
;
var
unmaskedContext
=
emptyContextObject
;
var
context
=
emptyContextObject
;
var
contextType
=
ctor
.
contextType
;
{
if
(
'
contextType
'
in
ctor
)
{
var
isValid
=
contextType
=
=
=
null
|
|
contextType
!
=
=
undefined
&
&
contextType
.
typeof
=
=
=
REACT_CONTEXT_TYPE
&
&
contextType
.
_context
=
=
=
undefined
;
if
(
!
isValid
&
&
!
didWarnAboutInvalidateContextType
.
has
(
ctor
)
)
{
didWarnAboutInvalidateContextType
.
add
(
ctor
)
;
var
addendum
=
'
'
;
if
(
contextType
=
=
=
undefined
)
{
addendum
=
'
However
it
is
set
to
undefined
.
'
+
'
This
can
be
caused
by
a
typo
or
by
mixing
up
named
and
default
imports
.
'
+
'
This
can
also
happen
due
to
a
circular
dependency
so
'
+
'
try
moving
the
createContext
(
)
call
to
a
separate
file
.
'
;
}
else
if
(
typeof
contextType
!
=
=
'
object
'
)
{
addendum
=
'
However
it
is
set
to
a
'
+
typeof
contextType
+
'
.
'
;
}
else
if
(
contextType
.
typeof
=
=
=
REACT_PROVIDER_TYPE
)
{
addendum
=
'
Did
you
accidentally
pass
the
Context
.
Provider
instead
?
'
;
}
else
if
(
contextType
.
_context
!
=
=
undefined
)
{
addendum
=
'
Did
you
accidentally
pass
the
Context
.
Consumer
instead
?
'
;
}
else
{
addendum
=
'
However
it
is
set
to
an
object
with
keys
{
'
+
Object
.
keys
(
contextType
)
.
join
(
'
'
)
+
'
}
.
'
;
}
warningWithoutStack
1
(
false
'
%
s
defines
an
invalid
contextType
.
'
+
'
contextType
should
point
to
the
Context
object
returned
by
React
.
createContext
(
)
.
%
s
'
getComponentName
(
ctor
)
|
|
'
Component
'
addendum
)
;
}
}
}
if
(
typeof
contextType
=
=
=
'
object
'
&
&
contextType
!
=
=
null
)
{
context
=
readContext
(
contextType
)
;
}
else
if
(
!
disableLegacyContext
)
{
unmaskedContext
=
getUnmaskedContext
(
workInProgress
ctor
true
)
;
var
contextTypes
=
ctor
.
contextTypes
;
isLegacyContextConsumer
=
contextTypes
!
=
=
null
&
&
contextTypes
!
=
=
undefined
;
context
=
isLegacyContextConsumer
?
getMaskedContext
(
workInProgress
unmaskedContext
)
:
emptyContextObject
;
}
{
if
(
debugRenderPhaseSideEffectsForStrictMode
&
&
workInProgress
.
mode
&
StrictMode
)
{
new
ctor
(
props
context
)
;
}
}
var
instance
=
new
ctor
(
props
context
)
;
var
state
=
workInProgress
.
memoizedState
=
instance
.
state
!
=
=
null
&
&
instance
.
state
!
=
=
undefined
?
instance
.
state
:
null
;
adoptClassInstance
(
workInProgress
instance
)
;
{
if
(
typeof
ctor
.
getDerivedStateFromProps
=
=
=
'
function
'
&
&
state
=
=
=
null
)
{
var
componentName
=
getComponentName
(
ctor
)
|
|
'
Component
'
;
if
(
!
didWarnAboutUninitializedState
.
has
(
componentName
)
)
{
didWarnAboutUninitializedState
.
add
(
componentName
)
;
warningWithoutStack
1
(
false
'
%
s
uses
getDerivedStateFromProps
but
its
initial
state
is
'
+
'
%
s
.
This
is
not
recommended
.
Instead
define
the
initial
state
by
'
+
'
assigning
an
object
to
this
.
state
in
the
constructor
of
%
s
.
'
+
'
This
ensures
that
getDerivedStateFromProps
arguments
have
a
consistent
shape
.
'
componentName
instance
.
state
=
=
=
null
?
'
null
'
:
'
undefined
'
componentName
)
;
}
}
if
(
typeof
ctor
.
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
var
foundWillMountName
=
null
;
var
foundWillReceivePropsName
=
null
;
var
foundWillUpdateName
=
null
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
&
&
instance
.
componentWillMount
.
__suppressDeprecationWarning
!
=
=
true
)
{
foundWillMountName
=
'
componentWillMount
'
;
}
else
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
foundWillMountName
=
'
UNSAFE_componentWillMount
'
;
}
if
(
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
&
&
instance
.
componentWillReceiveProps
.
__suppressDeprecationWarning
!
=
=
true
)
{
foundWillReceivePropsName
=
'
componentWillReceiveProps
'
;
}
else
if
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
)
{
foundWillReceivePropsName
=
'
UNSAFE_componentWillReceiveProps
'
;
}
if
(
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
&
&
instance
.
componentWillUpdate
.
__suppressDeprecationWarning
!
=
=
true
)
{
foundWillUpdateName
=
'
componentWillUpdate
'
;
}
else
if
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
)
{
foundWillUpdateName
=
'
UNSAFE_componentWillUpdate
'
;
}
if
(
foundWillMountName
!
=
=
null
|
|
foundWillReceivePropsName
!
=
=
null
|
|
foundWillUpdateName
!
=
=
null
)
{
var
_componentName
=
getComponentName
(
ctor
)
|
|
'
Component
'
;
var
newApiName
=
typeof
ctor
.
getDerivedStateFromProps
=
=
=
'
function
'
?
'
getDerivedStateFromProps
(
)
'
:
'
getSnapshotBeforeUpdate
(
)
'
;
if
(
!
didWarnAboutLegacyLifecyclesAndDerivedState
.
has
(
_componentName
)
)
{
didWarnAboutLegacyLifecyclesAndDerivedState
.
add
(
_componentName
)
;
warningWithoutStack
1
(
false
'
Unsafe
legacy
lifecycles
will
not
be
called
for
components
using
new
component
APIs
.
\
n
\
n
'
+
'
%
s
uses
%
s
but
also
contains
the
following
legacy
lifecycles
:
%
s
%
s
%
s
\
n
\
n
'
+
'
The
above
lifecycles
should
be
removed
.
Learn
more
about
this
warning
here
:
\
n
'
+
'
https
:
/
/
fb
.
me
/
react
-
unsafe
-
component
-
lifecycles
'
_componentName
newApiName
foundWillMountName
!
=
=
null
?
"
\
n
"
+
foundWillMountName
:
'
'
foundWillReceivePropsName
!
=
=
null
?
"
\
n
"
+
foundWillReceivePropsName
:
'
'
foundWillUpdateName
!
=
=
null
?
"
\
n
"
+
foundWillUpdateName
:
'
'
)
;
}
}
}
}
if
(
isLegacyContextConsumer
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
instance
;
}
function
callComponentWillMount
(
workInProgress
instance
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
var
oldState
=
instance
.
state
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
instance
.
componentWillMount
(
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillMount
(
)
;
}
stopPhaseTimer
(
)
;
if
(
oldState
!
=
=
instance
.
state
)
{
{
warningWithoutStack
1
(
false
'
%
s
.
componentWillMount
(
)
:
Assigning
directly
to
this
.
state
is
'
+
"
deprecated
(
except
inside
a
component
'
s
"
+
'
constructor
)
.
Use
setState
instead
.
'
getComponentName
(
workInProgress
.
type
)
|
|
'
Component
'
)
;
}
classComponentUpdater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
callComponentWillReceiveProps
(
workInProgress
instance
newProps
nextContext
)
{
var
oldState
=
instance
.
state
;
startPhaseTimer
(
workInProgress
'
componentWillReceiveProps
'
)
;
if
(
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
{
instance
.
componentWillReceiveProps
(
newProps
nextContext
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillReceiveProps
(
newProps
nextContext
)
;
}
stopPhaseTimer
(
)
;
if
(
instance
.
state
!
=
=
oldState
)
{
{
var
componentName
=
getComponentName
(
workInProgress
.
type
)
|
|
'
Component
'
;
if
(
!
didWarnAboutStateAssignmentForComponent
.
has
(
componentName
)
)
{
didWarnAboutStateAssignmentForComponent
.
add
(
componentName
)
;
warningWithoutStack
1
(
false
'
%
s
.
componentWillReceiveProps
(
)
:
Assigning
directly
to
'
+
"
this
.
state
is
deprecated
(
except
inside
a
component
'
s
"
+
'
constructor
)
.
Use
setState
instead
.
'
componentName
)
;
}
}
classComponentUpdater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
mountClassInstance
(
workInProgress
ctor
newProps
renderExpirationTime
)
{
{
checkClassInstance
(
workInProgress
ctor
newProps
)
;
}
var
instance
=
workInProgress
.
stateNode
;
instance
.
props
=
newProps
;
instance
.
state
=
workInProgress
.
memoizedState
;
instance
.
refs
=
emptyRefsObject
;
var
contextType
=
ctor
.
contextType
;
if
(
typeof
contextType
=
=
=
'
object
'
&
&
contextType
!
=
=
null
)
{
instance
.
context
=
readContext
(
contextType
)
;
}
else
if
(
disableLegacyContext
)
{
instance
.
context
=
emptyContextObject
;
}
else
{
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
ctor
true
)
;
instance
.
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
}
{
if
(
instance
.
state
=
=
=
newProps
)
{
var
componentName
=
getComponentName
(
ctor
)
|
|
'
Component
'
;
if
(
!
didWarnAboutDirectlyAssigningPropsToState
.
has
(
componentName
)
)
{
didWarnAboutDirectlyAssigningPropsToState
.
add
(
componentName
)
;
warningWithoutStack
1
(
false
'
%
s
:
It
is
not
recommended
to
assign
props
directly
to
state
'
+
"
because
updates
to
props
won
'
t
be
reflected
in
state
.
"
+
'
In
most
cases
it
is
better
to
use
props
directly
.
'
componentName
)
;
}
}
if
(
workInProgress
.
mode
&
StrictMode
)
{
ReactStrictModeWarnings
.
recordLegacyContextWarning
(
workInProgress
instance
)
;
}
if
(
warnAboutDeprecatedLifecycles
)
{
ReactStrictModeWarnings
.
recordUnsafeLifecycleWarnings
(
workInProgress
instance
)
;
}
}
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
ctor
getDerivedStateFromProps
newProps
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
if
(
typeof
ctor
.
getDerivedStateFromProps
!
=
=
'
function
'
&
&
typeof
instance
.
getSnapshotBeforeUpdate
!
=
=
'
function
'
&
&
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
)
{
callComponentWillMount
(
workInProgress
instance
)
;
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
function
resumeMountClassInstance
(
workInProgress
ctor
newProps
renderExpirationTime
)
{
var
instance
=
workInProgress
.
stateNode
;
var
oldProps
=
workInProgress
.
memoizedProps
;
instance
.
props
=
oldProps
;
var
oldContext
=
instance
.
context
;
var
contextType
=
ctor
.
contextType
;
var
nextContext
=
emptyContextObject
;
if
(
typeof
contextType
=
=
=
'
object
'
&
&
contextType
!
=
=
null
)
{
nextContext
=
readContext
(
contextType
)
;
}
else
if
(
!
disableLegacyContext
)
{
var
nextLegacyUnmaskedContext
=
getUnmaskedContext
(
workInProgress
ctor
true
)
;
nextContext
=
getMaskedContext
(
workInProgress
nextLegacyUnmaskedContext
)
;
}
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
var
hasNewLifecycles
=
typeof
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
;
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
)
{
if
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
nextContext
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
nextContext
)
;
}
}
resetHasForceUpdateBeforeProcessing
(
)
;
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
instance
.
state
=
oldState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
newState
=
workInProgress
.
memoizedState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
checkHasForceUpdateAfterProcessing
(
)
)
{
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
return
false
;
}
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
ctor
getDerivedStateFromProps
newProps
)
;
newState
=
workInProgress
.
memoizedState
;
}
var
shouldUpdate
=
checkHasForceUpdateAfterProcessing
(
)
|
|
checkShouldComponentUpdate
(
workInProgress
ctor
oldProps
newProps
oldState
newState
nextContext
)
;
if
(
shouldUpdate
)
{
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
instance
.
componentWillMount
(
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillMount
(
)
;
}
stopPhaseTimer
(
)
;
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
else
{
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
workInProgress
.
memoizedProps
=
newProps
;
workInProgress
.
memoizedState
=
newState
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
nextContext
;
return
shouldUpdate
;
}
function
updateClassInstance
(
current
workInProgress
ctor
newProps
renderExpirationTime
)
{
var
instance
=
workInProgress
.
stateNode
;
var
oldProps
=
workInProgress
.
memoizedProps
;
instance
.
props
=
workInProgress
.
type
=
=
=
workInProgress
.
elementType
?
oldProps
:
resolveDefaultProps
(
workInProgress
.
type
oldProps
)
;
var
oldContext
=
instance
.
context
;
var
contextType
=
ctor
.
contextType
;
var
nextContext
=
emptyContextObject
;
if
(
typeof
contextType
=
=
=
'
object
'
&
&
contextType
!
=
=
null
)
{
nextContext
=
readContext
(
contextType
)
;
}
else
if
(
!
disableLegacyContext
)
{
var
nextUnmaskedContext
=
getUnmaskedContext
(
workInProgress
ctor
true
)
;
nextContext
=
getMaskedContext
(
workInProgress
nextUnmaskedContext
)
;
}
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
var
hasNewLifecycles
=
typeof
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
;
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
)
{
if
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
nextContext
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
nextContext
)
;
}
}
resetHasForceUpdateBeforeProcessing
(
)
;
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
instance
.
state
=
oldState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
newState
=
workInProgress
.
memoizedState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
checkHasForceUpdateAfterProcessing
(
)
)
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
return
false
;
}
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
ctor
getDerivedStateFromProps
newProps
)
;
newState
=
workInProgress
.
memoizedState
;
}
var
shouldUpdate
=
checkHasForceUpdateAfterProcessing
(
)
|
|
checkShouldComponentUpdate
(
workInProgress
ctor
oldProps
newProps
oldState
newState
nextContext
)
;
if
(
shouldUpdate
)
{
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
)
{
startPhaseTimer
(
workInProgress
'
componentWillUpdate
'
)
;
if
(
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
{
instance
.
componentWillUpdate
(
newProps
newState
nextContext
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillUpdate
(
newProps
newState
nextContext
)
;
}
stopPhaseTimer
(
)
;
}
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
else
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
workInProgress
.
memoizedProps
=
newProps
;
workInProgress
.
memoizedState
=
newState
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
nextContext
;
return
shouldUpdate
;
}
var
didWarnAboutMaps
;
var
didWarnAboutGenerators
;
var
didWarnAboutStringRefs
;
var
ownerHasKeyUseWarning
;
var
ownerHasFunctionTypeWarning
;
var
warnForMissingKey
=
function
(
child
)
{
}
;
{
didWarnAboutMaps
=
false
;
didWarnAboutGenerators
=
false
;
didWarnAboutStringRefs
=
{
}
;
ownerHasKeyUseWarning
=
{
}
;
ownerHasFunctionTypeWarning
=
{
}
;
warnForMissingKey
=
function
(
child
)
{
if
(
child
=
=
=
null
|
|
typeof
child
!
=
=
'
object
'
)
{
return
;
}
if
(
!
child
.
_store
|
|
child
.
_store
.
validated
|
|
child
.
key
!
=
null
)
{
return
;
}
if
(
!
(
typeof
child
.
_store
=
=
=
'
object
'
)
)
{
{
throw
Error
(
"
React
Component
in
warnForMissingKey
should
have
a
_store
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
child
.
_store
.
validated
=
true
;
var
currentComponentErrorInfo
=
'
Each
child
in
a
list
should
have
a
unique
'
+
'
"
key
"
prop
.
See
https
:
/
/
fb
.
me
/
react
-
warning
-
keys
for
'
+
'
more
information
.
'
+
getCurrentFiberStackInDev
(
)
;
if
(
ownerHasKeyUseWarning
[
currentComponentErrorInfo
]
)
{
return
;
}
ownerHasKeyUseWarning
[
currentComponentErrorInfo
]
=
true
;
warning
1
(
false
'
Each
child
in
a
list
should
have
a
unique
'
+
'
"
key
"
prop
.
See
https
:
/
/
fb
.
me
/
react
-
warning
-
keys
for
'
+
'
more
information
.
'
)
;
}
;
}
var
isArray
=
Array
.
isArray
;
function
coerceRef
(
returnFiber
current
1
element
)
{
var
mixedRef
=
element
.
ref
;
if
(
mixedRef
!
=
=
null
&
&
typeof
mixedRef
!
=
=
'
function
'
&
&
typeof
mixedRef
!
=
=
'
object
'
)
{
{
if
(
returnFiber
.
mode
&
StrictMode
|
|
warnAboutStringRefs
)
{
var
componentName
=
getComponentName
(
returnFiber
.
type
)
|
|
'
Component
'
;
if
(
!
didWarnAboutStringRefs
[
componentName
]
)
{
if
(
warnAboutStringRefs
)
{
warningWithoutStack
1
(
false
'
Component
"
%
s
"
contains
the
string
ref
"
%
s
"
.
Support
for
string
refs
'
+
'
will
be
removed
in
a
future
major
release
.
We
recommend
using
'
+
'
useRef
(
)
or
createRef
(
)
instead
.
'
+
'
Learn
more
about
using
refs
safely
here
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
strict
-
mode
-
string
-
ref
%
s
'
componentName
mixedRef
getStackByFiberInDevAndProd
(
returnFiber
)
)
;
}
else
{
warningWithoutStack
1
(
false
'
A
string
ref
"
%
s
"
has
been
found
within
a
strict
mode
tree
.
'
+
'
String
refs
are
a
source
of
potential
bugs
and
should
be
avoided
.
'
+
'
We
recommend
using
useRef
(
)
or
createRef
(
)
instead
.
'
+
'
Learn
more
about
using
refs
safely
here
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
strict
-
mode
-
string
-
ref
%
s
'
mixedRef
getStackByFiberInDevAndProd
(
returnFiber
)
)
;
}
didWarnAboutStringRefs
[
componentName
]
=
true
;
}
}
}
if
(
element
.
_owner
)
{
var
owner
=
element
.
_owner
;
var
inst
;
if
(
owner
)
{
var
ownerFiber
=
owner
;
if
(
!
(
ownerFiber
.
tag
=
=
=
ClassComponent
)
)
{
{
throw
Error
(
"
Function
components
cannot
have
refs
.
Did
you
mean
to
use
React
.
forwardRef
(
)
?
"
)
;
}
}
inst
=
ownerFiber
.
stateNode
;
}
if
(
!
inst
)
{
{
throw
Error
(
"
Missing
owner
for
string
ref
"
+
mixedRef
+
"
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
var
stringRef
=
'
'
+
mixedRef
;
if
(
current
1
!
=
=
null
&
&
current
1
.
ref
!
=
=
null
&
&
typeof
current
1
.
ref
=
=
=
'
function
'
&
&
current
1
.
ref
.
_stringRef
=
=
=
stringRef
)
{
return
current
1
.
ref
;
}
var
ref
=
function
(
value
)
{
var
refs
=
inst
.
refs
;
if
(
refs
=
=
=
emptyRefsObject
)
{
refs
=
inst
.
refs
=
{
}
;
}
if
(
value
=
=
=
null
)
{
delete
refs
[
stringRef
]
;
}
else
{
refs
[
stringRef
]
=
value
;
}
}
;
ref
.
_stringRef
=
stringRef
;
return
ref
;
}
else
{
if
(
!
(
typeof
mixedRef
=
=
=
'
string
'
)
)
{
{
throw
Error
(
"
Expected
ref
to
be
a
function
a
string
an
object
returned
by
React
.
createRef
(
)
or
null
.
"
)
;
}
}
if
(
!
element
.
_owner
)
{
{
throw
Error
(
"
Element
ref
was
specified
as
a
string
(
"
+
mixedRef
+
"
)
but
no
owner
was
set
.
This
could
happen
for
one
of
the
following
reasons
:
\
n1
.
You
may
be
adding
a
ref
to
a
function
component
\
n2
.
You
may
be
adding
a
ref
to
a
component
that
was
not
created
inside
a
component
'
s
render
method
\
n3
.
You
have
multiple
copies
of
React
loaded
\
nSee
https
:
/
/
fb
.
me
/
react
-
refs
-
must
-
have
-
owner
for
more
information
.
"
)
;
}
}
}
}
return
mixedRef
;
}
function
throwOnInvalidObjectType
(
returnFiber
newChild
)
{
if
(
returnFiber
.
type
!
=
=
'
textarea
'
)
{
var
addendum
=
'
'
;
{
addendum
=
'
If
you
meant
to
render
a
collection
of
children
use
an
array
'
+
'
instead
.
'
+
getCurrentFiberStackInDev
(
)
;
}
{
{
throw
Error
(
"
Objects
are
not
valid
as
a
React
child
(
found
:
"
+
(
Object
.
prototype
.
toString
.
call
(
newChild
)
=
=
=
'
[
object
Object
]
'
?
'
object
with
keys
{
'
+
Object
.
keys
(
newChild
)
.
join
(
'
'
)
+
'
}
'
:
newChild
)
+
"
)
.
"
+
addendum
)
;
}
}
}
}
function
warnOnFunctionType
(
)
{
var
currentComponentErrorInfo
=
'
Functions
are
not
valid
as
a
React
child
.
This
may
happen
if
'
+
'
you
return
a
Component
instead
of
<
Component
/
>
from
render
.
'
+
'
Or
maybe
you
meant
to
call
this
function
rather
than
return
it
.
'
+
getCurrentFiberStackInDev
(
)
;
if
(
ownerHasFunctionTypeWarning
[
currentComponentErrorInfo
]
)
{
return
;
}
ownerHasFunctionTypeWarning
[
currentComponentErrorInfo
]
=
true
;
warning
1
(
false
'
Functions
are
not
valid
as
a
React
child
.
This
may
happen
if
'
+
'
you
return
a
Component
instead
of
<
Component
/
>
from
render
.
'
+
'
Or
maybe
you
meant
to
call
this
function
rather
than
return
it
.
'
)
;
}
function
ChildReconciler
(
shouldTrackSideEffects
)
{
function
deleteChild
(
returnFiber
childToDelete
)
{
if
(
!
shouldTrackSideEffects
)
{
return
;
}
var
last
=
returnFiber
.
lastEffect
;
if
(
last
!
=
=
null
)
{
last
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
childToDelete
.
nextEffect
=
null
;
childToDelete
.
effectTag
=
Deletion
;
}
function
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
{
if
(
!
shouldTrackSideEffects
)
{
return
null
;
}
var
childToDelete
=
currentFirstChild
;
while
(
childToDelete
!
=
=
null
)
{
deleteChild
(
returnFiber
childToDelete
)
;
childToDelete
=
childToDelete
.
sibling
;
}
return
null
;
}
function
mapRemainingChildren
(
returnFiber
currentFirstChild
)
{
var
existingChildren
=
new
Map
(
)
;
var
existingChild
=
currentFirstChild
;
while
(
existingChild
!
=
=
null
)
{
if
(
existingChild
.
key
!
=
=
null
)
{
existingChildren
.
set
(
existingChild
.
key
existingChild
)
;
}
else
{
existingChildren
.
set
(
existingChild
.
index
existingChild
)
;
}
existingChild
=
existingChild
.
sibling
;
}
return
existingChildren
;
}
function
useFiber
(
fiber
pendingProps
expirationTime
)
{
var
clone
=
createWorkInProgress
(
fiber
pendingProps
expirationTime
)
;
clone
.
index
=
0
;
clone
.
sibling
=
null
;
return
clone
;
}
function
placeChild
(
newFiber
lastPlacedIndex
newIndex
)
{
newFiber
.
index
=
newIndex
;
if
(
!
shouldTrackSideEffects
)
{
return
lastPlacedIndex
;
}
var
current
1
=
newFiber
.
alternate
;
if
(
current
1
!
=
=
null
)
{
var
oldIndex
=
current
1
.
index
;
if
(
oldIndex
<
lastPlacedIndex
)
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
else
{
return
oldIndex
;
}
}
else
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
}
function
placeSingleChild
(
newFiber
)
{
if
(
shouldTrackSideEffects
&
&
newFiber
.
alternate
=
=
=
null
)
{
newFiber
.
effectTag
=
Placement
;
}
return
newFiber
;
}
function
updateTextNode
(
returnFiber
current
1
textContent
expirationTime
)
{
if
(
current
1
=
=
=
null
|
|
current
1
.
tag
!
=
=
HostText
)
{
var
created
=
createFiberFromText
(
textContent
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
1
textContent
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
updateElement
(
returnFiber
current
1
element
expirationTime
)
{
if
(
current
1
!
=
=
null
&
&
(
current
1
.
elementType
=
=
=
element
.
type
|
|
(
isCompatibleFamilyForHotReloading
(
current
1
element
)
)
)
)
{
var
existing
=
useFiber
(
current
1
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
returnFiber
current
1
element
)
;
existing
.
return
=
returnFiber
;
{
existing
.
_debugSource
=
element
.
_source
;
existing
.
_debugOwner
=
element
.
_owner
;
}
return
existing
;
}
else
{
var
created
=
createFiberFromElement
(
element
returnFiber
.
mode
expirationTime
)
;
created
.
ref
=
coerceRef
(
returnFiber
current
1
element
)
;
created
.
return
=
returnFiber
;
return
created
;
}
}
function
updatePortal
(
returnFiber
current
1
portal
expirationTime
)
{
if
(
current
1
=
=
=
null
|
|
current
1
.
tag
!
=
=
HostPortal
|
|
current
1
.
stateNode
.
containerInfo
!
=
=
portal
.
containerInfo
|
|
current
1
.
stateNode
.
implementation
!
=
=
portal
.
implementation
)
{
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
1
portal
.
children
|
|
[
]
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
updateFragment
(
returnFiber
current
1
fragment
expirationTime
key
)
{
if
(
current
1
=
=
=
null
|
|
current
1
.
tag
!
=
=
Fragment
)
{
var
created
=
createFiberFromFragment
(
fragment
returnFiber
.
mode
expirationTime
key
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
1
fragment
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
createChild
(
returnFiber
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
created
=
createFiberFromText
(
'
'
+
newChild
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_created
=
createFiberFromElement
(
newChild
returnFiber
.
mode
expirationTime
)
;
_created
.
ref
=
coerceRef
(
returnFiber
null
newChild
)
;
_created
.
return
=
returnFiber
;
return
_created
;
}
case
REACT_PORTAL_TYPE
:
{
var
_created2
=
createFiberFromPortal
(
newChild
returnFiber
.
mode
expirationTime
)
;
_created2
.
return
=
returnFiber
;
return
_created2
;
}
}
if
(
isArray
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_created3
=
createFiberFromFragment
(
newChild
returnFiber
.
mode
expirationTime
null
)
;
_created3
.
return
=
returnFiber
;
return
_created3
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
{
if
(
typeof
newChild
=
=
=
'
function
'
)
{
warnOnFunctionType
(
)
;
}
}
return
null
;
}
function
updateSlot
(
returnFiber
oldFiber
newChild
expirationTime
)
{
var
key
=
oldFiber
!
=
=
null
?
oldFiber
.
key
:
null
;
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateTextNode
(
returnFiber
oldFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
oldFiber
newChild
.
props
.
children
expirationTime
key
)
;
}
return
updateElement
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
case
REACT_PORTAL_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
return
updatePortal
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
}
if
(
isArray
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateFragment
(
returnFiber
oldFiber
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
{
if
(
typeof
newChild
=
=
=
'
function
'
)
{
warnOnFunctionType
(
)
;
}
}
return
null
;
}
function
updateFromMap
(
existingChildren
returnFiber
newIdx
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
matchedFiber
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateTextNode
(
returnFiber
matchedFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_matchedFiber
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
_matchedFiber
newChild
.
props
.
children
expirationTime
newChild
.
key
)
;
}
return
updateElement
(
returnFiber
_matchedFiber
newChild
expirationTime
)
;
}
case
REACT_PORTAL_TYPE
:
{
var
_matchedFiber2
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
return
updatePortal
(
returnFiber
_matchedFiber2
newChild
expirationTime
)
;
}
}
if
(
isArray
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_matchedFiber3
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateFragment
(
returnFiber
_matchedFiber3
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
{
if
(
typeof
newChild
=
=
=
'
function
'
)
{
warnOnFunctionType
(
)
;
}
}
return
null
;
}
function
warnOnInvalidKey
(
child
knownKeys
)
{
{
if
(
typeof
child
!
=
=
'
object
'
|
|
child
=
=
=
null
)
{
return
knownKeys
;
}
switch
(
child
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
case
REACT_PORTAL_TYPE
:
warnForMissingKey
(
child
)
;
var
key
=
child
.
key
;
if
(
typeof
key
!
=
=
'
string
'
)
{
break
;
}
if
(
knownKeys
=
=
=
null
)
{
knownKeys
=
new
Set
(
)
;
knownKeys
.
add
(
key
)
;
break
;
}
if
(
!
knownKeys
.
has
(
key
)
)
{
knownKeys
.
add
(
key
)
;
break
;
}
warning
1
(
false
'
Encountered
two
children
with
the
same
key
%
s
.
'
+
'
Keys
should
be
unique
so
that
components
maintain
their
identity
'
+
'
across
updates
.
Non
-
unique
keys
may
cause
children
to
be
'
+
'
duplicated
and
/
or
omitted
the
behavior
is
unsupported
and
'
+
'
could
change
in
a
future
version
.
'
key
)
;
break
;
default
:
break
;
}
}
return
knownKeys
;
}
function
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChildren
expirationTime
)
{
{
var
knownKeys
=
null
;
for
(
var
i
=
0
;
i
<
newChildren
.
length
;
i
+
+
)
{
var
child
=
newChildren
[
i
]
;
knownKeys
=
warnOnInvalidKey
(
child
knownKeys
)
;
}
}
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
for
(
;
oldFiber
!
=
=
null
&
&
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
oldFiber
=
=
=
null
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
newIdx
=
=
=
newChildren
.
length
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber
=
createChild
(
returnFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
_newFiber
=
=
=
null
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber
;
}
previousNewFiber
=
_newFiber
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber2
=
updateFromMap
(
existingChildren
returnFiber
newIdx
newChildren
[
newIdx
]
expirationTime
)
;
if
(
_newFiber2
!
=
=
null
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber2
.
alternate
!
=
=
null
)
{
existingChildren
.
delete
(
_newFiber2
.
key
=
=
=
null
?
newIdx
:
_newFiber2
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber2
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber2
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber2
;
}
previousNewFiber
=
_newFiber2
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChildrenIterable
expirationTime
)
{
var
iteratorFn
=
getIteratorFn
(
newChildrenIterable
)
;
if
(
!
(
typeof
iteratorFn
=
=
=
'
function
'
)
)
{
{
throw
Error
(
"
An
object
is
not
an
iterable
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
{
if
(
typeof
Symbol
=
=
=
'
function
'
&
&
newChildrenIterable
[
Symbol
.
toStringTag
]
=
=
=
'
Generator
'
)
{
!
didWarnAboutGenerators
?
warning
1
(
false
'
Using
Generators
as
children
is
unsupported
and
will
likely
yield
'
+
'
unexpected
results
because
enumerating
a
generator
mutates
it
.
'
+
'
You
may
convert
it
to
an
array
with
Array
.
from
(
)
or
the
'
+
'
[
.
.
.
spread
]
operator
before
rendering
.
Keep
in
mind
'
+
'
you
might
need
to
polyfill
these
features
for
older
browsers
.
'
)
:
void
0
;
didWarnAboutGenerators
=
true
;
}
if
(
newChildrenIterable
.
entries
=
=
=
iteratorFn
)
{
!
didWarnAboutMaps
?
warning
1
(
false
'
Using
Maps
as
children
is
unsupported
and
will
likely
yield
'
+
'
unexpected
results
.
Convert
it
to
a
sequence
/
iterable
of
keyed
'
+
'
ReactElements
instead
.
'
)
:
void
0
;
didWarnAboutMaps
=
true
;
}
var
_newChildren
=
iteratorFn
.
call
(
newChildrenIterable
)
;
if
(
_newChildren
)
{
var
knownKeys
=
null
;
var
_step
=
_newChildren
.
next
(
)
;
for
(
;
!
_step
.
done
;
_step
=
_newChildren
.
next
(
)
)
{
var
child
=
_step
.
value
;
knownKeys
=
warnOnInvalidKey
(
child
knownKeys
)
;
}
}
}
var
newChildren
=
iteratorFn
.
call
(
newChildrenIterable
)
;
if
(
!
(
newChildren
!
=
null
)
)
{
{
throw
Error
(
"
An
iterable
object
provided
no
iterator
.
"
)
;
}
}
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
var
step
=
newChildren
.
next
(
)
;
for
(
;
oldFiber
!
=
=
null
&
&
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
step
.
value
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
oldFiber
=
=
=
null
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
step
.
done
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber3
=
createChild
(
returnFiber
step
.
value
expirationTime
)
;
if
(
_newFiber3
=
=
=
null
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber3
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber3
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber3
;
}
previousNewFiber
=
_newFiber3
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber4
=
updateFromMap
(
existingChildren
returnFiber
newIdx
step
.
value
expirationTime
)
;
if
(
_newFiber4
!
=
=
null
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber4
.
alternate
!
=
=
null
)
{
existingChildren
.
delete
(
_newFiber4
.
key
=
=
=
null
?
newIdx
:
_newFiber4
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber4
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber4
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber4
;
}
previousNewFiber
=
_newFiber4
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileSingleTextNode
(
returnFiber
currentFirstChild
textContent
expirationTime
)
{
if
(
currentFirstChild
!
=
=
null
&
&
currentFirstChild
.
tag
=
=
=
HostText
)
{
deleteRemainingChildren
(
returnFiber
currentFirstChild
.
sibling
)
;
var
existing
=
useFiber
(
currentFirstChild
textContent
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
var
created
=
createFiberFromText
(
textContent
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
function
reconcileSingleElement
(
returnFiber
currentFirstChild
element
expirationTime
)
{
var
key
=
element
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
Fragment
?
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
:
child
.
elementType
=
=
=
element
.
type
|
|
(
isCompatibleFamilyForHotReloading
(
child
element
)
)
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
?
element
.
props
.
children
:
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
returnFiber
child
element
)
;
existing
.
return
=
returnFiber
;
{
existing
.
_debugSource
=
element
.
_source
;
existing
.
_debugOwner
=
element
.
_owner
;
}
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
if
(
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
var
created
=
createFiberFromFragment
(
element
.
props
.
children
returnFiber
.
mode
expirationTime
element
.
key
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
_created4
=
createFiberFromElement
(
element
returnFiber
.
mode
expirationTime
)
;
_created4
.
ref
=
coerceRef
(
returnFiber
currentFirstChild
element
)
;
_created4
.
return
=
returnFiber
;
return
_created4
;
}
}
function
reconcileSinglePortal
(
returnFiber
currentFirstChild
portal
expirationTime
)
{
var
key
=
portal
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
HostPortal
&
&
child
.
stateNode
.
containerInfo
=
=
=
portal
.
containerInfo
&
&
child
.
stateNode
.
implementation
=
=
=
portal
.
implementation
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
portal
.
children
|
|
[
]
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
function
reconcileChildFibers
(
returnFiber
currentFirstChild
newChild
expirationTime
)
{
var
isUnkeyedTopLevelFragment
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
&
&
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
&
&
newChild
.
key
=
=
=
null
;
if
(
isUnkeyedTopLevelFragment
)
{
newChild
=
newChild
.
props
.
children
;
}
var
isObject
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
;
if
(
isObject
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
return
placeSingleChild
(
reconcileSingleElement
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
case
REACT_PORTAL_TYPE
:
return
placeSingleChild
(
reconcileSinglePortal
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
}
}
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
return
placeSingleChild
(
reconcileSingleTextNode
(
returnFiber
currentFirstChild
'
'
+
newChild
expirationTime
)
)
;
}
if
(
isArray
(
newChild
)
)
{
return
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
getIteratorFn
(
newChild
)
)
{
return
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
isObject
)
{
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
{
if
(
typeof
newChild
=
=
=
'
function
'
)
{
warnOnFunctionType
(
)
;
}
}
if
(
typeof
newChild
=
=
=
'
undefined
'
&
&
!
isUnkeyedTopLevelFragment
)
{
switch
(
returnFiber
.
tag
)
{
case
ClassComponent
:
{
{
var
instance
=
returnFiber
.
stateNode
;
if
(
instance
.
render
.
_isMockFunction
)
{
break
;
}
}
}
case
FunctionComponent
:
{
var
Component
=
returnFiber
.
type
;
{
{
throw
Error
(
(
Component
.
displayName
|
|
Component
.
name
|
|
'
Component
'
)
+
"
(
.
.
.
)
:
Nothing
was
returned
from
render
.
This
usually
means
a
return
statement
is
missing
.
Or
to
render
nothing
return
null
.
"
)
;
}
}
}
}
}
return
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
}
return
reconcileChildFibers
;
}
var
reconcileChildFibers
=
ChildReconciler
(
true
)
;
var
mountChildFibers
=
ChildReconciler
(
false
)
;
function
cloneChildFibers
(
current
1
workInProgress
)
{
if
(
!
(
current
1
=
=
=
null
|
|
workInProgress
.
child
=
=
=
current
1
.
child
)
)
{
{
throw
Error
(
"
Resuming
work
not
yet
implemented
.
"
)
;
}
}
if
(
workInProgress
.
child
=
=
=
null
)
{
return
;
}
var
currentChild
=
workInProgress
.
child
;
var
newChild
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
workInProgress
.
child
=
newChild
;
newChild
.
return
=
workInProgress
;
while
(
currentChild
.
sibling
!
=
=
null
)
{
currentChild
=
currentChild
.
sibling
;
newChild
=
newChild
.
sibling
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
newChild
.
return
=
workInProgress
;
}
newChild
.
sibling
=
null
;
}
function
resetChildFibers
(
workInProgress
renderExpirationTime
)
{
var
child
=
workInProgress
.
child
;
while
(
child
!
=
=
null
)
{
resetWorkInProgress
(
child
renderExpirationTime
)
;
child
=
child
.
sibling
;
}
}
var
NO_CONTEXT
=
{
}
;
var
contextStackCursor
1
=
createCursor
(
NO_CONTEXT
)
;
var
contextFiberStackCursor
=
createCursor
(
NO_CONTEXT
)
;
var
rootInstanceStackCursor
=
createCursor
(
NO_CONTEXT
)
;
function
requiredContext
(
c
)
{
if
(
!
(
c
!
=
=
NO_CONTEXT
)
)
{
{
throw
Error
(
"
Expected
host
context
to
exist
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
return
c
;
}
function
getRootHostContainer
(
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
return
rootInstance
;
}
function
pushHostContainer
(
fiber
nextRootInstance
)
{
push
(
rootInstanceStackCursor
nextRootInstance
fiber
)
;
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
1
NO_CONTEXT
fiber
)
;
var
nextRootContext
=
getRootHostContext
(
nextRootInstance
)
;
pop
(
contextStackCursor
1
fiber
)
;
push
(
contextStackCursor
1
nextRootContext
fiber
)
;
}
function
popHostContainer
(
fiber
)
{
pop
(
contextStackCursor
1
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
pop
(
rootInstanceStackCursor
fiber
)
;
}
function
getHostContext
(
)
{
var
context
=
requiredContext
(
contextStackCursor
1
.
current
)
;
return
context
;
}
function
pushHostContext
(
fiber
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
var
context
=
requiredContext
(
contextStackCursor
1
.
current
)
;
var
nextContext
=
getChildHostContext
(
context
fiber
.
type
rootInstance
)
;
if
(
context
=
=
=
nextContext
)
{
return
;
}
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
1
nextContext
fiber
)
;
}
function
popHostContext
(
fiber
)
{
if
(
contextFiberStackCursor
.
current
!
=
=
fiber
)
{
return
;
}
pop
(
contextStackCursor
1
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
}
var
DefaultSuspenseContext
=
0
;
var
SubtreeSuspenseContextMask
=
1
;
var
InvisibleParentSuspenseContext
=
1
;
var
ForceSuspenseFallback
=
2
;
var
suspenseStackCursor
=
createCursor
(
DefaultSuspenseContext
)
;
function
hasSuspenseContext
(
parentContext
flag
)
{
return
(
parentContext
&
flag
)
!
=
=
0
;
}
function
setDefaultShallowSuspenseContext
(
parentContext
)
{
return
parentContext
&
SubtreeSuspenseContextMask
;
}
function
setShallowSuspenseContext
(
parentContext
shallowContext
)
{
return
parentContext
&
SubtreeSuspenseContextMask
|
shallowContext
;
}
function
addSubtreeSuspenseContext
(
parentContext
subtreeContext
)
{
return
parentContext
|
subtreeContext
;
}
function
pushSuspenseContext
(
fiber
newContext
)
{
push
(
suspenseStackCursor
newContext
fiber
)
;
}
function
popSuspenseContext
(
fiber
)
{
pop
(
suspenseStackCursor
fiber
)
;
}
function
shouldCaptureSuspense
(
workInProgress
hasInvisibleParent
)
{
var
nextState
=
workInProgress
.
memoizedState
;
if
(
nextState
!
=
=
null
)
{
if
(
nextState
.
dehydrated
!
=
=
null
)
{
return
true
;
}
return
false
;
}
var
props
=
workInProgress
.
memoizedProps
;
if
(
props
.
fallback
=
=
=
undefined
)
{
return
false
;
}
if
(
props
.
unstable_avoidThisFallback
!
=
=
true
)
{
return
true
;
}
if
(
hasInvisibleParent
)
{
return
false
;
}
return
true
;
}
function
findFirstSuspended
(
row
)
{
var
node
=
row
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
SuspenseComponent
)
{
var
state
=
node
.
memoizedState
;
if
(
state
!
=
=
null
)
{
var
dehydrated
=
state
.
dehydrated
;
if
(
dehydrated
=
=
=
null
|
|
isSuspenseInstancePending
(
dehydrated
)
|
|
isSuspenseInstanceFallback
(
dehydrated
)
)
{
return
node
;
}
}
}
else
if
(
node
.
tag
=
=
=
SuspenseListComponent
&
&
node
.
memoizedProps
.
revealOrder
!
=
=
undefined
)
{
var
didSuspend
=
(
node
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
if
(
didSuspend
)
{
return
node
;
}
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
row
)
{
return
null
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
row
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
return
null
;
}
var
emptyObject
=
{
}
;
var
isArray
2
=
Array
.
isArray
;
function
createResponderInstance
(
responder
responderProps
responderState
fiber
)
{
return
{
fiber
:
fiber
props
:
responderProps
responder
:
responder
rootEventTypes
:
null
state
:
responderState
}
;
}
function
mountEventResponder
1
(
responder
responderProps
fiber
respondersMap
rootContainerInstance
)
{
var
responderState
=
emptyObject
;
var
getInitialState
=
responder
.
getInitialState
;
if
(
getInitialState
!
=
=
null
)
{
responderState
=
getInitialState
(
responderProps
)
;
}
var
responderInstance
=
createResponderInstance
(
responder
responderProps
responderState
fiber
)
;
if
(
!
rootContainerInstance
)
{
var
node
=
fiber
;
while
(
node
!
=
=
null
)
{
var
tag
=
node
.
tag
;
if
(
tag
=
=
=
HostComponent
)
{
rootContainerInstance
=
node
.
stateNode
;
break
;
}
else
if
(
tag
=
=
=
HostRoot
)
{
rootContainerInstance
=
node
.
stateNode
.
containerInfo
;
break
;
}
node
=
node
.
return
;
}
}
mountResponderInstance
(
responder
responderInstance
responderProps
responderState
rootContainerInstance
)
;
respondersMap
.
set
(
responder
responderInstance
)
;
}
function
updateEventListener
(
listener
fiber
visistedResponders
respondersMap
rootContainerInstance
)
{
var
responder
;
var
props
;
if
(
listener
)
{
responder
=
listener
.
responder
;
props
=
listener
.
props
;
}
if
(
!
(
responder
&
&
responder
.
typeof
=
=
=
REACT_RESPONDER_TYPE
)
)
{
{
throw
Error
(
"
An
invalid
value
was
used
as
an
event
listener
.
Expect
one
or
many
event
listeners
created
via
React
.
unstable_useResponder
(
)
.
"
)
;
}
}
var
listenerProps
=
props
;
if
(
visistedResponders
.
has
(
responder
)
)
{
{
warning
1
(
false
'
Duplicate
event
responder
"
%
s
"
found
in
event
listeners
.
'
+
'
Event
listeners
passed
to
elements
cannot
use
the
same
event
responder
more
than
once
.
'
responder
.
displayName
)
;
}
return
;
}
visistedResponders
.
add
(
responder
)
;
var
responderInstance
=
respondersMap
.
get
(
responder
)
;
if
(
responderInstance
=
=
=
undefined
)
{
mountEventResponder
1
(
responder
listenerProps
fiber
respondersMap
rootContainerInstance
)
;
}
else
{
responderInstance
.
props
=
listenerProps
;
responderInstance
.
fiber
=
fiber
;
}
}
function
updateEventListeners
(
listeners
fiber
rootContainerInstance
)
{
var
visistedResponders
=
new
Set
(
)
;
var
dependencies
=
fiber
.
dependencies
;
if
(
listeners
!
=
null
)
{
if
(
dependencies
=
=
=
null
)
{
dependencies
=
fiber
.
dependencies
=
{
expirationTime
:
NoWork
firstContext
:
null
responders
:
new
Map
(
)
}
;
}
var
respondersMap
=
dependencies
.
responders
;
if
(
respondersMap
=
=
=
null
)
{
respondersMap
=
new
Map
(
)
;
}
if
(
isArray
2
(
listeners
)
)
{
for
(
var
i
=
0
length
=
listeners
.
length
;
i
<
length
;
i
+
+
)
{
var
listener
=
listeners
[
i
]
;
updateEventListener
(
listener
fiber
visistedResponders
respondersMap
rootContainerInstance
)
;
}
}
else
{
updateEventListener
(
listeners
fiber
visistedResponders
respondersMap
rootContainerInstance
)
;
}
}
if
(
dependencies
!
=
=
null
)
{
var
_respondersMap
=
dependencies
.
responders
;
if
(
_respondersMap
!
=
=
null
)
{
var
mountedResponders
=
Array
.
from
(
_respondersMap
.
keys
(
)
)
;
for
(
var
_i
=
0
_length
=
mountedResponders
.
length
;
_i
<
_length
;
_i
+
+
)
{
var
mountedResponder
=
mountedResponders
[
_i
]
;
if
(
!
visistedResponders
.
has
(
mountedResponder
)
)
{
var
responderInstance
=
_respondersMap
.
get
(
mountedResponder
)
;
unmountResponderInstance
(
responderInstance
)
;
_respondersMap
.
delete
(
mountedResponder
)
;
}
}
}
}
}
function
createResponderListener
(
responder
props
)
{
var
eventResponderListener
=
{
responder
:
responder
props
:
props
}
;
{
Object
.
freeze
(
eventResponderListener
)
;
}
return
eventResponderListener
;
}
var
NoEffect
1
=
0
;
var
UnmountSnapshot
=
2
;
var
UnmountMutation
=
4
;
var
MountMutation
=
8
;
var
UnmountLayout
=
16
;
var
MountLayout
=
32
;
var
MountPassive
=
64
;
var
UnmountPassive
=
128
;
var
ReactCurrentDispatcher
1
=
ReactSharedInternals
.
ReactCurrentDispatcher
;
var
ReactCurrentBatchConfig
1
=
ReactSharedInternals
.
ReactCurrentBatchConfig
;
var
didWarnAboutMismatchedHooksForComponent
;
{
didWarnAboutMismatchedHooksForComponent
=
new
Set
(
)
;
}
var
renderExpirationTime
1
=
NoWork
;
var
currentlyRenderingFiber
1
=
null
;
var
currentHook
=
null
;
var
nextCurrentHook
=
null
;
var
firstWorkInProgressHook
=
null
;
var
workInProgressHook
=
null
;
var
nextWorkInProgressHook
=
null
;
var
remainingExpirationTime
=
NoWork
;
var
componentUpdateQueue
=
null
;
var
sideEffectTag
=
0
;
var
didScheduleRenderPhaseUpdate
=
false
;
var
renderPhaseUpdates
=
null
;
var
numberOfReRenders
=
0
;
var
RE_RENDER_LIMIT
=
25
;
var
currentHookNameInDev
=
null
;
var
hookTypesDev
=
null
;
var
hookTypesUpdateIndexDev
=
-
1
;
var
ignorePreviousDependencies
=
false
;
function
mountHookTypesDev
(
)
{
{
var
hookName
=
currentHookNameInDev
;
if
(
hookTypesDev
=
=
=
null
)
{
hookTypesDev
=
[
hookName
]
;
}
else
{
hookTypesDev
.
push
(
hookName
)
;
}
}
}
function
updateHookTypesDev
(
)
{
{
var
hookName
=
currentHookNameInDev
;
if
(
hookTypesDev
!
=
=
null
)
{
hookTypesUpdateIndexDev
+
+
;
if
(
hookTypesDev
[
hookTypesUpdateIndexDev
]
!
=
=
hookName
)
{
warnOnHookMismatchInDev
(
hookName
)
;
}
}
}
}
function
checkDepsAreArrayDev
(
deps
)
{
{
if
(
deps
!
=
=
undefined
&
&
deps
!
=
=
null
&
&
!
Array
.
isArray
(
deps
)
)
{
warning
1
(
false
'
%
s
received
a
final
argument
that
is
not
an
array
(
instead
received
%
s
)
.
When
'
+
'
specified
the
final
argument
must
be
an
array
.
'
currentHookNameInDev
typeof
deps
)
;
}
}
}
function
warnOnHookMismatchInDev
(
currentHookName
)
{
{
var
componentName
=
getComponentName
(
currentlyRenderingFiber
1
.
type
)
;
if
(
!
didWarnAboutMismatchedHooksForComponent
.
has
(
componentName
)
)
{
didWarnAboutMismatchedHooksForComponent
.
add
(
componentName
)
;
if
(
hookTypesDev
!
=
=
null
)
{
var
table
=
'
'
;
var
secondColumnStart
=
30
;
for
(
var
i
=
0
;
i
<
=
hookTypesUpdateIndexDev
;
i
+
+
)
{
var
oldHookName
=
hookTypesDev
[
i
]
;
var
newHookName
=
i
=
=
=
hookTypesUpdateIndexDev
?
currentHookName
:
oldHookName
;
var
row
=
i
+
1
+
"
.
"
+
oldHookName
;
while
(
row
.
length
<
secondColumnStart
)
{
row
+
=
'
'
;
}
row
+
=
newHookName
+
'
\
n
'
;
table
+
=
row
;
}
warning
1
(
false
'
React
has
detected
a
change
in
the
order
of
Hooks
called
by
%
s
.
'
+
'
This
will
lead
to
bugs
and
errors
if
not
fixed
.
'
+
'
For
more
information
read
the
Rules
of
Hooks
:
https
:
/
/
fb
.
me
/
rules
-
of
-
hooks
\
n
\
n
'
+
'
Previous
render
Next
render
\
n
'
+
'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
'
+
'
%
s
'
+
'
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
\
n
'
componentName
table
)
;
}
}
}
}
function
throwInvalidHookError
(
)
{
{
{
throw
Error
(
"
Invalid
hook
call
.
Hooks
can
only
be
called
inside
of
the
body
of
a
function
component
.
This
could
happen
for
one
of
the
following
reasons
:
\
n1
.
You
might
have
mismatching
versions
of
React
and
the
renderer
(
such
as
React
DOM
)
\
n2
.
You
might
be
breaking
the
Rules
of
Hooks
\
n3
.
You
might
have
more
than
one
copy
of
React
in
the
same
app
\
nSee
https
:
/
/
fb
.
me
/
react
-
invalid
-
hook
-
call
for
tips
about
how
to
debug
and
fix
this
problem
.
"
)
;
}
}
}
function
areHookInputsEqual
(
nextDeps
prevDeps
)
{
{
if
(
ignorePreviousDependencies
)
{
return
false
;
}
}
if
(
prevDeps
=
=
=
null
)
{
{
warning
1
(
false
'
%
s
received
a
final
argument
during
this
render
but
not
during
'
+
'
the
previous
render
.
Even
though
the
final
argument
is
optional
'
+
'
its
type
cannot
change
between
renders
.
'
currentHookNameInDev
)
;
}
return
false
;
}
{
if
(
nextDeps
.
length
!
=
=
prevDeps
.
length
)
{
warning
1
(
false
'
The
final
argument
passed
to
%
s
changed
size
between
renders
.
The
'
+
'
order
and
size
of
this
array
must
remain
constant
.
\
n
\
n
'
+
'
Previous
:
%
s
\
n
'
+
'
Incoming
:
%
s
'
currentHookNameInDev
"
[
"
+
prevDeps
.
join
(
'
'
)
+
"
]
"
"
[
"
+
nextDeps
.
join
(
'
'
)
+
"
]
"
)
;
}
}
for
(
var
i
=
0
;
i
<
prevDeps
.
length
&
&
i
<
nextDeps
.
length
;
i
+
+
)
{
if
(
is
1
(
nextDeps
[
i
]
prevDeps
[
i
]
)
)
{
continue
;
}
return
false
;
}
return
true
;
}
function
renderWithHooks
(
current
workInProgress
Component
props
refOrContext
nextRenderExpirationTime
)
{
renderExpirationTime
1
=
nextRenderExpirationTime
;
currentlyRenderingFiber
1
=
workInProgress
;
nextCurrentHook
=
current
!
=
=
null
?
current
.
memoizedState
:
null
;
{
hookTypesDev
=
current
!
=
=
null
?
current
.
_debugHookTypes
:
null
;
hookTypesUpdateIndexDev
=
-
1
;
ignorePreviousDependencies
=
current
!
=
=
null
&
&
current
.
type
!
=
=
workInProgress
.
type
;
}
{
if
(
nextCurrentHook
!
=
=
null
)
{
ReactCurrentDispatcher
1
.
current
=
HooksDispatcherOnUpdateInDEV
;
}
else
if
(
hookTypesDev
!
=
=
null
)
{
ReactCurrentDispatcher
1
.
current
=
HooksDispatcherOnMountWithHookTypesInDEV
;
}
else
{
ReactCurrentDispatcher
1
.
current
=
HooksDispatcherOnMountInDEV
;
}
}
var
children
=
Component
(
props
refOrContext
)
;
if
(
didScheduleRenderPhaseUpdate
)
{
do
{
didScheduleRenderPhaseUpdate
=
false
;
numberOfReRenders
+
=
1
;
{
ignorePreviousDependencies
=
false
;
}
nextCurrentHook
=
current
!
=
=
null
?
current
.
memoizedState
:
null
;
nextWorkInProgressHook
=
firstWorkInProgressHook
;
currentHook
=
null
;
workInProgressHook
=
null
;
componentUpdateQueue
=
null
;
{
hookTypesUpdateIndexDev
=
-
1
;
}
ReactCurrentDispatcher
1
.
current
=
HooksDispatcherOnUpdateInDEV
;
children
=
Component
(
props
refOrContext
)
;
}
while
(
didScheduleRenderPhaseUpdate
)
;
renderPhaseUpdates
=
null
;
numberOfReRenders
=
0
;
}
ReactCurrentDispatcher
1
.
current
=
ContextOnlyDispatcher
;
var
renderedWork
=
currentlyRenderingFiber
1
;
renderedWork
.
memoizedState
=
firstWorkInProgressHook
;
renderedWork
.
expirationTime
=
remainingExpirationTime
;
renderedWork
.
updateQueue
=
componentUpdateQueue
;
renderedWork
.
effectTag
|
=
sideEffectTag
;
{
renderedWork
.
_debugHookTypes
=
hookTypesDev
;
}
var
didRenderTooFewHooks
=
currentHook
!
=
=
null
&
&
currentHook
.
next
!
=
=
null
;
renderExpirationTime
1
=
NoWork
;
currentlyRenderingFiber
1
=
null
;
currentHook
=
null
;
nextCurrentHook
=
null
;
firstWorkInProgressHook
=
null
;
workInProgressHook
=
null
;
nextWorkInProgressHook
=
null
;
{
currentHookNameInDev
=
null
;
hookTypesDev
=
null
;
hookTypesUpdateIndexDev
=
-
1
;
}
remainingExpirationTime
=
NoWork
;
componentUpdateQueue
=
null
;
sideEffectTag
=
0
;
if
(
!
!
didRenderTooFewHooks
)
{
{
throw
Error
(
"
Rendered
fewer
hooks
than
expected
.
This
may
be
caused
by
an
accidental
early
return
statement
.
"
)
;
}
}
return
children
;
}
function
bailoutHooks
(
current
workInProgress
expirationTime
)
{
workInProgress
.
updateQueue
=
current
.
updateQueue
;
workInProgress
.
effectTag
&
=
~
(
Passive
|
Update
)
;
if
(
current
.
expirationTime
<
=
expirationTime
)
{
current
.
expirationTime
=
NoWork
;
}
}
function
resetHooks
(
)
{
ReactCurrentDispatcher
1
.
current
=
ContextOnlyDispatcher
;
renderExpirationTime
1
=
NoWork
;
currentlyRenderingFiber
1
=
null
;
currentHook
=
null
;
nextCurrentHook
=
null
;
firstWorkInProgressHook
=
null
;
workInProgressHook
=
null
;
nextWorkInProgressHook
=
null
;
{
hookTypesDev
=
null
;
hookTypesUpdateIndexDev
=
-
1
;
currentHookNameInDev
=
null
;
}
remainingExpirationTime
=
NoWork
;
componentUpdateQueue
=
null
;
sideEffectTag
=
0
;
didScheduleRenderPhaseUpdate
=
false
;
renderPhaseUpdates
=
null
;
numberOfReRenders
=
0
;
}
function
mountWorkInProgressHook
(
)
{
var
hook
=
{
memoizedState
:
null
baseState
:
null
queue
:
null
baseUpdate
:
null
next
:
null
}
;
if
(
workInProgressHook
=
=
=
null
)
{
firstWorkInProgressHook
=
workInProgressHook
=
hook
;
}
else
{
workInProgressHook
=
workInProgressHook
.
next
=
hook
;
}
return
workInProgressHook
;
}
function
updateWorkInProgressHook
(
)
{
if
(
nextWorkInProgressHook
!
=
=
null
)
{
workInProgressHook
=
nextWorkInProgressHook
;
nextWorkInProgressHook
=
workInProgressHook
.
next
;
currentHook
=
nextCurrentHook
;
nextCurrentHook
=
currentHook
!
=
=
null
?
currentHook
.
next
:
null
;
}
else
{
if
(
!
(
nextCurrentHook
!
=
=
null
)
)
{
{
throw
Error
(
"
Rendered
more
hooks
than
during
the
previous
render
.
"
)
;
}
}
currentHook
=
nextCurrentHook
;
var
newHook
=
{
memoizedState
:
currentHook
.
memoizedState
baseState
:
currentHook
.
baseState
queue
:
currentHook
.
queue
baseUpdate
:
currentHook
.
baseUpdate
next
:
null
}
;
if
(
workInProgressHook
=
=
=
null
)
{
workInProgressHook
=
firstWorkInProgressHook
=
newHook
;
}
else
{
workInProgressHook
=
workInProgressHook
.
next
=
newHook
;
}
nextCurrentHook
=
currentHook
.
next
;
}
return
workInProgressHook
;
}
function
createFunctionComponentUpdateQueue
(
)
{
return
{
lastEffect
:
null
}
;
}
function
basicStateReducer
(
state
action
)
{
return
typeof
action
=
=
=
'
function
'
?
action
(
state
)
:
action
;
}
function
mountReducer
(
reducer
initialArg
init
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
initialState
;
if
(
init
!
=
=
undefined
)
{
initialState
=
init
(
initialArg
)
;
}
else
{
initialState
=
initialArg
;
}
hook
.
memoizedState
=
hook
.
baseState
=
initialState
;
var
queue
=
hook
.
queue
=
{
last
:
null
dispatch
:
null
lastRenderedReducer
:
reducer
lastRenderedState
:
initialState
}
;
var
dispatch
=
queue
.
dispatch
=
dispatchAction
.
bind
(
null
currentlyRenderingFiber
1
queue
)
;
return
[
hook
.
memoizedState
dispatch
]
;
}
function
updateReducer
(
reducer
initialArg
init
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
var
queue
=
hook
.
queue
;
if
(
!
(
queue
!
=
=
null
)
)
{
{
throw
Error
(
"
Should
have
a
queue
.
This
is
likely
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
queue
.
lastRenderedReducer
=
reducer
;
if
(
numberOfReRenders
>
0
)
{
var
_dispatch
=
queue
.
dispatch
;
if
(
renderPhaseUpdates
!
=
=
null
)
{
var
firstRenderPhaseUpdate
=
renderPhaseUpdates
.
get
(
queue
)
;
if
(
firstRenderPhaseUpdate
!
=
=
undefined
)
{
renderPhaseUpdates
.
delete
(
queue
)
;
var
newState
=
hook
.
memoizedState
;
var
update
=
firstRenderPhaseUpdate
;
do
{
var
action
=
update
.
action
;
newState
=
reducer
(
newState
action
)
;
update
=
update
.
next
;
}
while
(
update
!
=
=
null
)
;
if
(
!
is
1
(
newState
hook
.
memoizedState
)
)
{
markWorkInProgressReceivedUpdate
(
)
;
}
hook
.
memoizedState
=
newState
;
if
(
hook
.
baseUpdate
=
=
=
queue
.
last
)
{
hook
.
baseState
=
newState
;
}
queue
.
lastRenderedState
=
newState
;
return
[
newState
_dispatch
]
;
}
}
return
[
hook
.
memoizedState
_dispatch
]
;
}
var
last
=
queue
.
last
;
var
baseUpdate
=
hook
.
baseUpdate
;
var
baseState
=
hook
.
baseState
;
var
first
;
if
(
baseUpdate
!
=
=
null
)
{
if
(
last
!
=
=
null
)
{
last
.
next
=
null
;
}
first
=
baseUpdate
.
next
;
}
else
{
first
=
last
!
=
=
null
?
last
.
next
:
null
;
}
if
(
first
!
=
=
null
)
{
var
_newState
=
baseState
;
var
newBaseState
=
null
;
var
newBaseUpdate
=
null
;
var
prevUpdate
=
baseUpdate
;
var
_update
=
first
;
var
didSkip
=
false
;
do
{
var
updateExpirationTime
=
_update
.
expirationTime
;
if
(
updateExpirationTime
<
renderExpirationTime
1
)
{
if
(
!
didSkip
)
{
didSkip
=
true
;
newBaseUpdate
=
prevUpdate
;
newBaseState
=
_newState
;
}
if
(
updateExpirationTime
>
remainingExpirationTime
)
{
remainingExpirationTime
=
updateExpirationTime
;
markUnprocessedUpdateTime
(
remainingExpirationTime
)
;
}
}
else
{
markRenderEventTimeAndConfig
(
updateExpirationTime
_update
.
suspenseConfig
)
;
if
(
_update
.
eagerReducer
=
=
=
reducer
)
{
_newState
=
_update
.
eagerState
;
}
else
{
var
_action
=
_update
.
action
;
_newState
=
reducer
(
_newState
_action
)
;
}
}
prevUpdate
=
_update
;
_update
=
_update
.
next
;
}
while
(
_update
!
=
=
null
&
&
_update
!
=
=
first
)
;
if
(
!
didSkip
)
{
newBaseUpdate
=
prevUpdate
;
newBaseState
=
_newState
;
}
if
(
!
is
1
(
_newState
hook
.
memoizedState
)
)
{
markWorkInProgressReceivedUpdate
(
)
;
}
hook
.
memoizedState
=
_newState
;
hook
.
baseUpdate
=
newBaseUpdate
;
hook
.
baseState
=
newBaseState
;
queue
.
lastRenderedState
=
_newState
;
}
var
dispatch
=
queue
.
dispatch
;
return
[
hook
.
memoizedState
dispatch
]
;
}
function
mountState
(
initialState
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
if
(
typeof
initialState
=
=
=
'
function
'
)
{
initialState
=
initialState
(
)
;
}
hook
.
memoizedState
=
hook
.
baseState
=
initialState
;
var
queue
=
hook
.
queue
=
{
last
:
null
dispatch
:
null
lastRenderedReducer
:
basicStateReducer
lastRenderedState
:
initialState
}
;
var
dispatch
=
queue
.
dispatch
=
dispatchAction
.
bind
(
null
currentlyRenderingFiber
1
queue
)
;
return
[
hook
.
memoizedState
dispatch
]
;
}
function
updateState
(
initialState
)
{
return
updateReducer
(
basicStateReducer
initialState
)
;
}
function
pushEffect
(
tag
create
destroy
deps
)
{
var
effect
=
{
tag
:
tag
create
:
create
destroy
:
destroy
deps
:
deps
next
:
null
}
;
if
(
componentUpdateQueue
=
=
=
null
)
{
componentUpdateQueue
=
createFunctionComponentUpdateQueue
(
)
;
componentUpdateQueue
.
lastEffect
=
effect
.
next
=
effect
;
}
else
{
var
lastEffect
=
componentUpdateQueue
.
lastEffect
;
if
(
lastEffect
=
=
=
null
)
{
componentUpdateQueue
.
lastEffect
=
effect
.
next
=
effect
;
}
else
{
var
firstEffect
=
lastEffect
.
next
;
lastEffect
.
next
=
effect
;
effect
.
next
=
firstEffect
;
componentUpdateQueue
.
lastEffect
=
effect
;
}
}
return
effect
;
}
function
mountRef
(
initialValue
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
ref
=
{
current
:
initialValue
}
;
{
Object
.
seal
(
ref
)
;
}
hook
.
memoizedState
=
ref
;
return
ref
;
}
function
updateRef
(
initialValue
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
return
hook
.
memoizedState
;
}
function
mountEffectImpl
(
fiberEffectTag
hookEffectTag
create
deps
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
sideEffectTag
|
=
fiberEffectTag
;
hook
.
memoizedState
=
pushEffect
(
hookEffectTag
create
undefined
nextDeps
)
;
}
function
updateEffectImpl
(
fiberEffectTag
hookEffectTag
create
deps
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
var
destroy
=
undefined
;
if
(
currentHook
!
=
=
null
)
{
var
prevEffect
=
currentHook
.
memoizedState
;
destroy
=
prevEffect
.
destroy
;
if
(
nextDeps
!
=
=
null
)
{
var
prevDeps
=
prevEffect
.
deps
;
if
(
areHookInputsEqual
(
nextDeps
prevDeps
)
)
{
pushEffect
(
NoEffect
1
create
destroy
nextDeps
)
;
return
;
}
}
}
sideEffectTag
|
=
fiberEffectTag
;
hook
.
memoizedState
=
pushEffect
(
hookEffectTag
create
destroy
nextDeps
)
;
}
function
mountEffect
(
create
deps
)
{
{
if
(
'
undefined
'
!
=
=
typeof
jest
)
{
warnIfNotCurrentlyActingEffectsInDEV
(
currentlyRenderingFiber
1
)
;
}
}
return
mountEffectImpl
(
Update
|
Passive
UnmountPassive
|
MountPassive
create
deps
)
;
}
function
updateEffect
(
create
deps
)
{
{
if
(
'
undefined
'
!
=
=
typeof
jest
)
{
warnIfNotCurrentlyActingEffectsInDEV
(
currentlyRenderingFiber
1
)
;
}
}
return
updateEffectImpl
(
Update
|
Passive
UnmountPassive
|
MountPassive
create
deps
)
;
}
function
mountLayoutEffect
(
create
deps
)
{
return
mountEffectImpl
(
Update
UnmountMutation
|
MountLayout
create
deps
)
;
}
function
updateLayoutEffect
(
create
deps
)
{
return
updateEffectImpl
(
Update
UnmountMutation
|
MountLayout
create
deps
)
;
}
function
imperativeHandleEffect
(
create
ref
)
{
if
(
typeof
ref
=
=
=
'
function
'
)
{
var
refCallback
=
ref
;
var
_inst
=
create
(
)
;
refCallback
(
_inst
)
;
return
function
(
)
{
refCallback
(
null
)
;
}
;
}
else
if
(
ref
!
=
=
null
&
&
ref
!
=
=
undefined
)
{
var
refObject
=
ref
;
{
!
refObject
.
hasOwnProperty
(
'
current
'
)
?
warning
1
(
false
'
Expected
useImperativeHandle
(
)
first
argument
to
either
be
a
'
+
'
ref
callback
or
React
.
createRef
(
)
object
.
Instead
received
:
%
s
.
'
'
an
object
with
keys
{
'
+
Object
.
keys
(
refObject
)
.
join
(
'
'
)
+
'
}
'
)
:
void
0
;
}
var
_inst2
=
create
(
)
;
refObject
.
current
=
_inst2
;
return
function
(
)
{
refObject
.
current
=
null
;
}
;
}
}
function
mountImperativeHandle
(
ref
create
deps
)
{
{
!
(
typeof
create
=
=
=
'
function
'
)
?
warning
1
(
false
'
Expected
useImperativeHandle
(
)
second
argument
to
be
a
function
'
+
'
that
creates
a
handle
.
Instead
received
:
%
s
.
'
create
!
=
=
null
?
typeof
create
:
'
null
'
)
:
void
0
;
}
var
effectDeps
=
deps
!
=
=
null
&
&
deps
!
=
=
undefined
?
deps
.
concat
(
[
ref
]
)
:
null
;
return
mountEffectImpl
(
Update
UnmountMutation
|
MountLayout
imperativeHandleEffect
.
bind
(
null
create
ref
)
effectDeps
)
;
}
function
updateImperativeHandle
(
ref
create
deps
)
{
{
!
(
typeof
create
=
=
=
'
function
'
)
?
warning
1
(
false
'
Expected
useImperativeHandle
(
)
second
argument
to
be
a
function
'
+
'
that
creates
a
handle
.
Instead
received
:
%
s
.
'
create
!
=
=
null
?
typeof
create
:
'
null
'
)
:
void
0
;
}
var
effectDeps
=
deps
!
=
=
null
&
&
deps
!
=
=
undefined
?
deps
.
concat
(
[
ref
]
)
:
null
;
return
updateEffectImpl
(
Update
UnmountMutation
|
MountLayout
imperativeHandleEffect
.
bind
(
null
create
ref
)
effectDeps
)
;
}
function
mountDebugValue
(
value
formatterFn
)
{
}
var
updateDebugValue
=
mountDebugValue
;
function
mountCallback
(
callback
deps
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
hook
.
memoizedState
=
[
callback
nextDeps
]
;
return
callback
;
}
function
updateCallback
(
callback
deps
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
var
prevState
=
hook
.
memoizedState
;
if
(
prevState
!
=
=
null
)
{
if
(
nextDeps
!
=
=
null
)
{
var
prevDeps
=
prevState
[
1
]
;
if
(
areHookInputsEqual
(
nextDeps
prevDeps
)
)
{
return
prevState
[
0
]
;
}
}
}
hook
.
memoizedState
=
[
callback
nextDeps
]
;
return
callback
;
}
function
mountMemo
(
nextCreate
deps
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
var
nextValue
=
nextCreate
(
)
;
hook
.
memoizedState
=
[
nextValue
nextDeps
]
;
return
nextValue
;
}
function
updateMemo
(
nextCreate
deps
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
var
prevState
=
hook
.
memoizedState
;
if
(
prevState
!
=
=
null
)
{
if
(
nextDeps
!
=
=
null
)
{
var
prevDeps
=
prevState
[
1
]
;
if
(
areHookInputsEqual
(
nextDeps
prevDeps
)
)
{
return
prevState
[
0
]
;
}
}
}
var
nextValue
=
nextCreate
(
)
;
hook
.
memoizedState
=
[
nextValue
nextDeps
]
;
return
nextValue
;
}
function
mountDeferredValue
(
value
config
)
{
var
_mountState
=
mountState
(
value
)
prevValue
=
_mountState
[
0
]
setValue
=
_mountState
[
1
]
;
mountEffect
(
function
(
)
{
unstable_next
(
function
(
)
{
var
previousConfig
=
ReactCurrentBatchConfig
1
.
suspense
;
ReactCurrentBatchConfig
1
.
suspense
=
config
=
=
=
undefined
?
null
:
config
;
try
{
setValue
(
value
)
;
}
finally
{
ReactCurrentBatchConfig
1
.
suspense
=
previousConfig
;
}
}
)
;
}
[
value
config
]
)
;
return
prevValue
;
}
function
updateDeferredValue
(
value
config
)
{
var
_updateState
=
updateState
(
value
)
prevValue
=
_updateState
[
0
]
setValue
=
_updateState
[
1
]
;
updateEffect
(
function
(
)
{
unstable_next
(
function
(
)
{
var
previousConfig
=
ReactCurrentBatchConfig
1
.
suspense
;
ReactCurrentBatchConfig
1
.
suspense
=
config
=
=
=
undefined
?
null
:
config
;
try
{
setValue
(
value
)
;
}
finally
{
ReactCurrentBatchConfig
1
.
suspense
=
previousConfig
;
}
}
)
;
}
[
value
config
]
)
;
return
prevValue
;
}
function
mountTransition
(
config
)
{
var
_mountState2
=
mountState
(
false
)
isPending
=
_mountState2
[
0
]
setPending
=
_mountState2
[
1
]
;
var
startTransition
=
mountCallback
(
function
(
callback
)
{
setPending
(
true
)
;
unstable_next
(
function
(
)
{
var
previousConfig
=
ReactCurrentBatchConfig
1
.
suspense
;
ReactCurrentBatchConfig
1
.
suspense
=
config
=
=
=
undefined
?
null
:
config
;
try
{
setPending
(
false
)
;
callback
(
)
;
}
finally
{
ReactCurrentBatchConfig
1
.
suspense
=
previousConfig
;
}
}
)
;
}
[
config
isPending
]
)
;
return
[
startTransition
isPending
]
;
}
function
updateTransition
(
config
)
{
var
_updateState2
=
updateState
(
false
)
isPending
=
_updateState2
[
0
]
setPending
=
_updateState2
[
1
]
;
var
startTransition
=
updateCallback
(
function
(
callback
)
{
setPending
(
true
)
;
unstable_next
(
function
(
)
{
var
previousConfig
=
ReactCurrentBatchConfig
1
.
suspense
;
ReactCurrentBatchConfig
1
.
suspense
=
config
=
=
=
undefined
?
null
:
config
;
try
{
setPending
(
false
)
;
callback
(
)
;
}
finally
{
ReactCurrentBatchConfig
1
.
suspense
=
previousConfig
;
}
}
)
;
}
[
config
isPending
]
)
;
return
[
startTransition
isPending
]
;
}
function
dispatchAction
(
fiber
queue
action
)
{
if
(
!
(
numberOfReRenders
<
RE_RENDER_LIMIT
)
)
{
{
throw
Error
(
"
Too
many
re
-
renders
.
React
limits
the
number
of
renders
to
prevent
an
infinite
loop
.
"
)
;
}
}
{
!
(
typeof
arguments
[
3
]
!
=
=
'
function
'
)
?
warning
1
(
false
"
State
updates
from
the
useState
(
)
and
useReducer
(
)
Hooks
don
'
t
support
the
"
+
'
second
callback
argument
.
To
execute
a
side
effect
after
'
+
'
rendering
declare
it
in
the
component
body
with
useEffect
(
)
.
'
)
:
void
0
;
}
var
alternate
=
fiber
.
alternate
;
if
(
fiber
=
=
=
currentlyRenderingFiber
1
|
|
alternate
!
=
=
null
&
&
alternate
=
=
=
currentlyRenderingFiber
1
)
{
didScheduleRenderPhaseUpdate
=
true
;
var
update
=
{
expirationTime
:
renderExpirationTime
1
suspenseConfig
:
null
action
:
action
eagerReducer
:
null
eagerState
:
null
next
:
null
}
;
{
update
.
priority
=
getCurrentPriorityLevel
(
)
;
}
if
(
renderPhaseUpdates
=
=
=
null
)
{
renderPhaseUpdates
=
new
Map
(
)
;
}
var
firstRenderPhaseUpdate
=
renderPhaseUpdates
.
get
(
queue
)
;
if
(
firstRenderPhaseUpdate
=
=
=
undefined
)
{
renderPhaseUpdates
.
set
(
queue
update
)
;
}
else
{
var
lastRenderPhaseUpdate
=
firstRenderPhaseUpdate
;
while
(
lastRenderPhaseUpdate
.
next
!
=
=
null
)
{
lastRenderPhaseUpdate
=
lastRenderPhaseUpdate
.
next
;
}
lastRenderPhaseUpdate
.
next
=
update
;
}
}
else
{
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
var
suspenseConfig
=
requestCurrentSuspenseConfig
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
suspenseConfig
)
;
var
_update2
=
{
expirationTime
:
expirationTime
suspenseConfig
:
suspenseConfig
action
:
action
eagerReducer
:
null
eagerState
:
null
next
:
null
}
;
{
_update2
.
priority
=
getCurrentPriorityLevel
(
)
;
}
var
last
=
queue
.
last
;
if
(
last
=
=
=
null
)
{
_update2
.
next
=
_update2
;
}
else
{
var
first
=
last
.
next
;
if
(
first
!
=
=
null
)
{
_update2
.
next
=
first
;
}
last
.
next
=
_update2
;
}
queue
.
last
=
_update2
;
if
(
fiber
.
expirationTime
=
=
=
NoWork
&
&
(
alternate
=
=
=
null
|
|
alternate
.
expirationTime
=
=
=
NoWork
)
)
{
var
lastRenderedReducer
=
queue
.
lastRenderedReducer
;
if
(
lastRenderedReducer
!
=
=
null
)
{
var
prevDispatcher
;
{
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnUpdateInDEV
;
}
try
{
var
currentState
=
queue
.
lastRenderedState
;
var
eagerState
=
lastRenderedReducer
(
currentState
action
)
;
_update2
.
eagerReducer
=
lastRenderedReducer
;
_update2
.
eagerState
=
eagerState
;
if
(
is
1
(
eagerState
currentState
)
)
{
return
;
}
}
catch
(
error
)
{
}
finally
{
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
}
}
{
if
(
'
undefined
'
!
=
=
typeof
jest
)
{
warnIfNotScopedWithMatchingAct
(
fiber
)
;
warnIfNotCurrentlyActingUpdatesInDev
(
fiber
)
;
}
}
scheduleWork
(
fiber
expirationTime
)
;
}
}
var
ContextOnlyDispatcher
=
{
readContext
:
readContext
useCallback
:
throwInvalidHookError
useContext
:
throwInvalidHookError
useEffect
:
throwInvalidHookError
useImperativeHandle
:
throwInvalidHookError
useLayoutEffect
:
throwInvalidHookError
useMemo
:
throwInvalidHookError
useReducer
:
throwInvalidHookError
useRef
:
throwInvalidHookError
useState
:
throwInvalidHookError
useDebugValue
:
throwInvalidHookError
useResponder
:
throwInvalidHookError
useDeferredValue
:
throwInvalidHookError
useTransition
:
throwInvalidHookError
}
;
var
HooksDispatcherOnMountInDEV
=
null
;
var
HooksDispatcherOnMountWithHookTypesInDEV
=
null
;
var
HooksDispatcherOnUpdateInDEV
=
null
;
var
InvalidNestedHooksDispatcherOnMountInDEV
=
null
;
var
InvalidNestedHooksDispatcherOnUpdateInDEV
=
null
;
{
var
warnInvalidContextAccess
=
function
(
)
{
warning
1
(
false
'
Context
can
only
be
read
while
React
is
rendering
.
'
+
'
In
classes
you
can
read
it
in
the
render
method
or
getDerivedStateFromProps
.
'
+
'
In
function
components
you
can
read
it
directly
in
the
function
body
but
not
'
+
'
inside
Hooks
like
useReducer
(
)
or
useMemo
(
)
.
'
)
;
}
;
var
warnInvalidHookAccess
=
function
(
)
{
warning
1
(
false
'
Do
not
call
Hooks
inside
useEffect
(
.
.
.
)
useMemo
(
.
.
.
)
or
other
built
-
in
Hooks
.
'
+
'
You
can
only
call
Hooks
at
the
top
level
of
your
React
function
.
'
+
'
For
more
information
see
'
+
'
https
:
/
/
fb
.
me
/
rules
-
of
-
hooks
'
)
;
}
;
HooksDispatcherOnMountInDEV
=
{
readContext
:
function
(
context
observedBits
)
{
return
readContext
(
context
observedBits
)
;
}
useCallback
:
function
(
callback
deps
)
{
currentHookNameInDev
=
'
useCallback
'
;
mountHookTypesDev
(
)
;
checkDepsAreArrayDev
(
deps
)
;
return
mountCallback
(
callback
deps
)
;
}
useContext
:
function
(
context
observedBits
)
{
currentHookNameInDev
=
'
useContext
'
;
mountHookTypesDev
(
)
;
return
readContext
(
context
observedBits
)
;
}
useEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useEffect
'
;
mountHookTypesDev
(
)
;
checkDepsAreArrayDev
(
deps
)
;
return
mountEffect
(
create
deps
)
;
}
useImperativeHandle
:
function
(
ref
create
deps
)
{
currentHookNameInDev
=
'
useImperativeHandle
'
;
mountHookTypesDev
(
)
;
checkDepsAreArrayDev
(
deps
)
;
return
mountImperativeHandle
(
ref
create
deps
)
;
}
useLayoutEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useLayoutEffect
'
;
mountHookTypesDev
(
)
;
checkDepsAreArrayDev
(
deps
)
;
return
mountLayoutEffect
(
create
deps
)
;
}
useMemo
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useMemo
'
;
mountHookTypesDev
(
)
;
checkDepsAreArrayDev
(
deps
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountMemo
(
create
deps
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useReducer
:
function
(
reducer
initialArg
init
)
{
currentHookNameInDev
=
'
useReducer
'
;
mountHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountReducer
(
reducer
initialArg
init
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useRef
:
function
(
initialValue
)
{
currentHookNameInDev
=
'
useRef
'
;
mountHookTypesDev
(
)
;
return
mountRef
(
initialValue
)
;
}
useState
:
function
(
initialState
)
{
currentHookNameInDev
=
'
useState
'
;
mountHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountState
(
initialState
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useDebugValue
:
function
(
value
formatterFn
)
{
currentHookNameInDev
=
'
useDebugValue
'
;
mountHookTypesDev
(
)
;
return
mountDebugValue
(
value
formatterFn
)
;
}
useResponder
:
function
(
responder
props
)
{
currentHookNameInDev
=
'
useResponder
'
;
mountHookTypesDev
(
)
;
return
createResponderListener
(
responder
props
)
;
}
useDeferredValue
:
function
(
value
config
)
{
currentHookNameInDev
=
'
useDeferredValue
'
;
mountHookTypesDev
(
)
;
return
mountDeferredValue
(
value
config
)
;
}
useTransition
:
function
(
config
)
{
currentHookNameInDev
=
'
useTransition
'
;
mountHookTypesDev
(
)
;
return
mountTransition
(
config
)
;
}
}
;
HooksDispatcherOnMountWithHookTypesInDEV
=
{
readContext
:
function
(
context
observedBits
)
{
return
readContext
(
context
observedBits
)
;
}
useCallback
:
function
(
callback
deps
)
{
currentHookNameInDev
=
'
useCallback
'
;
updateHookTypesDev
(
)
;
return
mountCallback
(
callback
deps
)
;
}
useContext
:
function
(
context
observedBits
)
{
currentHookNameInDev
=
'
useContext
'
;
updateHookTypesDev
(
)
;
return
readContext
(
context
observedBits
)
;
}
useEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useEffect
'
;
updateHookTypesDev
(
)
;
return
mountEffect
(
create
deps
)
;
}
useImperativeHandle
:
function
(
ref
create
deps
)
{
currentHookNameInDev
=
'
useImperativeHandle
'
;
updateHookTypesDev
(
)
;
return
mountImperativeHandle
(
ref
create
deps
)
;
}
useLayoutEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useLayoutEffect
'
;
updateHookTypesDev
(
)
;
return
mountLayoutEffect
(
create
deps
)
;
}
useMemo
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useMemo
'
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountMemo
(
create
deps
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useReducer
:
function
(
reducer
initialArg
init
)
{
currentHookNameInDev
=
'
useReducer
'
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountReducer
(
reducer
initialArg
init
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useRef
:
function
(
initialValue
)
{
currentHookNameInDev
=
'
useRef
'
;
updateHookTypesDev
(
)
;
return
mountRef
(
initialValue
)
;
}
useState
:
function
(
initialState
)
{
currentHookNameInDev
=
'
useState
'
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountState
(
initialState
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useDebugValue
:
function
(
value
formatterFn
)
{
currentHookNameInDev
=
'
useDebugValue
'
;
updateHookTypesDev
(
)
;
return
mountDebugValue
(
value
formatterFn
)
;
}
useResponder
:
function
(
responder
props
)
{
currentHookNameInDev
=
'
useResponder
'
;
updateHookTypesDev
(
)
;
return
createResponderListener
(
responder
props
)
;
}
useDeferredValue
:
function
(
value
config
)
{
currentHookNameInDev
=
'
useDeferredValue
'
;
updateHookTypesDev
(
)
;
return
mountDeferredValue
(
value
config
)
;
}
useTransition
:
function
(
config
)
{
currentHookNameInDev
=
'
useTransition
'
;
updateHookTypesDev
(
)
;
return
mountTransition
(
config
)
;
}
}
;
HooksDispatcherOnUpdateInDEV
=
{
readContext
:
function
(
context
observedBits
)
{
return
readContext
(
context
observedBits
)
;
}
useCallback
:
function
(
callback
deps
)
{
currentHookNameInDev
=
'
useCallback
'
;
updateHookTypesDev
(
)
;
return
updateCallback
(
callback
deps
)
;
}
useContext
:
function
(
context
observedBits
)
{
currentHookNameInDev
=
'
useContext
'
;
updateHookTypesDev
(
)
;
return
readContext
(
context
observedBits
)
;
}
useEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useEffect
'
;
updateHookTypesDev
(
)
;
return
updateEffect
(
create
deps
)
;
}
useImperativeHandle
:
function
(
ref
create
deps
)
{
currentHookNameInDev
=
'
useImperativeHandle
'
;
updateHookTypesDev
(
)
;
return
updateImperativeHandle
(
ref
create
deps
)
;
}
useLayoutEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useLayoutEffect
'
;
updateHookTypesDev
(
)
;
return
updateLayoutEffect
(
create
deps
)
;
}
useMemo
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useMemo
'
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnUpdateInDEV
;
try
{
return
updateMemo
(
create
deps
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useReducer
:
function
(
reducer
initialArg
init
)
{
currentHookNameInDev
=
'
useReducer
'
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnUpdateInDEV
;
try
{
return
updateReducer
(
reducer
initialArg
init
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useRef
:
function
(
initialValue
)
{
currentHookNameInDev
=
'
useRef
'
;
updateHookTypesDev
(
)
;
return
updateRef
(
initialValue
)
;
}
useState
:
function
(
initialState
)
{
currentHookNameInDev
=
'
useState
'
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnUpdateInDEV
;
try
{
return
updateState
(
initialState
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useDebugValue
:
function
(
value
formatterFn
)
{
currentHookNameInDev
=
'
useDebugValue
'
;
updateHookTypesDev
(
)
;
return
updateDebugValue
(
value
formatterFn
)
;
}
useResponder
:
function
(
responder
props
)
{
currentHookNameInDev
=
'
useResponder
'
;
updateHookTypesDev
(
)
;
return
createResponderListener
(
responder
props
)
;
}
useDeferredValue
:
function
(
value
config
)
{
currentHookNameInDev
=
'
useDeferredValue
'
;
updateHookTypesDev
(
)
;
return
updateDeferredValue
(
value
config
)
;
}
useTransition
:
function
(
config
)
{
currentHookNameInDev
=
'
useTransition
'
;
updateHookTypesDev
(
)
;
return
updateTransition
(
config
)
;
}
}
;
InvalidNestedHooksDispatcherOnMountInDEV
=
{
readContext
:
function
(
context
observedBits
)
{
warnInvalidContextAccess
(
)
;
return
readContext
(
context
observedBits
)
;
}
useCallback
:
function
(
callback
deps
)
{
currentHookNameInDev
=
'
useCallback
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
mountCallback
(
callback
deps
)
;
}
useContext
:
function
(
context
observedBits
)
{
currentHookNameInDev
=
'
useContext
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
readContext
(
context
observedBits
)
;
}
useEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useEffect
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
mountEffect
(
create
deps
)
;
}
useImperativeHandle
:
function
(
ref
create
deps
)
{
currentHookNameInDev
=
'
useImperativeHandle
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
mountImperativeHandle
(
ref
create
deps
)
;
}
useLayoutEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useLayoutEffect
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
mountLayoutEffect
(
create
deps
)
;
}
useMemo
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useMemo
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountMemo
(
create
deps
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useReducer
:
function
(
reducer
initialArg
init
)
{
currentHookNameInDev
=
'
useReducer
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountReducer
(
reducer
initialArg
init
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useRef
:
function
(
initialValue
)
{
currentHookNameInDev
=
'
useRef
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
mountRef
(
initialValue
)
;
}
useState
:
function
(
initialState
)
{
currentHookNameInDev
=
'
useState
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnMountInDEV
;
try
{
return
mountState
(
initialState
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useDebugValue
:
function
(
value
formatterFn
)
{
currentHookNameInDev
=
'
useDebugValue
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
mountDebugValue
(
value
formatterFn
)
;
}
useResponder
:
function
(
responder
props
)
{
currentHookNameInDev
=
'
useResponder
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
createResponderListener
(
responder
props
)
;
}
useDeferredValue
:
function
(
value
config
)
{
currentHookNameInDev
=
'
useDeferredValue
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
mountDeferredValue
(
value
config
)
;
}
useTransition
:
function
(
config
)
{
currentHookNameInDev
=
'
useTransition
'
;
warnInvalidHookAccess
(
)
;
mountHookTypesDev
(
)
;
return
mountTransition
(
config
)
;
}
}
;
InvalidNestedHooksDispatcherOnUpdateInDEV
=
{
readContext
:
function
(
context
observedBits
)
{
warnInvalidContextAccess
(
)
;
return
readContext
(
context
observedBits
)
;
}
useCallback
:
function
(
callback
deps
)
{
currentHookNameInDev
=
'
useCallback
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
updateCallback
(
callback
deps
)
;
}
useContext
:
function
(
context
observedBits
)
{
currentHookNameInDev
=
'
useContext
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
readContext
(
context
observedBits
)
;
}
useEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useEffect
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
updateEffect
(
create
deps
)
;
}
useImperativeHandle
:
function
(
ref
create
deps
)
{
currentHookNameInDev
=
'
useImperativeHandle
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
updateImperativeHandle
(
ref
create
deps
)
;
}
useLayoutEffect
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useLayoutEffect
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
updateLayoutEffect
(
create
deps
)
;
}
useMemo
:
function
(
create
deps
)
{
currentHookNameInDev
=
'
useMemo
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnUpdateInDEV
;
try
{
return
updateMemo
(
create
deps
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useReducer
:
function
(
reducer
initialArg
init
)
{
currentHookNameInDev
=
'
useReducer
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnUpdateInDEV
;
try
{
return
updateReducer
(
reducer
initialArg
init
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useRef
:
function
(
initialValue
)
{
currentHookNameInDev
=
'
useRef
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
updateRef
(
initialValue
)
;
}
useState
:
function
(
initialState
)
{
currentHookNameInDev
=
'
useState
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
var
prevDispatcher
=
ReactCurrentDispatcher
1
.
current
;
ReactCurrentDispatcher
1
.
current
=
InvalidNestedHooksDispatcherOnUpdateInDEV
;
try
{
return
updateState
(
initialState
)
;
}
finally
{
ReactCurrentDispatcher
1
.
current
=
prevDispatcher
;
}
}
useDebugValue
:
function
(
value
formatterFn
)
{
currentHookNameInDev
=
'
useDebugValue
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
updateDebugValue
(
value
formatterFn
)
;
}
useResponder
:
function
(
responder
props
)
{
currentHookNameInDev
=
'
useResponder
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
createResponderListener
(
responder
props
)
;
}
useDeferredValue
:
function
(
value
config
)
{
currentHookNameInDev
=
'
useDeferredValue
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
updateDeferredValue
(
value
config
)
;
}
useTransition
:
function
(
config
)
{
currentHookNameInDev
=
'
useTransition
'
;
warnInvalidHookAccess
(
)
;
updateHookTypesDev
(
)
;
return
updateTransition
(
config
)
;
}
}
;
}
var
now
1
=
unstable_now
;
var
commitTime
=
0
;
var
profilerStartTime
=
-
1
;
function
getCommitTime
(
)
{
return
commitTime
;
}
function
recordCommitTime
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
commitTime
=
now
1
(
)
;
}
function
startProfilerTimer
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
profilerStartTime
=
now
1
(
)
;
if
(
fiber
.
actualStartTime
<
0
)
{
fiber
.
actualStartTime
=
now
1
(
)
;
}
}
function
stopProfilerTimerIfRunning
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
profilerStartTime
=
-
1
;
}
function
stopProfilerTimerIfRunningAndRecordDelta
(
fiber
overrideBaseTime
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
if
(
profilerStartTime
>
=
0
)
{
var
elapsedTime
=
now
1
(
)
-
profilerStartTime
;
fiber
.
actualDuration
+
=
elapsedTime
;
if
(
overrideBaseTime
)
{
fiber
.
selfBaseDuration
=
elapsedTime
;
}
profilerStartTime
=
-
1
;
}
}
var
hydrationParentFiber
=
null
;
var
nextHydratableInstance
=
null
;
var
isHydrating
=
false
;
function
warnIfHydrating
(
)
{
{
!
!
isHydrating
?
warning
1
(
false
'
We
should
not
be
hydrating
here
.
This
is
a
bug
in
React
.
Please
file
a
bug
.
'
)
:
void
0
;
}
}
function
enterHydrationState
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
var
parentInstance
=
fiber
.
stateNode
.
containerInfo
;
nextHydratableInstance
=
getFirstHydratableChild
(
parentInstance
)
;
hydrationParentFiber
=
fiber
;
isHydrating
=
true
;
return
true
;
}
function
reenterHydrationStateFromDehydratedSuspenseInstance
(
fiber
suspenseInstance
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
nextHydratableInstance
=
getNextHydratableSibling
(
suspenseInstance
)
;
popToNextHostParent
(
fiber
)
;
isHydrating
=
true
;
return
true
;
}
function
deleteHydratableInstance
(
returnFiber
instance
)
{
{
switch
(
returnFiber
.
tag
)
{
case
HostRoot
:
didNotHydrateContainerInstance
(
returnFiber
.
stateNode
.
containerInfo
instance
)
;
break
;
case
HostComponent
:
didNotHydrateInstance
(
returnFiber
.
type
returnFiber
.
memoizedProps
returnFiber
.
stateNode
instance
)
;
break
;
}
}
var
childToDelete
=
createFiberFromHostInstanceForDeletion
(
)
;
childToDelete
.
stateNode
=
instance
;
childToDelete
.
return
=
returnFiber
;
childToDelete
.
effectTag
=
Deletion
;
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
}
function
insertNonHydratedInstance
(
returnFiber
fiber
)
{
fiber
.
effectTag
=
fiber
.
effectTag
&
~
Hydrating
|
Placement
;
{
switch
(
returnFiber
.
tag
)
{
case
HostRoot
:
{
var
parentContainer
=
returnFiber
.
stateNode
.
containerInfo
;
switch
(
fiber
.
tag
)
{
case
HostComponent
:
var
type
=
fiber
.
type
;
var
props
=
fiber
.
pendingProps
;
didNotFindHydratableContainerInstance
(
parentContainer
type
props
)
;
break
;
case
HostText
:
var
text
=
fiber
.
pendingProps
;
didNotFindHydratableContainerTextInstance
(
parentContainer
text
)
;
break
;
case
SuspenseComponent
:
break
;
}
break
;
}
case
HostComponent
:
{
var
parentType
=
returnFiber
.
type
;
var
parentProps
=
returnFiber
.
memoizedProps
;
var
parentInstance
=
returnFiber
.
stateNode
;
switch
(
fiber
.
tag
)
{
case
HostComponent
:
var
_type
=
fiber
.
type
;
var
_props
=
fiber
.
pendingProps
;
didNotFindHydratableInstance
(
parentType
parentProps
parentInstance
_type
_props
)
;
break
;
case
HostText
:
var
_text
=
fiber
.
pendingProps
;
didNotFindHydratableTextInstance
(
parentType
parentProps
parentInstance
_text
)
;
break
;
case
SuspenseComponent
:
didNotFindHydratableSuspenseInstance
(
parentType
parentProps
parentInstance
)
;
break
;
}
break
;
}
default
:
return
;
}
}
}
function
tryHydrate
(
fiber
nextInstance
)
{
switch
(
fiber
.
tag
)
{
case
HostComponent
:
{
var
type
=
fiber
.
type
;
var
props
=
fiber
.
pendingProps
;
var
instance
=
canHydrateInstance
(
nextInstance
type
props
)
;
if
(
instance
!
=
=
null
)
{
fiber
.
stateNode
=
instance
;
return
true
;
}
return
false
;
}
case
HostText
:
{
var
text
=
fiber
.
pendingProps
;
var
textInstance
=
canHydrateTextInstance
(
nextInstance
text
)
;
if
(
textInstance
!
=
=
null
)
{
fiber
.
stateNode
=
textInstance
;
return
true
;
}
return
false
;
}
case
SuspenseComponent
:
{
if
(
enableSuspenseServerRenderer
)
{
var
suspenseInstance
=
canHydrateSuspenseInstance
(
nextInstance
)
;
if
(
suspenseInstance
!
=
=
null
)
{
var
suspenseState
=
{
dehydrated
:
suspenseInstance
retryTime
:
Never
}
;
fiber
.
memoizedState
=
suspenseState
;
var
dehydratedFragment
=
createFiberFromDehydratedFragment
(
suspenseInstance
)
;
dehydratedFragment
.
return
=
fiber
;
fiber
.
child
=
dehydratedFragment
;
return
true
;
}
}
return
false
;
}
default
:
return
false
;
}
}
function
tryToClaimNextHydratableInstance
(
fiber
)
{
if
(
!
isHydrating
)
{
return
;
}
var
nextInstance
=
nextHydratableInstance
;
if
(
!
nextInstance
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
var
firstAttemptedInstance
=
nextInstance
;
if
(
!
tryHydrate
(
fiber
nextInstance
)
)
{
nextInstance
=
getNextHydratableSibling
(
firstAttemptedInstance
)
;
if
(
!
nextInstance
|
|
!
tryHydrate
(
fiber
nextInstance
)
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
deleteHydratableInstance
(
hydrationParentFiber
firstAttemptedInstance
)
;
}
hydrationParentFiber
=
fiber
;
nextHydratableInstance
=
getFirstHydratableChild
(
nextInstance
)
;
}
function
prepareToHydrateHostInstance
(
fiber
rootContainerInstance
hostContext
)
{
if
(
!
supportsHydration
)
{
{
{
throw
Error
(
"
Expected
prepareToHydrateHostInstance
(
)
to
never
be
called
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
var
instance
=
fiber
.
stateNode
;
var
updatePayload
=
hydrateInstance
(
instance
fiber
.
type
fiber
.
memoizedProps
rootContainerInstance
hostContext
fiber
)
;
fiber
.
updateQueue
=
updatePayload
;
if
(
updatePayload
!
=
=
null
)
{
return
true
;
}
return
false
;
}
function
prepareToHydrateHostTextInstance
(
fiber
)
{
if
(
!
supportsHydration
)
{
{
{
throw
Error
(
"
Expected
prepareToHydrateHostTextInstance
(
)
to
never
be
called
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
var
textInstance
=
fiber
.
stateNode
;
var
textContent
=
fiber
.
memoizedProps
;
var
shouldUpdate
=
hydrateTextInstance
(
textInstance
textContent
fiber
)
;
{
if
(
shouldUpdate
)
{
var
returnFiber
=
hydrationParentFiber
;
if
(
returnFiber
!
=
=
null
)
{
switch
(
returnFiber
.
tag
)
{
case
HostRoot
:
{
var
parentContainer
=
returnFiber
.
stateNode
.
containerInfo
;
didNotMatchHydratedContainerTextInstance
(
parentContainer
textInstance
textContent
)
;
break
;
}
case
HostComponent
:
{
var
parentType
=
returnFiber
.
type
;
var
parentProps
=
returnFiber
.
memoizedProps
;
var
parentInstance
=
returnFiber
.
stateNode
;
didNotMatchHydratedTextInstance
(
parentType
parentProps
parentInstance
textInstance
textContent
)
;
break
;
}
}
}
}
}
return
shouldUpdate
;
}
function
prepareToHydrateHostSuspenseInstance
(
fiber
)
{
if
(
!
supportsHydration
)
{
{
{
throw
Error
(
"
Expected
prepareToHydrateHostSuspenseInstance
(
)
to
never
be
called
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
var
suspenseState
=
fiber
.
memoizedState
;
var
suspenseInstance
=
suspenseState
!
=
=
null
?
suspenseState
.
dehydrated
:
null
;
if
(
!
suspenseInstance
)
{
{
throw
Error
(
"
Expected
to
have
a
hydrated
suspense
instance
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
hydrateSuspenseInstance
(
suspenseInstance
fiber
)
;
}
function
skipPastDehydratedSuspenseInstance
(
fiber
)
{
if
(
!
supportsHydration
)
{
{
{
throw
Error
(
"
Expected
skipPastDehydratedSuspenseInstance
(
)
to
never
be
called
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
var
suspenseState
=
fiber
.
memoizedState
;
var
suspenseInstance
=
suspenseState
!
=
=
null
?
suspenseState
.
dehydrated
:
null
;
if
(
!
suspenseInstance
)
{
{
throw
Error
(
"
Expected
to
have
a
hydrated
suspense
instance
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
return
getNextHydratableInstanceAfterSuspenseInstance
(
suspenseInstance
)
;
}
function
popToNextHostParent
(
fiber
)
{
var
parent
=
fiber
.
return
;
while
(
parent
!
=
=
null
&
&
parent
.
tag
!
=
=
HostComponent
&
&
parent
.
tag
!
=
=
HostRoot
&
&
parent
.
tag
!
=
=
SuspenseComponent
)
{
parent
=
parent
.
return
;
}
hydrationParentFiber
=
parent
;
}
function
popHydrationState
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
if
(
fiber
!
=
=
hydrationParentFiber
)
{
return
false
;
}
if
(
!
isHydrating
)
{
popToNextHostParent
(
fiber
)
;
isHydrating
=
true
;
return
false
;
}
var
type
=
fiber
.
type
;
if
(
fiber
.
tag
!
=
=
HostComponent
|
|
type
!
=
=
'
head
'
&
&
type
!
=
=
'
body
'
&
&
!
shouldSetTextContent
(
type
fiber
.
memoizedProps
)
)
{
var
nextInstance
=
nextHydratableInstance
;
while
(
nextInstance
)
{
deleteHydratableInstance
(
fiber
nextInstance
)
;
nextInstance
=
getNextHydratableSibling
(
nextInstance
)
;
}
}
popToNextHostParent
(
fiber
)
;
if
(
fiber
.
tag
=
=
=
SuspenseComponent
)
{
nextHydratableInstance
=
skipPastDehydratedSuspenseInstance
(
fiber
)
;
}
else
{
nextHydratableInstance
=
hydrationParentFiber
?
getNextHydratableSibling
(
fiber
.
stateNode
)
:
null
;
}
return
true
;
}
function
resetHydrationState
(
)
{
if
(
!
supportsHydration
)
{
return
;
}
hydrationParentFiber
=
null
;
nextHydratableInstance
=
null
;
isHydrating
=
false
;
}
var
ReactCurrentOwner
3
=
ReactSharedInternals
.
ReactCurrentOwner
;
var
didReceiveUpdate
=
false
;
var
didWarnAboutBadClass
;
var
didWarnAboutModulePatternComponent
;
var
didWarnAboutContextTypeOnFunctionComponent
;
var
didWarnAboutGetDerivedStateOnFunctionComponent
;
var
didWarnAboutFunctionRefs
;
var
didWarnAboutReassigningProps
;
var
didWarnAboutMaxDuration
;
var
didWarnAboutRevealOrder
;
var
didWarnAboutTailOptions
;
var
didWarnAboutDefaultPropsOnFunctionComponent
;
{
didWarnAboutBadClass
=
{
}
;
didWarnAboutModulePatternComponent
=
{
}
;
didWarnAboutContextTypeOnFunctionComponent
=
{
}
;
didWarnAboutGetDerivedStateOnFunctionComponent
=
{
}
;
didWarnAboutFunctionRefs
=
{
}
;
didWarnAboutReassigningProps
=
false
;
didWarnAboutMaxDuration
=
false
;
didWarnAboutRevealOrder
=
{
}
;
didWarnAboutTailOptions
=
{
}
;
didWarnAboutDefaultPropsOnFunctionComponent
=
{
}
;
}
function
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
{
if
(
current
1
=
=
=
null
)
{
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
current
1
.
child
nextChildren
renderExpirationTime
)
;
}
}
function
forceUnmountCurrentAndReconcile
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
current
1
.
child
null
renderExpirationTime
)
;
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
function
updateForwardRef
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
{
{
if
(
workInProgress
.
type
!
=
=
workInProgress
.
elementType
)
{
var
innerPropTypes
=
Component
.
propTypes
;
if
(
innerPropTypes
)
{
checkPropTypes_1
(
innerPropTypes
nextProps
'
prop
'
getComponentName
(
Component
)
getCurrentFiberStackInDev
)
;
}
}
}
var
render
=
Component
.
render
;
var
ref
=
workInProgress
.
ref
;
var
nextChildren
;
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
{
ReactCurrentOwner
3
.
current
=
workInProgress
;
setCurrentPhase
(
'
render
'
)
;
nextChildren
=
renderWithHooks
(
current
1
workInProgress
render
nextProps
ref
renderExpirationTime
)
;
if
(
debugRenderPhaseSideEffectsForStrictMode
&
&
workInProgress
.
mode
&
StrictMode
)
{
if
(
workInProgress
.
memoizedState
!
=
=
null
)
{
nextChildren
=
renderWithHooks
(
current
1
workInProgress
render
nextProps
ref
renderExpirationTime
)
;
}
}
setCurrentPhase
(
null
)
;
}
if
(
current
1
!
=
=
null
&
&
!
didReceiveUpdate
)
{
bailoutHooks
(
current
1
workInProgress
renderExpirationTime
)
;
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateMemoComponent
(
current
1
workInProgress
Component
nextProps
updateExpirationTime
renderExpirationTime
)
{
if
(
current
1
=
=
=
null
)
{
var
type
=
Component
.
type
;
if
(
isSimpleFunctionComponent
(
type
)
&
&
Component
.
compare
=
=
=
null
&
&
Component
.
defaultProps
=
=
=
undefined
)
{
var
resolvedType
=
type
;
{
resolvedType
=
resolveFunctionForHotReloading
(
type
)
;
}
workInProgress
.
tag
=
SimpleMemoComponent
;
workInProgress
.
type
=
resolvedType
;
{
validateFunctionComponentInDev
(
workInProgress
type
)
;
}
return
updateSimpleMemoComponent
(
current
1
workInProgress
resolvedType
nextProps
updateExpirationTime
renderExpirationTime
)
;
}
{
var
innerPropTypes
=
type
.
propTypes
;
if
(
innerPropTypes
)
{
checkPropTypes_1
(
innerPropTypes
nextProps
'
prop
'
getComponentName
(
type
)
getCurrentFiberStackInDev
)
;
}
}
var
child
=
createFiberFromTypeAndProps
(
Component
.
type
null
nextProps
null
workInProgress
.
mode
renderExpirationTime
)
;
child
.
ref
=
workInProgress
.
ref
;
child
.
return
=
workInProgress
;
workInProgress
.
child
=
child
;
return
child
;
}
{
var
_type
=
Component
.
type
;
var
_innerPropTypes
=
_type
.
propTypes
;
if
(
_innerPropTypes
)
{
checkPropTypes_1
(
_innerPropTypes
nextProps
'
prop
'
getComponentName
(
_type
)
getCurrentFiberStackInDev
)
;
}
}
var
currentChild
=
current
1
.
child
;
if
(
updateExpirationTime
<
renderExpirationTime
)
{
var
prevProps
=
currentChild
.
memoizedProps
;
var
compare
=
Component
.
compare
;
compare
=
compare
!
=
=
null
?
compare
:
shallowEqual
;
if
(
compare
(
prevProps
nextProps
)
&
&
current
1
.
ref
=
=
=
workInProgress
.
ref
)
{
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
}
workInProgress
.
effectTag
|
=
PerformedWork
;
var
newChild
=
createWorkInProgress
(
currentChild
nextProps
renderExpirationTime
)
;
newChild
.
ref
=
workInProgress
.
ref
;
newChild
.
return
=
workInProgress
;
workInProgress
.
child
=
newChild
;
return
newChild
;
}
function
updateSimpleMemoComponent
(
current
1
workInProgress
Component
nextProps
updateExpirationTime
renderExpirationTime
)
{
{
if
(
workInProgress
.
type
!
=
=
workInProgress
.
elementType
)
{
var
outerMemoType
=
workInProgress
.
elementType
;
if
(
outerMemoType
.
typeof
=
=
=
REACT_LAZY_TYPE
)
{
outerMemoType
=
refineResolvedLazyComponent
(
outerMemoType
)
;
}
var
outerPropTypes
=
outerMemoType
&
&
outerMemoType
.
propTypes
;
if
(
outerPropTypes
)
{
checkPropTypes_1
(
outerPropTypes
nextProps
'
prop
'
getComponentName
(
outerMemoType
)
getCurrentFiberStackInDev
)
;
}
}
}
if
(
current
1
!
=
=
null
)
{
var
prevProps
=
current
1
.
memoizedProps
;
if
(
shallowEqual
(
prevProps
nextProps
)
&
&
current
1
.
ref
=
=
=
workInProgress
.
ref
&
&
(
workInProgress
.
type
=
=
=
current
1
.
type
)
)
{
didReceiveUpdate
=
false
;
if
(
updateExpirationTime
<
renderExpirationTime
)
{
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
}
}
return
updateFunctionComponent
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
;
}
function
updateFragment
(
current
1
workInProgress
renderExpirationTime
)
{
var
nextChildren
=
workInProgress
.
pendingProps
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateMode
(
current
1
workInProgress
renderExpirationTime
)
{
var
nextChildren
=
workInProgress
.
pendingProps
.
children
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateProfiler
(
current
1
workInProgress
renderExpirationTime
)
{
if
(
enableProfilerTimer
)
{
workInProgress
.
effectTag
|
=
Update
;
}
var
nextProps
=
workInProgress
.
pendingProps
;
var
nextChildren
=
nextProps
.
children
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
markRef
(
current
1
workInProgress
)
{
var
ref
=
workInProgress
.
ref
;
if
(
current
1
=
=
=
null
&
&
ref
!
=
=
null
|
|
current
1
!
=
=
null
&
&
current
1
.
ref
!
=
=
ref
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
}
function
updateFunctionComponent
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
{
{
if
(
workInProgress
.
type
!
=
=
workInProgress
.
elementType
)
{
var
innerPropTypes
=
Component
.
propTypes
;
if
(
innerPropTypes
)
{
checkPropTypes_1
(
innerPropTypes
nextProps
'
prop
'
getComponentName
(
Component
)
getCurrentFiberStackInDev
)
;
}
}
}
var
context
;
if
(
!
disableLegacyContext
)
{
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
Component
true
)
;
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
}
var
nextChildren
;
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
{
ReactCurrentOwner
3
.
current
=
workInProgress
;
setCurrentPhase
(
'
render
'
)
;
nextChildren
=
renderWithHooks
(
current
1
workInProgress
Component
nextProps
context
renderExpirationTime
)
;
if
(
debugRenderPhaseSideEffectsForStrictMode
&
&
workInProgress
.
mode
&
StrictMode
)
{
if
(
workInProgress
.
memoizedState
!
=
=
null
)
{
nextChildren
=
renderWithHooks
(
current
1
workInProgress
Component
nextProps
context
renderExpirationTime
)
;
}
}
setCurrentPhase
(
null
)
;
}
if
(
current
1
!
=
=
null
&
&
!
didReceiveUpdate
)
{
bailoutHooks
(
current
1
workInProgress
renderExpirationTime
)
;
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateClassComponent
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
{
{
if
(
workInProgress
.
type
!
=
=
workInProgress
.
elementType
)
{
var
innerPropTypes
=
Component
.
propTypes
;
if
(
innerPropTypes
)
{
checkPropTypes_1
(
innerPropTypes
nextProps
'
prop
'
getComponentName
(
Component
)
getCurrentFiberStackInDev
)
;
}
}
}
var
hasContext
;
if
(
isContextProvider
(
Component
)
)
{
hasContext
=
true
;
pushContextProvider
(
workInProgress
)
;
}
else
{
hasContext
=
false
;
}
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
var
instance
=
workInProgress
.
stateNode
;
var
shouldUpdate
;
if
(
instance
=
=
=
null
)
{
if
(
current
1
!
=
=
null
)
{
current
1
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
}
constructClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
mountClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
shouldUpdate
=
true
;
}
else
if
(
current
1
=
=
=
null
)
{
shouldUpdate
=
resumeMountClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
}
else
{
shouldUpdate
=
updateClassInstance
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
;
}
var
nextUnitOfWork
=
finishClassComponent
(
current
1
workInProgress
Component
shouldUpdate
hasContext
renderExpirationTime
)
;
{
var
inst
=
workInProgress
.
stateNode
;
if
(
inst
.
props
!
=
=
nextProps
)
{
!
didWarnAboutReassigningProps
?
warning
1
(
false
'
It
looks
like
%
s
is
reassigning
its
own
this
.
props
while
rendering
.
'
+
'
This
is
not
supported
and
can
lead
to
confusing
bugs
.
'
getComponentName
(
workInProgress
.
type
)
|
|
'
a
component
'
)
:
void
0
;
didWarnAboutReassigningProps
=
true
;
}
}
return
nextUnitOfWork
;
}
function
finishClassComponent
(
current
1
workInProgress
Component
shouldUpdate
hasContext
renderExpirationTime
)
{
markRef
(
current
1
workInProgress
)
;
var
didCaptureError
=
(
workInProgress
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
if
(
!
shouldUpdate
&
&
!
didCaptureError
)
{
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
Component
false
)
;
}
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
var
instance
=
workInProgress
.
stateNode
;
ReactCurrentOwner
3
.
current
=
workInProgress
;
var
nextChildren
;
if
(
didCaptureError
&
&
typeof
Component
.
getDerivedStateFromError
!
=
=
'
function
'
)
{
nextChildren
=
null
;
if
(
enableProfilerTimer
)
{
stopProfilerTimerIfRunning
(
workInProgress
)
;
}
}
else
{
{
setCurrentPhase
(
'
render
'
)
;
nextChildren
=
instance
.
render
(
)
;
if
(
debugRenderPhaseSideEffectsForStrictMode
&
&
workInProgress
.
mode
&
StrictMode
)
{
instance
.
render
(
)
;
}
setCurrentPhase
(
null
)
;
}
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
current
1
!
=
=
null
&
&
didCaptureError
)
{
forceUnmountCurrentAndReconcile
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
}
else
{
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
}
workInProgress
.
memoizedState
=
instance
.
state
;
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
Component
true
)
;
}
return
workInProgress
.
child
;
}
function
pushHostRootContext
(
workInProgress
)
{
var
root
=
workInProgress
.
stateNode
;
if
(
root
.
pendingContext
)
{
pushTopLevelContextObject
(
workInProgress
root
.
pendingContext
root
.
pendingContext
!
=
=
root
.
context
)
;
}
else
if
(
root
.
context
)
{
pushTopLevelContextObject
(
workInProgress
root
.
context
false
)
;
}
pushHostContainer
(
workInProgress
root
.
containerInfo
)
;
}
function
updateHostRoot
(
current
1
workInProgress
renderExpirationTime
)
{
pushHostRootContext
(
workInProgress
)
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
!
(
updateQueue
!
=
=
null
)
)
{
{
throw
Error
(
"
If
the
root
does
not
have
an
updateQueue
we
should
have
already
bailed
out
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevState
=
workInProgress
.
memoizedState
;
var
prevChildren
=
prevState
!
=
=
null
?
prevState
.
element
:
null
;
processUpdateQueue
(
workInProgress
updateQueue
nextProps
null
renderExpirationTime
)
;
var
nextState
=
workInProgress
.
memoizedState
;
var
nextChildren
=
nextState
.
element
;
if
(
nextChildren
=
=
=
prevChildren
)
{
resetHydrationState
(
)
;
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
var
root
=
workInProgress
.
stateNode
;
if
(
root
.
hydrate
&
&
enterHydrationState
(
workInProgress
)
)
{
var
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
workInProgress
.
child
=
child
;
var
node
=
child
;
while
(
node
)
{
node
.
effectTag
=
node
.
effectTag
&
~
Placement
|
Hydrating
;
node
=
node
.
sibling
;
}
}
else
{
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
resetHydrationState
(
)
;
}
return
workInProgress
.
child
;
}
function
updateHostComponent
(
current
1
workInProgress
renderExpirationTime
)
{
pushHostContext
(
workInProgress
)
;
if
(
current
1
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
var
type
=
workInProgress
.
type
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevProps
=
current
1
!
=
=
null
?
current
1
.
memoizedProps
:
null
;
var
nextChildren
=
nextProps
.
children
;
var
isDirectTextChild
=
shouldSetTextContent
(
type
nextProps
)
;
if
(
isDirectTextChild
)
{
nextChildren
=
null
;
}
else
if
(
prevProps
!
=
=
null
&
&
shouldSetTextContent
(
type
prevProps
)
)
{
workInProgress
.
effectTag
|
=
ContentReset
;
}
markRef
(
current
1
workInProgress
)
;
if
(
workInProgress
.
mode
&
ConcurrentMode
&
&
renderExpirationTime
!
=
=
Never
&
&
shouldDeprioritizeSubtree
(
type
nextProps
)
)
{
if
(
enableSchedulerTracing
)
{
markSpawnedWork
(
Never
)
;
}
workInProgress
.
expirationTime
=
workInProgress
.
childExpirationTime
=
Never
;
return
null
;
}
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateHostText
(
current
1
workInProgress
)
{
if
(
current
1
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
return
null
;
}
function
mountLazyComponent
(
_current
workInProgress
elementType
updateExpirationTime
renderExpirationTime
)
{
if
(
_current
!
=
=
null
)
{
_current
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
}
var
props
=
workInProgress
.
pendingProps
;
cancelWorkTimer
(
workInProgress
)
;
var
Component
=
readLazyComponentType
(
elementType
)
;
workInProgress
.
type
=
Component
;
var
resolvedTag
=
workInProgress
.
tag
=
resolveLazyComponentTag
(
Component
)
;
startWorkTimer
(
workInProgress
)
;
var
resolvedProps
=
resolveDefaultProps
(
Component
props
)
;
var
child
;
switch
(
resolvedTag
)
{
case
FunctionComponent
:
{
{
validateFunctionComponentInDev
(
workInProgress
Component
)
;
workInProgress
.
type
=
Component
=
resolveFunctionForHotReloading
(
Component
)
;
}
child
=
updateFunctionComponent
(
null
workInProgress
Component
resolvedProps
renderExpirationTime
)
;
break
;
}
case
ClassComponent
:
{
{
workInProgress
.
type
=
Component
=
resolveClassForHotReloading
(
Component
)
;
}
child
=
updateClassComponent
(
null
workInProgress
Component
resolvedProps
renderExpirationTime
)
;
break
;
}
case
ForwardRef
:
{
{
workInProgress
.
type
=
Component
=
resolveForwardRefForHotReloading
(
Component
)
;
}
child
=
updateForwardRef
(
null
workInProgress
Component
resolvedProps
renderExpirationTime
)
;
break
;
}
case
MemoComponent
:
{
{
if
(
workInProgress
.
type
!
=
=
workInProgress
.
elementType
)
{
var
outerPropTypes
=
Component
.
propTypes
;
if
(
outerPropTypes
)
{
checkPropTypes_1
(
outerPropTypes
resolvedProps
'
prop
'
getComponentName
(
Component
)
getCurrentFiberStackInDev
)
;
}
}
}
child
=
updateMemoComponent
(
null
workInProgress
Component
resolveDefaultProps
(
Component
.
type
resolvedProps
)
updateExpirationTime
renderExpirationTime
)
;
break
;
}
default
:
{
var
hint
=
'
'
;
{
if
(
Component
!
=
=
null
&
&
typeof
Component
=
=
=
'
object
'
&
&
Component
.
typeof
=
=
=
REACT_LAZY_TYPE
)
{
hint
=
'
Did
you
wrap
a
component
in
React
.
lazy
(
)
more
than
once
?
'
;
}
}
{
{
throw
Error
(
"
Element
type
is
invalid
.
Received
a
promise
that
resolves
to
:
"
+
Component
+
"
.
Lazy
element
type
must
resolve
to
a
class
or
function
.
"
+
hint
)
;
}
}
}
}
return
child
;
}
function
mountIncompleteClassComponent
(
_current
workInProgress
Component
nextProps
renderExpirationTime
)
{
if
(
_current
!
=
=
null
)
{
_current
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
}
workInProgress
.
tag
=
ClassComponent
;
var
hasContext
;
if
(
isContextProvider
(
Component
)
)
{
hasContext
=
true
;
pushContextProvider
(
workInProgress
)
;
}
else
{
hasContext
=
false
;
}
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
constructClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
mountClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
return
finishClassComponent
(
null
workInProgress
Component
true
hasContext
renderExpirationTime
)
;
}
function
mountIndeterminateComponent
(
_current
workInProgress
Component
renderExpirationTime
)
{
if
(
_current
!
=
=
null
)
{
_current
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
}
var
props
=
workInProgress
.
pendingProps
;
var
context
;
if
(
!
disableLegacyContext
)
{
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
Component
false
)
;
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
}
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
var
value
;
{
if
(
Component
.
prototype
&
&
typeof
Component
.
prototype
.
render
=
=
=
'
function
'
)
{
var
componentName
=
getComponentName
(
Component
)
|
|
'
Unknown
'
;
if
(
!
didWarnAboutBadClass
[
componentName
]
)
{
warningWithoutStack
1
(
false
"
The
<
%
s
/
>
component
appears
to
have
a
render
method
but
doesn
'
t
extend
React
.
Component
.
"
+
'
This
is
likely
to
cause
errors
.
Change
%
s
to
extend
React
.
Component
instead
.
'
componentName
componentName
)
;
didWarnAboutBadClass
[
componentName
]
=
true
;
}
}
if
(
workInProgress
.
mode
&
StrictMode
)
{
ReactStrictModeWarnings
.
recordLegacyContextWarning
(
workInProgress
null
)
;
}
ReactCurrentOwner
3
.
current
=
workInProgress
;
value
=
renderWithHooks
(
null
workInProgress
Component
props
context
renderExpirationTime
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
&
&
typeof
value
.
render
=
=
=
'
function
'
&
&
value
.
typeof
=
=
=
undefined
)
{
{
var
_componentName
=
getComponentName
(
Component
)
|
|
'
Unknown
'
;
if
(
!
didWarnAboutModulePatternComponent
[
_componentName
]
)
{
warningWithoutStack
1
(
false
'
The
<
%
s
/
>
component
appears
to
be
a
function
component
that
returns
a
class
instance
.
'
+
'
Change
%
s
to
a
class
that
extends
React
.
Component
instead
.
'
+
"
If
you
can
'
t
use
a
class
try
assigning
the
prototype
on
the
function
as
a
workaround
.
"
+
"
%
s
.
prototype
=
React
.
Component
.
prototype
.
Don
'
t
use
an
arrow
function
since
it
"
+
'
cannot
be
called
with
new
by
React
.
'
_componentName
_componentName
_componentName
)
;
didWarnAboutModulePatternComponent
[
_componentName
]
=
true
;
}
}
workInProgress
.
tag
=
ClassComponent
;
resetHooks
(
)
;
var
hasContext
=
false
;
if
(
isContextProvider
(
Component
)
)
{
hasContext
=
true
;
pushContextProvider
(
workInProgress
)
;
}
else
{
hasContext
=
false
;
}
workInProgress
.
memoizedState
=
value
.
state
!
=
=
null
&
&
value
.
state
!
=
=
undefined
?
value
.
state
:
null
;
var
getDerivedStateFromProps
=
Component
.
getDerivedStateFromProps
;
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
Component
getDerivedStateFromProps
props
)
;
}
adoptClassInstance
(
workInProgress
value
)
;
mountClassInstance
(
workInProgress
Component
props
renderExpirationTime
)
;
return
finishClassComponent
(
null
workInProgress
Component
true
hasContext
renderExpirationTime
)
;
}
else
{
workInProgress
.
tag
=
FunctionComponent
;
{
if
(
disableLegacyContext
&
&
Component
.
contextTypes
)
{
warningWithoutStack
1
(
false
'
%
s
uses
the
legacy
contextTypes
API
which
is
no
longer
supported
.
'
+
'
Use
React
.
createContext
(
)
with
React
.
useContext
(
)
instead
.
'
getComponentName
(
Component
)
|
|
'
Unknown
'
)
;
}
if
(
debugRenderPhaseSideEffectsForStrictMode
&
&
workInProgress
.
mode
&
StrictMode
)
{
if
(
workInProgress
.
memoizedState
!
=
=
null
)
{
value
=
renderWithHooks
(
null
workInProgress
Component
props
context
renderExpirationTime
)
;
}
}
}
reconcileChildren
(
null
workInProgress
value
renderExpirationTime
)
;
{
validateFunctionComponentInDev
(
workInProgress
Component
)
;
}
return
workInProgress
.
child
;
}
}
function
validateFunctionComponentInDev
(
workInProgress
Component
)
{
if
(
Component
)
{
!
!
Component
.
childContextTypes
?
warningWithoutStack
1
(
false
'
%
s
(
.
.
.
)
:
childContextTypes
cannot
be
defined
on
a
function
component
.
'
Component
.
displayName
|
|
Component
.
name
|
|
'
Component
'
)
:
void
0
;
}
if
(
workInProgress
.
ref
!
=
=
null
)
{
var
info
=
'
'
;
var
ownerName
=
getCurrentFiberOwnerNameInDevOrNull
(
)
;
if
(
ownerName
)
{
info
+
=
'
\
n
\
nCheck
the
render
method
of
'
+
ownerName
+
'
.
'
;
}
var
warningKey
=
ownerName
|
|
workInProgress
.
_debugID
|
|
'
'
;
var
debugSource
=
workInProgress
.
_debugSource
;
if
(
debugSource
)
{
warningKey
=
debugSource
.
fileName
+
'
:
'
+
debugSource
.
lineNumber
;
}
if
(
!
didWarnAboutFunctionRefs
[
warningKey
]
)
{
didWarnAboutFunctionRefs
[
warningKey
]
=
true
;
warning
1
(
false
'
Function
components
cannot
be
given
refs
.
'
+
'
Attempts
to
access
this
ref
will
fail
.
'
+
'
Did
you
mean
to
use
React
.
forwardRef
(
)
?
%
s
'
info
)
;
}
}
if
(
warnAboutDefaultPropsOnFunctionComponents
&
&
Component
.
defaultProps
!
=
=
undefined
)
{
var
componentName
=
getComponentName
(
Component
)
|
|
'
Unknown
'
;
if
(
!
didWarnAboutDefaultPropsOnFunctionComponent
[
componentName
]
)
{
warningWithoutStack
1
(
false
'
%
s
:
Support
for
defaultProps
will
be
removed
from
function
components
'
+
'
in
a
future
major
release
.
Use
JavaScript
default
parameters
instead
.
'
componentName
)
;
didWarnAboutDefaultPropsOnFunctionComponent
[
componentName
]
=
true
;
}
}
if
(
typeof
Component
.
getDerivedStateFromProps
=
=
=
'
function
'
)
{
var
_componentName2
=
getComponentName
(
Component
)
|
|
'
Unknown
'
;
if
(
!
didWarnAboutGetDerivedStateOnFunctionComponent
[
_componentName2
]
)
{
warningWithoutStack
1
(
false
'
%
s
:
Function
components
do
not
support
getDerivedStateFromProps
.
'
_componentName2
)
;
didWarnAboutGetDerivedStateOnFunctionComponent
[
_componentName2
]
=
true
;
}
}
if
(
typeof
Component
.
contextType
=
=
=
'
object
'
&
&
Component
.
contextType
!
=
=
null
)
{
var
_componentName3
=
getComponentName
(
Component
)
|
|
'
Unknown
'
;
if
(
!
didWarnAboutContextTypeOnFunctionComponent
[
_componentName3
]
)
{
warningWithoutStack
1
(
false
'
%
s
:
Function
components
do
not
support
contextType
.
'
_componentName3
)
;
didWarnAboutContextTypeOnFunctionComponent
[
_componentName3
]
=
true
;
}
}
}
var
SUSPENDED_MARKER
=
{
dehydrated
:
null
retryTime
:
NoWork
}
;
function
shouldRemainOnFallback
(
suspenseContext
current
1
workInProgress
)
{
return
hasSuspenseContext
(
suspenseContext
ForceSuspenseFallback
)
&
&
(
current
1
=
=
=
null
|
|
current
1
.
memoizedState
!
=
=
null
)
;
}
function
updateSuspenseComponent
(
current
1
workInProgress
renderExpirationTime
)
{
var
mode
=
workInProgress
.
mode
;
var
nextProps
=
workInProgress
.
pendingProps
;
{
if
(
shouldSuspend
(
workInProgress
)
)
{
workInProgress
.
effectTag
|
=
DidCapture
;
}
}
var
suspenseContext
=
suspenseStackCursor
.
current
;
var
nextDidTimeout
=
false
;
var
didSuspend
=
(
workInProgress
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
if
(
didSuspend
|
|
shouldRemainOnFallback
(
suspenseContext
current
1
workInProgress
)
)
{
nextDidTimeout
=
true
;
workInProgress
.
effectTag
&
=
~
DidCapture
;
}
else
{
if
(
current
1
=
=
=
null
|
|
current
1
.
memoizedState
!
=
=
null
)
{
if
(
nextProps
.
fallback
!
=
=
undefined
&
&
nextProps
.
unstable_avoidThisFallback
!
=
=
true
)
{
suspenseContext
=
addSubtreeSuspenseContext
(
suspenseContext
InvisibleParentSuspenseContext
)
;
}
}
}
suspenseContext
=
setDefaultShallowSuspenseContext
(
suspenseContext
)
;
pushSuspenseContext
(
workInProgress
suspenseContext
)
;
{
if
(
'
maxDuration
'
in
nextProps
)
{
if
(
!
didWarnAboutMaxDuration
)
{
didWarnAboutMaxDuration
=
true
;
warning
1
(
false
'
maxDuration
has
been
removed
from
React
.
'
+
'
Remove
the
maxDuration
prop
.
'
)
;
}
}
}
if
(
current
1
=
=
=
null
)
{
if
(
nextProps
.
fallback
!
=
=
undefined
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
if
(
enableSuspenseServerRenderer
)
{
var
suspenseState
=
workInProgress
.
memoizedState
;
if
(
suspenseState
!
=
=
null
)
{
var
dehydrated
=
suspenseState
.
dehydrated
;
if
(
dehydrated
!
=
=
null
)
{
return
mountDehydratedSuspenseComponent
(
workInProgress
dehydrated
renderExpirationTime
)
;
}
}
}
}
if
(
nextDidTimeout
)
{
var
nextFallbackChildren
=
nextProps
.
fallback
;
var
primaryChildFragment
=
createFiberFromFragment
(
null
mode
NoWork
null
)
;
primaryChildFragment
.
return
=
workInProgress
;
if
(
(
workInProgress
.
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
var
progressedState
=
workInProgress
.
memoizedState
;
var
progressedPrimaryChild
=
progressedState
!
=
=
null
?
workInProgress
.
child
.
child
:
workInProgress
.
child
;
primaryChildFragment
.
child
=
progressedPrimaryChild
;
var
progressedChild
=
progressedPrimaryChild
;
while
(
progressedChild
!
=
=
null
)
{
progressedChild
.
return
=
primaryChildFragment
;
progressedChild
=
progressedChild
.
sibling
;
}
}
var
fallbackChildFragment
=
createFiberFromFragment
(
nextFallbackChildren
mode
renderExpirationTime
null
)
;
fallbackChildFragment
.
return
=
workInProgress
;
primaryChildFragment
.
sibling
=
fallbackChildFragment
;
workInProgress
.
memoizedState
=
SUSPENDED_MARKER
;
workInProgress
.
child
=
primaryChildFragment
;
return
fallbackChildFragment
;
}
else
{
var
nextPrimaryChildren
=
nextProps
.
children
;
workInProgress
.
memoizedState
=
null
;
return
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextPrimaryChildren
renderExpirationTime
)
;
}
}
else
{
var
prevState
=
current
1
.
memoizedState
;
if
(
prevState
!
=
=
null
)
{
if
(
enableSuspenseServerRenderer
)
{
var
_dehydrated
=
prevState
.
dehydrated
;
if
(
_dehydrated
!
=
=
null
)
{
if
(
!
didSuspend
)
{
return
updateDehydratedSuspenseComponent
(
current
1
workInProgress
_dehydrated
prevState
renderExpirationTime
)
;
}
else
if
(
workInProgress
.
memoizedState
!
=
=
null
)
{
workInProgress
.
child
=
current
1
.
child
;
workInProgress
.
effectTag
|
=
DidCapture
;
return
null
;
}
else
{
var
_nextFallbackChildren
=
nextProps
.
fallback
;
var
_primaryChildFragment
=
createFiberFromFragment
(
null
mode
NoWork
null
)
;
_primaryChildFragment
.
return
=
workInProgress
;
_primaryChildFragment
.
child
=
null
;
if
(
(
workInProgress
.
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
var
_progressedChild
=
_primaryChildFragment
.
child
=
workInProgress
.
child
;
while
(
_progressedChild
!
=
=
null
)
{
_progressedChild
.
return
=
_primaryChildFragment
;
_progressedChild
=
_progressedChild
.
sibling
;
}
}
else
{
reconcileChildFibers
(
workInProgress
current
1
.
child
null
renderExpirationTime
)
;
}
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
var
treeBaseDuration
=
0
;
var
hiddenChild
=
_primaryChildFragment
.
child
;
while
(
hiddenChild
!
=
=
null
)
{
treeBaseDuration
+
=
hiddenChild
.
treeBaseDuration
;
hiddenChild
=
hiddenChild
.
sibling
;
}
_primaryChildFragment
.
treeBaseDuration
=
treeBaseDuration
;
}
var
_fallbackChildFragment
=
createFiberFromFragment
(
_nextFallbackChildren
mode
renderExpirationTime
null
)
;
_fallbackChildFragment
.
return
=
workInProgress
;
_primaryChildFragment
.
sibling
=
_fallbackChildFragment
;
_fallbackChildFragment
.
effectTag
|
=
Placement
;
_primaryChildFragment
.
childExpirationTime
=
NoWork
;
workInProgress
.
memoizedState
=
SUSPENDED_MARKER
;
workInProgress
.
child
=
_primaryChildFragment
;
return
_fallbackChildFragment
;
}
}
}
var
currentPrimaryChildFragment
=
current
1
.
child
;
var
currentFallbackChildFragment
=
currentPrimaryChildFragment
.
sibling
;
if
(
nextDidTimeout
)
{
var
_nextFallbackChildren2
=
nextProps
.
fallback
;
var
_primaryChildFragment2
=
createWorkInProgress
(
currentPrimaryChildFragment
currentPrimaryChildFragment
.
pendingProps
NoWork
)
;
_primaryChildFragment2
.
return
=
workInProgress
;
if
(
(
workInProgress
.
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
var
_progressedState
=
workInProgress
.
memoizedState
;
var
_progressedPrimaryChild
=
_progressedState
!
=
=
null
?
workInProgress
.
child
.
child
:
workInProgress
.
child
;
if
(
_progressedPrimaryChild
!
=
=
currentPrimaryChildFragment
.
child
)
{
_primaryChildFragment2
.
child
=
_progressedPrimaryChild
;
var
_progressedChild2
=
_progressedPrimaryChild
;
while
(
_progressedChild2
!
=
=
null
)
{
_progressedChild2
.
return
=
_primaryChildFragment2
;
_progressedChild2
=
_progressedChild2
.
sibling
;
}
}
}
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
var
_treeBaseDuration
=
0
;
var
_hiddenChild
=
_primaryChildFragment2
.
child
;
while
(
_hiddenChild
!
=
=
null
)
{
_treeBaseDuration
+
=
_hiddenChild
.
treeBaseDuration
;
_hiddenChild
=
_hiddenChild
.
sibling
;
}
_primaryChildFragment2
.
treeBaseDuration
=
_treeBaseDuration
;
}
var
_fallbackChildFragment2
=
createWorkInProgress
(
currentFallbackChildFragment
_nextFallbackChildren2
currentFallbackChildFragment
.
expirationTime
)
;
_fallbackChildFragment2
.
return
=
workInProgress
;
_primaryChildFragment2
.
sibling
=
_fallbackChildFragment2
;
_primaryChildFragment2
.
childExpirationTime
=
NoWork
;
workInProgress
.
memoizedState
=
SUSPENDED_MARKER
;
workInProgress
.
child
=
_primaryChildFragment2
;
return
_fallbackChildFragment2
;
}
else
{
var
_nextPrimaryChildren
=
nextProps
.
children
;
var
currentPrimaryChild
=
currentPrimaryChildFragment
.
child
;
var
primaryChild
=
reconcileChildFibers
(
workInProgress
currentPrimaryChild
_nextPrimaryChildren
renderExpirationTime
)
;
workInProgress
.
memoizedState
=
null
;
return
workInProgress
.
child
=
primaryChild
;
}
}
else
{
var
_currentPrimaryChild
=
current
1
.
child
;
if
(
nextDidTimeout
)
{
var
_nextFallbackChildren3
=
nextProps
.
fallback
;
var
_primaryChildFragment3
=
createFiberFromFragment
(
null
mode
NoWork
null
)
;
_primaryChildFragment3
.
return
=
workInProgress
;
_primaryChildFragment3
.
child
=
_currentPrimaryChild
;
if
(
_currentPrimaryChild
!
=
=
null
)
{
_currentPrimaryChild
.
return
=
_primaryChildFragment3
;
}
if
(
(
workInProgress
.
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
var
_progressedState2
=
workInProgress
.
memoizedState
;
var
_progressedPrimaryChild2
=
_progressedState2
!
=
=
null
?
workInProgress
.
child
.
child
:
workInProgress
.
child
;
_primaryChildFragment3
.
child
=
_progressedPrimaryChild2
;
var
_progressedChild3
=
_progressedPrimaryChild2
;
while
(
_progressedChild3
!
=
=
null
)
{
_progressedChild3
.
return
=
_primaryChildFragment3
;
_progressedChild3
=
_progressedChild3
.
sibling
;
}
}
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
var
_treeBaseDuration2
=
0
;
var
_hiddenChild2
=
_primaryChildFragment3
.
child
;
while
(
_hiddenChild2
!
=
=
null
)
{
_treeBaseDuration2
+
=
_hiddenChild2
.
treeBaseDuration
;
_hiddenChild2
=
_hiddenChild2
.
sibling
;
}
_primaryChildFragment3
.
treeBaseDuration
=
_treeBaseDuration2
;
}
var
_fallbackChildFragment3
=
createFiberFromFragment
(
_nextFallbackChildren3
mode
renderExpirationTime
null
)
;
_fallbackChildFragment3
.
return
=
workInProgress
;
_primaryChildFragment3
.
sibling
=
_fallbackChildFragment3
;
_fallbackChildFragment3
.
effectTag
|
=
Placement
;
_primaryChildFragment3
.
childExpirationTime
=
NoWork
;
workInProgress
.
memoizedState
=
SUSPENDED_MARKER
;
workInProgress
.
child
=
_primaryChildFragment3
;
return
_fallbackChildFragment3
;
}
else
{
workInProgress
.
memoizedState
=
null
;
var
_nextPrimaryChildren2
=
nextProps
.
children
;
return
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
_currentPrimaryChild
_nextPrimaryChildren2
renderExpirationTime
)
;
}
}
}
}
function
retrySuspenseComponentWithoutHydrating
(
current
1
workInProgress
renderExpirationTime
)
{
workInProgress
.
memoizedState
=
null
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
nextChildren
=
nextProps
.
children
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
mountDehydratedSuspenseComponent
(
workInProgress
suspenseInstance
renderExpirationTime
)
{
if
(
(
workInProgress
.
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
{
warning
1
(
false
'
Cannot
hydrate
Suspense
in
legacy
mode
.
Switch
from
'
+
'
ReactDOM
.
hydrate
(
element
container
)
to
'
+
'
ReactDOM
.
createBlockingRoot
(
container
{
hydrate
:
true
}
)
'
+
'
.
render
(
element
)
or
remove
the
Suspense
components
from
'
+
'
the
server
rendered
components
.
'
)
;
}
workInProgress
.
expirationTime
=
Sync
;
}
else
if
(
isSuspenseInstanceFallback
(
suspenseInstance
)
)
{
var
serverDisplayTime
=
requestCurrentTimeForUpdate
(
)
;
var
newExpirationTime
=
computeAsyncExpiration
(
serverDisplayTime
)
;
if
(
enableSchedulerTracing
)
{
markSpawnedWork
(
newExpirationTime
)
;
}
workInProgress
.
expirationTime
=
newExpirationTime
;
}
else
{
workInProgress
.
expirationTime
=
Never
;
if
(
enableSchedulerTracing
)
{
markSpawnedWork
(
Never
)
;
}
}
return
null
;
}
function
updateDehydratedSuspenseComponent
(
current
1
workInProgress
suspenseInstance
suspenseState
renderExpirationTime
)
{
warnIfHydrating
(
)
;
if
(
(
workInProgress
.
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
return
retrySuspenseComponentWithoutHydrating
(
current
1
workInProgress
renderExpirationTime
)
;
}
if
(
isSuspenseInstanceFallback
(
suspenseInstance
)
)
{
return
retrySuspenseComponentWithoutHydrating
(
current
1
workInProgress
renderExpirationTime
)
;
}
var
hasContextChanged
1
=
current
1
.
childExpirationTime
>
=
renderExpirationTime
;
if
(
didReceiveUpdate
|
|
hasContextChanged
1
)
{
if
(
renderExpirationTime
<
Sync
)
{
if
(
suspenseState
.
retryTime
<
=
renderExpirationTime
)
{
var
attemptHydrationAtExpirationTime
=
renderExpirationTime
+
1
;
suspenseState
.
retryTime
=
attemptHydrationAtExpirationTime
;
scheduleWork
(
current
1
attemptHydrationAtExpirationTime
)
;
}
else
{
}
}
renderDidSuspendDelayIfPossible
(
)
;
return
retrySuspenseComponentWithoutHydrating
(
current
1
workInProgress
renderExpirationTime
)
;
}
else
if
(
isSuspenseInstancePending
(
suspenseInstance
)
)
{
workInProgress
.
effectTag
|
=
DidCapture
;
workInProgress
.
child
=
current
1
.
child
;
registerSuspenseInstanceRetry
(
suspenseInstance
retryDehydratedSuspenseBoundary
.
bind
(
null
current
1
)
)
;
return
null
;
}
else
{
reenterHydrationStateFromDehydratedSuspenseInstance
(
workInProgress
suspenseInstance
)
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
nextChildren
=
nextProps
.
children
;
var
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
var
node
=
child
;
while
(
node
)
{
node
.
effectTag
|
=
Hydrating
;
node
=
node
.
sibling
;
}
workInProgress
.
child
=
child
;
return
workInProgress
.
child
;
}
}
function
scheduleWorkOnFiber
(
fiber
renderExpirationTime
)
{
if
(
fiber
.
expirationTime
<
renderExpirationTime
)
{
fiber
.
expirationTime
=
renderExpirationTime
;
}
var
alternate
=
fiber
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
.
expirationTime
<
renderExpirationTime
)
{
alternate
.
expirationTime
=
renderExpirationTime
;
}
scheduleWorkOnParentPath
(
fiber
.
return
renderExpirationTime
)
;
}
function
propagateSuspenseContextChange
(
workInProgress
firstChild
renderExpirationTime
)
{
var
node
=
firstChild
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
SuspenseComponent
)
{
var
state
=
node
.
memoizedState
;
if
(
state
!
=
=
null
)
{
scheduleWorkOnFiber
(
node
renderExpirationTime
)
;
}
}
else
if
(
node
.
tag
=
=
=
SuspenseListComponent
)
{
scheduleWorkOnFiber
(
node
renderExpirationTime
)
;
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
findLastContentRow
(
firstChild
)
{
var
row
=
firstChild
;
var
lastContentRow
=
null
;
while
(
row
!
=
=
null
)
{
var
currentRow
=
row
.
alternate
;
if
(
currentRow
!
=
=
null
&
&
findFirstSuspended
(
currentRow
)
=
=
=
null
)
{
lastContentRow
=
row
;
}
row
=
row
.
sibling
;
}
return
lastContentRow
;
}
function
validateRevealOrder
(
revealOrder
)
{
{
if
(
revealOrder
!
=
=
undefined
&
&
revealOrder
!
=
=
'
forwards
'
&
&
revealOrder
!
=
=
'
backwards
'
&
&
revealOrder
!
=
=
'
together
'
&
&
!
didWarnAboutRevealOrder
[
revealOrder
]
)
{
didWarnAboutRevealOrder
[
revealOrder
]
=
true
;
if
(
typeof
revealOrder
=
=
=
'
string
'
)
{
switch
(
revealOrder
.
toLowerCase
(
)
)
{
case
'
together
'
:
case
'
forwards
'
:
case
'
backwards
'
:
{
warning
1
(
false
'
"
%
s
"
is
not
a
valid
value
for
revealOrder
on
<
SuspenseList
/
>
.
'
+
'
Use
lowercase
"
%
s
"
instead
.
'
revealOrder
revealOrder
.
toLowerCase
(
)
)
;
break
;
}
case
'
forward
'
:
case
'
backward
'
:
{
warning
1
(
false
'
"
%
s
"
is
not
a
valid
value
for
revealOrder
on
<
SuspenseList
/
>
.
'
+
'
React
uses
the
-
s
suffix
in
the
spelling
.
Use
"
%
ss
"
instead
.
'
revealOrder
revealOrder
.
toLowerCase
(
)
)
;
break
;
}
default
:
warning
1
(
false
'
"
%
s
"
is
not
a
supported
revealOrder
on
<
SuspenseList
/
>
.
'
+
'
Did
you
mean
"
together
"
"
forwards
"
or
"
backwards
"
?
'
revealOrder
)
;
break
;
}
}
else
{
warning
1
(
false
'
%
s
is
not
a
supported
value
for
revealOrder
on
<
SuspenseList
/
>
.
'
+
'
Did
you
mean
"
together
"
"
forwards
"
or
"
backwards
"
?
'
revealOrder
)
;
}
}
}
}
function
validateTailOptions
(
tailMode
revealOrder
)
{
{
if
(
tailMode
!
=
=
undefined
&
&
!
didWarnAboutTailOptions
[
tailMode
]
)
{
if
(
tailMode
!
=
=
'
collapsed
'
&
&
tailMode
!
=
=
'
hidden
'
)
{
didWarnAboutTailOptions
[
tailMode
]
=
true
;
warning
1
(
false
'
"
%
s
"
is
not
a
supported
value
for
tail
on
<
SuspenseList
/
>
.
'
+
'
Did
you
mean
"
collapsed
"
or
"
hidden
"
?
'
tailMode
)
;
}
else
if
(
revealOrder
!
=
=
'
forwards
'
&
&
revealOrder
!
=
=
'
backwards
'
)
{
didWarnAboutTailOptions
[
tailMode
]
=
true
;
warning
1
(
false
'
<
SuspenseList
tail
=
"
%
s
"
/
>
is
only
valid
if
revealOrder
is
'
+
'
"
forwards
"
or
"
backwards
"
.
'
+
'
Did
you
mean
to
specify
revealOrder
=
"
forwards
"
?
'
tailMode
)
;
}
}
}
}
function
validateSuspenseListNestedChild
(
childSlot
index
)
{
{
var
isArray
=
Array
.
isArray
(
childSlot
)
;
var
isIterable
=
!
isArray
&
&
typeof
getIteratorFn
(
childSlot
)
=
=
=
'
function
'
;
if
(
isArray
|
|
isIterable
)
{
var
type
=
isArray
?
'
array
'
:
'
iterable
'
;
warning
1
(
false
'
A
nested
%
s
was
passed
to
row
#
%
s
in
<
SuspenseList
/
>
.
Wrap
it
in
'
+
'
an
additional
SuspenseList
to
configure
its
revealOrder
:
'
+
'
<
SuspenseList
revealOrder
=
.
.
.
>
.
.
.
'
+
'
<
SuspenseList
revealOrder
=
.
.
.
>
{
%
s
}
<
/
SuspenseList
>
.
.
.
'
+
'
<
/
SuspenseList
>
'
type
index
type
)
;
return
false
;
}
}
return
true
;
}
function
validateSuspenseListChildren
(
children
revealOrder
)
{
{
if
(
(
revealOrder
=
=
=
'
forwards
'
|
|
revealOrder
=
=
=
'
backwards
'
)
&
&
children
!
=
=
undefined
&
&
children
!
=
=
null
&
&
children
!
=
=
false
)
{
if
(
Array
.
isArray
(
children
)
)
{
for
(
var
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
if
(
!
validateSuspenseListNestedChild
(
children
[
i
]
i
)
)
{
return
;
}
}
}
else
{
var
iteratorFn
=
getIteratorFn
(
children
)
;
if
(
typeof
iteratorFn
=
=
=
'
function
'
)
{
var
childrenIterator
=
iteratorFn
.
call
(
children
)
;
if
(
childrenIterator
)
{
var
step
=
childrenIterator
.
next
(
)
;
var
_i
=
0
;
for
(
;
!
step
.
done
;
step
=
childrenIterator
.
next
(
)
)
{
if
(
!
validateSuspenseListNestedChild
(
step
.
value
_i
)
)
{
return
;
}
_i
+
+
;
}
}
}
else
{
warning
1
(
false
'
A
single
row
was
passed
to
a
<
SuspenseList
revealOrder
=
"
%
s
"
/
>
.
'
+
'
This
is
not
useful
since
it
needs
multiple
rows
.
'
+
'
Did
you
mean
to
pass
multiple
children
or
an
array
?
'
revealOrder
)
;
}
}
}
}
}
function
initSuspenseListRenderState
(
workInProgress
isBackwards
tail
lastContentRow
tailMode
lastEffectBeforeRendering
)
{
var
renderState
=
workInProgress
.
memoizedState
;
if
(
renderState
=
=
=
null
)
{
workInProgress
.
memoizedState
=
{
isBackwards
:
isBackwards
rendering
:
null
last
:
lastContentRow
tail
:
tail
tailExpiration
:
0
tailMode
:
tailMode
lastEffect
:
lastEffectBeforeRendering
}
;
}
else
{
renderState
.
isBackwards
=
isBackwards
;
renderState
.
rendering
=
null
;
renderState
.
last
=
lastContentRow
;
renderState
.
tail
=
tail
;
renderState
.
tailExpiration
=
0
;
renderState
.
tailMode
=
tailMode
;
renderState
.
lastEffect
=
lastEffectBeforeRendering
;
}
}
function
updateSuspenseListComponent
(
current
1
workInProgress
renderExpirationTime
)
{
var
nextProps
=
workInProgress
.
pendingProps
;
var
revealOrder
=
nextProps
.
revealOrder
;
var
tailMode
=
nextProps
.
tail
;
var
newChildren
=
nextProps
.
children
;
validateRevealOrder
(
revealOrder
)
;
validateTailOptions
(
tailMode
revealOrder
)
;
validateSuspenseListChildren
(
newChildren
revealOrder
)
;
reconcileChildren
(
current
1
workInProgress
newChildren
renderExpirationTime
)
;
var
suspenseContext
=
suspenseStackCursor
.
current
;
var
shouldForceFallback
=
hasSuspenseContext
(
suspenseContext
ForceSuspenseFallback
)
;
if
(
shouldForceFallback
)
{
suspenseContext
=
setShallowSuspenseContext
(
suspenseContext
ForceSuspenseFallback
)
;
workInProgress
.
effectTag
|
=
DidCapture
;
}
else
{
var
didSuspendBefore
=
current
1
!
=
=
null
&
&
(
current
1
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
if
(
didSuspendBefore
)
{
propagateSuspenseContextChange
(
workInProgress
workInProgress
.
child
renderExpirationTime
)
;
}
suspenseContext
=
setDefaultShallowSuspenseContext
(
suspenseContext
)
;
}
pushSuspenseContext
(
workInProgress
suspenseContext
)
;
if
(
(
workInProgress
.
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
workInProgress
.
memoizedState
=
null
;
}
else
{
switch
(
revealOrder
)
{
case
'
forwards
'
:
{
var
lastContentRow
=
findLastContentRow
(
workInProgress
.
child
)
;
var
tail
;
if
(
lastContentRow
=
=
=
null
)
{
tail
=
workInProgress
.
child
;
workInProgress
.
child
=
null
;
}
else
{
tail
=
lastContentRow
.
sibling
;
lastContentRow
.
sibling
=
null
;
}
initSuspenseListRenderState
(
workInProgress
false
tail
lastContentRow
tailMode
workInProgress
.
lastEffect
)
;
break
;
}
case
'
backwards
'
:
{
var
_tail
=
null
;
var
row
=
workInProgress
.
child
;
workInProgress
.
child
=
null
;
while
(
row
!
=
=
null
)
{
var
currentRow
=
row
.
alternate
;
if
(
currentRow
!
=
=
null
&
&
findFirstSuspended
(
currentRow
)
=
=
=
null
)
{
workInProgress
.
child
=
row
;
break
;
}
var
nextRow
=
row
.
sibling
;
row
.
sibling
=
_tail
;
_tail
=
row
;
row
=
nextRow
;
}
initSuspenseListRenderState
(
workInProgress
true
_tail
null
tailMode
workInProgress
.
lastEffect
)
;
break
;
}
case
'
together
'
:
{
initSuspenseListRenderState
(
workInProgress
false
null
null
undefined
workInProgress
.
lastEffect
)
;
break
;
}
default
:
{
workInProgress
.
memoizedState
=
null
;
}
}
}
return
workInProgress
.
child
;
}
function
updatePortalComponent
(
current
1
workInProgress
renderExpirationTime
)
{
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
var
nextChildren
=
workInProgress
.
pendingProps
;
if
(
current
1
=
=
=
null
)
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
}
return
workInProgress
.
child
;
}
function
updateContextProvider
(
current
1
workInProgress
renderExpirationTime
)
{
var
providerType
=
workInProgress
.
type
;
var
context
=
providerType
.
_context
;
var
newProps
=
workInProgress
.
pendingProps
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newValue
=
newProps
.
value
;
{
var
providerPropTypes
=
workInProgress
.
type
.
propTypes
;
if
(
providerPropTypes
)
{
checkPropTypes_1
(
providerPropTypes
newProps
'
prop
'
'
Context
.
Provider
'
getCurrentFiberStackInDev
)
;
}
}
pushProvider
(
workInProgress
newValue
)
;
if
(
oldProps
!
=
=
null
)
{
var
oldValue
=
oldProps
.
value
;
var
changedBits
=
calculateChangedBits
(
context
newValue
oldValue
)
;
if
(
changedBits
=
=
=
0
)
{
if
(
oldProps
.
children
=
=
=
newProps
.
children
&
&
!
hasContextChanged
(
)
)
{
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
}
else
{
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
;
}
}
var
newChildren
=
newProps
.
children
;
reconcileChildren
(
current
1
workInProgress
newChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
var
hasWarnedAboutUsingContextAsConsumer
=
false
;
function
updateContextConsumer
(
current
1
workInProgress
renderExpirationTime
)
{
var
context
=
workInProgress
.
type
;
{
if
(
context
.
_context
=
=
=
undefined
)
{
if
(
context
!
=
=
context
.
Consumer
)
{
if
(
!
hasWarnedAboutUsingContextAsConsumer
)
{
hasWarnedAboutUsingContextAsConsumer
=
true
;
warning
1
(
false
'
Rendering
<
Context
>
directly
is
not
supported
and
will
be
removed
in
'
+
'
a
future
major
release
.
Did
you
mean
to
render
<
Context
.
Consumer
>
instead
?
'
)
;
}
}
}
else
{
context
=
context
.
_context
;
}
}
var
newProps
=
workInProgress
.
pendingProps
;
var
render
=
newProps
.
children
;
{
!
(
typeof
render
=
=
=
'
function
'
)
?
warningWithoutStack
1
(
false
'
A
context
consumer
was
rendered
with
multiple
children
or
a
child
'
+
"
that
isn
'
t
a
function
.
A
context
consumer
expects
a
single
child
"
+
'
that
is
a
function
.
If
you
did
pass
a
function
make
sure
there
'
+
'
is
no
trailing
or
leading
whitespace
around
it
.
'
)
:
void
0
;
}
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
var
newValue
=
readContext
(
context
newProps
.
unstable_observedBits
)
;
var
newChildren
;
{
ReactCurrentOwner
3
.
current
=
workInProgress
;
setCurrentPhase
(
'
render
'
)
;
newChildren
=
render
(
newValue
)
;
setCurrentPhase
(
null
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
1
workInProgress
newChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateFundamentalComponent
1
(
current
1
workInProgress
renderExpirationTime
)
{
var
fundamentalImpl
=
workInProgress
.
type
.
impl
;
if
(
fundamentalImpl
.
reconcileChildren
=
=
=
false
)
{
return
null
;
}
var
nextProps
=
workInProgress
.
pendingProps
;
var
nextChildren
=
nextProps
.
children
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateScopeComponent
(
current
1
workInProgress
renderExpirationTime
)
{
var
nextProps
=
workInProgress
.
pendingProps
;
var
nextChildren
=
nextProps
.
children
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
markWorkInProgressReceivedUpdate
(
)
{
didReceiveUpdate
=
true
;
}
function
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
{
cancelWorkTimer
(
workInProgress
)
;
if
(
current
1
!
=
=
null
)
{
workInProgress
.
dependencies
=
current
1
.
dependencies
;
}
if
(
enableProfilerTimer
)
{
stopProfilerTimerIfRunning
(
workInProgress
)
;
}
var
updateExpirationTime
=
workInProgress
.
expirationTime
;
if
(
updateExpirationTime
!
=
=
NoWork
)
{
markUnprocessedUpdateTime
(
updateExpirationTime
)
;
}
var
childExpirationTime
=
workInProgress
.
childExpirationTime
;
if
(
childExpirationTime
<
renderExpirationTime
)
{
return
null
;
}
else
{
cloneChildFibers
(
current
1
workInProgress
)
;
return
workInProgress
.
child
;
}
}
function
remountFiber
(
current
1
oldWorkInProgress
newWorkInProgress
)
{
{
var
returnFiber
=
oldWorkInProgress
.
return
;
if
(
returnFiber
=
=
=
null
)
{
throw
new
Error
(
'
Cannot
swap
the
root
fiber
.
'
)
;
}
current
1
.
alternate
=
null
;
oldWorkInProgress
.
alternate
=
null
;
newWorkInProgress
.
index
=
oldWorkInProgress
.
index
;
newWorkInProgress
.
sibling
=
oldWorkInProgress
.
sibling
;
newWorkInProgress
.
return
=
oldWorkInProgress
.
return
;
newWorkInProgress
.
ref
=
oldWorkInProgress
.
ref
;
if
(
oldWorkInProgress
=
=
=
returnFiber
.
child
)
{
returnFiber
.
child
=
newWorkInProgress
;
}
else
{
var
prevSibling
=
returnFiber
.
child
;
if
(
prevSibling
=
=
=
null
)
{
throw
new
Error
(
'
Expected
parent
to
have
a
child
.
'
)
;
}
while
(
prevSibling
.
sibling
!
=
=
oldWorkInProgress
)
{
prevSibling
=
prevSibling
.
sibling
;
if
(
prevSibling
=
=
=
null
)
{
throw
new
Error
(
'
Expected
to
find
the
previous
sibling
.
'
)
;
}
}
prevSibling
.
sibling
=
newWorkInProgress
;
}
var
last
=
returnFiber
.
lastEffect
;
if
(
last
!
=
=
null
)
{
last
.
nextEffect
=
current
1
;
returnFiber
.
lastEffect
=
current
1
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
current
1
;
}
current
1
.
nextEffect
=
null
;
current
1
.
effectTag
=
Deletion
;
newWorkInProgress
.
effectTag
|
=
Placement
;
return
newWorkInProgress
;
}
}
function
beginWork
1
(
current
1
workInProgress
renderExpirationTime
)
{
var
updateExpirationTime
=
workInProgress
.
expirationTime
;
{
if
(
workInProgress
.
_debugNeedsRemount
&
&
current
1
!
=
=
null
)
{
return
remountFiber
(
current
1
workInProgress
createFiberFromTypeAndProps
(
workInProgress
.
type
workInProgress
.
key
workInProgress
.
pendingProps
workInProgress
.
_debugOwner
|
|
null
workInProgress
.
mode
workInProgress
.
expirationTime
)
)
;
}
}
if
(
current
1
!
=
=
null
)
{
var
oldProps
=
current
1
.
memoizedProps
;
var
newProps
=
workInProgress
.
pendingProps
;
if
(
oldProps
!
=
=
newProps
|
|
hasContextChanged
(
)
|
|
(
workInProgress
.
type
!
=
=
current
1
.
type
)
)
{
didReceiveUpdate
=
true
;
}
else
if
(
updateExpirationTime
<
renderExpirationTime
)
{
didReceiveUpdate
=
false
;
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
pushHostRootContext
(
workInProgress
)
;
resetHydrationState
(
)
;
break
;
case
HostComponent
:
pushHostContext
(
workInProgress
)
;
if
(
workInProgress
.
mode
&
ConcurrentMode
&
&
renderExpirationTime
!
=
=
Never
&
&
shouldDeprioritizeSubtree
(
workInProgress
.
type
newProps
)
)
{
if
(
enableSchedulerTracing
)
{
markSpawnedWork
(
Never
)
;
}
workInProgress
.
expirationTime
=
workInProgress
.
childExpirationTime
=
Never
;
return
null
;
}
break
;
case
ClassComponent
:
{
var
Component
=
workInProgress
.
type
;
if
(
isContextProvider
(
Component
)
)
{
pushContextProvider
(
workInProgress
)
;
}
break
;
}
case
HostPortal
:
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
break
;
case
ContextProvider
:
{
var
newValue
=
workInProgress
.
memoizedProps
.
value
;
pushProvider
(
workInProgress
newValue
)
;
break
;
}
case
Profiler
:
if
(
enableProfilerTimer
)
{
var
hasChildWork
=
workInProgress
.
childExpirationTime
>
=
renderExpirationTime
;
if
(
hasChildWork
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
break
;
case
SuspenseComponent
:
{
var
state
=
workInProgress
.
memoizedState
;
if
(
state
!
=
=
null
)
{
if
(
enableSuspenseServerRenderer
)
{
if
(
state
.
dehydrated
!
=
=
null
)
{
pushSuspenseContext
(
workInProgress
setDefaultShallowSuspenseContext
(
suspenseStackCursor
.
current
)
)
;
workInProgress
.
effectTag
|
=
DidCapture
;
break
;
}
}
var
primaryChildFragment
=
workInProgress
.
child
;
var
primaryChildExpirationTime
=
primaryChildFragment
.
childExpirationTime
;
if
(
primaryChildExpirationTime
!
=
=
NoWork
&
&
primaryChildExpirationTime
>
=
renderExpirationTime
)
{
return
updateSuspenseComponent
(
current
1
workInProgress
renderExpirationTime
)
;
}
else
{
pushSuspenseContext
(
workInProgress
setDefaultShallowSuspenseContext
(
suspenseStackCursor
.
current
)
)
;
var
child
=
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
if
(
child
!
=
=
null
)
{
return
child
.
sibling
;
}
else
{
return
null
;
}
}
}
else
{
pushSuspenseContext
(
workInProgress
setDefaultShallowSuspenseContext
(
suspenseStackCursor
.
current
)
)
;
}
break
;
}
case
SuspenseListComponent
:
{
var
didSuspendBefore
=
(
current
1
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
var
_hasChildWork
=
workInProgress
.
childExpirationTime
>
=
renderExpirationTime
;
if
(
didSuspendBefore
)
{
if
(
_hasChildWork
)
{
return
updateSuspenseListComponent
(
current
1
workInProgress
renderExpirationTime
)
;
}
workInProgress
.
effectTag
|
=
DidCapture
;
}
var
renderState
=
workInProgress
.
memoizedState
;
if
(
renderState
!
=
=
null
)
{
renderState
.
rendering
=
null
;
renderState
.
tail
=
null
;
}
pushSuspenseContext
(
workInProgress
suspenseStackCursor
.
current
)
;
if
(
_hasChildWork
)
{
break
;
}
else
{
return
null
;
}
}
}
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
else
{
didReceiveUpdate
=
false
;
}
}
else
{
didReceiveUpdate
=
false
;
}
workInProgress
.
expirationTime
=
NoWork
;
switch
(
workInProgress
.
tag
)
{
case
IndeterminateComponent
:
{
return
mountIndeterminateComponent
(
current
1
workInProgress
workInProgress
.
type
renderExpirationTime
)
;
}
case
LazyComponent
:
{
var
elementType
=
workInProgress
.
elementType
;
return
mountLazyComponent
(
current
1
workInProgress
elementType
updateExpirationTime
renderExpirationTime
)
;
}
case
FunctionComponent
:
{
var
_Component
=
workInProgress
.
type
;
var
unresolvedProps
=
workInProgress
.
pendingProps
;
var
resolvedProps
=
workInProgress
.
elementType
=
=
=
_Component
?
unresolvedProps
:
resolveDefaultProps
(
_Component
unresolvedProps
)
;
return
updateFunctionComponent
(
current
1
workInProgress
_Component
resolvedProps
renderExpirationTime
)
;
}
case
ClassComponent
:
{
var
_Component2
=
workInProgress
.
type
;
var
_unresolvedProps
=
workInProgress
.
pendingProps
;
var
_resolvedProps
=
workInProgress
.
elementType
=
=
=
_Component2
?
_unresolvedProps
:
resolveDefaultProps
(
_Component2
_unresolvedProps
)
;
return
updateClassComponent
(
current
1
workInProgress
_Component2
_resolvedProps
renderExpirationTime
)
;
}
case
HostRoot
:
return
updateHostRoot
(
current
1
workInProgress
renderExpirationTime
)
;
case
HostComponent
:
return
updateHostComponent
(
current
1
workInProgress
renderExpirationTime
)
;
case
HostText
:
return
updateHostText
(
current
1
workInProgress
)
;
case
SuspenseComponent
:
return
updateSuspenseComponent
(
current
1
workInProgress
renderExpirationTime
)
;
case
HostPortal
:
return
updatePortalComponent
(
current
1
workInProgress
renderExpirationTime
)
;
case
ForwardRef
:
{
var
type
=
workInProgress
.
type
;
var
_unresolvedProps2
=
workInProgress
.
pendingProps
;
var
_resolvedProps2
=
workInProgress
.
elementType
=
=
=
type
?
_unresolvedProps2
:
resolveDefaultProps
(
type
_unresolvedProps2
)
;
return
updateForwardRef
(
current
1
workInProgress
type
_resolvedProps2
renderExpirationTime
)
;
}
case
Fragment
:
return
updateFragment
(
current
1
workInProgress
renderExpirationTime
)
;
case
Mode
:
return
updateMode
(
current
1
workInProgress
renderExpirationTime
)
;
case
Profiler
:
return
updateProfiler
(
current
1
workInProgress
renderExpirationTime
)
;
case
ContextProvider
:
return
updateContextProvider
(
current
1
workInProgress
renderExpirationTime
)
;
case
ContextConsumer
:
return
updateContextConsumer
(
current
1
workInProgress
renderExpirationTime
)
;
case
MemoComponent
:
{
var
_type2
=
workInProgress
.
type
;
var
_unresolvedProps3
=
workInProgress
.
pendingProps
;
var
_resolvedProps3
=
resolveDefaultProps
(
_type2
_unresolvedProps3
)
;
{
if
(
workInProgress
.
type
!
=
=
workInProgress
.
elementType
)
{
var
outerPropTypes
=
_type2
.
propTypes
;
if
(
outerPropTypes
)
{
checkPropTypes_1
(
outerPropTypes
_resolvedProps3
'
prop
'
getComponentName
(
_type2
)
getCurrentFiberStackInDev
)
;
}
}
}
_resolvedProps3
=
resolveDefaultProps
(
_type2
.
type
_resolvedProps3
)
;
return
updateMemoComponent
(
current
1
workInProgress
_type2
_resolvedProps3
updateExpirationTime
renderExpirationTime
)
;
}
case
SimpleMemoComponent
:
{
return
updateSimpleMemoComponent
(
current
1
workInProgress
workInProgress
.
type
workInProgress
.
pendingProps
updateExpirationTime
renderExpirationTime
)
;
}
case
IncompleteClassComponent
:
{
var
_Component3
=
workInProgress
.
type
;
var
_unresolvedProps4
=
workInProgress
.
pendingProps
;
var
_resolvedProps4
=
workInProgress
.
elementType
=
=
=
_Component3
?
_unresolvedProps4
:
resolveDefaultProps
(
_Component3
_unresolvedProps4
)
;
return
mountIncompleteClassComponent
(
current
1
workInProgress
_Component3
_resolvedProps4
renderExpirationTime
)
;
}
case
SuspenseListComponent
:
{
return
updateSuspenseListComponent
(
current
1
workInProgress
renderExpirationTime
)
;
}
case
FundamentalComponent
:
{
if
(
enableFundamentalAPI
)
{
return
updateFundamentalComponent
1
(
current
1
workInProgress
renderExpirationTime
)
;
}
break
;
}
case
ScopeComponent
:
{
if
(
enableScopeAPI
)
{
return
updateScopeComponent
(
current
1
workInProgress
renderExpirationTime
)
;
}
break
;
}
}
{
{
throw
Error
(
"
Unknown
unit
of
work
tag
(
"
+
workInProgress
.
tag
+
"
)
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
function
createFundamentalStateInstance
(
currentFiber
props
impl
state
)
{
return
{
currentFiber
:
currentFiber
impl
:
impl
instance
:
null
prevProps
:
null
props
:
props
state
:
state
}
;
}
function
isFiberSuspenseAndTimedOut
(
fiber
)
{
return
fiber
.
tag
=
=
=
SuspenseComponent
&
&
fiber
.
memoizedState
!
=
=
null
;
}
function
getSuspenseFallbackChild
(
fiber
)
{
return
fiber
.
child
.
sibling
.
child
;
}
var
emptyObject
1
=
{
}
;
function
collectScopedNodes
(
node
fn
scopedNodes
)
{
if
(
enableScopeAPI
)
{
if
(
node
.
tag
=
=
=
HostComponent
)
{
var
_type
=
node
.
type
memoizedProps
=
node
.
memoizedProps
stateNode
=
node
.
stateNode
;
var
_instance
=
getPublicInstance
(
stateNode
)
;
if
(
_instance
!
=
=
null
&
&
fn
(
_type
memoizedProps
|
|
emptyObject
1
_instance
)
=
=
=
true
)
{
scopedNodes
.
push
(
_instance
)
;
}
}
var
child
=
node
.
child
;
if
(
isFiberSuspenseAndTimedOut
(
node
)
)
{
child
=
getSuspenseFallbackChild
(
node
)
;
}
if
(
child
!
=
=
null
)
{
collectScopedNodesFromChildren
(
child
fn
scopedNodes
)
;
}
}
}
function
collectFirstScopedNode
(
node
fn
)
{
if
(
enableScopeAPI
)
{
if
(
node
.
tag
=
=
=
HostComponent
)
{
var
_type2
=
node
.
type
memoizedProps
=
node
.
memoizedProps
stateNode
=
node
.
stateNode
;
var
_instance2
=
getPublicInstance
(
stateNode
)
;
if
(
_instance2
!
=
=
null
&
&
fn
(
_type2
memoizedProps
_instance2
)
=
=
=
true
)
{
return
_instance2
;
}
}
var
child
=
node
.
child
;
if
(
isFiberSuspenseAndTimedOut
(
node
)
)
{
child
=
getSuspenseFallbackChild
(
node
)
;
}
if
(
child
!
=
=
null
)
{
return
collectFirstScopedNodeFromChildren
(
child
fn
)
;
}
}
return
null
;
}
function
collectScopedNodesFromChildren
(
startingChild
fn
scopedNodes
)
{
var
child
=
startingChild
;
while
(
child
!
=
=
null
)
{
collectScopedNodes
(
child
fn
scopedNodes
)
;
child
=
child
.
sibling
;
}
}
function
collectFirstScopedNodeFromChildren
(
startingChild
fn
)
{
var
child
=
startingChild
;
while
(
child
!
=
=
null
)
{
var
scopedNode
=
collectFirstScopedNode
(
child
fn
)
;
if
(
scopedNode
!
=
=
null
)
{
return
scopedNode
;
}
child
=
child
.
sibling
;
}
return
null
;
}
function
collectNearestScopeMethods
(
node
scope
childrenScopes
)
{
if
(
isValidScopeNode
(
node
scope
)
)
{
childrenScopes
.
push
(
node
.
stateNode
.
methods
)
;
}
else
{
var
child
=
node
.
child
;
if
(
isFiberSuspenseAndTimedOut
(
node
)
)
{
child
=
getSuspenseFallbackChild
(
node
)
;
}
if
(
child
!
=
=
null
)
{
collectNearestChildScopeMethods
(
child
scope
childrenScopes
)
;
}
}
}
function
collectNearestChildScopeMethods
(
startingChild
scope
childrenScopes
)
{
var
child
=
startingChild
;
while
(
child
!
=
=
null
)
{
collectNearestScopeMethods
(
child
scope
childrenScopes
)
;
child
=
child
.
sibling
;
}
}
function
isValidScopeNode
(
node
scope
)
{
return
node
.
tag
=
=
=
ScopeComponent
&
&
node
.
type
=
=
=
scope
&
&
node
.
stateNode
!
=
=
null
;
}
function
createScopeMethods
(
scope
instance
)
{
return
{
getChildren
:
function
(
)
{
var
currentFiber
=
instance
.
fiber
;
var
child
=
currentFiber
.
child
;
var
childrenScopes
=
[
]
;
if
(
child
!
=
=
null
)
{
collectNearestChildScopeMethods
(
child
scope
childrenScopes
)
;
}
return
childrenScopes
.
length
=
=
=
0
?
null
:
childrenScopes
;
}
getChildrenFromRoot
:
function
(
)
{
var
currentFiber
=
instance
.
fiber
;
var
node
=
currentFiber
;
while
(
node
!
=
=
null
)
{
var
parent
=
node
.
return
;
if
(
parent
=
=
=
null
)
{
break
;
}
node
=
parent
;
if
(
node
.
tag
=
=
=
ScopeComponent
&
&
node
.
type
=
=
=
scope
)
{
break
;
}
}
var
childrenScopes
=
[
]
;
collectNearestChildScopeMethods
(
node
.
child
scope
childrenScopes
)
;
return
childrenScopes
.
length
=
=
=
0
?
null
:
childrenScopes
;
}
getParent
:
function
(
)
{
var
node
=
instance
.
fiber
.
return
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
ScopeComponent
&
&
node
.
type
=
=
=
scope
)
{
return
node
.
stateNode
.
methods
;
}
node
=
node
.
return
;
}
return
null
;
}
getProps
:
function
(
)
{
var
currentFiber
=
instance
.
fiber
;
return
currentFiber
.
memoizedProps
;
}
queryAllNodes
:
function
(
fn
)
{
var
currentFiber
=
instance
.
fiber
;
var
child
=
currentFiber
.
child
;
var
scopedNodes
=
[
]
;
if
(
child
!
=
=
null
)
{
collectScopedNodesFromChildren
(
child
fn
scopedNodes
)
;
}
return
scopedNodes
.
length
=
=
=
0
?
null
:
scopedNodes
;
}
queryFirstNode
:
function
(
fn
)
{
var
currentFiber
=
instance
.
fiber
;
var
child
=
currentFiber
.
child
;
if
(
child
!
=
=
null
)
{
return
collectFirstScopedNodeFromChildren
(
child
fn
)
;
}
return
null
;
}
containsNode
:
function
(
node
)
{
var
fiber
=
getInstanceFromNode
2
(
node
)
;
while
(
fiber
!
=
=
null
)
{
if
(
fiber
.
tag
=
=
=
ScopeComponent
&
&
fiber
.
type
=
=
=
scope
&
&
fiber
.
stateNode
=
=
=
instance
)
{
return
true
;
}
fiber
=
fiber
.
return
;
}
return
false
;
}
}
;
}
function
markUpdate
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Update
;
}
function
markRef
1
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
var
appendAllChildren
;
var
updateHostContainer
;
var
updateHostComponent
1
;
var
updateHostText
1
;
if
(
supportsMutation
)
{
appendAllChildren
=
function
(
parent
workInProgress
needsVisibilityToggle
isHidden
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
appendInitialChild
(
parent
node
.
stateNode
)
;
}
else
if
(
enableFundamentalAPI
&
&
node
.
tag
=
=
=
FundamentalComponent
)
{
appendInitialChild
(
parent
node
.
stateNode
.
instance
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
;
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
1
=
function
(
current
workInProgress
type
newProps
rootContainerInstance
)
{
var
oldProps
=
current
.
memoizedProps
;
if
(
oldProps
=
=
=
newProps
)
{
return
;
}
var
instance
=
workInProgress
.
stateNode
;
var
currentHostContext
=
getHostContext
(
)
;
var
updatePayload
=
prepareUpdate
(
instance
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
workInProgress
.
updateQueue
=
updatePayload
;
if
(
updatePayload
)
{
markUpdate
(
workInProgress
)
;
}
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
markUpdate
(
workInProgress
)
;
}
}
;
}
else
if
(
supportsPersistence
)
{
appendAllChildren
=
function
(
parent
workInProgress
needsVisibilityToggle
isHidden
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
branches
:
if
(
node
.
tag
=
=
=
HostComponent
)
{
var
instance
=
node
.
stateNode
;
if
(
needsVisibilityToggle
&
&
isHidden
)
{
var
props
=
node
.
memoizedProps
;
var
type
=
node
.
type
;
instance
=
cloneHiddenInstance
(
instance
type
props
node
)
;
}
appendInitialChild
(
parent
instance
)
;
}
else
if
(
node
.
tag
=
=
=
HostText
)
{
var
_instance
=
node
.
stateNode
;
if
(
needsVisibilityToggle
&
&
isHidden
)
{
var
text
=
node
.
memoizedProps
;
_instance
=
cloneHiddenTextInstance
(
_instance
text
node
)
;
}
appendInitialChild
(
parent
_instance
)
;
}
else
if
(
enableFundamentalAPI
&
&
node
.
tag
=
=
=
FundamentalComponent
)
{
var
_instance2
=
node
.
stateNode
.
instance
;
if
(
needsVisibilityToggle
&
&
isHidden
)
{
var
_props
=
node
.
memoizedProps
;
var
_type
=
node
.
type
;
_instance2
=
cloneHiddenInstance
(
_instance2
_type
_props
node
)
;
}
appendInitialChild
(
parent
_instance2
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
tag
=
=
=
SuspenseComponent
)
{
if
(
(
node
.
effectTag
&
Update
)
!
=
=
NoEffect
)
{
var
newIsHidden
=
node
.
memoizedState
!
=
=
null
;
if
(
newIsHidden
)
{
var
primaryChildParent
=
node
.
child
;
if
(
primaryChildParent
!
=
=
null
)
{
if
(
primaryChildParent
.
child
!
=
=
null
)
{
primaryChildParent
.
child
.
return
=
primaryChildParent
;
appendAllChildren
(
parent
primaryChildParent
true
newIsHidden
)
;
}
var
fallbackChildParent
=
primaryChildParent
.
sibling
;
if
(
fallbackChildParent
!
=
=
null
)
{
fallbackChildParent
.
return
=
node
;
node
=
fallbackChildParent
;
continue
;
}
}
}
}
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
node
=
node
;
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
;
var
appendAllChildrenToContainer
=
function
(
containerChildSet
workInProgress
needsVisibilityToggle
isHidden
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
branches
:
if
(
node
.
tag
=
=
=
HostComponent
)
{
var
instance
=
node
.
stateNode
;
if
(
needsVisibilityToggle
&
&
isHidden
)
{
var
props
=
node
.
memoizedProps
;
var
type
=
node
.
type
;
instance
=
cloneHiddenInstance
(
instance
type
props
node
)
;
}
appendChildToContainerChildSet
(
containerChildSet
instance
)
;
}
else
if
(
node
.
tag
=
=
=
HostText
)
{
var
_instance3
=
node
.
stateNode
;
if
(
needsVisibilityToggle
&
&
isHidden
)
{
var
text
=
node
.
memoizedProps
;
_instance3
=
cloneHiddenTextInstance
(
_instance3
text
node
)
;
}
appendChildToContainerChildSet
(
containerChildSet
_instance3
)
;
}
else
if
(
enableFundamentalAPI
&
&
node
.
tag
=
=
=
FundamentalComponent
)
{
var
_instance4
=
node
.
stateNode
.
instance
;
if
(
needsVisibilityToggle
&
&
isHidden
)
{
var
_props2
=
node
.
memoizedProps
;
var
_type2
=
node
.
type
;
_instance4
=
cloneHiddenInstance
(
_instance4
_type2
_props2
node
)
;
}
appendChildToContainerChildSet
(
containerChildSet
_instance4
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
tag
=
=
=
SuspenseComponent
)
{
if
(
(
node
.
effectTag
&
Update
)
!
=
=
NoEffect
)
{
var
newIsHidden
=
node
.
memoizedState
!
=
=
null
;
if
(
newIsHidden
)
{
var
primaryChildParent
=
node
.
child
;
if
(
primaryChildParent
!
=
=
null
)
{
if
(
primaryChildParent
.
child
!
=
=
null
)
{
primaryChildParent
.
child
.
return
=
primaryChildParent
;
appendAllChildrenToContainer
(
containerChildSet
primaryChildParent
true
newIsHidden
)
;
}
var
fallbackChildParent
=
primaryChildParent
.
sibling
;
if
(
fallbackChildParent
!
=
=
null
)
{
fallbackChildParent
.
return
=
node
;
node
=
fallbackChildParent
;
continue
;
}
}
}
}
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
node
=
node
;
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
;
updateHostContainer
=
function
(
workInProgress
)
{
var
portalOrRoot
=
workInProgress
.
stateNode
;
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
if
(
childrenUnchanged
)
{
}
else
{
var
container
=
portalOrRoot
.
containerInfo
;
var
newChildSet
=
createContainerChildSet
(
container
)
;
appendAllChildrenToContainer
(
newChildSet
workInProgress
false
false
)
;
portalOrRoot
.
pendingChildren
=
newChildSet
;
markUpdate
(
workInProgress
)
;
finalizeContainerChildren
(
container
newChildSet
)
;
}
}
;
updateHostComponent
1
=
function
(
current
workInProgress
type
newProps
rootContainerInstance
)
{
var
currentInstance
=
current
.
stateNode
;
var
oldProps
=
current
.
memoizedProps
;
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
if
(
childrenUnchanged
&
&
oldProps
=
=
=
newProps
)
{
workInProgress
.
stateNode
=
currentInstance
;
return
;
}
var
recyclableInstance
=
workInProgress
.
stateNode
;
var
currentHostContext
=
getHostContext
(
)
;
var
updatePayload
=
null
;
if
(
oldProps
!
=
=
newProps
)
{
updatePayload
=
prepareUpdate
(
recyclableInstance
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
}
if
(
childrenUnchanged
&
&
updatePayload
=
=
=
null
)
{
workInProgress
.
stateNode
=
currentInstance
;
return
;
}
var
newInstance
=
cloneInstance
(
currentInstance
updatePayload
type
oldProps
newProps
workInProgress
childrenUnchanged
recyclableInstance
)
;
if
(
finalizeInitialChildren
(
newInstance
type
newProps
rootContainerInstance
currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
newInstance
;
if
(
childrenUnchanged
)
{
markUpdate
(
workInProgress
)
;
}
else
{
appendAllChildren
(
newInstance
workInProgress
false
false
)
;
}
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
currentHostContext
=
getHostContext
(
)
;
workInProgress
.
stateNode
=
createTextInstance
(
newText
rootContainerInstance
currentHostContext
workInProgress
)
;
markUpdate
(
workInProgress
)
;
}
}
;
}
else
{
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
1
=
function
(
current
workInProgress
type
newProps
rootContainerInstance
)
{
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
}
;
}
function
cutOffTailIfNeeded
(
renderState
hasRenderedATailFallback
)
{
switch
(
renderState
.
tailMode
)
{
case
'
hidden
'
:
{
var
tailNode
=
renderState
.
tail
;
var
lastTailNode
=
null
;
while
(
tailNode
!
=
=
null
)
{
if
(
tailNode
.
alternate
!
=
=
null
)
{
lastTailNode
=
tailNode
;
}
tailNode
=
tailNode
.
sibling
;
}
if
(
lastTailNode
=
=
=
null
)
{
renderState
.
tail
=
null
;
}
else
{
lastTailNode
.
sibling
=
null
;
}
break
;
}
case
'
collapsed
'
:
{
var
_tailNode
=
renderState
.
tail
;
var
_lastTailNode
=
null
;
while
(
_tailNode
!
=
=
null
)
{
if
(
_tailNode
.
alternate
!
=
=
null
)
{
_lastTailNode
=
_tailNode
;
}
_tailNode
=
_tailNode
.
sibling
;
}
if
(
_lastTailNode
=
=
=
null
)
{
if
(
!
hasRenderedATailFallback
&
&
renderState
.
tail
!
=
=
null
)
{
renderState
.
tail
.
sibling
=
null
;
}
else
{
renderState
.
tail
=
null
;
}
}
else
{
_lastTailNode
.
sibling
=
null
;
}
break
;
}
}
}
function
completeWork
(
current
workInProgress
renderExpirationTime
)
{
var
newProps
=
workInProgress
.
pendingProps
;
switch
(
workInProgress
.
tag
)
{
case
IndeterminateComponent
:
break
;
case
LazyComponent
:
break
;
case
SimpleMemoComponent
:
case
FunctionComponent
:
break
;
case
ClassComponent
:
{
var
Component
=
workInProgress
.
type
;
if
(
isContextProvider
(
Component
)
)
{
popContext
(
workInProgress
)
;
}
break
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
fiberRoot
=
workInProgress
.
stateNode
;
if
(
fiberRoot
.
pendingContext
)
{
fiberRoot
.
context
=
fiberRoot
.
pendingContext
;
fiberRoot
.
pendingContext
=
null
;
}
if
(
current
=
=
=
null
|
|
current
.
child
=
=
=
null
)
{
var
wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
wasHydrated
)
{
markUpdate
(
workInProgress
)
;
}
}
updateHostContainer
(
workInProgress
)
;
break
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
type
=
workInProgress
.
type
;
if
(
current
!
=
=
null
&
&
workInProgress
.
stateNode
!
=
null
)
{
updateHostComponent
1
(
current
workInProgress
type
newProps
rootContainerInstance
)
;
if
(
enableFlareAPI
)
{
var
prevListeners
=
current
.
memoizedProps
.
listeners
;
var
nextListeners
=
newProps
.
listeners
;
if
(
prevListeners
!
=
=
nextListeners
)
{
markUpdate
(
workInProgress
)
;
}
}
if
(
current
.
ref
!
=
=
workInProgress
.
ref
)
{
markRef
1
(
workInProgress
)
;
}
}
else
{
if
(
!
newProps
)
{
if
(
!
(
workInProgress
.
stateNode
!
=
=
null
)
)
{
{
throw
Error
(
"
We
must
have
new
props
for
new
mounts
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
break
;
}
var
currentHostContext
=
getHostContext
(
)
;
var
_wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
_wasHydrated
)
{
if
(
prepareToHydrateHostInstance
(
workInProgress
rootContainerInstance
currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
if
(
enableFlareAPI
)
{
var
listeners
=
newProps
.
listeners
;
if
(
listeners
!
=
null
)
{
updateEventListeners
(
listeners
workInProgress
rootContainerInstance
)
;
}
}
}
else
{
var
instance
=
createInstance
(
type
newProps
rootContainerInstance
currentHostContext
workInProgress
)
;
appendAllChildren
(
instance
workInProgress
false
false
)
;
workInProgress
.
stateNode
=
instance
;
if
(
enableFlareAPI
)
{
var
_listeners
=
newProps
.
listeners
;
if
(
_listeners
!
=
null
)
{
updateEventListeners
(
_listeners
workInProgress
rootContainerInstance
)
;
}
}
if
(
finalizeInitialChildren
(
instance
type
newProps
rootContainerInstance
currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
}
if
(
workInProgress
.
ref
!
=
=
null
)
{
markRef
1
(
workInProgress
)
;
}
}
break
;
}
case
HostText
:
{
var
newText
=
newProps
;
if
(
current
&
&
workInProgress
.
stateNode
!
=
null
)
{
var
oldText
=
current
.
memoizedProps
;
updateHostText
1
(
current
workInProgress
oldText
newText
)
;
}
else
{
if
(
typeof
newText
!
=
=
'
string
'
)
{
if
(
!
(
workInProgress
.
stateNode
!
=
=
null
)
)
{
{
throw
Error
(
"
We
must
have
new
props
for
new
mounts
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
var
_rootContainerInstance
=
getRootHostContainer
(
)
;
var
_currentHostContext
=
getHostContext
(
)
;
var
_wasHydrated2
=
popHydrationState
(
workInProgress
)
;
if
(
_wasHydrated2
)
{
if
(
prepareToHydrateHostTextInstance
(
workInProgress
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
workInProgress
.
stateNode
=
createTextInstance
(
newText
_rootContainerInstance
_currentHostContext
workInProgress
)
;
}
}
break
;
}
case
ForwardRef
:
break
;
case
SuspenseComponent
:
{
popSuspenseContext
(
workInProgress
)
;
var
nextState
=
workInProgress
.
memoizedState
;
if
(
enableSuspenseServerRenderer
)
{
if
(
nextState
!
=
=
null
&
&
nextState
.
dehydrated
!
=
=
null
)
{
if
(
current
=
=
=
null
)
{
var
_wasHydrated3
=
popHydrationState
(
workInProgress
)
;
if
(
!
_wasHydrated3
)
{
{
throw
Error
(
"
A
dehydrated
suspense
component
was
completed
without
a
hydrated
node
.
This
is
probably
a
bug
in
React
.
"
)
;
}
}
prepareToHydrateHostSuspenseInstance
(
workInProgress
)
;
if
(
enableSchedulerTracing
)
{
markSpawnedWork
(
Never
)
;
}
return
null
;
}
else
{
resetHydrationState
(
)
;
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
)
{
workInProgress
.
memoizedState
=
null
;
}
workInProgress
.
effectTag
|
=
Update
;
return
null
;
}
}
}
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
)
{
workInProgress
.
expirationTime
=
renderExpirationTime
;
return
workInProgress
;
}
var
nextDidTimeout
=
nextState
!
=
=
null
;
var
prevDidTimeout
=
false
;
if
(
current
=
=
=
null
)
{
if
(
workInProgress
.
memoizedProps
.
fallback
!
=
=
undefined
)
{
popHydrationState
(
workInProgress
)
;
}
}
else
{
var
prevState
=
current
.
memoizedState
;
prevDidTimeout
=
prevState
!
=
=
null
;
if
(
!
nextDidTimeout
&
&
prevState
!
=
=
null
)
{
var
currentFallbackChild
=
current
.
child
.
sibling
;
if
(
currentFallbackChild
!
=
=
null
)
{
var
first
=
workInProgress
.
firstEffect
;
if
(
first
!
=
=
null
)
{
workInProgress
.
firstEffect
=
currentFallbackChild
;
currentFallbackChild
.
nextEffect
=
first
;
}
else
{
workInProgress
.
firstEffect
=
workInProgress
.
lastEffect
=
currentFallbackChild
;
currentFallbackChild
.
nextEffect
=
null
;
}
currentFallbackChild
.
effectTag
=
Deletion
;
}
}
}
if
(
nextDidTimeout
&
&
!
prevDidTimeout
)
{
if
(
(
workInProgress
.
mode
&
BlockingMode
)
!
=
=
NoMode
)
{
var
hasInvisibleChildContext
=
current
=
=
=
null
&
&
workInProgress
.
memoizedProps
.
unstable_avoidThisFallback
!
=
=
true
;
if
(
hasInvisibleChildContext
|
|
hasSuspenseContext
(
suspenseStackCursor
.
current
InvisibleParentSuspenseContext
)
)
{
renderDidSuspend
(
)
;
}
else
{
renderDidSuspendDelayIfPossible
(
)
;
}
}
}
if
(
supportsPersistence
)
{
if
(
nextDidTimeout
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
supportsMutation
)
{
if
(
nextDidTimeout
|
|
prevDidTimeout
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
enableSuspenseCallback
&
&
workInProgress
.
updateQueue
!
=
=
null
&
&
workInProgress
.
memoizedProps
.
suspenseCallback
!
=
null
)
{
workInProgress
.
effectTag
|
=
Update
;
}
break
;
}
case
Fragment
:
break
;
case
Mode
:
break
;
case
Profiler
:
break
;
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
updateHostContainer
(
workInProgress
)
;
break
;
case
ContextProvider
:
popProvider
(
workInProgress
)
;
break
;
case
ContextConsumer
:
break
;
case
MemoComponent
:
break
;
case
IncompleteClassComponent
:
{
var
_Component
=
workInProgress
.
type
;
if
(
isContextProvider
(
_Component
)
)
{
popContext
(
workInProgress
)
;
}
break
;
}
case
SuspenseListComponent
:
{
popSuspenseContext
(
workInProgress
)
;
var
renderState
=
workInProgress
.
memoizedState
;
if
(
renderState
=
=
=
null
)
{
break
;
}
var
didSuspendAlready
=
(
workInProgress
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
var
renderedTail
=
renderState
.
rendering
;
if
(
renderedTail
=
=
=
null
)
{
if
(
!
didSuspendAlready
)
{
var
cannotBeSuspended
=
renderHasNotSuspendedYet
(
)
&
&
(
current
=
=
=
null
|
|
(
current
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
)
;
if
(
!
cannotBeSuspended
)
{
var
row
=
workInProgress
.
child
;
while
(
row
!
=
=
null
)
{
var
suspended
=
findFirstSuspended
(
row
)
;
if
(
suspended
!
=
=
null
)
{
didSuspendAlready
=
true
;
workInProgress
.
effectTag
|
=
DidCapture
;
cutOffTailIfNeeded
(
renderState
false
)
;
var
newThennables
=
suspended
.
updateQueue
;
if
(
newThennables
!
=
=
null
)
{
workInProgress
.
updateQueue
=
newThennables
;
workInProgress
.
effectTag
|
=
Update
;
}
if
(
renderState
.
lastEffect
=
=
=
null
)
{
workInProgress
.
firstEffect
=
null
;
}
workInProgress
.
lastEffect
=
renderState
.
lastEffect
;
resetChildFibers
(
workInProgress
renderExpirationTime
)
;
pushSuspenseContext
(
workInProgress
setShallowSuspenseContext
(
suspenseStackCursor
.
current
ForceSuspenseFallback
)
)
;
return
workInProgress
.
child
;
}
row
=
row
.
sibling
;
}
}
}
else
{
cutOffTailIfNeeded
(
renderState
false
)
;
}
}
else
{
if
(
!
didSuspendAlready
)
{
var
_suspended
=
findFirstSuspended
(
renderedTail
)
;
if
(
_suspended
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
DidCapture
;
didSuspendAlready
=
true
;
var
_newThennables
=
_suspended
.
updateQueue
;
if
(
_newThennables
!
=
=
null
)
{
workInProgress
.
updateQueue
=
_newThennables
;
workInProgress
.
effectTag
|
=
Update
;
}
cutOffTailIfNeeded
(
renderState
true
)
;
if
(
renderState
.
tail
=
=
=
null
&
&
renderState
.
tailMode
=
=
=
'
hidden
'
&
&
!
renderedTail
.
alternate
)
{
var
lastEffect
=
workInProgress
.
lastEffect
=
renderState
.
lastEffect
;
if
(
lastEffect
!
=
=
null
)
{
lastEffect
.
nextEffect
=
null
;
}
return
null
;
}
}
else
if
(
now
(
)
>
renderState
.
tailExpiration
&
&
renderExpirationTime
>
Never
)
{
workInProgress
.
effectTag
|
=
DidCapture
;
didSuspendAlready
=
true
;
cutOffTailIfNeeded
(
renderState
false
)
;
var
nextPriority
=
renderExpirationTime
-
1
;
workInProgress
.
expirationTime
=
workInProgress
.
childExpirationTime
=
nextPriority
;
if
(
enableSchedulerTracing
)
{
markSpawnedWork
(
nextPriority
)
;
}
}
}
if
(
renderState
.
isBackwards
)
{
renderedTail
.
sibling
=
workInProgress
.
child
;
workInProgress
.
child
=
renderedTail
;
}
else
{
var
previousSibling
=
renderState
.
last
;
if
(
previousSibling
!
=
=
null
)
{
previousSibling
.
sibling
=
renderedTail
;
}
else
{
workInProgress
.
child
=
renderedTail
;
}
renderState
.
last
=
renderedTail
;
}
}
if
(
renderState
.
tail
!
=
=
null
)
{
if
(
renderState
.
tailExpiration
=
=
=
0
)
{
var
TAIL_EXPIRATION_TIMEOUT_MS
=
500
;
renderState
.
tailExpiration
=
now
(
)
+
TAIL_EXPIRATION_TIMEOUT_MS
;
}
var
next
=
renderState
.
tail
;
renderState
.
rendering
=
next
;
renderState
.
tail
=
next
.
sibling
;
renderState
.
lastEffect
=
workInProgress
.
lastEffect
;
next
.
sibling
=
null
;
var
suspenseContext
=
suspenseStackCursor
.
current
;
if
(
didSuspendAlready
)
{
suspenseContext
=
setShallowSuspenseContext
(
suspenseContext
ForceSuspenseFallback
)
;
}
else
{
suspenseContext
=
setDefaultShallowSuspenseContext
(
suspenseContext
)
;
}
pushSuspenseContext
(
workInProgress
suspenseContext
)
;
return
next
;
}
break
;
}
case
FundamentalComponent
:
{
if
(
enableFundamentalAPI
)
{
var
fundamentalImpl
=
workInProgress
.
type
.
impl
;
var
fundamentalInstance
=
workInProgress
.
stateNode
;
if
(
fundamentalInstance
=
=
=
null
)
{
var
getInitialState
=
fundamentalImpl
.
getInitialState
;
var
fundamentalState
;
if
(
getInitialState
!
=
=
undefined
)
{
fundamentalState
=
getInitialState
(
newProps
)
;
}
fundamentalInstance
=
workInProgress
.
stateNode
=
createFundamentalStateInstance
(
workInProgress
newProps
fundamentalImpl
fundamentalState
|
|
{
}
)
;
var
_instance5
=
getFundamentalComponentInstance
(
fundamentalInstance
)
;
fundamentalInstance
.
instance
=
_instance5
;
if
(
fundamentalImpl
.
reconcileChildren
=
=
=
false
)
{
return
null
;
}
appendAllChildren
(
_instance5
workInProgress
false
false
)
;
mountFundamentalComponent
(
fundamentalInstance
)
;
}
else
{
var
prevProps
=
fundamentalInstance
.
props
;
fundamentalInstance
.
prevProps
=
prevProps
;
fundamentalInstance
.
props
=
newProps
;
fundamentalInstance
.
currentFiber
=
workInProgress
;
if
(
supportsPersistence
)
{
var
_instance6
=
cloneFundamentalInstance
(
fundamentalInstance
)
;
fundamentalInstance
.
instance
=
_instance6
;
appendAllChildren
(
_instance6
workInProgress
false
false
)
;
}
var
shouldUpdate
=
shouldUpdateFundamentalComponent
(
fundamentalInstance
)
;
if
(
shouldUpdate
)
{
markUpdate
(
workInProgress
)
;
}
}
}
break
;
}
case
ScopeComponent
:
{
if
(
enableScopeAPI
)
{
if
(
current
=
=
=
null
)
{
var
_type3
=
workInProgress
.
type
;
var
scopeInstance
=
{
fiber
:
workInProgress
methods
:
null
}
;
workInProgress
.
stateNode
=
scopeInstance
;
scopeInstance
.
methods
=
createScopeMethods
(
_type3
scopeInstance
)
;
if
(
enableFlareAPI
)
{
var
_listeners2
=
newProps
.
listeners
;
if
(
_listeners2
!
=
null
)
{
var
_rootContainerInstance2
=
getRootHostContainer
(
)
;
updateEventListeners
(
_listeners2
workInProgress
_rootContainerInstance2
)
;
}
}
if
(
workInProgress
.
ref
!
=
=
null
)
{
markRef
1
(
workInProgress
)
;
markUpdate
(
workInProgress
)
;
}
}
else
{
if
(
enableFlareAPI
)
{
var
_prevListeners
=
current
.
memoizedProps
.
listeners
;
var
_nextListeners
=
newProps
.
listeners
;
if
(
_prevListeners
!
=
=
_nextListeners
|
|
workInProgress
.
ref
!
=
=
null
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
if
(
workInProgress
.
ref
!
=
=
null
)
{
markUpdate
(
workInProgress
)
;
}
}
if
(
current
.
ref
!
=
=
workInProgress
.
ref
)
{
markRef
1
(
workInProgress
)
;
}
}
}
break
;
}
default
:
{
{
throw
Error
(
"
Unknown
unit
of
work
tag
(
"
+
workInProgress
.
tag
+
"
)
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
return
null
;
}
function
unwindWork
(
workInProgress
renderExpirationTime
)
{
switch
(
workInProgress
.
tag
)
{
case
ClassComponent
:
{
var
Component
=
workInProgress
.
type
;
if
(
isContextProvider
(
Component
)
)
{
popContext
(
workInProgress
)
;
}
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
effectTag
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
_effectTag
=
workInProgress
.
effectTag
;
if
(
!
(
(
_effectTag
&
DidCapture
)
=
=
=
NoEffect
)
)
{
{
throw
Error
(
"
The
root
failed
to
unmount
after
an
error
.
This
is
likely
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
workInProgress
.
effectTag
=
_effectTag
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
return
null
;
}
case
SuspenseComponent
:
{
popSuspenseContext
(
workInProgress
)
;
if
(
enableSuspenseServerRenderer
)
{
var
suspenseState
=
workInProgress
.
memoizedState
;
if
(
suspenseState
!
=
=
null
&
&
suspenseState
.
dehydrated
!
=
=
null
)
{
if
(
!
(
workInProgress
.
alternate
!
=
=
null
)
)
{
{
throw
Error
(
"
Threw
in
newly
mounted
dehydrated
component
.
This
is
likely
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
resetHydrationState
(
)
;
}
}
var
_effectTag2
=
workInProgress
.
effectTag
;
if
(
_effectTag2
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
_effectTag2
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
SuspenseListComponent
:
{
popSuspenseContext
(
workInProgress
)
;
return
null
;
}
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
return
null
;
case
ContextProvider
:
popProvider
(
workInProgress
)
;
return
null
;
default
:
return
null
;
}
}
function
unwindInterruptedWork
(
interruptedWork
)
{
switch
(
interruptedWork
.
tag
)
{
case
ClassComponent
:
{
var
childContextTypes
=
interruptedWork
.
type
.
childContextTypes
;
if
(
childContextTypes
!
=
=
null
&
&
childContextTypes
!
=
=
undefined
)
{
popContext
(
interruptedWork
)
;
}
break
;
}
case
HostRoot
:
{
popHostContainer
(
interruptedWork
)
;
popTopLevelContextObject
(
interruptedWork
)
;
break
;
}
case
HostComponent
:
{
popHostContext
(
interruptedWork
)
;
break
;
}
case
HostPortal
:
popHostContainer
(
interruptedWork
)
;
break
;
case
SuspenseComponent
:
popSuspenseContext
(
interruptedWork
)
;
break
;
case
SuspenseListComponent
:
popSuspenseContext
(
interruptedWork
)
;
break
;
case
ContextProvider
:
popProvider
(
interruptedWork
)
;
break
;
default
:
break
;
}
}
function
createCapturedValue
(
value
source
)
{
return
{
value
:
value
source
:
source
stack
:
getStackByFiberInDevAndProd
(
source
)
}
;
}
function
showErrorDialog
(
capturedError
)
{
return
true
;
}
function
logCapturedError
(
capturedError
)
{
var
logError
=
showErrorDialog
(
capturedError
)
;
if
(
logError
=
=
=
false
)
{
return
;
}
var
error
=
capturedError
.
error
;
{
var
componentName
=
capturedError
.
componentName
componentStack
=
capturedError
.
componentStack
errorBoundaryName
=
capturedError
.
errorBoundaryName
errorBoundaryFound
=
capturedError
.
errorBoundaryFound
willRetry
=
capturedError
.
willRetry
;
if
(
error
!
=
null
&
&
error
.
_suppressLogging
)
{
if
(
errorBoundaryFound
&
&
willRetry
)
{
return
;
}
console
.
error
(
error
)
;
}
var
componentNameMessage
=
componentName
?
"
The
above
error
occurred
in
the
<
"
+
componentName
+
"
>
component
:
"
:
'
The
above
error
occurred
in
one
of
your
React
components
:
'
;
var
errorBoundaryMessage
;
if
(
errorBoundaryFound
&
&
errorBoundaryName
)
{
if
(
willRetry
)
{
errorBoundaryMessage
=
"
React
will
try
to
recreate
this
component
tree
from
scratch
"
+
(
"
using
the
error
boundary
you
provided
"
+
errorBoundaryName
+
"
.
"
)
;
}
else
{
errorBoundaryMessage
=
"
This
error
was
initially
handled
by
the
error
boundary
"
+
errorBoundaryName
+
"
.
\
n
"
+
"
Recreating
the
tree
from
scratch
failed
so
React
will
unmount
the
tree
.
"
;
}
}
else
{
errorBoundaryMessage
=
'
Consider
adding
an
error
boundary
to
your
tree
to
customize
error
handling
behavior
.
\
n
'
+
'
Visit
https
:
/
/
fb
.
me
/
react
-
error
-
boundaries
to
learn
more
about
error
boundaries
.
'
;
}
var
combinedMessage
=
"
"
+
componentNameMessage
+
componentStack
+
"
\
n
\
n
"
+
(
"
"
+
errorBoundaryMessage
)
;
console
.
error
(
combinedMessage
)
;
}
}
var
didWarnAboutUndefinedSnapshotBeforeUpdate
=
null
;
{
didWarnAboutUndefinedSnapshotBeforeUpdate
=
new
Set
(
)
;
}
var
PossiblyWeakSet
=
typeof
WeakSet
=
=
=
'
function
'
?
WeakSet
:
Set
;
function
logError
(
boundary
errorInfo
)
{
var
source
=
errorInfo
.
source
;
var
stack
=
errorInfo
.
stack
;
if
(
stack
=
=
=
null
&
&
source
!
=
=
null
)
{
stack
=
getStackByFiberInDevAndProd
(
source
)
;
}
var
capturedError
=
{
componentName
:
source
!
=
=
null
?
getComponentName
(
source
.
type
)
:
null
componentStack
:
stack
!
=
=
null
?
stack
:
'
'
error
:
errorInfo
.
value
errorBoundary
:
null
errorBoundaryName
:
null
errorBoundaryFound
:
false
willRetry
:
false
}
;
if
(
boundary
!
=
=
null
&
&
boundary
.
tag
=
=
=
ClassComponent
)
{
capturedError
.
errorBoundary
=
boundary
.
stateNode
;
capturedError
.
errorBoundaryName
=
getComponentName
(
boundary
.
type
)
;
capturedError
.
errorBoundaryFound
=
true
;
capturedError
.
willRetry
=
true
;
}
try
{
logCapturedError
(
capturedError
)
;
}
catch
(
e
)
{
setTimeout
(
function
(
)
{
throw
e
;
}
)
;
}
}
var
callComponentWillUnmountWithTimer
=
function
(
current
1
instance
)
{
startPhaseTimer
(
current
1
'
componentWillUnmount
'
)
;
instance
.
props
=
current
1
.
memoizedProps
;
instance
.
state
=
current
1
.
memoizedState
;
instance
.
componentWillUnmount
(
)
;
stopPhaseTimer
(
)
;
}
;
function
safelyCallComponentWillUnmount
(
current
1
instance
)
{
{
invokeGuardedCallback
(
null
callComponentWillUnmountWithTimer
null
current
1
instance
)
;
if
(
hasCaughtError
(
)
)
{
var
unmountError
=
clearCaughtError
(
)
;
captureCommitPhaseError
(
current
1
unmountError
)
;
}
}
}
function
safelyDetachRef
(
current
1
)
{
var
ref
=
current
1
.
ref
;
if
(
ref
!
=
=
null
)
{
if
(
typeof
ref
=
=
=
'
function
'
)
{
{
invokeGuardedCallback
(
null
ref
null
null
)
;
if
(
hasCaughtError
(
)
)
{
var
refError
=
clearCaughtError
(
)
;
captureCommitPhaseError
(
current
1
refError
)
;
}
}
}
else
{
ref
.
current
=
null
;
}
}
}
function
safelyCallDestroy
(
current
1
destroy
)
{
{
invokeGuardedCallback
(
null
destroy
null
)
;
if
(
hasCaughtError
(
)
)
{
var
error
=
clearCaughtError
(
)
;
captureCommitPhaseError
(
current
1
error
)
;
}
}
}
function
commitBeforeMutationLifeCycles
(
current
1
finishedWork
)
{
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountSnapshot
NoEffect
1
finishedWork
)
;
return
;
}
case
ClassComponent
:
{
if
(
finishedWork
.
effectTag
&
Snapshot
)
{
if
(
current
1
!
=
=
null
)
{
var
prevProps
=
current
1
.
memoizedProps
;
var
prevState
=
current
1
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
getSnapshotBeforeUpdate
'
)
;
var
instance
=
finishedWork
.
stateNode
;
{
if
(
finishedWork
.
type
=
=
=
finishedWork
.
elementType
&
&
!
didWarnAboutReassigningProps
)
{
!
(
instance
.
props
=
=
=
finishedWork
.
memoizedProps
)
?
warning
1
(
false
'
Expected
%
s
props
to
match
memoized
props
before
'
+
'
getSnapshotBeforeUpdate
.
'
+
'
This
might
either
be
because
of
a
bug
in
React
or
because
'
+
'
a
component
reassigns
its
own
this
.
props
.
'
+
'
Please
file
an
issue
.
'
getComponentName
(
finishedWork
.
type
)
|
|
'
instance
'
)
:
void
0
;
!
(
instance
.
state
=
=
=
finishedWork
.
memoizedState
)
?
warning
1
(
false
'
Expected
%
s
state
to
match
memoized
state
before
'
+
'
getSnapshotBeforeUpdate
.
'
+
'
This
might
either
be
because
of
a
bug
in
React
or
because
'
+
'
a
component
reassigns
its
own
this
.
props
.
'
+
'
Please
file
an
issue
.
'
getComponentName
(
finishedWork
.
type
)
|
|
'
instance
'
)
:
void
0
;
}
}
var
snapshot
=
instance
.
getSnapshotBeforeUpdate
(
finishedWork
.
elementType
=
=
=
finishedWork
.
type
?
prevProps
:
resolveDefaultProps
(
finishedWork
.
type
prevProps
)
prevState
)
;
{
var
didWarnSet
=
didWarnAboutUndefinedSnapshotBeforeUpdate
;
if
(
snapshot
=
=
=
undefined
&
&
!
didWarnSet
.
has
(
finishedWork
.
type
)
)
{
didWarnSet
.
add
(
finishedWork
.
type
)
;
warningWithoutStack
1
(
false
'
%
s
.
getSnapshotBeforeUpdate
(
)
:
A
snapshot
value
(
or
null
)
'
+
'
must
be
returned
.
You
have
returned
undefined
.
'
getComponentName
(
finishedWork
.
type
)
)
;
}
}
instance
.
__reactInternalSnapshotBeforeUpdate
=
snapshot
;
stopPhaseTimer
(
)
;
}
}
return
;
}
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
case
IncompleteClassComponent
:
return
;
default
:
{
{
{
throw
Error
(
"
This
unit
of
work
tag
should
not
have
side
-
effects
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
}
}
function
commitHookEffectList
(
unmountTag
mountTag
finishedWork
)
{
var
updateQueue
=
finishedWork
.
updateQueue
;
var
lastEffect
=
updateQueue
!
=
=
null
?
updateQueue
.
lastEffect
:
null
;
if
(
lastEffect
!
=
=
null
)
{
var
firstEffect
=
lastEffect
.
next
;
var
effect
=
firstEffect
;
do
{
if
(
(
effect
.
tag
&
unmountTag
)
!
=
=
NoEffect
1
)
{
var
destroy
=
effect
.
destroy
;
effect
.
destroy
=
undefined
;
if
(
destroy
!
=
=
undefined
)
{
destroy
(
)
;
}
}
if
(
(
effect
.
tag
&
mountTag
)
!
=
=
NoEffect
1
)
{
var
create
=
effect
.
create
;
effect
.
destroy
=
create
(
)
;
{
var
_destroy
=
effect
.
destroy
;
if
(
_destroy
!
=
=
undefined
&
&
typeof
_destroy
!
=
=
'
function
'
)
{
var
addendum
=
void
0
;
if
(
_destroy
=
=
=
null
)
{
addendum
=
'
You
returned
null
.
If
your
effect
does
not
require
clean
'
+
'
up
return
undefined
(
or
nothing
)
.
'
;
}
else
if
(
typeof
_destroy
.
then
=
=
=
'
function
'
)
{
addendum
=
'
\
n
\
nIt
looks
like
you
wrote
useEffect
(
async
(
)
=
>
.
.
.
)
or
returned
a
Promise
.
'
+
'
Instead
write
the
async
function
inside
your
effect
'
+
'
and
call
it
immediately
:
\
n
\
n
'
+
'
useEffect
(
(
)
=
>
{
\
n
'
+
'
async
function
fetchData
(
)
{
\
n
'
+
'
/
/
You
can
await
here
\
n
'
+
'
const
response
=
await
MyAPI
.
getData
(
someId
)
;
\
n
'
+
'
/
/
.
.
.
\
n
'
+
'
}
\
n
'
+
'
fetchData
(
)
;
\
n
'
+
"
}
[
someId
]
)
;
/
/
Or
[
]
if
effect
doesn
'
t
need
props
or
state
\
n
\
n
"
+
'
Learn
more
about
data
fetching
with
Hooks
:
https
:
/
/
fb
.
me
/
react
-
hooks
-
data
-
fetching
'
;
}
else
{
addendum
=
'
You
returned
:
'
+
_destroy
;
}
warningWithoutStack
1
(
false
'
An
effect
function
must
not
return
anything
besides
a
function
'
+
'
which
is
used
for
clean
-
up
.
%
s
%
s
'
addendum
getStackByFiberInDevAndProd
(
finishedWork
)
)
;
}
}
}
effect
=
effect
.
next
;
}
while
(
effect
!
=
=
firstEffect
)
;
}
}
function
commitPassiveHookEffects
(
finishedWork
)
{
if
(
(
finishedWork
.
effectTag
&
Passive
)
!
=
=
NoEffect
)
{
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountPassive
NoEffect
1
finishedWork
)
;
commitHookEffectList
(
NoEffect
1
MountPassive
finishedWork
)
;
break
;
}
default
:
break
;
}
}
}
function
commitLifeCycles
(
finishedRoot
current
1
finishedWork
committedExpirationTime
)
{
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountLayout
MountLayout
finishedWork
)
;
break
;
}
case
ClassComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
finishedWork
.
effectTag
&
Update
)
{
if
(
current
1
=
=
=
null
)
{
startPhaseTimer
(
finishedWork
'
componentDidMount
'
)
;
{
if
(
finishedWork
.
type
=
=
=
finishedWork
.
elementType
&
&
!
didWarnAboutReassigningProps
)
{
!
(
instance
.
props
=
=
=
finishedWork
.
memoizedProps
)
?
warning
1
(
false
'
Expected
%
s
props
to
match
memoized
props
before
'
+
'
componentDidMount
.
'
+
'
This
might
either
be
because
of
a
bug
in
React
or
because
'
+
'
a
component
reassigns
its
own
this
.
props
.
'
+
'
Please
file
an
issue
.
'
getComponentName
(
finishedWork
.
type
)
|
|
'
instance
'
)
:
void
0
;
!
(
instance
.
state
=
=
=
finishedWork
.
memoizedState
)
?
warning
1
(
false
'
Expected
%
s
state
to
match
memoized
state
before
'
+
'
componentDidMount
.
'
+
'
This
might
either
be
because
of
a
bug
in
React
or
because
'
+
'
a
component
reassigns
its
own
this
.
props
.
'
+
'
Please
file
an
issue
.
'
getComponentName
(
finishedWork
.
type
)
|
|
'
instance
'
)
:
void
0
;
}
}
instance
.
componentDidMount
(
)
;
stopPhaseTimer
(
)
;
}
else
{
var
prevProps
=
finishedWork
.
elementType
=
=
=
finishedWork
.
type
?
current
1
.
memoizedProps
:
resolveDefaultProps
(
finishedWork
.
type
current
1
.
memoizedProps
)
;
var
prevState
=
current
1
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
componentDidUpdate
'
)
;
{
if
(
finishedWork
.
type
=
=
=
finishedWork
.
elementType
&
&
!
didWarnAboutReassigningProps
)
{
!
(
instance
.
props
=
=
=
finishedWork
.
memoizedProps
)
?
warning
1
(
false
'
Expected
%
s
props
to
match
memoized
props
before
'
+
'
componentDidUpdate
.
'
+
'
This
might
either
be
because
of
a
bug
in
React
or
because
'
+
'
a
component
reassigns
its
own
this
.
props
.
'
+
'
Please
file
an
issue
.
'
getComponentName
(
finishedWork
.
type
)
|
|
'
instance
'
)
:
void
0
;
!
(
instance
.
state
=
=
=
finishedWork
.
memoizedState
)
?
warning
1
(
false
'
Expected
%
s
state
to
match
memoized
state
before
'
+
'
componentDidUpdate
.
'
+
'
This
might
either
be
because
of
a
bug
in
React
or
because
'
+
'
a
component
reassigns
its
own
this
.
props
.
'
+
'
Please
file
an
issue
.
'
getComponentName
(
finishedWork
.
type
)
|
|
'
instance
'
)
:
void
0
;
}
}
instance
.
componentDidUpdate
(
prevProps
prevState
instance
.
__reactInternalSnapshotBeforeUpdate
)
;
stopPhaseTimer
(
)
;
}
}
var
updateQueue
=
finishedWork
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
{
if
(
finishedWork
.
type
=
=
=
finishedWork
.
elementType
&
&
!
didWarnAboutReassigningProps
)
{
!
(
instance
.
props
=
=
=
finishedWork
.
memoizedProps
)
?
warning
1
(
false
'
Expected
%
s
props
to
match
memoized
props
before
'
+
'
processing
the
update
queue
.
'
+
'
This
might
either
be
because
of
a
bug
in
React
or
because
'
+
'
a
component
reassigns
its
own
this
.
props
.
'
+
'
Please
file
an
issue
.
'
getComponentName
(
finishedWork
.
type
)
|
|
'
instance
'
)
:
void
0
;
!
(
instance
.
state
=
=
=
finishedWork
.
memoizedState
)
?
warning
1
(
false
'
Expected
%
s
state
to
match
memoized
state
before
'
+
'
processing
the
update
queue
.
'
+
'
This
might
either
be
because
of
a
bug
in
React
or
because
'
+
'
a
component
reassigns
its
own
this
.
props
.
'
+
'
Please
file
an
issue
.
'
getComponentName
(
finishedWork
.
type
)
|
|
'
instance
'
)
:
void
0
;
}
}
commitUpdateQueue
(
finishedWork
updateQueue
instance
committedExpirationTime
)
;
}
return
;
}
case
HostRoot
:
{
var
_updateQueue
=
finishedWork
.
updateQueue
;
if
(
_updateQueue
!
=
=
null
)
{
var
_instance
=
null
;
if
(
finishedWork
.
child
!
=
=
null
)
{
switch
(
finishedWork
.
child
.
tag
)
{
case
HostComponent
:
_instance
=
getPublicInstance
(
finishedWork
.
child
.
stateNode
)
;
break
;
case
ClassComponent
:
_instance
=
finishedWork
.
child
.
stateNode
;
break
;
}
}
commitUpdateQueue
(
finishedWork
_updateQueue
_instance
committedExpirationTime
)
;
}
return
;
}
case
HostComponent
:
{
var
_instance2
=
finishedWork
.
stateNode
;
if
(
current
1
=
=
=
null
&
&
finishedWork
.
effectTag
&
Update
)
{
var
type
=
finishedWork
.
type
;
var
props
=
finishedWork
.
memoizedProps
;
commitMount
(
_instance2
type
props
finishedWork
)
;
}
return
;
}
case
HostText
:
{
return
;
}
case
HostPortal
:
{
return
;
}
case
Profiler
:
{
if
(
enableProfilerTimer
)
{
var
onRender
=
finishedWork
.
memoizedProps
.
onRender
;
if
(
typeof
onRender
=
=
=
'
function
'
)
{
if
(
enableSchedulerTracing
)
{
onRender
(
finishedWork
.
memoizedProps
.
id
current
1
=
=
=
null
?
'
mount
'
:
'
update
'
finishedWork
.
actualDuration
finishedWork
.
treeBaseDuration
finishedWork
.
actualStartTime
getCommitTime
(
)
finishedRoot
.
memoizedInteractions
)
;
}
else
{
onRender
(
finishedWork
.
memoizedProps
.
id
current
1
=
=
=
null
?
'
mount
'
:
'
update
'
finishedWork
.
actualDuration
finishedWork
.
treeBaseDuration
finishedWork
.
actualStartTime
getCommitTime
(
)
)
;
}
}
}
return
;
}
case
SuspenseComponent
:
{
commitSuspenseHydrationCallbacks
(
finishedRoot
finishedWork
)
;
return
;
}
case
SuspenseListComponent
:
case
IncompleteClassComponent
:
case
FundamentalComponent
:
case
ScopeComponent
:
return
;
default
:
{
{
{
throw
Error
(
"
This
unit
of
work
tag
should
not
have
side
-
effects
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
}
}
function
hideOrUnhideAllChildren
(
finishedWork
isHidden
)
{
if
(
supportsMutation
)
{
var
node
=
finishedWork
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
)
{
var
instance
=
node
.
stateNode
;
if
(
isHidden
)
{
hideInstance
(
instance
)
;
}
else
{
unhideInstance
(
node
.
stateNode
node
.
memoizedProps
)
;
}
}
else
if
(
node
.
tag
=
=
=
HostText
)
{
var
_instance3
=
node
.
stateNode
;
if
(
isHidden
)
{
hideTextInstance
(
_instance3
)
;
}
else
{
unhideTextInstance
(
_instance3
node
.
memoizedProps
)
;
}
}
else
if
(
node
.
tag
=
=
=
SuspenseComponent
&
&
node
.
memoizedState
!
=
=
null
&
&
node
.
memoizedState
.
dehydrated
=
=
=
null
)
{
var
fallbackChildFragment
=
node
.
child
.
sibling
;
fallbackChildFragment
.
return
=
node
;
node
=
fallbackChildFragment
;
continue
;
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
finishedWork
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
finishedWork
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
}
function
commitAttachRef
(
finishedWork
)
{
var
ref
=
finishedWork
.
ref
;
if
(
ref
!
=
=
null
)
{
var
instance
=
finishedWork
.
stateNode
;
var
instanceToUse
;
switch
(
finishedWork
.
tag
)
{
case
HostComponent
:
instanceToUse
=
getPublicInstance
(
instance
)
;
break
;
default
:
instanceToUse
=
instance
;
}
if
(
enableScopeAPI
&
&
finishedWork
.
tag
=
=
=
ScopeComponent
)
{
instanceToUse
=
instance
.
methods
;
}
if
(
typeof
ref
=
=
=
'
function
'
)
{
ref
(
instanceToUse
)
;
}
else
{
{
if
(
!
ref
.
hasOwnProperty
(
'
current
'
)
)
{
warningWithoutStack
1
(
false
'
Unexpected
ref
object
provided
for
%
s
.
'
+
'
Use
either
a
ref
-
setter
function
or
React
.
createRef
(
)
.
%
s
'
getComponentName
(
finishedWork
.
type
)
getStackByFiberInDevAndProd
(
finishedWork
)
)
;
}
}
ref
.
current
=
instanceToUse
;
}
}
}
function
commitDetachRef
(
current
1
)
{
var
currentRef
=
current
1
.
ref
;
if
(
currentRef
!
=
=
null
)
{
if
(
typeof
currentRef
=
=
=
'
function
'
)
{
currentRef
(
null
)
;
}
else
{
currentRef
.
current
=
null
;
}
}
}
function
commitUnmount
(
finishedRoot
current
1
renderPriorityLevel
)
{
onCommitUnmount
(
current
1
)
;
switch
(
current
1
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
MemoComponent
:
case
SimpleMemoComponent
:
{
var
updateQueue
=
current
1
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
var
lastEffect
=
updateQueue
.
lastEffect
;
if
(
lastEffect
!
=
=
null
)
{
var
firstEffect
=
lastEffect
.
next
;
var
priorityLevel
=
renderPriorityLevel
>
NormalPriority
?
NormalPriority
:
renderPriorityLevel
;
runWithPriority
2
(
priorityLevel
function
(
)
{
var
effect
=
firstEffect
;
do
{
var
destroy
=
effect
.
destroy
;
if
(
destroy
!
=
=
undefined
)
{
safelyCallDestroy
(
current
1
destroy
)
;
}
effect
=
effect
.
next
;
}
while
(
effect
!
=
=
firstEffect
)
;
}
)
;
}
}
break
;
}
case
ClassComponent
:
{
safelyDetachRef
(
current
1
)
;
var
instance
=
current
1
.
stateNode
;
if
(
typeof
instance
.
componentWillUnmount
=
=
=
'
function
'
)
{
safelyCallComponentWillUnmount
(
current
1
instance
)
;
}
return
;
}
case
HostComponent
:
{
if
(
enableFlareAPI
)
{
var
dependencies
=
current
1
.
dependencies
;
if
(
dependencies
!
=
=
null
)
{
var
respondersMap
=
dependencies
.
responders
;
if
(
respondersMap
!
=
=
null
)
{
var
responderInstances
=
Array
.
from
(
respondersMap
.
values
(
)
)
;
for
(
var
i
=
0
length
=
responderInstances
.
length
;
i
<
length
;
i
+
+
)
{
var
responderInstance
=
responderInstances
[
i
]
;
unmountResponderInstance
(
responderInstance
)
;
}
dependencies
.
responders
=
null
;
}
}
}
safelyDetachRef
(
current
1
)
;
return
;
}
case
HostPortal
:
{
if
(
supportsMutation
)
{
unmountHostComponents
(
finishedRoot
current
1
renderPriorityLevel
)
;
}
else
if
(
supportsPersistence
)
{
emptyPortalContainer
(
current
1
)
;
}
return
;
}
case
FundamentalComponent
:
{
if
(
enableFundamentalAPI
)
{
var
fundamentalInstance
=
current
1
.
stateNode
;
if
(
fundamentalInstance
!
=
=
null
)
{
unmountFundamentalComponent
(
fundamentalInstance
)
;
current
1
.
stateNode
=
null
;
}
}
return
;
}
case
DehydratedFragment
:
{
if
(
enableSuspenseCallback
)
{
var
hydrationCallbacks
=
finishedRoot
.
hydrationCallbacks
;
if
(
hydrationCallbacks
!
=
=
null
)
{
var
onDeleted
=
hydrationCallbacks
.
onDeleted
;
if
(
onDeleted
)
{
onDeleted
(
current
1
.
stateNode
)
;
}
}
}
return
;
}
case
ScopeComponent
:
{
if
(
enableScopeAPI
)
{
safelyDetachRef
(
current
1
)
;
}
}
}
}
function
commitNestedUnmounts
(
finishedRoot
root
renderPriorityLevel
)
{
var
node
=
root
;
while
(
true
)
{
commitUnmount
(
finishedRoot
node
renderPriorityLevel
)
;
if
(
node
.
child
!
=
=
null
&
&
(
!
supportsMutation
|
|
node
.
tag
!
=
=
HostPortal
)
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
root
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
root
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
detachFiber
(
current
1
)
{
var
alternate
=
current
1
.
alternate
;
current
1
.
return
=
null
;
current
1
.
child
=
null
;
current
1
.
memoizedState
=
null
;
current
1
.
updateQueue
=
null
;
current
1
.
dependencies
=
null
;
current
1
.
alternate
=
null
;
current
1
.
firstEffect
=
null
;
current
1
.
lastEffect
=
null
;
current
1
.
pendingProps
=
null
;
current
1
.
memoizedProps
=
null
;
if
(
alternate
!
=
=
null
)
{
detachFiber
(
alternate
)
;
}
}
function
emptyPortalContainer
(
current
1
)
{
if
(
!
supportsPersistence
)
{
return
;
}
var
portal
=
current
1
.
stateNode
;
var
containerInfo
=
portal
.
containerInfo
;
var
emptyChildSet
=
createContainerChildSet
(
containerInfo
)
;
replaceContainerChildren
(
containerInfo
emptyChildSet
)
;
}
function
commitContainer
(
finishedWork
)
{
if
(
!
supportsPersistence
)
{
return
;
}
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
case
HostComponent
:
case
HostText
:
case
FundamentalComponent
:
{
return
;
}
case
HostRoot
:
case
HostPortal
:
{
var
portalOrRoot
=
finishedWork
.
stateNode
;
var
containerInfo
=
portalOrRoot
.
containerInfo
pendingChildren
=
portalOrRoot
.
pendingChildren
;
replaceContainerChildren
(
containerInfo
pendingChildren
)
;
return
;
}
default
:
{
{
{
throw
Error
(
"
This
unit
of
work
tag
should
not
have
side
-
effects
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
}
}
function
getHostParentFiber
(
fiber
)
{
var
parent
=
fiber
.
return
;
while
(
parent
!
=
=
null
)
{
if
(
isHostParent
(
parent
)
)
{
return
parent
;
}
parent
=
parent
.
return
;
}
{
{
throw
Error
(
"
Expected
to
find
a
host
parent
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
function
isHostParent
(
fiber
)
{
return
fiber
.
tag
=
=
=
HostComponent
|
|
fiber
.
tag
=
=
=
HostRoot
|
|
fiber
.
tag
=
=
=
HostPortal
;
}
function
getHostSibling
(
fiber
)
{
var
node
=
fiber
;
siblings
:
while
(
true
)
{
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
isHostParent
(
node
.
return
)
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
while
(
node
.
tag
!
=
=
HostComponent
&
&
node
.
tag
!
=
=
HostText
&
&
node
.
tag
!
=
=
DehydratedFragment
)
{
if
(
node
.
effectTag
&
Placement
)
{
continue
siblings
;
}
if
(
node
.
child
=
=
=
null
|
|
node
.
tag
=
=
=
HostPortal
)
{
continue
siblings
;
}
else
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
}
}
if
(
!
(
node
.
effectTag
&
Placement
)
)
{
return
node
.
stateNode
;
}
}
}
function
commitPlacement
(
finishedWork
)
{
if
(
!
supportsMutation
)
{
return
;
}
var
parentFiber
=
getHostParentFiber
(
finishedWork
)
;
var
parent
;
var
isContainer
;
var
parentStateNode
=
parentFiber
.
stateNode
;
switch
(
parentFiber
.
tag
)
{
case
HostComponent
:
parent
=
parentStateNode
;
isContainer
=
false
;
break
;
case
HostRoot
:
parent
=
parentStateNode
.
containerInfo
;
isContainer
=
true
;
break
;
case
HostPortal
:
parent
=
parentStateNode
.
containerInfo
;
isContainer
=
true
;
break
;
case
FundamentalComponent
:
if
(
enableFundamentalAPI
)
{
parent
=
parentStateNode
.
instance
;
isContainer
=
false
;
}
default
:
{
{
throw
Error
(
"
Invalid
host
parent
fiber
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
if
(
parentFiber
.
effectTag
&
ContentReset
)
{
resetTextContent
(
parent
)
;
parentFiber
.
effectTag
&
=
~
ContentReset
;
}
var
before
=
getHostSibling
(
finishedWork
)
;
var
node
=
finishedWork
;
while
(
true
)
{
var
isHost
=
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
;
if
(
isHost
|
|
enableFundamentalAPI
&
&
node
.
tag
=
=
=
FundamentalComponent
)
{
var
stateNode
=
isHost
?
node
.
stateNode
:
node
.
stateNode
.
instance
;
if
(
before
)
{
if
(
isContainer
)
{
insertInContainerBefore
(
parent
stateNode
before
)
;
}
else
{
insertBefore
(
parent
stateNode
before
)
;
}
}
else
{
if
(
isContainer
)
{
appendChildToContainer
(
parent
stateNode
)
;
}
else
{
appendChild
(
parent
stateNode
)
;
}
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
finishedWork
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
finishedWork
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
unmountHostComponents
(
finishedRoot
current
1
renderPriorityLevel
)
{
var
node
=
current
1
;
var
currentParentIsValid
=
false
;
var
currentParent
;
var
currentParentIsContainer
;
while
(
true
)
{
if
(
!
currentParentIsValid
)
{
var
parent
=
node
.
return
;
findParent
:
while
(
true
)
{
if
(
!
(
parent
!
=
=
null
)
)
{
{
throw
Error
(
"
Expected
to
find
a
host
parent
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
var
parentStateNode
=
parent
.
stateNode
;
switch
(
parent
.
tag
)
{
case
HostComponent
:
currentParent
=
parentStateNode
;
currentParentIsContainer
=
false
;
break
findParent
;
case
HostRoot
:
currentParent
=
parentStateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
case
HostPortal
:
currentParent
=
parentStateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
case
FundamentalComponent
:
if
(
enableFundamentalAPI
)
{
currentParent
=
parentStateNode
.
instance
;
currentParentIsContainer
=
false
;
}
}
parent
=
parent
.
return
;
}
currentParentIsValid
=
true
;
}
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
commitNestedUnmounts
(
finishedRoot
node
renderPriorityLevel
)
;
if
(
currentParentIsContainer
)
{
removeChildFromContainer
(
currentParent
node
.
stateNode
)
;
}
else
{
removeChild
(
currentParent
node
.
stateNode
)
;
}
}
else
if
(
enableFundamentalAPI
&
&
node
.
tag
=
=
=
FundamentalComponent
)
{
var
fundamentalNode
=
node
.
stateNode
.
instance
;
commitNestedUnmounts
(
finishedRoot
node
renderPriorityLevel
)
;
if
(
currentParentIsContainer
)
{
removeChildFromContainer
(
currentParent
fundamentalNode
)
;
}
else
{
removeChild
(
currentParent
fundamentalNode
)
;
}
}
else
if
(
enableSuspenseServerRenderer
&
&
node
.
tag
=
=
=
DehydratedFragment
)
{
if
(
enableSuspenseCallback
)
{
var
hydrationCallbacks
=
finishedRoot
.
hydrationCallbacks
;
if
(
hydrationCallbacks
!
=
=
null
)
{
var
onDeleted
=
hydrationCallbacks
.
onDeleted
;
if
(
onDeleted
)
{
onDeleted
(
node
.
stateNode
)
;
}
}
}
if
(
currentParentIsContainer
)
{
clearSuspenseBoundaryFromContainer
(
currentParent
node
.
stateNode
)
;
}
else
{
clearSuspenseBoundary
(
currentParent
node
.
stateNode
)
;
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
if
(
node
.
child
!
=
=
null
)
{
currentParent
=
node
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
{
commitUnmount
(
finishedRoot
node
renderPriorityLevel
)
;
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
if
(
node
=
=
=
current
1
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
current
1
)
{
return
;
}
node
=
node
.
return
;
if
(
node
.
tag
=
=
=
HostPortal
)
{
currentParentIsValid
=
false
;
}
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
commitDeletion
(
finishedRoot
current
1
renderPriorityLevel
)
{
if
(
supportsMutation
)
{
unmountHostComponents
(
finishedRoot
current
1
renderPriorityLevel
)
;
}
else
{
commitNestedUnmounts
(
finishedRoot
current
1
renderPriorityLevel
)
;
}
detachFiber
(
current
1
)
;
}
function
commitWork
(
current
1
finishedWork
)
{
if
(
!
supportsMutation
)
{
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
MemoComponent
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountMutation
MountMutation
finishedWork
)
;
return
;
}
case
Profiler
:
{
return
;
}
case
SuspenseComponent
:
{
commitSuspenseComponent
(
finishedWork
)
;
attachSuspenseRetryListeners
(
finishedWork
)
;
return
;
}
case
SuspenseListComponent
:
{
attachSuspenseRetryListeners
(
finishedWork
)
;
return
;
}
case
HostRoot
:
{
if
(
supportsHydration
)
{
var
root
=
finishedWork
.
stateNode
;
if
(
root
.
hydrate
)
{
root
.
hydrate
=
false
;
commitHydratedContainer
(
root
.
containerInfo
)
;
}
}
break
;
}
}
commitContainer
(
finishedWork
)
;
return
;
}
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
MemoComponent
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountMutation
MountMutation
finishedWork
)
;
return
;
}
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
instance
!
=
null
)
{
var
newProps
=
finishedWork
.
memoizedProps
;
var
oldProps
=
current
1
!
=
=
null
?
current
1
.
memoizedProps
:
newProps
;
var
type
=
finishedWork
.
type
;
var
updatePayload
=
finishedWork
.
updateQueue
;
finishedWork
.
updateQueue
=
null
;
if
(
updatePayload
!
=
=
null
)
{
commitUpdate
(
instance
updatePayload
type
oldProps
newProps
finishedWork
)
;
}
if
(
enableFlareAPI
)
{
var
prevListeners
=
oldProps
.
listeners
;
var
nextListeners
=
newProps
.
listeners
;
if
(
prevListeners
!
=
=
nextListeners
)
{
updateEventListeners
(
nextListeners
finishedWork
null
)
;
}
}
}
return
;
}
case
HostText
:
{
if
(
!
(
finishedWork
.
stateNode
!
=
=
null
)
)
{
{
throw
Error
(
"
This
should
have
a
text
node
initialized
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
var
textInstance
=
finishedWork
.
stateNode
;
var
newText
=
finishedWork
.
memoizedProps
;
var
oldText
=
current
1
!
=
=
null
?
current
1
.
memoizedProps
:
newText
;
commitTextUpdate
(
textInstance
oldText
newText
)
;
return
;
}
case
HostRoot
:
{
if
(
supportsHydration
)
{
var
_root
=
finishedWork
.
stateNode
;
if
(
_root
.
hydrate
)
{
_root
.
hydrate
=
false
;
commitHydratedContainer
(
_root
.
containerInfo
)
;
}
}
return
;
}
case
Profiler
:
{
return
;
}
case
SuspenseComponent
:
{
commitSuspenseComponent
(
finishedWork
)
;
attachSuspenseRetryListeners
(
finishedWork
)
;
return
;
}
case
SuspenseListComponent
:
{
attachSuspenseRetryListeners
(
finishedWork
)
;
return
;
}
case
IncompleteClassComponent
:
{
return
;
}
case
FundamentalComponent
:
{
if
(
enableFundamentalAPI
)
{
var
fundamentalInstance
=
finishedWork
.
stateNode
;
updateFundamentalComponent
(
fundamentalInstance
)
;
}
return
;
}
case
ScopeComponent
:
{
if
(
enableScopeAPI
)
{
var
scopeInstance
=
finishedWork
.
stateNode
;
scopeInstance
.
fiber
=
finishedWork
;
if
(
enableFlareAPI
)
{
var
_newProps
=
finishedWork
.
memoizedProps
;
var
_oldProps
=
current
1
!
=
=
null
?
current
1
.
memoizedProps
:
_newProps
;
var
_prevListeners
=
_oldProps
.
listeners
;
var
_nextListeners
=
_newProps
.
listeners
;
if
(
_prevListeners
!
=
=
_nextListeners
)
{
updateEventListeners
(
_nextListeners
finishedWork
null
)
;
}
}
}
return
;
}
default
:
{
{
{
throw
Error
(
"
This
unit
of
work
tag
should
not
have
side
-
effects
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
}
}
function
commitSuspenseComponent
(
finishedWork
)
{
var
newState
=
finishedWork
.
memoizedState
;
var
newDidTimeout
;
var
primaryChildParent
=
finishedWork
;
if
(
newState
=
=
=
null
)
{
newDidTimeout
=
false
;
}
else
{
newDidTimeout
=
true
;
primaryChildParent
=
finishedWork
.
child
;
markCommitTimeOfFallback
(
)
;
}
if
(
supportsMutation
&
&
primaryChildParent
!
=
=
null
)
{
hideOrUnhideAllChildren
(
primaryChildParent
newDidTimeout
)
;
}
if
(
enableSuspenseCallback
&
&
newState
!
=
=
null
)
{
var
suspenseCallback
=
finishedWork
.
memoizedProps
.
suspenseCallback
;
if
(
typeof
suspenseCallback
=
=
=
'
function
'
)
{
var
thenables
=
finishedWork
.
updateQueue
;
if
(
thenables
!
=
=
null
)
{
suspenseCallback
(
new
Set
(
thenables
)
)
;
}
}
else
{
if
(
suspenseCallback
!
=
=
undefined
)
{
warning
1
(
false
'
Unexpected
type
for
suspenseCallback
.
'
)
;
}
}
}
}
function
commitSuspenseHydrationCallbacks
(
finishedRoot
finishedWork
)
{
if
(
!
supportsHydration
)
{
return
;
}
var
newState
=
finishedWork
.
memoizedState
;
if
(
newState
=
=
=
null
)
{
var
current
1
=
finishedWork
.
alternate
;
if
(
current
1
!
=
=
null
)
{
var
prevState
=
current
1
.
memoizedState
;
if
(
prevState
!
=
=
null
)
{
var
suspenseInstance
=
prevState
.
dehydrated
;
if
(
suspenseInstance
!
=
=
null
)
{
commitHydratedSuspenseInstance
(
suspenseInstance
)
;
if
(
enableSuspenseCallback
)
{
var
hydrationCallbacks
=
finishedRoot
.
hydrationCallbacks
;
if
(
hydrationCallbacks
!
=
=
null
)
{
var
onHydrated
=
hydrationCallbacks
.
onHydrated
;
if
(
onHydrated
)
{
onHydrated
(
suspenseInstance
)
;
}
}
}
}
}
}
}
}
function
attachSuspenseRetryListeners
(
finishedWork
)
{
var
thenables
=
finishedWork
.
updateQueue
;
if
(
thenables
!
=
=
null
)
{
finishedWork
.
updateQueue
=
null
;
var
retryCache
=
finishedWork
.
stateNode
;
if
(
retryCache
=
=
=
null
)
{
retryCache
=
finishedWork
.
stateNode
=
new
PossiblyWeakSet
(
)
;
}
thenables
.
forEach
(
function
(
thenable
)
{
var
retry
=
resolveRetryThenable
.
bind
(
null
finishedWork
thenable
)
;
if
(
!
retryCache
.
has
(
thenable
)
)
{
if
(
enableSchedulerTracing
)
{
if
(
thenable
.
__reactDoNotTraceInteractions
!
=
=
true
)
{
retry
=
unstable_wrap
(
retry
)
;
}
}
retryCache
.
add
(
thenable
)
;
thenable
.
then
(
retry
retry
)
;
}
}
)
;
}
}
function
commitResetTextContent
(
current
1
)
{
if
(
!
supportsMutation
)
{
return
;
}
resetTextContent
(
current
1
.
stateNode
)
;
}
var
PossiblyWeakMap
1
=
typeof
WeakMap
=
=
=
'
function
'
?
WeakMap
:
Map
;
function
createRootErrorUpdate
(
fiber
errorInfo
expirationTime
)
{
var
update
=
createUpdate
(
expirationTime
null
)
;
update
.
tag
=
CaptureUpdate
;
update
.
payload
=
{
element
:
null
}
;
var
error
=
errorInfo
.
value
;
update
.
callback
=
function
(
)
{
onUncaughtError
(
error
)
;
logError
(
fiber
errorInfo
)
;
}
;
return
update
;
}
function
createClassErrorUpdate
(
fiber
errorInfo
expirationTime
)
{
var
update
=
createUpdate
(
expirationTime
null
)
;
update
.
tag
=
CaptureUpdate
;
var
getDerivedStateFromError
=
fiber
.
type
.
getDerivedStateFromError
;
if
(
typeof
getDerivedStateFromError
=
=
=
'
function
'
)
{
var
error
=
errorInfo
.
value
;
update
.
payload
=
function
(
)
{
logError
(
fiber
errorInfo
)
;
return
getDerivedStateFromError
(
error
)
;
}
;
}
var
inst
=
fiber
.
stateNode
;
if
(
inst
!
=
=
null
&
&
typeof
inst
.
componentDidCatch
=
=
=
'
function
'
)
{
update
.
callback
=
function
callback
(
)
{
{
markFailedErrorBoundaryForHotReloading
(
fiber
)
;
}
if
(
typeof
getDerivedStateFromError
!
=
=
'
function
'
)
{
markLegacyErrorBoundaryAsFailed
(
this
)
;
logError
(
fiber
errorInfo
)
;
}
var
error
=
errorInfo
.
value
;
var
stack
=
errorInfo
.
stack
;
this
.
componentDidCatch
(
error
{
componentStack
:
stack
!
=
=
null
?
stack
:
'
'
}
)
;
{
if
(
typeof
getDerivedStateFromError
!
=
=
'
function
'
)
{
!
(
fiber
.
expirationTime
=
=
=
Sync
)
?
warningWithoutStack
1
(
false
'
%
s
:
Error
boundaries
should
implement
getDerivedStateFromError
(
)
.
'
+
'
In
that
method
return
a
state
update
to
display
an
error
message
or
fallback
UI
.
'
getComponentName
(
fiber
.
type
)
|
|
'
Unknown
'
)
:
void
0
;
}
}
}
;
}
else
{
update
.
callback
=
function
(
)
{
markFailedErrorBoundaryForHotReloading
(
fiber
)
;
}
;
}
return
update
;
}
function
attachPingListener
(
root
renderExpirationTime
thenable
)
{
var
pingCache
=
root
.
pingCache
;
var
threadIDs
;
if
(
pingCache
=
=
=
null
)
{
pingCache
=
root
.
pingCache
=
new
PossiblyWeakMap
1
(
)
;
threadIDs
=
new
Set
(
)
;
pingCache
.
set
(
thenable
threadIDs
)
;
}
else
{
threadIDs
=
pingCache
.
get
(
thenable
)
;
if
(
threadIDs
=
=
=
undefined
)
{
threadIDs
=
new
Set
(
)
;
pingCache
.
set
(
thenable
threadIDs
)
;
}
}
if
(
!
threadIDs
.
has
(
renderExpirationTime
)
)
{
threadIDs
.
add
(
renderExpirationTime
)
;
var
ping
=
pingSuspendedRoot
.
bind
(
null
root
thenable
renderExpirationTime
)
;
thenable
.
then
(
ping
ping
)
;
}
}
function
throwException
(
root
returnFiber
sourceFiber
value
renderExpirationTime
)
{
sourceFiber
.
effectTag
|
=
Incomplete
;
sourceFiber
.
firstEffect
=
sourceFiber
.
lastEffect
=
null
;
if
(
value
!
=
=
null
&
&
typeof
value
=
=
=
'
object
'
&
&
typeof
value
.
then
=
=
=
'
function
'
)
{
var
thenable
=
value
;
checkForWrongSuspensePriorityInDEV
(
sourceFiber
)
;
var
hasInvisibleParentBoundary
=
hasSuspenseContext
(
suspenseStackCursor
.
current
InvisibleParentSuspenseContext
)
;
var
_workInProgress
=
returnFiber
;
do
{
if
(
_workInProgress
.
tag
=
=
=
SuspenseComponent
&
&
shouldCaptureSuspense
(
_workInProgress
hasInvisibleParentBoundary
)
)
{
var
thenables
=
_workInProgress
.
updateQueue
;
if
(
thenables
=
=
=
null
)
{
var
updateQueue
=
new
Set
(
)
;
updateQueue
.
add
(
thenable
)
;
_workInProgress
.
updateQueue
=
updateQueue
;
}
else
{
thenables
.
add
(
thenable
)
;
}
if
(
(
_workInProgress
.
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
_workInProgress
.
effectTag
|
=
DidCapture
;
sourceFiber
.
effectTag
&
=
~
(
LifecycleEffectMask
|
Incomplete
)
;
if
(
sourceFiber
.
tag
=
=
=
ClassComponent
)
{
var
currentSourceFiber
=
sourceFiber
.
alternate
;
if
(
currentSourceFiber
=
=
=
null
)
{
sourceFiber
.
tag
=
IncompleteClassComponent
;
}
else
{
var
update
=
createUpdate
(
Sync
null
)
;
update
.
tag
=
ForceUpdate
;
enqueueUpdate
(
sourceFiber
update
)
;
}
}
sourceFiber
.
expirationTime
=
Sync
;
return
;
}
attachPingListener
(
root
renderExpirationTime
thenable
)
;
_workInProgress
.
effectTag
|
=
ShouldCapture
;
_workInProgress
.
expirationTime
=
renderExpirationTime
;
return
;
}
_workInProgress
=
_workInProgress
.
return
;
}
while
(
_workInProgress
!
=
=
null
)
;
value
=
new
Error
(
(
getComponentName
(
sourceFiber
.
type
)
|
|
'
A
React
component
'
)
+
'
suspended
while
rendering
but
no
fallback
UI
was
specified
.
\
n
'
+
'
\
n
'
+
'
Add
a
<
Suspense
fallback
=
.
.
.
>
component
higher
in
the
tree
to
'
+
'
provide
a
loading
indicator
or
placeholder
to
display
.
'
+
getStackByFiberInDevAndProd
(
sourceFiber
)
)
;
}
renderDidError
(
)
;
value
=
createCapturedValue
(
value
sourceFiber
)
;
var
workInProgress
=
returnFiber
;
do
{
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
{
var
_errorInfo
=
value
;
workInProgress
.
effectTag
|
=
ShouldCapture
;
workInProgress
.
expirationTime
=
renderExpirationTime
;
var
_update
=
createRootErrorUpdate
(
workInProgress
_errorInfo
renderExpirationTime
)
;
enqueueCapturedUpdate
(
workInProgress
_update
)
;
return
;
}
case
ClassComponent
:
var
errorInfo
=
value
;
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
&
&
(
typeof
ctor
.
getDerivedStateFromError
=
=
=
'
function
'
|
|
instance
!
=
=
null
&
&
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
&
&
!
isAlreadyFailedLegacyErrorBoundary
(
instance
)
)
)
{
workInProgress
.
effectTag
|
=
ShouldCapture
;
workInProgress
.
expirationTime
=
renderExpirationTime
;
var
_update2
=
createClassErrorUpdate
(
workInProgress
errorInfo
renderExpirationTime
)
;
enqueueCapturedUpdate
(
workInProgress
_update2
)
;
return
;
}
break
;
default
:
break
;
}
workInProgress
=
workInProgress
.
return
;
}
while
(
workInProgress
!
=
=
null
)
;
}
var
ceil
=
Math
.
ceil
;
var
ReactCurrentDispatcher
=
ReactSharedInternals
.
ReactCurrentDispatcher
;
var
ReactCurrentOwner
2
=
ReactSharedInternals
.
ReactCurrentOwner
;
var
IsSomeRendererActing
=
ReactSharedInternals
.
IsSomeRendererActing
;
var
NoContext
=
0
;
var
BatchedContext
=
1
;
var
EventContext
=
2
;
var
DiscreteEventContext
=
4
;
var
LegacyUnbatchedContext
=
8
;
var
RenderContext
=
16
;
var
CommitContext
=
32
;
var
RootIncomplete
=
0
;
var
RootFatalErrored
=
1
;
var
RootErrored
=
2
;
var
RootSuspended
=
3
;
var
RootSuspendedWithDelay
=
4
;
var
RootCompleted
=
5
;
var
executionContext
=
NoContext
;
var
workInProgressRoot
=
null
;
var
workInProgress
=
null
;
var
renderExpirationTime
=
NoWork
;
var
workInProgressRootExitStatus
=
RootIncomplete
;
var
workInProgressRootFatalError
=
null
;
var
workInProgressRootLatestProcessedExpirationTime
=
Sync
;
var
workInProgressRootLatestSuspenseTimeout
=
Sync
;
var
workInProgressRootCanSuspendUsingConfig
=
null
;
var
workInProgressRootNextUnprocessedUpdateTime
=
NoWork
;
var
workInProgressRootHasPendingPing
=
false
;
var
globalMostRecentFallbackTime
=
0
;
var
FALLBACK_THROTTLE_MS
=
500
;
var
nextEffect
=
null
;
var
hasUncaughtError
=
false
;
var
firstUncaughtError
=
null
;
var
legacyErrorBoundariesThatAlreadyFailed
=
null
;
var
rootDoesHavePassiveEffects
=
false
;
var
rootWithPendingPassiveEffects
=
null
;
var
pendingPassiveEffectsRenderPriority
=
NoPriority
;
var
pendingPassiveEffectsExpirationTime
=
NoWork
;
var
rootsWithPendingDiscreteUpdates
=
null
;
var
NESTED_UPDATE_LIMIT
=
50
;
var
nestedUpdateCount
=
0
;
var
rootWithNestedUpdates
=
null
;
var
NESTED_PASSIVE_UPDATE_LIMIT
=
50
;
var
nestedPassiveUpdateCount
=
0
;
var
interruptedBy
=
null
;
var
spawnedWorkDuringRender
=
null
;
var
currentEventTime
=
NoWork
;
function
requestCurrentTimeForUpdate
(
)
{
if
(
(
executionContext
&
(
RenderContext
|
CommitContext
)
)
!
=
=
NoContext
)
{
return
msToExpirationTime
(
now
(
)
)
;
}
if
(
currentEventTime
!
=
=
NoWork
)
{
return
currentEventTime
;
}
currentEventTime
=
msToExpirationTime
(
now
(
)
)
;
return
currentEventTime
;
}
function
getCurrentTime
(
)
{
return
msToExpirationTime
(
now
(
)
)
;
}
function
computeExpirationForFiber
(
currentTime
fiber
suspenseConfig
)
{
var
mode
=
fiber
.
mode
;
if
(
(
mode
&
BlockingMode
)
=
=
=
NoMode
)
{
return
Sync
;
}
var
priorityLevel
=
getCurrentPriorityLevel
(
)
;
if
(
(
mode
&
ConcurrentMode
)
=
=
=
NoMode
)
{
return
priorityLevel
=
=
=
ImmediatePriority
?
Sync
:
Batched
;
}
if
(
(
executionContext
&
RenderContext
)
!
=
=
NoContext
)
{
return
renderExpirationTime
;
}
var
expirationTime
;
if
(
suspenseConfig
!
=
=
null
)
{
expirationTime
=
computeSuspenseExpiration
(
currentTime
suspenseConfig
.
timeoutMs
|
0
|
|
LOW_PRIORITY_EXPIRATION
)
;
}
else
{
switch
(
priorityLevel
)
{
case
ImmediatePriority
:
expirationTime
=
Sync
;
break
;
case
UserBlockingPriority
2
:
expirationTime
=
computeInteractiveExpiration
(
currentTime
)
;
break
;
case
NormalPriority
:
case
LowPriority
:
expirationTime
=
computeAsyncExpiration
(
currentTime
)
;
break
;
case
IdlePriority
:
expirationTime
=
Idle
;
break
;
default
:
{
{
throw
Error
(
"
Expected
a
valid
priority
level
"
)
;
}
}
}
}
if
(
workInProgressRoot
!
=
=
null
&
&
expirationTime
=
=
=
renderExpirationTime
)
{
expirationTime
-
=
1
;
}
return
expirationTime
;
}
function
scheduleUpdateOnFiber
(
fiber
expirationTime
)
{
checkForNestedUpdates
(
)
;
warnAboutInvalidUpdatesOnClassComponentsInDEV
(
fiber
)
;
var
root
=
markUpdateTimeFromFiberToRoot
(
fiber
expirationTime
)
;
if
(
root
=
=
=
null
)
{
warnAboutUpdateOnUnmountedFiberInDEV
(
fiber
)
;
return
;
}
checkForInterruption
(
fiber
expirationTime
)
;
recordScheduleUpdate
(
)
;
var
priorityLevel
=
getCurrentPriorityLevel
(
)
;
if
(
expirationTime
=
=
=
Sync
)
{
if
(
(
executionContext
&
LegacyUnbatchedContext
)
!
=
=
NoContext
&
&
(
executionContext
&
(
RenderContext
|
CommitContext
)
)
=
=
=
NoContext
)
{
schedulePendingInteractions
(
root
expirationTime
)
;
performSyncWorkOnRoot
(
root
)
;
}
else
{
ensureRootIsScheduled
(
root
)
;
schedulePendingInteractions
(
root
expirationTime
)
;
if
(
executionContext
=
=
=
NoContext
)
{
flushSyncCallbackQueue
(
)
;
}
}
}
else
{
ensureRootIsScheduled
(
root
)
;
schedulePendingInteractions
(
root
expirationTime
)
;
}
if
(
(
executionContext
&
DiscreteEventContext
)
!
=
=
NoContext
&
&
(
priorityLevel
=
=
=
UserBlockingPriority
2
|
|
priorityLevel
=
=
=
ImmediatePriority
)
)
{
if
(
rootsWithPendingDiscreteUpdates
=
=
=
null
)
{
rootsWithPendingDiscreteUpdates
=
new
Map
(
[
[
root
expirationTime
]
]
)
;
}
else
{
var
lastDiscreteTime
=
rootsWithPendingDiscreteUpdates
.
get
(
root
)
;
if
(
lastDiscreteTime
=
=
=
undefined
|
|
lastDiscreteTime
>
expirationTime
)
{
rootsWithPendingDiscreteUpdates
.
set
(
root
expirationTime
)
;
}
}
}
}
var
scheduleWork
=
scheduleUpdateOnFiber
;
function
markUpdateTimeFromFiberToRoot
(
fiber
expirationTime
)
{
if
(
fiber
.
expirationTime
<
expirationTime
)
{
fiber
.
expirationTime
=
expirationTime
;
}
var
alternate
=
fiber
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
.
expirationTime
<
expirationTime
)
{
alternate
.
expirationTime
=
expirationTime
;
}
var
node
=
fiber
.
return
;
var
root
=
null
;
if
(
node
=
=
=
null
&
&
fiber
.
tag
=
=
=
HostRoot
)
{
root
=
fiber
.
stateNode
;
}
else
{
while
(
node
!
=
=
null
)
{
alternate
=
node
.
alternate
;
if
(
node
.
childExpirationTime
<
expirationTime
)
{
node
.
childExpirationTime
=
expirationTime
;
if
(
alternate
!
=
=
null
&
&
alternate
.
childExpirationTime
<
expirationTime
)
{
alternate
.
childExpirationTime
=
expirationTime
;
}
}
else
if
(
alternate
!
=
=
null
&
&
alternate
.
childExpirationTime
<
expirationTime
)
{
alternate
.
childExpirationTime
=
expirationTime
;
}
if
(
node
.
return
=
=
=
null
&
&
node
.
tag
=
=
=
HostRoot
)
{
root
=
node
.
stateNode
;
break
;
}
node
=
node
.
return
;
}
}
if
(
root
!
=
=
null
)
{
if
(
workInProgressRoot
=
=
=
root
)
{
markUnprocessedUpdateTime
(
expirationTime
)
;
if
(
workInProgressRootExitStatus
=
=
=
RootSuspendedWithDelay
)
{
markRootSuspendedAtTime
(
root
renderExpirationTime
)
;
}
}
markRootUpdatedAtTime
(
root
expirationTime
)
;
}
return
root
;
}
function
getNextRootExpirationTimeToWorkOn
(
root
)
{
var
lastExpiredTime
=
root
.
lastExpiredTime
;
if
(
lastExpiredTime
!
=
=
NoWork
)
{
return
lastExpiredTime
;
}
var
firstPendingTime
=
root
.
firstPendingTime
;
if
(
!
isRootSuspendedAtTime
(
root
firstPendingTime
)
)
{
return
firstPendingTime
;
}
var
lastPingedTime
=
root
.
lastPingedTime
;
var
nextKnownPendingLevel
=
root
.
nextKnownPendingLevel
;
return
lastPingedTime
>
nextKnownPendingLevel
?
lastPingedTime
:
nextKnownPendingLevel
;
}
function
ensureRootIsScheduled
(
root
)
{
var
lastExpiredTime
=
root
.
lastExpiredTime
;
if
(
lastExpiredTime
!
=
=
NoWork
)
{
root
.
callbackExpirationTime
=
Sync
;
root
.
callbackPriority
=
ImmediatePriority
;
root
.
callbackNode
=
scheduleSyncCallback
(
performSyncWorkOnRoot
.
bind
(
null
root
)
)
;
return
;
}
var
expirationTime
=
getNextRootExpirationTimeToWorkOn
(
root
)
;
var
existingCallbackNode
=
root
.
callbackNode
;
if
(
expirationTime
=
=
=
NoWork
)
{
if
(
existingCallbackNode
!
=
=
null
)
{
root
.
callbackNode
=
null
;
root
.
callbackExpirationTime
=
NoWork
;
root
.
callbackPriority
=
NoPriority
;
}
return
;
}
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
var
priorityLevel
=
inferPriorityFromExpirationTime
(
currentTime
expirationTime
)
;
if
(
existingCallbackNode
!
=
=
null
)
{
var
existingCallbackPriority
=
root
.
callbackPriority
;
var
existingCallbackExpirationTime
=
root
.
callbackExpirationTime
;
if
(
existingCallbackExpirationTime
=
=
=
expirationTime
&
&
existingCallbackPriority
>
=
priorityLevel
)
{
return
;
}
cancelCallback
(
existingCallbackNode
)
;
}
root
.
callbackExpirationTime
=
expirationTime
;
root
.
callbackPriority
=
priorityLevel
;
var
callbackNode
;
if
(
expirationTime
=
=
=
Sync
)
{
callbackNode
=
scheduleSyncCallback
(
performSyncWorkOnRoot
.
bind
(
null
root
)
)
;
}
else
if
(
disableSchedulerTimeoutBasedOnReactExpirationTime
)
{
callbackNode
=
scheduleCallback
(
priorityLevel
performConcurrentWorkOnRoot
.
bind
(
null
root
)
)
;
}
else
{
callbackNode
=
scheduleCallback
(
priorityLevel
performConcurrentWorkOnRoot
.
bind
(
null
root
)
{
timeout
:
expirationTimeToMs
(
expirationTime
)
-
now
(
)
}
)
;
}
root
.
callbackNode
=
callbackNode
;
}
function
performConcurrentWorkOnRoot
(
root
didTimeout
)
{
currentEventTime
=
NoWork
;
if
(
didTimeout
)
{
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
markRootExpiredAtTime
(
root
currentTime
)
;
ensureRootIsScheduled
(
root
)
;
return
null
;
}
var
expirationTime
=
getNextRootExpirationTimeToWorkOn
(
root
)
;
if
(
expirationTime
!
=
=
NoWork
)
{
var
originalCallbackNode
=
root
.
callbackNode
;
if
(
!
(
(
executionContext
&
(
RenderContext
|
CommitContext
)
)
=
=
=
NoContext
)
)
{
{
throw
Error
(
"
Should
not
already
be
working
.
"
)
;
}
}
flushPassiveEffects
(
)
;
if
(
root
!
=
=
workInProgressRoot
|
|
expirationTime
!
=
=
renderExpirationTime
)
{
prepareFreshStack
(
root
expirationTime
)
;
startWorkOnPendingInteractions
(
root
expirationTime
)
;
}
if
(
workInProgress
!
=
=
null
)
{
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
RenderContext
;
var
prevDispatcher
=
pushDispatcher
(
root
)
;
var
prevInteractions
=
pushInteractions
(
root
)
;
startWorkLoopTimer
(
workInProgress
)
;
do
{
try
{
workLoopConcurrent
(
)
;
break
;
}
catch
(
thrownValue
)
{
handleError
(
root
thrownValue
)
;
}
}
while
(
true
)
;
resetContextDependencies
(
)
;
executionContext
=
prevExecutionContext
;
popDispatcher
(
prevDispatcher
)
;
if
(
enableSchedulerTracing
)
{
popInteractions
(
prevInteractions
)
;
}
if
(
workInProgressRootExitStatus
=
=
=
RootFatalErrored
)
{
var
fatalError
=
workInProgressRootFatalError
;
stopInterruptedWorkLoopTimer
(
)
;
prepareFreshStack
(
root
expirationTime
)
;
markRootSuspendedAtTime
(
root
expirationTime
)
;
ensureRootIsScheduled
(
root
)
;
throw
fatalError
;
}
if
(
workInProgress
!
=
=
null
)
{
stopInterruptedWorkLoopTimer
(
)
;
}
else
{
stopFinishedWorkLoopTimer
(
)
;
var
finishedWork
=
root
.
finishedWork
=
root
.
current
.
alternate
;
root
.
finishedExpirationTime
=
expirationTime
;
finishConcurrentRender
(
root
finishedWork
workInProgressRootExitStatus
expirationTime
)
;
}
ensureRootIsScheduled
(
root
)
;
if
(
root
.
callbackNode
=
=
=
originalCallbackNode
)
{
return
performConcurrentWorkOnRoot
.
bind
(
null
root
)
;
}
}
}
return
null
;
}
function
finishConcurrentRender
(
root
finishedWork
exitStatus
expirationTime
)
{
workInProgressRoot
=
null
;
switch
(
exitStatus
)
{
case
RootIncomplete
:
case
RootFatalErrored
:
{
{
{
throw
Error
(
"
Root
did
not
complete
.
This
is
a
bug
in
React
.
"
)
;
}
}
}
case
RootErrored
:
{
markRootExpiredAtTime
(
root
expirationTime
>
Idle
?
Idle
:
expirationTime
)
;
break
;
}
case
RootSuspended
:
{
markRootSuspendedAtTime
(
root
expirationTime
)
;
var
lastSuspendedTime
=
root
.
lastSuspendedTime
;
if
(
expirationTime
=
=
=
lastSuspendedTime
)
{
root
.
nextKnownPendingLevel
=
getRemainingExpirationTime
(
finishedWork
)
;
}
flushSuspensePriorityWarningInDEV
(
)
;
var
hasNotProcessedNewUpdates
=
workInProgressRootLatestProcessedExpirationTime
=
=
=
Sync
;
if
(
hasNotProcessedNewUpdates
&
&
!
(
true
&
&
flushSuspenseFallbacksInTests
&
&
IsThisRendererActing
.
current
)
)
{
var
msUntilTimeout
=
globalMostRecentFallbackTime
+
FALLBACK_THROTTLE_MS
-
now
(
)
;
if
(
msUntilTimeout
>
10
)
{
if
(
workInProgressRootHasPendingPing
)
{
var
lastPingedTime
=
root
.
lastPingedTime
;
if
(
lastPingedTime
=
=
=
NoWork
|
|
lastPingedTime
>
=
expirationTime
)
{
root
.
lastPingedTime
=
expirationTime
;
prepareFreshStack
(
root
expirationTime
)
;
break
;
}
}
var
nextTime
=
getNextRootExpirationTimeToWorkOn
(
root
)
;
if
(
nextTime
!
=
=
NoWork
&
&
nextTime
!
=
=
expirationTime
)
{
break
;
}
if
(
lastSuspendedTime
!
=
=
NoWork
&
&
lastSuspendedTime
!
=
=
expirationTime
)
{
root
.
lastPingedTime
=
lastSuspendedTime
;
break
;
}
root
.
timeoutHandle
=
scheduleTimeout
(
commitRoot
.
bind
(
null
root
)
msUntilTimeout
)
;
break
;
}
}
commitRoot
(
root
)
;
break
;
}
case
RootSuspendedWithDelay
:
{
markRootSuspendedAtTime
(
root
expirationTime
)
;
var
_lastSuspendedTime
=
root
.
lastSuspendedTime
;
if
(
expirationTime
=
=
=
_lastSuspendedTime
)
{
root
.
nextKnownPendingLevel
=
getRemainingExpirationTime
(
finishedWork
)
;
}
flushSuspensePriorityWarningInDEV
(
)
;
if
(
!
(
true
&
&
flushSuspenseFallbacksInTests
&
&
IsThisRendererActing
.
current
)
)
{
if
(
workInProgressRootHasPendingPing
)
{
var
_lastPingedTime
=
root
.
lastPingedTime
;
if
(
_lastPingedTime
=
=
=
NoWork
|
|
_lastPingedTime
>
=
expirationTime
)
{
root
.
lastPingedTime
=
expirationTime
;
prepareFreshStack
(
root
expirationTime
)
;
break
;
}
}
var
_nextTime
=
getNextRootExpirationTimeToWorkOn
(
root
)
;
if
(
_nextTime
!
=
=
NoWork
&
&
_nextTime
!
=
=
expirationTime
)
{
break
;
}
if
(
_lastSuspendedTime
!
=
=
NoWork
&
&
_lastSuspendedTime
!
=
=
expirationTime
)
{
root
.
lastPingedTime
=
_lastSuspendedTime
;
break
;
}
var
_msUntilTimeout
;
if
(
workInProgressRootLatestSuspenseTimeout
!
=
=
Sync
)
{
_msUntilTimeout
=
expirationTimeToMs
(
workInProgressRootLatestSuspenseTimeout
)
-
now
(
)
;
}
else
if
(
workInProgressRootLatestProcessedExpirationTime
=
=
=
Sync
)
{
_msUntilTimeout
=
0
;
}
else
{
var
eventTimeMs
=
inferTimeFromExpirationTime
(
workInProgressRootLatestProcessedExpirationTime
)
;
var
currentTimeMs
=
now
(
)
;
var
timeUntilExpirationMs
=
expirationTimeToMs
(
expirationTime
)
-
currentTimeMs
;
var
timeElapsed
=
currentTimeMs
-
eventTimeMs
;
if
(
timeElapsed
<
0
)
{
timeElapsed
=
0
;
}
_msUntilTimeout
=
jnd
(
timeElapsed
)
-
timeElapsed
;
if
(
timeUntilExpirationMs
<
_msUntilTimeout
)
{
_msUntilTimeout
=
timeUntilExpirationMs
;
}
}
if
(
_msUntilTimeout
>
10
)
{
root
.
timeoutHandle
=
scheduleTimeout
(
commitRoot
.
bind
(
null
root
)
_msUntilTimeout
)
;
break
;
}
}
commitRoot
(
root
)
;
break
;
}
case
RootCompleted
:
{
if
(
!
(
true
&
&
flushSuspenseFallbacksInTests
&
&
IsThisRendererActing
.
current
)
&
&
workInProgressRootLatestProcessedExpirationTime
!
=
=
Sync
&
&
workInProgressRootCanSuspendUsingConfig
!
=
=
null
)
{
var
_msUntilTimeout2
=
computeMsUntilSuspenseLoadingDelay
(
workInProgressRootLatestProcessedExpirationTime
expirationTime
workInProgressRootCanSuspendUsingConfig
)
;
if
(
_msUntilTimeout2
>
10
)
{
markRootSuspendedAtTime
(
root
expirationTime
)
;
root
.
timeoutHandle
=
scheduleTimeout
(
commitRoot
.
bind
(
null
root
)
_msUntilTimeout2
)
;
break
;
}
}
commitRoot
(
root
)
;
break
;
}
default
:
{
{
{
throw
Error
(
"
Unknown
root
exit
status
.
"
)
;
}
}
}
}
}
function
performSyncWorkOnRoot
(
root
)
{
var
lastExpiredTime
=
root
.
lastExpiredTime
;
var
expirationTime
=
lastExpiredTime
!
=
=
NoWork
?
lastExpiredTime
:
Sync
;
if
(
root
.
finishedExpirationTime
=
=
=
expirationTime
)
{
commitRoot
(
root
)
;
}
else
{
if
(
!
(
(
executionContext
&
(
RenderContext
|
CommitContext
)
)
=
=
=
NoContext
)
)
{
{
throw
Error
(
"
Should
not
already
be
working
.
"
)
;
}
}
flushPassiveEffects
(
)
;
if
(
root
!
=
=
workInProgressRoot
|
|
expirationTime
!
=
=
renderExpirationTime
)
{
prepareFreshStack
(
root
expirationTime
)
;
startWorkOnPendingInteractions
(
root
expirationTime
)
;
}
if
(
workInProgress
!
=
=
null
)
{
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
RenderContext
;
var
prevDispatcher
=
pushDispatcher
(
root
)
;
var
prevInteractions
=
pushInteractions
(
root
)
;
startWorkLoopTimer
(
workInProgress
)
;
do
{
try
{
workLoopSync
(
)
;
break
;
}
catch
(
thrownValue
)
{
handleError
(
root
thrownValue
)
;
}
}
while
(
true
)
;
resetContextDependencies
(
)
;
executionContext
=
prevExecutionContext
;
popDispatcher
(
prevDispatcher
)
;
if
(
enableSchedulerTracing
)
{
popInteractions
(
prevInteractions
)
;
}
if
(
workInProgressRootExitStatus
=
=
=
RootFatalErrored
)
{
var
fatalError
=
workInProgressRootFatalError
;
stopInterruptedWorkLoopTimer
(
)
;
prepareFreshStack
(
root
expirationTime
)
;
markRootSuspendedAtTime
(
root
expirationTime
)
;
ensureRootIsScheduled
(
root
)
;
throw
fatalError
;
}
if
(
workInProgress
!
=
=
null
)
{
{
{
throw
Error
(
"
Cannot
commit
an
incomplete
root
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
}
else
{
stopFinishedWorkLoopTimer
(
)
;
root
.
finishedWork
=
root
.
current
.
alternate
;
root
.
finishedExpirationTime
=
expirationTime
;
finishSyncRender
(
root
workInProgressRootExitStatus
expirationTime
)
;
}
ensureRootIsScheduled
(
root
)
;
}
}
return
null
;
}
function
finishSyncRender
(
root
exitStatus
expirationTime
)
{
workInProgressRoot
=
null
;
{
if
(
exitStatus
=
=
=
RootSuspended
|
|
exitStatus
=
=
=
RootSuspendedWithDelay
)
{
flushSuspensePriorityWarningInDEV
(
)
;
}
}
commitRoot
(
root
)
;
}
function
flushRoot
(
root
expirationTime
)
{
markRootExpiredAtTime
(
root
expirationTime
)
;
ensureRootIsScheduled
(
root
)
;
if
(
(
executionContext
&
(
RenderContext
|
CommitContext
)
)
=
=
=
NoContext
)
{
flushSyncCallbackQueue
(
)
;
}
}
function
flushDiscreteUpdates
(
)
{
if
(
(
executionContext
&
(
BatchedContext
|
RenderContext
|
CommitContext
)
)
!
=
=
NoContext
)
{
if
(
true
&
&
(
executionContext
&
RenderContext
)
!
=
=
NoContext
)
{
warning
1
(
false
'
unstable_flushDiscreteUpdates
:
Cannot
flush
updates
when
React
is
'
+
'
already
rendering
.
'
)
;
}
return
;
}
flushPendingDiscreteUpdates
(
)
;
flushPassiveEffects
(
)
;
}
function
syncUpdates
(
fn
a
b
c
)
{
return
runWithPriority
2
(
ImmediatePriority
fn
.
bind
(
null
a
b
c
)
)
;
}
function
flushPendingDiscreteUpdates
(
)
{
if
(
rootsWithPendingDiscreteUpdates
!
=
=
null
)
{
var
roots
=
rootsWithPendingDiscreteUpdates
;
rootsWithPendingDiscreteUpdates
=
null
;
roots
.
forEach
(
function
(
expirationTime
root
)
{
markRootExpiredAtTime
(
root
expirationTime
)
;
ensureRootIsScheduled
(
root
)
;
}
)
;
flushSyncCallbackQueue
(
)
;
}
}
function
batchedUpdates
1
(
fn
a
)
{
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
BatchedContext
;
try
{
return
fn
(
a
)
;
}
finally
{
executionContext
=
prevExecutionContext
;
if
(
executionContext
=
=
=
NoContext
)
{
flushSyncCallbackQueue
(
)
;
}
}
}
function
batchedEventUpdates
1
(
fn
a
)
{
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
EventContext
;
try
{
return
fn
(
a
)
;
}
finally
{
executionContext
=
prevExecutionContext
;
if
(
executionContext
=
=
=
NoContext
)
{
flushSyncCallbackQueue
(
)
;
}
}
}
function
discreteUpdates
1
(
fn
a
b
c
)
{
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
DiscreteEventContext
;
try
{
return
runWithPriority
2
(
UserBlockingPriority
2
fn
.
bind
(
null
a
b
c
)
)
;
}
finally
{
executionContext
=
prevExecutionContext
;
if
(
executionContext
=
=
=
NoContext
)
{
flushSyncCallbackQueue
(
)
;
}
}
}
function
unbatchedUpdates
(
fn
a
)
{
var
prevExecutionContext
=
executionContext
;
executionContext
&
=
~
BatchedContext
;
executionContext
|
=
LegacyUnbatchedContext
;
try
{
return
fn
(
a
)
;
}
finally
{
executionContext
=
prevExecutionContext
;
if
(
executionContext
=
=
=
NoContext
)
{
flushSyncCallbackQueue
(
)
;
}
}
}
function
flushSync
(
fn
a
)
{
if
(
(
executionContext
&
(
RenderContext
|
CommitContext
)
)
!
=
=
NoContext
)
{
{
{
throw
Error
(
"
flushSync
was
called
from
inside
a
lifecycle
method
.
It
cannot
be
called
when
React
is
already
rendering
.
"
)
;
}
}
}
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
BatchedContext
;
try
{
return
runWithPriority
2
(
ImmediatePriority
fn
.
bind
(
null
a
)
)
;
}
finally
{
executionContext
=
prevExecutionContext
;
flushSyncCallbackQueue
(
)
;
}
}
function
flushControlled
(
fn
)
{
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
BatchedContext
;
try
{
runWithPriority
2
(
ImmediatePriority
fn
)
;
}
finally
{
executionContext
=
prevExecutionContext
;
if
(
executionContext
=
=
=
NoContext
)
{
flushSyncCallbackQueue
(
)
;
}
}
}
function
prepareFreshStack
(
root
expirationTime
)
{
root
.
finishedWork
=
null
;
root
.
finishedExpirationTime
=
NoWork
;
var
timeoutHandle
=
root
.
timeoutHandle
;
if
(
timeoutHandle
!
=
=
noTimeout
)
{
root
.
timeoutHandle
=
noTimeout
;
cancelTimeout
(
timeoutHandle
)
;
}
if
(
workInProgress
!
=
=
null
)
{
var
interruptedWork
=
workInProgress
.
return
;
while
(
interruptedWork
!
=
=
null
)
{
unwindInterruptedWork
(
interruptedWork
)
;
interruptedWork
=
interruptedWork
.
return
;
}
}
workInProgressRoot
=
root
;
workInProgress
=
createWorkInProgress
(
root
.
current
null
expirationTime
)
;
renderExpirationTime
=
expirationTime
;
workInProgressRootExitStatus
=
RootIncomplete
;
workInProgressRootFatalError
=
null
;
workInProgressRootLatestProcessedExpirationTime
=
Sync
;
workInProgressRootLatestSuspenseTimeout
=
Sync
;
workInProgressRootCanSuspendUsingConfig
=
null
;
workInProgressRootNextUnprocessedUpdateTime
=
NoWork
;
workInProgressRootHasPendingPing
=
false
;
if
(
enableSchedulerTracing
)
{
spawnedWorkDuringRender
=
null
;
}
{
ReactStrictModeWarnings
.
discardPendingWarnings
(
)
;
componentsThatTriggeredHighPriSuspend
=
null
;
}
}
function
handleError
(
root
thrownValue
)
{
do
{
try
{
resetContextDependencies
(
)
;
resetHooks
(
)
;
resetCurrentFiber
(
)
;
if
(
workInProgress
=
=
=
null
|
|
workInProgress
.
return
=
=
=
null
)
{
workInProgressRootExitStatus
=
RootFatalErrored
;
workInProgressRootFatalError
=
thrownValue
;
return
null
;
}
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
stopProfilerTimerIfRunningAndRecordDelta
(
workInProgress
true
)
;
}
throwException
(
root
workInProgress
.
return
workInProgress
thrownValue
renderExpirationTime
)
;
workInProgress
=
completeUnitOfWork
(
workInProgress
)
;
}
catch
(
yetAnotherThrownValue
)
{
thrownValue
=
yetAnotherThrownValue
;
continue
;
}
return
;
}
while
(
true
)
;
}
function
pushDispatcher
(
root
)
{
var
prevDispatcher
=
ReactCurrentDispatcher
.
current
;
ReactCurrentDispatcher
.
current
=
ContextOnlyDispatcher
;
if
(
prevDispatcher
=
=
=
null
)
{
return
ContextOnlyDispatcher
;
}
else
{
return
prevDispatcher
;
}
}
function
popDispatcher
(
prevDispatcher
)
{
ReactCurrentDispatcher
.
current
=
prevDispatcher
;
}
function
pushInteractions
(
root
)
{
if
(
enableSchedulerTracing
)
{
var
prevInteractions
=
__interactionsRef
.
current
;
__interactionsRef
.
current
=
root
.
memoizedInteractions
;
return
prevInteractions
;
}
return
null
;
}
function
popInteractions
(
prevInteractions
)
{
if
(
enableSchedulerTracing
)
{
__interactionsRef
.
current
=
prevInteractions
;
}
}
function
markCommitTimeOfFallback
(
)
{
globalMostRecentFallbackTime
=
now
(
)
;
}
function
markRenderEventTimeAndConfig
(
expirationTime
suspenseConfig
)
{
if
(
expirationTime
<
workInProgressRootLatestProcessedExpirationTime
&
&
expirationTime
>
Idle
)
{
workInProgressRootLatestProcessedExpirationTime
=
expirationTime
;
}
if
(
suspenseConfig
!
=
=
null
)
{
if
(
expirationTime
<
workInProgressRootLatestSuspenseTimeout
&
&
expirationTime
>
Idle
)
{
workInProgressRootLatestSuspenseTimeout
=
expirationTime
;
workInProgressRootCanSuspendUsingConfig
=
suspenseConfig
;
}
}
}
function
markUnprocessedUpdateTime
(
expirationTime
)
{
if
(
expirationTime
>
workInProgressRootNextUnprocessedUpdateTime
)
{
workInProgressRootNextUnprocessedUpdateTime
=
expirationTime
;
}
}
function
renderDidSuspend
(
)
{
if
(
workInProgressRootExitStatus
=
=
=
RootIncomplete
)
{
workInProgressRootExitStatus
=
RootSuspended
;
}
}
function
renderDidSuspendDelayIfPossible
(
)
{
if
(
workInProgressRootExitStatus
=
=
=
RootIncomplete
|
|
workInProgressRootExitStatus
=
=
=
RootSuspended
)
{
workInProgressRootExitStatus
=
RootSuspendedWithDelay
;
}
if
(
workInProgressRootNextUnprocessedUpdateTime
!
=
=
NoWork
&
&
workInProgressRoot
!
=
=
null
)
{
markRootSuspendedAtTime
(
workInProgressRoot
renderExpirationTime
)
;
markRootUpdatedAtTime
(
workInProgressRoot
workInProgressRootNextUnprocessedUpdateTime
)
;
}
}
function
renderDidError
(
)
{
if
(
workInProgressRootExitStatus
!
=
=
RootCompleted
)
{
workInProgressRootExitStatus
=
RootErrored
;
}
}
function
renderHasNotSuspendedYet
(
)
{
return
workInProgressRootExitStatus
=
=
=
RootIncomplete
;
}
function
inferTimeFromExpirationTime
(
expirationTime
)
{
var
earliestExpirationTimeMs
=
expirationTimeToMs
(
expirationTime
)
;
return
earliestExpirationTimeMs
-
LOW_PRIORITY_EXPIRATION
;
}
function
inferTimeFromExpirationTimeWithSuspenseConfig
(
expirationTime
suspenseConfig
)
{
var
earliestExpirationTimeMs
=
expirationTimeToMs
(
expirationTime
)
;
return
earliestExpirationTimeMs
-
(
suspenseConfig
.
timeoutMs
|
0
|
|
LOW_PRIORITY_EXPIRATION
)
;
}
function
workLoopSync
(
)
{
while
(
workInProgress
!
=
=
null
)
{
workInProgress
=
performUnitOfWork
(
workInProgress
)
;
}
}
function
workLoopConcurrent
(
)
{
while
(
workInProgress
!
=
=
null
&
&
!
shouldYield
(
)
)
{
workInProgress
=
performUnitOfWork
(
workInProgress
)
;
}
}
function
performUnitOfWork
(
unitOfWork
)
{
var
current
1
=
unitOfWork
.
alternate
;
startWorkTimer
(
unitOfWork
)
;
setCurrentFiber
(
unitOfWork
)
;
var
next
;
if
(
enableProfilerTimer
&
&
(
unitOfWork
.
mode
&
ProfileMode
)
!
=
=
NoMode
)
{
startProfilerTimer
(
unitOfWork
)
;
next
=
beginWork
1
(
current
1
unitOfWork
renderExpirationTime
)
;
stopProfilerTimerIfRunningAndRecordDelta
(
unitOfWork
true
)
;
}
else
{
next
=
beginWork
1
(
current
1
unitOfWork
renderExpirationTime
)
;
}
resetCurrentFiber
(
)
;
unitOfWork
.
memoizedProps
=
unitOfWork
.
pendingProps
;
if
(
next
=
=
=
null
)
{
next
=
completeUnitOfWork
(
unitOfWork
)
;
}
ReactCurrentOwner
2
.
current
=
null
;
return
next
;
}
function
completeUnitOfWork
(
unitOfWork
)
{
workInProgress
=
unitOfWork
;
do
{
var
current
1
=
workInProgress
.
alternate
;
var
returnFiber
=
workInProgress
.
return
;
if
(
(
workInProgress
.
effectTag
&
Incomplete
)
=
=
=
NoEffect
)
{
setCurrentFiber
(
workInProgress
)
;
var
next
=
void
0
;
if
(
!
enableProfilerTimer
|
|
(
workInProgress
.
mode
&
ProfileMode
)
=
=
=
NoMode
)
{
next
=
completeWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
else
{
startProfilerTimer
(
workInProgress
)
;
next
=
completeWork
(
current
1
workInProgress
renderExpirationTime
)
;
stopProfilerTimerIfRunningAndRecordDelta
(
workInProgress
false
)
;
}
stopWorkTimer
(
workInProgress
)
;
resetCurrentFiber
(
)
;
resetChildExpirationTime
(
workInProgress
)
;
if
(
next
!
=
=
null
)
{
return
next
;
}
if
(
returnFiber
!
=
=
null
&
&
(
returnFiber
.
effectTag
&
Incomplete
)
=
=
=
NoEffect
)
{
if
(
returnFiber
.
firstEffect
=
=
=
null
)
{
returnFiber
.
firstEffect
=
workInProgress
.
firstEffect
;
}
if
(
workInProgress
.
lastEffect
!
=
=
null
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
.
firstEffect
;
}
returnFiber
.
lastEffect
=
workInProgress
.
lastEffect
;
}
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
>
PerformedWork
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
;
}
else
{
returnFiber
.
firstEffect
=
workInProgress
;
}
returnFiber
.
lastEffect
=
workInProgress
;
}
}
}
else
{
var
_next
=
unwindWork
(
workInProgress
renderExpirationTime
)
;
if
(
enableProfilerTimer
&
&
(
workInProgress
.
mode
&
ProfileMode
)
!
=
=
NoMode
)
{
stopProfilerTimerIfRunningAndRecordDelta
(
workInProgress
false
)
;
var
actualDuration
=
workInProgress
.
actualDuration
;
var
child
=
workInProgress
.
child
;
while
(
child
!
=
=
null
)
{
actualDuration
+
=
child
.
actualDuration
;
child
=
child
.
sibling
;
}
workInProgress
.
actualDuration
=
actualDuration
;
}
if
(
_next
!
=
=
null
)
{
stopFailedWorkTimer
(
workInProgress
)
;
_next
.
effectTag
&
=
HostEffectMask
;
return
_next
;
}
stopWorkTimer
(
workInProgress
)
;
if
(
returnFiber
!
=
=
null
)
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
null
;
returnFiber
.
effectTag
|
=
Incomplete
;
}
}
var
siblingFiber
=
workInProgress
.
sibling
;
if
(
siblingFiber
!
=
=
null
)
{
return
siblingFiber
;
}
workInProgress
=
returnFiber
;
}
while
(
workInProgress
!
=
=
null
)
;
if
(
workInProgressRootExitStatus
=
=
=
RootIncomplete
)
{
workInProgressRootExitStatus
=
RootCompleted
;
}
return
null
;
}
function
getRemainingExpirationTime
(
fiber
)
{
var
updateExpirationTime
=
fiber
.
expirationTime
;
var
childExpirationTime
=
fiber
.
childExpirationTime
;
return
updateExpirationTime
>
childExpirationTime
?
updateExpirationTime
:
childExpirationTime
;
}
function
resetChildExpirationTime
(
completedWork
)
{
if
(
renderExpirationTime
!
=
=
Never
&
&
completedWork
.
childExpirationTime
=
=
=
Never
)
{
return
;
}
var
newChildExpirationTime
=
NoWork
;
if
(
enableProfilerTimer
&
&
(
completedWork
.
mode
&
ProfileMode
)
!
=
=
NoMode
)
{
var
actualDuration
=
completedWork
.
actualDuration
;
var
treeBaseDuration
=
completedWork
.
selfBaseDuration
;
var
shouldBubbleActualDurations
=
completedWork
.
alternate
=
=
=
null
|
|
completedWork
.
child
!
=
=
completedWork
.
alternate
.
child
;
var
child
=
completedWork
.
child
;
while
(
child
!
=
=
null
)
{
var
childUpdateExpirationTime
=
child
.
expirationTime
;
var
childChildExpirationTime
=
child
.
childExpirationTime
;
if
(
childUpdateExpirationTime
>
newChildExpirationTime
)
{
newChildExpirationTime
=
childUpdateExpirationTime
;
}
if
(
childChildExpirationTime
>
newChildExpirationTime
)
{
newChildExpirationTime
=
childChildExpirationTime
;
}
if
(
shouldBubbleActualDurations
)
{
actualDuration
+
=
child
.
actualDuration
;
}
treeBaseDuration
+
=
child
.
treeBaseDuration
;
child
=
child
.
sibling
;
}
completedWork
.
actualDuration
=
actualDuration
;
completedWork
.
treeBaseDuration
=
treeBaseDuration
;
}
else
{
var
_child
=
completedWork
.
child
;
while
(
_child
!
=
=
null
)
{
var
_childUpdateExpirationTime
=
_child
.
expirationTime
;
var
_childChildExpirationTime
=
_child
.
childExpirationTime
;
if
(
_childUpdateExpirationTime
>
newChildExpirationTime
)
{
newChildExpirationTime
=
_childUpdateExpirationTime
;
}
if
(
_childChildExpirationTime
>
newChildExpirationTime
)
{
newChildExpirationTime
=
_childChildExpirationTime
;
}
_child
=
_child
.
sibling
;
}
}
completedWork
.
childExpirationTime
=
newChildExpirationTime
;
}
function
commitRoot
(
root
)
{
var
renderPriorityLevel
=
getCurrentPriorityLevel
(
)
;
runWithPriority
2
(
ImmediatePriority
commitRootImpl
.
bind
(
null
root
renderPriorityLevel
)
)
;
return
null
;
}
function
commitRootImpl
(
root
renderPriorityLevel
)
{
do
{
flushPassiveEffects
(
)
;
}
while
(
rootWithPendingPassiveEffects
!
=
=
null
)
;
flushRenderPhaseStrictModeWarningsInDEV
(
)
;
if
(
!
(
(
executionContext
&
(
RenderContext
|
CommitContext
)
)
=
=
=
NoContext
)
)
{
{
throw
Error
(
"
Should
not
already
be
working
.
"
)
;
}
}
var
finishedWork
=
root
.
finishedWork
;
var
expirationTime
=
root
.
finishedExpirationTime
;
if
(
finishedWork
=
=
=
null
)
{
return
null
;
}
root
.
finishedWork
=
null
;
root
.
finishedExpirationTime
=
NoWork
;
if
(
!
(
finishedWork
!
=
=
root
.
current
)
)
{
{
throw
Error
(
"
Cannot
commit
the
same
tree
as
before
.
This
error
is
likely
caused
by
a
bug
in
React
.
Please
file
an
issue
.
"
)
;
}
}
root
.
callbackNode
=
null
;
root
.
callbackExpirationTime
=
NoWork
;
root
.
callbackPriority
=
NoPriority
;
root
.
nextKnownPendingLevel
=
NoWork
;
startCommitTimer
(
)
;
var
remainingExpirationTimeBeforeCommit
=
getRemainingExpirationTime
(
finishedWork
)
;
markRootFinishedAtTime
(
root
expirationTime
remainingExpirationTimeBeforeCommit
)
;
if
(
root
=
=
=
workInProgressRoot
)
{
workInProgressRoot
=
null
;
workInProgress
=
null
;
renderExpirationTime
=
NoWork
;
}
else
{
}
var
firstEffect
;
if
(
finishedWork
.
effectTag
>
PerformedWork
)
{
if
(
finishedWork
.
lastEffect
!
=
=
null
)
{
finishedWork
.
lastEffect
.
nextEffect
=
finishedWork
;
firstEffect
=
finishedWork
.
firstEffect
;
}
else
{
firstEffect
=
finishedWork
;
}
}
else
{
firstEffect
=
finishedWork
.
firstEffect
;
}
if
(
firstEffect
!
=
=
null
)
{
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
CommitContext
;
var
prevInteractions
=
pushInteractions
(
root
)
;
ReactCurrentOwner
2
.
current
=
null
;
startCommitSnapshotEffectsTimer
(
)
;
prepareForCommit
(
root
.
containerInfo
)
;
nextEffect
=
firstEffect
;
do
{
{
invokeGuardedCallback
(
null
commitBeforeMutationEffects
null
)
;
if
(
hasCaughtError
(
)
)
{
if
(
!
(
nextEffect
!
=
=
null
)
)
{
{
throw
Error
(
"
Should
be
working
on
an
effect
.
"
)
;
}
}
var
error
=
clearCaughtError
(
)
;
captureCommitPhaseError
(
nextEffect
error
)
;
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
while
(
nextEffect
!
=
=
null
)
;
stopCommitSnapshotEffectsTimer
(
)
;
if
(
enableProfilerTimer
)
{
recordCommitTime
(
)
;
}
startCommitHostEffectsTimer
(
)
;
nextEffect
=
firstEffect
;
do
{
{
invokeGuardedCallback
(
null
commitMutationEffects
null
root
renderPriorityLevel
)
;
if
(
hasCaughtError
(
)
)
{
if
(
!
(
nextEffect
!
=
=
null
)
)
{
{
throw
Error
(
"
Should
be
working
on
an
effect
.
"
)
;
}
}
var
_error
=
clearCaughtError
(
)
;
captureCommitPhaseError
(
nextEffect
_error
)
;
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
while
(
nextEffect
!
=
=
null
)
;
stopCommitHostEffectsTimer
(
)
;
resetAfterCommit
(
root
.
containerInfo
)
;
root
.
current
=
finishedWork
;
startCommitLifeCyclesTimer
(
)
;
nextEffect
=
firstEffect
;
do
{
{
invokeGuardedCallback
(
null
commitLayoutEffects
null
root
expirationTime
)
;
if
(
hasCaughtError
(
)
)
{
if
(
!
(
nextEffect
!
=
=
null
)
)
{
{
throw
Error
(
"
Should
be
working
on
an
effect
.
"
)
;
}
}
var
_error2
=
clearCaughtError
(
)
;
captureCommitPhaseError
(
nextEffect
_error2
)
;
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
while
(
nextEffect
!
=
=
null
)
;
stopCommitLifeCyclesTimer
(
)
;
nextEffect
=
null
;
requestPaint
(
)
;
if
(
enableSchedulerTracing
)
{
popInteractions
(
prevInteractions
)
;
}
executionContext
=
prevExecutionContext
;
}
else
{
root
.
current
=
finishedWork
;
startCommitSnapshotEffectsTimer
(
)
;
stopCommitSnapshotEffectsTimer
(
)
;
if
(
enableProfilerTimer
)
{
recordCommitTime
(
)
;
}
startCommitHostEffectsTimer
(
)
;
stopCommitHostEffectsTimer
(
)
;
startCommitLifeCyclesTimer
(
)
;
stopCommitLifeCyclesTimer
(
)
;
}
stopCommitTimer
(
)
;
var
rootDidHavePassiveEffects
=
rootDoesHavePassiveEffects
;
if
(
rootDoesHavePassiveEffects
)
{
rootDoesHavePassiveEffects
=
false
;
rootWithPendingPassiveEffects
=
root
;
pendingPassiveEffectsExpirationTime
=
expirationTime
;
pendingPassiveEffectsRenderPriority
=
renderPriorityLevel
;
}
else
{
nextEffect
=
firstEffect
;
while
(
nextEffect
!
=
=
null
)
{
var
nextNextEffect
=
nextEffect
.
nextEffect
;
nextEffect
.
nextEffect
=
null
;
nextEffect
=
nextNextEffect
;
}
}
var
remainingExpirationTime
=
root
.
firstPendingTime
;
if
(
remainingExpirationTime
!
=
=
NoWork
)
{
if
(
enableSchedulerTracing
)
{
if
(
spawnedWorkDuringRender
!
=
=
null
)
{
var
expirationTimes
=
spawnedWorkDuringRender
;
spawnedWorkDuringRender
=
null
;
for
(
var
i
=
0
;
i
<
expirationTimes
.
length
;
i
+
+
)
{
scheduleInteractions
(
root
expirationTimes
[
i
]
root
.
memoizedInteractions
)
;
}
}
schedulePendingInteractions
(
root
remainingExpirationTime
)
;
}
}
else
{
legacyErrorBoundariesThatAlreadyFailed
=
null
;
}
if
(
enableSchedulerTracing
)
{
if
(
!
rootDidHavePassiveEffects
)
{
finishPendingInteractions
(
root
expirationTime
)
;
}
}
if
(
remainingExpirationTime
=
=
=
Sync
)
{
if
(
root
=
=
=
rootWithNestedUpdates
)
{
nestedUpdateCount
+
+
;
}
else
{
nestedUpdateCount
=
0
;
rootWithNestedUpdates
=
root
;
}
}
else
{
nestedUpdateCount
=
0
;
}
onCommitRoot
(
finishedWork
.
stateNode
expirationTime
)
;
ensureRootIsScheduled
(
root
)
;
if
(
hasUncaughtError
)
{
hasUncaughtError
=
false
;
var
_error3
=
firstUncaughtError
;
firstUncaughtError
=
null
;
throw
_error3
;
}
if
(
(
executionContext
&
LegacyUnbatchedContext
)
!
=
=
NoContext
)
{
return
null
;
}
flushSyncCallbackQueue
(
)
;
return
null
;
}
function
commitBeforeMutationEffects
(
)
{
while
(
nextEffect
!
=
=
null
)
{
var
effectTag
=
nextEffect
.
effectTag
;
if
(
(
effectTag
&
Snapshot
)
!
=
=
NoEffect
)
{
setCurrentFiber
(
nextEffect
)
;
recordEffect
(
)
;
var
current
1
=
nextEffect
.
alternate
;
commitBeforeMutationLifeCycles
(
current
1
nextEffect
)
;
resetCurrentFiber
(
)
;
}
if
(
(
effectTag
&
Passive
)
!
=
=
NoEffect
)
{
if
(
!
rootDoesHavePassiveEffects
)
{
rootDoesHavePassiveEffects
=
true
;
scheduleCallback
(
NormalPriority
function
(
)
{
flushPassiveEffects
(
)
;
return
null
;
}
)
;
}
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitMutationEffects
(
root
renderPriorityLevel
)
{
while
(
nextEffect
!
=
=
null
)
{
setCurrentFiber
(
nextEffect
)
;
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
ContentReset
)
{
commitResetTextContent
(
nextEffect
)
;
}
if
(
effectTag
&
Ref
)
{
var
current
1
=
nextEffect
.
alternate
;
if
(
current
1
!
=
=
null
)
{
commitDetachRef
(
current
1
)
;
}
}
var
primaryEffectTag
=
effectTag
&
(
Placement
|
Update
|
Deletion
|
Hydrating
)
;
switch
(
primaryEffectTag
)
{
case
Placement
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
break
;
}
case
PlacementAndUpdate
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
var
_current
=
nextEffect
.
alternate
;
commitWork
(
_current
nextEffect
)
;
break
;
}
case
Hydrating
:
{
nextEffect
.
effectTag
&
=
~
Hydrating
;
break
;
}
case
HydratingAndUpdate
:
{
nextEffect
.
effectTag
&
=
~
Hydrating
;
var
_current2
=
nextEffect
.
alternate
;
commitWork
(
_current2
nextEffect
)
;
break
;
}
case
Update
:
{
var
_current3
=
nextEffect
.
alternate
;
commitWork
(
_current3
nextEffect
)
;
break
;
}
case
Deletion
:
{
commitDeletion
(
root
nextEffect
renderPriorityLevel
)
;
break
;
}
}
recordEffect
(
)
;
resetCurrentFiber
(
)
;
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitLayoutEffects
(
root
committedExpirationTime
)
{
while
(
nextEffect
!
=
=
null
)
{
setCurrentFiber
(
nextEffect
)
;
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
(
Update
|
Callback
)
)
{
recordEffect
(
)
;
var
current
1
=
nextEffect
.
alternate
;
commitLifeCycles
(
root
current
1
nextEffect
committedExpirationTime
)
;
}
if
(
effectTag
&
Ref
)
{
recordEffect
(
)
;
commitAttachRef
(
nextEffect
)
;
}
resetCurrentFiber
(
)
;
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
flushPassiveEffects
(
)
{
if
(
pendingPassiveEffectsRenderPriority
!
=
=
NoPriority
)
{
var
priorityLevel
=
pendingPassiveEffectsRenderPriority
>
NormalPriority
?
NormalPriority
:
pendingPassiveEffectsRenderPriority
;
pendingPassiveEffectsRenderPriority
=
NoPriority
;
return
runWithPriority
2
(
priorityLevel
flushPassiveEffectsImpl
)
;
}
}
function
flushPassiveEffectsImpl
(
)
{
if
(
rootWithPendingPassiveEffects
=
=
=
null
)
{
return
false
;
}
var
root
=
rootWithPendingPassiveEffects
;
var
expirationTime
=
pendingPassiveEffectsExpirationTime
;
rootWithPendingPassiveEffects
=
null
;
pendingPassiveEffectsExpirationTime
=
NoWork
;
if
(
!
(
(
executionContext
&
(
RenderContext
|
CommitContext
)
)
=
=
=
NoContext
)
)
{
{
throw
Error
(
"
Cannot
flush
passive
effects
while
already
rendering
.
"
)
;
}
}
var
prevExecutionContext
=
executionContext
;
executionContext
|
=
CommitContext
;
var
prevInteractions
=
pushInteractions
(
root
)
;
var
effect
=
root
.
current
.
firstEffect
;
while
(
effect
!
=
=
null
)
{
{
setCurrentFiber
(
effect
)
;
invokeGuardedCallback
(
null
commitPassiveHookEffects
null
effect
)
;
if
(
hasCaughtError
(
)
)
{
if
(
!
(
effect
!
=
=
null
)
)
{
{
throw
Error
(
"
Should
be
working
on
an
effect
.
"
)
;
}
}
var
error
=
clearCaughtError
(
)
;
captureCommitPhaseError
(
effect
error
)
;
}
resetCurrentFiber
(
)
;
}
var
nextNextEffect
=
effect
.
nextEffect
;
effect
.
nextEffect
=
null
;
effect
=
nextNextEffect
;
}
if
(
enableSchedulerTracing
)
{
popInteractions
(
prevInteractions
)
;
finishPendingInteractions
(
root
expirationTime
)
;
}
executionContext
=
prevExecutionContext
;
flushSyncCallbackQueue
(
)
;
nestedPassiveUpdateCount
=
rootWithPendingPassiveEffects
=
=
=
null
?
0
:
nestedPassiveUpdateCount
+
1
;
return
true
;
}
function
isAlreadyFailedLegacyErrorBoundary
(
instance
)
{
return
legacyErrorBoundariesThatAlreadyFailed
!
=
=
null
&
&
legacyErrorBoundariesThatAlreadyFailed
.
has
(
instance
)
;
}
function
markLegacyErrorBoundaryAsFailed
(
instance
)
{
if
(
legacyErrorBoundariesThatAlreadyFailed
=
=
=
null
)
{
legacyErrorBoundariesThatAlreadyFailed
=
new
Set
(
[
instance
]
)
;
}
else
{
legacyErrorBoundariesThatAlreadyFailed
.
add
(
instance
)
;
}
}
function
prepareToThrowUncaughtError
(
error
)
{
if
(
!
hasUncaughtError
)
{
hasUncaughtError
=
true
;
firstUncaughtError
=
error
;
}
}
var
onUncaughtError
=
prepareToThrowUncaughtError
;
function
captureCommitPhaseErrorOnRoot
(
rootFiber
sourceFiber
error
)
{
var
errorInfo
=
createCapturedValue
(
error
sourceFiber
)
;
var
update
=
createRootErrorUpdate
(
rootFiber
errorInfo
Sync
)
;
enqueueUpdate
(
rootFiber
update
)
;
var
root
=
markUpdateTimeFromFiberToRoot
(
rootFiber
Sync
)
;
if
(
root
!
=
=
null
)
{
ensureRootIsScheduled
(
root
)
;
schedulePendingInteractions
(
root
Sync
)
;
}
}
function
captureCommitPhaseError
(
sourceFiber
error
)
{
if
(
sourceFiber
.
tag
=
=
=
HostRoot
)
{
captureCommitPhaseErrorOnRoot
(
sourceFiber
sourceFiber
error
)
;
return
;
}
var
fiber
=
sourceFiber
.
return
;
while
(
fiber
!
=
=
null
)
{
if
(
fiber
.
tag
=
=
=
HostRoot
)
{
captureCommitPhaseErrorOnRoot
(
fiber
sourceFiber
error
)
;
return
;
}
else
if
(
fiber
.
tag
=
=
=
ClassComponent
)
{
var
ctor
=
fiber
.
type
;
var
instance
=
fiber
.
stateNode
;
if
(
typeof
ctor
.
getDerivedStateFromError
=
=
=
'
function
'
|
|
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
&
&
!
isAlreadyFailedLegacyErrorBoundary
(
instance
)
)
{
var
errorInfo
=
createCapturedValue
(
error
sourceFiber
)
;
var
update
=
createClassErrorUpdate
(
fiber
errorInfo
Sync
)
;
enqueueUpdate
(
fiber
update
)
;
var
root
=
markUpdateTimeFromFiberToRoot
(
fiber
Sync
)
;
if
(
root
!
=
=
null
)
{
ensureRootIsScheduled
(
root
)
;
schedulePendingInteractions
(
root
Sync
)
;
}
return
;
}
}
fiber
=
fiber
.
return
;
}
}
function
pingSuspendedRoot
(
root
thenable
suspendedTime
)
{
var
pingCache
=
root
.
pingCache
;
if
(
pingCache
!
=
=
null
)
{
pingCache
.
delete
(
thenable
)
;
}
if
(
workInProgressRoot
=
=
=
root
&
&
renderExpirationTime
=
=
=
suspendedTime
)
{
if
(
workInProgressRootExitStatus
=
=
=
RootSuspendedWithDelay
|
|
workInProgressRootExitStatus
=
=
=
RootSuspended
&
&
workInProgressRootLatestProcessedExpirationTime
=
=
=
Sync
&
&
now
(
)
-
globalMostRecentFallbackTime
<
FALLBACK_THROTTLE_MS
)
{
prepareFreshStack
(
root
renderExpirationTime
)
;
}
else
{
workInProgressRootHasPendingPing
=
true
;
}
return
;
}
if
(
!
isRootSuspendedAtTime
(
root
suspendedTime
)
)
{
return
;
}
var
lastPingedTime
=
root
.
lastPingedTime
;
if
(
lastPingedTime
!
=
=
NoWork
&
&
lastPingedTime
<
suspendedTime
)
{
return
;
}
root
.
lastPingedTime
=
suspendedTime
;
if
(
root
.
finishedExpirationTime
=
=
=
suspendedTime
)
{
root
.
finishedExpirationTime
=
NoWork
;
root
.
finishedWork
=
null
;
}
ensureRootIsScheduled
(
root
)
;
schedulePendingInteractions
(
root
suspendedTime
)
;
}
function
retryTimedOutBoundary
(
boundaryFiber
retryTime
)
{
if
(
retryTime
=
=
=
NoWork
)
{
var
suspenseConfig
=
null
;
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
retryTime
=
computeExpirationForFiber
(
currentTime
boundaryFiber
suspenseConfig
)
;
}
var
root
=
markUpdateTimeFromFiberToRoot
(
boundaryFiber
retryTime
)
;
if
(
root
!
=
=
null
)
{
ensureRootIsScheduled
(
root
)
;
schedulePendingInteractions
(
root
retryTime
)
;
}
}
function
retryDehydratedSuspenseBoundary
(
boundaryFiber
)
{
var
suspenseState
=
boundaryFiber
.
memoizedState
;
var
retryTime
=
NoWork
;
if
(
suspenseState
!
=
=
null
)
{
retryTime
=
suspenseState
.
retryTime
;
}
retryTimedOutBoundary
(
boundaryFiber
retryTime
)
;
}
function
resolveRetryThenable
(
boundaryFiber
thenable
)
{
var
retryTime
=
NoWork
;
var
retryCache
;
if
(
enableSuspenseServerRenderer
)
{
switch
(
boundaryFiber
.
tag
)
{
case
SuspenseComponent
:
retryCache
=
boundaryFiber
.
stateNode
;
var
suspenseState
=
boundaryFiber
.
memoizedState
;
if
(
suspenseState
!
=
=
null
)
{
retryTime
=
suspenseState
.
retryTime
;
}
break
;
case
SuspenseListComponent
:
retryCache
=
boundaryFiber
.
stateNode
;
break
;
default
:
{
{
throw
Error
(
"
Pinged
unknown
suspense
boundary
type
.
This
is
probably
a
bug
in
React
.
"
)
;
}
}
}
}
else
{
retryCache
=
boundaryFiber
.
stateNode
;
}
if
(
retryCache
!
=
=
null
)
{
retryCache
.
delete
(
thenable
)
;
}
retryTimedOutBoundary
(
boundaryFiber
retryTime
)
;
}
function
jnd
(
timeElapsed
)
{
return
timeElapsed
<
120
?
120
:
timeElapsed
<
480
?
480
:
timeElapsed
<
1080
?
1080
:
timeElapsed
<
1920
?
1920
:
timeElapsed
<
3000
?
3000
:
timeElapsed
<
4320
?
4320
:
ceil
(
timeElapsed
/
1960
)
*
1960
;
}
function
computeMsUntilSuspenseLoadingDelay
(
mostRecentEventTime
committedExpirationTime
suspenseConfig
)
{
var
busyMinDurationMs
=
suspenseConfig
.
busyMinDurationMs
|
0
;
if
(
busyMinDurationMs
<
=
0
)
{
return
0
;
}
var
busyDelayMs
=
suspenseConfig
.
busyDelayMs
|
0
;
var
currentTimeMs
=
now
(
)
;
var
eventTimeMs
=
inferTimeFromExpirationTimeWithSuspenseConfig
(
mostRecentEventTime
suspenseConfig
)
;
var
timeElapsed
=
currentTimeMs
-
eventTimeMs
;
if
(
timeElapsed
<
=
busyDelayMs
)
{
return
0
;
}
var
msUntilTimeout
=
busyDelayMs
+
busyMinDurationMs
-
timeElapsed
;
return
msUntilTimeout
;
}
function
checkForNestedUpdates
(
)
{
if
(
nestedUpdateCount
>
NESTED_UPDATE_LIMIT
)
{
nestedUpdateCount
=
0
;
rootWithNestedUpdates
=
null
;
{
{
throw
Error
(
"
Maximum
update
depth
exceeded
.
This
can
happen
when
a
component
repeatedly
calls
setState
inside
componentWillUpdate
or
componentDidUpdate
.
React
limits
the
number
of
nested
updates
to
prevent
infinite
loops
.
"
)
;
}
}
}
{
if
(
nestedPassiveUpdateCount
>
NESTED_PASSIVE_UPDATE_LIMIT
)
{
nestedPassiveUpdateCount
=
0
;
warning
1
(
false
'
Maximum
update
depth
exceeded
.
This
can
happen
when
a
component
'
+
"
calls
setState
inside
useEffect
but
useEffect
either
doesn
'
t
"
+
'
have
a
dependency
array
or
one
of
the
dependencies
changes
on
'
+
'
every
render
.
'
)
;
}
}
}
function
flushRenderPhaseStrictModeWarningsInDEV
(
)
{
{
ReactStrictModeWarnings
.
flushLegacyContextWarning
(
)
;
if
(
warnAboutDeprecatedLifecycles
)
{
ReactStrictModeWarnings
.
flushPendingUnsafeLifecycleWarnings
(
)
;
}
}
}
function
stopFinishedWorkLoopTimer
(
)
{
var
didCompleteRoot
=
true
;
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
}
function
stopInterruptedWorkLoopTimer
(
)
{
var
didCompleteRoot
=
false
;
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
}
function
checkForInterruption
(
fiberThatReceivedUpdate
updateExpirationTime
)
{
if
(
enableUserTimingAPI
&
&
workInProgressRoot
!
=
=
null
&
&
updateExpirationTime
>
renderExpirationTime
)
{
interruptedBy
=
fiberThatReceivedUpdate
;
}
}
var
didWarnStateUpdateForUnmountedComponent
=
null
;
function
warnAboutUpdateOnUnmountedFiberInDEV
(
fiber
)
{
{
var
tag
=
fiber
.
tag
;
if
(
tag
!
=
=
HostRoot
&
&
tag
!
=
=
ClassComponent
&
&
tag
!
=
=
FunctionComponent
&
&
tag
!
=
=
ForwardRef
&
&
tag
!
=
=
MemoComponent
&
&
tag
!
=
=
SimpleMemoComponent
)
{
return
;
}
var
componentName
=
getComponentName
(
fiber
.
type
)
|
|
'
ReactComponent
'
;
if
(
didWarnStateUpdateForUnmountedComponent
!
=
=
null
)
{
if
(
didWarnStateUpdateForUnmountedComponent
.
has
(
componentName
)
)
{
return
;
}
didWarnStateUpdateForUnmountedComponent
.
add
(
componentName
)
;
}
else
{
didWarnStateUpdateForUnmountedComponent
=
new
Set
(
[
componentName
]
)
;
}
warningWithoutStack
1
(
false
"
Can
'
t
perform
a
React
state
update
on
an
unmounted
component
.
This
"
+
'
is
a
no
-
op
but
it
indicates
a
memory
leak
in
your
application
.
To
'
+
'
fix
cancel
all
subscriptions
and
asynchronous
tasks
in
%
s
.
%
s
'
tag
=
=
=
ClassComponent
?
'
the
componentWillUnmount
method
'
:
'
a
useEffect
cleanup
function
'
getStackByFiberInDevAndProd
(
fiber
)
)
;
}
}
var
beginWork
1
;
if
(
true
&
&
replayFailedUnitOfWorkWithInvokeGuardedCallback
)
{
var
dummyFiber
=
null
;
beginWork
1
=
function
(
current
1
unitOfWork
expirationTime
)
{
var
originalWorkInProgressCopy
=
assignFiberPropertiesInDEV
(
dummyFiber
unitOfWork
)
;
try
{
return
beginWork
1
(
current
1
unitOfWork
expirationTime
)
;
}
catch
(
originalError
)
{
if
(
originalError
!
=
=
null
&
&
typeof
originalError
=
=
=
'
object
'
&
&
typeof
originalError
.
then
=
=
=
'
function
'
)
{
throw
originalError
;
}
resetContextDependencies
(
)
;
resetHooks
(
)
;
unwindInterruptedWork
(
unitOfWork
)
;
assignFiberPropertiesInDEV
(
unitOfWork
originalWorkInProgressCopy
)
;
if
(
enableProfilerTimer
&
&
unitOfWork
.
mode
&
ProfileMode
)
{
startProfilerTimer
(
unitOfWork
)
;
}
invokeGuardedCallback
(
null
beginWork
1
null
current
1
unitOfWork
expirationTime
)
;
if
(
hasCaughtError
(
)
)
{
var
replayError
=
clearCaughtError
(
)
;
throw
replayError
;
}
else
{
throw
originalError
;
}
}
}
;
}
else
{
beginWork
1
=
beginWork
1
;
}
var
didWarnAboutUpdateInRender
=
false
;
var
didWarnAboutUpdateInGetChildContext
=
false
;
function
warnAboutInvalidUpdatesOnClassComponentsInDEV
(
fiber
)
{
{
if
(
fiber
.
tag
=
=
=
ClassComponent
)
{
switch
(
phase
)
{
case
'
getChildContext
'
:
if
(
didWarnAboutUpdateInGetChildContext
)
{
return
;
}
warningWithoutStack
1
(
false
'
setState
(
.
.
.
)
:
Cannot
call
setState
(
)
inside
getChildContext
(
)
'
)
;
didWarnAboutUpdateInGetChildContext
=
true
;
break
;
case
'
render
'
:
if
(
didWarnAboutUpdateInRender
)
{
return
;
}
warningWithoutStack
1
(
false
'
Cannot
update
during
an
existing
state
transition
(
such
as
'
+
'
within
render
)
.
Render
methods
should
be
a
pure
function
of
'
+
'
props
and
state
.
'
)
;
didWarnAboutUpdateInRender
=
true
;
break
;
}
}
}
}
var
IsThisRendererActing
=
{
current
:
false
}
;
function
warnIfNotScopedWithMatchingAct
(
fiber
)
{
{
if
(
warnsIfNotActing
=
=
=
true
&
&
IsSomeRendererActing
.
current
=
=
=
true
&
&
IsThisRendererActing
.
current
!
=
=
true
)
{
warningWithoutStack
1
(
false
"
It
looks
like
you
'
re
using
the
wrong
act
(
)
around
your
test
interactions
.
\
n
"
+
'
Be
sure
to
use
the
matching
version
of
act
(
)
corresponding
to
your
renderer
:
\
n
\
n
'
+
'
/
/
for
react
-
dom
:
\
n
'
+
"
import
{
act
}
from
'
react
-
dom
/
test
-
utils
'
;
\
n
"
+
'
/
/
.
.
.
\
n
'
+
'
act
(
(
)
=
>
.
.
.
)
;
\
n
\
n
'
+
'
/
/
for
react
-
test
-
renderer
:
\
n
'
+
"
import
TestRenderer
from
'
react
-
test
-
renderer
'
;
\
n
"
+
'
const
{
act
}
=
TestRenderer
;
\
n
'
+
'
/
/
.
.
.
\
n
'
+
'
act
(
(
)
=
>
.
.
.
)
;
'
+
'
%
s
'
getStackByFiberInDevAndProd
(
fiber
)
)
;
}
}
}
function
warnIfNotCurrentlyActingEffectsInDEV
(
fiber
)
{
{
if
(
warnsIfNotActing
=
=
=
true
&
&
(
fiber
.
mode
&
StrictMode
)
!
=
=
NoMode
&
&
IsSomeRendererActing
.
current
=
=
=
false
&
&
IsThisRendererActing
.
current
=
=
=
false
)
{
warningWithoutStack
1
(
false
'
An
update
to
%
s
ran
an
effect
but
was
not
wrapped
in
act
(
.
.
.
)
.
\
n
\
n
'
+
'
When
testing
code
that
causes
React
state
updates
should
be
'
+
'
wrapped
into
act
(
.
.
.
)
:
\
n
\
n
'
+
'
act
(
(
)
=
>
{
\
n
'
+
'
/
*
fire
events
that
update
state
*
/
\
n
'
+
'
}
)
;
\
n
'
+
'
/
*
assert
on
the
output
*
/
\
n
\
n
'
+
"
This
ensures
that
you
'
re
testing
the
behavior
the
user
would
see
"
+
'
in
the
browser
.
'
+
'
Learn
more
at
https
:
/
/
fb
.
me
/
react
-
wrap
-
tests
-
with
-
act
'
+
'
%
s
'
getComponentName
(
fiber
.
type
)
getStackByFiberInDevAndProd
(
fiber
)
)
;
}
}
}
function
warnIfNotCurrentlyActingUpdatesInDEV
(
fiber
)
{
{
if
(
warnsIfNotActing
=
=
=
true
&
&
executionContext
=
=
=
NoContext
&
&
IsSomeRendererActing
.
current
=
=
=
false
&
&
IsThisRendererActing
.
current
=
=
=
false
)
{
warningWithoutStack
1
(
false
'
An
update
to
%
s
inside
a
test
was
not
wrapped
in
act
(
.
.
.
)
.
\
n
\
n
'
+
'
When
testing
code
that
causes
React
state
updates
should
be
'
+
'
wrapped
into
act
(
.
.
.
)
:
\
n
\
n
'
+
'
act
(
(
)
=
>
{
\
n
'
+
'
/
*
fire
events
that
update
state
*
/
\
n
'
+
'
}
)
;
\
n
'
+
'
/
*
assert
on
the
output
*
/
\
n
\
n
'
+
"
This
ensures
that
you
'
re
testing
the
behavior
the
user
would
see
"
+
'
in
the
browser
.
'
+
'
Learn
more
at
https
:
/
/
fb
.
me
/
react
-
wrap
-
tests
-
with
-
act
'
+
'
%
s
'
getComponentName
(
fiber
.
type
)
getStackByFiberInDevAndProd
(
fiber
)
)
;
}
}
}
var
warnIfNotCurrentlyActingUpdatesInDev
=
warnIfNotCurrentlyActingUpdatesInDEV
;
var
didWarnAboutUnmockedScheduler
=
false
;
function
warnIfUnmockedScheduler
(
fiber
)
{
{
if
(
didWarnAboutUnmockedScheduler
=
=
=
false
&
&
unstable_flushAllWithoutAsserting
=
=
=
undefined
)
{
if
(
fiber
.
mode
&
BlockingMode
|
|
fiber
.
mode
&
ConcurrentMode
)
{
didWarnAboutUnmockedScheduler
=
true
;
warningWithoutStack
1
(
false
'
In
Concurrent
or
Sync
modes
the
"
scheduler
"
module
needs
to
be
mocked
'
+
'
to
guarantee
consistent
behaviour
across
tests
and
browsers
.
'
+
'
For
example
with
jest
:
\
n
'
+
"
jest
.
mock
(
'
scheduler
'
(
)
=
>
require
(
'
scheduler
/
unstable_mock
'
)
)
;
\
n
\
n
"
+
'
For
more
info
visit
https
:
/
/
fb
.
me
/
react
-
mock
-
scheduler
'
)
;
}
else
if
(
warnAboutUnmockedScheduler
=
=
=
true
)
{
didWarnAboutUnmockedScheduler
=
true
;
warningWithoutStack
1
(
false
'
Starting
from
React
v17
the
"
scheduler
"
module
will
need
to
be
mocked
'
+
'
to
guarantee
consistent
behaviour
across
tests
and
browsers
.
'
+
'
For
example
with
jest
:
\
n
'
+
"
jest
.
mock
(
'
scheduler
'
(
)
=
>
require
(
'
scheduler
/
unstable_mock
'
)
)
;
\
n
\
n
"
+
'
For
more
info
visit
https
:
/
/
fb
.
me
/
react
-
mock
-
scheduler
'
)
;
}
}
}
}
var
componentsThatTriggeredHighPriSuspend
=
null
;
function
checkForWrongSuspensePriorityInDEV
(
sourceFiber
)
{
{
var
currentPriorityLevel
=
getCurrentPriorityLevel
(
)
;
if
(
(
sourceFiber
.
mode
&
ConcurrentMode
)
!
=
=
NoEffect
&
&
(
currentPriorityLevel
=
=
=
UserBlockingPriority
2
|
|
currentPriorityLevel
=
=
=
ImmediatePriority
)
)
{
var
workInProgressNode
=
sourceFiber
;
while
(
workInProgressNode
!
=
=
null
)
{
var
current
1
=
workInProgressNode
.
alternate
;
if
(
current
1
!
=
=
null
)
{
switch
(
workInProgressNode
.
tag
)
{
case
ClassComponent
:
var
updateQueue
=
current
1
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
var
update
=
updateQueue
.
firstUpdate
;
while
(
update
!
=
=
null
)
{
var
priorityLevel
=
update
.
priority
;
if
(
priorityLevel
=
=
=
UserBlockingPriority
2
|
|
priorityLevel
=
=
=
ImmediatePriority
)
{
if
(
componentsThatTriggeredHighPriSuspend
=
=
=
null
)
{
componentsThatTriggeredHighPriSuspend
=
new
Set
(
[
getComponentName
(
workInProgressNode
.
type
)
]
)
;
}
else
{
componentsThatTriggeredHighPriSuspend
.
add
(
getComponentName
(
workInProgressNode
.
type
)
)
;
}
break
;
}
update
=
update
.
next
;
}
}
break
;
case
FunctionComponent
:
case
ForwardRef
:
case
SimpleMemoComponent
:
if
(
workInProgressNode
.
memoizedState
!
=
=
null
&
&
workInProgressNode
.
memoizedState
.
baseUpdate
!
=
=
null
)
{
var
_update
=
workInProgressNode
.
memoizedState
.
baseUpdate
;
while
(
_update
!
=
=
null
)
{
var
priority
=
_update
.
priority
;
if
(
priority
=
=
=
UserBlockingPriority
2
|
|
priority
=
=
=
ImmediatePriority
)
{
if
(
componentsThatTriggeredHighPriSuspend
=
=
=
null
)
{
componentsThatTriggeredHighPriSuspend
=
new
Set
(
[
getComponentName
(
workInProgressNode
.
type
)
]
)
;
}
else
{
componentsThatTriggeredHighPriSuspend
.
add
(
getComponentName
(
workInProgressNode
.
type
)
)
;
}
break
;
}
if
(
_update
.
next
=
=
=
workInProgressNode
.
memoizedState
.
baseUpdate
)
{
break
;
}
_update
=
_update
.
next
;
}
}
break
;
default
:
break
;
}
}
workInProgressNode
=
workInProgressNode
.
return
;
}
}
}
}
function
flushSuspensePriorityWarningInDEV
(
)
{
{
if
(
componentsThatTriggeredHighPriSuspend
!
=
=
null
)
{
var
componentNames
=
[
]
;
componentsThatTriggeredHighPriSuspend
.
forEach
(
function
(
name
)
{
return
componentNames
.
push
(
name
)
;
}
)
;
componentsThatTriggeredHighPriSuspend
=
null
;
if
(
componentNames
.
length
>
0
)
{
warningWithoutStack
1
(
false
'
%
s
triggered
a
user
-
blocking
update
that
suspended
.
'
+
'
\
n
\
n
'
+
'
The
fix
is
to
split
the
update
into
multiple
parts
:
a
user
-
blocking
'
+
'
update
to
provide
immediate
feedback
and
another
update
that
'
+
'
triggers
the
bulk
of
the
changes
.
'
+
'
\
n
\
n
'
+
'
Refer
to
the
documentation
for
useTransition
to
learn
how
'
+
'
to
implement
this
pattern
.
'
componentNames
.
sort
(
)
.
join
(
'
'
)
)
;
}
}
}
}
function
computeThreadID
(
root
expirationTime
)
{
return
expirationTime
*
1000
+
root
.
interactionThreadID
;
}
function
markSpawnedWork
(
expirationTime
)
{
if
(
!
enableSchedulerTracing
)
{
return
;
}
if
(
spawnedWorkDuringRender
=
=
=
null
)
{
spawnedWorkDuringRender
=
[
expirationTime
]
;
}
else
{
spawnedWorkDuringRender
.
push
(
expirationTime
)
;
}
}
function
scheduleInteractions
(
root
expirationTime
interactions
)
{
if
(
!
enableSchedulerTracing
)
{
return
;
}
if
(
interactions
.
size
>
0
)
{
var
pendingInteractionMap
=
root
.
pendingInteractionMap
;
var
pendingInteractions
=
pendingInteractionMap
.
get
(
expirationTime
)
;
if
(
pendingInteractions
!
=
null
)
{
interactions
.
forEach
(
function
(
interaction
)
{
if
(
!
pendingInteractions
.
has
(
interaction
)
)
{
interaction
.
__count
+
+
;
}
pendingInteractions
.
add
(
interaction
)
;
}
)
;
}
else
{
pendingInteractionMap
.
set
(
expirationTime
new
Set
(
interactions
)
)
;
interactions
.
forEach
(
function
(
interaction
)
{
interaction
.
__count
+
+
;
}
)
;
}
var
subscriber
=
__subscriberRef
.
current
;
if
(
subscriber
!
=
=
null
)
{
var
threadID
=
computeThreadID
(
root
expirationTime
)
;
subscriber
.
onWorkScheduled
(
interactions
threadID
)
;
}
}
}
function
schedulePendingInteractions
(
root
expirationTime
)
{
if
(
!
enableSchedulerTracing
)
{
return
;
}
scheduleInteractions
(
root
expirationTime
__interactionsRef
.
current
)
;
}
function
startWorkOnPendingInteractions
(
root
expirationTime
)
{
if
(
!
enableSchedulerTracing
)
{
return
;
}
var
interactions
=
new
Set
(
)
;
root
.
pendingInteractionMap
.
forEach
(
function
(
scheduledInteractions
scheduledExpirationTime
)
{
if
(
scheduledExpirationTime
>
=
expirationTime
)
{
scheduledInteractions
.
forEach
(
function
(
interaction
)
{
return
interactions
.
add
(
interaction
)
;
}
)
;
}
}
)
;
root
.
memoizedInteractions
=
interactions
;
if
(
interactions
.
size
>
0
)
{
var
subscriber
=
__subscriberRef
.
current
;
if
(
subscriber
!
=
=
null
)
{
var
threadID
=
computeThreadID
(
root
expirationTime
)
;
try
{
subscriber
.
onWorkStarted
(
interactions
threadID
)
;
}
catch
(
error
)
{
scheduleCallback
(
ImmediatePriority
function
(
)
{
throw
error
;
}
)
;
}
}
}
}
function
finishPendingInteractions
(
root
committedExpirationTime
)
{
if
(
!
enableSchedulerTracing
)
{
return
;
}
var
earliestRemainingTimeAfterCommit
=
root
.
firstPendingTime
;
var
subscriber
;
try
{
subscriber
=
__subscriberRef
.
current
;
if
(
subscriber
!
=
=
null
&
&
root
.
memoizedInteractions
.
size
>
0
)
{
var
threadID
=
computeThreadID
(
root
committedExpirationTime
)
;
subscriber
.
onWorkStopped
(
root
.
memoizedInteractions
threadID
)
;
}
}
catch
(
error
)
{
scheduleCallback
(
ImmediatePriority
function
(
)
{
throw
error
;
}
)
;
}
finally
{
var
pendingInteractionMap
=
root
.
pendingInteractionMap
;
pendingInteractionMap
.
forEach
(
function
(
scheduledInteractions
scheduledExpirationTime
)
{
if
(
scheduledExpirationTime
>
earliestRemainingTimeAfterCommit
)
{
pendingInteractionMap
.
delete
(
scheduledExpirationTime
)
;
scheduledInteractions
.
forEach
(
function
(
interaction
)
{
interaction
.
__count
-
-
;
if
(
subscriber
!
=
=
null
&
&
interaction
.
__count
=
=
=
0
)
{
try
{
subscriber
.
onInteractionScheduledWorkCompleted
(
interaction
)
;
}
catch
(
error
)
{
scheduleCallback
(
ImmediatePriority
function
(
)
{
throw
error
;
}
)
;
}
}
}
)
;
}
}
)
;
}
}
var
onCommitFiberRoot
=
null
;
var
onCommitFiberUnmount
=
null
;
var
hasLoggedError
=
false
;
var
isDevToolsPresent
=
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
!
=
=
'
undefined
'
;
function
injectInternals
(
internals
)
{
if
(
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
=
=
=
'
undefined
'
)
{
return
false
;
}
var
hook
=
__REACT_DEVTOOLS_GLOBAL_HOOK__
;
if
(
hook
.
isDisabled
)
{
return
true
;
}
if
(
!
hook
.
supportsFiber
)
{
{
warningWithoutStack
1
(
false
'
The
installed
version
of
React
DevTools
is
too
old
and
will
not
work
'
+
'
with
the
current
version
of
React
.
Please
update
React
DevTools
.
'
+
'
https
:
/
/
fb
.
me
/
react
-
devtools
'
)
;
}
return
true
;
}
try
{
var
rendererID
=
hook
.
inject
(
internals
)
;
onCommitFiberRoot
=
function
(
root
expirationTime
)
{
try
{
var
didError
=
(
root
.
current
.
effectTag
&
DidCapture
)
=
=
=
DidCapture
;
if
(
enableProfilerTimer
)
{
var
currentTime
=
getCurrentTime
(
)
;
var
priorityLevel
=
inferPriorityFromExpirationTime
(
currentTime
expirationTime
)
;
hook
.
onCommitFiberRoot
(
rendererID
root
priorityLevel
didError
)
;
}
else
{
hook
.
onCommitFiberRoot
(
rendererID
root
undefined
didError
)
;
}
}
catch
(
err
)
{
if
(
true
&
&
!
hasLoggedError
)
{
hasLoggedError
=
true
;
warningWithoutStack
1
(
false
'
React
DevTools
encountered
an
error
:
%
s
'
err
)
;
}
}
}
;
onCommitFiberUnmount
=
function
(
fiber
)
{
try
{
hook
.
onCommitFiberUnmount
(
rendererID
fiber
)
;
}
catch
(
err
)
{
if
(
true
&
&
!
hasLoggedError
)
{
hasLoggedError
=
true
;
warningWithoutStack
1
(
false
'
React
DevTools
encountered
an
error
:
%
s
'
err
)
;
}
}
}
;
}
catch
(
err
)
{
{
warningWithoutStack
1
(
false
'
React
DevTools
encountered
an
error
:
%
s
.
'
err
)
;
}
}
return
true
;
}
function
onCommitRoot
(
root
expirationTime
)
{
if
(
typeof
onCommitFiberRoot
=
=
=
'
function
'
)
{
onCommitFiberRoot
(
root
expirationTime
)
;
}
}
function
onCommitUnmount
(
fiber
)
{
if
(
typeof
onCommitFiberUnmount
=
=
=
'
function
'
)
{
onCommitFiberUnmount
(
fiber
)
;
}
}
var
hasBadMapPolyfill
;
{
hasBadMapPolyfill
=
false
;
try
{
var
nonExtensibleObject
=
Object
.
preventExtensions
(
{
}
)
;
var
testMap
=
new
Map
(
[
[
nonExtensibleObject
null
]
]
)
;
var
testSet
=
new
Set
(
[
nonExtensibleObject
]
)
;
testMap
.
set
(
0
0
)
;
testSet
.
add
(
0
)
;
}
catch
(
e
)
{
hasBadMapPolyfill
=
true
;
}
}
var
debugCounter
=
1
;
function
FiberNode
(
tag
pendingProps
key
mode
)
{
this
.
tag
=
tag
;
this
.
key
=
key
;
this
.
elementType
=
null
;
this
.
type
=
null
;
this
.
stateNode
=
null
;
this
.
return
=
null
;
this
.
child
=
null
;
this
.
sibling
=
null
;
this
.
index
=
0
;
this
.
ref
=
null
;
this
.
pendingProps
=
pendingProps
;
this
.
memoizedProps
=
null
;
this
.
updateQueue
=
null
;
this
.
memoizedState
=
null
;
this
.
dependencies
=
null
;
this
.
mode
=
mode
;
this
.
effectTag
=
NoEffect
;
this
.
nextEffect
=
null
;
this
.
firstEffect
=
null
;
this
.
lastEffect
=
null
;
this
.
expirationTime
=
NoWork
;
this
.
childExpirationTime
=
NoWork
;
this
.
alternate
=
null
;
if
(
enableProfilerTimer
)
{
this
.
actualDuration
=
Number
.
NaN
;
this
.
actualStartTime
=
Number
.
NaN
;
this
.
selfBaseDuration
=
Number
.
NaN
;
this
.
treeBaseDuration
=
Number
.
NaN
;
this
.
actualDuration
=
0
;
this
.
actualStartTime
=
-
1
;
this
.
selfBaseDuration
=
0
;
this
.
treeBaseDuration
=
0
;
}
if
(
enableUserTimingAPI
)
{
this
.
_debugID
=
debugCounter
+
+
;
this
.
_debugIsCurrentlyTiming
=
false
;
}
{
this
.
_debugSource
=
null
;
this
.
_debugOwner
=
null
;
this
.
_debugNeedsRemount
=
false
;
this
.
_debugHookTypes
=
null
;
if
(
!
hasBadMapPolyfill
&
&
typeof
Object
.
preventExtensions
=
=
=
'
function
'
)
{
Object
.
preventExtensions
(
this
)
;
}
}
}
var
createFiber
=
function
(
tag
pendingProps
key
mode
)
{
return
new
FiberNode
(
tag
pendingProps
key
mode
)
;
}
;
function
shouldConstruct
(
Component
)
{
var
prototype
=
Component
.
prototype
;
return
!
!
(
prototype
&
&
prototype
.
isReactComponent
)
;
}
function
isSimpleFunctionComponent
(
type
)
{
return
typeof
type
=
=
=
'
function
'
&
&
!
shouldConstruct
(
type
)
&
&
type
.
defaultProps
=
=
=
undefined
;
}
function
resolveLazyComponentTag
(
Component
)
{
if
(
typeof
Component
=
=
=
'
function
'
)
{
return
shouldConstruct
(
Component
)
?
ClassComponent
:
FunctionComponent
;
}
else
if
(
Component
!
=
=
undefined
&
&
Component
!
=
=
null
)
{
var
typeof
=
Component
.
typeof
;
if
(
typeof
=
=
=
REACT_FORWARD_REF_TYPE
)
{
return
ForwardRef
;
}
if
(
typeof
=
=
=
REACT_MEMO_TYPE
)
{
return
MemoComponent
;
}
}
return
IndeterminateComponent
;
}
function
createWorkInProgress
(
current
pendingProps
expirationTime
)
{
var
workInProgress
=
current
.
alternate
;
if
(
workInProgress
=
=
=
null
)
{
workInProgress
=
createFiber
(
current
.
tag
pendingProps
current
.
key
current
.
mode
)
;
workInProgress
.
elementType
=
current
.
elementType
;
workInProgress
.
type
=
current
.
type
;
workInProgress
.
stateNode
=
current
.
stateNode
;
{
workInProgress
.
_debugID
=
current
.
_debugID
;
workInProgress
.
_debugSource
=
current
.
_debugSource
;
workInProgress
.
_debugOwner
=
current
.
_debugOwner
;
workInProgress
.
_debugHookTypes
=
current
.
_debugHookTypes
;
}
workInProgress
.
alternate
=
current
;
current
.
alternate
=
workInProgress
;
}
else
{
workInProgress
.
pendingProps
=
pendingProps
;
workInProgress
.
effectTag
=
NoEffect
;
workInProgress
.
nextEffect
=
null
;
workInProgress
.
firstEffect
=
null
;
workInProgress
.
lastEffect
=
null
;
if
(
enableProfilerTimer
)
{
workInProgress
.
actualDuration
=
0
;
workInProgress
.
actualStartTime
=
-
1
;
}
}
workInProgress
.
childExpirationTime
=
current
.
childExpirationTime
;
workInProgress
.
expirationTime
=
current
.
expirationTime
;
workInProgress
.
child
=
current
.
child
;
workInProgress
.
memoizedProps
=
current
.
memoizedProps
;
workInProgress
.
memoizedState
=
current
.
memoizedState
;
workInProgress
.
updateQueue
=
current
.
updateQueue
;
var
currentDependencies
=
current
.
dependencies
;
workInProgress
.
dependencies
=
currentDependencies
=
=
=
null
?
null
:
{
expirationTime
:
currentDependencies
.
expirationTime
firstContext
:
currentDependencies
.
firstContext
responders
:
currentDependencies
.
responders
}
;
workInProgress
.
sibling
=
current
.
sibling
;
workInProgress
.
index
=
current
.
index
;
workInProgress
.
ref
=
current
.
ref
;
if
(
enableProfilerTimer
)
{
workInProgress
.
selfBaseDuration
=
current
.
selfBaseDuration
;
workInProgress
.
treeBaseDuration
=
current
.
treeBaseDuration
;
}
{
workInProgress
.
_debugNeedsRemount
=
current
.
_debugNeedsRemount
;
switch
(
workInProgress
.
tag
)
{
case
IndeterminateComponent
:
case
FunctionComponent
:
case
SimpleMemoComponent
:
workInProgress
.
type
=
resolveFunctionForHotReloading
(
current
.
type
)
;
break
;
case
ClassComponent
:
workInProgress
.
type
=
resolveClassForHotReloading
(
current
.
type
)
;
break
;
case
ForwardRef
:
workInProgress
.
type
=
resolveForwardRefForHotReloading
(
current
.
type
)
;
break
;
default
:
break
;
}
}
return
workInProgress
;
}
function
resetWorkInProgress
(
workInProgress
renderExpirationTime
)
{
workInProgress
.
effectTag
&
=
Placement
;
workInProgress
.
nextEffect
=
null
;
workInProgress
.
firstEffect
=
null
;
workInProgress
.
lastEffect
=
null
;
var
current
=
workInProgress
.
alternate
;
if
(
current
=
=
=
null
)
{
workInProgress
.
childExpirationTime
=
NoWork
;
workInProgress
.
expirationTime
=
renderExpirationTime
;
workInProgress
.
child
=
null
;
workInProgress
.
memoizedProps
=
null
;
workInProgress
.
memoizedState
=
null
;
workInProgress
.
updateQueue
=
null
;
workInProgress
.
dependencies
=
null
;
if
(
enableProfilerTimer
)
{
workInProgress
.
selfBaseDuration
=
0
;
workInProgress
.
treeBaseDuration
=
0
;
}
}
else
{
workInProgress
.
childExpirationTime
=
current
.
childExpirationTime
;
workInProgress
.
expirationTime
=
current
.
expirationTime
;
workInProgress
.
child
=
current
.
child
;
workInProgress
.
memoizedProps
=
current
.
memoizedProps
;
workInProgress
.
memoizedState
=
current
.
memoizedState
;
workInProgress
.
updateQueue
=
current
.
updateQueue
;
var
currentDependencies
=
current
.
dependencies
;
workInProgress
.
dependencies
=
currentDependencies
=
=
=
null
?
null
:
{
expirationTime
:
currentDependencies
.
expirationTime
firstContext
:
currentDependencies
.
firstContext
responders
:
currentDependencies
.
responders
}
;
if
(
enableProfilerTimer
)
{
workInProgress
.
selfBaseDuration
=
current
.
selfBaseDuration
;
workInProgress
.
treeBaseDuration
=
current
.
treeBaseDuration
;
}
}
return
workInProgress
;
}
function
createHostRootFiber
(
tag
)
{
var
mode
;
if
(
tag
=
=
=
ConcurrentRoot
)
{
mode
=
ConcurrentMode
|
BlockingMode
|
StrictMode
;
}
else
if
(
tag
=
=
=
BlockingRoot
)
{
mode
=
BlockingMode
|
StrictMode
;
}
else
{
mode
=
NoMode
;
}
if
(
enableProfilerTimer
&
&
isDevToolsPresent
)
{
mode
|
=
ProfileMode
;
}
return
createFiber
(
HostRoot
null
null
mode
)
;
}
function
createFiberFromTypeAndProps
(
type
key
pendingProps
owner
mode
expirationTime
)
{
var
fiber
;
var
fiberTag
=
IndeterminateComponent
;
var
resolvedType
=
type
;
if
(
typeof
type
=
=
=
'
function
'
)
{
if
(
shouldConstruct
(
type
)
)
{
fiberTag
=
ClassComponent
;
{
resolvedType
=
resolveClassForHotReloading
(
resolvedType
)
;
}
}
else
{
{
resolvedType
=
resolveFunctionForHotReloading
(
resolvedType
)
;
}
}
}
else
if
(
typeof
type
=
=
=
'
string
'
)
{
fiberTag
=
HostComponent
;
}
else
{
getTag
:
switch
(
type
)
{
case
REACT_FRAGMENT_TYPE
:
return
createFiberFromFragment
(
pendingProps
.
children
mode
expirationTime
key
)
;
case
REACT_CONCURRENT_MODE_TYPE
:
fiberTag
=
Mode
;
mode
|
=
ConcurrentMode
|
BlockingMode
|
StrictMode
;
break
;
case
REACT_STRICT_MODE_TYPE
:
fiberTag
=
Mode
;
mode
|
=
StrictMode
;
break
;
case
REACT_PROFILER_TYPE
:
return
createFiberFromProfiler
(
pendingProps
mode
expirationTime
key
)
;
case
REACT_SUSPENSE_TYPE
:
return
createFiberFromSuspense
(
pendingProps
mode
expirationTime
key
)
;
case
REACT_SUSPENSE_LIST_TYPE
:
return
createFiberFromSuspenseList
(
pendingProps
mode
expirationTime
key
)
;
default
:
{
if
(
typeof
type
=
=
=
'
object
'
&
&
type
!
=
=
null
)
{
switch
(
type
.
typeof
)
{
case
REACT_PROVIDER_TYPE
:
fiberTag
=
ContextProvider
;
break
getTag
;
case
REACT_CONTEXT_TYPE
:
fiberTag
=
ContextConsumer
;
break
getTag
;
case
REACT_FORWARD_REF_TYPE
:
fiberTag
=
ForwardRef
;
{
resolvedType
=
resolveForwardRefForHotReloading
(
resolvedType
)
;
}
break
getTag
;
case
REACT_MEMO_TYPE
:
fiberTag
=
MemoComponent
;
break
getTag
;
case
REACT_LAZY_TYPE
:
fiberTag
=
LazyComponent
;
resolvedType
=
null
;
break
getTag
;
case
REACT_FUNDAMENTAL_TYPE
:
if
(
enableFundamentalAPI
)
{
return
createFiberFromFundamental
(
type
pendingProps
mode
expirationTime
key
)
;
}
break
;
case
REACT_SCOPE_TYPE
:
if
(
enableScopeAPI
)
{
return
createFiberFromScope
(
type
pendingProps
mode
expirationTime
key
)
;
}
}
}
var
info
=
'
'
;
{
if
(
type
=
=
=
undefined
|
|
typeof
type
=
=
=
'
object
'
&
&
type
!
=
=
null
&
&
Object
.
keys
(
type
)
.
length
=
=
=
0
)
{
info
+
=
'
You
likely
forgot
to
export
your
component
from
the
file
'
+
"
it
'
s
defined
in
or
you
might
have
mixed
up
default
and
"
+
'
named
imports
.
'
;
}
var
ownerName
=
owner
?
getComponentName
(
owner
.
type
)
:
null
;
if
(
ownerName
)
{
info
+
=
'
\
n
\
nCheck
the
render
method
of
'
+
ownerName
+
'
.
'
;
}
}
{
{
throw
Error
(
"
Element
type
is
invalid
:
expected
a
string
(
for
built
-
in
components
)
or
a
class
/
function
(
for
composite
components
)
but
got
:
"
+
(
type
=
=
null
?
type
:
typeof
type
)
+
"
.
"
+
info
)
;
}
}
}
}
}
fiber
=
createFiber
(
fiberTag
pendingProps
key
mode
)
;
fiber
.
elementType
=
type
;
fiber
.
type
=
resolvedType
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromElement
(
element
mode
expirationTime
)
{
var
owner
=
null
;
{
owner
=
element
.
_owner
;
}
var
type
=
element
.
type
;
var
key
=
element
.
key
;
var
pendingProps
=
element
.
props
;
var
fiber
=
createFiberFromTypeAndProps
(
type
key
pendingProps
owner
mode
expirationTime
)
;
{
fiber
.
_debugSource
=
element
.
_source
;
fiber
.
_debugOwner
=
element
.
_owner
;
}
return
fiber
;
}
function
createFiberFromFragment
(
elements
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
Fragment
elements
key
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromFundamental
(
fundamentalComponent
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
FundamentalComponent
pendingProps
key
mode
)
;
fiber
.
elementType
=
fundamentalComponent
;
fiber
.
type
=
fundamentalComponent
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromScope
(
scope
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
ScopeComponent
pendingProps
key
mode
)
;
fiber
.
type
=
scope
;
fiber
.
elementType
=
scope
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromProfiler
(
pendingProps
mode
expirationTime
key
)
{
{
if
(
typeof
pendingProps
.
id
!
=
=
'
string
'
|
|
typeof
pendingProps
.
onRender
!
=
=
'
function
'
)
{
warningWithoutStack
1
(
false
'
Profiler
must
specify
an
"
id
"
string
and
"
onRender
"
function
as
props
'
)
;
}
}
var
fiber
=
createFiber
(
Profiler
pendingProps
key
mode
|
ProfileMode
)
;
fiber
.
elementType
=
REACT_PROFILER_TYPE
;
fiber
.
type
=
REACT_PROFILER_TYPE
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromSuspense
(
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
SuspenseComponent
pendingProps
key
mode
)
;
fiber
.
type
=
REACT_SUSPENSE_TYPE
;
fiber
.
elementType
=
REACT_SUSPENSE_TYPE
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromSuspenseList
(
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
SuspenseListComponent
pendingProps
key
mode
)
;
{
fiber
.
type
=
REACT_SUSPENSE_LIST_TYPE
;
}
fiber
.
elementType
=
REACT_SUSPENSE_LIST_TYPE
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromText
(
content
mode
expirationTime
)
{
var
fiber
=
createFiber
(
HostText
content
null
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromHostInstanceForDeletion
(
)
{
var
fiber
=
createFiber
(
HostComponent
null
null
NoMode
)
;
fiber
.
elementType
=
'
DELETED
'
;
fiber
.
type
=
'
DELETED
'
;
return
fiber
;
}
function
createFiberFromDehydratedFragment
(
dehydratedNode
)
{
var
fiber
=
createFiber
(
DehydratedFragment
null
null
NoMode
)
;
fiber
.
stateNode
=
dehydratedNode
;
return
fiber
;
}
function
createFiberFromPortal
(
portal
mode
expirationTime
)
{
var
pendingProps
=
portal
.
children
!
=
=
null
?
portal
.
children
:
[
]
;
var
fiber
=
createFiber
(
HostPortal
pendingProps
portal
.
key
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
fiber
.
stateNode
=
{
containerInfo
:
portal
.
containerInfo
pendingChildren
:
null
implementation
:
portal
.
implementation
}
;
return
fiber
;
}
function
assignFiberPropertiesInDEV
(
target
source
)
{
if
(
target
=
=
=
null
)
{
target
=
createFiber
(
IndeterminateComponent
null
null
NoMode
)
;
}
target
.
tag
=
source
.
tag
;
target
.
key
=
source
.
key
;
target
.
elementType
=
source
.
elementType
;
target
.
type
=
source
.
type
;
target
.
stateNode
=
source
.
stateNode
;
target
.
return
=
source
.
return
;
target
.
child
=
source
.
child
;
target
.
sibling
=
source
.
sibling
;
target
.
index
=
source
.
index
;
target
.
ref
=
source
.
ref
;
target
.
pendingProps
=
source
.
pendingProps
;
target
.
memoizedProps
=
source
.
memoizedProps
;
target
.
updateQueue
=
source
.
updateQueue
;
target
.
memoizedState
=
source
.
memoizedState
;
target
.
dependencies
=
source
.
dependencies
;
target
.
mode
=
source
.
mode
;
target
.
effectTag
=
source
.
effectTag
;
target
.
nextEffect
=
source
.
nextEffect
;
target
.
firstEffect
=
source
.
firstEffect
;
target
.
lastEffect
=
source
.
lastEffect
;
target
.
expirationTime
=
source
.
expirationTime
;
target
.
childExpirationTime
=
source
.
childExpirationTime
;
target
.
alternate
=
source
.
alternate
;
if
(
enableProfilerTimer
)
{
target
.
actualDuration
=
source
.
actualDuration
;
target
.
actualStartTime
=
source
.
actualStartTime
;
target
.
selfBaseDuration
=
source
.
selfBaseDuration
;
target
.
treeBaseDuration
=
source
.
treeBaseDuration
;
}
target
.
_debugID
=
source
.
_debugID
;
target
.
_debugSource
=
source
.
_debugSource
;
target
.
_debugOwner
=
source
.
_debugOwner
;
target
.
_debugIsCurrentlyTiming
=
source
.
_debugIsCurrentlyTiming
;
target
.
_debugNeedsRemount
=
source
.
_debugNeedsRemount
;
target
.
_debugHookTypes
=
source
.
_debugHookTypes
;
return
target
;
}
function
FiberRootNode
(
containerInfo
tag
hydrate
)
{
this
.
tag
=
tag
;
this
.
current
=
null
;
this
.
containerInfo
=
containerInfo
;
this
.
pendingChildren
=
null
;
this
.
pingCache
=
null
;
this
.
finishedExpirationTime
=
NoWork
;
this
.
finishedWork
=
null
;
this
.
timeoutHandle
=
noTimeout
;
this
.
context
=
null
;
this
.
pendingContext
=
null
;
this
.
hydrate
=
hydrate
;
this
.
callbackNode
=
null
;
this
.
callbackPriority
=
NoPriority
;
this
.
firstPendingTime
=
NoWork
;
this
.
firstSuspendedTime
=
NoWork
;
this
.
lastSuspendedTime
=
NoWork
;
this
.
nextKnownPendingLevel
=
NoWork
;
this
.
lastPingedTime
=
NoWork
;
this
.
lastExpiredTime
=
NoWork
;
if
(
enableSchedulerTracing
)
{
this
.
interactionThreadID
=
unstable_getThreadID
(
)
;
this
.
memoizedInteractions
=
new
Set
(
)
;
this
.
pendingInteractionMap
=
new
Map
(
)
;
}
if
(
enableSuspenseCallback
)
{
this
.
hydrationCallbacks
=
null
;
}
}
function
createFiberRoot
(
containerInfo
tag
hydrate
hydrationCallbacks
)
{
var
root
=
new
FiberRootNode
(
containerInfo
tag
hydrate
)
;
if
(
enableSuspenseCallback
)
{
root
.
hydrationCallbacks
=
hydrationCallbacks
;
}
var
uninitializedFiber
=
createHostRootFiber
(
tag
)
;
root
.
current
=
uninitializedFiber
;
uninitializedFiber
.
stateNode
=
root
;
return
root
;
}
function
isRootSuspendedAtTime
(
root
expirationTime
)
{
var
firstSuspendedTime
=
root
.
firstSuspendedTime
;
var
lastSuspendedTime
=
root
.
lastSuspendedTime
;
return
firstSuspendedTime
!
=
=
NoWork
&
&
firstSuspendedTime
>
=
expirationTime
&
&
lastSuspendedTime
<
=
expirationTime
;
}
function
markRootSuspendedAtTime
(
root
expirationTime
)
{
var
firstSuspendedTime
=
root
.
firstSuspendedTime
;
var
lastSuspendedTime
=
root
.
lastSuspendedTime
;
if
(
firstSuspendedTime
<
expirationTime
)
{
root
.
firstSuspendedTime
=
expirationTime
;
}
if
(
lastSuspendedTime
>
expirationTime
|
|
firstSuspendedTime
=
=
=
NoWork
)
{
root
.
lastSuspendedTime
=
expirationTime
;
}
if
(
expirationTime
<
=
root
.
lastPingedTime
)
{
root
.
lastPingedTime
=
NoWork
;
}
if
(
expirationTime
<
=
root
.
lastExpiredTime
)
{
root
.
lastExpiredTime
=
NoWork
;
}
}
function
markRootUpdatedAtTime
(
root
expirationTime
)
{
var
firstPendingTime
=
root
.
firstPendingTime
;
if
(
expirationTime
>
firstPendingTime
)
{
root
.
firstPendingTime
=
expirationTime
;
}
var
firstSuspendedTime
=
root
.
firstSuspendedTime
;
if
(
firstSuspendedTime
!
=
=
NoWork
)
{
if
(
expirationTime
>
=
firstSuspendedTime
)
{
root
.
firstSuspendedTime
=
root
.
lastSuspendedTime
=
root
.
nextKnownPendingLevel
=
NoWork
;
}
else
if
(
expirationTime
>
=
root
.
lastSuspendedTime
)
{
root
.
lastSuspendedTime
=
expirationTime
+
1
;
}
if
(
expirationTime
>
root
.
nextKnownPendingLevel
)
{
root
.
nextKnownPendingLevel
=
expirationTime
;
}
}
}
function
markRootFinishedAtTime
(
root
finishedExpirationTime
remainingExpirationTime
)
{
root
.
firstPendingTime
=
remainingExpirationTime
;
if
(
finishedExpirationTime
<
=
root
.
lastSuspendedTime
)
{
root
.
firstSuspendedTime
=
root
.
lastSuspendedTime
=
root
.
nextKnownPendingLevel
=
NoWork
;
}
else
if
(
finishedExpirationTime
<
=
root
.
firstSuspendedTime
)
{
root
.
firstSuspendedTime
=
finishedExpirationTime
-
1
;
}
if
(
finishedExpirationTime
<
=
root
.
lastPingedTime
)
{
root
.
lastPingedTime
=
NoWork
;
}
if
(
finishedExpirationTime
<
=
root
.
lastExpiredTime
)
{
root
.
lastExpiredTime
=
NoWork
;
}
}
function
markRootExpiredAtTime
(
root
expirationTime
)
{
var
lastExpiredTime
=
root
.
lastExpiredTime
;
if
(
lastExpiredTime
=
=
=
NoWork
|
|
lastExpiredTime
>
expirationTime
)
{
root
.
lastExpiredTime
=
expirationTime
;
}
}
var
ReactFiberInstrumentation
=
{
debugTool
:
null
}
;
var
ReactFiberInstrumentation_1
=
ReactFiberInstrumentation
;
var
didWarnAboutNestedUpdates
;
var
didWarnAboutFindNodeInStrictMode
;
{
didWarnAboutNestedUpdates
=
false
;
didWarnAboutFindNodeInStrictMode
=
{
}
;
}
function
getContextForSubtree
(
parentComponent
)
{
if
(
!
parentComponent
)
{
return
emptyContextObject
;
}
var
fiber
=
get
(
parentComponent
)
;
var
parentContext
=
findCurrentUnmaskedContext
(
fiber
)
;
if
(
fiber
.
tag
=
=
=
ClassComponent
)
{
var
Component
=
fiber
.
type
;
if
(
isContextProvider
(
Component
)
)
{
return
processChildContext
(
fiber
Component
parentContext
)
;
}
}
return
parentContext
;
}
function
findHostInstance
(
component
)
{
var
fiber
=
get
(
component
)
;
if
(
fiber
=
=
=
undefined
)
{
if
(
typeof
component
.
render
=
=
=
'
function
'
)
{
{
{
throw
Error
(
"
Unable
to
find
node
on
an
unmounted
component
.
"
)
;
}
}
}
else
{
{
{
throw
Error
(
"
Argument
appears
to
not
be
a
ReactComponent
.
Keys
:
"
+
Object
.
keys
(
component
)
)
;
}
}
}
}
var
hostFiber
=
findCurrentHostFiber
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
function
findHostInstanceWithWarning
(
component
methodName
)
{
{
var
fiber
=
get
(
component
)
;
if
(
fiber
=
=
=
undefined
)
{
if
(
typeof
component
.
render
=
=
=
'
function
'
)
{
{
{
throw
Error
(
"
Unable
to
find
node
on
an
unmounted
component
.
"
)
;
}
}
}
else
{
{
{
throw
Error
(
"
Argument
appears
to
not
be
a
ReactComponent
.
Keys
:
"
+
Object
.
keys
(
component
)
)
;
}
}
}
}
var
hostFiber
=
findCurrentHostFiber
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
if
(
hostFiber
.
mode
&
StrictMode
)
{
var
componentName
=
getComponentName
(
fiber
.
type
)
|
|
'
Component
'
;
if
(
!
didWarnAboutFindNodeInStrictMode
[
componentName
]
)
{
didWarnAboutFindNodeInStrictMode
[
componentName
]
=
true
;
if
(
fiber
.
mode
&
StrictMode
)
{
warningWithoutStack
1
(
false
'
%
s
is
deprecated
in
StrictMode
.
'
+
'
%
s
was
passed
an
instance
of
%
s
which
is
inside
StrictMode
.
'
+
'
Instead
add
a
ref
directly
to
the
element
you
want
to
reference
.
'
+
'
Learn
more
about
using
refs
safely
here
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
strict
-
mode
-
find
-
node
%
s
'
methodName
methodName
componentName
getStackByFiberInDevAndProd
(
hostFiber
)
)
;
}
else
{
warningWithoutStack
1
(
false
'
%
s
is
deprecated
in
StrictMode
.
'
+
'
%
s
was
passed
an
instance
of
%
s
which
renders
StrictMode
children
.
'
+
'
Instead
add
a
ref
directly
to
the
element
you
want
to
reference
.
'
+
'
Learn
more
about
using
refs
safely
here
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
strict
-
mode
-
find
-
node
%
s
'
methodName
methodName
componentName
getStackByFiberInDevAndProd
(
hostFiber
)
)
;
}
}
}
return
hostFiber
.
stateNode
;
}
return
findHostInstance
(
component
)
;
}
function
createContainer
(
containerInfo
tag
hydrate
hydrationCallbacks
)
{
return
createFiberRoot
(
containerInfo
tag
hydrate
hydrationCallbacks
)
;
}
function
updateContainer
(
element
container
parentComponent
callback
)
{
var
current
1
=
container
.
current
;
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
{
if
(
'
undefined
'
!
=
=
typeof
jest
)
{
warnIfUnmockedScheduler
(
current
1
)
;
warnIfNotScopedWithMatchingAct
(
current
1
)
;
}
}
var
suspenseConfig
=
requestCurrentSuspenseConfig
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
current
1
suspenseConfig
)
;
{
if
(
ReactFiberInstrumentation_1
.
debugTool
)
{
if
(
current
1
.
alternate
=
=
=
null
)
{
ReactFiberInstrumentation_1
.
debugTool
.
onMountContainer
(
container
)
;
}
else
if
(
element
=
=
=
null
)
{
ReactFiberInstrumentation_1
.
debugTool
.
onUnmountContainer
(
container
)
;
}
else
{
ReactFiberInstrumentation_1
.
debugTool
.
onUpdateContainer
(
container
)
;
}
}
}
var
context
=
getContextForSubtree
(
parentComponent
)
;
if
(
container
.
context
=
=
=
null
)
{
container
.
context
=
context
;
}
else
{
container
.
pendingContext
=
context
;
}
{
if
(
phase
=
=
=
'
render
'
&
&
current
!
=
=
null
&
&
!
didWarnAboutNestedUpdates
)
{
didWarnAboutNestedUpdates
=
true
;
warningWithoutStack
1
(
false
'
Render
methods
should
be
a
pure
function
of
props
and
state
;
'
+
'
triggering
nested
component
updates
from
render
is
not
allowed
.
'
+
'
If
necessary
trigger
nested
updates
in
componentDidUpdate
.
\
n
\
n
'
+
'
Check
the
render
method
of
%
s
.
'
getComponentName
(
current
.
type
)
|
|
'
Unknown
'
)
;
}
}
var
update
=
createUpdate
(
expirationTime
suspenseConfig
)
;
update
.
payload
=
{
element
:
element
}
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
!
(
typeof
callback
=
=
=
'
function
'
)
?
warningWithoutStack
1
(
false
'
render
(
.
.
.
)
:
Expected
the
last
optional
callback
argument
to
be
a
'
+
'
function
.
Instead
received
:
%
s
.
'
callback
)
:
void
0
;
update
.
callback
=
callback
;
}
enqueueUpdate
(
current
1
update
)
;
scheduleWork
(
current
1
expirationTime
)
;
return
expirationTime
;
}
function
getPublicRootInstance
(
container
)
{
var
containerFiber
=
container
.
current
;
if
(
!
containerFiber
.
child
)
{
return
null
;
}
switch
(
containerFiber
.
child
.
tag
)
{
case
HostComponent
:
return
getPublicInstance
(
containerFiber
.
child
.
stateNode
)
;
default
:
return
containerFiber
.
child
.
stateNode
;
}
}
function
attemptSynchronousHydration
1
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
HostRoot
:
var
root
=
fiber
.
stateNode
;
if
(
root
.
hydrate
)
{
flushRoot
(
root
root
.
firstPendingTime
)
;
}
break
;
case
SuspenseComponent
:
flushSync
(
function
(
)
{
return
scheduleWork
(
fiber
Sync
)
;
}
)
;
var
retryExpTime
=
computeInteractiveExpiration
(
requestCurrentTimeForUpdate
(
)
)
;
markRetryTimeIfNotHydrated
(
fiber
retryExpTime
)
;
break
;
}
}
function
markRetryTimeImpl
(
fiber
retryTime
)
{
var
suspenseState
=
fiber
.
memoizedState
;
if
(
suspenseState
!
=
=
null
&
&
suspenseState
.
dehydrated
!
=
=
null
)
{
if
(
suspenseState
.
retryTime
<
retryTime
)
{
suspenseState
.
retryTime
=
retryTime
;
}
}
}
function
markRetryTimeIfNotHydrated
(
fiber
retryTime
)
{
markRetryTimeImpl
(
fiber
retryTime
)
;
var
alternate
=
fiber
.
alternate
;
if
(
alternate
)
{
markRetryTimeImpl
(
alternate
retryTime
)
;
}
}
function
attemptUserBlockingHydration
1
(
fiber
)
{
if
(
fiber
.
tag
!
=
=
SuspenseComponent
)
{
return
;
}
var
expTime
=
computeInteractiveExpiration
(
requestCurrentTimeForUpdate
(
)
)
;
scheduleWork
(
fiber
expTime
)
;
markRetryTimeIfNotHydrated
(
fiber
expTime
)
;
}
function
attemptContinuousHydration
1
(
fiber
)
{
if
(
fiber
.
tag
!
=
=
SuspenseComponent
)
{
return
;
}
var
expTime
=
computeContinuousHydrationExpiration
(
requestCurrentTimeForUpdate
(
)
)
;
scheduleWork
(
fiber
expTime
)
;
markRetryTimeIfNotHydrated
(
fiber
expTime
)
;
}
function
attemptHydrationAtCurrentPriority
1
(
fiber
)
{
if
(
fiber
.
tag
!
=
=
SuspenseComponent
)
{
return
;
}
var
currentTime
=
requestCurrentTimeForUpdate
(
)
;
var
expTime
=
computeExpirationForFiber
(
currentTime
fiber
null
)
;
scheduleWork
(
fiber
expTime
)
;
markRetryTimeIfNotHydrated
(
fiber
expTime
)
;
}
function
findHostInstanceWithNoPortals
(
fiber
)
{
var
hostFiber
=
findCurrentHostFiberWithNoPortals
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
if
(
hostFiber
.
tag
=
=
=
FundamentalComponent
)
{
return
hostFiber
.
stateNode
.
instance
;
}
return
hostFiber
.
stateNode
;
}
var
shouldSuspendImpl
=
function
(
fiber
)
{
return
false
;
}
;
function
shouldSuspend
(
fiber
)
{
return
shouldSuspendImpl
(
fiber
)
;
}
var
overrideHookState
=
null
;
var
overrideProps
=
null
;
var
scheduleUpdate
=
null
;
var
setSuspenseHandler
=
null
;
{
var
copyWithSetImpl
=
function
(
obj
path
idx
value
)
{
if
(
idx
>
=
path
.
length
)
{
return
value
;
}
var
key
=
path
[
idx
]
;
var
updated
=
Array
.
isArray
(
obj
)
?
obj
.
slice
(
)
:
_assign
(
{
}
obj
)
;
updated
[
key
]
=
copyWithSetImpl
(
obj
[
key
]
path
idx
+
1
value
)
;
return
updated
;
}
;
var
copyWithSet
=
function
(
obj
path
value
)
{
return
copyWithSetImpl
(
obj
path
0
value
)
;
}
;
overrideHookState
=
function
(
fiber
id
path
value
)
{
var
currentHook
=
fiber
.
memoizedState
;
while
(
currentHook
!
=
=
null
&
&
id
>
0
)
{
currentHook
=
currentHook
.
next
;
id
-
-
;
}
if
(
currentHook
!
=
=
null
)
{
var
newState
=
copyWithSet
(
currentHook
.
memoizedState
path
value
)
;
currentHook
.
memoizedState
=
newState
;
currentHook
.
baseState
=
newState
;
fiber
.
memoizedProps
=
_assign
(
{
}
fiber
.
memoizedProps
)
;
scheduleWork
(
fiber
Sync
)
;
}
}
;
overrideProps
=
function
(
fiber
path
value
)
{
fiber
.
pendingProps
=
copyWithSet
(
fiber
.
memoizedProps
path
value
)
;
if
(
fiber
.
alternate
)
{
fiber
.
alternate
.
pendingProps
=
fiber
.
pendingProps
;
}
scheduleWork
(
fiber
Sync
)
;
}
;
scheduleUpdate
=
function
(
fiber
)
{
scheduleWork
(
fiber
Sync
)
;
}
;
setSuspenseHandler
=
function
(
newShouldSuspendImpl
)
{
shouldSuspendImpl
=
newShouldSuspendImpl
;
}
;
}
function
injectIntoDevTools
(
devToolsConfig
)
{
var
findFiberByHostInstance
=
devToolsConfig
.
findFiberByHostInstance
;
var
ReactCurrentDispatcher
=
ReactSharedInternals
.
ReactCurrentDispatcher
;
return
injectInternals
(
_assign
(
{
}
devToolsConfig
{
overrideHookState
:
overrideHookState
overrideProps
:
overrideProps
setSuspenseHandler
:
setSuspenseHandler
scheduleUpdate
:
scheduleUpdate
currentDispatcherRef
:
ReactCurrentDispatcher
findHostInstanceByFiber
:
function
(
fiber
)
{
var
hostFiber
=
findCurrentHostFiber
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
findFiberByHostInstance
:
function
(
instance
)
{
if
(
!
findFiberByHostInstance
)
{
return
null
;
}
return
findFiberByHostInstance
(
instance
)
;
}
findHostInstancesForRefresh
:
findHostInstancesForRefresh
scheduleRefresh
:
scheduleRefresh
scheduleRoot
:
scheduleRoot
setRefreshHandler
:
setRefreshHandler
getCurrentFiber
:
function
(
)
{
return
current
;
}
}
)
)
;
}
function
ReactDOMRoot
(
container
options
)
{
this
.
_internalRoot
=
createRootImpl
(
container
ConcurrentRoot
options
)
;
}
function
ReactDOMBlockingRoot
(
container
tag
options
)
{
this
.
_internalRoot
=
createRootImpl
(
container
tag
options
)
;
}
ReactDOMRoot
.
prototype
.
render
=
ReactDOMBlockingRoot
.
prototype
.
render
=
function
(
children
callback
)
{
var
root
=
this
.
_internalRoot
;
var
cb
=
callback
=
=
=
undefined
?
null
:
callback
;
{
warnOnInvalidCallback
(
cb
'
render
'
)
;
}
updateContainer
(
children
root
null
cb
)
;
}
;
ReactDOMRoot
.
prototype
.
unmount
=
ReactDOMBlockingRoot
.
prototype
.
unmount
=
function
(
callback
)
{
var
root
=
this
.
_internalRoot
;
var
cb
=
callback
=
=
=
undefined
?
null
:
callback
;
{
warnOnInvalidCallback
(
cb
'
render
'
)
;
}
var
container
=
root
.
containerInfo
;
updateContainer
(
null
root
null
function
(
)
{
unmarkContainerAsRoot
(
container
)
;
if
(
cb
!
=
=
null
)
{
cb
(
)
;
}
}
)
;
}
;
function
createRootImpl
(
container
tag
options
)
{
var
hydrate
=
options
!
=
null
&
&
options
.
hydrate
=
=
=
true
;
var
hydrationCallbacks
=
options
!
=
null
&
&
options
.
hydrationOptions
|
|
null
;
var
root
=
createContainer
(
container
tag
hydrate
hydrationCallbacks
)
;
markContainerAsRoot
(
root
.
current
container
)
;
if
(
hydrate
&
&
tag
!
=
=
LegacyRoot
)
{
var
doc
=
container
.
nodeType
=
=
=
DOCUMENT_NODE
?
container
:
container
.
ownerDocument
;
eagerlyTrapReplayableEvents
(
doc
)
;
}
return
root
;
}
function
createRoot
(
container
options
)
{
if
(
!
isValidContainer
(
container
)
)
{
{
throw
Error
(
"
createRoot
(
.
.
.
)
:
Target
container
is
not
a
DOM
element
.
"
)
;
}
}
warnIfReactDOMContainerInDEV
(
container
)
;
return
new
ReactDOMRoot
(
container
options
)
;
}
function
createBlockingRoot
(
container
options
)
{
if
(
!
isValidContainer
(
container
)
)
{
{
throw
Error
(
"
createRoot
(
.
.
.
)
:
Target
container
is
not
a
DOM
element
.
"
)
;
}
}
warnIfReactDOMContainerInDEV
(
container
)
;
return
new
ReactDOMBlockingRoot
(
container
BlockingRoot
options
)
;
}
function
createLegacyRoot
(
container
options
)
{
return
new
ReactDOMBlockingRoot
(
container
LegacyRoot
options
)
;
}
function
isValidContainer
(
node
)
{
return
!
!
(
node
&
&
(
node
.
nodeType
=
=
=
ELEMENT_NODE
|
|
node
.
nodeType
=
=
=
DOCUMENT_NODE
|
|
node
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE
|
|
node
.
nodeType
=
=
=
COMMENT_NODE
&
&
node
.
nodeValue
=
=
=
'
react
-
mount
-
point
-
unstable
'
)
)
;
}
function
warnOnInvalidCallback
(
callback
callerName
)
{
{
!
(
callback
=
=
=
null
|
|
typeof
callback
=
=
=
'
function
'
)
?
warningWithoutStack
1
(
false
'
%
s
(
.
.
.
)
:
Expected
the
last
optional
callback
argument
to
be
a
'
+
'
function
.
Instead
received
:
%
s
.
'
callerName
callback
)
:
void
0
;
}
}
function
warnIfReactDOMContainerInDEV
(
container
)
{
{
if
(
isContainerMarkedAsRoot
(
container
)
)
{
if
(
container
.
_reactRootContainer
)
{
warningWithoutStack
1
(
false
'
You
are
calling
ReactDOM
.
createRoot
(
)
on
a
container
that
was
previously
'
+
'
passed
to
ReactDOM
.
render
(
)
.
This
is
not
supported
.
'
)
;
}
else
{
warningWithoutStack
1
(
false
'
You
are
calling
ReactDOM
.
createRoot
(
)
on
a
container
that
'
+
'
has
already
been
passed
to
createRoot
(
)
before
.
Instead
call
'
+
'
root
.
render
(
)
on
the
existing
root
instead
if
you
want
to
update
it
.
'
)
;
}
}
}
}
var
ReactCurrentOwner
1
=
ReactSharedInternals
.
ReactCurrentOwner
;
var
topLevelUpdateWarnings
;
var
warnedAboutHydrateAPI
=
false
;
{
topLevelUpdateWarnings
=
function
(
container
)
{
if
(
container
.
_reactRootContainer
&
&
container
.
nodeType
!
=
=
COMMENT_NODE
)
{
var
hostInstance
=
findHostInstanceWithNoPortals
(
container
.
_reactRootContainer
.
_internalRoot
.
current
)
;
if
(
hostInstance
)
{
!
(
hostInstance
.
parentNode
=
=
=
container
)
?
warningWithoutStack
1
(
false
'
render
(
.
.
.
)
:
It
looks
like
the
React
-
rendered
content
of
this
'
+
'
container
was
removed
without
using
React
.
This
is
not
'
+
'
supported
and
will
cause
errors
.
Instead
call
'
+
'
ReactDOM
.
unmountComponentAtNode
to
empty
a
container
.
'
)
:
void
0
;
}
}
var
isRootRenderedBySomeReact
=
!
!
container
.
_reactRootContainer
;
var
rootEl
=
getReactRootElementInContainer
(
container
)
;
var
hasNonRootReactChild
=
!
!
(
rootEl
&
&
getInstanceFromNode
1
(
rootEl
)
)
;
!
(
!
hasNonRootReactChild
|
|
isRootRenderedBySomeReact
)
?
warningWithoutStack
1
(
false
'
render
(
.
.
.
)
:
Replacing
React
-
rendered
children
with
a
new
root
'
+
'
component
.
If
you
intended
to
update
the
children
of
this
node
'
+
'
you
should
instead
have
the
existing
children
update
their
state
'
+
'
and
render
the
new
components
instead
of
calling
ReactDOM
.
render
.
'
)
:
void
0
;
!
(
container
.
nodeType
!
=
=
ELEMENT_NODE
|
|
!
container
.
tagName
|
|
container
.
tagName
.
toUpperCase
(
)
!
=
=
'
BODY
'
)
?
warningWithoutStack
1
(
false
'
render
(
)
:
Rendering
components
directly
into
document
.
body
is
'
+
'
discouraged
since
its
children
are
often
manipulated
by
third
-
party
'
+
'
scripts
and
browser
extensions
.
This
may
lead
to
subtle
'
+
'
reconciliation
issues
.
Try
rendering
into
a
container
element
created
'
+
'
for
your
app
.
'
)
:
void
0
;
}
;
}
function
getReactRootElementInContainer
(
container
)
{
if
(
!
container
)
{
return
null
;
}
if
(
container
.
nodeType
=
=
=
DOCUMENT_NODE
)
{
return
container
.
documentElement
;
}
else
{
return
container
.
firstChild
;
}
}
function
shouldHydrateDueToLegacyHeuristic
(
container
)
{
var
rootElement
=
getReactRootElementInContainer
(
container
)
;
return
!
!
(
rootElement
&
&
rootElement
.
nodeType
=
=
=
ELEMENT_NODE
&
&
rootElement
.
hasAttribute
(
ROOT_ATTRIBUTE_NAME
)
)
;
}
function
legacyCreateRootFromDOMContainer
(
container
forceHydrate
)
{
var
shouldHydrate
=
forceHydrate
|
|
shouldHydrateDueToLegacyHeuristic
(
container
)
;
if
(
!
shouldHydrate
)
{
var
warned
=
false
;
var
rootSibling
;
while
(
rootSibling
=
container
.
lastChild
)
{
{
if
(
!
warned
&
&
rootSibling
.
nodeType
=
=
=
ELEMENT_NODE
&
&
rootSibling
.
hasAttribute
(
ROOT_ATTRIBUTE_NAME
)
)
{
warned
=
true
;
warningWithoutStack
1
(
false
'
render
(
)
:
Target
node
has
markup
rendered
by
React
but
there
'
+
'
are
unrelated
nodes
as
well
.
This
is
most
commonly
caused
by
'
+
'
white
-
space
inserted
around
server
-
rendered
markup
.
'
)
;
}
}
container
.
removeChild
(
rootSibling
)
;
}
}
{
if
(
shouldHydrate
&
&
!
forceHydrate
&
&
!
warnedAboutHydrateAPI
)
{
warnedAboutHydrateAPI
=
true
;
lowPriorityWarningWithoutStack
1
(
false
'
render
(
)
:
Calling
ReactDOM
.
render
(
)
to
hydrate
server
-
rendered
markup
'
+
'
will
stop
working
in
React
v17
.
Replace
the
ReactDOM
.
render
(
)
call
'
+
'
with
ReactDOM
.
hydrate
(
)
if
you
want
React
to
attach
to
the
server
HTML
.
'
)
;
}
}
return
createLegacyRoot
(
container
shouldHydrate
?
{
hydrate
:
true
}
:
undefined
)
;
}
function
legacyRenderSubtreeIntoContainer
(
parentComponent
children
container
forceHydrate
callback
)
{
{
topLevelUpdateWarnings
(
container
)
;
warnOnInvalidCallback
(
callback
=
=
=
undefined
?
null
:
callback
'
render
'
)
;
}
var
root
=
container
.
_reactRootContainer
;
var
fiberRoot
;
if
(
!
root
)
{
root
=
container
.
_reactRootContainer
=
legacyCreateRootFromDOMContainer
(
container
forceHydrate
)
;
fiberRoot
=
root
.
_internalRoot
;
if
(
typeof
callback
=
=
=
'
function
'
)
{
var
originalCallback
=
callback
;
callback
=
function
(
)
{
var
instance
=
getPublicRootInstance
(
fiberRoot
)
;
originalCallback
.
call
(
instance
)
;
}
;
}
unbatchedUpdates
(
function
(
)
{
updateContainer
(
children
fiberRoot
parentComponent
callback
)
;
}
)
;
}
else
{
fiberRoot
=
root
.
_internalRoot
;
if
(
typeof
callback
=
=
=
'
function
'
)
{
var
_originalCallback
=
callback
;
callback
=
function
(
)
{
var
instance
=
getPublicRootInstance
(
fiberRoot
)
;
_originalCallback
.
call
(
instance
)
;
}
;
}
updateContainer
(
children
fiberRoot
parentComponent
callback
)
;
}
return
getPublicRootInstance
(
fiberRoot
)
;
}
function
findDOMNode
(
componentOrElement
)
{
{
var
owner
=
ReactCurrentOwner
1
.
current
;
if
(
owner
!
=
=
null
&
&
owner
.
stateNode
!
=
=
null
)
{
var
warnedAboutRefsInRender
=
owner
.
stateNode
.
_warnedAboutRefsInRender
;
!
warnedAboutRefsInRender
?
warningWithoutStack
1
(
false
'
%
s
is
accessing
findDOMNode
inside
its
render
(
)
.
'
+
'
render
(
)
should
be
a
pure
function
of
props
and
state
.
It
should
'
+
'
never
access
something
that
requires
stale
data
from
the
previous
'
+
'
render
such
as
refs
.
Move
this
logic
to
componentDidMount
and
'
+
'
componentDidUpdate
instead
.
'
getComponentName
(
owner
.
type
)
|
|
'
A
component
'
)
:
void
0
;
owner
.
stateNode
.
_warnedAboutRefsInRender
=
true
;
}
}
if
(
componentOrElement
=
=
null
)
{
return
null
;
}
if
(
componentOrElement
.
nodeType
=
=
=
ELEMENT_NODE
)
{
return
componentOrElement
;
}
{
return
findHostInstanceWithWarning
(
componentOrElement
'
findDOMNode
'
)
;
}
return
findHostInstance
(
componentOrElement
)
;
}
function
hydrate
(
element
container
callback
)
{
if
(
!
isValidContainer
(
container
)
)
{
{
throw
Error
(
"
Target
container
is
not
a
DOM
element
.
"
)
;
}
}
{
var
isModernRoot
=
isContainerMarkedAsRoot
(
container
)
&
&
container
.
_reactRootContainer
=
=
=
undefined
;
if
(
isModernRoot
)
{
warningWithoutStack
1
(
false
'
You
are
calling
ReactDOM
.
hydrate
(
)
on
a
container
that
was
previously
'
+
'
passed
to
ReactDOM
.
createRoot
(
)
.
This
is
not
supported
.
'
+
'
Did
you
mean
to
call
createRoot
(
container
{
hydrate
:
true
}
)
.
render
(
element
)
?
'
)
;
}
}
return
legacyRenderSubtreeIntoContainer
(
null
element
container
true
callback
)
;
}
function
render
(
element
container
callback
)
{
if
(
!
isValidContainer
(
container
)
)
{
{
throw
Error
(
"
Target
container
is
not
a
DOM
element
.
"
)
;
}
}
{
var
isModernRoot
=
isContainerMarkedAsRoot
(
container
)
&
&
container
.
_reactRootContainer
=
=
=
undefined
;
if
(
isModernRoot
)
{
warningWithoutStack
1
(
false
'
You
are
calling
ReactDOM
.
render
(
)
on
a
container
that
was
previously
'
+
'
passed
to
ReactDOM
.
createRoot
(
)
.
This
is
not
supported
.
'
+
'
Did
you
mean
to
call
root
.
render
(
element
)
?
'
)
;
}
}
return
legacyRenderSubtreeIntoContainer
(
null
element
container
false
callback
)
;
}
function
unstable_renderSubtreeIntoContainer
(
parentComponent
element
containerNode
callback
)
{
if
(
!
isValidContainer
(
containerNode
)
)
{
{
throw
Error
(
"
Target
container
is
not
a
DOM
element
.
"
)
;
}
}
if
(
!
(
parentComponent
!
=
null
&
&
has
1
(
parentComponent
)
)
)
{
{
throw
Error
(
"
parentComponent
must
be
a
valid
React
Component
"
)
;
}
}
return
legacyRenderSubtreeIntoContainer
(
parentComponent
element
containerNode
false
callback
)
;
}
function
unmountComponentAtNode
(
container
)
{
if
(
!
isValidContainer
(
container
)
)
{
{
throw
Error
(
"
unmountComponentAtNode
(
.
.
.
)
:
Target
container
is
not
a
DOM
element
.
"
)
;
}
}
{
var
isModernRoot
=
isContainerMarkedAsRoot
(
container
)
&
&
container
.
_reactRootContainer
=
=
=
undefined
;
if
(
isModernRoot
)
{
warningWithoutStack
1
(
false
'
You
are
calling
ReactDOM
.
unmountComponentAtNode
(
)
on
a
container
that
was
previously
'
+
'
passed
to
ReactDOM
.
createRoot
(
)
.
This
is
not
supported
.
Did
you
mean
to
call
root
.
unmount
(
)
?
'
)
;
}
}
if
(
container
.
_reactRootContainer
)
{
{
var
rootEl
=
getReactRootElementInContainer
(
container
)
;
var
renderedByDifferentReact
=
rootEl
&
&
!
getInstanceFromNode
1
(
rootEl
)
;
!
!
renderedByDifferentReact
?
warningWithoutStack
1
(
false
"
unmountComponentAtNode
(
)
:
The
node
you
'
re
attempting
to
unmount
"
+
'
was
rendered
by
another
copy
of
React
.
'
)
:
void
0
;
}
unbatchedUpdates
(
function
(
)
{
legacyRenderSubtreeIntoContainer
(
null
null
container
false
function
(
)
{
container
.
_reactRootContainer
=
null
;
unmarkContainerAsRoot
(
container
)
;
}
)
;
}
)
;
return
true
;
}
else
{
{
var
_rootEl
=
getReactRootElementInContainer
(
container
)
;
var
hasNonRootReactChild
=
!
!
(
_rootEl
&
&
getInstanceFromNode
1
(
_rootEl
)
)
;
var
isContainerReactRoot
=
container
.
nodeType
=
=
=
ELEMENT_NODE
&
&
isValidContainer
(
container
.
parentNode
)
&
&
!
!
container
.
parentNode
.
_reactRootContainer
;
!
!
hasNonRootReactChild
?
warningWithoutStack
1
(
false
"
unmountComponentAtNode
(
)
:
The
node
you
'
re
attempting
to
unmount
"
+
'
was
rendered
by
React
and
is
not
a
top
-
level
container
.
%
s
'
isContainerReactRoot
?
'
You
may
have
accidentally
passed
in
a
React
root
node
instead
'
+
'
of
its
container
.
'
:
'
Instead
have
the
parent
component
update
its
state
and
'
+
'
rerender
in
order
to
remove
this
component
.
'
)
:
void
0
;
}
return
false
;
}
}
function
createPortal
1
(
children
containerInfo
implementation
)
{
var
key
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
null
;
return
{
typeof
:
REACT_PORTAL_TYPE
key
:
key
=
=
null
?
null
:
'
'
+
key
children
:
children
containerInfo
:
containerInfo
implementation
:
implementation
}
;
}
var
ReactVersion
=
'
16
.
12
.
0
'
;
setAttemptSynchronousHydration
(
attemptSynchronousHydration
1
)
;
setAttemptUserBlockingHydration
(
attemptUserBlockingHydration
1
)
;
setAttemptContinuousHydration
(
attemptContinuousHydration
1
)
;
setAttemptHydrationAtCurrentPriority
(
attemptHydrationAtCurrentPriority
1
)
;
var
didWarnAboutUnstableCreatePortal
=
false
;
{
if
(
typeof
Map
!
=
=
'
function
'
|
|
Map
.
prototype
=
=
null
|
|
typeof
Map
.
prototype
.
forEach
!
=
=
'
function
'
|
|
typeof
Set
!
=
=
'
function
'
|
|
Set
.
prototype
=
=
null
|
|
typeof
Set
.
prototype
.
clear
!
=
=
'
function
'
|
|
typeof
Set
.
prototype
.
forEach
!
=
=
'
function
'
)
{
warningWithoutStack
1
(
false
'
React
depends
on
Map
and
Set
built
-
in
types
.
Make
sure
that
you
load
a
'
+
'
polyfill
in
older
browsers
.
https
:
/
/
fb
.
me
/
react
-
polyfills
'
)
;
}
}
setRestoreImplementation
(
restoreControlledState
1
)
;
setBatchingImplementation
(
batchedUpdates
1
discreteUpdates
1
flushDiscreteUpdates
batchedEventUpdates
1
)
;
function
createPortal
1
(
children
container
)
{
var
key
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
null
;
if
(
!
isValidContainer
(
container
)
)
{
{
throw
Error
(
"
Target
container
is
not
a
DOM
element
.
"
)
;
}
}
return
createPortal
1
(
children
container
null
key
)
;
}
var
ReactDOM
=
{
createPortal
:
createPortal
1
findDOMNode
:
findDOMNode
hydrate
:
hydrate
render
:
render
unstable_renderSubtreeIntoContainer
:
unstable_renderSubtreeIntoContainer
unmountComponentAtNode
:
unmountComponentAtNode
unstable_createPortal
:
function
(
)
{
if
(
!
didWarnAboutUnstableCreatePortal
)
{
didWarnAboutUnstableCreatePortal
=
true
;
lowPriorityWarningWithoutStack
1
(
false
'
The
ReactDOM
.
unstable_createPortal
(
)
alias
has
been
deprecated
'
+
'
and
will
be
removed
in
React
17
+
.
Update
your
code
to
use
'
+
'
ReactDOM
.
createPortal
(
)
instead
.
It
has
the
exact
same
API
'
+
'
but
without
the
"
unstable_
"
prefix
.
'
)
;
}
return
createPortal
1
.
apply
(
void
0
arguments
)
;
}
unstable_batchedUpdates
:
batchedUpdates
1
flushSync
:
flushSync
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
:
{
Events
:
[
getInstanceFromNode
1
getNodeFromInstance
1
getFiberCurrentPropsFromNode
1
injection
.
injectEventPluginsByName
eventNameDispatchConfigs
accumulateTwoPhaseDispatches
accumulateDirectDispatches
enqueueStateRestore
restoreStateIfNeeded
dispatchEvent
runEventsInBatch
flushPassiveEffects
IsThisRendererActing
]
}
}
;
if
(
exposeConcurrentModeAPIs
)
{
ReactDOM
.
createRoot
=
createRoot
;
ReactDOM
.
createBlockingRoot
=
createBlockingRoot
;
ReactDOM
.
unstable_discreteUpdates
=
discreteUpdates
1
;
ReactDOM
.
unstable_flushDiscreteUpdates
=
flushDiscreteUpdates
;
ReactDOM
.
unstable_flushControlled
=
flushControlled
;
ReactDOM
.
unstable_scheduleHydration
=
function
(
target
)
{
if
(
target
)
{
queueExplicitHydrationTarget
(
target
)
;
}
}
;
}
var
foundDevTools
=
injectIntoDevTools
(
{
findFiberByHostInstance
:
getClosestInstanceFromNode
bundleType
:
1
version
:
ReactVersion
rendererPackageName
:
'
react
-
dom
'
}
)
;
{
if
(
!
foundDevTools
&
&
canUseDOM
&
&
window
.
top
=
=
=
window
.
self
)
{
if
(
navigator
.
userAgent
.
indexOf
(
'
Chrome
'
)
>
-
1
&
&
navigator
.
userAgent
.
indexOf
(
'
Edge
'
)
=
=
=
-
1
|
|
navigator
.
userAgent
.
indexOf
(
'
Firefox
'
)
>
-
1
)
{
var
protocol
=
window
.
location
.
protocol
;
if
(
/
^
(
https
?
|
file
)
:
/
.
test
(
protocol
)
)
{
console
.
info
(
'
%
cDownload
the
React
DevTools
'
+
'
for
a
better
development
experience
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
devtools
'
+
(
protocol
=
=
=
'
file
:
'
?
'
\
nYou
might
need
to
use
a
local
HTTP
server
(
instead
of
file
:
/
/
)
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
devtools
-
faq
'
:
'
'
)
'
font
-
weight
:
bold
'
)
;
}
}
}
}
var
ReactDOM
2
=
Object
.
freeze
(
{
default
:
ReactDOM
}
)
;
var
ReactDOM
3
=
(
ReactDOM
2
&
&
ReactDOM
)
|
|
ReactDOM
2
;
var
reactDom
=
ReactDOM
3
.
default
|
|
ReactDOM
3
;
return
reactDom
;
}
)
)
)
;
