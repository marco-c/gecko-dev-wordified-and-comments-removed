"
use
strict
"
;
const
{
Localization
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Localization
.
jsm
"
{
}
)
;
const
POPUP_NOTIFICATION_ID
=
"
contextual
-
feature
-
recommendation
"
;
const
DELAY_BEFORE_EXPAND_MS
=
1000
;
const
DURATION_OF_EXPAND_MS
=
5000
;
const
RecommendationMap
=
new
WeakMap
(
)
;
const
PageActionMap
=
new
WeakMap
(
)
;
class
PageAction
{
constructor
(
win
dispatchToASRouter
)
{
this
.
window
=
win
;
this
.
urlbar
=
win
.
document
.
getElementById
(
"
urlbar
"
)
;
this
.
container
=
win
.
document
.
getElementById
(
"
contextual
-
feature
-
recommendation
"
)
;
this
.
button
=
win
.
document
.
getElementById
(
"
cfr
-
button
"
)
;
this
.
label
=
win
.
document
.
getElementById
(
"
cfr
-
label
"
)
;
this
.
_dispatchToASRouter
=
dispatchToASRouter
;
this
.
_popupStateChange
=
this
.
_popupStateChange
.
bind
(
this
)
;
this
.
_collapse
=
this
.
_collapse
.
bind
(
this
)
;
this
.
_handleClick
=
this
.
_handleClick
.
bind
(
this
)
;
this
.
dispatchUserAction
=
this
.
dispatchUserAction
.
bind
(
this
)
;
this
.
_l10n
=
new
Localization
(
[
"
browser
/
newtab
/
asrouter
.
ftl
"
]
)
;
this
.
stateTransitionTimeoutIDs
=
[
]
;
this
.
container
.
onclick
=
this
.
_handleClick
;
}
async
show
(
notification_text
shouldExpand
=
false
)
{
this
.
container
.
hidden
=
false
;
this
.
label
.
value
=
await
this
.
getStrings
(
{
string
:
notification_text
}
)
;
await
this
.
window
.
promiseDocumentFlushed
;
const
[
{
width
}
]
=
this
.
label
.
getClientRects
(
)
;
this
.
urlbar
.
style
.
setProperty
(
"
-
-
cfr
-
label
-
width
"
{
width
}
px
)
;
if
(
shouldExpand
)
{
this
.
_clearScheduledStateChanges
(
)
;
this
.
_expand
(
DELAY_BEFORE_EXPAND_MS
)
;
this
.
_collapse
(
DELAY_BEFORE_EXPAND_MS
+
DURATION_OF_EXPAND_MS
)
;
}
}
hide
(
)
{
this
.
container
.
hidden
=
true
;
this
.
_clearScheduledStateChanges
(
)
;
this
.
urlbar
.
removeAttribute
(
"
cfr
-
recommendation
-
state
"
)
;
}
dispatchUserAction
(
action
)
{
this
.
_dispatchToASRouter
(
{
type
:
"
USER_ACTION
"
data
:
action
}
{
browser
:
this
.
window
.
gBrowser
.
selectedBrowser
}
)
;
}
_expand
(
delay
=
0
)
{
if
(
!
delay
)
{
this
.
_clearScheduledStateChanges
(
)
;
this
.
urlbar
.
setAttribute
(
"
cfr
-
recommendation
-
state
"
"
expanded
"
)
;
}
else
{
this
.
stateTransitionTimeoutIDs
.
push
(
this
.
window
.
setTimeout
(
(
)
=
>
{
this
.
urlbar
.
setAttribute
(
"
cfr
-
recommendation
-
state
"
"
expanded
"
)
;
}
delay
)
)
;
}
}
_collapse
(
delay
=
0
)
{
if
(
!
delay
)
{
this
.
_clearScheduledStateChanges
(
)
;
if
(
this
.
urlbar
.
getAttribute
(
"
cfr
-
recommendation
-
state
"
)
=
=
=
"
expanded
"
)
{
this
.
urlbar
.
setAttribute
(
"
cfr
-
recommendation
-
state
"
"
collapsed
"
)
;
}
}
else
{
this
.
stateTransitionTimeoutIDs
.
push
(
this
.
window
.
setTimeout
(
(
)
=
>
{
if
(
this
.
urlbar
.
getAttribute
(
"
cfr
-
recommendation
-
state
"
)
=
=
=
"
expanded
"
)
{
this
.
urlbar
.
setAttribute
(
"
cfr
-
recommendation
-
state
"
"
collapsed
"
)
;
}
}
delay
)
)
;
}
}
_clearScheduledStateChanges
(
)
{
while
(
this
.
stateTransitionTimeoutIDs
.
length
>
0
)
{
this
.
window
.
clearTimeout
(
this
.
stateTransitionTimeoutIDs
.
pop
(
)
)
;
}
}
_popupStateChange
(
state
)
{
if
(
[
"
dismissed
"
"
removed
"
]
.
includes
(
state
)
)
{
this
.
_collapse
(
)
;
}
}
async
getStrings
(
{
string
hasAttributes
}
)
{
if
(
!
string
.
string_id
)
{
return
string
;
}
const
[
localeStrings
]
=
await
this
.
_l10n
.
formatMessages
(
[
{
id
:
string
.
string_id
}
]
)
;
if
(
hasAttributes
&
&
localeStrings
.
attributes
)
{
const
attributes
=
localeStrings
.
attributes
.
reduce
(
(
acc
attribute
)
=
>
{
acc
[
attribute
.
name
]
=
attribute
.
value
;
return
acc
;
}
{
}
)
;
return
{
value
:
localeStrings
.
value
attributes
}
;
}
else
{
return
localeStrings
.
value
;
}
}
async
_handleClick
(
event
)
{
const
browser
=
this
.
window
.
gBrowser
.
selectedBrowser
;
if
(
!
RecommendationMap
.
has
(
browser
)
)
{
this
.
hide
(
)
;
return
;
}
const
{
content
}
=
RecommendationMap
.
get
(
browser
)
;
this
.
_clearScheduledStateChanges
(
)
;
browser
.
cfrpopupnotificationanchor
=
this
.
container
;
const
{
primary
secondary
}
=
content
.
buttons
;
const
primaryBtnStrings
=
await
this
.
getStrings
(
{
string
:
primary
.
label
hasAttributes
:
true
}
)
;
const
secondaryBtnStrings
=
await
this
.
getStrings
(
{
string
:
secondary
.
label
hasAttributes
:
true
}
)
;
const
mainAction
=
{
label
:
primaryBtnStrings
.
value
accessKey
:
primaryBtnStrings
.
attributes
.
accesskey
callback
:
(
)
=
>
this
.
dispatchUserAction
(
primary
.
action
)
}
;
const
secondaryActions
=
[
{
label
:
secondaryBtnStrings
.
value
accessKey
:
secondaryBtnStrings
.
attributes
.
accesskey
callback
:
this
.
_collapse
}
]
;
const
options
=
{
popupIconURL
:
content
.
addon
.
icon
hideClose
:
true
eventCallback
:
this
.
_popupStateChange
}
;
this
.
window
.
PopupNotifications
.
show
(
browser
POPUP_NOTIFICATION_ID
await
this
.
getStrings
(
{
string
:
content
.
text
}
)
"
cfr
"
mainAction
secondaryActions
options
)
;
}
}
function
isHostMatch
(
browser
host
)
{
return
(
browser
.
documentURI
.
scheme
.
startsWith
(
"
http
"
)
&
&
browser
.
documentURI
.
host
=
=
=
host
)
;
}
const
CFRPageActions
=
{
RecommendationMap
PageActionMap
updatePageActions
(
browser
)
{
const
win
=
browser
.
ownerGlobal
;
const
pageAction
=
PageActionMap
.
get
(
win
)
;
if
(
!
pageAction
|
|
browser
!
=
=
win
.
gBrowser
.
selectedBrowser
)
{
return
;
}
if
(
RecommendationMap
.
has
(
browser
)
)
{
const
{
host
content
}
=
RecommendationMap
.
get
(
browser
)
;
if
(
isHostMatch
(
browser
host
)
)
{
pageAction
.
show
(
this
.
getStrings
(
{
string
:
content
.
notification_text
}
)
)
;
}
else
{
RecommendationMap
.
delete
(
browser
)
;
pageAction
.
hide
(
)
;
}
}
else
{
pageAction
.
hide
(
)
;
}
}
async
forceRecommendation
(
browser
recommendation
dispatchToASRouter
)
{
const
win
=
browser
.
browser
.
ownerGlobal
;
const
{
id
content
}
=
recommendation
;
RecommendationMap
.
set
(
browser
.
browser
{
id
content
}
)
;
if
(
!
PageActionMap
.
has
(
win
)
)
{
PageActionMap
.
set
(
win
new
PageAction
(
win
dispatchToASRouter
)
)
;
}
await
PageActionMap
.
get
(
win
)
.
show
(
this
.
getStrings
(
{
string
:
recommendation
.
content
.
notification_text
}
)
true
)
;
return
true
;
}
async
addRecommendation
(
browser
host
recommendation
dispatchToASRouter
)
{
const
win
=
browser
.
ownerGlobal
;
if
(
browser
!
=
=
win
.
gBrowser
.
selectedBrowser
|
|
!
isHostMatch
(
browser
host
)
)
{
return
false
;
}
const
{
id
content
}
=
recommendation
;
RecommendationMap
.
set
(
browser
{
id
host
content
}
)
;
if
(
!
PageActionMap
.
has
(
win
)
)
{
PageActionMap
.
set
(
win
new
PageAction
(
win
dispatchToASRouter
)
)
;
}
await
PageActionMap
.
get
(
win
)
.
show
(
recommendation
.
content
.
notification_text
true
)
;
return
true
;
}
clearRecommendations
(
)
{
for
(
const
[
win
pageAction
]
of
PageActionMap
)
{
pageAction
.
hide
(
)
;
PageActionMap
.
delete
(
win
)
;
}
RecommendationMap
.
clear
(
)
;
}
}
;
this
.
CFRPageActions
=
CFRPageActions
;
const
EXPORTED_SYMBOLS
=
[
"
CFRPageActions
"
]
;
