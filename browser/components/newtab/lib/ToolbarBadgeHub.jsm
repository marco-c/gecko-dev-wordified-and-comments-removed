"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
EveryWindow
:
"
resource
:
/
/
/
modules
/
EveryWindow
.
jsm
"
ToolbarPanelHub
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ToolbarPanelHub
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
const
{
setInterval
clearInterval
requestIdleCallback
setTimeout
clearTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
SYSTEM_TICK_INTERVAL
=
5
*
60
*
1000
;
let
notificationsByWindow
=
new
WeakMap
(
)
;
class
_ToolbarBadgeHub
{
constructor
(
)
{
this
.
id
=
"
toolbar
-
badge
-
hub
"
;
this
.
state
=
null
;
this
.
prefs
=
{
WHATSNEW_TOOLBAR_PANEL
:
"
browser
.
messaging
-
system
.
whatsNewPanel
.
enabled
"
HOMEPAGE_OVERRIDE_PREF
:
"
browser
.
startup
.
homepage_override
.
once
"
}
;
this
.
removeAllNotifications
=
this
.
removeAllNotifications
.
bind
(
this
)
;
this
.
removeToolbarNotification
=
this
.
removeToolbarNotification
.
bind
(
this
)
;
this
.
addToolbarNotification
=
this
.
addToolbarNotification
.
bind
(
this
)
;
this
.
registerBadgeToAllWindows
=
this
.
registerBadgeToAllWindows
.
bind
(
this
)
;
this
.
_sendTelemetry
=
this
.
_sendTelemetry
.
bind
(
this
)
;
this
.
sendUserEventTelemetry
=
this
.
sendUserEventTelemetry
.
bind
(
this
)
;
this
.
checkHomepageOverridePref
=
this
.
checkHomepageOverridePref
.
bind
(
this
)
;
this
.
_handleMessageRequest
=
null
;
this
.
_addImpression
=
null
;
this
.
_blockMessageById
=
null
;
this
.
_dispatch
=
null
;
}
async
init
(
waitForInitialized
{
handleMessageRequest
addImpression
blockMessageById
unblockMessageById
dispatch
}
)
{
this
.
_handleMessageRequest
=
handleMessageRequest
;
this
.
_blockMessageById
=
blockMessageById
;
this
.
_unblockMessageById
=
unblockMessageById
;
this
.
_addImpression
=
addImpression
;
this
.
_dispatch
=
dispatch
;
await
waitForInitialized
;
this
.
messageRequest
(
{
triggerId
:
"
toolbarBadgeUpdate
"
template
:
"
toolbar_badge
"
}
)
;
Services
.
prefs
.
addObserver
(
this
.
prefs
.
WHATSNEW_TOOLBAR_PANEL
this
)
;
const
_intervalId
=
setInterval
(
(
)
=
>
this
.
checkHomepageOverridePref
(
)
SYSTEM_TICK_INTERVAL
)
;
this
.
state
=
{
_intervalId
}
;
}
checkHomepageOverridePref
(
)
{
const
prefValue
=
Services
.
prefs
.
getStringPref
(
this
.
prefs
.
HOMEPAGE_OVERRIDE_PREF
"
"
)
;
if
(
prefValue
)
{
Services
.
prefs
.
clearUserPref
(
this
.
prefs
.
HOMEPAGE_OVERRIDE_PREF
)
;
let
message_id
;
try
{
message_id
=
JSON
.
parse
(
prefValue
)
.
message_id
;
}
catch
(
e
)
{
}
if
(
message_id
)
{
this
.
_unblockMessageById
(
message_id
)
;
}
}
this
.
messageRequest
(
{
triggerId
:
"
momentsUpdate
"
template
:
"
update_action
"
}
)
;
}
observe
(
aSubject
aTopic
aPrefName
)
{
switch
(
aPrefName
)
{
case
this
.
prefs
.
WHATSNEW_TOOLBAR_PANEL
:
this
.
messageRequest
(
{
triggerId
:
"
toolbarBadgeUpdate
"
template
:
"
toolbar_badge
"
}
)
;
break
;
}
}
maybeInsertFTL
(
win
)
{
win
.
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
newtab
/
asrouter
.
ftl
"
)
;
}
executeAction
(
{
id
data
message_id
}
)
{
switch
(
id
)
{
case
"
show
-
whatsnew
-
button
"
:
ToolbarPanelHub
.
enableToolbarButton
(
)
;
ToolbarPanelHub
.
enableAppmenuButton
(
)
;
break
;
case
"
moments
-
wnp
"
:
const
{
url
expireDelta
}
=
data
;
let
{
expire
}
=
data
;
if
(
!
expire
)
{
expire
=
this
.
getExpirationDate
(
expireDelta
)
;
}
Services
.
prefs
.
setStringPref
(
this
.
prefs
.
HOMEPAGE_OVERRIDE_PREF
JSON
.
stringify
(
{
message_id
url
expire
}
)
)
;
this
.
_blockMessageById
(
message_id
)
;
break
;
}
}
getExpirationDate
(
expireDelta
)
{
return
Date
.
now
(
)
+
expireDelta
;
}
_clearBadgeTimeout
(
)
{
if
(
this
.
state
.
showBadgeTimeoutId
)
{
clearTimeout
(
this
.
state
.
showBadgeTimeoutId
)
;
}
}
removeAllNotifications
(
event
)
{
if
(
event
)
{
if
(
(
event
.
type
=
=
=
"
mousedown
"
|
|
event
.
type
=
=
=
"
click
"
)
&
&
event
.
button
!
=
=
0
)
{
return
;
}
if
(
event
.
type
=
=
=
"
keypress
"
&
&
event
.
key
!
=
=
"
"
&
&
event
.
key
!
=
=
"
Enter
"
)
{
return
;
}
event
.
target
.
removeEventListener
(
"
mousedown
"
this
.
removeAllNotifications
)
;
event
.
target
.
removeEventListener
(
"
keypress
"
this
.
removeAllNotifications
)
;
if
(
this
.
state
.
notification
)
{
this
.
sendUserEventTelemetry
(
"
CLICK
"
this
.
state
.
notification
)
;
}
}
EveryWindow
.
unregisterCallback
(
this
.
id
)
;
if
(
this
.
state
.
notification
)
{
this
.
_blockMessageById
(
this
.
state
.
notification
.
id
)
;
}
this
.
_clearBadgeTimeout
(
)
;
this
.
state
=
{
}
;
}
removeToolbarNotification
(
toolbarButton
)
{
toolbarButton
.
querySelector
(
"
.
toolbarbutton
-
badge
"
)
.
classList
.
remove
(
"
feature
-
callout
"
)
;
toolbarButton
.
removeAttribute
(
"
badged
"
)
;
const
notificationDescription
=
toolbarButton
.
querySelector
(
"
#
toolbarbutton
-
notification
-
description
"
)
;
if
(
notificationDescription
)
{
notificationDescription
.
remove
(
)
;
toolbarButton
.
removeAttribute
(
"
aria
-
labelledby
"
)
;
toolbarButton
.
removeAttribute
(
"
aria
-
describedby
"
)
;
}
}
addToolbarNotification
(
win
message
)
{
const
document
=
win
.
browser
.
ownerDocument
;
if
(
message
.
content
.
action
)
{
this
.
executeAction
(
{
.
.
.
message
.
content
.
action
message_id
:
message
.
id
}
)
;
}
let
toolbarbutton
=
document
.
getElementById
(
message
.
content
.
target
)
;
if
(
toolbarbutton
)
{
const
badge
=
toolbarbutton
.
querySelector
(
"
.
toolbarbutton
-
badge
"
)
;
badge
.
classList
.
add
(
"
feature
-
callout
"
)
;
toolbarbutton
.
setAttribute
(
"
badged
"
true
)
;
if
(
message
.
content
.
badgeDescription
)
{
this
.
maybeInsertFTL
(
win
)
;
toolbarbutton
.
setAttribute
(
"
aria
-
labelledby
"
toolbarbutton
-
notification
-
description
{
message
.
content
.
target
}
)
;
toolbarbutton
.
setAttribute
(
"
aria
-
describedby
"
toolbarbutton
-
notification
-
description
{
message
.
content
.
target
}
)
;
const
descriptionEl
=
document
.
createElement
(
"
span
"
)
;
descriptionEl
.
setAttribute
(
"
id
"
"
toolbarbutton
-
notification
-
description
"
)
;
descriptionEl
.
setAttribute
(
"
hidden
"
true
)
;
document
.
l10n
.
setAttributes
(
descriptionEl
message
.
content
.
badgeDescription
.
string_id
)
;
toolbarbutton
.
appendChild
(
descriptionEl
)
;
}
toolbarbutton
.
addEventListener
(
"
mousedown
"
this
.
removeAllNotifications
)
;
toolbarbutton
.
addEventListener
(
"
keypress
"
this
.
removeAllNotifications
)
;
this
.
state
=
{
notification
:
{
id
:
message
.
id
}
}
;
this
.
_addImpression
(
message
)
;
this
.
sendUserEventTelemetry
(
"
IMPRESSION
"
message
)
;
return
toolbarbutton
;
}
return
null
;
}
registerBadgeToAllWindows
(
message
)
{
if
(
message
.
template
=
=
=
"
update_action
"
)
{
this
.
executeAction
(
{
.
.
.
message
.
content
.
action
message_id
:
message
.
id
}
)
;
return
;
}
EveryWindow
.
registerCallback
(
this
.
id
win
=
>
{
if
(
notificationsByWindow
.
has
(
win
)
)
{
return
;
}
const
el
=
this
.
addToolbarNotification
(
win
message
)
;
notificationsByWindow
.
set
(
win
el
)
;
}
win
=
>
{
const
el
=
notificationsByWindow
.
get
(
win
)
;
if
(
el
)
{
this
.
removeToolbarNotification
(
el
)
;
}
notificationsByWindow
.
delete
(
win
)
;
}
)
;
}
registerBadgeNotificationListener
(
message
options
=
{
}
)
{
if
(
options
.
force
)
{
this
.
removeAllNotifications
(
)
;
this
.
registerBadgeToAllWindows
(
message
)
;
return
;
}
if
(
message
.
content
.
delay
)
{
this
.
state
.
showBadgeTimeoutId
=
setTimeout
(
(
)
=
>
{
requestIdleCallback
(
(
)
=
>
this
.
registerBadgeToAllWindows
(
message
)
)
;
}
message
.
content
.
delay
)
;
}
else
{
this
.
registerBadgeToAllWindows
(
message
)
;
}
}
async
messageRequest
(
{
triggerId
template
}
)
{
const
telemetryObject
=
{
triggerId
}
;
TelemetryStopwatch
.
start
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
const
message
=
await
this
.
_handleMessageRequest
(
{
triggerId
template
}
)
;
TelemetryStopwatch
.
finish
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
if
(
message
)
{
this
.
registerBadgeNotificationListener
(
message
)
;
}
}
_sendTelemetry
(
ping
)
{
this
.
_dispatch
(
{
type
:
"
TOOLBAR_BADGE_TELEMETRY
"
data
:
{
action
:
"
cfr_user_event
"
source
:
"
CFR
"
.
.
.
ping
}
}
)
;
}
sendUserEventTelemetry
(
event
message
)
{
const
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
win
&
&
!
PrivateBrowsingUtils
.
isBrowserPrivate
(
win
.
ownerGlobal
.
gBrowser
.
selectedBrowser
)
)
{
this
.
_sendTelemetry
(
{
message_id
:
message
.
id
bucket_id
:
message
.
id
event
}
)
;
}
}
uninit
(
)
{
this
.
_clearBadgeTimeout
(
)
;
clearInterval
(
this
.
state
.
_intervalId
)
;
this
.
state
=
null
;
notificationsByWindow
=
new
WeakMap
(
)
;
Services
.
prefs
.
removeObserver
(
this
.
prefs
.
WHATSNEW_TOOLBAR_PANEL
this
)
;
}
}
this
.
_ToolbarBadgeHub
=
_ToolbarBadgeHub
;
this
.
ToolbarBadgeHub
=
new
_ToolbarBadgeHub
(
)
;
const
EXPORTED_SYMBOLS
=
[
"
ToolbarBadgeHub
"
"
_ToolbarBadgeHub
"
]
;
