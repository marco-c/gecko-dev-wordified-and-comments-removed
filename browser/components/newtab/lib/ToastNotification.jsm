"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
ExperimentAPI
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
RemoteL10n
:
"
resource
:
/
/
/
modules
/
asrouter
/
RemoteL10n
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
AlertsService
:
[
"
mozilla
.
org
/
alerts
-
service
;
1
"
"
nsIAlertsService
"
]
}
)
;
const
ToastNotification
=
{
get
AlertsService
(
)
{
return
lazy
.
AlertsService
;
}
sendUserEventTelemetry
(
event
message
dispatch
)
{
const
ping
=
{
message_id
:
message
.
id
event
}
;
dispatch
(
{
type
:
"
TOAST_NOTIFICATION_TELEMETRY
"
data
:
{
action
:
"
toast_notification_user_event
"
.
.
.
ping
}
}
)
;
}
async
showToastNotification
(
message
dispatch
)
{
let
{
content
}
=
message
;
let
title
=
await
lazy
.
RemoteL10n
.
formatLocalizableText
(
content
.
title
)
;
let
body
=
await
lazy
.
RemoteL10n
.
formatLocalizableText
(
content
.
body
)
;
let
{
tag
}
=
content
;
let
experimentMetadata
=
lazy
.
ExperimentAPI
.
getExperimentMetaData
(
{
featureId
:
"
backgroundTaskMessage
"
}
)
|
|
{
}
;
if
(
experimentMetadata
?
.
active
&
&
experimentMetadata
?
.
slug
&
&
experimentMetadata
?
.
branch
?
.
slug
)
{
tag
=
{
experimentMetadata
?
.
slug
}
:
{
experimentMetadata
?
.
branch
?
.
slug
}
;
}
this
.
sendUserEventTelemetry
(
"
IMPRESSION
"
message
dispatch
)
;
dispatch
(
{
type
:
"
IMPRESSION
"
data
:
message
}
)
;
let
alert
=
Cc
[
"
mozilla
.
org
/
alert
-
notification
;
1
"
]
.
createInstance
(
Ci
.
nsIAlertNotification
)
;
let
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
alert
.
init
(
tag
content
.
image_url
?
Services
.
urlFormatter
.
formatURL
(
content
.
image_url
)
:
content
.
image_url
title
body
true
content
.
data
null
null
null
systemPrincipal
null
content
.
requireInteraction
)
;
if
(
content
.
actions
)
{
let
actions
=
Cu
.
cloneInto
(
content
.
actions
{
}
)
;
for
(
let
action
of
actions
)
{
if
(
action
.
title
)
{
action
.
title
=
await
lazy
.
RemoteL10n
.
formatLocalizableText
(
action
.
title
)
;
}
if
(
action
.
launch_action
)
{
action
.
opaqueRelaunchData
=
JSON
.
stringify
(
action
.
launch_action
)
;
delete
action
.
launch_action
;
}
}
alert
.
actions
=
actions
;
}
let
relaunchAction
=
content
.
launch_action
;
if
(
!
relaunchAction
&
&
content
.
launch_url
)
{
relaunchAction
=
{
type
:
"
OPEN_URL
"
data
:
{
args
:
content
.
launch_url
where
:
"
tab
"
}
}
;
}
if
(
relaunchAction
)
{
alert
.
opaqueRelaunchData
=
JSON
.
stringify
(
relaunchAction
)
;
}
let
shownPromise
=
Promise
.
withResolvers
(
)
;
let
obs
=
(
subject
topic
data
)
=
>
{
if
(
topic
=
=
=
"
alertshow
"
)
{
shownPromise
.
resolve
(
)
;
}
}
;
this
.
AlertsService
.
showAlert
(
alert
obs
)
;
await
shownPromise
;
return
true
;
}
}
;
const
EXPORTED_SYMBOLS
=
[
"
ToastNotification
"
]
;
