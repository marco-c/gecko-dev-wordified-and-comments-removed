"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
Screenshots
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BackgroundPageThumbs
"
"
resource
:
/
/
gre
/
modules
/
BackgroundPageThumbs
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PageThumbs
"
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
GREY_10
=
"
#
F9F9FA
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gPrivilegedAboutProcessEnabled
"
"
browser
.
tabs
.
remote
.
separatePrivilegedContentProcess
"
false
)
;
const
Screenshots
=
{
async
getScreenshotForURL
(
url
)
{
try
{
await
BackgroundPageThumbs
.
captureIfMissing
(
url
{
backgroundColor
:
GREY_10
}
)
;
if
(
gPrivilegedAboutProcessEnabled
)
{
return
PageThumbs
.
getThumbnailURL
(
url
)
;
}
const
imgPath
=
PageThumbs
.
getThumbnailPath
(
url
)
;
const
filePathResponse
=
await
fetch
(
file
:
/
/
{
imgPath
}
)
;
const
fileContents
=
await
filePathResponse
.
blob
(
)
;
if
(
fileContents
.
size
=
=
=
0
)
{
return
null
;
}
return
{
path
:
imgPath
data
:
fileContents
}
;
}
catch
(
err
)
{
Cu
.
reportError
(
getScreenshot
(
{
url
}
)
failed
:
{
err
}
)
;
}
try
{
await
PageThumbs
.
_store
(
url
url
null
true
)
;
}
catch
(
err
)
{
}
return
null
;
}
_shouldGetScreenshots
(
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
)
{
return
true
;
}
}
return
false
;
}
async
maybeCacheScreenshot
(
link
url
property
onScreenshot
)
{
if
(
!
this
.
_shouldGetScreenshots
(
)
)
{
return
;
}
if
(
!
link
.
__sharedCache
)
{
link
.
__sharedCache
=
{
updateLink
(
prop
val
)
{
link
[
prop
]
=
val
;
}
}
;
}
const
cache
=
link
.
__sharedCache
;
if
(
cache
.
fetchingScreenshot
|
|
link
[
property
]
!
=
=
undefined
)
{
return
;
}
cache
.
fetchingScreenshot
=
this
.
getScreenshotForURL
(
url
)
;
const
screenshot
=
await
cache
.
fetchingScreenshot
;
delete
cache
.
fetchingScreenshot
;
cache
.
updateLink
(
property
screenshot
)
;
onScreenshot
(
screenshot
)
;
}
}
;
