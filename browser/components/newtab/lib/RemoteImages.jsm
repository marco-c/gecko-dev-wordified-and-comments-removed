"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
Downloader
"
"
resource
:
/
/
services
-
settings
/
Attachments
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
KintoHttpClient
"
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
RS_SERVER_PREF
=
"
services
.
settings
.
server
"
;
const
RS_MAIN_BUCKET
=
"
main
"
;
const
RS_COLLECTION
=
"
ms
-
images
"
;
const
RS_DOWNLOAD_MAX_RETRIES
=
2
;
const
CLEANUP_FINISHED_TOPIC
=
"
remote
-
images
:
cleanup
-
finished
"
;
const
IMAGE_EXPIRY_DURATION
=
30
*
24
*
60
*
60
;
const
EXTENSIONS
=
new
Map
(
[
[
"
avif
"
"
image
/
avif
"
]
[
"
png
"
"
image
/
png
"
]
[
"
svg
"
"
image
/
svg
+
xml
"
]
]
)
;
class
_RemoteImages
{
#
cleaningUp
;
constructor
(
)
{
this
.
#
cleaningUp
=
false
;
Services
.
obs
.
addObserver
(
(
)
=
>
this
.
#
cleanup
(
)
"
remote
-
settings
:
changes
-
poll
-
end
"
)
;
}
get
imagesDir
(
)
{
const
value
=
PathUtils
.
join
(
PathUtils
.
localProfileDir
"
settings
"
RS_MAIN_BUCKET
RS_COLLECTION
)
;
Object
.
defineProperty
(
this
"
imagesDir
"
{
value
}
)
;
return
value
;
}
async
load
(
imageId
)
{
let
blob
;
try
{
blob
=
await
this
.
#
readFromDisk
(
imageId
)
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
Components
.
Exception
&
&
e
.
name
=
=
=
"
NS_ERROR_FILE_NOT_FOUND
"
)
)
{
throw
e
;
}
blob
=
await
this
.
#
download
(
imageId
)
;
}
return
URL
.
createObjectURL
(
blob
)
;
}
unload
(
url
)
{
URL
.
revokeObjectURL
(
url
)
;
}
async
#
cleanup
(
)
{
if
(
this
.
#
cleaningUp
)
{
return
;
}
this
.
#
cleaningUp
=
true
;
try
{
const
now
=
Date
.
now
(
)
;
const
children
=
await
IOUtils
.
getChildren
(
this
.
imagesDir
)
;
for
(
const
child
of
children
)
{
const
stat
=
await
IOUtils
.
stat
(
child
)
;
if
(
now
-
stat
.
lastModified
>
=
IMAGE_EXPIRY_DURATION
)
{
await
IOUtils
.
remove
(
child
)
;
}
}
}
finally
{
this
.
#
cleaningUp
=
false
;
Services
.
obs
.
notifyObservers
(
null
CLEANUP_FINISHED_TOPIC
)
;
}
}
#
getRecordIdAndMimetype
(
imageId
)
{
const
idx
=
imageId
.
lastIndexOf
(
"
.
"
)
;
if
(
idx
=
=
=
-
1
)
{
throw
new
TypeError
(
"
imageId
must
include
extension
"
)
;
}
const
recordId
=
imageId
.
substring
(
0
idx
)
;
const
ext
=
imageId
.
substring
(
idx
+
1
)
;
const
mimetype
=
EXTENSIONS
.
get
(
ext
)
;
if
(
!
mimetype
)
{
throw
new
TypeError
(
Unsupported
extension
'
.
{
ext
}
'
for
remote
image
{
imageId
}
)
;
}
return
{
recordId
mimetype
}
;
}
async
#
readFromDisk
(
imageId
)
{
const
{
mimetype
}
=
this
.
#
getRecordIdAndMimetype
(
imageId
)
;
const
path
=
PathUtils
.
join
(
this
.
imagesDir
imageId
)
;
const
blob
=
await
File
.
createFromFileName
(
path
{
type
:
mimetype
}
)
;
await
IOUtils
.
setModificationTime
(
path
)
;
return
blob
;
}
async
#
download
(
imageId
)
{
const
client
=
new
KintoHttpClient
(
Services
.
prefs
.
getStringPref
(
RS_SERVER_PREF
)
)
;
const
{
recordId
}
=
this
.
#
getRecordIdAndMimetype
(
imageId
)
;
const
record
=
await
client
.
bucket
(
RS_MAIN_BUCKET
)
.
collection
(
RS_COLLECTION
)
.
getRecord
(
recordId
)
;
const
downloader
=
new
Downloader
(
RS_MAIN_BUCKET
RS_COLLECTION
)
;
const
arrayBuffer
=
await
downloader
.
downloadAsBytes
(
record
.
data
{
retries
:
RS_DOWNLOAD_MAX_RETRIES
}
)
;
const
path
=
PathUtils
.
join
(
this
.
imagesDir
imageId
)
;
IOUtils
.
write
(
path
new
Uint8Array
(
arrayBuffer
)
)
;
return
new
Blob
(
[
arrayBuffer
]
{
type
:
record
.
data
.
attachment
.
mimetype
}
)
;
}
}
const
RemoteImages
=
new
_RemoteImages
(
)
;
const
EXPORTED_SYMBOLS
=
[
"
RemoteImages
"
]
;
