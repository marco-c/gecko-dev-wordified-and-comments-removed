"
use
strict
"
;
const
{
JSONFile
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
sys
.
mjs
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
sys
.
mjs
"
)
;
const
{
RemoteSettings
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
Downloader
:
"
resource
:
/
/
services
-
settings
/
Attachments
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
KintoHttpClient
"
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
Utils
"
"
resource
:
/
/
services
-
settings
/
Utils
.
jsm
"
)
;
const
RS_MAIN_BUCKET
=
"
main
"
;
const
RS_COLLECTION
=
"
ms
-
images
"
;
const
RS_DOWNLOAD_MAX_RETRIES
=
2
;
const
REMOTE_IMAGES_PATH
=
PathUtils
.
join
(
PathUtils
.
localProfileDir
"
settings
"
RS_MAIN_BUCKET
RS_COLLECTION
)
;
const
REMOTE_IMAGES_DB_PATH
=
PathUtils
.
join
(
REMOTE_IMAGES_PATH
"
db
.
json
"
)
;
const
IMAGE_EXPIRY_DURATION
=
30
*
24
*
60
*
60
;
const
PREFETCH_FINISHED_TOPIC
=
"
remote
-
images
:
prefetch
-
finished
"
;
const
MessageInspectors
=
{
}
;
class
_RemoteImages
{
#
dbPromise
;
#
fetching
;
constructor
(
)
{
this
.
#
dbPromise
=
null
;
this
.
#
fetching
=
new
Map
(
)
;
RemoteSettings
(
RS_COLLECTION
)
.
on
(
"
sync
"
(
)
=
>
this
.
#
onSync
(
)
)
;
this
.
withDb
(
(
)
=
>
{
}
)
;
}
async
#
loadDb
(
)
{
let
db
;
if
(
!
(
await
IOUtils
.
exists
(
REMOTE_IMAGES_DB_PATH
)
)
)
{
db
=
await
this
.
#
migrate
(
)
;
}
else
{
db
=
new
JSONFile
(
{
path
:
REMOTE_IMAGES_DB_PATH
}
)
;
await
db
.
load
(
)
;
}
return
db
;
}
reset
(
)
{
return
this
.
withDb
(
async
db
=
>
{
this
.
#
dbPromise
=
null
;
await
db
.
finalize
(
)
;
}
)
;
}
async
withDb
(
fn
)
{
const
dbPromise
=
this
.
#
dbPromise
?
?
this
.
#
loadDb
(
)
;
const
{
resolve
promise
}
=
PromiseUtils
.
defer
(
)
;
this
.
#
dbPromise
=
promise
;
const
db
=
await
dbPromise
;
try
{
return
await
fn
(
db
)
;
}
finally
{
resolve
(
db
)
;
}
}
async
patchMessage
(
message
replaceWith
=
"
imageURL
"
)
{
if
(
!
!
message
&
&
!
!
message
.
imageId
)
{
const
{
imageId
}
=
message
;
const
urls
=
await
this
.
load
(
imageId
)
;
if
(
urls
.
size
)
{
const
blobURL
=
urls
.
get
(
imageId
)
;
delete
message
.
imageId
;
message
[
replaceWith
]
=
blobURL
;
return
(
)
=
>
this
.
unload
(
urls
)
;
}
}
return
null
;
}
load
(
.
.
.
imageIds
)
{
return
this
.
withDb
(
async
db
=
>
{
const
urls
=
new
Map
(
imageIds
.
map
(
key
=
>
[
key
undefined
]
)
)
;
await
Promise
.
all
(
Array
.
from
(
urls
.
keys
(
)
)
.
map
(
async
imageId
=
>
{
try
{
urls
.
set
(
imageId
await
this
.
#
loadImpl
(
db
imageId
)
)
;
}
catch
(
e
)
{
console
.
error
(
Could
not
load
image
ID
{
imageId
}
:
{
e
}
)
;
urls
.
delete
(
imageId
)
;
}
}
)
)
;
return
urls
;
}
)
;
}
async
#
loadImpl
(
db
imageId
)
{
const
recordId
=
this
.
#
getRecordId
(
imageId
)
;
if
(
this
.
#
fetching
.
has
(
imageId
)
)
{
const
{
record
arrayBuffer
}
=
await
this
.
#
fetching
.
get
(
imageId
)
;
return
new
Blob
(
[
arrayBuffer
]
{
type
:
record
.
data
.
attachment
.
mimetype
}
)
;
}
let
blob
;
if
(
db
.
data
.
images
[
recordId
]
)
{
try
{
blob
=
await
this
.
#
readFromDisk
(
db
recordId
)
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
Components
.
Exception
&
&
e
.
name
=
=
=
"
NS_ERROR_FILE_NOT_FOUND
"
)
)
{
throw
e
;
}
}
}
if
(
typeof
blob
=
=
=
"
undefined
"
)
{
blob
=
await
this
.
#
download
(
db
recordId
)
;
}
return
URL
.
createObjectURL
(
blob
)
;
}
unload
(
urls
)
{
for
(
const
url
of
urls
.
keys
(
)
)
{
URL
.
revokeObjectURL
(
url
)
;
}
}
#
onSync
(
)
{
return
this
.
withDb
(
async
db
=
>
{
await
this
.
#
cleanup
(
db
)
;
const
recordsById
=
await
RemoteSettings
(
RS_COLLECTION
)
.
db
.
list
(
)
.
then
(
records
=
>
Object
.
assign
(
{
}
.
.
.
records
.
map
(
record
=
>
(
{
[
record
.
id
]
:
record
}
)
)
)
)
;
await
Promise
.
all
(
Object
.
values
(
db
.
data
.
images
)
.
filter
(
entry
=
>
recordsById
[
entry
.
recordId
]
?
.
attachment
.
hash
!
=
=
entry
.
hash
)
.
map
(
entry
=
>
this
.
#
download
(
db
entry
.
recordId
{
fetchOnly
:
true
}
)
)
)
;
}
)
;
}
forceCleanup
(
)
{
return
this
.
withDb
(
db
=
>
this
.
#
cleanup
(
db
)
)
;
}
async
#
cleanup
(
db
)
{
const
now
=
Date
.
now
(
)
;
await
Promise
.
all
(
Object
.
values
(
db
.
data
.
images
)
.
filter
(
entry
=
>
now
-
entry
.
lastLoaded
>
=
IMAGE_EXPIRY_DURATION
)
.
map
(
entry
=
>
{
const
path
=
PathUtils
.
join
(
REMOTE_IMAGES_PATH
entry
.
recordId
)
;
delete
db
.
data
.
images
[
entry
.
recordId
]
;
return
IOUtils
.
remove
(
path
)
.
catch
(
e
=
>
{
console
.
error
(
Could
not
remove
remote
image
{
entry
.
recordId
}
:
{
e
}
)
;
}
)
;
}
)
)
;
db
.
saveSoon
(
)
;
}
#
getRecordId
(
imageId
)
{
const
idx
=
imageId
.
lastIndexOf
(
"
.
"
)
;
if
(
idx
=
=
=
-
1
)
{
return
imageId
;
}
return
imageId
.
substring
(
0
idx
)
;
}
async
#
readFromDisk
(
db
recordId
)
{
const
path
=
PathUtils
.
join
(
REMOTE_IMAGES_PATH
recordId
)
;
try
{
const
blob
=
await
File
.
createFromFileName
(
path
{
type
:
db
.
data
.
images
[
recordId
]
.
mimetype
}
)
;
db
.
data
.
images
[
recordId
]
.
lastLoaded
=
Date
.
now
(
)
;
return
blob
;
}
catch
(
e
)
{
delete
db
.
data
.
images
[
recordId
]
;
throw
e
;
}
finally
{
db
.
saveSoon
(
)
;
}
}
async
#
download
(
db
recordId
{
fetchOnly
=
false
}
=
{
}
)
{
const
{
record
arrayBuffer
}
=
await
this
.
#
unsafeDownload
(
recordId
)
;
const
{
mimetype
hash
}
=
record
.
data
.
attachment
;
if
(
fetchOnly
)
{
Object
.
assign
(
db
.
data
.
images
[
recordId
]
{
mimetype
hash
}
)
;
}
else
{
db
.
data
.
images
[
recordId
]
=
{
recordId
mimetype
hash
lastLoaded
:
Date
.
now
(
)
}
;
}
db
.
saveSoon
(
)
;
if
(
fetchOnly
)
{
return
undefined
;
}
return
new
Blob
(
[
arrayBuffer
]
{
type
:
record
.
data
.
attachment
.
mimetype
}
)
;
}
async
#
unsafeDownload
(
recordId
)
{
const
client
=
new
lazy
.
KintoHttpClient
(
lazy
.
Utils
.
SERVER_URL
)
;
const
record
=
await
client
.
bucket
(
RS_MAIN_BUCKET
)
.
collection
(
RS_COLLECTION
)
.
getRecord
(
recordId
)
;
const
downloader
=
new
lazy
.
Downloader
(
RS_MAIN_BUCKET
RS_COLLECTION
)
;
const
arrayBuffer
=
await
downloader
.
downloadAsBytes
(
record
.
data
{
retries
:
RS_DOWNLOAD_MAX_RETRIES
}
)
;
const
path
=
PathUtils
.
join
(
REMOTE_IMAGES_PATH
recordId
)
;
IOUtils
.
write
(
path
new
Uint8Array
(
arrayBuffer
)
)
;
return
{
record
arrayBuffer
}
;
}
async
prefetchImagesFor
(
messages
)
{
const
recordIds
=
messages
.
filter
(
message
=
>
message
.
template
&
&
Object
.
hasOwn
(
MessageInspectors
message
.
template
)
)
.
flatMap
(
message
=
>
MessageInspectors
[
message
.
template
]
(
message
)
)
.
map
(
imageId
=
>
this
.
#
getRecordId
(
imageId
)
)
;
if
(
recordIds
.
length
)
{
const
promises
=
await
this
.
withDb
(
db
=
>
new
Map
(
recordIds
.
reduce
(
(
entries
recordId
)
=
>
{
const
promise
=
this
.
#
beginPrefetch
(
db
recordId
)
;
if
(
promise
!
=
=
null
)
{
this
.
#
fetching
.
set
(
recordId
promise
)
;
entries
.
push
(
[
recordId
promise
]
)
;
}
return
entries
;
}
[
]
)
)
)
;
const
prefetchesFinished
=
Array
.
from
(
promises
.
entries
(
)
)
.
map
(
(
[
recordId
promise
]
)
=
>
promise
.
then
(
result
=
>
this
.
#
finishPrefetch
(
result
)
(
)
=
>
this
.
#
handleFailedPrefetch
(
recordId
)
)
)
;
await
Promise
.
all
(
prefetchesFinished
)
;
Services
.
obs
.
notifyObservers
(
null
PREFETCH_FINISHED_TOPIC
)
;
}
}
#
beginPrefetch
(
db
recordId
)
{
if
(
!
Object
.
hasOwn
(
db
.
data
.
images
recordId
)
)
{
const
promise
=
this
.
#
unsafeDownload
(
recordId
)
;
this
.
#
fetching
.
set
(
recordId
promise
)
;
return
promise
;
}
return
null
;
}
#
finishPrefetch
(
{
record
}
)
{
return
this
.
withDb
(
db
=
>
{
const
{
id
:
recordId
}
=
record
.
data
;
const
{
mimetype
hash
}
=
record
.
data
.
attachment
;
this
.
#
fetching
.
delete
(
recordId
)
;
db
.
data
.
images
[
recordId
]
=
{
recordId
mimetype
hash
lastLoaded
:
Date
.
now
(
)
}
;
db
.
saveSoon
(
)
;
}
)
;
}
#
handleFailedPrefetch
(
recordId
)
{
return
this
.
withDb
(
db
=
>
{
this
.
#
fetching
.
delete
(
recordId
)
;
}
)
;
}
async
#
migrate
(
)
{
let
children
;
try
{
children
=
await
IOUtils
.
getChildren
(
REMOTE_IMAGES_PATH
)
;
await
Promise
.
all
(
children
.
map
(
async
path
=
>
{
try
{
await
IOUtils
.
remove
(
path
)
;
}
catch
(
e
)
{
console
.
error
(
RemoteImages
could
not
delete
{
path
}
:
{
e
}
)
;
}
}
)
)
;
}
catch
(
e
)
{
if
(
!
(
DOMException
.
isInstance
(
e
)
&
&
e
.
name
=
=
=
"
NotFoundError
"
)
)
{
throw
e
;
}
}
await
IOUtils
.
makeDirectory
(
REMOTE_IMAGES_PATH
)
;
const
db
=
new
JSONFile
(
{
path
:
REMOTE_IMAGES_DB_PATH
}
)
;
db
.
data
=
{
version
:
1
images
:
{
}
}
;
db
.
saveSoon
(
)
;
return
db
;
}
}
const
RemoteImages
=
new
_RemoteImages
(
)
;
const
EXPORTED_SYMBOLS
=
[
"
RemoteImages
"
"
REMOTE_IMAGES_PATH
"
"
REMOTE_IMAGES_DB_PATH
"
]
;
