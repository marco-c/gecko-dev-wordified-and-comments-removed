"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
actionCreators
:
ac
actionTypes
:
at
actionUtils
:
au
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
jsm
"
)
;
const
{
shortURL
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
ShortURL
.
jsm
"
)
;
const
{
AboutNewTab
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
AboutNewTab
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PartnerLinkAttribution
"
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
pktApi
"
"
chrome
:
/
/
pocket
/
content
/
pktApi
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ExperimentAPI
"
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
}
)
;
const
LINK_BLOCKED_EVENT
=
"
newtab
-
linkBlocked
"
;
const
PLACES_LINKS_CHANGED_DELAY_TIME
=
1000
;
const
TOP_SITES_BLOCKED_SPONSORS_PREF
=
"
browser
.
topsites
.
blockedSponsors
"
;
class
Observer
{
constructor
(
dispatch
observerInterface
)
{
this
.
dispatch
=
dispatch
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
observerInterface
"
nsISupportsWeakReference
"
]
)
;
}
}
class
BookmarksObserver
extends
Observer
{
constructor
(
dispatch
)
{
super
(
dispatch
Ci
.
nsINavBookmarkObserver
)
;
this
.
skipTags
=
true
;
}
onItemChanged
(
)
{
}
}
class
PlacesObserver
extends
Observer
{
constructor
(
dispatch
)
{
super
(
dispatch
Ci
.
nsINavBookmarkObserver
)
;
this
.
handlePlacesEvent
=
this
.
handlePlacesEvent
.
bind
(
this
)
;
}
handlePlacesEvent
(
events
)
{
const
removedPages
=
[
]
;
const
removedBookmarks
=
[
]
;
for
(
const
{
itemType
source
dateAdded
guid
title
url
isRemovedFromStore
isTagging
type
}
of
events
)
{
switch
(
type
)
{
case
"
history
-
cleared
"
:
this
.
dispatch
(
{
type
:
at
.
PLACES_HISTORY_CLEARED
}
)
;
break
;
case
"
page
-
removed
"
:
if
(
isRemovedFromStore
)
{
removedPages
.
push
(
url
)
;
}
break
;
case
"
bookmark
-
added
"
:
if
(
isTagging
|
|
itemType
!
=
=
lazy
.
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
|
|
source
=
=
=
lazy
.
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
|
|
source
=
=
=
lazy
.
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
|
|
source
=
=
=
lazy
.
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
|
|
source
=
=
=
lazy
.
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
|
|
(
!
url
.
startsWith
(
"
http
:
/
/
"
)
&
&
!
url
.
startsWith
(
"
https
:
/
/
"
)
)
)
{
return
;
}
this
.
dispatch
(
{
type
:
at
.
PLACES_LINKS_CHANGED
}
)
;
this
.
dispatch
(
{
type
:
at
.
PLACES_BOOKMARK_ADDED
data
:
{
bookmarkGuid
:
guid
bookmarkTitle
:
title
dateAdded
:
dateAdded
*
1000
url
}
}
)
;
break
;
case
"
bookmark
-
removed
"
:
if
(
isTagging
|
|
(
itemType
=
=
=
lazy
.
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
&
&
source
!
=
=
lazy
.
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
&
&
source
!
=
=
lazy
.
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
&
&
source
!
=
=
lazy
.
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
&
&
source
!
=
=
lazy
.
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
)
)
{
removedBookmarks
.
push
(
url
)
;
}
break
;
}
}
if
(
removedPages
.
length
|
|
removedBookmarks
.
length
)
{
this
.
dispatch
(
{
type
:
at
.
PLACES_LINKS_CHANGED
}
)
;
}
if
(
removedPages
.
length
)
{
this
.
dispatch
(
{
type
:
at
.
PLACES_LINKS_DELETED
data
:
{
urls
:
removedPages
}
}
)
;
}
if
(
removedBookmarks
.
length
)
{
this
.
dispatch
(
{
type
:
at
.
PLACES_BOOKMARKS_REMOVED
data
:
{
urls
:
removedBookmarks
}
}
)
;
}
}
}
class
PlacesFeed
{
constructor
(
)
{
this
.
placesChangedTimer
=
null
;
this
.
customDispatch
=
this
.
customDispatch
.
bind
(
this
)
;
this
.
bookmarksObserver
=
new
BookmarksObserver
(
this
.
customDispatch
)
;
this
.
placesObserver
=
new
PlacesObserver
(
this
.
customDispatch
)
;
}
addObservers
(
)
{
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
bookmarks
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavBookmarksService
)
.
addObserver
(
this
.
bookmarksObserver
true
)
;
lazy
.
PlacesUtils
.
observers
.
addListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
"
history
-
cleared
"
"
page
-
removed
"
]
this
.
placesObserver
.
handlePlacesEvent
)
;
Services
.
obs
.
addObserver
(
this
LINK_BLOCKED_EVENT
)
;
}
setTimeout
(
callback
delay
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
callback
delay
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
customDispatch
(
action
)
{
if
(
action
.
type
=
=
=
at
.
PLACES_LINKS_CHANGED
)
{
if
(
this
.
placesChangedTimer
)
{
this
.
placesChangedTimer
.
delay
=
PLACES_LINKS_CHANGED_DELAY_TIME
;
}
else
{
this
.
placesChangedTimer
=
this
.
setTimeout
(
(
)
=
>
{
this
.
placesChangedTimer
=
null
;
this
.
store
.
dispatch
(
ac
.
OnlyToMain
(
action
)
)
;
}
PLACES_LINKS_CHANGED_DELAY_TIME
)
;
}
}
else
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
action
)
)
;
}
}
removeObservers
(
)
{
if
(
this
.
placesChangedTimer
)
{
this
.
placesChangedTimer
.
cancel
(
)
;
this
.
placesChangedTimer
=
null
;
}
lazy
.
PlacesUtils
.
bookmarks
.
removeObserver
(
this
.
bookmarksObserver
)
;
lazy
.
PlacesUtils
.
observers
.
removeListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
"
history
-
cleared
"
"
page
-
removed
"
]
this
.
placesObserver
.
handlePlacesEvent
)
;
Services
.
obs
.
removeObserver
(
this
LINK_BLOCKED_EVENT
)
;
}
observe
(
subject
topic
value
)
{
if
(
topic
=
=
=
LINK_BLOCKED_EVENT
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
PLACES_LINK_BLOCKED
data
:
{
url
:
value
}
}
)
)
;
}
}
openLink
(
action
where
=
"
"
isPrivate
=
false
)
{
const
params
=
{
private
:
isPrivate
targetBrowser
:
action
.
_target
.
browser
fromChrome
:
false
}
;
const
{
event
referrer
typedBonus
}
=
action
.
data
;
if
(
referrer
)
{
const
ReferrerInfo
=
Components
.
Constructor
(
"
mozilla
.
org
/
referrer
-
info
;
1
"
"
nsIReferrerInfo
"
"
init
"
)
;
params
.
referrerInfo
=
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
UNSAFE_URL
true
Services
.
io
.
newURI
(
referrer
)
)
;
}
const
urlToOpen
=
action
.
data
.
type
=
=
=
"
pocket
"
?
action
.
data
.
open_url
:
action
.
data
.
url
;
try
{
let
uri
=
Services
.
io
.
newURI
(
urlToOpen
)
;
if
(
!
[
"
http
"
"
https
"
]
.
includes
(
uri
.
scheme
)
)
{
throw
new
Error
(
Can
'
t
open
link
using
{
uri
.
scheme
}
protocol
from
the
new
tab
page
.
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
;
}
if
(
typedBonus
)
{
lazy
.
PlacesUtils
.
history
.
markPageAsTyped
(
Services
.
io
.
newURI
(
urlToOpen
)
)
;
}
const
win
=
action
.
_target
.
browser
.
ownerGlobal
;
win
.
openTrustedLinkIn
(
urlToOpen
where
|
|
win
.
whereToOpenLink
(
event
)
params
)
;
if
(
action
.
data
.
original_url
)
{
lazy
.
PlacesUtils
.
history
.
insert
(
{
url
:
action
.
data
.
original_url
visits
:
[
{
transition
:
lazy
.
PlacesUtils
.
history
.
TRANSITION_TYPED
}
]
}
)
;
}
}
async
saveToPocket
(
site
browser
)
{
const
sendToPocket
=
lazy
.
NimbusFeatures
.
pocketNewtab
.
getVariable
(
"
sendToPocket
"
)
;
if
(
sendToPocket
&
&
!
lazy
.
pktApi
.
isUserLoggedIn
(
)
)
{
const
pocketNewtabExperiment
=
lazy
.
ExperimentAPI
.
getExperiment
(
{
featureId
:
"
pocketNewtab
"
}
)
;
const
pocketSiteHost
=
Services
.
prefs
.
getStringPref
(
"
extensions
.
pocket
.
site
"
)
;
let
utmSource
=
"
firefox_newtab_save_button
"
;
let
utmCampaign
=
pocketNewtabExperiment
?
.
slug
;
let
utmContent
=
pocketNewtabExperiment
?
.
branch
?
.
slug
;
const
url
=
new
URL
(
https
:
/
/
{
pocketSiteHost
}
/
ff_signup
)
;
url
.
searchParams
.
append
(
"
utmSource
"
utmSource
)
;
if
(
utmCampaign
&
&
utmContent
)
{
url
.
searchParams
.
append
(
"
utmCampaign
"
utmCampaign
)
;
url
.
searchParams
.
append
(
"
utmContent
"
utmContent
)
;
}
const
win
=
browser
.
ownerGlobal
;
win
.
openTrustedLinkIn
(
url
.
href
"
tab
"
)
;
return
;
}
const
{
url
title
}
=
site
;
try
{
let
data
=
await
lazy
.
NewTabUtils
.
activityStreamLinks
.
addPocketEntry
(
url
title
browser
)
;
if
(
data
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
PLACES_SAVED_TO_POCKET
data
:
{
url
open_url
:
data
.
item
.
open_url
title
pocket_id
:
data
.
item
.
item_id
}
}
)
)
;
}
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
async
deleteFromPocket
(
itemID
)
{
try
{
await
lazy
.
NewTabUtils
.
activityStreamLinks
.
deletePocketEntry
(
itemID
)
;
this
.
store
.
dispatch
(
{
type
:
at
.
POCKET_LINK_DELETED_OR_ARCHIVED
}
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
async
archiveFromPocket
(
itemID
)
{
try
{
await
lazy
.
NewTabUtils
.
activityStreamLinks
.
archivePocketEntry
(
itemID
)
;
this
.
store
.
dispatch
(
{
type
:
at
.
POCKET_LINK_DELETED_OR_ARCHIVED
}
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
makeAttributionRequest
(
data
)
{
let
args
=
Object
.
assign
(
{
campaignID
:
Services
.
prefs
.
getStringPref
(
"
browser
.
partnerlink
.
campaign
.
topsites
"
)
}
data
)
;
lazy
.
PartnerLinkAttribution
.
makeRequest
(
args
)
;
}
async
fillSearchTopSiteTerm
(
{
_target
data
}
)
{
const
searchEngine
=
await
Services
.
search
.
getEngineByAlias
(
data
.
label
)
;
_target
.
browser
.
ownerGlobal
.
gURLBar
.
search
(
data
.
label
{
searchEngine
searchModeEntry
:
"
topsites_newtab
"
}
)
;
}
_getDefaultSearchEngine
(
isPrivateWindow
)
{
return
Services
.
search
[
isPrivateWindow
?
"
defaultPrivateEngine
"
:
"
defaultEngine
"
]
;
}
handoffSearchToAwesomebar
(
action
)
{
const
{
_target
data
meta
}
=
action
;
const
searchEngine
=
this
.
_getDefaultSearchEngine
(
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
_target
.
browser
)
)
;
const
urlBar
=
_target
.
browser
.
ownerGlobal
.
gURLBar
;
let
isFirstChange
=
true
;
const
newtabSession
=
AboutNewTab
.
activityStream
.
store
.
feeds
.
get
(
"
feeds
.
telemetry
"
)
?
.
sessions
.
get
(
au
.
getPortIdOfSender
(
action
)
)
;
if
(
!
data
|
|
!
data
.
text
)
{
urlBar
.
setHiddenFocus
(
)
;
}
else
{
urlBar
.
handoff
(
data
.
text
searchEngine
newtabSession
?
.
session_id
)
;
isFirstChange
=
false
;
}
const
checkFirstChange
=
(
)
=
>
{
if
(
isFirstChange
)
{
isFirstChange
=
false
;
urlBar
.
removeHiddenFocus
(
true
)
;
urlBar
.
handoff
(
"
"
searchEngine
newtabSession
?
.
session_id
)
;
this
.
store
.
dispatch
(
ac
.
OnlyToOneContent
(
{
type
:
at
.
DISABLE_SEARCH
}
meta
.
fromTarget
)
)
;
urlBar
.
removeEventListener
(
"
compositionstart
"
checkFirstChange
)
;
urlBar
.
removeEventListener
(
"
paste
"
checkFirstChange
)
;
}
}
;
const
onKeydown
=
ev
=
>
{
if
(
ev
.
key
.
length
=
=
=
1
&
&
!
ev
.
altKey
&
&
!
ev
.
ctrlKey
&
&
!
ev
.
metaKey
)
{
checkFirstChange
(
)
;
}
if
(
ev
.
key
=
=
=
"
Escape
"
)
{
onDone
(
)
;
}
}
;
const
onDone
=
ev
=
>
{
this
.
store
.
dispatch
(
ac
.
OnlyToOneContent
(
{
type
:
at
.
SHOW_SEARCH
}
meta
.
fromTarget
)
)
;
const
forceSuppressFocusBorder
=
ev
?
.
type
=
=
=
"
mousedown
"
;
urlBar
.
removeHiddenFocus
(
forceSuppressFocusBorder
)
;
urlBar
.
removeEventListener
(
"
keydown
"
onKeydown
)
;
urlBar
.
removeEventListener
(
"
mousedown
"
onDone
)
;
urlBar
.
removeEventListener
(
"
blur
"
onDone
)
;
urlBar
.
removeEventListener
(
"
compositionstart
"
checkFirstChange
)
;
urlBar
.
removeEventListener
(
"
paste
"
checkFirstChange
)
;
}
;
urlBar
.
addEventListener
(
"
keydown
"
onKeydown
)
;
urlBar
.
addEventListener
(
"
mousedown
"
onDone
)
;
urlBar
.
addEventListener
(
"
blur
"
onDone
)
;
urlBar
.
addEventListener
(
"
compositionstart
"
checkFirstChange
)
;
urlBar
.
addEventListener
(
"
paste
"
checkFirstChange
)
;
}
addToBlockedTopSitesSponsors
(
urls
)
{
const
blockedPref
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
TOP_SITES_BLOCKED_SPONSORS_PREF
"
[
]
"
)
)
;
const
merged
=
new
Set
(
[
.
.
.
blockedPref
.
.
.
urls
.
map
(
url
=
>
shortURL
(
url
)
)
]
)
;
Services
.
prefs
.
setStringPref
(
TOP_SITES_BLOCKED_SPONSORS_PREF
JSON
.
stringify
(
[
.
.
.
merged
]
)
)
;
}
onAction
(
action
)
{
switch
(
action
.
type
)
{
case
at
.
INIT
:
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
this
.
addObservers
(
)
)
;
break
;
case
at
.
UNINIT
:
this
.
removeObservers
(
)
;
break
;
case
at
.
ABOUT_SPONSORED_TOP_SITES
:
{
const
url
=
{
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
}
sponsor
-
privacy
;
const
win
=
action
.
_target
.
browser
.
ownerGlobal
;
win
.
openTrustedLinkIn
(
url
"
tab
"
)
;
break
;
}
case
at
.
BLOCK_URL
:
{
if
(
action
.
data
)
{
let
sponsoredTopSites
=
[
]
;
action
.
data
.
forEach
(
site
=
>
{
const
{
url
pocket_id
isSponsoredTopSite
}
=
site
;
lazy
.
NewTabUtils
.
activityStreamLinks
.
blockURL
(
{
url
pocket_id
}
)
;
if
(
isSponsoredTopSite
)
{
sponsoredTopSites
.
push
(
{
url
}
)
;
}
}
)
;
if
(
sponsoredTopSites
.
length
)
{
this
.
addToBlockedTopSitesSponsors
(
sponsoredTopSites
)
;
}
}
break
;
}
case
at
.
BOOKMARK_URL
:
lazy
.
NewTabUtils
.
activityStreamLinks
.
addBookmark
(
action
.
data
action
.
_target
.
browser
.
ownerGlobal
)
;
break
;
case
at
.
DELETE_BOOKMARK_BY_ID
:
lazy
.
NewTabUtils
.
activityStreamLinks
.
deleteBookmark
(
action
.
data
)
;
break
;
case
at
.
DELETE_HISTORY_URL
:
{
const
{
url
forceBlock
pocket_id
}
=
action
.
data
;
lazy
.
NewTabUtils
.
activityStreamLinks
.
deleteHistoryEntry
(
url
)
;
if
(
forceBlock
)
{
lazy
.
NewTabUtils
.
activityStreamLinks
.
blockURL
(
{
url
pocket_id
}
)
;
}
break
;
}
case
at
.
OPEN_NEW_WINDOW
:
this
.
openLink
(
action
"
window
"
)
;
break
;
case
at
.
OPEN_PRIVATE_WINDOW
:
this
.
openLink
(
action
"
window
"
true
)
;
break
;
case
at
.
SAVE_TO_POCKET
:
this
.
saveToPocket
(
action
.
data
.
site
action
.
_target
.
browser
)
;
break
;
case
at
.
DELETE_FROM_POCKET
:
this
.
deleteFromPocket
(
action
.
data
.
pocket_id
)
;
break
;
case
at
.
ARCHIVE_FROM_POCKET
:
this
.
archiveFromPocket
(
action
.
data
.
pocket_id
)
;
break
;
case
at
.
FILL_SEARCH_TERM
:
this
.
fillSearchTopSiteTerm
(
action
)
;
break
;
case
at
.
HANDOFF_SEARCH_TO_AWESOMEBAR
:
this
.
handoffSearchToAwesomebar
(
action
)
;
break
;
case
at
.
OPEN_LINK
:
{
this
.
openLink
(
action
)
;
break
;
}
case
at
.
PARTNER_LINK_ATTRIBUTION
:
this
.
makeAttributionRequest
(
action
.
data
)
;
break
;
}
}
}
PlacesFeed
.
BookmarksObserver
=
BookmarksObserver
;
PlacesFeed
.
PlacesObserver
=
PlacesObserver
;
const
EXPORTED_SYMBOLS
=
[
"
PlacesFeed
"
]
;
