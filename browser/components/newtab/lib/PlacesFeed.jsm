"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
actionCreators
:
ac
actionTypes
:
at
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
jsm
"
{
}
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
LINK_BLOCKED_EVENT
=
"
newtab
-
linkBlocked
"
;
const
PLACES_LINKS_CHANGED_DELAY_TIME
=
1000
;
class
Observer
{
constructor
(
dispatch
observerInterface
)
{
this
.
dispatch
=
dispatch
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
observerInterface
Ci
.
nsISupportsWeakReference
]
)
;
}
}
class
HistoryObserver
extends
Observer
{
constructor
(
dispatch
)
{
super
(
dispatch
Ci
.
nsINavHistoryObserver
)
;
}
onDeleteURI
(
uri
)
{
this
.
dispatch
(
{
type
:
at
.
PLACES_LINKS_CHANGED
}
)
;
this
.
dispatch
(
{
type
:
at
.
PLACES_LINK_DELETED
data
:
{
url
:
uri
.
spec
}
}
)
;
}
onClearHistory
(
)
{
this
.
dispatch
(
{
type
:
at
.
PLACES_HISTORY_CLEARED
}
)
;
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onTitleChanged
(
)
{
}
onFrecencyChanged
(
)
{
}
onManyFrecenciesChanged
(
)
{
}
onPageChanged
(
)
{
}
onDeleteVisits
(
)
{
}
}
class
BookmarksObserver
extends
Observer
{
constructor
(
dispatch
)
{
super
(
dispatch
Ci
.
nsINavBookmarkObserver
)
;
this
.
skipTags
=
true
;
}
onItemAdded
(
id
folderId
index
type
uri
bookmarkTitle
dateAdded
bookmarkGuid
parentGuid
source
)
{
if
(
type
!
=
=
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
|
|
source
=
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
|
|
source
=
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
|
|
source
=
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
|
|
source
=
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
|
|
(
uri
.
scheme
!
=
=
"
http
"
&
&
uri
.
scheme
!
=
=
"
https
"
)
)
{
return
;
}
this
.
dispatch
(
{
type
:
at
.
PLACES_LINKS_CHANGED
}
)
;
this
.
dispatch
(
{
type
:
at
.
PLACES_BOOKMARK_ADDED
data
:
{
bookmarkGuid
bookmarkTitle
dateAdded
url
:
uri
.
spec
}
}
)
;
}
onItemRemoved
(
id
folderId
index
type
uri
guid
parentGuid
source
)
{
if
(
type
=
=
=
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
&
&
source
!
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
&
&
source
!
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
&
&
source
!
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
&
&
source
!
=
=
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
)
{
this
.
dispatch
(
{
type
:
at
.
PLACES_LINKS_CHANGED
}
)
;
this
.
dispatch
(
{
type
:
at
.
PLACES_BOOKMARK_REMOVED
data
:
{
url
:
uri
.
spec
bookmarkGuid
:
guid
}
}
)
;
}
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onItemVisited
(
)
{
}
onItemMoved
(
)
{
}
onItemChanged
(
)
{
}
}
class
PlacesFeed
{
constructor
(
)
{
this
.
placesChangedTimer
=
null
;
this
.
customDispatch
=
this
.
customDispatch
.
bind
(
this
)
;
this
.
historyObserver
=
new
HistoryObserver
(
this
.
customDispatch
)
;
this
.
bookmarksObserver
=
new
BookmarksObserver
(
this
.
customDispatch
)
;
}
addObservers
(
)
{
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavHistoryService
)
.
addObserver
(
this
.
historyObserver
true
)
;
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
bookmarks
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavBookmarksService
)
.
addObserver
(
this
.
bookmarksObserver
true
)
;
Services
.
obs
.
addObserver
(
this
LINK_BLOCKED_EVENT
)
;
}
setTimeout
(
callback
delay
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
callback
delay
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
customDispatch
(
action
)
{
if
(
action
.
type
=
=
=
at
.
PLACES_LINKS_CHANGED
)
{
if
(
this
.
placesChangedTimer
)
{
this
.
placesChangedTimer
.
delay
=
PLACES_LINKS_CHANGED_DELAY_TIME
;
}
else
{
this
.
placesChangedTimer
=
this
.
setTimeout
(
(
)
=
>
{
this
.
placesChangedTimer
=
null
;
this
.
store
.
dispatch
(
ac
.
OnlyToMain
(
action
)
)
;
}
PLACES_LINKS_CHANGED_DELAY_TIME
)
;
}
}
else
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
action
)
)
;
}
}
removeObservers
(
)
{
if
(
this
.
placesChangedTimer
)
{
this
.
placesChangedTimer
.
cancel
(
)
;
this
.
placesChangedTimer
=
null
;
}
PlacesUtils
.
history
.
removeObserver
(
this
.
historyObserver
)
;
PlacesUtils
.
bookmarks
.
removeObserver
(
this
.
bookmarksObserver
)
;
Services
.
obs
.
removeObserver
(
this
LINK_BLOCKED_EVENT
)
;
}
observe
(
subject
topic
value
)
{
if
(
topic
=
=
=
LINK_BLOCKED_EVENT
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
PLACES_LINK_BLOCKED
data
:
{
url
:
value
}
}
)
)
;
}
}
openLink
(
action
where
=
"
"
isPrivate
=
false
)
{
const
params
=
{
private
:
isPrivate
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
}
;
const
{
event
referrer
typedBonus
}
=
action
.
data
;
if
(
referrer
)
{
params
.
referrerPolicy
=
Ci
.
nsIHttpChannel
.
REFERRER_POLICY_UNSAFE_URL
;
params
.
referrerURI
=
Services
.
io
.
newURI
(
referrer
)
;
}
const
urlToOpen
=
action
.
data
.
type
=
=
=
"
pocket
"
?
action
.
data
.
open_url
:
action
.
data
.
url
;
if
(
typedBonus
)
{
PlacesUtils
.
history
.
markPageAsTyped
(
Services
.
io
.
newURI
(
urlToOpen
)
)
;
}
const
win
=
action
.
_target
.
browser
.
ownerGlobal
;
win
.
openLinkIn
(
urlToOpen
where
|
|
win
.
whereToOpenLink
(
event
)
params
)
;
}
async
saveToPocket
(
site
browser
)
{
const
{
url
title
}
=
site
;
try
{
let
data
=
await
NewTabUtils
.
activityStreamLinks
.
addPocketEntry
(
url
title
browser
)
;
if
(
data
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
PLACES_SAVED_TO_POCKET
data
:
{
url
open_url
:
data
.
item
.
open_url
title
pocket_id
:
data
.
item
.
item_id
}
}
)
)
;
}
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
onAction
(
action
)
{
switch
(
action
.
type
)
{
case
at
.
INIT
:
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
this
.
addObservers
(
)
)
;
break
;
case
at
.
UNINIT
:
this
.
removeObservers
(
)
;
break
;
case
at
.
BLOCK_URL
:
{
const
{
url
pocket_id
}
=
action
.
data
;
NewTabUtils
.
activityStreamLinks
.
blockURL
(
{
url
pocket_id
}
)
;
break
;
}
case
at
.
BOOKMARK_URL
:
NewTabUtils
.
activityStreamLinks
.
addBookmark
(
action
.
data
action
.
_target
.
browser
.
ownerGlobal
)
;
break
;
case
at
.
DELETE_BOOKMARK_BY_ID
:
NewTabUtils
.
activityStreamLinks
.
deleteBookmark
(
action
.
data
)
;
break
;
case
at
.
DELETE_HISTORY_URL
:
{
const
{
url
forceBlock
pocket_id
}
=
action
.
data
;
NewTabUtils
.
activityStreamLinks
.
deleteHistoryEntry
(
url
)
;
if
(
forceBlock
)
{
NewTabUtils
.
activityStreamLinks
.
blockURL
(
{
url
pocket_id
}
)
;
}
break
;
}
case
at
.
OPEN_NEW_WINDOW
:
this
.
openLink
(
action
"
window
"
)
;
break
;
case
at
.
OPEN_PRIVATE_WINDOW
:
this
.
openLink
(
action
"
window
"
true
)
;
break
;
case
at
.
SAVE_TO_POCKET
:
this
.
saveToPocket
(
action
.
data
.
site
action
.
_target
.
browser
)
;
break
;
case
at
.
OPEN_LINK
:
{
this
.
openLink
(
action
)
;
break
;
}
}
}
}
this
.
PlacesFeed
=
PlacesFeed
;
PlacesFeed
.
HistoryObserver
=
HistoryObserver
;
PlacesFeed
.
BookmarksObserver
=
BookmarksObserver
;
const
EXPORTED_SYMBOLS
=
[
"
PlacesFeed
"
]
;
