const
FXA_ENABLED_PREF
=
"
identity
.
fxaccounts
.
enabled
"
;
const
DISTRIBUTION_ID_PREF
=
"
distribution
.
id
"
;
const
DISTRIBUTION_ID_CHINA_REPACK
=
"
MozillaOnline
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ASRouterPreferences
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterPreferences
.
jsm
"
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
ClientEnvironment
:
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
NewTabUtils
:
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
ProfileAge
:
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
ShellService
:
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
AttributionCode
:
"
resource
:
/
/
/
modules
/
AttributionCode
.
jsm
"
TargetingContext
:
"
resource
:
/
/
messaging
-
system
/
targeting
/
Targeting
.
jsm
"
fxAccounts
:
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
jsm
"
TelemetrySession
:
"
resource
:
/
/
gre
/
modules
/
TelemetrySession
.
jsm
"
HomePage
:
"
resource
:
/
/
/
modules
/
HomePage
.
jsm
"
AboutNewTab
:
"
resource
:
/
/
/
modules
/
AboutNewTab
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
cfrFeaturesUserPref
"
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
features
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
cfrAddonsUserPref
"
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
addons
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
isWhatsNewPanelEnabled
"
"
browser
.
messaging
-
system
.
whatsNewPanel
.
enabled
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
hasAccessedFxAPanel
"
"
identity
.
fxaccounts
.
toolbar
.
accessed
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
clientsDevicesDesktop
"
"
services
.
sync
.
clients
.
devices
.
desktop
"
0
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
clientsDevicesMobile
"
"
services
.
sync
.
clients
.
devices
.
mobile
"
0
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
syncNumClients
"
"
services
.
sync
.
numClients
"
0
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
devtoolsSelfXSSCount
"
"
devtools
.
selfxss
.
count
"
0
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
isFxAEnabled
"
FXA_ENABLED_PREF
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
isXPIInstallEnabled
"
"
xpinstall
.
enabled
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
snippetsUserPref
"
"
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
snippets
"
false
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
BrowserHandler
:
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
"
nsIBrowserHandler
"
]
TrackingDBService
:
[
"
mozilla
.
org
/
tracking
-
db
-
service
;
1
"
"
nsITrackingDBService
"
]
}
)
;
const
FXA_USERNAME_PREF
=
"
services
.
sync
.
username
"
;
const
{
activityStreamProvider
:
asProvider
}
=
NewTabUtils
;
const
FXA_ATTACHED_CLIENTS_UPDATE_INTERVAL
=
4
*
60
*
60
*
1000
;
const
FRECENT_SITES_UPDATE_INTERVAL
=
6
*
60
*
60
*
1000
;
const
FRECENT_SITES_IGNORE_BLOCKED
=
false
;
const
FRECENT_SITES_NUM_ITEMS
=
25
;
const
FRECENT_SITES_MIN_FRECENCY
=
100
;
const
CACHE_EXPIRATION
=
5
*
60
*
1000
;
const
jexlEvaluationCache
=
new
Map
(
)
;
function
CachedTargetingGetter
(
property
options
=
null
updateInterval
=
FRECENT_SITES_UPDATE_INTERVAL
getter
=
asProvider
)
{
return
{
_lastUpdated
:
0
_value
:
null
expire
(
)
{
this
.
_lastUpdated
=
0
;
this
.
_value
=
null
;
}
async
get
(
)
{
const
now
=
Date
.
now
(
)
;
if
(
now
-
this
.
_lastUpdated
>
=
updateInterval
)
{
this
.
_value
=
await
getter
[
property
]
(
options
)
;
this
.
_lastUpdated
=
now
;
}
return
this
.
_value
;
}
}
;
}
function
CacheListAttachedOAuthClients
(
)
{
return
{
_lastUpdated
:
0
_value
:
null
expire
(
)
{
this
.
_lastUpdated
=
0
;
this
.
_value
=
null
;
}
get
(
)
{
const
now
=
Date
.
now
(
)
;
if
(
now
-
this
.
_lastUpdated
>
=
FXA_ATTACHED_CLIENTS_UPDATE_INTERVAL
)
{
this
.
_value
=
new
Promise
(
resolve
=
>
{
fxAccounts
.
listAttachedOAuthClients
(
)
.
then
(
clients
=
>
{
resolve
(
clients
)
;
}
)
.
catch
(
(
)
=
>
resolve
(
[
]
)
)
;
}
)
;
this
.
_lastUpdated
=
now
;
}
return
this
.
_value
;
}
}
;
}
function
CheckBrowserNeedsUpdate
(
updateInterval
=
FRECENT_SITES_UPDATE_INTERVAL
)
{
const
UpdateChecker
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
checker
;
1
"
]
;
const
checker
=
{
_lastUpdated
:
0
_value
:
null
setUp
(
value
)
{
this
.
_lastUpdated
=
Date
.
now
(
)
;
this
.
_value
=
value
;
}
expire
(
)
{
this
.
_lastUpdated
=
0
;
this
.
_value
=
null
;
}
get
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
now
=
Date
.
now
(
)
;
const
updateServiceListener
=
{
onCheckComplete
(
request
updates
)
{
checker
.
_value
=
!
!
updates
.
length
;
resolve
(
checker
.
_value
)
;
}
onError
(
request
update
)
{
reject
(
request
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheckListener
"
]
)
}
;
if
(
UpdateChecker
&
&
now
-
this
.
_lastUpdated
>
=
updateInterval
)
{
const
checkerInstance
=
UpdateChecker
.
createInstance
(
Ci
.
nsIUpdateChecker
)
;
if
(
checkerInstance
.
canCheckForUpdates
)
{
checkerInstance
.
checkForUpdates
(
updateServiceListener
true
)
;
this
.
_lastUpdated
=
now
;
}
else
{
resolve
(
false
)
;
}
}
else
{
resolve
(
this
.
_value
)
;
}
}
)
;
}
}
;
return
checker
;
}
const
QueryCache
=
{
expireAll
(
)
{
Object
.
keys
(
this
.
queries
)
.
forEach
(
query
=
>
{
this
.
queries
[
query
]
.
expire
(
)
;
}
)
;
Object
.
keys
(
this
.
getters
)
.
forEach
(
key
=
>
{
this
.
getters
[
key
]
.
expire
(
)
;
}
)
;
}
queries
:
{
TopFrecentSites
:
new
CachedTargetingGetter
(
"
getTopFrecentSites
"
{
ignoreBlocked
:
FRECENT_SITES_IGNORE_BLOCKED
numItems
:
FRECENT_SITES_NUM_ITEMS
topsiteFrecency
:
FRECENT_SITES_MIN_FRECENCY
onePerDomain
:
true
includeFavicon
:
false
}
)
TotalBookmarksCount
:
new
CachedTargetingGetter
(
"
getTotalBookmarksCount
"
)
CheckBrowserNeedsUpdate
:
new
CheckBrowserNeedsUpdate
(
)
RecentBookmarks
:
new
CachedTargetingGetter
(
"
getRecentBookmarks
"
)
ListAttachedOAuthClients
:
new
CacheListAttachedOAuthClients
(
)
UserMonthlyActivity
:
new
CachedTargetingGetter
(
"
getUserMonthlyActivity
"
)
}
getters
:
{
doesAppNeedPin
:
new
CachedTargetingGetter
(
"
doesAppNeedPin
"
null
FRECENT_SITES_UPDATE_INTERVAL
ShellService
)
}
}
;
function
sortMessagesByWeightedRank
(
messages
)
{
return
messages
.
map
(
message
=
>
(
{
message
rank
:
Math
.
pow
(
Math
.
random
(
)
1
/
message
.
weight
)
}
)
)
.
sort
(
(
a
b
)
=
>
b
.
rank
-
a
.
rank
)
.
map
(
(
{
message
}
)
=
>
message
)
;
}
function
getSortedMessages
(
messages
options
=
{
}
)
{
let
{
ordered
}
=
{
ordered
:
false
.
.
.
options
}
;
let
result
=
messages
;
if
(
!
ordered
)
{
result
=
sortMessagesByWeightedRank
(
result
)
;
}
result
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
priority
>
b
.
priority
|
|
(
!
isNaN
(
a
.
priority
)
&
&
isNaN
(
b
.
priority
)
)
)
{
return
-
1
;
}
if
(
a
.
priority
<
b
.
priority
|
|
(
isNaN
(
a
.
priority
)
&
&
!
isNaN
(
b
.
priority
)
)
)
{
return
1
;
}
if
(
a
.
targeting
&
&
!
b
.
targeting
)
{
return
-
1
;
}
if
(
!
a
.
targeting
&
&
b
.
targeting
)
{
return
1
;
}
if
(
ordered
)
{
if
(
a
.
order
>
b
.
order
|
|
(
!
isNaN
(
a
.
order
)
&
&
isNaN
(
b
.
order
)
)
)
{
return
1
;
}
if
(
a
.
order
<
b
.
order
|
|
(
isNaN
(
a
.
order
)
&
&
!
isNaN
(
b
.
order
)
)
)
{
return
-
1
;
}
}
return
0
;
}
)
;
return
result
;
}
function
parseAboutPageURL
(
url
)
{
let
ret
=
{
isWebExt
:
false
isCustomUrl
:
false
urls
:
[
]
}
;
if
(
url
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
)
{
ret
.
isWebExt
=
true
;
ret
.
urls
.
push
(
{
url
host
:
"
"
}
)
;
}
else
{
for
(
const
_url
of
url
.
split
(
"
|
"
)
)
{
if
(
!
[
"
about
:
home
"
"
about
:
newtab
"
"
about
:
blank
"
]
.
includes
(
_url
)
)
{
ret
.
isCustomUrl
=
true
;
}
try
{
const
parsedURL
=
new
URL
(
_url
)
;
const
host
=
parsedURL
.
hostname
.
replace
(
/
^
www
\
.
/
i
"
"
)
;
ret
.
urls
.
push
(
{
url
:
_url
host
}
)
;
}
catch
(
e
)
{
}
}
if
(
!
ret
.
urls
.
length
)
{
ret
.
urls
.
push
(
{
url
host
:
"
"
}
)
;
}
}
return
ret
;
}
const
TargetingGetters
=
{
get
locale
(
)
{
return
Services
.
locale
.
appLocaleAsBCP47
;
}
get
localeLanguageCode
(
)
{
return
(
Services
.
locale
.
appLocaleAsBCP47
&
&
Services
.
locale
.
appLocaleAsBCP47
.
substr
(
0
2
)
)
;
}
get
browserSettings
(
)
{
const
{
settings
}
=
TelemetryEnvironment
.
currentEnvironment
;
return
{
update
:
settings
.
update
}
;
}
get
attributionData
(
)
{
return
AttributionCode
.
getCachedAttributionData
(
)
;
}
get
currentDate
(
)
{
return
new
Date
(
)
;
}
get
profileAgeCreated
(
)
{
return
ProfileAge
(
)
.
then
(
times
=
>
times
.
created
)
;
}
get
profileAgeReset
(
)
{
return
ProfileAge
(
)
.
then
(
times
=
>
times
.
reset
)
;
}
get
usesFirefoxSync
(
)
{
return
Services
.
prefs
.
prefHasUserValue
(
FXA_USERNAME_PREF
)
;
}
get
isFxAEnabled
(
)
{
return
isFxAEnabled
;
}
get
sync
(
)
{
return
{
desktopDevices
:
clientsDevicesDesktop
mobileDevices
:
clientsDevicesMobile
totalDevices
:
syncNumClients
}
;
}
get
xpinstallEnabled
(
)
{
return
isXPIInstallEnabled
;
}
get
addonsInfo
(
)
{
return
AddonManager
.
getActiveAddons
(
[
"
extension
"
"
service
"
]
)
.
then
(
(
{
addons
fullData
}
)
=
>
{
const
info
=
{
}
;
for
(
const
addon
of
addons
)
{
info
[
addon
.
id
]
=
{
version
:
addon
.
version
type
:
addon
.
type
isSystem
:
addon
.
isSystem
isWebExtension
:
addon
.
isWebExtension
}
;
if
(
fullData
)
{
Object
.
assign
(
info
[
addon
.
id
]
{
name
:
addon
.
name
userDisabled
:
addon
.
userDisabled
installDate
:
addon
.
installDate
}
)
;
}
}
return
{
addons
:
info
isFullData
:
fullData
}
;
}
)
;
}
get
searchEngines
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
search
.
getAppProvidedEngines
(
)
.
then
(
engines
=
>
{
resolve
(
{
current
:
Services
.
search
.
defaultEngine
.
identifier
installed
:
engines
.
map
(
engine
=
>
engine
.
identifier
)
}
)
;
}
)
.
catch
(
(
)
=
>
resolve
(
{
installed
:
[
]
current
:
"
"
}
)
)
;
}
)
;
}
get
isDefaultBrowser
(
)
{
try
{
return
ShellService
.
isDefaultBrowser
(
)
;
}
catch
(
e
)
{
}
return
null
;
}
get
devToolsOpenedCount
(
)
{
return
devtoolsSelfXSSCount
;
}
get
topFrecentSites
(
)
{
return
QueryCache
.
queries
.
TopFrecentSites
.
get
(
)
.
then
(
sites
=
>
sites
.
map
(
site
=
>
(
{
url
:
site
.
url
host
:
new
URL
(
site
.
url
)
.
hostname
frecency
:
site
.
frecency
lastVisitDate
:
site
.
lastVisitDate
}
)
)
)
;
}
get
recentBookmarks
(
)
{
return
QueryCache
.
queries
.
RecentBookmarks
.
get
(
)
;
}
get
pinnedSites
(
)
{
return
NewTabUtils
.
pinnedLinks
.
links
.
map
(
site
=
>
site
?
{
url
:
site
.
url
host
:
new
URL
(
site
.
url
)
.
hostname
searchTopSite
:
site
.
searchTopSite
}
:
{
}
)
;
}
get
providerCohorts
(
)
{
return
ASRouterPreferences
.
providers
.
reduce
(
(
prev
current
)
=
>
{
prev
[
current
.
id
]
=
current
.
cohort
|
|
"
"
;
return
prev
;
}
{
}
)
;
}
get
totalBookmarksCount
(
)
{
return
QueryCache
.
queries
.
TotalBookmarksCount
.
get
(
)
;
}
get
firefoxVersion
(
)
{
return
parseInt
(
AppConstants
.
MOZ_APP_VERSION
.
match
(
/
\
d
+
/
)
10
)
;
}
get
region
(
)
{
return
Region
.
home
|
|
"
"
;
}
get
needsUpdate
(
)
{
return
QueryCache
.
queries
.
CheckBrowserNeedsUpdate
.
get
(
)
;
}
get
hasPinnedTabs
(
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
win
.
closed
|
|
!
win
.
ownerGlobal
.
gBrowser
)
{
continue
;
}
if
(
win
.
ownerGlobal
.
gBrowser
.
visibleTabs
.
filter
(
t
=
>
t
.
pinned
)
.
length
)
{
return
true
;
}
}
return
false
;
}
get
hasAccessedFxAPanel
(
)
{
return
hasAccessedFxAPanel
;
}
get
isWhatsNewPanelEnabled
(
)
{
return
isWhatsNewPanelEnabled
;
}
get
userPrefs
(
)
{
return
{
cfrFeatures
:
cfrFeaturesUserPref
cfrAddons
:
cfrAddonsUserPref
snippets
:
snippetsUserPref
}
;
}
get
totalBlockedCount
(
)
{
return
TrackingDBService
.
sumAllEvents
(
)
;
}
get
blockedCountByType
(
)
{
const
idToTextMap
=
new
Map
(
[
[
Ci
.
nsITrackingDBService
.
TRACKERS_ID
"
trackerCount
"
]
[
Ci
.
nsITrackingDBService
.
TRACKING_COOKIES_ID
"
cookieCount
"
]
[
Ci
.
nsITrackingDBService
.
CRYPTOMINERS_ID
"
cryptominerCount
"
]
[
Ci
.
nsITrackingDBService
.
FINGERPRINTERS_ID
"
fingerprinterCount
"
]
[
Ci
.
nsITrackingDBService
.
SOCIAL_ID
"
socialCount
"
]
]
)
;
const
dateTo
=
new
Date
(
)
;
const
dateFrom
=
new
Date
(
dateTo
.
getTime
(
)
-
42
*
24
*
60
*
60
*
1000
)
;
return
TrackingDBService
.
getEventsByDateRange
(
dateFrom
dateTo
)
.
then
(
eventsByDate
=
>
{
let
totalEvents
=
{
}
;
for
(
let
blockedType
of
idToTextMap
.
values
(
)
)
{
totalEvents
[
blockedType
]
=
0
;
}
return
eventsByDate
.
reduce
(
(
acc
day
)
=
>
{
const
type
=
day
.
getResultByName
(
"
type
"
)
;
const
count
=
day
.
getResultByName
(
"
count
"
)
;
acc
[
idToTextMap
.
get
(
type
)
]
=
acc
[
idToTextMap
.
get
(
type
)
]
+
count
;
return
acc
;
}
totalEvents
)
;
}
)
;
}
get
attachedFxAOAuthClients
(
)
{
return
this
.
usesFirefoxSync
?
QueryCache
.
queries
.
ListAttachedOAuthClients
.
get
(
)
:
[
]
;
}
get
platformName
(
)
{
return
AppConstants
.
platform
;
}
get
isChinaRepack
(
)
{
return
(
Services
.
prefs
.
getDefaultBranch
(
null
)
.
getCharPref
(
DISTRIBUTION_ID_PREF
"
default
"
)
=
=
=
DISTRIBUTION_ID_CHINA_REPACK
)
;
}
get
userId
(
)
{
return
ClientEnvironment
.
userId
;
}
get
profileRestartCount
(
)
{
return
(
TelemetrySession
.
getMetadata
(
"
targeting
"
)
.
profileSubsessionCounter
-
1
)
;
}
get
homePageSettings
(
)
{
const
url
=
HomePage
.
get
(
)
;
const
{
isWebExt
isCustomUrl
urls
}
=
parseAboutPageURL
(
url
)
;
return
{
isWebExt
isCustomUrl
urls
isDefault
:
HomePage
.
isDefault
isLocked
:
HomePage
.
locked
}
;
}
get
newtabSettings
(
)
{
const
url
=
AboutNewTab
.
newTabURL
;
const
{
isWebExt
isCustomUrl
urls
}
=
parseAboutPageURL
(
url
)
;
return
{
isWebExt
isCustomUrl
isDefault
:
AboutNewTab
.
activityStreamEnabled
url
:
urls
[
0
]
.
url
host
:
urls
[
0
]
.
host
}
;
}
get
isFissionExperimentEnabled
(
)
{
return
(
Services
.
appinfo
.
fissionExperimentStatus
=
=
=
Ci
.
nsIXULRuntime
.
eExperimentStatusTreatment
)
;
}
get
activeNotifications
(
)
{
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
window
.
gURLBar
.
view
.
isOpen
|
|
window
.
gNotificationBox
.
currentNotification
|
|
window
.
gBrowser
.
getNotificationBox
(
)
.
currentNotification
)
{
return
true
;
}
return
false
;
}
get
isMajorUpgrade
(
)
{
return
BrowserHandler
.
majorUpgrade
;
}
get
hasActiveEnterprisePolicies
(
)
{
return
Services
.
policies
.
status
=
=
=
Services
.
policies
.
ACTIVE
;
}
get
userMonthlyActivity
(
)
{
return
QueryCache
.
queries
.
UserMonthlyActivity
.
get
(
)
;
}
get
doesAppNeedPin
(
)
{
return
QueryCache
.
getters
.
doesAppNeedPin
.
get
(
)
;
}
}
;
this
.
ASRouterTargeting
=
{
Environment
:
TargetingGetters
isTriggerMatch
(
trigger
=
{
}
candidateMessageTrigger
=
{
}
)
{
if
(
trigger
.
id
!
=
=
candidateMessageTrigger
.
id
)
{
return
false
;
}
else
if
(
!
candidateMessageTrigger
.
params
&
&
!
candidateMessageTrigger
.
patterns
)
{
return
true
;
}
if
(
!
trigger
.
param
)
{
return
false
;
}
return
(
(
candidateMessageTrigger
.
params
&
&
trigger
.
param
.
host
&
&
candidateMessageTrigger
.
params
.
includes
(
trigger
.
param
.
host
)
)
|
|
(
candidateMessageTrigger
.
params
&
&
trigger
.
param
.
type
&
&
candidateMessageTrigger
.
params
.
filter
(
t
=
>
t
=
=
=
trigger
.
param
.
type
)
.
length
)
|
|
(
candidateMessageTrigger
.
params
&
&
trigger
.
param
.
type
&
&
candidateMessageTrigger
.
params
.
filter
(
t
=
>
(
t
&
trigger
.
param
.
type
)
=
=
=
t
)
.
length
)
|
|
(
candidateMessageTrigger
.
patterns
&
&
trigger
.
param
.
url
&
&
new
MatchPatternSet
(
candidateMessageTrigger
.
patterns
)
.
matches
(
trigger
.
param
.
url
)
)
)
;
}
getCachedEvaluation
(
targeting
)
{
if
(
jexlEvaluationCache
.
has
(
targeting
)
)
{
const
{
timestamp
value
}
=
jexlEvaluationCache
.
get
(
targeting
)
;
if
(
Date
.
now
(
)
-
timestamp
<
=
CACHE_EXPIRATION
)
{
return
{
value
}
;
}
jexlEvaluationCache
.
delete
(
targeting
)
;
}
return
null
;
}
async
checkMessageTargeting
(
message
targetingContext
onError
shouldCache
)
{
if
(
!
message
.
targeting
)
{
return
true
;
}
let
result
;
try
{
if
(
shouldCache
)
{
result
=
this
.
getCachedEvaluation
(
message
.
targeting
)
;
if
(
result
)
{
return
result
.
value
;
}
}
result
=
await
targetingContext
.
evalWithDefault
(
message
.
targeting
)
;
if
(
shouldCache
)
{
jexlEvaluationCache
.
set
(
message
.
targeting
{
timestamp
:
Date
.
now
(
)
value
:
result
}
)
;
}
}
catch
(
error
)
{
if
(
onError
)
{
onError
(
error
message
)
;
}
Cu
.
reportError
(
error
)
;
result
=
false
;
}
return
result
;
}
_isMessageMatch
(
message
trigger
targetingContext
onError
shouldCache
=
false
)
{
return
(
message
&
&
(
trigger
?
this
.
isTriggerMatch
(
trigger
message
.
trigger
)
:
!
message
.
trigger
)
&
&
this
.
checkMessageTargeting
(
message
targetingContext
onError
shouldCache
)
)
;
}
async
findMatchingMessage
(
{
messages
trigger
=
{
}
context
=
{
}
onError
ordered
=
false
shouldCache
=
false
returnAll
=
false
}
)
{
const
sortedMessages
=
getSortedMessages
(
messages
{
ordered
}
)
;
const
matching
=
returnAll
?
[
]
:
null
;
const
targetingContext
=
new
TargetingContext
(
TargetingContext
.
combineContexts
(
context
this
.
Environment
trigger
.
context
|
|
{
}
)
)
;
const
isMatch
=
candidate
=
>
this
.
_isMessageMatch
(
candidate
trigger
targetingContext
onError
shouldCache
)
;
for
(
const
candidate
of
sortedMessages
)
{
if
(
await
isMatch
(
candidate
)
)
{
if
(
!
returnAll
)
{
return
candidate
;
}
matching
.
push
(
candidate
)
;
}
}
return
matching
;
}
}
;
this
.
getSortedMessages
=
getSortedMessages
;
this
.
QueryCache
=
QueryCache
;
this
.
CachedTargetingGetter
=
CachedTargetingGetter
;
this
.
EXPORTED_SYMBOLS
=
[
"
ASRouterTargeting
"
"
QueryCache
"
"
CachedTargetingGetter
"
"
getSortedMessages
"
]
;
