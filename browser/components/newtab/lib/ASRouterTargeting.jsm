ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
FilterExpressions
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ASRouterPreferences
"
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterPreferences
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ProfileAge
"
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ShellService
"
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryEnvironment
"
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
FXA_USERNAME_PREF
=
"
services
.
sync
.
username
"
;
const
SEARCH_REGION_PREF
=
"
browser
.
search
.
region
"
;
const
MOZ_JEXL_FILEPATH
=
"
mozjexl
"
;
const
{
activityStreamProvider
:
asProvider
}
=
NewTabUtils
;
const
FRECENT_SITES_UPDATE_INTERVAL
=
6
*
60
*
60
*
1000
;
const
FRECENT_SITES_IGNORE_BLOCKED
=
false
;
const
FRECENT_SITES_NUM_ITEMS
=
25
;
const
FRECENT_SITES_MIN_FRECENCY
=
100
;
function
CachedTargetingGetter
(
property
options
=
null
updateInterval
=
FRECENT_SITES_UPDATE_INTERVAL
)
{
return
{
_lastUpdated
:
0
_value
:
null
expire
(
)
{
this
.
_lastUpdated
=
0
;
this
.
_value
=
null
;
}
get
(
)
{
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
const
now
=
Date
.
now
(
)
;
if
(
now
-
this
.
_lastUpdated
>
=
updateInterval
)
{
try
{
this
.
_value
=
await
asProvider
[
property
]
(
options
)
;
this
.
_lastUpdated
=
now
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
reject
(
e
)
;
}
}
resolve
(
this
.
_value
)
;
}
)
;
}
}
;
}
const
QueryCache
=
{
expireAll
(
)
{
Object
.
keys
(
this
.
queries
)
.
forEach
(
query
=
>
{
this
.
queries
[
query
]
.
expire
(
)
;
}
)
;
}
queries
:
{
TopFrecentSites
:
new
CachedTargetingGetter
(
"
getTopFrecentSites
"
{
ignoreBlocked
:
FRECENT_SITES_IGNORE_BLOCKED
numItems
:
FRECENT_SITES_NUM_ITEMS
topsiteFrecency
:
FRECENT_SITES_MIN_FRECENCY
onePerDomain
:
true
includeFavicon
:
false
}
)
TotalBookmarksCount
:
new
CachedTargetingGetter
(
"
getTotalBookmarksCount
"
)
}
}
;
function
sortMessagesByWeightedRank
(
messages
)
{
return
messages
.
map
(
message
=
>
(
{
message
rank
:
Math
.
pow
(
Math
.
random
(
)
1
/
message
.
weight
)
}
)
)
.
sort
(
(
a
b
)
=
>
b
.
rank
-
a
.
rank
)
.
map
(
(
{
message
}
)
=
>
message
)
;
}
const
TargetingGetters
=
{
get
locale
(
)
{
return
Services
.
locale
.
appLocaleAsLangTag
;
}
get
localeLanguageCode
(
)
{
return
Services
.
locale
.
appLocaleAsLangTag
&
&
Services
.
locale
.
appLocaleAsLangTag
.
substr
(
0
2
)
;
}
get
browserSettings
(
)
{
const
{
settings
}
=
TelemetryEnvironment
.
currentEnvironment
;
return
{
attribution
:
settings
.
attribution
update
:
settings
.
update
}
;
}
get
currentDate
(
)
{
return
new
Date
(
)
;
}
get
profileAgeCreated
(
)
{
return
new
ProfileAge
(
null
null
)
.
created
;
}
get
profileAgeReset
(
)
{
return
new
ProfileAge
(
null
null
)
.
reset
;
}
get
usesFirefoxSync
(
)
{
return
Services
.
prefs
.
prefHasUserValue
(
FXA_USERNAME_PREF
)
;
}
get
sync
(
)
{
return
{
desktopDevices
:
Services
.
prefs
.
getIntPref
(
"
services
.
sync
.
clients
.
devices
.
desktop
"
0
)
mobileDevices
:
Services
.
prefs
.
getIntPref
(
"
services
.
sync
.
clients
.
devices
.
mobile
"
0
)
totalDevices
:
Services
.
prefs
.
getIntPref
(
"
services
.
sync
.
numClients
"
0
)
}
;
}
get
xpinstallEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
xpinstall
.
enabled
"
true
)
;
}
get
addonsInfo
(
)
{
return
AddonManager
.
getActiveAddons
(
[
"
extension
"
"
service
"
]
)
.
then
(
(
{
addons
fullData
}
)
=
>
{
const
info
=
{
}
;
for
(
const
addon
of
addons
)
{
info
[
addon
.
id
]
=
{
version
:
addon
.
version
type
:
addon
.
type
isSystem
:
addon
.
isSystem
isWebExtension
:
addon
.
isWebExtension
}
;
if
(
fullData
)
{
Object
.
assign
(
info
[
addon
.
id
]
{
name
:
addon
.
name
userDisabled
:
addon
.
userDisabled
installDate
:
addon
.
installDate
}
)
;
}
}
return
{
addons
:
info
isFullData
:
fullData
}
;
}
)
;
}
get
searchEngines
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
search
.
init
(
rv
=
>
{
if
(
Components
.
isSuccessCode
(
rv
)
)
{
let
engines
=
Services
.
search
.
getVisibleEngines
(
)
;
resolve
(
{
current
:
Services
.
search
.
defaultEngine
.
identifier
installed
:
engines
.
map
(
engine
=
>
engine
.
identifier
)
.
filter
(
engine
=
>
engine
)
}
)
;
}
else
{
resolve
(
{
installed
:
[
]
current
:
"
"
}
)
;
}
}
)
;
}
)
;
}
get
isDefaultBrowser
(
)
{
try
{
return
ShellService
.
isDefaultBrowser
(
)
;
}
catch
(
e
)
{
}
return
null
;
}
get
devToolsOpenedCount
(
)
{
return
Services
.
prefs
.
getIntPref
(
"
devtools
.
selfxss
.
count
"
)
;
}
get
topFrecentSites
(
)
{
return
QueryCache
.
queries
.
TopFrecentSites
.
get
(
)
.
then
(
sites
=
>
sites
.
map
(
site
=
>
(
{
url
:
site
.
url
host
:
(
new
URL
(
site
.
url
)
)
.
hostname
frecency
:
site
.
frecency
lastVisitDate
:
site
.
lastVisitDate
}
)
)
)
;
}
get
providerCohorts
(
)
{
return
ASRouterPreferences
.
providers
.
reduce
(
(
prev
current
)
=
>
{
prev
[
current
.
id
]
=
current
.
cohort
|
|
"
"
;
return
prev
;
}
{
}
)
;
}
get
totalBookmarksCount
(
)
{
return
QueryCache
.
queries
.
TotalBookmarksCount
.
get
(
)
;
}
get
firefoxVersion
(
)
{
return
parseInt
(
AppConstants
.
MOZ_APP_VERSION
.
match
(
/
\
d
+
/
)
10
)
;
}
get
region
(
)
{
return
Services
.
prefs
.
getStringPref
(
SEARCH_REGION_PREF
"
"
)
;
}
}
;
this
.
ASRouterTargeting
=
{
Environment
:
TargetingGetters
ERROR_TYPES
:
{
MALFORMED_EXPRESSION
:
"
MALFORMED_EXPRESSION
"
OTHER_ERROR
:
"
OTHER_ERROR
"
}
isMatch
(
filterExpression
customContext
)
{
let
context
=
this
.
Environment
;
if
(
customContext
)
{
context
=
{
}
;
Object
.
defineProperties
(
context
Object
.
getOwnPropertyDescriptors
(
this
.
Environment
)
)
;
Object
.
defineProperties
(
context
Object
.
getOwnPropertyDescriptors
(
customContext
)
)
;
}
return
FilterExpressions
.
eval
(
filterExpression
context
)
;
}
isTriggerMatch
(
trigger
=
{
}
candidateMessageTrigger
=
{
}
)
{
if
(
trigger
.
id
!
=
=
candidateMessageTrigger
.
id
)
{
return
false
;
}
else
if
(
!
candidateMessageTrigger
.
params
)
{
return
true
;
}
return
candidateMessageTrigger
.
params
.
includes
(
trigger
.
param
)
;
}
async
checkMessageTargeting
(
message
context
onError
)
{
if
(
!
message
.
targeting
)
{
return
true
;
}
let
result
;
try
{
result
=
await
this
.
isMatch
(
message
.
targeting
context
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
if
(
onError
)
{
const
type
=
error
.
fileName
.
includes
(
MOZ_JEXL_FILEPATH
)
?
this
.
ERROR_TYPES
.
MALFORMED_EXPRESSION
:
this
.
ERROR_TYPES
.
OTHER_ERROR
;
onError
(
type
error
message
)
;
}
result
=
false
;
}
return
result
;
}
async
findMatchingMessage
(
{
messages
trigger
context
onError
}
)
{
const
sortedMessages
=
sortMessagesByWeightedRank
(
[
.
.
.
messages
]
)
;
for
(
const
candidate
of
sortedMessages
)
{
if
(
candidate
&
&
(
trigger
?
this
.
isTriggerMatch
(
trigger
candidate
.
trigger
)
:
!
candidate
.
trigger
)
&
&
await
this
.
checkMessageTargeting
(
candidate
context
onError
)
)
{
return
candidate
;
}
}
return
null
;
}
}
;
this
.
QueryCache
=
QueryCache
;
this
.
CachedTargetingGetter
=
CachedTargetingGetter
;
this
.
EXPORTED_SYMBOLS
=
[
"
ASRouterTargeting
"
"
QueryCache
"
"
CachedTargetingGetter
"
]
;
