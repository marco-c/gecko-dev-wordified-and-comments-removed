"
use
strict
"
;
const
{
tokenize
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
Tokenize
.
jsm
"
)
;
this
.
RecipeExecutor
=
class
RecipeExecutor
{
constructor
(
nbTaggers
nmfTaggers
)
{
this
.
ITEM_BUILDER_REGISTRY
=
{
nb_tag
:
this
.
naiveBayesTag
conditionally_nmf_tag
:
this
.
conditionallyNmfTag
accept_item_by_field_value
:
this
.
acceptItemByFieldValue
tokenize_url
:
this
.
tokenizeUrl
get_url_domain
:
this
.
getUrlDomain
tokenize_field
:
this
.
tokenizeField
copy_value
:
this
.
copyValue
keep_top_k
:
this
.
keepTopK
scalar_multiply
:
this
.
scalarMultiply
elementwise_multiply
:
this
.
elementwiseMultiply
vector_multiply
:
this
.
vectorMultiply
scalar_add
:
this
.
scalarAdd
vector_add
:
this
.
vectorAdd
make_boolean
:
this
.
makeBoolean
whitelist_fields
:
this
.
whitelistFields
filter_by_value
:
this
.
filterByValue
l2_normalize
:
this
.
l2Normalize
prob_normalize
:
this
.
probNormalize
set_default
:
this
.
setDefault
lookup_value
:
this
.
lookupValue
copy_to_map
:
this
.
copyToMap
scalar_multiply_tag
:
this
.
scalarMultiplyTag
apply_softmax_tags
:
this
.
applySoftmaxTags
}
;
this
.
ITEM_COMBINER_REGISTRY
=
{
combiner_add
:
this
.
combinerAdd
combiner_max
:
this
.
combinerMax
combiner_collect_values
:
this
.
combinerCollectValues
}
;
this
.
nbTaggers
=
nbTaggers
;
this
.
nmfTaggers
=
nmfTaggers
;
}
_typeOf
(
data
)
{
let
t
=
typeof
(
data
)
;
if
(
t
=
=
=
"
object
"
)
{
if
(
data
=
=
=
null
)
{
return
"
null
"
;
}
if
(
Array
.
isArray
(
data
)
)
{
return
"
array
"
;
}
return
"
map
"
;
}
return
t
;
}
_lookupScalar
(
item
k
dfault
)
{
if
(
this
.
_typeOf
(
k
)
=
=
=
"
number
"
)
{
return
k
;
}
else
if
(
(
this
.
_typeOf
(
k
)
=
=
=
"
string
"
)
&
&
(
k
in
item
)
&
&
(
this
.
_typeOf
(
item
[
k
]
)
=
=
=
"
number
"
)
)
{
return
item
[
k
]
;
}
return
dfault
;
}
_assembleText
(
item
fields
)
{
let
textArr
=
[
]
;
for
(
let
field
of
fields
)
{
if
(
field
in
item
)
{
let
type
=
this
.
_typeOf
(
item
[
field
]
)
;
if
(
type
=
=
=
"
string
"
)
{
textArr
.
push
(
item
[
field
]
)
;
}
else
if
(
type
=
=
=
"
array
"
)
{
for
(
let
ele
of
item
[
field
]
)
{
textArr
.
push
(
String
(
ele
)
)
;
}
}
else
{
textArr
.
push
(
String
(
item
[
field
]
)
)
;
}
}
}
return
textArr
.
join
(
"
"
)
;
}
naiveBayesTag
(
item
config
)
{
let
text
=
this
.
_assembleText
(
item
config
.
fields
)
;
let
tokens
=
tokenize
(
text
)
;
let
tags
=
{
}
;
let
extended_tags
=
{
}
;
for
(
let
nbTagger
of
this
.
nbTaggers
)
{
let
result
=
nbTagger
.
tagTokens
(
tokens
)
;
if
(
(
result
.
label
!
=
=
null
)
&
&
result
.
confident
)
{
extended_tags
[
result
.
label
]
=
result
;
tags
[
result
.
label
]
=
Math
.
exp
(
result
.
logProb
)
;
}
}
item
.
nb_tags
=
tags
;
item
.
nb_tags_extended
=
extended_tags
;
item
.
nb_tokens
=
tokens
;
return
item
;
}
conditionallyNmfTag
(
item
config
)
{
let
nestedNmfTags
=
{
}
;
let
parentTags
=
{
}
;
let
parentWeights
=
{
}
;
if
(
!
(
"
nb_tags
"
in
item
)
|
|
!
(
"
nb_tokens
"
in
item
)
)
{
return
null
;
}
Object
.
keys
(
item
.
nb_tags
)
.
forEach
(
parentTag
=
>
{
let
nmfTagger
=
this
.
nmfTaggers
[
parentTag
]
;
if
(
nmfTagger
!
=
=
undefined
)
{
nestedNmfTags
[
parentTag
]
=
{
}
;
parentWeights
[
parentTag
]
=
item
.
nb_tags
[
parentTag
]
;
let
nmfTags
=
nmfTagger
.
tagTokens
(
item
.
nb_tokens
)
;
Object
.
keys
(
nmfTags
)
.
forEach
(
nmfTag
=
>
{
nestedNmfTags
[
parentTag
]
[
nmfTag
]
=
nmfTags
[
nmfTag
]
;
parentTags
[
nmfTag
]
=
parentTag
;
}
)
;
}
}
)
;
item
.
nmf_tags
=
nestedNmfTags
;
item
.
nmf_tags_parent
=
parentTags
;
item
.
nmf_tags_parent_weights
=
parentWeights
;
return
item
;
}
acceptItemByFieldValue
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
rhs
=
null
;
if
(
"
rhsValue
"
in
config
)
{
rhs
=
config
.
rhsValue
;
}
else
if
(
(
"
rhsField
"
in
config
)
&
&
(
config
.
rhsField
in
item
)
)
{
rhs
=
item
[
config
.
rhsField
]
;
}
if
(
rhs
=
=
=
null
)
{
return
null
;
}
if
(
(
(
config
.
op
=
=
=
"
=
=
"
)
&
&
(
item
[
config
.
field
]
=
=
rhs
)
)
|
|
(
(
config
.
op
=
=
=
"
!
=
"
)
&
&
(
item
[
config
.
field
]
!
=
rhs
)
)
|
|
(
(
config
.
op
=
=
=
"
<
"
)
&
&
(
item
[
config
.
field
]
<
rhs
)
)
|
|
(
(
config
.
op
=
=
=
"
<
=
"
)
&
&
(
item
[
config
.
field
]
<
=
rhs
)
)
|
|
(
(
config
.
op
=
=
=
"
>
"
)
&
&
(
item
[
config
.
field
]
>
rhs
)
)
|
|
(
(
config
.
op
=
=
=
"
>
=
"
)
&
&
(
item
[
config
.
field
]
>
=
rhs
)
)
)
{
return
item
;
}
return
null
;
}
tokenizeUrl
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
url
=
new
URL
(
item
[
config
.
field
]
)
;
let
domain
=
url
.
hostname
;
if
(
domain
.
startsWith
(
"
www
.
"
)
)
{
domain
=
domain
.
substring
(
4
)
;
}
let
toks
=
tokenize
(
domain
)
;
let
pathToks
=
tokenize
(
decodeURIComponent
(
url
.
pathname
.
replace
(
/
\
+
/
g
"
"
)
)
)
;
for
(
let
tok
of
pathToks
)
{
toks
.
push
(
tok
)
;
}
for
(
let
pair
of
url
.
searchParams
.
entries
(
)
)
{
let
k
=
tokenize
(
decodeURIComponent
(
pair
[
0
]
.
replace
(
/
\
+
/
g
"
"
)
)
)
;
for
(
let
tok
of
k
)
{
toks
.
push
(
tok
)
;
}
if
(
(
pair
[
1
]
!
=
=
null
)
&
&
(
pair
[
1
]
!
=
=
"
"
)
)
{
let
v
=
tokenize
(
decodeURIComponent
(
pair
[
1
]
.
replace
(
/
\
+
/
g
"
"
)
)
)
;
for
(
let
tok
of
v
)
{
toks
.
push
(
tok
)
;
}
}
}
item
[
config
.
dest
]
=
toks
;
return
item
;
}
getUrlDomain
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
url
=
new
URL
(
item
[
config
.
field
]
)
;
let
domain
=
url
.
hostname
.
toLocaleLowerCase
(
)
;
if
(
domain
.
startsWith
(
"
www
.
"
)
)
{
domain
=
domain
.
substring
(
4
)
;
}
item
[
config
.
dest
]
=
domain
;
let
pathLength
=
0
;
if
(
"
path_length
"
in
config
)
{
pathLength
=
config
.
path_length
;
}
if
(
pathLength
>
0
)
{
item
[
config
.
dest
]
+
=
url
.
pathname
.
toLocaleLowerCase
(
)
.
split
(
"
/
"
)
.
slice
(
0
pathLength
+
1
)
.
join
(
"
/
"
)
;
}
return
item
;
}
tokenizeField
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
item
[
config
.
dest
]
=
tokenize
(
item
[
config
.
field
]
)
;
return
item
;
}
copyValue
(
item
config
)
{
if
(
!
(
config
.
src
in
item
)
)
{
return
null
;
}
item
[
config
.
dest
]
=
JSON
.
parse
(
JSON
.
stringify
(
item
[
config
.
src
]
)
)
;
return
item
;
}
keepTopK
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
k
=
this
.
_lookupScalar
(
item
config
.
k
1048576
)
;
let
descending
=
(
!
(
"
descending
"
in
config
)
|
|
(
config
.
descending
!
=
=
false
)
)
;
let
sortable
=
[
]
;
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
outerKey
=
>
{
let
innerType
=
this
.
_typeOf
(
item
[
config
.
field
]
[
outerKey
]
)
;
if
(
innerType
=
=
=
"
map
"
)
{
Object
.
keys
(
item
[
config
.
field
]
[
outerKey
]
)
.
forEach
(
innerKey
=
>
{
sortable
.
push
(
{
key
:
innerKey
value
:
item
[
config
.
field
]
[
outerKey
]
[
innerKey
]
}
)
;
}
)
;
}
else
{
sortable
.
push
(
{
key
:
outerKey
value
:
item
[
config
.
field
]
[
outerKey
]
}
)
;
}
}
)
;
sortable
.
sort
(
(
a
b
)
=
>
{
if
(
descending
)
{
return
b
.
value
-
a
.
value
;
}
return
a
.
value
-
b
.
value
;
}
)
;
let
newMap
=
{
}
;
let
i
=
0
;
for
(
let
pair
of
sortable
)
{
if
(
i
>
=
k
)
{
break
;
}
newMap
[
pair
.
key
]
=
pair
.
value
;
i
+
+
;
}
item
[
config
.
field
]
=
newMap
;
return
item
;
}
scalarMultiply
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
k
=
this
.
_lookupScalar
(
item
config
.
k
config
.
dfault
)
;
let
fieldType
=
this
.
_typeOf
(
item
[
config
.
field
]
)
;
if
(
fieldType
=
=
=
"
number
"
)
{
item
[
config
.
field
]
*
=
k
;
}
else
if
(
fieldType
=
=
=
"
array
"
)
{
for
(
let
i
=
0
;
i
<
item
[
config
.
field
]
.
length
;
i
+
+
)
{
item
[
config
.
field
]
[
i
]
*
=
k
;
}
}
else
if
(
fieldType
=
=
=
"
map
"
)
{
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
key
=
>
{
item
[
config
.
field
]
[
key
]
*
=
k
;
}
)
;
}
else
{
return
null
;
}
return
item
;
}
elementwiseMultiply
(
item
config
)
{
if
(
!
(
config
.
left
in
item
)
|
|
!
(
config
.
right
in
item
)
)
{
return
null
;
}
let
leftType
=
this
.
_typeOf
(
item
[
config
.
left
]
)
;
if
(
leftType
!
=
=
this
.
_typeOf
(
item
[
config
.
right
]
)
)
{
return
null
;
}
if
(
leftType
=
=
=
"
array
"
)
{
if
(
item
[
config
.
left
]
.
length
!
=
=
item
[
config
.
right
]
.
length
)
{
return
null
;
}
for
(
let
i
=
0
;
i
<
item
[
config
.
left
]
.
length
;
i
+
+
)
{
item
[
config
.
left
]
[
i
]
*
=
item
[
config
.
right
]
[
i
]
;
}
}
else
if
(
leftType
=
=
=
"
map
"
)
{
Object
.
keys
(
item
[
config
.
left
]
)
.
forEach
(
outerKey
=
>
{
let
r
=
0
.
0
;
if
(
outerKey
in
item
[
config
.
right
]
)
{
r
=
item
[
config
.
right
]
[
outerKey
]
;
}
Object
.
keys
(
item
[
config
.
left
]
[
outerKey
]
)
.
forEach
(
innerKey
=
>
{
item
[
config
.
left
]
[
outerKey
]
[
innerKey
]
*
=
r
;
}
)
;
}
)
;
}
else
if
(
leftType
=
=
=
"
number
"
)
{
item
[
config
.
left
]
*
=
item
[
config
.
right
]
;
}
else
{
return
null
;
}
return
item
;
}
vectorMultiply
(
item
config
)
{
if
(
!
(
config
.
left
in
item
)
|
|
!
(
config
.
right
in
item
)
)
{
return
null
;
}
let
leftType
=
this
.
_typeOf
(
item
[
config
.
left
]
)
;
if
(
leftType
!
=
=
this
.
_typeOf
(
item
[
config
.
right
]
)
)
{
return
null
;
}
let
destVal
=
0
.
0
;
if
(
leftType
=
=
=
"
array
"
)
{
if
(
item
[
config
.
left
]
.
length
!
=
=
item
[
config
.
right
]
.
length
)
{
return
null
;
}
for
(
let
i
=
0
;
i
<
item
[
config
.
left
]
.
length
;
i
+
+
)
{
destVal
+
=
item
[
config
.
left
]
[
i
]
*
item
[
config
.
right
]
[
i
]
;
}
}
else
if
(
leftType
=
=
=
"
map
"
)
{
Object
.
keys
(
item
[
config
.
left
]
)
.
forEach
(
key
=
>
{
if
(
key
in
item
[
config
.
right
]
)
{
destVal
+
=
item
[
config
.
left
]
[
key
]
*
item
[
config
.
right
]
[
key
]
;
}
}
)
;
}
else
{
return
null
;
}
item
[
config
.
dest
]
=
destVal
;
return
item
;
}
scalarAdd
(
item
config
)
{
let
k
=
this
.
_lookupScalar
(
item
config
.
k
config
.
dfault
)
;
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
fieldType
=
this
.
_typeOf
(
item
[
config
.
field
]
)
;
if
(
fieldType
=
=
=
"
array
"
)
{
for
(
let
i
=
0
;
i
<
item
[
config
.
field
]
.
length
;
i
+
+
)
{
item
[
config
.
field
]
[
i
]
+
=
k
;
}
}
else
if
(
fieldType
=
=
=
"
map
"
)
{
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
key
=
>
{
item
[
config
.
field
]
[
key
]
+
=
k
;
}
)
;
}
else
if
(
fieldType
=
=
=
"
number
"
)
{
item
[
config
.
field
]
+
=
k
;
}
else
{
return
null
;
}
return
item
;
}
vectorAdd
(
item
config
)
{
if
(
!
(
config
.
left
in
item
)
)
{
return
this
.
copyValue
(
item
{
src
:
config
.
right
dest
:
config
.
left
}
)
;
}
if
(
!
(
config
.
right
in
item
)
)
{
return
null
;
}
let
leftType
=
this
.
_typeOf
(
item
[
config
.
left
]
)
;
if
(
leftType
!
=
=
this
.
_typeOf
(
item
[
config
.
right
]
)
)
{
return
null
;
}
if
(
leftType
=
=
=
"
array
"
)
{
if
(
item
[
config
.
left
]
.
length
!
=
=
item
[
config
.
right
]
.
length
)
{
return
null
;
}
for
(
let
i
=
0
;
i
<
item
[
config
.
left
]
.
length
;
i
+
+
)
{
item
[
config
.
left
]
[
i
]
+
=
item
[
config
.
right
]
[
i
]
;
}
return
item
;
}
else
if
(
leftType
=
=
=
"
map
"
)
{
Object
.
keys
(
item
[
config
.
right
]
)
.
forEach
(
key
=
>
{
let
v
=
0
;
if
(
key
in
item
[
config
.
left
]
)
{
v
=
item
[
config
.
left
]
[
key
]
;
}
item
[
config
.
left
]
[
key
]
=
v
+
item
[
config
.
right
]
[
key
]
;
}
)
;
return
item
;
}
return
null
;
}
makeBoolean
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
threshold
=
this
.
_lookupScalar
(
item
config
.
threshold
0
.
0
)
;
let
type
=
this
.
_typeOf
(
item
[
config
.
field
]
)
;
if
(
type
=
=
=
"
array
"
)
{
for
(
let
i
=
0
;
i
<
item
[
config
.
field
]
.
length
;
i
+
+
)
{
if
(
item
[
config
.
field
]
[
i
]
>
threshold
)
{
item
[
config
.
field
]
[
i
]
=
1
.
0
;
}
else
if
(
config
.
keep_negative
)
{
item
[
config
.
field
]
[
i
]
=
-
1
.
0
;
}
else
{
item
[
config
.
field
]
[
i
]
=
0
.
0
;
}
}
}
else
if
(
type
=
=
=
"
map
"
)
{
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
key
=
>
{
let
value
=
item
[
config
.
field
]
[
key
]
;
if
(
value
>
threshold
)
{
item
[
config
.
field
]
[
key
]
=
1
.
0
;
}
else
if
(
config
.
keep_negative
)
{
item
[
config
.
field
]
[
key
]
=
-
1
.
0
;
}
else
{
item
[
config
.
field
]
[
key
]
=
0
.
0
;
}
}
)
;
}
else
if
(
type
=
=
=
"
number
"
)
{
let
value
=
item
[
config
.
field
]
;
if
(
value
>
threshold
)
{
item
[
config
.
field
]
=
1
.
0
;
}
else
if
(
config
.
keep_negative
)
{
item
[
config
.
field
]
=
-
1
.
0
;
}
else
{
item
[
config
.
field
]
=
0
.
0
;
}
}
else
{
return
null
;
}
return
item
;
}
whitelistFields
(
item
config
)
{
let
newItem
=
{
}
;
for
(
let
ele
of
config
.
fields
)
{
if
(
ele
in
item
)
{
newItem
[
ele
]
=
item
[
ele
]
;
}
}
return
newItem
;
}
filterByValue
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
threshold
=
this
.
_lookupScalar
(
item
config
.
threshold
0
.
0
)
;
let
filtered
=
{
}
;
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
key
=
>
{
let
value
=
item
[
config
.
field
]
[
key
]
;
if
(
value
>
threshold
)
{
filtered
[
key
]
=
value
;
}
}
)
;
item
[
config
.
field
]
=
filtered
;
return
item
;
}
l2Normalize
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
data
=
item
[
config
.
field
]
;
let
type
=
this
.
_typeOf
(
data
)
;
if
(
type
=
=
=
"
array
"
)
{
let
norm
=
0
.
0
;
for
(
let
datum
of
data
)
{
norm
+
=
datum
*
datum
;
}
norm
=
Math
.
sqrt
(
norm
)
;
if
(
norm
!
=
=
0
)
{
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
data
[
i
]
/
=
norm
;
}
}
}
else
if
(
type
=
=
=
"
map
"
)
{
let
norm
=
0
.
0
;
Object
.
keys
(
data
)
.
forEach
(
key
=
>
{
norm
+
=
data
[
key
]
*
data
[
key
]
;
}
)
;
norm
=
Math
.
sqrt
(
norm
)
;
if
(
norm
!
=
=
0
)
{
Object
.
keys
(
data
)
.
forEach
(
key
=
>
{
data
[
key
]
/
=
norm
;
}
)
;
}
}
else
{
return
null
;
}
item
[
config
.
field
]
=
data
;
return
item
;
}
probNormalize
(
item
config
)
{
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
data
=
item
[
config
.
field
]
;
let
type
=
this
.
_typeOf
(
data
)
;
if
(
type
=
=
=
"
array
"
)
{
let
norm
=
0
.
0
;
for
(
let
datum
of
data
)
{
norm
+
=
datum
;
}
if
(
norm
!
=
=
0
)
{
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
data
[
i
]
/
=
norm
;
}
}
}
else
if
(
type
=
=
=
"
map
"
)
{
let
norm
=
0
.
0
;
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
key
=
>
{
norm
+
=
item
[
config
.
field
]
[
key
]
;
}
)
;
if
(
norm
!
=
=
0
)
{
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
key
=
>
{
item
[
config
.
field
]
[
key
]
/
=
norm
;
}
)
;
}
}
else
{
return
null
;
}
return
item
;
}
setDefault
(
item
config
)
{
let
val
=
this
.
_lookupScalar
(
item
config
.
value
config
.
value
)
;
if
(
!
(
config
.
field
in
item
)
)
{
item
[
config
.
field
]
=
val
;
}
return
item
;
}
lookupValue
(
item
config
)
{
if
(
(
config
.
haystack
in
item
)
&
&
(
config
.
needle
in
item
[
config
.
haystack
]
)
)
{
item
[
config
.
dest
]
=
item
[
config
.
haystack
]
[
config
.
needle
]
;
}
return
item
;
}
copyToMap
(
item
config
)
{
if
(
config
.
src
in
item
)
{
if
(
!
(
config
.
dest_map
in
item
)
)
{
item
[
config
.
dest_map
]
=
{
}
;
}
item
[
config
.
dest_map
]
[
config
.
dest_key
]
=
item
[
config
.
src
]
;
}
return
item
;
}
scalarMultiplyTag
(
item
config
)
{
let
EPSILON
=
0
.
000001
;
if
(
!
(
config
.
field
in
item
)
)
{
return
null
;
}
let
k
=
this
.
_lookupScalar
(
item
config
.
k
1
)
;
let
type
=
this
.
_typeOf
(
item
[
config
.
field
]
)
;
if
(
type
=
=
=
"
map
"
)
{
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
parentKey
=
>
{
Object
.
keys
(
item
[
config
.
field
]
[
parentKey
]
)
.
forEach
(
key
=
>
{
let
v
=
item
[
config
.
field
]
[
parentKey
]
[
key
]
;
if
(
config
.
log_scale
)
{
v
=
Math
.
log
(
v
+
EPSILON
)
;
}
item
[
config
.
field
]
[
parentKey
]
[
key
]
=
v
*
k
;
}
)
;
}
)
;
}
else
{
return
null
;
}
return
item
;
}
applySoftmaxTags
(
item
config
)
{
let
type
=
this
.
_typeOf
(
item
[
config
.
field
]
)
;
if
(
type
!
=
=
"
map
"
)
{
return
null
;
}
let
abort
=
false
;
let
softmaxSum
=
{
}
;
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
tag
=
>
{
if
(
this
.
_typeOf
(
item
[
config
.
field
]
[
tag
]
)
!
=
=
"
map
"
)
{
abort
=
true
;
return
;
}
if
(
abort
)
{
return
;
}
softmaxSum
[
tag
]
=
0
;
Object
.
keys
(
item
[
config
.
field
]
[
tag
]
)
.
forEach
(
subtag
=
>
{
if
(
this
.
_typeOf
(
item
[
config
.
field
]
[
tag
]
[
subtag
]
)
!
=
=
"
number
"
)
{
abort
=
true
;
return
;
}
let
score
=
item
[
config
.
field
]
[
tag
]
[
subtag
]
;
softmaxSum
[
tag
]
+
=
Math
.
exp
(
score
)
;
}
)
;
}
)
;
if
(
abort
)
{
return
null
;
}
Object
.
keys
(
item
[
config
.
field
]
)
.
forEach
(
tag
=
>
{
Object
.
keys
(
item
[
config
.
field
]
[
tag
]
)
.
forEach
(
subtag
=
>
{
item
[
config
.
field
]
[
tag
]
[
subtag
]
=
Math
.
exp
(
item
[
config
.
field
]
[
tag
]
[
subtag
]
)
/
softmaxSum
[
tag
]
;
}
)
;
}
)
;
return
item
;
}
combinerAdd
(
left
right
config
)
{
if
(
!
(
config
.
field
in
right
)
)
{
return
left
;
}
let
type
=
this
.
_typeOf
(
right
[
config
.
field
]
)
;
if
(
!
(
config
.
field
in
left
)
)
{
if
(
type
=
=
=
"
map
"
)
{
left
[
config
.
field
]
=
{
}
;
}
else
if
(
type
=
=
=
"
array
"
)
{
left
[
config
.
field
]
=
[
]
;
}
else
if
(
type
=
=
=
"
number
"
)
{
left
[
config
.
field
]
=
0
;
}
else
{
return
null
;
}
}
if
(
type
!
=
=
this
.
_typeOf
(
left
[
config
.
field
]
)
)
{
return
null
;
}
if
(
type
=
=
=
"
map
"
)
{
Object
.
keys
(
right
[
config
.
field
]
)
.
forEach
(
key
=
>
{
if
(
!
(
key
in
left
[
config
.
field
]
)
)
{
left
[
config
.
field
]
[
key
]
=
0
;
}
left
[
config
.
field
]
[
key
]
+
=
right
[
config
.
field
]
[
key
]
;
}
)
;
}
else
if
(
type
=
=
=
"
array
"
)
{
for
(
let
i
=
0
;
i
<
right
[
config
.
field
]
.
length
;
i
+
+
)
{
if
(
i
<
left
[
config
.
field
]
.
length
)
{
left
[
config
.
field
]
[
i
]
+
=
right
[
config
.
field
]
[
i
]
;
}
else
{
left
[
config
.
field
]
.
push
(
right
[
config
.
field
]
[
i
]
)
;
}
}
}
else
if
(
type
=
=
=
"
number
"
)
{
left
[
config
.
field
]
+
=
right
[
config
.
field
]
;
}
else
{
return
null
;
}
return
left
;
}
combinerMax
(
left
right
config
)
{
if
(
!
(
config
.
field
in
right
)
)
{
return
left
;
}
let
type
=
this
.
_typeOf
(
right
[
config
.
field
]
)
;
if
(
!
(
config
.
field
in
left
)
)
{
if
(
type
=
=
=
"
map
"
)
{
left
[
config
.
field
]
=
{
}
;
}
else
if
(
type
=
=
=
"
array
"
)
{
left
[
config
.
field
]
=
[
]
;
}
else
if
(
type
=
=
=
"
number
"
)
{
left
[
config
.
field
]
=
0
;
}
else
{
return
null
;
}
}
if
(
type
!
=
=
this
.
_typeOf
(
left
[
config
.
field
]
)
)
{
return
null
;
}
if
(
type
=
=
=
"
map
"
)
{
Object
.
keys
(
right
[
config
.
field
]
)
.
forEach
(
key
=
>
{
if
(
!
(
key
in
left
[
config
.
field
]
)
|
|
(
right
[
config
.
field
]
[
key
]
>
left
[
config
.
field
]
[
key
]
)
)
{
left
[
config
.
field
]
[
key
]
=
right
[
config
.
field
]
[
key
]
;
}
}
)
;
}
else
if
(
type
=
=
=
"
array
"
)
{
for
(
let
i
=
0
;
i
<
right
[
config
.
field
]
.
length
;
i
+
+
)
{
if
(
i
<
left
[
config
.
field
]
.
length
)
{
if
(
left
[
config
.
field
]
[
i
]
<
right
[
config
.
field
]
[
i
]
)
{
left
[
config
.
field
]
[
i
]
=
right
[
config
.
field
]
[
i
]
;
}
}
else
{
left
[
config
.
field
]
.
push
(
right
[
config
.
field
]
[
i
]
)
;
}
}
}
else
if
(
type
=
=
=
"
number
"
)
{
if
(
left
[
config
.
field
]
<
right
[
config
.
field
]
)
{
left
[
config
.
field
]
=
right
[
config
.
field
]
;
}
}
else
{
return
null
;
}
return
left
;
}
combinerCollectValues
(
left
right
config
)
{
let
op
;
if
(
config
.
operation
=
=
=
"
sum
"
)
{
op
=
(
a
b
)
=
>
a
+
b
;
}
else
if
(
config
.
operation
=
=
=
"
max
"
)
{
op
=
(
a
b
)
=
>
(
(
a
>
b
)
?
a
:
b
)
;
}
else
if
(
config
.
operation
=
=
=
"
overwrite
"
)
{
op
=
(
a
b
)
=
>
b
;
}
else
if
(
config
.
operation
=
=
=
"
count
"
)
{
op
=
(
a
b
)
=
>
a
+
1
;
}
else
{
return
null
;
}
if
(
!
(
config
.
left_field
in
left
)
)
{
left
[
config
.
left_field
]
=
{
}
;
}
if
(
(
!
(
config
.
right_key_field
in
right
)
)
|
|
(
!
(
config
.
right_value_field
in
right
)
)
)
{
return
left
;
}
let
key
=
right
[
config
.
right_key_field
]
;
let
rightValue
=
right
[
config
.
right_value_field
]
;
let
leftValue
=
0
.
0
;
if
(
key
in
left
[
config
.
left_field
]
)
{
leftValue
=
left
[
config
.
left_field
]
[
key
]
;
}
left
[
config
.
left_field
]
[
key
]
=
op
(
leftValue
rightValue
)
;
return
left
;
}
executeRecipe
(
item
recipe
)
{
let
newItem
=
item
;
for
(
let
step
of
recipe
)
{
let
op
=
this
.
ITEM_BUILDER_REGISTRY
[
step
.
function
]
;
if
(
op
=
=
=
undefined
)
{
return
null
;
}
newItem
=
op
.
call
(
this
newItem
step
)
;
if
(
newItem
=
=
=
null
)
{
break
;
}
}
return
newItem
;
}
executeCombinerRecipe
(
item1
item2
recipe
)
{
let
newItem1
=
item1
;
for
(
let
step
of
recipe
)
{
let
op
=
this
.
ITEM_COMBINER_REGISTRY
[
step
.
function
]
;
if
(
op
=
=
=
undefined
)
{
return
null
;
}
newItem1
=
op
.
call
(
this
newItem1
item2
step
)
;
if
(
newItem1
=
=
=
null
)
{
break
;
}
}
return
newItem1
;
}
}
;
const
EXPORTED_SYMBOLS
=
[
"
RecipeExecutor
"
]
;
