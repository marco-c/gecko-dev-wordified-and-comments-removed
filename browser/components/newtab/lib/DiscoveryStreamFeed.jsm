"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
const
{
actionTypes
:
at
actionCreators
:
ac
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
jsm
"
)
;
const
{
PersistentCache
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
PersistentCache
.
jsm
"
)
;
const
CACHE_KEY
=
"
discovery_stream
"
;
const
LAYOUT_UPDATE_TIME
=
30
*
60
*
1000
;
const
COMPONENT_FEEDS_UPDATE_TIME
=
30
*
60
*
1000
;
const
SPOCS_FEEDS_UPDATE_TIME
=
30
*
60
*
1000
;
const
MAX_LIFETIME_CAP
=
500
;
const
PREF_CONFIG
=
"
discoverystream
.
config
"
;
const
PREF_OPT_OUT
=
"
discoverystream
.
optOut
.
0
"
;
const
PREF_SHOW_SPONSORED
=
"
showSponsored
"
;
const
PREF_SPOC_IMPRESSIONS
=
"
discoverystream
.
spoc
.
impressions
"
;
this
.
DiscoveryStreamFeed
=
class
DiscoveryStreamFeed
{
constructor
(
)
{
this
.
loaded
=
false
;
this
.
cache
=
new
PersistentCache
(
CACHE_KEY
true
)
;
this
.
_prefCache
=
{
}
;
}
get
config
(
)
{
if
(
this
.
_prefCache
.
config
)
{
return
this
.
_prefCache
.
config
;
}
try
{
this
.
_prefCache
.
config
=
JSON
.
parse
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_CONFIG
]
)
;
this
.
_prefCache
.
config
.
enabled
=
this
.
_prefCache
.
config
.
enabled
&
&
!
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_OPT_OUT
]
;
}
catch
(
e
)
{
this
.
_prefCache
.
config
=
{
}
;
Cu
.
reportError
(
Could
not
parse
preference
.
Try
resetting
{
PREF_CONFIG
}
in
about
:
config
.
)
;
}
return
this
.
_prefCache
.
config
;
}
get
showSpocs
(
)
{
return
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_SHOW_SPONSORED
]
&
&
this
.
config
.
show_spocs
;
}
setupPrefs
(
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_CONFIG_SETUP
data
:
this
.
config
}
)
)
;
}
uninitPrefs
(
)
{
this
.
_prefCache
=
{
}
;
}
async
fetchFromEndpoint
(
endpoint
)
{
if
(
!
endpoint
)
{
Cu
.
reportError
(
"
Tried
to
fetch
endpoint
but
none
was
configured
.
"
)
;
return
null
;
}
try
{
const
response
=
await
fetch
(
endpoint
{
credentials
:
"
omit
"
}
)
;
if
(
!
response
.
ok
)
{
throw
new
Error
(
{
endpoint
}
returned
unexpected
status
:
{
response
.
status
}
)
;
}
return
response
.
json
(
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
Failed
to
fetch
{
endpoint
}
:
{
error
.
message
}
)
;
}
return
null
;
}
isExpired
(
cacheData
key
url
)
{
const
{
layout
spocs
feeds
}
=
cacheData
;
switch
(
key
)
{
case
"
layout
"
:
return
(
!
layout
|
|
!
(
Date
.
now
(
)
-
layout
.
_timestamp
<
LAYOUT_UPDATE_TIME
)
)
;
case
"
spocs
"
:
return
(
!
spocs
|
|
!
(
Date
.
now
(
)
-
spocs
.
lastUpdated
<
SPOCS_FEEDS_UPDATE_TIME
)
)
;
case
"
feed
"
:
return
(
!
feeds
|
|
!
feeds
[
url
]
|
|
!
(
Date
.
now
(
)
-
feeds
[
url
]
.
lastUpdated
<
COMPONENT_FEEDS_UPDATE_TIME
)
)
;
default
:
throw
new
Error
(
{
key
}
is
not
a
valid
key
)
;
}
}
async
checkIfAnyCacheExpired
(
)
{
const
cachedData
=
await
this
.
cache
.
get
(
)
|
|
{
}
;
const
{
feeds
}
=
cachedData
;
return
this
.
isExpired
(
cachedData
"
layout
"
)
|
|
this
.
isExpired
(
cachedData
"
spocs
"
)
|
|
!
feeds
|
|
Object
.
keys
(
feeds
)
.
some
(
url
=
>
this
.
isExpired
(
cachedData
"
feed
"
url
)
)
;
}
async
loadLayout
(
sendUpdate
)
{
const
cachedData
=
await
this
.
cache
.
get
(
)
|
|
{
}
;
let
{
layout
:
layoutResponse
}
=
cachedData
;
if
(
this
.
isExpired
(
cachedData
"
layout
"
)
)
{
layoutResponse
=
await
this
.
fetchFromEndpoint
(
this
.
config
.
layout_endpoint
)
;
if
(
layoutResponse
&
&
layoutResponse
.
layout
)
{
layoutResponse
.
_timestamp
=
Date
.
now
(
)
;
await
this
.
cache
.
set
(
"
layout
"
layoutResponse
)
;
}
else
{
Cu
.
reportError
(
"
No
response
for
response
.
layout
prop
"
)
;
}
}
if
(
layoutResponse
&
&
layoutResponse
.
layout
)
{
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_LAYOUT_UPDATE
data
:
{
layout
:
layoutResponse
.
layout
lastUpdated
:
layoutResponse
.
_timestamp
}
}
)
;
}
if
(
layoutResponse
&
&
layoutResponse
.
spocs
&
&
layoutResponse
.
spocs
.
url
)
{
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_ENDPOINT
data
:
layoutResponse
.
spocs
.
url
}
)
;
}
}
async
loadComponentFeeds
(
sendUpdate
)
{
const
{
DiscoveryStream
}
=
this
.
store
.
getState
(
)
;
const
newFeeds
=
{
}
;
if
(
DiscoveryStream
&
&
DiscoveryStream
.
layout
)
{
for
(
let
row
of
DiscoveryStream
.
layout
)
{
if
(
!
row
|
|
!
row
.
components
)
{
continue
;
}
for
(
let
component
of
row
.
components
)
{
if
(
component
&
&
component
.
feed
)
{
const
{
url
}
=
component
.
feed
;
newFeeds
[
url
]
=
await
this
.
getComponentFeed
(
url
)
;
}
}
}
await
this
.
cache
.
set
(
"
feeds
"
newFeeds
)
;
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_FEEDS_UPDATE
data
:
newFeeds
}
)
;
}
}
async
loadSpocs
(
sendUpdate
)
{
const
cachedData
=
await
this
.
cache
.
get
(
)
|
|
{
}
;
let
spocs
;
if
(
this
.
showSpocs
)
{
spocs
=
cachedData
.
spocs
;
if
(
this
.
isExpired
(
cachedData
"
spocs
"
)
)
{
const
endpoint
=
this
.
store
.
getState
(
)
.
DiscoveryStream
.
spocs
.
spocs_endpoint
;
const
spocsResponse
=
await
this
.
fetchFromEndpoint
(
endpoint
)
;
if
(
spocsResponse
)
{
spocs
=
{
lastUpdated
:
Date
.
now
(
)
data
:
spocsResponse
}
;
this
.
cleanUpCampaignImpressionPref
(
spocs
.
data
)
;
await
this
.
cache
.
set
(
"
spocs
"
spocs
)
;
}
else
{
Cu
.
reportError
(
"
No
response
for
spocs_endpoint
prop
"
)
;
}
}
}
spocs
=
spocs
|
|
{
lastUpdated
:
Date
.
now
(
)
data
:
{
}
}
;
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_UPDATE
data
:
{
lastUpdated
:
spocs
.
lastUpdated
spocs
:
this
.
filterSpocs
(
spocs
.
data
)
}
}
)
;
}
filterSpocs
(
data
)
{
if
(
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
const
{
spocs
}
=
data
;
const
impressions
=
this
.
readImpressionsPref
(
PREF_SPOC_IMPRESSIONS
)
;
return
{
.
.
.
data
spocs
:
spocs
.
filter
(
s
=
>
this
.
isBelowFrequencyCap
(
impressions
s
)
)
}
;
}
return
data
;
}
isBelowFrequencyCap
(
impressions
spoc
)
{
const
campaignImpressions
=
impressions
[
spoc
.
campaign_id
]
;
if
(
!
campaignImpressions
)
{
return
true
;
}
const
lifetime
=
spoc
.
caps
&
&
spoc
.
caps
.
lifetime
;
const
lifeTimeCap
=
Math
.
min
(
lifetime
|
|
MAX_LIFETIME_CAP
MAX_LIFETIME_CAP
)
;
const
lifeTimeCapExceeded
=
campaignImpressions
.
length
>
=
lifeTimeCap
;
if
(
lifeTimeCapExceeded
)
{
return
false
;
}
const
campaignCap
=
spoc
.
caps
&
&
spoc
.
caps
.
campaign
;
if
(
campaignCap
)
{
const
campaignCapExceeded
=
campaignImpressions
.
filter
(
i
=
>
(
Date
.
now
(
)
-
i
)
<
(
campaignCap
.
period
*
1000
)
)
.
length
>
=
campaignCap
.
count
;
return
!
campaignCapExceeded
;
}
return
true
;
}
async
getComponentFeed
(
feedUrl
)
{
const
cachedData
=
await
this
.
cache
.
get
(
)
|
|
{
}
;
const
{
feeds
}
=
cachedData
;
let
feed
=
feeds
?
feeds
[
feedUrl
]
:
null
;
if
(
this
.
isExpired
(
cachedData
"
feed
"
feedUrl
)
)
{
const
feedResponse
=
await
this
.
fetchFromEndpoint
(
feedUrl
)
;
if
(
feedResponse
)
{
feed
=
{
lastUpdated
:
Date
.
now
(
)
data
:
feedResponse
}
;
}
else
{
Cu
.
reportError
(
"
No
response
for
feed
"
)
;
}
}
return
feed
;
}
async
refreshAll
(
options
=
{
}
)
{
const
dispatch
=
options
.
updateOpenTabs
?
action
=
>
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
action
)
)
:
this
.
store
.
dispatch
;
await
this
.
loadLayout
(
dispatch
)
;
await
this
.
loadComponentFeeds
(
dispatch
)
;
await
this
.
loadSpocs
(
dispatch
)
;
this
.
loaded
=
true
;
}
async
enable
(
)
{
await
this
.
refreshAll
(
{
updateOpenTabs
:
true
}
)
;
}
async
disable
(
)
{
await
this
.
clearCache
(
)
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_LAYOUT_RESET
}
)
)
;
this
.
loaded
=
false
;
}
async
clearCache
(
)
{
await
this
.
cache
.
set
(
"
layout
"
{
}
)
;
await
this
.
cache
.
set
(
"
feeds
"
{
}
)
;
await
this
.
cache
.
set
(
"
spocs
"
{
}
)
;
}
async
onPrefChange
(
)
{
if
(
this
.
config
.
enabled
)
{
await
this
.
clearCache
(
)
;
await
this
.
enable
(
)
;
}
if
(
this
.
loaded
&
&
!
this
.
config
.
enabled
)
{
await
this
.
disable
(
)
;
}
}
recordCampaignImpression
(
campaignId
)
{
let
impressions
=
this
.
readImpressionsPref
(
PREF_SPOC_IMPRESSIONS
)
;
const
timeStamps
=
impressions
[
campaignId
]
|
|
[
]
;
timeStamps
.
push
(
Date
.
now
(
)
)
;
impressions
=
{
.
.
.
impressions
[
campaignId
]
:
timeStamps
}
;
this
.
writeImpressionsPref
(
PREF_SPOC_IMPRESSIONS
impressions
)
;
}
cleanUpCampaignImpressionPref
(
data
)
{
if
(
data
.
spocs
&
&
data
.
spocs
.
length
)
{
const
campaignIds
=
data
.
spocs
.
map
(
s
=
>
{
s
.
campaign_id
}
)
;
this
.
cleanUpImpressionPref
(
id
=
>
!
campaignIds
.
includes
(
id
)
PREF_SPOC_IMPRESSIONS
)
;
}
}
writeImpressionsPref
(
pref
impressions
)
{
this
.
store
.
dispatch
(
ac
.
SetPref
(
pref
JSON
.
stringify
(
impressions
)
)
)
;
}
readImpressionsPref
(
pref
)
{
const
prefVal
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
pref
]
;
return
prefVal
?
JSON
.
parse
(
prefVal
)
:
{
}
;
}
cleanUpImpressionPref
(
isExpired
pref
)
{
const
impressions
=
this
.
readImpressionsPref
(
pref
)
;
let
changed
=
false
;
Object
.
keys
(
impressions
)
.
forEach
(
id
=
>
{
if
(
isExpired
(
id
)
)
{
changed
=
true
;
delete
impressions
[
id
]
;
}
}
)
;
if
(
changed
)
{
this
.
writeImpressionsPref
(
pref
impressions
)
;
}
}
async
onAction
(
action
)
{
switch
(
action
.
type
)
{
case
at
.
INIT
:
this
.
setupPrefs
(
)
;
if
(
this
.
config
.
enabled
)
{
await
this
.
enable
(
)
;
}
break
;
case
at
.
SYSTEM_TICK
:
if
(
this
.
config
.
enabled
&
&
this
.
loaded
&
&
await
this
.
checkIfAnyCacheExpired
(
)
)
{
await
this
.
refreshAll
(
{
updateOpenTabs
:
false
}
)
;
}
break
;
case
at
.
DISCOVERY_STREAM_CONFIG_SET_VALUE
:
if
(
action
.
data
.
name
=
=
=
"
enabled
"
&
&
action
.
data
.
value
)
{
this
.
store
.
dispatch
(
ac
.
SetPref
(
PREF_OPT_OUT
false
)
)
;
}
this
.
store
.
dispatch
(
ac
.
SetPref
(
PREF_CONFIG
JSON
.
stringify
(
{
.
.
.
JSON
.
parse
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_CONFIG
]
)
[
action
.
data
.
name
]
:
action
.
data
.
value
}
)
)
)
;
break
;
case
at
.
DISCOVERY_STREAM_CONFIG_CHANGE
:
await
this
.
onPrefChange
(
)
;
break
;
case
at
.
DISCOVERY_STREAM_OPT_OUT
:
this
.
store
.
dispatch
(
ac
.
SetPref
(
PREF_OPT_OUT
true
)
)
;
break
;
case
at
.
DISCOVERY_STREAM_SPOC_IMPRESSION
:
if
(
this
.
showSpocs
)
{
this
.
recordCampaignImpression
(
action
.
data
.
campaignId
)
;
const
cachedData
=
await
this
.
cache
.
get
(
)
|
|
{
}
;
const
{
spocs
}
=
cachedData
;
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_UPDATE
data
:
{
lastUpdated
:
spocs
.
lastUpdated
spocs
:
this
.
filterSpocs
(
spocs
.
data
)
}
}
)
)
;
}
break
;
case
at
.
UNINIT
:
this
.
uninitPrefs
(
)
;
break
;
case
at
.
PREF_CHANGED
:
switch
(
action
.
data
.
name
)
{
case
PREF_CONFIG
:
case
PREF_OPT_OUT
:
this
.
_prefCache
.
config
=
null
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_CONFIG_CHANGE
data
:
this
.
config
}
)
)
;
break
;
case
PREF_SHOW_SPONSORED
:
await
this
.
loadSpocs
(
)
;
break
;
}
break
;
}
}
}
;
const
EXPORTED_SYMBOLS
=
[
"
DiscoveryStreamFeed
"
]
;
