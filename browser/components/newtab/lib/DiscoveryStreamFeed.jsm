"
use
strict
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
NewTabUtils
:
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
RemoteSettings
"
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
pktApi
"
"
chrome
:
/
/
pocket
/
content
/
pktApi
.
jsm
"
)
;
const
{
setTimeout
clearTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
const
{
actionTypes
:
at
actionCreators
:
ac
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PersistentCache
"
"
resource
:
/
/
activity
-
stream
/
lib
/
PersistentCache
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ExperimentAPI
"
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
)
;
const
CACHE_KEY
=
"
discovery_stream
"
;
const
LAYOUT_UPDATE_TIME
=
30
*
60
*
1000
;
const
STARTUP_CACHE_EXPIRE_TIME
=
7
*
24
*
60
*
60
*
1000
;
const
COMPONENT_FEEDS_UPDATE_TIME
=
30
*
60
*
1000
;
const
SPOCS_FEEDS_UPDATE_TIME
=
30
*
60
*
1000
;
const
DEFAULT_RECS_EXPIRE_TIME
=
60
*
60
*
1000
;
const
MIN_PERSONALIZATION_UPDATE_TIME
=
12
*
60
*
60
*
1000
;
const
MAX_LIFETIME_CAP
=
500
;
const
FETCH_TIMEOUT
=
45
*
1000
;
const
SPOCS_URL
=
"
https
:
/
/
spocs
.
getpocket
.
com
/
spocs
"
;
const
PREF_CONFIG
=
"
discoverystream
.
config
"
;
const
PREF_ENDPOINTS
=
"
discoverystream
.
endpoints
"
;
const
PREF_IMPRESSION_ID
=
"
browser
.
newtabpage
.
activity
-
stream
.
impressionId
"
;
const
PREF_ENABLED
=
"
discoverystream
.
enabled
"
;
const
PREF_HARDCODED_BASIC_LAYOUT
=
"
discoverystream
.
hardcoded
-
basic
-
layout
"
;
const
PREF_SPOCS_ENDPOINT
=
"
discoverystream
.
spocs
-
endpoint
"
;
const
PREF_SPOCS_ENDPOINT_QUERY
=
"
discoverystream
.
spocs
-
endpoint
-
query
"
;
const
PREF_REGION_BASIC_LAYOUT
=
"
discoverystream
.
region
-
basic
-
layout
"
;
const
PREF_USER_TOPSTORIES
=
"
feeds
.
section
.
topstories
"
;
const
PREF_SYSTEM_TOPSTORIES
=
"
feeds
.
system
.
topstories
"
;
const
PREF_USER_TOPSITES
=
"
feeds
.
topsites
"
;
const
PREF_SYSTEM_TOPSITES
=
"
feeds
.
system
.
topsites
"
;
const
PREF_SPOCS_CLEAR_ENDPOINT
=
"
discoverystream
.
endpointSpocsClear
"
;
const
PREF_SHOW_SPONSORED
=
"
showSponsored
"
;
const
PREF_SHOW_SPONSORED_TOPSITES
=
"
showSponsoredTopSites
"
;
const
PREF_SPOC_IMPRESSIONS
=
"
discoverystream
.
spoc
.
impressions
"
;
const
PREF_FLIGHT_BLOCKS
=
"
discoverystream
.
flight
.
blocks
"
;
const
PREF_REC_IMPRESSIONS
=
"
discoverystream
.
rec
.
impressions
"
;
const
PREF_COLLECTIONS_ENABLED
=
"
discoverystream
.
sponsored
-
collections
.
enabled
"
;
const
PREF_POCKET_BUTTON
=
"
extensions
.
pocket
.
enabled
"
;
const
PREF_COLLECTION_DISMISSIBLE
=
"
discoverystream
.
isCollectionDismissible
"
;
const
PREF_PERSONALIZATION
=
"
discoverystream
.
personalization
.
enabled
"
;
const
PREF_PERSONALIZATION_OVERRIDE
=
"
discoverystream
.
personalization
.
override
"
;
let
getHardcodedLayout
;
class
DiscoveryStreamFeed
{
constructor
(
)
{
this
.
loaded
=
false
;
this
.
cache
=
new
lazy
.
PersistentCache
(
CACHE_KEY
true
)
;
this
.
locale
=
Services
.
locale
.
appLocaleAsBCP47
;
this
.
_impressionId
=
this
.
getOrCreateImpressionId
(
)
;
this
.
_prefCache
=
{
}
;
}
getOrCreateImpressionId
(
)
{
let
impressionId
=
Services
.
prefs
.
getCharPref
(
PREF_IMPRESSION_ID
"
"
)
;
if
(
!
impressionId
)
{
impressionId
=
String
(
Services
.
uuid
.
generateUUID
(
)
)
;
Services
.
prefs
.
setCharPref
(
PREF_IMPRESSION_ID
impressionId
)
;
}
return
impressionId
;
}
finalLayoutEndpoint
(
url
apiKey
)
{
if
(
url
.
includes
(
"
apiKey
"
)
&
&
!
apiKey
)
{
throw
new
Error
(
Layout
Endpoint
-
An
API
key
was
specified
but
none
configured
:
{
url
}
)
;
}
return
url
.
replace
(
"
apiKey
"
apiKey
)
;
}
get
config
(
)
{
if
(
this
.
_prefCache
.
config
)
{
return
this
.
_prefCache
.
config
;
}
try
{
this
.
_prefCache
.
config
=
JSON
.
parse
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_CONFIG
]
)
;
const
layoutUrl
=
this
.
_prefCache
.
config
.
layout_endpoint
;
const
apiKeyPref
=
this
.
_prefCache
.
config
.
api_key_pref
;
if
(
layoutUrl
&
&
apiKeyPref
)
{
const
apiKey
=
Services
.
prefs
.
getCharPref
(
apiKeyPref
"
"
)
;
this
.
_prefCache
.
config
.
layout_endpoint
=
this
.
finalLayoutEndpoint
(
layoutUrl
apiKey
)
;
}
}
catch
(
e
)
{
this
.
_prefCache
.
config
=
{
}
;
console
.
error
(
Could
not
parse
preference
.
Try
resetting
{
PREF_CONFIG
}
in
about
:
config
.
{
e
}
)
;
}
this
.
_prefCache
.
config
.
enabled
=
this
.
_prefCache
.
config
.
enabled
&
&
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_ENABLED
]
;
return
this
.
_prefCache
.
config
;
}
resetConfigDefauts
(
)
{
this
.
store
.
dispatch
(
{
type
:
at
.
CLEAR_PREF
data
:
{
name
:
PREF_CONFIG
}
}
)
;
}
get
region
(
)
{
return
lazy
.
Region
.
home
;
}
get
showSpocs
(
)
{
return
this
.
showSponsoredStories
|
|
this
.
showSponsoredTopsites
;
}
get
showSponsoredStories
(
)
{
return
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_SHOW_SPONSORED
]
&
&
this
.
config
.
show_spocs
)
;
}
get
showSponsoredTopsites
(
)
{
const
placements
=
this
.
getPlacements
(
)
;
return
!
!
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_SHOW_SPONSORED_TOPSITES
]
&
&
placements
.
find
(
placement
=
>
placement
.
name
=
=
=
"
sponsored
-
topsites
"
)
)
;
}
get
showStories
(
)
{
return
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_SYSTEM_TOPSTORIES
]
&
&
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_USER_TOPSTORIES
]
)
;
}
get
showTopsites
(
)
{
return
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_SYSTEM_TOPSITES
]
&
&
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_USER_TOPSITES
]
)
;
}
get
personalized
(
)
{
if
(
!
this
.
showStories
)
{
return
false
;
}
const
spocsPersonalized
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
?
.
spocsPersonalized
;
const
recsPersonalized
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
?
.
recsPersonalized
;
const
personalization
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_PERSONALIZATION
]
;
const
overrideState
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_PERSONALIZATION_OVERRIDE
]
;
return
(
personalization
&
&
!
overrideState
&
&
!
!
this
.
recommendationProvider
&
&
(
spocsPersonalized
|
|
recsPersonalized
)
)
;
}
get
recommendationProvider
(
)
{
if
(
this
.
_recommendationProvider
)
{
return
this
.
_recommendationProvider
;
}
this
.
_recommendationProvider
=
this
.
store
.
feeds
.
get
(
"
feeds
.
recommendationprovider
"
)
;
return
this
.
_recommendationProvider
;
}
setupConfig
(
isStartup
=
false
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_CONFIG_SETUP
data
:
this
.
config
meta
:
{
isStartup
}
}
)
)
;
}
setupPrefs
(
isStartup
=
false
)
{
const
pocketNewtabExperiment
=
lazy
.
ExperimentAPI
.
getExperimentMetaData
(
{
featureId
:
"
pocketNewtab
"
}
)
;
const
pocketNewtabRollout
=
lazy
.
ExperimentAPI
.
getRolloutMetaData
(
{
featureId
:
"
pocketNewtab
"
}
)
;
const
experimentMetaData
=
pocketNewtabExperiment
|
|
pocketNewtabRollout
;
let
utmSource
=
"
pocket
-
newtab
"
;
let
utmCampaign
=
experimentMetaData
?
.
slug
;
let
utmContent
=
experimentMetaData
?
.
branch
?
.
slug
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_EXPERIMENT_DATA
data
:
{
utmSource
utmCampaign
utmContent
}
meta
:
{
isStartup
}
}
)
)
;
const
pocketButtonEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_POCKET_BUTTON
)
;
const
nimbusConfig
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
|
|
{
}
;
const
{
region
}
=
this
.
store
.
getState
(
)
.
Prefs
.
values
;
this
.
setupSpocsCacheUpdateTime
(
)
;
const
saveToPocketCardRegions
=
nimbusConfig
.
saveToPocketCardRegions
?
.
split
(
"
"
)
.
map
(
s
=
>
s
.
trim
(
)
)
;
const
saveToPocketCard
=
pocketButtonEnabled
&
&
(
nimbusConfig
.
saveToPocketCard
|
|
saveToPocketCardRegions
?
.
includes
(
region
)
)
;
const
hideDescriptionsRegions
=
nimbusConfig
.
hideDescriptionsRegions
?
.
split
(
"
"
)
.
map
(
s
=
>
s
.
trim
(
)
)
;
const
hideDescriptions
=
nimbusConfig
.
hideDescriptions
|
|
hideDescriptionsRegions
?
.
includes
(
region
)
;
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
{
type
:
at
.
DISCOVERY_STREAM_PREFS_SETUP
data
:
{
recentSavesEnabled
:
nimbusConfig
.
recentSavesEnabled
pocketButtonEnabled
saveToPocketCard
hideDescriptions
compactImages
:
nimbusConfig
.
compactImages
imageGradient
:
nimbusConfig
.
imageGradient
newSponsoredLabel
:
nimbusConfig
.
newSponsoredLabel
titleLines
:
nimbusConfig
.
titleLines
descLines
:
nimbusConfig
.
descLines
readTime
:
nimbusConfig
.
readTime
}
meta
:
{
isStartup
}
}
)
)
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_COLLECTION_DISMISSIBLE_TOGGLE
data
:
{
value
:
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_COLLECTION_DISMISSIBLE
]
}
meta
:
{
isStartup
}
}
)
)
;
}
async
setupPocketState
(
target
)
{
let
dispatch
=
action
=
>
this
.
store
.
dispatch
(
ac
.
OnlyToOneContent
(
action
target
)
)
;
const
isUserLoggedIn
=
lazy
.
pktApi
.
isUserLoggedIn
(
)
;
dispatch
(
{
type
:
at
.
DISCOVERY_STREAM_POCKET_STATE_SET
data
:
{
isUserLoggedIn
}
}
)
;
if
(
isUserLoggedIn
)
{
let
recentSaves
=
await
lazy
.
pktApi
.
getRecentSavesCache
(
)
;
if
(
recentSaves
)
{
dispatch
(
{
type
:
at
.
DISCOVERY_STREAM_RECENT_SAVES
data
:
{
recentSaves
}
}
)
;
}
else
{
lazy
.
pktApi
.
getRecentSaves
(
{
success
(
data
)
{
dispatch
(
{
type
:
at
.
DISCOVERY_STREAM_RECENT_SAVES
data
:
{
recentSaves
:
data
}
}
)
;
}
error
(
error
)
{
}
}
)
;
}
}
}
uninitPrefs
(
)
{
this
.
_prefCache
=
{
}
;
}
async
fetchFromEndpoint
(
rawEndpoint
options
=
{
}
)
{
if
(
!
rawEndpoint
)
{
console
.
error
(
"
Tried
to
fetch
endpoint
but
none
was
configured
.
"
)
;
return
null
;
}
const
apiKeyPref
=
this
.
_prefCache
.
config
.
api_key_pref
;
const
apiKey
=
Services
.
prefs
.
getCharPref
(
apiKeyPref
"
"
)
;
const
endpoint
=
rawEndpoint
.
replace
(
"
apiKey
"
apiKey
)
.
replace
(
"
locale
"
this
.
locale
)
.
replace
(
"
region
"
this
.
region
)
;
try
{
const
allowed
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_ENDPOINTS
]
.
split
(
"
"
)
;
if
(
!
allowed
.
some
(
prefix
=
>
endpoint
.
startsWith
(
prefix
)
)
)
{
throw
new
Error
(
Not
one
of
allowed
prefixes
(
{
allowed
}
)
)
;
}
const
controller
=
new
AbortController
(
)
;
const
{
signal
}
=
controller
;
const
fetchPromise
=
fetch
(
endpoint
{
.
.
.
options
credentials
:
"
omit
"
signal
}
)
;
const
timeoutId
=
setTimeout
(
(
)
=
>
{
controller
.
abort
(
)
;
}
FETCH_TIMEOUT
)
;
const
response
=
await
fetchPromise
;
if
(
!
response
.
ok
)
{
throw
new
Error
(
Unexpected
status
(
{
response
.
status
}
)
)
;
}
clearTimeout
(
timeoutId
)
;
return
response
.
json
(
)
;
}
catch
(
error
)
{
console
.
error
(
Failed
to
fetch
{
endpoint
}
:
{
error
.
message
}
)
;
}
return
null
;
}
get
spocsCacheUpdateTime
(
)
{
if
(
this
.
_spocsCacheUpdateTime
)
{
return
this
.
_spocsCacheUpdateTime
;
}
this
.
setupSpocsCacheUpdateTime
(
)
;
return
this
.
_spocsCacheUpdateTime
;
}
setupSpocsCacheUpdateTime
(
)
{
const
nimbusConfig
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
|
|
{
}
;
const
{
spocsCacheTimeout
}
=
nimbusConfig
;
const
MAX_TIMEOUT
=
30
;
const
MIN_TIMEOUT
=
5
;
if
(
spocsCacheTimeout
&
&
spocsCacheTimeout
<
=
MAX_TIMEOUT
&
&
spocsCacheTimeout
>
=
MIN_TIMEOUT
)
{
this
.
_spocsCacheUpdateTime
=
spocsCacheTimeout
*
60
*
1000
;
}
else
{
this
.
_spocsCacheUpdateTime
=
SPOCS_FEEDS_UPDATE_TIME
;
}
}
isExpired
(
{
cachedData
key
url
isStartup
}
)
{
const
{
layout
spocs
feeds
}
=
cachedData
;
const
updateTimePerComponent
=
{
layout
:
LAYOUT_UPDATE_TIME
spocs
:
this
.
spocsCacheUpdateTime
feed
:
COMPONENT_FEEDS_UPDATE_TIME
}
;
const
EXPIRATION_TIME
=
isStartup
?
STARTUP_CACHE_EXPIRE_TIME
:
updateTimePerComponent
[
key
]
;
switch
(
key
)
{
case
"
layout
"
:
if
(
this
.
config
.
hardcoded_layout
)
{
return
false
;
}
return
!
layout
|
|
!
(
Date
.
now
(
)
-
layout
.
lastUpdated
<
EXPIRATION_TIME
)
;
case
"
spocs
"
:
return
!
spocs
|
|
!
(
Date
.
now
(
)
-
spocs
.
lastUpdated
<
EXPIRATION_TIME
)
;
case
"
feed
"
:
return
(
!
feeds
|
|
!
feeds
[
url
]
|
|
!
(
Date
.
now
(
)
-
feeds
[
url
]
.
lastUpdated
<
EXPIRATION_TIME
)
)
;
default
:
throw
new
Error
(
{
key
}
is
not
a
valid
key
)
;
}
}
async
_checkExpirationPerComponent
(
)
{
const
cachedData
=
(
await
this
.
cache
.
get
(
)
)
|
|
{
}
;
const
{
feeds
}
=
cachedData
;
return
{
layout
:
this
.
isExpired
(
{
cachedData
key
:
"
layout
"
}
)
spocs
:
this
.
showSpocs
&
&
this
.
isExpired
(
{
cachedData
key
:
"
spocs
"
}
)
feeds
:
this
.
showStories
&
&
(
!
feeds
|
|
Object
.
keys
(
feeds
)
.
some
(
url
=
>
this
.
isExpired
(
{
cachedData
key
:
"
feed
"
url
}
)
)
)
}
;
}
async
checkIfAnyCacheExpired
(
)
{
const
expirationPerComponent
=
await
this
.
_checkExpirationPerComponent
(
)
;
return
(
expirationPerComponent
.
layout
|
|
expirationPerComponent
.
spocs
|
|
expirationPerComponent
.
feeds
)
;
}
async
fetchLayout
(
isStartup
)
{
const
cachedData
=
(
await
this
.
cache
.
get
(
)
)
|
|
{
}
;
let
{
layout
}
=
cachedData
;
if
(
this
.
isExpired
(
{
cachedData
key
:
"
layout
"
isStartup
}
)
)
{
const
layoutResponse
=
await
this
.
fetchFromEndpoint
(
this
.
config
.
layout_endpoint
)
;
if
(
layoutResponse
&
&
layoutResponse
.
layout
)
{
layout
=
{
lastUpdated
:
Date
.
now
(
)
spocs
:
layoutResponse
.
spocs
layout
:
layoutResponse
.
layout
status
:
"
success
"
}
;
await
this
.
cache
.
set
(
"
layout
"
layout
)
;
}
else
{
console
.
error
(
"
No
response
for
response
.
layout
prop
"
)
;
}
}
return
layout
;
}
updatePlacements
(
sendUpdate
layout
isStartup
=
false
)
{
const
placements
=
[
]
;
const
placementsMap
=
{
}
;
for
(
const
row
of
layout
.
filter
(
r
=
>
r
.
components
&
&
r
.
components
.
length
)
)
{
for
(
const
component
of
row
.
components
.
filter
(
c
=
>
c
.
placement
&
&
c
.
spocs
)
)
{
let
placement
;
if
(
component
.
spocs
.
prefs
)
{
if
(
component
.
spocs
.
prefs
.
length
&
&
component
.
spocs
.
prefs
.
every
(
p
=
>
this
.
store
.
getState
(
)
.
Prefs
.
values
[
p
]
)
)
{
placement
=
component
.
placement
;
}
}
else
if
(
this
.
showSponsoredStories
)
{
placement
=
component
.
placement
;
}
if
(
placement
?
.
name
&
&
!
placementsMap
[
placement
.
name
]
)
{
placementsMap
[
placement
.
name
]
=
placement
;
placements
.
push
(
placement
)
;
}
}
}
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_PLACEMENTS
data
:
{
placements
}
meta
:
{
isStartup
}
}
)
;
}
addEndpointQuery
(
url
query
)
{
if
(
!
query
)
{
return
url
;
}
const
urlObject
=
new
URL
(
url
)
;
const
params
=
new
URLSearchParams
(
query
)
;
for
(
let
[
key
val
]
of
params
.
entries
(
)
)
{
urlObject
.
searchParams
.
append
(
key
val
)
;
}
return
urlObject
.
toString
(
)
;
}
parseGridPositions
(
csvPositions
)
{
let
gridPositions
;
try
{
gridPositions
=
csvPositions
.
map
(
index
=
>
{
let
parsedInt
=
parseInt
(
index
10
)
;
if
(
!
isNaN
(
parsedInt
)
&
&
parsedInt
>
=
0
)
{
return
parsedInt
;
}
throw
new
Error
(
"
Bad
input
"
)
;
}
)
;
}
catch
(
e
)
{
gridPositions
=
undefined
;
}
return
gridPositions
;
}
async
loadLayout
(
sendUpdate
isStartup
)
{
let
layoutResp
=
{
}
;
let
url
=
"
"
;
if
(
!
this
.
config
.
hardcoded_layout
)
{
layoutResp
=
await
this
.
fetchLayout
(
isStartup
)
;
}
if
(
!
layoutResp
|
|
!
layoutResp
.
layout
)
{
const
isBasicLayout
=
this
.
config
.
hardcoded_basic_layout
|
|
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_HARDCODED_BASIC_LAYOUT
]
|
|
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_REGION_BASIC_LAYOUT
]
;
const
sponsoredCollectionsEnabled
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_COLLECTIONS_ENABLED
]
;
const
pocketConfig
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
|
|
{
}
;
let
items
=
isBasicLayout
?
3
:
21
;
if
(
pocketConfig
.
fourCardLayout
|
|
pocketConfig
.
hybridLayout
)
{
items
=
isBasicLayout
?
4
:
24
;
}
const
prepConfArr
=
arr
=
>
{
return
arr
?
.
split
(
"
"
)
.
filter
(
item
=
>
item
)
.
map
(
item
=
>
parseInt
(
item
10
)
)
;
}
;
const
spocAdTypes
=
prepConfArr
(
pocketConfig
.
spocAdTypes
)
;
const
spocZoneIds
=
prepConfArr
(
pocketConfig
.
spocZoneIds
)
;
const
spocTopsitesAdTypes
=
prepConfArr
(
pocketConfig
.
spocTopsitesAdTypes
)
;
const
spocTopsitesZoneIds
=
prepConfArr
(
pocketConfig
.
spocTopsitesZoneIds
)
;
const
{
spocSiteId
}
=
pocketConfig
;
let
spocPlacementData
;
let
spocTopsitesPlacementData
;
let
spocsUrl
;
if
(
spocAdTypes
?
.
length
&
&
spocZoneIds
?
.
length
)
{
spocPlacementData
=
{
ad_types
:
spocAdTypes
zone_ids
:
spocZoneIds
}
;
}
if
(
spocTopsitesAdTypes
?
.
length
&
&
spocTopsitesZoneIds
?
.
length
)
{
spocTopsitesPlacementData
=
{
ad_types
:
spocTopsitesAdTypes
zone_ids
:
spocTopsitesZoneIds
}
;
}
if
(
spocSiteId
)
{
const
newUrl
=
new
URL
(
SPOCS_URL
)
;
newUrl
.
searchParams
.
set
(
"
site
"
spocSiteId
)
;
spocsUrl
=
newUrl
.
href
;
}
layoutResp
=
getHardcodedLayout
(
{
spocsUrl
items
sponsoredCollectionsEnabled
spocPlacementData
spocTopsitesPlacementData
spocPositions
:
this
.
parseGridPositions
(
pocketConfig
.
spocPositions
?
.
split
(
)
)
widgetPositions
:
this
.
parseGridPositions
(
pocketConfig
.
widgetPositions
?
.
split
(
)
)
widgetData
:
[
.
.
.
(
this
.
locale
.
startsWith
(
"
en
-
"
)
?
[
{
type
:
"
TopicsWidget
"
}
]
:
[
]
)
]
hybridLayout
:
pocketConfig
.
hybridLayout
hideCardBackground
:
pocketConfig
.
hideCardBackground
fourCardLayout
:
pocketConfig
.
fourCardLayout
newFooterSection
:
pocketConfig
.
newFooterSection
compactGrid
:
pocketConfig
.
compactGrid
essentialReadsHeader
:
this
.
locale
.
startsWith
(
"
en
-
"
)
&
&
pocketConfig
.
essentialReadsHeader
editorsPicksHeader
:
this
.
locale
.
startsWith
(
"
en
-
"
)
&
&
pocketConfig
.
editorsPicksHeader
}
)
;
}
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_LAYOUT_UPDATE
data
:
layoutResp
meta
:
{
isStartup
}
}
)
;
if
(
layoutResp
.
spocs
)
{
url
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_SPOCS_ENDPOINT
]
|
|
this
.
config
.
spocs_endpoint
|
|
layoutResp
.
spocs
.
url
;
const
spocsEndpointQuery
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_SPOCS_ENDPOINT_QUERY
]
;
url
=
this
.
addEndpointQuery
(
url
spocsEndpointQuery
)
;
if
(
url
&
&
url
!
=
=
this
.
store
.
getState
(
)
.
DiscoveryStream
.
spocs
.
spocs_endpoint
)
{
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_ENDPOINT
data
:
{
url
}
meta
:
{
isStartup
}
}
)
;
this
.
updatePlacements
(
sendUpdate
layoutResp
.
layout
isStartup
)
;
}
}
}
buildFeedPromise
(
{
newFeedsPromises
newFeeds
}
isStartup
=
false
sendUpdate
)
{
return
component
=
>
{
const
{
url
}
=
component
.
feed
;
if
(
!
newFeeds
[
url
]
)
{
newFeeds
[
url
]
=
{
}
;
const
feedPromise
=
this
.
getComponentFeed
(
url
isStartup
)
;
feedPromise
.
then
(
feed
=
>
{
newFeeds
[
url
]
=
this
.
filterRecommendations
(
feed
)
;
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_FEED_UPDATE
data
:
{
feed
:
newFeeds
[
url
]
url
}
meta
:
{
isStartup
}
}
)
;
}
)
.
catch
(
error
=
>
{
console
.
error
(
Error
trying
to
load
component
feed
{
url
}
:
{
error
}
)
;
}
)
;
newFeedsPromises
.
push
(
feedPromise
)
;
}
}
;
}
filterRecommendations
(
feed
)
{
if
(
feed
&
&
feed
.
data
&
&
feed
.
data
.
recommendations
&
&
feed
.
data
.
recommendations
.
length
)
{
const
{
data
:
recommendations
}
=
this
.
filterBlocked
(
feed
.
data
.
recommendations
)
;
return
{
.
.
.
feed
data
:
{
.
.
.
feed
.
data
recommendations
}
}
;
}
return
feed
;
}
reduceFeedComponents
(
isStartup
sendUpdate
)
{
return
(
accumulator
row
)
=
>
{
row
.
components
.
filter
(
component
=
>
component
&
&
component
.
feed
)
.
forEach
(
this
.
buildFeedPromise
(
accumulator
isStartup
sendUpdate
)
)
;
return
accumulator
;
}
;
}
buildFeedPromises
(
layout
isStartup
sendUpdate
)
{
const
initialData
=
{
newFeedsPromises
:
[
]
newFeeds
:
{
}
}
;
return
layout
.
filter
(
row
=
>
row
&
&
row
.
components
)
.
reduce
(
this
.
reduceFeedComponents
(
isStartup
sendUpdate
)
initialData
)
;
}
async
loadComponentFeeds
(
sendUpdate
isStartup
=
false
)
{
const
{
DiscoveryStream
}
=
this
.
store
.
getState
(
)
;
if
(
!
DiscoveryStream
|
|
!
DiscoveryStream
.
layout
)
{
return
;
}
this
.
componentFeedFetched
=
false
;
const
{
newFeedsPromises
newFeeds
}
=
this
.
buildFeedPromises
(
DiscoveryStream
.
layout
isStartup
sendUpdate
)
;
await
Promise
.
all
(
newFeedsPromises
)
;
if
(
this
.
componentFeedFetched
)
{
this
.
cleanUpTopRecImpressionPref
(
newFeeds
)
;
}
await
this
.
cache
.
set
(
"
feeds
"
newFeeds
)
;
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_FEEDS_UPDATE
meta
:
{
isStartup
}
}
)
;
}
getPlacements
(
)
{
const
{
placements
}
=
this
.
store
.
getState
(
)
.
DiscoveryStream
.
spocs
;
return
placements
;
}
placementsForEach
(
callback
)
{
this
.
getPlacements
(
)
.
forEach
(
callback
)
;
}
normalizeSpocsItems
(
spocs
)
{
const
items
=
spocs
.
items
|
|
spocs
;
const
title
=
spocs
.
title
|
|
"
"
;
const
context
=
spocs
.
context
|
|
"
"
;
const
sponsor
=
spocs
.
sponsor
|
|
"
"
;
const
{
sponsored_by_override
}
=
spocs
;
const
{
flight_id
}
=
spocs
;
return
{
items
title
context
sponsor
sponsored_by_override
.
.
.
(
flight_id
?
{
flight_id
}
:
{
}
)
}
;
}
personalizationOverride
(
overrideCommand
)
{
const
overrideState
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_PERSONALIZATION_OVERRIDE
]
;
const
personalization
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_PERSONALIZATION
]
;
if
(
overrideCommand
&
&
personalization
&
&
!
overrideState
)
{
this
.
store
.
dispatch
(
ac
.
SetPref
(
PREF_PERSONALIZATION_OVERRIDE
true
)
)
;
}
if
(
!
overrideCommand
&
&
overrideState
)
{
this
.
store
.
dispatch
(
{
type
:
at
.
CLEAR_PREF
data
:
{
name
:
PREF_PERSONALIZATION_OVERRIDE
}
}
)
;
}
}
updateSponsoredCollectionsPref
(
collectionEnabled
=
false
)
{
const
currentState
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_COLLECTIONS_ENABLED
]
;
if
(
currentState
!
=
=
collectionEnabled
)
{
this
.
store
.
dispatch
(
ac
.
SetPref
(
PREF_COLLECTIONS_ENABLED
collectionEnabled
)
)
;
}
}
async
loadSpocs
(
sendUpdate
isStartup
)
{
const
cachedData
=
(
await
this
.
cache
.
get
(
)
)
|
|
{
}
;
let
spocsState
;
const
placements
=
this
.
getPlacements
(
)
;
if
(
this
.
showSpocs
&
&
placements
?
.
length
)
{
spocsState
=
cachedData
.
spocs
;
if
(
this
.
isExpired
(
{
cachedData
key
:
"
spocs
"
isStartup
}
)
)
{
const
endpoint
=
this
.
store
.
getState
(
)
.
DiscoveryStream
.
spocs
.
spocs_endpoint
;
const
headers
=
new
Headers
(
)
;
headers
.
append
(
"
content
-
type
"
"
application
/
json
"
)
;
const
apiKeyPref
=
this
.
_prefCache
.
config
.
api_key_pref
;
const
apiKey
=
Services
.
prefs
.
getCharPref
(
apiKeyPref
"
"
)
;
const
spocsResponse
=
await
this
.
fetchFromEndpoint
(
endpoint
{
method
:
"
POST
"
headers
body
:
JSON
.
stringify
(
{
pocket_id
:
this
.
_impressionId
version
:
2
consumer_key
:
apiKey
.
.
.
(
placements
.
length
?
{
placements
}
:
{
}
)
}
)
}
)
;
if
(
spocsResponse
)
{
spocsState
=
{
lastUpdated
:
Date
.
now
(
)
spocs
:
{
.
.
.
spocsResponse
}
}
;
if
(
spocsResponse
.
settings
&
&
spocsResponse
.
settings
.
feature_flags
)
{
this
.
personalizationOverride
(
!
spocsResponse
.
settings
.
feature_flags
.
spoc_v2
)
;
this
.
updateSponsoredCollectionsPref
(
spocsResponse
.
settings
.
feature_flags
.
collections
)
;
}
const
spocsResultPromises
=
this
.
getPlacements
(
)
.
map
(
async
placement
=
>
{
const
freshSpocs
=
spocsState
.
spocs
[
placement
.
name
]
;
if
(
!
freshSpocs
)
{
return
;
}
const
{
items
:
normalizedSpocsItems
title
context
sponsor
sponsored_by_override
}
=
this
.
normalizeSpocsItems
(
freshSpocs
)
;
if
(
!
normalizedSpocsItems
|
|
!
normalizedSpocsItems
.
length
)
{
spocsState
.
spocs
=
{
.
.
.
spocsState
.
spocs
[
placement
.
name
]
:
{
title
context
items
:
[
]
}
}
;
return
;
}
const
{
data
:
migratedSpocs
}
=
this
.
migrateFlightId
(
normalizedSpocsItems
)
;
const
{
data
:
capResult
}
=
this
.
frequencyCapSpocs
(
migratedSpocs
)
;
const
{
data
:
blockedResults
}
=
this
.
filterBlocked
(
capResult
)
;
const
{
data
:
scoredResults
}
=
await
this
.
scoreItems
(
blockedResults
"
spocs
"
)
;
spocsState
.
spocs
=
{
.
.
.
spocsState
.
spocs
[
placement
.
name
]
:
{
title
context
sponsor
sponsored_by_override
items
:
scoredResults
}
}
;
}
)
;
await
Promise
.
all
(
spocsResultPromises
)
;
this
.
cleanUpFlightImpressionPref
(
spocsState
.
spocs
)
;
await
this
.
cache
.
set
(
"
spocs
"
{
lastUpdated
:
spocsState
.
lastUpdated
spocs
:
spocsState
.
spocs
}
)
;
}
else
{
console
.
error
(
"
No
response
for
spocs_endpoint
prop
"
)
;
}
}
}
spocsState
=
spocsState
&
&
spocsState
.
spocs
?
spocsState
:
{
lastUpdated
:
Date
.
now
(
)
spocs
:
{
}
}
;
sendUpdate
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_UPDATE
data
:
{
lastUpdated
:
spocsState
.
lastUpdated
spocs
:
spocsState
.
spocs
}
meta
:
{
isStartup
}
}
)
;
}
async
clearSpocs
(
)
{
const
endpoint
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_SPOCS_CLEAR_ENDPOINT
]
;
if
(
!
endpoint
)
{
return
;
}
const
headers
=
new
Headers
(
)
;
headers
.
append
(
"
content
-
type
"
"
application
/
json
"
)
;
await
this
.
fetchFromEndpoint
(
endpoint
{
method
:
"
DELETE
"
headers
body
:
JSON
.
stringify
(
{
pocket_id
:
this
.
_impressionId
}
)
}
)
;
}
async
loadPersonalizationScoresCache
(
isStartup
=
false
)
{
const
cachedData
=
(
await
this
.
cache
.
get
(
)
)
|
|
{
}
;
const
{
personalization
}
=
cachedData
;
if
(
this
.
personalized
&
&
personalization
&
&
personalization
.
scores
)
{
this
.
recommendationProvider
.
setProvider
(
personalization
.
scores
)
;
this
.
personalizationLastUpdated
=
personalization
.
_timestamp
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_PERSONALIZATION_LAST_UPDATED
data
:
{
lastUpdated
:
this
.
personalizationLastUpdated
}
meta
:
{
isStartup
}
}
)
)
;
}
}
async
updatePersonalizationScores
(
)
{
if
(
!
this
.
personalized
|
|
Date
.
now
(
)
-
this
.
personalizationLastUpdated
<
MIN_PERSONALIZATION_UPDATE_TIME
)
{
return
;
}
this
.
recommendationProvider
.
setProvider
(
)
;
await
this
.
recommendationProvider
.
init
(
)
;
const
personalization
=
{
scores
:
this
.
recommendationProvider
.
getScores
(
)
}
;
this
.
personalizationLastUpdated
=
Date
.
now
(
)
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_PERSONALIZATION_LAST_UPDATED
data
:
{
lastUpdated
:
this
.
personalizationLastUpdated
}
}
)
)
;
personalization
.
_timestamp
=
this
.
personalizationLastUpdated
;
this
.
cache
.
set
(
"
personalization
"
personalization
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
idle
-
daily
"
:
this
.
updatePersonalizationScores
(
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
data
=
=
=
PREF_POCKET_BUTTON
)
{
this
.
configReset
(
)
;
}
break
;
}
}
sortItem
(
a
b
)
{
if
(
a
.
priority
=
=
=
b
.
priority
)
{
return
b
.
score
-
a
.
score
;
}
else
if
(
!
a
.
priority
|
|
a
.
priority
<
=
0
)
{
return
1
;
}
else
if
(
!
b
.
priority
|
|
b
.
priority
<
=
0
)
{
return
-
1
;
}
return
a
.
priority
-
b
.
priority
;
}
async
scoreItems
(
items
type
)
{
const
spocsPersonalized
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
?
.
spocsPersonalized
;
const
recsPersonalized
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
?
.
recsPersonalized
;
const
personalizedByType
=
type
=
=
=
"
feed
"
?
recsPersonalized
:
spocsPersonalized
;
const
data
=
(
await
Promise
.
all
(
items
.
map
(
item
=
>
this
.
scoreItem
(
item
personalizedByType
)
)
)
)
.
sort
(
this
.
sortItem
)
;
return
{
data
}
;
}
async
scoreItem
(
item
personalizedByType
)
{
item
.
score
=
item
.
item_score
;
if
(
item
.
score
!
=
=
0
&
&
!
item
.
score
)
{
item
.
score
=
1
;
}
if
(
this
.
personalized
&
&
personalizedByType
)
{
await
this
.
recommendationProvider
.
calculateItemRelevanceScore
(
item
)
;
}
return
item
;
}
filterBlocked
(
data
)
{
if
(
data
&
&
data
.
length
)
{
let
flights
=
this
.
readDataPref
(
PREF_FLIGHT_BLOCKS
)
;
const
filteredItems
=
data
.
filter
(
item
=
>
{
const
blocked
=
lazy
.
NewTabUtils
.
blockedLinks
.
isBlocked
(
{
url
:
item
.
url
}
)
|
|
flights
[
item
.
flight_id
]
;
return
!
blocked
;
}
)
;
return
{
data
:
filteredItems
}
;
}
return
{
data
}
;
}
migrateFlightId
(
spocs
)
{
if
(
spocs
&
&
spocs
.
length
)
{
return
{
data
:
spocs
.
map
(
s
=
>
{
return
{
.
.
.
s
.
.
.
(
s
.
flight_id
|
|
s
.
campaign_id
?
{
flight_id
:
s
.
flight_id
|
|
s
.
campaign_id
}
:
{
}
)
.
.
.
(
s
.
caps
?
{
caps
:
{
.
.
.
s
.
caps
flight
:
s
.
caps
.
flight
|
|
s
.
caps
.
campaign
}
}
:
{
}
)
}
;
}
)
}
;
}
return
{
data
:
spocs
}
;
}
frequencyCapSpocs
(
spocs
)
{
if
(
spocs
&
&
spocs
.
length
)
{
const
impressions
=
this
.
readDataPref
(
PREF_SPOC_IMPRESSIONS
)
;
const
caps
=
[
]
;
const
result
=
spocs
.
filter
(
s
=
>
{
const
isBelow
=
this
.
isBelowFrequencyCap
(
impressions
s
)
;
if
(
!
isBelow
)
{
caps
.
push
(
s
)
;
}
return
isBelow
;
}
)
;
if
(
caps
.
length
)
{
this
.
store
.
dispatch
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_CAPS
data
:
caps
}
)
;
}
return
{
data
:
result
filtered
:
caps
}
;
}
return
{
data
:
spocs
filtered
:
[
]
}
;
}
isBelowFrequencyCap
(
impressions
spoc
)
{
const
flightImpressions
=
impressions
[
spoc
.
flight_id
]
;
if
(
!
flightImpressions
)
{
return
true
;
}
const
lifetime
=
spoc
.
caps
&
&
spoc
.
caps
.
lifetime
;
const
lifeTimeCap
=
Math
.
min
(
lifetime
|
|
MAX_LIFETIME_CAP
MAX_LIFETIME_CAP
)
;
const
lifeTimeCapExceeded
=
flightImpressions
.
length
>
=
lifeTimeCap
;
if
(
lifeTimeCapExceeded
)
{
return
false
;
}
const
flightCap
=
spoc
.
caps
&
&
spoc
.
caps
.
flight
;
if
(
flightCap
)
{
const
flightCapExceeded
=
flightImpressions
.
filter
(
i
=
>
Date
.
now
(
)
-
i
<
flightCap
.
period
*
1000
)
.
length
>
=
flightCap
.
count
;
return
!
flightCapExceeded
;
}
return
true
;
}
async
retryFeed
(
feed
)
{
const
{
url
}
=
feed
;
const
result
=
await
this
.
getComponentFeed
(
url
)
;
const
newFeed
=
this
.
filterRecommendations
(
result
)
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_FEED_UPDATE
data
:
{
feed
:
newFeed
url
}
}
)
)
;
}
async
getComponentFeed
(
feedUrl
isStartup
)
{
const
cachedData
=
(
await
this
.
cache
.
get
(
)
)
|
|
{
}
;
const
{
feeds
}
=
cachedData
;
let
feed
=
feeds
?
feeds
[
feedUrl
]
:
null
;
if
(
this
.
isExpired
(
{
cachedData
key
:
"
feed
"
url
:
feedUrl
isStartup
}
)
)
{
const
feedResponse
=
await
this
.
fetchFromEndpoint
(
feedUrl
)
;
if
(
feedResponse
)
{
const
{
data
:
scoredItems
}
=
await
this
.
scoreItems
(
feedResponse
.
recommendations
"
feed
"
)
;
const
{
recsExpireTime
}
=
feedResponse
.
settings
;
const
recommendations
=
this
.
rotate
(
scoredItems
recsExpireTime
)
;
this
.
componentFeedFetched
=
true
;
feed
=
{
lastUpdated
:
Date
.
now
(
)
data
:
{
settings
:
feedResponse
.
settings
recommendations
status
:
"
success
"
}
}
;
}
else
{
console
.
error
(
"
No
response
for
feed
"
)
;
}
}
return
(
feed
|
|
{
data
:
{
status
:
"
failed
"
}
}
)
;
}
async
_maybeUpdateCachedData
(
)
{
const
expirationPerComponent
=
await
this
.
_checkExpirationPerComponent
(
)
;
if
(
expirationPerComponent
.
layout
)
{
await
this
.
loadLayout
(
this
.
store
.
dispatch
)
;
}
if
(
expirationPerComponent
.
spocs
)
{
await
this
.
loadSpocs
(
this
.
store
.
dispatch
)
;
}
if
(
expirationPerComponent
.
feeds
)
{
await
this
.
loadComponentFeeds
(
this
.
store
.
dispatch
)
;
}
}
async
refreshAll
(
options
=
{
}
)
{
const
personalizationCacheLoadPromise
=
this
.
loadPersonalizationScoresCache
(
options
.
isStartup
)
;
const
spocsPersonalized
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
?
.
spocsPersonalized
;
const
recsPersonalized
=
this
.
store
.
getState
(
)
.
Prefs
.
values
?
.
pocketConfig
?
.
recsPersonalized
;
let
expirationPerComponent
=
{
}
;
if
(
this
.
personalized
)
{
expirationPerComponent
=
await
this
.
_checkExpirationPerComponent
(
)
;
}
await
this
.
refreshContent
(
options
)
;
if
(
this
.
personalized
)
{
personalizationCacheLoadPromise
.
then
(
(
)
=
>
{
const
initPromise
=
this
.
recommendationProvider
.
init
(
)
;
initPromise
.
then
(
(
)
=
>
{
const
{
feeds
spocs
}
=
this
.
store
.
getState
(
)
.
DiscoveryStream
;
if
(
recsPersonalized
&
&
feeds
.
loaded
&
&
expirationPerComponent
.
feeds
)
{
this
.
scoreFeeds
(
feeds
)
;
}
if
(
spocsPersonalized
&
&
spocs
.
loaded
&
&
expirationPerComponent
.
spocs
)
{
this
.
scoreSpocs
(
spocs
)
;
}
}
)
;
}
)
;
}
}
async
scoreFeeds
(
feedsState
)
{
if
(
feedsState
.
data
)
{
const
feeds
=
{
}
;
const
feedsPromises
=
Object
.
keys
(
feedsState
.
data
)
.
map
(
url
=
>
{
let
feed
=
feedsState
.
data
[
url
]
;
const
feedPromise
=
this
.
scoreItems
(
feed
.
data
.
recommendations
"
feed
"
)
;
feedPromise
.
then
(
(
{
data
:
scoredItems
}
)
=
>
{
const
{
recsExpireTime
}
=
feed
.
data
.
settings
;
const
recommendations
=
this
.
rotate
(
scoredItems
recsExpireTime
)
;
feed
=
{
.
.
.
feed
data
:
{
.
.
.
feed
.
data
recommendations
}
}
;
feeds
[
url
]
=
feed
;
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
{
type
:
at
.
DISCOVERY_STREAM_FEED_UPDATE
data
:
{
feed
url
}
}
)
)
;
}
)
;
return
feedPromise
;
}
)
;
await
Promise
.
all
(
feedsPromises
)
;
await
this
.
cache
.
set
(
"
feeds
"
feeds
)
;
}
}
async
scoreSpocs
(
spocsState
)
{
const
spocsResultPromises
=
this
.
getPlacements
(
)
.
map
(
async
placement
=
>
{
const
nextSpocs
=
spocsState
.
data
[
placement
.
name
]
|
|
{
}
;
const
{
items
}
=
nextSpocs
;
if
(
!
items
|
|
!
items
.
length
)
{
return
;
}
const
{
data
:
scoreResult
}
=
await
this
.
scoreItems
(
items
"
spocs
"
)
;
spocsState
.
data
=
{
.
.
.
spocsState
.
data
[
placement
.
name
]
:
{
.
.
.
nextSpocs
items
:
scoreResult
}
}
;
}
)
;
await
Promise
.
all
(
spocsResultPromises
)
;
await
this
.
cache
.
set
(
"
spocs
"
{
lastUpdated
:
spocsState
.
lastUpdated
spocs
:
spocsState
.
data
}
)
;
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_UPDATE
data
:
{
lastUpdated
:
spocsState
.
lastUpdated
spocs
:
spocsState
.
data
}
}
)
)
;
}
async
refreshContent
(
options
=
{
}
)
{
const
{
updateOpenTabs
isStartup
}
=
options
;
const
dispatch
=
updateOpenTabs
?
action
=
>
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
action
)
)
:
this
.
store
.
dispatch
;
await
this
.
loadLayout
(
dispatch
isStartup
)
;
if
(
this
.
showStories
|
|
this
.
showTopsites
)
{
const
promises
=
[
]
;
const
spocsPromise
=
this
.
loadSpocs
(
dispatch
isStartup
)
.
catch
(
error
=
>
console
.
error
(
Error
trying
to
load
spocs
feeds
:
{
error
}
)
)
;
promises
.
push
(
spocsPromise
)
;
if
(
this
.
showStories
)
{
const
storiesPromise
=
this
.
loadComponentFeeds
(
dispatch
isStartup
)
.
catch
(
error
=
>
console
.
error
(
Error
trying
to
load
component
feeds
:
{
error
}
)
)
;
promises
.
push
(
storiesPromise
)
;
}
await
Promise
.
all
(
promises
)
;
if
(
isStartup
)
{
await
this
.
_maybeUpdateCachedData
(
)
;
}
}
}
rotate
(
recommendations
recsExpireTime
)
{
const
maxImpressionAge
=
Math
.
max
(
recsExpireTime
*
1000
|
|
DEFAULT_RECS_EXPIRE_TIME
DEFAULT_RECS_EXPIRE_TIME
)
;
const
impressions
=
this
.
readDataPref
(
PREF_REC_IMPRESSIONS
)
;
const
expired
=
[
]
;
const
active
=
[
]
;
for
(
const
item
of
recommendations
)
{
if
(
impressions
[
item
.
id
]
&
&
Date
.
now
(
)
-
impressions
[
item
.
id
]
>
=
maxImpressionAge
)
{
expired
.
push
(
item
)
;
}
else
{
active
.
push
(
item
)
;
}
}
return
active
.
concat
(
expired
)
;
}
enableStories
(
)
{
if
(
this
.
config
.
enabled
&
&
this
.
loaded
)
{
this
.
refreshAll
(
{
updateOpenTabs
:
true
}
)
;
}
}
async
enable
(
)
{
await
this
.
refreshAll
(
{
updateOpenTabs
:
true
isStartup
:
true
}
)
;
Services
.
obs
.
addObserver
(
this
"
idle
-
daily
"
)
;
this
.
loaded
=
true
;
}
async
reset
(
)
{
this
.
resetDataPrefs
(
)
;
await
this
.
resetCache
(
)
;
if
(
this
.
loaded
)
{
Services
.
obs
.
removeObserver
(
this
"
idle
-
daily
"
)
;
}
this
.
resetState
(
)
;
}
async
resetCache
(
)
{
await
this
.
resetAllCache
(
)
;
}
async
resetContentCache
(
)
{
await
this
.
cache
.
set
(
"
layout
"
{
}
)
;
await
this
.
cache
.
set
(
"
feeds
"
{
}
)
;
await
this
.
cache
.
set
(
"
spocs
"
{
}
)
;
}
async
resetAllCache
(
)
{
await
this
.
resetContentCache
(
)
;
await
this
.
cache
.
set
(
"
personalization
"
{
}
)
;
}
resetDataPrefs
(
)
{
this
.
writeDataPref
(
PREF_SPOC_IMPRESSIONS
{
}
)
;
this
.
writeDataPref
(
PREF_REC_IMPRESSIONS
{
}
)
;
this
.
writeDataPref
(
PREF_FLIGHT_BLOCKS
{
}
)
;
}
resetState
(
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_LAYOUT_RESET
}
)
)
;
this
.
setupPrefs
(
false
)
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_COLLECTION_DISMISSIBLE_TOGGLE
data
:
{
value
:
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_COLLECTION_DISMISSIBLE
]
}
}
)
)
;
this
.
personalizationLastUpdated
=
null
;
this
.
loaded
=
false
;
}
async
onPrefChange
(
)
{
await
this
.
reset
(
)
;
if
(
this
.
config
.
enabled
)
{
await
this
.
enable
(
)
;
}
}
configReset
(
)
{
this
.
_prefCache
.
config
=
null
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_CONFIG_CHANGE
data
:
this
.
config
}
)
)
;
}
recordFlightImpression
(
flightId
)
{
let
impressions
=
this
.
readDataPref
(
PREF_SPOC_IMPRESSIONS
)
;
const
timeStamps
=
impressions
[
flightId
]
|
|
[
]
;
timeStamps
.
push
(
Date
.
now
(
)
)
;
impressions
=
{
.
.
.
impressions
[
flightId
]
:
timeStamps
}
;
this
.
writeDataPref
(
PREF_SPOC_IMPRESSIONS
impressions
)
;
}
recordTopRecImpressions
(
recId
)
{
let
impressions
=
this
.
readDataPref
(
PREF_REC_IMPRESSIONS
)
;
if
(
!
impressions
[
recId
]
)
{
impressions
=
{
.
.
.
impressions
[
recId
]
:
Date
.
now
(
)
}
;
this
.
writeDataPref
(
PREF_REC_IMPRESSIONS
impressions
)
;
}
}
recordBlockFlightId
(
flightId
)
{
const
flights
=
this
.
readDataPref
(
PREF_FLIGHT_BLOCKS
)
;
if
(
!
flights
[
flightId
]
)
{
flights
[
flightId
]
=
1
;
this
.
writeDataPref
(
PREF_FLIGHT_BLOCKS
flights
)
;
}
}
cleanUpFlightImpressionPref
(
data
)
{
let
flightIds
=
[
]
;
this
.
placementsForEach
(
placement
=
>
{
const
newSpocs
=
data
[
placement
.
name
]
;
if
(
!
newSpocs
)
{
return
;
}
const
items
=
newSpocs
.
items
|
|
[
]
;
flightIds
=
[
.
.
.
flightIds
.
.
.
items
.
map
(
s
=
>
{
s
.
flight_id
}
)
]
;
}
)
;
if
(
flightIds
&
&
flightIds
.
length
)
{
this
.
cleanUpImpressionPref
(
id
=
>
!
flightIds
.
includes
(
id
)
PREF_SPOC_IMPRESSIONS
)
;
}
}
cleanUpTopRecImpressionPref
(
newFeeds
)
{
const
activeStories
=
Object
.
keys
(
newFeeds
)
.
filter
(
currentValue
=
>
newFeeds
[
currentValue
]
.
data
)
.
reduce
(
(
accumulator
currentValue
)
=
>
{
const
{
recommendations
}
=
newFeeds
[
currentValue
]
.
data
;
return
accumulator
.
concat
(
recommendations
.
map
(
i
=
>
{
i
.
id
}
)
)
;
}
[
]
)
;
this
.
cleanUpImpressionPref
(
id
=
>
!
activeStories
.
includes
(
id
)
PREF_REC_IMPRESSIONS
)
;
}
writeDataPref
(
pref
impressions
)
{
this
.
store
.
dispatch
(
ac
.
SetPref
(
pref
JSON
.
stringify
(
impressions
)
)
)
;
}
readDataPref
(
pref
)
{
const
prefVal
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
pref
]
;
return
prefVal
?
JSON
.
parse
(
prefVal
)
:
{
}
;
}
cleanUpImpressionPref
(
isExpired
pref
)
{
const
impressions
=
this
.
readDataPref
(
pref
)
;
let
changed
=
false
;
Object
.
keys
(
impressions
)
.
forEach
(
id
=
>
{
if
(
isExpired
(
id
)
)
{
changed
=
true
;
delete
impressions
[
id
]
;
}
}
)
;
if
(
changed
)
{
this
.
writeDataPref
(
pref
impressions
)
;
}
}
onCollectionsChanged
(
)
{
const
dispatch
=
action
=
>
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
action
)
)
;
this
.
loadLayout
(
dispatch
false
)
;
}
async
onPrefChangedAction
(
action
)
{
switch
(
action
.
data
.
name
)
{
case
PREF_CONFIG
:
case
PREF_ENABLED
:
case
PREF_HARDCODED_BASIC_LAYOUT
:
case
PREF_SPOCS_ENDPOINT
:
case
PREF_SPOCS_ENDPOINT_QUERY
:
case
PREF_PERSONALIZATION
:
this
.
configReset
(
)
;
break
;
case
PREF_COLLECTIONS_ENABLED
:
this
.
onCollectionsChanged
(
)
;
break
;
case
PREF_USER_TOPSITES
:
case
PREF_SYSTEM_TOPSITES
:
if
(
!
(
this
.
showTopsites
|
|
(
this
.
showStories
&
&
this
.
showSponsoredStories
)
)
)
{
this
.
clearSpocs
(
)
;
}
break
;
case
PREF_USER_TOPSTORIES
:
case
PREF_SYSTEM_TOPSTORIES
:
if
(
!
(
this
.
showStories
|
|
(
this
.
showTopsites
&
&
this
.
showSponsoredTopsites
)
)
)
{
this
.
clearSpocs
(
)
;
}
if
(
action
.
data
.
value
)
{
this
.
enableStories
(
)
;
}
break
;
case
PREF_SHOW_SPONSORED
:
case
PREF_SHOW_SPONSORED_TOPSITES
:
const
dispatch
=
update
=
>
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
update
)
)
;
this
.
updatePlacements
(
dispatch
this
.
store
.
getState
(
)
.
DiscoveryStream
.
layout
)
;
if
(
!
(
(
this
.
showSponsoredStories
|
|
(
this
.
showTopSites
&
&
this
.
showSponsoredTopSites
)
)
&
&
(
this
.
showSponsoredTopsites
|
|
(
this
.
showStories
&
&
this
.
showSponsoredStories
)
)
)
)
{
this
.
clearSpocs
(
)
;
}
await
this
.
cache
.
set
(
"
spocs
"
{
}
)
;
await
this
.
loadSpocs
(
dispatch
)
;
break
;
}
}
async
onAction
(
action
)
{
switch
(
action
.
type
)
{
case
at
.
INIT
:
this
.
setupConfig
(
true
)
;
this
.
setupPrefs
(
true
)
;
if
(
this
.
config
.
enabled
)
{
await
this
.
enable
(
)
;
}
Services
.
prefs
.
addObserver
(
PREF_POCKET_BUTTON
this
)
;
break
;
case
at
.
DISCOVERY_STREAM_DEV_SYSTEM_TICK
:
case
at
.
SYSTEM_TICK
:
if
(
this
.
config
.
enabled
&
&
this
.
loaded
&
&
(
await
this
.
checkIfAnyCacheExpired
(
)
)
)
{
await
this
.
refreshAll
(
{
updateOpenTabs
:
false
}
)
;
}
break
;
case
at
.
DISCOVERY_STREAM_DEV_IDLE_DAILY
:
Services
.
obs
.
notifyObservers
(
null
"
idle
-
daily
"
)
;
break
;
case
at
.
DISCOVERY_STREAM_DEV_SYNC_RS
:
lazy
.
RemoteSettings
.
pollChanges
(
)
;
break
;
case
at
.
DISCOVERY_STREAM_DEV_EXPIRE_CACHE
:
await
this
.
resetContentCache
(
)
;
break
;
case
at
.
DISCOVERY_STREAM_CONFIG_SET_VALUE
:
this
.
store
.
dispatch
(
ac
.
SetPref
(
PREF_CONFIG
JSON
.
stringify
(
{
.
.
.
JSON
.
parse
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
PREF_CONFIG
]
)
[
action
.
data
.
name
]
:
action
.
data
.
value
}
)
)
)
;
break
;
case
at
.
DISCOVERY_STREAM_POCKET_STATE_INIT
:
this
.
setupPocketState
(
action
.
meta
.
fromTarget
)
;
break
;
case
at
.
DISCOVERY_STREAM_CONFIG_RESET
:
this
.
configReset
(
)
;
break
;
case
at
.
DISCOVERY_STREAM_CONFIG_RESET_DEFAULTS
:
this
.
resetConfigDefauts
(
)
;
break
;
case
at
.
DISCOVERY_STREAM_RETRY_FEED
:
this
.
retryFeed
(
action
.
data
.
feed
)
;
break
;
case
at
.
DISCOVERY_STREAM_CONFIG_CHANGE
:
await
this
.
onPrefChange
(
)
;
break
;
case
at
.
DISCOVERY_STREAM_IMPRESSION_STATS
:
if
(
action
.
data
.
tiles
&
&
action
.
data
.
tiles
[
0
]
&
&
action
.
data
.
tiles
[
0
]
.
id
)
{
this
.
recordTopRecImpressions
(
action
.
data
.
tiles
[
0
]
.
id
)
;
}
break
;
case
at
.
DISCOVERY_STREAM_SPOC_IMPRESSION
:
if
(
this
.
showSpocs
)
{
this
.
recordFlightImpression
(
action
.
data
.
flightId
)
;
const
spocsState
=
this
.
store
.
getState
(
)
.
DiscoveryStream
.
spocs
;
let
frequencyCapped
=
[
]
;
this
.
placementsForEach
(
placement
=
>
{
const
spocs
=
spocsState
.
data
[
placement
.
name
]
;
if
(
!
spocs
|
|
!
spocs
.
items
)
{
return
;
}
const
{
data
:
capResult
filtered
}
=
this
.
frequencyCapSpocs
(
spocs
.
items
)
;
frequencyCapped
=
[
.
.
.
frequencyCapped
.
.
.
filtered
]
;
spocsState
.
data
=
{
.
.
.
spocsState
.
data
[
placement
.
name
]
:
{
.
.
.
spocs
items
:
capResult
}
}
;
}
)
;
if
(
frequencyCapped
.
length
)
{
await
this
.
cache
.
set
(
"
spocs
"
{
lastUpdated
:
spocsState
.
lastUpdated
spocs
:
spocsState
.
data
}
)
;
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
{
type
:
at
.
DISCOVERY_STREAM_SPOCS_UPDATE
data
:
{
lastUpdated
:
spocsState
.
lastUpdated
spocs
:
spocsState
.
data
}
}
)
)
;
}
}
break
;
case
at
.
PLACES_LINK_BLOCKED
:
if
(
this
.
showSpocs
)
{
let
blockedItems
=
[
]
;
const
spocsState
=
this
.
store
.
getState
(
)
.
DiscoveryStream
.
spocs
;
this
.
placementsForEach
(
placement
=
>
{
const
spocs
=
spocsState
.
data
[
placement
.
name
]
;
if
(
spocs
&
&
spocs
.
items
&
&
spocs
.
items
.
length
)
{
const
blockedResults
=
[
]
;
const
blocks
=
spocs
.
items
.
filter
(
s
=
>
{
const
blocked
=
s
.
url
=
=
=
action
.
data
.
url
;
if
(
!
blocked
)
{
blockedResults
.
push
(
s
)
;
}
return
blocked
;
}
)
;
blockedItems
=
[
.
.
.
blockedItems
.
.
.
blocks
]
;
spocsState
.
data
=
{
.
.
.
spocsState
.
data
[
placement
.
name
]
:
{
.
.
.
spocs
items
:
blockedResults
}
}
;
}
}
)
;
if
(
blockedItems
.
length
)
{
await
this
.
cache
.
set
(
"
spocs
"
{
lastUpdated
:
spocsState
.
lastUpdated
spocs
:
spocsState
.
data
}
)
;
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
{
type
:
at
.
DISCOVERY_STREAM_LINK_BLOCKED
data
:
action
.
data
}
)
)
;
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_SPOC_BLOCKED
data
:
action
.
data
}
)
)
;
break
;
}
}
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
DISCOVERY_STREAM_LINK_BLOCKED
data
:
action
.
data
}
)
)
;
break
;
case
at
.
UNINIT
:
this
.
uninitPrefs
(
)
;
this
.
_recommendationProvider
=
null
;
Services
.
prefs
.
removeObserver
(
PREF_POCKET_BUTTON
this
)
;
break
;
case
at
.
BLOCK_URL
:
{
action
.
data
.
forEach
(
site
=
>
{
const
{
flight_id
}
=
site
;
if
(
flight_id
)
{
this
.
recordBlockFlightId
(
flight_id
)
;
}
}
)
;
break
;
}
case
at
.
PREF_CHANGED
:
await
this
.
onPrefChangedAction
(
action
)
;
if
(
action
.
data
.
name
=
=
=
"
pocketConfig
"
)
{
await
this
.
onPrefChange
(
)
;
this
.
setupPrefs
(
false
)
;
}
break
;
}
}
}
getHardcodedLayout
=
(
{
spocsUrl
=
SPOCS_URL
items
=
21
spocPositions
=
[
1
5
7
11
18
20
]
spocPlacementData
=
{
ad_types
:
[
3617
]
zone_ids
:
[
217758
217995
]
}
spocTopsitesPlacementData
widgetPositions
=
[
]
widgetData
=
[
]
sponsoredCollectionsEnabled
=
false
hybridLayout
=
false
hideCardBackground
=
false
fourCardLayout
=
false
newFooterSection
=
false
compactGrid
=
false
essentialReadsHeader
=
false
editorsPicksHeader
=
false
}
)
=
>
(
{
lastUpdate
:
Date
.
now
(
)
spocs
:
{
url
:
spocsUrl
}
layout
:
[
{
width
:
12
components
:
[
{
type
:
"
TopSites
"
header
:
{
title
:
{
id
:
"
newtab
-
section
-
header
-
topsites
"
}
}
.
.
.
(
spocTopsitesPlacementData
?
{
placement
:
{
name
:
"
sponsored
-
topsites
"
ad_types
:
spocTopsitesPlacementData
.
ad_types
zone_ids
:
spocTopsitesPlacementData
.
zone_ids
}
spocs
:
{
probability
:
1
prefs
:
[
PREF_SHOW_SPONSORED_TOPSITES
]
positions
:
[
{
index
:
1
}
]
}
}
:
{
}
)
properties
:
{
}
}
.
.
.
(
sponsoredCollectionsEnabled
?
[
{
type
:
"
CollectionCardGrid
"
properties
:
{
items
:
3
}
header
:
{
title
:
"
"
}
placement
:
{
name
:
"
sponsored
-
collection
"
ad_types
:
[
3617
]
zone_ids
:
[
217759
218031
]
}
spocs
:
{
probability
:
1
positions
:
[
{
index
:
0
}
{
index
:
1
}
{
index
:
2
}
]
}
}
]
:
[
]
)
{
type
:
"
Message
"
essentialReadsHeader
editorsPicksHeader
header
:
{
title
:
{
id
:
"
newtab
-
section
-
header
-
pocket
"
values
:
{
provider
:
"
Pocket
"
}
}
subtitle
:
"
"
link_text
:
{
id
:
"
newtab
-
pocket
-
learn
-
more
"
}
link_url
:
"
https
:
/
/
getpocket
.
com
/
firefox
/
new_tab_learn_more
"
icon
:
"
chrome
:
/
/
global
/
skin
/
icons
/
pocket
.
svg
"
}
properties
:
{
}
styles
:
{
"
.
ds
-
message
"
:
"
margin
-
bottom
:
-
20px
"
}
}
{
type
:
"
CardGrid
"
properties
:
{
items
hybridLayout
hideCardBackground
fourCardLayout
compactGrid
essentialReadsHeader
editorsPicksHeader
}
widgets
:
{
positions
:
widgetPositions
.
map
(
position
=
>
{
return
{
index
:
position
}
;
}
)
data
:
widgetData
}
cta_variant
:
"
link
"
header
:
{
title
:
"
"
}
placement
:
{
name
:
"
spocs
"
ad_types
:
spocPlacementData
.
ad_types
zone_ids
:
spocPlacementData
.
zone_ids
}
feed
:
{
embed_reference
:
null
url
:
"
https
:
/
/
getpocket
.
cdn
.
mozilla
.
net
/
v3
/
firefox
/
global
-
recs
?
version
=
3
&
consumer_key
=
apiKey
&
locale_lang
=
locale
&
region
=
region
&
count
=
30
"
}
spocs
:
{
probability
:
1
positions
:
spocPositions
.
map
(
position
=
>
{
return
{
index
:
position
}
;
}
)
}
}
{
type
:
"
Navigation
"
newFooterSection
properties
:
{
alignment
:
"
left
-
align
"
links
:
[
{
name
:
"
Self
improvement
"
url
:
"
https
:
/
/
getpocket
.
com
/
explore
/
self
-
improvement
?
utm_source
=
pocket
-
newtab
"
}
{
name
:
"
Food
"
url
:
"
https
:
/
/
getpocket
.
com
/
explore
/
food
?
utm_source
=
pocket
-
newtab
"
}
{
name
:
"
Entertainment
"
url
:
"
https
:
/
/
getpocket
.
com
/
explore
/
entertainment
?
utm_source
=
pocket
-
newtab
"
}
{
name
:
"
Health
&
fitness
"
url
:
"
https
:
/
/
getpocket
.
com
/
explore
/
health
?
utm_source
=
pocket
-
newtab
"
}
{
name
:
"
Science
"
url
:
"
https
:
/
/
getpocket
.
com
/
explore
/
science
?
utm_source
=
pocket
-
newtab
"
}
{
name
:
"
More
recommendations
"
url
:
"
https
:
/
/
getpocket
.
com
/
explore
?
utm_source
=
pocket
-
newtab
"
}
]
extraLinks
:
[
{
name
:
"
Career
"
url
:
"
https
:
/
/
getpocket
.
com
/
explore
/
career
?
utm_source
=
pocket
-
newtab
"
}
{
name
:
"
Technology
"
url
:
"
https
:
/
/
getpocket
.
com
/
explore
/
technology
?
utm_source
=
pocket
-
newtab
"
}
]
privacyNoticeURL
:
{
url
:
"
https
:
/
/
www
.
mozilla
.
org
/
privacy
/
firefox
/
#
suggest
-
relevant
-
content
"
title
:
{
id
:
"
newtab
-
section
-
menu
-
privacy
-
notice
"
}
}
}
header
:
{
title
:
{
id
:
"
newtab
-
pocket
-
read
-
more
"
}
}
styles
:
{
"
.
ds
-
navigation
"
:
"
margin
-
top
:
-
10px
;
"
}
}
.
.
.
(
newFooterSection
?
[
{
type
:
"
PrivacyLink
"
properties
:
{
url
:
"
https
:
/
/
www
.
mozilla
.
org
/
privacy
/
firefox
/
"
title
:
{
id
:
"
newtab
-
section
-
menu
-
privacy
-
notice
"
}
}
}
]
:
[
]
)
]
}
]
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
DiscoveryStreamFeed
"
]
;
