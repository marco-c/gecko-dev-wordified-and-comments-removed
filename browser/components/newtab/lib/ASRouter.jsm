"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
SnippetsTestMessageProvider
:
"
resource
:
/
/
activity
-
stream
/
lib
/
SnippetsTestMessageProvider
.
jsm
"
PanelTestProvider
:
"
resource
:
/
/
activity
-
stream
/
lib
/
PanelTestProvider
.
jsm
"
Spotlight
:
"
resource
:
/
/
activity
-
stream
/
lib
/
Spotlight
.
jsm
"
ToastNotification
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ToastNotification
.
jsm
"
ToolbarBadgeHub
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ToolbarBadgeHub
.
jsm
"
ToolbarPanelHub
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ToolbarPanelHub
.
jsm
"
MomentsPageHub
:
"
resource
:
/
/
activity
-
stream
/
lib
/
MomentsPageHub
.
jsm
"
InfoBar
:
"
resource
:
/
/
activity
-
stream
/
lib
/
InfoBar
.
jsm
"
ASRouterTargeting
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterTargeting
.
jsm
"
ASRouterPreferences
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterPreferences
.
jsm
"
TARGETING_PREFERENCES
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterPreferences
.
jsm
"
ASRouterTriggerListeners
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterTriggerListeners
.
jsm
"
KintoHttpClient
:
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
Downloader
:
"
resource
:
/
/
services
-
settings
/
Attachments
.
jsm
"
RemoteImages
:
"
resource
:
/
/
activity
-
stream
/
lib
/
RemoteImages
.
jsm
"
RemoteL10n
:
"
resource
:
/
/
activity
-
stream
/
lib
/
RemoteL10n
.
jsm
"
ExperimentAPI
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
SpecialMessageActions
:
"
resource
:
/
/
messaging
-
system
/
lib
/
SpecialMessageActions
.
jsm
"
TargetingContext
:
"
resource
:
/
/
messaging
-
system
/
targeting
/
Targeting
.
jsm
"
Utils
:
"
resource
:
/
/
services
-
settings
/
Utils
.
jsm
"
MacAttribution
:
"
resource
:
/
/
/
modules
/
MacAttribution
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
BrowserHandler
:
[
"
mozilla
.
org
/
browser
/
clh
;
1
"
"
nsIBrowserHandler
"
]
}
)
;
const
{
actionCreators
:
ac
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
jsm
"
)
;
const
{
CFRMessageProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
CFRMessageProvider
.
jsm
"
)
;
const
{
OnboardingMessageProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
OnboardingMessageProvider
.
jsm
"
)
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
const
{
CFRPageActions
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
CFRPageActions
.
jsm
"
)
;
const
{
AttributionCode
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
AttributionCode
.
jsm
"
)
;
const
DEFAULT_ALLOWLIST_HOSTS
=
{
"
activity
-
stream
-
icons
.
services
.
mozilla
.
com
"
:
"
production
"
"
snippets
-
admin
.
mozilla
.
org
"
:
"
preview
"
}
;
const
SNIPPETS_ENDPOINT_ALLOWLIST
=
"
browser
.
newtab
.
activity
-
stream
.
asrouter
.
allowHosts
"
;
const
MAX_MESSAGE_LIFETIME_CAP
=
100
;
const
LOCAL_MESSAGE_PROVIDERS
=
{
OnboardingMessageProvider
CFRMessageProvider
}
;
const
STARTPAGE_VERSION
=
"
6
"
;
const
RS_MAIN_BUCKET
=
"
main
"
;
const
RS_COLLECTION_L10N
=
"
ms
-
language
-
packs
"
;
const
RS_PROVIDERS_WITH_L10N
=
[
"
cfr
"
]
;
const
RS_FLUENT_VERSION
=
"
v1
"
;
const
RS_FLUENT_RECORD_PREFIX
=
cfr
-
{
RS_FLUENT_VERSION
}
;
const
RS_DOWNLOAD_MAX_RETRIES
=
2
;
const
JEXL_PROVIDER_CACHE
=
new
Set
(
[
"
snippets
"
]
)
;
const
TOPIC_INTL_LOCALE_CHANGED
=
"
intl
:
app
-
locales
-
changed
"
;
const
TOPIC_EXPERIMENT_FORCE_ENROLLED
=
"
nimbus
:
force
-
enroll
"
;
const
USE_REMOTE_L10N_PREF
=
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
useRemoteL10n
"
;
const
MESSAGING_EXPERIMENTS_DEFAULT_FEATURES
=
[
"
cfr
"
"
infobar
"
"
moments
-
page
"
"
pbNewtab
"
"
spotlight
"
]
;
const
REACH_EVENT_GROUPS
=
[
"
cfr
"
"
moments
-
page
"
"
infobar
"
"
spotlight
"
]
;
const
REACH_EVENT_CATEGORY
=
"
messaging_experiments
"
;
const
REACH_EVENT_METHOD
=
"
reach
"
;
const
MessageLoaderUtils
=
{
STARTPAGE_VERSION
REMOTE_LOADER_CACHE_KEY
:
"
RemoteLoaderCache
"
_errors
:
[
]
reportError
(
e
)
{
Cu
.
reportError
(
e
)
;
this
.
_errors
.
push
(
{
timestamp
:
new
Date
(
)
error
:
{
message
:
e
.
toString
(
)
stack
:
e
.
stack
}
}
)
;
}
get
errors
(
)
{
const
errors
=
this
.
_errors
;
this
.
_errors
=
[
]
;
return
errors
;
}
_localLoader
(
provider
)
{
return
provider
.
messages
;
}
async
_remoteLoaderCache
(
storage
)
{
let
allCached
;
try
{
allCached
=
(
await
storage
.
get
(
MessageLoaderUtils
.
REMOTE_LOADER_CACHE_KEY
)
)
|
|
{
}
;
}
catch
(
e
)
{
MessageLoaderUtils
.
reportError
(
e
)
;
allCached
=
{
}
;
}
return
allCached
;
}
async
_remoteLoader
(
provider
options
)
{
let
remoteMessages
=
[
]
;
if
(
provider
.
url
)
{
const
allCached
=
await
MessageLoaderUtils
.
_remoteLoaderCache
(
options
.
storage
)
;
const
cached
=
allCached
[
provider
.
id
]
;
let
etag
;
if
(
cached
&
&
cached
.
url
=
=
=
provider
.
url
&
&
cached
.
version
=
=
=
STARTPAGE_VERSION
)
{
const
{
lastFetched
messages
}
=
cached
;
if
(
!
MessageLoaderUtils
.
shouldProviderUpdate
(
{
.
.
.
provider
lastUpdated
:
lastFetched
}
)
)
{
return
messages
;
}
etag
=
cached
.
etag
;
remoteMessages
=
messages
;
}
let
headers
=
new
Headers
(
)
;
if
(
etag
)
{
headers
.
set
(
"
If
-
None
-
Match
"
etag
)
;
}
let
response
;
try
{
response
=
await
fetch
(
provider
.
url
{
headers
credentials
:
"
omit
"
}
)
;
}
catch
(
e
)
{
MessageLoaderUtils
.
reportError
(
e
)
;
}
if
(
response
&
&
response
.
ok
&
&
response
.
status
>
=
200
&
&
response
.
status
<
400
)
{
let
jsonResponse
;
try
{
jsonResponse
=
await
response
.
json
(
)
;
}
catch
(
e
)
{
MessageLoaderUtils
.
reportError
(
e
)
;
return
remoteMessages
;
}
if
(
jsonResponse
&
&
jsonResponse
.
messages
)
{
remoteMessages
=
jsonResponse
.
messages
.
map
(
msg
=
>
(
{
.
.
.
msg
provider_url
:
provider
.
url
}
)
)
;
if
(
provider
.
updateCycleInMs
>
0
)
{
etag
=
response
.
headers
.
get
(
"
ETag
"
)
;
const
cacheInfo
=
{
messages
:
remoteMessages
etag
lastFetched
:
Date
.
now
(
)
version
:
STARTPAGE_VERSION
}
;
options
.
storage
.
set
(
MessageLoaderUtils
.
REMOTE_LOADER_CACHE_KEY
{
.
.
.
allCached
[
provider
.
id
]
:
cacheInfo
}
)
;
}
}
else
{
MessageLoaderUtils
.
reportError
(
No
messages
returned
from
{
provider
.
url
}
.
)
;
}
}
else
if
(
response
)
{
MessageLoaderUtils
.
reportError
(
Invalid
response
status
{
response
.
status
}
from
{
provider
.
url
}
.
)
;
}
}
return
remoteMessages
;
}
async
_remoteSettingsLoader
(
provider
options
)
{
let
messages
=
[
]
;
if
(
provider
.
bucket
)
{
try
{
messages
=
await
MessageLoaderUtils
.
_getRemoteSettingsMessages
(
provider
.
bucket
)
;
if
(
!
messages
.
length
)
{
MessageLoaderUtils
.
_handleRemoteSettingsUndesiredEvent
(
"
ASR_RS_NO_MESSAGES
"
provider
.
id
options
.
dispatchCFRAction
)
;
}
else
if
(
RS_PROVIDERS_WITH_L10N
.
includes
(
provider
.
id
)
&
&
lazy
.
RemoteL10n
.
isLocaleSupported
(
MessageLoaderUtils
.
locale
)
)
{
const
recordId
=
{
RS_FLUENT_RECORD_PREFIX
}
-
{
MessageLoaderUtils
.
locale
}
;
const
kinto
=
new
lazy
.
KintoHttpClient
(
lazy
.
Utils
.
SERVER_URL
)
;
const
record
=
await
kinto
.
bucket
(
RS_MAIN_BUCKET
)
.
collection
(
RS_COLLECTION_L10N
)
.
getRecord
(
recordId
)
;
if
(
record
&
&
record
.
data
)
{
const
downloader
=
new
lazy
.
Downloader
(
RS_MAIN_BUCKET
RS_COLLECTION_L10N
"
browser
"
"
newtab
"
)
;
await
downloader
.
downloadToDisk
(
record
.
data
{
retries
:
RS_DOWNLOAD_MAX_RETRIES
}
)
;
lazy
.
RemoteL10n
.
reloadL10n
(
)
;
}
else
{
MessageLoaderUtils
.
_handleRemoteSettingsUndesiredEvent
(
"
ASR_RS_NO_MESSAGES
"
RS_COLLECTION_L10N
options
.
dispatchCFRAction
)
;
}
}
}
catch
(
e
)
{
MessageLoaderUtils
.
_handleRemoteSettingsUndesiredEvent
(
"
ASR_RS_ERROR
"
provider
.
id
options
.
dispatchCFRAction
)
;
MessageLoaderUtils
.
reportError
(
e
)
;
}
}
return
messages
;
}
_getRemoteSettingsMessages
(
bucket
)
{
return
RemoteSettings
(
bucket
)
.
get
(
)
;
}
async
_experimentsAPILoader
(
provider
)
{
const
featureIds
=
Array
.
isArray
(
provider
.
featureIds
)
?
provider
.
featureIds
:
MESSAGING_EXPERIMENTS_DEFAULT_FEATURES
;
let
experiments
=
[
]
;
for
(
const
featureId
of
featureIds
)
{
let
featureAPI
=
lazy
.
NimbusFeatures
[
featureId
]
;
let
experimentData
=
lazy
.
ExperimentAPI
.
getExperimentMetaData
(
{
featureId
}
)
;
if
(
!
experimentData
)
{
continue
;
}
let
message
=
featureAPI
.
getAllVariables
(
)
;
if
(
message
?
.
id
)
{
message
.
_nimbusFeature
=
featureId
;
experiments
.
push
(
message
)
;
}
if
(
!
REACH_EVENT_GROUPS
.
includes
(
featureId
)
)
{
continue
;
}
const
branches
=
(
await
lazy
.
ExperimentAPI
.
getAllBranches
(
experimentData
.
slug
)
)
|
|
[
]
;
for
(
const
branch
of
branches
)
{
let
branchValue
=
branch
[
featureId
]
.
value
;
if
(
branch
.
slug
!
=
=
experimentData
.
branch
.
slug
&
&
branchValue
?
.
trigger
)
{
experiments
.
push
(
{
forReachEvent
:
{
sent
:
false
group
:
featureId
}
experimentSlug
:
experimentData
.
slug
branchSlug
:
branch
.
slug
.
.
.
branchValue
}
)
;
}
}
}
return
experiments
;
}
_handleRemoteSettingsUndesiredEvent
(
event
providerId
dispatchCFRAction
)
{
if
(
dispatchCFRAction
)
{
dispatchCFRAction
(
ac
.
ASRouterUserEvent
(
{
action
:
"
asrouter_undesired_event
"
event
message_id
:
"
n
/
a
"
event_context
:
providerId
}
)
)
;
}
}
_getMessageLoader
(
provider
)
{
switch
(
provider
.
type
)
{
case
"
remote
"
:
return
this
.
_remoteLoader
;
case
"
remote
-
settings
"
:
return
this
.
_remoteSettingsLoader
;
case
"
remote
-
experiments
"
:
return
this
.
_experimentsAPILoader
;
case
"
local
"
:
default
:
return
this
.
_localLoader
;
}
}
shouldProviderUpdate
(
provider
currentTime
=
Date
.
now
(
)
)
{
return
(
!
(
provider
.
lastUpdated
>
=
0
)
|
|
currentTime
-
provider
.
lastUpdated
>
provider
.
updateCycleInMs
)
;
}
async
_loadDataForProvider
(
provider
options
)
{
const
loader
=
this
.
_getMessageLoader
(
provider
)
;
let
messages
=
await
loader
(
provider
options
)
;
if
(
!
messages
)
{
messages
=
[
]
;
MessageLoaderUtils
.
reportError
(
new
Error
(
Tried
to
load
messages
for
{
provider
.
id
}
but
the
result
was
not
an
Array
.
)
)
;
}
return
{
messages
}
;
}
async
loadMessagesForProvider
(
provider
options
)
{
let
{
messages
}
=
await
this
.
_loadDataForProvider
(
provider
options
)
;
if
(
provider
.
exclude
&
&
provider
.
exclude
.
length
)
{
messages
=
messages
.
filter
(
message
=
>
!
provider
.
exclude
.
includes
(
message
.
id
)
)
;
}
const
lastUpdated
=
Date
.
now
(
)
;
return
{
messages
:
messages
.
map
(
messageData
=
>
{
const
message
=
{
weight
:
100
.
.
.
messageData
groups
:
messageData
.
groups
|
|
[
]
provider
:
provider
.
id
}
;
return
message
;
}
)
.
filter
(
message
=
>
message
.
weight
>
0
)
lastUpdated
errors
:
MessageLoaderUtils
.
errors
}
;
}
async
cleanupCache
(
providers
storage
)
{
const
ids
=
providers
.
filter
(
p
=
>
p
.
type
=
=
=
"
remote
"
)
.
map
(
p
=
>
p
.
id
)
;
const
cache
=
await
MessageLoaderUtils
.
_remoteLoaderCache
(
storage
)
;
let
dirty
=
false
;
for
(
let
id
in
cache
)
{
if
(
!
ids
.
includes
(
id
)
)
{
delete
cache
[
id
]
;
dirty
=
true
;
}
}
if
(
dirty
)
{
await
storage
.
set
(
MessageLoaderUtils
.
REMOTE_LOADER_CACHE_KEY
cache
)
;
}
}
get
locale
(
)
{
const
localeMap
=
{
"
ja
-
JP
-
macos
"
:
"
ja
-
JP
-
mac
"
und
:
"
en
-
US
"
}
;
const
locale
=
Services
.
locale
.
appLocaleAsBCP47
;
return
localeMap
[
locale
]
?
?
locale
;
}
}
;
class
_ASRouter
{
constructor
(
localProviders
=
LOCAL_MESSAGE_PROVIDERS
)
{
this
.
initialized
=
false
;
this
.
clearChildMessages
=
null
;
this
.
clearChildProviders
=
null
;
this
.
updateAdminState
=
null
;
this
.
sendTelemetry
=
null
;
this
.
dispatchCFRAction
=
null
;
this
.
_storage
=
null
;
this
.
_resetInitialization
(
)
;
this
.
_state
=
{
providers
:
[
]
messageBlockList
:
[
]
messageImpressions
:
{
}
messages
:
[
]
groups
:
[
]
errors
:
[
]
localeInUse
:
Services
.
locale
.
appLocaleAsBCP47
}
;
this
.
_experimentChangedListeners
=
new
Map
(
)
;
this
.
_triggerHandler
=
this
.
_triggerHandler
.
bind
(
this
)
;
this
.
_localProviders
=
localProviders
;
this
.
blockMessageById
=
this
.
blockMessageById
.
bind
(
this
)
;
this
.
unblockMessageById
=
this
.
unblockMessageById
.
bind
(
this
)
;
this
.
handleMessageRequest
=
this
.
handleMessageRequest
.
bind
(
this
)
;
this
.
addImpression
=
this
.
addImpression
.
bind
(
this
)
;
this
.
_handleTargetingError
=
this
.
_handleTargetingError
.
bind
(
this
)
;
this
.
onPrefChange
=
this
.
onPrefChange
.
bind
(
this
)
;
this
.
_onLocaleChanged
=
this
.
_onLocaleChanged
.
bind
(
this
)
;
this
.
isUnblockedMessage
=
this
.
isUnblockedMessage
.
bind
(
this
)
;
this
.
unblockAll
=
this
.
unblockAll
.
bind
(
this
)
;
this
.
forceWNPanel
=
this
.
forceWNPanel
.
bind
(
this
)
;
this
.
_onExperimentForceEnrolled
=
this
.
_onExperimentForceEnrolled
.
bind
(
this
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
REACH_EVENT_CATEGORY
true
)
;
}
async
onPrefChange
(
prefName
)
{
if
(
lazy
.
TARGETING_PREFERENCES
.
includes
(
prefName
)
)
{
let
invalidMessages
=
[
]
;
const
context
=
this
.
_getMessagesContext
(
)
;
const
targetingContext
=
new
lazy
.
TargetingContext
(
context
)
;
for
(
const
msg
of
this
.
state
.
messages
.
filter
(
this
.
isUnblockedMessage
)
)
{
if
(
!
msg
.
targeting
)
{
continue
;
}
const
isMatch
=
await
targetingContext
.
evalWithDefault
(
msg
.
targeting
)
;
if
(
!
isMatch
)
{
invalidMessages
.
push
(
msg
.
id
)
;
}
}
this
.
clearChildMessages
(
invalidMessages
)
;
}
else
{
this
.
_loadLocalProviders
(
)
;
let
invalidProviders
=
await
this
.
_updateMessageProviders
(
)
;
if
(
invalidProviders
.
length
)
{
this
.
clearChildProviders
(
invalidProviders
)
;
}
await
this
.
loadMessagesFromAllProviders
(
)
;
await
this
.
setState
(
state
=
>
(
{
groups
:
state
.
groups
.
map
(
this
.
_checkGroupEnabled
)
}
)
)
;
}
}
async
_updateMessageProviders
(
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
"
entering
updateMessageProviders
"
)
;
const
previousProviders
=
this
.
state
.
providers
;
const
providers
=
await
Promise
.
all
(
[
.
.
.
previousProviders
.
filter
(
p
=
>
p
.
id
=
=
=
"
preview
"
)
.
.
.
lazy
.
ASRouterPreferences
.
providers
.
filter
(
p
=
>
p
.
enabled
&
&
lazy
.
ASRouterPreferences
.
getUserPreference
(
p
.
id
)
!
=
=
false
)
]
.
map
(
async
_provider
=
>
{
const
provider
=
{
.
.
.
_provider
}
;
if
(
provider
.
type
=
=
=
"
local
"
&
&
!
provider
.
messages
)
{
const
localProvider
=
this
.
_localProviders
[
provider
.
localProvider
]
;
provider
.
messages
=
[
]
;
if
(
localProvider
)
{
provider
.
messages
=
await
localProvider
.
getMessages
(
)
;
}
}
if
(
provider
.
type
=
=
=
"
remote
"
&
&
provider
.
url
)
{
provider
.
url
=
provider
.
url
.
replace
(
/
%
STARTPAGE_VERSION
%
/
g
STARTPAGE_VERSION
)
;
provider
.
url
=
Services
.
urlFormatter
.
formatURL
(
provider
.
url
)
;
}
if
(
provider
.
id
=
=
=
"
messaging
-
experiments
"
)
{
if
(
!
provider
.
featureIds
)
{
provider
.
featureIds
=
MESSAGING_EXPERIMENTS_DEFAULT_FEATURES
;
}
}
provider
.
lastUpdated
=
undefined
;
return
provider
;
}
)
)
;
const
providerIDs
=
providers
.
map
(
p
=
>
p
.
id
)
;
let
invalidProviders
=
[
]
;
for
(
const
prevProvider
of
previousProviders
)
{
if
(
!
providerIDs
.
includes
(
prevProvider
.
id
)
)
{
invalidProviders
.
push
(
prevProvider
.
id
)
;
}
}
{
const
prevExpts
=
previousProviders
.
find
(
p
=
>
p
.
id
=
=
=
"
messaging
-
experiments
"
)
;
const
expts
=
providers
.
find
(
p
=
>
p
.
id
=
=
=
"
messaging
-
experiments
"
)
;
this
.
_onFeatureListChanged
(
prevExpts
?
.
enabled
?
prevExpts
.
featureIds
:
[
]
expts
?
.
enabled
?
expts
.
featureIds
:
[
]
)
;
}
return
this
.
setState
(
prevState
=
>
(
{
providers
messages
:
[
.
.
.
prevState
.
messages
.
filter
(
message
=
>
providerIDs
.
includes
(
message
.
provider
)
)
]
}
)
)
.
then
(
(
)
=
>
invalidProviders
)
;
}
get
state
(
)
{
return
this
.
_state
;
}
set
state
(
value
)
{
throw
new
Error
(
"
Do
not
modify
this
.
state
directy
.
Instead
call
this
.
setState
(
newState
)
"
)
;
}
_resetInitialization
(
)
{
this
.
initialized
=
false
;
this
.
initializing
=
false
;
this
.
waitForInitialized
=
new
Promise
(
resolve
=
>
{
this
.
_finishInitializing
=
(
)
=
>
{
this
.
initialized
=
true
;
this
.
initializing
=
false
;
resolve
(
)
;
}
;
}
)
;
}
hasGroupsEnabled
(
groups
=
[
]
)
{
return
this
.
state
.
groups
.
filter
(
(
{
id
}
)
=
>
groups
.
includes
(
id
)
)
.
every
(
(
{
enabled
}
)
=
>
enabled
)
;
}
isExcludedByProvider
(
message
)
{
if
(
message
.
provider
=
=
=
"
preview
"
)
{
return
false
;
}
const
provider
=
this
.
state
.
providers
.
find
(
p
=
>
p
.
id
=
=
=
message
.
provider
)
;
if
(
!
provider
)
{
return
true
;
}
if
(
provider
.
exclude
)
{
return
provider
.
exclude
.
includes
(
message
.
id
)
;
}
return
false
;
}
_checkGroupEnabled
(
group
)
{
return
{
.
.
.
group
enabled
:
group
.
enabled
&
&
(
Array
.
isArray
(
group
.
userPreferences
)
?
group
.
userPreferences
.
some
(
pref
=
>
lazy
.
ASRouterPreferences
.
getUserPreference
(
pref
)
)
:
true
)
}
;
}
async
loadAllMessageGroups
(
)
{
const
provider
=
this
.
state
.
providers
.
find
(
p
=
>
p
.
id
=
=
=
"
message
-
groups
"
&
&
MessageLoaderUtils
.
shouldProviderUpdate
(
p
)
)
;
let
remoteMessages
=
null
;
if
(
provider
)
{
const
{
messages
}
=
await
MessageLoaderUtils
.
_loadDataForProvider
(
provider
{
storage
:
this
.
_storage
dispatchCFRAction
:
this
.
dispatchCFRAction
}
)
;
remoteMessages
=
messages
;
}
await
this
.
setState
(
state
=
>
(
{
groups
:
(
remoteMessages
|
|
state
.
groups
)
.
map
(
this
.
_checkGroupEnabled
)
}
)
)
;
}
async
loadMessagesFromAllProviders
(
toUpdate
=
undefined
)
{
const
needsUpdate
=
Array
.
isArray
(
toUpdate
)
?
toUpdate
:
this
.
state
.
providers
.
filter
(
provider
=
>
MessageLoaderUtils
.
shouldProviderUpdate
(
provider
)
)
;
lazy
.
ASRouterPreferences
.
console
.
debug
(
"
entering
loadMessagesFromAllProviders
"
)
;
await
this
.
loadAllMessageGroups
(
)
;
if
(
needsUpdate
.
length
)
{
let
newState
=
{
messages
:
[
]
providers
:
[
]
}
;
for
(
const
provider
of
this
.
state
.
providers
)
{
if
(
needsUpdate
.
includes
(
provider
)
)
{
const
{
messages
lastUpdated
errors
}
=
await
MessageLoaderUtils
.
loadMessagesForProvider
(
provider
{
storage
:
this
.
_storage
dispatchCFRAction
:
this
.
dispatchCFRAction
}
)
;
newState
.
providers
.
push
(
{
.
.
.
provider
lastUpdated
errors
}
)
;
newState
.
messages
=
[
.
.
.
newState
.
messages
.
.
.
messages
]
;
}
else
{
let
messages
=
this
.
state
.
messages
.
filter
(
msg
=
>
msg
.
provider
=
=
=
provider
.
id
)
;
newState
.
providers
.
push
(
provider
)
;
newState
.
messages
=
[
.
.
.
newState
.
messages
.
.
.
messages
]
;
}
}
const
unseenListeners
=
new
Set
(
lazy
.
ASRouterTriggerListeners
.
keys
(
)
)
;
for
(
const
{
trigger
}
of
newState
.
messages
)
{
if
(
trigger
&
&
lazy
.
ASRouterTriggerListeners
.
has
(
trigger
.
id
)
)
{
lazy
.
ASRouterTriggerListeners
.
get
(
trigger
.
id
)
.
init
(
this
.
_triggerHandler
trigger
.
params
trigger
.
patterns
)
;
unseenListeners
.
delete
(
trigger
.
id
)
;
}
}
for
(
const
triggerID
of
unseenListeners
)
{
lazy
.
ASRouterTriggerListeners
.
get
(
triggerID
)
.
uninit
(
)
;
}
await
this
.
setState
(
this
.
_removePreviewEndpoint
(
newState
)
)
;
await
this
.
cleanupImpressions
(
)
;
}
return
this
.
state
;
}
async
_maybeUpdateL10nAttachment
(
)
{
const
{
localeInUse
}
=
this
.
state
.
localeInUse
;
const
newLocale
=
Services
.
locale
.
appLocaleAsBCP47
;
if
(
newLocale
!
=
=
localeInUse
)
{
const
providers
=
[
.
.
.
this
.
state
.
providers
]
;
let
needsUpdate
=
false
;
providers
.
forEach
(
provider
=
>
{
if
(
RS_PROVIDERS_WITH_L10N
.
includes
(
provider
.
id
)
)
{
provider
.
lastUpdated
=
undefined
;
needsUpdate
=
true
;
}
}
)
;
if
(
needsUpdate
)
{
await
this
.
setState
(
{
localeInUse
:
newLocale
providers
}
)
;
await
this
.
loadMessagesFromAllProviders
(
)
;
}
}
return
this
.
state
;
}
async
_onLocaleChanged
(
subject
topic
data
)
{
await
this
.
_maybeUpdateL10nAttachment
(
)
;
}
observe
(
aSubject
aTopic
aPrefName
)
{
switch
(
aPrefName
)
{
case
USE_REMOTE_L10N_PREF
:
CFRPageActions
.
reloadL10n
(
)
;
break
;
}
}
toWaitForInitFunc
(
func
)
{
return
(
.
.
.
args
)
=
>
this
.
waitForInitialized
.
then
(
(
)
=
>
func
(
.
.
.
args
)
)
;
}
async
init
(
{
storage
sendTelemetry
clearChildMessages
clearChildProviders
updateAdminState
dispatchCFRAction
}
)
{
if
(
this
.
initializing
|
|
this
.
initialized
)
{
return
null
;
}
this
.
initializing
=
true
;
this
.
_storage
=
storage
;
this
.
ALLOWLIST_HOSTS
=
this
.
_loadSnippetsAllowHosts
(
)
;
this
.
clearChildMessages
=
this
.
toWaitForInitFunc
(
clearChildMessages
)
;
this
.
clearChildProviders
=
this
.
toWaitForInitFunc
(
clearChildProviders
)
;
this
.
updateAdminState
=
this
.
toWaitForInitFunc
(
updateAdminState
)
;
this
.
sendTelemetry
=
sendTelemetry
;
this
.
dispatchCFRAction
=
this
.
toWaitForInitFunc
(
dispatchCFRAction
)
;
lazy
.
ASRouterPreferences
.
init
(
)
;
lazy
.
ASRouterPreferences
.
addListener
(
this
.
onPrefChange
)
;
lazy
.
ToolbarBadgeHub
.
init
(
this
.
waitForInitialized
{
handleMessageRequest
:
this
.
handleMessageRequest
addImpression
:
this
.
addImpression
blockMessageById
:
this
.
blockMessageById
unblockMessageById
:
this
.
unblockMessageById
sendTelemetry
:
this
.
sendTelemetry
}
)
;
lazy
.
ToolbarPanelHub
.
init
(
this
.
waitForInitialized
{
getMessages
:
this
.
handleMessageRequest
sendTelemetry
:
this
.
sendTelemetry
}
)
;
lazy
.
MomentsPageHub
.
init
(
this
.
waitForInitialized
{
handleMessageRequest
:
this
.
handleMessageRequest
addImpression
:
this
.
addImpression
blockMessageById
:
this
.
blockMessageById
sendTelemetry
:
this
.
sendTelemetry
}
)
;
this
.
_loadLocalProviders
(
)
;
const
messageBlockList
=
(
await
this
.
_storage
.
get
(
"
messageBlockList
"
)
)
|
|
[
]
;
const
messageImpressions
=
(
await
this
.
_storage
.
get
(
"
messageImpressions
"
)
)
|
|
{
}
;
const
groupImpressions
=
(
await
this
.
_storage
.
get
(
"
groupImpressions
"
)
)
|
|
{
}
;
const
previousSessionEnd
=
(
await
this
.
_storage
.
get
(
"
previousSessionEnd
"
)
)
|
|
0
;
await
this
.
setState
(
{
messageBlockList
groupImpressions
messageImpressions
previousSessionEnd
.
.
.
(
lazy
.
ASRouterPreferences
.
specialConditions
|
|
{
}
)
initialized
:
false
}
)
;
await
this
.
_updateMessageProviders
(
)
;
await
this
.
loadMessagesFromAllProviders
(
)
;
await
MessageLoaderUtils
.
cleanupCache
(
this
.
state
.
providers
storage
)
;
lazy
.
SpecialMessageActions
.
blockMessageById
=
this
.
blockMessageById
;
Services
.
obs
.
addObserver
(
this
.
_onLocaleChanged
TOPIC_INTL_LOCALE_CHANGED
)
;
Services
.
obs
.
addObserver
(
this
.
_onExperimentForceEnrolled
TOPIC_EXPERIMENT_FORCE_ENROLLED
)
;
Services
.
prefs
.
addObserver
(
USE_REMOTE_L10N_PREF
this
)
;
this
.
_finishInitializing
(
)
;
return
this
.
state
;
}
uninit
(
)
{
this
.
_storage
.
set
(
"
previousSessionEnd
"
Date
.
now
(
)
)
;
this
.
clearChildMessages
=
null
;
this
.
clearChildProviders
=
null
;
this
.
updateAdminState
=
null
;
this
.
sendTelemetry
=
null
;
this
.
dispatchCFRAction
=
null
;
lazy
.
ASRouterPreferences
.
removeListener
(
this
.
onPrefChange
)
;
lazy
.
ASRouterPreferences
.
uninit
(
)
;
lazy
.
ToolbarPanelHub
.
uninit
(
)
;
lazy
.
ToolbarBadgeHub
.
uninit
(
)
;
lazy
.
MomentsPageHub
.
uninit
(
)
;
for
(
const
listener
of
lazy
.
ASRouterTriggerListeners
.
values
(
)
)
{
listener
.
uninit
(
)
;
}
Services
.
obs
.
removeObserver
(
this
.
_onLocaleChanged
TOPIC_INTL_LOCALE_CHANGED
)
;
Services
.
obs
.
removeObserver
(
this
.
_onExperimentForceEnrolled
TOPIC_EXPERIMENT_FORCE_ENROLLED
)
;
Services
.
prefs
.
removeObserver
(
USE_REMOTE_L10N_PREF
this
)
;
CFRPageActions
.
clearRecommendations
(
)
;
this
.
_resetInitialization
(
)
;
}
setState
(
callbackOrObj
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
"
in
setState
callbackOrObj
=
"
callbackOrObj
)
;
lazy
.
ASRouterPreferences
.
console
.
trace
(
)
;
const
newState
=
typeof
callbackOrObj
=
=
=
"
function
"
?
callbackOrObj
(
this
.
state
)
:
callbackOrObj
;
this
.
_state
=
{
.
.
.
this
.
state
.
.
.
newState
}
;
if
(
lazy
.
ASRouterPreferences
.
devtoolsEnabled
)
{
return
this
.
updateTargetingParameters
(
)
.
then
(
state
=
>
{
this
.
updateAdminState
(
state
)
;
return
state
;
}
)
;
}
return
Promise
.
resolve
(
this
.
state
)
;
}
updateTargetingParameters
(
)
{
return
this
.
getTargetingParameters
(
lazy
.
ASRouterTargeting
.
Environment
this
.
_getMessagesContext
(
)
)
.
then
(
targetingParameters
=
>
(
{
.
.
.
this
.
state
providerPrefs
:
lazy
.
ASRouterPreferences
.
providers
userPrefs
:
lazy
.
ASRouterPreferences
.
getAllUserPreferences
(
)
targetingParameters
errors
:
this
.
errors
}
)
)
;
}
getMessageById
(
id
)
{
return
this
.
state
.
messages
.
find
(
message
=
>
message
.
id
=
=
=
id
)
;
}
_loadLocalProviders
(
)
{
if
(
lazy
.
ASRouterPreferences
.
devtoolsEnabled
)
{
this
.
_localProviders
=
{
.
.
.
this
.
_localProviders
SnippetsTestMessageProvider
:
lazy
.
SnippetsTestMessageProvider
PanelTestProvider
:
lazy
.
PanelTestProvider
}
;
}
}
async
getTargetingParameters
(
environment
localContext
)
{
const
targetingParameters
=
{
}
;
for
(
const
param
of
Object
.
keys
(
environment
)
)
{
targetingParameters
[
param
]
=
await
environment
[
param
]
;
}
for
(
const
param
of
Object
.
keys
(
localContext
)
)
{
targetingParameters
[
param
]
=
await
localContext
[
param
]
;
}
return
targetingParameters
;
}
_handleTargetingError
(
error
message
)
{
Cu
.
reportError
(
error
)
;
this
.
dispatchCFRAction
(
ac
.
ASRouterUserEvent
(
{
message_id
:
message
.
id
action
:
"
asrouter_undesired_event
"
event
:
"
TARGETING_EXPRESSION_ERROR
"
event_context
:
{
}
}
)
)
;
}
_getMessagesContext
(
)
{
const
{
messageImpressions
previousSessionEnd
}
=
this
.
state
;
return
{
get
messageImpressions
(
)
{
return
messageImpressions
;
}
get
previousSessionEnd
(
)
{
return
previousSessionEnd
;
}
}
;
}
async
evaluateExpression
(
{
expression
context
}
)
{
const
targetingContext
=
new
lazy
.
TargetingContext
(
context
)
;
let
evaluationStatus
;
try
{
evaluationStatus
=
{
result
:
await
targetingContext
.
evalWithDefault
(
expression
)
success
:
true
}
;
}
catch
(
e
)
{
evaluationStatus
=
{
result
:
e
.
message
success
:
false
}
;
}
return
Promise
.
resolve
(
{
evaluationStatus
}
)
;
}
unblockAll
(
)
{
return
this
.
setState
(
{
messageBlockList
:
[
]
}
)
;
}
isUnblockedMessage
(
message
)
{
const
{
state
}
=
this
;
return
(
!
state
.
messageBlockList
.
includes
(
message
.
id
)
&
&
(
!
message
.
campaign
|
|
!
state
.
messageBlockList
.
includes
(
message
.
campaign
)
)
&
&
this
.
hasGroupsEnabled
(
message
.
groups
)
&
&
!
this
.
isExcludedByProvider
(
message
)
)
;
}
isBelowFrequencyCaps
(
message
)
{
const
{
messageImpressions
groupImpressions
}
=
this
.
state
;
const
impressionsForMessage
=
messageImpressions
[
message
.
id
]
;
return
(
this
.
_isBelowItemFrequencyCap
(
message
impressionsForMessage
MAX_MESSAGE_LIFETIME_CAP
)
&
&
message
.
groups
.
every
(
messageGroup
=
>
this
.
_isBelowItemFrequencyCap
(
this
.
state
.
groups
.
find
(
(
{
id
}
)
=
>
id
=
=
=
messageGroup
)
groupImpressions
[
messageGroup
]
)
)
)
;
}
_isBelowItemFrequencyCap
(
item
impressions
maxLifetimeCap
=
Infinity
)
{
if
(
item
&
&
item
.
frequency
&
&
impressions
&
&
impressions
.
length
)
{
if
(
item
.
frequency
.
lifetime
&
&
impressions
.
length
>
=
Math
.
min
(
item
.
frequency
.
lifetime
maxLifetimeCap
)
)
{
return
false
;
}
if
(
item
.
frequency
.
custom
)
{
const
now
=
Date
.
now
(
)
;
for
(
const
setting
of
item
.
frequency
.
custom
)
{
let
{
period
}
=
setting
;
const
impressionsInPeriod
=
impressions
.
filter
(
t
=
>
now
-
t
<
period
)
;
if
(
impressionsInPeriod
.
length
>
=
setting
.
cap
)
{
return
false
;
}
}
}
}
return
true
;
}
async
_extraTemplateStrings
(
originalMessage
)
{
let
extraTemplateStrings
;
let
localProvider
=
this
.
_findProvider
(
originalMessage
.
provider
)
;
if
(
localProvider
&
&
localProvider
.
getExtraAttributes
)
{
extraTemplateStrings
=
await
localProvider
.
getExtraAttributes
(
)
;
}
return
extraTemplateStrings
;
}
_findProvider
(
providerID
)
{
return
this
.
_localProviders
[
this
.
state
.
providers
.
find
(
i
=
>
i
.
id
=
=
=
providerID
)
.
localProvider
]
;
}
routeCFRMessage
(
message
browser
trigger
force
=
false
)
{
if
(
!
message
)
{
return
{
message
:
{
}
}
;
}
switch
(
message
.
template
)
{
case
"
whatsnew_panel_message
"
:
if
(
force
)
{
lazy
.
ToolbarPanelHub
.
forceShowMessage
(
browser
message
)
;
}
break
;
case
"
cfr_doorhanger
"
:
case
"
milestone_message
"
:
if
(
force
)
{
CFRPageActions
.
forceRecommendation
(
browser
message
this
.
dispatchCFRAction
)
;
}
else
{
CFRPageActions
.
addRecommendation
(
browser
trigger
.
param
&
&
trigger
.
param
.
host
message
this
.
dispatchCFRAction
)
;
}
break
;
case
"
cfr_urlbar_chiclet
"
:
if
(
force
)
{
CFRPageActions
.
forceRecommendation
(
browser
message
this
.
dispatchCFRAction
)
;
}
else
{
CFRPageActions
.
addRecommendation
(
browser
null
message
this
.
dispatchCFRAction
)
;
}
break
;
case
"
toolbar_badge
"
:
lazy
.
ToolbarBadgeHub
.
registerBadgeNotificationListener
(
message
{
force
}
)
;
break
;
case
"
update_action
"
:
lazy
.
MomentsPageHub
.
executeAction
(
message
)
;
break
;
case
"
infobar
"
:
lazy
.
InfoBar
.
showInfoBarMessage
(
browser
message
this
.
dispatchCFRAction
)
;
break
;
case
"
spotlight
"
:
lazy
.
Spotlight
.
showSpotlightDialog
(
browser
message
this
.
dispatchCFRAction
)
;
break
;
case
"
toast_notification
"
:
lazy
.
ToastNotification
.
showToastNotification
(
message
this
.
dispatchCFRAction
)
;
break
;
}
return
{
message
}
;
}
addImpression
(
message
)
{
const
groupsWithFrequency
=
this
.
state
.
groups
.
filter
(
(
{
frequency
id
}
)
=
>
frequency
&
&
message
.
groups
.
includes
(
id
)
)
;
if
(
message
.
frequency
|
|
groupsWithFrequency
.
length
)
{
const
time
=
Date
.
now
(
)
;
return
this
.
setState
(
state
=
>
{
const
messageImpressions
=
this
.
_addImpressionForItem
(
state
message
"
messageImpressions
"
time
)
;
let
{
groupImpressions
}
=
this
.
state
;
for
(
const
group
of
groupsWithFrequency
)
{
groupImpressions
=
this
.
_addImpressionForItem
(
state
group
"
groupImpressions
"
time
)
;
}
return
{
messageImpressions
groupImpressions
}
;
}
)
;
}
return
Promise
.
resolve
(
)
;
}
_addImpressionForItem
(
state
item
impressionsString
time
)
{
const
impressions
=
{
.
.
.
state
[
impressionsString
]
}
;
if
(
item
.
frequency
)
{
impressions
[
item
.
id
]
=
impressions
[
item
.
id
]
?
[
.
.
.
impressions
[
item
.
id
]
]
:
[
]
;
impressions
[
item
.
id
]
.
push
(
time
)
;
this
.
_storage
.
set
(
impressionsString
impressions
)
;
}
return
impressions
;
}
getLongestPeriod
(
item
)
{
if
(
!
item
.
frequency
|
|
!
item
.
frequency
.
custom
)
{
return
null
;
}
return
item
.
frequency
.
custom
.
sort
(
(
a
b
)
=
>
b
.
period
-
a
.
period
)
[
0
]
.
period
;
}
cleanupImpressions
(
)
{
return
this
.
setState
(
state
=
>
{
const
messageImpressions
=
this
.
_cleanupImpressionsForItems
(
state
state
.
messages
"
messageImpressions
"
)
;
const
groupImpressions
=
this
.
_cleanupImpressionsForItems
(
state
state
.
groups
"
groupImpressions
"
)
;
return
{
messageImpressions
groupImpressions
}
;
}
)
;
}
_cleanupImpressionsForItems
(
state
items
impressionsString
)
{
const
impressions
=
{
.
.
.
state
[
impressionsString
]
}
;
let
needsUpdate
=
false
;
Object
.
keys
(
impressions
)
.
forEach
(
id
=
>
{
const
[
item
]
=
items
.
filter
(
x
=
>
x
.
id
=
=
=
id
)
;
if
(
!
item
|
|
!
item
.
frequency
|
|
!
Array
.
isArray
(
impressions
[
id
]
)
)
{
delete
impressions
[
id
]
;
needsUpdate
=
true
;
return
;
}
if
(
!
impressions
[
id
]
.
length
)
{
return
;
}
if
(
item
.
frequency
.
custom
&
&
!
item
.
frequency
.
lifetime
)
{
const
now
=
Date
.
now
(
)
;
impressions
[
id
]
=
impressions
[
id
]
.
filter
(
t
=
>
now
-
t
<
this
.
getLongestPeriod
(
item
)
)
;
needsUpdate
=
true
;
}
}
)
;
if
(
needsUpdate
)
{
this
.
_storage
.
set
(
impressionsString
impressions
)
;
}
return
impressions
;
}
handleMessageRequest
(
{
messages
:
candidates
triggerId
triggerParam
triggerContext
template
provider
ordered
=
false
returnAll
=
false
}
)
{
let
shouldCache
;
lazy
.
ASRouterPreferences
.
console
.
debug
(
"
in
handleMessageRequest
arguments
=
"
Array
.
from
(
arguments
)
)
;
lazy
.
ASRouterPreferences
.
console
.
trace
(
)
;
const
messages
=
candidates
|
|
this
.
state
.
messages
.
filter
(
m
=
>
{
if
(
provider
&
&
m
.
provider
!
=
=
provider
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
m
.
id
"
filtered
by
provider
"
)
;
return
false
;
}
if
(
template
&
&
m
.
template
!
=
=
template
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
m
.
id
"
filtered
by
template
"
)
;
return
false
;
}
if
(
triggerId
&
&
!
m
.
trigger
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
m
.
id
"
filtered
by
trigger
"
)
;
return
false
;
}
if
(
triggerId
&
&
m
.
trigger
.
id
!
=
=
triggerId
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
m
.
id
"
filtered
by
triggerId
"
)
;
return
false
;
}
if
(
!
this
.
isUnblockedMessage
(
m
)
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
m
.
id
"
filtered
because
blocked
"
)
;
return
false
;
}
if
(
!
this
.
isBelowFrequencyCaps
(
m
)
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
m
.
id
"
filtered
because
capped
"
)
;
return
false
;
}
if
(
shouldCache
!
=
=
false
)
{
shouldCache
=
JEXL_PROVIDER_CACHE
.
has
(
m
.
provider
)
;
}
return
true
;
}
)
;
if
(
!
messages
.
length
)
{
return
returnAll
?
messages
:
null
;
}
const
context
=
this
.
_getMessagesContext
(
)
;
return
lazy
.
ASRouterTargeting
.
findMatchingMessage
(
{
messages
trigger
:
triggerId
&
&
{
id
:
triggerId
param
:
triggerParam
context
:
triggerContext
}
context
onError
:
this
.
_handleTargetingError
ordered
shouldCache
returnAll
}
)
;
}
setMessageById
(
{
id
.
.
.
data
}
force
browser
)
{
return
this
.
routeCFRMessage
(
this
.
getMessageById
(
id
)
browser
data
force
)
;
}
blockMessageById
(
idOrIds
)
{
lazy
.
ASRouterPreferences
.
console
.
debug
(
"
blockMessageById
called
idOrIds
=
"
idOrIds
)
;
lazy
.
ASRouterPreferences
.
console
.
trace
(
)
;
const
idsToBlock
=
Array
.
isArray
(
idOrIds
)
?
idOrIds
:
[
idOrIds
]
;
return
this
.
setState
(
state
=
>
{
const
messageBlockList
=
[
.
.
.
state
.
messageBlockList
]
;
const
messageImpressions
=
{
.
.
.
state
.
messageImpressions
}
;
idsToBlock
.
forEach
(
id
=
>
{
const
message
=
state
.
messages
.
find
(
m
=
>
m
.
id
=
=
=
id
)
;
const
idToBlock
=
message
&
&
message
.
campaign
?
message
.
campaign
:
id
;
if
(
!
messageBlockList
.
includes
(
idToBlock
)
)
{
messageBlockList
.
push
(
idToBlock
)
;
}
delete
messageImpressions
[
id
]
;
}
)
;
this
.
_storage
.
set
(
"
messageBlockList
"
messageBlockList
)
;
this
.
_storage
.
set
(
"
messageImpressions
"
messageImpressions
)
;
return
{
messageBlockList
messageImpressions
}
;
}
)
;
}
unblockMessageById
(
idOrIds
)
{
const
idsToUnblock
=
Array
.
isArray
(
idOrIds
)
?
idOrIds
:
[
idOrIds
]
;
return
this
.
setState
(
state
=
>
{
const
messageBlockList
=
[
.
.
.
state
.
messageBlockList
]
;
idsToUnblock
.
map
(
id
=
>
state
.
messages
.
find
(
m
=
>
m
.
id
=
=
=
id
)
)
.
forEach
(
message
=
>
{
const
idToUnblock
=
message
&
&
message
.
campaign
?
message
.
campaign
:
message
.
id
;
messageBlockList
.
splice
(
messageBlockList
.
indexOf
(
idToUnblock
)
1
)
;
}
)
;
this
.
_storage
.
set
(
"
messageBlockList
"
messageBlockList
)
;
return
{
messageBlockList
}
;
}
)
;
}
resetGroupsState
(
)
{
const
newGroupImpressions
=
{
}
;
for
(
let
{
id
}
of
this
.
state
.
groups
)
{
newGroupImpressions
[
id
]
=
[
]
;
}
this
.
_storage
.
set
(
"
groupImpressions
"
newGroupImpressions
)
;
return
this
.
setState
(
(
{
groups
}
)
=
>
(
{
groupImpressions
:
newGroupImpressions
}
)
)
;
}
resetMessageState
(
)
{
const
newMessageImpressions
=
{
}
;
for
(
let
{
id
}
of
this
.
state
.
messages
)
{
newMessageImpressions
[
id
]
=
[
]
;
}
this
.
_storage
.
set
(
"
messageImpressions
"
newMessageImpressions
)
;
return
this
.
setState
(
(
)
=
>
(
{
messageImpressions
:
newMessageImpressions
}
)
)
;
}
_validPreviewEndpoint
(
url
)
{
try
{
const
endpoint
=
new
URL
(
url
)
;
if
(
!
this
.
ALLOWLIST_HOSTS
[
endpoint
.
host
]
)
{
Cu
.
reportError
(
The
preview
URL
host
{
endpoint
.
host
}
is
not
in
the
list
of
allowed
hosts
.
)
;
}
if
(
endpoint
.
protocol
!
=
=
"
https
:
"
)
{
Cu
.
reportError
(
"
The
URL
protocol
is
not
https
.
"
)
;
}
return
(
endpoint
.
protocol
=
=
=
"
https
:
"
&
&
this
.
ALLOWLIST_HOSTS
[
endpoint
.
host
]
)
;
}
catch
(
e
)
{
return
false
;
}
}
_updateOnboardingState
(
)
{
let
addonInstallObs
=
(
subject
topic
)
=
>
{
Services
.
obs
.
removeObserver
(
addonInstallObs
"
webextension
-
install
-
notify
"
)
;
}
;
Services
.
obs
.
addObserver
(
addonInstallObs
"
webextension
-
install
-
notify
"
)
;
}
_loadSnippetsAllowHosts
(
)
{
let
additionalHosts
=
[
]
;
const
allowPrefValue
=
Services
.
prefs
.
getStringPref
(
SNIPPETS_ENDPOINT_ALLOWLIST
"
"
)
;
try
{
additionalHosts
=
JSON
.
parse
(
allowPrefValue
)
;
}
catch
(
e
)
{
if
(
allowPrefValue
)
{
Cu
.
reportError
(
Pref
{
SNIPPETS_ENDPOINT_ALLOWLIST
}
value
is
not
valid
JSON
)
;
}
}
if
(
!
additionalHosts
.
length
)
{
return
DEFAULT_ALLOWLIST_HOSTS
;
}
return
additionalHosts
.
reduce
(
(
allow_hosts
host
)
=
>
{
allow_hosts
[
host
]
=
"
preview
"
;
Services
.
console
.
logStringMessage
(
Adding
{
host
}
to
list
of
allowed
hosts
.
)
;
return
allow_hosts
;
}
{
.
.
.
DEFAULT_ALLOWLIST_HOSTS
}
)
;
}
_triggerHandler
(
browser
trigger
)
{
if
(
lazy
.
BrowserHandler
.
kiosk
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
sendTriggerMessage
(
{
.
.
.
trigger
browser
}
)
;
}
_removePreviewEndpoint
(
state
)
{
state
.
providers
=
state
.
providers
.
filter
(
p
=
>
p
.
id
!
=
=
"
preview
"
)
;
return
state
;
}
addPreviewEndpoint
(
url
browser
)
{
const
providers
=
[
.
.
.
this
.
state
.
providers
]
;
if
(
this
.
_validPreviewEndpoint
(
url
)
&
&
!
providers
.
find
(
p
=
>
p
.
url
=
=
=
url
)
)
{
browser
.
sendMessageToActor
(
"
EnterSnippetsPreviewMode
"
{
}
"
ASRouter
"
)
;
providers
.
push
(
{
id
:
"
preview
"
type
:
"
remote
"
enabled
:
true
url
updateCycleInMs
:
0
}
)
;
return
this
.
setState
(
{
providers
}
)
;
}
return
Promise
.
resolve
(
)
;
}
async
forceAttribution
(
data
)
{
const
attributionData
=
AttributionCode
.
allowedCodeKeys
.
map
(
key
=
>
{
key
}
=
{
encodeURIComponent
(
data
[
key
]
|
|
"
"
)
}
)
.
join
(
"
&
"
)
;
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
await
AttributionCode
.
writeAttributionFile
(
encodeURIComponent
(
attributionData
)
)
;
}
else
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
let
appPath
=
lazy
.
MacAttribution
.
applicationPath
;
let
attributionSvc
=
Cc
[
"
mozilla
.
org
/
mac
-
attribution
;
1
"
]
.
getService
(
Ci
.
nsIMacAttributionService
)
;
let
referrer
=
https
:
/
/
www
.
mozilla
.
org
/
anything
/
?
{
attributionData
}
;
attributionSvc
.
setReferrerUrl
(
appPath
referrer
true
)
;
await
AttributionCode
.
deleteFileAsync
(
)
;
}
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
env
.
set
(
"
XPCSHELL_TEST_PROFILE_DIR
"
"
testing
"
)
;
AttributionCode
.
_clearCache
(
)
;
await
AttributionCode
.
getAttrDataAsync
(
)
;
await
this
.
_updateMessageProviders
(
)
;
return
this
.
loadMessagesFromAllProviders
(
)
;
}
async
sendPBNewTabMessage
(
{
tabId
hideDefault
}
)
{
let
message
=
null
;
const
PromoInfo
=
{
FOCUS
:
{
enabledPref
:
"
browser
.
promo
.
focus
.
enabled
"
}
VPN
:
{
enabledPref
:
"
browser
.
vpn_promo
.
enabled
"
}
PIN
:
{
enabledPref
:
"
browser
.
promo
.
pin
.
enabled
"
}
}
;
await
this
.
loadMessagesFromAllProviders
(
)
;
if
(
hideDefault
)
{
await
this
.
setState
(
state
=
>
(
{
messages
:
state
.
messages
.
filter
(
m
=
>
!
(
m
.
template
=
=
=
"
pb_newtab
"
&
&
m
.
type
=
=
=
"
default
"
)
)
}
)
)
;
}
await
this
.
setState
(
state
=
>
(
{
messages
:
state
.
messages
.
filter
(
m
=
>
m
.
template
=
=
=
"
pb_newtab
"
&
&
Services
.
prefs
.
getBoolPref
(
PromoInfo
[
m
.
content
?
.
promoType
]
?
.
enabledPref
true
)
)
}
)
)
;
const
telemetryObject
=
{
tabId
}
;
TelemetryStopwatch
.
start
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
message
=
await
this
.
handleMessageRequest
(
{
template
:
"
pb_newtab
"
}
)
;
TelemetryStopwatch
.
finish
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
[
"
infoLinkUrl
"
]
.
forEach
(
key
=
>
{
if
(
message
?
.
content
?
.
[
key
]
)
{
message
.
content
[
key
]
=
Services
.
urlFormatter
.
formatURL
(
message
.
content
[
key
]
)
;
}
}
)
;
return
{
message
}
;
}
async
sendNewTabMessage
(
{
endpoint
tabId
browser
}
)
{
let
message
;
if
(
endpoint
)
{
await
this
.
addPreviewEndpoint
(
endpoint
.
url
browser
)
;
}
await
this
.
loadMessagesFromAllProviders
(
)
;
if
(
endpoint
)
{
message
=
await
this
.
handleMessageRequest
(
{
provider
:
"
preview
"
}
)
;
if
(
message
)
{
await
this
.
setState
(
state
=
>
(
{
messages
:
state
.
messages
.
filter
(
m
=
>
m
.
id
!
=
=
message
.
id
)
}
)
)
;
}
}
else
{
const
telemetryObject
=
{
tabId
}
;
TelemetryStopwatch
.
start
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
message
=
await
this
.
handleMessageRequest
(
{
provider
:
"
snippets
"
}
)
;
TelemetryStopwatch
.
finish
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
}
return
this
.
routeCFRMessage
(
message
browser
undefined
false
)
;
}
_recordReachEvent
(
message
)
{
const
messageGroup
=
message
.
forReachEvent
.
group
;
const
underscored
=
messageGroup
.
split
(
"
-
"
)
.
join
(
"
_
"
)
;
const
extra
=
{
branches
:
message
.
branchSlug
}
;
Services
.
telemetry
.
recordEvent
(
REACH_EVENT_CATEGORY
REACH_EVENT_METHOD
underscored
message
.
experimentSlug
extra
)
;
}
async
sendTriggerMessage
(
{
tabId
browser
.
.
.
trigger
}
)
{
await
this
.
loadMessagesFromAllProviders
(
)
;
const
telemetryObject
=
{
tabId
}
;
TelemetryStopwatch
.
start
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
const
messages
=
(
await
this
.
handleMessageRequest
(
{
triggerId
:
trigger
.
id
triggerParam
:
trigger
.
param
triggerContext
:
trigger
.
context
returnAll
:
true
}
)
)
|
|
[
]
;
TelemetryStopwatch
.
finish
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
const
nonReachMessages
=
[
]
;
for
(
const
message
of
messages
)
{
if
(
message
.
forReachEvent
)
{
if
(
!
message
.
forReachEvent
.
sent
)
{
this
.
_recordReachEvent
(
message
)
;
message
.
forReachEvent
.
sent
=
true
;
}
}
else
{
nonReachMessages
.
push
(
message
)
;
}
}
if
(
nonReachMessages
.
length
)
{
let
featureId
=
nonReachMessages
[
0
]
.
_nimbusFeature
;
if
(
featureId
)
{
lazy
.
NimbusFeatures
[
featureId
]
.
recordExposureEvent
(
{
once
:
true
}
)
;
}
}
return
this
.
routeCFRMessage
(
nonReachMessages
[
0
]
|
|
null
browser
trigger
false
)
;
}
async
forceWNPanel
(
browser
)
{
let
win
=
browser
.
ownerGlobal
;
await
lazy
.
ToolbarPanelHub
.
enableToolbarButton
(
)
;
win
.
PanelUI
.
showSubView
(
"
PanelUI
-
whatsNew
"
win
.
document
.
getElementById
(
"
whats
-
new
-
menu
-
button
"
)
)
;
let
panel
=
win
.
document
.
getElementById
(
"
customizationui
-
widget
-
panel
"
)
;
panel
.
setAttribute
(
"
noautohide
"
true
)
;
}
async
closeWNPanel
(
browser
)
{
let
win
=
browser
.
ownerGlobal
;
let
panel
=
win
.
document
.
getElementById
(
"
customizationui
-
widget
-
panel
"
)
;
panel
.
setAttribute
(
"
noautohide
"
false
)
;
await
lazy
.
ToolbarPanelHub
.
_hideToolbarButton
(
win
)
;
}
async
_onExperimentForceEnrolled
(
subject
topic
slug
)
{
const
experimentProvider
=
this
.
state
.
providers
.
find
(
p
=
>
p
.
id
=
=
=
"
messaging
-
experiments
"
)
;
if
(
!
experimentProvider
.
enabled
)
{
return
;
}
const
branch
=
lazy
.
ExperimentAPI
.
getActiveBranch
(
{
slug
}
)
;
const
features
=
branch
.
features
?
?
[
branch
.
feature
]
;
const
featureIds
=
features
.
map
(
feature
=
>
feature
.
featureId
)
;
this
.
_onFeaturesUpdated
(
.
.
.
featureIds
)
;
await
this
.
loadMessagesFromAllProviders
(
[
experimentProvider
]
)
;
}
_onFeatureListChanged
(
oldFeatures
newFeatures
)
{
for
(
const
featureId
of
oldFeatures
)
{
if
(
!
newFeatures
.
includes
(
featureId
)
)
{
const
listener
=
this
.
_experimentChangedListeners
.
get
(
featureId
)
;
this
.
_experimentChangedListeners
.
delete
(
featureId
)
;
lazy
.
NimbusFeatures
[
featureId
]
.
off
(
listener
)
;
}
}
const
newlySubscribed
=
[
]
;
for
(
const
featureId
of
newFeatures
)
{
if
(
!
oldFeatures
.
includes
(
featureId
)
)
{
const
listener
=
(
)
=
>
this
.
_onFeaturesUpdated
(
featureId
)
;
this
.
_experimentChangedListeners
.
set
(
featureId
listener
)
;
lazy
.
NimbusFeatures
[
featureId
]
.
onUpdate
(
listener
)
;
newlySubscribed
.
push
(
featureId
)
;
}
}
this
.
_onFeaturesUpdated
(
.
.
.
newlySubscribed
)
;
}
_onFeaturesUpdated
(
.
.
.
featureIds
)
{
const
messages
=
[
]
;
for
(
const
featureId
of
featureIds
)
{
const
featureAPI
=
lazy
.
NimbusFeatures
[
featureId
]
;
if
(
lazy
.
ExperimentAPI
.
getExperimentMetaData
(
{
featureId
}
)
)
{
messages
.
push
(
featureAPI
.
getAllVariables
(
)
)
;
}
}
if
(
messages
.
length
)
{
lazy
.
RemoteImages
.
prefetchImagesFor
(
messages
)
;
}
}
}
const
ASRouter
=
new
_ASRouter
(
)
;
const
EXPORTED_SYMBOLS
=
[
"
_ASRouter
"
"
ASRouter
"
"
MessageLoaderUtils
"
]
;
