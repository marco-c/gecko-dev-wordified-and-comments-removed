"
use
strict
"
;
const
{
actionCreators
:
ac
actionTypes
:
at
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
sys
.
mjs
"
)
;
const
{
TippyTopProvider
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
lib
/
TippyTopProvider
.
sys
.
mjs
"
)
;
const
{
insertPinned
TOP_SITES_MAX_SITES_PER_ROW
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
common
/
Reducers
.
sys
.
mjs
"
)
;
const
{
Dedupe
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
common
/
Dedupe
.
sys
.
mjs
"
)
;
const
{
shortURL
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
ShortURL
.
jsm
"
)
;
const
{
getDefaultOptions
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
lib
/
ActivityStreamStorage
.
sys
.
mjs
"
)
;
const
{
CUSTOM_SEARCH_SHORTCUTS
SEARCH_SHORTCUTS_EXPERIMENT
SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
checkHasSearchEngine
getSearchProvider
getSearchFormURL
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
lib
/
SearchShortcuts
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
FilterAdult
:
"
resource
:
/
/
activity
-
stream
/
lib
/
FilterAdult
.
sys
.
mjs
"
LinksCache
:
"
resource
:
/
/
activity
-
stream
/
lib
/
LinksCache
.
sys
.
mjs
"
NewTabUtils
:
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
PageThumbs
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
sys
.
mjs
"
Region
:
"
resource
:
/
/
gre
/
modules
/
Region
.
sys
.
mjs
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
sys
.
mjs
"
Sampling
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
Sampling
.
sys
.
mjs
"
Screenshots
:
"
resource
:
/
/
activity
-
stream
/
lib
/
Screenshots
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
const
{
Logger
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
messaging
-
system
/
lib
/
Logger
.
sys
.
mjs
"
)
;
return
new
Logger
(
"
TopSitesFeed
"
)
;
}
)
;
const
CONTEXT_ID_PREF
=
"
browser
.
contextual
-
services
.
contextId
"
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
contextId
"
(
)
=
>
{
let
_contextId
=
Services
.
prefs
.
getStringPref
(
CONTEXT_ID_PREF
null
)
;
if
(
!
_contextId
)
{
_contextId
=
String
(
Services
.
uuid
.
generateUUID
(
)
)
;
Services
.
prefs
.
setStringPref
(
CONTEXT_ID_PREF
_contextId
)
;
}
return
_contextId
;
}
)
;
const
DEFAULT_SITES_PREF
=
"
default
.
sites
"
;
const
SHOWN_ON_NEWTAB_PREF
=
"
feeds
.
topsites
"
;
const
DEFAULT_TOP_SITES
=
[
]
;
const
FRECENCY_THRESHOLD
=
100
+
1
;
const
MIN_FAVICON_SIZE
=
96
;
const
CACHED_LINK_PROPS_TO_MIGRATE
=
[
"
screenshot
"
"
customScreenshot
"
]
;
const
PINNED_FAVICON_PROPS_TO_MIGRATE
=
[
"
favicon
"
"
faviconRef
"
"
faviconSize
"
]
;
const
SECTION_ID
=
"
topsites
"
;
const
ROWS_PREF
=
"
topSitesRows
"
;
const
SHOW_SPONSORED_PREF
=
"
showSponsoredTopSites
"
;
const
MAX_NUM_SPONSORED
=
2
;
const
NIMBUS_VARIABLE_MAX_SPONSORED
=
"
topSitesMaxSponsored
"
;
const
NIMBUS_VARIABLE_ADDITIONAL_TILES
=
"
topSitesUseAdditionalTilesFromContile
"
;
const
NIMBUS_VARIABLE_CONTILE_SOV_ENABLED
=
"
topSitesContileSovEnabled
"
;
const
NIMBUS_VARIABLE_CONTILE_MAX_NUM_SPONSORED
=
"
topSitesContileMaxSponsored
"
;
const
FILTER_DEFAULT_SEARCH_PREF
=
"
improvesearch
.
noDefaultSearchTile
"
;
const
SEARCH_FILTERS
=
[
"
google
"
"
search
.
yahoo
"
"
yahoo
"
"
bing
"
"
ask
"
"
duckduckgo
"
]
;
const
REMOTE_SETTING_DEFAULTS_PREF
=
"
browser
.
topsites
.
useRemoteSetting
"
;
const
DEFAULT_SITES_OVERRIDE_PREF
=
"
browser
.
newtabpage
.
activity
-
stream
.
default
.
sites
"
;
const
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
=
"
browser
.
topsites
.
experiment
.
"
;
const
NIMBUS_VARIABLE_CONTILE_ENABLED
=
"
topSitesContileEnabled
"
;
const
NIMBUS_VARIABLE_CONTILE_POSITIONS
=
"
contileTopsitesPositions
"
;
const
CONTILE_ENDPOINT_PREF
=
"
browser
.
topsites
.
contile
.
endpoint
"
;
const
CONTILE_UPDATE_INTERVAL
=
15
*
60
*
1000
;
const
CONTILE_MAX_NUM_SPONSORED
=
2
;
const
TOP_SITES_BLOCKED_SPONSORS_PREF
=
"
browser
.
topsites
.
blockedSponsors
"
;
const
CONTILE_CACHE_PREF
=
"
browser
.
topsites
.
contile
.
cachedTiles
"
;
const
CONTILE_CACHE_VALID_FOR_PREF
=
"
browser
.
topsites
.
contile
.
cacheValidFor
"
;
const
CONTILE_CACHE_LAST_FETCH_PREF
=
"
browser
.
topsites
.
contile
.
lastFetch
"
;
const
SPONSORED_TILE_PARTNER_AMP
=
"
amp
"
;
const
SPONSORED_TILE_PARTNER_MOZ_SALES
=
"
moz
-
sales
"
;
const
SPONSORED_TILE_PARTNERS
=
new
Set
(
[
SPONSORED_TILE_PARTNER_AMP
SPONSORED_TILE_PARTNER_MOZ_SALES
]
)
;
const
DISPLAY_FAIL_REASON_OVERSOLD
=
"
oversold
"
;
const
DISPLAY_FAIL_REASON_DISMISSED
=
"
dismissed
"
;
function
getShortURLForCurrentSearch
(
)
{
const
url
=
shortURL
(
{
url
:
Services
.
search
.
defaultEngine
.
searchForm
}
)
;
return
url
;
}
class
TopSitesTelemetry
{
constructor
(
)
{
this
.
allSponsoredTiles
=
{
}
;
}
_tileProviderForTiles
(
tiles
)
{
return
tiles
&
&
tiles
.
length
?
this
.
_tileProvider
(
tiles
[
0
]
)
:
null
;
}
_tileProvider
(
tile
)
{
return
tile
.
partner
|
|
SPONSORED_TILE_PARTNER_AMP
;
}
_buildPropertyKey
(
tile
)
{
let
provider
=
this
.
_tileProvider
(
tile
)
;
return
provider
+
shortURL
(
tile
)
;
}
_getFilteredTiles
(
currentTiles
)
{
let
notPreviouslyFilteredTiles
=
Object
.
assign
(
{
}
.
.
.
Object
.
entries
(
this
.
allSponsoredTiles
)
.
filter
(
(
[
k
v
]
)
=
>
v
.
display_fail_reason
=
=
=
null
|
|
v
.
display_fail_reason
=
=
=
undefined
)
.
map
(
(
[
k
v
]
)
=
>
(
{
[
k
]
:
v
}
)
)
)
;
let
remainingTiles
=
currentTiles
.
map
(
el
=
>
{
return
this
.
_buildPropertyKey
(
el
)
;
}
)
;
let
tilesToUpdate
=
Object
.
keys
(
notPreviouslyFilteredTiles
)
.
filter
(
element
=
>
!
remainingTiles
.
includes
(
element
)
)
;
return
tilesToUpdate
;
}
setSponsoredTilesConfigured
(
)
{
const
maxSponsored
=
lazy
.
NimbusFeatures
.
pocketNewtab
.
getVariable
(
NIMBUS_VARIABLE_MAX_SPONSORED
)
?
?
MAX_NUM_SPONSORED
;
Glean
.
topsites
.
sponsoredTilesConfigured
.
set
(
maxSponsored
)
;
}
clearTilesForProvider
(
provider
)
{
Object
.
entries
(
this
.
allSponsoredTiles
)
.
filter
(
(
[
k
v
]
)
=
>
k
.
startsWith
(
provider
)
)
.
map
(
(
[
k
v
]
)
=
>
delete
this
.
allSponsoredTiles
[
k
]
)
;
}
_getAdvertiser
(
tile
)
{
let
label
=
tile
.
label
|
|
null
;
let
title
=
tile
.
title
|
|
null
;
return
label
?
?
title
?
?
shortURL
(
tile
)
;
}
setTiles
(
tiles
)
{
if
(
tiles
&
&
tiles
.
length
)
{
let
tile_provider
=
this
.
_tileProviderForTiles
(
tiles
)
;
this
.
clearTilesForProvider
(
tile_provider
)
;
for
(
let
sponsoredTile
of
tiles
)
{
this
.
allSponsoredTiles
[
this
.
_buildPropertyKey
(
sponsoredTile
)
]
=
{
advertiser
:
this
.
_getAdvertiser
(
sponsoredTile
)
.
toLowerCase
(
)
provider
:
tile_provider
display_position
:
null
display_fail_reason
:
null
}
;
}
}
}
_setDisplayFailReason
(
filteredTiles
reason
)
{
for
(
let
tile
of
filteredTiles
)
{
if
(
tile
in
this
.
allSponsoredTiles
)
{
let
tileToUpdate
=
this
.
allSponsoredTiles
[
tile
]
;
tileToUpdate
.
display_position
=
null
;
tileToUpdate
.
display_fail_reason
=
reason
;
}
}
}
determineFilteredTilesAndSetToOversold
(
nonOversoldTiles
)
{
let
filteredTiles
=
this
.
_getFilteredTiles
(
nonOversoldTiles
)
;
this
.
_setDisplayFailReason
(
filteredTiles
DISPLAY_FAIL_REASON_OVERSOLD
)
;
}
determineFilteredTilesAndSetToDismissed
(
nonDismissedTiles
)
{
let
filteredTiles
=
this
.
_getFilteredTiles
(
nonDismissedTiles
)
;
this
.
_setDisplayFailReason
(
filteredTiles
DISPLAY_FAIL_REASON_DISMISSED
)
;
}
_setTilePositions
(
currentTiles
)
{
if
(
this
.
allSponsoredTiles
)
{
currentTiles
.
forEach
(
item
=
>
{
if
(
this
.
_buildPropertyKey
(
item
)
in
this
.
allSponsoredTiles
)
{
let
tile
=
this
.
allSponsoredTiles
[
this
.
_buildPropertyKey
(
item
)
]
;
if
(
tile
.
display_fail_reason
=
=
=
undefined
|
|
tile
.
display_fail_reason
=
=
=
null
)
{
tile
.
display_position
=
item
.
sponsored_position
;
}
}
}
)
;
}
}
finalizeNewtabPingFields
(
currentTiles
)
{
this
.
_setTilePositions
(
currentTiles
)
;
Glean
.
topsites
.
sponsoredTilesReceived
.
set
(
JSON
.
stringify
(
{
sponsoredTilesReceived
:
Object
.
values
(
this
.
allSponsoredTiles
)
}
)
)
;
}
}
class
ContileIntegration
{
constructor
(
topSitesFeed
)
{
this
.
_topSitesFeed
=
topSitesFeed
;
this
.
_lastPeriodicUpdate
=
0
;
this
.
_sites
=
[
]
;
this
.
_sov
=
null
;
}
get
sites
(
)
{
return
this
.
_sites
;
}
get
sov
(
)
{
return
this
.
_sov
;
}
periodicUpdate
(
)
{
let
now
=
Date
.
now
(
)
;
if
(
now
-
this
.
_lastPeriodicUpdate
>
=
CONTILE_UPDATE_INTERVAL
)
{
this
.
_lastPeriodicUpdate
=
now
;
this
.
refresh
(
)
;
}
}
async
refresh
(
)
{
let
updateDefaultSites
=
await
this
.
_fetchSites
(
)
;
await
this
.
_topSitesFeed
.
allocatePositions
(
)
;
if
(
updateDefaultSites
)
{
this
.
_topSitesFeed
.
_readDefaults
(
)
;
}
}
_resetContileCachePrefs
(
)
{
Services
.
prefs
.
clearUserPref
(
CONTILE_CACHE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
CONTILE_CACHE_LAST_FETCH_PREF
)
;
Services
.
prefs
.
clearUserPref
(
CONTILE_CACHE_VALID_FOR_PREF
)
;
}
_filterBlockedSponsors
(
tiles
)
{
const
blocklist
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
TOP_SITES_BLOCKED_SPONSORS_PREF
"
[
]
"
)
)
;
return
tiles
.
filter
(
tile
=
>
!
blocklist
.
includes
(
shortURL
(
tile
)
)
)
;
}
_extractCacheValidFor
(
cacheHeader
)
{
if
(
!
cacheHeader
)
{
lazy
.
log
.
warn
(
"
Contile
response
cache
control
header
is
empty
"
)
;
return
0
;
}
const
[
staleIfError
]
=
cacheHeader
.
match
(
/
stale
-
if
-
error
=
\
s
*
(
[
0
-
9
]
+
)
/
i
)
;
const
[
maxAge
]
=
cacheHeader
.
match
(
/
max
-
age
=
\
s
*
(
[
0
-
9
]
+
)
/
i
)
;
const
validFor
=
Number
.
parseInt
(
staleIfError
10
)
+
Number
.
parseInt
(
maxAge
10
)
;
return
isNaN
(
validFor
)
?
0
:
validFor
;
}
_loadTilesFromCache
(
)
{
lazy
.
log
.
info
(
"
Contile
client
is
trying
to
load
tiles
from
local
cache
.
"
)
;
const
now
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
const
lastFetch
=
Services
.
prefs
.
getIntPref
(
CONTILE_CACHE_LAST_FETCH_PREF
0
)
;
const
validFor
=
Services
.
prefs
.
getIntPref
(
CONTILE_CACHE_VALID_FOR_PREF
0
)
;
this
.
_topSitesFeed
.
_telemetryUtility
.
setSponsoredTilesConfigured
(
)
;
if
(
now
<
=
lastFetch
+
validFor
)
{
try
{
let
cachedTiles
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
CONTILE_CACHE_PREF
)
)
;
this
.
_topSitesFeed
.
_telemetryUtility
.
setTiles
(
cachedTiles
)
;
cachedTiles
=
this
.
_filterBlockedSponsors
(
cachedTiles
)
;
this
.
_topSitesFeed
.
_telemetryUtility
.
determineFilteredTilesAndSetToDismissed
(
cachedTiles
)
;
this
.
_sites
=
cachedTiles
;
lazy
.
log
.
info
(
"
Local
cache
loaded
.
"
)
;
return
true
;
}
catch
(
error
)
{
lazy
.
log
.
warn
(
Failed
to
load
tiles
from
local
cache
:
{
error
}
.
)
;
return
false
;
}
}
return
false
;
}
_getMaxNumFromContile
(
)
{
return
(
lazy
.
NimbusFeatures
.
pocketNewtab
.
getVariable
(
NIMBUS_VARIABLE_CONTILE_MAX_NUM_SPONSORED
)
?
?
CONTILE_MAX_NUM_SPONSORED
)
;
}
async
_fetchSites
(
)
{
if
(
!
lazy
.
NimbusFeatures
.
newtab
.
getVariable
(
NIMBUS_VARIABLE_CONTILE_ENABLED
)
|
|
!
this
.
_topSitesFeed
.
store
.
getState
(
)
.
Prefs
.
values
[
SHOW_SPONSORED_PREF
]
)
{
if
(
this
.
_sites
.
length
)
{
this
.
_sites
=
[
]
;
return
true
;
}
return
false
;
}
try
{
let
url
=
Services
.
prefs
.
getStringPref
(
CONTILE_ENDPOINT_PREF
)
;
const
response
=
await
this
.
_topSitesFeed
.
fetch
(
url
{
credentials
:
"
omit
"
}
)
;
if
(
!
response
.
ok
)
{
lazy
.
log
.
warn
(
Contile
endpoint
returned
unexpected
status
:
{
response
.
status
}
)
;
if
(
response
.
status
=
=
=
304
|
|
response
.
status
>
=
500
)
{
return
this
.
_loadTilesFromCache
(
)
;
}
}
const
lastFetch
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
Services
.
prefs
.
setIntPref
(
CONTILE_CACHE_LAST_FETCH_PREF
lastFetch
)
;
this
.
_topSitesFeed
.
_telemetryUtility
.
setSponsoredTilesConfigured
(
)
;
if
(
response
.
status
=
=
=
204
)
{
this
.
_topSitesFeed
.
_telemetryUtility
.
clearTilesForProvider
(
SPONSORED_TILE_PARTNER_AMP
)
;
if
(
this
.
_sites
.
length
)
{
this
.
_sites
=
[
]
;
Services
.
prefs
.
setStringPref
(
CONTILE_CACHE_PREF
JSON
.
stringify
(
this
.
_sites
)
)
;
return
true
;
}
return
false
;
}
const
body
=
await
response
.
json
(
)
;
if
(
body
?
.
sov
)
{
this
.
_sov
=
JSON
.
parse
(
atob
(
body
.
sov
)
)
;
}
if
(
body
?
.
tiles
&
&
Array
.
isArray
(
body
.
tiles
)
)
{
const
useAdditionalTiles
=
lazy
.
NimbusFeatures
.
newtab
.
getVariable
(
NIMBUS_VARIABLE_ADDITIONAL_TILES
)
;
const
maxNumFromContile
=
this
.
_getMaxNumFromContile
(
)
;
let
{
tiles
}
=
body
;
this
.
_topSitesFeed
.
_telemetryUtility
.
setTiles
(
tiles
)
;
if
(
useAdditionalTiles
!
=
=
undefined
&
&
!
useAdditionalTiles
&
&
tiles
.
length
>
maxNumFromContile
)
{
tiles
.
length
=
maxNumFromContile
;
this
.
_topSitesFeed
.
_telemetryUtility
.
determineFilteredTilesAndSetToOversold
(
tiles
)
;
}
tiles
=
this
.
_filterBlockedSponsors
(
tiles
)
;
this
.
_topSitesFeed
.
_telemetryUtility
.
determineFilteredTilesAndSetToDismissed
(
tiles
)
;
if
(
tiles
.
length
>
maxNumFromContile
)
{
lazy
.
log
.
info
(
"
Remove
unused
links
from
Contile
"
)
;
tiles
.
length
=
maxNumFromContile
;
this
.
_topSitesFeed
.
_telemetryUtility
.
determineFilteredTilesAndSetToOversold
(
tiles
)
;
}
this
.
_sites
=
tiles
;
Services
.
prefs
.
setStringPref
(
CONTILE_CACHE_PREF
JSON
.
stringify
(
this
.
_sites
)
)
;
Services
.
prefs
.
setIntPref
(
CONTILE_CACHE_VALID_FOR_PREF
this
.
_extractCacheValidFor
(
response
.
headers
.
get
(
"
cache
-
control
"
)
|
|
response
.
headers
.
get
(
"
Cache
-
Control
"
)
)
)
;
return
true
;
}
}
catch
(
error
)
{
lazy
.
log
.
warn
(
Failed
to
fetch
data
from
Contile
server
:
{
error
.
message
}
)
;
return
this
.
_loadTilesFromCache
(
)
;
}
return
false
;
}
}
class
TopSitesFeed
{
constructor
(
)
{
this
.
_telemetryUtility
=
new
TopSitesTelemetry
(
)
;
this
.
_contile
=
new
ContileIntegration
(
this
)
;
this
.
_tippyTopProvider
=
new
TippyTopProvider
(
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
_currentSearchHostname
"
getShortURLForCurrentSearch
)
;
this
.
dedupe
=
new
Dedupe
(
this
.
_dedupeKey
)
;
this
.
frecentCache
=
new
lazy
.
LinksCache
(
lazy
.
NewTabUtils
.
activityStreamLinks
"
getTopSites
"
CACHED_LINK_PROPS_TO_MIGRATE
(
oldOptions
newOptions
)
=
>
!
(
oldOptions
.
numItems
>
=
newOptions
.
numItems
)
)
;
this
.
pinnedCache
=
new
lazy
.
LinksCache
(
lazy
.
NewTabUtils
.
pinnedLinks
"
links
"
[
.
.
.
CACHED_LINK_PROPS_TO_MIGRATE
.
.
.
PINNED_FAVICON_PROPS_TO_MIGRATE
]
)
;
lazy
.
PageThumbs
.
addExpirationFilter
(
this
)
;
this
.
_nimbusChangeListener
=
this
.
_nimbusChangeListener
.
bind
(
this
)
;
}
_nimbusChangeListener
(
event
reason
)
{
if
(
!
[
"
feature
-
experiment
-
loaded
"
"
feature
-
rollout
-
loaded
"
]
.
includes
(
reason
)
)
{
this
.
_contile
.
refresh
(
)
;
}
}
init
(
)
{
this
.
_readDefaults
(
{
isStartup
:
true
}
)
;
this
.
_storage
=
this
.
store
.
dbStorage
.
getDbTable
(
"
sectionPrefs
"
)
;
this
.
_contile
.
refresh
(
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
region
-
updated
"
)
;
Services
.
prefs
.
addObserver
(
REMOTE_SETTING_DEFAULTS_PREF
this
)
;
Services
.
prefs
.
addObserver
(
DEFAULT_SITES_OVERRIDE_PREF
this
)
;
Services
.
prefs
.
addObserver
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
this
)
;
lazy
.
NimbusFeatures
.
newtab
.
onUpdate
(
this
.
_nimbusChangeListener
)
;
}
uninit
(
)
{
lazy
.
PageThumbs
.
removeExpirationFilter
(
this
)
;
Services
.
obs
.
removeObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
removeObserver
(
this
"
browser
-
region
-
updated
"
)
;
Services
.
prefs
.
removeObserver
(
REMOTE_SETTING_DEFAULTS_PREF
this
)
;
Services
.
prefs
.
removeObserver
(
DEFAULT_SITES_OVERRIDE_PREF
this
)
;
Services
.
prefs
.
removeObserver
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
this
)
;
lazy
.
NimbusFeatures
.
newtab
.
offUpdate
(
this
.
_nimbusChangeListener
)
;
}
observe
(
subj
topic
data
)
{
switch
(
topic
)
{
case
"
browser
-
search
-
engine
-
modified
"
:
if
(
data
=
=
=
"
engine
-
default
"
&
&
this
.
store
.
getState
(
)
.
Prefs
.
values
[
FILTER_DEFAULT_SEARCH_PREF
]
)
{
delete
this
.
_currentSearchHostname
;
this
.
_currentSearchHostname
=
getShortURLForCurrentSearch
(
)
;
}
this
.
refresh
(
{
broadcast
:
true
}
)
;
break
;
case
"
browser
-
region
-
updated
"
:
this
.
_readDefaults
(
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
data
=
=
=
REMOTE_SETTING_DEFAULTS_PREF
|
|
data
=
=
=
DEFAULT_SITES_OVERRIDE_PREF
|
|
data
.
startsWith
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
)
)
{
this
.
_readDefaults
(
)
;
}
break
;
}
}
_dedupeKey
(
site
)
{
return
site
&
&
site
.
hostname
;
}
async
_readDefaults
(
{
isStartup
=
false
}
=
{
}
)
{
this
.
_useRemoteSetting
=
false
;
if
(
!
Services
.
prefs
.
getBoolPref
(
REMOTE_SETTING_DEFAULTS_PREF
)
)
{
this
.
refreshDefaults
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
DEFAULT_SITES_PREF
]
{
isStartup
}
)
;
return
;
}
if
(
Services
.
prefs
.
prefIsLocked
(
DEFAULT_SITES_OVERRIDE_PREF
)
|
|
Cu
.
isInAutomation
)
{
let
sites
=
Services
.
prefs
.
getStringPref
(
DEFAULT_SITES_OVERRIDE_PREF
"
"
)
;
this
.
refreshDefaults
(
sites
{
isStartup
}
)
;
return
;
}
DEFAULT_TOP_SITES
.
length
=
0
;
const
contileEnabled
=
lazy
.
NimbusFeatures
.
newtab
.
getVariable
(
NIMBUS_VARIABLE_CONTILE_ENABLED
)
;
let
contilePositions
=
lazy
.
NimbusFeatures
.
pocketNewtab
.
getVariable
(
NIMBUS_VARIABLE_CONTILE_POSITIONS
)
?
.
split
(
"
"
)
.
map
(
item
=
>
parseInt
(
item
10
)
+
1
)
.
filter
(
item
=
>
!
Number
.
isNaN
(
item
)
)
;
if
(
!
contilePositions
|
|
contilePositions
.
length
=
=
=
0
)
{
contilePositions
=
[
1
2
]
;
}
let
hasContileTiles
=
false
;
if
(
contileEnabled
)
{
let
contilePositionIndex
=
0
;
const
minLength
=
Math
.
min
(
contilePositions
.
length
this
.
_contile
.
sites
.
length
)
;
for
(
let
i
=
0
;
i
<
minLength
;
i
+
+
)
{
let
site
=
this
.
_contile
.
sites
[
i
]
;
let
hostname
=
shortURL
(
site
)
;
let
link
=
{
isDefault
:
true
url
:
site
.
url
hostname
sendAttributionRequest
:
false
label
:
site
.
name
show_sponsored_label
:
hostname
!
=
=
"
yandex
"
sponsored_position
:
contilePositions
[
contilePositionIndex
+
+
]
sponsored_click_url
:
site
.
click_url
sponsored_impression_url
:
site
.
impression_url
sponsored_tile_id
:
site
.
id
partner
:
SPONSORED_TILE_PARTNER_AMP
}
;
if
(
site
.
image_url
&
&
site
.
image_size
>
=
MIN_FAVICON_SIZE
)
{
link
.
favicon
=
site
.
image_url
;
link
.
faviconSize
=
site
.
image_size
;
}
DEFAULT_TOP_SITES
.
push
(
link
)
;
}
hasContileTiles
=
contilePositionIndex
>
0
;
this
.
_telemetryUtility
.
determineFilteredTilesAndSetToOversold
(
DEFAULT_TOP_SITES
)
;
}
this
.
_useRemoteSetting
=
true
;
let
remoteSettingData
=
await
this
.
_getRemoteConfig
(
)
;
const
sponsoredBlocklist
=
JSON
.
parse
(
Services
.
prefs
.
getStringPref
(
TOP_SITES_BLOCKED_SPONSORS_PREF
"
[
]
"
)
)
;
for
(
let
siteData
of
remoteSettingData
)
{
let
hostname
=
shortURL
(
siteData
)
;
if
(
contileEnabled
&
&
DEFAULT_TOP_SITES
.
findIndex
(
site
=
>
site
.
hostname
=
=
=
hostname
)
>
-
1
)
{
continue
;
}
if
(
siteData
.
sponsored_position
&
&
sponsoredBlocklist
.
includes
(
hostname
)
)
{
continue
;
}
let
link
=
{
isDefault
:
true
url
:
siteData
.
url
hostname
sendAttributionRequest
:
!
!
siteData
.
send_attribution_request
}
;
if
(
siteData
.
url_urlbar_override
)
{
link
.
url_urlbar
=
siteData
.
url_urlbar_override
;
}
if
(
siteData
.
title
)
{
link
.
label
=
siteData
.
title
;
}
if
(
siteData
.
search_shortcut
)
{
link
=
await
this
.
topSiteToSearchTopSite
(
link
)
;
}
else
if
(
siteData
.
sponsored_position
)
{
if
(
contileEnabled
&
&
hasContileTiles
)
{
continue
;
}
const
{
sponsored_position
sponsored_tile_id
sponsored_impression_url
sponsored_click_url
}
=
siteData
;
link
=
{
sponsored_position
sponsored_tile_id
sponsored_impression_url
sponsored_click_url
show_sponsored_label
:
link
.
hostname
!
=
=
"
yandex
"
.
.
.
link
}
;
}
DEFAULT_TOP_SITES
.
push
(
link
)
;
}
this
.
refresh
(
{
broadcast
:
true
isStartup
}
)
;
}
refreshDefaults
(
sites
{
isStartup
=
false
}
=
{
}
)
{
DEFAULT_TOP_SITES
.
length
=
0
;
if
(
sites
)
{
for
(
const
url
of
sites
.
split
(
"
"
)
)
{
const
site
=
{
isDefault
:
true
url
}
;
site
.
hostname
=
shortURL
(
site
)
;
DEFAULT_TOP_SITES
.
push
(
site
)
;
}
}
this
.
refresh
(
{
broadcast
:
true
isStartup
}
)
;
}
async
_getRemoteConfig
(
firstTime
=
true
)
{
if
(
!
this
.
_remoteConfig
)
{
this
.
_remoteConfig
=
await
lazy
.
RemoteSettings
(
"
top
-
sites
"
)
;
this
.
_remoteConfig
.
on
(
"
sync
"
(
)
=
>
{
this
.
_readDefaults
(
)
;
}
)
;
}
let
result
=
[
]
;
let
failed
=
false
;
try
{
result
=
await
this
.
_remoteConfig
.
get
(
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
failed
=
true
;
}
if
(
!
result
.
length
)
{
console
.
error
(
"
Received
empty
top
sites
configuration
!
"
)
;
failed
=
true
;
}
if
(
firstTime
&
&
failed
)
{
await
this
.
_remoteConfig
.
db
.
clear
(
)
;
return
this
.
_getRemoteConfig
(
false
)
;
}
result
.
sort
(
(
a
b
)
=
>
a
.
order
-
b
.
order
)
;
result
=
result
.
filter
(
topsite
=
>
{
if
(
topsite
.
exclude_regions
?
.
includes
(
lazy
.
Region
.
home
)
)
{
return
false
;
}
if
(
topsite
.
include_regions
?
.
length
&
&
!
topsite
.
include_regions
.
includes
(
lazy
.
Region
.
home
)
)
{
return
false
;
}
if
(
topsite
.
exclude_locales
?
.
includes
(
Services
.
locale
.
appLocaleAsBCP47
)
)
{
return
false
;
}
if
(
topsite
.
include_locales
?
.
length
&
&
!
topsite
.
include_locales
.
includes
(
Services
.
locale
.
appLocaleAsBCP47
)
)
{
return
false
;
}
if
(
topsite
.
exclude_experiments
?
.
some
(
experimentID
=
>
Services
.
prefs
.
getBoolPref
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
+
experimentID
false
)
)
)
{
return
false
;
}
if
(
topsite
.
include_experiments
?
.
length
&
&
topsite
.
include_experiments
.
every
(
experimentID
=
>
!
Services
.
prefs
.
getBoolPref
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
+
experimentID
false
)
)
)
{
return
false
;
}
return
true
;
}
)
;
return
result
;
}
filterForThumbnailExpiration
(
callback
)
{
const
{
rows
}
=
this
.
store
.
getState
(
)
.
TopSites
;
callback
(
rows
.
reduce
(
(
acc
site
)
=
>
{
acc
.
push
(
site
.
url
)
;
if
(
site
.
customScreenshotURL
)
{
acc
.
push
(
site
.
customScreenshotURL
)
;
}
return
acc
;
}
[
]
)
)
;
}
shouldFilterSearchTile
(
hostname
)
{
if
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
FILTER_DEFAULT_SEARCH_PREF
]
&
&
(
SEARCH_FILTERS
.
includes
(
hostname
)
|
|
hostname
=
=
=
this
.
_currentSearchHostname
)
)
{
return
true
;
}
return
false
;
}
async
_maybeInsertSearchShortcuts
(
plainPinnedSites
)
{
if
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_EXPERIMENT
]
)
{
const
prevInsertedShortcuts
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
]
.
split
(
"
"
)
.
filter
(
s
=
>
s
)
;
const
newInsertedShortcuts
=
[
]
;
let
shouldPin
=
this
.
_useRemoteSetting
?
DEFAULT_TOP_SITES
.
filter
(
s
=
>
s
.
searchTopSite
)
.
map
(
s
=
>
s
.
hostname
)
:
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF
]
.
split
(
"
"
)
;
shouldPin
=
shouldPin
.
map
(
getSearchProvider
)
.
filter
(
s
=
>
s
&
&
s
.
shortURL
!
=
=
this
.
_currentSearchHostname
)
;
if
(
shouldPin
.
every
(
shortcut
=
>
prevInsertedShortcuts
.
includes
(
shortcut
.
shortURL
)
)
)
{
return
false
;
}
const
numberOfSlots
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
;
const
emptySlots
=
Math
.
max
(
numberOfSlots
-
plainPinnedSites
.
length
0
)
;
const
pinnedSites
=
[
.
.
.
plainPinnedSites
]
.
concat
(
Array
(
emptySlots
)
.
fill
(
null
)
)
;
const
tryToInsertSearchShortcut
=
async
shortcut
=
>
{
const
nextAvailable
=
pinnedSites
.
indexOf
(
null
)
;
if
(
!
pinnedSites
.
find
(
s
=
>
s
&
&
shortURL
(
s
)
=
=
=
shortcut
.
shortURL
)
&
&
!
prevInsertedShortcuts
.
includes
(
shortcut
.
shortURL
)
&
&
nextAvailable
>
-
1
&
&
(
await
checkHasSearchEngine
(
shortcut
.
keyword
)
)
)
{
const
site
=
await
this
.
topSiteToSearchTopSite
(
{
url
:
shortcut
.
url
}
)
;
this
.
_pinSiteAt
(
site
nextAvailable
)
;
pinnedSites
[
nextAvailable
]
=
site
;
newInsertedShortcuts
.
push
(
shortcut
.
shortURL
)
;
}
}
;
for
(
let
shortcut
of
shouldPin
)
{
await
tryToInsertSearchShortcut
(
shortcut
)
;
}
if
(
newInsertedShortcuts
.
length
)
{
this
.
store
.
dispatch
(
ac
.
SetPref
(
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
prevInsertedShortcuts
.
concat
(
newInsertedShortcuts
)
.
join
(
"
"
)
)
)
;
return
true
;
}
}
return
false
;
}
fetch
(
.
.
.
args
)
{
return
fetch
(
.
.
.
args
)
;
}
fetchDiscoveryStreamSpocs
(
)
{
let
sponsored
=
[
]
;
const
{
DiscoveryStream
}
=
this
.
store
.
getState
(
)
;
if
(
DiscoveryStream
)
{
const
discoveryStreamSpocs
=
DiscoveryStream
.
spocs
.
data
[
"
sponsored
-
topsites
"
]
?
.
items
|
|
[
]
;
const
findSponsoredTopsitesPositions
=
name
=
>
{
for
(
const
row
of
DiscoveryStream
.
layout
)
{
for
(
const
component
of
row
.
components
)
{
if
(
component
.
placement
?
.
name
=
=
=
name
)
{
return
component
.
spocs
.
positions
;
}
}
}
return
null
;
}
;
const
discoveryStreamSpocPositions
=
findSponsoredTopsitesPositions
(
"
sponsored
-
topsites
"
)
;
if
(
discoveryStreamSpocPositions
?
.
length
)
{
function
reformatImageURL
(
url
width
height
)
{
return
'
https
:
/
/
img
-
getpocket
.
cdn
.
mozilla
.
net
/
{
width
}
x
{
height
}
/
filters
:
format
(
jpeg
)
:
quality
(
60
)
:
no_upscale
(
)
:
strip_exif
(
)
/
{
encodeURIComponent
(
url
)
}
'
;
}
const
minLength
=
Math
.
min
(
discoveryStreamSpocPositions
.
length
discoveryStreamSpocs
.
length
)
;
for
(
let
i
=
0
;
i
<
minLength
;
i
+
+
)
{
const
positionIndex
=
discoveryStreamSpocPositions
[
i
]
.
index
;
const
spoc
=
discoveryStreamSpocs
[
i
]
;
const
link
=
{
favicon
:
reformatImageURL
(
spoc
.
raw_image_src
96
96
)
faviconSize
:
96
type
:
"
SPOC
"
label
:
spoc
.
title
|
|
spoc
.
sponsor
title
:
spoc
.
title
|
|
spoc
.
sponsor
url
:
spoc
.
url
flightId
:
spoc
.
flight_id
id
:
spoc
.
id
guid
:
spoc
.
id
shim
:
spoc
.
shim
pos
:
positionIndex
sponsored_position
:
positionIndex
+
1
hostname
:
shortURL
(
{
url
:
spoc
.
url
}
)
partner
:
SPONSORED_TILE_PARTNER_MOZ_SALES
}
;
sponsored
.
push
(
link
)
;
}
}
}
return
sponsored
;
}
async
getLinksWithDefaults
(
isStartup
=
false
)
{
const
prefValues
=
this
.
store
.
getState
(
)
.
Prefs
.
values
;
const
numItems
=
prefValues
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
;
const
searchShortcutsExperiment
=
prefValues
[
SEARCH_SHORTCUTS_EXPERIMENT
]
;
try
{
await
Services
.
search
.
init
(
)
;
}
catch
{
}
let
frecent
=
[
]
;
const
cache
=
await
this
.
frecentCache
.
request
(
{
numItems
:
numItems
+
SEARCH_FILTERS
.
length
+
1
topsiteFrecency
:
FRECENCY_THRESHOLD
}
)
;
for
(
let
link
of
cache
)
{
const
hostname
=
shortURL
(
link
)
;
if
(
!
this
.
shouldFilterSearchTile
(
hostname
)
)
{
frecent
.
push
(
{
.
.
.
(
searchShortcutsExperiment
?
await
this
.
topSiteToSearchTopSite
(
link
)
:
link
)
hostname
}
)
;
}
}
let
contileSponsored
=
[
]
;
let
notBlockedDefaultSites
=
[
]
;
for
(
let
link
of
DEFAULT_TOP_SITES
)
{
if
(
link
.
sponsored_position
&
&
link
.
hostname
=
=
=
"
yandex
"
)
{
if
(
link
.
hostname
!
=
=
this
.
_currentSearchHostname
)
{
continue
;
}
}
else
if
(
this
.
shouldFilterSearchTile
(
link
.
hostname
)
)
{
continue
;
}
if
(
lazy
.
NewTabUtils
.
blockedLinks
.
isBlocked
(
{
url
:
link
.
url
}
)
)
{
continue
;
}
const
searchProvider
=
getSearchProvider
(
shortURL
(
link
)
)
;
if
(
searchProvider
&
&
lazy
.
NewTabUtils
.
blockedLinks
.
isBlocked
(
{
url
:
searchProvider
.
url
}
)
)
{
continue
;
}
if
(
link
.
sponsored_position
)
{
if
(
!
prefValues
[
SHOW_SPONSORED_PREF
]
)
{
continue
;
}
contileSponsored
[
link
.
sponsored_position
-
1
]
=
link
;
this
.
_unpinSearchShortcut
(
link
.
hostname
)
;
}
else
{
notBlockedDefaultSites
.
push
(
searchShortcutsExperiment
?
await
this
.
topSiteToSearchTopSite
(
link
)
:
link
)
;
}
}
this
.
_telemetryUtility
.
determineFilteredTilesAndSetToDismissed
(
contileSponsored
)
;
const
discoverySponsored
=
this
.
fetchDiscoveryStreamSpocs
(
)
;
this
.
_telemetryUtility
.
setTiles
(
discoverySponsored
)
;
const
sponsored
=
this
.
_mergeSponsoredLinks
(
{
[
SPONSORED_TILE_PARTNER_AMP
]
:
contileSponsored
[
SPONSORED_TILE_PARTNER_MOZ_SALES
]
:
discoverySponsored
}
)
;
this
.
_maybeCapSponsoredLinks
(
sponsored
)
;
this
.
_telemetryUtility
.
determineFilteredTilesAndSetToOversold
(
sponsored
)
;
let
plainPinned
=
await
this
.
pinnedCache
.
request
(
)
;
if
(
await
this
.
_maybeInsertSearchShortcuts
(
plainPinned
)
)
{
this
.
pinnedCache
.
expire
(
)
;
plainPinned
=
await
this
.
pinnedCache
.
request
(
)
;
}
const
pinned
=
await
Promise
.
all
(
plainPinned
.
map
(
async
link
=
>
{
if
(
!
link
)
{
return
link
;
}
if
(
link
.
searchTopSite
)
{
const
searchProvider
=
getSearchProvider
(
shortURL
(
link
)
)
;
if
(
!
searchProvider
|
|
!
(
await
checkHasSearchEngine
(
searchProvider
.
keyword
)
)
)
{
return
null
;
}
}
const
finder
=
other
=
>
other
.
url
=
=
=
link
.
url
;
const
frecentSite
=
frecent
.
find
(
finder
)
;
if
(
frecentSite
&
&
link
.
customScreenshotURL
)
{
delete
frecentSite
.
screenshot
;
}
const
copy
=
Object
.
assign
(
{
}
frecentSite
|
|
{
isDefault
:
!
!
notBlockedDefaultSites
.
find
(
finder
)
}
link
{
hostname
:
shortURL
(
link
)
}
{
searchTopSite
:
!
!
link
.
searchTopSite
}
)
;
if
(
!
copy
.
favicon
)
{
try
{
lazy
.
NewTabUtils
.
activityStreamProvider
.
_faviconBytesToDataURI
(
await
lazy
.
NewTabUtils
.
activityStreamProvider
.
_addFavicons
(
[
copy
]
)
)
;
for
(
const
prop
of
PINNED_FAVICON_PROPS_TO_MIGRATE
)
{
copy
.
__sharedCache
.
updateLink
(
prop
copy
[
prop
]
)
;
}
}
catch
(
e
)
{
}
}
return
copy
;
}
)
)
;
const
[
dedupedSponsored
dedupedFrecent
dedupedDefaults
]
=
this
.
dedupe
.
group
(
pinned
sponsored
frecent
notBlockedDefaultSites
)
;
const
dedupedUnpinned
=
[
.
.
.
dedupedFrecent
.
.
.
dedupedDefaults
]
;
const
checkedAdult
=
lazy
.
FilterAdult
.
filter
(
dedupedUnpinned
)
;
let
withPinned
=
insertPinned
(
checkedAdult
pinned
)
;
dedupedSponsored
.
forEach
(
link
=
>
{
if
(
!
link
)
{
return
;
}
let
index
=
link
.
sponsored_position
-
1
;
if
(
index
>
=
withPinned
.
length
)
{
withPinned
[
index
]
=
link
;
}
else
if
(
withPinned
[
index
]
?
.
sponsored_position
)
{
withPinned
[
index
]
=
link
;
}
else
{
withPinned
.
splice
(
index
0
link
)
;
}
}
)
;
withPinned
=
withPinned
.
slice
(
0
numItems
)
;
for
(
const
link
of
withPinned
)
{
if
(
link
)
{
if
(
link
.
customScreenshotURL
)
{
this
.
_fetchScreenshot
(
link
link
.
customScreenshotURL
isStartup
)
;
}
else
if
(
link
.
searchTopSite
&
&
!
link
.
isDefault
)
{
await
this
.
_attachTippyTopIconForSearchShortcut
(
link
link
.
label
)
;
}
else
{
this
.
_fetchIcon
(
link
isStartup
)
;
}
delete
link
.
__sharedCache
;
link
.
typedBonus
=
true
;
}
}
this
.
_linksWithDefaults
=
withPinned
;
this
.
_telemetryUtility
.
finalizeNewtabPingFields
(
dedupedSponsored
)
;
return
withPinned
;
}
_maybeCapSponsoredLinks
(
links
)
{
const
maxSponsored
=
lazy
.
NimbusFeatures
.
pocketNewtab
.
getVariable
(
NIMBUS_VARIABLE_MAX_SPONSORED
)
?
?
MAX_NUM_SPONSORED
;
if
(
links
.
length
>
maxSponsored
)
{
links
.
length
=
maxSponsored
;
}
}
_mergeSponsoredLinks
(
sponsoredLinks
)
{
const
{
positions
:
allocatedPositions
ready
:
sovReady
}
=
this
.
store
.
getState
(
)
.
TopSites
.
sov
|
|
{
}
;
if
(
!
this
.
_contile
.
sov
|
|
!
sovReady
|
|
!
lazy
.
NimbusFeatures
.
pocketNewtab
.
getVariable
(
NIMBUS_VARIABLE_CONTILE_SOV_ENABLED
)
)
{
return
Object
.
values
(
sponsoredLinks
)
.
flat
(
)
;
}
sponsoredLinks
[
SPONSORED_TILE_PARTNER_AMP
]
=
sponsoredLinks
[
SPONSORED_TILE_PARTNER_AMP
]
.
filter
(
Boolean
)
;
let
sponsored
=
[
]
;
let
chosenPartners
=
[
]
;
for
(
const
allocation
of
allocatedPositions
)
{
let
link
=
null
;
const
{
assignedPartner
}
=
allocation
;
if
(
assignedPartner
)
{
link
=
sponsoredLinks
[
assignedPartner
]
?
.
shift
(
)
;
}
if
(
!
link
)
{
for
(
const
partner
of
SPONSORED_TILE_PARTNERS
)
{
if
(
partner
=
=
=
assignedPartner
|
|
sponsoredLinks
[
partner
]
.
length
=
=
=
0
)
{
continue
;
}
link
=
sponsoredLinks
[
partner
]
.
shift
(
)
;
break
;
}
if
(
!
link
)
{
if
(
chosenPartners
.
length
)
{
Glean
.
newtab
.
sovAllocation
.
set
(
chosenPartners
.
map
(
entry
=
>
JSON
.
stringify
(
entry
)
)
)
;
}
return
sponsored
;
}
}
link
.
sponsored_position
=
allocation
.
position
;
if
(
link
.
pos
!
=
=
undefined
)
{
link
.
pos
=
allocation
.
position
-
1
;
}
sponsored
.
push
(
link
)
;
chosenPartners
.
push
(
{
pos
:
allocation
.
position
assigned
:
assignedPartner
chosen
:
link
.
partner
}
)
;
}
if
(
chosenPartners
.
length
)
{
Glean
.
newtab
.
sovAllocation
.
set
(
chosenPartners
.
map
(
entry
=
>
JSON
.
stringify
(
entry
)
)
)
;
}
if
(
lazy
.
NimbusFeatures
.
pocketNewtab
.
getVariable
(
NIMBUS_VARIABLE_CONTILE_MAX_NUM_SPONSORED
)
)
{
return
sponsored
.
concat
(
sponsoredLinks
[
SPONSORED_TILE_PARTNER_AMP
]
)
;
}
return
sponsored
;
}
async
_attachTippyTopIconForSearchShortcut
(
link
keyword
)
{
if
(
[
"
\
u044F
\
u043D
\
u0434
\
u0435
\
u043A
\
u0441
"
"
yandex
"
]
.
includes
(
keyword
)
)
{
let
site
=
{
url
:
link
.
url
}
;
site
.
url
=
(
await
getSearchFormURL
(
keyword
)
)
|
|
site
.
url
;
this
.
_tippyTopProvider
.
processSite
(
site
)
;
link
.
tippyTopIcon
=
site
.
tippyTopIcon
;
link
.
smallFavicon
=
site
.
smallFavicon
;
link
.
backgroundColor
=
site
.
backgroundColor
;
}
else
{
this
.
_tippyTopProvider
.
processSite
(
link
)
;
}
}
async
refresh
(
options
=
{
}
)
{
if
(
!
this
.
_startedUp
&
&
!
options
.
isStartup
)
{
return
;
}
this
.
_startedUp
=
true
;
if
(
!
this
.
_tippyTopProvider
.
initialized
)
{
await
this
.
_tippyTopProvider
.
init
(
)
;
}
const
links
=
await
this
.
getLinksWithDefaults
(
{
isStartup
:
options
.
isStartup
}
)
;
const
newAction
=
{
type
:
at
.
TOP_SITES_UPDATED
data
:
{
links
}
}
;
let
storedPrefs
;
try
{
storedPrefs
=
(
await
this
.
_storage
.
get
(
SECTION_ID
)
)
|
|
{
}
;
}
catch
(
e
)
{
storedPrefs
=
{
}
;
console
.
error
(
"
Problem
getting
stored
prefs
for
TopSites
"
)
;
}
newAction
.
data
.
pref
=
getDefaultOptions
(
storedPrefs
)
;
if
(
options
.
isStartup
)
{
newAction
.
meta
=
{
isStartup
:
true
}
;
}
if
(
options
.
broadcast
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
newAction
)
)
;
}
else
{
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
newAction
)
)
;
}
}
async
allocatePositions
(
)
{
if
(
!
this
.
_contile
.
sov
)
{
return
;
}
const
sampleInput
=
{
lazy
.
contextId
}
-
{
this
.
_contile
.
sov
.
name
}
;
const
allocatedPositions
=
[
]
;
for
(
const
allocation
of
this
.
_contile
.
sov
.
allocations
)
{
const
allocatedPosition
=
{
position
:
allocation
.
position
}
;
allocatedPositions
.
push
(
allocatedPosition
)
;
const
ratios
=
allocation
.
allocation
.
map
(
alloc
=
>
alloc
.
percentage
)
;
if
(
ratios
.
length
)
{
const
index
=
await
lazy
.
Sampling
.
ratioSample
(
sampleInput
ratios
)
;
allocatedPosition
.
assignedPartner
=
allocation
.
allocation
[
index
]
.
partner
;
}
}
this
.
store
.
dispatch
(
ac
.
OnlyToMain
(
{
type
:
at
.
SOV_UPDATED
data
:
{
ready
:
!
!
allocatedPositions
.
length
positions
:
allocatedPositions
}
}
)
)
;
}
async
updateCustomSearchShortcuts
(
isStartup
=
false
)
{
if
(
!
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_EXPERIMENT
]
)
{
return
;
}
if
(
!
this
.
_tippyTopProvider
.
initialized
)
{
await
this
.
_tippyTopProvider
.
init
(
)
;
}
let
searchShortcuts
=
[
]
;
for
(
const
engine
of
await
Services
.
search
.
getAppProvidedEngines
(
)
)
{
const
shortcut
=
CUSTOM_SEARCH_SHORTCUTS
.
find
(
s
=
>
engine
.
aliases
.
includes
(
s
.
keyword
)
)
;
if
(
shortcut
)
{
let
clone
=
{
.
.
.
shortcut
}
;
await
this
.
_attachTippyTopIconForSearchShortcut
(
clone
clone
.
keyword
)
;
searchShortcuts
.
push
(
clone
)
;
}
}
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
UPDATE_SEARCH_SHORTCUTS
data
:
{
searchShortcuts
}
meta
:
{
isStartup
}
}
)
)
;
}
async
topSiteToSearchTopSite
(
site
)
{
const
searchProvider
=
getSearchProvider
(
shortURL
(
site
)
)
;
if
(
!
searchProvider
|
|
!
(
await
checkHasSearchEngine
(
searchProvider
.
keyword
)
)
)
{
return
site
;
}
return
{
.
.
.
site
searchTopSite
:
true
label
:
searchProvider
.
keyword
}
;
}
async
_fetchIcon
(
link
isStartup
=
false
)
{
if
(
link
.
favicon
&
&
link
.
faviconSize
>
=
MIN_FAVICON_SIZE
)
{
return
;
}
this
.
_tippyTopProvider
.
processSite
(
link
)
;
if
(
link
.
tippyTopIcon
)
{
return
;
}
this
.
_requestRichIcon
(
link
.
url
)
;
await
this
.
_fetchScreenshot
(
link
link
.
url
isStartup
)
;
}
async
_fetchScreenshot
(
link
url
isStartup
=
false
)
{
if
(
link
.
screenshot
|
|
!
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SHOWN_ON_NEWTAB_PREF
]
)
{
return
;
}
await
lazy
.
Screenshots
.
maybeCacheScreenshot
(
link
url
"
screenshot
"
screenshot
=
>
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
data
:
{
screenshot
url
:
link
.
url
}
type
:
at
.
SCREENSHOT_UPDATED
meta
:
{
isStartup
}
}
)
)
)
;
}
async
getScreenshotPreview
(
url
target
)
{
const
preview
=
(
await
lazy
.
Screenshots
.
getScreenshotForURL
(
url
)
)
|
|
"
"
;
this
.
store
.
dispatch
(
ac
.
OnlyToOneContent
(
{
data
:
{
url
preview
}
type
:
at
.
PREVIEW_RESPONSE
}
target
)
)
;
}
_requestRichIcon
(
url
)
{
this
.
store
.
dispatch
(
{
type
:
at
.
RICH_ICON_MISSING
data
:
{
url
}
}
)
;
}
updateSectionPrefs
(
collapsed
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
TOP_SITES_PREFS_UPDATED
data
:
{
pref
:
collapsed
}
}
)
)
;
}
_broadcastPinnedSitesUpdated
(
)
{
this
.
pinnedCache
.
expire
(
)
;
this
.
refresh
(
{
broadcast
:
true
}
)
;
}
async
_pinSiteAt
(
{
customScreenshotURL
label
url
searchTopSite
}
index
)
{
const
toPin
=
{
url
}
;
if
(
label
)
{
toPin
.
label
=
label
;
}
if
(
customScreenshotURL
)
{
toPin
.
customScreenshotURL
=
customScreenshotURL
;
}
if
(
searchTopSite
)
{
toPin
.
searchTopSite
=
searchTopSite
;
}
lazy
.
NewTabUtils
.
pinnedLinks
.
pin
(
toPin
index
)
;
await
this
.
_clearLinkCustomScreenshot
(
{
customScreenshotURL
url
}
)
;
}
async
_clearLinkCustomScreenshot
(
site
)
{
if
(
site
.
customScreenshotURL
!
=
=
undefined
)
{
const
pinned
=
await
this
.
pinnedCache
.
request
(
)
;
const
link
=
pinned
.
find
(
pin
=
>
pin
&
&
pin
.
url
=
=
=
site
.
url
)
;
if
(
link
&
&
link
.
customScreenshotURL
!
=
=
site
.
customScreenshotURL
)
{
link
.
__sharedCache
.
updateLink
(
"
screenshot
"
undefined
)
;
}
}
}
async
pin
(
action
)
{
let
{
site
index
}
=
action
.
data
;
index
=
this
.
_adjustPinIndexForSponsoredLinks
(
site
index
)
;
if
(
index
>
=
0
)
{
await
this
.
_pinSiteAt
(
site
index
)
;
this
.
_broadcastPinnedSitesUpdated
(
)
;
}
else
{
if
(
index
=
=
=
-
1
)
{
lazy
.
NewTabUtils
.
blockedLinks
.
unblock
(
{
url
:
site
.
url
}
)
;
this
.
frecentCache
.
expire
(
)
;
}
this
.
insert
(
action
)
;
}
}
unpin
(
action
)
{
const
{
site
}
=
action
.
data
;
lazy
.
NewTabUtils
.
pinnedLinks
.
unpin
(
site
)
;
this
.
_broadcastPinnedSitesUpdated
(
)
;
}
unpinAllSearchShortcuts
(
)
{
Services
.
prefs
.
clearUserPref
(
browser
.
newtabpage
.
activity
-
stream
.
{
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
}
)
;
for
(
let
pinnedLink
of
lazy
.
NewTabUtils
.
pinnedLinks
.
links
)
{
if
(
pinnedLink
&
&
pinnedLink
.
searchTopSite
)
{
lazy
.
NewTabUtils
.
pinnedLinks
.
unpin
(
pinnedLink
)
;
}
}
this
.
pinnedCache
.
expire
(
)
;
}
_unpinSearchShortcut
(
vendor
)
{
for
(
let
pinnedLink
of
lazy
.
NewTabUtils
.
pinnedLinks
.
links
)
{
if
(
pinnedLink
&
&
pinnedLink
.
searchTopSite
&
&
shortURL
(
pinnedLink
)
=
=
=
vendor
)
{
lazy
.
NewTabUtils
.
pinnedLinks
.
unpin
(
pinnedLink
)
;
this
.
pinnedCache
.
expire
(
)
;
const
prevInsertedShortcuts
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
]
.
split
(
"
"
)
;
this
.
store
.
dispatch
(
ac
.
SetPref
(
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
prevInsertedShortcuts
.
filter
(
s
=
>
s
!
=
=
vendor
)
.
join
(
"
"
)
)
)
;
break
;
}
}
}
_adjustPinIndexForSponsoredLinks
(
site
index
)
{
if
(
!
this
.
_linksWithDefaults
)
{
return
index
;
}
let
adjustedIndex
=
index
;
for
(
let
i
=
0
;
i
<
index
;
i
+
+
)
{
const
link
=
this
.
_linksWithDefaults
[
i
]
;
if
(
link
&
&
link
.
sponsored_position
&
&
this
.
_linksWithDefaults
[
i
]
?
.
url
!
=
=
site
.
url
)
{
adjustedIndex
-
-
;
}
}
return
adjustedIndex
;
}
_insertPin
(
site
originalIndex
draggedFromIndex
)
{
let
index
=
this
.
_adjustPinIndexForSponsoredLinks
(
site
originalIndex
)
;
const
topSitesCount
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
;
if
(
index
>
=
topSitesCount
)
{
return
;
}
let
pinned
=
lazy
.
NewTabUtils
.
pinnedLinks
.
links
;
if
(
!
pinned
[
index
]
)
{
this
.
_pinSiteAt
(
site
index
)
;
}
else
{
pinned
[
draggedFromIndex
]
=
null
;
let
holeIndex
=
index
;
const
indexStep
=
index
>
draggedFromIndex
?
-
1
:
1
;
while
(
pinned
[
holeIndex
]
)
{
holeIndex
+
=
indexStep
;
}
if
(
holeIndex
>
=
topSitesCount
|
|
holeIndex
<
0
)
{
holeIndex
=
topSitesCount
-
1
;
}
const
shiftingStep
=
holeIndex
>
index
?
-
1
:
1
;
while
(
holeIndex
!
=
=
index
)
{
const
nextIndex
=
holeIndex
+
shiftingStep
;
this
.
_pinSiteAt
(
pinned
[
nextIndex
]
holeIndex
)
;
holeIndex
=
nextIndex
;
}
this
.
_pinSiteAt
(
site
index
)
;
}
}
async
insert
(
action
)
{
let
{
index
}
=
action
.
data
;
if
(
!
(
index
>
0
)
)
{
index
=
0
;
}
this
.
_insertPin
(
action
.
data
.
site
index
action
.
data
.
draggedFromIndex
!
=
=
undefined
?
action
.
data
.
draggedFromIndex
:
this
.
store
.
getState
(
)
.
Prefs
.
values
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
)
;
await
this
.
_clearLinkCustomScreenshot
(
action
.
data
.
site
)
;
this
.
_broadcastPinnedSitesUpdated
(
)
;
}
updatePinnedSearchShortcuts
(
{
addedShortcuts
deletedShortcuts
}
)
{
deletedShortcuts
.
forEach
(
(
{
url
}
)
=
>
{
lazy
.
NewTabUtils
.
pinnedLinks
.
unpin
(
{
url
}
)
;
}
)
;
const
numberOfSlots
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
;
addedShortcuts
.
forEach
(
shortcut
=
>
{
let
index
=
lazy
.
NewTabUtils
.
pinnedLinks
.
links
.
findIndex
(
link
=
>
!
link
)
;
if
(
index
<
0
&
&
lazy
.
NewTabUtils
.
pinnedLinks
.
links
.
length
+
1
<
numberOfSlots
)
{
index
=
lazy
.
NewTabUtils
.
pinnedLinks
.
links
.
length
;
}
if
(
index
>
=
0
)
{
lazy
.
NewTabUtils
.
pinnedLinks
.
pin
(
shortcut
index
)
;
}
else
{
this
.
_insertPin
(
shortcut
0
numberOfSlots
)
;
}
}
)
;
this
.
_broadcastPinnedSitesUpdated
(
)
;
}
onAction
(
action
)
{
switch
(
action
.
type
)
{
case
at
.
INIT
:
this
.
init
(
)
;
this
.
updateCustomSearchShortcuts
(
true
)
;
break
;
case
at
.
SYSTEM_TICK
:
this
.
refresh
(
{
broadcast
:
false
}
)
;
this
.
_contile
.
periodicUpdate
(
)
;
break
;
case
at
.
PLACES_HISTORY_CLEARED
:
case
at
.
PLACES_LINKS_DELETED
:
this
.
frecentCache
.
expire
(
)
;
this
.
refresh
(
{
broadcast
:
true
}
)
;
break
;
case
at
.
PLACES_LINKS_CHANGED
:
this
.
frecentCache
.
expire
(
)
;
this
.
refresh
(
{
broadcast
:
false
}
)
;
break
;
case
at
.
PLACES_LINK_BLOCKED
:
this
.
frecentCache
.
expire
(
)
;
this
.
pinnedCache
.
expire
(
)
;
this
.
refresh
(
{
broadcast
:
true
}
)
;
break
;
case
at
.
PREF_CHANGED
:
switch
(
action
.
data
.
name
)
{
case
DEFAULT_SITES_PREF
:
if
(
!
this
.
_useRemoteSetting
)
{
this
.
refreshDefaults
(
action
.
data
.
value
)
;
}
break
;
case
ROWS_PREF
:
case
FILTER_DEFAULT_SEARCH_PREF
:
case
SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF
:
this
.
refresh
(
{
broadcast
:
true
}
)
;
break
;
case
SHOW_SPONSORED_PREF
:
if
(
lazy
.
NimbusFeatures
.
newtab
.
getVariable
(
NIMBUS_VARIABLE_CONTILE_ENABLED
)
)
{
this
.
_contile
.
refresh
(
)
;
}
else
{
this
.
refresh
(
{
broadcast
:
true
}
)
;
}
if
(
!
action
.
data
.
value
)
{
this
.
_contile
.
_resetContileCachePrefs
(
)
;
}
break
;
case
SEARCH_SHORTCUTS_EXPERIMENT
:
if
(
action
.
data
.
value
)
{
this
.
updateCustomSearchShortcuts
(
)
;
}
else
{
this
.
unpinAllSearchShortcuts
(
)
;
}
this
.
refresh
(
{
broadcast
:
true
}
)
;
}
break
;
case
at
.
UPDATE_SECTION_PREFS
:
if
(
action
.
data
.
id
=
=
=
SECTION_ID
)
{
this
.
updateSectionPrefs
(
action
.
data
.
value
)
;
}
break
;
case
at
.
PREFS_INITIAL_VALUES
:
if
(
!
this
.
_useRemoteSetting
)
{
this
.
refreshDefaults
(
action
.
data
[
DEFAULT_SITES_PREF
]
)
;
}
break
;
case
at
.
TOP_SITES_PIN
:
this
.
pin
(
action
)
;
break
;
case
at
.
TOP_SITES_UNPIN
:
this
.
unpin
(
action
)
;
break
;
case
at
.
TOP_SITES_INSERT
:
this
.
insert
(
action
)
;
break
;
case
at
.
PREVIEW_REQUEST
:
this
.
getScreenshotPreview
(
action
.
data
.
url
action
.
meta
.
fromTarget
)
;
break
;
case
at
.
UPDATE_PINNED_SEARCH_SHORTCUTS
:
this
.
updatePinnedSearchShortcuts
(
action
.
data
)
;
break
;
case
at
.
DISCOVERY_STREAM_SPOCS_UPDATE
:
this
.
refresh
(
{
broadcast
:
true
isStartup
:
action
.
meta
.
isStartup
}
)
;
break
;
case
at
.
UNINIT
:
this
.
uninit
(
)
;
break
;
}
}
}
const
EXPORTED_SYMBOLS
=
[
"
TopSitesFeed
"
"
DEFAULT_TOP_SITES
"
"
ContileIntegration
"
]
;
