"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
actionCreators
:
ac
actionTypes
:
at
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
jsm
"
)
;
const
{
TippyTopProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
TippyTopProvider
.
jsm
"
)
;
const
{
insertPinned
TOP_SITES_MAX_SITES_PER_ROW
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Reducers
.
jsm
"
)
;
const
{
Dedupe
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Dedupe
.
jsm
"
)
;
const
{
shortURL
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
ShortURL
.
jsm
"
)
;
const
{
getDefaultOptions
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
ActivityStreamStorage
.
jsm
"
)
;
const
{
CUSTOM_SEARCH_SHORTCUTS
SEARCH_SHORTCUTS_EXPERIMENT
SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
checkHasSearchEngine
getSearchProvider
getSearchFormURL
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
SearchShortcuts
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
filterAdult
"
"
resource
:
/
/
activity
-
stream
/
lib
/
FilterAdult
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LinksCache
"
"
resource
:
/
/
activity
-
stream
/
lib
/
LinksCache
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Screenshots
"
"
resource
:
/
/
activity
-
stream
/
lib
/
Screenshots
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PageThumbs
"
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
RemoteSettings
"
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Region
"
"
resource
:
/
/
gre
/
modules
/
Region
.
jsm
"
)
;
const
DEFAULT_SITES_PREF
=
"
default
.
sites
"
;
const
SHOWN_ON_NEWTAB_PREF
=
"
feeds
.
topsites
"
;
const
DEFAULT_TOP_SITES
=
[
]
;
const
ATTRIBUTION_REQUEST_SITES
=
[
]
;
const
FRECENCY_THRESHOLD
=
100
+
1
;
const
MIN_FAVICON_SIZE
=
96
;
const
CACHED_LINK_PROPS_TO_MIGRATE
=
[
"
screenshot
"
"
customScreenshot
"
]
;
const
PINNED_FAVICON_PROPS_TO_MIGRATE
=
[
"
favicon
"
"
faviconRef
"
"
faviconSize
"
]
;
const
SECTION_ID
=
"
topsites
"
;
const
ROWS_PREF
=
"
topSitesRows
"
;
const
SHOW_SPONSORED_PREF
=
"
showSponsoredTopSites
"
;
const
FILTER_DEFAULT_SEARCH_PREF
=
"
improvesearch
.
noDefaultSearchTile
"
;
const
SEARCH_FILTERS
=
[
"
google
"
"
search
.
yahoo
"
"
yahoo
"
"
bing
"
"
ask
"
"
duckduckgo
"
]
;
const
REMOTE_SETTING_DEFAULTS_PREF
=
"
browser
.
topsites
.
useRemoteSetting
"
;
const
REMOTE_SETTING_MIGRATION_ID_PREF
=
"
browser
.
topsites
.
migratedToRemoteSetting
.
id
"
;
const
DEFAULT_SITES_POLICY_PREF
=
"
browser
.
newtabpage
.
activity
-
stream
.
default
.
sites
"
;
const
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
=
"
browser
.
topsites
.
experiment
.
"
;
function
getShortURLForCurrentSearch
(
)
{
const
url
=
shortURL
(
{
url
:
Services
.
search
.
defaultEngine
.
searchForm
}
)
;
return
url
;
}
this
.
TopSitesFeed
=
class
TopSitesFeed
{
constructor
(
)
{
this
.
_tippyTopProvider
=
new
TippyTopProvider
(
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_currentSearchHostname
"
getShortURLForCurrentSearch
)
;
this
.
dedupe
=
new
Dedupe
(
this
.
_dedupeKey
)
;
this
.
frecentCache
=
new
LinksCache
(
NewTabUtils
.
activityStreamLinks
"
getTopSites
"
CACHED_LINK_PROPS_TO_MIGRATE
(
oldOptions
newOptions
)
=
>
!
(
oldOptions
.
numItems
>
=
newOptions
.
numItems
)
)
;
this
.
pinnedCache
=
new
LinksCache
(
NewTabUtils
.
pinnedLinks
"
links
"
[
.
.
.
CACHED_LINK_PROPS_TO_MIGRATE
.
.
.
PINNED_FAVICON_PROPS_TO_MIGRATE
]
)
;
PageThumbs
.
addExpirationFilter
(
this
)
;
}
init
(
)
{
this
.
_readDefaults
(
{
isStartup
:
true
}
)
;
this
.
_storage
=
this
.
store
.
dbStorage
.
getDbTable
(
"
sectionPrefs
"
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
prefs
.
addObserver
(
REMOTE_SETTING_DEFAULTS_PREF
this
)
;
Services
.
prefs
.
addObserver
(
DEFAULT_SITES_POLICY_PREF
this
)
;
Services
.
prefs
.
addObserver
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
this
)
;
}
uninit
(
)
{
PageThumbs
.
removeExpirationFilter
(
this
)
;
Services
.
obs
.
removeObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
prefs
.
removeObserver
(
REMOTE_SETTING_DEFAULTS_PREF
this
)
;
Services
.
prefs
.
removeObserver
(
DEFAULT_SITES_POLICY_PREF
this
)
;
Services
.
prefs
.
removeObserver
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
this
)
;
}
observe
(
subj
topic
data
)
{
switch
(
topic
)
{
case
"
browser
-
search
-
engine
-
modified
"
:
if
(
data
=
=
=
"
engine
-
default
"
&
&
this
.
store
.
getState
(
)
.
Prefs
.
values
[
FILTER_DEFAULT_SEARCH_PREF
]
)
{
delete
this
.
_currentSearchHostname
;
this
.
_currentSearchHostname
=
getShortURLForCurrentSearch
(
)
;
this
.
refresh
(
{
broadcast
:
true
}
)
;
}
break
;
case
"
nsPref
:
changed
"
:
if
(
data
=
=
=
REMOTE_SETTING_DEFAULTS_PREF
|
|
data
=
=
=
DEFAULT_SITES_POLICY_PREF
|
|
data
.
startsWith
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
)
)
{
this
.
_readDefaults
(
)
;
}
break
;
}
}
_dedupeKey
(
site
)
{
return
site
&
&
site
.
hostname
;
}
async
_readDefaults
(
{
isStartup
=
false
}
=
{
}
)
{
this
.
_useRemoteSetting
=
Services
.
prefs
.
getBoolPref
(
REMOTE_SETTING_DEFAULTS_PREF
)
;
if
(
!
this
.
_useRemoteSetting
)
{
this
.
refreshDefaults
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
DEFAULT_SITES_PREF
]
{
isStartup
}
)
;
Services
.
prefs
.
clearUserPref
(
REMOTE_SETTING_MIGRATION_ID_PREF
)
;
return
;
}
const
remoteSettingMigrationID
=
1
;
if
(
Services
.
prefs
.
getIntPref
(
REMOTE_SETTING_MIGRATION_ID_PREF
0
)
<
remoteSettingMigrationID
)
{
this
.
unpinAllSearchShortcuts
(
)
;
Services
.
prefs
.
setIntPref
(
REMOTE_SETTING_MIGRATION_ID_PREF
remoteSettingMigrationID
)
;
}
if
(
Services
.
prefs
.
prefIsLocked
(
DEFAULT_SITES_POLICY_PREF
)
)
{
let
sites
;
try
{
sites
=
Services
.
prefs
.
getStringPref
(
DEFAULT_SITES_POLICY_PREF
)
;
}
catch
(
e
)
{
}
if
(
sites
)
{
this
.
refreshDefaults
(
sites
{
isStartup
}
)
;
return
;
}
}
let
remoteSettingData
=
await
this
.
_getRemoteConfig
(
)
;
DEFAULT_TOP_SITES
.
length
=
0
;
ATTRIBUTION_REQUEST_SITES
.
length
=
0
;
for
(
let
siteData
of
remoteSettingData
)
{
let
link
=
{
isDefault
:
true
url
:
siteData
.
url
hostname
:
shortURL
(
siteData
)
}
;
if
(
siteData
.
url_urlbar_override
)
{
link
.
url_urlbar
=
siteData
.
url_urlbar_override
;
}
if
(
siteData
.
title
)
{
link
.
label
=
siteData
.
title
;
}
if
(
siteData
.
search_shortcut
)
{
link
=
await
this
.
topSiteToSearchTopSite
(
link
)
;
}
else
{
if
(
siteData
.
sponsored_position
)
{
link
.
sponsored_position
=
siteData
.
sponsored_position
;
}
if
(
siteData
.
send_attribution_request
)
{
ATTRIBUTION_REQUEST_SITES
.
push
(
siteData
.
url
)
;
}
}
DEFAULT_TOP_SITES
.
push
(
link
)
;
}
this
.
refresh
(
{
broadcast
:
true
isStartup
}
)
;
}
refreshDefaults
(
sites
{
isStartup
=
false
}
=
{
}
)
{
DEFAULT_TOP_SITES
.
length
=
0
;
ATTRIBUTION_REQUEST_SITES
.
length
=
0
;
if
(
sites
)
{
for
(
const
url
of
sites
.
split
(
"
"
)
)
{
const
site
=
{
isDefault
:
true
url
}
;
site
.
hostname
=
shortURL
(
site
)
;
DEFAULT_TOP_SITES
.
push
(
site
)
;
}
}
this
.
refresh
(
{
broadcast
:
true
isStartup
}
)
;
}
async
_getRemoteConfig
(
firstTime
=
true
)
{
if
(
!
this
.
_remoteConfig
)
{
this
.
_remoteConfig
=
await
RemoteSettings
(
"
top
-
sites
"
)
;
this
.
_remoteConfig
.
on
(
"
sync
"
(
)
=
>
{
this
.
_readDefaults
(
)
;
}
)
;
}
let
result
=
[
]
;
let
failed
=
false
;
try
{
result
=
await
this
.
_remoteConfig
.
get
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
failed
=
true
;
}
if
(
!
result
.
length
)
{
Cu
.
reportError
(
"
Received
empty
top
sites
configuration
!
"
)
;
failed
=
true
;
}
if
(
firstTime
&
&
failed
)
{
await
this
.
_remoteConfig
.
db
.
clear
(
)
;
return
this
.
_getRemoteConfig
(
false
)
;
}
result
.
sort
(
(
a
b
)
=
>
a
.
order
-
b
.
order
)
;
result
=
result
.
filter
(
topsite
=
>
{
if
(
topsite
.
exclude_regions
?
.
includes
(
Region
.
home
)
)
{
return
false
;
}
if
(
topsite
.
include_regions
?
.
length
&
&
!
topsite
.
include_regions
.
includes
(
Region
.
home
)
)
{
return
false
;
}
if
(
topsite
.
exclude_locales
?
.
includes
(
Services
.
locale
.
appLocaleAsBCP47
)
)
{
return
false
;
}
if
(
topsite
.
include_locales
?
.
length
&
&
!
topsite
.
include_locales
.
includes
(
Services
.
locale
.
appLocaleAsBCP47
)
)
{
return
false
;
}
if
(
topsite
.
exclude_experiments
?
.
some
(
experimentID
=
>
Services
.
prefs
.
getBoolPref
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
+
experimentID
false
)
)
)
{
return
false
;
}
if
(
topsite
.
include_experiments
?
.
length
&
&
topsite
.
include_experiments
.
every
(
experimentID
=
>
!
Services
.
prefs
.
getBoolPref
(
DEFAULT_SITES_EXPERIMENTS_PREF_BRANCH
+
experimentID
false
)
)
)
{
return
false
;
}
return
true
;
}
)
;
return
result
;
}
filterForThumbnailExpiration
(
callback
)
{
const
{
rows
}
=
this
.
store
.
getState
(
)
.
TopSites
;
callback
(
rows
.
reduce
(
(
acc
site
)
=
>
{
acc
.
push
(
site
.
url
)
;
if
(
site
.
customScreenshotURL
)
{
acc
.
push
(
site
.
customScreenshotURL
)
;
}
return
acc
;
}
[
]
)
)
;
}
shouldFilterSearchTile
(
hostname
)
{
if
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
FILTER_DEFAULT_SEARCH_PREF
]
&
&
(
SEARCH_FILTERS
.
includes
(
hostname
)
|
|
hostname
=
=
=
this
.
_currentSearchHostname
)
)
{
return
true
;
}
return
false
;
}
async
_maybeInsertSearchShortcuts
(
plainPinnedSites
)
{
if
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_EXPERIMENT
]
)
{
const
prevInsertedShortcuts
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
]
.
split
(
"
"
)
.
filter
(
s
=
>
s
)
;
const
newInsertedShortcuts
=
[
]
;
let
shouldPin
=
this
.
_useRemoteSetting
?
DEFAULT_TOP_SITES
.
filter
(
s
=
>
s
.
searchTopSite
)
.
map
(
s
=
>
s
.
hostname
)
:
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF
]
.
split
(
"
"
)
;
shouldPin
=
shouldPin
.
map
(
getSearchProvider
)
.
filter
(
s
=
>
s
&
&
s
.
shortURL
!
=
=
this
.
_currentSearchHostname
)
;
if
(
shouldPin
.
every
(
shortcut
=
>
prevInsertedShortcuts
.
includes
(
shortcut
.
shortURL
)
)
)
{
return
false
;
}
const
numberOfSlots
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
;
const
emptySlots
=
Math
.
max
(
numberOfSlots
-
plainPinnedSites
.
length
0
)
;
const
pinnedSites
=
[
.
.
.
plainPinnedSites
]
.
concat
(
Array
(
emptySlots
)
.
fill
(
null
)
)
;
const
tryToInsertSearchShortcut
=
async
shortcut
=
>
{
const
nextAvailable
=
pinnedSites
.
indexOf
(
null
)
;
if
(
!
pinnedSites
.
find
(
s
=
>
s
&
&
s
.
hostname
=
=
=
shortcut
.
shortURL
)
&
&
!
prevInsertedShortcuts
.
includes
(
shortcut
.
shortURL
)
&
&
nextAvailable
>
-
1
&
&
(
await
checkHasSearchEngine
(
shortcut
.
keyword
)
)
)
{
const
site
=
await
this
.
topSiteToSearchTopSite
(
{
url
:
shortcut
.
url
}
)
;
this
.
_pinSiteAt
(
site
nextAvailable
)
;
pinnedSites
[
nextAvailable
]
=
site
;
newInsertedShortcuts
.
push
(
shortcut
.
shortURL
)
;
}
}
;
for
(
let
shortcut
of
shouldPin
)
{
await
tryToInsertSearchShortcut
(
shortcut
)
;
}
if
(
newInsertedShortcuts
.
length
)
{
this
.
store
.
dispatch
(
ac
.
SetPref
(
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
prevInsertedShortcuts
.
concat
(
newInsertedShortcuts
)
.
join
(
"
"
)
)
)
;
return
true
;
}
}
return
false
;
}
async
getLinksWithDefaults
(
isStartup
=
false
)
{
const
prefValues
=
this
.
store
.
getState
(
)
.
Prefs
.
values
;
const
numItems
=
prefValues
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
;
const
searchShortcutsExperiment
=
!
this
.
_useRemoteSetting
&
&
prefValues
[
SEARCH_SHORTCUTS_EXPERIMENT
]
;
await
Services
.
search
.
init
(
)
;
let
frecent
=
[
]
;
const
cache
=
await
this
.
frecentCache
.
request
(
{
numItems
:
numItems
+
SEARCH_FILTERS
.
length
+
1
topsiteFrecency
:
FRECENCY_THRESHOLD
}
)
;
for
(
let
link
of
cache
)
{
const
hostname
=
shortURL
(
link
)
;
if
(
!
this
.
shouldFilterSearchTile
(
hostname
)
)
{
frecent
.
push
(
{
.
.
.
(
searchShortcutsExperiment
?
await
this
.
topSiteToSearchTopSite
(
link
)
:
link
)
hostname
}
)
;
}
}
let
date
=
new
Date
(
)
;
let
pad
=
number
=
>
number
.
toString
(
)
.
padStart
(
2
"
0
"
)
;
let
yyyymmddhh
=
String
(
date
.
getFullYear
(
)
)
+
pad
(
date
.
getMonth
(
)
+
1
)
+
pad
(
date
.
getDate
(
)
)
+
pad
(
date
.
getHours
(
)
)
;
let
notBlockedDefaultSites
=
[
]
;
let
sponsored
=
[
]
;
for
(
let
link
of
DEFAULT_TOP_SITES
)
{
if
(
this
.
shouldFilterSearchTile
(
link
.
hostname
)
)
{
continue
;
}
let
isBlocked
=
NewTabUtils
.
blockedLinks
.
isBlocked
(
{
url
:
link
.
url
}
)
;
let
url_end
;
let
url_start
;
if
(
this
.
_useRemoteSetting
)
{
[
url_start
url_end
]
=
link
.
url
.
split
(
"
%
YYYYMMDDHH
%
"
)
;
}
if
(
typeof
url_end
=
=
=
"
string
"
)
{
link
=
{
.
.
.
link
original_url
:
link
.
url
url
:
url_start
+
yyyymmddhh
+
url_end
}
;
if
(
link
.
url_urlbar
)
{
link
.
url_urlbar
=
link
.
url_urlbar
.
replace
(
"
%
YYYYMMDDHH
%
"
yyyymmddhh
)
;
}
let
frecentIndex
=
frecent
.
findIndex
(
frecentLink
=
>
frecentLink
.
url
=
=
=
link
.
original_url
|
|
(
frecentLink
.
url
.
startsWith
(
url_start
)
&
&
frecentLink
.
url
.
endsWith
(
url_end
)
&
&
frecentLink
.
url
.
length
=
=
=
link
.
url
.
length
)
)
;
if
(
frecentIndex
>
-
1
)
{
if
(
isBlocked
)
{
frecent
.
splice
(
frecentIndex
1
)
;
}
else
{
frecent
[
frecentIndex
]
.
original_url
=
link
.
original_url
;
frecent
[
frecentIndex
]
.
url
=
link
.
url
;
}
}
}
if
(
isBlocked
)
{
continue
;
}
const
searchProvider
=
getSearchProvider
(
shortURL
(
link
)
)
;
if
(
searchProvider
&
&
NewTabUtils
.
blockedLinks
.
isBlocked
(
{
url
:
searchProvider
.
url
}
)
)
{
continue
;
}
if
(
link
.
sponsored_position
)
{
if
(
!
prefValues
[
SHOW_SPONSORED_PREF
]
)
{
continue
;
}
sponsored
[
link
.
sponsored_position
-
1
]
=
link
;
}
else
{
notBlockedDefaultSites
.
push
(
searchShortcutsExperiment
?
await
this
.
topSiteToSearchTopSite
(
link
)
:
link
)
;
}
}
let
plainPinned
=
await
this
.
pinnedCache
.
request
(
)
;
if
(
await
this
.
_maybeInsertSearchShortcuts
(
plainPinned
)
)
{
this
.
pinnedCache
.
expire
(
)
;
plainPinned
=
await
this
.
pinnedCache
.
request
(
)
;
}
const
pinned
=
await
Promise
.
all
(
plainPinned
.
map
(
async
link
=
>
{
if
(
!
link
)
{
return
link
;
}
const
finder
=
other
=
>
other
.
url
=
=
=
link
.
url
;
const
frecentSite
=
frecent
.
find
(
finder
)
;
if
(
frecentSite
&
&
link
.
customScreenshotURL
)
{
delete
frecentSite
.
screenshot
;
}
const
copy
=
Object
.
assign
(
{
}
frecentSite
|
|
{
isDefault
:
!
!
notBlockedDefaultSites
.
find
(
finder
)
}
link
{
hostname
:
shortURL
(
link
)
}
{
searchTopSite
:
!
!
link
.
searchTopSite
}
)
;
if
(
!
copy
.
favicon
)
{
try
{
NewTabUtils
.
activityStreamProvider
.
_faviconBytesToDataURI
(
await
NewTabUtils
.
activityStreamProvider
.
_addFavicons
(
[
copy
]
)
)
;
for
(
const
prop
of
PINNED_FAVICON_PROPS_TO_MIGRATE
)
{
copy
.
__sharedCache
.
updateLink
(
prop
copy
[
prop
]
)
;
}
}
catch
(
e
)
{
}
}
return
copy
;
}
)
)
;
const
[
dedupedSponsored
dedupedFrecent
dedupedDefaults
]
=
this
.
dedupe
.
group
(
pinned
sponsored
frecent
notBlockedDefaultSites
)
;
const
dedupedUnpinned
=
[
.
.
.
dedupedFrecent
.
.
.
dedupedDefaults
]
;
const
checkedAdult
=
prefValues
.
filterAdult
?
filterAdult
(
dedupedUnpinned
)
:
dedupedUnpinned
;
let
withPinned
=
insertPinned
(
checkedAdult
pinned
)
;
dedupedSponsored
.
forEach
(
link
=
>
{
if
(
!
link
)
{
return
;
}
let
index
=
link
.
sponsored_position
-
1
;
if
(
index
>
withPinned
.
length
)
{
withPinned
[
index
]
=
link
;
}
else
{
withPinned
.
splice
(
index
0
link
)
;
}
}
)
;
withPinned
=
withPinned
.
slice
(
0
numItems
)
;
for
(
const
link
of
withPinned
)
{
if
(
link
)
{
if
(
link
.
customScreenshotURL
)
{
this
.
_fetchScreenshot
(
link
link
.
customScreenshotURL
isStartup
)
;
}
else
if
(
link
.
searchTopSite
&
&
!
link
.
isDefault
)
{
await
this
.
_attachTippyTopIconForSearchShortcut
(
link
link
.
label
)
;
}
else
{
this
.
_fetchIcon
(
link
isStartup
)
;
}
delete
link
.
__sharedCache
;
link
.
typedBonus
=
true
;
if
(
ATTRIBUTION_REQUEST_SITES
.
includes
(
link
.
original_url
|
|
link
.
url
)
)
{
link
.
sendAttributionRequest
=
true
;
}
}
}
this
.
_linksWithDefaults
=
withPinned
;
return
withPinned
;
}
async
_attachTippyTopIconForSearchShortcut
(
link
keyword
)
{
if
(
[
"
\
u044F
\
u043D
\
u0434
\
u0435
\
u043A
\
u0441
"
"
yandex
"
]
.
includes
(
keyword
)
)
{
let
site
=
{
url
:
link
.
url
}
;
site
.
url
=
(
await
getSearchFormURL
(
keyword
)
)
|
|
site
.
url
;
this
.
_tippyTopProvider
.
processSite
(
site
)
;
link
.
tippyTopIcon
=
site
.
tippyTopIcon
;
link
.
smallFavicon
=
site
.
smallFavicon
;
link
.
backgroundColor
=
site
.
backgroundColor
;
}
else
{
this
.
_tippyTopProvider
.
processSite
(
link
)
;
}
}
async
refresh
(
options
=
{
}
)
{
if
(
!
this
.
_startedUp
&
&
!
options
.
isStartup
)
{
return
;
}
this
.
_startedUp
=
true
;
if
(
!
this
.
_tippyTopProvider
.
initialized
)
{
await
this
.
_tippyTopProvider
.
init
(
)
;
}
const
links
=
await
this
.
getLinksWithDefaults
(
{
isStartup
:
options
.
isStartup
}
)
;
const
newAction
=
{
type
:
at
.
TOP_SITES_UPDATED
data
:
{
links
}
}
;
let
storedPrefs
;
try
{
storedPrefs
=
(
await
this
.
_storage
.
get
(
SECTION_ID
)
)
|
|
{
}
;
}
catch
(
e
)
{
storedPrefs
=
{
}
;
Cu
.
reportError
(
"
Problem
getting
stored
prefs
for
TopSites
"
)
;
}
newAction
.
data
.
pref
=
getDefaultOptions
(
storedPrefs
)
;
if
(
options
.
isStartup
)
{
newAction
.
meta
=
{
isStartup
:
true
}
;
}
if
(
options
.
broadcast
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
newAction
)
)
;
}
else
{
this
.
store
.
dispatch
(
ac
.
AlsoToPreloaded
(
newAction
)
)
;
}
}
async
updateCustomSearchShortcuts
(
isStartup
=
false
)
{
if
(
!
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SEARCH_SHORTCUTS_EXPERIMENT
]
)
{
return
;
}
if
(
!
this
.
_tippyTopProvider
.
initialized
)
{
await
this
.
_tippyTopProvider
.
init
(
)
;
}
let
searchShortcuts
=
[
]
;
for
(
const
engine
of
await
Services
.
search
.
getDefaultEngines
(
)
)
{
const
shortcut
=
CUSTOM_SEARCH_SHORTCUTS
.
find
(
s
=
>
engine
.
aliases
.
includes
(
s
.
keyword
)
)
;
if
(
shortcut
)
{
let
clone
=
{
.
.
.
shortcut
}
;
await
this
.
_attachTippyTopIconForSearchShortcut
(
clone
clone
.
keyword
)
;
searchShortcuts
.
push
(
clone
)
;
}
}
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
UPDATE_SEARCH_SHORTCUTS
data
:
{
searchShortcuts
}
meta
:
{
isStartup
}
}
)
)
;
}
async
topSiteToSearchTopSite
(
site
)
{
const
searchProvider
=
getSearchProvider
(
shortURL
(
site
)
)
;
if
(
!
searchProvider
|
|
!
(
await
checkHasSearchEngine
(
searchProvider
.
keyword
)
)
)
{
return
site
;
}
return
{
.
.
.
site
searchTopSite
:
true
label
:
searchProvider
.
keyword
}
;
}
async
_fetchIcon
(
link
isStartup
=
false
)
{
if
(
link
.
favicon
&
&
link
.
faviconSize
>
=
MIN_FAVICON_SIZE
)
{
return
;
}
this
.
_tippyTopProvider
.
processSite
(
link
)
;
if
(
link
.
tippyTopIcon
)
{
return
;
}
this
.
_requestRichIcon
(
link
.
url
)
;
await
this
.
_fetchScreenshot
(
link
link
.
url
isStartup
)
;
}
async
_fetchScreenshot
(
link
url
isStartup
=
false
)
{
if
(
link
.
screenshot
|
|
!
this
.
store
.
getState
(
)
.
Prefs
.
values
[
SHOWN_ON_NEWTAB_PREF
]
)
{
return
;
}
await
Screenshots
.
maybeCacheScreenshot
(
link
url
"
screenshot
"
screenshot
=
>
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
data
:
{
screenshot
url
:
link
.
url
}
type
:
at
.
SCREENSHOT_UPDATED
meta
:
{
isStartup
}
}
)
)
)
;
}
async
getScreenshotPreview
(
url
target
)
{
const
preview
=
(
await
Screenshots
.
getScreenshotForURL
(
url
)
)
|
|
"
"
;
this
.
store
.
dispatch
(
ac
.
OnlyToOneContent
(
{
data
:
{
url
preview
}
type
:
at
.
PREVIEW_RESPONSE
}
target
)
)
;
}
_requestRichIcon
(
url
)
{
this
.
store
.
dispatch
(
{
type
:
at
.
RICH_ICON_MISSING
data
:
{
url
}
}
)
;
}
updateSectionPrefs
(
collapsed
)
{
this
.
store
.
dispatch
(
ac
.
BroadcastToContent
(
{
type
:
at
.
TOP_SITES_PREFS_UPDATED
data
:
{
pref
:
collapsed
}
}
)
)
;
}
_broadcastPinnedSitesUpdated
(
)
{
this
.
pinnedCache
.
expire
(
)
;
this
.
refresh
(
{
broadcast
:
true
}
)
;
}
async
_pinSiteAt
(
{
customScreenshotURL
label
url
searchTopSite
}
index
)
{
const
toPin
=
{
url
}
;
if
(
label
)
{
toPin
.
label
=
label
;
}
if
(
customScreenshotURL
)
{
toPin
.
customScreenshotURL
=
customScreenshotURL
;
}
if
(
searchTopSite
)
{
toPin
.
searchTopSite
=
searchTopSite
;
}
NewTabUtils
.
pinnedLinks
.
pin
(
toPin
index
)
;
await
this
.
_clearLinkCustomScreenshot
(
{
customScreenshotURL
url
}
)
;
}
async
_clearLinkCustomScreenshot
(
site
)
{
if
(
site
.
customScreenshotURL
!
=
=
undefined
)
{
const
pinned
=
await
this
.
pinnedCache
.
request
(
)
;
const
link
=
pinned
.
find
(
pin
=
>
pin
&
&
pin
.
url
=
=
=
site
.
url
)
;
if
(
link
&
&
link
.
customScreenshotURL
!
=
=
site
.
customScreenshotURL
)
{
link
.
__sharedCache
.
updateLink
(
"
screenshot
"
undefined
)
;
}
}
}
async
pin
(
action
)
{
let
{
site
index
}
=
action
.
data
;
index
=
this
.
_adjustPinIndexForSponsoredLinks
(
site
index
)
;
if
(
index
>
=
0
)
{
await
this
.
_pinSiteAt
(
site
index
)
;
this
.
_broadcastPinnedSitesUpdated
(
)
;
}
else
{
if
(
index
=
=
=
-
1
)
{
NewTabUtils
.
blockedLinks
.
unblock
(
{
url
:
site
.
url
}
)
;
this
.
frecentCache
.
expire
(
)
;
}
this
.
insert
(
action
)
;
}
}
unpin
(
action
)
{
const
{
site
}
=
action
.
data
;
NewTabUtils
.
pinnedLinks
.
unpin
(
site
)
;
this
.
_broadcastPinnedSitesUpdated
(
)
;
}
unpinAllSearchShortcuts
(
)
{
Services
.
prefs
.
clearUserPref
(
browser
.
newtabpage
.
activity
-
stream
.
{
SEARCH_SHORTCUTS_HAVE_PINNED_PREF
}
)
;
for
(
let
pinnedLink
of
NewTabUtils
.
pinnedLinks
.
links
)
{
if
(
pinnedLink
&
&
pinnedLink
.
searchTopSite
)
{
NewTabUtils
.
pinnedLinks
.
unpin
(
pinnedLink
)
;
}
}
this
.
pinnedCache
.
expire
(
)
;
}
_adjustPinIndexForSponsoredLinks
(
site
index
)
{
if
(
!
this
.
_linksWithDefaults
)
{
return
index
;
}
let
adjustedIndex
=
index
;
for
(
let
i
=
0
;
i
<
index
;
i
+
+
)
{
if
(
this
.
_linksWithDefaults
[
i
]
?
.
sponsored_position
&
&
this
.
_linksWithDefaults
[
i
]
?
.
url
!
=
=
site
.
url
)
{
adjustedIndex
-
-
;
}
}
return
adjustedIndex
;
}
_insertPin
(
site
originalIndex
draggedFromIndex
)
{
let
index
=
this
.
_adjustPinIndexForSponsoredLinks
(
site
originalIndex
)
;
const
topSitesCount
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
;
if
(
index
>
=
topSitesCount
)
{
return
;
}
let
pinned
=
NewTabUtils
.
pinnedLinks
.
links
;
if
(
!
pinned
[
index
]
)
{
this
.
_pinSiteAt
(
site
index
)
;
}
else
{
pinned
[
draggedFromIndex
]
=
null
;
let
holeIndex
=
index
;
const
indexStep
=
index
>
draggedFromIndex
?
-
1
:
1
;
while
(
pinned
[
holeIndex
]
)
{
holeIndex
+
=
indexStep
;
}
if
(
holeIndex
>
=
topSitesCount
|
|
holeIndex
<
0
)
{
holeIndex
=
topSitesCount
-
1
;
}
const
shiftingStep
=
holeIndex
>
index
?
-
1
:
1
;
while
(
holeIndex
!
=
=
index
)
{
const
nextIndex
=
holeIndex
+
shiftingStep
;
this
.
_pinSiteAt
(
pinned
[
nextIndex
]
holeIndex
)
;
holeIndex
=
nextIndex
;
}
this
.
_pinSiteAt
(
site
index
)
;
}
}
async
insert
(
action
)
{
let
{
index
}
=
action
.
data
;
if
(
!
(
index
>
0
)
)
{
index
=
0
;
}
this
.
_insertPin
(
action
.
data
.
site
index
action
.
data
.
draggedFromIndex
!
=
=
undefined
?
action
.
data
.
draggedFromIndex
:
this
.
store
.
getState
(
)
.
Prefs
.
values
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
)
;
await
this
.
_clearLinkCustomScreenshot
(
action
.
data
.
site
)
;
this
.
_broadcastPinnedSitesUpdated
(
)
;
}
updatePinnedSearchShortcuts
(
{
addedShortcuts
deletedShortcuts
}
)
{
deletedShortcuts
.
forEach
(
(
{
url
}
)
=
>
{
NewTabUtils
.
pinnedLinks
.
unpin
(
{
url
}
)
;
}
)
;
const
numberOfSlots
=
this
.
store
.
getState
(
)
.
Prefs
.
values
[
ROWS_PREF
]
*
TOP_SITES_MAX_SITES_PER_ROW
;
addedShortcuts
.
forEach
(
shortcut
=
>
{
let
index
=
NewTabUtils
.
pinnedLinks
.
links
.
findIndex
(
link
=
>
!
link
)
;
if
(
index
<
0
&
&
NewTabUtils
.
pinnedLinks
.
links
.
length
+
1
<
numberOfSlots
)
{
index
=
NewTabUtils
.
pinnedLinks
.
links
.
length
;
}
if
(
index
>
=
0
)
{
NewTabUtils
.
pinnedLinks
.
pin
(
shortcut
index
)
;
}
else
{
this
.
_insertPin
(
shortcut
0
numberOfSlots
)
;
}
}
)
;
this
.
_broadcastPinnedSitesUpdated
(
)
;
}
onAction
(
action
)
{
switch
(
action
.
type
)
{
case
at
.
INIT
:
this
.
init
(
)
;
this
.
updateCustomSearchShortcuts
(
true
)
;
break
;
case
at
.
SYSTEM_TICK
:
this
.
refresh
(
{
broadcast
:
false
}
)
;
break
;
case
at
.
PLACES_HISTORY_CLEARED
:
case
at
.
PLACES_LINK_DELETED
:
this
.
frecentCache
.
expire
(
)
;
this
.
refresh
(
{
broadcast
:
true
}
)
;
break
;
case
at
.
PLACES_LINKS_CHANGED
:
this
.
frecentCache
.
expire
(
)
;
this
.
refresh
(
{
broadcast
:
false
}
)
;
break
;
case
at
.
PLACES_LINK_BLOCKED
:
this
.
frecentCache
.
expire
(
)
;
this
.
pinnedCache
.
expire
(
)
;
this
.
refresh
(
{
broadcast
:
true
}
)
;
break
;
case
at
.
PREF_CHANGED
:
switch
(
action
.
data
.
name
)
{
case
DEFAULT_SITES_PREF
:
if
(
!
this
.
_useRemoteSetting
)
{
this
.
refreshDefaults
(
action
.
data
.
value
)
;
}
break
;
case
ROWS_PREF
:
case
FILTER_DEFAULT_SEARCH_PREF
:
case
SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF
:
case
SHOW_SPONSORED_PREF
:
this
.
refresh
(
{
broadcast
:
true
}
)
;
break
;
case
SEARCH_SHORTCUTS_EXPERIMENT
:
if
(
action
.
data
.
value
)
{
this
.
updateCustomSearchShortcuts
(
)
;
}
else
{
this
.
unpinAllSearchShortcuts
(
)
;
}
this
.
refresh
(
{
broadcast
:
true
}
)
;
}
break
;
case
at
.
UPDATE_SECTION_PREFS
:
if
(
action
.
data
.
id
=
=
=
SECTION_ID
)
{
this
.
updateSectionPrefs
(
action
.
data
.
value
)
;
}
break
;
case
at
.
PREFS_INITIAL_VALUES
:
if
(
!
this
.
_useRemoteSetting
)
{
this
.
refreshDefaults
(
action
.
data
[
DEFAULT_SITES_PREF
]
)
;
}
break
;
case
at
.
TOP_SITES_PIN
:
this
.
pin
(
action
)
;
break
;
case
at
.
TOP_SITES_UNPIN
:
this
.
unpin
(
action
)
;
break
;
case
at
.
TOP_SITES_INSERT
:
this
.
insert
(
action
)
;
break
;
case
at
.
PREVIEW_REQUEST
:
this
.
getScreenshotPreview
(
action
.
data
.
url
action
.
meta
.
fromTarget
)
;
break
;
case
at
.
UPDATE_PINNED_SEARCH_SHORTCUTS
:
this
.
updatePinnedSearchShortcuts
(
action
.
data
)
;
break
;
case
at
.
UNINIT
:
this
.
uninit
(
)
;
break
;
}
}
}
;
this
.
DEFAULT_TOP_SITES
=
DEFAULT_TOP_SITES
;
const
EXPORTED_SYMBOLS
=
[
"
TopSitesFeed
"
"
DEFAULT_TOP_SITES
"
]
;
