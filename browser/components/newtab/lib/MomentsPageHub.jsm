"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
setInterval
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
clearInterval
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
const
SYSTEM_TICK_INTERVAL
=
5
*
60
*
1000
;
const
HOMEPAGE_OVERRIDE_PREF
=
"
browser
.
startup
.
homepage_override
.
once
"
;
const
REACH_EVENT_CATEGORY
=
"
messaging_experiments
"
;
const
REACH_EVENT_METHOD
=
"
reach
"
;
const
REACH_EVENT_OBJECT
=
"
moments_page
"
;
class
_MomentsPageHub
{
constructor
(
)
{
this
.
id
=
"
moments
-
page
-
hub
"
;
this
.
state
=
{
}
;
this
.
checkHomepageOverridePref
=
this
.
checkHomepageOverridePref
.
bind
(
this
)
;
this
.
_initialized
=
false
;
}
async
init
(
waitForInitialized
{
handleMessageRequest
addImpression
blockMessageById
sendTelemetry
}
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_handleMessageRequest
=
handleMessageRequest
;
this
.
_addImpression
=
addImpression
;
this
.
_blockMessageById
=
blockMessageById
;
this
.
_sendTelemetry
=
sendTelemetry
;
await
waitForInitialized
;
this
.
messageRequest
(
{
triggerId
:
"
momentsUpdate
"
template
:
"
update_action
"
}
)
;
const
_intervalId
=
setInterval
(
(
)
=
>
this
.
checkHomepageOverridePref
(
)
SYSTEM_TICK_INTERVAL
)
;
this
.
state
=
{
_intervalId
}
;
}
_sendPing
(
ping
)
{
this
.
_sendTelemetry
(
{
type
:
"
MOMENTS_PAGE_TELEMETRY
"
data
:
{
action
:
"
moments_user_event
"
.
.
.
ping
}
}
)
;
}
sendUserEventTelemetry
(
message
)
{
this
.
_sendPing
(
{
message_id
:
message
.
id
bucket_id
:
message
.
id
event
:
"
MOMENTS_PAGE_SET
"
}
)
;
}
getExpirationDate
(
expireDelta
)
{
return
Date
.
now
(
)
+
expireDelta
;
}
executeAction
(
message
)
{
const
{
id
data
}
=
message
.
content
.
action
;
switch
(
id
)
{
case
"
moments
-
wnp
"
:
const
{
url
expireDelta
}
=
data
;
let
{
expire
}
=
data
;
if
(
!
expire
)
{
expire
=
this
.
getExpirationDate
(
expireDelta
)
;
}
Services
.
prefs
.
setStringPref
(
HOMEPAGE_OVERRIDE_PREF
JSON
.
stringify
(
{
message_id
:
message
.
id
url
expire
}
)
)
;
this
.
sendUserEventTelemetry
(
message
)
;
this
.
_addImpression
(
message
)
;
this
.
_blockMessageById
(
message
.
id
)
;
break
;
}
}
_recordReachEvent
(
message
)
{
const
extra
=
{
branches
:
message
.
branchSlug
}
;
Services
.
telemetry
.
recordEvent
(
REACH_EVENT_CATEGORY
REACH_EVENT_METHOD
REACH_EVENT_OBJECT
message
.
experimentSlug
extra
)
;
}
async
messageRequest
(
{
triggerId
template
}
)
{
const
telemetryObject
=
{
triggerId
}
;
TelemetryStopwatch
.
start
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
const
messages
=
await
this
.
_handleMessageRequest
(
{
triggerId
template
returnAll
:
true
}
)
;
TelemetryStopwatch
.
finish
(
"
MS_MESSAGE_REQUEST_TIME_MS
"
telemetryObject
)
;
const
nonReachMessages
=
[
]
;
for
(
const
message
of
messages
)
{
if
(
message
.
forReachEvent
)
{
if
(
!
message
.
forReachEvent
.
sent
)
{
this
.
_recordReachEvent
(
message
)
;
message
.
forReachEvent
.
sent
=
true
;
}
}
else
{
nonReachMessages
.
push
(
message
)
;
}
}
if
(
nonReachMessages
.
length
)
{
this
.
executeAction
(
nonReachMessages
[
0
]
)
;
}
}
checkHomepageOverridePref
(
)
{
this
.
messageRequest
(
{
triggerId
:
"
momentsUpdate
"
template
:
"
update_action
"
}
)
;
}
uninit
(
)
{
clearInterval
(
this
.
state
.
_intervalId
)
;
this
.
state
=
{
}
;
this
.
_initialized
=
false
;
}
}
const
MomentsPageHub
=
new
_MomentsPageHub
(
)
;
const
EXPORTED_SYMBOLS
=
[
"
_MomentsPageHub
"
"
MomentsPageHub
"
]
;
