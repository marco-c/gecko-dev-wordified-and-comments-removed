"
use
strict
"
;
const
{
actionTypes
:
at
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
sys
.
mjs
"
)
;
const
{
shortURL
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
ShortURL
.
jsm
"
)
;
const
{
SectionsManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
SectionsManager
.
jsm
"
)
;
const
{
TOP_SITES_DEFAULT_ROWS
TOP_SITES_MAX_SITES_PER_ROW
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
common
/
Reducers
.
sys
.
mjs
"
)
;
const
{
Dedupe
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
common
/
Dedupe
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
FilterAdult
"
"
resource
:
/
/
activity
-
stream
/
lib
/
FilterAdult
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
LinksCache
"
"
resource
:
/
/
activity
-
stream
/
lib
/
LinksCache
.
jsm
"
)
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
NewTabUtils
:
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
sys
.
mjs
"
PageThumbs
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
Screenshots
"
"
resource
:
/
/
activity
-
stream
/
lib
/
Screenshots
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
DownloadsManager
"
"
resource
:
/
/
activity
-
stream
/
lib
/
DownloadsManager
.
jsm
"
)
;
const
HIGHLIGHTS_MAX_LENGTH
=
16
;
const
MANY_EXTRA_LENGTH
=
HIGHLIGHTS_MAX_LENGTH
*
5
+
TOP_SITES_DEFAULT_ROWS
*
TOP_SITES_MAX_SITES_PER_ROW
;
const
SECTION_ID
=
"
highlights
"
;
const
SYNC_BOOKMARKS_FINISHED_EVENT
=
"
weave
:
engine
:
sync
:
applied
"
;
const
BOOKMARKS_RESTORE_SUCCESS_EVENT
=
"
bookmarks
-
restore
-
success
"
;
const
BOOKMARKS_RESTORE_FAILED_EVENT
=
"
bookmarks
-
restore
-
failed
"
;
const
RECENT_DOWNLOAD_THRESHOLD
=
36
*
60
*
60
*
1000
;
class
HighlightsFeed
{
constructor
(
)
{
this
.
dedupe
=
new
Dedupe
(
this
.
_dedupeKey
)
;
this
.
linksCache
=
new
lazy
.
LinksCache
(
lazy
.
NewTabUtils
.
activityStreamLinks
"
getHighlights
"
[
"
image
"
]
)
;
lazy
.
PageThumbs
.
addExpirationFilter
(
this
)
;
this
.
downloadsManager
=
new
lazy
.
DownloadsManager
(
)
;
}
_dedupeKey
(
site
)
{
return
(
site
&
&
(
site
.
pocket_id
|
|
site
.
type
=
=
=
"
bookmark
"
|
|
site
.
type
=
=
=
"
download
"
?
{
}
:
site
.
url
)
)
;
}
init
(
)
{
Services
.
obs
.
addObserver
(
this
SYNC_BOOKMARKS_FINISHED_EVENT
)
;
Services
.
obs
.
addObserver
(
this
BOOKMARKS_RESTORE_SUCCESS_EVENT
)
;
Services
.
obs
.
addObserver
(
this
BOOKMARKS_RESTORE_FAILED_EVENT
)
;
SectionsManager
.
onceInitialized
(
this
.
postInit
.
bind
(
this
)
)
;
}
postInit
(
)
{
SectionsManager
.
enableSection
(
SECTION_ID
true
)
;
this
.
fetchHighlights
(
{
broadcast
:
true
isStartup
:
true
}
)
;
this
.
downloadsManager
.
init
(
this
.
store
)
;
}
uninit
(
)
{
SectionsManager
.
disableSection
(
SECTION_ID
)
;
lazy
.
PageThumbs
.
removeExpirationFilter
(
this
)
;
Services
.
obs
.
removeObserver
(
this
SYNC_BOOKMARKS_FINISHED_EVENT
)
;
Services
.
obs
.
removeObserver
(
this
BOOKMARKS_RESTORE_SUCCESS_EVENT
)
;
Services
.
obs
.
removeObserver
(
this
BOOKMARKS_RESTORE_FAILED_EVENT
)
;
}
observe
(
subject
topic
data
)
{
const
manyBookmarksChanged
=
(
topic
=
=
=
SYNC_BOOKMARKS_FINISHED_EVENT
&
&
data
=
=
=
"
bookmarks
"
)
|
|
topic
=
=
=
BOOKMARKS_RESTORE_SUCCESS_EVENT
|
|
topic
=
=
=
BOOKMARKS_RESTORE_FAILED_EVENT
;
if
(
manyBookmarksChanged
)
{
this
.
fetchHighlights
(
{
broadcast
:
true
}
)
;
}
}
filterForThumbnailExpiration
(
callback
)
{
const
state
=
this
.
store
.
getState
(
)
.
Sections
.
find
(
section
=
>
section
.
id
=
=
=
SECTION_ID
)
;
callback
(
state
&
&
state
.
initialized
?
state
.
rows
.
reduce
(
(
acc
site
)
=
>
{
acc
.
push
(
site
.
url
)
;
if
(
site
.
preview_image_url
)
{
acc
.
push
(
site
.
preview_image_url
)
;
}
return
acc
;
}
[
]
)
:
[
]
)
;
}
_orderHighlights
(
pages
)
{
const
splitHighlights
=
{
chronologicalCandidates
:
[
]
visited
:
[
]
}
;
for
(
let
page
of
pages
)
{
if
(
page
.
type
=
=
=
"
history
"
)
{
splitHighlights
.
visited
.
push
(
page
)
;
}
else
{
splitHighlights
.
chronologicalCandidates
.
push
(
page
)
;
}
}
return
splitHighlights
.
chronologicalCandidates
.
sort
(
(
a
b
)
=
>
a
.
date_added
<
b
.
date_added
)
.
concat
(
splitHighlights
.
visited
)
;
}
async
fetchHighlights
(
options
=
{
}
)
{
if
(
(
!
this
.
store
.
getState
(
)
.
TopSites
.
initialized
&
&
this
.
store
.
getState
(
)
.
Prefs
.
values
[
"
feeds
.
system
.
topsites
"
]
&
&
this
.
store
.
getState
(
)
.
Prefs
.
values
[
"
feeds
.
topsites
"
]
)
|
|
!
this
.
store
.
getState
(
)
.
Sections
.
length
)
{
return
;
}
if
(
options
.
broadcast
)
{
this
.
linksCache
.
expire
(
)
;
}
const
manyPages
=
await
this
.
linksCache
.
request
(
{
numItems
:
MANY_EXTRA_LENGTH
excludeBookmarks
:
!
this
.
store
.
getState
(
)
.
Prefs
.
values
[
"
section
.
highlights
.
includeBookmarks
"
]
excludeHistory
:
!
this
.
store
.
getState
(
)
.
Prefs
.
values
[
"
section
.
highlights
.
includeVisited
"
]
excludePocket
:
!
this
.
store
.
getState
(
)
.
Prefs
.
values
[
"
section
.
highlights
.
includePocket
"
]
}
)
;
if
(
this
.
store
.
getState
(
)
.
Prefs
.
values
[
"
section
.
highlights
.
includeDownloads
"
]
)
{
let
results
=
await
this
.
downloadsManager
.
getDownloads
(
RECENT_DOWNLOAD_THRESHOLD
{
numItems
:
1
onlySucceeded
:
true
onlyExists
:
true
}
)
;
if
(
results
.
length
)
{
manyPages
.
push
(
{
.
.
.
results
[
0
]
type
:
"
download
"
}
)
;
}
}
const
orderedPages
=
this
.
_orderHighlights
(
manyPages
)
;
const
checkedAdult
=
lazy
.
FilterAdult
.
filter
(
orderedPages
)
;
const
[
deduped
]
=
this
.
dedupe
.
group
(
this
.
store
.
getState
(
)
.
TopSites
.
rows
checkedAdult
)
;
const
highlights
=
[
]
;
const
hosts
=
new
Set
(
)
;
for
(
const
page
of
deduped
)
{
const
hostname
=
shortURL
(
page
)
;
if
(
page
.
type
=
=
=
"
history
"
&
&
hosts
.
has
(
hostname
)
)
{
continue
;
}
if
(
!
page
.
image
&
&
page
.
type
!
=
=
"
download
"
)
{
this
.
fetchImage
(
page
options
.
isStartup
)
;
}
if
(
page
.
type
=
=
=
"
history
"
&
&
page
.
bookmarkGuid
&
&
this
.
store
.
getState
(
)
.
Prefs
.
values
[
"
section
.
highlights
.
includeBookmarks
"
]
)
{
page
.
type
=
"
bookmark
"
;
}
Object
.
assign
(
page
{
hasImage
:
page
.
type
!
=
=
"
download
"
hostname
type
:
page
.
type
pocket_id
:
page
.
pocket_id
}
)
;
highlights
.
push
(
page
)
;
hosts
.
add
(
hostname
)
;
delete
page
.
__sharedCache
;
if
(
highlights
.
length
=
=
=
HIGHLIGHTS_MAX_LENGTH
)
{
break
;
}
}
const
{
initialized
}
=
this
.
store
.
getState
(
)
.
Sections
.
find
(
section
=
>
section
.
id
=
=
=
SECTION_ID
)
;
const
shouldBroadcast
=
options
.
broadcast
|
|
!
initialized
;
SectionsManager
.
updateSection
(
SECTION_ID
{
rows
:
highlights
}
shouldBroadcast
options
.
isStartup
)
;
}
fetchImage
(
page
isStartup
=
false
)
{
const
{
preview_image_url
:
imageUrl
url
}
=
page
;
return
lazy
.
Screenshots
.
maybeCacheScreenshot
(
page
imageUrl
|
|
url
"
image
"
image
=
>
{
SectionsManager
.
updateSectionCard
(
SECTION_ID
url
{
image
}
true
isStartup
)
;
}
)
;
}
onAction
(
action
)
{
this
.
downloadsManager
.
onAction
(
action
)
;
switch
(
action
.
type
)
{
case
at
.
INIT
:
this
.
init
(
)
;
break
;
case
at
.
SYSTEM_TICK
:
case
at
.
TOP_SITES_UPDATED
:
this
.
fetchHighlights
(
{
broadcast
:
false
isStartup
:
!
!
action
.
meta
?
.
isStartup
}
)
;
break
;
case
at
.
PREF_CHANGED
:
if
(
action
.
data
.
name
.
startsWith
(
"
section
.
highlights
.
include
"
)
)
{
this
.
fetchHighlights
(
{
broadcast
:
true
}
)
;
}
break
;
case
at
.
PLACES_HISTORY_CLEARED
:
case
at
.
PLACES_LINK_BLOCKED
:
case
at
.
DOWNLOAD_CHANGED
:
case
at
.
POCKET_LINK_DELETED_OR_ARCHIVED
:
this
.
fetchHighlights
(
{
broadcast
:
true
}
)
;
break
;
case
at
.
PLACES_LINKS_CHANGED
:
case
at
.
PLACES_SAVED_TO_POCKET
:
this
.
linksCache
.
expire
(
)
;
this
.
fetchHighlights
(
{
broadcast
:
false
}
)
;
break
;
case
at
.
UNINIT
:
this
.
uninit
(
)
;
break
;
}
}
}
const
EXPORTED_SYMBOLS
=
[
"
HighlightsFeed
"
"
SECTION_ID
"
"
MANY_EXTRA_LENGTH
"
"
SYNC_BOOKMARKS_FINISHED_EVENT
"
"
BOOKMARKS_RESTORE_SUCCESS_EVENT
"
"
BOOKMARKS_RESTORE_FAILED_EVENT
"
]
;
