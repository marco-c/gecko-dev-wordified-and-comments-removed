"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
DEFAULT_TIME_SEGMENTS
=
[
{
"
id
"
:
"
hour
"
"
startTime
"
:
3600
"
endTime
"
:
0
"
weightPosition
"
:
1
}
{
"
id
"
:
"
day
"
"
startTime
"
:
86400
"
endTime
"
:
3600
"
weightPosition
"
:
0
.
75
}
{
"
id
"
:
"
week
"
"
startTime
"
:
604800
"
endTime
"
:
86400
"
weightPosition
"
:
0
.
5
}
{
"
id
"
:
"
weekPlus
"
"
startTime
"
:
0
"
endTime
"
:
604800
"
weightPosition
"
:
0
.
25
}
{
"
id
"
:
"
alltime
"
"
startTime
"
:
0
"
endTime
"
:
0
"
weightPosition
"
:
0
.
25
}
]
;
const
DEFAULT_PARAMETER_SETS
=
{
"
linear
-
frequency
"
:
{
"
recencyFactor
"
:
0
.
4
"
frequencyFactor
"
:
0
.
5
"
combinedDomainFactor
"
:
0
.
5
"
perfectFrequencyVisits
"
:
10
"
perfectCombinedDomainScore
"
:
2
"
multiDomainBoost
"
:
0
.
1
"
itemScoreFactor
"
:
0
}
}
;
const
DEFAULT_MAX_HISTORY_QUERY_RESULTS
=
1000
;
function
merge
(
.
.
.
args
)
{
return
Object
.
assign
.
apply
(
this
args
)
;
}
this
.
UserDomainAffinityProvider
=
class
UserDomainAffinityProvider
{
constructor
(
timeSegments
=
DEFAULT_TIME_SEGMENTS
parameterSets
=
DEFAULT_PARAMETER_SETS
maxHistoryQueryResults
=
DEFAULT_MAX_HISTORY_QUERY_RESULTS
version
scores
)
{
this
.
timeSegments
=
timeSegments
;
this
.
maxHistoryQueryResults
=
maxHistoryQueryResults
;
this
.
version
=
version
;
if
(
scores
)
{
this
.
parameterSets
=
parameterSets
;
this
.
scores
=
scores
;
}
else
{
this
.
parameterSets
=
this
.
prepareParameterSets
(
parameterSets
)
;
this
.
scores
=
this
.
calculateAllUserDomainAffinityScores
(
)
;
}
}
prepareParameterSets
(
ps
)
{
return
Object
.
keys
(
ps
)
.
map
(
k
=
>
(
{
[
k
]
:
merge
(
ps
[
k
]
{
timeSegmentWeights
:
this
.
calculateTimeSegmentWeights
(
ps
[
k
]
.
recencyFactor
)
}
)
}
)
)
.
reduce
(
(
acc
cur
)
=
>
merge
(
acc
cur
)
)
;
}
calculateTimeSegmentWeights
(
recencyFactor
)
{
return
this
.
timeSegments
.
reduce
(
(
acc
cur
)
=
>
merge
(
acc
(
{
[
cur
.
id
]
:
this
.
calculateScore
(
cur
.
weightPosition
1
recencyFactor
)
}
)
)
{
}
)
;
}
calculateAllUserDomainAffinityScores
(
)
{
return
this
.
timeSegments
.
map
(
ts
=
>
this
.
calculateUserDomainAffinityScores
(
ts
)
)
.
reduce
(
(
acc
cur
)
=
>
this
.
_combineScores
(
acc
cur
)
)
;
}
calculateUserDomainAffinityScores
(
ts
)
{
let
visits
=
this
.
queryVisits
(
ts
)
;
return
Object
.
keys
(
visits
)
.
reduce
(
(
acc
d
)
=
>
merge
(
acc
{
[
d
]
:
this
.
calculateScoresForParameterSets
(
ts
visits
[
d
]
)
}
)
{
}
)
;
}
calculateScoresForParameterSets
(
ts
vc
)
{
return
Object
.
keys
(
this
.
parameterSets
)
.
reduce
(
(
acc
ps
)
=
>
merge
(
acc
{
[
ps
]
:
this
.
calculateScoreForParameterSet
(
ts
vc
this
.
parameterSets
[
ps
]
)
}
)
{
}
)
;
}
calculateScoreForParameterSet
(
timeSegment
visitCount
parameterSet
)
{
return
this
.
calculateScore
(
visitCount
*
parameterSet
.
timeSegmentWeights
[
timeSegment
.
id
]
parameterSet
.
perfectFrequencyVisits
parameterSet
.
frequencyFactor
)
;
}
_combineScores
(
a
b
)
{
const
c
=
merge
(
{
}
a
b
)
;
return
Object
.
keys
(
c
)
.
reduce
(
(
acc
d
)
=
>
merge
(
acc
this
.
_combine
(
a
b
c
d
)
)
{
}
)
;
}
_combine
(
a
b
c
d
)
{
return
Object
.
keys
(
c
[
d
]
)
.
map
(
ps
=
>
(
{
[
d
]
:
{
[
ps
]
:
Math
.
min
(
1
(
(
a
[
d
]
&
&
a
[
d
]
[
ps
]
)
|
|
0
)
+
(
(
b
[
d
]
&
&
b
[
d
]
[
ps
]
)
|
|
0
)
)
}
}
)
)
.
reduce
(
(
acc
cur
)
=
>
(
{
[
d
]
:
merge
(
acc
[
d
]
cur
[
d
]
)
}
)
)
;
}
calculateScore
(
score
maxScore
factor
ease
=
2
)
{
let
a
=
0
;
let
x
=
Math
.
max
(
0
score
/
maxScore
)
;
if
(
x
>
=
1
)
{
return
1
;
}
if
(
factor
=
=
=
0
.
5
)
{
return
x
;
}
if
(
factor
<
0
.
5
)
{
a
=
(
factor
/
0
.
5
)
*
0
.
49
;
}
else
if
(
factor
>
0
.
5
)
{
a
=
1
+
(
factor
-
0
.
5
)
/
0
.
5
*
9
;
}
return
(
Math
.
pow
(
a
ease
*
x
)
-
1
)
/
(
Math
.
pow
(
a
ease
)
-
1
)
;
}
queryVisits
(
ts
)
{
const
visitCounts
=
{
}
;
const
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
const
wwwRegEx
=
/
^
www
\
.
/
;
query
.
beginTimeReference
=
query
.
TIME_RELATIVE_NOW
;
query
.
beginTime
=
(
ts
.
startTime
&
&
ts
.
startTime
!
=
=
0
)
?
-
(
ts
.
startTime
*
1000
*
1000
)
:
-
(
Date
.
now
(
)
*
1000
)
;
query
.
endTimeReference
=
query
.
TIME_RELATIVE_NOW
;
query
.
endTime
=
(
ts
.
endTime
&
&
ts
.
endTime
!
=
=
0
)
?
-
(
ts
.
endTime
*
1000
*
1000
)
:
0
;
const
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
sortingMode
=
options
.
SORT_BY_VISITCOUNT_DESCENDING
;
options
.
maxResults
=
this
.
maxHistoryQueryResults
;
const
{
root
}
=
PlacesUtils
.
history
.
executeQuery
(
query
options
)
;
root
.
containerOpen
=
true
;
for
(
let
i
=
0
;
i
<
root
.
childCount
;
i
+
+
)
{
let
node
=
root
.
getChild
(
i
)
;
let
host
=
Services
.
io
.
newURI
(
node
.
uri
)
.
host
.
replace
(
wwwRegEx
"
"
)
;
if
(
!
visitCounts
[
host
]
)
{
visitCounts
[
host
]
=
0
;
}
visitCounts
[
host
]
+
=
node
.
accessCount
;
}
root
.
containerOpen
=
false
;
return
visitCounts
;
}
calculateItemRelevanceScore
(
item
)
{
const
params
=
this
.
parameterSets
[
item
.
parameter_set
]
;
if
(
!
item
.
domain_affinities
|
|
!
params
)
{
return
item
.
item_score
;
}
const
scores
=
Object
.
keys
(
item
.
domain_affinities
)
.
reduce
(
(
acc
d
)
=
>
{
let
userDomainAffinityScore
=
this
.
scores
[
d
]
?
this
.
scores
[
d
]
[
item
.
parameter_set
]
:
false
;
if
(
userDomainAffinityScore
)
{
acc
.
combinedDomainScore
+
=
userDomainAffinityScore
*
item
.
domain_affinities
[
d
]
;
acc
.
matchingDomainsCount
+
+
;
}
return
acc
;
}
{
combinedDomainScore
:
0
matchingDomainsCount
:
0
}
)
;
const
boostedCombinedDomainScore
=
scores
.
combinedDomainScore
*
Math
.
pow
(
params
.
multiDomainBoost
+
1
scores
.
matchingDomainsCount
)
;
const
normalizedCombinedDomainScore
=
this
.
calculateScore
(
boostedCombinedDomainScore
params
.
perfectCombinedDomainScore
params
.
combinedDomainFactor
)
;
return
params
.
itemScoreFactor
*
(
item
.
item_score
-
normalizedCombinedDomainScore
)
+
normalizedCombinedDomainScore
;
}
getAffinities
(
)
{
return
{
timeSegments
:
this
.
timeSegments
parameterSets
:
this
.
parameterSets
maxHistoryQueryResults
:
this
.
maxHistoryQueryResults
version
:
this
.
version
scores
:
this
.
scores
}
;
}
}
;
const
EXPORTED_SYMBOLS
=
[
"
UserDomainAffinityProvider
"
]
;
