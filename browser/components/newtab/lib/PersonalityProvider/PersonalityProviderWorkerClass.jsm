"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PersonalityProviderWorker
"
]
;
const
PERSONALITY_PROVIDER_DIR
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
"
personality
-
provider
"
)
;
const
PersonalityProviderWorker
=
class
PersonalityProviderWorker
{
_getFileStr
(
filepath
)
{
const
binaryData
=
OS
.
File
.
read
(
filepath
)
;
const
gTextDecoder
=
new
TextDecoder
(
)
;
return
gTextDecoder
.
decode
(
binaryData
)
;
}
setBaseAttachmentsURL
(
url
)
{
this
.
baseAttachmentsURL
=
url
;
}
setInterestConfig
(
interestConfig
)
{
this
.
interestConfig
=
interestConfig
;
}
setInterestVector
(
interestVector
)
{
this
.
interestVector
=
interestVector
;
}
onSync
(
event
)
{
const
{
data
:
{
created
updated
deleted
}
}
=
event
;
const
toRemove
=
deleted
.
concat
(
updated
.
map
(
u
=
>
u
.
old
)
)
;
toRemove
.
map
(
record
=
>
this
.
deleteAttachment
(
record
)
)
;
const
toDownload
=
created
.
concat
(
updated
.
map
(
u
=
>
u
.
new
)
)
;
toDownload
.
map
(
record
=
>
this
.
maybeDownloadAttachment
(
record
)
)
;
}
maybeDownloadAttachment
(
record
retries
=
3
)
{
const
{
attachment
:
{
filename
size
}
}
=
record
;
OS
.
File
.
makeDir
(
PERSONALITY_PROVIDER_DIR
)
;
const
localFilePath
=
OS
.
Path
.
join
(
PERSONALITY_PROVIDER_DIR
filename
)
;
let
retry
=
0
;
while
(
retry
+
+
<
retries
&
&
(
!
OS
.
File
.
exists
(
localFilePath
)
|
|
OS
.
File
.
stat
(
localFilePath
)
.
size
!
=
=
size
)
)
{
this
.
_downloadAttachment
(
record
)
;
}
}
_downloadAttachment
(
record
)
{
const
{
attachment
:
{
location
filename
}
}
=
record
;
const
remoteFilePath
=
this
.
baseAttachmentsURL
+
location
;
const
localFilePath
=
OS
.
Path
.
join
(
PERSONALITY_PROVIDER_DIR
filename
)
;
const
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
remoteFilePath
false
)
;
xhr
.
setRequestHeader
(
"
Accept
-
Encoding
"
"
gzip
"
)
;
xhr
.
responseType
=
"
arraybuffer
"
;
xhr
.
withCredentials
=
false
;
xhr
.
send
(
null
)
;
if
(
xhr
.
status
!
=
=
200
)
{
console
.
error
(
Failed
to
fetch
{
remoteFilePath
}
:
{
xhr
.
statusText
}
)
;
return
;
}
const
buffer
=
xhr
.
response
;
const
bytes
=
new
Uint8Array
(
buffer
)
;
OS
.
File
.
writeAtomic
(
localFilePath
bytes
{
tmpPath
:
{
localFilePath
}
.
tmp
}
)
;
}
deleteAttachment
(
record
)
{
const
{
attachment
:
{
filename
}
}
=
record
;
OS
.
File
.
makeDir
(
PERSONALITY_PROVIDER_DIR
)
;
const
path
=
OS
.
Path
.
join
(
PERSONALITY_PROVIDER_DIR
filename
)
;
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
OS
.
File
.
removeEmptyDir
(
PERSONALITY_PROVIDER_DIR
{
ignoreAbsent
:
true
}
)
;
}
getAttachment
(
record
)
{
const
{
attachment
:
{
filename
}
}
=
record
;
const
filepath
=
OS
.
Path
.
join
(
PERSONALITY_PROVIDER_DIR
filename
)
;
try
{
this
.
maybeDownloadAttachment
(
record
)
;
return
JSON
.
parse
(
this
.
_getFileStr
(
filepath
)
)
;
}
catch
(
error
)
{
console
.
error
(
Failed
to
load
{
filepath
}
:
{
error
.
message
}
)
;
}
return
{
}
;
}
fetchModels
(
models
)
{
this
.
models
=
models
.
map
(
record
=
>
(
{
.
.
.
this
.
getAttachment
(
record
)
recordKey
:
record
.
key
}
)
)
;
if
(
!
this
.
models
.
length
)
{
return
{
ok
:
false
}
;
}
return
{
ok
:
true
}
;
}
generateTaggers
(
modelKeys
)
{
if
(
!
this
.
taggers
)
{
let
nbTaggers
=
[
]
;
let
nmfTaggers
=
{
}
;
for
(
let
model
of
this
.
models
)
{
if
(
!
modelKeys
.
includes
(
model
.
recordKey
)
)
{
continue
;
}
if
(
model
.
model_type
=
=
=
"
nb
"
)
{
nbTaggers
.
push
(
new
NaiveBayesTextTagger
(
model
toksToTfIdfVector
)
)
;
}
else
if
(
model
.
model_type
=
=
=
"
nmf
"
)
{
nmfTaggers
[
model
.
parent_tag
]
=
new
NmfTextTagger
(
model
toksToTfIdfVector
)
;
}
}
this
.
taggers
=
{
nbTaggers
nmfTaggers
}
;
}
}
generateRecipeExecutor
(
)
{
const
recipeExecutor
=
new
RecipeExecutor
(
this
.
taggers
.
nbTaggers
this
.
taggers
.
nmfTaggers
tokenize
)
;
this
.
recipeExecutor
=
recipeExecutor
;
}
createInterestVector
(
history
)
{
let
interestVector
=
{
}
;
for
(
let
historyRec
of
history
)
{
let
ivItem
=
this
.
recipeExecutor
.
executeRecipe
(
historyRec
this
.
interestConfig
.
history_item_builder
)
;
if
(
ivItem
=
=
=
null
)
{
continue
;
}
interestVector
=
this
.
recipeExecutor
.
executeCombinerRecipe
(
interestVector
ivItem
this
.
interestConfig
.
interest_combiner
)
;
if
(
interestVector
=
=
=
null
)
{
return
null
;
}
}
const
finalResult
=
this
.
recipeExecutor
.
executeRecipe
(
interestVector
this
.
interestConfig
.
interest_finalizer
)
;
return
{
ok
:
true
interestVector
:
finalResult
}
;
}
calculateItemRelevanceScore
(
pocketItem
)
{
const
{
personalization_models
}
=
pocketItem
;
let
scorableItem
;
if
(
personalization_models
&
&
Object
.
keys
(
personalization_models
)
.
length
)
{
scorableItem
=
{
id
:
pocketItem
.
id
item_tags
:
personalization_models
item_score
:
pocketItem
.
item_score
item_sort_id
:
1
}
;
}
else
{
scorableItem
=
this
.
recipeExecutor
.
executeRecipe
(
pocketItem
this
.
interestConfig
.
item_to_rank_builder
)
;
if
(
scorableItem
=
=
=
null
)
{
return
null
;
}
}
let
rankingVector
=
JSON
.
parse
(
JSON
.
stringify
(
this
.
interestVector
)
)
;
Object
.
keys
(
scorableItem
)
.
forEach
(
key
=
>
{
rankingVector
[
key
]
=
scorableItem
[
key
]
;
}
)
;
rankingVector
=
this
.
recipeExecutor
.
executeRecipe
(
rankingVector
this
.
interestConfig
.
item_ranker
)
;
if
(
rankingVector
=
=
=
null
)
{
return
null
;
}
return
{
scorableItem
rankingVector
}
;
}
}
;
