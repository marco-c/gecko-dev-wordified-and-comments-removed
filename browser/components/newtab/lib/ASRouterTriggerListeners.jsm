"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
FEW_MINUTES
=
15
*
60
*
1000
;
async
function
checkStartupFinished
(
win
)
{
if
(
!
win
.
gBrowserInit
.
delayedStartupFinished
)
{
await
new
Promise
(
resolve
=
>
{
let
delayedStartupObserver
=
(
subject
topic
)
=
>
{
if
(
topic
=
=
=
"
browser
-
delayed
-
startup
-
finished
"
&
&
subject
=
=
=
win
)
{
Services
.
obs
.
removeObserver
(
delayedStartupObserver
"
browser
-
delayed
-
startup
-
finished
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
delayedStartupObserver
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
}
}
function
isPrivateWindow
(
win
)
{
return
!
(
win
instanceof
Ci
.
nsIDOMWindow
)
|
|
win
.
closed
|
|
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
;
}
this
.
ASRouterTriggerListeners
=
new
Map
(
[
[
"
frequentVisits
"
{
_initialized
:
false
_triggerHandler
:
null
_hosts
:
null
_visits
:
null
async
init
(
triggerHandler
hosts
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
onTabSwitch
=
this
.
onTabSwitch
.
bind
(
this
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
isPrivateWindow
(
win
)
)
{
continue
;
}
await
checkStartupFinished
(
win
)
;
win
.
addEventListener
(
"
TabSelect
"
this
.
onTabSwitch
)
;
win
.
gBrowser
.
addTabsProgressListener
(
this
)
;
}
this
.
_initialized
=
true
;
this
.
_triggerHandler
=
triggerHandler
;
this
.
_visits
=
new
Map
(
)
;
if
(
this
.
_hosts
)
{
hosts
.
forEach
(
h
=
>
this
.
_hosts
.
add
(
h
)
)
;
}
else
{
this
.
_hosts
=
new
Set
(
hosts
)
;
}
}
_updateVisits
(
host
)
{
const
visits
=
this
.
_visits
.
get
(
host
)
;
if
(
visits
&
&
Date
.
now
(
)
-
visits
[
0
]
>
FEW_MINUTES
)
{
this
.
_visits
.
set
(
host
[
Date
.
now
(
)
.
.
.
visits
]
)
;
return
true
;
}
if
(
!
visits
)
{
this
.
_visits
.
set
(
host
[
Date
.
now
(
)
]
)
;
return
true
;
}
return
false
;
}
onTabSwitch
(
event
)
{
if
(
!
event
.
target
.
ownerGlobal
.
gBrowser
)
{
return
;
}
let
host
;
const
{
gBrowser
}
=
event
.
target
.
ownerGlobal
;
try
{
host
=
gBrowser
.
currentURI
.
host
;
}
catch
(
e
)
{
}
if
(
host
&
&
this
.
_hosts
.
has
(
host
)
)
{
this
.
triggerHandler
(
gBrowser
.
selectedBrowser
host
)
;
}
}
triggerHandler
(
aBrowser
host
)
{
const
updated
=
this
.
_updateVisits
(
host
)
;
if
(
!
updated
)
{
return
;
}
this
.
_triggerHandler
(
aBrowser
{
id
:
"
frequentVisits
"
param
:
host
context
:
{
recentVisits
:
this
.
_visits
.
get
(
host
)
.
map
(
timestamp
=
>
(
{
host
timestamp
}
)
)
}
}
)
;
}
onLocationChange
(
aBrowser
aWebProgress
aRequest
aLocationURI
aFlags
)
{
const
location
=
aLocationURI
?
aLocationURI
.
spec
:
"
"
;
const
isSameDocument
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
;
if
(
location
&
&
aWebProgress
.
isTopLevel
&
&
!
isSameDocument
)
{
try
{
const
host
=
(
new
URL
(
location
)
)
.
hostname
;
if
(
host
&
&
this
.
_hosts
.
has
(
host
)
)
{
this
.
triggerHandler
(
aBrowser
host
)
;
}
}
catch
(
e
)
{
}
}
}
observe
(
win
topic
data
)
{
let
onLoad
;
switch
(
topic
)
{
case
"
domwindowopened
"
:
if
(
isPrivateWindow
(
win
)
)
{
break
;
}
onLoad
=
(
)
=
>
{
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
=
"
navigator
:
browser
"
)
{
win
.
addEventListener
(
"
TabSelect
"
this
.
onTabSwitch
)
;
win
.
gBrowser
.
addTabsProgressListener
(
this
)
;
}
}
;
win
.
addEventListener
(
"
load
"
onLoad
{
once
:
true
}
)
;
break
;
case
"
domwindowclosed
"
:
if
(
(
win
instanceof
Ci
.
nsIDOMWindow
)
&
&
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
=
"
navigator
:
browser
"
)
{
win
.
removeEventListener
(
"
TabSelect
"
this
.
onTabSwitch
)
;
win
.
gBrowser
.
removeTabsProgressListener
(
this
)
;
}
break
;
}
}
uninit
(
)
{
if
(
this
.
_initialized
)
{
Services
.
ww
.
unregisterNotification
(
this
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
isPrivateWindow
(
win
)
)
{
continue
;
}
win
.
removeEventListener
(
"
TabSelect
"
this
.
onTabSwitch
)
;
win
.
gBrowser
.
removeTabsProgressListener
(
this
)
;
}
this
.
_initialized
=
false
;
this
.
_triggerHandler
=
null
;
this
.
_hosts
=
null
;
this
.
_visits
=
null
;
}
}
}
]
[
"
openURL
"
{
_initialized
:
false
_triggerHandler
:
null
_hosts
:
null
async
init
(
triggerHandler
hosts
=
[
]
)
{
if
(
!
this
.
_initialized
)
{
this
.
onLocationChange
=
this
.
onLocationChange
.
bind
(
this
)
;
Services
.
ww
.
registerNotification
(
this
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
isPrivateWindow
(
win
)
)
{
continue
;
}
await
checkStartupFinished
(
win
)
;
win
.
gBrowser
.
addTabsProgressListener
(
this
)
;
}
this
.
_initialized
=
true
;
}
this
.
_triggerHandler
=
triggerHandler
;
if
(
this
.
_hosts
)
{
hosts
.
forEach
(
h
=
>
this
.
_hosts
.
add
(
h
)
)
;
}
else
{
this
.
_hosts
=
new
Set
(
hosts
)
;
}
}
uninit
(
)
{
if
(
this
.
_initialized
)
{
Services
.
ww
.
unregisterNotification
(
this
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
isPrivateWindow
(
win
)
)
{
continue
;
}
win
.
gBrowser
.
removeTabsProgressListener
(
this
)
;
}
this
.
_initialized
=
false
;
this
.
_triggerHandler
=
null
;
this
.
_hosts
=
null
;
}
}
onLocationChange
(
aBrowser
aWebProgress
aRequest
aLocationURI
aFlags
)
{
const
location
=
aLocationURI
?
aLocationURI
.
spec
:
"
"
;
const
isSameDocument
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
;
if
(
location
&
&
aWebProgress
.
isTopLevel
&
&
!
isSameDocument
)
{
try
{
const
host
=
(
new
URL
(
location
)
)
.
hostname
;
if
(
this
.
_hosts
.
has
(
host
)
)
{
this
.
_triggerHandler
(
aBrowser
{
id
:
"
openURL
"
param
:
host
}
)
;
}
}
catch
(
e
)
{
}
}
}
observe
(
win
topic
data
)
{
let
onLoad
;
switch
(
topic
)
{
case
"
domwindowopened
"
:
if
(
isPrivateWindow
(
win
)
)
{
break
;
}
onLoad
=
(
)
=
>
{
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
=
"
navigator
:
browser
"
)
{
win
.
gBrowser
.
addTabsProgressListener
(
this
)
;
}
}
;
win
.
addEventListener
(
"
load
"
onLoad
{
once
:
true
}
)
;
break
;
case
"
domwindowclosed
"
:
if
(
(
win
instanceof
Ci
.
nsIDOMWindow
)
&
&
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
=
"
navigator
:
browser
"
)
{
win
.
gBrowser
.
removeTabsProgressListener
(
this
)
;
}
break
;
}
}
}
]
]
)
;
const
EXPORTED_SYMBOLS
=
[
"
ASRouterTriggerListeners
"
]
;
