"
use
strict
"
;
const
{
actionTypes
:
at
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
jsm
"
)
;
const
{
getDomain
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
lib
/
TippyTopProvider
.
jsm
"
)
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
const
MIN_FAVICON_SIZE
=
96
;
function
getFaviconInfo
(
uri
)
{
return
new
Promise
(
resolve
=
>
PlacesUtils
.
favicons
.
getFaviconDataForPage
(
uri
(
iconUri
faviconLength
favicon
mimeType
faviconSize
)
=
>
resolve
(
iconUri
?
{
iconUri
faviconSize
}
:
null
)
NewTabUtils
.
activityStreamProvider
.
THUMB_FAVICON_SIZE
)
)
;
}
async
function
fetchVisitPaths
(
url
)
{
const
query
=
WITH
RECURSIVE
path
(
visit_id
)
AS
(
SELECT
v
.
id
FROM
moz_places
h
JOIN
moz_historyvisits
v
ON
v
.
place_id
=
h
.
id
WHERE
h
.
url_hash
=
hash
(
:
url
)
AND
h
.
url
=
:
url
AND
v
.
visit_date
=
h
.
last_visit_date
UNION
SELECT
id
FROM
moz_historyvisits
JOIN
path
ON
visit_id
=
from_visit
WHERE
visit_type
IN
(
{
PlacesUtils
.
history
.
TRANSITIONS
.
REDIRECT_PERMANENT
}
{
PlacesUtils
.
history
.
TRANSITIONS
.
REDIRECT_TEMPORARY
}
)
)
SELECT
visit_id
(
SELECT
(
SELECT
url
FROM
moz_places
WHERE
id
=
place_id
)
FROM
moz_historyvisits
WHERE
id
=
visit_id
)
AS
url
FROM
path
;
const
visits
=
await
NewTabUtils
.
activityStreamProvider
.
executePlacesQuery
(
query
{
columns
:
[
"
visit_id
"
"
url
"
]
params
:
{
url
}
}
)
;
return
visits
;
}
async
function
fetchIconFromRedirects
(
url
)
{
const
visitPaths
=
await
fetchVisitPaths
(
url
)
;
if
(
visitPaths
.
length
>
1
)
{
const
lastVisit
=
visitPaths
.
pop
(
)
;
const
redirectedUri
=
Services
.
io
.
newURI
(
lastVisit
.
url
)
;
const
iconInfo
=
await
getFaviconInfo
(
redirectedUri
)
;
if
(
iconInfo
&
&
iconInfo
.
faviconSize
>
=
MIN_FAVICON_SIZE
)
{
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
Services
.
io
.
newURI
(
url
)
iconInfo
.
iconUri
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
}
}
class
FaviconFeed
{
constructor
(
)
{
this
.
_queryForRedirects
=
new
Set
(
)
;
}
async
fetchIcon
(
url
)
{
if
(
!
this
.
shouldFetchIcons
)
{
return
;
}
const
site
=
await
this
.
getSite
(
getDomain
(
url
)
)
;
if
(
!
site
)
{
if
(
!
this
.
_queryForRedirects
.
has
(
url
)
)
{
this
.
_queryForRedirects
.
add
(
url
)
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
fetchIconFromRedirects
(
url
)
)
;
}
return
;
}
let
iconUri
=
Services
.
io
.
newURI
(
site
.
image_url
)
;
iconUri
=
iconUri
.
mutate
(
)
.
setRef
(
"
tippytop
"
)
.
finalize
(
)
;
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
Services
.
io
.
newURI
(
url
)
iconUri
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
async
getSite
(
domain
)
{
const
sites
=
await
this
.
tippyTop
.
get
(
{
filters
:
{
domain
}
syncIfEmpty
:
false
}
)
;
return
sites
.
length
?
sites
[
0
]
:
null
;
}
get
tippyTop
(
)
{
if
(
!
this
.
_tippyTop
)
{
this
.
_tippyTop
=
RemoteSettings
(
"
tippytop
"
)
;
}
return
this
.
_tippyTop
;
}
get
shouldFetchIcons
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
chrome
.
site_icons
"
)
;
}
onAction
(
action
)
{
switch
(
action
.
type
)
{
case
at
.
RICH_ICON_MISSING
:
this
.
fetchIcon
(
action
.
data
.
url
)
;
break
;
}
}
}
const
EXPORTED_SYMBOLS
=
[
"
FaviconFeed
"
"
fetchIconFromRedirects
"
]
;
