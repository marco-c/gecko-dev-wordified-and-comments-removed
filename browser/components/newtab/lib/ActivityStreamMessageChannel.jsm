"
use
strict
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
AboutNewTab
"
"
resource
:
/
/
/
modules
/
AboutNewTab
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
AboutHomeStartupCache
"
"
resource
:
/
/
/
modules
/
BrowserGlue
.
jsm
"
)
;
const
{
RemotePages
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
remotepagemanager
/
RemotePageManagerParent
.
jsm
"
)
;
const
{
actionCreators
:
ac
actionTypes
:
at
actionUtils
:
au
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
jsm
"
)
;
const
ABOUT_NEW_TAB_URL
=
"
about
:
newtab
"
;
const
ABOUT_HOME_URL
=
"
about
:
home
"
;
const
DEFAULT_OPTIONS
=
{
dispatch
(
action
)
{
throw
new
Error
(
\
nMessageChannel
:
Received
action
{
action
.
type
}
but
no
dispatcher
was
defined
.
\
n
)
;
}
pageURL
:
ABOUT_NEW_TAB_URL
outgoingMessageName
:
"
ActivityStream
:
MainToContent
"
incomingMessageName
:
"
ActivityStream
:
ContentToMain
"
}
;
class
ActivityStreamMessageChannel
{
constructor
(
options
=
{
}
)
{
Object
.
assign
(
this
DEFAULT_OPTIONS
options
)
;
this
.
channel
=
null
;
this
.
middleware
=
this
.
middleware
.
bind
(
this
)
;
this
.
onMessage
=
this
.
onMessage
.
bind
(
this
)
;
this
.
onNewTabLoad
=
this
.
onNewTabLoad
.
bind
(
this
)
;
this
.
onNewTabUnload
=
this
.
onNewTabUnload
.
bind
(
this
)
;
this
.
onNewTabInit
=
this
.
onNewTabInit
.
bind
(
this
)
;
}
middleware
(
store
)
{
return
next
=
>
action
=
>
{
const
skipMain
=
action
.
meta
&
&
action
.
meta
.
skipMain
;
if
(
!
this
.
channel
&
&
!
skipMain
)
{
next
(
action
)
;
return
;
}
if
(
au
.
isSendToOneContent
(
action
)
)
{
this
.
send
(
action
)
;
}
else
if
(
au
.
isBroadcastToContent
(
action
)
)
{
this
.
broadcast
(
action
)
;
}
else
if
(
au
.
isSendToPreloaded
(
action
)
)
{
this
.
sendToPreloaded
(
action
)
;
}
if
(
!
skipMain
)
{
next
(
action
)
;
}
}
;
}
onActionFromContent
(
action
targetId
)
{
this
.
dispatch
(
ac
.
AlsoToMain
(
action
this
.
validatePortID
(
targetId
)
)
)
;
}
broadcast
(
action
)
{
lazy
.
AboutHomeStartupCache
.
onPreloadedNewTabMessage
(
)
;
this
.
channel
.
sendAsyncMessage
(
this
.
outgoingMessageName
action
)
;
}
send
(
action
)
{
const
targetId
=
action
.
meta
&
&
action
.
meta
.
toTarget
;
const
target
=
this
.
getTargetById
(
targetId
)
;
try
{
target
.
sendAsyncMessage
(
this
.
outgoingMessageName
action
)
;
}
catch
(
e
)
{
}
}
validatePortID
(
id
)
{
if
(
typeof
id
!
=
=
"
string
"
|
|
!
id
.
includes
(
"
:
"
)
)
{
Cu
.
reportError
(
"
Invalid
portID
"
)
;
}
return
id
;
}
getTargetById
(
id
)
{
this
.
validatePortID
(
id
)
;
for
(
let
port
of
this
.
channel
.
messagePorts
)
{
if
(
port
.
portID
=
=
=
id
)
{
return
port
;
}
}
return
null
;
}
sendToPreloaded
(
action
)
{
lazy
.
AboutHomeStartupCache
.
onPreloadedNewTabMessage
(
)
;
const
preloadedBrowsers
=
this
.
getPreloadedBrowser
(
)
;
if
(
preloadedBrowsers
&
&
action
.
data
)
{
for
(
let
preloadedBrowser
of
preloadedBrowsers
)
{
try
{
preloadedBrowser
.
sendAsyncMessage
(
this
.
outgoingMessageName
action
)
;
}
catch
(
e
)
{
}
}
}
}
getPreloadedBrowser
(
)
{
let
preloadedPorts
=
[
]
;
for
(
let
port
of
this
.
channel
.
messagePorts
)
{
if
(
this
.
isPreloadedBrowser
(
port
.
browser
)
)
{
preloadedPorts
.
push
(
port
)
;
}
}
return
preloadedPorts
.
length
?
preloadedPorts
:
null
;
}
isPreloadedBrowser
(
browser
)
{
return
browser
.
getAttribute
(
"
preloadedState
"
)
=
=
=
"
preloaded
"
;
}
createChannel
(
)
{
const
channel
=
this
.
pageURL
=
=
=
ABOUT_NEW_TAB_URL
&
&
lazy
.
AboutNewTab
.
overridePageListener
(
true
)
;
this
.
channel
=
channel
|
|
new
RemotePages
(
[
ABOUT_HOME_URL
ABOUT_NEW_TAB_URL
]
)
;
this
.
channel
.
addMessageListener
(
"
RemotePage
:
Init
"
this
.
onNewTabInit
)
;
this
.
channel
.
addMessageListener
(
"
RemotePage
:
Load
"
this
.
onNewTabLoad
)
;
this
.
channel
.
addMessageListener
(
"
RemotePage
:
Unload
"
this
.
onNewTabUnload
)
;
this
.
channel
.
addMessageListener
(
this
.
incomingMessageName
this
.
onMessage
)
;
}
simulateMessagesForExistingTabs
(
)
{
for
(
const
target
of
this
.
channel
.
messagePorts
)
{
const
simulatedMsg
=
{
target
:
Object
.
assign
(
{
simulated
:
true
}
target
)
}
;
this
.
onNewTabInit
(
simulatedMsg
)
;
if
(
target
.
loaded
)
{
this
.
onNewTabLoad
(
simulatedMsg
)
;
}
}
}
destroyChannel
(
)
{
this
.
channel
.
removeMessageListener
(
"
RemotePage
:
Init
"
this
.
onNewTabInit
)
;
this
.
channel
.
removeMessageListener
(
"
RemotePage
:
Load
"
this
.
onNewTabLoad
)
;
this
.
channel
.
removeMessageListener
(
"
RemotePage
:
Unload
"
this
.
onNewTabUnload
)
;
this
.
channel
.
removeMessageListener
(
this
.
incomingMessageName
this
.
onMessage
)
;
if
(
this
.
pageURL
=
=
=
ABOUT_NEW_TAB_URL
)
{
lazy
.
AboutNewTab
.
reset
(
this
.
channel
)
;
}
else
{
this
.
channel
.
destroy
(
)
;
}
this
.
channel
=
null
;
}
onNewTabInit
(
msg
)
{
this
.
onActionFromContent
(
{
type
:
at
.
NEW_TAB_INIT
data
:
msg
.
target
}
msg
.
target
.
portID
)
;
}
onNewTabLoad
(
msg
)
{
let
{
browser
}
=
msg
.
target
;
if
(
this
.
isPreloadedBrowser
(
browser
)
&
&
browser
.
ownerGlobal
.
windowState
!
=
=
browser
.
ownerGlobal
.
STATE_MINIMIZED
&
&
!
browser
.
ownerGlobal
.
isFullyOccluded
)
{
browser
.
renderLayers
=
true
;
}
this
.
onActionFromContent
(
{
type
:
at
.
NEW_TAB_LOAD
}
msg
.
target
.
portID
)
;
}
onNewTabUnload
(
msg
)
{
this
.
onActionFromContent
(
{
type
:
at
.
NEW_TAB_UNLOAD
}
msg
.
target
.
portID
)
;
}
onMessage
(
msg
)
{
const
{
portID
}
=
msg
.
target
;
if
(
!
msg
.
data
|
|
!
msg
.
data
.
type
)
{
Cu
.
reportError
(
new
Error
(
Received
an
improperly
formatted
message
from
{
portID
}
)
)
;
return
;
}
let
action
=
{
}
;
Object
.
assign
(
action
msg
.
data
)
;
action
.
_target
=
msg
.
target
;
this
.
onActionFromContent
(
action
portID
)
;
}
}
const
EXPORTED_SYMBOLS
=
[
"
ActivityStreamMessageChannel
"
"
DEFAULT_OPTIONS
"
]
;
