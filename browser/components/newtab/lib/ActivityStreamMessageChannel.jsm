"
use
strict
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
AboutHomeStartupCache
:
"
resource
:
/
/
/
modules
/
BrowserGlue
.
sys
.
mjs
"
AboutNewTabParent
:
"
resource
:
/
/
/
actors
/
AboutNewTabParent
.
sys
.
mjs
"
}
)
;
const
{
actionCreators
:
ac
actionTypes
:
at
actionUtils
:
au
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
activity
-
stream
/
common
/
Actions
.
sys
.
mjs
"
)
;
const
ABOUT_NEW_TAB_URL
=
"
about
:
newtab
"
;
const
DEFAULT_OPTIONS
=
{
dispatch
(
action
)
{
throw
new
Error
(
\
nMessageChannel
:
Received
action
{
action
.
type
}
but
no
dispatcher
was
defined
.
\
n
)
;
}
pageURL
:
ABOUT_NEW_TAB_URL
outgoingMessageName
:
"
ActivityStream
:
MainToContent
"
incomingMessageName
:
"
ActivityStream
:
ContentToMain
"
}
;
class
ActivityStreamMessageChannel
{
constructor
(
options
=
{
}
)
{
Object
.
assign
(
this
DEFAULT_OPTIONS
options
)
;
this
.
middleware
=
this
.
middleware
.
bind
(
this
)
;
this
.
onMessage
=
this
.
onMessage
.
bind
(
this
)
;
this
.
onNewTabLoad
=
this
.
onNewTabLoad
.
bind
(
this
)
;
this
.
onNewTabUnload
=
this
.
onNewTabUnload
.
bind
(
this
)
;
this
.
onNewTabInit
=
this
.
onNewTabInit
.
bind
(
this
)
;
}
get
loadedTabs
(
)
{
return
lazy
.
AboutNewTabParent
?
.
loadedTabs
|
|
new
Map
(
)
;
}
middleware
(
store
)
{
return
next
=
>
action
=
>
{
const
skipMain
=
action
.
meta
&
&
action
.
meta
.
skipMain
;
if
(
au
.
isSendToOneContent
(
action
)
)
{
this
.
send
(
action
)
;
}
else
if
(
au
.
isBroadcastToContent
(
action
)
)
{
this
.
broadcast
(
action
)
;
}
else
if
(
au
.
isSendToPreloaded
(
action
)
)
{
this
.
sendToPreloaded
(
action
)
;
}
if
(
!
skipMain
)
{
next
(
action
)
;
}
}
;
}
onActionFromContent
(
action
targetId
)
{
this
.
dispatch
(
ac
.
AlsoToMain
(
action
this
.
validatePortID
(
targetId
)
)
)
;
}
broadcast
(
action
)
{
lazy
.
AboutHomeStartupCache
.
onPreloadedNewTabMessage
(
)
;
for
(
let
{
actor
}
of
this
.
loadedTabs
.
values
(
)
)
{
try
{
actor
.
sendAsyncMessage
(
this
.
outgoingMessageName
action
)
;
}
catch
(
e
)
{
}
}
}
send
(
action
)
{
const
targetId
=
action
.
meta
&
&
action
.
meta
.
toTarget
;
const
target
=
this
.
getTargetById
(
targetId
)
;
try
{
target
.
sendAsyncMessage
(
this
.
outgoingMessageName
action
)
;
}
catch
(
e
)
{
}
}
validatePortID
(
id
)
{
if
(
typeof
id
!
=
=
"
string
"
|
|
!
id
.
includes
(
"
:
"
)
)
{
console
.
error
(
"
Invalid
portID
"
)
;
}
return
id
;
}
getTargetById
(
id
)
{
this
.
validatePortID
(
id
)
;
for
(
let
{
portID
actor
}
of
this
.
loadedTabs
.
values
(
)
)
{
if
(
portID
=
=
=
id
)
{
return
actor
;
}
}
return
null
;
}
sendToPreloaded
(
action
)
{
lazy
.
AboutHomeStartupCache
.
onPreloadedNewTabMessage
(
)
;
const
preloadedActors
=
this
.
getPreloadedActors
(
)
;
if
(
preloadedActors
&
&
action
.
data
)
{
for
(
let
preloadedActor
of
preloadedActors
)
{
try
{
preloadedActor
.
sendAsyncMessage
(
this
.
outgoingMessageName
action
)
;
}
catch
(
e
)
{
}
}
}
}
getPreloadedActors
(
)
{
let
preloadedActors
=
[
]
;
for
(
let
{
actor
browser
}
of
this
.
loadedTabs
.
values
(
)
)
{
if
(
this
.
isPreloadedBrowser
(
browser
)
)
{
preloadedActors
.
push
(
actor
)
;
}
}
return
preloadedActors
.
length
?
preloadedActors
:
null
;
}
isPreloadedBrowser
(
browser
)
{
return
browser
.
getAttribute
(
"
preloadedState
"
)
=
=
=
"
preloaded
"
;
}
simulateMessagesForExistingTabs
(
)
{
for
(
const
loadedTab
of
this
.
loadedTabs
.
values
(
)
)
{
let
simulatedDetails
=
{
actor
:
loadedTab
.
actor
browser
:
loadedTab
.
browser
browsingContext
:
loadedTab
.
browsingContext
portID
:
loadedTab
.
portID
url
:
loadedTab
.
url
simulated
:
true
}
;
this
.
onActionFromContent
(
{
type
:
at
.
NEW_TAB_INIT
data
:
simulatedDetails
}
loadedTab
.
portID
)
;
if
(
loadedTab
.
loaded
)
{
this
.
tabLoaded
(
simulatedDetails
)
;
}
}
}
onNewTabInit
(
msg
tabDetails
)
{
this
.
onActionFromContent
(
{
type
:
at
.
NEW_TAB_INIT
data
:
tabDetails
}
msg
.
data
.
portID
)
;
}
onNewTabLoad
(
msg
tabDetails
)
{
this
.
tabLoaded
(
tabDetails
)
;
}
tabLoaded
(
tabDetails
)
{
tabDetails
.
loaded
=
true
;
let
{
browser
}
=
tabDetails
;
if
(
this
.
isPreloadedBrowser
(
browser
)
&
&
browser
.
ownerGlobal
.
windowState
!
=
=
browser
.
ownerGlobal
.
STATE_MINIMIZED
&
&
!
browser
.
ownerGlobal
.
isFullyOccluded
)
{
browser
.
renderLayers
=
true
;
}
this
.
onActionFromContent
(
{
type
:
at
.
NEW_TAB_LOAD
}
tabDetails
.
portID
)
;
}
onNewTabUnload
(
msg
tabDetails
)
{
this
.
onActionFromContent
(
{
type
:
at
.
NEW_TAB_UNLOAD
}
tabDetails
.
portID
)
;
}
onMessage
(
msg
tabDetails
)
{
if
(
!
msg
.
data
|
|
!
msg
.
data
.
type
)
{
console
.
error
(
new
Error
(
Received
an
improperly
formatted
message
from
{
tabDetails
.
portID
}
)
)
;
return
;
}
let
action
=
{
}
;
Object
.
assign
(
action
msg
.
data
)
;
action
.
_target
=
{
browser
:
tabDetails
.
browser
}
;
this
.
onActionFromContent
(
action
tabDetails
.
portID
)
;
}
}
const
EXPORTED_SYMBOLS
=
[
"
ActivityStreamMessageChannel
"
"
DEFAULT_OPTIONS
"
]
;
