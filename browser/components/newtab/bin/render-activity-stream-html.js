const
fs
=
require
(
"
fs
"
)
;
const
{
mkdir
}
=
require
(
"
shelljs
"
)
;
const
path
=
require
(
"
path
"
)
;
const
{
prerender
}
=
require
(
"
.
/
prerender
"
)
;
const
{
CENTRAL_LOCALES
DEFAULT_LOCALE
}
=
require
(
"
.
/
locales
"
)
;
const
DEFAULT_OPTIONS
=
{
addonPath
:
"
.
.
"
baseUrl
:
"
resource
:
/
/
activity
-
stream
/
"
}
;
const
RTL_LIST
=
[
"
ar
"
"
he
"
"
fa
"
"
ur
"
]
;
function
getLanguage
(
locale
)
{
return
locale
.
split
(
"
-
"
)
[
0
]
;
}
function
getStrings
(
locale
allStrings
)
{
const
availableLocales
=
Object
.
keys
(
allStrings
)
;
const
language
=
getLanguage
(
locale
)
;
const
similarLocales
=
availableLocales
.
filter
(
other
=
>
other
!
=
=
locale
&
&
getLanguage
(
other
)
=
=
=
language
)
;
const
localeFallbacks
=
[
DEFAULT_LOCALE
.
.
.
similarLocales
locale
]
;
return
Object
.
assign
(
{
}
.
.
.
localeFallbacks
.
map
(
l
=
>
allStrings
[
l
]
)
)
;
}
function
getTextDirection
(
locale
)
{
return
RTL_LIST
.
includes
(
locale
.
split
(
"
-
"
)
[
0
]
)
?
"
rtl
"
:
"
ltr
"
;
}
function
templateHTML
(
options
html
)
{
const
isPrerendered
=
!
!
html
;
const
debugString
=
options
.
debug
?
"
-
dev
"
:
"
"
;
const
scripts
=
[
"
chrome
:
/
/
browser
/
content
/
contentSearchUI
.
js
"
"
chrome
:
/
/
browser
/
content
/
contentTheme
.
js
"
{
options
.
baseUrl
}
vendor
/
react
{
debugString
}
.
js
{
options
.
baseUrl
}
vendor
/
react
-
dom
{
debugString
}
.
js
{
options
.
baseUrl
}
vendor
/
prop
-
types
.
js
{
options
.
baseUrl
}
vendor
/
react
-
intl
.
js
{
options
.
baseUrl
}
vendor
/
redux
.
js
{
options
.
baseUrl
}
vendor
/
react
-
redux
.
js
{
options
.
baseUrl
}
prerendered
/
{
options
.
locale
}
/
activity
-
stream
-
strings
.
js
{
options
.
baseUrl
}
data
/
content
/
activity
-
stream
.
bundle
.
js
]
;
if
(
isPrerendered
)
{
scripts
.
unshift
(
{
options
.
baseUrl
}
prerendered
/
static
/
activity
-
stream
-
initial
-
state
.
js
)
;
}
const
scriptTag
=
<
script
>
/
/
Don
'
t
directly
load
the
following
scripts
as
part
of
html
to
let
the
page
/
/
finish
loading
to
render
the
content
sooner
.
for
(
const
src
of
{
JSON
.
stringify
(
scripts
null
2
)
}
)
{
/
/
These
dynamically
inserted
scripts
by
default
are
async
but
we
need
them
/
/
to
load
in
the
desired
order
(
i
.
e
.
bundle
last
)
.
const
script
=
document
.
body
.
appendChild
(
document
.
createElement
(
"
script
"
)
)
;
script
.
async
=
false
;
script
.
src
=
src
;
}
<
/
script
>
;
return
<
!
doctype
html
>
<
html
lang
=
"
{
options
.
locale
}
"
dir
=
"
{
options
.
direction
}
"
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
>
<
meta
http
-
equiv
=
"
Content
-
Security
-
Policy
"
content
=
"
default
-
src
'
none
'
;
script
-
src
'
unsafe
-
inline
'
resource
:
chrome
:
;
connect
-
src
https
:
;
img
-
src
https
:
data
:
blob
:
;
style
-
src
'
unsafe
-
inline
'
;
"
>
<
title
>
{
options
.
strings
.
newtab_page_title
}
<
/
title
>
<
link
rel
=
"
icon
"
type
=
"
image
/
png
"
href
=
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
/
>
<
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
browser
/
content
/
contentSearchUI
.
css
"
/
>
<
link
rel
=
"
stylesheet
"
href
=
"
{
options
.
baseUrl
}
css
/
activity
-
stream
.
css
"
/
>
<
/
head
>
<
body
class
=
"
activity
-
stream
"
>
<
div
id
=
"
root
"
>
{
isPrerendered
?
html
:
"
<
!
-
-
Regular
React
Rendering
-
-
>
"
}
<
/
div
>
<
div
id
=
"
snippets
-
container
"
>
<
div
id
=
"
snippets
"
>
<
/
div
>
<
/
div
>
{
options
.
noscripts
?
"
"
:
scriptTag
}
<
/
body
>
<
/
html
>
;
}
function
templateJs
(
name
desc
state
)
{
return
/
/
Note
-
this
is
a
generated
{
desc
}
file
.
window
.
{
name
}
=
{
JSON
.
stringify
(
state
null
2
)
}
;
;
}
function
writeFiles
(
name
destPath
filesMap
{
html
state
}
options
)
{
for
(
const
[
file
templater
]
of
filesMap
)
{
fs
.
writeFileSync
(
path
.
join
(
destPath
file
)
templater
(
{
html
options
state
}
)
)
;
}
console
.
log
(
"
\
x1b
[
32m
"
{
name
}
"
\
x1b
[
0m
"
)
;
}
const
STATIC_FILES
=
new
Map
(
[
[
"
activity
-
stream
-
debug
.
html
"
(
{
options
}
)
=
>
templateHTML
(
options
)
]
[
"
activity
-
stream
-
initial
-
state
.
js
"
(
{
state
}
)
=
>
templateJs
(
"
gActivityStreamPrerenderedState
"
"
static
"
state
)
]
[
"
activity
-
stream
-
prerendered
-
debug
.
html
"
(
{
html
options
}
)
=
>
templateHTML
(
options
html
)
]
]
)
;
const
LOCALIZED_FILES
=
new
Map
(
[
[
"
activity
-
stream
-
prerendered
.
html
"
(
{
html
options
}
)
=
>
templateHTML
(
options
html
)
]
[
"
activity
-
stream
-
prerendered
-
noscripts
.
html
"
(
{
html
options
}
)
=
>
templateHTML
(
Object
.
assign
(
{
}
options
{
noscripts
:
true
}
)
html
)
]
[
"
activity
-
stream
-
strings
.
js
"
(
{
options
:
{
locale
strings
}
}
)
=
>
templateJs
(
"
gActivityStreamStrings
"
locale
strings
)
]
[
"
activity
-
stream
.
html
"
(
{
options
}
)
=
>
templateHTML
(
options
)
]
[
"
activity
-
stream
-
noscripts
.
html
"
(
{
options
}
)
=
>
templateHTML
(
Object
.
assign
(
{
}
options
{
noscripts
:
true
}
)
)
]
]
)
;
function
main
(
)
{
const
args
=
require
(
"
minimist
"
)
(
process
.
argv
.
slice
(
2
)
{
alias
:
{
addonPath
:
"
a
"
baseUrl
:
"
b
"
}
}
)
;
const
baseOptions
=
Object
.
assign
(
{
debug
:
false
}
DEFAULT_OPTIONS
args
|
|
{
}
)
;
const
addonPath
=
path
.
resolve
(
__dirname
baseOptions
.
addonPath
)
;
const
allStrings
=
require
(
{
baseOptions
.
addonPath
}
/
data
/
locales
.
json
)
;
const
extraLocales
=
Object
.
keys
(
allStrings
)
.
filter
(
locale
=
>
locale
!
=
=
DEFAULT_LOCALE
&
&
!
CENTRAL_LOCALES
.
includes
(
locale
)
)
;
const
prerenderedPath
=
path
.
join
(
addonPath
"
prerendered
"
)
;
console
.
log
(
Writing
prerendered
files
to
individual
directories
under
{
prerenderedPath
}
:
)
;
let
defaultStrings
;
let
langStrings
;
const
isSubset
=
(
strings
existing
)
=
>
existing
&
&
Object
.
keys
(
strings
)
.
every
(
key
=
>
strings
[
key
]
=
=
=
existing
[
key
]
)
;
const
localizedLocales
=
[
]
;
const
skippedLocales
=
[
]
;
for
(
const
locale
of
[
DEFAULT_LOCALE
.
.
.
CENTRAL_LOCALES
]
)
{
const
strings
=
getStrings
(
locale
allStrings
)
;
if
(
isSubset
(
strings
defaultStrings
)
|
|
isSubset
(
strings
langStrings
)
)
{
skippedLocales
.
push
(
locale
)
;
continue
;
}
const
prerenderData
=
prerender
(
locale
strings
)
;
const
options
=
Object
.
assign
(
{
}
baseOptions
{
direction
:
getTextDirection
(
locale
)
locale
strings
}
)
;
const
localePath
=
path
.
join
(
prerenderedPath
"
locales
"
locale
)
;
mkdir
(
"
-
p
"
localePath
)
;
writeFiles
(
locale
localePath
LOCALIZED_FILES
prerenderData
options
)
;
if
(
locale
=
=
=
DEFAULT_LOCALE
)
{
const
staticPath
=
path
.
join
(
prerenderedPath
"
static
"
)
;
mkdir
(
"
-
p
"
staticPath
)
;
writeFiles
(
{
locale
}
(
static
)
staticPath
STATIC_FILES
prerenderData
Object
.
assign
(
{
}
options
{
debug
:
true
}
)
)
;
defaultStrings
=
strings
;
}
if
(
getLanguage
(
locale
)
=
=
=
locale
)
{
langStrings
=
strings
;
}
localizedLocales
.
push
(
locale
)
;
}
if
(
skippedLocales
.
length
)
{
console
.
log
(
"
\
x1b
[
33m
"
Skipped
the
following
locales
because
they
use
the
same
strings
as
{
DEFAULT_LOCALE
}
or
its
language
locale
:
{
skippedLocales
.
join
(
"
"
)
}
"
\
x1b
[
0m
"
)
;
}
if
(
extraLocales
.
length
)
{
console
.
log
(
"
\
x1b
[
33m
"
Skipped
the
following
locales
because
they
are
not
in
CENTRAL_LOCALES
:
{
extraLocales
.
join
(
"
"
)
}
"
\
x1b
[
0m
"
)
;
}
const
bcp47String
=
localizedLocales
.
join
(
"
"
)
.
replace
(
/
(
ja
-
JP
-
mac
)
/
"
1os
"
)
;
console
.
log
(
\
nIf
aboutNewTabService
tests
are
failing
for
unexpected
locales
make
sure
its
list
is
updated
:
\
nconst
ACTIVITY_STREAM_BCP47
=
"
{
bcp47String
}
"
.
split
(
"
"
)
;
)
;
}
main
(
)
;
