var
NewtabRenderUtils
;
(
(
)
=
>
{
"
use
strict
"
;
var
__webpack_require__
=
{
}
;
(
(
)
=
>
{
__webpack_require__
.
n
=
(
module
)
=
>
{
var
getter
=
module
&
&
module
.
__esModule
?
(
)
=
>
(
module
[
'
default
'
]
)
:
(
)
=
>
(
module
)
;
__webpack_require__
.
d
(
getter
{
a
:
getter
}
)
;
return
getter
;
}
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
d
=
(
exports
definition
)
=
>
{
for
(
var
key
in
definition
)
{
if
(
__webpack_require__
.
o
(
definition
key
)
&
&
!
__webpack_require__
.
o
(
exports
key
)
)
{
Object
.
defineProperty
(
exports
key
{
enumerable
:
true
get
:
definition
[
key
]
}
)
;
}
}
}
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
g
=
(
function
(
)
{
if
(
typeof
globalThis
=
=
=
'
object
'
)
return
globalThis
;
try
{
return
this
|
|
new
Function
(
'
return
this
'
)
(
)
;
}
catch
(
e
)
{
if
(
typeof
window
=
=
=
'
object
'
)
return
window
;
}
}
)
(
)
;
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
o
=
(
obj
prop
)
=
>
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
prop
)
)
}
)
(
)
;
(
(
)
=
>
{
__webpack_require__
.
r
=
(
exports
)
=
>
{
if
(
typeof
Symbol
!
=
=
'
undefined
'
&
&
Symbol
.
toStringTag
)
{
Object
.
defineProperty
(
exports
Symbol
.
toStringTag
{
value
:
'
Module
'
}
)
;
}
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
}
;
}
)
(
)
;
var
__webpack_exports__
=
{
}
;
__webpack_require__
.
r
(
__webpack_exports__
)
;
__webpack_require__
.
d
(
__webpack_exports__
{
"
NewTab
"
:
(
)
=
>
(
NewTab
)
"
renderCache
"
:
(
)
=
>
(
renderCache
)
"
renderWithoutState
"
:
(
)
=
>
(
renderWithoutState
)
}
)
;
var
builtins_namespaceObject
=
{
}
;
__webpack_require__
.
r
(
builtins_namespaceObject
)
;
__webpack_require__
.
d
(
builtins_namespaceObject
{
"
DATETIME
"
:
(
)
=
>
(
DATETIME
)
"
NUMBER
"
:
(
)
=
>
(
NUMBER
)
}
)
;
;
const
MAIN_MESSAGE_TYPE
=
"
ActivityStream
:
Main
"
;
const
CONTENT_MESSAGE_TYPE
=
"
ActivityStream
:
Content
"
;
const
PRELOAD_MESSAGE_TYPE
=
"
ActivityStream
:
PreloadedBrowser
"
;
const
UI_CODE
=
1
;
const
BACKGROUND_PROCESS
=
2
;
const
globalImportContext
=
typeof
Window
=
=
=
"
undefined
"
?
BACKGROUND_PROCESS
:
UI_CODE
;
const
actionTypes
=
{
}
;
for
(
const
type
of
[
"
ABOUT_SPONSORED_TOP_SITES
"
"
ADDONS_INFO_REQUEST
"
"
ADDONS_INFO_RESPONSE
"
"
ARCHIVE_FROM_POCKET
"
"
AS_ROUTER_INITIALIZED
"
"
AS_ROUTER_PREF_CHANGED
"
"
AS_ROUTER_TARGETING_UPDATE
"
"
AS_ROUTER_TELEMETRY_USER_EVENT
"
"
BLOCK_URL
"
"
BOOKMARK_URL
"
"
CLEAR_PREF
"
"
COPY_DOWNLOAD_LINK
"
"
DELETE_BOOKMARK_BY_ID
"
"
DELETE_FROM_POCKET
"
"
DELETE_HISTORY_URL
"
"
DIALOG_CANCEL
"
"
DIALOG_OPEN
"
"
DISABLE_SEARCH
"
"
DISCOVERY_STREAM_COLLECTION_DISMISSIBLE_TOGGLE
"
"
DISCOVERY_STREAM_CONFIG_CHANGE
"
"
DISCOVERY_STREAM_CONFIG_RESET
"
"
DISCOVERY_STREAM_CONFIG_RESET_DEFAULTS
"
"
DISCOVERY_STREAM_CONFIG_SETUP
"
"
DISCOVERY_STREAM_CONFIG_SET_VALUE
"
"
DISCOVERY_STREAM_DEV_EXPIRE_CACHE
"
"
DISCOVERY_STREAM_DEV_IDLE_DAILY
"
"
DISCOVERY_STREAM_DEV_SYNC_RS
"
"
DISCOVERY_STREAM_DEV_SYSTEM_TICK
"
"
DISCOVERY_STREAM_EXPERIMENT_DATA
"
"
DISCOVERY_STREAM_FEEDS_UPDATE
"
"
DISCOVERY_STREAM_FEED_UPDATE
"
"
DISCOVERY_STREAM_IMPRESSION_STATS
"
"
DISCOVERY_STREAM_LAYOUT_RESET
"
"
DISCOVERY_STREAM_LAYOUT_UPDATE
"
"
DISCOVERY_STREAM_LINK_BLOCKED
"
"
DISCOVERY_STREAM_LOADED_CONTENT
"
"
DISCOVERY_STREAM_PERSONALIZATION_INIT
"
"
DISCOVERY_STREAM_PERSONALIZATION_LAST_UPDATED
"
"
DISCOVERY_STREAM_PERSONALIZATION_TOGGLE
"
"
DISCOVERY_STREAM_POCKET_STATE_INIT
"
"
DISCOVERY_STREAM_POCKET_STATE_SET
"
"
DISCOVERY_STREAM_PREFS_SETUP
"
"
DISCOVERY_STREAM_RECENT_SAVES
"
"
DISCOVERY_STREAM_RETRY_FEED
"
"
DISCOVERY_STREAM_SPOCS_CAPS
"
"
DISCOVERY_STREAM_SPOCS_ENDPOINT
"
"
DISCOVERY_STREAM_SPOCS_PLACEMENTS
"
"
DISCOVERY_STREAM_SPOCS_UPDATE
"
"
DISCOVERY_STREAM_SPOC_BLOCKED
"
"
DISCOVERY_STREAM_SPOC_IMPRESSION
"
"
DISCOVERY_STREAM_USER_EVENT
"
"
DOWNLOAD_CHANGED
"
"
FAKE_FOCUS_SEARCH
"
"
FILL_SEARCH_TERM
"
"
HANDOFF_SEARCH_TO_AWESOMEBAR
"
"
HIDE_PRIVACY_INFO
"
"
INIT
"
"
NEW_TAB_INIT
"
"
NEW_TAB_INITIAL_STATE
"
"
NEW_TAB_LOAD
"
"
NEW_TAB_REHYDRATED
"
"
NEW_TAB_STATE_REQUEST
"
"
NEW_TAB_UNLOAD
"
"
OPEN_DOWNLOAD_FILE
"
"
OPEN_LINK
"
"
OPEN_NEW_WINDOW
"
"
OPEN_PRIVATE_WINDOW
"
"
OPEN_WEBEXT_SETTINGS
"
"
PARTNER_LINK_ATTRIBUTION
"
"
PLACES_BOOKMARKS_REMOVED
"
"
PLACES_BOOKMARK_ADDED
"
"
PLACES_HISTORY_CLEARED
"
"
PLACES_LINKS_CHANGED
"
"
PLACES_LINKS_DELETED
"
"
PLACES_LINK_BLOCKED
"
"
PLACES_SAVED_TO_POCKET
"
"
POCKET_CTA
"
"
POCKET_LINK_DELETED_OR_ARCHIVED
"
"
POCKET_LOGGED_IN
"
"
POCKET_WAITING_FOR_SPOC
"
"
PREFS_INITIAL_VALUES
"
"
PREF_CHANGED
"
"
PREVIEW_REQUEST
"
"
PREVIEW_REQUEST_CANCEL
"
"
PREVIEW_RESPONSE
"
"
REMOVE_DOWNLOAD_FILE
"
"
RICH_ICON_MISSING
"
"
SAVE_SESSION_PERF_DATA
"
"
SAVE_TO_POCKET
"
"
SCREENSHOT_UPDATED
"
"
SECTION_DEREGISTER
"
"
SECTION_DISABLE
"
"
SECTION_ENABLE
"
"
SECTION_MOVE
"
"
SECTION_OPTIONS_CHANGED
"
"
SECTION_REGISTER
"
"
SECTION_UPDATE
"
"
SECTION_UPDATE_CARD
"
"
SETTINGS_CLOSE
"
"
SETTINGS_OPEN
"
"
SET_PREF
"
"
SHOW_DOWNLOAD_FILE
"
"
SHOW_FIREFOX_ACCOUNTS
"
"
SHOW_PRIVACY_INFO
"
"
SHOW_SEARCH
"
"
SKIPPED_SIGNIN
"
"
SNIPPETS_BLOCKLIST_CLEARED
"
"
SNIPPETS_BLOCKLIST_UPDATED
"
"
SNIPPETS_DATA
"
"
SNIPPETS_PREVIEW_MODE
"
"
SNIPPETS_RESET
"
"
SNIPPET_BLOCKED
"
"
SUBMIT_EMAIL
"
"
SUBMIT_SIGNIN
"
"
SYSTEM_TICK
"
"
TELEMETRY_IMPRESSION_STATS
"
"
TELEMETRY_USER_EVENT
"
"
TOP_SITES_CANCEL_EDIT
"
"
TOP_SITES_CLOSE_SEARCH_SHORTCUTS_MODAL
"
"
TOP_SITES_EDIT
"
"
TOP_SITES_IMPRESSION_STATS
"
"
TOP_SITES_INSERT
"
"
TOP_SITES_OPEN_SEARCH_SHORTCUTS_MODAL
"
"
TOP_SITES_PIN
"
"
TOP_SITES_PREFS_UPDATED
"
"
TOP_SITES_UNPIN
"
"
TOP_SITES_UPDATED
"
"
TOTAL_BOOKMARKS_REQUEST
"
"
TOTAL_BOOKMARKS_RESPONSE
"
"
UNINIT
"
"
UPDATE_PINNED_SEARCH_SHORTCUTS
"
"
UPDATE_SEARCH_SHORTCUTS
"
"
UPDATE_SECTION_PREFS
"
"
WEBEXT_CLICK
"
"
WEBEXT_DISMISS
"
]
)
{
actionTypes
[
type
]
=
type
;
}
function
_RouteMessage
(
action
options
)
{
const
meta
=
action
.
meta
?
{
.
.
.
action
.
meta
}
:
{
}
;
if
(
!
options
|
|
!
options
.
from
|
|
!
options
.
to
)
{
throw
new
Error
(
"
Routed
Messages
must
have
options
as
the
second
parameter
and
must
at
least
include
a
.
from
and
.
to
property
.
"
)
;
}
[
"
from
"
"
to
"
"
toTarget
"
"
fromTarget
"
"
skipMain
"
"
skipLocal
"
]
.
forEach
(
o
=
>
{
if
(
typeof
options
[
o
]
!
=
=
"
undefined
"
)
{
meta
[
o
]
=
options
[
o
]
;
}
else
if
(
meta
[
o
]
)
{
delete
meta
[
o
]
;
}
}
)
;
return
{
.
.
.
action
meta
}
;
}
function
AlsoToMain
(
action
fromTarget
skipLocal
)
{
return
_RouteMessage
(
action
{
from
:
CONTENT_MESSAGE_TYPE
to
:
MAIN_MESSAGE_TYPE
fromTarget
skipLocal
}
)
;
}
function
OnlyToMain
(
action
fromTarget
)
{
return
AlsoToMain
(
action
fromTarget
true
)
;
}
function
BroadcastToContent
(
action
)
{
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
}
)
;
}
function
AlsoToOneContent
(
action
target
skipMain
)
{
if
(
!
target
)
{
throw
new
Error
(
"
You
must
provide
a
target
ID
as
the
second
parameter
of
AlsoToOneContent
.
If
you
want
to
send
to
all
content
processes
use
BroadcastToContent
"
)
;
}
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
CONTENT_MESSAGE_TYPE
toTarget
:
target
skipMain
}
)
;
}
function
OnlyToOneContent
(
action
target
)
{
return
AlsoToOneContent
(
action
target
true
)
;
}
function
AlsoToPreloaded
(
action
)
{
return
_RouteMessage
(
action
{
from
:
MAIN_MESSAGE_TYPE
to
:
PRELOAD_MESSAGE_TYPE
}
)
;
}
function
UserEvent
(
data
)
{
return
AlsoToMain
(
{
type
:
actionTypes
.
TELEMETRY_USER_EVENT
data
}
)
;
}
function
DiscoveryStreamUserEvent
(
data
)
{
return
AlsoToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_USER_EVENT
data
}
)
;
}
function
ASRouterUserEvent
(
data
)
{
return
AlsoToMain
(
{
type
:
actionTypes
.
AS_ROUTER_TELEMETRY_USER_EVENT
data
}
)
;
}
function
ImpressionStats
(
data
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
TELEMETRY_IMPRESSION_STATS
data
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
function
DiscoveryStreamImpressionStats
(
data
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
DISCOVERY_STREAM_IMPRESSION_STATS
data
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
function
DiscoveryStreamLoadedContent
(
data
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
DISCOVERY_STREAM_LOADED_CONTENT
data
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
function
SetPref
(
name
value
importContext
=
globalImportContext
)
{
const
action
=
{
type
:
actionTypes
.
SET_PREF
data
:
{
name
value
}
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
function
WebExtEvent
(
type
data
importContext
=
globalImportContext
)
{
if
(
!
data
|
|
!
data
.
source
)
{
throw
new
Error
(
'
WebExtEvent
actions
should
include
a
property
"
source
"
the
id
of
the
webextension
that
should
receive
the
event
.
'
)
;
}
const
action
=
{
type
data
}
;
return
importContext
=
=
=
UI_CODE
?
AlsoToMain
(
action
)
:
action
;
}
const
actionCreators
=
{
BroadcastToContent
UserEvent
DiscoveryStreamUserEvent
ASRouterUserEvent
ImpressionStats
AlsoToOneContent
OnlyToOneContent
AlsoToMain
OnlyToMain
AlsoToPreloaded
SetPref
WebExtEvent
DiscoveryStreamImpressionStats
DiscoveryStreamLoadedContent
}
;
const
actionUtils
=
{
isSendToMain
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
action
.
meta
.
to
=
=
=
MAIN_MESSAGE_TYPE
&
&
action
.
meta
.
from
=
=
=
CONTENT_MESSAGE_TYPE
;
}
isBroadcastToContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
!
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
isSendToOneContent
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
if
(
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
&
&
action
.
meta
.
toTarget
)
{
return
true
;
}
return
false
;
}
isSendToPreloaded
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
action
.
meta
.
to
=
=
=
PRELOAD_MESSAGE_TYPE
&
&
action
.
meta
.
from
=
=
=
MAIN_MESSAGE_TYPE
;
}
isFromMain
(
action
)
{
if
(
!
action
.
meta
)
{
return
false
;
}
return
action
.
meta
.
from
=
=
=
MAIN_MESSAGE_TYPE
&
&
action
.
meta
.
to
=
=
=
CONTENT_MESSAGE_TYPE
;
}
getPortIdOfSender
(
action
)
{
return
action
.
meta
&
&
action
.
meta
.
fromTarget
|
|
null
;
}
_RouteMessage
}
;
;
const
MESSAGE_TYPE_LIST
=
[
"
BLOCK_MESSAGE_BY_ID
"
"
USER_ACTION
"
"
IMPRESSION
"
"
TRIGGER
"
"
NEWTAB_MESSAGE_REQUEST
"
"
PBNEWTAB_MESSAGE_REQUEST
"
"
DOORHANGER_TELEMETRY
"
"
TOOLBAR_BADGE_TELEMETRY
"
"
TOOLBAR_PANEL_TELEMETRY
"
"
MOMENTS_PAGE_TELEMETRY
"
"
INFOBAR_TELEMETRY
"
"
SPOTLIGHT_TELEMETRY
"
"
TOAST_NOTIFICATION_TELEMETRY
"
"
AS_ROUTER_TELEMETRY_USER_EVENT
"
"
ADMIN_CONNECT_STATE
"
"
UNBLOCK_MESSAGE_BY_ID
"
"
UNBLOCK_ALL
"
"
BLOCK_BUNDLE
"
"
UNBLOCK_BUNDLE
"
"
DISABLE_PROVIDER
"
"
ENABLE_PROVIDER
"
"
EVALUATE_JEXL_EXPRESSION
"
"
EXPIRE_QUERY_CACHE
"
"
FORCE_ATTRIBUTION
"
"
FORCE_WHATSNEW_PANEL
"
"
CLOSE_WHATSNEW_PANEL
"
"
OVERRIDE_MESSAGE
"
"
MODIFY_MESSAGE_JSON
"
"
RESET_PROVIDER_PREF
"
"
SET_PROVIDER_USER_PREF
"
"
RESET_GROUPS_STATE
"
]
;
const
MESSAGE_TYPE_HASH
=
MESSAGE_TYPE_LIST
.
reduce
(
(
hash
value
)
=
>
{
hash
[
value
]
=
value
;
return
hash
;
}
{
}
)
;
;
const
ASRouterUtils
=
{
addListener
(
listener
)
{
if
(
__webpack_require__
.
g
.
ASRouterAddParentListener
)
{
__webpack_require__
.
g
.
ASRouterAddParentListener
(
listener
)
;
}
}
removeListener
(
listener
)
{
if
(
__webpack_require__
.
g
.
ASRouterRemoveParentListener
)
{
__webpack_require__
.
g
.
ASRouterRemoveParentListener
(
listener
)
;
}
}
sendMessage
(
action
)
{
if
(
__webpack_require__
.
g
.
ASRouterMessage
)
{
return
__webpack_require__
.
g
.
ASRouterMessage
(
action
)
;
}
throw
new
Error
(
Unexpected
call
:
\
n
{
JSON
.
stringify
(
action
null
3
)
}
)
;
}
blockById
(
id
options
)
{
return
ASRouterUtils
.
sendMessage
(
{
type
:
MESSAGE_TYPE_HASH
.
BLOCK_MESSAGE_BY_ID
data
:
{
id
.
.
.
options
}
}
)
;
}
modifyMessageJson
(
content
)
{
return
ASRouterUtils
.
sendMessage
(
{
type
:
MESSAGE_TYPE_HASH
.
MODIFY_MESSAGE_JSON
data
:
{
content
}
}
)
;
}
executeAction
(
button_action
)
{
return
ASRouterUtils
.
sendMessage
(
{
type
:
MESSAGE_TYPE_HASH
.
USER_ACTION
data
:
button_action
}
)
;
}
unblockById
(
id
)
{
return
ASRouterUtils
.
sendMessage
(
{
type
:
MESSAGE_TYPE_HASH
.
UNBLOCK_MESSAGE_BY_ID
data
:
{
id
}
}
)
;
}
blockBundle
(
bundle
)
{
return
ASRouterUtils
.
sendMessage
(
{
type
:
MESSAGE_TYPE_HASH
.
BLOCK_BUNDLE
data
:
{
bundle
}
}
)
;
}
unblockBundle
(
bundle
)
{
return
ASRouterUtils
.
sendMessage
(
{
type
:
MESSAGE_TYPE_HASH
.
UNBLOCK_BUNDLE
data
:
{
bundle
}
}
)
;
}
overrideMessage
(
id
)
{
return
ASRouterUtils
.
sendMessage
(
{
type
:
MESSAGE_TYPE_HASH
.
OVERRIDE_MESSAGE
data
:
{
id
}
}
)
;
}
sendTelemetry
(
ping
)
{
return
ASRouterUtils
.
sendMessage
(
actionCreators
.
ASRouterUserEvent
(
ping
)
)
;
}
getPreviewEndpoint
(
)
{
if
(
__webpack_require__
.
g
.
document
&
&
__webpack_require__
.
g
.
document
.
location
&
&
__webpack_require__
.
g
.
document
.
location
.
href
.
includes
(
"
endpoint
"
)
)
{
const
params
=
new
URLSearchParams
(
__webpack_require__
.
g
.
document
.
location
.
href
.
slice
(
__webpack_require__
.
g
.
document
.
location
.
href
.
indexOf
(
"
endpoint
"
)
)
)
;
try
{
const
endpoint
=
new
URL
(
params
.
get
(
"
endpoint
"
)
)
;
return
{
url
:
endpoint
.
href
snippetId
:
params
.
get
(
"
snippetId
"
)
theme
:
this
.
getPreviewTheme
(
)
dir
:
this
.
getPreviewDir
(
)
}
;
}
catch
(
e
)
{
}
}
return
null
;
}
getPreviewTheme
(
)
{
return
new
URLSearchParams
(
__webpack_require__
.
g
.
document
.
location
.
href
.
slice
(
__webpack_require__
.
g
.
document
.
location
.
href
.
indexOf
(
"
theme
"
)
)
)
.
get
(
"
theme
"
)
;
}
getPreviewDir
(
)
{
return
new
URLSearchParams
(
__webpack_require__
.
g
.
document
.
location
.
href
.
slice
(
__webpack_require__
.
g
.
document
.
location
.
href
.
indexOf
(
"
dir
"
)
)
)
.
get
(
"
dir
"
)
;
}
}
;
;
const
external_ReactRedux_namespaceObject
=
ReactRedux
;
;
const
external_React_namespaceObject
=
React
;
var
external_React_default
=
__webpack_require__
.
n
(
external_React_namespaceObject
)
;
;
class
SimpleHashRouter
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onHashChange
=
this
.
onHashChange
.
bind
(
this
)
;
this
.
state
=
{
hash
:
__webpack_require__
.
g
.
location
.
hash
}
;
}
onHashChange
(
)
{
this
.
setState
(
{
hash
:
__webpack_require__
.
g
.
location
.
hash
}
)
;
}
componentWillMount
(
)
{
__webpack_require__
.
g
.
addEventListener
(
"
hashchange
"
this
.
onHashChange
)
;
}
componentWillUnmount
(
)
{
__webpack_require__
.
g
.
removeEventListener
(
"
hashchange
"
this
.
onHashChange
)
;
}
render
(
)
{
const
[
.
.
.
routes
]
=
this
.
state
.
hash
.
split
(
"
-
"
)
;
return
external_React_default
(
)
.
cloneElement
(
this
.
props
.
children
{
location
:
{
hash
:
this
.
state
.
hash
routes
}
}
)
;
}
}
;
function
_extends
(
)
{
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
_extends
.
apply
(
this
arguments
)
;
}
const
Row
=
props
=
>
external_React_default
(
)
.
createElement
(
"
tr
"
_extends
(
{
className
:
"
message
-
item
"
}
props
)
props
.
children
)
;
function
relativeTime
(
timestamp
)
{
if
(
!
timestamp
)
{
return
"
"
;
}
const
seconds
=
Math
.
floor
(
(
Date
.
now
(
)
-
timestamp
)
/
1000
)
;
const
minutes
=
Math
.
floor
(
(
Date
.
now
(
)
-
timestamp
)
/
60000
)
;
if
(
seconds
<
2
)
{
return
"
just
now
"
;
}
else
if
(
seconds
<
60
)
{
return
{
seconds
}
seconds
ago
;
}
else
if
(
minutes
=
=
=
1
)
{
return
"
1
minute
ago
"
;
}
else
if
(
minutes
<
600
)
{
return
{
minutes
}
minutes
ago
;
}
return
new
Date
(
timestamp
)
.
toLocaleString
(
)
;
}
const
LAYOUT_VARIANTS
=
{
basic
:
"
Basic
default
layout
(
on
by
default
in
nightly
)
"
staging_spocs
:
"
A
layout
with
all
spocs
shown
"
"
dev
-
test
-
all
"
:
"
A
little
bit
of
everything
.
Good
layout
for
testing
all
components
"
"
dev
-
test
-
feeds
"
:
"
Stress
testing
for
slow
feeds
"
}
;
class
ToggleStoryButton
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
handleClick
=
this
.
handleClick
.
bind
(
this
)
;
}
handleClick
(
)
{
this
.
props
.
onClick
(
this
.
props
.
story
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
button
"
{
onClick
:
this
.
handleClick
}
"
collapse
/
open
"
)
;
}
}
class
ToggleMessageJSON
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
handleClick
=
this
.
handleClick
.
bind
(
this
)
;
}
handleClick
(
)
{
this
.
props
.
toggleJSON
(
this
.
props
.
msgId
)
;
}
render
(
)
{
let
iconName
=
this
.
props
.
isCollapsed
?
"
icon
icon
-
arrowhead
-
forward
-
small
"
:
"
icon
icon
-
arrowhead
-
down
-
small
"
;
return
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
clearButton
"
onClick
:
this
.
handleClick
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
iconName
}
)
)
;
}
}
class
TogglePrefCheckbox
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onChange
=
this
.
onChange
.
bind
(
this
)
;
}
onChange
(
event
)
{
this
.
props
.
onChange
(
this
.
props
.
pref
event
.
target
.
checked
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
checked
:
this
.
props
.
checked
onChange
:
this
.
onChange
disabled
:
this
.
props
.
disabled
}
)
"
"
this
.
props
.
pref
"
"
)
;
}
}
class
Personalization
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
togglePersonalization
=
this
.
togglePersonalization
.
bind
(
this
)
;
}
togglePersonalization
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_PERSONALIZATION_TOGGLE
}
)
)
;
}
render
(
)
{
const
{
lastUpdated
initialized
}
=
this
.
props
.
state
.
Personalization
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
colSpan
:
"
2
"
}
external_React_default
(
)
.
createElement
(
TogglePrefCheckbox
{
checked
:
this
.
props
.
personalized
pref
:
"
personalized
"
onChange
:
this
.
togglePersonalization
}
)
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Personalization
Last
Updated
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
lastUpdated
)
|
|
"
(
no
data
)
"
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Personalization
Initialized
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
initialized
?
"
true
"
:
"
false
"
)
)
)
)
)
;
}
}
class
DiscoveryStreamAdmin
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
restorePrefDefaults
=
this
.
restorePrefDefaults
.
bind
(
this
)
;
this
.
setConfigValue
=
this
.
setConfigValue
.
bind
(
this
)
;
this
.
expireCache
=
this
.
expireCache
.
bind
(
this
)
;
this
.
refreshCache
=
this
.
refreshCache
.
bind
(
this
)
;
this
.
idleDaily
=
this
.
idleDaily
.
bind
(
this
)
;
this
.
systemTick
=
this
.
systemTick
.
bind
(
this
)
;
this
.
syncRemoteSettings
=
this
.
syncRemoteSettings
.
bind
(
this
)
;
this
.
changeEndpointVariant
=
this
.
changeEndpointVariant
.
bind
(
this
)
;
this
.
onStoryToggle
=
this
.
onStoryToggle
.
bind
(
this
)
;
this
.
state
=
{
toggledStories
:
{
}
}
;
}
setConfigValue
(
name
value
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_CONFIG_SET_VALUE
data
:
{
name
value
}
}
)
)
;
}
restorePrefDefaults
(
event
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_CONFIG_RESET_DEFAULTS
}
)
)
;
}
refreshCache
(
)
{
const
{
config
}
=
this
.
props
.
state
.
DiscoveryStream
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_CONFIG_CHANGE
data
:
config
}
)
)
;
}
dispatchSimpleAction
(
type
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
}
)
)
;
}
systemTick
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_SYSTEM_TICK
)
;
}
expireCache
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_EXPIRE_CACHE
)
;
}
idleDaily
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_IDLE_DAILY
)
;
}
syncRemoteSettings
(
)
{
this
.
dispatchSimpleAction
(
actionTypes
.
DISCOVERY_STREAM_DEV_SYNC_RS
)
;
}
changeEndpointVariant
(
event
)
{
const
endpoint
=
this
.
props
.
state
.
DiscoveryStream
.
config
.
layout_endpoint
;
if
(
endpoint
)
{
this
.
setConfigValue
(
"
layout_endpoint
"
endpoint
.
replace
(
/
layout_variant
=
.
+
/
layout_variant
=
{
event
.
target
.
value
}
)
)
;
}
}
renderComponent
(
width
component
)
{
return
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Type
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
component
.
type
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Width
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
width
)
)
component
.
feed
&
&
this
.
renderFeed
(
component
.
feed
)
)
)
;
}
isCurrentVariant
(
id
)
{
const
endpoint
=
this
.
props
.
state
.
DiscoveryStream
.
config
.
layout_endpoint
;
const
isMatch
=
endpoint
&
&
!
!
endpoint
.
match
(
layout_variant
=
{
id
}
)
;
return
isMatch
;
}
renderFeedData
(
url
)
{
const
{
feeds
}
=
this
.
props
.
state
.
DiscoveryStream
;
const
feed
=
feeds
.
data
[
url
]
.
data
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h4
"
null
"
Feed
url
:
"
url
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
feed
.
recommendations
.
map
(
story
=
>
this
.
renderStoryData
(
story
)
)
)
)
)
;
}
renderFeedsData
(
)
{
const
{
feeds
}
=
this
.
props
.
state
.
DiscoveryStream
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
Object
.
keys
(
feeds
.
data
)
.
map
(
url
=
>
this
.
renderFeedData
(
url
)
)
)
;
}
renderSpocs
(
)
{
const
{
spocs
}
=
this
.
props
.
state
.
DiscoveryStream
;
let
spocsData
=
[
]
;
if
(
spocs
.
data
&
&
spocs
.
data
.
spocs
&
&
spocs
.
data
.
spocs
.
items
)
{
spocsData
=
spocs
.
data
.
spocs
.
items
|
|
[
]
;
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
spocs_endpoint
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
spocs
.
spocs_endpoint
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Data
last
fetched
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
spocs
.
lastUpdated
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h4
"
null
"
Spoc
data
"
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
spocsData
.
map
(
spoc
=
>
this
.
renderStoryData
(
spoc
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h4
"
null
"
Spoc
frequency
caps
"
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
spocs
.
frequency_caps
.
map
(
spoc
=
>
this
.
renderStoryData
(
spoc
)
)
)
)
)
;
}
onStoryToggle
(
story
)
{
const
{
toggledStories
}
=
this
.
state
;
this
.
setState
(
{
toggledStories
:
{
.
.
.
toggledStories
[
story
.
id
]
:
!
toggledStories
[
story
.
id
]
}
}
)
;
}
renderStoryData
(
story
)
{
let
storyData
=
"
"
;
if
(
this
.
state
.
toggledStories
[
story
.
id
]
)
{
storyData
=
JSON
.
stringify
(
story
null
2
)
;
}
return
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
"
message
-
item
"
key
:
story
.
id
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
message
-
id
"
}
external_React_default
(
)
.
createElement
(
"
span
"
null
story
.
id
"
"
external_React_default
(
)
.
createElement
(
"
br
"
null
)
)
external_React_default
(
)
.
createElement
(
ToggleStoryButton
{
story
:
story
onClick
:
this
.
onStoryToggle
}
)
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
message
-
summary
"
}
external_React_default
(
)
.
createElement
(
"
pre
"
null
storyData
)
)
)
;
}
renderFeed
(
feed
)
{
const
{
feeds
}
=
this
.
props
.
state
.
DiscoveryStream
;
if
(
!
feed
.
url
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Feed
url
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
feed
.
url
)
)
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Data
last
fetched
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
feeds
.
data
[
feed
.
url
]
?
feeds
.
data
[
feed
.
url
]
.
lastUpdated
:
null
)
|
|
"
(
no
data
)
"
)
)
)
;
}
render
(
)
{
const
prefToggles
=
"
enabled
hardcoded_layout
show_spocs
collapsible
"
.
split
(
"
"
)
;
const
{
config
lastUpdated
layout
}
=
this
.
props
.
state
.
DiscoveryStream
;
const
personalized
=
this
.
props
.
otherPrefs
[
"
discoverystream
.
personalization
.
enabled
"
]
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
restorePrefDefaults
}
"
Restore
Pref
Defaults
"
)
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
refreshCache
}
"
Refresh
Cache
"
)
external_React_default
(
)
.
createElement
(
"
br
"
null
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
expireCache
}
"
Expire
Cache
"
)
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
systemTick
}
"
Trigger
System
Tick
"
)
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
idleDaily
}
"
Trigger
Idle
Daily
"
)
external_React_default
(
)
.
createElement
(
"
br
"
null
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
syncRemoteSettings
}
"
Sync
Remote
Settings
"
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
prefToggles
.
map
(
pref
=
>
external_React_default
(
)
.
createElement
(
Row
{
key
:
pref
}
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
TogglePrefCheckbox
{
checked
:
config
[
pref
]
pref
:
pref
onChange
:
this
.
setConfigValue
}
)
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Endpoint
variant
"
)
external_React_default
(
)
.
createElement
(
"
p
"
null
"
You
can
also
change
this
manually
by
changing
this
pref
:
"
"
"
external_React_default
(
)
.
createElement
(
"
code
"
null
"
browser
.
newtabpage
.
activity
-
stream
.
discoverystream
.
config
"
)
)
external_React_default
(
)
.
createElement
(
"
table
"
{
style
:
config
.
enabled
&
&
!
config
.
hardcoded_layout
?
null
:
{
opacity
:
0
.
5
}
}
external_React_default
(
)
.
createElement
(
"
tbody
"
null
Object
.
keys
(
LAYOUT_VARIANTS
)
.
map
(
id
=
>
external_React_default
(
)
.
createElement
(
Row
{
key
:
id
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
radio
"
value
:
id
checked
:
this
.
isCurrentVariant
(
id
)
onChange
:
this
.
changeEndpointVariant
}
)
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
id
)
external_React_default
(
)
.
createElement
(
"
td
"
null
LAYOUT_VARIANTS
[
id
]
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Caching
info
"
)
external_React_default
(
)
.
createElement
(
"
table
"
{
style
:
config
.
enabled
?
null
:
{
opacity
:
0
.
5
}
}
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
Row
null
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Data
last
fetched
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
lastUpdated
)
|
|
"
(
no
data
)
"
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Layout
"
)
layout
.
map
(
(
row
rowIndex
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
row
-
{
rowIndex
}
}
row
.
components
.
map
(
(
component
componentIndex
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
component
-
{
componentIndex
}
className
:
"
ds
-
component
"
}
this
.
renderComponent
(
row
.
width
component
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Personalization
"
)
external_React_default
(
)
.
createElement
(
Personalization
{
personalized
:
personalized
dispatch
:
this
.
props
.
dispatch
state
:
{
Personalization
:
this
.
props
.
state
.
Personalization
}
}
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Spocs
"
)
this
.
renderSpocs
(
)
external_React_default
(
)
.
createElement
(
"
h3
"
null
"
Feeds
Data
"
)
this
.
renderFeedsData
(
)
)
;
}
}
class
ASRouterAdminInner
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
handleEnabledToggle
=
this
.
handleEnabledToggle
.
bind
(
this
)
;
this
.
handleUserPrefToggle
=
this
.
handleUserPrefToggle
.
bind
(
this
)
;
this
.
onChangeMessageFilter
=
this
.
onChangeMessageFilter
.
bind
(
this
)
;
this
.
onChangeMessageGroupsFilter
=
this
.
onChangeMessageGroupsFilter
.
bind
(
this
)
;
this
.
unblockAll
=
this
.
unblockAll
.
bind
(
this
)
;
this
.
handleClearAllImpressionsByProvider
=
this
.
handleClearAllImpressionsByProvider
.
bind
(
this
)
;
this
.
handleExpressionEval
=
this
.
handleExpressionEval
.
bind
(
this
)
;
this
.
onChangeTargetingParameters
=
this
.
onChangeTargetingParameters
.
bind
(
this
)
;
this
.
onChangeAttributionParameters
=
this
.
onChangeAttributionParameters
.
bind
(
this
)
;
this
.
setAttribution
=
this
.
setAttribution
.
bind
(
this
)
;
this
.
onCopyTargetingParams
=
this
.
onCopyTargetingParams
.
bind
(
this
)
;
this
.
onNewTargetingParams
=
this
.
onNewTargetingParams
.
bind
(
this
)
;
this
.
resetPanel
=
this
.
resetPanel
.
bind
(
this
)
;
this
.
toggleJSON
=
this
.
toggleJSON
.
bind
(
this
)
;
this
.
toggleAllMessages
=
this
.
toggleAllMessages
.
bind
(
this
)
;
this
.
resetGroups
=
this
.
resetGroups
.
bind
(
this
)
;
this
.
onMessageFromParent
=
this
.
onMessageFromParent
.
bind
(
this
)
;
this
.
setStateFromParent
=
this
.
setStateFromParent
.
bind
(
this
)
;
this
.
setState
=
this
.
setState
.
bind
(
this
)
;
this
.
state
=
{
messageFilter
:
"
all
"
messageGroupsFilter
:
"
all
"
collapsedMessages
:
[
]
modifiedMessages
:
[
]
evaluationStatus
:
{
}
stringTargetingParameters
:
null
newStringTargetingParameters
:
null
copiedToClipboard
:
false
attributionParameters
:
{
source
:
"
addons
.
mozilla
.
org
"
medium
:
"
referral
"
campaign
:
"
non
-
fx
-
button
"
content
:
rta
:
{
btoa
(
"
uBlock0
raymondhill
.
net
"
)
}
experiment
:
"
ua
-
onboarding
"
variation
:
"
chrome
"
ua
:
"
Google
Chrome
123
"
dltoken
:
"
00000000
-
0000
-
0000
-
0000
-
000000000000
"
}
}
;
}
onMessageFromParent
(
{
type
data
}
)
{
switch
(
type
)
{
case
"
UpdateAdminState
"
:
{
this
.
setStateFromParent
(
data
)
;
break
;
}
}
}
setStateFromParent
(
data
)
{
this
.
setState
(
data
)
;
if
(
!
this
.
state
.
stringTargetingParameters
)
{
const
stringTargetingParameters
=
{
}
;
for
(
const
param
of
Object
.
keys
(
data
.
targetingParameters
)
)
{
stringTargetingParameters
[
param
]
=
JSON
.
stringify
(
data
.
targetingParameters
[
param
]
null
2
)
;
}
this
.
setState
(
{
stringTargetingParameters
}
)
;
}
}
componentWillMount
(
)
{
ASRouterUtils
.
addListener
(
this
.
onMessageFromParent
)
;
const
endpoint
=
ASRouterUtils
.
getPreviewEndpoint
(
)
;
ASRouterUtils
.
sendMessage
(
{
type
:
"
ADMIN_CONNECT_STATE
"
data
:
{
endpoint
}
}
)
.
then
(
this
.
setStateFromParent
)
;
}
handleBlock
(
msg
)
{
return
(
)
=
>
ASRouterUtils
.
blockById
(
msg
.
id
)
;
}
handleUnblock
(
msg
)
{
return
(
)
=
>
ASRouterUtils
.
unblockById
(
msg
.
id
)
;
}
resetJSON
(
msg
)
{
document
.
getElementById
(
{
msg
.
id
}
-
textarea
)
.
value
=
JSON
.
stringify
(
msg
null
2
)
;
let
index
=
this
.
state
.
modifiedMessages
.
indexOf
(
msg
.
id
)
;
this
.
setState
(
prevState
=
>
(
{
modifiedMessages
:
[
.
.
.
prevState
.
modifiedMessages
.
slice
(
0
index
)
.
.
.
prevState
.
modifiedMessages
.
slice
(
index
+
1
)
]
}
)
)
;
}
resetAllJSON
(
)
{
let
messageCheckboxes
=
document
.
querySelectorAll
(
'
input
[
type
=
"
checkbox
"
]
'
)
;
for
(
const
checkbox
of
messageCheckboxes
)
{
let
trimmedId
=
checkbox
.
id
.
replace
(
"
checkbox
"
"
"
)
;
let
message
=
this
.
state
.
messages
.
filter
(
msg
=
>
msg
.
id
=
=
=
trimmedId
)
;
let
msgId
=
message
[
0
]
.
id
;
document
.
getElementById
(
{
msgId
}
-
textarea
)
.
value
=
JSON
.
stringify
(
message
[
0
]
null
2
)
;
}
this
.
setState
(
{
WNMessages
:
[
]
}
)
;
}
resetPanel
(
)
{
this
.
resetAllJSON
(
)
;
}
handleOverride
(
id
)
{
return
(
)
=
>
ASRouterUtils
.
overrideMessage
(
id
)
.
then
(
state
=
>
{
this
.
setStateFromParent
(
state
)
;
this
.
props
.
notifyContent
(
{
message
:
state
.
message
}
)
;
}
)
;
}
expireCache
(
)
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
EXPIRE_QUERY_CACHE
"
}
)
;
}
resetPref
(
)
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
RESET_PROVIDER_PREF
"
}
)
;
}
resetGroups
(
id
value
)
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
RESET_GROUPS_STATE
"
}
)
.
then
(
this
.
setStateFromParent
)
;
}
handleExpressionEval
(
)
{
const
context
=
{
}
;
for
(
const
param
of
Object
.
keys
(
this
.
state
.
stringTargetingParameters
)
)
{
const
value
=
this
.
state
.
stringTargetingParameters
[
param
]
;
context
[
param
]
=
value
?
JSON
.
parse
(
value
)
:
null
;
}
ASRouterUtils
.
sendMessage
(
{
type
:
"
EVALUATE_JEXL_EXPRESSION
"
data
:
{
expression
:
this
.
refs
.
expressionInput
.
value
context
}
}
)
.
then
(
this
.
setStateFromParent
)
;
}
onChangeTargetingParameters
(
event
)
{
const
{
name
}
=
event
.
target
;
const
{
value
}
=
event
.
target
;
this
.
setState
(
(
{
stringTargetingParameters
}
)
=
>
{
let
targetingParametersError
=
null
;
const
updatedParameters
=
{
.
.
.
stringTargetingParameters
}
;
updatedParameters
[
name
]
=
value
;
try
{
JSON
.
parse
(
value
)
;
}
catch
(
e
)
{
console
.
log
(
Error
parsing
value
of
parameter
{
name
}
)
;
targetingParametersError
=
{
id
:
name
}
;
}
return
{
copiedToClipboard
:
false
evaluationStatus
:
{
}
stringTargetingParameters
:
updatedParameters
targetingParametersError
}
;
}
)
;
}
unblockAll
(
)
{
return
ASRouterUtils
.
sendMessage
(
{
type
:
"
UNBLOCK_ALL
"
}
)
.
then
(
this
.
setStateFromParent
)
;
}
handleClearAllImpressionsByProvider
(
)
{
const
providerId
=
this
.
state
.
messageFilter
;
if
(
!
providerId
)
{
return
;
}
const
userPrefInfo
=
this
.
state
.
userPrefs
;
const
isUserEnabled
=
providerId
in
userPrefInfo
?
userPrefInfo
[
providerId
]
:
true
;
ASRouterUtils
.
sendMessage
(
{
type
:
"
DISABLE_PROVIDER
"
data
:
providerId
}
)
;
if
(
!
isUserEnabled
)
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
SET_PROVIDER_USER_PREF
"
data
:
{
id
:
providerId
value
:
true
}
}
)
;
}
ASRouterUtils
.
sendMessage
(
{
type
:
"
ENABLE_PROVIDER
"
data
:
providerId
}
)
;
}
handleEnabledToggle
(
event
)
{
const
provider
=
this
.
state
.
providerPrefs
.
find
(
p
=
>
p
.
id
=
=
=
event
.
target
.
dataset
.
provider
)
;
const
userPrefInfo
=
this
.
state
.
userPrefs
;
const
isUserEnabled
=
provider
.
id
in
userPrefInfo
?
userPrefInfo
[
provider
.
id
]
:
true
;
const
isSystemEnabled
=
provider
.
enabled
;
const
isEnabling
=
event
.
target
.
checked
;
if
(
isEnabling
)
{
if
(
!
isUserEnabled
)
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
SET_PROVIDER_USER_PREF
"
data
:
{
id
:
provider
.
id
value
:
true
}
}
)
;
}
if
(
!
isSystemEnabled
)
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
ENABLE_PROVIDER
"
data
:
provider
.
id
}
)
;
}
}
else
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
DISABLE_PROVIDER
"
data
:
provider
.
id
}
)
;
}
this
.
setState
(
{
messageFilter
:
"
all
"
}
)
;
}
handleUserPrefToggle
(
event
)
{
const
action
=
{
type
:
"
SET_PROVIDER_USER_PREF
"
data
:
{
id
:
event
.
target
.
dataset
.
provider
value
:
event
.
target
.
checked
}
}
;
ASRouterUtils
.
sendMessage
(
action
)
;
this
.
setState
(
{
messageFilter
:
"
all
"
}
)
;
}
onChangeMessageFilter
(
event
)
{
this
.
setState
(
{
messageFilter
:
event
.
target
.
value
}
)
;
}
onChangeMessageGroupsFilter
(
event
)
{
this
.
setState
(
{
messageGroupsFilter
:
event
.
target
.
value
}
)
;
}
onCopyTargetingParams
(
event
)
{
const
stringTargetingParameters
=
{
.
.
.
this
.
state
.
stringTargetingParameters
}
;
for
(
const
key
of
Object
.
keys
(
stringTargetingParameters
)
)
{
if
(
stringTargetingParameters
[
key
]
=
=
=
undefined
)
{
stringTargetingParameters
[
key
]
=
null
;
}
}
const
setClipboardData
=
e
=
>
{
e
.
preventDefault
(
)
;
e
.
clipboardData
.
setData
(
"
text
"
JSON
.
stringify
(
stringTargetingParameters
null
2
)
)
;
document
.
removeEventListener
(
"
copy
"
setClipboardData
)
;
this
.
setState
(
{
copiedToClipboard
:
true
}
)
;
}
;
document
.
addEventListener
(
"
copy
"
setClipboardData
)
;
document
.
execCommand
(
"
copy
"
)
;
}
onNewTargetingParams
(
event
)
{
this
.
setState
(
{
newStringTargetingParameters
:
event
.
target
.
value
}
)
;
event
.
target
.
classList
.
remove
(
"
errorState
"
)
;
this
.
refs
.
targetingParamsEval
.
innerText
=
"
"
;
try
{
const
stringTargetingParameters
=
JSON
.
parse
(
event
.
target
.
value
)
;
this
.
setState
(
{
stringTargetingParameters
}
)
;
}
catch
(
e
)
{
event
.
target
.
classList
.
add
(
"
errorState
"
)
;
this
.
refs
.
targetingParamsEval
.
innerText
=
e
.
message
;
}
}
toggleJSON
(
msgId
)
{
if
(
this
.
state
.
collapsedMessages
.
includes
(
msgId
)
)
{
let
index
=
this
.
state
.
collapsedMessages
.
indexOf
(
msgId
)
;
this
.
setState
(
prevState
=
>
(
{
collapsedMessages
:
[
.
.
.
prevState
.
collapsedMessages
.
slice
(
0
index
)
.
.
.
prevState
.
collapsedMessages
.
slice
(
index
+
1
)
]
}
)
)
;
}
else
{
this
.
setState
(
prevState
=
>
(
{
collapsedMessages
:
prevState
.
collapsedMessages
.
concat
(
msgId
)
}
)
)
;
}
}
handleChange
(
msgId
)
{
if
(
!
this
.
state
.
modifiedMessages
.
includes
(
msgId
)
)
{
this
.
setState
(
prevState
=
>
(
{
modifiedMessages
:
prevState
.
modifiedMessages
.
concat
(
msgId
)
}
)
)
;
}
}
renderMessageItem
(
msg
)
{
const
isBlockedByGroup
=
this
.
state
.
groups
.
filter
(
group
=
>
msg
.
groups
.
includes
(
group
.
id
)
)
.
some
(
group
=
>
!
group
.
enabled
)
;
const
msgProvider
=
this
.
state
.
providers
.
find
(
provider
=
>
provider
.
id
=
=
=
msg
.
provider
)
|
|
{
}
;
const
isProviderExcluded
=
msgProvider
.
exclude
&
&
msgProvider
.
exclude
.
includes
(
msg
.
id
)
;
const
isMessageBlocked
=
this
.
state
.
messageBlockList
.
includes
(
msg
.
id
)
|
|
this
.
state
.
messageBlockList
.
includes
(
msg
.
campaign
)
;
const
isBlocked
=
isMessageBlocked
|
|
isBlockedByGroup
|
|
isProviderExcluded
;
const
impressions
=
this
.
state
.
messageImpressions
[
msg
.
id
]
?
this
.
state
.
messageImpressions
[
msg
.
id
]
.
length
:
0
;
const
isCollapsed
=
this
.
state
.
collapsedMessages
.
includes
(
msg
.
id
)
;
const
isModified
=
this
.
state
.
modifiedMessages
.
includes
(
msg
.
id
)
;
let
itemClassName
=
"
message
-
item
"
;
if
(
isBlocked
)
{
itemClassName
+
=
"
blocked
"
;
}
return
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
itemClassName
key
:
{
msg
.
id
}
-
{
msg
.
provider
}
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
message
-
id
"
}
external_React_default
(
)
.
createElement
(
"
span
"
null
msg
.
id
"
"
external_React_default
(
)
.
createElement
(
"
br
"
null
)
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
ToggleMessageJSON
{
msgId
:
{
msg
.
id
}
toggleJSON
:
this
.
toggleJSON
isCollapsed
:
isCollapsed
}
)
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
button
-
column
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
button
{
isBlocked
?
"
"
:
"
primary
"
}
onClick
:
isBlocked
?
this
.
handleUnblock
(
msg
)
:
this
.
handleBlock
(
msg
)
}
isBlocked
?
"
Unblock
"
:
"
Block
"
)
isBlocked
?
null
:
isModified
?
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
restore
"
onClick
:
e
=
>
this
.
resetJSON
(
msg
)
}
"
Reset
"
)
:
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
show
"
onClick
:
this
.
handleOverride
(
msg
.
id
)
}
"
Show
"
)
isBlocked
?
null
:
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
modify
"
onClick
:
e
=
>
this
.
modifyJson
(
msg
)
}
"
Modify
"
)
external_React_default
(
)
.
createElement
(
"
br
"
null
)
"
(
"
impressions
"
impressions
)
"
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
message
-
summary
"
}
isBlocked
&
&
external_React_default
(
)
.
createElement
(
"
tr
"
null
"
Block
reason
:
"
isBlockedByGroup
&
&
"
Blocked
by
group
"
isProviderExcluded
&
&
"
Excluded
by
provider
"
isMessageBlocked
&
&
"
Message
blocked
"
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
pre
"
{
className
:
isCollapsed
?
"
collapsed
"
:
"
expanded
"
}
external_React_default
(
)
.
createElement
(
"
textarea
"
{
id
:
{
msg
.
id
}
-
textarea
name
:
msg
.
id
className
:
"
general
-
textarea
"
disabled
:
isBlocked
onChange
:
e
=
>
this
.
handleChange
(
msg
.
id
)
}
JSON
.
stringify
(
msg
null
2
)
)
)
)
)
)
;
}
modifyJson
(
content
)
{
const
message
=
JSON
.
parse
(
document
.
getElementById
(
{
content
.
id
}
-
textarea
)
.
value
)
;
return
ASRouterUtils
.
modifyMessageJson
(
message
)
.
then
(
state
=
>
{
this
.
setStateFromParent
(
state
)
;
this
.
props
.
notifyContent
(
{
message
:
state
.
message
}
)
;
}
)
;
}
toggleAllMessages
(
messagesToShow
)
{
if
(
this
.
state
.
collapsedMessages
.
length
)
{
this
.
setState
(
{
collapsedMessages
:
[
]
}
)
;
}
else
{
Array
.
prototype
.
forEach
.
call
(
messagesToShow
msg
=
>
{
this
.
setState
(
prevState
=
>
(
{
collapsedMessages
:
prevState
.
collapsedMessages
.
concat
(
msg
.
id
)
}
)
)
;
}
)
;
}
}
renderMessages
(
)
{
if
(
!
this
.
state
.
messages
)
{
return
null
;
}
const
messagesToShow
=
this
.
state
.
messageFilter
=
=
=
"
all
"
?
this
.
state
.
messages
:
this
.
state
.
messages
.
filter
(
message
=
>
message
.
provider
=
=
=
this
.
state
.
messageFilter
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
ASRouterButton
slim
"
onClick
:
e
=
>
this
.
toggleAllMessages
(
messagesToShow
)
}
"
Collapse
/
Expand
All
"
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
helpLink
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
info
"
}
)
"
"
external_React_default
(
)
.
createElement
(
"
span
"
null
"
To
modify
a
message
change
the
JSON
and
click
'
Modify
'
to
see
your
changes
.
Click
'
Reset
'
to
restore
the
JSON
to
the
original
.
"
)
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
messagesToShow
.
map
(
msg
=
>
this
.
renderMessageItem
(
msg
)
)
)
)
)
;
}
renderMessagesByGroup
(
)
{
if
(
!
this
.
state
.
messages
)
{
return
null
;
}
const
messagesToShow
=
this
.
state
.
messageGroupsFilter
=
=
=
"
all
"
?
this
.
state
.
messages
.
filter
(
m
=
>
m
.
groups
.
length
)
:
this
.
state
.
messages
.
filter
(
message
=
>
message
.
groups
.
includes
(
this
.
state
.
messageGroupsFilter
)
)
;
return
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
messagesToShow
.
map
(
msg
=
>
this
.
renderMessageItem
(
msg
)
)
)
)
;
}
renderMessageFilter
(
)
{
if
(
!
this
.
state
.
providers
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
p
"
null
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
unblock
-
all
ASRouterButton
test
-
only
"
onClick
:
this
.
unblockAll
}
"
Unblock
All
Snippets
"
)
"
Show
messages
from
"
external_React_default
(
)
.
createElement
(
"
select
"
{
value
:
this
.
state
.
messageFilter
onChange
:
this
.
onChangeMessageFilter
}
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
all
"
}
"
all
providers
"
)
this
.
state
.
providers
.
map
(
provider
=
>
external_React_default
(
)
.
createElement
(
"
option
"
{
key
:
provider
.
id
value
:
provider
.
id
}
provider
.
id
)
)
)
this
.
state
.
messageFilter
!
=
=
"
all
"
&
&
!
this
.
state
.
messageFilter
.
includes
(
"
_local_testing
"
)
?
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
messages
-
reset
"
onClick
:
this
.
handleClearAllImpressionsByProvider
}
"
Reset
All
"
)
:
null
)
;
}
renderMessageGroupsFilter
(
)
{
if
(
!
this
.
state
.
groups
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
p
"
null
"
Show
messages
from
"
external_React_default
(
)
.
createElement
(
"
select
"
{
value
:
this
.
state
.
messageGroupsFilter
onChange
:
this
.
onChangeMessageGroupsFilter
}
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
all
"
}
"
all
groups
"
)
this
.
state
.
groups
.
map
(
group
=
>
external_React_default
(
)
.
createElement
(
"
option
"
{
key
:
group
.
id
value
:
group
.
id
}
group
.
id
)
)
)
)
;
}
renderTableHead
(
)
{
return
external_React_default
(
)
.
createElement
(
"
thead
"
null
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
"
message
-
item
"
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Provider
ID
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
Source
"
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Cohort
"
)
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Last
Updated
"
)
)
)
;
}
renderProviders
(
)
{
const
providersConfig
=
this
.
state
.
providerPrefs
;
const
providerInfo
=
this
.
state
.
providers
;
const
userPrefInfo
=
this
.
state
.
userPrefs
;
return
external_React_default
(
)
.
createElement
(
"
table
"
null
this
.
renderTableHead
(
)
external_React_default
(
)
.
createElement
(
"
tbody
"
null
providersConfig
.
map
(
(
provider
i
)
=
>
{
const
isTestProvider
=
provider
.
id
.
includes
(
"
_local_testing
"
)
;
const
info
=
providerInfo
.
find
(
p
=
>
p
.
id
=
=
=
provider
.
id
)
|
|
{
}
;
const
isUserEnabled
=
provider
.
id
in
userPrefInfo
?
userPrefInfo
[
provider
.
id
]
:
true
;
const
isSystemEnabled
=
isTestProvider
|
|
provider
.
enabled
;
let
label
=
"
local
"
;
if
(
provider
.
type
=
=
=
"
remote
"
)
{
label
=
external_React_default
(
)
.
createElement
(
"
span
"
null
"
endpoint
(
"
external_React_default
(
)
.
createElement
(
"
a
"
{
className
:
"
providerUrl
"
target
:
"
_blank
"
href
:
info
.
url
rel
:
"
noopener
noreferrer
"
}
info
.
url
)
"
)
"
)
;
}
else
if
(
provider
.
type
=
=
=
"
remote
-
settings
"
)
{
label
=
remote
settings
(
{
provider
.
bucket
}
)
;
}
else
if
(
provider
.
type
=
=
=
"
remote
-
experiments
"
)
{
label
=
external_React_default
(
)
.
createElement
(
"
span
"
null
"
remote
settings
(
"
external_React_default
(
)
.
createElement
(
"
a
"
{
className
:
"
providerUrl
"
target
:
"
_blank
"
href
:
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
/
buckets
/
main
/
collections
/
nimbus
-
desktop
-
experiments
/
records
"
rel
:
"
noopener
noreferrer
"
}
"
nimbus
-
desktop
-
experiments
"
)
"
)
"
)
;
}
let
reasonsDisabled
=
[
]
;
if
(
!
isSystemEnabled
)
{
reasonsDisabled
.
push
(
"
system
pref
"
)
;
}
if
(
!
isUserEnabled
)
{
reasonsDisabled
.
push
(
"
user
pref
"
)
;
}
if
(
reasonsDisabled
.
length
)
{
label
=
disabled
via
{
reasonsDisabled
.
join
(
"
"
)
}
;
}
return
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
"
message
-
item
"
key
:
i
}
external_React_default
(
)
.
createElement
(
"
td
"
null
isTestProvider
?
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
disabled
:
true
readOnly
:
true
checked
:
true
}
)
:
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
"
data
-
provider
"
:
provider
.
id
checked
:
isUserEnabled
&
&
isSystemEnabled
onChange
:
this
.
handleEnabledToggle
}
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
provider
.
id
)
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
sourceLabel
{
isUserEnabled
&
&
isSystemEnabled
?
"
"
:
"
isDisabled
"
}
}
label
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
provider
.
cohort
)
external_React_default
(
)
.
createElement
(
"
td
"
{
style
:
{
whiteSpace
:
"
nowrap
"
}
}
info
.
lastUpdated
?
new
Date
(
info
.
lastUpdated
)
.
toLocaleString
(
)
:
"
"
)
)
;
}
)
)
)
;
}
renderTargetingParameters
(
)
{
const
success
=
this
.
state
.
evaluationStatus
.
success
&
&
!
!
this
.
state
.
evaluationStatus
.
result
;
const
result
=
JSON
.
stringify
(
this
.
state
.
evaluationStatus
.
result
null
2
)
|
|
"
(
Empty
result
)
"
;
return
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
Evaluate
JEXL
expression
"
)
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
p
"
null
external_React_default
(
)
.
createElement
(
"
textarea
"
{
ref
:
"
expressionInput
"
rows
:
"
10
"
cols
:
"
60
"
placeholder
:
"
Evaluate
JEXL
expressions
and
mock
parameters
by
changing
their
values
below
"
}
)
)
external_React_default
(
)
.
createElement
(
"
p
"
null
"
Status
:
"
"
"
external_React_default
(
)
.
createElement
(
"
span
"
{
ref
:
"
evaluationStatus
"
}
success
?
"
"
:
"
"
"
Result
:
"
result
)
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
ASRouterButton
secondary
"
onClick
:
this
.
handleExpressionEval
}
"
Evaluate
"
)
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
Modify
targeting
parameters
"
)
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
ASRouterButton
secondary
"
onClick
:
this
.
onCopyTargetingParams
disabled
:
this
.
state
.
copiedToClipboard
}
this
.
state
.
copiedToClipboard
?
"
Parameters
copied
!
"
:
"
Copy
parameters
"
)
)
)
this
.
state
.
stringTargetingParameters
&
&
Object
.
keys
(
this
.
state
.
stringTargetingParameters
)
.
map
(
(
param
i
)
=
>
{
const
value
=
this
.
state
.
stringTargetingParameters
[
param
]
;
const
errorState
=
this
.
state
.
targetingParametersError
&
&
this
.
state
.
targetingParametersError
.
id
=
=
=
param
;
const
className
=
errorState
?
"
errorState
"
:
"
"
;
const
inputComp
=
(
value
&
&
value
.
length
)
>
30
?
external_React_default
(
)
.
createElement
(
"
textarea
"
{
name
:
param
className
:
className
value
:
value
rows
:
"
10
"
cols
:
"
60
"
onChange
:
this
.
onChangeTargetingParameters
}
)
:
external_React_default
(
)
.
createElement
(
"
input
"
{
name
:
param
className
:
className
value
:
value
onChange
:
this
.
onChangeTargetingParameters
}
)
;
return
external_React_default
(
)
.
createElement
(
"
tr
"
{
key
:
i
}
external_React_default
(
)
.
createElement
(
"
td
"
null
param
)
external_React_default
(
)
.
createElement
(
"
td
"
null
inputComp
)
)
;
}
)
)
)
;
}
onChangeAttributionParameters
(
event
)
{
const
{
name
value
}
=
event
.
target
;
this
.
setState
(
(
{
attributionParameters
}
)
=
>
{
const
updatedParameters
=
{
.
.
.
attributionParameters
}
;
updatedParameters
[
name
]
=
value
;
return
{
attributionParameters
:
updatedParameters
}
;
}
)
;
}
setAttribution
(
e
)
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
FORCE_ATTRIBUTION
"
data
:
this
.
state
.
attributionParameters
}
)
.
then
(
this
.
setStateFromParent
)
;
}
_getGroupImpressionsCount
(
id
frequency
)
{
if
(
frequency
)
{
return
this
.
state
.
groupImpressions
[
id
]
?
this
.
state
.
groupImpressions
[
id
]
.
length
:
0
;
}
return
"
n
/
a
"
;
}
renderDiscoveryStream
(
)
{
const
{
config
}
=
this
.
props
.
DiscoveryStream
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tbody
"
null
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
"
message
-
item
"
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Enabled
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
config
.
enabled
?
"
yes
"
:
"
no
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
"
message
-
item
"
}
external_React_default
(
)
.
createElement
(
"
td
"
{
className
:
"
min
"
}
"
Endpoint
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
config
.
endpoint
|
|
"
(
empty
)
"
)
)
)
)
)
;
}
renderAttributionParamers
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
Attribution
Parameters
"
)
external_React_default
(
)
.
createElement
(
"
p
"
null
"
"
"
This
forces
the
browser
to
set
some
attribution
parameters
useful
for
testing
the
Return
To
AMO
feature
.
Clicking
on
'
Force
Attribution
'
with
the
default
values
in
each
field
will
demo
the
Return
To
AMO
flow
with
the
addon
called
'
uBlock
Origin
'
.
If
you
wish
to
try
different
attribution
parameters
enter
them
in
the
text
boxes
.
If
you
wish
to
try
a
different
addon
with
the
Return
To
AMO
flow
make
sure
the
'
content
'
text
box
has
a
string
that
is
'
rta
:
base64
(
addonID
)
'
the
base64
string
of
the
addonID
prefixed
with
'
rta
:
'
.
The
addon
must
currently
be
a
recommended
addon
on
AMO
.
Then
click
'
Force
Attribution
'
.
Clicking
on
'
Force
Attribution
'
with
blank
text
boxes
reset
attribution
data
.
"
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
b
"
null
"
Source
"
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
name
:
"
source
"
placeholder
:
"
addons
.
mozilla
.
org
"
value
:
this
.
state
.
attributionParameters
.
source
onChange
:
this
.
onChangeAttributionParameters
}
)
"
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
b
"
null
"
Medium
"
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
name
:
"
medium
"
placeholder
:
"
referral
"
value
:
this
.
state
.
attributionParameters
.
medium
onChange
:
this
.
onChangeAttributionParameters
}
)
"
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
b
"
null
"
Campaign
"
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
name
:
"
campaign
"
placeholder
:
"
non
-
fx
-
button
"
value
:
this
.
state
.
attributionParameters
.
campaign
onChange
:
this
.
onChangeAttributionParameters
}
)
"
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
b
"
null
"
Content
"
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
name
:
"
content
"
placeholder
:
rta
:
{
btoa
(
"
uBlock0
raymondhill
.
net
"
)
}
value
:
this
.
state
.
attributionParameters
.
content
onChange
:
this
.
onChangeAttributionParameters
}
)
"
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
b
"
null
"
Experiment
"
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
name
:
"
experiment
"
placeholder
:
"
ua
-
onboarding
"
value
:
this
.
state
.
attributionParameters
.
experiment
onChange
:
this
.
onChangeAttributionParameters
}
)
"
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
b
"
null
"
Variation
"
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
name
:
"
variation
"
placeholder
:
"
chrome
"
value
:
this
.
state
.
attributionParameters
.
variation
onChange
:
this
.
onChangeAttributionParameters
}
)
"
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
b
"
null
"
User
Agent
"
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
name
:
"
ua
"
placeholder
:
"
Google
Chrome
123
"
value
:
this
.
state
.
attributionParameters
.
ua
onChange
:
this
.
onChangeAttributionParameters
}
)
"
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
"
b
"
null
"
Download
Token
"
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
name
:
"
dltoken
"
placeholder
:
"
00000000
-
0000
-
0000
-
0000
-
000000000000
"
value
:
this
.
state
.
attributionParameters
.
dltoken
onChange
:
this
.
onChangeAttributionParameters
}
)
"
"
)
)
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
td
"
null
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
ASRouterButton
primary
button
"
onClick
:
this
.
setAttribution
}
"
"
"
Force
Attribution
"
"
"
)
"
"
)
)
)
)
;
}
renderErrorMessage
(
{
id
errors
}
)
{
const
providerId
=
external_React_default
(
)
.
createElement
(
"
td
"
{
rowSpan
:
errors
.
length
}
id
)
;
return
errors
.
map
(
(
{
error
timestamp
}
cellKey
)
=
>
external_React_default
(
)
.
createElement
(
"
tr
"
{
key
:
cellKey
}
cellKey
=
=
=
errors
.
length
-
1
?
providerId
:
null
external_React_default
(
)
.
createElement
(
"
td
"
null
error
.
message
)
external_React_default
(
)
.
createElement
(
"
td
"
null
relativeTime
(
timestamp
)
)
)
)
.
reverse
(
)
;
}
renderErrors
(
)
{
const
providersWithErrors
=
this
.
state
.
providers
&
&
this
.
state
.
providers
.
filter
(
p
=
>
p
.
errors
&
&
p
.
errors
.
length
)
;
if
(
providersWithErrors
&
&
providersWithErrors
.
length
)
{
return
external_React_default
(
)
.
createElement
(
"
table
"
{
className
:
"
errorReporting
"
}
external_React_default
(
)
.
createElement
(
"
thead
"
null
external_React_default
(
)
.
createElement
(
"
tr
"
null
external_React_default
(
)
.
createElement
(
"
th
"
null
"
Provider
ID
"
)
external_React_default
(
)
.
createElement
(
"
th
"
null
"
Message
"
)
external_React_default
(
)
.
createElement
(
"
th
"
null
"
Timestamp
"
)
)
)
external_React_default
(
)
.
createElement
(
"
tbody
"
null
providersWithErrors
.
map
(
this
.
renderErrorMessage
)
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
p
"
null
"
No
errors
"
)
;
}
getSection
(
)
{
const
[
section
]
=
this
.
props
.
location
.
routes
;
switch
(
section
)
{
case
"
targeting
"
:
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
Targeting
Utilities
"
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
expireCache
}
"
Expire
Cache
"
)
"
"
"
(
This
expires
the
cache
in
ASR
Targeting
for
bookmarks
and
top
sites
)
"
this
.
renderTargetingParameters
(
)
this
.
renderAttributionParamers
(
)
)
;
case
"
groups
"
:
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
Message
Groups
"
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
button
"
onClick
:
this
.
resetGroups
}
"
Reset
group
impressions
"
)
external_React_default
(
)
.
createElement
(
"
table
"
null
external_React_default
(
)
.
createElement
(
"
thead
"
null
external_React_default
(
)
.
createElement
(
"
tr
"
{
className
:
"
message
-
item
"
}
external_React_default
(
)
.
createElement
(
"
td
"
null
"
Enabled
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
Impressions
count
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
Custom
frequency
"
)
external_React_default
(
)
.
createElement
(
"
td
"
null
"
User
preferences
"
)
)
)
external_React_default
(
)
.
createElement
(
"
tbody
"
null
this
.
state
.
groups
&
&
this
.
state
.
groups
.
map
(
(
{
id
enabled
frequency
userPreferences
=
[
]
}
index
)
=
>
external_React_default
(
)
.
createElement
(
Row
{
key
:
id
}
external_React_default
(
)
.
createElement
(
"
td
"
null
external_React_default
(
)
.
createElement
(
TogglePrefCheckbox
{
checked
:
enabled
pref
:
id
disabled
:
true
}
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
this
.
_getGroupImpressionsCount
(
id
frequency
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
JSON
.
stringify
(
frequency
null
2
)
)
external_React_default
(
)
.
createElement
(
"
td
"
null
userPreferences
.
join
(
"
"
)
)
)
)
)
)
this
.
renderMessageGroupsFilter
(
)
this
.
renderMessagesByGroup
(
)
)
;
case
"
ds
"
:
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
Discovery
Stream
"
)
external_React_default
(
)
.
createElement
(
DiscoveryStreamAdmin
{
state
:
{
DiscoveryStream
:
this
.
props
.
DiscoveryStream
Personalization
:
this
.
props
.
Personalization
}
otherPrefs
:
this
.
props
.
Prefs
.
values
dispatch
:
this
.
props
.
dispatch
}
)
)
;
case
"
errors
"
:
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
ASRouter
Errors
"
)
this
.
renderErrors
(
)
)
;
default
:
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
Message
Providers
"
"
"
external_React_default
(
)
.
createElement
(
"
button
"
{
title
:
"
Restore
all
provider
settings
that
ship
with
Firefox
"
className
:
"
button
"
onClick
:
this
.
resetPref
}
"
Restore
default
prefs
"
)
)
this
.
state
.
providers
?
this
.
renderProviders
(
)
:
null
external_React_default
(
)
.
createElement
(
"
h2
"
null
"
Messages
"
)
this
.
renderMessageFilter
(
)
this
.
renderMessages
(
)
)
;
}
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
asrouter
-
admin
{
this
.
props
.
collapsed
?
"
collapsed
"
:
"
expanded
"
}
}
external_React_default
(
)
.
createElement
(
"
aside
"
{
className
:
"
sidebar
"
}
external_React_default
(
)
.
createElement
(
"
ul
"
null
external_React_default
(
)
.
createElement
(
"
li
"
null
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
"
#
devtools
"
}
"
General
"
)
)
external_React_default
(
)
.
createElement
(
"
li
"
null
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
"
#
devtools
-
targeting
"
}
"
Targeting
"
)
)
external_React_default
(
)
.
createElement
(
"
li
"
null
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
"
#
devtools
-
groups
"
}
"
Message
Groups
"
)
)
external_React_default
(
)
.
createElement
(
"
li
"
null
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
"
#
devtools
-
ds
"
}
"
Discovery
Stream
"
)
)
external_React_default
(
)
.
createElement
(
"
li
"
null
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
"
#
devtools
-
errors
"
}
"
Errors
"
)
)
)
)
external_React_default
(
)
.
createElement
(
"
main
"
{
className
:
"
main
-
panel
"
}
external_React_default
(
)
.
createElement
(
"
h1
"
null
"
AS
Router
Admin
"
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
helpLink
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
info
"
}
)
"
"
external_React_default
(
)
.
createElement
(
"
span
"
null
"
Need
help
using
these
tools
?
Check
out
our
"
"
"
external_React_default
(
)
.
createElement
(
"
a
"
{
target
:
"
blank
"
href
:
"
https
:
/
/
firefox
-
source
-
docs
.
mozilla
.
org
/
browser
/
components
/
newtab
/
content
-
src
/
asrouter
/
docs
/
debugging
-
docs
.
html
"
}
"
documentation
"
)
)
)
this
.
getSection
(
)
)
)
;
}
}
class
CollapseToggle
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onCollapseToggle
=
this
.
onCollapseToggle
.
bind
(
this
)
;
this
.
state
=
{
collapsed
:
false
}
;
}
get
renderAdmin
(
)
{
const
{
props
}
=
this
;
return
props
.
location
.
hash
&
&
(
props
.
location
.
hash
.
startsWith
(
"
#
asrouter
"
)
|
|
props
.
location
.
hash
.
startsWith
(
"
#
devtools
"
)
)
;
}
onCollapseToggle
(
e
)
{
e
.
preventDefault
(
)
;
this
.
setState
(
state
=
>
(
{
collapsed
:
!
state
.
collapsed
}
)
)
;
}
setBodyClass
(
)
{
if
(
this
.
renderAdmin
&
&
!
this
.
state
.
collapsed
)
{
__webpack_require__
.
g
.
document
.
body
.
classList
.
add
(
"
no
-
scroll
"
)
;
}
else
{
__webpack_require__
.
g
.
document
.
body
.
classList
.
remove
(
"
no
-
scroll
"
)
;
}
}
componentDidMount
(
)
{
this
.
setBodyClass
(
)
;
}
componentDidUpdate
(
)
{
this
.
setBodyClass
(
)
;
}
componentWillUnmount
(
)
{
__webpack_require__
.
g
.
document
.
body
.
classList
.
remove
(
"
no
-
scroll
"
)
;
ASRouterUtils
.
removeListener
(
this
.
onMessageFromParent
)
;
}
render
(
)
{
const
{
props
}
=
this
;
const
{
renderAdmin
}
=
this
;
const
isCollapsed
=
this
.
state
.
collapsed
|
|
!
renderAdmin
;
const
label
=
{
isCollapsed
?
"
Expand
"
:
"
Collapse
"
}
devtools
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
"
#
devtools
"
title
:
label
"
aria
-
label
"
:
label
className
:
asrouter
-
toggle
{
isCollapsed
?
"
collapsed
"
:
"
expanded
"
}
onClick
:
this
.
renderAdmin
?
this
.
onCollapseToggle
:
null
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
devtools
"
}
)
)
renderAdmin
?
external_React_default
(
)
.
createElement
(
ASRouterAdminInner
_extends
(
{
}
props
{
collapsed
:
this
.
state
.
collapsed
}
)
)
:
null
)
;
}
}
const
_ASRouterAdmin
=
props
=
>
external_React_default
(
)
.
createElement
(
SimpleHashRouter
null
external_React_default
(
)
.
createElement
(
CollapseToggle
props
)
)
;
const
ASRouterAdmin
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Sections
:
state
.
Sections
DiscoveryStream
:
state
.
DiscoveryStream
Personalization
:
state
.
Personalization
Prefs
:
state
.
Prefs
}
)
)
(
_ASRouterAdmin
)
;
;
class
FluentType
{
constructor
(
value
opts
)
{
this
.
value
=
value
;
this
.
opts
=
opts
;
}
valueOf
(
)
{
return
this
.
value
;
}
toString
(
)
{
throw
new
Error
(
"
Subclasses
of
FluentType
must
implement
toString
.
"
)
;
}
}
class
FluentNone
extends
FluentType
{
valueOf
(
)
{
return
null
;
}
toString
(
)
{
return
{
{
this
.
value
|
|
"
?
?
?
"
}
}
;
}
}
class
FluentNumber
extends
FluentType
{
constructor
(
value
opts
)
{
super
(
parseFloat
(
value
)
opts
)
;
}
toString
(
bundle
)
{
try
{
const
nf
=
bundle
.
_memoizeIntlObject
(
Intl
.
NumberFormat
this
.
opts
)
;
return
nf
.
format
(
this
.
value
)
;
}
catch
(
e
)
{
return
this
.
value
;
}
}
}
class
FluentDateTime
extends
FluentType
{
constructor
(
value
opts
)
{
super
(
new
Date
(
value
)
opts
)
;
}
toString
(
bundle
)
{
try
{
const
dtf
=
bundle
.
_memoizeIntlObject
(
Intl
.
DateTimeFormat
this
.
opts
)
;
return
dtf
.
format
(
this
.
value
)
;
}
catch
(
e
)
{
return
this
.
value
;
}
}
}
;
function
merge
(
argopts
opts
)
{
return
Object
.
assign
(
{
}
argopts
values
(
opts
)
)
;
}
function
values
(
opts
)
{
const
unwrapped
=
{
}
;
for
(
const
[
name
opt
]
of
Object
.
entries
(
opts
)
)
{
unwrapped
[
name
]
=
opt
.
valueOf
(
)
;
}
return
unwrapped
;
}
function
NUMBER
(
[
arg
]
opts
)
{
if
(
arg
instanceof
FluentNone
)
{
return
arg
;
}
if
(
arg
instanceof
FluentNumber
)
{
return
new
FluentNumber
(
arg
.
valueOf
(
)
merge
(
arg
.
opts
opts
)
)
;
}
return
new
FluentNone
(
"
NUMBER
(
)
"
)
;
}
function
DATETIME
(
[
arg
]
opts
)
{
if
(
arg
instanceof
FluentNone
)
{
return
arg
;
}
if
(
arg
instanceof
FluentDateTime
)
{
return
new
FluentDateTime
(
arg
.
valueOf
(
)
merge
(
arg
.
opts
opts
)
)
;
}
return
new
FluentNone
(
"
DATETIME
(
)
"
)
;
}
;
const
MAX_PLACEABLE_LENGTH
=
2500
;
const
FSI
=
"
\
u2068
"
;
const
PDI
=
"
\
u2069
"
;
function
match
(
bundle
selector
key
)
{
if
(
key
=
=
=
selector
)
{
return
true
;
}
if
(
key
instanceof
FluentNumber
&
&
selector
instanceof
FluentNumber
&
&
key
.
value
=
=
=
selector
.
value
)
{
return
true
;
}
if
(
selector
instanceof
FluentNumber
&
&
typeof
key
=
=
=
"
string
"
)
{
let
category
=
bundle
.
_memoizeIntlObject
(
Intl
.
PluralRules
selector
.
opts
)
.
select
(
selector
.
value
)
;
if
(
key
=
=
=
category
)
{
return
true
;
}
}
return
false
;
}
function
getDefault
(
scope
variants
star
)
{
if
(
variants
[
star
]
)
{
return
Type
(
scope
variants
[
star
]
)
;
}
scope
.
errors
.
push
(
new
RangeError
(
"
No
default
"
)
)
;
return
new
FluentNone
(
)
;
}
function
getArguments
(
scope
args
)
{
const
positional
=
[
]
;
const
named
=
{
}
;
for
(
const
arg
of
args
)
{
if
(
arg
.
type
=
=
=
"
narg
"
)
{
named
[
arg
.
name
]
=
Type
(
scope
arg
.
value
)
;
}
else
{
positional
.
push
(
Type
(
scope
arg
)
)
;
}
}
return
[
positional
named
]
;
}
function
Type
(
scope
expr
)
{
if
(
typeof
expr
=
=
=
"
string
"
)
{
return
scope
.
bundle
.
_transform
(
expr
)
;
}
if
(
expr
instanceof
FluentNone
)
{
return
expr
;
}
if
(
Array
.
isArray
(
expr
)
)
{
return
Pattern
(
scope
expr
)
;
}
switch
(
expr
.
type
)
{
case
"
str
"
:
return
expr
.
value
;
case
"
num
"
:
return
new
FluentNumber
(
expr
.
value
{
minimumFractionDigits
:
expr
.
precision
}
)
;
case
"
var
"
:
return
VariableReference
(
scope
expr
)
;
case
"
mesg
"
:
return
MessageReference
(
scope
expr
)
;
case
"
term
"
:
return
TermReference
(
scope
expr
)
;
case
"
func
"
:
return
FunctionReference
(
scope
expr
)
;
case
"
select
"
:
return
SelectExpression
(
scope
expr
)
;
case
undefined
:
{
if
(
expr
.
value
!
=
=
null
&
&
expr
.
value
!
=
=
undefined
)
{
return
Type
(
scope
expr
.
value
)
;
}
scope
.
errors
.
push
(
new
RangeError
(
"
No
value
"
)
)
;
return
new
FluentNone
(
)
;
}
default
:
return
new
FluentNone
(
)
;
}
}
function
VariableReference
(
scope
{
name
}
)
{
if
(
!
scope
.
args
|
|
!
scope
.
args
.
hasOwnProperty
(
name
)
)
{
if
(
scope
.
insideTermReference
=
=
=
false
)
{
scope
.
errors
.
push
(
new
ReferenceError
(
Unknown
variable
:
{
name
}
)
)
;
}
return
new
FluentNone
(
{
name
}
)
;
}
const
arg
=
scope
.
args
[
name
]
;
if
(
arg
instanceof
FluentType
)
{
return
arg
;
}
switch
(
typeof
arg
)
{
case
"
string
"
:
return
arg
;
case
"
number
"
:
return
new
FluentNumber
(
arg
)
;
case
"
object
"
:
if
(
arg
instanceof
Date
)
{
return
new
FluentDateTime
(
arg
)
;
}
default
:
scope
.
errors
.
push
(
new
TypeError
(
Unsupported
variable
type
:
{
name
}
{
typeof
arg
}
)
)
;
return
new
FluentNone
(
{
name
}
)
;
}
}
function
MessageReference
(
scope
{
name
attr
}
)
{
const
message
=
scope
.
bundle
.
_messages
.
get
(
name
)
;
if
(
!
message
)
{
const
err
=
new
ReferenceError
(
Unknown
message
:
{
name
}
)
;
scope
.
errors
.
push
(
err
)
;
return
new
FluentNone
(
name
)
;
}
if
(
attr
)
{
const
attribute
=
message
.
attrs
&
&
message
.
attrs
[
attr
]
;
if
(
attribute
)
{
return
Type
(
scope
attribute
)
;
}
scope
.
errors
.
push
(
new
ReferenceError
(
Unknown
attribute
:
{
attr
}
)
)
;
return
new
FluentNone
(
{
name
}
.
{
attr
}
)
;
}
return
Type
(
scope
message
)
;
}
function
TermReference
(
scope
{
name
attr
args
}
)
{
const
id
=
-
{
name
}
;
const
term
=
scope
.
bundle
.
_terms
.
get
(
id
)
;
if
(
!
term
)
{
const
err
=
new
ReferenceError
(
Unknown
term
:
{
id
}
)
;
scope
.
errors
.
push
(
err
)
;
return
new
FluentNone
(
id
)
;
}
const
[
keyargs
]
=
getArguments
(
scope
args
)
;
const
local
=
{
.
.
.
scope
args
:
keyargs
insideTermReference
:
true
}
;
if
(
attr
)
{
const
attribute
=
term
.
attrs
&
&
term
.
attrs
[
attr
]
;
if
(
attribute
)
{
return
Type
(
local
attribute
)
;
}
scope
.
errors
.
push
(
new
ReferenceError
(
Unknown
attribute
:
{
attr
}
)
)
;
return
new
FluentNone
(
{
id
}
.
{
attr
}
)
;
}
return
Type
(
local
term
)
;
}
function
FunctionReference
(
scope
{
name
args
}
)
{
const
func
=
scope
.
bundle
.
_functions
[
name
]
|
|
builtins_namespaceObject
[
name
]
;
if
(
!
func
)
{
scope
.
errors
.
push
(
new
ReferenceError
(
Unknown
function
:
{
name
}
(
)
)
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
if
(
typeof
func
!
=
=
"
function
"
)
{
scope
.
errors
.
push
(
new
TypeError
(
Function
{
name
}
(
)
is
not
callable
)
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
try
{
return
func
(
.
.
.
getArguments
(
scope
args
)
)
;
}
catch
(
e
)
{
return
new
FluentNone
(
{
name
}
(
)
)
;
}
}
function
SelectExpression
(
scope
{
selector
variants
star
}
)
{
let
sel
=
Type
(
scope
selector
)
;
if
(
sel
instanceof
FluentNone
)
{
const
variant
=
getDefault
(
scope
variants
star
)
;
return
Type
(
scope
variant
)
;
}
for
(
const
variant
of
variants
)
{
const
key
=
Type
(
scope
variant
.
key
)
;
if
(
match
(
scope
.
bundle
sel
key
)
)
{
return
Type
(
scope
variant
)
;
}
}
const
variant
=
getDefault
(
scope
variants
star
)
;
return
Type
(
scope
variant
)
;
}
function
Pattern
(
scope
ptn
)
{
if
(
scope
.
dirty
.
has
(
ptn
)
)
{
scope
.
errors
.
push
(
new
RangeError
(
"
Cyclic
reference
"
)
)
;
return
new
FluentNone
(
)
;
}
scope
.
dirty
.
add
(
ptn
)
;
const
result
=
[
]
;
const
useIsolating
=
scope
.
bundle
.
_useIsolating
&
&
ptn
.
length
>
1
;
for
(
const
elem
of
ptn
)
{
if
(
typeof
elem
=
=
=
"
string
"
)
{
result
.
push
(
scope
.
bundle
.
_transform
(
elem
)
)
;
continue
;
}
const
part
=
Type
(
scope
elem
)
.
toString
(
scope
.
bundle
)
;
if
(
useIsolating
)
{
result
.
push
(
FSI
)
;
}
if
(
part
.
length
>
MAX_PLACEABLE_LENGTH
)
{
scope
.
errors
.
push
(
new
RangeError
(
"
Too
many
characters
in
placeable
"
+
(
{
part
.
length
}
max
allowed
is
{
MAX_PLACEABLE_LENGTH
}
)
)
)
;
result
.
push
(
part
.
slice
(
MAX_PLACEABLE_LENGTH
)
)
;
}
else
{
result
.
push
(
part
)
;
}
if
(
useIsolating
)
{
result
.
push
(
PDI
)
;
}
}
scope
.
dirty
.
delete
(
ptn
)
;
return
result
.
join
(
"
"
)
;
}
function
resolve
(
bundle
args
message
errors
=
[
]
)
{
const
scope
=
{
bundle
args
errors
dirty
:
new
WeakSet
(
)
insideTermReference
:
false
}
;
return
Type
(
scope
message
)
.
toString
(
bundle
)
;
}
;
class
FluentError
extends
Error
{
}
;
const
RE_MESSAGE_START
=
/
^
(
-
?
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
*
=
*
/
mg
;
const
RE_ATTRIBUTE_START
=
/
\
.
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
*
=
*
/
y
;
const
RE_VARIANT_START
=
/
\
*
?
\
[
/
y
;
const
RE_NUMBER_LITERAL
=
/
(
-
?
[
0
-
9
]
+
(
?
:
\
.
(
[
0
-
9
]
+
)
)
?
)
/
y
;
const
RE_IDENTIFIER
=
/
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
/
y
;
const
RE_REFERENCE
=
/
(
[
-
]
)
?
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
(
?
:
\
.
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
)
?
/
y
;
const
RE_FUNCTION_NAME
=
/
^
[
A
-
Z
]
[
A
-
Z0
-
9_
-
]
*
/
;
const
RE_TEXT_RUN
=
/
(
[
^
{
}
\
n
\
r
]
+
)
/
y
;
const
RE_STRING_RUN
=
/
(
[
^
\
\
"
\
n
\
r
]
*
)
/
y
;
const
RE_STRING_ESCAPE
=
/
\
\
(
[
\
\
"
]
)
/
y
;
const
RE_UNICODE_ESCAPE
=
/
\
\
u
(
[
a
-
fA
-
F0
-
9
]
{
4
}
)
|
\
\
U
(
[
a
-
fA
-
F0
-
9
]
{
6
}
)
/
y
;
const
RE_LEADING_NEWLINES
=
/
^
\
n
+
/
;
const
RE_TRAILING_SPACES
=
/
+
/
;
const
RE_BLANK_LINES
=
/
*
\
r
?
\
n
/
g
;
const
RE_INDENT
=
/
(
*
)
/
;
const
TOKEN_BRACE_OPEN
=
/
{
\
s
*
/
y
;
const
TOKEN_BRACE_CLOSE
=
/
\
s
*
}
/
y
;
const
TOKEN_BRACKET_OPEN
=
/
\
[
\
s
*
/
y
;
const
TOKEN_BRACKET_CLOSE
=
/
\
s
*
]
*
/
y
;
const
TOKEN_PAREN_OPEN
=
/
\
s
*
\
(
\
s
*
/
y
;
const
TOKEN_ARROW
=
/
\
s
*
-
>
\
s
*
/
y
;
const
TOKEN_COLON
=
/
\
s
*
:
\
s
*
/
y
;
const
TOKEN_COMMA
=
/
\
s
*
?
\
s
*
/
y
;
const
TOKEN_BLANK
=
/
\
s
+
/
y
;
const
MAX_PLACEABLES
=
100
;
class
FluentResource
extends
Map
{
static
fromString
(
source
)
{
RE_MESSAGE_START
.
lastIndex
=
0
;
let
resource
=
new
this
(
)
;
let
cursor
=
0
;
while
(
true
)
{
let
next
=
RE_MESSAGE_START
.
exec
(
source
)
;
if
(
next
=
=
=
null
)
{
break
;
}
cursor
=
RE_MESSAGE_START
.
lastIndex
;
try
{
resource
.
set
(
next
[
1
]
parseMessage
(
)
)
;
}
catch
(
err
)
{
if
(
err
instanceof
FluentError
)
{
continue
;
}
throw
err
;
}
}
return
resource
;
function
test
(
re
)
{
re
.
lastIndex
=
cursor
;
return
re
.
test
(
source
)
;
}
function
consumeChar
(
char
errorClass
)
{
if
(
source
[
cursor
]
=
=
=
char
)
{
cursor
+
+
;
return
true
;
}
if
(
errorClass
)
{
throw
new
errorClass
(
Expected
{
char
}
)
;
}
return
false
;
}
function
consumeToken
(
re
errorClass
)
{
if
(
test
(
re
)
)
{
cursor
=
re
.
lastIndex
;
return
true
;
}
if
(
errorClass
)
{
throw
new
errorClass
(
Expected
{
re
.
toString
(
)
}
)
;
}
return
false
;
}
function
match
(
re
)
{
re
.
lastIndex
=
cursor
;
let
result
=
re
.
exec
(
source
)
;
if
(
result
=
=
=
null
)
{
throw
new
FluentError
(
Expected
{
re
.
toString
(
)
}
)
;
}
cursor
=
re
.
lastIndex
;
return
result
;
}
function
match1
(
re
)
{
return
match
(
re
)
[
1
]
;
}
function
parseMessage
(
)
{
let
value
=
parsePattern
(
)
;
let
attrs
=
parseAttributes
(
)
;
if
(
attrs
=
=
=
null
)
{
if
(
value
=
=
=
null
)
{
throw
new
FluentError
(
"
Expected
message
value
or
attributes
"
)
;
}
return
value
;
}
return
{
value
attrs
}
;
}
function
parseAttributes
(
)
{
let
attrs
=
{
}
;
while
(
test
(
RE_ATTRIBUTE_START
)
)
{
let
name
=
match1
(
RE_ATTRIBUTE_START
)
;
let
value
=
parsePattern
(
)
;
if
(
value
=
=
=
null
)
{
throw
new
FluentError
(
"
Expected
attribute
value
"
)
;
}
attrs
[
name
]
=
value
;
}
return
Object
.
keys
(
attrs
)
.
length
>
0
?
attrs
:
null
;
}
function
parsePattern
(
)
{
if
(
test
(
RE_TEXT_RUN
)
)
{
var
first
=
match1
(
RE_TEXT_RUN
)
;
}
if
(
source
[
cursor
]
=
=
=
"
{
"
|
|
source
[
cursor
]
=
=
=
"
}
"
)
{
return
parsePatternElements
(
first
?
[
first
]
:
[
]
Infinity
)
;
}
let
indent
=
parseIndent
(
)
;
if
(
indent
)
{
if
(
first
)
{
return
parsePatternElements
(
[
first
indent
]
indent
.
length
)
;
}
indent
.
value
=
trim
(
indent
.
value
RE_LEADING_NEWLINES
)
;
return
parsePatternElements
(
[
indent
]
indent
.
length
)
;
}
if
(
first
)
{
return
trim
(
first
RE_TRAILING_SPACES
)
;
}
return
null
;
}
function
parsePatternElements
(
elements
=
[
]
commonIndent
)
{
let
placeableCount
=
0
;
while
(
true
)
{
if
(
test
(
RE_TEXT_RUN
)
)
{
elements
.
push
(
match1
(
RE_TEXT_RUN
)
)
;
continue
;
}
if
(
source
[
cursor
]
=
=
=
"
{
"
)
{
if
(
+
+
placeableCount
>
MAX_PLACEABLES
)
{
throw
new
FluentError
(
"
Too
many
placeables
"
)
;
}
elements
.
push
(
parsePlaceable
(
)
)
;
continue
;
}
if
(
source
[
cursor
]
=
=
=
"
}
"
)
{
throw
new
FluentError
(
"
Unbalanced
closing
brace
"
)
;
}
let
indent
=
parseIndent
(
)
;
if
(
indent
)
{
elements
.
push
(
indent
)
;
commonIndent
=
Math
.
min
(
commonIndent
indent
.
length
)
;
continue
;
}
break
;
}
let
lastIndex
=
elements
.
length
-
1
;
if
(
typeof
elements
[
lastIndex
]
=
=
=
"
string
"
)
{
elements
[
lastIndex
]
=
trim
(
elements
[
lastIndex
]
RE_TRAILING_SPACES
)
;
}
let
baked
=
[
]
;
for
(
let
element
of
elements
)
{
if
(
element
.
type
=
=
=
"
indent
"
)
{
element
=
element
.
value
.
slice
(
0
element
.
value
.
length
-
commonIndent
)
;
}
else
if
(
element
.
type
=
=
=
"
str
"
)
{
element
=
element
.
value
;
}
if
(
element
)
{
baked
.
push
(
element
)
;
}
}
return
baked
;
}
function
parsePlaceable
(
)
{
consumeToken
(
TOKEN_BRACE_OPEN
FluentError
)
;
let
selector
=
parseInlineExpression
(
)
;
if
(
consumeToken
(
TOKEN_BRACE_CLOSE
)
)
{
return
selector
;
}
if
(
consumeToken
(
TOKEN_ARROW
)
)
{
let
variants
=
parseVariants
(
)
;
consumeToken
(
TOKEN_BRACE_CLOSE
FluentError
)
;
return
{
type
:
"
select
"
selector
.
.
.
variants
}
;
}
throw
new
FluentError
(
"
Unclosed
placeable
"
)
;
}
function
parseInlineExpression
(
)
{
if
(
source
[
cursor
]
=
=
=
"
{
"
)
{
return
parsePlaceable
(
)
;
}
if
(
test
(
RE_REFERENCE
)
)
{
let
[
sigil
name
attr
=
null
]
=
match
(
RE_REFERENCE
)
;
if
(
sigil
=
=
=
"
"
)
{
return
{
type
:
"
var
"
name
}
;
}
if
(
consumeToken
(
TOKEN_PAREN_OPEN
)
)
{
let
args
=
parseArguments
(
)
;
if
(
sigil
=
=
=
"
-
"
)
{
return
{
type
:
"
term
"
name
attr
args
}
;
}
if
(
RE_FUNCTION_NAME
.
test
(
name
)
)
{
return
{
type
:
"
func
"
name
args
}
;
}
throw
new
FluentError
(
"
Function
names
must
be
all
upper
-
case
"
)
;
}
if
(
sigil
=
=
=
"
-
"
)
{
return
{
type
:
"
term
"
name
attr
args
:
[
]
}
;
}
return
{
type
:
"
mesg
"
name
attr
}
;
}
return
parseLiteral
(
)
;
}
function
parseArguments
(
)
{
let
args
=
[
]
;
while
(
true
)
{
switch
(
source
[
cursor
]
)
{
case
"
)
"
:
cursor
+
+
;
return
args
;
case
undefined
:
throw
new
FluentError
(
"
Unclosed
argument
list
"
)
;
}
args
.
push
(
parseArgument
(
)
)
;
consumeToken
(
TOKEN_COMMA
)
;
}
}
function
parseArgument
(
)
{
let
expr
=
parseInlineExpression
(
)
;
if
(
expr
.
type
!
=
=
"
mesg
"
)
{
return
expr
;
}
if
(
consumeToken
(
TOKEN_COLON
)
)
{
return
{
type
:
"
narg
"
name
:
expr
.
name
value
:
parseLiteral
(
)
}
;
}
return
expr
;
}
function
parseVariants
(
)
{
let
variants
=
[
]
;
let
count
=
0
;
let
star
;
while
(
test
(
RE_VARIANT_START
)
)
{
if
(
consumeChar
(
"
*
"
)
)
{
star
=
count
;
}
let
key
=
parseVariantKey
(
)
;
let
value
=
parsePattern
(
)
;
if
(
value
=
=
=
null
)
{
throw
new
FluentError
(
"
Expected
variant
value
"
)
;
}
variants
[
count
+
+
]
=
{
key
value
}
;
}
if
(
count
=
=
=
0
)
{
return
null
;
}
if
(
star
=
=
=
undefined
)
{
throw
new
FluentError
(
"
Expected
default
variant
"
)
;
}
return
{
variants
star
}
;
}
function
parseVariantKey
(
)
{
consumeToken
(
TOKEN_BRACKET_OPEN
FluentError
)
;
let
key
=
test
(
RE_NUMBER_LITERAL
)
?
parseNumberLiteral
(
)
:
match1
(
RE_IDENTIFIER
)
;
consumeToken
(
TOKEN_BRACKET_CLOSE
FluentError
)
;
return
key
;
}
function
parseLiteral
(
)
{
if
(
test
(
RE_NUMBER_LITERAL
)
)
{
return
parseNumberLiteral
(
)
;
}
if
(
source
[
cursor
]
=
=
=
"
\
"
"
)
{
return
parseStringLiteral
(
)
;
}
throw
new
FluentError
(
"
Invalid
expression
"
)
;
}
function
parseNumberLiteral
(
)
{
let
[
value
fraction
=
"
"
]
=
match
(
RE_NUMBER_LITERAL
)
;
let
precision
=
fraction
.
length
;
return
{
type
:
"
num
"
value
:
parseFloat
(
value
)
precision
}
;
}
function
parseStringLiteral
(
)
{
consumeChar
(
"
\
"
"
FluentError
)
;
let
value
=
"
"
;
while
(
true
)
{
value
+
=
match1
(
RE_STRING_RUN
)
;
if
(
source
[
cursor
]
=
=
=
"
\
\
"
)
{
value
+
=
parseEscapeSequence
(
)
;
continue
;
}
if
(
consumeChar
(
"
\
"
"
)
)
{
return
{
type
:
"
str
"
value
}
;
}
throw
new
FluentError
(
"
Unclosed
string
literal
"
)
;
}
}
function
parseEscapeSequence
(
)
{
if
(
test
(
RE_STRING_ESCAPE
)
)
{
return
match1
(
RE_STRING_ESCAPE
)
;
}
if
(
test
(
RE_UNICODE_ESCAPE
)
)
{
let
[
codepoint4
codepoint6
]
=
match
(
RE_UNICODE_ESCAPE
)
;
let
codepoint
=
parseInt
(
codepoint4
|
|
codepoint6
16
)
;
return
codepoint
<
=
0xD7FF
|
|
0xE000
<
=
codepoint
?
String
.
fromCodePoint
(
codepoint
)
:
"
"
;
}
throw
new
FluentError
(
"
Unknown
escape
sequence
"
)
;
}
function
parseIndent
(
)
{
let
start
=
cursor
;
consumeToken
(
TOKEN_BLANK
)
;
switch
(
source
[
cursor
]
)
{
case
"
.
"
:
case
"
[
"
:
case
"
*
"
:
case
"
}
"
:
case
undefined
:
return
false
;
case
"
{
"
:
return
makeIndent
(
source
.
slice
(
start
cursor
)
)
;
}
if
(
source
[
cursor
-
1
]
=
=
=
"
"
)
{
return
makeIndent
(
source
.
slice
(
start
cursor
)
)
;
}
return
false
;
}
function
trim
(
text
re
)
{
return
text
.
replace
(
re
"
"
)
;
}
function
makeIndent
(
blank
)
{
let
value
=
blank
.
replace
(
RE_BLANK_LINES
"
\
n
"
)
;
let
length
=
RE_INDENT
.
exec
(
blank
)
[
1
]
.
length
;
return
{
type
:
"
indent
"
value
length
}
;
}
}
}
;
class
FluentBundle
{
constructor
(
locales
{
functions
=
{
}
useIsolating
=
true
transform
=
v
=
>
v
}
=
{
}
)
{
this
.
locales
=
Array
.
isArray
(
locales
)
?
locales
:
[
locales
]
;
this
.
_terms
=
new
Map
(
)
;
this
.
_messages
=
new
Map
(
)
;
this
.
_functions
=
functions
;
this
.
_useIsolating
=
useIsolating
;
this
.
_transform
=
transform
;
this
.
_intls
=
new
WeakMap
(
)
;
}
get
messages
(
)
{
return
this
.
_messages
[
Symbol
.
iterator
]
(
)
;
}
hasMessage
(
id
)
{
return
this
.
_messages
.
has
(
id
)
;
}
getMessage
(
id
)
{
return
this
.
_messages
.
get
(
id
)
;
}
addMessages
(
source
options
)
{
const
res
=
FluentResource
.
fromString
(
source
)
;
return
this
.
addResource
(
res
options
)
;
}
addResource
(
res
{
allowOverrides
=
false
}
=
{
}
)
{
const
errors
=
[
]
;
for
(
const
[
id
value
]
of
res
)
{
if
(
id
.
startsWith
(
"
-
"
)
)
{
if
(
allowOverrides
=
=
=
false
&
&
this
.
_terms
.
has
(
id
)
)
{
errors
.
push
(
Attempt
to
override
an
existing
term
:
"
{
id
}
"
)
;
continue
;
}
this
.
_terms
.
set
(
id
value
)
;
}
else
{
if
(
allowOverrides
=
=
=
false
&
&
this
.
_messages
.
has
(
id
)
)
{
errors
.
push
(
Attempt
to
override
an
existing
message
:
"
{
id
}
"
)
;
continue
;
}
this
.
_messages
.
set
(
id
value
)
;
}
}
return
errors
;
}
format
(
message
args
errors
)
{
if
(
typeof
message
=
=
=
"
string
"
)
{
return
this
.
_transform
(
message
)
;
}
if
(
message
=
=
=
null
|
|
message
.
value
=
=
=
null
)
{
return
null
;
}
if
(
typeof
message
.
value
=
=
=
"
string
"
)
{
return
this
.
_transform
(
message
.
value
)
;
}
return
resolve
(
this
args
message
errors
)
;
}
_memoizeIntlObject
(
ctor
opts
)
{
const
cache
=
this
.
_intls
.
get
(
ctor
)
|
|
{
}
;
const
id
=
JSON
.
stringify
(
opts
)
;
if
(
!
cache
[
id
]
)
{
cache
[
id
]
=
new
ctor
(
this
.
locales
opts
)
;
this
.
_intls
.
set
(
ctor
cache
)
;
}
return
cache
[
id
]
;
}
}
;
;
const
RICH_TEXT_CONFIG
=
{
text
:
[
"
text
"
"
scene1_text
"
]
success_text
:
"
success_text
"
error_text
:
"
error_text
"
scene2_text
:
"
scene2_text
"
amo_html
:
"
amo_html
"
privacy_html
:
"
scene2_privacy_html
"
disclaimer_html
:
"
scene2_disclaimer_html
"
}
;
const
RICH_TEXT_KEYS
=
Object
.
keys
(
RICH_TEXT_CONFIG
)
;
function
generateBundles
(
content
)
{
const
bundle
=
new
FluentBundle
(
"
en
-
US
"
)
;
RICH_TEXT_KEYS
.
forEach
(
key
=
>
{
const
attrs
=
RICH_TEXT_CONFIG
[
key
]
;
const
attrsToTry
=
Array
.
isArray
(
attrs
)
?
[
.
.
.
attrs
]
:
[
attrs
]
;
let
string
=
"
"
;
while
(
!
string
&
&
attrsToTry
.
length
)
{
const
attr
=
attrsToTry
.
pop
(
)
;
string
=
content
[
attr
]
;
}
bundle
.
addMessages
(
{
key
}
=
{
string
}
)
;
}
)
;
return
[
bundle
]
;
}
;
const
VISIBLE
=
"
visible
"
;
const
VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
class
ImpressionsWrapper
extends
(
external_React_default
(
)
)
.
PureComponent
{
sendImpressionOrAddListener
(
)
{
if
(
this
.
props
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
props
.
sendImpression
(
{
id
:
this
.
props
.
id
}
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
this
.
props
.
document
.
visibilityState
=
=
=
VISIBLE
)
{
this
.
props
.
sendImpression
(
{
id
:
this
.
props
.
id
}
)
;
this
.
props
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
this
.
props
.
document
.
addEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
componentDidMount
(
)
{
if
(
this
.
props
.
sendOnMount
)
{
this
.
sendImpressionOrAddListener
(
)
;
}
}
componentDidUpdate
(
prevProps
)
{
if
(
this
.
props
.
shouldSendImpressionOnUpdate
(
this
.
props
prevProps
)
)
{
this
.
sendImpressionOrAddListener
(
)
;
}
}
render
(
)
{
return
this
.
props
.
children
;
}
}
ImpressionsWrapper
.
defaultProps
=
{
document
:
__webpack_require__
.
g
.
document
sendOnMount
:
true
}
;
;
const
external_PropTypes_namespaceObject
=
PropTypes
;
var
external_PropTypes_default
=
__webpack_require__
.
n
(
external_PropTypes_namespaceObject
)
;
;
function
mapBundleSync
(
iterable
ids
)
{
if
(
!
Array
.
isArray
(
ids
)
)
{
return
getBundleForId
(
iterable
ids
)
;
}
return
ids
.
map
(
id
=
>
getBundleForId
(
iterable
id
)
)
;
}
function
getBundleForId
(
iterable
id
)
{
for
(
const
bundle
of
iterable
)
{
if
(
bundle
.
hasMessage
(
id
)
)
{
return
bundle
;
}
}
return
null
;
}
;
async
function
mapBundleAsync
(
iterable
ids
)
{
if
(
!
Array
.
isArray
(
ids
)
)
{
for
await
(
const
bundle
of
iterable
)
{
if
(
bundle
.
hasMessage
(
ids
)
)
{
return
bundle
;
}
}
}
let
remainingCount
=
ids
.
length
;
const
foundBundles
=
new
Array
(
remainingCount
)
.
fill
(
null
)
;
for
await
(
const
bundle
of
iterable
)
{
for
(
const
[
index
id
]
of
ids
.
entries
(
)
)
{
if
(
!
foundBundles
[
index
]
&
&
bundle
.
hasMessage
(
id
)
)
{
foundBundles
[
index
]
=
bundle
;
remainingCount
-
-
;
}
if
(
remainingCount
=
=
=
0
)
{
return
foundBundles
;
}
}
}
return
foundBundles
;
}
;
;
class
CachedIterable
extends
Array
{
static
from
(
iterable
)
{
if
(
iterable
instanceof
this
)
{
return
iterable
;
}
return
new
this
(
iterable
)
;
}
}
;
class
CachedSyncIterable
extends
CachedIterable
{
constructor
(
iterable
)
{
super
(
)
;
if
(
Symbol
.
iterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
iterator
]
(
)
;
}
else
{
throw
new
TypeError
(
"
Argument
must
implement
the
iteration
protocol
.
"
)
;
}
}
[
Symbol
.
iterator
]
(
)
{
const
cached
=
this
;
let
cur
=
0
;
return
{
next
(
)
{
if
(
cached
.
length
<
=
cur
)
{
cached
.
push
(
cached
.
iterator
.
next
(
)
)
;
}
return
cached
[
cur
+
+
]
;
}
}
;
}
touchNext
(
count
=
1
)
{
let
idx
=
0
;
while
(
idx
+
+
<
count
)
{
const
last
=
this
[
this
.
length
-
1
]
;
if
(
last
&
&
last
.
done
)
{
break
;
}
this
.
push
(
this
.
iterator
.
next
(
)
)
;
}
return
this
[
this
.
length
-
1
]
;
}
}
;
class
CachedAsyncIterable
extends
CachedIterable
{
constructor
(
iterable
)
{
super
(
)
;
if
(
Symbol
.
asyncIterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
asyncIterator
]
(
)
;
}
else
if
(
Symbol
.
iterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
iterator
]
(
)
;
}
else
{
throw
new
TypeError
(
"
Argument
must
implement
the
iteration
protocol
.
"
)
;
}
}
[
Symbol
.
iterator
]
(
)
{
const
cached
=
this
;
let
cur
=
0
;
return
{
next
(
)
{
if
(
cached
.
length
=
=
=
cur
)
{
return
{
value
:
undefined
done
:
true
}
;
}
return
cached
[
cur
+
+
]
;
}
}
;
}
[
Symbol
.
asyncIterator
]
(
)
{
const
cached
=
this
;
let
cur
=
0
;
return
{
async
next
(
)
{
if
(
cached
.
length
<
=
cur
)
{
cached
.
push
(
await
cached
.
iterator
.
next
(
)
)
;
}
return
cached
[
cur
+
+
]
;
}
}
;
}
async
touchNext
(
count
=
1
)
{
let
idx
=
0
;
while
(
idx
+
+
<
count
)
{
const
last
=
this
[
this
.
length
-
1
]
;
if
(
last
&
&
last
.
done
)
{
break
;
}
this
.
push
(
await
this
.
iterator
.
next
(
)
)
;
}
return
this
[
this
.
length
-
1
]
;
}
}
;
;
class
ReactLocalization
{
constructor
(
bundles
)
{
this
.
bundles
=
CachedSyncIterable
.
from
(
bundles
)
;
this
.
subs
=
new
Set
(
)
;
}
subscribe
(
comp
)
{
this
.
subs
.
add
(
comp
)
;
}
unsubscribe
(
comp
)
{
this
.
subs
.
delete
(
comp
)
;
}
setBundles
(
bundles
)
{
this
.
bundles
=
CachedSyncIterable
.
from
(
bundles
)
;
this
.
subs
.
forEach
(
comp
=
>
comp
.
relocalize
(
)
)
;
}
getBundle
(
id
)
{
return
mapBundleSync
(
this
.
bundles
id
)
;
}
getString
(
id
args
fallback
)
{
const
bundle
=
this
.
getBundle
(
id
)
;
if
(
bundle
=
=
=
null
)
{
return
fallback
|
|
id
;
}
const
msg
=
bundle
.
getMessage
(
id
)
;
return
bundle
.
format
(
msg
args
)
;
}
}
function
isReactLocalization
(
props
propName
)
{
const
prop
=
props
[
propName
]
;
if
(
prop
instanceof
ReactLocalization
)
{
return
null
;
}
return
new
Error
(
The
{
propName
}
context
field
must
be
an
instance
of
ReactLocalization
.
)
;
}
;
let
cachedParseMarkup
;
function
createParseMarkup
(
)
{
if
(
typeof
document
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
document
is
undefined
.
Without
it
translations
cannot
"
+
"
be
safely
sanitized
.
Consult
the
documentation
at
"
+
"
https
:
/
/
github
.
com
/
projectfluent
/
fluent
.
js
/
wiki
/
React
-
Overlays
.
"
)
;
}
if
(
!
cachedParseMarkup
)
{
const
template
=
document
.
createElement
(
"
template
"
)
;
cachedParseMarkup
=
function
parseMarkup
(
str
)
{
template
.
innerHTML
=
str
;
return
Array
.
from
(
template
.
content
.
childNodes
)
;
}
;
}
return
cachedParseMarkup
;
}
;
class
LocalizationProvider
extends
external_React_namespaceObject
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
const
{
bundles
parseMarkup
}
=
props
;
if
(
bundles
=
=
=
undefined
)
{
throw
new
Error
(
"
LocalizationProvider
must
receive
the
bundles
prop
.
"
)
;
}
if
(
!
bundles
[
Symbol
.
iterator
]
)
{
throw
new
Error
(
"
The
bundles
prop
must
be
an
iterable
.
"
)
;
}
this
.
l10n
=
new
ReactLocalization
(
bundles
)
;
this
.
parseMarkup
=
parseMarkup
|
|
createParseMarkup
(
)
;
}
getChildContext
(
)
{
return
{
l10n
:
this
.
l10n
parseMarkup
:
this
.
parseMarkup
}
;
}
componentWillReceiveProps
(
next
)
{
const
{
bundles
}
=
next
;
if
(
bundles
!
=
=
this
.
props
.
bundles
)
{
this
.
l10n
.
setBundles
(
bundles
)
;
}
}
render
(
)
{
return
external_React_namespaceObject
.
Children
.
only
(
this
.
props
.
children
)
;
}
}
LocalizationProvider
.
childContextTypes
=
{
l10n
:
isReactLocalization
parseMarkup
:
(
external_PropTypes_default
(
)
)
.
func
}
;
LocalizationProvider
.
propTypes
=
{
children
:
(
external_PropTypes_default
(
)
)
.
element
.
isRequired
bundles
:
isIterable
parseMarkup
:
(
external_PropTypes_default
(
)
)
.
func
}
;
function
isIterable
(
props
propName
componentName
)
{
const
prop
=
props
[
propName
]
;
if
(
Symbol
.
iterator
in
Object
(
prop
)
)
{
return
null
;
}
return
new
Error
(
The
{
propName
}
prop
supplied
to
{
componentName
}
must
be
an
iterable
.
)
;
}
;
function
withLocalization
(
Inner
)
{
class
WithLocalization
extends
external_React_namespaceObject
.
Component
{
componentDidMount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
subscribe
(
this
)
;
}
}
componentWillUnmount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
unsubscribe
(
this
)
;
}
}
relocalize
(
)
{
this
.
forceUpdate
(
)
;
}
getString
(
id
args
fallback
)
{
const
{
l10n
}
=
this
.
context
;
if
(
!
l10n
)
{
return
fallback
|
|
id
;
}
return
l10n
.
getString
(
id
args
fallback
)
;
}
render
(
)
{
return
(
0
external_React_namespaceObject
.
createElement
)
(
Inner
Object
.
assign
(
{
getString
:
(
.
.
.
args
)
=
>
this
.
getString
(
.
.
.
args
)
}
this
.
props
)
)
;
}
}
WithLocalization
.
displayName
=
WithLocalization
(
{
displayName
(
Inner
)
}
)
;
WithLocalization
.
contextTypes
=
{
l10n
:
isReactLocalization
}
;
return
WithLocalization
;
}
function
displayName
(
component
)
{
return
component
.
displayName
|
|
component
.
name
|
|
"
Component
"
;
}
;
var
omittedCloseTags
=
{
area
:
true
base
:
true
br
:
true
col
:
true
embed
:
true
hr
:
true
img
:
true
input
:
true
keygen
:
true
link
:
true
meta
:
true
param
:
true
source
:
true
track
:
true
wbr
:
true
}
;
const
vendor_omittedCloseTags
=
(
omittedCloseTags
)
;
;
var
voidElementTags
=
{
menuitem
:
true
.
.
.
vendor_omittedCloseTags
}
;
const
vendor_voidElementTags
=
(
voidElementTags
)
;
;
const
reMarkup
=
/
<
|
&
#
?
\
w
+
;
/
;
function
toArguments
(
props
)
{
const
args
=
{
}
;
const
elems
=
{
}
;
for
(
const
[
propname
propval
]
of
Object
.
entries
(
props
)
)
{
if
(
propname
.
startsWith
(
"
"
)
)
{
const
name
=
propname
.
substr
(
1
)
;
args
[
name
]
=
propval
;
}
else
if
(
(
0
external_React_namespaceObject
.
isValidElement
)
(
propval
)
)
{
const
name
=
propname
.
toLowerCase
(
)
;
elems
[
name
]
=
propval
;
}
}
return
[
args
elems
]
;
}
class
Localized
extends
external_React_namespaceObject
.
Component
{
componentDidMount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
subscribe
(
this
)
;
}
}
componentWillUnmount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
unsubscribe
(
this
)
;
}
}
relocalize
(
)
{
this
.
forceUpdate
(
)
;
}
render
(
)
{
const
{
l10n
parseMarkup
}
=
this
.
context
;
const
{
id
attrs
children
:
elem
=
null
}
=
this
.
props
;
if
(
Array
.
isArray
(
elem
)
)
{
throw
new
Error
(
"
<
Localized
/
>
expected
to
receive
a
single
"
+
"
React
node
child
"
)
;
}
if
(
!
l10n
)
{
return
elem
;
}
const
bundle
=
l10n
.
getBundle
(
id
)
;
if
(
bundle
=
=
=
null
)
{
return
elem
;
}
const
msg
=
bundle
.
getMessage
(
id
)
;
const
[
args
elems
]
=
toArguments
(
this
.
props
)
;
const
messageValue
=
bundle
.
format
(
msg
args
)
;
if
(
!
(
0
external_React_namespaceObject
.
isValidElement
)
(
elem
)
)
{
return
messageValue
;
}
if
(
attrs
&
&
msg
.
attrs
)
{
var
localizedProps
=
{
}
;
for
(
const
[
name
allowed
]
of
Object
.
entries
(
attrs
)
)
{
if
(
allowed
&
&
msg
.
attrs
.
hasOwnProperty
(
name
)
)
{
localizedProps
[
name
]
=
bundle
.
format
(
msg
.
attrs
[
name
]
args
)
;
}
}
}
if
(
elem
.
type
in
vendor_voidElementTags
)
{
return
(
0
external_React_namespaceObject
.
cloneElement
)
(
elem
localizedProps
)
;
}
if
(
messageValue
=
=
=
null
)
{
return
(
0
external_React_namespaceObject
.
cloneElement
)
(
elem
localizedProps
)
;
}
if
(
!
reMarkup
.
test
(
messageValue
)
)
{
return
(
0
external_React_namespaceObject
.
cloneElement
)
(
elem
localizedProps
messageValue
)
;
}
const
translationNodes
=
parseMarkup
(
messageValue
)
;
const
translatedChildren
=
translationNodes
.
map
(
childNode
=
>
{
if
(
childNode
.
nodeType
=
=
=
childNode
.
TEXT_NODE
)
{
return
childNode
.
textContent
;
}
if
(
!
elems
.
hasOwnProperty
(
childNode
.
localName
)
)
{
return
childNode
.
textContent
;
}
const
sourceChild
=
elems
[
childNode
.
localName
]
;
if
(
sourceChild
.
type
in
vendor_voidElementTags
)
{
return
sourceChild
;
}
return
(
0
external_React_namespaceObject
.
cloneElement
)
(
sourceChild
null
childNode
.
textContent
)
;
}
)
;
return
(
0
external_React_namespaceObject
.
cloneElement
)
(
elem
localizedProps
.
.
.
translatedChildren
)
;
}
}
Localized
.
contextTypes
=
{
l10n
:
isReactLocalization
parseMarkup
:
(
external_PropTypes_default
(
)
)
.
func
}
;
Localized
.
propTypes
=
{
children
:
(
external_PropTypes_default
(
)
)
.
node
}
;
;
;
const
IS_NEWTAB
=
__webpack_require__
.
g
.
document
&
&
__webpack_require__
.
g
.
document
.
documentURI
=
=
=
"
about
:
newtab
"
;
const
NEWTAB_DARK_THEME
=
{
ntp_background
:
{
r
:
42
g
:
42
b
:
46
a
:
1
}
ntp_card_background
:
{
r
:
66
g
:
65
b
:
77
a
:
1
}
ntp_text
:
{
r
:
249
g
:
249
b
:
250
a
:
1
}
sidebar
:
{
r
:
56
g
:
56
b
:
61
a
:
1
}
sidebar_text
:
{
r
:
249
g
:
249
b
:
250
a
:
1
}
}
;
;
const
external_ReactDOM_namespaceObject
=
ReactDOM
;
var
external_ReactDOM_default
=
__webpack_require__
.
n
(
external_ReactDOM_namespaceObject
)
;
;
const
ALLOWED_STYLE_TAGS
=
[
"
color
"
"
backgroundColor
"
]
;
const
Button
=
props
=
>
{
const
style
=
{
}
;
for
(
const
tag
of
ALLOWED_STYLE_TAGS
)
{
if
(
typeof
props
[
tag
]
!
=
=
"
undefined
"
)
{
style
[
tag
]
=
props
[
tag
]
;
}
}
if
(
style
.
backgroundColor
)
{
style
.
border
=
"
0
"
;
}
return
external_React_default
(
)
.
createElement
(
"
button
"
{
onClick
:
props
.
onClick
className
:
props
.
className
|
|
"
ASRouterButton
secondary
"
style
:
style
}
props
.
children
)
;
}
;
;
const
ConditionalWrapper
=
(
{
condition
wrap
children
}
)
=
>
condition
&
&
wrap
?
wrap
(
children
)
:
children
;
const
ConditionalWrapper_ConditionalWrapper
=
(
ConditionalWrapper
)
;
;
function
safeURI
(
url
)
{
if
(
!
url
)
{
return
"
"
;
}
const
{
protocol
}
=
new
URL
(
url
)
;
const
isAllowed
=
[
"
http
:
"
"
https
:
"
"
data
:
"
"
resource
:
"
"
chrome
:
"
]
.
includes
(
protocol
)
;
if
(
!
isAllowed
)
{
console
.
warn
(
The
protocol
{
protocol
}
is
not
allowed
for
template
URLs
.
)
;
}
return
isAllowed
?
url
:
"
"
;
}
;
function
RichText_extends
(
)
{
RichText_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
RichText_extends
.
apply
(
this
arguments
)
;
}
const
ALLOWED_TAGS
=
{
b
:
external_React_default
(
)
.
createElement
(
"
b
"
null
)
i
:
external_React_default
(
)
.
createElement
(
"
i
"
null
)
u
:
external_React_default
(
)
.
createElement
(
"
u
"
null
)
strong
:
external_React_default
(
)
.
createElement
(
"
strong
"
null
)
em
:
external_React_default
(
)
.
createElement
(
"
em
"
null
)
br
:
external_React_default
(
)
.
createElement
(
"
br
"
null
)
}
;
function
convertLinks
(
links
sendClick
doNotAutoBlock
openNewWindow
=
false
)
{
if
(
links
)
{
return
Object
.
keys
(
links
)
.
reduce
(
(
acc
linkTag
)
=
>
{
const
{
action
}
=
links
[
linkTag
]
;
const
url
=
action
?
false
:
safeURI
(
links
[
linkTag
]
.
url
)
;
acc
[
linkTag
]
=
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
url
target
:
openNewWindow
?
"
_blank
"
:
"
"
"
data
-
metric
"
:
links
[
linkTag
]
.
metric
"
data
-
action
"
:
action
"
data
-
args
"
:
links
[
linkTag
]
.
args
"
data
-
do_not_autoblock
"
:
doNotAutoBlock
"
data
-
entrypoint_name
"
:
links
[
linkTag
]
.
entrypoint_name
"
data
-
entrypoint_value
"
:
links
[
linkTag
]
.
entrypoint_value
rel
:
"
noreferrer
"
onClick
:
sendClick
}
)
;
return
acc
;
}
{
}
)
;
}
return
null
;
}
function
RichText
(
props
)
{
if
(
!
RICH_TEXT_KEYS
.
includes
(
props
.
localization_id
)
)
{
throw
new
Error
(
ASRouter
:
{
props
.
localization_id
}
is
not
a
valid
rich
text
property
.
If
you
want
it
to
be
processed
you
need
to
add
it
to
asrouter
/
rich
-
text
-
strings
.
js
)
;
}
return
external_React_default
(
)
.
createElement
(
Localized
RichText_extends
(
{
id
:
props
.
localization_id
}
ALLOWED_TAGS
props
.
customElements
convertLinks
(
props
.
links
props
.
sendClick
props
.
doNotAutoBlock
props
.
openNewWindow
)
)
external_React_default
(
)
.
createElement
(
"
span
"
null
props
.
text
)
)
;
}
;
class
SnippetBase
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onBlockClicked
=
this
.
onBlockClicked
.
bind
(
this
)
;
this
.
onDismissClicked
=
this
.
onDismissClicked
.
bind
(
this
)
;
this
.
setBlockButtonRef
=
this
.
setBlockButtonRef
.
bind
(
this
)
;
this
.
onBlockButtonMouseEnter
=
this
.
onBlockButtonMouseEnter
.
bind
(
this
)
;
this
.
onBlockButtonMouseLeave
=
this
.
onBlockButtonMouseLeave
.
bind
(
this
)
;
this
.
state
=
{
blockButtonHover
:
false
}
;
}
componentDidMount
(
)
{
if
(
this
.
blockButtonRef
)
{
this
.
blockButtonRef
.
addEventListener
(
"
mouseenter
"
this
.
onBlockButtonMouseEnter
)
;
this
.
blockButtonRef
.
addEventListener
(
"
mouseleave
"
this
.
onBlockButtonMouseLeave
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
blockButtonRef
)
{
this
.
blockButtonRef
.
removeEventListener
(
"
mouseenter
"
this
.
onBlockButtonMouseEnter
)
;
this
.
blockButtonRef
.
removeEventListener
(
"
mouseleave
"
this
.
onBlockButtonMouseLeave
)
;
}
}
setBlockButtonRef
(
element
)
{
this
.
blockButtonRef
=
element
;
}
onBlockButtonMouseEnter
(
)
{
this
.
setState
(
{
blockButtonHover
:
true
}
)
;
}
onBlockButtonMouseLeave
(
)
{
this
.
setState
(
{
blockButtonHover
:
false
}
)
;
}
onBlockClicked
(
)
{
if
(
this
.
props
.
provider
!
=
=
"
preview
"
)
{
this
.
props
.
sendUserActionTelemetry
(
{
event
:
"
BLOCK
"
id
:
this
.
props
.
UISurface
}
)
;
}
this
.
props
.
onBlock
(
)
;
}
onDismissClicked
(
)
{
if
(
this
.
props
.
provider
!
=
=
"
preview
"
)
{
this
.
props
.
sendUserActionTelemetry
(
{
event
:
"
DISMISS
"
id
:
this
.
props
.
UISurface
}
)
;
}
this
.
props
.
onDismiss
(
)
;
}
renderDismissButton
(
)
{
if
(
this
.
props
.
footerDismiss
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
footer
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
footer
-
content
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
ASRouterButton
secondary
"
onClick
:
this
.
onDismissClicked
}
this
.
props
.
content
.
scene2_dismiss_button_text
)
)
)
;
}
const
label
=
this
.
props
.
content
.
block_button_text
|
|
"
Remove
this
"
;
return
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
blockButton
"
title
:
label
"
aria
-
label
"
:
label
onClick
:
this
.
onBlockClicked
ref
:
this
.
setBlockButtonRef
}
)
;
}
render
(
)
{
const
{
props
}
=
this
;
const
{
blockButtonHover
}
=
this
.
state
;
const
containerClassName
=
SnippetBaseContainer
{
props
.
className
?
{
props
.
className
}
:
"
"
}
{
blockButtonHover
?
"
active
"
:
"
"
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
containerClassName
style
:
this
.
props
.
textStyle
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
innerWrapper
"
}
props
.
children
)
this
.
renderDismissButton
(
)
)
;
}
}
;
function
SimpleSnippet_extends
(
)
{
SimpleSnippet_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
SimpleSnippet_extends
.
apply
(
this
arguments
)
;
}
const
DEFAULT_ICON_PATH
=
"
chrome
:
/
/
branding
/
content
/
icon64
.
png
"
;
const
ICON_ALT_TEXT
=
"
"
;
class
SimpleSnippet
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onButtonClick
=
this
.
onButtonClick
.
bind
(
this
)
;
}
onButtonClick
(
)
{
if
(
this
.
props
.
provider
!
=
=
"
preview
"
)
{
this
.
props
.
sendUserActionTelemetry
(
{
event
:
"
CLICK_BUTTON
"
id
:
this
.
props
.
UISurface
}
)
;
}
const
{
button_url
button_entrypoint_value
button_entrypoint_name
}
=
this
.
props
.
content
;
const
type
=
this
.
props
.
content
.
button_action
|
|
button_url
&
&
"
OPEN_URL
"
;
const
entrypoint
=
button_entrypoint_name
?
new
URLSearchParams
(
[
[
button_entrypoint_name
button_entrypoint_value
]
]
)
.
toString
(
)
:
button_entrypoint_value
;
this
.
props
.
onAction
(
{
type
data
:
{
args
:
this
.
props
.
content
.
button_action_args
|
|
button_url
.
.
.
(
entrypoint
&
&
{
entrypoint
}
)
}
}
)
;
if
(
!
this
.
props
.
content
.
do_not_autoblock
)
{
this
.
props
.
onBlock
(
)
;
}
}
_shouldRenderButton
(
)
{
return
this
.
props
.
content
.
button_action
|
|
this
.
props
.
onButtonClick
|
|
this
.
props
.
content
.
button_url
;
}
renderTitle
(
)
{
const
{
title
}
=
this
.
props
.
content
;
return
title
?
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
title
{
this
.
_shouldRenderButton
(
)
?
"
title
-
inline
"
:
"
"
}
}
this
.
renderTitleIcon
(
)
"
"
title
)
:
null
;
}
renderTitleIcon
(
)
{
const
titleIconLight
=
safeURI
(
this
.
props
.
content
.
title_icon
)
;
const
titleIconDark
=
safeURI
(
this
.
props
.
content
.
title_icon_dark_theme
|
|
this
.
props
.
content
.
title_icon
)
;
if
(
!
titleIconLight
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
titleIcon
icon
-
light
-
theme
"
style
:
{
backgroundImage
:
url
(
"
{
titleIconLight
}
"
)
}
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
titleIcon
icon
-
dark
-
theme
"
style
:
{
backgroundImage
:
url
(
"
{
titleIconDark
}
"
)
}
}
)
)
;
}
renderButton
(
)
{
const
{
props
}
=
this
;
if
(
!
this
.
_shouldRenderButton
(
)
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
Button
{
onClick
:
props
.
onButtonClick
|
|
this
.
onButtonClick
color
:
props
.
content
.
button_color
backgroundColor
:
props
.
content
.
button_background_color
}
props
.
content
.
button_label
)
;
}
renderText
(
)
{
const
{
props
}
=
this
;
return
external_React_default
(
)
.
createElement
(
RichText
{
text
:
props
.
content
.
text
customElements
:
this
.
props
.
customElements
localization_id
:
"
text
"
links
:
props
.
content
.
links
sendClick
:
props
.
sendClick
}
)
;
}
wrapSectionHeader
(
url
)
{
return
function
(
children
)
{
return
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
url
}
children
)
;
}
;
}
wrapSnippetContent
(
children
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
innerContentWrapper
"
}
children
)
;
}
renderSectionHeader
(
)
{
const
{
props
}
=
this
;
if
(
props
.
content
.
section_title_icon
&
&
props
.
content
.
section_title_text
)
{
const
sectionTitleIconLight
=
safeURI
(
props
.
content
.
section_title_icon
)
;
const
sectionTitleIconDark
=
safeURI
(
props
.
content
.
section_title_icon_dark_theme
|
|
props
.
content
.
section_title_icon
)
;
const
sectionTitleURL
=
props
.
content
.
section_title_url
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
header
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
ConditionalWrapper_ConditionalWrapper
{
condition
:
sectionTitleURL
wrap
:
this
.
wrapSectionHeader
(
sectionTitleURL
)
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
light
-
theme
"
style
:
{
backgroundImage
:
url
(
"
{
sectionTitleIconLight
}
"
)
}
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
dark
-
theme
"
style
:
{
backgroundImage
:
url
(
"
{
sectionTitleIconDark
}
"
)
}
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
-
text
"
}
props
.
content
.
section_title_text
)
)
)
)
;
}
return
null
;
}
render
(
)
{
const
{
props
}
=
this
;
const
sectionHeader
=
this
.
renderSectionHeader
(
)
;
let
className
=
"
SimpleSnippet
"
;
if
(
props
.
className
)
{
className
+
=
{
props
.
className
}
;
}
if
(
props
.
content
.
tall
)
{
className
+
=
"
tall
"
;
}
if
(
sectionHeader
)
{
className
+
=
"
has
-
section
-
header
"
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
snippet
-
hover
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
SnippetBase
SimpleSnippet_extends
(
{
}
props
{
className
:
className
textStyle
:
this
.
props
.
textStyle
}
)
sectionHeader
external_React_default
(
)
.
createElement
(
ConditionalWrapper_ConditionalWrapper
{
condition
:
sectionHeader
wrap
:
this
.
wrapSnippetContent
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
safeURI
(
props
.
content
.
icon
)
|
|
DEFAULT_ICON_PATH
className
:
"
icon
icon
-
light
-
theme
"
alt
:
props
.
content
.
icon_alt_text
|
|
ICON_ALT_TEXT
}
)
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
safeURI
(
props
.
content
.
icon_dark_theme
|
|
props
.
content
.
icon
)
|
|
DEFAULT_ICON_PATH
className
:
"
icon
icon
-
dark
-
theme
"
alt
:
props
.
content
.
icon_alt_text
|
|
ICON_ALT_TEXT
}
)
external_React_default
(
)
.
createElement
(
"
div
"
null
this
.
renderTitle
(
)
"
"
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
body
"
}
this
.
renderText
(
)
)
this
.
props
.
extraContent
)
external_React_default
(
)
.
createElement
(
"
div
"
null
this
.
renderButton
(
)
)
)
)
)
;
}
}
;
function
EOYSnippet_extends
(
)
{
EOYSnippet_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
EOYSnippet_extends
.
apply
(
this
arguments
)
;
}
class
EOYSnippetBase
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
handleSubmit
=
this
.
handleSubmit
.
bind
(
this
)
;
}
setFrequencyValue
(
)
{
const
frequencyCheckbox
=
this
.
refs
.
form
.
querySelector
(
"
#
monthly
-
checkbox
"
)
;
if
(
frequencyCheckbox
.
checked
)
{
this
.
refs
.
form
.
querySelector
(
"
[
name
=
'
frequency
'
]
"
)
.
value
=
"
monthly
"
;
}
}
handleSubmit
(
event
)
{
event
.
preventDefault
(
)
;
this
.
props
.
sendClick
(
event
)
;
this
.
setFrequencyValue
(
)
;
if
(
!
this
.
props
.
content
.
do_not_autoblock
)
{
this
.
props
.
onBlock
(
)
;
}
this
.
refs
.
form
.
submit
(
)
;
}
renderDonations
(
)
{
const
fieldNames
=
[
"
first
"
"
second
"
"
third
"
"
fourth
"
]
;
const
numberFormat
=
new
Intl
.
NumberFormat
(
this
.
props
.
content
.
locale
|
|
navigator
.
language
{
style
:
"
currency
"
currency
:
this
.
props
.
content
.
currency_code
minimumFractionDigits
:
0
}
)
;
const
{
selected_button
}
=
this
.
props
.
content
;
const
btnStyle
=
{
color
:
this
.
props
.
content
.
button_color
backgroundColor
:
this
.
props
.
content
.
button_background_color
}
;
const
donationURLParams
=
[
]
;
const
paramsStartIndex
=
this
.
props
.
content
.
donation_form_url
.
indexOf
(
"
?
"
)
;
for
(
const
entry
of
new
URLSearchParams
(
this
.
props
.
content
.
donation_form_url
.
slice
(
paramsStartIndex
)
)
.
entries
(
)
)
{
donationURLParams
.
push
(
entry
)
;
}
return
external_React_default
(
)
.
createElement
(
"
form
"
{
className
:
"
EOYSnippetForm
"
action
:
this
.
props
.
content
.
donation_form_url
method
:
this
.
props
.
form_method
onSubmit
:
this
.
handleSubmit
"
data
-
metric
"
:
"
EOYSnippetForm
"
ref
:
"
form
"
}
donationURLParams
.
map
(
(
[
key
value
]
idx
)
=
>
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
hidden
"
name
:
key
value
:
value
key
:
idx
}
)
)
fieldNames
.
map
(
(
field
idx
)
=
>
{
const
button_name
=
donation_amount_
{
field
}
;
const
amount
=
this
.
props
.
content
[
button_name
]
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
{
key
:
idx
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
radio
"
name
:
"
amount
"
value
:
amount
id
:
field
defaultChecked
:
button_name
=
=
=
selected_button
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
field
className
:
"
donation
-
amount
"
}
numberFormat
.
format
(
amount
)
)
)
;
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
monthly
-
checkbox
-
container
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
monthly
-
checkbox
"
type
:
"
checkbox
"
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
"
monthly
-
checkbox
"
}
this
.
props
.
content
.
monthly_checkbox_label_text
)
)
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
hidden
"
name
:
"
frequency
"
value
:
"
single
"
}
)
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
hidden
"
name
:
"
currency
"
value
:
this
.
props
.
content
.
currency_code
}
)
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
hidden
"
name
:
"
presets
"
value
:
fieldNames
.
map
(
field
=
>
this
.
props
.
content
[
donation_amount_
{
field
}
]
)
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
style
:
btnStyle
type
:
"
submit
"
className
:
"
ASRouterButton
primary
donation
-
form
-
url
"
}
this
.
props
.
content
.
button_label
)
)
;
}
render
(
)
{
const
textStyle
=
{
color
:
this
.
props
.
content
.
text_color
backgroundColor
:
this
.
props
.
content
.
background_color
}
;
const
customElement
=
external_React_default
(
)
.
createElement
(
"
em
"
{
style
:
{
backgroundColor
:
this
.
props
.
content
.
highlight_color
}
}
)
;
return
external_React_default
(
)
.
createElement
(
SimpleSnippet
EOYSnippet_extends
(
{
}
this
.
props
{
className
:
this
.
props
.
content
.
test
customElements
:
{
em
:
customElement
}
textStyle
:
textStyle
extraContent
:
this
.
renderDonations
(
)
}
)
)
;
}
}
const
EOYSnippet
=
props
=
>
{
const
extendedContent
=
{
monthly_checkbox_label_text
:
"
Make
my
donation
monthly
"
locale
:
"
en
-
US
"
currency_code
:
"
usd
"
selected_button
:
"
donation_amount_second
"
.
.
.
props
.
content
}
;
return
external_React_default
(
)
.
createElement
(
EOYSnippetBase
EOYSnippet_extends
(
{
}
props
{
content
:
extendedContent
form_method
:
"
GET
"
}
)
)
;
}
;
;
function
SubmitFormSnippet_extends
(
)
{
SubmitFormSnippet_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
SubmitFormSnippet_extends
.
apply
(
this
arguments
)
;
}
const
SubmitFormSnippet_ICON_ALT_TEXT
=
"
"
;
class
SubmitFormSnippet
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
expandSnippet
=
this
.
expandSnippet
.
bind
(
this
)
;
this
.
handleSubmit
=
this
.
handleSubmit
.
bind
(
this
)
;
this
.
handleSubmitAttempt
=
this
.
handleSubmitAttempt
.
bind
(
this
)
;
this
.
onInputChange
=
this
.
onInputChange
.
bind
(
this
)
;
this
.
state
=
{
expanded
:
false
submitAttempted
:
false
signupSubmitted
:
false
signupSuccess
:
false
disableForm
:
false
}
;
}
handleSubmitAttempt
(
)
{
if
(
!
this
.
state
.
submitAttempted
)
{
this
.
setState
(
{
submitAttempted
:
true
}
)
;
}
}
async
handleSubmit
(
event
)
{
let
json
;
if
(
this
.
state
.
disableForm
)
{
return
;
}
event
.
preventDefault
(
)
;
this
.
setState
(
{
disableForm
:
true
}
)
;
this
.
props
.
sendUserActionTelemetry
(
{
event
:
"
CLICK_BUTTON
"
event_context
:
"
conversion
-
subscribe
-
activation
"
id
:
"
NEWTAB_FOOTER_BAR_CONTENT
"
}
)
;
if
(
this
.
props
.
form_method
.
toUpperCase
(
)
=
=
=
"
GET
"
)
{
this
.
props
.
onBlock
(
{
preventDismiss
:
true
}
)
;
this
.
refs
.
form
.
submit
(
)
;
return
;
}
const
{
url
formData
}
=
this
.
props
.
processFormData
?
this
.
props
.
processFormData
(
this
.
refs
.
mainInput
this
.
props
)
:
{
url
:
this
.
refs
.
form
.
action
formData
:
new
FormData
(
this
.
refs
.
form
)
}
;
try
{
const
fetchRequest
=
new
Request
(
url
{
body
:
formData
method
:
"
POST
"
credentials
:
"
omit
"
}
)
;
const
response
=
await
fetch
(
fetchRequest
)
;
json
=
await
response
.
json
(
)
;
}
catch
(
err
)
{
console
.
log
(
err
)
;
}
if
(
json
&
&
json
.
status
=
=
=
"
ok
"
)
{
this
.
setState
(
{
signupSuccess
:
true
signupSubmitted
:
true
}
)
;
if
(
!
this
.
props
.
content
.
do_not_autoblock
)
{
this
.
props
.
onBlock
(
{
preventDismiss
:
true
}
)
;
}
this
.
props
.
sendUserActionTelemetry
(
{
event
:
"
CLICK_BUTTON
"
event_context
:
"
subscribe
-
success
"
id
:
"
NEWTAB_FOOTER_BAR_CONTENT
"
}
)
;
}
else
{
console
.
error
(
"
There
was
a
problem
submitting
the
form
"
json
|
|
"
[
No
JSON
response
]
"
)
;
this
.
setState
(
{
signupSuccess
:
false
signupSubmitted
:
true
}
)
;
this
.
props
.
sendUserActionTelemetry
(
{
event
:
"
CLICK_BUTTON
"
event_context
:
"
subscribe
-
error
"
id
:
"
NEWTAB_FOOTER_BAR_CONTENT
"
}
)
;
}
this
.
setState
(
{
disableForm
:
false
}
)
;
}
expandSnippet
(
)
{
this
.
props
.
sendUserActionTelemetry
(
{
event
:
"
CLICK_BUTTON
"
event_context
:
"
scene1
-
button
-
learn
-
more
"
id
:
this
.
props
.
UISurface
}
)
;
this
.
setState
(
{
expanded
:
true
signupSuccess
:
false
signupSubmitted
:
false
}
)
;
}
renderHiddenFormInputs
(
)
{
const
{
hidden_inputs
}
=
this
.
props
.
content
;
if
(
!
hidden_inputs
)
{
return
null
;
}
return
Object
.
keys
(
hidden_inputs
)
.
map
(
(
key
idx
)
=
>
external_React_default
(
)
.
createElement
(
"
input
"
{
key
:
idx
type
:
"
hidden
"
name
:
key
value
:
hidden_inputs
[
key
]
}
)
)
;
}
renderDisclaimer
(
)
{
const
{
content
}
=
this
.
props
;
if
(
!
content
.
scene2_disclaimer_html
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
disclaimerText
"
}
external_React_default
(
)
.
createElement
(
RichText
{
text
:
content
.
scene2_disclaimer_html
localization_id
:
"
disclaimer_html
"
links
:
content
.
links
doNotAutoBlock
:
true
openNewWindow
:
true
sendClick
:
this
.
props
.
sendClick
}
)
)
;
}
renderFormPrivacyNotice
(
)
{
const
{
content
}
=
this
.
props
;
if
(
!
content
.
scene2_privacy_html
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
privacyNotice
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
id
:
"
id_privacy
"
name
:
"
privacy
"
required
:
"
required
"
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
"
id_privacy
"
}
external_React_default
(
)
.
createElement
(
RichText
{
text
:
content
.
scene2_privacy_html
localization_id
:
"
privacy_html
"
links
:
content
.
links
doNotAutoBlock
:
true
openNewWindow
:
true
sendClick
:
this
.
props
.
sendClick
}
)
)
)
;
}
renderSignupSubmitted
(
)
{
const
{
content
}
=
this
.
props
;
const
isSuccess
=
this
.
state
.
signupSuccess
;
const
successTitle
=
isSuccess
&
&
content
.
success_title
;
const
bodyText
=
isSuccess
?
{
success_text
:
content
.
success_text
}
:
{
error_text
:
content
.
error_text
}
;
const
retryButtonText
=
content
.
retry_button_label
;
return
external_React_default
(
)
.
createElement
(
SnippetBase
this
.
props
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
submissionStatus
"
}
successTitle
?
external_React_default
(
)
.
createElement
(
"
h2
"
{
className
:
"
submitStatusTitle
"
}
successTitle
)
:
null
external_React_default
(
)
.
createElement
(
"
p
"
null
external_React_default
(
)
.
createElement
(
RichText
SubmitFormSnippet_extends
(
{
}
bodyText
{
localization_id
:
isSuccess
?
"
success_text
"
:
"
error_text
"
}
)
)
isSuccess
?
null
:
external_React_default
(
)
.
createElement
(
Button
{
onClick
:
this
.
expandSnippet
}
retryButtonText
)
)
)
)
;
}
onInputChange
(
event
)
{
if
(
!
this
.
props
.
validateInput
)
{
return
;
}
const
hasError
=
this
.
props
.
validateInput
(
event
.
target
.
value
this
.
props
.
content
)
;
event
.
target
.
setCustomValidity
(
hasError
)
;
}
wrapSectionHeader
(
url
)
{
return
function
(
children
)
{
return
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
url
}
children
)
;
}
;
}
renderInput
(
)
{
const
placholder
=
this
.
props
.
content
.
scene2_email_placeholder_text
|
|
this
.
props
.
content
.
scene2_input_placeholder
;
return
external_React_default
(
)
.
createElement
(
"
input
"
{
ref
:
"
mainInput
"
type
:
this
.
props
.
inputType
|
|
"
email
"
className
:
mainInput
{
this
.
state
.
submitAttempted
?
"
"
:
"
clean
"
}
name
:
"
email
"
required
:
true
placeholder
:
placholder
onChange
:
this
.
props
.
validateInput
?
this
.
onInputChange
:
null
}
)
;
}
renderForm
(
)
{
return
external_React_default
(
)
.
createElement
(
"
form
"
{
action
:
this
.
props
.
form_action
method
:
this
.
props
.
form_method
onSubmit
:
this
.
handleSubmit
ref
:
"
form
"
}
this
.
renderHiddenFormInputs
(
)
external_React_default
(
)
.
createElement
(
"
div
"
null
this
.
renderInput
(
)
external_React_default
(
)
.
createElement
(
"
button
"
{
type
:
"
submit
"
className
:
"
ASRouterButton
primary
"
onClick
:
this
.
handleSubmitAttempt
ref
:
"
formSubmitBtn
"
}
this
.
props
.
content
.
scene2_button_label
)
)
this
.
renderFormPrivacyNotice
(
)
|
|
this
.
renderDisclaimer
(
)
)
;
}
renderScene2Icon
(
)
{
const
{
content
}
=
this
.
props
;
if
(
!
content
.
scene2_icon
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
scene2Icon
"
}
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
safeURI
(
content
.
scene2_icon
)
className
:
"
icon
-
light
-
theme
"
alt
:
content
.
scene2_icon_alt_text
|
|
SubmitFormSnippet_ICON_ALT_TEXT
}
)
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
safeURI
(
content
.
scene2_icon_dark_theme
|
|
content
.
scene2_icon
)
className
:
"
icon
-
dark
-
theme
"
alt
:
content
.
scene2_icon_alt_text
|
|
SubmitFormSnippet_ICON_ALT_TEXT
}
)
)
;
}
renderSignupView
(
)
{
const
{
content
}
=
this
.
props
;
const
containerClass
=
SubmitFormSnippet
{
this
.
props
.
className
}
;
return
external_React_default
(
)
.
createElement
(
SnippetBase
SubmitFormSnippet_extends
(
{
}
this
.
props
{
className
:
containerClass
footerDismiss
:
true
}
)
this
.
renderScene2Icon
(
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
message
"
}
external_React_default
(
)
.
createElement
(
"
p
"
null
content
.
scene2_title
&
&
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
scene2Title
"
}
content
.
scene2_title
)
"
"
content
.
scene2_text
&
&
external_React_default
(
)
.
createElement
(
RichText
{
scene2_text
:
content
.
scene2_text
localization_id
:
"
scene2_text
"
}
)
)
)
this
.
renderForm
(
)
)
;
}
renderSectionHeader
(
)
{
const
{
props
}
=
this
;
if
(
props
.
content
.
section_title_icon
&
&
props
.
content
.
section_title_text
)
{
const
sectionTitleIconLight
=
safeURI
(
props
.
content
.
section_title_icon
)
;
const
sectionTitleIconDark
=
safeURI
(
props
.
content
.
section_title_icon_dark_theme
|
|
props
.
content
.
section_title_icon
)
;
const
sectionTitleURL
=
props
.
content
.
section_title_url
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
header
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
ConditionalWrapper_ConditionalWrapper
{
wrap
:
this
.
wrapSectionHeader
(
sectionTitleURL
)
condition
:
sectionTitleURL
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
light
-
theme
"
style
:
{
backgroundImage
:
url
(
"
{
sectionTitleIconLight
}
"
)
}
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
dark
-
theme
"
style
:
{
backgroundImage
:
url
(
"
{
sectionTitleIconDark
}
"
)
}
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
-
text
"
}
props
.
content
.
section_title_text
)
)
)
)
;
}
return
null
;
}
renderSignupViewAlt
(
)
{
const
{
content
}
=
this
.
props
;
const
containerClass
=
SubmitFormSnippet
{
this
.
props
.
className
}
scene2Alt
;
return
external_React_default
(
)
.
createElement
(
SnippetBase
SubmitFormSnippet_extends
(
{
}
this
.
props
{
className
:
containerClass
footerDismiss
:
false
}
)
this
.
renderSectionHeader
(
)
this
.
renderScene2Icon
(
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
message
"
}
external_React_default
(
)
.
createElement
(
"
p
"
null
content
.
scene2_text
&
&
external_React_default
(
)
.
createElement
(
RichText
{
scene2_text
:
content
.
scene2_text
localization_id
:
"
scene2_text
"
}
)
)
this
.
renderForm
(
)
)
)
;
}
getFirstSceneContent
(
)
{
return
Object
.
keys
(
this
.
props
.
content
)
.
filter
(
key
=
>
key
.
includes
(
"
scene1
"
)
)
.
reduce
(
(
acc
key
)
=
>
{
acc
[
key
.
substr
(
7
)
]
=
this
.
props
.
content
[
key
]
;
return
acc
;
}
{
}
)
;
}
render
(
)
{
const
content
=
{
.
.
.
this
.
props
.
content
.
.
.
this
.
getFirstSceneContent
(
)
}
;
if
(
this
.
state
.
signupSubmitted
)
{
return
this
.
renderSignupSubmitted
(
)
;
}
if
(
this
.
props
.
expandedAlt
)
{
return
this
.
renderSignupViewAlt
(
)
;
}
if
(
this
.
state
.
expanded
)
{
return
this
.
renderSignupView
(
)
;
}
return
external_React_default
(
)
.
createElement
(
SimpleSnippet
SubmitFormSnippet_extends
(
{
}
this
.
props
{
content
:
content
onButtonClick
:
this
.
expandSnippet
}
)
)
;
}
}
;
function
FXASignupSnippet_extends
(
)
{
FXASignupSnippet_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
FXASignupSnippet_extends
.
apply
(
this
arguments
)
;
}
const
FXASignupSnippet
=
props
=
>
{
const
userAgent
=
window
.
navigator
.
userAgent
.
match
(
/
Firefox
\
/
(
[
0
-
9
]
+
)
\
.
/
)
;
const
firefox_version
=
userAgent
?
parseInt
(
userAgent
[
1
]
10
)
:
0
;
const
extendedContent
=
{
scene1_button_label
:
"
Learn
more
"
retry_button_label
:
"
Try
again
"
scene2_email_placeholder_text
:
"
Your
email
here
"
scene2_button_label
:
"
Sign
me
up
"
scene2_dismiss_button_text
:
"
Dismiss
"
.
.
.
props
.
content
hidden_inputs
:
{
action
:
"
email
"
context
:
"
fx_desktop_v3
"
entrypoint
:
"
snippets
"
utm_source
:
"
snippet
"
utm_content
:
firefox_version
utm_campaign
:
props
.
content
.
utm_campaign
utm_term
:
props
.
content
.
utm_term
.
.
.
props
.
content
.
hidden_inputs
}
}
;
return
external_React_default
(
)
.
createElement
(
SubmitFormSnippet
FXASignupSnippet_extends
(
{
}
props
{
content
:
extendedContent
form_action
:
"
https
:
/
/
accounts
.
firefox
.
com
/
"
form_method
:
"
GET
"
}
)
)
;
}
;
;
function
NewsletterSnippet_extends
(
)
{
NewsletterSnippet_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
NewsletterSnippet_extends
.
apply
(
this
arguments
)
;
}
const
NewsletterSnippet
=
props
=
>
{
const
extendedContent
=
{
scene1_button_label
:
"
Learn
more
"
retry_button_label
:
"
Try
again
"
scene2_email_placeholder_text
:
"
Your
email
here
"
scene2_button_label
:
"
Sign
me
up
"
scene2_dismiss_button_text
:
"
Dismiss
"
scene2_newsletter
:
"
mozilla
-
foundation
"
.
.
.
props
.
content
hidden_inputs
:
{
newsletters
:
props
.
content
.
scene2_newsletter
|
|
"
mozilla
-
foundation
"
fmt
:
"
H
"
lang
:
props
.
content
.
locale
|
|
"
en
-
US
"
source_url
:
https
:
/
/
snippets
.
mozilla
.
com
/
show
/
{
props
.
id
}
.
.
.
props
.
content
.
hidden_inputs
}
}
;
return
external_React_default
(
)
.
createElement
(
SubmitFormSnippet
NewsletterSnippet_extends
(
{
}
props
{
content
:
extendedContent
form_action
:
"
https
:
/
/
basket
.
mozilla
.
org
/
subscribe
.
json
"
form_method
:
"
POST
"
}
)
)
;
}
;
;
function
isEmailOrPhoneNumber
(
val
content
)
{
const
{
locale
}
=
content
;
const
email_re
=
/
^
(
(
[
^
<
>
(
)
[
\
]
\
\
.
;
:
\
s
"
]
+
(
\
.
[
^
<
>
(
)
[
\
]
\
\
.
;
:
\
s
"
]
+
)
*
)
|
(
"
.
+
"
)
)
(
(
\
[
[
0
-
9
]
{
1
3
}
\
.
[
0
-
9
]
{
1
3
}
\
.
[
0
-
9
]
{
1
3
}
\
.
[
0
-
9
]
{
1
3
}
]
)
|
(
(
[
a
-
zA
-
Z
\
-
0
-
9
]
+
\
.
)
+
[
a
-
zA
-
Z
]
{
2
}
)
)
/
;
const
check_email
=
email_re
.
test
(
val
)
;
let
check_phone
;
switch
(
locale
)
{
case
"
en
-
US
"
:
case
"
en
-
CA
"
:
check_phone
=
val
.
length
>
=
10
&
&
val
.
length
<
=
11
&
&
!
isNaN
(
val
)
;
break
;
case
"
de
"
:
check_phone
=
val
.
length
>
=
2
&
&
val
.
length
<
=
12
&
&
!
isNaN
(
val
)
;
break
;
default
:
check_phone
=
!
isNaN
(
val
)
;
break
;
}
if
(
check_email
)
{
return
"
email
"
;
}
else
if
(
check_phone
)
{
return
"
phone
"
;
}
return
"
"
;
}
;
function
SendToDeviceSnippet_extends
(
)
{
SendToDeviceSnippet_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
SendToDeviceSnippet_extends
.
apply
(
this
arguments
)
;
}
function
validateInput
(
value
content
)
{
const
type
=
isEmailOrPhoneNumber
(
value
content
)
;
return
type
?
"
"
:
"
Must
be
an
email
or
a
phone
number
.
"
;
}
function
processFormData
(
input
message
)
{
const
{
content
}
=
message
;
const
type
=
content
.
include_sms
?
isEmailOrPhoneNumber
(
input
.
value
content
)
:
"
email
"
;
const
formData
=
new
FormData
(
)
;
let
url
;
if
(
type
=
=
=
"
phone
"
)
{
url
=
"
https
:
/
/
basket
.
mozilla
.
org
/
news
/
subscribe_sms
/
"
;
formData
.
append
(
"
mobile_number
"
input
.
value
)
;
formData
.
append
(
"
msg_name
"
content
.
message_id_sms
)
;
formData
.
append
(
"
country
"
content
.
country
)
;
}
else
if
(
type
=
=
=
"
email
"
)
{
url
=
"
https
:
/
/
basket
.
mozilla
.
org
/
news
/
subscribe
/
"
;
formData
.
append
(
"
email
"
input
.
value
)
;
formData
.
append
(
"
newsletters
"
content
.
message_id_email
)
;
formData
.
append
(
"
source_url
"
encodeURIComponent
(
https
:
/
/
snippets
.
mozilla
.
com
/
show
/
{
message
.
id
}
)
)
;
}
formData
.
append
(
"
lang
"
content
.
locale
)
;
return
{
formData
url
}
;
}
function
addDefaultValues
(
props
)
{
return
{
.
.
.
props
content
:
{
scene1_button_label
:
"
Learn
more
"
retry_button_label
:
"
Try
again
"
scene2_dismiss_button_text
:
"
Dismiss
"
scene2_button_label
:
"
Send
"
scene2_input_placeholder
:
"
Your
email
here
"
locale
:
"
en
-
US
"
country
:
"
us
"
message_id_email
:
"
"
include_sms
:
false
.
.
.
props
.
content
}
}
;
}
const
SendToDeviceSnippet
=
props
=
>
{
const
propsWithDefaults
=
addDefaultValues
(
props
)
;
return
external_React_default
(
)
.
createElement
(
SubmitFormSnippet
SendToDeviceSnippet_extends
(
{
}
propsWithDefaults
{
form_method
:
"
POST
"
className
:
"
send_to_device_snippet
"
inputType
:
propsWithDefaults
.
content
.
include_sms
?
"
text
"
:
"
email
"
validateInput
:
propsWithDefaults
.
content
.
include_sms
?
validateInput
:
null
processFormData
:
processFormData
}
)
)
;
}
;
const
SendToDeviceScene2Snippet
=
props
=
>
{
return
external_React_default
(
)
.
createElement
(
SendToDeviceSnippet
SendToDeviceSnippet_extends
(
{
expandedAlt
:
true
}
props
)
)
;
}
;
;
function
SimpleBelowSearchSnippet_extends
(
)
{
SimpleBelowSearchSnippet_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
SimpleBelowSearchSnippet_extends
.
apply
(
this
arguments
)
;
}
const
SimpleBelowSearchSnippet_DEFAULT_ICON_PATH
=
"
chrome
:
/
/
branding
/
content
/
icon64
.
png
"
;
const
SimpleBelowSearchSnippet_ICON_ALT_TEXT
=
"
"
;
class
SimpleBelowSearchSnippet
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onButtonClick
=
this
.
onButtonClick
.
bind
(
this
)
;
}
renderText
(
)
{
const
{
props
}
=
this
;
return
props
.
content
.
text
?
external_React_default
(
)
.
createElement
(
RichText
{
text
:
props
.
content
.
text
customElements
:
this
.
props
.
customElements
localization_id
:
"
text
"
links
:
props
.
content
.
links
sendClick
:
props
.
sendClick
}
)
:
null
;
}
renderTitle
(
)
{
const
{
title
}
=
this
.
props
.
content
;
return
title
?
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
title
title
-
inline
"
}
title
external_React_default
(
)
.
createElement
(
"
br
"
null
)
)
:
null
;
}
async
onButtonClick
(
)
{
if
(
this
.
props
.
provider
!
=
=
"
preview
"
)
{
this
.
props
.
sendUserActionTelemetry
(
{
event
:
"
CLICK_BUTTON
"
id
:
this
.
props
.
UISurface
}
)
;
}
const
{
button_url
}
=
this
.
props
.
content
;
const
type
=
this
.
props
.
content
.
button_action
|
|
button_url
&
&
"
OPEN_URL
"
;
await
this
.
props
.
onAction
(
{
type
data
:
{
args
:
this
.
props
.
content
.
button_action_args
|
|
button_url
}
}
)
;
if
(
!
this
.
props
.
content
.
do_not_autoblock
)
{
this
.
props
.
onBlock
(
)
;
}
}
_shouldRenderButton
(
)
{
return
this
.
props
.
content
.
button_action
|
|
this
.
props
.
onButtonClick
|
|
this
.
props
.
content
.
button_url
;
}
renderButton
(
)
{
const
{
props
}
=
this
;
if
(
!
this
.
_shouldRenderButton
(
)
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
Button
{
onClick
:
props
.
onButtonClick
|
|
this
.
onButtonClick
color
:
props
.
content
.
button_color
backgroundColor
:
props
.
content
.
button_background_color
}
props
.
content
.
button_label
)
;
}
render
(
)
{
const
{
props
}
=
this
;
let
className
=
"
SimpleBelowSearchSnippet
"
;
let
containerName
=
"
below
-
search
-
snippet
"
;
if
(
props
.
className
)
{
className
+
=
{
props
.
className
}
;
}
if
(
this
.
_shouldRenderButton
(
)
)
{
className
+
=
"
withButton
"
;
containerName
+
=
"
withButton
"
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
containerName
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
snippet
-
hover
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
SnippetBase
SimpleBelowSearchSnippet_extends
(
{
}
props
{
className
:
className
textStyle
:
this
.
props
.
textStyle
}
)
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
safeURI
(
props
.
content
.
icon
)
|
|
SimpleBelowSearchSnippet_DEFAULT_ICON_PATH
className
:
"
icon
icon
-
light
-
theme
"
alt
:
props
.
content
.
icon_alt_text
|
|
SimpleBelowSearchSnippet_ICON_ALT_TEXT
}
)
external_React_default
(
)
.
createElement
(
"
img
"
{
src
:
safeURI
(
props
.
content
.
icon_dark_theme
|
|
props
.
content
.
icon
)
|
|
SimpleBelowSearchSnippet_DEFAULT_ICON_PATH
className
:
"
icon
icon
-
dark
-
theme
"
alt
:
props
.
content
.
icon_alt_text
|
|
SimpleBelowSearchSnippet_ICON_ALT_TEXT
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
textContainer
"
}
this
.
renderTitle
(
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
body
"
}
this
.
renderText
(
)
)
this
.
props
.
extraContent
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
buttonContainer
"
}
this
.
renderButton
(
)
)
)
)
)
;
}
}
;
const
SnippetsTemplates
=
{
simple_snippet
:
SimpleSnippet
newsletter_snippet
:
NewsletterSnippet
fxa_signup_snippet
:
FXASignupSnippet
send_to_device_snippet
:
SendToDeviceSnippet
send_to_device_scene2_snippet
:
SendToDeviceScene2Snippet
eoy_snippet
:
EOYSnippet
simple_below_search_snippet
:
SimpleBelowSearchSnippet
}
;
;
function
asrouter_content_extends
(
)
{
asrouter_content_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
asrouter_content_extends
.
apply
(
this
arguments
)
;
}
const
TEMPLATES_BELOW_SEARCH
=
[
"
simple_below_search_snippet
"
]
;
function
shouldSendImpressionOnUpdate
(
nextProps
prevProps
)
{
return
nextProps
.
message
.
id
&
&
(
!
prevProps
.
message
|
|
prevProps
.
message
.
id
!
=
=
nextProps
.
message
.
id
)
;
}
class
ASRouterUISurface
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
sendClick
=
this
.
sendClick
.
bind
(
this
)
;
this
.
sendImpression
=
this
.
sendImpression
.
bind
(
this
)
;
this
.
sendUserActionTelemetry
=
this
.
sendUserActionTelemetry
.
bind
(
this
)
;
this
.
onUserAction
=
this
.
onUserAction
.
bind
(
this
)
;
this
.
fetchFlowParams
=
this
.
fetchFlowParams
.
bind
(
this
)
;
this
.
onBlockSelected
=
this
.
onBlockSelected
.
bind
(
this
)
;
this
.
onBlockById
=
this
.
onBlockById
.
bind
(
this
)
;
this
.
onDismiss
=
this
.
onDismiss
.
bind
(
this
)
;
this
.
onMessageFromParent
=
this
.
onMessageFromParent
.
bind
(
this
)
;
this
.
state
=
{
message
:
{
}
}
;
if
(
props
.
document
)
{
this
.
footerPortal
=
props
.
document
.
getElementById
(
"
footer
-
asrouter
-
container
"
)
;
}
}
async
fetchFlowParams
(
params
=
{
}
)
{
let
result
=
{
}
;
const
{
fxaEndpoint
}
=
this
.
props
;
if
(
!
fxaEndpoint
)
{
const
err
=
"
Tried
to
fetch
flow
params
before
fxaEndpoint
pref
was
ready
"
;
console
.
error
(
err
)
;
}
try
{
const
urlObj
=
new
URL
(
fxaEndpoint
)
;
urlObj
.
pathname
=
"
metrics
-
flow
"
;
Object
.
keys
(
params
)
.
forEach
(
key
=
>
{
urlObj
.
searchParams
.
append
(
key
params
[
key
]
)
;
}
)
;
const
response
=
await
fetch
(
urlObj
.
toString
(
)
{
credentials
:
"
omit
"
}
)
;
if
(
response
.
status
=
=
=
200
)
{
const
{
deviceId
flowId
flowBeginTime
}
=
await
response
.
json
(
)
;
result
=
{
deviceId
flowId
flowBeginTime
}
;
}
else
{
console
.
error
(
"
Non
-
200
response
"
response
)
;
}
}
catch
(
error
)
{
console
.
error
(
error
)
;
}
return
result
;
}
sendUserActionTelemetry
(
extraProps
=
{
}
)
{
const
{
message
}
=
this
.
state
;
const
eventType
=
{
message
.
provider
}
_user_event
;
const
source
=
extraProps
.
id
;
delete
extraProps
.
id
;
ASRouterUtils
.
sendTelemetry
(
{
source
message_id
:
message
.
id
action
:
eventType
.
.
.
extraProps
}
)
;
}
sendImpression
(
extraProps
)
{
if
(
this
.
state
.
message
.
provider
=
=
=
"
preview
"
)
{
return
Promise
.
resolve
(
)
;
}
this
.
sendUserActionTelemetry
(
{
event
:
"
IMPRESSION
"
.
.
.
extraProps
}
)
;
return
ASRouterUtils
.
sendMessage
(
{
type
:
MESSAGE_TYPE_HASH
.
IMPRESSION
data
:
this
.
state
.
message
}
)
;
}
sendClick
(
event
)
{
const
{
dataset
}
=
event
.
target
;
const
metric
=
{
event_context
:
dataset
.
metric
id
:
"
NEWTAB_FOOTER_BAR_CONTENT
"
}
;
const
{
entrypoint_name
entrypoint_value
}
=
dataset
;
const
entrypoint
=
entrypoint_name
?
new
URLSearchParams
(
[
[
entrypoint_name
entrypoint_value
]
]
)
.
toString
(
)
:
entrypoint_value
;
const
action
=
{
type
:
dataset
.
action
data
:
{
args
:
dataset
.
args
.
.
.
(
entrypoint
&
&
{
entrypoint
}
)
}
}
;
if
(
action
.
type
)
{
ASRouterUtils
.
executeAction
(
action
)
;
}
if
(
!
this
.
state
.
message
.
content
.
do_not_autoblock
&
&
!
dataset
.
do_not_autoblock
)
{
this
.
onBlockById
(
this
.
state
.
message
.
id
)
;
}
if
(
this
.
state
.
message
.
provider
!
=
=
"
preview
"
)
{
this
.
sendUserActionTelemetry
(
{
event
:
"
CLICK_BUTTON
"
.
.
.
metric
}
)
;
}
}
onBlockSelected
(
options
)
{
return
this
.
onBlockById
(
this
.
state
.
message
.
id
{
.
.
.
options
campaign
:
this
.
state
.
message
.
campaign
}
)
;
}
onBlockById
(
id
options
)
{
return
ASRouterUtils
.
blockById
(
id
options
)
.
then
(
clearAll
=
>
{
if
(
clearAll
)
{
this
.
setState
(
{
message
:
{
}
}
)
;
}
}
)
;
}
onDismiss
(
)
{
this
.
clearMessage
(
this
.
state
.
message
.
id
)
;
}
clearMessage
(
idOrCampaign
)
{
if
(
idOrCampaign
=
=
=
this
.
state
.
message
.
id
|
|
idOrCampaign
=
=
=
this
.
state
.
message
.
campaign
)
{
this
.
setState
(
{
message
:
{
}
}
)
;
}
}
clearProvider
(
id
)
{
if
(
this
.
state
.
message
.
provider
=
=
=
id
)
{
this
.
setState
(
{
message
:
{
}
}
)
;
}
}
onMessageFromParent
(
{
type
data
}
)
{
switch
(
type
)
{
case
"
ClearMessages
"
:
{
data
.
forEach
(
id
=
>
this
.
clearMessage
(
id
)
)
;
break
;
}
case
"
ClearProviders
"
:
{
data
.
forEach
(
id
=
>
this
.
clearProvider
(
id
)
)
;
break
;
}
case
"
EnterSnippetsPreviewMode
"
:
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
SNIPPETS_PREVIEW_MODE
}
)
;
break
;
}
}
}
requestMessage
(
endpoint
)
{
ASRouterUtils
.
sendMessage
(
{
type
:
"
NEWTAB_MESSAGE_REQUEST
"
data
:
{
endpoint
}
}
)
.
then
(
state
=
>
this
.
setState
(
state
)
)
;
}
componentWillMount
(
)
{
const
endpoint
=
ASRouterUtils
.
getPreviewEndpoint
(
)
;
if
(
endpoint
&
&
endpoint
.
theme
=
=
=
"
dark
"
)
{
__webpack_require__
.
g
.
window
.
dispatchEvent
(
new
CustomEvent
(
"
LightweightTheme
:
Set
"
{
detail
:
{
data
:
NEWTAB_DARK_THEME
}
}
)
)
;
}
if
(
endpoint
&
&
endpoint
.
dir
=
=
=
"
rtl
"
)
{
this
.
props
.
document
.
dir
=
"
rtl
"
;
}
ASRouterUtils
.
addListener
(
this
.
onMessageFromParent
)
;
this
.
requestMessage
(
endpoint
)
;
}
componentWillUnmount
(
)
{
ASRouterUtils
.
removeListener
(
this
.
onMessageFromParent
)
;
}
componentDidUpdate
(
prevProps
prevState
)
{
if
(
prevProps
.
adminContent
&
&
JSON
.
stringify
(
prevProps
.
adminContent
)
!
=
=
JSON
.
stringify
(
this
.
props
.
adminContent
)
)
{
this
.
updateContent
(
)
;
}
if
(
prevState
.
message
.
id
!
=
=
this
.
state
.
message
.
id
)
{
const
main
=
__webpack_require__
.
g
.
window
.
document
.
querySelector
(
"
main
"
)
;
if
(
main
)
{
if
(
this
.
state
.
message
.
id
)
{
main
.
classList
.
add
(
"
has
-
snippet
"
)
;
}
else
{
main
.
classList
.
remove
(
"
has
-
snippet
"
)
;
}
}
}
}
updateContent
(
)
{
this
.
setState
(
{
.
.
.
this
.
props
.
adminContent
}
)
;
}
async
getMonitorUrl
(
{
url
flowRequestParams
=
{
}
}
)
{
const
flowValues
=
await
this
.
fetchFlowParams
(
flowRequestParams
)
;
const
urlObj
=
new
URL
(
url
)
;
[
"
deviceId
"
"
flowId
"
"
flowBeginTime
"
]
.
forEach
(
key
=
>
{
if
(
key
in
flowValues
)
{
urlObj
.
searchParams
.
append
(
key
flowValues
[
key
]
)
;
}
}
)
;
return
urlObj
.
toString
(
)
;
}
async
onUserAction
(
action
)
{
switch
(
action
.
type
)
{
case
"
ENABLE_FIREFOX_MONITOR
"
:
const
url
=
await
this
.
getMonitorUrl
(
action
.
data
.
args
)
;
ASRouterUtils
.
executeAction
(
{
type
:
"
OPEN_URL
"
data
:
{
args
:
url
}
}
)
;
break
;
default
:
ASRouterUtils
.
executeAction
(
action
)
;
}
}
renderSnippets
(
)
{
const
{
message
}
=
this
.
state
;
if
(
!
SnippetsTemplates
[
message
.
template
]
)
{
return
null
;
}
const
SnippetComponent
=
SnippetsTemplates
[
message
.
template
]
;
const
{
content
}
=
message
;
return
external_React_default
(
)
.
createElement
(
ImpressionsWrapper
{
id
:
"
NEWTAB_FOOTER_BAR
"
message
:
this
.
state
.
message
sendImpression
:
this
.
sendImpression
shouldSendImpressionOnUpdate
:
shouldSendImpressionOnUpdate
document
:
this
.
props
.
document
}
external_React_default
(
)
.
createElement
(
LocalizationProvider
{
bundles
:
generateBundles
(
content
)
}
external_React_default
(
)
.
createElement
(
SnippetComponent
asrouter_content_extends
(
{
}
this
.
state
.
message
{
UISurface
:
"
NEWTAB_FOOTER_BAR
"
onBlock
:
this
.
onBlockSelected
onDismiss
:
this
.
onDismiss
onAction
:
this
.
onUserAction
sendClick
:
this
.
sendClick
sendUserActionTelemetry
:
this
.
sendUserActionTelemetry
}
)
)
)
)
;
}
renderPreviewBanner
(
)
{
if
(
this
.
state
.
message
.
provider
!
=
=
"
preview
"
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
snippets
-
preview
-
banner
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
info
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
null
"
Preview
Purposes
Only
"
)
)
;
}
render
(
)
{
const
{
message
}
=
this
.
state
;
if
(
!
message
.
id
)
{
return
null
;
}
const
shouldRenderBelowSearch
=
TEMPLATES_BELOW_SEARCH
.
includes
(
message
.
template
)
;
return
shouldRenderBelowSearch
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
below
-
search
-
snippet
-
wrapper
"
}
this
.
renderSnippets
(
)
)
:
external_ReactDOM_default
(
)
.
createPortal
(
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
this
.
renderPreviewBanner
(
)
this
.
renderSnippets
(
)
)
this
.
footerPortal
)
;
}
}
ASRouterUISurface
.
defaultProps
=
{
document
:
__webpack_require__
.
g
.
document
}
;
;
class
_ConfirmDialog
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
_handleCancelBtn
=
this
.
_handleCancelBtn
.
bind
(
this
)
;
this
.
_handleConfirmBtn
=
this
.
_handleConfirmBtn
.
bind
(
this
)
;
}
_handleCancelBtn
(
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
DIALOG_CANCEL
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
actionTypes
.
DIALOG_CANCEL
source
:
this
.
props
.
data
.
eventSource
}
)
)
;
}
_handleConfirmBtn
(
)
{
this
.
props
.
data
.
onConfirm
.
forEach
(
this
.
props
.
dispatch
)
;
}
_renderModalMessage
(
)
{
const
message_body
=
this
.
props
.
data
.
body_string_id
;
if
(
!
message_body
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
span
"
null
message_body
.
map
(
msg
=
>
external_React_default
(
)
.
createElement
(
"
p
"
{
key
:
msg
"
data
-
l10n
-
id
"
:
msg
}
)
)
)
;
}
render
(
)
{
if
(
!
this
.
props
.
visible
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
confirmation
-
dialog
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
modal
-
overlay
"
onClick
:
this
.
_handleCancelBtn
role
:
"
presentation
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
modal
"
}
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
modal
-
message
"
}
this
.
props
.
data
.
icon
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
icon
icon
-
spacer
icon
-
{
this
.
props
.
data
.
icon
}
}
)
this
.
_renderModalMessage
(
)
)
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
onClick
:
this
.
_handleCancelBtn
"
data
-
l10n
-
id
"
:
this
.
props
.
data
.
cancel_button_string_id
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
"
onClick
:
this
.
_handleConfirmBtn
"
data
-
l10n
-
id
"
:
this
.
props
.
data
.
confirm_button_string_id
}
)
)
)
)
;
}
}
const
ConfirmDialog
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
state
.
Dialog
)
(
_ConfirmDialog
)
;
;
const
PLACEHOLDER_IMAGE_DATA_ARRAY
=
[
{
rotation
:
"
0deg
"
offsetx
:
"
20px
"
offsety
:
"
8px
"
scale
:
"
45
%
"
}
{
rotation
:
"
54deg
"
offsetx
:
"
-
26px
"
offsety
:
"
62px
"
scale
:
"
55
%
"
}
{
rotation
:
"
-
30deg
"
offsetx
:
"
78px
"
offsety
:
"
30px
"
scale
:
"
68
%
"
}
{
rotation
:
"
-
22deg
"
offsetx
:
"
0
"
offsety
:
"
92px
"
scale
:
"
60
%
"
}
{
rotation
:
"
-
65deg
"
offsetx
:
"
66px
"
offsety
:
"
28px
"
scale
:
"
60
%
"
}
{
rotation
:
"
22deg
"
offsetx
:
"
-
35px
"
offsety
:
"
62px
"
scale
:
"
52
%
"
}
{
rotation
:
"
-
25deg
"
offsetx
:
"
86px
"
offsety
:
"
-
15px
"
scale
:
"
68
%
"
}
]
;
const
PLACEHOLDER_IMAGE_COLORS_ARRAY
=
"
#
0090ED
#
FF4F5F
#
2AC3A2
#
FF7139
#
A172FF
#
FFA437
#
FF2A8A
"
.
split
(
"
"
)
;
function
generateIndex
(
{
keyCode
max
}
)
{
if
(
!
keyCode
)
{
return
Math
.
floor
(
Math
.
random
(
)
*
max
)
;
}
const
hashStr
=
str
=
>
{
let
hash
=
0
;
for
(
let
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
let
charCode
=
str
.
charCodeAt
(
i
)
;
hash
+
=
charCode
;
}
return
hash
;
}
;
const
hash
=
hashStr
(
keyCode
)
;
return
hash
%
max
;
}
function
PlaceholderImage
(
{
urlKey
titleKey
}
)
{
const
dataIndex
=
generateIndex
(
{
keyCode
:
urlKey
max
:
PLACEHOLDER_IMAGE_DATA_ARRAY
.
length
}
)
;
const
colorIndex
=
generateIndex
(
{
keyCode
:
titleKey
max
:
PLACEHOLDER_IMAGE_COLORS_ARRAY
.
length
}
)
;
const
{
rotation
offsetx
offsety
scale
}
=
PLACEHOLDER_IMAGE_DATA_ARRAY
[
dataIndex
]
;
const
color
=
PLACEHOLDER_IMAGE_COLORS_ARRAY
[
colorIndex
]
;
const
style
=
{
"
-
-
placeholderBackgroundColor
"
:
color
"
-
-
placeholderBackgroundRotation
"
:
rotation
"
-
-
placeholderBackgroundOffsetx
"
:
offsetx
"
-
-
placeholderBackgroundOffsety
"
:
offsety
"
-
-
placeholderBackgroundScale
"
:
scale
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
style
:
style
className
:
"
placeholder
-
image
"
}
)
;
}
class
DSImage
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onOptimizedImageError
=
this
.
onOptimizedImageError
.
bind
(
this
)
;
this
.
onNonOptimizedImageError
=
this
.
onNonOptimizedImageError
.
bind
(
this
)
;
this
.
onLoad
=
this
.
onLoad
.
bind
(
this
)
;
this
.
state
=
{
isLoaded
:
false
optimizedImageFailed
:
false
useTransition
:
false
}
;
}
onIdleCallback
(
)
{
if
(
!
this
.
state
.
isLoaded
)
{
this
.
setState
(
{
useTransition
:
true
}
)
;
}
}
reformatImageURL
(
url
width
height
)
{
return
https
:
/
/
img
-
getpocket
.
cdn
.
mozilla
.
net
/
{
width
}
x
{
height
}
/
filters
:
format
(
jpeg
)
:
quality
(
60
)
:
no_upscale
(
)
:
strip_exif
(
)
/
{
encodeURIComponent
(
url
)
}
;
}
componentDidMount
(
)
{
this
.
idleCallbackId
=
this
.
props
.
windowObj
.
requestIdleCallback
(
this
.
onIdleCallback
.
bind
(
this
)
)
;
}
componentWillUnmount
(
)
{
if
(
this
.
idleCallbackId
)
{
this
.
props
.
windowObj
.
cancelIdleCallback
(
this
.
idleCallbackId
)
;
}
}
render
(
)
{
let
classNames
=
ds
-
image
{
this
.
props
.
extraClassNames
?
{
this
.
props
.
extraClassNames
}
:
}
{
this
.
state
&
&
this
.
state
.
useTransition
?
use
-
transition
:
}
{
this
.
state
&
&
this
.
state
.
isLoaded
?
loaded
:
}
;
let
img
;
if
(
this
.
state
)
{
if
(
this
.
props
.
optimize
&
&
this
.
props
.
rawSource
&
&
!
this
.
state
.
optimizedImageFailed
)
{
let
baseSource
=
this
.
props
.
rawSource
;
let
sizeRules
=
[
]
;
let
srcSetRules
=
[
]
;
for
(
let
rule
of
this
.
props
.
sizes
)
{
let
{
mediaMatcher
width
height
}
=
rule
;
let
sizeRule
=
{
mediaMatcher
}
{
width
}
px
;
sizeRules
.
push
(
sizeRule
)
;
let
srcSetRule
=
{
this
.
reformatImageURL
(
baseSource
width
height
)
}
{
width
}
w
;
let
srcSetRule2x
=
{
this
.
reformatImageURL
(
baseSource
width
*
2
height
*
2
)
}
{
width
*
2
}
w
;
srcSetRules
.
push
(
srcSetRule
)
;
srcSetRules
.
push
(
srcSetRule2x
)
;
}
if
(
this
.
props
.
sizes
.
length
)
{
sizeRules
.
push
(
{
this
.
props
.
sizes
[
this
.
props
.
sizes
.
length
-
1
]
.
width
}
px
)
;
}
img
=
external_React_default
(
)
.
createElement
(
"
img
"
{
loading
:
"
lazy
"
alt
:
this
.
props
.
alt_text
crossOrigin
:
"
anonymous
"
onLoad
:
this
.
onLoad
onError
:
this
.
onOptimizedImageError
sizes
:
sizeRules
.
join
(
"
"
)
src
:
baseSource
srcSet
:
srcSetRules
.
join
(
"
"
)
}
)
;
}
else
if
(
this
.
props
.
source
&
&
!
this
.
state
.
nonOptimizedImageFailed
)
{
img
=
external_React_default
(
)
.
createElement
(
"
img
"
{
loading
:
"
lazy
"
alt
:
this
.
props
.
alt_text
crossOrigin
:
"
anonymous
"
onLoad
:
this
.
onLoad
onError
:
this
.
onNonOptimizedImageError
src
:
this
.
props
.
source
}
)
;
}
else
{
classNames
=
{
classNames
}
loaded
;
img
=
external_React_default
(
)
.
createElement
(
PlaceholderImage
{
urlKey
:
this
.
props
.
url
titleKey
:
this
.
props
.
title
}
)
;
}
}
return
external_React_default
(
)
.
createElement
(
"
picture
"
{
className
:
classNames
}
img
)
;
}
onOptimizedImageError
(
)
{
this
.
setState
(
{
optimizedImageFailed
:
true
}
)
;
}
onNonOptimizedImageError
(
)
{
this
.
setState
(
{
nonOptimizedImageFailed
:
true
}
)
;
}
onLoad
(
)
{
this
.
setState
(
{
isLoaded
:
true
}
)
;
}
}
DSImage
.
defaultProps
=
{
source
:
null
rawSource
:
null
extraClassNames
:
null
optimize
:
true
alt_text
:
null
windowObj
:
window
sizes
:
[
]
}
;
;
class
ContextMenu
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
hideContext
=
this
.
hideContext
.
bind
(
this
)
;
this
.
onShow
=
this
.
onShow
.
bind
(
this
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
hideContext
(
)
{
this
.
props
.
onUpdate
(
false
)
;
}
onShow
(
)
{
if
(
this
.
props
.
onShow
)
{
this
.
props
.
onShow
(
)
;
}
}
componentDidMount
(
)
{
this
.
onShow
(
)
;
setTimeout
(
(
)
=
>
{
__webpack_require__
.
g
.
addEventListener
(
"
click
"
this
.
hideContext
)
;
}
0
)
;
}
componentWillUnmount
(
)
{
__webpack_require__
.
g
.
removeEventListener
(
"
click
"
this
.
hideContext
)
;
}
onClick
(
event
)
{
event
.
stopPropagation
(
)
;
}
render
(
)
{
return
(
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
context
-
menu
"
}
external_React_default
(
)
.
createElement
(
"
ul
"
{
role
:
"
menu
"
onClick
:
this
.
onClick
onKeyDown
:
this
.
onClick
className
:
"
context
-
menu
-
list
"
}
this
.
props
.
options
.
map
(
(
option
i
)
=
>
option
.
type
=
=
=
"
separator
"
?
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
i
className
:
"
separator
"
role
:
"
separator
"
}
)
:
option
.
type
!
=
=
"
empty
"
&
&
external_React_default
(
)
.
createElement
(
ContextMenuItem
{
key
:
i
option
:
option
hideContext
:
this
.
hideContext
keyboardAccess
:
this
.
props
.
keyboardAccess
}
)
)
)
)
)
;
}
}
class
_ContextMenuItem
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onKeyUp
=
this
.
onKeyUp
.
bind
(
this
)
;
this
.
focusFirst
=
this
.
focusFirst
.
bind
(
this
)
;
}
onClick
(
event
)
{
this
.
props
.
hideContext
(
)
;
this
.
props
.
option
.
onClick
(
event
)
;
}
focusFirst
(
button
)
{
if
(
this
.
props
.
keyboardAccess
&
&
button
)
{
button
.
focus
(
)
;
}
}
focusSibling
(
target
key
)
{
const
parent
=
target
.
parentNode
;
const
closestSiblingSelector
=
key
=
=
=
"
ArrowUp
"
?
"
previousSibling
"
:
"
nextSibling
"
;
if
(
!
parent
[
closestSiblingSelector
]
)
{
return
;
}
if
(
parent
[
closestSiblingSelector
]
.
firstElementChild
)
{
parent
[
closestSiblingSelector
]
.
firstElementChild
.
focus
(
)
;
}
else
{
parent
[
closestSiblingSelector
]
[
closestSiblingSelector
]
.
firstElementChild
.
focus
(
)
;
}
}
onKeyDown
(
event
)
{
const
{
option
}
=
this
.
props
;
switch
(
event
.
key
)
{
case
"
Tab
"
:
if
(
event
.
shiftKey
&
&
option
.
first
|
|
!
event
.
shiftKey
&
&
option
.
last
)
{
this
.
props
.
hideContext
(
)
;
}
break
;
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
event
.
preventDefault
(
)
;
this
.
focusSibling
(
event
.
target
event
.
key
)
;
break
;
case
"
Enter
"
:
case
"
"
:
event
.
preventDefault
(
)
;
this
.
props
.
hideContext
(
)
;
option
.
onClick
(
)
;
break
;
case
"
Escape
"
:
this
.
props
.
hideContext
(
)
;
break
;
}
}
onKeyUp
(
event
)
{
if
(
event
.
key
=
=
=
"
"
)
{
event
.
preventDefault
(
)
;
}
}
render
(
)
{
const
{
option
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
"
li
"
{
role
:
"
presentation
"
className
:
"
context
-
menu
-
item
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
option
.
disabled
?
"
disabled
"
:
"
"
role
:
"
menuitem
"
onClick
:
this
.
onClick
onKeyDown
:
this
.
onKeyDown
onKeyUp
:
this
.
onKeyUp
ref
:
option
.
first
?
this
.
focusFirst
:
null
}
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
option
.
string_id
|
|
option
.
id
}
)
)
)
;
}
}
const
ContextMenuItem
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
_ContextMenuItem
)
;
;
const
_OpenInPrivateWindow
=
site
=
>
(
{
id
:
"
newtab
-
menu
-
open
-
new
-
private
-
window
"
icon
:
"
new
-
window
-
private
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_PRIVATE_WINDOW
data
:
{
url
:
site
.
url
referrer
:
site
.
referrer
}
}
)
userEvent
:
"
OPEN_PRIVATE_WINDOW
"
}
)
;
const
LinkMenuOptions
=
{
Separator
:
(
)
=
>
(
{
type
:
"
separator
"
}
)
EmptyItem
:
(
)
=
>
(
{
type
:
"
empty
"
}
)
ShowPrivacyInfo
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
show
-
privacy
-
info
"
icon
:
"
info
"
action
:
{
type
:
actionTypes
.
SHOW_PRIVACY_INFO
}
userEvent
:
"
SHOW_PRIVACY_INFO
"
}
)
AboutSponsored
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
show
-
privacy
-
info
"
icon
:
"
info
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
ABOUT_SPONSORED_TOP_SITES
}
)
userEvent
:
"
TOPSITE_SPONSOR_INFO
"
}
)
RemoveBookmark
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
remove
-
bookmark
"
icon
:
"
bookmark
-
added
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DELETE_BOOKMARK_BY_ID
data
:
site
.
bookmarkGuid
}
)
userEvent
:
"
BOOKMARK_DELETE
"
}
)
AddBookmark
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
bookmark
"
icon
:
"
bookmark
-
hollow
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
BOOKMARK_URL
data
:
{
url
:
site
.
url
title
:
site
.
title
type
:
site
.
type
}
}
)
userEvent
:
"
BOOKMARK_ADD
"
}
)
OpenInNewWindow
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
open
-
new
-
window
"
icon
:
"
new
-
window
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
OPEN_NEW_WINDOW
data
:
{
referrer
:
site
.
referrer
typedBonus
:
site
.
typedBonus
url
:
site
.
url
sponsored_tile_id
:
site
.
sponsored_tile_id
}
}
)
userEvent
:
"
OPEN_NEW_WINDOW
"
}
)
BlockUrl
:
(
site
index
eventSource
)
=
>
{
return
LinkMenuOptions
.
BlockUrls
(
[
site
]
index
eventSource
)
;
}
BlockUrls
:
(
tiles
pos
eventSource
)
=
>
(
{
id
:
"
newtab
-
menu
-
dismiss
"
icon
:
"
dismiss
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
BLOCK_URL
data
:
tiles
.
map
(
site
=
>
(
{
url
:
site
.
original_url
|
|
site
.
open_url
|
|
site
.
url
pocket_id
:
site
.
pocket_id
isSponsoredTopSite
:
site
.
sponsored_position
.
.
.
(
site
.
flight_id
?
{
flight_id
:
site
.
flight_id
}
:
{
}
)
}
)
)
}
)
impression
:
actionCreators
.
ImpressionStats
(
{
source
:
eventSource
block
:
0
tiles
:
tiles
.
map
(
(
site
index
)
=
>
(
{
id
:
site
.
guid
pos
:
pos
+
index
.
.
.
(
site
.
shim
&
&
site
.
shim
.
delete
?
{
shim
:
site
.
shim
.
delete
}
:
{
}
)
}
)
)
}
)
userEvent
:
"
BLOCK
"
}
)
WebExtDismiss
:
(
site
index
eventSource
)
=
>
(
{
id
:
"
menu_action_webext_dismiss
"
string_id
:
"
newtab
-
menu
-
dismiss
"
icon
:
"
dismiss
"
action
:
actionCreators
.
WebExtEvent
(
actionTypes
.
WEBEXT_DISMISS
{
source
:
eventSource
url
:
site
.
url
action_position
:
index
}
)
}
)
DeleteUrl
:
(
site
index
eventSource
isEnabled
siteInfo
)
=
>
(
{
id
:
"
newtab
-
menu
-
delete
-
history
"
icon
:
"
delete
"
action
:
{
type
:
actionTypes
.
DIALOG_OPEN
data
:
{
onConfirm
:
[
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DELETE_HISTORY_URL
data
:
{
url
:
site
.
url
pocket_id
:
site
.
pocket_id
forceBlock
:
site
.
bookmarkGuid
}
}
)
actionCreators
.
UserEvent
(
Object
.
assign
(
{
event
:
"
DELETE
"
source
:
eventSource
action_position
:
index
}
siteInfo
)
)
]
eventSource
body_string_id
:
[
"
newtab
-
confirm
-
delete
-
history
-
p1
"
"
newtab
-
confirm
-
delete
-
history
-
p2
"
]
confirm_button_string_id
:
"
newtab
-
topsites
-
delete
-
history
-
button
"
cancel_button_string_id
:
"
newtab
-
topsites
-
cancel
-
button
"
icon
:
"
modal
-
delete
"
}
}
userEvent
:
"
DIALOG_OPEN
"
}
)
ShowFile
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
show
-
file
"
icon
:
"
search
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SHOW_DOWNLOAD_FILE
data
:
{
url
:
site
.
url
}
}
)
}
)
OpenFile
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
open
-
file
"
icon
:
"
open
-
file
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_DOWNLOAD_FILE
data
:
{
url
:
site
.
url
}
}
)
}
)
CopyDownloadLink
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
copy
-
download
-
link
"
icon
:
"
copy
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
COPY_DOWNLOAD_LINK
data
:
{
url
:
site
.
url
}
}
)
}
)
GoToDownloadPage
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
go
-
to
-
download
-
page
"
icon
:
"
download
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
url
:
site
.
referrer
}
}
)
disabled
:
!
site
.
referrer
}
)
RemoveDownload
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
remove
-
download
"
icon
:
"
delete
"
action
:
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
REMOVE_DOWNLOAD_FILE
data
:
{
url
:
site
.
url
}
}
)
}
)
PinTopSite
:
(
site
index
)
=
>
(
{
id
:
"
newtab
-
menu
-
pin
"
icon
:
"
pin
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOP_SITES_PIN
data
:
{
site
index
}
}
)
userEvent
:
"
PIN
"
}
)
UnpinTopSite
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
unpin
"
icon
:
"
unpin
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOP_SITES_UNPIN
data
:
{
site
:
{
url
:
site
.
url
}
}
}
)
userEvent
:
"
UNPIN
"
}
)
SaveToPocket
:
(
site
index
eventSource
=
"
CARDGRID
"
)
=
>
(
{
id
:
"
newtab
-
menu
-
save
-
to
-
pocket
"
icon
:
"
pocket
-
save
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SAVE_TO_POCKET
data
:
{
site
:
{
url
:
site
.
url
title
:
site
.
title
}
}
}
)
impression
:
actionCreators
.
ImpressionStats
(
{
source
:
eventSource
pocket
:
0
tiles
:
[
{
id
:
site
.
guid
pos
:
index
.
.
.
(
site
.
shim
&
&
site
.
shim
.
save
?
{
shim
:
site
.
shim
.
save
}
:
{
}
)
}
]
}
)
userEvent
:
"
SAVE_TO_POCKET
"
}
)
DeleteFromPocket
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
delete
-
pocket
"
icon
:
"
pocket
-
delete
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DELETE_FROM_POCKET
data
:
{
pocket_id
:
site
.
pocket_id
}
}
)
userEvent
:
"
DELETE_FROM_POCKET
"
}
)
ArchiveFromPocket
:
site
=
>
(
{
id
:
"
newtab
-
menu
-
archive
-
pocket
"
icon
:
"
pocket
-
archive
"
action
:
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
ARCHIVE_FROM_POCKET
data
:
{
pocket_id
:
site
.
pocket_id
}
}
)
userEvent
:
"
ARCHIVE_FROM_POCKET
"
}
)
EditTopSite
:
(
site
index
)
=
>
(
{
id
:
"
newtab
-
menu
-
edit
-
topsites
"
icon
:
"
edit
"
action
:
{
type
:
actionTypes
.
TOP_SITES_EDIT
data
:
{
index
}
}
}
)
CheckBookmark
:
site
=
>
site
.
bookmarkGuid
?
LinkMenuOptions
.
RemoveBookmark
(
site
)
:
LinkMenuOptions
.
AddBookmark
(
site
)
CheckPinTopSite
:
(
site
index
)
=
>
site
.
isPinned
?
LinkMenuOptions
.
UnpinTopSite
(
site
)
:
LinkMenuOptions
.
PinTopSite
(
site
index
)
CheckSavedToPocket
:
(
site
index
source
)
=
>
site
.
pocket_id
?
LinkMenuOptions
.
DeleteFromPocket
(
site
)
:
LinkMenuOptions
.
SaveToPocket
(
site
index
source
)
CheckBookmarkOrArchive
:
site
=
>
site
.
pocket_id
?
LinkMenuOptions
.
ArchiveFromPocket
(
site
)
:
LinkMenuOptions
.
CheckBookmark
(
site
)
CheckArchiveFromPocket
:
site
=
>
site
.
pocket_id
?
LinkMenuOptions
.
ArchiveFromPocket
(
site
)
:
LinkMenuOptions
.
EmptyItem
(
)
CheckDeleteFromPocket
:
site
=
>
site
.
pocket_id
?
LinkMenuOptions
.
DeleteFromPocket
(
site
)
:
LinkMenuOptions
.
EmptyItem
(
)
OpenInPrivateWindow
:
(
site
index
eventSource
isEnabled
)
=
>
isEnabled
?
_OpenInPrivateWindow
(
site
)
:
LinkMenuOptions
.
EmptyItem
(
)
}
;
;
const
DEFAULT_SITE_MENU_OPTIONS
=
[
"
CheckPinTopSite
"
"
EditTopSite
"
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
]
;
class
_LinkMenu
extends
(
external_React_default
(
)
)
.
PureComponent
{
getOptions
(
)
{
const
{
props
}
=
this
;
const
{
site
index
source
isPrivateBrowsingEnabled
siteInfo
platform
userEvent
=
actionCreators
.
UserEvent
}
=
props
;
const
propOptions
=
site
.
isDefault
&
&
!
site
.
searchTopSite
&
&
!
site
.
sponsored_position
?
DEFAULT_SITE_MENU_OPTIONS
:
props
.
options
;
const
options
=
propOptions
.
map
(
o
=
>
LinkMenuOptions
[
o
]
(
site
index
source
isPrivateBrowsingEnabled
siteInfo
platform
)
)
.
map
(
option
=
>
{
const
{
action
impression
id
type
userEvent
:
eventName
}
=
option
;
if
(
!
type
&
&
id
)
{
option
.
onClick
=
(
event
=
{
}
)
=
>
{
const
{
ctrlKey
metaKey
shiftKey
button
}
=
event
;
if
(
ctrlKey
|
|
metaKey
|
|
shiftKey
|
|
button
=
=
=
1
)
{
action
.
data
=
Object
.
assign
(
{
event
:
{
ctrlKey
metaKey
shiftKey
button
}
}
action
.
data
)
;
}
props
.
dispatch
(
action
)
;
if
(
eventName
)
{
const
userEventData
=
Object
.
assign
(
{
event
:
eventName
source
action_position
:
index
}
siteInfo
)
;
props
.
dispatch
(
userEvent
(
userEventData
)
)
;
}
if
(
impression
&
&
props
.
shouldSendImpressionStats
)
{
props
.
dispatch
(
impression
)
;
}
}
;
}
return
option
;
}
)
;
options
[
0
]
.
first
=
true
;
options
[
options
.
length
-
1
]
.
last
=
true
;
return
options
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
ContextMenu
{
onUpdate
:
this
.
props
.
onUpdate
onShow
:
this
.
props
.
onShow
options
:
this
.
getOptions
(
)
keyboardAccess
:
this
.
props
.
keyboardAccess
}
)
;
}
}
const
getState
=
state
=
>
(
{
isPrivateBrowsingEnabled
:
state
.
Prefs
.
values
.
isPrivateBrowsingEnabled
platform
:
state
.
Prefs
.
values
.
platform
}
)
;
const
LinkMenu
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
getState
)
(
_LinkMenu
)
;
;
class
ContextMenuButton
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
showContextMenu
:
false
contextMenuKeyboard
:
false
}
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onUpdate
=
this
.
onUpdate
.
bind
(
this
)
;
}
openContextMenu
(
isKeyBoard
event
)
{
if
(
this
.
props
.
onUpdate
)
{
this
.
props
.
onUpdate
(
true
)
;
}
this
.
setState
(
{
showContextMenu
:
true
contextMenuKeyboard
:
isKeyBoard
}
)
;
}
onClick
(
event
)
{
event
.
preventDefault
(
)
;
this
.
openContextMenu
(
false
event
)
;
}
onKeyDown
(
event
)
{
if
(
event
.
key
=
=
=
"
Enter
"
|
|
event
.
key
=
=
=
"
"
)
{
event
.
preventDefault
(
)
;
this
.
openContextMenu
(
true
event
)
;
}
}
onUpdate
(
showContextMenu
)
{
if
(
this
.
props
.
onUpdate
)
{
this
.
props
.
onUpdate
(
showContextMenu
)
;
}
this
.
setState
(
{
showContextMenu
}
)
;
}
render
(
)
{
const
{
tooltipArgs
tooltip
children
refFunction
}
=
this
.
props
;
const
{
showContextMenu
contextMenuKeyboard
}
=
this
.
state
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
button
"
{
"
aria
-
haspopup
"
:
"
true
"
"
data
-
l10n
-
id
"
:
tooltip
"
data
-
l10n
-
args
"
:
tooltipArgs
?
JSON
.
stringify
(
tooltipArgs
)
:
null
className
:
"
context
-
menu
-
button
icon
"
onKeyDown
:
this
.
onKeyDown
onClick
:
this
.
onClick
ref
:
refFunction
}
)
showContextMenu
?
external_React_default
(
)
.
cloneElement
(
children
{
keyboardAccess
:
contextMenuKeyboard
onUpdate
:
this
.
onUpdate
}
)
:
null
)
;
}
}
;
class
DSLinkMenu
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
index
dispatch
}
=
this
.
props
;
let
pocketMenuOptions
=
[
]
;
let
TOP_STORIES_CONTEXT_MENU_OPTIONS
=
[
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
]
;
if
(
!
this
.
props
.
isRecentSave
)
{
if
(
this
.
props
.
pocket_button_enabled
)
{
pocketMenuOptions
=
this
.
props
.
saveToPocketCard
?
[
"
CheckDeleteFromPocket
"
]
:
[
"
CheckSavedToPocket
"
]
;
}
TOP_STORIES_CONTEXT_MENU_OPTIONS
=
[
"
CheckBookmark
"
"
CheckArchiveFromPocket
"
.
.
.
pocketMenuOptions
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
.
.
.
(
this
.
props
.
showPrivacyInfo
?
[
"
ShowPrivacyInfo
"
]
:
[
]
)
]
;
}
const
type
=
this
.
props
.
type
|
|
"
DISCOVERY_STREAM
"
;
const
title
=
this
.
props
.
title
|
|
this
.
props
.
source
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
context
-
menu
-
position
-
container
"
}
external_React_default
(
)
.
createElement
(
ContextMenuButton
{
tooltip
:
"
newtab
-
menu
-
content
-
tooltip
"
tooltipArgs
:
{
title
}
onUpdate
:
this
.
props
.
onMenuUpdate
}
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
index
source
:
type
.
toUpperCase
(
)
onShow
:
this
.
props
.
onMenuShow
options
:
TOP_STORIES_CONTEXT_MENU_OPTIONS
shouldSendImpressionStats
:
true
userEvent
:
actionCreators
.
DiscoveryStreamUserEvent
site
:
{
referrer
:
"
https
:
/
/
getpocket
.
com
/
recommendations
"
title
:
this
.
props
.
title
type
:
this
.
props
.
type
url
:
this
.
props
.
url
guid
:
this
.
props
.
id
pocket_id
:
this
.
props
.
pocket_id
shim
:
this
.
props
.
shim
bookmarkGuid
:
this
.
props
.
bookmarkGuid
flight_id
:
this
.
props
.
flightId
}
}
)
)
)
;
}
}
;
const
ImpressionStats_VISIBLE
=
"
visible
"
;
const
ImpressionStats_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
const
INTERSECTION_RATIO
=
0
.
5
;
class
ImpressionStats_ImpressionStats
extends
(
external_React_default
(
)
)
.
PureComponent
{
_needsImpressionStats
(
cards
)
{
if
(
!
this
.
impressionCardGuids
|
|
this
.
impressionCardGuids
.
length
!
=
=
cards
.
length
)
{
return
true
;
}
for
(
let
i
=
0
;
i
<
cards
.
length
;
i
+
+
)
{
if
(
cards
[
i
]
.
id
!
=
=
this
.
impressionCardGuids
[
i
]
)
{
return
true
;
}
}
return
false
;
}
_dispatchImpressionStats
(
)
{
const
{
props
}
=
this
;
const
cards
=
props
.
rows
;
if
(
this
.
props
.
flightId
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_SPOC_IMPRESSION
data
:
{
flightId
:
this
.
props
.
flightId
}
}
)
)
;
}
if
(
this
.
_needsImpressionStats
(
cards
)
)
{
props
.
dispatch
(
actionCreators
.
DiscoveryStreamImpressionStats
(
{
source
:
props
.
source
.
toUpperCase
(
)
window_inner_width
:
window
.
innerWidth
window_inner_height
:
window
.
innerHeight
tiles
:
cards
.
map
(
link
=
>
(
{
id
:
link
.
id
pos
:
link
.
pos
.
.
.
(
link
.
shim
?
{
shim
:
link
.
shim
}
:
{
}
)
}
)
)
}
)
)
;
this
.
impressionCardGuids
=
cards
.
map
(
link
=
>
link
.
id
)
;
}
}
_needsLoadedContent
(
cards
)
{
if
(
!
this
.
loadedContentGuids
|
|
this
.
loadedContentGuids
.
length
!
=
=
cards
.
length
)
{
return
true
;
}
for
(
let
i
=
0
;
i
<
cards
.
length
;
i
+
+
)
{
if
(
cards
[
i
]
.
id
!
=
=
this
.
loadedContentGuids
[
i
]
)
{
return
true
;
}
}
return
false
;
}
_dispatchLoadedContent
(
)
{
const
{
props
}
=
this
;
const
cards
=
props
.
rows
;
if
(
this
.
_needsLoadedContent
(
cards
)
)
{
props
.
dispatch
(
actionCreators
.
DiscoveryStreamLoadedContent
(
{
source
:
props
.
source
.
toUpperCase
(
)
tiles
:
cards
.
map
(
link
=
>
(
{
id
:
link
.
id
pos
:
link
.
pos
}
)
)
}
)
)
;
this
.
loadedContentGuids
=
cards
.
map
(
link
=
>
link
.
id
)
;
}
}
setImpressionObserverOrAddListener
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
dispatch
)
{
return
;
}
if
(
props
.
document
.
visibilityState
=
=
=
ImpressionStats_VISIBLE
)
{
this
.
_dispatchLoadedContent
(
)
;
this
.
setImpressionObserver
(
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
props
.
document
.
removeEventListener
(
ImpressionStats_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
props
.
document
.
visibilityState
=
=
=
ImpressionStats_VISIBLE
)
{
this
.
_dispatchLoadedContent
(
)
;
this
.
setImpressionObserver
(
)
;
props
.
document
.
removeEventListener
(
ImpressionStats_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
props
.
document
.
addEventListener
(
ImpressionStats_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
setImpressionObserver
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
rows
.
length
)
{
return
;
}
this
.
_handleIntersect
=
entries
=
>
{
if
(
entries
.
some
(
entry
=
>
entry
.
isIntersecting
&
&
entry
.
intersectionRatio
>
=
INTERSECTION_RATIO
)
)
{
this
.
_dispatchImpressionStats
(
)
;
this
.
impressionObserver
.
unobserve
(
this
.
refs
.
impression
)
;
}
}
;
const
options
=
{
threshold
:
INTERSECTION_RATIO
}
;
this
.
impressionObserver
=
new
props
.
IntersectionObserver
(
this
.
_handleIntersect
options
)
;
this
.
impressionObserver
.
observe
(
this
.
refs
.
impression
)
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
rows
.
length
)
{
this
.
setImpressionObserverOrAddListener
(
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
_handleIntersect
&
&
this
.
impressionObserver
)
{
this
.
impressionObserver
.
unobserve
(
this
.
refs
.
impression
)
;
}
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
ImpressionStats_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
"
impression
"
className
:
"
impression
-
observer
"
}
this
.
props
.
children
)
;
}
}
ImpressionStats_ImpressionStats
.
defaultProps
=
{
IntersectionObserver
:
__webpack_require__
.
g
.
IntersectionObserver
document
:
__webpack_require__
.
g
.
document
rows
:
[
]
source
:
"
"
}
;
;
class
SafeAnchor
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
onClick
(
event
)
{
if
(
this
.
props
.
dispatch
)
{
event
.
preventDefault
(
)
;
const
{
altKey
button
ctrlKey
metaKey
shiftKey
}
=
event
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
{
event
:
{
altKey
button
ctrlKey
metaKey
shiftKey
}
referrer
:
"
https
:
/
/
getpocket
.
com
/
recommendations
"
url
:
event
.
currentTarget
.
href
}
}
)
)
;
}
if
(
this
.
props
.
onLinkClick
)
{
this
.
props
.
onLinkClick
(
event
)
;
}
}
safeURI
(
url
)
{
let
protocol
=
null
;
try
{
protocol
=
new
URL
(
url
)
.
protocol
;
}
catch
(
e
)
{
return
"
"
;
}
const
isAllowed
=
[
"
http
:
"
"
https
:
"
]
.
includes
(
protocol
)
;
if
(
!
isAllowed
)
{
console
.
warn
(
{
url
}
is
not
allowed
for
anchor
targets
.
)
;
return
"
"
;
}
return
url
;
}
render
(
)
{
const
{
url
className
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
this
.
safeURI
(
url
)
className
:
className
onClick
:
this
.
onClick
}
this
.
props
.
children
)
;
}
}
;
const
cardContextTypes
=
{
history
:
{
fluentID
:
"
newtab
-
label
-
visited
"
icon
:
"
history
-
item
"
}
removedBookmark
:
{
fluentID
:
"
newtab
-
label
-
removed
-
bookmark
"
icon
:
"
bookmark
-
removed
"
}
bookmark
:
{
fluentID
:
"
newtab
-
label
-
bookmarked
"
icon
:
"
bookmark
-
added
"
}
trending
:
{
fluentID
:
"
newtab
-
label
-
recommended
"
icon
:
"
trending
"
}
pocket
:
{
fluentID
:
"
newtab
-
label
-
saved
"
icon
:
"
pocket
"
}
download
:
{
fluentID
:
"
newtab
-
label
-
download
"
icon
:
"
download
"
}
}
;
;
const
external_ReactTransitionGroup_namespaceObject
=
ReactTransitionGroup
;
;
class
FluentOrText
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
children
message
}
=
this
.
props
;
const
child
=
children
?
external_React_default
(
)
.
Children
.
only
(
children
)
:
external_React_default
(
)
.
createElement
(
"
span
"
null
)
;
let
grandChildren
=
message
;
let
extraProps
;
if
(
typeof
message
=
=
=
"
object
"
)
{
const
args
=
message
.
args
|
|
message
.
values
;
extraProps
=
{
"
data
-
l10n
-
args
"
:
args
&
&
JSON
.
stringify
(
args
)
"
data
-
l10n
-
id
"
:
message
.
id
|
|
message
.
string_id
}
;
grandChildren
=
child
.
props
.
children
;
}
return
external_React_default
(
)
.
cloneElement
(
child
extraProps
grandChildren
)
;
}
}
;
const
ANIMATION_DURATION
=
3000
;
const
DSMessageLabel
=
props
=
>
{
const
{
context
context_type
}
=
props
;
const
{
icon
fluentID
}
=
cardContextTypes
[
context_type
]
|
|
{
}
;
if
(
!
context
&
&
context_type
)
{
return
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
TransitionGroup
{
component
:
null
}
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
CSSTransition
{
key
:
fluentID
timeout
:
ANIMATION_DURATION
classNames
:
"
story
-
animate
"
}
external_React_default
(
)
.
createElement
(
StatusMessage
{
icon
:
icon
fluentID
:
fluentID
}
)
)
)
;
}
return
null
;
}
;
const
StatusMessage
=
(
{
icon
fluentID
}
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
status
-
message
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
"
aria
-
haspopup
"
:
"
true
"
className
:
story
-
badge
-
icon
icon
icon
-
{
icon
}
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
story
-
context
-
label
"
"
data
-
l10n
-
id
"
:
fluentID
}
)
)
;
const
SponsorLabel
=
(
{
sponsored_by_override
sponsor
context
newSponsoredLabel
}
)
=
>
{
const
classList
=
story
-
sponsored
-
label
{
newSponsoredLabel
|
|
"
"
}
clamp
;
if
(
sponsored_by_override
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
classList
}
sponsored_by_override
)
;
}
else
if
(
sponsored_by_override
=
=
=
"
"
)
{
return
null
;
}
else
if
(
sponsor
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
classList
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
{
id
:
newtab
-
label
-
sponsored
-
by
values
:
{
sponsor
}
}
}
)
)
;
}
else
if
(
context
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
classList
}
context
)
;
}
return
null
;
}
;
class
DSContextFooter
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
context
context_type
sponsor
sponsored_by_override
}
=
this
.
props
;
const
sponsorLabel
=
SponsorLabel
(
{
sponsored_by_override
sponsor
context
}
)
;
const
dsMessageLabel
=
DSMessageLabel
(
{
context
context_type
}
)
;
if
(
sponsorLabel
|
|
dsMessageLabel
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
story
-
footer
"
}
sponsorLabel
dsMessageLabel
)
;
}
return
null
;
}
}
const
DSMessageFooter
=
props
=
>
{
const
{
context
context_type
saveToPocketCard
}
=
props
;
const
dsMessageLabel
=
DSMessageLabel
(
{
context
context_type
}
)
;
if
(
!
dsMessageLabel
|
|
saveToPocketCard
&
&
context_type
=
=
=
"
pocket
"
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
story
-
footer
"
}
dsMessageLabel
)
;
}
;
;
const
READING_WPM
=
220
;
function
readTimeFromWordCount
(
wordCount
)
{
if
(
!
wordCount
)
return
false
;
return
Math
.
ceil
(
parseInt
(
wordCount
10
)
/
READING_WPM
)
;
}
const
DSSource
=
(
{
source
timeToRead
newSponsoredLabel
context
sponsor
sponsored_by_override
}
)
=
>
{
if
(
newSponsoredLabel
)
{
if
(
sponsored_by_override
|
|
sponsor
|
|
context
)
{
return
external_React_default
(
)
.
createElement
(
SponsorLabel
{
context
:
context
sponsor
:
sponsor
sponsored_by_override
:
sponsored_by_override
newSponsoredLabel
:
"
new
-
sponsored
-
label
"
}
)
;
}
}
if
(
timeToRead
)
{
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
source
clamp
time
-
to
-
read
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
{
id
:
newtab
-
label
-
source
-
read
-
time
values
:
{
source
timeToRead
}
}
}
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
source
clamp
"
}
source
)
;
}
;
const
DefaultMeta
=
(
{
source
title
excerpt
timeToRead
newSponsoredLabel
context
context_type
sponsor
sponsored_by_override
saveToPocketCard
isRecentSave
}
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
meta
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
info
-
wrap
"
}
external_React_default
(
)
.
createElement
(
DSSource
{
source
:
source
timeToRead
:
timeToRead
newSponsoredLabel
:
newSponsoredLabel
context
:
context
sponsor
:
sponsor
sponsored_by_override
:
sponsored_by_override
}
)
external_React_default
(
)
.
createElement
(
"
header
"
{
title
:
title
className
:
"
title
clamp
"
}
title
)
excerpt
&
&
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
excerpt
clamp
"
}
excerpt
)
)
!
newSponsoredLabel
&
&
external_React_default
(
)
.
createElement
(
DSContextFooter
{
context_type
:
context_type
context
:
context
sponsor
:
sponsor
sponsored_by_override
:
sponsored_by_override
}
)
newSponsoredLabel
&
&
external_React_default
(
)
.
createElement
(
DSMessageFooter
{
context_type
:
context_type
context
:
null
saveToPocketCard
:
saveToPocketCard
}
)
)
;
class
_DSCard
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
onSaveClick
=
this
.
onSaveClick
.
bind
(
this
)
;
this
.
onMenuUpdate
=
this
.
onMenuUpdate
.
bind
(
this
)
;
this
.
onMenuShow
=
this
.
onMenuShow
.
bind
(
this
)
;
this
.
setContextMenuButtonHostRef
=
element
=
>
{
this
.
contextMenuButtonHostElement
=
element
;
}
;
this
.
setPlaceholderRef
=
element
=
>
{
this
.
placeholderElement
=
element
;
}
;
this
.
state
=
{
isSeen
:
false
}
;
if
(
props
.
App
.
isForStartupCache
)
{
this
.
state
.
isSeen
=
true
;
}
this
.
dsImageSizes
=
[
{
mediaMatcher
:
"
(
min
-
width
:
1122px
)
"
width
:
296
height
:
148
}
{
mediaMatcher
:
"
(
min
-
width
:
866px
)
"
width
:
218
height
:
109
}
{
mediaMatcher
:
"
(
max
-
width
:
610px
)
"
width
:
202
height
:
101
}
]
;
}
onLinkClick
(
event
)
{
if
(
this
.
props
.
dispatch
)
{
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
this
.
props
.
type
.
toUpperCase
(
)
action_position
:
this
.
props
.
pos
value
:
{
card_type
:
this
.
props
.
flightId
?
"
spoc
"
:
"
organic
"
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
this
.
props
.
type
.
toUpperCase
(
)
click
:
0
window_inner_width
:
this
.
props
.
windowObj
.
innerWidth
window_inner_height
:
this
.
props
.
windowObj
.
innerHeight
tiles
:
[
{
id
:
this
.
props
.
id
pos
:
this
.
props
.
pos
.
.
.
(
this
.
props
.
shim
&
&
this
.
props
.
shim
.
click
?
{
shim
:
this
.
props
.
shim
.
click
}
:
{
}
)
type
:
this
.
props
.
flightId
?
"
spoc
"
:
"
organic
"
}
]
}
)
)
;
}
}
onSaveClick
(
event
)
{
if
(
this
.
props
.
dispatch
)
{
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SAVE_TO_POCKET
data
:
{
site
:
{
url
:
this
.
props
.
url
title
:
this
.
props
.
title
}
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
SAVE_TO_POCKET
"
source
:
"
CARDGRID_HOVER
"
action_position
:
this
.
props
.
pos
value
:
{
card_type
:
this
.
props
.
flightId
?
"
spoc
"
:
"
organic
"
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
"
CARDGRID_HOVER
"
pocket
:
0
tiles
:
[
{
id
:
this
.
props
.
id
pos
:
this
.
props
.
pos
.
.
.
(
this
.
props
.
shim
&
&
this
.
props
.
shim
.
save
?
{
shim
:
this
.
props
.
shim
.
save
}
:
{
}
)
}
]
}
)
)
;
}
}
onMenuUpdate
(
showContextMenu
)
{
if
(
!
showContextMenu
)
{
const
dsLinkMenuHostDiv
=
this
.
contextMenuButtonHostElement
;
if
(
dsLinkMenuHostDiv
)
{
dsLinkMenuHostDiv
.
classList
.
remove
(
"
active
"
"
last
-
item
"
)
;
}
}
}
async
onMenuShow
(
)
{
const
dsLinkMenuHostDiv
=
this
.
contextMenuButtonHostElement
;
if
(
dsLinkMenuHostDiv
)
{
await
this
.
props
.
windowObj
.
document
.
l10n
.
translateFragment
(
dsLinkMenuHostDiv
)
;
if
(
this
.
props
.
windowObj
.
scrollMaxX
>
0
)
{
dsLinkMenuHostDiv
.
classList
.
add
(
"
last
-
item
"
)
;
}
dsLinkMenuHostDiv
.
classList
.
add
(
"
active
"
)
;
}
}
onSeen
(
entries
)
{
if
(
this
.
state
)
{
const
entry
=
entries
.
find
(
e
=
>
e
.
isIntersecting
)
;
if
(
entry
)
{
if
(
this
.
placeholderElement
)
{
this
.
observer
.
unobserve
(
this
.
placeholderElement
)
;
}
this
.
setState
(
{
isSeen
:
true
}
)
;
}
}
}
onIdleCallback
(
)
{
if
(
!
this
.
state
.
isSeen
)
{
if
(
this
.
observer
&
&
this
.
placeholderElement
)
{
this
.
observer
.
unobserve
(
this
.
placeholderElement
)
;
}
this
.
setState
(
{
isSeen
:
true
}
)
;
}
}
componentDidMount
(
)
{
this
.
idleCallbackId
=
this
.
props
.
windowObj
.
requestIdleCallback
(
this
.
onIdleCallback
.
bind
(
this
)
)
;
if
(
this
.
placeholderElement
)
{
this
.
observer
=
new
IntersectionObserver
(
this
.
onSeen
.
bind
(
this
)
)
;
this
.
observer
.
observe
(
this
.
placeholderElement
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
observer
&
&
this
.
placeholderElement
)
{
this
.
observer
.
unobserve
(
this
.
placeholderElement
)
;
}
if
(
this
.
idleCallbackId
)
{
this
.
props
.
windowObj
.
cancelIdleCallback
(
this
.
idleCallbackId
)
;
}
}
render
(
)
{
if
(
this
.
props
.
placeholder
|
|
!
this
.
state
.
isSeen
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
card
placeholder
"
ref
:
this
.
setPlaceholderRef
}
)
;
}
const
{
isRecentSave
DiscoveryStream
saveToPocketCard
}
=
this
.
props
;
const
{
pocketButtonEnabled
hideDescriptions
compactImages
imageGradient
newSponsoredLabel
titleLines
=
3
descLines
=
3
readTime
:
displayReadTime
}
=
DiscoveryStream
;
const
excerpt
=
!
hideDescriptions
?
this
.
props
.
excerpt
:
"
"
;
let
timeToRead
;
if
(
displayReadTime
)
{
timeToRead
=
this
.
props
.
time_to_read
|
|
readTimeFromWordCount
(
this
.
props
.
word_count
)
;
}
const
compactImagesClassName
=
compactImages
?
ds
-
card
-
compact
-
image
:
;
const
imageGradientClassName
=
imageGradient
?
ds
-
card
-
image
-
gradient
:
;
const
titleLinesName
=
ds
-
card
-
title
-
lines
-
{
titleLines
}
;
const
descLinesClassName
=
ds
-
card
-
desc
-
lines
-
{
descLines
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
ds
-
card
{
compactImagesClassName
}
{
imageGradientClassName
}
{
titleLinesName
}
{
descLinesClassName
}
ref
:
this
.
setContextMenuButtonHostRef
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
card
-
link
"
dispatch
:
this
.
props
.
dispatch
onLinkClick
:
!
this
.
props
.
placeholder
?
this
.
onLinkClick
:
undefined
url
:
this
.
props
.
url
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
img
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
DSImage
{
extraClassNames
:
"
img
"
source
:
this
.
props
.
image_src
rawSource
:
this
.
props
.
raw_image_src
sizes
:
this
.
dsImageSizes
url
:
this
.
props
.
url
title
:
this
.
props
.
title
}
)
)
external_React_default
(
)
.
createElement
(
DefaultMeta
{
source
:
this
.
props
.
source
title
:
this
.
props
.
title
excerpt
:
excerpt
newSponsoredLabel
:
newSponsoredLabel
timeToRead
:
timeToRead
context
:
this
.
props
.
context
context_type
:
this
.
props
.
context_type
sponsor
:
this
.
props
.
sponsor
sponsored_by_override
:
this
.
props
.
sponsored_by_override
saveToPocketCard
:
saveToPocketCard
}
)
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
this
.
props
.
flightId
rows
:
[
{
id
:
this
.
props
.
id
pos
:
this
.
props
.
pos
.
.
.
(
this
.
props
.
shim
&
&
this
.
props
.
shim
.
impression
?
{
shim
:
this
.
props
.
shim
.
impression
}
:
{
}
)
}
]
dispatch
:
this
.
props
.
dispatch
source
:
this
.
props
.
type
}
)
)
saveToPocketCard
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
stp
-
button
-
hover
-
background
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
stp
-
button
-
position
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
card
-
stp
-
button
"
onClick
:
this
.
onSaveClick
}
this
.
props
.
context_type
=
=
=
"
pocket
"
?
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
story
-
badge
-
icon
icon
icon
-
pocket
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
saved
-
to
-
pocket
"
}
)
)
:
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
story
-
badge
-
icon
icon
icon
-
pocket
-
save
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
save
-
to
-
pocket
"
}
)
)
)
external_React_default
(
)
.
createElement
(
DSLinkMenu
{
id
:
this
.
props
.
id
index
:
this
.
props
.
pos
dispatch
:
this
.
props
.
dispatch
url
:
this
.
props
.
url
title
:
this
.
props
.
title
source
:
this
.
props
.
source
type
:
this
.
props
.
type
pocket_id
:
this
.
props
.
pocket_id
shim
:
this
.
props
.
shim
bookmarkGuid
:
this
.
props
.
bookmarkGuid
flightId
:
!
this
.
props
.
is_collection
?
this
.
props
.
flightId
:
undefined
showPrivacyInfo
:
!
!
this
.
props
.
flightId
onMenuUpdate
:
this
.
onMenuUpdate
onMenuShow
:
this
.
onMenuShow
saveToPocketCard
:
saveToPocketCard
pocket_button_enabled
:
pocketButtonEnabled
isRecentSave
:
isRecentSave
}
)
)
)
!
saveToPocketCard
&
&
external_React_default
(
)
.
createElement
(
DSLinkMenu
{
id
:
this
.
props
.
id
index
:
this
.
props
.
pos
dispatch
:
this
.
props
.
dispatch
url
:
this
.
props
.
url
title
:
this
.
props
.
title
source
:
this
.
props
.
source
type
:
this
.
props
.
type
pocket_id
:
this
.
props
.
pocket_id
shim
:
this
.
props
.
shim
bookmarkGuid
:
this
.
props
.
bookmarkGuid
flightId
:
!
this
.
props
.
is_collection
?
this
.
props
.
flightId
:
undefined
showPrivacyInfo
:
!
!
this
.
props
.
flightId
hostRef
:
this
.
contextMenuButtonHostRef
onMenuUpdate
:
this
.
onMenuUpdate
onMenuShow
:
this
.
onMenuShow
pocket_button_enabled
:
pocketButtonEnabled
isRecentSave
:
isRecentSave
}
)
)
;
}
}
_DSCard
.
defaultProps
=
{
windowObj
:
window
}
;
const
DSCard
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
App
:
state
.
App
DiscoveryStream
:
state
.
DiscoveryStream
}
)
)
(
_DSCard
)
;
const
PlaceholderDSCard
=
props
=
>
external_React_default
(
)
.
createElement
(
DSCard
{
placeholder
:
true
}
)
;
;
class
DSEmptyState
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onReset
=
this
.
onReset
.
bind
(
this
)
;
this
.
state
=
{
}
;
}
componentWillUnmount
(
)
{
if
(
this
.
timeout
)
{
clearTimeout
(
this
.
timeout
)
;
}
}
onReset
(
)
{
if
(
this
.
props
.
dispatch
&
&
this
.
props
.
feed
)
{
const
{
feed
}
=
this
.
props
;
const
{
url
}
=
feed
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_FEED_UPDATE
data
:
{
feed
:
{
.
.
.
feed
data
:
{
.
.
.
feed
.
data
status
:
"
waiting
"
}
}
url
}
}
)
;
this
.
setState
(
{
waiting
:
true
}
)
;
this
.
timeout
=
setTimeout
(
(
)
=
>
{
this
.
timeout
=
null
;
this
.
setState
(
{
waiting
:
false
}
)
;
}
300
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_RETRY_FEED
data
:
{
feed
}
}
)
)
;
}
}
renderButton
(
)
{
if
(
this
.
props
.
status
=
=
=
"
waiting
"
|
|
this
.
state
.
waiting
)
{
return
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
try
-
again
-
button
waiting
"
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
loading
"
}
)
;
}
return
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
try
-
again
-
button
"
onClick
:
this
.
onReset
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
try
-
again
-
button
"
}
)
;
}
renderState
(
)
{
if
(
this
.
props
.
status
=
=
=
"
waiting
"
|
|
this
.
props
.
status
=
=
=
"
failed
"
)
{
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
timed
-
out
"
}
)
this
.
renderButton
(
)
)
;
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
"
h2
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
header
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
discovery
-
empty
-
section
-
topstories
-
content
"
}
)
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
empty
-
state
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
empty
-
state
-
message
"
}
this
.
renderState
(
)
)
)
;
}
}
;
function
_TopicsWidget
(
props
)
{
const
{
id
source
position
DiscoveryStream
dispatch
}
=
props
;
const
{
utmCampaign
utmContent
utmSource
}
=
DiscoveryStream
.
experimentData
;
let
queryParams
=
?
utm_source
=
{
utmSource
}
;
if
(
utmCampaign
&
&
utmContent
)
{
queryParams
+
=
&
utm_content
=
{
utmContent
}
&
utm_campaign
=
{
utmCampaign
}
;
}
const
topics
=
[
{
label
:
"
Technology
"
name
:
"
technology
"
}
{
label
:
"
Science
"
name
:
"
science
"
}
{
label
:
"
Self
-
Improvement
"
name
:
"
self
-
improvement
"
}
{
label
:
"
Travel
"
name
:
"
travel
"
}
{
label
:
"
Career
"
name
:
"
career
"
}
{
label
:
"
Entertainment
"
name
:
"
entertainment
"
}
{
label
:
"
Food
"
name
:
"
food
"
}
{
label
:
"
Health
"
name
:
"
health
"
}
{
label
:
"
Must
-
Reads
"
name
:
"
must
-
reads
"
url
:
https
:
/
/
getpocket
.
com
/
collections
{
queryParams
}
}
]
;
function
onLinkClick
(
topic
positionInCard
)
{
if
(
dispatch
)
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
action_position
:
position
value
:
{
card_type
:
"
topics_widget
"
topic
.
.
.
(
positionInCard
|
|
positionInCard
=
=
=
0
?
{
position_in_card
:
positionInCard
}
:
{
}
)
}
}
)
)
;
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
click
:
0
window_inner_width
:
props
.
windowObj
.
innerWidth
window_inner_height
:
props
.
windowObj
.
innerHeight
tiles
:
[
{
id
pos
:
position
}
]
}
)
)
;
}
}
function
mapTopicItem
(
topic
index
)
{
return
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
topic
.
name
className
:
topic
.
overflow
?
"
ds
-
topics
-
widget
-
list
-
overflow
-
item
"
:
"
"
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
url
:
topic
.
url
|
|
https
:
/
/
getpocket
.
com
/
explore
/
{
topic
.
name
}
{
queryParams
}
dispatch
:
dispatch
onLinkClick
:
(
)
=
>
onLinkClick
(
topic
.
name
index
)
}
topic
.
label
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
topics
-
widget
"
}
external_React_default
(
)
.
createElement
(
"
header
"
{
className
:
"
ds
-
topics
-
widget
-
header
"
}
"
Popular
Topics
"
)
external_React_default
(
)
.
createElement
(
"
hr
"
null
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
topics
-
widget
-
list
-
container
"
}
external_React_default
(
)
.
createElement
(
"
ul
"
null
topics
.
map
(
mapTopicItem
)
)
)
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
topics
-
widget
-
button
button
primary
"
url
:
https
:
/
/
getpocket
.
com
/
{
queryParams
}
dispatch
:
dispatch
onLinkClick
:
(
)
=
>
onLinkClick
(
"
more
-
topics
"
)
}
"
More
Topics
"
)
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
dispatch
:
dispatch
rows
:
[
{
id
pos
:
position
}
]
source
:
source
}
)
)
;
}
_TopicsWidget
.
defaultProps
=
{
windowObj
:
window
}
;
const
TopicsWidget
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
DiscoveryStream
:
state
.
DiscoveryStream
}
)
)
(
_TopicsWidget
)
;
;
const
WIDGET_IDS
=
{
TOPICS
:
1
}
;
function
DSSubHeader
(
{
children
}
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
top
-
bar
ds
-
sub
-
header
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
-
container
"
}
children
)
)
;
}
function
CardGrid_IntersectionObserver
(
{
children
windowObj
=
window
onIntersecting
}
)
{
const
intersectionElement
=
(
0
external_React_namespaceObject
.
useRef
)
(
null
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
let
observer
;
if
(
!
observer
&
&
onIntersecting
&
&
intersectionElement
.
current
)
{
observer
=
new
windowObj
.
IntersectionObserver
(
entries
=
>
{
const
entry
=
entries
.
find
(
e
=
>
e
.
isIntersecting
)
;
if
(
entry
)
{
if
(
observer
&
&
intersectionElement
.
current
)
{
observer
.
unobserve
(
intersectionElement
.
current
)
;
}
onIntersecting
(
)
;
}
}
)
;
observer
.
observe
(
intersectionElement
.
current
)
;
}
return
(
)
=
>
{
var
_observer
;
return
(
_observer
=
observer
)
=
=
=
null
|
|
_observer
=
=
=
void
0
?
void
0
:
_observer
.
disconnect
(
)
;
}
;
}
[
windowObj
onIntersecting
]
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
intersectionElement
}
children
)
;
}
function
RecentSavesContainer
(
{
gridClassName
=
"
"
dispatch
windowObj
=
window
items
=
3
source
=
"
CARDGRID_RECENT_SAVES
"
}
)
{
const
{
recentSavesData
isUserLoggedIn
experimentData
:
{
utmCampaign
utmContent
utmSource
}
}
=
(
0
external_ReactRedux_namespaceObject
.
useSelector
)
(
state
=
>
state
.
DiscoveryStream
)
;
const
[
visible
setVisible
]
=
(
0
external_React_namespaceObject
.
useState
)
(
false
)
;
const
onIntersecting
=
(
0
external_React_namespaceObject
.
useCallback
)
(
(
)
=
>
setVisible
(
true
)
[
]
)
;
(
0
external_React_namespaceObject
.
useEffect
)
(
(
)
=
>
{
if
(
visible
)
{
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
DISCOVERY_STREAM_POCKET_STATE_INIT
}
)
)
;
}
}
[
visible
dispatch
]
)
;
if
(
!
visible
)
{
return
external_React_default
(
)
.
createElement
(
CardGrid_IntersectionObserver
{
windowObj
:
windowObj
onIntersecting
:
onIntersecting
}
)
;
}
if
(
visible
&
&
!
isUserLoggedIn
)
{
return
null
;
}
function
renderCard
(
rec
index
)
{
return
external_React_default
(
)
.
createElement
(
DSCard
{
key
:
dscard
-
{
(
rec
=
=
=
null
|
|
rec
=
=
=
void
0
?
void
0
:
rec
.
id
)
|
|
index
}
id
:
rec
.
id
pos
:
index
type
:
source
image_src
:
rec
.
image_src
raw_image_src
:
rec
.
raw_image_src
word_count
:
rec
.
word_count
time_to_read
:
rec
.
time_to_read
title
:
rec
.
title
excerpt
:
rec
.
excerpt
url
:
rec
.
url
source
:
rec
.
domain
isRecentSave
:
true
dispatch
:
dispatch
}
)
;
}
function
onMyListClicked
(
)
{
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
{
source
}
_VIEW_LIST
}
)
)
;
}
let
queryParams
=
?
utm_source
=
{
utmSource
}
;
if
(
utmCampaign
&
&
utmContent
)
{
queryParams
+
=
&
utm_content
=
{
utmContent
}
&
utm_campaign
=
{
utmCampaign
}
;
}
const
recentSavesCards
=
[
]
;
for
(
let
index
=
0
;
index
<
items
;
index
+
+
)
{
const
recentSave
=
recentSavesData
[
index
]
;
if
(
!
recentSave
)
{
recentSavesCards
.
push
(
external_React_default
(
)
.
createElement
(
PlaceholderDSCard
{
key
:
dscard
-
{
index
}
}
)
)
;
}
else
{
var
_recentSave
domain_me
;
recentSavesCards
.
push
(
renderCard
(
{
id
:
recentSave
.
item_id
|
|
recentSave
.
resolved_id
image_src
:
recentSave
.
top_image_url
raw_image_src
:
recentSave
.
top_image_url
word_count
:
recentSave
.
word_count
time_to_read
:
recentSave
.
time_to_read
title
:
recentSave
.
resolved_title
|
|
recentSave
.
given_title
url
:
recentSave
.
resolved_url
|
|
recentSave
.
given_url
domain
:
(
_recentSave
domain_me
=
recentSave
.
domain_metadata
)
=
=
=
null
|
|
_recentSave
domain_me
=
=
=
void
0
?
void
0
:
_recentSave
domain_me
.
name
excerpt
:
recentSave
.
excerpt
}
index
)
)
;
}
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
DSSubHeader
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
"
Recently
Saved
to
your
List
"
}
)
)
external_React_default
(
)
.
createElement
(
SafeAnchor
{
onLinkClick
:
onMyListClicked
className
:
"
section
-
sub
-
link
"
url
:
https
:
/
/
getpocket
.
com
/
a
{
queryParams
}
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
"
View
My
List
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
ds
-
card
-
grid
-
recent
-
saves
{
gridClassName
}
}
recentSavesCards
)
)
;
}
class
_CardGrid
extends
(
external_React_default
(
)
)
.
PureComponent
{
renderCards
(
)
{
var
_widgets
positions
_widgets
data
_essentialReadsCards
_editorsPicksCards
;
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
{
items
hybridLayout
hideCardBackground
fourCardLayout
compactGrid
essentialReadsHeader
editorsPicksHeader
widgets
recentSavesEnabled
hideDescriptions
DiscoveryStream
}
=
this
.
props
;
const
{
saveToPocketCard
}
=
DiscoveryStream
;
const
showRecentSaves
=
prefs
.
showRecentSaves
&
&
recentSavesEnabled
;
const
recs
=
this
.
props
.
data
.
recommendations
.
slice
(
0
items
)
;
const
cards
=
[
]
;
let
essentialReadsCards
=
[
]
;
let
editorsPicksCards
=
[
]
;
for
(
let
index
=
0
;
index
<
items
;
index
+
+
)
{
const
rec
=
recs
[
index
]
;
cards
.
push
(
!
rec
|
|
rec
.
placeholder
?
external_React_default
(
)
.
createElement
(
PlaceholderDSCard
{
key
:
dscard
-
{
index
}
}
)
:
external_React_default
(
)
.
createElement
(
DSCard
{
key
:
dscard
-
{
rec
.
id
}
pos
:
rec
.
pos
flightId
:
rec
.
flight_id
image_src
:
rec
.
image_src
raw_image_src
:
rec
.
raw_image_src
word_count
:
rec
.
word_count
time_to_read
:
rec
.
time_to_read
title
:
rec
.
title
excerpt
:
rec
.
excerpt
url
:
rec
.
url
id
:
rec
.
id
shim
:
rec
.
shim
type
:
this
.
props
.
type
context
:
rec
.
context
sponsor
:
rec
.
sponsor
sponsored_by_override
:
rec
.
sponsored_by_override
dispatch
:
this
.
props
.
dispatch
source
:
rec
.
domain
pocket_id
:
rec
.
pocket_id
context_type
:
rec
.
context_type
bookmarkGuid
:
rec
.
bookmarkGuid
is_collection
:
this
.
props
.
is_collection
saveToPocketCard
:
saveToPocketCard
&
&
!
rec
.
flight_id
}
)
)
;
}
if
(
widgets
!
=
=
null
&
&
widgets
!
=
=
void
0
&
&
(
_widgets
positions
=
widgets
.
positions
)
!
=
=
null
&
&
_widgets
positions
!
=
=
void
0
&
&
_widgets
positions
.
length
&
&
widgets
!
=
=
null
&
&
widgets
!
=
=
void
0
&
&
(
_widgets
data
=
widgets
.
data
)
!
=
=
null
&
&
_widgets
data
!
=
=
void
0
&
&
_widgets
data
.
length
)
{
let
positionIndex
=
0
;
const
source
=
"
CARDGRID_WIDGET
"
;
for
(
const
widget
of
widgets
.
data
)
{
let
widgetComponent
=
null
;
const
position
=
widgets
.
positions
[
positionIndex
]
;
if
(
!
position
)
{
break
;
}
switch
(
widget
=
=
=
null
|
|
widget
=
=
=
void
0
?
void
0
:
widget
.
type
)
{
case
"
TopicsWidget
"
:
widgetComponent
=
external_React_default
(
)
.
createElement
(
TopicsWidget
{
position
:
position
.
index
dispatch
:
this
.
props
.
dispatch
source
:
source
id
:
WIDGET_IDS
.
TOPICS
}
)
;
break
;
}
if
(
widgetComponent
)
{
positionIndex
+
+
;
cards
.
splice
(
position
.
index
1
widgetComponent
)
;
}
}
}
let
moreRecsHeader
=
"
"
;
if
(
showRecentSaves
|
|
essentialReadsHeader
&
&
editorsPicksHeader
)
{
let
spliceAt
=
6
;
if
(
fourCardLayout
)
{
spliceAt
=
8
;
}
moreRecsHeader
=
"
More
Recommendations
"
;
essentialReadsCards
=
[
.
.
.
cards
.
splice
(
0
spliceAt
)
]
;
if
(
essentialReadsHeader
&
&
editorsPicksHeader
)
{
editorsPicksCards
=
[
.
.
.
cards
.
splice
(
0
cards
.
length
)
]
;
}
}
const
hideCardBackgroundClass
=
hideCardBackground
?
ds
-
card
-
grid
-
hide
-
background
:
;
const
fourCardLayoutClass
=
fourCardLayout
?
ds
-
card
-
grid
-
four
-
card
-
variant
:
;
const
hideDescriptionsClassName
=
!
hideDescriptions
?
ds
-
card
-
grid
-
include
-
descriptions
:
;
const
compactGridClassName
=
compactGrid
?
ds
-
card
-
grid
-
compact
:
;
const
hybridLayoutClassName
=
hybridLayout
?
ds
-
card
-
grid
-
hybrid
-
layout
:
;
const
gridClassName
=
ds
-
card
-
grid
ds
-
card
-
grid
-
border
{
hybridLayoutClassName
}
{
hideCardBackgroundClass
}
{
fourCardLayoutClass
}
{
hideDescriptionsClassName
}
{
compactGridClassName
}
;
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
(
(
_essentialReadsCards
=
essentialReadsCards
)
=
=
=
null
|
|
_essentialReadsCards
=
=
=
void
0
?
void
0
:
_essentialReadsCards
.
length
)
>
0
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
gridClassName
}
essentialReadsCards
)
showRecentSaves
&
&
external_React_default
(
)
.
createElement
(
RecentSavesContainer
{
gridClassName
:
gridClassName
dispatch
:
this
.
props
.
dispatch
}
)
(
(
_editorsPicksCards
=
editorsPicksCards
)
=
=
=
null
|
|
_editorsPicksCards
=
=
=
void
0
?
void
0
:
_editorsPicksCards
.
length
)
>
0
&
&
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
DSSubHeader
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
"
Editor
\
u2019s
Picks
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
gridClassName
}
editorsPicksCards
)
)
(
cards
=
=
=
null
|
|
cards
=
=
=
void
0
?
void
0
:
cards
.
length
)
>
0
&
&
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
moreRecsHeader
&
&
external_React_default
(
)
.
createElement
(
DSSubHeader
null
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
moreRecsHeader
}
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
gridClassName
}
cards
)
)
)
;
}
render
(
)
{
const
{
data
}
=
this
.
props
;
if
(
!
data
)
{
return
null
;
}
const
isEmpty
=
data
.
recommendations
.
length
=
=
=
0
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
this
.
props
.
title
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
header
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
title
"
}
this
.
props
.
title
)
this
.
props
.
context
&
&
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
this
.
props
.
context
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
context
"
}
)
)
)
isEmpty
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
card
-
grid
empty
"
}
external_React_default
(
)
.
createElement
(
DSEmptyState
{
status
:
data
.
status
dispatch
:
this
.
props
.
dispatch
feed
:
this
.
props
.
feed
}
)
)
:
this
.
renderCards
(
)
)
;
}
}
_CardGrid
.
defaultProps
=
{
items
:
4
}
;
const
CardGrid
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
DiscoveryStream
:
state
.
DiscoveryStream
}
)
)
(
_CardGrid
)
;
;
class
DSDismiss
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onDismissClick
=
this
.
onDismissClick
.
bind
(
this
)
;
this
.
onHover
=
this
.
onHover
.
bind
(
this
)
;
this
.
offHover
=
this
.
offHover
.
bind
(
this
)
;
this
.
state
=
{
hovering
:
false
}
;
}
onDismissClick
(
)
{
if
(
this
.
props
.
onDismissClick
)
{
this
.
props
.
onDismissClick
(
)
;
}
}
onHover
(
)
{
this
.
setState
(
{
hovering
:
true
}
)
;
}
offHover
(
)
{
this
.
setState
(
{
hovering
:
false
}
)
;
}
render
(
)
{
let
className
=
ds
-
dismiss
{
this
.
state
.
hovering
?
hovering
:
}
{
this
.
props
.
extraClasses
?
{
this
.
props
.
extraClasses
}
:
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
className
}
this
.
props
.
children
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
ds
-
dismiss
-
button
"
"
data
-
l10n
-
id
"
:
"
newtab
-
dismiss
-
button
-
tooltip
"
onHover
:
this
.
onHover
onClick
:
this
.
onDismissClick
onMouseEnter
:
this
.
onHover
onMouseLeave
:
this
.
offHover
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
dismiss
"
}
)
)
)
;
}
}
;
class
CollectionCardGrid
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onDismissClick
=
this
.
onDismissClick
.
bind
(
this
)
;
this
.
state
=
{
dismissed
:
false
}
;
}
onDismissClick
(
)
{
const
{
data
}
=
this
.
props
;
if
(
this
.
props
.
dispatch
&
&
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
this
.
setState
(
{
dismissed
:
true
}
)
;
const
pos
=
0
;
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
spocsData
=
data
.
spocs
.
map
(
item
=
>
(
{
url
:
item
.
url
guid
:
item
.
id
shim
:
item
.
shim
flight_id
:
item
.
flightId
}
)
)
;
const
blockUrlOption
=
LinkMenuOptions
.
BlockUrls
(
spocsData
pos
source
)
;
const
{
action
impression
userEvent
}
=
blockUrlOption
;
this
.
props
.
dispatch
(
action
)
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
userEvent
source
action_position
:
pos
}
)
)
;
if
(
impression
)
{
this
.
props
.
dispatch
(
impression
)
;
}
}
}
render
(
)
{
const
{
data
dismissible
pocket_button_enabled
}
=
this
.
props
;
if
(
this
.
state
.
dismissed
|
|
!
data
|
|
!
data
.
spocs
|
|
!
data
.
spocs
[
0
]
|
|
data
.
spocs
.
length
<
3
)
{
return
null
;
}
const
{
spocs
placement
feed
}
=
this
.
props
;
const
{
title
context
sponsored_by_override
sponsor
}
=
spocs
.
data
[
placement
.
name
]
|
|
{
}
;
if
(
!
title
)
{
return
null
;
}
let
sponsoredByMessage
=
"
"
;
if
(
sponsored_by_override
|
|
sponsored_by_override
=
=
=
"
"
)
{
sponsoredByMessage
=
sponsored_by_override
;
}
else
if
(
sponsor
)
{
sponsoredByMessage
=
{
id
:
newtab
-
label
-
sponsored
-
by
values
:
{
sponsor
}
}
;
}
else
if
(
context
)
{
sponsoredByMessage
=
context
;
}
const
recsData
=
{
recommendations
:
data
.
spocs
}
;
const
type
=
{
this
.
props
.
type
}
_card
;
const
collectionGrid
=
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
collection
-
card
-
grid
"
}
external_React_default
(
)
.
createElement
(
CardGrid
{
pocket_button_enabled
:
pocket_button_enabled
title
:
title
context
:
sponsoredByMessage
data
:
recsData
feed
:
feed
type
:
type
is_collection
:
true
dispatch
:
this
.
props
.
dispatch
items
:
this
.
props
.
items
}
)
)
;
if
(
dismissible
)
{
return
external_React_default
(
)
.
createElement
(
DSDismiss
{
onDismissClick
:
this
.
onDismissClick
extraClasses
:
ds
-
dismiss
-
ds
-
collection
}
collectionGrid
)
;
}
return
collectionGrid
;
}
}
;
function
A11yLinkButton_extends
(
)
{
A11yLinkButton_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
A11yLinkButton_extends
.
apply
(
this
arguments
)
;
}
function
A11yLinkButton
(
props
)
{
let
className
=
"
a11y
-
link
-
button
"
;
if
(
props
.
className
)
{
className
+
=
{
props
.
className
}
;
}
return
external_React_default
(
)
.
createElement
(
"
button
"
A11yLinkButton_extends
(
{
type
:
"
button
"
}
props
{
className
:
className
}
)
props
.
children
)
;
}
;
class
ErrorBoundaryFallback
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
windowObj
=
this
.
props
.
windowObj
|
|
window
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
onClick
(
)
{
this
.
windowObj
.
location
.
reload
(
true
)
;
}
render
(
)
{
const
defaultClass
=
"
as
-
error
-
fallback
"
;
let
className
;
if
(
"
className
"
in
this
.
props
)
{
className
=
{
this
.
props
.
className
}
{
defaultClass
}
;
}
else
{
className
=
defaultClass
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
className
}
external_React_default
(
)
.
createElement
(
"
div
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
error
-
fallback
-
info
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
null
external_React_default
(
)
.
createElement
(
A11yLinkButton
{
className
:
"
reload
-
button
"
onClick
:
this
.
onClick
"
data
-
l10n
-
id
"
:
"
newtab
-
error
-
fallback
-
refresh
-
link
"
}
)
)
)
;
}
}
ErrorBoundaryFallback
.
defaultProps
=
{
className
:
"
as
-
error
-
fallback
"
}
;
class
ErrorBoundary
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
hasError
:
false
}
;
}
componentDidCatch
(
error
info
)
{
this
.
setState
(
{
hasError
:
true
}
)
;
}
render
(
)
{
if
(
!
this
.
state
.
hasError
)
{
return
this
.
props
.
children
;
}
return
external_React_default
(
)
.
createElement
(
this
.
props
.
FallbackComponent
{
className
:
this
.
props
.
className
}
)
;
}
}
ErrorBoundary
.
defaultProps
=
{
FallbackComponent
:
ErrorBoundaryFallback
}
;
;
class
_CollapsibleSection
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onBodyMount
=
this
.
onBodyMount
.
bind
(
this
)
;
this
.
onMenuButtonMouseEnter
=
this
.
onMenuButtonMouseEnter
.
bind
(
this
)
;
this
.
onMenuButtonMouseLeave
=
this
.
onMenuButtonMouseLeave
.
bind
(
this
)
;
this
.
onMenuUpdate
=
this
.
onMenuUpdate
.
bind
(
this
)
;
this
.
state
=
{
menuButtonHover
:
false
showContextMenu
:
false
}
;
this
.
setContextMenuButtonRef
=
this
.
setContextMenuButtonRef
.
bind
(
this
)
;
}
setContextMenuButtonRef
(
element
)
{
this
.
contextMenuButtonRef
=
element
;
}
onBodyMount
(
node
)
{
this
.
sectionBody
=
node
;
}
onMenuButtonMouseEnter
(
)
{
this
.
setState
(
{
menuButtonHover
:
true
}
)
;
}
onMenuButtonMouseLeave
(
)
{
this
.
setState
(
{
menuButtonHover
:
false
}
)
;
}
onMenuUpdate
(
showContextMenu
)
{
this
.
setState
(
{
showContextMenu
}
)
;
}
render
(
)
{
const
{
isAnimating
maxHeight
menuButtonHover
showContextMenu
}
=
this
.
state
;
const
{
id
collapsed
learnMore
title
subTitle
}
=
this
.
props
;
const
active
=
menuButtonHover
|
|
showContextMenu
;
let
bodyStyle
;
if
(
isAnimating
&
&
!
collapsed
)
{
bodyStyle
=
{
maxHeight
}
;
}
else
if
(
!
isAnimating
&
&
collapsed
)
{
bodyStyle
=
{
display
:
"
none
"
}
;
}
let
titleStyle
;
if
(
this
.
props
.
hideTitle
)
{
titleStyle
=
{
visibility
:
"
hidden
"
}
;
}
const
hasSubtitleClassName
=
subTitle
?
has
-
subtitle
:
;
return
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
collapsible
-
section
{
this
.
props
.
className
}
{
active
?
"
active
"
:
"
"
}
"
data
-
section
-
id
"
:
id
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
top
-
bar
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
section
-
title
-
container
{
hasSubtitleClassName
}
style
:
titleStyle
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
title
}
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
learn
-
more
-
link
-
wrapper
"
}
learnMore
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
learn
-
more
-
link
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
learnMore
.
link
.
message
}
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
learnMore
.
link
.
href
}
)
)
)
)
subTitle
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
section
-
sub
-
title
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
subTitle
}
)
)
)
)
external_React_default
(
)
.
createElement
(
ErrorBoundary
{
className
:
"
section
-
body
-
fallback
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
this
.
onBodyMount
style
:
bodyStyle
}
this
.
props
.
children
)
)
)
;
}
}
_CollapsibleSection
.
defaultProps
=
{
document
:
__webpack_require__
.
g
.
document
|
|
{
addEventListener
:
(
)
=
>
{
}
removeEventListener
:
(
)
=
>
{
}
visibilityState
:
"
hidden
"
}
}
;
const
CollapsibleSection
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
_CollapsibleSection
)
;
;
class
DSMessage
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
message
"
}
external_React_default
(
)
.
createElement
(
"
header
"
{
className
:
"
title
"
}
this
.
props
.
icon
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
glyph
"
style
:
{
backgroundImage
:
url
(
{
this
.
props
.
icon
}
)
}
}
)
this
.
props
.
title
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
title
-
text
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
this
.
props
.
title
}
)
)
this
.
props
.
link_text
&
&
this
.
props
.
link_url
&
&
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
link
"
url
:
this
.
props
.
link_url
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
this
.
props
.
link_text
}
)
)
)
)
;
}
}
;
class
ModalOverlayWrapper
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
}
onKeyDown
(
event
)
{
if
(
event
.
key
=
=
=
"
Escape
"
)
{
this
.
props
.
onClose
(
event
)
;
}
}
componentWillMount
(
)
{
this
.
props
.
document
.
addEventListener
(
"
keydown
"
this
.
onKeyDown
)
;
this
.
props
.
document
.
body
.
classList
.
add
(
"
modal
-
open
"
)
;
}
componentWillUnmount
(
)
{
this
.
props
.
document
.
removeEventListener
(
"
keydown
"
this
.
onKeyDown
)
;
this
.
props
.
document
.
body
.
classList
.
remove
(
"
modal
-
open
"
)
;
}
render
(
)
{
const
{
props
}
=
this
;
let
className
=
props
.
unstyled
?
"
"
:
"
modalOverlayInner
active
"
;
if
(
props
.
innerClassName
)
{
className
+
=
{
props
.
innerClassName
}
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
modalOverlayOuter
active
"
onKeyDown
:
this
.
onKeyDown
role
:
"
presentation
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
className
"
aria
-
labelledby
"
:
props
.
headerId
id
:
props
.
id
role
:
"
dialog
"
}
props
.
children
)
)
;
}
}
ModalOverlayWrapper
.
defaultProps
=
{
document
:
__webpack_require__
.
g
.
document
}
;
;
class
DSPrivacyModal
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
closeModal
=
this
.
closeModal
.
bind
(
this
)
;
this
.
onLearnLinkClick
=
this
.
onLearnLinkClick
.
bind
(
this
)
;
this
.
onManageLinkClick
=
this
.
onManageLinkClick
.
bind
(
this
)
;
}
onLearnLinkClick
(
event
)
{
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK_PRIVACY_INFO
"
source
:
"
DS_PRIVACY_MODAL
"
}
)
)
;
}
onManageLinkClick
(
event
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SETTINGS_OPEN
}
)
)
;
}
closeModal
(
)
{
this
.
props
.
dispatch
(
{
type
:
HIDE_PRIVACY_INFO
data
:
{
}
}
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
ModalOverlayWrapper
{
onClose
:
this
.
closeModal
innerClassName
:
"
ds
-
privacy
-
modal
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
privacy
-
notice
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
header
"
}
)
external_React_default
(
)
.
createElement
(
"
p
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
paragraph
-
2
"
}
)
external_React_default
(
)
.
createElement
(
"
a
"
{
className
:
"
modal
-
link
modal
-
link
-
privacy
"
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
link
"
onClick
:
this
.
onLearnLinkClick
href
:
"
https
:
/
/
help
.
getpocket
.
com
/
article
/
1142
-
firefox
-
new
-
tab
-
recommendations
-
faq
"
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
modal
-
link
modal
-
link
-
manage
"
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
button
-
manage
"
onClick
:
this
.
onManageLinkClick
}
)
)
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
"
type
:
"
submit
"
onClick
:
this
.
closeModal
"
data
-
l10n
-
id
"
:
"
newtab
-
privacy
-
modal
-
button
-
done
"
}
)
)
)
;
}
}
;
class
DSSignup
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
active
:
false
lastItem
:
false
}
;
this
.
onMenuButtonUpdate
=
this
.
onMenuButtonUpdate
.
bind
(
this
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
onMenuShow
=
this
.
onMenuShow
.
bind
(
this
)
;
}
onMenuButtonUpdate
(
showContextMenu
)
{
if
(
!
showContextMenu
)
{
this
.
setState
(
{
active
:
false
lastItem
:
false
}
)
;
}
}
nextAnimationFrame
(
)
{
return
new
Promise
(
resolve
=
>
this
.
props
.
windowObj
.
requestAnimationFrame
(
resolve
)
)
;
}
async
onMenuShow
(
)
{
let
{
lastItem
}
=
this
.
state
;
await
this
.
nextAnimationFrame
(
)
;
if
(
this
.
props
.
windowObj
.
scrollMaxX
>
0
)
{
lastItem
=
true
;
}
this
.
setState
(
{
active
:
true
lastItem
}
)
;
}
onLinkClick
(
)
{
const
{
data
}
=
this
.
props
;
if
(
this
.
props
.
dispatch
&
&
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
[
spoc
]
=
data
.
spocs
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
action_position
:
0
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
click
:
0
tiles
:
[
{
id
:
spoc
.
id
pos
:
0
.
.
.
(
spoc
.
shim
&
&
spoc
.
shim
.
click
?
{
shim
:
spoc
.
shim
.
click
}
:
{
}
)
}
]
}
)
)
;
}
}
render
(
)
{
const
{
data
dispatch
type
}
=
this
.
props
;
if
(
!
data
|
|
!
data
.
spocs
|
|
!
data
.
spocs
[
0
]
)
{
return
null
;
}
const
[
spoc
]
=
data
.
spocs
;
const
{
title
url
excerpt
flight_id
id
shim
}
=
spoc
;
const
SIGNUP_CONTEXT_MENU_OPTIONS
=
[
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
.
.
.
(
flight_id
?
[
"
ShowPrivacyInfo
"
]
:
[
]
)
]
;
const
outerClassName
=
[
"
ds
-
signup
"
this
.
state
.
active
&
&
"
active
"
this
.
state
.
lastItem
&
&
"
last
-
item
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
outerClassName
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
signup
-
content
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
icon
-
small
-
spacer
icon
-
mail
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
null
title
"
"
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
chevron
-
link
"
dispatch
:
dispatch
onLinkClick
:
this
.
onLinkClick
url
:
url
}
excerpt
)
)
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
flight_id
rows
:
[
{
id
pos
:
0
shim
:
shim
&
&
shim
.
impression
}
]
dispatch
:
dispatch
source
:
type
}
)
)
external_React_default
(
)
.
createElement
(
ContextMenuButton
{
tooltip
:
"
newtab
-
menu
-
content
-
tooltip
"
tooltipArgs
:
{
title
}
onUpdate
:
this
.
onMenuButtonUpdate
}
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
0
source
:
type
.
toUpperCase
(
)
onShow
:
this
.
onMenuShow
options
:
SIGNUP_CONTEXT_MENU_OPTIONS
shouldSendImpressionStats
:
true
userEvent
:
actionCreators
.
DiscoveryStreamUserEvent
site
:
{
referrer
:
"
https
:
/
/
getpocket
.
com
/
recommendations
"
title
type
url
guid
:
id
shim
flight_id
}
}
)
)
)
;
}
}
DSSignup
.
defaultProps
=
{
windowObj
:
window
}
;
;
class
DSTextPromo
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
onDismissClick
=
this
.
onDismissClick
.
bind
(
this
)
;
}
onLinkClick
(
)
{
const
{
data
}
=
this
.
props
;
if
(
this
.
props
.
dispatch
&
&
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
[
spoc
]
=
data
.
spocs
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
action_position
:
0
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
click
:
0
tiles
:
[
{
id
:
spoc
.
id
pos
:
0
.
.
.
(
spoc
.
shim
&
&
spoc
.
shim
.
click
?
{
shim
:
spoc
.
shim
.
click
}
:
{
}
)
}
]
}
)
)
;
}
}
onDismissClick
(
)
{
const
{
data
}
=
this
.
props
;
if
(
this
.
props
.
dispatch
&
&
data
&
&
data
.
spocs
&
&
data
.
spocs
.
length
)
{
const
index
=
0
;
const
source
=
this
.
props
.
type
.
toUpperCase
(
)
;
const
[
spoc
]
=
data
.
spocs
;
const
spocData
=
{
url
:
spoc
.
url
guid
:
spoc
.
id
shim
:
spoc
.
shim
}
;
const
blockUrlOption
=
LinkMenuOptions
.
BlockUrl
(
spocData
index
source
)
;
const
{
action
impression
userEvent
}
=
blockUrlOption
;
this
.
props
.
dispatch
(
action
)
;
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
userEvent
source
action_position
:
index
}
)
)
;
if
(
impression
)
{
this
.
props
.
dispatch
(
impression
)
;
}
}
}
render
(
)
{
const
{
data
}
=
this
.
props
;
if
(
!
data
|
|
!
data
.
spocs
|
|
!
data
.
spocs
[
0
]
)
{
return
null
;
}
const
[
spoc
]
=
data
.
spocs
;
const
{
image_src
raw_image_src
alt_text
title
url
context
cta
flight_id
id
shim
}
=
spoc
;
return
external_React_default
(
)
.
createElement
(
DSDismiss
{
onDismissClick
:
this
.
onDismissClick
extraClasses
:
ds
-
dismiss
-
ds
-
text
-
promo
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
text
-
promo
"
}
external_React_default
(
)
.
createElement
(
DSImage
{
alt_text
:
alt_text
source
:
image_src
rawSource
:
raw_image_src
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
text
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
null
{
title
}
\
u2003
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
chevron
-
link
"
dispatch
:
this
.
props
.
dispatch
onLinkClick
:
this
.
onLinkClick
url
:
url
}
cta
)
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
subtitle
"
}
context
)
)
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
flight_id
rows
:
[
{
id
pos
:
0
shim
:
shim
&
&
shim
.
impression
}
]
dispatch
:
this
.
props
.
dispatch
source
:
this
.
props
.
type
}
)
)
)
;
}
}
;
const
ScreenshotUtils
=
{
isBlob
(
isLocal
image
)
{
return
!
!
(
image
&
&
image
.
path
&
&
(
!
isLocal
&
&
image
.
data
|
|
isLocal
&
&
image
.
url
)
)
;
}
createLocalImageObject
(
remoteImage
)
{
if
(
!
remoteImage
)
{
return
null
;
}
if
(
this
.
isBlob
(
false
remoteImage
)
)
{
return
{
url
:
__webpack_require__
.
g
.
URL
.
createObjectURL
(
remoteImage
.
data
)
path
:
remoteImage
.
path
}
;
}
return
{
url
:
remoteImage
}
;
}
maybeRevokeBlobObjectURL
(
localImage
)
{
if
(
this
.
isBlob
(
true
localImage
)
)
{
__webpack_require__
.
g
.
URL
.
revokeObjectURL
(
localImage
.
url
)
;
}
}
isRemoteImageLocal
(
localImage
remoteImage
)
{
if
(
remoteImage
&
&
localImage
)
{
return
this
.
isBlob
(
false
remoteImage
)
?
localImage
.
path
=
=
=
remoteImage
.
path
:
localImage
.
url
=
=
=
remoteImage
;
}
return
!
remoteImage
&
&
!
localImage
;
}
}
;
;
const
gImageLoading
=
new
Map
(
)
;
class
_Card
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
activeCard
:
null
imageLoaded
:
false
cardImage
:
null
}
;
this
.
onMenuButtonUpdate
=
this
.
onMenuButtonUpdate
.
bind
(
this
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
}
async
maybeLoadImage
(
)
{
const
{
cardImage
}
=
this
.
state
;
if
(
!
cardImage
)
{
return
;
}
const
imageUrl
=
cardImage
.
url
;
if
(
!
this
.
state
.
imageLoaded
)
{
if
(
!
gImageLoading
.
has
(
imageUrl
)
)
{
const
loaderPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
const
loader
=
new
Image
(
)
;
loader
.
addEventListener
(
"
load
"
resolve
)
;
loader
.
addEventListener
(
"
error
"
reject
)
;
loader
.
src
=
imageUrl
;
}
)
;
gImageLoading
.
set
(
imageUrl
loaderPromise
)
;
loaderPromise
.
catch
(
ex
=
>
ex
)
.
then
(
(
)
=
>
gImageLoading
.
delete
(
imageUrl
)
)
.
catch
(
)
;
}
try
{
await
gImageLoading
.
get
(
imageUrl
)
;
}
catch
(
ex
)
{
return
;
}
if
(
ScreenshotUtils
.
isRemoteImageLocal
(
this
.
state
.
cardImage
this
.
props
.
link
.
image
)
&
&
!
this
.
state
.
imageLoaded
)
{
this
.
setState
(
{
imageLoaded
:
true
}
)
;
}
}
}
static
getNextStateFromProps
(
nextProps
prevState
)
{
const
{
image
}
=
nextProps
.
link
;
const
imageInState
=
ScreenshotUtils
.
isRemoteImageLocal
(
prevState
.
cardImage
image
)
;
let
nextState
=
null
;
if
(
!
imageInState
&
&
nextProps
.
link
)
{
nextState
=
{
imageLoaded
:
false
}
;
}
if
(
imageInState
)
{
return
nextState
;
}
ScreenshotUtils
.
maybeRevokeBlobObjectURL
(
prevState
.
cardImage
)
;
nextState
=
nextState
|
|
{
}
;
nextState
.
cardImage
=
ScreenshotUtils
.
createLocalImageObject
(
image
)
;
return
nextState
;
}
onMenuButtonUpdate
(
isOpen
)
{
if
(
isOpen
)
{
this
.
setState
(
{
activeCard
:
this
.
props
.
index
}
)
;
}
else
{
this
.
setState
(
{
activeCard
:
null
}
)
;
}
}
_getTelemetryInfo
(
)
{
if
(
this
.
props
.
link
.
type
!
=
=
"
history
"
)
{
return
{
value
:
{
card_type
:
this
.
props
.
link
.
type
}
}
;
}
return
null
;
}
onLinkClick
(
event
)
{
event
.
preventDefault
(
)
;
const
{
altKey
button
ctrlKey
metaKey
shiftKey
}
=
event
;
if
(
this
.
props
.
link
.
type
=
=
=
"
download
"
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_DOWNLOAD_FILE
data
:
Object
.
assign
(
this
.
props
.
link
{
event
:
{
button
ctrlKey
metaKey
shiftKey
}
}
)
}
)
)
;
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
Object
.
assign
(
this
.
props
.
link
{
event
:
{
altKey
button
ctrlKey
metaKey
shiftKey
}
}
)
}
)
)
;
}
if
(
this
.
props
.
isWebExtension
)
{
this
.
props
.
dispatch
(
actionCreators
.
WebExtEvent
(
actionTypes
.
WEBEXT_CLICK
{
source
:
this
.
props
.
eventSource
url
:
this
.
props
.
link
.
url
action_position
:
this
.
props
.
index
}
)
)
;
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
Object
.
assign
(
{
event
:
"
CLICK
"
source
:
this
.
props
.
eventSource
action_position
:
this
.
props
.
index
}
this
.
_getTelemetryInfo
(
)
)
)
)
;
if
(
this
.
props
.
shouldSendImpressionStats
)
{
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
this
.
props
.
eventSource
click
:
0
tiles
:
[
{
id
:
this
.
props
.
link
.
guid
pos
:
this
.
props
.
index
}
]
}
)
)
;
}
}
}
componentDidMount
(
)
{
this
.
maybeLoadImage
(
)
;
}
componentDidUpdate
(
)
{
this
.
maybeLoadImage
(
)
;
}
componentWillMount
(
)
{
const
nextState
=
_Card
.
getNextStateFromProps
(
this
.
props
this
.
state
)
;
if
(
nextState
)
{
this
.
setState
(
nextState
)
;
}
}
componentWillReceiveProps
(
nextProps
)
{
const
nextState
=
_Card
.
getNextStateFromProps
(
nextProps
this
.
state
)
;
if
(
nextState
)
{
this
.
setState
(
nextState
)
;
}
}
componentWillUnmount
(
)
{
ScreenshotUtils
.
maybeRevokeBlobObjectURL
(
this
.
state
.
cardImage
)
;
}
render
(
)
{
const
{
index
className
link
dispatch
contextMenuOptions
eventSource
shouldSendImpressionStats
}
=
this
.
props
;
const
{
props
}
=
this
;
const
title
=
link
.
title
|
|
link
.
hostname
;
const
isContextMenuOpen
=
this
.
state
.
activeCard
=
=
=
index
;
const
{
icon
fluentID
}
=
cardContextTypes
[
link
.
type
=
=
=
"
now
"
?
"
trending
"
:
link
.
type
]
|
|
{
}
;
const
hasImage
=
this
.
state
.
cardImage
|
|
link
.
hasImage
;
const
imageStyle
=
{
backgroundImage
:
this
.
state
.
cardImage
?
url
(
{
this
.
state
.
cardImage
.
url
}
)
:
"
none
"
}
;
const
outerClassName
=
[
"
card
-
outer
"
className
isContextMenuOpen
&
&
"
active
"
props
.
placeholder
&
&
"
placeholder
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
return
external_React_default
(
)
.
createElement
(
"
li
"
{
className
:
outerClassName
}
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
link
.
type
=
=
=
"
pocket
"
?
link
.
open_url
:
link
.
url
onClick
:
!
props
.
placeholder
?
this
.
onLinkClick
:
undefined
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
preview
-
image
-
outer
"
}
hasImage
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
card
-
preview
-
image
{
this
.
state
.
imageLoaded
?
"
loaded
"
:
"
"
}
style
:
imageStyle
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
details
"
}
link
.
type
=
=
=
"
download
"
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
host
-
name
alternate
"
"
data
-
l10n
-
id
"
:
"
newtab
-
menu
-
open
-
file
"
}
)
link
.
hostname
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
host
-
name
"
}
link
.
hostname
.
slice
(
0
100
)
link
.
type
=
=
=
"
download
"
&
&
\
u2014
{
link
.
description
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
[
"
card
-
text
"
icon
?
"
"
:
"
no
-
context
"
link
.
description
?
"
"
:
"
no
-
description
"
link
.
hostname
?
"
"
:
"
no
-
host
-
name
"
]
.
join
(
"
"
)
}
external_React_default
(
)
.
createElement
(
"
h4
"
{
className
:
"
card
-
title
"
dir
:
"
auto
"
}
link
.
title
)
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
card
-
description
"
dir
:
"
auto
"
}
link
.
description
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
context
"
}
icon
&
&
!
link
.
context
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
"
aria
-
haspopup
"
:
"
true
"
className
:
card
-
context
-
icon
icon
icon
-
{
icon
}
}
)
link
.
icon
&
&
link
.
context
&
&
external_React_default
(
)
.
createElement
(
"
span
"
{
"
aria
-
haspopup
"
:
"
true
"
className
:
"
card
-
context
-
icon
icon
"
style
:
{
backgroundImage
:
url
(
'
{
link
.
icon
}
'
)
}
}
)
fluentID
&
&
!
link
.
context
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
context
-
label
"
"
data
-
l10n
-
id
"
:
fluentID
}
)
link
.
context
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
card
-
context
-
label
"
}
link
.
context
)
)
)
)
)
!
props
.
placeholder
&
&
external_React_default
(
)
.
createElement
(
ContextMenuButton
{
tooltip
:
"
newtab
-
menu
-
content
-
tooltip
"
tooltipArgs
:
{
title
}
onUpdate
:
this
.
onMenuButtonUpdate
}
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
dispatch
index
:
index
source
:
eventSource
options
:
link
.
contextMenuOptions
|
|
contextMenuOptions
site
:
link
siteInfo
:
this
.
_getTelemetryInfo
(
)
shouldSendImpressionStats
:
shouldSendImpressionStats
}
)
)
)
;
}
}
_Card
.
defaultProps
=
{
link
:
{
}
}
;
const
Card
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
platform
:
state
.
Prefs
.
values
.
platform
}
)
)
(
_Card
)
;
const
PlaceholderCard
=
props
=
>
external_React_default
(
)
.
createElement
(
Card
{
placeholder
:
true
className
:
props
.
className
}
)
;
;
let
usablePerfObj
=
window
.
performance
;
function
_PerfService
(
options
)
{
if
(
options
&
&
options
.
performanceObj
)
{
this
.
_perf
=
options
.
performanceObj
;
}
else
{
this
.
_perf
=
usablePerfObj
;
}
}
_PerfService
.
prototype
=
{
mark
:
function
mark
(
str
)
{
this
.
_perf
.
mark
(
str
)
;
}
getEntriesByName
:
function
getEntriesByName
(
name
type
)
{
return
this
.
_perf
.
getEntriesByName
(
name
type
)
;
}
get
timeOrigin
(
)
{
return
this
.
_perf
.
timeOrigin
;
}
absNow
:
function
absNow
(
)
{
return
this
.
timeOrigin
+
this
.
_perf
.
now
(
)
;
}
getMostRecentAbsMarkStartByName
(
name
)
{
let
entries
=
this
.
getEntriesByName
(
name
"
mark
"
)
;
if
(
!
entries
.
length
)
{
throw
new
Error
(
No
marks
with
the
name
{
name
}
)
;
}
let
mostRecentEntry
=
entries
[
entries
.
length
-
1
]
;
return
this
.
_perf
.
timeOrigin
+
mostRecentEntry
.
startTime
;
}
}
;
const
perfService
=
new
_PerfService
(
)
;
;
const
RECORDED_SECTIONS
=
[
"
highlights
"
"
topsites
"
]
;
class
ComponentPerfTimer
extends
(
external_React_default
(
)
)
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
perfSvc
=
this
.
props
.
perfSvc
|
|
perfService
;
this
.
_sendBadStateEvent
=
this
.
_sendBadStateEvent
.
bind
(
this
)
;
this
.
_sendPaintedEvent
=
this
.
_sendPaintedEvent
.
bind
(
this
)
;
this
.
_reportMissingData
=
false
;
this
.
_timestampHandled
=
false
;
this
.
_recordedFirstRender
=
false
;
}
componentDidMount
(
)
{
if
(
!
RECORDED_SECTIONS
.
includes
(
this
.
props
.
id
)
)
{
return
;
}
this
.
_maybeSendPaintedEvent
(
)
;
}
componentDidUpdate
(
)
{
if
(
!
RECORDED_SECTIONS
.
includes
(
this
.
props
.
id
)
)
{
return
;
}
this
.
_maybeSendPaintedEvent
(
)
;
}
_afterFramePaint
(
callback
)
{
requestAnimationFrame
(
(
)
=
>
setTimeout
(
callback
0
)
)
;
}
_maybeSendBadStateEvent
(
)
{
if
(
!
this
.
props
.
initialized
)
{
this
.
_reportMissingData
=
true
;
}
else
if
(
this
.
_reportMissingData
)
{
this
.
_reportMissingData
=
false
;
this
.
_sendBadStateEvent
(
)
;
}
}
_maybeSendPaintedEvent
(
)
{
if
(
this
.
_timestampHandled
|
|
!
this
.
props
.
initialized
)
{
return
;
}
this
.
_timestampHandled
=
true
;
this
.
_afterFramePaint
(
this
.
_sendPaintedEvent
)
;
}
_ensureFirstRenderTsRecorded
(
)
{
if
(
!
this
.
_recordedFirstRender
)
{
this
.
_recordedFirstRender
=
true
;
const
key
=
{
this
.
props
.
id
}
_first_render_ts
;
this
.
perfSvc
.
mark
(
key
)
;
}
}
_sendBadStateEvent
(
)
{
const
dataReadyKey
=
{
this
.
props
.
id
}
_data_ready_ts
;
this
.
perfSvc
.
mark
(
dataReadyKey
)
;
try
{
const
firstRenderKey
=
{
this
.
props
.
id
}
_first_render_ts
;
const
value
=
parseInt
(
this
.
perfSvc
.
getMostRecentAbsMarkStartByName
(
dataReadyKey
)
-
this
.
perfSvc
.
getMostRecentAbsMarkStartByName
(
firstRenderKey
)
10
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SAVE_SESSION_PERF_DATA
data
:
{
[
{
this
.
props
.
id
}
_data_late_by_ms
]
:
value
}
}
)
)
;
}
catch
(
ex
)
{
}
}
_sendPaintedEvent
(
)
{
if
(
this
.
props
.
id
!
=
=
"
topsites
"
)
{
return
;
}
const
key
=
{
this
.
props
.
id
}
_first_painted_ts
;
this
.
perfSvc
.
mark
(
key
)
;
try
{
const
data
=
{
}
;
data
[
key
]
=
this
.
perfSvc
.
getMostRecentAbsMarkStartByName
(
key
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SAVE_SESSION_PERF_DATA
data
}
)
)
;
}
catch
(
ex
)
{
}
}
render
(
)
{
if
(
RECORDED_SECTIONS
.
includes
(
this
.
props
.
id
)
)
{
this
.
_ensureFirstRenderTsRecorded
(
)
;
this
.
_maybeSendBadStateEvent
(
)
;
}
return
this
.
props
.
children
;
}
}
;
class
MoreRecommendations
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
read_more_endpoint
}
=
this
.
props
;
if
(
read_more_endpoint
)
{
return
external_React_default
(
)
.
createElement
(
"
a
"
{
className
:
"
more
-
recommendations
"
href
:
read_more_endpoint
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
more
-
recommendations
"
}
)
;
}
return
null
;
}
}
;
class
_PocketLoggedInCta
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
pocketCta
}
=
this
.
props
.
Pocket
;
return
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
pocket
-
logged
-
in
-
cta
"
}
external_React_default
(
)
.
createElement
(
"
a
"
{
className
:
"
pocket
-
cta
-
button
"
href
:
pocketCta
.
ctaUrl
?
pocketCta
.
ctaUrl
:
"
https
:
/
/
getpocket
.
com
/
"
}
pocketCta
.
ctaButton
?
pocketCta
.
ctaButton
:
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
cta
-
button
"
}
)
)
external_React_default
(
)
.
createElement
(
"
a
"
{
href
:
pocketCta
.
ctaUrl
?
pocketCta
.
ctaUrl
:
"
https
:
/
/
getpocket
.
com
/
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
cta
-
text
"
}
pocketCta
.
ctaText
?
pocketCta
.
ctaText
:
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
cta
-
text
"
}
)
)
)
)
;
}
}
const
PocketLoggedInCta
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Pocket
:
state
.
Pocket
}
)
)
(
_PocketLoggedInCta
)
;
;
class
Topic
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
url
name
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
"
li
"
null
external_React_default
(
)
.
createElement
(
"
a
"
{
key
:
name
href
:
url
}
name
)
)
;
}
}
class
Topics
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
topics
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
topics
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
read
-
more
"
}
)
external_React_default
(
)
.
createElement
(
"
ul
"
null
topics
&
&
topics
.
map
(
t
=
>
external_React_default
(
)
.
createElement
(
Topic
{
key
:
t
.
name
url
:
t
.
url
name
:
t
.
name
}
)
)
)
)
;
}
}
;
const
TOP_SITES_SOURCE
=
"
TOP_SITES
"
;
const
TOP_SITES_CONTEXT_MENU_OPTIONS
=
[
"
CheckPinTopSite
"
"
EditTopSite
"
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
"
DeleteUrl
"
]
;
const
TOP_SITES_SPOC_CONTEXT_MENU_OPTIONS
=
[
"
PinTopSite
"
"
Separator
"
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
"
ShowPrivacyInfo
"
]
;
const
TOP_SITES_SPONSORED_POSITION_CONTEXT_MENU_OPTIONS
=
[
"
OpenInNewWindow
"
"
OpenInPrivateWindow
"
"
Separator
"
"
BlockUrl
"
"
AboutSponsored
"
]
;
const
TOP_SITES_SEARCH_SHORTCUTS_CONTEXT_MENU_OPTIONS
=
[
"
CheckPinTopSite
"
"
Separator
"
"
BlockUrl
"
]
;
const
MIN_RICH_FAVICON_SIZE
=
96
;
const
MIN_SMALL_FAVICON_SIZE
=
16
;
;
class
SelectableSearchShortcut
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
shortcut
selected
}
=
this
.
props
;
const
imageStyle
=
{
backgroundImage
:
url
(
"
{
shortcut
.
tippyTopIcon
}
"
)
}
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
outer
search
-
shortcut
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
checkbox
"
id
:
shortcut
.
keyword
name
:
shortcut
.
keyword
checked
:
selected
onChange
:
this
.
props
.
onChange
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
shortcut
.
keyword
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
inner
"
}
external_React_default
(
)
.
createElement
(
"
span
"
null
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
tile
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
icon
rich
-
icon
"
style
:
imageStyle
"
data
-
fallback
"
:
"
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
icon
search
-
topsite
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
title
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
dir
:
"
auto
"
}
shortcut
.
keyword
)
)
)
)
)
)
;
}
}
class
SearchShortcutsForm
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
handleChange
=
this
.
handleChange
.
bind
(
this
)
;
this
.
onCancelButtonClick
=
this
.
onCancelButtonClick
.
bind
(
this
)
;
this
.
onSaveButtonClick
=
this
.
onSaveButtonClick
.
bind
(
this
)
;
const
shortcuts
=
[
]
;
const
{
rows
searchShortcuts
}
=
props
.
TopSites
;
searchShortcuts
.
forEach
(
shortcut
=
>
{
shortcuts
.
push
(
{
.
.
.
shortcut
isSelected
:
!
!
rows
.
find
(
row
=
>
row
&
&
row
.
isPinned
&
&
row
.
searchTopSite
&
&
row
.
label
=
=
=
shortcut
.
keyword
)
}
)
;
}
)
;
this
.
state
=
{
shortcuts
}
;
}
handleChange
(
event
)
{
const
{
target
}
=
event
;
const
{
name
checked
}
=
target
;
this
.
setState
(
prevState
=
>
{
const
shortcuts
=
prevState
.
shortcuts
.
slice
(
)
;
let
shortcut
=
shortcuts
.
find
(
(
{
keyword
}
)
=
>
keyword
=
=
=
name
)
;
shortcut
.
isSelected
=
checked
;
return
{
shortcuts
}
;
}
)
;
}
onCancelButtonClick
(
ev
)
{
ev
.
preventDefault
(
)
;
this
.
props
.
onClose
(
)
;
}
onSaveButtonClick
(
ev
)
{
ev
.
preventDefault
(
)
;
const
{
rows
}
=
this
.
props
.
TopSites
;
const
pinQueue
=
[
]
;
const
unpinQueue
=
[
]
;
this
.
state
.
shortcuts
.
forEach
(
shortcut
=
>
{
const
alreadyPinned
=
rows
.
find
(
row
=
>
row
&
&
row
.
isPinned
&
&
row
.
searchTopSite
&
&
row
.
label
=
=
=
shortcut
.
keyword
)
;
if
(
shortcut
.
isSelected
&
&
!
alreadyPinned
)
{
pinQueue
.
push
(
this
.
_searchTopSite
(
shortcut
)
)
;
}
else
if
(
!
shortcut
.
isSelected
&
&
alreadyPinned
)
{
unpinQueue
.
push
(
{
url
:
alreadyPinned
.
url
searchVendor
:
shortcut
.
shortURL
}
)
;
}
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
UPDATE_PINNED_SEARCH_SHORTCUTS
data
:
{
addedShortcuts
:
pinQueue
deletedShortcuts
:
unpinQueue
}
}
)
)
;
pinQueue
.
forEach
(
shortcut
=
>
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
SEARCH_EDIT_ADD
"
value
:
{
search_vendor
:
shortcut
.
searchVendor
}
}
)
)
;
}
)
;
unpinQueue
.
forEach
(
shortcut
=
>
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
SEARCH_EDIT_DELETE
"
value
:
{
search_vendor
:
shortcut
.
searchVendor
}
}
)
)
;
}
)
;
this
.
props
.
onClose
(
)
;
}
_searchTopSite
(
shortcut
)
{
return
{
url
:
shortcut
.
url
searchTopSite
:
true
label
:
shortcut
.
keyword
searchVendor
:
shortcut
.
shortURL
}
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
form
"
{
className
:
"
topsite
-
form
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
search
-
shortcuts
-
container
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
grey
-
title
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
add
-
search
-
engine
-
header
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
null
this
.
state
.
shortcuts
.
map
(
shortcut
=
>
external_React_default
(
)
.
createElement
(
SelectableSearchShortcut
{
key
:
shortcut
.
keyword
shortcut
:
shortcut
selected
:
shortcut
.
isSelected
onChange
:
this
.
handleChange
}
)
)
)
)
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
cancel
"
type
:
"
button
"
onClick
:
this
.
onCancelButtonClick
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
cancel
-
button
"
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
"
type
:
"
submit
"
onClick
:
this
.
onSaveButtonClick
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
save
-
button
"
}
)
)
)
;
}
}
;
class
Dedupe
{
constructor
(
createKey
)
{
this
.
createKey
=
createKey
|
|
this
.
defaultCreateKey
;
}
defaultCreateKey
(
item
)
{
return
item
;
}
group
(
.
.
.
groups
)
{
const
globalKeys
=
new
Set
(
)
;
const
result
=
[
]
;
for
(
const
values
of
groups
)
{
const
valueMap
=
new
Map
(
)
;
for
(
const
value
of
values
)
{
const
key
=
this
.
createKey
(
value
)
;
if
(
!
globalKeys
.
has
(
key
)
&
&
!
valueMap
.
has
(
key
)
)
{
valueMap
.
set
(
key
value
)
;
}
}
result
.
push
(
valueMap
)
;
valueMap
.
forEach
(
(
value
key
)
=
>
globalKeys
.
add
(
key
)
)
;
}
return
result
.
map
(
m
=
>
Array
.
from
(
m
.
values
(
)
)
)
;
}
}
;
const
TOP_SITES_DEFAULT_ROWS
=
1
;
const
TOP_SITES_MAX_SITES_PER_ROW
=
8
;
const
PREF_COLLECTION_DISMISSIBLE
=
"
discoverystream
.
isCollectionDismissible
"
;
const
dedupe
=
new
Dedupe
(
site
=
>
site
&
&
site
.
url
)
;
const
INITIAL_STATE
=
{
App
:
{
initialized
:
false
locale
:
"
"
}
ASRouter
:
{
initialized
:
false
}
Snippets
:
{
initialized
:
false
}
TopSites
:
{
initialized
:
false
rows
:
[
]
editForm
:
null
showSearchShortcutsForm
:
false
searchShortcuts
:
[
]
}
Prefs
:
{
initialized
:
false
values
:
{
featureConfig
:
{
}
}
}
Dialog
:
{
visible
:
false
data
:
{
}
}
Sections
:
[
]
Pocket
:
{
isUserLoggedIn
:
null
pocketCta
:
{
}
waitingForSpoc
:
true
}
DiscoveryStream
:
{
config
:
{
enabled
:
false
layout_endpoint
:
"
"
}
layout
:
[
]
lastUpdated
:
null
isPrivacyInfoModalVisible
:
false
isCollectionDismissible
:
false
feeds
:
{
data
:
{
}
loaded
:
false
}
spocs
:
{
spocs_endpoint
:
"
"
lastUpdated
:
null
data
:
{
}
loaded
:
false
frequency_caps
:
[
]
blocked
:
[
]
placements
:
[
]
}
experimentData
:
{
utmSource
:
"
pocket
-
newtab
"
utmCampaign
:
undefined
utmContent
:
undefined
}
recentSavesData
:
[
]
isUserLoggedIn
:
false
recentSavesEnabled
:
false
}
Personalization
:
{
lastUpdated
:
null
initialized
:
false
}
Search
:
{
fakeFocus
:
false
hide
:
false
}
}
;
function
App
(
prevState
=
INITIAL_STATE
.
App
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
INIT
:
return
Object
.
assign
(
{
}
prevState
action
.
data
|
|
{
}
{
initialized
:
true
}
)
;
default
:
return
prevState
;
}
}
function
ASRouter
(
prevState
=
INITIAL_STATE
.
ASRouter
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
AS_ROUTER_INITIALIZED
:
return
{
.
.
.
action
.
data
initialized
:
true
}
;
default
:
return
prevState
;
}
}
function
insertPinned
(
links
pinned
)
{
const
pinnedUrls
=
pinned
.
map
(
link
=
>
link
&
&
link
.
url
)
;
let
newLinks
=
links
.
filter
(
link
=
>
link
?
!
pinnedUrls
.
includes
(
link
.
url
)
:
false
)
;
newLinks
=
newLinks
.
map
(
link
=
>
{
if
(
link
&
&
link
.
isPinned
)
{
delete
link
.
isPinned
;
delete
link
.
pinIndex
;
}
return
link
;
}
)
;
pinned
.
forEach
(
(
val
index
)
=
>
{
if
(
!
val
)
{
return
;
}
let
link
=
Object
.
assign
(
{
}
val
{
isPinned
:
true
pinIndex
:
index
}
)
;
if
(
index
>
newLinks
.
length
)
{
newLinks
[
index
]
=
link
;
}
else
{
newLinks
.
splice
(
index
0
link
)
;
}
}
)
;
return
newLinks
;
}
function
TopSites
(
prevState
=
INITIAL_STATE
.
TopSites
action
)
{
let
hasMatch
;
let
newRows
;
switch
(
action
.
type
)
{
case
actionTypes
.
TOP_SITES_UPDATED
:
if
(
!
action
.
data
|
|
!
action
.
data
.
links
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
rows
:
action
.
data
.
links
}
action
.
data
.
pref
?
{
pref
:
action
.
data
.
pref
}
:
{
}
)
;
case
actionTypes
.
TOP_SITES_PREFS_UPDATED
:
return
Object
.
assign
(
{
}
prevState
{
pref
:
action
.
data
.
pref
}
)
;
case
actionTypes
.
TOP_SITES_EDIT
:
return
Object
.
assign
(
{
}
prevState
{
editForm
:
{
index
:
action
.
data
.
index
previewResponse
:
null
}
}
)
;
case
actionTypes
.
TOP_SITES_CANCEL_EDIT
:
return
Object
.
assign
(
{
}
prevState
{
editForm
:
null
}
)
;
case
actionTypes
.
TOP_SITES_OPEN_SEARCH_SHORTCUTS_MODAL
:
return
Object
.
assign
(
{
}
prevState
{
showSearchShortcutsForm
:
true
}
)
;
case
actionTypes
.
TOP_SITES_CLOSE_SEARCH_SHORTCUTS_MODAL
:
return
Object
.
assign
(
{
}
prevState
{
showSearchShortcutsForm
:
false
}
)
;
case
actionTypes
.
PREVIEW_RESPONSE
:
if
(
!
prevState
.
editForm
|
|
action
.
data
.
url
!
=
=
prevState
.
editForm
.
previewUrl
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
editForm
:
{
index
:
prevState
.
editForm
.
index
previewResponse
:
action
.
data
.
preview
previewUrl
:
action
.
data
.
url
}
}
)
;
case
actionTypes
.
PREVIEW_REQUEST
:
if
(
!
prevState
.
editForm
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
editForm
:
{
index
:
prevState
.
editForm
.
index
previewResponse
:
null
previewUrl
:
action
.
data
.
url
}
}
)
;
case
actionTypes
.
PREVIEW_REQUEST_CANCEL
:
if
(
!
prevState
.
editForm
)
{
return
prevState
;
}
return
Object
.
assign
(
{
}
prevState
{
editForm
:
{
index
:
prevState
.
editForm
.
index
previewResponse
:
null
}
}
)
;
case
actionTypes
.
SCREENSHOT_UPDATED
:
newRows
=
prevState
.
rows
.
map
(
row
=
>
{
if
(
row
&
&
row
.
url
=
=
=
action
.
data
.
url
)
{
hasMatch
=
true
;
return
Object
.
assign
(
{
}
row
{
screenshot
:
action
.
data
.
screenshot
}
)
;
}
return
row
;
}
)
;
return
hasMatch
?
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
:
prevState
;
case
actionTypes
.
PLACES_BOOKMARK_ADDED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
newRows
=
prevState
.
rows
.
map
(
site
=
>
{
if
(
site
&
&
site
.
url
=
=
=
action
.
data
.
url
)
{
const
{
bookmarkGuid
bookmarkTitle
dateAdded
}
=
action
.
data
;
return
Object
.
assign
(
{
}
site
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
dateAdded
}
)
;
}
return
site
;
}
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
actionTypes
.
PLACES_BOOKMARKS_REMOVED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
newRows
=
prevState
.
rows
.
map
(
site
=
>
{
if
(
site
&
&
action
.
data
.
urls
.
includes
(
site
.
url
)
)
{
const
newSite
=
Object
.
assign
(
{
}
site
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
return
newSite
;
}
return
site
;
}
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
actionTypes
.
PLACES_LINKS_DELETED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
newRows
=
prevState
.
rows
.
filter
(
site
=
>
!
action
.
data
.
urls
.
includes
(
site
.
url
)
)
;
return
Object
.
assign
(
{
}
prevState
{
rows
:
newRows
}
)
;
case
actionTypes
.
UPDATE_SEARCH_SHORTCUTS
:
return
{
.
.
.
prevState
searchShortcuts
:
action
.
data
.
searchShortcuts
}
;
case
actionTypes
.
SNIPPETS_PREVIEW_MODE
:
return
{
.
.
.
prevState
rows
:
[
]
}
;
default
:
return
prevState
;
}
}
function
Dialog
(
prevState
=
INITIAL_STATE
.
Dialog
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
DIALOG_OPEN
:
return
Object
.
assign
(
{
}
prevState
{
visible
:
true
data
:
action
.
data
}
)
;
case
actionTypes
.
DIALOG_CANCEL
:
return
Object
.
assign
(
{
}
prevState
{
visible
:
false
}
)
;
case
actionTypes
.
DELETE_HISTORY_URL
:
return
Object
.
assign
(
{
}
INITIAL_STATE
.
Dialog
)
;
default
:
return
prevState
;
}
}
function
Prefs
(
prevState
=
INITIAL_STATE
.
Prefs
action
)
{
let
newValues
;
switch
(
action
.
type
)
{
case
actionTypes
.
PREFS_INITIAL_VALUES
:
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
values
:
action
.
data
}
)
;
case
actionTypes
.
PREF_CHANGED
:
newValues
=
Object
.
assign
(
{
}
prevState
.
values
)
;
newValues
[
action
.
data
.
name
]
=
action
.
data
.
value
;
return
Object
.
assign
(
{
}
prevState
{
values
:
newValues
}
)
;
default
:
return
prevState
;
}
}
function
Sections
(
prevState
=
INITIAL_STATE
.
Sections
action
)
{
let
hasMatch
;
let
newState
;
switch
(
action
.
type
)
{
case
actionTypes
.
SECTION_DEREGISTER
:
return
prevState
.
filter
(
section
=
>
section
.
id
!
=
=
action
.
data
)
;
case
actionTypes
.
SECTION_REGISTER
:
newState
=
prevState
.
map
(
section
=
>
{
if
(
section
&
&
section
.
id
=
=
=
action
.
data
.
id
)
{
hasMatch
=
true
;
return
Object
.
assign
(
{
}
section
action
.
data
)
;
}
return
section
;
}
)
;
if
(
!
hasMatch
)
{
const
initialized
=
!
!
(
action
.
data
.
rows
&
&
!
!
action
.
data
.
rows
.
length
)
;
const
section
=
Object
.
assign
(
{
title
:
"
"
rows
:
[
]
enabled
:
false
}
action
.
data
{
initialized
}
)
;
newState
.
push
(
section
)
;
}
return
newState
;
case
actionTypes
.
SECTION_UPDATE
:
newState
=
prevState
.
map
(
section
=
>
{
if
(
section
&
&
section
.
id
=
=
=
action
.
data
.
id
)
{
const
initialized
=
action
.
data
.
rows
?
{
initialized
:
true
}
:
{
}
;
if
(
action
.
data
.
rows
&
&
!
!
action
.
data
.
rows
.
length
&
&
section
.
rows
.
find
(
card
=
>
card
.
pinned
)
)
{
const
rows
=
Array
.
from
(
action
.
data
.
rows
)
;
section
.
rows
.
forEach
(
(
card
index
)
=
>
{
if
(
card
.
pinned
)
{
if
(
rows
[
index
]
.
guid
!
=
=
card
.
guid
)
{
rows
.
splice
(
index
0
card
)
;
}
}
}
)
;
return
Object
.
assign
(
{
}
section
initialized
Object
.
assign
(
{
}
action
.
data
{
rows
}
)
)
;
}
return
Object
.
assign
(
{
}
section
initialized
action
.
data
)
;
}
return
section
;
}
)
;
if
(
!
action
.
data
.
dedupeConfigurations
)
{
return
newState
;
}
action
.
data
.
dedupeConfigurations
.
forEach
(
dedupeConf
=
>
{
newState
=
newState
.
map
(
section
=
>
{
if
(
section
.
id
=
=
=
dedupeConf
.
id
)
{
const
dedupedRows
=
dedupeConf
.
dedupeFrom
.
reduce
(
(
rows
dedupeSectionId
)
=
>
{
const
dedupeSection
=
newState
.
find
(
s
=
>
s
.
id
=
=
=
dedupeSectionId
)
;
const
[
newRows
]
=
dedupe
.
group
(
dedupeSection
.
rows
rows
)
;
return
newRows
;
}
section
.
rows
)
;
return
Object
.
assign
(
{
}
section
{
rows
:
dedupedRows
}
)
;
}
return
section
;
}
)
;
}
)
;
return
newState
;
case
actionTypes
.
SECTION_UPDATE_CARD
:
return
prevState
.
map
(
section
=
>
{
if
(
section
&
&
section
.
id
=
=
=
action
.
data
.
id
&
&
section
.
rows
)
{
const
newRows
=
section
.
rows
.
map
(
card
=
>
{
if
(
card
.
url
=
=
=
action
.
data
.
url
)
{
return
Object
.
assign
(
{
}
card
action
.
data
.
options
)
;
}
return
card
;
}
)
;
return
Object
.
assign
(
{
}
section
{
rows
:
newRows
}
)
;
}
return
section
;
}
)
;
case
actionTypes
.
PLACES_BOOKMARK_ADDED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
map
(
item
=
>
{
if
(
item
.
url
=
=
=
action
.
data
.
url
)
{
const
{
bookmarkGuid
bookmarkTitle
dateAdded
}
=
action
.
data
;
return
Object
.
assign
(
{
}
item
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
dateAdded
type
:
"
bookmark
"
}
)
;
}
return
item
;
}
)
}
)
)
;
case
actionTypes
.
PLACES_SAVED_TO_POCKET
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
map
(
item
=
>
{
if
(
item
.
url
=
=
=
action
.
data
.
url
)
{
return
Object
.
assign
(
{
}
item
{
open_url
:
action
.
data
.
open_url
pocket_id
:
action
.
data
.
pocket_id
title
:
action
.
data
.
title
type
:
"
pocket
"
}
)
;
}
return
item
;
}
)
}
)
)
;
case
actionTypes
.
PLACES_BOOKMARKS_REMOVED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
map
(
item
=
>
{
if
(
action
.
data
.
urls
.
includes
(
item
.
url
)
)
{
const
newSite
=
Object
.
assign
(
{
}
item
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
if
(
!
newSite
.
type
|
|
newSite
.
type
=
=
=
"
bookmark
"
)
{
newSite
.
type
=
"
history
"
;
}
return
newSite
;
}
return
item
;
}
)
}
)
)
;
case
actionTypes
.
PLACES_LINKS_DELETED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
filter
(
site
=
>
!
action
.
data
.
urls
.
includes
(
site
.
url
)
)
}
)
)
;
case
actionTypes
.
PLACES_LINK_BLOCKED
:
if
(
!
action
.
data
)
{
return
prevState
;
}
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
filter
(
site
=
>
site
.
url
!
=
=
action
.
data
.
url
)
}
)
)
;
case
actionTypes
.
DELETE_FROM_POCKET
:
case
actionTypes
.
ARCHIVE_FROM_POCKET
:
return
prevState
.
map
(
section
=
>
Object
.
assign
(
{
}
section
{
rows
:
section
.
rows
.
filter
(
site
=
>
site
.
pocket_id
!
=
=
action
.
data
.
pocket_id
)
}
)
)
;
case
actionTypes
.
SNIPPETS_PREVIEW_MODE
:
return
prevState
.
map
(
section
=
>
(
{
.
.
.
section
rows
:
[
]
}
)
)
;
default
:
return
prevState
;
}
}
function
Snippets
(
prevState
=
INITIAL_STATE
.
Snippets
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
SNIPPETS_DATA
:
return
Object
.
assign
(
{
}
prevState
{
initialized
:
true
}
action
.
data
)
;
case
actionTypes
.
SNIPPET_BLOCKED
:
return
Object
.
assign
(
{
}
prevState
{
blockList
:
prevState
.
blockList
.
concat
(
action
.
data
)
}
)
;
case
actionTypes
.
SNIPPETS_BLOCKLIST_CLEARED
:
return
Object
.
assign
(
{
}
prevState
{
blockList
:
[
]
}
)
;
case
actionTypes
.
SNIPPETS_RESET
:
return
INITIAL_STATE
.
Snippets
;
default
:
return
prevState
;
}
}
function
Pocket
(
prevState
=
INITIAL_STATE
.
Pocket
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
POCKET_WAITING_FOR_SPOC
:
return
{
.
.
.
prevState
waitingForSpoc
:
action
.
data
}
;
case
actionTypes
.
POCKET_LOGGED_IN
:
return
{
.
.
.
prevState
isUserLoggedIn
:
!
!
action
.
data
}
;
case
actionTypes
.
POCKET_CTA
:
return
{
.
.
.
prevState
pocketCta
:
{
ctaButton
:
action
.
data
.
cta_button
ctaText
:
action
.
data
.
cta_text
ctaUrl
:
action
.
data
.
cta_url
useCta
:
action
.
data
.
use_cta
}
}
;
default
:
return
prevState
;
}
}
function
Reducers_Personalization
(
prevState
=
INITIAL_STATE
.
Personalization
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
DISCOVERY_STREAM_PERSONALIZATION_LAST_UPDATED
:
return
{
.
.
.
prevState
lastUpdated
:
action
.
data
.
lastUpdated
}
;
case
actionTypes
.
DISCOVERY_STREAM_PERSONALIZATION_INIT
:
return
{
.
.
.
prevState
initialized
:
true
}
;
default
:
return
prevState
;
}
}
function
DiscoveryStream
(
prevState
=
INITIAL_STATE
.
DiscoveryStream
action
)
{
const
isNotReady
=
(
)
=
>
!
action
.
data
|
|
!
prevState
.
spocs
.
loaded
|
|
!
prevState
.
feeds
.
loaded
;
const
handlePlacements
=
handleSites
=
>
{
const
{
data
placements
}
=
prevState
.
spocs
;
const
result
=
{
}
;
const
forPlacement
=
placement
=
>
{
const
placementSpocs
=
data
[
placement
.
name
]
;
if
(
!
placementSpocs
|
|
!
placementSpocs
.
items
|
|
!
placementSpocs
.
items
.
length
)
{
return
;
}
result
[
placement
.
name
]
=
{
.
.
.
placementSpocs
items
:
handleSites
(
placementSpocs
.
items
)
}
;
}
;
if
(
!
placements
|
|
!
placements
.
length
)
{
[
{
name
:
"
spocs
"
}
]
.
forEach
(
forPlacement
)
;
}
else
{
placements
.
forEach
(
forPlacement
)
;
}
return
result
;
}
;
const
nextState
=
handleSites
=
>
(
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
data
:
handlePlacements
(
handleSites
)
}
feeds
:
{
.
.
.
prevState
.
feeds
data
:
Object
.
keys
(
prevState
.
feeds
.
data
)
.
reduce
(
(
accumulator
feed_url
)
=
>
{
accumulator
[
feed_url
]
=
{
data
:
{
.
.
.
prevState
.
feeds
.
data
[
feed_url
]
.
data
recommendations
:
handleSites
(
prevState
.
feeds
.
data
[
feed_url
]
.
data
.
recommendations
)
}
}
;
return
accumulator
;
}
{
}
)
}
}
)
;
switch
(
action
.
type
)
{
case
actionTypes
.
DISCOVERY_STREAM_CONFIG_CHANGE
:
case
actionTypes
.
DISCOVERY_STREAM_CONFIG_SETUP
:
return
{
.
.
.
prevState
config
:
action
.
data
|
|
{
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_EXPERIMENT_DATA
:
return
{
.
.
.
prevState
experimentData
:
action
.
data
|
|
{
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_LAYOUT_UPDATE
:
return
{
.
.
.
prevState
lastUpdated
:
action
.
data
.
lastUpdated
|
|
null
layout
:
action
.
data
.
layout
|
|
[
]
}
;
case
actionTypes
.
DISCOVERY_STREAM_COLLECTION_DISMISSIBLE_TOGGLE
:
return
{
.
.
.
prevState
isCollectionDismissible
:
action
.
data
.
value
}
;
case
actionTypes
.
DISCOVERY_STREAM_PREFS_SETUP
:
return
{
.
.
.
prevState
recentSavesEnabled
:
action
.
data
.
recentSavesEnabled
pocketButtonEnabled
:
action
.
data
.
pocketButtonEnabled
saveToPocketCard
:
action
.
data
.
saveToPocketCard
hideDescriptions
:
action
.
data
.
hideDescriptions
compactImages
:
action
.
data
.
compactImages
imageGradient
:
action
.
data
.
imageGradient
newSponsoredLabel
:
action
.
data
.
newSponsoredLabel
titleLines
:
action
.
data
.
titleLines
descLines
:
action
.
data
.
descLines
readTime
:
action
.
data
.
readTime
}
;
case
actionTypes
.
DISCOVERY_STREAM_RECENT_SAVES
:
return
{
.
.
.
prevState
recentSavesData
:
action
.
data
.
recentSaves
}
;
case
actionTypes
.
DISCOVERY_STREAM_POCKET_STATE_SET
:
return
{
.
.
.
prevState
isUserLoggedIn
:
action
.
data
.
isUserLoggedIn
}
;
case
actionTypes
.
HIDE_PRIVACY_INFO
:
return
{
.
.
.
prevState
isPrivacyInfoModalVisible
:
false
}
;
case
actionTypes
.
SHOW_PRIVACY_INFO
:
return
{
.
.
.
prevState
isPrivacyInfoModalVisible
:
true
}
;
case
actionTypes
.
DISCOVERY_STREAM_LAYOUT_RESET
:
return
{
.
.
.
INITIAL_STATE
.
DiscoveryStream
config
:
prevState
.
config
}
;
case
actionTypes
.
DISCOVERY_STREAM_FEEDS_UPDATE
:
return
{
.
.
.
prevState
feeds
:
{
.
.
.
prevState
.
feeds
loaded
:
true
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_FEED_UPDATE
:
const
newData
=
{
}
;
newData
[
action
.
data
.
url
]
=
action
.
data
.
feed
;
return
{
.
.
.
prevState
feeds
:
{
.
.
.
prevState
.
feeds
data
:
{
.
.
.
prevState
.
feeds
.
data
.
.
.
newData
}
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_CAPS
:
return
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
frequency_caps
:
[
.
.
.
prevState
.
spocs
.
frequency_caps
.
.
.
action
.
data
]
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_ENDPOINT
:
return
{
.
.
.
prevState
spocs
:
{
.
.
.
INITIAL_STATE
.
DiscoveryStream
.
spocs
spocs_endpoint
:
action
.
data
.
url
|
|
INITIAL_STATE
.
DiscoveryStream
.
spocs
.
spocs_endpoint
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_PLACEMENTS
:
return
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
placements
:
action
.
data
.
placements
|
|
INITIAL_STATE
.
DiscoveryStream
.
spocs
.
placements
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_SPOCS_UPDATE
:
if
(
action
.
data
)
{
return
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
lastUpdated
:
action
.
data
.
lastUpdated
data
:
action
.
data
.
spocs
loaded
:
true
}
}
;
}
return
prevState
;
case
actionTypes
.
DISCOVERY_STREAM_SPOC_BLOCKED
:
return
{
.
.
.
prevState
spocs
:
{
.
.
.
prevState
.
spocs
blocked
:
[
.
.
.
prevState
.
spocs
.
blocked
action
.
data
.
url
]
}
}
;
case
actionTypes
.
DISCOVERY_STREAM_LINK_BLOCKED
:
return
isNotReady
(
)
?
prevState
:
nextState
(
items
=
>
items
.
filter
(
item
=
>
item
.
url
!
=
=
action
.
data
.
url
)
)
;
case
actionTypes
.
PLACES_SAVED_TO_POCKET
:
const
addPocketInfo
=
item
=
>
{
if
(
item
.
url
=
=
=
action
.
data
.
url
)
{
return
Object
.
assign
(
{
}
item
{
open_url
:
action
.
data
.
open_url
pocket_id
:
action
.
data
.
pocket_id
context_type
:
"
pocket
"
}
)
;
}
return
item
;
}
;
return
isNotReady
(
)
?
prevState
:
nextState
(
items
=
>
items
.
map
(
addPocketInfo
)
)
;
case
actionTypes
.
DELETE_FROM_POCKET
:
case
actionTypes
.
ARCHIVE_FROM_POCKET
:
return
isNotReady
(
)
?
prevState
:
nextState
(
items
=
>
items
.
filter
(
item
=
>
item
.
pocket_id
!
=
=
action
.
data
.
pocket_id
)
)
;
case
actionTypes
.
PLACES_BOOKMARK_ADDED
:
const
updateBookmarkInfo
=
item
=
>
{
if
(
item
.
url
=
=
=
action
.
data
.
url
)
{
const
{
bookmarkGuid
bookmarkTitle
dateAdded
}
=
action
.
data
;
return
Object
.
assign
(
{
}
item
{
bookmarkGuid
bookmarkTitle
bookmarkDateCreated
:
dateAdded
context_type
:
"
bookmark
"
}
)
;
}
return
item
;
}
;
return
isNotReady
(
)
?
prevState
:
nextState
(
items
=
>
items
.
map
(
updateBookmarkInfo
)
)
;
case
actionTypes
.
PLACES_BOOKMARKS_REMOVED
:
const
removeBookmarkInfo
=
item
=
>
{
if
(
action
.
data
.
urls
.
includes
(
item
.
url
)
)
{
const
newSite
=
Object
.
assign
(
{
}
item
)
;
delete
newSite
.
bookmarkGuid
;
delete
newSite
.
bookmarkTitle
;
delete
newSite
.
bookmarkDateCreated
;
if
(
!
newSite
.
context_type
|
|
newSite
.
context_type
=
=
=
"
bookmark
"
)
{
newSite
.
context_type
=
"
removedBookmark
"
;
}
return
newSite
;
}
return
item
;
}
;
return
isNotReady
(
)
?
prevState
:
nextState
(
items
=
>
items
.
map
(
removeBookmarkInfo
)
)
;
case
actionTypes
.
PREF_CHANGED
:
if
(
action
.
data
.
name
=
=
=
PREF_COLLECTION_DISMISSIBLE
)
{
return
{
.
.
.
prevState
isCollectionDismissible
:
action
.
data
.
value
}
;
}
return
prevState
;
default
:
return
prevState
;
}
}
function
Search
(
prevState
=
INITIAL_STATE
.
Search
action
)
{
switch
(
action
.
type
)
{
case
actionTypes
.
DISABLE_SEARCH
:
return
Object
.
assign
(
{
.
.
.
prevState
disable
:
true
}
)
;
case
actionTypes
.
FAKE_FOCUS_SEARCH
:
return
Object
.
assign
(
{
.
.
.
prevState
fakeFocus
:
true
}
)
;
case
actionTypes
.
SHOW_SEARCH
:
return
Object
.
assign
(
{
.
.
.
prevState
disable
:
false
fakeFocus
:
false
}
)
;
default
:
return
prevState
;
}
}
const
reducers
=
{
TopSites
App
ASRouter
Snippets
Prefs
Dialog
Sections
Pocket
Personalization
:
Reducers_Personalization
DiscoveryStream
Search
}
;
;
class
TopSiteFormInput
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
validationError
:
this
.
props
.
validationError
}
;
this
.
onChange
=
this
.
onChange
.
bind
(
this
)
;
this
.
onMount
=
this
.
onMount
.
bind
(
this
)
;
this
.
onClearIconPress
=
this
.
onClearIconPress
.
bind
(
this
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
nextProps
.
shouldFocus
&
&
!
this
.
props
.
shouldFocus
)
{
this
.
input
.
focus
(
)
;
}
if
(
nextProps
.
validationError
&
&
!
this
.
props
.
validationError
)
{
this
.
setState
(
{
validationError
:
true
}
)
;
}
if
(
this
.
state
.
validationError
&
&
!
nextProps
.
value
)
{
this
.
setState
(
{
validationError
:
false
}
)
;
}
}
onClearIconPress
(
event
)
{
if
(
event
.
key
=
=
=
"
Enter
"
)
{
this
.
props
.
onClear
(
)
;
}
}
onChange
(
ev
)
{
if
(
this
.
state
.
validationError
)
{
this
.
setState
(
{
validationError
:
false
}
)
;
}
this
.
props
.
onChange
(
ev
)
;
}
onMount
(
input
)
{
this
.
input
=
input
;
}
renderLoadingOrCloseButton
(
)
{
const
showClearButton
=
this
.
props
.
value
&
&
this
.
props
.
onClear
;
if
(
this
.
props
.
loading
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
loading
-
container
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
loading
-
animation
"
}
)
)
;
}
else
if
(
showClearButton
)
{
return
external_React_default
(
)
.
createElement
(
"
button
"
{
type
:
"
button
"
className
:
"
icon
icon
-
clear
-
input
icon
-
button
-
style
"
onClick
:
this
.
props
.
onClear
onKeyPress
:
this
.
onClearIconPress
}
)
;
}
return
null
;
}
render
(
)
{
const
{
typeUrl
}
=
this
.
props
;
const
{
validationError
}
=
this
.
state
;
return
external_React_default
(
)
.
createElement
(
"
label
"
null
external_React_default
(
)
.
createElement
(
"
span
"
{
"
data
-
l10n
-
id
"
:
this
.
props
.
titleId
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
field
{
typeUrl
?
"
url
"
:
"
"
}
{
validationError
?
"
invalid
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
text
"
value
:
this
.
props
.
value
ref
:
this
.
onMount
onChange
:
this
.
onChange
"
data
-
l10n
-
id
"
:
this
.
props
.
placeholderId
autoFocus
:
this
.
props
.
shouldFocus
disabled
:
this
.
props
.
loading
}
)
this
.
renderLoadingOrCloseButton
(
)
validationError
&
&
external_React_default
(
)
.
createElement
(
"
aside
"
{
className
:
"
error
-
tooltip
"
"
data
-
l10n
-
id
"
:
this
.
props
.
errorMessageId
}
)
)
)
;
}
}
TopSiteFormInput
.
defaultProps
=
{
showClearButton
:
false
value
:
"
"
validationError
:
false
}
;
;
const
TopSiteImpressionWrapper_VISIBLE
=
"
visible
"
;
const
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
const
TopSiteImpressionWrapper_INTERSECTION_RATIO
=
0
.
5
;
class
TopSiteImpressionWrapper
extends
(
external_React_default
(
)
)
.
PureComponent
{
_dispatchImpressionStats
(
)
{
const
{
tile
}
=
this
.
props
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOP_SITES_IMPRESSION_STATS
data
:
{
type
:
"
impression
"
.
.
.
tile
}
}
)
)
;
}
setImpressionObserverOrAddListener
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
dispatch
)
{
return
;
}
if
(
props
.
document
.
visibilityState
=
=
=
TopSiteImpressionWrapper_VISIBLE
)
{
this
.
setImpressionObserver
(
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
props
.
document
.
removeEventListener
(
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
props
.
document
.
visibilityState
=
=
=
TopSiteImpressionWrapper_VISIBLE
)
{
this
.
setImpressionObserver
(
)
;
props
.
document
.
removeEventListener
(
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
props
.
document
.
addEventListener
(
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
setImpressionObserver
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
tile
)
{
return
;
}
this
.
_handleIntersect
=
entries
=
>
{
if
(
entries
.
some
(
entry
=
>
entry
.
isIntersecting
&
&
entry
.
intersectionRatio
>
=
TopSiteImpressionWrapper_INTERSECTION_RATIO
)
)
{
this
.
_dispatchImpressionStats
(
)
;
this
.
impressionObserver
.
unobserve
(
this
.
refs
.
topsite_impression_wrapper
)
;
}
}
;
const
options
=
{
threshold
:
TopSiteImpressionWrapper_INTERSECTION_RATIO
}
;
this
.
impressionObserver
=
new
props
.
IntersectionObserver
(
this
.
_handleIntersect
options
)
;
this
.
impressionObserver
.
observe
(
this
.
refs
.
topsite_impression_wrapper
)
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
tile
)
{
this
.
setImpressionObserverOrAddListener
(
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
_handleIntersect
&
&
this
.
impressionObserver
)
{
this
.
impressionObserver
.
unobserve
(
this
.
refs
.
topsite_impression_wrapper
)
;
}
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
TopSiteImpressionWrapper_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
ref
:
"
topsite_impression_wrapper
"
className
:
"
topsite
-
impression
-
observer
"
}
this
.
props
.
children
)
;
}
}
TopSiteImpressionWrapper
.
defaultProps
=
{
IntersectionObserver
:
__webpack_require__
.
g
.
IntersectionObserver
document
:
__webpack_require__
.
g
.
document
tile
:
null
}
;
;
function
TopSite_extends
(
)
{
TopSite_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
TopSite_extends
.
apply
(
this
arguments
)
;
}
const
SPOC_TYPE
=
"
SPOC
"
;
const
NEWTAB_SOURCE
=
"
newtab
"
;
class
TopSiteLink
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
screenshotImage
:
null
}
;
this
.
onDragEvent
=
this
.
onDragEvent
.
bind
(
this
)
;
this
.
onKeyPress
=
this
.
onKeyPress
.
bind
(
this
)
;
}
_allowDrop
(
e
)
{
return
(
this
.
dragged
|
|
!
this
.
props
.
link
.
sponsored_position
)
&
&
e
.
dataTransfer
.
types
.
includes
(
"
text
/
topsite
-
index
"
)
;
}
onDragEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
click
"
:
if
(
this
.
dragged
)
{
event
.
preventDefault
(
)
;
}
break
;
case
"
dragstart
"
:
event
.
target
.
blur
(
)
;
if
(
this
.
props
.
link
.
sponsored_position
)
{
event
.
preventDefault
(
)
;
break
;
}
this
.
dragged
=
true
;
event
.
dataTransfer
.
effectAllowed
=
"
move
"
;
event
.
dataTransfer
.
setData
(
"
text
/
topsite
-
index
"
this
.
props
.
index
)
;
this
.
props
.
onDragEvent
(
event
this
.
props
.
index
this
.
props
.
link
this
.
props
.
title
)
;
break
;
case
"
dragend
"
:
this
.
props
.
onDragEvent
(
event
)
;
break
;
case
"
dragenter
"
:
case
"
dragover
"
:
case
"
drop
"
:
if
(
this
.
_allowDrop
(
event
)
)
{
event
.
preventDefault
(
)
;
this
.
props
.
onDragEvent
(
event
this
.
props
.
index
)
;
}
break
;
case
"
mousedown
"
:
if
(
event
.
button
=
=
=
1
&
&
this
.
props
.
link
.
searchTopSite
)
{
event
.
preventDefault
(
)
;
}
this
.
dragged
=
false
;
break
;
}
}
static
getNextStateFromProps
(
nextProps
prevState
)
{
const
{
screenshot
}
=
nextProps
.
link
;
const
imageInState
=
ScreenshotUtils
.
isRemoteImageLocal
(
prevState
.
screenshotImage
screenshot
)
;
if
(
imageInState
)
{
return
null
;
}
ScreenshotUtils
.
maybeRevokeBlobObjectURL
(
prevState
.
screenshotImage
)
;
return
{
screenshotImage
:
ScreenshotUtils
.
createLocalImageObject
(
screenshot
)
}
;
}
componentWillMount
(
)
{
const
nextState
=
TopSiteLink
.
getNextStateFromProps
(
this
.
props
this
.
state
)
;
if
(
nextState
)
{
this
.
setState
(
nextState
)
;
}
}
componentWillReceiveProps
(
nextProps
)
{
const
nextState
=
TopSiteLink
.
getNextStateFromProps
(
nextProps
this
.
state
)
;
if
(
nextState
)
{
this
.
setState
(
nextState
)
;
}
}
componentWillUnmount
(
)
{
ScreenshotUtils
.
maybeRevokeBlobObjectURL
(
this
.
state
.
screenshotImage
)
;
}
onKeyPress
(
event
)
{
if
(
this
.
props
.
link
.
searchTopSite
&
&
event
.
key
=
=
=
"
Enter
"
)
{
this
.
props
.
onClick
(
event
)
;
}
}
generateColor
(
)
{
let
{
title
colors
}
=
this
.
props
;
if
(
!
colors
)
{
return
"
"
;
}
let
colorArray
=
colors
.
split
(
"
"
)
;
const
hashStr
=
str
=
>
{
let
hash
=
0
;
for
(
let
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
let
charCode
=
str
.
charCodeAt
(
i
)
;
hash
+
=
charCode
;
}
return
hash
;
}
;
let
hash
=
hashStr
(
title
)
;
let
index
=
hash
%
colorArray
.
length
;
return
colorArray
[
index
]
;
}
calculateStyle
(
)
{
const
{
defaultStyle
link
}
=
this
.
props
;
const
{
tippyTopIcon
faviconSize
}
=
link
;
let
imageClassName
;
let
imageStyle
;
let
showSmallFavicon
=
false
;
let
smallFaviconStyle
;
let
hasScreenshotImage
=
this
.
state
.
screenshotImage
&
&
this
.
state
.
screenshotImage
.
url
;
let
selectedColor
;
if
(
defaultStyle
)
{
selectedColor
=
this
.
generateColor
(
)
;
}
else
if
(
link
.
searchTopSite
)
{
imageClassName
=
"
top
-
site
-
icon
rich
-
icon
"
;
imageStyle
=
{
backgroundColor
:
link
.
backgroundColor
backgroundImage
:
url
(
{
tippyTopIcon
}
)
}
;
smallFaviconStyle
=
{
backgroundImage
:
url
(
{
tippyTopIcon
}
)
}
;
}
else
if
(
link
.
customScreenshotURL
)
{
const
spocImgURL
=
link
.
type
=
=
=
SPOC_TYPE
?
link
.
customScreenshotURL
:
"
"
;
imageClassName
=
"
top
-
site
-
icon
rich
-
icon
"
;
imageStyle
=
{
backgroundColor
:
link
.
backgroundColor
backgroundImage
:
hasScreenshotImage
?
url
(
{
this
.
state
.
screenshotImage
.
url
}
)
:
url
(
{
spocImgURL
}
)
}
;
}
else
if
(
tippyTopIcon
|
|
faviconSize
>
=
MIN_RICH_FAVICON_SIZE
)
{
imageClassName
=
"
top
-
site
-
icon
rich
-
icon
"
;
imageStyle
=
{
backgroundColor
:
link
.
backgroundColor
backgroundImage
:
url
(
{
tippyTopIcon
|
|
link
.
favicon
}
)
}
;
}
else
if
(
faviconSize
>
=
MIN_SMALL_FAVICON_SIZE
)
{
showSmallFavicon
=
true
;
smallFaviconStyle
=
{
backgroundImage
:
url
(
{
link
.
favicon
}
)
}
;
}
else
{
selectedColor
=
this
.
generateColor
(
)
;
imageClassName
=
"
"
;
}
return
{
showSmallFavicon
smallFaviconStyle
imageStyle
imageClassName
selectedColor
}
;
}
render
(
)
{
const
{
children
className
isDraggable
link
onClick
title
}
=
this
.
props
;
const
topSiteOuterClassName
=
top
-
site
-
outer
{
className
?
{
className
}
:
"
"
}
{
link
.
isDragged
?
"
dragged
"
:
"
"
}
{
link
.
searchTopSite
?
"
search
-
shortcut
"
:
"
"
}
;
const
[
letterFallback
]
=
title
;
const
{
showSmallFavicon
smallFaviconStyle
imageStyle
imageClassName
selectedColor
}
=
this
.
calculateStyle
(
)
;
let
draggableProps
=
{
}
;
if
(
isDraggable
)
{
draggableProps
=
{
onClick
:
this
.
onDragEvent
onDragEnd
:
this
.
onDragEvent
onDragStart
:
this
.
onDragEvent
onMouseDown
:
this
.
onDragEvent
}
;
}
return
external_React_default
(
)
.
createElement
(
"
li
"
TopSite_extends
(
{
className
:
topSiteOuterClassName
onDrop
:
this
.
onDragEvent
onDragOver
:
this
.
onDragEvent
onDragEnter
:
this
.
onDragEvent
onDragLeave
:
this
.
onDragEvent
}
draggableProps
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
inner
"
}
external_React_default
(
)
.
createElement
(
"
a
"
{
className
:
"
top
-
site
-
button
"
href
:
link
.
searchTopSite
?
undefined
:
link
.
url
tabIndex
:
"
0
"
onKeyPress
:
this
.
onKeyPress
onClick
:
onClick
draggable
:
true
"
data
-
is
-
sponsored
-
link
"
:
!
!
link
.
sponsored_tile_id
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
tile
"
"
aria
-
hidden
"
:
true
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
selectedColor
?
"
icon
-
wrapper
letter
-
fallback
"
:
"
icon
-
wrapper
"
"
data
-
fallback
"
:
letterFallback
style
:
selectedColor
?
{
backgroundColor
:
selectedColor
}
:
{
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
imageClassName
style
:
imageStyle
}
)
showSmallFavicon
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
icon
default
-
icon
"
"
data
-
fallback
"
:
smallFaviconStyle
?
"
"
:
letterFallback
style
:
smallFaviconStyle
}
)
)
link
.
searchTopSite
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
site
-
icon
search
-
topsite
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
title
{
link
.
isPinned
?
"
has
-
icon
pinned
"
:
"
"
}
{
link
.
type
=
=
=
SPOC_TYPE
|
|
link
.
show_sponsored_label
?
"
sponsored
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
"
span
"
{
dir
:
"
auto
"
}
link
.
isPinned
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
icon
icon
-
pin
-
small
"
}
)
title
|
|
external_React_default
(
)
.
createElement
(
"
br
"
null
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
sponsored
-
label
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topsite
-
sponsored
"
}
)
)
)
)
children
link
.
type
=
=
=
SPOC_TYPE
?
external_React_default
(
)
.
createElement
(
ImpressionStats_ImpressionStats
{
flightId
:
link
.
flightId
rows
:
[
{
id
:
link
.
id
pos
:
link
.
pos
shim
:
link
.
shim
&
&
link
.
shim
.
impression
}
]
dispatch
:
this
.
props
.
dispatch
source
:
TOP_SITES_SOURCE
}
)
:
null
link
.
sponsored_position
?
external_React_default
(
)
.
createElement
(
TopSiteImpressionWrapper
{
tile
:
{
position
:
this
.
props
.
index
+
1
tile_id
:
link
.
sponsored_tile_id
|
|
-
1
reporting_url
:
link
.
sponsored_impression_url
advertiser
:
title
.
toLocaleLowerCase
(
)
source
:
NEWTAB_SOURCE
}
dispatch
:
this
.
props
.
dispatch
}
)
:
null
)
)
;
}
}
TopSiteLink
.
defaultProps
=
{
title
:
"
"
link
:
{
}
isDraggable
:
true
}
;
class
TopSite
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
showContextMenu
:
false
}
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
this
.
onMenuUpdate
=
this
.
onMenuUpdate
.
bind
(
this
)
;
}
_getTelemetryInfo
(
)
{
const
value
=
{
icon_type
:
this
.
props
.
link
.
iconType
}
;
if
(
this
.
props
.
link
.
isPinned
)
{
value
.
card_type
=
"
pinned
"
;
}
if
(
this
.
props
.
link
.
searchTopSite
)
{
value
.
card_type
=
"
search
"
;
value
.
search_vendor
=
this
.
props
.
link
.
hostname
;
}
if
(
this
.
props
.
link
.
type
=
=
=
SPOC_TYPE
|
|
this
.
props
.
link
.
sponsored_position
)
{
value
.
card_type
=
"
spoc
"
;
}
return
{
value
}
;
}
userEvent
(
event
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
Object
.
assign
(
{
event
source
:
TOP_SITES_SOURCE
action_position
:
this
.
props
.
index
}
this
.
_getTelemetryInfo
(
)
)
)
)
;
}
onLinkClick
(
event
)
{
this
.
userEvent
(
"
CLICK
"
)
;
event
.
preventDefault
(
)
;
const
{
altKey
button
ctrlKey
metaKey
shiftKey
}
=
event
;
if
(
!
this
.
props
.
link
.
searchTopSite
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
OPEN_LINK
data
:
Object
.
assign
(
this
.
props
.
link
{
event
:
{
altKey
button
ctrlKey
metaKey
shiftKey
}
}
)
}
)
)
;
if
(
this
.
props
.
link
.
type
=
=
=
SPOC_TYPE
)
{
this
.
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
TOP_SITES_SOURCE
click
:
0
tiles
:
[
{
id
:
this
.
props
.
link
.
id
pos
:
this
.
props
.
link
.
pos
shim
:
this
.
props
.
link
.
shim
&
&
this
.
props
.
link
.
shim
.
click
}
]
}
)
)
;
}
if
(
this
.
props
.
link
.
sendAttributionRequest
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
PARTNER_LINK_ATTRIBUTION
data
:
{
targetURL
:
this
.
props
.
link
.
url
source
:
"
newtab
"
}
}
)
)
;
}
if
(
this
.
props
.
link
.
sponsored_position
)
{
const
title
=
this
.
props
.
link
.
label
|
|
this
.
props
.
link
.
hostname
;
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
TOP_SITES_IMPRESSION_STATS
data
:
{
type
:
"
click
"
position
:
this
.
props
.
index
+
1
tile_id
:
this
.
props
.
link
.
sponsored_tile_id
|
|
-
1
reporting_url
:
this
.
props
.
link
.
sponsored_click_url
advertiser
:
title
.
toLocaleLowerCase
(
)
source
:
NEWTAB_SOURCE
}
}
)
)
;
}
}
else
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
FILL_SEARCH_TERM
data
:
{
label
:
this
.
props
.
link
.
label
}
}
)
)
;
}
}
onMenuUpdate
(
isOpen
)
{
if
(
isOpen
)
{
this
.
props
.
onActivate
(
this
.
props
.
index
)
;
}
else
{
this
.
props
.
onActivate
(
)
;
}
}
render
(
)
{
const
{
props
}
=
this
;
const
{
link
}
=
props
;
const
isContextMenuOpen
=
props
.
activeIndex
=
=
=
props
.
index
;
const
title
=
link
.
label
|
|
link
.
hostname
;
let
menuOptions
;
if
(
link
.
sponsored_position
)
{
menuOptions
=
TOP_SITES_SPONSORED_POSITION_CONTEXT_MENU_OPTIONS
;
}
else
if
(
link
.
searchTopSite
)
{
menuOptions
=
TOP_SITES_SEARCH_SHORTCUTS_CONTEXT_MENU_OPTIONS
;
}
else
if
(
link
.
type
=
=
=
SPOC_TYPE
)
{
menuOptions
=
TOP_SITES_SPOC_CONTEXT_MENU_OPTIONS
;
}
else
{
menuOptions
=
TOP_SITES_CONTEXT_MENU_OPTIONS
;
}
return
external_React_default
(
)
.
createElement
(
TopSiteLink
TopSite_extends
(
{
}
props
{
onClick
:
this
.
onLinkClick
onDragEvent
:
this
.
props
.
onDragEvent
className
:
{
props
.
className
|
|
"
"
}
{
isContextMenuOpen
?
"
active
"
:
"
"
}
title
:
title
}
)
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
ContextMenuButton
{
tooltip
:
"
newtab
-
menu
-
content
-
tooltip
"
tooltipArgs
:
{
title
}
onUpdate
:
this
.
onMenuUpdate
}
external_React_default
(
)
.
createElement
(
LinkMenu
{
dispatch
:
props
.
dispatch
index
:
props
.
index
onUpdate
:
this
.
onMenuUpdate
options
:
menuOptions
site
:
link
shouldSendImpressionStats
:
link
.
type
=
=
=
SPOC_TYPE
siteInfo
:
this
.
_getTelemetryInfo
(
)
source
:
TOP_SITES_SOURCE
}
)
)
)
)
;
}
}
TopSite
.
defaultProps
=
{
link
:
{
}
onActivate
(
)
{
}
}
;
class
TopSitePlaceholder
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onEditButtonClick
=
this
.
onEditButtonClick
.
bind
(
this
)
;
}
onEditButtonClick
(
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
TOP_SITES_EDIT
data
:
{
index
:
this
.
props
.
index
}
}
)
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
TopSiteLink
TopSite_extends
(
{
}
this
.
props
{
className
:
placeholder
{
this
.
props
.
className
|
|
"
"
}
isDraggable
:
false
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
"
aria
-
haspopup
"
:
"
true
"
className
:
"
context
-
menu
-
button
edit
-
button
icon
"
"
data
-
l10n
-
id
"
:
"
newtab
-
menu
-
topsites
-
placeholder
-
tooltip
"
onClick
:
this
.
onEditButtonClick
}
)
)
;
}
}
class
TopSiteList
extends
(
external_React_default
(
)
)
.
PureComponent
{
static
get
DEFAULT_STATE
(
)
{
return
{
activeIndex
:
null
draggedIndex
:
null
draggedSite
:
null
draggedTitle
:
null
topSitesPreview
:
null
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
TopSiteList
.
DEFAULT_STATE
;
this
.
onDragEvent
=
this
.
onDragEvent
.
bind
(
this
)
;
this
.
onActivate
=
this
.
onActivate
.
bind
(
this
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
this
.
state
.
draggedSite
)
{
const
prevTopSites
=
this
.
props
.
TopSites
&
&
this
.
props
.
TopSites
.
rows
;
const
newTopSites
=
nextProps
.
TopSites
&
&
nextProps
.
TopSites
.
rows
;
if
(
prevTopSites
&
&
prevTopSites
[
this
.
state
.
draggedIndex
]
&
&
prevTopSites
[
this
.
state
.
draggedIndex
]
.
url
=
=
=
this
.
state
.
draggedSite
.
url
&
&
(
!
newTopSites
[
this
.
state
.
draggedIndex
]
|
|
newTopSites
[
this
.
state
.
draggedIndex
]
.
url
!
=
=
this
.
state
.
draggedSite
.
url
)
)
{
this
.
setState
(
TopSiteList
.
DEFAULT_STATE
)
;
}
}
}
userEvent
(
event
index
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
source
:
TOP_SITES_SOURCE
action_position
:
index
}
)
)
;
}
onDragEvent
(
event
index
link
title
)
{
switch
(
event
.
type
)
{
case
"
dragstart
"
:
this
.
dropped
=
false
;
this
.
setState
(
{
draggedIndex
:
index
draggedSite
:
link
draggedTitle
:
title
activeIndex
:
null
}
)
;
this
.
userEvent
(
"
DRAG
"
index
)
;
break
;
case
"
dragend
"
:
if
(
!
this
.
dropped
)
{
this
.
setState
(
TopSiteList
.
DEFAULT_STATE
)
;
}
break
;
case
"
dragenter
"
:
if
(
index
=
=
=
this
.
state
.
draggedIndex
)
{
this
.
setState
(
{
topSitesPreview
:
null
}
)
;
}
else
{
this
.
setState
(
{
topSitesPreview
:
this
.
_makeTopSitesPreview
(
index
)
}
)
;
}
break
;
case
"
drop
"
:
if
(
index
!
=
=
this
.
state
.
draggedIndex
)
{
this
.
dropped
=
true
;
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOP_SITES_INSERT
data
:
{
site
:
{
url
:
this
.
state
.
draggedSite
.
url
label
:
this
.
state
.
draggedTitle
customScreenshotURL
:
this
.
state
.
draggedSite
.
customScreenshotURL
.
.
.
(
this
.
state
.
draggedSite
.
searchTopSite
&
&
{
searchTopSite
:
true
}
)
}
index
draggedFromIndex
:
this
.
state
.
draggedIndex
}
}
)
)
;
this
.
userEvent
(
"
DROP
"
index
)
;
}
break
;
}
}
_getTopSites
(
)
{
let
topSites
=
this
.
props
.
TopSites
.
rows
.
slice
(
)
;
topSites
.
length
=
this
.
props
.
TopSitesRows
*
TOP_SITES_MAX_SITES_PER_ROW
;
return
topSites
;
}
_makeTopSitesPreview
(
index
)
{
const
topSites
=
this
.
_getTopSites
(
)
;
topSites
[
this
.
state
.
draggedIndex
]
=
null
;
const
preview
=
topSites
.
map
(
site
=
>
site
&
&
(
site
.
isPinned
|
|
site
.
sponsored_position
)
?
site
:
null
)
;
const
unpinned
=
topSites
.
filter
(
site
=
>
site
&
&
!
site
.
isPinned
&
&
!
site
.
sponsored_position
)
;
const
siteToInsert
=
Object
.
assign
(
{
}
this
.
state
.
draggedSite
{
isPinned
:
true
isDragged
:
true
}
)
;
if
(
!
preview
[
index
]
)
{
preview
[
index
]
=
siteToInsert
;
}
else
{
let
holeIndex
=
index
;
const
indexStep
=
index
>
this
.
state
.
draggedIndex
?
-
1
:
1
;
while
(
preview
[
holeIndex
]
)
{
holeIndex
+
=
indexStep
;
}
const
shiftingStep
=
index
>
this
.
state
.
draggedIndex
?
1
:
-
1
;
while
(
index
>
this
.
state
.
draggedIndex
?
holeIndex
<
index
:
holeIndex
>
index
)
{
let
nextIndex
=
holeIndex
+
shiftingStep
;
while
(
preview
[
nextIndex
]
&
&
preview
[
nextIndex
]
.
sponsored_position
)
{
nextIndex
+
=
shiftingStep
;
}
preview
[
holeIndex
]
=
preview
[
nextIndex
]
;
holeIndex
=
nextIndex
;
}
preview
[
index
]
=
siteToInsert
;
}
for
(
let
i
=
0
;
i
<
preview
.
length
;
i
+
+
)
{
if
(
!
preview
[
i
]
)
{
preview
[
i
]
=
unpinned
.
shift
(
)
|
|
null
;
}
}
return
preview
;
}
onActivate
(
index
)
{
this
.
setState
(
{
activeIndex
:
index
}
)
;
}
render
(
)
{
const
{
props
}
=
this
;
const
topSites
=
this
.
state
.
topSitesPreview
|
|
this
.
_getTopSites
(
)
;
const
topSitesUI
=
[
]
;
const
commonProps
=
{
onDragEvent
:
this
.
onDragEvent
dispatch
:
props
.
dispatch
}
;
let
holeIndex
=
0
;
const
maxNarrowVisibleIndex
=
props
.
TopSitesRows
*
6
;
for
(
let
i
=
0
l
=
topSites
.
length
;
i
<
l
;
i
+
+
)
{
const
link
=
topSites
[
i
]
&
&
Object
.
assign
(
{
}
topSites
[
i
]
{
iconType
:
this
.
props
.
topSiteIconType
(
topSites
[
i
]
)
}
)
;
const
slotProps
=
{
key
:
link
?
link
.
url
:
holeIndex
+
+
index
:
i
}
;
if
(
i
>
=
maxNarrowVisibleIndex
)
{
slotProps
.
className
=
"
hide
-
for
-
narrow
"
;
}
topSitesUI
.
push
(
!
link
?
external_React_default
(
)
.
createElement
(
TopSitePlaceholder
TopSite_extends
(
{
}
slotProps
commonProps
)
)
:
external_React_default
(
)
.
createElement
(
TopSite
TopSite_extends
(
{
link
:
link
activeIndex
:
this
.
state
.
activeIndex
onActivate
:
this
.
onActivate
}
slotProps
commonProps
{
colors
:
props
.
colors
}
)
)
)
;
}
return
external_React_default
(
)
.
createElement
(
"
ul
"
{
className
:
top
-
sites
-
list
{
this
.
state
.
draggedSite
?
"
dnd
-
active
"
:
"
"
}
}
topSitesUI
)
;
}
}
;
class
TopSiteForm
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
const
{
site
}
=
props
;
this
.
state
=
{
label
:
site
?
site
.
label
|
|
site
.
hostname
:
"
"
url
:
site
?
site
.
url
:
"
"
validationError
:
false
customScreenshotUrl
:
site
?
site
.
customScreenshotURL
:
"
"
showCustomScreenshotForm
:
site
?
site
.
customScreenshotURL
:
false
}
;
this
.
onClearScreenshotInput
=
this
.
onClearScreenshotInput
.
bind
(
this
)
;
this
.
onLabelChange
=
this
.
onLabelChange
.
bind
(
this
)
;
this
.
onUrlChange
=
this
.
onUrlChange
.
bind
(
this
)
;
this
.
onCancelButtonClick
=
this
.
onCancelButtonClick
.
bind
(
this
)
;
this
.
onClearUrlClick
=
this
.
onClearUrlClick
.
bind
(
this
)
;
this
.
onDoneButtonClick
=
this
.
onDoneButtonClick
.
bind
(
this
)
;
this
.
onCustomScreenshotUrlChange
=
this
.
onCustomScreenshotUrlChange
.
bind
(
this
)
;
this
.
onPreviewButtonClick
=
this
.
onPreviewButtonClick
.
bind
(
this
)
;
this
.
onEnableScreenshotUrlForm
=
this
.
onEnableScreenshotUrlForm
.
bind
(
this
)
;
this
.
validateUrl
=
this
.
validateUrl
.
bind
(
this
)
;
}
onLabelChange
(
event
)
{
this
.
setState
(
{
label
:
event
.
target
.
value
}
)
;
}
onUrlChange
(
event
)
{
this
.
setState
(
{
url
:
event
.
target
.
value
validationError
:
false
}
)
;
}
onClearUrlClick
(
)
{
this
.
setState
(
{
url
:
"
"
validationError
:
false
}
)
;
}
onEnableScreenshotUrlForm
(
)
{
this
.
setState
(
{
showCustomScreenshotForm
:
true
}
)
;
}
_updateCustomScreenshotInput
(
customScreenshotUrl
)
{
this
.
setState
(
{
customScreenshotUrl
validationError
:
false
}
)
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
PREVIEW_REQUEST_CANCEL
}
)
;
}
onCustomScreenshotUrlChange
(
event
)
{
this
.
_updateCustomScreenshotInput
(
event
.
target
.
value
)
;
}
onClearScreenshotInput
(
)
{
this
.
_updateCustomScreenshotInput
(
"
"
)
;
}
onCancelButtonClick
(
ev
)
{
ev
.
preventDefault
(
)
;
this
.
props
.
onClose
(
)
;
}
onDoneButtonClick
(
ev
)
{
ev
.
preventDefault
(
)
;
if
(
this
.
validateForm
(
)
)
{
const
site
=
{
url
:
this
.
cleanUrl
(
this
.
state
.
url
)
}
;
const
{
index
}
=
this
.
props
;
if
(
this
.
state
.
label
!
=
=
"
"
)
{
site
.
label
=
this
.
state
.
label
;
}
if
(
this
.
state
.
customScreenshotUrl
)
{
site
.
customScreenshotURL
=
this
.
cleanUrl
(
this
.
state
.
customScreenshotUrl
)
;
}
else
if
(
this
.
props
.
site
&
&
this
.
props
.
site
.
customScreenshotURL
)
{
site
.
customScreenshotURL
=
null
;
}
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
TOP_SITES_PIN
data
:
{
site
index
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
TOP_SITES_EDIT
"
action_position
:
index
}
)
)
;
this
.
props
.
onClose
(
)
;
}
}
onPreviewButtonClick
(
event
)
{
event
.
preventDefault
(
)
;
if
(
this
.
validateForm
(
)
)
{
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
PREVIEW_REQUEST
data
:
{
url
:
this
.
cleanUrl
(
this
.
state
.
customScreenshotUrl
)
}
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
PREVIEW_REQUEST
"
}
)
)
;
}
}
cleanUrl
(
url
)
{
if
(
!
url
.
startsWith
(
"
http
:
"
)
&
&
!
url
.
startsWith
(
"
https
:
"
)
)
{
return
http
:
/
/
{
url
}
;
}
return
url
;
}
_tryParseUrl
(
url
)
{
try
{
return
new
URL
(
url
)
;
}
catch
(
e
)
{
return
null
;
}
}
validateUrl
(
url
)
{
const
validProtocols
=
[
"
http
:
"
"
https
:
"
]
;
const
urlObj
=
this
.
_tryParseUrl
(
url
)
|
|
this
.
_tryParseUrl
(
this
.
cleanUrl
(
url
)
)
;
return
urlObj
&
&
validProtocols
.
includes
(
urlObj
.
protocol
)
;
}
validateCustomScreenshotUrl
(
)
{
const
{
customScreenshotUrl
}
=
this
.
state
;
return
!
customScreenshotUrl
|
|
this
.
validateUrl
(
customScreenshotUrl
)
;
}
validateForm
(
)
{
const
validate
=
this
.
validateUrl
(
this
.
state
.
url
)
&
&
this
.
validateCustomScreenshotUrl
(
)
;
if
(
!
validate
)
{
this
.
setState
(
{
validationError
:
true
}
)
;
}
return
validate
;
}
_renderCustomScreenshotInput
(
)
{
const
{
customScreenshotUrl
}
=
this
.
state
;
const
requestFailed
=
this
.
props
.
previewResponse
=
=
=
"
"
;
const
validationError
=
this
.
state
.
validationError
&
&
!
this
.
validateCustomScreenshotUrl
(
)
|
|
requestFailed
;
const
shouldFocus
=
validationError
&
&
this
.
validateUrl
(
this
.
state
.
url
)
|
|
!
customScreenshotUrl
;
const
isLoading
=
this
.
props
.
previewResponse
=
=
=
null
&
&
customScreenshotUrl
&
&
this
.
props
.
previewUrl
=
=
=
this
.
cleanUrl
(
customScreenshotUrl
)
;
if
(
!
this
.
state
.
showCustomScreenshotForm
)
{
return
external_React_default
(
)
.
createElement
(
A11yLinkButton
{
onClick
:
this
.
onEnableScreenshotUrlForm
className
:
"
enable
-
custom
-
image
-
input
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
use
-
image
-
link
"
}
)
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
custom
-
image
-
input
-
container
"
}
external_React_default
(
)
.
createElement
(
TopSiteFormInput
{
errorMessageId
:
requestFailed
?
"
newtab
-
topsites
-
image
-
validation
"
:
"
newtab
-
topsites
-
url
-
validation
"
loading
:
isLoading
onChange
:
this
.
onCustomScreenshotUrlChange
onClear
:
this
.
onClearScreenshotInput
shouldFocus
:
shouldFocus
typeUrl
:
true
value
:
customScreenshotUrl
validationError
:
validationError
titleId
:
"
newtab
-
topsites
-
image
-
url
-
label
"
placeholderId
:
"
newtab
-
topsites
-
url
-
input
"
}
)
)
;
}
render
(
)
{
const
{
customScreenshotUrl
}
=
this
.
state
;
const
requestFailed
=
this
.
props
.
previewResponse
=
=
=
"
"
;
const
showAsAdd
=
!
this
.
props
.
site
;
const
previous
=
this
.
props
.
site
&
&
this
.
props
.
site
.
customScreenshotURL
|
|
"
"
;
const
changed
=
customScreenshotUrl
&
&
this
.
cleanUrl
(
customScreenshotUrl
)
!
=
=
previous
;
const
previewMode
=
changed
&
&
!
this
.
props
.
previewResponse
;
const
previewLink
=
Object
.
assign
(
{
}
this
.
props
.
site
)
;
if
(
this
.
props
.
previewResponse
)
{
previewLink
.
screenshot
=
this
.
props
.
previewResponse
;
previewLink
.
customScreenshotURL
=
this
.
props
.
previewUrl
;
}
const
onSubmit
=
previewMode
?
this
.
onPreviewButtonClick
:
this
.
onDoneButtonClick
;
const
addTopsitesHeaderL10nId
=
"
newtab
-
topsites
-
add
-
shortcut
-
header
"
;
const
editTopsitesHeaderL10nId
=
"
newtab
-
topsites
-
edit
-
shortcut
-
header
"
;
return
external_React_default
(
)
.
createElement
(
"
form
"
{
className
:
"
topsite
-
form
"
onSubmit
:
onSubmit
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
form
-
input
-
container
"
}
external_React_default
(
)
.
createElement
(
"
h3
"
{
className
:
"
section
-
title
grey
-
title
"
"
data
-
l10n
-
id
"
:
showAsAdd
?
addTopsitesHeaderL10nId
:
editTopsitesHeaderL10nId
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
fields
-
and
-
preview
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
form
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
TopSiteFormInput
{
onChange
:
this
.
onLabelChange
value
:
this
.
state
.
label
titleId
:
"
newtab
-
topsites
-
title
-
label
"
placeholderId
:
"
newtab
-
topsites
-
title
-
input
"
}
)
external_React_default
(
)
.
createElement
(
TopSiteFormInput
{
onChange
:
this
.
onUrlChange
shouldFocus
:
this
.
state
.
validationError
&
&
!
this
.
validateUrl
(
this
.
state
.
url
)
value
:
this
.
state
.
url
onClear
:
this
.
onClearUrlClick
validationError
:
this
.
state
.
validationError
&
&
!
this
.
validateUrl
(
this
.
state
.
url
)
titleId
:
"
newtab
-
topsites
-
url
-
label
"
typeUrl
:
true
placeholderId
:
"
newtab
-
topsites
-
url
-
input
"
errorMessageId
:
"
newtab
-
topsites
-
url
-
validation
"
}
)
this
.
_renderCustomScreenshotInput
(
)
)
external_React_default
(
)
.
createElement
(
TopSiteLink
{
link
:
previewLink
defaultStyle
:
requestFailed
title
:
this
.
state
.
label
}
)
)
)
external_React_default
(
)
.
createElement
(
"
section
"
{
className
:
"
actions
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
cancel
"
type
:
"
button
"
onClick
:
this
.
onCancelButtonClick
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
cancel
-
button
"
}
)
previewMode
?
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
preview
"
type
:
"
submit
"
"
data
-
l10n
-
id
"
:
"
newtab
-
topsites
-
preview
-
button
"
}
)
:
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
done
"
type
:
"
submit
"
"
data
-
l10n
-
id
"
:
showAsAdd
?
"
newtab
-
topsites
-
add
-
button
"
:
"
newtab
-
topsites
-
save
-
button
"
}
)
)
)
;
}
}
TopSiteForm
.
defaultProps
=
{
site
:
null
index
:
-
1
}
;
;
function
TopSites_extends
(
)
{
TopSites_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
TopSites_extends
.
apply
(
this
arguments
)
;
}
function
topSiteIconType
(
link
)
{
if
(
link
.
customScreenshotURL
)
{
return
"
custom_screenshot
"
;
}
if
(
link
.
tippyTopIcon
|
|
link
.
faviconRef
=
=
=
"
tippytop
"
)
{
return
"
tippytop
"
;
}
if
(
link
.
faviconSize
>
=
MIN_RICH_FAVICON_SIZE
)
{
return
"
rich_icon
"
;
}
if
(
link
.
screenshot
)
{
return
"
screenshot
"
;
}
return
"
no_image
"
;
}
function
countTopSitesIconsTypes
(
topSites
)
{
const
countTopSitesTypes
=
(
acc
link
)
=
>
{
acc
[
topSiteIconType
(
link
)
]
+
+
;
return
acc
;
}
;
return
topSites
.
reduce
(
countTopSitesTypes
{
custom_screenshot
:
0
screenshot
:
0
tippytop
:
0
rich_icon
:
0
no_image
:
0
}
)
;
}
class
_TopSites
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onEditFormClose
=
this
.
onEditFormClose
.
bind
(
this
)
;
this
.
onSearchShortcutsFormClose
=
this
.
onSearchShortcutsFormClose
.
bind
(
this
)
;
}
_dispatchTopSitesStats
(
)
{
const
topSites
=
this
.
_getVisibleTopSites
(
)
.
filter
(
topSite
=
>
topSite
!
=
=
null
&
&
topSite
!
=
=
undefined
)
;
const
topSitesIconsStats
=
countTopSitesIconsTypes
(
topSites
)
;
const
topSitesPinned
=
topSites
.
filter
(
site
=
>
!
!
site
.
isPinned
)
.
length
;
const
searchShortcuts
=
topSites
.
filter
(
site
=
>
!
!
site
.
searchTopSite
)
.
length
;
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SAVE_SESSION_PERF_DATA
data
:
{
topsites_icon_stats
:
topSitesIconsStats
topsites_pinned
:
topSitesPinned
topsites_search_shortcuts
:
searchShortcuts
}
}
)
)
;
}
_getVisibleTopSites
(
)
{
let
sitesPerRow
=
TOP_SITES_MAX_SITES_PER_ROW
;
if
(
!
__webpack_require__
.
g
.
matchMedia
(
(
min
-
width
:
1072px
)
)
.
matches
)
{
sitesPerRow
-
=
2
;
}
return
this
.
props
.
TopSites
.
rows
.
slice
(
0
this
.
props
.
TopSitesRows
*
sitesPerRow
)
;
}
componentDidUpdate
(
)
{
this
.
_dispatchTopSitesStats
(
)
;
}
componentDidMount
(
)
{
this
.
_dispatchTopSitesStats
(
)
;
}
onEditFormClose
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
TOP_SITES_EDIT_CLOSE
"
}
)
)
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
TOP_SITES_CANCEL_EDIT
}
)
;
}
onSearchShortcutsFormClose
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
source
:
TOP_SITES_SOURCE
event
:
"
SEARCH_EDIT_CLOSE
"
}
)
)
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
TOP_SITES_CLOSE_SEARCH_SHORTCUTS_MODAL
}
)
;
}
render
(
)
{
const
{
props
}
=
this
;
const
{
editForm
showSearchShortcutsForm
}
=
props
.
TopSites
;
const
extraMenuOptions
=
[
"
AddTopSite
"
]
;
const
colors
=
props
.
Prefs
.
values
[
"
newNewtabExperience
.
colors
"
]
;
if
(
props
.
Prefs
.
values
[
"
improvesearch
.
topSiteSearchShortcuts
"
]
)
{
extraMenuOptions
.
push
(
"
AddSearchShortcut
"
)
;
}
return
external_React_default
(
)
.
createElement
(
ComponentPerfTimer
{
id
:
"
topsites
"
initialized
:
props
.
TopSites
.
initialized
dispatch
:
props
.
dispatch
}
external_React_default
(
)
.
createElement
(
CollapsibleSection
{
className
:
"
top
-
sites
"
id
:
"
topsites
"
title
:
props
.
title
|
|
{
id
:
"
newtab
-
section
-
header
-
topsites
"
}
hideTitle
:
true
extraMenuOptions
:
extraMenuOptions
showPrefName
:
"
feeds
.
topsites
"
eventSource
:
TOP_SITES_SOURCE
collapsed
:
false
isFixed
:
props
.
isFixed
isFirst
:
props
.
isFirst
isLast
:
props
.
isLast
dispatch
:
props
.
dispatch
}
external_React_default
(
)
.
createElement
(
TopSiteList
{
TopSites
:
props
.
TopSites
TopSitesRows
:
props
.
TopSitesRows
dispatch
:
props
.
dispatch
topSiteIconType
:
topSiteIconType
colors
:
colors
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
edit
-
topsites
-
wrapper
"
}
editForm
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
edit
-
topsites
"
}
external_React_default
(
)
.
createElement
(
ModalOverlayWrapper
{
unstyled
:
true
onClose
:
this
.
onEditFormClose
innerClassName
:
"
modal
"
}
external_React_default
(
)
.
createElement
(
TopSiteForm
TopSites_extends
(
{
site
:
props
.
TopSites
.
rows
[
editForm
.
index
]
onClose
:
this
.
onEditFormClose
dispatch
:
this
.
props
.
dispatch
}
editForm
)
)
)
)
showSearchShortcutsForm
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
edit
-
search
-
shortcuts
"
}
external_React_default
(
)
.
createElement
(
ModalOverlayWrapper
{
unstyled
:
true
onClose
:
this
.
onSearchShortcutsFormClose
innerClassName
:
"
modal
"
}
external_React_default
(
)
.
createElement
(
SearchShortcutsForm
{
TopSites
:
props
.
TopSites
onClose
:
this
.
onSearchShortcutsFormClose
dispatch
:
this
.
props
.
dispatch
}
)
)
)
)
)
)
;
}
}
const
TopSites_TopSites
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
(
state
props
)
=
>
(
{
TopSites
:
props
.
TopSitesWithSpoc
|
|
state
.
TopSites
Prefs
:
state
.
Prefs
TopSitesRows
:
state
.
Prefs
.
values
.
topSitesRows
}
)
)
(
_TopSites
)
;
;
function
Sections_extends
(
)
{
Sections_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
Sections_extends
.
apply
(
this
arguments
)
;
}
const
Sections_VISIBLE
=
"
visible
"
;
const
Sections_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
const
CARDS_PER_ROW_DEFAULT
=
3
;
const
CARDS_PER_ROW_COMPACT_WIDE
=
4
;
class
Section
extends
(
external_React_default
(
)
)
.
PureComponent
{
get
numRows
(
)
{
const
{
rowsPref
maxRows
Prefs
}
=
this
.
props
;
return
rowsPref
?
Prefs
.
values
[
rowsPref
]
:
maxRows
;
}
_dispatchImpressionStats
(
)
{
const
{
props
}
=
this
;
let
cardsPerRow
=
CARDS_PER_ROW_DEFAULT
;
if
(
props
.
compactCards
&
&
__webpack_require__
.
g
.
matchMedia
(
(
min
-
width
:
1072px
)
)
.
matches
)
{
cardsPerRow
=
CARDS_PER_ROW_COMPACT_WIDE
;
}
const
maxCards
=
cardsPerRow
*
this
.
numRows
;
const
cards
=
props
.
rows
.
slice
(
0
maxCards
)
;
if
(
this
.
needsImpressionStats
(
cards
)
)
{
props
.
dispatch
(
actionCreators
.
ImpressionStats
(
{
source
:
props
.
eventSource
tiles
:
cards
.
map
(
link
=
>
(
{
id
:
link
.
guid
}
)
)
}
)
)
;
this
.
impressionCardGuids
=
cards
.
map
(
link
=
>
link
.
guid
)
;
}
}
sendImpressionStatsOrAddListener
(
)
{
const
{
props
}
=
this
;
if
(
!
props
.
shouldSendImpressionStats
|
|
!
props
.
dispatch
)
{
return
;
}
if
(
props
.
document
.
visibilityState
=
=
=
Sections_VISIBLE
)
{
this
.
_dispatchImpressionStats
(
)
;
}
else
{
if
(
this
.
_onVisibilityChange
)
{
props
.
document
.
removeEventListener
(
Sections_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
this
.
_onVisibilityChange
=
(
)
=
>
{
if
(
props
.
document
.
visibilityState
=
=
=
Sections_VISIBLE
)
{
if
(
!
this
.
props
.
pref
.
collapsed
)
{
this
.
_dispatchImpressionStats
(
)
;
}
props
.
document
.
removeEventListener
(
Sections_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
;
props
.
document
.
addEventListener
(
Sections_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
componentWillMount
(
)
{
this
.
sendNewTabRehydrated
(
this
.
props
.
initialized
)
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
rows
.
length
&
&
!
this
.
props
.
pref
.
collapsed
)
{
this
.
sendImpressionStatsOrAddListener
(
)
;
}
}
componentDidUpdate
(
prevProps
)
{
const
{
props
}
=
this
;
const
isCollapsed
=
props
.
pref
.
collapsed
;
const
wasCollapsed
=
prevProps
.
pref
.
collapsed
;
if
(
props
.
rows
.
length
&
&
(
props
.
rows
!
=
=
prevProps
.
rows
&
&
!
isCollapsed
|
|
wasCollapsed
&
&
!
isCollapsed
)
)
{
this
.
sendImpressionStatsOrAddListener
(
)
;
}
}
componentWillUpdate
(
nextProps
)
{
this
.
sendNewTabRehydrated
(
nextProps
.
initialized
)
;
}
componentWillUnmount
(
)
{
if
(
this
.
_onVisibilityChange
)
{
this
.
props
.
document
.
removeEventListener
(
Sections_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
needsImpressionStats
(
cards
)
{
if
(
!
this
.
impressionCardGuids
|
|
this
.
impressionCardGuids
.
length
!
=
=
cards
.
length
)
{
return
true
;
}
for
(
let
i
=
0
;
i
<
cards
.
length
;
i
+
+
)
{
if
(
cards
[
i
]
.
guid
!
=
=
this
.
impressionCardGuids
[
i
]
)
{
return
true
;
}
}
return
false
;
}
sendNewTabRehydrated
(
initialized
)
{
if
(
initialized
&
&
!
this
.
renderNotified
)
{
this
.
props
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
NEW_TAB_REHYDRATED
data
:
{
}
}
)
)
;
this
.
renderNotified
=
true
;
}
}
render
(
)
{
const
{
id
eventSource
title
rows
Pocket
topics
emptyState
dispatch
compactCards
read_more_endpoint
contextMenuOptions
initialized
learnMore
pref
privacyNoticeURL
isFirst
isLast
}
=
this
.
props
;
const
waitingForSpoc
=
id
=
=
=
"
topstories
"
&
&
this
.
props
.
Pocket
.
waitingForSpoc
;
const
maxCardsPerRow
=
compactCards
?
CARDS_PER_ROW_COMPACT_WIDE
:
CARDS_PER_ROW_DEFAULT
;
const
{
numRows
}
=
this
;
const
maxCards
=
maxCardsPerRow
*
numRows
;
const
maxCardsOnNarrow
=
CARDS_PER_ROW_DEFAULT
*
numRows
;
const
{
pocketCta
isUserLoggedIn
}
=
Pocket
|
|
{
}
;
const
{
useCta
}
=
pocketCta
|
|
{
}
;
const
isPocketLoggedInDefined
=
isUserLoggedIn
=
=
=
true
|
|
isUserLoggedIn
=
=
=
false
;
const
hasTopics
=
topics
&
&
!
!
topics
.
length
;
const
shouldShowPocketCta
=
id
=
=
=
"
topstories
"
&
&
useCta
&
&
isUserLoggedIn
=
=
=
false
;
const
shouldShowTopics
=
id
=
=
=
"
topstories
"
&
&
hasTopics
&
&
(
useCta
&
&
isUserLoggedIn
=
=
=
true
|
|
!
useCta
&
&
isPocketLoggedInDefined
)
;
const
shouldShowReadMore
=
read_more_endpoint
&
&
hasTopics
;
const
realRows
=
rows
.
slice
(
0
maxCards
)
;
const
shouldShowEmptyState
=
initialized
&
&
!
rows
.
length
;
const
cards
=
[
]
;
if
(
!
shouldShowEmptyState
)
{
for
(
let
i
=
0
;
i
<
maxCards
;
i
+
+
)
{
const
link
=
realRows
[
i
]
;
const
className
=
i
>
=
maxCardsOnNarrow
?
"
hide
-
for
-
narrow
"
:
"
"
;
let
usePlaceholder
=
!
link
;
if
(
!
usePlaceholder
&
&
i
=
=
=
2
&
&
waitingForSpoc
)
{
usePlaceholder
=
true
;
}
cards
.
push
(
!
usePlaceholder
?
external_React_default
(
)
.
createElement
(
Card
{
key
:
i
index
:
i
className
:
className
dispatch
:
dispatch
link
:
link
contextMenuOptions
:
contextMenuOptions
eventSource
:
eventSource
shouldSendImpressionStats
:
this
.
props
.
shouldSendImpressionStats
isWebExtension
:
this
.
props
.
isWebExtension
}
)
:
external_React_default
(
)
.
createElement
(
PlaceholderCard
{
key
:
i
className
:
className
}
)
)
;
}
}
const
sectionClassName
=
[
"
section
"
compactCards
?
"
compact
-
cards
"
:
"
normal
-
cards
"
]
.
join
(
"
"
)
;
return
external_React_default
(
)
.
createElement
(
ComponentPerfTimer
this
.
props
external_React_default
(
)
.
createElement
(
CollapsibleSection
{
className
:
sectionClassName
title
:
title
id
:
id
eventSource
:
eventSource
collapsed
:
this
.
props
.
pref
.
collapsed
showPrefName
:
pref
&
&
pref
.
feed
|
|
id
privacyNoticeURL
:
privacyNoticeURL
Prefs
:
this
.
props
.
Prefs
isFixed
:
this
.
props
.
isFixed
isFirst
:
isFirst
isLast
:
isLast
learnMore
:
learnMore
dispatch
:
this
.
props
.
dispatch
isWebExtension
:
this
.
props
.
isWebExtension
}
!
shouldShowEmptyState
&
&
external_React_default
(
)
.
createElement
(
"
ul
"
{
className
:
"
section
-
list
"
style
:
{
padding
:
0
}
}
cards
)
shouldShowEmptyState
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
section
-
empty
-
state
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
empty
-
state
"
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
emptyState
.
message
}
external_React_default
(
)
.
createElement
(
"
p
"
{
className
:
"
empty
-
state
-
message
"
}
)
)
)
)
id
=
=
=
"
topstories
"
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
top
-
stories
-
bottom
-
container
"
}
shouldShowTopics
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wrapper
-
topics
"
}
external_React_default
(
)
.
createElement
(
Topics
{
topics
:
this
.
props
.
topics
}
)
)
shouldShowPocketCta
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wrapper
-
cta
"
}
external_React_default
(
)
.
createElement
(
PocketLoggedInCta
null
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wrapper
-
more
-
recommendations
"
}
shouldShowReadMore
&
&
external_React_default
(
)
.
createElement
(
MoreRecommendations
{
read_more_endpoint
:
read_more_endpoint
}
)
)
)
)
)
;
}
}
Section
.
defaultProps
=
{
document
:
__webpack_require__
.
g
.
document
rows
:
[
]
emptyState
:
{
}
pref
:
{
}
title
:
"
"
}
;
const
SectionIntl
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
Pocket
:
state
.
Pocket
}
)
)
(
Section
)
;
class
_Sections
extends
(
external_React_default
(
)
)
.
PureComponent
{
renderSections
(
)
{
const
sections
=
[
]
;
const
enabledSections
=
this
.
props
.
Sections
.
filter
(
section
=
>
section
.
enabled
)
;
const
{
sectionOrder
"
feeds
.
topsites
"
:
showTopSites
}
=
this
.
props
.
Prefs
.
values
;
const
expectedCount
=
enabledSections
.
length
+
~
~
showTopSites
;
for
(
const
sectionId
of
sectionOrder
.
split
(
"
"
)
)
{
const
commonProps
=
{
key
:
sectionId
isFirst
:
sections
.
length
=
=
=
0
isLast
:
sections
.
length
=
=
=
expectedCount
-
1
}
;
if
(
sectionId
=
=
=
"
topsites
"
&
&
showTopSites
)
{
sections
.
push
(
external_React_default
(
)
.
createElement
(
TopSites_TopSites
commonProps
)
)
;
}
else
{
const
section
=
enabledSections
.
find
(
s
=
>
s
.
id
=
=
=
sectionId
)
;
if
(
section
)
{
sections
.
push
(
external_React_default
(
)
.
createElement
(
SectionIntl
Sections_extends
(
{
}
section
commonProps
)
)
)
;
}
}
}
return
sections
;
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
sections
-
list
"
}
this
.
renderSections
(
)
)
;
}
}
const
Sections_Sections
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Sections
:
state
.
Sections
Prefs
:
state
.
Prefs
}
)
)
(
_Sections
)
;
;
function
Highlights_extends
(
)
{
Highlights_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
Highlights_extends
.
apply
(
this
arguments
)
;
}
class
_Highlights
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
section
=
this
.
props
.
Sections
.
find
(
s
=
>
s
.
id
=
=
=
"
highlights
"
)
;
if
(
!
section
|
|
!
section
.
enabled
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
highlights
sections
-
list
"
}
external_React_default
(
)
.
createElement
(
SectionIntl
Highlights_extends
(
{
}
section
{
isFixed
:
true
}
)
)
)
;
}
}
const
Highlights
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Sections
:
state
.
Sections
}
)
)
(
_Highlights
)
;
;
class
HorizontalRule
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
hr
"
{
className
:
"
ds
-
hr
"
}
)
;
}
}
;
class
Navigation_Topic
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onLinkClick
=
this
.
onLinkClick
.
bind
(
this
)
;
}
onLinkClick
(
event
)
{
if
(
this
.
props
.
dispatch
)
{
this
.
props
.
dispatch
(
actionCreators
.
DiscoveryStreamUserEvent
(
{
event
:
"
CLICK
"
source
:
"
POPULAR_TOPICS
"
action_position
:
0
value
:
{
topic
:
event
.
target
.
text
.
toLowerCase
(
)
.
replace
(
-
)
}
}
)
)
;
}
}
render
(
)
{
const
{
url
name
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
SafeAnchor
{
onLinkClick
:
this
.
onLinkClick
className
:
this
.
props
.
className
url
:
url
}
name
)
;
}
}
class
Navigation
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
let
links
=
this
.
props
.
links
|
|
[
]
;
const
alignment
=
this
.
props
.
alignment
|
|
"
centered
"
;
const
header
=
this
.
props
.
header
|
|
{
}
;
const
english
=
this
.
props
.
locale
.
startsWith
(
"
en
-
"
)
;
const
privacyNotice
=
this
.
props
.
privacyNoticeURL
|
|
{
}
;
const
{
newFooterSection
}
=
this
.
props
;
const
className
=
ds
-
navigation
ds
-
navigation
-
{
alignment
}
{
newFooterSection
?
ds
-
navigation
-
new
-
topics
:
}
;
let
{
title
}
=
header
;
if
(
newFooterSection
)
{
title
=
{
id
:
"
newtab
-
pocket
-
new
-
topics
-
title
"
}
;
if
(
this
.
props
.
extraLinks
)
{
links
=
[
.
.
.
links
.
slice
(
0
links
.
length
-
1
)
.
.
.
this
.
props
.
extraLinks
links
[
links
.
length
-
1
]
]
;
}
}
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
className
}
title
&
&
english
?
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
title
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
ds
-
navigation
-
header
"
}
)
)
:
null
english
?
external_React_default
(
)
.
createElement
(
"
ul
"
null
links
&
&
links
.
map
(
t
=
>
external_React_default
(
)
.
createElement
(
"
li
"
{
key
:
t
.
name
}
external_React_default
(
)
.
createElement
(
Navigation_Topic
{
url
:
t
.
url
name
:
t
.
name
dispatch
:
this
.
props
.
dispatch
}
)
)
)
)
:
null
!
newFooterSection
?
external_React_default
(
)
.
createElement
(
SafeAnchor
{
className
:
"
ds
-
navigation
-
privacy
"
url
:
privacyNotice
.
url
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
privacyNotice
.
title
}
)
)
:
null
newFooterSection
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
navigation
-
family
"
}
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
firefox
-
logo
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
null
"
|
"
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
icon
pocket
-
logo
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
ds
-
navigation
-
family
-
message
"
"
data
-
l10n
-
id
"
:
"
newtab
-
pocket
-
pocket
-
firefox
-
family
"
}
)
)
:
null
)
;
}
}
;
class
PrivacyLink
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
properties
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
privacy
-
link
"
}
external_React_default
(
)
.
createElement
(
SafeAnchor
{
url
:
properties
.
url
}
external_React_default
(
)
.
createElement
(
FluentOrText
{
message
:
properties
.
title
}
)
)
)
;
}
}
;
class
SectionTitle
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
const
{
header
:
{
title
subtitle
}
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
section
-
title
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
title
"
}
title
)
subtitle
?
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
subtitle
"
}
subtitle
)
:
null
)
;
}
}
;
const
selectLayoutRender
=
(
{
state
=
{
}
prefs
=
{
}
locale
=
"
"
}
)
=
>
{
const
{
layout
feeds
spocs
}
=
state
;
let
spocIndexPlacementMap
=
{
}
;
function
fillSpocPositionsForPlacement
(
data
spocsConfig
spocsData
placementName
)
{
if
(
!
spocIndexPlacementMap
[
placementName
]
&
&
spocIndexPlacementMap
[
placementName
]
!
=
=
0
)
{
spocIndexPlacementMap
[
placementName
]
=
0
;
}
const
results
=
[
.
.
.
data
]
;
for
(
let
position
of
spocsConfig
.
positions
)
{
const
spoc
=
spocsData
[
spocIndexPlacementMap
[
placementName
]
]
;
if
(
!
spoc
)
{
break
;
}
spocIndexPlacementMap
[
placementName
]
+
+
;
if
(
!
spocs
.
blocked
.
includes
(
spoc
.
url
)
)
{
results
.
splice
(
position
.
index
0
spoc
)
;
}
}
return
results
;
}
const
positions
=
{
}
;
const
DS_COMPONENTS
=
[
"
Message
"
"
TextPromo
"
"
SectionTitle
"
"
Signup
"
"
Navigation
"
"
CardGrid
"
"
CollectionCardGrid
"
"
HorizontalRule
"
"
PrivacyLink
"
]
;
const
filterArray
=
[
]
;
if
(
!
prefs
[
"
feeds
.
topsites
"
]
)
{
filterArray
.
push
(
"
TopSites
"
)
;
}
const
pocketEnabled
=
prefs
[
"
feeds
.
section
.
topstories
"
]
&
&
prefs
[
"
feeds
.
system
.
topstories
"
]
;
if
(
!
pocketEnabled
)
{
filterArray
.
push
(
.
.
.
DS_COMPONENTS
)
;
}
const
placeholderComponent
=
component
=
>
{
if
(
!
component
.
feed
)
{
return
{
.
.
.
component
data
:
{
spocs
:
[
]
}
}
;
}
const
data
=
{
recommendations
:
[
]
}
;
let
items
=
0
;
if
(
component
.
properties
&
&
component
.
properties
.
items
)
{
items
=
component
.
properties
.
items
;
}
for
(
let
i
=
0
;
i
<
items
;
i
+
+
)
{
data
.
recommendations
.
push
(
{
placeholder
:
true
}
)
;
}
return
{
.
.
.
component
data
}
;
}
;
const
handleSpocs
=
(
data
component
)
=
>
{
let
result
=
[
.
.
.
data
]
;
if
(
component
.
spocs
&
&
component
.
spocs
.
positions
&
&
component
.
spocs
.
positions
.
length
)
{
const
placement
=
component
.
placement
|
|
{
}
;
const
placementName
=
placement
.
name
|
|
"
spocs
"
;
const
spocsData
=
spocs
.
data
[
placementName
]
;
if
(
spocs
.
loaded
&
&
spocsData
&
&
spocsData
.
items
&
&
spocsData
.
items
.
length
)
{
result
=
fillSpocPositionsForPlacement
(
result
component
.
spocs
spocsData
.
items
placementName
)
;
}
}
return
result
;
}
;
const
handleComponent
=
component
=
>
{
if
(
component
.
spocs
&
&
component
.
spocs
.
positions
&
&
component
.
spocs
.
positions
.
length
)
{
const
placement
=
component
.
placement
|
|
{
}
;
const
placementName
=
placement
.
name
|
|
"
spocs
"
;
const
spocsData
=
spocs
.
data
[
placementName
]
;
if
(
spocs
.
loaded
&
&
spocsData
&
&
spocsData
.
items
&
&
spocsData
.
items
.
length
)
{
return
{
.
.
.
component
data
:
{
spocs
:
spocsData
.
items
.
filter
(
spoc
=
>
spoc
&
&
!
spocs
.
blocked
.
includes
(
spoc
.
url
)
)
.
map
(
(
spoc
index
)
=
>
(
{
.
.
.
spoc
pos
:
index
}
)
)
}
}
;
}
}
return
{
.
.
.
component
data
:
{
spocs
:
[
]
}
}
;
}
;
const
handleComponentWithFeed
=
component
=
>
{
positions
[
component
.
type
]
=
positions
[
component
.
type
]
|
|
0
;
let
data
=
{
recommendations
:
[
]
}
;
const
feed
=
feeds
.
data
[
component
.
feed
.
url
]
;
if
(
feed
&
&
feed
.
data
)
{
data
=
{
.
.
.
feed
.
data
recommendations
:
[
.
.
.
(
feed
.
data
.
recommendations
|
|
[
]
)
]
}
;
}
if
(
component
&
&
component
.
properties
&
&
component
.
properties
.
offset
)
{
data
=
{
.
.
.
data
recommendations
:
data
.
recommendations
.
slice
(
component
.
properties
.
offset
)
}
;
}
data
=
{
.
.
.
data
recommendations
:
handleSpocs
(
data
.
recommendations
component
)
}
;
let
items
=
0
;
if
(
component
.
properties
&
&
component
.
properties
.
items
)
{
items
=
Math
.
min
(
component
.
properties
.
items
data
.
recommendations
.
length
)
;
}
for
(
let
i
=
0
;
i
<
items
;
i
+
+
)
{
data
.
recommendations
[
i
]
=
{
.
.
.
data
.
recommendations
[
i
]
pos
:
positions
[
component
.
type
]
+
+
}
;
}
return
{
.
.
.
component
data
}
;
}
;
const
renderLayout
=
(
)
=
>
{
const
renderedLayoutArray
=
[
]
;
for
(
const
row
of
layout
.
filter
(
r
=
>
r
.
components
.
filter
(
c
=
>
!
filterArray
.
includes
(
c
.
type
)
)
.
length
)
)
{
let
components
=
[
]
;
renderedLayoutArray
.
push
(
{
.
.
.
row
components
}
)
;
for
(
const
component
of
row
.
components
.
filter
(
c
=
>
!
filterArray
.
includes
(
c
.
type
)
)
)
{
const
spocsConfig
=
component
.
spocs
;
if
(
spocsConfig
|
|
component
.
feed
)
{
if
(
component
.
feed
&
&
!
feeds
.
data
[
component
.
feed
.
url
]
|
|
spocsConfig
&
&
spocsConfig
.
positions
&
&
spocsConfig
.
positions
.
length
&
&
!
spocs
.
loaded
)
{
components
.
push
(
placeholderComponent
(
component
)
)
;
return
renderedLayoutArray
;
}
if
(
component
.
feed
)
{
components
.
push
(
handleComponentWithFeed
(
component
)
)
;
}
else
{
components
.
push
(
handleComponent
(
component
)
)
;
}
}
else
{
components
.
push
(
component
)
;
}
}
}
return
renderedLayoutArray
;
}
;
const
layoutRender
=
renderLayout
(
)
;
return
{
layoutRender
}
;
}
;
;
class
TopSites_TopSites_TopSites
extends
(
external_React_default
(
)
)
.
PureComponent
{
getFirstAvailableSpoc
(
topSites
data
)
{
const
{
spocs
}
=
data
;
if
(
!
spocs
|
|
spocs
.
length
=
=
=
0
)
{
return
null
;
}
const
userTopSites
=
new
Set
(
topSites
.
map
(
topSite
=
>
topSite
&
&
topSite
.
url
)
)
;
return
spocs
.
find
(
spoc
=
>
!
userTopSites
.
has
(
spoc
.
url
)
&
&
!
userTopSites
.
has
(
http
:
/
/
{
spoc
.
domain
}
)
&
&
!
userTopSites
.
has
(
https
:
/
/
{
spoc
.
domain
}
)
&
&
!
userTopSites
.
has
(
http
:
/
/
www
.
{
spoc
.
domain
}
)
&
&
!
userTopSites
.
has
(
https
:
/
/
www
.
{
spoc
.
domain
}
)
)
;
}
getFirstAvailableIndex
(
topSites
promoAlignment
)
{
if
(
promoAlignment
=
=
=
"
left
"
)
{
return
topSites
.
findIndex
(
topSite
=
>
!
topSite
|
|
!
topSite
.
isPinned
)
;
}
if
(
topSites
.
length
<
TOP_SITES_MAX_SITES_PER_ROW
)
{
return
-
1
;
}
let
endOfRow
=
TOP_SITES_MAX_SITES_PER_ROW
-
1
;
for
(
let
i
=
endOfRow
;
i
>
=
0
;
i
-
-
)
{
if
(
!
topSites
[
i
]
|
|
!
topSites
[
i
]
.
isPinned
)
{
return
i
;
}
}
for
(
let
i
=
endOfRow
+
1
;
i
<
topSites
.
length
;
i
+
+
)
{
if
(
!
topSites
[
i
]
|
|
!
topSites
[
i
]
.
isPinned
)
{
return
i
;
}
}
return
-
1
;
}
insertSpocContent
(
TopSites
data
promoAlignment
)
{
if
(
!
TopSites
.
rows
|
|
TopSites
.
rows
.
length
=
=
=
0
|
|
!
data
.
spocs
|
|
data
.
spocs
.
length
=
=
=
0
)
{
return
null
;
}
let
topSites
=
[
.
.
.
TopSites
.
rows
]
;
const
topSiteSpoc
=
this
.
getFirstAvailableSpoc
(
topSites
data
)
;
if
(
!
topSiteSpoc
)
{
return
null
;
}
const
link
=
{
customScreenshotURL
:
topSiteSpoc
.
image_src
type
:
"
SPOC
"
label
:
topSiteSpoc
.
sponsor
title
:
topSiteSpoc
.
sponsor
url
:
topSiteSpoc
.
url
flightId
:
topSiteSpoc
.
flight_id
id
:
topSiteSpoc
.
id
guid
:
topSiteSpoc
.
id
shim
:
topSiteSpoc
.
shim
pos
:
promoAlignment
=
=
=
"
left
"
?
0
:
7
}
;
const
firstAvailableIndex
=
this
.
getFirstAvailableIndex
(
topSites
promoAlignment
)
;
if
(
firstAvailableIndex
=
=
=
-
1
)
{
topSites
.
push
(
link
)
;
}
else
{
let
shiftedTopSite
=
topSites
[
firstAvailableIndex
]
;
let
index
=
firstAvailableIndex
+
1
;
while
(
shiftedTopSite
)
{
if
(
index
=
=
=
topSites
.
length
)
{
topSites
.
push
(
shiftedTopSite
)
;
shiftedTopSite
=
null
;
}
else
if
(
topSites
[
index
]
&
&
topSites
[
index
]
.
isPinned
)
{
index
+
=
1
;
}
else
{
const
nextTopSite
=
topSites
[
index
]
;
topSites
[
index
]
=
shiftedTopSite
;
shiftedTopSite
=
nextTopSite
;
index
+
=
1
;
}
}
topSites
[
firstAvailableIndex
]
=
link
;
}
return
{
.
.
.
TopSites
rows
:
topSites
}
;
}
render
(
)
{
const
{
header
=
{
}
data
promoAlignment
TopSites
}
=
this
.
props
;
const
TopSitesWithSpoc
=
TopSites
&
&
data
&
&
promoAlignment
?
this
.
insertSpocContent
(
TopSites
data
promoAlignment
)
:
null
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
ds
-
top
-
sites
{
TopSitesWithSpoc
?
"
top
-
sites
-
spoc
"
:
"
"
}
}
external_React_default
(
)
.
createElement
(
TopSites_TopSites
{
isFixed
:
true
title
:
header
.
title
TopSitesWithSpoc
:
TopSitesWithSpoc
}
)
)
;
}
}
const
DiscoveryStreamComponents_TopSites_TopSites_TopSites
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
TopSites
:
state
.
TopSites
}
)
)
(
TopSites_TopSites_TopSites
)
;
;
const
ALLOWED_CSS_URL_PREFIXES
=
[
"
chrome
:
/
/
"
"
resource
:
/
/
"
"
https
:
/
/
img
-
getpocket
.
cdn
.
mozilla
.
net
/
"
]
;
const
DUMMY_CSS_SELECTOR
=
"
DUMMY
#
CSS
.
SELECTOR
"
;
function
isAllowedCSS
(
property
value
)
{
if
(
value
=
=
=
undefined
)
{
return
true
;
}
const
urls
=
value
.
match
(
/
url
\
(
"
[
^
"
]
+
"
\
)
/
g
)
;
return
!
urls
|
|
urls
.
every
(
url
=
>
ALLOWED_CSS_URL_PREFIXES
.
some
(
prefix
=
>
url
.
slice
(
5
)
.
startsWith
(
prefix
)
)
)
;
}
class
_DiscoveryStreamBase
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onStyleMount
=
this
.
onStyleMount
.
bind
(
this
)
;
}
onStyleMount
(
style
)
{
if
(
!
style
)
{
return
;
}
const
{
sheet
}
=
style
;
const
styles
=
JSON
.
parse
(
style
.
dataset
.
styles
)
;
styles
.
forEach
(
(
row
rowIndex
)
=
>
{
row
.
forEach
(
(
component
componentIndex
)
=
>
{
if
(
!
component
)
{
return
;
}
Object
.
entries
(
component
)
.
forEach
(
(
[
selectors
declarations
]
)
=
>
{
sheet
.
insertRule
(
{
DUMMY_CSS_SELECTOR
}
{
}
)
;
const
[
rule
]
=
sheet
.
cssRules
;
rule
.
style
=
declarations
;
[
.
.
.
rule
.
style
]
.
forEach
(
property
=
>
{
const
value
=
rule
.
style
[
property
]
;
if
(
!
isAllowedCSS
(
property
value
)
)
{
console
.
error
(
Bad
CSS
declaration
{
property
}
:
{
value
}
)
;
rule
.
style
.
removeProperty
(
property
)
;
}
}
)
;
const
prefix
=
.
ds
-
layout
>
.
ds
-
column
:
nth
-
child
(
{
rowIndex
+
1
}
)
.
ds
-
column
-
grid
>
:
nth
-
child
(
{
componentIndex
+
1
}
)
;
rule
.
selectorText
=
selectors
.
split
(
"
"
)
.
map
(
selector
=
>
prefix
+
(
selector
[
0
]
=
=
=
"
:
"
?
"
"
:
"
"
)
+
selector
)
.
join
(
"
"
)
;
if
(
rule
.
selectorText
=
=
=
DUMMY_CSS_SELECTOR
)
{
console
.
error
(
Bad
CSS
selector
{
selectors
}
)
;
}
}
)
;
}
)
;
}
)
;
}
renderComponent
(
component
embedWidth
)
{
switch
(
component
.
type
)
{
case
"
Highlights
"
:
return
external_React_default
(
)
.
createElement
(
Highlights
null
)
;
case
"
TopSites
"
:
let
promoAlignment
;
if
(
component
.
spocs
&
&
component
.
spocs
.
positions
&
&
component
.
spocs
.
positions
.
length
)
{
promoAlignment
=
component
.
spocs
.
positions
[
0
]
.
index
=
=
=
0
?
"
left
"
:
"
right
"
;
}
return
external_React_default
(
)
.
createElement
(
DiscoveryStreamComponents_TopSites_TopSites_TopSites
{
header
:
component
.
header
data
:
component
.
data
promoAlignment
:
promoAlignment
}
)
;
case
"
TextPromo
"
:
return
external_React_default
(
)
.
createElement
(
DSTextPromo
{
dispatch
:
this
.
props
.
dispatch
type
:
component
.
type
data
:
component
.
data
}
)
;
case
"
Signup
"
:
return
external_React_default
(
)
.
createElement
(
DSSignup
{
dispatch
:
this
.
props
.
dispatch
type
:
component
.
type
data
:
component
.
data
}
)
;
case
"
Message
"
:
return
external_React_default
(
)
.
createElement
(
DSMessage
{
title
:
component
.
header
&
&
component
.
header
.
title
subtitle
:
component
.
header
&
&
component
.
header
.
subtitle
link_text
:
component
.
header
&
&
component
.
header
.
link_text
link_url
:
component
.
header
&
&
component
.
header
.
link_url
icon
:
component
.
header
&
&
component
.
header
.
icon
essentialReadsHeader
:
component
.
essentialReadsHeader
editorsPicksHeader
:
component
.
editorsPicksHeader
}
)
;
case
"
SectionTitle
"
:
return
external_React_default
(
)
.
createElement
(
SectionTitle
{
header
:
component
.
header
}
)
;
case
"
Navigation
"
:
return
external_React_default
(
)
.
createElement
(
Navigation
{
dispatch
:
this
.
props
.
dispatch
links
:
component
.
properties
.
links
extraLinks
:
component
.
properties
.
extraLinks
alignment
:
component
.
properties
.
alignment
explore_topics
:
component
.
properties
.
explore_topics
header
:
component
.
header
locale
:
this
.
props
.
App
.
locale
newFooterSection
:
component
.
newFooterSection
privacyNoticeURL
:
component
.
properties
.
privacyNoticeURL
}
)
;
case
"
CollectionCardGrid
"
:
const
{
DiscoveryStream
}
=
this
.
props
;
return
external_React_default
(
)
.
createElement
(
CollectionCardGrid
{
data
:
component
.
data
feed
:
component
.
feed
spocs
:
DiscoveryStream
.
spocs
placement
:
component
.
placement
type
:
component
.
type
items
:
component
.
properties
.
items
dismissible
:
this
.
props
.
DiscoveryStream
.
isCollectionDismissible
dispatch
:
this
.
props
.
dispatch
}
)
;
case
"
CardGrid
"
:
return
external_React_default
(
)
.
createElement
(
CardGrid
{
title
:
component
.
header
&
&
component
.
header
.
title
data
:
component
.
data
feed
:
component
.
feed
widgets
:
component
.
widgets
type
:
component
.
type
dispatch
:
this
.
props
.
dispatch
items
:
component
.
properties
.
items
hybridLayout
:
component
.
properties
.
hybridLayout
hideCardBackground
:
component
.
properties
.
hideCardBackground
fourCardLayout
:
component
.
properties
.
fourCardLayout
compactGrid
:
component
.
properties
.
compactGrid
essentialReadsHeader
:
component
.
properties
.
essentialReadsHeader
editorsPicksHeader
:
component
.
properties
.
editorsPicksHeader
recentSavesEnabled
:
this
.
props
.
DiscoveryStream
.
recentSavesEnabled
hideDescriptions
:
this
.
props
.
DiscoveryStream
.
hideDescriptions
}
)
;
case
"
HorizontalRule
"
:
return
external_React_default
(
)
.
createElement
(
HorizontalRule
null
)
;
case
"
PrivacyLink
"
:
return
external_React_default
(
)
.
createElement
(
PrivacyLink
{
properties
:
component
.
properties
}
)
;
default
:
return
external_React_default
(
)
.
createElement
(
"
div
"
null
component
.
type
)
;
}
}
renderStyles
(
styles
)
{
const
json
=
JSON
.
stringify
(
styles
)
;
return
external_React_default
(
)
.
createElement
(
"
style
"
{
key
:
json
"
data
-
styles
"
:
json
ref
:
this
.
onStyleMount
}
)
;
}
render
(
)
{
const
{
locale
}
=
this
.
props
;
const
{
layoutRender
}
=
selectLayoutRender
(
{
state
:
this
.
props
.
DiscoveryStream
prefs
:
this
.
props
.
Prefs
.
values
locale
}
)
;
const
{
config
}
=
this
.
props
.
DiscoveryStream
;
if
(
!
config
.
collapsible
)
{
return
this
.
renderLayout
(
layoutRender
)
;
}
const
extractComponent
=
type
=
>
{
for
(
const
[
rowIndex
row
]
of
Object
.
entries
(
layoutRender
)
)
{
for
(
const
[
index
component
]
of
Object
.
entries
(
row
.
components
)
)
{
if
(
component
.
type
=
=
=
type
)
{
if
(
row
.
components
.
length
=
=
=
1
)
{
layoutRender
.
splice
(
rowIndex
1
)
;
}
else
{
row
.
components
.
splice
(
index
1
)
;
}
return
component
;
}
}
}
return
null
;
}
;
const
topStories
=
this
.
props
.
Sections
.
find
(
s
=
>
s
.
id
=
=
=
"
topstories
"
)
;
if
(
!
topStories
)
{
return
null
;
}
const
topSites
=
extractComponent
(
"
TopSites
"
)
;
const
sponsoredCollection
=
extractComponent
(
"
CollectionCardGrid
"
)
;
const
message
=
extractComponent
(
"
Message
"
)
|
|
{
header
:
{
link_text
:
topStories
.
learnMore
.
link
.
message
link_url
:
topStories
.
learnMore
.
link
.
href
title
:
topStories
.
title
}
}
;
const
privacyLinkComponent
=
extractComponent
(
"
PrivacyLink
"
)
;
let
learnMore
=
{
link
:
{
href
:
message
.
header
.
link_url
message
:
message
.
header
.
link_text
}
}
;
let
sectionTitle
=
message
.
header
.
title
;
let
subTitle
=
"
"
;
if
(
message
.
essentialReadsHeader
|
|
message
.
editorsPicksHeader
)
{
learnMore
=
null
;
subTitle
=
"
Recommended
By
Pocket
"
;
if
(
message
.
essentialReadsHeader
)
{
sectionTitle
=
"
Today
s
Essential
Reads
"
;
}
else
if
(
message
.
editorsPicksHeader
)
{
sectionTitle
=
"
Editor
s
Picks
"
;
}
}
return
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
this
.
props
.
DiscoveryStream
.
isPrivacyInfoModalVisible
&
&
external_React_default
(
)
.
createElement
(
DSPrivacyModal
{
dispatch
:
this
.
props
.
dispatch
}
)
topSites
&
&
this
.
renderLayout
(
[
{
width
:
12
components
:
[
topSites
]
}
]
)
sponsoredCollection
&
&
this
.
renderLayout
(
[
{
width
:
12
components
:
[
sponsoredCollection
]
}
]
)
!
!
layoutRender
.
length
&
&
external_React_default
(
)
.
createElement
(
CollapsibleSection
{
className
:
"
ds
-
layout
"
collapsed
:
topStories
.
pref
.
collapsed
dispatch
:
this
.
props
.
dispatch
id
:
topStories
.
id
isFixed
:
true
learnMore
:
learnMore
privacyNoticeURL
:
topStories
.
privacyNoticeURL
showPrefName
:
topStories
.
pref
.
feed
title
:
sectionTitle
subTitle
:
subTitle
eventSource
:
"
CARDGRID
"
}
this
.
renderLayout
(
layoutRender
)
)
this
.
renderLayout
(
[
{
width
:
12
components
:
[
{
type
:
"
Highlights
"
}
]
}
]
)
privacyLinkComponent
&
&
this
.
renderLayout
(
[
{
width
:
12
components
:
[
privacyLinkComponent
]
}
]
)
)
;
}
renderLayout
(
layoutRender
)
{
const
styles
=
[
]
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
discovery
-
stream
ds
-
layout
"
}
layoutRender
.
map
(
(
row
rowIndex
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
row
-
{
rowIndex
}
className
:
ds
-
column
ds
-
column
-
{
row
.
width
}
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
ds
-
column
-
grid
"
}
row
.
components
.
map
(
(
component
componentIndex
)
=
>
{
if
(
!
component
)
{
return
null
;
}
styles
[
rowIndex
]
=
[
.
.
.
(
styles
[
rowIndex
]
|
|
[
]
)
component
.
styles
]
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
key
:
component
-
{
componentIndex
}
}
this
.
renderComponent
(
component
row
.
width
)
)
;
}
)
)
)
)
this
.
renderStyles
(
styles
)
)
;
}
}
const
DiscoveryStreamBase
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
DiscoveryStream
:
state
.
DiscoveryStream
Prefs
:
state
.
Prefs
Sections
:
state
.
Sections
document
:
__webpack_require__
.
g
.
document
App
:
state
.
App
}
)
)
(
_DiscoveryStreamBase
)
;
;
class
BackgroundsSection
extends
(
external_React_default
(
)
)
.
PureComponent
{
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
div
"
null
)
;
}
}
;
class
ContentSection
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onPreferenceSelect
=
this
.
onPreferenceSelect
.
bind
(
this
)
;
this
.
topSitesDrawerRef
=
external_React_default
(
)
.
createRef
(
)
;
this
.
pocketDrawerRef
=
external_React_default
(
)
.
createRef
(
)
;
}
inputUserEvent
(
eventSource
status
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
PREF_CHANGED
"
source
:
eventSource
value
:
{
status
menu_source
:
"
CUSTOMIZE_MENU
"
}
}
)
)
;
}
onPreferenceSelect
(
e
)
{
let
prefName
=
e
.
target
.
getAttribute
(
"
preference
"
)
;
const
eventSource
=
e
.
target
.
getAttribute
(
"
eventSource
"
)
;
let
value
;
if
(
e
.
target
.
nodeName
=
=
=
"
SELECT
"
)
{
value
=
parseInt
(
e
.
target
.
value
10
)
;
}
else
if
(
e
.
target
.
nodeName
=
=
=
"
INPUT
"
)
{
value
=
e
.
target
.
checked
;
if
(
eventSource
)
{
this
.
inputUserEvent
(
eventSource
value
)
;
}
}
this
.
props
.
setPref
(
prefName
value
)
;
}
componentDidMount
(
)
{
this
.
setDrawerMargins
(
)
;
}
componentDidUpdate
(
)
{
this
.
setDrawerMargins
(
)
;
}
setDrawerMargins
(
)
{
this
.
setDrawerMargin
(
TOP_SITES
this
.
props
.
enabledSections
.
topSitesEnabled
)
;
this
.
setDrawerMargin
(
TOP_STORIES
this
.
props
.
enabledSections
.
pocketEnabled
)
;
}
setDrawerMargin
(
drawerID
isOpen
)
{
let
drawerRef
;
if
(
drawerID
=
=
=
TOP_SITES
)
{
drawerRef
=
this
.
topSitesDrawerRef
.
current
;
}
else
if
(
drawerID
=
=
=
TOP_STORIES
)
{
drawerRef
=
this
.
pocketDrawerRef
.
current
;
}
else
{
return
;
}
let
drawerHeight
;
if
(
drawerRef
)
{
var
_window
getComputedSt
;
drawerHeight
=
parseFloat
(
(
_window
getComputedSt
=
window
.
getComputedStyle
(
drawerRef
)
)
=
=
=
null
|
|
_window
getComputedSt
=
=
=
void
0
?
void
0
:
_window
getComputedSt
.
height
)
;
if
(
isOpen
)
{
drawerRef
.
style
.
marginTop
=
0
;
}
else
{
drawerRef
.
style
.
marginTop
=
-
{
drawerHeight
}
px
;
}
}
}
render
(
)
{
const
{
enabledSections
mayHaveSponsoredTopSites
pocketRegion
mayHaveSponsoredStories
mayHaveRecentSaves
openPreferences
}
=
this
.
props
;
const
{
topSitesEnabled
pocketEnabled
highlightsEnabled
showSponsoredTopSitesEnabled
showSponsoredPocketEnabled
showRecentSavesEnabled
topSitesRowsCount
}
=
enabledSections
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
home
-
section
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
shortcuts
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
"
switch
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
shortcuts
-
toggle
"
checked
:
topSitesEnabled
type
:
"
checkbox
"
onChange
:
this
.
onPreferenceSelect
preference
:
"
feeds
.
topsites
"
"
aria
-
labelledby
"
:
"
custom
-
shortcuts
-
title
"
"
aria
-
describedby
"
:
"
custom
-
shortcuts
-
subtitle
"
eventSource
:
"
TOP_SITES
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
slider
"
role
:
"
presentation
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
h2
"
{
id
:
"
custom
-
shortcuts
-
title
"
className
:
"
title
"
}
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
"
shortcuts
-
toggle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
shortcuts
-
title
"
}
)
)
external_React_default
(
)
.
createElement
(
"
p
"
{
id
:
"
custom
-
shortcuts
-
subtitle
"
className
:
"
subtitle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
shortcuts
-
subtitle
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
more
-
info
-
top
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
more
-
information
"
ref
:
this
.
topSitesDrawerRef
}
external_React_default
(
)
.
createElement
(
"
select
"
{
id
:
"
row
-
selector
"
className
:
"
selector
"
name
:
"
row
-
count
"
preference
:
"
topSitesRows
"
value
:
topSitesRowsCount
onChange
:
this
.
onPreferenceSelect
disabled
:
!
topSitesEnabled
"
aria
-
labelledby
"
:
"
custom
-
shortcuts
-
title
"
}
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
1
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
row
-
selector
"
"
data
-
l10n
-
args
"
:
"
{
\
"
num
\
"
:
1
}
"
}
)
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
2
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
row
-
selector
"
"
data
-
l10n
-
args
"
:
"
{
\
"
num
\
"
:
2
}
"
}
)
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
3
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
row
-
selector
"
"
data
-
l10n
-
args
"
:
"
{
\
"
num
\
"
:
3
}
"
}
)
external_React_default
(
)
.
createElement
(
"
option
"
{
value
:
"
4
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
row
-
selector
"
"
data
-
l10n
-
args
"
:
"
{
\
"
num
\
"
:
4
}
"
}
)
)
mayHaveSponsoredTopSites
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
check
-
wrapper
"
role
:
"
presentation
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
sponsored
-
shortcuts
"
className
:
"
sponsored
-
checkbox
"
disabled
:
!
topSitesEnabled
checked
:
showSponsoredTopSitesEnabled
type
:
"
checkbox
"
onChange
:
this
.
onPreferenceSelect
preference
:
"
showSponsoredTopSites
"
eventSource
:
"
SPONSORED_TOP_SITES
"
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
"
sponsored
"
htmlFor
:
"
sponsored
-
shortcuts
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
sponsored
-
sites
"
}
)
)
)
)
)
)
pocketRegion
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
pocket
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
"
switch
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
pocket
-
toggle
"
checked
:
pocketEnabled
type
:
"
checkbox
"
onChange
:
this
.
onPreferenceSelect
preference
:
"
feeds
.
section
.
topstories
"
"
aria
-
labelledby
"
:
"
custom
-
pocket
-
title
"
"
aria
-
describedby
"
:
"
custom
-
pocket
-
subtitle
"
eventSource
:
"
TOP_STORIES
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
slider
"
role
:
"
presentation
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
h2
"
{
id
:
"
custom
-
pocket
-
title
"
className
:
"
title
"
}
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
"
pocket
-
toggle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
pocket
-
title
"
}
)
)
external_React_default
(
)
.
createElement
(
"
p
"
{
id
:
"
custom
-
pocket
-
subtitle
"
className
:
"
subtitle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
pocket
-
subtitle
"
}
)
(
mayHaveSponsoredStories
|
|
mayHaveRecentSaves
)
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
more
-
info
-
pocket
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
more
-
information
"
ref
:
this
.
pocketDrawerRef
}
mayHaveSponsoredStories
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
check
-
wrapper
"
role
:
"
presentation
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
sponsored
-
pocket
"
className
:
"
sponsored
-
checkbox
"
disabled
:
!
pocketEnabled
checked
:
showSponsoredPocketEnabled
type
:
"
checkbox
"
onChange
:
this
.
onPreferenceSelect
preference
:
"
showSponsored
"
eventSource
:
"
POCKET_SPOCS
"
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
"
sponsored
"
htmlFor
:
"
sponsored
-
pocket
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
pocket
-
sponsored
"
}
)
)
mayHaveRecentSaves
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
check
-
wrapper
"
role
:
"
presentation
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
recent
-
saves
-
pocket
"
className
:
"
sponsored
-
checkbox
"
disabled
:
!
pocketEnabled
checked
:
showRecentSavesEnabled
type
:
"
checkbox
"
onChange
:
this
.
onPreferenceSelect
preference
:
"
showRecentSaves
"
eventSource
:
"
POCKET_RECENT_SAVES
"
}
)
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
"
sponsored
"
htmlFor
:
"
recent
-
saves
-
pocket
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
pocket
-
show
-
recent
-
saves
"
}
)
)
)
)
)
)
external_React_default
(
)
.
createElement
(
"
div
"
{
id
:
"
recent
-
section
"
className
:
"
section
"
}
external_React_default
(
)
.
createElement
(
"
label
"
{
className
:
"
switch
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
highlights
-
toggle
"
checked
:
highlightsEnabled
type
:
"
checkbox
"
onChange
:
this
.
onPreferenceSelect
preference
:
"
feeds
.
section
.
highlights
"
eventSource
:
"
HIGHLIGHTS
"
"
aria
-
labelledby
"
:
"
custom
-
recent
-
title
"
"
aria
-
describedby
"
:
"
custom
-
recent
-
subtitle
"
}
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
slider
"
role
:
"
presentation
"
}
)
)
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
h2
"
{
id
:
"
custom
-
recent
-
title
"
className
:
"
title
"
}
external_React_default
(
)
.
createElement
(
"
label
"
{
htmlFor
:
"
highlights
-
toggle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
recent
-
title
"
}
)
)
external_React_default
(
)
.
createElement
(
"
p
"
{
id
:
"
custom
-
recent
-
subtitle
"
className
:
"
subtitle
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
recent
-
subtitle
"
}
)
)
)
external_React_default
(
)
.
createElement
(
"
span
"
{
className
:
"
divider
"
role
:
"
separator
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
"
button
"
{
id
:
"
settings
-
link
"
className
:
"
external
-
link
"
onClick
:
openPreferences
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
settings
"
}
)
)
)
;
}
}
;
class
_CustomizeMenu
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onEntered
=
this
.
onEntered
.
bind
(
this
)
;
this
.
onExited
=
this
.
onExited
.
bind
(
this
)
;
}
onEntered
(
)
{
if
(
this
.
closeButton
)
{
this
.
closeButton
.
focus
(
)
;
}
}
onExited
(
)
{
if
(
this
.
openButton
)
{
this
.
openButton
.
focus
(
)
;
}
}
render
(
)
{
return
external_React_default
(
)
.
createElement
(
"
span
"
null
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
CSSTransition
{
timeout
:
300
classNames
:
"
personalize
-
animate
"
in
:
!
this
.
props
.
showing
appear
:
true
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
"
icon
icon
-
settings
personalize
-
button
"
onClick
:
(
)
=
>
this
.
props
.
onOpen
(
)
"
data
-
l10n
-
id
"
:
"
newtab
-
personalize
-
icon
-
label
"
ref
:
c
=
>
this
.
openButton
=
c
}
)
)
external_React_default
(
)
.
createElement
(
external_ReactTransitionGroup_namespaceObject
.
CSSTransition
{
timeout
:
250
classNames
:
"
customize
-
animate
"
in
:
this
.
props
.
showing
onEntered
:
this
.
onEntered
onExited
:
this
.
onExited
appear
:
true
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
customize
-
menu
"
role
:
"
dialog
"
"
data
-
l10n
-
id
"
:
"
newtab
-
personalize
-
dialog
-
label
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
onClick
:
(
)
=
>
this
.
props
.
onClose
(
)
className
:
"
close
-
button
"
"
data
-
l10n
-
id
"
:
"
newtab
-
custom
-
close
-
button
"
ref
:
c
=
>
this
.
closeButton
=
c
}
)
external_React_default
(
)
.
createElement
(
BackgroundsSection
null
)
external_React_default
(
)
.
createElement
(
ContentSection
{
openPreferences
:
this
.
props
.
openPreferences
setPref
:
this
.
props
.
setPref
enabledSections
:
this
.
props
.
enabledSections
pocketRegion
:
this
.
props
.
pocketRegion
mayHaveSponsoredTopSites
:
this
.
props
.
mayHaveSponsoredTopSites
mayHaveSponsoredStories
:
this
.
props
.
DiscoveryStream
.
config
.
show_spocs
mayHaveRecentSaves
:
this
.
props
.
DiscoveryStream
.
recentSavesEnabled
dispatch
:
this
.
props
.
dispatch
}
)
)
)
)
;
}
}
const
CustomizeMenu
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
DiscoveryStream
:
state
.
DiscoveryStream
}
)
)
(
_CustomizeMenu
)
;
;
function
Search_extends
(
)
{
Search_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
Search_extends
.
apply
(
this
arguments
)
;
}
class
_Search
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
onSearchClick
=
this
.
onSearchClick
.
bind
(
this
)
;
this
.
onSearchHandoffClick
=
this
.
onSearchHandoffClick
.
bind
(
this
)
;
this
.
onSearchHandoffPaste
=
this
.
onSearchHandoffPaste
.
bind
(
this
)
;
this
.
onSearchHandoffDrop
=
this
.
onSearchHandoffDrop
.
bind
(
this
)
;
this
.
onInputMount
=
this
.
onInputMount
.
bind
(
this
)
;
this
.
onInputMountHandoff
=
this
.
onInputMountHandoff
.
bind
(
this
)
;
this
.
onSearchHandoffButtonMount
=
this
.
onSearchHandoffButtonMount
.
bind
(
this
)
;
}
handleEvent
(
event
)
{
if
(
event
.
detail
.
type
=
=
=
"
Search
"
)
{
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
SEARCH
"
}
)
)
;
}
}
onSearchClick
(
event
)
{
window
.
gContentSearchController
.
search
(
event
)
;
}
doSearchHandoff
(
text
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
HANDOFF_SEARCH_TO_AWESOMEBAR
data
:
{
text
}
}
)
)
;
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
FAKE_FOCUS_SEARCH
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
SEARCH_HANDOFF
"
}
)
)
;
if
(
text
)
{
this
.
props
.
dispatch
(
{
type
:
actionTypes
.
DISABLE_SEARCH
}
)
;
}
}
onSearchHandoffClick
(
event
)
{
event
.
preventDefault
(
)
;
this
.
doSearchHandoff
(
)
;
}
onSearchHandoffPaste
(
event
)
{
event
.
preventDefault
(
)
;
this
.
doSearchHandoff
(
event
.
clipboardData
.
getData
(
"
Text
"
)
)
;
}
onSearchHandoffDrop
(
event
)
{
event
.
preventDefault
(
)
;
let
text
=
event
.
dataTransfer
.
getData
(
"
text
"
)
;
if
(
text
)
{
this
.
doSearchHandoff
(
text
)
;
}
}
componentWillUnmount
(
)
{
delete
window
.
gContentSearchController
;
}
onInputMount
(
input
)
{
if
(
input
)
{
const
healthReportKey
=
IS_NEWTAB
?
"
newtab
"
:
"
abouthome
"
;
const
searchSource
=
IS_NEWTAB
?
"
newtab
"
:
"
homepage
"
;
window
.
gContentSearchController
=
new
ContentSearchUIController
(
input
input
.
parentNode
healthReportKey
searchSource
)
;
addEventListener
(
"
ContentSearchClient
"
this
)
;
}
else
{
window
.
gContentSearchController
=
null
;
removeEventListener
(
"
ContentSearchClient
"
this
)
;
}
}
onInputMountHandoff
(
input
)
{
if
(
input
)
{
this
.
_handoffSearchController
=
new
ContentSearchHandoffUIController
(
)
;
}
}
getDefaultEngineName
(
)
{
return
this
.
props
.
Prefs
.
values
[
"
urlbar
.
placeholderName
"
]
;
}
getHandoffInputL10nAttributes
(
)
{
let
defaultEngineName
=
this
.
getDefaultEngineName
(
)
;
return
defaultEngineName
?
{
"
data
-
l10n
-
id
"
:
"
newtab
-
search
-
box
-
handoff
-
input
"
"
data
-
l10n
-
args
"
:
{
"
engine
"
:
"
{
defaultEngineName
}
"
}
}
:
{
"
data
-
l10n
-
id
"
:
"
newtab
-
search
-
box
-
handoff
-
input
-
no
-
engine
"
}
;
}
getHandoffTextL10nAttributes
(
)
{
let
defaultEngineName
=
this
.
getDefaultEngineName
(
)
;
return
defaultEngineName
?
{
"
data
-
l10n
-
id
"
:
"
newtab
-
search
-
box
-
handoff
-
text
"
"
data
-
l10n
-
args
"
:
{
"
engine
"
:
"
{
defaultEngineName
}
"
}
}
:
{
"
data
-
l10n
-
id
"
:
"
newtab
-
search
-
box
-
handoff
-
text
-
no
-
engine
"
}
;
}
onSearchHandoffButtonMount
(
button
)
{
this
.
_searchHandoffButton
=
button
;
}
render
(
)
{
const
wrapperClassName
=
[
"
search
-
wrapper
"
this
.
props
.
disable
&
&
"
search
-
disabled
"
this
.
props
.
fakeFocus
&
&
"
fake
-
focus
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
return
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
wrapperClassName
}
this
.
props
.
showLogo
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
logo
-
and
-
wordmark
"
}
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
logo
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
wordmark
"
}
)
)
!
this
.
props
.
handoffEnabled
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
search
-
inner
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
input
"
{
id
:
"
newtab
-
search
-
text
"
"
data
-
l10n
-
id
"
:
"
newtab
-
search
-
box
-
input
"
maxLength
:
"
256
"
ref
:
this
.
onInputMount
type
:
"
search
"
}
)
external_React_default
(
)
.
createElement
(
"
button
"
{
id
:
"
searchSubmit
"
className
:
"
search
-
button
"
"
data
-
l10n
-
id
"
:
"
newtab
-
search
-
box
-
search
-
button
"
onClick
:
this
.
onSearchClick
}
)
)
this
.
props
.
handoffEnabled
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
search
-
inner
-
wrapper
"
}
external_React_default
(
)
.
createElement
(
"
button
"
Search_extends
(
{
className
:
"
search
-
handoff
-
button
"
}
this
.
getHandoffInputL10nAttributes
(
)
{
ref
:
this
.
onSearchHandoffButtonMount
onClick
:
this
.
onSearchHandoffClick
tabIndex
:
"
-
1
"
}
)
external_React_default
(
)
.
createElement
(
"
div
"
Search_extends
(
{
className
:
"
fake
-
textbox
"
}
this
.
getHandoffTextL10nAttributes
(
)
)
)
external_React_default
(
)
.
createElement
(
"
input
"
{
type
:
"
search
"
className
:
"
fake
-
editable
"
tabIndex
:
"
-
1
"
"
aria
-
hidden
"
:
"
true
"
onDrop
:
this
.
onSearchHandoffDrop
onPaste
:
this
.
onSearchHandoffPaste
ref
:
this
.
onInputMountHandoff
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
fake
-
caret
"
}
)
)
)
)
;
}
}
const
Search_Search
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
Prefs
:
state
.
Prefs
}
)
)
(
_Search
)
;
;
function
Base_extends
(
)
{
Base_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
return
Base_extends
.
apply
(
this
arguments
)
;
}
const
PrefsButton
=
(
{
onClick
icon
}
)
=
>
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
prefs
-
button
"
}
external_React_default
(
)
.
createElement
(
"
button
"
{
className
:
icon
{
icon
|
|
"
icon
-
settings
"
}
onClick
:
onClick
"
data
-
l10n
-
id
"
:
"
newtab
-
settings
-
button
"
}
)
)
;
function
debounce
(
func
wait
)
{
let
timer
;
return
(
.
.
.
args
)
=
>
{
if
(
timer
)
{
return
;
}
let
wakeUp
=
(
)
=
>
{
timer
=
null
;
}
;
timer
=
setTimeout
(
wakeUp
wait
)
;
func
.
apply
(
this
args
)
;
}
;
}
class
_Base
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
message
:
{
}
}
;
this
.
notifyContent
=
this
.
notifyContent
.
bind
(
this
)
;
}
notifyContent
(
state
)
{
this
.
setState
(
state
)
;
}
componentWillUnmount
(
)
{
this
.
updateTheme
(
)
;
}
componentWillUpdate
(
)
{
this
.
updateTheme
(
)
;
}
updateTheme
(
)
{
const
bodyClassName
=
[
"
activity
-
stream
"
document
.
body
.
classList
.
contains
(
"
inline
-
onboarding
"
)
?
"
inline
-
onboarding
"
:
"
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
__webpack_require__
.
g
.
document
.
body
.
className
=
bodyClassName
;
}
render
(
)
{
const
{
props
}
=
this
;
const
{
App
}
=
props
;
const
isDevtoolsEnabled
=
props
.
Prefs
.
values
[
"
asrouter
.
devtoolsEnabled
"
]
;
if
(
!
App
.
initialized
)
{
return
null
;
}
return
external_React_default
(
)
.
createElement
(
ErrorBoundary
{
className
:
"
base
-
content
-
fallback
"
}
external_React_default
(
)
.
createElement
(
(
external_React_default
(
)
)
.
Fragment
null
external_React_default
(
)
.
createElement
(
BaseContent
Base_extends
(
{
}
this
.
props
{
adminContent
:
this
.
state
}
)
)
isDevtoolsEnabled
?
external_React_default
(
)
.
createElement
(
ASRouterAdmin
{
notifyContent
:
this
.
notifyContent
}
)
:
null
)
)
;
}
}
class
BaseContent
extends
(
external_React_default
(
)
)
.
PureComponent
{
constructor
(
props
)
{
super
(
props
)
;
this
.
openPreferences
=
this
.
openPreferences
.
bind
(
this
)
;
this
.
openCustomizationMenu
=
this
.
openCustomizationMenu
.
bind
(
this
)
;
this
.
closeCustomizationMenu
=
this
.
closeCustomizationMenu
.
bind
(
this
)
;
this
.
handleOnKeyDown
=
this
.
handleOnKeyDown
.
bind
(
this
)
;
this
.
onWindowScroll
=
debounce
(
this
.
onWindowScroll
.
bind
(
this
)
5
)
;
this
.
setPref
=
this
.
setPref
.
bind
(
this
)
;
this
.
state
=
{
fixedSearch
:
false
customizeMenuVisible
:
false
}
;
}
componentDidMount
(
)
{
__webpack_require__
.
g
.
addEventListener
(
"
scroll
"
this
.
onWindowScroll
)
;
__webpack_require__
.
g
.
addEventListener
(
"
keydown
"
this
.
handleOnKeyDown
)
;
}
componentWillUnmount
(
)
{
__webpack_require__
.
g
.
removeEventListener
(
"
scroll
"
this
.
onWindowScroll
)
;
__webpack_require__
.
g
.
removeEventListener
(
"
keydown
"
this
.
handleOnKeyDown
)
;
}
onWindowScroll
(
)
{
const
prefs
=
this
.
props
.
Prefs
.
values
;
const
SCROLL_THRESHOLD
=
prefs
[
"
logowordmark
.
alwaysVisible
"
]
?
179
:
34
;
if
(
__webpack_require__
.
g
.
scrollY
>
SCROLL_THRESHOLD
&
&
!
this
.
state
.
fixedSearch
)
{
this
.
setState
(
{
fixedSearch
:
true
}
)
;
}
else
if
(
__webpack_require__
.
g
.
scrollY
<
=
SCROLL_THRESHOLD
&
&
this
.
state
.
fixedSearch
)
{
this
.
setState
(
{
fixedSearch
:
false
}
)
;
}
}
openPreferences
(
)
{
this
.
props
.
dispatch
(
actionCreators
.
OnlyToMain
(
{
type
:
actionTypes
.
SETTINGS_OPEN
}
)
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
OPEN_NEWTAB_PREFS
"
}
)
)
;
}
openCustomizationMenu
(
)
{
this
.
setState
(
{
customizeMenuVisible
:
true
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
SHOW_PERSONALIZE
"
}
)
)
;
}
closeCustomizationMenu
(
)
{
if
(
this
.
state
.
customizeMenuVisible
)
{
this
.
setState
(
{
customizeMenuVisible
:
false
}
)
;
this
.
props
.
dispatch
(
actionCreators
.
UserEvent
(
{
event
:
"
HIDE_PERSONALIZE
"
}
)
)
;
}
}
handleOnKeyDown
(
e
)
{
if
(
e
.
key
=
=
=
"
Escape
"
)
{
this
.
closeCustomizationMenu
(
)
;
}
}
setPref
(
pref
value
)
{
this
.
props
.
dispatch
(
actionCreators
.
SetPref
(
pref
value
)
)
;
}
render
(
)
{
const
{
props
}
=
this
;
const
{
App
}
=
props
;
const
{
initialized
}
=
App
;
const
prefs
=
props
.
Prefs
.
values
;
const
isDiscoveryStream
=
props
.
DiscoveryStream
.
config
&
&
props
.
DiscoveryStream
.
config
.
enabled
;
let
filteredSections
=
props
.
Sections
.
filter
(
section
=
>
section
.
id
!
=
=
"
topstories
"
)
;
const
pocketEnabled
=
prefs
[
"
feeds
.
section
.
topstories
"
]
&
&
prefs
[
"
feeds
.
system
.
topstories
"
]
;
const
noSectionsEnabled
=
!
prefs
[
"
feeds
.
topsites
"
]
&
&
!
pocketEnabled
&
&
filteredSections
.
filter
(
section
=
>
section
.
enabled
)
.
length
=
=
=
0
;
const
searchHandoffEnabled
=
prefs
[
"
improvesearch
.
handoffToAwesomebar
"
]
;
const
showCustomizationMenu
=
this
.
state
.
customizeMenuVisible
;
const
enabledSections
=
{
topSitesEnabled
:
prefs
[
"
feeds
.
topsites
"
]
pocketEnabled
:
prefs
[
"
feeds
.
section
.
topstories
"
]
highlightsEnabled
:
prefs
[
"
feeds
.
section
.
highlights
"
]
showSponsoredTopSitesEnabled
:
prefs
.
showSponsoredTopSites
showSponsoredPocketEnabled
:
prefs
.
showSponsored
showRecentSavesEnabled
:
prefs
.
showRecentSaves
topSitesRowsCount
:
prefs
.
topSitesRows
}
;
const
pocketRegion
=
prefs
[
"
feeds
.
system
.
topstories
"
]
;
const
{
mayHaveSponsoredTopSites
}
=
prefs
;
const
outerClassName
=
[
"
outer
-
wrapper
"
isDiscoveryStream
&
&
pocketEnabled
&
&
"
ds
-
outer
-
wrapper
-
search
-
alignment
"
isDiscoveryStream
&
&
"
ds
-
outer
-
wrapper
-
breakpoint
-
override
"
prefs
.
showSearch
&
&
this
.
state
.
fixedSearch
&
&
!
noSectionsEnabled
&
&
"
fixed
-
search
"
prefs
.
showSearch
&
&
noSectionsEnabled
&
&
"
only
-
search
"
prefs
[
"
logowordmark
.
alwaysVisible
"
]
&
&
"
visible
-
logo
"
]
.
filter
(
v
=
>
v
)
.
join
(
"
"
)
;
const
hasSnippet
=
prefs
[
"
feeds
.
snippets
"
]
&
&
this
.
props
.
adminContent
&
&
this
.
props
.
adminContent
.
message
&
&
this
.
props
.
adminContent
.
message
.
id
;
return
external_React_default
(
)
.
createElement
(
"
div
"
null
external_React_default
(
)
.
createElement
(
CustomizeMenu
{
onClose
:
this
.
closeCustomizationMenu
onOpen
:
this
.
openCustomizationMenu
openPreferences
:
this
.
openPreferences
setPref
:
this
.
setPref
enabledSections
:
enabledSections
pocketRegion
:
pocketRegion
mayHaveSponsoredTopSites
:
mayHaveSponsoredTopSites
showing
:
showCustomizationMenu
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
outerClassName
onClick
:
this
.
closeCustomizationMenu
}
external_React_default
(
)
.
createElement
(
"
main
"
{
className
:
hasSnippet
?
"
has
-
snippet
"
:
"
"
}
prefs
.
showSearch
&
&
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
"
non
-
collapsible
-
section
"
}
external_React_default
(
)
.
createElement
(
ErrorBoundary
null
external_React_default
(
)
.
createElement
(
Search_Search
Base_extends
(
{
showLogo
:
noSectionsEnabled
|
|
prefs
[
"
logowordmark
.
alwaysVisible
"
]
handoffEnabled
:
searchHandoffEnabled
}
props
.
Search
)
)
)
)
external_React_default
(
)
.
createElement
(
ASRouterUISurface
{
adminContent
:
this
.
props
.
adminContent
appUpdateChannel
:
this
.
props
.
Prefs
.
values
.
appUpdateChannel
fxaEndpoint
:
this
.
props
.
Prefs
.
values
.
fxa_endpoint
dispatch
:
this
.
props
.
dispatch
}
)
external_React_default
(
)
.
createElement
(
"
div
"
{
className
:
body
-
wrapper
{
initialized
?
"
on
"
:
"
"
}
}
isDiscoveryStream
?
external_React_default
(
)
.
createElement
(
ErrorBoundary
{
className
:
"
borderless
-
error
"
}
external_React_default
(
)
.
createElement
(
DiscoveryStreamBase
{
locale
:
props
.
App
.
locale
}
)
)
:
external_React_default
(
)
.
createElement
(
Sections_Sections
null
)
)
external_React_default
(
)
.
createElement
(
ConfirmDialog
null
)
)
)
)
;
}
}
const
Base
=
(
0
external_ReactRedux_namespaceObject
.
connect
)
(
state
=
>
(
{
App
:
state
.
App
Prefs
:
state
.
Prefs
Sections
:
state
.
Sections
DiscoveryStream
:
state
.
DiscoveryStream
Search
:
state
.
Search
}
)
)
(
_Base
)
;
;
const
detect_user_session_start_VISIBLE
=
"
visible
"
;
const
detect_user_session_start_VISIBILITY_CHANGE_EVENT
=
"
visibilitychange
"
;
class
DetectUserSessionStart
{
constructor
(
store
options
=
{
}
)
{
this
.
_store
=
store
;
this
.
document
=
options
.
document
|
|
__webpack_require__
.
g
.
document
;
this
.
_perfService
=
options
.
perfService
|
|
perfService
;
this
.
_onVisibilityChange
=
this
.
_onVisibilityChange
.
bind
(
this
)
;
}
sendEventOrAddListener
(
)
{
if
(
this
.
document
.
visibilityState
=
=
=
detect_user_session_start_VISIBLE
)
{
this
.
_sendEvent
(
)
;
}
else
{
this
.
document
.
addEventListener
(
detect_user_session_start_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
_sendEvent
(
)
{
this
.
_perfService
.
mark
(
"
visibility_event_rcvd_ts
"
)
;
try
{
let
visibility_event_rcvd_ts
=
this
.
_perfService
.
getMostRecentAbsMarkStartByName
(
"
visibility_event_rcvd_ts
"
)
;
this
.
_store
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
SAVE_SESSION_PERF_DATA
data
:
{
visibility_event_rcvd_ts
}
}
)
)
;
}
catch
(
ex
)
{
}
}
_onVisibilityChange
(
)
{
if
(
this
.
document
.
visibilityState
=
=
=
detect_user_session_start_VISIBLE
)
{
this
.
_sendEvent
(
)
;
this
.
document
.
removeEventListener
(
detect_user_session_start_VISIBILITY_CHANGE_EVENT
this
.
_onVisibilityChange
)
;
}
}
}
;
const
external_Redux_namespaceObject
=
Redux
;
;
const
MERGE_STORE_ACTION
=
"
NEW_TAB_INITIAL_STATE
"
;
const
OUTGOING_MESSAGE_NAME
=
"
ActivityStream
:
ContentToMain
"
;
const
INCOMING_MESSAGE_NAME
=
"
ActivityStream
:
MainToContent
"
;
const
EARLY_QUEUED_ACTIONS
=
[
actionTypes
.
SAVE_SESSION_PERF_DATA
]
;
function
mergeStateReducer
(
mainReducer
)
{
return
(
prevState
action
)
=
>
{
if
(
action
.
type
=
=
=
MERGE_STORE_ACTION
)
{
return
{
.
.
.
prevState
.
.
.
action
.
data
}
;
}
return
mainReducer
(
prevState
action
)
;
}
;
}
const
messageMiddleware
=
store
=
>
next
=
>
action
=
>
{
const
skipLocal
=
action
.
meta
&
&
action
.
meta
.
skipLocal
;
if
(
actionUtils
.
isSendToMain
(
action
)
)
{
RPMSendAsyncMessage
(
OUTGOING_MESSAGE_NAME
action
)
;
}
if
(
!
skipLocal
)
{
next
(
action
)
;
}
}
;
const
rehydrationMiddleware
=
(
{
getState
}
)
=
>
{
getState
.
didRehydrate
=
false
;
getState
.
didRequestInitialState
=
false
;
return
next
=
>
action
=
>
{
if
(
getState
.
didRehydrate
|
|
window
.
__FROM_STARTUP_CACHE__
)
{
if
(
window
.
__FROM_STARTUP_CACHE__
&
&
action
.
meta
&
&
action
.
meta
.
isStartup
)
{
return
null
;
}
return
next
(
action
)
;
}
const
isMergeStoreAction
=
action
.
type
=
=
=
MERGE_STORE_ACTION
;
const
isRehydrationRequest
=
action
.
type
=
=
=
actionTypes
.
NEW_TAB_STATE_REQUEST
;
if
(
isRehydrationRequest
)
{
getState
.
didRequestInitialState
=
true
;
return
next
(
action
)
;
}
if
(
isMergeStoreAction
)
{
getState
.
didRehydrate
=
true
;
return
next
(
action
)
;
}
if
(
getState
.
didRequestInitialState
&
&
action
.
type
=
=
=
actionTypes
.
INIT
)
{
return
next
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
NEW_TAB_STATE_REQUEST
}
)
)
;
}
if
(
actionUtils
.
isBroadcastToContent
(
action
)
|
|
actionUtils
.
isSendToOneContent
(
action
)
|
|
actionUtils
.
isSendToPreloaded
(
action
)
)
{
return
null
;
}
return
next
(
action
)
;
}
;
}
;
const
queueEarlyMessageMiddleware
=
(
{
getState
}
)
=
>
{
getState
.
earlyActionQueue
=
[
]
;
getState
.
receivedFromMain
=
false
;
return
next
=
>
action
=
>
{
if
(
getState
.
receivedFromMain
)
{
next
(
action
)
;
}
else
if
(
actionUtils
.
isFromMain
(
action
)
)
{
next
(
action
)
;
getState
.
receivedFromMain
=
true
;
getState
.
earlyActionQueue
.
forEach
(
next
)
;
getState
.
earlyActionQueue
.
length
=
0
;
}
else
if
(
EARLY_QUEUED_ACTIONS
.
includes
(
action
.
type
)
)
{
getState
.
earlyActionQueue
.
push
(
action
)
;
}
else
{
next
(
action
)
;
}
}
;
}
;
function
initStore
(
reducers
initialState
)
{
const
store
=
(
0
external_Redux_namespaceObject
.
createStore
)
(
mergeStateReducer
(
(
0
external_Redux_namespaceObject
.
combineReducers
)
(
reducers
)
)
initialState
__webpack_require__
.
g
.
RPMAddMessageListener
&
&
(
0
external_Redux_namespaceObject
.
applyMiddleware
)
(
queueEarlyMessageMiddleware
rehydrationMiddleware
messageMiddleware
)
)
;
if
(
__webpack_require__
.
g
.
RPMAddMessageListener
)
{
__webpack_require__
.
g
.
RPMAddMessageListener
(
INCOMING_MESSAGE_NAME
msg
=
>
{
try
{
store
.
dispatch
(
msg
.
data
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Content
msg
:
"
msg
"
Dispatch
error
:
"
ex
)
;
dump
(
Content
msg
:
{
JSON
.
stringify
(
msg
)
}
\
nDispatch
error
:
{
ex
}
\
n
{
ex
.
stack
}
)
;
}
}
)
;
}
return
store
;
}
;
const
NewTab
=
(
{
store
}
)
=
>
external_React_default
(
)
.
createElement
(
external_ReactRedux_namespaceObject
.
Provider
{
store
:
store
}
external_React_default
(
)
.
createElement
(
Base
null
)
)
;
function
renderWithoutState
(
)
{
const
store
=
initStore
(
reducers
)
;
new
DetectUserSessionStart
(
store
)
.
sendEventOrAddListener
(
)
;
let
didRequest
=
false
;
let
requestIdleCallbackId
=
0
;
function
doRequest
(
)
{
if
(
!
didRequest
)
{
if
(
requestIdleCallbackId
)
{
cancelIdleCallback
(
requestIdleCallbackId
)
;
}
didRequest
=
true
;
store
.
dispatch
(
actionCreators
.
AlsoToMain
(
{
type
:
actionTypes
.
NEW_TAB_STATE_REQUEST
}
)
)
;
}
}
if
(
document
.
hidden
)
{
requestIdleCallbackId
=
requestIdleCallback
(
doRequest
)
;
addEventListener
(
"
visibilitychange
"
doRequest
{
once
:
true
}
)
;
}
else
{
doRequest
(
)
;
}
external_ReactDOM_default
(
)
.
hydrate
(
external_React_default
(
)
.
createElement
(
NewTab
{
store
:
store
}
)
document
.
getElementById
(
"
root
"
)
)
;
}
function
renderCache
(
initialState
)
{
const
store
=
initStore
(
reducers
initialState
)
;
new
DetectUserSessionStart
(
store
)
.
sendEventOrAddListener
(
)
;
external_ReactDOM_default
(
)
.
hydrate
(
external_React_default
(
)
.
createElement
(
NewTab
{
store
:
store
}
)
document
.
getElementById
(
"
root
"
)
)
;
}
NewtabRenderUtils
=
__webpack_exports__
;
}
)
(
)
;
