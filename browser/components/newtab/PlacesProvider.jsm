"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesProvider
"
]
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BinarySearch
"
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
EventEmitter
"
function
(
)
{
const
{
EventEmitter
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
event
-
emitter
.
js
"
{
}
)
;
return
EventEmitter
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gPrincipal
"
function
(
)
{
let
uri
=
Services
.
io
.
newURI
(
"
about
:
newtab
"
null
null
)
;
return
Services
.
scriptSecurityManager
.
getNoAppCodebasePrincipal
(
uri
)
;
}
)
;
const
HISTORY_RESULTS_LIMIT
=
100
;
let
LinkChecker
=
{
_cache
:
new
Map
(
)
get
flags
(
)
{
return
Ci
.
nsIScriptSecurityManager
.
DISALLOW_INHERIT_PRINCIPAL
|
Ci
.
nsIScriptSecurityManager
.
DONT_REPORT_ERRORS
;
}
checkLoadURI
:
function
LinkChecker_checkLoadURI
(
aURI
)
{
if
(
!
this
.
_cache
.
has
(
aURI
)
)
{
this
.
_cache
.
set
(
aURI
this
.
_doCheckLoadURI
(
aURI
)
)
;
}
return
this
.
_cache
.
get
(
aURI
)
;
}
_doCheckLoadURI
:
function
LinkChecker_doCheckLoadURI
(
aURI
)
{
let
result
=
false
;
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
gPrincipal
aURI
this
.
flags
)
;
result
=
true
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
result
;
}
}
;
const
LinkUtils
=
{
_sortProperties
:
[
"
frecency
"
"
lastVisitDate
"
"
url
"
]
compareLinks
:
function
LinkUtils_compareLinks
(
aLink1
aLink2
)
{
for
(
let
prop
of
LinkUtils
.
_sortProperties
)
{
if
(
!
aLink1
.
hasOwnProperty
(
prop
)
|
|
!
aLink2
.
hasOwnProperty
(
prop
)
)
{
throw
new
Error
(
"
Comparable
link
missing
required
property
:
"
+
prop
)
;
}
}
return
aLink2
.
frecency
-
aLink1
.
frecency
|
|
aLink2
.
lastVisitDate
-
aLink1
.
lastVisitDate
|
|
aLink1
.
url
.
localeCompare
(
aLink2
.
url
)
;
}
}
;
let
Links
=
function
Links
(
)
{
EventEmitter
.
decorate
(
this
)
;
}
;
Links
.
prototype
=
{
get
maxNumLinks
(
)
{
return
HISTORY_RESULTS_LIMIT
;
}
historyObserver
:
{
onDeleteURI
:
function
historyObserver_onDeleteURI
(
aURI
)
{
gLinks
.
emit
(
"
deleteURI
"
{
url
:
aURI
.
spec
}
)
;
}
onClearHistory
:
function
historyObserver_onClearHistory
(
)
{
gLinks
.
emit
(
"
clearHistory
"
)
;
}
onFrecencyChanged
:
function
historyObserver_onFrecencyChanged
(
aURI
aNewFrecency
aGUID
aHidden
aLastVisitDate
)
{
if
(
!
aHidden
&
&
aLastVisitDate
)
{
gLinks
.
emit
(
"
linkChanged
"
{
url
:
aURI
.
spec
frecency
:
aNewFrecency
lastVisitDate
:
aLastVisitDate
type
:
"
history
"
}
)
;
}
}
onManyFrecenciesChanged
:
function
historyObserver_onManyFrecenciesChanged
(
)
{
gLinks
.
emit
(
"
manyLinksChanged
"
)
;
}
onTitleChanged
:
function
historyObserver_onTitleChanged
(
aURI
aNewTitle
)
{
gLinks
.
emit
(
"
linkChanged
"
{
url
:
aURI
.
spec
title
:
aNewTitle
}
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsINavHistoryObserver
Ci
.
nsISupportsWeakReference
]
)
}
init
:
function
PlacesProvider_init
(
)
{
PlacesUtils
.
history
.
addObserver
(
this
.
historyObserver
true
)
;
}
destroy
:
function
PlacesProvider_destroy
(
)
{
PlacesUtils
.
history
.
removeObserver
(
this
.
historyObserver
)
;
}
getLinks
:
function
PlacesProvider_getLinks
(
)
{
let
getLinksPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
options
=
PlacesUtils
.
history
.
getNewQueryOptions
(
)
;
options
.
maxResults
=
this
.
maxNumLinks
;
options
.
sortingMode
=
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_FRECENCY_DESCENDING
;
let
links
=
[
]
;
let
queryHandlers
=
{
handleResult
:
function
(
aResultSet
)
{
for
(
let
row
=
aResultSet
.
getNextRow
(
)
;
row
;
row
=
aResultSet
.
getNextRow
(
)
)
{
let
url
=
row
.
getResultByIndex
(
1
)
;
if
(
LinkChecker
.
checkLoadURI
(
url
)
)
{
let
link
=
{
url
:
url
title
:
row
.
getResultByIndex
(
2
)
frecency
:
row
.
getResultByIndex
(
12
)
lastVisitDate
:
row
.
getResultByIndex
(
5
)
type
:
"
history
"
}
;
links
.
push
(
link
)
;
}
}
}
handleError
:
function
(
aError
)
{
reject
(
aError
)
;
}
handleCompletion
:
function
(
aReason
)
{
let
i
=
1
;
let
outOfOrder
=
[
]
;
while
(
i
<
links
.
length
)
{
if
(
LinkUtils
.
compareLinks
(
links
[
i
-
1
]
links
[
i
]
)
>
0
)
{
outOfOrder
.
push
(
links
.
splice
(
i
1
)
[
0
]
)
;
}
else
{
i
+
+
;
}
}
for
(
let
link
of
outOfOrder
)
{
i
=
BinarySearch
.
insertionIndexOf
(
LinkUtils
.
compareLinks
links
link
)
;
links
.
splice
(
i
0
link
)
;
}
resolve
(
links
)
;
}
}
;
let
query
=
PlacesUtils
.
history
.
getNewQuery
(
)
;
let
db
=
PlacesUtils
.
history
.
QueryInterface
(
Ci
.
nsPIPlacesDatabase
)
;
db
.
asyncExecuteLegacyQueries
(
[
query
]
1
options
queryHandlers
)
;
}
)
;
return
getLinksPromise
;
}
}
;
const
gLinks
=
new
Links
(
)
;
let
PlacesProvider
=
{
LinkChecker
:
LinkChecker
LinkUtils
:
LinkUtils
links
:
gLinks
}
;
