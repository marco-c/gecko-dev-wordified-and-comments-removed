"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PlacesProvider
"
]
;
const
{
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BinarySearch
"
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
EventEmitter
"
function
(
)
{
const
{
EventEmitter
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
{
}
)
;
return
EventEmitter
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gPrincipal
"
function
(
)
{
let
uri
=
Services
.
io
.
newURI
(
"
about
:
newtab
"
null
null
)
;
return
Services
.
scriptSecurityManager
.
getNoAppCodebasePrincipal
(
uri
)
;
}
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
const
HISTORY_RESULTS_LIMIT
=
100
;
let
LinkChecker
=
{
_cache
:
new
Map
(
)
get
flags
(
)
{
return
Ci
.
nsIScriptSecurityManager
.
DISALLOW_INHERIT_PRINCIPAL
|
Ci
.
nsIScriptSecurityManager
.
DONT_REPORT_ERRORS
;
}
checkLoadURI
:
function
LinkChecker_checkLoadURI
(
aURI
)
{
if
(
!
this
.
_cache
.
has
(
aURI
)
)
{
this
.
_cache
.
set
(
aURI
this
.
_doCheckLoadURI
(
aURI
)
)
;
}
return
this
.
_cache
.
get
(
aURI
)
;
}
_doCheckLoadURI
:
function
LinkChecker_doCheckLoadURI
(
aURI
)
{
let
result
=
false
;
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
gPrincipal
aURI
this
.
flags
)
;
result
=
true
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
result
;
}
}
;
let
Links
=
function
Links
(
)
{
EventEmitter
.
decorate
(
this
)
;
}
;
Links
.
prototype
=
{
get
maxNumLinks
(
)
{
return
HISTORY_RESULTS_LIMIT
;
}
historyObserver
:
{
onDeleteURI
:
function
historyObserver_onDeleteURI
(
aURI
)
{
gLinks
.
emit
(
"
deleteURI
"
{
url
:
aURI
.
spec
}
)
;
}
onClearHistory
:
function
historyObserver_onClearHistory
(
)
{
gLinks
.
emit
(
"
clearHistory
"
)
;
}
onFrecencyChanged
:
function
historyObserver_onFrecencyChanged
(
aURI
aNewFrecency
aGUID
aHidden
aLastVisitDate
)
{
if
(
!
aHidden
&
&
aLastVisitDate
)
{
gLinks
.
emit
(
"
linkChanged
"
{
url
:
aURI
.
spec
frecency
:
aNewFrecency
lastVisitDate
:
aLastVisitDate
type
:
"
history
"
}
)
;
}
}
onManyFrecenciesChanged
:
function
historyObserver_onManyFrecenciesChanged
(
)
{
gLinks
.
emit
(
"
manyLinksChanged
"
)
;
}
onTitleChanged
:
function
historyObserver_onTitleChanged
(
aURI
aNewTitle
)
{
gLinks
.
emit
(
"
linkChanged
"
{
url
:
aURI
.
spec
title
:
aNewTitle
}
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsINavHistoryObserver
Ci
.
nsISupportsWeakReference
]
)
}
init
:
function
PlacesProvider_init
(
)
{
PlacesUtils
.
history
.
addObserver
(
this
.
historyObserver
true
)
;
}
destroy
:
function
PlacesProvider_destroy
(
)
{
PlacesUtils
.
history
.
removeObserver
(
this
.
historyObserver
)
;
}
getLinks
:
Task
.
async
(
function
*
(
)
{
let
sqlQuery
=
SELECT
url
title
frecency
last_visit_date
as
lastVisitDate
"
history
"
as
type
FROM
moz_places
WHERE
frecency
in
(
SELECT
MAX
(
frecency
)
as
frecency
FROM
moz_places
WHERE
hidden
=
0
AND
last_visit_date
NOTNULL
GROUP
BY
+
rev_host
ORDER
BY
frecency
DESC
LIMIT
:
limit
)
GROUP
BY
rev_host
HAVING
MAX
(
lastVisitDate
)
ORDER
BY
frecency
DESC
lastVisitDate
DESC
url
;
let
links
=
yield
this
.
executePlacesQuery
(
sqlQuery
{
columns
:
[
"
url
"
"
title
"
"
lastVisitDate
"
"
frecency
"
"
type
"
]
params
:
{
limit
:
this
.
maxNumLinks
}
}
)
;
return
links
.
filter
(
link
=
>
LinkChecker
.
checkLoadURI
(
link
.
url
)
)
;
}
)
executePlacesQuery
:
Task
.
async
(
function
*
(
aSql
aOptions
=
{
}
)
{
let
{
columns
params
callback
}
=
aOptions
;
let
items
=
[
]
;
let
queryError
=
null
;
let
conn
=
yield
PlacesUtils
.
promiseDBConnection
(
)
;
yield
conn
.
executeCached
(
aSql
params
aRow
=
>
{
try
{
if
(
callback
)
{
callback
(
aRow
)
;
}
else
{
let
item
=
null
;
if
(
columns
&
&
Array
.
isArray
(
columns
)
)
{
item
=
{
}
;
columns
.
forEach
(
column
=
>
{
item
[
column
]
=
aRow
.
getResultByName
(
column
)
;
}
)
;
}
else
{
item
=
[
]
;
for
(
let
i
=
0
;
i
<
aRow
.
numEntries
;
i
+
+
)
{
item
.
push
(
aRow
.
getResultByIndex
(
i
)
)
;
}
}
items
.
push
(
item
)
;
}
}
catch
(
e
)
{
queryError
=
e
;
throw
StopIteration
;
}
}
)
;
if
(
queryError
)
{
throw
new
Error
(
queryError
)
;
}
return
items
;
}
)
}
;
const
gLinks
=
new
Links
(
)
;
let
PlacesProvider
=
{
LinkChecker
:
LinkChecker
links
:
gLinks
}
;
