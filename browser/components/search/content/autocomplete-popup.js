<
binding
id
=
"
browser
-
search
-
autocomplete
-
result
-
popup
"
extends
=
"
chrome
:
/
/
global
/
content
/
bindings
/
autocomplete
.
xml
#
autocomplete
-
rich
-
result
-
popup
"
>
<
content
ignorekeys
=
"
true
"
level
=
"
top
"
consumeoutsideclicks
=
"
never
"
>
<
xul
:
hbox
anonid
=
"
searchbar
-
engine
"
xbl
:
inherits
=
"
showonlysettings
"
class
=
"
search
-
panel
-
header
search
-
panel
-
current
-
engine
"
>
<
xul
:
image
class
=
"
searchbar
-
engine
-
image
"
xbl
:
inherits
=
"
src
"
/
>
<
xul
:
label
anonid
=
"
searchbar
-
engine
-
name
"
flex
=
"
1
"
crop
=
"
end
"
role
=
"
presentation
"
/
>
<
/
xul
:
hbox
>
<
xul
:
richlistbox
anonid
=
"
richlistbox
"
class
=
"
autocomplete
-
richlistbox
search
-
panel
-
tree
"
flex
=
"
1
"
/
>
<
xul
:
hbox
anonid
=
"
search
-
one
-
off
-
buttons
"
class
=
"
search
-
one
-
offs
"
/
>
<
/
content
>
<
implementation
>
<
method
name
=
"
openAutocompletePopup
"
>
<
parameter
name
=
"
aInput
"
/
>
<
parameter
name
=
"
aElement
"
/
>
<
body
>
<
!
[
CDATA
[
aInput
.
popup
.
hidden
=
false
;
this
.
_openAutocompletePopup
(
aInput
aElement
)
;
]
]
>
<
/
body
>
<
/
method
>
<
method
name
=
"
onPopupClick
"
>
<
parameter
name
=
"
aEvent
"
/
>
<
body
>
<
!
[
CDATA
[
if
(
aEvent
.
button
=
=
2
)
return
;
let
searchBar
=
BrowserSearch
.
searchBar
;
let
popupForSearchBar
=
searchBar
&
&
searchBar
.
textbox
=
=
this
.
mInput
;
if
(
popupForSearchBar
)
{
searchBar
.
telemetrySearchDetails
=
{
index
:
this
.
selectedIndex
kind
:
"
mouse
"
}
;
}
if
(
aEvent
.
button
=
=
0
&
&
!
aEvent
.
shiftKey
&
&
!
aEvent
.
ctrlKey
&
&
!
aEvent
.
altKey
&
&
!
aEvent
.
metaKey
)
{
this
.
input
.
controller
.
handleEnter
(
true
aEvent
)
;
return
;
}
if
(
popupForSearchBar
)
{
BrowserUsageTelemetry
.
recordSearchbarSelectedResultMethod
(
aEvent
this
.
selectedIndex
)
;
let
search
=
this
.
input
.
controller
.
getValueAt
(
this
.
selectedIndex
)
;
let
where
=
whereToOpenLink
(
aEvent
false
true
)
;
let
params
=
{
}
;
let
modifier
=
AppConstants
.
platform
=
=
"
macosx
"
?
aEvent
.
metaKey
:
aEvent
.
ctrlKey
;
if
(
where
=
=
"
tab
"
&
&
(
aEvent
instanceof
MouseEvent
)
&
&
(
aEvent
.
button
=
=
1
|
|
modifier
)
)
params
.
inBackground
=
true
;
if
(
!
(
where
=
=
"
tab
"
&
&
params
.
inBackground
)
)
{
this
.
closePopup
(
)
;
this
.
input
.
controller
.
handleEscape
(
)
;
}
searchBar
.
doSearch
(
search
where
null
params
)
;
if
(
where
=
=
"
tab
"
&
&
params
.
inBackground
)
searchBar
.
focus
(
)
;
else
searchBar
.
value
=
search
;
}
]
]
>
<
/
body
>
<
/
method
>
<
!
-
-
Popup
rollup
is
triggered
by
native
events
before
the
mousedown
event
reaches
the
DOM
.
The
will
be
set
to
true
by
the
popuphiding
event
and
false
after
the
mousedown
event
has
been
triggered
to
detect
what
caused
rollup
.
-
-
>
<
field
name
=
"
_isHiding
"
>
false
<
/
field
>
<
field
name
=
"
_bundle
"
>
null
<
/
field
>
<
property
name
=
"
bundle
"
readonly
=
"
true
"
>
<
getter
>
<
!
[
CDATA
[
if
(
!
this
.
_bundle
)
{
const
kBundleURI
=
"
chrome
:
/
/
browser
/
locale
/
search
.
properties
"
;
this
.
_bundle
=
Services
.
strings
.
createBundle
(
kBundleURI
)
;
}
return
this
.
_bundle
;
]
]
>
<
/
getter
>
<
/
property
>
<
field
name
=
"
oneOffButtons
"
readonly
=
"
true
"
>
new
SearchOneOffs
(
document
.
getAnonymousElementByAttribute
(
this
"
anonid
"
"
search
-
one
-
off
-
buttons
"
)
)
;
<
/
field
>
<
method
name
=
"
updateHeader
"
>
<
body
>
<
!
[
CDATA
[
Services
.
search
.
getDefault
(
)
.
then
(
currentEngine
=
>
{
let
uri
=
currentEngine
.
iconURI
;
if
(
uri
)
{
this
.
setAttribute
(
"
src
"
uri
.
spec
)
;
}
else
{
this
.
removeAttribute
(
"
src
"
)
;
}
let
headerText
=
this
.
bundle
.
formatStringFromName
(
"
searchHeader
"
[
currentEngine
.
name
]
1
)
;
document
.
getAnonymousElementByAttribute
(
this
"
anonid
"
"
searchbar
-
engine
-
name
"
)
.
setAttribute
(
"
value
"
headerText
)
;
document
.
getAnonymousElementByAttribute
(
this
"
anonid
"
"
searchbar
-
engine
"
)
.
engine
=
currentEngine
;
}
)
;
]
]
>
<
/
body
>
<
/
method
>
<
!
-
-
This
is
called
when
a
one
-
off
is
clicked
and
when
"
search
in
new
tab
"
is
selected
from
a
one
-
off
context
menu
.
-
-
>
<
method
name
=
"
handleOneOffSearch
"
>
<
parameter
name
=
"
event
"
/
>
<
parameter
name
=
"
engine
"
/
>
<
parameter
name
=
"
where
"
/
>
<
parameter
name
=
"
params
"
/
>
<
body
>
<
!
[
CDATA
[
let
searchbar
=
document
.
getElementById
(
"
searchbar
"
)
;
searchbar
.
handleSearchCommandWhere
(
event
engine
where
params
)
;
]
]
>
<
/
body
>
<
/
method
>
<
/
implementation
>
<
handlers
>
<
handler
event
=
"
popupshowing
"
>
<
!
[
CDATA
[
let
DOMUtils
=
window
.
windowUtils
;
let
textboxRect
=
DOMUtils
.
getBoundsWithoutFlushing
(
this
.
mInput
)
;
let
inputRect
=
DOMUtils
.
getBoundsWithoutFlushing
(
this
.
mInput
.
inputField
)
;
let
minWidth
=
Math
.
max
(
textboxRect
.
width
this
.
oneOffButtons
.
buttonWidth
*
3
)
;
this
.
style
.
minWidth
=
Math
.
round
(
minWidth
)
+
"
px
"
;
this
.
style
.
marginLeft
=
(
textboxRect
.
left
-
inputRect
.
left
)
+
"
px
"
;
this
.
style
.
marginRight
=
(
inputRect
.
right
-
textboxRect
.
right
)
+
"
px
"
;
let
searchbar
=
document
.
getElementById
(
"
searchbar
"
)
;
if
(
searchbar
.
hasAttribute
(
"
showonlysettings
"
)
)
{
searchbar
.
removeAttribute
(
"
showonlysettings
"
)
;
this
.
setAttribute
(
"
showonlysettings
"
"
true
"
)
;
this
.
richlistbox
.
collapsed
=
true
;
}
else
{
this
.
removeAttribute
(
"
showonlysettings
"
)
;
this
.
richlistbox
.
collapsed
=
(
this
.
matchCount
=
=
0
)
;
}
this
.
updateHeader
(
)
;
]
]
>
<
/
handler
>
<
handler
event
=
"
popuphiding
"
>
<
!
[
CDATA
[
this
.
_isHiding
=
true
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
_isHiding
=
false
;
}
)
;
]
]
>
<
/
handler
>
<
!
-
-
This
handles
clicks
on
the
topmost
"
Foo
Search
"
header
in
the
popup
(
hbox
[
anonid
=
"
searchbar
-
engine
"
]
)
.
-
-
>
<
handler
event
=
"
click
"
>
<
!
[
CDATA
[
if
(
event
.
button
=
=
2
)
{
return
;
}
let
button
=
event
.
originalTarget
;
let
engine
=
button
.
parentNode
.
engine
;
if
(
!
engine
)
{
return
;
}
this
.
oneOffButtons
.
handleSearchCommand
(
event
engine
)
;
]
]
>
<
/
handler
>
<
/
handlers
>
<
/
binding
>
