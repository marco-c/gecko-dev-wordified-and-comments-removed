"
use
strict
"
;
{
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
SearchSuggestionController
:
"
resource
:
/
/
gre
/
modules
/
SearchSuggestionController
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
}
)
;
class
MozSearchbar
extends
MozXULElement
{
static
get
inheritedAttributes
(
)
{
return
{
"
.
searchbar
-
textbox
"
:
"
disabled
disableautocomplete
searchengine
src
newlines
"
"
.
searchbar
-
search
-
button
"
:
"
addengines
"
}
;
}
static
get
markup
(
)
{
return
<
stringbundle
src
=
"
chrome
:
/
/
browser
/
locale
/
search
.
properties
"
>
<
/
stringbundle
>
<
hbox
class
=
"
searchbar
-
search
-
button
"
data
-
l10n
-
id
=
"
searchbar
-
icon
"
>
<
image
class
=
"
searchbar
-
search
-
icon
"
>
<
/
image
>
<
image
class
=
"
searchbar
-
search
-
icon
-
overlay
"
>
<
/
image
>
<
/
hbox
>
<
html
:
input
class
=
"
searchbar
-
textbox
"
is
=
"
autocomplete
-
input
"
type
=
"
search
"
data
-
l10n
-
id
=
"
searchbar
-
input
"
autocompletepopup
=
"
PopupSearchAutoComplete
"
autocompletesearch
=
"
search
-
autocomplete
"
autocompletesearchparam
=
"
searchbar
-
history
"
maxrows
=
"
10
"
completeselectedindex
=
"
true
"
minresultsforpopup
=
"
0
"
/
>
<
menupopup
class
=
"
textbox
-
contextmenu
"
>
<
/
menupopup
>
<
hbox
class
=
"
search
-
go
-
container
"
align
=
"
center
"
>
<
image
class
=
"
search
-
go
-
button
urlbar
-
icon
"
hidden
=
"
true
"
onclick
=
"
handleSearchCommand
(
event
)
;
"
data
-
l10n
-
id
=
"
searchbar
-
submit
"
>
<
/
image
>
<
/
hbox
>
;
}
constructor
(
)
{
super
(
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
search
.
ftl
"
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
_setupEventListeners
(
)
;
let
searchbar
=
this
;
this
.
observer
=
{
observe
(
aEngine
aTopic
aVerb
)
{
if
(
aTopic
=
=
"
browser
-
search
-
engine
-
modified
"
|
|
(
aTopic
=
=
"
browser
-
search
-
service
"
&
&
aVerb
=
=
"
init
-
complete
"
)
)
{
searchbar
.
_engines
=
null
;
searchbar
.
_textbox
.
popup
.
updateHeader
(
)
;
searchbar
.
updateDisplay
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
}
;
this
.
_ignoreFocus
=
false
;
this
.
_engines
=
null
;
this
.
telemetrySelectedIndex
=
-
1
;
}
connectedCallback
(
)
{
if
(
this
.
closest
(
"
#
BrowserToolbarPalette
"
)
)
{
return
;
}
this
.
appendChild
(
this
.
constructor
.
fragment
)
;
this
.
initializeAttributeInheritance
(
)
;
if
(
this
.
parentNode
.
parentNode
.
localName
=
=
"
toolbarpaletteitem
"
)
{
return
;
}
let
storedWidth
=
Services
.
xulStore
.
getValue
(
document
.
documentURI
this
.
parentNode
.
id
"
width
"
)
;
if
(
storedWidth
)
{
this
.
parentNode
.
setAttribute
(
"
width
"
storedWidth
)
;
this
.
parentNode
.
style
.
width
=
storedWidth
+
"
px
"
;
}
this
.
_stringBundle
=
this
.
querySelector
(
"
stringbundle
"
)
;
this
.
_textbox
=
this
.
querySelector
(
"
.
searchbar
-
textbox
"
)
;
this
.
_menupopup
=
null
;
this
.
_pasteAndSearchMenuItem
=
null
;
this
.
_setupTextboxEventListeners
(
)
;
this
.
_initTextbox
(
)
;
window
.
addEventListener
(
"
unload
"
this
.
destroy
)
;
Services
.
obs
.
addObserver
(
this
.
observer
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
addObserver
(
this
.
observer
"
browser
-
search
-
service
"
)
;
this
.
_initialized
=
true
;
(
window
.
delayedStartupPromise
|
|
Promise
.
resolve
(
)
)
.
then
(
(
)
=
>
{
window
.
requestIdleCallback
(
(
)
=
>
{
Services
.
search
.
init
(
)
.
then
(
aStatus
=
>
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
updateDisplay
(
)
;
BrowserSearch
.
updateOpenSearchBadge
(
)
;
}
)
.
catch
(
status
=
>
console
.
error
(
"
Cannot
initialize
search
service
bailing
out
:
"
+
status
)
)
;
}
)
;
}
)
;
this
.
textbox
.
popup
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
let
oneOffButtons
=
this
.
textbox
.
popup
.
oneOffButtons
;
if
(
oneOffButtons
)
{
oneOffButtons
.
telemetryOrigin
=
"
searchbar
"
;
oneOffButtons
.
textbox
=
this
.
textbox
;
oneOffButtons
.
popup
=
this
.
textbox
.
popup
;
}
}
{
capture
:
true
once
:
true
}
)
;
}
async
getEngines
(
)
{
if
(
!
this
.
_engines
)
{
this
.
_engines
=
await
Services
.
search
.
getVisibleEngines
(
)
;
}
return
this
.
_engines
;
}
set
currentEngine
(
val
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
Services
.
search
.
setDefaultPrivate
(
val
Ci
.
nsISearchService
.
CHANGE_REASON_USER_SEARCHBAR
)
;
}
else
{
Services
.
search
.
setDefault
(
val
Ci
.
nsISearchService
.
CHANGE_REASON_USER_SEARCHBAR
)
;
}
}
get
currentEngine
(
)
{
let
currentEngine
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
currentEngine
=
Services
.
search
.
defaultPrivateEngine
;
}
else
{
currentEngine
=
Services
.
search
.
defaultEngine
;
}
return
currentEngine
|
|
{
name
:
"
"
uri
:
null
}
;
}
get
textbox
(
)
{
return
this
.
_textbox
;
}
set
value
(
val
)
{
this
.
_textbox
.
value
=
val
;
}
get
value
(
)
{
return
this
.
_textbox
.
value
;
}
destroy
(
)
{
if
(
this
.
_initialized
)
{
this
.
_initialized
=
false
;
window
.
removeEventListener
(
"
unload
"
this
.
destroy
)
;
Services
.
obs
.
removeObserver
(
this
.
observer
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
removeObserver
(
this
.
observer
"
browser
-
search
-
service
"
)
;
}
if
(
this
.
_textbox
&
&
this
.
_textbox
.
mController
&
&
this
.
_textbox
.
mController
.
input
&
&
this
.
_textbox
.
mController
.
input
.
wrappedJSObject
=
=
this
.
nsIAutocompleteInput
)
{
this
.
_textbox
.
mController
.
input
=
null
;
}
}
focus
(
)
{
this
.
_textbox
.
focus
(
)
;
}
select
(
)
{
this
.
_textbox
.
select
(
)
;
}
setIcon
(
element
uri
)
{
element
.
setAttribute
(
"
src
"
uri
)
;
}
updateDisplay
(
)
{
this
.
_textbox
.
title
=
this
.
_stringBundle
.
getFormattedString
(
"
searchtip
"
[
this
.
currentEngine
.
name
]
)
;
}
updateGoButtonVisibility
(
)
{
this
.
querySelector
(
"
.
search
-
go
-
button
"
)
.
hidden
=
!
this
.
_textbox
.
value
;
}
openSuggestionsPanel
(
aShowOnlySettingsIfEmpty
)
{
if
(
this
.
_textbox
.
open
)
{
return
;
}
this
.
_textbox
.
showHistoryPopup
(
)
;
if
(
this
.
_textbox
.
value
)
{
this
.
_textbox
.
mController
.
handleText
(
)
;
}
else
if
(
aShowOnlySettingsIfEmpty
)
{
this
.
setAttribute
(
"
showonlysettings
"
"
true
"
)
;
}
}
async
selectEngine
(
aEvent
isNextEngine
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
let
engines
=
await
this
.
getEngines
(
)
;
let
currentName
=
this
.
currentEngine
.
name
;
let
newIndex
=
-
1
;
let
lastIndex
=
engines
.
length
-
1
;
for
(
let
i
=
lastIndex
;
i
>
=
0
;
-
-
i
)
{
if
(
engines
[
i
]
.
name
=
=
currentName
)
{
if
(
!
isNextEngine
&
&
i
=
=
0
)
{
newIndex
=
lastIndex
;
}
else
if
(
isNextEngine
&
&
i
=
=
lastIndex
)
{
newIndex
=
0
;
}
else
{
newIndex
=
i
+
(
isNextEngine
?
1
:
-
1
)
;
}
break
;
}
}
this
.
currentEngine
=
engines
[
newIndex
]
;
this
.
openSuggestionsPanel
(
)
;
}
handleSearchCommand
(
aEvent
aEngine
aForceNewTab
)
{
let
where
=
"
current
"
;
let
params
;
const
newTabPref
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
openintab
"
)
;
if
(
aEvent
&
&
aEvent
.
originalTarget
.
classList
.
contains
(
"
search
-
go
-
button
"
)
)
{
if
(
aEvent
.
button
=
=
2
)
{
return
;
}
where
=
whereToOpenLink
(
aEvent
false
true
)
;
if
(
newTabPref
&
&
!
aEvent
.
altKey
&
&
!
aEvent
.
getModifierState
(
"
AltGraph
"
)
&
&
where
=
=
"
current
"
&
&
!
gBrowser
.
selectedTab
.
isEmpty
)
{
where
=
"
tab
"
;
}
}
else
if
(
aForceNewTab
)
{
where
=
"
tab
"
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
)
{
where
+
=
"
-
background
"
;
}
}
else
{
if
(
(
KeyboardEvent
.
isInstance
(
aEvent
)
&
&
(
aEvent
.
altKey
|
|
aEvent
.
getModifierState
(
"
AltGraph
"
)
)
)
^
newTabPref
&
&
!
gBrowser
.
selectedTab
.
isEmpty
)
{
where
=
"
tab
"
;
}
if
(
MouseEvent
.
isInstance
(
aEvent
)
&
&
(
aEvent
.
button
=
=
1
|
|
aEvent
.
getModifierState
(
"
Accel
"
)
)
)
{
where
=
"
tab
"
;
params
=
{
inBackground
:
true
}
;
}
}
this
.
handleSearchCommandWhere
(
aEvent
aEngine
where
params
)
;
}
handleSearchCommandWhere
(
aEvent
aEngine
aWhere
aParams
=
{
}
)
{
let
textBox
=
this
.
_textbox
;
let
textValue
=
textBox
.
value
;
let
selectedIndex
=
this
.
telemetrySelectedIndex
;
let
isOneOff
=
false
;
BrowserSearchTelemetry
.
recordSearchSuggestionSelectionMethod
(
aEvent
"
searchbar
"
selectedIndex
)
;
if
(
selectedIndex
=
=
-
1
)
{
isOneOff
=
this
.
textbox
.
popup
.
oneOffButtons
.
eventTargetIsAOneOff
(
aEvent
)
;
}
if
(
aWhere
=
=
=
"
tab
"
&
&
!
!
aParams
.
inBackground
)
{
aParams
.
avoidBrowserFocus
=
true
;
}
else
if
(
aWhere
!
=
=
"
window
"
&
&
aEvent
.
keyCode
=
=
=
KeyEvent
.
DOM_VK_RETURN
)
{
aParams
.
avoidBrowserFocus
=
true
;
this
.
_needBrowserFocusAtEnterKeyUp
=
true
;
}
this
.
doSearch
(
textValue
aWhere
aEngine
aParams
isOneOff
)
;
}
doSearch
(
aData
aWhere
aEngine
aParams
isOneOff
=
false
)
{
let
textBox
=
this
.
_textbox
;
let
engine
=
aEngine
|
|
this
.
currentEngine
;
if
(
aData
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
lazy
.
FormHistory
.
enabled
&
&
aData
.
length
<
=
lazy
.
SearchSuggestionController
.
SEARCH_HISTORY_MAX_VALUE_LENGTH
)
{
lazy
.
FormHistory
.
update
(
{
op
:
"
bump
"
fieldname
:
textBox
.
getAttribute
(
"
autocompletesearchparam
"
)
value
:
aData
source
:
engine
.
name
}
)
.
catch
(
error
=
>
console
.
error
(
"
Saving
search
to
form
history
failed
:
"
+
error
.
message
)
)
;
}
let
submission
=
engine
.
getSubmission
(
aData
null
"
searchbar
"
)
;
const
details
=
{
isOneOff
isSuggestion
:
!
isOneOff
&
&
this
.
telemetrySelectedIndex
!
=
-
1
url
:
submission
.
uri
}
;
this
.
telemetrySelectedIndex
=
-
1
;
BrowserSearchTelemetry
.
recordSearch
(
gBrowser
.
selectedBrowser
engine
"
searchbar
"
details
)
;
let
params
=
{
postData
:
submission
.
postData
globalHistoryOptions
:
{
triggeringSearchEngine
:
engine
.
name
}
}
;
if
(
aParams
)
{
for
(
let
key
in
aParams
)
{
params
[
key
]
=
aParams
[
key
]
;
}
}
openTrustedLinkIn
(
submission
.
uri
.
spec
aWhere
params
)
;
}
disconnectedCallback
(
)
{
this
.
destroy
(
)
;
while
(
this
.
firstChild
)
{
this
.
firstChild
.
remove
(
)
;
}
}
_maybeSelectAll
(
)
{
if
(
!
this
.
_preventClickSelectsAll
&
&
document
.
activeElement
=
=
this
.
_textbox
&
&
this
.
_textbox
.
selectionStart
=
=
this
.
_textbox
.
selectionEnd
)
{
this
.
select
(
)
;
}
}
_setupEventListeners
(
)
{
this
.
addEventListener
(
"
click
"
event
=
>
{
this
.
_maybeSelectAll
(
)
;
}
)
;
this
.
addEventListener
(
"
DOMMouseScroll
"
event
=
>
{
if
(
event
.
getModifierState
(
"
Accel
"
)
)
{
this
.
selectEngine
(
event
event
.
detail
>
0
)
;
}
}
true
)
;
this
.
addEventListener
(
"
input
"
event
=
>
{
this
.
updateGoButtonVisibility
(
)
;
}
)
;
this
.
addEventListener
(
"
drop
"
event
=
>
{
this
.
updateGoButtonVisibility
(
)
;
}
)
;
this
.
addEventListener
(
"
blur
"
event
=
>
{
this
.
_needBrowserFocusAtEnterKeyUp
=
false
;
this
.
_ignoreFocus
=
document
.
activeElement
=
=
this
.
_textbox
;
}
true
)
;
this
.
addEventListener
(
"
focus
"
event
=
>
{
this
.
currentEngine
.
speculativeConnect
(
{
window
originAttributes
:
gBrowser
.
contentPrincipal
.
originAttributes
}
)
;
if
(
this
.
_ignoreFocus
)
{
this
.
_ignoreFocus
=
false
;
return
;
}
if
(
!
this
.
_textbox
.
value
)
{
return
;
}
if
(
Services
.
focus
.
getLastFocusMethod
(
window
)
&
Services
.
focus
.
FLAG_BYMOUSE
)
{
return
;
}
this
.
openSuggestionsPanel
(
)
;
}
true
)
;
this
.
addEventListener
(
"
mousedown
"
event
=
>
{
this
.
_preventClickSelectsAll
=
this
.
_textbox
.
focused
;
if
(
event
.
button
!
=
0
)
{
return
;
}
if
(
event
.
originalTarget
.
classList
.
contains
(
"
search
-
go
-
button
"
)
)
{
return
;
}
if
(
event
.
originalTarget
.
localName
=
=
"
menuitem
"
)
{
return
;
}
let
isIconClick
=
event
.
originalTarget
.
classList
.
contains
(
"
searchbar
-
search
-
button
"
)
;
if
(
isIconClick
&
&
this
.
textbox
.
popup
.
popupOpen
)
{
this
.
textbox
.
popup
.
closePopup
(
)
;
}
else
if
(
isIconClick
|
|
this
.
_textbox
.
value
)
{
this
.
openSuggestionsPanel
(
true
)
;
}
}
)
;
}
_setupTextboxEventListeners
(
)
{
this
.
textbox
.
addEventListener
(
"
input
"
event
=
>
{
this
.
textbox
.
popup
.
removeAttribute
(
"
showonlysettings
"
)
;
}
)
;
this
.
textbox
.
addEventListener
(
"
dragover
"
event
=
>
{
let
types
=
event
.
dataTransfer
.
types
;
if
(
types
.
includes
(
"
text
/
plain
"
)
|
|
types
.
includes
(
"
text
/
x
-
moz
-
text
-
internal
"
)
)
{
event
.
preventDefault
(
)
;
}
}
)
;
this
.
textbox
.
addEventListener
(
"
drop
"
event
=
>
{
let
dataTransfer
=
event
.
dataTransfer
;
let
data
=
dataTransfer
.
getData
(
"
text
/
plain
"
)
;
if
(
!
data
)
{
data
=
dataTransfer
.
getData
(
"
text
/
x
-
moz
-
text
-
internal
"
)
;
}
if
(
data
)
{
event
.
preventDefault
(
)
;
this
.
textbox
.
value
=
data
;
this
.
openSuggestionsPanel
(
)
;
}
}
)
;
this
.
textbox
.
addEventListener
(
"
contextmenu
"
event
=
>
{
if
(
!
this
.
_menupopup
)
{
this
.
_buildContextMenu
(
)
;
}
this
.
_textbox
.
closePopup
(
)
;
if
(
event
.
button
)
{
this
.
_maybeSelectAll
(
)
;
}
for
(
let
item
of
this
.
_menupopup
.
querySelectorAll
(
"
menuitem
[
cmd
]
"
)
)
{
let
command
=
item
.
getAttribute
(
"
cmd
"
)
;
let
controller
=
document
.
commandDispatcher
.
getControllerForCommand
(
command
)
;
item
.
disabled
=
!
controller
.
isCommandEnabled
(
command
)
;
}
let
pasteEnabled
=
document
.
commandDispatcher
.
getControllerForCommand
(
"
cmd_paste
"
)
.
isCommandEnabled
(
"
cmd_paste
"
)
;
this
.
_pasteAndSearchMenuItem
.
disabled
=
!
pasteEnabled
;
this
.
_menupopup
.
openPopupAtScreen
(
event
.
screenX
event
.
screenY
true
)
;
event
.
preventDefault
(
)
;
}
)
;
}
_initTextbox
(
)
{
if
(
this
.
parentNode
.
parentNode
.
localName
=
=
"
toolbarpaletteitem
"
)
{
return
;
}
this
.
setAttribute
(
"
role
"
"
combobox
"
)
;
this
.
setAttribute
(
"
aria
-
owns
"
this
.
textbox
.
popup
.
id
)
;
Object
.
defineProperty
(
this
.
textbox
"
searchParam
"
{
get
(
)
{
return
(
this
.
getAttribute
(
"
autocompletesearchparam
"
)
+
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
?
"
|
private
"
:
"
"
)
)
;
}
set
(
val
)
{
this
.
setAttribute
(
"
autocompletesearchparam
"
val
)
;
}
}
)
;
Object
.
defineProperty
(
this
.
textbox
"
selectedButton
"
{
get
(
)
{
return
this
.
popup
.
oneOffButtons
.
selectedButton
;
}
set
(
val
)
{
this
.
popup
.
oneOffButtons
.
selectedButton
=
val
;
}
}
)
;
this
.
textbox
.
onBeforeValueSet
=
aValue
=
>
{
if
(
this
.
textbox
.
popup
.
_oneOffButtons
)
{
this
.
textbox
.
popup
.
oneOffButtons
.
query
=
aValue
;
}
return
aValue
;
}
;
this
.
textbox
.
onBeforeHandleKeyDown
=
aEvent
=
>
{
if
(
aEvent
.
getModifierState
(
"
Accel
"
)
)
{
if
(
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_DOWN
|
|
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_UP
)
{
this
.
selectEngine
(
aEvent
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_DOWN
)
;
return
true
;
}
return
false
;
}
if
(
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_F4
)
|
|
(
aEvent
.
getModifierState
(
"
Alt
"
)
&
&
(
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_DOWN
|
|
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_UP
)
)
)
{
if
(
!
this
.
textbox
.
openSearch
(
)
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
return
true
;
}
}
let
popup
=
this
.
textbox
.
popup
;
if
(
popup
.
popupOpen
)
{
let
suggestionsHidden
=
popup
.
richlistbox
.
getAttribute
(
"
collapsed
"
)
=
=
"
true
"
;
let
numItems
=
suggestionsHidden
?
0
:
popup
.
matchCount
;
return
popup
.
oneOffButtons
.
handleKeyDown
(
aEvent
numItems
true
)
;
}
else
if
(
aEvent
.
keyCode
=
=
KeyEvent
.
DOM_VK_ESCAPE
)
{
if
(
this
.
textbox
.
editor
.
canUndo
)
{
this
.
textbox
.
editor
.
undoAll
(
)
;
}
else
{
this
.
textbox
.
select
(
)
;
}
return
true
;
}
return
false
;
}
;
this
.
textbox
.
openPopup
=
(
)
=
>
{
if
(
document
.
documentElement
.
getAttribute
(
"
customizing
"
)
=
=
"
true
"
)
{
return
;
}
let
popup
=
this
.
textbox
.
popup
;
if
(
!
popup
.
mPopupOpen
)
{
popup
.
hidden
=
false
;
if
(
popup
.
id
=
=
"
PopupSearchAutoComplete
"
)
{
popup
.
setAttribute
(
"
norolluponanchor
"
"
true
"
)
;
}
popup
.
mInput
=
this
.
textbox
;
popup
.
selectedIndex
=
-
1
;
requestAnimationFrame
(
(
)
=
>
{
let
{
width
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
)
;
if
(
popup
.
oneOffButtons
)
{
width
=
Math
.
max
(
width
popup
.
oneOffButtons
.
buttonWidth
*
4
)
;
}
popup
.
style
.
setProperty
(
"
-
-
panel
-
width
"
width
+
"
px
"
)
;
}
)
;
popup
.
_invalidate
(
)
;
popup
.
openPopup
(
this
"
after_start
"
)
;
}
}
;
this
.
textbox
.
openSearch
=
(
)
=
>
{
if
(
!
this
.
textbox
.
popupOpen
)
{
this
.
openSuggestionsPanel
(
)
;
return
false
;
}
return
true
;
}
;
this
.
textbox
.
handleEnter
=
event
=
>
{
if
(
this
.
textbox
.
selectedButton
&
&
this
.
textbox
.
selectedButton
.
getAttribute
(
"
anonid
"
)
=
=
"
addengine
-
menu
-
button
"
)
{
this
.
textbox
.
selectedButton
.
open
=
!
this
.
textbox
.
selectedButton
.
open
;
return
true
;
}
return
this
.
textbox
.
mController
.
handleEnter
(
false
event
|
|
null
)
;
}
;
this
.
textbox
.
onTextEntered
=
event
=
>
{
this
.
textbox
.
editor
.
clearUndoRedo
(
)
;
let
engine
;
let
oneOff
=
this
.
textbox
.
selectedButton
;
if
(
oneOff
)
{
if
(
!
oneOff
.
engine
)
{
oneOff
.
doCommand
(
)
;
return
;
}
engine
=
oneOff
.
engine
;
}
if
(
this
.
textbox
.
popupSelectedIndex
!
=
-
1
)
{
this
.
telemetrySelectedIndex
=
this
.
textbox
.
popupSelectedIndex
;
this
.
textbox
.
popupSelectedIndex
=
-
1
;
}
this
.
handleSearchCommand
(
event
engine
)
;
}
;
this
.
textbox
.
onbeforeinput
=
event
=
>
{
if
(
event
.
data
&
&
this
.
_needBrowserFocusAtEnterKeyUp
)
{
event
.
preventDefault
(
)
;
}
}
;
this
.
textbox
.
onkeyup
=
event
=
>
{
if
(
this
.
_needBrowserFocusAtEnterKeyUp
)
{
this
.
_needBrowserFocusAtEnterKeyUp
=
false
;
gBrowser
.
selectedBrowser
.
focus
(
)
;
}
}
;
}
_buildContextMenu
(
)
{
const
raw
=
<
menuitem
data
-
l10n
-
id
=
"
text
-
action
-
undo
"
cmd
=
"
cmd_undo
"
/
>
<
menuitem
data
-
l10n
-
id
=
"
text
-
action
-
redo
"
cmd
=
"
cmd_redo
"
/
>
<
menuseparator
/
>
<
menuitem
data
-
l10n
-
id
=
"
text
-
action
-
cut
"
cmd
=
"
cmd_cut
"
/
>
<
menuitem
data
-
l10n
-
id
=
"
text
-
action
-
copy
"
cmd
=
"
cmd_copy
"
/
>
<
menuitem
data
-
l10n
-
id
=
"
text
-
action
-
paste
"
cmd
=
"
cmd_paste
"
/
>
<
menuitem
class
=
"
searchbar
-
paste
-
and
-
search
"
/
>
<
menuitem
data
-
l10n
-
id
=
"
text
-
action
-
delete
"
cmd
=
"
cmd_delete
"
/
>
<
menuitem
data
-
l10n
-
id
=
"
text
-
action
-
select
-
all
"
cmd
=
"
cmd_selectAll
"
/
>
<
menuseparator
/
>
<
menuitem
class
=
"
searchbar
-
clear
-
history
"
/
>
;
this
.
_menupopup
=
this
.
querySelector
(
"
.
textbox
-
contextmenu
"
)
;
let
frag
=
MozXULElement
.
parseXULToFragment
(
raw
)
;
this
.
_pasteAndSearchMenuItem
=
frag
.
querySelector
(
"
.
searchbar
-
paste
-
and
-
search
"
)
;
this
.
_pasteAndSearchMenuItem
.
setAttribute
(
"
label
"
this
.
_stringBundle
.
getString
(
"
cmd_pasteAndSearch
"
)
)
;
let
clearHistoryItem
=
frag
.
querySelector
(
"
.
searchbar
-
clear
-
history
"
)
;
clearHistoryItem
.
setAttribute
(
"
label
"
this
.
_stringBundle
.
getString
(
"
cmd_clearHistory
"
)
)
;
clearHistoryItem
.
setAttribute
(
"
accesskey
"
this
.
_stringBundle
.
getString
(
"
cmd_clearHistory_accesskey
"
)
)
;
this
.
_menupopup
.
appendChild
(
frag
)
;
this
.
_menupopup
.
addEventListener
(
"
command
"
event
=
>
{
switch
(
event
.
originalTarget
)
{
case
this
.
_pasteAndSearchMenuItem
:
this
.
select
(
)
;
goDoCommand
(
"
cmd_paste
"
)
;
this
.
handleSearchCommand
(
event
)
;
break
;
case
clearHistoryItem
:
let
param
=
this
.
textbox
.
getAttribute
(
"
autocompletesearchparam
"
)
;
lazy
.
FormHistory
.
update
(
{
op
:
"
remove
"
fieldname
:
param
}
)
;
this
.
textbox
.
value
=
"
"
;
break
;
default
:
let
cmd
=
event
.
originalTarget
.
getAttribute
(
"
cmd
"
)
;
if
(
cmd
)
{
let
controller
=
document
.
commandDispatcher
.
getControllerForCommand
(
cmd
)
;
controller
.
doCommand
(
cmd
)
;
}
break
;
}
}
)
;
}
}
customElements
.
define
(
"
searchbar
"
MozSearchbar
)
;
}
