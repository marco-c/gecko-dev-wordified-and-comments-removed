"
use
strict
"
;
{
const
inheritsMap
=
{
"
.
searchbar
-
textbox
"
:
[
"
disabled
"
"
disableautocomplete
"
"
searchengine
"
"
src
"
"
newlines
"
]
"
.
searchbar
-
search
-
button
"
:
[
"
addengines
"
]
}
;
function
inheritAttribute
(
parent
child
attr
)
{
if
(
!
parent
.
hasAttribute
(
attr
)
)
{
child
.
removeAttribute
(
attr
)
;
}
else
{
child
.
setAttribute
(
attr
parent
.
getAttribute
(
attr
)
)
;
}
}
class
MozSearchbar
extends
MozXULElement
{
static
get
observedAttributes
(
)
{
let
unique
=
new
Set
(
)
;
for
(
var
i
in
inheritsMap
)
{
inheritsMap
[
i
]
.
forEach
(
attr
=
>
unique
.
add
(
attr
)
)
;
}
return
Array
.
from
(
unique
)
;
}
attributeChangedCallback
(
)
{
this
.
inheritAttributes
(
)
;
}
inheritAttributes
(
)
{
if
(
!
this
.
isConnected
)
{
return
;
}
for
(
let
sel
in
inheritsMap
)
{
let
node
=
this
.
querySelector
(
sel
)
;
for
(
let
attr
of
inheritsMap
[
sel
]
)
{
inheritAttribute
(
this
node
attr
)
;
}
}
}
constructor
(
)
{
super
(
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
_setupEventListeners
(
)
;
let
searchbar
=
this
;
this
.
observer
=
{
observe
(
aEngine
aTopic
aVerb
)
{
if
(
aTopic
=
=
"
browser
-
search
-
engine
-
modified
"
|
|
(
aTopic
=
=
"
browser
-
search
-
service
"
&
&
aVerb
=
=
"
init
-
complete
"
)
)
{
searchbar
.
_engines
=
null
;
searchbar
.
_textbox
.
popup
.
updateHeader
(
)
;
searchbar
.
updateDisplay
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
}
;
this
.
content
=
MozXULElement
.
parseXULToFragment
(
<
stringbundle
src
=
"
chrome
:
/
/
browser
/
locale
/
search
.
properties
"
>
<
/
stringbundle
>
<
textbox
class
=
"
searchbar
-
textbox
"
type
=
"
autocomplete
"
inputtype
=
"
search
"
placeholder
=
"
&
searchInput
.
placeholder
;
"
flex
=
"
1
"
autocompletepopup
=
"
PopupSearchAutoComplete
"
autocompletesearch
=
"
search
-
autocomplete
"
autocompletesearchparam
=
"
searchbar
-
history
"
maxrows
=
"
10
"
completeselectedindex
=
"
true
"
minresultsforpopup
=
"
0
"
inherits
=
"
disabled
disableautocomplete
searchengine
src
newlines
"
>
<
box
>
<
hbox
class
=
"
searchbar
-
search
-
button
"
inherits
=
"
addengines
"
tooltiptext
=
"
&
searchIcon
.
tooltip
;
"
>
<
image
class
=
"
searchbar
-
search
-
icon
"
>
<
/
image
>
<
image
class
=
"
searchbar
-
search
-
icon
-
overlay
"
>
<
/
image
>
<
/
hbox
>
<
/
box
>
<
hbox
class
=
"
search
-
go
-
container
"
>
<
image
class
=
"
search
-
go
-
button
urlbar
-
icon
"
hidden
=
"
true
"
onclick
=
"
handleSearchCommand
(
event
)
;
"
tooltiptext
=
"
&
contentSearchSubmit
.
tooltip
;
"
>
<
/
image
>
<
/
hbox
>
<
/
textbox
>
[
"
chrome
:
/
/
browser
/
locale
/
browser
.
dtd
"
]
)
;
}
connectedCallback
(
)
{
if
(
this
.
closest
(
"
#
BrowserToolbarPalette
"
)
)
{
return
;
}
this
.
appendChild
(
document
.
importNode
(
this
.
content
true
)
)
;
this
.
inheritAttributes
(
)
;
window
.
addEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
_ignoreFocus
=
false
;
this
.
_clickClosedPopup
=
false
;
this
.
_stringBundle
=
this
.
querySelector
(
"
stringbundle
"
)
;
this
.
_textboxInitialized
=
false
;
this
.
_textbox
=
this
.
querySelector
(
"
.
searchbar
-
textbox
"
)
;
this
.
_engines
=
null
;
this
.
FormHistory
=
(
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
{
}
)
)
.
FormHistory
;
if
(
this
.
parentNode
.
parentNode
.
localName
=
=
"
toolbarpaletteitem
"
)
return
;
Services
.
obs
.
addObserver
(
this
.
observer
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
addObserver
(
this
.
observer
"
browser
-
search
-
service
"
)
;
this
.
_initialized
=
true
;
(
window
.
delayedStartupPromise
|
|
Promise
.
resolve
(
)
)
.
then
(
(
)
=
>
{
window
.
requestIdleCallback
(
(
)
=
>
{
Services
.
search
.
init
(
aStatus
=
>
{
if
(
!
this
.
_initialized
)
return
;
if
(
Components
.
isSuccessCode
(
aStatus
)
)
{
this
.
updateDisplay
(
)
;
BrowserSearch
.
updateOpenSearchBadge
(
)
;
}
else
{
Cu
.
reportError
(
"
Cannot
initialize
search
service
bailing
out
:
"
+
aStatus
)
;
}
}
)
;
}
)
;
}
)
;
this
.
textbox
.
popup
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
let
oneOffButtons
=
this
.
textbox
.
popup
.
oneOffButtons
;
if
(
oneOffButtons
)
{
oneOffButtons
.
telemetryOrigin
=
"
searchbar
"
;
oneOffButtons
.
textbox
=
this
.
textbox
;
oneOffButtons
.
popup
=
this
.
textbox
.
popup
;
}
}
{
capture
:
true
once
:
true
}
)
;
}
get
engines
(
)
{
if
(
!
this
.
_engines
)
this
.
_engines
=
Services
.
search
.
getVisibleEngines
(
)
;
return
this
.
_engines
;
}
set
currentEngine
(
val
)
{
Services
.
search
.
defaultEngine
=
val
;
return
val
;
}
get
currentEngine
(
)
{
var
currentEngine
=
Services
.
search
.
defaultEngine
;
return
currentEngine
|
|
{
name
:
"
"
uri
:
null
}
;
}
get
textbox
(
)
{
return
this
.
_textbox
;
}
set
value
(
val
)
{
return
this
.
_textbox
.
value
=
val
;
}
get
value
(
)
{
return
this
.
_textbox
.
value
;
}
destroy
(
)
{
if
(
this
.
_initialized
)
{
this
.
_initialized
=
false
;
window
.
removeEventListener
(
"
unload
"
this
.
destroy
)
;
Services
.
obs
.
removeObserver
(
this
.
observer
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
removeObserver
(
this
.
observer
"
browser
-
search
-
service
"
)
;
}
if
(
this
.
_textboxInitialized
&
&
this
.
_textbox
.
mController
.
input
=
=
this
)
this
.
_textbox
.
mController
.
input
=
null
;
}
focus
(
)
{
this
.
_textbox
.
focus
(
)
;
}
select
(
)
{
this
.
_textbox
.
select
(
)
;
}
setIcon
(
element
uri
)
{
element
.
setAttribute
(
"
src
"
uri
)
;
}
updateDisplay
(
)
{
var
uri
=
this
.
currentEngine
.
iconURI
;
this
.
setIcon
(
this
uri
?
uri
.
spec
:
"
"
)
;
var
name
=
this
.
currentEngine
.
name
;
var
text
=
this
.
_stringBundle
.
getFormattedString
(
"
searchtip
"
[
name
]
)
;
this
.
_textbox
.
label
=
text
;
this
.
_textbox
.
tooltipText
=
text
;
}
updateGoButtonVisibility
(
)
{
this
.
querySelector
(
"
.
search
-
go
-
button
"
)
.
hidden
=
!
this
.
_textbox
.
value
;
}
openSuggestionsPanel
(
aShowOnlySettingsIfEmpty
)
{
if
(
this
.
_textbox
.
open
)
return
;
this
.
_textbox
.
showHistoryPopup
(
)
;
if
(
this
.
_textbox
.
value
)
{
this
.
_textbox
.
mController
.
handleText
(
)
;
}
else
if
(
aShowOnlySettingsIfEmpty
)
{
this
.
setAttribute
(
"
showonlysettings
"
"
true
"
)
;
}
}
selectEngine
(
aEvent
isNextEngine
)
{
var
newIndex
=
this
.
engines
.
indexOf
(
this
.
currentEngine
)
;
newIndex
+
=
isNextEngine
?
1
:
-
1
;
if
(
newIndex
>
=
0
&
&
newIndex
<
this
.
engines
.
length
)
{
this
.
currentEngine
=
this
.
engines
[
newIndex
]
;
}
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
this
.
openSuggestionsPanel
(
)
;
}
handleSearchCommand
(
aEvent
aEngine
aForceNewTab
)
{
var
where
=
"
current
"
;
let
params
;
if
(
aEvent
&
&
aEvent
.
originalTarget
.
classList
.
contains
(
"
search
-
go
-
button
"
)
)
{
if
(
aEvent
.
button
=
=
2
)
return
;
where
=
whereToOpenLink
(
aEvent
false
true
)
;
}
else
if
(
aForceNewTab
)
{
where
=
"
tab
"
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
)
where
+
=
"
-
background
"
;
}
else
{
var
newTabPref
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
openintab
"
)
;
if
(
(
(
aEvent
instanceof
KeyboardEvent
&
&
aEvent
.
altKey
)
^
newTabPref
)
&
&
!
gBrowser
.
selectedTab
.
isEmpty
)
{
where
=
"
tab
"
;
}
if
(
(
aEvent
instanceof
MouseEvent
)
&
&
(
aEvent
.
button
=
=
1
|
|
aEvent
.
getModifierState
(
"
Accel
"
)
)
)
{
where
=
"
tab
"
;
params
=
{
inBackground
:
true
}
;
}
}
this
.
handleSearchCommandWhere
(
aEvent
aEngine
where
params
)
;
}
handleSearchCommandWhere
(
aEvent
aEngine
aWhere
aParams
)
{
var
textBox
=
this
.
_textbox
;
var
textValue
=
textBox
.
value
;
let
selection
=
this
.
telemetrySearchDetails
;
let
oneOffRecorded
=
false
;
BrowserUsageTelemetry
.
recordSearchbarSelectedResultMethod
(
aEvent
selection
?
selection
.
index
:
-
1
)
;
if
(
!
selection
|
|
(
selection
.
index
=
=
-
1
)
)
{
oneOffRecorded
=
this
.
textbox
.
popup
.
oneOffButtons
.
maybeRecordTelemetry
(
aEvent
aWhere
aParams
)
;
if
(
!
oneOffRecorded
)
{
let
source
=
"
unknown
"
;
let
type
=
"
unknown
"
;
let
target
=
aEvent
.
originalTarget
;
if
(
aEvent
instanceof
KeyboardEvent
)
{
type
=
"
key
"
;
}
else
if
(
aEvent
instanceof
MouseEvent
)
{
type
=
"
mouse
"
;
if
(
target
.
classList
.
contains
(
"
search
-
panel
-
header
"
)
|
|
target
.
parentNode
.
classList
.
contains
(
"
search
-
panel
-
header
"
)
)
{
source
=
"
header
"
;
}
}
else
if
(
aEvent
instanceof
XULCommandEvent
)
{
if
(
target
.
getAttribute
(
"
anonid
"
)
=
=
"
paste
-
and
-
search
"
)
{
source
=
"
paste
"
;
}
}
if
(
!
aEngine
)
{
aEngine
=
this
.
currentEngine
;
}
BrowserSearch
.
recordOneoffSearchInTelemetry
(
aEngine
source
type
aWhere
)
;
}
}
this
.
doSearch
(
textValue
aWhere
aEngine
aParams
oneOffRecorded
)
;
if
(
aWhere
=
=
"
tab
"
&
&
aParams
&
&
aParams
.
inBackground
)
this
.
focus
(
)
;
}
doSearch
(
aData
aWhere
aEngine
aParams
aOneOff
)
{
var
textBox
=
this
.
_textbox
;
if
(
aData
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
this
.
FormHistory
.
enabled
)
{
this
.
FormHistory
.
update
(
{
op
:
"
bump
"
fieldname
:
textBox
.
getAttribute
(
"
autocompletesearchparam
"
)
value
:
aData
}
{
handleError
(
aError
)
{
Cu
.
reportError
(
"
Saving
search
to
form
history
failed
:
"
+
aError
.
message
)
;
}
}
)
;
}
let
engine
=
aEngine
|
|
this
.
currentEngine
;
var
submission
=
engine
.
getSubmission
(
aData
null
"
searchbar
"
)
;
let
telemetrySearchDetails
=
this
.
telemetrySearchDetails
;
this
.
telemetrySearchDetails
=
null
;
if
(
telemetrySearchDetails
&
&
telemetrySearchDetails
.
index
=
=
-
1
)
{
telemetrySearchDetails
=
null
;
}
const
details
=
{
isOneOff
:
aOneOff
isSuggestion
:
(
!
aOneOff
&
&
telemetrySearchDetails
)
selection
:
telemetrySearchDetails
}
;
BrowserSearch
.
recordSearchInTelemetry
(
engine
"
searchbar
"
details
)
;
let
params
=
{
postData
:
submission
.
postData
}
;
if
(
aParams
)
{
for
(
let
key
in
aParams
)
{
params
[
key
]
=
aParams
[
key
]
;
}
}
openTrustedLinkIn
(
submission
.
uri
.
spec
aWhere
params
)
;
}
disconnectedCallback
(
)
{
this
.
destroy
(
)
;
while
(
this
.
firstChild
)
{
this
.
firstChild
.
remove
(
)
;
}
}
_setupEventListeners
(
)
{
this
.
addEventListener
(
"
command
"
(
event
)
=
>
{
const
target
=
event
.
originalTarget
;
if
(
target
.
engine
)
{
this
.
currentEngine
=
target
.
engine
;
}
else
if
(
target
.
classList
.
contains
(
"
addengine
-
item
"
)
)
{
var
installCallback
=
{
onSuccess
:
engine
=
>
this
.
currentEngine
=
engine
}
;
Services
.
search
.
addEngine
(
target
.
getAttribute
(
"
uri
"
)
null
target
.
getAttribute
(
"
src
"
)
false
installCallback
)
;
}
else
return
;
this
.
focus
(
)
;
this
.
select
(
)
;
}
)
;
this
.
addEventListener
(
"
DOMMouseScroll
"
(
event
)
=
>
{
if
(
event
.
getModifierState
(
"
Accel
"
)
)
{
this
.
selectEngine
(
event
event
.
detail
>
0
)
;
}
}
true
)
;
this
.
addEventListener
(
"
input
"
(
event
)
=
>
{
this
.
updateGoButtonVisibility
(
)
;
}
)
;
this
.
addEventListener
(
"
drop
"
(
event
)
=
>
{
this
.
updateGoButtonVisibility
(
)
;
}
)
;
this
.
addEventListener
(
"
blur
"
(
event
)
=
>
{
this
.
_ignoreFocus
=
(
document
.
activeElement
=
=
this
.
_textbox
.
inputField
)
;
}
true
)
;
this
.
addEventListener
(
"
focus
"
(
event
)
=
>
{
this
.
currentEngine
.
speculativeConnect
(
{
window
originAttributes
:
gBrowser
.
contentPrincipal
.
originAttributes
}
)
;
if
(
this
.
_ignoreFocus
)
{
this
.
_ignoreFocus
=
false
;
return
;
}
if
(
!
this
.
_textbox
.
value
)
return
;
if
(
Services
.
focus
.
getLastFocusMethod
(
window
)
&
Services
.
focus
.
FLAG_BYMOUSE
)
return
;
this
.
openSuggestionsPanel
(
)
;
}
true
)
;
this
.
addEventListener
(
"
mousedown
"
(
event
)
=
>
{
if
(
event
.
originalTarget
.
classList
.
contains
(
"
searchbar
-
search
-
button
"
)
)
{
this
.
_clickClosedPopup
=
this
.
_textbox
.
popup
.
_isHiding
;
}
}
true
)
;
this
.
addEventListener
(
"
mousedown
"
(
event
)
=
>
{
if
(
event
.
button
!
=
0
)
{
return
;
}
if
(
event
.
originalTarget
.
classList
.
contains
(
"
search
-
go
-
button
"
)
)
{
return
;
}
if
(
event
.
originalTarget
.
localName
=
=
"
menuitem
"
)
{
return
;
}
let
isIconClick
=
event
.
originalTarget
.
classList
.
contains
(
"
searchbar
-
search
-
button
"
)
;
if
(
isIconClick
&
&
this
.
_clickClosedPopup
)
{
return
;
}
if
(
isIconClick
|
|
this
.
_textbox
.
value
)
{
this
.
openSuggestionsPanel
(
true
)
;
}
}
)
;
}
}
customElements
.
define
(
"
searchbar
"
MozSearchbar
)
;
}
