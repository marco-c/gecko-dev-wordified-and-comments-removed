"
use
strict
"
;
{
class
MozSearchbar
extends
MozXULElement
{
static
get
inheritedAttributes
(
)
{
return
{
"
.
searchbar
-
textbox
"
:
"
disabled
disableautocomplete
searchengine
src
newlines
"
"
.
searchbar
-
search
-
button
"
:
"
addengines
"
}
;
}
constructor
(
)
{
super
(
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
_setupEventListeners
(
)
;
let
searchbar
=
this
;
this
.
observer
=
{
observe
(
aEngine
aTopic
aVerb
)
{
if
(
aTopic
=
=
"
browser
-
search
-
engine
-
modified
"
|
|
(
aTopic
=
=
"
browser
-
search
-
service
"
&
&
aVerb
=
=
"
init
-
complete
"
)
)
{
searchbar
.
_engines
=
null
;
searchbar
.
_textbox
.
popup
.
updateHeader
(
)
;
searchbar
.
updateDisplay
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
}
;
this
.
content
=
MozXULElement
.
parseXULToFragment
(
<
stringbundle
src
=
"
chrome
:
/
/
browser
/
locale
/
search
.
properties
"
>
<
/
stringbundle
>
<
hbox
class
=
"
searchbar
-
search
-
button
"
tooltiptext
=
"
&
searchIcon
.
tooltip
;
"
>
<
image
class
=
"
searchbar
-
search
-
icon
"
>
<
/
image
>
<
image
class
=
"
searchbar
-
search
-
icon
-
overlay
"
>
<
/
image
>
<
/
hbox
>
<
html
:
input
class
=
"
searchbar
-
textbox
"
is
=
"
autocomplete
-
input
"
type
=
"
search
"
placeholder
=
"
&
searchInput
.
placeholder
;
"
autocompletepopup
=
"
PopupSearchAutoComplete
"
autocompletesearch
=
"
search
-
autocomplete
"
autocompletesearchparam
=
"
searchbar
-
history
"
maxrows
=
"
10
"
completeselectedindex
=
"
true
"
minresultsforpopup
=
"
0
"
/
>
<
menupopup
class
=
"
textbox
-
contextmenu
"
>
<
/
menupopup
>
<
hbox
class
=
"
search
-
go
-
container
"
>
<
image
class
=
"
search
-
go
-
button
urlbar
-
icon
"
hidden
=
"
true
"
onclick
=
"
handleSearchCommand
(
event
)
;
"
tooltiptext
=
"
&
contentSearchSubmit
.
tooltip
;
"
>
<
/
image
>
<
/
hbox
>
[
"
chrome
:
/
/
browser
/
locale
/
browser
.
dtd
"
]
)
;
this
.
_ignoreFocus
=
false
;
this
.
_engines
=
null
;
}
connectedCallback
(
)
{
if
(
this
.
closest
(
"
#
BrowserToolbarPalette
"
)
)
{
return
;
}
this
.
appendChild
(
document
.
importNode
(
this
.
content
true
)
)
;
this
.
initializeAttributeInheritance
(
)
;
if
(
this
.
parentNode
.
parentNode
.
localName
=
=
"
toolbarpaletteitem
"
)
{
return
;
}
this
.
_stringBundle
=
this
.
querySelector
(
"
stringbundle
"
)
;
this
.
_textbox
=
this
.
querySelector
(
"
.
searchbar
-
textbox
"
)
;
this
.
_menupopup
=
null
;
this
.
_pasteAndSearchMenuItem
=
null
;
this
.
_setupTextboxEventListeners
(
)
;
this
.
_initTextbox
(
)
;
window
.
addEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
FormHistory
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
{
}
)
.
FormHistory
;
Services
.
obs
.
addObserver
(
this
.
observer
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
addObserver
(
this
.
observer
"
browser
-
search
-
service
"
)
;
this
.
_initialized
=
true
;
(
window
.
delayedStartupPromise
|
|
Promise
.
resolve
(
)
)
.
then
(
(
)
=
>
{
window
.
requestIdleCallback
(
(
)
=
>
{
Services
.
search
.
init
(
)
.
then
(
aStatus
=
>
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
updateDisplay
(
)
;
BrowserSearch
.
updateOpenSearchBadge
(
)
;
}
)
.
catch
(
status
=
>
Cu
.
reportError
(
"
Cannot
initialize
search
service
bailing
out
:
"
+
status
)
)
;
}
)
;
}
)
;
this
.
textbox
.
popup
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
let
oneOffButtons
=
this
.
textbox
.
popup
.
oneOffButtons
;
if
(
oneOffButtons
)
{
oneOffButtons
.
telemetryOrigin
=
"
searchbar
"
;
oneOffButtons
.
textbox
=
this
.
textbox
;
oneOffButtons
.
popup
=
this
.
textbox
.
popup
;
}
}
{
capture
:
true
once
:
true
}
)
;
}
async
getEngines
(
)
{
if
(
!
this
.
_engines
)
{
this
.
_engines
=
await
Services
.
search
.
getVisibleEngines
(
)
;
}
return
this
.
_engines
;
}
set
currentEngine
(
val
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
Services
.
search
.
defaultPrivateEngine
=
val
;
}
else
{
Services
.
search
.
defaultEngine
=
val
;
}
return
val
;
}
get
currentEngine
(
)
{
let
currentEngine
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
currentEngine
=
Services
.
search
.
defaultPrivateEngine
;
}
else
{
currentEngine
=
Services
.
search
.
defaultEngine
;
}
return
currentEngine
|
|
{
name
:
"
"
uri
:
null
}
;
}
get
textbox
(
)
{
return
this
.
_textbox
;
}
set
value
(
val
)
{
return
(
this
.
_textbox
.
value
=
val
)
;
}
get
value
(
)
{
return
this
.
_textbox
.
value
;
}
destroy
(
)
{
if
(
this
.
_initialized
)
{
this
.
_initialized
=
false
;
window
.
removeEventListener
(
"
unload
"
this
.
destroy
)
;
Services
.
obs
.
removeObserver
(
this
.
observer
"
browser
-
search
-
engine
-
modified
"
)
;
Services
.
obs
.
removeObserver
(
this
.
observer
"
browser
-
search
-
service
"
)
;
}
if
(
this
.
_textbox
&
&
this
.
_textbox
.
mController
&
&
this
.
_textbox
.
mController
.
input
&
&
this
.
_textbox
.
mController
.
input
.
wrappedJSObject
=
=
this
.
nsIAutocompleteInput
)
{
this
.
_textbox
.
mController
.
input
=
null
;
}
}
focus
(
)
{
this
.
_textbox
.
focus
(
)
;
}
select
(
)
{
this
.
_textbox
.
select
(
)
;
}
setIcon
(
element
uri
)
{
element
.
setAttribute
(
"
src
"
uri
)
;
}
updateDisplay
(
)
{
let
uri
=
this
.
currentEngine
.
iconURI
;
this
.
setIcon
(
this
uri
?
uri
.
spec
:
"
"
)
;
let
name
=
this
.
currentEngine
.
name
;
let
text
=
this
.
_stringBundle
.
getFormattedString
(
"
searchtip
"
[
name
]
)
;
this
.
_textbox
.
label
=
text
;
this
.
_textbox
.
tooltipText
=
text
;
}
updateGoButtonVisibility
(
)
{
this
.
querySelector
(
"
.
search
-
go
-
button
"
)
.
hidden
=
!
this
.
_textbox
.
value
;
}
openSuggestionsPanel
(
aShowOnlySettingsIfEmpty
)
{
if
(
this
.
_textbox
.
open
)
{
return
;
}
this
.
_textbox
.
showHistoryPopup
(
)
;
if
(
this
.
_textbox
.
value
)
{
this
.
_textbox
.
mController
.
handleText
(
)
;
}
else
if
(
aShowOnlySettingsIfEmpty
)
{
this
.
setAttribute
(
"
showonlysettings
"
"
true
"
)
;
}
}
async
selectEngine
(
aEvent
isNextEngine
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
let
engines
=
await
this
.
getEngines
(
)
;
let
currentName
=
this
.
currentEngine
.
name
;
let
newIndex
=
-
1
;
let
lastIndex
=
engines
.
length
-
1
;
for
(
let
i
=
lastIndex
;
i
>
=
0
;
-
-
i
)
{
if
(
engines
[
i
]
.
name
=
=
currentName
)
{
if
(
!
isNextEngine
&
&
i
=
=
0
)
{
newIndex
=
lastIndex
;
}
else
if
(
isNextEngine
&
&
i
=
=
lastIndex
)
{
newIndex
=
0
;
}
else
{
newIndex
=
i
+
(
isNextEngine
?
1
:
-
1
)
;
}
break
;
}
}
this
.
currentEngine
=
engines
[
newIndex
]
;
this
.
openSuggestionsPanel
(
)
;
}
handleSearchCommand
(
aEvent
aEngine
aForceNewTab
)
{
let
where
=
"
current
"
;
let
params
;
if
(
aEvent
&
&
aEvent
.
originalTarget
.
classList
.
contains
(
"
search
-
go
-
button
"
)
)
{
if
(
aEvent
.
button
=
=
2
)
{
return
;
}
where
=
whereToOpenLink
(
aEvent
false
true
)
;
}
else
if
(
aForceNewTab
)
{
where
=
"
tab
"
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
)
{
where
+
=
"
-
background
"
;
}
}
else
{
let
newTabPref
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
openintab
"
)
;
if
(
(
aEvent
instanceof
KeyboardEvent
&
&
(
aEvent
.
altKey
|
|
aEvent
.
getModifierState
(
"
AltGraph
"
)
)
)
^
newTabPref
&
&
!
gBrowser
.
selectedTab
.
isEmpty
)
{
where
=
"
tab
"
;
}
if
(
aEvent
instanceof
MouseEvent
&
&
(
aEvent
.
button
=
=
1
|
|
aEvent
.
getModifierState
(
"
Accel
"
)
)
)
{
where
=
"
tab
"
;
params
=
{
inBackground
:
true
}
;
}
}
this
.
handleSearchCommandWhere
(
aEvent
aEngine
where
params
)
;
}
handleSearchCommandWhere
(
aEvent
aEngine
aWhere
aParams
)
{
let
textBox
=
this
.
_textbox
;
let
textValue
=
textBox
.
value
;
let
selection
=
this
.
telemetrySearchDetails
;
let
oneOffRecorded
=
false
;
BrowserUsageTelemetry
.
recordSearchbarSelectedResultMethod
(
aEvent
selection
?
selection
.
index
:
-
1
)
;
if
(
!
selection
|
|
selection
.
index
=
=
-
1
)
{
oneOffRecorded
=
this
.
textbox
.
popup
.
oneOffButtons
.
maybeRecordTelemetry
(
aEvent
)
;
if
(
!
oneOffRecorded
)
{
let
source
=
"
unknown
"
;
let
type
=
"
unknown
"
;
let
target
=
aEvent
.
originalTarget
;
if
(
aEvent
instanceof
KeyboardEvent
)
{
type
=
"
key
"
;
}
else
if
(
aEvent
instanceof
MouseEvent
)
{
type
=
"
mouse
"
;
if
(
target
.
classList
.
contains
(
"
search
-
panel
-
header
"
)
|
|
target
.
parentNode
.
classList
.
contains
(
"
search
-
panel
-
header
"
)
)
{
source
=
"
header
"
;
}
}
else
if
(
aEvent
instanceof
XULCommandEvent
)
{
if
(
target
.
getAttribute
(
"
anonid
"
)
=
=
"
paste
-
and
-
search
"
)
{
source
=
"
paste
"
;
}
}
if
(
!
aEngine
)
{
aEngine
=
this
.
currentEngine
;
}
BrowserSearch
.
recordOneoffSearchInTelemetry
(
aEngine
source
type
)
;
}
}
this
.
doSearch
(
textValue
aWhere
aEngine
aParams
oneOffRecorded
)
;
if
(
aWhere
=
=
"
tab
"
&
&
aParams
&
&
aParams
.
inBackground
)
{
this
.
focus
(
)
;
}
}
doSearch
(
aData
aWhere
aEngine
aParams
aOneOff
)
{
let
textBox
=
this
.
_textbox
;
if
(
aData
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
this
.
FormHistory
.
enabled
)
{
this
.
FormHistory
.
update
(
{
op
:
"
bump
"
fieldname
:
textBox
.
getAttribute
(
"
autocompletesearchparam
"
)
value
:
aData
}
{
handleError
(
aError
)
{
Cu
.
reportError
(
"
Saving
search
to
form
history
failed
:
"
+
aError
.
message
)
;
}
}
)
;
}
let
engine
=
aEngine
|
|
this
.
currentEngine
;
let
submission
=
engine
.
getSubmission
(
aData
null
"
searchbar
"
)
;
let
telemetrySearchDetails
=
this
.
telemetrySearchDetails
;
this
.
telemetrySearchDetails
=
null
;
if
(
telemetrySearchDetails
&
&
telemetrySearchDetails
.
index
=
=
-
1
)
{
telemetrySearchDetails
=
null
;
}
const
details
=
{
isOneOff
:
aOneOff
isSuggestion
:
!
aOneOff
&
&
telemetrySearchDetails
selection
:
telemetrySearchDetails
}
;
BrowserSearch
.
recordSearchInTelemetry
(
engine
"
searchbar
"
details
)
;
let
params
=
{
postData
:
submission
.
postData
}
;
if
(
aParams
)
{
for
(
let
key
in
aParams
)
{
params
[
key
]
=
aParams
[
key
]
;
}
}
openTrustedLinkIn
(
submission
.
uri
.
spec
aWhere
params
)
;
}
disconnectedCallback
(
)
{
this
.
destroy
(
)
;
while
(
this
.
firstChild
)
{
this
.
firstChild
.
remove
(
)
;
}
}
_maybeSelectAll
(
)
{
if
(
!
this
.
_preventClickSelectsAll
&
&
UrlbarPrefs
.
get
(
"
clickSelectsAll
"
)
&
&
document
.
activeElement
=
=
this
.
_textbox
&
&
this
.
_textbox
.
selectionStart
=
=
this
.
_textbox
.
selectionEnd
)
{
this
.
_textbox
.
editor
.
selectAll
(
)
;
}
}
_setupEventListeners
(
)
{
this
.
addEventListener
(
"
click
"
event
=
>
{
this
.
_maybeSelectAll
(
)
;
}
)
;
this
.
addEventListener
(
"
command
"
event
=
>
{
const
target
=
event
.
originalTarget
;
if
(
target
.
engine
)
{
this
.
currentEngine
=
target
.
engine
;
}
else
if
(
target
.
classList
.
contains
(
"
addengine
-
item
"
)
)
{
Services
.
search
.
addEngine
(
target
.
getAttribute
(
"
uri
"
)
target
.
getAttribute
(
"
src
"
)
false
)
.
then
(
engine
=
>
(
this
.
currentEngine
=
engine
)
)
;
}
else
{
return
;
}
this
.
focus
(
)
;
this
.
select
(
)
;
}
)
;
this
.
addEventListener
(
"
DOMMouseScroll
"
event
=
>
{
if
(
event
.
getModifierState
(
"
Accel
"
)
)
{
this
.
selectEngine
(
event
event
.
detail
>
0
)
;
}
}
true
)
;
this
.
addEventListener
(
"
input
"
event
=
>
{
this
.
updateGoButtonVisibility
(
)
;
}
)
;
this
.
addEventListener
(
"
drop
"
event
=
>
{
this
.
updateGoButtonVisibility
(
)
;
}
)
;
this
.
addEventListener
(
"
blur
"
event
=
>
{
this
.
_ignoreFocus
=
document
.
activeElement
=
=
this
.
_textbox
;
}
true
)
;
this
.
addEventListener
(
"
focus
"
event
=
>
{
this
.
currentEngine
.
speculativeConnect
(
{
window
originAttributes
:
gBrowser
.
contentPrincipal
.
originAttributes
}
)
;
if
(
this
.
_ignoreFocus
)
{
this
.
_ignoreFocus
=
false
;
return
;
}
if
(
!
this
.
_textbox
.
value
)
{
return
;
}
if
(
Services
.
focus
.
getLastFocusMethod
(
window
)
&
Services
.
focus
.
FLAG_BYMOUSE
)
{
return
;
}
this
.
openSuggestionsPanel
(
)
;
}
true
)
;
this
.
addEventListener
(
"
mousedown
"
event
=
>
{
this
.
_preventClickSelectsAll
=
this
.
_textbox
.
focused
;
if
(
event
.
button
!
=
0
)
{
return
;
}
if
(
event
.
originalTarget
.
classList
.
contains
(
"
search
-
go
-
button
"
)
)
{
return
;
}
if
(
event
.
originalTarget
.
localName
=
=
"
menuitem
"
)
{
return
;
}
let
isIconClick
=
event
.
originalTarget
.
classList
.
contains
(
"
searchbar
-
search
-
button
"
)
;
if
(
isIconClick
&
&
this
.
textbox
.
popup
.
popupOpen
)
{
this
.
textbox
.
popup
.
closePopup
(
)
;
}
else
if
(
isIconClick
|
|
this
.
_textbox
.
value
)
{
this
.
openSuggestionsPanel
(
true
)
;
}
if
(
event
.
detail
=
=
2
&
&
UrlbarPrefs
.
get
(
"
doubleClickSelectsAll
"
)
)
{
this
.
_textbox
.
editor
.
selectAll
(
)
;
event
.
preventDefault
(
)
;
}
}
)
;
}
_setupTextboxEventListeners
(
)
{
this
.
textbox
.
addEventListener
(
"
input
"
event
=
>
{
this
.
textbox
.
popup
.
removeAttribute
(
"
showonlysettings
"
)
;
}
)
;
this
.
textbox
.
addEventListener
(
"
keypress
"
event
=
>
{
let
popup
=
this
.
textbox
.
popup
;
if
(
!
popup
.
popupOpen
|
|
event
.
getModifierState
(
"
Accel
"
)
)
{
return
;
}
let
suggestionsHidden
=
popup
.
richlistbox
.
getAttribute
(
"
collapsed
"
)
=
=
"
true
"
;
let
numItems
=
suggestionsHidden
?
0
:
popup
.
matchCount
;
popup
.
oneOffButtons
.
handleKeyPress
(
event
numItems
true
)
;
}
true
)
;
this
.
textbox
.
addEventListener
(
"
keypress
"
event
=
>
{
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_UP
&
&
event
.
getModifierState
(
"
Accel
"
)
)
{
this
.
selectEngine
(
event
false
)
;
}
}
true
)
;
this
.
textbox
.
addEventListener
(
"
keypress
"
event
=
>
{
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_DOWN
&
&
event
.
getModifierState
(
"
Accel
"
)
)
{
this
.
selectEngine
(
event
true
)
;
}
}
true
)
;
this
.
textbox
.
addEventListener
(
"
keypress
"
event
=
>
{
if
(
event
.
getModifierState
(
"
Alt
"
)
&
&
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_DOWN
|
|
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_UP
)
)
{
this
.
textbox
.
openSearch
(
)
;
}
}
true
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
textbox
.
addEventListener
(
"
keypress
"
event
=
>
{
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_F4
)
{
this
.
textbox
.
openSearch
(
)
;
}
}
true
)
;
}
this
.
textbox
.
addEventListener
(
"
dragover
"
event
=
>
{
let
types
=
event
.
dataTransfer
.
types
;
if
(
types
.
includes
(
"
text
/
plain
"
)
|
|
types
.
includes
(
"
text
/
x
-
moz
-
text
-
internal
"
)
)
{
event
.
preventDefault
(
)
;
}
}
)
;
this
.
textbox
.
addEventListener
(
"
drop
"
event
=
>
{
let
dataTransfer
=
event
.
dataTransfer
;
let
data
=
dataTransfer
.
getData
(
"
text
/
plain
"
)
;
if
(
!
data
)
{
data
=
dataTransfer
.
getData
(
"
text
/
x
-
moz
-
text
-
internal
"
)
;
}
if
(
data
)
{
event
.
preventDefault
(
)
;
this
.
textbox
.
value
=
data
;
this
.
openSuggestionsPanel
(
)
;
}
}
)
;
this
.
textbox
.
addEventListener
(
"
contextmenu
"
event
=
>
{
if
(
!
this
.
_menupopup
)
{
this
.
_buildContextMenu
(
)
;
}
BrowserSearch
.
searchBar
.
_textbox
.
closePopup
(
)
;
let
controller
=
document
.
commandDispatcher
.
getControllerForCommand
(
"
cmd_paste
"
)
;
let
pasteEnabled
=
controller
.
isCommandEnabled
(
"
cmd_paste
"
)
;
if
(
pasteEnabled
)
{
this
.
_pasteAndSearchMenuItem
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
this
.
_pasteAndSearchMenuItem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
this
.
_menupopup
.
openPopupAtScreen
(
event
.
screenX
event
.
screenY
true
)
;
if
(
event
.
button
)
{
this
.
_maybeSelectAll
(
)
;
}
event
.
preventDefault
(
)
;
}
)
;
}
_initTextbox
(
)
{
if
(
this
.
parentNode
.
parentNode
.
localName
=
=
"
toolbarpaletteitem
"
)
{
return
;
}
this
.
setAttribute
(
"
role
"
"
combobox
"
)
;
this
.
setAttribute
(
"
aria
-
owns
"
this
.
textbox
.
popup
.
id
)
;
Object
.
defineProperty
(
this
.
textbox
"
searchParam
"
{
get
(
)
{
return
(
this
.
getAttribute
(
"
autocompletesearchparam
"
)
+
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
?
"
|
private
"
:
"
"
)
)
;
}
set
(
val
)
{
this
.
setAttribute
(
"
autocompletesearchparam
"
val
)
;
return
val
;
}
}
)
;
Object
.
defineProperty
(
this
.
textbox
"
selectedButton
"
{
get
(
)
{
return
this
.
popup
.
oneOffButtons
.
selectedButton
;
}
set
(
val
)
{
return
(
this
.
popup
.
oneOffButtons
.
selectedButton
=
val
)
;
}
}
)
;
this
.
textbox
.
onBeforeValueSet
=
aValue
=
>
{
this
.
textbox
.
popup
.
oneOffButtons
.
query
=
aValue
;
return
aValue
;
}
;
this
.
textbox
.
openPopup
=
(
)
=
>
{
if
(
document
.
documentElement
.
getAttribute
(
"
customizing
"
)
=
=
"
true
"
)
{
return
;
}
let
popup
=
this
.
textbox
.
popup
;
if
(
!
popup
.
mPopupOpen
)
{
popup
.
hidden
=
false
;
if
(
popup
.
id
=
=
"
PopupSearchAutoComplete
"
)
{
popup
.
setAttribute
(
"
norolluponanchor
"
"
true
"
)
;
}
popup
.
mInput
=
this
.
textbox
;
popup
.
selectedIndex
=
-
1
;
document
.
popupNode
=
null
;
requestAnimationFrame
(
(
)
=
>
{
let
{
width
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
)
;
if
(
popup
.
oneOffButtons
)
{
width
=
Math
.
max
(
width
popup
.
oneOffButtons
.
buttonWidth
*
3
)
;
}
popup
.
style
.
width
=
width
+
"
px
"
;
}
)
;
popup
.
_invalidate
(
)
;
popup
.
openPopup
(
this
"
after_start
"
)
;
}
}
;
this
.
textbox
.
openSearch
=
(
)
=
>
{
if
(
!
this
.
textbox
.
popupOpen
)
{
this
.
openSuggestionsPanel
(
)
;
return
false
;
}
return
true
;
}
;
this
.
textbox
.
handleEnter
=
event
=
>
{
if
(
this
.
textbox
.
selectedButton
&
&
this
.
textbox
.
selectedButton
.
getAttribute
(
"
anonid
"
)
=
=
"
addengine
-
menu
-
button
"
)
{
this
.
textbox
.
selectedButton
.
open
=
!
this
.
textbox
.
selectedButton
.
open
;
return
true
;
}
return
this
.
textbox
.
mController
.
handleEnter
(
false
event
|
|
null
)
;
}
;
this
.
textbox
.
onTextEntered
=
event
=
>
{
let
engine
;
let
oneOff
=
this
.
textbox
.
selectedButton
;
if
(
oneOff
)
{
if
(
!
oneOff
.
engine
)
{
oneOff
.
doCommand
(
)
;
return
;
}
engine
=
oneOff
.
engine
;
}
if
(
this
.
textbox
.
_selectionDetails
)
{
BrowserSearch
.
searchBar
.
telemetrySearchDetails
=
this
.
textbox
.
_selectionDetails
;
this
.
textbox
.
_selectionDetails
=
null
;
}
this
.
handleSearchCommand
(
event
engine
)
;
}
;
}
_buildContextMenu
(
)
{
const
raw
=
<
menuitem
label
=
"
&
undoCmd
.
label
;
"
accesskey
=
"
&
undoCmd
.
accesskey
;
"
cmd
=
"
cmd_undo
"
/
>
<
menuseparator
/
>
<
menuitem
label
=
"
&
cutCmd
.
label
;
"
accesskey
=
"
&
cutCmd
.
accesskey
;
"
cmd
=
"
cmd_cut
"
/
>
<
menuitem
label
=
"
&
copyCmd
.
label
;
"
accesskey
=
"
&
copyCmd
.
accesskey
;
"
cmd
=
"
cmd_copy
"
/
>
<
menuitem
label
=
"
&
pasteCmd
.
label
;
"
accesskey
=
"
&
pasteCmd
.
accesskey
;
"
cmd
=
"
cmd_paste
"
/
>
<
menuitem
class
=
"
searchbar
-
paste
-
and
-
search
"
/
>
<
menuitem
label
=
"
&
deleteCmd
.
label
;
"
accesskey
=
"
&
deleteCmd
.
accesskey
;
"
cmd
=
"
cmd_delete
"
/
>
<
menuseparator
/
>
<
menuitem
label
=
"
&
selectAllCmd
.
label
;
"
accesskey
=
"
&
selectAllCmd
.
accesskey
;
"
cmd
=
"
cmd_selectAll
"
/
>
<
menuseparator
/
>
<
menuitem
class
=
"
searchbar
-
clear
-
history
"
/
>
;
this
.
_menupopup
=
this
.
querySelector
(
"
.
textbox
-
contextmenu
"
)
;
let
frag
=
MozXULElement
.
parseXULToFragment
(
raw
[
"
chrome
:
/
/
global
/
locale
/
textcontext
.
dtd
"
]
)
;
this
.
_pasteAndSearchMenuItem
=
frag
.
querySelector
(
"
.
searchbar
-
paste
-
and
-
search
"
)
;
this
.
_pasteAndSearchMenuItem
.
setAttribute
(
"
label
"
this
.
_stringBundle
.
getString
(
"
cmd_pasteAndSearch
"
)
)
;
let
clearHistoryItem
=
frag
.
querySelector
(
"
.
searchbar
-
clear
-
history
"
)
;
clearHistoryItem
.
setAttribute
(
"
label
"
this
.
_stringBundle
.
getString
(
"
cmd_clearHistory
"
)
)
;
clearHistoryItem
.
setAttribute
(
"
accesskey
"
this
.
_stringBundle
.
getString
(
"
cmd_clearHistory_accesskey
"
)
)
;
this
.
_menupopup
.
appendChild
(
frag
)
;
this
.
_menupopup
.
addEventListener
(
"
command
"
event
=
>
{
switch
(
event
.
originalTarget
)
{
case
this
.
_pasteAndSearchMenuItem
:
BrowserSearch
.
pasteAndSearch
(
event
)
;
break
;
case
clearHistoryItem
:
let
param
=
this
.
textbox
.
getAttribute
(
"
autocompletesearchparam
"
)
;
BrowserSearch
.
searchBar
.
FormHistory
.
update
(
{
op
:
"
remove
"
fieldname
:
param
}
null
)
;
this
.
textbox
.
value
=
"
"
;
break
;
default
:
let
cmd
=
event
.
originalTarget
.
getAttribute
(
"
cmd
"
)
;
if
(
cmd
)
{
let
controller
=
document
.
commandDispatcher
.
getControllerForCommand
(
cmd
)
;
controller
.
doCommand
(
cmd
)
;
}
break
;
}
}
)
;
}
}
customElements
.
define
(
"
searchbar
"
MozSearchbar
)
;
}
