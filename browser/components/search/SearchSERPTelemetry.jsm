"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SearchSERPTelemetry
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserSearchTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserSearchTelemetry
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
SEARCH_COUNTS_HISTOGRAM_KEY
=
"
SEARCH_COUNTS
"
;
const
SEARCH_CONTENT_SCALAR_BASE
=
"
browser
.
search
.
content
.
"
;
const
SEARCH_WITH_ADS_SCALAR_OLD
=
"
browser
.
search
.
with_ads
"
;
const
SEARCH_WITH_ADS_SCALAR_BASE
=
"
browser
.
search
.
withads
.
"
;
const
SEARCH_AD_CLICKS_SCALAR_OLD
=
"
browser
.
search
.
ad_clicks
"
;
const
SEARCH_AD_CLICKS_SCALAR_BASE
=
"
browser
.
search
.
adclicks
.
"
;
const
SEARCH_DATA_TRANSFERRED_SCALAR
=
"
browser
.
search
.
data_transferred
"
;
const
SEARCH_TELEMETRY_PRIVATE_BROWSING_KEY_SUFFIX
=
"
pb
"
;
const
TELEMETRY_SETTINGS_KEY
=
"
search
-
telemetry
-
v2
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
SearchTelemetry
"
maxLogLevel
:
SearchUtils
.
loggingEnabled
?
"
Debug
"
:
"
Warn
"
}
)
;
}
)
;
class
TelemetryHandler
{
_initialized
=
false
;
_contentHandler
;
_originalProviderInfo
=
null
;
_searchProviderInfo
=
null
;
_telemetrySettings
;
_browserInfoByURL
=
new
Map
(
)
;
_browserSourceMap
=
new
WeakMap
(
)
;
constructor
(
)
{
this
.
_contentHandler
=
new
ContentHandler
(
{
browserInfoByURL
:
this
.
_browserInfoByURL
findBrowserItemForURL
:
(
.
.
.
args
)
=
>
this
.
_findBrowserItemForURL
(
.
.
.
args
)
getProviderInfoForURL
:
(
.
.
.
args
)
=
>
this
.
_getProviderInfoForURL
(
.
.
.
args
)
checkURLForSerpMatch
:
(
.
.
.
args
)
=
>
this
.
_checkURLForSerpMatch
(
.
.
.
args
)
}
)
;
}
async
init
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_telemetrySettings
=
RemoteSettings
(
TELEMETRY_SETTINGS_KEY
)
;
let
rawProviderInfo
=
[
]
;
try
{
rawProviderInfo
=
await
this
.
_telemetrySettings
.
get
(
)
;
}
catch
(
ex
)
{
logConsole
.
error
(
"
Could
not
get
settings
:
"
ex
)
;
}
this
.
_contentHandler
.
init
(
rawProviderInfo
)
;
this
.
_originalProviderInfo
=
rawProviderInfo
;
this
.
_setSearchProviderInfo
(
rawProviderInfo
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
this
.
_registerWindow
(
win
)
;
}
Services
.
wm
.
addListener
(
this
)
;
this
.
_initialized
=
true
;
}
uninit
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_contentHandler
.
uninit
(
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
this
.
_unregisterWindow
(
win
)
;
}
Services
.
wm
.
removeListener
(
this
)
;
this
.
_initialized
=
false
;
}
recordBrowserSource
(
browser
source
)
{
this
.
_browserSourceMap
.
set
(
browser
source
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
!
=
"
TabClose
"
)
{
Cu
.
reportError
(
Received
unexpected
event
type
{
event
.
type
}
)
;
return
;
}
this
.
stopTrackingBrowser
(
event
.
target
.
linkedBrowser
)
;
}
overrideSearchTelemetryForTests
(
providerInfo
)
{
let
info
=
providerInfo
?
providerInfo
:
this
.
_originalProviderInfo
;
this
.
_contentHandler
.
overrideSearchTelemetryForTests
(
info
)
;
this
.
_setSearchProviderInfo
(
info
)
;
}
_setSearchProviderInfo
(
providerInfo
)
{
this
.
_searchProviderInfo
=
providerInfo
.
map
(
provider
=
>
{
let
newProvider
=
{
.
.
.
provider
searchPageRegexp
:
new
RegExp
(
provider
.
searchPageRegexp
)
}
;
if
(
provider
.
extraAdServersRegexps
)
{
newProvider
.
extraAdServersRegexps
=
provider
.
extraAdServersRegexps
.
map
(
r
=
>
new
RegExp
(
r
)
)
;
}
return
newProvider
;
}
)
;
}
reportPageWithAds
(
info
)
{
this
.
_contentHandler
.
_reportPageWithAds
(
info
)
;
}
updateTrackingStatus
(
browser
url
loadType
)
{
if
(
!
BrowserSearchTelemetry
.
shouldRecordSearchCount
(
browser
.
getTabBrowser
(
)
)
)
{
return
;
}
let
info
=
this
.
_checkURLForSerpMatch
(
url
)
;
if
(
!
info
)
{
this
.
stopTrackingBrowser
(
browser
)
;
return
;
}
let
source
=
"
unknown
"
;
if
(
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_RELOAD
)
{
source
=
"
reload
"
;
}
else
if
(
loadType
&
Ci
.
nsIDocShell
.
LOAD_CMD_HISTORY
)
{
source
=
"
tabhistory
"
;
}
else
if
(
this
.
_browserSourceMap
.
has
(
browser
)
)
{
source
=
this
.
_browserSourceMap
.
get
(
browser
)
;
this
.
_browserSourceMap
.
delete
(
browser
)
;
}
this
.
_reportSerpPage
(
info
source
url
)
;
let
item
=
this
.
_browserInfoByURL
.
get
(
url
)
;
if
(
item
)
{
item
.
browsers
.
add
(
browser
)
;
item
.
count
+
+
;
item
.
source
=
source
;
}
else
{
this
.
_browserInfoByURL
.
set
(
url
{
browsers
:
new
WeakSet
(
[
browser
]
)
info
count
:
1
source
}
)
;
}
}
stopTrackingBrowser
(
browser
)
{
for
(
let
[
url
item
]
of
this
.
_browserInfoByURL
)
{
if
(
item
.
browsers
.
has
(
browser
)
)
{
item
.
browsers
.
delete
(
browser
)
;
item
.
count
-
-
;
}
if
(
!
item
.
count
)
{
this
.
_browserInfoByURL
.
delete
(
url
)
;
}
}
}
_findBrowserItemForURL
(
url
)
{
try
{
url
=
new
URL
(
url
)
;
}
catch
(
ex
)
{
return
null
;
}
const
compareURLs
=
(
url1
url2
)
=
>
{
if
(
url1
.
href
=
=
url2
.
href
)
{
return
Infinity
;
}
let
score
=
0
;
if
(
url1
.
hostname
=
=
url2
.
hostname
)
{
+
+
score
;
if
(
url1
.
pathname
=
=
url2
.
pathname
)
{
+
+
score
;
for
(
let
[
key1
value1
]
of
url1
.
searchParams
)
{
if
(
url2
.
searchParams
.
has
(
key1
)
)
{
+
+
score
;
if
(
url2
.
searchParams
.
get
(
key1
)
=
=
value1
)
{
+
+
score
;
}
}
}
if
(
url1
.
hash
=
=
url2
.
hash
)
{
+
+
score
;
}
}
}
return
score
;
}
;
let
item
;
let
currentBestMatch
=
0
;
for
(
let
[
trackingURL
candidateItem
]
of
this
.
_browserInfoByURL
)
{
if
(
currentBestMatch
=
=
=
Infinity
)
{
break
;
}
try
{
trackingURL
=
candidateItem
.
_trackingURL
|
|
(
candidateItem
.
_trackingURL
=
new
URL
(
trackingURL
)
)
;
}
catch
(
ex
)
{
continue
;
}
let
score
=
compareURLs
(
url
trackingURL
)
;
if
(
score
>
currentBestMatch
)
{
item
=
candidateItem
;
currentBestMatch
=
score
;
}
}
return
item
;
}
onOpenWindow
(
appWin
)
{
let
win
=
appWin
.
docShell
.
domWindow
;
win
.
addEventListener
(
"
load
"
(
)
=
>
{
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
this
.
_registerWindow
(
win
)
;
}
{
once
:
true
}
)
;
}
onCloseWindow
(
appWin
)
{
let
win
=
appWin
.
docShell
.
domWindow
;
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
this
.
_unregisterWindow
(
win
)
;
}
_registerWindow
(
win
)
{
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabClose
"
this
)
;
}
_unregisterWindow
(
win
)
{
for
(
let
tab
of
win
.
gBrowser
.
tabs
)
{
this
.
stopTrackingBrowser
(
tab
)
;
}
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabClose
"
this
)
;
}
_getProviderInfoForURL
(
url
useOnlyExtraAdServers
=
false
)
{
if
(
useOnlyExtraAdServers
)
{
return
this
.
_searchProviderInfo
.
find
(
info
=
>
{
if
(
info
.
extraAdServersRegexps
)
{
for
(
let
regexp
of
info
.
extraAdServersRegexps
)
{
if
(
regexp
.
test
(
url
)
)
{
return
true
;
}
}
}
return
false
;
}
)
;
}
return
this
.
_searchProviderInfo
.
find
(
info
=
>
info
.
searchPageRegexp
.
test
(
url
)
)
;
}
_checkURLForSerpMatch
(
url
)
{
let
searchProviderInfo
=
this
.
_getProviderInfoForURL
(
url
)
;
if
(
!
searchProviderInfo
)
{
return
null
;
}
let
queries
=
new
URLSearchParams
(
url
.
split
(
"
#
"
)
[
0
]
.
split
(
"
?
"
)
[
1
]
)
;
if
(
!
queries
.
get
(
searchProviderInfo
.
queryParamName
)
)
{
return
null
;
}
let
oldType
=
"
organic
"
;
let
type
=
"
organic
"
;
let
code
;
if
(
searchProviderInfo
.
codeParamName
)
{
code
=
queries
.
get
(
searchProviderInfo
.
codeParamName
)
;
if
(
code
)
{
if
(
searchProviderInfo
.
taggedCodes
.
includes
(
code
)
)
{
oldType
=
"
sap
"
;
type
=
"
tagged
"
;
if
(
searchProviderInfo
.
followOnParamNames
&
&
searchProviderInfo
.
followOnParamNames
.
some
(
p
=
>
queries
.
has
(
p
)
)
)
{
oldType
+
=
"
-
follow
-
on
"
;
type
+
=
"
-
follow
-
on
"
;
}
}
else
if
(
searchProviderInfo
.
organicCodes
.
includes
(
code
)
)
{
oldType
=
"
organic
"
;
type
=
"
organic
"
;
}
else
if
(
searchProviderInfo
.
expectedOrganicCodes
?
.
includes
(
code
)
)
{
code
=
"
none
"
;
}
else
{
code
=
"
other
"
;
}
}
else
if
(
searchProviderInfo
.
followOnCookies
)
{
for
(
let
followOnCookie
of
searchProviderInfo
.
followOnCookies
)
{
if
(
followOnCookie
.
extraCodeParamName
)
{
let
eCode
=
queries
.
get
(
followOnCookie
.
extraCodeParamName
)
;
if
(
!
eCode
|
|
!
followOnCookie
.
extraCodePrefixes
.
some
(
p
=
>
eCode
.
startsWith
(
p
)
)
)
{
continue
;
}
}
for
(
let
cookie
of
Services
.
cookies
.
getCookiesFromHost
(
followOnCookie
.
host
{
}
)
)
{
if
(
cookie
.
name
!
=
followOnCookie
.
name
)
{
continue
;
}
let
[
cookieParam
cookieValue
]
=
cookie
.
value
.
split
(
"
=
"
)
.
map
(
p
=
>
p
.
trim
(
)
)
;
if
(
cookieParam
=
=
followOnCookie
.
codeParamName
&
&
searchProviderInfo
.
taggedCodes
.
includes
(
cookieValue
)
)
{
oldType
=
"
sap
-
follow
-
on
"
;
type
=
"
tagged
-
follow
-
on
"
;
code
=
cookieValue
;
break
;
}
}
}
}
}
return
{
provider
:
searchProviderInfo
.
telemetryId
oldType
type
code
}
;
}
_reportSerpPage
(
info
source
url
)
{
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_CONTENT_SCALAR_BASE
+
source
{
info
.
provider
}
:
{
info
.
type
}
:
{
info
.
code
|
|
"
none
"
}
1
)
;
let
payload
=
{
info
.
provider
}
.
in
-
content
:
{
info
.
oldType
}
:
{
info
.
code
|
|
"
none
"
}
;
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
SEARCH_COUNTS_HISTOGRAM_KEY
)
;
histogram
.
add
(
payload
)
;
logConsole
.
debug
(
"
Counting
"
payload
"
for
"
url
)
;
}
}
class
ContentHandler
{
constructor
(
options
)
{
this
.
_browserInfoByURL
=
options
.
browserInfoByURL
;
this
.
_findBrowserItemForURL
=
options
.
findBrowserItemForURL
;
this
.
_getProviderInfoForURL
=
options
.
getProviderInfoForURL
;
this
.
_checkURLForSerpMatch
=
options
.
checkURLForSerpMatch
;
}
init
(
providerInfo
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
SearchTelemetry
:
ProviderInfo
"
providerInfo
)
;
Cc
[
"
mozilla
.
org
/
network
/
http
-
activity
-
distributor
;
1
"
]
.
getService
(
Ci
.
nsIHttpActivityDistributor
)
.
addObserver
(
this
)
;
Services
.
obs
.
addObserver
(
this
"
http
-
on
-
stop
-
request
"
)
;
}
uninit
(
)
{
Cc
[
"
mozilla
.
org
/
network
/
http
-
activity
-
distributor
;
1
"
]
.
getService
(
Ci
.
nsIHttpActivityDistributor
)
.
removeObserver
(
this
)
;
Services
.
obs
.
removeObserver
(
this
"
http
-
on
-
stop
-
request
"
)
;
}
overrideSearchTelemetryForTests
(
providerInfo
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
SearchTelemetry
:
ProviderInfo
"
providerInfo
)
;
}
_reportChannelBandwidth
(
aChannel
)
{
if
(
!
(
aChannel
instanceof
Ci
.
nsIChannel
)
)
{
return
;
}
let
wrappedChannel
=
ChannelWrapper
.
get
(
aChannel
)
;
let
getTopURL
=
channel
=
>
{
if
(
channel
.
loadInfo
&
&
channel
.
loadInfo
.
externalContentPolicyType
=
=
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
)
{
return
channel
.
finalURL
;
}
let
frameAncestors
;
try
{
frameAncestors
=
channel
.
frameAncestors
;
}
catch
(
e
)
{
frameAncestors
=
null
;
}
if
(
frameAncestors
)
{
let
ancestor
=
frameAncestors
.
find
(
obj
=
>
obj
.
frameId
=
=
0
)
;
if
(
ancestor
)
{
return
ancestor
.
url
;
}
}
if
(
channel
.
loadInfo
&
&
channel
.
loadInfo
.
loadingPrincipal
)
{
return
channel
.
loadInfo
.
loadingPrincipal
.
spec
;
}
return
null
;
}
;
let
topUrl
=
getTopURL
(
wrappedChannel
)
;
if
(
!
topUrl
)
{
return
;
}
let
info
=
this
.
_checkURLForSerpMatch
(
topUrl
)
;
if
(
!
info
)
{
return
;
}
let
bytesTransferred
=
wrappedChannel
.
requestSize
+
wrappedChannel
.
responseSize
;
let
{
provider
}
=
info
;
let
isPrivate
=
wrappedChannel
.
loadInfo
&
&
wrappedChannel
.
loadInfo
.
originAttributes
.
privateBrowsingId
>
0
;
if
(
isPrivate
)
{
provider
+
=
-
{
SEARCH_TELEMETRY_PRIVATE_BROWSING_KEY_SUFFIX
}
;
}
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_DATA_TRANSFERRED_SCALAR
provider
bytesTransferred
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
http
-
on
-
stop
-
request
"
:
this
.
_reportChannelBandwidth
(
aSubject
)
;
break
;
}
}
observeActivity
(
nativeChannel
activityType
activitySubtype
)
{
if
(
!
this
.
_browserInfoByURL
.
size
|
|
activityType
!
=
Ci
.
nsIHttpActivityObserver
.
ACTIVITY_TYPE_HTTP_TRANSACTION
|
|
activitySubtype
!
=
Ci
.
nsIHttpActivityObserver
.
ACTIVITY_SUBTYPE_TRANSACTION_CLOSE
)
{
return
;
}
if
(
!
(
nativeChannel
instanceof
Ci
.
nsIChannel
)
)
{
return
;
}
let
channel
=
ChannelWrapper
.
get
(
nativeChannel
)
;
if
(
channel
.
_adClickRecorded
)
{
logConsole
.
debug
(
"
Ad
click
already
recorded
"
)
;
return
;
}
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
channel
.
statusCode
=
=
204
)
{
logConsole
.
debug
(
"
Ignoring
activity
from
ambiguous
responses
"
)
;
return
;
}
let
originURL
=
channel
.
originURI
&
&
channel
.
originURI
.
spec
;
let
item
=
this
.
_findBrowserItemForURL
(
originURL
)
;
if
(
!
originURL
|
|
!
item
)
{
return
;
}
let
URL
=
channel
.
finalURL
;
let
info
=
this
.
_getProviderInfoForURL
(
URL
true
)
;
if
(
!
info
)
{
return
;
}
try
{
logConsole
.
debug
(
"
Counting
ad
click
in
page
for
"
info
.
telemetryId
item
.
source
originURL
URL
)
;
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_AD_CLICKS_SCALAR_OLD
{
info
.
telemetryId
}
:
{
item
.
info
.
oldType
}
1
)
;
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_AD_CLICKS_SCALAR_BASE
+
item
.
source
{
info
.
telemetryId
}
:
{
item
.
info
.
type
}
1
)
;
channel
.
_adClickRecorded
=
true
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
)
;
}
_reportPageWithAds
(
info
)
{
let
item
=
this
.
_findBrowserItemForURL
(
info
.
url
)
;
if
(
!
item
)
{
logConsole
.
warn
(
"
Expected
to
report
URI
for
"
info
.
url
"
with
ads
but
couldn
'
t
find
the
information
"
)
;
return
;
}
logConsole
.
debug
(
"
Counting
ads
in
page
for
"
item
.
info
.
provider
item
.
info
.
type
item
.
source
info
.
url
)
;
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_WITH_ADS_SCALAR_OLD
{
item
.
info
.
provider
}
:
{
item
.
info
.
oldType
}
1
)
;
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_WITH_ADS_SCALAR_BASE
+
item
.
source
{
item
.
info
.
provider
}
:
{
item
.
info
.
type
}
1
)
;
}
}
var
SearchSERPTelemetry
=
new
TelemetryHandler
(
)
;
