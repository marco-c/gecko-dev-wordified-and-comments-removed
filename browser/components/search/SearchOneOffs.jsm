"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SearchOneOffs
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
}
)
;
class
SearchOneOffs
{
constructor
(
container
)
{
this
.
container
=
container
;
this
.
window
=
container
.
ownerGlobal
;
this
.
document
=
container
.
ownerDocument
;
this
.
container
.
appendChild
(
this
.
window
.
MozXULElement
.
parseXULToFragment
(
<
hbox
class
=
"
search
-
panel
-
one
-
offs
-
header
search
-
panel
-
header
"
>
<
label
class
=
"
search
-
panel
-
one
-
offs
-
header
-
label
"
data
-
l10n
-
id
=
"
search
-
one
-
offs
-
with
-
title
"
/
>
<
/
hbox
>
<
box
class
=
"
search
-
panel
-
one
-
offs
-
container
"
>
<
hbox
class
=
"
search
-
panel
-
one
-
offs
"
role
=
"
group
"
/
>
<
hbox
class
=
"
search
-
one
-
offs
-
spacer
"
/
>
<
button
class
=
"
searchbar
-
engine
-
one
-
off
-
item
search
-
setting
-
button
-
compact
"
data
-
l10n
-
id
=
"
search
-
one
-
offs
-
change
-
settings
-
compact
-
button
"
/
>
<
/
box
>
<
vbox
class
=
"
search
-
add
-
engines
"
/
>
<
button
class
=
"
search
-
setting
-
button
"
data
-
l10n
-
id
=
"
search
-
one
-
offs
-
change
-
settings
-
button
"
/
>
<
box
>
<
menupopup
class
=
"
search
-
one
-
offs
-
context
-
menu
"
>
<
menuitem
class
=
"
search
-
one
-
offs
-
context
-
open
-
in
-
new
-
tab
"
data
-
l10n
-
id
=
"
search
-
one
-
offs
-
context
-
open
-
new
-
tab
"
/
>
<
menuitem
class
=
"
search
-
one
-
offs
-
context
-
set
-
default
"
data
-
l10n
-
id
=
"
search
-
one
-
offs
-
context
-
set
-
as
-
default
"
/
>
<
menuitem
class
=
"
search
-
one
-
offs
-
context
-
set
-
default
-
private
"
data
-
l10n
-
id
=
"
search
-
one
-
offs
-
context
-
set
-
as
-
default
-
private
"
/
>
<
/
menupopup
>
<
/
box
>
)
)
;
this
.
_view
=
null
;
this
.
_popup
=
null
;
this
.
_textbox
=
null
;
this
.
_textboxWidth
=
0
;
this
.
telemetryOrigin
=
"
"
;
this
.
_query
=
"
"
;
this
.
_selectedButton
=
null
;
this
.
buttons
=
this
.
querySelector
(
"
.
search
-
panel
-
one
-
offs
"
)
;
this
.
header
=
this
.
querySelector
(
"
.
search
-
panel
-
one
-
offs
-
header
"
)
;
this
.
addEngines
=
this
.
querySelector
(
"
.
search
-
add
-
engines
"
)
;
this
.
settingsButton
=
this
.
querySelector
(
"
.
search
-
setting
-
button
"
)
;
this
.
settingsButtonCompact
=
this
.
querySelector
(
"
.
search
-
setting
-
button
-
compact
"
)
;
this
.
spacerCompact
=
this
.
querySelector
(
"
.
search
-
one
-
offs
-
spacer
"
)
;
this
.
contextMenuPopup
=
this
.
querySelector
(
"
.
search
-
one
-
offs
-
context
-
menu
"
)
;
this
.
_bundle
=
null
;
this
.
_contextEngine
=
null
;
this
.
_engines
=
null
;
this
.
_rebuilding
=
false
;
this
.
_addEngineMenuThreshold
=
5
;
this
.
_addEngineMenuTimeoutMs
=
200
;
this
.
_addEngineMenuTimeout
=
null
;
this
.
_addEngineMenuShouldBeOpen
=
false
;
this
.
addEventListener
(
"
mousedown
"
this
)
;
this
.
addEventListener
(
"
mousemove
"
this
)
;
this
.
addEventListener
(
"
mouseout
"
this
)
;
this
.
addEventListener
(
"
click
"
this
)
;
this
.
addEventListener
(
"
command
"
this
)
;
this
.
addEventListener
(
"
contextmenu
"
this
)
;
let
listener
=
aEvent
=
>
aEvent
.
stopPropagation
(
)
;
this
.
contextMenuPopup
.
addEventListener
(
"
popupshowing
"
listener
)
;
this
.
contextMenuPopup
.
addEventListener
(
"
popuphiding
"
listener
)
;
this
.
contextMenuPopup
.
addEventListener
(
"
popupshown
"
aEvent
=
>
{
aEvent
.
stopPropagation
(
)
;
}
)
;
this
.
contextMenuPopup
.
addEventListener
(
"
popuphidden
"
aEvent
=
>
{
aEvent
.
stopPropagation
(
)
;
}
)
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
;
Services
.
prefs
.
addObserver
(
"
browser
.
search
.
hiddenOneOffs
"
this
true
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
search
-
engine
-
modified
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
search
-
service
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
lightweight
-
theme
-
changed
"
true
)
;
}
addEventListener
(
.
.
.
args
)
{
this
.
container
.
addEventListener
(
.
.
.
args
)
;
}
removeEventListener
(
.
.
.
args
)
{
this
.
container
.
removeEventListener
(
.
.
.
args
)
;
}
dispatchEvent
(
.
.
.
args
)
{
this
.
container
.
dispatchEvent
(
.
.
.
args
)
;
}
getAttribute
(
.
.
.
args
)
{
return
this
.
container
.
getAttribute
(
.
.
.
args
)
;
}
setAttribute
(
.
.
.
args
)
{
this
.
container
.
setAttribute
(
.
.
.
args
)
;
}
querySelector
(
.
.
.
args
)
{
return
this
.
container
.
querySelector
(
.
.
.
args
)
;
}
handleEvent
(
event
)
{
let
methodName
=
"
_on_
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
new
Error
(
"
Unrecognized
search
-
one
-
offs
event
:
"
+
event
.
type
)
;
}
}
get
buttonWidth
(
)
{
return
48
;
}
get
buttonHeight
(
)
{
return
32
;
}
set
view
(
val
)
{
if
(
this
.
_view
)
{
this
.
_view
.
controller
.
removeQueryListener
(
this
)
;
}
this
.
_view
=
val
;
if
(
val
)
{
if
(
val
.
isOpen
)
{
this
.
_rebuild
(
)
;
}
val
.
controller
.
addQueryListener
(
this
)
;
}
}
set
popup
(
val
)
{
if
(
this
.
_popup
)
{
this
.
_popup
.
removeEventListener
(
"
popupshowing
"
this
)
;
this
.
_popup
.
removeEventListener
(
"
popuphidden
"
this
)
;
}
if
(
val
)
{
val
.
addEventListener
(
"
popupshowing
"
this
)
;
val
.
addEventListener
(
"
popuphidden
"
this
)
;
}
this
.
_popup
=
val
;
if
(
val
&
&
val
.
state
!
=
"
closed
"
)
{
this
.
_rebuild
(
)
;
}
}
get
popup
(
)
{
return
this
.
_popup
;
}
set
textbox
(
val
)
{
if
(
this
.
_textbox
)
{
this
.
_textbox
.
removeEventListener
(
"
input
"
this
)
;
}
if
(
val
)
{
val
.
addEventListener
(
"
input
"
this
)
;
}
this
.
_textbox
=
val
;
}
get
style
(
)
{
return
this
.
container
.
style
;
}
get
textbox
(
)
{
return
this
.
_textbox
;
}
set
query
(
val
)
{
this
.
_query
=
val
;
if
(
(
this
.
_view
&
&
this
.
_view
.
isOpen
)
|
|
(
this
.
popup
&
&
this
.
popup
.
popupOpen
)
)
{
let
isOneOffSelected
=
this
.
selectedButton
&
&
this
.
selectedButton
.
classList
.
contains
(
"
searchbar
-
engine
-
one
-
off
-
item
"
)
;
if
(
this
.
selectedButton
&
&
!
isOneOffSelected
)
{
this
.
selectedButton
=
null
;
}
}
}
get
query
(
)
{
return
this
.
_query
;
}
set
selectedButton
(
val
)
{
let
previousButton
=
this
.
_selectedButton
;
if
(
previousButton
)
{
previousButton
.
removeAttribute
(
"
selected
"
)
;
}
if
(
val
)
{
val
.
setAttribute
(
"
selected
"
"
true
"
)
;
if
(
!
val
.
engine
)
{
this
.
selectedAutocompleteIndex
=
-
1
;
}
}
this
.
_selectedButton
=
val
;
if
(
this
.
textbox
)
{
if
(
val
)
{
this
.
textbox
.
setAttribute
(
"
aria
-
activedescendant
"
val
.
id
)
;
}
else
{
let
active
=
this
.
textbox
.
getAttribute
(
"
aria
-
activedescendant
"
)
;
if
(
active
&
&
active
.
includes
(
"
-
engine
-
one
-
off
-
item
-
"
)
)
{
this
.
textbox
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
}
}
let
event
=
new
CustomEvent
(
"
SelectedOneOffButtonChanged
"
{
previousSelectedButton
:
previousButton
}
)
;
this
.
dispatchEvent
(
event
)
;
}
get
selectedButton
(
)
{
return
this
.
_selectedButton
;
}
set
selectedButtonIndex
(
val
)
{
let
buttons
=
this
.
getSelectableButtons
(
true
)
;
this
.
selectedButton
=
buttons
[
val
]
;
}
get
selectedButtonIndex
(
)
{
let
buttons
=
this
.
getSelectableButtons
(
true
)
;
for
(
let
i
=
0
;
i
<
buttons
.
length
;
i
+
+
)
{
if
(
buttons
[
i
]
=
=
this
.
_selectedButton
)
{
return
i
;
}
}
return
-
1
;
}
get
selectedAutocompleteIndex
(
)
{
if
(
!
this
.
compact
)
{
return
this
.
popup
.
selectedIndex
;
}
return
this
.
_view
.
selectedElementIndex
;
}
set
selectedAutocompleteIndex
(
val
)
{
if
(
!
this
.
compact
)
{
this
.
popup
.
selectedIndex
=
val
;
return
;
}
this
.
_view
.
selectedElementIndex
=
val
;
}
get
compact
(
)
{
return
this
.
getAttribute
(
"
compact
"
)
=
=
"
true
"
;
}
get
bundle
(
)
{
if
(
!
this
.
_bundle
)
{
const
kBundleURI
=
"
chrome
:
/
/
browser
/
locale
/
search
.
properties
"
;
this
.
_bundle
=
Services
.
strings
.
createBundle
(
kBundleURI
)
;
}
return
this
.
_bundle
;
}
async
getEngines
(
)
{
if
(
this
.
_engines
)
{
return
this
.
_engines
;
}
let
currentEngineNameToIgnore
;
if
(
!
this
.
getAttribute
(
"
includecurrentengine
"
)
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
)
{
currentEngineNameToIgnore
=
(
await
Services
.
search
.
getDefaultPrivate
(
)
)
.
name
;
}
else
{
currentEngineNameToIgnore
=
(
await
Services
.
search
.
getDefault
(
)
)
.
name
;
}
}
let
pref
=
Services
.
prefs
.
getStringPref
(
"
browser
.
search
.
hiddenOneOffs
"
)
;
let
hiddenList
=
pref
?
pref
.
split
(
"
"
)
:
[
]
;
this
.
_engines
=
(
await
Services
.
search
.
getVisibleEngines
(
)
)
.
filter
(
e
=
>
{
let
name
=
e
.
name
;
return
(
(
!
currentEngineNameToIgnore
|
|
name
!
=
currentEngineNameToIgnore
)
&
&
!
hiddenList
.
includes
(
name
)
)
;
}
)
;
return
this
.
_engines
;
}
observe
(
aEngine
aTopic
aData
)
{
this
.
_engines
=
null
;
}
async
_rebuild
(
)
{
if
(
this
.
_rebuilding
)
{
return
;
}
this
.
_rebuilding
=
true
;
try
{
await
this
.
__rebuild
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Search
-
one
-
offs
:
:
_rebuild
(
)
error
:
"
+
ex
)
;
}
finally
{
this
.
_rebuilding
=
false
;
}
}
async
__rebuild
(
)
{
if
(
!
this
.
compact
)
{
this
.
_rebuildAddEngineList
(
)
;
}
if
(
!
this
.
popup
&
&
this
.
_engines
)
{
return
;
}
if
(
this
.
popup
&
&
this
.
_textbox
)
{
let
textboxWidth
=
await
this
.
window
.
promiseDocumentFlushed
(
(
)
=
>
{
return
this
.
_textbox
.
clientWidth
;
}
)
;
if
(
this
.
_engines
&
&
this
.
_textboxWidth
=
=
textboxWidth
)
{
return
;
}
this
.
_textboxWidth
=
textboxWidth
;
}
while
(
this
.
buttons
.
firstElementChild
)
{
this
.
buttons
.
firstElementChild
.
remove
(
)
;
}
let
headerText
=
this
.
header
.
querySelector
(
"
.
search
-
panel
-
one
-
offs
-
header
-
label
"
)
;
headerText
.
id
=
this
.
telemetryOrigin
+
"
-
one
-
offs
-
header
-
label
"
;
this
.
buttons
.
setAttribute
(
"
aria
-
labelledby
"
headerText
.
id
)
;
let
engines
=
await
this
.
getEngines
(
)
;
let
defaultEngine
=
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
?
await
Services
.
search
.
getDefaultPrivate
(
)
:
await
Services
.
search
.
getDefault
(
)
;
let
oneOffCount
=
engines
.
length
;
let
hideOneOffs
=
!
oneOffCount
|
|
(
oneOffCount
=
=
1
&
&
engines
[
0
]
.
name
=
=
defaultEngine
.
name
)
;
if
(
this
.
compact
)
{
this
.
container
.
hidden
=
hideOneOffs
;
}
else
{
this
.
header
.
hidden
=
this
.
buttons
.
hidden
=
hideOneOffs
;
}
if
(
hideOneOffs
)
{
return
;
}
if
(
this
.
compact
)
{
this
.
spacerCompact
.
setAttribute
(
"
flex
"
"
1
"
)
;
}
if
(
this
.
popup
)
{
let
buttonsWidth
=
this
.
popup
.
clientWidth
;
let
scale
=
this
.
window
.
windowUtils
.
screenPixelsPerCSSPixel
;
if
(
Math
.
floor
(
scale
)
!
=
scale
)
{
-
-
buttonsWidth
;
}
this
.
buttons
.
style
.
setProperty
(
"
max
-
width
"
{
buttonsWidth
}
px
)
;
buttonsWidth
=
Math
.
max
(
buttonsWidth
this
.
buttonWidth
)
;
let
enginesPerRow
=
Math
.
floor
(
buttonsWidth
/
this
.
buttonWidth
)
;
let
rowCount
=
Math
.
ceil
(
oneOffCount
/
enginesPerRow
)
;
let
height
=
rowCount
*
this
.
buttonHeight
;
this
.
buttons
.
style
.
setProperty
(
"
height
"
{
height
}
px
)
;
}
let
origin
=
this
.
telemetryOrigin
;
this
.
settingsButton
.
id
=
origin
+
"
-
anon
-
search
-
settings
"
;
this
.
settingsButtonCompact
.
id
=
origin
+
"
-
anon
-
search
-
settings
-
compact
"
;
for
(
let
i
=
0
;
i
<
engines
.
length
;
+
+
i
)
{
let
engine
=
engines
[
i
]
;
let
button
=
this
.
document
.
createXULElement
(
"
button
"
)
;
button
.
id
=
this
.
_buttonIDForEngine
(
engine
)
;
let
uri
=
"
chrome
:
/
/
browser
/
skin
/
search
-
engine
-
placeholder
.
png
"
;
if
(
engine
.
iconURI
)
{
uri
=
engine
.
iconURI
.
spec
;
}
button
.
setAttribute
(
"
image
"
uri
)
;
button
.
setAttribute
(
"
class
"
"
searchbar
-
engine
-
one
-
off
-
item
"
)
;
if
(
this
.
compact
)
{
let
tooltip
=
engine
.
name
;
let
aliases
=
UrlbarSearchUtils
.
aliasesForEngine
(
engine
)
;
if
(
aliases
.
length
)
{
tooltip
=
tooltip
+
(
{
aliases
[
0
]
}
)
;
}
button
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
}
else
{
button
.
setAttribute
(
"
tooltiptext
"
engine
.
name
)
;
}
button
.
engine
=
engine
;
this
.
buttons
.
appendChild
(
button
)
;
}
this
.
dispatchEvent
(
new
Event
(
"
rebuild
"
)
)
;
}
_rebuildAddEngineList
(
)
{
let
list
=
this
.
addEngines
;
while
(
list
.
firstChild
)
{
list
.
firstChild
.
remove
(
)
;
}
if
(
!
this
.
window
.
gBrowser
.
selectedBrowser
.
engines
)
{
return
;
}
let
engines
=
this
.
window
.
gBrowser
.
selectedBrowser
.
engines
;
let
tooManyEngines
=
engines
.
length
>
this
.
_addEngineMenuThreshold
;
if
(
tooManyEngines
)
{
let
button
=
this
.
document
.
createXULElement
(
"
toolbarbutton
"
)
;
button
.
classList
.
add
(
"
addengine
-
menu
-
button
"
"
addengine
-
item
"
)
;
button
.
setAttribute
(
"
badged
"
"
true
"
)
;
button
.
setAttribute
(
"
type
"
"
menu
"
)
;
button
.
setAttribute
(
"
wantdropmarker
"
"
true
"
)
;
button
.
setAttribute
(
"
label
"
this
.
bundle
.
GetStringFromName
(
"
cmd_addFoundEngineMenu
"
)
)
;
button
.
setAttribute
(
"
crop
"
"
end
"
)
;
button
.
setAttribute
(
"
pack
"
"
start
"
)
;
let
engine
=
engines
[
0
]
;
if
(
engine
.
icon
)
{
button
.
setAttribute
(
"
image
"
engine
.
icon
)
;
}
list
.
appendChild
(
button
)
;
list
=
this
.
document
.
createXULElement
(
"
menupopup
"
)
;
button
.
appendChild
(
list
)
;
list
.
setAttribute
(
"
class
"
"
addengine
-
menu
"
)
;
list
.
setAttribute
(
"
position
"
"
topright
topleft
"
)
;
let
suppressEventTypes
=
[
"
popupshowing
"
"
popuphiding
"
"
popupshown
"
"
popuphidden
"
]
;
for
(
let
type
of
suppressEventTypes
)
{
list
.
addEventListener
(
type
event
=
>
{
event
.
stopPropagation
(
)
;
}
)
;
}
}
let
eltType
=
tooManyEngines
?
"
menuitem
"
:
"
toolbarbutton
"
;
for
(
let
engine
of
engines
)
{
let
button
=
this
.
document
.
createXULElement
(
eltType
)
;
button
.
classList
.
add
(
"
addengine
-
item
"
)
;
if
(
!
tooManyEngines
)
{
button
.
setAttribute
(
"
badged
"
"
true
"
)
;
}
button
.
id
=
this
.
telemetryOrigin
+
"
-
add
-
engine
-
"
+
this
.
_fixUpEngineNameForID
(
engine
.
title
)
;
let
label
=
this
.
bundle
.
formatStringFromName
(
"
cmd_addFoundEngine
"
[
engine
.
title
]
)
;
button
.
setAttribute
(
"
label
"
label
)
;
button
.
setAttribute
(
"
crop
"
"
end
"
)
;
button
.
setAttribute
(
"
tooltiptext
"
engine
.
title
+
"
\
n
"
+
engine
.
uri
)
;
button
.
setAttribute
(
"
uri
"
engine
.
uri
)
;
button
.
setAttribute
(
"
title
"
engine
.
title
)
;
if
(
engine
.
icon
)
{
button
.
setAttribute
(
"
image
"
engine
.
icon
)
;
}
if
(
tooManyEngines
)
{
button
.
classList
.
add
(
"
menuitem
-
iconic
"
)
;
}
else
{
button
.
setAttribute
(
"
pack
"
"
start
"
)
;
}
list
.
appendChild
(
button
)
;
}
}
_buttonIDForEngine
(
engine
)
{
return
(
this
.
telemetryOrigin
+
"
-
engine
-
one
-
off
-
item
-
"
+
this
.
_fixUpEngineNameForID
(
engine
.
name
)
)
;
}
_fixUpEngineNameForID
(
name
)
{
return
name
.
replace
(
/
/
g
"
-
"
)
;
}
_buttonForEngine
(
engine
)
{
let
id
=
this
.
_buttonIDForEngine
(
engine
)
;
return
this
.
document
.
getElementById
(
id
)
;
}
getSelectableButtons
(
aIncludeNonEngineButtons
)
{
let
buttons
=
[
]
;
for
(
let
oneOff
=
this
.
buttons
.
firstElementChild
;
oneOff
;
oneOff
=
oneOff
.
nextElementSibling
)
{
buttons
.
push
(
oneOff
)
;
}
if
(
aIncludeNonEngineButtons
)
{
for
(
let
addEngine
=
this
.
addEngines
.
firstElementChild
;
addEngine
;
addEngine
=
addEngine
.
nextElementSibling
)
{
buttons
.
push
(
addEngine
)
;
}
buttons
.
push
(
this
.
compact
?
this
.
settingsButtonCompact
:
this
.
settingsButton
)
;
}
return
buttons
;
}
handleSearchCommand
(
aEvent
aEngine
aForceNewTab
)
{
if
(
this
.
_view
?
.
oneOffsCommandHandler
(
aEvent
aEngine
)
)
{
return
;
}
let
where
=
"
current
"
;
let
params
;
if
(
aForceNewTab
)
{
where
=
"
tab
"
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
)
{
params
=
{
inBackground
:
true
}
;
}
}
else
{
let
newTabPref
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
openintab
"
)
;
if
(
(
aEvent
instanceof
KeyboardEvent
&
&
aEvent
.
altKey
)
^
newTabPref
&
&
!
this
.
window
.
gBrowser
.
selectedTab
.
isEmpty
)
{
where
=
"
tab
"
;
}
if
(
aEvent
instanceof
MouseEvent
&
&
(
aEvent
.
button
=
=
1
|
|
aEvent
.
getModifierState
(
"
Accel
"
)
)
)
{
where
=
"
tab
"
;
params
=
{
inBackground
:
true
}
;
}
}
(
this
.
_view
|
|
this
.
popup
)
.
handleOneOffSearch
(
aEvent
aEngine
where
params
)
;
}
advanceSelection
(
aForward
aIncludeNonEngineButtons
aWrapAround
)
{
let
buttons
=
this
.
getSelectableButtons
(
aIncludeNonEngineButtons
)
;
let
index
;
if
(
this
.
selectedButton
)
{
let
inc
=
aForward
?
1
:
-
1
;
let
oldIndex
=
buttons
.
indexOf
(
this
.
selectedButton
)
;
index
=
(
oldIndex
+
inc
+
buttons
.
length
)
%
buttons
.
length
;
if
(
!
aWrapAround
&
&
(
(
aForward
&
&
index
<
=
oldIndex
)
|
|
(
!
aForward
&
&
oldIndex
<
=
index
)
)
)
{
index
=
-
1
;
}
}
else
{
index
=
aForward
?
0
:
buttons
.
length
-
1
;
}
this
.
selectedButton
=
index
<
0
?
null
:
buttons
[
index
]
;
}
handleKeyDown
(
event
numListItems
allowEmptySelection
textboxUserValue
)
{
if
(
!
this
.
popup
&
&
!
this
.
_view
)
{
return
false
;
}
let
handled
=
this
.
_handleKeyDown
(
event
numListItems
allowEmptySelection
textboxUserValue
)
;
if
(
handled
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
return
handled
;
}
_handleKeyDown
(
event
numListItems
allowEmptySelection
textboxUserValue
)
{
if
(
this
.
compact
&
&
this
.
container
.
hidden
)
{
return
false
;
}
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_RIGHT
&
&
this
.
selectedButton
&
&
this
.
selectedButton
.
classList
.
contains
(
"
addengine
-
menu
-
button
"
)
)
{
this
.
selectedButton
.
open
=
true
;
return
true
;
}
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_TAB
&
&
!
event
.
getModifierState
(
"
Alt
"
)
&
&
!
event
.
getModifierState
(
"
AltGraph
"
)
&
&
!
event
.
getModifierState
(
"
Control
"
)
&
&
!
event
.
getModifierState
(
"
Meta
"
)
)
{
if
(
this
.
getAttribute
(
"
disabletab
"
)
=
=
"
true
"
|
|
(
event
.
shiftKey
&
&
this
.
selectedButtonIndex
<
=
0
)
|
|
(
!
event
.
shiftKey
&
&
this
.
selectedButtonIndex
=
=
this
.
getSelectableButtons
(
true
)
.
length
-
1
)
)
{
this
.
selectedButton
=
null
;
return
false
;
}
this
.
selectedAutocompleteIndex
=
-
1
;
this
.
advanceSelection
(
!
event
.
shiftKey
true
false
)
;
return
!
!
this
.
selectedButton
;
}
if
(
event
.
keyCode
=
=
KeyboardEvent
.
DOM_VK_UP
)
{
if
(
event
.
altKey
)
{
this
.
advanceSelection
(
false
false
false
)
;
return
true
;
}
if
(
numListItems
=
=
0
)
{
this
.
advanceSelection
(
false
true
false
)
;
return
true
;
}
if
(
this
.
selectedAutocompleteIndex
>
0
)
{
this
.
selectedButton
=
null
;
return
false
;
}
if
(
this
.
selectedAutocompleteIndex
=
=
0
)
{
if
(
allowEmptySelection
)
{
return
false
;
}
if
(
this
.
textbox
&
&
typeof
textboxUserValue
=
=
"
string
"
)
{
this
.
textbox
.
value
=
textboxUserValue
;
}
this
.
advanceSelection
(
false
true
true
)
;
return
true
;
}
if
(
!
this
.
selectedButton
)
{
this
.
advanceSelection
(
false
true
true
)
;
return
true
;
}
if
(
this
.
selectedButtonIndex
=
=
0
)
{
this
.
selectedButton
=
null
;
return
false
;
}
this
.
advanceSelection
(
false
true
false
)
;
return
true
;
}
if
(
event
.
keyCode
=
=
KeyboardEvent
.
DOM_VK_DOWN
)
{
if
(
event
.
altKey
)
{
this
.
advanceSelection
(
true
false
false
)
;
return
true
;
}
if
(
numListItems
=
=
0
)
{
this
.
advanceSelection
(
true
true
false
)
;
return
true
;
}
if
(
this
.
selectedAutocompleteIndex
>
=
0
&
&
this
.
selectedAutocompleteIndex
<
numListItems
-
1
)
{
this
.
selectedButton
=
null
;
return
false
;
}
if
(
this
.
selectedAutocompleteIndex
=
=
numListItems
-
1
)
{
if
(
!
allowEmptySelection
)
{
this
.
selectedAutocompleteIndex
=
-
1
;
if
(
this
.
textbox
&
&
typeof
textboxUserValue
=
=
"
string
"
)
{
this
.
textbox
.
value
=
textboxUserValue
;
}
}
this
.
selectedButtonIndex
=
0
;
if
(
allowEmptySelection
)
{
return
false
;
}
return
true
;
}
if
(
this
.
selectedButton
)
{
let
buttons
=
this
.
getSelectableButtons
(
true
)
;
if
(
this
.
selectedButtonIndex
=
=
buttons
.
length
-
1
)
{
this
.
selectedButton
=
null
;
if
(
allowEmptySelection
)
{
return
true
;
}
return
false
;
}
this
.
advanceSelection
(
true
true
false
)
;
return
true
;
}
return
false
;
}
if
(
event
.
keyCode
=
=
KeyboardEvent
.
DOM_VK_LEFT
)
{
if
(
this
.
selectedButton
&
&
(
this
.
compact
|
|
this
.
selectedButton
.
engine
)
)
{
this
.
advanceSelection
(
false
this
.
compact
true
)
;
return
true
;
}
return
false
;
}
if
(
event
.
keyCode
=
=
KeyboardEvent
.
DOM_VK_RIGHT
)
{
if
(
this
.
selectedButton
&
&
(
this
.
compact
|
|
this
.
selectedButton
.
engine
)
)
{
this
.
advanceSelection
(
true
this
.
compact
true
)
;
return
true
;
}
return
false
;
}
return
false
;
}
maybeRecordTelemetry
(
aEvent
)
{
if
(
!
aEvent
)
{
return
false
;
}
let
source
=
null
;
let
type
=
"
unknown
"
;
let
engine
=
null
;
let
target
=
aEvent
.
originalTarget
;
if
(
aEvent
instanceof
KeyboardEvent
)
{
type
=
"
key
"
;
if
(
this
.
selectedButton
)
{
source
=
"
oneoff
"
;
engine
=
this
.
selectedButton
.
engine
;
}
}
else
if
(
aEvent
instanceof
MouseEvent
)
{
type
=
"
mouse
"
;
if
(
target
.
classList
.
contains
(
"
searchbar
-
engine
-
one
-
off
-
item
"
)
)
{
source
=
"
oneoff
"
;
engine
=
target
.
engine
;
}
}
else
if
(
aEvent
instanceof
this
.
window
.
XULCommandEvent
&
&
target
.
classList
.
contains
(
"
search
-
one
-
offs
-
context
-
open
-
in
-
new
-
tab
"
)
)
{
source
=
"
oneoff
-
context
"
;
engine
=
this
.
_contextEngine
;
}
if
(
!
source
)
{
return
false
;
}
if
(
this
.
telemetryOrigin
)
{
source
+
=
"
-
"
+
this
.
telemetryOrigin
;
}
this
.
window
.
BrowserSearch
.
recordOneoffSearchInTelemetry
(
engine
source
type
)
;
return
true
;
}
_resetAddEngineMenuTimeout
(
)
{
if
(
this
.
_addEngineMenuTimeout
)
{
clearTimeout
(
this
.
_addEngineMenuTimeout
)
;
}
this
.
_addEngineMenuTimeout
=
setTimeout
(
(
)
=
>
{
delete
this
.
_addEngineMenuTimeout
;
let
button
=
this
.
querySelector
(
"
.
addengine
-
menu
-
button
"
)
;
button
.
open
=
this
.
_addEngineMenuShouldBeOpen
;
}
this
.
_addEngineMenuTimeoutMs
)
;
}
_on_mousedown
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
target
.
classList
.
contains
(
"
addengine
-
menu
-
button
"
)
)
{
return
;
}
event
.
preventDefault
(
)
;
}
_on_mousemove
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
(
target
.
localName
=
=
"
menuitem
"
&
&
target
.
classList
.
contains
(
"
addengine
-
item
"
)
)
|
|
target
.
classList
.
contains
(
"
addengine
-
menu
-
button
"
)
)
{
this
.
_addEngineMenuShouldBeOpen
=
true
;
this
.
_resetAddEngineMenuTimeout
(
)
;
}
}
_on_mouseout
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
(
target
.
localName
=
=
"
menuitem
"
&
&
target
.
classList
.
contains
(
"
addengine
-
item
"
)
)
|
|
target
.
classList
.
contains
(
"
addengine
-
menu
-
button
"
)
)
{
this
.
_addEngineMenuShouldBeOpen
=
false
;
this
.
_resetAddEngineMenuTimeout
(
)
;
}
}
_on_click
(
event
)
{
if
(
this
.
_view
?
.
oneOffsClickHandler
(
event
)
)
{
return
;
}
if
(
event
.
button
=
=
2
)
{
return
;
}
let
button
=
event
.
originalTarget
;
let
engine
=
button
.
engine
;
if
(
!
engine
)
{
return
;
}
this
.
selectedButton
=
button
;
this
.
handleSearchCommand
(
event
engine
)
;
}
_on_command
(
event
)
{
let
target
=
event
.
target
;
if
(
target
=
=
this
.
settingsButton
|
|
target
=
=
this
.
settingsButtonCompact
)
{
this
.
window
.
openPreferences
(
"
paneSearch
"
)
;
if
(
this
.
_view
)
{
this
.
_view
.
close
(
)
;
}
else
{
this
.
popup
.
hidePopup
(
)
;
}
return
;
}
if
(
target
.
classList
.
contains
(
"
addengine
-
item
"
)
)
{
Services
.
search
.
addOpenSearchEngine
(
target
.
getAttribute
(
"
uri
"
)
target
.
getAttribute
(
"
image
"
)
)
.
then
(
engine
=
>
{
this
.
_rebuild
(
)
;
}
)
.
catch
(
errorCode
=
>
{
if
(
errorCode
!
=
Ci
.
nsISearchService
.
ERROR_DUPLICATE_ENGINE
)
{
return
;
}
const
kSearchBundleURI
=
"
chrome
:
/
/
global
/
locale
/
search
/
search
.
properties
"
;
let
searchBundle
=
Services
.
strings
.
createBundle
(
kSearchBundleURI
)
;
let
brandBundle
=
this
.
document
.
getElementById
(
"
bundle_brand
"
)
;
let
brandName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
let
title
=
searchBundle
.
GetStringFromName
(
"
error_invalid_engine_title
"
)
;
let
text
=
searchBundle
.
formatStringFromName
(
"
error_duplicate_engine_msg
"
[
brandName
target
.
getAttribute
(
"
uri
"
)
]
)
;
Services
.
prompt
.
alertBC
(
this
.
window
.
gBrowser
.
selectedBrowser
.
browsingContext
Ci
.
nsIPrompt
.
MODAL_TYPE_CONTENT
title
text
)
;
}
)
;
}
if
(
target
.
classList
.
contains
(
"
search
-
one
-
offs
-
context
-
open
-
in
-
new
-
tab
"
)
)
{
this
.
selectedButton
=
this
.
_buttonForEngine
(
this
.
_contextEngine
)
;
this
.
handleSearchCommand
(
event
this
.
_contextEngine
true
)
;
}
const
isPrivateButton
=
target
.
classList
.
contains
(
"
search
-
one
-
offs
-
context
-
set
-
default
-
private
"
)
;
if
(
target
.
classList
.
contains
(
"
search
-
one
-
offs
-
context
-
set
-
default
"
)
|
|
isPrivateButton
)
{
const
engineType
=
isPrivateButton
?
"
defaultPrivateEngine
"
:
"
defaultEngine
"
;
let
currentEngine
=
Services
.
search
[
engineType
]
;
const
isPrivateWin
=
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
;
if
(
!
this
.
getAttribute
(
"
includecurrentengine
"
)
&
&
isPrivateButton
=
=
isPrivateWin
)
{
let
button
=
this
.
_buttonForEngine
(
this
.
_contextEngine
)
;
button
.
id
=
this
.
_buttonIDForEngine
(
currentEngine
)
;
let
uri
=
"
chrome
:
/
/
browser
/
skin
/
search
-
engine
-
placeholder
.
png
"
;
if
(
currentEngine
.
iconURI
)
{
uri
=
currentEngine
.
iconURI
.
spec
;
}
button
.
setAttribute
(
"
image
"
uri
)
;
button
.
setAttribute
(
"
tooltiptext
"
currentEngine
.
name
)
;
button
.
engine
=
currentEngine
;
}
Services
.
search
[
engineType
]
=
this
.
_contextEngine
;
}
}
_on_contextmenu
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
!
target
.
classList
.
contains
(
"
searchbar
-
engine
-
one
-
off
-
item
"
)
|
|
target
.
classList
.
contains
(
"
search
-
setting
-
button
-
compact
"
)
)
{
event
.
preventDefault
(
)
;
return
;
}
this
.
contextMenuPopup
.
querySelector
(
"
.
search
-
one
-
offs
-
context
-
set
-
default
"
)
.
setAttribute
(
"
disabled
"
target
.
engine
=
=
Services
.
search
.
defaultEngine
.
wrappedJSObject
)
;
const
privateDefaultItem
=
this
.
contextMenuPopup
.
querySelector
(
"
.
search
-
one
-
offs
-
context
-
set
-
default
-
private
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
separatePrivateDefault
.
ui
.
enabled
"
false
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
search
.
separatePrivateDefault
"
false
)
)
{
privateDefaultItem
.
hidden
=
false
;
privateDefaultItem
.
setAttribute
(
"
disabled
"
target
.
engine
=
=
Services
.
search
.
defaultPrivateEngine
.
wrappedJSObject
)
;
}
else
{
privateDefaultItem
.
hidden
=
true
;
}
this
.
contextMenuPopup
.
openPopupAtScreen
(
event
.
screenX
event
.
screenY
true
)
;
event
.
preventDefault
(
)
;
this
.
_contextEngine
=
target
.
engine
;
}
_on_input
(
event
)
{
this
.
query
=
event
.
target
.
oneOffSearchQuery
|
|
event
.
target
.
value
;
}
_on_popupshowing
(
)
{
this
.
onViewOpen
(
)
;
}
_on_popuphidden
(
)
{
this
.
onViewClose
(
)
;
}
onViewOpen
(
)
{
this
.
_rebuild
(
)
;
}
onViewClose
(
)
{
this
.
selectedButton
=
null
;
this
.
_contextEngine
=
null
;
}
}
