"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SearchTelemetry
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
SEARCH_COUNTS_HISTOGRAM_KEY
=
"
SEARCH_COUNTS
"
;
const
SEARCH_WITH_ADS_SCALAR
=
"
browser
.
search
.
with_ads
"
;
const
SEARCH_AD_CLICKS_SCALAR
=
"
browser
.
search
.
ad_clicks
"
;
const
SEARCH_PROVIDER_INFO
=
{
google
:
{
regexp
:
/
^
https
:
\
/
\
/
www
\
.
google
\
.
(
?
:
.
+
)
\
/
search
/
queryParam
:
"
q
"
codeParam
:
"
client
"
codePrefixes
:
[
"
firefox
"
]
followonParams
:
[
"
oq
"
"
ved
"
"
ei
"
]
extraAdServersRegexps
:
[
/
^
https
:
\
/
\
/
www
\
.
google
(
?
:
adservices
)
?
\
.
com
\
/
(
?
:
pagead
\
/
)
?
aclk
/
]
}
duckduckgo
:
{
regexp
:
/
^
https
:
\
/
\
/
duckduckgo
\
.
com
\
/
/
queryParam
:
"
q
"
codeParam
:
"
t
"
codePrefixes
:
[
"
ff
"
]
extraAdServersRegexps
:
[
/
^
https
:
\
/
\
/
duckduckgo
.
com
\
/
y
\
.
js
/
/
^
https
:
\
/
\
/
www
\
.
amazon
\
.
(
?
:
[
a
-
z
.
]
{
2
24
}
)
.
*
(
?
:
tag
=
duckduckgo
-
)
/
]
}
yahoo
:
{
regexp
:
/
^
https
:
\
/
\
/
(
?
:
.
*
)
search
\
.
yahoo
\
.
com
\
/
search
/
queryParam
:
"
p
"
}
baidu
:
{
regexp
:
/
^
https
:
\
/
\
/
www
\
.
baidu
\
.
com
\
/
(
?
:
s
|
baidu
)
/
queryParam
:
"
wd
"
codeParam
:
"
tn
"
codePrefixes
:
[
"
34046034_
"
"
monline_
"
]
followonParams
:
[
"
oq
"
]
}
bing
:
{
regexp
:
/
^
https
:
\
/
\
/
www
\
.
bing
\
.
com
\
/
search
/
queryParam
:
"
q
"
codeParam
:
"
pc
"
codePrefixes
:
[
"
MOZ
"
"
MZ
"
]
followonCookies
:
[
{
extraCodeParam
:
"
form
"
extraCodePrefixes
:
[
"
QBRE
"
]
host
:
"
www
.
bing
.
com
"
name
:
"
SRCHS
"
codeParam
:
"
PC
"
codePrefixes
:
[
"
MOZ
"
"
MZ
"
]
}
]
extraAdServersRegexps
:
[
/
^
https
:
\
/
\
/
www
\
.
bing
\
.
com
\
/
acli
?
c
?
k
/
/
^
https
:
\
/
\
/
www
\
.
bing
\
.
com
\
/
fd
\
/
ls
\
/
GLinkPingPost
\
.
aspx
.
*
acli
?
c
?
k
/
]
}
}
;
const
BROWSER_SEARCH_PREF
=
"
browser
.
search
.
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
loggingEnabled
"
BROWSER_SEARCH_PREF
+
"
log
"
false
)
;
class
TelemetryHandler
{
constructor
(
)
{
this
.
_browserInfoByURL
=
new
Map
(
)
;
this
.
_initialized
=
false
;
this
.
__searchProviderInfo
=
null
;
this
.
_contentHandler
=
new
ContentHandler
(
{
browserInfoByURL
:
this
.
_browserInfoByURL
findBrowserItemForURL
:
(
.
.
.
args
)
=
>
this
.
_findBrowserItemForURL
(
.
.
.
args
)
getProviderInfoForURL
:
(
.
.
.
args
)
=
>
this
.
_getProviderInfoForURL
(
.
.
.
args
)
}
)
;
}
init
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_contentHandler
.
init
(
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
this
.
_registerWindow
(
win
)
;
}
Services
.
wm
.
addListener
(
this
)
;
this
.
_initialized
=
true
;
}
uninit
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_contentHandler
.
uninit
(
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
this
.
_unregisterWindow
(
win
)
;
}
Services
.
wm
.
removeListener
(
this
)
;
this
.
_initialized
=
false
;
}
handleEvent
(
event
)
{
if
(
event
.
type
!
=
"
TabClose
"
)
{
Cu
.
reportError
(
Received
unexpected
event
type
{
event
.
type
}
)
;
return
;
}
this
.
stopTrackingBrowser
(
event
.
target
.
linkedBrowser
)
;
}
overrideSearchTelemetryForTests
(
infoByProvider
)
{
if
(
infoByProvider
)
{
for
(
let
info
of
Object
.
values
(
infoByProvider
)
)
{
info
.
regexp
=
new
RegExp
(
info
.
regexp
)
;
}
this
.
__searchProviderInfo
=
infoByProvider
;
}
else
{
this
.
__searchProviderInfo
=
SEARCH_PROVIDER_INFO
;
}
this
.
_contentHandler
.
overrideSearchTelemetryForTests
(
this
.
__searchProviderInfo
)
;
}
updateTrackingStatus
(
browser
url
)
{
let
info
=
this
.
_checkURLForSerpMatch
(
url
)
;
if
(
!
info
)
{
this
.
stopTrackingBrowser
(
browser
)
;
return
;
}
this
.
_reportSerpPage
(
info
url
)
;
if
(
info
.
code
)
{
let
item
=
this
.
_browserInfoByURL
.
get
(
url
)
;
if
(
item
)
{
item
.
browsers
.
add
(
browser
)
;
item
.
count
+
+
;
}
else
{
this
.
_browserInfoByURL
.
set
(
url
{
browsers
:
new
WeakSet
(
[
browser
]
)
info
count
:
1
}
)
;
}
}
}
stopTrackingBrowser
(
browser
)
{
for
(
let
[
url
item
]
of
this
.
_browserInfoByURL
)
{
if
(
item
.
browsers
.
has
(
browser
)
)
{
item
.
browsers
.
delete
(
browser
)
;
item
.
count
-
-
;
}
if
(
!
item
.
count
)
{
this
.
_browserInfoByURL
.
delete
(
url
)
;
}
}
}
_findBrowserItemForURL
(
url
)
{
try
{
url
=
new
URL
(
url
)
;
}
catch
(
ex
)
{
return
null
;
}
const
compareURLs
=
(
url1
url2
)
=
>
{
if
(
url1
.
href
=
=
url2
.
href
)
{
return
Infinity
;
}
let
score
=
0
;
if
(
url1
.
hostname
=
=
url2
.
hostname
)
{
+
+
score
;
if
(
url1
.
pathname
=
=
url2
.
pathname
)
{
+
+
score
;
for
(
let
[
key1
value1
]
of
url1
.
searchParams
)
{
if
(
url2
.
searchParams
.
has
(
key1
)
)
{
+
+
score
;
if
(
url2
.
searchParams
.
get
(
key1
)
=
=
value1
)
{
+
+
score
;
}
}
}
if
(
url1
.
hash
=
=
url2
.
hash
)
{
+
+
score
;
}
}
}
return
score
;
}
;
let
item
;
let
currentBestMatch
=
0
;
for
(
let
[
trackingURL
candidateItem
]
of
this
.
_browserInfoByURL
)
{
if
(
currentBestMatch
=
=
=
Infinity
)
{
break
;
}
try
{
trackingURL
=
candidateItem
.
_trackingURL
|
|
(
candidateItem
.
_trackingURL
=
new
URL
(
trackingURL
)
)
;
}
catch
(
ex
)
{
continue
;
}
let
score
=
compareURLs
(
url
trackingURL
)
;
if
(
score
>
currentBestMatch
)
{
item
=
candidateItem
;
currentBestMatch
=
score
;
}
}
return
item
;
}
onOpenWindow
(
appWin
)
{
let
win
=
appWin
.
docShell
.
domWindow
;
win
.
addEventListener
(
"
load
"
(
)
=
>
{
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
this
.
_registerWindow
(
win
)
;
}
{
once
:
true
}
)
;
}
onCloseWindow
(
appWin
)
{
let
win
=
appWin
.
docShell
.
domWindow
;
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
this
.
_unregisterWindow
(
win
)
;
}
_registerWindow
(
win
)
{
this
.
_contentHandler
.
registerWindow
(
win
)
;
win
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabClose
"
this
)
;
}
_unregisterWindow
(
win
)
{
for
(
let
tab
of
win
.
gBrowser
.
tabs
)
{
this
.
stopTrackingBrowser
(
tab
)
;
}
this
.
_contentHandler
.
unregisterWindow
(
win
)
;
win
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabClose
"
this
)
;
}
_getProviderInfoForURL
(
url
useOnlyExtraAdServers
=
false
)
{
if
(
useOnlyExtraAdServers
)
{
return
Object
.
entries
(
this
.
_searchProviderInfo
)
.
find
(
(
[
_
info
]
)
=
>
{
if
(
info
.
extraAdServersRegexps
)
{
for
(
let
regexp
of
info
.
extraAdServersRegexps
)
{
if
(
regexp
.
test
(
url
)
)
{
return
true
;
}
}
}
return
false
;
}
)
;
}
return
Object
.
entries
(
this
.
_searchProviderInfo
)
.
find
(
(
[
_
info
]
)
=
>
info
.
regexp
.
test
(
url
)
)
;
}
_checkURLForSerpMatch
(
url
)
{
let
info
=
this
.
_getProviderInfoForURL
(
url
)
;
if
(
!
info
)
{
return
null
;
}
let
[
provider
searchProviderInfo
]
=
info
;
let
queries
=
new
URLSearchParams
(
url
.
split
(
"
#
"
)
[
0
]
.
split
(
"
?
"
)
[
1
]
)
;
if
(
!
queries
.
get
(
searchProviderInfo
.
queryParam
)
)
{
return
null
;
}
let
type
=
"
organic
"
;
let
code
;
if
(
searchProviderInfo
.
codeParam
)
{
code
=
queries
.
get
(
searchProviderInfo
.
codeParam
)
;
if
(
code
&
&
searchProviderInfo
.
codePrefixes
.
some
(
p
=
>
code
.
startsWith
(
p
)
)
)
{
if
(
searchProviderInfo
.
followonParams
&
&
searchProviderInfo
.
followonParams
.
some
(
p
=
>
queries
.
has
(
p
)
)
)
{
type
=
"
sap
-
follow
-
on
"
;
}
else
{
type
=
"
sap
"
;
}
}
else
if
(
searchProviderInfo
.
followonCookies
)
{
for
(
let
followonCookie
of
searchProviderInfo
.
followonCookies
)
{
if
(
followonCookie
.
extraCodeParam
)
{
let
eCode
=
queries
.
get
(
followonCookie
.
extraCodeParam
)
;
if
(
!
eCode
|
|
!
followonCookie
.
extraCodePrefixes
.
some
(
p
=
>
eCode
.
startsWith
(
p
)
)
)
{
continue
;
}
}
for
(
let
cookie
of
Services
.
cookies
.
getCookiesFromHost
(
followonCookie
.
host
{
}
)
)
{
if
(
cookie
.
name
!
=
followonCookie
.
name
)
{
continue
;
}
let
[
cookieParam
cookieValue
]
=
cookie
.
value
.
split
(
"
=
"
)
.
map
(
p
=
>
p
.
trim
(
)
)
;
if
(
cookieParam
=
=
followonCookie
.
codeParam
&
&
followonCookie
.
codePrefixes
.
some
(
p
=
>
cookieValue
.
startsWith
(
p
)
)
)
{
type
=
"
sap
-
follow
-
on
"
;
code
=
cookieValue
;
break
;
}
}
}
}
}
return
{
provider
type
code
}
;
}
_reportSerpPage
(
info
url
)
{
let
payload
=
{
info
.
provider
}
.
in
-
content
:
{
info
.
type
}
:
{
info
.
code
|
|
"
none
"
}
;
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
SEARCH_COUNTS_HISTOGRAM_KEY
)
;
histogram
.
add
(
payload
)
;
LOG
(
{
payload
}
for
{
url
}
)
;
}
get
_searchProviderInfo
(
)
{
if
(
!
this
.
__searchProviderInfo
)
{
this
.
__searchProviderInfo
=
SEARCH_PROVIDER_INFO
;
}
return
this
.
__searchProviderInfo
;
}
}
class
ContentHandler
{
constructor
(
options
)
{
this
.
_browserInfoByURL
=
options
.
browserInfoByURL
;
this
.
_findBrowserItemForURL
=
options
.
findBrowserItemForURL
;
this
.
_getProviderInfoForURL
=
options
.
getProviderInfoForURL
;
}
init
(
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
SearchTelemetry
:
ProviderInfo
"
SEARCH_PROVIDER_INFO
)
;
Cc
[
"
mozilla
.
org
/
network
/
http
-
activity
-
distributor
;
1
"
]
.
getService
(
Ci
.
nsIHttpActivityDistributor
)
.
addObserver
(
this
)
;
}
uninit
(
)
{
Cc
[
"
mozilla
.
org
/
network
/
http
-
activity
-
distributor
;
1
"
]
.
getService
(
Ci
.
nsIHttpActivityDistributor
)
.
removeObserver
(
this
)
;
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
!
=
"
SearchTelemetry
:
PageInfo
"
)
{
LOG
(
"
Received
unexpected
message
:
"
+
msg
.
name
)
;
return
;
}
this
.
_reportPageWithAds
(
msg
.
data
)
;
}
overrideSearchTelemetryForTests
(
providerInfo
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
SearchTelemetry
:
ProviderInfo
"
providerInfo
)
;
}
observeActivity
(
nativeChannel
activityType
activitySubtype
)
{
if
(
!
this
.
_browserInfoByURL
.
size
|
|
activityType
!
=
Ci
.
nsIHttpActivityObserver
.
ACTIVITY_TYPE_HTTP_TRANSACTION
|
|
activitySubtype
!
=
Ci
.
nsIHttpActivityObserver
.
ACTIVITY_SUBTYPE_TRANSACTION_CLOSE
)
{
return
;
}
if
(
!
(
nativeChannel
instanceof
Ci
.
nsIChannel
)
)
{
return
;
}
let
channel
=
ChannelWrapper
.
get
(
nativeChannel
)
;
if
(
channel
.
_adClickRecorded
)
{
LOG
(
"
Ad
click
already
recorded
"
)
;
return
;
}
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
channel
.
statusCode
=
=
204
)
{
LOG
(
"
Ignoring
activity
from
ambiguous
responses
"
)
;
return
;
}
let
originURL
=
channel
.
originURI
&
&
channel
.
originURI
.
spec
;
let
info
=
this
.
_findBrowserItemForURL
(
originURL
)
;
if
(
!
originURL
|
|
!
info
)
{
return
;
}
let
URL
=
channel
.
finalURL
;
info
=
this
.
_getProviderInfoForURL
(
URL
true
)
;
if
(
!
info
)
{
return
;
}
try
{
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_AD_CLICKS_SCALAR
info
[
0
]
1
)
;
channel
.
_adClickRecorded
=
true
;
LOG
(
Counting
ad
click
in
page
for
{
info
[
0
]
}
{
originURL
}
{
URL
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
)
;
}
registerWindow
(
win
)
{
win
.
messageManager
.
addMessageListener
(
"
SearchTelemetry
:
PageInfo
"
this
)
;
}
unregisterWindow
(
win
)
{
win
.
messageManager
.
removeMessageListener
(
"
SearchTelemetry
:
PageInfo
"
this
)
;
}
_reportPageWithAds
(
info
)
{
let
item
=
this
.
_findBrowserItemForURL
(
info
.
url
)
;
if
(
!
item
)
{
LOG
(
Expected
to
report
URI
for
{
info
.
url
}
with
ads
but
couldn
'
t
find
the
information
)
;
return
;
}
Services
.
telemetry
.
keyedScalarAdd
(
SEARCH_WITH_ADS_SCALAR
item
.
info
.
provider
1
)
;
LOG
(
Counting
ads
in
page
for
{
item
.
info
.
provider
}
{
info
.
url
}
)
;
}
}
function
LOG
(
msg
)
{
if
(
loggingEnabled
)
{
dump
(
*
*
*
SearchTelemetry
:
{
msg
}
\
n
"
)
;
Services
.
console
.
logStringMessage
(
msg
)
;
}
}
var
SearchTelemetry
=
new
TelemetryHandler
(
)
;
