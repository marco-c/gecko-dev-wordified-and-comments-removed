ChromeUtils
.
defineESModuleGetters
(
this
{
ADLINK_CHECK_TIMEOUT_MS
:
"
resource
:
/
/
/
actors
/
SearchSERPTelemetryChild
.
sys
.
mjs
"
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
sys
.
mjs
"
FormHistoryTestUtils
:
"
resource
:
/
/
testing
-
common
/
FormHistoryTestUtils
.
sys
.
mjs
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
sys
.
mjs
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
CustomizableUITestUtils
:
"
resource
:
/
/
testing
-
common
/
CustomizableUITestUtils
.
jsm
"
}
)
;
let
gCUITestUtils
=
new
CustomizableUITestUtils
(
window
)
;
AddonTestUtils
.
initMochitest
(
this
)
;
SearchTestUtils
.
init
(
this
)
;
const
UUID_REGEX
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
function
isSubObjectOf
(
expectedObj
actualObj
name
)
{
for
(
let
prop
in
expectedObj
)
{
if
(
typeof
expectedObj
[
prop
]
=
=
"
function
"
)
{
continue
;
}
if
(
expectedObj
[
prop
]
instanceof
Object
)
{
is
(
actualObj
[
prop
]
.
length
expectedObj
[
prop
]
.
length
name
+
"
[
"
+
prop
+
"
]
"
)
;
isSubObjectOf
(
expectedObj
[
prop
]
actualObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
else
{
is
(
actualObj
[
prop
]
expectedObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
}
}
function
getLocale
(
)
{
return
Services
.
locale
.
requestedLocale
|
|
undefined
;
}
function
promiseEvent
(
aTarget
aEventName
aPreventDefault
)
{
function
cancelEvent
(
event
)
{
if
(
aPreventDefault
)
{
event
.
preventDefault
(
)
;
}
return
true
;
}
return
BrowserTestUtils
.
waitForEvent
(
aTarget
aEventName
false
cancelEvent
)
;
}
function
getOneOffs
(
)
{
let
oneOffs
=
[
]
;
let
searchPopup
=
document
.
getElementById
(
"
PopupSearchAutoComplete
"
)
;
let
oneOffsContainer
=
searchPopup
.
searchOneOffsContainer
;
let
oneOff
=
oneOffsContainer
.
querySelector
(
"
.
search
-
panel
-
one
-
offs
"
)
;
for
(
oneOff
=
oneOff
.
firstChild
;
oneOff
;
oneOff
=
oneOff
.
nextSibling
)
{
if
(
oneOff
.
nodeType
=
=
Node
.
ELEMENT_NODE
)
{
oneOffs
.
push
(
oneOff
)
;
}
}
return
oneOffs
;
}
async
function
typeInSearchField
(
browser
text
fieldName
)
{
await
SpecialPowers
.
spawn
(
browser
[
[
fieldName
text
]
]
async
function
(
[
contentFieldName
contentText
]
)
{
let
searchInput
=
content
.
document
.
getElementById
(
contentFieldName
)
;
searchInput
.
focus
(
)
;
searchInput
.
value
=
contentText
;
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
searchCounts
"
(
)
=
>
{
return
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
SEARCH_AD_CLICK_SCALARS
"
(
)
=
>
{
const
sources
=
[
.
.
.
BrowserSearchTelemetry
.
KNOWN_SEARCH_SOURCES
.
values
(
)
"
unknown
"
]
;
return
[
.
.
.
sources
.
map
(
v
=
>
browser
.
search
.
withads
.
{
v
}
)
.
.
.
sources
.
map
(
v
=
>
browser
.
search
.
adclicks
.
{
v
}
)
]
;
}
)
;
function
promiseWaitForAdLinkCheck
(
)
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
ADLINK_CHECK_TIMEOUT_MS
)
)
;
}
async
function
assertSearchSourcesTelemetry
(
expectedHistograms
expectedScalars
)
{
let
histSnapshot
=
{
}
;
let
scalars
=
{
}
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
histSnapshot
=
searchCounts
.
snapshot
(
)
;
return
(
Object
.
getOwnPropertyNames
(
histSnapshot
)
.
length
=
=
Object
.
getOwnPropertyNames
(
expectedHistograms
)
.
length
)
;
}
"
should
have
the
correct
number
of
histograms
"
)
;
if
(
Object
.
entries
(
expectedScalars
)
.
length
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
scalars
=
Services
.
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
return
Object
.
getOwnPropertyNames
(
expectedScalars
)
.
every
(
scalar
=
>
scalar
in
scalars
)
;
}
"
should
have
the
expected
keyed
scalars
"
)
;
}
Assert
.
equal
(
Object
.
getOwnPropertyNames
(
histSnapshot
)
.
length
Object
.
getOwnPropertyNames
(
expectedHistograms
)
.
length
"
Should
only
have
one
key
"
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
expectedHistograms
)
)
{
Assert
.
ok
(
key
in
histSnapshot
Histogram
should
have
the
expected
key
:
{
key
}
)
;
Assert
.
equal
(
histSnapshot
[
key
]
.
sum
value
Should
have
counted
the
correct
number
of
visits
for
{
key
}
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
expectedScalars
)
)
{
Assert
.
ok
(
name
in
scalars
Scalar
{
name
}
should
have
been
added
.
)
;
Assert
.
deepEqual
(
scalars
[
name
]
value
Should
have
counted
the
correct
number
of
visits
for
{
name
}
)
;
}
for
(
let
name
of
SEARCH_AD_CLICK_SCALARS
)
{
Assert
.
equal
(
name
in
scalars
name
in
expectedScalars
Should
have
matched
{
name
}
in
scalars
and
expectedScalars
)
;
}
}
async
function
searchInSearchbar
(
inputText
win
=
window
)
{
await
new
Promise
(
r
=
>
waitForFocus
(
r
win
)
)
;
let
sb
=
win
.
BrowserSearch
.
searchBar
;
sb
.
focus
(
)
;
sb
.
value
=
inputText
;
sb
.
textbox
.
controller
.
startSearch
(
inputText
)
;
await
BrowserTestUtils
.
waitForEvent
(
sb
.
textbox
.
popup
"
popupshown
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
sb
.
textbox
.
controller
.
searchStatus
>
=
Ci
.
nsIAutoCompleteController
.
STATUS_COMPLETE_NO_MATCH
"
The
search
in
the
searchbar
must
complete
.
"
)
;
return
sb
.
textbox
.
popup
;
}
function
clearSearchbarHistory
(
win
=
window
)
{
info
(
"
cleanup
the
search
history
"
)
;
return
FormHistory
.
update
(
{
op
:
"
remove
"
fieldname
:
"
searchbar
-
history
"
}
)
;
}
function
resetTelemetry
(
)
{
searchCounts
.
clear
(
)
;
Services
.
telemetry
.
clearScalars
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
}
function
assertImpressionEvents
(
expectedEvents
)
{
const
impressionIdsSet
=
new
Set
(
)
;
let
recordedImpressions
=
Glean
.
serp
.
impression
.
testGetValue
(
)
?
?
[
]
;
Assert
.
equal
(
recordedImpressions
.
length
expectedEvents
.
length
"
Should
have
the
correct
number
of
impressions
.
"
)
;
for
(
let
[
idx
expectedEvent
]
of
expectedEvents
.
entries
(
)
)
{
let
impressionId
=
recordedImpressions
[
idx
]
.
extra
.
impression_id
;
Assert
.
ok
(
UUID_REGEX
.
test
(
impressionId
)
"
Should
have
an
impression_id
with
a
valid
UUID
.
"
)
;
Assert
.
ok
(
!
impressionIdsSet
.
has
(
impressionId
)
"
Should
have
a
unique
impression_id
.
"
)
;
impressionIdsSet
.
add
(
impressionId
)
;
expectedEvent
.
impression
.
impression_id
=
impressionId
;
Assert
.
deepEqual
(
recordedImpressions
[
idx
]
.
extra
expectedEvent
.
impression
"
Should
have
matched
impression
values
.
"
)
;
if
(
expectedEvent
.
engagements
)
{
for
(
let
expectedEngagment
of
expectedEvent
.
engagements
)
{
expectedEngagment
.
impression_id
=
impressionId
;
}
}
}
let
recordedEngagements
=
Glean
.
serp
.
engagement
.
testGetValue
(
)
?
?
[
]
;
let
idToEngagements
=
new
Map
(
)
;
let
totalExpectedEngagements
=
0
;
for
(
let
recordedEngagement
of
recordedEngagements
)
{
let
impressionId
=
recordedEngagement
.
extra
.
impression_id
;
Assert
.
ok
(
impressionId
"
Should
have
an
engagement
event
with
an
impression_id
"
)
;
let
arr
=
idToEngagements
.
get
(
impressionId
)
?
?
[
]
;
arr
.
push
(
recordedEngagement
.
extra
)
;
idToEngagements
.
set
(
impressionId
arr
)
;
}
for
(
let
expectedEvent
of
expectedEvents
)
{
let
impressionId
=
expectedEvent
.
impression
.
impression_id
;
let
expectedEngagements
=
expectedEvent
.
engagements
;
if
(
expectedEngagements
)
{
let
recorded
=
idToEngagements
.
get
(
impressionId
)
;
Assert
.
deepEqual
(
recorded
expectedEngagements
"
Should
have
matched
engagement
values
.
"
)
;
totalExpectedEngagements
+
=
expectedEngagements
.
length
;
}
}
Assert
.
equal
(
recordedEngagements
.
length
totalExpectedEngagements
"
Should
have
equal
number
of
engagements
.
"
)
;
}
function
assertAdImpressionEvents
(
expectedAdImpressions
)
{
let
adImpressions
=
Glean
.
serp
.
adImpression
.
testGetValue
(
)
?
?
[
]
;
let
impressions
=
Glean
.
serp
.
impression
.
testGetValue
(
)
?
?
[
]
;
Assert
.
equal
(
impressions
.
length
1
"
Should
have
a
SERP
impression
event
.
"
)
;
Assert
.
equal
(
adImpressions
.
length
expectedAdImpressions
.
length
"
Should
have
equal
number
of
ad
impression
events
.
"
)
;
expectedAdImpressions
=
expectedAdImpressions
.
map
(
expectedAdImpression
=
>
{
expectedAdImpression
.
impression_id
=
impressions
[
0
]
.
extra
.
impression_id
;
return
expectedAdImpression
;
}
)
;
for
(
let
[
index
expectedAdImpression
]
of
expectedAdImpressions
.
entries
(
)
)
{
Assert
.
deepEqual
(
adImpressions
[
index
]
?
.
extra
expectedAdImpression
"
Should
have
equal
values
for
an
ad
impression
.
"
)
;
}
}
async
function
assertAbandonmentEvent
(
expectedAbandonment
)
{
let
recordedAbandonment
=
Glean
.
serp
.
abandonment
.
testGetValue
(
)
?
?
[
]
;
Assert
.
equal
(
recordedAbandonment
[
0
]
.
extra
.
reason
expectedAbandonment
.
abandonment
.
reason
"
Should
have
the
correct
abandonment
reason
.
"
)
;
}
