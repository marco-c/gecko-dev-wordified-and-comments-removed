ChromeUtils
.
defineESModuleGetters
(
this
{
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
sys
.
mjs
"
FormHistoryTestUtils
:
"
resource
:
/
/
testing
-
common
/
FormHistoryTestUtils
.
sys
.
mjs
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
sys
.
mjs
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ADLINK_CHECK_TIMEOUT_MS
:
"
resource
:
/
/
/
actors
/
SearchSERPTelemetryChild
.
jsm
"
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
CustomizableUITestUtils
:
"
resource
:
/
/
testing
-
common
/
CustomizableUITestUtils
.
jsm
"
}
)
;
let
gCUITestUtils
=
new
CustomizableUITestUtils
(
window
)
;
AddonTestUtils
.
initMochitest
(
this
)
;
SearchTestUtils
.
init
(
this
)
;
function
isSubObjectOf
(
expectedObj
actualObj
name
)
{
for
(
let
prop
in
expectedObj
)
{
if
(
typeof
expectedObj
[
prop
]
=
=
"
function
"
)
{
continue
;
}
if
(
expectedObj
[
prop
]
instanceof
Object
)
{
is
(
actualObj
[
prop
]
.
length
expectedObj
[
prop
]
.
length
name
+
"
[
"
+
prop
+
"
]
"
)
;
isSubObjectOf
(
expectedObj
[
prop
]
actualObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
else
{
is
(
actualObj
[
prop
]
expectedObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
}
}
function
getLocale
(
)
{
return
Services
.
locale
.
requestedLocale
|
|
undefined
;
}
function
promiseEvent
(
aTarget
aEventName
aPreventDefault
)
{
function
cancelEvent
(
event
)
{
if
(
aPreventDefault
)
{
event
.
preventDefault
(
)
;
}
return
true
;
}
return
BrowserTestUtils
.
waitForEvent
(
aTarget
aEventName
false
cancelEvent
)
;
}
function
getOneOffs
(
)
{
let
oneOffs
=
[
]
;
let
searchPopup
=
document
.
getElementById
(
"
PopupSearchAutoComplete
"
)
;
let
oneOffsContainer
=
searchPopup
.
searchOneOffsContainer
;
let
oneOff
=
oneOffsContainer
.
querySelector
(
"
.
search
-
panel
-
one
-
offs
"
)
;
for
(
oneOff
=
oneOff
.
firstChild
;
oneOff
;
oneOff
=
oneOff
.
nextSibling
)
{
if
(
oneOff
.
nodeType
=
=
Node
.
ELEMENT_NODE
)
{
oneOffs
.
push
(
oneOff
)
;
}
}
return
oneOffs
;
}
async
function
typeInSearchField
(
browser
text
fieldName
)
{
await
SpecialPowers
.
spawn
(
browser
[
[
fieldName
text
]
]
async
function
(
[
contentFieldName
contentText
]
)
{
let
searchInput
=
content
.
document
.
getElementById
(
contentFieldName
)
;
searchInput
.
focus
(
)
;
searchInput
.
value
=
contentText
;
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
searchCounts
"
(
)
=
>
{
return
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
SEARCH_AD_CLICK_SCALARS
"
(
)
=
>
{
const
sources
=
[
.
.
.
BrowserSearchTelemetry
.
KNOWN_SEARCH_SOURCES
.
values
(
)
"
unknown
"
]
;
return
[
.
.
.
sources
.
map
(
v
=
>
browser
.
search
.
withads
.
{
v
}
)
.
.
.
sources
.
map
(
v
=
>
browser
.
search
.
adclicks
.
{
v
}
)
]
;
}
)
;
function
promiseWaitForAdLinkCheck
(
)
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
ADLINK_CHECK_TIMEOUT_MS
)
)
;
}
async
function
assertSearchSourcesTelemetry
(
expectedHistograms
expectedScalars
)
{
let
histSnapshot
=
{
}
;
let
scalars
=
{
}
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
histSnapshot
=
searchCounts
.
snapshot
(
)
;
return
(
Object
.
getOwnPropertyNames
(
histSnapshot
)
.
length
=
=
Object
.
getOwnPropertyNames
(
expectedHistograms
)
.
length
)
;
}
"
should
have
the
correct
number
of
histograms
"
)
;
if
(
Object
.
entries
(
expectedScalars
)
.
length
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
scalars
=
Services
.
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
return
Object
.
getOwnPropertyNames
(
expectedScalars
)
.
every
(
scalar
=
>
scalar
in
scalars
)
;
}
"
should
have
the
expected
keyed
scalars
"
)
;
}
Assert
.
equal
(
Object
.
getOwnPropertyNames
(
histSnapshot
)
.
length
Object
.
getOwnPropertyNames
(
expectedHistograms
)
.
length
"
Should
only
have
one
key
"
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
expectedHistograms
)
)
{
Assert
.
ok
(
key
in
histSnapshot
Histogram
should
have
the
expected
key
:
{
key
}
)
;
Assert
.
equal
(
histSnapshot
[
key
]
.
sum
value
Should
have
counted
the
correct
number
of
visits
for
{
key
}
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
expectedScalars
)
)
{
Assert
.
ok
(
name
in
scalars
Scalar
{
name
}
should
have
been
added
.
)
;
Assert
.
deepEqual
(
scalars
[
name
]
value
Should
have
counted
the
correct
number
of
visits
for
{
name
}
)
;
}
for
(
let
name
of
SEARCH_AD_CLICK_SCALARS
)
{
Assert
.
equal
(
name
in
scalars
name
in
expectedScalars
Should
have
matched
{
name
}
in
scalars
and
expectedScalars
)
;
}
}
async
function
searchInSearchbar
(
inputText
win
=
window
)
{
await
new
Promise
(
r
=
>
waitForFocus
(
r
win
)
)
;
let
sb
=
win
.
BrowserSearch
.
searchBar
;
sb
.
focus
(
)
;
sb
.
value
=
inputText
;
sb
.
textbox
.
controller
.
startSearch
(
inputText
)
;
await
BrowserTestUtils
.
waitForEvent
(
sb
.
textbox
.
popup
"
popupshown
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
sb
.
textbox
.
controller
.
searchStatus
>
=
Ci
.
nsIAutoCompleteController
.
STATUS_COMPLETE_NO_MATCH
"
The
search
in
the
searchbar
must
complete
.
"
)
;
return
sb
.
textbox
.
popup
;
}
function
clearSearchbarHistory
(
win
=
window
)
{
info
(
"
cleanup
the
search
history
"
)
;
return
FormHistory
.
update
(
{
op
:
"
remove
"
fieldname
:
"
searchbar
-
history
"
}
)
;
}
function
assertUUIDs
(
recordedEvents
)
{
const
UUID_REGEX
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
let
impressionIdsSet
=
new
Set
(
)
;
for
(
let
recordedEvent
of
recordedEvents
)
{
let
impressionId
=
recordedEvent
.
extra
.
impression_id
;
Assert
.
equal
(
typeof
impressionId
"
string
"
"
should
be
an
impression_id
on
the
event
"
)
;
Assert
.
ok
(
UUID_REGEX
.
test
(
impressionId
)
"
impression_id
should
be
a
valid
UUID
"
)
;
Assert
.
ok
(
!
impressionIdsSet
.
has
(
impressionId
)
"
Should
not
have
found
a
duplicate
impression_id
"
)
;
impressionIdsSet
.
add
(
impressionId
)
;
}
}
function
assertImpressionEvents
(
expectedEvents
)
{
let
recordedEvents
=
Glean
.
serp
.
impression
.
testGetValue
(
)
;
Assert
.
equal
(
recordedEvents
.
length
expectedEvents
.
length
"
should
have
the
correct
number
of
Glean
events
"
)
;
for
(
let
[
idx
expectedEvent
]
of
expectedEvents
.
entries
(
)
)
{
let
recordedEvent
=
recordedEvents
[
idx
]
.
extra
;
for
(
let
key
of
Object
.
keys
(
expectedEvent
)
)
{
Assert
.
equal
(
recordedEvent
[
key
]
expectedEvent
[
key
]
the
value
for
recorded
key
"
{
key
}
"
should
match
the
value
for
expected
key
"
{
key
}
"
)
;
}
}
assertUUIDs
(
recordedEvents
)
;
}
