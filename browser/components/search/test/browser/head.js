ChromeUtils
.
defineESModuleGetters
(
this
{
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
sys
.
mjs
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
sys
.
mjs
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ADLINK_CHECK_TIMEOUT_MS
:
"
resource
:
/
/
/
actors
/
SearchSERPTelemetryChild
.
jsm
"
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
CustomizableUITestUtils
:
"
resource
:
/
/
testing
-
common
/
CustomizableUITestUtils
.
jsm
"
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
FormHistoryTestUtils
:
"
resource
:
/
/
testing
-
common
/
FormHistoryTestUtils
.
jsm
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
}
)
;
let
gCUITestUtils
=
new
CustomizableUITestUtils
(
window
)
;
AddonTestUtils
.
initMochitest
(
this
)
;
SearchTestUtils
.
init
(
this
)
;
function
isSubObjectOf
(
expectedObj
actualObj
name
)
{
for
(
let
prop
in
expectedObj
)
{
if
(
typeof
expectedObj
[
prop
]
=
=
"
function
"
)
{
continue
;
}
if
(
expectedObj
[
prop
]
instanceof
Object
)
{
is
(
actualObj
[
prop
]
.
length
expectedObj
[
prop
]
.
length
name
+
"
[
"
+
prop
+
"
]
"
)
;
isSubObjectOf
(
expectedObj
[
prop
]
actualObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
else
{
is
(
actualObj
[
prop
]
expectedObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
}
}
function
getLocale
(
)
{
return
Services
.
locale
.
requestedLocale
|
|
undefined
;
}
function
promiseEvent
(
aTarget
aEventName
aPreventDefault
)
{
function
cancelEvent
(
event
)
{
if
(
aPreventDefault
)
{
event
.
preventDefault
(
)
;
}
return
true
;
}
return
BrowserTestUtils
.
waitForEvent
(
aTarget
aEventName
false
cancelEvent
)
;
}
function
getOneOffs
(
)
{
let
oneOffs
=
[
]
;
let
searchPopup
=
document
.
getElementById
(
"
PopupSearchAutoComplete
"
)
;
let
oneOffsContainer
=
searchPopup
.
searchOneOffsContainer
;
let
oneOff
=
oneOffsContainer
.
querySelector
(
"
.
search
-
panel
-
one
-
offs
"
)
;
for
(
oneOff
=
oneOff
.
firstChild
;
oneOff
;
oneOff
=
oneOff
.
nextSibling
)
{
if
(
oneOff
.
nodeType
=
=
Node
.
ELEMENT_NODE
)
{
oneOffs
.
push
(
oneOff
)
;
}
}
return
oneOffs
;
}
async
function
typeInSearchField
(
browser
text
fieldName
)
{
await
SpecialPowers
.
spawn
(
browser
[
[
fieldName
text
]
]
async
function
(
[
contentFieldName
contentText
]
)
{
let
searchInput
=
content
.
document
.
getElementById
(
contentFieldName
)
;
searchInput
.
focus
(
)
;
searchInput
.
value
=
contentText
;
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
searchCounts
"
(
)
=
>
{
return
Services
.
telemetry
.
getKeyedHistogramById
(
"
SEARCH_COUNTS
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
SEARCH_AD_CLICK_SCALARS
"
(
)
=
>
{
const
sources
=
[
.
.
.
BrowserSearchTelemetry
.
KNOWN_SEARCH_SOURCES
.
values
(
)
"
unknown
"
]
;
return
[
"
browser
.
search
.
with_ads
"
"
browser
.
search
.
ad_clicks
"
.
.
.
sources
.
map
(
v
=
>
browser
.
search
.
withads
.
{
v
}
)
.
.
.
sources
.
map
(
v
=
>
browser
.
search
.
adclicks
.
{
v
}
)
]
;
}
)
;
function
promiseWaitForAdLinkCheck
(
)
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
ADLINK_CHECK_TIMEOUT_MS
)
)
;
}
async
function
assertSearchSourcesTelemetry
(
expectedHistograms
expectedScalars
)
{
let
histSnapshot
=
{
}
;
let
scalars
=
{
}
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
histSnapshot
=
searchCounts
.
snapshot
(
)
;
return
(
Object
.
getOwnPropertyNames
(
histSnapshot
)
.
length
=
=
Object
.
getOwnPropertyNames
(
expectedHistograms
)
.
length
)
;
}
"
should
have
the
correct
number
of
histograms
"
)
;
if
(
Object
.
entries
(
expectedScalars
)
.
length
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
scalars
=
Services
.
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
)
.
parent
|
|
{
}
;
return
Object
.
getOwnPropertyNames
(
expectedScalars
)
.
every
(
scalar
=
>
scalar
in
scalars
)
;
}
"
should
have
the
expected
keyed
scalars
"
)
;
}
Assert
.
equal
(
Object
.
getOwnPropertyNames
(
histSnapshot
)
.
length
Object
.
getOwnPropertyNames
(
expectedHistograms
)
.
length
"
Should
only
have
one
key
"
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
expectedHistograms
)
)
{
Assert
.
ok
(
key
in
histSnapshot
Histogram
should
have
the
expected
key
:
{
key
}
)
;
Assert
.
equal
(
histSnapshot
[
key
]
.
sum
value
Should
have
counted
the
correct
number
of
visits
for
{
key
}
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
expectedScalars
)
)
{
Assert
.
ok
(
name
in
scalars
Scalar
{
name
}
should
have
been
added
.
)
;
Assert
.
deepEqual
(
scalars
[
name
]
value
Should
have
counted
the
correct
number
of
visits
for
{
name
}
)
;
}
for
(
let
name
of
SEARCH_AD_CLICK_SCALARS
)
{
Assert
.
equal
(
name
in
scalars
name
in
expectedScalars
Should
have
matched
{
name
}
in
scalars
and
expectedScalars
)
;
}
}
async
function
searchInSearchbar
(
inputText
win
=
window
)
{
await
new
Promise
(
r
=
>
waitForFocus
(
r
win
)
)
;
let
sb
=
win
.
BrowserSearch
.
searchBar
;
sb
.
focus
(
)
;
sb
.
value
=
inputText
;
sb
.
textbox
.
controller
.
startSearch
(
inputText
)
;
await
BrowserTestUtils
.
waitForEvent
(
sb
.
textbox
.
popup
"
popupshown
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
sb
.
textbox
.
controller
.
searchStatus
>
=
Ci
.
nsIAutoCompleteController
.
STATUS_COMPLETE_NO_MATCH
"
The
search
in
the
searchbar
must
complete
.
"
)
;
return
sb
.
textbox
.
popup
;
}
function
clearSearchbarHistory
(
win
=
window
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
info
(
"
cleanup
the
search
history
"
)
;
FormHistory
.
update
(
{
op
:
"
remove
"
fieldname
:
"
searchbar
-
history
"
}
{
handleCompletion
:
resolve
handleError
:
reject
}
)
;
}
)
;
}
