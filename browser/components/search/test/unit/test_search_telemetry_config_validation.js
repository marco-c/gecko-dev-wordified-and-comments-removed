"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
sys
.
mjs
"
TELEMETRY_SETTINGS_KEY
:
"
moz
-
src
:
/
/
/
browser
/
components
/
search
/
SearchSERPTelemetry
.
sys
.
mjs
"
JsonSchema
:
"
resource
:
/
/
gre
/
modules
/
JsonSchema
.
sys
.
mjs
"
SearchEngineSelector
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
search
/
SearchEngineSelector
.
sys
.
mjs
"
}
)
;
function
isObject
(
value
)
{
return
value
!
=
null
&
&
typeof
value
=
=
"
object
"
&
&
!
Array
.
isArray
(
value
)
;
}
function
disallowAdditionalProperties
(
section
)
{
if
(
!
AppConstants
.
NIGHTLY_BUILD
)
{
info
(
"
Skipping
additional
properties
validation
.
"
)
;
return
;
}
if
(
section
.
type
=
=
"
object
"
&
&
(
!
"
additionalProperties
"
)
in
section
)
{
section
.
additionalProperties
=
false
;
}
for
(
let
value
of
Object
.
values
(
section
)
)
{
if
(
isObject
(
value
)
)
{
disallowAdditionalProperties
(
value
)
;
}
}
}
add_task
(
async
function
test_search_telemetry_validates_to_schema
(
)
{
let
schema
=
await
IOUtils
.
readJSON
(
PathUtils
.
join
(
do_get_cwd
(
)
.
path
"
search
-
telemetry
-
v2
-
schema
.
json
"
)
)
;
disallowAdditionalProperties
(
schema
)
;
let
data
=
await
RemoteSettings
(
TELEMETRY_SETTINGS_KEY
)
.
get
(
)
;
let
validator
=
new
JsonSchema
.
Validator
(
schema
)
;
for
(
let
entry
of
data
)
{
delete
entry
.
schema
;
delete
entry
.
id
;
delete
entry
.
last_modified
;
delete
entry
.
filter_expression
;
let
result
=
validator
.
validate
(
entry
)
;
let
message
=
Should
validate
{
entry
.
telemetryId
}
;
if
(
!
result
.
valid
)
{
message
+
=
:
\
n
{
JSON
.
stringify
(
result
.
errors
null
2
)
}
;
}
Assert
.
ok
(
result
.
valid
message
)
;
}
}
)
;
add_task
(
async
function
test_search_config_codes_in_search_telemetry
(
)
{
let
searchTelemetry
=
await
RemoteSettings
(
TELEMETRY_SETTINGS_KEY
)
.
get
(
)
;
let
selector
=
new
SearchEngineSelector
(
(
)
=
>
{
}
)
;
let
searchConfig
=
await
selector
.
getEngineConfiguration
(
)
;
const
telemetryIdToSearchEngineIdMap
=
new
Map
(
[
[
"
duckduckgo
"
"
ddg
"
]
]
)
;
for
(
let
telemetryEntry
of
searchTelemetry
)
{
info
(
Checking
:
{
telemetryEntry
.
telemetryId
}
)
;
let
engine
;
for
(
let
entry
of
searchConfig
)
{
if
(
entry
.
recordType
!
=
"
engine
"
)
{
continue
;
}
if
(
entry
.
identifier
=
=
telemetryEntry
.
telemetryId
|
|
entry
.
identifier
=
=
telemetryIdToSearchEngineIdMap
.
get
(
telemetryEntry
.
telemetryId
)
)
{
engine
=
entry
;
}
}
Assert
.
ok
(
!
!
engine
Should
have
associated
engine
data
for
telemetry
id
{
telemetryEntry
.
telemetryId
}
)
;
if
(
engine
.
base
.
partnerCode
)
{
Assert
.
ok
(
telemetryEntry
.
taggedCodes
.
includes
(
engine
.
base
.
partnerCode
)
Should
have
the
base
partner
code
{
engine
.
base
.
partnerCode
}
listed
in
the
search
telemetry
'
taggedCodes
'
)
;
}
else
{
Assert
.
ok
(
[
"
google
"
"
baidu
"
]
.
includes
(
telemetryEntry
.
telemetryId
)
"
Should
only
not
have
a
base
partner
code
for
Google
and
Baidu
"
)
;
}
if
(
engine
.
variants
)
{
for
(
let
variant
of
engine
.
variants
)
{
if
(
"
partnerCode
"
in
variant
)
{
Assert
.
ok
(
telemetryEntry
.
taggedCodes
.
includes
(
variant
.
partnerCode
)
Should
have
the
partner
code
{
variant
.
partnerCode
}
listed
in
the
search
telemetry
'
taggedCodes
'
)
;
}
}
}
}
}
)
;
