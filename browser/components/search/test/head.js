Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
function
isSubObjectOf
(
expectedObj
actualObj
name
)
{
for
(
let
prop
in
expectedObj
)
{
if
(
typeof
expectedObj
[
prop
]
=
=
'
function
'
)
continue
;
if
(
expectedObj
[
prop
]
instanceof
Object
)
{
is
(
actualObj
[
prop
]
.
length
expectedObj
[
prop
]
.
length
name
+
"
[
"
+
prop
+
"
]
"
)
;
isSubObjectOf
(
expectedObj
[
prop
]
actualObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
else
{
is
(
actualObj
[
prop
]
expectedObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
}
}
function
getLocale
(
)
{
const
localePref
=
"
general
.
useragent
.
locale
"
;
return
getLocalizedPref
(
localePref
Services
.
prefs
.
getCharPref
(
localePref
)
)
;
}
function
getLocalizedPref
(
aPrefName
aDefault
)
{
try
{
return
Services
.
prefs
.
getComplexValue
(
aPrefName
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
catch
(
ex
)
{
return
aDefault
;
}
return
aDefault
;
}
function
promiseEvent
(
aTarget
aEventName
aPreventDefault
)
{
function
cancelEvent
(
event
)
{
if
(
aPreventDefault
)
{
event
.
preventDefault
(
)
;
}
return
true
;
}
return
BrowserTestUtils
.
waitForEvent
(
aTarget
aEventName
false
cancelEvent
)
;
}
function
promiseNewEngine
(
basename
options
=
{
}
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
setAsCurrent
=
options
.
setAsCurrent
=
=
undefined
?
true
:
options
.
setAsCurrent
;
info
(
"
Waiting
for
engine
to
be
added
:
"
+
basename
)
;
Services
.
search
.
init
(
{
onInitComplete
:
function
(
)
{
let
url
=
getRootDirectory
(
gTestPath
)
+
basename
;
let
current
=
Services
.
search
.
currentEngine
;
Services
.
search
.
addEngine
(
url
null
options
.
iconURL
|
|
"
"
false
{
onSuccess
:
function
(
engine
)
{
info
(
"
Search
engine
added
:
"
+
basename
)
;
if
(
setAsCurrent
)
{
Services
.
search
.
currentEngine
=
engine
;
}
registerCleanupFunction
(
(
)
=
>
{
if
(
setAsCurrent
)
{
Services
.
search
.
currentEngine
=
current
;
}
Services
.
search
.
removeEngine
(
engine
)
;
info
(
"
Search
engine
removed
:
"
+
basename
)
;
}
)
;
resolve
(
engine
)
;
}
onError
:
function
(
errCode
)
{
ok
(
false
"
addEngine
failed
with
error
code
"
+
errCode
)
;
reject
(
)
;
}
}
)
;
}
}
)
;
}
)
;
}
function
promiseTabLoadEvent
(
tab
url
)
{
let
deferred
=
Promise
.
defer
(
)
;
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
let
timeout
=
setTimeout
(
(
)
=
>
{
deferred
.
reject
(
new
Error
(
"
Timed
out
while
waiting
for
a
'
load
'
event
"
)
)
;
}
30000
)
;
loaded
.
then
(
(
)
=
>
{
clearTimeout
(
timeout
)
;
deferred
.
resolve
(
)
}
)
;
if
(
url
)
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
)
;
return
Promise
.
all
(
[
deferred
.
promise
loaded
]
)
;
}
function
getOneOffs
(
)
{
let
oneOffs
=
[
]
;
let
searchPopup
=
document
.
getElementById
(
"
PopupSearchAutoComplete
"
)
;
let
oneOffsContainer
=
document
.
getAnonymousElementByAttribute
(
searchPopup
"
anonid
"
"
search
-
one
-
off
-
buttons
"
)
;
let
oneOff
=
document
.
getAnonymousElementByAttribute
(
oneOffsContainer
"
anonid
"
"
search
-
panel
-
one
-
offs
"
)
;
for
(
oneOff
=
oneOff
.
firstChild
;
oneOff
;
oneOff
=
oneOff
.
nextSibling
)
{
if
(
oneOff
.
nodeType
=
=
Node
.
ELEMENT_NODE
)
{
if
(
oneOff
.
classList
.
contains
(
"
dummy
"
)
|
|
oneOff
.
classList
.
contains
(
"
search
-
setting
-
button
-
compact
"
)
)
break
;
oneOffs
.
push
(
oneOff
)
;
}
}
return
oneOffs
;
}
