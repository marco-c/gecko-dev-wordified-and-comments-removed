function
isSubObjectOf
(
expectedObj
actualObj
name
)
{
for
(
let
prop
in
expectedObj
)
{
if
(
typeof
expectedObj
[
prop
]
=
=
"
function
"
)
continue
;
if
(
expectedObj
[
prop
]
instanceof
Object
)
{
is
(
actualObj
[
prop
]
.
length
expectedObj
[
prop
]
.
length
name
+
"
[
"
+
prop
+
"
]
"
)
;
isSubObjectOf
(
expectedObj
[
prop
]
actualObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
else
{
is
(
actualObj
[
prop
]
expectedObj
[
prop
]
name
+
"
[
"
+
prop
+
"
]
"
)
;
}
}
}
function
getLocale
(
)
{
return
Services
.
locale
.
getRequestedLocale
(
)
|
|
undefined
;
}
function
promiseEvent
(
aTarget
aEventName
aPreventDefault
)
{
function
cancelEvent
(
event
)
{
if
(
aPreventDefault
)
{
event
.
preventDefault
(
)
;
}
return
true
;
}
return
BrowserTestUtils
.
waitForEvent
(
aTarget
aEventName
false
cancelEvent
)
;
}
function
promiseNewEngine
(
basename
options
=
{
}
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
setAsCurrent
=
options
.
setAsCurrent
=
=
undefined
?
true
:
options
.
setAsCurrent
;
info
(
"
Waiting
for
engine
to
be
added
:
"
+
basename
)
;
Services
.
search
.
init
(
{
onInitComplete
(
)
{
let
url
=
getRootDirectory
(
options
.
testPath
|
|
gTestPath
)
+
basename
;
let
current
=
Services
.
search
.
currentEngine
;
Services
.
search
.
addEngine
(
url
null
options
.
iconURL
|
|
"
"
false
{
onSuccess
(
engine
)
{
info
(
"
Search
engine
added
:
"
+
basename
)
;
if
(
setAsCurrent
)
{
Services
.
search
.
currentEngine
=
engine
;
}
registerCleanupFunction
(
(
)
=
>
{
if
(
setAsCurrent
)
{
Services
.
search
.
currentEngine
=
current
;
}
Services
.
search
.
removeEngine
(
engine
)
;
info
(
"
Search
engine
removed
:
"
+
basename
)
;
}
)
;
resolve
(
engine
)
;
}
onError
(
errCode
)
{
ok
(
false
"
addEngine
failed
with
error
code
"
+
errCode
)
;
reject
(
)
;
}
}
)
;
}
}
)
;
}
)
;
}
let
promiseStateChangeFrameScript
=
"
data
:
"
+
encodeURIComponent
(
(
{
function
processScript
(
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
let
listener
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
"
nsISupportsWeakReference
"
"
nsIWebProgressListener
"
]
)
onStateChange
:
function
onStateChange
(
webProgress
req
flags
status
)
{
if
(
!
webProgress
.
isTopLevel
|
|
!
(
flags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
)
{
return
;
}
req
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
spec
=
req
.
originalURI
.
spec
;
if
(
spec
=
=
"
about
:
blank
"
)
return
;
docShell
.
removeProgressListener
(
listener
)
;
req
.
cancel
(
Cr
.
NS_ERROR_FAILURE
)
;
sendAsyncMessage
(
"
PromiseStateChange
:
:
StateChanged
"
spec
)
;
}
}
;
docShell
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
docShell
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
}
}
)
(
)
)
;
function
promiseStateChangeURI
(
)
{
const
MSG
=
"
PromiseStateChange
:
:
StateChanged
"
;
return
new
Promise
(
resolve
=
>
{
let
mm
=
window
.
getGroupMessageManager
(
"
browsers
"
)
;
mm
.
loadFrameScript
(
promiseStateChangeFrameScript
true
)
;
let
listener
=
msg
=
>
{
mm
.
removeMessageListener
(
MSG
listener
)
;
mm
.
removeDelayedFrameScript
(
promiseStateChangeFrameScript
)
;
resolve
(
msg
.
data
)
;
}
;
mm
.
addMessageListener
(
MSG
listener
)
;
}
)
;
}
function
promiseTabLoadEvent
(
tab
url
)
{
info
(
"
Wait
tab
event
:
load
"
)
;
function
handle
(
loadedUrl
)
{
if
(
loadedUrl
=
=
=
"
about
:
blank
"
|
|
(
url
&
&
loadedUrl
!
=
=
url
)
)
{
info
(
Skipping
spurious
load
event
for
{
loadedUrl
}
)
;
return
false
;
}
info
(
"
Tab
event
received
:
load
"
)
;
return
true
;
}
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
handle
)
;
if
(
url
)
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
url
)
;
return
loaded
;
}
function
getOneOffs
(
)
{
let
oneOffs
=
[
]
;
let
searchPopup
=
document
.
getElementById
(
"
PopupSearchAutoComplete
"
)
;
let
oneOffsContainer
=
document
.
getAnonymousElementByAttribute
(
searchPopup
"
anonid
"
"
search
-
one
-
off
-
buttons
"
)
;
let
oneOff
=
document
.
getAnonymousElementByAttribute
(
oneOffsContainer
"
anonid
"
"
search
-
panel
-
one
-
offs
"
)
;
for
(
oneOff
=
oneOff
.
firstChild
;
oneOff
;
oneOff
=
oneOff
.
nextSibling
)
{
if
(
oneOff
.
nodeType
=
=
Node
.
ELEMENT_NODE
)
{
if
(
oneOff
.
classList
.
contains
(
"
dummy
"
)
|
|
oneOff
.
classList
.
contains
(
"
search
-
setting
-
button
-
compact
"
)
)
break
;
oneOffs
.
push
(
oneOff
)
;
}
}
return
oneOffs
;
}
