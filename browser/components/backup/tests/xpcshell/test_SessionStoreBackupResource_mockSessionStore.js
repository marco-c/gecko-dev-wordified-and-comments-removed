"
use
strict
"
;
const
{
SessionStoreBackupResource
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
SessionStoreBackupResource
.
sys
.
mjs
"
)
;
const
mockSessionStore
=
{
getCurrentState
:
_ignored
=
>
{
return
{
cookies
:
[
]
windows
:
[
{
tabs
:
[
{
someData
:
"
hi
I
am
data
I
will
get
serialized
"
moreData
:
-
3
.
7
storage
:
{
message
:
"
I
don
'
t
get
serialized
!
"
}
}
{
stillMoreData
:
-
3
.
71
storage
:
{
message
:
"
I
don
'
t
get
serialized
either
!
"
}
}
]
_closedTabs
:
[
{
state
:
{
closedTabData
:
"
hi
I
am
a
closed
tab
"
moreData
:
-
3
.
7
storage
:
{
message
:
"
I
don
'
t
get
serialized
!
"
}
}
etc
:
{
dataNotInState
:
true
}
}
{
state
:
{
storage
:
{
message
:
"
I
don
'
t
get
serialized
either
!
"
}
}
}
]
}
{
tabs
:
[
{
someData
:
"
hi
I
am
window
#
2
'
s
data
I
will
get
serialized
"
moreData
:
-
3
.
7
storage
:
{
message
:
"
I
don
'
t
get
serialized
!
"
}
}
]
_closedTabs
:
[
{
state
:
{
storage
:
{
message
:
"
I
don
'
t
get
serialized
either
!
"
}
}
notState
:
{
notStateData
:
"
not
state
data
"
}
}
]
}
{
tabs
:
[
{
someData
:
"
hi
I
am
the
private
window
'
s
data
"
storage
:
{
message
:
"
I
don
'
t
get
serialized
!
"
}
}
]
isPrivate
:
true
_closedTabs
:
[
]
}
{
tabs
:
[
{
someData
:
"
hi
I
am
the
private
window
#
2
'
s
data
"
storage
:
{
message
:
"
I
don
'
t
get
serialized
!
"
}
}
]
isPrivate
:
true
_closedTabs
:
[
]
}
]
savedGroups
:
[
{
tabs
:
[
{
state
:
{
savedGroupData
:
-
3
.
7
storage
:
{
message
:
"
I
don
'
t
get
serialized
!
"
}
}
}
{
state
:
{
someData
:
"
hi
I
am
window
#
2
'
s
data
"
moreData
:
-
3
.
71
}
}
]
notTabData
:
"
notTabData
"
}
]
}
;
}
}
;
let
filteredMockSessionData
;
let
sessionStoreBackupResource
;
add_setup
(
(
)
=
>
{
sessionStoreBackupResource
=
new
SessionStoreBackupResource
(
mockSessionStore
)
;
filteredMockSessionData
=
sessionStoreBackupResource
.
filteredSessionStoreState
;
}
)
;
add_task
(
async
function
test_backups_have_correct_window_state
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
sourcePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
SessionStoreBackupResource
-
src
"
)
;
let
stagingPath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
SessionStoreBackupResource
-
stage
"
)
;
Assert
.
equal
(
filteredMockSessionData
.
windows
.
length
2
"
will
serialize
only
2
windows
since
we
don
'
t
backup
private
window
sessions
"
)
;
Assert
.
equal
(
filteredMockSessionData
.
windows
[
0
]
.
tabs
.
length
2
"
will
serialize
2
tabs
for
1st
window
"
)
;
Assert
.
equal
(
filteredMockSessionData
.
windows
[
0
]
.
tabs
[
0
]
.
storage
undefined
"
does
not
contain
win
0
tab
storage
"
)
;
Assert
.
equal
(
filteredMockSessionData
.
windows
[
0
]
.
_closedTabs
[
0
]
.
storage
undefined
"
does
not
contain
win
0
closed
tab
storage
"
)
;
Assert
.
equal
(
filteredMockSessionData
.
savedGroups
.
length
1
"
will
serialize
1
savedGroup
"
)
;
Assert
.
equal
(
filteredMockSessionData
.
savedGroups
[
0
]
.
tabs
.
length
2
"
will
serialize
2
savedGroup
tabs
"
)
;
let
manifestEntry
=
await
sessionStoreBackupResource
.
backup
(
stagingPath
sourcePath
false
)
;
Assert
.
equal
(
manifestEntry
null
"
SessionStoreBackupResource
.
backup
should
return
null
as
its
ManifestEntry
"
)
;
await
assertFilesExist
(
stagingPath
[
{
path
:
"
sessionstore
.
jsonlz4
"
}
]
)
;
let
sessionStoreStateStaged
=
await
IOUtils
.
readJSON
(
PathUtils
.
join
(
stagingPath
"
sessionstore
.
jsonlz4
"
)
{
decompress
:
true
}
)
;
Assert
.
deepEqual
(
sessionStoreStateStaged
filteredMockSessionData
"
sessionstore
.
jsonlz4
in
the
staging
folder
matches
the
recorded
session
state
"
)
;
await
maybeRemovePath
(
stagingPath
)
;
await
maybeRemovePath
(
sourcePath
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_recover
(
)
{
let
recoveryPath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
SessionStoreBackupResource
-
recover
"
)
;
let
destProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
SessionStoreBackupResource
-
restored
-
profile
"
)
;
let
sessionStoreBackupPath
=
PathUtils
.
join
(
recoveryPath
"
sessionstore
.
jsonlz4
"
)
;
await
IOUtils
.
writeJSON
(
sessionStoreBackupPath
filteredMockSessionData
{
compress
:
true
}
)
;
let
postRecoveryEntry
=
await
sessionStoreBackupResource
.
recover
(
null
recoveryPath
destProfilePath
)
;
Assert
.
equal
(
postRecoveryEntry
null
"
SessionStoreBackupResource
.
recover
should
return
null
as
its
post
recovery
entry
"
)
;
await
assertFilesExist
(
destProfilePath
[
{
path
:
"
sessionstore
.
jsonlz4
"
}
]
)
;
let
sessionStateCopied
=
await
IOUtils
.
readJSON
(
PathUtils
.
join
(
destProfilePath
"
sessionstore
.
jsonlz4
"
)
{
decompress
:
true
}
)
;
Assert
.
deepEqual
(
sessionStateCopied
filteredMockSessionData
"
sessionstore
.
jsonlz4
in
the
destination
profile
folder
matches
the
backed
up
session
state
"
)
;
await
maybeRemovePath
(
recoveryPath
)
;
await
maybeRemovePath
(
destProfilePath
)
;
}
)
;
