"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
HOME_KEY
=
"
Home
"
;
let
gTestRoot
;
let
gFakeHomePath
;
let
gFakeHomeFile
;
add_setup
(
async
(
)
=
>
{
gTestRoot
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testResolveArchiveDestFolderPath
"
)
;
gFakeHomePath
=
PathUtils
.
join
(
gTestRoot
"
FakeHome
"
)
;
await
IOUtils
.
makeDirectory
(
gFakeHomePath
)
;
gFakeHomeFile
=
await
IOUtils
.
getFile
(
gFakeHomePath
)
;
let
dirsvc
=
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIProperties
)
;
let
originalFile
;
try
{
originalFile
=
dirsvc
.
get
(
HOME_KEY
Ci
.
nsIFile
)
;
dirsvc
.
undefine
(
HOME_KEY
)
;
}
catch
(
e
)
{
originalFile
=
undefined
;
}
dirsvc
.
set
(
HOME_KEY
gFakeHomeFile
)
;
registerCleanupFunction
(
(
)
=
>
{
dirsvc
.
undefine
(
HOME_KEY
)
;
if
(
originalFile
)
{
dirsvc
.
set
(
HOME_KEY
originalFile
)
;
}
}
)
;
}
)
;
add_task
(
async
function
test_create_folder
(
)
{
const
PARENT_FOLDER
=
PathUtils
.
join
(
gTestRoot
"
TestFolder
"
)
;
await
IOUtils
.
makeDirectory
(
PARENT_FOLDER
)
;
let
bs
=
new
BackupService
(
)
;
const
DESTINATION_PATH
=
PathUtils
.
join
(
PARENT_FOLDER
BackupService
.
BACKUP_DIR_NAME
)
;
let
path
=
await
bs
.
resolveArchiveDestFolderPath
(
DESTINATION_PATH
)
;
Assert
.
equal
(
path
DESTINATION_PATH
"
Got
back
the
expected
folder
path
.
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
path
)
"
The
destination
folder
was
created
.
"
)
;
Assert
.
equal
(
(
await
IOUtils
.
getChildren
(
path
)
)
.
length
0
"
Destination
folder
should
be
empty
.
"
)
;
await
IOUtils
.
remove
(
PARENT_FOLDER
{
recursive
:
true
}
)
;
}
)
;
add_task
(
async
function
test_create_parent_folder_hierarchy
(
)
{
const
MISSING_PARENT_FOLDER
=
PathUtils
.
join
(
gTestRoot
"
DoesNotExistYet
"
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
MISSING_PARENT_FOLDER
)
)
"
Folder
should
not
exist
yet
.
"
)
;
let
bs
=
new
BackupService
(
)
;
const
CONFIGURED_DESTINATION_PATH
=
PathUtils
.
join
(
MISSING_PARENT_FOLDER
BackupService
.
BACKUP_DIR_NAME
)
;
let
path
=
await
bs
.
resolveArchiveDestFolderPath
(
CONFIGURED_DESTINATION_PATH
)
;
Assert
.
equal
(
path
CONFIGURED_DESTINATION_PATH
"
Got
back
the
expected
folder
path
.
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
path
)
"
The
destination
folder
was
created
.
"
)
;
await
IOUtils
.
remove
(
MISSING_PARENT_FOLDER
{
recursive
:
true
}
)
;
}
)
;
add_task
(
async
function
test_find_folder
(
)
{
const
PARENT_FOLDER
=
PathUtils
.
join
(
gTestRoot
"
TestFolder
"
)
;
const
DESTINATION_PATH
=
PathUtils
.
join
(
PARENT_FOLDER
BackupService
.
BACKUP_DIR_NAME
)
;
await
IOUtils
.
makeDirectory
(
DESTINATION_PATH
{
createAncestors
:
true
}
)
;
let
bs
=
new
BackupService
(
)
;
let
path
=
await
bs
.
resolveArchiveDestFolderPath
(
DESTINATION_PATH
)
;
Assert
.
equal
(
path
DESTINATION_PATH
"
Got
back
the
expected
folder
path
.
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
path
)
"
The
destination
folder
exists
.
"
)
;
Assert
.
equal
(
(
await
IOUtils
.
getChildren
(
path
)
)
.
length
0
"
Destination
folder
should
be
empty
.
"
)
;
await
IOUtils
.
remove
(
PARENT_FOLDER
{
recursive
:
true
}
)
;
}
)
;
add_task
(
async
function
test_fallback_to_default
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
todo_check_true
(
false
"
Programmatically
setting
folder
permissions
does
not
work
on
"
+
"
Windows
so
this
test
is
skipped
.
"
)
;
return
;
}
const
UNWRITABLE_PARENT
=
PathUtils
.
join
(
gTestRoot
"
UnwritableParent
"
)
;
await
IOUtils
.
makeDirectory
(
UNWRITABLE_PARENT
)
;
await
IOUtils
.
setPermissions
(
UNWRITABLE_PARENT
0o444
)
;
const
CONFIGURED_FOLDER
=
PathUtils
.
join
(
UNWRITABLE_PARENT
"
ImpossibleChild
"
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
CONFIGURED_FOLDER
)
)
"
Configured
folder
should
not
exist
.
"
)
;
const
DEFAULT_FOLDER
=
PathUtils
.
join
(
gTestRoot
"
FakeDocuments
"
)
;
await
IOUtils
.
makeDirectory
(
DEFAULT_FOLDER
)
;
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
BackupService
"
DEFAULT_PARENT_DIR_PATH
"
)
.
get
(
(
)
=
>
DEFAULT_FOLDER
)
;
const
CONFIGURED_DESTINATION_PATH
=
PathUtils
.
join
(
CONFIGURED_FOLDER
BackupService
.
BACKUP_DIR_NAME
)
;
const
EXPECTED_DESTINATION_PATH
=
PathUtils
.
join
(
DEFAULT_FOLDER
BackupService
.
BACKUP_DIR_NAME
)
;
let
path
=
await
bs
.
resolveArchiveDestFolderPath
(
CONFIGURED_DESTINATION_PATH
)
;
Assert
.
equal
(
path
EXPECTED_DESTINATION_PATH
"
Got
back
the
expected
folder
path
.
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
path
)
"
The
destination
folder
was
created
.
"
)
;
await
IOUtils
.
remove
(
DEFAULT_FOLDER
{
recursive
:
true
}
)
;
await
IOUtils
.
remove
(
UNWRITABLE_PARENT
{
recursive
:
true
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_fallback_to_home
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
todo_check_true
(
false
"
Programmatically
setting
folder
permissions
does
not
work
on
"
+
"
Windows
so
this
test
is
skipped
.
"
)
;
return
;
}
const
UNWRITABLE_PARENT
=
PathUtils
.
join
(
gTestRoot
"
UnwritableParent
"
)
;
await
IOUtils
.
makeDirectory
(
UNWRITABLE_PARENT
)
;
await
IOUtils
.
setPermissions
(
UNWRITABLE_PARENT
0o444
)
;
const
CONFIGURED_FOLDER
=
PathUtils
.
join
(
UNWRITABLE_PARENT
"
ImpossibleChild
"
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
CONFIGURED_FOLDER
)
)
"
Configured
folder
should
not
exist
.
"
)
;
const
DEFAULT_FOLDER
=
PathUtils
.
join
(
gTestRoot
"
FakeDocuments
"
)
;
await
IOUtils
.
makeDirectory
(
DEFAULT_FOLDER
)
;
await
IOUtils
.
setPermissions
(
DEFAULT_FOLDER
0o444
)
;
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
BackupService
"
DEFAULT_PARENT_DIR_PATH
"
)
.
get
(
(
)
=
>
DEFAULT_FOLDER
)
;
const
CONFIGURED_DESTINATION_PATH
=
PathUtils
.
join
(
CONFIGURED_FOLDER
BackupService
.
BACKUP_DIR_NAME
)
;
const
EXPECTED_DESTINATION_PATH
=
PathUtils
.
join
(
gFakeHomePath
BackupService
.
BACKUP_DIR_NAME
)
;
let
path
=
await
bs
.
resolveArchiveDestFolderPath
(
CONFIGURED_DESTINATION_PATH
)
;
Assert
.
equal
(
path
EXPECTED_DESTINATION_PATH
"
Got
back
the
expected
folder
path
.
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
path
)
"
The
destination
folder
was
created
.
"
)
;
await
IOUtils
.
remove
(
EXPECTED_DESTINATION_PATH
{
recursive
:
true
}
)
;
await
IOUtils
.
remove
(
DEFAULT_FOLDER
{
recursive
:
true
}
)
;
await
IOUtils
.
remove
(
UNWRITABLE_PARENT
{
recursive
:
true
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_fallback_to_home_fail
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
todo_check_true
(
false
"
Programmatically
setting
folder
permissions
does
not
work
on
"
+
"
Windows
so
this
test
is
skipped
.
"
)
;
return
;
}
const
UNWRITABLE_PARENT
=
PathUtils
.
join
(
gTestRoot
"
UnwritableParent
"
)
;
await
IOUtils
.
makeDirectory
(
UNWRITABLE_PARENT
)
;
await
IOUtils
.
setPermissions
(
UNWRITABLE_PARENT
0o444
)
;
const
CONFIGURED_FOLDER
=
PathUtils
.
join
(
UNWRITABLE_PARENT
"
ImpossibleChild
"
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
CONFIGURED_FOLDER
)
)
"
Configured
folder
should
not
exist
.
"
)
;
const
DEFAULT_FOLDER
=
PathUtils
.
join
(
gTestRoot
"
FakeDocuments
"
)
;
await
IOUtils
.
makeDirectory
(
DEFAULT_FOLDER
)
;
await
IOUtils
.
setPermissions
(
DEFAULT_FOLDER
0o444
)
;
const
UNWRITABLE_HOME_FOLDER
=
PathUtils
.
join
(
gTestRoot
"
UnwritableHome
"
)
;
await
IOUtils
.
makeDirectory
(
UNWRITABLE_HOME_FOLDER
)
;
await
IOUtils
.
setPermissions
(
UNWRITABLE_HOME_FOLDER
0o444
)
;
let
unwritableHomeFolderFile
=
await
IOUtils
.
getFile
(
UNWRITABLE_HOME_FOLDER
)
;
let
dirsvc
=
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIProperties
)
;
dirsvc
.
undefine
(
HOME_KEY
)
;
dirsvc
.
set
(
HOME_KEY
unwritableHomeFolderFile
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
BackupService
"
DEFAULT_PARENT_DIR_PATH
"
)
.
get
(
(
)
=
>
DEFAULT_FOLDER
)
;
let
bs
=
new
BackupService
(
)
;
const
CONFIGURED_DESTINATION_PATH
=
PathUtils
.
join
(
CONFIGURED_FOLDER
BackupService
.
BACKUP_DIR_NAME
)
;
await
Assert
.
rejects
(
bs
.
resolveArchiveDestFolderPath
(
CONFIGURED_DESTINATION_PATH
)
/
Could
not
resolve
/
)
;
sandbox
.
restore
(
)
;
await
IOUtils
.
remove
(
UNWRITABLE_HOME_FOLDER
{
recursive
:
true
}
)
;
await
IOUtils
.
remove
(
DEFAULT_FOLDER
{
recursive
:
true
}
)
;
await
IOUtils
.
remove
(
UNWRITABLE_PARENT
{
recursive
:
true
}
)
;
dirsvc
.
undefine
(
HOME_KEY
)
;
dirsvc
.
set
(
HOME_KEY
gFakeHomeFile
)
;
}
)
;
