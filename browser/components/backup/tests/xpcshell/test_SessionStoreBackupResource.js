"
use
strict
"
;
const
{
SessionStoreBackupResource
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
SessionStoreBackupResource
.
sys
.
mjs
"
)
;
const
{
SessionStore
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
sys
.
mjs
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
const
TOTAL_COOKIES
=
10
;
add_setup
(
async
(
)
=
>
{
Services
.
cookies
.
sessionCookies
;
Services
.
prefs
.
setBoolPref
(
"
network
.
cookieJarSettings
.
unblocked_for_testing
"
true
)
;
let
uri
=
NetUtil
.
newURI
(
"
https
:
/
/
foo
.
com
/
"
)
;
let
channel
=
NetUtil
.
newChannel
(
{
uri
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
}
)
;
for
(
let
i
=
0
;
i
<
TOTAL_COOKIES
;
+
+
i
)
{
uri
=
NetUtil
.
newURI
(
"
https
:
/
/
"
+
i
+
"
.
com
/
"
)
;
Services
.
cookies
.
setCookieStringFromHttp
(
uri
"
oh
=
hai
"
channel
)
;
}
Assert
.
equal
(
Services
.
cookies
.
sessionCookies
.
length
TOTAL_COOKIES
)
;
let
state
=
SessionStore
.
getCurrentState
(
true
)
;
Assert
.
equal
(
state
.
cookies
.
length
TOTAL_COOKIES
"
The
cookies
are
part
of
the
session
"
)
;
}
)
;
add_task
(
async
function
test_measure
(
)
{
const
EXPECTED_KILOBYTES_FOR_BACKUPS_DIR
=
1000
;
Services
.
fog
.
testResetFOG
(
)
;
let
tempDir
=
PathUtils
.
tempDir
;
let
sessionStoreBackupsPath
=
PathUtils
.
join
(
tempDir
"
sessionstore
-
backups
"
"
restore
.
jsonlz4
"
)
;
await
createKilobyteSizedFile
(
sessionStoreBackupsPath
EXPECTED_KILOBYTES_FOR_BACKUPS_DIR
)
;
let
sessionStoreBackupResource
=
new
SessionStoreBackupResource
(
)
;
await
sessionStoreBackupResource
.
measure
(
tempDir
)
;
let
sessionStoreBackupsDirectoryMeasurement
=
Glean
.
browserBackup
.
sessionStoreBackupsDirectorySize
.
testGetValue
(
)
;
let
sessionStoreMeasurement
=
Glean
.
browserBackup
.
sessionStoreSize
.
testGetValue
(
)
;
let
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
false
false
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
"
browser
.
backup
.
session_store_backups_directory_size
"
sessionStoreBackupsDirectoryMeasurement
"
Glean
and
telemetry
measurements
for
session
store
backups
directory
should
be
equal
"
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
"
browser
.
backup
.
session_store_size
"
sessionStoreMeasurement
"
Glean
and
telemetry
measurements
for
session
store
should
be
equal
"
)
;
Assert
.
equal
(
sessionStoreBackupsDirectoryMeasurement
EXPECTED_KILOBYTES_FOR_BACKUPS_DIR
"
Should
have
collected
the
correct
glean
measurement
for
the
sessionstore
-
backups
directory
"
)
;
Assert
.
greater
(
sessionStoreMeasurement
0
"
Should
have
collected
a
measurement
for
the
session
store
"
)
;
await
IOUtils
.
remove
(
sessionStoreBackupsPath
)
;
}
)
;
add_task
(
async
function
test_backup_encrypted
(
)
{
await
testBackupHelper
(
true
)
;
}
)
;
add_task
(
async
function
test_backup_not_encrypted
(
)
{
await
testBackupHelper
(
false
)
;
}
)
;
async
function
testBackupHelper
(
isEncrypted
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
sessionStoreBackupResource
=
new
SessionStoreBackupResource
(
)
;
let
sourcePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
SessionStoreBackupResource
-
source
-
test
"
)
;
let
stagingPath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
SessionStoreBackupResource
-
staging
-
test
"
)
;
const
simpleCopyFiles
=
[
{
path
:
[
"
sessionstore
-
backups
"
"
test
-
sessionstore
-
backup
.
jsonlz4
"
]
}
{
path
:
[
"
sessionstore
-
backups
"
"
test
-
sessionstore
-
recovery
.
baklz4
"
]
}
]
;
await
createTestFiles
(
sourcePath
simpleCopyFiles
)
;
let
sessionStoreState
=
SessionStore
.
getCurrentState
(
true
)
;
let
manifestEntry
=
await
sessionStoreBackupResource
.
backup
(
stagingPath
sourcePath
isEncrypted
)
;
Assert
.
equal
(
manifestEntry
null
"
SessionStoreBackupResource
.
backup
should
return
null
as
its
ManifestEntry
"
)
;
await
assertFilesExist
(
stagingPath
[
.
.
.
simpleCopyFiles
{
path
:
"
sessionstore
.
jsonlz4
"
}
]
)
;
let
sessionStoreStateStaged
=
await
IOUtils
.
readJSON
(
PathUtils
.
join
(
stagingPath
"
sessionstore
.
jsonlz4
"
)
{
decompress
:
true
}
)
;
delete
sessionStoreStateStaged
.
session
.
lastUpdate
;
delete
sessionStoreState
.
session
.
lastUpdate
;
if
(
!
isEncrypted
)
{
sessionStoreState
.
cookies
=
[
]
;
}
Assert
.
deepEqual
(
sessionStoreStateStaged
sessionStoreState
"
sessionstore
.
jsonlz4
in
the
staging
folder
matches
the
recorded
session
state
"
)
;
await
maybeRemovePath
(
stagingPath
)
;
await
maybeRemovePath
(
sourcePath
)
;
sandbox
.
restore
(
)
;
}
add_task
(
async
function
test_recover
(
)
{
let
sessionStoreBackupResource
=
new
SessionStoreBackupResource
(
)
;
let
recoveryPath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
SessionStoreBackupResource
-
recovery
-
test
"
)
;
let
destProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
SessionStoreBackupResource
-
test
-
profile
"
)
;
const
simpleCopyFiles
=
[
{
path
:
[
"
sessionstore
-
backups
"
"
test
-
sessionstore
-
backup
.
jsonlz4
"
]
}
{
path
:
[
"
sessionstore
-
backups
"
"
test
-
sessionstore
-
recovery
.
baklz4
"
]
}
]
;
await
createTestFiles
(
recoveryPath
simpleCopyFiles
)
;
let
sessionStoreState
=
SessionStore
.
getCurrentState
(
true
)
;
let
sessionStoreBackupPath
=
PathUtils
.
join
(
recoveryPath
"
sessionstore
.
jsonlz4
"
)
;
await
IOUtils
.
writeJSON
(
sessionStoreBackupPath
sessionStoreState
{
compress
:
true
}
)
;
let
postRecoveryEntry
=
await
sessionStoreBackupResource
.
recover
(
null
recoveryPath
destProfilePath
)
;
Assert
.
equal
(
postRecoveryEntry
null
"
SessionStoreBackupResource
.
recover
should
return
null
as
its
post
recovery
entry
"
)
;
await
assertFilesExist
(
destProfilePath
[
.
.
.
simpleCopyFiles
{
path
:
"
sessionstore
.
jsonlz4
"
}
]
)
;
let
sessionStateCopied
=
await
IOUtils
.
readJSON
(
PathUtils
.
join
(
destProfilePath
"
sessionstore
.
jsonlz4
"
)
{
decompress
:
true
}
)
;
delete
sessionStateCopied
.
session
.
lastUpdate
;
delete
sessionStoreState
.
session
.
lastUpdate
;
Assert
.
deepEqual
(
sessionStateCopied
sessionStoreState
"
sessionstore
.
jsonlz4
in
the
destination
profile
folder
matches
the
backed
up
session
state
"
)
;
await
maybeRemovePath
(
recoveryPath
)
;
await
maybeRemovePath
(
destProfilePath
)
;
}
)
;
