"
use
strict
"
;
async
function
testRenderTemplate
(
isEncrypted
metadata
=
FAKE_METADATA
)
{
let
bs
=
new
BackupService
(
)
;
let
markup
=
await
bs
.
renderTemplate
(
BackupService
.
ARCHIVE_TEMPLATE
isEncrypted
metadata
)
;
let
backupDOM
=
new
DOMParser
(
)
.
parseFromString
(
markup
"
text
/
html
"
)
;
return
{
backupDOM
markup
}
;
}
add_setup
(
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
security
.
allow_parent_unrestricted_js_loads
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
security
.
allow_parent_unrestricted_js_loads
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_header
(
)
{
let
{
markup
}
=
await
testRenderTemplate
(
false
)
;
const
EXPECTED_HEADER
=
/
^
<
!
DOCTYPE
html
>
[
\
r
\
n
]
+
<
!
-
-
Version
:
(
\
d
+
)
-
-
>
[
\
r
\
n
]
+
/
;
Assert
.
ok
(
markup
.
match
(
EXPECTED_HEADER
)
"
Should
have
found
the
expected
header
.
"
)
;
}
)
;
add_task
(
async
function
test_encryption_state
(
)
{
let
{
backupDOM
}
=
await
testRenderTemplate
(
false
)
;
Assert
.
equal
(
backupDOM
.
querySelector
(
"
#
encryption
-
state
-
value
"
)
.
textContent
"
No
"
)
;
(
{
backupDOM
}
=
await
testRenderTemplate
(
true
)
)
;
Assert
.
equal
(
backupDOM
.
querySelector
(
"
#
encryption
-
state
-
value
"
)
.
textContent
"
Yes
"
)
;
}
)
;
add_task
(
async
function
test_metadata
(
)
{
let
{
backupDOM
}
=
await
testRenderTemplate
(
true
)
;
let
backupDate
=
new
Date
(
FAKE_METADATA
.
date
)
;
let
expectedDate
=
new
Intl
.
DateTimeFormat
(
"
en
-
US
"
{
dateStyle
:
"
short
"
}
)
.
format
(
backupDate
)
;
let
expectedTime
=
new
Intl
.
DateTimeFormat
(
"
en
-
US
"
{
timeStyle
:
"
short
"
}
)
.
format
(
backupDate
)
;
Assert
.
equal
(
backupDOM
.
querySelector
(
"
#
creation
-
date
-
value
"
)
.
textContent
{
expectedTime
}
{
expectedDate
}
)
;
Assert
.
equal
(
backupDOM
.
querySelector
(
"
#
creation
-
device
-
value
"
)
.
textContent
"
A
super
cool
machine
"
)
;
}
)
;
add_task
(
async
function
test_hostile_metadata
(
)
{
let
{
backupDOM
}
=
await
testRenderTemplate
(
true
{
date
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
appName
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
appVersion
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
buildID
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
profileName
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
machineName
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
osName
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
osVersion
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
legacyClientID
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
profileGroupID
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
accountID
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
accountEmail
:
"
<
script
>
alert
(
'
test
'
)
;
<
/
script
>
"
}
)
;
let
scriptTags
=
backupDOM
.
querySelectorAll
(
"
script
"
)
;
Assert
.
equal
(
scriptTags
.
length
1
"
There
should
only
be
1
script
tag
on
the
page
.
"
)
;
let
scriptContent
=
scriptTags
[
0
]
.
innerHTML
;
let
evalSandbox
=
Cu
.
Sandbox
(
Cu
.
getGlobalForObject
(
{
}
)
)
;
evalSandbox
.
navigator
=
{
userAgent
:
"
"
}
;
evalSandbox
.
document
=
{
getElementById
:
sinon
.
stub
(
)
.
callsFake
(
(
.
.
.
args
)
=
>
{
return
backupDOM
.
getElementById
(
.
.
.
args
)
;
}
)
body
:
{
toggleAttribute
:
sinon
.
stub
(
)
}
location
:
{
pathname
:
"
test_archive
.
html
"
}
}
;
evalSandbox
.
alert
=
sinon
.
stub
(
)
;
Cu
.
evalInSandbox
(
scriptContent
evalSandbox
)
;
Assert
.
ok
(
evalSandbox
.
alert
.
notCalled
"
alert
(
)
was
never
called
"
)
;
}
)
;
add_task
(
async
function
test_backup_file_path_from_javascript
(
)
{
let
{
backupDOM
}
=
await
testRenderTemplate
(
false
)
;
let
scriptTags
=
backupDOM
.
querySelectorAll
(
"
script
"
)
;
Assert
.
equal
(
scriptTags
.
length
1
"
There
should
only
be
1
script
tag
on
the
page
.
"
)
;
let
scriptContent
=
scriptTags
[
0
]
.
innerHTML
;
let
evalSandbox
=
Cu
.
Sandbox
(
Cu
.
getGlobalForObject
(
{
}
)
)
;
evalSandbox
.
navigator
=
{
userAgent
:
"
Mozilla
/
5
.
0
(
Macintosh
;
Intel
Mac
OS
X
10
.
15
;
rv
:
129
.
0
)
Gecko
/
20100101
Firefox
/
129
.
0
"
}
;
evalSandbox
.
document
=
{
getElementById
:
sinon
.
stub
(
)
.
callsFake
(
(
.
.
.
args
)
=
>
{
return
backupDOM
.
getElementById
(
.
.
.
args
)
;
}
)
body
:
{
toggleAttribute
:
sinon
.
stub
(
)
}
location
:
{
pathname
:
"
test_archive
.
html
"
}
}
;
Cu
.
evalInSandbox
(
scriptContent
evalSandbox
)
;
Assert
.
equal
(
backupDOM
.
querySelector
(
"
#
backup
-
file
-
path
-
value
"
)
.
textContent
"
test_archive
.
html
"
"
backup
file
path
should
have
been
sourced
from
document
.
location
"
)
;
}
)
;
add_task
(
async
function
test_moz_browser_handling
(
)
{
let
{
backupDOM
}
=
await
testRenderTemplate
(
false
)
;
let
scriptTags
=
backupDOM
.
querySelectorAll
(
"
script
"
)
;
Assert
.
equal
(
scriptTags
.
length
1
"
There
should
only
be
1
script
tag
on
the
page
.
"
)
;
let
scriptContent
=
scriptTags
[
0
]
.
innerHTML
;
let
evalSandbox
=
Cu
.
Sandbox
(
Cu
.
getGlobalForObject
(
{
}
)
)
;
evalSandbox
.
navigator
=
{
userAgent
:
"
Mozilla
/
5
.
0
(
Macintosh
;
Intel
Mac
OS
X
10
.
15
;
rv
:
129
.
0
)
Gecko
/
20100101
Firefox
/
129
.
0
"
}
;
evalSandbox
.
document
=
{
getElementById
:
sinon
.
stub
(
)
.
callsFake
(
(
.
.
.
args
)
=
>
{
return
backupDOM
.
getElementById
(
.
.
.
args
)
;
}
)
body
:
{
toggleAttribute
:
sinon
.
stub
(
)
}
location
:
{
pathname
:
"
test_archive
.
html
"
}
}
;
Cu
.
evalInSandbox
(
scriptContent
evalSandbox
)
;
Assert
.
ok
(
evalSandbox
.
document
.
body
.
toggleAttribute
.
calledOnce
"
document
.
body
.
toggleAttribute
called
"
)
;
Assert
.
ok
(
evalSandbox
.
document
.
body
.
toggleAttribute
.
calledWith
(
"
is
-
moz
-
browser
"
true
)
"
document
.
body
.
toggleAttribute
called
setting
is
-
moz
-
browser
to
true
"
)
;
}
)
;
add_task
(
async
function
test_non_moz_browser_handling
(
)
{
let
{
backupDOM
}
=
await
testRenderTemplate
(
true
)
;
let
scriptTags
=
backupDOM
.
querySelectorAll
(
"
script
"
)
;
Assert
.
equal
(
scriptTags
.
length
1
"
There
should
only
be
1
script
tag
on
the
page
.
"
)
;
let
scriptContent
=
scriptTags
[
0
]
.
innerHTML
;
let
evalSandbox
=
Cu
.
Sandbox
(
Cu
.
getGlobalForObject
(
{
}
)
)
;
evalSandbox
.
navigator
=
{
userAgent
:
"
Mozilla
/
5
.
0
(
Macintosh
;
Intel
Mac
OS
X
10_15_7
)
AppleWebKit
/
605
.
1
.
15
(
KHTML
like
Gecko
)
Version
/
17
.
4
.
1
Safari
/
605
.
1
.
15
"
}
;
evalSandbox
.
document
=
{
getElementById
:
sinon
.
stub
(
)
.
callsFake
(
(
.
.
.
args
)
=
>
{
return
backupDOM
.
getElementById
(
.
.
.
args
)
;
}
)
body
:
{
toggleAttribute
:
sinon
.
stub
(
)
}
location
:
{
pathname
:
"
test_archive
.
html
"
}
}
;
Cu
.
evalInSandbox
(
scriptContent
evalSandbox
)
;
Assert
.
ok
(
evalSandbox
.
document
.
body
.
toggleAttribute
.
calledOnce
"
document
.
body
.
toggleAttribute
called
"
)
;
Assert
.
ok
(
evalSandbox
.
document
.
body
.
toggleAttribute
.
calledWith
(
"
is
-
moz
-
browser
"
false
)
"
document
.
body
.
toggleAttribute
called
setting
is
-
moz
-
browser
to
false
"
)
;
}
)
;
add_task
(
async
function
test_no_license
(
)
{
let
{
markup
}
=
await
testRenderTemplate
(
true
)
;
Assert
.
ok
(
!
markup
.
includes
(
"
https
:
/
/
mozilla
.
org
/
MPL
"
)
"
The
license
headers
were
stripped
.
"
)
;
}
)
;
