"
use
strict
"
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
const
{
PlacesTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
const
{
DownloadHistory
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
DownloadHistory
.
sys
.
mjs
"
)
;
async
function
addTestHistory
(
uriString
timestamp
=
Date
.
now
(
)
)
{
let
uri
=
NetUtil
.
newURI
(
uriString
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
transition
:
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
visitDate
:
timestamp
*
1000
}
)
;
}
async
function
expectRegeneration
(
taskFn
msg
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
BackupService
"
REGENERATION_DEBOUNCE_RATE_MS
"
)
.
get
(
(
)
=
>
0
)
;
let
bs
=
new
BackupService
(
)
;
let
deleteDeferred
=
Promise
.
withResolvers
(
)
;
sandbox
.
stub
(
bs
"
deleteLastBackup
"
)
.
callsFake
(
(
)
=
>
{
Assert
.
ok
(
true
"
Saw
deleteLastBackup
call
"
)
;
deleteDeferred
.
resolve
(
)
;
return
Promise
.
resolve
(
)
;
}
)
;
let
createBackupDeferred
=
Promise
.
withResolvers
(
)
;
sandbox
.
stub
(
bs
"
createBackupOnIdleDispatch
"
)
.
callsFake
(
(
)
=
>
{
Assert
.
ok
(
true
"
Saw
createBackupOnIdleDispatch
call
"
)
;
createBackupDeferred
.
resolve
(
)
;
return
Promise
.
resolve
(
)
;
}
)
;
bs
.
initBackupScheduler
(
)
;
await
taskFn
(
)
;
let
regenerationPromises
=
[
deleteDeferred
.
promise
createBackupDeferred
.
promise
]
;
let
timeoutPromise
=
new
Promise
(
(
resolve
reject
)
=
>
setTimeout
(
(
)
=
>
{
reject
(
)
;
}
1000
)
)
;
try
{
await
Promise
.
race
(
[
Promise
.
all
(
regenerationPromises
)
timeoutPromise
]
)
;
Assert
.
ok
(
true
msg
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
Timed
out
waiting
for
regeneration
.
"
)
;
}
bs
.
uninitBackupScheduler
(
)
;
sandbox
.
restore
(
)
;
}
async
function
expectNoRegeneration
(
taskFn
msg
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
BackupService
"
REGENERATION_DEBOUNCE_RATE_MS
"
)
.
get
(
(
)
=
>
0
)
;
let
bs
=
new
BackupService
(
)
;
let
regenerationPromise
=
Promise
.
withResolvers
(
)
;
sandbox
.
stub
(
bs
"
deleteLastBackup
"
)
.
callsFake
(
(
)
=
>
{
Assert
.
ok
(
false
"
Unexpectedly
saw
deleteLastBackup
call
"
)
;
regenerationPromise
.
reject
(
)
;
return
Promise
.
resolve
(
)
;
}
)
;
sandbox
.
stub
(
bs
"
createBackupOnIdleDispatch
"
)
.
callsFake
(
(
)
=
>
{
Assert
.
ok
(
false
"
Unexpectedly
saw
createBackupOnIdleDispatch
call
"
)
;
regenerationPromise
.
reject
(
)
;
return
Promise
.
resolve
(
)
;
}
)
;
bs
.
initBackupScheduler
(
)
;
await
taskFn
(
)
;
let
timeoutPromise
=
new
Promise
(
resolve
=
>
setTimeout
(
(
)
=
>
{
Assert
.
ok
(
true
"
Saw
no
regeneration
within
1
second
.
"
)
;
resolve
(
)
;
}
1000
)
)
;
try
{
await
Promise
.
race
(
[
regenerationPromise
.
promise
timeoutPromise
]
)
;
Assert
.
ok
(
true
msg
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
Saw
an
unexpected
regeneration
.
"
)
;
}
bs
.
uninitBackupScheduler
(
)
;
sandbox
.
restore
(
)
;
}
add_task
(
async
function
test_page_removed_reason_deleted
(
)
{
const
PAGE_URI
=
"
https
:
/
/
test
.
com
"
;
await
addTestHistory
(
PAGE_URI
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
remove
(
PAGE_URI
)
;
}
"
Saw
regeneration
on
page
-
removed
via
user
deletion
.
"
)
;
}
)
;
add_task
(
async
function
test_page_removed_reason_expired
(
)
{
const
PAGE_URI
=
"
https
:
/
/
test
.
com
"
;
await
addTestHistory
(
PAGE_URI
0
)
;
await
expectNoRegeneration
(
async
(
)
=
>
{
let
promise
=
TestUtils
.
topicObserved
(
PlacesUtils
.
TOPIC_EXPIRATION_FINISHED
)
;
let
expire
=
Cc
[
"
mozilla
.
org
/
places
/
expiration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
expire
.
observe
(
null
"
places
-
debug
-
start
-
expiration
"
-
1
)
;
await
promise
;
}
"
Saw
no
regeneration
on
page
-
removed
via
expiration
.
"
)
;
}
)
;
add_task
(
async
function
test_history_cleared
(
)
{
const
PAGE_URI
=
"
https
:
/
/
test
.
com
"
;
await
addTestHistory
(
PAGE_URI
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
clear
(
)
;
}
"
Saw
regeneration
on
history
-
cleared
.
"
)
;
}
)
;
add_task
(
async
function
test_download_removed
(
)
{
const
FAKE_FILE_PATH
=
PathUtils
.
join
(
PathUtils
.
tempDir
"
somefile
.
zip
"
)
;
let
download
=
{
source
:
{
url
:
"
https
:
/
/
test
.
com
/
somefile
"
isPrivate
:
false
}
target
:
{
path
:
FAKE_FILE_PATH
}
}
;
await
DownloadHistory
.
addDownloadToHistory
(
download
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
remove
(
download
.
source
.
url
)
;
}
"
Saw
regeneration
on
download
removal
.
"
)
;
}
)
;
add_task
(
async
function
test_all_downloads_removed
(
)
{
const
FAKE_FILE_PATH
=
PathUtils
.
join
(
PathUtils
.
tempDir
"
somefile
.
zip
"
)
;
let
download1
=
{
source
:
{
url
:
"
https
:
/
/
test
.
com
/
somefile
"
isPrivate
:
false
}
target
:
{
path
:
FAKE_FILE_PATH
}
}
;
let
download2
=
{
source
:
{
url
:
"
https
:
/
/
test
.
com
/
somefile2
"
isPrivate
:
false
}
target
:
{
path
:
FAKE_FILE_PATH
}
}
;
await
DownloadHistory
.
addDownloadToHistory
(
download1
)
;
await
DownloadHistory
.
addDownloadToHistory
(
download2
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
removeVisitsByFilter
(
{
transition
:
PlacesUtils
.
history
.
TRANSITIONS
.
DOWNLOAD
}
)
;
}
"
Saw
regeneration
on
all
downloads
removed
.
"
)
;
}
)
;
