"
use
strict
"
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
const
{
PlacesTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
const
{
DownloadHistory
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
DownloadHistory
.
sys
.
mjs
"
)
;
const
{
AddonTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
sys
.
mjs
"
)
;
const
{
ExtensionTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ExtensionXPCShellUtils
.
sys
.
mjs
"
)
;
const
{
formAutofillStorage
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
autofill
/
FormAutofillStorage
.
sys
.
mjs
"
)
;
const
{
Sanitizer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
Sanitizer
.
sys
.
mjs
"
)
;
ExtensionTestUtils
.
init
(
this
)
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
)
;
const
nsLoginInfo
=
new
Components
.
Constructor
(
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
Ci
.
nsILoginInfo
"
init
"
)
;
async
function
addTestHistory
(
uriString
timestamp
=
Date
.
now
(
)
)
{
let
uri
=
NetUtil
.
newURI
(
uriString
)
;
await
PlacesTestUtils
.
addVisits
(
{
uri
transition
:
Ci
.
nsINavHistoryService
.
TRANSITION_TYPED
visitDate
:
timestamp
*
1000
}
)
;
}
async
function
expectRegeneration
(
taskFn
msg
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
BackupService
"
REGENERATION_DEBOUNCE_RATE_MS
"
)
.
get
(
(
)
=
>
0
)
;
let
bs
=
new
BackupService
(
)
;
let
deleteDeferred
=
Promise
.
withResolvers
(
)
;
sandbox
.
stub
(
bs
"
deleteLastBackup
"
)
.
callsFake
(
(
)
=
>
{
Assert
.
ok
(
true
"
Saw
deleteLastBackup
call
"
)
;
deleteDeferred
.
resolve
(
)
;
return
Promise
.
resolve
(
)
;
}
)
;
let
createBackupDeferred
=
Promise
.
withResolvers
(
)
;
sandbox
.
stub
(
bs
"
createBackupOnIdleDispatch
"
)
.
callsFake
(
(
)
=
>
{
Assert
.
ok
(
true
"
Saw
createBackupOnIdleDispatch
call
"
)
;
createBackupDeferred
.
resolve
(
)
;
return
Promise
.
resolve
(
)
;
}
)
;
bs
.
initBackupScheduler
(
)
;
await
taskFn
(
)
;
let
regenerationPromises
=
[
deleteDeferred
.
promise
createBackupDeferred
.
promise
]
;
let
timeoutPromise
=
new
Promise
(
(
resolve
reject
)
=
>
setTimeout
(
(
)
=
>
{
reject
(
)
;
}
1000
)
)
;
try
{
await
Promise
.
race
(
[
Promise
.
all
(
regenerationPromises
)
timeoutPromise
]
)
;
Assert
.
ok
(
true
msg
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
Timed
out
waiting
for
regeneration
.
"
)
;
}
bs
.
uninitBackupScheduler
(
)
;
sandbox
.
restore
(
)
;
}
async
function
expectNoRegeneration
(
taskFn
msg
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
BackupService
"
REGENERATION_DEBOUNCE_RATE_MS
"
)
.
get
(
(
)
=
>
0
)
;
let
bs
=
new
BackupService
(
)
;
let
regenerationPromise
=
Promise
.
withResolvers
(
)
;
sandbox
.
stub
(
bs
"
deleteLastBackup
"
)
.
callsFake
(
(
)
=
>
{
Assert
.
ok
(
false
"
Unexpectedly
saw
deleteLastBackup
call
"
)
;
regenerationPromise
.
reject
(
)
;
return
Promise
.
resolve
(
)
;
}
)
;
sandbox
.
stub
(
bs
"
createBackupOnIdleDispatch
"
)
.
callsFake
(
(
)
=
>
{
Assert
.
ok
(
false
"
Unexpectedly
saw
createBackupOnIdleDispatch
call
"
)
;
regenerationPromise
.
reject
(
)
;
return
Promise
.
resolve
(
)
;
}
)
;
bs
.
initBackupScheduler
(
)
;
await
taskFn
(
)
;
let
timeoutPromise
=
new
Promise
(
resolve
=
>
setTimeout
(
(
)
=
>
{
Assert
.
ok
(
true
"
Saw
no
regeneration
within
1
second
.
"
)
;
resolve
(
)
;
}
1000
)
)
;
try
{
await
Promise
.
race
(
[
regenerationPromise
.
promise
timeoutPromise
]
)
;
Assert
.
ok
(
true
msg
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
Saw
an
unexpected
regeneration
.
"
)
;
}
bs
.
uninitBackupScheduler
(
)
;
sandbox
.
restore
(
)
;
}
add_task
(
async
function
test_page_removed_reason_deleted
(
)
{
const
PAGE_URI
=
"
https
:
/
/
test
.
com
"
;
await
addTestHistory
(
PAGE_URI
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
remove
(
PAGE_URI
)
;
}
"
Saw
regeneration
on
page
-
removed
via
user
deletion
.
"
)
;
}
)
;
add_task
(
async
function
test_page_removed_reason_expired
(
)
{
const
PAGE_URI
=
"
https
:
/
/
test
.
com
"
;
await
addTestHistory
(
PAGE_URI
0
)
;
await
expectNoRegeneration
(
async
(
)
=
>
{
let
promise
=
TestUtils
.
topicObserved
(
PlacesUtils
.
TOPIC_EXPIRATION_FINISHED
)
;
let
expire
=
Cc
[
"
mozilla
.
org
/
places
/
expiration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
expire
.
observe
(
null
"
places
-
debug
-
start
-
expiration
"
-
1
)
;
await
promise
;
}
"
Saw
no
regeneration
on
page
-
removed
via
expiration
.
"
)
;
}
)
;
add_task
(
async
function
test_history_cleared
(
)
{
const
PAGE_URI
=
"
https
:
/
/
test
.
com
"
;
await
addTestHistory
(
PAGE_URI
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
clear
(
)
;
}
"
Saw
regeneration
on
history
-
cleared
.
"
)
;
}
)
;
add_task
(
async
function
test_download_removed
(
)
{
const
FAKE_FILE_PATH
=
PathUtils
.
join
(
PathUtils
.
tempDir
"
somefile
.
zip
"
)
;
let
download
=
{
source
:
{
url
:
"
https
:
/
/
test
.
com
/
somefile
"
isPrivate
:
false
}
target
:
{
path
:
FAKE_FILE_PATH
}
}
;
await
DownloadHistory
.
addDownloadToHistory
(
download
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
remove
(
download
.
source
.
url
)
;
}
"
Saw
regeneration
on
download
removal
.
"
)
;
}
)
;
add_task
(
async
function
test_all_downloads_removed
(
)
{
const
FAKE_FILE_PATH
=
PathUtils
.
join
(
PathUtils
.
tempDir
"
somefile
.
zip
"
)
;
let
download1
=
{
source
:
{
url
:
"
https
:
/
/
test
.
com
/
somefile
"
isPrivate
:
false
}
target
:
{
path
:
FAKE_FILE_PATH
}
}
;
let
download2
=
{
source
:
{
url
:
"
https
:
/
/
test
.
com
/
somefile2
"
isPrivate
:
false
}
target
:
{
path
:
FAKE_FILE_PATH
}
}
;
await
DownloadHistory
.
addDownloadToHistory
(
download1
)
;
await
DownloadHistory
.
addDownloadToHistory
(
download2
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
removeVisitsByFilter
(
{
transition
:
PlacesUtils
.
history
.
TRANSITIONS
.
DOWNLOAD
}
)
;
}
"
Saw
regeneration
on
all
downloads
removed
.
"
)
;
}
)
;
add_task
(
async
function
test_password_removed
(
)
{
let
login
=
new
nsLoginInfo
(
"
https
:
/
/
example
.
com
"
"
https
:
/
/
example
.
com
"
null
"
notifyu1
"
"
notifyp1
"
"
user
"
"
pass
"
)
;
await
Services
.
logins
.
addLoginAsync
(
login
)
;
await
expectRegeneration
(
async
(
)
=
>
{
Services
.
logins
.
removeLogin
(
login
)
;
}
"
Saw
regeneration
on
password
removed
.
"
)
;
}
)
;
add_task
(
async
function
test_all_passwords_removed
(
)
{
let
login1
=
new
nsLoginInfo
(
"
https
:
/
/
example
.
com
"
"
https
:
/
/
example
.
com
"
null
"
notifyu1
"
"
notifyp1
"
"
user
"
"
pass
"
)
;
let
login2
=
new
nsLoginInfo
(
"
https
:
/
/
example
.
com
"
"
https
:
/
/
example
.
com
"
null
"
"
"
notifyp1
"
"
"
"
pass
"
)
;
await
Services
.
logins
.
addLoginAsync
(
login1
)
;
await
Services
.
logins
.
addLoginAsync
(
login2
)
;
await
expectRegeneration
(
async
(
)
=
>
{
Services
.
logins
.
removeAllLogins
(
)
;
}
"
Saw
regeneration
on
all
passwords
removed
.
"
)
;
}
)
;
add_task
(
async
function
test_bookmark_removed
(
)
{
let
bookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
"
data
:
text
/
plain
Content
"
title
:
"
Regeneration
Test
Bookmark
"
}
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
)
;
}
"
Saw
regeneration
on
bookmark
removed
.
"
)
;
}
)
;
add_task
(
async
function
test_all_bookmarks_removed
(
)
{
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
"
data
:
text
/
plain
Content
"
title
:
"
Regeneration
Test
Bookmark
1
"
}
)
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
"
data
:
text
/
plain
Content2
"
title
:
"
Regeneration
Test
Bookmark
2
"
}
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
}
"
Saw
regeneration
on
all
bookmarks
removed
.
"
)
;
}
)
;
add_task
(
async
function
test_addon_uninstalled
(
)
{
await
AddonTestUtils
.
promiseStartupManager
(
)
;
let
testExtension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Some
test
extension
"
browser_specific_settings
:
{
gecko
:
{
id
:
"
test
-
backup
-
regeneration
ext
-
0
"
}
}
}
useAddonManager
:
"
temporary
"
}
)
;
await
testExtension
.
startup
(
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
testExtension
.
unload
(
)
;
}
"
Saw
regeneration
on
test
extension
uninstall
.
"
)
;
}
)
;
add_task
(
async
function
test_payment_method_removed
(
)
{
await
formAutofillStorage
.
initialize
(
)
;
let
guid
=
await
formAutofillStorage
.
creditCards
.
add
(
{
"
cc
-
name
"
:
"
Foxy
the
Firefox
"
"
cc
-
number
"
:
"
5555555555554444
"
"
cc
-
exp
-
month
"
:
5
"
cc
-
exp
-
year
"
:
2099
}
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
formAutofillStorage
.
creditCards
.
remove
(
guid
)
;
}
"
Saw
regeneration
on
payment
method
removal
.
"
)
;
}
)
;
add_task
(
async
function
test_address_removed
(
)
{
await
formAutofillStorage
.
initialize
(
)
;
let
guid
=
await
formAutofillStorage
.
addresses
.
add
(
{
"
given
-
name
"
:
"
John
"
"
additional
-
name
"
:
"
R
.
"
"
family
-
name
"
:
"
Smith
"
organization
:
"
World
Wide
Web
Consortium
"
"
street
-
address
"
:
"
32
Vassar
Street
\
\
\
nMIT
Room
32
-
G524
"
"
address
-
level2
"
:
"
Cambridge
"
"
address
-
level1
"
:
"
MA
"
"
postal
-
code
"
:
"
02139
"
country
:
"
US
"
tel
:
"
+
15195555555
"
email
:
"
user
example
.
com
"
}
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
formAutofillStorage
.
addresses
.
remove
(
guid
)
;
}
"
Saw
regeneration
on
address
removal
.
"
)
;
}
)
;
add_task
(
async
function
test_sanitization
(
)
{
await
expectRegeneration
(
async
(
)
=
>
{
await
Sanitizer
.
sanitize
(
[
"
cookiesAndStorage
"
]
)
;
}
"
Saw
regeneration
on
sanitization
of
cookies
and
storage
.
"
)
;
await
expectRegeneration
(
async
(
)
=
>
{
await
Sanitizer
.
sanitize
(
[
"
siteSettings
"
]
)
;
}
"
Saw
regeneration
on
sanitization
of
site
settings
.
"
)
;
}
)
;
