"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
BackupError
:
"
resource
:
/
/
/
modules
/
backup
/
BackupError
.
mjs
"
ERRORS
:
"
chrome
:
/
/
browser
/
content
/
backup
/
backup
-
constants
.
mjs
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
}
)
;
const
BACKUP_RETRY_LIMIT_PREF_NAME
=
"
browser
.
backup
.
backup
-
retry
-
limit
"
;
const
DISABLED_ON_IDLE_RETRY_PREF_NAME
=
"
browser
.
backup
.
disabled
-
on
-
idle
-
backup
-
retry
"
;
const
BACKUP_ERROR_CODE_PREF_NAME
=
"
browser
.
backup
.
errorCode
"
;
const
MINIMUM_TIME_BETWEEN_BACKUPS_SECONDS_PREF_NAME
=
"
browser
.
backup
.
scheduled
.
minimum
-
time
-
between
-
backups
-
seconds
"
;
const
SCHEDULED_BACKUPS_ENABLED_PREF_NAME
=
"
browser
.
backup
.
scheduled
.
enabled
"
;
const
BACKUP_DEBUG_INFO_PREF_NAME
=
"
browser
.
backup
.
backup
-
debug
-
info
"
;
const
BACKUP_DEFAULT_LOCATION_PREF_NAME
=
"
browser
.
backup
.
location
"
;
function
bsInProgressStateUpdate
(
bs
isBackupInProgress
)
{
return
new
Promise
(
resolve
=
>
{
bs
.
addEventListener
(
"
BackupService
:
StateUpdate
"
(
)
=
>
{
if
(
bs
.
state
.
backupInProgress
=
=
isBackupInProgress
)
{
resolve
(
)
;
}
else
{
Assert
.
ok
(
false
"
Failure
in
waiting
for
state
updates
"
)
;
}
}
{
once
:
true
}
)
;
}
)
;
}
add_setup
(
async
(
)
=
>
{
const
TEST_PROFILE_PATH
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testBackup
"
)
;
Services
.
prefs
.
setStringPref
(
BACKUP_DEFAULT_LOCATION_PREF_NAME
TEST_PROFILE_PATH
)
;
Services
.
prefs
.
setBoolPref
(
SCHEDULED_BACKUPS_ENABLED_PREF_NAME
true
)
;
Services
.
prefs
.
setIntPref
(
BACKUP_RETRY_LIMIT_PREF_NAME
2
)
;
Services
.
prefs
.
setBoolPref
(
DISABLED_ON_IDLE_RETRY_PREF_NAME
false
)
;
setupProfile
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
BACKUP_DEFAULT_LOCATION_PREF_NAME
)
;
Services
.
prefs
.
clearUserPref
(
SCHEDULED_BACKUPS_ENABLED_PREF_NAME
)
;
Services
.
prefs
.
clearUserPref
(
BACKUP_RETRY_LIMIT_PREF_NAME
)
;
Services
.
prefs
.
clearUserPref
(
DISABLED_ON_IDLE_RETRY_PREF_NAME
)
;
await
IOUtils
.
remove
(
TEST_PROFILE_PATH
{
recursive
:
true
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_retry_limit
(
)
{
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
const
createBackupFailureStub
=
sandbox
.
stub
(
bs
"
resolveArchiveDestFolderPath
"
)
.
rejects
(
new
BackupError
(
"
forced
failure
"
ERRORS
.
UNKNOWN
)
)
;
sandbox
.
stub
(
ChromeUtils
"
idleDispatch
"
)
.
callsFake
(
callback
=
>
callback
(
)
)
;
sandbox
.
spy
(
bs
"
createBackup
"
)
;
const
n
=
Services
.
prefs
.
getIntPref
(
BACKUP_RETRY_LIMIT_PREF_NAME
)
;
for
(
let
i
=
0
;
i
<
=
n
;
i
+
+
)
{
Services
.
prefs
.
setIntPref
(
BACKUP_ERROR_CODE_PREF_NAME
ERRORS
.
NONE
)
;
bs
.
createBackupOnIdleDispatch
(
)
;
await
bsInProgressStateUpdate
(
bs
true
)
;
await
bsInProgressStateUpdate
(
bs
false
)
;
await
new
Promise
(
executeSoon
)
;
Assert
.
equal
(
bs
.
createBackup
.
callCount
i
+
1
"
createBackup
was
called
on
idle
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
BACKUP_ERROR_CODE_PREF_NAME
)
ERRORS
.
UNKNOWN
"
Error
code
has
been
set
"
)
;
}
const
previousCalls
=
bs
.
createBackup
.
callCount
;
bs
.
createBackupOnIdleDispatch
(
)
;
await
new
Promise
(
executeSoon
)
;
Assert
.
equal
(
bs
.
createBackup
.
callCount
previousCalls
"
createBackup
was
not
called
again
after
hitting
the
retry
limit
"
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
DISABLED_ON_IDLE_RETRY_PREF_NAME
)
"
Disable
on
idle
has
been
enabled
"
)
;
Services
.
prefs
.
setIntPref
(
MINIMUM_TIME_BETWEEN_BACKUPS_SECONDS_PREF_NAME
0
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
MINIMUM_TIME_BETWEEN_BACKUPS_SECONDS_PREF_NAME
)
;
}
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10
)
)
;
bs
.
createBackupOnIdleDispatch
(
)
;
await
bsInProgressStateUpdate
(
bs
true
)
;
Assert
.
equal
(
bs
.
createBackup
.
callCount
previousCalls
+
1
"
createBackup
was
called
again
"
)
;
await
bsInProgressStateUpdate
(
bs
false
)
;
createBackupFailureStub
.
restore
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
10
)
)
;
let
testProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testBackup_profile
"
)
;
await
bs
.
createBackup
(
{
profilePath
:
testProfilePath
}
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
DISABLED_ON_IDLE_RETRY_PREF_NAME
)
"
Retry
on
idle
is
enabled
now
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getIntPref
(
BACKUP_ERROR_CODE_PREF_NAME
)
ERRORS
.
NONE
"
The
error
code
is
reset
to
NONE
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getStringPref
(
BACKUP_DEBUG_INFO_PREF_NAME
null
)
"
Error
debug
info
has
been
cleared
"
)
;
sandbox
.
restore
(
)
;
}
)
;
