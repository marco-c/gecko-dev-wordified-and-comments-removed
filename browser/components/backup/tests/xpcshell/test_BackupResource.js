"
use
strict
"
;
const
{
bytesToFuzzyKilobytes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
BackupResource
.
sys
.
mjs
"
)
;
const
EXPECTED_KILOBYTES_FOR_XULSTORE
=
1
;
add_task
(
async
function
test_getFileSize
(
)
{
let
file
=
do_get_file
(
"
data
/
test_xulstore
.
json
"
)
;
let
testFilePath
=
PathUtils
.
join
(
PathUtils
.
profileDir
"
test_xulstore
.
json
"
)
;
await
IOUtils
.
copy
(
file
.
path
PathUtils
.
profileDir
)
;
let
size
=
await
BackupResource
.
getFileSize
(
testFilePath
)
;
Assert
.
equal
(
size
EXPECTED_KILOBYTES_FOR_XULSTORE
"
Size
of
the
test_xulstore
.
json
is
rounded
up
to
the
nearest
kilobyte
.
"
)
;
await
IOUtils
.
remove
(
testFilePath
)
;
}
)
;
add_task
(
async
function
test_getDirectorySize
(
)
{
let
file
=
do_get_file
(
"
data
/
test_xulstore
.
json
"
)
;
let
testDir
=
PathUtils
.
join
(
PathUtils
.
profileDir
"
testDir
"
)
;
await
IOUtils
.
makeDirectory
(
testDir
)
;
await
IOUtils
.
copy
(
file
.
path
testDir
)
;
let
nestedTestDir
=
PathUtils
.
join
(
testDir
"
testDir
"
)
;
await
IOUtils
.
makeDirectory
(
nestedTestDir
)
;
await
IOUtils
.
copy
(
file
.
path
nestedTestDir
)
;
let
size
=
await
BackupResource
.
getDirectorySize
(
testDir
)
;
Assert
.
equal
(
size
EXPECTED_KILOBYTES_FOR_XULSTORE
*
2
Total
size
of
the
directory
is
rounded
up
to
the
nearest
kilobyte
and
is
equal
to
twice
the
size
of
the
test_xulstore
.
json
file
)
;
await
IOUtils
.
remove
(
testDir
{
recursive
:
true
}
)
;
}
)
;
add_task
(
async
function
test_bytesToFuzzyKilobytes
(
)
{
let
largeSize
=
bytesToFuzzyKilobytes
(
1234000
)
;
Assert
.
equal
(
largeSize
1230
"
1234
bytes
is
rounded
up
to
the
nearest
tenth
kilobyte
1230
"
)
;
let
smallSize
=
bytesToFuzzyKilobytes
(
3
)
;
Assert
.
equal
(
smallSize
1
"
Sizes
under
10
kilobytes
return
1
kilobyte
"
)
;
}
)
;
add_task
(
async
function
test_copySqliteDatabases
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
sourcePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
BackupResource
-
source
-
test
"
)
;
let
destPath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
BackupResource
-
dest
-
test
"
)
;
let
pretendDatabases
=
[
"
places
.
sqlite
"
"
favicons
.
sqlite
"
]
;
let
fakeConnection
=
{
backup
:
sandbox
.
stub
(
)
.
resolves
(
true
)
close
:
sandbox
.
stub
(
)
.
resolves
(
true
)
}
;
sandbox
.
stub
(
Sqlite
"
openConnection
"
)
.
returns
(
fakeConnection
)
;
await
BackupResource
.
copySqliteDatabases
(
sourcePath
destPath
pretendDatabases
)
;
Assert
.
ok
(
Sqlite
.
openConnection
.
calledTwice
"
Sqlite
.
openConnection
called
twice
"
)
;
Assert
.
ok
(
Sqlite
.
openConnection
.
firstCall
.
calledWith
(
{
path
:
PathUtils
.
join
(
sourcePath
"
places
.
sqlite
"
)
readOnly
:
true
}
)
"
openConnection
called
with
places
.
sqlite
as
read
-
only
"
)
;
Assert
.
ok
(
Sqlite
.
openConnection
.
secondCall
.
calledWith
(
{
path
:
PathUtils
.
join
(
sourcePath
"
favicons
.
sqlite
"
)
readOnly
:
true
}
)
"
openConnection
called
with
favicons
.
sqlite
as
read
-
only
"
)
;
Assert
.
ok
(
fakeConnection
.
backup
.
calledTwice
"
backup
on
an
Sqlite
connection
called
twice
"
)
;
Assert
.
ok
(
fakeConnection
.
backup
.
firstCall
.
calledWith
(
PathUtils
.
join
(
destPath
"
places
.
sqlite
"
)
)
"
backup
called
with
places
.
sqlite
to
the
destination
path
"
)
;
Assert
.
ok
(
fakeConnection
.
backup
.
secondCall
.
calledWith
(
PathUtils
.
join
(
destPath
"
favicons
.
sqlite
"
)
)
"
backup
called
with
favicons
.
sqlite
to
the
destination
path
"
)
;
Assert
.
ok
(
fakeConnection
.
close
.
calledTwice
"
close
on
an
Sqlite
connection
called
twice
"
)
;
await
maybeRemovePath
(
sourcePath
)
;
await
maybeRemovePath
(
destPath
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_copyFiles
(
)
{
let
sourcePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
BackupResource
-
source
-
test
"
)
;
let
destPath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
BackupResource
-
dest
-
test
"
)
;
const
testFiles
=
[
{
path
:
"
file1
.
txt
"
}
{
path
:
[
"
some
"
"
nested
"
"
file
"
"
file2
.
txt
"
]
}
{
path
:
"
file3
.
txt
"
}
]
;
await
createTestFiles
(
sourcePath
testFiles
)
;
await
BackupResource
.
copyFiles
(
sourcePath
destPath
[
"
file1
.
txt
"
"
some
"
"
file3
.
txt
"
"
does
-
not
-
exist
.
txt
"
]
)
;
await
assertFilesExist
(
destPath
testFiles
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
PathUtils
.
join
(
destPath
"
does
-
not
-
exist
.
txt
"
)
)
)
"
does
-
not
-
exist
.
txt
wasn
'
t
somehow
written
to
.
"
)
;
await
maybeRemovePath
(
sourcePath
)
;
await
maybeRemovePath
(
destPath
)
;
}
)
;
