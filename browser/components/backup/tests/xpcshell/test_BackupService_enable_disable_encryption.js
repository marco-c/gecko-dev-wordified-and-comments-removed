"
use
strict
"
;
const
{
OSKeyStoreTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
OSKeyStoreTestUtils
.
sys
.
mjs
"
)
;
const
TEST_PASSWORD
=
"
This
is
some
test
password
.
"
;
add_setup
(
async
(
)
=
>
{
OSKeyStoreTestUtils
.
setup
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
OSKeyStoreTestUtils
.
cleanup
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_disabled_encryption
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
bs
=
new
BackupService
(
{
FakeBackupResource1
FakeBackupResource2
FakeBackupResource3
}
)
;
Assert
.
ok
(
!
bs
.
state
.
encryptionEnabled
"
State
should
indicate
that
encryption
is
disabled
.
"
)
;
let
testProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testDisabledEncryption
"
)
;
let
encState
=
await
bs
.
loadEncryptionState
(
testProfilePath
)
;
Assert
.
ok
(
!
encState
"
Should
not
find
an
ArchiveEncryptionState
.
"
)
;
sandbox
.
stub
(
FakeBackupResource2
"
requiresEncryption
"
)
.
get
(
(
)
=
>
{
return
true
;
}
)
;
Assert
.
ok
(
FakeBackupResource2
.
requiresEncryption
"
FakeBackupResource2
requires
encryption
.
"
)
;
Assert
.
ok
(
!
FakeBackupResource1
.
requiresEncryption
"
FakeBackupResource1
does
not
require
encryption
.
"
)
;
Assert
.
ok
(
!
FakeBackupResource3
.
requiresEncryption
"
FakeBackupResource3
does
not
require
encryption
.
"
)
;
let
resourceWithoutEncryptionStubs
=
[
sandbox
.
stub
(
FakeBackupResource1
.
prototype
"
backup
"
)
.
resolves
(
null
)
sandbox
.
stub
(
FakeBackupResource3
.
prototype
"
backup
"
)
.
resolves
(
null
)
]
;
let
resourceWithEncryptionStub
=
sandbox
.
stub
(
FakeBackupResource2
.
prototype
"
backup
"
)
.
resolves
(
null
)
;
await
bs
.
createBackup
(
{
profilePath
:
testProfilePath
}
)
;
Assert
.
ok
(
resourceWithEncryptionStub
.
notCalled
"
FakeBackupResource2
.
backup
should
not
have
been
called
"
)
;
for
(
let
resourceWithoutEncryptionStub
of
resourceWithoutEncryptionStubs
)
{
Assert
.
ok
(
resourceWithoutEncryptionStub
.
calledOnce
"
backup
called
on
resource
that
didn
'
t
require
encryption
"
)
;
}
await
IOUtils
.
remove
(
testProfilePath
{
recursive
:
true
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_already_disabled_encryption
(
)
{
let
bs
=
new
BackupService
(
)
;
Assert
.
ok
(
!
bs
.
state
.
encryptionEnabled
"
State
should
indicate
that
encryption
is
disabled
.
"
)
;
let
encState
=
await
bs
.
loadEncryptionState
(
)
;
Assert
.
ok
(
!
encState
"
Should
not
find
an
ArchiveEncryptionState
.
"
)
;
await
Assert
.
rejects
(
bs
.
disableEncryption
(
)
/
already
disabled
/
"
It
should
not
be
possible
to
disable
encryption
if
it
'
s
already
disabled
"
)
;
}
)
;
add_task
(
async
function
test_enable_encryption
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
bs
=
new
BackupService
(
{
FakeBackupResource1
FakeBackupResource2
FakeBackupResource3
}
)
;
Assert
.
ok
(
!
bs
.
state
.
encryptionEnabled
"
State
should
initially
indicate
that
encryption
is
disabled
.
"
)
;
let
testProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testEnableEncryption
"
)
;
let
encState
=
await
bs
.
loadEncryptionState
(
testProfilePath
)
;
Assert
.
ok
(
!
encState
"
Should
not
find
an
ArchiveEncryptionState
.
"
)
;
let
stateUpdatePromise
=
new
Promise
(
resolve
=
>
{
bs
.
addEventListener
(
"
BackupService
:
StateUpdate
"
resolve
{
once
:
true
}
)
;
}
)
;
await
bs
.
enableEncryption
(
TEST_PASSWORD
testProfilePath
)
;
await
stateUpdatePromise
;
Assert
.
ok
(
bs
.
state
.
encryptionEnabled
"
State
should
indicate
that
encryption
is
enabled
.
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
PathUtils
.
join
(
testProfilePath
BackupService
.
PROFILE_FOLDER_NAME
BackupService
.
ARCHIVE_ENCRYPTION_STATE_FILE
)
)
"
Encryption
state
file
should
exist
.
"
)
;
sandbox
.
stub
(
FakeBackupResource2
"
requiresEncryption
"
)
.
get
(
(
)
=
>
{
return
true
;
}
)
;
Assert
.
ok
(
FakeBackupResource2
.
requiresEncryption
"
FakeBackupResource2
requires
encryption
.
"
)
;
Assert
.
ok
(
!
FakeBackupResource1
.
requiresEncryption
"
FakeBackupResource1
does
not
require
encryption
.
"
)
;
Assert
.
ok
(
!
FakeBackupResource3
.
requiresEncryption
"
FakeBackupResource3
does
not
require
encryption
.
"
)
;
let
allResourceBackupStubs
=
[
sandbox
.
stub
(
FakeBackupResource1
.
prototype
"
backup
"
)
.
resolves
(
null
)
sandbox
.
stub
(
FakeBackupResource3
.
prototype
"
backup
"
)
.
resolves
(
null
)
sandbox
.
stub
(
FakeBackupResource2
.
prototype
"
backup
"
)
.
resolves
(
null
)
]
;
await
bs
.
createBackup
(
{
profilePath
:
testProfilePath
}
)
;
for
(
let
resourceBackupStub
of
allResourceBackupStubs
)
{
Assert
.
ok
(
resourceBackupStub
.
calledOnce
"
backup
called
on
resource
"
)
;
}
Assert
.
ok
(
await
IOUtils
.
exists
(
PathUtils
.
join
(
testProfilePath
BackupService
.
PROFILE_FOLDER_NAME
BackupService
.
ARCHIVE_ENCRYPTION_STATE_FILE
)
)
"
Encryption
state
file
should
still
exist
.
"
)
;
await
IOUtils
.
remove
(
testProfilePath
{
recursive
:
true
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_already_enabled_encryption
(
)
{
let
bs
=
new
BackupService
(
)
;
let
testProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testAlreadyEnabledEncryption
"
)
;
await
bs
.
enableEncryption
(
TEST_PASSWORD
testProfilePath
)
;
let
encState
=
await
bs
.
loadEncryptionState
(
testProfilePath
)
;
Assert
.
ok
(
encState
"
ArchiveEncryptionState
is
available
.
"
)
;
await
Assert
.
rejects
(
bs
.
enableEncryption
(
TEST_PASSWORD
testProfilePath
)
/
already
enabled
/
"
It
should
not
be
possible
to
enable
encryption
if
it
'
s
already
enabled
"
)
;
await
IOUtils
.
remove
(
testProfilePath
{
recursive
:
true
}
)
;
}
)
;
add_task
(
async
function
test_disabling_encryption
(
)
{
let
bs
=
new
BackupService
(
)
;
let
testProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testDisableEncryption
"
)
;
await
bs
.
enableEncryption
(
TEST_PASSWORD
testProfilePath
)
;
let
encState
=
await
bs
.
loadEncryptionState
(
testProfilePath
)
;
Assert
.
ok
(
encState
"
ArchiveEncryptionState
is
available
.
"
)
;
Assert
.
ok
(
bs
.
state
.
encryptionEnabled
"
State
should
indicate
that
encryption
is
enabled
.
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
PathUtils
.
join
(
testProfilePath
BackupService
.
PROFILE_FOLDER_NAME
BackupService
.
ARCHIVE_ENCRYPTION_STATE_FILE
)
)
"
Encryption
state
file
should
exist
.
"
)
;
let
stateUpdatePromise
=
new
Promise
(
resolve
=
>
{
bs
.
addEventListener
(
"
BackupService
:
StateUpdate
"
resolve
{
once
:
true
}
)
;
}
)
;
await
bs
.
disableEncryption
(
testProfilePath
)
;
await
stateUpdatePromise
;
Assert
.
ok
(
!
bs
.
state
.
encryptionEnabled
"
State
should
indicate
that
encryption
is
now
disabled
.
"
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
PathUtils
.
join
(
testProfilePath
BackupService
.
PROFILE_FOLDER_NAME
BackupService
.
ARCHIVE_ENCRYPTION_STATE_FILE
)
)
)
"
Encryption
state
file
should
have
been
removed
.
"
)
;
await
IOUtils
.
remove
(
testProfilePath
{
recursive
:
true
}
)
;
}
)
;
