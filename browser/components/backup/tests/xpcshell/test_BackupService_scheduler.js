"
use
strict
"
;
const
SCHEDULED_BACKUPS_ENABLED_PREF_NAME
=
"
browser
.
backup
.
scheduled
.
enabled
"
;
const
IDLE_THRESHOLD_SECONDS_PREF_NAME
=
"
browser
.
backup
.
scheduled
.
idle
-
threshold
-
seconds
"
;
const
LAST_BACKUP_TIMESTAMP_PREF_NAME
=
"
browser
.
backup
.
scheduled
.
last
-
backup
-
timestamp
"
;
const
MINIMUM_TIME_BETWEEN_BACKUPS_SECONDS_PREF_NAME
=
"
browser
.
backup
.
scheduled
.
minimum
-
time
-
between
-
backups
-
seconds
"
;
let
idleService
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUserIdleService
"
]
)
idleTime
:
19999
disabled
:
true
addIdleObserver
(
)
{
}
removeIdleObserver
(
)
{
}
}
;
add_setup
(
(
)
=
>
{
let
fakeIdleServiceCID
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
idleService
)
;
Services
.
prefs
.
setBoolPref
(
SCHEDULED_BACKUPS_ENABLED_PREF_NAME
true
)
;
Services
.
prefs
.
setIntPref
(
MINIMUM_TIME_BETWEEN_BACKUPS_SECONDS_PREF_NAME
20
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
fakeIdleServiceCID
)
;
Services
.
prefs
.
clearUserPref
(
SCHEDULED_BACKUPS_ENABLED_PREF_NAME
)
;
Services
.
prefs
.
clearUserPref
(
MINIMUM_TIME_BETWEEN_BACKUPS_SECONDS_PREF_NAME
)
;
}
)
;
}
)
;
add_task
(
async
function
test_init_uninitBackupScheduler
(
)
{
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
idleService
"
addIdleObserver
"
)
;
sandbox
.
stub
(
idleService
"
removeIdleObserver
"
)
;
await
bs
.
initBackupScheduler
(
)
;
Assert
.
ok
(
idleService
.
addIdleObserver
.
calledOnce
"
addIdleObserver
was
called
"
)
;
Assert
.
ok
(
idleService
.
addIdleObserver
.
firstCall
.
args
[
0
]
instanceof
Ci
.
nsIObserver
"
The
first
argument
to
addIdleObserver
was
an
nsIObserver
"
)
;
const
THRESHOLD_SECONDS
=
Services
.
prefs
.
getIntPref
(
IDLE_THRESHOLD_SECONDS_PREF_NAME
)
;
Assert
.
equal
(
idleService
.
addIdleObserver
.
firstCall
.
args
[
1
]
THRESHOLD_SECONDS
"
The
idle
threshold
preference
value
was
passed
as
the
second
argument
.
"
)
;
Assert
.
ok
(
idleService
.
removeIdleObserver
.
notCalled
"
removeIdleObserver
has
not
been
called
yet
.
"
)
;
let
addObserverArg
=
idleService
.
addIdleObserver
.
firstCall
.
args
[
0
]
;
idleService
.
addIdleObserver
.
resetHistory
(
)
;
Services
.
prefs
.
setIntPref
(
IDLE_THRESHOLD_SECONDS_PREF_NAME
THRESHOLD_SECONDS
+
5
)
;
bs
.
uninitBackupScheduler
(
)
;
Assert
.
ok
(
idleService
.
addIdleObserver
.
notCalled
"
addIdleObserver
was
not
called
again
.
"
)
;
Assert
.
ok
(
idleService
.
removeIdleObserver
.
calledOnce
"
removeIdleObserver
was
called
once
.
"
)
;
Assert
.
ok
(
idleService
.
removeIdleObserver
.
firstCall
.
args
[
0
]
instanceof
Ci
.
nsIObserver
"
The
first
argument
to
addIdleObserver
was
an
nsIObserver
"
)
;
Assert
.
equal
(
idleService
.
removeIdleObserver
.
firstCall
.
args
[
0
]
addObserverArg
"
The
first
argument
to
addIdleObserver
matches
the
first
argument
to
removeIdleObserver
"
)
;
Assert
.
equal
(
idleService
.
removeIdleObserver
.
firstCall
.
args
[
1
]
THRESHOLD_SECONDS
"
The
original
idle
threshold
preference
value
was
passed
as
the
second
argument
.
"
)
;
sandbox
.
restore
(
)
;
Services
.
prefs
.
clearUserPref
(
IDLE_THRESHOLD_SECONDS_PREF_NAME
)
;
}
)
;
add_task
(
async
function
test_BackupService_onObserve_idle
(
)
{
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
bs
"
onIdle
"
)
;
bs
.
onObserve
(
idleService
"
idle
"
)
;
Assert
.
ok
(
bs
.
onIdle
.
calledOnce
"
BackupService
.
onIdle
was
called
.
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_BackupService_onObserve_quit_application_granted
(
)
{
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
bs
"
uninitBackupScheduler
"
)
;
bs
.
onObserve
(
null
"
quit
-
application
-
granted
"
)
;
Assert
.
ok
(
bs
.
uninitBackupScheduler
.
calledOnce
"
BackupService
.
uninitBackupScheduler
was
called
.
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_BackupService_idle_no_backup_exists
(
)
{
Services
.
prefs
.
clearUserPref
(
LAST_BACKUP_TIMESTAMP_PREF_NAME
)
;
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
bs
"
createBackupOnIdleDispatch
"
)
;
bs
.
initBackupScheduler
(
)
;
Assert
.
equal
(
bs
.
state
.
lastBackupDate
null
"
State
should
have
null
for
lastBackupDate
"
)
;
bs
.
onIdle
(
)
;
Assert
.
ok
(
bs
.
createBackupOnIdleDispatch
.
calledOnce
"
BackupService
.
createBackupOnIdleDispatch
was
called
.
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_BackupService_idle_not_expired_backup
(
)
{
let
fiveSecondsAgo
=
Date
.
now
(
)
-
5000
;
let
lastBackupPrefValue
=
Math
.
floor
(
fiveSecondsAgo
/
1000
)
;
Services
.
prefs
.
setIntPref
(
LAST_BACKUP_TIMESTAMP_PREF_NAME
lastBackupPrefValue
)
;
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
bs
.
initBackupScheduler
(
)
;
Assert
.
equal
(
bs
.
state
.
lastBackupDate
lastBackupPrefValue
"
State
should
have
cached
lastBackupDate
"
)
;
sandbox
.
stub
(
bs
"
createBackupOnIdleDispatch
"
)
;
bs
.
onIdle
(
)
;
Assert
.
ok
(
bs
.
createBackupOnIdleDispatch
.
notCalled
"
BackupService
.
createBackupOnIdleDispatch
was
not
called
.
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_BackupService_idle_expired_backup
(
)
{
let
twentyFiveSecondsAgo
=
Date
.
now
(
)
-
25000
;
let
lastBackupPrefValue
=
Math
.
floor
(
twentyFiveSecondsAgo
/
1000
)
;
Services
.
prefs
.
setIntPref
(
LAST_BACKUP_TIMESTAMP_PREF_NAME
lastBackupPrefValue
)
;
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
bs
.
initBackupScheduler
(
)
;
Assert
.
equal
(
bs
.
state
.
lastBackupDate
lastBackupPrefValue
"
State
should
have
cached
lastBackupDate
"
)
;
sandbox
.
stub
(
bs
"
createBackupOnIdleDispatch
"
)
;
bs
.
onIdle
(
)
;
Assert
.
ok
(
bs
.
createBackupOnIdleDispatch
.
calledOnce
"
BackupService
.
createBackupOnIdleDispatch
was
called
.
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_BackupService_idle_time_travel
(
)
{
let
twentyFiveSecondsFromNow
=
Date
.
now
(
)
+
25000
;
let
lastBackupPrefValue
=
Math
.
floor
(
twentyFiveSecondsFromNow
/
1000
)
;
Services
.
prefs
.
setIntPref
(
LAST_BACKUP_TIMESTAMP_PREF_NAME
lastBackupPrefValue
)
;
let
bs
=
new
BackupService
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
bs
.
initBackupScheduler
(
)
;
Assert
.
equal
(
bs
.
state
.
lastBackupDate
lastBackupPrefValue
"
State
should
have
cached
lastBackupDate
"
)
;
sandbox
.
stub
(
bs
"
createBackupOnIdleDispatch
"
)
;
bs
.
onIdle
(
)
;
Assert
.
ok
(
bs
.
createBackupOnIdleDispatch
.
calledOnce
"
BackupService
.
createBackupOnIdleDispatch
was
called
.
"
)
;
Assert
.
equal
(
bs
.
state
.
lastBackupDate
null
"
Should
have
cleared
the
last
backup
date
.
"
)
;
sandbox
.
restore
(
)
;
}
)
;
