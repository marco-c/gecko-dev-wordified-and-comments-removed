"
use
strict
"
;
const
{
BackupService
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
BackupService
.
sys
.
mjs
"
)
;
const
{
BackupResource
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
BackupResource
.
sys
.
mjs
"
)
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
)
;
const
{
Sqlite
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
sys
.
mjs
"
)
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
const
BYTES_IN_KB
=
1000
;
do_get_profile
(
)
;
class
FakeBackupResource1
extends
BackupResource
{
static
get
key
(
)
{
return
"
fake1
"
;
}
static
get
requiresEncryption
(
)
{
return
false
;
}
}
class
FakeBackupResource2
extends
BackupResource
{
static
get
key
(
)
{
return
"
fake2
"
;
}
static
get
requiresEncryption
(
)
{
return
false
;
}
static
get
priority
(
)
{
return
1
;
}
}
class
FakeBackupResource3
extends
BackupResource
{
static
get
key
(
)
{
return
"
fake3
"
;
}
static
get
requiresEncryption
(
)
{
return
false
;
}
static
get
priority
(
)
{
return
2
;
}
}
async
function
createKilobyteSizedFile
(
path
sizeInKB
)
{
let
bytes
=
new
Uint8Array
(
sizeInKB
*
BYTES_IN_KB
)
;
await
IOUtils
.
write
(
path
bytes
)
;
}
async
function
createTestFiles
(
parentPath
testFilesArray
)
{
for
(
let
{
path
sizeInKB
}
of
testFilesArray
)
{
if
(
Array
.
isArray
(
path
)
)
{
let
folders
=
path
.
slice
(
0
-
1
)
;
await
IOUtils
.
getDirectory
(
PathUtils
.
join
(
parentPath
.
.
.
folders
)
)
;
}
if
(
sizeInKB
=
=
=
undefined
)
{
sizeInKB
=
10
;
}
let
filePath
=
PathUtils
.
join
(
parentPath
.
.
.
[
]
.
concat
(
path
)
)
;
await
createKilobyteSizedFile
(
filePath
sizeInKB
)
;
}
}
async
function
assertFilesExist
(
parentPath
testFilesArray
)
{
for
(
let
{
path
}
of
testFilesArray
)
{
let
copiedFileName
=
PathUtils
.
join
(
parentPath
.
.
.
[
]
.
concat
(
path
)
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
copiedFileName
)
{
copiedFileName
}
should
exist
in
the
staging
folder
)
;
}
}
async
function
maybeRemovePath
(
path
)
{
try
{
await
IOUtils
.
remove
(
path
{
ignoreAbsent
:
true
recursive
:
true
}
)
;
}
catch
(
error
)
{
if
(
error
.
name
!
=
"
NS_ERROR_FILE_IS_LOCKED
"
)
{
console
.
error
(
error
)
;
}
}
}
