"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
BackupService
:
"
resource
:
/
/
/
modules
/
backup
/
BackupService
.
sys
.
mjs
"
BackupResource
:
"
resource
:
/
/
/
modules
/
backup
/
BackupResource
.
sys
.
mjs
"
MeasurementUtils
:
"
resource
:
/
/
/
modules
/
backup
/
MeasurementUtils
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
sys
.
mjs
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
OSKeyStoreTestUtils
:
"
resource
:
/
/
testing
-
common
/
OSKeyStoreTestUtils
.
sys
.
mjs
"
MockRegistrar
:
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
}
)
;
const
HISTORY_ENABLED_PREF
=
"
places
.
history
.
enabled
"
;
const
SANITIZE_ON_SHUTDOWN_PREF
=
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
;
let
gFakeOSKeyStore
;
add_setup
(
async
(
)
=
>
{
gFakeOSKeyStore
=
{
asyncEncryptBytes
:
sinon
.
stub
(
)
asyncDecryptBytes
:
sinon
.
stub
(
)
asyncDeleteSecret
:
sinon
.
stub
(
)
.
resolves
(
)
asyncSecretAvailable
:
sinon
.
stub
(
)
.
resolves
(
true
)
asyncGetRecoveryPhrase
:
sinon
.
stub
(
)
.
resolves
(
"
SomeRecoveryPhrase
"
)
asyncRecoverSecret
:
sinon
.
stub
(
)
.
resolves
(
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIOSKeyStore
]
)
}
;
let
osKeyStoreCID
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
security
/
oskeystore
;
1
"
gFakeOSKeyStore
)
;
OSKeyStoreTestUtils
.
setup
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
OSKeyStoreTestUtils
.
cleanup
(
)
;
MockRegistrar
.
unregister
(
osKeyStoreCID
)
;
}
)
;
}
)
;
const
BYTES_IN_KB
=
1000
;
const
FAKE_METADATA
=
{
date
:
"
2024
-
06
-
07T00
:
00
:
00
+
00
:
00
"
appName
:
"
firefox
"
appVersion
:
"
128
.
0
"
buildID
:
"
20240604133346
"
profileName
:
"
profile
-
default
"
machineName
:
"
A
super
cool
machine
"
osName
:
"
Windows_NT
"
osVersion
:
"
10
.
0
"
legacyClientID
:
"
decafbad
-
0cd1
-
0cd2
-
0cd3
-
decafbad1000
"
profileGroupID
:
"
decafbad
-
0cd1
-
0cd2
-
0cd3
-
decafbad2000
"
accountID
:
"
"
accountEmail
:
"
"
}
;
do_get_profile
(
)
;
Services
.
prefs
.
setStringPref
(
"
browser
.
backup
.
location
"
PathUtils
.
tempDir
)
;
class
FakeBackupResource1
extends
BackupResource
{
static
get
key
(
)
{
return
"
fake1
"
;
}
static
get
requiresEncryption
(
)
{
return
false
;
}
}
class
FakeBackupResource2
extends
BackupResource
{
static
get
key
(
)
{
return
"
fake2
"
;
}
static
get
requiresEncryption
(
)
{
return
false
;
}
static
get
priority
(
)
{
return
1
;
}
}
class
FakeBackupResource3
extends
BackupResource
{
static
get
key
(
)
{
return
"
fake3
"
;
}
static
get
requiresEncryption
(
)
{
return
false
;
}
static
get
priority
(
)
{
return
2
;
}
}
async
function
createKilobyteSizedFile
(
path
sizeInKB
)
{
let
bytes
=
new
Uint8Array
(
sizeInKB
*
BYTES_IN_KB
)
;
await
IOUtils
.
write
(
path
bytes
)
;
}
async
function
createTestFiles
(
parentPath
testFilesArray
)
{
for
(
let
{
path
sizeInKB
}
of
testFilesArray
)
{
if
(
Array
.
isArray
(
path
)
)
{
let
folders
=
path
.
slice
(
0
-
1
)
;
await
IOUtils
.
getDirectory
(
PathUtils
.
join
(
parentPath
.
.
.
folders
)
)
;
}
if
(
sizeInKB
=
=
=
undefined
)
{
sizeInKB
=
10
;
}
let
filePath
=
PathUtils
.
join
(
parentPath
.
.
.
[
]
.
concat
(
path
)
)
;
await
createKilobyteSizedFile
(
filePath
sizeInKB
)
;
}
}
async
function
assertFilesExist
(
parentPath
testFilesArray
)
{
for
(
let
{
path
}
of
testFilesArray
)
{
let
copiedFileName
=
PathUtils
.
join
(
parentPath
.
.
.
[
]
.
concat
(
path
)
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
copiedFileName
)
{
copiedFileName
}
should
exist
in
the
staging
folder
)
;
}
}
async
function
maybeRemovePath
(
path
)
{
try
{
await
IOUtils
.
remove
(
path
{
ignoreAbsent
:
true
recursive
:
true
}
)
;
}
catch
(
error
)
{
if
(
error
.
name
!
=
"
NS_ERROR_FILE_IS_LOCKED
"
)
{
console
.
error
(
error
)
;
}
}
}
function
*
seededRandomNumberGenerator
(
)
{
let
sfc32
=
function
(
a
b
c
d
)
{
return
function
(
)
{
a
|
=
0
;
b
|
=
0
;
c
|
=
0
;
d
|
=
0
;
var
t
=
(
(
(
a
+
b
)
|
0
)
+
d
)
|
0
;
d
=
(
d
+
1
)
|
0
;
a
=
b
^
(
b
>
>
>
9
)
;
b
=
(
c
+
(
c
<
<
3
)
)
|
0
;
c
=
(
c
<
<
21
)
|
(
c
>
>
>
11
)
;
c
=
(
c
+
t
)
|
0
;
return
(
t
>
>
>
0
)
/
4294967296
;
}
;
}
;
const
SEED1
=
123
;
const
SEED2
=
456
;
const
SEED3
=
789
;
const
SEED4
=
101
;
let
generator
=
sfc32
(
SEED1
SEED2
SEED3
SEED4
)
;
while
(
true
)
{
yield
Math
.
round
(
generator
(
)
*
1000
)
%
255
;
}
}
function
assertUint8ArraysSimilarity
(
uint8ArrayA
uint8ArrayB
expectSimilar
)
{
let
lengthToCheck
;
if
(
expectSimilar
)
{
Assert
.
equal
(
uint8ArrayA
.
byteLength
uint8ArrayB
.
byteLength
"
Uint8Arrays
have
the
same
byteLength
"
)
;
lengthToCheck
=
uint8ArrayA
.
byteLength
;
}
else
{
Assert
.
notEqual
(
uint8ArrayA
.
byteLength
uint8ArrayB
.
byteLength
"
Uint8Arrays
have
differing
byteLength
"
)
;
lengthToCheck
=
Math
.
min
(
uint8ArrayA
.
byteLength
uint8ArrayB
.
byteLength
)
;
}
let
foundDifference
=
false
;
for
(
let
i
=
0
;
i
<
lengthToCheck
;
+
+
i
)
{
if
(
uint8ArrayA
[
i
]
!
=
uint8ArrayB
[
i
]
)
{
foundDifference
=
true
;
break
;
}
}
if
(
expectSimilar
)
{
Assert
.
ok
(
!
foundDifference
"
Arrays
contain
the
same
bytes
.
"
)
;
}
else
{
Assert
.
ok
(
foundDifference
"
Arrays
contain
different
bytes
.
"
)
;
}
}
function
countHistogramMeasurements
(
histogram
)
{
const
snapshot
=
histogram
.
snapshot
(
)
;
const
countsPerBucket
=
Object
.
values
(
snapshot
.
values
)
;
return
countsPerBucket
.
reduce
(
(
sum
count
)
=
>
sum
+
count
0
)
;
}
function
setupProfile
(
)
{
Services
.
fog
.
initializeFOG
(
)
;
let
gProfD
=
do_get_profile
(
)
;
let
gDataHome
=
gProfD
.
clone
(
)
;
gDataHome
.
append
(
"
data
"
)
;
gDataHome
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
let
gDataHomeLocal
=
gProfD
.
clone
(
)
;
gDataHomeLocal
.
append
(
"
local
"
)
;
gDataHomeLocal
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
let
xreDirProvider
=
Cc
[
"
mozilla
.
org
/
xre
/
directory
-
provider
;
1
"
]
.
getService
(
Ci
.
nsIXREDirProvider
)
;
xreDirProvider
.
setUserDataDirectory
(
gDataHome
false
)
;
xreDirProvider
.
setUserDataDirectory
(
gDataHomeLocal
true
)
;
let
profileSvc
=
Cc
[
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
]
.
getService
(
Ci
.
nsIToolkitProfileService
)
;
let
createdProfile
=
{
}
;
let
didCreate
=
profileSvc
.
selectStartupProfile
(
[
"
xpcshell
"
]
false
AppConstants
.
UPDATE_CHANNEL
"
"
{
}
{
}
createdProfile
)
;
Assert
.
ok
(
didCreate
"
Created
a
testing
profile
and
set
it
to
current
.
"
)
;
Assert
.
equal
(
profileSvc
.
currentProfile
createdProfile
.
value
"
Profile
set
to
current
"
)
;
return
createdProfile
.
value
;
}
function
assertHistogramMeasurementQuantity
(
histogram
expected
message
=
"
Should
have
taken
a
specific
number
of
measurements
in
the
histogram
"
)
{
const
totalCount
=
countHistogramMeasurements
(
histogram
)
;
Assert
.
equal
(
totalCount
expected
message
)
;
}
function
assertSingleTimeMeasurement
(
timerTestValue
)
{
Assert
.
notEqual
(
timerTestValue
null
"
Timer
should
have
something
recorded
"
)
;
Assert
.
equal
(
timerTestValue
.
count
1
"
Timer
should
have
a
single
measurement
"
)
;
Assert
.
greater
(
timerTestValue
.
sum
0
"
Timer
measurement
should
be
non
-
zero
"
)
;
}
