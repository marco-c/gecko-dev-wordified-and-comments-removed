"
use
strict
"
;
add_task
(
async
function
test_createArchive_unencrypted
(
)
{
let
bs
=
new
BackupService
(
)
;
let
testProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testCreateArchive
"
)
;
let
fakeMetadata
=
{
testKey
:
"
test
value
"
}
;
let
archiveTemplateFile
=
do_get_file
(
"
data
/
test_archive
.
template
.
html
"
)
;
let
archiveTemplateURI
=
Services
.
io
.
newFileURI
(
archiveTemplateFile
)
.
spec
;
const
FAKE_COMPRESSED_STAGING_PATH
=
PathUtils
.
join
(
testProfilePath
"
fake
-
compressed
-
staging
.
zip
"
)
;
const
SIZE_IN_BYTES
=
1525231
;
let
fakeBytes
=
new
Uint8Array
(
SIZE_IN_BYTES
)
;
let
gen
=
seededRandomNumberGenerator
(
)
;
for
(
let
i
=
0
;
i
<
SIZE_IN_BYTES
;
+
+
i
)
{
fakeBytes
.
set
(
[
gen
.
next
(
)
.
value
%
255
]
i
)
;
}
await
IOUtils
.
write
(
FAKE_COMPRESSED_STAGING_PATH
fakeBytes
)
;
const
FAKE_ARCHIVE_PATH
=
PathUtils
.
join
(
testProfilePath
"
fake
-
archive
.
html
"
)
;
await
bs
.
createArchive
(
FAKE_ARCHIVE_PATH
archiveTemplateURI
FAKE_COMPRESSED_STAGING_PATH
null
fakeMetadata
)
;
const
EXTRACTION_PATH
=
PathUtils
.
join
(
testProfilePath
"
extraction
.
bin
"
)
;
await
bs
.
extractCompressedSnapshotFromArchive
(
FAKE_ARCHIVE_PATH
EXTRACTION_PATH
)
;
Assert
.
equal
(
(
await
IOUtils
.
stat
(
EXTRACTION_PATH
)
)
.
size
SIZE_IN_BYTES
)
;
let
writtenBytes
=
await
IOUtils
.
read
(
EXTRACTION_PATH
)
;
let
matches
=
true
;
for
(
let
i
=
0
;
i
<
writtenBytes
.
byteLength
;
+
+
i
)
{
if
(
writtenBytes
[
i
]
!
=
=
fakeBytes
[
i
]
)
{
Assert
.
ok
(
false
"
Byte
at
index
"
+
i
+
"
did
not
match
.
"
)
;
matches
=
false
;
}
}
Assert
.
ok
(
matches
"
All
bytes
matched
after
extraction
.
"
)
;
await
IOUtils
.
remove
(
testProfilePath
{
recursive
:
true
}
)
;
}
)
;
