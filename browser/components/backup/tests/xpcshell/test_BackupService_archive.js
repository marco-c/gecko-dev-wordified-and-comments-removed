"
use
strict
"
;
const
{
ArchiveEncryptionState
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
ArchiveEncryptionState
.
sys
.
mjs
"
)
;
const
{
OSKeyStoreTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
OSKeyStoreTestUtils
.
sys
.
mjs
"
)
;
let
testProfilePath
;
let
fakeCompressedStagingPath
;
let
archiveTemplateFile
=
do_get_file
(
"
data
/
test_archive
.
template
.
html
"
)
;
let
archiveTemplateURI
=
Services
.
io
.
newFileURI
(
archiveTemplateFile
)
.
spec
;
const
SIZE_IN_BYTES
=
125123
;
let
fakeBytes
;
async
function
assertExtractionsMatch
(
extractionPath
)
{
let
writtenBytes
=
await
IOUtils
.
read
(
extractionPath
)
;
assertUint8ArraysSimilarity
(
writtenBytes
fakeBytes
true
)
;
}
add_setup
(
async
(
)
=
>
{
testProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testCreateArchive
"
)
;
fakeCompressedStagingPath
=
PathUtils
.
join
(
testProfilePath
"
fake
-
compressed
-
staging
.
zip
"
)
;
fakeBytes
=
new
Uint8Array
(
SIZE_IN_BYTES
)
;
let
gen
=
seededRandomNumberGenerator
(
)
;
for
(
let
i
=
0
;
i
<
SIZE_IN_BYTES
;
+
+
i
)
{
fakeBytes
.
set
(
gen
.
next
(
)
.
value
i
)
;
}
await
IOUtils
.
write
(
fakeCompressedStagingPath
fakeBytes
)
;
OSKeyStoreTestUtils
.
setup
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
OSKeyStoreTestUtils
.
cleanup
(
)
;
await
IOUtils
.
remove
(
testProfilePath
{
recursive
:
true
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_createArchive_unencrypted
(
)
{
let
bs
=
new
BackupService
(
)
;
const
FAKE_ARCHIVE_PATH
=
PathUtils
.
join
(
testProfilePath
"
fake
-
unencrypted
-
archive
.
html
"
)
;
await
bs
.
createArchive
(
FAKE_ARCHIVE_PATH
archiveTemplateURI
fakeCompressedStagingPath
null
FAKE_METADATA
)
;
let
{
isEncrypted
archiveJSON
}
=
await
bs
.
sampleArchive
(
FAKE_ARCHIVE_PATH
)
;
Assert
.
ok
(
!
isEncrypted
"
Should
not
be
considered
encrypted
.
"
)
;
Assert
.
deepEqual
(
archiveJSON
.
meta
FAKE_METADATA
"
Metadata
was
encoded
in
the
archive
JSON
block
.
"
)
;
const
EXTRACTION_PATH
=
PathUtils
.
join
(
testProfilePath
"
extraction
.
bin
"
)
;
await
bs
.
extractCompressedSnapshotFromArchive
(
FAKE_ARCHIVE_PATH
EXTRACTION_PATH
)
;
assertExtractionsMatch
(
EXTRACTION_PATH
)
;
await
IOUtils
.
remove
(
FAKE_ARCHIVE_PATH
)
;
await
IOUtils
.
remove
(
EXTRACTION_PATH
)
;
}
)
;
add_task
(
async
function
test_createArchive_encrypted
(
)
{
const
TEST_RECOVERY_CODE
=
"
This
is
some
recovery
code
.
"
;
let
bs
=
new
BackupService
(
)
;
let
{
instance
:
encState
}
=
await
ArchiveEncryptionState
.
initialize
(
TEST_RECOVERY_CODE
)
;
const
FAKE_ARCHIVE_PATH
=
PathUtils
.
join
(
testProfilePath
"
fake
-
encrypted
-
archive
.
html
"
)
;
await
bs
.
createArchive
(
FAKE_ARCHIVE_PATH
archiveTemplateURI
fakeCompressedStagingPath
encState
FAKE_METADATA
)
;
let
{
isEncrypted
archiveJSON
}
=
await
bs
.
sampleArchive
(
FAKE_ARCHIVE_PATH
)
;
Assert
.
ok
(
isEncrypted
"
Should
be
considered
encrypted
.
"
)
;
Assert
.
deepEqual
(
archiveJSON
.
meta
FAKE_METADATA
"
Metadata
was
encoded
in
the
archive
JSON
block
.
"
)
;
const
EXTRACTION_PATH
=
PathUtils
.
join
(
testProfilePath
"
extraction
.
bin
"
)
;
await
Assert
.
rejects
(
bs
.
extractCompressedSnapshotFromArchive
(
FAKE_ARCHIVE_PATH
EXTRACTION_PATH
)
/
recovery
code
is
required
/
)
;
await
bs
.
extractCompressedSnapshotFromArchive
(
FAKE_ARCHIVE_PATH
EXTRACTION_PATH
TEST_RECOVERY_CODE
)
;
assertExtractionsMatch
(
EXTRACTION_PATH
)
;
await
IOUtils
.
remove
(
FAKE_ARCHIVE_PATH
)
;
await
IOUtils
.
remove
(
EXTRACTION_PATH
)
;
}
)
;
add_task
(
async
function
test_createArchive_multiple_of_six_test
(
)
{
let
bs
=
new
BackupService
(
)
;
const
FAKE_ARCHIVE_PATH
=
PathUtils
.
join
(
testProfilePath
"
fake
-
unencrypted
-
archive
.
html
"
)
;
const
FAKE_COMPRESSED_FILE
=
PathUtils
.
join
(
testProfilePath
"
fake
-
compressed
-
staging
.
zip
"
)
;
const
NOT_MULTIPLE_OF_SIX_OVERRIDE_CHUNK_SIZE
=
500
;
const
MULTIPLE_OF_SIX_SIZE_IN_BYTES
=
6
*
500
;
let
multipleOfSixBytes
=
new
Uint8Array
(
MULTIPLE_OF_SIX_SIZE_IN_BYTES
)
;
let
gen
=
seededRandomNumberGenerator
(
)
;
for
(
let
i
=
0
;
i
<
MULTIPLE_OF_SIX_SIZE_IN_BYTES
;
+
+
i
)
{
multipleOfSixBytes
.
set
(
gen
.
next
(
)
.
value
i
)
;
}
await
IOUtils
.
write
(
FAKE_COMPRESSED_FILE
multipleOfSixBytes
)
;
await
bs
.
createArchive
(
FAKE_ARCHIVE_PATH
archiveTemplateURI
FAKE_COMPRESSED_FILE
null
FAKE_METADATA
{
chunkSize
:
NOT_MULTIPLE_OF_SIX_OVERRIDE_CHUNK_SIZE
}
)
;
const
EXTRACTION_PATH
=
PathUtils
.
join
(
testProfilePath
"
extraction
.
bin
"
)
;
await
bs
.
extractCompressedSnapshotFromArchive
(
FAKE_ARCHIVE_PATH
EXTRACTION_PATH
)
;
let
writtenBytes
=
await
IOUtils
.
read
(
EXTRACTION_PATH
)
;
assertUint8ArraysSimilarity
(
writtenBytes
multipleOfSixBytes
true
)
;
await
IOUtils
.
remove
(
FAKE_COMPRESSED_FILE
)
;
await
IOUtils
.
remove
(
FAKE_ARCHIVE_PATH
)
;
await
IOUtils
.
remove
(
EXTRACTION_PATH
)
;
}
)
;
