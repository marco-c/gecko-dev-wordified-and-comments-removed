"
use
strict
"
;
const
{
MiscDataBackupResource
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
MiscDataBackupResource
.
sys
.
mjs
"
)
;
const
{
ASRouterStorage
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
asrouter
/
ASRouterStorage
.
sys
.
mjs
"
)
;
const
{
ProfileAge
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
sys
.
mjs
"
)
;
add_task
(
async
function
test_measure
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
const
EXPECTED_MISC_KILOBYTES_SIZE
=
231
;
const
tempDir
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
MiscDataBackupResource
-
measurement
-
test
"
)
;
const
mockFiles
=
[
{
path
:
"
enumerate_devices
.
txt
"
sizeInKB
:
1
}
{
path
:
"
protections
.
sqlite
"
sizeInKB
:
100
}
{
path
:
"
SiteSecurityServiceState
.
bin
"
sizeInKB
:
10
}
{
path
:
[
"
storage
"
"
permanent
"
"
chrome
"
"
123ABC
.
sqlite
"
]
sizeInKB
:
40
}
{
path
:
[
"
storage
"
"
permanent
"
"
chrome
"
"
456DEF
.
sqlite
"
]
sizeInKB
:
40
}
{
path
:
[
"
storage
"
"
permanent
"
"
chrome
"
"
mockIDBDir
"
"
890HIJ
.
sqlite
"
]
sizeInKB
:
40
}
]
;
await
createTestFiles
(
tempDir
mockFiles
)
;
let
miscDataBackupResource
=
new
MiscDataBackupResource
(
)
;
await
miscDataBackupResource
.
measure
(
tempDir
)
;
let
measurement
=
Glean
.
browserBackup
.
miscDataSize
.
testGetValue
(
)
;
let
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
false
false
)
;
TelemetryTestUtils
.
assertScalar
(
scalars
"
browser
.
backup
.
misc_data_size
"
measurement
"
Glean
and
telemetry
measurements
for
misc
data
should
be
equal
"
)
;
Assert
.
equal
(
measurement
EXPECTED_MISC_KILOBYTES_SIZE
"
Should
have
collected
the
correct
glean
measurement
for
misc
files
"
)
;
await
maybeRemovePath
(
tempDir
)
;
}
)
;
add_task
(
async
function
test_backup
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
miscDataBackupResource
=
new
MiscDataBackupResource
(
)
;
let
sourcePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
MiscDataBackupResource
-
source
-
test
"
)
;
let
stagingPath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
MiscDataBackupResource
-
staging
-
test
"
)
;
const
simpleCopyFiles
=
[
{
path
:
"
enumerate_devices
.
txt
"
}
{
path
:
"
SiteSecurityServiceState
.
bin
"
}
]
;
await
createTestFiles
(
sourcePath
simpleCopyFiles
)
;
await
createTestFiles
(
sourcePath
[
{
path
:
"
protections
.
sqlite
"
}
]
)
;
let
fakeConnection
=
{
backup
:
sandbox
.
stub
(
)
.
resolves
(
true
)
close
:
sandbox
.
stub
(
)
.
resolves
(
true
)
}
;
sandbox
.
stub
(
Sqlite
"
openConnection
"
)
.
returns
(
fakeConnection
)
;
let
snippetsTableStub
=
{
getAllKeys
:
sandbox
.
stub
(
)
.
resolves
(
[
"
key1
"
"
key2
"
]
)
get
:
sandbox
.
stub
(
)
.
callsFake
(
key
=
>
{
return
{
key
:
value
for
{
key
}
}
;
}
)
}
;
sandbox
.
stub
(
ASRouterStorage
.
prototype
"
getDbTable
"
)
.
withArgs
(
"
snippets
"
)
.
resolves
(
snippetsTableStub
)
;
let
manifestEntry
=
await
miscDataBackupResource
.
backup
(
stagingPath
sourcePath
)
;
Assert
.
equal
(
manifestEntry
null
"
MiscDataBackupResource
.
backup
should
return
null
as
its
ManifestEntry
"
)
;
await
assertFilesExist
(
stagingPath
simpleCopyFiles
)
;
Assert
.
ok
(
fakeConnection
.
backup
.
calledOnce
"
Called
backup
the
expected
number
of
times
for
all
connections
"
)
;
Assert
.
ok
(
fakeConnection
.
backup
.
firstCall
.
calledWith
(
PathUtils
.
join
(
stagingPath
"
protections
.
sqlite
"
)
)
"
Called
backup
on
the
protections
.
sqlite
Sqlite
connection
"
)
;
let
snippetsBackupPath
=
PathUtils
.
join
(
stagingPath
"
activity
-
stream
-
snippets
.
json
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
snippetsBackupPath
)
"
The
activity
-
stream
-
snippets
.
json
file
should
exist
"
)
;
let
snippetsBackupContents
=
await
IOUtils
.
readJSON
(
snippetsBackupPath
)
;
Assert
.
deepEqual
(
snippetsBackupContents
{
key1
:
{
key
:
"
value
for
key1
"
}
key2
:
{
key
:
"
value
for
key2
"
}
}
"
The
contents
of
the
activity
-
stream
-
snippets
.
json
file
should
be
as
expected
"
)
;
await
maybeRemovePath
(
stagingPath
)
;
await
maybeRemovePath
(
sourcePath
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_recover
(
)
{
let
miscBackupResource
=
new
MiscDataBackupResource
(
)
;
let
recoveryPath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
MiscDataBackupResource
-
recovery
-
test
"
)
;
let
destProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
MiscDataBackupResource
-
test
-
profile
"
)
;
let
originalProfileAge
=
await
ProfileAge
(
PathUtils
.
profileDir
)
;
await
originalProfileAge
.
computeAndPersistCreated
(
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
PathUtils
.
join
(
PathUtils
.
profileDir
"
times
.
json
"
)
)
)
;
const
simpleCopyFiles
=
[
{
path
:
"
enumerate_devices
.
txt
"
}
{
path
:
"
protections
.
sqlite
"
}
{
path
:
"
SiteSecurityServiceState
.
bin
"
}
]
;
await
createTestFiles
(
recoveryPath
simpleCopyFiles
)
;
const
SNIPPETS_BACKUP_FILE
=
"
activity
-
stream
-
snippets
.
json
"
;
await
createTestFiles
(
recoveryPath
[
{
path
:
SNIPPETS_BACKUP_FILE
}
]
)
;
let
postRecoveryEntry
=
await
miscBackupResource
.
recover
(
null
recoveryPath
destProfilePath
)
;
Assert
.
deepEqual
(
postRecoveryEntry
{
snippetsBackupFile
:
PathUtils
.
join
(
recoveryPath
SNIPPETS_BACKUP_FILE
)
}
"
MiscDataBackupResource
.
recover
should
return
the
snippets
backup
data
"
+
"
path
as
its
post
recovery
entry
"
)
;
await
assertFilesExist
(
destProfilePath
simpleCopyFiles
)
;
Assert
.
ok
(
!
(
await
IOUtils
.
exists
(
PathUtils
.
join
(
destProfilePath
SNIPPETS_BACKUP_FILE
)
)
)
"
Snippets
backup
data
should
not
have
gone
into
the
profile
directory
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
PathUtils
.
join
(
destProfilePath
"
times
.
json
"
)
)
)
;
let
copiedProfileAge
=
await
ProfileAge
(
destProfilePath
)
;
Assert
.
equal
(
await
originalProfileAge
.
created
await
copiedProfileAge
.
created
"
Created
timestamp
should
match
.
"
)
;
Assert
.
equal
(
await
originalProfileAge
.
firstUse
await
copiedProfileAge
.
firstUse
"
First
use
timestamp
should
match
.
"
)
;
Assert
.
ok
(
await
copiedProfileAge
.
recoveredFromBackup
"
Backup
recovery
timestamp
should
have
been
set
.
"
)
;
await
maybeRemovePath
(
recoveryPath
)
;
await
maybeRemovePath
(
destProfilePath
)
;
}
)
;
add_task
(
async
function
test_postRecovery
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
fakeProfilePath
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
MiscDataBackupResource
-
test
-
profile
"
)
;
let
fakeSnippetsData
=
{
key1
:
"
value1
"
key2
:
"
value2
"
}
;
const
SNIPPEST_BACKUP_FILE
=
PathUtils
.
join
(
fakeProfilePath
"
activity
-
stream
-
snippets
.
json
"
)
;
await
IOUtils
.
writeJSON
(
SNIPPEST_BACKUP_FILE
fakeSnippetsData
)
;
let
snippetsTableStub
=
{
set
:
sandbox
.
stub
(
)
}
;
sandbox
.
stub
(
ASRouterStorage
.
prototype
"
getDbTable
"
)
.
withArgs
(
"
snippets
"
)
.
resolves
(
snippetsTableStub
)
;
let
miscBackupResource
=
new
MiscDataBackupResource
(
)
;
await
miscBackupResource
.
postRecovery
(
{
snippetsBackupFile
:
SNIPPEST_BACKUP_FILE
}
)
;
Assert
.
ok
(
snippetsTableStub
.
set
.
calledTwice
"
The
snippets
table
'
s
set
method
was
called
twice
"
)
;
Assert
.
ok
(
snippetsTableStub
.
set
.
firstCall
.
calledWith
(
"
key1
"
"
value1
"
)
"
The
snippets
table
'
s
set
method
was
called
with
the
first
key
-
value
pair
"
)
;
Assert
.
ok
(
snippetsTableStub
.
set
.
secondCall
.
calledWith
(
"
key2
"
"
value2
"
)
"
The
snippets
table
'
s
set
method
was
called
with
the
second
key
-
value
pair
"
)
;
sandbox
.
restore
(
)
;
}
)
;
