"
use
strict
"
;
const
{
ArchiveEncryptionState
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
ArchiveEncryptionState
.
sys
.
mjs
"
)
;
const
{
ArchiveEncryptor
ArchiveDecryptor
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
ArchiveEncryption
.
sys
.
mjs
"
)
;
const
{
ArchiveUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
backup
/
ArchiveUtils
.
sys
.
mjs
"
)
;
const
TEST_RECOVERY_CODE
=
"
This
is
my
recovery
code
.
"
;
const
FAKE_BYTES_AMOUNT
=
1000
;
let
fakeBytes
=
null
;
add_setup
(
async
(
)
=
>
{
fakeBytes
=
new
Uint8Array
(
FAKE_BYTES_AMOUNT
)
;
let
gen
=
seededRandomNumberGenerator
(
)
;
for
(
let
i
=
0
;
i
<
FAKE_BYTES_AMOUNT
;
+
+
i
)
{
fakeBytes
.
set
(
gen
.
next
(
)
.
value
i
)
;
}
}
)
;
add_task
(
async
function
test_ArchiveEncryptor_initializer
(
)
{
let
{
instance
:
encState
}
=
await
ArchiveEncryptionState
.
initialize
(
TEST_RECOVERY_CODE
)
;
let
encryptor
=
await
ArchiveEncryptor
.
initialize
(
encState
.
publicKey
encState
.
backupAuthKey
)
;
Assert
.
ok
(
encryptor
"
An
ArchiveEncryptor
was
successfully
constructed
"
)
;
}
)
;
add_task
(
async
function
test_ArchiveEncryption_single_chunk
(
)
{
let
{
instance
:
encState
}
=
await
ArchiveEncryptionState
.
initialize
(
TEST_RECOVERY_CODE
)
;
let
encryptor
=
await
ArchiveEncryptor
.
initialize
(
encState
.
publicKey
encState
.
backupAuthKey
)
;
const
TEST_METADATA
=
{
test
:
"
hello
!
"
}
;
let
jsonBlock
=
await
encryptor
.
confirm
(
TEST_METADATA
encState
.
wrappedSecrets
encState
.
salt
encState
.
nonce
)
;
jsonBlock
=
JSON
.
parse
(
JSON
.
stringify
(
jsonBlock
)
)
;
let
encryptedBytes
=
await
encryptor
.
encrypt
(
fakeBytes
true
)
;
Assert
.
greater
(
encryptedBytes
.
byteLength
fakeBytes
.
byteLength
"
Encrypted
bytes
should
be
larger
"
)
;
assertUint8ArraysSimilarity
(
encryptedBytes
fakeBytes
false
)
;
let
decryptor
=
await
ArchiveDecryptor
.
initialize
(
TEST_RECOVERY_CODE
jsonBlock
)
;
Assert
.
ok
(
decryptor
"
Got
back
an
initialized
ArchiveDecryptor
"
)
;
let
decryptedBytes
=
await
decryptor
.
decrypt
(
encryptedBytes
true
)
;
Assert
.
equal
(
decryptedBytes
.
byteLength
fakeBytes
.
byteLength
"
Decrypted
bytes
should
have
original
length
"
)
;
assertUint8ArraysSimilarity
(
decryptedBytes
fakeBytes
true
)
;
}
)
;
add_task
(
async
function
test_ArchiveEncryption_uneven_chunks
(
)
{
let
{
instance
:
encState
}
=
await
ArchiveEncryptionState
.
initialize
(
TEST_RECOVERY_CODE
)
;
let
encryptor
=
await
ArchiveEncryptor
.
initialize
(
encState
.
publicKey
encState
.
backupAuthKey
)
;
const
TEST_METADATA
=
{
test
:
"
hello
!
"
}
;
let
jsonBlock
=
await
encryptor
.
confirm
(
TEST_METADATA
encState
.
wrappedSecrets
encState
.
salt
encState
.
nonce
)
;
jsonBlock
=
JSON
.
parse
(
JSON
.
stringify
(
jsonBlock
)
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
ArchiveUtils
"
ARCHIVE_CHUNK_MAX_BYTES_SIZE
"
)
.
get
(
(
)
=
>
{
return
333
;
}
)
;
let
firstChunk
=
fakeBytes
.
subarray
(
0
333
)
;
Assert
.
equal
(
firstChunk
.
byteLength
333
)
;
let
secondChunk
=
fakeBytes
.
subarray
(
333
666
)
;
Assert
.
equal
(
secondChunk
.
byteLength
333
)
;
let
thirdChunk
=
fakeBytes
.
subarray
(
667
999
)
;
Assert
.
equal
(
thirdChunk
.
byteLength
332
)
;
let
encryptedFirstChunk
=
await
encryptor
.
encrypt
(
firstChunk
)
;
let
encryptedSecondChunk
=
await
encryptor
.
encrypt
(
secondChunk
)
;
let
encryptedThirdChunk
=
await
encryptor
.
encrypt
(
thirdChunk
true
)
;
let
encryptedPairsToCompare
=
[
[
firstChunk
encryptedFirstChunk
]
[
secondChunk
encryptedSecondChunk
]
[
thirdChunk
encryptedThirdChunk
]
]
;
for
(
let
[
chunk
encryptedChunk
]
of
encryptedPairsToCompare
)
{
assertUint8ArraysSimilarity
(
chunk
encryptedChunk
false
)
;
}
let
decryptor
=
await
ArchiveDecryptor
.
initialize
(
TEST_RECOVERY_CODE
jsonBlock
)
;
Assert
.
ok
(
decryptor
"
Got
back
an
initialized
ArchiveDecryptor
"
)
;
let
decryptedFirstChunk
=
await
decryptor
.
decrypt
(
encryptedFirstChunk
)
;
let
decryptedSecondChunk
=
await
decryptor
.
decrypt
(
encryptedSecondChunk
)
;
let
decryptedThirdChunk
=
await
decryptor
.
decrypt
(
encryptedThirdChunk
true
)
;
let
decryptedPairsToCompare
=
[
[
firstChunk
decryptedFirstChunk
]
[
secondChunk
decryptedSecondChunk
]
[
thirdChunk
decryptedThirdChunk
]
]
;
for
(
let
[
chunk
decryptedChunk
]
of
decryptedPairsToCompare
)
{
Assert
.
equal
(
chunk
.
byteLength
decryptedChunk
.
byteLength
"
Decrypted
bytes
should
have
original
length
"
)
;
assertUint8ArraysSimilarity
(
chunk
decryptedChunk
true
)
;
}
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_ArchiveEncryption_even_chunks
(
)
{
let
{
instance
:
encState
}
=
await
ArchiveEncryptionState
.
initialize
(
TEST_RECOVERY_CODE
)
;
let
encryptor
=
await
ArchiveEncryptor
.
initialize
(
encState
.
publicKey
encState
.
backupAuthKey
)
;
const
TEST_METADATA
=
{
test
:
"
hello
!
"
}
;
let
jsonBlock
=
await
encryptor
.
confirm
(
TEST_METADATA
encState
.
wrappedSecrets
encState
.
salt
encState
.
nonce
)
;
jsonBlock
=
JSON
.
parse
(
JSON
.
stringify
(
jsonBlock
)
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
ArchiveUtils
"
ARCHIVE_CHUNK_MAX_BYTES_SIZE
"
)
.
get
(
(
)
=
>
{
return
500
;
}
)
;
let
firstChunk
=
fakeBytes
.
subarray
(
0
500
)
;
Assert
.
equal
(
firstChunk
.
byteLength
500
)
;
let
secondChunk
=
fakeBytes
.
subarray
(
500
)
;
Assert
.
equal
(
secondChunk
.
byteLength
500
)
;
let
encryptedFirstChunk
=
await
encryptor
.
encrypt
(
firstChunk
)
;
let
encryptedSecondChunk
=
await
encryptor
.
encrypt
(
secondChunk
true
)
;
let
encryptedPairsToCompare
=
[
[
firstChunk
encryptedFirstChunk
]
[
secondChunk
encryptedSecondChunk
]
]
;
for
(
let
[
chunk
encryptedChunk
]
of
encryptedPairsToCompare
)
{
assertUint8ArraysSimilarity
(
chunk
encryptedChunk
false
)
;
}
let
decryptor
=
await
ArchiveDecryptor
.
initialize
(
TEST_RECOVERY_CODE
jsonBlock
)
;
Assert
.
ok
(
decryptor
"
Got
back
an
initialized
ArchiveDecryptor
"
)
;
let
decryptedFirstChunk
=
await
decryptor
.
decrypt
(
encryptedFirstChunk
)
;
let
decryptedSecondChunk
=
await
decryptor
.
decrypt
(
encryptedSecondChunk
true
)
;
let
decryptedPairsToCompare
=
[
[
firstChunk
decryptedFirstChunk
]
[
secondChunk
decryptedSecondChunk
]
]
;
for
(
let
[
chunk
decryptedChunk
]
of
decryptedPairsToCompare
)
{
Assert
.
equal
(
chunk
.
byteLength
decryptedChunk
.
byteLength
"
Decrypted
bytes
should
have
original
length
"
)
;
assertUint8ArraysSimilarity
(
chunk
decryptedChunk
true
)
;
}
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_ArchiveEncryption_wrong_recoveryCode
(
)
{
let
{
instance
:
encState
}
=
await
ArchiveEncryptionState
.
initialize
(
TEST_RECOVERY_CODE
)
;
let
encryptor
=
await
ArchiveEncryptor
.
initialize
(
encState
.
publicKey
encState
.
backupAuthKey
)
;
const
TEST_METADATA
=
{
test
:
"
hello
!
"
}
;
let
jsonBlock
=
await
encryptor
.
confirm
(
TEST_METADATA
encState
.
wrappedSecrets
encState
.
salt
encState
.
nonce
)
;
await
encryptor
.
encrypt
(
fakeBytes
true
)
;
await
Assert
.
rejects
(
ArchiveDecryptor
.
initialize
(
"
Wrong
recovery
code
"
jsonBlock
)
/
Unauthenticated
/
)
;
}
)
;
