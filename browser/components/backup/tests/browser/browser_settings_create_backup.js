"
use
strict
"
;
let
TEST_PROFILE_PATH
;
const
SCHEDULED_BACKUPS_ENABLED_PREF
=
"
browser
.
backup
.
scheduled
.
enabled
"
;
const
BACKUP_DEFAULT_LOCATION_PREF
=
"
browser
.
backup
.
location
"
;
add_setup
(
async
(
)
=
>
{
TEST_PROFILE_PATH
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testBackup
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
BACKUP_DEFAULT_LOCATION_PREF
TEST_PROFILE_PATH
]
[
SCHEDULED_BACKUPS_ENABLED_PREF
true
]
]
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
IOUtils
.
remove
(
TEST_PROFILE_PATH
{
recursive
:
true
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_create_new_backup_trigger
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
"
async
browser
=
>
{
let
settings
=
browser
.
contentDocument
.
querySelector
(
"
backup
-
settings
"
)
;
let
bs
=
BackupService
.
get
(
)
;
Assert
.
ok
(
!
bs
.
state
.
backupInProgress
"
There
is
no
backup
in
progress
"
)
;
Assert
.
ok
(
!
settings
.
triggerBackupButtonEl
.
disabled
"
No
backup
in
progress
and
backup
'
s
enabled
should
mean
that
we
can
Backup
Now
"
)
;
let
stateUpdated
=
BrowserTestUtils
.
waitForEvent
(
bs
"
BackupService
:
StateUpdate
"
false
(
)
=
>
{
return
bs
.
state
.
backupInProgress
;
}
)
;
settings
.
triggerBackupButtonEl
.
click
(
)
;
await
stateUpdated
;
await
settings
.
updateComplete
;
Assert
.
ok
(
settings
.
triggerBackupButtonEl
.
disabled
"
A
backup
is
in
progress
"
)
;
await
BrowserTestUtils
.
waitForEvent
(
bs
"
BackupService
:
StateUpdate
"
false
(
)
=
>
{
return
!
bs
.
state
.
backupInProgress
;
}
)
;
await
settings
.
updateComplete
;
Assert
.
ok
(
!
settings
.
triggerBackupButtonEl
.
disabled
"
A
backup
is
complete
"
)
;
let
fileName
=
JSON
.
parse
(
settings
.
lastBackupFileNameEl
.
getAttribute
(
"
data
-
l10n
-
args
"
)
)
.
fileName
;
Assert
.
ok
(
fileName
"
the
archive
was
created
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_create_backup_trigger_disabled
(
)
{
let
bs
=
BackupService
.
get
(
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
UNBLOCK_TOPIC
=
"
backup
-
test
-
allow
-
create
"
;
const
origResolveDest
=
bs
.
resolveArchiveDestFolderPath
.
bind
(
bs
)
;
sandbox
.
stub
(
bs
"
resolveArchiveDestFolderPath
"
)
.
callsFake
(
async
(
.
.
.
args
)
=
>
{
await
TestUtils
.
topicObserved
(
UNBLOCK_TOPIC
)
;
return
origResolveDest
(
.
.
.
args
)
;
}
)
;
let
backupPromise
=
bs
.
createBackup
(
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
"
async
browser
=
>
{
let
settings
=
browser
.
contentDocument
.
querySelector
(
"
backup
-
settings
"
)
;
Assert
.
ok
(
settings
.
triggerBackupButtonEl
.
disabled
"
A
backup
is
in
progress
"
)
;
let
stateUpdated
=
BrowserTestUtils
.
waitForEvent
(
bs
"
BackupService
:
StateUpdate
"
false
(
)
=
>
{
return
!
bs
.
state
.
backupInProgress
;
}
)
;
Services
.
obs
.
notifyObservers
(
null
UNBLOCK_TOPIC
)
;
let
result
=
await
backupPromise
;
ok
(
result
Backup
completed
and
returned
result
{
result
.
archivePath
}
)
;
await
stateUpdated
;
await
settings
.
updateComplete
;
Assert
.
ok
(
!
settings
.
triggerBackupButtonEl
.
disabled
"
No
backup
in
progress
we
can
trigger
a
new
one
"
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
