"
use
strict
"
;
const
SCHEDULED_BACKUPS_ENABLED_PREF
=
"
browser
.
backup
.
scheduled
.
enabled
"
;
add_task
(
async
function
password_validation
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
"
async
browser
=
>
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
settings
=
browser
.
contentDocument
.
querySelector
(
"
backup
-
settings
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SCHEDULED_BACKUPS_ENABLED_PREF
true
]
]
}
)
;
settings
.
backupServiceState
.
encryptionEnabled
=
true
;
await
settings
.
requestUpdate
(
)
;
await
settings
.
updateComplete
;
let
changePasswordButton
=
settings
.
changePasswordButtonEl
;
Assert
.
ok
(
changePasswordButton
"
Change
password
button
should
be
found
"
)
;
changePasswordButton
.
click
(
)
;
await
settings
.
updateComplete
;
let
enableBackupEncryption
=
settings
.
enableBackupEncryptionEl
;
let
passwordInputs
=
enableBackupEncryption
.
passwordInputsEl
;
Assert
.
ok
(
passwordInputs
"
password
-
validation
-
inputs
should
be
found
"
)
;
let
passwordRules
=
passwordInputs
.
passwordRulesEl
;
Assert
.
ok
(
passwordRules
"
Password
rules
tooltip
should
be
found
"
)
;
let
visiblePromise
=
BrowserTestUtils
.
waitForMutationCondition
(
passwordRules
{
attributes
:
true
childList
:
true
}
(
)
=
>
BrowserTestUtils
.
isVisible
(
passwordRules
)
)
;
let
newPasswordInput
=
passwordInputs
.
inputNewPasswordEl
;
newPasswordInput
.
focus
(
)
;
await
visiblePromise
;
Assert
.
ok
(
true
"
Password
rules
tooltip
should
be
visible
"
)
;
await
createMockPassInputEventPromise
(
newPasswordInput
"
"
)
;
await
passwordInputs
.
updateComplete
;
Assert
.
ok
(
passwordInputs
.
_tooShort
"
Too
short
password
rule
was
detected
because
of
an
empty
string
"
)
;
Assert
.
ok
(
!
passwordInputs
.
_passwordsValid
"
Passwords
are
considered
invalid
"
)
;
let
validityStub
=
sandbox
.
stub
(
newPasswordInput
"
validity
"
)
.
get
(
(
)
=
>
{
return
{
tooShort
:
true
valid
:
false
}
;
}
)
;
await
passwordInputs
.
updateComplete
;
Assert
.
ok
(
passwordInputs
.
_tooShort
"
Too
short
password
rule
was
detected
because
of
ValidityState
.
tooShort
"
)
;
Assert
.
ok
(
!
passwordInputs
.
_passwordsValid
"
Passwords
are
still
considered
invalid
"
)
;
validityStub
.
restore
(
)
;
const
mockEmail
=
"
email
example
.
com
"
;
await
createMockPassInputEventPromise
(
newPasswordInput
mockEmail
)
;
await
passwordInputs
.
updateComplete
;
Assert
.
ok
(
!
passwordInputs
.
_tooShort
"
Too
short
rule
is
no
longer
detected
"
)
;
Assert
.
ok
(
passwordInputs
.
_hasEmail
"
Has
email
rule
was
detected
"
)
;
Assert
.
ok
(
!
passwordInputs
.
_passwordsValid
"
Passwords
are
still
considered
invalid
"
)
;
const
noMatchPass
=
{
MOCK_PASSWORD
}
-
notMatch
;
await
createMockPassInputEventPromise
(
newPasswordInput
MOCK_PASSWORD
)
;
let
repeatPasswordInput
=
passwordInputs
.
inputRepeatPasswordEl
;
await
createMockPassInputEventPromise
(
repeatPasswordInput
noMatchPass
)
;
await
passwordInputs
.
updateComplete
;
Assert
.
ok
(
!
passwordInputs
.
_hasEmail
"
Has
email
rule
is
no
longer
detected
"
)
;
Assert
.
ok
(
!
passwordInputs
.
_passwordsMatch
"
Passwords
do
not
match
"
)
;
Assert
.
ok
(
!
passwordInputs
.
_passwordsValid
"
Passwords
are
still
considered
invalid
"
)
;
await
createMockPassInputEventPromise
(
repeatPasswordInput
MOCK_PASSWORD
)
;
await
passwordInputs
.
updateComplete
;
Assert
.
ok
(
passwordInputs
.
_passwordsMatch
"
Passwords
now
match
"
)
;
Assert
.
ok
(
passwordInputs
.
_passwordsValid
"
Passwords
are
now
considered
valid
"
)
;
let
classChangePromise
=
BrowserTestUtils
.
waitForMutationCondition
(
passwordRules
{
attributes
:
true
attributesFilter
:
[
"
class
"
]
}
(
)
=
>
passwordRules
.
classList
.
contains
(
"
hidden
"
)
)
;
let
hiddenPromise
=
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
BrowserTestUtils
.
isHidden
(
passwordRules
)
;
}
)
;
newPasswordInput
.
blur
(
)
;
await
passwordInputs
.
updateComplete
;
await
classChangePromise
;
await
hiddenPromise
;
Assert
.
ok
(
true
"
Password
rules
tooltip
should
be
hidden
"
)
;
sandbox
.
restore
(
)
;
}
)
;
}
)
;
