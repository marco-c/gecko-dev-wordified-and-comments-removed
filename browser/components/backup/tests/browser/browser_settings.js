"
use
strict
"
;
const
{
MockRegistrar
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
)
;
const
SCHEDULED_BACKUPS_ENABLED_PREF
=
"
browser
.
backup
.
scheduled
.
enabled
"
;
const
BACKUP_ARCHIVE_ENABLED_PREF
=
"
browser
.
backup
.
archive
.
enabled
"
;
const
BACKUP_RESTORE_ENABLED_PREF
=
"
browser
.
backup
.
restore
.
enabled
"
;
add_setup
(
async
(
)
=
>
{
MockFilePicker
.
init
(
window
.
browsingContext
)
;
registerCleanupFunction
(
(
)
=
>
{
MockFilePicker
.
cleanup
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_preferences_visibility
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
#
sync
"
async
browser
=
>
{
let
backupSection
=
browser
.
contentDocument
.
querySelector
(
"
#
dataBackupGroup
"
)
;
Assert
.
ok
(
backupSection
"
Found
backup
preferences
section
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
backupSection
)
"
Backup
section
is
visible
"
)
;
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
BACKUP_ARCHIVE_ENABLED_PREF
false
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
#
sync
"
async
browser
=
>
{
let
backupSection
=
browser
.
contentDocument
.
querySelector
(
"
#
dataBackupGroup
"
)
;
Assert
.
ok
(
backupSection
"
Found
backup
preferences
section
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
backupSection
)
"
Backup
section
is
still
visible
"
)
;
let
settings
=
browser
.
contentDocument
.
querySelector
(
"
backup
-
settings
"
)
;
let
backupArchiveSection
=
settings
.
querySelector
(
"
#
scheduled
-
backups
"
)
;
Assert
.
ok
(
!
backupArchiveSection
"
Backup
archive
section
is
not
available
"
)
;
Assert
.
ok
(
settings
.
restoreFromBackupEl
"
Backup
restore
section
is
available
"
)
;
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
BACKUP_RESTORE_ENABLED_PREF
false
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
#
sync
"
async
browser
=
>
{
let
settings
=
browser
.
contentDocument
.
querySelector
(
"
backup
-
settings
"
)
;
Assert
.
ok
(
!
settings
.
restoreFromBackupEl
"
Backup
Restore
section
is
not
available
"
)
;
let
backupSection
=
browser
.
contentDocument
.
querySelector
(
"
#
dataBackupGroup
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
backupSection
)
"
Backup
section
is
now
hidden
"
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_disable_backup_encryption_confirm
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
#
sync
"
async
browser
=
>
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
disableEncryptionStub
=
sandbox
.
stub
(
BackupService
.
prototype
"
disableEncryption
"
)
.
resolves
(
true
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
BACKUP_RESTORE_ENABLED_PREF
)
"
Restore
pref
is
back
to
true
"
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
BACKUP_ARCHIVE_ENABLED_PREF
)
"
Archive
pref
is
back
to
true
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SCHEDULED_BACKUPS_ENABLED_PREF
true
]
]
}
)
;
let
settings
=
browser
.
contentDocument
.
querySelector
(
"
backup
-
settings
"
)
;
settings
.
backupServiceState
.
encryptionEnabled
=
true
;
await
settings
.
requestUpdate
(
)
;
await
settings
.
updateComplete
;
let
sensitiveDataCheckbox
=
settings
.
sensitiveDataCheckboxInputEl
;
Assert
.
ok
(
sensitiveDataCheckbox
"
Sensitive
data
checkbox
should
be
found
"
)
;
Assert
.
ok
(
sensitiveDataCheckbox
.
checked
"
Sensitive
data
checkbox
should
be
checked
"
)
;
let
disableBackupEncryption
=
settings
.
disableBackupEncryptionEl
;
Assert
.
ok
(
disableBackupEncryption
"
disable
-
backup
-
encryption
should
be
found
"
)
;
let
confirmButton
=
disableBackupEncryption
.
confirmButtonEl
;
let
promise
=
BrowserTestUtils
.
waitForEvent
(
window
"
BackupUI
:
DisableEncryption
"
)
;
Assert
.
ok
(
confirmButton
"
Confirm
button
should
be
found
"
)
;
confirmButton
.
click
(
)
;
await
promise
;
await
settings
.
updateComplete
;
Assert
.
ok
(
disableEncryptionStub
.
calledOnce
"
BackupService
was
called
to
disable
encryption
"
)
;
let
legacyEvents
=
TelemetryTestUtils
.
getEvents
(
{
category
:
"
browser
.
backup
"
method
:
"
password_removed
"
object
:
"
BackupService
"
}
{
process
:
"
parent
"
}
)
;
Assert
.
equal
(
legacyEvents
.
length
1
"
Found
the
password_removed
legacy
event
.
"
)
;
let
events
=
Glean
.
browserBackup
.
passwordRemoved
.
testGetValue
(
)
;
Assert
.
equal
(
events
.
length
1
"
Found
the
passwordRemoved
Glean
event
.
"
)
;
sandbox
.
restore
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_restore_from_backup
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
#
sync
"
async
browser
=
>
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
recoverFromBackupArchiveStub
=
sandbox
.
stub
(
BackupService
.
prototype
"
recoverFromBackupArchive
"
)
.
resolves
(
)
;
const
mockBackupFilePath
=
await
IOUtils
.
createUniqueFile
(
PathUtils
.
tempDir
"
backup
.
html
"
)
;
const
mockBackupFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
mockBackupFile
.
initWithPath
(
mockBackupFilePath
)
;
let
filePickerShownPromise
=
new
Promise
(
resolve
=
>
{
MockFilePicker
.
showCallback
=
async
(
)
=
>
{
Assert
.
ok
(
true
"
Filepicker
shown
"
)
;
MockFilePicker
.
setFiles
(
[
mockBackupFile
]
)
;
resolve
(
)
;
}
;
}
)
;
MockFilePicker
.
returnValue
=
MockFilePicker
.
returnOK
;
let
settings
=
browser
.
contentDocument
.
querySelector
(
"
backup
-
settings
"
)
;
await
settings
.
updateComplete
;
Assert
.
ok
(
settings
.
restoreFromBackupButtonEl
"
Button
to
restore
backups
should
be
found
"
)
;
settings
.
restoreFromBackupButtonEl
.
click
(
)
;
await
settings
.
updateComplete
;
let
restoreFromBackup
=
settings
.
restoreFromBackupEl
;
Assert
.
ok
(
restoreFromBackup
"
restore
-
from
-
backup
should
be
found
"
)
;
let
infoPromise
=
BrowserTestUtils
.
waitForEvent
(
window
"
BackupUI
:
GetBackupFileInfo
"
)
;
restoreFromBackup
.
chooseButtonEl
.
click
(
)
;
await
filePickerShownPromise
;
restoreFromBackup
.
backupServiceState
=
{
.
.
.
restoreFromBackup
.
backupServiceState
backupFileToRestore
:
mockBackupFilePath
}
;
await
restoreFromBackup
.
updateComplete
;
restoreFromBackup
.
dispatchEvent
(
new
CustomEvent
(
"
BackupUI
:
SelectNewFilepickerPath
"
{
bubbles
:
true
composed
:
true
detail
:
{
path
:
mockBackupFilePath
filename
:
mockBackupFile
.
leafName
iconURL
:
"
"
}
}
)
)
;
await
infoPromise
;
restoreFromBackup
.
backupServiceState
=
{
.
.
.
restoreFromBackup
.
backupServiceState
backupFileInfo
:
{
date
:
new
Date
(
)
isEncrypted
:
true
}
}
;
await
restoreFromBackup
.
updateComplete
;
restoreFromBackup
.
passwordInput
.
value
=
"
h
-
*
Vfge3_hGxdpwqr
w
"
;
let
restorePromise
=
BrowserTestUtils
.
waitForEvent
(
window
"
BackupUI
:
RestoreFromBackupFile
"
)
;
Assert
.
ok
(
restoreFromBackup
.
confirmButtonEl
"
Confirm
button
should
be
found
"
)
;
Assert
.
ok
(
!
restoreFromBackup
.
confirmButtonEl
.
disabled
"
Confirm
button
should
not
be
disabled
"
)
;
await
restoreFromBackup
.
updateComplete
;
let
quitObservedPromise
=
TestUtils
.
topicObserved
(
"
quit
-
application
-
requested
"
subject
=
>
{
let
cancelQuit
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRBool
)
;
cancelQuit
.
data
=
true
;
return
true
;
}
)
;
restoreFromBackup
.
confirmButtonEl
.
click
(
)
;
await
restorePromise
.
then
(
e
=
>
{
let
mockEvent
=
{
backupFile
:
mockBackupFile
.
path
backupPassword
:
"
h
-
*
Vfge3_hGxdpwqr
w
"
}
;
Assert
.
deepEqual
(
e
.
detail
mockEvent
"
Event
should
contain
the
file
and
password
"
)
;
}
)
;
await
quitObservedPromise
;
Assert
.
ok
(
recoverFromBackupArchiveStub
.
calledOnce
"
BackupService
was
called
to
start
a
recovery
from
a
backup
archive
.
"
)
;
sandbox
.
restore
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_last_backup_info_and_location
(
)
{
const
TEST_PROFILE_PATH
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testLastBackupInfo
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SCHEDULED_BACKUPS_ENABLED_PREF
true
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
#
sync
"
async
browser
=
>
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
bs
=
BackupService
.
get
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
backup
.
location
"
TEST_PROFILE_PATH
]
]
}
)
;
Assert
.
ok
(
bs
.
state
.
backupDirPath
"
Backup
Dir
Path
was
set
"
)
;
let
settings
=
browser
.
contentDocument
.
querySelector
(
"
backup
-
settings
"
)
;
await
settings
.
updateComplete
;
let
stateUpdated
=
BrowserTestUtils
.
waitForEvent
(
bs
"
BackupService
:
StateUpdate
"
false
(
)
=
>
{
return
bs
.
state
.
lastBackupDate
&
&
bs
.
state
.
lastBackupFileName
;
}
)
;
let
{
archivePath
}
=
await
bs
.
createBackup
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
IOUtils
.
remove
(
archivePath
)
;
}
)
;
await
stateUpdated
;
await
settings
.
updateComplete
;
let
dateArgs
=
JSON
.
parse
(
settings
.
lastBackupDateEl
.
getAttribute
(
"
data
-
l10n
-
args
"
)
)
;
Assert
.
equal
(
dateArgs
.
date
bs
.
state
.
lastBackupDate
*
1000
"
Should
have
the
backup
date
as
a
Fluent
arg
in
milliseconds
"
)
;
let
locationArgs
=
JSON
.
parse
(
settings
.
lastBackupFileNameEl
.
getAttribute
(
"
data
-
l10n
-
args
"
)
)
;
Assert
.
equal
(
locationArgs
.
fileName
bs
.
state
.
lastBackupFileName
"
Should
have
the
backup
file
name
as
a
Fluent
arg
"
)
;
let
showBackupLocationPromise
=
new
Promise
(
resolve
=
>
{
let
showBackupLocationStub
=
sandbox
.
stub
(
bs
"
showBackupLocation
"
)
;
showBackupLocationStub
.
callsFake
(
(
)
=
>
{
resolve
(
)
;
}
)
;
}
)
;
settings
.
backupLocationShowButtonEl
.
click
(
)
;
await
showBackupLocationPromise
;
const
TEST_NEW_BACKUP_PARENT_PATH
=
await
IOUtils
.
createUniqueDirectory
(
PathUtils
.
tempDir
"
testNewBackupParent
"
)
;
let
newBackupParent
=
await
IOUtils
.
getDirectory
(
TEST_NEW_BACKUP_PARENT_PATH
)
;
stateUpdated
=
BrowserTestUtils
.
waitForEvent
(
bs
"
BackupService
:
StateUpdate
"
false
(
)
=
>
{
return
bs
.
state
.
backupDirPath
.
startsWith
(
TEST_NEW_BACKUP_PARENT_PATH
)
;
}
)
;
let
filePickerShownPromise
=
new
Promise
(
resolve
=
>
{
MockFilePicker
.
showCallback
=
async
(
)
=
>
{
Assert
.
ok
(
true
"
Filepicker
shown
"
)
;
MockFilePicker
.
setFiles
(
[
newBackupParent
]
)
;
resolve
(
)
;
}
;
}
)
;
MockFilePicker
.
returnValue
=
MockFilePicker
.
returnOK
;
settings
.
backupLocationEditButtonEl
.
click
(
)
;
await
filePickerShownPromise
;
await
stateUpdated
;
await
IOUtils
.
remove
(
TEST_NEW_BACKUP_PARENT_PATH
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
sandbox
.
restore
(
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
