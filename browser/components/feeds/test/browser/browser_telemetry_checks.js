"
use
strict
"
;
add_task
(
async
function
(
)
{
function
getSnapShot
(
)
{
return
Services
.
telemetry
.
snapshotScalars
(
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTOUT
false
)
;
}
const
TEST_PATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
com
"
)
;
const
FEED_URI
=
TEST_PATH
+
"
valid
-
feed
.
xml
"
;
Services
.
telemetry
.
clearScalars
(
)
;
const
kScalarPrefix
=
"
browser
.
feeds
.
"
;
const
kPreviewLoaded
=
kScalarPrefix
+
"
preview_loaded
"
;
const
kSubscribed
=
kScalarPrefix
+
"
feed_subscribed
"
;
const
kLivemarkCount
=
kScalarPrefix
+
"
livebookmark_count
"
;
const
kLivemarkOpened
=
kScalarPrefix
+
"
livebookmark_opened
"
;
const
kLivemarkItemOpened
=
kScalarPrefix
+
"
livebookmark_item_opened
"
;
let
scalarForContent
=
gMultiProcessBrowser
?
"
content
"
:
"
parent
"
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
FEED_URI
)
;
let
previewCount
=
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
snapshot
=
getSnapShot
(
)
[
scalarForContent
]
;
return
snapshot
&
&
snapshot
[
kPreviewLoaded
]
;
}
)
;
Assert
.
equal
(
previewCount
1
"
Should
register
the
preview
in
telemetry
.
"
)
;
let
old
=
PlacesCommandHook
.
addLiveBookmark
;
let
createBMPromise
=
new
Promise
(
resolve
=
>
{
PlacesCommandHook
.
addLiveBookmark
=
function
(
.
.
.
args
)
{
resolve
(
args
)
;
return
createBMPromise
;
}
;
}
)
;
registerCleanupFunction
(
(
)
=
>
PlacesCommandHook
.
addLiveBookmark
=
old
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
subscribeButton
"
{
}
tab
.
linkedBrowser
)
;
let
bmArgs
=
await
createBMPromise
;
Assert
.
deepEqual
(
bmArgs
[
FEED_URI
"
Example
Feed
"
"
"
]
"
Should
have
been
trying
to
subscribe
"
)
;
let
snapshot
=
getSnapShot
(
)
;
Assert
.
equal
(
snapshot
.
parent
[
kSubscribed
]
1
"
Should
have
subscribed
once
.
"
)
;
let
livemarks
=
await
Promise
.
all
(
[
PlacesUtils
.
livemarks
.
addLivemark
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
feedURI
:
Services
.
io
.
newURI
(
FEED_URI
)
}
)
PlacesUtils
.
livemarks
.
addLivemark
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
feedURI
:
Services
.
io
.
newURI
(
FEED_URI
)
}
)
]
)
;
registerCleanupFunction
(
async
(
)
=
>
{
for
(
let
mark
of
livemarks
)
{
await
PlacesUtils
.
livemarks
.
removeLivemark
(
mark
)
;
}
}
)
;
if
(
document
.
getElementById
(
"
PersonalToolbar
"
)
.
getAttribute
(
"
collapsed
"
)
=
=
"
true
"
)
{
CustomizableUI
.
setToolbarVisibility
(
"
PersonalToolbar
"
true
)
;
registerCleanupFunction
(
(
)
=
>
CustomizableUI
.
setToolbarVisibility
(
"
PersonalToolbar
"
false
)
)
;
}
let
{
PlacesDBUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesDBUtils
.
jsm
"
{
}
)
;
await
PlacesDBUtils
.
_telemetryForFeeds
(
)
;
Assert
.
equal
(
getSnapShot
(
)
.
parent
[
kLivemarkCount
]
2
"
Should
have
created
two
livemarks
and
counted
them
.
"
)
;
info
(
"
Waiting
for
livemark
"
)
;
let
livemarkOnToolbar
=
await
TestUtils
.
waitForCondition
(
(
)
=
>
document
.
querySelector
(
"
#
PersonalToolbar
.
bookmark
-
item
[
livemark
]
"
)
)
;
let
popup
=
livemarkOnToolbar
.
querySelector
(
"
menupopup
"
)
;
let
popupShownPromise
=
BrowserTestUtils
.
waitForEvent
(
popup
"
popupshown
"
)
;
info
(
"
Clicking
on
livemark
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
livemarkOnToolbar
{
}
)
;
await
popupShownPromise
;
Assert
.
equal
(
getSnapShot
(
)
.
parent
[
kLivemarkOpened
]
1
"
Should
count
livemark
opening
"
)
;
let
item
=
await
TestUtils
.
waitForCondition
(
(
)
=
>
popup
.
querySelector
(
"
menuitem
.
bookmark
-
item
"
)
)
;
item
.
doCommand
(
)
;
Assert
.
equal
(
getSnapShot
(
)
.
parent
[
kLivemarkItemOpened
]
1
"
Should
count
livemark
item
opening
"
)
;
popup
.
hidePopup
(
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
