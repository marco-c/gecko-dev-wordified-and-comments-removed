"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
FEEDWRITER_CID
=
Components
.
ID
(
"
{
49bb6593
-
3aff
-
4eb3
-
a068
-
2712c28bd58e
}
"
)
;
const
FEEDWRITER_CONTRACTID
=
"
mozilla
.
org
/
browser
/
feeds
/
result
-
writer
;
1
"
;
function
LOG
(
str
)
{
let
shouldLog
=
Services
.
prefs
.
getBoolPref
(
"
feeds
.
log
"
false
)
;
if
(
shouldLog
)
dump
(
"
*
*
*
Feeds
:
"
+
str
+
"
\
n
"
)
;
}
function
makeURI
(
aURLSpec
aCharset
)
{
try
{
return
Services
.
io
.
newURI
(
aURLSpec
aCharset
)
;
}
catch
(
ex
)
{
}
return
null
;
}
const
XML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
URI_BUNDLE
=
"
chrome
:
/
/
browser
/
locale
/
feeds
/
subscribe
.
properties
"
;
const
TITLE_ID
=
"
feedTitleText
"
;
const
SUBTITLE_ID
=
"
feedSubtitleText
"
;
function
convertByteUnits
(
aBytes
)
{
let
units
=
[
"
bytes
"
"
kilobyte
"
"
megabyte
"
"
gigabyte
"
]
;
let
unitIndex
=
0
;
while
(
(
aBytes
>
=
999
.
5
)
&
&
(
unitIndex
<
units
.
length
-
1
)
)
{
aBytes
/
=
1024
;
unitIndex
+
+
;
}
aBytes
=
aBytes
.
toFixed
(
(
aBytes
>
0
)
&
&
(
aBytes
<
100
)
?
1
:
0
)
;
return
[
aBytes
units
[
unitIndex
]
]
;
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gCanFrameFeeds
"
"
browser
.
feeds
.
unsafelyFrameFeeds
"
false
)
;
function
FeedWriter
(
)
{
Services
.
telemetry
.
scalarAdd
(
"
browser
.
feeds
.
preview_loaded
"
1
)
;
}
FeedWriter
.
prototype
=
{
_getPropertyAsBag
(
container
property
)
{
return
container
.
fields
.
getProperty
(
property
)
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
}
_getPropertyAsString
(
container
property
)
{
try
{
return
container
.
fields
.
getPropertyAsAString
(
property
)
;
}
catch
(
e
)
{
}
return
"
"
;
}
_setContentText
(
id
text
)
{
let
element
=
this
.
_document
.
getElementById
(
id
)
;
let
textNode
=
text
.
createDocumentFragment
(
element
)
;
while
(
element
.
hasChildNodes
(
)
)
element
.
firstChild
.
remove
(
)
;
element
.
appendChild
(
textNode
)
;
if
(
text
.
base
)
{
element
.
setAttributeNS
(
XML_NS
"
base
"
text
.
base
.
spec
)
;
}
}
_safeSetURIAttribute
(
element
attribute
uri
)
{
const
flags
=
Ci
.
nsIScriptSecurityManager
.
DISALLOW_INHERIT_PRINCIPAL
;
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
this
.
_feedPrincipal
uri
flags
)
;
}
catch
(
e
)
{
return
;
}
element
.
setAttribute
(
attribute
uri
)
;
}
__bundle
:
null
get
_bundle
(
)
{
if
(
!
this
.
__bundle
)
{
this
.
__bundle
=
Services
.
strings
.
createBundle
(
URI_BUNDLE
)
;
}
return
this
.
__bundle
;
}
_getFormattedString
(
key
params
)
{
return
this
.
_bundle
.
formatStringFromName
(
key
params
params
.
length
)
;
}
_getString
(
key
)
{
return
this
.
_bundle
.
GetStringFromName
(
key
)
;
}
_parseDate
(
dateString
)
{
let
dateObj
=
new
Date
(
dateString
)
;
if
(
!
dateObj
.
getTime
(
)
)
return
false
;
return
this
.
_dateFormatter
.
format
(
dateObj
)
;
}
__dateFormatter
:
null
get
_dateFormatter
(
)
{
if
(
!
this
.
__dateFormatter
)
{
const
dtOptions
=
{
timeStyle
:
"
short
"
dateStyle
:
"
long
"
}
;
this
.
__dateFormatter
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
dtOptions
)
;
}
return
this
.
__dateFormatter
;
}
_setTitleText
(
container
)
{
if
(
container
.
title
)
{
let
title
=
container
.
title
.
plainText
(
)
;
this
.
_setContentText
(
TITLE_ID
container
.
title
)
;
this
.
_document
.
title
=
title
;
}
let
feed
=
container
.
QueryInterface
(
Ci
.
nsIFeed
)
;
if
(
feed
&
&
feed
.
subtitle
)
this
.
_setContentText
(
SUBTITLE_ID
container
.
subtitle
)
;
}
_setTitleImage
(
container
)
{
try
{
let
parts
=
container
.
image
;
let
feedTitleImage
=
this
.
_document
.
getElementById
(
"
feedTitleImage
"
)
;
this
.
_safeSetURIAttribute
(
feedTitleImage
"
src
"
parts
.
getPropertyAsAString
(
"
url
"
)
)
;
let
feedTitleLink
=
this
.
_document
.
getElementById
(
"
feedTitleLink
"
)
;
let
titleText
=
this
.
_getFormattedString
(
"
linkTitleTextFormat
"
[
parts
.
getPropertyAsAString
(
"
title
"
)
]
)
;
let
feedTitleText
=
this
.
_document
.
getElementById
(
"
feedTitleText
"
)
;
let
titleImageWidth
=
parseInt
(
parts
.
getPropertyAsAString
(
"
width
"
)
)
+
15
;
feedTitleLink
.
setAttribute
(
"
title
"
titleText
)
;
feedTitleText
.
style
.
marginRight
=
titleImageWidth
+
"
px
"
;
this
.
_safeSetURIAttribute
(
feedTitleLink
"
href
"
parts
.
getPropertyAsAString
(
"
link
"
)
)
;
}
catch
(
e
)
{
LOG
(
"
Failed
to
set
Title
Image
(
this
is
benign
)
:
"
+
e
)
;
}
}
_writeFeedContent
(
container
)
{
let
feed
=
container
.
QueryInterface
(
Ci
.
nsIFeed
)
;
if
(
feed
.
items
.
length
=
=
0
)
return
;
let
feedContent
=
this
.
_document
.
getElementById
(
"
feedContent
"
)
;
for
(
let
i
=
0
;
i
<
feed
.
items
.
length
;
+
+
i
)
{
let
entry
=
feed
.
items
.
queryElementAt
(
i
Ci
.
nsIFeedEntry
)
;
entry
.
QueryInterface
(
Ci
.
nsIFeedContainer
)
;
let
entryContainer
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
entryContainer
.
className
=
"
entry
"
;
if
(
entry
.
title
)
{
let
a
=
this
.
_document
.
createElementNS
(
HTML_NS
"
a
"
)
;
let
span
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
a
.
appendChild
(
span
)
;
if
(
entry
.
title
.
base
)
span
.
setAttributeNS
(
XML_NS
"
base
"
entry
.
title
.
base
.
spec
)
;
span
.
appendChild
(
entry
.
title
.
createDocumentFragment
(
a
)
)
;
if
(
entry
.
link
)
this
.
_safeSetURIAttribute
(
a
"
href
"
entry
.
link
.
spec
)
;
let
title
=
this
.
_document
.
createElementNS
(
HTML_NS
"
h3
"
)
;
title
.
appendChild
(
a
)
;
let
lastUpdated
=
this
.
_parseDate
(
entry
.
updated
)
;
if
(
lastUpdated
)
{
let
dateDiv
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
dateDiv
.
className
=
"
lastUpdated
"
;
dateDiv
.
textContent
=
lastUpdated
;
title
.
appendChild
(
dateDiv
)
;
}
entryContainer
.
appendChild
(
title
)
;
}
let
body
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
let
summary
=
entry
.
summary
|
|
entry
.
content
;
let
docFragment
=
null
;
if
(
summary
)
{
if
(
summary
.
base
)
body
.
setAttributeNS
(
XML_NS
"
base
"
summary
.
base
.
spec
)
;
else
LOG
(
"
no
base
?
"
)
;
docFragment
=
summary
.
createDocumentFragment
(
body
)
;
if
(
docFragment
)
body
.
appendChild
(
docFragment
)
;
if
(
!
entry
.
title
&
&
entry
.
link
)
{
let
a
=
this
.
_document
.
createElementNS
(
HTML_NS
"
a
"
)
;
a
.
appendChild
(
this
.
_document
.
createTextNode
(
"
#
"
)
)
;
this
.
_safeSetURIAttribute
(
a
"
href
"
entry
.
link
.
spec
)
;
body
.
appendChild
(
this
.
_document
.
createTextNode
(
"
"
)
)
;
body
.
appendChild
(
a
)
;
}
}
body
.
className
=
"
feedEntryContent
"
;
entryContainer
.
appendChild
(
body
)
;
if
(
entry
.
enclosures
&
&
entry
.
enclosures
.
length
>
0
)
{
let
enclosuresDiv
=
this
.
_buildEnclosureDiv
(
entry
)
;
entryContainer
.
appendChild
(
enclosuresDiv
)
;
}
let
clearDiv
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
clearDiv
.
style
.
clear
=
"
both
"
;
feedContent
.
appendChild
(
entryContainer
)
;
feedContent
.
appendChild
(
clearDiv
)
;
}
}
_getURLDisplayName
(
aURL
)
{
let
url
=
makeURI
(
aURL
)
;
url
.
QueryInterface
(
Ci
.
nsIURL
)
;
if
(
url
=
=
null
|
|
url
.
fileName
.
length
=
=
0
)
return
decodeURIComponent
(
aURL
)
;
return
decodeURIComponent
(
url
.
fileName
)
;
}
_buildEnclosureDiv
(
entry
)
{
let
enclosuresDiv
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
enclosuresDiv
.
className
=
"
enclosures
"
;
enclosuresDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
this
.
_getString
(
"
mediaLabel
"
)
)
)
;
for
(
let
i_enc
=
0
;
i_enc
<
entry
.
enclosures
.
length
;
+
+
i_enc
)
{
let
enc
=
entry
.
enclosures
.
queryElementAt
(
i_enc
Ci
.
nsIWritablePropertyBag2
)
;
if
(
!
(
enc
.
hasKey
(
"
url
"
)
)
)
continue
;
let
enclosureDiv
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
enclosureDiv
.
setAttribute
(
"
class
"
"
enclosure
"
)
;
let
mozicon
=
"
moz
-
icon
:
/
/
.
txt
?
size
=
16
"
;
let
type_text
=
null
;
let
size_text
=
null
;
if
(
enc
.
hasKey
(
"
type
"
)
)
{
type_text
=
enc
.
get
(
"
type
"
)
;
if
(
enc
.
hasKey
(
"
typeDesc
"
)
)
type_text
=
enc
.
get
(
"
typeDesc
"
)
;
if
(
type_text
&
&
type_text
.
length
>
0
)
mozicon
=
"
moz
-
icon
:
/
/
goat
?
size
=
16
&
contentType
=
"
+
enc
.
get
(
"
type
"
)
;
}
if
(
enc
.
hasKey
(
"
length
"
)
&
&
/
^
[
0
-
9
]
+
/
.
test
(
enc
.
get
(
"
length
"
)
)
)
{
let
enc_size
=
convertByteUnits
(
parseInt
(
enc
.
get
(
"
length
"
)
)
)
;
size_text
=
this
.
_getFormattedString
(
"
enclosureSizeText
"
[
enc_size
[
0
]
this
.
_getString
(
enc_size
[
1
]
)
]
)
;
}
let
iconimg
=
this
.
_document
.
createElementNS
(
HTML_NS
"
img
"
)
;
iconimg
.
setAttribute
(
"
src
"
mozicon
)
;
iconimg
.
setAttribute
(
"
class
"
"
type
-
icon
"
)
;
enclosureDiv
.
appendChild
(
iconimg
)
;
enclosureDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
"
"
)
)
;
let
enc_href
=
this
.
_document
.
createElementNS
(
HTML_NS
"
a
"
)
;
enc_href
.
appendChild
(
this
.
_document
.
createTextNode
(
this
.
_getURLDisplayName
(
enc
.
get
(
"
url
"
)
)
)
)
;
this
.
_safeSetURIAttribute
(
enc_href
"
href
"
enc
.
get
(
"
url
"
)
)
;
enclosureDiv
.
appendChild
(
enc_href
)
;
if
(
type_text
&
&
size_text
)
enclosureDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
"
(
"
+
type_text
+
"
"
+
size_text
+
"
)
"
)
)
;
else
if
(
type_text
)
enclosureDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
"
(
"
+
type_text
+
"
)
"
)
)
;
else
if
(
size_text
)
enclosureDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
"
(
"
+
size_text
+
"
)
"
)
)
;
enclosuresDiv
.
appendChild
(
enclosureDiv
)
;
}
return
enclosuresDiv
;
}
_getContainer
(
)
{
let
feedService
=
Cc
[
"
mozilla
.
org
/
browser
/
feeds
/
result
-
service
;
1
"
]
.
getService
(
Ci
.
nsIFeedResultService
)
;
let
result
;
try
{
result
=
feedService
.
getFeedResult
(
this
.
_getOriginalURI
(
this
.
_window
)
)
;
}
catch
(
e
)
{
LOG
(
"
Subscribe
Preview
:
feed
not
available
?
!
"
)
;
}
if
(
result
.
bozo
)
{
LOG
(
"
Subscribe
Preview
:
feed
result
is
bozo
?
!
"
)
;
}
let
container
;
try
{
container
=
result
.
doc
;
}
catch
(
e
)
{
LOG
(
"
Subscribe
Preview
:
no
result
.
doc
?
Why
didn
'
t
the
original
reload
?
"
)
;
return
null
;
}
return
container
;
}
_getOriginalURI
(
aWindow
)
{
let
docShell
=
aWindow
.
docShell
;
let
chan
=
docShell
.
currentDocumentChannel
;
let
attrs
=
docShell
.
getOriginAttributes
(
)
;
let
ssm
=
Services
.
scriptSecurityManager
;
let
nullPrincipal
=
ssm
.
createNullPrincipal
(
attrs
)
;
let
resolvedURI
=
NetUtil
.
newChannel
(
{
uri
:
"
about
:
feeds
"
loadingPrincipal
:
nullPrincipal
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
.
URI
;
if
(
resolvedURI
.
equals
(
chan
.
URI
)
)
return
chan
.
originalURI
;
return
null
;
}
_window
:
null
_document
:
null
_feedURI
:
null
_feedPrincipal
:
null
init
(
aWindow
)
{
let
window
=
aWindow
;
if
(
window
!
=
window
.
top
&
&
!
gCanFrameFeeds
)
{
return
;
}
this
.
_feedURI
=
this
.
_getOriginalURI
(
window
)
;
if
(
!
this
.
_feedURI
)
return
;
this
.
_window
=
window
;
this
.
_document
=
window
.
document
;
this
.
_feedPrincipal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
this
.
_feedURI
{
}
)
;
LOG
(
"
Subscribe
Preview
:
feed
uri
=
"
+
this
.
_window
.
location
.
href
)
;
}
writeContent
(
)
{
if
(
!
this
.
_window
)
return
;
try
{
let
container
=
this
.
_getContainer
(
)
;
if
(
!
container
)
return
;
this
.
_setTitleText
(
container
)
;
this
.
_setTitleImage
(
container
)
;
this
.
_writeFeedContent
(
container
)
;
}
finally
{
this
.
_removeFeedFromCache
(
)
;
}
}
close
(
)
{
if
(
!
this
.
_window
)
{
return
;
}
this
.
_document
=
null
;
this
.
_window
=
null
;
this
.
_removeFeedFromCache
(
)
;
this
.
__bundle
=
null
;
this
.
_feedURI
=
null
;
}
_removeFeedFromCache
(
)
{
if
(
this
.
_window
&
&
this
.
_feedURI
)
{
let
feedService
=
Cc
[
"
mozilla
.
org
/
browser
/
feeds
/
result
-
service
;
1
"
]
.
getService
(
Ci
.
nsIFeedResultService
)
;
feedService
.
removeFeedResult
(
this
.
_feedURI
)
;
this
.
_feedURI
=
null
;
}
}
classID
:
FEEDWRITER_CID
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsIDOMGlobalPropertyInitializer
]
)
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
FeedWriter
]
)
;
