"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
FEEDWRITER_CID
=
Components
.
ID
(
"
{
49bb6593
-
3aff
-
4eb3
-
a068
-
2712c28bd58e
}
"
)
;
const
FEEDWRITER_CONTRACTID
=
"
mozilla
.
org
/
browser
/
feeds
/
result
-
writer
;
1
"
;
function
LOG
(
str
)
{
let
shouldLog
=
Services
.
prefs
.
getBoolPref
(
"
feeds
.
log
"
false
)
;
if
(
shouldLog
)
dump
(
"
*
*
*
Feeds
:
"
+
str
+
"
\
n
"
)
;
}
function
makeURI
(
aURLSpec
aCharset
)
{
try
{
return
Services
.
io
.
newURI
(
aURLSpec
aCharset
)
;
}
catch
(
ex
)
{
}
return
null
;
}
const
XML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
URI_BUNDLE
=
"
chrome
:
/
/
browser
/
locale
/
feeds
/
subscribe
.
properties
"
;
const
TITLE_ID
=
"
feedTitleText
"
;
const
SUBTITLE_ID
=
"
feedSubtitleText
"
;
function
convertByteUnits
(
aBytes
)
{
let
units
=
[
"
bytes
"
"
kilobyte
"
"
megabyte
"
"
gigabyte
"
]
;
let
unitIndex
=
0
;
while
(
(
aBytes
>
=
999
.
5
)
&
&
(
unitIndex
<
units
.
length
-
1
)
)
{
aBytes
/
=
1024
;
unitIndex
+
+
;
}
aBytes
=
aBytes
.
toFixed
(
(
aBytes
>
0
)
&
&
(
aBytes
<
100
)
?
1
:
0
)
;
return
[
aBytes
units
[
unitIndex
]
]
;
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gCanFrameFeeds
"
"
browser
.
feeds
.
unsafelyFrameFeeds
"
false
)
;
function
FeedWriter
(
)
{
this
.
_selectedApp
=
undefined
;
this
.
_selectedAppMenuItem
=
null
;
this
.
_subscribeCallback
=
null
;
this
.
_defaultHandlerMenuItem
=
null
;
Services
.
telemetry
.
scalarAdd
(
"
browser
.
feeds
.
preview_loaded
"
1
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_mm
"
(
)
=
>
this
.
_window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
)
;
}
FeedWriter
.
prototype
=
{
_getPropertyAsBag
(
container
property
)
{
return
container
.
fields
.
getProperty
(
property
)
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
}
_getPropertyAsString
(
container
property
)
{
try
{
return
container
.
fields
.
getPropertyAsAString
(
property
)
;
}
catch
(
e
)
{
}
return
"
"
;
}
_setContentText
(
id
text
)
{
let
element
=
this
.
_document
.
getElementById
(
id
)
;
let
textNode
=
text
.
createDocumentFragment
(
element
)
;
while
(
element
.
hasChildNodes
(
)
)
element
.
firstChild
.
remove
(
)
;
element
.
appendChild
(
textNode
)
;
if
(
text
.
base
)
{
element
.
setAttributeNS
(
XML_NS
"
base
"
text
.
base
.
spec
)
;
}
}
_safeSetURIAttribute
(
element
attribute
uri
)
{
const
flags
=
Ci
.
nsIScriptSecurityManager
.
DISALLOW_INHERIT_PRINCIPAL
;
try
{
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
this
.
_feedPrincipal
uri
flags
)
;
}
catch
(
e
)
{
return
;
}
element
.
setAttribute
(
attribute
uri
)
;
}
__bundle
:
null
get
_bundle
(
)
{
if
(
!
this
.
__bundle
)
{
this
.
__bundle
=
Services
.
strings
.
createBundle
(
URI_BUNDLE
)
;
}
return
this
.
__bundle
;
}
_getFormattedString
(
key
params
)
{
return
this
.
_bundle
.
formatStringFromName
(
key
params
params
.
length
)
;
}
_getString
(
key
)
{
return
this
.
_bundle
.
GetStringFromName
(
key
)
;
}
_setCheckboxCheckedState
(
aValue
)
{
let
checkbox
=
this
.
_document
.
getElementById
(
"
alwaysUse
"
)
;
if
(
checkbox
)
{
let
change
=
(
aValue
!
=
(
checkbox
.
getAttribute
(
"
checked
"
)
=
=
"
true
"
)
)
;
if
(
aValue
)
checkbox
.
setAttribute
(
"
checked
"
"
true
"
)
;
else
checkbox
.
removeAttribute
(
"
checked
"
)
;
if
(
change
)
{
let
event
=
this
.
_document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
CheckboxStateChange
"
true
true
)
;
checkbox
.
dispatchEvent
(
event
)
;
}
}
}
_parseDate
(
dateString
)
{
let
dateObj
=
new
Date
(
dateString
)
;
if
(
!
dateObj
.
getTime
(
)
)
return
false
;
return
this
.
_dateFormatter
.
format
(
dateObj
)
;
}
__dateFormatter
:
null
get
_dateFormatter
(
)
{
if
(
!
this
.
__dateFormatter
)
{
const
dtOptions
=
{
timeStyle
:
"
short
"
dateStyle
:
"
long
"
}
;
this
.
__dateFormatter
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
dtOptions
)
;
}
return
this
.
__dateFormatter
;
}
__feedType
:
null
_getFeedType
(
)
{
if
(
this
.
__feedType
!
=
null
)
return
this
.
__feedType
;
try
{
let
container
=
this
.
_getContainer
(
)
;
let
feed
=
container
.
QueryInterface
(
Ci
.
nsIFeed
)
;
this
.
__feedType
=
feed
.
type
;
return
feed
.
type
;
}
catch
(
ex
)
{
}
return
Ci
.
nsIFeed
.
TYPE_FEED
;
}
_setTitleText
(
container
)
{
if
(
container
.
title
)
{
let
title
=
container
.
title
.
plainText
(
)
;
this
.
_setContentText
(
TITLE_ID
container
.
title
)
;
this
.
_document
.
title
=
title
;
}
let
feed
=
container
.
QueryInterface
(
Ci
.
nsIFeed
)
;
if
(
feed
&
&
feed
.
subtitle
)
this
.
_setContentText
(
SUBTITLE_ID
container
.
subtitle
)
;
}
_setTitleImage
(
container
)
{
try
{
let
parts
=
container
.
image
;
let
feedTitleImage
=
this
.
_document
.
getElementById
(
"
feedTitleImage
"
)
;
this
.
_safeSetURIAttribute
(
feedTitleImage
"
src
"
parts
.
getPropertyAsAString
(
"
url
"
)
)
;
let
feedTitleLink
=
this
.
_document
.
getElementById
(
"
feedTitleLink
"
)
;
let
titleText
=
this
.
_getFormattedString
(
"
linkTitleTextFormat
"
[
parts
.
getPropertyAsAString
(
"
title
"
)
]
)
;
let
feedTitleText
=
this
.
_document
.
getElementById
(
"
feedTitleText
"
)
;
let
titleImageWidth
=
parseInt
(
parts
.
getPropertyAsAString
(
"
width
"
)
)
+
15
;
feedTitleLink
.
setAttribute
(
"
title
"
titleText
)
;
feedTitleText
.
style
.
marginRight
=
titleImageWidth
+
"
px
"
;
this
.
_safeSetURIAttribute
(
feedTitleLink
"
href
"
parts
.
getPropertyAsAString
(
"
link
"
)
)
;
}
catch
(
e
)
{
LOG
(
"
Failed
to
set
Title
Image
(
this
is
benign
)
:
"
+
e
)
;
}
}
_writeFeedContent
(
container
)
{
let
feed
=
container
.
QueryInterface
(
Ci
.
nsIFeed
)
;
if
(
feed
.
items
.
length
=
=
0
)
return
;
let
feedContent
=
this
.
_document
.
getElementById
(
"
feedContent
"
)
;
for
(
let
i
=
0
;
i
<
feed
.
items
.
length
;
+
+
i
)
{
let
entry
=
feed
.
items
.
queryElementAt
(
i
Ci
.
nsIFeedEntry
)
;
entry
.
QueryInterface
(
Ci
.
nsIFeedContainer
)
;
let
entryContainer
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
entryContainer
.
className
=
"
entry
"
;
if
(
entry
.
title
)
{
let
a
=
this
.
_document
.
createElementNS
(
HTML_NS
"
a
"
)
;
let
span
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
a
.
appendChild
(
span
)
;
if
(
entry
.
title
.
base
)
span
.
setAttributeNS
(
XML_NS
"
base
"
entry
.
title
.
base
.
spec
)
;
span
.
appendChild
(
entry
.
title
.
createDocumentFragment
(
a
)
)
;
if
(
entry
.
link
)
this
.
_safeSetURIAttribute
(
a
"
href
"
entry
.
link
.
spec
)
;
let
title
=
this
.
_document
.
createElementNS
(
HTML_NS
"
h3
"
)
;
title
.
appendChild
(
a
)
;
let
lastUpdated
=
this
.
_parseDate
(
entry
.
updated
)
;
if
(
lastUpdated
)
{
let
dateDiv
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
dateDiv
.
className
=
"
lastUpdated
"
;
dateDiv
.
textContent
=
lastUpdated
;
title
.
appendChild
(
dateDiv
)
;
}
entryContainer
.
appendChild
(
title
)
;
}
let
body
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
let
summary
=
entry
.
summary
|
|
entry
.
content
;
let
docFragment
=
null
;
if
(
summary
)
{
if
(
summary
.
base
)
body
.
setAttributeNS
(
XML_NS
"
base
"
summary
.
base
.
spec
)
;
else
LOG
(
"
no
base
?
"
)
;
docFragment
=
summary
.
createDocumentFragment
(
body
)
;
if
(
docFragment
)
body
.
appendChild
(
docFragment
)
;
if
(
!
entry
.
title
&
&
entry
.
link
)
{
let
a
=
this
.
_document
.
createElementNS
(
HTML_NS
"
a
"
)
;
a
.
appendChild
(
this
.
_document
.
createTextNode
(
"
#
"
)
)
;
this
.
_safeSetURIAttribute
(
a
"
href
"
entry
.
link
.
spec
)
;
body
.
appendChild
(
this
.
_document
.
createTextNode
(
"
"
)
)
;
body
.
appendChild
(
a
)
;
}
}
body
.
className
=
"
feedEntryContent
"
;
entryContainer
.
appendChild
(
body
)
;
if
(
entry
.
enclosures
&
&
entry
.
enclosures
.
length
>
0
)
{
let
enclosuresDiv
=
this
.
_buildEnclosureDiv
(
entry
)
;
entryContainer
.
appendChild
(
enclosuresDiv
)
;
}
let
clearDiv
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
clearDiv
.
style
.
clear
=
"
both
"
;
feedContent
.
appendChild
(
entryContainer
)
;
feedContent
.
appendChild
(
clearDiv
)
;
}
}
_getURLDisplayName
(
aURL
)
{
let
url
=
makeURI
(
aURL
)
;
url
.
QueryInterface
(
Ci
.
nsIURL
)
;
if
(
url
=
=
null
|
|
url
.
fileName
.
length
=
=
0
)
return
decodeURIComponent
(
aURL
)
;
return
decodeURIComponent
(
url
.
fileName
)
;
}
_buildEnclosureDiv
(
entry
)
{
let
enclosuresDiv
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
enclosuresDiv
.
className
=
"
enclosures
"
;
enclosuresDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
this
.
_getString
(
"
mediaLabel
"
)
)
)
;
for
(
let
i_enc
=
0
;
i_enc
<
entry
.
enclosures
.
length
;
+
+
i_enc
)
{
let
enc
=
entry
.
enclosures
.
queryElementAt
(
i_enc
Ci
.
nsIWritablePropertyBag2
)
;
if
(
!
(
enc
.
hasKey
(
"
url
"
)
)
)
continue
;
let
enclosureDiv
=
this
.
_document
.
createElementNS
(
HTML_NS
"
div
"
)
;
enclosureDiv
.
setAttribute
(
"
class
"
"
enclosure
"
)
;
let
mozicon
=
"
moz
-
icon
:
/
/
.
txt
?
size
=
16
"
;
let
type_text
=
null
;
let
size_text
=
null
;
if
(
enc
.
hasKey
(
"
type
"
)
)
{
type_text
=
enc
.
get
(
"
type
"
)
;
if
(
enc
.
hasKey
(
"
typeDesc
"
)
)
type_text
=
enc
.
get
(
"
typeDesc
"
)
;
if
(
type_text
&
&
type_text
.
length
>
0
)
mozicon
=
"
moz
-
icon
:
/
/
goat
?
size
=
16
&
contentType
=
"
+
enc
.
get
(
"
type
"
)
;
}
if
(
enc
.
hasKey
(
"
length
"
)
&
&
/
^
[
0
-
9
]
+
/
.
test
(
enc
.
get
(
"
length
"
)
)
)
{
let
enc_size
=
convertByteUnits
(
parseInt
(
enc
.
get
(
"
length
"
)
)
)
;
size_text
=
this
.
_getFormattedString
(
"
enclosureSizeText
"
[
enc_size
[
0
]
this
.
_getString
(
enc_size
[
1
]
)
]
)
;
}
let
iconimg
=
this
.
_document
.
createElementNS
(
HTML_NS
"
img
"
)
;
iconimg
.
setAttribute
(
"
src
"
mozicon
)
;
iconimg
.
setAttribute
(
"
class
"
"
type
-
icon
"
)
;
enclosureDiv
.
appendChild
(
iconimg
)
;
enclosureDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
"
"
)
)
;
let
enc_href
=
this
.
_document
.
createElementNS
(
HTML_NS
"
a
"
)
;
enc_href
.
appendChild
(
this
.
_document
.
createTextNode
(
this
.
_getURLDisplayName
(
enc
.
get
(
"
url
"
)
)
)
)
;
this
.
_safeSetURIAttribute
(
enc_href
"
href
"
enc
.
get
(
"
url
"
)
)
;
enclosureDiv
.
appendChild
(
enc_href
)
;
if
(
type_text
&
&
size_text
)
enclosureDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
"
(
"
+
type_text
+
"
"
+
size_text
+
"
)
"
)
)
;
else
if
(
type_text
)
enclosureDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
"
(
"
+
type_text
+
"
)
"
)
)
;
else
if
(
size_text
)
enclosureDiv
.
appendChild
(
this
.
_document
.
createTextNode
(
"
(
"
+
size_text
+
"
)
"
)
)
;
enclosuresDiv
.
appendChild
(
enclosureDiv
)
;
}
return
enclosuresDiv
;
}
_getContainer
(
)
{
let
feedService
=
Cc
[
"
mozilla
.
org
/
browser
/
feeds
/
result
-
service
;
1
"
]
.
getService
(
Ci
.
nsIFeedResultService
)
;
let
result
;
try
{
result
=
feedService
.
getFeedResult
(
this
.
_getOriginalURI
(
this
.
_window
)
)
;
}
catch
(
e
)
{
LOG
(
"
Subscribe
Preview
:
feed
not
available
?
!
"
)
;
}
if
(
result
.
bozo
)
{
LOG
(
"
Subscribe
Preview
:
feed
result
is
bozo
?
!
"
)
;
}
let
container
;
try
{
container
=
result
.
doc
;
}
catch
(
e
)
{
LOG
(
"
Subscribe
Preview
:
no
result
.
doc
?
Why
didn
'
t
the
original
reload
?
"
)
;
return
null
;
}
return
container
;
}
_getFileIconURL
(
file
)
{
let
fph
=
Services
.
io
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
let
urlSpec
=
fph
.
getURLSpecFromFile
(
file
)
;
return
"
moz
-
icon
:
/
/
"
+
urlSpec
+
"
?
size
=
16
"
;
}
_chooseClientApp
(
aCallback
)
{
this
.
_subscribeCallback
=
aCallback
;
this
.
_mm
.
sendAsyncMessage
(
"
FeedWriter
:
ChooseClientApp
"
{
title
:
this
.
_getString
(
"
chooseApplicationDialogTitle
"
)
feedType
:
this
.
_getFeedType
(
)
}
)
;
}
_setSubscribeUsingLabel
(
)
{
let
stringLabel
=
"
subscribeFeedUsing
"
;
switch
(
this
.
_getFeedType
(
)
)
{
case
Ci
.
nsIFeed
.
TYPE_VIDEO
:
stringLabel
=
"
subscribeVideoPodcastUsing
"
;
break
;
case
Ci
.
nsIFeed
.
TYPE_AUDIO
:
stringLabel
=
"
subscribeAudioPodcastUsing
"
;
break
;
}
let
subscribeUsing
=
this
.
_document
.
getElementById
(
"
subscribeUsingDescription
"
)
;
let
textNode
=
this
.
_document
.
createTextNode
(
this
.
_getString
(
stringLabel
)
)
;
subscribeUsing
.
insertBefore
(
textNode
subscribeUsing
.
firstChild
)
;
}
_setAlwaysUseLabel
(
)
{
let
checkbox
=
this
.
_document
.
getElementById
(
"
alwaysUse
"
)
;
if
(
checkbox
&
&
this
.
_handlersList
)
{
let
handlerName
=
this
.
_handlersList
.
selectedOptions
[
0
]
.
textContent
;
let
stringLabel
=
"
alwaysUseForFeeds
"
;
switch
(
this
.
_getFeedType
(
)
)
{
case
Ci
.
nsIFeed
.
TYPE_VIDEO
:
stringLabel
=
"
alwaysUseForVideoPodcasts
"
;
break
;
case
Ci
.
nsIFeed
.
TYPE_AUDIO
:
stringLabel
=
"
alwaysUseForAudioPodcasts
"
;
break
;
}
let
label
=
this
.
_getFormattedString
(
stringLabel
[
handlerName
]
)
;
let
checkboxText
=
this
.
_document
.
getElementById
(
"
checkboxText
"
)
;
if
(
checkboxText
.
lastChild
.
nodeType
=
=
checkboxText
.
TEXT_NODE
)
{
checkboxText
.
lastChild
.
textContent
=
label
;
}
else
{
LOG
(
"
FeedWriter
.
_setAlwaysUseLabel
:
Expected
textNode
as
lastChild
of
alwaysUse
label
"
)
;
let
textNode
=
this
.
_document
.
createTextNode
(
label
)
;
checkboxText
.
appendChild
(
textNode
)
;
}
}
}
handleEvent
(
event
)
{
if
(
event
.
target
.
ownerDocument
!
=
this
.
_document
)
{
LOG
(
"
FeedWriter
.
handleEvent
:
Someone
passed
the
feed
writer
as
a
listener
to
the
events
of
another
document
!
"
)
;
return
;
}
switch
(
event
.
type
)
{
case
"
click
"
:
if
(
event
.
target
.
id
=
=
"
subscribeButton
"
)
{
this
.
subscribe
(
)
;
}
break
;
case
"
change
"
:
LOG
(
"
Change
fired
"
)
;
if
(
event
.
target
.
selectedOptions
[
0
]
.
id
=
=
"
chooseApplicationMenuItem
"
)
{
this
.
_chooseClientApp
(
(
)
=
>
{
LOG
(
"
Selected
handler
after
callback
"
)
;
this
.
_setAlwaysUseLabel
(
)
;
}
)
;
}
else
{
this
.
_setAlwaysUseLabel
(
)
;
}
break
;
}
}
_setSelectedHandlerResponse
(
handler
)
{
LOG
(
Selecting
handler
response
{
handler
}
)
;
switch
(
handler
)
{
case
"
client
"
:
case
"
default
"
:
break
;
case
"
bookmarks
"
:
default
:
{
let
liveBookmarksMenuItem
=
this
.
_document
.
getElementById
(
"
liveBookmarksMenuItem
"
)
;
if
(
liveBookmarksMenuItem
)
liveBookmarksMenuItem
.
selected
=
true
;
}
}
}
_initSubscriptionUI
(
setupMessage
)
{
if
(
!
this
.
_handlersList
)
return
;
LOG
(
"
UI
init
"
)
;
let
feedType
=
this
.
_getFeedType
(
)
;
let
header
=
this
.
_document
.
getElementById
(
"
feedHeader
"
)
;
switch
(
feedType
)
{
case
Ci
.
nsIFeed
.
TYPE_VIDEO
:
header
.
className
=
"
videoPodcastBackground
"
;
break
;
case
Ci
.
nsIFeed
.
TYPE_AUDIO
:
header
.
className
=
"
audioPodcastBackground
"
;
break
;
default
:
header
.
className
=
"
feedBackground
"
;
}
let
liveBookmarksMenuItem
=
this
.
_document
.
getElementById
(
"
liveBookmarksMenuItem
"
)
;
let
menuItem
=
liveBookmarksMenuItem
.
cloneNode
(
false
)
;
menuItem
.
removeAttribute
(
"
selected
"
)
;
menuItem
.
setAttribute
(
"
id
"
"
selectedAppMenuItem
"
)
;
menuItem
.
setAttribute
(
"
handlerType
"
"
client
"
)
;
menuItem
.
style
.
display
=
"
none
"
;
this
.
_selectedAppMenuItem
=
menuItem
;
this
.
_handlersList
.
appendChild
(
this
.
_selectedAppMenuItem
)
;
menuItem
=
liveBookmarksMenuItem
.
cloneNode
(
false
)
;
menuItem
.
removeAttribute
(
"
selected
"
)
;
menuItem
.
setAttribute
(
"
id
"
"
defaultHandlerMenuItem
"
)
;
menuItem
.
setAttribute
(
"
handlerType
"
"
client
"
)
;
menuItem
.
style
.
display
=
"
none
"
;
this
.
_defaultHandlerMenuItem
=
menuItem
;
this
.
_handlersList
.
appendChild
(
this
.
_defaultHandlerMenuItem
)
;
menuItem
=
liveBookmarksMenuItem
.
cloneNode
(
false
)
;
menuItem
.
removeAttribute
(
"
selected
"
)
;
menuItem
.
setAttribute
(
"
id
"
"
chooseApplicationMenuItem
"
)
;
menuItem
.
textContent
=
this
.
_getString
(
"
chooseApplicationMenuItem
"
)
;
this
.
_handlersList
.
appendChild
(
menuItem
)
;
this
.
_setSelectedHandlerResponse
(
setupMessage
.
reader
.
handler
)
;
if
(
setupMessage
.
defaultMenuItem
)
{
LOG
(
Setting
default
menu
item
{
setupMessage
.
defaultMenuItem
}
)
;
this
.
_setApplicationLauncherMenuItem
(
this
.
_defaultHandlerMenuItem
setupMessage
.
defaultMenuItem
)
;
}
if
(
setupMessage
.
selectedMenuItem
)
{
LOG
(
Setting
selected
menu
item
{
setupMessage
.
selectedMenuItem
}
)
;
this
.
_setApplicationLauncherMenuItem
(
this
.
_selectedAppMenuItem
setupMessage
.
selectedMenuItem
)
;
}
this
.
_setSubscribeUsingLabel
(
)
;
this
.
_setCheckboxCheckedState
(
setupMessage
.
reader
.
alwaysUse
)
;
this
.
_setAlwaysUseLabel
(
)
;
this
.
_handlersList
.
addEventListener
(
"
change
"
this
)
;
this
.
_document
.
getElementById
(
"
subscribeButton
"
)
.
addEventListener
(
"
click
"
this
)
;
if
(
setupMessage
.
showFirstRunUI
)
{
let
textfeedinfo1
textfeedinfo2
;
switch
(
feedType
)
{
case
Ci
.
nsIFeed
.
TYPE_VIDEO
:
textfeedinfo1
=
"
feedSubscriptionVideoPodcast1
"
;
textfeedinfo2
=
"
feedSubscriptionVideoPodcast2
"
;
break
;
case
Ci
.
nsIFeed
.
TYPE_AUDIO
:
textfeedinfo1
=
"
feedSubscriptionAudioPodcast1
"
;
textfeedinfo2
=
"
feedSubscriptionAudioPodcast2
"
;
break
;
default
:
textfeedinfo1
=
"
feedSubscriptionFeed1
"
;
textfeedinfo2
=
"
feedSubscriptionFeed2
"
;
}
let
feedinfo1
=
this
.
_document
.
getElementById
(
"
feedSubscriptionInfo1
"
)
;
let
feedinfo1Str
=
this
.
_getString
(
textfeedinfo1
)
;
let
feedinfo2
=
this
.
_document
.
getElementById
(
"
feedSubscriptionInfo2
"
)
;
let
feedinfo2Str
=
this
.
_getString
(
textfeedinfo2
)
;
feedinfo1
.
textContent
=
feedinfo1Str
;
feedinfo2
.
textContent
=
feedinfo2Str
;
header
.
setAttribute
(
"
firstrun
"
"
true
"
)
;
this
.
_mm
.
sendAsyncMessage
(
"
FeedWriter
:
ShownFirstRun
"
)
;
}
}
_getOriginalURI
(
aWindow
)
{
let
docShell
=
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
let
chan
=
docShell
.
currentDocumentChannel
;
let
attrs
=
docShell
.
getOriginAttributes
(
)
;
let
ssm
=
Services
.
scriptSecurityManager
;
let
nullPrincipal
=
ssm
.
createNullPrincipal
(
attrs
)
;
let
resolvedURI
=
NetUtil
.
newChannel
(
{
uri
:
"
about
:
feeds
"
loadingPrincipal
:
nullPrincipal
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
.
URI
;
if
(
resolvedURI
.
equals
(
chan
.
URI
)
)
return
chan
.
originalURI
;
return
null
;
}
_window
:
null
_document
:
null
_feedURI
:
null
_feedPrincipal
:
null
_handlersList
:
null
init
(
aWindow
)
{
let
window
=
aWindow
;
if
(
window
!
=
window
.
top
&
&
!
gCanFrameFeeds
)
{
return
;
}
this
.
_feedURI
=
this
.
_getOriginalURI
(
window
)
;
if
(
!
this
.
_feedURI
)
return
;
this
.
_window
=
window
;
this
.
_document
=
window
.
document
;
this
.
_handlersList
=
this
.
_document
.
getElementById
(
"
handlersMenuList
"
)
;
this
.
_feedPrincipal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
this
.
_feedURI
{
}
)
;
LOG
(
"
Subscribe
Preview
:
feed
uri
=
"
+
this
.
_window
.
location
.
href
)
;
this
.
_mm
.
addMessageListener
(
"
FeedWriter
:
PreferenceUpdated
"
this
)
;
this
.
_mm
.
addMessageListener
(
"
FeedWriter
:
SetApplicationLauncherMenuItem
"
this
)
;
this
.
_mm
.
addMessageListener
(
"
FeedWriter
:
GetSubscriptionUIResponse
"
this
)
;
const
feedType
=
this
.
_getFeedType
(
)
;
this
.
_mm
.
sendAsyncMessage
(
"
FeedWriter
:
GetSubscriptionUI
"
{
feedType
}
)
;
}
receiveMessage
(
msg
)
{
if
(
!
this
.
_window
)
{
return
;
}
LOG
(
received
message
from
parent
{
msg
.
name
}
)
;
switch
(
msg
.
name
)
{
case
"
FeedWriter
:
PreferenceUpdated
"
:
const
feedType
=
this
.
_getFeedType
(
)
;
LOG
(
Got
prefChange
!
{
JSON
.
stringify
(
msg
.
data
)
}
current
type
:
{
feedType
}
)
;
let
feedTypePref
=
msg
.
data
.
default
;
if
(
feedType
in
msg
.
data
)
{
feedTypePref
=
msg
.
data
[
feedType
]
;
}
LOG
(
Got
pref
{
JSON
.
stringify
(
feedTypePref
)
}
)
;
this
.
_setCheckboxCheckedState
(
feedTypePref
.
alwaysUse
)
;
this
.
_setSelectedHandlerResponse
(
feedTypePref
.
handler
)
;
this
.
_setAlwaysUseLabel
(
)
;
break
;
case
"
FeedWriter
:
GetSubscriptionUIResponse
"
:
this
.
_initSubscriptionUI
(
msg
.
data
)
;
break
;
case
"
FeedWriter
:
SetApplicationLauncherMenuItem
"
:
LOG
(
FeedWriter
:
SetApplicationLauncherMenuItem
-
picked
{
msg
.
data
.
name
}
)
;
this
.
_setApplicationLauncherMenuItem
(
this
.
_selectedAppMenuItem
msg
.
data
.
name
)
;
if
(
this
.
_subscribeCallback
)
{
this
.
_subscribeCallback
(
)
;
this
.
_subscribeCallback
=
null
;
}
break
;
}
}
_setApplicationLauncherMenuItem
(
menuItem
aName
)
{
[
.
.
.
this
.
_handlersList
.
children
]
.
forEach
(
(
option
)
=
>
{
option
.
removeAttribute
(
"
selected
"
)
;
}
)
;
menuItem
.
textContent
=
aName
;
menuItem
.
style
.
display
=
"
"
;
menuItem
.
selected
=
true
;
}
writeContent
(
)
{
if
(
!
this
.
_window
)
return
;
try
{
let
container
=
this
.
_getContainer
(
)
;
if
(
!
container
)
return
;
this
.
_setTitleText
(
container
)
;
this
.
_setTitleImage
(
container
)
;
this
.
_writeFeedContent
(
container
)
;
}
finally
{
this
.
_removeFeedFromCache
(
)
;
}
}
close
(
)
{
if
(
!
this
.
_window
)
{
return
;
}
this
.
_document
.
getElementById
(
"
subscribeButton
"
)
.
removeEventListener
(
"
click
"
this
)
;
this
.
_handlersList
.
removeEventListener
(
"
change
"
this
)
;
this
.
_document
=
null
;
this
.
_window
=
null
;
this
.
_handlersList
=
null
;
this
.
_removeFeedFromCache
(
)
;
this
.
__bundle
=
null
;
this
.
_feedURI
=
null
;
this
.
_selectedApp
=
undefined
;
this
.
_selectedAppMenuItem
=
null
;
this
.
_defaultHandlerMenuItem
=
null
;
}
_removeFeedFromCache
(
)
{
if
(
this
.
_window
&
&
this
.
_feedURI
)
{
let
feedService
=
Cc
[
"
mozilla
.
org
/
browser
/
feeds
/
result
-
service
;
1
"
]
.
getService
(
Ci
.
nsIFeedResultService
)
;
feedService
.
removeFeedResult
(
this
.
_feedURI
)
;
this
.
_feedURI
=
null
;
}
}
subscribe
(
)
{
if
(
!
this
.
_window
)
{
return
;
}
let
feedType
=
this
.
_getFeedType
(
)
;
let
defaultHandler
=
"
reader
"
;
let
useAsDefault
=
this
.
_document
.
getElementById
(
"
alwaysUse
"
)
.
getAttribute
(
"
checked
"
)
;
let
selectedItem
=
this
.
_handlersList
.
selectedOptions
[
0
]
;
let
subscribeCallback
=
(
)
=
>
{
let
feedReader
=
null
;
let
settings
=
{
feedType
useAsDefault
feedTitle
:
this
.
_document
.
getElementById
(
TITLE_ID
)
.
textContent
feedSubtitle
:
this
.
_document
.
getElementById
(
SUBTITLE_ID
)
.
textContent
feedLocation
:
this
.
_window
.
location
.
href
}
;
switch
(
selectedItem
.
id
)
{
case
"
selectedAppMenuItem
"
:
feedReader
=
"
client
"
;
break
;
case
"
defaultHandlerMenuItem
"
:
feedReader
=
"
default
"
;
break
;
case
"
liveBookmarksMenuItem
"
:
defaultHandler
=
"
bookmarks
"
;
feedReader
=
"
bookmarks
"
;
break
;
}
settings
.
reader
=
feedReader
;
if
(
!
useAsDefault
)
{
defaultHandler
=
"
ask
"
;
}
settings
.
action
=
defaultHandler
;
LOG
(
FeedWriter
:
SetFeedPrefsAndSubscribe
-
{
JSON
.
stringify
(
settings
)
}
)
;
this
.
_mm
.
sendAsyncMessage
(
"
FeedWriter
:
SetFeedPrefsAndSubscribe
"
settings
)
;
}
;
if
(
selectedItem
.
id
=
=
"
chooseApplicationMenuItem
"
)
{
this
.
_chooseClientApp
(
aResult
=
>
{
if
(
aResult
)
{
selectedItem
=
this
.
_handlersList
.
selectedOptions
[
0
]
;
subscribeCallback
(
)
;
}
}
)
;
}
else
{
subscribeCallback
(
)
;
}
}
classID
:
FEEDWRITER_CID
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsIDOMGlobalPropertyInitializer
]
)
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
FeedWriter
]
)
;
