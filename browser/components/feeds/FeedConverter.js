ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
function
LOG
(
str
)
{
dump
(
"
*
*
*
"
+
str
+
"
\
n
"
)
;
}
const
FS_CONTRACTID
=
"
mozilla
.
org
/
browser
/
feeds
/
result
-
service
;
1
"
;
const
FPH_CONTRACTID
=
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
feed
"
;
const
PCPH_CONTRACTID
=
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
pcast
"
;
const
TYPE_MAYBE_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
feed
"
;
const
TYPE_MAYBE_VIDEO_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
video
.
feed
"
;
const
TYPE_MAYBE_AUDIO_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
audio
.
feed
"
;
const
TYPE_ANY
=
"
*
/
*
"
;
const
PREF_SELECTED_APP
=
"
browser
.
feeds
.
handlers
.
application
"
;
const
PREF_SELECTED_WEB
=
"
browser
.
feeds
.
handlers
.
webservice
"
;
const
PREF_SELECTED_ACTION
=
"
browser
.
feeds
.
handler
"
;
const
PREF_SELECTED_READER
=
"
browser
.
feeds
.
handler
.
default
"
;
const
PREF_VIDEO_SELECTED_APP
=
"
browser
.
videoFeeds
.
handlers
.
application
"
;
const
PREF_VIDEO_SELECTED_WEB
=
"
browser
.
videoFeeds
.
handlers
.
webservice
"
;
const
PREF_VIDEO_SELECTED_ACTION
=
"
browser
.
videoFeeds
.
handler
"
;
const
PREF_VIDEO_SELECTED_READER
=
"
browser
.
videoFeeds
.
handler
.
default
"
;
const
PREF_AUDIO_SELECTED_APP
=
"
browser
.
audioFeeds
.
handlers
.
application
"
;
const
PREF_AUDIO_SELECTED_WEB
=
"
browser
.
audioFeeds
.
handlers
.
webservice
"
;
const
PREF_AUDIO_SELECTED_ACTION
=
"
browser
.
audioFeeds
.
handler
"
;
const
PREF_AUDIO_SELECTED_READER
=
"
browser
.
audioFeeds
.
handler
.
default
"
;
function
getPrefAppForType
(
t
)
{
switch
(
t
)
{
case
Ci
.
nsIFeed
.
TYPE_VIDEO
:
return
PREF_VIDEO_SELECTED_APP
;
case
Ci
.
nsIFeed
.
TYPE_AUDIO
:
return
PREF_AUDIO_SELECTED_APP
;
default
:
return
PREF_SELECTED_APP
;
}
}
function
getPrefWebForType
(
t
)
{
switch
(
t
)
{
case
Ci
.
nsIFeed
.
TYPE_VIDEO
:
return
PREF_VIDEO_SELECTED_WEB
;
case
Ci
.
nsIFeed
.
TYPE_AUDIO
:
return
PREF_AUDIO_SELECTED_WEB
;
default
:
return
PREF_SELECTED_WEB
;
}
}
function
getPrefActionForType
(
t
)
{
switch
(
t
)
{
case
Ci
.
nsIFeed
.
TYPE_VIDEO
:
return
PREF_VIDEO_SELECTED_ACTION
;
case
Ci
.
nsIFeed
.
TYPE_AUDIO
:
return
PREF_AUDIO_SELECTED_ACTION
;
default
:
return
PREF_SELECTED_ACTION
;
}
}
function
getPrefReaderForType
(
t
)
{
switch
(
t
)
{
case
Ci
.
nsIFeed
.
TYPE_VIDEO
:
return
PREF_VIDEO_SELECTED_READER
;
case
Ci
.
nsIFeed
.
TYPE_AUDIO
:
return
PREF_AUDIO_SELECTED_READER
;
default
:
return
PREF_SELECTED_READER
;
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gCanFrameFeeds
"
"
browser
.
feeds
.
unsafelyFrameFeeds
"
false
)
;
function
FeedConverter
(
)
{
}
FeedConverter
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
229fa115
-
9412
-
4d32
-
baf3
-
2fc407f76fb1
}
"
)
_data
:
null
_listener
:
null
_sniffed
:
false
convert
(
sourceStream
sourceType
destinationType
context
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
asyncConvertData
(
sourceType
destinationType
listener
context
)
{
this
.
_listener
=
listener
;
}
_forcePreviewPage
:
false
_releaseHandles
(
)
{
this
.
_listener
=
null
;
this
.
_request
=
null
;
this
.
_processor
=
null
;
}
handleResult
(
result
)
{
try
{
let
feedService
=
Cc
[
"
mozilla
.
org
/
browser
/
feeds
/
result
-
service
;
1
"
]
.
getService
(
Ci
.
nsIFeedResultService
)
;
if
(
!
this
.
_forcePreviewPage
&
&
result
.
doc
)
{
let
feed
=
result
.
doc
.
QueryInterface
(
Ci
.
nsIFeed
)
;
let
handler
=
Services
.
prefs
.
getCharPref
(
getPrefActionForType
(
feed
.
type
)
"
ask
"
)
;
if
(
handler
!
=
"
ask
"
)
{
if
(
handler
=
=
"
reader
"
)
handler
=
Services
.
prefs
.
getCharPref
(
getPrefReaderForType
(
feed
.
type
)
"
bookmarks
"
)
;
switch
(
handler
)
{
case
"
web
"
:
let
wccr
=
Cc
[
"
mozilla
.
org
/
embeddor
.
implemented
/
web
-
content
-
handler
-
registrar
;
1
"
]
.
getService
(
Ci
.
nsIWebContentConverterService
)
;
if
(
(
feed
.
type
=
=
Ci
.
nsIFeed
.
TYPE_FEED
&
&
wccr
.
getAutoHandler
(
TYPE_MAYBE_FEED
)
)
|
|
(
feed
.
type
=
=
Ci
.
nsIFeed
.
TYPE_VIDEO
&
&
wccr
.
getAutoHandler
(
TYPE_MAYBE_VIDEO_FEED
)
)
|
|
(
feed
.
type
=
=
Ci
.
nsIFeed
.
TYPE_AUDIO
&
&
wccr
.
getAutoHandler
(
TYPE_MAYBE_AUDIO_FEED
)
)
)
{
wccr
.
loadPreferredHandler
(
this
.
_request
)
;
return
;
}
break
;
default
:
LOG
(
"
unexpected
handler
:
"
+
handler
)
;
case
"
bookmarks
"
:
case
"
client
"
:
case
"
default
"
:
try
{
let
title
=
feed
.
title
?
feed
.
title
.
plainText
(
)
:
"
"
;
let
desc
=
feed
.
subtitle
?
feed
.
subtitle
.
plainText
(
)
:
"
"
;
feedService
.
addToClientReader
(
result
.
uri
.
spec
title
desc
feed
.
type
handler
)
;
return
;
}
catch
(
ex
)
{
}
}
}
}
let
chromeChannel
;
let
oldChannel
=
this
.
_request
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
loadInfo
=
oldChannel
.
loadInfo
;
if
(
result
.
doc
)
{
feedService
.
addFeedResult
(
result
)
;
let
aboutFeedsURI
=
Services
.
io
.
newURI
(
"
about
:
feeds
"
)
;
chromeChannel
=
Services
.
io
.
newChannelFromURIWithLoadInfo
(
aboutFeedsURI
loadInfo
)
;
chromeChannel
.
originalURI
=
result
.
uri
;
chromeChannel
.
owner
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
aboutFeedsURI
loadInfo
.
originAttributes
)
;
}
else
{
chromeChannel
=
Services
.
io
.
newChannelFromURIWithLoadInfo
(
result
.
uri
loadInfo
)
;
}
chromeChannel
.
loadGroup
=
this
.
_request
.
loadGroup
;
chromeChannel
.
asyncOpen2
(
this
.
_listener
)
;
}
finally
{
this
.
_releaseHandles
(
)
;
}
}
onDataAvailable
(
request
context
inputStream
sourceOffset
count
)
{
if
(
this
.
_processor
)
this
.
_processor
.
onDataAvailable
(
request
context
inputStream
sourceOffset
count
)
;
}
onStartRequest
(
request
context
)
{
let
channel
=
request
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
{
loadInfo
}
=
channel
;
if
(
(
loadInfo
.
frameOuterWindowID
|
|
loadInfo
.
outerWindowID
)
!
=
loadInfo
.
topOuterWindowID
&
&
!
gCanFrameFeeds
)
{
return
;
}
try
{
let
httpChannel
=
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
!
httpChannel
.
requestSucceeded
)
{
request
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
return
;
}
httpChannel
.
getResponseHeader
(
"
X
-
Moz
-
Is
-
Feed
"
)
;
}
catch
(
ex
)
{
this
.
_sniffed
=
true
;
}
this
.
_request
=
request
;
let
feedService
=
Cc
[
"
mozilla
.
org
/
browser
/
feeds
/
result
-
service
;
1
"
]
.
getService
(
Ci
.
nsIFeedResultService
)
;
this
.
_forcePreviewPage
=
feedService
.
forcePreviewPage
;
feedService
.
forcePreviewPage
=
false
;
this
.
_processor
=
Cc
[
"
mozilla
.
org
/
feed
-
processor
;
1
"
]
.
createInstance
(
Ci
.
nsIFeedProcessor
)
;
this
.
_processor
.
listener
=
this
;
this
.
_processor
.
parseAsync
(
null
channel
.
URI
)
;
this
.
_processor
.
onStartRequest
(
request
context
)
;
}
onStopRequest
(
request
context
status
)
{
if
(
this
.
_processor
)
this
.
_processor
.
onStopRequest
(
request
context
status
)
;
}
QueryInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIFeedResultListener
)
|
|
iid
.
equals
(
Ci
.
nsIStreamConverter
)
|
|
iid
.
equals
(
Ci
.
nsIStreamListener
)
|
|
iid
.
equals
(
Ci
.
nsIRequestObserver
)
|
|
iid
.
equals
(
Ci
.
nsISupports
)
)
return
this
;
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
}
;
function
FeedResultService
(
)
{
}
FeedResultService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
2376201c
-
bbc6
-
472f
-
9b62
-
7548040a61c6
}
"
)
_results
:
{
}
forcePreviewPage
:
false
addToClientReader
(
spec
title
subtitle
feedType
feedReader
)
{
if
(
!
feedReader
)
{
feedReader
=
"
default
"
;
}
let
handler
=
Services
.
prefs
.
getCharPref
(
getPrefActionForType
(
feedType
)
"
bookmarks
"
)
;
if
(
handler
=
=
"
ask
"
|
|
handler
=
=
"
reader
"
)
handler
=
feedReader
;
switch
(
handler
)
{
case
"
client
"
:
Services
.
cpmm
.
sendAsyncMessage
(
"
FeedConverter
:
ExecuteClientApp
"
{
spec
title
subtitle
feedHandler
:
getPrefAppForType
(
feedType
)
}
)
;
break
;
case
"
default
"
:
Services
.
cpmm
.
sendAsyncMessage
(
"
FeedConverter
:
ExecuteClientApp
"
{
spec
title
subtitle
feedHandler
:
"
default
"
}
)
;
break
;
default
:
LOG
(
"
unexpected
handler
:
"
+
handler
)
;
case
"
bookmarks
"
:
Services
.
cpmm
.
sendAsyncMessage
(
"
FeedConverter
:
addLiveBookmark
"
{
spec
title
subtitle
}
)
;
break
;
}
}
addFeedResult
(
feedResult
)
{
if
(
feedResult
.
uri
=
=
null
)
throw
new
Error
(
"
null
URI
!
"
)
;
if
(
feedResult
.
uri
=
=
null
)
throw
new
Error
(
"
null
feedResult
!
"
)
;
let
spec
=
feedResult
.
uri
.
spec
;
if
(
!
this
.
_results
[
spec
]
)
this
.
_results
[
spec
]
=
[
]
;
this
.
_results
[
spec
]
.
push
(
feedResult
)
;
}
getFeedResult
(
uri
)
{
if
(
uri
=
=
null
)
throw
new
Error
(
"
null
URI
!
"
)
;
let
resultList
=
this
.
_results
[
uri
.
spec
]
;
for
(
let
result
of
resultList
)
{
if
(
result
.
uri
=
=
uri
)
return
result
;
}
return
null
;
}
removeFeedResult
(
uri
)
{
if
(
uri
=
=
null
)
throw
new
Error
(
"
null
URI
!
"
)
;
let
resultList
=
this
.
_results
[
uri
.
spec
]
;
if
(
!
resultList
)
return
;
let
deletions
=
0
;
for
(
let
i
=
0
;
i
<
resultList
.
length
;
+
+
i
)
{
if
(
resultList
[
i
]
.
uri
=
=
uri
)
{
delete
resultList
[
i
]
;
+
+
deletions
;
}
}
resultList
.
sort
(
)
;
resultList
.
splice
(
resultList
.
length
-
deletions
deletions
)
;
if
(
resultList
.
length
=
=
0
)
delete
this
.
_results
[
uri
.
spec
]
;
}
createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
return
this
.
QueryInterface
(
iid
)
;
}
QueryInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIFeedResultService
)
|
|
iid
.
equals
(
Ci
.
nsIFactory
)
|
|
iid
.
equals
(
Ci
.
nsISupports
)
)
return
this
;
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
}
;
var
components
=
[
FeedConverter
FeedResultService
]
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
components
)
;
