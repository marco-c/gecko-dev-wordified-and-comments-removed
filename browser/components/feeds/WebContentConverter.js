ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
function
LOG
(
str
)
{
}
const
WCCR_CLASSID
=
Components
.
ID
(
"
{
792a7e82
-
06a0
-
437c
-
af63
-
b2d12e808acc
}
"
)
;
const
WCC_CLASSID
=
Components
.
ID
(
"
{
db7ebf28
-
cc40
-
415f
-
8a51
-
1b111851df1e
}
"
)
;
const
WCC_CLASSNAME
=
"
Web
Service
Handler
"
;
const
PREF_HANDLER_EXTERNAL_PREFIX
=
"
network
.
protocol
-
handler
.
external
"
;
const
STRING_BUNDLE_URI
=
"
chrome
:
/
/
browser
/
locale
/
feeds
/
subscribe
.
properties
"
;
const
NS_ERROR_MODULE_DOM
=
2152923136
;
const
NS_ERROR_DOM_SYNTAX_ERR
=
NS_ERROR_MODULE_DOM
+
12
;
const
Utils
=
{
makeURI
(
aURL
aOriginCharset
aBaseURI
)
{
return
Services
.
io
.
newURI
(
aURL
aOriginCharset
aBaseURI
)
;
}
checkAndGetURI
(
aURIString
aContentWindow
)
{
let
uri
;
try
{
let
baseURI
=
aContentWindow
.
document
.
baseURIObject
;
uri
=
this
.
makeURI
(
aURIString
null
baseURI
)
;
}
catch
(
ex
)
{
throw
NS_ERROR_DOM_SYNTAX_ERR
;
}
if
(
uri
.
scheme
!
=
"
http
"
&
&
uri
.
scheme
!
=
"
https
"
)
{
throw
this
.
getSecurityError
(
"
Permission
denied
to
add
"
+
uri
.
spec
+
"
as
a
content
or
protocol
handler
"
aContentWindow
)
;
}
if
(
!
[
"
http
:
"
"
https
:
"
]
.
includes
(
aContentWindow
.
location
.
protocol
)
|
|
aContentWindow
.
location
.
hostname
!
=
uri
.
host
)
{
throw
this
.
getSecurityError
(
"
Permission
denied
to
add
"
+
uri
.
spec
+
"
as
a
content
or
protocol
handler
"
aContentWindow
)
;
}
if
(
!
uri
.
spec
.
includes
(
"
%
s
"
)
)
throw
NS_ERROR_DOM_SYNTAX_ERR
;
return
uri
;
}
_safeProtocols
:
new
Set
(
[
"
bitcoin
"
"
geo
"
"
im
"
"
irc
"
"
ircs
"
"
magnet
"
"
mailto
"
"
mms
"
"
news
"
"
nntp
"
"
openpgp4fpr
"
"
sip
"
"
sms
"
"
smsto
"
"
ssh
"
"
tel
"
"
urn
"
"
webcal
"
"
wtai
"
"
xmpp
"
]
)
checkProtocolHandlerAllowed
(
aProtocol
aURIString
aWindowOrNull
)
{
if
(
aProtocol
.
startsWith
(
"
web
+
"
)
)
{
if
(
!
/
[
a
-
z
]
+
/
.
test
(
aProtocol
.
substring
(
4
)
)
)
{
throw
this
.
getSecurityError
(
Permission
denied
to
add
a
protocol
handler
for
{
aProtocol
}
aWindowOrNull
)
;
}
}
else
if
(
!
this
.
_safeProtocols
.
has
(
aProtocol
)
)
{
throw
this
.
getSecurityError
(
Permission
denied
to
add
a
protocol
handler
for
{
aProtocol
}
aWindowOrNull
)
;
}
let
handler
=
Services
.
io
.
getProtocolHandler
(
aProtocol
)
;
if
(
!
(
handler
instanceof
Ci
.
nsIExternalProtocolHandler
)
)
{
throw
this
.
getSecurityError
(
Permission
denied
to
add
{
aURIString
}
as
a
protocol
handler
aWindowOrNull
)
;
}
let
pb
=
Services
.
prefs
;
let
allowed
=
pb
.
getBoolPref
(
PREF_HANDLER_EXTERNAL_PREFIX
+
"
.
"
+
aProtocol
pb
.
getBoolPref
(
PREF_HANDLER_EXTERNAL_PREFIX
+
"
-
default
"
)
)
;
if
(
!
allowed
)
{
throw
this
.
getSecurityError
(
Not
allowed
to
register
a
protocol
handler
for
{
aProtocol
}
aWindowOrNull
)
;
}
}
getSecurityError
(
errorString
aWindowOrNull
)
{
if
(
!
aWindowOrNull
)
{
return
errorString
;
}
return
new
aWindowOrNull
.
DOMException
(
errorString
"
SecurityError
"
)
;
}
}
;
function
WebContentConverterRegistrar
(
)
{
}
WebContentConverterRegistrar
.
prototype
=
{
get
stringBundle
(
)
{
let
sb
=
Services
.
strings
.
createBundle
(
STRING_BUNDLE_URI
)
;
delete
WebContentConverterRegistrar
.
prototype
.
stringBundle
;
return
WebContentConverterRegistrar
.
prototype
.
stringBundle
=
sb
;
}
_getFormattedString
(
key
params
)
{
return
this
.
stringBundle
.
formatStringFromName
(
key
params
params
.
length
)
;
}
_getString
(
key
)
{
return
this
.
stringBundle
.
GetStringFromName
(
key
)
;
}
removeProtocolHandler
(
aProtocol
aURITemplate
)
{
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
aProtocol
)
;
let
handlers
=
handlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
0
;
i
<
handlers
.
length
;
i
+
+
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
if
(
handler
.
uriTemplate
=
=
aURITemplate
)
{
handlers
.
removeElementAt
(
i
)
;
let
hs
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
hs
.
store
(
handlerInfo
)
;
return
;
}
}
catch
(
e
)
{
}
}
}
_protocolHandlerRegistered
(
aProtocol
aURITemplate
)
{
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
aProtocol
)
;
let
handlers
=
handlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
0
;
i
<
handlers
.
length
;
i
+
+
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
if
(
handler
.
uriTemplate
=
=
aURITemplate
)
return
true
;
}
catch
(
e
)
{
}
}
return
false
;
}
registerProtocolHandler
(
aProtocol
aURIString
aTitle
aBrowserOrWindow
)
{
aProtocol
=
(
aProtocol
|
|
"
"
)
.
toLowerCase
(
)
;
LOG
(
"
registerProtocolHandler
(
"
+
aProtocol
+
"
"
+
aURIString
+
"
"
+
aTitle
+
"
)
"
)
;
let
haveWindow
=
(
aBrowserOrWindow
instanceof
Ci
.
nsIDOMWindow
)
;
let
uri
;
if
(
haveWindow
)
{
uri
=
Utils
.
checkAndGetURI
(
aURIString
aBrowserOrWindow
)
;
}
else
{
uri
=
Utils
.
makeURI
(
aURIString
null
)
;
}
if
(
this
.
_protocolHandlerRegistered
(
aProtocol
uri
.
spec
)
)
{
return
;
}
let
browser
;
if
(
haveWindow
)
{
let
browserWindow
=
this
.
_getBrowserWindowForContentWindow
(
aBrowserOrWindow
)
;
browser
=
this
.
_getBrowserForContentWindow
(
browserWindow
aBrowserOrWindow
)
;
}
else
{
browser
=
aBrowserOrWindow
;
}
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
Services
.
console
.
logStringMessage
(
"
Web
page
denied
access
to
register
a
protocol
handler
inside
private
browsing
mode
"
)
;
return
;
}
Utils
.
checkProtocolHandlerAllowed
(
aProtocol
aURIString
haveWindow
?
aBrowserOrWindow
:
null
)
;
let
message
=
this
.
_getFormattedString
(
"
addProtocolHandler
"
[
aTitle
uri
.
host
aProtocol
]
)
;
let
notificationIcon
=
uri
.
prePath
+
"
/
favicon
.
ico
"
;
let
notificationValue
=
"
Protocol
Registration
:
"
+
aProtocol
;
let
addButton
=
{
label
:
this
.
_getString
(
"
addProtocolHandlerAddButton
"
)
accessKey
:
this
.
_getString
(
"
addProtocolHandlerAddButtonAccesskey
"
)
protocolInfo
:
{
protocol
:
aProtocol
uri
:
uri
.
spec
name
:
aTitle
}
callback
(
aNotification
aButtonInfo
)
{
let
protocol
=
aButtonInfo
.
protocolInfo
.
protocol
;
let
name
=
aButtonInfo
.
protocolInfo
.
name
;
let
handler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
handler
.
name
=
name
;
handler
.
uriTemplate
=
aButtonInfo
.
protocolInfo
.
uri
;
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
protocol
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
handler
)
;
handlerInfo
.
alwaysAskBeforeHandling
=
true
;
let
hs
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
hs
.
store
(
handlerInfo
)
;
}
}
;
let
notificationBox
=
browser
.
getTabBrowser
(
)
.
getNotificationBox
(
browser
)
;
notificationBox
.
appendNotification
(
message
notificationValue
notificationIcon
notificationBox
.
PRIORITY_INFO_LOW
[
addButton
]
)
;
}
_getBrowserWindowForContentWindow
(
aContentWindow
)
{
return
aContentWindow
.
docShell
.
rootTreeItem
.
domWindow
.
wrappedJSObject
;
}
_getBrowserForContentWindow
(
aBrowserWindow
aContentWindow
)
{
aContentWindow
=
aContentWindow
.
top
;
return
aBrowserWindow
.
gBrowser
.
browsers
.
find
(
(
browser
)
=
>
browser
.
contentWindow
=
=
aContentWindow
)
;
}
createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
return
this
.
QueryInterface
(
iid
)
;
}
classID
:
WCCR_CLASSID
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebContentHandlerRegistrar
Ci
.
nsIFactory
]
)
_xpcom_categories
:
[
{
category
:
"
app
-
startup
"
service
:
true
}
]
}
;
function
WebContentConverterRegistrarContent
(
)
{
}
WebContentConverterRegistrarContent
.
prototype
=
{
registerProtocolHandler
(
aProtocol
aURIString
aTitle
aBrowserOrWindow
)
{
aProtocol
=
(
aProtocol
|
|
"
"
)
.
toLowerCase
(
)
;
let
messageManager
=
aBrowserOrWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsITabChild
)
.
messageManager
;
let
uri
=
Utils
.
checkAndGetURI
(
aURIString
aBrowserOrWindow
)
;
Utils
.
checkProtocolHandlerAllowed
(
aProtocol
aURIString
aBrowserOrWindow
)
;
messageManager
.
sendAsyncMessage
(
"
WCCR
:
registerProtocolHandler
"
{
protocol
:
aProtocol
uri
:
uri
.
spec
title
:
aTitle
}
)
;
}
createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
return
this
.
QueryInterface
(
iid
)
;
}
classID
:
WCCR_CLASSID
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebContentHandlerRegistrar
Ci
.
nsIFactory
]
)
}
;
this
.
NSGetFactory
=
(
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
?
XPCOMUtils
.
generateNSGetFactory
(
[
WebContentConverterRegistrarContent
]
)
:
XPCOMUtils
.
generateNSGetFactory
(
[
WebContentConverterRegistrar
]
)
;
