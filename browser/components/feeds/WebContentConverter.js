ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
function
LOG
(
str
)
{
}
const
WCCR_CONTRACTID
=
"
mozilla
.
org
/
embeddor
.
implemented
/
web
-
content
-
handler
-
registrar
;
1
"
;
const
WCCR_CLASSID
=
Components
.
ID
(
"
{
792a7e82
-
06a0
-
437c
-
af63
-
b2d12e808acc
}
"
)
;
const
WCC_CLASSID
=
Components
.
ID
(
"
{
db7ebf28
-
cc40
-
415f
-
8a51
-
1b111851df1e
}
"
)
;
const
WCC_CLASSNAME
=
"
Web
Service
Handler
"
;
const
TYPE_MAYBE_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
feed
"
;
const
TYPE_ANY
=
"
*
/
*
"
;
const
PREF_CONTENTHANDLERS_AUTO
=
"
browser
.
contentHandlers
.
auto
.
"
;
const
PREF_CONTENTHANDLERS_BRANCH
=
"
browser
.
contentHandlers
.
types
.
"
;
const
PREF_SELECTED_WEB
=
"
browser
.
feeds
.
handlers
.
webservice
"
;
const
PREF_SELECTED_ACTION
=
"
browser
.
feeds
.
handler
"
;
const
PREF_SELECTED_READER
=
"
browser
.
feeds
.
handler
.
default
"
;
const
PREF_HANDLER_EXTERNAL_PREFIX
=
"
network
.
protocol
-
handler
.
external
"
;
const
STRING_BUNDLE_URI
=
"
chrome
:
/
/
browser
/
locale
/
feeds
/
subscribe
.
properties
"
;
const
NS_ERROR_MODULE_DOM
=
2152923136
;
const
NS_ERROR_DOM_SYNTAX_ERR
=
NS_ERROR_MODULE_DOM
+
12
;
function
WebContentConverter
(
)
{
}
WebContentConverter
.
prototype
=
{
convert
(
)
{
}
asyncConvertData
(
)
{
}
onDataAvailable
(
)
{
}
onStopRequest
(
)
{
}
onStartRequest
(
request
context
)
{
let
wccr
=
Cc
[
WCCR_CONTRACTID
]
.
getService
(
Ci
.
nsIWebContentConverterService
)
;
wccr
.
loadPreferredHandler
(
request
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIStreamConverter
"
"
nsIStreamListener
"
]
)
}
;
let
WebContentConverterFactory
=
{
createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
return
new
WebContentConverter
(
)
.
QueryInterface
(
iid
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIFactory
"
]
)
}
;
function
ServiceInfo
(
contentType
uri
name
)
{
this
.
_contentType
=
contentType
;
this
.
_uri
=
uri
;
this
.
_name
=
name
;
}
ServiceInfo
.
prototype
=
{
get
name
(
)
{
return
this
.
_name
;
}
equals
(
aHandlerApp
)
{
if
(
!
aHandlerApp
)
throw
Cr
.
NS_ERROR_NULL_POINTER
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebContentHandlerInfo
&
&
aHandlerApp
.
contentType
=
=
this
.
contentType
&
&
aHandlerApp
.
uri
=
=
this
.
uri
)
return
true
;
return
false
;
}
get
contentType
(
)
{
return
this
.
_contentType
;
}
get
uri
(
)
{
return
this
.
_uri
;
}
getHandlerURI
(
uri
)
{
return
this
.
_uri
.
replace
(
/
%
s
/
gi
encodeURIComponent
(
uri
)
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebContentHandlerInfo
"
]
)
}
;
const
Utils
=
{
makeURI
(
aURL
aOriginCharset
aBaseURI
)
{
return
Services
.
io
.
newURI
(
aURL
aOriginCharset
aBaseURI
)
;
}
checkAndGetURI
(
aURIString
aContentWindow
)
{
let
uri
;
try
{
let
baseURI
=
aContentWindow
.
document
.
baseURIObject
;
uri
=
this
.
makeURI
(
aURIString
null
baseURI
)
;
}
catch
(
ex
)
{
throw
NS_ERROR_DOM_SYNTAX_ERR
;
}
if
(
uri
.
scheme
!
=
"
http
"
&
&
uri
.
scheme
!
=
"
https
"
)
{
throw
this
.
getSecurityError
(
"
Permission
denied
to
add
"
+
uri
.
spec
+
"
as
a
content
or
protocol
handler
"
aContentWindow
)
;
}
if
(
!
[
"
http
:
"
"
https
:
"
]
.
includes
(
aContentWindow
.
location
.
protocol
)
|
|
aContentWindow
.
location
.
hostname
!
=
uri
.
host
)
{
throw
this
.
getSecurityError
(
"
Permission
denied
to
add
"
+
uri
.
spec
+
"
as
a
content
or
protocol
handler
"
aContentWindow
)
;
}
if
(
!
uri
.
spec
.
includes
(
"
%
s
"
)
)
throw
NS_ERROR_DOM_SYNTAX_ERR
;
return
uri
;
}
_safeProtocols
:
new
Set
(
[
"
bitcoin
"
"
geo
"
"
im
"
"
irc
"
"
ircs
"
"
magnet
"
"
mailto
"
"
mms
"
"
news
"
"
nntp
"
"
openpgp4fpr
"
"
sip
"
"
sms
"
"
smsto
"
"
ssh
"
"
tel
"
"
urn
"
"
webcal
"
"
wtai
"
"
xmpp
"
]
)
checkProtocolHandlerAllowed
(
aProtocol
aURIString
aWindowOrNull
)
{
if
(
aProtocol
.
startsWith
(
"
web
+
"
)
)
{
if
(
!
/
[
a
-
z
]
+
/
.
test
(
aProtocol
.
substring
(
4
)
)
)
{
throw
this
.
getSecurityError
(
Permission
denied
to
add
a
protocol
handler
for
{
aProtocol
}
aWindowOrNull
)
;
}
}
else
if
(
!
this
.
_safeProtocols
.
has
(
aProtocol
)
)
{
throw
this
.
getSecurityError
(
Permission
denied
to
add
a
protocol
handler
for
{
aProtocol
}
aWindowOrNull
)
;
}
let
handler
=
Services
.
io
.
getProtocolHandler
(
aProtocol
)
;
if
(
!
(
handler
instanceof
Ci
.
nsIExternalProtocolHandler
)
)
{
throw
this
.
getSecurityError
(
Permission
denied
to
add
{
aURIString
}
as
a
protocol
handler
aWindowOrNull
)
;
}
let
pb
=
Services
.
prefs
;
let
allowed
=
pb
.
getBoolPref
(
PREF_HANDLER_EXTERNAL_PREFIX
+
"
.
"
+
aProtocol
pb
.
getBoolPref
(
PREF_HANDLER_EXTERNAL_PREFIX
+
"
-
default
"
)
)
;
if
(
!
allowed
)
{
throw
this
.
getSecurityError
(
Not
allowed
to
register
a
protocol
handler
for
{
aProtocol
}
aWindowOrNull
)
;
}
}
getSecurityError
(
errorString
aWindowOrNull
)
{
if
(
!
aWindowOrNull
)
{
return
errorString
;
}
return
new
aWindowOrNull
.
DOMException
(
errorString
"
SecurityError
"
)
;
}
_mappings
:
{
"
application
/
rss
+
xml
"
:
TYPE_MAYBE_FEED
"
application
/
atom
+
xml
"
:
TYPE_MAYBE_FEED
}
resolveContentType
(
aContentType
)
{
if
(
aContentType
in
this
.
_mappings
)
return
this
.
_mappings
[
aContentType
]
;
return
aContentType
;
}
}
;
function
WebContentConverterRegistrar
(
)
{
this
.
_contentTypes
=
{
}
;
this
.
_autoHandleContentTypes
=
{
}
;
}
WebContentConverterRegistrar
.
prototype
=
{
get
stringBundle
(
)
{
let
sb
=
Services
.
strings
.
createBundle
(
STRING_BUNDLE_URI
)
;
delete
WebContentConverterRegistrar
.
prototype
.
stringBundle
;
return
WebContentConverterRegistrar
.
prototype
.
stringBundle
=
sb
;
}
_getFormattedString
(
key
params
)
{
return
this
.
stringBundle
.
formatStringFromName
(
key
params
params
.
length
)
;
}
_getString
(
key
)
{
return
this
.
stringBundle
.
GetStringFromName
(
key
)
;
}
getAutoHandler
(
contentType
)
{
contentType
=
Utils
.
resolveContentType
(
contentType
)
;
if
(
contentType
in
this
.
_autoHandleContentTypes
)
return
this
.
_autoHandleContentTypes
[
contentType
]
;
return
null
;
}
setAutoHandler
(
contentType
handler
)
{
if
(
handler
&
&
!
this
.
_typeIsRegistered
(
contentType
handler
.
uri
)
)
throw
Cr
.
NS_ERROR_NOT_AVAILABLE
;
contentType
=
Utils
.
resolveContentType
(
contentType
)
;
this
.
_setAutoHandler
(
contentType
handler
)
;
let
ps
=
Services
.
prefs
;
let
autoBranch
=
ps
.
getBranch
(
PREF_CONTENTHANDLERS_AUTO
)
;
if
(
handler
)
autoBranch
.
setCharPref
(
contentType
handler
.
uri
)
;
else
if
(
autoBranch
.
prefHasUserValue
(
contentType
)
)
autoBranch
.
clearUserPref
(
contentType
)
;
ps
.
savePrefFile
(
null
)
;
}
_setAutoHandler
(
contentType
handler
)
{
if
(
handler
)
this
.
_autoHandleContentTypes
[
contentType
]
=
handler
;
else
if
(
contentType
in
this
.
_autoHandleContentTypes
)
delete
this
.
_autoHandleContentTypes
[
contentType
]
;
}
getWebContentHandlerByURI
(
contentType
uri
)
{
return
this
.
getContentHandlers
(
contentType
)
.
find
(
e
=
>
e
.
uri
=
=
uri
)
|
|
null
;
}
loadPreferredHandler
(
request
)
{
let
channel
=
request
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
contentType
=
Utils
.
resolveContentType
(
channel
.
contentType
)
;
let
handler
=
this
.
getAutoHandler
(
contentType
)
;
if
(
handler
)
{
request
.
cancel
(
Cr
.
NS_ERROR_FAILURE
)
;
let
triggeringPrincipal
=
channel
.
loadInfo
?
channel
.
loadInfo
.
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
let
webNavigation
=
channel
.
notificationCallbacks
.
getInterface
(
Ci
.
nsIWebNavigation
)
;
webNavigation
.
loadURI
(
handler
.
getHandlerURI
(
channel
.
URI
.
spec
)
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
null
null
null
triggeringPrincipal
)
;
}
}
removeProtocolHandler
(
aProtocol
aURITemplate
)
{
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
aProtocol
)
;
let
handlers
=
handlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
0
;
i
<
handlers
.
length
;
i
+
+
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
if
(
handler
.
uriTemplate
=
=
aURITemplate
)
{
handlers
.
removeElementAt
(
i
)
;
let
hs
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
hs
.
store
(
handlerInfo
)
;
return
;
}
}
catch
(
e
)
{
}
}
}
removeContentHandler
(
contentType
uri
)
{
function
notURI
(
serviceInfo
)
{
return
serviceInfo
.
uri
!
=
uri
;
}
if
(
contentType
in
this
.
_contentTypes
)
{
this
.
_contentTypes
[
contentType
]
=
this
.
_contentTypes
[
contentType
]
.
filter
(
notURI
)
;
}
}
_blockedTypes
:
{
"
application
/
vnd
.
mozilla
.
maybe
.
feed
"
:
true
}
_protocolHandlerRegistered
(
aProtocol
aURITemplate
)
{
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
aProtocol
)
;
let
handlers
=
handlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
0
;
i
<
handlers
.
length
;
i
+
+
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
if
(
handler
.
uriTemplate
=
=
aURITemplate
)
return
true
;
}
catch
(
e
)
{
}
}
return
false
;
}
registerProtocolHandler
(
aProtocol
aURIString
aTitle
aBrowserOrWindow
)
{
aProtocol
=
(
aProtocol
|
|
"
"
)
.
toLowerCase
(
)
;
LOG
(
"
registerProtocolHandler
(
"
+
aProtocol
+
"
"
+
aURIString
+
"
"
+
aTitle
+
"
)
"
)
;
let
haveWindow
=
(
aBrowserOrWindow
instanceof
Ci
.
nsIDOMWindow
)
;
let
uri
;
if
(
haveWindow
)
{
uri
=
Utils
.
checkAndGetURI
(
aURIString
aBrowserOrWindow
)
;
}
else
{
uri
=
Utils
.
makeURI
(
aURIString
null
)
;
}
if
(
this
.
_protocolHandlerRegistered
(
aProtocol
uri
.
spec
)
)
{
return
;
}
let
browser
;
if
(
haveWindow
)
{
let
browserWindow
=
this
.
_getBrowserWindowForContentWindow
(
aBrowserOrWindow
)
;
browser
=
this
.
_getBrowserForContentWindow
(
browserWindow
aBrowserOrWindow
)
;
}
else
{
browser
=
aBrowserOrWindow
;
}
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
Services
.
console
.
logStringMessage
(
"
Web
page
denied
access
to
register
a
protocol
handler
inside
private
browsing
mode
"
)
;
return
;
}
Utils
.
checkProtocolHandlerAllowed
(
aProtocol
aURIString
haveWindow
?
aBrowserOrWindow
:
null
)
;
let
message
=
this
.
_getFormattedString
(
"
addProtocolHandler
"
[
aTitle
uri
.
host
aProtocol
]
)
;
let
notificationIcon
=
uri
.
prePath
+
"
/
favicon
.
ico
"
;
let
notificationValue
=
"
Protocol
Registration
:
"
+
aProtocol
;
let
addButton
=
{
label
:
this
.
_getString
(
"
addProtocolHandlerAddButton
"
)
accessKey
:
this
.
_getString
(
"
addProtocolHandlerAddButtonAccesskey
"
)
protocolInfo
:
{
protocol
:
aProtocol
uri
:
uri
.
spec
name
:
aTitle
}
callback
(
aNotification
aButtonInfo
)
{
let
protocol
=
aButtonInfo
.
protocolInfo
.
protocol
;
let
name
=
aButtonInfo
.
protocolInfo
.
name
;
let
handler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
handler
.
name
=
name
;
handler
.
uriTemplate
=
aButtonInfo
.
protocolInfo
.
uri
;
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
protocol
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
handler
)
;
handlerInfo
.
alwaysAskBeforeHandling
=
true
;
let
hs
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
hs
.
store
(
handlerInfo
)
;
}
}
;
let
notificationBox
=
browser
.
getTabBrowser
(
)
.
getNotificationBox
(
browser
)
;
notificationBox
.
appendNotification
(
message
notificationValue
notificationIcon
notificationBox
.
PRIORITY_INFO_LOW
[
addButton
]
)
;
}
registerContentHandler
(
aContentType
aURIString
aTitle
aWindowOrBrowser
)
{
LOG
(
"
registerContentHandler
(
"
+
aContentType
+
"
"
+
aURIString
+
"
"
+
aTitle
+
"
)
"
)
;
let
haveWindow
=
aWindowOrBrowser
&
&
(
aWindowOrBrowser
instanceof
Ci
.
nsIDOMWindow
)
;
let
uri
;
if
(
haveWindow
)
{
uri
=
Utils
.
checkAndGetURI
(
aURIString
aWindowOrBrowser
)
;
}
else
if
(
aWindowOrBrowser
)
{
uri
=
Utils
.
makeURI
(
aURIString
null
)
;
}
let
contentType
=
Utils
.
resolveContentType
(
aContentType
)
;
if
(
contentType
!
=
TYPE_MAYBE_FEED
)
{
return
;
}
if
(
aWindowOrBrowser
)
{
let
notificationBox
;
if
(
haveWindow
)
{
let
browserWindow
=
this
.
_getBrowserWindowForContentWindow
(
aWindowOrBrowser
)
;
let
browserElement
=
this
.
_getBrowserForContentWindow
(
browserWindow
aWindowOrBrowser
)
;
notificationBox
=
browserElement
.
getTabBrowser
(
)
.
getNotificationBox
(
browserElement
)
;
}
else
{
notificationBox
=
aWindowOrBrowser
.
getTabBrowser
(
)
.
getNotificationBox
(
aWindowOrBrowser
)
;
}
this
.
_appendFeedReaderNotification
(
uri
aTitle
notificationBox
)
;
}
else
{
this
.
_registerContentHandler
(
contentType
aURIString
aTitle
)
;
}
}
_getBrowserWindowForContentWindow
(
aContentWindow
)
{
return
aContentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
.
wrappedJSObject
;
}
_getBrowserForContentWindow
(
aBrowserWindow
aContentWindow
)
{
aContentWindow
=
aContentWindow
.
top
;
return
aBrowserWindow
.
gBrowser
.
browsers
.
find
(
(
browser
)
=
>
browser
.
contentWindow
=
=
aContentWindow
)
;
}
_appendFeedReaderNotification
(
aURI
aName
aNotificationBox
)
{
let
uriSpec
=
aURI
.
spec
;
let
notificationValue
=
"
feed
reader
notification
:
"
+
uriSpec
;
let
notificationIcon
=
aURI
.
prePath
+
"
/
favicon
.
ico
"
;
if
(
aNotificationBox
.
getNotificationWithValue
(
notificationValue
)
)
return
false
;
let
buttons
;
let
message
;
if
(
this
.
getWebContentHandlerByURI
(
TYPE_MAYBE_FEED
uriSpec
)
)
message
=
this
.
_getFormattedString
(
"
handlerRegistered
"
[
aName
]
)
;
else
{
message
=
this
.
_getFormattedString
(
"
addHandler
"
[
aName
aURI
.
host
]
)
;
let
self
=
this
;
let
addButton
=
{
_outer
:
self
label
:
self
.
_getString
(
"
addHandlerAddButton
"
)
accessKey
:
self
.
_getString
(
"
addHandlerAddButtonAccesskey
"
)
feedReaderInfo
:
{
uri
:
uriSpec
name
:
aName
}
callback
(
aNotification
aButtonInfo
)
{
let
uri
=
aButtonInfo
.
feedReaderInfo
.
uri
;
let
name
=
aButtonInfo
.
feedReaderInfo
.
name
;
let
outer
=
aButtonInfo
.
_outer
;
if
(
!
outer
.
getWebContentHandlerByURI
(
TYPE_MAYBE_FEED
uri
)
)
outer
.
_registerContentHandler
(
TYPE_MAYBE_FEED
uri
name
)
;
aButtonInfo
.
_outer
=
null
;
return
false
;
}
}
;
buttons
=
[
addButton
]
;
}
aNotificationBox
.
appendNotification
(
message
notificationValue
notificationIcon
aNotificationBox
.
PRIORITY_INFO_LOW
buttons
)
;
return
true
;
}
_saveContentHandlerToPrefs
(
contentType
uri
title
)
{
let
ps
=
Services
.
prefs
;
let
i
=
0
;
let
typeBranch
=
null
;
while
(
true
)
{
typeBranch
=
ps
.
getBranch
(
PREF_CONTENTHANDLERS_BRANCH
+
i
+
"
.
"
)
;
try
{
typeBranch
.
getCharPref
(
"
type
"
)
;
+
+
i
;
}
catch
(
e
)
{
break
;
}
}
if
(
typeBranch
)
{
typeBranch
.
setCharPref
(
"
type
"
contentType
)
;
let
pls
=
Cc
[
"
mozilla
.
org
/
pref
-
localizedstring
;
1
"
]
.
createInstance
(
Ci
.
nsIPrefLocalizedString
)
;
pls
.
data
=
uri
;
typeBranch
.
setComplexValue
(
"
uri
"
Ci
.
nsIPrefLocalizedString
pls
)
;
pls
.
data
=
title
;
typeBranch
.
setComplexValue
(
"
title
"
Ci
.
nsIPrefLocalizedString
pls
)
;
ps
.
savePrefFile
(
null
)
;
}
}
_typeIsRegistered
(
contentType
uri
)
{
if
(
!
(
contentType
in
this
.
_contentTypes
)
)
return
false
;
return
this
.
_contentTypes
[
contentType
]
.
some
(
t
=
>
t
.
uri
=
=
uri
)
;
}
_getConverterContractID
(
contentType
)
{
const
template
=
"
mozilla
.
org
/
streamconv
;
1
?
from
=
%
s
&
to
=
*
/
*
"
;
return
template
.
replace
(
/
%
s
/
contentType
)
;
}
_registerContentHandler
(
contentType
uri
title
)
{
this
.
_updateContentTypeHandlerMap
(
contentType
uri
title
)
;
this
.
_saveContentHandlerToPrefs
(
contentType
uri
title
)
;
if
(
contentType
=
=
TYPE_MAYBE_FEED
)
{
let
pb
=
Services
.
prefs
.
getBranch
(
null
)
;
pb
.
setCharPref
(
PREF_SELECTED_READER
"
web
"
)
;
pb
.
setStringPref
(
PREF_SELECTED_WEB
uri
)
;
pb
.
setCharPref
(
PREF_SELECTED_ACTION
"
ask
"
)
;
this
.
_setAutoHandler
(
TYPE_MAYBE_FEED
null
)
;
}
}
_updateContentTypeHandlerMap
(
contentType
uri
title
)
{
if
(
!
(
contentType
in
this
.
_contentTypes
)
)
this
.
_contentTypes
[
contentType
]
=
[
]
;
if
(
this
.
_typeIsRegistered
(
contentType
uri
)
)
return
;
this
.
_contentTypes
[
contentType
]
.
push
(
new
ServiceInfo
(
contentType
uri
title
)
)
;
if
(
!
(
contentType
in
this
.
_blockedTypes
)
)
{
let
converterContractID
=
this
.
_getConverterContractID
(
contentType
)
;
let
cr
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
cr
.
registerFactory
(
WCC_CLASSID
WCC_CLASSNAME
converterContractID
WebContentConverterFactory
)
;
}
}
getContentHandlers
(
contentType
countRef
)
{
if
(
countRef
)
{
countRef
.
value
=
0
;
}
if
(
!
(
contentType
in
this
.
_contentTypes
)
)
return
[
]
;
let
handlers
=
this
.
_contentTypes
[
contentType
]
;
if
(
countRef
)
{
countRef
.
value
=
handlers
.
length
;
}
return
handlers
;
}
resetHandlersForType
(
contentType
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
_registerContentHandlerHavingBranch
(
branch
)
{
let
vals
=
branch
.
getChildList
(
"
"
)
;
if
(
vals
.
length
=
=
0
)
return
;
let
type
=
branch
.
getCharPref
(
"
type
"
)
;
let
uri
=
branch
.
getComplexValue
(
"
uri
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
let
title
=
branch
.
getComplexValue
(
"
title
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
this
.
_updateContentTypeHandlerMap
(
type
uri
title
)
;
}
_init
(
)
{
let
ps
=
Services
.
prefs
;
let
children
=
ps
.
getBranch
(
PREF_CONTENTHANDLERS_BRANCH
)
.
getChildList
(
"
"
)
;
let
nums
=
children
.
map
(
(
child
)
=
>
{
let
match
=
/
^
(
\
d
+
)
\
.
uri
/
.
exec
(
child
)
;
return
match
?
match
[
1
]
:
"
"
;
}
)
.
filter
(
child
=
>
!
!
child
)
.
sort
(
)
;
for
(
let
num
of
nums
)
{
let
branch
=
ps
.
getBranch
(
PREF_CONTENTHANDLERS_BRANCH
+
num
+
"
.
"
)
;
try
{
this
.
_registerContentHandlerHavingBranch
(
branch
)
;
}
catch
(
ex
)
{
}
}
let
autoBranch
;
try
{
autoBranch
=
ps
.
getBranch
(
PREF_CONTENTHANDLERS_AUTO
)
;
}
catch
(
e
)
{
}
if
(
autoBranch
)
{
for
(
let
type
of
autoBranch
.
getChildList
(
"
"
)
)
{
let
uri
=
autoBranch
.
getCharPref
(
type
)
;
if
(
uri
)
{
let
handler
=
this
.
getWebContentHandlerByURI
(
type
uri
)
;
if
(
handler
)
{
this
.
_setAutoHandler
(
type
handler
)
;
}
}
}
}
}
observe
(
subject
topic
data
)
{
let
os
=
Services
.
obs
;
switch
(
topic
)
{
case
"
app
-
startup
"
:
os
.
addObserver
(
this
"
browser
-
ui
-
startup
-
complete
"
)
;
break
;
case
"
browser
-
ui
-
startup
-
complete
"
:
os
.
removeObserver
(
this
"
browser
-
ui
-
startup
-
complete
"
)
;
this
.
_init
(
)
;
break
;
}
}
createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
return
this
.
QueryInterface
(
iid
)
;
}
classID
:
WCCR_CLASSID
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebContentConverterService
Ci
.
nsIWebContentHandlerRegistrar
Ci
.
nsIObserver
Ci
.
nsIFactory
]
)
_xpcom_categories
:
[
{
category
:
"
app
-
startup
"
service
:
true
}
]
}
;
function
WebContentConverterRegistrarContent
(
)
{
this
.
_contentTypes
=
{
}
;
}
WebContentConverterRegistrarContent
.
prototype
=
{
_init
(
)
{
let
ps
=
Services
.
prefs
;
let
children
=
ps
.
getBranch
(
PREF_CONTENTHANDLERS_BRANCH
)
.
getChildList
(
"
"
)
;
let
nums
=
children
.
map
(
(
child
)
=
>
{
let
match
=
/
^
(
\
d
+
)
\
.
uri
/
.
exec
(
child
)
;
return
match
?
match
[
1
]
:
"
"
;
}
)
.
filter
(
child
=
>
!
!
child
)
.
sort
(
)
;
for
(
let
num
of
nums
)
{
let
branch
=
ps
.
getBranch
(
PREF_CONTENTHANDLERS_BRANCH
+
num
+
"
.
"
)
;
try
{
this
.
_registerContentHandlerHavingBranch
(
branch
)
;
}
catch
(
ex
)
{
}
}
}
_typeIsRegistered
(
contentType
uri
)
{
return
this
.
_contentTypes
[
contentType
]
.
some
(
e
=
>
e
.
uri
=
=
uri
)
;
}
_registerContentHandlerHavingBranch
(
branch
)
{
let
vals
=
branch
.
getChildList
(
"
"
)
;
if
(
vals
.
length
=
=
0
)
return
;
let
type
=
branch
.
getCharPref
(
"
type
"
)
;
let
uri
=
branch
.
getComplexValue
(
"
uri
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
let
title
=
branch
.
getComplexValue
(
"
title
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
this
.
_updateContentTypeHandlerMap
(
type
uri
title
)
;
}
_updateContentTypeHandlerMap
(
contentType
uri
title
)
{
if
(
!
(
contentType
in
this
.
_contentTypes
)
)
this
.
_contentTypes
[
contentType
]
=
[
]
;
if
(
this
.
_typeIsRegistered
(
contentType
uri
)
)
return
;
this
.
_contentTypes
[
contentType
]
.
push
(
new
ServiceInfo
(
contentType
uri
title
)
)
;
if
(
!
(
contentType
in
this
.
_blockedTypes
)
)
{
let
converterContractID
=
this
.
_getConverterContractID
(
contentType
)
;
let
cr
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
cr
.
registerFactory
(
WCC_CLASSID
WCC_CLASSNAME
converterContractID
WebContentConverterFactory
)
;
}
}
getContentHandlers
(
contentType
countRef
)
{
this
.
_init
(
)
;
if
(
countRef
)
{
countRef
.
value
=
0
;
}
if
(
!
(
contentType
in
this
.
_contentTypes
)
)
return
[
]
;
let
handlers
=
this
.
_contentTypes
[
contentType
]
;
if
(
countRef
)
{
countRef
.
value
=
handlers
.
length
;
}
return
handlers
;
}
setAutoHandler
(
contentType
handler
)
{
Services
.
cpmm
.
sendAsyncMessage
(
"
WCCR
:
setAutoHandler
"
{
contentType
handler
}
)
;
}
getWebContentHandlerByURI
(
contentType
uri
)
{
return
this
.
getContentHandlers
(
contentType
)
.
find
(
e
=
>
e
.
uri
=
=
uri
)
|
|
null
;
}
registerContentHandler
(
aContentType
aURIString
aTitle
aBrowserOrWindow
)
{
let
messageManager
=
aBrowserOrWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsITabChild
)
.
messageManager
;
let
uri
=
Utils
.
checkAndGetURI
(
aURIString
aBrowserOrWindow
)
;
if
(
Utils
.
resolveContentType
(
aContentType
)
!
=
TYPE_MAYBE_FEED
)
{
return
;
}
messageManager
.
sendAsyncMessage
(
"
WCCR
:
registerContentHandler
"
{
contentType
:
aContentType
uri
:
uri
.
spec
title
:
aTitle
}
)
;
}
registerProtocolHandler
(
aProtocol
aURIString
aTitle
aBrowserOrWindow
)
{
aProtocol
=
(
aProtocol
|
|
"
"
)
.
toLowerCase
(
)
;
let
messageManager
=
aBrowserOrWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsITabChild
)
.
messageManager
;
let
uri
=
Utils
.
checkAndGetURI
(
aURIString
aBrowserOrWindow
)
;
Utils
.
checkProtocolHandlerAllowed
(
aProtocol
aURIString
aBrowserOrWindow
)
;
messageManager
.
sendAsyncMessage
(
"
WCCR
:
registerProtocolHandler
"
{
protocol
:
aProtocol
uri
:
uri
.
spec
title
:
aTitle
}
)
;
}
createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
return
this
.
QueryInterface
(
iid
)
;
}
classID
:
WCCR_CLASSID
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebContentHandlerRegistrar
Ci
.
nsIWebContentConverterService
Ci
.
nsIFactory
]
)
}
;
this
.
NSGetFactory
=
(
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
?
XPCOMUtils
.
generateNSGetFactory
(
[
WebContentConverterRegistrarContent
]
)
:
XPCOMUtils
.
generateNSGetFactory
(
[
WebContentConverterRegistrar
]
)
;
