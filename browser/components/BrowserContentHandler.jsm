var
EXPORTED_SYMBOLS
=
[
"
nsBrowserContentHandler
"
"
nsDefaultCommandLineHandler
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
HeadlessShell
:
"
resource
:
/
/
/
modules
/
HeadlessShell
.
jsm
"
HomePage
:
"
resource
:
/
/
/
modules
/
HomePage
.
jsm
"
FirstStartup
:
"
resource
:
/
/
gre
/
modules
/
FirstStartup
.
jsm
"
LaterRun
:
"
resource
:
/
/
/
modules
/
LaterRun
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
SessionStartup
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStartup
.
jsm
"
ShellService
:
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
UpdatePing
:
"
resource
:
/
/
gre
/
modules
/
UpdatePing
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
UpdateManager
:
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
"
nsIUpdateManager
"
]
WinTaskbar
:
[
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
"
nsIWinTaskbar
"
]
WindowsUIUtils
:
[
"
mozilla
.
org
/
windows
-
ui
-
utils
;
1
"
"
nsIWindowsUIUtils
"
]
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gSystemPrincipal
"
(
)
=
>
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
const
ONCE_DOMAINS
=
[
"
mozilla
.
org
"
"
firefox
.
com
"
]
;
const
ONCE_PREF
=
"
browser
.
startup
.
homepage_override
.
once
"
;
const
PRIVATE_BROWSING_ICON_INDEX
=
5
;
function
shouldLoadURI
(
aURI
)
{
if
(
aURI
&
&
!
aURI
.
schemeIs
(
"
chrome
"
)
)
{
return
true
;
}
dump
(
"
*
*
*
Preventing
external
load
of
chrome
:
URI
into
browser
window
\
n
"
)
;
dump
(
"
Use
-
-
chrome
<
uri
>
instead
\
n
"
)
;
return
false
;
}
function
resolveURIInternal
(
aCmdLine
aArgument
)
{
var
uri
=
aCmdLine
.
resolveURI
(
aArgument
)
;
var
uriFixup
=
Services
.
uriFixup
;
if
(
!
(
uri
instanceof
Ci
.
nsIFileURL
)
)
{
return
Services
.
uriFixup
.
getFixupURIInfo
(
aArgument
uriFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
)
.
preferredURI
;
}
try
{
if
(
uri
.
file
.
exists
(
)
)
{
return
uri
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
try
{
uri
=
Services
.
uriFixup
.
getFixupURIInfo
(
aArgument
)
.
preferredURI
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
uri
;
}
let
gKiosk
=
false
;
let
gMajorUpgrade
=
false
;
var
gFirstWindow
=
false
;
const
OVERRIDE_NONE
=
0
;
const
OVERRIDE_NEW_PROFILE
=
1
;
const
OVERRIDE_NEW_MSTONE
=
2
;
const
OVERRIDE_NEW_BUILD_ID
=
3
;
function
needHomepageOverride
(
prefb
)
{
var
savedmstone
=
prefb
.
getCharPref
(
"
browser
.
startup
.
homepage_override
.
mstone
"
"
"
)
;
if
(
savedmstone
=
=
"
ignore
"
)
{
return
OVERRIDE_NONE
;
}
var
mstone
=
Services
.
appinfo
.
platformVersion
;
var
savedBuildID
=
prefb
.
getCharPref
(
"
browser
.
startup
.
homepage_override
.
buildID
"
"
"
)
;
var
buildID
=
Services
.
appinfo
.
platformBuildID
;
if
(
mstone
!
=
savedmstone
)
{
if
(
savedmstone
)
{
prefb
.
setBoolPref
(
"
browser
.
rights
.
3
.
shown
"
true
)
;
gMajorUpgrade
=
true
;
}
prefb
.
setCharPref
(
"
browser
.
startup
.
homepage_override
.
mstone
"
mstone
)
;
prefb
.
setCharPref
(
"
browser
.
startup
.
homepage_override
.
buildID
"
buildID
)
;
return
savedmstone
?
OVERRIDE_NEW_MSTONE
:
OVERRIDE_NEW_PROFILE
;
}
if
(
buildID
!
=
savedBuildID
)
{
prefb
.
setCharPref
(
"
browser
.
startup
.
homepage_override
.
buildID
"
buildID
)
;
return
OVERRIDE_NEW_BUILD_ID
;
}
return
OVERRIDE_NONE
;
}
function
getPostUpdateOverridePage
(
update
defaultOverridePage
)
{
update
=
update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
let
actions
=
update
.
getProperty
(
"
actions
"
)
;
if
(
!
actions
)
{
return
defaultOverridePage
;
}
if
(
actions
.
includes
(
"
silent
"
)
|
|
!
actions
.
includes
(
"
showURL
"
)
)
{
return
"
"
;
}
if
(
!
Services
.
policies
.
isAllowed
(
"
postUpdateCustomPage
"
)
)
{
return
defaultOverridePage
;
}
return
update
.
getProperty
(
"
openURL
"
)
|
|
defaultOverridePage
;
}
function
openBrowserWindow
(
cmdLine
triggeringPrincipal
urlOrUrlList
postData
=
null
forcePrivate
=
false
)
{
let
chromeURL
=
AppConstants
.
BROWSER_CHROME_URL
;
const
isStartup
=
cmdLine
&
&
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_INITIAL_LAUNCH
;
let
args
;
if
(
!
urlOrUrlList
)
{
args
=
[
gBrowserContentHandler
.
getArgs
(
isStartup
)
]
;
}
else
if
(
Array
.
isArray
(
urlOrUrlList
)
)
{
if
(
!
triggeringPrincipal
|
|
!
triggeringPrincipal
.
equals
(
lazy
.
gSystemPrincipal
)
)
{
throw
new
Error
(
"
Can
'
t
open
multiple
URLs
with
something
other
than
system
principal
.
"
)
;
}
let
uriArray
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
urlOrUrlList
.
forEach
(
function
(
uri
)
{
var
sstring
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
sstring
.
data
=
uri
;
uriArray
.
appendElement
(
sstring
)
;
}
)
;
args
=
[
uriArray
]
;
}
else
{
let
extraOptions
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag2
)
;
extraOptions
.
setPropertyAsBool
(
"
fromExternal
"
true
)
;
args
=
[
urlOrUrlList
extraOptions
null
postData
undefined
undefined
null
null
triggeringPrincipal
]
;
}
if
(
isStartup
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
blank
"
)
;
if
(
win
)
{
win
.
document
.
documentElement
.
removeAttribute
(
"
windowtype
"
)
;
if
(
forcePrivate
)
{
win
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
.
usePrivateBrowsing
=
true
;
if
(
lazy
.
NimbusFeatures
.
majorRelease2022
.
getVariable
(
"
feltPrivacyWindowSeparation
"
)
)
{
lazy
.
WinTaskbar
.
setGroupIdForWindow
(
win
lazy
.
WinTaskbar
.
defaultPrivateGroupId
)
;
lazy
.
WindowsUIUtils
.
setWindowIconFromExe
(
win
Services
.
dirsvc
.
get
(
"
XREExeF
"
Ci
.
nsIFile
)
.
path
PRIVATE_BROWSING_ICON_INDEX
)
;
}
}
let
openTime
=
win
.
openTime
;
win
.
location
=
chromeURL
;
win
.
arguments
=
args
;
ChromeUtils
.
addProfilerMarker
(
"
earlyBlankWindowVisible
"
openTime
)
;
return
win
;
}
}
if
(
!
urlOrUrlList
)
{
let
[
url
]
=
args
;
args
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
args
.
data
=
url
;
}
else
{
if
(
args
.
length
>
1
)
{
let
string
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
string
.
data
=
args
[
0
]
;
args
[
0
]
=
string
;
}
let
array
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
args
.
forEach
(
a
=
>
{
array
.
appendElement
(
a
)
;
}
)
;
args
=
array
;
}
let
features
=
"
chrome
dialog
=
no
all
"
+
gBrowserContentHandler
.
getFeatures
(
cmdLine
)
;
if
(
forcePrivate
)
{
features
+
=
"
private
"
;
}
return
Services
.
ww
.
openWindow
(
null
chromeURL
"
_blank
"
features
args
)
;
}
function
openPreferences
(
cmdLine
extraArgs
)
{
openBrowserWindow
(
cmdLine
lazy
.
gSystemPrincipal
"
about
:
preferences
"
)
;
}
async
function
doSearch
(
searchTerm
cmdLine
)
{
let
win
=
openBrowserWindow
(
cmdLine
lazy
.
gSystemPrincipal
"
about
:
blank
"
)
;
await
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observe
(
subject
)
{
if
(
subject
=
=
win
)
{
Services
.
obs
.
removeObserver
(
observe
"
browser
-
delayed
-
startup
-
finished
"
)
;
resolve
(
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
win
.
BrowserSearch
.
loadSearchFromCommandLine
(
searchTerm
lazy
.
PrivateBrowsingUtils
.
isInTemporaryAutoStartMode
|
|
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
lazy
.
gSystemPrincipal
win
.
gBrowser
.
selectedBrowser
.
csp
)
.
catch
(
Cu
.
reportError
)
;
}
function
nsBrowserContentHandler
(
)
{
if
(
!
gBrowserContentHandler
)
{
gBrowserContentHandler
=
this
;
}
return
gBrowserContentHandler
;
}
nsBrowserContentHandler
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICommandLineHandler
"
"
nsIBrowserHandler
"
"
nsIContentHandler
"
"
nsICommandLineValidator
"
]
)
handle
:
function
bch_handle
(
cmdLine
)
{
if
(
cmdLine
.
handleFlag
(
"
kiosk
"
false
)
)
{
gKiosk
=
true
;
}
if
(
cmdLine
.
handleFlag
(
"
disable
-
pinch
"
false
)
)
{
let
defaults
=
Services
.
prefs
.
getDefaultBranch
(
null
)
;
defaults
.
setBoolPref
(
"
apz
.
allow_zooming
"
false
)
;
Services
.
prefs
.
lockPref
(
"
apz
.
allow_zooming
"
)
;
defaults
.
setCharPref
(
"
browser
.
gesture
.
pinch
.
in
"
"
"
)
;
Services
.
prefs
.
lockPref
(
"
browser
.
gesture
.
pinch
.
in
"
)
;
defaults
.
setCharPref
(
"
browser
.
gesture
.
pinch
.
in
.
shift
"
"
"
)
;
Services
.
prefs
.
lockPref
(
"
browser
.
gesture
.
pinch
.
in
.
shift
"
)
;
defaults
.
setCharPref
(
"
browser
.
gesture
.
pinch
.
out
"
"
"
)
;
Services
.
prefs
.
lockPref
(
"
browser
.
gesture
.
pinch
.
out
"
)
;
defaults
.
setCharPref
(
"
browser
.
gesture
.
pinch
.
out
.
shift
"
"
"
)
;
Services
.
prefs
.
lockPref
(
"
browser
.
gesture
.
pinch
.
out
.
shift
"
)
;
}
if
(
cmdLine
.
handleFlag
(
"
browser
"
false
)
)
{
openBrowserWindow
(
cmdLine
lazy
.
gSystemPrincipal
)
;
cmdLine
.
preventDefault
=
true
;
}
if
(
cmdLine
.
handleFlag
(
"
remote
"
true
)
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ABORT
)
;
}
var
uriparam
;
try
{
while
(
(
uriparam
=
cmdLine
.
handleFlagWithParam
(
"
new
-
window
"
false
)
)
)
{
let
uri
=
resolveURIInternal
(
cmdLine
uriparam
)
;
if
(
!
shouldLoadURI
(
uri
)
)
{
continue
;
}
openBrowserWindow
(
cmdLine
lazy
.
gSystemPrincipal
uri
.
spec
)
;
cmdLine
.
preventDefault
=
true
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
try
{
while
(
(
uriparam
=
cmdLine
.
handleFlagWithParam
(
"
new
-
tab
"
false
)
)
)
{
let
uri
=
resolveURIInternal
(
cmdLine
uriparam
)
;
handURIToExistingBrowser
(
uri
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
cmdLine
false
lazy
.
gSystemPrincipal
)
;
cmdLine
.
preventDefault
=
true
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
var
chromeParam
=
cmdLine
.
handleFlagWithParam
(
"
chrome
"
false
)
;
if
(
chromeParam
)
{
if
(
chromeParam
=
=
"
chrome
:
/
/
browser
/
content
/
pref
/
pref
.
xul
"
|
|
chromeParam
=
=
"
chrome
:
/
/
browser
/
content
/
preferences
/
preferences
.
xul
"
)
{
openPreferences
(
cmdLine
)
;
cmdLine
.
preventDefault
=
true
;
}
else
{
try
{
let
resolvedURI
=
resolveURIInternal
(
cmdLine
chromeParam
)
;
let
isLocal
=
uri
=
>
{
let
localSchemes
=
new
Set
(
[
"
chrome
"
"
file
"
"
resource
"
]
)
;
if
(
uri
instanceof
Ci
.
nsINestedURI
)
{
uri
=
uri
.
QueryInterface
(
Ci
.
nsINestedURI
)
.
innerMostURI
;
}
return
localSchemes
.
has
(
uri
.
scheme
)
;
}
;
if
(
isLocal
(
resolvedURI
)
)
{
let
features
=
"
chrome
dialog
=
no
all
"
+
this
.
getFeatures
(
cmdLine
)
;
let
argArray
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
argArray
.
appendElement
(
null
)
;
Services
.
ww
.
openWindow
(
null
resolvedURI
.
spec
"
_blank
"
features
argArray
)
;
cmdLine
.
preventDefault
=
true
;
}
else
{
dump
(
"
*
*
*
Preventing
load
of
web
URI
as
chrome
\
n
"
)
;
dump
(
"
If
you
'
re
trying
to
load
a
webpage
do
not
pass
-
-
chrome
.
\
n
"
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
if
(
cmdLine
.
handleFlag
(
"
preferences
"
false
)
)
{
openPreferences
(
cmdLine
)
;
cmdLine
.
preventDefault
=
true
;
}
if
(
cmdLine
.
handleFlag
(
"
silent
"
false
)
)
{
cmdLine
.
preventDefault
=
true
;
}
try
{
var
privateWindowParam
=
cmdLine
.
handleFlagWithParam
(
"
private
-
window
"
false
)
;
if
(
privateWindowParam
)
{
let
forcePrivate
=
true
;
let
resolvedURI
;
if
(
!
lazy
.
PrivateBrowsingUtils
.
enabled
)
{
forcePrivate
=
false
;
resolvedURI
=
Services
.
io
.
newURI
(
"
about
:
privatebrowsing
"
)
;
}
else
{
resolvedURI
=
resolveURIInternal
(
cmdLine
privateWindowParam
)
;
}
handURIToExistingBrowser
(
resolvedURI
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
cmdLine
forcePrivate
lazy
.
gSystemPrincipal
)
;
cmdLine
.
preventDefault
=
true
;
}
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_INVALID_ARG
)
{
throw
e
;
}
if
(
cmdLine
.
handleFlag
(
"
private
-
window
"
false
)
)
{
openBrowserWindow
(
cmdLine
lazy
.
gSystemPrincipal
"
about
:
privatebrowsing
"
null
lazy
.
PrivateBrowsingUtils
.
enabled
)
;
cmdLine
.
preventDefault
=
true
;
}
}
var
searchParam
=
cmdLine
.
handleFlagWithParam
(
"
search
"
false
)
;
if
(
searchParam
)
{
doSearch
(
searchParam
cmdLine
)
;
cmdLine
.
preventDefault
=
true
;
}
if
(
cmdLine
.
handleFlag
(
"
private
"
false
)
&
&
lazy
.
PrivateBrowsingUtils
.
enabled
)
{
lazy
.
PrivateBrowsingUtils
.
enterTemporaryAutoStartMode
(
)
;
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_INITIAL_LAUNCH
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
blank
"
)
;
if
(
win
)
{
win
.
docShell
.
QueryInterface
(
Ci
.
nsILoadContext
)
.
usePrivateBrowsing
=
true
;
}
}
}
if
(
cmdLine
.
handleFlag
(
"
setDefaultBrowser
"
false
)
)
{
lazy
.
ShellService
.
setDefaultBrowser
(
true
true
)
;
}
if
(
cmdLine
.
handleFlag
(
"
first
-
startup
"
false
)
)
{
lazy
.
FirstStartup
.
init
(
)
;
}
var
fileParam
=
cmdLine
.
handleFlagWithParam
(
"
file
"
false
)
;
if
(
fileParam
)
{
var
file
=
cmdLine
.
resolveFile
(
fileParam
)
;
var
fileURI
=
Services
.
io
.
newFileURI
(
file
)
;
openBrowserWindow
(
cmdLine
lazy
.
gSystemPrincipal
fileURI
.
spec
)
;
cmdLine
.
preventDefault
=
true
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
for
(
var
i
=
cmdLine
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
param
=
cmdLine
.
getArgument
(
i
)
;
if
(
param
.
match
(
/
^
\
?
/
)
)
{
cmdLine
.
removeArguments
(
i
i
)
;
cmdLine
.
preventDefault
=
true
;
searchParam
=
param
.
substr
(
2
)
;
doSearch
(
searchParam
cmdLine
)
;
}
}
}
}
get
helpInfo
(
)
{
let
info
=
"
-
-
browser
Open
a
browser
window
.
\
n
"
+
"
-
-
new
-
window
<
url
>
Open
<
url
>
in
a
new
window
.
\
n
"
+
"
-
-
new
-
tab
<
url
>
Open
<
url
>
in
a
new
tab
.
\
n
"
+
"
-
-
private
-
window
<
url
>
Open
<
url
>
in
a
new
private
window
.
\
n
"
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
info
+
=
"
-
-
preferences
Open
Options
dialog
.
\
n
"
;
}
else
{
info
+
=
"
-
-
preferences
Open
Preferences
dialog
.
\
n
"
;
}
info
+
=
"
-
-
screenshot
[
<
path
>
]
Save
screenshot
to
<
path
>
or
in
working
directory
.
\
n
"
;
info
+
=
"
-
-
window
-
size
width
[
height
]
Width
and
optionally
height
of
screenshot
.
\
n
"
;
info
+
=
"
-
-
search
<
term
>
Search
<
term
>
with
your
default
search
engine
.
\
n
"
;
info
+
=
"
-
-
setDefaultBrowser
Set
this
app
as
the
default
browser
.
\
n
"
;
info
+
=
"
-
-
first
-
startup
Run
post
-
install
actions
before
opening
a
new
window
.
\
n
"
;
info
+
=
"
-
-
kiosk
Start
the
browser
in
kiosk
mode
.
\
n
"
;
info
+
=
"
-
-
disable
-
pinch
Disable
touch
-
screen
and
touch
-
pad
pinch
gestures
.
\
n
"
;
return
info
;
}
get
defaultArgs
(
)
{
return
this
.
getArgs
(
)
;
}
getArgs
(
isStartup
=
false
)
{
var
prefb
=
Services
.
prefs
;
if
(
!
gFirstWindow
)
{
gFirstWindow
=
true
;
if
(
lazy
.
PrivateBrowsingUtils
.
isInTemporaryAutoStartMode
)
{
return
"
about
:
privatebrowsing
"
;
}
}
var
override
;
var
overridePage
=
"
"
;
var
additionalPage
=
"
"
;
var
willRestoreSession
=
false
;
try
{
let
old_mstone
=
Services
.
prefs
.
getCharPref
(
"
browser
.
startup
.
homepage_override
.
mstone
"
"
unknown
"
)
;
let
old_buildId
=
Services
.
prefs
.
getCharPref
(
"
browser
.
startup
.
homepage_override
.
buildID
"
"
unknown
"
)
;
override
=
needHomepageOverride
(
prefb
)
;
if
(
override
!
=
OVERRIDE_NONE
)
{
switch
(
override
)
{
case
OVERRIDE_NEW_PROFILE
:
overridePage
=
Services
.
urlFormatter
.
formatURLPref
(
"
startup
.
homepage_welcome_url
"
)
;
additionalPage
=
Services
.
urlFormatter
.
formatURLPref
(
"
startup
.
homepage_welcome_url
.
additional
"
)
;
lazy
.
LaterRun
.
enabled
=
true
;
break
;
case
OVERRIDE_NEW_MSTONE
:
willRestoreSession
=
lazy
.
SessionStartup
.
isAutomaticRestoreEnabled
(
)
;
overridePage
=
Services
.
urlFormatter
.
formatURLPref
(
"
startup
.
homepage_override_url
"
)
;
let
update
=
lazy
.
UpdateManager
.
readyUpdate
;
if
(
update
&
&
Services
.
vc
.
compare
(
update
.
appVersion
old_mstone
)
>
0
)
{
overridePage
=
getPostUpdateOverridePage
(
update
overridePage
)
;
lazy
.
UpdatePing
.
handleUpdateSuccess
(
old_mstone
old_buildId
)
;
}
overridePage
=
overridePage
.
replace
(
"
%
OLD_VERSION
%
"
old_mstone
)
;
break
;
case
OVERRIDE_NEW_BUILD_ID
:
if
(
lazy
.
UpdateManager
.
readyUpdate
)
{
lazy
.
UpdatePing
.
handleUpdateSuccess
(
old_mstone
old_buildId
)
;
}
break
;
}
}
}
catch
(
ex
)
{
}
if
(
overridePage
=
=
"
about
:
blank
"
)
{
overridePage
=
"
"
;
}
if
(
isStartup
&
&
overridePage
=
=
"
"
&
&
prefb
.
prefHasUserValue
(
ONCE_PREF
)
)
{
try
{
const
{
expire
url
}
=
JSON
.
parse
(
Services
.
urlFormatter
.
formatURLPref
(
ONCE_PREF
)
)
;
if
(
!
(
Date
.
now
(
)
>
expire
)
)
{
overridePage
=
url
.
split
(
"
|
"
)
.
map
(
val
=
>
{
try
{
return
new
URL
(
val
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Invalid
once
url
:
{
ex
}
)
;
return
null
;
}
}
)
.
filter
(
parsed
=
>
parsed
&
&
parsed
.
protocol
=
=
"
https
:
"
&
&
ONCE_DOMAINS
.
includes
(
Services
.
eTLD
.
getBaseDomainFromHost
(
parsed
.
host
)
)
)
.
join
(
"
|
"
)
;
if
(
overridePage
!
=
url
)
{
Cu
.
reportError
(
Mismatched
once
urls
:
{
url
}
)
;
}
}
}
catch
(
ex
)
{
Cu
.
reportError
(
Invalid
once
pref
:
{
ex
}
)
;
}
finally
{
prefb
.
clearUserPref
(
ONCE_PREF
)
;
}
}
if
(
!
additionalPage
)
{
additionalPage
=
lazy
.
LaterRun
.
getURL
(
)
|
|
"
"
;
}
if
(
additionalPage
&
&
additionalPage
!
=
"
about
:
blank
"
)
{
if
(
overridePage
)
{
overridePage
+
=
"
|
"
+
additionalPage
;
}
else
{
overridePage
=
additionalPage
;
}
}
var
startPage
=
"
"
;
try
{
var
choice
=
prefb
.
getIntPref
(
"
browser
.
startup
.
page
"
)
;
if
(
choice
=
=
1
|
|
choice
=
=
3
)
{
startPage
=
lazy
.
HomePage
.
get
(
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
startPage
=
=
"
about
:
blank
"
)
{
startPage
=
"
"
;
}
let
skipStartPage
=
override
=
=
OVERRIDE_NEW_PROFILE
&
&
prefb
.
getBoolPref
(
"
browser
.
startup
.
firstrunSkipsHomepage
"
)
;
if
(
overridePage
&
&
startPage
&
&
!
willRestoreSession
&
&
!
skipStartPage
)
{
return
overridePage
+
"
|
"
+
startPage
;
}
return
overridePage
|
|
startPage
|
|
"
about
:
blank
"
;
}
mFeatures
:
null
getFeatures
:
function
bch_features
(
cmdLine
)
{
if
(
this
.
mFeatures
=
=
=
null
)
{
this
.
mFeatures
=
"
"
;
if
(
cmdLine
)
{
try
{
var
width
=
cmdLine
.
handleFlagWithParam
(
"
width
"
false
)
;
var
height
=
cmdLine
.
handleFlagWithParam
(
"
height
"
false
)
;
var
left
=
cmdLine
.
handleFlagWithParam
(
"
left
"
false
)
;
var
top
=
cmdLine
.
handleFlagWithParam
(
"
top
"
false
)
;
if
(
width
)
{
this
.
mFeatures
+
=
"
width
=
"
+
width
;
}
if
(
height
)
{
this
.
mFeatures
+
=
"
height
=
"
+
height
;
}
if
(
left
)
{
this
.
mFeatures
+
=
"
left
=
"
+
left
;
}
if
(
top
)
{
this
.
mFeatures
+
=
"
top
=
"
+
top
;
}
}
catch
(
e
)
{
}
}
if
(
lazy
.
PrivateBrowsingUtils
.
isInTemporaryAutoStartMode
)
{
this
.
mFeatures
+
=
"
private
"
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
suppress_first_window_animation
"
)
&
&
!
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
)
{
this
.
mFeatures
+
=
"
suppressanimation
"
;
}
}
return
this
.
mFeatures
;
}
get
kiosk
(
)
{
return
gKiosk
;
}
get
majorUpgrade
(
)
{
return
gMajorUpgrade
;
}
set
majorUpgrade
(
val
)
{
gMajorUpgrade
=
val
;
}
handleContent
:
function
bch_handleContent
(
contentType
context
request
)
{
const
NS_ERROR_WONT_HANDLE_CONTENT
=
0x805d0001
;
try
{
var
webNavInfo
=
Cc
[
"
mozilla
.
org
/
webnavigation
-
info
;
1
"
]
.
getService
(
Ci
.
nsIWebNavigationInfo
)
;
if
(
!
webNavInfo
.
isTypeSupported
(
contentType
)
)
{
throw
NS_ERROR_WONT_HANDLE_CONTENT
;
}
}
catch
(
e
)
{
throw
NS_ERROR_WONT_HANDLE_CONTENT
;
}
request
.
QueryInterface
(
Ci
.
nsIChannel
)
;
handURIToExistingBrowser
(
request
.
URI
Ci
.
nsIBrowserDOMWindow
.
OPEN_DEFAULTWINDOW
null
false
request
.
loadInfo
.
triggeringPrincipal
)
;
request
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
}
validate
:
function
bch_validate
(
cmdLine
)
{
var
urlFlagIdx
=
cmdLine
.
findFlag
(
"
url
"
false
)
;
if
(
urlFlagIdx
>
-
1
&
&
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_EXPLICIT
)
{
var
urlParam
=
cmdLine
.
getArgument
(
urlFlagIdx
+
1
)
;
if
(
cmdLine
.
length
!
=
urlFlagIdx
+
2
|
|
/
firefoxurl
(
-
[
a
-
f0
-
9
]
+
)
?
:
/
i
.
test
(
urlParam
)
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ABORT
)
;
}
var
isDefault
=
false
;
try
{
var
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
win10
-
default
-
browser
"
;
if
(
urlParam
=
=
url
)
{
isDefault
=
lazy
.
ShellService
.
isDefaultBrowser
(
false
false
)
;
}
}
catch
(
ex
)
{
}
if
(
isDefault
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ABORT
)
;
}
}
}
}
;
var
gBrowserContentHandler
=
new
nsBrowserContentHandler
(
)
;
function
handURIToExistingBrowser
(
uri
location
cmdLine
forcePrivate
triggeringPrincipal
)
{
if
(
!
shouldLoadURI
(
uri
)
)
{
return
;
}
var
allowPrivate
=
forcePrivate
|
|
lazy
.
PrivateBrowsingUtils
.
permanentPrivateBrowsing
;
var
navWin
=
lazy
.
BrowserWindowTracker
.
getTopWindow
(
{
private
:
allowPrivate
}
)
;
if
(
!
navWin
)
{
openBrowserWindow
(
cmdLine
triggeringPrincipal
uri
.
spec
null
forcePrivate
)
;
return
;
}
var
bwin
=
navWin
.
browserDOMWindow
;
bwin
.
openURI
(
uri
null
location
Ci
.
nsIBrowserDOMWindow
.
OPEN_EXTERNAL
triggeringPrincipal
)
;
}
function
maybeRecordToHandleTelemetry
(
uri
isLaunch
)
{
let
scalar
=
isLaunch
?
"
os
.
environment
.
launched_to_handle
"
:
"
os
.
environment
.
invoked_to_handle
"
;
if
(
uri
instanceof
Ci
.
nsIFileURL
)
{
let
extension
=
"
.
"
+
uri
.
fileExtension
.
toLowerCase
(
)
;
let
registeredExtensions
=
new
Set
(
[
"
.
avif
"
"
.
htm
"
"
.
html
"
"
.
pdf
"
"
.
shtml
"
"
.
xht
"
"
.
xhtml
"
"
.
svg
"
"
.
webp
"
]
)
;
if
(
registeredExtensions
.
has
(
extension
)
)
{
Services
.
telemetry
.
keyedScalarAdd
(
scalar
extension
1
)
;
}
else
{
Services
.
telemetry
.
keyedScalarAdd
(
scalar
"
.
<
other
extension
>
"
1
)
;
}
}
else
if
(
uri
)
{
let
scheme
=
uri
.
scheme
.
toLowerCase
(
)
;
let
registeredSchemes
=
new
Set
(
[
"
about
"
"
http
"
"
https
"
"
mailto
"
]
)
;
if
(
registeredSchemes
.
has
(
scheme
)
)
{
Services
.
telemetry
.
keyedScalarAdd
(
scalar
scheme
1
)
;
}
else
{
Services
.
telemetry
.
keyedScalarAdd
(
scalar
"
<
other
protocol
>
"
1
)
;
}
}
}
function
nsDefaultCommandLineHandler
(
)
{
}
nsDefaultCommandLineHandler
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsICommandLineHandler
"
]
)
_haveProfile
:
false
handle
:
function
dch_handle
(
cmdLine
)
{
var
urilist
=
[
]
;
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_INITIAL_LAUNCH
&
&
Services
.
startup
.
wasSilentlyStarted
)
{
Services
.
startup
.
enterLastWindowClosingSurvivalArea
(
)
;
Services
.
obs
.
addObserver
(
function
windowOpenObserver
(
)
{
Services
.
startup
.
exitLastWindowClosingSurvivalArea
(
)
;
Services
.
obs
.
removeObserver
(
windowOpenObserver
"
domwindowopened
"
)
;
}
"
domwindowopened
"
)
;
return
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
if
(
!
this
.
_haveProfile
)
{
try
{
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
this
.
_haveProfile
=
true
;
}
catch
(
e
)
{
while
(
(
ar
=
cmdLine
.
handleFlagWithParam
(
"
url
"
false
)
)
)
{
}
cmdLine
.
preventDefault
=
true
;
}
}
}
let
launchedWithArg_osint
=
AppConstants
.
platform
=
=
"
win
"
&
&
cmdLine
.
findFlag
(
"
osint
"
false
)
=
=
0
;
if
(
launchedWithArg_osint
)
{
cmdLine
.
handleFlag
(
"
osint
"
false
)
;
}
try
{
var
ar
;
while
(
(
ar
=
cmdLine
.
handleFlagWithParam
(
"
url
"
false
)
)
)
{
var
uri
=
resolveURIInternal
(
cmdLine
ar
)
;
urilist
.
push
(
uri
)
;
if
(
launchedWithArg_osint
)
{
launchedWithArg_osint
=
false
;
const
isLaunch
=
cmdLine
&
&
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_INITIAL_LAUNCH
;
maybeRecordToHandleTelemetry
(
uri
isLaunch
)
;
}
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
if
(
cmdLine
.
findFlag
(
"
screenshot
"
true
)
!
=
-
1
)
{
lazy
.
HeadlessShell
.
handleCmdLineArgs
(
cmdLine
urilist
.
filter
(
shouldLoadURI
)
.
map
(
u
=
>
u
.
spec
)
)
;
return
;
}
for
(
let
i
=
0
;
i
<
cmdLine
.
length
;
+
+
i
)
{
var
curarg
=
cmdLine
.
getArgument
(
i
)
;
if
(
curarg
.
match
(
/
^
-
/
)
)
{
Cu
.
reportError
(
"
Warning
:
unrecognized
command
line
flag
"
+
curarg
+
"
\
n
"
)
;
+
+
i
;
}
else
{
try
{
urilist
.
push
(
resolveURIInternal
(
cmdLine
curarg
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
opening
URI
'
"
+
curarg
+
"
'
from
the
command
line
:
"
+
e
+
"
\
n
"
)
;
}
}
}
if
(
urilist
.
length
)
{
if
(
cmdLine
.
state
!
=
Ci
.
nsICommandLine
.
STATE_INITIAL_LAUNCH
&
&
urilist
.
length
=
=
1
)
{
try
{
handURIToExistingBrowser
(
urilist
[
0
]
Ci
.
nsIBrowserDOMWindow
.
OPEN_DEFAULTWINDOW
cmdLine
false
lazy
.
gSystemPrincipal
)
;
return
;
}
catch
(
e
)
{
}
}
var
URLlist
=
urilist
.
filter
(
shouldLoadURI
)
.
map
(
u
=
>
u
.
spec
)
;
if
(
URLlist
.
length
)
{
openBrowserWindow
(
cmdLine
lazy
.
gSystemPrincipal
URLlist
)
;
}
}
else
if
(
!
cmdLine
.
preventDefault
)
{
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
"
)
&
&
cmdLine
.
state
!
=
Ci
.
nsICommandLine
.
STATE_INITIAL_LAUNCH
&
&
lazy
.
WindowsUIUtils
.
inTabletMode
)
{
let
win
=
lazy
.
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
win
)
{
win
.
focus
(
)
;
return
;
}
}
openBrowserWindow
(
cmdLine
lazy
.
gSystemPrincipal
)
;
}
else
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
blank
"
)
;
if
(
win
)
{
win
.
close
(
)
;
}
}
}
helpInfo
:
"
"
}
;
