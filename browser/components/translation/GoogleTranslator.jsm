"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
GoogleTranslator
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
httpRequest
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Http
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
DOMParser
"
]
)
;
const
MAX_REQUEST_DATA
=
5000
;
const
MAX_REQUEST_CHUNKS
=
128
;
const
MAX_REQUESTS
=
15
;
const
URL
=
"
https
:
/
/
translation
.
googleapis
.
com
/
language
/
translate
/
v2
"
;
var
GoogleTranslator
=
function
(
translationDocument
sourceLanguage
targetLanguage
)
{
this
.
translationDocument
=
translationDocument
;
this
.
sourceLanguage
=
sourceLanguage
;
this
.
targetLanguage
=
targetLanguage
;
this
.
_pendingRequests
=
0
;
this
.
_partialSuccess
=
false
;
this
.
_translatedCharacterCount
=
0
;
}
;
this
.
GoogleTranslator
.
prototype
=
{
async
translate
(
)
{
let
currentIndex
=
0
;
this
.
_onFinishedDeferred
=
PromiseUtils
.
defer
(
)
;
for
(
let
requestCount
=
0
;
requestCount
<
MAX_REQUESTS
;
requestCount
+
+
)
{
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
let
request
=
this
.
_generateNextTranslationRequest
(
currentIndex
)
;
let
googleRequest
=
new
GoogleRequest
(
request
.
data
this
.
sourceLanguage
this
.
targetLanguage
)
;
this
.
_pendingRequests
+
+
;
googleRequest
.
fireRequest
(
)
.
then
(
this
.
_chunkCompleted
.
bind
(
this
)
this
.
_chunkFailed
.
bind
(
this
)
)
;
currentIndex
=
request
.
lastIndex
;
if
(
request
.
finished
)
{
break
;
}
}
return
this
.
_onFinishedDeferred
.
promise
;
}
_chunkCompleted
(
googleRequest
)
{
if
(
this
.
_parseChunkResult
(
googleRequest
)
)
{
this
.
_partialSuccess
=
true
;
this
.
_translatedCharacterCount
+
=
googleRequest
.
characterCount
;
}
this
.
_checkIfFinished
(
)
;
}
_chunkFailed
(
aError
)
{
this
.
_checkIfFinished
(
)
;
}
_checkIfFinished
(
)
{
if
(
-
-
this
.
_pendingRequests
=
=
0
)
{
if
(
this
.
_partialSuccess
)
{
this
.
_onFinishedDeferred
.
resolve
(
{
characterCount
:
this
.
_translatedCharacterCount
}
)
;
}
else
{
this
.
_onFinishedDeferred
.
reject
(
"
failure
"
)
;
}
}
}
_parseChunkResult
(
googleRequest
)
{
let
results
;
try
{
let
response
=
googleRequest
.
networkRequest
.
response
;
results
=
JSON
.
parse
(
response
)
.
data
.
translations
;
}
catch
(
e
)
{
return
false
;
}
let
len
=
results
.
length
;
if
(
len
!
=
googleRequest
.
translationData
.
length
)
{
return
false
;
}
let
error
=
false
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
try
{
let
result
=
results
[
i
]
.
translatedText
;
let
root
=
googleRequest
.
translationData
[
i
]
[
0
]
;
if
(
root
.
isSimpleRoot
&
&
result
.
includes
(
"
&
"
)
)
{
let
doc
=
(
new
DOMParser
(
)
)
.
parseFromString
(
result
"
text
/
html
"
)
;
result
=
doc
.
body
.
firstChild
.
nodeValue
;
}
root
.
parseResult
(
result
)
;
}
catch
(
e
)
{
error
=
true
;
}
}
return
!
error
;
}
_generateNextTranslationRequest
(
startIndex
)
{
let
currentDataSize
=
0
;
let
currentChunks
=
0
;
let
output
=
[
]
;
let
rootsList
=
this
.
translationDocument
.
roots
;
for
(
let
i
=
startIndex
;
i
<
rootsList
.
length
;
i
+
+
)
{
let
root
=
rootsList
[
i
]
;
let
text
=
this
.
translationDocument
.
generateTextForItem
(
root
)
;
if
(
!
text
)
{
continue
;
}
let
newCurSize
=
currentDataSize
+
text
.
length
;
let
newChunks
=
currentChunks
+
1
;
if
(
newCurSize
>
MAX_REQUEST_DATA
|
|
newChunks
>
MAX_REQUEST_CHUNKS
)
{
return
{
data
:
output
finished
:
false
lastIndex
:
i
}
;
}
currentDataSize
=
newCurSize
;
currentChunks
=
newChunks
;
output
.
push
(
[
root
text
]
)
;
}
return
{
data
:
output
finished
:
true
lastIndex
:
0
}
;
}
}
;
function
GoogleRequest
(
translationData
sourceLanguage
targetLanguage
)
{
this
.
translationData
=
translationData
;
this
.
sourceLanguage
=
sourceLanguage
;
this
.
targetLanguage
=
targetLanguage
;
this
.
characterCount
=
0
;
}
GoogleRequest
.
prototype
=
{
fireRequest
(
)
{
let
key
=
Services
.
cpmm
.
sharedData
.
get
(
"
translationKey
"
)
|
|
Services
.
prefs
.
getStringPref
(
"
browser
.
translation
.
google
.
apiKey
"
"
"
)
;
if
(
!
key
)
{
return
Promise
.
reject
(
"
no
API
key
"
)
;
}
let
postData
=
[
[
"
key
"
key
]
[
"
source
"
this
.
sourceLanguage
]
[
"
target
"
this
.
targetLanguage
]
]
;
for
(
let
[
text
]
of
this
.
translationData
)
{
postData
.
push
(
[
"
q
"
text
]
)
;
this
.
characterCount
+
=
text
.
length
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
options
=
{
onLoad
:
(
responseText
xhr
)
=
>
{
resolve
(
this
)
;
}
onError
(
e
responseText
xhr
)
{
reject
(
xhr
)
;
}
postData
}
;
this
.
networkRequest
=
httpRequest
(
URL
options
)
;
}
)
;
}
}
;
