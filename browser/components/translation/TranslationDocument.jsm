"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TranslationDocument
"
]
;
const
{
Async
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
DOMParser
"
]
)
;
var
TranslationDocument
=
function
(
document
)
{
this
.
itemsMap
=
new
Map
(
)
;
this
.
roots
=
[
]
;
this
.
_init
(
document
)
;
}
;
this
.
TranslationDocument
.
prototype
=
{
translatedFrom
:
"
"
translatedTo
:
"
"
translationError
:
false
originalShown
:
true
_init
(
document
)
{
let
winUtils
=
document
.
defaultView
.
windowUtils
;
let
nodeList
=
winUtils
.
getTranslationNodes
(
document
.
body
)
;
let
length
=
nodeList
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
node
=
nodeList
.
item
(
i
)
;
let
isRoot
=
nodeList
.
isTranslationRootAtIndex
(
i
)
;
this
.
_createItemForNode
(
node
i
isRoot
)
;
}
for
(
let
root
of
this
.
roots
)
{
if
(
root
.
children
.
length
=
=
0
&
&
root
.
nodeRef
.
childElementCount
=
=
0
)
{
root
.
isSimpleRoot
=
true
;
}
}
}
_createItemForNode
(
node
id
isRoot
)
{
if
(
this
.
itemsMap
.
has
(
node
)
)
{
return
this
.
itemsMap
.
get
(
node
)
;
}
let
item
=
new
TranslationItem
(
node
id
isRoot
)
;
if
(
isRoot
)
{
this
.
roots
.
push
(
item
)
;
}
else
{
let
parentItem
=
this
.
itemsMap
.
get
(
node
.
parentNode
)
;
if
(
parentItem
)
{
parentItem
.
children
.
push
(
item
)
;
}
}
this
.
itemsMap
.
set
(
node
item
)
;
return
item
;
}
generateTextForItem
(
item
)
{
if
(
item
.
original
)
{
return
regenerateTextFromOriginalHelper
(
item
)
;
}
if
(
item
.
isSimpleRoot
)
{
let
text
=
item
.
nodeRef
.
firstChild
.
nodeValue
.
trim
(
)
;
item
.
original
=
[
text
]
;
return
text
;
}
let
str
=
"
"
;
item
.
original
=
[
]
;
let
wasLastItemPlaceholder
=
false
;
for
(
let
child
of
item
.
nodeRef
.
childNodes
)
{
if
(
child
.
nodeType
=
=
child
.
TEXT_NODE
)
{
let
x
=
child
.
nodeValue
.
trim
(
)
;
if
(
x
!
=
"
"
)
{
item
.
original
.
push
(
x
)
;
str
+
=
x
;
wasLastItemPlaceholder
=
false
;
}
continue
;
}
let
objInMap
=
this
.
itemsMap
.
get
(
child
)
;
if
(
objInMap
&
&
!
objInMap
.
isRoot
)
{
item
.
original
.
push
(
objInMap
)
;
str
+
=
this
.
generateTextForItem
(
objInMap
)
;
wasLastItemPlaceholder
=
false
;
}
else
if
(
!
wasLastItemPlaceholder
)
{
item
.
original
.
push
(
TranslationItem_NodePlaceholder
)
;
str
+
=
"
<
br
>
"
;
wasLastItemPlaceholder
=
true
;
}
}
return
generateTranslationHtmlForItem
(
item
str
)
;
}
showTranslation
(
)
{
this
.
originalShown
=
false
;
this
.
_swapDocumentContent
(
"
translation
"
)
;
}
showOriginal
(
)
{
this
.
originalShown
=
true
;
this
.
_swapDocumentContent
(
"
original
"
)
;
}
_swapDocumentContent
(
target
)
{
(
async
(
)
=
>
{
const
YIELD_INTERVAL
=
100
;
let
maybeYield
=
Async
.
jankYielder
(
YIELD_INTERVAL
)
;
for
(
let
root
of
this
.
roots
)
{
root
.
swapText
(
target
)
;
await
maybeYield
(
)
;
}
}
)
(
)
;
}
}
;
function
TranslationItem
(
node
id
isRoot
)
{
this
.
nodeRef
=
node
;
this
.
id
=
id
;
this
.
isRoot
=
isRoot
;
this
.
children
=
[
]
;
}
TranslationItem
.
prototype
=
{
isRoot
:
false
isSimpleRoot
:
false
toString
(
)
{
let
rootType
=
"
"
;
if
(
this
.
isRoot
)
{
if
(
this
.
isSimpleRoot
)
{
rootType
=
"
(
simple
root
)
"
;
}
else
{
rootType
=
"
(
non
simple
root
)
"
;
}
}
return
"
[
object
TranslationItem
:
<
"
+
this
.
nodeRef
.
localName
+
"
>
"
+
rootType
+
"
]
"
;
}
parseResult
(
result
)
{
if
(
this
.
isSimpleRoot
)
{
this
.
translation
=
[
result
]
;
return
;
}
let
domParser
=
new
DOMParser
(
)
;
let
doc
=
domParser
.
parseFromString
(
result
"
text
/
html
"
)
;
parseResultNode
(
this
doc
.
body
.
firstChild
)
;
}
getChildById
(
id
)
{
for
(
let
child
of
this
.
children
)
{
if
(
(
"
n
"
+
child
.
id
)
=
=
id
)
{
return
child
;
}
}
return
null
;
}
swapText
(
target
)
{
swapTextForItem
(
this
target
)
;
}
}
;
const
TranslationItem_NodePlaceholder
=
{
toString
(
)
{
return
"
[
object
TranslationItem_NodePlaceholder
]
"
;
}
}
;
function
generateTranslationHtmlForItem
(
item
content
)
{
let
localName
=
item
.
isRoot
?
"
div
"
:
"
b
"
;
return
"
<
"
+
localName
+
"
id
=
n
"
+
item
.
id
+
"
>
"
+
content
+
"
<
/
"
+
localName
+
"
>
"
;
}
function
regenerateTextFromOriginalHelper
(
item
)
{
if
(
item
.
isSimpleRoot
)
{
return
item
.
original
[
0
]
;
}
let
str
=
"
"
;
for
(
let
child
of
item
.
original
)
{
if
(
child
instanceof
TranslationItem
)
{
str
+
=
regenerateTextFromOriginalHelper
(
child
)
;
}
else
if
(
child
=
=
=
TranslationItem_NodePlaceholder
)
{
str
+
=
"
<
br
>
"
;
}
else
{
str
+
=
child
;
}
}
return
generateTranslationHtmlForItem
(
item
str
)
;
}
function
parseResultNode
(
item
node
)
{
item
.
translation
=
[
]
;
for
(
let
child
of
node
.
childNodes
)
{
if
(
child
.
nodeType
=
=
child
.
TEXT_NODE
)
{
item
.
translation
.
push
(
child
.
nodeValue
)
;
}
else
if
(
child
.
localName
=
=
"
br
"
)
{
item
.
translation
.
push
(
TranslationItem_NodePlaceholder
)
;
}
else
{
let
translationItemChild
=
item
.
getChildById
(
child
.
id
)
;
if
(
translationItemChild
)
{
item
.
translation
.
push
(
translationItemChild
)
;
parseResultNode
(
translationItemChild
child
)
;
}
}
}
}
function
swapTextForItem
(
item
target
)
{
let
visitStack
=
[
item
]
;
while
(
visitStack
.
length
>
0
)
{
let
curItem
=
visitStack
.
shift
(
)
;
let
domNode
=
curItem
.
nodeRef
;
if
(
!
domNode
)
{
continue
;
}
if
(
!
curItem
[
target
]
)
{
continue
;
}
domNode
.
normalize
(
)
;
let
curNode
=
domNode
.
firstChild
;
while
(
curNode
&
&
curNode
.
nodeType
=
=
curNode
.
TEXT_NODE
&
&
curNode
.
nodeValue
.
trim
(
)
=
=
"
"
)
{
curNode
=
curNode
.
nextSibling
;
}
for
(
let
targetItem
of
curItem
[
target
]
)
{
if
(
targetItem
instanceof
TranslationItem
)
{
visitStack
.
push
(
targetItem
)
;
let
targetNode
=
targetItem
.
nodeRef
;
if
(
curNode
!
=
targetNode
&
&
targetNode
.
parentNode
=
=
domNode
)
{
domNode
.
insertBefore
(
targetNode
curNode
)
;
curNode
=
targetNode
;
}
if
(
curNode
)
{
curNode
=
getNextSiblingSkippingEmptyTextNodes
(
curNode
)
;
}
}
else
if
(
targetItem
=
=
=
TranslationItem_NodePlaceholder
)
{
while
(
curNode
&
&
(
curNode
.
nodeType
!
=
curNode
.
TEXT_NODE
|
|
curNode
.
nodeValue
.
trim
(
)
=
=
"
"
)
)
{
curNode
=
curNode
.
nextSibling
;
}
}
else
{
while
(
curNode
&
&
curNode
.
nodeType
!
=
curNode
.
TEXT_NODE
)
{
curNode
=
curNode
.
nextSibling
;
}
if
(
!
curNode
)
{
curNode
=
domNode
.
appendChild
(
domNode
.
ownerDocument
.
createTextNode
(
"
"
)
)
;
}
let
preSpace
=
/
^
\
s
/
.
test
(
curNode
.
nodeValue
)
?
"
"
:
"
"
;
let
endSpace
=
/
\
s
/
.
test
(
curNode
.
nodeValue
)
?
"
"
:
"
"
;
curNode
.
nodeValue
=
preSpace
+
targetItem
+
endSpace
;
curNode
=
getNextSiblingSkippingEmptyTextNodes
(
curNode
)
;
}
}
if
(
curNode
)
{
clearRemainingNonEmptyTextNodesFromElement
(
curNode
)
;
}
domNode
.
normalize
(
)
;
}
}
function
getNextSiblingSkippingEmptyTextNodes
(
startSibling
)
{
let
item
=
startSibling
.
nextSibling
;
while
(
item
&
&
item
.
nodeType
=
=
item
.
TEXT_NODE
&
&
item
.
nodeValue
.
trim
(
)
=
=
"
"
)
{
item
=
item
.
nextSibling
;
}
return
item
;
}
function
clearRemainingNonEmptyTextNodesFromElement
(
startSibling
)
{
let
item
=
startSibling
;
while
(
item
)
{
if
(
item
.
nodeType
=
=
item
.
TEXT_NODE
&
&
item
.
nodeValue
!
=
"
"
)
{
item
.
nodeValue
=
"
"
;
}
item
=
item
.
nextSibling
;
}
}
