"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderCalculator
"
"
Calculator
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarView
:
"
resource
:
/
/
/
modules
/
UrlbarView
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ClipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
const
ENABLED_PREF
=
"
suggest
.
calculator
"
;
const
DYNAMIC_RESULT_TYPE
=
"
calculator
"
;
const
VIEW_TEMPLATE
=
{
attributes
:
{
selectable
:
true
}
children
:
[
{
name
:
"
content
"
tag
:
"
span
"
attributes
:
{
class
:
"
urlbarView
-
no
-
wrap
"
}
children
:
[
{
name
:
"
icon
"
tag
:
"
img
"
attributes
:
{
class
:
"
urlbarView
-
favicon
"
}
}
{
name
:
"
input
"
tag
:
"
strong
"
}
{
name
:
"
action
"
tag
:
"
span
"
}
]
}
]
}
;
const
MIN_EXPRESSION_LENGTH
=
3
;
class
ProviderCalculator
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
UrlbarResult
.
addDynamicResultType
(
DYNAMIC_RESULT_TYPE
)
;
UrlbarView
.
addDynamicViewTemplate
(
DYNAMIC_RESULT_TYPE
VIEW_TEMPLATE
)
;
}
get
name
(
)
{
return
DYNAMIC_RESULT_TYPE
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
;
}
isActive
(
queryContext
)
{
return
(
queryContext
.
trimmedSearchString
&
&
!
queryContext
.
searchMode
&
&
UrlbarPrefs
.
get
(
ENABLED_PREF
)
)
;
}
async
startQuery
(
queryContext
addCallback
)
{
try
{
let
postfix
=
Calculator
.
infix2postfix
(
queryContext
.
searchString
)
;
if
(
postfix
.
length
<
MIN_EXPRESSION_LENGTH
)
{
return
;
}
let
value
=
Calculator
.
evaluatePostfix
(
postfix
)
;
const
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
value
input
:
queryContext
.
searchString
dynamicType
:
DYNAMIC_RESULT_TYPE
}
)
;
result
.
suggestedIndex
=
1
;
addCallback
(
this
result
)
;
}
catch
(
e
)
{
}
}
getViewUpdate
(
result
)
{
const
viewUpdate
=
{
icon
:
{
attributes
:
{
src
:
"
chrome
:
/
/
global
/
skin
/
icons
/
edit
-
copy
.
svg
"
}
}
input
:
{
l10n
:
{
id
:
"
urlbar
-
result
-
action
-
calculator
-
result
"
args
:
{
result
:
result
.
payload
.
value
}
}
}
action
:
{
l10n
:
{
id
:
"
urlbar
-
result
-
action
-
copy
-
to
-
clipboard
"
}
}
}
;
return
viewUpdate
;
}
async
pickResult
(
{
payload
}
)
{
ClipboardHelper
.
copyString
(
payload
.
value
)
;
}
}
class
BaseCalculator
{
stack
=
[
]
;
numberSystems
=
[
]
;
addNumberSystem
(
system
)
{
this
.
numberSystems
.
push
(
system
)
;
}
isNumeric
(
value
)
{
return
value
-
0
=
=
value
&
&
value
.
length
;
}
isOperator
(
value
)
{
return
this
.
numberSystems
.
some
(
sys
=
>
sys
.
isOperator
(
value
)
)
;
}
isNumericToken
(
char
)
{
return
this
.
numberSystems
.
some
(
sys
=
>
sys
.
isNumericToken
(
char
)
)
;
}
parsel10nFloat
(
num
)
{
for
(
const
system
of
this
.
numberSystems
)
{
num
=
system
.
transformNumber
(
num
)
;
}
return
parseFloat
(
num
10
)
;
}
precedence
(
val
)
{
if
(
[
"
-
"
"
+
"
]
.
includes
(
val
)
)
{
return
2
;
}
if
(
[
"
*
"
"
/
"
]
.
includes
(
val
)
)
{
return
3
;
}
return
null
;
}
infix2postfix
(
infix
)
{
let
parser
=
new
Parser
(
infix
this
)
;
let
tokens
=
parser
.
parse
(
infix
)
;
let
output
=
[
]
;
let
stack
=
[
]
;
tokens
.
forEach
(
token
=
>
{
if
(
token
.
number
)
{
output
.
push
(
this
.
parsel10nFloat
(
token
.
value
10
)
)
;
}
if
(
this
.
isOperator
(
token
.
value
)
)
{
let
i
=
this
.
precedence
;
while
(
stack
.
length
&
&
this
.
isOperator
(
stack
[
stack
.
length
-
1
]
)
&
&
i
(
token
.
value
)
<
=
i
(
stack
[
stack
.
length
-
1
]
)
)
{
output
.
push
(
stack
.
pop
(
)
)
;
}
stack
.
push
(
token
.
value
)
;
}
if
(
token
.
value
=
=
=
"
(
"
)
{
stack
.
push
(
token
.
value
)
;
}
if
(
token
.
value
=
=
=
"
)
"
)
{
while
(
stack
.
length
&
&
stack
[
stack
.
length
-
1
]
!
=
=
"
(
"
)
{
output
.
push
(
stack
.
pop
(
)
)
;
}
stack
.
pop
(
)
;
}
}
)
;
while
(
stack
.
length
)
{
output
.
push
(
stack
.
pop
(
)
)
;
}
return
output
;
}
evaluate
=
{
"
*
"
:
(
a
b
)
=
>
a
*
b
"
+
"
:
(
a
b
)
=
>
a
+
b
"
-
"
:
(
a
b
)
=
>
a
-
b
"
/
"
:
(
a
b
)
=
>
a
/
b
}
;
evaluatePostfix
(
postfix
)
{
let
stack
=
[
]
;
postfix
.
forEach
(
token
=
>
{
if
(
!
this
.
isOperator
(
token
)
)
{
stack
.
push
(
token
)
;
}
else
{
let
op2
=
stack
.
pop
(
)
;
let
op1
=
stack
.
pop
(
)
;
let
result
=
this
.
evaluate
[
token
]
(
op1
op2
)
;
if
(
isNaN
(
result
)
)
{
throw
new
Error
(
"
Value
is
"
+
result
)
;
}
stack
.
push
(
result
)
;
}
}
)
;
let
finalResult
=
stack
.
pop
(
)
;
if
(
isNaN
(
finalResult
)
)
{
throw
new
Error
(
"
Value
is
"
+
finalResult
)
;
}
return
finalResult
;
}
}
function
Parser
(
input
calculator
)
{
this
.
calculator
=
calculator
;
this
.
init
(
input
)
;
}
Parser
.
prototype
=
{
init
(
input
)
{
input
=
input
.
replace
(
/
[
\
t
\
v
\
n
]
/
g
"
"
)
;
this
.
_chars
=
[
]
;
for
(
let
i
=
0
;
i
<
input
.
length
;
+
+
i
)
{
this
.
_chars
.
push
(
input
[
i
]
)
;
}
this
.
_tokens
=
[
]
;
}
parse
(
input
)
{
if
(
!
this
.
_tokenizeBlock
(
)
|
|
this
.
_chars
.
length
)
{
throw
new
Error
(
"
Wrong
input
"
)
;
}
return
this
.
_tokens
;
}
_tokenizeBlock
(
)
{
if
(
!
this
.
_chars
.
length
)
{
return
false
;
}
if
(
this
.
_chars
[
0
]
=
=
"
(
"
)
{
this
.
_tokens
.
push
(
{
number
:
false
value
:
this
.
_chars
[
0
]
}
)
;
this
.
_chars
.
shift
(
)
;
if
(
!
this
.
_tokenizeBlock
(
)
)
{
return
false
;
}
if
(
!
this
.
_chars
.
length
|
|
this
.
_chars
[
0
]
!
=
"
)
"
)
{
return
false
;
}
this
.
_chars
.
shift
(
)
;
this
.
_tokens
.
push
(
{
number
:
false
value
:
"
)
"
}
)
;
}
else
if
(
!
this
.
_tokenizeNumber
(
)
)
{
return
false
;
}
if
(
!
this
.
_chars
.
length
|
|
this
.
_chars
[
0
]
=
=
"
)
"
)
{
return
true
;
}
while
(
this
.
_chars
.
length
&
&
this
.
_chars
[
0
]
!
=
"
)
"
)
{
if
(
!
this
.
_tokenizeOther
(
)
)
{
return
false
;
}
if
(
!
this
.
_tokenizeBlock
(
)
)
{
return
false
;
}
}
return
true
;
}
_tokenizeNumber
(
)
{
if
(
!
this
.
_chars
.
length
)
{
return
false
;
}
let
number
=
[
]
;
if
(
/
[
+
-
]
/
.
test
(
this
.
_chars
[
0
]
)
)
{
number
.
push
(
this
.
_chars
.
shift
(
)
)
;
}
let
tokenizeNumberInternal
=
(
)
=
>
{
if
(
!
this
.
_chars
.
length
|
|
!
this
.
calculator
.
isNumericToken
(
this
.
_chars
[
0
]
)
)
{
return
false
;
}
while
(
this
.
_chars
.
length
&
&
this
.
calculator
.
isNumericToken
(
this
.
_chars
[
0
]
)
)
{
number
.
push
(
this
.
_chars
.
shift
(
)
)
;
}
return
true
;
}
;
if
(
!
tokenizeNumberInternal
(
)
)
{
return
false
;
}
if
(
!
this
.
_chars
.
length
|
|
this
.
_chars
[
0
]
!
=
"
e
"
)
{
this
.
_tokens
.
push
(
{
number
:
true
value
:
number
.
join
(
"
"
)
}
)
;
return
true
;
}
number
.
push
(
this
.
_chars
.
shift
(
)
)
;
if
(
/
[
+
-
]
/
.
test
(
this
.
_chars
[
0
]
)
)
{
number
.
push
(
this
.
_chars
.
shift
(
)
)
;
}
if
(
!
this
.
_chars
.
length
)
{
return
false
;
}
if
(
!
tokenizeNumberInternal
(
)
)
{
return
false
;
}
this
.
_tokens
.
push
(
{
number
:
true
value
:
number
.
join
(
"
"
)
}
)
;
return
true
;
}
_tokenizeOther
(
)
{
if
(
!
this
.
_chars
.
length
)
{
return
false
;
}
if
(
this
.
calculator
.
isOperator
(
this
.
_chars
[
0
]
)
)
{
this
.
_tokens
.
push
(
{
number
:
false
value
:
this
.
_chars
.
shift
(
)
}
)
;
return
true
;
}
return
false
;
}
}
;
let
Calculator
=
new
BaseCalculator
(
)
;
Calculator
.
addNumberSystem
(
{
isOperator
:
char
=
>
[
"
"
"
"
"
-
"
"
+
"
"
*
"
"
/
"
]
.
includes
(
char
)
isNumericToken
:
char
=
>
/
^
[
0
-
9
\
.
]
/
.
test
(
char
)
transformNumber
:
num
=
>
{
let
firstComma
=
num
.
indexOf
(
"
"
)
;
let
firstPeriod
=
num
.
indexOf
(
"
.
"
)
;
if
(
firstPeriod
!
=
-
1
&
&
firstComma
!
=
-
1
&
&
firstPeriod
<
firstComma
)
{
num
=
num
.
replace
(
/
\
.
/
g
"
"
)
;
num
=
num
.
replace
(
/
/
g
"
.
"
)
;
}
else
if
(
firstPeriod
!
=
-
1
&
&
firstComma
!
=
-
1
)
{
num
=
num
.
replace
(
/
/
g
"
"
)
;
}
else
if
(
firstComma
!
=
-
1
)
{
num
=
num
.
replace
(
/
/
g
"
.
"
)
;
}
return
num
;
}
}
)
;
var
UrlbarProviderCalculator
=
new
ProviderCalculator
(
)
;
