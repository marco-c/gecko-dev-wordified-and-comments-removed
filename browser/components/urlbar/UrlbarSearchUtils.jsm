"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarSearchUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
SEARCH_ENGINE_TOPIC
=
"
browser
-
search
-
engine
-
modified
"
;
class
SearchUtils
{
constructor
(
)
{
this
.
_refreshEnginesByAliasPromise
=
Promise
.
resolve
(
)
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
separatePrivateDefaultUIEnabled
"
"
browser
.
search
.
separatePrivateDefault
.
ui
.
enabled
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
separatePrivateDefault
"
"
browser
.
search
.
separatePrivateDefault
"
false
)
;
}
async
init
(
)
{
if
(
!
this
.
_initPromise
)
{
this
.
_initPromise
=
this
.
_initInternal
(
)
;
}
await
this
.
_initPromise
;
}
async
enginesForDomainPrefix
(
prefix
{
matchAllDomainLevels
=
false
onlyEnabled
=
false
}
=
{
}
)
{
await
this
.
init
(
)
;
prefix
=
prefix
.
toLowerCase
(
)
;
let
disabledEngines
=
onlyEnabled
?
Services
.
prefs
.
getStringPref
(
"
browser
.
search
.
hiddenOneOffs
"
"
"
)
.
split
(
"
"
)
.
filter
(
e
=
>
!
!
e
)
:
[
]
;
let
partialMatchEngines
=
[
]
;
function
matchPrefix
(
engine
engineHost
)
{
let
parts
=
engineHost
.
split
(
"
.
"
)
;
for
(
let
i
=
1
;
i
<
parts
.
length
-
1
;
+
+
i
)
{
if
(
parts
.
slice
(
i
)
.
join
(
"
.
"
)
.
startsWith
(
prefix
)
)
{
partialMatchEngines
.
push
(
engine
)
;
}
}
}
let
perfectMatchEngines
=
[
]
;
let
perfectMatchEngineSet
=
new
Set
(
)
;
for
(
let
engine
of
await
Services
.
search
.
getVisibleEngines
(
)
)
{
if
(
disabledEngines
.
includes
(
engine
.
name
)
)
{
continue
;
}
let
domain
=
engine
.
getResultDomain
(
)
;
if
(
domain
.
startsWith
(
prefix
)
|
|
domain
.
startsWith
(
"
www
.
"
+
prefix
)
)
{
perfectMatchEngines
.
push
(
engine
)
;
perfectMatchEngineSet
.
add
(
engine
)
;
}
if
(
matchAllDomainLevels
)
{
if
(
prefix
.
includes
(
"
.
"
)
)
{
matchPrefix
(
engine
domain
)
;
}
matchPrefix
(
engine
domain
.
substr
(
0
domain
.
length
-
engine
.
searchUrlPublicSuffix
.
length
)
)
;
}
}
let
engines
=
perfectMatchEngines
;
let
engineSet
=
perfectMatchEngineSet
;
for
(
let
engine
of
partialMatchEngines
)
{
if
(
!
engineSet
.
has
(
engine
)
)
{
engineSet
.
add
(
engine
)
;
engines
.
push
(
engine
)
;
}
}
return
engines
;
}
async
engineForAlias
(
alias
searchString
=
null
)
{
await
Promise
.
all
(
[
this
.
init
(
)
this
.
_refreshEnginesByAliasPromise
]
)
;
let
engine
=
this
.
_enginesByAlias
.
get
(
alias
.
toLocaleLowerCase
(
)
)
;
if
(
engine
&
&
searchString
)
{
let
query
=
lazy
.
UrlbarUtils
.
substringAfter
(
searchString
alias
)
;
if
(
!
lazy
.
UrlbarTokenizer
.
REGEXP_SPACES_START
.
test
(
query
)
)
{
return
null
;
}
}
return
engine
|
|
null
;
}
async
tokenAliasEngines
(
)
{
await
this
.
init
(
)
;
let
tokenAliasEngines
=
[
]
;
for
(
let
engine
of
await
Services
.
search
.
getVisibleEngines
(
)
)
{
let
tokenAliases
=
this
.
_aliasesForEngine
(
engine
)
.
filter
(
a
=
>
a
.
startsWith
(
"
"
)
)
;
if
(
tokenAliases
.
length
)
{
tokenAliasEngines
.
push
(
{
engine
tokenAliases
}
)
;
}
}
return
tokenAliasEngines
;
}
getRootDomainFromEngine
(
engine
)
{
let
domain
=
engine
.
getResultDomain
(
)
;
let
suffix
=
engine
.
searchUrlPublicSuffix
;
if
(
!
suffix
)
{
if
(
domain
.
endsWith
(
"
.
test
"
)
)
{
suffix
=
"
test
"
;
}
else
{
return
domain
;
}
}
domain
=
domain
.
substr
(
0
domain
.
length
-
suffix
.
length
-
1
)
;
let
domainParts
=
domain
.
split
(
"
.
"
)
;
return
domainParts
.
pop
(
)
;
}
getDefaultEngine
(
isPrivate
=
false
)
{
return
this
.
separatePrivateDefaultUIEnabled
&
&
this
.
separatePrivateDefault
&
&
isPrivate
?
Services
.
search
.
defaultPrivateEngine
:
Services
.
search
.
defaultEngine
;
}
getSearchModeScalarKey
(
searchMode
)
{
let
scalarKey
;
if
(
searchMode
.
engineName
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
searchMode
.
engineName
)
;
let
resultDomain
=
engine
.
getResultDomain
(
)
;
if
(
!
engine
.
isAppProvided
)
{
scalarKey
=
"
other
"
;
}
else
if
(
resultDomain
.
includes
(
"
amazon
.
"
)
)
{
scalarKey
=
"
Amazon
"
;
}
else
if
(
resultDomain
.
endsWith
(
"
wikipedia
.
org
"
)
)
{
scalarKey
=
"
Wikipedia
"
;
}
else
{
scalarKey
=
searchMode
.
engineName
;
}
}
else
if
(
searchMode
.
source
)
{
scalarKey
=
lazy
.
UrlbarUtils
.
getResultSourceName
(
searchMode
.
source
)
|
|
"
other
"
;
}
return
scalarKey
;
}
async
_initInternal
(
)
{
await
Services
.
search
.
init
(
)
;
await
this
.
_refreshEnginesByAlias
(
)
;
Services
.
obs
.
addObserver
(
this
SEARCH_ENGINE_TOPIC
true
)
;
}
async
_refreshEnginesByAlias
(
)
{
this
.
_enginesByAlias
=
new
Map
(
)
;
for
(
let
engine
of
await
Services
.
search
.
getVisibleEngines
(
)
)
{
if
(
!
engine
.
hidden
)
{
for
(
let
alias
of
this
.
_aliasesForEngine
(
engine
)
)
{
this
.
_enginesByAlias
.
set
(
alias
engine
)
;
}
}
}
}
serpsAreEquivalent
(
historySerp
generatedSerp
ignoreParams
=
[
]
)
{
let
historyParams
=
new
URL
(
historySerp
)
.
searchParams
;
let
generatedParams
=
new
URL
(
generatedSerp
)
.
searchParams
;
if
(
!
Array
.
from
(
historyParams
.
entries
(
)
)
.
every
(
(
[
key
value
]
)
=
>
ignoreParams
.
includes
(
key
)
|
|
value
=
=
=
generatedParams
.
get
(
key
)
)
)
{
return
false
;
}
return
true
;
}
_aliasesForEngine
(
engine
)
{
return
engine
.
aliases
.
reduce
(
(
aliases
aliasWithCase
)
=
>
{
let
alias
=
aliasWithCase
.
toLocaleLowerCase
(
)
;
aliases
.
push
(
alias
)
;
if
(
!
alias
.
startsWith
(
"
"
)
)
{
aliases
.
push
(
"
"
+
alias
)
;
}
return
aliases
;
}
[
]
)
;
}
observe
(
subject
topic
data
)
{
switch
(
data
)
{
case
"
engine
-
added
"
:
case
"
engine
-
changed
"
:
case
"
engine
-
removed
"
:
case
"
engine
-
default
"
:
this
.
_refreshEnginesByAliasPromise
=
this
.
_refreshEnginesByAlias
(
)
;
break
;
}
}
}
var
UrlbarSearchUtils
=
new
SearchUtils
(
)
;
