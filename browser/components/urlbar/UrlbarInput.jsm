"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarInput
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
ExtensionSearchHandler
:
"
resource
:
/
/
gre
/
modules
/
ExtensionSearchHandler
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
ReaderMode
:
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarController
:
"
resource
:
/
/
/
modules
/
UrlbarController
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarQueryContext
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarValueFormatter
:
"
resource
:
/
/
/
modules
/
UrlbarValueFormatter
.
jsm
"
UrlbarView
:
"
resource
:
/
/
/
modules
/
UrlbarView
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ClipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
class
UrlbarInput
{
constructor
(
options
=
{
}
)
{
this
.
textbox
=
options
.
textbox
;
this
.
textbox
.
clickSelectsAll
=
UrlbarPrefs
.
get
(
"
clickSelectsAll
"
)
;
this
.
panel
=
options
.
panel
;
this
.
window
=
this
.
textbox
.
ownerGlobal
;
this
.
document
=
this
.
window
.
document
;
this
.
controller
=
options
.
controller
|
|
new
UrlbarController
(
{
browserWindow
:
this
.
window
}
)
;
this
.
controller
.
setInput
(
this
)
;
this
.
view
=
new
UrlbarView
(
this
)
;
this
.
valueIsTyped
=
false
;
this
.
userInitiatedFocus
=
false
;
this
.
isPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
;
this
.
lastQueryContextPromise
=
Promise
.
resolve
(
)
;
this
.
_untrimmedValue
=
"
"
;
this
.
_suppressStartQuery
=
false
;
this
.
_actionOverrideKeyCount
=
0
;
const
METHODS
=
[
"
addEventListener
"
"
removeEventListener
"
"
setAttribute
"
"
hasAttribute
"
"
removeAttribute
"
"
getAttribute
"
"
select
"
]
;
const
READ_ONLY_PROPERTIES
=
[
"
inputField
"
"
editor
"
]
;
const
READ_WRITE_PROPERTIES
=
[
"
placeholder
"
"
readOnly
"
"
selectionStart
"
"
selectionEnd
"
]
;
for
(
let
method
of
METHODS
)
{
this
[
method
]
=
(
.
.
.
args
)
=
>
{
return
this
.
textbox
[
method
]
(
.
.
.
args
)
;
}
;
}
for
(
let
property
of
READ_ONLY_PROPERTIES
)
{
Object
.
defineProperty
(
this
property
{
enumerable
:
true
get
(
)
{
return
this
.
textbox
[
property
]
;
}
}
)
;
}
for
(
let
property
of
READ_WRITE_PROPERTIES
)
{
Object
.
defineProperty
(
this
property
{
enumerable
:
true
get
(
)
{
return
this
.
textbox
[
property
]
;
}
set
(
val
)
{
return
this
.
textbox
[
property
]
=
val
;
}
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
valueFormatter
"
(
)
=
>
{
return
new
UrlbarValueFormatter
(
this
)
;
}
)
;
this
.
addEventListener
(
"
mousedown
"
this
)
;
this
.
inputField
.
addEventListener
(
"
blur
"
this
)
;
this
.
inputField
.
addEventListener
(
"
focus
"
this
)
;
this
.
inputField
.
addEventListener
(
"
input
"
this
)
;
this
.
inputField
.
addEventListener
(
"
mouseover
"
this
)
;
this
.
inputField
.
addEventListener
(
"
overflow
"
this
)
;
this
.
inputField
.
addEventListener
(
"
underflow
"
this
)
;
this
.
inputField
.
addEventListener
(
"
scrollend
"
this
)
;
this
.
inputField
.
addEventListener
(
"
select
"
this
)
;
this
.
inputField
.
addEventListener
(
"
keydown
"
this
)
;
this
.
inputField
.
addEventListener
(
"
keyup
"
this
)
;
this
.
view
.
panel
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
view
.
panel
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
inputField
.
controllers
.
insertControllerAt
(
0
new
CopyCutController
(
this
)
)
;
this
.
_initPasteAndGo
(
)
;
}
trimValue
(
val
)
{
return
UrlbarPrefs
.
get
(
"
trimURLs
"
)
?
this
.
window
.
trimURL
(
val
)
:
val
;
}
formatValue
(
)
{
this
.
valueFormatter
.
update
(
)
;
}
closePopup
(
)
{
this
.
controller
.
cancelQuery
(
)
;
this
.
view
.
close
(
)
;
}
focus
(
)
{
this
.
inputField
.
focus
(
)
;
}
blur
(
)
{
this
.
inputField
.
blur
(
)
;
}
makeURIReadable
(
uri
)
{
let
readerStrippedURI
=
ReaderMode
.
getOriginalUrlObjectForDisplay
(
uri
.
displaySpec
)
;
if
(
readerStrippedURI
)
{
return
readerStrippedURI
;
}
try
{
return
Services
.
uriFixup
.
createExposableURI
(
uri
)
;
}
catch
(
ex
)
{
}
return
uri
;
}
handleEvent
(
event
)
{
let
methodName
=
"
_on_
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
new
Error
(
"
Unrecognized
UrlbarInput
event
:
"
+
event
.
type
)
;
}
}
handleCommand
(
event
openWhere
openParams
=
{
}
triggeringPrincipal
=
null
)
{
let
isMouseEvent
=
event
instanceof
this
.
window
.
MouseEvent
;
if
(
isMouseEvent
&
&
event
.
button
=
=
2
)
{
return
;
}
let
result
=
this
.
view
.
selectedResult
;
if
(
result
)
{
this
.
pickResult
(
event
result
)
;
return
;
}
let
url
=
this
.
value
;
if
(
!
url
)
{
return
;
}
let
where
=
openWhere
|
|
this
.
_whereToOpen
(
event
)
;
openParams
.
postData
=
null
;
openParams
.
allowInheritPrincipal
=
false
;
url
=
this
.
_maybeCanonizeURL
(
event
url
)
|
|
url
.
trim
(
)
;
try
{
new
URL
(
url
)
;
}
catch
(
ex
)
{
let
browser
=
this
.
window
.
gBrowser
.
selectedBrowser
;
let
lastLocationChange
=
browser
.
lastLocationChange
;
UrlbarUtils
.
getShortcutOrURIAndPostData
(
url
)
.
then
(
data
=
>
{
if
(
where
!
=
"
current
"
|
|
browser
.
lastLocationChange
=
=
lastLocationChange
)
{
openParams
.
postData
=
data
.
postData
;
openParams
.
allowInheritPrincipal
=
data
.
mayInheritPrincipal
;
this
.
_loadURL
(
data
.
url
where
openParams
)
;
}
}
)
;
return
;
}
this
.
_loadURL
(
url
where
openParams
)
;
}
handleRevert
(
)
{
this
.
window
.
gBrowser
.
userTypedValue
=
null
;
this
.
window
.
URLBarSetURI
(
null
true
)
;
if
(
this
.
value
&
&
this
.
focused
)
{
this
.
select
(
)
;
}
}
pickResult
(
event
result
)
{
this
.
setValueFromResult
(
result
)
;
this
.
view
.
close
(
)
;
let
where
=
this
.
_whereToOpen
(
event
)
;
let
{
url
postData
}
=
UrlbarUtils
.
getUrlFromResult
(
result
)
;
let
openParams
=
{
postData
allowInheritPrincipal
:
false
}
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
{
if
(
this
.
hasAttribute
(
"
actionoverride
"
)
)
{
where
=
"
current
"
;
break
;
}
this
.
handleRevert
(
)
;
let
prevTab
=
this
.
window
.
gBrowser
.
selectedTab
;
let
loadOpts
=
{
adoptIntoActiveWindow
:
UrlbarPrefs
.
get
(
"
switchTabs
.
adoptIntoActiveWindow
"
)
}
;
if
(
this
.
window
.
switchToTabHavingURI
(
Services
.
io
.
newURI
(
url
)
false
loadOpts
)
&
&
prevTab
.
isEmpty
)
{
this
.
window
.
gBrowser
.
removeTab
(
prevTab
)
;
}
return
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
{
let
canonizedUrl
=
this
.
_maybeCanonizeURL
(
event
result
.
payload
.
suggestion
|
|
result
.
payload
.
query
)
;
if
(
canonizedUrl
)
{
url
=
canonizedUrl
;
break
;
}
const
actionDetails
=
{
isSuggestion
:
!
!
result
.
payload
.
suggestion
alias
:
result
.
payload
.
keyword
}
;
const
engine
=
Services
.
search
.
getEngineByName
(
result
.
payload
.
engine
)
;
this
.
_recordSearch
(
engine
event
actionDetails
)
;
break
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
{
ExtensionSearchHandler
.
handleInputEntered
(
result
.
payload
.
keyword
result
.
payload
.
content
where
)
;
return
;
}
}
if
(
!
url
)
{
throw
new
Error
(
Invalid
url
for
result
{
JSON
.
stringify
(
result
)
}
)
;
}
this
.
_loadURL
(
url
where
openParams
)
;
}
setValueFromResult
(
result
)
{
let
val
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
val
=
result
.
payload
.
suggestion
|
|
result
.
payload
.
query
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
val
=
result
.
payload
.
content
;
break
;
default
:
{
val
=
result
.
payload
.
url
;
let
uri
;
try
{
uri
=
Services
.
io
.
newURI
(
val
)
;
}
catch
(
ex
)
{
}
if
(
uri
)
{
val
=
this
.
window
.
losslessDecodeURI
(
uri
)
;
}
break
;
}
}
this
.
value
=
val
;
this
.
window
.
gBrowser
.
userTypedValue
=
val
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
this
.
setAttribute
(
"
actiontype
"
"
switchtab
"
)
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
this
.
setAttribute
(
"
actiontype
"
"
extension
"
)
;
break
;
}
}
startQuery
(
{
lastKey
=
null
}
=
{
}
)
{
if
(
this
.
_suppressStartQuery
)
{
return
;
}
let
searchString
=
this
.
textValue
;
let
enableAutofill
=
UrlbarPrefs
.
get
(
"
autoFill
"
)
&
&
(
!
this
.
_lastSearchString
|
|
!
this
.
_lastSearchString
.
startsWith
(
searchString
)
)
;
this
.
_lastSearchString
=
searchString
;
this
.
lastQueryContextPromise
=
this
.
controller
.
startQuery
(
new
UrlbarQueryContext
(
{
enableAutofill
isPrivate
:
this
.
isPrivate
lastKey
maxResults
:
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
muxer
:
"
UnifiedComplete
"
providers
:
[
"
UnifiedComplete
"
]
searchString
}
)
)
;
}
search
(
value
)
{
this
.
window
.
focusAndSelectUrlBar
(
)
;
if
(
Object
.
values
(
UrlbarTokenizer
.
RESTRICT
)
.
includes
(
value
)
)
{
this
.
inputField
.
value
=
value
+
"
"
;
}
else
{
this
.
inputField
.
value
=
value
;
}
this
.
selectionStart
=
-
1
;
let
event
=
this
.
document
.
createEvent
(
"
UIEvents
"
)
;
event
.
initUIEvent
(
"
input
"
true
false
this
.
window
0
)
;
this
.
inputField
.
dispatchEvent
(
event
)
;
}
setHiddenFocus
(
)
{
this
.
textbox
.
classList
.
add
(
"
hidden
-
focus
"
)
;
this
.
focus
(
)
;
}
removeHiddenFocus
(
)
{
this
.
textbox
.
classList
.
remove
(
"
hidden
-
focus
"
)
;
}
autofill
(
value
)
{
if
(
!
value
.
toLocaleLowerCase
(
)
.
startsWith
(
this
.
textValue
.
toLocaleLowerCase
(
)
)
)
{
return
;
}
let
len
=
this
.
textValue
.
length
;
this
.
value
=
this
.
textValue
+
value
.
substring
(
len
)
;
this
.
selectionStart
=
len
;
this
.
selectionEnd
=
value
.
length
;
}
get
focused
(
)
{
return
this
.
textbox
.
getAttribute
(
"
focused
"
)
=
=
"
true
"
;
}
get
goButton
(
)
{
return
this
.
document
.
getAnonymousElementByAttribute
(
this
.
textbox
"
anonid
"
"
urlbar
-
go
-
button
"
)
;
}
get
textValue
(
)
{
return
this
.
inputField
.
value
;
}
get
value
(
)
{
return
this
.
_untrimmedValue
;
}
set
value
(
val
)
{
this
.
_untrimmedValue
=
val
;
let
originalUrl
=
ReaderMode
.
getOriginalUrlObjectForDisplay
(
val
)
;
if
(
originalUrl
)
{
val
=
originalUrl
.
displaySpec
;
}
val
=
this
.
trimValue
(
val
)
;
this
.
valueIsTyped
=
false
;
this
.
inputField
.
value
=
val
;
this
.
formatValue
(
)
;
this
.
removeAttribute
(
"
actiontype
"
)
;
let
event
=
this
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
ValueChange
"
true
true
)
;
this
.
inputField
.
dispatchEvent
(
event
)
;
return
val
;
}
_updateTextOverflow
(
)
{
if
(
!
this
.
_overflowing
)
{
this
.
removeAttribute
(
"
textoverflow
"
)
;
return
;
}
this
.
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
input
=
this
.
inputField
;
if
(
input
&
&
this
.
_overflowing
)
{
let
side
=
input
.
scrollLeft
&
&
input
.
scrollLeft
=
=
input
.
scrollLeftMax
?
"
start
"
:
"
end
"
;
this
.
window
.
requestAnimationFrame
(
(
)
=
>
{
if
(
this
.
_overflowing
)
{
this
.
setAttribute
(
"
textoverflow
"
side
)
;
}
}
)
;
}
}
)
;
}
_updateUrlTooltip
(
)
{
if
(
this
.
focused
|
|
!
this
.
_overflowing
)
{
this
.
inputField
.
removeAttribute
(
"
title
"
)
;
}
else
{
this
.
inputField
.
setAttribute
(
"
title
"
this
.
value
)
;
}
}
_getSelectedValueForClipboard
(
)
{
let
inputVal
=
this
.
inputField
.
value
;
let
selection
=
this
.
editor
.
selection
;
const
flags
=
Ci
.
nsIDocumentEncoder
.
OutputPreformatted
|
Ci
.
nsIDocumentEncoder
.
OutputRaw
;
let
selectedVal
=
selection
.
toStringWithFormat
(
"
text
/
plain
"
flags
0
)
;
if
(
selection
.
rangeCount
>
1
)
{
return
selectedVal
;
}
if
(
this
.
selectionStart
>
0
|
|
this
.
valueIsTyped
|
|
selectedVal
=
=
"
"
)
{
return
selectedVal
;
}
if
(
!
selectedVal
.
includes
(
"
/
"
)
)
{
let
remainder
=
inputVal
.
replace
(
selectedVal
"
"
)
;
if
(
remainder
!
=
"
"
&
&
remainder
[
0
]
!
=
"
/
"
)
{
return
selectedVal
;
}
}
let
uri
;
if
(
this
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
valid
"
)
{
uri
=
this
.
window
.
gBrowser
.
currentURI
;
}
else
{
try
{
uri
=
Services
.
uriFixup
.
createFixupURI
(
inputVal
Services
.
uriFixup
.
FIXUP_FLAG_NONE
)
;
}
catch
(
e
)
{
}
if
(
!
uri
)
{
return
selectedVal
;
}
}
uri
=
this
.
makeURIReadable
(
uri
)
;
if
(
inputVal
=
=
selectedVal
&
&
!
uri
.
schemeIs
(
"
javascript
"
)
&
&
!
uri
.
schemeIs
(
"
data
"
)
&
&
!
UrlbarPrefs
.
get
(
"
decodeURLsOnCopy
"
)
)
{
return
uri
.
displaySpec
;
}
let
spec
=
uri
.
displaySpec
;
let
trimmedSpec
=
this
.
trimValue
(
spec
)
;
if
(
spec
!
=
trimmedSpec
)
{
let
trimmedSegments
=
spec
.
split
(
trimmedSpec
)
;
selectedVal
=
trimmedSegments
[
0
]
+
selectedVal
;
}
return
selectedVal
;
}
_toggleActionOverride
(
event
)
{
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_SHIFT
|
|
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_ALT
|
|
event
.
keyCode
=
=
(
AppConstants
.
platform
=
=
"
macosx
"
?
KeyEvent
.
DOM_VK_META
:
KeyEvent
.
DOM_VK_CONTROL
)
)
{
if
(
event
.
type
=
=
"
keydown
"
)
{
this
.
_actionOverrideKeyCount
+
+
;
this
.
setAttribute
(
"
actionoverride
"
"
true
"
)
;
this
.
view
.
panel
.
setAttribute
(
"
actionoverride
"
"
true
"
)
;
}
else
if
(
this
.
_actionOverrideKeyCount
&
&
-
-
this
.
_actionOverrideKeyCount
=
=
0
)
{
this
.
removeAttribute
(
"
actionoverride
"
)
;
this
.
view
.
panel
.
removeAttribute
(
"
actionoverride
"
)
;
}
}
}
_recordSearch
(
engine
event
searchActionDetails
=
{
}
)
{
const
isOneOff
=
this
.
view
.
oneOffSearchButtons
.
maybeRecordTelemetry
(
event
)
;
let
eventType
=
"
unknown
"
;
if
(
event
instanceof
KeyboardEvent
)
{
eventType
=
"
key
"
;
}
else
if
(
event
instanceof
MouseEvent
)
{
eventType
=
"
mouse
"
;
}
let
details
=
searchActionDetails
;
details
.
isOneOff
=
isOneOff
;
details
.
type
=
eventType
;
this
.
window
.
BrowserSearch
.
recordSearchInTelemetry
(
engine
"
urlbar
"
details
)
;
}
_maybeCanonizeURL
(
event
value
)
{
if
(
!
(
event
instanceof
KeyboardEvent
)
|
|
!
event
.
ctrlKey
|
|
!
UrlbarPrefs
.
get
(
"
ctrlCanonizesURLs
"
)
|
|
!
/
^
\
s
*
[
^
.
:
\
/
\
s
]
+
(
?
:
\
/
.
*
|
\
s
*
)
/
i
.
test
(
value
)
)
{
return
null
;
}
let
suffix
=
Services
.
prefs
.
getCharPref
(
"
browser
.
fixup
.
alternate
.
suffix
"
)
;
if
(
!
suffix
.
endsWith
(
"
/
"
)
)
{
suffix
+
=
"
/
"
;
}
value
=
value
.
trim
(
)
;
let
firstSlash
=
value
.
indexOf
(
"
/
"
)
;
if
(
firstSlash
>
=
0
)
{
value
=
value
.
substring
(
0
firstSlash
)
+
suffix
+
value
.
substring
(
firstSlash
+
1
)
;
}
else
{
value
=
value
+
suffix
;
}
value
=
"
http
:
/
/
www
.
"
+
value
;
this
.
value
=
value
;
return
value
;
}
_loadURL
(
url
openUILinkWhere
params
)
{
let
browser
=
this
.
window
.
gBrowser
.
selectedBrowser
;
if
(
this
.
window
.
gInitialPages
.
includes
(
url
)
)
{
browser
.
initialPageLoadedFromUserAction
=
url
;
}
try
{
UrlbarUtils
.
addToUrlbarHistory
(
url
this
.
window
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
params
.
allowThirdPartyFixup
=
true
;
if
(
openUILinkWhere
=
=
"
current
"
)
{
params
.
targetBrowser
=
browser
;
params
.
indicateErrorPageLoad
=
true
;
params
.
allowPinnedTabHostChange
=
true
;
params
.
allowPopups
=
url
.
startsWith
(
"
javascript
:
"
)
;
}
else
{
params
.
initiatingDoc
=
this
.
window
.
document
;
}
browser
.
focus
(
)
;
if
(
openUILinkWhere
!
=
"
current
"
)
{
this
.
handleRevert
(
)
;
}
try
{
this
.
window
.
openTrustedLinkIn
(
url
openUILinkWhere
params
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_LOAD_SHOWED_ERRORPAGE
)
{
this
.
handleRevert
(
)
;
}
}
this
.
closePopup
(
)
;
}
_whereToOpen
(
event
)
{
let
isMouseEvent
=
event
instanceof
MouseEvent
;
let
reuseEmpty
=
!
isMouseEvent
;
let
where
=
undefined
;
if
(
!
isMouseEvent
&
&
event
&
&
event
.
altKey
)
{
where
=
event
.
shiftKey
?
"
tabshifted
"
:
"
tab
"
;
}
else
if
(
!
isMouseEvent
&
&
event
&
&
event
.
ctrlKey
&
&
UrlbarPrefs
.
get
(
"
ctrlCanonizesURLs
"
)
)
{
where
=
"
current
"
;
}
else
{
where
=
this
.
window
.
whereToOpenLink
(
event
false
false
)
;
}
if
(
UrlbarPrefs
.
get
(
"
openintab
"
)
)
{
if
(
where
=
=
"
current
"
)
{
where
=
"
tab
"
;
}
else
if
(
where
=
=
"
tab
"
)
{
where
=
"
current
"
;
}
reuseEmpty
=
true
;
}
if
(
where
=
=
"
tab
"
&
&
reuseEmpty
&
&
this
.
window
.
gBrowser
.
selectedTab
.
isEmpty
)
{
where
=
"
current
"
;
}
return
where
;
}
_initPasteAndGo
(
)
{
let
inputBox
=
this
.
document
.
getAnonymousElementByAttribute
(
this
.
textbox
"
anonid
"
"
moz
-
input
-
box
"
)
;
this
.
window
.
customElements
.
upgrade
(
inputBox
)
;
let
contextMenu
=
inputBox
.
menupopup
;
let
insertLocation
=
contextMenu
.
firstElementChild
;
while
(
insertLocation
.
nextElementSibling
&
&
insertLocation
.
getAttribute
(
"
cmd
"
)
!
=
"
cmd_paste
"
)
{
insertLocation
=
insertLocation
.
nextElementSibling
;
}
if
(
!
insertLocation
)
{
return
;
}
let
pasteAndGo
=
this
.
document
.
createXULElement
(
"
menuitem
"
)
;
let
label
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
.
GetStringFromName
(
"
pasteAndGo
.
label
"
)
;
pasteAndGo
.
setAttribute
(
"
label
"
label
)
;
pasteAndGo
.
setAttribute
(
"
anonid
"
"
paste
-
and
-
go
"
)
;
pasteAndGo
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
_suppressStartQuery
=
true
;
this
.
select
(
)
;
this
.
window
.
goDoCommand
(
"
cmd_paste
"
)
;
this
.
handleCommand
(
)
;
this
.
_suppressStartQuery
=
false
;
}
)
;
contextMenu
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
let
controller
=
this
.
document
.
commandDispatcher
.
getControllerForCommand
(
"
cmd_paste
"
)
;
let
enabled
=
controller
.
isCommandEnabled
(
"
cmd_paste
"
)
;
if
(
enabled
)
{
pasteAndGo
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
pasteAndGo
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
)
;
insertLocation
.
insertAdjacentElement
(
"
afterend
"
pasteAndGo
)
;
}
_on_blur
(
event
)
{
this
.
formatValue
(
)
;
this
.
closePopup
(
)
;
}
_on_focus
(
event
)
{
this
.
_updateUrlTooltip
(
)
;
this
.
formatValue
(
)
;
}
_on_mouseover
(
event
)
{
this
.
_updateUrlTooltip
(
)
;
}
_on_mousedown
(
event
)
{
if
(
event
.
originalTarget
=
=
this
.
inputField
&
&
event
.
button
=
=
0
&
&
event
.
detail
=
=
2
&
&
UrlbarPrefs
.
get
(
"
doubleClickSelectsAll
"
)
)
{
this
.
editor
.
selectAll
(
)
;
event
.
preventDefault
(
)
;
return
;
}
if
(
event
.
originalTarget
.
classList
.
contains
(
"
urlbar
-
history
-
dropmarker
"
)
&
&
event
.
button
=
=
0
)
{
if
(
this
.
view
.
isOpen
)
{
this
.
view
.
close
(
)
;
}
else
{
this
.
startQuery
(
)
;
}
}
}
_on_input
(
)
{
let
value
=
this
.
textValue
;
this
.
valueIsTyped
=
true
;
this
.
_untrimmedValue
=
value
;
this
.
window
.
gBrowser
.
userTypedValue
=
value
;
if
(
value
)
{
this
.
setAttribute
(
"
usertyping
"
"
true
"
)
;
}
else
{
this
.
removeAttribute
(
"
usertyping
"
)
;
}
this
.
removeAttribute
(
"
actiontype
"
)
;
this
.
startQuery
(
{
lastKey
:
null
}
)
;
}
_on_select
(
event
)
{
if
(
!
Services
.
clipboard
.
supportsSelectionClipboard
(
)
)
{
return
;
}
if
(
!
this
.
window
.
windowUtils
.
isHandlingUserInput
)
{
return
;
}
let
val
=
this
.
_getSelectedValueForClipboard
(
)
;
if
(
!
val
)
{
return
;
}
ClipboardHelper
.
copyStringToClipboard
(
val
Services
.
clipboard
.
kSelectionClipboard
)
;
}
_on_overflow
(
event
)
{
const
targetIsPlaceholder
=
!
event
.
originalTarget
.
classList
.
contains
(
"
anonymous
-
div
"
)
;
if
(
targetIsPlaceholder
)
{
return
;
}
this
.
_overflowing
=
true
;
this
.
_updateTextOverflow
(
)
;
}
_on_underflow
(
event
)
{
const
targetIsPlaceholder
=
!
event
.
originalTarget
.
classList
.
contains
(
"
anonymous
-
div
"
)
;
if
(
targetIsPlaceholder
)
{
return
;
}
this
.
_overflowing
=
false
;
this
.
_updateTextOverflow
(
)
;
this
.
_updateUrlTooltip
(
)
;
}
_on_scrollend
(
event
)
{
this
.
_updateTextOverflow
(
)
;
}
_on_TabSelect
(
event
)
{
this
.
controller
.
tabContextChanged
(
)
;
}
_on_keydown
(
event
)
{
this
.
controller
.
handleKeyNavigation
(
event
)
;
this
.
_toggleActionOverride
(
event
)
;
}
_on_keyup
(
event
)
{
this
.
_toggleActionOverride
(
event
)
;
}
_on_popupshowing
(
)
{
this
.
setAttribute
(
"
open
"
"
true
"
)
;
}
_on_popuphidden
(
)
{
this
.
removeAttribute
(
"
open
"
)
;
}
}
class
CopyCutController
{
constructor
(
urlbar
)
{
this
.
urlbar
=
urlbar
;
}
doCommand
(
command
)
{
let
urlbar
=
this
.
urlbar
;
let
val
=
urlbar
.
_getSelectedValueForClipboard
(
)
;
if
(
!
val
)
{
return
;
}
if
(
command
=
=
"
cmd_cut
"
&
&
this
.
isCommandEnabled
(
command
)
)
{
let
start
=
urlbar
.
selectionStart
;
let
end
=
urlbar
.
selectionEnd
;
urlbar
.
inputField
.
value
=
urlbar
.
inputField
.
value
.
substring
(
0
start
)
+
urlbar
.
inputField
.
value
.
substring
(
end
)
;
urlbar
.
selectionStart
=
urlbar
.
selectionEnd
=
start
;
let
event
=
urlbar
.
document
.
createEvent
(
"
UIEvents
"
)
;
event
.
initUIEvent
(
"
input
"
true
false
urlbar
.
window
0
)
;
urlbar
.
inputField
.
dispatchEvent
(
event
)
;
}
ClipboardHelper
.
copyString
(
val
)
;
}
supportsCommand
(
command
)
{
switch
(
command
)
{
case
"
cmd_copy
"
:
case
"
cmd_cut
"
:
return
true
;
}
return
false
;
}
isCommandEnabled
(
command
)
{
return
this
.
supportsCommand
(
command
)
&
&
(
command
!
=
"
cmd_cut
"
|
|
!
this
.
urlbar
.
readOnly
)
&
&
this
.
urlbar
.
selectionStart
<
this
.
urlbar
.
selectionEnd
;
}
onEvent
(
)
{
}
}
