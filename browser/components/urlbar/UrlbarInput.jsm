"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarInput
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
BrowserSearchTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserSearchTelemetry
.
jsm
"
BrowserUIUtils
:
"
resource
:
/
/
/
modules
/
BrowserUIUtils
.
jsm
"
CONTEXTUAL_SERVICES_PING_TYPES
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
ExtensionSearchHandler
:
"
resource
:
/
/
gre
/
modules
/
ExtensionSearchHandler
.
jsm
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
ReaderMode
:
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
PartnerLinkAttribution
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
SearchUIUtils
:
"
resource
:
/
/
/
modules
/
SearchUIUtils
.
jsm
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarController
:
"
resource
:
/
/
/
modules
/
UrlbarController
.
jsm
"
UrlbarEventBufferer
:
"
resource
:
/
/
/
modules
/
UrlbarEventBufferer
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarQueryContext
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarValueFormatter
:
"
resource
:
/
/
/
modules
/
UrlbarValueFormatter
.
jsm
"
UrlbarView
:
"
resource
:
/
/
/
modules
/
UrlbarView
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ClipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
const
DEFAULT_FORM_HISTORY_NAME
=
"
searchbar
-
history
"
;
const
SEARCH_BUTTON_ID
=
"
urlbar
-
search
-
button
"
;
const
SCALAR_CATEGORY_TOPSITES
=
"
contextual
.
services
.
topsites
.
click
"
;
let
getBoundsWithoutFlushing
=
element
=
>
element
.
ownerGlobal
.
windowUtils
.
getBoundsWithoutFlushing
(
element
)
;
let
px
=
number
=
>
number
.
toFixed
(
2
)
+
"
px
"
;
class
UrlbarInput
{
constructor
(
options
=
{
}
)
{
this
.
textbox
=
options
.
textbox
;
this
.
window
=
this
.
textbox
.
ownerGlobal
;
this
.
isPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
;
this
.
document
=
this
.
window
.
document
;
this
.
textbox
.
appendChild
(
this
.
window
.
MozXULElement
.
parseXULToFragment
(
<
vbox
class
=
"
urlbarView
"
role
=
"
group
"
tooltip
=
"
aHTMLTooltip
"
>
<
html
:
div
class
=
"
urlbarView
-
body
-
outer
"
>
<
html
:
div
class
=
"
urlbarView
-
body
-
inner
"
>
<
html
:
div
id
=
"
urlbar
-
results
"
class
=
"
urlbarView
-
results
"
role
=
"
listbox
"
/
>
<
/
html
:
div
>
<
/
html
:
div
>
<
hbox
class
=
"
search
-
one
-
offs
"
includecurrentengine
=
"
true
"
disabletab
=
"
true
"
/
>
<
/
vbox
>
)
)
;
this
.
panel
=
this
.
textbox
.
querySelector
(
"
.
urlbarView
"
)
;
this
.
searchButton
=
UrlbarPrefs
.
get
(
"
experimental
.
searchButton
"
)
;
if
(
this
.
searchButton
)
{
this
.
textbox
.
classList
.
add
(
"
searchButton
"
)
;
}
this
.
controller
=
new
UrlbarController
(
{
input
:
this
eventTelemetryCategory
:
options
.
eventTelemetryCategory
}
)
;
this
.
view
=
new
UrlbarView
(
this
)
;
this
.
valueIsTyped
=
false
;
this
.
formHistoryName
=
DEFAULT_FORM_HISTORY_NAME
;
this
.
lastQueryContextPromise
=
Promise
.
resolve
(
)
;
this
.
_actionOverrideKeyCount
=
0
;
this
.
_autofillPlaceholder
=
"
"
;
this
.
_lastSearchString
=
"
"
;
this
.
_lastValidURLStr
=
"
"
;
this
.
_valueOnLastSearch
=
"
"
;
this
.
_resultForCurrentValue
=
null
;
this
.
_suppressStartQuery
=
false
;
this
.
_suppressPrimaryAdjustment
=
false
;
this
.
_untrimmedValue
=
"
"
;
this
.
_searchModesByBrowser
=
new
WeakMap
(
)
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
;
this
.
_addObservers
(
)
;
this
.
_enableAutofillPlaceholder
=
true
;
const
CONTAINER_METHODS
=
[
"
getAttribute
"
"
hasAttribute
"
"
querySelector
"
"
setAttribute
"
"
removeAttribute
"
"
toggleAttribute
"
]
;
const
INPUT_METHODS
=
[
"
addEventListener
"
"
blur
"
"
removeEventListener
"
]
;
const
READ_WRITE_PROPERTIES
=
[
"
placeholder
"
"
readOnly
"
"
selectionStart
"
"
selectionEnd
"
]
;
for
(
let
method
of
CONTAINER_METHODS
)
{
this
[
method
]
=
(
.
.
.
args
)
=
>
{
return
this
.
textbox
[
method
]
(
.
.
.
args
)
;
}
;
}
for
(
let
method
of
INPUT_METHODS
)
{
this
[
method
]
=
(
.
.
.
args
)
=
>
{
return
this
.
inputField
[
method
]
(
.
.
.
args
)
;
}
;
}
for
(
let
property
of
READ_WRITE_PROPERTIES
)
{
Object
.
defineProperty
(
this
property
{
enumerable
:
true
get
(
)
{
return
this
.
inputField
[
property
]
;
}
set
(
val
)
{
this
.
inputField
[
property
]
=
val
;
}
}
)
;
}
this
.
inputField
=
this
.
querySelector
(
"
#
urlbar
-
input
"
)
;
this
.
_inputContainer
=
this
.
querySelector
(
"
#
urlbar
-
input
-
container
"
)
;
this
.
_identityBox
=
this
.
querySelector
(
"
#
identity
-
box
"
)
;
this
.
_searchModeIndicator
=
this
.
querySelector
(
"
#
urlbar
-
search
-
mode
-
indicator
"
)
;
this
.
_searchModeIndicatorTitle
=
this
.
_searchModeIndicator
.
querySelector
(
"
#
urlbar
-
search
-
mode
-
indicator
-
title
"
)
;
this
.
_searchModeIndicatorClose
=
this
.
_searchModeIndicator
.
querySelector
(
"
#
urlbar
-
search
-
mode
-
indicator
-
close
"
)
;
this
.
_searchModeLabel
=
this
.
querySelector
(
"
#
urlbar
-
label
-
search
-
mode
"
)
;
this
.
_toolbar
=
this
.
textbox
.
closest
(
"
toolbar
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
valueFormatter
"
(
)
=
>
{
return
new
UrlbarValueFormatter
(
this
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
addSearchEngineHelper
"
(
)
=
>
{
return
new
AddSearchEngineHelper
(
this
)
;
}
)
;
if
(
!
this
.
window
.
toolbar
.
visible
|
|
this
.
readOnly
)
{
return
;
}
this
.
eventBufferer
=
new
UrlbarEventBufferer
(
this
)
;
this
.
_inputFieldEvents
=
[
"
compositionstart
"
"
compositionend
"
"
contextmenu
"
"
dragover
"
"
dragstart
"
"
drop
"
"
focus
"
"
blur
"
"
input
"
"
beforeinput
"
"
keydown
"
"
keyup
"
"
mouseover
"
"
overflow
"
"
underflow
"
"
paste
"
"
scrollend
"
"
select
"
]
;
for
(
let
name
of
this
.
_inputFieldEvents
)
{
this
.
addEventListener
(
name
this
)
;
}
this
.
window
.
addEventListener
(
"
mousedown
"
this
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
this
.
window
.
addEventListener
(
"
draggableregionleftmousedown
"
this
)
;
}
this
.
textbox
.
addEventListener
(
"
mousedown
"
this
)
;
this
.
_inputContainer
.
addEventListener
(
"
click
"
this
)
;
this
.
view
.
panel
.
addEventListener
(
"
command
"
this
true
)
;
this
.
window
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
window
.
addEventListener
(
"
customizationstarting
"
this
)
;
this
.
window
.
addEventListener
(
"
aftercustomization
"
this
)
;
this
.
updateLayoutBreakout
(
)
;
this
.
_initCopyCutController
(
)
;
this
.
_initPasteAndGo
(
)
;
this
.
_compositionState
=
UrlbarUtils
.
COMPOSITION
.
NONE
;
this
.
_compositionClosedPopup
=
false
;
this
.
editor
.
newlineHandling
=
Ci
.
nsIEditor
.
eNewlinesStripSurroundingWhitespace
;
}
formatValue
(
)
{
if
(
this
.
editor
)
{
this
.
valueFormatter
.
update
(
)
;
}
}
focus
(
)
{
let
beforeFocus
=
new
CustomEvent
(
"
beforefocus
"
{
bubbles
:
true
cancelable
:
true
}
)
;
this
.
inputField
.
dispatchEvent
(
beforeFocus
)
;
if
(
beforeFocus
.
defaultPrevented
)
{
return
;
}
this
.
inputField
.
focus
(
)
;
}
select
(
)
{
let
beforeSelect
=
new
CustomEvent
(
"
beforeselect
"
{
bubbles
:
true
cancelable
:
true
}
)
;
this
.
inputField
.
dispatchEvent
(
beforeSelect
)
;
if
(
beforeSelect
.
defaultPrevented
)
{
return
;
}
this
.
_suppressPrimaryAdjustment
=
true
;
this
.
inputField
.
select
(
)
;
this
.
_suppressPrimaryAdjustment
=
false
;
}
setURI
(
uri
=
null
dueToTabSwitch
=
false
)
{
let
value
=
this
.
window
.
gBrowser
.
userTypedValue
;
let
valid
=
false
;
if
(
value
=
=
=
null
|
|
(
!
value
&
&
dueToTabSwitch
)
)
{
uri
=
uri
|
|
this
.
window
.
gBrowser
.
currentURI
;
try
{
uri
=
Services
.
io
.
createExposableURI
(
uri
)
;
}
catch
(
e
)
{
}
if
(
this
.
window
.
isInitialPage
(
uri
)
&
&
BrowserUIUtils
.
checkEmptyPageOrigin
(
this
.
window
.
gBrowser
.
selectedBrowser
uri
)
)
{
value
=
"
"
;
}
else
{
try
{
value
=
losslessDecodeURI
(
uri
)
;
}
catch
(
ex
)
{
value
=
"
about
:
blank
"
;
}
}
valid
=
!
this
.
window
.
isBlankPageURL
(
uri
.
spec
)
|
|
uri
.
schemeIs
(
"
moz
-
extension
"
)
;
}
else
if
(
this
.
window
.
isInitialPage
(
value
)
&
&
BrowserUIUtils
.
checkEmptyPageOrigin
(
this
.
window
.
gBrowser
.
selectedBrowser
)
)
{
value
=
"
"
;
valid
=
true
;
}
let
isDifferentValidValue
=
valid
&
&
value
!
=
this
.
untrimmedValue
;
this
.
value
=
value
;
this
.
valueIsTyped
=
!
valid
;
this
.
removeAttribute
(
"
usertyping
"
)
;
if
(
isDifferentValidValue
)
{
this
.
selectionStart
=
this
.
selectionEnd
=
0
;
}
this
.
setPageProxyState
(
valid
?
"
valid
"
:
"
invalid
"
dueToTabSwitch
)
;
if
(
dueToTabSwitch
&
&
!
valid
)
{
this
.
restoreSearchModeState
(
)
;
}
else
if
(
valid
)
{
this
.
searchMode
=
null
;
}
}
makeURIReadable
(
uri
)
{
let
readerStrippedURI
=
ReaderMode
.
getOriginalUrlObjectForDisplay
(
uri
.
displaySpec
)
;
if
(
readerStrippedURI
)
{
return
readerStrippedURI
;
}
try
{
return
Services
.
io
.
createExposableURI
(
uri
)
;
}
catch
(
ex
)
{
}
return
uri
;
}
handleEvent
(
event
)
{
let
methodName
=
"
_on_
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
new
Error
(
"
Unrecognized
UrlbarInput
event
:
"
+
event
.
type
)
;
}
}
handleCommand
(
event
=
null
)
{
let
isMouseEvent
=
event
instanceof
this
.
window
.
MouseEvent
;
if
(
isMouseEvent
&
&
event
.
button
=
=
2
)
{
return
;
}
if
(
this
.
view
.
isOpen
)
{
let
selectedOneOff
=
this
.
view
.
oneOffSearchButtons
.
selectedButton
;
if
(
selectedOneOff
&
&
(
!
isMouseEvent
|
|
event
.
target
=
=
selectedOneOff
)
)
{
this
.
view
.
oneOffSearchButtons
.
handleSearchCommand
(
event
{
engineName
:
selectedOneOff
.
engine
?
.
name
source
:
selectedOneOff
.
source
entry
:
"
oneoff
"
}
)
;
return
;
}
}
this
.
handleNavigation
(
{
event
}
)
;
}
handleNavigation
(
{
event
oneOffParams
triggeringPrincipal
}
)
{
let
element
=
this
.
view
.
selectedElement
;
let
result
=
this
.
view
.
getResultFromElement
(
element
)
;
let
openParams
=
oneOffParams
?
.
openParams
|
|
{
}
;
let
isComposing
=
this
.
editor
.
composing
;
let
selectedPrivateResult
=
result
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
inPrivateWindow
;
let
selectedPrivateEngineResult
=
selectedPrivateResult
&
&
result
.
payload
.
isPrivateEngine
;
if
(
!
isComposing
&
&
element
&
&
(
!
oneOffParams
?
.
engine
|
|
selectedPrivateEngineResult
)
)
{
this
.
pickElement
(
element
event
)
;
return
;
}
if
(
UrlbarPrefs
.
get
(
"
experimental
.
hideHeuristic
"
)
&
&
!
element
&
&
!
isComposing
&
&
!
oneOffParams
?
.
engine
&
&
this
.
_resultForCurrentValue
?
.
heuristic
)
{
this
.
pickResult
(
this
.
_resultForCurrentValue
event
)
;
return
;
}
if
(
!
result
&
&
this
.
value
.
startsWith
(
"
"
)
)
{
let
tokenAliasResult
=
this
.
view
.
getResultAtIndex
(
0
)
;
if
(
tokenAliasResult
?
.
autofill
&
&
tokenAliasResult
?
.
payload
.
keyword
)
{
this
.
pickResult
(
tokenAliasResult
event
)
;
return
;
}
}
let
url
;
let
selType
=
this
.
controller
.
engagementEvent
.
typeFromElement
(
element
)
;
let
typedValue
=
this
.
value
;
if
(
oneOffParams
?
.
engine
)
{
selType
=
"
oneoff
"
;
typedValue
=
this
.
_lastSearchString
;
result
=
this
.
_resultForCurrentValue
;
let
searchString
=
(
result
&
&
(
result
.
payload
.
suggestion
|
|
result
.
payload
.
query
)
)
|
|
this
.
_lastSearchString
;
[
url
openParams
.
postData
]
=
UrlbarUtils
.
getSearchQueryUrl
(
oneOffParams
.
engine
searchString
)
;
this
.
_recordSearch
(
oneOffParams
.
engine
event
{
url
}
)
;
UrlbarUtils
.
addToFormHistory
(
this
searchString
oneOffParams
.
engine
.
name
)
.
catch
(
Cu
.
reportError
)
;
}
else
{
url
=
this
.
untrimmedValue
;
openParams
.
postData
=
null
;
}
if
(
!
url
)
{
return
;
}
if
(
this
.
searchMode
&
&
!
this
.
searchMode
.
engineName
&
&
!
result
&
&
!
oneOffParams
)
{
return
;
}
let
selectedResult
=
result
|
|
this
.
view
.
selectedResult
;
this
.
controller
.
recordSelectedResult
(
event
selectedResult
)
;
let
where
=
oneOffParams
?
.
openWhere
|
|
this
.
_whereToOpen
(
event
)
;
if
(
selectedPrivateResult
)
{
where
=
"
window
"
;
openParams
.
private
=
true
;
}
openParams
.
allowInheritPrincipal
=
false
;
url
=
this
.
_maybeCanonizeURL
(
event
url
)
|
|
url
.
trim
(
)
;
this
.
controller
.
engagementEvent
.
record
(
event
{
searchString
:
typedValue
selIndex
:
this
.
view
.
selectedRowIndex
selType
provider
:
selectedResult
?
.
providerName
}
)
;
let
isValidUrl
=
false
;
try
{
new
URL
(
url
)
;
isValidUrl
=
true
;
}
catch
(
ex
)
{
}
if
(
isValidUrl
)
{
this
.
_loadURL
(
url
event
where
openParams
)
;
return
;
}
if
(
!
isComposing
&
&
this
.
_resultForCurrentValue
)
{
this
.
pickResult
(
this
.
_resultForCurrentValue
event
)
;
return
;
}
let
browser
=
this
.
window
.
gBrowser
.
selectedBrowser
;
let
lastLocationChange
=
browser
.
lastLocationChange
;
UrlbarUtils
.
getHeuristicResultFor
(
url
)
.
then
(
newResult
=
>
{
if
(
where
!
=
"
current
"
|
|
browser
.
lastLocationChange
=
=
lastLocationChange
)
{
this
.
pickResult
(
newResult
event
null
browser
)
;
}
}
)
.
catch
(
ex
=
>
{
if
(
url
)
{
let
flags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
|
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
if
(
this
.
isPrivate
)
{
flags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
let
{
preferredURI
:
uri
postData
}
=
Services
.
uriFixup
.
getFixupURIInfo
(
url
flags
)
;
if
(
where
!
=
"
current
"
|
|
browser
.
lastLocationChange
=
=
lastLocationChange
)
{
openParams
.
postData
=
postData
;
this
.
_loadURL
(
uri
.
spec
event
where
openParams
null
browser
)
;
}
}
}
)
;
}
handleRevert
(
)
{
this
.
window
.
gBrowser
.
userTypedValue
=
null
;
this
.
searchMode
=
null
;
this
.
setURI
(
null
true
)
;
if
(
this
.
value
&
&
this
.
focused
)
{
this
.
select
(
)
;
}
}
handoff
(
searchString
searchEngine
)
{
this
.
_isHandoffSession
=
true
;
if
(
UrlbarPrefs
.
get
(
"
shouldHandOffToSearchMode
"
)
&
&
searchEngine
)
{
this
.
search
(
searchString
{
searchEngine
searchModeEntry
:
"
handoff
"
}
)
;
}
else
{
this
.
search
(
searchString
)
;
}
}
pickElement
(
element
event
)
{
let
result
=
this
.
view
.
getResultFromElement
(
element
)
;
if
(
!
result
)
{
return
;
}
this
.
pickResult
(
result
event
element
)
;
}
pickResult
(
result
event
element
=
null
browser
=
this
.
window
.
gBrowser
.
selectedBrowser
)
{
if
(
result
.
heuristic
&
&
this
.
searchMode
?
.
isPreview
&
&
this
.
view
.
oneOffSearchButtons
.
selectedButton
)
{
this
.
confirmSearchMode
(
)
;
this
.
search
(
this
.
value
)
;
return
;
}
if
(
element
?
.
classList
.
contains
(
"
urlbarView
-
button
-
block
"
)
)
{
this
.
controller
.
handleDeleteEntry
(
result
)
;
return
;
}
let
urlOverride
;
if
(
element
?
.
classList
.
contains
(
"
urlbarView
-
button
-
help
"
)
)
{
urlOverride
=
result
.
payload
.
helpUrl
;
}
let
originalUntrimmedValue
=
this
.
untrimmedValue
;
let
isCanonized
=
this
.
setValueFromResult
(
{
result
event
urlOverride
}
)
;
let
where
=
this
.
_whereToOpen
(
event
)
;
let
openParams
=
{
allowInheritPrincipal
:
false
}
;
if
(
urlOverride
&
&
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
&
&
where
=
=
"
current
"
)
{
where
=
"
tab
"
;
}
let
selIndex
=
result
.
rowIndex
;
if
(
!
result
.
payload
.
providesSearchMode
)
{
this
.
view
.
close
(
{
elementPicked
:
true
}
)
;
}
this
.
controller
.
recordSelectedResult
(
event
result
)
;
if
(
isCanonized
)
{
this
.
controller
.
engagementEvent
.
record
(
event
{
searchString
:
this
.
_lastSearchString
selIndex
selType
:
"
canonized
"
provider
:
result
.
providerName
}
)
;
this
.
_loadURL
(
this
.
value
event
where
openParams
browser
)
;
return
;
}
let
{
url
postData
}
=
urlOverride
?
{
url
:
urlOverride
postData
:
null
}
:
UrlbarUtils
.
getUrlFromResult
(
result
)
;
openParams
.
postData
=
postData
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
{
if
(
result
.
heuristic
&
&
UrlbarPrefs
.
get
(
"
browser
.
fixup
.
dns_first_for_single_words
"
)
&
&
UrlbarUtils
.
looksLikeSingleWordHost
(
originalUntrimmedValue
)
)
{
url
=
originalUntrimmedValue
;
}
break
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
{
openParams
.
allowInheritPrincipal
=
true
;
break
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
{
if
(
this
.
hasAttribute
(
"
actionoverride
"
)
)
{
where
=
"
current
"
;
break
;
}
this
.
handleRevert
(
)
;
let
prevTab
=
this
.
window
.
gBrowser
.
selectedTab
;
let
loadOpts
=
{
adoptIntoActiveWindow
:
UrlbarPrefs
.
get
(
"
switchTabs
.
adoptIntoActiveWindow
"
)
}
;
let
searchString
=
this
.
_lastSearchString
;
this
.
controller
.
engagementEvent
.
record
(
event
{
searchString
selIndex
selType
:
"
tabswitch
"
provider
:
result
.
providerName
}
)
;
let
switched
=
this
.
window
.
switchToTabHavingURI
(
Services
.
io
.
newURI
(
url
)
false
loadOpts
)
;
if
(
switched
&
&
prevTab
.
isEmpty
)
{
this
.
window
.
gBrowser
.
removeTab
(
prevTab
)
;
}
if
(
switched
&
&
!
this
.
isPrivate
&
&
!
result
.
heuristic
)
{
UrlbarUtils
.
addToInputHistory
(
url
searchString
)
.
catch
(
Cu
.
reportError
)
;
}
return
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
{
if
(
result
.
payload
.
providesSearchMode
)
{
let
searchModeParams
=
this
.
_searchModeForResult
(
result
)
;
if
(
searchModeParams
)
{
this
.
searchMode
=
searchModeParams
;
this
.
search
(
"
"
)
;
}
return
;
}
if
(
!
this
.
searchMode
&
&
result
.
heuristic
&
&
!
UrlbarPrefs
.
get
(
"
browser
.
fixup
.
dns_first_for_single_words
"
)
&
&
UrlbarPrefs
.
get
(
"
dnsResolveSingleWordsAfterSearch
"
)
>
0
&
&
this
.
window
.
gKeywordURIFixup
&
&
UrlbarUtils
.
looksLikeSingleWordHost
(
originalUntrimmedValue
)
)
{
let
fixupInfo
=
this
.
_getURIFixupInfo
(
originalUntrimmedValue
.
trim
(
)
)
;
if
(
fixupInfo
)
{
this
.
window
.
gKeywordURIFixup
.
check
(
this
.
window
.
gBrowser
.
selectedBrowser
fixupInfo
)
;
}
}
if
(
result
.
payload
.
inPrivateWindow
)
{
where
=
"
window
"
;
openParams
.
private
=
true
;
}
const
actionDetails
=
{
isSuggestion
:
!
!
result
.
payload
.
suggestion
isFormHistory
:
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
alias
:
result
.
payload
.
keyword
url
}
;
const
engine
=
Services
.
search
.
getEngineByName
(
result
.
payload
.
engine
)
;
this
.
_recordSearch
(
engine
event
actionDetails
)
;
if
(
!
result
.
payload
.
inPrivateWindow
)
{
UrlbarUtils
.
addToFormHistory
(
this
result
.
payload
.
suggestion
|
|
result
.
payload
.
query
engine
.
name
)
.
catch
(
Cu
.
reportError
)
;
}
break
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
{
let
scalarName
;
if
(
element
.
classList
.
contains
(
"
urlbarView
-
button
-
help
"
)
)
{
url
=
result
.
payload
.
helpUrl
;
if
(
!
url
)
{
Cu
.
reportError
(
"
helpUrl
not
specified
"
)
;
return
;
}
scalarName
=
{
result
.
payload
.
type
}
-
help
;
}
else
{
scalarName
=
{
result
.
payload
.
type
}
-
picked
;
}
Services
.
telemetry
.
keyedScalarAdd
(
"
urlbar
.
tips
"
scalarName
1
)
;
if
(
!
url
)
{
this
.
handleRevert
(
)
;
this
.
controller
.
engagementEvent
.
record
(
event
{
searchString
:
this
.
_lastSearchString
selIndex
selType
:
"
tip
"
provider
:
result
.
providerName
}
)
;
let
provider
=
UrlbarProvidersManager
.
getProvider
(
result
.
providerName
)
;
if
(
!
provider
)
{
Cu
.
reportError
(
Provider
not
found
:
{
result
.
providerName
}
)
;
return
;
}
provider
.
tryMethod
(
"
pickResult
"
result
element
)
;
return
;
}
break
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
:
{
url
=
result
.
payload
.
url
;
if
(
!
url
|
|
!
result
.
payload
.
shouldNavigate
)
{
this
.
handleRevert
(
)
;
}
let
provider
=
UrlbarProvidersManager
.
getProvider
(
result
.
providerName
)
;
if
(
!
provider
)
{
Cu
.
reportError
(
Provider
not
found
:
{
result
.
providerName
}
)
;
return
;
}
provider
.
tryMethod
(
"
pickResult
"
result
element
)
;
if
(
!
url
|
|
!
result
.
payload
.
shouldNavigate
)
{
this
.
controller
.
engagementEvent
.
record
(
event
{
selIndex
searchString
:
this
.
_lastSearchString
selType
:
this
.
controller
.
engagementEvent
.
typeFromElement
(
element
)
provider
:
result
.
providerName
}
)
;
return
;
}
break
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
{
this
.
controller
.
engagementEvent
.
record
(
event
{
searchString
:
this
.
_lastSearchString
selIndex
selType
:
"
extension
"
provider
:
result
.
providerName
}
)
;
this
.
handleRevert
(
)
;
ExtensionSearchHandler
.
handleInputEntered
(
result
.
payload
.
keyword
result
.
payload
.
content
where
)
;
return
;
}
}
if
(
!
url
)
{
throw
new
Error
(
Invalid
url
for
result
{
JSON
.
stringify
(
result
)
}
)
;
}
if
(
!
this
.
isPrivate
&
&
!
result
.
heuristic
)
{
UrlbarUtils
.
addToInputHistory
(
url
this
.
_lastSearchString
)
.
catch
(
Cu
.
reportError
)
;
}
this
.
controller
.
engagementEvent
.
record
(
event
{
searchString
:
this
.
_lastSearchString
selIndex
selType
:
this
.
controller
.
engagementEvent
.
typeFromElement
(
element
)
provider
:
result
.
providerName
}
)
;
if
(
result
.
payload
.
sendAttributionRequest
)
{
PartnerLinkAttribution
.
makeRequest
(
{
targetURL
:
result
.
payload
.
url
source
:
"
urlbar
"
campaignID
:
Services
.
prefs
.
getStringPref
(
"
browser
.
partnerlink
.
campaign
.
topsites
"
)
}
)
;
if
(
!
this
.
isPrivate
&
&
result
.
providerName
=
=
=
"
UrlbarProviderTopSites
"
)
{
const
position
=
selIndex
+
1
;
Services
.
telemetry
.
keyedScalarAdd
(
SCALAR_CATEGORY_TOPSITES
urlbar_
{
position
}
1
)
;
PartnerLinkAttribution
.
sendContextualServicesPing
(
{
position
source
:
"
urlbar
"
tile_id
:
result
.
payload
.
sponsoredTileId
|
|
-
1
reporting_url
:
result
.
payload
.
sponsoredClickUrl
advertiser
:
result
.
payload
.
title
.
toLocaleLowerCase
(
)
}
CONTEXTUAL_SERVICES_PING_TYPES
.
TOPSITES_SELECTION
)
;
}
}
this
.
_loadURL
(
url
event
where
openParams
{
source
:
result
.
source
type
:
result
.
type
}
browser
)
;
}
setValueFromResult
(
{
result
=
null
event
=
null
urlOverride
=
null
}
=
{
}
)
{
this
.
setPageProxyState
(
"
invalid
"
true
)
;
if
(
this
.
searchMode
?
.
isPreview
&
&
!
result
?
.
payload
.
providesSearchMode
&
&
!
this
.
view
.
oneOffSearchButtons
.
selectedButton
)
{
this
.
searchMode
=
null
;
}
if
(
!
result
)
{
this
.
value
=
this
.
_lastSearchString
|
|
this
.
_valueOnLastSearch
;
this
.
setResultForCurrentValue
(
result
)
;
return
false
;
}
const
setValueAndRestoreActionType
=
(
value
allowTrim
)
=
>
{
this
.
_setValue
(
value
allowTrim
)
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
this
.
setAttribute
(
"
actiontype
"
"
switchtab
"
)
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
this
.
setAttribute
(
"
actiontype
"
"
extension
"
)
;
break
;
}
}
;
let
canonizedUrl
=
this
.
_maybeCanonizeURL
(
event
result
.
autofill
?
this
.
_lastSearchString
:
this
.
value
)
;
if
(
canonizedUrl
)
{
setValueAndRestoreActionType
(
canonizedUrl
true
)
;
this
.
setResultForCurrentValue
(
result
)
;
return
true
;
}
if
(
result
.
autofill
)
{
let
{
value
selectionStart
selectionEnd
}
=
result
.
autofill
;
this
.
_autofillValue
(
value
selectionStart
selectionEnd
)
;
}
if
(
result
.
payload
.
providesSearchMode
)
{
let
enteredSearchMode
;
if
(
this
.
view
.
resultIsSelected
(
result
)
)
{
enteredSearchMode
=
this
.
maybeConfirmSearchModeFromResult
(
{
result
checkValue
:
false
startQuery
:
false
}
)
;
}
if
(
!
enteredSearchMode
)
{
setValueAndRestoreActionType
(
this
.
_getValueFromResult
(
result
)
true
)
;
this
.
searchMode
=
null
;
}
this
.
setResultForCurrentValue
(
result
)
;
return
false
;
}
let
allowTrim
=
true
;
if
(
(
urlOverride
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
)
&
&
UrlbarPrefs
.
get
(
"
trimURLs
"
)
)
{
let
url
=
urlOverride
|
|
result
.
payload
.
url
;
if
(
url
.
startsWith
(
BrowserUIUtils
.
trimURLProtocol
)
)
{
let
fixupInfo
=
this
.
_getURIFixupInfo
(
BrowserUIUtils
.
trimURL
(
url
)
)
;
if
(
fixupInfo
?
.
keywordAsSent
)
{
allowTrim
=
false
;
}
}
}
if
(
!
result
.
autofill
)
{
setValueAndRestoreActionType
(
this
.
_getValueFromResult
(
result
urlOverride
)
allowTrim
)
;
}
this
.
setResultForCurrentValue
(
result
)
;
return
false
;
}
setResultForCurrentValue
(
result
)
{
this
.
_resultForCurrentValue
=
result
;
}
_autofillFirstResult
(
result
)
{
if
(
!
result
.
autofill
)
{
return
;
}
let
isPlaceholderSelected
=
this
.
selectionEnd
=
=
this
.
_autofillPlaceholder
.
length
&
&
this
.
selectionStart
=
=
this
.
_lastSearchString
.
length
&
&
this
.
_autofillPlaceholder
.
toLocaleLowerCase
(
)
.
startsWith
(
this
.
_lastSearchString
.
toLocaleLowerCase
(
)
)
;
if
(
!
isPlaceholderSelected
&
&
!
this
.
_autofillIgnoresSelection
&
&
(
this
.
selectionStart
!
=
this
.
selectionEnd
|
|
this
.
selectionEnd
!
=
this
.
_lastSearchString
.
length
)
)
{
return
;
}
this
.
setValueFromResult
(
{
result
}
)
;
}
onFirstResult
(
firstResult
)
{
if
(
firstResult
.
heuristic
&
&
firstResult
.
payload
.
keyword
&
&
!
firstResult
.
payload
.
providesSearchMode
&
&
this
.
maybeConfirmSearchModeFromResult
(
{
result
:
firstResult
entry
:
"
typed
"
checkValue
:
false
}
)
)
{
return
true
;
}
if
(
firstResult
.
autofill
)
{
this
.
_autofillFirstResult
(
firstResult
)
;
}
else
if
(
this
.
_autofillPlaceholder
&
&
!
this
.
value
.
endsWith
(
"
"
)
)
{
this
.
_setValue
(
this
.
window
.
gBrowser
.
userTypedValue
false
)
;
}
return
false
;
}
startQuery
(
{
allowAutofill
=
true
autofillIgnoresSelection
=
false
searchString
=
null
resetSearchState
=
true
event
=
null
}
=
{
}
)
{
if
(
!
searchString
)
{
searchString
=
this
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
valid
"
?
"
"
:
this
.
value
;
}
else
if
(
!
this
.
value
.
startsWith
(
searchString
)
)
{
throw
new
Error
(
"
The
current
value
doesn
'
t
start
with
the
search
string
"
)
;
}
if
(
event
)
{
this
.
controller
.
engagementEvent
.
start
(
event
searchString
)
;
}
if
(
this
.
_suppressStartQuery
)
{
return
;
}
this
.
_autofillIgnoresSelection
=
autofillIgnoresSelection
;
if
(
resetSearchState
)
{
this
.
_resetSearchState
(
)
;
}
this
.
_lastSearchString
=
searchString
;
this
.
_valueOnLastSearch
=
this
.
value
;
let
options
=
{
allowAutofill
isPrivate
:
this
.
isPrivate
maxResults
:
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
searchString
userContextId
:
this
.
window
.
gBrowser
.
selectedBrowser
.
getAttribute
(
"
usercontextid
"
)
currentPage
:
this
.
window
.
gBrowser
.
currentURI
.
spec
formHistoryName
:
this
.
formHistoryName
prohibitRemoteResults
:
event
&
&
UrlbarUtils
.
isPasteEvent
(
event
)
&
&
UrlbarPrefs
.
get
(
"
maxCharsForSearchSuggestions
"
)
<
event
.
data
?
.
length
}
;
if
(
this
.
searchMode
)
{
this
.
confirmSearchMode
(
)
;
options
.
searchMode
=
this
.
searchMode
;
if
(
this
.
searchMode
.
source
)
{
options
.
sources
=
[
this
.
searchMode
.
source
]
;
}
}
this
.
lastQueryContextPromise
=
this
.
controller
.
startQuery
(
new
UrlbarQueryContext
(
options
)
)
;
}
search
(
value
{
searchEngine
searchModeEntry
focus
=
true
}
=
{
}
)
{
if
(
focus
)
{
this
.
focus
(
)
;
}
let
trimmedValue
=
value
.
trim
(
)
;
let
end
=
trimmedValue
.
search
(
UrlbarTokenizer
.
REGEXP_SPACES
)
;
let
firstToken
=
end
=
=
-
1
?
trimmedValue
:
trimmedValue
.
substring
(
0
end
)
;
let
searchMode
=
UrlbarUtils
.
searchModeForToken
(
firstToken
)
;
let
firstTokenIsRestriction
=
!
!
searchMode
;
if
(
!
searchMode
&
&
searchEngine
)
{
searchMode
=
{
engineName
:
searchEngine
.
name
}
;
firstTokenIsRestriction
=
searchEngine
.
aliases
.
includes
(
firstToken
)
;
}
if
(
searchMode
)
{
searchMode
.
entry
=
searchModeEntry
;
this
.
searchMode
=
searchMode
;
if
(
firstTokenIsRestriction
)
{
value
=
value
.
replace
(
firstToken
"
"
)
;
}
if
(
UrlbarTokenizer
.
REGEXP_SPACES
.
test
(
value
[
0
]
)
)
{
value
=
value
.
slice
(
1
)
;
}
this
.
_revertOnBlurValue
=
value
;
}
else
if
(
Object
.
values
(
UrlbarTokenizer
.
RESTRICT
)
.
includes
(
firstToken
)
)
{
this
.
searchMode
=
null
;
if
(
Object
.
values
(
UrlbarTokenizer
.
RESTRICT
)
.
includes
(
value
)
)
{
value
+
=
"
"
;
}
this
.
_revertOnBlurValue
=
value
;
}
this
.
inputField
.
value
=
value
;
this
.
selectionStart
=
-
1
;
this
.
_lastSearchString
=
"
"
;
let
event
=
new
UIEvent
(
"
input
"
{
bubbles
:
true
cancelable
:
false
view
:
this
.
window
detail
:
0
}
)
;
this
.
inputField
.
dispatchEvent
(
event
)
;
}
setHiddenFocus
(
)
{
this
.
_hideFocus
=
true
;
if
(
this
.
focused
)
{
this
.
removeAttribute
(
"
focused
"
)
;
}
else
{
this
.
focus
(
)
;
}
}
removeHiddenFocus
(
forceSuppressFocusBorder
=
false
)
{
this
.
_hideFocus
=
false
;
if
(
this
.
focused
)
{
this
.
setAttribute
(
"
focused
"
"
true
"
)
;
if
(
forceSuppressFocusBorder
)
{
this
.
toggleAttribute
(
"
suppress
-
focus
-
border
"
true
)
;
}
}
}
getSearchMode
(
browser
confirmedOnly
=
false
)
{
let
modes
=
this
.
_searchModesByBrowser
.
get
(
browser
)
;
if
(
!
confirmedOnly
&
&
modes
?
.
preview
)
{
return
{
.
.
.
modes
.
preview
}
;
}
if
(
modes
?
.
confirmed
)
{
return
{
.
.
.
modes
.
confirmed
}
;
}
return
null
;
}
async
setSearchMode
(
searchMode
browser
)
{
let
currentSearchMode
=
this
.
getSearchMode
(
browser
)
;
let
areSearchModesSame
=
(
!
currentSearchMode
&
&
!
searchMode
)
|
|
ObjectUtils
.
deepEqual
(
currentSearchMode
searchMode
)
;
let
engine
;
if
(
searchMode
?
.
engineName
)
{
if
(
!
Services
.
search
.
isInitialized
)
{
await
Services
.
search
.
init
(
)
;
}
engine
=
Services
.
search
.
getEngineByName
(
searchMode
.
engineName
)
;
if
(
!
engine
|
|
engine
.
hidden
)
{
searchMode
=
null
;
}
}
let
{
engineName
source
entry
isPreview
=
true
}
=
searchMode
|
|
{
}
;
searchMode
=
null
;
if
(
engineName
)
{
searchMode
=
{
engineName
isGeneralPurposeEngine
:
engine
.
isGeneralPurposeEngine
}
;
if
(
source
)
{
searchMode
.
source
=
source
;
}
else
if
(
searchMode
.
isGeneralPurposeEngine
)
{
searchMode
.
source
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
;
}
}
else
if
(
source
)
{
let
sourceName
=
UrlbarUtils
.
getResultSourceName
(
source
)
;
if
(
sourceName
)
{
searchMode
=
{
source
}
;
}
else
{
Cu
.
reportError
(
Unrecognized
source
:
{
source
}
)
;
}
}
if
(
searchMode
)
{
searchMode
.
isPreview
=
isPreview
;
if
(
UrlbarUtils
.
SEARCH_MODE_ENTRY
.
has
(
entry
)
)
{
searchMode
.
entry
=
entry
;
}
else
{
searchMode
.
entry
=
"
other
"
;
}
if
(
!
searchMode
.
isPreview
)
{
this
.
_searchModesByBrowser
.
set
(
browser
{
confirmed
:
searchMode
}
)
;
}
else
{
let
modes
=
this
.
_searchModesByBrowser
.
get
(
browser
)
|
|
{
}
;
modes
.
preview
=
searchMode
;
this
.
_searchModesByBrowser
.
set
(
browser
modes
)
;
}
}
else
{
this
.
_searchModesByBrowser
.
delete
(
browser
)
;
}
if
(
browser
=
=
this
.
window
.
gBrowser
.
selectedBrowser
)
{
this
.
_updateSearchModeUI
(
searchMode
)
;
if
(
searchMode
)
{
this
.
window
.
gBrowser
.
userTypedValue
=
this
.
untrimmedValue
;
this
.
valueIsTyped
=
true
;
if
(
!
searchMode
.
isPreview
&
&
!
areSearchModesSame
)
{
try
{
BrowserSearchTelemetry
.
recordSearchMode
(
searchMode
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
}
}
restoreSearchModeState
(
)
{
let
modes
=
this
.
_searchModesByBrowser
.
get
(
this
.
window
.
gBrowser
.
selectedBrowser
)
;
this
.
searchMode
=
modes
?
.
confirmed
;
}
searchModeShortcut
(
)
{
this
.
searchMode
=
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
engineName
:
UrlbarSearchUtils
.
getDefaultEngine
(
this
.
isPrivate
)
.
name
entry
:
"
shortcut
"
}
;
this
.
search
(
this
.
value
)
;
this
.
select
(
)
;
}
confirmSearchMode
(
)
{
let
searchMode
=
this
.
searchMode
;
if
(
searchMode
?
.
isPreview
)
{
searchMode
.
isPreview
=
false
;
this
.
searchMode
=
searchMode
;
this
.
view
.
oneOffSearchButtons
.
selectedButton
=
null
;
}
}
get
editor
(
)
{
return
this
.
inputField
.
editor
;
}
get
focused
(
)
{
return
this
.
document
.
activeElement
=
=
this
.
inputField
;
}
get
goButton
(
)
{
return
this
.
querySelector
(
"
#
urlbar
-
go
-
button
"
)
;
}
get
value
(
)
{
return
this
.
inputField
.
value
;
}
get
untrimmedValue
(
)
{
return
this
.
_untrimmedValue
;
}
set
value
(
val
)
{
this
.
_setValue
(
val
true
)
;
}
get
lastSearchString
(
)
{
return
this
.
_lastSearchString
;
}
get
searchMode
(
)
{
return
this
.
getSearchMode
(
this
.
window
.
gBrowser
.
selectedBrowser
)
;
}
set
searchMode
(
searchMode
)
{
this
.
setSearchMode
(
searchMode
this
.
window
.
gBrowser
.
selectedBrowser
)
;
}
async
updateLayoutBreakout
(
)
{
if
(
!
this
.
_toolbar
)
{
return
;
}
if
(
this
.
document
.
fullscreenElement
)
{
this
.
window
.
addEventListener
(
"
fullscreen
"
(
)
=
>
{
this
.
updateLayoutBreakout
(
)
;
}
{
once
:
true
}
)
;
return
;
}
await
this
.
_updateLayoutBreakoutDimensions
(
)
;
}
startLayoutExtend
(
)
{
if
(
!
this
.
hasAttribute
(
"
breakout
"
)
|
|
this
.
hasAttribute
(
"
breakout
-
extend
"
)
)
{
return
;
}
if
(
!
this
.
view
.
isOpen
)
{
return
;
}
if
(
Cu
.
isInAutomation
)
{
if
(
UrlbarPrefs
.
get
(
"
disableExtendForTests
"
)
)
{
this
.
setAttribute
(
"
breakout
-
extend
-
disabled
"
"
true
"
)
;
return
;
}
this
.
removeAttribute
(
"
breakout
-
extend
-
disabled
"
)
;
}
this
.
_toolbar
.
setAttribute
(
"
urlbar
-
exceeds
-
toolbar
-
bounds
"
"
true
"
)
;
this
.
setAttribute
(
"
breakout
-
extend
"
"
true
"
)
;
if
(
!
this
.
hasAttribute
(
"
breakout
-
extend
-
animate
"
)
)
{
this
.
window
.
promiseDocumentFlushed
(
(
)
=
>
{
this
.
window
.
requestAnimationFrame
(
(
)
=
>
{
this
.
setAttribute
(
"
breakout
-
extend
-
animate
"
"
true
"
)
;
}
)
;
}
)
;
}
}
endLayoutExtend
(
)
{
if
(
!
this
.
hasAttribute
(
"
breakout
-
extend
"
)
|
|
this
.
view
.
isOpen
)
{
return
;
}
this
.
removeAttribute
(
"
breakout
-
extend
"
)
;
this
.
_toolbar
.
removeAttribute
(
"
urlbar
-
exceeds
-
toolbar
-
bounds
"
)
;
}
setPageProxyState
(
state
updatePopupNotifications
)
{
let
prevState
=
this
.
getAttribute
(
"
pageproxystate
"
)
;
this
.
setAttribute
(
"
pageproxystate
"
state
)
;
this
.
_inputContainer
.
setAttribute
(
"
pageproxystate
"
state
)
;
this
.
_identityBox
.
setAttribute
(
"
pageproxystate
"
state
)
;
if
(
state
=
=
"
valid
"
)
{
this
.
_lastValidURLStr
=
this
.
value
;
}
if
(
updatePopupNotifications
&
&
prevState
!
=
state
&
&
this
.
window
.
UpdatePopupNotificationsVisibility
)
{
this
.
window
.
UpdatePopupNotificationsVisibility
(
)
;
}
}
afterTabSwitchFocusChange
(
)
{
this
.
_gotFocusChange
=
true
;
this
.
_afterTabSelectAndFocusChange
(
)
;
}
maybeConfirmSearchModeFromResult
(
{
entry
result
=
this
.
_resultForCurrentValue
checkValue
=
true
startQuery
=
true
}
)
{
if
(
!
result
|
|
(
checkValue
&
&
this
.
value
.
trim
(
)
!
=
result
.
payload
.
keyword
?
.
trim
(
)
)
)
{
return
false
;
}
let
searchMode
=
this
.
_searchModeForResult
(
result
entry
)
;
if
(
!
searchMode
)
{
return
false
;
}
this
.
searchMode
=
searchMode
;
let
value
=
result
.
payload
.
query
?
.
trimStart
(
)
|
|
"
"
;
this
.
_setValue
(
value
false
)
;
if
(
startQuery
)
{
this
.
startQuery
(
{
allowAutofill
:
false
}
)
;
}
return
true
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
SearchUtils
.
TOPIC_ENGINE_MODIFIED
:
{
switch
(
data
)
{
case
SearchUtils
.
MODIFIED_TYPE
.
CHANGED
:
case
SearchUtils
.
MODIFIED_TYPE
.
REMOVED
:
{
let
searchMode
=
this
.
searchMode
;
let
engine
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
if
(
searchMode
?
.
engineName
=
=
engine
.
name
)
{
this
.
searchMode
=
searchMode
;
}
break
;
}
}
break
;
}
}
}
_addObservers
(
)
{
Services
.
obs
.
addObserver
(
this
SearchUtils
.
TOPIC_ENGINE_MODIFIED
true
)
;
}
_getURIFixupInfo
(
searchString
)
{
let
flags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
|
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
if
(
this
.
isPrivate
)
{
flags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
try
{
return
Services
.
uriFixup
.
getFixupURIInfo
(
searchString
flags
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
An
error
occured
while
trying
to
fixup
"
{
searchString
}
"
:
{
ex
}
)
;
}
return
null
;
}
_afterTabSelectAndFocusChange
(
)
{
if
(
!
this
.
_gotFocusChange
|
|
!
this
.
_gotTabSelect
)
{
return
;
}
this
.
_gotFocusChange
=
this
.
_gotTabSelect
=
false
;
this
.
_resetSearchState
(
)
;
if
(
this
.
view
.
autoOpen
(
{
event
:
new
CustomEvent
(
"
tabswitch
"
)
}
)
)
{
return
;
}
this
.
view
.
close
(
)
;
}
async
_updateLayoutBreakoutDimensions
(
)
{
let
updateKey
=
{
}
;
this
.
_layoutBreakoutUpdateKey
=
updateKey
;
this
.
removeAttribute
(
"
breakout
"
)
;
this
.
textbox
.
parentNode
.
removeAttribute
(
"
breakout
"
)
;
await
this
.
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
await
new
Promise
(
resolve
=
>
{
this
.
window
.
requestAnimationFrame
(
(
)
=
>
{
if
(
this
.
_layoutBreakoutUpdateKey
!
=
updateKey
)
{
return
;
}
this
.
textbox
.
parentNode
.
style
.
setProperty
(
"
-
-
urlbar
-
container
-
height
"
px
(
getBoundsWithoutFlushing
(
this
.
textbox
.
parentNode
)
.
height
)
)
;
this
.
textbox
.
style
.
setProperty
(
"
-
-
urlbar
-
height
"
px
(
getBoundsWithoutFlushing
(
this
.
textbox
)
.
height
)
)
;
this
.
textbox
.
style
.
setProperty
(
"
-
-
urlbar
-
toolbar
-
height
"
px
(
getBoundsWithoutFlushing
(
this
.
_toolbar
)
.
height
)
)
;
this
.
setAttribute
(
"
breakout
"
"
true
"
)
;
this
.
textbox
.
parentNode
.
setAttribute
(
"
breakout
"
"
true
"
)
;
resolve
(
)
;
}
)
;
}
)
;
}
_setValue
(
val
allowTrim
)
{
let
originalUrl
=
ReaderMode
.
getOriginalUrlObjectForDisplay
(
val
)
;
if
(
originalUrl
)
{
val
=
originalUrl
.
displaySpec
;
}
this
.
_untrimmedValue
=
val
;
if
(
allowTrim
)
{
val
=
this
.
_trimValue
(
val
)
;
}
this
.
valueIsTyped
=
false
;
this
.
_resultForCurrentValue
=
null
;
this
.
inputField
.
value
=
val
;
this
.
formatValue
(
)
;
this
.
removeAttribute
(
"
actiontype
"
)
;
let
event
=
this
.
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
ValueChange
"
true
true
)
;
this
.
inputField
.
dispatchEvent
(
event
)
;
return
val
;
}
_getValueFromResult
(
result
urlOverride
=
null
)
{
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
return
result
.
payload
.
input
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
{
let
value
=
"
"
;
if
(
result
.
payload
.
keyword
)
{
value
+
=
result
.
payload
.
keyword
+
"
"
;
}
value
+
=
result
.
payload
.
suggestion
|
|
result
.
payload
.
query
;
return
value
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
result
.
payload
.
content
;
case
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
:
return
result
.
payload
.
input
|
|
"
"
;
}
if
(
urlOverride
=
=
=
"
"
)
{
return
"
"
;
}
try
{
let
uri
=
Services
.
io
.
newURI
(
urlOverride
|
|
result
.
payload
.
url
)
;
if
(
uri
)
{
return
losslessDecodeURI
(
uri
)
;
}
}
catch
(
ex
)
{
}
return
"
"
;
}
_resetSearchState
(
)
{
this
.
_lastSearchString
=
this
.
value
;
this
.
_autofillPlaceholder
=
"
"
;
}
_maybeAutofillOnInput
(
value
)
{
let
allowAutofill
=
this
.
selectionEnd
=
=
value
.
length
&
&
!
this
.
searchMode
?
.
engineName
&
&
this
.
searchMode
?
.
source
!
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
;
if
(
!
allowAutofill
|
|
!
UrlbarUtils
.
canAutofillURL
(
this
.
_autofillPlaceholder
value
)
)
{
this
.
_autofillPlaceholder
=
"
"
;
}
else
if
(
this
.
_autofillPlaceholder
&
&
this
.
selectionEnd
=
=
this
.
value
.
length
&
&
this
.
_enableAutofillPlaceholder
)
{
let
autofillValue
=
value
+
this
.
_autofillPlaceholder
.
substring
(
value
.
length
)
;
this
.
_autofillValue
(
autofillValue
value
.
length
autofillValue
.
length
)
;
}
return
allowAutofill
;
}
_checkForRtlText
(
value
)
{
let
directionality
=
this
.
window
.
windowUtils
.
getDirectionFromText
(
value
)
;
if
(
directionality
=
=
this
.
window
.
windowUtils
.
DIRECTION_RTL
)
{
return
true
;
}
return
false
;
}
_updateTextOverflow
(
)
{
if
(
!
this
.
_overflowing
)
{
this
.
removeAttribute
(
"
textoverflow
"
)
;
return
;
}
let
isRTL
=
this
.
getAttribute
(
"
domaindir
"
)
!
=
"
ltr
"
&
&
this
.
_checkForRtlText
(
this
.
value
)
;
this
.
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
input
=
this
.
inputField
;
if
(
input
&
&
this
.
_overflowing
)
{
let
side
=
"
both
"
;
if
(
isRTL
)
{
if
(
input
.
scrollLeft
=
=
0
)
{
side
=
"
left
"
;
}
else
if
(
input
.
scrollLeft
=
=
input
.
scrollLeftMin
)
{
side
=
"
right
"
;
}
}
else
if
(
input
.
scrollLeft
=
=
0
)
{
side
=
"
right
"
;
}
else
if
(
input
.
scrollLeft
=
=
input
.
scrollLeftMax
)
{
side
=
"
left
"
;
}
this
.
window
.
requestAnimationFrame
(
(
)
=
>
{
if
(
this
.
_overflowing
)
{
this
.
setAttribute
(
"
textoverflow
"
side
)
;
}
}
)
;
}
}
)
;
}
_updateUrlTooltip
(
)
{
if
(
this
.
focused
|
|
!
this
.
_overflowing
)
{
this
.
inputField
.
removeAttribute
(
"
title
"
)
;
}
else
{
this
.
inputField
.
setAttribute
(
"
title
"
this
.
untrimmedValue
)
;
}
}
_getSelectedValueForClipboard
(
)
{
let
selection
=
this
.
editor
.
selection
;
const
flags
=
Ci
.
nsIDocumentEncoder
.
OutputPreformatted
|
Ci
.
nsIDocumentEncoder
.
OutputRaw
;
let
selectedVal
=
selection
.
toStringWithFormat
(
"
text
/
plain
"
flags
0
)
;
if
(
selection
.
rangeCount
>
1
)
{
return
selectedVal
;
}
if
(
this
.
selectionStart
>
0
|
|
this
.
valueIsTyped
|
|
selectedVal
=
=
"
"
)
{
return
selectedVal
;
}
if
(
!
selectedVal
.
includes
(
"
/
"
)
)
{
let
remainder
=
this
.
value
.
replace
(
selectedVal
"
"
)
;
if
(
remainder
!
=
"
"
&
&
remainder
[
0
]
!
=
"
/
"
)
{
return
selectedVal
;
}
}
let
uri
;
if
(
this
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
valid
"
)
{
uri
=
this
.
window
.
gBrowser
.
currentURI
;
}
else
{
try
{
uri
=
Services
.
io
.
newURI
(
this
.
_untrimmedValue
)
;
}
catch
(
ex
)
{
return
selectedVal
;
}
}
uri
=
this
.
makeURIReadable
(
uri
)
;
let
displaySpec
=
uri
.
displaySpec
;
if
(
this
.
value
=
=
selectedVal
&
&
!
uri
.
schemeIs
(
"
javascript
"
)
&
&
!
uri
.
schemeIs
(
"
data
"
)
&
&
!
UrlbarPrefs
.
get
(
"
decodeURLsOnCopy
"
)
)
{
return
displaySpec
;
}
if
(
!
selectedVal
.
startsWith
(
BrowserUIUtils
.
trimURLProtocol
)
&
&
!
displaySpec
.
startsWith
(
this
.
_trimValue
(
displaySpec
)
)
)
{
selectedVal
=
BrowserUIUtils
.
trimURLProtocol
+
selectedVal
;
}
if
(
!
UrlbarPrefs
.
get
(
"
decodeURLsOnCopy
"
)
&
&
!
uri
.
schemeIs
(
"
data
"
)
)
{
try
{
new
URL
(
selectedVal
)
;
selectedVal
=
encodeURI
(
selectedVal
)
;
}
catch
(
ex
)
{
}
}
return
selectedVal
;
}
_toggleActionOverride
(
event
)
{
if
(
event
.
repeat
)
{
return
;
}
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_SHIFT
|
|
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_ALT
|
|
event
.
keyCode
=
=
(
AppConstants
.
platform
=
=
"
macosx
"
?
KeyEvent
.
DOM_VK_META
:
KeyEvent
.
DOM_VK_CONTROL
)
)
{
if
(
event
.
type
=
=
"
keydown
"
)
{
this
.
_actionOverrideKeyCount
+
+
;
this
.
setAttribute
(
"
actionoverride
"
"
true
"
)
;
this
.
view
.
panel
.
setAttribute
(
"
actionoverride
"
"
true
"
)
;
}
else
if
(
this
.
_actionOverrideKeyCount
&
&
-
-
this
.
_actionOverrideKeyCount
=
=
0
)
{
this
.
_clearActionOverride
(
)
;
}
}
}
_clearActionOverride
(
)
{
this
.
_actionOverrideKeyCount
=
0
;
this
.
removeAttribute
(
"
actionoverride
"
)
;
this
.
view
.
panel
.
removeAttribute
(
"
actionoverride
"
)
;
}
_recordSearch
(
engine
event
searchActionDetails
=
{
}
)
{
const
isOneOff
=
this
.
view
.
oneOffSearchButtons
.
eventTargetIsAOneOff
(
event
)
;
let
source
=
"
urlbar
"
;
if
(
this
.
_isHandoffSession
)
{
source
=
"
urlbar
-
handoff
"
;
}
else
if
(
this
.
searchMode
&
&
!
isOneOff
)
{
source
=
"
urlbar
-
searchmode
"
;
}
BrowserSearchTelemetry
.
recordSearch
(
this
.
window
.
gBrowser
.
selectedBrowser
engine
source
{
.
.
.
searchActionDetails
isOneOff
}
)
;
}
_trimValue
(
val
)
{
return
UrlbarPrefs
.
get
(
"
trimURLs
"
)
?
BrowserUIUtils
.
trimURL
(
val
)
:
val
;
}
_maybeCanonizeURL
(
event
value
)
{
if
(
!
(
event
instanceof
KeyboardEvent
)
|
|
event
.
_disableCanonization
|
|
!
event
.
ctrlKey
|
|
!
UrlbarPrefs
.
get
(
"
ctrlCanonizesURLs
"
)
|
|
!
/
^
\
s
*
[
^
.
:
\
/
\
s
]
+
(
?
:
\
/
.
*
|
\
s
*
)
/
i
.
test
(
value
)
)
{
return
null
;
}
let
suffix
=
Services
.
prefs
.
getCharPref
(
"
browser
.
fixup
.
alternate
.
suffix
"
)
;
if
(
!
suffix
.
endsWith
(
"
/
"
)
)
{
suffix
+
=
"
/
"
;
}
value
=
value
.
trim
(
)
;
let
firstSlash
=
value
.
indexOf
(
"
/
"
)
;
if
(
firstSlash
>
=
0
)
{
value
=
value
.
substring
(
0
firstSlash
)
+
suffix
+
value
.
substring
(
firstSlash
+
1
)
;
}
else
{
value
=
value
+
suffix
;
}
try
{
const
info
=
Services
.
uriFixup
.
getFixupURIInfo
(
value
Ci
.
nsIURIFixup
.
FIXUP_FLAGS_MAKE_ALTERNATE_URI
)
;
value
=
info
.
fixedURI
.
spec
;
}
catch
(
ex
)
{
Cu
.
reportError
(
An
error
occured
while
trying
to
fixup
"
{
value
}
"
:
{
ex
}
)
;
}
this
.
value
=
value
;
return
value
;
}
_autofillValue
(
value
selectionStart
selectionEnd
)
{
this
.
_setValue
(
value
false
)
;
this
.
selectionStart
=
selectionStart
;
this
.
selectionEnd
=
selectionEnd
;
this
.
_autofillPlaceholder
=
value
;
}
_loadURL
(
url
event
openUILinkWhere
params
resultDetails
=
null
browser
=
this
.
window
.
gBrowser
.
selectedBrowser
)
{
if
(
openUILinkWhere
=
=
"
current
"
)
{
this
.
value
=
url
;
browser
.
userTypedValue
=
url
;
}
if
(
openUILinkWhere
!
=
"
window
"
&
&
this
.
window
.
gInitialPages
.
includes
(
url
)
)
{
browser
.
initialPageLoadedFromUserAction
=
url
;
}
try
{
UrlbarUtils
.
addToUrlbarHistory
(
url
this
.
window
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
if
(
!
params
.
triggeringPrincipal
|
|
params
.
triggeringPrincipal
.
isSystemPrincipal
)
{
delete
browser
.
authPromptAbuseCounter
;
if
(
openUILinkWhere
=
=
"
current
"
&
&
browser
.
currentURI
&
&
url
=
=
=
browser
.
currentURI
.
spec
)
{
this
.
window
.
SitePermissions
.
clearTemporaryBlockPermissions
(
browser
)
;
}
}
params
.
allowThirdPartyFixup
=
true
;
if
(
openUILinkWhere
=
=
"
current
"
)
{
params
.
targetBrowser
=
browser
;
params
.
indicateErrorPageLoad
=
true
;
params
.
allowPinnedTabHostChange
=
true
;
params
.
allowPopups
=
url
.
startsWith
(
"
javascript
:
"
)
;
}
else
{
params
.
initiatingDoc
=
this
.
window
.
document
;
}
if
(
this
.
_keyDownEnterDeferred
&
&
event
?
.
keyCode
=
=
=
KeyEvent
.
DOM_VK_RETURN
&
&
openUILinkWhere
=
=
=
"
current
"
)
{
params
.
avoidBrowserFocus
=
true
;
this
.
_keyDownEnterDeferred
.
loadedContent
=
true
;
this
.
_keyDownEnterDeferred
.
resolve
(
browser
)
;
}
if
(
!
params
.
avoidBrowserFocus
)
{
browser
.
focus
(
)
;
this
.
selectionStart
=
this
.
selectionEnd
=
0
;
}
if
(
openUILinkWhere
!
=
"
current
"
)
{
this
.
handleRevert
(
)
;
}
this
.
_notifyStartNavigation
(
resultDetails
)
;
try
{
this
.
window
.
openTrustedLinkIn
(
url
openUILinkWhere
params
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_LOAD_SHOWED_ERRORPAGE
)
{
this
.
handleRevert
(
)
;
}
}
this
.
view
.
close
(
{
showFocusBorder
:
false
}
)
;
}
_whereToOpen
(
event
)
{
let
isKeyboardEvent
=
event
instanceof
KeyboardEvent
;
let
reuseEmpty
=
isKeyboardEvent
;
let
where
=
undefined
;
if
(
isKeyboardEvent
&
&
(
event
.
altKey
|
|
event
.
getModifierState
(
"
AltGraph
"
)
)
)
{
where
=
event
.
shiftKey
?
"
tabshifted
"
:
"
tab
"
;
}
else
if
(
isKeyboardEvent
&
&
event
.
ctrlKey
&
&
UrlbarPrefs
.
get
(
"
ctrlCanonizesURLs
"
)
)
{
where
=
"
current
"
;
}
else
{
where
=
this
.
window
.
whereToOpenLink
(
event
false
false
)
;
}
if
(
UrlbarPrefs
.
get
(
"
openintab
"
)
)
{
if
(
where
=
=
"
current
"
)
{
where
=
"
tab
"
;
}
else
if
(
where
=
=
"
tab
"
)
{
where
=
"
current
"
;
}
reuseEmpty
=
true
;
}
if
(
where
=
=
"
tab
"
&
&
reuseEmpty
&
&
this
.
window
.
gBrowser
.
selectedTab
.
isEmpty
)
{
where
=
"
current
"
;
}
return
where
;
}
_initCopyCutController
(
)
{
this
.
_copyCutController
=
new
CopyCutController
(
this
)
;
this
.
inputField
.
controllers
.
insertControllerAt
(
0
this
.
_copyCutController
)
;
}
_initPasteAndGo
(
)
{
let
inputBox
=
this
.
querySelector
(
"
moz
-
input
-
box
"
)
;
let
contextMenu
=
inputBox
.
menupopup
;
let
insertLocation
=
contextMenu
.
firstElementChild
;
while
(
insertLocation
.
nextElementSibling
&
&
insertLocation
.
getAttribute
(
"
cmd
"
)
!
=
"
cmd_paste
"
)
{
insertLocation
=
insertLocation
.
nextElementSibling
;
}
if
(
!
insertLocation
)
{
return
;
}
let
pasteAndGo
=
this
.
document
.
createXULElement
(
"
menuitem
"
)
;
pasteAndGo
.
id
=
"
paste
-
and
-
go
"
;
let
label
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
.
GetStringFromName
(
"
pasteAndGo
.
label
"
)
;
pasteAndGo
.
setAttribute
(
"
label
"
label
)
;
pasteAndGo
.
setAttribute
(
"
anonid
"
"
paste
-
and
-
go
"
)
;
pasteAndGo
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
_suppressStartQuery
=
true
;
this
.
select
(
)
;
this
.
window
.
goDoCommand
(
"
cmd_paste
"
)
;
this
.
setResultForCurrentValue
(
null
)
;
this
.
handleCommand
(
)
;
this
.
_suppressStartQuery
=
false
;
}
)
;
contextMenu
.
addEventListener
(
"
popupshowing
"
(
)
=
>
{
this
.
view
.
close
(
)
;
let
controller
=
this
.
document
.
commandDispatcher
.
getControllerForCommand
(
"
cmd_paste
"
)
;
let
enabled
=
controller
.
isCommandEnabled
(
"
cmd_paste
"
)
;
if
(
enabled
)
{
pasteAndGo
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
pasteAndGo
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
)
;
insertLocation
.
insertAdjacentElement
(
"
afterend
"
pasteAndGo
)
;
}
_notifyStartNavigation
(
result
)
{
Services
.
obs
.
notifyObservers
(
{
result
}
"
urlbar
-
user
-
start
-
navigation
"
)
;
}
_searchModeForResult
(
result
entry
=
null
)
{
if
(
!
result
.
payload
.
keyword
&
&
!
result
.
payload
.
engine
)
{
return
null
;
}
let
searchMode
=
UrlbarUtils
.
searchModeForToken
(
result
.
payload
.
keyword
)
;
if
(
!
searchMode
&
&
result
.
payload
.
engine
&
&
(
!
result
.
payload
.
originalEngine
|
|
result
.
payload
.
engine
=
=
result
.
payload
.
originalEngine
)
)
{
searchMode
=
{
engineName
:
result
.
payload
.
engine
}
;
}
if
(
searchMode
)
{
if
(
entry
)
{
searchMode
.
entry
=
entry
;
}
else
{
switch
(
result
.
providerName
)
{
case
"
UrlbarProviderTopSites
"
:
searchMode
.
entry
=
"
topsites_urlbar
"
;
break
;
case
"
TabToSearch
"
:
if
(
result
.
payload
.
dynamicType
)
{
searchMode
.
entry
=
"
tabtosearch_onboard
"
;
}
else
{
searchMode
.
entry
=
"
tabtosearch
"
;
}
break
;
default
:
searchMode
.
entry
=
"
keywordoffer
"
;
break
;
}
}
}
return
searchMode
;
}
_updateSearchModeUI
(
searchMode
)
{
let
{
engineName
source
isGeneralPurposeEngine
}
=
searchMode
|
|
{
}
;
if
(
!
engineName
&
&
!
source
&
&
!
this
.
hasAttribute
(
"
searchmode
"
)
)
{
return
;
}
this
.
_searchModeIndicatorTitle
.
textContent
=
"
"
;
this
.
_searchModeLabel
.
textContent
=
"
"
;
this
.
_searchModeIndicatorTitle
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
this
.
_searchModeLabel
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
if
(
!
engineName
&
&
!
source
)
{
try
{
this
.
window
.
BrowserSearch
.
initPlaceHolder
(
true
)
;
}
catch
(
ex
)
{
}
this
.
removeAttribute
(
"
searchmode
"
)
;
return
;
}
if
(
engineName
)
{
this
.
_searchModeIndicatorTitle
.
textContent
=
engineName
;
this
.
_searchModeLabel
.
textContent
=
engineName
;
this
.
document
.
l10n
.
setAttributes
(
this
.
inputField
isGeneralPurposeEngine
?
"
urlbar
-
placeholder
-
search
-
mode
-
web
-
2
"
:
"
urlbar
-
placeholder
-
search
-
mode
-
other
-
engine
"
{
name
:
engineName
}
)
;
}
else
if
(
source
)
{
let
sourceName
=
UrlbarUtils
.
getResultSourceName
(
source
)
;
let
l10nID
=
urlbar
-
search
-
mode
-
{
sourceName
}
;
this
.
document
.
l10n
.
setAttributes
(
this
.
_searchModeIndicatorTitle
l10nID
)
;
this
.
document
.
l10n
.
setAttributes
(
this
.
_searchModeLabel
l10nID
)
;
this
.
document
.
l10n
.
setAttributes
(
this
.
inputField
urlbar
-
placeholder
-
search
-
mode
-
other
-
{
sourceName
}
)
;
}
this
.
toggleAttribute
(
"
searchmode
"
true
)
;
if
(
this
.
_autofillPlaceholder
&
&
this
.
window
.
gBrowser
.
userTypedValue
)
{
this
.
value
=
this
.
window
.
gBrowser
.
userTypedValue
;
}
if
(
this
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
valid
"
)
{
this
.
value
=
"
"
;
this
.
setPageProxyState
(
"
invalid
"
true
)
;
}
}
_maybeSelectAll
(
)
{
if
(
!
this
.
_preventClickSelectsAll
&
&
this
.
_compositionState
!
=
UrlbarUtils
.
COMPOSITION
.
COMPOSING
&
&
this
.
document
.
activeElement
=
=
this
.
inputField
&
&
this
.
inputField
.
selectionStart
=
=
this
.
inputField
.
selectionEnd
)
{
this
.
select
(
)
;
}
}
_on_command
(
event
)
{
if
(
!
event
.
target
.
classList
.
contains
(
"
searchbar
-
engine
-
one
-
off
-
item
"
)
|
|
this
.
searchMode
?
.
entry
!
=
"
oneoff
"
)
{
this
.
controller
.
engagementEvent
.
discard
(
)
;
}
}
_on_blur
(
event
)
{
this
.
focusedViaMousedown
=
false
;
this
.
_isHandoffSession
=
false
;
this
.
controller
.
engagementEvent
.
record
(
event
{
searchString
:
this
.
_lastSearchString
}
)
;
this
.
removeAttribute
(
"
focused
"
)
;
if
(
this
.
_autofillPlaceholder
&
&
this
.
window
.
gBrowser
.
userTypedValue
)
{
this
.
value
=
this
.
window
.
gBrowser
.
userTypedValue
;
}
else
if
(
this
.
value
=
=
this
.
_focusUntrimmedValue
)
{
this
.
value
=
this
.
_focusUntrimmedValue
;
}
this
.
_focusUntrimmedValue
=
null
;
this
.
formatValue
(
)
;
this
.
_resetSearchState
(
)
;
this
.
_clearActionOverride
(
)
;
if
(
ExtensionSearchHandler
.
hasActiveInputSession
(
)
)
{
ExtensionSearchHandler
.
handleInputCancelled
(
)
;
}
if
(
!
UrlbarPrefs
.
get
(
"
ui
.
popup
.
disable_autohide
"
)
)
{
this
.
view
.
close
(
)
;
}
if
(
this
.
_revertOnBlurValue
=
=
this
.
value
)
{
this
.
handleRevert
(
)
;
}
this
.
_revertOnBlurValue
=
null
;
if
(
this
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
&
&
this
.
window
.
UpdatePopupNotificationsVisibility
)
{
this
.
window
.
UpdatePopupNotificationsVisibility
(
)
;
}
if
(
this
.
_keyDownEnterDeferred
)
{
this
.
_keyDownEnterDeferred
.
resolve
(
)
;
this
.
_keyDownEnterDeferred
=
null
;
}
this
.
_isKeyDownWithCtrl
=
false
;
Services
.
obs
.
notifyObservers
(
null
"
urlbar
-
blur
"
)
;
}
_on_click
(
event
)
{
if
(
event
.
target
=
=
this
.
inputField
|
|
event
.
target
=
=
this
.
_inputContainer
|
|
event
.
target
.
id
=
=
SEARCH_BUTTON_ID
)
{
this
.
_maybeSelectAll
(
)
;
}
if
(
event
.
target
=
=
this
.
_searchModeIndicatorClose
&
&
event
.
button
!
=
2
)
{
this
.
searchMode
=
null
;
this
.
view
.
oneOffSearchButtons
.
selectedButton
=
null
;
if
(
this
.
view
.
isOpen
)
{
this
.
startQuery
(
{
event
}
)
;
}
}
}
_on_contextmenu
(
event
)
{
this
.
addSearchEngineHelper
.
refreshContextMenu
(
event
)
;
if
(
!
event
.
button
)
{
return
;
}
this
.
_maybeSelectAll
(
)
;
}
_on_focus
(
event
)
{
if
(
!
this
.
_hideFocus
)
{
this
.
setAttribute
(
"
focused
"
"
true
"
)
;
}
if
(
this
.
value
!
=
this
.
_untrimmedValue
)
{
let
untrim
=
false
;
let
fixedURI
=
this
.
_getURIFixupInfo
(
this
.
value
)
?
.
preferredURI
;
if
(
fixedURI
)
{
try
{
let
expectedURI
=
Services
.
io
.
newURI
(
this
.
_untrimmedValue
)
;
untrim
=
fixedURI
.
displaySpec
!
=
expectedURI
.
displaySpec
;
}
catch
(
ex
)
{
untrim
=
true
;
}
}
if
(
untrim
)
{
this
.
inputField
.
value
=
this
.
_focusUntrimmedValue
=
this
.
_untrimmedValue
;
}
}
if
(
this
.
focusedViaMousedown
)
{
this
.
view
.
autoOpen
(
{
event
}
)
;
}
else
if
(
this
.
inputField
.
hasAttribute
(
"
refocused
-
by
-
panel
"
)
)
{
this
.
_maybeSelectAll
(
)
;
}
this
.
_updateUrlTooltip
(
)
;
this
.
formatValue
(
)
;
if
(
this
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
&
&
this
.
window
.
UpdatePopupNotificationsVisibility
)
{
this
.
window
.
UpdatePopupNotificationsVisibility
(
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
urlbar
-
focus
"
)
;
}
_on_mouseover
(
event
)
{
this
.
_updateUrlTooltip
(
)
;
}
_on_draggableregionleftmousedown
(
event
)
{
if
(
!
UrlbarPrefs
.
get
(
"
ui
.
popup
.
disable_autohide
"
)
)
{
this
.
view
.
close
(
)
;
}
}
_on_mousedown
(
event
)
{
switch
(
event
.
currentTarget
)
{
case
this
.
textbox
:
this
.
_mousedownOnUrlbarDescendant
=
true
;
if
(
event
.
target
!
=
this
.
inputField
&
&
event
.
target
!
=
this
.
_inputContainer
&
&
event
.
target
.
id
!
=
SEARCH_BUTTON_ID
)
{
break
;
}
this
.
focusedViaMousedown
=
!
this
.
focused
;
this
.
_preventClickSelectsAll
=
this
.
focused
;
const
hasFocus
=
this
.
hasAttribute
(
"
focused
"
)
;
if
(
event
.
target
!
=
this
.
inputField
)
{
this
.
focus
(
)
;
}
if
(
event
.
button
!
=
0
)
{
break
;
}
if
(
this
.
focusedViaMousedown
)
{
this
.
selectionStart
=
this
.
selectionEnd
=
0
;
}
if
(
event
.
target
.
id
=
=
SEARCH_BUTTON_ID
)
{
this
.
_preventClickSelectsAll
=
true
;
this
.
search
(
UrlbarTokenizer
.
RESTRICT
.
SEARCH
)
;
}
else
{
this
.
view
.
autoOpen
(
{
event
suppressFocusBorder
:
!
hasFocus
}
)
;
}
break
;
case
this
.
window
:
if
(
this
.
_mousedownOnUrlbarDescendant
)
{
this
.
_mousedownOnUrlbarDescendant
=
false
;
break
;
}
if
(
event
.
target
.
closest
(
"
tab
"
)
)
{
break
;
}
if
(
!
UrlbarPrefs
.
get
(
"
ui
.
popup
.
disable_autohide
"
)
)
{
this
.
view
.
close
(
)
;
}
break
;
}
}
_on_input
(
event
)
{
let
value
=
this
.
value
;
this
.
valueIsTyped
=
true
;
this
.
_untrimmedValue
=
value
;
this
.
_resultForCurrentValue
=
null
;
this
.
window
.
gBrowser
.
userTypedValue
=
value
;
this
.
controller
.
userSelectionBehavior
=
"
none
"
;
let
compositionState
=
this
.
_compositionState
;
let
compositionClosedPopup
=
this
.
_compositionClosedPopup
;
if
(
this
.
_compositionState
!
=
UrlbarUtils
.
COMPOSITION
.
COMPOSING
)
{
this
.
_compositionState
=
UrlbarUtils
.
COMPOSITION
.
NONE
;
this
.
_compositionClosedPopup
=
false
;
}
if
(
value
)
{
this
.
setAttribute
(
"
usertyping
"
"
true
"
)
;
}
else
{
this
.
removeAttribute
(
"
usertyping
"
)
;
}
this
.
removeAttribute
(
"
actiontype
"
)
;
if
(
this
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
valid
"
&
&
this
.
value
!
=
this
.
_lastValidURLStr
)
{
this
.
setPageProxyState
(
"
invalid
"
true
)
;
}
if
(
!
this
.
view
.
isOpen
)
{
this
.
view
.
clear
(
)
;
}
else
if
(
!
value
&
&
!
UrlbarPrefs
.
get
(
"
suggest
.
topsites
"
)
)
{
this
.
view
.
clear
(
)
;
if
(
!
this
.
searchMode
|
|
!
this
.
view
.
oneOffSearchButtons
.
hasView
)
{
this
.
view
.
close
(
)
;
return
;
}
}
this
.
view
.
removeAccessibleFocus
(
)
;
if
(
!
UrlbarPrefs
.
get
(
"
keepPanelOpenDuringImeComposition
"
)
&
&
(
compositionState
=
=
UrlbarUtils
.
COMPOSITION
.
COMPOSING
|
|
(
compositionState
=
=
UrlbarUtils
.
COMPOSITION
.
CANCELED
&
&
!
compositionClosedPopup
)
)
)
{
return
;
}
const
allowAutofill
=
(
!
UrlbarPrefs
.
get
(
"
keepPanelOpenDuringImeComposition
"
)
|
|
compositionState
!
=
=
UrlbarUtils
.
COMPOSITION
.
COMPOSING
)
&
&
!
!
event
.
data
&
&
!
UrlbarUtils
.
isPasteEvent
(
event
)
&
&
this
.
_maybeAutofillOnInput
(
value
)
;
this
.
startQuery
(
{
searchString
:
value
allowAutofill
resetSearchState
:
false
event
}
)
;
}
_on_select
(
event
)
{
if
(
this
.
_suppressPrimaryAdjustment
|
|
!
this
.
window
.
windowUtils
.
isHandlingUserInput
|
|
!
Services
.
clipboard
.
supportsSelectionClipboard
(
)
)
{
return
;
}
let
val
=
this
.
_getSelectedValueForClipboard
(
)
;
if
(
!
val
)
{
return
;
}
ClipboardHelper
.
copyStringToClipboard
(
val
Services
.
clipboard
.
kSelectionClipboard
)
;
}
_on_overflow
(
event
)
{
const
targetIsPlaceholder
=
event
.
originalTarget
.
implementedPseudoElement
=
=
"
:
:
placeholder
"
;
if
(
targetIsPlaceholder
)
{
return
;
}
this
.
_overflowing
=
true
;
this
.
_updateTextOverflow
(
)
;
}
_on_underflow
(
event
)
{
const
targetIsPlaceholder
=
event
.
originalTarget
.
implementedPseudoElement
=
=
"
:
:
placeholder
"
;
if
(
targetIsPlaceholder
)
{
return
;
}
this
.
_overflowing
=
false
;
this
.
_updateTextOverflow
(
)
;
this
.
_updateUrlTooltip
(
)
;
}
_on_paste
(
event
)
{
let
originalPasteData
=
event
.
clipboardData
.
getData
(
"
text
/
plain
"
)
;
if
(
!
originalPasteData
)
{
return
;
}
let
oldValue
=
this
.
inputField
.
value
;
let
oldStart
=
oldValue
.
substring
(
0
this
.
selectionStart
)
;
if
(
oldStart
.
trim
(
)
)
{
return
;
}
let
oldEnd
=
oldValue
.
substring
(
this
.
selectionEnd
)
;
let
isURLAssumed
=
true
;
try
{
const
{
keywordAsSent
}
=
Services
.
uriFixup
.
getFixupURIInfo
(
originalPasteData
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
|
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
)
;
isURLAssumed
=
!
keywordAsSent
;
}
catch
(
e
)
{
}
let
pasteData
=
isURLAssumed
?
originalPasteData
.
replace
(
/
[
\
r
\
n
]
/
g
"
"
)
:
originalPasteData
.
replace
(
/
\
s
/
g
"
"
)
;
pasteData
=
UrlbarUtils
.
stripUnsafeProtocolOnPaste
(
pasteData
)
;
if
(
originalPasteData
!
=
pasteData
)
{
event
.
preventDefault
(
)
;
event
.
stopImmediatePropagation
(
)
;
this
.
inputField
.
value
=
oldStart
+
pasteData
+
oldEnd
;
this
.
_untrimmedValue
=
this
.
inputField
.
value
;
let
newCursorPos
=
oldStart
.
length
+
pasteData
.
length
;
this
.
selectionStart
=
newCursorPos
;
this
.
selectionEnd
=
newCursorPos
;
this
.
startQuery
(
{
searchString
:
this
.
inputField
.
value
allowAutofill
:
false
resetSearchState
:
false
event
}
)
;
}
}
_on_scrollend
(
event
)
{
this
.
_updateTextOverflow
(
)
;
}
_on_TabSelect
(
event
)
{
this
.
_gotTabSelect
=
true
;
this
.
_afterTabSelectAndFocusChange
(
)
;
}
_on_beforeinput
(
event
)
{
if
(
event
.
data
&
&
this
.
_keyDownEnterDeferred
)
{
event
.
preventDefault
(
)
;
}
}
_on_keydown
(
event
)
{
if
(
event
.
keyCode
=
=
=
KeyEvent
.
DOM_VK_RETURN
)
{
if
(
this
.
_keyDownEnterDeferred
)
{
this
.
_keyDownEnterDeferred
.
reject
(
)
;
}
this
.
_keyDownEnterDeferred
=
PromiseUtils
.
defer
(
)
;
event
.
_disableCanonization
=
this
.
_isKeyDownWithCtrl
;
}
else
if
(
event
.
keyCode
!
=
=
KeyEvent
.
DOM_VK_CONTROL
&
&
event
.
ctrlKey
)
{
this
.
_isKeyDownWithCtrl
=
true
;
}
if
(
this
.
eventBufferer
.
shouldDeferEvent
(
event
)
)
{
this
.
controller
.
handleKeyNavigation
(
event
false
)
;
}
this
.
_toggleActionOverride
(
event
)
;
this
.
eventBufferer
.
maybeDeferEvent
(
event
(
)
=
>
{
this
.
controller
.
handleKeyNavigation
(
event
)
;
}
)
;
}
async
_on_keyup
(
event
)
{
if
(
event
.
keyCode
=
=
=
KeyEvent
.
DOM_VK_CONTROL
)
{
this
.
_isKeyDownWithCtrl
=
false
;
}
this
.
_toggleActionOverride
(
event
)
;
if
(
this
.
_keyDownEnterDeferred
)
{
if
(
this
.
_keyDownEnterDeferred
.
loadedContent
)
{
try
{
const
loadingBrowser
=
await
this
.
_keyDownEnterDeferred
.
promise
;
if
(
this
.
window
.
gBrowser
.
selectedBrowser
=
=
=
loadingBrowser
)
{
loadingBrowser
.
focus
(
)
;
this
.
selectionStart
=
this
.
selectionEnd
=
0
;
}
}
catch
(
ex
)
{
}
}
else
{
this
.
_keyDownEnterDeferred
.
resolve
(
)
;
}
this
.
_keyDownEnterDeferred
=
null
;
}
}
_on_compositionstart
(
event
)
{
if
(
this
.
_compositionState
=
=
UrlbarUtils
.
COMPOSITION
.
COMPOSING
)
{
throw
new
Error
(
"
Trying
to
start
a
nested
composition
?
"
)
;
}
this
.
_compositionState
=
UrlbarUtils
.
COMPOSITION
.
COMPOSING
;
if
(
UrlbarPrefs
.
get
(
"
keepPanelOpenDuringImeComposition
"
)
)
{
return
;
}
if
(
this
.
view
.
isOpen
)
{
if
(
this
.
searchMode
)
{
if
(
!
this
.
value
)
{
this
.
window
.
gBrowser
.
userTypedValue
=
null
;
}
this
.
confirmSearchMode
(
)
;
}
this
.
_compositionClosedPopup
=
true
;
this
.
view
.
close
(
)
;
}
else
{
this
.
_compositionClosedPopup
=
false
;
}
}
_on_compositionend
(
event
)
{
if
(
this
.
_compositionState
!
=
UrlbarUtils
.
COMPOSITION
.
COMPOSING
)
{
throw
new
Error
(
"
Trying
to
stop
a
non
existing
composition
?
"
)
;
}
if
(
!
UrlbarPrefs
.
get
(
"
keepPanelOpenDuringImeComposition
"
)
)
{
this
.
view
.
clearSelection
(
)
;
this
.
_resultForCurrentValue
=
null
;
}
this
.
_compositionState
=
event
.
data
?
UrlbarUtils
.
COMPOSITION
.
COMMIT
:
UrlbarUtils
.
COMPOSITION
.
CANCELED
;
}
_on_dragstart
(
event
)
{
let
nodePosition
=
this
.
inputField
.
compareDocumentPosition
(
event
.
originalTarget
)
;
if
(
event
.
target
!
=
this
.
inputField
&
&
!
(
nodePosition
&
Node
.
DOCUMENT_POSITION_CONTAINED_BY
)
)
{
return
;
}
this
.
view
.
close
(
)
;
if
(
this
.
selectionStart
!
=
0
|
|
this
.
selectionEnd
!
=
this
.
inputField
.
textLength
|
|
this
.
getAttribute
(
"
pageproxystate
"
)
!
=
"
valid
"
)
{
return
;
}
let
uri
=
this
.
makeURIReadable
(
this
.
window
.
gBrowser
.
currentURI
)
;
let
href
=
uri
.
displaySpec
;
let
title
=
this
.
window
.
gBrowser
.
contentTitle
|
|
href
;
event
.
dataTransfer
.
setData
(
"
text
/
x
-
moz
-
url
"
{
href
}
\
n
{
title
}
)
;
event
.
dataTransfer
.
setData
(
"
text
/
unicode
"
href
)
;
event
.
dataTransfer
.
setData
(
"
text
/
html
"
<
a
href
=
"
{
href
}
"
>
{
title
}
<
/
a
>
)
;
event
.
dataTransfer
.
effectAllowed
=
"
copyLink
"
;
event
.
stopPropagation
(
)
;
}
_on_dragover
(
event
)
{
if
(
!
getDroppableData
(
event
)
)
{
event
.
dataTransfer
.
dropEffect
=
"
none
"
;
}
}
_on_drop
(
event
)
{
let
droppedItem
=
getDroppableData
(
event
)
;
let
droppedURL
=
droppedItem
instanceof
URL
?
droppedItem
.
href
:
droppedItem
;
if
(
droppedURL
&
&
droppedURL
!
=
=
this
.
window
.
gBrowser
.
currentURI
.
spec
)
{
let
principal
=
Services
.
droppedLinkHandler
.
getTriggeringPrincipal
(
event
)
;
this
.
value
=
droppedURL
;
this
.
setPageProxyState
(
"
invalid
"
)
;
this
.
focus
(
)
;
this
.
controller
.
engagementEvent
.
start
(
event
)
;
this
.
handleNavigation
(
{
triggeringPrincipal
:
principal
}
)
;
this
.
window
.
gBrowser
.
userTypedValue
=
null
;
this
.
setURI
(
null
true
)
;
}
}
_on_customizationstarting
(
)
{
this
.
blur
(
)
;
this
.
inputField
.
controllers
.
removeController
(
this
.
_copyCutController
)
;
delete
this
.
_copyCutController
;
}
_on_aftercustomization
(
)
{
this
.
_initCopyCutController
(
)
;
this
.
_initPasteAndGo
(
)
;
}
}
function
getDroppableData
(
event
)
{
let
links
;
try
{
links
=
Services
.
droppedLinkHandler
.
dropLinks
(
event
)
;
}
catch
(
ex
)
{
return
null
;
}
if
(
links
.
length
&
&
links
[
0
]
.
url
)
{
event
.
preventDefault
(
)
;
let
href
=
links
[
0
]
.
url
;
if
(
UrlbarUtils
.
stripUnsafeProtocolOnPaste
(
href
)
!
=
href
)
{
event
.
stopImmediatePropagation
(
)
;
return
null
;
}
try
{
let
url
=
new
URL
(
href
)
;
try
{
let
principal
=
Services
.
droppedLinkHandler
.
getTriggeringPrincipal
(
event
)
;
Services
.
scriptSecurityManager
.
checkLoadURIStrWithPrincipal
(
principal
url
.
href
Ci
.
nsIScriptSecurityManager
.
DISALLOW_INHERIT_PRINCIPAL
)
;
return
url
;
}
catch
(
ex
)
{
return
null
;
}
}
catch
(
ex
)
{
}
}
return
event
.
dataTransfer
.
getData
(
"
text
/
unicode
"
)
;
}
function
losslessDecodeURI
(
aURI
)
{
let
scheme
=
aURI
.
scheme
;
let
value
=
aURI
.
displaySpec
;
if
(
!
/
%
25
(
?
:
3B
|
2F
|
3F
|
3A
|
40
|
26
|
3D
|
2B
|
24
|
2C
|
23
)
/
i
.
test
(
value
)
)
{
let
decodeASCIIOnly
=
!
[
"
https
"
"
http
"
"
file
"
"
ftp
"
]
.
includes
(
scheme
)
;
if
(
decodeASCIIOnly
)
{
value
=
value
.
replace
(
/
%
(
2
[
0
-
4
]
|
2
[
6
-
9a
-
f
]
|
[
3
-
6
]
[
0
-
9a
-
f
]
|
7
[
0
-
9a
-
e
]
)
/
g
decodeURI
)
;
}
else
{
try
{
value
=
decodeURI
(
value
)
.
replace
(
/
%
(
?
!
3B
|
2F
|
3F
|
3A
|
40
|
26
|
3D
|
2B
|
24
|
2C
|
23
)
/
gi
encodeURIComponent
)
;
}
catch
(
e
)
{
}
}
}
value
=
value
.
replace
(
/
[
\
u0000
-
\
u001f
\
u007f
-
\
u00a0
\
u1680
\
u2000
-
\
u200a
\
u2028
\
u2029
\
u202f
\
u205f
\
u2800
\
u3000
\
ufffc
]
|
[
\
r
\
n
\
t
]
|
\
u0020
(
?
=
\
u0020
)
|
\
s
/
g
encodeURIComponent
)
;
value
=
value
.
replace
(
/
[
\
u00ad
\
u034f
\
u061c
\
u06dd
\
u070f
\
u115f
\
u1160
\
u17b4
\
u17b5
\
u180b
-
\
u180e
\
u200b
\
u200e
\
u200f
\
u202a
-
\
u202e
\
u2060
-
\
u206f
\
u3164
\
u0600
-
\
u0605
\
u08e2
\
ufe00
-
\
ufe0f
\
ufeff
\
uffa0
\
ufff0
-
\
ufffb
]
|
\
ud804
[
\
udcbd
\
udccd
]
|
\
ud80d
[
\
udc30
-
\
udc38
]
|
\
ud82f
[
\
udca0
-
\
udca3
]
|
\
ud834
[
\
udd73
-
\
udd7a
]
|
[
\
udb40
-
\
udb43
]
[
\
udc00
-
\
udfff
]
|
\
ud83d
[
\
udd0f
-
\
udd13
\
udee1
]
/
g
encodeURIComponent
)
;
return
value
;
}
class
CopyCutController
{
constructor
(
urlbar
)
{
this
.
urlbar
=
urlbar
;
}
doCommand
(
command
)
{
let
urlbar
=
this
.
urlbar
;
let
val
=
urlbar
.
_getSelectedValueForClipboard
(
)
;
if
(
!
val
)
{
return
;
}
if
(
command
=
=
"
cmd_cut
"
&
&
this
.
isCommandEnabled
(
command
)
)
{
let
start
=
urlbar
.
selectionStart
;
let
end
=
urlbar
.
selectionEnd
;
urlbar
.
inputField
.
value
=
urlbar
.
inputField
.
value
.
substring
(
0
start
)
+
urlbar
.
inputField
.
value
.
substring
(
end
)
;
urlbar
.
selectionStart
=
urlbar
.
selectionEnd
=
start
;
let
event
=
new
UIEvent
(
"
input
"
{
bubbles
:
true
cancelable
:
false
view
:
urlbar
.
window
detail
:
0
}
)
;
urlbar
.
inputField
.
dispatchEvent
(
event
)
;
}
ClipboardHelper
.
copyString
(
val
)
;
}
supportsCommand
(
command
)
{
switch
(
command
)
{
case
"
cmd_copy
"
:
case
"
cmd_cut
"
:
return
true
;
}
return
false
;
}
isCommandEnabled
(
command
)
{
return
(
this
.
supportsCommand
(
command
)
&
&
(
command
!
=
"
cmd_cut
"
|
|
!
this
.
urlbar
.
readOnly
)
&
&
this
.
urlbar
.
selectionStart
<
this
.
urlbar
.
selectionEnd
)
;
}
onEvent
(
)
{
}
}
class
AddSearchEngineHelper
{
constructor
(
input
)
{
this
.
input
=
input
;
this
.
shortcutButtons
=
input
.
view
.
oneOffSearchButtons
;
}
get
maxInlineEngines
(
)
{
return
this
.
shortcutButtons
.
_maxInlineAddEngines
;
}
setEnginesFromBrowser
(
browser
)
{
this
.
browsingContext
=
browser
.
browsingContext
;
let
engines
=
browser
.
engines
?
.
slice
(
)
|
|
[
]
;
if
(
!
this
.
_sameEngines
(
this
.
engines
engines
)
)
{
this
.
engines
=
engines
;
this
.
shortcutButtons
.
updateWebEngines
(
engines
)
;
}
}
_sameEngines
(
engines1
engines2
)
{
if
(
engines1
?
.
length
!
=
engines2
?
.
length
)
{
return
false
;
}
return
ObjectUtils
.
deepEqual
(
engines1
.
map
(
e
=
>
e
.
title
)
engines2
.
map
(
e
=
>
e
.
title
)
)
;
}
_createMenuitem
(
engine
index
)
{
let
elt
=
this
.
input
.
document
.
createXULElement
(
"
menuitem
"
)
;
elt
.
setAttribute
(
"
anonid
"
add
-
engine
-
{
index
}
)
;
elt
.
classList
.
add
(
"
menuitem
-
iconic
"
)
;
elt
.
classList
.
add
(
"
context
-
menu
-
add
-
engine
"
)
;
elt
.
setAttribute
(
"
data
-
l10n
-
id
"
"
search
-
one
-
offs
-
add
-
engine
"
)
;
elt
.
setAttribute
(
"
data
-
l10n
-
args
"
JSON
.
stringify
(
{
engineName
:
engine
.
title
}
)
)
;
elt
.
setAttribute
(
"
uri
"
engine
.
uri
)
;
if
(
engine
.
icon
)
{
elt
.
setAttribute
(
"
image
"
engine
.
icon
)
;
}
else
{
elt
.
removeAttribute
(
"
image
"
engine
.
icon
)
;
}
elt
.
addEventListener
(
"
command
"
this
.
_onCommand
.
bind
(
this
)
)
;
return
elt
;
}
_createMenu
(
engine
)
{
let
elt
=
this
.
input
.
document
.
createXULElement
(
"
menu
"
)
;
elt
.
setAttribute
(
"
anonid
"
"
add
-
engine
-
menu
"
)
;
elt
.
classList
.
add
(
"
menu
-
iconic
"
)
;
elt
.
classList
.
add
(
"
context
-
menu
-
add
-
engine
"
)
;
elt
.
setAttribute
(
"
data
-
l10n
-
id
"
"
search
-
one
-
offs
-
add
-
engine
-
menu
"
)
;
if
(
engine
.
icon
)
{
elt
.
setAttribute
(
"
image
"
engine
.
icon
)
;
}
let
popup
=
this
.
input
.
document
.
createXULElement
(
"
menupopup
"
)
;
elt
.
appendChild
(
popup
)
;
return
elt
;
}
refreshContextMenu
(
)
{
let
engines
=
this
.
engines
;
if
(
!
this
.
input
.
querySelector
(
"
.
menuseparator
-
add
-
engine
"
)
)
{
this
.
contextSeparator
=
this
.
input
.
document
.
createXULElement
(
"
menuseparator
"
)
;
this
.
contextSeparator
.
setAttribute
(
"
anonid
"
"
add
-
engine
-
separator
"
)
;
this
.
contextSeparator
.
classList
.
add
(
"
menuseparator
-
add
-
engine
"
)
;
this
.
contextSeparator
.
collapsed
=
true
;
let
contextMenu
=
this
.
input
.
querySelector
(
"
moz
-
input
-
box
"
)
.
menupopup
;
contextMenu
.
appendChild
(
this
.
contextSeparator
)
;
}
this
.
contextSeparator
.
collapsed
=
!
engines
.
length
;
let
curElt
=
this
.
contextSeparator
;
for
(
let
elt
=
curElt
.
nextElementSibling
;
elt
;
)
{
let
nextElementSibling
=
elt
.
nextElementSibling
;
elt
.
remove
(
)
;
elt
=
nextElementSibling
;
}
if
(
engines
.
length
>
this
.
maxInlineEngines
)
{
let
elt
=
this
.
_createMenu
(
engines
[
0
]
)
;
this
.
contextSeparator
.
insertAdjacentElement
(
"
afterend
"
elt
)
;
curElt
=
elt
.
lastElementChild
;
}
for
(
let
i
=
0
;
i
<
engines
.
length
;
+
+
i
)
{
let
elt
=
this
.
_createMenuitem
(
engines
[
i
]
i
)
;
if
(
curElt
.
localName
=
=
"
menupopup
"
)
{
curElt
.
appendChild
(
elt
)
;
}
else
{
curElt
.
insertAdjacentElement
(
"
afterend
"
elt
)
;
}
curElt
=
elt
;
}
}
async
_onCommand
(
event
)
{
let
added
=
await
SearchUIUtils
.
addOpenSearchEngine
(
event
.
target
.
getAttribute
(
"
uri
"
)
event
.
target
.
getAttribute
(
"
image
"
)
this
.
browsingContext
)
.
catch
(
console
.
error
)
;
if
(
added
)
{
this
.
refreshContextMenu
(
)
;
}
}
}
