"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarInput
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
QueryContext
:
"
resource
:
/
/
/
modules
/
UrlbarController
.
jsm
"
UrlbarController
:
"
resource
:
/
/
/
modules
/
UrlbarController
.
jsm
"
UrlbarView
:
"
resource
:
/
/
/
modules
/
UrlbarView
.
jsm
"
}
)
;
class
UrlbarInput
{
constructor
(
options
=
{
}
)
{
this
.
textbox
=
options
.
textbox
;
this
.
panel
=
options
.
panel
;
this
.
window
=
this
.
textbox
.
ownerGlobal
;
this
.
controller
=
options
.
controller
|
|
new
UrlbarController
(
)
;
this
.
view
=
new
UrlbarView
(
this
)
;
this
.
valueIsTyped
=
false
;
this
.
userInitiatedFocus
=
false
;
this
.
isPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
;
const
METHODS
=
[
"
addEventListener
"
"
removeEventListener
"
"
setAttribute
"
"
hasAttribute
"
"
removeAttribute
"
"
getAttribute
"
"
focus
"
"
blur
"
"
select
"
]
;
const
READ_ONLY_PROPERTIES
=
[
"
focused
"
"
inputField
"
"
editor
"
]
;
const
READ_WRITE_PROPERTIES
=
[
"
value
"
"
placeholder
"
"
readOnly
"
"
selectionStart
"
"
selectionEnd
"
]
;
for
(
let
method
of
METHODS
)
{
this
[
method
]
=
(
.
.
.
args
)
=
>
{
this
.
textbox
[
method
]
(
.
.
.
args
)
;
}
;
}
for
(
let
property
of
READ_ONLY_PROPERTIES
)
{
Object
.
defineProperty
(
this
property
{
enumerable
:
true
get
(
)
{
return
this
.
textbox
[
property
]
;
}
}
)
;
}
for
(
let
property
of
READ_WRITE_PROPERTIES
)
{
Object
.
defineProperty
(
this
property
{
enumerable
:
true
get
(
)
{
return
this
.
textbox
[
property
]
;
}
set
(
val
)
{
return
this
.
textbox
[
property
]
=
val
;
}
}
)
;
}
this
.
addEventListener
(
"
input
"
this
)
;
this
.
inputField
.
addEventListener
(
"
overflow
"
this
)
;
this
.
inputField
.
addEventListener
(
"
underflow
"
this
)
;
this
.
inputField
.
addEventListener
(
"
scrollend
"
this
)
;
}
formatValue
(
)
{
}
closePopup
(
)
{
this
.
view
.
close
(
)
;
}
openResults
(
)
{
this
.
view
.
open
(
)
;
}
handleEvent
(
event
)
{
let
methodName
=
"
_on
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
"
Unrecognized
urlbar
event
:
"
+
event
.
type
;
}
}
_updateTextOverflow
(
)
{
if
(
!
this
.
_inOverflow
)
{
this
.
removeAttribute
(
"
textoverflow
"
)
;
return
;
}
this
.
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
input
=
this
.
inputField
;
if
(
input
&
&
this
.
_inOverflow
)
{
let
side
=
input
.
scrollLeft
&
&
input
.
scrollLeft
=
=
input
.
scrollLeftMax
?
"
start
"
:
"
end
"
;
this
.
setAttribute
(
"
textoverflow
"
side
)
;
}
}
)
;
}
_oninput
(
event
)
{
this
.
controller
.
handleQuery
(
new
QueryContext
(
{
searchString
:
event
.
target
.
value
lastKey
:
"
"
maxResults
:
12
isPrivate
:
this
.
isPrivate
}
)
)
;
}
_onoverflow
(
event
)
{
const
targetIsPlaceholder
=
!
event
.
originalTarget
.
classList
.
contains
(
"
anonymous
-
div
"
)
;
if
(
targetIsPlaceholder
)
{
return
;
}
this
.
_inOverflow
=
true
;
this
.
_updateTextOverflow
(
)
;
}
_onunderflow
(
event
)
{
const
targetIsPlaceholder
=
!
event
.
originalTarget
.
classList
.
contains
(
"
anonymous
-
div
"
)
;
if
(
targetIsPlaceholder
)
{
return
;
}
this
.
_inOverflow
=
false
;
this
.
_updateTextOverflow
(
)
;
}
_onscrollend
(
event
)
{
this
.
_updateTextOverflow
(
)
;
}
}
