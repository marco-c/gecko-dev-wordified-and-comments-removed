"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarView
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UrlbarContextualTip
:
"
resource
:
/
/
/
modules
/
UrlbarContextualTip
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
DEFAULT_REMOVE_STALE_ROWS_TIMEOUT
=
400
;
const
SELECTABLE_ELEMENTS
=
[
"
urlbarView
-
row
"
"
urlbarView
-
tip
-
button
"
"
urlbarView
-
tip
-
help
"
]
;
class
UrlbarView
{
constructor
(
input
)
{
this
.
input
=
input
;
this
.
panel
=
input
.
panel
;
this
.
controller
=
input
.
controller
;
this
.
document
=
this
.
panel
.
ownerDocument
;
this
.
window
=
this
.
document
.
defaultView
;
if
(
this
.
input
.
megabar
)
{
this
.
panel
.
classList
.
add
(
"
megabar
"
)
;
}
this
.
_mainContainer
=
this
.
panel
.
querySelector
(
"
.
urlbarView
-
body
-
inner
"
)
;
this
.
_rows
=
this
.
panel
.
querySelector
(
"
.
urlbarView
-
results
"
)
;
this
.
_rows
.
addEventListener
(
"
mousedown
"
this
)
;
this
.
_rows
.
addEventListener
(
"
mouseup
"
this
)
;
this
.
_rows
.
addEventListener
(
"
overflow
"
this
)
;
this
.
_rows
.
addEventListener
(
"
underflow
"
this
)
;
this
.
window
.
addEventListener
(
"
deactivate
"
this
)
;
this
.
window
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
controller
.
setView
(
this
)
;
this
.
controller
.
addQueryListener
(
this
)
;
}
setContextualTip
(
details
)
{
if
(
!
this
.
contextualTip
)
{
this
.
contextualTip
=
new
UrlbarContextualTip
(
this
)
;
}
this
.
contextualTip
.
set
(
details
)
;
if
(
this
.
visibleRowCount
=
=
0
)
{
this
.
_enableOrDisableOneOffSearches
(
false
)
;
}
this
.
_openPanel
(
)
;
}
hideContextualTip
(
)
{
if
(
this
.
contextualTip
)
{
this
.
contextualTip
.
hide
(
)
;
this
.
input
.
lastQueryContextPromise
.
then
(
(
)
=
>
{
if
(
this
.
visibleRowCount
=
=
0
)
{
this
.
close
(
)
;
}
}
)
;
}
}
removeContextualTip
(
)
{
if
(
!
this
.
contextualTip
)
{
return
;
}
this
.
contextualTip
.
remove
(
)
;
this
.
contextualTip
=
null
;
}
get
oneOffSearchButtons
(
)
{
if
(
!
this
.
_oneOffSearchButtons
)
{
this
.
_oneOffSearchButtons
=
new
this
.
window
.
SearchOneOffs
(
this
.
panel
.
querySelector
(
"
.
search
-
one
-
offs
"
)
)
;
this
.
_oneOffSearchButtons
.
addEventListener
(
"
SelectedOneOffButtonChanged
"
this
)
;
}
return
this
.
_oneOffSearchButtons
;
}
get
isOpen
(
)
{
return
this
.
input
.
hasAttribute
(
"
open
"
)
;
}
get
allowEmptySelection
(
)
{
return
!
(
this
.
_queryContext
&
&
this
.
_queryContext
.
results
[
0
]
&
&
this
.
_queryContext
.
results
[
0
]
.
heuristic
)
;
}
get
selectedRowIndex
(
)
{
if
(
!
this
.
isOpen
)
{
return
-
1
;
}
let
selectedRow
=
this
.
_getSelectedRow
(
)
;
if
(
!
selectedRow
)
{
return
-
1
;
}
return
selectedRow
.
result
.
rowIndex
;
}
set
selectedRowIndex
(
val
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
if
(
val
<
0
)
{
this
.
_selectElement
(
null
)
;
return
val
;
}
let
items
=
Array
.
from
(
this
.
_rows
.
children
)
.
filter
(
r
=
>
this
.
_isElementVisible
(
r
)
)
;
if
(
val
>
=
items
.
length
)
{
throw
new
Error
(
UrlbarView
:
Index
{
val
}
is
out
of
bounds
.
)
;
}
this
.
_selectElement
(
items
[
val
]
)
;
return
val
;
}
get
selectedElementIndex
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_selectedElement
)
{
return
-
1
;
}
return
this
.
_selectedElement
.
elementIndex
;
}
set
selectedElementIndex
(
val
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
if
(
val
<
0
)
{
this
.
_selectElement
(
null
)
;
return
val
;
}
let
selectableElement
=
this
.
_getFirstSelectableElement
(
)
;
while
(
selectableElement
&
&
selectableElement
.
elementIndex
!
=
val
)
{
selectableElement
=
this
.
_getNextSelectableElement
(
selectableElement
)
;
}
if
(
!
selectableElement
)
{
throw
new
Error
(
UrlbarView
:
Index
{
val
}
is
out
of
bounds
.
)
;
}
this
.
_selectElement
(
selectableElement
)
;
return
val
;
}
get
selectedResult
(
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
let
selectedRow
=
this
.
_getSelectedRow
(
)
;
if
(
!
selectedRow
)
{
return
null
;
}
return
selectedRow
.
result
;
}
get
selectedElement
(
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
return
this
.
_selectedElement
;
}
get
visibleRowCount
(
)
{
let
sum
=
0
;
for
(
let
row
of
this
.
_rows
.
children
)
{
sum
+
=
Number
(
this
.
_isElementVisible
(
row
)
)
;
}
return
sum
;
}
get
visibleElementCount
(
)
{
let
sum
=
0
;
let
element
=
this
.
_getFirstSelectableElement
(
)
;
while
(
element
)
{
if
(
this
.
_isElementVisible
(
element
)
)
{
sum
+
+
;
}
element
=
this
.
_getNextSelectableElement
(
element
)
;
}
return
sum
;
}
getResultFromElement
(
element
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
let
row
=
this
.
_getRowFromElement
(
element
)
;
if
(
!
row
)
{
return
null
;
}
return
row
.
result
;
}
selectBy
(
amount
{
reverse
=
false
}
=
{
}
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
this
.
controller
.
cancelQuery
(
)
;
let
selectedElement
=
this
.
_selectedElement
;
let
firstSelectableElement
=
this
.
_getFirstSelectableElement
(
)
;
let
lastSelectableElement
=
this
.
_getLastSelectableElement
(
)
;
if
(
!
selectedElement
)
{
this
.
_selectElement
(
reverse
?
lastSelectableElement
:
firstSelectableElement
)
;
return
;
}
let
endReached
=
reverse
?
selectedElement
=
=
firstSelectableElement
:
selectedElement
=
=
lastSelectableElement
;
if
(
endReached
)
{
if
(
this
.
allowEmptySelection
)
{
selectedElement
=
null
;
}
else
{
selectedElement
=
reverse
?
lastSelectableElement
:
firstSelectableElement
;
}
this
.
_selectElement
(
selectedElement
)
;
return
;
}
while
(
amount
-
-
>
0
)
{
let
next
=
reverse
?
this
.
_getPreviousSelectableElement
(
selectedElement
)
:
this
.
_getNextSelectableElement
(
selectedElement
)
;
if
(
!
next
)
{
break
;
}
if
(
!
this
.
_isElementVisible
(
next
)
)
{
continue
;
}
selectedElement
=
next
;
}
this
.
_selectElement
(
selectedElement
)
;
}
removeAccessibleFocus
(
)
{
this
.
_setAccessibleFocus
(
null
)
;
}
clear
(
)
{
this
.
_rows
.
textContent
=
"
"
;
}
close
(
)
{
this
.
controller
.
cancelQuery
(
)
;
if
(
!
this
.
isOpen
)
{
return
;
}
this
.
removeAccessibleFocus
(
)
;
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
expanded
"
"
false
"
)
;
this
.
input
.
dropmarker
.
removeAttribute
(
"
open
"
)
;
this
.
input
.
removeAttribute
(
"
open
"
)
;
this
.
input
.
endLayoutExtend
(
)
;
if
(
!
this
.
input
.
megabar
&
&
this
.
input
.
_toolbar
)
{
this
.
input
.
_toolbar
.
removeAttribute
(
"
urlbar
-
exceeds
-
toolbar
-
bounds
"
)
;
}
this
.
window
.
removeEventListener
(
"
resize
"
this
)
;
this
.
controller
.
notify
(
this
.
controller
.
NOTIFICATIONS
.
VIEW_CLOSE
)
;
if
(
this
.
contextualTip
)
{
this
.
contextualTip
.
hide
(
)
;
}
}
reOpen
(
)
{
if
(
this
.
_rows
.
firstElementChild
)
{
this
.
_openPanel
(
)
;
}
}
onQueryStarted
(
queryContext
)
{
this
.
_queryWasCancelled
=
false
;
this
.
_startRemoveStaleRowsTimer
(
)
;
}
onQueryCancelled
(
queryContext
)
{
this
.
_queryWasCancelled
=
true
;
this
.
_cancelRemoveStaleRowsTimer
(
)
;
}
onQueryFinished
(
queryContext
)
{
this
.
_cancelRemoveStaleRowsTimer
(
)
;
if
(
!
this
.
_queryWasCancelled
)
{
this
.
_removeStaleRows
(
)
;
}
}
onQueryResults
(
queryContext
)
{
this
.
_queryContext
=
queryContext
;
if
(
!
this
.
isOpen
)
{
this
.
clear
(
)
;
}
this
.
_updateResults
(
queryContext
)
;
let
isFirstPreselectedResult
=
false
;
if
(
queryContext
.
lastResultCount
=
=
0
)
{
if
(
queryContext
.
preselected
)
{
isFirstPreselectedResult
=
true
;
this
.
_selectElement
(
this
.
_getFirstSelectableElement
(
)
{
updateInput
:
false
setAccessibleFocus
:
this
.
controller
.
_userSelectionBehavior
=
=
"
arrow
"
}
)
;
}
else
{
this
.
_selectElement
(
null
{
updateInput
:
false
}
)
;
}
let
trimmedValue
=
queryContext
.
searchString
.
trim
(
)
;
this
.
_enableOrDisableOneOffSearches
(
trimmedValue
&
&
trimmedValue
[
0
]
!
=
"
"
&
&
(
trimmedValue
[
0
]
!
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
|
|
trimmedValue
.
length
!
=
1
)
)
;
this
.
input
.
maybeClearAutofillPlaceholder
(
queryContext
.
results
[
0
]
)
;
}
this
.
_openPanel
(
)
;
if
(
isFirstPreselectedResult
)
{
this
.
input
.
formatValue
(
)
;
}
}
onQueryResultRemoved
(
index
)
{
let
rowToRemove
=
this
.
_rows
.
children
[
index
]
;
rowToRemove
.
remove
(
)
;
this
.
_updateIndices
(
)
;
if
(
rowToRemove
!
=
this
.
_getSelectedRow
(
)
)
{
return
;
}
let
newSelectionIndex
=
index
;
if
(
index
>
=
this
.
_queryContext
.
results
.
length
)
{
newSelectionIndex
=
this
.
_queryContext
.
results
.
length
-
1
;
}
if
(
newSelectionIndex
>
=
0
)
{
this
.
selectedRowIndex
=
newSelectionIndex
;
}
}
handleEvent
(
event
)
{
let
methodName
=
"
_on_
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
new
Error
(
"
Unrecognized
UrlbarView
event
:
"
+
event
.
type
)
;
}
}
handleOneOffSearch
(
event
engine
where
params
)
{
this
.
input
.
handleCommand
(
event
where
params
)
;
}
_createElement
(
name
)
{
return
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
name
)
;
}
_openPanel
(
)
{
if
(
this
.
isOpen
)
{
return
;
}
this
.
controller
.
userSelectionBehavior
=
"
none
"
;
this
.
panel
.
removeAttribute
(
"
actionoverride
"
)
;
if
(
!
this
.
input
.
megabar
)
{
let
getBoundsWithoutFlushing
=
element
=
>
this
.
window
.
windowUtils
.
getBoundsWithoutFlushing
(
element
)
;
let
px
=
number
=
>
number
.
toFixed
(
2
)
+
"
px
"
;
let
inputRect
=
getBoundsWithoutFlushing
(
this
.
input
.
textbox
)
;
let
documentRect
=
getBoundsWithoutFlushing
(
this
.
document
.
documentElement
)
;
let
width
=
documentRect
.
right
-
documentRect
.
left
;
let
boundToCheck
=
this
.
window
.
RTL_UI
?
"
right
"
:
"
left
"
;
let
startOffset
=
Math
.
abs
(
inputRect
[
boundToCheck
]
-
documentRect
[
boundToCheck
]
)
;
let
alignSiteIcons
=
startOffset
/
width
<
=
0
.
3
|
|
startOffset
<
=
250
;
if
(
alignSiteIcons
)
{
let
boundToCheckEnd
=
this
.
window
.
RTL_UI
?
"
left
"
:
"
right
"
;
let
endOffset
=
Math
.
abs
(
inputRect
[
boundToCheckEnd
]
-
documentRect
[
boundToCheckEnd
]
)
;
if
(
endOffset
>
startOffset
*
2
)
{
endOffset
=
startOffset
;
}
let
alignRect
;
for
(
let
id
of
[
"
tracking
-
protection
-
icon
-
box
"
"
identity
-
icon
"
]
)
{
alignRect
=
getBoundsWithoutFlushing
(
this
.
document
.
getElementById
(
id
)
)
;
if
(
alignRect
.
width
>
0
)
{
break
;
}
}
let
start
=
this
.
window
.
RTL_UI
?
documentRect
.
right
-
alignRect
.
right
:
alignRect
.
left
;
this
.
panel
.
style
.
setProperty
(
"
-
-
item
-
padding
-
start
"
px
(
start
)
)
;
this
.
panel
.
style
.
setProperty
(
"
-
-
item
-
padding
-
end
"
px
(
endOffset
)
)
;
}
else
{
this
.
panel
.
style
.
removeProperty
(
"
-
-
item
-
padding
-
start
"
)
;
this
.
panel
.
style
.
removeProperty
(
"
-
-
item
-
padding
-
end
"
)
;
}
this
.
panel
.
style
.
top
=
px
(
getBoundsWithoutFlushing
(
this
.
input
.
textbox
.
closest
(
"
toolbar
"
)
)
.
bottom
)
;
this
.
_mainContainer
.
style
.
maxWidth
=
px
(
width
)
;
if
(
this
.
input
.
_toolbar
)
{
this
.
input
.
_toolbar
.
setAttribute
(
"
urlbar
-
exceeds
-
toolbar
-
bounds
"
"
true
"
)
;
}
}
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
expanded
"
"
true
"
)
;
this
.
input
.
dropmarker
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
input
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
input
.
startLayoutExtend
(
)
;
this
.
window
.
addEventListener
(
"
resize
"
this
)
;
this
.
_windowOuterWidth
=
this
.
window
.
outerWidth
;
this
.
controller
.
notify
(
this
.
controller
.
NOTIFICATIONS
.
VIEW_OPEN
)
;
}
_resultIsSearchSuggestion
(
result
)
{
return
Boolean
(
result
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
suggestion
)
;
}
_rowCanUpdateToResult
(
rowIndex
result
firstSearchSuggestionIndex
lastSearchSuggestionIndex
)
{
if
(
result
.
heuristic
)
{
return
true
;
}
let
row
=
this
.
_rows
.
children
[
rowIndex
]
;
let
resultIsSearchSuggestion
=
this
.
_resultIsSearchSuggestion
(
result
)
;
if
(
resultIsSearchSuggestion
=
=
this
.
_resultIsSearchSuggestion
(
row
.
result
)
)
{
return
true
;
}
return
resultIsSearchSuggestion
&
&
rowIndex
>
=
firstSearchSuggestionIndex
;
}
_updateResults
(
queryContext
)
{
let
firstSearchSuggestionIndex
=
-
1
;
let
lastSearchSuggestionIndex
=
-
1
;
for
(
let
i
=
0
;
i
<
this
.
_rows
.
children
.
length
;
+
+
i
)
{
let
row
=
this
.
_rows
.
children
[
i
]
;
row
.
setAttribute
(
"
stale
"
"
true
"
)
;
if
(
row
.
result
.
heuristic
|
|
i
>
=
queryContext
.
maxResults
|
|
!
this
.
_resultIsSearchSuggestion
(
row
.
result
)
)
{
continue
;
}
if
(
firstSearchSuggestionIndex
=
=
-
1
)
{
firstSearchSuggestionIndex
=
i
;
}
lastSearchSuggestionIndex
=
i
;
}
let
results
=
queryContext
.
results
;
let
resultIndex
=
0
;
for
(
let
rowIndex
=
0
;
rowIndex
<
this
.
_rows
.
children
.
length
&
&
resultIndex
<
results
.
length
;
+
+
rowIndex
)
{
let
row
=
this
.
_rows
.
children
[
rowIndex
]
;
let
result
=
results
[
resultIndex
]
;
if
(
this
.
_rowCanUpdateToResult
(
rowIndex
result
firstSearchSuggestionIndex
lastSearchSuggestionIndex
)
)
{
this
.
_updateRow
(
row
result
)
;
resultIndex
+
+
;
}
}
for
(
;
resultIndex
<
results
.
length
;
+
+
resultIndex
)
{
let
row
=
this
.
_createRow
(
results
[
resultIndex
]
.
type
)
;
this
.
_updateRow
(
row
results
[
resultIndex
]
)
;
if
(
this
.
_rows
.
children
.
length
>
=
queryContext
.
maxResults
)
{
this
.
_setRowVisibility
(
row
false
)
;
}
this
.
_rows
.
appendChild
(
row
)
;
}
this
.
_updateIndices
(
)
;
}
_createRow
(
type
)
{
let
item
=
this
.
_createElement
(
"
div
"
)
;
item
.
className
=
"
urlbarView
-
row
"
;
item
.
setAttribute
(
"
role
"
"
option
"
)
;
item
.
_elements
=
new
Map
(
)
;
let
content
=
this
.
_createElement
(
"
span
"
)
;
content
.
className
=
"
urlbarView
-
row
-
inner
"
;
item
.
appendChild
(
content
)
;
item
.
_elements
.
set
(
"
rowInner
"
content
)
;
let
typeIcon
=
this
.
_createElement
(
"
span
"
)
;
typeIcon
.
className
=
"
urlbarView
-
type
-
icon
"
;
content
.
appendChild
(
typeIcon
)
;
let
favicon
=
this
.
_createElement
(
"
img
"
)
;
favicon
.
className
=
"
urlbarView
-
favicon
"
;
content
.
appendChild
(
favicon
)
;
item
.
_elements
.
set
(
"
favicon
"
favicon
)
;
let
title
=
this
.
_createElement
(
"
span
"
)
;
title
.
className
=
"
urlbarView
-
title
"
;
content
.
appendChild
(
title
)
;
item
.
_elements
.
set
(
"
title
"
title
)
;
if
(
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
content
.
setAttribute
(
"
role
"
"
group
"
)
;
let
buttonSpacer
=
this
.
_createElement
(
"
span
"
)
;
buttonSpacer
.
className
=
"
urlbarView
-
tip
-
button
-
spacer
"
;
content
.
appendChild
(
buttonSpacer
)
;
let
tipButton
=
this
.
_createElement
(
"
span
"
)
;
tipButton
.
className
=
"
urlbarView
-
tip
-
button
"
;
tipButton
.
setAttribute
(
"
role
"
"
button
"
)
;
content
.
appendChild
(
tipButton
)
;
item
.
_elements
.
set
(
"
tipButton
"
tipButton
)
;
let
helpIcon
=
this
.
_createElement
(
"
span
"
)
;
helpIcon
.
className
=
"
urlbarView
-
tip
-
help
"
;
helpIcon
.
setAttribute
(
"
role
"
"
button
"
)
;
helpIcon
.
setAttribute
(
"
data
-
l10n
-
id
"
"
urlbar
-
tip
-
help
-
icon
"
)
;
item
.
_elements
.
set
(
"
helpButton
"
helpIcon
)
;
helpIcon
.
style
.
display
=
"
none
"
;
content
.
appendChild
(
helpIcon
)
;
}
else
{
let
tagsContainer
=
this
.
_createElement
(
"
span
"
)
;
tagsContainer
.
className
=
"
urlbarView
-
tags
"
;
content
.
appendChild
(
tagsContainer
)
;
item
.
_elements
.
set
(
"
tagsContainer
"
tagsContainer
)
;
let
titleSeparator
=
this
.
_createElement
(
"
span
"
)
;
titleSeparator
.
className
=
"
urlbarView
-
title
-
separator
"
;
content
.
appendChild
(
titleSeparator
)
;
item
.
_elements
.
set
(
"
titleSeparator
"
titleSeparator
)
;
let
action
=
this
.
_createElement
(
"
span
"
)
;
action
.
className
=
"
urlbarView
-
secondary
urlbarView
-
action
"
;
content
.
appendChild
(
action
)
;
item
.
_elements
.
set
(
"
action
"
action
)
;
let
url
=
this
.
_createElement
(
"
span
"
)
;
url
.
className
=
"
urlbarView
-
secondary
urlbarView
-
url
"
;
content
.
appendChild
(
url
)
;
item
.
_elements
.
set
(
"
url
"
url
)
;
}
return
item
;
}
_updateRow
(
item
result
)
{
item
.
result
=
result
;
item
.
removeAttribute
(
"
stale
"
)
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
!
result
.
payload
.
keywordOffer
&
&
!
result
.
payload
.
inPrivateWindow
)
{
item
.
setAttribute
(
"
type
"
"
search
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
)
{
item
.
setAttribute
(
"
type
"
"
remotetab
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
)
{
item
.
setAttribute
(
"
type
"
"
switchtab
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
item
.
setAttribute
(
"
type
"
"
tip
"
)
;
}
else
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
{
item
.
setAttribute
(
"
type
"
"
bookmark
"
)
;
}
else
{
item
.
removeAttribute
(
"
type
"
)
;
}
let
favicon
=
item
.
_elements
.
get
(
"
favicon
"
)
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
)
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
SEARCH_GLASS
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
TIP
;
}
else
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
DEFAULT
;
}
let
title
=
item
.
_elements
.
get
(
"
title
"
)
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
title
.
textContent
=
result
.
payload
.
text
;
let
tipButton
=
item
.
_elements
.
get
(
"
tipButton
"
)
;
tipButton
.
textContent
=
result
.
payload
.
buttonText
;
if
(
result
.
payload
.
helpUrl
)
{
let
helpIcon
=
item
.
_elements
.
get
(
"
helpButton
"
)
;
helpIcon
.
style
.
display
=
"
"
;
}
return
;
}
this
.
_addTextContentWithHighlights
(
title
result
.
title
result
.
titleHighlights
)
;
title
.
_tooltip
=
result
.
title
;
if
(
title
.
hasAttribute
(
"
overflow
"
)
)
{
title
.
setAttribute
(
"
title
"
title
.
_tooltip
)
;
}
let
tagsContainer
=
item
.
_elements
.
get
(
"
tagsContainer
"
)
;
tagsContainer
.
textContent
=
"
"
;
if
(
result
.
payload
.
tags
&
&
result
.
payload
.
tags
.
length
)
{
tagsContainer
.
append
(
.
.
.
result
.
payload
.
tags
.
map
(
(
tag
i
)
=
>
{
const
element
=
this
.
_createElement
(
"
span
"
)
;
element
.
className
=
"
urlbarView
-
tag
"
;
this
.
_addTextContentWithHighlights
(
element
tag
result
.
payloadHighlights
.
tags
[
i
]
)
;
return
element
;
}
)
)
;
}
let
action
=
"
"
;
let
isVisitAction
=
false
;
let
setURL
=
false
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
action
=
UrlbarUtils
.
strings
.
GetStringFromName
(
"
switchToTab2
"
)
;
setURL
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
action
=
result
.
payload
.
device
;
setURL
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
if
(
result
.
payload
.
inPrivateWindow
)
{
if
(
result
.
payload
.
isPrivateEngine
)
{
action
=
UrlbarUtils
.
strings
.
formatStringFromName
(
"
searchInPrivateWindowWithEngine
"
[
result
.
payload
.
engine
]
)
;
}
else
{
action
=
UrlbarUtils
.
strings
.
GetStringFromName
(
"
searchInPrivateWindow
"
)
;
}
}
else
{
action
=
UrlbarUtils
.
strings
.
formatStringFromName
(
"
searchWithEngine
"
[
result
.
payload
.
engine
]
)
;
}
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
isVisitAction
=
result
.
payload
.
input
.
trim
(
)
=
=
result
.
payload
.
keyword
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
action
=
result
.
payload
.
content
;
break
;
default
:
if
(
result
.
heuristic
)
{
isVisitAction
=
true
;
}
else
{
setURL
=
true
;
}
break
;
}
let
url
=
item
.
_elements
.
get
(
"
url
"
)
;
if
(
setURL
)
{
this
.
_addTextContentWithHighlights
(
url
result
.
payload
.
displayUrl
result
.
payloadHighlights
.
displayUrl
|
|
[
]
)
;
url
.
_tooltip
=
result
.
payload
.
displayUrl
;
}
else
{
url
.
textContent
=
"
"
;
url
.
_tooltip
=
"
"
;
}
if
(
url
.
hasAttribute
(
"
overflow
"
)
)
{
url
.
setAttribute
(
"
title
"
url
.
_tooltip
)
;
}
if
(
isVisitAction
)
{
action
=
UrlbarUtils
.
strings
.
GetStringFromName
(
"
visit
"
)
;
title
.
setAttribute
(
"
isurl
"
"
true
"
)
;
}
else
{
title
.
removeAttribute
(
"
isurl
"
)
;
}
item
.
_elements
.
get
(
"
action
"
)
.
textContent
=
action
;
item
.
_elements
.
get
(
"
titleSeparator
"
)
.
hidden
=
!
action
&
&
!
setURL
;
}
_updateIndices
(
)
{
for
(
let
i
=
0
;
i
<
this
.
_rows
.
children
.
length
;
i
+
+
)
{
let
item
=
this
.
_rows
.
children
[
i
]
;
item
.
result
.
rowIndex
=
i
;
item
.
id
=
"
urlbarView
-
row
-
"
+
i
;
if
(
item
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
let
title
=
item
.
_elements
.
get
(
"
title
"
)
;
title
.
id
=
item
.
id
+
"
-
title
"
;
let
content
=
item
.
_elements
.
get
(
"
rowInner
"
)
;
content
.
setAttribute
(
"
aria
-
labelledby
"
title
.
id
)
;
let
tipButton
=
item
.
_elements
.
get
(
"
tipButton
"
)
;
tipButton
.
id
=
item
.
id
+
"
-
tip
-
button
"
;
let
helpButton
=
item
.
_elements
.
get
(
"
helpButton
"
)
;
helpButton
.
id
=
item
.
id
+
"
-
tip
-
help
"
;
}
}
let
selectableElement
=
this
.
_getFirstSelectableElement
(
)
;
let
uiIndex
=
0
;
while
(
selectableElement
)
{
selectableElement
.
elementIndex
=
uiIndex
+
+
;
selectableElement
=
this
.
_getNextSelectableElement
(
selectableElement
)
;
}
}
_setRowVisibility
(
row
visible
)
{
row
.
style
.
display
=
visible
?
"
"
:
"
none
"
;
if
(
!
visible
)
{
this
.
_setElementOverflowing
(
row
.
_elements
.
get
(
"
title
"
)
false
)
;
this
.
_setElementOverflowing
(
row
.
_elements
.
get
(
"
url
"
)
false
)
;
}
}
_isElementVisible
(
element
)
{
if
(
!
element
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
element
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
}
if
(
!
element
)
{
return
false
;
}
return
element
.
style
.
display
!
=
"
none
"
;
}
_removeStaleRows
(
)
{
let
row
=
this
.
_rows
.
lastElementChild
;
while
(
row
)
{
let
next
=
row
.
previousElementSibling
;
if
(
row
.
hasAttribute
(
"
stale
"
)
)
{
row
.
remove
(
)
;
}
else
{
this
.
_setRowVisibility
(
row
true
)
;
}
row
=
next
;
}
this
.
_updateIndices
(
)
;
}
_startRemoveStaleRowsTimer
(
)
{
this
.
_removeStaleRowsTimer
=
this
.
window
.
setTimeout
(
(
)
=
>
{
this
.
_removeStaleRowsTimer
=
null
;
this
.
_removeStaleRows
(
)
;
}
UrlbarView
.
removeStaleRowsTimeout
)
;
}
_cancelRemoveStaleRowsTimer
(
)
{
if
(
this
.
_removeStaleRowsTimer
)
{
this
.
window
.
clearTimeout
(
this
.
_removeStaleRowsTimer
)
;
this
.
_removeStaleRowsTimer
=
null
;
}
}
_selectElement
(
item
{
updateInput
=
true
setAccessibleFocus
=
true
}
=
{
}
)
{
if
(
this
.
_selectedElement
)
{
this
.
_selectedElement
.
toggleAttribute
(
"
selected
"
false
)
;
this
.
_selectedElement
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
if
(
item
)
{
item
.
toggleAttribute
(
"
selected
"
true
)
;
item
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
}
this
.
_setAccessibleFocus
(
setAccessibleFocus
&
&
item
)
;
this
.
_selectedElement
=
item
;
if
(
updateInput
)
{
this
.
input
.
setValueFromResult
(
item
&
&
item
.
result
)
;
}
}
_getFirstSelectableElement
(
)
{
let
firstElementChild
=
this
.
_rows
.
firstElementChild
;
if
(
firstElementChild
&
&
firstElementChild
.
result
&
&
firstElementChild
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
firstElementChild
=
firstElementChild
.
_elements
.
get
(
"
tipButton
"
)
;
}
return
firstElementChild
;
}
_getLastSelectableElement
(
)
{
let
lastElementChild
=
this
.
_rows
.
lastElementChild
;
while
(
lastElementChild
&
&
!
this
.
_isElementVisible
(
lastElementChild
)
)
{
lastElementChild
=
this
.
_getPreviousSelectableElement
(
lastElementChild
)
;
}
if
(
lastElementChild
.
result
&
&
lastElementChild
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
lastElementChild
=
lastElementChild
.
_elements
.
get
(
"
helpButton
"
)
;
if
(
lastElementChild
.
style
.
display
=
=
"
none
"
)
{
lastElementChild
=
this
.
_getPreviousSelectableElement
(
lastElementChild
)
;
}
}
return
lastElementChild
;
}
_getNextSelectableElement
(
element
)
{
let
next
;
if
(
element
.
classList
.
contains
(
"
urlbarView
-
tip
-
button
"
)
)
{
next
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
.
_elements
.
get
(
"
helpButton
"
)
;
if
(
next
.
style
.
display
=
=
"
none
"
)
{
next
=
this
.
_getNextSelectableElement
(
next
)
;
}
}
else
if
(
element
.
classList
.
contains
(
"
urlbarView
-
tip
-
help
"
)
)
{
next
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
.
nextElementSibling
;
}
else
{
next
=
element
.
nextElementSibling
;
}
if
(
!
next
)
{
return
null
;
}
if
(
next
.
result
&
&
next
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
next
=
next
.
_elements
.
get
(
"
tipButton
"
)
;
}
return
next
;
}
_getPreviousSelectableElement
(
element
)
{
let
previous
;
if
(
element
.
classList
.
contains
(
"
urlbarView
-
tip
-
button
"
)
)
{
previous
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
.
previousElementSibling
;
}
else
if
(
element
.
classList
.
contains
(
"
urlbarView
-
tip
-
help
"
)
)
{
previous
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
.
_elements
.
get
(
"
tipButton
"
)
;
}
else
{
previous
=
element
.
previousElementSibling
;
}
if
(
!
previous
)
{
return
null
;
}
if
(
previous
.
result
&
&
previous
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
previous
=
previous
.
_elements
.
get
(
"
helpButton
"
)
;
if
(
previous
.
style
.
display
=
=
"
none
"
)
{
previous
=
this
.
_getPreviousSelectableElement
(
previous
)
;
}
}
return
previous
;
}
_getSelectedRow
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_selectedElement
)
{
return
null
;
}
let
selected
=
this
.
_selectedElement
;
if
(
!
selected
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
selected
=
selected
.
closest
(
"
.
urlbarView
-
row
"
)
;
}
return
selected
;
}
_getRowFromElement
(
element
)
{
if
(
!
this
.
isOpen
|
|
!
element
)
{
return
null
;
}
if
(
!
element
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
element
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
}
return
element
;
}
_setAccessibleFocus
(
item
)
{
if
(
item
)
{
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
activedescendant
"
item
.
id
)
;
}
else
{
this
.
input
.
inputField
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
}
_addTextContentWithHighlights
(
parentNode
textContent
highlights
)
{
parentNode
.
textContent
=
"
"
;
if
(
!
textContent
)
{
return
;
}
highlights
=
(
highlights
|
|
[
]
)
.
concat
(
[
[
textContent
.
length
0
]
]
)
;
let
index
=
0
;
for
(
let
[
highlightIndex
highlightLength
]
of
highlights
)
{
if
(
highlightIndex
-
index
>
0
)
{
parentNode
.
appendChild
(
this
.
document
.
createTextNode
(
textContent
.
substring
(
index
highlightIndex
)
)
)
;
}
if
(
highlightLength
>
0
)
{
let
strong
=
this
.
_createElement
(
"
strong
"
)
;
strong
.
textContent
=
textContent
.
substring
(
highlightIndex
highlightIndex
+
highlightLength
)
;
parentNode
.
appendChild
(
strong
)
;
}
index
=
highlightIndex
+
highlightLength
;
}
}
_enableOrDisableOneOffSearches
(
enable
=
true
)
{
if
(
enable
&
&
UrlbarPrefs
.
get
(
"
oneOffSearches
"
)
)
{
this
.
oneOffSearchButtons
.
telemetryOrigin
=
"
urlbar
"
;
this
.
oneOffSearchButtons
.
style
.
display
=
"
"
;
this
.
oneOffSearchButtons
.
textbox
=
this
.
input
.
inputField
;
this
.
oneOffSearchButtons
.
view
=
this
;
}
else
{
this
.
oneOffSearchButtons
.
telemetryOrigin
=
null
;
this
.
oneOffSearchButtons
.
style
.
display
=
"
none
"
;
this
.
oneOffSearchButtons
.
textbox
=
null
;
this
.
oneOffSearchButtons
.
view
=
null
;
}
}
_setElementOverflowing
(
element
overflowing
)
{
element
.
toggleAttribute
(
"
overflow
"
overflowing
)
;
if
(
overflowing
)
{
element
.
setAttribute
(
"
title
"
element
.
_tooltip
)
;
}
else
{
element
.
removeAttribute
(
"
title
"
)
;
}
}
_on_SelectedOneOffButtonChanged
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_queryContext
)
{
return
;
}
let
engine
=
this
.
oneOffSearchButtons
.
selectedButton
&
&
this
.
oneOffSearchButtons
.
selectedButton
.
engine
;
for
(
let
i
=
0
;
i
<
this
.
_queryContext
.
results
.
length
;
i
+
+
)
{
let
result
=
this
.
_queryContext
.
results
[
i
]
;
if
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
(
!
result
.
heuristic
&
&
!
result
.
payload
.
suggestion
&
&
(
!
result
.
payload
.
inPrivateWindow
|
|
result
.
payload
.
isPrivateEngine
)
)
)
{
continue
;
}
if
(
engine
)
{
if
(
!
result
.
payload
.
originalEngine
)
{
result
.
payload
.
originalEngine
=
result
.
payload
.
engine
;
}
result
.
payload
.
engine
=
engine
.
name
;
}
else
if
(
result
.
payload
.
originalEngine
)
{
result
.
payload
.
engine
=
result
.
payload
.
originalEngine
;
delete
result
.
payload
.
originalEngine
;
}
let
item
=
this
.
_rows
.
children
[
i
]
;
if
(
!
result
.
payload
.
inPrivateWindow
)
{
let
action
=
item
.
querySelector
(
"
.
urlbarView
-
action
"
)
;
action
.
textContent
=
UrlbarUtils
.
strings
.
formatStringFromName
(
"
searchWithEngine
"
[
(
engine
&
&
engine
.
name
)
|
|
result
.
payload
.
engine
]
)
;
}
let
favicon
=
item
.
querySelector
(
"
.
urlbarView
-
favicon
"
)
;
if
(
engine
&
&
result
.
payload
.
icon
)
{
favicon
.
src
=
(
engine
.
iconURI
&
&
engine
.
iconURI
.
spec
)
|
|
UrlbarUtils
.
ICON
.
SEARCH_GLASS
;
}
else
if
(
!
engine
)
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
SEARCH_GLASS
;
}
}
}
_on_mousedown
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
let
target
=
event
.
target
;
while
(
!
SELECTABLE_ELEMENTS
.
includes
(
target
.
className
)
)
{
target
=
target
.
parentNode
;
}
this
.
_selectElement
(
target
{
updateInput
:
false
}
)
;
this
.
controller
.
speculativeConnect
(
this
.
selectedResult
this
.
_queryContext
"
mousedown
"
)
;
}
_on_mouseup
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
this
.
input
.
pickElement
(
event
.
target
event
)
;
}
_on_overflow
(
event
)
{
if
(
event
.
detail
=
=
1
&
&
(
event
.
target
.
classList
.
contains
(
"
urlbarView
-
url
"
)
|
|
event
.
target
.
classList
.
contains
(
"
urlbarView
-
title
"
)
)
)
{
this
.
_setElementOverflowing
(
event
.
target
true
)
;
}
}
_on_underflow
(
event
)
{
if
(
event
.
detail
=
=
1
&
&
(
event
.
target
.
classList
.
contains
(
"
urlbarView
-
url
"
)
|
|
event
.
target
.
classList
.
contains
(
"
urlbarView
-
title
"
)
)
)
{
this
.
_setElementOverflowing
(
event
.
target
false
)
;
}
}
_on_resize
(
)
{
if
(
this
.
input
.
megabar
)
{
return
;
}
if
(
this
.
_windowOuterWidth
=
=
this
.
window
.
outerWidth
)
{
return
;
}
this
.
close
(
)
;
}
_on_deactivate
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
ui
.
popup
.
disable_autohide
"
)
)
{
this
.
clear
(
)
;
}
}
_on_TabSelect
(
)
{
this
.
close
(
)
;
this
.
clear
(
)
;
}
}
UrlbarView
.
removeStaleRowsTimeout
=
DEFAULT_REMOVE_STALE_ROWS_TIMEOUT
;
