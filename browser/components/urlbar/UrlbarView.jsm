"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarView
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarSearchOneOffs
:
"
resource
:
/
/
/
modules
/
UrlbarSearchOneOffs
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
const
DEFAULT_REMOVE_STALE_ROWS_TIMEOUT
=
400
;
const
SELECTABLE_ELEMENT_SELECTOR
=
"
[
role
=
button
]
[
selectable
=
true
]
"
;
const
getBoundsWithoutFlushing
=
element
=
>
element
.
ownerGlobal
.
windowUtils
.
getBoundsWithoutFlushing
(
element
)
;
let
gUniqueIdSerial
=
1
;
function
getUniqueId
(
prefix
)
{
return
prefix
+
(
gUniqueIdSerial
+
+
%
9999
)
;
}
class
UrlbarView
{
constructor
(
input
)
{
this
.
input
=
input
;
this
.
panel
=
input
.
panel
;
this
.
controller
=
input
.
controller
;
this
.
document
=
this
.
panel
.
ownerDocument
;
this
.
window
=
this
.
document
.
defaultView
;
this
.
_mainContainer
=
this
.
panel
.
querySelector
(
"
.
urlbarView
-
body
-
inner
"
)
;
this
.
_rows
=
this
.
panel
.
querySelector
(
"
.
urlbarView
-
results
"
)
;
this
.
_rows
.
addEventListener
(
"
mousedown
"
this
)
;
this
.
_rows
.
addEventListener
(
"
mouseup
"
this
)
;
this
.
_rows
.
addEventListener
(
"
overflow
"
this
)
;
this
.
_rows
.
addEventListener
(
"
underflow
"
this
)
;
this
.
panel
.
setAttribute
(
"
noresults
"
"
true
"
)
;
this
.
controller
.
setView
(
this
)
;
this
.
controller
.
addQueryListener
(
this
)
;
this
.
_queryContextCache
=
new
QueryContextCache
(
5
)
;
for
(
let
viewTemplate
of
UrlbarView
.
dynamicViewTemplatesByName
.
values
(
)
)
{
if
(
viewTemplate
.
stylesheet
)
{
this
.
_addDynamicStylesheet
(
viewTemplate
.
stylesheet
)
;
}
}
}
get
oneOffSearchButtons
(
)
{
if
(
!
this
.
_oneOffSearchButtons
)
{
this
.
_oneOffSearchButtons
=
new
UrlbarSearchOneOffs
(
this
)
;
this
.
_oneOffSearchButtons
.
addEventListener
(
"
SelectedOneOffButtonChanged
"
this
)
;
}
return
this
.
_oneOffSearchButtons
;
}
get
oneOffsRefresh
(
)
{
return
(
UrlbarPrefs
.
get
(
"
update2
"
)
&
&
UrlbarPrefs
.
get
(
"
update2
.
oneOffsRefresh
"
)
)
;
}
get
isOpen
(
)
{
return
this
.
input
.
hasAttribute
(
"
open
"
)
;
}
get
allowEmptySelection
(
)
{
return
!
(
this
.
_queryContext
&
&
this
.
_queryContext
.
results
[
0
]
&
&
this
.
_queryContext
.
results
[
0
]
.
heuristic
)
;
}
get
selectedRowIndex
(
)
{
if
(
!
this
.
isOpen
)
{
return
-
1
;
}
let
selectedRow
=
this
.
_getSelectedRow
(
)
;
if
(
!
selectedRow
)
{
return
-
1
;
}
return
selectedRow
.
result
.
rowIndex
;
}
set
selectedRowIndex
(
val
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
if
(
val
<
0
)
{
this
.
_selectElement
(
null
)
;
return
val
;
}
let
items
=
Array
.
from
(
this
.
_rows
.
children
)
.
filter
(
r
=
>
this
.
_isElementVisible
(
r
)
)
;
if
(
val
>
=
items
.
length
)
{
throw
new
Error
(
UrlbarView
:
Index
{
val
}
is
out
of
bounds
.
)
;
}
this
.
_selectElement
(
items
[
val
]
)
;
return
val
;
}
get
selectedElementIndex
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_selectedElement
)
{
return
-
1
;
}
return
this
.
_selectedElement
.
elementIndex
;
}
set
selectedElementIndex
(
val
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
if
(
val
<
0
)
{
this
.
_selectElement
(
null
)
;
return
val
;
}
let
selectableElement
=
this
.
_getFirstSelectableElement
(
)
;
while
(
selectableElement
&
&
selectableElement
.
elementIndex
!
=
val
)
{
selectableElement
=
this
.
_getNextSelectableElement
(
selectableElement
)
;
}
if
(
!
selectableElement
)
{
throw
new
Error
(
UrlbarView
:
Index
{
val
}
is
out
of
bounds
.
)
;
}
this
.
_selectElement
(
selectableElement
)
;
return
val
;
}
get
selectedResult
(
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
let
selectedRow
=
this
.
_getSelectedRow
(
)
;
if
(
!
selectedRow
)
{
return
null
;
}
return
selectedRow
.
result
;
}
get
selectedElement
(
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
return
this
.
_selectedElement
;
}
get
visibleRowCount
(
)
{
let
sum
=
0
;
for
(
let
row
of
this
.
_rows
.
children
)
{
sum
+
=
Number
(
this
.
_isElementVisible
(
row
)
)
;
}
return
sum
;
}
get
visibleElementCount
(
)
{
let
sum
=
0
;
let
element
=
this
.
_getFirstSelectableElement
(
)
;
while
(
element
)
{
if
(
this
.
_isElementVisible
(
element
)
)
{
sum
+
+
;
}
element
=
this
.
_getNextSelectableElement
(
element
)
;
}
return
sum
;
}
getResultFromElement
(
element
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
let
row
=
this
.
_getRowFromElement
(
element
)
;
if
(
!
row
)
{
return
null
;
}
return
row
.
result
;
}
getClosestSelectableElement
(
element
)
{
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
if
(
!
row
)
{
return
null
;
}
let
closest
=
row
;
if
(
row
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
|
|
row
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
closest
=
element
.
closest
(
SELECTABLE_ELEMENT_SELECTOR
)
;
}
return
this
.
_isElementVisible
(
closest
)
?
closest
:
null
;
}
selectBy
(
amount
{
reverse
=
false
}
=
{
}
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
this
.
controller
.
cancelQuery
(
)
;
let
selectedElement
=
this
.
_selectedElement
;
let
firstSelectableElement
=
this
.
_getFirstSelectableElement
(
)
;
let
lastSelectableElement
=
this
.
_getLastSelectableElement
(
)
;
if
(
!
selectedElement
)
{
this
.
_selectElement
(
reverse
?
lastSelectableElement
:
firstSelectableElement
)
;
return
;
}
let
endReached
=
reverse
?
selectedElement
=
=
firstSelectableElement
:
selectedElement
=
=
lastSelectableElement
;
if
(
endReached
)
{
if
(
this
.
allowEmptySelection
)
{
selectedElement
=
null
;
}
else
{
selectedElement
=
reverse
?
lastSelectableElement
:
firstSelectableElement
;
}
this
.
_selectElement
(
selectedElement
)
;
return
;
}
while
(
amount
-
-
>
0
)
{
let
next
=
reverse
?
this
.
_getPreviousSelectableElement
(
selectedElement
)
:
this
.
_getNextSelectableElement
(
selectedElement
)
;
if
(
!
next
)
{
break
;
}
if
(
!
this
.
_isElementVisible
(
next
)
)
{
continue
;
}
selectedElement
=
next
;
}
this
.
_selectElement
(
selectedElement
)
;
}
removeAccessibleFocus
(
)
{
this
.
_setAccessibleFocus
(
null
)
;
}
clear
(
)
{
this
.
_rows
.
textContent
=
"
"
;
this
.
panel
.
setAttribute
(
"
noresults
"
"
true
"
)
;
this
.
_selectElement
(
null
{
updateInput
:
false
}
)
;
}
close
(
elementPicked
=
false
)
{
this
.
controller
.
cancelQuery
(
)
;
if
(
!
this
.
isOpen
)
{
return
;
}
this
.
removeAccessibleFocus
(
)
;
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
expanded
"
"
false
"
)
;
this
.
input
.
removeAttribute
(
"
open
"
)
;
this
.
input
.
endLayoutExtend
(
)
;
if
(
!
this
.
input
.
focused
&
&
!
elementPicked
)
{
this
.
controller
.
engagementEvent
.
discard
(
)
;
this
.
controller
.
engagementEvent
.
record
(
null
{
}
)
;
}
this
.
window
.
removeEventListener
(
"
resize
"
this
)
;
this
.
window
.
removeEventListener
(
"
blur
"
this
)
;
this
.
controller
.
notify
(
this
.
controller
.
NOTIFICATIONS
.
VIEW_CLOSE
)
;
}
autoOpen
(
queryOptions
=
{
}
)
{
if
(
this
.
_pickSearchTipIfPresent
(
queryOptions
.
event
)
)
{
return
false
;
}
if
(
!
queryOptions
.
event
)
{
return
false
;
}
if
(
!
this
.
input
.
value
|
|
this
.
input
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
valid
"
)
{
if
(
!
this
.
input
.
isPrivate
&
&
!
this
.
isOpen
&
&
[
"
mousedown
"
"
command
"
]
.
includes
(
queryOptions
.
event
.
type
)
)
{
this
.
input
.
startQuery
(
queryOptions
)
;
return
true
;
}
return
false
;
}
if
(
!
this
.
input
.
focused
)
{
return
false
;
}
if
(
this
.
isOpen
&
&
queryOptions
.
event
.
type
!
=
"
tabswitch
"
)
{
return
false
;
}
if
(
this
.
_rows
.
firstElementChild
&
&
this
.
_queryContext
.
searchString
=
=
this
.
input
.
value
)
{
queryOptions
.
allowAutofill
=
this
.
_queryContext
.
allowAutofill
;
}
else
{
let
cachedQueryContext
=
this
.
_queryContextCache
.
get
(
this
.
input
.
value
)
;
if
(
cachedQueryContext
)
{
this
.
onQueryResults
(
cachedQueryContext
)
;
}
}
this
.
controller
.
engagementEvent
.
discard
(
)
;
queryOptions
.
searchString
=
this
.
input
.
value
;
queryOptions
.
autofillIgnoresSelection
=
true
;
queryOptions
.
event
.
interactionType
=
"
returned
"
;
if
(
this
.
_queryContext
&
&
this
.
_queryContext
.
results
&
&
this
.
_queryContext
.
results
.
length
)
{
this
.
_openPanel
(
)
;
}
this
.
input
.
startQuery
(
queryOptions
)
;
return
true
;
}
onQueryStarted
(
queryContext
)
{
this
.
_queryWasCancelled
=
false
;
this
.
_queryUpdatedResults
=
false
;
this
.
_startRemoveStaleRowsTimer
(
)
;
}
onQueryCancelled
(
queryContext
)
{
this
.
_queryWasCancelled
=
true
;
this
.
_cancelRemoveStaleRowsTimer
(
)
;
}
onQueryFinished
(
queryContext
)
{
this
.
_cancelRemoveStaleRowsTimer
(
)
;
if
(
this
.
_queryWasCancelled
)
{
return
;
}
if
(
this
.
_queryUpdatedResults
)
{
this
.
_removeStaleRows
(
)
;
return
;
}
this
.
clear
(
)
;
if
(
!
this
.
input
.
searchMode
)
{
this
.
close
(
)
;
return
;
}
this
.
oneOffSearchButtons
.
enable
(
true
)
;
this
.
_openPanel
(
)
;
}
onQueryResults
(
queryContext
)
{
this
.
_queryContextCache
.
put
(
queryContext
)
;
this
.
_queryContext
=
queryContext
;
if
(
!
this
.
isOpen
)
{
this
.
clear
(
)
;
}
this
.
_queryUpdatedResults
=
true
;
this
.
_updateResults
(
queryContext
)
;
let
firstResult
=
queryContext
.
results
[
0
]
;
if
(
queryContext
.
lastResultCount
=
=
0
)
{
this
.
_selectElement
(
null
{
updateInput
:
false
}
)
;
this
.
oneOffSearchButtons
.
enable
(
(
(
this
.
oneOffsRefresh
&
&
firstResult
.
providerName
!
=
"
UrlbarProviderSearchTips
"
)
|
|
queryContext
.
trimmedSearchString
)
&
&
queryContext
.
trimmedSearchString
[
0
]
!
=
"
"
&
&
(
queryContext
.
trimmedSearchString
[
0
]
!
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
|
|
queryContext
.
trimmedSearchString
.
length
!
=
1
)
)
;
}
if
(
firstResult
.
heuristic
&
&
!
this
.
selectedElement
&
&
!
this
.
oneOffSearchButtons
.
selectedButton
)
{
this
.
_selectElement
(
this
.
_getFirstSelectableElement
(
)
{
updateInput
:
false
setAccessibleFocus
:
this
.
controller
.
_userSelectionBehavior
=
=
"
arrow
"
}
)
;
}
if
(
this
.
selectedElement
&
&
!
this
.
oneOffSearchButtons
.
selectedButton
)
{
let
aadID
=
this
.
input
.
inputField
.
getAttribute
(
"
aria
-
activedescendant
"
)
;
if
(
aadID
&
&
!
this
.
document
.
getElementById
(
aadID
)
)
{
this
.
_setAccessibleFocus
(
this
.
selectedElement
)
;
}
}
this
.
_openPanel
(
)
;
if
(
firstResult
.
heuristic
)
{
this
.
input
.
formatValue
(
)
;
}
}
onQueryResultRemoved
(
index
)
{
let
rowToRemove
=
this
.
_rows
.
children
[
index
]
;
rowToRemove
.
remove
(
)
;
this
.
_updateIndices
(
)
;
if
(
rowToRemove
!
=
this
.
_getSelectedRow
(
)
)
{
return
;
}
let
newSelectionIndex
=
index
;
if
(
index
>
=
this
.
_queryContext
.
results
.
length
)
{
newSelectionIndex
=
this
.
_queryContext
.
results
.
length
-
1
;
}
if
(
newSelectionIndex
>
=
0
)
{
this
.
selectedRowIndex
=
newSelectionIndex
;
}
}
handleEvent
(
event
)
{
let
methodName
=
"
_on_
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
new
Error
(
"
Unrecognized
UrlbarView
event
:
"
+
event
.
type
)
;
}
}
static
dynamicViewTemplatesByName
=
new
Map
(
)
;
static
addDynamicViewTemplate
(
name
viewTemplate
)
{
this
.
dynamicViewTemplatesByName
.
set
(
name
viewTemplate
)
;
if
(
viewTemplate
.
stylesheet
)
{
for
(
let
window
of
BrowserWindowTracker
.
orderedWindows
)
{
window
.
gURLBar
.
view
.
_addDynamicStylesheet
(
viewTemplate
.
stylesheet
)
;
}
}
}
static
removeDynamicViewTemplate
(
name
)
{
let
viewTemplate
=
this
.
dynamicViewTemplatesByName
.
get
(
name
)
;
if
(
!
viewTemplate
)
{
return
;
}
this
.
dynamicViewTemplatesByName
.
delete
(
name
)
;
if
(
viewTemplate
.
stylesheet
)
{
for
(
let
window
of
BrowserWindowTracker
.
orderedWindows
)
{
window
.
gURLBar
.
view
.
_removeDynamicStylesheet
(
viewTemplate
.
stylesheet
)
;
}
}
}
_createElement
(
name
)
{
return
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
name
)
;
}
_openPanel
(
)
{
if
(
this
.
isOpen
)
{
return
;
}
this
.
controller
.
userSelectionBehavior
=
"
none
"
;
this
.
panel
.
removeAttribute
(
"
actionoverride
"
)
;
this
.
_enableOrDisableRowWrap
(
)
;
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
expanded
"
"
true
"
)
;
this
.
input
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
input
.
startLayoutExtend
(
)
;
this
.
window
.
addEventListener
(
"
resize
"
this
)
;
this
.
window
.
addEventListener
(
"
blur
"
this
)
;
this
.
controller
.
notify
(
this
.
controller
.
NOTIFICATIONS
.
VIEW_OPEN
)
;
}
_resultIsSearchSuggestion
(
result
)
{
return
Boolean
(
result
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
suggestion
)
;
}
_rowCanUpdateToResult
(
rowIndex
result
firstSearchSuggestionIndex
lastSearchSuggestionIndex
)
{
if
(
result
.
heuristic
)
{
return
true
;
}
let
row
=
this
.
_rows
.
children
[
rowIndex
]
;
let
resultIsSearchSuggestion
=
this
.
_resultIsSearchSuggestion
(
result
)
;
if
(
resultIsSearchSuggestion
=
=
this
.
_resultIsSearchSuggestion
(
row
.
result
)
)
{
return
true
;
}
return
resultIsSearchSuggestion
&
&
rowIndex
>
=
firstSearchSuggestionIndex
;
}
_updateResults
(
queryContext
)
{
let
firstSearchSuggestionIndex
=
-
1
;
let
lastSearchSuggestionIndex
=
-
1
;
for
(
let
i
=
0
;
i
<
this
.
_rows
.
children
.
length
;
+
+
i
)
{
let
row
=
this
.
_rows
.
children
[
i
]
;
row
.
setAttribute
(
"
stale
"
"
true
"
)
;
if
(
row
.
result
.
heuristic
|
|
i
>
=
queryContext
.
maxResults
|
|
!
this
.
_resultIsSearchSuggestion
(
row
.
result
)
)
{
continue
;
}
if
(
firstSearchSuggestionIndex
=
=
-
1
)
{
firstSearchSuggestionIndex
=
i
;
}
lastSearchSuggestionIndex
=
i
;
}
let
results
=
queryContext
.
results
;
let
resultIndex
=
0
;
for
(
let
rowIndex
=
0
;
rowIndex
<
this
.
_rows
.
children
.
length
&
&
resultIndex
<
results
.
length
;
+
+
rowIndex
)
{
let
row
=
this
.
_rows
.
children
[
rowIndex
]
;
let
result
=
results
[
resultIndex
]
;
if
(
this
.
_rowCanUpdateToResult
(
rowIndex
result
firstSearchSuggestionIndex
lastSearchSuggestionIndex
)
)
{
this
.
_updateRow
(
row
result
)
;
resultIndex
+
+
;
}
}
for
(
;
resultIndex
<
results
.
length
;
+
+
resultIndex
)
{
let
row
=
this
.
_createRow
(
)
;
this
.
_updateRow
(
row
results
[
resultIndex
]
)
;
if
(
this
.
_rows
.
children
.
length
>
=
queryContext
.
maxResults
)
{
this
.
_setRowVisibility
(
row
false
)
;
}
this
.
_rows
.
appendChild
(
row
)
;
}
this
.
_updateIndices
(
)
;
}
_createRow
(
)
{
let
item
=
this
.
_createElement
(
"
div
"
)
;
item
.
className
=
"
urlbarView
-
row
"
;
item
.
setAttribute
(
"
role
"
"
option
"
)
;
item
.
_elements
=
new
Map
(
)
;
return
item
;
}
_createRowContent
(
item
)
{
let
noWrap
=
this
.
_createElement
(
"
span
"
)
;
noWrap
.
className
=
"
urlbarView
-
no
-
wrap
"
;
item
.
_content
.
appendChild
(
noWrap
)
;
let
favicon
=
this
.
_createElement
(
"
img
"
)
;
favicon
.
className
=
"
urlbarView
-
favicon
"
;
noWrap
.
appendChild
(
favicon
)
;
item
.
_elements
.
set
(
"
favicon
"
favicon
)
;
let
typeIcon
=
this
.
_createElement
(
"
span
"
)
;
typeIcon
.
className
=
"
urlbarView
-
type
-
icon
"
;
noWrap
.
appendChild
(
typeIcon
)
;
let
tailPrefix
=
this
.
_createElement
(
"
span
"
)
;
tailPrefix
.
className
=
"
urlbarView
-
tail
-
prefix
"
;
noWrap
.
appendChild
(
tailPrefix
)
;
item
.
_elements
.
set
(
"
tailPrefix
"
tailPrefix
)
;
tailPrefix
.
toggleAttribute
(
"
aria
-
hidden
"
true
)
;
let
tailPrefixStr
=
this
.
_createElement
(
"
span
"
)
;
tailPrefixStr
.
className
=
"
urlbarView
-
tail
-
prefix
-
string
"
;
tailPrefix
.
appendChild
(
tailPrefixStr
)
;
item
.
_elements
.
set
(
"
tailPrefixStr
"
tailPrefixStr
)
;
let
tailPrefixChar
=
this
.
_createElement
(
"
span
"
)
;
tailPrefixChar
.
className
=
"
urlbarView
-
tail
-
prefix
-
char
"
;
tailPrefix
.
appendChild
(
tailPrefixChar
)
;
item
.
_elements
.
set
(
"
tailPrefixChar
"
tailPrefixChar
)
;
let
title
=
this
.
_createElement
(
"
span
"
)
;
title
.
className
=
"
urlbarView
-
title
"
;
noWrap
.
appendChild
(
title
)
;
item
.
_elements
.
set
(
"
title
"
title
)
;
let
tagsContainer
=
this
.
_createElement
(
"
span
"
)
;
tagsContainer
.
className
=
"
urlbarView
-
tags
"
;
noWrap
.
appendChild
(
tagsContainer
)
;
item
.
_elements
.
set
(
"
tagsContainer
"
tagsContainer
)
;
let
titleSeparator
=
this
.
_createElement
(
"
span
"
)
;
titleSeparator
.
className
=
"
urlbarView
-
title
-
separator
"
;
noWrap
.
appendChild
(
titleSeparator
)
;
item
.
_elements
.
set
(
"
titleSeparator
"
titleSeparator
)
;
let
action
=
this
.
_createElement
(
"
span
"
)
;
action
.
className
=
"
urlbarView
-
action
"
;
noWrap
.
appendChild
(
action
)
;
item
.
_elements
.
set
(
"
action
"
action
)
;
let
url
=
this
.
_createElement
(
"
span
"
)
;
url
.
className
=
"
urlbarView
-
url
"
;
item
.
_content
.
appendChild
(
url
)
;
item
.
_elements
.
set
(
"
url
"
url
)
;
}
_createRowContentForTip
(
item
)
{
item
.
_content
.
setAttribute
(
"
role
"
"
group
"
)
;
let
favicon
=
this
.
_createElement
(
"
img
"
)
;
favicon
.
className
=
"
urlbarView
-
favicon
"
;
favicon
.
setAttribute
(
"
data
-
l10n
-
id
"
"
urlbar
-
tip
-
icon
-
description
"
)
;
item
.
_content
.
appendChild
(
favicon
)
;
item
.
_elements
.
set
(
"
favicon
"
favicon
)
;
let
title
=
this
.
_createElement
(
"
span
"
)
;
title
.
className
=
"
urlbarView
-
title
"
;
item
.
_content
.
appendChild
(
title
)
;
item
.
_elements
.
set
(
"
title
"
title
)
;
let
buttonSpacer
=
this
.
_createElement
(
"
span
"
)
;
buttonSpacer
.
className
=
"
urlbarView
-
tip
-
button
-
spacer
"
;
item
.
_content
.
appendChild
(
buttonSpacer
)
;
let
tipButton
=
this
.
_createElement
(
"
span
"
)
;
tipButton
.
className
=
"
urlbarView
-
tip
-
button
"
;
tipButton
.
setAttribute
(
"
role
"
"
button
"
)
;
item
.
_content
.
appendChild
(
tipButton
)
;
item
.
_elements
.
set
(
"
tipButton
"
tipButton
)
;
let
helpIcon
=
this
.
_createElement
(
"
span
"
)
;
helpIcon
.
className
=
"
urlbarView
-
tip
-
help
"
;
helpIcon
.
setAttribute
(
"
role
"
"
button
"
)
;
helpIcon
.
setAttribute
(
"
data
-
l10n
-
id
"
"
urlbar
-
tip
-
help
-
icon
"
)
;
item
.
_elements
.
set
(
"
helpButton
"
helpIcon
)
;
item
.
_content
.
appendChild
(
helpIcon
)
;
item
.
addEventListener
(
"
focus
"
(
)
=
>
this
.
input
.
focus
(
)
true
)
;
}
_createRowContentForDynamicType
(
item
result
)
{
let
{
dynamicType
}
=
result
.
payload
;
let
viewTemplate
=
UrlbarView
.
dynamicViewTemplatesByName
.
get
(
dynamicType
)
;
this
.
_buildViewForDynamicType
(
dynamicType
item
.
_content
viewTemplate
)
;
}
_buildViewForDynamicType
(
type
parentNode
template
)
{
for
(
let
className
of
template
.
classList
|
|
[
]
)
{
parentNode
.
classList
.
add
(
className
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
template
.
attributes
|
|
{
}
)
)
{
parentNode
.
setAttribute
(
name
value
)
;
}
if
(
template
.
name
)
{
parentNode
.
setAttribute
(
"
name
"
template
.
name
)
;
}
for
(
let
childTemplate
of
template
.
children
|
|
[
]
)
{
let
child
=
this
.
_createElement
(
childTemplate
.
tag
)
;
child
.
classList
.
add
(
urlbarView
-
dynamic
-
{
type
}
-
{
childTemplate
.
name
}
)
;
parentNode
.
appendChild
(
child
)
;
this
.
_buildViewForDynamicType
(
type
child
childTemplate
)
;
}
}
_updateRow
(
item
result
)
{
let
oldResult
=
item
.
result
;
let
oldResultType
=
item
.
result
&
&
item
.
result
.
type
;
item
.
result
=
result
;
item
.
removeAttribute
(
"
stale
"
)
;
item
.
id
=
getUniqueId
(
"
urlbarView
-
row
-
"
)
;
let
needsNewContent
=
oldResultType
=
=
=
undefined
|
|
(
oldResultType
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
!
=
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
|
|
(
oldResultType
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
!
=
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
|
|
(
oldResultType
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
&
&
oldResult
.
dynamicType
!
=
result
.
dynamicType
)
;
if
(
needsNewContent
)
{
if
(
item
.
_content
)
{
item
.
_content
.
remove
(
)
;
item
.
_elements
.
clear
(
)
;
}
item
.
_content
=
this
.
_createElement
(
"
span
"
)
;
item
.
_content
.
className
=
"
urlbarView
-
row
-
inner
"
;
item
.
appendChild
(
item
.
_content
)
;
item
.
removeAttribute
(
"
dynamicType
"
)
;
if
(
item
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
this
.
_createRowContentForTip
(
item
)
;
}
else
if
(
item
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
this
.
_createRowContentForDynamicType
(
item
result
)
;
}
else
{
this
.
_createRowContent
(
item
)
;
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
!
result
.
payload
.
keywordOffer
&
&
!
result
.
payload
.
inPrivateWindow
)
{
item
.
setAttribute
(
"
type
"
"
search
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
)
{
item
.
setAttribute
(
"
type
"
"
remotetab
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
)
{
item
.
setAttribute
(
"
type
"
"
switchtab
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
item
.
setAttribute
(
"
type
"
"
tip
"
)
;
this
.
_updateRowForTip
(
item
result
)
;
return
;
}
else
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
{
item
.
setAttribute
(
"
type
"
"
bookmark
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
item
.
setAttribute
(
"
type
"
"
dynamic
"
)
;
this
.
_updateRowForDynamicType
(
item
result
)
;
return
;
}
else
{
item
.
removeAttribute
(
"
type
"
)
;
}
let
favicon
=
item
.
_elements
.
get
(
"
favicon
"
)
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
)
{
favicon
.
src
=
this
.
_iconForSearchResult
(
result
)
;
}
else
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
DEFAULT
;
}
if
(
result
.
payload
.
isPinned
)
{
item
.
toggleAttribute
(
"
pinned
"
true
)
;
}
else
{
item
.
removeAttribute
(
"
pinned
"
)
;
}
let
title
=
item
.
_elements
.
get
(
"
title
"
)
;
this
.
_addTextContentWithHighlights
(
title
result
.
title
result
.
titleHighlights
)
;
if
(
result
.
payload
.
tail
&
&
result
.
payload
.
tailOffsetIndex
>
0
)
{
this
.
_fillTailSuggestionPrefix
(
item
result
)
;
title
.
setAttribute
(
"
aria
-
label
"
result
.
payload
.
suggestion
)
;
item
.
toggleAttribute
(
"
tail
-
suggestion
"
true
)
;
}
else
{
item
.
removeAttribute
(
"
tail
-
suggestion
"
)
;
title
.
removeAttribute
(
"
aria
-
label
"
)
;
}
title
.
_tooltip
=
result
.
title
;
if
(
title
.
hasAttribute
(
"
overflow
"
)
)
{
title
.
setAttribute
(
"
title
"
title
.
_tooltip
)
;
}
let
tagsContainer
=
item
.
_elements
.
get
(
"
tagsContainer
"
)
;
tagsContainer
.
textContent
=
"
"
;
if
(
result
.
payload
.
tags
&
&
result
.
payload
.
tags
.
length
)
{
tagsContainer
.
append
(
.
.
.
result
.
payload
.
tags
.
map
(
(
tag
i
)
=
>
{
const
element
=
this
.
_createElement
(
"
span
"
)
;
element
.
className
=
"
urlbarView
-
tag
"
;
this
.
_addTextContentWithHighlights
(
element
tag
result
.
payloadHighlights
.
tags
[
i
]
)
;
return
element
;
}
)
)
;
}
let
action
=
"
"
;
let
isVisitAction
=
false
;
let
setURL
=
false
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
action
=
UrlbarUtils
.
strings
.
GetStringFromName
(
"
switchToTab2
"
)
;
setURL
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
action
=
result
.
payload
.
device
;
setURL
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
if
(
result
.
payload
.
inPrivateWindow
)
{
if
(
result
.
payload
.
isPrivateEngine
)
{
action
=
UrlbarUtils
.
strings
.
formatStringFromName
(
"
searchInPrivateWindowWithEngine
"
[
result
.
payload
.
engine
]
)
;
}
else
{
action
=
UrlbarUtils
.
strings
.
GetStringFromName
(
"
searchInPrivateWindow
"
)
;
}
}
else
{
action
=
UrlbarUtils
.
strings
.
formatStringFromName
(
"
searchWithEngine
"
[
result
.
payload
.
engine
]
)
;
}
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
isVisitAction
=
result
.
payload
.
input
.
trim
(
)
=
=
result
.
payload
.
keyword
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
action
=
result
.
payload
.
content
;
break
;
default
:
if
(
result
.
heuristic
)
{
isVisitAction
=
true
;
}
else
{
setURL
=
true
;
}
break
;
}
let
url
=
item
.
_elements
.
get
(
"
url
"
)
;
if
(
setURL
)
{
item
.
setAttribute
(
"
has
-
url
"
"
true
"
)
;
this
.
_addTextContentWithHighlights
(
url
result
.
payload
.
displayUrl
result
.
payloadHighlights
.
displayUrl
|
|
[
]
)
;
url
.
_tooltip
=
result
.
payload
.
displayUrl
;
}
else
{
item
.
removeAttribute
(
"
has
-
url
"
)
;
url
.
textContent
=
"
"
;
url
.
_tooltip
=
"
"
;
}
if
(
url
.
hasAttribute
(
"
overflow
"
)
)
{
url
.
setAttribute
(
"
title
"
url
.
_tooltip
)
;
}
if
(
isVisitAction
)
{
action
=
UrlbarUtils
.
strings
.
GetStringFromName
(
"
visit
"
)
;
title
.
setAttribute
(
"
isurl
"
"
true
"
)
;
}
else
{
title
.
removeAttribute
(
"
isurl
"
)
;
}
item
.
_elements
.
get
(
"
action
"
)
.
textContent
=
action
;
if
(
!
title
.
hasAttribute
(
"
isurl
"
)
)
{
title
.
setAttribute
(
"
dir
"
"
auto
"
)
;
}
else
{
title
.
removeAttribute
(
"
dir
"
)
;
}
item
.
_elements
.
get
(
"
titleSeparator
"
)
.
hidden
=
!
action
&
&
!
setURL
;
}
_iconForSearchResult
(
result
engineOverride
=
null
)
{
return
(
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
UrlbarUtils
.
ICON
.
HISTORY
)
|
|
(
engineOverride
&
&
engineOverride
.
iconURI
&
&
engineOverride
.
iconURI
.
spec
)
|
|
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
SEARCH_GLASS
)
;
}
_updateRowForTip
(
item
result
)
{
let
favicon
=
item
.
_elements
.
get
(
"
favicon
"
)
;
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
TIP
;
favicon
.
id
=
item
.
id
+
"
-
icon
"
;
let
title
=
item
.
_elements
.
get
(
"
title
"
)
;
title
.
id
=
item
.
id
+
"
-
title
"
;
if
(
result
.
payload
.
textData
)
{
this
.
document
.
l10n
.
setAttributes
(
title
result
.
payload
.
textData
.
id
result
.
payload
.
textData
.
args
)
;
}
else
{
title
.
textContent
=
result
.
payload
.
text
;
}
item
.
_content
.
setAttribute
(
"
aria
-
labelledby
"
{
favicon
.
id
}
{
title
.
id
}
)
;
let
tipButton
=
item
.
_elements
.
get
(
"
tipButton
"
)
;
tipButton
.
id
=
item
.
id
+
"
-
tip
-
button
"
;
if
(
result
.
payload
.
buttonTextData
)
{
this
.
document
.
l10n
.
setAttributes
(
tipButton
result
.
payload
.
buttonTextData
.
id
result
.
payload
.
buttonTextData
.
args
)
;
}
else
{
tipButton
.
textContent
=
result
.
payload
.
buttonText
;
}
let
helpIcon
=
item
.
_elements
.
get
(
"
helpButton
"
)
;
helpIcon
.
id
=
item
.
id
+
"
-
tip
-
help
"
;
helpIcon
.
style
.
display
=
result
.
payload
.
helpUrl
?
"
"
:
"
none
"
;
if
(
result
.
providerName
=
=
"
UrlbarProviderSearchTips
"
)
{
this
.
window
.
A11yUtils
.
announce
(
result
.
payload
.
textData
)
;
}
}
async
_updateRowForDynamicType
(
item
result
)
{
item
.
setAttribute
(
"
dynamicType
"
result
.
payload
.
dynamicType
)
;
let
provider
=
UrlbarProvidersManager
.
getProvider
(
result
.
providerName
)
;
let
viewUpdate
=
await
provider
.
getViewUpdate
(
result
)
;
for
(
let
[
nodeName
update
]
of
Object
.
entries
(
viewUpdate
)
)
{
let
node
=
item
.
querySelector
(
.
urlbarView
-
dynamic
-
{
result
.
payload
.
dynamicType
}
-
{
nodeName
}
)
;
for
(
let
[
attrName
value
]
of
Object
.
entries
(
update
.
attributes
|
|
{
}
)
)
{
node
.
setAttribute
(
attrName
value
)
;
}
for
(
let
[
styleName
value
]
of
Object
.
entries
(
update
.
style
|
|
{
}
)
)
{
node
.
style
[
styleName
]
=
value
;
}
if
(
update
.
l10n
)
{
this
.
document
.
l10n
.
setAttributes
(
node
update
.
l10n
.
id
update
.
l10n
.
args
|
|
undefined
)
;
}
else
if
(
update
.
textContent
)
{
node
.
textContent
=
update
.
textContent
;
}
}
}
_updateIndices
(
)
{
let
visibleRowsExist
=
false
;
for
(
let
i
=
0
;
i
<
this
.
_rows
.
children
.
length
;
i
+
+
)
{
let
item
=
this
.
_rows
.
children
[
i
]
;
item
.
result
.
rowIndex
=
i
;
visibleRowsExist
=
visibleRowsExist
|
|
this
.
_isElementVisible
(
item
)
;
}
let
selectableElement
=
this
.
_getFirstSelectableElement
(
)
;
let
uiIndex
=
0
;
while
(
selectableElement
)
{
selectableElement
.
elementIndex
=
uiIndex
+
+
;
selectableElement
=
this
.
_getNextSelectableElement
(
selectableElement
)
;
}
if
(
visibleRowsExist
)
{
this
.
panel
.
removeAttribute
(
"
noresults
"
)
;
}
else
{
this
.
panel
.
setAttribute
(
"
noresults
"
"
true
"
)
;
}
}
_setRowVisibility
(
row
visible
)
{
row
.
style
.
display
=
visible
?
"
"
:
"
none
"
;
if
(
!
visible
&
&
row
.
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
&
&
row
.
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
this
.
_setElementOverflowing
(
row
.
_elements
.
get
(
"
title
"
)
false
)
;
this
.
_setElementOverflowing
(
row
.
_elements
.
get
(
"
url
"
)
false
)
;
}
}
_isElementVisible
(
element
)
{
if
(
!
element
|
|
element
.
style
.
display
=
=
"
none
"
)
{
return
false
;
}
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
return
row
&
&
row
.
style
.
display
!
=
"
none
"
;
}
_removeStaleRows
(
)
{
let
row
=
this
.
_rows
.
lastElementChild
;
while
(
row
)
{
let
next
=
row
.
previousElementSibling
;
if
(
row
.
hasAttribute
(
"
stale
"
)
)
{
row
.
remove
(
)
;
}
else
{
this
.
_setRowVisibility
(
row
true
)
;
}
row
=
next
;
}
this
.
_updateIndices
(
)
;
}
_startRemoveStaleRowsTimer
(
)
{
this
.
_removeStaleRowsTimer
=
this
.
window
.
setTimeout
(
(
)
=
>
{
this
.
_removeStaleRowsTimer
=
null
;
this
.
_removeStaleRows
(
)
;
}
UrlbarView
.
removeStaleRowsTimeout
)
;
}
_cancelRemoveStaleRowsTimer
(
)
{
if
(
this
.
_removeStaleRowsTimer
)
{
this
.
window
.
clearTimeout
(
this
.
_removeStaleRowsTimer
)
;
this
.
_removeStaleRowsTimer
=
null
;
}
}
_selectElement
(
item
{
updateInput
=
true
setAccessibleFocus
=
true
}
=
{
}
)
{
if
(
this
.
_selectedElement
)
{
this
.
_selectedElement
.
toggleAttribute
(
"
selected
"
false
)
;
this
.
_selectedElement
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
if
(
item
)
{
item
.
toggleAttribute
(
"
selected
"
true
)
;
item
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
}
this
.
_setAccessibleFocus
(
setAccessibleFocus
&
&
item
)
;
this
.
_selectedElement
=
item
;
let
result
=
item
?
.
closest
(
"
.
urlbarView
-
row
"
)
?
.
result
;
if
(
updateInput
)
{
this
.
input
.
setValueFromResult
(
result
)
;
}
else
{
this
.
input
.
setResultForCurrentValue
(
result
)
;
}
}
_isSelectableElement
(
element
)
{
return
this
.
getClosestSelectableElement
(
element
)
=
=
element
;
}
_getFirstSelectableElement
(
)
{
let
element
=
this
.
_rows
.
firstElementChild
;
if
(
element
&
&
!
this
.
_isSelectableElement
(
element
)
)
{
element
=
this
.
_getNextSelectableElement
(
element
)
;
}
return
element
;
}
_getLastSelectableElement
(
)
{
let
element
=
this
.
_rows
.
lastElementChild
;
if
(
element
&
&
!
this
.
_isSelectableElement
(
element
)
)
{
element
=
this
.
_getPreviousSelectableElement
(
element
)
;
}
return
element
;
}
_getNextSelectableElement
(
element
)
{
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
if
(
!
row
)
{
return
null
;
}
let
next
;
if
(
row
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
|
|
row
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
let
selectables
=
[
.
.
.
row
.
querySelectorAll
(
SELECTABLE_ELEMENT_SELECTOR
)
]
;
let
index
=
selectables
.
indexOf
(
element
)
;
if
(
index
=
=
selectables
.
length
-
1
)
{
next
=
row
.
nextElementSibling
;
}
else
{
next
=
selectables
[
index
+
1
]
;
}
}
else
{
next
=
row
.
nextElementSibling
;
}
if
(
next
&
&
!
this
.
_isSelectableElement
(
next
)
)
{
next
=
this
.
_getNextSelectableElement
(
next
)
;
}
return
next
;
}
_getPreviousSelectableElement
(
element
)
{
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
if
(
!
row
)
{
return
null
;
}
let
previous
;
if
(
row
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
|
|
row
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
let
selectables
=
[
.
.
.
row
.
querySelectorAll
(
SELECTABLE_ELEMENT_SELECTOR
)
]
;
let
index
=
selectables
.
indexOf
(
element
)
;
if
(
index
=
=
0
|
|
!
selectables
.
length
)
{
previous
=
row
.
previousElementSibling
;
}
else
if
(
index
<
0
)
{
previous
=
selectables
[
selectables
.
length
-
1
]
;
}
else
{
previous
=
selectables
[
index
-
1
]
;
}
}
else
{
previous
=
row
.
previousElementSibling
;
}
if
(
previous
&
&
!
this
.
_isSelectableElement
(
previous
)
)
{
previous
=
this
.
_getPreviousSelectableElement
(
previous
)
;
}
return
previous
;
}
_getSelectedRow
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_selectedElement
)
{
return
null
;
}
let
selected
=
this
.
_selectedElement
;
if
(
!
selected
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
selected
=
selected
.
closest
(
"
.
urlbarView
-
row
"
)
;
}
return
selected
;
}
_getRowFromElement
(
element
)
{
if
(
!
this
.
isOpen
|
|
!
element
)
{
return
null
;
}
if
(
!
element
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
element
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
}
return
element
;
}
_setAccessibleFocus
(
item
)
{
if
(
item
)
{
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
activedescendant
"
item
.
id
)
;
}
else
{
this
.
input
.
inputField
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
}
_addTextContentWithHighlights
(
parentNode
textContent
highlights
)
{
parentNode
.
textContent
=
"
"
;
if
(
!
textContent
)
{
return
;
}
highlights
=
(
highlights
|
|
[
]
)
.
concat
(
[
[
textContent
.
length
0
]
]
)
;
let
index
=
0
;
for
(
let
[
highlightIndex
highlightLength
]
of
highlights
)
{
if
(
highlightIndex
-
index
>
0
)
{
parentNode
.
appendChild
(
this
.
document
.
createTextNode
(
textContent
.
substring
(
index
highlightIndex
)
)
)
;
}
if
(
highlightLength
>
0
)
{
let
strong
=
this
.
_createElement
(
"
strong
"
)
;
strong
.
textContent
=
textContent
.
substring
(
highlightIndex
highlightIndex
+
highlightLength
)
;
parentNode
.
appendChild
(
strong
)
;
}
index
=
highlightIndex
+
highlightLength
;
}
}
_fillTailSuggestionPrefix
(
item
result
)
{
let
tailPrefixStrNode
=
item
.
_elements
.
get
(
"
tailPrefixStr
"
)
;
let
tailPrefixStr
=
result
.
payload
.
suggestion
.
substring
(
0
result
.
payload
.
tailOffsetIndex
)
;
tailPrefixStrNode
.
textContent
=
tailPrefixStr
;
let
tailPrefixCharNode
=
item
.
_elements
.
get
(
"
tailPrefixChar
"
)
;
tailPrefixCharNode
.
textContent
=
result
.
payload
.
tailPrefix
;
}
_enableOrDisableRowWrap
(
)
{
if
(
getBoundsWithoutFlushing
(
this
.
input
.
textbox
)
.
width
<
650
)
{
this
.
_rows
.
setAttribute
(
"
wrap
"
"
true
"
)
;
}
else
{
this
.
_rows
.
removeAttribute
(
"
wrap
"
)
;
}
}
_setElementOverflowing
(
element
overflowing
)
{
element
.
toggleAttribute
(
"
overflow
"
overflowing
)
;
if
(
overflowing
)
{
element
.
setAttribute
(
"
title
"
element
.
_tooltip
)
;
}
else
{
element
.
removeAttribute
(
"
title
"
)
;
}
}
_pickSearchTipIfPresent
(
event
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_queryContext
|
|
this
.
_queryContext
.
results
.
length
!
=
1
)
{
return
false
;
}
let
result
=
this
.
_queryContext
.
results
[
0
]
;
if
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
return
false
;
}
let
tipButton
=
this
.
_rows
.
firstElementChild
.
querySelector
(
"
.
urlbarView
-
tip
-
button
"
)
;
if
(
!
tipButton
)
{
throw
new
Error
(
"
Expected
a
tip
button
"
)
;
}
this
.
input
.
pickElement
(
tipButton
event
)
;
return
true
;
}
async
_addDynamicStylesheet
(
stylesheetURL
)
{
try
{
let
uri
=
Services
.
io
.
newURI
(
stylesheetURL
)
;
let
sheet
=
await
styleSheetService
.
preloadSheetAsync
(
uri
Ci
.
nsIStyleSheetService
.
AGENT_SHEET
)
;
this
.
window
.
windowUtils
.
addSheet
(
sheet
Ci
.
nsIDOMWindowUtils
.
AGENT_SHEET
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Error
adding
dynamic
stylesheet
:
{
ex
}
)
;
}
}
_removeDynamicStylesheet
(
stylesheetURL
)
{
try
{
this
.
window
.
windowUtils
.
removeSheetUsingURIString
(
stylesheetURL
Ci
.
nsIDOMWindowUtils
.
AGENT_SHEET
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Error
removing
dynamic
stylesheet
:
{
ex
}
)
;
}
}
_on_SelectedOneOffButtonChanged
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_queryContext
)
{
return
;
}
let
engine
=
this
.
oneOffSearchButtons
.
selectedButton
&
&
this
.
oneOffSearchButtons
.
selectedButton
.
engine
;
for
(
let
item
of
this
.
_rows
.
children
)
{
let
result
=
item
.
result
;
if
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
(
!
result
.
heuristic
&
&
(
!
result
.
payload
.
suggestion
|
|
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
)
&
&
(
!
result
.
payload
.
inPrivateWindow
|
|
result
.
payload
.
isPrivateEngine
)
)
)
{
continue
;
}
if
(
engine
)
{
if
(
!
result
.
payload
.
originalEngine
)
{
result
.
payload
.
originalEngine
=
result
.
payload
.
engine
;
}
result
.
payload
.
engine
=
engine
.
name
;
}
else
if
(
result
.
payload
.
originalEngine
)
{
result
.
payload
.
engine
=
result
.
payload
.
originalEngine
;
delete
result
.
payload
.
originalEngine
;
}
if
(
result
.
heuristic
&
&
engine
&
&
!
this
.
selectedElement
)
{
item
.
setAttribute
(
"
show
-
action
-
text
"
"
true
"
)
;
}
else
{
item
.
removeAttribute
(
"
show
-
action
-
text
"
)
;
}
if
(
!
result
.
payload
.
inPrivateWindow
)
{
let
action
=
item
.
querySelector
(
"
.
urlbarView
-
action
"
)
;
action
.
textContent
=
UrlbarUtils
.
strings
.
formatStringFromName
(
"
searchWithEngine
"
[
(
engine
&
&
engine
.
name
)
|
|
result
.
payload
.
engine
]
)
;
}
if
(
!
this
.
oneOffsRefresh
|
|
result
.
heuristic
|
|
(
result
.
payload
.
inPrivateWindow
&
&
!
result
.
payload
.
isPrivateEngine
)
)
{
let
favicon
=
item
.
querySelector
(
"
.
urlbarView
-
favicon
"
)
;
if
(
engine
&
&
result
.
payload
.
icon
)
{
favicon
.
src
=
(
engine
.
iconURI
&
&
engine
.
iconURI
.
spec
)
|
|
UrlbarUtils
.
ICON
.
SEARCH_GLASS
;
}
else
if
(
!
engine
)
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
SEARCH_GLASS
;
}
favicon
.
src
=
this
.
_iconForSearchResult
(
result
engine
)
;
}
}
}
_on_blur
(
event
)
{
if
(
!
UrlbarPrefs
.
get
(
"
ui
.
popup
.
disable_autohide
"
)
)
{
this
.
close
(
)
;
}
}
_on_mousedown
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
let
element
=
this
.
getClosestSelectableElement
(
event
.
target
)
;
if
(
!
element
)
{
return
;
}
this
.
_selectElement
(
element
{
updateInput
:
false
}
)
;
this
.
controller
.
speculativeConnect
(
this
.
selectedResult
this
.
_queryContext
"
mousedown
"
)
;
}
_on_mouseup
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
let
element
=
this
.
getClosestSelectableElement
(
event
.
target
)
;
if
(
!
element
)
{
return
;
}
this
.
input
.
pickElement
(
element
event
)
;
}
_on_overflow
(
event
)
{
if
(
event
.
detail
=
=
1
&
&
(
event
.
target
.
classList
.
contains
(
"
urlbarView
-
url
"
)
|
|
event
.
target
.
classList
.
contains
(
"
urlbarView
-
title
"
)
)
)
{
this
.
_setElementOverflowing
(
event
.
target
true
)
;
}
}
_on_underflow
(
event
)
{
if
(
event
.
detail
=
=
1
&
&
(
event
.
target
.
classList
.
contains
(
"
urlbarView
-
url
"
)
|
|
event
.
target
.
classList
.
contains
(
"
urlbarView
-
title
"
)
)
)
{
this
.
_setElementOverflowing
(
event
.
target
false
)
;
}
}
_on_resize
(
)
{
this
.
_enableOrDisableRowWrap
(
)
;
}
}
UrlbarView
.
removeStaleRowsTimeout
=
DEFAULT_REMOVE_STALE_ROWS_TIMEOUT
;
class
QueryContextCache
{
constructor
(
size
)
{
this
.
size
=
size
;
this
.
_cache
=
[
]
;
}
put
(
queryContext
)
{
let
searchString
=
queryContext
.
searchString
;
if
(
!
searchString
|
|
!
queryContext
.
results
.
length
)
{
return
;
}
let
index
=
this
.
_cache
.
findIndex
(
e
=
>
e
.
searchString
=
=
searchString
)
;
if
(
index
!
=
-
1
)
{
if
(
this
.
_cache
[
index
]
=
=
queryContext
)
{
return
;
}
this
.
_cache
.
splice
(
index
1
)
;
}
if
(
this
.
_cache
.
unshift
(
queryContext
)
>
this
.
size
)
{
this
.
_cache
.
length
=
this
.
size
;
}
}
get
(
searchString
)
{
return
this
.
_cache
.
find
(
e
=
>
e
.
searchString
=
=
searchString
)
;
}
}
