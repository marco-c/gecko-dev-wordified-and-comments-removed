"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarView
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
L10nCache
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarSearchOneOffs
:
"
resource
:
/
/
/
modules
/
UrlbarSearchOneOffs
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
styleSheetService
"
"
mozilla
.
org
/
content
/
style
-
sheet
-
service
;
1
"
"
nsIStyleSheetService
"
)
;
const
DEFAULT_REMOVE_STALE_ROWS_TIMEOUT
=
400
;
const
SELECTABLE_ELEMENT_SELECTOR
=
"
[
role
=
button
]
[
selectable
=
true
]
"
;
const
getBoundsWithoutFlushing
=
element
=
>
element
.
ownerGlobal
.
windowUtils
.
getBoundsWithoutFlushing
(
element
)
;
let
gUniqueIdSerial
=
1
;
function
getUniqueId
(
prefix
)
{
return
prefix
+
(
gUniqueIdSerial
+
+
%
9999
)
;
}
class
UrlbarView
{
constructor
(
input
)
{
this
.
input
=
input
;
this
.
panel
=
input
.
panel
;
this
.
controller
=
input
.
controller
;
this
.
document
=
this
.
panel
.
ownerDocument
;
this
.
window
=
this
.
document
.
defaultView
;
this
.
_mainContainer
=
this
.
panel
.
querySelector
(
"
.
urlbarView
-
body
-
inner
"
)
;
this
.
_rows
=
this
.
panel
.
querySelector
(
"
.
urlbarView
-
results
"
)
;
this
.
_rows
.
addEventListener
(
"
mousedown
"
this
)
;
this
.
_rows
.
addEventListener
(
"
mouseup
"
this
)
;
this
.
_rows
.
addEventListener
(
"
overflow
"
this
)
;
this
.
_rows
.
addEventListener
(
"
underflow
"
this
)
;
this
.
panel
.
setAttribute
(
"
noresults
"
"
true
"
)
;
this
.
controller
.
setView
(
this
)
;
this
.
controller
.
addQueryListener
(
this
)
;
this
.
_queryContextCache
=
new
QueryContextCache
(
5
)
;
this
.
_l10nCache
=
new
L10nCache
(
this
.
document
.
l10n
)
;
for
(
let
viewTemplate
of
UrlbarView
.
dynamicViewTemplatesByName
.
values
(
)
)
{
if
(
viewTemplate
.
stylesheet
)
{
addDynamicStylesheet
(
this
.
window
viewTemplate
.
stylesheet
)
;
}
}
}
get
oneOffSearchButtons
(
)
{
if
(
!
this
.
_oneOffSearchButtons
)
{
this
.
_oneOffSearchButtons
=
new
UrlbarSearchOneOffs
(
this
)
;
this
.
_oneOffSearchButtons
.
addEventListener
(
"
SelectedOneOffButtonChanged
"
this
)
;
}
return
this
.
_oneOffSearchButtons
;
}
get
isOpen
(
)
{
return
this
.
input
.
hasAttribute
(
"
open
"
)
;
}
get
allowEmptySelection
(
)
{
let
{
heuristicResult
}
=
this
.
_queryContext
;
return
!
heuristicResult
|
|
!
this
.
_shouldShowHeuristic
(
heuristicResult
)
;
}
get
selectedRowIndex
(
)
{
if
(
!
this
.
isOpen
)
{
return
-
1
;
}
let
selectedRow
=
this
.
_getSelectedRow
(
)
;
if
(
!
selectedRow
)
{
return
-
1
;
}
return
selectedRow
.
result
.
rowIndex
;
}
set
selectedRowIndex
(
val
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
if
(
val
<
0
)
{
this
.
_selectElement
(
null
)
;
return
;
}
let
items
=
Array
.
from
(
this
.
_rows
.
children
)
.
filter
(
r
=
>
this
.
_isElementVisible
(
r
)
)
;
if
(
val
>
=
items
.
length
)
{
throw
new
Error
(
UrlbarView
:
Index
{
val
}
is
out
of
bounds
.
)
;
}
this
.
_selectElement
(
items
[
val
]
)
;
}
get
selectedElementIndex
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_selectedElement
)
{
return
-
1
;
}
return
this
.
_selectedElement
.
elementIndex
;
}
set
selectedElementIndex
(
val
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
if
(
val
<
0
)
{
this
.
_selectElement
(
null
)
;
return
;
}
let
selectableElement
=
this
.
_getFirstSelectableElement
(
)
;
while
(
selectableElement
&
&
selectableElement
.
elementIndex
!
=
val
)
{
selectableElement
=
this
.
_getNextSelectableElement
(
selectableElement
)
;
}
if
(
!
selectableElement
)
{
throw
new
Error
(
UrlbarView
:
Index
{
val
}
is
out
of
bounds
.
)
;
}
this
.
_selectElement
(
selectableElement
)
;
}
get
selectedResult
(
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
let
selectedRow
=
this
.
_getSelectedRow
(
)
;
if
(
!
selectedRow
)
{
return
null
;
}
return
selectedRow
.
result
;
}
get
selectedElement
(
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
return
this
.
_selectedElement
;
}
clearSelection
(
)
{
this
.
_selectElement
(
null
{
updateInput
:
false
}
)
;
}
get
visibleRowCount
(
)
{
let
sum
=
0
;
for
(
let
row
of
this
.
_rows
.
children
)
{
sum
+
=
Number
(
this
.
_isElementVisible
(
row
)
)
;
}
return
sum
;
}
get
visibleElementCount
(
)
{
let
sum
=
0
;
let
element
=
this
.
_getFirstSelectableElement
(
)
;
while
(
element
)
{
if
(
this
.
_isElementVisible
(
element
)
)
{
sum
+
+
;
}
element
=
this
.
_getNextSelectableElement
(
element
)
;
}
return
sum
;
}
getResultFromElement
(
element
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
let
row
=
this
.
_getRowFromElement
(
element
)
;
if
(
!
row
)
{
return
null
;
}
return
row
.
result
;
}
getResultAtIndex
(
index
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_rows
.
children
.
length
|
|
index
>
=
this
.
_rows
.
children
.
length
)
{
return
null
;
}
return
this
.
_rows
.
children
[
index
]
.
result
;
}
getClosestSelectableElement
(
element
)
{
let
closest
=
element
.
closest
(
SELECTABLE_ELEMENT_SELECTOR
)
;
if
(
!
closest
)
{
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
if
(
row
&
&
!
row
.
querySelector
(
SELECTABLE_ELEMENT_SELECTOR
)
)
{
closest
=
row
;
}
}
return
this
.
_isElementVisible
(
closest
)
?
closest
:
null
;
}
resultIsSelected
(
result
)
{
if
(
this
.
selectedRowIndex
<
0
)
{
return
false
;
}
return
result
.
rowIndex
=
=
this
.
selectedRowIndex
;
}
selectBy
(
amount
{
reverse
=
false
userPressedTab
=
false
}
=
{
}
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
const
isSkippableTabToSearchAnnounce
=
selectedElt
=
>
{
let
skipAnnouncement
=
selectedElt
?
.
result
?
.
providerName
=
=
"
TabToSearch
"
&
&
!
this
.
_announceTabToSearchOnSelection
&
&
userPressedTab
&
&
UrlbarPrefs
.
get
(
"
accessibility
.
tabToSearch
.
announceResults
"
)
;
if
(
skipAnnouncement
)
{
this
.
_announceTabToSearchOnSelection
=
true
;
}
return
skipAnnouncement
;
}
;
if
(
!
this
.
input
.
eventBufferer
.
isDeferringEvents
)
{
this
.
controller
.
cancelQuery
(
)
;
}
let
selectedElement
=
this
.
_selectedElement
;
let
firstSelectableElement
=
this
.
_getFirstSelectableElement
(
)
;
let
lastSelectableElement
=
this
.
_getLastSelectableElement
(
)
;
if
(
!
selectedElement
)
{
selectedElement
=
reverse
?
lastSelectableElement
:
firstSelectableElement
;
this
.
_selectElement
(
selectedElement
{
setAccessibleFocus
:
!
isSkippableTabToSearchAnnounce
(
selectedElement
)
}
)
;
return
;
}
let
endReached
=
reverse
?
selectedElement
=
=
firstSelectableElement
:
selectedElement
=
=
lastSelectableElement
;
if
(
endReached
)
{
if
(
this
.
allowEmptySelection
)
{
selectedElement
=
null
;
}
else
{
selectedElement
=
reverse
?
lastSelectableElement
:
firstSelectableElement
;
}
this
.
_selectElement
(
selectedElement
{
setAccessibleFocus
:
!
isSkippableTabToSearchAnnounce
(
selectedElement
)
}
)
;
return
;
}
while
(
amount
-
-
>
0
)
{
let
next
=
reverse
?
this
.
_getPreviousSelectableElement
(
selectedElement
)
:
this
.
_getNextSelectableElement
(
selectedElement
)
;
if
(
!
next
)
{
break
;
}
if
(
!
this
.
_isElementVisible
(
next
)
)
{
continue
;
}
selectedElement
=
next
;
}
this
.
_selectElement
(
selectedElement
{
setAccessibleFocus
:
!
isSkippableTabToSearchAnnounce
(
selectedElement
)
}
)
;
}
removeAccessibleFocus
(
)
{
this
.
_setAccessibleFocus
(
null
)
;
}
clear
(
)
{
this
.
_rows
.
textContent
=
"
"
;
this
.
panel
.
setAttribute
(
"
noresults
"
"
true
"
)
;
this
.
clearSelection
(
)
;
}
close
(
{
elementPicked
=
false
showFocusBorder
=
true
}
=
{
}
)
{
this
.
controller
.
cancelQuery
(
)
;
if
(
!
elementPicked
&
&
showFocusBorder
)
{
this
.
input
.
removeAttribute
(
"
suppress
-
focus
-
border
"
)
;
}
if
(
!
this
.
isOpen
)
{
return
;
}
if
(
this
.
input
.
searchMode
?
.
isPreview
)
{
this
.
input
.
searchMode
=
null
;
}
this
.
removeAccessibleFocus
(
)
;
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
expanded
"
"
false
"
)
;
this
.
_openPanelInstance
=
null
;
this
.
_previousTabToSearchEngine
=
null
;
this
.
input
.
removeAttribute
(
"
open
"
)
;
this
.
input
.
endLayoutExtend
(
)
;
if
(
!
this
.
input
.
focused
&
&
!
elementPicked
)
{
this
.
controller
.
engagementEvent
.
discard
(
)
;
this
.
controller
.
engagementEvent
.
record
(
null
{
}
)
;
}
this
.
window
.
removeEventListener
(
"
resize
"
this
)
;
this
.
window
.
removeEventListener
(
"
blur
"
this
)
;
this
.
controller
.
notify
(
this
.
controller
.
NOTIFICATIONS
.
VIEW_CLOSE
)
;
}
autoOpen
(
{
event
suppressFocusBorder
=
true
}
)
{
if
(
this
.
_pickSearchTipIfPresent
(
event
)
)
{
return
false
;
}
if
(
!
event
)
{
return
false
;
}
let
queryOptions
=
{
event
}
;
if
(
!
this
.
input
.
value
|
|
this
.
input
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
valid
"
)
{
if
(
!
this
.
isOpen
&
&
[
"
mousedown
"
"
command
"
]
.
includes
(
event
.
type
)
)
{
this
.
input
.
startQuery
(
queryOptions
)
;
if
(
suppressFocusBorder
)
{
this
.
input
.
toggleAttribute
(
"
suppress
-
focus
-
border
"
true
)
;
}
return
true
;
}
return
false
;
}
if
(
!
this
.
input
.
focused
)
{
return
false
;
}
if
(
this
.
isOpen
&
&
event
.
type
!
=
"
tabswitch
"
)
{
return
false
;
}
if
(
this
.
_rows
.
firstElementChild
&
&
this
.
_queryContext
.
searchString
=
=
this
.
input
.
value
)
{
queryOptions
.
allowAutofill
=
this
.
_queryContext
.
allowAutofill
;
}
else
{
let
cachedQueryContext
=
this
.
_queryContextCache
.
get
(
this
.
input
.
value
)
;
if
(
cachedQueryContext
)
{
this
.
onQueryResults
(
cachedQueryContext
)
;
}
}
this
.
controller
.
engagementEvent
.
discard
(
)
;
queryOptions
.
searchString
=
this
.
input
.
value
;
queryOptions
.
autofillIgnoresSelection
=
true
;
queryOptions
.
event
.
interactionType
=
"
returned
"
;
if
(
this
.
_queryContext
&
&
this
.
_queryContext
.
results
&
&
this
.
_queryContext
.
results
.
length
)
{
this
.
_openPanel
(
)
;
}
this
.
input
.
startQuery
(
queryOptions
)
;
if
(
suppressFocusBorder
)
{
this
.
input
.
toggleAttribute
(
"
suppress
-
focus
-
border
"
true
)
;
}
return
true
;
}
onQueryStarted
(
queryContext
)
{
this
.
_queryWasCancelled
=
false
;
this
.
_queryUpdatedResults
=
false
;
this
.
_openPanelInstance
=
null
;
if
(
!
queryContext
.
searchString
)
{
this
.
_previousTabToSearchEngine
=
null
;
}
this
.
_startRemoveStaleRowsTimer
(
)
;
this
.
_cacheL10nStrings
(
)
;
}
onQueryCancelled
(
queryContext
)
{
this
.
_queryWasCancelled
=
true
;
this
.
_cancelRemoveStaleRowsTimer
(
)
;
}
onQueryFinished
(
queryContext
)
{
this
.
_cancelRemoveStaleRowsTimer
(
)
;
if
(
this
.
_queryWasCancelled
)
{
return
;
}
if
(
this
.
_queryUpdatedResults
)
{
this
.
_removeStaleRows
(
)
;
return
;
}
this
.
clear
(
)
;
if
(
!
this
.
input
.
searchMode
)
{
this
.
close
(
)
;
return
;
}
let
openPanelInstance
=
(
this
.
_openPanelInstance
=
{
}
)
;
this
.
oneOffSearchButtons
.
willHide
(
)
.
then
(
willHide
=
>
{
if
(
!
willHide
&
&
openPanelInstance
=
=
this
.
_openPanelInstance
)
{
this
.
oneOffSearchButtons
.
enable
(
true
)
;
this
.
_openPanel
(
)
;
}
}
)
;
}
onQueryResults
(
queryContext
)
{
this
.
_queryContextCache
.
put
(
queryContext
)
;
this
.
_queryContext
=
queryContext
;
if
(
!
this
.
isOpen
)
{
this
.
clear
(
)
;
}
this
.
_queryUpdatedResults
=
true
;
this
.
_updateResults
(
queryContext
)
;
let
firstResult
=
queryContext
.
results
[
0
]
;
if
(
queryContext
.
lastResultCount
=
=
0
)
{
this
.
_selectElement
(
null
{
updateInput
:
false
}
)
;
this
.
oneOffSearchButtons
.
enable
(
(
firstResult
.
providerName
!
=
"
UrlbarProviderSearchTips
"
|
|
queryContext
.
trimmedSearchString
)
&
&
queryContext
.
trimmedSearchString
[
0
]
!
=
"
"
&
&
(
queryContext
.
trimmedSearchString
[
0
]
!
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
|
|
queryContext
.
trimmedSearchString
.
length
!
=
1
)
)
;
}
if
(
!
this
.
selectedElement
&
&
!
this
.
oneOffSearchButtons
.
selectedButton
)
{
if
(
firstResult
.
heuristic
)
{
if
(
this
.
_shouldShowHeuristic
(
firstResult
)
)
{
this
.
_selectElement
(
this
.
_getFirstSelectableElement
(
)
{
updateInput
:
false
setAccessibleFocus
:
this
.
controller
.
_userSelectionBehavior
=
=
"
arrow
"
}
)
;
}
else
{
this
.
input
.
setResultForCurrentValue
(
firstResult
)
;
}
}
else
if
(
firstResult
.
payload
.
providesSearchMode
&
&
queryContext
.
trimmedSearchString
!
=
"
"
)
{
this
.
input
.
setResultForCurrentValue
(
firstResult
)
;
}
}
let
secondResult
=
queryContext
.
results
[
1
]
;
if
(
secondResult
?
.
providerName
=
=
"
TabToSearch
"
&
&
UrlbarPrefs
.
get
(
"
accessibility
.
tabToSearch
.
announceResults
"
)
&
&
this
.
_previousTabToSearchEngine
!
=
secondResult
.
payload
.
engine
)
{
let
engine
=
secondResult
.
payload
.
engine
;
this
.
window
.
A11yUtils
.
announce
(
{
id
:
secondResult
.
payload
.
isGeneralPurposeEngine
?
"
urlbar
-
result
-
action
-
before
-
tabtosearch
-
web
"
:
"
urlbar
-
result
-
action
-
before
-
tabtosearch
-
other
"
args
:
{
engine
}
}
)
;
this
.
_previousTabToSearchEngine
=
engine
;
this
.
_announceTabToSearchOnSelection
=
false
;
}
if
(
this
.
selectedElement
&
&
!
this
.
oneOffSearchButtons
.
selectedButton
)
{
let
aadID
=
this
.
input
.
inputField
.
getAttribute
(
"
aria
-
activedescendant
"
)
;
if
(
aadID
&
&
!
this
.
document
.
getElementById
(
aadID
)
)
{
this
.
_setAccessibleFocus
(
this
.
selectedElement
)
;
}
}
this
.
_openPanel
(
)
;
if
(
firstResult
.
heuristic
)
{
this
.
input
.
formatValue
(
)
;
}
if
(
queryContext
.
deferUserSelectionProviders
.
size
)
{
queryContext
.
results
.
forEach
(
r
=
>
{
queryContext
.
deferUserSelectionProviders
.
delete
(
r
.
providerName
)
;
}
)
;
}
}
onQueryResultRemoved
(
index
)
{
let
rowToRemove
=
this
.
_rows
.
children
[
index
]
;
rowToRemove
.
remove
(
)
;
this
.
_updateIndices
(
)
;
if
(
rowToRemove
!
=
this
.
_getSelectedRow
(
)
)
{
return
;
}
let
newSelectionIndex
=
index
;
if
(
index
>
=
this
.
_queryContext
.
results
.
length
)
{
newSelectionIndex
=
this
.
_queryContext
.
results
.
length
-
1
;
}
if
(
newSelectionIndex
>
=
0
)
{
this
.
selectedRowIndex
=
newSelectionIndex
;
}
}
handleEvent
(
event
)
{
let
methodName
=
"
_on_
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
new
Error
(
"
Unrecognized
UrlbarView
event
:
"
+
event
.
type
)
;
}
}
static
dynamicViewTemplatesByName
=
new
Map
(
)
;
static
addDynamicViewTemplate
(
name
viewTemplate
)
{
this
.
dynamicViewTemplatesByName
.
set
(
name
viewTemplate
)
;
if
(
viewTemplate
.
stylesheet
)
{
for
(
let
window
of
BrowserWindowTracker
.
orderedWindows
)
{
addDynamicStylesheet
(
window
viewTemplate
.
stylesheet
)
;
}
}
}
static
removeDynamicViewTemplate
(
name
)
{
let
viewTemplate
=
this
.
dynamicViewTemplatesByName
.
get
(
name
)
;
if
(
!
viewTemplate
)
{
return
;
}
this
.
dynamicViewTemplatesByName
.
delete
(
name
)
;
if
(
viewTemplate
.
stylesheet
)
{
for
(
let
window
of
BrowserWindowTracker
.
orderedWindows
)
{
removeDynamicStylesheet
(
window
viewTemplate
.
stylesheet
)
;
}
}
}
_createElement
(
name
)
{
return
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
name
)
;
}
_openPanel
(
)
{
if
(
this
.
isOpen
)
{
return
;
}
this
.
controller
.
userSelectionBehavior
=
"
none
"
;
this
.
panel
.
removeAttribute
(
"
actionoverride
"
)
;
this
.
_enableOrDisableRowWrap
(
)
;
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
expanded
"
"
true
"
)
;
this
.
input
.
toggleAttribute
(
"
suppress
-
focus
-
border
"
true
)
;
this
.
input
.
setAttribute
(
"
open
"
"
true
"
)
;
this
.
input
.
startLayoutExtend
(
)
;
this
.
window
.
addEventListener
(
"
resize
"
this
)
;
this
.
window
.
addEventListener
(
"
blur
"
this
)
;
this
.
controller
.
notify
(
this
.
controller
.
NOTIFICATIONS
.
VIEW_OPEN
)
;
}
_shouldShowHeuristic
(
result
)
{
if
(
!
result
?
.
heuristic
)
{
throw
new
Error
(
"
A
heuristic
result
must
be
given
"
)
;
}
return
(
!
UrlbarPrefs
.
get
(
"
experimental
.
hideHeuristic
"
)
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
;
}
_resultIsSearchSuggestion
(
result
)
{
return
Boolean
(
result
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
suggestion
)
;
}
_rowCanUpdateToResult
(
rowIndex
result
seenSearchSuggestion
)
{
if
(
result
.
heuristic
)
{
return
true
;
}
let
row
=
this
.
_rows
.
children
[
rowIndex
]
;
if
(
result
.
hasSuggestedIndex
!
=
row
.
result
.
hasSuggestedIndex
)
{
return
false
;
}
if
(
result
.
hasSuggestedIndex
&
&
result
.
suggestedIndex
!
=
row
.
result
.
suggestedIndex
)
{
return
false
;
}
let
resultIsSearchSuggestion
=
this
.
_resultIsSearchSuggestion
(
result
)
;
if
(
resultIsSearchSuggestion
=
=
this
.
_resultIsSearchSuggestion
(
row
.
result
)
)
{
return
true
;
}
return
resultIsSearchSuggestion
&
&
seenSearchSuggestion
;
}
_updateResults
(
queryContext
)
{
let
results
=
queryContext
.
results
;
if
(
results
[
0
]
?
.
heuristic
&
&
!
this
.
_shouldShowHeuristic
(
results
[
0
]
)
)
{
results
=
results
.
slice
(
1
)
;
}
let
rowIndex
=
0
;
let
resultIndex
=
0
;
let
visibleSpanCount
=
0
;
let
seenMisplacedResult
=
false
;
let
seenSearchSuggestion
=
false
;
for
(
;
rowIndex
<
this
.
_rows
.
children
.
length
&
&
resultIndex
<
results
.
length
;
+
+
rowIndex
)
{
let
row
=
this
.
_rows
.
children
[
rowIndex
]
;
if
(
this
.
_isElementVisible
(
row
)
)
{
visibleSpanCount
+
=
UrlbarUtils
.
getSpanForResult
(
row
.
result
)
;
}
if
(
!
seenMisplacedResult
)
{
seenSearchSuggestion
=
seenSearchSuggestion
|
|
(
!
row
.
result
.
heuristic
&
&
this
.
_resultIsSearchSuggestion
(
row
.
result
)
)
;
let
result
=
results
[
resultIndex
]
;
if
(
this
.
_rowCanUpdateToResult
(
rowIndex
result
seenSearchSuggestion
)
)
{
this
.
_updateRow
(
row
result
)
;
resultIndex
+
+
;
continue
;
}
if
(
result
.
hasSuggestedIndex
|
|
row
.
result
.
hasSuggestedIndex
)
{
seenMisplacedResult
=
true
;
}
}
row
.
setAttribute
(
"
stale
"
"
true
"
)
;
}
for
(
;
rowIndex
<
this
.
_rows
.
children
.
length
;
+
+
rowIndex
)
{
let
row
=
this
.
_rows
.
children
[
rowIndex
]
;
row
.
setAttribute
(
"
stale
"
"
true
"
)
;
if
(
this
.
_isElementVisible
(
row
)
)
{
visibleSpanCount
+
=
UrlbarUtils
.
getSpanForResult
(
row
.
result
)
;
}
}
for
(
;
resultIndex
<
results
.
length
;
+
+
resultIndex
)
{
let
row
=
this
.
_createRow
(
)
;
let
result
=
results
[
resultIndex
]
;
this
.
_updateRow
(
row
result
)
;
if
(
!
seenMisplacedResult
&
&
result
.
hasSuggestedIndex
)
{
if
(
result
.
isSuggestedIndexRelativeToGroup
)
{
seenMisplacedResult
=
true
;
}
else
{
let
finalIndex
=
result
.
suggestedIndex
>
=
0
?
Math
.
min
(
results
.
length
-
1
result
.
suggestedIndex
)
:
Math
.
max
(
0
results
.
length
+
result
.
suggestedIndex
)
;
if
(
this
.
_rows
.
children
.
length
!
=
finalIndex
)
{
seenMisplacedResult
=
true
;
}
}
}
let
newVisibleSpanCount
=
visibleSpanCount
+
UrlbarUtils
.
getSpanForResult
(
result
)
;
if
(
newVisibleSpanCount
<
=
queryContext
.
maxResults
&
&
!
seenMisplacedResult
)
{
visibleSpanCount
=
newVisibleSpanCount
;
}
else
{
this
.
_setRowVisibility
(
row
false
)
;
}
this
.
_rows
.
appendChild
(
row
)
;
}
this
.
_updateIndices
(
)
;
}
_createRow
(
)
{
let
item
=
this
.
_createElement
(
"
div
"
)
;
item
.
className
=
"
urlbarView
-
row
"
;
item
.
setAttribute
(
"
role
"
"
option
"
)
;
item
.
_elements
=
new
Map
(
)
;
return
item
;
}
_createRowContent
(
item
result
)
{
let
noWrap
=
this
.
_createElement
(
"
span
"
)
;
noWrap
.
className
=
"
urlbarView
-
no
-
wrap
"
;
item
.
_content
.
appendChild
(
noWrap
)
;
let
favicon
=
this
.
_createElement
(
"
img
"
)
;
favicon
.
className
=
"
urlbarView
-
favicon
"
;
noWrap
.
appendChild
(
favicon
)
;
item
.
_elements
.
set
(
"
favicon
"
favicon
)
;
let
typeIcon
=
this
.
_createElement
(
"
span
"
)
;
typeIcon
.
className
=
"
urlbarView
-
type
-
icon
"
;
noWrap
.
appendChild
(
typeIcon
)
;
let
tailPrefix
=
this
.
_createElement
(
"
span
"
)
;
tailPrefix
.
className
=
"
urlbarView
-
tail
-
prefix
"
;
noWrap
.
appendChild
(
tailPrefix
)
;
item
.
_elements
.
set
(
"
tailPrefix
"
tailPrefix
)
;
tailPrefix
.
toggleAttribute
(
"
aria
-
hidden
"
true
)
;
let
tailPrefixStr
=
this
.
_createElement
(
"
span
"
)
;
tailPrefixStr
.
className
=
"
urlbarView
-
tail
-
prefix
-
string
"
;
tailPrefix
.
appendChild
(
tailPrefixStr
)
;
item
.
_elements
.
set
(
"
tailPrefixStr
"
tailPrefixStr
)
;
let
tailPrefixChar
=
this
.
_createElement
(
"
span
"
)
;
tailPrefixChar
.
className
=
"
urlbarView
-
tail
-
prefix
-
char
"
;
tailPrefix
.
appendChild
(
tailPrefixChar
)
;
item
.
_elements
.
set
(
"
tailPrefixChar
"
tailPrefixChar
)
;
let
title
=
this
.
_createElement
(
"
span
"
)
;
title
.
className
=
"
urlbarView
-
title
"
;
noWrap
.
appendChild
(
title
)
;
item
.
_elements
.
set
(
"
title
"
title
)
;
let
tagsContainer
=
this
.
_createElement
(
"
span
"
)
;
tagsContainer
.
className
=
"
urlbarView
-
tags
"
;
noWrap
.
appendChild
(
tagsContainer
)
;
item
.
_elements
.
set
(
"
tagsContainer
"
tagsContainer
)
;
let
titleSeparator
=
this
.
_createElement
(
"
span
"
)
;
titleSeparator
.
className
=
"
urlbarView
-
title
-
separator
"
;
noWrap
.
appendChild
(
titleSeparator
)
;
item
.
_elements
.
set
(
"
titleSeparator
"
titleSeparator
)
;
let
action
=
this
.
_createElement
(
"
span
"
)
;
action
.
className
=
"
urlbarView
-
action
"
;
noWrap
.
appendChild
(
action
)
;
item
.
_elements
.
set
(
"
action
"
action
)
;
let
url
=
this
.
_createElement
(
"
span
"
)
;
url
.
className
=
"
urlbarView
-
url
"
;
item
.
_content
.
appendChild
(
url
)
;
item
.
_elements
.
set
(
"
url
"
url
)
;
if
(
result
.
payload
.
helpUrl
)
{
let
helpButton
=
this
.
_createElement
(
"
span
"
)
;
helpButton
.
className
=
"
urlbarView
-
help
"
;
helpButton
.
setAttribute
(
"
role
"
"
button
"
)
;
if
(
result
.
payload
.
helpL10nId
)
{
helpButton
.
setAttribute
(
"
data
-
l10n
-
id
"
result
.
payload
.
helpL10nId
)
;
}
item
.
appendChild
(
helpButton
)
;
item
.
_elements
.
set
(
"
helpButton
"
helpButton
)
;
item
.
_content
.
setAttribute
(
"
selectable
"
"
true
"
)
;
item
.
setAttribute
(
"
role
"
"
presentation
"
)
;
item
.
_content
.
setAttribute
(
"
role
"
"
option
"
)
;
}
}
_createRowContentForTip
(
item
)
{
item
.
_content
.
setAttribute
(
"
role
"
"
group
"
)
;
let
favicon
=
this
.
_createElement
(
"
img
"
)
;
favicon
.
className
=
"
urlbarView
-
favicon
"
;
favicon
.
setAttribute
(
"
data
-
l10n
-
id
"
"
urlbar
-
tip
-
icon
-
description
"
)
;
item
.
_content
.
appendChild
(
favicon
)
;
item
.
_elements
.
set
(
"
favicon
"
favicon
)
;
let
title
=
this
.
_createElement
(
"
span
"
)
;
title
.
className
=
"
urlbarView
-
title
"
;
item
.
_content
.
appendChild
(
title
)
;
item
.
_elements
.
set
(
"
title
"
title
)
;
let
buttonSpacer
=
this
.
_createElement
(
"
span
"
)
;
buttonSpacer
.
className
=
"
urlbarView
-
tip
-
button
-
spacer
"
;
item
.
_content
.
appendChild
(
buttonSpacer
)
;
let
tipButton
=
this
.
_createElement
(
"
span
"
)
;
tipButton
.
className
=
"
urlbarView
-
tip
-
button
"
;
tipButton
.
setAttribute
(
"
role
"
"
button
"
)
;
item
.
_content
.
appendChild
(
tipButton
)
;
item
.
_elements
.
set
(
"
tipButton
"
tipButton
)
;
let
helpIcon
=
this
.
_createElement
(
"
span
"
)
;
helpIcon
.
className
=
"
urlbarView
-
help
"
;
helpIcon
.
setAttribute
(
"
role
"
"
button
"
)
;
helpIcon
.
setAttribute
(
"
data
-
l10n
-
id
"
"
urlbar
-
tip
-
help
-
icon
"
)
;
item
.
_elements
.
set
(
"
helpButton
"
helpIcon
)
;
item
.
_content
.
appendChild
(
helpIcon
)
;
item
.
addEventListener
(
"
focus
"
(
)
=
>
this
.
input
.
focus
(
)
true
)
;
}
_createRowContentForDynamicType
(
item
result
)
{
let
{
dynamicType
}
=
result
.
payload
;
let
viewTemplate
=
UrlbarView
.
dynamicViewTemplatesByName
.
get
(
dynamicType
)
;
this
.
_buildViewForDynamicType
(
dynamicType
item
.
_content
item
.
_elements
viewTemplate
)
;
}
_buildViewForDynamicType
(
type
parentNode
elementsByName
template
)
{
for
(
let
className
of
template
.
classList
|
|
[
]
)
{
parentNode
.
classList
.
add
(
className
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
template
.
attributes
|
|
{
}
)
)
{
if
(
name
=
=
"
id
"
)
{
Cu
.
reportError
(
"
Dynamic
results
are
prohibited
from
setting
their
own
IDs
.
"
)
;
continue
;
}
parentNode
.
setAttribute
(
name
value
)
;
}
if
(
template
.
name
)
{
parentNode
.
setAttribute
(
"
name
"
template
.
name
)
;
elementsByName
.
set
(
template
.
name
parentNode
)
;
}
for
(
let
childTemplate
of
template
.
children
|
|
[
]
)
{
let
child
=
this
.
_createElement
(
childTemplate
.
tag
)
;
child
.
classList
.
add
(
urlbarView
-
dynamic
-
{
type
}
-
{
childTemplate
.
name
}
)
;
parentNode
.
appendChild
(
child
)
;
this
.
_buildViewForDynamicType
(
type
child
elementsByName
childTemplate
)
;
}
}
_updateRow
(
item
result
)
{
let
oldResult
=
item
.
result
;
let
oldResultType
=
item
.
result
&
&
item
.
result
.
type
;
item
.
result
=
result
;
item
.
removeAttribute
(
"
stale
"
)
;
item
.
id
=
getUniqueId
(
"
urlbarView
-
row
-
"
)
;
let
needsNewContent
=
oldResultType
=
=
=
undefined
|
|
(
oldResultType
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
!
=
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
|
|
(
oldResultType
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
!
=
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
|
|
(
oldResultType
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
&
&
oldResult
.
dynamicType
!
=
result
.
dynamicType
)
|
|
!
!
result
.
payload
.
helpUrl
!
=
item
.
_elements
.
has
(
"
helpButton
"
)
;
if
(
needsNewContent
)
{
while
(
item
.
lastChild
)
{
item
.
lastChild
.
remove
(
)
;
}
item
.
_elements
.
clear
(
)
;
item
.
_content
=
this
.
_createElement
(
"
span
"
)
;
item
.
_content
.
className
=
"
urlbarView
-
row
-
inner
"
;
item
.
appendChild
(
item
.
_content
)
;
item
.
removeAttribute
(
"
dynamicType
"
)
;
if
(
item
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
this
.
_createRowContentForTip
(
item
)
;
}
else
if
(
item
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
this
.
_createRowContentForDynamicType
(
item
result
)
;
}
else
{
this
.
_createRowContent
(
item
result
)
;
}
}
item
.
_content
.
id
=
item
.
id
+
"
-
inner
"
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
!
result
.
payload
.
providesSearchMode
&
&
!
result
.
payload
.
inPrivateWindow
)
{
item
.
setAttribute
(
"
type
"
"
search
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
)
{
item
.
setAttribute
(
"
type
"
"
remotetab
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
)
{
item
.
setAttribute
(
"
type
"
"
switchtab
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
item
.
setAttribute
(
"
type
"
"
tip
"
)
;
this
.
_updateRowForTip
(
item
result
)
;
return
;
}
else
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
{
item
.
setAttribute
(
"
type
"
"
bookmark
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
item
.
setAttribute
(
"
type
"
"
dynamic
"
)
;
this
.
_updateRowForDynamicType
(
item
result
)
;
return
;
}
else
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
item
.
setAttribute
(
"
type
"
"
tabtosearch
"
)
;
}
else
{
item
.
removeAttribute
(
"
type
"
)
;
}
let
favicon
=
item
.
_elements
.
get
(
"
favicon
"
)
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
)
{
favicon
.
src
=
this
.
_iconForResult
(
result
)
;
}
else
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
DEFAULT
;
}
let
title
=
item
.
_elements
.
get
(
"
title
"
)
;
this
.
_setResultTitle
(
result
title
)
;
if
(
result
.
payload
.
tail
&
&
result
.
payload
.
tailOffsetIndex
>
0
)
{
this
.
_fillTailSuggestionPrefix
(
item
result
)
;
title
.
setAttribute
(
"
aria
-
label
"
result
.
payload
.
suggestion
)
;
item
.
toggleAttribute
(
"
tail
-
suggestion
"
true
)
;
}
else
{
item
.
removeAttribute
(
"
tail
-
suggestion
"
)
;
title
.
removeAttribute
(
"
aria
-
label
"
)
;
}
title
.
_tooltip
=
result
.
title
;
if
(
title
.
hasAttribute
(
"
overflow
"
)
)
{
title
.
setAttribute
(
"
title
"
title
.
_tooltip
)
;
}
let
tagsContainer
=
item
.
_elements
.
get
(
"
tagsContainer
"
)
;
tagsContainer
.
textContent
=
"
"
;
if
(
result
.
payload
.
tags
&
&
result
.
payload
.
tags
.
length
)
{
tagsContainer
.
append
(
.
.
.
result
.
payload
.
tags
.
map
(
(
tag
i
)
=
>
{
const
element
=
this
.
_createElement
(
"
span
"
)
;
element
.
className
=
"
urlbarView
-
tag
"
;
this
.
_addTextContentWithHighlights
(
element
tag
result
.
payloadHighlights
.
tags
[
i
]
)
;
return
element
;
}
)
)
;
}
let
action
=
item
.
_elements
.
get
(
"
action
"
)
;
let
actionSetter
=
null
;
let
isVisitAction
=
false
;
let
setURL
=
false
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
actionSetter
=
(
)
=
>
{
this
.
document
.
l10n
.
setAttributes
(
action
"
urlbar
-
result
-
action
-
switch
-
tab
"
)
;
}
;
setURL
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
actionSetter
=
(
)
=
>
{
action
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
action
.
textContent
=
result
.
payload
.
device
;
}
;
setURL
=
true
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
if
(
result
.
payload
.
inPrivateWindow
)
{
if
(
result
.
payload
.
isPrivateEngine
)
{
actionSetter
=
(
)
=
>
{
this
.
document
.
l10n
.
setAttributes
(
action
"
urlbar
-
result
-
action
-
search
-
in
-
private
-
w
-
engine
"
{
engine
:
result
.
payload
.
engine
}
)
;
}
;
}
else
{
actionSetter
=
(
)
=
>
{
this
.
document
.
l10n
.
setAttributes
(
action
"
urlbar
-
result
-
action
-
search
-
in
-
private
"
)
;
}
;
}
}
else
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
actionSetter
=
(
)
=
>
{
this
.
document
.
l10n
.
setAttributes
(
action
result
.
payload
.
isGeneralPurposeEngine
?
"
urlbar
-
result
-
action
-
tabtosearch
-
web
"
:
"
urlbar
-
result
-
action
-
tabtosearch
-
other
-
engine
"
{
engine
:
result
.
payload
.
engine
}
)
;
}
;
}
else
if
(
!
result
.
payload
.
providesSearchMode
)
{
actionSetter
=
(
)
=
>
{
this
.
document
.
l10n
.
setAttributes
(
action
"
urlbar
-
result
-
action
-
search
-
w
-
engine
"
{
engine
:
result
.
payload
.
engine
}
)
;
}
;
}
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
isVisitAction
=
result
.
payload
.
input
.
trim
(
)
=
=
result
.
payload
.
keyword
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
actionSetter
=
(
)
=
>
{
action
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
action
.
textContent
=
result
.
payload
.
content
;
}
;
break
;
default
:
if
(
result
.
heuristic
)
{
isVisitAction
=
true
;
}
else
if
(
result
.
providerName
!
=
"
UrlbarProviderQuickSuggest
"
)
{
setURL
=
true
;
}
break
;
}
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
action
.
toggleAttribute
(
"
slide
-
in
"
true
)
;
}
else
{
action
.
removeAttribute
(
"
slide
-
in
"
)
;
}
if
(
result
.
payload
.
isPinned
)
{
item
.
toggleAttribute
(
"
pinned
"
true
)
;
}
else
{
item
.
removeAttribute
(
"
pinned
"
)
;
}
if
(
result
.
payload
.
isSponsored
&
&
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
)
{
item
.
toggleAttribute
(
"
sponsored
"
true
)
;
actionSetter
=
(
)
=
>
{
this
.
_setElementL10n
(
action
{
id
:
"
urlbar
-
result
-
action
-
sponsored
"
}
)
;
}
;
}
else
{
item
.
removeAttribute
(
"
sponsored
"
)
;
}
if
(
result
.
providerName
=
=
"
UrlbarProviderQuickSuggest
"
&
&
result
.
payload
.
isSponsored
)
{
item
.
toggleAttribute
(
"
firefox
-
suggest
-
sponsored
"
true
)
;
}
else
{
item
.
removeAttribute
(
"
firefox
-
suggest
-
sponsored
"
)
;
}
let
url
=
item
.
_elements
.
get
(
"
url
"
)
;
if
(
setURL
)
{
item
.
setAttribute
(
"
has
-
url
"
"
true
"
)
;
this
.
_addTextContentWithHighlights
(
url
result
.
payload
.
displayUrl
result
.
payloadHighlights
.
displayUrl
|
|
[
]
)
;
url
.
_tooltip
=
result
.
payload
.
displayUrl
;
}
else
{
item
.
removeAttribute
(
"
has
-
url
"
)
;
url
.
textContent
=
"
"
;
url
.
_tooltip
=
"
"
;
}
if
(
url
.
hasAttribute
(
"
overflow
"
)
)
{
url
.
setAttribute
(
"
title
"
url
.
_tooltip
)
;
}
if
(
isVisitAction
)
{
actionSetter
=
(
)
=
>
{
this
.
document
.
l10n
.
setAttributes
(
action
"
urlbar
-
result
-
action
-
visit
"
)
;
}
;
title
.
setAttribute
(
"
isurl
"
"
true
"
)
;
}
else
{
title
.
removeAttribute
(
"
isurl
"
)
;
}
if
(
actionSetter
)
{
actionSetter
(
)
;
item
.
_originalActionSetter
=
actionSetter
;
item
.
setAttribute
(
"
has
-
action
"
"
true
"
)
;
}
else
{
item
.
_originalActionSetter
=
(
)
=
>
{
action
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
action
.
textContent
=
"
"
;
}
;
item
.
_originalActionSetter
(
)
;
item
.
removeAttribute
(
"
has
-
action
"
)
;
}
if
(
!
title
.
hasAttribute
(
"
isurl
"
)
)
{
title
.
setAttribute
(
"
dir
"
"
auto
"
)
;
}
else
{
title
.
removeAttribute
(
"
dir
"
)
;
}
if
(
item
.
_elements
.
has
(
"
helpButton
"
)
)
{
item
.
setAttribute
(
"
has
-
help
"
"
true
"
)
;
let
helpButton
=
item
.
_elements
.
get
(
"
helpButton
"
)
;
helpButton
.
id
=
item
.
id
+
"
-
help
"
;
}
else
{
item
.
removeAttribute
(
"
has
-
help
"
)
;
}
}
_iconForResult
(
result
iconUrlOverride
=
null
)
{
return
(
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
)
&
&
UrlbarUtils
.
ICON
.
HISTORY
)
|
|
iconUrlOverride
|
|
result
.
payload
.
icon
|
|
(
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
)
&
&
UrlbarUtils
.
ICON
.
SEARCH_GLASS
)
|
|
UrlbarUtils
.
ICON
.
DEFAULT
)
;
}
_updateRowForTip
(
item
result
)
{
let
favicon
=
item
.
_elements
.
get
(
"
favicon
"
)
;
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
TIP
;
favicon
.
id
=
item
.
id
+
"
-
icon
"
;
let
title
=
item
.
_elements
.
get
(
"
title
"
)
;
title
.
id
=
item
.
id
+
"
-
title
"
;
if
(
result
.
payload
.
textData
)
{
this
.
document
.
l10n
.
setAttributes
(
title
result
.
payload
.
textData
.
id
result
.
payload
.
textData
.
args
)
;
}
else
{
title
.
textContent
=
result
.
payload
.
text
;
}
item
.
_content
.
setAttribute
(
"
aria
-
labelledby
"
{
favicon
.
id
}
{
title
.
id
}
)
;
let
tipButton
=
item
.
_elements
.
get
(
"
tipButton
"
)
;
tipButton
.
id
=
item
.
id
+
"
-
tip
-
button
"
;
if
(
result
.
payload
.
buttonTextData
)
{
this
.
document
.
l10n
.
setAttributes
(
tipButton
result
.
payload
.
buttonTextData
.
id
result
.
payload
.
buttonTextData
.
args
)
;
}
else
{
tipButton
.
textContent
=
result
.
payload
.
buttonText
;
}
let
helpIcon
=
item
.
_elements
.
get
(
"
helpButton
"
)
;
helpIcon
.
id
=
item
.
id
+
"
-
tip
-
help
"
;
helpIcon
.
style
.
display
=
result
.
payload
.
helpUrl
?
"
"
:
"
none
"
;
if
(
result
.
providerName
=
=
"
UrlbarProviderSearchTips
"
)
{
this
.
window
.
A11yUtils
.
announce
(
result
.
payload
.
textData
)
;
}
}
async
_updateRowForDynamicType
(
item
result
)
{
item
.
setAttribute
(
"
dynamicType
"
result
.
payload
.
dynamicType
)
;
let
idsByName
=
new
Map
(
)
;
for
(
let
[
name
node
]
of
item
.
_elements
)
{
node
.
id
=
{
item
.
id
}
-
{
name
}
;
idsByName
.
set
(
name
node
.
id
)
;
}
for
(
let
[
payloadName
highlights
]
of
Object
.
entries
(
result
.
payloadHighlights
)
)
{
if
(
!
highlights
.
length
)
{
continue
;
}
let
nodeToHighlight
=
item
.
querySelector
(
#
{
item
.
id
}
-
{
payloadName
}
)
;
this
.
_addTextContentWithHighlights
(
nodeToHighlight
result
.
payload
[
payloadName
]
highlights
)
;
}
let
provider
=
UrlbarProvidersManager
.
getProvider
(
result
.
providerName
)
;
let
viewUpdate
=
await
provider
.
getViewUpdate
(
result
idsByName
)
;
for
(
let
[
nodeName
update
]
of
Object
.
entries
(
viewUpdate
)
)
{
let
node
=
item
.
querySelector
(
#
{
item
.
id
}
-
{
nodeName
}
)
;
for
(
let
[
attrName
value
]
of
Object
.
entries
(
update
.
attributes
|
|
{
}
)
)
{
if
(
attrName
=
=
"
id
"
)
{
Cu
.
reportError
(
"
Dynamic
results
are
prohibited
from
setting
their
own
IDs
.
"
)
;
continue
;
}
if
(
value
=
=
=
null
)
{
node
.
removeAttribute
(
attrName
)
;
}
else
{
node
.
setAttribute
(
attrName
value
)
;
}
}
for
(
let
[
styleName
value
]
of
Object
.
entries
(
update
.
style
|
|
{
}
)
)
{
node
.
style
[
styleName
]
=
value
;
}
if
(
update
.
l10n
)
{
this
.
document
.
l10n
.
setAttributes
(
node
update
.
l10n
.
id
update
.
l10n
.
args
|
|
undefined
)
;
}
else
if
(
update
.
textContent
)
{
node
.
textContent
=
update
.
textContent
;
}
}
}
_updateIndices
(
)
{
let
currentLabel
;
let
visibleRowsExist
=
false
;
for
(
let
i
=
0
;
i
<
this
.
_rows
.
children
.
length
;
i
+
+
)
{
let
item
=
this
.
_rows
.
children
[
i
]
;
item
.
result
.
rowIndex
=
i
;
let
visible
=
this
.
_isElementVisible
(
item
)
;
visibleRowsExist
=
visibleRowsExist
|
|
visible
;
let
label
;
if
(
visible
)
{
label
=
this
.
_rowLabel
(
item
currentLabel
)
;
if
(
label
)
{
if
(
ObjectUtils
.
deepEqual
(
label
currentLabel
)
)
{
label
=
null
;
}
else
{
currentLabel
=
label
;
}
}
}
if
(
label
)
{
this
.
_setElementL10n
(
item
{
attribute
:
"
label
"
id
:
label
.
id
args
:
label
.
args
}
)
;
}
else
{
this
.
_removeElementL10n
(
item
{
attribute
:
"
label
"
}
)
;
}
}
let
selectableElement
=
this
.
_getFirstSelectableElement
(
)
;
let
uiIndex
=
0
;
while
(
selectableElement
)
{
selectableElement
.
elementIndex
=
uiIndex
+
+
;
selectableElement
=
this
.
_getNextSelectableElement
(
selectableElement
)
;
}
if
(
visibleRowsExist
)
{
this
.
panel
.
removeAttribute
(
"
noresults
"
)
;
}
else
{
this
.
panel
.
setAttribute
(
"
noresults
"
"
true
"
)
;
}
}
_rowLabel
(
row
currentLabel
)
{
if
(
UrlbarPrefs
.
get
(
"
groupLabels
.
enabled
"
)
&
&
this
.
_queryContext
?
.
searchString
&
&
!
row
.
result
.
heuristic
)
{
switch
(
row
.
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
return
{
id
:
"
urlbar
-
group
-
firefox
-
suggest
"
}
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
if
(
currentLabel
&
&
row
.
result
.
payload
.
suggestion
)
{
let
engineName
=
row
.
result
.
payload
.
engine
|
|
Services
.
search
.
defaultEngine
.
name
;
return
{
id
:
"
urlbar
-
group
-
search
-
suggestions
"
args
:
{
engine
:
engineName
}
}
;
}
break
;
}
}
return
null
;
}
_setRowVisibility
(
row
visible
)
{
row
.
style
.
display
=
visible
?
"
"
:
"
none
"
;
if
(
!
visible
&
&
row
.
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
&
&
row
.
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
this
.
_setElementOverflowing
(
row
.
_elements
.
get
(
"
title
"
)
false
)
;
this
.
_setElementOverflowing
(
row
.
_elements
.
get
(
"
url
"
)
false
)
;
this
.
_setElementOverflowing
(
row
.
_elements
.
get
(
"
tagsContainer
"
)
false
)
;
}
}
_isElementVisible
(
element
)
{
if
(
!
element
|
|
element
.
style
.
display
=
=
"
none
"
)
{
return
false
;
}
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
return
row
&
&
row
.
style
.
display
!
=
"
none
"
;
}
_removeStaleRows
(
)
{
let
row
=
this
.
_rows
.
lastElementChild
;
while
(
row
)
{
let
next
=
row
.
previousElementSibling
;
if
(
row
.
hasAttribute
(
"
stale
"
)
)
{
row
.
remove
(
)
;
}
else
{
this
.
_setRowVisibility
(
row
true
)
;
}
row
=
next
;
}
this
.
_updateIndices
(
)
;
}
_startRemoveStaleRowsTimer
(
)
{
this
.
_removeStaleRowsTimer
=
this
.
window
.
setTimeout
(
(
)
=
>
{
this
.
_removeStaleRowsTimer
=
null
;
this
.
_removeStaleRows
(
)
;
}
UrlbarView
.
removeStaleRowsTimeout
)
;
}
_cancelRemoveStaleRowsTimer
(
)
{
if
(
this
.
_removeStaleRowsTimer
)
{
this
.
window
.
clearTimeout
(
this
.
_removeStaleRowsTimer
)
;
this
.
_removeStaleRowsTimer
=
null
;
}
}
_selectElement
(
element
{
updateInput
=
true
setAccessibleFocus
=
true
}
=
{
}
)
{
if
(
this
.
_selectedElement
)
{
this
.
_selectedElement
.
toggleAttribute
(
"
selected
"
false
)
;
this
.
_selectedElement
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
if
(
element
)
{
element
.
toggleAttribute
(
"
selected
"
true
)
;
element
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
}
this
.
_setAccessibleFocus
(
setAccessibleFocus
&
&
element
)
;
this
.
_selectedElement
=
element
;
let
result
=
element
?
.
closest
(
"
.
urlbarView
-
row
"
)
?
.
result
;
if
(
updateInput
)
{
this
.
input
.
setValueFromResult
(
{
result
urlOverride
:
element
?
.
classList
?
.
contains
(
"
urlbarView
-
help
"
)
?
result
.
payload
.
helpUrl
:
null
}
)
;
}
else
{
this
.
input
.
setResultForCurrentValue
(
result
)
;
}
let
provider
=
UrlbarProvidersManager
.
getProvider
(
result
?
.
providerName
)
;
if
(
provider
)
{
provider
.
tryMethod
(
"
onSelection
"
result
element
)
;
}
}
_isSelectableElement
(
element
)
{
return
this
.
getClosestSelectableElement
(
element
)
=
=
element
;
}
_getFirstSelectableElement
(
)
{
let
element
=
this
.
_rows
.
firstElementChild
;
if
(
element
&
&
!
this
.
_isSelectableElement
(
element
)
)
{
element
=
this
.
_getNextSelectableElement
(
element
)
;
}
return
element
;
}
_getLastSelectableElement
(
)
{
let
row
=
this
.
_rows
.
lastElementChild
;
if
(
!
row
)
{
return
null
;
}
let
selectables
=
row
.
querySelectorAll
(
SELECTABLE_ELEMENT_SELECTOR
)
;
let
element
=
selectables
.
length
?
selectables
[
selectables
.
length
-
1
]
:
row
;
if
(
element
&
&
!
this
.
_isSelectableElement
(
element
)
)
{
element
=
this
.
_getPreviousSelectableElement
(
element
)
;
}
return
element
;
}
_getNextSelectableElement
(
element
)
{
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
if
(
!
row
)
{
return
null
;
}
let
next
=
row
.
nextElementSibling
;
let
selectables
=
[
.
.
.
row
.
querySelectorAll
(
SELECTABLE_ELEMENT_SELECTOR
)
]
;
if
(
selectables
.
length
)
{
let
index
=
selectables
.
indexOf
(
element
)
;
if
(
index
<
selectables
.
length
-
1
)
{
next
=
selectables
[
index
+
1
]
;
}
}
if
(
next
&
&
!
this
.
_isSelectableElement
(
next
)
)
{
next
=
this
.
_getNextSelectableElement
(
next
)
;
}
return
next
;
}
_getPreviousSelectableElement
(
element
)
{
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
if
(
!
row
)
{
return
null
;
}
let
previous
=
row
.
previousElementSibling
;
let
selectables
=
[
.
.
.
row
.
querySelectorAll
(
SELECTABLE_ELEMENT_SELECTOR
)
]
;
if
(
selectables
.
length
)
{
let
index
=
selectables
.
indexOf
(
element
)
;
if
(
index
<
0
)
{
previous
=
selectables
[
selectables
.
length
-
1
]
;
}
else
if
(
index
>
0
)
{
previous
=
selectables
[
index
-
1
]
;
}
}
if
(
previous
&
&
!
this
.
_isSelectableElement
(
previous
)
)
{
previous
=
this
.
_getPreviousSelectableElement
(
previous
)
;
}
return
previous
;
}
_getSelectedRow
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_selectedElement
)
{
return
null
;
}
let
selected
=
this
.
_selectedElement
;
if
(
!
selected
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
selected
=
selected
.
closest
(
"
.
urlbarView
-
row
"
)
;
}
return
selected
;
}
_getRowFromElement
(
element
)
{
if
(
!
this
.
isOpen
|
|
!
element
)
{
return
null
;
}
if
(
!
element
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
element
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
}
return
element
;
}
_setAccessibleFocus
(
item
)
{
if
(
item
)
{
this
.
input
.
inputField
.
setAttribute
(
"
aria
-
activedescendant
"
item
.
id
)
;
}
else
{
this
.
input
.
inputField
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
}
_setResultTitle
(
result
titleNode
)
{
if
(
result
.
payload
.
providesSearchMode
)
{
this
.
document
.
l10n
.
setAttributes
(
titleNode
"
urlbar
-
result
-
action
-
search
-
w
-
engine
"
{
engine
:
result
.
payload
.
engine
}
)
;
return
;
}
titleNode
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
this
.
_addTextContentWithHighlights
(
titleNode
result
.
title
result
.
titleHighlights
)
;
}
_addTextContentWithHighlights
(
parentNode
textContent
highlights
)
{
parentNode
.
textContent
=
"
"
;
if
(
!
textContent
)
{
return
;
}
highlights
=
(
highlights
|
|
[
]
)
.
concat
(
[
[
textContent
.
length
0
]
]
)
;
let
index
=
0
;
for
(
let
[
highlightIndex
highlightLength
]
of
highlights
)
{
if
(
highlightIndex
-
index
>
0
)
{
parentNode
.
appendChild
(
this
.
document
.
createTextNode
(
textContent
.
substring
(
index
highlightIndex
)
)
)
;
}
if
(
highlightLength
>
0
)
{
let
strong
=
this
.
_createElement
(
"
strong
"
)
;
strong
.
textContent
=
textContent
.
substring
(
highlightIndex
highlightIndex
+
highlightLength
)
;
parentNode
.
appendChild
(
strong
)
;
}
index
=
highlightIndex
+
highlightLength
;
}
}
_fillTailSuggestionPrefix
(
item
result
)
{
let
tailPrefixStrNode
=
item
.
_elements
.
get
(
"
tailPrefixStr
"
)
;
let
tailPrefixStr
=
result
.
payload
.
suggestion
.
substring
(
0
result
.
payload
.
tailOffsetIndex
)
;
tailPrefixStrNode
.
textContent
=
tailPrefixStr
;
let
tailPrefixCharNode
=
item
.
_elements
.
get
(
"
tailPrefixChar
"
)
;
tailPrefixCharNode
.
textContent
=
result
.
payload
.
tailPrefix
;
}
_enableOrDisableRowWrap
(
)
{
if
(
getBoundsWithoutFlushing
(
this
.
input
.
textbox
)
.
width
<
650
)
{
this
.
_rows
.
setAttribute
(
"
wrap
"
"
true
"
)
;
}
else
{
this
.
_rows
.
removeAttribute
(
"
wrap
"
)
;
}
}
_setElementOverflowing
(
element
overflowing
)
{
element
.
toggleAttribute
(
"
overflow
"
overflowing
)
;
if
(
overflowing
)
{
element
.
setAttribute
(
"
title
"
element
.
_tooltip
)
;
}
else
{
element
.
removeAttribute
(
"
title
"
)
;
}
}
_pickSearchTipIfPresent
(
event
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_queryContext
|
|
this
.
_queryContext
.
results
.
length
!
=
1
)
{
return
false
;
}
let
result
=
this
.
_queryContext
.
results
[
0
]
;
if
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
return
false
;
}
let
tipButton
=
this
.
_rows
.
firstElementChild
.
querySelector
(
"
.
urlbarView
-
tip
-
button
"
)
;
if
(
!
tipButton
)
{
throw
new
Error
(
"
Expected
a
tip
button
"
)
;
}
this
.
input
.
pickElement
(
tipButton
event
)
;
return
true
;
}
async
_cacheL10nStrings
(
)
{
let
idArgs
=
[
]
;
if
(
UrlbarPrefs
.
get
(
"
groupLabels
.
enabled
"
)
)
{
idArgs
.
push
(
{
id
:
"
urlbar
-
group
-
firefox
-
suggest
"
}
.
.
.
[
Services
.
search
.
defaultEngine
?
.
name
Services
.
search
.
defaultPrivateEngine
?
.
name
]
.
filter
(
engineName
=
>
engineName
)
.
map
(
engineName
=
>
(
{
id
:
"
urlbar
-
group
-
search
-
suggestions
"
args
:
{
engine
:
engineName
}
}
)
)
)
;
}
if
(
UrlbarPrefs
.
get
(
"
quickSuggestEnabled
"
)
)
{
idArgs
.
push
(
{
id
:
"
urlbar
-
result
-
action
-
sponsored
"
}
)
;
}
await
this
.
_l10nCache
.
ensureAll
(
idArgs
)
;
}
_setElementL10n
(
element
{
id
args
=
undefined
attribute
=
undefined
}
)
{
let
message
=
this
.
_l10nCache
.
get
(
id
args
)
;
if
(
message
)
{
if
(
attribute
)
{
element
.
setAttribute
(
attribute
message
.
attributes
[
attribute
]
)
;
}
else
{
element
.
textContent
=
message
.
value
;
}
}
else
{
if
(
attribute
)
{
element
.
setAttribute
(
"
data
-
l10n
-
attrs
"
attribute
)
;
}
this
.
document
.
l10n
.
setAttributes
(
element
id
args
)
;
}
}
_removeElementL10n
(
element
{
attribute
=
undefined
}
)
{
if
(
attribute
)
{
element
.
removeAttribute
(
attribute
)
;
element
.
removeAttribute
(
"
data
-
l10n
-
attrs
"
)
;
}
else
{
element
.
textContent
=
"
"
;
}
element
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
}
_on_SelectedOneOffButtonChanged
(
)
{
if
(
!
this
.
isOpen
|
|
!
this
.
_queryContext
)
{
return
;
}
let
engine
=
this
.
oneOffSearchButtons
.
selectedButton
?
.
engine
;
let
source
=
this
.
oneOffSearchButtons
.
selectedButton
?
.
source
;
let
localSearchMode
;
if
(
source
)
{
localSearchMode
=
UrlbarUtils
.
LOCAL_SEARCH_MODES
.
find
(
m
=
>
m
.
source
=
=
source
)
;
}
for
(
let
item
of
this
.
_rows
.
children
)
{
let
result
=
item
.
result
;
let
isPrivateSearchWithoutPrivateEngine
=
result
.
payload
.
inPrivateWindow
&
&
!
result
.
payload
.
isPrivateEngine
;
let
isSearchHistory
=
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
;
let
isSearchSuggestion
=
result
.
payload
.
suggestion
&
&
!
isSearchHistory
;
if
(
!
result
.
heuristic
&
&
!
isSearchSuggestion
&
&
!
isPrivateSearchWithoutPrivateEngine
)
{
continue
;
}
if
(
result
.
heuristic
&
&
!
engine
&
&
!
localSearchMode
&
&
this
.
input
.
searchMode
&
&
!
this
.
input
.
searchMode
.
isPreview
)
{
continue
;
}
let
action
=
item
.
querySelector
(
"
.
urlbarView
-
action
"
)
;
let
favicon
=
item
.
querySelector
(
"
.
urlbarView
-
favicon
"
)
;
let
title
=
item
.
querySelector
(
"
.
urlbarView
-
title
"
)
;
if
(
result
.
heuristic
&
&
!
this
.
selectedElement
&
&
(
localSearchMode
|
|
engine
)
)
{
item
.
setAttribute
(
"
show
-
action
-
text
"
"
true
"
)
;
}
else
{
item
.
removeAttribute
(
"
show
-
action
-
text
"
)
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
)
{
if
(
engine
)
{
if
(
!
result
.
payload
.
originalEngine
)
{
result
.
payload
.
originalEngine
=
result
.
payload
.
engine
;
}
result
.
payload
.
engine
=
engine
.
name
;
}
else
if
(
result
.
payload
.
originalEngine
)
{
result
.
payload
.
engine
=
result
.
payload
.
originalEngine
;
delete
result
.
payload
.
originalEngine
;
}
}
if
(
result
.
heuristic
)
{
title
.
textContent
=
localSearchMode
|
|
engine
?
this
.
_queryContext
.
searchString
:
result
.
title
;
if
(
localSearchMode
|
|
engine
)
{
item
.
setAttribute
(
"
restyled
-
search
"
"
true
"
)
;
}
else
{
item
.
removeAttribute
(
"
restyled
-
search
"
)
;
}
}
if
(
localSearchMode
)
{
let
name
=
UrlbarUtils
.
getResultSourceName
(
localSearchMode
.
source
)
;
this
.
document
.
l10n
.
setAttributes
(
action
urlbar
-
result
-
action
-
search
-
{
name
}
)
;
if
(
result
.
heuristic
)
{
item
.
setAttribute
(
"
source
"
name
)
;
}
}
else
if
(
engine
&
&
!
result
.
payload
.
inPrivateWindow
)
{
this
.
document
.
l10n
.
setAttributes
(
action
"
urlbar
-
result
-
action
-
search
-
w
-
engine
"
{
engine
:
engine
.
name
}
)
;
}
else
{
if
(
item
.
_originalActionSetter
)
{
item
.
_originalActionSetter
(
)
;
if
(
result
.
heuristic
)
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
DEFAULT
;
}
}
else
{
Cu
.
reportError
(
"
An
item
is
missing
the
action
setter
"
)
;
}
item
.
removeAttribute
(
"
source
"
)
;
}
let
iconOverride
=
localSearchMode
?
.
icon
|
|
engine
?
.
iconURI
?
.
spec
;
if
(
!
iconOverride
&
&
(
localSearchMode
|
|
engine
)
)
{
iconOverride
=
UrlbarUtils
.
ICON
.
SEARCH_GLASS
;
}
if
(
result
.
heuristic
|
|
(
result
.
payload
.
inPrivateWindow
&
&
!
result
.
payload
.
isPrivateEngine
)
)
{
favicon
.
src
=
this
.
_iconForResult
(
result
iconOverride
)
;
}
}
}
_on_blur
(
event
)
{
if
(
!
UrlbarPrefs
.
get
(
"
ui
.
popup
.
disable_autohide
"
)
)
{
this
.
close
(
)
;
}
}
_on_mousedown
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
let
element
=
this
.
getClosestSelectableElement
(
event
.
target
)
;
if
(
!
element
)
{
return
;
}
this
.
_selectElement
(
element
{
updateInput
:
false
}
)
;
this
.
controller
.
speculativeConnect
(
this
.
selectedResult
this
.
_queryContext
"
mousedown
"
)
;
}
_on_mouseup
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
let
element
=
this
.
getClosestSelectableElement
(
event
.
target
)
;
if
(
!
element
)
{
return
;
}
this
.
input
.
pickElement
(
element
event
)
;
}
_on_overflow
(
event
)
{
if
(
event
.
detail
=
=
1
&
&
(
event
.
target
.
classList
.
contains
(
"
urlbarView
-
url
"
)
|
|
event
.
target
.
classList
.
contains
(
"
urlbarView
-
title
"
)
|
|
event
.
target
.
classList
.
contains
(
"
urlbarView
-
tags
"
)
)
)
{
this
.
_setElementOverflowing
(
event
.
target
true
)
;
}
}
_on_underflow
(
event
)
{
if
(
event
.
detail
=
=
1
&
&
(
event
.
target
.
classList
.
contains
(
"
urlbarView
-
url
"
)
|
|
event
.
target
.
classList
.
contains
(
"
urlbarView
-
title
"
)
|
|
event
.
target
.
classList
.
contains
(
"
urlbarView
-
tags
"
)
)
)
{
this
.
_setElementOverflowing
(
event
.
target
false
)
;
}
}
_on_resize
(
)
{
this
.
_enableOrDisableRowWrap
(
)
;
}
}
UrlbarView
.
removeStaleRowsTimeout
=
DEFAULT_REMOVE_STALE_ROWS_TIMEOUT
;
class
QueryContextCache
{
constructor
(
size
)
{
this
.
size
=
size
;
this
.
_cache
=
[
]
;
}
put
(
queryContext
)
{
let
searchString
=
queryContext
.
searchString
;
if
(
!
searchString
|
|
!
queryContext
.
results
.
length
)
{
return
;
}
let
index
=
this
.
_cache
.
findIndex
(
e
=
>
e
.
searchString
=
=
searchString
)
;
if
(
index
!
=
-
1
)
{
if
(
this
.
_cache
[
index
]
=
=
queryContext
)
{
return
;
}
this
.
_cache
.
splice
(
index
1
)
;
}
if
(
this
.
_cache
.
unshift
(
queryContext
)
>
this
.
size
)
{
this
.
_cache
.
length
=
this
.
size
;
}
}
get
(
searchString
)
{
return
this
.
_cache
.
find
(
e
=
>
e
.
searchString
=
=
searchString
)
;
}
}
async
function
addDynamicStylesheet
(
window
stylesheetURL
)
{
try
{
let
uri
=
Services
.
io
.
newURI
(
stylesheetURL
)
;
let
sheet
=
await
styleSheetService
.
preloadSheetAsync
(
uri
Ci
.
nsIStyleSheetService
.
AGENT_SHEET
)
;
window
.
windowUtils
.
addSheet
(
sheet
Ci
.
nsIDOMWindowUtils
.
AGENT_SHEET
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Error
adding
dynamic
stylesheet
:
{
ex
}
)
;
}
}
function
removeDynamicStylesheet
(
window
stylesheetURL
)
{
try
{
window
.
windowUtils
.
removeSheetUsingURIString
(
stylesheetURL
Ci
.
nsIDOMWindowUtils
.
AGENT_SHEET
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Error
removing
dynamic
stylesheet
:
{
ex
}
)
;
}
}
