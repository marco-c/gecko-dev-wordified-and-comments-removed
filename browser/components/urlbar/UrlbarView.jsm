"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarView
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
bundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
autocomplete
.
properties
"
)
;
}
)
;
class
UrlbarView
{
constructor
(
input
)
{
this
.
input
=
input
;
this
.
panel
=
input
.
panel
;
this
.
controller
=
input
.
controller
;
this
.
document
=
this
.
panel
.
ownerDocument
;
this
.
window
=
this
.
document
.
defaultView
;
this
.
_mainContainer
=
this
.
panel
.
querySelector
(
"
.
urlbarView
-
body
-
inner
"
)
;
this
.
_rows
=
this
.
panel
.
querySelector
(
"
.
urlbarView
-
results
"
)
;
this
.
_rows
.
addEventListener
(
"
mouseup
"
this
)
;
this
.
_rows
.
addEventListener
(
"
mousedown
"
this
)
;
this
.
_rows
.
addEventListener
(
"
overflow
"
this
)
;
this
.
_rows
.
addEventListener
(
"
underflow
"
this
)
;
this
.
panel
.
addEventListener
(
"
popuphiding
"
this
)
;
this
.
controller
.
setView
(
this
)
;
this
.
controller
.
addQueryListener
(
this
)
;
}
get
oneOffSearchButtons
(
)
{
return
this
.
_oneOffSearchButtons
|
|
(
this
.
_oneOffSearchButtons
=
new
this
.
window
.
SearchOneOffs
(
this
.
panel
.
querySelector
(
"
.
search
-
one
-
offs
"
)
)
)
;
}
get
isOpen
(
)
{
return
this
.
panel
.
state
=
=
"
open
"
|
|
this
.
panel
.
state
=
=
"
showing
"
;
}
get
selectedResult
(
)
{
if
(
!
this
.
isOpen
)
{
return
null
;
}
let
resultIndex
=
this
.
_selected
.
getAttribute
(
"
resultIndex
"
)
;
return
this
.
_queryContext
.
results
[
resultIndex
]
;
}
selectNextItem
(
{
reverse
=
false
}
=
{
}
)
{
if
(
!
this
.
isOpen
)
{
throw
new
Error
(
"
UrlbarView
:
Cannot
select
an
item
if
the
view
isn
'
t
open
.
"
)
;
}
let
row
;
if
(
reverse
)
{
row
=
this
.
_selected
.
previousElementSibling
|
|
this
.
_rows
.
lastElementChild
;
}
else
{
row
=
this
.
_selected
.
nextElementSibling
|
|
this
.
_rows
.
firstElementChild
;
}
this
.
_selected
.
toggleAttribute
(
"
selected
"
false
)
;
this
.
_selected
=
row
;
row
.
toggleAttribute
(
"
selected
"
true
)
;
let
resultIndex
=
row
.
getAttribute
(
"
resultIndex
"
)
;
let
result
=
this
.
_queryContext
.
results
[
resultIndex
]
;
if
(
result
)
{
this
.
input
.
setValueFromResult
(
result
)
;
}
}
close
(
)
{
this
.
panel
.
hidePopup
(
)
;
}
onQueryStarted
(
queryContext
)
{
this
.
_rows
.
style
.
minHeight
=
this
.
_getBoundsWithoutFlushing
(
this
.
_rows
)
.
height
+
"
px
"
;
}
onQueryCancelled
(
queryContext
)
{
}
onQueryFinished
(
queryContext
)
{
this
.
_rows
.
style
.
minHeight
=
"
"
;
}
onQueryResults
(
queryContext
)
{
this
.
_queryContext
=
queryContext
;
let
fragment
=
this
.
document
.
createDocumentFragment
(
)
;
for
(
let
resultIndex
in
queryContext
.
results
)
{
fragment
.
appendChild
(
this
.
_createRow
(
resultIndex
)
)
;
}
if
(
queryContext
.
preselected
)
{
this
.
_selected
=
fragment
.
firstElementChild
;
this
.
_selected
.
toggleAttribute
(
"
selected
"
true
)
;
}
else
if
(
queryContext
.
lastResultCount
=
=
0
)
{
this
.
_selected
=
null
;
}
this
.
_rows
.
textContent
=
"
"
;
this
.
_rows
.
appendChild
(
fragment
)
;
this
.
_openPanel
(
)
;
}
onQueryResultRemoved
(
index
)
{
for
(
let
i
=
index
+
1
;
i
<
this
.
_rows
.
children
.
length
;
i
+
+
)
{
let
child
=
this
.
_rows
.
children
[
i
]
;
child
.
setAttribute
(
"
resultIndex
"
child
.
getAttribute
(
"
resultIndex
"
)
-
1
)
;
}
let
rowToRemove
=
this
.
_rows
.
children
[
index
]
;
rowToRemove
.
remove
(
)
;
if
(
rowToRemove
!
=
this
.
_selected
)
{
return
;
}
let
newSelectionIndex
=
index
;
if
(
index
>
=
this
.
_queryContext
.
results
.
length
)
{
newSelectionIndex
=
this
.
_queryContext
.
results
.
length
-
1
;
}
if
(
newSelectionIndex
>
=
0
)
{
this
.
_selected
=
this
.
_rows
.
children
[
newSelectionIndex
]
;
this
.
_selected
.
setAttribute
(
"
selected
"
true
)
;
}
this
.
input
.
setValueFromResult
(
this
.
_queryContext
.
results
[
newSelectionIndex
]
)
;
}
_getBoundsWithoutFlushing
(
element
)
{
return
this
.
window
.
windowUtils
.
getBoundsWithoutFlushing
(
element
)
;
}
_createElement
(
name
)
{
return
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
name
)
;
}
_openPanel
(
)
{
if
(
this
.
isOpen
)
{
return
;
}
this
.
panel
.
removeAttribute
(
"
hidden
"
)
;
this
.
_alignPanel
(
)
;
this
.
oneOffSearchButtons
;
this
.
panel
.
openPopup
(
this
.
input
.
textbox
.
closest
(
"
toolbar
"
)
"
after_end
"
0
-
1
)
;
}
_alignPanel
(
)
{
let
documentRect
=
this
.
_getBoundsWithoutFlushing
(
this
.
document
.
documentElement
)
;
let
width
=
documentRect
.
right
-
documentRect
.
left
;
this
.
panel
.
setAttribute
(
"
width
"
width
)
;
this
.
_mainContainer
.
style
.
maxWidth
=
(
width
-
2
)
+
"
px
"
;
let
boundToCheck
=
this
.
window
.
RTL_UI
?
"
right
"
:
"
left
"
;
let
inputRect
=
this
.
_getBoundsWithoutFlushing
(
this
.
input
.
textbox
)
;
let
startOffset
=
Math
.
abs
(
inputRect
[
boundToCheck
]
-
documentRect
[
boundToCheck
]
)
;
let
alignSiteIcons
=
startOffset
/
width
<
=
0
.
3
|
|
startOffset
<
=
250
;
if
(
alignSiteIcons
)
{
let
boundToCheckEnd
=
this
.
window
.
RTL_UI
?
"
left
"
:
"
right
"
;
let
endOffset
=
Math
.
abs
(
inputRect
[
boundToCheckEnd
]
-
documentRect
[
boundToCheckEnd
]
)
;
if
(
endOffset
>
startOffset
*
2
)
{
endOffset
=
startOffset
;
}
let
identityIcon
=
this
.
document
.
getElementById
(
"
identity
-
icon
"
)
;
let
identityRect
=
this
.
_getBoundsWithoutFlushing
(
identityIcon
)
;
let
start
=
this
.
window
.
RTL_UI
?
documentRect
.
right
-
identityRect
.
right
:
identityRect
.
left
;
this
.
panel
.
style
.
setProperty
(
"
-
-
item
-
padding
-
start
"
Math
.
round
(
start
)
+
"
px
"
)
;
this
.
panel
.
style
.
setProperty
(
"
-
-
item
-
padding
-
end
"
Math
.
round
(
endOffset
)
+
"
px
"
)
;
}
else
{
this
.
panel
.
style
.
removeProperty
(
"
-
-
item
-
padding
-
start
"
)
;
this
.
panel
.
style
.
removeProperty
(
"
-
-
item
-
padding
-
end
"
)
;
}
}
_createRow
(
resultIndex
)
{
let
result
=
this
.
_queryContext
.
results
[
resultIndex
]
;
let
item
=
this
.
_createElement
(
"
div
"
)
;
item
.
className
=
"
urlbarView
-
row
"
;
item
.
setAttribute
(
"
resultIndex
"
resultIndex
)
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
)
{
item
.
setAttribute
(
"
type
"
"
search
"
)
;
}
else
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
)
{
item
.
setAttribute
(
"
type
"
"
remotetab
"
)
;
}
else
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
TABS
)
{
item
.
setAttribute
(
"
type
"
"
tab
"
)
;
}
else
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
{
item
.
setAttribute
(
"
type
"
"
bookmark
"
)
;
}
let
content
=
this
.
_createElement
(
"
span
"
)
;
content
.
className
=
"
urlbarView
-
row
-
inner
"
;
item
.
appendChild
(
content
)
;
let
typeIcon
=
this
.
_createElement
(
"
span
"
)
;
typeIcon
.
className
=
"
urlbarView
-
type
-
icon
"
;
content
.
appendChild
(
typeIcon
)
;
let
favicon
=
this
.
_createElement
(
"
img
"
)
;
favicon
.
className
=
"
urlbarView
-
favicon
"
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
)
{
favicon
.
src
=
UrlbarUtils
.
ICON
.
SEARCH_GLASS
;
}
else
{
favicon
.
src
=
result
.
payload
.
icon
|
|
UrlbarUtils
.
ICON
.
DEFAULT
;
}
content
.
appendChild
(
favicon
)
;
let
title
=
this
.
_createElement
(
"
span
"
)
;
title
.
className
=
"
urlbarView
-
title
"
;
this
.
_addTextContentWithHighlights
(
title
result
.
title
result
.
titleHighlights
)
;
content
.
appendChild
(
title
)
;
if
(
result
.
payload
.
tags
&
&
result
.
payload
.
tags
.
length
>
0
)
{
const
tagsContainer
=
this
.
_createElement
(
"
div
"
)
;
tagsContainer
.
className
=
"
urlbarView
-
tags
"
;
tagsContainer
.
append
(
.
.
.
result
.
payload
.
tags
.
map
(
(
tag
i
)
=
>
{
const
element
=
this
.
_createElement
(
"
span
"
)
;
element
.
className
=
"
urlbarView
-
tag
"
;
this
.
_addTextContentWithHighlights
(
element
tag
result
.
payloadHighlights
.
tags
[
i
]
)
;
return
element
;
}
)
)
;
content
.
appendChild
(
tagsContainer
)
;
}
let
action
;
let
url
;
let
setAction
=
text
=
>
{
action
=
this
.
_createElement
(
"
span
"
)
;
action
.
className
=
"
urlbarView
-
secondary
urlbarView
-
action
"
;
action
.
textContent
=
text
;
}
;
let
setURL
=
(
)
=
>
{
url
=
this
.
_createElement
(
"
span
"
)
;
url
.
className
=
"
urlbarView
-
secondary
urlbarView
-
url
"
;
this
.
_addTextContentWithHighlights
(
url
result
.
payload
.
url
|
|
"
"
result
.
payloadHighlights
.
url
|
|
[
]
)
;
}
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
setAction
(
bundle
.
GetStringFromName
(
"
switchToTab2
"
)
)
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
setAction
(
result
.
payload
.
device
)
;
setURL
(
)
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
setAction
(
bundle
.
formatStringFromName
(
"
searchWithEngine
"
[
result
.
payload
.
engine
]
1
)
)
;
break
;
default
:
if
(
resultIndex
=
=
0
)
{
setAction
(
bundle
.
GetStringFromName
(
"
visit
"
)
)
;
}
else
{
setURL
(
)
;
}
break
;
}
if
(
action
)
{
content
.
appendChild
(
action
)
;
}
if
(
url
)
{
content
.
appendChild
(
url
)
;
}
return
item
;
}
_addTextContentWithHighlights
(
parentNode
textContent
highlights
)
{
if
(
!
textContent
)
{
return
;
}
highlights
=
(
highlights
|
|
[
]
)
.
concat
(
[
[
textContent
.
length
0
]
]
)
;
let
index
=
0
;
for
(
let
[
highlightIndex
highlightLength
]
of
highlights
)
{
if
(
highlightIndex
-
index
>
0
)
{
parentNode
.
appendChild
(
this
.
document
.
createTextNode
(
textContent
.
substring
(
index
highlightIndex
)
)
)
;
}
if
(
highlightLength
>
0
)
{
let
strong
=
this
.
_createElement
(
"
strong
"
)
;
strong
.
textContent
=
textContent
.
substring
(
highlightIndex
highlightIndex
+
highlightLength
)
;
parentNode
.
appendChild
(
strong
)
;
}
index
=
highlightIndex
+
highlightLength
;
}
}
handleEvent
(
event
)
{
let
methodName
=
"
_on_
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
new
Error
(
"
Unrecognized
UrlbarView
event
:
"
+
event
.
type
)
;
}
}
_on_mousedown
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
let
row
=
event
.
target
;
while
(
!
row
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
row
=
row
.
parentNode
;
}
let
resultIndex
=
row
.
getAttribute
(
"
resultIndex
"
)
;
if
(
this
.
_selected
)
{
this
.
_selected
.
toggleAttribute
(
"
selected
"
false
)
;
}
this
.
_selected
=
this
.
_rows
.
children
[
resultIndex
]
;
this
.
_selected
.
toggleAttribute
(
"
selected
"
true
)
;
this
.
controller
.
speculativeConnect
(
this
.
_queryContext
resultIndex
"
mousedown
"
)
;
}
_on_mouseup
(
event
)
{
if
(
event
.
button
=
=
2
)
{
return
;
}
let
row
=
event
.
target
;
while
(
!
row
.
classList
.
contains
(
"
urlbarView
-
row
"
)
)
{
row
=
row
.
parentNode
;
}
let
resultIndex
=
row
.
getAttribute
(
"
resultIndex
"
)
;
let
result
=
this
.
_queryContext
.
results
[
resultIndex
]
;
if
(
result
)
{
this
.
input
.
pickResult
(
event
result
)
;
}
}
_on_overflow
(
event
)
{
if
(
event
.
target
.
classList
.
contains
(
"
urlbarView
-
row
-
inner
"
)
)
{
event
.
target
.
toggleAttribute
(
"
overflow
"
true
)
;
}
}
_on_underflow
(
event
)
{
if
(
event
.
target
.
classList
.
contains
(
"
urlbarView
-
row
-
inner
"
)
)
{
event
.
target
.
toggleAttribute
(
"
overflow
"
false
)
;
}
}
_on_popuphiding
(
event
)
{
this
.
controller
.
cancelQuery
(
)
;
}
}
