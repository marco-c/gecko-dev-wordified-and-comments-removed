"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderSearchTips
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppMenuNotifications
:
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
jsm
"
DefaultBrowserCheck
:
"
resource
:
/
/
/
modules
/
BrowserGlue
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
ProfileAge
:
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarProviderTopSites
:
"
resource
:
/
/
/
modules
/
UrlbarProviderTopSites
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
updateManager
"
(
)
=
>
{
return
(
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
&
&
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
cfrFeaturesUserPref
"
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
features
"
true
)
;
const
TIPS
=
{
NONE
:
"
"
ONBOARD
:
"
searchTip_onboard
"
REDIRECT
:
"
searchTip_redirect
"
}
;
const
SUPPORTED_ENGINES
=
new
Map
(
[
[
"
Bing
"
{
domainPath
:
/
^
www
\
.
bing
\
.
com
\
/
/
}
]
[
"
DuckDuckGo
"
{
domainPath
:
/
^
(
start
\
.
)
?
duckduckgo
\
.
com
\
/
/
prohibitedSearchParams
:
[
"
q
"
]
}
]
[
"
Google
"
{
domainPath
:
/
^
www
\
.
google
\
.
(
com
|
ac
|
ad
|
ae
|
com
\
.
af
|
com
\
.
ag
|
com
\
.
ai
|
al
|
am
|
co
\
.
ao
|
com
\
.
ar
|
as
|
at
|
com
\
.
au
|
az
|
ba
|
com
\
.
bd
|
be
|
bf
|
bg
|
com
\
.
bh
|
bi
|
bj
|
com
\
.
bn
|
com
\
.
bo
|
com
\
.
br
|
bs
|
bt
|
co
\
.
bw
|
by
|
com
\
.
bz
|
ca
|
com
\
.
kh
|
cc
|
cd
|
cf
|
cat
|
cg
|
ch
|
ci
|
co
\
.
ck
|
cl
|
cm
|
cn
|
com
\
.
co
|
co
\
.
cr
|
com
\
.
cu
|
cv
|
com
\
.
cy
|
cz
|
de
|
dj
|
dk
|
dm
|
com
\
.
do
|
dz
|
com
\
.
ec
|
ee
|
com
\
.
eg
|
es
|
com
\
.
et
|
fi
|
com
\
.
fj
|
fm
|
fr
|
ga
|
ge
|
gf
|
gg
|
com
\
.
gh
|
com
\
.
gi
|
gl
|
gm
|
gp
|
gr
|
com
\
.
gt
|
gy
|
com
\
.
hk
|
hn
|
hr
|
ht
|
hu
|
co
\
.
id
|
iq
|
ie
|
co
\
.
il
|
im
|
co
\
.
in
|
io
|
is
|
it
|
je
|
com
\
.
jm
|
jo
|
co
\
.
jp
|
co
\
.
ke
|
ki
|
kg
|
co
\
.
kr
|
com
\
.
kw
|
kz
|
la
|
com
\
.
lb
|
com
\
.
lc
|
li
|
lk
|
co
\
.
ls
|
lt
|
lu
|
lv
|
com
\
.
ly
|
co
\
.
ma
|
md
|
me
|
mg
|
mk
|
ml
|
com
\
.
mm
|
mn
|
ms
|
com
\
.
mt
|
mu
|
mv
|
mw
|
com
\
.
mx
|
com
\
.
my
|
co
\
.
mz
|
com
\
.
na
|
ne
|
com
\
.
nf
|
com
\
.
ng
|
com
\
.
ni
|
nl
|
no
|
com
\
.
np
|
nr
|
nu
|
co
\
.
nz
|
com
\
.
om
|
com
\
.
pk
|
com
\
.
pa
|
com
\
.
pe
|
com
\
.
ph
|
pl
|
com
\
.
pg
|
pn
|
com
\
.
pr
|
ps
|
pt
|
com
\
.
py
|
com
\
.
qa
|
ro
|
rs
|
ru
|
rw
|
com
\
.
sa
|
com
\
.
sb
|
sc
|
se
|
com
\
.
sg
|
sh
|
si
|
sk
|
com
\
.
sl
|
sn
|
sm
|
so
|
st
|
sr
|
com
\
.
sv
|
td
|
tg
|
co
\
.
th
|
com
\
.
tj
|
tk
|
tl
|
tm
|
to
|
tn
|
com
\
.
tr
|
tt
|
com
\
.
tw
|
co
\
.
tz
|
com
\
.
ua
|
co
\
.
ug
|
co
\
.
uk
|
com
\
.
uy
|
co
\
.
uz
|
com
\
.
vc
|
co
\
.
ve
|
vg
|
co
\
.
vi
|
com
\
.
vn
|
vu
|
ws
|
co
\
.
za
|
co
\
.
zm
|
co
\
.
zw
)
\
/
(
webhp
)
?
/
}
]
]
)
;
const
MAX_SHOWN_COUNT
=
4
;
const
SHOW_TIP_DELAY_MS
=
200
;
const
LAST_UPDATE_THRESHOLD_MS
=
24
*
60
*
60
*
1000
;
class
ProviderSearchTips
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
this
.
disableTipsForCurrentSession
=
true
;
for
(
let
tip
of
Object
.
values
(
TIPS
)
)
{
if
(
tip
&
&
UrlbarPrefs
.
get
(
tipShownCount
.
{
tip
}
)
<
MAX_SHOWN_COUNT
)
{
this
.
disableTipsForCurrentSession
=
false
;
break
;
}
}
this
.
showedTipTypeInCurrentEngagement
=
TIPS
.
NONE
;
this
.
_seenWindows
=
new
WeakSet
(
)
;
}
get
TIP_TYPE
(
)
{
return
TIPS
;
}
get
PRIORITY
(
)
{
return
UrlbarProviderTopSites
.
PRIORITY
+
1
;
}
get
name
(
)
{
return
"
UrlbarProviderSearchTips
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
;
}
isActive
(
queryContext
)
{
return
this
.
currentTip
&
&
cfrFeaturesUserPref
;
}
getPriority
(
queryContext
)
{
return
this
.
PRIORITY
;
}
async
startQuery
(
queryContext
addCallback
)
{
let
instance
=
this
.
queryInstance
;
let
tip
=
this
.
currentTip
;
this
.
showedTipTypeInCurrentEngagement
=
this
.
currentTip
;
this
.
currentTip
=
TIPS
.
NONE
;
let
defaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
TIP
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
type
:
tip
buttonTextData
:
{
id
:
"
urlbar
-
search
-
tips
-
confirm
"
}
icon
:
defaultEngine
.
iconURI
?
.
spec
}
)
;
switch
(
tip
)
{
case
TIPS
.
ONBOARD
:
result
.
heuristic
=
true
;
result
.
payload
.
textData
=
{
id
:
"
urlbar
-
search
-
tips
-
onboard
"
args
:
{
engineName
:
defaultEngine
.
name
}
}
;
break
;
case
TIPS
.
REDIRECT
:
result
.
heuristic
=
false
;
result
.
payload
.
textData
=
{
id
:
"
urlbar
-
search
-
tips
-
redirect
-
2
"
args
:
{
engineName
:
defaultEngine
.
name
}
}
;
break
;
}
if
(
instance
!
=
this
.
queryInstance
)
{
return
;
}
Services
.
telemetry
.
keyedScalarAdd
(
"
urlbar
.
tips
"
{
tip
}
-
shown
1
)
;
addCallback
(
this
result
)
;
}
pickResult
(
result
)
{
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
window
.
gURLBar
.
value
=
"
"
;
window
.
gURLBar
.
setPageProxyState
(
"
invalid
"
)
;
window
.
gURLBar
.
removeAttribute
(
"
suppress
-
focus
-
border
"
)
;
window
.
gURLBar
.
focus
(
)
;
}
onEngagement
(
isPrivate
state
queryContext
details
)
{
if
(
this
.
showedTipTypeInCurrentEngagement
!
=
TIPS
.
NONE
&
&
state
=
=
"
engagement
"
)
{
UrlbarPrefs
.
set
(
tipShownCount
.
{
this
.
showedTipTypeInCurrentEngagement
}
MAX_SHOWN_COUNT
)
;
}
this
.
showedTipTypeInCurrentEngagement
=
TIPS
.
NONE
;
}
async
onLocationChange
(
window
uri
webProgress
flags
)
{
let
instance
=
(
this
.
_onLocationChangeInstance
=
{
}
)
;
if
(
!
this
.
_seenWindows
.
has
(
window
)
)
{
this
.
_seenWindows
.
add
(
window
)
;
await
window
.
gBrowserInit
.
firstContentWindowPaintPromise
;
if
(
instance
!
=
this
.
_onLocationChangeInstance
)
{
return
;
}
await
new
Promise
(
resolve
=
>
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
resolve
500
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
)
;
if
(
instance
!
=
this
.
_onLocationChangeInstance
)
{
return
;
}
}
if
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
|
|
!
webProgress
.
isTopLevel
)
{
return
;
}
if
(
this
.
showedTipTypeInCurrentEngagement
!
=
TIPS
.
NONE
)
{
window
.
gURLBar
.
view
.
close
(
)
;
}
if
(
!
cfrFeaturesUserPref
|
|
(
this
.
disableTipsForCurrentSession
&
&
!
UrlbarPrefs
.
get
(
"
searchTips
.
test
.
ignoreShowLimits
"
)
)
)
{
return
;
}
this
.
_maybeShowTipForUrl
(
uri
.
spec
)
.
catch
(
Cu
.
reportError
)
;
}
async
_maybeShowTipForUrl
(
urlStr
)
{
let
instance
=
{
}
;
this
.
_maybeShowTipForUrlInstance
=
instance
;
let
tip
;
let
isNewtab
=
[
"
about
:
newtab
"
"
about
:
home
"
]
.
includes
(
urlStr
)
;
let
isSearchHomepage
=
!
isNewtab
&
&
(
await
isDefaultEngineHomepage
(
urlStr
)
)
;
if
(
isNewtab
)
{
tip
=
TIPS
.
ONBOARD
;
}
else
if
(
isSearchHomepage
)
{
tip
=
TIPS
.
REDIRECT
;
}
else
{
return
;
}
let
ignoreShowLimits
=
UrlbarPrefs
.
get
(
"
searchTips
.
test
.
ignoreShowLimits
"
)
;
let
shownCount
=
UrlbarPrefs
.
get
(
tipShownCount
.
{
tip
}
)
;
if
(
shownCount
>
=
MAX_SHOWN_COUNT
&
&
!
ignoreShowLimits
)
{
return
;
}
if
(
(
await
isBrowserShowingNotification
(
)
)
&
&
!
ignoreShowLimits
)
{
return
;
}
let
date
=
await
lastBrowserUpdateDate
(
)
;
if
(
Date
.
now
(
)
-
date
<
=
LAST_UPDATE_THRESHOLD_MS
&
&
!
ignoreShowLimits
)
{
return
;
}
this
.
disableTipsForCurrentSession
=
true
;
UrlbarPrefs
.
set
(
tipShownCount
.
{
tip
}
shownCount
+
1
)
;
setTimeout
(
(
)
=
>
{
if
(
this
.
_maybeShowTipForUrlInstance
!
=
instance
)
{
return
;
}
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
window
.
gURLBar
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
invalid
"
&
&
window
.
gURLBar
.
value
!
=
"
"
)
{
return
;
}
this
.
currentTip
=
tip
;
window
.
gURLBar
.
search
(
"
"
{
focus
:
tip
=
=
TIPS
.
ONBOARD
}
)
;
}
SHOW_TIP_DELAY_MS
)
;
}
}
async
function
isBrowserShowingNotification
(
)
{
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
window
.
gURLBar
.
view
.
isOpen
|
|
window
.
gHighPriorityNotificationBox
.
currentNotification
|
|
window
.
gBrowser
.
getNotificationBox
(
)
.
currentNotification
)
{
return
true
;
}
if
(
AppMenuNotifications
.
activeNotification
&
&
!
AppMenuNotifications
.
activeNotification
.
dismissed
&
&
!
AppMenuNotifications
.
activeNotification
.
options
.
badgeOnly
)
{
return
true
;
}
if
(
[
"
tracking
-
protection
-
icon
-
container
"
"
identity
-
icon
-
box
"
"
identity
-
permission
-
box
"
]
.
some
(
id
=
>
window
.
document
.
getElementById
(
id
)
.
getAttribute
(
"
open
"
)
=
=
"
true
"
)
)
{
return
true
;
}
let
pageActions
=
window
.
document
.
getElementById
(
"
page
-
action
-
buttons
"
)
;
if
(
pageActions
)
{
for
(
let
child
of
pageActions
.
childNodes
)
{
if
(
child
.
getAttribute
(
"
open
"
)
=
=
"
true
"
)
{
return
true
;
}
}
}
let
navbar
=
window
.
document
.
getElementById
(
"
nav
-
bar
-
customization
-
target
"
)
;
for
(
let
node
of
navbar
.
querySelectorAll
(
"
toolbarbutton
"
)
)
{
if
(
node
.
getAttribute
(
"
open
"
)
=
=
"
true
"
)
{
return
true
;
}
}
const
willPrompt
=
await
DefaultBrowserCheck
.
willCheckDefaultBrowser
(
false
)
;
if
(
willPrompt
)
{
return
true
;
}
return
false
;
}
async
function
isDefaultEngineHomepage
(
urlStr
)
{
let
defaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
if
(
!
defaultEngine
)
{
return
false
;
}
let
homepageMatches
=
SUPPORTED_ENGINES
.
get
(
defaultEngine
.
name
)
;
if
(
!
homepageMatches
)
{
return
false
;
}
let
url
;
try
{
url
=
new
URL
(
urlStr
)
;
}
catch
(
e
)
{
return
false
;
}
if
(
url
.
searchParams
.
has
(
homepageMatches
.
prohibitedSearchParams
)
)
{
return
false
;
}
urlStr
=
url
.
hostname
.
concat
(
url
.
pathname
)
;
return
homepageMatches
.
domainPath
.
test
(
urlStr
)
;
}
async
function
lastBrowserUpdateDate
(
)
{
if
(
updateManager
&
&
updateManager
.
getUpdateCount
(
)
)
{
let
update
=
updateManager
.
getUpdateAt
(
0
)
;
return
update
.
installDate
;
}
let
age
=
await
ProfileAge
(
)
;
return
(
await
age
.
firstUse
)
|
|
age
.
created
;
}
var
UrlbarProviderSearchTips
=
new
ProviderSearchTips
(
)
;
