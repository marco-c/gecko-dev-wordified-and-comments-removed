"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarResult
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
JsonSchemaValidator
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
JsonSchemaValidator
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
class
UrlbarResult
{
constructor
(
resultType
resultSource
payload
payloadHighlights
=
{
}
)
{
if
(
!
Object
.
values
(
UrlbarUtils
.
RESULT_TYPE
)
.
includes
(
resultType
)
)
{
throw
new
Error
(
"
Invalid
result
type
"
)
;
}
this
.
type
=
resultType
;
if
(
!
Object
.
values
(
UrlbarUtils
.
RESULT_SOURCE
)
.
includes
(
resultSource
)
)
{
throw
new
Error
(
"
Invalid
result
source
"
)
;
}
this
.
source
=
resultSource
;
this
.
rowIndex
=
-
1
;
this
.
suggestedIndex
=
-
1
;
this
.
heuristic
=
false
;
if
(
!
payload
|
|
typeof
payload
!
=
"
object
"
)
{
throw
new
Error
(
"
Invalid
result
payload
"
)
;
}
this
.
payload
=
this
.
validatePayload
(
payload
)
;
if
(
!
payloadHighlights
|
|
typeof
payloadHighlights
!
=
"
object
"
)
{
throw
new
Error
(
"
Invalid
result
payload
highlights
"
)
;
}
this
.
payloadHighlights
=
payloadHighlights
;
for
(
let
name
in
payload
)
{
if
(
!
(
name
in
this
.
payloadHighlights
)
)
{
this
.
payloadHighlights
[
name
]
=
[
]
;
}
}
}
get
title
(
)
{
return
this
.
_titleAndHighlights
[
0
]
;
}
get
titleHighlights
(
)
{
return
this
.
_titleAndHighlights
[
1
]
;
}
get
_titleAndHighlights
(
)
{
switch
(
this
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
return
this
.
payload
.
title
?
[
this
.
payload
.
title
this
.
payloadHighlights
.
title
]
:
[
this
.
payload
.
url
|
|
"
"
this
.
payloadHighlights
.
url
|
|
[
]
]
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
switch
(
this
.
payload
.
keywordOffer
)
{
case
UrlbarUtils
.
KEYWORD_OFFER
.
SHOW
:
if
(
!
UrlbarPrefs
.
get
(
"
update2
"
)
)
{
return
[
this
.
payload
.
keyword
this
.
payloadHighlights
.
keyword
]
;
}
case
UrlbarUtils
.
KEYWORD_OFFER
.
HIDE
:
return
[
"
"
[
]
]
;
}
if
(
this
.
payload
.
tail
&
&
this
.
payload
.
tailOffsetIndex
>
=
0
)
{
return
[
this
.
payload
.
tail
this
.
payloadHighlights
.
tail
]
;
}
else
if
(
this
.
payload
.
suggestion
)
{
return
[
this
.
payload
.
suggestion
this
.
payloadHighlights
.
suggestion
]
;
}
return
[
this
.
payload
.
query
this
.
payloadHighlights
.
query
]
;
default
:
return
[
"
"
[
]
]
;
}
}
get
icon
(
)
{
return
this
.
payload
.
icon
;
}
validatePayload
(
payload
)
{
let
schema
=
UrlbarUtils
.
getPayloadSchema
(
this
.
type
)
;
if
(
!
schema
)
{
throw
new
Error
(
Unrecognized
result
type
:
{
this
.
type
}
)
;
}
let
result
=
JsonSchemaValidator
.
validate
(
payload
schema
{
allowExplicitUndefinedProperties
:
true
allowNullAsUndefinedProperties
:
true
allowExtraProperties
:
this
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
}
)
;
if
(
!
result
.
valid
)
{
throw
result
.
error
;
}
return
payload
;
}
static
payloadAndSimpleHighlights
(
tokens
payloadInfo
)
{
for
(
let
[
name
info
]
of
Object
.
entries
(
payloadInfo
)
)
{
if
(
!
Array
.
isArray
(
info
)
)
{
payloadInfo
[
name
]
=
[
info
]
;
}
}
if
(
(
!
payloadInfo
.
title
|
|
!
payloadInfo
.
title
[
0
]
)
&
&
payloadInfo
.
url
&
&
typeof
payloadInfo
.
url
[
0
]
=
=
"
string
"
)
{
payloadInfo
.
title
=
payloadInfo
.
title
|
|
[
"
"
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
;
try
{
payloadInfo
.
title
[
0
]
=
new
URL
(
payloadInfo
.
url
[
0
]
)
.
host
;
}
catch
(
e
)
{
}
}
if
(
payloadInfo
.
url
)
{
payloadInfo
.
displayUrl
=
[
.
.
.
payloadInfo
.
url
]
;
let
url
=
payloadInfo
.
displayUrl
[
0
]
;
if
(
url
&
&
UrlbarPrefs
.
get
(
"
trimURLs
"
)
)
{
url
=
BrowserUtils
.
removeSingleTrailingSlashFromURL
(
url
)
;
if
(
url
.
startsWith
(
"
https
:
/
/
"
)
)
{
url
=
url
.
substring
(
8
)
;
if
(
url
.
startsWith
(
"
www
.
"
)
)
{
url
=
url
.
substring
(
4
)
;
}
}
}
payloadInfo
.
displayUrl
[
0
]
=
Services
.
textToSubURI
.
unEscapeURIForUI
(
url
)
;
}
for
(
let
prop
of
[
"
displayUrl
"
"
title
"
]
.
filter
(
p
=
>
p
in
payloadInfo
)
)
{
payloadInfo
[
prop
]
[
0
]
=
payloadInfo
[
prop
]
[
0
]
.
substring
(
0
UrlbarUtils
.
MAX_TEXT_LENGTH
)
;
}
let
entries
=
Object
.
entries
(
payloadInfo
)
;
return
[
entries
.
reduce
(
(
payload
[
name
[
val
_
]
]
)
=
>
{
payload
[
name
]
=
val
;
return
payload
;
}
{
}
)
entries
.
reduce
(
(
highlights
[
name
[
val
highlightType
]
]
)
=
>
{
if
(
highlightType
)
{
highlights
[
name
]
=
!
Array
.
isArray
(
val
)
?
UrlbarUtils
.
getTokenMatches
(
tokens
val
|
|
"
"
highlightType
)
:
val
.
map
(
subval
=
>
UrlbarUtils
.
getTokenMatches
(
tokens
subval
highlightType
)
)
;
}
return
highlights
;
}
{
}
)
]
;
}
static
_dynamicResultTypesByName
=
new
Map
(
)
;
static
addDynamicResultType
(
name
type
=
{
}
)
{
if
(
/
[
^
a
-
z0
-
9_
-
]
/
i
.
test
(
name
)
)
{
Cu
.
reportError
(
Illegal
dynamic
type
name
:
{
name
}
)
;
return
;
}
this
.
_dynamicResultTypesByName
.
set
(
name
type
)
;
}
static
removeDynamicResultType
(
name
)
{
let
type
=
this
.
_dynamicResultTypesByName
.
get
(
name
)
;
if
(
type
)
{
this
.
_dynamicResultTypesByName
.
delete
(
name
)
;
}
}
static
getDynamicResultType
(
name
)
{
return
this
.
_dynamicResultTypesByName
.
get
(
name
)
;
}
}
