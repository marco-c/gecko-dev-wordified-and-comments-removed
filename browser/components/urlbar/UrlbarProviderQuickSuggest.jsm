"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderQuickSuggest
"
"
QUICK_SUGGEST_SOURCE
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CONTEXTUAL_SERVICES_PING_TYPES
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
PartnerLinkAttribution
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
SkippableTimer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
TaskQueue
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarQuickSuggest
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
AbortController
"
"
crypto
"
"
fetch
"
]
)
;
const
TIMESTAMP_TEMPLATE
=
"
%
YYYYMMDDHH
%
"
;
const
TIMESTAMP_LENGTH
=
10
;
const
TIMESTAMP_REGEXP
=
/
^
\
d
{
10
}
/
;
const
MERINO_ENDPOINT_PARAM_QUERY
=
"
q
"
;
const
MERINO_ENDPOINT_PARAM_CLIENT_VARIANTS
=
"
client_variants
"
;
const
MERINO_ENDPOINT_PARAM_PROVIDERS
=
"
providers
"
;
const
TELEMETRY_MERINO_LATENCY
=
"
FX_URLBAR_MERINO_LATENCY_MS
"
;
const
TELEMETRY_MERINO_RESPONSE
=
"
FX_URLBAR_MERINO_RESPONSE
"
;
const
TELEMETRY_REMOTE_SETTINGS_LATENCY
=
"
FX_URLBAR_QUICK_SUGGEST_REMOTE_SETTINGS_LATENCY_MS
"
;
const
TELEMETRY_SCALARS
=
{
BLOCK_SPONSORED
:
"
contextual
.
services
.
quicksuggest
.
block_sponsored
"
BLOCK_SPONSORED_BEST_MATCH
:
"
contextual
.
services
.
quicksuggest
.
block_sponsored_bestmatch
"
BLOCK_NONSPONSORED
:
"
contextual
.
services
.
quicksuggest
.
block_nonsponsored
"
BLOCK_NONSPONSORED_BEST_MATCH
:
"
contextual
.
services
.
quicksuggest
.
block_nonsponsored_bestmatch
"
CLICK
:
"
contextual
.
services
.
quicksuggest
.
click
"
CLICK_NONSPONSORED_BEST_MATCH
:
"
contextual
.
services
.
quicksuggest
.
click_nonsponsored_bestmatch
"
CLICK_SPONSORED_BEST_MATCH
:
"
contextual
.
services
.
quicksuggest
.
click_sponsored_bestmatch
"
HELP
:
"
contextual
.
services
.
quicksuggest
.
help
"
HELP_NONSPONSORED_BEST_MATCH
:
"
contextual
.
services
.
quicksuggest
.
help_nonsponsored_bestmatch
"
HELP_SPONSORED_BEST_MATCH
:
"
contextual
.
services
.
quicksuggest
.
help_sponsored_bestmatch
"
IMPRESSION
:
"
contextual
.
services
.
quicksuggest
.
impression
"
IMPRESSION_NONSPONSORED_BEST_MATCH
:
"
contextual
.
services
.
quicksuggest
.
impression_nonsponsored_bestmatch
"
IMPRESSION_SPONSORED_BEST_MATCH
:
"
contextual
.
services
.
quicksuggest
.
impression_sponsored_bestmatch
"
}
;
const
TELEMETRY_EVENT_CATEGORY
=
"
contextservices
.
quicksuggest
"
;
let
TELEMETRY_IMPRESSION_CAP_EXTRA_KEYS
=
{
intervalSeconds
:
"
intervalSeconds
"
startDateMs
:
"
startDate
"
count
:
"
count
"
maxCount
:
"
maxCount
"
impressionDateMs
:
"
impressionDate
"
}
;
const
QUICK_SUGGEST_SOURCE
=
{
REMOTE_SETTINGS
:
"
remote
-
settings
"
MERINO
:
"
merino
"
}
;
class
ProviderQuickSuggest
extends
UrlbarProvider
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
UrlbarQuickSuggest
.
init
(
)
;
UrlbarQuickSuggest
.
on
(
"
config
-
set
"
(
)
=
>
this
.
_validateImpressionStats
(
)
)
;
this
.
_updateFeatureState
(
)
;
NimbusFeatures
.
urlbar
.
onUpdate
(
(
)
=
>
this
.
_updateFeatureState
(
)
)
;
UrlbarPrefs
.
addObserver
(
this
)
;
}
get
name
(
)
{
return
"
UrlbarProviderQuickSuggest
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
NETWORK
;
}
get
helpUrl
(
)
{
return
(
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
firefox
-
suggest
"
)
;
}
get
bestMatchHelpUrl
(
)
{
return
this
.
helpUrl
;
}
get
timestampTemplate
(
)
{
return
TIMESTAMP_TEMPLATE
;
}
get
timestampLength
(
)
{
return
TIMESTAMP_LENGTH
;
}
get
telemetryScalars
(
)
{
return
{
.
.
.
TELEMETRY_SCALARS
}
;
}
isActive
(
queryContext
)
{
this
.
_resultFromLastQuery
=
null
;
if
(
!
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
)
|
|
(
queryContext
.
restrictSource
&
&
queryContext
.
restrictSource
!
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
)
)
{
return
false
;
}
return
(
queryContext
.
trimmedSearchString
&
&
!
queryContext
.
searchMode
&
&
!
queryContext
.
isPrivate
&
&
UrlbarPrefs
.
get
(
"
quickSuggestEnabled
"
)
&
&
(
UrlbarPrefs
.
get
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
|
|
UrlbarPrefs
.
get
(
"
suggest
.
quicksuggest
.
sponsored
"
)
|
|
UrlbarPrefs
.
get
(
"
quicksuggest
.
dataCollection
.
enabled
"
)
)
)
;
}
async
startQuery
(
queryContext
addCallback
)
{
let
instance
=
this
.
queryInstance
;
let
searchString
=
queryContext
.
searchString
.
trimStart
(
)
;
let
promises
=
[
]
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRemoteSettingsEnabled
"
)
)
{
promises
.
push
(
this
.
_fetchRemoteSettingsSuggestion
(
queryContext
searchString
)
)
;
}
if
(
UrlbarPrefs
.
get
(
"
merinoEnabled
"
)
&
&
UrlbarPrefs
.
get
(
"
quicksuggest
.
dataCollection
.
enabled
"
)
&
&
queryContext
.
allowRemoteResults
(
)
)
{
promises
.
push
(
this
.
_fetchMerinoSuggestions
(
queryContext
searchString
)
)
;
}
this
.
_resetElapsedImpressionCounters
(
)
;
let
allSuggestions
=
await
Promise
.
all
(
promises
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
;
}
allSuggestions
=
await
Promise
.
all
(
allSuggestions
.
flat
(
)
.
map
(
async
s
=
>
(
s
&
&
(
await
this
.
_canAddSuggestion
(
s
)
)
?
s
:
null
)
)
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
;
}
const
suggestion
=
allSuggestions
.
filter
(
Boolean
)
.
sort
(
(
a
b
)
=
>
b
.
score
-
a
.
score
)
[
0
]
;
if
(
!
suggestion
)
{
return
;
}
let
originalUrl
=
suggestion
.
url
;
this
.
_replaceSuggestionTemplates
(
suggestion
)
;
let
payload
=
{
originalUrl
url
:
suggestion
.
url
urlTimestampIndex
:
suggestion
.
urlTimestampIndex
icon
:
suggestion
.
icon
sponsoredImpressionUrl
:
suggestion
.
impression_url
sponsoredClickUrl
:
suggestion
.
click_url
sponsoredBlockId
:
suggestion
.
block_id
sponsoredAdvertiser
:
suggestion
.
advertiser
sponsoredIabCategory
:
suggestion
.
iab_category
isSponsored
:
suggestion
.
is_sponsored
helpUrl
:
this
.
helpUrl
helpL10nId
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
source
:
suggestion
.
source
requestId
:
suggestion
.
request_id
}
;
let
isSuggestionBestMatch
=
false
;
if
(
typeof
suggestion
.
_test_is_best_match
=
=
"
boolean
"
)
{
isSuggestionBestMatch
=
suggestion
.
_test_is_best_match
;
}
else
if
(
UrlbarQuickSuggest
.
config
.
best_match
)
{
let
{
best_match
}
=
UrlbarQuickSuggest
.
config
;
isSuggestionBestMatch
=
best_match
.
min_search_string_length
<
=
searchString
.
length
&
&
!
best_match
.
blocked_suggestion_ids
.
includes
(
suggestion
.
block_id
)
;
}
let
isResultBestMatch
=
isSuggestionBestMatch
&
&
UrlbarPrefs
.
get
(
"
bestMatchEnabled
"
)
&
&
UrlbarPrefs
.
get
(
"
suggest
.
bestmatch
"
)
;
if
(
isResultBestMatch
)
{
payload
.
title
=
[
suggestion
.
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
;
}
else
{
payload
.
title
=
suggestion
.
title
;
payload
.
qsSuggestion
=
[
suggestion
.
full_keyword
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
;
}
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
payload
)
)
;
if
(
isResultBestMatch
)
{
result
.
isBestMatch
=
true
;
result
.
suggestedIndex
=
1
;
}
else
if
(
!
isNaN
(
suggestion
.
position
)
&
&
UrlbarPrefs
.
get
(
"
quickSuggestAllowPositionInSuggestions
"
)
)
{
result
.
suggestedIndex
=
suggestion
.
position
;
}
else
{
result
.
isSuggestedIndexRelativeToGroup
=
true
;
result
.
suggestedIndex
=
UrlbarPrefs
.
get
(
suggestion
.
is_sponsored
?
"
quickSuggestSponsoredIndex
"
:
"
quickSuggestNonSponsoredIndex
"
)
;
}
addCallback
(
this
result
)
;
this
.
_resultFromLastQuery
=
result
;
if
(
UrlbarPrefs
.
get
(
"
isBestMatchExperiment
"
)
|
|
UrlbarPrefs
.
get
(
"
experimentType
"
)
=
=
=
"
best
-
match
"
)
{
if
(
isSuggestionBestMatch
&
&
(
!
UrlbarPrefs
.
get
(
"
bestMatchEnabled
"
)
|
|
UrlbarPrefs
.
get
(
"
suggest
.
bestmatch
"
)
)
)
{
UrlbarQuickSuggest
.
ensureExposureEventRecorded
(
)
;
}
}
else
if
(
UrlbarPrefs
.
get
(
"
experimentType
"
)
!
=
=
"
modal
"
)
{
UrlbarQuickSuggest
.
ensureExposureEventRecorded
(
)
;
}
}
blockResult
(
queryContext
result
)
{
if
(
(
!
result
.
isBestMatch
&
&
!
UrlbarPrefs
.
get
(
"
quickSuggestBlockingEnabled
"
)
)
|
|
(
result
.
isBestMatch
&
&
!
UrlbarPrefs
.
get
(
"
bestMatchBlockingEnabled
"
)
)
)
{
this
.
logger
.
info
(
"
Blocking
disabled
ignoring
block
"
)
;
return
false
;
}
this
.
logger
.
info
(
"
Blocking
result
:
"
+
JSON
.
stringify
(
result
)
)
;
this
.
blockSuggestion
(
result
.
payload
.
originalUrl
)
;
this
.
_recordEngagementTelemetry
(
result
queryContext
.
isPrivate
"
block
"
)
;
return
true
;
}
async
blockSuggestion
(
originalUrl
)
{
this
.
logger
.
debug
(
Queueing
blockSuggestion
:
{
originalUrl
}
)
;
await
this
.
_blockTaskQueue
.
queue
(
async
(
)
=
>
{
this
.
logger
.
info
(
Blocking
suggestion
:
{
originalUrl
}
)
;
let
digest
=
await
this
.
_getDigest
(
originalUrl
)
;
this
.
logger
.
debug
(
Got
digest
for
'
{
originalUrl
}
'
:
{
digest
}
)
;
this
.
_blockedDigests
.
add
(
digest
)
;
let
json
=
JSON
.
stringify
(
[
.
.
.
this
.
_blockedDigests
]
)
;
this
.
_updatingBlockedDigests
=
true
;
try
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
blockedDigests
"
json
)
;
}
finally
{
this
.
_updatingBlockedDigests
=
false
;
}
this
.
logger
.
debug
(
All
blocked
suggestions
:
{
json
}
)
;
}
)
;
}
async
isSuggestionBlocked
(
originalUrl
)
{
this
.
logger
.
debug
(
Queueing
isSuggestionBlocked
:
{
originalUrl
}
)
;
return
this
.
_blockTaskQueue
.
queue
(
async
(
)
=
>
{
this
.
logger
.
info
(
Getting
blocked
status
:
{
originalUrl
}
)
;
let
digest
=
await
this
.
_getDigest
(
originalUrl
)
;
this
.
logger
.
debug
(
Got
digest
for
'
{
originalUrl
}
'
:
{
digest
}
)
;
let
isBlocked
=
this
.
_blockedDigests
.
has
(
digest
)
;
this
.
logger
.
info
(
Blocked
status
for
'
{
originalUrl
}
'
:
{
isBlocked
}
)
;
return
isBlocked
;
}
)
;
}
async
clearBlockedSuggestions
(
)
{
this
.
logger
.
debug
(
Queueing
clearBlockedSuggestions
)
;
await
this
.
_blockTaskQueue
.
queue
(
(
)
=
>
{
this
.
logger
.
info
(
Clearing
all
blocked
suggestions
)
;
this
.
_blockedDigests
.
clear
(
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
blockedDigests
"
)
;
}
)
;
}
onEngagement
(
isPrivate
state
queryContext
details
)
{
if
(
!
this
.
_resultFromLastQuery
)
{
return
;
}
let
result
=
this
.
_resultFromLastQuery
;
this
.
_resultFromLastQuery
=
null
;
if
(
state
=
=
"
engagement
"
)
{
this
.
_recordEngagementTelemetry
(
result
isPrivate
details
.
selIndex
=
=
result
.
rowIndex
?
details
.
selType
:
"
"
)
;
}
}
_recordEngagementTelemetry
(
result
isPrivate
selType
)
{
this
.
_updateImpressionStats
(
result
.
payload
.
isSponsored
)
;
let
telemetryResultIndex
=
result
.
rowIndex
+
1
;
Services
.
telemetry
.
keyedScalarAdd
(
TELEMETRY_SCALARS
.
IMPRESSION
telemetryResultIndex
1
)
;
if
(
result
.
isBestMatch
)
{
Services
.
telemetry
.
keyedScalarAdd
(
result
.
payload
.
isSponsored
?
TELEMETRY_SCALARS
.
IMPRESSION_SPONSORED_BEST_MATCH
:
TELEMETRY_SCALARS
.
IMPRESSION_NONSPONSORED_BEST_MATCH
telemetryResultIndex
1
)
;
}
let
clickScalars
=
[
]
;
switch
(
selType
)
{
case
"
quicksuggest
"
:
clickScalars
.
push
(
TELEMETRY_SCALARS
.
CLICK
)
;
if
(
result
.
isBestMatch
)
{
clickScalars
.
push
(
result
.
payload
.
isSponsored
?
TELEMETRY_SCALARS
.
CLICK_SPONSORED_BEST_MATCH
:
TELEMETRY_SCALARS
.
CLICK_NONSPONSORED_BEST_MATCH
)
;
}
break
;
case
"
help
"
:
clickScalars
.
push
(
TELEMETRY_SCALARS
.
HELP
)
;
if
(
result
.
isBestMatch
)
{
clickScalars
.
push
(
result
.
payload
.
isSponsored
?
TELEMETRY_SCALARS
.
HELP_SPONSORED_BEST_MATCH
:
TELEMETRY_SCALARS
.
HELP_NONSPONSORED_BEST_MATCH
)
;
}
break
;
case
"
block
"
:
clickScalars
.
push
(
result
.
payload
.
isSponsored
?
TELEMETRY_SCALARS
.
BLOCK_SPONSORED
:
TELEMETRY_SCALARS
.
BLOCK_NONSPONSORED
)
;
if
(
result
.
isBestMatch
)
{
clickScalars
.
push
(
result
.
payload
.
isSponsored
?
TELEMETRY_SCALARS
.
BLOCK_SPONSORED_BEST_MATCH
:
TELEMETRY_SCALARS
.
BLOCK_NONSPONSORED_BEST_MATCH
)
;
}
break
;
default
:
if
(
selType
)
{
this
.
logger
.
error
(
"
Engagement
telemetry
error
unknown
selType
:
"
+
selType
)
;
}
break
;
}
for
(
let
scalar
of
clickScalars
)
{
Services
.
telemetry
.
keyedScalarAdd
(
scalar
telemetryResultIndex
1
)
;
}
let
match_type
=
result
.
isBestMatch
?
"
best
-
match
"
:
"
firefox
-
suggest
"
;
Services
.
telemetry
.
recordEvent
(
TELEMETRY_EVENT_CATEGORY
"
engagement
"
selType
=
=
"
quicksuggest
"
?
"
click
"
:
selType
|
|
"
impression_only
"
"
"
{
match_type
position
:
String
(
telemetryResultIndex
)
suggestion_type
:
result
.
payload
.
isSponsored
?
"
sponsored
"
:
"
nonsponsored
"
}
)
;
if
(
!
isPrivate
)
{
let
is_clicked
=
selType
=
=
"
quicksuggest
"
;
let
payload
=
{
match_type
advertiser
:
result
.
payload
.
sponsoredAdvertiser
.
toLocaleLowerCase
(
)
block_id
:
result
.
payload
.
sponsoredBlockId
position
:
telemetryResultIndex
request_id
:
result
.
payload
.
requestId
scenario
:
UrlbarPrefs
.
get
(
"
quicksuggest
.
scenario
"
)
}
;
PartnerLinkAttribution
.
sendContextualServicesPing
(
{
.
.
.
payload
is_clicked
reporting_url
:
result
.
payload
.
sponsoredImpressionUrl
}
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_IMPRESSION
)
;
if
(
is_clicked
)
{
PartnerLinkAttribution
.
sendContextualServicesPing
(
{
.
.
.
payload
reporting_url
:
result
.
payload
.
sponsoredClickUrl
}
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_SELECTION
)
;
}
if
(
selType
=
=
"
block
"
)
{
PartnerLinkAttribution
.
sendContextualServicesPing
(
{
.
.
.
payload
iab_category
:
result
.
payload
.
sponsoredIabCategory
}
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_BLOCK
)
;
}
}
}
onPrefChanged
(
pref
)
{
switch
(
pref
)
{
case
"
quicksuggest
.
blockedDigests
"
:
if
(
!
this
.
_updatingBlockedDigests
)
{
this
.
logger
.
info
(
"
browser
.
urlbar
.
quicksuggest
.
blockedDigests
changed
"
)
;
this
.
_loadBlockedDigests
(
)
;
}
break
;
case
"
quicksuggest
.
impressionCaps
.
stats
"
:
if
(
!
this
.
_updatingImpressionStats
)
{
this
.
logger
.
info
(
"
browser
.
urlbar
.
quicksuggest
.
impressionCaps
.
stats
changed
"
)
;
this
.
_loadImpressionStats
(
)
;
}
break
;
case
"
quicksuggest
.
dataCollection
.
enabled
"
:
if
(
!
UrlbarPrefs
.
updatingFirefoxSuggestScenario
)
{
Services
.
telemetry
.
recordEvent
(
TELEMETRY_EVENT_CATEGORY
"
data_collect_toggled
"
UrlbarPrefs
.
get
(
pref
)
?
"
enabled
"
:
"
disabled
"
)
;
}
break
;
case
"
suggest
.
quicksuggest
.
nonsponsored
"
:
if
(
!
UrlbarPrefs
.
updatingFirefoxSuggestScenario
)
{
Services
.
telemetry
.
recordEvent
(
TELEMETRY_EVENT_CATEGORY
"
enable_toggled
"
UrlbarPrefs
.
get
(
pref
)
?
"
enabled
"
:
"
disabled
"
)
;
}
break
;
case
"
suggest
.
quicksuggest
.
sponsored
"
:
if
(
!
UrlbarPrefs
.
updatingFirefoxSuggestScenario
)
{
Services
.
telemetry
.
recordEvent
(
TELEMETRY_EVENT_CATEGORY
"
sponsored_toggled
"
UrlbarPrefs
.
get
(
pref
)
?
"
enabled
"
:
"
disabled
"
)
;
}
break
;
}
}
cancelQuery
(
queryContext
)
{
this
.
_merinoTimeoutTimer
?
.
cancel
(
)
;
}
isURLEquivalentToResultURL
(
url
result
)
{
let
resultURL
=
result
.
payload
.
url
;
if
(
resultURL
.
length
!
=
url
.
length
)
{
return
false
;
}
let
{
urlTimestampIndex
}
=
result
.
payload
;
if
(
typeof
urlTimestampIndex
!
=
"
number
"
|
|
urlTimestampIndex
<
0
)
{
return
resultURL
=
=
url
;
}
if
(
resultURL
.
substring
(
0
urlTimestampIndex
)
!
=
url
.
substring
(
0
urlTimestampIndex
)
)
{
return
false
;
}
let
remainderIndex
=
urlTimestampIndex
+
TIMESTAMP_LENGTH
;
if
(
resultURL
.
substring
(
remainderIndex
)
!
=
url
.
substring
(
remainderIndex
)
)
{
return
false
;
}
let
maybeTimestamp
=
url
.
substring
(
urlTimestampIndex
urlTimestampIndex
+
TIMESTAMP_LENGTH
)
;
return
TIMESTAMP_REGEXP
.
test
(
maybeTimestamp
)
;
}
async
_fetchRemoteSettingsSuggestion
(
queryContext
searchString
)
{
let
instance
=
this
.
queryInstance
;
let
suggestion
;
TelemetryStopwatch
.
start
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
queryContext
)
;
try
{
suggestion
=
await
UrlbarQuickSuggest
.
query
(
searchString
)
;
TelemetryStopwatch
.
finish
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
queryContext
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
null
;
}
}
catch
(
error
)
{
TelemetryStopwatch
.
cancel
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
queryContext
)
;
this
.
logger
.
error
(
"
Could
not
fetch
remote
settings
suggestion
:
"
+
error
)
;
}
return
suggestion
;
}
async
_fetchMerinoSuggestions
(
queryContext
searchString
)
{
let
instance
=
this
.
queryInstance
;
let
endpointString
=
UrlbarPrefs
.
get
(
"
merino
.
endpointURL
"
)
;
if
(
!
endpointString
)
{
return
null
;
}
let
url
;
try
{
url
=
new
URL
(
endpointString
)
;
}
catch
(
error
)
{
this
.
logger
.
error
(
"
Could
not
make
Merino
endpoint
URL
:
"
+
error
)
;
return
null
;
}
url
.
searchParams
.
set
(
MERINO_ENDPOINT_PARAM_QUERY
searchString
)
;
let
clientVariants
=
UrlbarPrefs
.
get
(
"
merino
.
clientVariants
"
)
;
if
(
clientVariants
)
{
url
.
searchParams
.
set
(
MERINO_ENDPOINT_PARAM_CLIENT_VARIANTS
clientVariants
)
;
}
let
providers
=
UrlbarPrefs
.
get
(
"
merino
.
providers
"
)
;
if
(
providers
)
{
url
.
searchParams
.
set
(
MERINO_ENDPOINT_PARAM_PROVIDERS
providers
)
;
}
else
if
(
!
UrlbarPrefs
.
get
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
&
&
!
UrlbarPrefs
.
get
(
"
suggest
.
quicksuggest
.
sponsored
"
)
)
{
url
.
searchParams
.
set
(
MERINO_ENDPOINT_PARAM_PROVIDERS
"
"
)
;
}
let
responseHistogram
=
Services
.
telemetry
.
getHistogramById
(
TELEMETRY_MERINO_RESPONSE
)
;
let
maybeRecordResponse
=
category
=
>
{
responseHistogram
?
.
add
(
category
)
;
responseHistogram
=
null
;
}
;
let
timeout
=
UrlbarPrefs
.
get
(
"
merinoTimeoutMs
"
)
;
let
timer
=
(
this
.
_merinoTimeoutTimer
=
new
SkippableTimer
(
{
name
:
"
Merino
timeout
"
time
:
timeout
logger
:
this
.
logger
callback
:
(
)
=
>
{
this
.
logger
.
info
(
Merino
fetch
timed
out
(
timeout
=
{
timeout
}
ms
)
)
;
maybeRecordResponse
(
"
timeout
"
)
;
}
}
)
)
;
try
{
this
.
_merinoFetchController
?
.
abort
(
)
;
}
catch
(
error
)
{
this
.
logger
.
error
(
"
Could
not
abort
Merino
fetch
:
"
+
error
)
;
}
let
response
;
let
controller
=
(
this
.
_merinoFetchController
=
new
AbortController
(
)
)
;
TelemetryStopwatch
.
start
(
TELEMETRY_MERINO_LATENCY
queryContext
)
;
await
Promise
.
race
(
[
timer
.
promise
(
async
(
)
=
>
{
try
{
response
=
await
fetch
(
url
{
signal
:
controller
.
signal
}
)
;
TelemetryStopwatch
.
finish
(
TELEMETRY_MERINO_LATENCY
queryContext
)
;
maybeRecordResponse
(
response
.
ok
?
"
success
"
:
"
http_error
"
)
;
}
catch
(
error
)
{
TelemetryStopwatch
.
cancel
(
TELEMETRY_MERINO_LATENCY
queryContext
)
;
if
(
error
.
name
!
=
"
AbortError
"
)
{
this
.
logger
.
error
(
"
Could
not
fetch
Merino
endpoint
:
"
+
error
)
;
maybeRecordResponse
(
"
network_error
"
)
;
}
}
finally
{
timer
.
cancel
(
)
;
if
(
controller
=
=
this
.
_merinoFetchController
)
{
this
.
_merinoFetchController
=
null
;
}
}
}
)
(
)
]
)
;
if
(
timer
=
=
this
.
_merinoTimeoutTimer
)
{
this
.
_merinoTimeoutTimer
=
null
;
}
if
(
instance
!
=
this
.
queryInstance
)
{
return
null
;
}
let
body
;
try
{
body
=
await
response
?
.
json
(
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
null
;
}
}
catch
(
error
)
{
this
.
logger
.
error
(
"
Could
not
get
Merino
response
as
JSON
:
"
+
error
)
;
}
if
(
!
body
?
.
suggestions
?
.
length
)
{
return
null
;
}
let
{
suggestions
request_id
}
=
body
;
if
(
!
Array
.
isArray
(
suggestions
)
)
{
this
.
logger
.
error
(
"
Unexpected
Merino
response
:
"
+
JSON
.
stringify
(
body
)
)
;
return
null
;
}
return
suggestions
.
map
(
suggestion
=
>
(
{
.
.
.
suggestion
request_id
source
:
QUICK_SUGGEST_SOURCE
.
MERINO
}
)
)
;
}
async
_canAddSuggestion
(
suggestion
)
{
this
.
logger
.
info
(
"
Checking
if
suggestion
can
be
added
"
)
;
this
.
logger
.
debug
(
JSON
.
stringify
(
{
suggestion
}
)
)
;
if
(
(
suggestion
.
is_sponsored
&
&
!
UrlbarPrefs
.
get
(
"
suggest
.
quicksuggest
.
sponsored
"
)
)
|
|
(
!
suggestion
.
is_sponsored
&
&
!
UrlbarPrefs
.
get
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
)
)
{
this
.
logger
.
info
(
"
Suggestions
disabled
not
adding
suggestion
"
)
;
return
false
;
}
if
(
(
suggestion
.
is_sponsored
&
&
UrlbarPrefs
.
get
(
"
quickSuggestImpressionCapsSponsoredEnabled
"
)
)
|
|
(
!
suggestion
.
is_sponsored
&
&
UrlbarPrefs
.
get
(
"
quickSuggestImpressionCapsNonSponsoredEnabled
"
)
)
)
{
let
type
=
suggestion
.
is_sponsored
?
"
sponsored
"
:
"
nonsponsored
"
;
let
stats
=
this
.
_impressionStats
?
.
[
type
]
;
if
(
stats
)
{
let
hitStats
=
stats
.
filter
(
s
=
>
s
.
maxCount
<
=
s
.
count
)
;
if
(
hitStats
.
length
)
{
this
.
logger
.
info
(
"
Impression
cap
(
s
)
hit
not
adding
suggestion
"
)
;
this
.
logger
.
debug
(
JSON
.
stringify
(
{
type
hitStats
}
)
)
;
return
false
;
}
}
}
if
(
await
this
.
isSuggestionBlocked
(
suggestion
.
url
)
)
{
this
.
logger
.
info
(
"
Suggestion
blocked
not
adding
suggestion
"
)
;
return
false
;
}
this
.
logger
.
info
(
"
Suggestion
can
be
added
"
)
;
return
true
;
}
_replaceSuggestionTemplates
(
suggestion
)
{
let
now
=
new
Date
(
)
;
let
timestampParts
=
[
now
.
getFullYear
(
)
now
.
getMonth
(
)
+
1
now
.
getDate
(
)
now
.
getHours
(
)
]
;
let
timestamp
=
timestampParts
.
map
(
n
=
>
n
.
toString
(
)
.
padStart
(
2
"
0
"
)
)
.
join
(
"
"
)
;
for
(
let
key
of
[
"
url
"
"
click_url
"
]
)
{
let
value
=
suggestion
[
key
]
;
if
(
!
value
)
{
continue
;
}
let
timestampIndex
=
value
.
indexOf
(
TIMESTAMP_TEMPLATE
)
;
if
(
timestampIndex
>
=
0
)
{
if
(
key
=
=
"
url
"
)
{
suggestion
.
urlTimestampIndex
=
timestampIndex
;
}
suggestion
[
key
]
=
value
.
substring
(
0
timestampIndex
)
+
timestamp
+
value
.
substring
(
timestampIndex
+
TIMESTAMP_TEMPLATE
.
length
)
;
}
}
}
_updateImpressionStats
(
isSponsored
)
{
this
.
logger
.
info
(
"
Starting
impression
stats
update
"
)
;
this
.
logger
.
debug
(
JSON
.
stringify
(
{
isSponsored
currentStats
:
this
.
_impressionStats
impression_caps
:
UrlbarQuickSuggest
.
config
.
impression_caps
}
)
)
;
if
(
(
isSponsored
&
&
!
UrlbarPrefs
.
get
(
"
quickSuggestImpressionCapsSponsoredEnabled
"
)
)
|
|
(
!
isSponsored
&
&
!
UrlbarPrefs
.
get
(
"
quickSuggestImpressionCapsNonSponsoredEnabled
"
)
)
)
{
this
.
logger
.
info
(
"
Impression
caps
disabled
skipping
update
"
)
;
return
;
}
let
type
=
isSponsored
?
"
sponsored
"
:
"
nonsponsored
"
;
let
stats
=
this
.
_impressionStats
?
.
[
type
]
;
if
(
!
stats
)
{
this
.
logger
.
info
(
"
Impression
caps
undefined
skipping
update
"
)
;
return
;
}
for
(
let
stat
of
stats
)
{
stat
.
count
+
+
;
stat
.
impressionDateMs
=
Date
.
now
(
)
;
if
(
stat
.
count
=
=
stat
.
maxCount
)
{
this
.
logger
.
info
(
'
{
type
}
'
impression
cap
hit
)
;
this
.
logger
.
debug
(
JSON
.
stringify
(
{
type
hitStat
:
stat
}
)
)
;
this
.
_recordImpressionCapEvent
(
{
stat
eventType
:
"
hit
"
suggestionType
:
type
}
)
;
}
}
this
.
_updatingImpressionStats
=
true
;
try
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
impressionCaps
.
stats
"
JSON
.
stringify
(
this
.
_impressionStats
)
)
;
}
finally
{
this
.
_updatingImpressionStats
=
false
;
}
this
.
logger
.
info
(
"
Finished
impression
stats
update
"
)
;
this
.
logger
.
debug
(
JSON
.
stringify
(
{
newStats
:
this
.
_impressionStats
}
)
)
;
}
_loadImpressionStats
(
)
{
let
json
=
UrlbarPrefs
.
get
(
"
quicksuggest
.
impressionCaps
.
stats
"
)
;
if
(
!
json
)
{
this
.
_impressionStats
=
null
;
}
else
{
try
{
this
.
_impressionStats
=
JSON
.
parse
(
json
(
key
value
)
=
>
key
=
=
"
intervalSeconds
"
&
&
value
=
=
=
null
?
Infinity
:
value
)
;
}
catch
(
error
)
{
}
}
this
.
_validateImpressionStats
(
)
;
}
_validateImpressionStats
(
)
{
let
{
impression_caps
}
=
UrlbarQuickSuggest
.
config
;
this
.
logger
.
info
(
"
Validating
impression
stats
"
)
;
this
.
logger
.
debug
(
JSON
.
stringify
(
{
impression_caps
currentStats
:
this
.
_impressionStats
}
)
)
;
if
(
!
this
.
_impressionStats
|
|
typeof
this
.
_impressionStats
!
=
"
object
"
)
{
this
.
_impressionStats
=
{
}
;
}
for
(
let
[
type
cap
]
of
Object
.
entries
(
impression_caps
|
|
{
}
)
)
{
let
maxCapCounts
=
(
cap
.
custom
|
|
[
]
)
.
reduce
(
(
map
{
interval_s
max_count
}
)
=
>
{
map
.
set
(
interval_s
max_count
)
;
return
map
;
}
new
Map
(
)
)
;
if
(
typeof
cap
.
lifetime
=
=
"
number
"
)
{
maxCapCounts
.
set
(
Infinity
cap
.
lifetime
)
;
}
let
stats
=
this
.
_impressionStats
[
type
]
;
if
(
!
Array
.
isArray
(
stats
)
)
{
stats
=
[
]
;
this
.
_impressionStats
[
type
]
=
stats
;
}
let
orphanStats
=
[
]
;
let
maxCountInStats
=
0
;
for
(
let
i
=
0
;
i
<
stats
.
length
;
)
{
let
stat
=
stats
[
i
]
;
if
(
typeof
stat
.
intervalSeconds
!
=
"
number
"
|
|
typeof
stat
.
startDateMs
!
=
"
number
"
|
|
typeof
stat
.
count
!
=
"
number
"
|
|
typeof
stat
.
maxCount
!
=
"
number
"
|
|
typeof
stat
.
impressionDateMs
!
=
"
number
"
)
{
stats
.
splice
(
i
1
)
;
}
else
{
maxCountInStats
=
Math
.
max
(
maxCountInStats
stat
.
count
)
;
let
maxCount
=
maxCapCounts
.
get
(
stat
.
intervalSeconds
)
;
if
(
maxCount
=
=
=
undefined
)
{
stats
.
splice
(
i
1
)
;
orphanStats
.
push
(
stat
)
;
}
else
{
stat
.
maxCount
=
maxCount
;
i
+
+
;
}
}
}
for
(
let
[
intervalSeconds
maxCount
]
of
maxCapCounts
.
entries
(
)
)
{
if
(
!
stats
.
some
(
s
=
>
s
.
intervalSeconds
=
=
intervalSeconds
)
)
{
stats
.
push
(
{
maxCount
intervalSeconds
startDateMs
:
Date
.
now
(
)
count
:
0
impressionDateMs
:
0
}
)
;
}
}
for
(
let
orphan
of
orphanStats
)
{
for
(
let
stat
of
stats
)
{
if
(
orphan
.
intervalSeconds
<
=
stat
.
intervalSeconds
)
{
stat
.
count
=
Math
.
max
(
stat
.
count
orphan
.
count
)
;
stat
.
startDateMs
=
Math
.
min
(
stat
.
startDateMs
orphan
.
startDateMs
)
;
stat
.
impressionDateMs
=
Math
.
max
(
stat
.
impressionDateMs
orphan
.
impressionDateMs
)
;
}
}
}
let
lifetimeStat
=
stats
.
find
(
s
=
>
s
.
intervalSeconds
=
=
Infinity
)
;
if
(
lifetimeStat
)
{
lifetimeStat
.
count
=
maxCountInStats
;
}
stats
.
sort
(
(
a
b
)
=
>
a
.
intervalSeconds
-
b
.
intervalSeconds
)
;
}
this
.
logger
.
debug
(
JSON
.
stringify
(
{
newStats
:
this
.
_impressionStats
}
)
)
;
}
_resetElapsedImpressionCounters
(
)
{
this
.
logger
.
info
(
"
Checking
for
elapsed
impression
cap
intervals
"
)
;
this
.
logger
.
debug
(
JSON
.
stringify
(
{
currentStats
:
this
.
_impressionStats
impression_caps
:
UrlbarQuickSuggest
.
config
.
impression_caps
}
)
)
;
let
now
=
Date
.
now
(
)
;
for
(
let
[
type
stats
]
of
Object
.
entries
(
this
.
_impressionStats
)
)
{
for
(
let
stat
of
stats
)
{
let
elapsedMs
=
now
-
stat
.
startDateMs
;
let
intervalMs
=
1000
*
stat
.
intervalSeconds
;
let
elapsedIntervalCount
=
Math
.
floor
(
elapsedMs
/
intervalMs
)
;
if
(
elapsedIntervalCount
)
{
this
.
logger
.
info
(
Resetting
impression
counter
for
interval
{
stat
.
intervalSeconds
}
s
)
;
this
.
logger
.
debug
(
JSON
.
stringify
(
{
type
stat
elapsedMs
elapsedIntervalCount
}
)
)
;
let
newStartDateMs
=
stat
.
startDateMs
+
elapsedIntervalCount
*
intervalMs
;
let
startupDateMs
=
this
.
_getStartupDateMs
(
)
;
let
elapsedIntervalCountBeforeStartup
=
Math
.
floor
(
Math
.
max
(
0
startupDateMs
-
stat
.
startDateMs
)
/
intervalMs
)
;
let
elapsedIntervalCountAfterStartup
=
elapsedIntervalCount
-
elapsedIntervalCountBeforeStartup
;
if
(
elapsedIntervalCountAfterStartup
)
{
this
.
_recordImpressionCapEvent
(
{
eventType
:
"
reset
"
suggestionType
:
type
eventDateMs
:
newStartDateMs
eventCount
:
elapsedIntervalCountAfterStartup
stat
:
{
.
.
.
stat
startDateMs
:
stat
.
startDateMs
+
elapsedIntervalCountBeforeStartup
*
intervalMs
}
}
)
;
}
stat
.
startDateMs
=
newStartDateMs
;
stat
.
count
=
0
;
}
}
}
this
.
logger
.
debug
(
JSON
.
stringify
(
{
newStats
:
this
.
_impressionStats
}
)
)
;
}
_recordImpressionCapEvent
(
{
eventType
suggestionType
stat
eventCount
=
1
eventDateMs
=
Date
.
now
(
)
}
)
{
let
extra
=
{
type
:
suggestionType
eventDate
:
String
(
eventDateMs
)
eventCount
:
String
(
eventCount
)
}
;
for
(
let
[
statKey
value
]
of
Object
.
entries
(
stat
)
)
{
let
extraKey
=
TELEMETRY_IMPRESSION_CAP_EXTRA_KEYS
[
statKey
]
;
if
(
!
extraKey
)
{
throw
new
Error
(
"
Unrecognized
stats
object
key
:
"
+
statKey
)
;
}
extra
[
extraKey
]
=
String
(
value
)
;
}
Services
.
telemetry
.
recordEvent
(
TELEMETRY_EVENT_CATEGORY
"
impression_cap
"
eventType
"
"
extra
)
;
}
_getStartupDateMs
(
)
{
return
Services
.
startup
.
getStartupInfo
(
)
.
process
.
getTime
(
)
;
}
async
_loadBlockedDigests
(
)
{
this
.
logger
.
debug
(
Queueing
_loadBlockedDigests
)
;
await
this
.
_blockTaskQueue
.
queue
(
(
)
=
>
{
this
.
logger
.
info
(
Loading
blocked
suggestion
digests
)
;
let
json
=
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
;
this
.
logger
.
debug
(
browser
.
urlbar
.
quicksuggest
.
blockedDigests
value
:
{
json
}
)
;
if
(
!
json
)
{
this
.
logger
.
info
(
There
are
no
blocked
suggestion
digests
)
;
this
.
_blockedDigests
.
clear
(
)
;
}
else
{
try
{
this
.
_blockedDigests
=
new
Set
(
JSON
.
parse
(
json
)
)
;
this
.
logger
.
info
(
Successfully
loaded
blocked
suggestion
digests
)
;
}
catch
(
error
)
{
this
.
logger
.
error
(
Error
loading
blocked
suggestion
digests
:
{
error
}
)
;
}
}
}
)
;
}
async
_getDigest
(
string
)
{
let
stringArray
=
new
TextEncoder
(
)
.
encode
(
string
)
;
let
hashBuffer
=
await
crypto
.
subtle
.
digest
(
"
SHA
-
1
"
stringArray
)
;
let
hashArray
=
new
Uint8Array
(
hashBuffer
)
;
return
Array
.
from
(
hashArray
b
=
>
b
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
)
.
join
(
"
"
)
;
}
_updateFeatureState
(
)
{
let
enabled
=
UrlbarPrefs
.
get
(
"
quickSuggestEnabled
"
)
;
if
(
enabled
=
=
this
.
_quickSuggestEnabled
)
{
return
;
}
this
.
_quickSuggestEnabled
=
enabled
;
this
.
logger
.
info
(
"
Updating
feature
state
feature
enabled
:
"
+
enabled
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
TELEMETRY_EVENT_CATEGORY
enabled
)
;
if
(
enabled
)
{
this
.
_loadImpressionStats
(
)
;
this
.
_loadBlockedDigests
(
)
;
}
}
_quickSuggestEnabled
=
false
;
_resultFromLastQuery
=
null
;
_impressionStats
=
null
;
_updatingImpressionStats
=
false
;
_blockedDigests
=
new
Set
(
)
;
_blockTaskQueue
=
new
TaskQueue
(
)
;
_updatingBlockedDigests
=
false
;
}
var
UrlbarProviderQuickSuggest
=
new
ProviderQuickSuggest
(
)
;
