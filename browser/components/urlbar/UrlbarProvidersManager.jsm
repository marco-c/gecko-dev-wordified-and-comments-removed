"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProvidersManager
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
modules
/
PlacesUtils
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Places
.
Urlbar
.
ProvidersManager
"
)
)
;
var
localProviderModules
=
{
UrlbarProviderUnifiedComplete
:
"
resource
:
/
/
/
modules
/
UrlbarProviderUnifiedComplete
.
jsm
"
}
;
var
localMuxerModules
=
{
UrlbarMuxerUnifiedComplete
:
"
resource
:
/
/
/
modules
/
UrlbarMuxerUnifiedComplete
.
jsm
"
}
;
const
CHUNK_MATCHES_DELAY_MS
=
16
;
const
DEFAULT_PROVIDERS
=
[
"
UnifiedComplete
"
]
;
const
DEFAULT_MUXER
=
"
UnifiedComplete
"
;
class
ProvidersManager
{
constructor
(
)
{
this
.
providers
=
new
Map
(
)
;
for
(
let
type
of
Object
.
values
(
UrlbarUtils
.
PROVIDER_TYPE
)
)
{
this
.
providers
.
set
(
type
new
Map
(
)
)
;
}
for
(
let
[
symbol
module
]
of
Object
.
entries
(
localProviderModules
)
)
{
let
{
[
symbol
]
:
provider
}
=
ChromeUtils
.
import
(
module
{
}
)
;
this
.
registerProvider
(
provider
)
;
}
this
.
queries
=
new
Map
(
)
;
this
.
interruptLevel
=
0
;
this
.
muxers
=
new
Map
(
)
;
for
(
let
[
symbol
module
]
of
Object
.
entries
(
localMuxerModules
)
)
{
let
{
[
symbol
]
:
muxer
}
=
ChromeUtils
.
import
(
module
{
}
)
;
this
.
registerMuxer
(
muxer
)
;
}
}
registerProvider
(
provider
)
{
if
(
!
provider
|
|
!
(
provider
instanceof
UrlbarProvider
)
)
{
throw
new
Error
(
Trying
to
register
an
invalid
provider
)
;
}
if
(
!
Object
.
values
(
UrlbarUtils
.
PROVIDER_TYPE
)
.
includes
(
provider
.
type
)
)
{
throw
new
Error
(
Unknown
provider
type
{
provider
.
type
}
)
;
}
logger
.
info
(
Registering
provider
{
provider
.
name
}
)
;
this
.
providers
.
get
(
provider
.
type
)
.
set
(
provider
.
name
provider
)
;
}
unregisterProvider
(
provider
)
{
logger
.
info
(
Unregistering
provider
{
provider
.
name
}
)
;
this
.
providers
.
get
(
provider
.
type
)
.
delete
(
provider
.
name
)
;
}
registerMuxer
(
muxer
)
{
if
(
!
muxer
|
|
!
(
muxer
instanceof
UrlbarMuxer
)
)
{
throw
new
Error
(
Trying
to
register
an
invalid
muxer
)
;
}
logger
.
info
(
Registering
muxer
{
muxer
.
name
}
)
;
this
.
muxers
.
set
(
muxer
.
name
muxer
)
;
}
unregisterMuxer
(
muxer
)
{
let
muxerName
=
typeof
muxer
=
=
"
string
"
?
muxer
:
muxer
.
name
;
logger
.
info
(
Unregistering
muxer
{
muxerName
}
)
;
this
.
muxers
.
delete
(
muxerName
)
;
}
async
startQuery
(
queryContext
controller
)
{
logger
.
info
(
Query
start
{
queryContext
.
searchString
}
)
;
let
muxerName
=
queryContext
.
muxer
|
|
DEFAULT_MUXER
;
logger
.
info
(
Using
muxer
{
muxerName
}
)
;
let
muxer
=
this
.
muxers
.
get
(
muxerName
)
;
if
(
!
muxer
)
{
throw
new
Error
(
Muxer
with
name
{
muxerName
}
not
found
)
;
}
let
providers
=
queryContext
.
providers
|
|
DEFAULT_PROVIDERS
;
providers
=
filterProviders
(
this
.
providers
providers
)
;
let
query
=
new
Query
(
queryContext
controller
muxer
providers
)
;
this
.
queries
.
set
(
queryContext
query
)
;
await
query
.
start
(
)
;
}
cancelQuery
(
queryContext
)
{
logger
.
info
(
Query
cancel
{
queryContext
.
searchString
}
)
;
let
query
=
this
.
queries
.
get
(
queryContext
)
;
if
(
!
query
)
{
throw
new
Error
(
"
Couldn
'
t
find
a
matching
query
for
the
given
context
"
)
;
}
query
.
cancel
(
)
;
if
(
!
this
.
interruptLevel
)
{
try
{
let
db
=
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
db
.
interrupt
(
)
;
}
catch
(
ex
)
{
}
}
this
.
queries
.
delete
(
queryContext
)
;
}
async
runInCriticalSection
(
taskFn
)
{
this
.
interruptLevel
+
+
;
try
{
await
taskFn
(
)
;
}
finally
{
this
.
interruptLevel
-
-
;
}
}
}
var
UrlbarProvidersManager
=
new
ProvidersManager
(
)
;
class
Query
{
constructor
(
queryContext
controller
muxer
providers
)
{
this
.
context
=
queryContext
;
this
.
context
.
results
=
[
]
;
this
.
muxer
=
muxer
;
this
.
controller
=
controller
;
this
.
providers
=
providers
;
this
.
started
=
false
;
this
.
canceled
=
false
;
this
.
complete
=
false
;
this
.
acceptableSources
=
[
]
;
}
async
start
(
)
{
if
(
this
.
started
)
{
throw
new
Error
(
"
This
Query
has
been
started
already
"
)
;
}
this
.
started
=
true
;
UrlbarTokenizer
.
tokenize
(
this
.
context
)
;
this
.
acceptableSources
=
getAcceptableMatchSources
(
this
.
context
)
;
logger
.
debug
(
Acceptable
sources
{
this
.
acceptableSources
}
)
;
let
promises
=
[
]
;
for
(
let
provider
of
this
.
providers
.
get
(
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
)
.
values
(
)
)
{
if
(
this
.
canceled
)
{
break
;
}
if
(
this
.
_providerHasAcceptableSources
(
provider
)
)
{
promises
.
push
(
provider
.
startQuery
(
this
.
context
this
.
add
.
bind
(
this
)
)
)
;
}
}
this
.
_sleepTimer
=
new
SkippableTimer
(
(
)
=
>
{
}
UrlbarPrefs
.
get
(
"
delay
"
)
)
;
await
this
.
_sleepTimer
.
promise
;
for
(
let
providerType
of
[
UrlbarUtils
.
PROVIDER_TYPE
.
NETWORK
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
]
)
{
for
(
let
provider
of
this
.
providers
.
get
(
providerType
)
.
values
(
)
)
{
if
(
this
.
canceled
)
{
break
;
}
if
(
this
.
_providerHasAcceptableSources
(
provider
)
)
{
promises
.
push
(
provider
.
startQuery
(
this
.
context
this
.
add
.
bind
(
this
)
)
)
;
}
}
}
logger
.
info
(
Queried
{
promises
.
length
}
providers
)
;
if
(
promises
.
length
)
{
await
Promise
.
all
(
promises
.
map
(
p
=
>
p
.
catch
(
Cu
.
reportError
)
)
)
;
if
(
this
.
_chunkTimer
)
{
await
this
.
_chunkTimer
.
fire
(
)
;
}
}
this
.
complete
=
true
;
}
cancel
(
)
{
if
(
this
.
canceled
)
{
return
;
}
this
.
canceled
=
true
;
for
(
let
providers
of
this
.
providers
.
values
(
)
)
{
for
(
let
provider
of
providers
.
values
(
)
)
{
provider
.
cancelQuery
(
this
.
context
)
;
}
}
if
(
this
.
_chunkTimer
)
{
this
.
_chunkTimer
.
cancel
(
)
.
catch
(
Cu
.
reportError
)
;
}
if
(
this
.
_sleepTimer
)
{
this
.
_sleepTimer
.
fire
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
add
(
provider
match
)
{
if
(
!
(
provider
instanceof
UrlbarProvider
)
)
{
throw
new
Error
(
"
Invalid
provider
passed
to
the
add
callback
"
)
;
}
if
(
this
.
canceled
|
|
!
this
.
acceptableSources
.
includes
(
match
.
source
)
)
{
return
;
}
if
(
match
.
payload
.
url
&
&
match
.
payload
.
url
.
startsWith
(
"
javascript
:
"
)
&
&
!
this
.
context
.
searchString
.
startsWith
(
"
javascript
:
"
)
&
&
UrlbarPrefs
.
get
(
"
filter
.
javascript
"
)
)
{
return
;
}
this
.
context
.
results
.
push
(
match
)
;
let
notifyResults
=
(
)
=
>
{
if
(
this
.
_chunkTimer
)
{
this
.
_chunkTimer
.
cancel
(
)
.
catch
(
Cu
.
reportError
)
;
delete
this
.
_chunkTimer
;
}
this
.
muxer
.
sort
(
this
.
context
)
;
logger
.
debug
(
Cropping
{
this
.
context
.
results
.
length
}
matches
to
{
this
.
context
.
maxResults
}
)
;
this
.
context
.
results
=
this
.
context
.
results
.
slice
(
0
this
.
context
.
maxResults
)
;
this
.
controller
.
receiveResults
(
this
.
context
)
;
}
;
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
)
{
notifyResults
(
)
;
}
else
if
(
!
this
.
_chunkTimer
)
{
this
.
_chunkTimer
=
new
SkippableTimer
(
notifyResults
CHUNK_MATCHES_DELAY_MS
)
;
}
}
_providerHasAcceptableSources
(
provider
)
{
return
provider
.
sources
.
some
(
s
=
>
this
.
acceptableSources
.
includes
(
s
)
)
;
}
}
class
SkippableTimer
{
constructor
(
callback
time
)
{
let
timerPromise
=
new
Promise
(
resolve
=
>
{
this
.
_timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_timer
.
initWithCallback
(
(
)
=
>
{
logger
.
debug
(
Elapsed
{
time
}
ms
timer
)
;
resolve
(
)
;
}
time
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
logger
.
debug
(
Started
{
time
}
ms
timer
)
;
}
)
;
let
firePromise
=
new
Promise
(
resolve
=
>
{
this
.
fire
=
(
)
=
>
{
logger
.
debug
(
Skipped
{
time
}
ms
timer
)
;
resolve
(
)
;
return
this
.
promise
;
}
;
}
)
;
this
.
promise
=
Promise
.
race
(
[
timerPromise
firePromise
]
)
.
then
(
(
)
=
>
{
if
(
this
.
_timer
)
{
callback
(
)
;
}
}
)
;
}
cancel
(
)
{
logger
.
debug
(
Canceling
timer
for
{
this
.
_timer
.
delay
}
ms
)
;
this
.
_timer
.
cancel
(
)
;
delete
this
.
_timer
;
return
this
.
fire
(
)
;
}
}
function
getAcceptableMatchSources
(
context
)
{
let
acceptedSources
=
[
]
;
let
restrictToken
=
context
.
tokens
.
find
(
t
=
>
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
]
.
includes
(
t
.
type
)
)
;
let
restrictTokenType
=
restrictToken
?
restrictToken
.
type
:
undefined
;
for
(
let
source
of
Object
.
values
(
UrlbarUtils
.
MATCH_SOURCE
)
)
{
if
(
context
.
sources
&
&
!
context
.
sources
.
includes
(
source
)
)
{
continue
;
}
switch
(
source
)
{
case
UrlbarUtils
.
MATCH_SOURCE
.
BOOKMARKS
:
if
(
UrlbarPrefs
.
get
(
"
suggest
.
bookmark
"
)
&
&
(
!
restrictTokenType
|
|
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
|
|
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
MATCH_SOURCE
.
HISTORY
:
if
(
UrlbarPrefs
.
get
(
"
suggest
.
history
"
)
&
&
(
!
restrictTokenType
|
|
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
MATCH_SOURCE
.
SEARCH
:
if
(
UrlbarPrefs
.
get
(
"
suggest
.
searches
"
)
&
&
(
!
restrictTokenType
|
|
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
MATCH_SOURCE
.
TABS
:
if
(
UrlbarPrefs
.
get
(
"
suggest
.
openpage
"
)
&
&
(
!
restrictTokenType
|
|
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
MATCH_SOURCE
.
OTHER_NETWORK
:
if
(
!
context
.
isPrivate
&
&
!
restrictTokenType
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
MATCH_SOURCE
.
OTHER_LOCAL
:
default
:
if
(
!
restrictTokenType
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
}
}
return
acceptedSources
;
}
function
filterProviders
(
providersMap
names
)
{
let
providers
=
new
Map
(
)
;
for
(
let
[
type
providersByName
]
of
providersMap
)
{
providers
.
set
(
type
new
Map
(
)
)
;
for
(
let
name
of
Array
.
from
(
providersByName
.
keys
(
)
)
.
filter
(
n
=
>
names
.
includes
(
n
)
)
)
{
providers
.
get
(
type
)
.
set
(
name
providersByName
.
get
(
name
)
)
;
}
}
return
providers
;
}
