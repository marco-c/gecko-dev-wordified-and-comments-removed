"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProvidersManager
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
modules
/
PlacesUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Places
.
Urlbar
.
ProvidersManager
"
)
)
;
var
localProviderModules
=
{
UrlbarProviderOpenTabs
:
"
resource
:
/
/
/
modules
/
UrlbarProviderOpenTabs
.
jsm
"
}
;
const
CHUNK_MATCHES_DELAY_MS
=
16
;
class
ProvidersManager
{
constructor
(
)
{
this
.
providers
=
new
Map
(
)
;
for
(
let
type
of
Object
.
values
(
UrlbarUtils
.
PROVIDER_TYPE
)
)
{
this
.
providers
.
set
(
type
new
Map
(
)
)
;
}
for
(
let
[
symbol
module
]
of
Object
.
entries
(
localProviderModules
)
)
{
let
{
[
symbol
]
:
provider
}
=
ChromeUtils
.
import
(
module
{
}
)
;
this
.
registerProvider
(
provider
)
;
}
this
.
queries
=
new
Map
(
)
;
this
.
interruptLevel
=
0
;
}
registerProvider
(
provider
)
{
logger
.
info
(
Registering
provider
{
provider
.
name
}
)
;
if
(
!
Object
.
values
(
UrlbarUtils
.
PROVIDER_TYPE
)
.
includes
(
provider
.
type
)
)
{
throw
new
Error
(
Unknown
provider
type
{
provider
.
type
}
)
;
}
this
.
providers
.
get
(
provider
.
type
)
.
set
(
provider
.
name
provider
)
;
}
unregisterProvider
(
provider
)
{
logger
.
info
(
Unregistering
provider
{
provider
.
name
}
)
;
this
.
providers
.
get
(
provider
.
type
)
.
delete
(
provider
.
name
)
;
}
async
startQuery
(
queryContext
controller
)
{
logger
.
info
(
Query
start
{
queryContext
.
searchString
}
)
;
let
query
=
new
Query
(
queryContext
controller
this
.
providers
)
;
this
.
queries
.
set
(
queryContext
query
)
;
await
query
.
start
(
)
;
}
cancelQuery
(
queryContext
)
{
logger
.
info
(
Query
cancel
{
queryContext
.
searchString
}
)
;
let
query
=
this
.
queries
.
get
(
queryContext
)
;
if
(
!
query
)
{
throw
new
Error
(
"
Couldn
'
t
find
a
matching
query
for
the
given
context
"
)
;
}
query
.
cancel
(
)
;
if
(
!
this
.
interruptLevel
)
{
try
{
let
db
=
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
db
.
interrupt
(
)
;
}
catch
(
ex
)
{
}
}
this
.
queries
.
delete
(
queryContext
)
;
}
async
runInCriticalSection
(
taskFn
)
{
this
.
interruptLevel
+
+
;
try
{
await
taskFn
(
)
;
}
finally
{
this
.
interruptLevel
-
-
;
}
}
}
var
UrlbarProvidersManager
=
new
ProvidersManager
(
)
;
class
Query
{
constructor
(
queryContext
controller
providers
)
{
this
.
context
=
queryContext
;
this
.
context
.
results
=
[
]
;
this
.
controller
=
controller
;
this
.
providers
=
providers
;
this
.
started
=
false
;
this
.
canceled
=
false
;
this
.
complete
=
false
;
}
async
start
(
)
{
if
(
this
.
started
)
{
throw
new
Error
(
"
This
Query
has
been
started
already
"
)
;
}
this
.
started
=
true
;
UrlbarTokenizer
.
tokenize
(
this
.
context
)
;
let
promises
=
[
]
;
for
(
let
provider
of
this
.
providers
.
get
(
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
)
.
values
(
)
)
{
if
(
this
.
canceled
)
{
break
;
}
promises
.
push
(
provider
.
startQuery
(
this
.
context
this
.
add
)
)
;
}
this
.
_sleepTimer
=
new
SkippableTimer
(
(
)
=
>
{
}
UrlbarPrefs
.
get
(
"
delay
"
)
)
;
await
this
.
_sleepTimer
.
promise
;
for
(
let
providerType
of
[
UrlbarUtils
.
PROVIDER_TYPE
.
NETWORK
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
]
)
{
for
(
let
provider
of
this
.
providers
.
get
(
providerType
)
.
values
(
)
)
{
if
(
this
.
canceled
)
{
break
;
}
promises
.
push
(
provider
.
startQuery
(
this
.
context
this
.
add
.
bind
(
this
)
)
)
;
}
}
await
Promise
.
all
(
promises
.
map
(
p
=
>
p
.
catch
(
Cu
.
reportError
)
)
)
;
if
(
this
.
_chunkTimer
)
{
await
this
.
_chunkTimer
.
fire
(
)
;
}
this
.
complete
=
true
;
}
cancel
(
)
{
if
(
this
.
canceled
)
{
return
;
}
this
.
canceled
=
true
;
for
(
let
providers
of
this
.
providers
.
values
(
)
)
{
for
(
let
provider
of
providers
.
values
(
)
)
{
provider
.
cancelQuery
(
this
.
context
)
;
}
}
if
(
this
.
_chunkTimer
)
{
this
.
_chunkTimer
.
cancel
(
)
.
catch
(
Cu
.
reportError
)
;
}
if
(
this
.
_sleepTimer
)
{
this
.
_sleepTimer
.
fire
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
add
(
provider
match
)
{
if
(
this
.
canceled
)
{
return
;
}
this
.
context
.
results
.
push
(
match
)
;
let
notifyResults
=
(
)
=
>
{
if
(
this
.
_chunkTimer
)
{
this
.
_chunkTimer
.
cancel
(
)
.
catch
(
Cu
.
reportError
)
;
delete
this
.
_chunkTimer
;
}
this
.
controller
.
receiveResults
(
this
.
context
)
;
}
;
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
)
{
notifyResults
(
)
;
}
else
if
(
!
this
.
_chunkTimer
)
{
this
.
_chunkTimer
=
new
SkippableTimer
(
notifyResults
CHUNK_MATCHES_DELAY_MS
)
;
}
}
}
class
SkippableTimer
{
constructor
(
callback
time
)
{
let
timerPromise
=
new
Promise
(
resolve
=
>
{
this
.
_timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_timer
.
initWithCallback
(
(
)
=
>
{
logger
.
debug
(
Elapsed
{
time
}
ms
timer
)
;
resolve
(
)
;
}
time
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
logger
.
debug
(
Started
{
time
}
ms
timer
)
;
}
)
;
let
firePromise
=
new
Promise
(
resolve
=
>
{
this
.
fire
=
(
)
=
>
{
logger
.
debug
(
Skipped
{
time
}
ms
timer
)
;
resolve
(
)
;
return
this
.
promise
;
}
;
}
)
;
this
.
promise
=
Promise
.
race
(
[
timerPromise
firePromise
]
)
.
then
(
(
)
=
>
{
if
(
this
.
_timer
)
{
callback
(
)
;
}
}
)
;
}
cancel
(
)
{
logger
.
debug
(
Canceling
timer
for
{
this
.
_timer
.
delay
}
ms
)
;
this
.
_timer
.
cancel
(
)
;
delete
this
.
_timer
;
return
this
.
fire
(
)
;
}
}
