"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProvidersManager
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
SkippableTimer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
UrlbarUtils
.
getLogger
(
{
prefix
:
"
ProvidersManager
"
}
)
)
;
var
localProviderModules
=
{
UrlbarProviderAboutPages
:
"
resource
:
/
/
/
modules
/
UrlbarProviderAboutPages
.
jsm
"
UrlbarProviderAliasEngines
:
"
resource
:
/
/
/
modules
/
UrlbarProviderAliasEngines
.
jsm
"
UrlbarProviderAutofill
:
"
resource
:
/
/
/
modules
/
UrlbarProviderAutofill
.
jsm
"
UrlbarProviderBookmarkKeywords
:
"
resource
:
/
/
/
modules
/
UrlbarProviderBookmarkKeywords
.
jsm
"
UrlbarProviderCalculator
:
"
resource
:
/
/
/
modules
/
UrlbarProviderCalculator
.
jsm
"
UrlbarProviderHeuristicFallback
:
"
resource
:
/
/
/
modules
/
UrlbarProviderHeuristicFallback
.
jsm
"
UrlbarProviderInputHistory
:
"
resource
:
/
/
/
modules
/
UrlbarProviderInputHistory
.
jsm
"
UrlbarProviderInterventions
:
"
resource
:
/
/
/
modules
/
UrlbarProviderInterventions
.
jsm
"
UrlbarProviderOmnibox
:
"
resource
:
/
/
/
modules
/
UrlbarProviderOmnibox
.
jsm
"
UrlbarProviderPlaces
:
"
resource
:
/
/
/
modules
/
UrlbarProviderPlaces
.
jsm
"
UrlbarProviderPreloadedSites
:
"
resource
:
/
/
/
modules
/
UrlbarProviderPreloadedSites
.
jsm
"
UrlbarProviderPrivateSearch
:
"
resource
:
/
/
/
modules
/
UrlbarProviderPrivateSearch
.
jsm
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
jsm
"
UrlbarProviderRemoteTabs
:
"
resource
:
/
/
/
modules
/
UrlbarProviderRemoteTabs
.
jsm
"
UrlbarProviderSearchTips
:
"
resource
:
/
/
/
modules
/
UrlbarProviderSearchTips
.
jsm
"
UrlbarProviderSearchSuggestions
:
"
resource
:
/
/
/
modules
/
UrlbarProviderSearchSuggestions
.
jsm
"
UrlbarProviderTabToSearch
:
"
resource
:
/
/
/
modules
/
UrlbarProviderTabToSearch
.
jsm
"
UrlbarProviderTokenAliasEngines
:
"
resource
:
/
/
/
modules
/
UrlbarProviderTokenAliasEngines
.
jsm
"
UrlbarProviderTopSites
:
"
resource
:
/
/
/
modules
/
UrlbarProviderTopSites
.
jsm
"
UrlbarProviderUnitConversion
:
"
resource
:
/
/
/
modules
/
UrlbarProviderUnitConversion
.
jsm
"
}
;
var
localMuxerModules
=
{
UrlbarMuxerUnifiedComplete
:
"
resource
:
/
/
/
modules
/
UrlbarMuxerUnifiedComplete
.
jsm
"
}
;
const
CHUNK_RESULTS_DELAY_MS
=
16
;
const
DEFAULT_MUXER
=
"
UnifiedComplete
"
;
class
ProvidersManager
{
constructor
(
)
{
this
.
providers
=
[
]
;
for
(
let
[
symbol
module
]
of
Object
.
entries
(
localProviderModules
)
)
{
let
{
[
symbol
]
:
provider
}
=
ChromeUtils
.
import
(
module
)
;
this
.
registerProvider
(
provider
)
;
}
this
.
queries
=
new
Map
(
)
;
this
.
interruptLevel
=
0
;
this
.
muxers
=
new
Map
(
)
;
for
(
let
[
symbol
module
]
of
Object
.
entries
(
localMuxerModules
)
)
{
let
{
[
symbol
]
:
muxer
}
=
ChromeUtils
.
import
(
module
)
;
this
.
registerMuxer
(
muxer
)
;
}
}
registerProvider
(
provider
)
{
if
(
!
provider
|
|
!
(
provider
instanceof
UrlbarProvider
)
)
{
throw
new
Error
(
Trying
to
register
an
invalid
provider
)
;
}
if
(
!
Object
.
values
(
UrlbarUtils
.
PROVIDER_TYPE
)
.
includes
(
provider
.
type
)
)
{
throw
new
Error
(
Unknown
provider
type
{
provider
.
type
}
)
;
}
logger
.
info
(
Registering
provider
{
provider
.
name
}
)
;
let
index
=
-
1
;
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
)
{
index
=
this
.
providers
.
findIndex
(
p
=
>
p
.
type
!
=
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
)
;
}
if
(
index
<
0
)
{
index
=
this
.
providers
.
length
;
}
this
.
providers
.
splice
(
index
0
provider
)
;
}
unregisterProvider
(
provider
)
{
logger
.
info
(
Unregistering
provider
{
provider
.
name
}
)
;
let
index
=
this
.
providers
.
findIndex
(
p
=
>
p
.
name
=
=
provider
.
name
)
;
if
(
index
!
=
-
1
)
{
this
.
providers
.
splice
(
index
1
)
;
}
}
getProvider
(
name
)
{
return
this
.
providers
.
find
(
p
=
>
p
.
name
=
=
name
)
;
}
registerMuxer
(
muxer
)
{
if
(
!
muxer
|
|
!
(
muxer
instanceof
UrlbarMuxer
)
)
{
throw
new
Error
(
Trying
to
register
an
invalid
muxer
)
;
}
logger
.
info
(
Registering
muxer
{
muxer
.
name
}
)
;
this
.
muxers
.
set
(
muxer
.
name
muxer
)
;
}
unregisterMuxer
(
muxer
)
{
let
muxerName
=
typeof
muxer
=
=
"
string
"
?
muxer
:
muxer
.
name
;
logger
.
info
(
Unregistering
muxer
{
muxerName
}
)
;
this
.
muxers
.
delete
(
muxerName
)
;
}
async
startQuery
(
queryContext
controller
=
null
)
{
logger
.
info
(
Query
start
{
queryContext
.
searchString
}
)
;
let
muxerName
=
queryContext
.
muxer
|
|
DEFAULT_MUXER
;
logger
.
info
(
Using
muxer
{
muxerName
}
)
;
let
muxer
=
this
.
muxers
.
get
(
muxerName
)
;
if
(
!
muxer
)
{
throw
new
Error
(
Muxer
with
name
{
muxerName
}
not
found
)
;
}
let
providers
=
queryContext
.
providers
?
this
.
providers
.
filter
(
p
=
>
queryContext
.
providers
.
includes
(
p
.
name
)
)
:
this
.
providers
;
UrlbarTokenizer
.
tokenize
(
queryContext
)
;
if
(
queryContext
.
sources
&
&
queryContext
.
sources
.
length
=
=
1
)
{
queryContext
.
restrictSource
=
queryContext
.
sources
[
0
]
;
}
let
restrictToken
=
updateSourcesIfEmpty
(
queryContext
)
;
if
(
restrictToken
)
{
queryContext
.
restrictToken
=
restrictToken
;
if
(
UrlbarTokenizer
.
SEARCH_MODE_RESTRICT
.
has
(
restrictToken
.
value
)
)
{
queryContext
.
restrictSource
=
queryContext
.
sources
[
0
]
;
}
}
logger
.
debug
(
Context
sources
{
queryContext
.
sources
}
)
;
let
query
=
new
Query
(
queryContext
controller
muxer
providers
)
;
this
.
queries
.
set
(
queryContext
query
)
;
await
UrlbarSearchUtils
.
init
(
)
;
if
(
query
.
canceled
)
{
return
;
}
let
updateBehaviorPromises
=
[
]
;
for
(
let
provider
of
this
.
providers
)
{
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
&
&
provider
.
name
!
=
"
Omnibox
"
)
{
updateBehaviorPromises
.
push
(
provider
.
tryMethod
(
"
updateBehavior
"
queryContext
)
)
;
}
}
if
(
updateBehaviorPromises
.
length
)
{
await
Promise
.
all
(
updateBehaviorPromises
)
;
if
(
query
.
canceled
)
{
return
;
}
}
await
query
.
start
(
)
;
}
cancelQuery
(
queryContext
)
{
logger
.
info
(
Query
cancel
"
{
queryContext
.
searchString
}
"
)
;
let
query
=
this
.
queries
.
get
(
queryContext
)
;
if
(
!
query
)
{
throw
new
Error
(
"
Couldn
'
t
find
a
matching
query
for
the
given
context
"
)
;
}
query
.
cancel
(
)
;
if
(
!
this
.
interruptLevel
)
{
try
{
let
db
=
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
db
.
interrupt
(
)
;
}
catch
(
ex
)
{
}
}
this
.
queries
.
delete
(
queryContext
)
;
}
async
runInCriticalSection
(
taskFn
)
{
this
.
interruptLevel
+
+
;
try
{
await
taskFn
(
)
;
}
finally
{
this
.
interruptLevel
-
-
;
}
}
notifyEngagementChange
(
isPrivate
state
queryContext
details
)
{
for
(
let
provider
of
this
.
providers
)
{
provider
.
tryMethod
(
"
onEngagement
"
isPrivate
state
queryContext
details
)
;
}
}
}
var
UrlbarProvidersManager
=
new
ProvidersManager
(
)
;
class
Query
{
constructor
(
queryContext
controller
muxer
providers
)
{
this
.
context
=
queryContext
;
this
.
context
.
results
=
[
]
;
this
.
context
.
pendingHeuristicProviders
.
clear
(
)
;
this
.
context
.
deferUserSelectionProviders
.
clear
(
)
;
this
.
muxer
=
muxer
;
this
.
controller
=
controller
;
this
.
providers
=
providers
;
this
.
started
=
false
;
this
.
canceled
=
false
;
this
.
acceptableSources
=
queryContext
.
sources
.
slice
(
)
;
}
async
start
(
)
{
if
(
this
.
started
)
{
throw
new
Error
(
"
This
Query
has
been
started
already
"
)
;
}
this
.
started
=
true
;
let
activeProviders
=
[
]
;
let
activePromises
=
[
]
;
let
maxPriority
=
-
1
;
for
(
let
provider
of
this
.
providers
)
{
provider
.
queryInstance
=
this
;
activePromises
.
push
(
Promise
.
resolve
(
provider
.
tryMethod
(
"
isActive
"
this
.
context
)
)
.
then
(
isActive
=
>
{
if
(
isActive
&
&
!
this
.
canceled
)
{
let
priority
=
provider
.
tryMethod
(
"
getPriority
"
this
.
context
)
;
if
(
priority
>
=
maxPriority
)
{
if
(
priority
>
maxPriority
)
{
activeProviders
.
length
=
0
;
maxPriority
=
priority
;
}
activeProviders
.
push
(
provider
)
;
if
(
provider
.
deferUserSelection
)
{
this
.
context
.
deferUserSelectionProviders
.
add
(
provider
.
name
)
;
}
}
}
}
)
.
catch
(
ex
=
>
logger
.
error
(
ex
)
)
)
;
}
await
Promise
.
all
(
activePromises
)
;
if
(
this
.
canceled
)
{
this
.
controller
=
null
;
return
;
}
let
startQuery
=
async
provider
=
>
{
provider
.
logger
.
info
(
Starting
query
for
"
{
this
.
context
.
searchString
}
"
)
;
let
addedResult
=
false
;
await
provider
.
tryMethod
(
"
startQuery
"
this
.
context
(
.
.
.
args
)
=
>
{
addedResult
=
true
;
this
.
add
(
.
.
.
args
)
;
}
)
;
if
(
!
addedResult
)
{
this
.
context
.
deferUserSelectionProviders
.
delete
(
provider
.
name
)
;
}
}
;
let
queryPromises
=
[
]
;
for
(
let
provider
of
activeProviders
)
{
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
)
{
this
.
context
.
pendingHeuristicProviders
.
add
(
provider
.
name
)
;
queryPromises
.
push
(
startQuery
(
provider
)
)
;
continue
;
}
if
(
!
this
.
_sleepTimer
)
{
this
.
_sleepTimer
=
new
SkippableTimer
(
{
name
:
"
Query
provider
timer
"
time
:
UrlbarPrefs
.
get
(
"
delay
"
)
logger
:
provider
.
logger
}
)
;
}
queryPromises
.
push
(
this
.
_sleepTimer
.
promise
.
then
(
(
)
=
>
this
.
canceled
?
undefined
:
startQuery
(
provider
)
)
)
;
}
logger
.
info
(
Queried
{
queryPromises
.
length
}
providers
)
;
await
Promise
.
all
(
queryPromises
)
;
if
(
!
this
.
canceled
)
{
if
(
this
.
_heuristicProviderTimer
)
{
await
this
.
_heuristicProviderTimer
.
fire
(
)
;
}
if
(
this
.
_chunkTimer
)
{
await
this
.
_chunkTimer
.
fire
(
)
;
}
}
this
.
controller
=
null
;
}
cancel
(
)
{
if
(
this
.
canceled
)
{
return
;
}
this
.
canceled
=
true
;
this
.
context
.
deferUserSelectionProviders
.
clear
(
)
;
for
(
let
provider
of
this
.
providers
)
{
provider
.
logger
.
info
(
Canceling
query
for
"
{
this
.
context
.
searchString
}
"
)
;
provider
.
queryInstance
=
null
;
provider
.
tryMethod
(
"
cancelQuery
"
this
.
context
)
;
}
if
(
this
.
_heuristicProviderTimer
)
{
this
.
_heuristicProviderTimer
.
cancel
(
)
.
catch
(
ex
=
>
logger
.
error
(
ex
)
)
;
}
if
(
this
.
_chunkTimer
)
{
this
.
_chunkTimer
.
cancel
(
)
.
catch
(
ex
=
>
logger
.
error
(
ex
)
)
;
}
if
(
this
.
_sleepTimer
)
{
this
.
_sleepTimer
.
fire
(
)
.
catch
(
ex
=
>
logger
.
error
(
ex
)
)
;
}
}
add
(
provider
result
)
{
if
(
!
(
provider
instanceof
UrlbarProvider
)
)
{
throw
new
Error
(
"
Invalid
provider
passed
to
the
add
callback
"
)
;
}
this
.
context
.
pendingHeuristicProviders
.
delete
(
provider
.
name
)
;
if
(
this
.
canceled
)
{
return
;
}
if
(
result
.
heuristic
&
&
this
.
context
.
searchMode
&
&
(
!
this
.
context
.
trimmedSearchString
|
|
(
!
this
.
context
.
searchMode
.
engineName
&
&
!
result
.
autofill
)
)
)
{
return
;
}
if
(
!
this
.
acceptableSources
.
includes
(
result
.
source
)
&
&
!
result
.
heuristic
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
source
!
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
|
|
!
this
.
acceptableSources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
)
)
)
{
return
;
}
if
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
&
&
result
.
payload
.
url
&
&
result
.
payload
.
url
.
startsWith
(
"
javascript
:
"
)
&
&
!
this
.
context
.
searchString
.
startsWith
(
"
javascript
:
"
)
&
&
UrlbarPrefs
.
get
(
"
filter
.
javascript
"
)
)
{
return
;
}
result
.
providerName
=
provider
.
name
;
result
.
providerType
=
provider
.
type
;
this
.
context
.
results
.
push
(
result
)
;
this
.
_notifyResultsFromProvider
(
provider
)
;
}
_notifyResultsFromProvider
(
provider
)
{
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
)
{
if
(
!
this
.
_heuristicProviderTimer
)
{
this
.
_heuristicProviderTimer
=
new
SkippableTimer
(
{
name
:
"
Heuristic
provider
timer
"
callback
:
(
)
=
>
this
.
_notifyResults
(
)
time
:
CHUNK_RESULTS_DELAY_MS
logger
:
provider
.
logger
}
)
;
}
}
else
if
(
!
this
.
_chunkTimer
)
{
this
.
_chunkTimer
=
new
SkippableTimer
(
{
name
:
"
Query
chunk
timer
"
callback
:
(
)
=
>
this
.
_notifyResults
(
)
time
:
CHUNK_RESULTS_DELAY_MS
logger
:
provider
.
logger
}
)
;
}
if
(
this
.
_heuristicProviderTimer
&
&
!
this
.
context
.
pendingHeuristicProviders
.
size
)
{
this
.
_heuristicProviderTimer
.
fire
(
)
.
catch
(
ex
=
>
logger
.
error
(
ex
)
)
;
}
}
_notifyResults
(
)
{
this
.
muxer
.
sort
(
this
.
context
)
;
if
(
this
.
_heuristicProviderTimer
)
{
this
.
_heuristicProviderTimer
.
cancel
(
)
.
catch
(
ex
=
>
logger
.
error
(
ex
)
)
;
this
.
_heuristicProviderTimer
=
null
;
}
if
(
this
.
_chunkTimer
)
{
this
.
_chunkTimer
.
cancel
(
)
.
catch
(
ex
=
>
logger
.
error
(
ex
)
)
;
this
.
_chunkTimer
=
null
;
}
if
(
!
this
.
context
.
results
.
length
)
{
return
;
}
this
.
context
.
firstResultChanged
=
!
ObjectUtils
.
deepEqual
(
this
.
context
.
firstResult
this
.
context
.
results
[
0
]
)
;
this
.
context
.
firstResult
=
this
.
context
.
results
[
0
]
;
if
(
this
.
controller
)
{
this
.
controller
.
receiveResults
(
this
.
context
)
;
}
}
}
function
updateSourcesIfEmpty
(
context
)
{
if
(
context
.
sources
&
&
context
.
sources
.
length
)
{
return
false
;
}
let
acceptedSources
=
[
]
;
let
restrictToken
=
context
.
tokens
.
find
(
t
=
>
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
UrlbarTokenizer
.
TYPE
.
RESTRICT_TITLE
UrlbarTokenizer
.
TYPE
.
RESTRICT_URL
]
.
includes
(
t
.
type
)
)
;
let
restrictTokenType
=
restrictToken
&
&
restrictToken
.
type
!
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_TITLE
&
&
restrictToken
.
type
!
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_URL
?
restrictToken
.
type
:
undefined
;
for
(
let
source
of
Object
.
values
(
UrlbarUtils
.
RESULT_SOURCE
)
)
{
if
(
context
.
sources
&
&
!
context
.
sources
.
includes
(
source
)
)
{
continue
;
}
switch
(
source
)
{
case
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
:
if
(
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
|
|
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
|
|
(
!
restrictTokenType
&
&
UrlbarPrefs
.
get
(
"
suggest
.
bookmark
"
)
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
:
if
(
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
|
|
(
!
restrictTokenType
&
&
UrlbarPrefs
.
get
(
"
suggest
.
history
"
)
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
:
if
(
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
|
|
!
restrictTokenType
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
TABS
:
if
(
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
|
|
(
!
restrictTokenType
&
&
UrlbarPrefs
.
get
(
"
suggest
.
openpage
"
)
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
:
if
(
!
context
.
isPrivate
&
&
!
restrictTokenType
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
:
default
:
if
(
!
restrictTokenType
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
}
}
context
.
sources
=
acceptedSources
;
return
restrictToken
;
}
