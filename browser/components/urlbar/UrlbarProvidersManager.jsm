"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProvidersManager
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
SkippableTimer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Urlbar
.
ProvidersManager
"
)
)
;
var
localProviderModules
=
{
UrlbarProviderUnifiedComplete
:
"
resource
:
/
/
/
modules
/
UrlbarProviderUnifiedComplete
.
jsm
"
UrlbarProviderPrivateSearch
:
"
resource
:
/
/
/
modules
/
UrlbarProviderPrivateSearch
.
jsm
"
}
;
var
localMuxerModules
=
{
UrlbarMuxerUnifiedComplete
:
"
resource
:
/
/
/
modules
/
UrlbarMuxerUnifiedComplete
.
jsm
"
}
;
const
CHUNK_MATCHES_DELAY_MS
=
16
;
const
DEFAULT_MUXER
=
"
UnifiedComplete
"
;
class
ProvidersManager
{
constructor
(
)
{
this
.
providers
=
[
]
;
for
(
let
[
symbol
module
]
of
Object
.
entries
(
localProviderModules
)
)
{
let
{
[
symbol
]
:
provider
}
=
ChromeUtils
.
import
(
module
{
}
)
;
this
.
registerProvider
(
provider
)
;
}
this
.
queries
=
new
Map
(
)
;
this
.
interruptLevel
=
0
;
this
.
muxers
=
new
Map
(
)
;
for
(
let
[
symbol
module
]
of
Object
.
entries
(
localMuxerModules
)
)
{
let
{
[
symbol
]
:
muxer
}
=
ChromeUtils
.
import
(
module
{
}
)
;
this
.
registerMuxer
(
muxer
)
;
}
}
registerProvider
(
provider
)
{
if
(
!
provider
|
|
!
(
provider
instanceof
UrlbarProvider
)
)
{
throw
new
Error
(
Trying
to
register
an
invalid
provider
)
;
}
if
(
!
Object
.
values
(
UrlbarUtils
.
PROVIDER_TYPE
)
.
includes
(
provider
.
type
)
)
{
throw
new
Error
(
Unknown
provider
type
{
provider
.
type
}
)
;
}
logger
.
info
(
Registering
provider
{
provider
.
name
}
)
;
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
)
{
this
.
providers
.
unshift
(
provider
)
;
}
else
{
this
.
providers
.
push
(
provider
)
;
}
}
unregisterProvider
(
provider
)
{
logger
.
info
(
Unregistering
provider
{
provider
.
name
}
)
;
let
index
=
this
.
providers
.
findIndex
(
p
=
>
p
.
name
=
=
provider
.
name
)
;
if
(
index
!
=
-
1
)
{
this
.
providers
.
splice
(
index
1
)
;
}
}
getProvider
(
name
)
{
return
this
.
providers
.
find
(
p
=
>
p
.
name
=
=
name
)
;
}
registerMuxer
(
muxer
)
{
if
(
!
muxer
|
|
!
(
muxer
instanceof
UrlbarMuxer
)
)
{
throw
new
Error
(
Trying
to
register
an
invalid
muxer
)
;
}
logger
.
info
(
Registering
muxer
{
muxer
.
name
}
)
;
this
.
muxers
.
set
(
muxer
.
name
muxer
)
;
}
unregisterMuxer
(
muxer
)
{
let
muxerName
=
typeof
muxer
=
=
"
string
"
?
muxer
:
muxer
.
name
;
logger
.
info
(
Unregistering
muxer
{
muxerName
}
)
;
this
.
muxers
.
delete
(
muxerName
)
;
}
async
startQuery
(
queryContext
controller
)
{
logger
.
info
(
Query
start
{
queryContext
.
searchString
}
)
;
let
muxerName
=
queryContext
.
muxer
|
|
DEFAULT_MUXER
;
logger
.
info
(
Using
muxer
{
muxerName
}
)
;
let
muxer
=
this
.
muxers
.
get
(
muxerName
)
;
if
(
!
muxer
)
{
throw
new
Error
(
Muxer
with
name
{
muxerName
}
not
found
)
;
}
let
providers
=
queryContext
.
providers
?
this
.
providers
.
filter
(
p
=
>
queryContext
.
providers
.
includes
(
p
.
name
)
)
:
this
.
providers
;
UrlbarTokenizer
.
tokenize
(
queryContext
)
;
queryContext
.
acceptableSources
=
getAcceptableMatchSources
(
queryContext
)
;
logger
.
debug
(
Acceptable
sources
{
queryContext
.
acceptableSources
}
)
;
let
query
=
new
Query
(
queryContext
controller
muxer
providers
)
;
this
.
queries
.
set
(
queryContext
query
)
;
for
(
let
provider
of
this
.
providers
)
{
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
)
{
await
provider
.
updateBehavior
(
queryContext
)
;
}
}
await
query
.
start
(
)
;
}
cancelQuery
(
queryContext
)
{
logger
.
info
(
Query
cancel
{
queryContext
.
searchString
}
)
;
let
query
=
this
.
queries
.
get
(
queryContext
)
;
if
(
!
query
)
{
throw
new
Error
(
"
Couldn
'
t
find
a
matching
query
for
the
given
context
"
)
;
}
query
.
cancel
(
)
;
if
(
!
this
.
interruptLevel
)
{
try
{
let
db
=
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
db
.
interrupt
(
)
;
}
catch
(
ex
)
{
}
}
this
.
queries
.
delete
(
queryContext
)
;
}
async
runInCriticalSection
(
taskFn
)
{
this
.
interruptLevel
+
+
;
try
{
await
taskFn
(
)
;
}
finally
{
this
.
interruptLevel
-
-
;
}
}
notifyEngagementChange
(
isPrivate
state
)
{
for
(
let
provider
of
this
.
providers
)
{
provider
.
onEngagement
(
isPrivate
state
)
;
}
}
}
var
UrlbarProvidersManager
=
new
ProvidersManager
(
)
;
class
Query
{
constructor
(
queryContext
controller
muxer
providers
)
{
this
.
context
=
queryContext
;
this
.
context
.
results
=
[
]
;
this
.
muxer
=
muxer
;
this
.
controller
=
controller
;
this
.
providers
=
providers
;
this
.
started
=
false
;
this
.
canceled
=
false
;
this
.
complete
=
false
;
this
.
acceptableSources
=
queryContext
.
acceptableSources
.
slice
(
)
;
}
async
start
(
)
{
if
(
this
.
started
)
{
throw
new
Error
(
"
This
Query
has
been
started
already
"
)
;
}
this
.
started
=
true
;
let
providers
=
this
.
providers
.
filter
(
p
=
>
p
.
isActive
(
this
.
context
)
)
;
let
restrictProviders
=
providers
.
filter
(
p
=
>
p
.
isRestricting
(
this
.
context
)
)
;
if
(
restrictProviders
.
length
)
{
providers
=
restrictProviders
;
}
let
promises
=
[
]
;
let
delayStarted
=
false
;
for
(
let
provider
of
providers
)
{
if
(
this
.
canceled
)
{
break
;
}
if
(
provider
.
type
!
=
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
&
&
!
delayStarted
)
{
delayStarted
=
true
;
this
.
_sleepTimer
=
new
SkippableTimer
(
{
name
:
"
Query
provider
timer
"
time
:
UrlbarPrefs
.
get
(
"
delay
"
)
logger
}
)
;
await
this
.
_sleepTimer
.
promise
;
}
promises
.
push
(
provider
.
startQuery
(
this
.
context
this
.
add
.
bind
(
this
)
)
)
;
}
logger
.
info
(
Queried
{
promises
.
length
}
providers
)
;
if
(
promises
.
length
)
{
await
Promise
.
all
(
promises
.
map
(
p
=
>
p
.
catch
(
Cu
.
reportError
)
)
)
;
if
(
this
.
_chunkTimer
)
{
await
this
.
_chunkTimer
.
fire
(
)
;
}
}
this
.
complete
=
true
;
this
.
controller
=
null
;
}
cancel
(
)
{
if
(
this
.
canceled
)
{
return
;
}
this
.
canceled
=
true
;
for
(
let
provider
of
this
.
providers
)
{
provider
.
cancelQuery
(
this
.
context
)
;
}
if
(
this
.
_chunkTimer
)
{
this
.
_chunkTimer
.
cancel
(
)
.
catch
(
Cu
.
reportError
)
;
}
if
(
this
.
_sleepTimer
)
{
this
.
_sleepTimer
.
fire
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
add
(
provider
match
)
{
if
(
!
(
provider
instanceof
UrlbarProvider
)
)
{
throw
new
Error
(
"
Invalid
provider
passed
to
the
add
callback
"
)
;
}
if
(
this
.
canceled
)
{
return
;
}
if
(
!
this
.
acceptableSources
.
includes
(
match
.
source
)
&
&
!
match
.
heuristic
)
{
return
;
}
if
(
match
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
&
&
match
.
payload
.
url
&
&
match
.
payload
.
url
.
startsWith
(
"
javascript
:
"
)
&
&
!
this
.
context
.
searchString
.
startsWith
(
"
javascript
:
"
)
&
&
UrlbarPrefs
.
get
(
"
filter
.
javascript
"
)
)
{
return
;
}
match
.
providerName
=
provider
.
name
;
this
.
context
.
results
.
push
(
match
)
;
let
notifyResults
=
(
)
=
>
{
if
(
this
.
_chunkTimer
)
{
this
.
_chunkTimer
.
cancel
(
)
.
catch
(
Cu
.
reportError
)
;
delete
this
.
_chunkTimer
;
}
this
.
muxer
.
sort
(
this
.
context
)
;
logger
.
debug
(
Cropping
{
this
.
context
.
results
.
length
}
matches
to
{
this
.
context
.
maxResults
}
)
;
let
resultCount
=
this
.
context
.
maxResults
;
for
(
let
i
=
0
;
i
<
this
.
context
.
results
.
length
;
i
+
+
)
{
resultCount
-
=
UrlbarUtils
.
getSpanForResult
(
this
.
context
.
results
[
i
]
)
;
if
(
resultCount
<
0
)
{
this
.
context
.
results
.
splice
(
i
this
.
context
.
results
.
length
-
i
)
;
break
;
}
}
this
.
controller
.
receiveResults
(
this
.
context
)
;
}
;
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
)
{
notifyResults
(
)
;
}
else
if
(
!
this
.
_chunkTimer
)
{
this
.
_chunkTimer
=
new
SkippableTimer
(
{
name
:
"
Query
chunk
timer
"
callback
:
notifyResults
time
:
CHUNK_MATCHES_DELAY_MS
logger
}
)
;
}
}
}
function
getAcceptableMatchSources
(
context
)
{
let
acceptedSources
=
[
]
;
let
restrictToken
=
context
.
tokens
.
find
(
t
=
>
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
]
.
includes
(
t
.
type
)
)
;
let
restrictTokenType
=
restrictToken
?
restrictToken
.
type
:
undefined
;
for
(
let
source
of
Object
.
values
(
UrlbarUtils
.
RESULT_SOURCE
)
)
{
if
(
context
.
sources
&
&
!
context
.
sources
.
includes
(
source
)
)
{
continue
;
}
switch
(
source
)
{
case
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
:
if
(
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
|
|
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
|
|
(
!
restrictTokenType
&
&
UrlbarPrefs
.
get
(
"
suggest
.
bookmark
"
)
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
:
if
(
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
|
|
(
!
restrictTokenType
&
&
UrlbarPrefs
.
get
(
"
suggest
.
history
"
)
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
:
if
(
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
|
|
!
restrictTokenType
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
TABS
:
if
(
restrictTokenType
=
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
|
|
(
!
restrictTokenType
&
&
UrlbarPrefs
.
get
(
"
suggest
.
openpage
"
)
)
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
:
if
(
!
context
.
isPrivate
&
&
!
restrictTokenType
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
case
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
:
default
:
if
(
!
restrictTokenType
)
{
acceptedSources
.
push
(
source
)
;
}
break
;
}
}
return
acceptedSources
;
}
