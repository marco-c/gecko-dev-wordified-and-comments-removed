"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderInterventions
"
"
QueryScorer
"
]
;
var
gGlobalScope
=
this
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
UrlbarProvider
UrlbarUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppUpdater
:
"
resource
:
/
/
/
modules
/
AppUpdater
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
NLP
:
"
resource
:
/
/
gre
/
modules
/
NLP
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
ResetProfile
:
"
resource
:
/
/
gre
/
modules
/
ResetProfile
.
jsm
"
Sanitizer
:
"
resource
:
/
/
/
modules
/
Sanitizer
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
appUpdater
"
(
)
=
>
new
AppUpdater
(
)
)
;
const
TIPS
=
{
NONE
:
"
"
CLEAR
:
"
intervention_clear
"
REFRESH
:
"
intervention_refresh
"
UPDATE_ASK
:
"
intervention_update_ask
"
UPDATE_CHECKING
:
"
intervention_update_checking
"
UPDATE_REFRESH
:
"
intervention_update_refresh
"
UPDATE_RESTART
:
"
intervention_update_restart
"
UPDATE_WEB
:
"
intervention_update_web
"
}
;
const
EN_LOCALE_MATCH
=
/
^
en
(
-
.
*
)
/
;
const
DOCUMENTS
=
{
clear
:
[
"
cache
firefox
"
"
clear
cache
firefox
"
"
clear
cache
in
firefox
"
"
clear
cookies
firefox
"
"
clear
firefox
cache
"
"
clear
history
firefox
"
"
cookies
firefox
"
"
delete
cookies
firefox
"
"
delete
history
firefox
"
"
firefox
cache
"
"
firefox
clear
cache
"
"
firefox
clear
cookies
"
"
firefox
clear
history
"
"
firefox
cookie
"
"
firefox
cookies
"
"
firefox
delete
cookies
"
"
firefox
delete
history
"
"
firefox
history
"
"
firefox
not
loading
pages
"
"
history
firefox
"
"
how
to
clear
cache
"
"
how
to
clear
history
"
]
refresh
:
[
"
firefox
crashing
"
"
firefox
keeps
crashing
"
"
firefox
not
responding
"
"
firefox
not
working
"
"
firefox
refresh
"
"
firefox
slow
"
"
how
to
reset
firefox
"
"
refresh
firefox
"
"
reset
firefox
"
]
update
:
[
"
download
firefox
"
"
download
mozilla
"
"
firefox
browser
"
"
firefox
download
"
"
firefox
for
mac
"
"
firefox
for
windows
"
"
firefox
free
download
"
"
firefox
install
"
"
firefox
installer
"
"
firefox
latest
version
"
"
firefox
mac
"
"
firefox
quantum
"
"
firefox
update
"
"
firefox
version
"
"
firefox
windows
"
"
get
firefox
"
"
how
to
update
firefox
"
"
install
firefox
"
"
mozilla
download
"
"
mozilla
firefox
2019
"
"
mozilla
firefox
2020
"
"
mozilla
firefox
download
"
"
mozilla
firefox
for
mac
"
"
mozilla
firefox
for
windows
"
"
mozilla
firefox
free
download
"
"
mozilla
firefox
mac
"
"
mozilla
firefox
update
"
"
mozilla
firefox
windows
"
"
mozilla
update
"
"
update
firefox
"
"
update
mozilla
"
"
www
.
firefox
.
com
"
]
}
;
const
UPDATE_CHECK_PERIOD_MS
=
12
*
60
*
60
*
1000
;
class
Node
{
constructor
(
word
)
{
this
.
word
=
word
;
this
.
documents
=
new
Set
(
)
;
this
.
childrenByWord
=
new
Map
(
)
;
}
}
class
QueryScorer
{
constructor
(
{
distanceThreshold
=
1
variations
=
new
Map
(
)
}
=
{
}
)
{
this
.
_distanceThreshold
=
distanceThreshold
;
this
.
_variations
=
variations
;
this
.
_documents
=
new
Set
(
)
;
this
.
_rootNode
=
new
Node
(
)
;
}
addDocument
(
doc
)
{
this
.
_documents
.
add
(
doc
)
;
for
(
let
phraseStr
of
doc
.
phrases
)
{
let
phrase
=
phraseStr
.
trim
(
)
.
split
(
/
\
s
+
/
)
.
map
(
word
=
>
word
.
toLocaleLowerCase
(
)
)
;
let
phrases
=
[
phrase
]
;
for
(
let
[
triggerWord
variations
]
of
this
.
_variations
)
{
let
index
=
phrase
.
indexOf
(
triggerWord
)
;
if
(
index
>
=
0
)
{
for
(
let
variation
of
variations
)
{
let
variationPhrase
=
Array
.
from
(
phrase
)
;
variationPhrase
.
splice
(
index
1
.
.
.
variation
.
split
(
/
\
s
+
/
)
)
;
phrases
.
push
(
variationPhrase
)
;
}
}
}
for
(
let
completedPhrase
of
phrases
)
{
this
.
_buildPhraseTree
(
this
.
_rootNode
doc
completedPhrase
0
)
;
}
}
}
score
(
queryString
)
{
let
queryWords
=
queryString
.
trim
(
)
.
split
(
/
\
s
+
/
)
.
map
(
word
=
>
word
.
toLocaleLowerCase
(
)
)
;
let
minDistanceByDoc
=
this
.
_traverse
(
{
queryWords
}
)
;
let
results
=
[
]
;
for
(
let
doc
of
this
.
_documents
)
{
let
distance
=
minDistanceByDoc
.
get
(
doc
)
;
results
.
push
(
{
document
:
doc
score
:
distance
=
=
=
undefined
?
Infinity
:
distance
}
)
;
}
results
.
sort
(
(
a
b
)
=
>
a
.
score
-
b
.
score
)
;
return
results
;
}
_buildPhraseTree
(
node
doc
phrase
wordIndex
)
{
if
(
phrase
.
length
=
=
wordIndex
)
{
return
;
}
let
word
=
phrase
[
wordIndex
]
.
toLocaleLowerCase
(
)
;
let
child
=
node
.
childrenByWord
.
get
(
word
)
;
if
(
!
child
)
{
child
=
new
Node
(
word
)
;
node
.
childrenByWord
.
set
(
word
child
)
;
}
child
.
documents
.
add
(
doc
)
;
this
.
_buildPhraseTree
(
child
doc
phrase
wordIndex
+
1
)
;
}
_traverse
(
{
queryWords
node
=
this
.
_rootNode
minDistanceByDoc
=
new
Map
(
)
queryWordsIndex
=
0
phraseDistance
=
0
}
=
{
}
)
{
if
(
!
node
.
childrenByWord
.
size
)
{
for
(
let
doc
of
node
.
documents
)
{
minDistanceByDoc
.
set
(
doc
Math
.
min
(
phraseDistance
minDistanceByDoc
.
has
(
doc
)
?
minDistanceByDoc
.
get
(
doc
)
:
Infinity
)
)
;
}
return
minDistanceByDoc
;
}
if
(
queryWordsIndex
=
=
queryWords
.
length
)
{
return
minDistanceByDoc
;
}
let
queryWord
=
queryWords
[
queryWordsIndex
]
;
for
(
let
[
childWord
child
]
of
node
.
childrenByWord
)
{
let
distance
=
NLP
.
levenshtein
(
queryWord
childWord
)
;
if
(
distance
<
=
this
.
_distanceThreshold
)
{
this
.
_traverse
(
{
node
:
child
queryWords
queryWordsIndex
:
queryWordsIndex
+
1
phraseDistance
:
phraseDistance
+
distance
minDistanceByDoc
}
)
;
}
}
return
minDistanceByDoc
;
}
}
function
getL10nPropertiesForTip
(
tip
)
{
const
baseURL
=
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
"
;
switch
(
tip
)
{
case
TIPS
.
CLEAR
:
return
{
textData
:
{
id
:
"
intervention
-
clear
-
data
"
}
buttonTextData
:
{
id
:
"
intervention
-
clear
-
data
-
confirm
"
}
helpUrl
:
baseURL
+
"
delete
-
browsing
-
search
-
download
-
history
-
firefox
"
}
;
case
TIPS
.
REFRESH
:
return
{
textData
:
{
id
:
"
intervention
-
refresh
-
profile
"
}
buttonTextData
:
{
id
:
"
intervention
-
refresh
-
profile
-
confirm
"
}
helpUrl
:
baseURL
+
"
refresh
-
firefox
-
reset
-
add
-
ons
-
and
-
settings
"
}
;
case
TIPS
.
UPDATE_ASK
:
return
{
textData
:
{
id
:
"
intervention
-
update
-
ask
"
}
buttonTextData
:
{
id
:
"
intervention
-
update
-
ask
-
confirm
"
}
helpUrl
:
baseURL
+
"
update
-
firefox
-
latest
-
release
"
}
;
case
TIPS
.
UPDATE_REFRESH
:
return
{
textData
:
{
id
:
"
intervention
-
update
-
refresh
"
}
buttonTextData
:
{
id
:
"
intervention
-
update
-
refresh
-
confirm
"
}
helpUrl
:
baseURL
+
"
refresh
-
firefox
-
reset
-
add
-
ons
-
and
-
settings
"
}
;
case
TIPS
.
UPDATE_RESTART
:
return
{
textData
:
{
id
:
"
intervention
-
update
-
restart
"
}
buttonTextData
:
{
id
:
"
intervention
-
update
-
restart
-
confirm
"
}
helpUrl
:
baseURL
+
"
update
-
firefox
-
latest
-
release
"
}
;
case
TIPS
.
UPDATE_WEB
:
return
{
textData
:
{
id
:
"
intervention
-
update
-
web
"
}
buttonTextData
:
{
id
:
"
intervention
-
update
-
web
-
confirm
"
}
helpUrl
:
baseURL
+
"
update
-
firefox
-
latest
-
release
"
}
;
default
:
throw
new
Error
(
"
Unknown
TIP
type
.
"
)
;
}
}
class
ProviderInterventions
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
this
.
currentTip
=
TIPS
.
NONE
;
this
.
tipsShownInCurrentEngagement
=
new
Set
(
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
queryScorer
"
(
)
=
>
{
let
queryScorer
=
new
QueryScorer
(
{
variations
:
new
Map
(
[
[
"
firefox
"
[
"
fire
fox
"
"
fox
fire
"
"
foxfire
"
]
]
[
"
mozilla
"
[
"
mozila
"
]
]
]
)
}
)
;
for
(
let
[
id
phrases
]
of
Object
.
entries
(
DOCUMENTS
)
)
{
queryScorer
.
addDocument
(
{
id
phrases
}
)
;
}
return
queryScorer
;
}
)
;
}
get
TIP_TYPE
(
)
{
return
TIPS
;
}
get
name
(
)
{
return
"
UrlbarProviderInterventions
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
;
}
isActive
(
queryContext
)
{
if
(
!
queryContext
.
searchString
|
|
queryContext
.
searchString
.
length
>
UrlbarUtils
.
MAX_TEXT_LENGTH
|
|
UrlbarTokenizer
.
REGEXP_LIKE_PROTOCOL
.
test
(
queryContext
.
searchString
)
|
|
!
EN_LOCALE_MATCH
.
test
(
Services
.
locale
.
appLocaleAsBCP47
)
|
|
!
Services
.
policies
.
isAllowed
(
"
urlbarinterventions
"
)
)
{
return
false
;
}
this
.
currentTip
=
TIPS
.
NONE
;
let
docScores
=
this
.
queryScorer
.
score
(
queryContext
.
searchString
)
;
let
topDocScore
=
docScores
[
0
]
;
let
topDocIDs
=
new
Set
(
)
;
if
(
topDocScore
.
score
!
=
Infinity
)
{
for
(
let
{
score
document
}
of
docScores
)
{
if
(
score
!
=
topDocScore
.
score
)
{
break
;
}
topDocIDs
.
add
(
document
.
id
)
;
}
}
if
(
topDocIDs
.
has
(
"
update
"
)
)
{
this
.
_setCurrentTipFromAppUpdaterStatus
(
)
;
}
else
if
(
topDocIDs
.
has
(
"
clear
"
)
)
{
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
this
.
currentTip
=
TIPS
.
CLEAR
;
}
}
else
if
(
topDocIDs
.
has
(
"
refresh
"
)
)
{
this
.
currentTip
=
TIPS
.
REFRESH
;
}
return
(
this
.
currentTip
!
=
TIPS
.
NONE
&
&
(
this
.
currentTip
!
=
TIPS
.
REFRESH
|
|
Services
.
policies
.
isAllowed
(
"
profileRefresh
"
)
)
)
;
}
async
_setCurrentTipFromAppUpdaterStatus
(
waitForCheck
)
{
try
{
this
.
checkForBrowserUpdate
(
)
;
}
catch
(
ex
)
{
return
;
}
switch
(
appUpdater
.
status
)
{
case
AppUpdater
.
STATUS
.
READY_FOR_RESTART
:
this
.
currentTip
=
TIPS
.
UPDATE_RESTART
;
break
;
case
AppUpdater
.
STATUS
.
DOWNLOAD_AND_INSTALL
:
this
.
currentTip
=
TIPS
.
UPDATE_ASK
;
break
;
case
AppUpdater
.
STATUS
.
NO_UPDATES_FOUND
:
this
.
currentTip
=
TIPS
.
UPDATE_REFRESH
;
break
;
case
AppUpdater
.
STATUS
.
CHECKING
:
this
.
currentTip
=
TIPS
.
UPDATE_CHECKING
;
break
;
case
AppUpdater
.
STATUS
.
NO_UPDATER
:
case
AppUpdater
.
STATUS
.
UPDATE_DISABLED_BY_POLICY
:
this
.
currentTip
=
TIPS
.
NONE
;
break
;
default
:
this
.
currentTip
=
TIPS
.
UPDATE_WEB
;
break
;
}
}
async
startQuery
(
queryContext
addCallback
)
{
let
instance
=
this
.
queryInstance
;
if
(
this
.
currentTip
=
=
TIPS
.
UPDATE_CHECKING
)
{
this
.
_setCurrentTipFromAppUpdaterStatus
(
)
;
if
(
this
.
currentTip
=
=
TIPS
.
UPDATE_CHECKING
)
{
await
new
Promise
(
resolve
=
>
{
this
.
_appUpdaterListener
=
(
)
=
>
{
appUpdater
.
removeListener
(
this
.
_appUpdaterListener
)
;
delete
this
.
_appUpdaterListener
;
resolve
(
)
;
}
;
appUpdater
.
addListener
(
this
.
_appUpdaterListener
)
;
}
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
;
}
this
.
_setCurrentTipFromAppUpdaterStatus
(
)
;
if
(
this
.
currentTip
=
=
TIPS
.
UPDATE_CHECKING
)
{
return
;
}
}
}
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
TIP
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
type
:
this
.
currentTip
}
)
;
result
.
suggestedIndex
=
1
;
Object
.
assign
(
result
.
payload
getL10nPropertiesForTip
(
this
.
currentTip
)
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
;
}
this
.
tipsShownInCurrentEngagement
.
add
(
this
.
currentTip
)
;
addCallback
(
this
result
)
;
}
cancelQuery
(
queryContext
)
{
if
(
this
.
_appUpdaterListener
)
{
appUpdater
.
removeListener
(
this
.
_appUpdaterListener
)
;
delete
this
.
_appUpdaterListener
;
}
}
pickResult
(
result
)
{
let
tip
=
result
.
payload
.
type
;
switch
(
tip
)
{
case
TIPS
.
CLEAR
:
openClearHistoryDialog
(
)
;
break
;
case
TIPS
.
REFRESH
:
case
TIPS
.
UPDATE_REFRESH
:
resetBrowser
(
)
;
break
;
case
TIPS
.
UPDATE_ASK
:
installBrowserUpdateAndRestart
(
)
;
break
;
case
TIPS
.
UPDATE_RESTART
:
restartBrowser
(
)
;
break
;
case
TIPS
.
UPDATE_WEB
:
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
window
.
gBrowser
.
selectedTab
=
window
.
gBrowser
.
addWebTab
(
"
https
:
/
/
www
.
mozilla
.
org
/
firefox
/
new
/
"
)
;
break
;
}
}
onEngagement
(
isPrivate
state
queryContext
details
)
{
if
(
[
"
engagement
"
"
abandonment
"
]
.
includes
(
state
)
)
{
for
(
let
tip
of
this
.
tipsShownInCurrentEngagement
)
{
Services
.
telemetry
.
keyedScalarAdd
(
"
urlbar
.
tips
"
{
tip
}
-
shown
1
)
;
}
}
this
.
tipsShownInCurrentEngagement
.
clear
(
)
;
}
checkForBrowserUpdate
(
force
=
false
)
{
if
(
force
|
|
!
this
.
_lastUpdateCheckTime
|
|
Date
.
now
(
)
-
this
.
_lastUpdateCheckTime
>
=
UPDATE_CHECK_PERIOD_MS
)
{
this
.
_lastUpdateCheckTime
=
Date
.
now
(
)
;
appUpdater
.
check
(
)
;
}
}
resetAppUpdater
(
)
{
if
(
!
Object
.
getOwnPropertyDescriptor
(
gGlobalScope
"
appUpdater
"
)
.
get
)
{
appUpdater
=
new
AppUpdater
(
)
;
}
}
}
var
UrlbarProviderInterventions
=
new
ProviderInterventions
(
)
;
function
installBrowserUpdateAndRestart
(
)
{
if
(
appUpdater
.
status
!
=
AppUpdater
.
STATUS
.
DOWNLOAD_AND_INSTALL
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
let
listener
=
(
)
=
>
{
if
(
appUpdater
.
status
!
=
AppUpdater
.
STATUS
.
READY_FOR_RESTART
&
&
appUpdater
.
status
!
=
AppUpdater
.
STATUS
.
DOWNLOAD_FAILED
)
{
return
;
}
appUpdater
.
removeListener
(
listener
)
;
if
(
appUpdater
.
status
=
=
AppUpdater
.
STATUS
.
READY_FOR_RESTART
)
{
restartBrowser
(
)
;
}
resolve
(
)
;
}
;
appUpdater
.
addListener
(
listener
)
;
appUpdater
.
startDownload
(
)
;
}
)
;
}
function
openClearHistoryDialog
(
)
{
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
return
;
}
Sanitizer
.
showUI
(
window
)
;
}
function
restartBrowser
(
)
{
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
cancelQuit
.
data
)
{
return
;
}
if
(
Services
.
appinfo
.
inSafeMode
)
{
Services
.
startup
.
restartInSafeMode
(
Ci
.
nsIAppStartup
.
eAttemptQuit
)
;
}
else
{
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
}
}
function
resetBrowser
(
)
{
if
(
!
ResetProfile
.
resetSupported
(
)
)
{
return
;
}
let
window
=
BrowserWindowTracker
.
getTopWindow
(
)
;
ResetProfile
.
openConfirmationDialog
(
window
)
;
}
