"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderSearchSuggestions
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
PlacesSearchAutocompleteProvider
:
"
resource
:
/
/
gre
/
modules
/
PlacesSearchAutocompleteProvider
.
jsm
"
SearchSuggestionController
:
"
resource
:
/
/
gre
/
modules
/
SearchSuggestionController
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
SkippableTimer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Urlbar
.
Provider
.
SearchSuggestions
"
)
)
;
function
looksLikeUrl
(
str
ignoreAlphanumericHosts
=
false
)
{
return
(
!
UrlbarTokenizer
.
REGEXP_SPACES
.
test
(
str
)
&
&
(
[
"
/
"
"
"
"
:
"
"
[
"
]
.
some
(
c
=
>
str
.
includes
(
c
)
)
|
|
(
ignoreAlphanumericHosts
?
/
^
(
[
\
[
\
]
A
-
Z0
-
9
-
]
+
\
.
)
{
3
}
[
^
.
]
+
/
i
.
test
(
str
)
:
str
.
includes
(
"
.
"
)
)
)
)
;
}
function
substringAt
(
sourceStr
targetStr
)
{
let
index
=
sourceStr
.
indexOf
(
targetStr
)
;
return
index
<
0
?
"
"
:
sourceStr
.
substr
(
index
)
;
}
function
substringAfter
(
sourceStr
targetStr
)
{
let
index
=
sourceStr
.
indexOf
(
targetStr
)
;
return
index
<
0
?
"
"
:
sourceStr
.
substr
(
index
+
targetStr
.
length
)
;
}
class
ProviderSearchSuggestions
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
this
.
queries
=
new
Map
(
)
;
}
get
name
(
)
{
return
"
SearchSuggestions
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
NETWORK
;
}
isActive
(
queryContext
)
{
if
(
!
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
)
|
|
(
queryContext
.
restrictSource
&
&
queryContext
.
restrictSource
!
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
)
)
{
return
false
;
}
if
(
!
queryContext
.
searchString
.
trim
(
)
)
{
return
false
;
}
return
this
.
_formHistoryCount
|
|
this
.
_allowRemoteSuggestions
(
queryContext
)
;
}
_allowRemoteSuggestions
(
queryContext
)
{
if
(
!
queryContext
.
allowSearchSuggestions
|
|
!
UrlbarPrefs
.
get
(
"
suggest
.
searches
"
)
|
|
!
UrlbarPrefs
.
get
(
"
browser
.
search
.
suggest
.
enabled
"
)
|
|
(
queryContext
.
isPrivate
&
&
!
UrlbarPrefs
.
get
(
"
browser
.
search
.
suggest
.
enabled
.
private
"
)
)
)
{
return
false
;
}
if
(
queryContext
.
searchString
.
startsWith
(
"
"
)
)
{
return
true
;
}
if
(
!
!
this
.
_lastLowResultsSearchSuggestion
&
&
queryContext
.
searchString
.
length
>
this
.
_lastLowResultsSearchSuggestion
.
length
&
&
queryContext
.
searchString
.
startsWith
(
this
.
_lastLowResultsSearchSuggestion
)
)
{
return
false
;
}
if
(
queryContext
.
searchString
.
length
<
2
)
{
return
false
;
}
if
(
queryContext
.
tokens
.
length
=
=
1
&
&
queryContext
.
tokens
[
0
]
.
type
=
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_ORIGIN
)
{
return
false
;
}
if
(
queryContext
.
tokens
.
some
(
t
=
>
t
.
type
=
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_URL
|
|
(
t
.
type
=
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_ORIGIN
&
&
!
UrlbarTokenizer
.
REGEXP_SINGLE_WORD_HOST
.
test
(
t
.
value
)
)
)
)
{
return
false
;
}
return
true
;
}
async
startQuery
(
queryContext
addCallback
)
{
logger
.
info
(
Starting
query
for
{
queryContext
.
searchString
}
)
;
let
instance
=
{
}
;
this
.
queries
.
set
(
queryContext
instance
)
;
let
trimmedOriginalSearchString
=
queryContext
.
searchString
.
trim
(
)
;
let
aliasEngine
=
await
this
.
_maybeGetAlias
(
queryContext
)
;
if
(
!
aliasEngine
)
{
if
(
queryContext
.
searchString
.
startsWith
(
"
"
)
)
{
return
;
}
}
let
query
=
aliasEngine
?
aliasEngine
.
query
:
substringAt
(
queryContext
.
searchString
queryContext
.
tokens
[
0
]
.
value
)
;
if
(
!
query
)
{
return
;
}
let
leadingRestrictionToken
=
null
;
if
(
UrlbarTokenizer
.
isRestrictionToken
(
queryContext
.
tokens
[
0
]
)
&
&
(
queryContext
.
tokens
.
length
>
1
|
|
queryContext
.
tokens
[
0
]
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
)
)
{
leadingRestrictionToken
=
queryContext
.
tokens
[
0
]
.
value
;
}
let
emptyQueryTokenAlias
=
aliasEngine
&
&
aliasEngine
.
isTokenAlias
&
&
!
aliasEngine
.
query
;
let
emptySearchRestriction
=
trimmedOriginalSearchString
.
length
<
=
3
&
&
leadingRestrictionToken
=
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
&
&
/
\
s
*
\
S
?
/
.
test
(
trimmedOriginalSearchString
)
;
if
(
emptySearchRestriction
|
|
emptyQueryTokenAlias
)
{
return
;
}
if
(
leadingRestrictionToken
=
=
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
)
{
query
=
substringAfter
(
query
leadingRestrictionToken
)
.
trim
(
)
;
}
let
engine
;
if
(
aliasEngine
)
{
engine
=
aliasEngine
.
engine
;
}
else
{
engine
=
queryContext
.
engineName
?
Services
.
search
.
getEngineByName
(
queryContext
.
engineName
)
:
await
PlacesSearchAutocompleteProvider
.
currentEngine
(
queryContext
.
isPrivate
)
;
if
(
!
engine
)
{
return
;
}
}
let
alias
=
(
aliasEngine
&
&
aliasEngine
.
alias
)
|
|
"
"
;
let
results
=
await
this
.
_fetchSearchSuggestions
(
queryContext
engine
query
alias
)
;
if
(
!
results
|
|
!
this
.
queries
.
has
(
queryContext
)
)
{
return
;
}
for
(
let
result
of
results
)
{
addCallback
(
this
result
)
;
}
this
.
queries
.
delete
(
queryContext
)
;
}
getPriority
(
queryContext
)
{
return
0
;
}
cancelQuery
(
queryContext
)
{
logger
.
info
(
Canceling
query
for
{
queryContext
.
searchString
}
)
;
if
(
this
.
_suggestionsController
)
{
this
.
_suggestionsController
.
stop
(
)
;
this
.
_suggestionsController
=
null
;
}
this
.
queries
.
delete
(
queryContext
)
;
}
get
_formHistoryCount
(
)
{
let
count
=
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
;
if
(
!
count
)
{
return
0
;
}
return
count
+
1
;
}
async
_fetchSearchSuggestions
(
queryContext
engine
searchString
alias
)
{
if
(
!
engine
|
|
!
searchString
)
{
return
null
;
}
this
.
_suggestionsController
=
new
SearchSuggestionController
(
)
;
this
.
_suggestionsController
.
formHistoryParam
=
queryContext
.
formHistoryName
;
this
.
_suggestionsController
.
maxLocalResults
=
this
.
_formHistoryCount
;
let
allowRemote
=
this
.
_allowRemoteSuggestions
(
queryContext
)
;
this
.
_suggestionsController
.
maxRemoteResults
=
allowRemote
?
queryContext
.
maxResults
+
1
:
0
;
this
.
_suggestionsFetchCompletePromise
=
this
.
_suggestionsController
.
fetch
(
searchString
queryContext
.
isPrivate
engine
queryContext
.
userContextId
)
;
let
fetchData
=
await
this
.
_suggestionsFetchCompletePromise
;
if
(
!
fetchData
)
{
return
null
;
}
let
results
=
[
]
;
for
(
let
entry
of
fetchData
.
local
)
{
results
.
push
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
engine
:
engine
.
name
suggestion
:
[
entry
.
value
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
lowerCaseSuggestion
:
entry
.
value
.
toLocaleLowerCase
(
)
}
)
)
)
;
}
if
(
allowRemote
&
&
!
fetchData
.
remote
.
length
&
&
searchString
.
length
>
UrlbarPrefs
.
get
(
"
maxCharsForSearchSuggestions
"
)
)
{
this
.
_lastLowResultsSearchSuggestion
=
searchString
;
}
let
tailTimer
=
new
SkippableTimer
(
{
name
:
"
ProviderSearchSuggestions
"
time
:
100
logger
}
)
;
for
(
let
entry
of
fetchData
.
remote
)
{
if
(
looksLikeUrl
(
entry
.
value
)
)
{
continue
;
}
if
(
entry
.
tail
&
&
entry
.
tailOffsetIndex
<
0
)
{
Cu
.
reportError
(
Error
in
tail
suggestion
parsing
.
Value
:
{
entry
.
value
}
tail
:
{
entry
.
tail
}
.
)
;
continue
;
}
let
tail
=
entry
.
tail
;
let
tailPrefix
=
entry
.
matchPrefix
;
if
(
tail
&
&
!
UrlbarPrefs
.
get
(
"
richSuggestions
.
tail
"
)
)
{
continue
;
}
if
(
!
tail
)
{
await
tailTimer
.
fire
(
)
.
catch
(
Cu
.
reportError
)
;
}
try
{
results
.
push
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
engine
:
[
engine
.
name
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
suggestion
:
[
entry
.
value
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
lowerCaseSuggestion
:
entry
.
value
.
toLocaleLowerCase
(
)
tailPrefix
tail
:
[
tail
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
tailOffsetIndex
:
entry
.
tailOffsetIndex
keyword
:
[
alias
?
alias
:
undefined
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
query
:
[
searchString
.
trim
(
)
UrlbarUtils
.
HIGHLIGHT
.
NONE
]
isSearchHistory
:
false
icon
:
[
engine
.
iconURI
&
&
!
entry
.
value
?
engine
.
iconURI
.
spec
:
"
"
]
keywordOffer
:
UrlbarUtils
.
KEYWORD_OFFER
.
NONE
}
)
)
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
continue
;
}
}
await
tailTimer
.
promise
;
return
results
;
}
async
_maybeGetAlias
(
queryContext
)
{
if
(
queryContext
.
restrictSource
&
&
queryContext
.
restrictSource
=
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
&
&
queryContext
.
engineName
&
&
!
queryContext
.
searchString
.
startsWith
(
"
"
)
)
{
return
null
;
}
let
possibleAlias
=
queryContext
.
tokens
[
0
]
?
.
value
.
trim
(
)
;
if
(
!
possibleAlias
|
|
possibleAlias
=
=
"
"
)
{
return
null
;
}
let
engineMatch
=
await
PlacesSearchAutocompleteProvider
.
engineForAlias
(
possibleAlias
)
;
if
(
engineMatch
)
{
return
{
engine
:
engineMatch
alias
:
possibleAlias
query
:
substringAfter
(
queryContext
.
searchString
possibleAlias
)
.
trim
(
)
isTokenAlias
:
possibleAlias
.
startsWith
(
"
"
)
}
;
}
let
engines
=
await
PlacesSearchAutocompleteProvider
.
tokenAliasEngines
(
)
;
if
(
!
engines
|
|
!
engines
.
length
)
{
return
null
;
}
for
(
let
{
engine
tokenAliases
}
of
engines
)
{
if
(
tokenAliases
.
includes
(
possibleAlias
)
)
{
return
{
engine
alias
:
possibleAlias
query
:
substringAfter
(
queryContext
.
searchString
possibleAlias
)
.
trim
(
)
isTokenAlias
:
true
}
;
}
}
return
null
;
}
}
var
UrlbarProviderSearchSuggestions
=
new
ProviderSearchSuggestions
(
)
;
