"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarTokenizer
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
UrlbarUtils
.
getLogger
(
{
prefix
:
"
Tokenizer
"
}
)
)
;
var
UrlbarTokenizer
=
{
REGEXP_SPACES
:
/
\
s
+
/
REGEXP_SPACES_START
:
/
^
\
s
+
/
REGEXP_LIKE_PROTOCOL
:
/
^
[
A
-
Z
+
.
-
]
+
:
\
/
*
(
?
!
\
/
)
/
i
REGEXP_USERINFO_INVALID_CHARS
:
/
[
^
\
w
.
~
%
!
&
'
(
)
*
+
;
=
:
-
]
/
REGEXP_HOSTPORT_INVALID_CHARS
:
/
[
^
\
[
\
]
A
-
Z0
-
9
.
:
-
]
/
i
REGEXP_SINGLE_WORD_HOST
:
/
^
[
^
.
:
]
+
/
i
REGEXP_HOSTPORT_IP_LIKE
:
/
^
(
?
=
(
.
*
[
.
:
]
.
*
)
{
2
}
)
[
a
-
f0
-
9
\
.
\
[
\
]
:
]
+
/
i
REGEXP_HOSTPORT_INVALID_IP
:
/
\
.
{
2
}
|
\
d
{
5
}
|
\
d
{
4
}
(
?
!
[
:
\
]
]
)
|
^
\
.
|
^
(
\
d
+
\
.
)
{
4
}
\
d
+
|
^
\
d
{
4
}
/
REGEXP_HOSTPORT_IPV4
:
/
^
(
\
d
{
1
3
}
\
.
)
{
3
}
\
d
{
1
3
}
(
:
\
d
+
)
?
/
REGEXP_HOSTPORT_IPV6
:
/
^
\
[
(
[
0
-
9a
-
f
]
{
0
4
}
:
)
{
0
7
}
[
0
-
9a
-
f
]
{
0
4
}
\
]
?
/
i
REGEXP_COMMON_EMAIL
:
/
^
[
\
w
!
#
%
&
'
*
+
/
=
?
^
{
|
}
~
.
-
]
+
[
\
[
\
]
A
-
Z0
-
9
.
-
]
+
/
i
REGEXP_HAS_PORT
:
/
:
\
d
+
/
REGEXP_PERCENT_ENCODED_START
:
/
^
(
%
[
0
-
9a
-
f
]
{
2
}
)
{
2
}
/
i
REGEXP_PREFIX
:
/
^
[
a
-
z
-
]
+
:
(
?
:
\
/
)
{
0
2
}
/
i
TYPE
:
{
TEXT
:
1
POSSIBLE_ORIGIN
:
2
POSSIBLE_URL
:
3
RESTRICT_HISTORY
:
4
RESTRICT_BOOKMARK
:
5
RESTRICT_TAG
:
6
RESTRICT_OPENPAGE
:
7
RESTRICT_SEARCH
:
8
RESTRICT_TITLE
:
9
RESTRICT_URL
:
10
RESTRICT_ACTION
:
11
}
RESTRICT
:
{
HISTORY
:
"
^
"
BOOKMARK
:
"
*
"
TAG
:
"
+
"
OPENPAGE
:
"
%
"
SEARCH
:
"
?
"
TITLE
:
"
#
"
URL
:
"
"
ACTION
:
"
>
"
}
get
SEARCH_MODE_RESTRICT
(
)
{
return
new
Set
(
[
this
.
RESTRICT
.
HISTORY
this
.
RESTRICT
.
BOOKMARK
this
.
RESTRICT
.
OPENPAGE
this
.
RESTRICT
.
SEARCH
this
.
RESTRICT
.
ACTION
]
)
;
}
looksLikeUrl
(
token
{
requirePath
=
false
}
=
{
}
)
{
if
(
token
.
length
<
2
)
{
return
false
;
}
if
(
token
.
startsWith
(
"
data
:
"
)
)
{
return
token
.
length
>
5
;
}
if
(
this
.
REGEXP_SPACES
.
test
(
token
)
)
{
return
false
;
}
if
(
this
.
REGEXP_LIKE_PROTOCOL
.
test
(
token
)
)
{
return
true
;
}
let
slashIndex
=
token
.
indexOf
(
"
/
"
)
;
let
prePath
=
slashIndex
!
=
-
1
?
token
.
slice
(
0
slashIndex
)
:
token
;
if
(
!
this
.
looksLikeOrigin
(
prePath
{
ignoreKnownDomains
:
true
}
)
)
{
return
false
;
}
let
path
=
slashIndex
!
=
-
1
?
token
.
slice
(
slashIndex
)
:
"
"
;
lazy
.
logger
.
debug
(
"
path
"
path
)
;
if
(
requirePath
&
&
!
path
)
{
return
false
;
}
let
atIndex
=
prePath
.
indexOf
(
"
"
)
;
let
userinfo
=
atIndex
!
=
-
1
?
prePath
.
slice
(
0
atIndex
)
:
"
"
;
if
(
path
.
length
&
&
userinfo
.
length
)
{
return
true
;
}
if
(
/
^
\
/
[
a
-
z
]
/
i
.
test
(
path
)
)
{
return
true
;
}
if
(
[
"
%
"
"
?
"
"
#
"
]
.
some
(
c
=
>
path
.
includes
(
c
)
)
)
{
return
true
;
}
let
hostPort
=
atIndex
!
=
-
1
?
prePath
.
slice
(
atIndex
+
1
)
:
prePath
;
if
(
this
.
REGEXP_HOSTPORT_IPV4
.
test
(
hostPort
)
)
{
return
true
;
}
if
(
this
.
REGEXP_HOSTPORT_IPV6
.
test
(
hostPort
)
&
&
[
"
[
"
"
]
"
"
:
"
]
.
some
(
c
=
>
hostPort
.
includes
(
c
)
)
)
{
return
true
;
}
if
(
Services
.
uriFixup
.
isDomainKnown
(
hostPort
)
)
{
return
true
;
}
return
false
;
}
looksLikeOrigin
(
token
{
ignoreKnownDomains
=
false
noIp
=
false
noPort
=
false
}
=
{
}
)
{
if
(
!
token
.
length
)
{
return
false
;
}
let
atIndex
=
token
.
indexOf
(
"
"
)
;
if
(
atIndex
!
=
-
1
&
&
this
.
REGEXP_COMMON_EMAIL
.
test
(
token
)
)
{
return
false
;
}
let
userinfo
=
atIndex
!
=
-
1
?
token
.
slice
(
0
atIndex
)
:
"
"
;
let
hostPort
=
atIndex
!
=
-
1
?
token
.
slice
(
atIndex
+
1
)
:
token
;
let
hasPort
=
this
.
REGEXP_HAS_PORT
.
test
(
hostPort
)
;
lazy
.
logger
.
debug
(
"
userinfo
"
userinfo
)
;
lazy
.
logger
.
debug
(
"
hostPort
"
hostPort
)
;
if
(
noPort
&
&
hasPort
)
{
return
false
;
}
if
(
this
.
REGEXP_HOSTPORT_IPV4
.
test
(
hostPort
)
|
|
this
.
REGEXP_HOSTPORT_IPV6
.
test
(
hostPort
)
)
{
return
!
noIp
;
}
if
(
this
.
REGEXP_LIKE_PROTOCOL
.
test
(
hostPort
)
|
|
this
.
REGEXP_USERINFO_INVALID_CHARS
.
test
(
userinfo
)
|
|
this
.
REGEXP_HOSTPORT_INVALID_CHARS
.
test
(
hostPort
)
|
|
(
!
this
.
REGEXP_SINGLE_WORD_HOST
.
test
(
hostPort
)
&
&
this
.
REGEXP_HOSTPORT_IP_LIKE
.
test
(
hostPort
)
&
&
this
.
REGEXP_HOSTPORT_INVALID_IP
.
test
(
hostPort
)
)
)
{
return
false
;
}
if
(
!
ignoreKnownDomains
&
&
!
userinfo
&
&
!
hasPort
&
&
this
.
REGEXP_SINGLE_WORD_HOST
.
test
(
hostPort
)
)
{
return
Services
.
uriFixup
.
isDomainKnown
(
hostPort
)
;
}
return
true
;
}
tokenize
(
queryContext
)
{
lazy
.
logger
.
info
(
"
Tokenizing
"
queryContext
)
;
if
(
!
queryContext
.
trimmedSearchString
)
{
queryContext
.
tokens
=
[
]
;
return
queryContext
;
}
let
unfiltered
=
splitString
(
queryContext
.
searchString
)
;
let
tokens
=
filterTokens
(
unfiltered
)
;
queryContext
.
tokens
=
tokens
;
return
queryContext
;
}
isRestrictionToken
(
token
)
{
return
(
token
&
&
token
.
type
>
=
this
.
TYPE
.
RESTRICT_HISTORY
&
&
token
.
type
<
=
this
.
TYPE
.
RESTRICT_URL
)
;
}
}
;
const
CHAR_TO_TYPE_MAP
=
new
Map
(
Object
.
entries
(
UrlbarTokenizer
.
RESTRICT
)
.
map
(
(
[
type
char
]
)
=
>
[
char
UrlbarTokenizer
.
TYPE
[
RESTRICT_
{
type
}
]
]
)
)
;
function
splitString
(
searchString
)
{
let
trimmed
=
searchString
.
trim
(
)
;
let
tokens
=
trimmed
.
startsWith
(
"
data
:
"
)
?
[
trimmed
]
:
trimmed
.
split
(
UrlbarTokenizer
.
REGEXP_SPACES
)
;
if
(
!
tokens
.
length
)
{
return
tokens
;
}
const
hasRestrictionToken
=
tokens
.
some
(
t
=
>
CHAR_TO_TYPE_MAP
.
has
(
t
)
)
;
if
(
hasRestrictionToken
)
{
return
tokens
;
}
const
firstToken
=
tokens
[
0
]
;
if
(
CHAR_TO_TYPE_MAP
.
has
(
firstToken
[
0
]
)
&
&
!
UrlbarTokenizer
.
REGEXP_PERCENT_ENCODED_START
.
test
(
firstToken
)
)
{
tokens
[
0
]
=
firstToken
.
substring
(
1
)
;
tokens
.
splice
(
0
0
firstToken
[
0
]
)
;
return
tokens
;
}
const
lastIndex
=
tokens
.
length
-
1
;
const
lastToken
=
tokens
[
lastIndex
]
;
if
(
lastToken
[
lastToken
.
length
-
1
]
=
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
&
&
!
UrlbarTokenizer
.
looksLikeUrl
(
lastToken
{
requirePath
:
true
}
)
)
{
tokens
[
lastIndex
]
=
lastToken
.
substring
(
0
lastToken
.
length
-
1
)
;
tokens
.
push
(
lastToken
[
lastToken
.
length
-
1
]
)
;
}
return
tokens
;
}
function
filterTokens
(
tokens
)
{
let
filtered
=
[
]
;
let
restrictions
=
[
]
;
for
(
let
i
=
0
;
i
<
tokens
.
length
;
+
+
i
)
{
let
token
=
tokens
[
i
]
;
let
tokenObj
=
{
value
:
token
lowerCaseValue
:
token
.
toLocaleLowerCase
(
)
type
:
UrlbarTokenizer
.
TYPE
.
TEXT
}
;
let
restrictionType
=
CHAR_TO_TYPE_MAP
.
get
(
token
)
;
if
(
restrictionType
)
{
restrictions
.
push
(
{
index
:
i
type
:
restrictionType
}
)
;
}
else
if
(
UrlbarTokenizer
.
looksLikeOrigin
(
token
)
)
{
tokenObj
.
type
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_ORIGIN
;
}
else
if
(
UrlbarTokenizer
.
looksLikeUrl
(
token
{
requirePath
:
true
}
)
)
{
tokenObj
.
type
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_URL
;
}
filtered
.
push
(
tokenObj
)
;
}
if
(
restrictions
.
length
)
{
let
matchingRestrictionFound
=
false
;
let
typeRestrictionFound
=
false
;
function
assignRestriction
(
r
)
{
if
(
r
&
&
!
(
matchingRestrictionFound
&
&
typeRestrictionFound
)
)
{
if
(
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_TITLE
UrlbarTokenizer
.
TYPE
.
RESTRICT_URL
]
.
includes
(
r
.
type
)
)
{
if
(
!
matchingRestrictionFound
)
{
matchingRestrictionFound
=
true
;
filtered
[
r
.
index
]
.
type
=
r
.
type
;
return
true
;
}
}
else
if
(
!
typeRestrictionFound
)
{
typeRestrictionFound
=
true
;
filtered
[
r
.
index
]
.
type
=
r
.
type
;
return
true
;
}
}
return
false
;
}
let
found
=
assignRestriction
(
restrictions
.
find
(
r
=
>
r
.
index
=
=
0
)
)
;
if
(
found
)
{
assignRestriction
(
restrictions
.
find
(
r
=
>
r
.
index
=
=
1
)
)
;
}
let
lastIndex
=
tokens
.
length
-
1
;
found
=
assignRestriction
(
restrictions
.
find
(
r
=
>
r
.
index
=
=
lastIndex
)
)
;
if
(
found
)
{
assignRestriction
(
restrictions
.
find
(
r
=
>
r
.
index
=
=
lastIndex
-
1
)
)
;
}
}
lazy
.
logger
.
info
(
"
Filtered
Tokens
"
tokens
)
;
return
filtered
;
}
