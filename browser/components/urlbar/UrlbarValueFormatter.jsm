"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarValueFormatter
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
class
UrlbarValueFormatter
{
constructor
(
urlbarInput
)
{
this
.
urlbarInput
=
urlbarInput
;
this
.
window
=
this
.
urlbarInput
.
window
;
this
.
document
=
this
.
window
.
document
;
this
.
_formattingApplied
=
false
;
this
.
window
.
addEventListener
(
"
resize
"
this
)
;
}
get
inputField
(
)
{
return
this
.
urlbarInput
.
inputField
;
}
get
scheme
(
)
{
return
this
.
urlbarInput
.
querySelector
(
"
#
urlbar
-
scheme
"
)
;
}
update
(
)
{
if
(
!
this
.
inputField
.
value
)
{
return
;
}
this
.
_removeURLFormat
(
)
;
this
.
_removeSearchAliasFormat
(
)
;
this
.
_formattingApplied
=
this
.
_formatURL
(
)
|
|
this
.
_formatSearchAlias
(
)
;
}
_ensureFormattedHostVisible
(
urlMetaData
)
{
let
instance
=
(
this
.
_formatURLInstance
=
{
}
)
;
this
.
window
.
requestAnimationFrame
(
(
)
=
>
{
if
(
this
.
_formatURLInstance
!
=
instance
)
{
return
;
}
urlMetaData
=
urlMetaData
|
|
this
.
_getUrlMetaData
(
)
;
if
(
!
urlMetaData
)
{
return
;
}
let
{
url
preDomain
domain
}
=
urlMetaData
;
let
directionality
=
this
.
window
.
windowUtils
.
getDirectionFromText
(
domain
)
;
if
(
directionality
=
=
this
.
window
.
windowUtils
.
DIRECTION_RTL
&
&
url
[
preDomain
.
length
+
domain
.
length
]
!
=
"
\
u200E
"
)
{
this
.
urlbarInput
.
setAttribute
(
"
hasrtldomain
"
"
true
"
)
;
this
.
inputField
.
scrollLeft
=
this
.
inputField
.
scrollLeftMax
;
}
else
{
this
.
urlbarInput
.
removeAttribute
(
"
hasrtldomain
"
)
;
this
.
inputField
.
scrollLeft
=
0
;
}
}
)
;
}
_getUrlMetaData
(
)
{
if
(
this
.
urlbarInput
.
focused
)
{
return
null
;
}
let
url
=
this
.
inputField
.
value
;
let
flags
=
Services
.
uriFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
|
Services
.
uriFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
)
{
flags
|
=
Services
.
uriFixup
.
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
let
uriInfo
;
try
{
uriInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
url
flags
)
;
}
catch
(
ex
)
{
}
if
(
!
uriInfo
|
|
!
uriInfo
.
fixedURI
|
|
uriInfo
.
keywordProviderName
|
|
!
[
"
http
"
"
https
"
"
ftp
"
]
.
includes
(
uriInfo
.
fixedURI
.
scheme
)
)
{
return
null
;
}
let
trimmedLength
=
0
;
if
(
uriInfo
.
fixedURI
.
scheme
=
=
"
http
"
&
&
!
url
.
startsWith
(
"
http
:
/
/
"
)
)
{
url
=
"
http
:
/
/
"
+
url
;
trimmedLength
=
"
http
:
/
/
"
.
length
;
}
let
matchedURL
=
url
.
match
(
/
^
(
(
[
a
-
z
]
+
:
\
/
\
/
)
(
?
:
[
^
\
/
#
?
]
+
)
?
)
(
\
S
+
?
)
(
?
:
:
\
d
+
)
?
\
s
*
(
?
:
[
\
/
#
?
]
|
)
/
)
;
if
(
!
matchedURL
)
{
return
null
;
}
let
[
preDomain
schemeWSlashes
domain
]
=
matchedURL
;
let
replaceUrl
=
false
;
try
{
replaceUrl
=
Services
.
io
.
newURI
(
"
http
:
/
/
"
+
domain
)
.
displayHost
!
=
uriInfo
.
fixedURI
.
displayHost
;
}
catch
(
ex
)
{
return
null
;
}
if
(
replaceUrl
)
{
if
(
this
.
_inGetUrlMetaData
)
{
return
null
;
}
try
{
this
.
_inGetUrlMetaData
=
true
;
this
.
window
.
gBrowser
.
userTypedValue
=
null
;
this
.
urlbarInput
.
setURI
(
uriInfo
.
fixedURI
)
;
return
this
.
_getUrlMetaData
(
)
;
}
finally
{
this
.
_inGetUrlMetaData
=
false
;
}
}
return
{
preDomain
schemeWSlashes
domain
url
uriInfo
trimmedLength
}
;
}
_removeURLFormat
(
)
{
this
.
scheme
.
value
=
"
"
;
if
(
!
this
.
_formattingApplied
)
{
return
;
}
let
controller
=
this
.
urlbarInput
.
editor
.
selectionController
;
let
strikeOut
=
controller
.
getSelection
(
controller
.
SELECTION_URLSTRIKEOUT
)
;
strikeOut
.
removeAllRanges
(
)
;
let
selection
=
controller
.
getSelection
(
controller
.
SELECTION_URLSECONDARY
)
;
selection
.
removeAllRanges
(
)
;
this
.
_formatScheme
(
controller
.
SELECTION_URLSTRIKEOUT
true
)
;
this
.
_formatScheme
(
controller
.
SELECTION_URLSECONDARY
true
)
;
this
.
inputField
.
style
.
setProperty
(
"
-
-
urlbar
-
scheme
-
size
"
"
0px
"
)
;
}
_formatURL
(
)
{
let
urlMetaData
=
this
.
_getUrlMetaData
(
)
;
if
(
!
urlMetaData
)
{
return
false
;
}
let
{
url
uriInfo
preDomain
schemeWSlashes
domain
trimmedLength
}
=
urlMetaData
;
if
(
!
UrlbarPrefs
.
get
(
"
trimURLs
"
)
|
|
schemeWSlashes
!
=
"
http
:
/
/
"
)
{
this
.
scheme
.
value
=
schemeWSlashes
;
this
.
inputField
.
style
.
setProperty
(
"
-
-
urlbar
-
scheme
-
size
"
schemeWSlashes
.
length
+
"
ch
"
)
;
}
this
.
_ensureFormattedHostVisible
(
urlMetaData
)
;
if
(
!
UrlbarPrefs
.
get
(
"
formatting
.
enabled
"
)
)
{
return
false
;
}
let
editor
=
this
.
urlbarInput
.
editor
;
let
controller
=
editor
.
selectionController
;
this
.
_formatScheme
(
controller
.
SELECTION_URLSECONDARY
)
;
let
textNode
=
editor
.
rootElement
.
firstChild
;
if
(
this
.
urlbarInput
.
getAttribute
(
"
pageproxystate
"
)
=
=
"
valid
"
&
&
url
.
startsWith
(
"
https
:
"
)
&
&
this
.
window
.
gBrowser
.
securityUI
.
state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
{
let
range
=
this
.
document
.
createRange
(
)
;
range
.
setStart
(
textNode
0
)
;
range
.
setEnd
(
textNode
5
)
;
let
strikeOut
=
controller
.
getSelection
(
controller
.
SELECTION_URLSTRIKEOUT
)
;
strikeOut
.
addRange
(
range
)
;
this
.
_formatScheme
(
controller
.
SELECTION_URLSTRIKEOUT
)
;
}
let
baseDomain
=
domain
;
let
subDomain
=
"
"
;
try
{
baseDomain
=
Services
.
eTLD
.
getBaseDomainFromHost
(
uriInfo
.
fixedURI
.
host
)
;
if
(
!
domain
.
endsWith
(
baseDomain
)
)
{
let
IDNService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
baseDomain
=
IDNService
.
convertACEtoUTF8
(
baseDomain
)
;
}
}
catch
(
e
)
{
}
if
(
baseDomain
!
=
domain
)
{
subDomain
=
domain
.
slice
(
0
-
baseDomain
.
length
)
;
}
let
selection
=
controller
.
getSelection
(
controller
.
SELECTION_URLSECONDARY
)
;
let
rangeLength
=
preDomain
.
length
+
subDomain
.
length
-
trimmedLength
;
if
(
rangeLength
)
{
let
range
=
this
.
document
.
createRange
(
)
;
range
.
setStart
(
textNode
0
)
;
range
.
setEnd
(
textNode
rangeLength
)
;
selection
.
addRange
(
range
)
;
}
let
startRest
=
preDomain
.
length
+
domain
.
length
-
trimmedLength
;
if
(
startRest
<
url
.
length
-
trimmedLength
)
{
let
range
=
this
.
document
.
createRange
(
)
;
range
.
setStart
(
textNode
startRest
)
;
range
.
setEnd
(
textNode
url
.
length
-
trimmedLength
)
;
selection
.
addRange
(
range
)
;
}
return
true
;
}
_formatScheme
(
selectionType
clear
)
{
let
editor
=
this
.
scheme
.
editor
;
let
controller
=
editor
.
selectionController
;
let
textNode
=
editor
.
rootElement
.
firstChild
;
let
selection
=
controller
.
getSelection
(
selectionType
)
;
if
(
clear
)
{
selection
.
removeAllRanges
(
)
;
}
else
{
let
r
=
this
.
document
.
createRange
(
)
;
r
.
setStart
(
textNode
0
)
;
r
.
setEnd
(
textNode
textNode
.
textContent
.
length
)
;
selection
.
addRange
(
r
)
;
}
}
_removeSearchAliasFormat
(
)
{
if
(
!
this
.
_formattingApplied
)
{
return
;
}
let
selection
=
this
.
urlbarInput
.
editor
.
selectionController
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
selection
.
removeAllRanges
(
)
;
}
_formatSearchAlias
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
formatting
.
enabled
"
)
)
{
return
false
;
}
let
editor
=
this
.
urlbarInput
.
editor
;
let
textNode
=
editor
.
rootElement
.
firstChild
;
let
value
=
textNode
.
textContent
;
let
trimmedValue
=
value
.
trim
(
)
;
if
(
!
trimmedValue
.
startsWith
(
"
"
)
|
|
(
this
.
urlbarInput
.
popup
|
|
this
.
urlbarInput
.
view
)
.
oneOffSearchButtons
.
selectedButton
)
{
return
false
;
}
let
alias
=
this
.
_getSearchAlias
(
)
;
if
(
!
alias
)
{
return
false
;
}
if
(
trimmedValue
!
=
alias
&
&
!
trimmedValue
.
startsWith
(
alias
+
"
"
)
)
{
return
false
;
}
let
index
=
value
.
indexOf
(
alias
)
;
if
(
index
<
0
)
{
return
false
;
}
let
selection
=
editor
.
selectionController
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
let
range
=
this
.
document
.
createRange
(
)
;
range
.
setStart
(
textNode
index
)
;
range
.
setEnd
(
textNode
index
+
alias
.
length
)
;
selection
.
addRange
(
range
)
;
let
fg
=
"
#
2362d7
"
;
let
bg
=
"
#
d2e6fd
"
;
if
(
this
.
document
.
documentElement
.
querySelector
(
"
:
-
moz
-
lwtheme
"
)
|
|
(
AppConstants
.
platform
=
=
"
win
"
&
&
this
.
window
.
matchMedia
(
"
(
-
moz
-
windows
-
default
-
theme
:
0
)
"
)
.
matches
)
)
{
selection
.
setColors
(
fg
bg
"
currentColor
"
"
currentColor
"
)
;
}
else
{
selection
.
setColors
(
fg
bg
fg
bg
)
;
}
return
true
;
}
_getSearchAlias
(
)
{
this
.
_selectedResult
=
this
.
urlbarInput
.
view
.
selectedResult
|
|
this
.
_selectedResult
;
if
(
this
.
_selectedResult
&
&
this
.
_selectedResult
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
)
{
return
this
.
_selectedResult
.
payload
.
keyword
|
|
null
;
}
return
null
;
}
handleEvent
(
event
)
{
let
methodName
=
"
_on_
"
+
event
.
type
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
event
)
;
}
else
{
throw
new
Error
(
"
Unrecognized
UrlbarValueFormatter
event
:
"
+
event
.
type
)
;
}
}
_on_resize
(
event
)
{
if
(
event
.
target
!
=
this
.
window
)
{
return
;
}
if
(
this
.
_resizeThrottleTimeout
)
{
this
.
window
.
clearTimeout
(
this
.
_resizeThrottleTimeout
)
;
}
this
.
_resizeThrottleTimeout
=
this
.
window
.
setTimeout
(
(
)
=
>
{
this
.
_resizeThrottleTimeout
=
null
;
this
.
_ensureFormattedHostVisible
(
)
;
}
100
)
;
}
}
