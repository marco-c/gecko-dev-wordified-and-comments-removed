"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarPrefs
"
"
UrlbarPrefsObserver
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
PREF_URLBAR_BRANCH
=
"
browser
.
urlbar
.
"
;
const
PREF_URLBAR_DEFAULTS
=
new
Map
(
[
[
"
accessibility
.
tabToSearch
.
announceResults
"
true
]
[
"
autoFill
"
true
]
[
"
autoFill
.
searchEngines
"
false
]
[
"
autoFill
.
stddevMultiplier
"
[
0
.
0
"
float
"
]
]
[
"
ctrlCanonizesURLs
"
true
]
[
"
decodeURLsOnCopy
"
false
]
[
"
delay
"
50
]
[
"
disableExtendForTests
"
false
]
[
"
dnsResolveFullyQualifiedNames
"
true
]
[
"
dnsResolveSingleWordsAfterSearch
"
1
]
[
"
eventTelemetry
.
enabled
"
false
]
[
"
experimental
.
expandTextOnFocus
"
false
]
[
"
experimental
.
hideHeuristic
"
false
]
[
"
experimental
.
searchButton
"
false
]
[
"
extension
.
timeout
"
400
]
[
"
filter
.
javascript
"
true
]
[
"
formatting
.
enabled
"
true
]
[
"
groupLabels
.
enabled
"
true
]
[
"
keepPanelOpenDuringImeComposition
"
false
]
[
"
maxCharsForSearchSuggestions
"
100
]
[
"
maxHistoricalSearchSuggestions
"
0
]
[
"
maxRichResults
"
10
]
[
"
merino
.
enabled
"
false
]
[
"
merino
.
endpointURL
"
"
https
:
/
/
merino
.
services
.
mozilla
.
com
/
api
/
v1
/
suggest
"
]
[
"
openintab
"
false
]
[
"
restyleSearches
"
false
]
[
"
resultGroups
"
"
"
]
[
"
richSuggestions
.
tail
"
true
]
[
"
searchTips
.
test
.
ignoreShowLimits
"
false
]
[
"
shortcuts
.
bookmarks
"
true
]
[
"
shortcuts
.
tabs
"
true
]
[
"
shortcuts
.
history
"
true
]
[
"
showSearchSuggestionsFirst
"
true
]
[
"
speculativeConnect
.
enabled
"
true
]
[
"
suggest
.
bookmark
"
true
]
[
"
suggest
.
calculator
"
false
]
[
"
suggest
.
engines
"
true
]
[
"
suggest
.
history
"
true
]
[
"
suggest
.
openpage
"
true
]
[
"
suggest
.
quicksuggest
"
false
]
[
"
suggest
.
quicksuggest
.
sponsored
"
false
]
[
"
suggest
.
searches
"
false
]
[
"
suggest
.
topsites
"
true
]
[
"
quicksuggest
.
enabled
"
false
]
[
"
quicksuggest
.
log
"
false
]
[
"
quicksuggest
.
remoteSettings
.
enabled
"
true
]
[
"
quicksuggest
.
scenario
"
"
history
"
]
[
"
quicksuggest
.
shouldShowOnboardingDialog
"
true
]
[
"
quicksuggest
.
showedOnboardingDialog
"
false
]
[
"
quicksuggest
.
seenRestarts
"
0
]
[
"
switchTabs
.
adoptIntoActiveWindow
"
false
]
[
"
tabToSearch
.
onboard
.
interactionsLeft
"
3
]
[
"
tipShownCount
.
searchTip_onboard
"
0
]
[
"
tipShownCount
.
searchTip_redirect
"
0
]
[
"
trimURLs
"
true
]
[
"
sponsoredTopSites
"
false
]
[
"
unitConversion
.
enabled
"
false
]
[
"
unitConversion
.
suggestedIndex
"
1
]
[
"
usepreloadedtopurls
.
enabled
"
false
]
[
"
usepreloadedtopurls
.
expire_days
"
14
]
[
"
update2
.
emptySearchBehavior
"
0
]
]
)
;
const
PREF_OTHER_DEFAULTS
=
new
Map
(
[
[
"
browser
.
fixup
.
dns_first_for_single_words
"
false
]
[
"
browser
.
search
.
suggest
.
enabled
"
true
]
[
"
browser
.
search
.
suggest
.
enabled
.
private
"
false
]
[
"
keyword
.
enabled
"
true
]
[
"
ui
.
popup
.
disable_autohide
"
false
]
]
)
;
const
SUGGEST_PREF_TO_BEHAVIOR
=
{
history
:
"
history
"
bookmark
:
"
bookmark
"
openpage
:
"
openpage
"
searches
:
"
search
"
}
;
const
PREF_TYPES
=
new
Map
(
[
[
"
boolean
"
"
Bool
"
]
[
"
float
"
"
Float
"
]
[
"
number
"
"
Int
"
]
[
"
string
"
"
Char
"
]
]
)
;
function
makeResultBuckets
(
{
showSearchSuggestionsFirst
}
)
{
let
rootBucket
=
{
children
:
[
{
maxResultCount
:
1
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_EXTENSION
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_SEARCH_TIP
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_OMNIBOX
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_ENGINE_ALIAS
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_BOOKMARK_KEYWORD
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_AUTOFILL
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_PRELOADED
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TOKEN_ALIAS_ENGINE
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_FALLBACK
}
]
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
OMNIBOX
availableSpan
:
UrlbarUtils
.
MAX_OMNIBOX_RESULT_COUNT
-
1
}
]
}
;
let
mainBucket
=
{
flexChildren
:
true
children
:
[
{
children
:
[
{
flexChildren
:
true
children
:
[
{
flex
:
2
group
:
UrlbarUtils
.
RESULT_GROUP
.
FORM_HISTORY
}
{
flex
:
4
group
:
UrlbarUtils
.
RESULT_GROUP
.
REMOTE_SUGGESTION
}
]
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
TAIL_SUGGESTION
}
]
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL_PARENT
children
:
[
{
availableSpan
:
3
group
:
UrlbarUtils
.
RESULT_GROUP
.
INPUT_HISTORY
}
{
flexChildren
:
true
children
:
[
{
flex
:
1
group
:
UrlbarUtils
.
RESULT_GROUP
.
REMOTE_TAB
}
{
flex
:
2
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
flex
:
2
group
:
UrlbarUtils
.
RESULT_GROUP
.
ABOUT_PAGES
}
{
flex
:
1
group
:
UrlbarUtils
.
RESULT_GROUP
.
PRELOADED
}
]
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
INPUT_HISTORY
}
]
}
]
}
;
if
(
!
showSearchSuggestionsFirst
)
{
mainBucket
.
children
.
reverse
(
)
;
}
mainBucket
.
children
[
0
]
.
flex
=
2
;
mainBucket
.
children
[
1
]
.
flex
=
1
;
rootBucket
.
children
.
push
(
mainBucket
)
;
return
rootBucket
;
}
class
Preferences
{
constructor
(
)
{
this
.
_map
=
new
Map
(
)
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
;
Services
.
prefs
.
addObserver
(
PREF_URLBAR_BRANCH
this
true
)
;
for
(
let
pref
of
PREF_OTHER_DEFAULTS
.
keys
(
)
)
{
Services
.
prefs
.
addObserver
(
pref
this
true
)
;
}
this
.
_observerWeakRefs
=
[
]
;
this
.
addObserver
(
this
)
;
this
.
shouldHandOffToSearchModePrefs
=
[
"
keyword
.
enabled
"
"
suggest
.
searches
"
]
;
NimbusFeatures
.
urlbar
.
onUpdate
(
(
)
=
>
this
.
_onNimbusUpdate
(
)
)
;
}
get
(
pref
)
{
let
value
=
this
.
_map
.
get
(
pref
)
;
if
(
value
=
=
=
undefined
)
{
value
=
this
.
_getPrefValue
(
pref
)
;
this
.
_map
.
set
(
pref
value
)
;
}
return
value
;
}
set
(
pref
value
)
{
let
{
defaultValue
set
}
=
this
.
_getPrefDescriptor
(
pref
)
;
if
(
typeof
value
!
=
typeof
defaultValue
)
{
throw
new
Error
(
Invalid
value
type
{
typeof
value
}
for
pref
{
pref
}
)
;
}
set
(
pref
value
)
;
}
clear
(
pref
)
{
let
{
clear
}
=
this
.
_getPrefDescriptor
(
pref
)
;
clear
(
pref
)
;
}
makeResultBuckets
(
options
)
{
return
makeResultBuckets
(
options
)
;
}
migrateResultBuckets
(
)
{
this
.
set
(
"
resultGroups
"
JSON
.
stringify
(
makeResultBuckets
(
{
showSearchSuggestionsFirst
:
this
.
get
(
"
showSearchSuggestionsFirst
"
)
}
)
)
)
;
}
addObserver
(
observer
)
{
this
.
_observerWeakRefs
.
push
(
Cu
.
getWeakReference
(
observer
)
)
;
}
observe
(
subject
topic
data
)
{
let
pref
=
data
.
replace
(
PREF_URLBAR_BRANCH
"
"
)
;
if
(
!
PREF_URLBAR_DEFAULTS
.
has
(
pref
)
&
&
!
PREF_OTHER_DEFAULTS
.
has
(
pref
)
)
{
return
;
}
for
(
let
i
=
0
;
i
<
this
.
_observerWeakRefs
.
length
;
)
{
let
observer
=
this
.
_observerWeakRefs
[
i
]
.
get
(
)
;
if
(
!
observer
)
{
this
.
_observerWeakRefs
.
splice
(
i
1
)
;
}
else
{
observer
.
onPrefChanged
(
pref
)
;
+
+
i
;
}
}
}
onPrefChanged
(
pref
)
{
this
.
_map
.
delete
(
pref
)
;
switch
(
pref
)
{
case
"
showSearchSuggestionsFirst
"
:
this
.
set
(
"
resultGroups
"
JSON
.
stringify
(
makeResultBuckets
(
{
showSearchSuggestionsFirst
:
this
.
get
(
pref
)
}
)
)
)
;
return
;
}
if
(
pref
.
startsWith
(
"
suggest
.
"
)
)
{
this
.
_map
.
delete
(
"
defaultBehavior
"
)
;
}
if
(
this
.
shouldHandOffToSearchModePrefs
.
includes
(
pref
)
)
{
this
.
_map
.
delete
(
"
shouldHandOffToSearchMode
"
)
;
}
}
_onNimbusUpdate
(
)
{
for
(
let
key
of
Object
.
keys
(
this
.
_nimbus
)
)
{
this
.
_map
.
delete
(
key
)
;
}
this
.
__nimbus
=
null
;
}
get
_nimbus
(
)
{
if
(
!
this
.
__nimbus
)
{
this
.
__nimbus
=
NimbusFeatures
.
urlbar
.
getAllVariables
(
)
;
}
return
this
.
__nimbus
;
}
_readPref
(
pref
)
{
let
{
defaultValue
get
}
=
this
.
_getPrefDescriptor
(
pref
)
;
return
get
(
pref
defaultValue
)
;
}
_getPrefValue
(
pref
)
{
switch
(
pref
)
{
case
"
defaultBehavior
"
:
{
let
val
=
0
;
for
(
let
type
of
Object
.
keys
(
SUGGEST_PREF_TO_BEHAVIOR
)
)
{
let
behavior
=
BEHAVIOR_
{
SUGGEST_PREF_TO_BEHAVIOR
[
type
]
.
toUpperCase
(
)
}
;
val
|
=
this
.
get
(
"
suggest
.
"
+
type
)
&
&
Ci
.
mozIPlacesAutoComplete
[
behavior
]
;
}
return
val
;
}
case
"
resultGroups
"
:
try
{
return
JSON
.
parse
(
this
.
_readPref
(
pref
)
)
;
}
catch
(
ex
)
{
}
return
makeResultBuckets
(
{
showSearchSuggestionsFirst
:
this
.
get
(
"
showSearchSuggestionsFirst
"
)
}
)
;
case
"
shouldHandOffToSearchMode
"
:
return
this
.
shouldHandOffToSearchModePrefs
.
some
(
prefName
=
>
!
this
.
get
(
prefName
)
)
;
}
return
this
.
_readPref
(
pref
)
;
}
_getPrefDescriptor
(
pref
)
{
let
branch
=
Services
.
prefs
.
getBranch
(
PREF_URLBAR_BRANCH
)
;
let
defaultValue
=
PREF_URLBAR_DEFAULTS
.
get
(
pref
)
;
if
(
defaultValue
=
=
=
undefined
)
{
branch
=
Services
.
prefs
;
defaultValue
=
PREF_OTHER_DEFAULTS
.
get
(
pref
)
;
if
(
defaultValue
=
=
=
undefined
)
{
let
nimbus
=
this
.
_getNimbusDescriptor
(
pref
)
;
if
(
nimbus
)
{
return
nimbus
;
}
throw
new
Error
(
"
Trying
to
access
an
unknown
pref
"
+
pref
)
;
}
}
let
type
;
if
(
!
Array
.
isArray
(
defaultValue
)
)
{
type
=
PREF_TYPES
.
get
(
typeof
defaultValue
)
;
}
else
{
if
(
defaultValue
.
length
!
=
2
)
{
throw
new
Error
(
"
Malformed
pref
def
:
"
+
pref
)
;
}
[
defaultValue
type
]
=
defaultValue
;
type
=
PREF_TYPES
.
get
(
type
)
;
}
if
(
!
type
)
{
throw
new
Error
(
"
Unknown
pref
type
:
"
+
pref
)
;
}
return
{
defaultValue
get
:
branch
[
get
{
type
}
Pref
]
set
:
branch
[
set
{
type
=
=
"
Float
"
?
"
Char
"
:
type
}
Pref
]
clear
:
branch
.
clearUserPref
}
;
}
_getNimbusDescriptor
(
name
)
{
if
(
!
this
.
_nimbus
.
hasOwnProperty
(
name
)
)
{
return
null
;
}
return
{
defaultValue
:
this
.
_nimbus
[
name
]
get
:
(
)
=
>
this
.
_nimbus
[
name
]
set
(
)
{
throw
new
Error
(
'
{
name
}
'
is
a
Nimbus
value
and
cannot
be
set
)
;
}
clear
(
)
{
throw
new
Error
(
'
{
name
}
'
is
a
Nimbus
value
and
cannot
be
cleared
)
;
}
}
;
}
initializeShowSearchSuggestionsFirstPref
(
)
{
let
matchBuckets
=
[
]
;
let
pref
=
Services
.
prefs
.
getCharPref
(
"
browser
.
urlbar
.
matchBuckets
"
"
"
)
;
try
{
matchBuckets
=
pref
.
split
(
"
"
)
.
map
(
v
=
>
{
let
bucket
=
v
.
split
(
"
:
"
)
;
return
[
bucket
[
0
]
.
trim
(
)
.
toLowerCase
(
)
Number
(
bucket
[
1
]
)
]
;
}
)
;
}
catch
(
ex
)
{
}
let
bucketNames
=
matchBuckets
.
map
(
bucket
=
>
bucket
[
0
]
)
;
let
suggestionIndex
=
bucketNames
.
indexOf
(
"
suggestion
"
)
;
let
generalIndex
=
bucketNames
.
indexOf
(
"
general
"
)
;
let
showSearchSuggestionsFirst
=
generalIndex
<
0
|
|
(
suggestionIndex
>
=
0
&
&
suggestionIndex
<
generalIndex
)
;
let
oldValue
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
showSearchSuggestionsFirst
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
showSearchSuggestionsFirst
"
showSearchSuggestionsFirst
)
;
if
(
oldValue
=
=
showSearchSuggestionsFirst
)
{
this
.
onPrefChanged
(
"
showSearchSuggestionsFirst
"
)
;
}
}
}
var
UrlbarPrefs
=
new
Preferences
(
)
;
