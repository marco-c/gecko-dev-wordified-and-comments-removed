"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarPrefs
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
PREF_URLBAR_BRANCH
=
"
browser
.
urlbar
.
"
;
const
PREF_URLBAR_DEFAULTS
=
new
Map
(
[
[
"
autocomplete
.
enabled
"
true
]
[
"
autoFill
"
true
]
[
"
autoFill
.
searchEngines
"
false
]
[
"
autoFill
.
stddevMultiplier
"
[
0
.
0
"
getFloatPref
"
]
]
[
"
clickSelectsAll
"
false
]
[
"
delay
"
50
]
[
"
doubleClickSelectsAll
"
false
]
[
"
filter
.
javascript
"
true
]
[
"
insertMethod
"
UrlbarUtils
.
INSERTMETHOD
.
MERGE_RELATED
]
[
"
matchBehavior
"
Ci
.
mozIPlacesAutoComplete
.
MATCH_BOUNDARY_ANYWHERE
]
[
"
matchBuckets
"
"
suggestion
:
4
general
:
Infinity
"
]
[
"
matchBucketsSearch
"
"
"
]
[
"
maxCharsForSearchSuggestions
"
20
]
[
"
maxHistoricalSearchSuggestions
"
0
]
[
"
maxRichResults
"
10
]
[
"
suggest
.
bookmark
"
true
]
[
"
suggest
.
history
"
true
]
[
"
suggest
.
history
.
onlyTyped
"
false
]
[
"
suggest
.
openpage
"
true
]
[
"
suggest
.
searches
"
false
]
[
"
trimURLs
"
true
]
[
"
usepreloadedtopurls
.
enabled
"
true
]
[
"
usepreloadedtopurls
.
expire_days
"
14
]
[
"
restyleSearches
"
false
]
]
)
;
const
PREF_OTHER_DEFAULTS
=
new
Map
(
[
[
"
keyword
.
enabled
"
true
]
]
)
;
const
TYPES
=
[
"
history
"
"
bookmark
"
"
openpage
"
"
searches
"
]
;
const
PREF_TYPES
=
new
Map
(
[
[
"
boolean
"
"
Bool
"
]
[
"
string
"
"
Char
"
]
[
"
number
"
"
Int
"
]
]
)
;
const
DEFAULT_BUCKETS_BEFORE
=
[
[
UrlbarUtils
.
MATCHTYPE
.
HEURISTIC
1
]
[
UrlbarUtils
.
MATCHTYPE
.
EXTENSION
UrlbarUtils
.
MAXIMUM_ALLOWED_EXTENSION_MATCHES
-
1
]
]
;
const
DEFAULT_BUCKETS_AFTER
=
[
[
UrlbarUtils
.
MATCHTYPE
.
SUGGESTION
Infinity
]
[
UrlbarUtils
.
MATCHTYPE
.
GENERAL
Infinity
]
]
;
class
Preferences
{
constructor
(
)
{
this
.
_map
=
new
Map
(
)
;
Services
.
prefs
.
addObserver
(
PREF_URLBAR_BRANCH
this
true
)
;
Services
.
prefs
.
addObserver
(
"
keyword
.
enabled
"
this
true
)
;
this
.
_updateLinkedPrefs
(
)
;
}
get
(
pref
)
{
if
(
!
this
.
_map
.
has
(
pref
)
)
this
.
_map
.
set
(
pref
this
.
_getPrefValue
(
pref
)
)
;
return
this
.
_map
.
get
(
pref
)
;
}
observe
(
subject
topic
data
)
{
let
pref
=
data
.
replace
(
PREF_URLBAR_BRANCH
"
"
)
;
if
(
!
PREF_URLBAR_DEFAULTS
.
has
(
pref
)
&
&
!
PREF_OTHER_DEFAULTS
.
has
(
pref
)
)
return
;
this
.
_map
.
delete
(
pref
)
;
if
(
pref
=
=
"
matchBuckets
"
)
{
this
.
_map
.
delete
(
"
matchBucketsSearch
"
)
;
}
else
if
(
pref
=
=
"
suggest
.
history
"
)
{
this
.
_map
.
delete
(
"
suggest
.
history
.
onlyTyped
"
)
;
}
if
(
pref
=
=
"
autocomplete
.
enabled
"
|
|
pref
.
startsWith
(
"
suggest
.
"
)
)
{
this
.
_map
.
delete
(
"
defaultBehavior
"
)
;
this
.
_map
.
delete
(
"
emptySearchDefaultBehavior
"
)
;
this
.
_updateLinkedPrefs
(
pref
)
;
}
}
_readPref
(
pref
)
{
let
prefs
=
Services
.
prefs
.
getBranch
(
PREF_URLBAR_BRANCH
)
;
let
def
=
PREF_URLBAR_DEFAULTS
.
get
(
pref
)
;
if
(
def
=
=
=
undefined
)
{
prefs
=
Services
.
prefs
;
def
=
PREF_OTHER_DEFAULTS
.
get
(
pref
)
;
}
if
(
def
=
=
=
undefined
)
throw
new
Error
(
"
Trying
to
access
an
unknown
pref
"
+
pref
)
;
let
getterName
;
if
(
!
Array
.
isArray
(
def
)
)
{
getterName
=
get
{
PREF_TYPES
.
get
(
typeof
def
)
}
Pref
;
}
else
{
if
(
def
.
length
!
=
2
)
{
throw
new
Error
(
"
Malformed
pref
def
:
"
+
pref
)
;
}
[
def
getterName
]
=
def
;
}
return
prefs
[
getterName
]
(
pref
def
)
;
}
_getPrefValue
(
pref
)
{
switch
(
pref
)
{
case
"
matchBuckets
"
:
{
let
val
=
this
.
_readPref
(
pref
)
;
try
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
val
)
;
}
catch
(
ex
)
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
PREF_URLBAR_DEFAULTS
.
get
(
pref
)
)
;
}
return
[
.
.
.
DEFAULT_BUCKETS_BEFORE
.
.
.
val
.
.
.
DEFAULT_BUCKETS_AFTER
]
;
}
case
"
matchBucketsSearch
"
:
{
let
val
=
this
.
_readPref
(
pref
)
;
if
(
val
)
{
try
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
val
)
;
return
[
.
.
.
DEFAULT_BUCKETS_BEFORE
.
.
.
val
.
.
.
DEFAULT_BUCKETS_AFTER
]
;
}
catch
(
ex
)
{
}
}
return
this
.
get
(
"
matchBuckets
"
)
;
}
case
"
suggest
.
history
.
onlyTyped
"
:
{
return
this
.
get
(
"
suggest
.
history
"
)
&
&
this
.
_readPref
(
pref
)
;
}
case
"
defaultBehavior
"
:
{
let
val
=
0
;
for
(
let
type
of
[
.
.
.
TYPES
"
history
.
onlyTyped
"
]
)
{
let
behavior
=
type
=
=
"
history
.
onlyTyped
"
?
"
TYPED
"
:
type
.
toUpperCase
(
)
;
val
|
=
this
.
get
(
"
suggest
.
"
+
type
)
&
&
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
behavior
]
;
}
return
val
;
}
case
"
emptySearchDefaultBehavior
"
:
{
let
val
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_RESTRICT
;
if
(
this
.
get
(
"
suggest
.
history
"
)
)
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_HISTORY
|
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_TYPED
;
}
else
if
(
this
.
get
(
"
suggest
.
bookmark
"
)
)
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_BOOKMARK
;
}
else
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_OPENPAGE
;
}
return
val
;
}
case
"
matchBehavior
"
:
{
let
val
=
this
.
_readPref
(
pref
)
;
if
(
!
[
Ci
.
mozIPlacesAutoComplete
.
MATCH_ANYWHERE
Ci
.
mozIPlacesAutoComplete
.
MATCH_BOUNDARY
Ci
.
mozIPlacesAutoComplete
.
MATCH_BEGINNING
]
.
includes
(
val
)
)
{
val
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_BOUNDARY_ANYWHERE
;
}
return
val
;
}
}
return
this
.
_readPref
(
pref
)
;
}
_updateLinkedPrefs
(
changedPref
=
"
"
)
{
if
(
this
.
_linkingPrefs
)
{
return
;
}
this
.
_linkingPrefs
=
true
;
try
{
let
branch
=
Services
.
prefs
.
getBranch
(
PREF_URLBAR_BRANCH
)
;
if
(
changedPref
.
startsWith
(
"
suggest
.
"
)
)
{
branch
.
setBoolPref
(
"
autocomplete
.
enabled
"
TYPES
.
some
(
type
=
>
this
.
get
(
"
suggest
.
"
+
type
)
)
)
;
}
else
if
(
this
.
get
(
"
autocomplete
.
enabled
"
)
)
{
if
(
TYPES
.
every
(
type
=
>
!
this
.
get
(
"
suggest
.
"
+
type
)
)
)
{
for
(
let
type
of
TYPES
)
{
let
def
=
PREF_URLBAR_DEFAULTS
.
get
(
"
suggest
.
"
+
type
)
;
branch
.
setBoolPref
(
"
suggest
.
"
+
type
def
)
;
}
}
}
else
{
for
(
let
type
of
TYPES
)
{
branch
.
setBoolPref
(
"
suggest
.
"
+
type
false
)
;
}
}
}
finally
{
delete
this
.
_linkingPrefs
;
}
}
QueryInterface
(
qiIID
)
{
let
supportedIIDs
=
[
Ci
.
nsISupports
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
;
for
(
let
iid
of
supportedIIDs
)
{
if
(
Ci
[
iid
]
.
equals
(
qiIID
)
)
{
return
this
;
}
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
}
var
UrlbarPrefs
=
new
Preferences
(
)
;
