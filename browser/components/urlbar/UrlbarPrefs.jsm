"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarPrefs
"
"
UrlbarPrefsObserver
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
PREF_URLBAR_BRANCH
=
"
browser
.
urlbar
.
"
;
const
PREF_URLBAR_DEFAULTS
=
new
Map
(
[
[
"
accessibility
.
tabToSearch
.
announceResults
"
true
]
[
"
autoFill
"
true
]
[
"
autoFill
.
searchEngines
"
false
]
[
"
autoFill
.
stddevMultiplier
"
[
0
.
0
"
float
"
]
]
[
"
ctrlCanonizesURLs
"
true
]
[
"
decodeURLsOnCopy
"
false
]
[
"
delay
"
50
]
[
"
disableExtendForTests
"
false
]
[
"
dnsResolveSingleWordsAfterSearch
"
1
]
[
"
eventTelemetry
.
enabled
"
false
]
[
"
experiment
.
update2
"
true
]
[
"
experimental
.
expandTextOnFocus
"
false
]
[
"
experimental
.
searchButton
"
false
]
[
"
experimental
.
searchModeIndicatorHover
"
false
]
[
"
extension
.
timeout
"
400
]
[
"
filter
.
javascript
"
true
]
[
"
formatting
.
enabled
"
true
]
[
"
imeCompositionClosesPanel
"
true
]
[
"
matchBuckets
"
"
suggestion
:
4
general
:
Infinity
"
]
[
"
matchBucketsSearch
"
"
"
]
[
"
maxCharsForSearchSuggestions
"
20
]
[
"
maxHistoricalSearchSuggestions
"
0
]
[
"
maxRichResults
"
10
]
[
"
openintab
"
false
]
[
"
restyleSearches
"
false
]
[
"
richSuggestions
.
tail
"
true
]
[
"
searchTips
.
test
.
ignoreShowLimits
"
false
]
[
"
shortcuts
.
bookmarks
"
true
]
[
"
shortcuts
.
tabs
"
true
]
[
"
shortcuts
.
history
"
true
]
[
"
speculativeConnect
.
enabled
"
true
]
[
"
suggest
.
bookmark
"
true
]
[
"
suggest
.
history
"
true
]
[
"
suggest
.
openpage
"
true
]
[
"
suggest
.
searches
"
false
]
[
"
suggest
.
engines
"
true
]
[
"
suggest
.
topsites
"
true
]
[
"
switchTabs
.
adoptIntoActiveWindow
"
false
]
[
"
tabToSearch
.
onboard
.
interactionsLeft
"
3
]
[
"
tipShownCount
.
searchTip_onboard
"
0
]
[
"
tipShownCount
.
searchTip_redirect
"
0
]
[
"
trimURLs
"
true
]
[
"
usepreloadedtopurls
.
enabled
"
false
]
[
"
usepreloadedtopurls
.
expire_days
"
14
]
[
"
update2
"
true
]
[
"
update2
.
disableOneOffsHorizontalKeyNavigation
"
true
]
[
"
update2
.
emptySearchBehavior
"
0
]
[
"
update2
.
oneOffsRefresh
"
true
]
[
"
update2
.
restyleBrowsingHistoryAsSearch
"
true
]
]
)
;
const
PREF_OTHER_DEFAULTS
=
new
Map
(
[
[
"
keyword
.
enabled
"
true
]
[
"
browser
.
search
.
suggest
.
enabled
"
true
]
[
"
browser
.
search
.
suggest
.
enabled
.
private
"
false
]
[
"
ui
.
popup
.
disable_autohide
"
false
]
[
"
browser
.
fixup
.
dns_first_for_single_words
"
false
]
]
)
;
const
SUGGEST_PREF_TO_BEHAVIOR
=
{
history
:
"
history
"
bookmark
:
"
bookmark
"
openpage
:
"
openpage
"
searches
:
"
search
"
}
;
const
PREF_TYPES
=
new
Map
(
[
[
"
boolean
"
"
Bool
"
]
[
"
float
"
"
Float
"
]
[
"
number
"
"
Int
"
]
[
"
string
"
"
Char
"
]
]
)
;
const
DEFAULT_BUCKETS_BEFORE
=
[
[
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
1
]
[
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
UrlbarUtils
.
MAXIMUM_ALLOWED_EXTENSION_MATCHES
-
1
]
]
;
const
DEFAULT_BUCKETS_AFTER
=
[
[
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
Infinity
]
[
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
Infinity
]
]
;
class
Preferences
{
constructor
(
)
{
this
.
_map
=
new
Map
(
)
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
;
Services
.
prefs
.
addObserver
(
PREF_URLBAR_BRANCH
this
true
)
;
for
(
let
pref
of
PREF_OTHER_DEFAULTS
.
keys
(
)
)
{
Services
.
prefs
.
addObserver
(
pref
this
true
)
;
}
this
.
_observerWeakRefs
=
[
]
;
this
.
addObserver
(
this
)
;
}
get
(
pref
)
{
let
value
=
this
.
_map
.
get
(
pref
)
;
if
(
value
=
=
=
undefined
)
{
value
=
this
.
_getPrefValue
(
pref
)
;
this
.
_map
.
set
(
pref
value
)
;
}
return
value
;
}
set
(
pref
value
)
{
let
{
defaultValue
setter
}
=
this
.
_getPrefDescriptor
(
pref
)
;
if
(
typeof
value
!
=
typeof
defaultValue
)
{
throw
new
Error
(
Invalid
value
type
{
typeof
value
}
for
pref
{
pref
}
)
;
}
setter
(
pref
value
)
;
}
addObserver
(
observer
)
{
this
.
_observerWeakRefs
.
push
(
Cu
.
getWeakReference
(
observer
)
)
;
}
observe
(
subject
topic
data
)
{
let
pref
=
data
.
replace
(
PREF_URLBAR_BRANCH
"
"
)
;
if
(
!
PREF_URLBAR_DEFAULTS
.
has
(
pref
)
&
&
!
PREF_OTHER_DEFAULTS
.
has
(
pref
)
)
{
return
;
}
for
(
let
i
=
0
;
i
<
this
.
_observerWeakRefs
.
length
;
)
{
let
observer
=
this
.
_observerWeakRefs
[
i
]
.
get
(
)
;
if
(
!
observer
)
{
this
.
_observerWeakRefs
.
splice
(
i
1
)
;
}
else
{
observer
.
onPrefChanged
(
pref
)
;
+
+
i
;
}
}
}
onPrefChanged
(
pref
)
{
this
.
_map
.
delete
(
pref
)
;
if
(
pref
=
=
"
matchBuckets
"
)
{
this
.
_map
.
delete
(
"
matchBucketsSearch
"
)
;
}
if
(
pref
.
startsWith
(
"
suggest
.
"
)
)
{
this
.
_map
.
delete
(
"
defaultBehavior
"
)
;
}
}
_readPref
(
pref
)
{
let
{
defaultValue
getter
}
=
this
.
_getPrefDescriptor
(
pref
)
;
return
getter
(
pref
defaultValue
)
;
}
_getPrefValue
(
pref
)
{
switch
(
pref
)
{
case
"
matchBuckets
"
:
{
let
val
=
this
.
_readPref
(
pref
)
;
try
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
val
)
;
}
catch
(
ex
)
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
PREF_URLBAR_DEFAULTS
.
get
(
pref
)
)
;
}
return
[
.
.
.
DEFAULT_BUCKETS_BEFORE
.
.
.
val
.
.
.
DEFAULT_BUCKETS_AFTER
]
;
}
case
"
matchBucketsSearch
"
:
{
let
val
=
this
.
_readPref
(
pref
)
;
if
(
val
)
{
try
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
val
)
;
return
[
.
.
.
DEFAULT_BUCKETS_BEFORE
.
.
.
val
.
.
.
DEFAULT_BUCKETS_AFTER
]
;
}
catch
(
ex
)
{
}
}
return
this
.
get
(
"
matchBuckets
"
)
;
}
case
"
defaultBehavior
"
:
{
let
val
=
0
;
for
(
let
type
of
Object
.
keys
(
SUGGEST_PREF_TO_BEHAVIOR
)
)
{
let
behavior
=
BEHAVIOR_
{
SUGGEST_PREF_TO_BEHAVIOR
[
type
]
.
toUpperCase
(
)
}
;
val
|
=
this
.
get
(
"
suggest
.
"
+
type
)
&
&
Ci
.
mozIPlacesAutoComplete
[
behavior
]
;
}
return
val
;
}
case
"
update2
"
:
{
if
(
!
this
.
_readPref
(
"
experiment
.
update2
"
)
)
{
return
false
;
}
return
this
.
_readPref
(
pref
)
;
}
}
return
this
.
_readPref
(
pref
)
;
}
_getPrefDescriptor
(
pref
)
{
let
branch
=
Services
.
prefs
.
getBranch
(
PREF_URLBAR_BRANCH
)
;
let
defaultValue
=
PREF_URLBAR_DEFAULTS
.
get
(
pref
)
;
if
(
defaultValue
=
=
=
undefined
)
{
branch
=
Services
.
prefs
;
defaultValue
=
PREF_OTHER_DEFAULTS
.
get
(
pref
)
;
}
if
(
defaultValue
=
=
=
undefined
)
{
throw
new
Error
(
"
Trying
to
access
an
unknown
pref
"
+
pref
)
;
}
let
type
;
if
(
!
Array
.
isArray
(
defaultValue
)
)
{
type
=
PREF_TYPES
.
get
(
typeof
defaultValue
)
;
}
else
{
if
(
defaultValue
.
length
!
=
2
)
{
throw
new
Error
(
"
Malformed
pref
def
:
"
+
pref
)
;
}
[
defaultValue
type
]
=
defaultValue
;
type
=
PREF_TYPES
.
get
(
type
)
;
}
if
(
!
type
)
{
throw
new
Error
(
"
Unknown
pref
type
:
"
+
pref
)
;
}
return
{
defaultValue
getter
:
branch
[
get
{
type
}
Pref
]
setter
:
branch
[
set
{
type
=
=
"
Float
"
?
"
Char
"
:
type
}
Pref
]
}
;
}
}
var
UrlbarPrefs
=
new
Preferences
(
)
;
