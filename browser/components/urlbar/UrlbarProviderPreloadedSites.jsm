"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderPreloadedSites
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
UrlbarProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ProfileAge
:
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
MS_PER_DAY
=
86400000
;
function
PreloadedSite
(
url
title
)
{
this
.
uri
=
Services
.
io
.
newURI
(
url
)
;
this
.
title
=
title
;
this
.
_matchTitle
=
title
.
toLowerCase
(
)
;
this
.
_hasWWW
=
this
.
uri
.
host
.
startsWith
(
"
www
.
"
)
;
this
.
_hostWithoutWWW
=
this
.
_hasWWW
?
this
.
uri
.
host
.
slice
(
4
)
:
this
.
uri
.
host
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
PreloadedSiteStorage
"
(
)
=
>
Object
.
seal
(
{
sites
:
[
]
add
(
url
title
)
{
let
site
=
new
PreloadedSite
(
url
title
)
;
this
.
sites
.
push
(
site
)
;
}
populate
(
sites
)
{
this
.
sites
=
[
]
;
for
(
let
site
of
sites
)
{
this
.
add
(
site
[
0
]
site
[
1
]
)
;
}
}
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ProfileAgeCreatedPromise
"
async
(
)
=
>
{
let
times
=
await
ProfileAge
(
)
;
return
times
.
created
;
}
)
;
class
ProviderPreloadedSites
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
if
(
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
fetch
(
"
chrome
:
/
/
browser
/
content
/
urlbar
/
preloaded
-
top
-
urls
.
json
"
)
.
then
(
response
=
>
response
.
json
(
)
)
.
then
(
sites
=
>
PreloadedSiteStorage
.
populate
(
sites
)
)
.
catch
(
ex
=
>
this
.
logger
.
error
(
ex
)
)
;
}
}
get
name
(
)
{
return
"
PreloadedSites
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
;
}
async
isActive
(
queryContext
)
{
let
instance
=
this
.
queryInstance
;
this
.
_autofillData
=
null
;
await
this
.
_checkPreloadedSitesExpiry
(
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
false
;
}
if
(
!
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
false
;
}
if
(
!
UrlbarPrefs
.
get
(
"
autoFill
"
)
|
|
!
queryContext
.
allowAutofill
|
|
queryContext
.
tokens
.
length
!
=
1
)
{
return
false
;
}
if
(
queryContext
.
searchString
.
length
>
UrlbarUtils
.
MAX_TEXT_LENGTH
)
{
return
false
;
}
[
this
.
_strippedPrefix
this
.
_searchString
]
=
UrlbarUtils
.
stripURLPrefix
(
queryContext
.
searchString
)
;
if
(
!
this
.
_searchString
|
|
!
this
.
_searchString
.
length
)
{
return
false
;
}
this
.
_lowerCaseSearchString
=
this
.
_searchString
.
toLowerCase
(
)
;
this
.
_strippedPrefix
=
this
.
_strippedPrefix
.
toLowerCase
(
)
;
if
(
UrlbarTokenizer
.
REGEXP_SPACES
.
test
(
queryContext
.
searchString
)
)
{
return
false
;
}
let
result
=
await
this
.
_getAutofillResult
(
queryContext
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
false
;
}
this
.
_autofillData
=
{
result
instance
}
;
return
true
;
}
async
startQuery
(
queryContext
addCallback
)
{
if
(
this
.
_autofillData
.
result
&
&
this
.
_autofillData
.
instance
=
=
this
.
queryInstance
)
{
this
.
_autofillData
.
result
.
heuristic
=
true
;
addCallback
(
this
this
.
_autofillData
.
result
)
;
this
.
_autofillData
=
null
;
}
for
(
let
site
of
PreloadedSiteStorage
.
sites
)
{
let
url
=
site
.
uri
.
spec
;
if
(
(
!
this
.
_strippedPrefix
|
|
url
.
startsWith
(
this
.
_strippedPrefix
)
)
&
&
(
site
.
uri
.
host
.
includes
(
this
.
_lowerCaseSearchString
)
|
|
site
.
_matchTitle
.
includes
(
this
.
_lowerCaseSearchString
)
)
)
{
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
title
:
[
site
.
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
url
:
[
url
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
UrlbarUtils
.
getIconForUrl
(
url
)
}
)
)
;
addCallback
(
this
result
)
;
}
}
}
cancelQuery
(
queryContext
)
{
if
(
this
.
_autofillData
?
.
instance
=
=
this
.
queryInstance
)
{
this
.
_autofillData
=
null
;
}
}
populatePreloadedSiteStorage
(
list
)
{
PreloadedSiteStorage
.
populate
(
list
)
;
}
async
_getAutofillResult
(
queryContext
)
{
let
matchedSite
=
PreloadedSiteStorage
.
sites
.
find
(
site
=
>
{
return
(
(
!
this
.
_strippedPrefix
|
|
site
.
uri
.
spec
.
startsWith
(
this
.
_strippedPrefix
)
)
&
&
(
site
.
uri
.
host
.
startsWith
(
this
.
_lowerCaseSearchString
)
|
|
site
.
uri
.
host
.
startsWith
(
"
www
.
"
+
this
.
_lowerCaseSearchString
)
)
)
;
}
)
;
if
(
!
matchedSite
)
{
return
null
;
}
let
url
=
matchedSite
.
uri
.
spec
;
let
[
title
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
url
{
stripHttp
:
true
trimEmptyQuery
:
true
trimSlash
:
!
this
.
_searchString
.
includes
(
"
/
"
)
}
)
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
title
:
[
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
url
:
[
url
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
UrlbarUtils
.
getIconForUrl
(
url
)
}
)
)
;
let
value
=
UrlbarUtils
.
stripURLPrefix
(
url
)
[
1
]
;
value
=
this
.
_strippedPrefix
+
value
.
substr
(
value
.
indexOf
(
this
.
_searchString
)
)
;
let
autofilledValue
=
queryContext
.
searchString
+
value
.
substring
(
queryContext
.
searchString
.
length
)
;
result
.
autofill
=
{
type
:
"
preloaded
"
value
:
autofilledValue
selectionStart
:
queryContext
.
searchString
.
length
selectionEnd
:
autofilledValue
.
length
}
;
return
result
;
}
async
_checkPreloadedSitesExpiry
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
;
}
let
profileCreationDate
=
await
ProfileAgeCreatedPromise
;
let
daysSinceProfileCreation
=
(
Date
.
now
(
)
-
profileCreationDate
)
/
MS_PER_DAY
;
if
(
daysSinceProfileCreation
>
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
expire_days
"
)
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
usepreloadedtopurls
.
enabled
"
false
)
;
}
}
}
var
UrlbarProviderPreloadedSites
=
new
ProviderPreloadedSites
(
)
;
