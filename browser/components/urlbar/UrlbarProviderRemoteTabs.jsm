"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderRemoteTabs
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
UrlbarProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
SyncedTabs
:
"
resource
:
/
/
services
-
sync
/
SyncedTabs
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
let
_cache
=
null
;
const
RECENT_REMOTE_TAB_THRESHOLD_MS
=
72
*
60
*
60
*
1000
;
XPCOMUtils
.
defineLazyGetter
(
this
"
weaveXPCService
"
function
(
)
{
try
{
return
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
catch
(
ex
)
{
}
return
null
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
showRemoteIconsPref
"
"
services
.
sync
.
syncedTabs
.
showRemoteIcons
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
showRemoteTabsPref
"
"
services
.
sync
.
syncedTabs
.
showRemoteTabs
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
syncUsernamePref
"
"
services
.
sync
.
username
"
)
;
function
escapeRegExp
(
string
)
{
return
string
.
replace
(
/
[
.
*
+
?
^
{
}
(
)
|
[
\
]
\
\
]
/
g
"
\
\
&
"
)
;
}
class
ProviderRemoteTabs
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
Services
.
obs
.
addObserver
(
this
.
observe
"
weave
:
engine
:
sync
:
finish
"
)
;
Services
.
obs
.
addObserver
(
this
.
observe
"
weave
:
service
:
start
-
over
"
)
;
}
get
name
(
)
{
return
"
RemoteTabs
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
NETWORK
;
}
isActive
(
queryContext
)
{
return
(
syncUsernamePref
&
&
showRemoteTabsPref
&
&
UrlbarPrefs
.
get
(
"
suggest
.
remotetab
"
)
&
&
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
TABS
)
&
&
weaveXPCService
&
&
weaveXPCService
.
ready
&
&
weaveXPCService
.
enabled
)
;
}
async
startQuery
(
queryContext
addCallback
)
{
let
instance
=
this
.
queryInstance
;
let
searchString
=
queryContext
.
tokens
.
map
(
t
=
>
t
.
value
)
.
join
(
"
"
)
;
let
re
=
new
RegExp
(
escapeRegExp
(
searchString
)
"
i
"
)
;
let
tabsData
=
await
this
.
ensureCache
(
)
;
if
(
instance
!
=
this
.
queryInstance
)
{
return
;
}
let
resultsAdded
=
0
;
let
staleTabs
=
[
]
;
for
(
let
{
tab
client
}
of
tabsData
)
{
if
(
!
searchString
|
|
searchString
=
=
UrlbarTokenizer
.
RESTRICT
.
OPENPAGE
|
|
re
.
test
(
tab
.
url
)
|
|
(
tab
.
title
&
&
re
.
test
(
tab
.
title
)
)
)
{
if
(
showRemoteIconsPref
)
{
if
(
!
tab
.
icon
)
{
tab
.
icon
=
UrlbarUtils
.
getIconForUrl
(
tab
.
url
)
;
}
else
{
tab
.
icon
=
PlacesUtils
.
favicons
.
getFaviconLinkForIcon
(
Services
.
io
.
newURI
(
tab
.
icon
)
)
.
spec
;
}
}
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
UrlbarUtils
.
RESULT_SOURCE
.
TABS
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
url
:
[
tab
.
url
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
title
:
[
tab
.
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
device
:
client
.
name
icon
:
showRemoteIconsPref
?
tab
.
icon
:
"
"
lastUsed
:
(
tab
.
lastUsed
|
|
0
)
*
1000
}
)
)
;
if
(
tab
.
lastUsed
<
=
(
Date
.
now
(
)
-
RECENT_REMOTE_TAB_THRESHOLD_MS
)
/
1000
)
{
staleTabs
.
push
(
result
)
;
}
else
{
addCallback
(
this
result
)
;
resultsAdded
+
+
;
}
}
if
(
resultsAdded
=
=
queryContext
.
maxResults
)
{
break
;
}
}
while
(
staleTabs
.
length
&
&
resultsAdded
<
queryContext
.
maxResults
)
{
addCallback
(
this
staleTabs
.
shift
(
)
)
;
resultsAdded
+
+
;
}
}
async
buildItems
(
)
{
let
tabsData
=
[
]
;
if
(
weaveXPCService
.
ready
)
{
let
clients
=
await
SyncedTabs
.
getTabClients
(
)
;
SyncedTabs
.
sortTabClientsByLastUsed
(
clients
)
;
for
(
let
client
of
clients
)
{
for
(
let
tab
of
client
.
tabs
)
{
tabsData
.
push
(
{
tab
client
}
)
;
}
}
}
return
tabsData
;
}
async
ensureCache
(
)
{
if
(
!
_cache
)
{
_cache
=
await
this
.
buildItems
(
)
;
}
return
_cache
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
weave
:
engine
:
sync
:
finish
"
:
if
(
data
=
=
"
tabs
"
)
{
_cache
=
null
;
}
break
;
case
"
weave
:
service
:
start
-
over
"
:
_cache
=
null
;
break
;
default
:
break
;
}
}
}
var
UrlbarProviderRemoteTabs
=
new
ProviderRemoteTabs
(
)
;
