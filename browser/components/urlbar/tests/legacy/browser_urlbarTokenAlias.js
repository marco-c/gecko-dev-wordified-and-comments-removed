"
use
strict
"
;
const
ALIAS
=
"
test
"
;
add_task
(
async
function
init
(
)
{
await
Services
.
search
.
addEngineWithDetails
(
"
Test
"
{
alias
:
ALIAS
template
:
"
http
:
/
/
example
.
com
/
?
search
=
{
searchTerms
}
"
}
)
;
registerCleanupFunction
(
async
function
(
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
"
Test
"
)
;
await
Services
.
search
.
removeEngine
(
engine
)
;
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
Assert
.
ok
(
!
gURLBar
.
popup
.
popupOpen
"
popup
should
be
closed
"
)
;
}
)
;
}
)
;
add_task
(
async
function
testNoRevert
(
)
{
await
doSimpleTest
(
false
)
;
}
)
;
add_task
(
async
function
testRevert
(
)
{
await
doSimpleTest
(
true
)
;
}
)
;
add_task
(
async
function
spacesBeforeAlias
(
)
{
gURLBar
.
search
(
"
"
+
ALIAS
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
true
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
}
)
;
add_task
(
async
function
charsBeforeAlias
(
)
{
gURLBar
.
search
(
"
not
an
alias
"
+
ALIAS
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
false
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
}
)
;
add_task
(
async
function
restrictionCharBeforeAlias
(
)
{
gURLBar
.
search
(
UrlbarTokenizer
.
RESTRICT
.
BOOKMARK
+
"
"
+
ALIAS
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
false
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
}
)
;
add_task
(
async
function
aliasCase
(
)
{
let
alias
=
"
TeSt
"
;
gURLBar
.
search
(
alias
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
true
alias
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
}
)
;
add_task
(
async
function
inputDoesntMatchHeuristicResult
(
)
{
let
searchString
=
{
ALIAS
}
aaa
;
gURLBar
.
search
(
searchString
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
true
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
let
value
=
{
ALIAS
}
xxx
;
gURLBar
.
value
=
{
ALIAS
}
xxx
;
Assert
.
equal
(
gURLBar
.
value
value
)
;
Assert
.
ok
(
gURLBar
.
value
.
includes
(
ALIAS
)
)
;
assertHighlighted
(
false
ALIAS
)
;
searchString
=
{
ALIAS
}
bbb
;
gURLBar
.
search
(
searchString
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
true
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
value
=
bbb
{
ALIAS
}
;
gURLBar
.
value
=
bbb
{
ALIAS
}
;
Assert
.
equal
(
gURLBar
.
value
value
)
;
Assert
.
ok
(
gURLBar
.
value
.
includes
(
ALIAS
)
)
;
assertHighlighted
(
false
ALIAS
)
;
gURLBar
.
search
(
"
"
)
;
}
)
;
add_task
(
async
function
nonHeuristicAliases
(
)
{
let
tokenEngines
=
[
]
;
for
(
let
engine
of
await
Services
.
search
.
getEngines
(
)
)
{
let
aliases
=
[
]
;
if
(
engine
.
alias
)
{
aliases
.
push
(
engine
.
alias
)
;
}
aliases
.
push
(
.
.
.
engine
.
wrappedJSObject
.
_internalAliases
)
;
let
tokenAliases
=
aliases
.
filter
(
a
=
>
a
.
startsWith
(
"
"
)
)
;
if
(
tokenAliases
.
length
)
{
tokenEngines
.
push
(
{
engine
tokenAliases
}
)
;
}
}
if
(
!
tokenEngines
.
length
)
{
Assert
.
ok
(
true
"
No
token
alias
engines
skipping
task
.
"
)
;
return
;
}
info
(
"
Got
token
alias
engines
:
"
+
tokenEngines
.
map
(
(
{
engine
}
)
=
>
engine
.
name
)
)
;
gURLBar
.
search
(
"
"
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
tokenEngines
.
length
-
1
)
;
for
(
let
{
tokenAliases
}
of
tokenEngines
)
{
let
alias
=
tokenAliases
[
0
]
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
assertHighlighted
(
true
alias
)
;
}
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
}
)
;
add_task
(
async
function
nonTokenAlias
(
)
{
let
alias
=
"
nontokenalias
"
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
Test
"
)
;
engine
.
alias
=
"
nontokenalias
"
;
Assert
.
equal
(
engine
.
alias
alias
)
;
gURLBar
.
search
(
alias
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertFirstResultIsAlias
(
true
alias
)
;
assertHighlighted
(
false
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
engine
.
alias
=
ALIAS
;
}
)
;
add_task
(
async
function
clickAndFillAlias
(
)
{
gURLBar
.
search
(
"
"
)
;
await
promiseSearchComplete
(
)
;
let
testEngineItem
;
for
(
let
i
=
0
;
!
testEngineItem
;
i
+
+
)
{
let
item
=
await
waitForAutocompleteResultAt
(
i
)
;
let
action
=
PlacesUtils
.
parseActionUrl
(
item
.
getAttribute
(
"
url
"
)
)
;
if
(
action
&
&
action
.
params
.
alias
=
=
ALIAS
)
{
testEngineItem
=
item
;
}
}
let
hiddenPromise
=
promisePopupHidden
(
gURLBar
.
popup
)
;
EventUtils
.
synthesizeMouseAtCenter
(
testEngineItem
{
}
)
;
await
hiddenPromise
;
await
promiseSearchComplete
(
)
;
await
promisePopupShown
(
gURLBar
.
popup
)
;
assertAlias
(
true
)
;
Assert
.
equal
(
gURLBar
.
textValue
{
ALIAS
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
}
)
;
async
function
doSimpleTest
(
revertBetweenSteps
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
autoFill
"
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
autoFill
"
)
;
}
)
;
gURLBar
.
search
(
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
false
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
gURLBar
.
search
(
ALIAS
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
true
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
gURLBar
.
search
(
ALIAS
+
"
foo
"
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
true
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
gURLBar
.
search
(
ALIAS
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
true
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
gURLBar
.
search
(
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
)
;
await
promiseSearchComplete
(
)
;
await
waitForAutocompleteResultAt
(
0
)
;
assertAlias
(
false
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
await
promisePopupHidden
(
gURLBar
.
popup
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
autoFill
"
)
;
}
function
assertAlias
(
aliasPresent
expectedAlias
=
ALIAS
)
{
assertFirstResultIsAlias
(
aliasPresent
expectedAlias
)
;
assertHighlighted
(
aliasPresent
expectedAlias
)
;
}
function
assertFirstResultIsAlias
(
isAlias
expectedAlias
)
{
let
controller
=
gURLBar
.
popup
.
input
.
controller
;
let
action
=
PlacesUtils
.
parseActionUrl
(
controller
.
getFinalCompleteValueAt
(
0
)
)
;
Assert
.
ok
(
action
)
;
Assert
.
equal
(
action
.
type
"
searchengine
"
)
;
Assert
.
equal
(
"
alias
"
in
action
.
params
isAlias
)
;
if
(
isAlias
)
{
Assert
.
equal
(
action
.
params
.
alias
expectedAlias
)
;
}
}
function
assertHighlighted
(
highlighted
expectedAlias
)
{
let
selection
=
gURLBar
.
editor
.
selectionController
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
Assert
.
ok
(
selection
)
;
if
(
!
highlighted
)
{
Assert
.
equal
(
selection
.
rangeCount
0
)
;
return
;
}
Assert
.
equal
(
selection
.
rangeCount
1
)
;
let
index
=
gURLBar
.
textValue
.
indexOf
(
expectedAlias
)
;
Assert
.
ok
(
index
>
=
0
gURLBar
.
textValue
=
"
{
gURLBar
.
textValue
}
"
expectedAlias
=
"
{
expectedAlias
}
"
)
;
let
range
=
selection
.
getRangeAt
(
0
)
;
Assert
.
ok
(
range
)
;
Assert
.
equal
(
range
.
startOffset
index
)
;
Assert
.
equal
(
range
.
endOffset
index
+
expectedAlias
.
length
)
;
}
