"
use
strict
"
;
const
PANEL_JSM_BASENAME
=
"
Panel
.
jsm
"
;
const
IFRAME_BASENAME
=
"
urlbarAddonIframe
.
html
"
;
const
CONTENT_SCRIPT_BASENAME
=
"
urlbarAddonIframeContentScript
.
js
"
;
let
gMsgMan
;
add_task
(
async
function
(
)
{
let
rootDirURL
=
getRootDirectory
(
gTestPath
)
;
let
jsmURL
=
rootDirURL
+
PANEL_JSM_BASENAME
;
let
iframeURL
=
rootDirURL
+
IFRAME_BASENAME
;
let
contentScriptURL
=
rootDirURL
+
CONTENT_SCRIPT_BASENAME
;
let
{
Panel
}
=
ChromeUtils
.
import
(
jsmURL
{
}
)
;
let
panel
=
new
Panel
(
gURLBar
.
popup
iframeURL
)
;
registerCleanupFunction
(
(
)
=
>
{
panel
.
destroy
(
)
;
Assert
.
ok
(
gURLBar
.
popup
.
_addonIframe
=
=
=
null
"
iframe
should
be
gone
"
)
;
}
)
;
let
iframe
=
gURLBar
.
popup
.
_addonIframe
;
Assert
.
ok
(
!
!
iframe
"
iframe
should
not
be
null
"
)
;
gMsgMan
=
iframe
.
frameLoader
.
messageManager
;
gMsgMan
.
loadFrameScript
(
contentScriptURL
false
)
;
await
promiseIframeLoad
(
)
;
let
value
=
"
this
value
set
by
the
test
"
;
gURLBar
.
value
=
value
;
let
readValue
=
await
promiseUrlbarFunctionCall
(
"
getValue
"
)
;
Assert
.
equal
(
readValue
value
"
value
"
)
;
value
=
"
this
value
set
by
the
iframe
"
;
await
promiseUrlbarFunctionCall
(
"
setValue
"
value
)
;
Assert
.
equal
(
gURLBar
.
value
value
"
setValue
"
)
;
let
maxResults
=
gURLBar
.
popup
.
maxResults
;
Assert
.
equal
(
typeof
(
maxResults
)
"
number
"
"
Sanity
check
"
)
;
let
readMaxResults
=
await
promiseUrlbarFunctionCall
(
"
getMaxResults
"
)
;
Assert
.
equal
(
readMaxResults
maxResults
"
getMaxResults
"
)
;
let
newMaxResults
=
maxResults
+
10
;
await
promiseUrlbarFunctionCall
(
"
setMaxResults
"
newMaxResults
)
;
Assert
.
equal
(
gURLBar
.
popup
.
maxResults
newMaxResults
"
setMaxResults
"
)
;
gURLBar
.
popup
.
maxResults
=
maxResults
;
value
=
"
http
:
/
/
mochi
.
test
:
8888
/
"
;
await
promiseUrlbarFunctionCall
(
"
setValue
"
value
)
;
Assert
.
equal
(
gURLBar
.
value
value
"
setValue
"
)
;
await
promiseUrlbarFunctionCall
(
"
enter
"
)
;
let
browser
=
gBrowser
.
selectedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
Assert
.
equal
(
browser
.
currentURI
.
spec
value
"
enter
should
have
loaded
the
URL
"
)
;
value
=
"
test
"
;
let
promiseValues
=
await
Promise
.
all
(
[
promiseEvent
(
"
input
"
)
[
1
]
promiseEvent
(
"
reset
"
)
[
1
]
promiseEvent
(
"
result
"
)
[
1
]
promiseAutocompleteResultPopup
(
value
window
true
)
]
)
;
let
result
=
promiseValues
[
2
]
;
let
engineName
=
(
await
Services
.
search
.
getDefault
(
)
)
.
name
;
Assert
.
deepEqual
(
PlacesUtils
.
parseActionUrl
(
result
.
url
)
{
type
:
"
searchengine
"
params
:
{
engineName
input
:
"
test
"
searchQuery
:
"
test
"
}
}
"
result
.
url
"
)
;
Assert
.
ok
(
"
action
"
in
result
"
result
.
action
"
)
;
Assert
.
equal
(
result
.
action
.
type
"
searchengine
"
"
result
.
action
.
type
"
)
;
Assert
.
ok
(
"
params
"
in
result
.
action
"
result
.
action
.
params
"
)
;
Assert
.
equal
(
result
.
action
.
params
.
engineName
engineName
"
result
.
action
.
params
.
engineName
"
)
;
Assert
.
equal
(
typeof
(
result
.
image
)
"
string
"
"
result
.
image
"
)
;
Assert
.
equal
(
result
.
title
engineName
"
result
.
title
"
)
;
Assert
.
equal
(
result
.
type
"
action
searchengine
heuristic
"
"
result
.
type
"
)
;
Assert
.
equal
(
result
.
text
value
"
result
.
text
"
)
;
let
keydownPromises
=
promiseEvent
(
"
keydown
"
)
;
await
keydownPromises
[
0
]
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
type
:
"
keydown
"
}
)
;
await
keydownPromises
[
1
]
;
let
height
=
iframe
.
getBoundingClientRect
(
)
.
height
;
let
readHeight
=
await
promiseUrlbarFunctionCall
(
"
getPanelHeight
"
)
;
Assert
.
equal
(
readHeight
height
"
getPanelHeight
"
)
;
let
newHeight
=
height
+
100
;
await
promiseUrlbarFunctionCall
(
"
setPanelHeight
"
newHeight
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
Math
.
round
(
iframe
.
getBoundingClientRect
(
)
.
height
)
=
=
newHeight
"
Wait
for
panel
height
change
after
setPanelHeight
"
)
.
catch
(
ex
=
>
{
info
(
"
Last
detected
height
:
"
+
Math
.
round
(
iframe
.
getBoundingClientRect
(
)
.
height
)
)
;
throw
ex
;
}
)
;
}
)
;
function
promiseIframeLoad
(
)
{
let
msgName
=
"
TestIframeLoadAck
"
;
return
new
Promise
(
resolve
=
>
{
info
(
"
Waiting
for
iframe
load
ack
"
)
;
gMsgMan
.
addMessageListener
(
msgName
function
onMsg
(
msg
)
{
info
(
"
Received
iframe
load
ack
"
)
;
gMsgMan
.
removeMessageListener
(
msgName
onMsg
)
;
resolve
(
)
;
}
)
;
}
)
;
}
function
promiseUrlbarFunctionCall
(
.
.
.
args
)
{
return
promiseMessage
(
"
function
"
args
)
[
0
]
;
}
function
promiseEvent
(
type
)
{
return
promiseMessage
(
"
event
"
type
2
)
;
}
let
gNextMessageID
=
1
;
function
promiseMessage
(
type
data
numExpectedAcks
=
1
)
{
let
testMsgName
=
"
TestMessage
"
;
let
ackMsgName
=
"
TestMessageAck
"
;
let
msgID
=
gNextMessageID
+
+
;
gMsgMan
.
sendAsyncMessage
(
testMsgName
{
type
messageID
:
msgID
data
}
)
;
let
ackPromises
=
[
]
;
for
(
let
i
=
0
;
i
<
numExpectedAcks
;
i
+
+
)
{
let
ackIndex
=
i
;
ackPromises
.
push
(
new
Promise
(
resolve
=
>
{
info
(
"
Waiting
for
message
ack
:
"
+
JSON
.
stringify
(
{
type
msgID
ackIndex
}
)
)
;
gMsgMan
.
addMessageListener
(
ackMsgName
function
onMsg
(
msg
)
{
if
(
msg
.
data
.
messageID
!
=
msgID
|
|
msg
.
data
.
ackIndex
!
=
ackIndex
)
{
return
;
}
info
(
"
Received
message
ack
:
"
+
JSON
.
stringify
(
{
type
msgID
:
msg
.
data
.
messageID
ackIndex
}
)
)
;
gMsgMan
.
removeMessageListener
(
ackMsgName
onMsg
)
;
resolve
(
msg
.
data
.
data
)
;
}
)
;
}
)
)
;
}
return
ackPromises
;
}
