"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
mozapps
/
update
/
tests
/
browser
/
head
.
js
"
this
)
;
const
SCHEMA_BASENAME
=
"
schema
.
json
"
;
const
SCRIPT_BASENAME
=
"
api
.
js
"
;
const
SCHEMA_PATH
=
getTestFilePath
(
SCHEMA_BASENAME
)
;
const
SCRIPT_PATH
=
getTestFilePath
(
SCRIPT_BASENAME
)
;
let
schemaSource
;
let
scriptSource
;
add_task
(
async
function
loadSource
(
)
{
schemaSource
=
await
(
await
fetch
(
"
file
:
/
/
"
+
SCHEMA_PATH
)
)
.
text
(
)
;
scriptSource
=
await
(
await
fetch
(
"
file
:
/
/
"
+
SCRIPT_PATH
)
)
.
text
(
)
;
}
)
;
async
function
loadExtension
(
background
)
{
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
permissions
:
[
"
urlbar
"
]
experiment_apis
:
{
experiments_urlbar
:
{
schema
:
SCHEMA_BASENAME
parent
:
{
scopes
:
[
"
addon_parent
"
]
paths
:
[
[
"
experiments
"
"
urlbar
"
]
]
script
:
SCRIPT_BASENAME
}
}
}
}
files
:
{
[
SCHEMA_BASENAME
]
:
schemaSource
[
SCRIPT_BASENAME
]
:
scriptSource
}
isPrivileged
:
true
background
}
)
;
await
ext
.
startup
(
)
;
return
ext
;
}
function
add_getBrowserUpdateStatus_task
(
params
steps
expectedUpdateStatus
setUp
)
{
add_task
(
async
function
(
)
{
if
(
setUp
)
{
let
skip
=
await
setUp
(
)
;
if
(
skip
)
{
Assert
.
ok
(
true
"
Skipping
test
"
)
;
return
;
}
}
await
initUpdate
(
params
)
;
let
ext
=
await
loadExtension
(
async
(
)
=
>
{
browser
.
test
.
onMessage
.
addListener
(
async
command
=
>
{
switch
(
command
)
{
case
"
check
"
:
await
browser
.
experiments
.
urlbar
.
checkForBrowserUpdate
(
)
;
browser
.
test
.
sendMessage
(
"
done
"
)
;
break
;
case
"
get
"
:
{
let
done
=
false
;
let
interval
=
setInterval
(
async
(
)
=
>
{
let
status
=
await
browser
.
experiments
.
urlbar
.
getBrowserUpdateStatus
(
)
;
if
(
status
!
=
"
checking
"
&
&
!
done
)
{
done
=
true
;
clearInterval
(
interval
)
;
browser
.
test
.
sendMessage
(
"
done
"
status
)
;
}
}
100
)
;
break
;
}
}
}
)
;
}
)
;
ext
.
sendMessage
(
"
check
"
)
;
await
ext
.
awaitMessage
(
"
done
"
)
;
await
processUpdateSteps
(
steps
)
;
ext
.
sendMessage
(
"
get
"
)
;
let
status
=
await
ext
.
awaitMessage
(
"
done
"
)
;
Assert
.
equal
(
status
expectedUpdateStatus
)
;
await
ext
.
unload
(
)
;
}
)
;
}
async
function
initUpdate
(
params
)
{
gEnv
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_MANUAL
gDetailsURL
]
]
}
)
;
await
setupTestUpdater
(
)
;
let
queryString
=
params
.
queryString
?
params
.
queryString
:
"
"
;
let
updateURL
=
URL_HTTP_UPDATE_SJS
+
"
?
detailsURL
=
"
+
gDetailsURL
+
queryString
+
getVersionParams
(
)
;
if
(
params
.
backgroundUpdate
)
{
setUpdateURL
(
updateURL
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
if
(
params
.
continueFile
)
{
await
continueFileHandler
(
params
.
continueFile
)
;
}
if
(
params
.
waitForUpdateState
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
gUpdateManager
.
activeUpdate
&
&
gUpdateManager
.
activeUpdate
.
state
=
=
params
.
waitForUpdateState
"
Waiting
for
update
state
:
"
+
params
.
waitForUpdateState
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
Assert
.
equal
(
gUpdateManager
.
activeUpdate
.
state
params
.
waitForUpdateState
"
The
update
state
value
should
equal
"
+
params
.
waitForUpdateState
)
;
}
}
else
{
updateURL
+
=
"
&
slowUpdateCheck
=
1
&
useSlowDownloadMar
=
1
"
;
setUpdateURL
(
updateURL
)
;
}
}
async
function
processUpdateSteps
(
steps
)
{
for
(
let
step
of
steps
)
{
await
processUpdateStep
(
step
)
;
}
}
async
function
processUpdateStep
(
step
)
{
if
(
typeof
step
=
=
"
function
"
)
{
step
(
)
;
return
;
}
const
{
panelId
checkActiveUpdate
continueFile
downloadInfo
}
=
step
;
if
(
checkActiveUpdate
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
gUpdateManager
.
activeUpdate
"
Waiting
for
active
update
"
)
;
Assert
.
ok
(
!
!
gUpdateManager
.
activeUpdate
"
There
should
be
an
active
update
"
)
;
Assert
.
equal
(
gUpdateManager
.
activeUpdate
.
state
checkActiveUpdate
.
state
"
The
active
update
state
should
equal
"
+
checkActiveUpdate
.
state
)
;
}
else
{
Assert
.
ok
(
!
gUpdateManager
.
activeUpdate
"
There
should
not
be
an
active
update
"
)
;
}
if
(
panelId
=
=
"
downloading
"
)
{
for
(
let
i
=
0
;
i
<
downloadInfo
.
length
;
+
+
i
)
{
let
data
=
downloadInfo
[
i
]
;
await
continueFileHandler
(
continueFile
)
;
let
patch
=
getPatchOfType
(
data
.
patchType
)
;
let
isLastPatch
=
i
=
=
downloadInfo
.
length
-
1
;
if
(
!
isLastPatch
|
|
patch
)
{
let
resultName
=
data
.
bitsResult
?
"
bitsResult
"
:
"
internalResult
"
;
patch
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
patch
.
getProperty
(
resultName
)
=
=
data
[
resultName
]
"
Waiting
for
expected
patch
property
"
+
resultName
+
"
value
:
"
+
data
[
resultName
]
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
Assert
.
equal
(
patch
.
getProperty
(
resultName
)
data
[
resultName
]
"
The
patch
property
"
+
resultName
+
"
value
should
equal
"
+
data
[
resultName
]
)
;
}
}
}
else
if
(
continueFile
)
{
await
continueFileHandler
(
continueFile
)
;
}
}
