"
use
strict
"
;
add_setup
(
async
function
(
)
{
await
setup
(
)
;
}
)
;
class
NoResponseTestProvider
extends
UrlbarTestUtils
.
TestProvider
{
constructor
(
)
{
super
(
{
name
:
"
TestProviderNoResponse
"
results
:
[
]
}
)
;
this
.
#
deferred
=
Promise
.
withResolvers
(
)
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
;
}
async
startQuery
(
_context
_addCallback
)
{
await
this
.
#
deferred
.
promise
;
}
done
(
)
{
this
.
#
deferred
.
resolve
(
)
;
}
#
deferred
=
null
;
}
const
noResponseProvider
=
new
NoResponseTestProvider
(
)
;
class
AnotherHeuristicProvider
extends
UrlbarTestUtils
.
TestProvider
{
constructor
(
{
results
}
)
{
super
(
{
name
:
"
TestProviderAnotherHeuristic
"
results
}
)
;
this
.
#
deferred
=
Promise
.
withResolvers
(
)
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
;
}
async
startQuery
(
context
addCallback
)
{
for
(
const
result
of
this
.
results
)
{
addCallback
(
this
result
)
;
}
this
.
#
deferred
.
resolve
(
context
)
;
}
onQueryStarted
(
)
{
return
this
.
#
deferred
.
promise
;
}
#
deferred
=
null
;
}
const
anotherHeuristicProvider
=
new
AnotherHeuristicProvider
(
{
results
:
[
Object
.
assign
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
url
:
"
https
:
/
/
example
.
com
/
immediate
"
}
)
{
heuristic
:
true
}
)
]
}
)
;
add_task
(
async
function
engagement_before_showing_results
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
tipShownCount
.
searchTip_onboard
"
999
]
]
}
)
;
let
originalChunkTimeout
=
UrlbarProvidersManager
.
CHUNK_RESULTS_DELAY_MS
;
UrlbarProvidersManager
.
CHUNK_RESULTS_DELAY_MS
=
1000000
;
UrlbarProvidersManager
.
registerProvider
(
noResponseProvider
)
;
UrlbarProvidersManager
.
registerProvider
(
anotherHeuristicProvider
)
;
const
cleanup
=
(
)
=
>
{
UrlbarProvidersManager
.
unregisterProvider
(
noResponseProvider
)
;
UrlbarProvidersManager
.
unregisterProvider
(
anotherHeuristicProvider
)
;
UrlbarProvidersManager
.
CHUNK_RESULTS_DELAY_MS
=
originalChunkTimeout
;
}
;
registerCleanupFunction
(
cleanup
)
;
await
doTest
(
async
(
)
=
>
{
await
UrlbarTestUtils
.
inputIntoURLBar
(
window
"
exam
"
)
;
const
context
=
await
anotherHeuristicProvider
.
onQueryStarted
(
)
;
const
query
=
UrlbarProvidersManager
.
queries
.
get
(
context
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
query
.
unsortedResults
.
some
(
r
=
>
r
.
providerName
=
=
=
"
HeuristicFallback
"
)
&
&
query
.
unsortedResults
.
some
(
r
=
>
r
.
providerName
=
=
=
anotherHeuristicProvider
.
name
)
)
;
await
doEnter
(
)
;
assertEngagementTelemetry
(
[
{
selected_result
:
"
input_field
"
selected_result_subtype
:
"
"
provider
:
undefined
results
:
"
"
groups
:
"
"
}
]
)
;
noResponseProvider
.
done
(
)
;
}
)
;
cleanup
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
engagement_after_closing_results
(
)
{
const
TRIGGERS
=
[
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
(
)
=
>
{
AccessibilityUtils
.
setEnv
(
{
mustHaveAccessibleRule
:
false
}
)
;
EventUtils
.
synthesizeMouseAtCenter
(
document
.
getElementById
(
"
customizableui
-
special
-
spring2
"
)
{
}
)
;
AccessibilityUtils
.
resetEnv
(
)
;
}
]
;
for
(
const
trigger
of
TRIGGERS
)
{
await
doTest
(
async
(
)
=
>
{
await
openPopup
(
"
test
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
{
trigger
(
)
;
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
test
"
"
The
inputted
text
remains
even
if
closing
the
results
"
)
;
assertAbandonmentTelemetry
(
[
]
)
;
await
doEnter
(
)
;
assertEngagementTelemetry
(
[
{
selected_result
:
"
search_engine
"
selected_result_subtype
:
"
"
provider
:
"
HeuristicFallback
"
results
:
"
search_engine
"
groups
:
"
heuristic
"
}
]
)
;
}
)
;
}
}
)
;
add_task
(
async
function
enter_to_reload_current_url
(
)
{
await
doTest
(
async
(
)
=
>
{
await
openPopup
(
"
https
:
/
/
example
.
com
"
)
;
await
doEnter
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
gURLBar
.
inputField
{
}
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
window
.
document
.
activeElement
=
=
=
gURLBar
.
inputField
)
;
await
doEnter
(
)
;
assertEngagementTelemetry
(
[
{
selected_result
:
"
url
"
selected_result_subtype
:
"
"
provider
:
"
HeuristicFallback
"
results
:
"
url
"
groups
:
"
heuristic
"
}
{
selected_result
:
"
input_field
"
selected_result_subtype
:
"
"
provider
:
undefined
results
:
"
"
groups
:
"
"
}
]
)
;
}
)
;
}
)
;
