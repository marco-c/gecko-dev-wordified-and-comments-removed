"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
sys
.
mjs
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
sys
.
mjs
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
sys
.
mjs
"
UrlbarView
:
"
resource
:
/
/
/
modules
/
UrlbarView
.
sys
.
mjs
"
}
)
;
const
MAX_RESULT_COUNT
=
10
;
let
gProvider
;
add_setup
(
async
function
(
)
{
await
initExposureTest
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
ui
.
popup
.
disable_autohide
"
true
]
[
"
browser
.
urlbar
.
maxRichResults
"
MAX_RESULT_COUNT
]
]
}
)
;
await
Services
.
fog
.
testFlushAllChildren
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
gProvider
=
new
TestProvider
(
)
;
UrlbarProvidersManager
.
registerProvider
(
gProvider
)
;
let
originalRemoveStaleRowsTimeout
=
UrlbarView
.
removeStaleRowsTimeout
;
UrlbarView
.
removeStaleRowsTimeout
=
30000
;
registerCleanupFunction
(
(
)
=
>
{
UrlbarView
.
removeStaleRowsTimeout
=
originalRemoveStaleRowsTimeout
;
UrlbarProvidersManager
.
unregisterProvider
(
gProvider
)
;
}
)
;
}
)
;
add_task
(
async
function
noExposure
(
)
{
for
(
let
showExposureResults
of
[
true
false
]
)
{
await
do_noExposure
(
showExposureResults
)
;
}
}
)
;
async
function
do_noExposure
(
showExposureResults
)
{
info
(
"
Starting
do_noExposure
:
"
+
JSON
.
stringify
(
{
showExposureResults
}
)
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
exposureResults
"
"
history
"
]
[
"
browser
.
urlbar
.
showExposureResults
"
showExposureResults
]
]
}
)
;
gProvider
.
results
=
[
]
;
for
(
let
i
=
0
;
i
<
MAX_RESULT_COUNT
;
i
+
+
)
{
gProvider
.
results
.
push
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
{
suggestion
:
"
suggestion
"
+
i
engine
:
Services
.
search
.
defaultEngine
.
name
}
)
)
;
}
info
(
"
Doing
first
query
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
1
"
}
)
;
let
historyUrl
=
"
https
:
/
/
example
.
com
/
history
"
;
let
bookmarkUrl
=
"
https
:
/
/
example
.
com
/
bookmark
"
;
gProvider
.
results
=
[
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
{
url
:
historyUrl
}
)
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
{
url
:
bookmarkUrl
}
)
]
;
let
queryResolver
=
Promise
.
withResolvers
(
)
;
gProvider
.
finishQueryPromise
=
queryResolver
.
promise
;
let
lastRowPromise
=
promiseLastRowAppended
(
row
=
>
row
.
result
.
payload
.
url
=
=
bookmarkUrl
)
;
info
(
"
Starting
second
query
"
)
;
let
queryPromise
=
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
2
"
reopenOnBlur
:
false
}
)
;
info
(
"
Waiting
for
last
row
"
)
;
let
lastRow
=
await
lastRowPromise
;
info
(
"
Done
waiting
for
last
row
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
lastRow
)
"
The
new
bookmark
row
should
be
hidden
since
the
view
is
full
"
)
;
let
rows
=
UrlbarTestUtils
.
getResultsContainer
(
window
)
;
let
expectedCount
=
MAX_RESULT_COUNT
+
1
;
if
(
showExposureResults
)
{
expectedCount
+
+
;
}
Assert
.
equal
(
rows
.
children
.
length
expectedCount
"
The
view
has
the
expected
number
of
rows
"
)
;
for
(
let
i
=
0
;
i
<
MAX_RESULT_COUNT
;
i
+
+
)
{
let
row
=
rows
.
children
[
i
]
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
row
)
rows
[
{
i
}
]
should
be
visible
)
;
Assert
.
ok
(
row
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
rows
[
{
i
}
]
.
result
.
type
should
be
SEARCH
)
;
if
(
i
>
0
)
{
Assert
.
ok
(
row
.
result
.
payload
.
suggestion
rows
[
{
i
}
]
should
have
a
suggestion
)
;
}
}
let
expected
=
[
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
url
:
bookmarkUrl
}
]
;
if
(
showExposureResults
)
{
expected
.
unshift
(
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
url
:
historyUrl
}
)
;
}
for
(
let
i
=
0
;
i
<
expected
.
length
;
i
+
+
)
{
let
{
source
url
}
=
expected
[
i
]
;
let
row
=
rows
.
children
[
MAX_RESULT_COUNT
+
i
]
;
Assert
.
ok
(
row
rows
[
{
i
}
]
should
exist
)
;
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
row
)
rows
[
{
i
}
]
should
be
hidden
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
URL
rows
[
{
i
}
]
.
result
.
type
should
be
URL
)
;
Assert
.
equal
(
row
.
result
.
source
source
rows
[
{
i
}
]
.
result
.
source
should
be
as
expected
)
;
Assert
.
equal
(
row
.
result
.
payload
.
url
url
rows
[
{
i
}
]
URL
should
be
as
expected
)
;
}
info
(
"
Closing
view
and
blurring
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
gURLBar
.
blur
(
)
;
assertExposureTelemetry
(
[
]
)
;
queryResolver
.
resolve
(
)
;
await
queryPromise
;
await
SpecialPowers
.
popPrefEnv
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
}
add_task
(
async
function
exposure_append
(
)
{
for
(
let
showExposureResults
of
[
true
false
]
)
{
for
(
let
cancelSecondQuery
of
[
true
false
]
)
{
await
do_exposure_append
(
{
showExposureResults
cancelSecondQuery
}
)
;
}
}
}
)
;
async
function
do_exposure_append
(
{
showExposureResults
cancelSecondQuery
}
)
{
info
(
"
Starting
do_exposure_append
:
"
+
JSON
.
stringify
(
{
showExposureResults
cancelSecondQuery
}
)
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
exposureResults
"
"
search_suggest
"
]
[
"
browser
.
urlbar
.
showExposureResults
"
showExposureResults
]
]
}
)
;
gProvider
.
results
=
[
]
;
info
(
"
Doing
first
query
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
1
"
}
)
;
let
newSuggestion
=
"
new
suggestion
"
;
let
bookmarkUrl
=
"
https
:
/
/
example
.
com
/
bookmark
"
;
gProvider
.
results
=
[
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
{
suggestion
:
newSuggestion
engine
:
Services
.
search
.
defaultEngine
.
name
}
)
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
{
url
:
bookmarkUrl
}
)
]
;
let
queryResolver
=
Promise
.
withResolvers
(
)
;
gProvider
.
finishQueryPromise
=
queryResolver
.
promise
;
let
lastRowPromise
=
promiseLastRowAppended
(
row
=
>
row
.
result
.
payload
.
url
=
=
bookmarkUrl
)
;
info
(
"
Starting
second
query
"
)
;
let
queryPromise
=
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
2
"
reopenOnBlur
:
false
}
)
;
info
(
"
Waiting
for
last
row
"
)
;
let
lastRow
=
await
lastRowPromise
;
info
(
"
Done
waiting
for
last
row
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
lastRow
)
"
The
new
bookmark
row
should
be
visible
since
the
view
is
not
full
"
)
;
let
rows
=
UrlbarTestUtils
.
getResultsContainer
(
window
)
;
let
newSuggestionRow
=
[
.
.
.
rows
.
children
]
.
find
(
r
=
>
r
.
result
.
payload
.
suggestion
=
=
newSuggestion
)
;
if
(
showExposureResults
)
{
Assert
.
ok
(
newSuggestionRow
"
The
new
suggestion
row
should
have
been
added
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
newSuggestionRow
)
"
The
new
suggestion
row
should
be
visible
"
)
;
}
else
{
Assert
.
ok
(
!
newSuggestionRow
"
The
new
suggestion
row
should
not
have
been
added
"
)
;
}
if
(
!
cancelSecondQuery
)
{
queryResolver
.
resolve
(
)
;
await
queryPromise
;
}
info
(
"
Closing
view
and
blurring
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
gURLBar
.
blur
(
)
;
assertExposureTelemetry
(
[
{
results
:
"
search_suggest
"
}
]
)
;
queryResolver
.
resolve
(
)
;
await
queryPromise
;
await
SpecialPowers
.
popPrefEnv
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
}
add_task
(
async
function
exposure_replace
(
)
{
for
(
let
showExposureResults
of
[
true
false
]
)
{
for
(
let
cancelSecondQuery
of
[
true
false
]
)
{
await
do_exposure_replace
(
{
showExposureResults
cancelSecondQuery
}
)
;
}
}
}
)
;
async
function
do_exposure_replace
(
{
showExposureResults
cancelSecondQuery
}
)
{
info
(
"
Starting
do_exposure_replace
:
"
+
JSON
.
stringify
(
{
showExposureResults
cancelSecondQuery
}
)
)
;
gProvider
.
results
=
[
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
{
suggestion
:
"
suggestion
"
engine
:
Services
.
search
.
defaultEngine
.
name
}
)
]
;
info
(
"
Doing
first
query
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
1
"
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
exposureResults
"
"
search_suggest
"
]
[
"
browser
.
urlbar
.
showExposureResults
"
showExposureResults
]
]
}
)
;
let
newSuggestion
=
"
new
suggestion
"
;
let
bookmarkUrl
=
"
https
:
/
/
example
.
com
/
bookmark
"
;
gProvider
.
results
=
[
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
{
suggestion
:
newSuggestion
engine
:
Services
.
search
.
defaultEngine
.
name
}
)
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
{
url
:
bookmarkUrl
}
)
]
;
let
queryResolver
=
Promise
.
withResolvers
(
)
;
gProvider
.
finishQueryPromise
=
queryResolver
.
promise
;
let
lastRowPromise
=
promiseLastRowAppended
(
row
=
>
row
.
result
.
payload
.
url
=
=
bookmarkUrl
)
;
info
(
"
Starting
second
query
"
)
;
let
queryPromise
=
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
2
"
reopenOnBlur
:
false
}
)
;
info
(
"
Waiting
for
last
row
"
)
;
let
lastRow
=
await
lastRowPromise
;
info
(
"
Done
waiting
for
last
row
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
lastRow
)
"
The
new
bookmark
row
should
be
visible
since
the
view
is
not
full
"
)
;
let
rows
=
UrlbarTestUtils
.
getResultsContainer
(
window
)
;
let
newSuggestionRow
=
[
.
.
.
rows
.
children
]
.
find
(
r
=
>
r
.
result
.
payload
.
suggestion
=
=
newSuggestion
)
;
if
(
showExposureResults
)
{
Assert
.
ok
(
newSuggestionRow
"
The
new
suggestion
row
should
have
replaced
the
old
one
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
newSuggestionRow
)
"
The
new
suggestion
row
should
be
visible
"
)
;
}
else
{
Assert
.
ok
(
!
newSuggestionRow
"
The
new
suggestion
row
should
not
have
been
added
"
)
;
}
if
(
!
cancelSecondQuery
)
{
queryResolver
.
resolve
(
)
;
await
queryPromise
;
}
info
(
"
Closing
view
and
blurring
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
gURLBar
.
blur
(
)
;
assertExposureTelemetry
(
[
{
results
:
"
search_suggest
"
}
]
)
;
queryResolver
.
resolve
(
)
;
await
queryPromise
;
await
SpecialPowers
.
popPrefEnv
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
}
class
TestProvider
extends
UrlbarTestUtils
.
TestProvider
{
finishQueryPromise
=
null
;
async
startQuery
(
context
addCallback
)
{
for
(
let
result
of
this
.
results
)
{
addCallback
(
this
result
)
;
}
await
this
.
finishQueryPromise
;
}
}
function
promiseLastRowAppended
(
predicate
)
{
return
new
Promise
(
resolve
=
>
{
let
rows
=
UrlbarTestUtils
.
getResultsContainer
(
window
)
;
let
observer
=
new
MutationObserver
(
mutations
=
>
{
let
lastRow
=
rows
.
children
[
rows
.
children
.
length
-
1
]
;
info
(
"
Observed
mutation
lastRow
.
result
is
:
"
+
JSON
.
stringify
(
lastRow
.
result
)
)
;
if
(
predicate
(
lastRow
)
)
{
observer
.
disconnect
(
)
;
resolve
(
lastRow
)
;
}
}
)
;
observer
.
observe
(
rows
{
childList
:
true
}
)
;
}
)
;
}
