"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
UrlbarTestUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
BrowserTestUtils
:
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
FormHistoryTestUtils
:
"
resource
:
/
/
testing
-
common
/
FormHistoryTestUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
UrlbarController
:
"
resource
:
/
/
/
modules
/
UrlbarController
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
var
UrlbarTestUtils
=
{
SELECTED_RESULT_METHODS
:
{
enter
:
0
enterSelection
:
1
click
:
2
arrowEnterSelection
:
3
tabEnterSelection
:
4
rightClickEnter
:
5
}
init
(
scope
)
{
this
.
_testScope
=
scope
;
if
(
scope
)
{
this
.
Assert
=
scope
.
Assert
;
this
.
EventUtils
=
scope
.
EventUtils
;
}
}
async
promiseSearchComplete
(
win
)
{
return
this
.
promisePopupOpen
(
win
(
)
=
>
{
}
)
.
then
(
(
)
=
>
win
.
gURLBar
.
lastQueryContextPromise
)
;
}
async
promiseAutocompleteResultPopup
(
{
window
value
waitForFocus
fireInputEvent
=
false
selectionStart
=
-
1
selectionEnd
=
-
1
}
=
{
}
)
{
if
(
this
.
_testScope
)
{
await
this
.
_testScope
.
SimpleTest
.
promiseFocus
(
window
)
;
}
else
{
await
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
window
)
)
;
}
window
.
gURLBar
.
inputField
.
focus
(
)
;
if
(
UrlbarPrefs
.
get
(
"
trimURLs
"
)
&
&
value
!
=
BrowserUtils
.
trimURL
(
value
)
)
{
window
.
gURLBar
.
inputField
.
value
=
value
;
fireInputEvent
=
true
;
}
else
{
window
.
gURLBar
.
value
=
value
;
}
if
(
selectionStart
>
=
0
&
&
selectionEnd
>
=
0
)
{
window
.
gURLBar
.
selectionEnd
=
selectionEnd
;
window
.
gURLBar
.
selectionStart
=
selectionStart
;
}
if
(
fireInputEvent
)
{
this
.
fireInputEvent
(
window
)
;
}
else
{
window
.
gURLBar
.
setPageProxyState
(
"
invalid
"
)
;
window
.
gURLBar
.
startQuery
(
)
;
}
return
this
.
promiseSearchComplete
(
window
)
;
}
async
waitForAutocompleteResultAt
(
win
index
)
{
await
this
.
promiseSearchComplete
(
win
)
;
if
(
index
>
=
win
.
gURLBar
.
view
.
_rows
.
length
)
{
throw
new
Error
(
"
Not
enough
results
"
)
;
}
return
win
.
gURLBar
.
view
.
_rows
.
children
[
index
]
;
}
getOneOffSearchButtons
(
win
)
{
return
win
.
gURLBar
.
view
.
oneOffSearchButtons
;
}
getOneOffSearchButtonsVisible
(
win
)
{
let
buttons
=
this
.
getOneOffSearchButtons
(
win
)
;
return
buttons
.
style
.
display
!
=
"
none
"
&
&
!
buttons
.
container
.
hidden
;
}
async
getDetailsOfResultAt
(
win
index
)
{
let
element
=
await
this
.
waitForAutocompleteResultAt
(
win
index
)
;
let
details
=
{
}
;
let
result
=
element
.
result
;
let
{
url
postData
}
=
UrlbarUtils
.
getUrlFromResult
(
result
)
;
details
.
url
=
url
;
details
.
postData
=
postData
;
details
.
type
=
result
.
type
;
details
.
source
=
result
.
source
;
details
.
heuristic
=
result
.
heuristic
;
details
.
autofill
=
!
!
result
.
autofill
;
details
.
image
=
element
.
getElementsByClassName
(
"
urlbarView
-
favicon
"
)
[
0
]
.
src
;
details
.
title
=
result
.
title
;
details
.
tags
=
"
tags
"
in
result
.
payload
?
result
.
payload
.
tags
:
[
]
;
let
actions
=
element
.
getElementsByClassName
(
"
urlbarView
-
action
"
)
;
let
urls
=
element
.
getElementsByClassName
(
"
urlbarView
-
url
"
)
;
let
typeIcon
=
element
.
querySelector
(
"
.
urlbarView
-
type
-
icon
"
)
;
await
win
.
document
.
l10n
.
translateFragment
(
element
)
;
details
.
displayed
=
{
title
:
element
.
getElementsByClassName
(
"
urlbarView
-
title
"
)
[
0
]
.
textContent
action
:
actions
.
length
?
actions
[
0
]
.
textContent
:
null
url
:
urls
.
length
?
urls
[
0
]
.
textContent
:
null
typeIcon
:
typeIcon
?
win
.
getComputedStyle
(
typeIcon
)
[
"
background
-
image
"
]
:
null
}
;
details
.
element
=
{
action
:
element
.
getElementsByClassName
(
"
urlbarView
-
action
"
)
[
0
]
row
:
element
separator
:
element
.
getElementsByClassName
(
"
urlbarView
-
title
-
separator
"
)
[
0
]
title
:
element
.
getElementsByClassName
(
"
urlbarView
-
title
"
)
[
0
]
url
:
element
.
getElementsByClassName
(
"
urlbarView
-
url
"
)
[
0
]
}
;
if
(
details
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
)
{
details
.
searchParams
=
{
engine
:
result
.
payload
.
engine
keyword
:
result
.
payload
.
keyword
query
:
result
.
payload
.
query
suggestion
:
result
.
payload
.
suggestion
isSearchHistory
:
result
.
payload
.
isSearchHistory
inPrivateWindow
:
result
.
payload
.
inPrivateWindow
isPrivateEngine
:
result
.
payload
.
isPrivateEngine
}
;
}
else
if
(
details
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
)
{
details
.
keyword
=
result
.
payload
.
keyword
;
}
return
details
;
}
getSelectedElement
(
win
)
{
return
win
.
gURLBar
.
view
.
selectedElement
|
|
null
;
}
getSelectedElementIndex
(
win
)
{
return
win
.
gURLBar
.
view
.
selectedElementIndex
;
}
getSelectedRow
(
win
)
{
return
win
.
gURLBar
.
view
.
_getSelectedRow
(
)
|
|
null
;
}
getSelectedRowIndex
(
win
)
{
return
win
.
gURLBar
.
view
.
selectedRowIndex
;
}
setSelectedRowIndex
(
win
index
)
{
win
.
gURLBar
.
view
.
selectedRowIndex
=
index
;
}
getResultCount
(
win
)
{
return
win
.
gURLBar
.
view
.
_rows
.
children
.
length
;
}
promiseSuggestionsPresent
(
win
)
{
return
this
.
promiseSearchComplete
(
win
)
.
then
(
context
=
>
{
let
firstSearchSuggestionIndex
=
context
.
results
.
findIndex
(
r
=
>
r
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
r
.
payload
.
suggestion
)
;
if
(
firstSearchSuggestionIndex
=
=
-
1
)
{
throw
new
Error
(
"
Cannot
find
a
search
suggestion
"
)
;
}
return
firstSearchSuggestionIndex
;
}
)
;
}
promiseSpeculativeConnections
(
httpserver
count
)
{
if
(
!
httpserver
)
{
throw
new
Error
(
"
Must
provide
an
http
server
"
)
;
}
return
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
httpserver
.
connectionNumber
=
=
count
"
Waiting
for
speculative
connection
setup
"
)
;
}
async
promisePopupOpen
(
win
openFn
)
{
if
(
!
openFn
)
{
throw
new
Error
(
"
openFn
should
be
supplied
to
promisePopupOpen
"
)
;
}
await
openFn
(
)
;
if
(
win
.
gURLBar
.
view
.
isOpen
)
{
return
;
}
if
(
this
.
_testScope
)
{
this
.
_testScope
.
info
(
"
Awaiting
for
the
urlbar
panel
to
open
"
)
;
}
await
new
Promise
(
resolve
=
>
{
win
.
gURLBar
.
controller
.
addQueryListener
(
{
onViewOpen
(
)
{
win
.
gURLBar
.
controller
.
removeQueryListener
(
this
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
async
promisePopupClose
(
win
closeFn
=
null
)
{
if
(
closeFn
)
{
await
closeFn
(
)
;
}
else
{
win
.
gURLBar
.
view
.
close
(
)
;
}
if
(
!
win
.
gURLBar
.
view
.
isOpen
)
{
return
;
}
if
(
this
.
_testScope
)
{
this
.
_testScope
.
info
(
"
Awaiting
for
the
urlbar
panel
to
close
"
)
;
}
await
new
Promise
(
resolve
=
>
{
win
.
gURLBar
.
controller
.
addQueryListener
(
{
onViewClose
(
)
{
win
.
gURLBar
.
controller
.
removeQueryListener
(
this
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
isPopupOpen
(
win
)
{
return
win
.
gURLBar
.
view
.
isOpen
;
}
async
assertSearchMode
(
window
expectedSearchMode
)
{
this
.
Assert
.
equal
(
!
!
window
.
gURLBar
.
searchMode
window
.
gURLBar
.
hasAttribute
(
"
searchmode
"
)
"
Urlbar
should
never
be
in
search
mode
without
the
corresponding
attribute
.
"
)
;
if
(
!
expectedSearchMode
)
{
this
.
Assert
.
ok
(
!
window
.
gURLBar
.
searchMode
"
gURLBar
.
searchMode
not
expected
"
)
;
const
prefName
=
"
browser
.
urlbar
.
placeholderName
"
+
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
?
"
.
private
"
:
"
"
)
;
let
engineName
=
Services
.
prefs
.
getStringPref
(
prefName
"
"
)
;
this
.
Assert
.
deepEqual
(
window
.
document
.
l10n
.
getAttributes
(
window
.
gURLBar
.
inputField
)
engineName
?
{
id
:
"
urlbar
-
placeholder
-
with
-
name
"
args
:
{
name
:
engineName
}
}
:
{
id
:
"
urlbar
-
placeholder
"
args
:
null
}
"
Expected
placeholder
l10n
when
search
mode
is
inactive
"
)
;
return
;
}
this
.
Assert
.
deepEqual
(
window
.
gURLBar
.
searchMode
expectedSearchMode
"
Expected
searchMode
"
)
;
let
expectedTextContent
=
"
"
;
let
expectedL10n
=
{
id
:
null
args
:
null
}
;
if
(
expectedSearchMode
.
engineName
)
{
expectedTextContent
=
expectedSearchMode
.
engineName
;
}
else
if
(
expectedSearchMode
.
source
)
{
let
name
=
UrlbarUtils
.
getResultSourceName
(
expectedSearchMode
.
source
)
;
this
.
Assert
.
ok
(
name
"
Expected
result
source
should
have
a
name
"
)
;
expectedL10n
=
{
id
:
urlbar
-
search
-
mode
-
{
name
}
args
:
null
}
;
}
else
{
this
.
Assert
.
ok
(
false
"
Unexpected
searchMode
"
)
;
}
for
(
let
element
of
[
window
.
gURLBar
.
_searchModeIndicatorTitle
window
.
gURLBar
.
_searchModeLabel
]
)
{
if
(
expectedTextContent
)
{
this
.
Assert
.
equal
(
element
.
textContent
expectedTextContent
"
Expected
textContent
"
)
;
}
this
.
Assert
.
deepEqual
(
window
.
document
.
l10n
.
getAttributes
(
element
)
expectedL10n
"
Expected
l10n
"
)
;
}
let
expectedPlaceholderL10n
;
if
(
expectedSearchMode
.
engineName
)
{
expectedPlaceholderL10n
=
{
id
:
UrlbarUtils
.
WEB_ENGINE_NAMES
.
has
(
expectedSearchMode
.
engineName
)
?
"
urlbar
-
placeholder
-
search
-
mode
-
web
-
2
"
:
"
urlbar
-
placeholder
-
search
-
mode
-
other
-
engine
"
args
:
{
name
:
expectedSearchMode
.
engineName
}
}
;
}
else
if
(
expectedSearchMode
.
source
)
{
let
name
=
UrlbarUtils
.
getResultSourceName
(
expectedSearchMode
.
source
)
;
expectedPlaceholderL10n
=
{
id
:
urlbar
-
placeholder
-
search
-
mode
-
other
-
{
name
}
args
:
null
}
;
}
this
.
Assert
.
deepEqual
(
window
.
document
.
l10n
.
getAttributes
(
window
.
gURLBar
.
inputField
)
expectedPlaceholderL10n
"
Expected
placeholder
l10n
when
search
mode
is
active
"
)
;
if
(
expectedSearchMode
.
engineName
&
&
this
.
isPopupOpen
(
window
)
)
{
let
resultCount
=
this
.
getResultCount
(
window
)
;
for
(
let
i
=
0
;
i
<
resultCount
;
i
+
+
)
{
let
result
=
await
this
.
getDetailsOfResultAt
(
window
i
)
;
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
)
{
this
.
Assert
.
equal
(
expectedSearchMode
.
engineName
result
.
searchParams
.
engine
"
Search
mode
result
matches
engine
name
.
"
)
;
}
else
{
let
engine
=
Services
.
search
.
getEngineByName
(
expectedSearchMode
.
engineName
)
;
let
engineHost
=
engine
.
getResultDomain
(
)
;
let
resultUrl
=
new
URL
(
result
.
url
)
;
this
.
Assert
.
ok
(
resultUrl
.
host
.
includes
(
engineHost
)
"
Search
mode
result
matches
engine
host
.
"
)
;
}
}
}
}
async
enterSearchMode
(
window
searchMode
=
null
)
{
await
this
.
promiseSearchComplete
(
window
)
;
let
oneOffs
=
this
.
getOneOffSearchButtons
(
window
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
oneOffs
.
_rebuilding
"
Waiting
for
one
-
offs
to
finish
rebuilding
"
)
;
this
.
Assert
.
equal
(
UrlbarTestUtils
.
getOneOffSearchButtonsVisible
(
window
)
true
"
One
-
offs
are
visible
"
)
;
let
buttons
=
oneOffs
.
getSelectableButtons
(
true
)
;
if
(
!
searchMode
)
{
searchMode
=
{
engineName
:
buttons
[
0
]
.
engine
.
name
}
;
if
(
UrlbarUtils
.
WEB_ENGINE_NAMES
.
has
(
searchMode
.
engineName
)
)
{
searchMode
.
source
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
;
}
}
let
oneOff
=
buttons
.
find
(
o
=
>
searchMode
.
engineName
?
o
.
engine
.
name
=
=
searchMode
.
engineName
:
o
.
source
=
=
searchMode
.
source
)
;
this
.
Assert
.
ok
(
oneOff
"
Found
one
-
off
button
for
search
mode
"
)
;
this
.
EventUtils
.
synthesizeMouseAtCenter
(
oneOff
{
}
window
)
;
await
this
.
promiseSearchComplete
(
window
)
;
this
.
Assert
.
ok
(
this
.
isPopupOpen
(
window
)
"
Urlbar
view
is
still
open
.
"
)
;
await
this
.
assertSearchMode
(
window
searchMode
)
;
}
async
exitSearchMode
(
window
{
backspace
clickClose
waitForSearch
=
true
}
)
{
let
urlbar
=
window
.
gURLBar
;
if
(
!
urlbar
.
hasAttribute
(
"
breakout
-
extend
"
)
&
&
clickClose
)
{
if
(
waitForSearch
)
{
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
urlbar
.
setSearchMode
(
{
}
)
;
await
searchPromise
;
}
else
{
urlbar
.
setSearchMode
(
{
}
)
;
}
return
;
}
if
(
backspace
)
{
let
urlbarValue
=
urlbar
.
value
;
urlbar
.
selectionStart
=
urlbar
.
selectionEnd
=
0
;
if
(
waitForSearch
)
{
let
searchPromise
=
this
.
promiseSearchComplete
(
window
)
;
this
.
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
{
}
window
)
;
await
searchPromise
;
}
else
{
this
.
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
{
}
window
)
;
}
this
.
Assert
.
equal
(
urlbar
.
value
urlbarValue
"
Urlbar
value
hasn
'
t
changed
.
"
)
;
this
.
assertSearchMode
(
window
null
)
;
}
else
if
(
clickClose
)
{
let
indicator
=
urlbar
.
querySelector
(
"
#
urlbar
-
search
-
mode
-
indicator
"
)
;
this
.
EventUtils
.
synthesizeMouseAtCenter
(
indicator
{
type
:
"
mouseover
"
}
window
)
;
let
closeButton
=
urlbar
.
querySelector
(
"
#
urlbar
-
search
-
mode
-
indicator
-
close
"
)
;
if
(
waitForSearch
)
{
let
searchPromise
=
this
.
promiseSearchComplete
(
window
)
;
this
.
EventUtils
.
synthesizeMouseAtCenter
(
closeButton
{
}
window
)
;
await
searchPromise
;
}
else
{
this
.
EventUtils
.
synthesizeMouseAtCenter
(
closeButton
{
}
window
)
;
}
await
this
.
assertSearchMode
(
window
null
)
;
}
}
async
promiseUserContextId
(
win
)
{
const
defaultId
=
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
let
context
=
await
win
.
gURLBar
.
lastQueryContextPromise
;
return
context
.
userContextId
|
|
defaultId
;
}
fireInputEvent
(
win
)
{
let
event
=
new
InputEvent
(
"
input
"
{
data
:
win
.
gURLBar
.
value
[
win
.
gURLBar
.
value
.
length
-
1
]
|
|
null
}
)
;
win
.
gURLBar
.
inputField
.
dispatchEvent
(
event
)
;
}
newMockController
(
options
=
{
}
)
{
return
new
UrlbarController
(
Object
.
assign
(
{
input
:
{
isPrivate
:
false
window
:
{
location
:
{
href
:
AppConstants
.
BROWSER_CHROME_URL
}
}
}
}
options
)
)
;
}
async
initXPCShellDependencies
(
)
{
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
history
-
startup
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
observe
(
null
"
profile
-
after
-
change
"
null
)
;
try
{
await
AddonTestUtils
.
promiseStartupManager
(
)
;
}
catch
(
error
)
{
if
(
!
error
.
message
.
includes
(
"
already
started
"
)
)
{
throw
error
;
}
}
}
}
;
UrlbarTestUtils
.
formHistory
=
{
add
(
values
=
[
]
window
=
BrowserWindowTracker
.
getTopWindow
(
)
)
{
let
fieldname
=
this
.
getFormHistoryName
(
window
)
;
return
FormHistoryTestUtils
.
add
(
fieldname
values
)
;
}
remove
(
values
=
[
]
window
=
BrowserWindowTracker
.
getTopWindow
(
)
)
{
let
fieldname
=
this
.
getFormHistoryName
(
window
)
;
return
FormHistoryTestUtils
.
remove
(
fieldname
values
)
;
}
clear
(
window
=
BrowserWindowTracker
.
getTopWindow
(
)
)
{
let
fieldname
=
this
.
getFormHistoryName
(
window
)
;
return
FormHistoryTestUtils
.
clear
(
fieldname
)
;
}
search
(
criteria
=
{
}
window
=
BrowserWindowTracker
.
getTopWindow
(
)
)
{
let
fieldname
=
this
.
getFormHistoryName
(
window
)
;
return
FormHistoryTestUtils
.
search
(
fieldname
criteria
)
;
}
promiseChanged
(
change
=
null
)
{
return
TestUtils
.
topicObserved
(
"
satchel
-
storage
-
changed
"
(
subject
data
)
=
>
!
change
|
|
data
=
=
"
formhistory
-
"
+
change
)
;
}
getFormHistoryName
(
window
=
BrowserWindowTracker
.
getTopWindow
(
)
)
{
return
window
?
window
.
gURLBar
.
formHistoryName
:
"
searchbar
-
history
"
;
}
}
;
class
TestProvider
extends
UrlbarProvider
{
constructor
(
{
results
name
=
Math
.
floor
(
Math
.
random
(
)
*
100000
)
type
=
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
priority
=
0
addTimeout
=
0
onCancel
=
null
}
=
{
}
)
{
super
(
)
;
this
.
_results
=
results
;
this
.
_name
=
name
;
this
.
_type
=
type
;
this
.
_priority
=
priority
;
this
.
_addTimeout
=
addTimeout
;
this
.
_onCancel
=
onCancel
;
}
get
name
(
)
{
return
"
TestProvider
"
+
this
.
_name
;
}
get
type
(
)
{
return
this
.
_type
;
}
getPriority
(
context
)
{
return
this
.
_priority
;
}
isActive
(
context
)
{
return
true
;
}
async
startQuery
(
context
addCallback
)
{
for
(
let
result
of
this
.
_results
)
{
if
(
!
this
.
_addTimeout
)
{
addCallback
(
this
result
)
;
}
else
{
await
new
Promise
(
resolve
=
>
{
setTimeout
(
(
)
=
>
{
addCallback
(
this
result
)
;
resolve
(
)
;
}
this
.
_addTimeout
)
;
}
)
;
}
}
}
cancelQuery
(
context
)
{
if
(
this
.
_onCancel
)
{
this
.
_onCancel
(
)
;
}
}
}
UrlbarTestUtils
.
TestProvider
=
TestProvider
;
