"
use
strict
"
;
let
testEngine
;
add_setup
(
async
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
scotchBonnet
.
enableOverride
"
false
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
urlbar
.
tabToSearch
.
onboard
.
interactionsLeft
"
0
)
;
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
Test
"
}
)
;
testEngine
=
await
Services
.
search
.
getEngineByName
(
"
Test
"
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
tabToSearch
.
onboard
.
interactionsLeft
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
scotchBonnet
.
enableOverride
"
)
;
}
)
;
}
)
;
add_task
(
async
function
basic
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
example
.
com
/
"
]
)
;
let
context
=
createContext
(
"
examp
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
testEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
testEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
]
}
)
;
info
(
"
Repeat
the
search
but
with
tab
-
to
-
search
disabled
through
pref
.
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
engines
"
false
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
]
}
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
engines
"
)
;
await
cleanupPlaces
(
)
;
}
)
;
add_task
(
async
function
noAutofill
(
)
{
let
context
=
createContext
(
"
examp
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
await
Services
.
search
.
defaultEngine
.
getIconURL
(
)
heuristic
:
true
providerName
:
"
HeuristicFallback
"
}
)
makeSearchResult
(
context
{
engineName
:
testEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
testEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
]
}
)
;
}
)
;
add_task
(
async
function
autofillDoesNotMatchEngine
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
example
.
test
.
ca
/
"
]
)
;
let
context
=
createContext
(
"
example
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
test
.
ca
/
"
completed
:
"
https
:
/
/
example
.
test
.
ca
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
test
.
ca
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
test
.
ca
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
}
)
;
add_task
(
async
function
ignoreWww
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
www
.
example
.
com
/
"
]
)
;
let
context
=
createContext
(
"
www
.
examp
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
www
.
example
.
com
/
"
completed
:
"
https
:
/
/
www
.
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
www
.
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
www
.
example
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
testEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
testEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
foo
.
bar
/
"
]
)
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestWww
"
search_url
:
"
https
:
/
/
www
.
foo
.
bar
/
"
}
{
skipUnload
:
true
}
)
;
let
wwwTestEngine
=
Services
.
search
.
getEngineByName
(
"
TestWww
"
)
;
context
=
createContext
(
"
foo
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
foo
.
bar
/
"
completed
:
"
https
:
/
/
foo
.
bar
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
foo
.
bar
/
"
title
:
"
test
visit
for
https
:
/
/
foo
.
bar
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
wwwTestEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
wwwTestEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
www
.
foo
.
bar
/
"
]
)
;
context
=
createContext
(
"
foo
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
foo
.
bar
/
"
completed
:
"
https
:
/
/
www
.
foo
.
bar
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
www
.
foo
.
bar
/
"
title
:
"
test
visit
for
https
:
/
/
www
.
foo
.
bar
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
wwwTestEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
wwwTestEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
conflictingEngines
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
foobar
.
com
/
"
"
https
:
/
/
foo
.
com
/
"
]
)
;
}
let
extension1
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestFooBar
"
search_url
:
"
https
:
/
/
foobar
.
com
/
"
}
{
skipUnload
:
true
}
)
;
let
extension2
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestFoo
"
search_url
:
"
https
:
/
/
foo
.
com
/
"
}
{
skipUnload
:
true
}
)
;
let
fooBarTestEngine
=
Services
.
search
.
getEngineByName
(
"
TestFooBar
"
)
;
let
fooTestEngine
=
Services
.
search
.
getEngineByName
(
"
TestFoo
"
)
;
let
context
=
createContext
(
"
foo
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
foo
.
com
/
"
completed
:
"
https
:
/
/
foo
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
foo
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
foo
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
fooTestEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
fooTestEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
foobar
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
foobar
.
com
/
"
providerName
:
"
Places
"
}
)
]
}
)
;
context
=
createContext
(
"
foob
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
foobar
.
com
/
"
completed
:
"
https
:
/
/
foobar
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
foobar
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
foobar
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
fooBarTestEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
fooBarTestEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension1
.
unload
(
)
;
await
extension2
.
unload
(
)
;
}
)
;
add_task
(
async
function
multipleEnginesForHostname
(
)
{
info
(
"
In
case
of
multiple
engines
only
one
tab
-
to
-
search
result
should
be
returned
"
)
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestMaps
"
search_url
:
"
https
:
/
/
example
.
com
/
maps
/
"
}
{
skipUnload
:
true
}
)
;
let
context
=
createContext
(
"
examp
"
{
isPrivate
:
false
}
)
;
let
maxResultCount
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
for
(
let
i
=
0
;
i
<
maxResultCount
;
i
+
+
)
{
await
PlacesTestUtils
.
addVisits
(
"
https
:
/
/
example
.
com
/
"
)
;
}
let
otherVisitResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResultCount
;
i
+
+
)
{
let
url
=
"
https
:
/
/
mochi
.
test
:
8888
/
example
/
"
+
i
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
otherVisitResults
.
unshift
(
makeVisitResult
(
context
{
uri
:
url
title
:
"
test
visit
for
"
+
url
}
)
)
;
}
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
testEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
testEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
.
.
.
otherVisitResults
.
slice
(
0
maxResultCount
-
2
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_casing
(
)
{
info
(
"
Tab
-
to
-
search
results
appear
also
in
case
of
different
casing
.
"
)
;
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
example
.
com
/
"
]
)
;
let
context
=
createContext
(
"
eXAm
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
eXAmple
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
testEngine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
testEngine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
}
)
;
add_task
(
async
function
test_publicSuffix
(
)
{
info
(
"
Tab
-
to
-
search
results
appear
also
in
case
of
partial
host
match
.
"
)
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
MyTest
"
search_url
:
"
https
:
/
/
test
.
mytest
.
it
/
"
}
{
skipUnload
:
true
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
MyTest
"
)
;
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
test
.
mytest
.
it
/
"
]
)
;
let
context
=
createContext
(
"
my
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
await
Services
.
search
.
defaultEngine
.
getIconURL
(
)
heuristic
:
true
providerName
:
"
HeuristicFallback
"
}
)
makeSearchResult
(
context
{
engineName
:
engine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
engine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
satisfiesAutofillThreshold
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
test
.
mytest
.
it
/
"
title
:
"
test
visit
for
https
:
/
/
test
.
mytest
.
it
/
"
providerName
:
"
Places
"
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_publicSuffixIsHost
(
)
{
info
(
"
Tab
-
to
-
search
results
does
not
appear
in
case
we
autofill
a
suffix
.
"
)
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
SuffixTest
"
search_url
:
"
https
:
/
/
somesuffix
.
com
.
mx
/
"
}
{
skipUnload
:
true
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
com
.
mx
/
"
]
)
;
let
context
=
createContext
(
"
co
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
com
.
mx
/
"
completed
:
"
https
:
/
/
com
.
mx
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
com
.
mx
/
"
title
:
"
test
visit
for
https
:
/
/
com
.
mx
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_disabledEngine
(
)
{
info
(
"
Tab
-
to
-
search
results
does
not
appear
for
a
Pref
-
disabled
engine
.
"
)
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
Disabled
"
search_url
:
"
https
:
/
/
disabled
.
com
/
"
}
{
skipUnload
:
true
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
Disabled
"
)
;
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
disabled
.
com
/
"
]
)
;
let
context
=
createContext
(
"
dis
"
{
isPrivate
:
false
}
)
;
info
(
"
Sanity
check
that
the
engine
would
appear
.
"
)
;
await
check_results
(
{
context
autofilled
:
"
disabled
.
com
/
"
completed
:
"
https
:
/
/
disabled
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
disabled
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
disabled
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
makeSearchResult
(
context
{
engineName
:
engine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
engine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
}
)
]
}
)
;
info
(
"
Now
disable
the
engine
.
"
)
;
engine
.
hideOneOffButton
=
true
;
await
check_results
(
{
context
autofilled
:
"
disabled
.
com
/
"
completed
:
"
https
:
/
/
disabled
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
disabled
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
disabled
.
com
/
"
heuristic
:
true
providerName
:
"
Autofill
"
}
)
]
}
)
;
engine
.
hideOneOffButton
=
false
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
}
)
;
