"
use
strict
"
;
const
TEST_URL
=
"
http
:
/
/
example
.
com
"
;
const
MATCH
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
UrlbarUtils
.
RESULT_SOURCE
.
TABS
{
url
:
TEST_URL
}
)
;
const
TELEMETRY_1ST_RESULT
=
"
PLACES_AUTOCOMPLETE_1ST_RESULT_TIME_MS
"
;
const
TELEMETRY_6_FIRST_RESULTS
=
"
PLACES_AUTOCOMPLETE_6_FIRST_RESULTS_TIME_MS
"
;
let
controller
;
let
firstHistogram
;
let
sixthHistogram
;
class
DelayedProvider
extends
UrlbarTestUtils
.
TestProvider
{
async
startQuery
(
context
add
)
{
Assert
.
ok
(
context
"
context
is
passed
-
in
"
)
;
Assert
.
equal
(
typeof
add
"
function
"
"
add
is
a
callback
"
)
;
this
.
_add
=
add
;
await
new
Promise
(
resolve
=
>
{
this
.
_resultsAdded
=
resolve
;
}
)
;
}
async
addResults
(
matches
finish
=
true
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
!
this
.
_add
"
Waiting
for
the
_add
callback
"
)
;
for
(
const
match
of
matches
)
{
this
.
_add
(
this
match
)
;
}
if
(
finish
)
{
this
.
_add
=
null
;
this
.
_resultsAdded
(
)
;
}
}
}
function
getHistogramReportsCount
(
results
)
{
let
sum
=
0
;
for
(
let
[
value
]
of
Object
.
entries
(
results
.
values
)
)
{
sum
+
=
value
;
}
return
sum
;
}
add_setup
(
function
(
)
{
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
firstHistogram
=
Services
.
telemetry
.
getHistogramById
(
TELEMETRY_1ST_RESULT
)
;
sixthHistogram
=
Services
.
telemetry
.
getHistogramById
(
TELEMETRY_6_FIRST_RESULTS
)
;
}
)
;
add_task
(
async
function
test_n_autocomplete_cancel
(
)
{
firstHistogram
.
clear
(
)
;
sixthHistogram
.
clear
(
)
;
let
provider
=
new
UrlbarTestUtils
.
TestProvider
(
{
results
:
[
]
}
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
const
context
=
createContext
(
TEST_URL
{
providers
:
[
provider
.
name
]
}
)
;
Assert
.
ok
(
!
context
.
firstTimerId
"
Should
not
have
started
first
result
stopwatch
"
)
;
Assert
.
ok
(
!
context
.
sixthTimerId
"
Should
not
have
started
first
6
results
stopwatch
"
)
;
let
startQueryPromise
=
controller
.
startQuery
(
context
)
;
Assert
.
ok
(
!
!
context
.
firstTimerId
"
Should
have
started
first
result
stopwatch
"
)
;
Assert
.
ok
(
!
!
context
.
sixthTimerId
"
Should
have
started
first
6
results
stopwatch
"
)
;
controller
.
cancelQuery
(
context
)
;
await
startQueryPromise
;
Assert
.
ok
(
!
context
.
firstTimerId
"
Should
have
canceled
first
result
stopwatch
"
)
;
Assert
.
ok
(
!
context
.
sixthTimerId
"
Should
have
canceled
first
6
results
stopwatch
"
)
;
let
results
=
firstHistogram
.
snapshot
(
)
;
Assert
.
equal
(
results
.
sum
0
"
Should
not
have
recorded
any
times
(
first
result
)
"
)
;
results
=
sixthHistogram
.
snapshot
(
)
;
Assert
.
equal
(
results
.
sum
0
"
Should
not
have
recorded
any
times
(
first
6
results
)
"
)
;
}
)
;
add_task
(
async
function
test_n_autocomplete_results
(
)
{
firstHistogram
.
clear
(
)
;
sixthHistogram
.
clear
(
)
;
let
provider
=
new
DelayedProvider
(
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
const
context
=
createContext
(
TEST_URL
{
providers
:
[
provider
.
name
]
}
)
;
let
resultsPromise
=
promiseControllerNotification
(
controller
"
onQueryResults
"
)
;
Assert
.
ok
(
!
context
.
firstTimerId
"
Should
not
have
started
first
result
stopwatch
"
)
;
Assert
.
ok
(
!
context
.
sixthTimerId
"
Should
not
have
started
first
6
results
stopwatch
"
)
;
controller
.
startQuery
(
context
)
;
Assert
.
ok
(
!
!
context
.
firstTimerId
"
Should
have
started
first
result
stopwatch
"
)
;
Assert
.
ok
(
!
!
context
.
sixthTimerId
"
Should
have
started
first
6
results
stopwatch
"
)
;
await
provider
.
addResults
(
[
MATCH
]
false
)
;
await
resultsPromise
;
Assert
.
ok
(
!
context
.
firstTimerId
"
Should
have
stopped
the
first
stopwatch
"
)
;
Assert
.
ok
(
!
!
context
.
sixthTimerId
"
Should
have
kept
the
first
6
results
stopwatch
running
"
)
;
let
firstResults
=
firstHistogram
.
snapshot
(
)
;
let
first6Results
=
sixthHistogram
.
snapshot
(
)
;
Assert
.
equal
(
getHistogramReportsCount
(
firstResults
)
1
"
Should
have
recorded
one
time
for
the
first
result
"
)
;
Assert
.
equal
(
getHistogramReportsCount
(
first6Results
)
0
"
Should
not
have
recorded
any
times
(
first
6
results
)
"
)
;
for
(
let
i
=
0
;
i
<
5
;
i
+
+
)
{
resultsPromise
=
promiseControllerNotification
(
controller
"
onQueryResults
"
)
;
await
provider
.
addResults
(
[
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
UrlbarUtils
.
RESULT_SOURCE
.
TABS
{
url
:
TEST_URL
+
"
/
"
+
i
}
)
]
false
)
;
await
resultsPromise
;
}
Assert
.
ok
(
!
context
.
firstTimerId
"
Should
have
stopped
the
first
stopwatch
"
)
;
Assert
.
ok
(
!
context
.
sixthTimerId
"
Should
have
stopped
the
first
6
results
stopwatch
"
)
;
let
updatedResults
=
firstHistogram
.
snapshot
(
)
;
let
updated6Results
=
sixthHistogram
.
snapshot
(
)
;
Assert
.
deepEqual
(
updatedResults
firstResults
"
Should
not
have
changed
the
histogram
for
the
first
result
"
)
;
Assert
.
equal
(
getHistogramReportsCount
(
updated6Results
)
1
"
Should
have
recorded
one
time
for
the
first
6
results
"
)
;
resultsPromise
=
promiseControllerNotification
(
controller
"
onQueryResults
"
)
;
await
provider
.
addResults
(
[
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
UrlbarUtils
.
RESULT_SOURCE
.
TABS
{
url
:
TEST_URL
+
"
/
6
"
}
)
]
)
;
await
resultsPromise
;
let
secondUpdateResults
=
firstHistogram
.
snapshot
(
)
;
let
secondUpdate6Results
=
sixthHistogram
.
snapshot
(
)
;
Assert
.
deepEqual
(
secondUpdateResults
firstResults
"
Should
not
have
changed
the
histogram
for
the
first
result
"
)
;
Assert
.
equal
(
getHistogramReportsCount
(
secondUpdate6Results
)
1
"
Should
not
have
changed
the
histogram
for
the
first
6
results
"
)
;
}
)
;
