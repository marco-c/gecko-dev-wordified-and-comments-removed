const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
{
UrlbarMuxer
UrlbarProvider
UrlbarQueryContext
UrlbarUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
HttpServer
:
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
UrlbarController
:
"
resource
:
/
/
/
modules
/
UrlbarController
.
jsm
"
UrlbarInput
:
"
resource
:
/
/
/
modules
/
UrlbarInput
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProviderOpenTabs
:
"
resource
:
/
/
/
modules
/
UrlbarProviderOpenTabs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarTestUtils
:
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
}
)
;
const
{
sinon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
jsm
"
)
;
AddonTestUtils
.
init
(
this
false
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
42
"
"
42
"
)
;
add_task
(
async
function
initXPCShellDependencies
(
)
{
await
UrlbarTestUtils
.
initXPCShellDependencies
(
)
;
}
)
;
function
createContext
(
searchString
=
"
foo
"
properties
=
{
}
)
{
info
(
Creating
new
queryContext
with
searchString
:
{
searchString
}
)
;
let
context
=
new
UrlbarQueryContext
(
Object
.
assign
(
{
allowAutofill
:
UrlbarPrefs
.
get
(
"
autoFill
"
)
isPrivate
:
true
maxResults
:
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
searchString
}
properties
)
)
;
UrlbarTokenizer
.
tokenize
(
context
)
;
return
context
;
}
function
promiseControllerNotification
(
controller
notification
expected
=
true
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
proxifiedObserver
=
new
Proxy
(
{
}
{
get
:
(
target
name
)
=
>
{
if
(
name
=
=
notification
)
{
return
(
.
.
.
args
)
=
>
{
controller
.
removeQueryListener
(
proxifiedObserver
)
;
if
(
expected
)
{
resolve
(
args
)
;
}
else
{
reject
(
)
;
}
}
;
}
return
(
)
=
>
false
;
}
}
)
;
controller
.
addQueryListener
(
proxifiedObserver
)
;
}
)
;
}
class
TestProvider
extends
UrlbarTestUtils
.
TestProvider
{
isActive
(
context
)
{
Assert
.
ok
(
context
"
context
is
passed
-
in
"
)
;
return
true
;
}
getPriority
(
context
)
{
Assert
.
ok
(
context
"
context
is
passed
-
in
"
)
;
return
0
;
}
async
startQuery
(
context
add
)
{
Assert
.
ok
(
context
"
context
is
passed
-
in
"
)
;
Assert
.
equal
(
typeof
add
"
function
"
"
add
is
a
callback
"
)
;
this
.
_context
=
context
;
for
(
const
result
of
this
.
_results
)
{
add
(
this
result
)
;
}
}
cancelQuery
(
context
)
{
if
(
this
.
_context
)
{
Assert
.
equal
(
this
.
_context
context
"
cancelQuery
:
context
is
the
same
"
)
;
}
if
(
this
.
_onCancel
)
{
this
.
_onCancel
(
)
;
}
}
}
function
convertToUtf8
(
str
)
{
return
String
.
fromCharCode
(
.
.
.
new
TextEncoder
(
)
.
encode
(
str
)
)
;
}
function
registerBasicTestProvider
(
results
=
[
]
onCancel
type
)
{
let
provider
=
new
TestProvider
(
{
results
onCancel
type
}
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
return
provider
.
name
;
}
function
makeTestServer
(
port
=
-
1
)
{
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
start
(
port
)
;
registerCleanupFunction
(
(
)
=
>
httpServer
.
stop
(
(
)
=
>
{
}
)
)
;
return
httpServer
;
}
async
function
addTestEngine
(
basename
httpServer
=
undefined
)
{
httpServer
=
httpServer
|
|
makeTestServer
(
)
;
httpServer
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
let
dataUrl
=
"
http
:
/
/
localhost
:
"
+
httpServer
.
identity
.
primaryPort
+
"
/
data
/
"
;
let
geoPref
=
"
browser
.
search
.
geoip
.
url
"
;
Services
.
prefs
.
setCharPref
(
geoPref
"
"
)
;
registerCleanupFunction
(
(
)
=
>
Services
.
prefs
.
clearUserPref
(
geoPref
)
)
;
info
(
"
Adding
engine
:
"
+
basename
)
;
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
obs
(
subject
topic
data
)
{
let
engine
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
info
(
"
Observed
"
+
data
+
"
for
"
+
engine
.
name
)
;
if
(
data
!
=
"
engine
-
added
"
|
|
engine
.
name
!
=
basename
)
{
return
;
}
Services
.
obs
.
removeObserver
(
obs
"
browser
-
search
-
engine
-
modified
"
)
;
registerCleanupFunction
(
(
)
=
>
Services
.
search
.
removeEngine
(
engine
)
)
;
resolve
(
engine
)
;
}
"
browser
-
search
-
engine
-
modified
"
)
;
info
(
"
Adding
engine
from
URL
:
"
+
dataUrl
+
basename
)
;
Services
.
search
.
addOpenSearchEngine
(
dataUrl
+
basename
null
)
;
}
)
;
}
async
function
addTestSuggestionsEngine
(
suggestionsFn
=
null
)
{
let
server
=
makeTestServer
(
9000
)
;
server
.
registerPathHandler
(
"
/
suggest
"
(
req
resp
)
=
>
{
let
searchStr
=
decodeURIComponent
(
req
.
queryString
.
replace
(
/
\
+
/
g
"
"
)
)
;
let
suggestions
=
suggestionsFn
?
suggestionsFn
(
searchStr
)
:
[
searchStr
]
.
concat
(
[
"
foo
"
"
bar
"
]
.
map
(
s
=
>
searchStr
+
"
"
+
s
)
)
;
let
data
=
[
searchStr
suggestions
]
;
resp
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
false
)
;
resp
.
write
(
JSON
.
stringify
(
data
)
)
;
}
)
;
let
engine
=
await
addTestEngine
(
"
engine
-
suggestions
.
xml
"
server
)
;
return
engine
;
}
async
function
addTestTailSuggestionsEngine
(
suggestionsFn
=
null
)
{
let
server
=
makeTestServer
(
9001
)
;
server
.
registerPathHandler
(
"
/
suggest
"
(
req
resp
)
=
>
{
let
searchStr
=
decodeURIComponent
(
req
.
queryString
.
replace
(
/
\
+
/
g
"
"
)
)
;
let
suggestions
=
suggestionsFn
?
suggestionsFn
(
searchStr
)
:
[
"
what
time
is
it
in
t
"
[
"
what
is
the
time
today
texas
"
]
.
concat
(
[
"
toronto
"
"
tunisia
"
]
.
map
(
s
=
>
searchStr
+
s
.
slice
(
1
)
)
)
[
]
{
"
google
:
irrelevantparameter
"
:
[
]
"
google
:
suggestdetail
"
:
[
{
}
]
.
concat
(
[
"
toronto
"
"
tunisia
"
]
.
map
(
s
=
>
(
{
mp
:
"
"
t
:
s
}
)
)
)
}
]
;
let
data
=
suggestions
;
let
jsonString
=
JSON
.
stringify
(
data
)
;
let
stringOfUtf8Bytes
=
convertToUtf8
(
jsonString
)
;
resp
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
false
)
;
resp
.
write
(
stringOfUtf8Bytes
)
;
}
)
;
let
engine
=
await
addTestEngine
(
"
engine
-
tail
-
suggestions
.
xml
"
server
)
;
return
engine
;
}
function
makeBookmarkResult
(
queryContext
{
title
uri
iconUri
tags
=
[
]
heuristic
=
false
}
)
{
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
url
:
[
uri
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
[
typeof
iconUri
!
=
"
undefined
"
?
iconUri
:
page
-
icon
:
{
uri
}
]
title
:
[
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
tags
:
[
tags
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
}
)
)
;
result
.
heuristic
=
heuristic
;
return
result
;
}
function
makeFormHistoryResult
(
queryContext
{
suggestion
engineName
}
)
{
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
engine
:
engineName
suggestion
:
[
suggestion
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
lowerCaseSuggestion
:
suggestion
.
toLocaleLowerCase
(
)
}
)
)
;
}
function
makeOmniboxResult
(
queryContext
{
content
description
keyword
heuristic
=
false
}
)
{
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
title
:
[
description
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
content
:
[
content
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
keyword
:
[
keyword
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
[
UrlbarUtils
.
ICON
.
EXTENSION
]
}
)
)
;
result
.
heuristic
=
heuristic
;
return
result
;
}
function
makeSearchResult
(
queryContext
{
suggestion
tailPrefix
tail
tailOffsetIndex
engineName
alias
query
engineIconUri
heuristic
=
false
keywordOffer
}
)
{
if
(
!
keywordOffer
)
{
keywordOffer
=
UrlbarUtils
.
KEYWORD_OFFER
.
NONE
;
if
(
alias
&
&
!
query
.
trim
(
)
&
&
alias
.
startsWith
(
"
"
)
)
{
keywordOffer
=
heuristic
?
UrlbarUtils
.
KEYWORD_OFFER
.
HIDE
:
UrlbarUtils
.
KEYWORD_OFFER
.
SHOW
;
}
}
if
(
tail
&
&
!
tailPrefix
)
{
tailPrefix
=
"
"
;
}
if
(
!
tailOffsetIndex
)
{
tailOffsetIndex
=
tail
?
suggestion
.
indexOf
(
tail
)
:
-
1
;
}
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
engine
:
[
engineName
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
suggestion
:
[
suggestion
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
tailPrefix
tail
:
[
tail
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
tailOffsetIndex
keyword
:
[
alias
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
query
:
[
typeof
query
!
=
"
undefined
"
?
query
:
queryContext
.
searchString
.
trim
(
)
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
isSearchHistory
:
false
icon
:
[
engineIconUri
?
engineIconUri
:
"
"
]
keywordOffer
}
)
)
;
if
(
typeof
suggestion
=
=
"
string
"
)
{
result
.
payload
.
lowerCaseSuggestion
=
result
.
payload
.
suggestion
.
toLocaleLowerCase
(
)
;
}
result
.
heuristic
=
heuristic
;
return
result
;
}
function
makeVisitResult
(
queryContext
{
title
uri
iconUri
tags
=
null
heuristic
=
false
}
)
{
let
payload
=
{
url
:
[
uri
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
[
typeof
iconUri
!
=
"
undefined
"
?
iconUri
:
page
-
icon
:
{
uri
}
]
title
:
[
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
}
;
if
(
!
heuristic
|
|
tags
)
{
payload
.
tags
=
[
tags
|
|
[
]
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
;
}
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
payload
)
)
;
result
.
heuristic
=
heuristic
;
return
result
;
}
async
function
check_results
(
{
context
matches
=
[
]
}
=
{
}
)
{
if
(
!
context
)
{
return
;
}
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
{
input
:
{
isPrivate
:
context
.
isPrivate
window
:
{
location
:
{
href
:
AppConstants
.
BROWSER_CHROME_URL
}
}
autofillFirstResult
(
)
{
}
}
}
)
;
await
controller
.
startQuery
(
context
)
;
Assert
.
equal
(
context
.
results
.
length
matches
.
length
"
Found
the
expected
number
of
results
.
"
)
;
Assert
.
deepEqual
(
matches
.
map
(
m
=
>
m
.
payload
)
context
.
results
.
map
(
m
=
>
m
.
payload
)
"
Payloads
are
the
same
.
"
)
;
Assert
.
deepEqual
(
matches
.
map
(
m
=
>
m
.
heuristic
)
context
.
results
.
map
(
m
=
>
m
.
heuristic
)
"
Heuristic
results
are
correctly
flagged
.
"
)
;
}
