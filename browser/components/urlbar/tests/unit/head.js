const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
var
{
UrlbarMuxer
UrlbarProvider
UrlbarQueryContext
UrlbarUtils
}
=
ChromeUtils
.
importESModule
(
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarUtils
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
HttpServer
:
"
resource
:
/
/
testing
-
common
/
httpd
.
sys
.
mjs
"
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
sys
.
mjs
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
UrlbarController
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarController
.
sys
.
mjs
"
UrlbarPrefs
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarPrefs
.
sys
.
mjs
"
UrlbarProviderOpenTabs
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarProviderOpenTabs
.
sys
.
mjs
"
UrlbarProvidersManager
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarProvidersManager
.
sys
.
mjs
"
UrlbarResult
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarResult
.
sys
.
mjs
"
UrlbarTokenizer
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarTokenizer
.
sys
.
mjs
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
QuickSuggestTestUtils
"
(
)
=
>
{
const
{
QuickSuggestTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
QuickSuggestTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
MerinoTestUtils
"
(
)
=
>
{
const
{
MerinoTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MerinoTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
UrlbarTestUtils
"
(
)
=
>
{
const
{
UrlbarTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
GeolocationTestUtils
"
(
)
=
>
{
const
{
GeolocationTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
GeolocationTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
PlacesFrecencyRecalculator
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
places
/
frecency
-
recalculator
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
wrappedJSObject
;
}
)
;
do_get_profile
(
)
;
SearchTestUtils
.
init
(
this
)
;
const
SUGGESTIONS_ENGINE_NAME
=
"
Suggestions
"
;
const
TAIL_SUGGESTIONS_ENGINE_NAME
=
"
Tail
Suggestions
"
;
const
SEARCH_GLASS_ICON
=
"
chrome
:
/
/
global
/
skin
/
icons
/
search
-
glass
.
svg
"
;
var
gDBConn
;
function
DBConn
(
aForceNewConnection
)
{
if
(
!
aForceNewConnection
)
{
let
db
=
PlacesUtils
.
history
.
DBConnection
;
if
(
db
.
connectionReady
)
{
return
db
;
}
}
if
(
!
gDBConn
|
|
aForceNewConnection
)
{
let
file
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
file
.
append
(
"
places
.
sqlite
"
)
;
let
dbConn
=
(
gDBConn
=
Services
.
storage
.
openDatabase
(
file
)
)
;
TestUtils
.
topicObserved
(
"
profile
-
before
-
change
"
)
.
then
(
(
)
=
>
dbConn
.
asyncClose
(
)
)
;
}
return
gDBConn
.
connectionReady
?
gDBConn
:
null
;
}
function
createContext
(
searchString
=
"
foo
"
properties
=
{
}
)
{
info
(
Creating
new
queryContext
with
searchString
:
{
searchString
}
)
;
let
context
=
new
UrlbarQueryContext
(
Object
.
assign
(
{
allowAutofill
:
UrlbarPrefs
.
get
(
"
autoFill
"
)
isPrivate
:
true
maxResults
:
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
sapName
:
"
urlbar
"
searchString
}
properties
)
)
;
let
tokens
=
UrlbarTokenizer
.
tokenize
(
context
)
;
context
.
tokens
=
tokens
;
return
context
;
}
function
promiseControllerNotification
(
controller
notification
expected
=
true
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
proxifiedObserver
=
new
Proxy
(
{
}
{
get
:
(
target
name
)
=
>
{
if
(
name
=
=
notification
)
{
return
(
.
.
.
args
)
=
>
{
controller
.
removeListener
(
proxifiedObserver
)
;
if
(
expected
)
{
resolve
(
args
)
;
}
else
{
reject
(
)
;
}
}
;
}
return
(
)
=
>
false
;
}
}
)
;
controller
.
addListener
(
proxifiedObserver
)
;
}
)
;
}
function
convertToUtf8
(
str
)
{
return
String
.
fromCharCode
(
.
.
.
new
TextEncoder
(
)
.
encode
(
str
)
)
;
}
function
registerBasicTestProvider
(
results
=
[
]
onCancel
type
name
)
{
let
provider
=
new
UrlbarTestUtils
.
TestProvider
(
{
results
onCancel
type
name
}
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
registerCleanupFunction
(
(
)
=
>
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
)
;
return
provider
;
}
function
makeTestServer
(
port
=
-
1
)
{
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
start
(
port
)
;
registerCleanupFunction
(
(
)
=
>
httpServer
.
stop
(
(
)
=
>
{
}
)
)
;
return
httpServer
;
}
async
function
addTestSuggestionsEngine
(
suggestionsFn
=
null
{
name
=
SUGGESTIONS_ENGINE_NAME
}
=
{
}
)
{
let
server
=
makeTestServer
(
)
;
server
.
registerPathHandler
(
"
/
suggest
"
(
req
resp
)
=
>
{
let
params
=
new
URLSearchParams
(
req
.
queryString
)
;
let
searchStr
=
params
.
get
(
"
q
"
)
;
let
suggestions
=
suggestionsFn
?
suggestionsFn
(
searchStr
)
:
[
searchStr
]
.
concat
(
[
"
foo
"
"
bar
"
]
.
map
(
s
=
>
searchStr
+
"
"
+
s
)
)
;
let
data
=
[
searchStr
suggestions
]
;
resp
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
false
)
;
resp
.
write
(
JSON
.
stringify
(
data
)
)
;
}
)
;
await
SearchTestUtils
.
installSearchExtension
(
{
name
search_url
:
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
search
suggest_url
:
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
suggest
suggest_url_get_params
:
"
?
q
=
{
searchTerms
}
"
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
name
)
;
return
engine
;
}
async
function
addTestTailSuggestionsEngine
(
suggestionsFn
=
null
)
{
let
server
=
makeTestServer
(
)
;
server
.
registerPathHandler
(
"
/
suggest
"
(
req
resp
)
=
>
{
let
params
=
new
URLSearchParams
(
req
.
queryString
)
;
let
searchStr
=
params
.
get
(
"
q
"
)
;
let
suggestions
=
suggestionsFn
?
suggestionsFn
(
searchStr
)
:
[
"
what
time
is
it
in
t
"
[
"
what
is
the
time
today
texas
"
]
.
concat
(
[
"
toronto
"
"
tunisia
"
]
.
map
(
s
=
>
searchStr
+
s
.
slice
(
1
)
)
)
[
]
{
"
google
:
irrelevantparameter
"
:
[
]
"
google
:
suggestdetail
"
:
[
{
}
]
.
concat
(
[
"
toronto
"
"
tunisia
"
]
.
map
(
s
=
>
(
{
mp
:
"
"
t
:
s
}
)
)
)
}
]
;
let
data
=
suggestions
;
let
jsonString
=
JSON
.
stringify
(
data
)
;
let
stringOfUtf8Bytes
=
convertToUtf8
(
jsonString
)
;
resp
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
false
)
;
resp
.
write
(
stringOfUtf8Bytes
)
;
}
)
;
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
TAIL_SUGGESTIONS_ENGINE_NAME
search_url
:
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
search
suggest_url
:
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
suggest
suggest_url_get_params
:
"
?
q
=
{
searchTerms
}
"
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
Tail
Suggestions
"
)
;
return
engine
;
}
function
defaultRichSuggestionsFn
(
searchStr
)
{
let
suffixes
=
[
"
toronto
"
"
tunisia
"
"
tacoma
"
"
taipei
"
]
;
return
[
"
what
time
is
it
in
t
"
suffixes
.
map
(
s
=
>
searchStr
+
s
.
slice
(
1
)
)
[
]
{
"
google
:
irrelevantparameter
"
:
[
]
"
google
:
suggestdetail
"
:
suffixes
.
map
(
(
suffix
i
)
=
>
{
if
(
i
%
2
)
{
return
{
}
;
}
return
{
a
:
"
description
"
dc
:
"
#
FFFFFF
"
i
:
"
data
:
image
/
gif
;
base64
R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw
=
=
"
t
:
"
Title
"
}
;
}
)
}
]
;
}
async
function
addOpenPages
(
uri
count
=
1
userContextId
=
0
tabGroupId
=
null
)
{
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
await
UrlbarProviderOpenTabs
.
registerOpenTab
(
uri
.
spec
userContextId
tabGroupId
false
)
;
}
}
async
function
removeOpenPages
(
aUri
aCount
=
1
aUserContextId
=
0
tabGroupId
=
null
)
{
for
(
let
i
=
0
;
i
<
aCount
;
i
+
+
)
{
await
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
aUri
.
spec
aUserContextId
tabGroupId
false
)
;
}
}
function
testEngine_setup
(
)
{
add_setup
(
async
(
)
=
>
{
await
cleanupPlaces
(
)
;
let
engine
=
await
addTestSuggestionsEngine
(
)
;
let
oldDefaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
searches
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
contextualSearch
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
separatePrivateDefault
.
ui
.
enabled
"
)
;
Services
.
search
.
setDefault
(
oldDefaultEngine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
}
)
;
Services
.
search
.
setDefault
(
engine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
separatePrivateDefault
.
ui
.
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
searches
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
scotchBonnet
.
enableOverride
"
false
)
;
}
)
;
}
async
function
cleanupPlaces
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
autoFill
"
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
function
makeBookmarkResult
(
queryContext
{
title
uri
iconUri
tags
=
[
]
heuristic
=
false
source
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
}
)
{
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
heuristic
payload
:
{
url
:
uri
title
tags
icon
:
typeof
iconUri
!
=
"
undefined
"
?
iconUri
:
page
-
icon
:
{
uri
}
isBlockable
:
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
?
true
:
undefined
blockL10n
:
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
?
{
id
:
"
urlbar
-
result
-
menu
-
remove
-
from
-
history
"
}
:
undefined
helpUrl
:
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
?
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
awesome
-
bar
-
result
-
menu
"
:
undefined
}
highlights
:
{
url
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
title
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
tags
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
}
}
)
;
}
function
makeFormHistoryResult
(
queryContext
{
suggestion
engineName
}
)
{
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
engine
:
engineName
suggestion
title
:
suggestion
lowerCaseSuggestion
:
suggestion
.
toLocaleLowerCase
(
)
isBlockable
:
true
blockL10n
:
{
id
:
"
urlbar
-
result
-
menu
-
remove
-
from
-
history
"
}
helpUrl
:
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
awesome
-
bar
-
result
-
menu
"
}
highlights
:
{
suggestion
:
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
title
:
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
}
}
)
;
}
function
makeOmniboxResult
(
queryContext
{
content
description
keyword
heuristic
=
false
}
)
{
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
source
:
UrlbarUtils
.
RESULT_SOURCE
.
ADDON
heuristic
payload
:
{
title
:
description
content
keyword
icon
:
UrlbarUtils
.
ICON
.
EXTENSION
}
highlights
:
{
title
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
content
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
keyword
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
}
}
)
;
}
function
makeTabSwitchResult
(
queryContext
{
uri
title
iconUri
userContextId
tabGroup
}
)
{
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
source
:
UrlbarUtils
.
RESULT_SOURCE
.
TABS
payload
:
{
url
:
uri
title
icon
:
typeof
iconUri
!
=
"
undefined
"
?
iconUri
:
page
-
icon
:
{
uri
}
userContextId
:
userContextId
|
|
0
tabGroup
}
highlights
:
{
url
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
title
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
}
}
)
;
}
function
makeKeywordSearchResult
(
queryContext
{
uri
keyword
title
iconUri
postData
heuristic
=
false
}
)
{
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
heuristic
payload
:
{
title
:
title
|
|
uri
url
:
uri
keyword
input
:
queryContext
.
searchString
postData
:
postData
|
|
null
icon
:
typeof
iconUri
!
=
"
undefined
"
?
iconUri
:
page
-
icon
:
{
uri
}
}
highlights
:
{
title
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
url
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
keyword
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
input
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
}
}
)
;
}
function
makeRemoteTabResult
(
queryContext
{
uri
device
title
iconUri
lastUsed
=
0
}
)
{
let
payload
=
{
url
:
uri
device
icon
:
typeof
iconUri
!
=
"
undefined
"
?
iconUri
:
page
-
icon
:
{
uri
}
lastUsed
:
lastUsed
*
1000
}
;
if
(
typeof
title
!
=
"
undefined
"
)
{
payload
.
title
=
title
;
}
else
{
payload
.
title
=
uri
;
}
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
source
:
UrlbarUtils
.
RESULT_SOURCE
.
TABS
payload
highlights
:
{
url
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
title
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
device
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
}
}
)
;
}
function
makeSearchResult
(
queryContext
{
suggestion
tailPrefix
tail
tailOffsetIndex
engineName
alias
uri
query
engineIconUri
providesSearchMode
providerName
inPrivateWindow
isPrivateEngine
searchUrlDomainWithoutSuffix
heuristic
=
false
trending
=
false
isRichSuggestion
=
false
type
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
source
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
satisfiesAutofillThreshold
=
false
}
)
{
if
(
tail
)
{
if
(
!
tailPrefix
&
&
!
isRichSuggestion
)
{
tailPrefix
=
"
"
;
}
if
(
!
tailOffsetIndex
)
{
tailOffsetIndex
=
suggestion
.
indexOf
(
tail
)
;
}
}
let
payload
=
{
engine
:
engineName
suggestion
tailPrefix
tail
tailOffsetIndex
keyword
:
alias
query
:
typeof
query
!
=
"
undefined
"
?
query
:
queryContext
.
trimmedSearchString
icon
:
engineIconUri
providesSearchMode
inPrivateWindow
isPrivateEngine
}
;
if
(
providesSearchMode
)
{
}
else
if
(
payload
.
tail
&
&
payload
.
tailOffsetIndex
>
=
0
)
{
payload
.
title
=
payload
.
tail
;
}
else
if
(
payload
.
suggestion
!
=
undefined
)
{
payload
.
title
=
payload
.
suggestion
;
}
else
if
(
payload
.
query
!
=
undefined
)
{
payload
.
title
=
payload
.
query
;
}
if
(
uri
)
{
payload
.
url
=
uri
;
}
if
(
providerName
=
=
"
UrlbarProviderTabToSearch
"
)
{
if
(
searchUrlDomainWithoutSuffix
.
startsWith
(
"
www
.
"
)
)
{
searchUrlDomainWithoutSuffix
=
searchUrlDomainWithoutSuffix
.
substring
(
4
)
;
}
payload
.
searchUrlDomainWithoutSuffix
=
searchUrlDomainWithoutSuffix
;
payload
.
satisfiesAutofillThreshold
=
satisfiesAutofillThreshold
;
payload
.
isGeneralPurposeEngine
=
false
;
}
if
(
providerName
=
=
"
UrlbarProviderTokenAliasEngines
"
)
{
payload
.
keywords
=
alias
?
.
toLowerCase
(
)
;
}
if
(
typeof
suggestion
=
=
"
string
"
)
{
payload
.
lowerCaseSuggestion
=
suggestion
.
toLocaleLowerCase
(
)
;
payload
.
trending
=
trending
;
}
if
(
isRichSuggestion
)
{
payload
.
icon
=
"
data
:
image
/
gif
;
base64
R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw
=
=
"
;
payload
.
description
=
"
description
"
;
}
return
new
UrlbarResult
(
{
type
source
heuristic
isRichSuggestion
providerName
payload
highlights
:
{
engine
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
suggestion
:
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
tail
:
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
keyword
:
providesSearchMode
?
UrlbarUtils
.
HIGHLIGHT
.
TYPED
:
undefined
query
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
}
}
)
;
}
function
makeVisitResult
(
queryContext
{
title
uri
iconUri
providerName
tags
=
[
]
heuristic
=
false
source
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
}
)
{
let
payload
=
{
url
:
uri
}
;
if
(
title
!
=
undefined
)
{
payload
.
title
=
title
;
}
if
(
!
heuristic
&
&
providerName
!
=
"
UrlbarProviderAboutPages
"
&
&
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
{
payload
.
isBlockable
=
true
;
payload
.
blockL10n
=
{
id
:
"
urlbar
-
result
-
menu
-
remove
-
from
-
history
"
}
;
payload
.
helpUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
awesome
-
bar
-
result
-
menu
"
;
}
if
(
iconUri
)
{
payload
.
icon
=
iconUri
;
}
else
if
(
iconUri
=
=
=
undefined
&
&
source
!
=
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
)
{
payload
.
icon
=
page
-
icon
:
{
uri
}
;
}
if
(
!
heuristic
&
&
tags
)
{
payload
.
tags
=
tags
;
}
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
heuristic
providerName
payload
highlights
:
{
url
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
title
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
fallbackTitle
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
tags
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
}
}
)
;
}
function
makeCalculatorResult
(
queryContext
{
value
}
)
{
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
payload
:
{
value
input
:
queryContext
.
searchString
dynamicType
:
"
calculator
"
}
}
)
;
}
function
makeGlobalActionsResult
(
{
actionsResults
query
inputLength
showOnboardingLabel
=
false
providesSearchMode
=
false
engine
}
)
{
const
payload
=
{
actionsResults
dynamicType
:
"
actions
"
query
input
:
query
inputLength
showOnboardingLabel
providesSearchMode
engine
}
;
return
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
ACTIONS
providerName
:
"
UrlbarProviderGlobalActions
"
payload
}
)
;
}
async
function
check_results
(
{
context
incompleteSearch
autofilled
completed
matches
=
[
]
conditionalPayloadProperties
=
{
}
}
=
{
}
)
{
if
(
!
context
)
{
return
;
}
await
PlacesFrecencyRecalculator
.
recalculateAnyOutdatedFrecencies
(
)
;
const
controller
=
UrlbarTestUtils
.
newMockController
(
{
input
:
{
isPrivate
:
context
.
isPrivate
onFirstResult
(
)
{
return
false
;
}
getSearchSource
(
)
{
return
"
dummy
-
search
-
source
"
;
}
window
:
{
location
:
{
href
:
AppConstants
.
BROWSER_CHROME_URL
}
}
}
}
)
;
controller
.
setView
(
{
get
visibleResults
(
)
{
return
context
.
results
;
}
controller
:
{
removeResult
(
)
{
}
}
}
)
;
if
(
incompleteSearch
)
{
let
incompleteContext
=
createContext
(
incompleteSearch
{
isPrivate
:
context
.
isPrivate
}
)
;
controller
.
startQuery
(
incompleteContext
)
;
}
await
controller
.
startQuery
(
context
)
;
if
(
autofilled
)
{
Assert
.
ok
(
context
.
results
[
0
]
"
There
is
a
first
result
.
"
)
;
Assert
.
ok
(
context
.
results
[
0
]
.
autofill
"
The
first
result
is
an
autofill
result
"
)
;
Assert
.
equal
(
context
.
results
[
0
]
.
autofill
.
value
autofilled
"
The
correct
value
was
autofilled
.
"
)
;
if
(
completed
)
{
Assert
.
equal
(
context
.
results
[
0
]
.
payload
.
url
completed
"
The
completed
autofill
value
is
correct
.
"
)
;
}
}
if
(
context
.
results
.
length
!
=
matches
.
length
)
{
info
(
"
Actual
results
:
"
+
JSON
.
stringify
(
context
.
results
)
)
;
}
Assert
.
equal
(
context
.
results
.
length
matches
.
length
"
Found
the
expected
number
of
results
.
"
)
;
let
propertiesToCheck
=
{
type
:
{
}
source
:
{
}
heuristic
:
{
}
isBestMatch
:
{
map
:
v
=
>
!
!
v
}
providerName
:
{
optional
:
true
}
suggestedIndex
:
{
optional
:
true
}
isSuggestedIndexRelativeToGroup
:
{
optional
:
true
map
:
v
=
>
!
!
v
}
exposureTelemetry
:
{
optional
:
true
}
isRichSuggestion
:
{
optional
:
true
}
richSuggestionIconVariation
:
{
optional
:
true
}
}
;
conditionalPayloadProperties
=
{
frecency
:
{
optional
:
true
}
lastVisit
:
{
optional
:
true
}
suggestionObject
:
{
ignore
:
true
}
.
.
.
conditionalPayloadProperties
}
;
for
(
let
i
=
0
;
i
<
matches
.
length
;
i
+
+
)
{
let
actual
=
context
.
results
[
i
]
;
let
expected
=
matches
[
i
]
;
info
(
Comparing
results
at
index
{
i
}
:
+
"
actual
=
"
+
JSON
.
stringify
(
actual
)
+
"
expected
=
"
+
JSON
.
stringify
(
expected
)
)
;
for
(
let
[
key
{
optional
map
}
]
of
Object
.
entries
(
propertiesToCheck
)
)
{
if
(
!
optional
|
|
expected
[
key
]
!
=
=
undefined
)
{
map
?
?
=
v
=
>
v
;
Assert
.
equal
(
map
(
actual
[
key
]
)
map
(
expected
[
key
]
)
result
.
{
key
}
at
result
index
{
i
}
)
;
}
}
if
(
actual
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
actual
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
&
&
actual
.
providerName
=
=
"
UrlbarProviderHeuristicFallback
"
)
{
expected
.
payload
.
icon
=
SEARCH_GLASS_ICON
;
}
if
(
actual
.
payload
?
.
url
)
{
try
{
const
payloadUrlProtocol
=
new
URL
(
actual
.
payload
.
url
)
.
protocol
;
if
(
!
UrlbarUtils
.
PROTOCOLS_WITH_ICONS
.
includes
(
payloadUrlProtocol
)
&
&
actual
.
source
!
=
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
)
{
expected
.
payload
.
icon
=
UrlbarUtils
.
ICON
.
DEFAULT
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
if
(
expected
.
payload
)
{
let
expectedKeys
=
new
Set
(
Object
.
keys
(
expected
.
payload
)
)
;
let
actualKeys
=
new
Set
(
Object
.
keys
(
actual
.
payload
)
)
;
for
(
let
key
of
actualKeys
.
union
(
expectedKeys
)
)
{
let
condition
=
conditionalPayloadProperties
[
key
]
;
if
(
condition
?
.
ignore
|
|
(
condition
?
.
optional
&
&
!
expected
.
hasOwnProperty
(
key
)
)
)
{
continue
;
}
Assert
.
deepEqual
(
actual
.
payload
[
key
]
expected
.
payload
[
key
]
result
.
payload
.
{
key
}
at
result
index
{
i
}
)
;
}
}
}
}
async
function
getOriginFrecency
(
prefix
aHost
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
execute
(
SELECT
frecency
FROM
moz_origins
WHERE
prefix
=
:
prefix
AND
host
=
:
host
{
prefix
host
:
aHost
}
)
;
Assert
.
equal
(
rows
.
length
1
)
;
return
rows
[
0
]
.
getResultByIndex
(
0
)
;
}
async
function
getOriginAutofillThreshold
(
)
{
return
PlacesUtils
.
metadata
.
get
(
"
origin_frecency_threshold
"
2
.
0
)
;
}
async
function
checkOriginsOrder
(
host
prefixOrder
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
checkOriginsOrder
"
async
db
=
>
{
let
prefixes
=
(
await
db
.
execute
(
SELECT
prefix
|
|
iif
(
instr
(
host
"
www
.
"
)
=
1
"
www
.
"
"
"
)
FROM
moz_origins
WHERE
host
=
:
host
OR
host
=
"
www
.
"
|
|
:
host
ORDER
BY
ROWID
ASC
{
host
}
)
)
.
map
(
r
=
>
r
.
getResultByIndex
(
0
)
)
;
Assert
.
deepEqual
(
prefixes
prefixOrder
)
;
}
)
;
}
function
daysAgo
(
days
)
{
let
date
=
new
Date
(
)
;
date
.
setDate
(
date
.
getDate
(
)
-
days
)
;
return
date
;
}
