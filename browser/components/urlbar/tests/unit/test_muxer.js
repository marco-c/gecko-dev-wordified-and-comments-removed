"
use
strict
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
}
)
;
let
sandbox
;
add_setup
(
async
function
(
)
{
sandbox
=
lazy
.
sinon
.
createSandbox
(
)
;
registerCleanupFunction
(
(
)
=
>
{
sandbox
.
restore
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_muxer
(
)
{
Assert
.
throws
(
(
)
=
>
UrlbarProvidersManager
.
registerMuxer
(
)
/
invalid
muxer
/
"
Should
throw
with
no
arguments
"
)
;
Assert
.
throws
(
(
)
=
>
UrlbarProvidersManager
.
registerMuxer
(
{
}
)
/
invalid
muxer
/
"
Should
throw
with
empty
object
"
)
;
Assert
.
throws
(
(
)
=
>
UrlbarProvidersManager
.
registerMuxer
(
{
name
:
"
"
}
)
/
invalid
muxer
/
"
Should
throw
with
empty
name
"
)
;
Assert
.
throws
(
(
)
=
>
UrlbarProvidersManager
.
registerMuxer
(
{
name
:
"
test
"
sort
:
"
no
"
}
)
/
invalid
muxer
/
"
Should
throw
with
invalid
sort
"
)
;
let
matches
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
source
:
UrlbarUtils
.
RESULT_SOURCE
.
TABS
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
tab
/
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
bookmark
/
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
history
/
"
}
}
)
]
;
let
provider
=
registerBasicTestProvider
(
matches
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider
.
name
]
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
class
TestMuxer
extends
UrlbarMuxer
{
get
name
(
)
{
return
"
TestMuxer
"
;
}
sort
(
queryContext
unsortedResults
)
{
queryContext
.
results
=
[
.
.
.
unsortedResults
]
.
sort
(
(
a
b
)
=
>
{
if
(
b
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
TABS
)
{
return
-
1
;
}
if
(
b
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
{
return
1
;
}
return
a
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
?
-
1
:
1
;
}
)
;
}
}
let
muxer
=
new
TestMuxer
(
)
;
UrlbarProvidersManager
.
registerMuxer
(
muxer
)
;
context
.
muxer
=
"
TestMuxer
"
;
info
(
"
Check
results
the
order
should
be
:
bookmark
history
tab
"
)
;
await
UrlbarProvidersManager
.
startQuery
(
context
controller
)
;
Assert
.
deepEqual
(
context
.
results
[
matches
[
1
]
matches
[
2
]
matches
[
0
]
]
)
;
UrlbarProvidersManager
.
unregisterMuxer
(
muxer
)
;
UrlbarProvidersManager
.
unregisterMuxer
(
"
TestMuxer
"
)
;
}
)
;
add_task
(
async
function
test_preselectedHeuristic_singleProvider
(
)
{
let
matches
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
a
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
heuristic
:
true
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
b
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
c
"
}
}
)
]
;
let
provider
=
registerBasicTestProvider
(
matches
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider
.
name
]
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
info
(
"
Check
results
the
order
should
be
:
b
(
heuristic
)
a
c
"
)
;
await
UrlbarProvidersManager
.
startQuery
(
context
controller
)
;
Assert
.
deepEqual
(
context
.
results
[
matches
[
1
]
matches
[
0
]
matches
[
2
]
]
)
;
}
)
;
add_task
(
async
function
test_preselectedHeuristic_multiProviders
(
)
{
let
matches1
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
a
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
b
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
c
"
}
}
)
]
;
let
matches2
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
d
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
heuristic
:
true
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
e
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
f
"
}
}
)
]
;
let
provider1
=
registerBasicTestProvider
(
matches1
)
;
let
provider2
=
registerBasicTestProvider
(
matches2
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider1
.
name
provider2
.
name
]
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
info
(
"
Check
results
the
order
should
be
:
e
(
heuristic
)
a
b
c
d
f
"
)
;
await
UrlbarProvidersManager
.
startQuery
(
context
controller
)
;
Assert
.
deepEqual
(
context
.
results
[
matches2
[
1
]
.
.
.
matches1
matches2
[
0
]
matches2
[
2
]
]
)
;
}
)
;
add_task
(
async
function
test_suggestions
(
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
urlbar
.
maxHistoricalSearchSuggestions
"
1
)
;
let
matches
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
a
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
b
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
engine
:
"
mozSearch
"
query
:
"
moz
"
suggestion
:
"
mozzarella
"
lowerCaseSuggestion
:
"
mozzarella
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
payload
:
{
engine
:
"
mozSearch
"
query
:
"
moz
"
suggestion
:
"
mozilla
"
lowerCaseSuggestion
:
"
mozilla
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
payload
:
{
engine
:
"
mozSearch
"
query
:
"
moz
"
providesSearchMode
:
true
keyword
:
"
moz
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
c
"
}
}
)
]
;
let
provider
=
registerBasicTestProvider
(
matches
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider
.
name
]
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
info
(
"
Check
results
the
order
should
be
:
mozzarella
moz
a
b
moz
c
"
)
;
await
UrlbarProvidersManager
.
startQuery
(
context
controller
)
;
Assert
.
deepEqual
(
context
.
results
[
matches
[
2
]
matches
[
3
]
matches
[
0
]
matches
[
1
]
matches
[
4
]
matches
[
5
]
]
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
maxHistoricalSearchSuggestions
"
)
;
}
)
;
add_task
(
async
function
test_deduplicate_for_unitConversion
(
)
{
const
searchSuggestion
=
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
payload
:
{
engine
:
"
Google
"
query
:
"
10cm
to
m
"
suggestion
:
"
=
0
.
1
meters
"
}
}
)
;
const
searchProvider
=
registerBasicTestProvider
(
[
searchSuggestion
]
null
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
)
;
const
unitConversionSuggestion
=
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
suggestedIndex
:
1
payload
:
{
dynamicType
:
"
unitConversion
"
output
:
"
0
.
1
m
"
input
:
"
10cm
to
m
"
}
}
)
;
const
unitConversion
=
registerBasicTestProvider
(
[
unitConversionSuggestion
]
null
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
"
UrlbarProviderUnitConversion
"
)
;
const
context
=
createContext
(
undefined
{
providers
:
[
searchProvider
.
name
unitConversion
.
name
]
}
)
;
const
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
await
UrlbarProvidersManager
.
startQuery
(
context
controller
)
;
Assert
.
deepEqual
(
context
.
results
[
unitConversionSuggestion
]
)
;
}
)
;
const
BAD_HEURISTIC_RESULTS
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
heuristic
:
true
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
heuristic
-
0
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
heuristic
:
true
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
heuristic
-
1
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
non
-
heuristic
-
0
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
mozilla
.
org
/
non
-
heuristic
-
1
"
}
}
)
]
;
const
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
=
BAD_HEURISTIC_RESULTS
[
0
]
;
const
BAD_HEURISTIC_RESULTS_GENERAL
=
[
BAD_HEURISTIC_RESULTS
[
2
]
BAD_HEURISTIC_RESULTS
[
3
]
]
;
add_task
(
async
function
test_badHeuristicGroups_multiple_0
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
maxResultCount
:
2
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
]
[
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicGroups_multiple_1
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
]
[
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicGroups_multiple_2
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
maxResultCount
:
2
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
]
[
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicGroups_multiple_3
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
]
[
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicGroups_multiple_4
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
maxResultCount
:
1
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
maxResultCount
:
1
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
}
]
[
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicGroups_multiple_5
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
}
]
[
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicGroups_multiple_6
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
maxResultCount
:
1
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
maxResultCount
:
1
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
[
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicGroups_multiple_7
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
[
BAD_HEURISTIC_RESULTS_FIRST_HEURISTIC
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicsGroups_notFirst_0
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
maxResultCount
:
1
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
}
]
[
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicsGroups_notFirst_1
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
children
:
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
}
]
[
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicsGroups_notFirst_2
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
maxResultCount
:
1
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
[
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicsGroups_notFirst_3
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
]
[
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
add_task
(
async
function
test_badHeuristicsGroups_notFirst_4
(
)
{
await
doBadHeuristicGroupsTest
(
[
{
maxResultCount
:
1
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
}
{
group
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
}
]
[
.
.
.
BAD_HEURISTIC_RESULTS_GENERAL
]
)
;
}
)
;
async
function
doBadHeuristicGroupsTest
(
resultGroups
expectedResults
)
{
sandbox
.
stub
(
UrlbarPrefs
"
getResultGroups
"
)
.
returns
(
{
children
:
resultGroups
}
)
;
let
provider
=
registerBasicTestProvider
(
BAD_HEURISTIC_RESULTS
)
;
let
context
=
createContext
(
"
foo
"
{
providers
:
[
provider
.
name
]
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
await
UrlbarProvidersManager
.
startQuery
(
context
controller
)
;
Assert
.
deepEqual
(
context
.
results
expectedResults
)
;
sandbox
.
restore
(
)
;
}
add_task
(
async
function
roomForHeuristic_suggestedIndex
(
)
{
let
results
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
heuristic
:
true
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
heuristic
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
suggestedIndex
:
1
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
suggestedIndex
"
}
}
)
]
;
UrlbarPrefs
.
set
(
"
maxRichResults
"
1
)
;
let
provider
=
registerBasicTestProvider
(
results
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider
.
name
]
}
)
;
await
check_results
(
{
context
matches
:
results
}
)
;
UrlbarPrefs
.
clear
(
"
maxRichResults
"
)
;
}
)
;
add_task
(
async
function
roomForHeuristic_largeResultSpan
(
)
{
let
results
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
heuristic
:
true
resultSpan
:
2
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
heuristic
"
}
}
)
]
;
UrlbarPrefs
.
set
(
"
maxRichResults
"
1
)
;
let
provider
=
registerBasicTestProvider
(
results
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider
.
name
]
}
)
;
await
check_results
(
{
context
matches
:
results
}
)
;
UrlbarPrefs
.
clear
(
"
maxRichResults
"
)
;
}
)
;
add_task
(
async
function
roomForHeuristic_maxRichResultsZero
(
)
{
let
results
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
heuristic
:
true
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
heuristic
"
}
}
)
]
;
UrlbarPrefs
.
set
(
"
maxRichResults
"
0
)
;
let
provider
=
registerBasicTestProvider
(
results
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider
.
name
]
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
UrlbarPrefs
.
clear
(
"
maxRichResults
"
)
;
}
)
;
add_task
(
async
function
roomForHeuristic_maxRichResultsZero_suggestedIndex
(
)
{
let
results
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
heuristic
:
true
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
heuristic
"
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
suggestedIndex
:
1
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
suggestedIndex
"
}
}
)
]
;
UrlbarPrefs
.
set
(
"
maxRichResults
"
0
)
;
let
provider
=
registerBasicTestProvider
(
results
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider
.
name
]
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
UrlbarPrefs
.
clear
(
"
maxRichResults
"
)
;
}
)
;
add_task
(
async
function
test_orderBy
(
)
{
let
results1
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
test1
"
frecency
:
10
}
}
)
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
test2
"
frecency
:
1000
}
}
)
]
;
let
provider1
=
registerBasicTestProvider
(
results1
)
;
let
results2
=
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
test3
"
frecency
:
100
}
}
)
]
;
let
provider2
=
registerBasicTestProvider
(
results2
)
;
let
context
=
createContext
(
undefined
{
providers
:
[
provider1
.
name
provider2
.
name
]
}
)
;
await
check_results
(
{
context
matches
:
[
results1
[
1
]
results2
[
0
]
results1
[
0
]
]
}
)
;
}
)
;
