const
{
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UrlbarProviderAutofill
:
"
resource
:
/
/
/
modules
/
UrlbarProviderAutofill
.
jsm
"
}
)
;
class
SlowHeuristicProvider
extends
TestProvider
{
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
;
}
async
startQuery
(
context
add
)
{
this
.
_context
=
context
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
300
)
)
;
for
(
let
result
of
this
.
_results
)
{
add
(
this
result
)
;
}
}
}
class
FastHeuristicProvider
extends
TestProvider
{
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
;
}
async
startQuery
(
context
add
)
{
this
.
_context
=
context
;
for
(
let
result
of
this
.
_results
)
{
add
(
this
result
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
results
-
added
"
)
;
}
}
add_task
(
async
function
setup
(
)
{
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
searches
"
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
searches
"
false
)
;
}
)
;
add_task
(
async
function
timerIsCancelled
(
)
{
let
context
=
createContext
(
"
m
"
{
isPrivate
:
false
}
)
;
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
info
(
"
Manually
set
up
query
and
then
overwrite
it
.
"
)
;
let
slowProvider
=
new
SlowHeuristicProvider
(
{
results
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
mozilla
.
org
/
title
:
mozilla
.
org
/
}
)
]
}
)
;
UrlbarProvidersManager
.
registerProvider
(
slowProvider
)
;
let
fastProvider
=
new
FastHeuristicProvider
(
{
results
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
mozilla
.
com
/
title
:
mozilla
.
com
/
heuristic
:
true
}
)
]
}
)
;
UrlbarProvidersManager
.
registerProvider
(
fastProvider
)
;
let
firstContext
=
createContext
(
"
m
"
{
providers
:
[
slowProvider
.
name
fastProvider
.
name
]
}
)
;
let
secondContext
=
createContext
(
"
ma
"
{
providers
:
[
slowProvider
.
name
fastProvider
.
name
]
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
let
queryRecieved
queryCancelled
;
const
controllerListener
=
{
onQueryResults
(
queryContext
)
{
Assert
.
equal
(
queryContext
secondContext
"
Only
the
second
query
should
finish
.
"
)
;
queryRecieved
=
true
;
}
onQueryCancelled
(
queryContext
)
{
Assert
.
equal
(
queryContext
firstContext
"
The
first
query
should
be
cancelled
.
"
)
;
Assert
.
ok
(
!
queryCancelled
"
No
more
than
one
query
should
be
cancelled
.
"
)
;
queryCancelled
=
true
;
}
}
;
controller
.
addQueryListener
(
controllerListener
)
;
let
resultsAddedPromise
=
new
Promise
(
resolve
=
>
{
let
observe
=
async
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observe
"
results
-
added
"
)
;
await
controller
.
startQuery
(
secondContext
)
;
resolve
(
)
;
}
;
Services
.
obs
.
addObserver
(
observe
"
results
-
added
"
)
;
}
)
;
controller
.
startQuery
(
firstContext
)
;
await
resultsAddedPromise
;
Assert
.
ok
(
queryCancelled
"
At
least
one
query
was
cancelled
.
"
)
;
Assert
.
ok
(
queryRecieved
"
At
least
one
query
finished
.
"
)
;
controller
.
removeQueryListener
(
controllerListener
)
;
}
)
;
add_task
(
async
function
autofillIsCleared
(
)
{
await
PlacesTestUtils
.
addVisits
(
"
http
:
/
/
example
.
com
"
)
;
let
firstContext
=
createContext
(
"
e
"
{
providers
:
[
"
Autofill
"
"
HeuristicFallback
"
]
}
)
;
let
secondContext
=
createContext
(
"
em
"
{
providers
:
[
"
Autofill
"
"
HeuristicFallback
"
]
}
)
;
info
(
"
Sanity
check
:
The
first
query
autofills
and
the
second
does
not
.
"
)
;
await
check_results
(
{
firstContext
autofilled
:
"
example
.
com
"
completed
:
"
http
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
firstContext
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
example
.
com
"
heuristic
:
true
}
)
]
}
)
;
await
check_results
(
{
secondContext
matches
:
[
makeSearchResult
(
secondContext
{
engineName
:
(
await
Services
.
search
.
getDefault
(
)
)
.
name
providerName
:
"
HeuristicFallback
"
heuristic
:
true
}
)
]
}
)
;
firstContext
=
createContext
(
"
e
"
{
providers
:
[
"
Autofill
"
"
HeuristicFallback
"
]
}
)
;
secondContext
=
createContext
(
"
em
"
{
providers
:
[
"
Autofill
"
"
HeuristicFallback
"
]
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
let
queryRecieved
queryCancelled
;
const
controllerListener
=
{
onQueryResults
(
queryContext
)
{
Assert
.
equal
(
queryContext
secondContext
"
Only
the
second
query
should
finish
.
"
)
;
queryRecieved
=
true
;
}
onQueryCancelled
(
queryContext
)
{
Assert
.
equal
(
queryContext
firstContext
"
The
first
query
should
be
cancelled
.
"
)
;
Assert
.
ok
(
!
UrlbarProviderAutofill
.
_autofillData
"
The
first
result
should
not
have
populated
autofill
data
.
"
)
;
Assert
.
ok
(
!
queryCancelled
"
No
more
than
one
query
should
be
cancelled
.
"
)
;
queryCancelled
=
true
;
}
}
;
controller
.
addQueryListener
(
controllerListener
)
;
controller
.
startQuery
(
firstContext
)
;
await
controller
.
startQuery
(
secondContext
)
;
Assert
.
ok
(
queryCancelled
"
At
least
one
query
was
cancelled
.
"
)
;
Assert
.
ok
(
queryRecieved
"
At
least
one
query
finished
.
"
)
;
controller
.
removeQueryListener
(
controllerListener
)
;
await
cleanupPlaces
(
)
;
}
)
;
