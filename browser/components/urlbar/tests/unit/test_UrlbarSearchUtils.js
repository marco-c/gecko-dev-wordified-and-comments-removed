const
{
UrlbarSearchUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
sys
.
mjs
"
)
;
let
baconEngineExtension
;
add_task
(
async
function
(
)
{
await
UrlbarSearchUtils
.
init
(
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
region
"
"
US
"
)
;
Services
.
search
.
restoreDefaultEngines
(
)
;
Services
.
search
.
resetToAppDefaultEngine
(
)
;
}
)
;
add_task
(
async
function
search_engine_match
(
)
{
let
engine
=
await
Services
.
search
.
getDefault
(
)
;
let
domain
=
engine
.
searchUrlDomain
;
let
token
=
domain
.
substr
(
0
1
)
;
let
matchedEngine
=
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
token
)
)
[
0
]
;
Assert
.
equal
(
matchedEngine
engine
)
;
}
)
;
add_task
(
async
function
no_match
(
)
{
Assert
.
equal
(
0
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
"
test
"
)
)
.
length
)
;
}
)
;
add_task
(
async
function
hide_search_engine_nomatch
(
)
{
let
engine
=
await
Services
.
search
.
getDefault
(
)
;
let
domain
=
engine
.
searchUrlDomain
;
let
token
=
domain
.
substr
(
0
1
)
;
let
promiseTopic
=
promiseSearchTopic
(
"
engine
-
changed
"
)
;
await
Promise
.
all
(
[
Services
.
search
.
removeEngine
(
engine
)
promiseTopic
]
)
;
Assert
.
ok
(
engine
.
hidden
)
;
let
matchedEngines
=
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
token
)
;
Assert
.
ok
(
!
matchedEngines
.
length
|
|
matchedEngines
[
0
]
.
searchUrlDomain
!
=
domain
)
;
engine
.
hidden
=
false
;
await
TestUtils
.
waitForCondition
(
async
(
)
=
>
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
token
)
)
.
length
)
;
let
matchedEngine2
=
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
token
)
)
[
0
]
;
Assert
.
ok
(
matchedEngine2
)
;
await
Services
.
search
.
setDefault
(
engine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
}
)
;
add_task
(
async
function
onlyEnabled_option_nomatch
(
)
{
let
engine
=
await
Services
.
search
.
getDefault
(
)
;
let
domain
=
engine
.
searchUrlDomain
;
let
token
=
domain
.
substr
(
0
1
)
;
engine
.
hideOneOffButton
=
true
;
let
matchedEngines
=
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
token
)
;
Assert
.
equal
(
matchedEngines
.
length
0
)
;
engine
.
hideOneOffButton
=
false
;
matchedEngines
=
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
token
)
;
Assert
.
equal
(
matchedEngines
[
0
]
.
searchUrlDomain
domain
)
;
}
)
;
add_task
(
async
function
add_search_engine_match
(
)
{
Assert
.
equal
(
0
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
"
bacon
"
)
)
.
length
)
;
baconEngineExtension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
bacon
"
keyword
:
"
pork
"
search_url
:
"
https
:
/
/
www
.
bacon
.
moz
/
"
}
{
skipUnload
:
true
}
)
;
let
matchedEngine
=
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
"
bacon
"
)
)
[
0
]
;
Assert
.
ok
(
matchedEngine
)
;
Assert
.
equal
(
matchedEngine
.
searchForm
"
https
:
/
/
www
.
bacon
.
moz
"
)
;
Assert
.
equal
(
matchedEngine
.
name
"
bacon
"
)
;
Assert
.
equal
(
await
matchedEngine
.
getIconURL
(
)
null
)
;
info
(
"
also
type
part
of
the
public
suffix
"
)
;
matchedEngine
=
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
"
bacon
.
m
"
)
)
[
0
]
;
Assert
.
ok
(
matchedEngine
)
;
Assert
.
equal
(
matchedEngine
.
searchForm
"
https
:
/
/
www
.
bacon
.
moz
"
)
;
Assert
.
equal
(
matchedEngine
.
name
"
bacon
"
)
;
Assert
.
equal
(
await
matchedEngine
.
getIconURL
(
)
null
)
;
}
)
;
add_task
(
async
function
match_multiple_search_engines
(
)
{
Assert
.
equal
(
0
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
"
baseball
"
)
)
.
length
)
;
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
baseball
"
search_url
:
"
https
:
/
/
www
.
baseball
.
moz
/
"
}
)
;
let
matchedEngines
=
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
"
ba
"
)
;
Assert
.
equal
(
matchedEngines
.
length
2
"
enginesForDomainPrefix
returned
two
engines
.
"
)
;
Assert
.
equal
(
matchedEngines
[
0
]
.
searchForm
"
https
:
/
/
www
.
bacon
.
moz
"
)
;
Assert
.
equal
(
matchedEngines
[
0
]
.
name
"
bacon
"
)
;
Assert
.
equal
(
matchedEngines
[
1
]
.
searchForm
"
https
:
/
/
www
.
baseball
.
moz
"
)
;
Assert
.
equal
(
matchedEngines
[
1
]
.
name
"
baseball
"
)
;
}
)
;
add_task
(
async
function
test_aliased_search_engine_match
(
)
{
Assert
.
equal
(
null
await
UrlbarSearchUtils
.
engineForAlias
(
"
sober
"
)
)
;
let
matchedEngine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
pork
"
)
;
Assert
.
ok
(
matchedEngine
)
;
Assert
.
equal
(
matchedEngine
.
name
"
bacon
"
)
;
Assert
.
ok
(
matchedEngine
.
aliases
.
includes
(
"
pork
"
)
)
;
Assert
.
equal
(
await
matchedEngine
.
getIconURL
(
)
null
)
;
matchedEngine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
PORK
"
)
;
Assert
.
ok
(
matchedEngine
)
;
Assert
.
equal
(
matchedEngine
.
name
"
bacon
"
)
;
Assert
.
ok
(
matchedEngine
.
aliases
.
includes
(
"
pork
"
)
)
;
Assert
.
equal
(
await
matchedEngine
.
getIconURL
(
)
null
)
;
matchedEngine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
Pork
"
)
;
Assert
.
ok
(
matchedEngine
)
;
Assert
.
equal
(
matchedEngine
.
name
"
bacon
"
)
;
Assert
.
ok
(
matchedEngine
.
aliases
.
includes
(
"
pork
"
)
)
;
Assert
.
equal
(
await
matchedEngine
.
getIconURL
(
)
null
)
;
}
)
;
add_task
(
async
function
test_aliased_search_engine_match_upper_case_alias
(
)
{
Assert
.
equal
(
0
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
"
patch
"
)
)
.
length
)
;
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
patch
"
keyword
:
"
PR
"
search_url
:
"
https
:
/
/
www
.
patch
.
moz
/
"
}
)
;
let
matchedEngine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
pr
"
)
;
Assert
.
ok
(
matchedEngine
)
;
Assert
.
equal
(
matchedEngine
.
name
"
patch
"
)
;
Assert
.
ok
(
matchedEngine
.
aliases
.
includes
(
"
PR
"
)
)
;
Assert
.
equal
(
await
matchedEngine
.
getIconURL
(
)
null
)
;
matchedEngine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
PR
"
)
;
Assert
.
ok
(
matchedEngine
)
;
Assert
.
equal
(
matchedEngine
.
name
"
patch
"
)
;
Assert
.
ok
(
matchedEngine
.
aliases
.
includes
(
"
PR
"
)
)
;
Assert
.
equal
(
await
matchedEngine
.
getIconURL
(
)
null
)
;
matchedEngine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
Pr
"
)
;
Assert
.
ok
(
matchedEngine
)
;
Assert
.
equal
(
matchedEngine
.
name
"
patch
"
)
;
Assert
.
ok
(
matchedEngine
.
aliases
.
includes
(
"
PR
"
)
)
;
Assert
.
equal
(
await
matchedEngine
.
getIconURL
(
)
null
)
;
}
)
;
add_task
(
async
function
remove_search_engine_nomatch
(
)
{
let
promiseTopic
=
promiseSearchTopic
(
"
engine
-
removed
"
)
;
await
Promise
.
all
(
[
baconEngineExtension
.
unload
(
)
promiseTopic
]
)
;
Assert
.
equal
(
0
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
"
bacon
"
)
)
.
length
)
;
}
)
;
add_task
(
async
function
test_builtin_aliased_search_engine_match
(
)
{
let
engine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
google
"
)
;
Assert
.
ok
(
engine
)
;
Assert
.
equal
(
engine
.
name
"
Google
"
)
;
let
promiseTopic
=
promiseSearchTopic
(
"
engine
-
changed
"
)
;
await
Promise
.
all
(
[
Services
.
search
.
removeEngine
(
engine
)
promiseTopic
]
)
;
let
matchedEngine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
google
"
)
;
Assert
.
ok
(
!
matchedEngine
)
;
engine
.
hidden
=
false
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
UrlbarSearchUtils
.
engineForAlias
(
"
google
"
)
)
;
engine
=
await
UrlbarSearchUtils
.
engineForAlias
(
"
google
"
)
;
Assert
.
ok
(
engine
)
;
}
)
;
add_task
(
async
function
test_serps_are_equivalent
(
)
{
info
(
"
Subset
URL
has
extraneous
parameters
.
"
)
;
let
url1
=
"
https
:
/
/
example
.
com
/
search
?
q
=
test
&
type
=
images
"
;
let
url2
=
"
https
:
/
/
example
.
com
/
search
?
q
=
test
"
;
Assert
.
ok
(
!
UrlbarSearchUtils
.
serpsAreEquivalent
(
url1
url2
)
)
;
info
(
"
Superset
URL
has
extraneous
parameters
.
"
)
;
Assert
.
ok
(
UrlbarSearchUtils
.
serpsAreEquivalent
(
url2
url1
)
)
;
info
(
"
Same
keys
different
values
.
"
)
;
url1
=
"
https
:
/
/
example
.
com
/
search
?
q
=
test
&
type
=
images
"
;
url2
=
"
https
:
/
/
example
.
com
/
search
?
q
=
test123
&
type
=
maps
"
;
Assert
.
ok
(
!
UrlbarSearchUtils
.
serpsAreEquivalent
(
url1
url2
)
)
;
Assert
.
ok
(
!
UrlbarSearchUtils
.
serpsAreEquivalent
(
url2
url1
)
)
;
info
(
"
Subset
matching
isn
'
t
strict
(
URL
is
subset
of
itself
)
.
"
)
;
Assert
.
ok
(
UrlbarSearchUtils
.
serpsAreEquivalent
(
url1
url1
)
)
;
info
(
"
Origin
and
pathname
are
ignored
.
"
)
;
url1
=
"
https
:
/
/
example
.
com
/
search
?
q
=
test
"
;
url2
=
"
https
:
/
/
example
-
1
.
com
/
maps
?
q
=
test
"
;
Assert
.
ok
(
UrlbarSearchUtils
.
serpsAreEquivalent
(
url1
url2
)
)
;
Assert
.
ok
(
UrlbarSearchUtils
.
serpsAreEquivalent
(
url2
url1
)
)
;
info
(
"
Params
can
be
optionally
ignored
"
)
;
url1
=
"
https
:
/
/
example
.
com
/
search
?
q
=
test
&
abc
=
123
&
foo
=
bar
"
;
url2
=
"
https
:
/
/
example
.
com
/
search
?
q
=
test
"
;
Assert
.
ok
(
!
UrlbarSearchUtils
.
serpsAreEquivalent
(
url1
url2
)
)
;
Assert
.
ok
(
UrlbarSearchUtils
.
serpsAreEquivalent
(
url1
url2
[
"
abc
"
"
foo
"
]
)
)
;
}
)
;
add_task
(
async
function
test_get_root_domain_from_engine
(
)
{
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestEngine2
"
search_url
:
"
https
:
/
/
example
.
com
/
"
}
{
skipUnload
:
true
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
TestEngine2
"
)
;
Assert
.
equal
(
UrlbarSearchUtils
.
getRootDomainFromEngine
(
engine
)
"
example
"
)
;
await
extension
.
unload
(
)
;
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestEngine
"
search_url
:
"
https
:
/
/
www
.
subdomain
.
othersubdomain
.
example
.
com
"
}
{
skipUnload
:
true
}
)
;
engine
=
Services
.
search
.
getEngineByName
(
"
TestEngine
"
)
;
Assert
.
equal
(
UrlbarSearchUtils
.
getRootDomainFromEngine
(
engine
)
"
example
"
)
;
await
extension
.
unload
(
)
;
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestMalformed
"
search_url
:
"
https
:
/
/
mochi
.
test
/
"
search_url_get_params
:
"
search
=
{
searchTerms
}
"
}
{
skipUnload
:
true
}
)
;
engine
=
Services
.
search
.
getEngineByName
(
"
TestMalformed
"
)
;
Assert
.
equal
(
UrlbarSearchUtils
.
getRootDomainFromEngine
(
engine
)
"
mochi
"
)
;
await
extension
.
unload
(
)
;
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestMalformed
"
search_url
:
"
https
:
/
/
subdomain
.
foobar
/
"
search_url_get_params
:
"
search
=
{
searchTerms
}
"
}
{
skipUnload
:
true
}
)
;
engine
=
Services
.
search
.
getEngineByName
(
"
TestMalformed
"
)
;
Assert
.
equal
(
UrlbarSearchUtils
.
getRootDomainFromEngine
(
engine
)
"
subdomain
.
foobar
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
get_search_term_if_default_serp_uri
(
)
{
let
testCases
=
[
{
url
:
null
skipUriTest
:
true
}
{
url
:
"
"
skipUriTest
:
true
}
{
url
:
"
about
:
blank
"
}
{
url
:
"
about
:
home
"
}
{
url
:
"
about
:
newtab
"
}
{
url
:
"
not
:
/
/
a
/
supported
/
protocol
"
}
{
url
:
"
view
-
source
:
http
:
/
/
www
.
example
.
com
/
"
}
{
url
:
"
http
:
/
/
mochi
.
test
:
8888
/
?
q
=
chocolate
&
pc
=
sample_code
"
}
{
url
:
"
http
:
/
/
example
.
com
/
?
q
=
chocolate
&
pc
=
sample_code
"
}
{
url
:
"
https
:
/
/
example
.
com
/
?
q
=
chocolate
&
pc
=
sample_code2
"
}
{
url
:
"
https
:
/
/
example
.
com
/
?
q
=
chocolate
&
pc
=
sample_code
&
pc2
=
sample_code_2
"
}
{
url
:
"
https
:
/
/
example
.
com
/
?
q
=
chocolate
&
pc
=
sample_code
"
expectedString
:
"
chocolate
"
}
{
url
:
"
https
:
/
/
example
.
com
/
?
q
=
chocolate
+
cakes
&
pc
=
sample_code
"
expectedString
:
"
chocolate
cakes
"
}
]
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestEngine
"
search_url
:
"
https
:
/
/
example
.
com
/
"
search_url_get_params
:
"
?
q
=
{
searchTerms
}
&
pc
=
sample_code
"
}
{
skipUnload
:
true
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
TestEngine
"
)
;
let
originalDefaultEngine
=
Services
.
search
.
defaultEngine
;
Services
.
search
.
defaultEngine
=
engine
;
for
(
let
testCase
of
testCases
)
{
let
expectedString
=
testCase
.
expectedString
?
?
"
"
;
Assert
.
equal
(
UrlbarSearchUtils
.
getSearchTermIfDefaultSerpUri
(
testCase
.
url
)
expectedString
Should
return
{
expectedString
=
=
"
"
?
"
an
empty
string
"
:
"
a
matching
search
string
"
}
)
;
if
(
!
testCase
.
skipUriTest
)
{
Assert
.
equal
(
UrlbarSearchUtils
.
getSearchTermIfDefaultSerpUri
(
Services
.
io
.
newURI
(
testCase
.
url
)
)
expectedString
Should
return
{
expectedString
=
=
"
"
?
"
an
empty
string
"
:
"
a
matching
search
string
"
}
)
;
}
}
Services
.
search
.
defaultEngine
=
originalDefaultEngine
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
matchAllDomainLevels
(
)
{
let
baseHostname
=
"
matchalldomainlevels
"
;
Assert
.
equal
(
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
baseHostname
)
)
.
length
0
Sanity
check
:
No
engines
initially
match
{
baseHostname
}
)
;
let
baseDomain
=
{
baseHostname
}
.
com
;
let
perfectDomains
=
[
baseDomain
www
.
{
baseDomain
}
]
;
let
partialDomains
=
[
foo
.
{
baseDomain
}
foo
.
bar
.
{
baseDomain
}
]
;
let
extensions
=
[
]
;
for
(
let
list
of
[
partialDomains
perfectDomains
]
)
{
for
(
let
domain
of
list
)
{
let
ext
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
domain
search_url
:
https
:
/
/
{
domain
}
/
}
{
skipUnload
:
true
}
)
;
extensions
.
push
(
ext
)
;
}
}
let
expectedDomains
=
[
.
.
.
perfectDomains
.
.
.
partialDomains
]
;
let
searchStrings
=
[
baseHostname
baseHostname
+
"
.
"
]
;
for
(
let
searchString
of
searchStrings
)
{
info
(
Searching
for
"
{
searchString
}
"
)
;
let
engines
=
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
searchString
{
matchAllDomainLevels
:
true
}
)
;
let
engineData
=
engines
.
map
(
e
=
>
(
{
name
:
e
.
name
searchForm
:
e
.
searchForm
}
)
)
;
info
(
"
Matching
engines
:
"
+
JSON
.
stringify
(
engineData
)
)
;
Assert
.
equal
(
engines
.
length
expectedDomains
.
length
"
Expected
number
of
matching
engines
"
)
;
Assert
.
deepEqual
(
engineData
.
map
(
d
=
>
d
.
name
)
expectedDomains
"
Expected
matching
engine
names
/
domains
in
the
expected
order
"
)
;
}
await
Promise
.
all
(
extensions
.
map
(
e
=
>
e
.
unload
(
)
)
)
;
}
)
;
function
promiseSearchTopic
(
expectedVerb
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observe
(
subject
topic
verb
)
{
info
(
"
browser
-
search
-
engine
-
modified
:
"
+
verb
)
;
if
(
verb
=
=
expectedVerb
)
{
Services
.
obs
.
removeObserver
(
observe
"
browser
-
search
-
engine
-
modified
"
)
;
resolve
(
)
;
}
}
"
browser
-
search
-
engine
-
modified
"
)
;
}
)
;
}
