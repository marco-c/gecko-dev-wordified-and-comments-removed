"
use
strict
"
;
const
HEURISTIC_FALLBACK_PROVIDERNAME
=
"
HeuristicFallback
"
;
const
origin
=
"
example
.
com
"
;
async
function
cleanup
(
)
{
let
suggestPrefs
=
[
"
history
"
"
bookmark
"
"
openpage
"
]
;
for
(
let
type
of
suggestPrefs
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
"
+
type
)
;
}
await
cleanupPlaces
(
)
;
}
testEngine_setup
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
quickactions
"
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
quickactions
"
false
)
;
add_task
(
async
function
trailingSlash
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
/
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
{
origin
}
/
completed
:
http
:
/
/
{
origin
}
/
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
/
title
:
test
visit
for
http
:
/
/
{
origin
}
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
trailingSlashWWW
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
www
.
example
.
com
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
/
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
http
:
/
/
www
.
example
.
com
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
www
.
{
origin
}
/
title
:
test
visit
for
http
:
/
/
www
.
{
origin
}
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
port
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
:
8888
/
"
completed
:
"
http
:
/
/
example
.
com
:
8888
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
:
8888
/
title
:
test
visit
for
http
:
/
/
{
origin
}
:
8888
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
portPartial
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
:
8
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
:
8888
/
"
completed
:
"
http
:
/
/
example
.
com
:
8888
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
:
8888
/
title
:
test
visit
for
http
:
/
/
{
origin
}
:
8888
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
preserveCase
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
]
)
;
let
context
=
createContext
(
"
EXaM
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
EXaMple
.
com
/
"
completed
:
"
http
:
/
/
example
.
com
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
/
title
:
test
visit
for
http
:
/
/
{
origin
}
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
preserveCasePort
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
"
EXaM
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
EXaMple
.
com
:
8888
/
"
completed
:
"
http
:
/
/
example
.
com
:
8888
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
:
8888
/
title
:
test
visit
for
http
:
/
/
{
origin
}
:
8888
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
portNoMatch1
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
:
89
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
http
:
/
/
{
origin
}
:
89
/
title
:
http
:
/
/
{
origin
}
:
89
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
portNoMatch2
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
:
9
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
http
:
/
/
{
origin
}
:
9
/
title
:
http
:
/
/
{
origin
}
:
9
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
trailingSlash_2
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
]
)
;
let
context
=
createContext
(
"
example
/
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
"
http
:
/
/
example
/
"
title
:
"
http
:
/
/
example
/
"
iconUri
:
"
page
-
icon
:
http
:
/
/
example
/
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
multidotted
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
www
.
example
.
co
.
jp
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
"
www
.
example
.
co
.
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
www
.
example
.
co
.
jp
:
8888
/
"
completed
:
"
http
:
/
/
www
.
example
.
co
.
jp
:
8888
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
www
.
example
.
co
.
jp
:
8888
/
"
title
:
"
test
visit
for
http
:
/
/
www
.
example
.
co
.
jp
:
8888
/
"
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_ip
(
)
{
Services
.
prefs
.
setBoolPref
(
"
keyword
.
enabled
"
false
)
;
for
(
let
str
of
[
"
192
.
168
.
1
.
1
/
"
"
255
.
255
.
255
.
255
:
8080
/
"
"
[
2001
:
db8
:
:
1428
:
57ab
]
/
"
"
[
:
:
c0a8
:
5909
]
/
"
"
[
:
:
1
]
/
"
]
)
{
info
(
"
testing
"
+
str
)
;
await
PlacesTestUtils
.
addVisits
(
"
http
:
/
/
"
+
str
)
;
for
(
let
i
=
1
;
i
<
str
.
length
;
+
+
i
)
{
let
context
=
createContext
(
str
.
substring
(
0
i
)
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
str
completed
:
"
http
:
/
/
"
+
str
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
"
+
str
title
:
test
visit
for
http
:
/
/
{
str
}
heuristic
:
true
}
)
]
}
)
;
}
await
cleanup
(
)
;
}
Services
.
prefs
.
clearUserPref
(
"
keyword
.
enabled
"
)
;
}
)
;
add_task
(
async
function
large_number_host
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
12345example
.
it
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
"
1234
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
12345example
.
it
:
8888
/
"
completed
:
"
http
:
/
/
12345example
.
it
:
8888
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
12345example
.
it
:
8888
/
"
title
:
"
test
visit
for
http
:
/
/
12345example
.
it
:
8888
/
"
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
groupByHost
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
]
)
;
let
httpFrec
=
frecencyForUrl
(
"
http
:
/
/
example
.
com
/
"
)
;
let
httpsFrec
=
frecencyForUrl
(
"
https
:
/
/
example
.
com
/
"
)
;
let
otherFrec
=
frecencyForUrl
(
"
https
:
/
/
mozilla
.
org
/
"
)
;
Assert
.
less
(
httpFrec
httpsFrec
"
Sanity
check
"
)
;
Assert
.
less
(
httpsFrec
otherFrec
"
Sanity
check
"
)
;
let
threshold
=
await
getOriginAutofillThreshold
(
)
;
Assert
.
less
(
httpFrec
threshold
"
http
origin
should
be
<
threshold
"
)
;
Assert
.
less
(
httpsFrec
threshold
"
https
origin
should
be
<
threshold
"
)
;
Assert
.
ok
(
threshold
<
=
otherFrec
"
Other
origin
should
cross
threshold
"
)
;
Assert
.
ok
(
threshold
<
=
httpFrec
+
httpsFrec
"
http
and
https
origin
added
together
should
cross
threshold
"
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
groupByHostNonDefaultStddevMultiplier
(
)
{
let
stddevMultiplier
=
1
.
5
;
Services
.
prefs
.
setCharPref
(
"
browser
.
urlbar
.
autoFill
.
stddevMultiplier
"
Number
(
stddevMultiplier
)
.
toFixed
(
1
)
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
foo
.
com
/
"
}
{
uri
:
"
https
:
/
/
foo
.
com
/
"
}
{
uri
:
"
https
:
/
/
foo
.
com
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
]
)
;
let
httpFrec
=
frecencyForUrl
(
"
http
:
/
/
example
.
com
/
"
)
;
let
httpsFrec
=
frecencyForUrl
(
"
https
:
/
/
example
.
com
/
"
)
;
let
otherFrec
=
frecencyForUrl
(
"
https
:
/
/
mozilla
.
org
/
"
)
;
Assert
.
less
(
httpFrec
httpsFrec
"
Sanity
check
"
)
;
Assert
.
less
(
httpsFrec
otherFrec
"
Sanity
check
"
)
;
let
threshold
=
await
getOriginAutofillThreshold
(
)
;
Assert
.
less
(
httpFrec
threshold
"
http
origin
should
be
<
threshold
"
)
;
Assert
.
less
(
httpsFrec
threshold
"
https
origin
should
be
<
threshold
"
)
;
Assert
.
ok
(
threshold
<
=
otherFrec
"
Other
origin
should
cross
threshold
"
)
;
Assert
.
ok
(
threshold
<
=
httpFrec
+
httpsFrec
"
http
and
https
origin
added
together
should
cross
threshold
"
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
}
)
]
}
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
autoFill
.
stddevMultiplier
"
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
suggestHistoryFalse_bookmark_multiple
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
history
"
false
)
;
let
search
=
"
ex
"
;
let
baseURL
=
"
http
:
/
/
example
.
com
/
"
;
let
bookmarkedURL
=
baseURL
+
"
bookmarked
"
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
baseURL
+
"
other1
"
}
]
)
;
let
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
]
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
bookmarkedURL
}
]
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
]
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
baseURL
+
"
other2
"
}
]
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
]
}
)
;
await
PlacesTestUtils
.
addBookmarkWithDetails
(
{
uri
:
bookmarkedURL
}
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
baseURL
hasAutofillTitle
:
false
matches
:
[
makeVisitResult
(
context
{
uri
:
baseURL
title
:
"
example
.
com
"
heuristic
:
true
}
)
makeBookmarkResult
(
context
{
uri
:
bookmarkedURL
title
:
"
A
bookmark
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
suggestHistoryFalse_bookmark_prefix_multiple
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
history
"
false
)
;
let
search
=
"
http
:
/
/
ex
"
;
let
baseURL
=
"
http
:
/
/
example
.
com
/
"
;
let
bookmarkedURL
=
baseURL
+
"
bookmarked
"
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
baseURL
+
"
other1
"
}
]
)
;
let
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
{
search
}
/
title
:
{
search
}
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
bookmarkedURL
}
]
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
{
search
}
/
title
:
{
search
}
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
baseURL
+
"
other2
"
}
]
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
{
search
}
/
title
:
{
search
}
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
PlacesTestUtils
.
addBookmarkWithDetails
(
{
uri
:
bookmarkedURL
}
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
http
:
/
/
example
.
com
/
"
completed
:
baseURL
hasAutofillTitle
:
false
matches
:
[
makeVisitResult
(
context
{
uri
:
baseURL
title
:
"
example
.
com
"
heuristic
:
true
}
)
makeBookmarkResult
(
context
{
uri
:
bookmarkedURL
title
:
"
A
bookmark
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
searchParams
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
?
"
"
http
:
/
/
example
.
com
/
?
foo
"
]
)
;
UrlbarPrefs
.
set
(
"
autoFill
"
false
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
?
foo
"
title
:
"
test
visit
for
http
:
/
/
example
.
com
/
?
foo
"
}
)
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
?
"
title
:
"
test
visit
for
http
:
/
/
example
.
com
/
?
"
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
autoFill
"
)
;
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
http
:
/
/
example
.
com
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
http
:
/
/
example
.
com
/
"
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
?
foo
"
title
:
"
test
visit
for
http
:
/
/
example
.
com
/
?
foo
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
searchParams_https
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
example
.
com
/
"
"
https
:
/
/
example
.
com
/
?
"
"
https
:
/
/
example
.
com
/
?
foo
"
]
)
;
UrlbarPrefs
.
set
(
"
autoFill
"
false
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
?
foo
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
?
foo
"
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
?
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
?
"
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
autoFill
"
)
;
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
?
foo
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
?
foo
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
originLooksLikePrefix
(
)
{
let
hostAndPort
=
"
localhost
:
8888
"
;
let
address
=
http
:
/
/
{
hostAndPort
}
/
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
address
}
]
)
;
UrlbarPrefs
.
set
(
"
suggest
.
engines
"
false
)
;
for
(
let
search
of
[
"
lo
"
"
localhost
"
"
localhost
:
"
"
localhost
:
8888
"
]
)
{
let
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
hostAndPort
+
"
/
"
completed
:
address
hasAutofillTitle
:
true
matches
:
[
makeVisitResult
(
context
{
uri
:
address
title
:
test
visit
for
http
:
/
/
{
hostAndPort
}
/
heuristic
:
true
}
)
]
}
)
;
}
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
about
(
)
{
const
testData
=
[
{
uri
:
"
about
:
config
"
input
:
"
conf
"
results
:
[
context
=
>
makeSearchResult
(
context
{
engineName
:
"
Suggestions
"
heuristic
:
true
}
)
context
=
>
makeBookmarkResult
(
context
{
uri
:
"
about
:
config
"
title
:
"
A
bookmark
"
}
)
]
}
{
uri
:
"
about
:
blank
"
input
:
"
about
:
blan
"
results
:
[
context
=
>
makeVisitResult
(
context
{
uri
:
"
about
:
blan
"
title
:
"
about
:
blan
"
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
heuristic
:
true
}
)
context
=
>
makeBookmarkResult
(
context
{
uri
:
"
about
:
blank
"
title
:
"
A
bookmark
"
}
)
]
}
]
;
for
(
const
{
uri
input
results
}
of
testData
)
{
await
PlacesTestUtils
.
addBookmarkWithDetails
(
{
uri
}
)
;
const
context
=
createContext
(
input
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
results
.
map
(
f
=
>
f
(
context
)
)
}
)
;
await
cleanup
(
)
;
}
}
)
;
