"
use
strict
"
;
const
HEURISTIC_FALLBACK_PROVIDERNAME
=
"
UrlbarProviderHeuristicFallback
"
;
const
origin
=
"
example
.
com
"
;
async
function
cleanup
(
)
{
let
suggestPrefs
=
[
"
history
"
"
bookmark
"
"
openpage
"
]
;
for
(
let
type
of
suggestPrefs
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
"
+
type
)
;
}
await
cleanupPlaces
(
)
;
}
testEngine_setup
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
quickactions
"
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
quickactions
"
false
)
;
add_task
(
async
function
trailingSlash
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
/
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
{
origin
}
/
completed
:
http
:
/
/
{
origin
}
/
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
/
title
:
test
visit
for
http
:
/
/
{
origin
}
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
trailingSlashWWW
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
www
.
example
.
com
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
/
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
http
:
/
/
www
.
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
www
.
{
origin
}
/
title
:
test
visit
for
http
:
/
/
www
.
{
origin
}
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
port
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
:
8888
/
"
completed
:
"
http
:
/
/
example
.
com
:
8888
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
:
8888
/
title
:
test
visit
for
http
:
/
/
{
origin
}
:
8888
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
portPartial
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
:
8
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
:
8888
/
"
completed
:
"
http
:
/
/
example
.
com
:
8888
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
:
8888
/
title
:
test
visit
for
http
:
/
/
{
origin
}
:
8888
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
preserveCase
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
]
)
;
let
context
=
createContext
(
"
EXaM
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
EXaMple
.
com
/
"
completed
:
"
http
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
/
title
:
test
visit
for
http
:
/
/
{
origin
}
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
preserveCasePort
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
"
EXaM
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
EXaMple
.
com
:
8888
/
"
completed
:
"
http
:
/
/
example
.
com
:
8888
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
http
:
/
/
{
origin
}
:
8888
/
title
:
test
visit
for
http
:
/
/
{
origin
}
:
8888
/
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
portNoMatch1
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
:
89
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
http
:
/
/
{
origin
}
:
89
/
fallbackTitle
:
{
origin
}
:
89
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
portNoMatch2
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
{
origin
}
:
9
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
http
:
/
/
{
origin
}
:
9
/
fallbackTitle
:
{
origin
}
:
9
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
trailingSlash_2
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
]
)
;
let
context
=
createContext
(
"
example
/
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
"
http
:
/
/
example
/
"
fallbackTitle
:
"
example
/
"
iconUri
:
"
page
-
icon
:
http
:
/
/
example
/
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
multidotted
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
www
.
example
.
co
.
jp
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
"
www
.
example
.
co
.
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
www
.
example
.
co
.
jp
:
8888
/
"
completed
:
"
http
:
/
/
www
.
example
.
co
.
jp
:
8888
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
www
.
example
.
co
.
jp
:
8888
/
"
title
:
"
test
visit
for
http
:
/
/
www
.
example
.
co
.
jp
:
8888
/
"
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_ip
(
)
{
Services
.
prefs
.
setBoolPref
(
"
keyword
.
enabled
"
false
)
;
for
(
let
str
of
[
"
192
.
168
.
1
.
1
/
"
"
255
.
255
.
255
.
255
:
8080
/
"
"
[
2001
:
db8
:
:
1428
:
57ab
]
/
"
"
[
:
:
c0a8
:
5909
]
/
"
"
[
:
:
1
]
/
"
]
)
{
info
(
"
testing
"
+
str
)
;
await
PlacesTestUtils
.
addVisits
(
"
http
:
/
/
"
+
str
)
;
for
(
let
i
=
1
;
i
<
str
.
length
;
+
+
i
)
{
let
context
=
createContext
(
str
.
substring
(
0
i
)
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
str
completed
:
"
http
:
/
/
"
+
str
matches
:
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
"
+
str
title
:
test
visit
for
http
:
/
/
{
str
}
heuristic
:
true
}
)
]
}
)
;
}
await
cleanup
(
)
;
}
Services
.
prefs
.
clearUserPref
(
"
keyword
.
enabled
"
)
;
}
)
;
add_task
(
async
function
large_number_host
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
12345example
.
it
:
8888
/
"
}
]
)
;
let
context
=
createContext
(
"
1234
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
12345example
.
it
:
8888
/
"
completed
:
"
http
:
/
/
12345example
.
it
:
8888
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
12345example
.
it
:
8888
/
"
title
:
"
test
visit
for
http
:
/
/
12345example
.
it
:
8888
/
"
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
groupByHost
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
]
)
;
let
httpFrec
=
await
PlacesTestUtils
.
getDatabaseValue
(
"
moz_places
"
"
frecency
"
{
url
:
"
http
:
/
/
example
.
com
/
"
}
)
;
let
httpsFrec
=
await
PlacesTestUtils
.
getDatabaseValue
(
"
moz_places
"
"
frecency
"
{
url
:
"
https
:
/
/
example
.
com
/
"
}
)
;
let
otherFrec
=
await
PlacesTestUtils
.
getDatabaseValue
(
"
moz_places
"
"
frecency
"
{
url
:
"
https
:
/
/
mozilla
.
org
/
"
}
)
;
Assert
.
less
(
httpFrec
httpsFrec
"
Sanity
check
"
)
;
Assert
.
less
(
httpsFrec
otherFrec
"
Sanity
check
"
)
;
let
threshold
=
await
getOriginAutofillThreshold
(
)
;
Assert
.
less
(
httpFrec
threshold
"
http
origin
should
be
<
threshold
"
)
;
Assert
.
less
(
httpsFrec
threshold
"
https
origin
should
be
<
threshold
"
)
;
Assert
.
lessOrEqual
(
threshold
otherFrec
"
Other
origin
should
cross
threshold
"
)
;
Assert
.
lessOrEqual
(
threshold
httpFrec
+
httpsFrec
"
http
and
https
origin
added
together
should
cross
threshold
"
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
groupByHostNonDefaultStddevMultiplier
(
)
{
let
stddevMultiplier
=
1
.
5
;
Services
.
prefs
.
setCharPref
(
"
browser
.
urlbar
.
autoFill
.
stddevMultiplier
"
Number
(
stddevMultiplier
)
.
toFixed
(
1
)
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
{
uri
:
"
http
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
example
.
com
/
"
}
{
uri
:
"
https
:
/
/
foo
.
com
/
"
}
{
uri
:
"
https
:
/
/
foo
.
com
/
"
}
{
uri
:
"
https
:
/
/
foo
.
com
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
{
uri
:
"
https
:
/
/
mozilla
.
org
/
"
}
]
)
;
let
httpFrec
=
await
PlacesTestUtils
.
getDatabaseValue
(
"
moz_places
"
"
frecency
"
{
url
:
"
http
:
/
/
example
.
com
/
"
}
)
;
let
httpsFrec
=
await
PlacesTestUtils
.
getDatabaseValue
(
"
moz_places
"
"
frecency
"
{
url
:
"
https
:
/
/
example
.
com
/
"
}
)
;
let
otherFrec
=
await
PlacesTestUtils
.
getDatabaseValue
(
"
moz_places
"
"
frecency
"
{
url
:
"
https
:
/
/
mozilla
.
org
/
"
}
)
;
Assert
.
less
(
httpFrec
httpsFrec
"
Sanity
check
"
)
;
Assert
.
less
(
httpsFrec
otherFrec
"
Sanity
check
"
)
;
let
threshold
=
await
getOriginAutofillThreshold
(
)
;
Assert
.
less
(
httpFrec
threshold
"
http
origin
should
be
<
threshold
"
)
;
Assert
.
less
(
httpsFrec
threshold
"
https
origin
should
be
<
threshold
"
)
;
Assert
.
lessOrEqual
(
threshold
otherFrec
"
Other
origin
should
cross
threshold
"
)
;
Assert
.
lessOrEqual
(
threshold
httpFrec
+
httpsFrec
"
http
and
https
origin
added
together
should
cross
threshold
"
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
}
)
]
}
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
autoFill
.
stddevMultiplier
"
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
suggestHistoryFalse_bookmark_multiple
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
history
"
false
)
;
let
search
=
"
ex
"
;
let
baseURL
=
"
http
:
/
/
example
.
com
/
"
;
let
bookmarkedURL
=
baseURL
+
"
bookmarked
"
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
baseURL
+
"
other1
"
}
]
)
;
let
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
]
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
bookmarkedURL
}
]
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
]
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
baseURL
+
"
other2
"
}
]
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
]
}
)
;
await
PlacesTestUtils
.
addBookmarkWithDetails
(
{
uri
:
bookmarkedURL
}
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
baseURL
matches
:
[
makeVisitResult
(
context
{
uri
:
baseURL
fallbackTitle
:
UrlbarTestUtils
.
trimURL
(
baseURL
)
heuristic
:
true
}
)
makeBookmarkResult
(
context
{
uri
:
bookmarkedURL
title
:
"
A
bookmark
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
suggestHistoryFalse_bookmark_prefix_multiple
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
history
"
false
)
;
let
search
=
"
http
:
/
/
ex
"
;
let
baseURL
=
"
http
:
/
/
example
.
com
/
"
;
let
bookmarkedURL
=
baseURL
+
"
bookmarked
"
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
baseURL
+
"
other1
"
}
]
)
;
let
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
{
search
}
/
fallbackTitle
:
{
search
}
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
bookmarkedURL
}
]
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
{
search
}
/
fallbackTitle
:
{
search
}
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
baseURL
+
"
other2
"
}
]
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
uri
:
{
search
}
/
fallbackTitle
:
{
search
}
/
iconUri
:
"
"
heuristic
:
true
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
}
)
]
}
)
;
await
PlacesTestUtils
.
addBookmarkWithDetails
(
{
uri
:
bookmarkedURL
}
)
;
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
http
:
/
/
example
.
com
/
"
completed
:
baseURL
matches
:
[
makeVisitResult
(
context
{
uri
:
baseURL
fallbackTitle
:
UrlbarTestUtils
.
trimURL
(
baseURL
)
heuristic
:
true
}
)
makeBookmarkResult
(
context
{
uri
:
bookmarkedURL
title
:
"
A
bookmark
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
searchParams
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
http
:
/
/
example
.
com
/
"
"
http
:
/
/
example
.
com
/
?
"
"
http
:
/
/
example
.
com
/
?
foo
"
]
)
;
UrlbarPrefs
.
set
(
"
autoFill
"
false
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
?
foo
"
title
:
"
test
visit
for
http
:
/
/
example
.
com
/
?
foo
"
}
)
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
?
"
title
:
"
test
visit
for
http
:
/
/
example
.
com
/
?
"
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
autoFill
"
)
;
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
http
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
http
:
/
/
example
.
com
/
"
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
?
foo
"
title
:
"
test
visit
for
http
:
/
/
example
.
com
/
?
foo
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
searchParams_https
(
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
https
:
/
/
example
.
com
/
"
"
https
:
/
/
example
.
com
/
?
"
"
https
:
/
/
example
.
com
/
?
foo
"
]
)
;
UrlbarPrefs
.
set
(
"
autoFill
"
false
)
;
let
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
SUGGESTIONS_ENGINE_NAME
providerName
:
HEURISTIC_FALLBACK_PROVIDERNAME
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
?
foo
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
?
foo
"
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
?
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
?
"
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
autoFill
"
)
;
context
=
createContext
(
"
ex
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
example
.
com
/
"
completed
:
"
https
:
/
/
example
.
com
/
"
matches
:
[
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
"
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
example
.
com
/
?
foo
"
title
:
"
test
visit
for
https
:
/
/
example
.
com
/
?
foo
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
originLooksLikePrefix
(
)
{
let
hostAndPort
=
"
localhost
:
8888
"
;
let
address
=
http
:
/
/
{
hostAndPort
}
/
;
await
PlacesTestUtils
.
addVisits
(
[
{
uri
:
address
}
]
)
;
UrlbarPrefs
.
set
(
"
suggest
.
engines
"
false
)
;
for
(
let
search
of
[
"
lo
"
"
localhost
"
"
localhost
:
"
"
localhost
:
8888
"
]
)
{
let
context
=
createContext
(
search
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
hostAndPort
+
"
/
"
completed
:
address
matches
:
[
makeVisitResult
(
context
{
uri
:
address
title
:
test
visit
for
http
:
/
/
{
hostAndPort
}
/
heuristic
:
true
}
)
]
}
)
;
}
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
about
(
)
{
const
testData
=
[
{
uri
:
"
about
:
config
"
input
:
"
conf
"
results
:
[
context
=
>
makeSearchResult
(
context
{
engineName
:
"
Suggestions
"
heuristic
:
true
}
)
context
=
>
makeBookmarkResult
(
context
{
uri
:
"
about
:
config
"
title
:
"
A
bookmark
"
}
)
]
}
{
uri
:
"
about
:
blank
"
input
:
"
about
:
blan
"
results
:
[
context
=
>
makeVisitResult
(
context
{
uri
:
"
about
:
blan
"
fallbackTitle
:
"
about
:
blan
"
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
heuristic
:
true
}
)
context
=
>
makeBookmarkResult
(
context
{
uri
:
"
about
:
blank
"
title
:
"
A
bookmark
"
}
)
]
}
]
;
for
(
const
{
uri
input
results
}
of
testData
)
{
await
PlacesTestUtils
.
addBookmarkWithDetails
(
{
uri
}
)
;
const
context
=
createContext
(
input
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
results
.
map
(
f
=
>
f
(
context
)
)
}
)
;
await
cleanup
(
)
;
}
}
)
;
add_task
(
async
function
place
(
)
{
const
testData
=
[
{
uri
:
"
place
:
transition
=
7
&
sort
=
4
"
input
:
"
tran
"
}
{
uri
:
"
place
:
transition
=
7
&
sort
=
4
"
input
:
"
place
:
tran
"
}
]
;
for
(
const
{
uri
input
}
of
testData
)
{
await
PlacesTestUtils
.
addBookmarkWithDetails
(
{
uri
}
)
;
const
context
=
createContext
(
input
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
"
Suggestions
"
heuristic
:
true
}
)
]
}
)
;
await
cleanup
(
)
;
}
}
)
;
add_task
(
async
function
nullTitle
(
)
{
await
doTitleTest
(
{
visits
:
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
"
frecency
:
100
}
{
uri
:
"
https
:
/
/
www
.
example
.
com
/
"
title
:
"
high
frecency
"
frecency
:
50
}
{
uri
:
"
http
:
/
/
www
.
example
.
com
/
"
title
:
"
low
frecency
"
frecency
:
1
}
]
input
:
"
example
.
com
"
expected
:
{
autofilled
:
"
example
.
com
/
"
completed
:
"
http
:
/
/
example
.
com
/
"
matches
:
context
=
>
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
high
frecency
"
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
www
.
example
.
com
/
"
title
:
"
high
frecency
"
}
)
]
}
}
)
;
}
)
;
add_task
(
async
function
domainTitle
(
)
{
await
doTitleTest
(
{
visits
:
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
example
.
com
"
frecency
:
100
}
{
uri
:
"
https
:
/
/
www
.
example
.
com
/
"
title
:
"
"
frecency
:
50
}
{
uri
:
"
http
:
/
/
www
.
example
.
com
/
"
title
:
"
lowest
frecency
but
has
title
"
frecency
:
1
}
]
input
:
"
example
.
com
"
expected
:
{
autofilled
:
"
example
.
com
/
"
completed
:
"
http
:
/
/
example
.
com
/
"
matches
:
context
=
>
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
lowest
frecency
but
has
title
"
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
www
.
example
.
com
/
"
title
:
"
www
.
example
.
com
"
}
)
]
}
}
)
;
}
)
;
add_task
(
async
function
exactMatchedTitle
(
)
{
await
doTitleTest
(
{
visits
:
[
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
exact
match
"
frecency
:
50
}
{
uri
:
"
https
:
/
/
www
.
example
.
com
/
"
title
:
"
high
frecency
uri
"
frecency
:
100
}
]
input
:
"
http
:
/
/
example
.
com
/
"
expected
:
{
autofilled
:
"
http
:
/
/
example
.
com
/
"
completed
:
"
http
:
/
/
example
.
com
/
"
matches
:
context
=
>
[
makeVisitResult
(
context
{
uri
:
"
http
:
/
/
example
.
com
/
"
title
:
"
exact
match
"
heuristic
:
true
}
)
makeVisitResult
(
context
{
uri
:
"
https
:
/
/
www
.
example
.
com
/
"
title
:
"
high
frecency
uri
"
}
)
]
}
}
)
;
}
)
;
async
function
doTitleTest
(
{
visits
input
expected
}
)
{
await
PlacesTestUtils
.
addVisits
(
visits
)
;
for
(
const
{
uri
frecency
}
of
visits
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
test
:
:
doTitleTest
"
async
db
=
>
{
await
db
.
execute
(
UPDATE
moz_places
SET
frecency
=
:
frecency
recalc_frecency
=
0
WHERE
url
=
:
url
{
frecency
url
:
uri
}
)
;
await
PlacesFrecencyRecalculator
.
recalculateAnyOutdatedFrecencies
(
)
;
}
)
;
}
const
context
=
createContext
(
input
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
expected
.
autofilled
completed
:
expected
.
completed
matches
:
expected
.
matches
(
context
)
}
)
;
await
cleanup
(
)
;
}
add_task
(
async
function
just_multiple_unvisited_bookmarks
(
)
{
let
filledUrl
=
"
https
:
/
/
www
.
tld2
.
com
/
"
;
let
urls
=
[
{
url
:
"
https
:
/
/
tld1
.
com
/
"
count
:
1
}
{
url
:
"
https
:
/
/
tld2
.
com
/
"
count
:
2
}
{
url
:
filledUrl
count
:
2
}
{
url
:
"
https
:
/
/
tld3
.
com
/
"
count
:
3
}
]
;
await
PlacesUtils
.
history
.
clear
(
)
;
for
(
let
{
url
count
}
of
urls
)
{
while
(
count
-
-
)
{
await
PlacesTestUtils
.
addBookmarkWithDetails
(
{
uri
:
url
}
)
;
}
}
await
PlacesFrecencyRecalculator
.
recalculateAnyOutdatedFrecencies
(
)
;
let
context
=
createContext
(
"
tld
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
autofilled
:
"
tld2
.
com
/
"
completed
:
filledUrl
matches
:
[
makeVisitResult
(
context
{
uri
:
filledUrl
title
:
"
A
bookmark
"
heuristic
:
true
}
)
makeBookmarkResult
(
context
{
uri
:
"
https
:
/
/
tld3
.
com
/
"
title
:
"
A
bookmark
"
}
)
makeBookmarkResult
(
context
{
uri
:
"
https
:
/
/
tld2
.
com
/
"
title
:
"
A
bookmark
"
}
)
makeBookmarkResult
(
context
{
uri
:
"
https
:
/
/
tld1
.
com
/
"
title
:
"
A
bookmark
"
}
)
]
}
)
;
await
cleanup
(
)
;
}
)
;
