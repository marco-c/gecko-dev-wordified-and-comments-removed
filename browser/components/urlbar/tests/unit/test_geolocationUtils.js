"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
GeolocationUtils
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
private
/
GeolocationUtils
.
sys
.
mjs
"
}
)
;
add_setup
(
async
(
)
=
>
{
await
MerinoTestUtils
.
initGeolocation
(
)
;
}
)
;
const
KAWASAKI
=
{
latitude
:
35
.
516667
longitude
:
139
.
7
country
:
"
JP
"
region
:
"
14
"
population
:
1531646
}
;
const
KAWASAKI_LARGER_POP
=
{
latitude
:
35
.
516667
longitude
:
139
.
7
country
:
"
JP
"
region
:
"
14
"
population
:
Infinity
}
;
const
YOKOSUKA
=
{
latitude
:
35
.
2815
longitude
:
139
.
672083
country
:
"
JP
"
region
:
"
14
"
population
:
388078
}
;
const
OSAKA
=
{
latitude
:
34
.
693889
longitude
:
135
.
502222
country
:
"
JP
"
region
:
"
27
"
population
:
2753862
}
;
const
MITOYO
=
{
latitude
:
34
.
1825
longitude
:
133
.
715
country
:
"
JP
"
region
:
"
37
"
population
:
59876
}
;
const
NYC
=
{
latitude
:
40
.
71427
longitude
:
-
74
.
00597
country
:
"
US
"
region
:
"
NY
"
population
:
8804190
}
;
add_task
(
async
function
bestByDistance
(
)
{
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
MITOYO
YOKOSUKA
KAWASAKI
KAWASAKI_LARGER_POP
NYC
]
)
KAWASAKI_LARGER_POP
"
Made
-
up
Kawasaki
-
like
city
should
be
best
when
listed
after
Kawasaki
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
MITOYO
YOKOSUKA
KAWASAKI_LARGER_POP
KAWASAKI
NYC
]
)
KAWASAKI_LARGER_POP
"
Made
-
up
Kawasaki
-
like
city
should
be
best
when
listed
before
Kawasaki
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
MITOYO
YOKOSUKA
KAWASAKI
NYC
]
)
KAWASAKI
"
Kawasaki
should
be
best
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
MITOYO
YOKOSUKA
{
.
.
.
KAWASAKI
latitude
:
null
}
NYC
]
)
YOKOSUKA
"
Yokosuka
should
be
best
when
Kawasaki
location
is
missing
latitude
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
MITOYO
YOKOSUKA
{
.
.
.
KAWASAKI
longitude
:
null
}
NYC
]
)
YOKOSUKA
"
Yokosuka
should
be
best
when
Kawasaki
location
is
missing
longitude
"
)
;
}
)
;
add_task
(
async
function
bestByRegion
(
)
{
let
kawasaki
=
{
.
.
.
KAWASAKI
latitude
:
null
longitude
:
null
}
;
let
yokosuka
=
{
.
.
.
YOKOSUKA
latitude
:
null
longitude
:
null
}
;
let
osaka
=
{
.
.
.
OSAKA
latitude
:
null
longitude
:
null
}
;
let
mitoyo
=
{
.
.
.
MITOYO
latitude
:
null
longitude
:
null
}
;
let
nyc
=
{
.
.
.
NYC
latitude
:
null
longitude
:
null
}
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
mitoyo
yokosuka
kawasaki
nyc
]
)
kawasaki
"
Kawasaki
should
be
best
when
listed
after
Yokosuka
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
mitoyo
kawasaki
yokosuka
nyc
]
)
kawasaki
"
Kawasaki
should
be
best
when
listed
before
Yokosuka
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
mitoyo
yokosuka
nyc
]
)
yokosuka
"
Yokosuka
should
be
best
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
mitoyo
osaka
nyc
]
)
osaka
"
Osaka
should
be
best
when
listed
after
Mitoyo
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
osaka
mitoyo
nyc
]
)
osaka
"
Osaka
should
be
best
when
listed
before
Mitoyo
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
mitoyo
nyc
]
)
mitoyo
"
Mitoyo
should
be
best
when
listed
first
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
nyc
mitoyo
]
)
mitoyo
"
Mitoyo
should
be
best
when
listed
last
"
)
;
}
)
;
add_task
(
async
function
locationFromItem
(
)
{
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
MITOYO
KAWASAKI
YOKOSUKA
NYC
]
item
=
>
item
=
=
NYC
?
NYC
:
{
}
)
NYC
"
NYC
should
be
best
"
)
;
}
)
;
add_task
(
async
function
unexpectedMerinoGeolocation
(
)
{
MerinoTestUtils
.
server
.
response
=
{
status
:
501
}
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
YOKOSUKA
KAWASAKI
]
)
NYC
"
NYC
should
be
best
when
geolocation
response
is
not
a
200
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
MerinoTestUtils
.
server
.
response
=
{
status
:
200
}
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
YOKOSUKA
KAWASAKI
]
)
NYC
"
NYC
should
be
best
when
geolocation
response
is
empty
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
=
null
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
KAWASAKI
YOKOSUKA
]
)
NYC
"
NYC
should
be
best
when
geolocation
response
is
missing
custom_details
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
=
null
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
KAWASAKI
YOKOSUKA
]
)
NYC
"
NYC
should
be
best
when
geolocation
response
is
missing
geolocation
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
.
region_code
=
null
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
.
country_code
=
null
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
.
location
=
null
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
KAWASAKI
YOKOSUKA
]
)
NYC
"
NYC
should
be
best
when
geolocation
response
is
missing
geolocation
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
.
location
=
null
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
KAWASAKI
YOKOSUKA
]
)
KAWASAKI
"
Kawasaki
should
be
best
when
geolocation
response
is
missing
location
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
.
location
.
latitude
=
null
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
KAWASAKI
YOKOSUKA
]
)
KAWASAKI
"
Kawasaki
should
be
best
when
geolocation
response
is
missing
latitude
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
.
location
.
longitude
=
null
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
KAWASAKI
YOKOSUKA
]
)
KAWASAKI
"
Kawasaki
should
be
best
when
geolocation
response
is
missing
longitude
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
.
region_code
=
null
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
[
0
]
.
custom_details
.
geolocation
.
location
=
null
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
NYC
MITOYO
]
)
MITOYO
"
Mitoyo
should
be
best
when
geolocation
response
is
missing
region_code
and
location
and
Mitoyo
is
listed
after
NYC
"
)
;
Assert
.
deepEqual
(
await
GeolocationUtils
.
best
(
[
MITOYO
NYC
]
)
MITOYO
"
Mitoyo
should
be
best
when
geolocation
response
is
missing
region_code
and
location
and
Mitoyo
is
listed
before
NYC
"
)
;
await
MerinoTestUtils
.
initGeolocation
(
)
;
}
)
;
