"
use
strict
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
}
)
;
const
{
UrlbarProviderSemanticHistorySearch
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
UrlbarProviderSemanticHistorySearch
.
sys
.
mjs
"
)
;
let
sandbox
;
add_task
(
async
function
setup
(
)
{
sandbox
=
lazy
.
sinon
.
createSandbox
(
)
;
}
)
;
add_task
(
async
function
test_startQuery_adds_results
(
)
{
const
provider
=
UrlbarProviderSemanticHistorySearch
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
ml
.
enable
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
places
.
semanticHistory
.
featureGate
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
semanticHistory
"
true
)
;
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
setIntPref
(
"
browser
.
urlbar
.
suggest
.
semanticHistory
.
minLength
"
5
)
;
const
queryContext
=
{
searchString
:
"
test
page
"
}
;
Assert
.
ok
(
provider
.
isActive
(
queryContext
)
"
Provider
should
be
active
"
)
;
const
semanticManager
=
provider
.
ensureSemanticManagerInitialized
(
)
;
sandbox
.
stub
(
semanticManager
.
embedder
"
ensureEngine
"
)
.
callsFake
(
(
)
=
>
{
}
)
;
sandbox
.
stub
(
semanticManager
"
infer
"
)
.
resolves
(
{
results
:
[
{
id
:
1
title
:
"
Test
Page
"
url
:
"
https
:
/
/
example
.
com
"
helpLink
:
"
https
:
/
/
example
.
com
/
icon
"
}
]
}
)
;
let
added
=
[
]
;
await
provider
.
startQuery
(
queryContext
(
_provider
result
)
=
>
{
added
.
push
(
result
)
;
}
)
;
Assert
.
equal
(
added
.
length
1
"
One
result
should
be
added
"
)
;
Assert
.
equal
(
added
[
0
]
.
payload
.
url
"
https
:
/
/
example
.
com
"
"
Correct
URL
should
be
used
"
)
;
}
)
;
add_task
(
async
function
test_isActive_conditions
(
)
{
const
provider
=
UrlbarProviderSemanticHistorySearch
;
const
semanticManager
=
provider
.
ensureSemanticManagerInitialized
(
)
;
const
canUseStub
=
sandbox
.
stub
(
semanticManager
"
canUseSemanticSearch
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
semanticHistory
"
true
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
urlbar
.
suggest
.
semanticHistory
.
minLength
"
5
)
;
const
shortQuery
=
{
searchString
:
"
hi
"
}
;
const
validQuery
=
{
searchString
:
"
hello
world
"
}
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
semanticHistory
"
false
)
;
Assert
.
ok
(
!
provider
.
isActive
(
validQuery
)
"
Should
be
inactive
when
pref
is
disabled
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
suggest
.
semanticHistory
"
true
)
;
Assert
.
ok
(
!
provider
.
isActive
(
shortQuery
)
"
Should
be
inactive
for
short
search
strings
"
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
urlbar
.
suggest
.
semanticHistory
.
minLength
"
5
)
;
canUseStub
.
get
(
(
)
=
>
false
)
;
Assert
.
ok
(
!
provider
.
isActive
(
validQuery
)
"
Should
be
inactive
if
canUseSemanticSearch
returns
false
"
)
;
canUseStub
.
get
(
(
)
=
>
true
)
;
Assert
.
ok
(
provider
.
isActive
(
validQuery
)
"
Should
be
active
when
all
conditions
are
met
"
)
;
}
)
;
add_task
(
function
cleanup
(
)
{
sandbox
.
restore
(
)
;
}
)
;
