"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
jsm
"
UrlbarQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarQuickSuggest
.
jsm
"
}
)
;
const
TEST_MERINO_TIMEOUT_MS
=
1000
;
const
PREF_MERINO_ENABLED
=
"
merino
.
enabled
"
;
const
PREF_REMOTE_SETTINGS_ENABLED
=
"
quicksuggest
.
remoteSettings
.
enabled
"
;
const
PREF_MERINO_ENDPOINT_URL
=
"
merino
.
endpointURL
"
;
const
PREF_DATA_COLLECTION_ENABLED
=
"
quicksuggest
.
dataCollection
.
enabled
"
;
const
TELEMETRY_MERINO_LATENCY
=
"
FX_URLBAR_MERINO_LATENCY_MS
"
;
const
TELEMETRY_MERINO_RESPONSE
=
"
FX_URLBAR_MERINO_RESPONSE
"
;
const
FETCH_RESPONSE
=
{
none
:
-
1
success
:
0
timeout
:
1
network_error
:
2
http_error
:
3
}
;
const
REMOTE_SETTINGS_SEARCH_STRING
=
"
frab
"
;
const
REMOTE_SETTINGS_DATA
=
[
{
id
:
1
url
:
"
http
:
/
/
test
.
com
/
q
=
frabbits
"
title
:
"
frabbits
"
keywords
:
[
REMOTE_SETTINGS_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
"
advertiser
:
"
TestAdvertiser
"
}
]
;
const
EXPECTED_REMOTE_SETTINGS_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
qsSuggestion
:
REMOTE_SETTINGS_SEARCH_STRING
title
:
"
frabbits
"
url
:
"
http
:
/
/
test
.
com
/
q
=
frabbits
"
icon
:
null
sponsoredImpressionUrl
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
"
sponsoredClickUrl
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
"
sponsoredBlockId
:
1
sponsoredAdvertiser
:
"
testadvertiser
"
isSponsored
:
true
helpUrl
:
UrlbarProviderQuickSuggest
.
helpUrl
helpL10nId
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
displayUrl
:
"
http
:
/
/
test
.
com
/
q
=
frabbits
"
source
:
"
remote
-
settings
"
}
}
;
const
MERINO_RESPONSE
=
{
body
:
{
request_id
:
"
request_id
"
suggestions
:
[
{
full_keyword
:
"
full_keyword
"
title
:
"
title
"
url
:
"
url
"
icon
:
"
icon
"
impression_url
:
"
impression_url
"
click_url
:
"
click_url
"
block_id
:
1
advertiser
:
"
advertiser
"
is_sponsored
:
true
score
:
1
}
]
}
}
;
const
EXPECTED_MERINO_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
qsSuggestion
:
"
full_keyword
"
title
:
"
title
"
url
:
"
url
"
icon
:
"
icon
"
sponsoredImpressionUrl
:
"
impression_url
"
sponsoredClickUrl
:
"
click_url
"
sponsoredBlockId
:
1
sponsoredAdvertiser
:
"
advertiser
"
isSponsored
:
true
helpUrl
:
UrlbarProviderQuickSuggest
.
helpUrl
helpL10nId
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
displayUrl
:
"
url
"
requestId
:
"
request_id
"
source
:
"
merino
"
}
}
;
let
gMerinoResponse
;
add_task
(
async
function
init
(
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
shouldShowOnboardingDialog
"
false
)
;
let
path
=
"
/
merino
"
;
let
server
=
makeMerinoServer
(
path
)
;
let
url
=
new
URL
(
"
http
:
/
/
localhost
/
"
)
;
url
.
pathname
=
path
;
url
.
port
=
server
.
identity
.
primaryPort
;
UrlbarPrefs
.
set
(
PREF_MERINO_ENDPOINT_URL
url
.
toString
(
)
)
;
UrlbarPrefs
.
set
(
"
merino
.
timeoutMs
"
TEST_MERINO_TIMEOUT_MS
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
REMOTE_SETTINGS_DATA
)
;
Assert
.
equal
(
typeof
UrlbarQuickSuggest
.
SUGGESTION_SCORE
"
number
"
"
Sanity
check
:
UrlbarQuickSuggest
.
SUGGESTION_SCORE
is
defined
"
)
;
}
)
;
add_task
(
async
function
oneEnabled_merino
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
)
.
body
.
suggestions
[
0
]
.
score
=
UrlbarQuickSuggest
.
SUGGESTION_SCORE
/
2
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_MERINO_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
oneEnabled_remoteSettings
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
)
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
none
latencyRecorded
:
false
}
)
;
}
)
;
add_task
(
async
function
dataCollectionDisabled
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
false
)
;
setMerinoResponse
(
)
;
let
context
=
createContext
(
"
frab
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
}
)
;
}
)
;
add_task
(
async
function
higherScore
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
)
.
body
.
suggestions
[
0
]
.
score
=
2
*
UrlbarQuickSuggest
.
SUGGESTION_SCORE
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_MERINO_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
lowerScore
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
)
.
body
.
suggestions
[
0
]
.
score
=
UrlbarQuickSuggest
.
SUGGESTION_SCORE
/
2
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
sameScore
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
)
.
body
.
suggestions
[
0
]
.
score
=
UrlbarQuickSuggest
.
SUGGESTION_SCORE
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
noMerinoScore
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
let
resp
=
setMerinoResponse
(
)
;
Assert
.
equal
(
typeof
resp
.
body
.
suggestions
[
0
]
.
score
"
number
"
"
Sanity
check
:
First
suggestion
has
a
score
"
)
;
delete
resp
.
body
.
suggestions
[
0
]
.
score
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
noSuggestion_remoteSettings
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
)
;
let
context
=
createContext
(
"
this
doesn
'
t
match
remote
settings
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_MERINO_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
noSuggestion_merino
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
{
body
:
{
request_id
:
"
request_id
"
suggestions
:
[
]
}
}
)
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
bothDisabled
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
)
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
none
latencyRecorded
:
false
}
)
;
}
)
;
add_task
(
async
function
multipleMerinoSuggestions
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
{
body
:
{
request_id
:
"
request_id
"
suggestions
:
[
{
full_keyword
:
"
multipleMerinoSuggestions
0
full_keyword
"
title
:
"
multipleMerinoSuggestions
0
title
"
url
:
"
multipleMerinoSuggestions
0
url
"
icon
:
"
multipleMerinoSuggestions
0
icon
"
impression_url
:
"
multipleMerinoSuggestions
0
impression_url
"
click_url
:
"
multipleMerinoSuggestions
0
click_url
"
block_id
:
0
advertiser
:
"
multipleMerinoSuggestions
0
advertiser
"
is_sponsored
:
true
score
:
0
.
1
}
{
full_keyword
:
"
multipleMerinoSuggestions
1
full_keyword
"
title
:
"
multipleMerinoSuggestions
1
title
"
url
:
"
multipleMerinoSuggestions
1
url
"
icon
:
"
multipleMerinoSuggestions
1
icon
"
impression_url
:
"
multipleMerinoSuggestions
1
impression_url
"
click_url
:
"
multipleMerinoSuggestions
1
click_url
"
block_id
:
1
advertiser
:
"
multipleMerinoSuggestions
1
advertiser
"
is_sponsored
:
true
score
:
1
}
{
full_keyword
:
"
multipleMerinoSuggestions
2
full_keyword
"
title
:
"
multipleMerinoSuggestions
2
title
"
url
:
"
multipleMerinoSuggestions
2
url
"
icon
:
"
multipleMerinoSuggestions
2
icon
"
impression_url
:
"
multipleMerinoSuggestions
2
impression_url
"
click_url
:
"
multipleMerinoSuggestions
2
click_url
"
block_id
:
2
advertiser
:
"
multipleMerinoSuggestions
2
advertiser
"
is_sponsored
:
true
score
:
0
.
2
}
]
}
}
)
;
let
context
=
createContext
(
"
test
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
qsSuggestion
:
"
multipleMerinoSuggestions
1
full_keyword
"
title
:
"
multipleMerinoSuggestions
1
title
"
url
:
"
multipleMerinoSuggestions
1
url
"
icon
:
"
multipleMerinoSuggestions
1
icon
"
sponsoredImpressionUrl
:
"
multipleMerinoSuggestions
1
impression_url
"
sponsoredClickUrl
:
"
multipleMerinoSuggestions
1
click_url
"
sponsoredBlockId
:
1
sponsoredAdvertiser
:
"
multipleMerinoSuggestions
1
advertiser
"
isSponsored
:
true
helpUrl
:
UrlbarProviderQuickSuggest
.
helpUrl
helpL10nId
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
displayUrl
:
"
multipleMerinoSuggestions
1
url
"
requestId
:
"
request_id
"
source
:
"
merino
"
}
}
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
unexpectedResponseProperties
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
let
resp
=
setMerinoResponse
(
)
;
resp
.
body
.
unexpectedString
=
"
some
value
"
;
resp
.
body
.
unexpectedArray
=
[
"
a
"
"
b
"
"
c
"
]
;
resp
.
body
.
unexpectedObject
=
{
foo
:
"
bar
"
}
;
let
context
=
createContext
(
"
test
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_MERINO_RESULT
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
unexpectedResponseBody
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
let
context
;
let
contextArgs
=
[
"
test
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
]
;
setMerinoResponse
(
{
body
:
{
}
}
)
;
context
=
createContext
(
.
.
.
contextArgs
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
setMerinoResponse
(
{
body
:
{
bogus
:
[
]
}
}
)
;
context
=
createContext
(
.
.
.
contextArgs
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
setMerinoResponse
(
{
body
:
{
suggestions
:
{
}
}
}
)
;
context
=
createContext
(
.
.
.
contextArgs
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
setMerinoResponse
(
{
body
:
{
suggestions
:
[
]
}
}
)
;
context
=
createContext
(
.
.
.
contextArgs
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
setMerinoResponse
(
{
body
:
"
"
}
)
;
context
=
createContext
(
.
.
.
contextArgs
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
setMerinoResponse
(
{
contentType
:
"
text
/
html
"
body
:
"
bogus
"
}
)
;
context
=
createContext
(
.
.
.
contextArgs
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
networkError_merinoOnly
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
await
doNetworkErrorTest
(
[
]
)
;
}
)
;
add_task
(
async
function
networkError_withRemoteSettings
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
await
doNetworkErrorTest
(
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
)
;
}
)
;
async
function
doNetworkErrorTest
(
expectedResults
)
{
let
originalURL
=
UrlbarPrefs
.
get
(
PREF_MERINO_ENDPOINT_URL
)
;
UrlbarPrefs
.
set
(
PREF_MERINO_ENDPOINT_URL
"
http
:
/
/
localhost
/
test_quicksuggest_merino
"
)
;
UrlbarPrefs
.
set
(
"
merino
.
timeoutMs
"
10000
)
;
let
histograms
=
getAndClearHistograms
(
)
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
expectedResults
}
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
_merinoTimeoutTimer
"
_merinoTimeoutTimer
does
not
exist
after
search
finished
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
UrlbarProviderQuickSuggest
.
_merinoFetchController
"
Waiting
for
fetch
to
finish
"
100
100
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
network_error
latencyRecorded
:
false
}
)
;
UrlbarPrefs
.
set
(
PREF_MERINO_ENDPOINT_URL
originalURL
)
;
UrlbarPrefs
.
set
(
"
merino
.
timeoutMs
"
TEST_MERINO_TIMEOUT_MS
)
;
}
add_task
(
async
function
httpError_merinoOnly
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
await
doHTTPErrorTest
(
[
]
)
;
}
)
;
add_task
(
async
function
httpError_withRemoteSettings
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
await
doHTTPErrorTest
(
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
)
;
}
)
;
async
function
doHTTPErrorTest
(
expectedResults
)
{
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
{
status
:
500
}
)
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
expectedResults
}
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
http_error
latencyRecorded
:
true
}
)
;
}
add_task
(
async
function
timeout_merinoOnly
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
setMerinoResponse
(
)
;
await
doSimpleTimeoutTest
(
[
]
)
;
}
)
;
add_task
(
async
function
timeout_withRemoteSettings
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
setMerinoResponse
(
)
;
await
doSimpleTimeoutTest
(
[
EXPECTED_REMOTE_SETTINGS_RESULT
]
)
;
}
)
;
add_task
(
async
function
timeout_followedByHTTPError
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
resp
=
setMerinoResponse
(
)
;
resp
.
status
=
500
;
delete
resp
.
body
;
await
doSimpleTimeoutTest
(
[
]
)
;
}
)
;
async
function
doSimpleTimeoutTest
(
expectedResults
)
{
let
histograms
=
getAndClearHistograms
(
)
;
gMerinoResponse
.
delay
=
2
*
UrlbarPrefs
.
get
(
"
merinoTimeoutMs
"
)
;
let
context
=
createContext
(
REMOTE_SETTINGS_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
expectedResults
}
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
_merinoTimeoutTimer
"
_merinoTimeoutTimer
does
not
exist
after
search
finished
"
)
;
Assert
.
ok
(
UrlbarProviderQuickSuggest
.
_merinoFetchController
"
_merinoFetchController
still
exists
after
search
finished
"
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
_merinoFetchController
.
signal
.
aborted
"
_merinoFetchController
is
not
aborted
"
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
timeout
latencyRecorded
:
false
latencyStopwatchRunning
:
true
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
UrlbarProviderQuickSuggest
.
_merinoFetchController
"
Waiting
for
fetch
to
finish
"
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
none
latencyRecorded
:
true
}
)
;
}
add_task
(
async
function
newFetchAbortsPrevious
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
let
resp
=
setMerinoResponse
(
)
;
resp
.
delay
=
10000
*
UrlbarPrefs
.
get
(
"
merinoTimeoutMs
"
)
;
let
context
=
createContext
(
"
first
search
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
_merinoTimeoutTimer
"
_merinoTimeoutTimer
does
not
exist
after
first
search
finished
"
)
;
Assert
.
ok
(
UrlbarProviderQuickSuggest
.
_merinoFetchController
"
_merinoFetchController
still
exists
after
first
search
finished
"
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
_merinoFetchController
.
signal
.
aborted
"
_merinoFetchController
is
not
aborted
"
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
timeout
latencyRecorded
:
false
latencyStopwatchRunning
:
true
}
)
;
delete
resp
.
delay
;
context
=
createContext
(
"
second
search
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_MERINO_RESULT
]
}
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
_merinoFetchController
"
_merinoFetchController
does
not
exist
after
second
search
finished
"
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
_merinoTimeoutTimer
"
_merinoTimeoutTimer
does
not
exist
after
second
search
finished
"
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
success
latencyRecorded
:
true
}
)
;
}
)
;
add_task
(
async
function
cancelDoesNotAbortFetch
(
)
{
UrlbarPrefs
.
set
(
PREF_MERINO_ENABLED
true
)
;
UrlbarPrefs
.
set
(
PREF_REMOTE_SETTINGS_ENABLED
false
)
;
UrlbarPrefs
.
set
(
PREF_DATA_COLLECTION_ENABLED
true
)
;
let
histograms
=
getAndClearHistograms
(
)
;
setMerinoResponse
(
)
.
delay
=
1000
;
let
context
=
createContext
(
"
test
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
{
input
:
{
isPrivate
:
context
.
isPrivate
onFirstResult
(
)
{
return
false
;
}
window
:
{
location
:
{
href
:
AppConstants
.
BROWSER_CHROME_URL
}
}
}
}
)
;
let
searchPromise
=
controller
.
startQuery
(
context
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
UrlbarProviderQuickSuggest
.
_merinoFetchController
"
Waiting
for
_merinoFetchController
"
)
;
controller
.
cancelQuery
(
)
;
await
searchPromise
;
Assert
.
ok
(
UrlbarProviderQuickSuggest
.
_merinoFetchController
"
_merinoFetchController
still
exists
after
search
canceled
"
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
_merinoFetchController
.
signal
.
aborted
"
_merinoFetchController
is
not
aborted
"
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
none
latencyRecorded
:
false
latencyStopwatchRunning
:
true
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
UrlbarProviderQuickSuggest
.
_merinoFetchController
"
Waiting
for
provider
to
null
out
_merinoFetchController
"
)
;
assertAndClearHistograms
(
{
histograms
context
response
:
FETCH_RESPONSE
.
none
latencyRecorded
:
true
}
)
;
}
)
;
function
makeMerinoServer
(
endpointPath
)
{
let
server
=
makeTestServer
(
)
;
server
.
registerPathHandler
(
endpointPath
async
(
req
resp
)
=
>
{
resp
.
processAsync
(
)
;
if
(
typeof
gMerinoResponse
.
delay
=
=
"
number
"
)
{
await
new
Promise
(
resolve
=
>
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
resolve
gMerinoResponse
.
delay
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
)
;
}
if
(
typeof
gMerinoResponse
.
status
=
=
"
number
"
)
{
resp
.
setStatusLine
(
"
"
gMerinoResponse
.
status
gMerinoResponse
.
status
)
;
}
resp
.
setHeader
(
"
Content
-
Type
"
gMerinoResponse
.
contentType
false
)
;
if
(
typeof
gMerinoResponse
.
body
=
=
"
string
"
)
{
resp
.
write
(
gMerinoResponse
.
body
)
;
}
else
if
(
gMerinoResponse
.
body
)
{
resp
.
write
(
JSON
.
stringify
(
gMerinoResponse
.
body
)
)
;
}
resp
.
finish
(
)
;
}
)
;
return
server
;
}
function
setMerinoResponse
(
resp
=
{
.
.
.
MERINO_RESPONSE
}
)
{
if
(
!
resp
.
contentType
)
{
resp
.
contentType
=
"
application
/
json
"
;
}
gMerinoResponse
=
resp
;
info
(
"
Set
Merino
response
:
"
+
JSON
.
stringify
(
resp
)
)
;
return
resp
;
}
function
getAndClearHistograms
(
)
{
return
{
latency
:
TelemetryTestUtils
.
getAndClearHistogram
(
TELEMETRY_MERINO_LATENCY
)
response
:
TelemetryTestUtils
.
getAndClearHistogram
(
TELEMETRY_MERINO_RESPONSE
)
}
;
}
function
assertAndClearHistograms
(
{
histograms
response
latencyRecorded
context
latencyStopwatchRunning
=
false
}
)
{
Assert
.
equal
(
typeof
response
"
number
"
"
Sanity
check
:
response
is
defined
"
)
;
if
(
response
!
=
FETCH_RESPONSE
.
none
)
{
TelemetryTestUtils
.
assertHistogram
(
histograms
.
response
response
1
)
;
}
else
{
Assert
.
strictEqual
(
histograms
.
response
.
snapshot
(
)
.
sum
0
"
Response
histogram
not
updated
"
)
;
}
if
(
latencyRecorded
)
{
Assert
.
deepEqual
(
Object
.
values
(
histograms
.
latency
.
snapshot
(
)
.
values
)
.
filter
(
v
=
>
v
>
0
)
[
1
]
"
Latency
histogram
updated
"
)
;
}
else
{
Assert
.
strictEqual
(
histograms
.
latency
.
snapshot
(
)
.
sum
0
"
Latency
histogram
not
updated
"
)
;
}
Assert
.
equal
(
TelemetryStopwatch
.
running
(
TELEMETRY_MERINO_LATENCY
context
)
latencyStopwatchRunning
"
Latency
stopwatch
running
as
expected
"
)
;
for
(
let
histogram
of
Object
.
values
(
histograms
)
)
{
histogram
.
clear
(
)
;
}
}
