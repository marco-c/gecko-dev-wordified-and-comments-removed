"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
QuickSuggestTestUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CONTEXTUAL_SERVICES_PING_TYPES
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
PartnerLinkAttribution
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
jsm
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
UrlbarQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarQuickSuggest
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
UrlbarTestUtils
"
(
)
=
>
{
const
{
UrlbarTestUtils
:
module
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
jsm
"
)
;
module
.
init
(
QuickSuggestTestUtils
.
_testScope
)
;
return
module
;
}
)
;
const
LEARN_MORE_URL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
firefox
-
suggest
"
;
const
SCALARS
=
{
IMPRESSION
:
"
contextual
.
services
.
quicksuggest
.
impression
"
CLICK
:
"
contextual
.
services
.
quicksuggest
.
click
"
HELP
:
"
contextual
.
services
.
quicksuggest
.
help
"
}
;
const
TELEMETRY_EVENT_CATEGORY
=
"
contextservices
.
quicksuggest
"
;
const
TEST_SCOPE_PROPERTIES
=
[
"
Assert
"
"
EventUtils
"
"
info
"
"
registerCleanupFunction
"
]
;
class
TestUtils
{
get
LEARN_MORE_URL
(
)
{
return
LEARN_MORE_URL
;
}
get
SCALARS
(
)
{
return
SCALARS
;
}
get
TELEMETRY_EVENT_CATEGORY
(
)
{
return
TELEMETRY_EVENT_CATEGORY
;
}
init
(
scope
)
{
if
(
!
scope
)
{
throw
new
Error
(
"
QuickSuggestTestUtils
.
init
(
)
must
be
called
with
a
scope
"
)
;
}
this
.
_testScope
=
scope
;
for
(
let
p
of
TEST_SCOPE_PROPERTIES
)
{
this
[
p
]
=
scope
[
p
]
;
}
Services
.
telemetry
.
clearScalars
(
)
;
}
uninit
(
)
{
this
.
_testScope
=
null
;
for
(
let
p
of
TEST_SCOPE_PROPERTIES
)
{
this
[
p
]
=
null
;
}
Services
.
telemetry
.
clearScalars
(
)
;
}
async
ensureQuickSuggestInit
(
results
=
null
)
{
this
.
info
?
.
(
"
ensureQuickSuggestInit
awaiting
UrlbarQuickSuggest
.
readyPromise
"
)
;
await
UrlbarQuickSuggest
.
readyPromise
;
this
.
info
?
.
(
"
ensureQuickSuggestInit
done
awaiting
UrlbarQuickSuggest
.
readyPromise
"
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
UrlbarQuickSuggest
"
_queueSettingsSync
"
)
;
let
cleanup
=
(
)
=
>
sandbox
.
restore
(
)
;
this
.
registerCleanupFunction
?
.
(
cleanup
)
;
if
(
results
)
{
UrlbarQuickSuggest
.
_addResults
(
results
)
;
}
return
cleanup
;
}
async
assertIsQuickSuggest
(
{
url
window
index
=
-
1
isSponsored
=
true
}
=
{
}
)
{
if
(
index
<
0
)
{
index
=
UrlbarTestUtils
.
getResultCount
(
window
)
-
1
;
this
.
Assert
.
greater
(
index
-
1
"
Sanity
check
:
Result
count
should
be
>
0
"
)
;
}
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
this
.
Assert
.
equal
(
details
.
type
UrlbarUtils
.
RESULT_TYPE
.
URL
)
;
this
.
Assert
.
equal
(
details
.
isSponsored
isSponsored
"
Result
isSponsored
"
)
;
this
.
Assert
.
equal
(
details
.
url
url
"
Result
URL
"
)
;
this
.
Assert
.
equal
(
details
.
displayed
.
action
isSponsored
?
"
Sponsored
"
:
"
"
"
Result
action
text
"
)
;
let
helpButton
=
details
.
element
.
row
.
_elements
.
get
(
"
helpButton
"
)
;
this
.
Assert
.
ok
(
helpButton
"
The
help
button
should
be
present
"
)
;
this
.
Assert
.
equal
(
details
.
result
.
payload
.
helpUrl
LEARN_MORE_URL
"
Result
helpURL
"
)
;
return
details
;
}
async
assertIsNotQuickSuggest
(
window
index
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
this
.
Assert
.
notEqual
(
details
.
result
.
providerName
"
UrlbarProviderQuickSuggest
"
Result
at
index
{
index
}
is
not
provided
by
UrlbarProviderQuickSuggest
)
;
}
async
assertNoQuickSuggestResults
(
window
)
{
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
await
this
.
assertIsNotQuickSuggest
(
window
i
)
;
}
}
assertScalars
(
expectedIndexesByScalarName
)
{
let
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
true
true
)
;
for
(
let
scalarName
of
Object
.
values
(
SCALARS
)
)
{
if
(
scalarName
in
expectedIndexesByScalarName
)
{
TelemetryTestUtils
.
assertKeyedScalar
(
scalars
scalarName
expectedIndexesByScalarName
[
scalarName
]
1
)
;
}
else
{
this
.
Assert
.
ok
(
!
(
scalarName
in
scalars
)
"
Scalar
should
not
be
present
:
"
+
scalarName
)
;
}
}
}
createTelemetryPingSpy
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
spy
=
sandbox
.
spy
(
PartnerLinkAttribution
.
_pingCentre
"
sendStructuredIngestionPing
"
)
;
let
spyCleanup
=
(
)
=
>
sandbox
.
restore
(
)
;
this
.
registerCleanupFunction
?
.
(
spyCleanup
)
;
return
{
sandbox
spy
spyCleanup
}
;
}
assertImpressionPing
(
{
index
search_query
spy
advertiser
=
"
test
-
advertiser
"
block_id
=
1
matched_keywords
=
search_query
reporting_url
=
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
"
scenario
=
"
offline
"
}
)
{
this
.
Assert
.
ok
(
spy
.
calledOnce
"
Should
send
a
custom
impression
ping
"
)
;
let
[
payload
endpoint
]
=
spy
.
firstCall
.
args
;
this
.
Assert
.
ok
(
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_IMPRESSION
)
"
Should
set
the
endpoint
for
QuickSuggest
impression
"
)
;
let
expectedPayload
=
{
advertiser
block_id
matched_keywords
:
scenario
=
=
"
online
"
?
matched_keywords
:
undefined
position
:
index
+
1
reporting_url
scenario
search_query
:
scenario
=
=
"
online
"
?
search_query
:
undefined
}
;
let
actualPayload
=
{
}
;
for
(
let
key
of
Object
.
keys
(
expectedPayload
)
)
{
actualPayload
[
key
]
=
payload
[
key
]
;
}
this
.
Assert
.
deepEqual
(
actualPayload
expectedPayload
"
Payload
is
correct
"
)
;
this
.
Assert
.
ok
(
!
!
payload
.
context_id
"
Should
set
the
context_id
"
)
;
}
assertNoImpressionPing
(
spy
)
{
this
.
Assert
.
ok
(
spy
.
notCalled
"
Should
not
send
a
custom
impression
"
)
;
}
assertClickPing
(
{
index
spy
advertiser
=
"
test
-
advertiser
"
block_id
=
1
reporting_url
=
"
http
:
/
/
click
.
reporting
.
test
.
com
/
"
scenario
=
"
offline
"
}
)
{
this
.
Assert
.
ok
(
spy
.
calledTwice
"
Should
send
a
custom
impression
ping
"
)
;
let
[
payload
endpoint
]
=
spy
.
secondCall
.
args
;
this
.
Assert
.
ok
(
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_SELECTION
)
"
Should
set
the
endpoint
for
QuickSuggest
click
"
)
;
let
expectedPayload
=
{
advertiser
block_id
position
:
index
+
1
reporting_url
scenario
}
;
let
actualPayload
=
{
}
;
for
(
let
key
of
Object
.
keys
(
expectedPayload
)
)
{
actualPayload
[
key
]
=
payload
[
key
]
;
}
this
.
Assert
.
deepEqual
(
actualPayload
expectedPayload
"
Payload
is
correct
"
)
;
this
.
Assert
.
ok
(
!
!
payload
.
context_id
"
Should
set
the
context_id
"
)
;
}
assertNoClickPing
(
spy
)
{
this
.
Assert
.
ok
(
spy
.
calledOnce
"
Should
not
send
a
custom
impression
"
)
;
}
}
var
QuickSuggestTestUtils
=
new
TestUtils
(
)
;
