"
use
strict
"
;
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
scotchBonnet
.
enableOverride
"
false
]
]
}
)
;
}
)
;
add_task
(
async
function
viewUpdateAppendHidden
(
)
{
let
provider
=
new
DelayingTestProvider
(
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
registerCleanupFunction
(
(
)
=
>
{
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
}
)
;
let
baseQuery
=
"
firefox
cache
"
;
let
queries
=
[
baseQuery
.
substring
(
0
baseQuery
.
length
-
1
)
baseQuery
]
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
queryStrings
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResults
;
i
+
+
)
{
queryStrings
.
push
(
{
baseQuery
}
{
i
}
)
;
}
provider
.
results
=
queryStrings
.
map
(
suggestion
=
>
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
{
query
:
queries
[
0
]
suggestion
lowerCaseSuggestion
:
suggestion
.
toLocaleLowerCase
(
)
engine
:
Services
.
search
.
defaultEngine
.
name
}
)
)
;
provider
.
finishQueryPromise
=
Promise
.
resolve
(
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
queries
[
0
]
}
)
;
let
tipResult
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
1
)
;
Assert
.
equal
(
tipResult
.
type
UrlbarUtils
.
RESULT_TYPE
.
TIP
"
Result
at
index
1
is
a
tip
"
)
;
let
tipResultSpan
=
UrlbarUtils
.
getSpanForResult
(
tipResult
.
element
.
row
.
result
)
;
Assert
.
greater
(
tipResultSpan
1
"
Sanity
check
:
Tip
has
large
result
span
"
)
;
let
expectedRowCount
=
maxResults
-
tipResultSpan
+
1
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
expectedRowCount
"
Sanity
check
:
Initial
row
count
takes
tip
result
span
into
account
"
)
;
provider
.
results
=
queryStrings
.
map
(
title
=
>
{
let
url
=
"
http
:
/
/
example
.
com
/
"
+
title
;
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
{
title
url
displayUrl
:
"
http
:
/
/
example
.
com
/
"
+
title
}
)
;
}
)
;
let
newExpectedRowCount
=
2
*
expectedRowCount
-
2
;
let
mutationPromise
=
new
Promise
(
resolve
=
>
{
let
observer
=
new
MutationObserver
(
(
)
=
>
{
let
childCount
=
UrlbarTestUtils
.
getResultCount
(
window
)
;
info
(
Rows
mutation
observer
called
childCount
now
{
childCount
}
)
;
if
(
newExpectedRowCount
<
=
childCount
)
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
}
)
;
observer
.
observe
(
UrlbarTestUtils
.
getResultsContainer
(
window
)
{
childList
:
true
}
)
;
}
)
;
let
resolveQuery
;
provider
.
finishQueryPromise
=
new
Promise
(
resolve
=
>
(
resolveQuery
=
resolve
)
)
;
let
queryPromise
=
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
queries
[
1
]
}
)
;
await
mutationPromise
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
newExpectedRowCount
"
New
expected
row
count
"
)
;
let
rows
=
UrlbarTestUtils
.
getResultsContainer
(
window
)
.
children
;
for
(
let
i
=
2
;
i
<
expectedRowCount
;
i
+
+
)
{
let
row
=
rows
[
i
]
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
Result
at
index
{
i
}
is
a
search
result
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
row
)
Search
result
at
index
{
i
}
is
visible
)
;
Assert
.
equal
(
row
.
getAttribute
(
"
stale
"
)
"
true
"
Search
result
at
index
{
i
}
is
stale
)
;
}
for
(
let
i
=
expectedRowCount
;
i
<
newExpectedRowCount
;
i
+
+
)
{
let
row
=
rows
[
i
]
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
URL
Result
at
index
{
i
}
is
a
URL
result
)
;
Assert
.
ok
(
!
BrowserTestUtils
.
isVisible
(
row
)
URL
result
at
index
{
i
}
is
hidden
)
;
Assert
.
ok
(
!
row
.
hasAttribute
(
"
stale
"
)
URL
result
at
index
{
i
}
is
not
stale
)
;
}
resolveQuery
(
)
;
await
queryPromise
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
gURLBar
.
handleRevert
(
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
}
)
;
