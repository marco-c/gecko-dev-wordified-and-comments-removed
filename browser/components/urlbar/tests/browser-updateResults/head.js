"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarView
:
"
resource
:
/
/
/
modules
/
UrlbarView
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
UrlbarTestUtils
"
(
)
=
>
{
const
{
UrlbarTestUtils
:
module
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
jsm
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
add_setup
(
async
function
headInit
(
)
{
await
PlacesUtils
.
history
.
clear
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
ui
.
popup
.
disable_autohide
"
true
]
[
"
browser
.
urlbar
.
maxRichResults
"
10
]
]
}
)
;
let
originalRemoveStaleRowsTimeout
=
UrlbarView
.
removeStaleRowsTimeout
;
UrlbarView
.
removeStaleRowsTimeout
=
30000
;
registerCleanupFunction
(
(
)
=
>
{
UrlbarView
.
removeStaleRowsTimeout
=
originalRemoveStaleRowsTimeout
;
}
)
;
}
)
;
class
DelayingTestProvider
extends
UrlbarTestUtils
.
TestProvider
{
finishQueryPromise
=
null
;
async
startQuery
(
context
addCallback
)
{
for
(
let
result
of
this
.
_results
)
{
addCallback
(
this
result
)
;
}
await
this
.
finishQueryPromise
;
}
}
function
makeSuggestedIndexResult
(
suggestedIndex
resultSpan
=
1
)
{
return
Object
.
assign
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
{
url
:
"
http
:
/
/
example
.
com
/
si
"
displayUrl
:
"
http
:
/
/
example
.
com
/
si
"
title
:
"
suggested
index
"
}
)
{
suggestedIndex
resultSpan
}
)
;
}
function
makeProviderResults
(
{
count
=
0
type
=
undefined
specs
=
[
]
}
)
{
if
(
count
)
{
specs
.
push
(
{
count
type
}
)
;
}
let
query
=
"
test
"
;
let
results
=
[
Object
.
assign
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
{
query
engine
:
Services
.
search
.
defaultEngine
.
name
}
)
{
heuristic
:
true
}
)
]
;
for
(
let
{
count
:
specCount
type
:
specType
}
of
specs
)
{
for
(
let
i
=
0
;
i
<
specCount
;
i
+
+
)
{
let
str
=
{
query
}
{
results
.
length
}
;
switch
(
specType
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
results
.
push
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
{
query
suggestion
:
str
lowerCaseSuggestion
:
str
.
toLowerCase
(
)
engine
:
Services
.
search
.
defaultEngine
.
name
}
)
)
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
results
.
push
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
{
url
:
"
http
:
/
/
example
.
com
/
"
+
i
displayUrl
:
"
http
:
/
/
example
.
com
/
"
+
i
title
:
str
}
)
)
;
break
;
default
:
throw
new
Error
(
Unsupported
makeProviderResults
type
:
{
specType
}
)
;
}
}
}
return
results
;
}
let
gSuggestedIndexTaskIndex
=
0
;
function
add_suggestedIndex_task
(
options
)
{
if
(
!
gSuggestedIndexTaskIndex
)
{
initSuggestedIndexTest
(
)
;
}
let
testIndex
=
gSuggestedIndexTaskIndex
+
+
;
let
testName
=
"
test_
"
+
testIndex
;
let
testDesc
=
JSON
.
stringify
(
options
)
;
let
func
=
async
(
)
=
>
{
info
(
Running
task
at
index
{
testIndex
}
:
{
testDesc
}
)
;
await
doSuggestedIndexTest
(
options
)
;
}
;
Object
.
defineProperty
(
func
"
name
"
{
value
:
testName
}
)
;
add_task
(
func
)
;
}
function
initSuggestedIndexTest
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
requestLongerTimeout
(
3
)
;
}
registerCleanupFunction
(
(
)
=
>
{
gSuggestedIndexTaskIndex
=
0
;
}
)
;
}
async
function
doSuggestedIndexTest
(
{
search1
search2
duringUpdate
}
)
{
let
provider
=
new
DelayingTestProvider
(
{
priority
:
Infinity
}
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
registerCleanupFunction
(
(
)
=
>
{
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
}
)
;
provider
.
_results
=
makeProviderResults
(
{
specs
:
search1
.
other
count
:
search1
.
otherCount
type
:
search1
.
otherType
}
)
;
if
(
!
search1
.
suggestedIndexes
)
{
search1
.
suggestedIndexes
=
[
]
;
}
search1
.
suggestedIndexes
=
search1
.
suggestedIndexes
.
map
(
value
=
>
typeof
value
=
=
"
number
"
?
[
value
1
]
:
value
)
;
if
(
typeof
search1
.
suggestedIndex
=
=
"
number
"
)
{
search1
.
suggestedIndexes
.
push
(
[
search1
.
suggestedIndex
search1
.
resultSpan
|
|
1
]
)
;
}
for
(
let
[
suggestedIndex
resultSpan
]
of
search1
.
suggestedIndexes
)
{
provider
.
_results
.
push
(
makeSuggestedIndexResult
(
suggestedIndex
resultSpan
)
)
;
}
provider
.
finishQueryPromise
=
Promise
.
resolve
(
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
search1
.
viewCount
"
Row
count
after
first
search
"
)
;
for
(
let
[
suggestedIndex
resultSpan
]
of
search1
.
suggestedIndexes
)
{
let
index
=
suggestedIndex
>
=
0
?
Math
.
min
(
search1
.
viewCount
-
1
suggestedIndex
)
:
Math
.
max
(
0
search1
.
viewCount
+
suggestedIndex
)
;
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
Assert
.
equal
(
result
.
element
.
row
.
result
.
suggestedIndex
suggestedIndex
"
suggestedIndex
after
first
search
"
)
;
Assert
.
equal
(
UrlbarUtils
.
getSpanForResult
(
result
.
element
.
row
.
result
)
resultSpan
"
resultSpan
after
first
search
"
)
;
}
provider
.
_results
=
makeProviderResults
(
{
specs
:
search2
.
other
count
:
search2
.
otherCount
type
:
search2
.
otherType
}
)
;
if
(
!
search2
.
suggestedIndexes
)
{
search2
.
suggestedIndexes
=
[
]
;
}
search2
.
suggestedIndexes
=
search2
.
suggestedIndexes
.
map
(
value
=
>
typeof
value
=
=
"
number
"
?
[
value
1
]
:
value
)
;
if
(
typeof
search2
.
suggestedIndex
=
=
"
number
"
)
{
search2
.
suggestedIndexes
.
push
(
[
search2
.
suggestedIndex
search2
.
resultSpan
|
|
1
]
)
;
}
for
(
let
[
suggestedIndex
resultSpan
]
of
search2
.
suggestedIndexes
)
{
provider
.
_results
.
push
(
makeSuggestedIndexResult
(
suggestedIndex
resultSpan
)
)
;
}
let
rowCountDuringUpdate
=
duringUpdate
.
reduce
(
(
count
rowState
)
=
>
count
+
rowState
.
count
0
)
;
let
mutationPromise
=
new
Promise
(
resolve
=
>
{
let
lastRowState
=
duringUpdate
[
duringUpdate
.
length
-
1
]
;
let
observer
=
new
MutationObserver
(
mutations
=
>
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
)
;
if
(
lastRowState
.
stale
)
{
let
{
children
}
=
gURLBar
.
view
.
_rows
;
observer
.
observe
(
children
[
children
.
length
-
1
]
{
attributes
:
true
}
)
;
}
else
if
(
search1
.
viewCount
=
=
rowCountDuringUpdate
)
{
observer
.
observe
(
gURLBar
.
view
.
_rows
{
subtree
:
true
attributes
:
true
characterData
:
true
}
)
;
}
else
{
observer
.
observe
(
gURLBar
.
view
.
_rows
{
childList
:
true
}
)
;
}
}
)
;
let
resolveQuery
;
provider
.
finishQueryPromise
=
new
Promise
(
resolve
=
>
(
resolveQuery
=
resolve
)
)
;
let
queryPromise
=
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
}
)
;
await
mutationPromise
;
Assert
.
equal
(
gURLBar
.
view
.
_rows
.
children
.
length
rowCountDuringUpdate
"
Row
count
during
update
"
)
;
let
rowIndex
=
0
;
for
(
let
rowState
of
duringUpdate
)
{
for
(
let
i
=
0
;
i
<
rowState
.
count
;
i
+
+
)
{
let
row
=
gURLBar
.
view
.
_rows
.
children
[
rowIndex
]
;
if
(
"
type
"
in
rowState
)
{
Assert
.
equal
(
row
.
result
.
type
rowState
.
type
Type
at
index
{
rowIndex
}
during
update
)
;
}
if
(
"
suggestedIndex
"
in
rowState
)
{
Assert
.
ok
(
row
.
result
.
hasSuggestedIndex
Row
at
index
{
rowIndex
}
has
suggestedIndex
during
update
)
;
Assert
.
equal
(
row
.
result
.
suggestedIndex
rowState
.
suggestedIndex
suggestedIndex
at
index
{
rowIndex
}
during
update
)
;
}
else
{
Assert
.
ok
(
!
row
.
result
.
hasSuggestedIndex
Row
at
index
{
rowIndex
}
does
not
have
suggestedIndex
during
update
)
;
}
Assert
.
equal
(
UrlbarUtils
.
getSpanForResult
(
row
.
result
)
rowState
.
resultSpan
|
|
1
resultSpan
at
index
{
rowIndex
}
during
update
)
;
if
(
rowState
.
stale
)
{
Assert
.
equal
(
row
.
getAttribute
(
"
stale
"
)
"
true
"
Row
at
index
{
rowIndex
}
is
stale
during
update
)
;
}
else
{
Assert
.
ok
(
!
row
.
hasAttribute
(
"
stale
"
)
Row
at
index
{
rowIndex
}
is
not
stale
during
update
)
;
}
Assert
.
equal
(
BrowserTestUtils
.
is_visible
(
row
)
!
rowState
.
hidden
Visible
at
index
{
rowIndex
}
during
update
)
;
rowIndex
+
+
;
}
}
resolveQuery
(
)
;
await
queryPromise
;
let
suggestedIndexesByRealIndex
=
new
Map
(
)
;
for
(
let
[
suggestedIndex
resultSpan
]
of
search2
.
suggestedIndexes
)
{
let
realIndex
=
suggestedIndex
>
=
0
?
Math
.
min
(
suggestedIndex
search2
.
viewCount
-
1
)
:
Math
.
max
(
0
search2
.
viewCount
+
suggestedIndex
)
;
suggestedIndexesByRealIndex
.
set
(
realIndex
[
suggestedIndex
resultSpan
]
)
;
}
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
search2
.
viewCount
"
Row
count
after
update
"
)
;
for
(
let
i
=
0
;
i
<
search2
.
viewCount
;
i
+
+
)
{
let
result
=
gURLBar
.
view
.
_rows
.
children
[
i
]
.
result
;
let
tuple
=
suggestedIndexesByRealIndex
.
get
(
i
)
;
if
(
tuple
)
{
let
[
suggestedIndex
resultSpan
]
=
tuple
;
Assert
.
ok
(
result
.
hasSuggestedIndex
Row
at
index
{
i
}
has
suggestedIndex
after
update
)
;
Assert
.
equal
(
result
.
suggestedIndex
suggestedIndex
suggestedIndex
at
index
{
i
}
after
update
)
;
Assert
.
equal
(
UrlbarUtils
.
getSpanForResult
(
result
)
resultSpan
resultSpan
at
index
{
i
}
after
update
)
;
}
else
{
Assert
.
ok
(
!
result
.
hasSuggestedIndex
Row
at
index
{
i
}
does
not
have
suggestedIndex
after
update
)
;
}
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
gURLBar
.
handleRevert
(
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
}
