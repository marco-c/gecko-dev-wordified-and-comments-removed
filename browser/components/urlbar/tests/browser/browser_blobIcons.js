"
use
strict
"
;
const
TEST_ICON_BLOB
=
new
Blob
(
[
new
Uint8Array
(
[
5
11
2013
]
)
]
)
;
add_task
(
async
function
test
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
registerCleanupFunction
(
(
)
=
>
sandbox
.
restore
(
)
)
;
let
spies
=
[
"
createObjectURL
"
"
revokeObjectURL
"
]
.
reduce
(
(
memo
name
)
=
>
{
memo
[
name
]
=
sandbox
.
spy
(
Cu
.
getGlobalForObject
(
gURLBar
.
view
)
.
URL
name
)
;
return
memo
;
}
{
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
}
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
checkCallCounts
(
spies
null
{
createObjectURL
:
0
}
)
;
let
provider
=
new
UrlbarTestUtils
.
TestProvider
(
{
results
:
[
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
payload
:
{
url
:
"
https
:
/
/
example
.
com
/
"
iconBlob
:
TEST_ICON_BLOB
}
}
)
]
}
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
let
blobUrl
=
await
doSearches
(
provider
spies
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
checkCallCounts
(
spies
blobUrl
{
createObjectURL
:
0
revokeObjectURL
:
1
}
)
;
resetSpies
(
spies
)
;
blobUrl
=
await
doSearches
(
provider
spies
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
checkCallCounts
(
spies
blobUrl
{
createObjectURL
:
0
revokeObjectURL
:
1
}
)
;
resetSpies
(
spies
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
}
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
checkCallCounts
(
spies
blobUrl
{
createObjectURL
:
0
revokeObjectURL
:
0
}
)
;
sandbox
.
restore
(
)
;
}
)
;
async
function
doSearches
(
provider
spies
)
{
let
previousBlobUrl
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
+
i
}
)
;
let
result
=
await
getTestResult
(
provider
)
;
Assert
.
ok
(
result
"
Test
result
should
be
present
"
)
;
Assert
.
ok
(
result
.
image
"
Row
has
an
icon
with
a
src
"
)
;
Assert
.
ok
(
result
.
image
.
startsWith
(
"
blob
:
"
)
"
Row
icon
src
is
a
blob
URL
"
)
;
if
(
i
>
0
)
{
Assert
.
equal
(
result
.
image
previousBlobUrl
"
Blob
URL
should
be
the
same
as
in
previous
searches
"
)
;
}
previousBlobUrl
=
result
.
image
;
await
checkCallCounts
(
spies
result
.
image
{
createObjectURL
:
1
revokeObjectURL
:
0
}
)
;
}
resetSpies
(
spies
)
;
return
previousBlobUrl
;
}
function
resetSpies
(
spies
)
{
for
(
let
spy
of
Object
.
values
(
spies
)
)
{
spy
.
resetHistory
(
)
;
}
}
async
function
getTestResult
(
provider
)
{
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
result
.
result
.
providerName
=
=
provider
.
name
)
{
return
result
;
}
}
return
null
;
}
async
function
checkCallCounts
(
spies
knownBlobUrl
expectedCountsByName
)
{
let
createCalls
=
[
]
;
for
(
let
call
of
spies
.
createObjectURL
.
getCalls
(
)
)
{
if
(
await
areBlobsEqual
(
call
.
args
[
0
]
TEST_ICON_BLOB
)
)
{
createCalls
.
push
(
call
)
;
}
}
Assert
.
strictEqual
(
createCalls
.
length
expectedCountsByName
.
createObjectURL
"
createObjectURL
spy
call
count
"
)
;
if
(
knownBlobUrl
)
{
let
calls
=
spies
.
revokeObjectURL
.
getCalls
(
)
.
filter
(
call
=
>
call
.
args
[
0
]
=
=
knownBlobUrl
)
;
Assert
.
strictEqual
(
calls
.
length
expectedCountsByName
.
revokeObjectURL
"
revokeObjectURL
spy
call
count
"
)
;
}
}
async
function
areBlobsEqual
(
blob1
blob2
)
{
let
buf1
=
new
Uint8Array
(
await
blob1
.
arrayBuffer
(
)
)
;
let
buf2
=
new
Uint8Array
(
await
blob2
.
arrayBuffer
(
)
)
;
return
(
buf1
.
length
=
=
buf2
.
length
&
&
buf1
.
every
(
(
element
i
)
=
>
element
=
=
buf2
[
i
]
)
)
;
}
