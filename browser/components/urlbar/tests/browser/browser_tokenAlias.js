"
use
strict
"
;
const
ALIAS
=
"
test
"
;
const
TEST_ENGINE_BASENAME
=
"
searchSuggestionEngine
.
xml
"
;
let
testEngine
;
add_task
(
async
function
init
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
update2
"
true
]
[
"
browser
.
urlbar
.
update2
.
localOneOffs
"
true
]
[
"
browser
.
urlbar
.
update2
.
oneOffsRefresh
"
true
]
]
}
)
;
let
defaultEngine
=
await
SearchTestUtils
.
promiseNewSearchEngine
(
getRootDirectory
(
gTestPath
)
+
TEST_ENGINE_BASENAME
)
;
defaultEngine
.
alias
=
"
default
"
;
let
oldDefaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
Services
.
search
.
setDefault
(
defaultEngine
)
;
testEngine
=
await
Services
.
search
.
addEngineWithDetails
(
"
Test
"
{
alias
:
ALIAS
template
:
"
http
:
/
/
example
.
com
/
?
search
=
{
searchTerms
}
"
}
)
;
registerCleanupFunction
(
async
function
(
)
{
await
Services
.
search
.
removeEngine
(
testEngine
)
;
Services
.
search
.
setDefault
(
oldDefaultEngine
)
;
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
searches
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testNoRevert
(
)
{
await
doSimpleTest
(
false
)
;
}
)
;
add_task
(
async
function
testRevert
(
)
{
await
doSimpleTest
(
true
)
;
}
)
;
async
function
doSimpleTest
(
revertBetweenSteps
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
autoFill
"
false
]
]
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
"
value
should
be
alias
substring
"
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
"
value
should
be
alias
"
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
+
"
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngine
.
name
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
+
"
foo
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngine
.
name
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
foo
"
"
value
should
be
query
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
+
"
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngine
.
name
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
"
value
should
be
alias
"
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
"
value
should
be
alias
substring
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
add_task
(
async
function
spacesBeforeAlias
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
+
ALIAS
+
"
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngine
.
name
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
charsBeforeAlias
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
not
an
alias
"
+
ALIAS
+
"
"
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
"
not
an
alias
"
+
ALIAS
+
"
"
"
value
should
be
unchanged
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
alreadyInSearchMode
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
await
UrlbarTestUtils
.
enterSearchMode
(
window
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
+
"
"
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
entry
:
"
oneoff
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
+
"
"
"
value
should
be
unchanged
"
)
;
gURLBar
.
value
=
"
"
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
spaceWhileTypingAlias
(
)
{
let
value
=
ALIAS
.
substring
(
0
ALIAS
.
length
-
1
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
selectionStart
:
value
.
length
selectionEnd
:
value
.
length
}
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
+
"
"
"
Alias
should
be
autofilled
"
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
"
"
)
;
await
searchPromise
;
Assert
.
equal
(
gURLBar
.
value
value
+
"
"
"
Alias
should
not
be
autofilled
"
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
)
;
add_task
(
async
function
aliasCase
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
TeSt
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngine
.
name
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
aliasCase_query
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
tEsT
query
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngine
.
name
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
query
"
"
value
should
be
query
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
nonHeuristicAliases
(
)
{
let
tokenEngines
=
[
]
;
for
(
let
engine
of
await
Services
.
search
.
getEngines
(
)
)
{
let
aliases
=
[
]
;
if
(
engine
.
alias
)
{
aliases
.
push
(
engine
.
alias
)
;
}
aliases
.
push
(
.
.
.
engine
.
aliases
)
;
let
tokenAliases
=
aliases
.
filter
(
a
=
>
a
.
startsWith
(
"
"
)
)
;
if
(
tokenAliases
.
length
)
{
tokenEngines
.
push
(
{
engine
tokenAliases
}
)
;
}
}
if
(
!
tokenEngines
.
length
)
{
Assert
.
ok
(
true
"
No
token
alias
engines
skipping
task
.
"
)
;
return
;
}
info
(
"
Got
token
alias
engines
:
"
+
tokenEngines
.
map
(
(
{
engine
}
)
=
>
engine
.
name
)
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
tokenEngines
.
length
-
1
)
;
for
(
let
{
tokenAliases
}
of
tokenEngines
)
{
let
alias
=
tokenAliases
[
0
]
;
let
engineName
=
(
await
UrlbarSearchUtils
.
engineForAlias
(
alias
)
)
.
name
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
let
expectedSearchMode
=
{
engineName
entry
:
"
keywordoffer
"
isPreview
:
true
}
;
if
(
UrlbarUtils
.
WEB_ENGINE_NAMES
.
has
(
engineName
)
)
{
expectedSearchMode
.
source
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
;
}
await
UrlbarTestUtils
.
assertSearchMode
(
window
expectedSearchMode
)
;
Assert
.
ok
(
!
gURLBar
.
value
"
The
Urlbar
should
be
empty
.
"
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
clickAndFillAlias
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
let
testEngineItem
;
for
(
let
i
=
0
;
!
testEngineItem
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
details
.
searchParams
&
&
details
.
searchParams
.
keyword
=
=
ALIAS
)
{
testEngineItem
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
i
)
;
}
}
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeMouseAtCenter
(
testEngineItem
{
}
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngineItem
.
result
.
payload
.
engine
entry
:
"
keywordoffer
"
}
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
enterAndFillAlias
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
let
details
;
let
index
=
0
;
for
(
;
;
index
+
+
)
{
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
if
(
details
.
searchParams
&
&
details
.
searchParams
.
keyword
=
=
ALIAS
)
{
index
+
+
;
break
;
}
}
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
repeat
:
index
}
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
details
.
searchParams
.
engine
entry
:
"
keywordoffer
"
}
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
enterAutofillsAlias
(
)
{
for
(
let
value
of
[
ALIAS
.
substring
(
0
ALIAS
.
length
-
1
)
ALIAS
]
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
selectionStart
:
value
.
length
selectionEnd
:
value
.
length
}
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngine
.
name
entry
:
"
keywordoffer
"
}
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
rightEntersSearchMode
(
)
{
for
(
let
value
of
[
ALIAS
.
substring
(
0
ALIAS
.
length
-
1
)
ALIAS
]
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
selectionStart
:
value
.
length
selectionEnd
:
value
.
length
}
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowRight
"
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngine
.
name
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
hiddenEngine
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
fireInputEvent
:
true
}
)
;
const
defaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
let
foundDefaultEngineInPopup
=
false
;
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
defaultEngine
.
name
=
=
details
.
searchParams
.
engine
)
{
foundDefaultEngineInPopup
=
true
;
break
;
}
}
Assert
.
ok
(
foundDefaultEngineInPopup
"
Default
engine
appears
in
the
popup
.
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
defaultEngine
.
hidden
=
true
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
fireInputEvent
:
true
}
)
;
foundDefaultEngineInPopup
=
false
;
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
defaultEngine
.
name
=
=
details
.
searchParams
.
engine
)
{
foundDefaultEngineInPopup
=
true
;
break
;
}
}
Assert
.
ok
(
!
foundDefaultEngineInPopup
"
Hidden
default
engine
does
not
appear
in
the
popup
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
defaultEngine
.
hidden
=
false
;
}
)
;
add_task
(
async
function
nonPrefixedKeyword
(
)
{
let
name
=
"
Custom
"
;
let
alias
=
"
customkeyword
"
;
let
engine
=
await
Services
.
search
.
addEngineWithDetails
(
name
{
alias
template
:
"
http
:
/
/
example
.
com
/
?
search
=
{
searchTerms
}
"
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
let
foundEngineInPopup
=
false
;
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
details
.
searchParams
.
engine
=
=
=
name
)
{
foundEngineInPopup
=
true
;
break
;
}
}
Assert
.
ok
(
foundEngineInPopup
"
Custom
engine
appears
in
the
popup
.
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
+
alias
}
)
;
let
keywordOfferResult
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
0
)
;
Assert
.
equal
(
keywordOfferResult
.
searchParams
.
engine
name
"
The
first
result
should
be
a
keyword
search
result
with
the
correct
engine
.
"
)
;
await
Services
.
search
.
removeEngine
(
engine
)
;
}
)
;
async
function
assertFirstResultIsAlias
(
isAlias
expectedAlias
)
{
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
0
)
;
Assert
.
equal
(
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
"
Should
have
the
correct
type
"
)
;
if
(
isAlias
)
{
Assert
.
equal
(
result
.
searchParams
.
keyword
expectedAlias
"
Payload
keyword
should
be
the
alias
"
)
;
}
else
{
Assert
.
notEqual
(
result
.
searchParams
.
keyword
expectedAlias
"
Payload
keyword
should
be
absent
or
not
the
alias
"
)
;
}
}
function
assertHighlighted
(
highlighted
expectedAlias
)
{
let
selection
=
gURLBar
.
editor
.
selectionController
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
Assert
.
ok
(
selection
)
;
if
(
!
highlighted
)
{
Assert
.
equal
(
selection
.
rangeCount
0
)
;
return
;
}
Assert
.
equal
(
selection
.
rangeCount
1
)
;
let
index
=
gURLBar
.
value
.
indexOf
(
expectedAlias
)
;
Assert
.
ok
(
index
>
=
0
gURLBar
.
value
=
"
{
gURLBar
.
value
}
"
expectedAlias
=
"
{
expectedAlias
}
"
)
;
let
range
=
selection
.
getRangeAt
(
0
)
;
Assert
.
ok
(
range
)
;
Assert
.
equal
(
range
.
startOffset
index
)
;
Assert
.
equal
(
range
.
endOffset
index
+
expectedAlias
.
length
)
;
}
