"
use
strict
"
;
const
TEST_ALIAS_ENGINE_NAME
=
"
Test
"
;
const
ALIAS
=
"
test
"
;
const
TEST_ENGINE_BASENAME
=
"
searchSuggestionEngine
.
xml
"
;
const
TEST_SPACES
=
[
"
"
"
\
u3000
"
"
\
u3000
"
"
\
u3000
"
]
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
requestLongerTimeout
(
5
)
;
}
add_setup
(
async
function
(
)
{
let
defaultEngine
=
await
SearchTestUtils
.
installOpenSearchEngine
(
{
url
:
getRootDirectory
(
gTestPath
)
+
TEST_ENGINE_BASENAME
setAsDefault
:
true
}
)
;
defaultEngine
.
alias
=
"
default
"
;
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
TEST_ALIAS_ENGINE_NAME
keyword
:
ALIAS
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
searches
"
true
]
[
"
browser
.
urlbar
.
scotchBonnet
.
enableOverride
"
false
]
]
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
maxRichResults
"
12
]
]
}
)
;
}
)
;
add_task
(
async
function
testNoRevert
(
)
{
await
doSimpleTest
(
false
)
;
}
)
;
add_task
(
async
function
testRevert
(
)
{
await
doSimpleTest
(
true
)
;
}
)
;
async
function
doSimpleTest
(
revertBetweenSteps
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
autoFill
"
false
]
]
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
"
value
should
be
alias
substring
"
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
"
value
should
be
alias
"
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
for
(
let
spaces
of
TEST_SPACES
)
{
info
(
"
Testing
:
"
+
JSON
.
stringify
(
{
spaces
:
codePoints
(
spaces
)
}
)
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
+
spaces
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
}
for
(
let
spaces
of
TEST_SPACES
)
{
info
(
"
Testing
:
"
+
JSON
.
stringify
(
{
spaces
:
codePoints
(
spaces
)
}
)
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
+
spaces
+
"
foo
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
foo
"
"
value
should
be
query
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
}
for
(
let
spaces
of
TEST_SPACES
)
{
info
(
"
Testing
:
"
+
JSON
.
stringify
(
{
spaces
:
codePoints
(
spaces
)
}
)
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
+
spaces
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
"
value
should
be
alias
"
)
;
if
(
revertBetweenSteps
)
{
gURLBar
.
handleRevert
(
)
;
gURLBar
.
blur
(
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
.
substr
(
0
ALIAS
.
length
-
1
)
"
value
should
be
alias
substring
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
add_task
(
async
function
spacesBeforeAlias
(
)
{
for
(
let
spaces
of
TEST_SPACES
)
{
info
(
"
Testing
:
"
+
JSON
.
stringify
(
{
spaces
:
codePoints
(
spaces
)
}
)
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
spaces
+
ALIAS
+
spaces
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
}
)
;
add_task
(
async
function
charsBeforeAlias
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
not
an
alias
"
+
ALIAS
+
"
"
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
Assert
.
equal
(
gURLBar
.
value
"
not
an
alias
"
+
ALIAS
+
"
"
"
value
should
be
unchanged
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
alreadyInSearchMode
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
await
UrlbarTestUtils
.
enterSearchMode
(
window
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
ALIAS
+
"
"
}
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
entry
:
"
oneoff
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
+
"
"
"
value
should
be
unchanged
"
)
;
gURLBar
.
value
=
"
"
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
spaceWhileTypingAlias
(
)
{
for
(
let
spaces
of
TEST_SPACES
)
{
if
(
spaces
.
length
!
=
1
)
{
continue
;
}
info
(
"
Testing
:
"
+
JSON
.
stringify
(
{
spaces
:
codePoints
(
spaces
)
}
)
)
;
let
value
=
ALIAS
.
substring
(
0
ALIAS
.
length
-
1
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
selectionStart
:
value
.
length
selectionEnd
:
value
.
length
}
)
;
Assert
.
equal
(
gURLBar
.
value
ALIAS
+
"
"
"
Alias
should
be
autofilled
"
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
spaces
)
;
await
searchPromise
;
Assert
.
equal
(
gURLBar
.
value
value
+
spaces
"
Alias
should
not
be
autofilled
"
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
null
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
}
)
;
add_task
(
async
function
aliasCase
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
TeSt
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
aliasCase_query
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
tEsT
query
"
}
)
;
await
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
query
"
"
value
should
be
query
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
nonHeuristicAliases
(
)
{
let
tokenEngines
=
[
]
;
for
(
let
engine
of
await
Services
.
search
.
getEngines
(
)
)
{
let
aliases
=
[
]
;
if
(
engine
.
alias
)
{
aliases
.
push
(
engine
.
alias
)
;
}
aliases
.
push
(
.
.
.
engine
.
aliases
)
;
let
tokenAliases
=
aliases
.
filter
(
a
=
>
a
.
startsWith
(
"
"
)
)
;
if
(
tokenAliases
.
length
)
{
tokenEngines
.
push
(
{
engine
tokenAliases
}
)
;
}
}
if
(
!
tokenEngines
.
length
)
{
Assert
.
ok
(
true
"
No
token
alias
engines
skipping
task
.
"
)
;
return
;
}
info
(
"
Got
token
alias
engines
:
"
+
tokenEngines
.
map
(
(
{
engine
}
)
=
>
engine
.
name
)
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
tokenEngines
.
length
-
1
)
;
for
(
let
{
tokenAliases
}
of
tokenEngines
)
{
let
alias
=
tokenAliases
[
0
]
;
let
engineName
=
(
await
UrlbarSearchUtils
.
engineForAlias
(
alias
)
)
.
name
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
let
expectedSearchMode
=
{
engineName
entry
:
"
keywordoffer
"
isPreview
:
true
}
;
if
(
Services
.
search
.
getEngineByName
(
engineName
)
.
isGeneralPurposeEngine
)
{
expectedSearchMode
.
source
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
;
}
await
UrlbarTestUtils
.
assertSearchMode
(
window
expectedSearchMode
)
;
Assert
.
ok
(
!
gURLBar
.
value
"
The
Urlbar
should
be
empty
.
"
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
clickAndFillAlias
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
let
testEngineItem
;
for
(
let
i
=
0
;
!
testEngineItem
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
details
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
RESTRICT
)
{
let
category
=
details
.
result
.
payload
.
l10nRestrictKeyword
;
let
keyword
=
{
category
.
toLowerCase
(
)
}
;
Assert
.
equal
(
details
.
displayed
.
title
{
keyword
}
-
Search
{
category
}
"
The
result
'
s
title
is
set
correctly
.
"
)
;
}
else
if
(
UrlbarPrefs
.
getScotchBonnetPref
(
"
searchRestrictKeywords
.
featureGate
"
)
)
{
Assert
.
equal
(
details
.
displayed
.
title
{
details
.
result
.
payload
.
keywords
}
-
Search
with
{
details
.
searchParams
.
engine
}
"
The
result
'
s
title
is
set
correctly
.
"
)
;
}
else
{
Assert
.
equal
(
details
.
displayed
.
title
Search
with
{
details
.
searchParams
.
engine
}
"
The
result
'
s
title
is
set
correctly
.
"
)
;
}
Assert
.
ok
(
!
details
.
action
"
The
result
should
have
no
action
text
.
"
)
;
if
(
details
.
searchParams
&
&
details
.
searchParams
.
keyword
=
=
ALIAS
)
{
testEngineItem
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
i
)
;
}
}
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeMouseAtCenter
(
testEngineItem
{
}
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngineItem
.
result
.
payload
.
engine
entry
:
"
keywordoffer
"
}
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
enterAndFillAlias
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
let
details
;
let
index
=
0
;
for
(
;
;
index
+
+
)
{
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
if
(
details
.
searchParams
&
&
details
.
searchParams
.
keyword
=
=
ALIAS
)
{
index
+
+
;
break
;
}
}
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
repeat
:
index
}
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
details
.
searchParams
.
engine
entry
:
"
keywordoffer
"
}
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
enterAutofillsAlias
(
)
{
for
(
let
value
of
[
ALIAS
.
substring
(
0
ALIAS
.
length
-
1
)
ALIAS
]
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
selectionStart
:
value
.
length
selectionEnd
:
value
.
length
}
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
keywordoffer
"
}
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
rightEntersSearchMode
(
)
{
for
(
let
value
of
[
ALIAS
.
substring
(
0
ALIAS
.
length
-
1
)
ALIAS
]
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
selectionStart
:
value
.
length
selectionEnd
:
value
.
length
}
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowRight
"
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
typed
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
rightEntersSearchMode
(
)
{
for
(
let
value
of
[
ALIAS
.
substring
(
0
ALIAS
.
length
-
1
)
ALIAS
]
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
selectionStart
:
value
.
length
selectionEnd
:
value
.
length
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
-
1
"
There
is
no
selected
result
.
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
0
"
The
first
result
is
selected
.
"
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
keywordoffer
"
isPreview
:
true
}
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
value
should
be
empty
"
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
TEST_ALIAS_ENGINE_NAME
entry
:
"
keywordoffer
"
isPreview
:
false
}
)
;
await
UrlbarTestUtils
.
exitSearchMode
(
window
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
}
)
;
add_task
(
async
function
hiddenEngine
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
fireInputEvent
:
true
}
)
;
const
defaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
let
foundDefaultEngineInPopup
=
false
;
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
details
.
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
RESTRICT
&
&
defaultEngine
.
name
=
=
details
.
searchParams
.
engine
)
{
foundDefaultEngineInPopup
=
true
;
break
;
}
}
Assert
.
ok
(
foundDefaultEngineInPopup
"
Default
engine
appears
in
the
popup
.
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
defaultEngine
.
hidden
=
true
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
fireInputEvent
:
true
}
)
;
foundDefaultEngineInPopup
=
false
;
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
details
.
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
RESTRICT
&
&
defaultEngine
.
name
=
=
details
.
searchParams
.
engine
)
{
foundDefaultEngineInPopup
=
true
;
break
;
}
}
Assert
.
ok
(
!
foundDefaultEngineInPopup
"
Hidden
default
engine
does
not
appear
in
the
popup
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
)
;
defaultEngine
.
hidden
=
false
;
}
)
;
add_task
(
async
function
nonPrefixedKeyword
(
)
{
if
(
UrlbarPrefs
.
getScotchBonnetPref
(
"
searchRestrictKeywords
.
featureGate
"
)
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
maxRichResults
"
99
]
]
}
)
;
}
let
name
=
"
Custom
"
;
let
alias
=
"
customkeyword
"
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
keyword
:
alias
}
{
skipUnload
:
true
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
let
foundEngineInPopup
=
false
;
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
details
.
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
RESTRICT
&
&
details
.
searchParams
.
engine
=
=
=
name
)
{
foundEngineInPopup
=
true
;
break
;
}
}
Assert
.
ok
(
foundEngineInPopup
"
Custom
engine
appears
in
the
popup
.
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
+
alias
}
)
;
let
keywordOfferResult
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
0
)
;
Assert
.
equal
(
keywordOfferResult
.
searchParams
.
engine
name
"
The
first
result
should
be
a
keyword
search
result
with
the
correct
engine
.
"
)
;
await
extension
.
unload
(
)
;
if
(
UrlbarPrefs
.
getScotchBonnetPref
(
"
searchRestrictKeywords
.
featureGate
"
)
)
{
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
multipleMatchingEngines
(
)
{
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
TestFoo
"
keyword
:
{
ALIAS
}
foo
}
{
skipUnload
:
true
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
te
"
fireInputEvent
:
true
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
2
"
Two
results
are
shown
.
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
-
1
"
Neither
result
is
selected
.
"
)
;
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
0
)
;
Assert
.
ok
(
result
.
autofill
"
The
first
result
is
autofilling
.
"
)
;
Assert
.
equal
(
result
.
searchParams
.
keyword
ALIAS
"
The
autofilled
engine
is
shown
first
.
"
)
;
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
1
)
;
Assert
.
equal
(
result
.
searchParams
.
keyword
{
ALIAS
}
foo
"
The
other
engine
is
shown
second
.
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
0
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
Urlbar
should
be
empty
.
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
1
)
;
Assert
.
equal
(
gURLBar
.
value
"
"
"
Urlbar
should
be
empty
.
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
-
1
"
Tabbing
all
the
way
through
the
matching
engines
should
return
to
the
input
.
"
)
;
Assert
.
equal
(
gURLBar
.
value
"
te
"
"
Urlbar
should
contain
the
search
string
.
"
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
doNotShowInSearchMode
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
}
)
;
let
testEngineItem
;
for
(
let
i
=
0
;
!
testEngineItem
;
i
+
+
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
if
(
details
.
searchParams
&
&
details
.
searchParams
.
keyword
=
=
ALIAS
)
{
testEngineItem
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
i
)
;
}
}
Assert
.
equal
(
testEngineItem
.
result
.
payload
.
keyword
ALIAS
"
Sanity
check
:
we
found
our
engine
.
"
)
;
let
searchPromise
=
UrlbarTestUtils
.
promiseSearchComplete
(
window
)
;
EventUtils
.
synthesizeMouseAtCenter
(
testEngineItem
{
}
)
;
await
searchPromise
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
testEngineItem
.
result
.
payload
.
engine
entry
:
"
keywordoffer
"
}
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
"
fireInputEvent
:
true
}
)
;
let
resultCount
=
UrlbarTestUtils
.
getResultCount
(
window
)
;
for
(
let
i
=
0
;
i
<
resultCount
;
i
+
+
)
{
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
Assert
.
ok
(
!
result
.
searchParams
.
keyword
Result
at
index
{
i
}
is
not
a
keywordoffer
.
)
;
}
}
)
;
async
function
assertFirstResultIsAlias
(
isAlias
expectedAlias
)
{
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
0
)
;
Assert
.
equal
(
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
"
Should
have
the
correct
type
"
)
;
if
(
isAlias
)
{
Assert
.
equal
(
result
.
searchParams
.
keyword
expectedAlias
"
Payload
keyword
should
be
the
alias
"
)
;
}
else
{
Assert
.
notEqual
(
result
.
searchParams
.
keyword
expectedAlias
"
Payload
keyword
should
be
absent
or
not
the
alias
"
)
;
}
}
function
assertHighlighted
(
highlighted
expectedAlias
)
{
let
selection
=
gURLBar
.
editor
.
selectionController
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
Assert
.
ok
(
selection
)
;
if
(
!
highlighted
)
{
Assert
.
equal
(
selection
.
rangeCount
0
)
;
return
;
}
Assert
.
equal
(
selection
.
rangeCount
1
)
;
let
index
=
gURLBar
.
value
.
indexOf
(
expectedAlias
)
;
Assert
.
ok
(
index
>
=
0
gURLBar
.
value
=
"
{
gURLBar
.
value
}
"
expectedAlias
=
"
{
expectedAlias
}
"
)
;
let
range
=
selection
.
getRangeAt
(
0
)
;
Assert
.
ok
(
range
)
;
Assert
.
equal
(
range
.
startOffset
index
)
;
Assert
.
equal
(
range
.
endOffset
index
+
expectedAlias
.
length
)
;
}
function
codePoints
(
str
)
{
return
str
.
split
(
"
"
)
.
map
(
s
=
>
s
.
charCodeAt
(
0
)
.
toString
(
16
)
)
;
}
