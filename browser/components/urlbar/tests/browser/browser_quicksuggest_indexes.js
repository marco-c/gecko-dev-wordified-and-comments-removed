"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
jsm
"
UrlbarQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarQuickSuggest
.
jsm
"
}
)
;
const
SUGGESTIONS_FIRST_PREF
=
"
browser
.
urlbar
.
showSearchSuggestionsFirst
"
;
const
SUGGESTIONS_PREF
=
"
browser
.
urlbar
.
suggest
.
searches
"
;
const
TEST_ENGINE_BASENAME
=
"
searchSuggestionEngine
.
xml
"
;
const
MAX_RESULTS
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
const
SPONSORED_INDEX_PREF
=
"
browser
.
urlbar
.
quicksuggest
.
sponsoredIndex
"
;
const
NON_SPONSORED_INDEX_PREF
=
"
browser
.
urlbar
.
quicksuggest
.
nonSponsoredIndex
"
;
const
SPONSORED_SEARCH_STRING
=
"
frabbits
"
;
const
NON_SPONSORED_SEARCH_STRING
=
"
nonspon
"
;
const
TEST_URL
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
browser
/
components
/
urlbar
/
tests
/
browser
/
quicksuggest
.
sjs
"
;
const
TEST_DATA
=
[
{
id
:
1
url
:
{
TEST_URL
}
?
q
=
{
SPONSORED_SEARCH_STRING
}
title
:
"
frabbits
"
keywords
:
[
SPONSORED_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
"
advertiser
:
"
TestAdvertiser
"
}
{
id
:
2
url
:
{
TEST_URL
}
?
q
=
{
NON_SPONSORED_SEARCH_STRING
}
title
:
"
Non
-
Sponsored
"
keywords
:
[
NON_SPONSORED_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
nonsponsored
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
nonsponsored
"
advertiser
:
"
TestAdvertiserNonSponsored
"
iab_category
:
"
5
-
Education
"
}
]
;
add_task
(
async
function
init
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
requestLongerTimeout
(
3
)
;
}
await
PlacesUtils
.
history
.
clear
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
)
;
await
SearchTestUtils
.
installSearchExtension
(
)
;
let
oldDefaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
await
Services
.
search
.
setDefault
(
Services
.
search
.
getEngineByName
(
"
Example
"
)
)
;
await
UrlbarQuickSuggest
.
init
(
)
;
let
{
_createTree
}
=
UrlbarQuickSuggest
;
UrlbarQuickSuggest
.
_createTree
=
(
)
=
>
{
}
;
await
UrlbarQuickSuggest
.
_processSuggestionsJSON
(
TEST_DATA
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
quicksuggest
.
enabled
"
true
]
[
"
browser
.
urlbar
.
quicksuggest
.
shouldShowOnboardingDialog
"
false
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
"
true
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
true
]
]
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
clear
(
)
;
Services
.
search
.
setDefault
(
oldDefaultEngine
)
;
UrlbarQuickSuggest
.
_createTree
=
_createTree
;
}
)
;
}
)
;
add_task
(
async
function
noSuggestions
(
)
{
await
doTestPermutations
(
(
{
withHistory
generalIndex
}
)
=
>
(
{
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
2
expectedIndex
:
generalIndex
=
=
0
|
|
!
withHistory
?
1
:
MAX_RESULTS
-
1
}
)
)
;
}
)
;
add_task
(
async
function
suggestionsFirst
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
true
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doTestPermutations
(
(
{
withHistory
generalIndex
}
)
=
>
(
{
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
4
expectedIndex
:
generalIndex
=
=
0
|
|
!
withHistory
?
3
:
MAX_RESULTS
-
1
}
)
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
suggestionsLast
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
false
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doTestPermutations
(
(
{
withHistory
generalIndex
}
)
=
>
(
{
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
4
expectedIndex
:
generalIndex
=
=
0
|
|
!
withHistory
?
1
:
MAX_RESULTS
-
3
}
)
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
otherSuggestedIndex_noSuggestions
(
)
{
await
doSuggestedIndexTest
(
[
{
heuristic
:
true
}
{
suggestedIndex
:
1
resultSpan
:
2
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
providerName
:
UrlbarProviderQuickSuggest
.
name
}
]
)
;
}
)
;
add_task
(
async
function
otherSuggestedIndex_suggestionsFirst
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
true
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doSuggestedIndexTest
(
[
{
heuristic
:
true
}
{
suggestedIndex
:
1
resultSpan
:
2
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
payload
:
{
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
}
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
payload
:
{
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
}
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
providerName
:
UrlbarProviderQuickSuggest
.
name
}
]
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
otherSuggestedIndex_suggestionsLast
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
false
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doSuggestedIndexTest
(
[
{
heuristic
:
true
}
{
suggestedIndex
:
1
resultSpan
:
2
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
providerName
:
UrlbarProviderQuickSuggest
.
name
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
payload
:
{
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
}
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
payload
:
{
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
}
}
]
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
class
TestProvider
extends
UrlbarTestUtils
.
TestProvider
{
constructor
(
)
{
super
(
{
results
:
[
Object
.
assign
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
url
:
"
http
:
/
/
example
.
com
/
test
"
}
)
{
suggestedIndex
:
1
resultSpan
:
2
}
)
]
}
)
;
}
}
async
function
doTestPermutations
(
callback
)
{
for
(
let
isSponsored
of
[
true
false
]
)
{
for
(
let
withHistory
of
[
true
false
]
)
{
for
(
let
generalIndex
of
[
0
-
1
]
)
{
let
opts
=
{
isSponsored
withHistory
generalIndex
}
;
await
doTest
(
Object
.
assign
(
opts
callback
(
opts
)
)
)
;
}
}
}
}
async
function
doTest
(
{
isSponsored
withHistory
generalIndex
expectedResultCount
expectedIndex
}
)
{
info
(
"
Running
test
with
options
:
"
+
JSON
.
stringify
(
{
isSponsored
withHistory
generalIndex
expectedResultCount
expectedIndex
}
)
)
;
let
indexPref
=
isSponsored
?
SPONSORED_INDEX_PREF
:
NON_SPONSORED_INDEX_PREF
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
indexPref
generalIndex
]
]
}
)
;
if
(
withHistory
)
{
await
addHistory
(
)
;
}
let
value
=
isSponsored
?
SPONSORED_SEARCH_STRING
:
NON_SPONSORED_SEARCH_STRING
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
expectedResultCount
"
Expected
result
count
"
)
;
await
assertIsQuickSuggest
(
{
isSponsored
index
:
expectedIndex
sponsoredURL
:
{
TEST_URL
}
?
q
=
{
SPONSORED_SEARCH_STRING
}
nonsponsoredURL
:
{
TEST_URL
}
?
q
=
{
NON_SPONSORED_SEARCH_STRING
}
}
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
async
function
addHistory
(
)
{
for
(
let
i
=
0
;
i
<
MAX_RESULTS
;
i
+
+
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
http
:
/
/
example
.
com
/
"
+
SPONSORED_SEARCH_STRING
+
i
"
http
:
/
/
example
.
com
/
"
+
NON_SPONSORED_SEARCH_STRING
+
i
]
)
;
}
}
async
function
withSuggestions
(
callback
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_PREF
true
]
]
}
)
;
let
engine
=
await
SearchTestUtils
.
promiseNewSearchEngine
(
getRootDirectory
(
gTestPath
)
+
TEST_ENGINE_BASENAME
)
;
let
oldDefaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
await
Services
.
search
.
setDefault
(
engine
)
;
try
{
await
callback
(
engine
)
;
}
finally
{
await
Services
.
search
.
setDefault
(
oldDefaultEngine
)
;
await
Services
.
search
.
removeEngine
(
engine
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
async
function
doSuggestedIndexTest
(
expectedProps
)
{
await
addHistory
(
)
;
let
provider
=
new
TestProvider
(
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
let
context
=
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
SPONSORED_SEARCH_STRING
}
)
;
checkResults
(
context
.
results
expectedProps
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
function
checkResults
(
actualResults
expectedProps
)
{
Assert
.
equal
(
actualResults
.
length
expectedProps
.
length
"
Expected
result
count
"
)
;
let
actualProps
=
actualResults
.
map
(
(
actual
i
)
=
>
{
if
(
expectedProps
.
length
<
=
i
)
{
return
actual
;
}
let
props
=
{
}
;
let
expected
=
expectedProps
[
i
]
;
for
(
let
[
key
expectedValue
]
of
Object
.
entries
(
expected
)
)
{
if
(
key
!
=
"
payload
"
)
{
props
[
key
]
=
actual
[
key
]
;
}
else
{
props
.
payload
=
{
}
;
for
(
let
pkey
of
Object
.
keys
(
expectedValue
)
)
{
props
.
payload
[
pkey
]
=
actual
.
payload
[
pkey
]
;
}
}
}
return
props
;
}
)
;
Assert
.
deepEqual
(
actualProps
expectedProps
)
;
}
