"
use
strict
"
;
const
TEST_ENGINE_BASENAME
=
"
searchSuggestionEngine
.
xml
"
;
let
gMaxResults
;
XPCOMUtils
.
defineLazyGetter
(
this
"
oneOffSearchButtons
"
(
)
=
>
{
return
UrlbarTestUtils
.
getOneOffSearchButtons
(
window
)
;
}
)
;
let
originalEngine
;
let
newEngine
;
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
update2
"
true
]
[
"
browser
.
urlbar
.
update2
.
localOneOffs
"
true
]
[
"
browser
.
urlbar
.
update2
.
oneOffsRefresh
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
contextMenu_not_shown
(
)
{
let
popupshownFired
=
false
;
let
onPopupshown
=
(
)
=
>
{
popupshownFired
=
true
;
}
;
let
contextMenu
=
oneOffSearchButtons
.
querySelector
(
"
.
search
-
one
-
offs
-
context
-
menu
"
)
;
contextMenu
.
addEventListener
(
"
popupshown
"
onPopupshown
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
foo
"
}
)
;
let
allOneOffs
=
oneOffSearchButtons
.
getSelectableButtons
(
true
)
;
Assert
.
greater
(
allOneOffs
.
length
0
"
There
should
be
at
least
one
one
-
off
"
)
;
Assert
.
ok
(
allOneOffs
[
0
]
.
engine
"
The
first
one
-
off
should
be
a
remote
one
-
off
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
allOneOffs
[
0
]
{
type
:
"
contextmenu
"
button
:
2
}
)
;
let
timeout
=
500
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeout
)
)
;
Assert
.
ok
(
!
popupshownFired
"
popupshown
should
not
be
fired
on
a
remote
one
-
off
"
)
;
let
localOneOffs
=
oneOffSearchButtons
.
localButtons
;
Assert
.
greater
(
localOneOffs
.
length
0
"
There
should
be
at
least
one
local
one
-
off
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
localOneOffs
[
0
]
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
timeout
)
)
;
Assert
.
ok
(
!
popupshownFired
"
popupshown
should
not
be
fired
on
a
local
one
-
off
"
)
;
contextMenu
.
removeEventListener
(
"
popupshown
"
onPopupshown
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
