"
use
strict
"
;
let
fakeController
;
function
assertContextMatches
(
context
expectedValues
)
{
Assert
.
ok
(
context
instanceof
UrlbarQueryContext
"
Should
be
a
UrlbarQueryContext
"
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
expectedValues
)
)
{
Assert
.
equal
(
context
[
key
]
value
Should
have
the
expected
value
for
{
key
}
in
the
UrlbarQueryContext
)
;
}
}
function
checkStartQueryCall
(
stub
expectedQueryContextProps
callIndex
=
0
)
{
Assert
.
equal
(
stub
.
callCount
callIndex
+
1
"
Should
have
called
startQuery
on
the
controller
"
)
;
let
args
=
stub
.
args
[
callIndex
]
;
Assert
.
equal
(
args
.
length
1
"
Should
have
called
startQuery
with
one
argument
"
)
;
let
queryContext
=
args
[
0
]
;
Assert
.
ok
(
queryContext
instanceof
UrlbarQueryContext
"
Should
have
been
passed
a
UrlbarQueryContext
"
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
expectedQueryContextProps
)
)
{
Assert
.
deepEqual
(
queryContext
[
name
]
value
Should
have
the
correct
value
for
queryContext
.
{
name
}
)
;
}
}
async
function
withNewWindow
(
callback
)
{
let
gTestRoot
=
getRootDirectory
(
gTestPath
)
;
let
win
=
window
.
openDialog
(
gTestRoot
+
"
empty
.
xul
"
"
"
"
chrome
"
)
;
await
BrowserTestUtils
.
waitForEvent
(
win
"
load
"
)
;
win
.
gBrowser
=
{
}
;
let
doc
=
win
.
document
;
let
textbox
=
doc
.
importNode
(
document
.
getElementById
(
"
urlbar
"
)
true
)
;
doc
.
documentElement
.
appendChild
(
textbox
)
;
let
panel
=
doc
.
importNode
(
document
.
getElementById
(
"
urlbar
-
results
"
)
true
)
;
doc
.
documentElement
.
appendChild
(
panel
)
;
let
inputOptions
=
{
textbox
panel
controller
:
fakeController
}
;
let
input
=
new
UrlbarInput
(
inputOptions
)
;
await
callback
(
input
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
input
.
textbox
=
null
;
input
.
panel
=
null
;
input
.
window
=
null
;
input
.
document
=
null
;
input
.
view
=
null
;
Assert
.
ok
(
fakeController
.
view
)
;
fakeController
.
removeQueryListener
(
fakeController
.
view
)
;
fakeController
.
view
=
null
;
}
add_task
(
async
function
setup
(
)
{
sandbox
=
sinon
.
sandbox
.
create
(
)
;
fakeController
=
new
UrlbarController
(
{
browserWindow
:
window
}
)
;
sandbox
.
stub
(
fakeController
"
startQuery
"
)
;
sandbox
.
stub
(
PrivateBrowsingUtils
"
isWindowPrivate
"
)
.
returns
(
false
)
;
registerCleanupFunction
(
async
(
)
=
>
{
sandbox
.
restore
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_input_starts_query
(
)
{
await
withNewWindow
(
input
=
>
{
input
.
inputField
.
value
=
"
search
"
;
input
.
handleEvent
(
{
target
:
input
.
inputField
type
:
"
input
"
}
)
;
checkStartQueryCall
(
fakeController
.
startQuery
{
searchString
:
"
search
"
isPrivate
:
false
maxResults
:
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
}
)
;
sandbox
.
resetHistory
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_input_with_private_browsing
(
)
{
PrivateBrowsingUtils
.
isWindowPrivate
.
returns
(
true
)
;
await
withNewWindow
(
privateInput
=
>
{
privateInput
.
inputField
.
value
=
"
search
"
;
privateInput
.
handleEvent
(
{
target
:
privateInput
.
inputField
type
:
"
input
"
}
)
;
checkStartQueryCall
(
fakeController
.
startQuery
{
searchString
:
"
search
"
isPrivate
:
true
}
)
;
sandbox
.
resetHistory
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_autofill_disabled_on_prefix_search
(
)
{
await
withNewWindow
(
input
=
>
{
input
.
inputField
.
value
=
"
autofill
"
;
input
.
handleEvent
(
{
target
:
input
.
inputField
type
:
"
input
"
}
)
;
checkStartQueryCall
(
fakeController
.
startQuery
{
searchString
:
"
autofill
"
enableAutofill
:
true
}
)
;
input
.
inputField
.
value
=
"
auto
"
;
input
.
handleEvent
(
{
target
:
input
.
inputField
type
:
"
input
"
}
)
;
checkStartQueryCall
(
fakeController
.
startQuery
{
searchString
:
"
auto
"
enableAutofill
:
false
}
1
)
;
input
.
inputField
.
value
=
"
autofill
"
;
input
.
handleEvent
(
{
target
:
input
.
inputField
type
:
"
input
"
}
)
;
checkStartQueryCall
(
fakeController
.
startQuery
{
searchString
:
"
autofill
"
enableAutofill
:
true
}
2
)
;
sandbox
.
resetHistory
(
)
;
}
)
;
}
)
;
