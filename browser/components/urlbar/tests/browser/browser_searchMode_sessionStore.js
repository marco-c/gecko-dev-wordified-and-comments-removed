"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
SessionStore
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
TabStateFlusher
:
"
resource
:
/
/
/
modules
/
sessionstore
/
TabStateFlusher
.
jsm
"
}
)
;
requestLongerTimeout
(
5
)
;
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
update2
"
true
]
[
"
browser
.
urlbar
.
update2
.
oneOffsRefresh
"
true
]
]
}
)
;
}
)
;
const
SEARCH_STRING
=
"
test
browser_sessionStore
.
js
"
;
const
URL
=
"
http
:
/
/
example
.
com
/
"
;
const
INITIAL_URL
=
"
about
:
newtab
"
;
add_task
(
async
function
initialPageOnRestore
(
)
{
await
doTest
(
{
urls
:
[
INITIAL_URL
]
searchModeTabIndex
:
0
exitSearchMode
:
false
switchTabsAfterEnteringSearchMode
:
false
}
)
;
}
)
;
add_task
(
async
function
switchToInitialPage
(
)
{
await
doTest
(
{
urls
:
[
URL
INITIAL_URL
]
searchModeTabIndex
:
1
exitSearchMode
:
false
switchTabsAfterEnteringSearchMode
:
true
}
)
;
}
)
;
add_task
(
async
function
nonInitialPageOnRestore
(
)
{
await
doTest
(
{
urls
:
[
URL
]
searchModeTabIndex
:
0
exitSearchMode
:
false
switchTabsAfterEnteringSearchMode
:
false
}
)
;
}
)
;
add_task
(
async
function
switchToNonInitialPage
(
)
{
await
doTest
(
{
urls
:
[
INITIAL_URL
URL
]
searchModeTabIndex
:
1
exitSearchMode
:
false
switchTabsAfterEnteringSearchMode
:
true
}
)
;
}
)
;
add_task
(
async
function
initialPageOnRestore_exit
(
)
{
await
doTest
(
{
urls
:
[
INITIAL_URL
]
searchModeTabIndex
:
0
exitSearchMode
:
true
switchTabsAfterEnteringSearchMode
:
false
}
)
;
}
)
;
add_task
(
async
function
switchToInitialPage_exit
(
)
{
await
doTest
(
{
urls
:
[
URL
INITIAL_URL
]
searchModeTabIndex
:
1
exitSearchMode
:
true
switchTabsAfterEnteringSearchMode
:
true
}
)
;
}
)
;
add_task
(
async
function
nonInitialPageOnRestore_exit
(
)
{
await
doTest
(
{
urls
:
[
URL
]
searchModeTabIndex
:
0
exitSearchMode
:
true
switchTabsAfterEnteringSearchMode
:
false
}
)
;
}
)
;
add_task
(
async
function
switchToNonInitialPage_exit
(
)
{
await
doTest
(
{
urls
:
[
INITIAL_URL
URL
]
searchModeTabIndex
:
1
exitSearchMode
:
true
switchTabsAfterEnteringSearchMode
:
true
}
)
;
}
)
;
async
function
doTest
(
{
urls
searchModeTabIndex
exitSearchMode
switchTabsAfterEnteringSearchMode
}
)
{
let
searchModeURL
=
urls
[
searchModeTabIndex
]
;
let
otherTabIndex
=
(
searchModeTabIndex
+
1
)
%
urls
.
length
;
let
otherURL
=
urls
[
otherTabIndex
]
;
await
withNewWindow
(
urls
async
win
=
>
{
if
(
win
.
gBrowser
.
selectedTab
!
=
win
.
gBrowser
.
tabs
[
searchModeTabIndex
]
)
{
await
BrowserTestUtils
.
switchTab
(
win
.
gBrowser
win
.
gBrowser
.
tabs
[
searchModeTabIndex
]
)
;
}
Assert
.
equal
(
win
.
gBrowser
.
currentURI
.
spec
searchModeURL
Sanity
check
:
Tab
at
index
{
searchModeTabIndex
}
is
correct
)
;
Assert
.
equal
(
searchModeURL
=
=
INITIAL_URL
win
.
gInitialPages
.
includes
(
win
.
gBrowser
.
currentURI
.
spec
)
Sanity
check
:
{
searchModeURL
}
is
or
is
not
in
gInitialPages
as
expected
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
:
win
value
:
SEARCH_STRING
fireInputEvent
:
true
}
)
;
await
UrlbarTestUtils
.
enterSearchMode
(
win
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
}
)
;
if
(
exitSearchMode
)
{
await
UrlbarTestUtils
.
exitSearchMode
(
win
)
;
}
await
TabStateFlusher
.
flush
(
win
.
gBrowser
.
selectedBrowser
)
;
if
(
switchTabsAfterEnteringSearchMode
)
{
await
BrowserTestUtils
.
switchTab
(
win
.
gBrowser
win
.
gBrowser
.
tabs
[
otherTabIndex
]
)
;
}
}
)
;
let
restoredURL
=
switchTabsAfterEnteringSearchMode
?
otherURL
:
searchModeURL
;
let
win
=
await
restoreWindow
(
restoredURL
)
;
Assert
.
equal
(
win
.
gBrowser
.
currentURI
.
spec
restoredURL
"
Sanity
check
:
Initially
selected
tab
in
restored
window
is
correct
"
)
;
if
(
switchTabsAfterEnteringSearchMode
)
{
await
BrowserTestUtils
.
switchTab
(
win
.
gBrowser
win
.
gBrowser
.
tabs
[
searchModeTabIndex
]
)
;
}
if
(
exitSearchMode
)
{
await
new
Promise
(
r
=
>
win
.
setTimeout
(
r
500
)
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
win
null
)
;
}
else
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
win
.
gURLBar
.
searchMode
"
Waiting
for
search
mode
to
be
restored
"
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
win
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
entry
:
"
oneoff
"
}
)
;
Assert
.
equal
(
win
.
gURLBar
.
value
SEARCH_STRING
"
Search
string
should
be
restored
"
)
;
}
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
add_task
(
async
function
duplicateTabs
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
SEARCH_STRING
fireInputEvent
:
true
}
)
;
await
UrlbarTestUtils
.
enterSearchMode
(
window
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
}
)
;
window
.
TabContextMenu
.
contextTab
=
gBrowser
.
selectedTab
;
let
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
gBrowser
.
currentURI
.
spec
)
;
let
menuitem
=
document
.
getElementById
(
"
context_duplicateTab
"
)
;
menuitem
.
click
(
)
;
let
newTab
=
await
tabPromise
;
Assert
.
equal
(
gBrowser
.
selectedTab
newTab
"
Sanity
check
:
The
duplicated
tab
is
now
the
selected
tab
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
gURLBar
.
searchMode
"
Waiting
for
search
mode
to
be
duplicated
/
restored
"
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
entry
:
"
oneoff
"
}
)
;
Assert
.
equal
(
gURLBar
.
value
SEARCH_STRING
"
Search
string
should
be
duplicated
/
restored
"
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
gURLBar
.
handleRevert
(
)
;
}
)
;
async
function
withNewWindow
(
urls
callback
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
for
(
let
url
of
urls
)
{
await
BrowserTestUtils
.
openNewForegroundTab
(
{
url
gBrowser
:
win
.
gBrowser
waitForLoad
:
url
!
=
"
about
:
newtab
"
}
)
;
if
(
url
=
=
"
about
:
newtab
"
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
win
.
gBrowser
.
currentURI
.
spec
=
=
"
about
:
newtab
"
"
Waiting
for
about
:
newtab
"
)
;
}
}
BrowserTestUtils
.
removeTab
(
win
.
gBrowser
.
tabs
[
0
]
)
;
await
callback
(
win
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
async
function
restoreWindow
(
expectedRestoredURL
)
{
let
winPromise
=
BrowserTestUtils
.
waitForNewWindow
(
)
;
let
win
=
SessionStore
.
undoCloseWindow
(
0
)
;
await
winPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
win
.
gBrowser
.
currentURI
.
spec
=
=
expectedRestoredURL
"
Waiting
for
restored
selected
browser
to
have
expected
URI
"
)
;
return
win
;
}
