"
use
strict
"
;
const
DYNAMIC_TYPE_NAME
=
"
test
"
;
const
DYNAMIC_TYPE_VIEW_TEMPLATE
=
{
stylesheet
:
getRootDirectory
(
gTestPath
)
+
"
dynamicResult0
.
css
"
children
:
[
{
name
:
"
selectable
"
tag
:
"
span
"
attributes
:
{
selectable
:
"
true
"
}
}
{
name
:
"
text
"
tag
:
"
span
"
}
{
name
:
"
buttonBox
"
tag
:
"
span
"
children
:
[
{
name
:
"
button1
"
tag
:
"
span
"
attributes
:
{
role
:
"
button
"
attribute_to_remove
:
"
value
"
}
}
{
name
:
"
button2
"
tag
:
"
span
"
attributes
:
{
role
:
"
button
"
}
}
]
}
]
}
;
const
IS_UPGRADING_SCHEMELESS
=
SpecialPowers
.
getBoolPref
(
"
dom
.
security
.
https_first_schemeless
"
)
;
const
DEFAULT_URL_SCHEME
=
IS_UPGRADING_SCHEMELESS
?
"
https
:
/
/
"
:
"
http
:
/
/
"
;
const
DUMMY_PAGE
=
DEFAULT_URL_SCHEME
+
"
example
.
com
/
browser
/
browser
/
base
/
content
/
test
/
general
/
dummy_page
.
html
"
;
add_task
(
async
function
registration
(
)
{
let
stylesheetURIs
=
[
]
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
stylesheetURIs
.
push
(
Services
.
io
.
newURI
(
getRootDirectory
(
gTestPath
)
+
dynamicResult
{
i
}
.
css
)
)
;
}
let
viewTemplatesByName
=
{
foo
:
{
stylesheet
:
stylesheetURIs
[
0
]
.
spec
children
:
[
{
name
:
"
text
"
tag
:
"
span
"
}
]
}
bar
:
{
stylesheet
:
stylesheetURIs
[
1
]
.
spec
children
:
[
{
name
:
"
icon
"
tag
:
"
span
"
}
{
name
:
"
button
"
tag
:
"
span
"
attributes
:
{
role
:
"
button
"
}
}
]
}
}
;
let
newWindows
=
[
]
;
newWindows
.
push
(
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
)
;
for
(
let
[
name
viewTemplate
]
of
Object
.
entries
(
viewTemplatesByName
)
)
{
UrlbarResult
.
addDynamicResultType
(
name
)
;
UrlbarView
.
addDynamicViewTemplate
(
name
viewTemplate
)
;
}
for
(
let
name
of
Object
.
keys
(
viewTemplatesByName
)
)
{
let
actualType
=
UrlbarResult
.
getDynamicResultType
(
name
)
;
Assert
.
deepEqual
(
actualType
{
}
"
Types
should
match
"
)
;
}
function
getCSSVariables
(
windows
)
{
let
valuesByWindow
=
new
Map
(
)
;
for
(
let
win
of
windows
)
{
let
values
=
[
]
;
valuesByWindow
.
set
(
window
values
)
;
for
(
let
i
=
0
;
i
<
stylesheetURIs
.
length
;
i
+
+
)
{
let
value
=
win
.
getComputedStyle
(
gURLBar
.
panel
)
.
getPropertyValue
(
-
-
testDynamicResult
{
i
}
)
;
values
.
push
(
(
value
|
|
"
"
)
.
trim
(
)
)
;
}
}
return
valuesByWindow
;
}
function
checkCSSVariables
(
windows
)
{
for
(
let
values
of
getCSSVariables
(
windows
)
.
values
(
)
)
{
for
(
let
i
=
0
;
i
<
stylesheetURIs
.
length
;
i
+
+
)
{
if
(
values
[
i
]
.
trim
(
)
!
=
=
ok
{
i
}
)
{
return
false
;
}
}
}
return
true
;
}
await
TestUtils
.
waitForCondition
(
(
)
=
>
checkCSSVariables
(
BrowserWindowTracker
.
orderedWindows
)
)
;
Assert
.
ok
(
true
"
Stylesheets
loaded
in
all
open
windows
"
)
;
let
newWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
newWindows
.
push
(
newWin
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
checkCSSVariables
(
[
newWin
]
)
)
;
Assert
.
ok
(
true
"
Stylesheets
loaded
in
new
window
"
)
;
for
(
let
name
of
Object
.
keys
(
viewTemplatesByName
)
)
{
UrlbarView
.
removeDynamicViewTemplate
(
name
)
;
UrlbarResult
.
removeDynamicResultType
(
name
)
;
let
actualType
=
UrlbarResult
.
getDynamicResultType
(
name
)
;
Assert
.
equal
(
actualType
null
"
Type
should
be
unregistered
"
)
;
}
let
valuesByWindow
=
getCSSVariables
(
BrowserWindowTracker
.
orderedWindows
)
;
for
(
let
values
of
valuesByWindow
.
values
(
)
)
{
for
(
let
i
=
0
;
i
<
stylesheetURIs
.
length
;
i
+
+
)
{
Assert
.
ok
(
!
values
[
i
]
"
Stylesheet
should
be
removed
"
)
;
}
}
for
(
let
win
of
newWindows
)
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
}
)
;
add_task
(
async
function
viewCreated
(
)
{
await
withDynamicTypeProvider
(
async
(
)
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
Assert
.
equal
(
row
.
getAttribute
(
"
dynamicType
"
)
DYNAMIC_TYPE_NAME
"
row
[
dynamicType
]
"
)
;
Assert
.
ok
(
!
row
.
hasAttribute
(
"
has
-
url
"
)
"
Row
should
not
have
has
-
url
since
view
template
does
not
contain
.
urlbarView
-
url
"
)
;
let
inner
=
row
.
querySelector
(
"
.
urlbarView
-
row
-
inner
"
)
;
Assert
.
ok
(
inner
"
.
urlbarView
-
row
-
inner
should
exist
"
)
;
checkDOM
(
inner
DYNAMIC_TYPE_VIEW_TEMPLATE
.
children
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
)
;
}
)
;
async
function
checkViewUpdated
(
provider
)
{
await
withDynamicTypeProvider
(
async
(
)
=
>
{
for
(
let
searchString
of
[
"
test
"
"
some
other
string
"
"
and
another
"
]
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
searchString
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
let
text
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
text
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
text
.
getAttribute
(
"
searchString
"
)
=
=
searchString
)
;
let
elementNames
=
[
"
selectable
"
"
text
"
"
button1
"
"
button2
"
]
;
for
(
let
name
of
elementNames
)
{
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
name
}
)
;
Assert
.
equal
(
element
.
getAttribute
(
"
searchString
"
)
searchString
'
element
.
getAttribute
(
"
searchString
"
)
'
)
;
}
let
button1
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
button1
)
;
Assert
.
equal
(
button1
.
hasAttribute
(
"
attribute_to_remove
"
)
false
"
Attribute
should
be
removed
"
)
;
Assert
.
equal
(
text
.
textContent
result
.
payload
.
searchString
is
:
{
searchString
}
"
text
.
textContent
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
}
provider
)
;
}
add_task
(
async
function
checkViewUpdatedPlain
(
)
{
await
checkViewUpdated
(
new
TestProvider
(
)
)
;
}
)
;
add_task
(
async
function
checkViewUpdatedWDynamicViewTemplate
(
)
{
class
TestShouldCallGetViewTemplateProvider
extends
TestProvider
{
getViewTemplateWasCalled
=
false
;
getViewTemplate
(
)
{
this
.
getViewTemplateWasCalled
=
true
;
return
DYNAMIC_TYPE_VIEW_TEMPLATE
;
}
}
let
provider
=
new
TestShouldCallGetViewTemplateProvider
(
)
;
Assert
.
ok
(
!
provider
.
getViewTemplateWasCalled
"
getViewTemplate
has
not
yet
been
called
for
the
provider
"
)
;
Assert
.
ok
(
!
UrlbarView
.
dynamicViewTemplatesByName
.
get
(
DYNAMIC_TYPE_NAME
)
"
No
template
has
been
registered
"
)
;
await
checkViewUpdated
(
provider
)
;
Assert
.
ok
(
provider
.
getViewTemplateWasCalled
"
getViewTemplate
was
called
for
the
provider
"
)
;
}
)
;
add_task
(
async
function
selection
(
)
{
await
withDynamicTypeProvider
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
clear
(
)
;
await
PlacesTestUtils
.
addVisits
(
"
http
:
/
/
example
.
com
/
test
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
let
selectables
=
[
"
selectable
"
"
button1
"
"
button2
"
]
;
for
(
let
name
of
selectables
)
{
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
name
}
)
;
Assert
.
ok
(
element
"
Sanity
check
element
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
element
Selected
element
:
{
name
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
1
"
Row
at
index
1
selected
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRow
(
window
)
row
"
Row
selected
"
)
;
}
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
2
"
Row
at
index
2
selected
"
)
;
Assert
.
notEqual
(
UrlbarTestUtils
.
getSelectedRow
(
window
)
row
"
Row
is
not
selected
"
)
;
for
(
let
name
of
selectables
.
reverse
(
)
)
{
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
name
}
)
;
Assert
.
ok
(
element
"
Sanity
check
element
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
{
shiftKey
:
true
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
element
Selected
element
:
{
name
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
1
"
Row
at
index
1
selected
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRow
(
window
)
row
"
Row
selected
"
)
;
}
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
{
shiftKey
:
true
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
0
"
Row
at
index
0
selected
"
)
;
Assert
.
notEqual
(
UrlbarTestUtils
.
getSelectedRow
(
window
)
row
"
Row
is
not
selected
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
}
)
;
add_task
(
async
function
pick
(
)
{
await
withDynamicTypeProvider
(
async
provider
=
>
{
let
selectables
=
[
"
selectable
"
"
button1
"
"
button2
"
]
;
for
(
let
i
=
0
;
i
<
selectables
.
length
;
i
+
+
)
{
let
selectable
=
selectables
[
i
]
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
selectable
}
)
;
Assert
.
ok
(
element
"
Sanity
check
element
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
{
repeat
:
i
+
1
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
element
Selected
element
:
{
name
}
)
;
let
pickPromise
=
provider
.
promisePick
(
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
)
;
let
[
result
pickedElement
]
=
await
pickPromise
;
Assert
.
equal
(
result
row
.
result
"
Picked
result
"
)
;
Assert
.
equal
(
pickedElement
element
"
Picked
element
"
)
;
}
}
)
;
}
)
;
add_task
(
async
function
shouldNavigate
(
)
{
class
TestShouldNavigateProvider
extends
TestProvider
{
async
startQuery
(
context
addCallback
)
{
addCallback
(
this
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
suggestedIndex
:
1
payload
:
{
dynamicType
:
DYNAMIC_TYPE_NAME
url
:
DUMMY_PAGE
searchString
:
context
.
searchString
}
}
)
)
;
}
}
await
withDynamicTypeProvider
(
async
provider
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
selectable
)
;
Assert
.
ok
(
element
"
Sanity
check
element
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
{
repeat
:
1
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
element
Selected
element
:
{
name
}
)
;
let
pickPromise
=
provider
.
promisePick
(
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
)
;
let
[
result
pickedElement
]
=
await
pickPromise
;
Assert
.
equal
(
result
row
.
result
"
Picked
result
"
)
;
Assert
.
equal
(
pickedElement
element
"
Picked
element
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
is
(
gBrowser
.
currentURI
.
spec
DUMMY_PAGE
"
We
navigated
to
payload
.
url
when
result
selected
"
)
;
BrowserTestUtils
.
startLoadingURIString
(
gBrowser
.
selectedBrowser
"
about
:
home
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
false
"
about
:
home
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
selectable
)
;
pickPromise
=
provider
.
promisePick
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
element
{
}
)
;
[
result
pickedElement
]
=
await
pickPromise
;
Assert
.
equal
(
result
row
.
result
"
Picked
result
"
)
;
Assert
.
equal
(
pickedElement
element
"
Picked
element
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
is
(
gBrowser
.
currentURI
.
spec
DUMMY_PAGE
"
We
navigated
to
payload
.
url
when
result
is
clicked
"
)
;
}
new
TestShouldNavigateProvider
(
)
)
;
}
)
;
add_task
(
async
function
highlighting
(
)
{
class
TestHighlightProvider
extends
TestProvider
{
startQuery
(
context
addCallback
)
{
this
.
_tokens
=
context
.
tokens
;
let
result
=
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
suggestedIndex
:
1
payload
:
{
dynamicType
:
DYNAMIC_TYPE_NAME
text
:
"
Test
title
"
}
highlights
:
{
text
:
UrlbarUtils
.
HIGHLIGHT
.
TYPED
}
}
)
;
addCallback
(
this
result
)
;
}
getViewUpdate
(
result
_idsByName
)
{
let
{
value
:
textContent
highlights
}
=
result
.
getDisplayableValueAndHighlights
(
"
text
"
{
tokens
:
this
.
_tokens
}
)
;
return
{
text
:
{
textContent
highlights
}
}
;
}
}
await
withDynamicTypeProvider
(
async
(
)
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
title
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
let
parentTextNode
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
text
)
;
let
highlightedTextNode
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
text
>
strong
)
;
Assert
.
equal
(
parentTextNode
.
firstChild
.
textContent
"
Test
"
)
;
Assert
.
equal
(
highlightedTextNode
.
textContent
"
title
"
"
The
highlighting
was
applied
successfully
.
"
)
;
for
(
let
value
of
[
"
yyyyy
"
"
zzzzz
"
]
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
parentTextNode
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
text
)
;
highlightedTextNode
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
text
>
strong
)
;
Assert
.
equal
(
parentTextNode
.
firstChild
.
textContent
"
Test
title
"
)
;
Assert
.
ok
(
!
highlightedTextNode
"
The
<
strong
>
child
node
was
deleted
.
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
gURLBar
.
handleRevert
(
)
;
}
}
new
TestHighlightProvider
(
)
)
;
class
TestHighlightProviderOveridden
extends
TestHighlightProvider
{
getViewUpdate
(
_result
_idsByName
)
{
return
{
text
:
{
textContent
:
"
Test
title
"
}
}
;
}
}
await
withDynamicTypeProvider
(
async
(
)
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
let
parentTextNode
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
text
)
;
let
highlightedTextNode
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
text
>
strong
)
;
Assert
.
equal
(
parentTextNode
.
firstChild
.
textContent
"
Test
title
"
"
No
highlighting
was
applied
"
)
;
Assert
.
ok
(
!
highlightedTextNode
"
The
<
strong
>
child
node
was
deleted
.
"
)
;
}
new
TestHighlightProviderOveridden
(
)
)
;
}
)
;
add_task
(
async
function
hasUrlTopLevel
(
)
{
await
doAttributesTest
(
{
viewTemplate
:
{
name
:
"
url
"
tag
:
"
span
"
classList
:
[
"
urlbarView
-
url
"
]
}
viewUpdate
:
{
url
:
{
textContent
:
"
https
:
/
/
example
.
com
/
"
}
}
expectedAttributes
:
{
"
has
-
url
"
:
true
}
}
)
;
}
)
;
add_task
(
async
function
hasUrlDescendant
(
)
{
await
doAttributesTest
(
{
viewTemplate
:
{
children
:
[
{
children
:
[
{
children
:
[
{
name
:
"
url
"
tag
:
"
span
"
classList
:
[
"
urlbarView
-
url
"
]
}
]
}
]
}
]
}
viewUpdate
:
{
url
:
{
textContent
:
"
https
:
/
/
example
.
com
/
"
}
}
expectedAttributes
:
{
"
has
-
url
"
:
true
}
}
)
;
}
)
;
add_task
(
async
function
hasActionTopLevel
(
)
{
await
doAttributesTest
(
{
viewTemplate
:
{
name
:
"
action
"
tag
:
"
span
"
classList
:
[
"
urlbarView
-
action
"
]
}
viewUpdate
:
{
action
:
{
textContent
:
"
Some
action
text
"
}
}
expectedAttributes
:
{
"
has
-
action
"
:
true
}
}
)
;
}
)
;
add_task
(
async
function
hasActionDescendant
(
)
{
await
doAttributesTest
(
{
viewTemplate
:
{
children
:
[
{
children
:
[
{
children
:
[
{
name
:
"
action
"
tag
:
"
span
"
classList
:
[
"
urlbarView
-
action
"
]
}
]
}
]
}
]
}
viewUpdate
:
{
action
:
{
textContent
:
"
Some
action
text
"
}
}
expectedAttributes
:
{
"
has
-
action
"
:
true
}
}
)
;
}
)
;
add_task
(
async
function
clear_dynamicType_attribute
(
)
{
class
TestIndex0Provider
extends
TestProvider
{
async
startQuery
(
context
addCallback
)
{
addCallback
(
this
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
suggestedIndex
:
0
payload
:
{
dynamicType
:
DYNAMIC_TYPE_NAME
}
}
)
)
;
}
}
await
withDynamicTypeProvider
(
async
provider
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
0
)
;
Assert
.
equal
(
row
.
getAttribute
(
"
dynamicType
"
)
"
test
"
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
Assert
.
ok
(
!
row
.
hasAttribute
(
"
dynamicType
"
)
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
new
TestIndex0Provider
(
)
)
;
}
)
;
add_task
(
async
function
hasUrlAndActionDescendant
(
)
{
await
doAttributesTest
(
{
viewTemplate
:
{
children
:
[
{
children
:
[
{
children
:
[
{
name
:
"
url
"
tag
:
"
span
"
classList
:
[
"
urlbarView
-
url
"
]
}
]
}
{
name
:
"
action
"
tag
:
"
span
"
classList
:
[
"
urlbarView
-
action
"
]
}
]
}
]
}
viewUpdate
:
{
url
:
{
textContent
:
"
https
:
/
/
example
.
com
/
"
}
action
:
{
textContent
:
"
Some
action
text
"
}
}
expectedAttributes
:
{
"
has
-
url
"
:
true
"
has
-
action
"
:
true
}
}
)
;
}
)
;
async
function
doAttributesTest
(
{
viewTemplate
viewUpdate
expectedAttributes
}
)
{
expectedAttributes
=
{
"
has
-
url
"
:
false
"
has
-
action
"
:
false
.
.
.
expectedAttributes
}
;
let
provider
=
new
TestProvider
(
)
;
provider
.
getViewTemplate
=
(
)
=
>
viewTemplate
;
provider
.
getViewUpdate
=
(
)
=
>
viewUpdate
;
await
withDynamicTypeProvider
(
async
(
)
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
Sanity
check
:
The
expected
row
is
present
"
)
;
for
(
let
[
name
expected
]
of
Object
.
entries
(
expectedAttributes
)
)
{
Assert
.
equal
(
row
.
hasAttribute
(
name
)
expected
"
Row
should
have
attribute
as
expected
:
"
+
name
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
provider
)
;
}
class
TestProvider
extends
UrlbarTestUtils
.
TestProvider
{
async
startQuery
(
context
addCallback
)
{
addCallback
(
this
new
UrlbarResult
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
suggestedIndex
:
1
payload
:
{
dynamicType
:
DYNAMIC_TYPE_NAME
searchString
:
context
.
searchString
}
}
)
)
;
}
getViewUpdate
(
result
idsByName
)
{
for
(
let
child
of
DYNAMIC_TYPE_VIEW_TEMPLATE
.
children
)
{
Assert
.
ok
(
idsByName
.
get
(
child
.
name
)
idsByName
contains
{
child
.
name
}
)
;
}
return
{
selectable
:
{
textContent
:
"
Selectable
"
attributes
:
{
searchString
:
result
.
payload
.
searchString
}
}
text
:
{
textContent
:
result
.
payload
.
searchString
is
:
{
result
.
payload
.
searchString
}
attributes
:
{
searchString
:
result
.
payload
.
searchString
}
}
button1
:
{
textContent
:
"
Button
1
"
attributes
:
{
searchString
:
result
.
payload
.
searchString
attribute_to_remove
:
null
}
}
button2
:
{
textContent
:
"
Button
2
"
attributes
:
{
searchString
:
result
.
payload
.
searchString
}
}
}
;
}
onEngagement
(
queryContext
controller
details
)
{
if
(
this
.
_pickPromiseResolve
)
{
let
{
result
element
}
=
details
;
this
.
_pickPromiseResolve
(
[
result
element
]
)
;
delete
this
.
_pickPromiseResolve
;
delete
this
.
_pickPromise
;
}
}
promisePick
(
)
{
this
.
_pickPromise
=
new
Promise
(
resolve
=
>
{
this
.
_pickPromiseResolve
=
resolve
;
}
)
;
return
this
.
_pickPromise
;
}
}
async
function
withDynamicTypeProvider
(
callback
provider
=
new
TestProvider
(
)
)
{
UrlbarResult
.
addDynamicResultType
(
DYNAMIC_TYPE_NAME
)
;
if
(
!
provider
.
getViewTemplate
)
{
UrlbarView
.
addDynamicViewTemplate
(
DYNAMIC_TYPE_NAME
DYNAMIC_TYPE_VIEW_TEMPLATE
)
;
}
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
await
callback
(
provider
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
if
(
!
provider
.
getViewTemplate
)
{
UrlbarView
.
removeDynamicViewTemplate
(
DYNAMIC_TYPE_NAME
)
;
}
UrlbarResult
.
removeDynamicResultType
(
DYNAMIC_TYPE_NAME
)
;
}
function
checkDOM
(
parentNode
expectedChildren
)
{
info
(
checkDOM
:
Checking
parentNode
id
=
{
parentNode
.
id
}
className
=
{
parentNode
.
className
}
)
;
for
(
let
i
=
0
;
i
<
expectedChildren
.
length
;
i
+
+
)
{
let
child
=
expectedChildren
[
i
]
;
let
actualChild
=
parentNode
.
children
[
i
]
;
info
(
checkDOM
:
Checking
expected
child
:
{
JSON
.
stringify
(
child
)
}
)
;
Assert
.
ok
(
actualChild
"
actualChild
should
exist
"
)
;
Assert
.
equal
(
actualChild
.
tagName
child
.
tag
"
child
.
tag
"
)
;
Assert
.
equal
(
actualChild
.
getAttribute
(
"
name
"
)
child
.
name
"
child
.
name
"
)
;
Assert
.
ok
(
actualChild
.
classList
.
contains
(
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
child
.
name
}
)
"
child
.
name
should
be
in
classList
"
)
;
Assert
.
ok
(
actualChild
.
id
.
startsWith
(
"
urlbarView
-
row
-
"
)
)
;
Assert
.
ok
(
actualChild
.
id
.
endsWith
(
child
.
name
)
"
The
child
was
assigned
the
correct
ID
.
"
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
child
.
attributes
|
|
{
}
)
)
{
if
(
name
=
=
"
attribute_to_remove
"
)
{
Assert
.
equal
(
actualChild
.
hasAttribute
(
name
)
false
attribute
:
{
name
}
)
;
continue
;
}
Assert
.
equal
(
actualChild
.
getAttribute
(
name
)
value
attribute
:
{
name
}
)
;
}
for
(
let
name
of
child
.
classList
|
|
[
]
)
{
Assert
.
ok
(
actualChild
.
classList
.
contains
(
name
)
classList
:
{
name
}
)
;
}
if
(
child
.
children
)
{
checkDOM
(
actualChild
child
.
children
)
;
}
}
}
