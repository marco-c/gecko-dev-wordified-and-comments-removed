"
use
strict
"
;
const
DYNAMIC_TYPE_NAME
=
"
test
"
;
const
DYNAMIC_TYPE_VIEW_TEMPLATE
=
{
stylesheet
:
getRootDirectory
(
gTestPath
)
+
"
dynamicResult0
.
css
"
children
:
[
{
name
:
"
selectable
"
tag
:
"
span
"
attributes
:
{
selectable
:
"
true
"
}
}
{
name
:
"
text
"
tag
:
"
span
"
}
{
name
:
"
buttonBox
"
tag
:
"
span
"
children
:
[
{
name
:
"
button1
"
tag
:
"
span
"
attributes
:
{
role
:
"
button
"
}
}
{
name
:
"
button2
"
tag
:
"
span
"
attributes
:
{
role
:
"
button
"
}
}
]
}
]
}
;
const
DUMMY_PAGE
=
"
http
:
/
/
example
.
com
/
browser
/
browser
/
base
/
content
/
test
/
general
/
dummy_page
.
html
"
;
add_task
(
async
function
registration
(
)
{
let
stylesheetURIs
=
[
]
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
stylesheetURIs
.
push
(
Services
.
io
.
newURI
(
getRootDirectory
(
gTestPath
)
+
dynamicResult
{
i
}
.
css
)
)
;
}
let
viewTemplatesByName
=
{
foo
:
{
stylesheet
:
stylesheetURIs
[
0
]
.
spec
children
:
[
{
name
:
"
text
"
tag
:
"
span
"
}
]
}
bar
:
{
stylesheet
:
stylesheetURIs
[
1
]
.
spec
children
:
[
{
name
:
"
icon
"
tag
:
"
span
"
}
{
name
:
"
button
"
tag
:
"
span
"
attributes
:
{
role
:
"
button
"
}
}
]
}
}
;
let
newWindows
=
[
]
;
newWindows
.
push
(
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
)
;
for
(
let
[
name
viewTemplate
]
of
Object
.
entries
(
viewTemplatesByName
)
)
{
UrlbarResult
.
addDynamicResultType
(
name
)
;
UrlbarView
.
addDynamicViewTemplate
(
name
viewTemplate
)
;
}
for
(
let
name
of
Object
.
keys
(
viewTemplatesByName
)
)
{
let
actualType
=
UrlbarResult
.
getDynamicResultType
(
name
)
;
Assert
.
deepEqual
(
actualType
{
}
"
Types
should
match
"
)
;
}
function
getCSSVariables
(
windows
)
{
let
valuesByWindow
=
new
Map
(
)
;
for
(
let
win
of
windows
)
{
let
values
=
[
]
;
valuesByWindow
.
set
(
window
values
)
;
for
(
let
i
=
0
;
i
<
stylesheetURIs
.
length
;
i
+
+
)
{
let
value
=
win
.
getComputedStyle
(
gURLBar
.
panel
)
.
getPropertyValue
(
-
-
testDynamicResult
{
i
}
)
;
values
.
push
(
(
value
|
|
"
"
)
.
trim
(
)
)
;
}
}
return
valuesByWindow
;
}
function
checkCSSVariables
(
windows
)
{
for
(
let
values
of
getCSSVariables
(
windows
)
.
values
(
)
)
{
for
(
let
i
=
0
;
i
<
stylesheetURIs
.
length
;
i
+
+
)
{
if
(
values
[
i
]
.
trim
(
)
!
=
=
ok
{
i
}
)
{
return
false
;
}
}
}
return
true
;
}
await
TestUtils
.
waitForCondition
(
(
)
=
>
checkCSSVariables
(
BrowserWindowTracker
.
orderedWindows
)
)
;
Assert
.
ok
(
true
"
Stylesheets
loaded
in
all
open
windows
"
)
;
let
newWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
newWindows
.
push
(
newWin
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
checkCSSVariables
(
[
newWin
]
)
)
;
Assert
.
ok
(
true
"
Stylesheets
loaded
in
new
window
"
)
;
for
(
let
name
of
Object
.
keys
(
viewTemplatesByName
)
)
{
UrlbarView
.
removeDynamicViewTemplate
(
name
)
;
UrlbarResult
.
removeDynamicResultType
(
name
)
;
let
actualType
=
UrlbarResult
.
getDynamicResultType
(
name
)
;
Assert
.
equal
(
actualType
null
"
Type
should
be
unregistered
"
)
;
}
let
valuesByWindow
=
getCSSVariables
(
BrowserWindowTracker
.
orderedWindows
)
;
for
(
let
values
of
valuesByWindow
.
values
(
)
)
{
for
(
let
i
=
0
;
i
<
stylesheetURIs
.
length
;
i
+
+
)
{
Assert
.
ok
(
!
values
[
i
]
"
Stylesheet
should
be
removed
"
)
;
}
}
for
(
let
win
of
newWindows
)
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
}
)
;
add_task
(
async
function
viewCreated
(
)
{
await
withDynamicTypeProvider
(
async
(
)
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
Assert
.
equal
(
row
.
getAttribute
(
"
dynamicType
"
)
DYNAMIC_TYPE_NAME
"
row
[
dynamicType
]
"
)
;
let
inner
=
row
.
querySelector
(
"
.
urlbarView
-
row
-
inner
"
)
;
Assert
.
ok
(
inner
"
.
urlbarView
-
row
-
inner
should
exist
"
)
;
checkDOM
(
inner
DYNAMIC_TYPE_VIEW_TEMPLATE
.
children
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
)
;
}
)
;
add_task
(
async
function
viewUpdated
(
)
{
await
withDynamicTypeProvider
(
async
(
)
=
>
{
for
(
let
searchString
of
[
"
test
"
"
some
other
string
"
"
and
another
"
]
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
searchString
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
let
text
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
text
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
text
.
getAttribute
(
"
searchString
"
)
=
=
searchString
)
;
let
elementNames
=
[
"
selectable
"
"
text
"
"
button1
"
"
button2
"
]
;
for
(
let
name
of
elementNames
)
{
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
name
}
)
;
Assert
.
equal
(
element
.
getAttribute
(
"
searchString
"
)
searchString
'
element
.
getAttribute
(
"
searchString
"
)
'
)
;
}
Assert
.
equal
(
text
.
textContent
result
.
payload
.
searchString
is
:
{
searchString
}
"
text
.
textContent
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
}
)
;
}
)
;
add_task
(
async
function
selection
(
)
{
await
withDynamicTypeProvider
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
clear
(
)
;
await
PlacesTestUtils
.
addVisits
(
"
http
:
/
/
example
.
com
/
test
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
let
selectables
=
[
"
selectable
"
"
button1
"
"
button2
"
]
;
for
(
let
name
of
selectables
)
{
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
name
}
)
;
Assert
.
ok
(
element
"
Sanity
check
element
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
element
Selected
element
:
{
name
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
1
"
Row
at
index
1
selected
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRow
(
window
)
row
"
Row
selected
"
)
;
}
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
2
"
Row
at
index
2
selected
"
)
;
Assert
.
notEqual
(
UrlbarTestUtils
.
getSelectedRow
(
window
)
row
"
Row
is
not
selected
"
)
;
for
(
let
name
of
selectables
.
reverse
(
)
)
{
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
name
}
)
;
Assert
.
ok
(
element
"
Sanity
check
element
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
element
Selected
element
:
{
name
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
1
"
Row
at
index
1
selected
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRow
(
window
)
row
"
Row
selected
"
)
;
}
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedRowIndex
(
window
)
0
"
Row
at
index
0
selected
"
)
;
Assert
.
notEqual
(
UrlbarTestUtils
.
getSelectedRow
(
window
)
row
"
Row
is
not
selected
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
}
)
;
add_task
(
async
function
pick
(
)
{
await
withDynamicTypeProvider
(
async
provider
=
>
{
let
selectables
=
[
"
selectable
"
"
button1
"
"
button2
"
]
;
for
(
let
i
=
0
;
i
<
selectables
.
length
;
i
+
+
)
{
let
selectable
=
selectables
[
i
]
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
selectable
}
)
;
Assert
.
ok
(
element
"
Sanity
check
element
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
repeat
:
i
+
1
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
element
Selected
element
:
{
name
}
)
;
let
pickPromise
=
provider
.
promisePick
(
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
)
;
let
[
result
pickedElement
]
=
await
pickPromise
;
Assert
.
equal
(
result
row
.
result
"
Picked
result
"
)
;
Assert
.
equal
(
pickedElement
element
"
Picked
element
"
)
;
}
}
)
;
}
)
;
add_task
(
async
function
shouldNavigate
(
)
{
class
TestShouldNavigateProvider
extends
TestProvider
{
async
startQuery
(
context
addCallback
)
{
for
(
let
result
of
this
.
_results
)
{
result
.
payload
.
searchString
=
context
.
searchString
;
result
.
payload
.
shouldNavigate
=
true
;
result
.
payload
.
url
=
DUMMY_PAGE
;
addCallback
(
this
result
)
;
}
}
}
await
withDynamicTypeProvider
(
async
provider
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
Assert
.
equal
(
row
.
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
"
row
.
result
.
type
"
)
;
let
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
selectable
)
;
Assert
.
ok
(
element
"
Sanity
check
element
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
repeat
:
1
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
element
Selected
element
:
{
name
}
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
is
(
gBrowser
.
currentURI
.
spec
DUMMY_PAGE
"
We
navigated
to
payload
.
url
when
result
selected
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
"
about
:
home
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
false
"
about
:
home
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
test
"
waitForFocus
:
SimpleTest
.
waitForFocus
}
)
;
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
1
)
;
element
=
row
.
querySelector
(
.
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
selectable
)
;
EventUtils
.
synthesizeMouseAtCenter
(
element
{
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
is
(
gBrowser
.
currentURI
.
spec
DUMMY_PAGE
"
We
navigated
to
payload
.
url
when
result
is
clicked
"
)
;
}
new
TestShouldNavigateProvider
(
)
)
;
}
)
;
class
TestProvider
extends
UrlbarTestUtils
.
TestProvider
{
constructor
(
)
{
super
(
{
results
:
[
Object
.
assign
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
dynamicType
:
DYNAMIC_TYPE_NAME
}
)
{
suggestedIndex
:
1
}
)
]
}
)
;
}
async
startQuery
(
context
addCallback
)
{
for
(
let
result
of
this
.
_results
)
{
result
.
payload
.
searchString
=
context
.
searchString
;
addCallback
(
this
result
)
;
}
}
getViewUpdate
(
result
idsByName
)
{
for
(
let
child
of
DYNAMIC_TYPE_VIEW_TEMPLATE
.
children
)
{
Assert
.
ok
(
idsByName
.
get
(
child
.
name
)
idsByName
contains
{
child
.
name
}
)
;
}
return
{
selectable
:
{
textContent
:
"
Selectable
"
attributes
:
{
searchString
:
result
.
payload
.
searchString
}
}
text
:
{
textContent
:
result
.
payload
.
searchString
is
:
{
result
.
payload
.
searchString
}
attributes
:
{
searchString
:
result
.
payload
.
searchString
}
}
button1
:
{
textContent
:
"
Button
1
"
attributes
:
{
searchString
:
result
.
payload
.
searchString
}
}
button2
:
{
textContent
:
"
Button
2
"
attributes
:
{
searchString
:
result
.
payload
.
searchString
}
}
}
;
}
pickResult
(
result
element
)
{
if
(
this
.
_pickPromiseResolve
)
{
this
.
_pickPromiseResolve
(
[
result
element
]
)
;
delete
this
.
_pickPromiseResolve
;
delete
this
.
_pickPromise
;
}
}
promisePick
(
)
{
this
.
_pickPromise
=
new
Promise
(
resolve
=
>
{
this
.
_pickPromiseResolve
=
resolve
;
}
)
;
return
this
.
_pickPromise
;
}
}
async
function
withDynamicTypeProvider
(
callback
provider
=
new
TestProvider
(
)
)
{
UrlbarResult
.
addDynamicResultType
(
DYNAMIC_TYPE_NAME
)
;
UrlbarView
.
addDynamicViewTemplate
(
DYNAMIC_TYPE_NAME
DYNAMIC_TYPE_VIEW_TEMPLATE
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
await
callback
(
provider
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
UrlbarView
.
removeDynamicViewTemplate
(
DYNAMIC_TYPE_NAME
)
;
UrlbarResult
.
removeDynamicResultType
(
DYNAMIC_TYPE_NAME
)
;
}
function
checkDOM
(
parentNode
expectedChildren
)
{
info
(
checkDOM
:
Checking
parentNode
id
=
{
parentNode
.
id
}
className
=
{
parentNode
.
className
}
)
;
for
(
let
i
=
0
;
i
<
expectedChildren
.
length
;
i
+
+
)
{
let
child
=
expectedChildren
[
i
]
;
let
actualChild
=
parentNode
.
children
[
i
]
;
info
(
checkDOM
:
Checking
expected
child
:
{
JSON
.
stringify
(
child
)
}
)
;
Assert
.
ok
(
actualChild
"
actualChild
should
exist
"
)
;
Assert
.
equal
(
actualChild
.
tagName
child
.
tag
"
child
.
tag
"
)
;
Assert
.
equal
(
actualChild
.
getAttribute
(
"
name
"
)
child
.
name
"
child
.
name
"
)
;
Assert
.
ok
(
actualChild
.
classList
.
contains
(
urlbarView
-
dynamic
-
{
DYNAMIC_TYPE_NAME
}
-
{
child
.
name
}
)
"
child
.
name
should
be
in
classList
"
)
;
Assert
.
ok
(
actualChild
.
id
.
startsWith
(
"
urlbarView
-
row
-
"
)
)
;
Assert
.
ok
(
actualChild
.
id
.
endsWith
(
child
.
name
)
"
The
child
was
assigned
the
correct
ID
.
"
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
child
.
attributes
|
|
{
}
)
)
{
Assert
.
equal
(
actualChild
.
getAttribute
(
name
)
value
attribute
:
{
name
}
)
;
}
for
(
let
name
of
child
.
classList
|
|
[
]
)
{
Assert
.
ok
(
actualChild
.
classList
.
contains
(
name
)
classList
:
{
name
}
)
;
}
if
(
child
.
children
)
{
checkDOM
(
actualChild
child
.
children
)
;
}
}
}
