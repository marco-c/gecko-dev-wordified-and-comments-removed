"
use
strict
"
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
requestLongerTimeout
(
3
)
;
}
add_task
(
async
function
init
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
experimental
.
hideHeuristic
"
true
]
[
"
browser
.
urlbar
.
suggest
.
quickactions
"
false
]
]
}
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
extension
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
withVisits
(
async
visitURLs
=
>
{
let
url
=
"
http
:
/
/
example
.
com
/
extension
-
test
"
;
let
provider
=
new
UrlbarTestUtils
.
TestProvider
(
{
name
:
"
ExtensionTest
"
type
:
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
results
:
[
Object
.
assign
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
url
title
:
"
Test
"
}
)
{
heuristic
:
true
}
)
]
}
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
let
heuristic
=
await
search
(
{
value
:
"
test
"
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_EXTENSION
}
)
;
Assert
.
equal
(
heuristic
.
payload
.
url
url
"
Heuristic
URL
is
correct
"
)
;
await
checkVisitResults
(
visitURLs
)
;
await
synthesizeEnterAndAwaitLoad
(
url
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
omnibox
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
omnibox
:
{
keyword
:
"
omniboxtest
"
}
}
background
(
)
{
browser
.
omnibox
.
onInputEntered
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
onInputEntered
"
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
let
heuristic
=
await
search
(
{
value
:
"
omniboxtest
foo
"
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_OMNIBOX
}
)
;
Assert
.
equal
(
heuristic
.
payload
.
keyword
"
omniboxtest
"
"
Heuristic
keyword
is
correct
"
)
;
let
messagePromise
=
extension
.
awaitMessage
(
"
onInputEntered
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
messagePromise
;
await
extension
.
unload
(
)
;
}
)
;
}
)
;
add_task
(
async
function
searchTip
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
searchTips
.
test
.
ignoreShowLimits
"
true
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
window
.
gBrowser
url
:
"
about
:
newtab
"
waitForLoad
:
false
}
async
(
)
=
>
{
await
UrlbarTestUtils
.
promisePopupOpen
(
window
(
)
=
>
{
}
)
;
Assert
.
ok
(
true
"
View
opened
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
1
)
;
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
0
)
;
Assert
.
equal
(
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
;
Assert
.
ok
(
result
.
heuristic
)
;
Assert
.
ok
(
UrlbarTestUtils
.
getSelectedElement
(
window
)
"
Selection
exists
"
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
engineAlias
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
withVisits
(
async
visitURLs
=
>
{
await
withEngine
(
{
keyword
:
"
test
"
}
async
(
)
=
>
{
let
heuristic
=
await
search
(
{
value
:
"
test
foo
"
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_FALLBACK
}
)
;
Assert
.
equal
(
heuristic
.
payload
.
engine
"
Example
"
"
Heuristic
engine
is
correct
"
)
;
Assert
.
equal
(
heuristic
.
payload
.
query
"
foo
"
"
Heuristic
query
is
correct
"
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
"
Example
"
entry
:
"
typed
"
}
)
;
await
checkVisitResults
(
visitURLs
)
;
await
synthesizeEnterAndAwaitLoad
(
"
https
:
/
/
example
.
com
/
?
q
=
foo
"
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
bookmarkKeyword
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
withVisits
(
async
visitURLs
=
>
{
let
keyword
=
"
bm
"
;
let
bm
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
url
:
"
http
:
/
/
example
.
com
/
?
q
=
%
s
"
title
:
"
test
"
}
)
;
await
PlacesUtils
.
keywords
.
insert
(
{
keyword
url
:
bm
.
url
}
)
;
let
heuristic
=
await
search
(
{
value
:
"
bm
foo
"
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_BOOKMARK_KEYWORD
}
)
;
Assert
.
equal
(
heuristic
.
payload
.
keyword
keyword
"
Heuristic
keyword
is
correct
"
)
;
let
heuristicURL
=
"
http
:
/
/
example
.
com
/
?
q
=
foo
"
;
Assert
.
equal
(
heuristic
.
payload
.
url
heuristicURL
"
Heuristic
URL
is
correct
"
)
;
await
checkVisitResults
(
visitURLs
)
;
await
synthesizeEnterAndAwaitLoad
(
heuristicURL
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
window
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
autofill
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
withVisits
(
async
visitURLs
=
>
{
let
heuristic
=
await
search
(
{
value
:
"
ex
"
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_AUTOFILL
}
)
;
Assert
.
ok
(
heuristic
.
autofill
"
Heuristic
is
autofill
"
)
;
let
heuristicURL
=
"
http
:
/
/
example
.
com
/
"
;
Assert
.
equal
(
heuristic
.
payload
.
url
heuristicURL
"
Heuristic
URL
is
correct
"
)
;
Assert
.
equal
(
gURLBar
.
value
"
example
.
com
/
"
"
Input
has
been
autofilled
"
)
;
await
checkVisitResults
(
visitURLs
)
;
await
synthesizeEnterAndAwaitLoad
(
heuristicURL
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
fallback_unknownURL
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
let
url
=
"
http
:
/
/
example
.
com
/
unknown
-
url
"
;
let
heuristic
=
await
search
(
{
value
:
url
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_FALLBACK
}
)
;
Assert
.
equal
(
heuristic
.
payload
.
url
url
"
Heuristic
URL
is
correct
"
)
;
await
synthesizeEnterAndAwaitLoad
(
url
)
;
}
)
;
}
)
;
add_task
(
async
function
fallback_searchRestrictionToken
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
withVisits
(
async
visitURLs
=
>
{
await
withEngine
(
{
makeDefault
:
true
}
async
(
)
=
>
{
let
heuristic
=
await
search
(
{
value
:
UrlbarTokenizer
.
RESTRICT
.
SEARCH
+
"
foo
"
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_FALLBACK
}
)
;
Assert
.
equal
(
heuristic
.
payload
.
engine
"
Example
"
"
Heuristic
engine
is
correct
"
)
;
Assert
.
equal
(
heuristic
.
payload
.
query
"
foo
"
"
Heuristic
query
is
correct
"
)
;
await
UrlbarTestUtils
.
assertSearchMode
(
window
{
engineName
:
"
Example
"
entry
:
"
typed
"
}
)
;
await
checkVisitResults
(
visitURLs
)
;
await
synthesizeEnterAndAwaitLoad
(
"
https
:
/
/
example
.
com
/
?
q
=
foo
"
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
window
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
fallback_search
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
withVisits
(
async
visitURLs
=
>
{
await
withEngine
(
{
makeDefault
:
true
}
async
(
)
=
>
{
let
heuristic
=
await
search
(
{
value
:
"
foo
"
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_FALLBACK
}
)
;
Assert
.
equal
(
heuristic
.
payload
.
engine
"
Example
"
"
Heuristic
engine
is
correct
"
)
;
Assert
.
equal
(
heuristic
.
payload
.
query
"
foo
"
"
Heuristic
query
is
correct
"
)
;
await
checkVisitResults
(
visitURLs
)
;
await
synthesizeEnterAndAwaitLoad
(
"
https
:
/
/
example
.
com
/
?
q
=
foo
"
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
window
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
pickNonHeuristic
(
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
withVisits
(
async
visitURLs
=
>
{
let
heuristic
=
await
search
(
{
value
:
"
ex
"
expectedGroup
:
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_AUTOFILL
}
)
;
Assert
.
ok
(
heuristic
.
autofill
"
Heuristic
is
autofill
"
)
;
Assert
.
equal
(
heuristic
.
payload
.
url
"
http
:
/
/
example
.
com
/
"
"
Heuristic
URL
is
correct
"
)
;
Assert
.
notEqual
(
heuristic
.
payload
.
url
visitURLs
[
0
]
"
Sanity
check
:
Heuristic
and
first
results
have
different
URLs
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
await
synthesizeEnterAndAwaitLoad
(
visitURLs
[
0
]
)
;
}
)
;
}
)
;
}
)
;
async
function
withVisits
(
callback
)
{
let
urls
=
[
]
;
for
(
let
i
=
0
;
i
<
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
i
+
+
)
{
urls
.
push
(
"
http
:
/
/
example
.
com
/
foo
/
"
+
i
)
;
}
await
PlacesTestUtils
.
addVisits
(
urls
)
;
urls
.
reverse
(
)
;
await
callback
(
urls
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
async
function
withEngine
(
{
keyword
=
undefined
makeDefault
=
false
}
callback
)
{
await
SearchTestUtils
.
installSearchExtension
(
{
keyword
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
Example
"
)
;
let
originalEngine
;
if
(
makeDefault
)
{
originalEngine
=
await
Services
.
search
.
getDefault
(
)
;
await
Services
.
search
.
setDefault
(
engine
)
;
}
await
callback
(
)
;
if
(
originalEngine
)
{
await
Services
.
search
.
setDefault
(
originalEngine
)
;
}
await
Services
.
search
.
removeEngine
(
engine
)
;
}
async
function
checkVisitResults
(
expectedURLs
)
{
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
expectedURLs
.
length
"
The
view
has
other
results
"
)
;
for
(
let
i
=
0
;
i
<
expectedURLs
.
length
;
i
+
+
)
{
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
Assert
.
equal
(
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
URL
"
Other
result
type
is
correct
at
index
"
+
i
)
;
Assert
.
equal
(
result
.
source
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
"
Other
result
source
is
correct
at
index
"
+
i
)
;
Assert
.
equal
(
result
.
url
expectedURLs
[
i
]
"
Other
result
URL
is
correct
at
index
"
+
i
)
;
}
}
async
function
search
(
{
value
expectedGroup
}
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
waitForFocus
value
fireInputEvent
:
true
}
)
;
let
{
_resultForCurrentValue
:
result
}
=
gURLBar
;
Assert
.
ok
(
result
"
_resultForCurrentValue
is
defined
"
)
;
Assert
.
ok
(
result
.
heuristic
"
_resultForCurrentValue
.
heuristic
is
true
"
)
;
Assert
.
equal
(
UrlbarUtils
.
getResultGroup
(
result
)
expectedGroup
"
_resultForCurrentValue
has
expected
group
"
)
;
Assert
.
ok
(
!
UrlbarTestUtils
.
getSelectedElement
(
window
)
"
No
selection
exists
"
)
;
return
result
;
}
async
function
synthesizeEnterAndAwaitLoad
(
expectedURL
)
{
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
false
expectedURL
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
loadPromise
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
