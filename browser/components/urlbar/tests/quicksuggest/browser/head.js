"
use
strict
"
;
let
sandbox
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
browser
/
components
/
urlbar
/
tests
/
browser
/
head
-
common
.
js
"
this
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
CONTEXTUAL_SERVICES_PING_TYPES
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
sys
.
mjs
"
QuickSuggest
:
"
resource
:
/
/
/
modules
/
QuickSuggest
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
QuickSuggestTestUtils
"
(
)
=
>
{
const
{
QuickSuggestTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
QuickSuggestTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
MerinoTestUtils
"
(
)
=
>
{
const
{
MerinoTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MerinoTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
PlacesFrecencyRecalculator
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
places
/
frecency
-
recalculator
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
wrappedJSObject
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
)
;
async
function
updateTopSites
(
condition
searchShortcuts
=
false
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
newtabpage
.
activity
-
stream
.
discoverystream
.
endpointSpocsClear
"
"
"
]
[
"
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
system
.
topsites
"
false
]
[
"
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
system
.
topsites
"
true
]
[
"
browser
.
newtabpage
.
activity
-
stream
.
improvesearch
.
topSiteSearchShortcuts
"
searchShortcuts
]
]
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
sites
=
AboutNewTab
.
getTopSites
(
)
;
return
condition
(
sites
)
;
}
"
Waiting
for
top
sites
to
be
updated
"
)
;
}
async
function
setUpTelemetryTest
(
{
remoteSettingsRecords
merinoSuggestions
=
null
config
=
QuickSuggestTestUtils
.
DEFAULT_CONFIG
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
openpage
"
false
]
]
}
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
)
;
await
SearchTestUtils
.
installSearchExtension
(
{
}
{
setAsDefault
:
true
}
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsRecords
merinoSuggestions
config
}
)
;
}
async
function
doTelemetryTest
(
{
index
suggestion
impressionOnly
click
commands
providerName
=
UrlbarProviderQuickSuggest
.
name
teardown
=
null
showSuggestion
=
(
)
=
>
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
suggestion
.
keywords
?
.
[
0
]
|
|
"
test
"
fireInputEvent
:
true
}
)
}
)
{
Services
.
telemetry
.
clearScalars
(
)
;
Services
.
telemetry
.
clearEvents
(
)
;
await
doImpressionOnlyTest
(
{
index
suggestion
providerName
showSuggestion
expected
:
impressionOnly
}
)
;
await
doClickTest
(
{
suggestion
providerName
showSuggestion
index
expected
:
click
}
)
;
for
(
let
command
of
commands
)
{
await
doCommandTest
(
{
suggestion
providerName
showSuggestion
index
commandOrArray
:
command
.
command
expected
:
command
}
)
;
if
(
teardown
)
{
info
(
"
Calling
teardown
"
)
;
await
teardown
(
)
;
info
(
"
Finished
teardown
"
)
;
}
}
}
async
function
doImpressionOnlyTest
(
{
index
suggestion
providerName
expected
showSuggestion
}
)
{
info
(
"
Starting
impression
-
only
test
"
)
;
Services
.
telemetry
.
clearEvents
(
)
;
let
expectedPings
=
expected
.
ping
?
[
expected
.
ping
]
:
[
]
;
let
gleanPingCount
=
watchGleanPings
(
expectedPings
)
;
info
(
"
Showing
suggestion
"
)
;
await
showSuggestion
(
)
;
let
row
=
await
validateSuggestionRow
(
index
suggestion
providerName
)
;
if
(
!
row
)
{
Assert
.
ok
(
false
"
Couldn
'
t
get
suggestion
row
stopping
impression
-
only
test
"
)
;
return
;
}
let
otherRow
;
let
rowCount
=
UrlbarTestUtils
.
getResultCount
(
window
)
;
for
(
let
i
=
0
;
i
<
rowCount
;
i
+
+
)
{
if
(
i
!
=
index
)
{
let
r
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
i
)
;
Assert
.
notEqual
(
r
.
result
.
providerName
providerName
"
No
other
row
should
be
from
expected
provider
:
index
=
"
+
i
)
;
if
(
!
otherRow
&
&
(
r
.
result
.
payload
.
url
|
|
(
r
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
(
r
.
result
.
payload
.
query
|
|
r
.
result
.
payload
.
suggestion
)
)
)
&
&
r
.
hasAttribute
(
"
row
-
selectable
"
)
)
{
otherRow
=
r
;
}
}
}
if
(
!
otherRow
)
{
Assert
.
ok
(
false
"
Couldn
'
t
get
a
different
selectable
row
with
a
URL
stopping
impression
-
only
test
"
)
;
return
;
}
info
(
"
Clicking
different
row
and
waiting
for
view
to
close
"
)
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeMouseAtCenter
(
otherRow
{
}
)
)
;
info
(
"
Waiting
for
page
to
load
after
clicking
different
row
"
)
;
await
loadPromise
;
info
(
"
Checking
scalars
.
Expected
:
"
+
JSON
.
stringify
(
expected
.
scalars
)
)
;
QuickSuggestTestUtils
.
assertScalars
(
expected
.
scalars
)
;
info
(
"
Checking
events
.
Expected
:
"
+
JSON
.
stringify
(
[
expected
.
event
]
)
)
;
QuickSuggestTestUtils
.
assertEvents
(
[
expected
.
event
]
)
;
Assert
.
equal
(
expectedPings
.
length
gleanPingCount
.
value
"
Submitted
one
Glean
ping
per
expected
ping
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
)
;
info
(
"
Finished
impression
-
only
test
"
)
;
}
async
function
doClickTest
(
{
index
suggestion
providerName
expected
showSuggestion
}
)
{
info
(
"
Starting
click
test
"
)
;
Services
.
telemetry
.
clearEvents
(
)
;
let
expectedPings
=
expected
.
pings
?
?
[
]
;
let
gleanPingCount
=
watchGleanPings
(
expectedPings
)
;
info
(
"
Showing
suggestion
"
)
;
await
showSuggestion
(
)
;
let
row
=
await
validateSuggestionRow
(
index
suggestion
providerName
)
;
if
(
!
row
)
{
Assert
.
ok
(
false
"
Couldn
'
t
get
suggestion
row
stopping
click
test
"
)
;
return
;
}
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
info
(
"
Clicking
row
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
row
{
}
)
;
info
(
"
Waiting
for
load
"
)
;
await
loadPromise
;
await
TestUtils
.
waitForTick
(
)
;
info
(
"
Checking
scalars
.
Expected
:
"
+
JSON
.
stringify
(
expected
.
scalars
)
)
;
QuickSuggestTestUtils
.
assertScalars
(
expected
.
scalars
)
;
info
(
"
Checking
events
.
Expected
:
"
+
JSON
.
stringify
(
[
expected
.
event
]
)
)
;
QuickSuggestTestUtils
.
assertEvents
(
[
expected
.
event
]
)
;
Assert
.
equal
(
expectedPings
.
length
gleanPingCount
.
value
"
Submitted
one
Glean
ping
per
expected
ping
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
info
(
"
Finished
click
test
"
)
;
}
async
function
doCommandTest
(
{
index
suggestion
providerName
commandOrArray
expected
showSuggestion
}
)
{
info
(
"
Starting
command
test
:
"
+
JSON
.
stringify
(
{
commandOrArray
}
)
)
;
Services
.
telemetry
.
clearEvents
(
)
;
let
expectedPings
=
expected
.
pings
?
?
[
]
;
let
gleanPingCount
=
watchGleanPings
(
expectedPings
)
;
info
(
"
Showing
suggestion
"
)
;
await
showSuggestion
(
)
;
let
row
=
await
validateSuggestionRow
(
index
suggestion
providerName
)
;
if
(
!
row
)
{
Assert
.
ok
(
false
"
Couldn
'
t
get
suggestion
row
stopping
click
test
"
)
;
return
;
}
let
command
=
typeof
commandOrArray
=
=
"
string
"
?
commandOrArray
:
commandOrArray
[
commandOrArray
.
length
-
1
]
;
let
loadPromise
;
if
(
command
=
=
"
help
"
)
{
loadPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
)
;
}
info
(
"
Clicking
command
"
)
;
await
UrlbarTestUtils
.
openResultMenuAndClickItem
(
window
commandOrArray
{
resultIndex
:
index
openByMouse
:
true
}
)
;
if
(
loadPromise
)
{
info
(
"
Waiting
for
load
"
)
;
await
loadPromise
;
await
TestUtils
.
waitForTick
(
)
;
if
(
command
=
=
"
help
"
)
{
info
(
"
Closing
help
tab
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
}
info
(
"
Checking
scalars
.
Expected
:
"
+
JSON
.
stringify
(
expected
.
scalars
)
)
;
QuickSuggestTestUtils
.
assertScalars
(
expected
.
scalars
)
;
info
(
"
Checking
events
.
Expected
:
"
+
JSON
.
stringify
(
[
expected
.
event
]
)
)
;
QuickSuggestTestUtils
.
assertEvents
(
[
expected
.
event
]
)
;
Assert
.
equal
(
expectedPings
.
length
gleanPingCount
.
value
"
Submitted
one
Glean
ping
per
expected
ping
"
)
;
if
(
command
=
=
"
dismiss
"
)
{
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
}
await
PlacesUtils
.
history
.
clear
(
)
;
info
(
"
Finished
command
test
:
"
+
JSON
.
stringify
(
{
commandOrArray
}
)
)
;
}
async
function
doManageTest
(
{
index
input
}
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
}
async
browser
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
input
}
)
;
const
managePage
=
"
about
:
preferences
#
search
"
;
let
onManagePageLoaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
managePage
)
;
await
UrlbarTestUtils
.
openResultMenuAndClickItem
(
window
"
manage
"
{
resultIndex
:
index
}
)
;
await
onManagePageLoaded
;
Assert
.
equal
(
browser
.
currentURI
.
spec
managePage
"
The
manage
page
is
loaded
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
)
;
}
async
function
validateSuggestionRow
(
index
suggestion
providerName
)
{
let
rowCount
=
UrlbarTestUtils
.
getResultCount
(
window
)
;
Assert
.
less
(
index
rowCount
"
Expected
suggestion
row
index
should
be
<
row
count
"
)
;
if
(
rowCount
<
=
index
)
{
return
null
;
}
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
index
)
;
Assert
.
equal
(
row
.
result
.
providerName
providerName
"
Expected
suggestion
row
should
be
from
expected
provider
"
)
;
Assert
.
equal
(
row
.
result
.
payload
.
url
suggestion
.
url
"
The
suggestion
row
should
represent
the
expected
suggestion
"
)
;
if
(
row
.
result
.
providerName
!
=
providerName
|
|
row
.
result
.
payload
.
url
!
=
suggestion
.
url
)
{
return
null
;
}
return
row
;
}
function
watchGleanPings
(
pings
)
{
let
countObject
=
{
value
:
0
}
;
let
checkPing
=
(
ping
next
)
=
>
{
countObject
.
value
+
+
;
_assertGleanPing
(
ping
)
;
if
(
next
)
{
GleanPings
.
quickSuggest
.
testBeforeNextSubmit
(
next
)
;
}
}
;
let
next
=
undefined
;
pings
.
slice
(
)
.
reverse
(
)
.
forEach
(
ping
=
>
{
next
=
checkPing
.
bind
(
null
ping
next
)
;
}
)
;
if
(
next
)
{
GleanPings
.
quickSuggest
.
testBeforeNextSubmit
(
next
)
;
}
return
countObject
;
}
function
_assertGleanPing
(
ping
)
{
Assert
.
equal
(
Glean
.
quickSuggest
.
pingType
.
testGetValue
(
)
ping
.
type
)
;
const
keymap
=
{
source
:
Glean
.
quickSuggest
.
source
match_type
:
Glean
.
quickSuggest
.
matchType
position
:
Glean
.
quickSuggest
.
position
suggested_index
:
Glean
.
quickSuggest
.
suggestedIndex
suggested_index_relative_to_group
:
Glean
.
quickSuggest
.
suggestedIndexRelativeToGroup
improve_suggest_experience_checked
:
Glean
.
quickSuggest
.
improveSuggestExperience
block_id
:
Glean
.
quickSuggest
.
blockId
advertiser
:
Glean
.
quickSuggest
.
advertiser
request_id
:
Glean
.
quickSuggest
.
requestId
context_id
:
Glean
.
quickSuggest
.
contextId
reporting_url
:
Glean
.
quickSuggest
.
reportingUrl
is_clicked
:
Glean
.
quickSuggest
.
isClicked
iab_category
:
Glean
.
quickSuggest
.
iabCategory
}
;
for
(
let
[
key
value
]
of
Object
.
entries
(
ping
.
payload
)
)
{
Assert
.
ok
(
key
in
keymap
A
Glean
metric
exists
for
field
{
key
}
)
;
if
(
value
=
=
=
"
"
)
{
value
=
null
;
}
Assert
.
equal
(
keymap
[
key
]
.
testGetValue
(
)
value
?
?
null
Glean
metric
field
{
key
}
should
be
the
expected
value
)
;
}
}
let
gAddTasksWithRustSetup
;
function
add_tasks_with_rust
(
.
.
.
args
)
{
let
skipIfRustEnabled
=
false
;
let
i
=
args
.
findIndex
(
a
=
>
a
.
skip_if_rust_enabled
)
;
if
(
i
>
=
0
)
{
skipIfRustEnabled
=
true
;
args
.
splice
(
i
1
)
;
}
let
taskFnIndex
=
args
.
findIndex
(
a
=
>
typeof
a
=
=
"
function
"
)
;
let
taskFn
=
args
[
taskFnIndex
]
;
for
(
let
rustEnabled
of
[
false
true
]
)
{
let
newTaskName
=
(
taskFn
.
name
|
|
"
anonymousTask
"
)
+
(
rustEnabled
?
"
_rustEnabled
"
:
"
_rustDisabled
"
)
;
if
(
rustEnabled
&
&
skipIfRustEnabled
)
{
info
(
"
add_tasks_with_rust
:
Skipping
due
to
skip_if_rust_enabled
:
"
+
newTaskName
)
;
continue
;
}
let
newTaskFn
=
async
(
.
.
.
taskFnArgs
)
=
>
{
info
(
"
add_tasks_with_rust
:
Setting
rustEnabled
:
"
+
rustEnabled
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
rustEnabled
)
;
info
(
"
add_tasks_with_rust
:
Done
setting
rustEnabled
:
"
+
rustEnabled
)
;
info
(
"
add_tasks_with_rust
:
Forcing
sync
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
add_tasks_with_rust
:
Done
forcing
sync
"
)
;
if
(
gAddTasksWithRustSetup
)
{
info
(
"
add_tasks_with_rust
:
Calling
setup
function
"
)
;
await
gAddTasksWithRustSetup
(
)
;
info
(
"
add_tasks_with_rust
:
Done
calling
setup
function
"
)
;
}
let
rv
;
try
{
info
(
"
add_tasks_with_rust
:
Calling
original
task
function
:
"
+
taskFn
.
name
)
;
rv
=
await
taskFn
(
.
.
.
taskFnArgs
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_ABORT
)
{
Assert
.
ok
(
false
"
add_tasks_with_rust
:
The
original
task
function
threw
an
error
:
"
+
e
)
;
}
throw
e
;
}
finally
{
info
(
"
add_tasks_with_rust
:
Done
calling
original
task
function
:
"
+
taskFn
.
name
)
;
info
(
"
add_tasks_with_rust
:
Clearing
rustEnabled
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
info
(
"
add_tasks_with_rust
:
Done
clearing
rustEnabled
"
)
;
info
(
"
add_tasks_with_rust
:
Forcing
sync
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
add_tasks_with_rust
:
Done
forcing
sync
"
)
;
}
return
rv
;
}
;
Object
.
defineProperty
(
newTaskFn
"
name
"
{
value
:
newTaskName
}
)
;
let
addTaskArgs
=
[
]
;
for
(
let
j
=
0
;
j
<
args
.
length
;
j
+
+
)
{
addTaskArgs
[
j
]
=
j
=
=
taskFnIndex
?
newTaskFn
:
Cu
.
cloneInto
(
args
[
j
]
this
{
cloneFunctions
:
true
}
)
;
}
add_task
(
.
.
.
addTaskArgs
)
;
}
}
function
registerAddTasksWithRustSetup
(
setupFn
)
{
gAddTasksWithRustSetup
=
setupFn
;
registerCleanupFunction
(
(
)
=
>
(
gAddTasksWithRustSetup
=
null
)
)
;
}
