"
use
strict
"
;
let
sandbox
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
browser
/
components
/
urlbar
/
tests
/
browser
/
head
-
common
.
js
"
this
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
CONTEXTUAL_SERVICES_PING_TYPES
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
QuickSuggest
:
"
resource
:
/
/
/
modules
/
QuickSuggest
.
sys
.
mjs
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
QuickSuggestTestUtils
"
(
)
=
>
{
const
{
QuickSuggestTestUtils
:
Utils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
QuickSuggestTestUtils
.
sys
.
mjs
"
)
;
return
new
Utils
(
this
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MerinoTestUtils
"
(
)
=
>
{
const
{
MerinoTestUtils
:
Utils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MerinoTestUtils
.
sys
.
mjs
"
)
;
return
new
Utils
(
this
)
;
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
)
;
async
function
setUpTelemetryTest
(
{
suggestions
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
quicksuggest
.
blockingEnabled
"
true
]
[
"
browser
.
urlbar
.
bestMatch
.
blockingEnabled
"
true
]
[
"
browser
.
urlbar
.
suggest
.
openpage
"
false
]
[
"
browser
.
urlbar
.
tipShownCount
.
searchTip_persist
"
999
]
]
}
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
)
;
Services
.
telemetry
.
clearScalars
(
)
;
Services
.
telemetry
.
clearEvents
(
)
;
await
SearchTestUtils
.
installSearchExtension
(
{
}
{
setAsDefault
:
true
}
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
suggestions
)
;
}
async
function
doTelemetryTest
(
{
index
suggestion
impressionOnly
selectables
showSuggestion
=
(
)
=
>
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
suggestion
.
keywords
[
0
]
fireInputEvent
:
true
}
)
}
)
{
let
selectableClassLists
=
await
doImpressionOnlyTest
(
{
index
suggestion
showSuggestion
expected
:
impressionOnly
}
)
;
if
(
!
selectableClassLists
)
{
Assert
.
ok
(
false
"
Impression
test
didn
'
t
complete
successfully
stopping
telemetry
test
"
)
;
return
;
}
info
(
"
Got
classLists
of
actual
selectable
elements
in
the
row
:
"
+
JSON
.
stringify
(
selectableClassLists
)
)
;
let
allMatchedExpectedClasses
=
new
Set
(
)
;
for
(
let
classList
of
selectableClassLists
)
{
info
(
"
Setting
up
selectable
test
for
actual
element
with
classList
"
+
JSON
.
stringify
(
classList
)
)
;
let
matchingExpectedClasses
=
Object
.
keys
(
selectables
)
.
filter
(
className
=
>
classList
.
includes
(
className
)
)
;
if
(
!
matchingExpectedClasses
.
length
)
{
Assert
.
ok
(
false
"
Actual
selectable
element
doesn
'
t
match
any
expected
classes
.
The
element
'
s
classList
is
"
+
JSON
.
stringify
(
classList
)
)
;
continue
;
}
if
(
matchingExpectedClasses
.
length
>
1
)
{
Assert
.
ok
(
false
"
Actual
selectable
element
matches
multiple
expected
classes
.
The
element
'
s
classList
is
"
+
JSON
.
stringify
(
classList
)
)
;
continue
;
}
let
className
=
matchingExpectedClasses
[
0
]
;
allMatchedExpectedClasses
.
add
(
className
)
;
await
doSelectableTest
(
{
suggestion
showSuggestion
index
className
expected
:
selectables
[
className
]
}
)
;
}
Assert
.
deepEqual
(
Object
.
keys
(
selectables
)
.
filter
(
className
=
>
!
allMatchedExpectedClasses
.
has
(
className
)
)
[
]
"
There
should
be
no
expected
classes
that
didn
'
t
match
actual
selectable
elements
"
)
;
}
async
function
doImpressionOnlyTest
(
{
index
suggestion
expected
showSuggestion
}
)
{
info
(
"
Starting
impression
-
only
test
"
)
;
Services
.
telemetry
.
clearEvents
(
)
;
let
{
spy
spyCleanup
}
=
QuickSuggestTestUtils
.
createTelemetryPingSpy
(
)
;
info
(
"
Showing
suggestion
"
)
;
await
showSuggestion
(
)
;
let
row
=
await
validateSuggestionRow
(
index
suggestion
)
;
if
(
!
row
)
{
Assert
.
ok
(
false
"
Couldn
'
t
get
quick
suggest
row
stopping
impression
-
only
test
"
)
;
await
spyCleanup
(
)
;
return
null
;
}
let
otherRow
;
let
rowCount
=
UrlbarTestUtils
.
getResultCount
(
window
)
;
for
(
let
i
=
0
;
i
<
rowCount
;
i
+
+
)
{
if
(
i
!
=
index
)
{
let
r
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
i
)
;
Assert
.
notEqual
(
r
.
result
.
providerName
UrlbarProviderQuickSuggest
.
name
"
No
other
row
should
be
a
quick
suggest
:
index
=
"
+
i
)
;
otherRow
=
otherRow
|
|
r
;
}
}
if
(
!
otherRow
)
{
Assert
.
ok
(
false
"
Couldn
'
t
get
non
-
quick
-
suggest
row
stopping
impression
-
only
test
"
)
;
await
spyCleanup
(
)
;
return
null
;
}
let
selectableClassLists
=
[
]
;
let
selectables
=
row
.
querySelectorAll
(
"
:
is
(
[
selectable
]
[
role
=
button
]
)
"
)
;
for
(
let
element
of
selectables
)
{
selectableClassLists
.
push
(
[
.
.
.
element
.
classList
]
)
;
}
info
(
"
Clicking
non
-
quick
-
suggest
row
and
waiting
for
view
to
close
"
)
;
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
EventUtils
.
synthesizeMouseAtCenter
(
otherRow
{
}
)
)
;
info
(
"
Waiting
for
page
to
load
after
clicking
non
-
quick
-
suggest
row
"
)
;
await
loadPromise
;
QuickSuggestTestUtils
.
assertScalars
(
expected
.
scalars
)
;
QuickSuggestTestUtils
.
assertEvents
(
[
expected
.
event
]
)
;
QuickSuggestTestUtils
.
assertPings
(
spy
[
expected
.
ping
]
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
)
;
await
spyCleanup
(
)
;
return
selectableClassLists
;
}
async
function
doSelectableTest
(
{
index
suggestion
className
expected
showSuggestion
}
)
{
info
(
"
Starting
selectable
test
:
"
+
JSON
.
stringify
(
{
className
}
)
)
;
Services
.
telemetry
.
clearEvents
(
)
;
let
{
spy
spyCleanup
}
=
QuickSuggestTestUtils
.
createTelemetryPingSpy
(
)
;
await
showSuggestion
(
)
;
let
row
=
await
validateSuggestionRow
(
index
suggestion
)
;
if
(
!
row
)
{
Assert
.
ok
(
false
"
Couldn
'
t
get
quick
suggest
row
stopping
selectable
test
"
)
;
await
spyCleanup
(
)
;
return
;
}
let
element
=
row
.
querySelector
(
"
.
"
+
className
)
;
Assert
.
ok
(
element
"
Sanity
check
:
Target
selectable
element
should
exist
"
)
;
let
helpLoadPromise
;
if
(
className
=
=
"
urlbarView
-
button
-
help
"
)
{
helpLoadPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
)
;
}
EventUtils
.
synthesizeMouseAtCenter
(
element
{
}
)
;
QuickSuggestTestUtils
.
assertScalars
(
expected
.
scalars
)
;
QuickSuggestTestUtils
.
assertEvents
(
[
expected
.
event
]
)
;
QuickSuggestTestUtils
.
assertPings
(
spy
expected
.
pings
)
;
if
(
helpLoadPromise
)
{
await
helpLoadPromise
;
await
TestUtils
.
waitForTick
(
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
if
(
className
=
=
"
urlbarView
-
button
-
block
"
)
{
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
}
await
PlacesUtils
.
history
.
clear
(
)
;
await
spyCleanup
(
)
;
}
async
function
validateSuggestionRow
(
index
suggestion
)
{
let
rowCount
=
UrlbarTestUtils
.
getResultCount
(
window
)
;
Assert
.
less
(
index
rowCount
"
Expected
quick
suggest
row
index
should
be
<
row
count
"
)
;
if
(
rowCount
<
=
index
)
{
return
null
;
}
let
row
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
index
)
;
Assert
.
equal
(
row
.
result
.
providerName
UrlbarProviderQuickSuggest
.
name
"
Expected
quick
suggest
row
should
actually
be
a
quick
suggest
"
)
;
Assert
.
equal
(
row
.
result
.
payload
.
url
suggestion
.
url
"
The
quick
suggest
row
should
represent
the
expected
suggestion
"
)
;
if
(
row
.
result
.
providerName
!
=
UrlbarProviderQuickSuggest
.
name
|
|
row
.
result
.
payload
.
url
!
=
suggestion
.
url
)
{
return
null
;
}
return
row
;
}
