"
use
strict
"
;
const
SUGGESTIONS_FIRST_PREF
=
"
browser
.
urlbar
.
showSearchSuggestionsFirst
"
;
const
SUGGESTIONS_PREF
=
"
browser
.
urlbar
.
suggest
.
searches
"
;
const
TEST_ENGINE_BASENAME
=
"
searchSuggestionEngine
.
xml
"
;
const
MAX_RESULTS
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
const
SPONSORED_INDEX_PREF
=
"
browser
.
urlbar
.
quicksuggest
.
sponsoredIndex
"
;
const
NON_SPONSORED_INDEX_PREF
=
"
browser
.
urlbar
.
quicksuggest
.
nonSponsoredIndex
"
;
const
SPONSORED_SEARCH_STRING
=
"
frabbits
"
;
const
NON_SPONSORED_SEARCH_STRING
=
"
nonspon
"
;
const
TEST_URL
=
"
http
:
/
/
example
.
com
/
quicksuggest
"
;
const
REMOTE_SETTINGS_RESULTS
=
[
QuickSuggestTestUtils
.
ampRemoteSettings
(
{
keywords
:
[
SPONSORED_SEARCH_STRING
]
}
)
QuickSuggestTestUtils
.
wikipediaRemoteSettings
(
{
keywords
:
[
NON_SPONSORED_SEARCH_STRING
]
}
)
]
;
requestLongerTimeout
(
3
)
;
add_setup
(
async
function
(
)
{
await
PlacesUtils
.
history
.
clear
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
)
;
await
SearchTestUtils
.
installSearchExtension
(
{
}
{
setAsDefault
:
true
}
)
;
let
isAmp
=
suggestion
=
>
suggestion
.
iab_category
=
=
"
22
-
Shopping
"
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsRecords
:
[
{
collection
:
QuickSuggestTestUtils
.
RS_COLLECTION
.
AMP
type
:
QuickSuggestTestUtils
.
RS_TYPE
.
AMP
attachment
:
REMOTE_SETTINGS_RESULTS
.
filter
(
isAmp
)
}
{
collection
:
QuickSuggestTestUtils
.
RS_COLLECTION
.
OTHER
type
:
QuickSuggestTestUtils
.
RS_TYPE
.
WIKIPEDIA
attachment
:
REMOTE_SETTINGS_RESULTS
.
filter
(
s
=
>
!
isAmp
(
s
)
)
}
]
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
}
)
;
add_task
(
async
function
searchSuggestionsFirst_withSuggestions
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
true
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doTestPermutations
(
(
{
withHistory
generalIndex
}
)
=
>
(
{
expectedSuggestedIndex
:
generalIndex
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
4
expectedViewIndex
:
generalIndex
=
=
0
|
|
!
withHistory
?
3
:
MAX_RESULTS
-
1
}
)
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
searchSuggestionsFirst_withoutSuggestions
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
true
]
]
}
)
;
await
doTestPermutations
(
(
{
isSponsored
withHistory
generalIndex
}
)
=
>
(
{
expectedSuggestedIndex
:
isSponsored
?
-
1
:
generalIndex
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
2
expectedViewIndex
:
(
generalIndex
=
=
0
&
&
!
isSponsored
)
|
|
!
withHistory
?
1
:
MAX_RESULTS
-
1
}
)
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
searchSuggestionsFirst_suggestionsDisabled
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
true
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doTestPermutations
(
(
{
isSponsored
withHistory
generalIndex
}
)
=
>
(
{
expectedSuggestedIndex
:
isSponsored
?
-
1
:
generalIndex
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
2
expectedViewIndex
:
(
generalIndex
=
=
0
&
&
!
isSponsored
)
|
|
!
withHistory
?
1
:
MAX_RESULTS
-
1
}
)
)
;
}
false
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
historyFirst_withSuggestions
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
false
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doTestPermutations
(
(
{
isSponsored
withHistory
generalIndex
}
)
=
>
(
{
expectedSuggestedIndex
:
isSponsored
?
-
1
:
generalIndex
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
4
expectedViewIndex
:
(
generalIndex
=
=
0
&
&
!
isSponsored
)
|
|
!
withHistory
?
1
:
MAX_RESULTS
-
3
}
)
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
historyFirst_withoutSuggestions
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
false
]
]
}
)
;
await
doTestPermutations
(
(
{
isSponsored
withHistory
generalIndex
}
)
=
>
(
{
expectedSuggestedIndex
:
isSponsored
?
-
1
:
generalIndex
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
2
expectedViewIndex
:
(
generalIndex
=
=
0
&
&
!
isSponsored
)
|
|
!
withHistory
?
1
:
MAX_RESULTS
-
1
}
)
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
historyFirst_suggestionsDisabled
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
false
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doTestPermutations
(
(
{
isSponsored
withHistory
generalIndex
}
)
=
>
(
{
expectedSuggestedIndex
:
isSponsored
?
-
1
:
generalIndex
expectedResultCount
:
withHistory
?
MAX_RESULTS
:
2
expectedViewIndex
:
(
generalIndex
=
=
0
&
&
!
isSponsored
)
|
|
!
withHistory
?
1
:
MAX_RESULTS
-
1
}
)
)
;
}
false
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
otherSuggestedIndex_noSuggestions
(
)
{
await
doSuggestedIndexTest
(
[
{
heuristic
:
true
}
{
suggestedIndex
:
1
resultSpan
:
2
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
providerName
:
UrlbarProviderQuickSuggest
.
name
}
]
)
;
}
)
;
add_task
(
async
function
otherSuggestedIndex_suggestionsFirst
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
true
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doSuggestedIndexTest
(
[
{
heuristic
:
true
}
{
suggestedIndex
:
1
resultSpan
:
2
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
payload
:
{
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
}
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
payload
:
{
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
}
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
providerName
:
UrlbarProviderQuickSuggest
.
name
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
]
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
otherSuggestedIndex_suggestionsLast
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_FIRST_PREF
false
]
]
}
)
;
await
withSuggestions
(
async
(
)
=
>
{
await
doSuggestedIndexTest
(
[
{
heuristic
:
true
}
{
suggestedIndex
:
1
resultSpan
:
2
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
providerName
:
UrlbarProviderQuickSuggest
.
name
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
payload
:
{
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
}
}
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
payload
:
{
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
}
}
]
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
class
TestProvider
extends
UrlbarTestUtils
.
TestProvider
{
constructor
(
)
{
super
(
{
results
:
[
Object
.
assign
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
url
:
"
http
:
/
/
example
.
com
/
test
"
}
)
{
suggestedIndex
:
1
resultSpan
:
2
}
)
]
}
)
;
}
}
async
function
doTestPermutations
(
callback
)
{
for
(
let
isSponsored
of
[
true
false
]
)
{
for
(
let
withHistory
of
[
true
false
]
)
{
for
(
let
generalIndex
of
[
0
-
1
]
)
{
let
opts
=
{
isSponsored
withHistory
generalIndex
}
;
await
doTest
(
Object
.
assign
(
opts
callback
(
opts
)
)
)
;
}
}
}
}
async
function
doTest
(
{
isSponsored
withHistory
generalIndex
expectedSuggestedIndex
expectedResultCount
expectedViewIndex
}
)
{
info
(
"
Running
test
with
options
:
"
+
JSON
.
stringify
(
{
isSponsored
withHistory
generalIndex
expectedResultCount
expectedViewIndex
}
)
)
;
let
indexPref
=
isSponsored
?
SPONSORED_INDEX_PREF
:
NON_SPONSORED_INDEX_PREF
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
indexPref
generalIndex
]
]
}
)
;
if
(
withHistory
)
{
await
addHistory
(
)
;
}
let
value
=
isSponsored
?
SPONSORED_SEARCH_STRING
:
NON_SPONSORED_SEARCH_STRING
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
}
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
expectedResultCount
"
Expected
result
count
"
)
;
let
details
=
await
QuickSuggestTestUtils
.
assertIsQuickSuggest
(
{
window
isSponsored
index
:
expectedViewIndex
url
:
isSponsored
?
REMOTE_SETTINGS_RESULTS
[
0
]
.
url
:
REMOTE_SETTINGS_RESULTS
[
1
]
.
url
}
)
;
Assert
.
equal
(
details
.
result
.
suggestedIndex
expectedSuggestedIndex
"
Expected
suggestedIndex
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
async
function
addHistory
(
)
{
for
(
let
i
=
0
;
i
<
MAX_RESULTS
;
i
+
+
)
{
await
PlacesTestUtils
.
addVisits
(
[
"
http
:
/
/
example
.
com
/
"
+
SPONSORED_SEARCH_STRING
+
i
"
http
:
/
/
example
.
com
/
"
+
NON_SPONSORED_SEARCH_STRING
+
i
]
)
;
}
}
async
function
withSuggestions
(
callback
enableSuggestions
=
true
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
SUGGESTIONS_PREF
enableSuggestions
]
]
}
)
;
let
engine
=
await
SearchTestUtils
.
installOpenSearchEngine
(
{
url
:
getRootDirectory
(
gTestPath
)
+
TEST_ENGINE_BASENAME
}
)
;
let
oldDefaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
await
Services
.
search
.
setDefault
(
engine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
try
{
await
callback
(
engine
)
;
}
finally
{
await
Services
.
search
.
setDefault
(
oldDefaultEngine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
await
Services
.
search
.
removeEngine
(
engine
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
async
function
doSuggestedIndexTest
(
expectedProps
)
{
await
addHistory
(
)
;
let
provider
=
new
TestProvider
(
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
let
context
=
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
SPONSORED_SEARCH_STRING
}
)
;
checkResults
(
context
.
results
expectedProps
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
function
checkResults
(
actualResults
expectedProps
)
{
Assert
.
equal
(
actualResults
.
length
expectedProps
.
length
"
Expected
result
count
"
)
;
let
actualProps
=
actualResults
.
map
(
(
actual
i
)
=
>
{
if
(
expectedProps
.
length
<
=
i
)
{
return
actual
;
}
let
props
=
{
}
;
let
expected
=
expectedProps
[
i
]
;
for
(
let
[
key
expectedValue
]
of
Object
.
entries
(
expected
)
)
{
if
(
key
!
=
"
payload
"
)
{
props
[
key
]
=
actual
[
key
]
;
}
else
{
props
.
payload
=
{
}
;
for
(
let
pkey
of
Object
.
keys
(
expectedValue
)
)
{
props
.
payload
[
pkey
]
=
actual
.
payload
[
pkey
]
;
}
}
}
return
props
;
}
)
;
Assert
.
deepEqual
(
actualProps
expectedProps
)
;
}
