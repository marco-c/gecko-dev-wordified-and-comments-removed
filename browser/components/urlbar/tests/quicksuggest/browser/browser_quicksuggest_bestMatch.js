"
use
strict
"
;
const
SUGGESTIONS
=
[
1
2
3
]
.
map
(
i
=
>
(
{
id
:
i
title
:
Best
match
{
i
}
url
:
http
:
/
/
example
.
com
/
bestmatch
{
i
}
keywords
:
[
bestmatch
{
i
}
]
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
_test_is_best_match
:
true
}
)
)
;
const
NON_BEST_MATCH_SUGGESTION
=
{
id
:
99
title
:
"
Non
-
best
match
"
url
:
"
http
:
/
/
example
.
com
/
nonbestmatch
"
keywords
:
[
"
non
"
]
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
}
;
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
bestMatch
.
enabled
"
true
]
]
}
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
UrlbarTestUtils
.
formHistory
.
clear
(
)
;
await
UrlbarProviderQuickSuggest
.
_blockTaskQueue
.
emptyPromise
;
await
UrlbarProviderQuickSuggest
.
clearBlockedSuggestions
(
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
SUGGESTIONS
.
concat
(
NON_BEST_MATCH_SUGGESTION
)
)
;
}
)
;
add_task
(
async
function
nimbusExposure_featureEnabled
(
)
{
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
true
bestMatchExpected
:
true
isBestMatchExperiment
:
true
exposureEventExpected
:
true
}
)
;
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
true
bestMatchExpected
:
true
experimentType
:
"
best
-
match
"
exposureEventExpected
:
true
}
)
;
}
)
;
add_task
(
async
function
nimbusExposure_featureEnabled_userDisabled
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
bestmatch
"
false
]
]
}
)
;
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
true
bestMatchExpected
:
false
isBestMatchExperiment
:
true
exposureEventExpected
:
false
}
)
;
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
true
bestMatchExpected
:
false
experimentType
:
"
best
-
match
"
exposureEventExpected
:
false
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
nimbusExposure_featureDisabled
(
)
{
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
false
bestMatchExpected
:
false
isBestMatchExperiment
:
true
exposureEventExpected
:
true
}
)
;
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
false
bestMatchExpected
:
false
experimentType
:
"
best
-
match
"
exposureEventExpected
:
true
}
)
;
}
)
;
add_task
(
async
function
nimbusExposure_notBestMatchExperimentType
(
)
{
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
false
bestMatchExpected
:
false
skipFirstSearch
:
true
experimentType
:
"
"
exposureEventExpected
:
true
}
)
;
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
false
bestMatchExpected
:
false
skipFirstSearch
:
true
exposureEventExpected
:
true
}
)
;
await
doNimbusExposureTest
(
{
bestMatchEnabled
:
false
bestMatchExpected
:
false
experimentType
:
"
modal
"
exposureEventExpected
:
false
}
)
;
}
)
;
async
function
doNimbusExposureTest
(
{
bestMatchEnabled
bestMatchExpected
experimentType
isBestMatchExperiment
skipFirstSearch
exposureEventExpected
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
bestMatch
.
enabled
"
false
]
]
}
)
;
await
QuickSuggestTestUtils
.
clearExposureEvent
(
)
;
await
QuickSuggestTestUtils
.
withExperiment
(
{
valueOverrides
:
{
bestMatchEnabled
experimentType
isBestMatchExperiment
}
callback
:
async
(
)
=
>
{
await
QuickSuggestTestUtils
.
assertExposureEvent
(
false
)
;
if
(
!
skipFirstSearch
)
{
info
(
"
Doing
first
search
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
NON_BEST_MATCH_SUGGESTION
.
keywords
[
0
]
fireInputEvent
:
true
}
)
;
await
QuickSuggestTestUtils
.
assertIsQuickSuggest
(
{
window
url
:
NON_BEST_MATCH_SUGGESTION
.
url
}
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
QuickSuggestTestUtils
.
assertExposureEvent
(
false
)
;
}
info
(
"
Doing
second
search
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
SUGGESTIONS
[
0
]
.
keywords
[
0
]
fireInputEvent
:
true
}
)
;
await
QuickSuggestTestUtils
.
assertIsQuickSuggest
(
{
window
originalUrl
:
SUGGESTIONS
[
0
]
.
url
isBestMatch
:
bestMatchExpected
}
)
;
await
QuickSuggestTestUtils
.
assertExposureEvent
(
exposureEventExpected
"
control
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
