"
use
strict
"
;
const
EXPECTED_RESULT_INDEX
=
1
;
const
{
WEATHER_SUGGESTION
}
=
MerinoTestUtils
;
requestLongerTimeout
(
5
)
;
add_setup
(
async
function
(
)
{
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsRecords
:
[
QuickSuggestTestUtils
.
weatherRecord
(
)
]
prefs
:
[
[
"
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
weather
.
featureGate
"
true
]
]
}
)
;
await
MerinoTestUtils
.
initWeather
(
)
;
}
)
;
add_task
(
async
function
showLessFrequentlyCapReached_manySearches
(
)
{
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
QuickSuggestTestUtils
.
weatherRecord
(
{
min_keyword_length
:
3
}
)
{
type
:
"
configuration
"
configuration
:
{
show_less_frequently_cap
:
1
}
}
]
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
wea
"
}
)
;
info
(
"
Weather
suggestion
should
be
present
after
'
wea
'
search
"
)
;
let
details
=
await
assertWeatherResultPresent
(
)
;
let
command
=
"
show_less_frequently
"
;
await
UrlbarTestUtils
.
openResultMenuAndClickItem
(
window
command
{
resultIndex
:
EXPECTED_RESULT_INDEX
}
)
;
Assert
.
ok
(
gURLBar
.
view
.
isOpen
"
The
view
should
remain
open
clicking
the
command
"
)
;
Assert
.
ok
(
details
.
element
.
row
.
hasAttribute
(
"
feedback
-
acknowledgment
"
)
"
Row
should
have
feedback
acknowledgment
after
clicking
command
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
"
weather
.
minKeywordLength
"
)
4
"
weather
.
minKeywordLength
should
be
incremented
once
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
wea
"
}
)
;
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
info
(
Weather
suggestion
should
be
absent
(
checking
index
{
i
}
)
)
;
assertIsWeatherResult
(
details
.
result
false
)
;
}
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
weat
"
}
)
;
info
(
"
Weather
suggestion
should
be
present
after
'
weat
'
search
"
)
;
details
=
await
assertWeatherResultPresent
(
)
;
Assert
.
ok
(
!
details
.
element
.
row
.
hasAttribute
(
"
feedback
-
acknowledgment
"
)
"
Row
should
not
have
feedback
acknowledgment
after
'
weat
'
search
"
)
;
await
UrlbarTestUtils
.
openResultMenu
(
window
{
resultIndex
:
EXPECTED_RESULT_INDEX
}
)
;
let
menuitem
=
gURLBar
.
view
.
resultMenu
.
querySelector
(
menuitem
[
data
-
command
=
{
command
}
]
)
;
Assert
.
ok
(
!
menuitem
"
Menuitem
should
be
absent
"
)
;
gURLBar
.
view
.
resultMenu
.
hidePopup
(
true
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
QuickSuggestTestUtils
.
weatherRecord
(
)
]
)
;
UrlbarPrefs
.
clear
(
"
weather
.
minKeywordLength
"
)
;
UrlbarPrefs
.
clear
(
"
weather
.
showLessFrequentlyCount
"
)
;
}
)
;
add_task
(
async
function
dontShow
(
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
weather
"
}
)
;
await
doDismissTest
(
"
dismiss
"
)
;
}
)
;
async
function
doDismissTest
(
command
)
{
let
resultCount
=
UrlbarTestUtils
.
getResultCount
(
window
)
;
let
details
=
await
assertWeatherResultPresent
(
)
;
await
UrlbarTestUtils
.
openResultMenuAndClickItem
(
window
command
{
resultIndex
:
EXPECTED_RESULT_INDEX
openByMouse
:
true
}
)
;
Assert
.
ok
(
!
UrlbarPrefs
.
get
(
"
suggest
.
weather
"
)
"
suggest
.
weather
pref
should
be
set
to
false
after
dismissal
"
)
;
Assert
.
ok
(
gURLBar
.
view
.
isOpen
"
The
view
should
remain
open
after
dismissal
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
resultCount
"
The
result
count
should
not
haved
changed
after
dismissal
"
)
;
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
EXPECTED_RESULT_INDEX
)
;
Assert
.
equal
(
details
.
type
UrlbarUtils
.
RESULT_TYPE
.
TIP
"
Row
should
be
a
tip
after
dismissal
"
)
;
Assert
.
equal
(
details
.
result
.
payload
.
type
"
dismissalAcknowledgment
"
"
Tip
type
should
be
dismissalAcknowledgment
"
)
;
Assert
.
ok
(
!
details
.
element
.
row
.
hasAttribute
(
"
feedback
-
acknowledgment
"
)
"
Row
should
not
have
feedback
acknowledgment
after
dismissal
"
)
;
let
gotItButton
=
UrlbarTestUtils
.
getButtonForResultIndex
(
window
"
0
"
EXPECTED_RESULT_INDEX
)
;
Assert
.
ok
(
gotItButton
"
Row
should
have
a
'
Got
it
'
button
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
gotItButton
{
}
window
)
;
Assert
.
ok
(
gURLBar
.
view
.
isOpen
"
The
view
should
remain
open
clicking
the
'
Got
it
'
button
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
window
)
resultCount
-
1
"
The
result
count
should
be
one
less
after
clicking
'
Got
it
'
button
"
)
;
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
i
)
;
Assert
.
notEqual
(
details
.
type
UrlbarUtils
.
RESULT_TYPE
.
TIP
"
Tip
result
should
not
be
present
"
)
;
info
(
"
Weather
result
should
not
be
present
"
)
;
assertIsWeatherResult
(
details
.
result
false
)
;
}
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
weather
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
add_task
(
async
function
inaccurateLocationAndDismissal
(
)
{
await
doSessionOngoingCommandTest
(
"
inaccurate_location
"
)
;
}
)
;
add_task
(
async
function
showLessFrequentlyAndDismissal
(
)
{
await
doSessionOngoingCommandTest
(
"
show_less_frequently
"
)
;
UrlbarPrefs
.
clear
(
"
weather
.
minKeywordLength
"
)
;
UrlbarPrefs
.
clear
(
"
weather
.
showLessFrequentlyCount
"
)
;
}
)
;
async
function
doSessionOngoingCommandTest
(
command
)
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
weather
"
}
)
;
info
(
"
Weather
suggestion
should
be
present
after
search
"
)
;
let
details
=
await
assertWeatherResultPresent
(
)
;
await
UrlbarTestUtils
.
openResultMenuAndClickItem
(
window
command
{
resultIndex
:
EXPECTED_RESULT_INDEX
}
)
;
Assert
.
ok
(
gURLBar
.
view
.
isOpen
"
The
view
should
remain
open
clicking
the
command
"
)
;
Assert
.
ok
(
details
.
element
.
row
.
hasAttribute
(
"
feedback
-
acknowledgment
"
)
"
Row
should
have
feedback
acknowledgment
after
clicking
command
"
)
;
info
(
"
Doing
dismissal
"
)
;
await
doDismissTest
(
"
dismiss
"
)
;
}
add_task
(
async
function
manage
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
}
async
browser
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
weather
"
}
)
;
await
assertWeatherResultPresent
(
)
;
const
managePage
=
"
about
:
preferences
#
search
"
;
let
onManagePageLoaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
managePage
)
;
await
UrlbarTestUtils
.
openResultMenuAndClickItem
(
window
"
manage
"
{
resultIndex
:
EXPECTED_RESULT_INDEX
}
)
;
await
onManagePageLoaded
;
Assert
.
equal
(
browser
.
currentURI
.
spec
managePage
"
The
manage
page
is
loaded
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
)
;
}
)
;
}
)
;
add_task
(
async
function
simplestUi
(
)
{
let
nimbusVariablesList
=
[
null
{
weatherUiTreatment
:
0
}
]
;
for
(
let
nimbusVariables
of
nimbusVariablesList
)
{
let
nimbusCleanup
=
nimbusVariables
?
await
UrlbarTestUtils
.
initNimbusFeature
(
nimbusVariables
)
:
null
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
weather
"
}
)
;
let
details
=
await
assertWeatherResultPresent
(
)
;
let
{
row
}
=
details
.
element
;
let
unit
=
Services
.
locale
.
regionalPrefsLocales
[
0
]
=
=
"
en
-
US
"
?
"
f
"
:
"
c
"
;
let
temperature
=
WEATHER_SUGGESTION
.
current_conditions
.
temperature
[
unit
]
+
"
"
+
unit
.
toUpperCase
(
)
;
let
expectedTitle
=
[
temperature
"
in
"
WEATHER_SUGGESTION
.
city_name
+
"
"
WEATHER_SUGGESTION
.
region_code
]
.
join
(
"
"
)
;
let
title
=
row
.
querySelector
(
"
.
urlbarView
-
title
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
title
.
textContent
=
=
expectedTitle
"
Waiting
for
the
row
'
s
title
text
to
be
updated
"
)
;
Assert
.
equal
(
title
.
textContent
expectedTitle
"
Row
should
have
expected
title
"
)
;
let
strongChildren
=
title
.
querySelectorAll
(
"
strong
"
)
;
Assert
.
equal
(
strongChildren
.
length
1
"
Title
should
have
one
<
strong
>
child
"
)
;
Assert
.
equal
(
strongChildren
[
0
]
.
textContent
temperature
"
Strong
child
should
be
correct
"
)
;
Assert
.
ok
(
!
row
.
hasAttribute
(
"
label
"
)
"
Simplest
UI
should
not
have
a
row
label
"
)
;
await
assertPageLoad
(
)
;
}
)
;
await
nimbusCleanup
?
.
(
)
;
}
}
)
;
add_task
(
async
function
simplerAndFullUi
(
)
{
const
testData
=
[
{
nimbusVariables
:
{
weatherUiTreatment
:
1
}
expectedSummary
:
WEATHER_SUGGESTION
.
current_conditions
.
summary
}
{
nimbusVariables
:
{
weatherUiTreatment
:
2
}
expectedSummary
:
{
WEATHER_SUGGESTION
.
current_conditions
.
summary
}
;
{
WEATHER_SUGGESTION
.
forecast
.
summary
}
}
]
;
for
(
let
{
nimbusVariables
expectedSummary
}
of
testData
)
{
let
nimbusCleanup
=
nimbusVariables
?
await
UrlbarTestUtils
.
initNimbusFeature
(
nimbusVariables
)
:
null
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
value
:
"
weather
"
}
)
;
let
details
=
await
assertWeatherResultPresent
(
)
;
let
{
row
}
=
details
.
element
;
let
summary
=
row
.
querySelector
(
"
.
urlbarView
-
dynamic
-
weather
-
summaryText
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
summary
.
textContent
=
=
expectedSummary
"
Waiting
for
the
row
'
s
summary
text
to
be
updated
"
)
;
Assert
.
equal
(
summary
.
textContent
expectedSummary
"
The
summary
text
should
be
correct
"
)
;
let
expectedTitle
=
[
"
Weather
for
"
WEATHER_SUGGESTION
.
city_name
+
"
"
WEATHER_SUGGESTION
.
region_code
]
.
join
(
"
"
)
;
let
title
=
row
.
querySelector
(
"
.
urlbarView
-
dynamic
-
weather
-
title
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
title
.
textContent
=
=
expectedTitle
"
Waiting
for
the
row
'
s
title
text
to
be
updated
"
)
;
Assert
.
equal
(
title
.
textContent
expectedTitle
"
The
title
text
should
be
correct
"
)
;
Assert
.
equal
(
row
.
getAttribute
(
"
label
"
)
"
Firefox
Suggest
"
"
Row
label
should
be
correct
"
)
;
await
assertPageLoad
(
)
;
}
)
;
await
nimbusCleanup
?
.
(
)
;
}
}
)
;
async
function
assertWeatherResultPresent
(
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
EXPECTED_RESULT_INDEX
)
;
assertIsWeatherResult
(
details
.
result
true
)
;
return
details
;
}
function
assertIsWeatherResult
(
result
isWeatherResult
)
{
if
(
isWeatherResult
)
{
Assert
.
equal
(
result
.
providerName
UrlbarProviderQuickSuggest
.
name
"
Result
should
be
from
UrlbarProviderQuickSuggest
"
)
;
Assert
.
equal
(
UrlbarUtils
.
searchEngagementTelemetryType
(
result
)
"
weather
"
"
Result
telemetry
type
should
be
'
weather
'
"
)
;
}
else
{
Assert
.
notEqual
(
result
.
providerName
UrlbarProviderQuickSuggest
.
name
"
Result
should
not
be
from
UrlbarProviderQuickSuggest
"
)
;
Assert
.
notEqual
(
UrlbarUtils
.
searchEngagementTelemetryType
(
result
)
"
weather
"
"
Result
telemetry
type
should
not
be
'
weather
'
"
)
;
}
}
async
function
assertPageLoad
(
)
{
let
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
false
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
repeat
:
EXPECTED_RESULT_INDEX
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
info
(
"
Waiting
for
weather
page
to
load
"
)
;
await
loadPromise
;
Assert
.
equal
(
gBrowser
.
currentURI
.
spec
"
https
:
/
/
example
.
com
/
weather
"
"
Expected
weather
page
should
have
loaded
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
