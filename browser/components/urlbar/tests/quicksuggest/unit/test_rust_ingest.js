"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
sys
.
mjs
"
InterruptKind
:
"
resource
:
/
/
gre
/
modules
/
RustSuggest
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
SuggestionProvider
:
"
resource
:
/
/
gre
/
modules
/
RustSuggest
.
sys
.
mjs
"
}
)
;
const
PREF_APP_UPDATE_TIMERMINIMUMDELAY
=
"
app
.
update
.
timerMinimumDelay
"
;
const
PREF_APP_UPDATE_TIMERFIRSTINTERVAL
=
"
app
.
update
.
timerFirstInterval
"
;
const
MAIN_TIMER_INTERVAL
=
1000
;
const
CATEGORY_UPDATE_TIMER
=
"
update
-
timer
"
;
const
REMOTE_SETTINGS_SUGGESTION
=
QuickSuggestTestUtils
.
ampRemoteSettings
(
)
;
add_setup
(
async
function
(
)
{
initUpdateTimerManager
(
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsRecords
:
[
{
type
:
"
data
"
attachment
:
[
REMOTE_SETTINGS_SUGGESTION
]
}
]
prefs
:
[
[
"
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
suggest
.
quicksuggest
.
nonsponsored
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
disableEnable
(
)
{
Assert
.
strictEqual
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
rustEnabled
"
)
true
"
Sanity
check
:
Rust
pref
is
initially
true
"
)
;
Assert
.
strictEqual
(
QuickSuggest
.
rustBackend
.
isEnabled
true
"
Sanity
check
:
Rust
backend
is
initially
enabled
"
)
;
let
enabledTypes
=
QuickSuggest
.
rustBackend
.
_test_enabledSuggestionTypes
;
Assert
.
greater
(
enabledTypes
.
length
0
"
This
test
expects
some
Rust
suggestion
types
to
be
enabled
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
await
withIngestStub
(
async
(
{
stub
rustBackend
}
)
=
>
{
info
(
"
Awaiting
ingest
promise
"
)
;
await
rustBackend
.
ingestPromise
;
checkIngestCounts
(
{
stub
expected
:
Object
.
fromEntries
(
enabledTypes
.
map
(
(
{
provider
}
)
=
>
[
provider
1
]
)
)
}
)
;
}
)
;
}
)
;
add_task
(
async
function
featureWithMultipleSuggestionTypes
(
)
{
let
feature
=
QuickSuggest
.
getFeature
(
"
AdmWikipedia
"
)
;
Assert
.
ok
(
!
!
feature
"
This
test
expects
the
AdmWikipedia
feature
to
exist
"
)
;
Assert
.
deepEqual
(
[
.
.
.
feature
.
rustSuggestionTypes
]
.
sort
(
)
[
"
Amp
"
"
Wikipedia
"
]
"
This
test
expects
the
AdmWikipedia
feature
to
manage
Amp
and
Wikipedia
suggestions
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
await
withIngestStub
(
async
(
{
stub
rustBackend
}
)
=
>
{
let
providersFilter
=
[
SuggestionProvider
.
AMP
SuggestionProvider
.
WIKIPEDIA
]
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
info
(
"
Awaiting
ingest
promise
after
disabling
sponsored
"
)
;
await
rustBackend
.
ingestPromise
;
checkIngestCounts
(
{
stub
providersFilter
expected
:
{
}
}
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
info
(
"
Awaiting
ingest
promise
after
disabling
nonsponsored
"
)
;
await
rustBackend
.
ingestPromise
;
checkIngestCounts
(
{
stub
providersFilter
expected
:
{
}
}
)
;
Assert
.
ok
(
!
feature
.
isEnabled
"
The
feature
should
be
disabled
after
disabling
sponsored
and
nonsponsored
suggestions
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
info
(
"
Awaiting
ingest
promise
after
re
-
enabling
sponsored
"
)
;
await
rustBackend
.
ingestPromise
;
checkIngestCounts
(
{
stub
providersFilter
expected
:
{
[
SuggestionProvider
.
AMP
]
:
1
}
}
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
info
(
"
Awaiting
ingest
promise
after
re
-
enabling
nonsponsored
"
)
;
await
rustBackend
.
ingestPromise
;
checkIngestCounts
(
{
stub
providersFilter
expected
:
{
[
SuggestionProvider
.
WIKIPEDIA
]
:
1
}
}
)
;
}
)
;
}
)
;
add_task
(
async
function
providerConstraintsChanged
(
)
{
let
feature
=
QuickSuggest
.
getFeature
(
"
ExposureSuggestions
"
)
;
Assert
.
ok
(
!
!
feature
"
This
test
expects
the
ExposureSuggestions
feature
to
exist
"
)
;
Assert
.
ok
(
feature
.
rustSuggestionTypes
.
includes
(
"
Exposure
"
)
"
This
test
expects
Exposure
suggestions
to
exist
"
)
;
let
providersFilter
=
[
SuggestionProvider
.
EXPOSURE
]
;
await
withIngestStub
(
async
(
{
stub
rustBackend
}
)
=
>
{
for
(
let
type
of
[
"
aaa
"
"
bbb
"
"
aaa
bbb
"
]
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
exposureSuggestionTypes
"
type
)
;
info
(
"
Awaiting
ingest
promise
after
setting
exposureSuggestionTypes
"
)
;
await
rustBackend
.
ingestPromise
;
checkIngestCounts
(
{
stub
providersFilter
expected
:
{
[
SuggestionProvider
.
EXPOSURE
]
:
1
}
}
)
;
}
UrlbarPrefs
.
set
(
"
quicksuggest
.
exposureSuggestionTypes
"
"
"
)
;
info
(
"
Awaiting
ingest
promise
after
setting
exposureSuggestionTypes
to
empty
string
"
)
;
await
rustBackend
.
ingestPromise
;
Assert
.
ok
(
!
feature
.
isEnabled
"
Exposure
feature
should
be
disabled
after
setting
exposureSuggestionTypes
to
empty
string
"
)
;
checkIngestCounts
(
{
stub
providersFilter
expected
:
{
}
}
)
;
}
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
exposureSuggestionTypes
"
)
;
await
QuickSuggest
.
rustBackend
.
ingestPromise
;
}
)
;
add_task
(
async
function
interval
(
)
{
let
intervalSecs
=
3
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustIngestIntervalSeconds
"
intervalSecs
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
info
(
"
Awaiting
initial
ingest
promise
"
)
;
let
{
ingestPromise
}
=
QuickSuggest
.
rustBackend
;
await
ingestPromise
;
let
enabledTypes
=
QuickSuggest
.
rustBackend
.
_test_enabledSuggestionTypes
;
Assert
.
greater
(
enabledTypes
.
length
0
"
This
test
expects
some
Rust
suggestion
types
to
be
enabled
"
)
;
await
withIngestStub
(
async
(
{
stub
}
)
=
>
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
info
(
Waiting
{
intervalSecs
}
s
for
ingest
to
start
at
index
{
i
}
)
;
(
{
ingestPromise
}
=
await
waitForIngestStart
(
ingestPromise
)
)
;
info
(
"
Waiting
for
ingest
to
finish
at
index
"
+
i
)
;
await
ingestPromise
;
info
(
"
Ingest
finished
at
index
"
+
i
)
;
checkIngestCounts
(
{
stub
expected
:
Object
.
fromEntries
(
enabledTypes
.
map
(
(
{
provider
}
)
=
>
[
provider
1
]
)
)
}
)
;
}
}
)
;
info
(
"
Disabling
the
backend
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
let
waitSecs
=
2
*
intervalSecs
;
let
wait
=
(
)
=
>
new
Promise
(
r
=
>
setTimeout
(
r
1000
*
waitSecs
)
)
;
let
waitedAtEndOfLoop
=
false
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
info
(
Waiting
{
waitSecs
}
s
after
disabling
backend
i
=
{
i
}
.
.
.
)
;
await
wait
(
)
;
let
{
ingestPromise
:
newIngestPromise
}
=
QuickSuggest
.
rustBackend
;
if
(
ingestPromise
=
=
newIngestPromise
)
{
info
(
No
new
ingest
started
i
=
{
i
}
)
;
waitedAtEndOfLoop
=
true
;
break
;
}
info
(
New
ingest
started
now
awaiting
i
=
{
i
}
)
;
ingestPromise
=
newIngestPromise
;
await
ingestPromise
;
}
if
(
!
waitedAtEndOfLoop
)
{
info
(
Waiting
a
final
{
waitSecs
}
s
.
.
.
)
;
await
wait
(
)
;
}
Assert
.
equal
(
QuickSuggest
.
rustBackend
.
ingestPromise
ingestPromise
"
No
new
ingest
started
after
disabling
the
backend
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustIngestIntervalSeconds
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
info
(
"
Awaiting
cleanup
ingest
promise
"
)
;
await
QuickSuggest
.
rustBackend
.
ingestPromise
;
info
(
"
Done
awaiting
cleanup
ingest
promise
"
)
;
}
)
;
add_task
(
async
function
shutdown
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
spy
=
sandbox
.
spy
(
QuickSuggest
.
rustBackend
.
_test_store
"
interrupt
"
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
asyncshutdown
.
testing
"
true
)
;
AsyncShutdown
.
profileBeforeChange
.
_trigger
(
)
;
let
calls
=
spy
.
getCalls
(
)
;
Assert
.
equal
(
calls
.
length
1
"
store
.
interrupt
(
)
should
have
been
called
once
on
simulated
shutdown
"
)
;
Assert
.
deepEqual
(
calls
[
0
]
.
args
[
InterruptKind
.
READ_WRITE
]
"
store
.
interrupt
(
)
should
have
been
called
with
InterruptKind
.
READ_WRITE
"
)
;
Assert
.
ok
(
InterruptKind
.
READ_WRITE
"
Sanity
check
:
InterruptKind
.
READ_WRITE
is
defined
"
)
;
Services
.
prefs
.
clearUserPref
(
"
toolkit
.
asyncshutdown
.
testing
"
)
;
sandbox
.
restore
(
)
;
}
)
;
async
function
withIngestStub
(
callback
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
{
rustBackend
}
=
QuickSuggest
;
let
stub
=
sandbox
.
stub
(
rustBackend
.
_test_store
"
ingest
"
)
;
await
callback
(
{
stub
rustBackend
}
)
;
sandbox
.
restore
(
)
;
}
function
getIngestCounts
(
stub
providersFilter
=
null
)
{
let
countsByProvider
=
{
}
;
for
(
let
call
of
stub
.
getCalls
(
)
)
{
let
ingestConstraints
=
call
.
args
[
0
]
;
for
(
let
p
of
ingestConstraints
.
providers
)
{
if
(
!
providersFilter
|
|
providersFilter
.
includes
(
p
)
)
{
if
(
!
countsByProvider
.
hasOwnProperty
(
p
)
)
{
countsByProvider
[
p
]
=
0
;
}
countsByProvider
[
p
]
+
+
;
}
}
}
info
(
"
Got
ingest
counts
:
"
+
JSON
.
stringify
(
countsByProvider
)
)
;
stub
.
resetHistory
(
)
;
return
countsByProvider
;
}
function
checkIngestCounts
(
{
stub
providersFilter
expected
}
)
{
Assert
.
deepEqual
(
getIngestCounts
(
stub
providersFilter
)
expected
"
Actual
ingest
counts
should
match
expected
counts
"
)
;
}
async
function
waitForIngestStart
(
oldIngestPromise
)
{
let
newIngestPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
{
ingestPromise
}
=
QuickSuggest
.
rustBackend
;
if
(
(
oldIngestPromise
&
&
ingestPromise
!
=
oldIngestPromise
)
|
|
(
!
oldIngestPromise
&
&
ingestPromise
)
)
{
newIngestPromise
=
ingestPromise
;
return
true
;
}
return
false
;
}
"
Waiting
for
a
new
ingest
to
start
"
)
;
Assert
.
equal
(
QuickSuggest
.
rustBackend
.
ingestPromise
newIngestPromise
"
Sanity
check
:
ingestPromise
hasn
'
t
changed
since
waitForCondition
returned
"
)
;
return
{
ingestPromise
:
newIngestPromise
}
;
}
function
initUpdateTimerManager
(
)
{
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_TIMERMINIMUMDELAY
MAIN_TIMER_INTERVAL
/
1000
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_TIMERFIRSTINTERVAL
MAIN_TIMER_INTERVAL
)
;
for
(
let
{
data
:
entry
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_UPDATE_TIMER
)
)
{
Services
.
catMan
.
deleteCategoryEntry
(
CATEGORY_UPDATE_TIMER
entry
false
)
;
}
Cc
[
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateTimerManager
)
.
QueryInterface
(
Ci
.
nsIObserver
)
.
observe
(
null
"
utm
-
test
-
init
"
"
"
)
;
}
