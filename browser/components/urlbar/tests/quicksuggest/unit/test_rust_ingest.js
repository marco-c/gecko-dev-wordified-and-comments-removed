"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
const
PREF_APP_UPDATE_TIMERMINIMUMDELAY
=
"
app
.
update
.
timerMinimumDelay
"
;
const
PREF_APP_UPDATE_TIMERFIRSTINTERVAL
=
"
app
.
update
.
timerFirstInterval
"
;
const
MAIN_TIMER_INTERVAL
=
1000
;
const
CATEGORY_UPDATE_TIMER
=
"
update
-
timer
"
;
const
REMOTE_SETTINGS_SUGGESTION
=
{
id
:
1
url
:
"
http
:
/
/
example
.
com
/
amp
"
title
:
"
AMP
Suggestion
"
keywords
:
[
"
amp
"
]
click_url
:
"
http
:
/
/
example
.
com
/
amp
-
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
amp
-
impression
"
advertiser
:
"
Amp
"
iab_category
:
"
22
-
Shopping
"
icon
:
"
1234
"
}
;
add_setup
(
async
function
(
)
{
initUpdateTimerManager
(
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsRecords
:
[
{
type
:
"
data
"
attachment
:
[
REMOTE_SETTINGS_SUGGESTION
]
}
]
prefs
:
[
[
"
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
quicksuggest
.
rustEnabled
"
false
]
]
}
)
;
}
)
;
add_task
(
async
function
firstRun
(
)
{
Assert
.
ok
(
!
UrlbarPrefs
.
get
(
"
quicksuggest
.
rustEnabled
"
)
"
rustEnabled
pref
is
initially
false
(
this
task
must
run
first
!
)
"
)
;
Assert
.
strictEqual
(
QuickSuggest
.
rustBackend
.
isEnabled
false
"
Rust
backend
is
initially
disabled
(
this
task
must
run
first
!
)
"
)
;
Assert
.
ok
(
!
QuickSuggest
.
rustBackend
.
ingestPromise
"
No
ingest
has
been
performed
yet
(
this
task
must
run
first
!
)
"
)
;
info
(
"
Enabling
the
Rust
backend
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
rustBackend
.
isEnabled
"
Rust
backend
is
now
enabled
"
)
;
let
{
ingestPromise
}
=
await
waitForIngestStart
(
null
)
;
info
(
"
Awaiting
ingest
promise
"
)
;
await
ingestPromise
;
info
(
"
Done
awaiting
ingest
promise
"
)
;
await
checkSuggestions
(
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
await
assertNoNewIngestStarted
(
ingestPromise
)
;
await
checkSuggestions
(
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
}
)
;
add_task
(
async
function
interval
(
)
{
let
{
ingestPromise
}
=
QuickSuggest
.
rustBackend
;
Assert
.
ok
(
ingestPromise
"
Sanity
check
:
An
ingest
has
already
been
performed
"
)
;
Assert
.
ok
(
!
UrlbarPrefs
.
get
(
"
quicksuggest
.
rustEnabled
"
)
"
Sanity
check
:
Rust
backend
is
initially
disabled
"
)
;
let
intervalSecs
=
1
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustIngestIntervalSeconds
"
intervalSecs
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
await
assertNoNewIngestStarted
(
ingestPromise
)
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
info
(
"
Preparing
for
ingest
at
index
"
+
i
)
;
let
suggestion
=
{
.
.
.
REMOTE_SETTINGS_SUGGESTION
url
:
REMOTE_SETTINGS_SUGGESTION
.
url
+
"
/
"
+
i
}
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
{
type
:
"
data
"
attachment
:
[
suggestion
]
}
]
{
forceSync
:
false
}
)
;
info
(
"
Waiting
for
ingest
to
start
at
index
"
+
i
)
;
(
{
ingestPromise
}
=
await
waitForIngestStart
(
ingestPromise
)
)
;
info
(
"
Waiting
for
ingest
to
finish
at
index
"
+
i
)
;
await
ingestPromise
;
await
checkSuggestions
(
[
suggestion
]
)
;
}
(
{
ingestPromise
}
=
await
waitForIngestStart
(
ingestPromise
)
)
;
info
(
"
Disabling
the
backend
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
info
(
"
Awaiting
final
ingest
promise
"
)
;
await
ingestPromise
;
let
waitSecs
=
3
*
intervalSecs
;
info
(
Waiting
{
waitSecs
}
s
.
.
.
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
1000
*
waitSecs
)
)
;
Assert
.
equal
(
QuickSuggest
.
rustBackend
.
ingestPromise
ingestPromise
"
No
new
ingest
started
after
disabling
the
backend
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustIngestIntervalSeconds
"
)
;
}
)
;
async
function
waitForIngestStart
(
oldIngestPromise
)
{
let
newIngestPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
{
ingestPromise
}
=
QuickSuggest
.
rustBackend
;
if
(
(
oldIngestPromise
&
&
ingestPromise
!
=
oldIngestPromise
)
|
|
(
!
oldIngestPromise
&
&
ingestPromise
)
)
{
newIngestPromise
=
ingestPromise
;
return
true
;
}
return
false
;
}
"
Waiting
for
a
new
ingest
to
start
"
)
;
Assert
.
equal
(
QuickSuggest
.
rustBackend
.
ingestPromise
newIngestPromise
"
Sanity
check
:
ingestPromise
hasn
'
t
changed
since
waitForCondition
returned
"
)
;
return
{
ingestPromise
:
newIngestPromise
}
;
}
async
function
assertNoNewIngestStarted
(
oldIngestPromise
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
await
TestUtils
.
waitForTick
(
)
;
}
Assert
.
equal
(
QuickSuggest
.
rustBackend
.
ingestPromise
oldIngestPromise
"
No
new
ingest
started
"
)
;
}
async
function
checkSuggestions
(
expected
=
[
REMOTE_SETTINGS_SUGGESTION
]
)
{
let
actual
=
await
QuickSuggest
.
rustBackend
.
query
(
"
amp
"
)
;
Assert
.
deepEqual
(
actual
.
map
(
s
=
>
s
.
url
)
expected
.
map
(
s
=
>
s
.
url
)
"
Backend
should
be
serving
the
expected
suggestions
"
)
;
}
function
initUpdateTimerManager
(
)
{
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_TIMERMINIMUMDELAY
MAIN_TIMER_INTERVAL
/
1000
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_TIMERFIRSTINTERVAL
MAIN_TIMER_INTERVAL
)
;
for
(
let
{
data
:
entry
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_UPDATE_TIMER
)
)
{
Services
.
catMan
.
deleteCategoryEntry
(
CATEGORY_UPDATE_TIMER
entry
false
)
;
}
Cc
[
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateTimerManager
)
.
QueryInterface
(
Ci
.
nsIObserver
)
.
observe
(
null
"
utm
-
test
-
init
"
"
"
)
;
}
