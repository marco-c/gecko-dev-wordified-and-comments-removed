"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
sys
.
mjs
"
InterruptKind
:
"
resource
:
/
/
gre
/
modules
/
RustSuggest
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
const
PREF_APP_UPDATE_TIMERMINIMUMDELAY
=
"
app
.
update
.
timerMinimumDelay
"
;
const
PREF_APP_UPDATE_TIMERFIRSTINTERVAL
=
"
app
.
update
.
timerFirstInterval
"
;
const
MAIN_TIMER_INTERVAL
=
1000
;
const
CATEGORY_UPDATE_TIMER
=
"
update
-
timer
"
;
const
REMOTE_SETTINGS_SUGGESTION
=
QuickSuggestTestUtils
.
ampRemoteSettings
(
)
;
add_setup
(
async
function
(
)
{
initUpdateTimerManager
(
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsRecords
:
[
{
type
:
"
data
"
attachment
:
[
REMOTE_SETTINGS_SUGGESTION
]
}
]
prefs
:
[
[
"
suggest
.
quicksuggest
.
sponsored
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
disableEnable
(
)
{
Assert
.
strictEqual
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
rustEnabled
"
)
true
"
Sanity
check
:
Rust
pref
is
initially
true
"
)
;
Assert
.
strictEqual
(
QuickSuggest
.
rustBackend
.
isEnabled
true
"
Sanity
check
:
Rust
backend
is
initially
enabled
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
let
{
ingestPromise
}
=
await
waitForIngestStart
(
null
)
;
info
(
"
Awaiting
ingest
promise
"
)
;
await
ingestPromise
;
info
(
"
Done
awaiting
ingest
promise
"
)
;
await
checkSuggestions
(
)
;
}
)
;
add_task
(
async
function
interval
(
)
{
let
{
ingestPromise
}
=
QuickSuggest
.
rustBackend
;
let
intervalSecs
=
1
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustIngestIntervalSeconds
"
intervalSecs
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
(
{
ingestPromise
}
=
await
waitForIngestStart
(
ingestPromise
)
)
;
info
(
"
Awaiting
initial
ingest
promise
"
)
;
await
ingestPromise
;
info
(
"
Done
awaiting
initial
ingest
promise
"
)
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
info
(
"
Preparing
for
ingest
at
index
"
+
i
)
;
let
suggestion
=
{
.
.
.
REMOTE_SETTINGS_SUGGESTION
url
:
REMOTE_SETTINGS_SUGGESTION
.
url
+
"
/
"
+
i
}
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
{
type
:
"
data
"
attachment
:
[
suggestion
]
}
]
{
forceSync
:
false
}
)
;
info
(
"
Waiting
for
ingest
to
start
at
index
"
+
i
)
;
(
{
ingestPromise
}
=
await
waitForIngestStart
(
ingestPromise
)
)
;
info
(
"
Waiting
for
ingest
to
finish
at
index
"
+
i
)
;
await
ingestPromise
;
await
checkSuggestions
(
[
suggestion
]
)
;
}
info
(
"
Disabling
the
backend
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
let
waitSecs
=
3
*
intervalSecs
;
let
wait
=
(
)
=
>
new
Promise
(
r
=
>
setTimeout
(
r
1000
*
waitSecs
)
)
;
let
waitedAtEndOfLoop
=
false
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
info
(
Waiting
{
waitSecs
}
s
after
disabling
backend
i
=
{
i
}
.
.
.
)
;
await
wait
(
)
;
let
{
ingestPromise
:
newIngestPromise
}
=
QuickSuggest
.
rustBackend
;
if
(
ingestPromise
=
=
newIngestPromise
)
{
info
(
No
new
ingest
started
i
=
{
i
}
)
;
waitedAtEndOfLoop
=
true
;
break
;
}
info
(
New
ingest
started
now
awaiting
i
=
{
i
}
)
;
ingestPromise
=
newIngestPromise
;
await
ingestPromise
;
}
if
(
!
waitedAtEndOfLoop
)
{
info
(
Waiting
a
final
{
waitSecs
}
s
.
.
.
)
;
await
wait
(
)
;
}
Assert
.
equal
(
QuickSuggest
.
rustBackend
.
ingestPromise
ingestPromise
"
No
new
ingest
started
after
disabling
the
backend
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustIngestIntervalSeconds
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
(
{
ingestPromise
}
=
await
waitForIngestStart
(
ingestPromise
)
)
;
info
(
"
Awaiting
cleanup
ingest
promise
"
)
;
await
ingestPromise
;
info
(
"
Done
awaiting
cleanup
ingest
promise
"
)
;
}
)
;
add_task
(
async
function
shutdown
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
spy
=
sandbox
.
spy
(
QuickSuggest
.
rustBackend
.
_test_store
"
interrupt
"
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
asyncshutdown
.
testing
"
true
)
;
AsyncShutdown
.
profileBeforeChange
.
_trigger
(
)
;
let
calls
=
spy
.
getCalls
(
)
;
Assert
.
equal
(
calls
.
length
1
"
store
.
interrupt
(
)
should
have
been
called
once
on
simulated
shutdown
"
)
;
Assert
.
deepEqual
(
calls
[
0
]
.
args
[
InterruptKind
.
READ_WRITE
]
"
store
.
interrupt
(
)
should
have
been
called
with
InterruptKind
.
READ_WRITE
"
)
;
Assert
.
ok
(
InterruptKind
.
READ_WRITE
"
Sanity
check
:
InterruptKind
.
READ_WRITE
is
defined
"
)
;
Services
.
prefs
.
clearUserPref
(
"
toolkit
.
asyncshutdown
.
testing
"
)
;
sandbox
.
restore
(
)
;
}
)
;
async
function
waitForIngestStart
(
oldIngestPromise
)
{
let
newIngestPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
{
ingestPromise
}
=
QuickSuggest
.
rustBackend
;
if
(
(
oldIngestPromise
&
&
ingestPromise
!
=
oldIngestPromise
)
|
|
(
!
oldIngestPromise
&
&
ingestPromise
)
)
{
newIngestPromise
=
ingestPromise
;
return
true
;
}
return
false
;
}
"
Waiting
for
a
new
ingest
to
start
"
)
;
Assert
.
equal
(
QuickSuggest
.
rustBackend
.
ingestPromise
newIngestPromise
"
Sanity
check
:
ingestPromise
hasn
'
t
changed
since
waitForCondition
returned
"
)
;
return
{
ingestPromise
:
newIngestPromise
}
;
}
async
function
checkSuggestions
(
expected
=
[
REMOTE_SETTINGS_SUGGESTION
]
)
{
let
actual
=
await
QuickSuggest
.
rustBackend
.
query
(
"
amp
"
)
;
Assert
.
deepEqual
(
actual
.
map
(
s
=
>
s
.
url
)
expected
.
map
(
s
=
>
s
.
url
)
"
Backend
should
be
serving
the
expected
suggestions
"
)
;
}
function
initUpdateTimerManager
(
)
{
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_TIMERMINIMUMDELAY
MAIN_TIMER_INTERVAL
/
1000
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_TIMERFIRSTINTERVAL
MAIN_TIMER_INTERVAL
)
;
for
(
let
{
data
:
entry
}
of
Services
.
catMan
.
enumerateCategory
(
CATEGORY_UPDATE_TIMER
)
)
{
Services
.
catMan
.
deleteCategoryEntry
(
CATEGORY_UPDATE_TIMER
entry
false
)
;
}
Cc
[
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateTimerManager
)
.
QueryInterface
(
Ci
.
nsIObserver
)
.
observe
(
null
"
utm
-
test
-
init
"
"
"
)
;
}
