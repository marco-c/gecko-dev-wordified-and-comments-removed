"
use
strict
"
;
let
SUGGESTIONS_DATA
=
[
{
keywords
:
[
"
aaa
"
]
isSponsored
:
true
}
{
keywords
:
[
"
aaa
"
"
bbb
"
]
isSponsored
:
false
score
:
2
*
RemoteSettingsClient
.
DEFAULT_SUGGESTION_SCORE
}
{
keywords
:
[
"
bbb
"
]
isSponsored
:
true
score
:
4
*
RemoteSettingsClient
.
DEFAULT_SUGGESTION_SCORE
}
{
keywords
:
[
"
bbb
"
]
isSponsored
:
false
score
:
3
*
RemoteSettingsClient
.
DEFAULT_SUGGESTION_SCORE
}
{
keywords
:
[
"
ccc
"
]
isSponsored
:
true
}
]
;
let
TESTS
=
{
aaa
:
{
expectedIndexes
:
[
0
1
]
searches
:
[
{
sponsored
:
true
nonsponsored
:
true
expectedIndex
:
1
}
{
sponsored
:
false
nonsponsored
:
true
expectedIndex
:
1
}
{
sponsored
:
true
nonsponsored
:
false
expectedIndex
:
0
}
{
sponsored
:
false
nonsponsored
:
false
expectedIndex
:
undefined
}
]
}
bbb
:
{
expectedIndexes
:
[
1
2
3
]
searches
:
[
{
sponsored
:
true
nonsponsored
:
true
expectedIndex
:
2
}
{
sponsored
:
false
nonsponsored
:
true
expectedIndex
:
3
}
{
sponsored
:
true
nonsponsored
:
false
expectedIndex
:
2
}
{
sponsored
:
false
nonsponsored
:
false
expectedIndex
:
undefined
}
]
}
ccc
:
{
expectedIndexes
:
[
4
]
searches
:
[
{
sponsored
:
true
nonsponsored
:
true
expectedIndex
:
4
}
{
sponsored
:
false
nonsponsored
:
true
expectedIndex
:
undefined
}
{
sponsored
:
true
nonsponsored
:
false
expectedIndex
:
4
}
{
sponsored
:
false
nonsponsored
:
false
expectedIndex
:
undefined
}
]
}
}
;
add_task
(
async
function
(
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
let
qsResults
=
[
]
;
let
qsSuggestions
=
[
]
;
let
urlbarResults
=
[
]
;
for
(
let
i
=
0
;
i
<
SUGGESTIONS_DATA
.
length
;
i
+
+
)
{
let
{
keywords
isSponsored
score
}
=
SUGGESTIONS_DATA
[
i
]
;
let
qsResult
=
{
keywords
score
id
:
i
url
:
"
http
:
/
/
example
.
com
/
"
+
i
title
:
"
Title
"
+
i
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
iab_category
:
isSponsored
?
"
22
-
Shopping
"
:
"
5
-
Education
"
}
;
qsResults
.
push
(
qsResult
)
;
let
qsSuggestion
=
{
.
.
.
qsResult
block_id
:
qsResult
.
id
is_sponsored
:
isSponsored
score
:
typeof
score
=
=
"
number
"
?
score
:
RemoteSettingsClient
.
DEFAULT_SUGGESTION_SCORE
source
:
"
remote
-
settings
"
icon
:
null
position
:
undefined
_test_is_best_match
:
undefined
}
;
delete
qsSuggestion
.
keywords
;
delete
qsSuggestion
.
id
;
qsSuggestions
.
push
(
qsSuggestion
)
;
urlbarResults
.
push
(
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
isSponsored
sponsoredBlockId
:
qsResult
.
id
url
:
qsResult
.
url
originalUrl
:
qsResult
.
url
displayUrl
:
qsResult
.
url
title
:
qsResult
.
title
sponsoredClickUrl
:
qsResult
.
click_url
sponsoredImpressionUrl
:
qsResult
.
impression_url
sponsoredAdvertiser
:
qsResult
.
advertiser
sponsoredIabCategory
:
qsResult
.
iab_category
icon
:
null
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10nId
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
source
:
"
remote
-
settings
"
}
}
)
;
}
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
qsResults
)
;
for
(
let
[
keyword
test
]
of
Object
.
entries
(
TESTS
)
)
{
info
(
"
Running
subtest
"
+
JSON
.
stringify
(
{
keyword
test
}
)
)
;
let
{
expectedIndexes
searches
}
=
test
;
Assert
.
deepEqual
(
await
QuickSuggest
.
remoteSettings
.
fetch
(
keyword
)
expectedIndexes
.
map
(
i
=
>
(
{
.
.
.
qsSuggestions
[
i
]
full_keyword
:
keyword
}
)
)
fetch
(
)
for
{
keyword
}
)
;
let
mapValue
=
QuickSuggest
.
remoteSettings
.
_test_resultsByKeyword
.
get
(
keyword
)
;
if
(
expectedIndexes
.
length
=
=
1
)
{
Assert
.
ok
(
!
Array
.
isArray
(
mapValue
)
"
The
map
value
is
not
an
array
"
)
;
Assert
.
deepEqual
(
mapValue
qsResults
[
expectedIndexes
[
0
]
]
"
The
map
value
is
the
expected
result
object
"
)
;
}
else
{
Assert
.
ok
(
Array
.
isArray
(
mapValue
)
"
The
map
value
is
an
array
"
)
;
Assert
.
greater
(
mapValue
.
length
0
"
The
array
is
not
empty
"
)
;
Assert
.
deepEqual
(
mapValue
expectedIndexes
.
map
(
i
=
>
qsResults
[
i
]
)
"
The
map
value
is
the
expected
array
of
result
objects
"
)
;
}
for
(
let
sponsored
of
[
true
false
]
)
{
for
(
let
nonsponsored
of
[
true
false
]
)
{
let
search
=
searches
.
find
(
s
=
>
s
.
sponsored
=
=
sponsored
&
&
s
.
nonsponsored
=
=
nonsponsored
)
;
Assert
.
ok
(
search
"
Sanity
check
:
Search
test
case
specified
for
"
+
JSON
.
stringify
(
{
keyword
sponsored
nonsponsored
}
)
)
;
info
(
"
Running
urlbar
search
subtest
"
+
JSON
.
stringify
(
{
keyword
expectedIndexes
search
}
)
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
sponsored
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
nonsponsored
)
;
let
context
=
createContext
(
keyword
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
matches
=
[
]
;
if
(
search
.
expectedIndex
!
=
=
undefined
)
{
matches
.
push
(
{
.
.
.
urlbarResults
[
search
.
expectedIndex
]
payload
:
{
.
.
.
urlbarResults
[
search
.
expectedIndex
]
.
payload
qsSuggestion
:
keyword
}
}
)
;
}
await
check_results
(
{
context
matches
}
)
;
}
}
}
}
)
;
