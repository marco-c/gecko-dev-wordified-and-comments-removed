"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
MLSuggest
:
"
resource
:
/
/
/
modules
/
urlbar
/
private
/
MLSuggest
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
const
ML_PREFS
=
[
"
browser
.
ml
.
enable
"
"
quicksuggest
.
mlEnabled
"
]
;
let
gSandbox
;
let
gInitializeStub
;
let
gShutdownStub
;
add_setup
(
async
function
init
(
)
{
gSandbox
=
sinon
.
createSandbox
(
)
;
gInitializeStub
=
gSandbox
.
stub
(
MLSuggest
"
initialize
"
)
;
gShutdownStub
=
gSandbox
.
stub
(
MLSuggest
"
shutdown
"
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
prefs
:
[
[
"
suggest
.
quicksuggest
.
nonsponsored
"
true
]
[
"
suggest
.
quicksuggest
.
sponsored
"
true
]
]
}
)
;
}
)
;
function
enableMl
(
enable
)
{
if
(
enable
)
{
for
(
let
p
of
ML_PREFS
)
{
UrlbarPrefs
.
set
(
p
true
)
;
}
}
else
{
for
(
let
p
of
ML_PREFS
)
{
UrlbarPrefs
.
clear
(
p
)
;
}
}
}
add_task
(
async
function
zeroDelay
(
)
{
let
startMs
=
Cu
.
now
(
)
;
enableMl
(
true
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
gInitializeStub
.
callCount
>
0
"
Waiting
for
initialize
to
be
called
"
)
;
let
elapsedMs
=
Cu
.
now
(
)
-
startMs
;
Assert
.
less
(
elapsedMs
1000
"
initialize
should
have
been
called
quickly
after
enabling
the
backend
"
)
;
enableMl
(
false
)
;
gInitializeStub
.
resetHistory
(
)
;
gShutdownStub
.
resetHistory
(
)
;
}
)
;
add_task
(
async
function
delay
(
)
{
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
{
quickSuggestMlInitDelaySeconds
:
4
}
)
;
enableMl
(
true
)
;
Assert
.
equal
(
gInitializeStub
.
callCount
0
"
initialize
should
not
have
been
called
immediately
after
enabling
ML
"
)
;
await
waitSeconds
(
2
)
;
Assert
.
equal
(
gInitializeStub
.
callCount
0
"
initialize
should
not
have
been
called
after
waiting
2s
"
)
;
await
waitSeconds
(
4
)
;
Assert
.
equal
(
gInitializeStub
.
callCount
1
"
initialize
should
have
been
called
after
waiting
a
total
of
6s
"
)
;
enableMl
(
false
)
;
Assert
.
equal
(
gShutdownStub
.
callCount
1
"
shutdown
should
have
been
called
after
disabling
ML
"
)
;
gInitializeStub
.
resetHistory
(
)
;
gShutdownStub
.
resetHistory
(
)
;
await
cleanUpNimbus
(
)
;
}
)
;
add_task
(
async
function
disabledBeforeTimerFires
(
)
{
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
{
quickSuggestMlInitDelaySeconds
:
3
}
)
;
enableMl
(
true
)
;
await
waitSeconds
(
1
)
;
enableMl
(
false
)
;
Assert
.
equal
(
gShutdownStub
.
callCount
1
"
shutdown
should
have
been
called
after
disabling
ML
"
)
;
await
waitSeconds
(
3
)
;
Assert
.
equal
(
gInitializeStub
.
callCount
0
"
initialize
should
not
have
been
called
after
waiting
2s
"
)
;
gInitializeStub
.
resetHistory
(
)
;
gShutdownStub
.
resetHistory
(
)
;
await
cleanUpNimbus
(
)
;
}
)
;
async
function
waitSeconds
(
s
)
{
info
(
Waiting
{
s
}
seconds
.
.
.
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
s
*
1000
)
)
;
}
