"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExperimentFakes
:
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
sys
.
mjs
"
MerinoClient
:
"
resource
:
/
/
/
modules
/
MerinoClient
.
sys
.
mjs
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
}
)
;
const
TEST_TIMEOUT_MS
=
30000
;
const
EXPECTED_MERINO_SUGGESTIONS
=
[
]
;
const
{
SEARCH_PARAMS
}
=
MerinoClient
;
let
gClient
;
add_setup
(
async
function
init
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
timeoutMs
"
TEST_TIMEOUT_MS
)
;
registerCleanupFunction
(
(
)
=
>
{
UrlbarPrefs
.
clear
(
"
merino
.
timeoutMs
"
)
;
}
)
;
gClient
=
new
MerinoClient
(
)
;
await
MerinoTestUtils
.
server
.
start
(
)
;
for
(
let
suggestion
of
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
)
{
EXPECTED_MERINO_SUGGESTIONS
.
push
(
{
.
.
.
suggestion
request_id
:
MerinoTestUtils
.
server
.
response
.
body
.
request_id
source
:
"
merino
"
}
)
;
}
}
)
;
add_task
(
async
function
name
(
)
{
Assert
.
equal
(
gClient
.
name
"
anonymous
"
"
gClient
name
is
'
anonymous
'
since
it
wasn
'
t
given
a
name
"
)
;
let
client
=
new
MerinoClient
(
"
New
client
"
)
;
Assert
.
equal
(
client
.
name
"
New
client
"
"
newClient
name
is
correct
"
)
;
}
)
;
add_task
(
async
function
success
(
)
{
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
request
successfully
finished
"
)
;
}
)
;
add_task
(
async
function
noSuggestions
(
)
{
let
{
suggestions
}
=
MerinoTestUtils
.
server
.
response
.
body
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
[
]
;
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
no_suggestion
"
"
The
request
successfully
finished
without
suggestions
"
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
suggestions
;
}
)
;
add_task
(
async
function
cache
(
)
{
MerinoTestUtils
.
enableClientCache
(
true
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
dateNowStub
=
sandbox
.
stub
(
Cu
.
getGlobalForObject
(
MerinoClient
)
.
Date
"
now
"
)
;
let
startDateMs
=
Date
.
now
(
)
;
dateNowStub
.
returns
(
startDateMs
)
;
let
provider
=
"
test
-
provider
"
;
let
client
=
new
MerinoClient
(
"
cache
-
test
"
{
cachePeriodMs
:
60
*
1000
}
)
;
let
fetches
=
[
{
timeOffsetMs
:
0
query
:
"
aaa
"
shouldCallMerino
:
true
}
{
timeOffsetMs
:
30
*
1000
query
:
"
aaa
"
shouldCallMerino
:
false
}
{
timeOffsetMs
:
60
*
1000
query
:
"
aaa
"
shouldCallMerino
:
true
}
{
timeOffsetMs
:
90
*
1000
query
:
"
aaa
"
shouldCallMerino
:
false
}
{
timeOffsetMs
:
200
*
1000
query
:
"
aaa
"
shouldCallMerino
:
true
}
{
timeOffsetMs
:
259
*
1000
query
:
"
aaa
"
shouldCallMerino
:
false
}
{
timeOffsetMs
:
260
*
1000
query
:
"
aaa
"
shouldCallMerino
:
true
}
{
timeOffsetMs
:
261
*
1000
query
:
"
aaa
"
shouldCallMerino
:
false
}
{
timeOffsetMs
:
262
*
1000
query
:
"
bbb
"
shouldCallMerino
:
true
}
{
timeOffsetMs
:
263
*
1000
query
:
"
bbb
"
shouldCallMerino
:
false
}
{
timeOffsetMs
:
264
*
1000
query
:
"
aaa
"
shouldCallMerino
:
true
}
{
timeOffsetMs
:
265
*
1000
query
:
"
aaa
"
shouldCallMerino
:
false
}
]
;
for
(
let
i
=
0
;
i
<
fetches
.
length
;
i
+
+
)
{
let
fetch
=
fetches
[
i
]
;
info
(
Fetch
{
i
}
start
:
+
JSON
.
stringify
(
fetch
)
)
;
let
{
timeOffsetMs
query
shouldCallMerino
}
=
fetch
;
dateNowStub
.
returns
(
startDateMs
+
timeOffsetMs
)
;
let
callsByProvider
=
await
doFetchAndGetCalls
(
client
{
query
providers
:
[
provider
]
}
)
;
info
(
Fetch
{
i
}
callsByProvider
:
+
JSON
.
stringify
(
callsByProvider
)
)
;
let
actualCalls
=
Object
.
entries
(
callsByProvider
)
.
map
(
(
[
p
calls
]
)
=
>
[
p
calls
.
map
(
params
=
>
{
params
.
delete
(
MerinoClient
.
SEARCH_PARAMS
.
SESSION_ID
)
;
params
.
delete
(
MerinoClient
.
SEARCH_PARAMS
.
SEQUENCE_NUMBER
)
;
return
params
.
toString
(
)
;
}
)
]
)
;
if
(
!
shouldCallMerino
)
{
Assert
.
deepEqual
(
actualCalls
[
]
Fetch
{
i
}
should
not
have
called
Merino
)
;
}
else
{
let
expectedParams
=
new
URLSearchParams
(
)
;
expectedParams
.
set
(
MerinoClient
.
SEARCH_PARAMS
.
PROVIDERS
provider
)
;
expectedParams
.
set
(
MerinoClient
.
SEARCH_PARAMS
.
QUERY
query
)
;
expectedParams
.
sort
(
)
;
Assert
.
deepEqual
(
actualCalls
[
[
provider
[
expectedParams
.
toString
(
)
]
]
]
Fetch
{
i
}
should
have
called
Merino
)
;
}
}
sandbox
.
restore
(
)
;
MerinoTestUtils
.
enableClientCache
(
false
)
;
}
)
;
async
function
doFetchAndGetCalls
(
client
fetchArgs
)
{
let
callsByProvider
=
{
}
;
MerinoTestUtils
.
server
.
requestHandler
=
req
=
>
{
let
params
=
new
URLSearchParams
(
req
.
queryString
)
;
params
.
sort
(
)
;
let
provider
=
params
.
get
(
"
providers
"
)
;
callsByProvider
[
provider
]
|
|
=
[
]
;
callsByProvider
[
provider
]
.
push
(
params
)
;
return
{
body
:
{
request_id
:
"
request_id
"
suggestions
:
[
{
foo
:
"
bar
"
}
]
}
}
;
}
;
await
client
.
fetch
(
fetchArgs
)
;
MerinoTestUtils
.
server
.
requestHandler
=
null
;
return
callsByProvider
;
}
add_task
(
async
function
unexpectedResponseProperties
(
)
{
MerinoTestUtils
.
server
.
response
.
body
.
unexpectedString
=
"
some
value
"
;
MerinoTestUtils
.
server
.
response
.
body
.
unexpectedArray
=
[
"
a
"
"
b
"
"
c
"
]
;
MerinoTestUtils
.
server
.
response
.
body
.
unexpectedObject
=
{
foo
:
"
bar
"
}
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
request
successfully
finished
"
)
;
}
)
;
add_task
(
async
function
unexpectedResponseBody
(
)
{
let
responses
=
[
{
body
:
{
}
}
{
body
:
{
bogus
:
[
]
}
}
{
body
:
{
suggestions
:
{
}
}
}
{
body
:
{
suggestions
:
[
]
}
}
{
body
:
"
"
}
{
body
:
"
bogus
"
contentType
:
"
text
/
html
"
}
]
;
for
(
let
r
of
responses
)
{
info
(
"
Testing
response
:
"
+
JSON
.
stringify
(
r
)
)
;
MerinoTestUtils
.
server
.
response
=
r
;
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
no_suggestion
"
"
The
request
successfully
finished
without
suggestions
"
)
;
}
MerinoTestUtils
.
server
.
reset
(
)
;
}
)
;
add_task
(
async
function
networkError
(
)
{
let
responsePromise
=
gClient
.
waitForNextResponse
(
)
;
await
MerinoTestUtils
.
server
.
withNetworkError
(
async
(
)
=
>
{
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
}
)
;
Assert
.
strictEqual
(
gClient
.
_test_timeoutTimer
null
"
timeoutTimer
does
not
exist
after
fetch
finished
"
)
;
await
responsePromise
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
network_error
"
"
The
request
failed
with
a
network
error
"
)
;
}
)
;
add_task
(
async
function
httpError
(
)
{
MerinoTestUtils
.
server
.
response
=
{
status
:
500
}
;
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
http_error
"
"
The
request
failed
with
an
HTTP
error
"
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
}
)
;
add_task
(
async
function
clientTimeout
(
)
{
await
doClientTimeoutTest
(
{
prefTimeoutMs
:
200
responseDelayMs
:
400
}
)
;
}
)
;
add_task
(
async
function
clientTimeoutFollowedByHTTPError
(
)
{
MerinoTestUtils
.
server
.
response
=
{
status
:
500
}
;
await
doClientTimeoutTest
(
{
prefTimeoutMs
:
200
responseDelayMs
:
400
expectedResponseStatus
:
500
}
)
;
}
)
;
add_task
(
async
function
timeoutPassedToFetch
(
)
{
await
doClientTimeoutTest
(
{
prefTimeoutMs
:
30000
responseDelayMs
:
400
fetchArgs
:
{
query
:
"
search
"
timeoutMs
:
1
}
}
)
;
}
)
;
async
function
doClientTimeoutTest
(
{
prefTimeoutMs
responseDelayMs
fetchArgs
=
{
query
:
"
search
"
}
expectedResponseStatus
=
200
}
=
{
}
)
{
let
originalPrefTimeoutMs
=
UrlbarPrefs
.
get
(
"
merino
.
timeoutMs
"
)
;
UrlbarPrefs
.
set
(
"
merino
.
timeoutMs
"
prefTimeoutMs
)
;
MerinoTestUtils
.
server
.
response
.
delay
=
responseDelayMs
;
let
responsePromise
=
gClient
.
waitForNextResponse
(
)
;
await
fetchAndCheckSuggestions
(
{
args
:
fetchArgs
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
timeout
"
"
The
request
timed
out
"
)
;
Assert
.
strictEqual
(
gClient
.
_test_timeoutTimer
null
"
timeoutTimer
does
not
exist
after
fetch
finished
"
)
;
Assert
.
ok
(
gClient
.
_test_fetchController
"
fetchController
still
exists
after
fetch
finished
"
)
;
Assert
.
ok
(
!
gClient
.
_test_fetchController
.
signal
.
aborted
"
fetchController
is
not
aborted
"
)
;
let
httpResponse
=
await
responsePromise
;
Assert
.
ok
(
httpResponse
"
Response
was
received
"
)
;
Assert
.
equal
(
httpResponse
.
status
expectedResponseStatus
"
Response
status
"
)
;
Assert
.
ok
(
!
gClient
.
_test_fetchController
"
fetchController
no
longer
exists
"
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
UrlbarPrefs
.
set
(
"
merino
.
timeoutMs
"
originalPrefTimeoutMs
)
;
}
add_task
(
async
function
newFetchAbortsPrevious
(
)
{
MerinoTestUtils
.
server
.
response
.
delay
=
100
*
UrlbarPrefs
.
get
(
"
merino
.
timeoutMs
"
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
timeout
"
"
The
request
timed
out
"
)
;
Assert
.
strictEqual
(
gClient
.
_test_timeoutTimer
null
"
timeoutTimer
does
not
exist
after
first
fetch
finished
"
)
;
Assert
.
ok
(
gClient
.
_test_fetchController
"
fetchController
still
exists
after
first
fetch
finished
"
)
;
Assert
.
ok
(
!
gClient
.
_test_fetchController
.
signal
.
aborted
"
fetchController
is
not
aborted
"
)
;
delete
MerinoTestUtils
.
server
.
response
.
delay
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
request
finished
successfully
"
)
;
Assert
.
ok
(
!
gClient
.
_test_fetchController
"
fetchController
does
not
exist
after
second
fetch
finished
"
)
;
Assert
.
strictEqual
(
gClient
.
_test_timeoutTimer
null
"
timeoutTimer
does
not
exist
after
second
fetch
finished
"
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
}
)
;
add_task
(
async
function
clientVariants_providers_notSet
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
clientVariants
"
"
"
)
;
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
"
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
clientVariants
"
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
clientVariants_providers_preferences
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
clientVariants
"
"
green
"
)
;
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
pink
"
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
[
SEARCH_PARAMS
.
CLIENT_VARIANTS
]
:
"
green
"
[
SEARCH_PARAMS
.
PROVIDERS
]
:
"
pink
"
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
clientVariants
"
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
providers_arg_single
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
prefShouldNotBeUsed
"
)
;
await
fetchAndCheckSuggestions
(
{
args
:
{
query
:
"
search
"
providers
:
[
"
argShouldBeUsed
"
]
}
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
[
SEARCH_PARAMS
.
PROVIDERS
]
:
"
argShouldBeUsed
"
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
providers_arg_many
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
prefShouldNotBeUsed
"
)
;
await
fetchAndCheckSuggestions
(
{
args
:
{
query
:
"
search
"
providers
:
[
"
one
"
"
two
"
"
three
"
]
}
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
[
SEARCH_PARAMS
.
PROVIDERS
]
:
"
one
two
three
"
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
providers_arg_empty
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
prefShouldNotBeUsed
"
)
;
await
fetchAndCheckSuggestions
(
{
args
:
{
query
:
"
search
"
providers
:
[
]
}
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
[
SEARCH_PARAMS
.
PROVIDERS
]
:
"
"
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
providers_arg_invalid
(
)
{
let
providersValues
=
[
"
"
"
nonempty
"
{
}
]
;
for
(
let
providers
of
providersValues
)
{
info
(
"
Calling
fetch
(
)
with
providers
:
"
+
JSON
.
stringify
(
providers
)
)
;
let
error
;
try
{
await
gClient
.
fetch
(
{
providers
query
:
"
search
"
}
)
;
}
catch
(
e
)
{
error
=
e
;
}
Assert
.
ok
(
error
"
fetch
(
)
threw
an
error
"
)
;
Assert
.
equal
(
error
.
message
"
providers
must
be
an
array
if
given
"
"
Expected
error
was
thrown
"
)
;
}
}
)
;
add_task
(
async
function
nimbus
(
)
{
let
originalEndpointURL
=
UrlbarPrefs
.
get
(
"
merino
.
endpointURL
"
)
;
UrlbarPrefs
.
set
(
"
merino
.
endpointURL
"
"
"
)
;
await
UrlbarTestUtils
.
initNimbusFeature
(
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
let
expectedParams
=
[
{
param
:
SEARCH_PARAMS
.
CLIENT_VARIANTS
value
:
"
test
-
client
-
variants
"
variable
:
"
merinoClientVariants
"
}
{
param
:
SEARCH_PARAMS
.
PROVIDERS
value
:
"
test
-
providers
"
variable
:
"
merinoProviders
"
}
]
;
let
experimentValues
=
{
merinoEndpointURL
:
MerinoTestUtils
.
server
.
url
.
toString
(
)
}
;
for
(
let
{
variable
value
}
of
expectedParams
)
{
experimentValues
[
variable
]
=
value
;
}
await
withExperiment
(
experimentValues
async
(
)
=
>
{
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
let
params
=
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
}
;
for
(
let
{
param
value
}
of
expectedParams
)
{
params
[
param
]
=
value
;
}
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
}
]
)
;
}
)
;
UrlbarPrefs
.
set
(
"
merino
.
endpointURL
"
originalEndpointURL
)
;
}
)
;
async
function
fetchAndCheckSuggestions
(
{
expected
args
=
{
query
:
"
search
"
}
}
)
{
let
actual
=
await
gClient
.
fetch
(
args
)
;
Assert
.
deepEqual
(
actual
expected
"
Expected
suggestions
"
)
;
gClient
.
resetSession
(
)
;
}
async
function
withExperiment
(
values
callback
)
{
const
doExperimentCleanup
=
await
ExperimentFakes
.
enrollWithFeatureConfig
(
{
featureId
:
NimbusFeatures
.
urlbar
.
featureId
value
:
{
enabled
:
true
.
.
.
values
}
}
{
slug
:
"
mock
-
experiment
"
branchSlug
:
"
treatment
"
}
)
;
await
callback
(
)
;
doExperimentCleanup
(
)
;
}
