"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
MerinoClient
:
"
resource
:
/
/
/
modules
/
MerinoClient
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ExperimentFakes
:
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
}
)
;
const
EXPECTED_MERINO_SUGGESTIONS
=
[
]
;
const
{
SEARCH_PARAMS
}
=
MerinoClient
;
let
gClient
;
add_task
(
async
function
init
(
)
{
gClient
=
new
MerinoClient
(
)
;
await
MerinoTestUtils
.
server
.
start
(
)
;
for
(
let
suggestion
of
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
)
{
EXPECTED_MERINO_SUGGESTIONS
.
push
(
{
.
.
.
suggestion
request_id
:
MerinoTestUtils
.
server
.
response
.
body
.
request_id
source
:
"
merino
"
}
)
;
}
}
)
;
add_task
(
async
function
name
(
)
{
Assert
.
equal
(
gClient
.
name
"
anonymous
"
"
gClient
name
is
'
anonymous
'
since
it
wasn
'
t
given
a
name
"
)
;
let
client
=
new
MerinoClient
(
"
New
client
"
)
;
Assert
.
equal
(
client
.
name
"
New
client
"
"
newClient
name
is
correct
"
)
;
}
)
;
add_task
(
async
function
basic
(
)
{
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
request
successfully
finished
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
success
"
latencyRecorded
:
true
client
:
gClient
}
)
;
}
)
;
add_task
(
async
function
unexpectedResponseProperties
(
)
{
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
unexpectedString
=
"
some
value
"
;
MerinoTestUtils
.
server
.
response
.
body
.
unexpectedArray
=
[
"
a
"
"
b
"
"
c
"
]
;
MerinoTestUtils
.
server
.
response
.
body
.
unexpectedObject
=
{
foo
:
"
bar
"
}
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
request
successfully
finished
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
success
"
latencyRecorded
:
true
client
:
gClient
}
)
;
}
)
;
add_task
(
async
function
unexpectedResponseBody
(
)
{
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
)
;
let
responses
=
[
{
body
:
{
}
}
{
body
:
{
bogus
:
[
]
}
}
{
body
:
{
suggestions
:
{
}
}
}
{
body
:
{
suggestions
:
[
]
}
}
{
body
:
"
"
}
{
body
:
"
bogus
"
contentType
:
"
text
/
html
"
}
]
;
for
(
let
r
of
responses
)
{
info
(
"
Testing
response
:
"
+
JSON
.
stringify
(
r
)
)
;
MerinoTestUtils
.
server
.
response
=
r
;
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
request
successfully
finished
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
success
"
latencyRecorded
:
true
client
:
gClient
}
)
;
}
MerinoTestUtils
.
server
.
reset
(
)
;
}
)
;
add_task
(
async
function
networkError
(
)
{
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
)
;
let
responsePromise
=
gClient
.
waitForNextResponse
(
)
;
await
MerinoTestUtils
.
server
.
withNetworkError
(
async
(
)
=
>
{
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
}
)
;
Assert
.
strictEqual
(
gClient
.
_test_timeoutTimer
null
"
timeoutTimer
does
not
exist
after
fetch
finished
"
)
;
await
responsePromise
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
network_error
"
"
The
request
failed
with
a
network
error
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
network_error
"
latencyRecorded
:
false
client
:
gClient
}
)
;
}
)
;
add_task
(
async
function
httpError
(
)
{
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
)
;
MerinoTestUtils
.
server
.
response
=
{
status
:
500
}
;
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
http_error
"
"
The
request
failed
with
an
HTTP
error
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
http_error
"
latencyRecorded
:
true
client
:
gClient
}
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
}
)
;
add_task
(
async
function
clientTimeout
(
)
{
await
doClientTimeoutTest
(
)
;
}
)
;
add_task
(
async
function
clientTimeoutFollowedByHTTPError
(
)
{
MerinoTestUtils
.
server
.
response
=
{
status
:
500
}
;
await
doClientTimeoutTest
(
{
expectedResponseStatus
:
500
}
)
;
}
)
;
add_task
(
async
function
timeoutPassedToFetch
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
timeoutMs
"
30000
)
;
await
doClientTimeoutTest
(
{
responseDelay
:
400
fetchArgs
:
{
query
:
"
search
"
timeoutMs
:
1
}
}
)
;
UrlbarPrefs
.
clear
(
"
merino
.
timeoutMs
"
)
;
}
)
;
async
function
doClientTimeoutTest
(
{
responseDelay
=
2
*
UrlbarPrefs
.
get
(
"
merino
.
timeoutMs
"
)
fetchArgs
=
{
query
:
"
search
"
}
expectedResponseStatus
=
200
}
=
{
}
)
{
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
)
;
MerinoTestUtils
.
server
.
response
.
delay
=
responseDelay
;
let
responsePromise
=
gClient
.
waitForNextResponse
(
)
;
await
fetchAndCheckSuggestions
(
{
args
:
fetchArgs
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
timeout
"
"
The
request
timed
out
"
)
;
Assert
.
strictEqual
(
gClient
.
_test_timeoutTimer
null
"
timeoutTimer
does
not
exist
after
fetch
finished
"
)
;
Assert
.
ok
(
gClient
.
_test_fetchController
"
fetchController
still
exists
after
fetch
finished
"
)
;
Assert
.
ok
(
!
gClient
.
_test_fetchController
.
signal
.
aborted
"
fetchController
is
not
aborted
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
timeout
"
latencyRecorded
:
false
latencyStopwatchRunning
:
true
client
:
gClient
}
)
;
let
httpResponse
=
await
responsePromise
;
Assert
.
ok
(
httpResponse
"
Response
was
received
"
)
;
Assert
.
equal
(
httpResponse
.
status
expectedResponseStatus
"
Response
status
"
)
;
Assert
.
ok
(
!
gClient
.
_test_fetchController
"
fetchController
no
longer
exists
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
null
latencyRecorded
:
true
client
:
gClient
}
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
}
add_task
(
async
function
newFetchAbortsPrevious
(
)
{
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
)
;
MerinoTestUtils
.
server
.
response
.
delay
=
10000
*
UrlbarPrefs
.
get
(
"
merino
.
timeoutMs
"
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
[
]
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
timeout
"
"
The
request
timed
out
"
)
;
Assert
.
strictEqual
(
gClient
.
_test_timeoutTimer
null
"
timeoutTimer
does
not
exist
after
first
fetch
finished
"
)
;
Assert
.
ok
(
gClient
.
_test_fetchController
"
fetchController
still
exists
after
first
fetch
finished
"
)
;
Assert
.
ok
(
!
gClient
.
_test_fetchController
.
signal
.
aborted
"
fetchController
is
not
aborted
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
timeout
"
latencyRecorded
:
false
latencyStopwatchRunning
:
true
client
:
gClient
}
)
;
delete
MerinoTestUtils
.
server
.
response
.
delay
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
request
finished
successfully
"
)
;
Assert
.
ok
(
!
gClient
.
_test_fetchController
"
fetchController
does
not
exist
after
second
fetch
finished
"
)
;
Assert
.
strictEqual
(
gClient
.
_test_timeoutTimer
null
"
timeoutTimer
does
not
exist
after
second
fetch
finished
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
success
"
latencyRecorded
:
true
client
:
gClient
}
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
}
)
;
add_task
(
async
function
clientVariants_providers_notSet
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
clientVariants
"
"
"
)
;
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
"
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
clientVariants
"
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
clientVariants_providers_preferences
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
clientVariants
"
"
green
"
)
;
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
pink
"
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
[
SEARCH_PARAMS
.
CLIENT_VARIANTS
]
:
"
green
"
[
SEARCH_PARAMS
.
PROVIDERS
]
:
"
pink
"
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
clientVariants
"
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
providers_arg_single
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
prefShouldNotBeUsed
"
)
;
await
fetchAndCheckSuggestions
(
{
args
:
{
query
:
"
search
"
providers
:
[
"
argShouldBeUsed
"
]
}
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
[
SEARCH_PARAMS
.
PROVIDERS
]
:
"
argShouldBeUsed
"
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
providers_arg_many
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
prefShouldNotBeUsed
"
)
;
await
fetchAndCheckSuggestions
(
{
args
:
{
query
:
"
search
"
providers
:
[
"
one
"
"
two
"
"
three
"
]
}
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
[
SEARCH_PARAMS
.
PROVIDERS
]
:
"
one
two
three
"
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
providers_arg_empty
(
)
{
UrlbarPrefs
.
set
(
"
merino
.
providers
"
"
prefShouldNotBeUsed
"
)
;
await
fetchAndCheckSuggestions
(
{
args
:
{
query
:
"
search
"
providers
:
[
]
}
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
[
SEARCH_PARAMS
.
PROVIDERS
]
:
"
"
}
}
]
)
;
UrlbarPrefs
.
clear
(
"
merino
.
providers
"
)
;
}
)
;
add_task
(
async
function
providers_arg_invalid
(
)
{
let
providersValues
=
[
"
"
"
nonempty
"
{
}
]
;
for
(
let
providers
of
providersValues
)
{
info
(
"
Calling
fetch
(
)
with
providers
:
"
+
JSON
.
stringify
(
providers
)
)
;
let
error
;
try
{
await
gClient
.
fetch
(
{
providers
query
:
"
search
"
}
)
;
}
catch
(
e
)
{
error
=
e
;
}
Assert
.
ok
(
error
"
fetch
(
)
threw
an
error
"
)
;
Assert
.
equal
(
error
.
message
"
providers
must
be
an
array
if
given
"
"
Expected
error
was
thrown
"
)
;
}
}
)
;
add_task
(
async
function
nimbus
(
)
{
let
originalEndpointURL
=
UrlbarPrefs
.
get
(
"
merino
.
endpointURL
"
)
;
UrlbarPrefs
.
set
(
"
merino
.
endpointURL
"
"
"
)
;
await
QuickSuggestTestUtils
.
initNimbusFeature
(
)
;
await
fetchAndCheckSuggestions
(
{
expected
:
null
}
)
;
let
expectedParams
=
[
{
param
:
SEARCH_PARAMS
.
CLIENT_VARIANTS
value
:
"
test
-
client
-
variants
"
variable
:
"
merinoClientVariants
"
}
{
param
:
SEARCH_PARAMS
.
PROVIDERS
value
:
"
test
-
providers
"
variable
:
"
merinoProviders
"
}
]
;
let
experimentValues
=
{
merinoEndpointURL
:
MerinoTestUtils
.
server
.
url
.
toString
(
)
}
;
for
(
let
{
variable
value
}
of
expectedParams
)
{
experimentValues
[
variable
]
=
value
;
}
await
withExperiment
(
experimentValues
async
(
)
=
>
{
await
fetchAndCheckSuggestions
(
{
expected
:
EXPECTED_MERINO_SUGGESTIONS
}
)
;
let
params
=
{
[
SEARCH_PARAMS
.
QUERY
]
:
"
search
"
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
}
;
for
(
let
{
param
value
}
of
expectedParams
)
{
params
[
param
]
=
value
;
}
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
}
]
)
;
}
)
;
UrlbarPrefs
.
set
(
"
merino
.
endpointURL
"
originalEndpointURL
)
;
}
)
;
async
function
fetchAndCheckSuggestions
(
{
expected
args
=
{
query
:
"
search
"
}
}
)
{
let
actual
=
await
gClient
.
fetch
(
args
)
;
Assert
.
deepEqual
(
actual
expected
"
Expected
suggestions
"
)
;
gClient
.
resetSession
(
)
;
}
async
function
withExperiment
(
values
callback
)
{
let
{
enrollmentPromise
doExperimentCleanup
}
=
ExperimentFakes
.
enrollmentHelper
(
ExperimentFakes
.
recipe
(
"
mock
-
experiment
"
{
active
:
true
branches
:
[
{
slug
:
"
treatment
"
features
:
[
{
featureId
:
NimbusFeatures
.
urlbar
.
featureId
value
:
{
enabled
:
true
.
.
.
values
}
}
]
}
]
}
)
)
;
await
enrollmentPromise
;
await
callback
(
)
;
await
doExperimentCleanup
(
)
;
}
