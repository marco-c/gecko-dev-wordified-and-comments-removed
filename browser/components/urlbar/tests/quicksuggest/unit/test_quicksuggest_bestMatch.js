"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
jsm
"
}
)
;
const
MAX_RESULT_COUNT
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
const
BEST_MATCH_SEARCH_STRING
=
"
bestmatch
"
;
const
NON_BEST_MATCH_SEARCH_STRING
=
"
foobar
"
;
const
BEST_MATCH_POSITION_SEARCH_STRING
=
"
bestmatchposition
"
;
const
BEST_MATCH_POSITION
=
Math
.
round
(
MAX_RESULT_COUNT
/
2
)
;
const
SUGGESTIONS
=
[
{
id
:
1
url
:
"
http
:
/
/
example
.
com
/
best
-
match
"
title
:
{
BEST_MATCH_SEARCH_STRING
}
title
keywords
:
[
BEST_MATCH_SEARCH_STRING
.
slice
(
0
-
1
)
BEST_MATCH_SEARCH_STRING
]
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
_test_is_best_match
:
true
}
{
id
:
2
url
:
"
http
:
/
/
example
.
com
/
non
-
best
-
match
"
title
:
{
NON_BEST_MATCH_SEARCH_STRING
}
title
keywords
:
[
NON_BEST_MATCH_SEARCH_STRING
.
slice
(
0
-
1
)
NON_BEST_MATCH_SEARCH_STRING
]
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
}
{
id
:
3
url
:
"
http
:
/
/
example
.
com
/
best
-
match
-
position
"
title
:
{
BEST_MATCH_POSITION_SEARCH_STRING
}
title
keywords
:
[
BEST_MATCH_POSITION_SEARCH_STRING
]
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
position
:
BEST_MATCH_POSITION
_test_is_best_match
:
true
}
]
;
const
EXPECTED_BEST_MATCH_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
isBestMatch
:
true
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
best
-
match
"
title
:
{
BEST_MATCH_SEARCH_STRING
}
title
icon
:
null
isSponsored
:
true
sponsoredImpressionUrl
:
"
http
:
/
/
example
.
com
/
impression
"
sponsoredClickUrl
:
"
http
:
/
/
example
.
com
/
click
"
sponsoredBlockId
:
1
sponsoredAdvertiser
:
"
TestAdvertiser
"
helpUrl
:
UrlbarProviderQuickSuggest
.
helpUrl
helpL10nId
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
displayUrl
:
"
http
:
/
/
example
.
com
/
best
-
match
"
source
:
"
remote
-
settings
"
}
}
;
const
EXPECTED_NON_BEST_MATCH_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
non
-
best
-
match
"
title
:
{
NON_BEST_MATCH_SEARCH_STRING
}
title
qsSuggestion
:
NON_BEST_MATCH_SEARCH_STRING
icon
:
null
isSponsored
:
true
sponsoredImpressionUrl
:
"
http
:
/
/
example
.
com
/
impression
"
sponsoredClickUrl
:
"
http
:
/
/
example
.
com
/
click
"
sponsoredBlockId
:
2
sponsoredAdvertiser
:
"
TestAdvertiser
"
helpUrl
:
UrlbarProviderQuickSuggest
.
helpUrl
helpL10nId
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
displayUrl
:
"
http
:
/
/
example
.
com
/
non
-
best
-
match
"
source
:
"
remote
-
settings
"
}
}
;
const
EXPECTED_BEST_MATCH_POSITION_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
isBestMatch
:
true
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
best
-
match
-
position
"
title
:
{
BEST_MATCH_POSITION_SEARCH_STRING
}
title
icon
:
null
isSponsored
:
true
sponsoredImpressionUrl
:
"
http
:
/
/
example
.
com
/
impression
"
sponsoredClickUrl
:
"
http
:
/
/
example
.
com
/
click
"
sponsoredBlockId
:
3
sponsoredAdvertiser
:
"
TestAdvertiser
"
helpUrl
:
UrlbarProviderQuickSuggest
.
helpUrl
helpL10nId
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
displayUrl
:
"
http
:
/
/
example
.
com
/
best
-
match
-
position
"
source
:
"
remote
-
settings
"
}
}
;
add_task
(
async
function
init
(
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
bestMatch
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
SUGGESTIONS
)
;
}
)
;
add_task
(
async
function
bestMatch
(
)
{
let
context
=
createContext
(
BEST_MATCH_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_BEST_MATCH_RESULT
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
{
BEST_MATCH_SEARCH_STRING
}
title
"
result
.
title
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
[
0
BEST_MATCH_SEARCH_STRING
.
length
]
]
"
result
.
titleHighlights
"
)
;
Assert
.
equal
(
result
.
suggestedIndex
1
"
result
.
suggestedIndex
"
)
;
Assert
.
equal
(
!
!
result
.
isSuggestedIndexRelativeToGroup
false
"
result
.
isSuggestedIndexRelativeToGroup
"
)
;
}
)
;
add_task
(
async
function
nonBestMatch
(
)
{
let
searchString
=
NON_BEST_MATCH_SEARCH_STRING
.
slice
(
0
-
1
)
;
let
context
=
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_NON_BEST_MATCH_RESULT
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
{
NON_BEST_MATCH_SEARCH_STRING
}
{
NON_BEST_MATCH_SEARCH_STRING
}
title
"
result
.
title
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
[
NON_BEST_MATCH_SEARCH_STRING
.
length
-
1
1
]
]
"
result
.
titleHighlights
"
)
;
Assert
.
equal
(
result
.
suggestedIndex
-
1
"
result
.
suggestedIndex
"
)
;
Assert
.
equal
(
result
.
isSuggestedIndexRelativeToGroup
true
"
result
.
isSuggestedIndexRelativeToGroup
"
)
;
}
)
;
add_task
(
async
function
tabToSearch
(
)
{
UrlbarPrefs
.
set
(
"
tabToSearch
.
onboard
.
interactionsLeft
"
0
)
;
let
engineURL
=
https
:
/
/
foo
.
{
BEST_MATCH_SEARCH_STRING
}
.
com
/
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
Test
"
search_url
:
engineURL
}
true
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
Test
"
)
;
await
PlacesTestUtils
.
addVisits
(
engineURL
)
;
let
context
=
createContext
(
BEST_MATCH_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
Services
.
search
.
defaultEngine
.
iconURI
?
.
spec
heuristic
:
true
}
)
makeSearchResult
(
context
{
engineName
:
engine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
uri
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
engine
.
getResultDomain
(
)
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
satisfiesAutofillThreshold
:
true
}
)
EXPECTED_BEST_MATCH_RESULT
makeVisitResult
(
context
{
uri
:
engineURL
title
:
test
visit
for
{
engineURL
}
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
UrlbarPrefs
.
clear
(
"
tabToSearch
.
onboard
.
interactionsLeft
"
)
;
}
)
;
add_task
(
async
function
disabled
(
)
{
UrlbarPrefs
.
set
(
"
bestMatch
.
enabled
"
false
)
;
let
expectedResult
=
{
.
.
.
EXPECTED_BEST_MATCH_RESULT
}
;
delete
expectedResult
.
isBestMatch
;
expectedResult
.
payload
=
{
.
.
.
expectedResult
.
payload
}
;
expectedResult
.
payload
.
qsSuggestion
=
BEST_MATCH_SEARCH_STRING
;
let
searchString
=
BEST_MATCH_SEARCH_STRING
.
slice
(
0
-
1
)
;
let
context
=
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedResult
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
{
BEST_MATCH_SEARCH_STRING
}
{
BEST_MATCH_SEARCH_STRING
}
title
"
result
.
title
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
[
BEST_MATCH_SEARCH_STRING
.
length
-
1
1
]
]
"
result
.
titleHighlights
"
)
;
Assert
.
equal
(
result
.
suggestedIndex
-
1
"
result
.
suggestedIndex
"
)
;
Assert
.
equal
(
result
.
isSuggestedIndexRelativeToGroup
true
"
result
.
isSuggestedIndexRelativeToGroup
"
)
;
UrlbarPrefs
.
set
(
"
bestMatch
.
enabled
"
true
)
;
}
)
;
add_task
(
async
function
position
(
)
{
Assert
.
greater
(
BEST_MATCH_POSITION
1
"
Precondition
:
suggestion
.
position
>
the
best
match
index
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
allowPositionInSuggestions
"
true
)
;
let
context
=
createContext
(
BEST_MATCH_POSITION_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResultCount
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
visitResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResultCount
;
i
+
+
)
{
let
url
=
http
:
/
/
example
.
com
/
{
BEST_MATCH_POSITION_SEARCH_STRING
}
-
{
i
}
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
visitResults
.
unshift
(
makeVisitResult
(
context
{
uri
:
url
title
:
test
visit
for
{
url
}
}
)
)
;
}
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
Services
.
search
.
defaultEngine
.
iconURI
?
.
spec
heuristic
:
true
}
)
EXPECTED_BEST_MATCH_POSITION_RESULT
.
.
.
visitResults
.
slice
(
0
MAX_RESULT_COUNT
-
2
)
]
}
)
;
await
cleanupPlaces
(
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
allowPositionInSuggestions
"
)
;
}
)
;
