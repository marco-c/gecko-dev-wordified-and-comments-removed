"
use
strict
"
;
const
MAX_RESULT_COUNT
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
const
BEST_MATCH_POSITION_SEARCH_STRING
=
"
bestmatchposition
"
;
const
BEST_MATCH_POSITION
=
Math
.
round
(
MAX_RESULT_COUNT
/
2
)
;
const
REMOTE_SETTINGS_RESULTS
=
[
{
id
:
1
url
:
"
http
:
/
/
example
.
com
/
"
title
:
"
Fullkeyword
title
"
keywords
:
[
"
fu
"
"
ful
"
"
full
"
"
fullk
"
"
fullke
"
"
fullkey
"
"
fullkeyw
"
"
fullkeywo
"
"
fullkeywor
"
"
fullkeyword
"
"
example
"
]
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
}
{
id
:
2
url
:
"
http
:
/
/
example
.
com
/
best
-
match
-
position
"
title
:
{
BEST_MATCH_POSITION_SEARCH_STRING
}
title
keywords
:
[
BEST_MATCH_POSITION_SEARCH_STRING
]
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
position
:
BEST_MATCH_POSITION
}
]
;
const
EXPECTED_BEST_MATCH_URLBAR_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
isBestMatch
:
true
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
"
originalUrl
:
"
http
:
/
/
example
.
com
/
"
title
:
"
Fullkeyword
title
"
icon
:
null
isSponsored
:
true
sponsoredImpressionUrl
:
"
http
:
/
/
example
.
com
/
impression
"
sponsoredClickUrl
:
"
http
:
/
/
example
.
com
/
click
"
sponsoredBlockId
:
1
sponsoredAdvertiser
:
"
TestAdvertiser
"
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
false
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
displayUrl
:
"
http
:
/
/
example
.
com
"
source
:
"
remote
-
settings
"
}
}
;
const
EXPECTED_NON_BEST_MATCH_URLBAR_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
"
originalUrl
:
"
http
:
/
/
example
.
com
/
"
title
:
"
Fullkeyword
title
"
qsSuggestion
:
"
fullkeyword
"
icon
:
null
isSponsored
:
true
sponsoredImpressionUrl
:
"
http
:
/
/
example
.
com
/
impression
"
sponsoredClickUrl
:
"
http
:
/
/
example
.
com
/
click
"
sponsoredBlockId
:
1
sponsoredAdvertiser
:
"
TestAdvertiser
"
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
false
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
displayUrl
:
"
http
:
/
/
example
.
com
"
source
:
"
remote
-
settings
"
}
}
;
const
EXPECTED_BEST_MATCH_POSITION_URLBAR_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
isBestMatch
:
true
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
best
-
match
-
position
"
originalUrl
:
"
http
:
/
/
example
.
com
/
best
-
match
-
position
"
title
:
{
BEST_MATCH_POSITION_SEARCH_STRING
}
title
icon
:
null
isSponsored
:
true
sponsoredImpressionUrl
:
"
http
:
/
/
example
.
com
/
impression
"
sponsoredClickUrl
:
"
http
:
/
/
example
.
com
/
click
"
sponsoredBlockId
:
2
sponsoredAdvertiser
:
"
TestAdvertiser
"
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
false
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
displayUrl
:
"
http
:
/
/
example
.
com
/
best
-
match
-
position
"
source
:
"
remote
-
settings
"
}
}
;
add_task
(
async
function
init
(
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
bestMatch
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
bestmatch
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsResults
:
REMOTE_SETTINGS_RESULTS
}
)
;
}
)
;
add_task
(
async
function
bestMatch
(
)
{
let
context
=
createContext
(
"
fullkeyword
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_BEST_MATCH_URLBAR_RESULT
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
"
Fullkeyword
title
"
"
result
.
title
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
[
0
"
fullkeyword
"
.
length
]
]
"
result
.
titleHighlights
"
)
;
Assert
.
equal
(
result
.
suggestedIndex
1
"
result
.
suggestedIndex
"
)
;
Assert
.
equal
(
!
!
result
.
isSuggestedIndexRelativeToGroup
false
"
result
.
isSuggestedIndexRelativeToGroup
"
)
;
}
)
;
add_task
(
async
function
nonBestMatch
(
)
{
let
context
=
createContext
(
"
fu
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_NON_BEST_MATCH_URLBAR_RESULT
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
"
fullkeyword
Fullkeyword
title
"
"
result
.
title
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
[
"
fu
"
.
length
"
fullkeyword
"
.
length
-
"
fu
"
.
length
]
]
"
result
.
titleHighlights
"
)
;
Assert
.
equal
(
result
.
suggestedIndex
-
1
"
result
.
suggestedIndex
"
)
;
Assert
.
equal
(
result
.
isSuggestedIndexRelativeToGroup
true
"
result
.
isSuggestedIndexRelativeToGroup
"
)
;
}
)
;
add_task
(
async
function
prefixKeywords
(
)
{
let
sawNonBestMatch
=
false
;
let
sawBestMatch
=
false
;
for
(
let
keyword
of
REMOTE_SETTINGS_RESULTS
[
0
]
.
keywords
)
{
info
(
Searching
for
"
{
keyword
}
"
)
;
let
context
=
createContext
(
keyword
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
expectedResult
;
if
(
keyword
.
length
<
4
)
{
expectedResult
=
EXPECTED_NON_BEST_MATCH_URLBAR_RESULT
;
sawNonBestMatch
=
true
;
}
else
{
expectedResult
=
EXPECTED_BEST_MATCH_URLBAR_RESULT
;
sawBestMatch
=
true
;
}
await
check_results
(
{
context
matches
:
[
expectedResult
]
}
)
;
}
Assert
.
ok
(
sawNonBestMatch
"
Sanity
check
:
Saw
a
non
-
best
match
"
)
;
Assert
.
ok
(
sawBestMatch
"
Sanity
check
:
Saw
a
best
match
"
)
;
}
)
;
add_task
(
async
function
tabToSearch
(
)
{
UrlbarPrefs
.
set
(
"
tabToSearch
.
onboard
.
interactionsLeft
"
0
)
;
let
engineURL
=
"
https
:
/
/
foo
.
fullkeyword
.
com
/
"
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
Test
"
search_url
:
engineURL
}
{
skipUnload
:
true
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
Test
"
)
;
await
PlacesTestUtils
.
addVisits
(
engineURL
)
;
let
context
=
createContext
(
"
fullkeyword
"
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
Services
.
search
.
defaultEngine
.
iconURI
?
.
spec
heuristic
:
true
}
)
makeSearchResult
(
context
{
engineName
:
engine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
uri
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
engine
.
getResultDomain
(
)
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
satisfiesAutofillThreshold
:
true
}
)
EXPECTED_BEST_MATCH_URLBAR_RESULT
makeVisitResult
(
context
{
uri
:
engineURL
title
:
test
visit
for
{
engineURL
}
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
UrlbarPrefs
.
clear
(
"
tabToSearch
.
onboard
.
interactionsLeft
"
)
;
}
)
;
add_task
(
async
function
disabled_featureGate
(
)
{
UrlbarPrefs
.
set
(
"
bestMatch
.
enabled
"
false
)
;
await
doDisabledTest
(
)
;
UrlbarPrefs
.
set
(
"
bestMatch
.
enabled
"
true
)
;
}
)
;
add_task
(
async
function
disabled_suggestions
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
bestmatch
"
false
)
;
await
doDisabledTest
(
)
;
UrlbarPrefs
.
set
(
"
suggest
.
bestmatch
"
true
)
;
}
)
;
async
function
doDisabledTest
(
)
{
let
context
=
createContext
(
"
fullkeywor
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_NON_BEST_MATCH_URLBAR_RESULT
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
"
fullkeyword
Fullkeyword
title
"
"
result
.
title
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
[
"
fullkeywor
"
.
length
1
]
]
"
result
.
titleHighlights
"
)
;
Assert
.
equal
(
result
.
suggestedIndex
-
1
"
result
.
suggestedIndex
"
)
;
Assert
.
equal
(
result
.
isSuggestedIndexRelativeToGroup
true
"
result
.
isSuggestedIndexRelativeToGroup
"
)
;
}
add_task
(
async
function
position
(
)
{
Assert
.
greater
(
BEST_MATCH_POSITION
1
"
Precondition
:
suggestion
.
position
>
the
best
match
index
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
allowPositionInSuggestions
"
true
)
;
let
context
=
createContext
(
BEST_MATCH_POSITION_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResultCount
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
visitResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResultCount
;
i
+
+
)
{
let
url
=
http
:
/
/
example
.
com
/
{
BEST_MATCH_POSITION_SEARCH_STRING
}
-
{
i
}
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
visitResults
.
unshift
(
makeVisitResult
(
context
{
uri
:
url
title
:
test
visit
for
{
url
}
}
)
)
;
}
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
Services
.
search
.
defaultEngine
.
iconURI
?
.
spec
heuristic
:
true
}
)
EXPECTED_BEST_MATCH_POSITION_URLBAR_RESULT
.
.
.
visitResults
.
slice
(
0
MAX_RESULT_COUNT
-
2
)
]
}
)
;
await
cleanupPlaces
(
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
allowPositionInSuggestions
"
)
;
}
)
;
add_task
(
async
function
blockedAsBestMatch
(
)
{
let
config
=
QuickSuggestTestUtils
.
DEFAULT_CONFIG
;
config
.
best_match
.
blocked_suggestion_ids
=
[
1
]
;
await
QuickSuggestTestUtils
.
withConfig
(
{
config
callback
:
async
(
)
=
>
{
let
context
=
createContext
(
"
fullkeyword
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_NON_BEST_MATCH_URLBAR_RESULT
]
}
)
;
}
}
)
;
}
)
;
add_task
(
async
function
noConfig
(
)
{
await
QuickSuggestTestUtils
.
withConfig
(
{
config
:
{
}
callback
:
async
(
)
=
>
{
let
context
=
createContext
(
"
fullkeyword
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_NON_BEST_MATCH_URLBAR_RESULT
]
}
)
;
}
}
)
;
}
)
;
add_task
(
async
function
hueristicDeduplication
(
)
{
let
scenarios
=
[
[
"
http
:
/
/
example
.
com
/
"
false
]
[
"
http
:
/
/
www
.
example
.
com
/
"
false
]
[
"
http
:
/
/
exampledomain
.
com
/
"
true
]
]
;
for
(
let
[
url
expectBestMatch
]
of
scenarios
)
{
await
PlacesTestUtils
.
addVisits
(
url
)
;
let
context
=
createContext
(
"
example
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
UrlbarProviderAutofill
.
name
]
isPrivate
:
false
}
)
;
const
EXPECTED_AUTOFILL_RESULT
=
makeVisitResult
(
context
{
uri
:
url
title
:
test
visit
for
{
url
}
heuristic
:
true
}
)
;
await
check_results
(
{
context
matches
:
expectBestMatch
?
[
EXPECTED_AUTOFILL_RESULT
EXPECTED_BEST_MATCH_URLBAR_RESULT
]
:
[
EXPECTED_AUTOFILL_RESULT
]
}
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
}
)
;
