"
use
strict
"
;
const
PREF
=
"
browser
.
urlbar
.
quicksuggest
.
blockedDigests
"
;
add_setup
(
async
function
(
)
{
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasDefaultValue
(
PREF
)
"
Sanity
check
:
Pref
should
not
have
a
default
-
branch
value
"
)
;
}
)
;
add_task
(
async
function
notDefined
(
)
{
await
doTest
(
null
[
]
)
;
}
)
;
add_task
(
async
function
emptyString
(
)
{
await
doTest
(
"
"
[
]
)
;
}
)
;
add_task
(
async
function
invalidJson1
(
)
{
await
doTest
(
"
bogus
"
[
]
)
;
}
)
;
add_task
(
async
function
invalidJson2
(
)
{
await
doTest
(
"
{
"
[
]
)
;
}
)
;
add_task
(
async
function
falsey
(
)
{
await
doTest
(
JSON
.
stringify
(
null
)
[
]
)
;
}
)
;
add_task
(
async
function
notAnArray1
(
)
{
await
doTest
(
JSON
.
stringify
(
123
)
[
]
)
;
}
)
;
add_task
(
async
function
notAnArray2
(
)
{
await
doTest
(
JSON
.
stringify
(
{
}
)
[
]
)
;
}
)
;
add_task
(
async
function
notAnArrayOfStrings
(
)
{
await
doTest
(
JSON
.
stringify
(
[
123
456
]
)
[
]
)
;
}
)
;
add_task
(
async
function
oneKey
(
)
{
let
keys
=
[
"
aaa
"
]
;
await
doTest
(
JSON
.
stringify
(
keys
)
keys
)
;
}
)
;
add_task
(
async
function
manyKeys
(
)
{
let
keys
=
[
"
aaa
"
"
bbb
"
"
ccc
"
"
ddd
"
"
eee
"
]
;
await
doTest
(
JSON
.
stringify
(
keys
)
keys
)
;
}
)
;
add_task
(
async
function
manyKeysSomeInvalid
(
)
{
await
doTest
(
JSON
.
stringify
(
[
"
aaa
"
123
"
bbb
"
456
"
ccc
"
]
)
[
"
aaa
"
"
bbb
"
"
ccc
"
]
)
;
}
)
;
add_task
(
async
function
keysAlreadyPresent
(
)
{
await
QuickSuggest
.
rustBackend
.
dismissByKey
(
"
yyy
"
)
;
await
QuickSuggest
.
rustBackend
.
dismissByKey
(
"
zzz
"
)
;
await
doTest
(
JSON
.
stringify
(
[
"
aaa
"
"
bbb
"
"
ccc
"
]
)
[
"
aaa
"
"
bbb
"
"
ccc
"
"
yyy
"
"
zzz
"
]
)
;
}
)
;
async
function
doTest
(
prefValue
expectedDismissalKeys
)
{
let
{
rustBackend
}
=
QuickSuggest
;
rustBackend
.
enable
(
false
)
;
if
(
prefValue
=
=
=
null
)
{
Services
.
prefs
.
clearUserPref
(
PREF
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
PREF
)
"
Sanity
check
:
Pref
should
not
have
user
value
after
clearing
it
"
)
;
}
else
{
Services
.
prefs
.
setCharPref
(
PREF
prefValue
)
;
Assert
.
ok
(
Services
.
prefs
.
prefHasUserValue
(
PREF
)
"
Sanity
check
:
Pref
should
have
user
value
after
setting
it
"
)
;
}
rustBackend
.
enable
(
true
)
;
await
rustBackend
.
_test_ingest
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
Services
.
prefs
.
prefHasUserValue
(
PREF
)
"
Waiting
for
the
Rust
backend
to
complete
the
dismissals
migration
"
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF
)
)
{
Assert
.
ok
(
false
"
The
backend
should
have
completed
the
migration
"
)
;
return
;
}
Assert
.
equal
(
await
rustBackend
.
anyDismissedSuggestions
(
)
!
!
expectedDismissalKeys
.
length
"
anyDismissedSuggestions
should
match
expectedDismissalKeys
"
)
;
for
(
let
key
of
expectedDismissalKeys
)
{
Assert
.
ok
(
await
rustBackend
.
isDismissedByKey
(
key
)
"
Dismissal
key
should
be
recorded
:
"
+
key
)
;
}
await
rustBackend
.
clearDismissedSuggestions
(
)
;
}
