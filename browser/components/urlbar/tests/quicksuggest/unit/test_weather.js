"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
MockRegistrar
:
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
UrlbarProviderWeather
:
"
resource
:
/
/
/
modules
/
UrlbarProviderWeather
.
sys
.
mjs
"
}
)
;
const
HISTOGRAM_LATENCY
=
"
FX_URLBAR_MERINO_LATENCY_WEATHER_MS
"
;
const
HISTOGRAM_RESPONSE
=
"
FX_URLBAR_MERINO_RESPONSE_WEATHER
"
;
const
{
WEATHER_SUGGESTION
}
=
MerinoTestUtils
;
add_task
(
async
function
init
(
)
{
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
await
MerinoTestUtils
.
initWeather
(
)
;
QuickSuggest
.
weather
.
_test_fetchDelayAfterComingOnlineMs
=
53
;
}
)
;
add_task
(
async
function
disableAndEnable_featureGate
(
)
{
await
doBasicDisableAndEnableTest
(
"
weather
.
featureGate
"
)
;
}
)
;
add_task
(
async
function
disableAndEnable_suggestPref
(
)
{
await
doBasicDisableAndEnableTest
(
"
suggest
.
weather
"
)
;
}
)
;
async
function
doBasicDisableAndEnableTest
(
pref
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
UrlbarPrefs
.
set
(
pref
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
"
pendingFetchCount
:
0
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
info
(
"
Re
-
enable
the
feature
"
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
pref
true
)
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
"
hasSuggestion
:
false
pendingFetchCount
:
1
}
)
;
await
fetchPromise
;
assertEnabled
(
{
message
:
"
After
awaiting
fetch
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
success
"
"
The
request
successfully
finished
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
success
"
latencyRecorded
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeExpectedResult
(
)
]
}
)
;
}
add_task
(
async
function
disableAndEnable_immediate1
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
"
pendingFetchCount
:
0
}
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
true
)
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
"
hasSuggestion
:
false
pendingFetchCount
:
1
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
again
"
pendingFetchCount
:
1
}
)
;
await
fetchPromise
;
assertDisabled
(
{
message
:
"
After
awaiting
fetch
"
pendingFetchCount
:
0
}
)
;
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
true
)
;
await
fetchPromise
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
disableAndEnable_immediate2
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
"
pendingFetchCount
:
0
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
true
)
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
"
hasSuggestion
:
false
pendingFetchCount
:
1
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
again
"
pendingFetchCount
:
1
}
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
true
)
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
again
"
hasSuggestion
:
false
pendingFetchCount
:
2
}
)
;
await
fetchPromise
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
again
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
noSuggestion
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
let
{
suggestions
}
=
MerinoTestUtils
.
server
.
response
.
body
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
[
]
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
After
fetch
"
hasSuggestion
:
false
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
no_suggestion
"
"
The
request
successfully
finished
without
suggestions
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
no_suggestion
"
latencyRecorded
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
suggestions
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
networkError
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
QuickSuggest
.
weather
.
_test_setTimeoutMs
(
10000
)
;
await
MerinoTestUtils
.
server
.
withNetworkError
(
async
(
)
=
>
{
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
}
)
;
QuickSuggest
.
weather
.
_test_setTimeoutMs
(
-
1
)
;
assertEnabled
(
{
message
:
"
After
fetch
"
hasSuggestion
:
false
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
network_error
"
"
The
request
failed
with
a
network
error
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
network_error
"
latencyRecorded
:
false
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
httpError
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
MerinoTestUtils
.
server
.
response
=
{
status
:
500
}
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
After
fetch
"
hasSuggestion
:
false
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
http_error
"
"
The
request
failed
with
an
HTTP
error
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
http_error
"
latencyRecorded
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
[
WEATHER_SUGGESTION
]
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
clientTimeout
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
MerinoTestUtils
.
server
.
response
.
delay
=
400
;
QuickSuggest
.
weather
.
_test_setTimeoutMs
(
1
)
;
let
responsePromise
=
QuickSuggest
.
weather
.
_test_merino
.
waitForNextResponse
(
)
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
After
fetch
"
hasSuggestion
:
false
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
timeout
"
"
The
request
timed
out
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
timeout
"
latencyRecorded
:
false
latencyStopwatchRunning
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
await
responsePromise
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
null
latencyRecorded
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
QuickSuggest
.
weather
.
_test_setTimeoutMs
(
-
1
)
;
delete
MerinoTestUtils
.
server
.
response
.
delay
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
locale_enUS
(
)
{
await
doLocaleTest
(
{
shouldRunTask
:
osLocale
=
>
osLocale
=
=
"
en
-
US
"
osUnit
:
"
f
"
unitsByLocale
:
{
"
en
-
US
"
:
"
f
"
"
en
-
CA
"
:
"
f
"
"
en
-
GB
"
:
"
f
"
de
:
"
c
"
}
}
)
;
}
)
;
add_task
(
async
function
locale_nonUSEnglish
(
)
{
await
doLocaleTest
(
{
shouldRunTask
:
osLocale
=
>
osLocale
.
startsWith
(
"
en
"
)
&
&
osLocale
!
=
"
en
-
US
"
osUnit
:
"
c
"
unitsByLocale
:
{
"
en
-
US
"
:
"
c
"
"
en
-
CA
"
:
"
c
"
"
en
-
GB
"
:
"
c
"
de
:
"
c
"
}
}
)
;
}
)
;
add_task
(
async
function
locale_nonEnglish
(
)
{
await
doLocaleTest
(
{
shouldRunTask
:
osLocale
=
>
!
osLocale
.
startsWith
(
"
en
"
)
osUnit
:
"
c
"
unitsByLocale
:
{
"
en
-
US
"
:
"
f
"
"
en
-
CA
"
:
"
c
"
"
en
-
GB
"
:
"
c
"
de
:
"
c
"
}
}
)
;
}
)
;
async
function
doLocaleTest
(
{
shouldRunTask
osUnit
unitsByLocale
}
)
{
Services
.
prefs
.
setBoolPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
true
)
;
let
osLocale
=
Services
.
locale
.
regionalPrefsLocales
[
0
]
;
Services
.
prefs
.
clearUserPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
)
;
if
(
!
shouldRunTask
(
osLocale
)
)
{
info
(
"
Skipping
task
should
not
run
for
this
OS
locale
"
)
;
return
;
}
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
Services
.
locale
.
appLocaleAsBCP47
"
en
-
US
"
"
Initial
app
locale
should
be
en
-
US
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
)
"
intl
.
regional_prefs
.
use_os_locales
should
be
false
initially
"
)
;
for
(
let
[
locale
temperatureUnit
]
of
Object
.
entries
(
unitsByLocale
)
)
{
await
QuickSuggestTestUtils
.
withLocales
(
[
locale
]
async
(
)
=
>
{
info
(
"
Checking
locale
:
"
+
locale
)
;
await
check_results
(
{
context
:
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
makeExpectedResult
(
{
temperatureUnit
}
)
]
}
)
;
info
(
"
Checking
locale
with
intl
.
regional_prefs
.
use_os_locales
:
"
+
locale
)
;
Services
.
prefs
.
setBoolPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
true
)
;
await
check_results
(
{
context
:
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
makeExpectedResult
(
{
temperatureUnit
:
osUnit
}
)
]
}
)
;
Services
.
prefs
.
clearUserPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
)
;
}
)
;
}
}
add_task
(
async
function
noKeywordVariables
(
)
{
await
doKeywordsTest
(
{
nimbusValues
:
{
}
tests
:
{
"
"
:
true
w
:
false
we
:
false
wea
:
false
weat
:
false
weath
:
false
weathe
:
false
weather
:
false
f
:
false
fo
:
false
for
:
false
fore
:
false
forec
:
false
foreca
:
false
forecas
:
false
forecast
:
false
}
}
)
;
}
)
;
add_task
(
async
function
minLength_absent
(
)
{
await
doKeywordsTest
(
{
nimbusValues
:
{
weatherKeywords
:
[
"
weather
"
]
}
tests
:
{
"
"
:
true
w
:
false
we
:
false
wea
:
false
weat
:
false
weath
:
false
weathe
:
false
weather
:
false
"
weather
"
:
false
"
weather
"
:
false
"
weather
"
:
false
}
}
)
;
}
)
;
add_task
(
async
function
minLength_zero
(
)
{
await
doKeywordsTest
(
{
nimbusValues
:
{
weatherKeywords
:
[
"
weather
"
]
weatherKeywordsMinimumLength
:
0
}
tests
:
{
"
"
:
true
w
:
false
we
:
false
wea
:
false
weat
:
false
weath
:
false
weathe
:
false
weather
:
false
"
weather
"
:
false
"
weather
"
:
false
"
weather
"
:
false
}
}
)
;
}
)
;
add_task
(
async
function
minLength_large
(
)
{
await
doKeywordsTest
(
{
nimbusValues
:
{
weatherKeywords
:
[
"
weather
"
"
forecast
"
]
weatherKeywordsMinimumLength
:
999
}
tests
:
{
"
"
:
false
w
:
false
we
:
false
wea
:
false
weat
:
false
weath
:
false
weathe
:
false
weather
:
true
f
:
false
fo
:
false
for
:
false
fore
:
false
forec
:
false
foreca
:
false
forecas
:
false
forecast
:
true
}
}
)
;
}
)
;
add_task
(
async
function
minLength_typical
(
)
{
await
doKeywordsTest
(
{
nimbusValues
:
{
weatherKeywords
:
[
"
weather
"
"
forecast
"
]
weatherKeywordsMinimumLength
:
4
}
tests
:
{
"
"
:
false
w
:
false
we
:
false
wea
:
false
weat
:
true
weath
:
true
weathe
:
true
weather
:
true
f
:
false
fo
:
false
for
:
false
fore
:
true
forec
:
true
foreca
:
true
forecas
:
true
forecast
:
true
"
wea
"
:
false
"
wea
"
:
false
"
wea
"
:
false
"
wea
"
:
false
"
weat
"
:
true
"
weat
"
:
true
"
weat
"
:
true
"
weat
"
:
true
}
}
)
;
}
)
;
async
function
doKeywordsTest
(
{
nimbusValues
tests
}
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
cleanup
=
await
UrlbarTestUtils
.
initNimbusFeature
(
nimbusValues
)
;
for
(
let
[
searchString
expected
]
of
Object
.
entries
(
tests
)
)
{
info
(
"
Doing
search
:
"
+
JSON
.
stringify
(
{
nimbusValues
searchString
}
)
)
;
let
suggestedIndex
=
searchString
?
1
:
0
;
await
check_results
(
{
context
:
createContext
(
searchString
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
expected
?
[
makeExpectedResult
(
{
suggestedIndex
}
)
]
:
[
]
}
)
;
}
await
cleanup
(
)
;
}
add_task
(
async
function
zeroPrefix_withoutNimbus
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
info
(
"
1
.
Doing
searches
before
installing
experiment
and
setting
keyword
"
)
;
await
check_results
(
{
context
:
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
makeExpectedResult
(
)
]
}
)
;
await
check_results
(
{
context
:
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
let
cleanup
=
await
UrlbarTestUtils
.
initNimbusFeature
(
{
weatherKeywords
:
[
"
weather
"
]
weatherKeywordsMinimumLength
:
1
}
)
;
info
(
"
2
.
Doing
searches
after
installing
experiment
and
setting
keyword
"
)
;
await
check_results
(
{
context
:
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
await
check_results
(
{
context
:
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
makeExpectedResult
(
{
suggestedIndex
:
1
}
)
]
}
)
;
await
cleanup
(
)
;
info
(
"
3
.
Doing
searches
after
uninstalling
experiment
"
)
;
await
check_results
(
{
context
:
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
makeExpectedResult
(
)
]
}
)
;
await
check_results
(
{
context
:
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
}
)
;
add_task
(
async
function
zeroPrefix_spacesInSearchString
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
for
(
let
searchString
of
[
"
"
"
"
"
"
"
doesn
'
t
match
anything
"
]
)
{
await
check_results
(
{
context
:
createContext
(
searchString
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
}
}
)
;
add_task
(
async
function
zeroPrefix_nonEmptySearchString
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
context
=
createContext
(
"
this
shouldn
'
t
match
anything
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_task
(
async
function
block
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
Assert
.
ok
(
UrlbarPrefs
.
get
(
"
suggest
.
weather
"
)
"
Sanity
check
:
suggest
.
weather
is
true
initially
"
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeExpectedResult
(
)
]
}
)
;
UrlbarProviderWeather
.
blockResult
(
context
context
.
results
[
0
]
)
;
Assert
.
ok
(
!
UrlbarPrefs
.
get
(
"
suggest
.
weather
"
)
"
suggest
.
weather
is
false
after
blocking
the
result
"
)
;
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
"
suggest
.
weather
"
true
)
;
await
fetchPromise
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
matchingQuickSuggest_sponsored
(
)
{
await
doMatchingQuickSuggestTest
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
}
)
;
add_task
(
async
function
matchingQuickSuggest_nonsponsored
(
)
{
await
doMatchingQuickSuggestTest
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
}
)
;
async
function
doMatchingQuickSuggestTest
(
pref
isSponsored
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
keyword
=
"
test
"
;
let
iab_category
=
isSponsored
?
"
22
-
Shopping
"
:
"
5
-
Education
"
;
UrlbarPrefs
.
set
(
pref
true
)
;
await
QuickSuggestTestUtils
.
setRemoteSettingsResults
(
[
{
id
:
1
url
:
"
http
:
/
/
example
.
com
/
"
title
:
"
Suggestion
"
keywords
:
[
keyword
]
click_url
:
"
http
:
/
/
example
.
com
/
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
impression
"
advertiser
:
"
TestAdvertiser
"
iab_category
}
]
)
;
info
(
"
Doing
first
search
for
quick
suggest
result
"
)
;
await
check_results
(
{
context
:
createContext
(
keyword
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
subtype
:
isSponsored
?
UrlbarProviderQuickSuggest
.
RESULT_SUBTYPE
.
SPONSORED
:
UrlbarProviderQuickSuggest
.
RESULT_SUBTYPE
.
NONSPONSORED
qsSuggestion
:
keyword
title
:
"
Suggestion
"
url
:
"
http
:
/
/
example
.
com
/
"
displayUrl
:
"
http
:
/
/
example
.
com
"
originalUrl
:
"
http
:
/
/
example
.
com
/
"
icon
:
null
sponsoredImpressionUrl
:
"
http
:
/
/
example
.
com
/
impression
"
sponsoredClickUrl
:
"
http
:
/
/
example
.
com
/
click
"
sponsoredBlockId
:
1
sponsoredAdvertiser
:
"
TestAdvertiser
"
sponsoredIabCategory
:
iab_category
isSponsored
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
UrlbarPrefs
.
get
(
"
quickSuggestBlockingEnabled
"
)
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
source
:
"
remote
-
settings
"
}
}
]
}
)
;
info
(
"
Doing
second
search
for
weather
suggestion
"
)
;
let
cleanup
=
await
UrlbarTestUtils
.
initNimbusFeature
(
{
weatherKeywords
:
[
keyword
]
weatherKeywordsMinimumLength
:
1
}
)
;
await
check_results
(
{
context
:
createContext
(
keyword
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
UrlbarProviderWeather
.
name
]
isPrivate
:
false
}
)
matches
:
[
makeExpectedResult
(
{
suggestedIndex
:
1
}
)
]
}
)
;
await
cleanup
(
)
;
UrlbarPrefs
.
clear
(
pref
)
;
}
add_task
(
async
function
wakeBeforeNextFetchPeriod
(
)
{
await
doWakeTest
(
{
sleepIntervalMs
:
QuickSuggest
.
weather
.
_test_fetchIntervalMs
-
100
shouldFetchOnWake
:
false
fetchTimerMsOnWake
:
100
}
)
;
}
)
;
add_task
(
async
function
wakeAfterNextFetchPeriod
(
)
{
await
doWakeTest
(
{
sleepIntervalMs
:
QuickSuggest
.
weather
.
_test_fetchIntervalMs
+
100
shouldFetchOnWake
:
true
}
)
;
}
)
;
add_task
(
async
function
wakeAfterManyFetchPeriods
(
)
{
await
doWakeTest
(
{
sleepIntervalMs
:
100
*
QuickSuggest
.
weather
.
_test_fetchIntervalMs
+
100
shouldFetchOnWake
:
true
}
)
;
}
)
;
async
function
doWakeTest
(
{
sleepIntervalMs
shouldFetchOnWake
fetchTimerMsOnWake
}
)
{
let
nowOnStart
=
100
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
dateNowStub
=
sandbox
.
stub
(
Cu
.
getGlobalForObject
(
QuickSuggest
.
weather
)
.
Date
"
now
"
)
;
dateNowStub
.
returns
(
nowOnStart
)
;
info
(
"
Starting
first
fetch
period
"
)
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_lastFetchTimeMs
nowOnStart
"
Last
fetch
time
should
be
updated
after
fetch
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
QuickSuggest
.
weather
.
_test_fetchIntervalMs
"
Timer
period
should
be
full
fetch
interval
"
)
;
let
timer
=
QuickSuggest
.
weather
.
_test_fetchTimer
;
info
(
"
Sending
wake
notification
"
)
;
let
nowOnWake
=
nowOnStart
+
sleepIntervalMs
;
dateNowStub
.
returns
(
nowOnWake
)
;
QuickSuggest
.
weather
.
observe
(
null
"
wake_notification
"
"
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
0
"
After
wake
next
fetch
should
not
have
immediately
started
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_lastFetchTimeMs
nowOnStart
"
After
wake
last
fetch
time
should
be
unchanged
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
0
"
After
wake
the
timer
should
exist
(
be
non
-
zero
)
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
timer
"
After
wake
a
new
timer
should
have
been
created
"
)
;
if
(
shouldFetchOnWake
)
{
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
QuickSuggest
.
weather
.
_test_fetchDelayAfterComingOnlineMs
"
After
wake
timer
period
should
be
fetchDelayAfterComingOnlineMs
"
)
;
}
else
{
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
fetchTimerMsOnWake
"
After
wake
timer
period
should
be
the
remaining
interval
"
)
;
}
info
(
"
Waiting
for
fetch
after
wake
"
)
;
await
QuickSuggest
.
weather
.
waitForFetches
(
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
QuickSuggest
.
weather
.
_test_fetchIntervalMs
"
After
post
-
wake
fetch
timer
period
should
remain
full
fetch
interval
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
0
"
After
post
-
wake
fetch
no
more
fetches
should
be
pending
"
)
;
dateNowStub
.
restore
(
)
;
}
add_task
(
async
function
networkLinkStatusChanged_nonNull
(
)
{
await
doOnlineTestWithSuggestion
(
{
topic
:
"
network
:
link
-
status
-
changed
"
dataValues
:
[
"
down
"
"
up
"
"
changed
"
"
unknown
"
"
this
is
not
a
valid
data
value
"
]
}
)
;
}
)
;
add_task
(
async
function
networkOfflineStatusChanged_nonNull
(
)
{
await
doOnlineTestWithSuggestion
(
{
topic
:
"
network
:
offline
-
status
-
changed
"
dataValues
:
[
"
offline
"
"
online
"
"
this
is
not
a
valid
data
value
"
]
}
)
;
}
)
;
add_task
(
async
function
captivePortalLoginSuccess_nonNull
(
)
{
await
doOnlineTestWithSuggestion
(
{
topic
:
"
captive
-
portal
-
login
-
success
"
dataValues
:
[
"
"
]
}
)
;
}
)
;
async
function
doOnlineTestWithSuggestion
(
{
topic
dataValues
}
)
{
info
(
"
Starting
fetch
period
"
)
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
Assert
.
ok
(
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
have
been
fetched
"
)
;
let
timer
=
QuickSuggest
.
weather
.
_test_fetchTimer
;
for
(
let
data
of
dataValues
)
{
info
(
"
Sending
notification
:
"
+
JSON
.
stringify
(
{
topic
data
}
)
)
;
QuickSuggest
.
weather
.
observe
(
null
topic
data
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
0
"
Fetch
should
not
have
started
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimer
timer
"
Timer
should
not
have
been
recreated
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
QuickSuggest
.
weather
.
_test_fetchIntervalMs
"
Timer
period
should
be
the
full
fetch
interval
"
)
;
}
}
add_task
(
async
function
networkLinkStatusChanged_null
(
)
{
await
doOnlineTestWithNullSuggestion
(
{
topic
:
"
network
:
link
-
status
-
changed
"
offlineData
:
"
down
"
otherDataValues
:
[
"
up
"
"
changed
"
"
unknown
"
"
this
is
not
a
valid
data
value
"
]
}
)
;
}
)
;
add_task
(
async
function
networkOfflineStatusChanged_null
(
)
{
await
doOnlineTestWithNullSuggestion
(
{
topic
:
"
network
:
offline
-
status
-
changed
"
offlineData
:
"
offline
"
otherDataValues
:
[
"
online
"
"
this
is
not
a
valid
data
value
"
]
}
)
;
}
)
;
add_task
(
async
function
captivePortalLoginSuccess_null
(
)
{
await
doOnlineTestWithNullSuggestion
(
{
topic
:
"
captive
-
portal
-
login
-
success
"
otherDataValues
:
[
"
"
]
}
)
;
}
)
;
async
function
doOnlineTestWithNullSuggestion
(
{
topic
otherDataValues
offlineData
=
"
"
}
)
{
QuickSuggest
.
weather
.
_test_setSuggestionToNull
(
)
;
Assert
.
ok
(
!
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
be
null
"
)
;
let
timer
=
QuickSuggest
.
weather
.
_test_fetchTimer
;
if
(
offlineData
)
{
info
(
"
Sending
notification
:
"
+
JSON
.
stringify
(
{
topic
offlineData
}
)
)
;
QuickSuggest
.
weather
.
observe
(
null
topic
offlineData
)
;
Assert
.
ok
(
!
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
remain
null
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
0
"
Fetch
should
not
have
started
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimer
timer
"
Timer
should
not
have
been
recreated
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
QuickSuggest
.
weather
.
_test_fetchIntervalMs
"
Timer
period
should
be
the
full
fetch
interval
"
)
;
}
for
(
let
data
of
otherDataValues
)
{
QuickSuggest
.
weather
.
_test_setSuggestionToNull
(
)
;
Assert
.
ok
(
!
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
be
null
"
)
;
info
(
"
Sending
notification
:
"
+
JSON
.
stringify
(
{
topic
data
}
)
)
;
QuickSuggest
.
weather
.
observe
(
null
topic
data
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
0
"
Fetch
should
not
have
started
yet
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
0
"
Timer
should
exist
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
timer
"
A
new
timer
should
have
been
created
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
QuickSuggest
.
weather
.
_test_fetchDelayAfterComingOnlineMs
"
Timer
ms
should
be
fetchDelayAfterComingOnlineMs
"
)
;
timer
=
QuickSuggest
.
weather
.
_test_fetchTimer
;
info
(
"
Waiting
for
fetch
after
notification
"
)
;
await
QuickSuggest
.
weather
.
waitForFetches
(
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
0
"
Fetch
should
not
be
pending
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
0
"
Timer
should
exist
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
timer
"
A
new
timer
should
have
been
created
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
QuickSuggest
.
weather
.
_test_fetchIntervalMs
"
Timer
period
should
be
full
fetch
interval
"
)
;
timer
=
QuickSuggest
.
weather
.
_test_fetchTimer
;
}
}
add_task
(
async
function
manyOnlineNotifications
(
)
{
await
doManyNotificationsTest
(
[
[
"
network
:
link
-
status
-
changed
"
"
changed
"
]
[
"
network
:
link
-
status
-
changed
"
"
up
"
]
[
"
network
:
offline
-
status
-
changed
"
"
online
"
]
]
)
;
}
)
;
add_task
(
async
function
wakeAndOnlineNotifications
(
)
{
await
doManyNotificationsTest
(
[
[
"
wake_notification
"
"
"
]
[
"
network
:
link
-
status
-
changed
"
"
changed
"
]
[
"
network
:
link
-
status
-
changed
"
"
up
"
]
[
"
network
:
offline
-
status
-
changed
"
"
online
"
]
]
)
;
}
)
;
async
function
doManyNotificationsTest
(
notifications
)
{
let
nowOnStart
=
100
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
dateNowStub
=
sandbox
.
stub
(
Cu
.
getGlobalForObject
(
QuickSuggest
.
weather
)
.
Date
"
now
"
)
;
dateNowStub
.
returns
(
nowOnStart
)
;
info
(
"
Starting
first
fetch
period
"
)
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_lastFetchTimeMs
nowOnStart
"
Last
fetch
time
should
be
updated
after
fetch
"
)
;
let
nowOnWake
=
nowOnStart
+
100
*
QuickSuggest
.
weather
.
_test_fetchIntervalMs
;
dateNowStub
.
returns
(
nowOnWake
)
;
QuickSuggest
.
weather
.
_test_setSuggestionToNull
(
)
;
Assert
.
ok
(
!
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
be
null
"
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
for
(
let
[
topic
data
]
of
notifications
)
{
info
(
"
Sending
notification
:
"
+
JSON
.
stringify
(
{
topic
data
}
)
)
;
QuickSuggest
.
weather
.
observe
(
null
topic
data
)
;
}
info
(
"
Waiting
for
fetch
after
notifications
"
)
;
await
QuickSuggest
.
weather
.
waitForFetches
(
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
0
"
Fetch
should
not
be
pending
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
0
"
Timer
should
exist
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_fetchTimerMs
QuickSuggest
.
weather
.
_test_fetchIntervalMs
"
Timer
period
should
be
full
fetch
interval
"
)
;
Assert
.
equal
(
MerinoTestUtils
.
server
.
requests
.
length
1
"
Merino
should
have
received
only
one
request
"
)
;
dateNowStub
.
restore
(
)
;
}
add_task
(
async
function
vpn
(
)
{
let
mockLinkService
=
{
isLinkUp
:
true
linkStatusKnown
:
true
linkType
:
Ci
.
nsINetworkLinkService
.
LINK_TYPE_WIFI
networkID
:
"
abcd
"
dnsSuffixList
:
[
]
platformDNSIndications
:
Ci
.
nsINetworkLinkService
.
NONE_DETECTED
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsINetworkLinkService
"
]
)
}
;
let
networkLinkServiceCID
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
network
/
network
-
link
-
service
;
1
"
mockLinkService
)
;
QuickSuggest
.
weather
.
_test_linkService
=
mockLinkService
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
Assert
.
ok
(
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
exist
"
)
;
mockLinkService
.
platformDNSIndications
=
Ci
.
nsINetworkLinkService
.
VPN_DETECTED
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
Assert
.
ok
(
!
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
be
null
"
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
QuickSuggest
.
weather
.
observe
(
null
"
network
:
link
-
status
-
changed
"
"
changed
"
)
;
await
fetchPromise
;
Assert
.
ok
(
!
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
remain
null
"
)
;
mockLinkService
.
platformDNSIndications
=
Ci
.
nsINetworkLinkService
.
NONE_DETECTED
;
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
QuickSuggest
.
weather
.
observe
(
null
"
network
:
link
-
status
-
changed
"
"
changed
"
)
;
await
fetchPromise
;
Assert
.
ok
(
QuickSuggest
.
weather
.
suggestion
"
Suggestion
should
be
fetched
"
)
;
MockRegistrar
.
unregister
(
networkLinkServiceCID
)
;
delete
QuickSuggest
.
weather
.
_test_linkService
;
}
)
;
function
assertEnabled
(
{
message
hasSuggestion
pendingFetchCount
}
)
{
info
(
"
Asserting
feature
is
enabled
"
)
;
if
(
message
)
{
info
(
message
)
;
}
Assert
.
equal
(
!
!
QuickSuggest
.
weather
.
suggestion
hasSuggestion
"
Suggestion
is
null
or
non
-
null
as
expected
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
0
"
Fetch
timer
is
non
-
zero
"
)
;
Assert
.
ok
(
QuickSuggest
.
weather
.
_test_merino
"
Merino
client
is
non
-
null
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
pendingFetchCount
"
Expected
pending
fetch
count
"
)
;
}
function
assertDisabled
(
{
message
pendingFetchCount
}
)
{
info
(
"
Asserting
feature
is
disabled
"
)
;
if
(
message
)
{
info
(
message
)
;
}
Assert
.
strictEqual
(
QuickSuggest
.
weather
.
suggestion
null
"
Suggestion
is
null
"
)
;
Assert
.
strictEqual
(
QuickSuggest
.
weather
.
_test_fetchTimer
0
"
Fetch
timer
is
zero
"
)
;
Assert
.
strictEqual
(
QuickSuggest
.
weather
.
_test_merino
null
"
Merino
client
is
null
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
pendingFetchCount
"
Expected
pending
fetch
count
"
)
;
}
function
makeExpectedResult
(
{
suggestedIndex
=
0
temperatureUnit
=
undefined
}
=
{
}
)
{
if
(
!
temperatureUnit
)
{
temperatureUnit
=
Services
.
locale
.
regionalPrefsLocales
[
0
]
=
=
"
en
-
US
"
?
"
f
"
:
"
c
"
;
}
return
{
suggestedIndex
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
temperatureUnit
url
:
WEATHER_SUGGESTION
.
url
iconId
:
"
6
"
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
true
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
requestId
:
MerinoTestUtils
.
server
.
response
.
body
.
request_id
source
:
"
merino
"
merinoProvider
:
"
accuweather
"
dynamicType
:
"
weather
"
city
:
WEATHER_SUGGESTION
.
city_name
temperature
:
WEATHER_SUGGESTION
.
current_conditions
.
temperature
[
temperatureUnit
]
currentConditions
:
WEATHER_SUGGESTION
.
current_conditions
.
summary
forecast
:
WEATHER_SUGGESTION
.
forecast
.
summary
high
:
WEATHER_SUGGESTION
.
forecast
.
high
[
temperatureUnit
]
low
:
WEATHER_SUGGESTION
.
forecast
.
low
[
temperatureUnit
]
shouldNavigate
:
true
}
}
;
}
