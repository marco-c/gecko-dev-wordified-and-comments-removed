"
use
strict
"
;
const
HISTOGRAM_LATENCY
=
"
FX_URLBAR_MERINO_LATENCY_WEATHER_MS
"
;
const
HISTOGRAM_RESPONSE
=
"
FX_URLBAR_MERINO_RESPONSE_WEATHER
"
;
const
{
WEATHER_SUGGESTION
}
=
MerinoTestUtils
;
const
EXPECTED_RESULT
=
makeExpectedResult
(
"
f
"
)
;
add_task
(
async
function
init
(
)
{
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
await
MerinoTestUtils
.
initWeather
(
)
;
}
)
;
add_task
(
async
function
disableAndEnable_featureGate
(
)
{
await
doBasicDisableAndEnableTest
(
"
weather
.
featureGate
"
)
;
}
)
;
add_task
(
async
function
disableAndEnable_suggestPref
(
)
{
await
doBasicDisableAndEnableTest
(
"
suggest
.
weather
"
)
;
}
)
;
async
function
doBasicDisableAndEnableTest
(
pref
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
UrlbarPrefs
.
set
(
pref
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
"
pendingFetchCount
:
0
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
info
(
"
Re
-
enable
the
feature
"
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
pref
true
)
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
"
hasSuggestion
:
false
pendingFetchCount
:
1
}
)
;
await
fetchPromise
;
assertEnabled
(
{
message
:
"
After
awaiting
fetch
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
success
"
"
The
request
successfully
finished
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
success
"
latencyRecorded
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_RESULT
]
}
)
;
}
add_task
(
async
function
disableAndEnable_immediate1
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
"
pendingFetchCount
:
0
}
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
true
)
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
"
hasSuggestion
:
false
pendingFetchCount
:
1
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
again
"
pendingFetchCount
:
1
}
)
;
await
fetchPromise
;
assertDisabled
(
{
message
:
"
After
awaiting
fetch
"
pendingFetchCount
:
0
}
)
;
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
true
)
;
await
fetchPromise
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
disableAndEnable_immediate2
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
"
pendingFetchCount
:
0
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
true
)
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
"
hasSuggestion
:
false
pendingFetchCount
:
1
}
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
again
"
pendingFetchCount
:
1
}
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
"
weather
.
featureGate
"
true
)
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
again
"
hasSuggestion
:
false
pendingFetchCount
:
2
}
)
;
await
fetchPromise
;
assertEnabled
(
{
message
:
"
Immediately
after
re
-
enabling
again
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
noSuggestion
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
let
{
suggestions
}
=
MerinoTestUtils
.
server
.
response
.
body
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
[
]
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
After
fetch
"
hasSuggestion
:
false
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
no_suggestion
"
"
The
request
successfully
finished
without
suggestions
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
no_suggestion
"
latencyRecorded
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
suggestions
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
networkError
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
QuickSuggest
.
weather
.
_test_setTimeoutMs
(
10000
)
;
await
MerinoTestUtils
.
server
.
withNetworkError
(
async
(
)
=
>
{
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
}
)
;
QuickSuggest
.
weather
.
_test_setTimeoutMs
(
-
1
)
;
assertEnabled
(
{
message
:
"
After
fetch
"
hasSuggestion
:
false
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
network_error
"
"
The
request
failed
with
a
network
error
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
network_error
"
latencyRecorded
:
false
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
httpError
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
MerinoTestUtils
.
server
.
response
=
{
status
:
500
}
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
After
fetch
"
hasSuggestion
:
false
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
http_error
"
"
The
request
failed
with
an
HTTP
error
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
http_error
"
latencyRecorded
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
[
WEATHER_SUGGESTION
]
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
clientTimeout
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
histograms
=
MerinoTestUtils
.
getAndClearHistograms
(
{
extraLatency
:
HISTOGRAM_LATENCY
extraResponse
:
HISTOGRAM_RESPONSE
}
)
;
MerinoTestUtils
.
server
.
response
.
delay
=
400
;
QuickSuggest
.
weather
.
_test_setTimeoutMs
(
1
)
;
let
responsePromise
=
QuickSuggest
.
weather
.
_test_merino
.
waitForNextResponse
(
)
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
After
fetch
"
hasSuggestion
:
false
pendingFetchCount
:
0
}
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_merino
.
lastFetchStatus
"
timeout
"
"
The
request
timed
out
"
)
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
"
timeout
"
latencyRecorded
:
false
latencyStopwatchRunning
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
await
responsePromise
;
MerinoTestUtils
.
checkAndClearHistograms
(
{
histograms
response
:
null
latencyRecorded
:
true
client
:
QuickSuggest
.
weather
.
_test_merino
}
)
;
QuickSuggest
.
weather
.
_test_setTimeoutMs
(
-
1
)
;
delete
MerinoTestUtils
.
server
.
response
.
delay
;
await
QuickSuggest
.
weather
.
_test_fetch
(
)
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
add_task
(
async
function
localeTemperatureUnit
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
unitsByLocale
=
{
"
en
-
US
"
:
"
f
"
"
en
-
CA
"
:
"
c
"
"
en
-
GB
"
:
"
c
"
de
:
"
c
"
}
;
for
(
let
[
locale
expectedUnit
]
of
Object
.
entries
(
unitsByLocale
)
)
{
await
QuickSuggestTestUtils
.
withLocales
(
[
locale
]
async
(
)
=
>
{
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeExpectedResult
(
expectedUnit
)
]
}
)
;
}
)
;
}
}
)
;
add_task
(
async
function
nonEmptySearchString
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
let
context
=
createContext
(
"
this
shouldn
'
t
match
anything
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_task
(
async
function
block
(
)
{
assertEnabled
(
{
message
:
"
Sanity
check
initial
state
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
Assert
.
ok
(
UrlbarPrefs
.
get
(
"
suggest
.
weather
"
)
"
Sanity
check
:
suggest
.
weather
is
true
initially
"
)
;
let
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_RESULT
]
}
)
;
UrlbarProviderQuickSuggest
.
blockResult
(
context
context
.
results
[
0
]
)
;
Assert
.
ok
(
!
UrlbarPrefs
.
get
(
"
suggest
.
weather
"
)
"
suggest
.
weather
is
false
after
blocking
the
result
"
)
;
context
=
createContext
(
"
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
let
fetchPromise
=
QuickSuggest
.
weather
.
waitForFetches
(
)
;
UrlbarPrefs
.
set
(
"
suggest
.
weather
"
true
)
;
await
fetchPromise
;
assertEnabled
(
{
message
:
"
On
cleanup
"
hasSuggestion
:
true
pendingFetchCount
:
0
}
)
;
}
)
;
function
assertEnabled
(
{
message
hasSuggestion
pendingFetchCount
}
)
{
info
(
"
Asserting
feature
is
enabled
"
)
;
if
(
message
)
{
info
(
message
)
;
}
Assert
.
equal
(
!
!
QuickSuggest
.
weather
.
suggestion
hasSuggestion
"
Suggestion
is
null
or
non
-
null
as
expected
"
)
;
Assert
.
notEqual
(
QuickSuggest
.
weather
.
_test_fetchInterval
0
"
Fetch
interval
is
non
-
zero
"
)
;
Assert
.
ok
(
QuickSuggest
.
weather
.
_test_merino
"
Merino
client
is
non
-
null
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
pendingFetchCount
"
Expected
pending
fetch
count
"
)
;
}
function
assertDisabled
(
{
message
pendingFetchCount
}
)
{
info
(
"
Asserting
feature
is
disabled
"
)
;
if
(
message
)
{
info
(
message
)
;
}
Assert
.
strictEqual
(
QuickSuggest
.
weather
.
suggestion
null
"
Suggestion
is
null
"
)
;
Assert
.
strictEqual
(
QuickSuggest
.
weather
.
_test_fetchInterval
0
"
Fetch
interval
is
zero
"
)
;
Assert
.
strictEqual
(
QuickSuggest
.
weather
.
_test_merino
null
"
Merino
client
is
null
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
_test_pendingFetchCount
pendingFetchCount
"
Expected
pending
fetch
count
"
)
;
}
function
makeExpectedResult
(
temperatureUnit
)
{
return
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
url
:
"
http
:
/
/
example
.
com
/
weather
"
icon
:
"
chrome
:
/
/
global
/
skin
/
icons
/
highlights
.
svg
"
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
true
blockL10n
:
{
id
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
requestId
:
"
request_id
"
source
:
"
merino
"
merinoProvider
:
"
accuweather
"
dynamicType
:
"
weather
"
city
:
"
San
Francisco
"
temperature
:
{
c
:
15
.
5
f
:
60
}
currentConditions
:
"
Mostly
cloudy
"
forecast
:
"
Pleasant
Saturday
"
high
:
{
c
:
21
.
1
f
:
70
}
low
:
{
c
:
13
.
9
f
:
57
}
isWeather
:
true
shouldNavigate
:
true
}
}
;
}
