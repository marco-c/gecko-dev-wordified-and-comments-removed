"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
MerinoClient
:
"
resource
:
/
/
/
modules
/
MerinoClient
.
sys
.
mjs
"
UrlbarProviderPlaces
:
"
resource
:
/
/
/
modules
/
UrlbarProviderPlaces
.
sys
.
mjs
"
}
)
;
const
{
WEATHER_SUGGESTION
}
=
MerinoTestUtils
;
let
gWeather
;
add_setup
(
async
(
)
=
>
{
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
prefs
:
[
[
"
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
weather
.
featureGate
"
true
]
]
remoteSettingsRecords
:
[
QuickSuggestTestUtils
.
weatherRecord
(
)
QuickSuggestTestUtils
.
geonamesRecord
(
)
]
}
)
;
await
MerinoTestUtils
.
initWeather
(
)
;
gWeather
=
QuickSuggest
.
getFeature
(
"
WeatherSuggestions
"
)
;
}
)
;
add_task
(
async
function
disableAndEnable_featureGate
(
)
{
await
doBasicDisableAndEnableTest
(
"
weather
.
featureGate
"
)
;
}
)
;
add_task
(
async
function
disableAndEnable_suggestPref
(
)
{
await
doBasicDisableAndEnableTest
(
"
suggest
.
weather
"
)
;
}
)
;
add_task
(
async
function
disableAndEnable_sponsoredPref
(
)
{
await
doBasicDisableAndEnableTest
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
}
)
;
async
function
doBasicDisableAndEnableTest
(
pref
)
{
UrlbarPrefs
.
set
(
pref
false
)
;
assertDisabled
(
{
message
:
"
After
disabling
"
}
)
;
let
context
=
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
info
(
"
Re
-
enable
the
feature
"
)
;
UrlbarPrefs
.
set
(
pref
true
)
;
context
=
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
weatherResult
(
)
]
}
)
;
}
add_task
(
async
function
noSuggestion
(
)
{
let
{
suggestions
}
=
MerinoTestUtils
.
server
.
response
.
body
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
[
]
;
let
context
=
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
MerinoTestUtils
.
server
.
response
.
body
.
suggestions
=
suggestions
;
}
)
;
add_task
(
async
function
urlAlreadyInHistory
(
)
{
let
suggestionVisit
=
{
uri
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
url
title
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
title
}
;
let
otherVisit
=
{
uri
:
"
https
:
/
/
example
.
com
/
some
-
other
-
weather
-
page
"
title
:
"
Some
other
weather
page
"
}
;
await
PlacesTestUtils
.
addVisits
(
[
suggestionVisit
otherVisit
]
)
;
info
(
"
Doing
first
search
"
)
;
let
context
=
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderPlaces
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
otherVisit
)
makeVisitResult
(
context
suggestionVisit
)
]
}
)
;
info
(
"
Doing
second
search
"
)
;
context
=
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
UrlbarProviderPlaces
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeVisitResult
(
context
otherVisit
)
QuickSuggestTestUtils
.
weatherResult
(
)
]
}
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
locale_enUS
(
)
{
await
doLocaleTest
(
{
shouldRunTask
:
osLocale
=
>
osLocale
=
=
"
en
-
US
"
osUnit
:
"
f
"
unitsByLocale
:
{
"
en
-
US
"
:
"
f
"
"
en
-
CA
"
:
"
f
"
"
en
-
GB
"
:
"
f
"
de
:
"
c
"
}
}
)
;
}
)
;
add_task
(
async
function
locale_nonUSEnglish
(
)
{
await
doLocaleTest
(
{
shouldRunTask
:
osLocale
=
>
osLocale
.
startsWith
(
"
en
"
)
&
&
osLocale
!
=
"
en
-
US
"
osUnit
:
"
c
"
unitsByLocale
:
{
"
en
-
US
"
:
"
c
"
"
en
-
CA
"
:
"
c
"
"
en
-
GB
"
:
"
c
"
de
:
"
c
"
}
}
)
;
}
)
;
add_task
(
async
function
locale_nonEnglish
(
)
{
await
doLocaleTest
(
{
shouldRunTask
:
osLocale
=
>
!
osLocale
.
startsWith
(
"
en
"
)
osUnit
:
"
c
"
unitsByLocale
:
{
"
en
-
US
"
:
"
f
"
"
en
-
CA
"
:
"
c
"
"
en
-
GB
"
:
"
c
"
de
:
"
c
"
}
}
)
;
}
)
;
async
function
doLocaleTest
(
{
shouldRunTask
osUnit
unitsByLocale
}
)
{
Services
.
prefs
.
setBoolPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
true
)
;
let
osLocale
=
Services
.
locale
.
regionalPrefsLocales
[
0
]
;
Services
.
prefs
.
clearUserPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
)
;
if
(
!
shouldRunTask
(
osLocale
)
)
{
info
(
"
Skipping
task
should
not
run
for
this
OS
locale
"
)
;
return
;
}
Assert
.
equal
(
Services
.
locale
.
appLocaleAsBCP47
"
en
-
US
"
"
Initial
app
locale
should
be
en
-
US
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
)
"
intl
.
regional_prefs
.
use_os_locales
should
be
false
initially
"
)
;
for
(
let
[
locale
temperatureUnit
]
of
Object
.
entries
(
unitsByLocale
)
)
{
await
QuickSuggestTestUtils
.
withLocales
(
{
locales
:
[
locale
]
callback
:
async
(
)
=
>
{
info
(
"
Checking
locale
:
"
+
locale
)
;
await
check_results
(
{
context
:
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
QuickSuggestTestUtils
.
weatherResult
(
{
temperatureUnit
}
)
]
}
)
;
info
(
"
Checking
locale
with
intl
.
regional_prefs
.
use_os_locales
:
"
+
locale
)
;
Services
.
prefs
.
setBoolPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
true
)
;
await
check_results
(
{
context
:
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
QuickSuggestTestUtils
.
weatherResult
(
{
temperatureUnit
:
osUnit
}
)
]
}
)
;
Services
.
prefs
.
clearUserPref
(
"
intl
.
regional_prefs
.
use_os_locales
"
)
;
}
}
)
;
}
}
add_task
(
async
function
block
(
)
{
Assert
.
ok
(
UrlbarPrefs
.
get
(
"
suggest
.
weather
"
)
"
Sanity
check
:
suggest
.
weather
is
true
initially
"
)
;
let
context
=
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
weatherResult
(
)
]
}
)
;
const
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
controller
.
setView
(
{
get
visibleResults
(
)
{
return
context
.
results
;
}
controller
:
{
removeResult
(
)
{
}
}
}
)
;
let
result
=
context
.
results
[
0
]
;
let
provider
=
UrlbarProvidersManager
.
getProvider
(
result
.
providerName
)
;
Assert
.
ok
(
provider
"
Sanity
check
:
Result
provider
found
"
)
;
provider
.
onEngagement
(
context
controller
{
result
selType
:
"
dismiss
"
selIndex
:
context
.
results
[
0
]
.
rowIndex
}
)
;
Assert
.
ok
(
!
UrlbarPrefs
.
get
(
"
suggest
.
weather
"
)
"
suggest
.
weather
is
false
after
blocking
the
result
"
)
;
context
=
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
UrlbarPrefs
.
set
(
"
suggest
.
weather
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
)
;
add_task
(
async
function
nimbusOverride
(
)
{
let
defaultResult
=
QuickSuggestTestUtils
.
weatherResult
(
)
;
await
check_results
(
{
context
:
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
defaultResult
]
}
)
;
let
nimbusCleanup
=
await
UrlbarTestUtils
.
initNimbusFeature
(
{
weatherKeywordsMinimumLength
:
999
}
)
;
await
check_results
(
{
context
:
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
await
nimbusCleanup
(
)
;
await
check_results
(
{
context
:
createContext
(
"
weather
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
defaultResult
]
}
)
;
}
)
;
add_task
(
async
function
cityQueries_noGeo
(
)
{
await
doCityTest
(
{
desc
:
"
Should
match
most
populous
Waterloo
(
Waterloo
IA
)
"
query
:
"
waterloo
"
geolocation
:
null
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
IA
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
}
)
;
add_task
(
async
function
cityQueries_geoCoords
(
)
{
await
doCityTest
(
{
desc
:
"
Coordinates
closer
to
Waterloo
IA
so
should
match
it
"
query
:
"
waterloo
"
geolocation
:
{
location
:
{
latitude
:
41
.
0
longitude
:
-
93
.
0
}
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
IA
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
Coordinates
closer
to
Waterloo
AL
so
should
match
it
"
query
:
"
waterloo
"
geolocation
:
{
location
:
{
latitude
:
33
.
0
longitude
:
-
87
.
0
}
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
AL
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
When
multiple
cities
are
tied
for
nearest
(
within
the
accuracy
radius
)
the
most
populous
one
should
match
"
query
:
"
weather
twin
city
"
geolocation
:
{
location
:
{
latitude
:
0
.
0
longitude
:
0
.
0
accuracy
:
5
}
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
Twin
City
B
"
region
:
"
GA
"
country
:
"
US
"
}
suggestionCity
:
"
Twin
City
B
"
}
}
)
;
}
)
;
add_task
(
async
function
cityQueries_geoRegion
(
)
{
await
doCityTest
(
{
desc
:
"
Should
match
Waterloo
IA
"
query
:
"
waterloo
"
geolocation
:
{
region_code
:
"
IA
"
country_code
:
"
US
"
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
IA
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
Should
match
Waterloo
AL
"
query
:
"
waterloo
"
geolocation
:
{
region_code
:
"
AL
"
country_code
:
"
US
"
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
AL
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
Rust
did
not
return
Waterloo
NY
so
should
match
most
populous
Waterloo
(
Waterloo
IA
)
"
query
:
"
waterloo
"
geolocation
:
{
region_code
:
"
NY
"
country_code
:
"
US
"
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
IA
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
Rust
did
not
return
Waterloo
ON
CA
so
should
match
most
populous
Waterloo
(
Waterloo
IA
)
"
query
:
"
waterloo
"
geolocation
:
{
region_code
:
"
08
"
country_code
:
"
CA
"
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
IA
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
Query
matches
a
US
and
CA
city
geolocation
is
US
so
should
match
US
city
"
query
:
"
us
ca
city
"
geolocation
:
{
region_code
:
"
HI
"
country_code
:
"
US
"
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
US
CA
City
"
region
:
"
IA
"
country
:
"
US
"
}
suggestionCity
:
"
US
CA
City
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
Query
matches
a
US
and
CA
city
geolocation
is
CA
so
should
match
CA
city
"
query
:
"
us
ca
city
"
geolocation
:
{
region_code
:
"
01
"
country_code
:
"
CA
"
}
expected
:
{
geolocationCalled
:
true
weatherParams
:
{
city
:
"
US
CA
City
"
region
:
"
08
"
country
:
"
CA
"
}
suggestionCity
:
"
US
CA
City
"
}
}
)
;
}
)
;
add_task
(
async
function
cityRegionQueries
(
)
{
await
doCityTest
(
{
desc
:
"
Waterloo
IA
directly
queried
"
query
:
"
waterloo
ia
"
geolocation
:
null
expected
:
{
geolocationCalled
:
false
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
IA
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
Waterloo
AL
directly
queried
"
query
:
"
waterloo
al
"
geolocation
:
null
expected
:
{
geolocationCalled
:
false
weatherParams
:
{
city
:
"
Waterloo
"
region
:
"
AL
"
country
:
"
US
"
}
suggestionCity
:
"
Waterloo
"
}
}
)
;
await
doCityTest
(
{
desc
:
"
Waterloo
NY
directly
queried
but
Rust
didn
'
t
return
Waterloo
NY
so
no
match
"
query
:
"
waterloo
ny
"
geolocation
:
null
expected
:
null
}
)
;
}
)
;
add_task
(
async
function
noCityQuery
(
)
{
await
doCityTest
(
{
desc
:
"
No
city
in
query
so
only
one
call
to
Merino
should
be
made
and
Merino
does
the
geolocation
internally
"
query
:
"
weather
"
geolocation
:
null
expected
:
{
geolocationCalled
:
false
weatherParams
:
{
}
suggestionCity
:
WEATHER_SUGGESTION
.
city_name
}
}
)
;
}
)
;
async
function
doCityTest
(
{
desc
query
geolocation
expected
}
)
{
info
(
"
Doing
city
test
:
"
+
JSON
.
stringify
(
{
desc
query
}
)
)
;
if
(
expected
)
{
expected
.
weatherParams
.
q
?
?
=
"
"
;
}
let
callsByProvider
=
await
doSearch
(
{
query
geolocation
suggestionCity
:
expected
?
.
suggestionCity
}
)
;
Assert
.
equal
(
callsByProvider
.
geolocation
?
.
length
|
|
0
expected
?
.
geolocationCalled
?
1
:
0
"
geolocation
provider
should
have
been
called
the
correct
number
of
times
"
)
;
Assert
.
equal
(
callsByProvider
.
accuweather
?
.
length
|
|
0
expected
?
1
:
0
"
accuweather
provider
should
have
been
called
the
correct
number
of
times
"
)
;
if
(
expected
)
{
for
(
let
[
key
value
]
of
Object
.
entries
(
expected
.
weatherParams
)
)
{
Assert
.
strictEqual
(
callsByProvider
.
accuweather
[
0
]
.
get
(
key
)
value
"
Weather
param
should
be
correct
:
"
+
key
)
;
}
}
}
add_task
(
async
function
merinoCache
(
)
{
let
query
=
"
waterloo
"
;
let
geolocation
=
{
location
:
{
latitude
:
41
.
0
longitude
:
-
93
.
0
}
}
;
MerinoTestUtils
.
enableClientCache
(
true
)
;
let
startDateMs
=
Date
.
now
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
dateNowStub
=
sandbox
.
stub
(
Cu
.
getGlobalForObject
(
MerinoClient
)
.
Date
"
now
"
)
;
dateNowStub
.
returns
(
startDateMs
)
;
info
(
"
Doing
search
1
"
)
;
let
callsByProvider
=
await
doSearch
(
{
query
geolocation
suggestionCity
:
"
Waterloo
"
}
)
;
info
(
"
search
1
callsByProvider
:
"
+
JSON
.
stringify
(
callsByProvider
)
)
;
Assert
.
equal
(
callsByProvider
.
geolocation
.
length
1
"
geolocation
provider
should
have
been
called
on
search
1
"
)
;
Assert
.
equal
(
callsByProvider
.
accuweather
.
length
1
"
accuweather
provider
should
have
been
called
on
search
1
"
)
;
dateNowStub
.
returns
(
startDateMs
+
0
.
5
*
60
*
1000
)
;
info
(
"
Doing
search
2
"
)
;
callsByProvider
=
await
doSearch
(
{
query
suggestionCity
:
"
Waterloo
"
}
)
;
info
(
"
search
2
callsByProvider
:
"
+
JSON
.
stringify
(
callsByProvider
)
)
;
Assert
.
ok
(
!
callsByProvider
.
geolocation
"
geolocation
provider
should
not
have
been
called
on
search
2
"
)
;
Assert
.
ok
(
!
callsByProvider
.
accuweather
"
accuweather
provider
should
not
have
been
called
on
search
2
"
)
;
dateNowStub
.
returns
(
startDateMs
+
1
.
5
*
60
*
1000
)
;
info
(
"
Doing
search
3
"
)
;
callsByProvider
=
await
doSearch
(
{
query
suggestionCity
:
"
Waterloo
"
}
)
;
info
(
"
search
3
callsByProvider
:
"
+
JSON
.
stringify
(
callsByProvider
)
)
;
Assert
.
ok
(
!
callsByProvider
.
geolocation
"
geolocation
provider
should
not
have
been
called
on
search
3
"
)
;
Assert
.
equal
(
callsByProvider
.
accuweather
.
length
1
"
accuweather
provider
should
have
been
called
on
search
3
"
)
;
dateNowStub
.
returns
(
startDateMs
+
3
*
60
*
1000
)
;
info
(
"
Doing
search
4
"
)
;
callsByProvider
=
await
doSearch
(
{
query
suggestionCity
:
"
Waterloo
"
}
)
;
info
(
"
search
4
callsByProvider
:
"
+
JSON
.
stringify
(
callsByProvider
)
)
;
Assert
.
equal
(
callsByProvider
.
geolocation
.
length
1
"
geolocation
provider
should
have
been
called
on
search
4
"
)
;
Assert
.
equal
(
callsByProvider
.
accuweather
.
length
1
"
accuweather
provider
should
have
been
called
on
search
4
"
)
;
sandbox
.
restore
(
)
;
MerinoTestUtils
.
enableClientCache
(
false
)
;
}
)
;
async
function
doSearch
(
{
query
geolocation
suggestionCity
}
)
{
let
callsByProvider
=
{
}
;
MerinoTestUtils
.
server
.
requestHandler
=
req
=
>
{
let
params
=
new
URLSearchParams
(
req
.
queryString
)
;
let
provider
=
params
.
get
(
"
providers
"
)
;
callsByProvider
[
provider
]
|
|
=
[
]
;
callsByProvider
[
provider
]
.
push
(
params
)
;
if
(
provider
=
=
"
geolocation
"
)
{
return
{
body
:
{
request_id
:
"
request_id
"
suggestions
:
!
geolocation
?
[
]
:
[
{
custom_details
:
{
geolocation
}
}
]
}
}
;
}
Assert
.
equal
(
provider
"
accuweather
"
"
Sanity
check
:
If
the
request
isn
'
t
geolocation
it
should
be
accuweather
"
)
;
let
suggestion
=
{
.
.
.
WEATHER_SUGGESTION
}
;
if
(
suggestionCity
)
{
suggestion
=
{
.
.
.
suggestion
title
:
"
Weather
for
"
+
suggestionCity
city_name
:
suggestionCity
}
;
}
return
{
body
:
{
request_id
:
"
request_id
"
suggestions
:
[
suggestion
]
}
}
;
}
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
!
suggestionCity
?
[
]
:
[
QuickSuggestTestUtils
.
weatherResult
(
{
city
:
suggestionCity
}
)
]
}
)
;
MerinoTestUtils
.
server
.
requestHandler
=
null
;
return
callsByProvider
;
}
function
assertDisabled
(
{
message
}
)
{
info
(
"
Asserting
feature
is
disabled
"
)
;
if
(
message
)
{
info
(
message
)
;
}
Assert
.
strictEqual
(
gWeather
.
_test_merino
null
"
Merino
client
is
null
"
)
;
}
