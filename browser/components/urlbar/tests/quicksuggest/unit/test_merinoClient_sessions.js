"
use
strict
"
;
const
{
MerinoClient
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
MerinoClient
.
sys
.
mjs
"
)
;
const
{
SEARCH_PARAMS
}
=
MerinoClient
;
let
gClient
;
add_task
(
async
function
init
(
)
{
gClient
=
new
MerinoClient
(
)
;
await
MerinoTestUtils
.
server
.
start
(
)
;
}
)
;
add_task
(
async
function
singleSession
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
let
query
=
"
search
"
+
i
;
await
gClient
.
fetch
(
{
query
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
i
}
}
]
)
;
}
gClient
.
resetSession
(
)
;
}
)
;
add_task
(
async
function
manySessions
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
let
query
=
"
search
"
+
i
;
await
gClient
.
fetch
(
{
query
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
}
}
]
)
;
gClient
.
resetSession
(
)
;
}
}
)
;
add_task
(
async
function
twoFetches_wait
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
MerinoTestUtils
.
server
.
response
.
delay
=
UrlbarPrefs
.
get
(
"
merino
.
timeoutMs
"
)
;
let
requestPromise
=
MerinoTestUtils
.
server
.
waitForNextRequest
(
)
;
let
query1
=
"
search
"
+
i
;
gClient
.
fetch
(
{
query
:
query1
}
)
;
await
requestPromise
;
delete
MerinoTestUtils
.
server
.
response
.
delay
;
let
query2
=
query1
+
"
again
"
;
await
gClient
.
fetch
(
{
query
:
query2
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query1
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
}
}
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query2
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
+
1
}
}
]
)
;
}
gClient
.
resetSession
(
)
;
}
)
;
add_task
(
async
function
twoFetches_immediate
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
MerinoTestUtils
.
server
.
response
.
delay
=
100
*
UrlbarPrefs
.
get
(
"
merino
.
timeoutMs
"
)
;
let
query1
=
"
search
"
+
i
;
gClient
.
fetch
(
{
query
:
query1
}
)
;
delete
MerinoTestUtils
.
server
.
response
.
delay
;
let
query2
=
query1
+
"
again
"
;
await
gClient
.
fetch
(
{
query
:
query2
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query2
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
+
1
}
}
]
)
;
}
gClient
.
resetSession
(
)
;
}
)
;
add_task
(
async
function
networkError
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
let
query1
=
"
search
"
+
i
;
await
MerinoTestUtils
.
server
.
withNetworkError
(
async
(
)
=
>
{
await
gClient
.
fetch
(
{
query
:
query1
}
)
;
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
network_error
"
"
The
request
failed
with
a
network
error
"
)
;
let
query2
=
query1
+
"
again
"
;
await
gClient
.
fetch
(
{
query
:
query2
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
request
completed
successfully
"
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query2
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
+
1
}
}
]
)
;
}
gClient
.
resetSession
(
)
;
}
)
;
add_task
(
async
function
httpError
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
MerinoTestUtils
.
server
.
response
.
status
=
500
;
let
query1
=
"
search
"
+
i
;
await
gClient
.
fetch
(
{
query
:
query1
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
http_error
"
"
The
last
request
failed
with
a
network
error
"
)
;
MerinoTestUtils
.
server
.
response
.
status
=
200
;
let
query2
=
query1
+
"
again
"
;
await
gClient
.
fetch
(
{
query
:
query2
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
last
request
completed
successfully
"
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query1
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
}
}
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query2
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
+
1
}
}
]
)
;
MerinoTestUtils
.
server
.
reset
(
)
;
}
gClient
.
resetSession
(
)
;
}
)
;
add_task
(
async
function
clientTimeout_wait
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
MerinoTestUtils
.
server
.
response
.
delay
=
2
*
UrlbarPrefs
.
get
(
"
merino
.
timeoutMs
"
)
;
let
responsePromise
=
gClient
.
waitForNextResponse
(
)
;
let
query1
=
"
search
"
+
i
;
await
gClient
.
fetch
(
{
query
:
query1
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
timeout
"
"
The
last
request
failed
with
a
client
timeout
"
)
;
await
responsePromise
;
delete
MerinoTestUtils
.
server
.
response
.
delay
;
let
query2
=
query1
+
"
again
"
;
await
gClient
.
fetch
(
{
query
:
query2
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
last
request
completed
successfully
"
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query1
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
}
}
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query2
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
+
1
}
}
]
)
;
}
gClient
.
resetSession
(
)
;
}
)
;
add_task
(
async
function
clientTimeout_canceled
(
)
{
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
MerinoTestUtils
.
server
.
response
.
delay
=
2
*
UrlbarPrefs
.
get
(
"
merino
.
timeoutMs
"
)
;
let
query1
=
"
search
"
+
i
;
await
gClient
.
fetch
(
{
query
:
query1
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
timeout
"
"
The
last
request
failed
with
a
client
timeout
"
)
;
delete
MerinoTestUtils
.
server
.
response
.
delay
;
let
query2
=
query1
+
"
again
"
;
await
gClient
.
fetch
(
{
query
:
query2
}
)
;
Assert
.
equal
(
gClient
.
lastFetchStatus
"
success
"
"
The
last
request
completed
successfully
"
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query1
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
}
}
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query2
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
2
*
i
+
1
}
}
]
)
;
}
gClient
.
resetSession
(
)
;
}
)
;
add_task
(
async
function
sessionTimeout
(
)
{
let
originalTimeoutMs
=
gClient
.
sessionTimeoutMs
;
gClient
.
sessionTimeoutMs
=
500
;
let
query1
=
"
search
"
;
await
gClient
.
fetch
(
{
query
:
query1
}
)
;
await
gClient
.
waitForNextSessionReset
(
)
;
Assert
.
strictEqual
(
gClient
.
sessionID
null
"
sessionID
is
null
after
session
timeout
"
)
;
Assert
.
strictEqual
(
gClient
.
sequenceNumber
0
"
sequenceNumber
is
zero
after
session
timeout
"
)
;
Assert
.
strictEqual
(
gClient
.
_test_sessionTimer
null
"
sessionTimer
is
null
after
session
timeout
"
)
;
let
query2
=
query1
+
"
again
"
;
await
gClient
.
fetch
(
{
query
:
query2
}
)
;
MerinoTestUtils
.
server
.
checkAndClearRequests
(
[
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query1
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
}
}
{
params
:
{
[
SEARCH_PARAMS
.
QUERY
]
:
query2
[
SEARCH_PARAMS
.
SEQUENCE_NUMBER
]
:
0
}
}
]
)
;
Assert
.
ok
(
gClient
.
sessionID
"
sessionID
is
non
-
null
after
first
request
in
a
new
session
"
)
;
Assert
.
equal
(
gClient
.
sequenceNumber
1
"
sequenceNumber
is
one
after
first
request
in
a
new
session
"
)
;
Assert
.
ok
(
gClient
.
_test_sessionTimer
"
sessionTimer
is
non
-
null
after
first
request
in
a
new
session
"
)
;
gClient
.
sessionTimeoutMs
=
originalTimeoutMs
;
gClient
.
resetSession
(
)
;
}
)
;
