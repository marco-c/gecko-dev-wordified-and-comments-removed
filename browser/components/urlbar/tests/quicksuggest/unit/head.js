ChromeUtils
.
defineESModuleGetters
(
this
{
QuickSuggest
:
"
resource
:
/
/
/
modules
/
QuickSuggest
.
sys
.
mjs
"
SearchUtils
:
"
resource
:
/
/
gre
/
modules
/
SearchUtils
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarProviderAutofill
:
"
resource
:
/
/
/
modules
/
UrlbarProviderAutofill
.
sys
.
mjs
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
sys
.
mjs
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
sys
.
mjs
"
}
)
;
add_setup
(
async
function
setUpQuickSuggestXpcshellTest
(
)
{
UrlbarPrefs
.
_testSkipTelemetryEnvironmentInit
=
true
;
}
)
;
let
gAddTasksWithRustSetup
;
function
add_tasks_with_rust
(
.
.
.
args
)
{
let
skipIfRustEnabled
=
false
;
let
i
=
args
.
findIndex
(
a
=
>
a
.
skip_if_rust_enabled
)
;
if
(
i
>
=
0
)
{
skipIfRustEnabled
=
true
;
args
.
splice
(
i
1
)
;
}
let
taskFnIndex
=
args
.
findIndex
(
a
=
>
typeof
a
=
=
"
function
"
)
;
let
taskFn
=
args
[
taskFnIndex
]
;
for
(
let
rustEnabled
of
[
false
true
]
)
{
let
newTaskName
=
(
taskFn
.
name
|
|
"
anonymousTask
"
)
+
(
rustEnabled
?
"
_rustEnabled
"
:
"
_rustDisabled
"
)
;
if
(
rustEnabled
&
&
skipIfRustEnabled
)
{
info
(
"
add_tasks_with_rust
:
Skipping
due
to
skip_if_rust_enabled
:
"
+
newTaskName
)
;
continue
;
}
let
newTaskFn
=
async
(
.
.
.
taskFnArgs
)
=
>
{
info
(
"
add_tasks_with_rust
:
Setting
rustEnabled
:
"
+
rustEnabled
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
rustEnabled
)
;
info
(
"
add_tasks_with_rust
:
Done
setting
rustEnabled
:
"
+
rustEnabled
)
;
info
(
"
add_tasks_with_rust
:
Forcing
sync
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
add_tasks_with_rust
:
Done
forcing
sync
"
)
;
if
(
gAddTasksWithRustSetup
)
{
info
(
"
add_tasks_with_rust
:
Calling
setup
function
"
)
;
await
gAddTasksWithRustSetup
(
)
;
info
(
"
add_tasks_with_rust
:
Done
calling
setup
function
"
)
;
}
let
rv
;
try
{
info
(
"
add_tasks_with_rust
:
Calling
original
task
function
:
"
+
taskFn
.
name
)
;
rv
=
await
taskFn
(
.
.
.
taskFnArgs
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_ABORT
)
{
Assert
.
ok
(
false
"
add_tasks_with_rust
:
The
original
task
function
threw
an
error
:
"
+
e
)
;
}
throw
e
;
}
finally
{
info
(
"
add_tasks_with_rust
:
Done
calling
original
task
function
:
"
+
taskFn
.
name
)
;
info
(
"
add_tasks_with_rust
:
Clearing
rustEnabled
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
info
(
"
add_tasks_with_rust
:
Done
clearing
rustEnabled
"
)
;
info
(
"
add_tasks_with_rust
:
Forcing
sync
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
add_tasks_with_rust
:
Done
forcing
sync
"
)
;
}
return
rv
;
}
;
Object
.
defineProperty
(
newTaskFn
"
name
"
{
value
:
newTaskName
}
)
;
let
addTaskArgs
=
[
]
;
for
(
let
j
=
0
;
j
<
args
.
length
;
j
+
+
)
{
addTaskArgs
[
j
]
=
j
=
=
taskFnIndex
?
newTaskFn
:
Cu
.
cloneInto
(
args
[
j
]
this
{
cloneFunctions
:
true
}
)
;
}
add_task
(
.
.
.
addTaskArgs
)
;
}
}
function
registerAddTasksWithRustSetup
(
setupFn
)
{
gAddTasksWithRustSetup
=
setupFn
;
}
async
function
doMigrateTest
(
{
testOverrides
scenario
expectedPrefs
initialUserBranch
=
{
}
}
)
{
info
(
"
Testing
migration
:
"
+
JSON
.
stringify
(
{
testOverrides
initialUserBranch
scenario
expectedPrefs
}
)
)
;
function
setPref
(
branch
name
value
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
branch
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
branch
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
branch
.
setCharPref
(
name
value
)
;
break
;
default
:
Assert
.
ok
(
false
Pref
type
not
handled
for
setPref
:
{
name
}
=
{
value
}
)
;
break
;
}
}
function
getPref
(
branch
name
)
{
let
type
=
typeof
UrlbarPrefs
.
get
(
name
)
;
switch
(
type
)
{
case
"
boolean
"
:
return
branch
.
getBoolPref
(
name
)
;
case
"
number
"
:
return
branch
.
getIntPref
(
name
)
;
case
"
string
"
:
return
branch
.
getCharPref
(
name
)
;
default
:
Assert
.
ok
(
false
Pref
type
not
handled
for
getPref
:
{
name
}
{
type
}
)
;
break
;
}
return
null
;
}
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
browser
.
urlbar
.
"
)
;
let
userBranch
=
Services
.
prefs
.
getBranch
(
"
browser
.
urlbar
.
"
)
;
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
true
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
migrationVersion
"
)
;
let
initialDefaultBranch
=
{
"
suggest
.
quicksuggest
.
nonsponsored
"
:
false
"
suggest
.
quicksuggest
.
sponsored
"
:
false
"
quicksuggest
.
dataCollection
.
enabled
"
:
false
}
;
for
(
let
name
of
Object
.
keys
(
initialDefaultBranch
)
)
{
userBranch
.
clearUserPref
(
name
)
;
}
for
(
let
[
branch
prefs
]
of
[
[
defaultBranch
initialDefaultBranch
]
[
userBranch
initialUserBranch
]
]
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
if
(
value
!
=
=
undefined
)
{
setPref
(
branch
name
value
)
;
}
}
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
false
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
info
(
Calling
updateFirefoxSuggestScenario
i
=
{
i
}
)
;
await
UrlbarPrefs
.
updateFirefoxSuggestScenario
(
{
.
.
.
testOverrides
scenario
isStartup
:
true
}
)
;
let
expectedEffectivePrefs
=
{
}
;
let
{
defaultBranch
:
expectedDefaultBranch
userBranch
:
expectedUserBranch
}
=
expectedPrefs
;
expectedDefaultBranch
=
expectedDefaultBranch
|
|
{
}
;
expectedUserBranch
=
expectedUserBranch
|
|
{
}
;
for
(
let
[
branch
prefs
branchType
]
of
[
[
defaultBranch
expectedDefaultBranch
"
default
"
]
[
userBranch
expectedUserBranch
"
user
"
]
]
)
{
let
entries
=
Object
.
entries
(
prefs
)
;
if
(
!
entries
.
length
)
{
continue
;
}
info
(
Checking
expected
prefs
on
{
branchType
}
branch
after
updating
scenario
)
;
for
(
let
[
name
value
]
of
entries
)
{
expectedEffectivePrefs
[
name
]
=
value
;
if
(
branch
=
=
userBranch
)
{
Assert
.
ok
(
userBranch
.
prefHasUserValue
(
name
)
Pref
{
name
}
is
on
user
branch
)
;
}
Assert
.
equal
(
getPref
(
branch
name
)
value
Pref
{
name
}
value
on
{
branchType
}
branch
)
;
}
}
info
(
Making
sure
prefs
on
the
default
branch
without
expected
user
-
branch
values
are
not
on
the
user
branch
)
;
for
(
let
name
of
Object
.
keys
(
initialDefaultBranch
)
)
{
if
(
!
expectedUserBranch
.
hasOwnProperty
(
name
)
)
{
Assert
.
ok
(
!
userBranch
.
prefHasUserValue
(
name
)
Pref
{
name
}
is
not
on
user
branch
)
;
}
}
info
(
Checking
expected
effective
prefs
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
expectedEffectivePrefs
)
)
{
Assert
.
equal
(
UrlbarPrefs
.
get
(
name
)
value
Pref
{
name
}
effective
value
)
;
}
let
currentVersion
=
testOverrides
?
.
migrationVersion
=
=
=
undefined
?
UrlbarPrefs
.
FIREFOX_SUGGEST_MIGRATION_VERSION
:
testOverrides
.
migrationVersion
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
migrationVersion
"
)
currentVersion
"
quicksuggest
.
migrationVersion
is
correct
after
migration
"
)
;
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
true
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
migrationVersion
"
)
;
let
userBranchNames
=
[
.
.
.
Object
.
keys
(
initialUserBranch
)
.
.
.
Object
.
keys
(
expectedPrefs
.
userBranch
|
|
{
}
)
]
;
for
(
let
name
of
userBranchNames
)
{
userBranch
.
clearUserPref
(
name
)
;
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
false
;
}
async
function
doShowLessFrequentlyTests
(
{
feature
expectedResult
showLessFrequentlyCountPref
nimbusCapVariable
keyword
keywordBaseIndex
=
keyword
.
indexOf
(
"
"
)
}
)
{
if
(
keywordBaseIndex
<
=
0
)
{
throw
new
Error
(
"
keywordBaseIndex
must
be
>
0
but
it
'
s
"
+
keywordBaseIndex
)
;
}
if
(
keyword
.
length
<
keywordBaseIndex
+
3
)
{
throw
new
Error
(
"
keyword
must
have
at
least
two
chars
after
keywordBaseIndex
"
)
;
}
let
tests
=
[
{
showLessFrequentlyCount
:
0
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
-
1
)
]
:
false
[
keyword
.
substring
(
0
keywordBaseIndex
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
1
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
2
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
3
)
]
:
true
}
}
{
showLessFrequentlyCount
:
1
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
)
]
:
false
}
}
{
showLessFrequentlyCount
:
2
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
+
1
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
+
2
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
}
}
]
;
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
3
}
}
)
;
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
Nimbus
and
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
10
}
nimbus
:
{
[
nimbusCapVariable
]
:
3
}
}
)
;
}
async
function
doOneShowLessFrequentlyTest
(
{
feature
expectedResult
showLessFrequentlyCountPref
tests
rs
=
{
}
nimbus
=
{
}
}
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
false
)
;
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
nimbus
)
;
await
QuickSuggestTestUtils
.
withConfig
(
{
config
:
rs
callback
:
async
(
)
=
>
{
let
cumulativeSearches
=
{
}
;
for
(
let
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
of
tests
)
{
info
(
"
Starting
subtest
:
"
+
JSON
.
stringify
(
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
)
)
;
Assert
.
equal
(
feature
.
showLessFrequentlyCount
showLessFrequentlyCount
"
showLessFrequentlyCount
should
be
correct
initially
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
showLessFrequentlyCountPref
)
showLessFrequentlyCount
"
Pref
should
be
correct
initially
"
)
;
Assert
.
equal
(
feature
.
canShowLessFrequently
canShowLessFrequently
"
canShowLessFrequently
should
be
correct
initially
"
)
;
cumulativeSearches
=
{
.
.
.
cumulativeSearches
.
.
.
newSearches
}
;
for
(
let
[
searchString
isExpected
]
of
Object
.
entries
(
cumulativeSearches
)
)
{
info
(
"
Doing
search
:
"
+
JSON
.
stringify
(
{
searchString
isExpected
}
)
)
;
let
results
=
[
]
;
if
(
isExpected
)
{
results
.
push
(
typeof
expectedResult
=
=
"
function
"
?
expectedResult
(
searchString
)
:
expectedResult
)
;
}
await
check_results
(
{
context
:
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
results
}
)
;
}
feature
.
incrementShowLessFrequentlyCount
(
)
;
}
}
}
)
;
await
cleanUpNimbus
(
)
;
UrlbarPrefs
.
clear
(
showLessFrequentlyCountPref
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
true
)
;
}
async
function
doRustProvidersTests
(
{
searchString
tests
}
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
for
(
let
{
prefs
expectedUrls
}
of
tests
)
{
info
(
"
Starting
Rust
providers
test
:
"
+
JSON
.
stringify
(
{
prefs
expectedUrls
}
)
)
;
info
(
"
Setting
prefs
and
forcing
sync
"
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
UrlbarPrefs
.
set
(
name
value
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
Querying
with
search
string
:
"
+
JSON
.
stringify
(
searchString
)
)
;
let
suggestions
=
await
QuickSuggest
.
rustBackend
.
query
(
searchString
)
;
info
(
"
Got
suggestions
:
"
+
JSON
.
stringify
(
suggestions
)
)
;
Assert
.
deepEqual
(
suggestions
.
map
(
s
=
>
s
.
url
)
.
sort
(
)
expectedUrls
.
sort
(
)
"
query
(
)
should
return
the
expected
suggestions
(
by
URL
)
"
)
;
info
(
"
Clearing
prefs
and
forcing
sync
"
)
;
for
(
let
name
of
Object
.
keys
(
prefs
)
)
{
UrlbarPrefs
.
clear
(
name
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
info
(
"
Clearing
rustEnabled
pref
and
forcing
sync
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
async
function
waitForNewWeatherFetch
(
)
{
let
{
fetchPromise
:
oldFetchPromise
}
=
QuickSuggest
.
weather
;
let
newFetchPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
{
fetchPromise
}
=
QuickSuggest
.
weather
;
if
(
(
oldFetchPromise
&
&
fetchPromise
!
=
oldFetchPromise
)
|
|
(
!
oldFetchPromise
&
&
fetchPromise
)
)
{
newFetchPromise
=
fetchPromise
;
return
true
;
}
return
false
;
}
"
Waiting
for
a
new
weather
fetch
to
start
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
fetchPromise
newFetchPromise
"
Sanity
check
:
fetchPromise
hasn
'
t
changed
since
waitForCondition
returned
"
)
;
await
newFetchPromise
;
}
