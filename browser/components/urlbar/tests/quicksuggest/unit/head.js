ChromeUtils
.
defineESModuleGetters
(
this
{
QuickSuggest
:
"
resource
:
/
/
/
modules
/
QuickSuggest
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarProviderAutofill
:
"
resource
:
/
/
/
modules
/
UrlbarProviderAutofill
.
sys
.
mjs
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
sys
.
mjs
"
}
)
;
add_setup
(
async
function
setUpQuickSuggestXpcshellTest
(
)
{
UrlbarPrefs
.
_testSkipTelemetryEnvironmentInit
=
true
;
}
)
;
function
add_tasks_with_rust
(
.
.
.
args
)
{
let
taskFnIndex
=
args
.
findIndex
(
a
=
>
typeof
a
=
=
"
function
"
)
;
let
taskFn
=
args
[
taskFnIndex
]
;
for
(
let
rustEnabled
of
[
false
true
]
)
{
let
newTaskFn
=
async
(
.
.
.
taskFnArgs
)
=
>
{
info
(
"
add_tasks_with_rust
:
Setting
rustEnabled
:
"
+
rustEnabled
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
rustEnabled
)
;
info
(
"
add_tasks_with_rust
:
Done
setting
rustEnabled
:
"
+
rustEnabled
)
;
info
(
"
add_tasks_with_rust
:
Forcing
sync
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
add_tasks_with_rust
:
Done
forcing
sync
"
)
;
let
rv
;
try
{
info
(
"
add_tasks_with_rust
:
Calling
original
task
function
:
"
+
taskFn
.
name
)
;
rv
=
await
taskFn
(
.
.
.
taskFnArgs
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_ABORT
)
{
Assert
.
ok
(
false
"
add_tasks_with_rust
:
The
original
task
function
threw
an
error
:
"
+
e
)
;
}
throw
e
;
}
finally
{
info
(
"
add_tasks_with_rust
:
Done
calling
original
task
function
:
"
+
taskFn
.
name
)
;
info
(
"
add_tasks_with_rust
:
Clearing
rustEnabled
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
info
(
"
add_tasks_with_rust
:
Done
clearing
rustEnabled
"
)
;
info
(
"
add_tasks_with_rust
:
Forcing
sync
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
add_tasks_with_rust
:
Done
forcing
sync
"
)
;
}
return
rv
;
}
;
Object
.
defineProperty
(
newTaskFn
"
name
"
{
value
:
taskFn
.
name
+
(
rustEnabled
?
"
_rustEnabled
"
:
"
_rustDisabled
"
)
}
)
;
let
addTaskArgs
=
[
.
.
.
args
]
;
addTaskArgs
[
taskFnIndex
]
=
newTaskFn
;
add_task
(
.
.
.
addTaskArgs
)
;
}
}
function
makeWikipediaResult
(
{
source
provider
keyword
=
"
wikipedia
"
title
=
"
Wikipedia
Suggestion
"
url
=
"
http
:
/
/
example
.
com
/
wikipedia
"
originalUrl
=
"
http
:
/
/
example
.
com
/
wikipedia
"
icon
=
null
iconBlob
=
new
Blob
(
[
new
Uint8Array
(
[
]
)
]
)
impressionUrl
=
"
http
:
/
/
example
.
com
/
wikipedia
-
impression
"
clickUrl
=
"
http
:
/
/
example
.
com
/
wikipedia
-
click
"
blockId
=
1
advertiser
=
"
Wikipedia
"
iabCategory
=
"
5
-
Education
"
suggestedIndex
=
-
1
isSuggestedIndexRelativeToGroup
=
true
}
)
{
let
result
=
{
suggestedIndex
isSuggestedIndexRelativeToGroup
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
title
url
originalUrl
displayUrl
:
url
.
replace
(
/
^
https
:
\
/
\
/
/
"
"
)
isSponsored
:
false
qsSuggestion
:
keyword
sponsoredAdvertiser
:
"
Wikipedia
"
sponsoredIabCategory
:
"
5
-
Education
"
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
}
isBlockable
:
true
blockL10n
:
{
id
:
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
}
telemetryType
:
"
adm_nonsponsored
"
}
}
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRustEnabled
"
)
)
{
result
.
payload
.
source
=
source
|
|
"
rust
"
;
result
.
payload
.
provider
=
provider
|
|
"
Wikipedia
"
;
result
.
payload
.
iconBlob
=
iconBlob
;
}
else
{
result
.
payload
.
source
=
source
|
|
"
remote
-
settings
"
;
result
.
payload
.
provider
=
provider
|
|
"
AdmWikipedia
"
;
result
.
payload
.
icon
=
icon
;
result
.
payload
.
sponsoredImpressionUrl
=
impressionUrl
;
result
.
payload
.
sponsoredClickUrl
=
clickUrl
;
result
.
payload
.
sponsoredBlockId
=
blockId
;
result
.
payload
.
sponsoredAdvertiser
=
advertiser
;
result
.
payload
.
sponsoredIabCategory
=
iabCategory
;
}
return
result
;
}
function
makeAmpResult
(
{
source
provider
keyword
=
"
amp
"
title
=
"
AMP
Suggestion
"
url
=
"
http
:
/
/
example
.
com
/
amp
"
originalUrl
=
"
http
:
/
/
example
.
com
/
amp
"
icon
=
null
iconBlob
=
new
Blob
(
[
new
Uint8Array
(
[
]
)
]
)
impressionUrl
=
"
http
:
/
/
example
.
com
/
amp
-
impression
"
clickUrl
=
"
http
:
/
/
example
.
com
/
amp
-
click
"
blockId
=
1
advertiser
=
"
Amp
"
iabCategory
=
"
22
-
Shopping
"
suggestedIndex
=
-
1
isSuggestedIndexRelativeToGroup
=
true
}
=
{
}
)
{
let
result
=
{
suggestedIndex
isSuggestedIndexRelativeToGroup
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
title
url
originalUrl
displayUrl
:
url
.
replace
(
/
^
https
:
\
/
\
/
/
"
"
)
isSponsored
:
true
qsSuggestion
:
keyword
sponsoredImpressionUrl
:
impressionUrl
sponsoredClickUrl
:
clickUrl
sponsoredBlockId
:
blockId
sponsoredAdvertiser
:
advertiser
sponsoredIabCategory
:
iabCategory
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
}
isBlockable
:
true
blockL10n
:
{
id
:
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
}
telemetryType
:
"
adm_sponsored
"
descriptionL10n
:
{
id
:
"
urlbar
-
result
-
action
-
sponsored
"
}
}
}
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRustEnabled
"
)
)
{
result
.
payload
.
source
=
source
|
|
"
rust
"
;
result
.
payload
.
provider
=
provider
|
|
"
Amp
"
;
result
.
payload
.
iconBlob
=
iconBlob
;
}
else
{
result
.
payload
.
source
=
source
|
|
"
remote
-
settings
"
;
result
.
payload
.
provider
=
provider
|
|
"
AdmWikipedia
"
;
result
.
payload
.
icon
=
icon
;
}
return
result
;
}
function
makeMdnResult
(
{
url
title
description
}
)
{
let
finalUrl
=
new
URL
(
url
)
;
finalUrl
.
searchParams
.
set
(
"
utm_medium
"
"
firefox
-
desktop
"
)
;
finalUrl
.
searchParams
.
set
(
"
utm_source
"
"
firefox
-
suggest
"
)
;
finalUrl
.
searchParams
.
set
(
"
utm_campaign
"
"
firefox
-
mdn
-
web
-
docs
-
suggestion
-
experiment
"
)
;
finalUrl
.
searchParams
.
set
(
"
utm_content
"
"
treatment
"
)
;
let
result
=
{
isBestMatch
:
true
suggestedIndex
:
1
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
heuristic
:
false
payload
:
{
telemetryType
:
"
mdn
"
title
url
:
finalUrl
.
href
originalUrl
:
url
displayUrl
:
finalUrl
.
href
.
replace
(
/
^
https
:
\
/
\
/
/
"
"
)
description
icon
:
"
chrome
:
/
/
global
/
skin
/
icons
/
mdn
.
svg
"
shouldShowUrl
:
true
bottomTextL10n
:
{
id
:
"
firefox
-
suggest
-
mdn
-
bottom
-
text
"
}
}
}
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRustEnabled
"
)
)
{
result
.
payload
.
source
=
"
rust
"
;
result
.
payload
.
provider
=
"
Mdn
"
;
}
else
{
result
.
payload
.
source
=
"
remote
-
settings
"
;
result
.
payload
.
provider
=
"
MDNSuggestions
"
;
}
return
result
;
}
async
function
doMigrateTest
(
{
testOverrides
scenario
expectedPrefs
initialUserBranch
=
{
}
}
)
{
info
(
"
Testing
migration
:
"
+
JSON
.
stringify
(
{
testOverrides
initialUserBranch
scenario
expectedPrefs
}
)
)
;
function
setPref
(
branch
name
value
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
branch
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
branch
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
branch
.
setCharPref
(
name
value
)
;
break
;
default
:
Assert
.
ok
(
false
Pref
type
not
handled
for
setPref
:
{
name
}
=
{
value
}
)
;
break
;
}
}
function
getPref
(
branch
name
)
{
let
type
=
typeof
UrlbarPrefs
.
get
(
name
)
;
switch
(
type
)
{
case
"
boolean
"
:
return
branch
.
getBoolPref
(
name
)
;
case
"
number
"
:
return
branch
.
getIntPref
(
name
)
;
case
"
string
"
:
return
branch
.
getCharPref
(
name
)
;
default
:
Assert
.
ok
(
false
Pref
type
not
handled
for
getPref
:
{
name
}
{
type
}
)
;
break
;
}
return
null
;
}
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
browser
.
urlbar
.
"
)
;
let
userBranch
=
Services
.
prefs
.
getBranch
(
"
browser
.
urlbar
.
"
)
;
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
true
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
migrationVersion
"
)
;
let
initialDefaultBranch
=
{
"
suggest
.
quicksuggest
.
nonsponsored
"
:
false
"
suggest
.
quicksuggest
.
sponsored
"
:
false
"
quicksuggest
.
dataCollection
.
enabled
"
:
false
}
;
for
(
let
name
of
Object
.
keys
(
initialDefaultBranch
)
)
{
userBranch
.
clearUserPref
(
name
)
;
}
for
(
let
[
branch
prefs
]
of
[
[
defaultBranch
initialDefaultBranch
]
[
userBranch
initialUserBranch
]
]
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
if
(
value
!
=
=
undefined
)
{
setPref
(
branch
name
value
)
;
}
}
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
false
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
info
(
Calling
updateFirefoxSuggestScenario
i
=
{
i
}
)
;
await
UrlbarPrefs
.
updateFirefoxSuggestScenario
(
{
.
.
.
testOverrides
scenario
isStartup
:
true
}
)
;
let
expectedEffectivePrefs
=
{
}
;
let
{
defaultBranch
:
expectedDefaultBranch
userBranch
:
expectedUserBranch
}
=
expectedPrefs
;
expectedDefaultBranch
=
expectedDefaultBranch
|
|
{
}
;
expectedUserBranch
=
expectedUserBranch
|
|
{
}
;
for
(
let
[
branch
prefs
branchType
]
of
[
[
defaultBranch
expectedDefaultBranch
"
default
"
]
[
userBranch
expectedUserBranch
"
user
"
]
]
)
{
let
entries
=
Object
.
entries
(
prefs
)
;
if
(
!
entries
.
length
)
{
continue
;
}
info
(
Checking
expected
prefs
on
{
branchType
}
branch
after
updating
scenario
)
;
for
(
let
[
name
value
]
of
entries
)
{
expectedEffectivePrefs
[
name
]
=
value
;
if
(
branch
=
=
userBranch
)
{
Assert
.
ok
(
userBranch
.
prefHasUserValue
(
name
)
Pref
{
name
}
is
on
user
branch
)
;
}
Assert
.
equal
(
getPref
(
branch
name
)
value
Pref
{
name
}
value
on
{
branchType
}
branch
)
;
}
}
info
(
Making
sure
prefs
on
the
default
branch
without
expected
user
-
branch
values
are
not
on
the
user
branch
)
;
for
(
let
name
of
Object
.
keys
(
initialDefaultBranch
)
)
{
if
(
!
expectedUserBranch
.
hasOwnProperty
(
name
)
)
{
Assert
.
ok
(
!
userBranch
.
prefHasUserValue
(
name
)
Pref
{
name
}
is
not
on
user
branch
)
;
}
}
info
(
Checking
expected
effective
prefs
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
expectedEffectivePrefs
)
)
{
Assert
.
equal
(
UrlbarPrefs
.
get
(
name
)
value
Pref
{
name
}
effective
value
)
;
}
let
currentVersion
=
testOverrides
?
.
migrationVersion
=
=
=
undefined
?
UrlbarPrefs
.
FIREFOX_SUGGEST_MIGRATION_VERSION
:
testOverrides
.
migrationVersion
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
migrationVersion
"
)
currentVersion
"
quicksuggest
.
migrationVersion
is
correct
after
migration
"
)
;
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
true
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
migrationVersion
"
)
;
let
userBranchNames
=
[
.
.
.
Object
.
keys
(
initialUserBranch
)
.
.
.
Object
.
keys
(
expectedPrefs
.
userBranch
|
|
{
}
)
]
;
for
(
let
name
of
userBranchNames
)
{
userBranch
.
clearUserPref
(
name
)
;
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
false
;
}
async
function
doShowLessFrequentlyTests
(
{
feature
expectedResult
showLessFrequentlyCountPref
nimbusCapVariable
keyword
}
)
{
let
spaceIndex
=
keyword
.
indexOf
(
"
"
)
;
if
(
spaceIndex
<
0
)
{
throw
new
Error
(
"
keyword
must
contain
a
space
"
)
;
}
if
(
spaceIndex
=
=
0
)
{
throw
new
Error
(
"
keyword
must
not
start
with
a
space
"
)
;
}
if
(
keyword
.
length
<
spaceIndex
+
3
)
{
throw
new
Error
(
"
keyword
must
have
at
least
two
chars
after
the
space
"
)
;
}
let
tests
=
[
{
showLessFrequentlyCount
:
0
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
spaceIndex
-
1
)
]
:
false
[
keyword
.
substring
(
0
spaceIndex
)
]
:
true
[
keyword
.
substring
(
0
spaceIndex
+
1
)
]
:
true
[
keyword
.
substring
(
0
spaceIndex
+
2
)
]
:
true
[
keyword
.
substring
(
0
spaceIndex
+
3
)
]
:
true
}
}
{
showLessFrequentlyCount
:
1
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
spaceIndex
)
]
:
false
}
}
{
showLessFrequentlyCount
:
2
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
spaceIndex
+
1
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
[
keyword
.
substring
(
0
spaceIndex
+
2
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
}
}
]
;
if
(
!
UrlbarPrefs
.
get
(
"
quicksuggest
.
rustEnabled
"
)
)
{
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
3
}
}
)
;
}
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
Nimbus
and
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
10
}
nimbus
:
{
[
nimbusCapVariable
]
:
3
}
}
)
;
}
async
function
doOneShowLessFrequentlyTest
(
{
feature
expectedResult
showLessFrequentlyCountPref
tests
rs
=
{
}
nimbus
=
{
}
}
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
false
)
;
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
nimbus
)
;
await
QuickSuggestTestUtils
.
withConfig
(
{
config
:
rs
callback
:
async
(
)
=
>
{
let
cumulativeSearches
=
{
}
;
for
(
let
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
of
tests
)
{
info
(
"
Starting
subtest
:
"
+
JSON
.
stringify
(
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
)
)
;
Assert
.
equal
(
feature
.
showLessFrequentlyCount
showLessFrequentlyCount
"
showLessFrequentlyCount
should
be
correct
initially
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
showLessFrequentlyCountPref
)
showLessFrequentlyCount
"
Pref
should
be
correct
initially
"
)
;
Assert
.
equal
(
feature
.
canShowLessFrequently
canShowLessFrequently
"
canShowLessFrequently
should
be
correct
initially
"
)
;
cumulativeSearches
=
{
.
.
.
cumulativeSearches
.
.
.
newSearches
}
;
for
(
let
[
searchString
isExpected
]
of
Object
.
entries
(
cumulativeSearches
)
)
{
info
(
"
Doing
search
:
"
+
JSON
.
stringify
(
{
searchString
isExpected
}
)
)
;
let
results
=
[
]
;
if
(
isExpected
)
{
results
.
push
(
typeof
expectedResult
=
=
"
function
"
?
expectedResult
(
searchString
)
:
expectedResult
)
;
}
await
check_results
(
{
context
:
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
results
}
)
;
}
feature
.
incrementShowLessFrequentlyCount
(
)
;
}
}
}
)
;
await
cleanUpNimbus
(
)
;
UrlbarPrefs
.
clear
(
showLessFrequentlyCountPref
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
true
)
;
}
async
function
doRustProvidersTests
(
{
searchString
tests
}
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
for
(
let
{
prefs
expectedUrls
}
of
tests
)
{
info
(
"
Starting
Rust
providers
test
:
"
+
JSON
.
stringify
(
{
prefs
expectedUrls
}
)
)
;
info
(
"
Setting
prefs
and
forcing
sync
"
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
UrlbarPrefs
.
set
(
name
value
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
Querying
with
search
string
:
"
+
JSON
.
stringify
(
searchString
)
)
;
let
suggestions
=
await
QuickSuggest
.
rustBackend
.
query
(
searchString
)
;
info
(
"
Got
suggestions
:
"
+
JSON
.
stringify
(
suggestions
)
)
;
Assert
.
deepEqual
(
suggestions
.
map
(
s
=
>
s
.
url
)
.
sort
(
)
expectedUrls
.
sort
(
)
"
query
(
)
should
return
the
expected
suggestions
(
by
URL
)
"
)
;
info
(
"
Clearing
prefs
and
forcing
sync
"
)
;
for
(
let
name
of
Object
.
keys
(
prefs
)
)
{
UrlbarPrefs
.
clear
(
name
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
info
(
"
Clearing
rustEnabled
pref
and
forcing
sync
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
