ChromeUtils
.
defineESModuleGetters
(
this
{
Preferences
:
"
resource
:
/
/
gre
/
modules
/
Preferences
.
sys
.
mjs
"
QuickSuggest
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
QuickSuggest
.
sys
.
mjs
"
SearchUtils
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
search
/
SearchUtils
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarProviderAutofill
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarProviderAutofill
.
sys
.
mjs
"
UrlbarProviderQuickSuggest
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarProviderQuickSuggest
.
sys
.
mjs
"
UrlbarSearchUtils
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarSearchUtils
.
sys
.
mjs
"
}
)
;
add_setup
(
async
function
setUpQuickSuggestXpcshellTest
(
)
{
QuickSuggest
.
_testSkipTelemetryEnvironmentInit
=
true
;
}
)
;
async
function
setUpMigrateTest
(
)
{
await
UrlbarTestUtils
.
initNimbusFeature
(
)
;
await
QuickSuggestTestUtils
.
setRegionAndLocale
(
{
region
:
"
US
"
locale
:
"
en
-
US
"
}
)
;
}
async
function
doMigrateTest
(
{
toVersion
preMigrationUserPrefs
=
{
}
expectedPostMigrationUserPrefs
=
{
}
}
)
{
info
(
"
Testing
migration
:
"
+
JSON
.
stringify
(
{
toVersion
preMigrationUserPrefs
expectedPostMigrationUserPrefs
}
)
)
;
let
userPrefsToAlwaysCheck
=
[
"
quicksuggest
.
dataCollection
.
enabled
"
"
quicksuggest
.
enabled
"
"
suggest
.
quicksuggest
"
"
suggest
.
quicksuggest
.
nonsponsored
"
"
suggest
.
quicksuggest
.
sponsored
"
]
;
let
userBranch
=
new
Preferences
(
{
branch
:
"
browser
.
urlbar
.
"
defaultBranch
:
false
}
)
;
if
(
toVersion
=
=
1
)
{
userBranch
.
reset
(
"
quicksuggest
.
migrationVersion
"
)
;
}
else
{
userBranch
.
set
(
"
quicksuggest
.
migrationVersion
"
toVersion
-
1
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
preMigrationUserPrefs
)
)
{
userBranch
.
set
(
name
value
)
;
}
for
(
let
name
of
userPrefsToAlwaysCheck
)
{
if
(
!
preMigrationUserPrefs
.
hasOwnProperty
(
name
)
)
{
preMigrationUserPrefs
[
name
]
=
userBranch
.
isSet
(
name
)
?
userBranch
.
get
(
name
)
:
null
;
}
}
let
userPrefsToCheckPostMigration
=
new
Set
(
[
.
.
.
Object
.
keys
(
preMigrationUserPrefs
)
.
.
.
Object
.
keys
(
expectedPostMigrationUserPrefs
)
]
)
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
info
(
Reinitializing
Suggest
i
=
{
i
}
)
;
await
QuickSuggest
.
_test_reset
(
{
migrationVersion
:
toVersion
}
)
;
for
(
let
name
of
userPrefsToCheckPostMigration
)
{
let
expectedValue
=
expectedPostMigrationUserPrefs
.
hasOwnProperty
(
name
)
?
expectedPostMigrationUserPrefs
[
name
]
:
preMigrationUserPrefs
[
name
]
;
if
(
expectedValue
=
=
=
null
)
{
Assert
.
ok
(
!
userBranch
.
isSet
(
name
)
"
Pref
should
not
have
a
user
value
after
migration
:
"
+
name
)
;
}
else
{
Assert
.
ok
(
userBranch
.
isSet
(
name
)
"
Pref
should
have
a
user
value
after
migration
:
"
+
name
)
;
Assert
.
equal
(
userBranch
.
get
(
name
)
expectedValue
"
Pref
should
have
been
set
to
the
expected
value
after
migration
:
"
+
name
)
;
}
}
Assert
.
equal
(
userBranch
.
get
(
"
quicksuggest
.
migrationVersion
"
)
toVersion
"
quicksuggest
.
migrationVersion
should
be
updated
after
migration
"
)
;
}
userBranch
.
reset
(
"
quicksuggest
.
migrationVersion
"
)
;
for
(
let
name
of
userPrefsToCheckPostMigration
)
{
userBranch
.
reset
(
name
)
;
}
}
async
function
doDismissOneTest
(
{
feature
result
command
queriesForDismissals
queriesForOthers
providers
=
[
UrlbarProviderQuickSuggest
.
name
]
}
)
{
await
QuickSuggest
.
clearDismissedSuggestions
(
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
Assert
.
ok
(
!
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
)
"
Sanity
check
:
canClearDismissedSuggestions
should
return
false
initially
"
)
;
let
changedPromise
=
TestUtils
.
topicObserved
(
"
quicksuggest
-
dismissals
-
changed
"
)
;
let
actualResult
=
await
getActualResult
(
{
providers
query
:
queriesForDismissals
[
0
]
.
query
expectedResult
:
result
}
)
;
triggerCommand
(
{
command
feature
result
:
actualResult
expectedCountsByCall
:
{
removeResult
:
1
}
}
)
;
info
(
"
Awaiting
dismissals
-
changed
promise
"
)
;
await
changedPromise
;
Assert
.
ok
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
"
canClearDismissedSuggestions
should
return
true
after
triggering
command
"
)
;
Assert
.
ok
(
await
QuickSuggest
.
isResultDismissed
(
actualResult
)
"
The
result
should
be
dismissed
"
)
;
for
(
let
{
query
}
of
queriesForDismissals
)
{
info
(
"
Doing
search
for
dismissed
suggestions
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
}
for
(
let
{
query
expectedResults
}
of
queriesForOthers
)
{
info
(
"
Doing
search
for
non
-
dismissed
suggestions
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
isPrivate
:
false
}
)
matches
:
expectedResults
}
)
;
}
let
clearedPromise
=
TestUtils
.
topicObserved
(
"
quicksuggest
-
dismissals
-
cleared
"
)
;
info
(
"
Clearing
dismissals
"
)
;
await
QuickSuggest
.
clearDismissedSuggestions
(
)
;
info
(
"
Awaiting
dismissals
-
cleared
promise
"
)
;
await
clearedPromise
;
Assert
.
ok
(
!
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
)
"
canClearDismissedSuggestions
should
return
false
after
clearing
dismissals
"
)
;
for
(
let
{
query
expectedResults
=
[
result
]
}
of
queriesForDismissals
)
{
info
(
"
Doing
search
after
clearing
dismissals
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
isPrivate
:
false
}
)
matches
:
expectedResults
}
)
;
}
}
async
function
doDismissAllTest
(
{
feature
result
command
pref
queries
providers
=
[
UrlbarProviderQuickSuggest
.
name
]
}
)
{
await
QuickSuggest
.
clearDismissedSuggestions
(
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
Assert
.
ok
(
!
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
)
"
Sanity
check
:
canClearDismissedSuggestions
should
return
false
initially
"
)
;
let
changedPromise
=
TestUtils
.
topicObserved
(
"
quicksuggest
-
dismissals
-
changed
"
)
;
let
actualResult
=
await
getActualResult
(
{
providers
query
:
queries
[
0
]
.
query
expectedResult
:
result
}
)
;
triggerCommand
(
{
command
feature
result
:
actualResult
expectedCountsByCall
:
{
removeResult
:
1
}
}
)
;
info
(
"
Awaiting
dismissals
-
changed
promise
"
)
;
await
changedPromise
;
Assert
.
ok
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
"
canClearDismissedSuggestions
should
return
true
after
triggering
command
"
)
;
Assert
.
ok
(
!
UrlbarPrefs
.
get
(
pref
)
"
Pref
should
be
false
after
triggering
command
:
"
+
pref
)
;
for
(
let
{
query
}
of
queries
)
{
info
(
"
Doing
search
after
triggering
command
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
}
let
clearedPromise
=
TestUtils
.
topicObserved
(
"
quicksuggest
-
dismissals
-
cleared
"
)
;
info
(
"
Clearing
dismissals
"
)
;
await
QuickSuggest
.
clearDismissedSuggestions
(
)
;
info
(
"
Awaiting
dismissals
-
cleared
promise
"
)
;
await
clearedPromise
;
Assert
.
ok
(
!
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
)
"
canClearDismissedSuggestions
should
return
false
after
clearing
dismissals
"
)
;
Assert
.
ok
(
UrlbarPrefs
.
get
(
pref
)
"
Pref
should
be
true
after
clearing
it
:
"
+
pref
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
for
(
let
{
query
expectedResults
=
[
result
]
}
of
queries
)
{
info
(
"
Doing
search
after
clearing
dismissals
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
isPrivate
:
false
}
)
matches
:
expectedResults
}
)
;
}
}
async
function
getActualResult
(
{
query
expectedResult
providers
=
[
UrlbarProviderQuickSuggest
.
name
]
}
)
{
info
(
"
Doing
search
to
get
an
actual
result
:
"
+
JSON
.
stringify
(
query
)
)
;
let
context
=
createContext
(
query
{
providers
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedResult
]
}
)
;
let
actualResult
=
context
.
results
.
find
(
r
=
>
r
.
providerName
=
=
UrlbarProviderQuickSuggest
.
name
&
&
r
.
payload
.
provider
=
=
expectedResult
.
payload
.
provider
)
;
Assert
.
ok
(
actualResult
"
Search
should
have
returned
a
matching
result
"
)
;
return
actualResult
;
}
async
function
doShowLessFrequentlyTests
(
{
feature
expectedResult
showLessFrequentlyCountPref
nimbusCapVariable
keyword
keywordBaseIndex
=
keyword
.
indexOf
(
"
"
)
}
)
{
if
(
keywordBaseIndex
<
=
0
)
{
throw
new
Error
(
"
keywordBaseIndex
must
be
>
0
but
it
'
s
"
+
keywordBaseIndex
)
;
}
if
(
keyword
.
length
<
keywordBaseIndex
+
3
)
{
throw
new
Error
(
"
keyword
must
have
at
least
two
chars
after
keywordBaseIndex
"
)
;
}
let
tests
=
[
{
showLessFrequentlyCount
:
0
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
-
1
)
]
:
false
[
keyword
.
substring
(
0
keywordBaseIndex
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
1
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
2
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
3
)
]
:
true
}
}
{
showLessFrequentlyCount
:
1
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
)
]
:
false
}
}
{
showLessFrequentlyCount
:
2
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
+
1
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
+
2
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
}
}
]
;
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
3
}
}
)
;
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
Nimbus
and
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
10
}
nimbus
:
{
[
nimbusCapVariable
]
:
3
}
}
)
;
}
async
function
doOneShowLessFrequentlyTest
(
{
feature
expectedResult
showLessFrequentlyCountPref
tests
rs
=
{
}
nimbus
=
{
}
}
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
online
.
enabled
"
false
)
;
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
nimbus
)
;
await
QuickSuggestTestUtils
.
withConfig
(
{
config
:
rs
callback
:
async
(
)
=
>
{
let
cumulativeSearches
=
{
}
;
for
(
let
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
of
tests
)
{
info
(
"
Starting
subtest
:
"
+
JSON
.
stringify
(
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
)
)
;
Assert
.
equal
(
feature
.
showLessFrequentlyCount
showLessFrequentlyCount
"
showLessFrequentlyCount
should
be
correct
initially
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
showLessFrequentlyCountPref
)
showLessFrequentlyCount
"
Pref
should
be
correct
initially
"
)
;
Assert
.
equal
(
feature
.
canShowLessFrequently
canShowLessFrequently
"
canShowLessFrequently
should
be
correct
initially
"
)
;
cumulativeSearches
=
{
.
.
.
cumulativeSearches
.
.
.
newSearches
}
;
for
(
let
[
searchString
isExpected
]
of
Object
.
entries
(
cumulativeSearches
)
)
{
info
(
"
Doing
search
:
"
+
JSON
.
stringify
(
{
searchString
isExpected
}
)
)
;
let
results
=
[
]
;
if
(
isExpected
)
{
results
.
push
(
typeof
expectedResult
=
=
"
function
"
?
expectedResult
(
searchString
)
:
expectedResult
)
;
}
await
check_results
(
{
context
:
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
results
}
)
;
}
feature
.
incrementShowLessFrequentlyCount
(
)
;
}
}
}
)
;
await
cleanUpNimbus
(
)
;
UrlbarPrefs
.
clear
(
showLessFrequentlyCountPref
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
online
.
enabled
"
)
;
}
async
function
doRustProvidersTests
(
{
searchString
tests
}
)
{
for
(
let
{
prefs
expectedUrls
}
of
tests
)
{
info
(
"
Starting
Rust
providers
test
:
"
+
JSON
.
stringify
(
{
prefs
expectedUrls
}
)
)
;
info
(
"
Setting
prefs
and
forcing
sync
"
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
UrlbarPrefs
.
set
(
name
value
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
Querying
with
search
string
:
"
+
JSON
.
stringify
(
searchString
)
)
;
let
suggestions
=
await
QuickSuggest
.
rustBackend
.
query
(
searchString
)
;
info
(
"
Got
suggestions
:
"
+
JSON
.
stringify
(
suggestions
)
)
;
Assert
.
deepEqual
(
suggestions
.
map
(
s
=
>
s
.
url
)
.
sort
(
)
expectedUrls
.
sort
(
)
"
query
(
)
should
return
the
expected
suggestions
(
by
URL
)
"
)
;
info
(
"
Clearing
prefs
and
forcing
sync
"
)
;
for
(
let
name
of
Object
.
keys
(
prefs
)
)
{
UrlbarPrefs
.
clear
(
name
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
}
function
triggerCommand
(
{
feature
command
result
searchString
=
"
"
expectedCountsByCall
=
null
}
)
{
info
(
Calling
{
feature
.
name
}
.
onEngagement
(
)
to
trigger
command
:
{
command
}
)
;
let
countsByCall
=
new
Map
(
)
;
let
addCall
=
name
=
>
{
if
(
!
countsByCall
.
has
(
name
)
)
{
countsByCall
.
set
(
name
0
)
;
}
countsByCall
.
set
(
name
countsByCall
.
get
(
name
)
+
1
)
;
}
;
feature
.
onEngagement
(
{
}
{
removeResult
(
)
{
addCall
(
"
removeResult
"
)
;
}
input
:
{
startQuery
(
)
{
addCall
(
"
startQuery
"
)
;
}
}
view
:
{
acknowledgeFeedback
(
)
{
addCall
(
"
acknowledgeFeedback
"
)
;
}
invalidateResultMenuCommands
(
)
{
addCall
(
"
invalidateResultMenuCommands
"
)
;
}
}
}
{
result
selType
:
command
}
searchString
)
;
if
(
expectedCountsByCall
)
{
for
(
let
[
name
expectedCount
]
of
Object
.
entries
(
expectedCountsByCall
)
)
{
Assert
.
equal
(
countsByCall
.
get
(
name
)
?
?
0
expectedCount
"
Function
should
have
been
called
the
expected
number
of
times
:
"
+
name
)
;
}
}
return
countsByCall
;
}
