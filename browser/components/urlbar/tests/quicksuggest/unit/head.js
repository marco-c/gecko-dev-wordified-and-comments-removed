ChromeUtils
.
defineESModuleGetters
(
this
{
QuickSuggest
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
QuickSuggest
.
sys
.
mjs
"
SearchUtils
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
search
/
SearchUtils
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarProviderAutofill
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarProviderAutofill
.
sys
.
mjs
"
UrlbarProviderQuickSuggest
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarProviderQuickSuggest
.
sys
.
mjs
"
UrlbarSearchUtils
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
UrlbarSearchUtils
.
sys
.
mjs
"
}
)
;
add_setup
(
async
function
setUpQuickSuggestXpcshellTest
(
)
{
QuickSuggest
.
_testSkipTelemetryEnvironmentInit
=
true
;
}
)
;
async
function
doMigrateTest
(
{
testOverrides
expectedPrefs
shouldEnable
=
true
initialUserBranch
=
{
}
}
)
{
info
(
"
Testing
migration
:
"
+
JSON
.
stringify
(
{
testOverrides
initialUserBranch
shouldEnable
expectedPrefs
}
)
)
;
function
setPref
(
branch
name
value
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
branch
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
branch
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
branch
.
setCharPref
(
name
value
)
;
break
;
default
:
Assert
.
ok
(
false
Pref
type
not
handled
for
setPref
:
{
name
}
=
{
value
}
)
;
break
;
}
}
function
getPref
(
branch
name
)
{
let
type
=
typeof
UrlbarPrefs
.
get
(
name
)
;
switch
(
type
)
{
case
"
boolean
"
:
return
branch
.
getBoolPref
(
name
)
;
case
"
number
"
:
return
branch
.
getIntPref
(
name
)
;
case
"
string
"
:
return
branch
.
getCharPref
(
name
)
;
default
:
Assert
.
ok
(
false
Pref
type
not
handled
for
getPref
:
{
name
}
{
type
}
)
;
break
;
}
return
null
;
}
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
browser
.
urlbar
.
"
)
;
let
userBranch
=
Services
.
prefs
.
getBranch
(
"
browser
.
urlbar
.
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
migrationVersion
"
)
;
let
initialDefaultBranch
=
{
"
suggest
.
quicksuggest
.
nonsponsored
"
:
false
"
suggest
.
quicksuggest
.
sponsored
"
:
false
"
quicksuggest
.
dataCollection
.
enabled
"
:
false
}
;
for
(
let
name
of
Object
.
keys
(
initialDefaultBranch
)
)
{
userBranch
.
clearUserPref
(
name
)
;
}
for
(
let
[
branch
prefs
]
of
[
[
defaultBranch
initialDefaultBranch
]
[
userBranch
initialUserBranch
]
]
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
if
(
value
!
=
=
undefined
)
{
setPref
(
branch
name
value
)
;
}
}
}
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
info
(
Reinitializing
Suggest
i
=
{
i
}
)
;
await
QuickSuggest
.
_test_reinit
(
{
.
.
.
testOverrides
region
:
shouldEnable
?
"
US
"
:
"
XX
"
locale
:
shouldEnable
?
"
en
-
US
"
:
"
xx
-
XX
"
}
)
;
let
expectedEffectivePrefs
=
{
}
;
let
{
defaultBranch
:
expectedDefaultBranch
userBranch
:
expectedUserBranch
}
=
expectedPrefs
;
expectedDefaultBranch
=
expectedDefaultBranch
|
|
{
}
;
expectedUserBranch
=
expectedUserBranch
|
|
{
}
;
for
(
let
[
branch
prefs
branchType
]
of
[
[
defaultBranch
expectedDefaultBranch
"
default
"
]
[
userBranch
expectedUserBranch
"
user
"
]
]
)
{
let
entries
=
Object
.
entries
(
prefs
)
;
if
(
!
entries
.
length
)
{
continue
;
}
info
(
Checking
expected
prefs
on
{
branchType
}
branch
after
Suggest
init
)
;
for
(
let
[
name
value
]
of
entries
)
{
expectedEffectivePrefs
[
name
]
=
value
;
if
(
branch
=
=
userBranch
)
{
Assert
.
ok
(
userBranch
.
prefHasUserValue
(
name
)
Pref
{
name
}
is
on
user
branch
)
;
}
Assert
.
equal
(
getPref
(
branch
name
)
value
Pref
{
name
}
value
on
{
branchType
}
branch
)
;
}
}
info
(
Making
sure
prefs
on
the
default
branch
without
expected
user
-
branch
values
are
not
on
the
user
branch
)
;
for
(
let
name
of
Object
.
keys
(
initialDefaultBranch
)
)
{
if
(
!
expectedUserBranch
.
hasOwnProperty
(
name
)
)
{
Assert
.
ok
(
!
userBranch
.
prefHasUserValue
(
name
)
Pref
{
name
}
is
not
on
user
branch
)
;
}
}
info
(
Checking
expected
effective
prefs
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
expectedEffectivePrefs
)
)
{
Assert
.
equal
(
UrlbarPrefs
.
get
(
name
)
value
Pref
{
name
}
effective
value
)
;
}
let
currentVersion
=
testOverrides
?
.
migrationVersion
=
=
=
undefined
?
QuickSuggest
.
MIGRATION_VERSION
:
testOverrides
.
migrationVersion
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
migrationVersion
"
)
currentVersion
"
quicksuggest
.
migrationVersion
is
correct
after
migration
"
)
;
}
UrlbarPrefs
.
clear
(
"
quicksuggest
.
migrationVersion
"
)
;
let
userBranchNames
=
[
.
.
.
Object
.
keys
(
initialUserBranch
)
.
.
.
Object
.
keys
(
expectedPrefs
.
userBranch
|
|
{
}
)
]
;
for
(
let
name
of
userBranchNames
)
{
userBranch
.
clearUserPref
(
name
)
;
}
}
async
function
doDismissOneTest
(
{
feature
result
command
queriesForDismissals
queriesForOthers
}
)
{
await
QuickSuggest
.
clearDismissedSuggestions
(
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
Assert
.
ok
(
!
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
)
"
Sanity
check
:
canClearDismissedSuggestions
should
return
false
initially
"
)
;
let
changedPromise
=
TestUtils
.
topicObserved
(
"
quicksuggest
-
dismissals
-
changed
"
)
;
triggerCommand
(
{
result
command
feature
expectedCountsByCall
:
{
removeResult
:
1
}
}
)
;
info
(
"
Awaiting
dismissals
-
changed
promise
"
)
;
await
changedPromise
;
Assert
.
ok
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
"
canClearDismissedSuggestions
should
return
true
after
triggering
command
"
)
;
Assert
.
ok
(
await
QuickSuggest
.
isResultDismissed
(
result
)
"
The
result
should
be
dismissed
"
)
;
for
(
let
{
query
}
of
queriesForDismissals
)
{
info
(
"
Doing
search
for
dismissed
suggestions
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
}
for
(
let
{
query
expectedResults
}
of
queriesForOthers
)
{
info
(
"
Doing
search
for
non
-
dismissed
suggestions
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
expectedResults
}
)
;
}
let
clearedPromise
=
TestUtils
.
topicObserved
(
"
quicksuggest
-
dismissals
-
cleared
"
)
;
info
(
"
Clearing
dismissals
"
)
;
await
QuickSuggest
.
clearDismissedSuggestions
(
)
;
info
(
"
Awaiting
dismissals
-
cleared
promise
"
)
;
await
clearedPromise
;
Assert
.
ok
(
!
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
)
"
canClearDismissedSuggestions
should
return
false
after
clearing
dismissals
"
)
;
for
(
let
{
query
expectedResults
=
[
result
]
}
of
queriesForDismissals
)
{
info
(
"
Doing
search
after
clearing
dismissals
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
expectedResults
}
)
;
}
}
async
function
doDismissAllTest
(
{
feature
result
command
pref
queries
}
)
{
await
QuickSuggest
.
clearDismissedSuggestions
(
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
Assert
.
ok
(
!
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
)
"
Sanity
check
:
canClearDismissedSuggestions
should
return
false
initially
"
)
;
let
changedPromise
=
TestUtils
.
topicObserved
(
"
quicksuggest
-
dismissals
-
changed
"
)
;
triggerCommand
(
{
result
command
feature
expectedCountsByCall
:
{
removeResult
:
1
}
}
)
;
info
(
"
Awaiting
dismissals
-
changed
promise
"
)
;
await
changedPromise
;
Assert
.
ok
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
"
canClearDismissedSuggestions
should
return
true
after
triggering
command
"
)
;
Assert
.
ok
(
!
UrlbarPrefs
.
get
(
pref
)
"
Pref
should
be
false
after
triggering
command
:
"
+
pref
)
;
for
(
let
{
query
}
of
queries
)
{
info
(
"
Doing
search
after
triggering
command
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
}
let
clearedPromise
=
TestUtils
.
topicObserved
(
"
quicksuggest
-
dismissals
-
cleared
"
)
;
info
(
"
Clearing
dismissals
"
)
;
await
QuickSuggest
.
clearDismissedSuggestions
(
)
;
info
(
"
Awaiting
dismissals
-
cleared
promise
"
)
;
await
clearedPromise
;
Assert
.
ok
(
!
(
await
QuickSuggest
.
canClearDismissedSuggestions
(
)
)
"
canClearDismissedSuggestions
should
return
false
after
clearing
dismissals
"
)
;
Assert
.
ok
(
UrlbarPrefs
.
get
(
pref
)
"
Pref
should
be
true
after
clearing
it
:
"
+
pref
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
for
(
let
{
query
expectedResults
=
[
result
]
}
of
queries
)
{
info
(
"
Doing
search
after
clearing
dismissals
:
"
+
JSON
.
stringify
(
query
)
)
;
await
check_results
(
{
context
:
createContext
(
query
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
expectedResults
}
)
;
}
}
async
function
doShowLessFrequentlyTests
(
{
feature
expectedResult
showLessFrequentlyCountPref
nimbusCapVariable
keyword
keywordBaseIndex
=
keyword
.
indexOf
(
"
"
)
}
)
{
if
(
keywordBaseIndex
<
=
0
)
{
throw
new
Error
(
"
keywordBaseIndex
must
be
>
0
but
it
'
s
"
+
keywordBaseIndex
)
;
}
if
(
keyword
.
length
<
keywordBaseIndex
+
3
)
{
throw
new
Error
(
"
keyword
must
have
at
least
two
chars
after
keywordBaseIndex
"
)
;
}
let
tests
=
[
{
showLessFrequentlyCount
:
0
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
-
1
)
]
:
false
[
keyword
.
substring
(
0
keywordBaseIndex
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
1
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
2
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
3
)
]
:
true
}
}
{
showLessFrequentlyCount
:
1
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
)
]
:
false
}
}
{
showLessFrequentlyCount
:
2
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
+
1
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
+
2
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
}
}
]
;
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
3
}
}
)
;
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
Nimbus
and
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
10
}
nimbus
:
{
[
nimbusCapVariable
]
:
3
}
}
)
;
}
async
function
doOneShowLessFrequentlyTest
(
{
feature
expectedResult
showLessFrequentlyCountPref
tests
rs
=
{
}
nimbus
=
{
}
}
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
false
)
;
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
nimbus
)
;
await
QuickSuggestTestUtils
.
withConfig
(
{
config
:
rs
callback
:
async
(
)
=
>
{
let
cumulativeSearches
=
{
}
;
for
(
let
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
of
tests
)
{
info
(
"
Starting
subtest
:
"
+
JSON
.
stringify
(
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
)
)
;
Assert
.
equal
(
feature
.
showLessFrequentlyCount
showLessFrequentlyCount
"
showLessFrequentlyCount
should
be
correct
initially
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
showLessFrequentlyCountPref
)
showLessFrequentlyCount
"
Pref
should
be
correct
initially
"
)
;
Assert
.
equal
(
feature
.
canShowLessFrequently
canShowLessFrequently
"
canShowLessFrequently
should
be
correct
initially
"
)
;
cumulativeSearches
=
{
.
.
.
cumulativeSearches
.
.
.
newSearches
}
;
for
(
let
[
searchString
isExpected
]
of
Object
.
entries
(
cumulativeSearches
)
)
{
info
(
"
Doing
search
:
"
+
JSON
.
stringify
(
{
searchString
isExpected
}
)
)
;
let
results
=
[
]
;
if
(
isExpected
)
{
results
.
push
(
typeof
expectedResult
=
=
"
function
"
?
expectedResult
(
searchString
)
:
expectedResult
)
;
}
await
check_results
(
{
context
:
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
results
}
)
;
}
feature
.
incrementShowLessFrequentlyCount
(
)
;
}
}
}
)
;
await
cleanUpNimbus
(
)
;
UrlbarPrefs
.
clear
(
showLessFrequentlyCountPref
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
true
)
;
}
async
function
doRustProvidersTests
(
{
searchString
tests
}
)
{
for
(
let
{
prefs
expectedUrls
}
of
tests
)
{
info
(
"
Starting
Rust
providers
test
:
"
+
JSON
.
stringify
(
{
prefs
expectedUrls
}
)
)
;
info
(
"
Setting
prefs
and
forcing
sync
"
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
UrlbarPrefs
.
set
(
name
value
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
Querying
with
search
string
:
"
+
JSON
.
stringify
(
searchString
)
)
;
let
suggestions
=
await
QuickSuggest
.
rustBackend
.
query
(
searchString
)
;
info
(
"
Got
suggestions
:
"
+
JSON
.
stringify
(
suggestions
)
)
;
Assert
.
deepEqual
(
suggestions
.
map
(
s
=
>
s
.
url
)
.
sort
(
)
expectedUrls
.
sort
(
)
"
query
(
)
should
return
the
expected
suggestions
(
by
URL
)
"
)
;
info
(
"
Clearing
prefs
and
forcing
sync
"
)
;
for
(
let
name
of
Object
.
keys
(
prefs
)
)
{
UrlbarPrefs
.
clear
(
name
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
}
function
triggerCommand
(
{
feature
command
result
searchString
=
"
"
expectedCountsByCall
=
null
}
)
{
info
(
Calling
{
feature
.
name
}
.
onEngagement
(
)
to
trigger
command
:
{
command
}
)
;
let
countsByCall
=
new
Map
(
)
;
let
addCall
=
name
=
>
{
if
(
!
countsByCall
.
has
(
name
)
)
{
countsByCall
.
set
(
name
0
)
;
}
countsByCall
.
set
(
name
countsByCall
.
get
(
name
)
+
1
)
;
}
;
feature
.
onEngagement
(
{
}
{
removeResult
(
)
{
addCall
(
"
removeResult
"
)
;
}
view
:
{
acknowledgeFeedback
(
)
{
addCall
(
"
acknowledgeFeedback
"
)
;
}
invalidateResultMenuCommands
(
)
{
addCall
(
"
invalidateResultMenuCommands
"
)
;
}
}
}
{
result
selType
:
command
}
searchString
)
;
if
(
expectedCountsByCall
)
{
for
(
let
[
name
expectedCount
]
of
Object
.
entries
(
expectedCountsByCall
)
)
{
Assert
.
equal
(
countsByCall
.
get
(
name
)
?
?
0
expectedCount
"
Function
should
have
been
called
the
expected
number
of
times
:
"
+
name
)
;
}
}
return
countsByCall
;
}
