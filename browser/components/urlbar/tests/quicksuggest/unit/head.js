ChromeUtils
.
defineESModuleGetters
(
this
{
QuickSuggest
:
"
resource
:
/
/
/
modules
/
QuickSuggest
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarProviderAutofill
:
"
resource
:
/
/
/
modules
/
UrlbarProviderAutofill
.
sys
.
mjs
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
sys
.
mjs
"
}
)
;
add_setup
(
async
function
setUpQuickSuggestXpcshellTest
(
)
{
UrlbarPrefs
.
_testSkipTelemetryEnvironmentInit
=
true
;
}
)
;
let
gAddTasksWithRustSetup
;
function
add_tasks_with_rust
(
.
.
.
args
)
{
let
skipIfRustEnabled
=
false
;
let
i
=
args
.
findIndex
(
a
=
>
a
.
skip_if_rust_enabled
)
;
if
(
i
>
=
0
)
{
skipIfRustEnabled
=
true
;
args
.
splice
(
i
1
)
;
}
let
taskFnIndex
=
args
.
findIndex
(
a
=
>
typeof
a
=
=
"
function
"
)
;
let
taskFn
=
args
[
taskFnIndex
]
;
for
(
let
rustEnabled
of
[
false
true
]
)
{
let
newTaskName
=
(
taskFn
.
name
|
|
"
anonymousTask
"
)
+
(
rustEnabled
?
"
_rustEnabled
"
:
"
_rustDisabled
"
)
;
if
(
rustEnabled
&
&
skipIfRustEnabled
)
{
info
(
"
add_tasks_with_rust
:
Skipping
due
to
skip_if_rust_enabled
:
"
+
newTaskName
)
;
continue
;
}
let
newTaskFn
=
async
(
.
.
.
taskFnArgs
)
=
>
{
info
(
"
add_tasks_with_rust
:
Setting
rustEnabled
:
"
+
rustEnabled
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
rustEnabled
)
;
info
(
"
add_tasks_with_rust
:
Done
setting
rustEnabled
:
"
+
rustEnabled
)
;
info
(
"
add_tasks_with_rust
:
Forcing
sync
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
add_tasks_with_rust
:
Done
forcing
sync
"
)
;
if
(
gAddTasksWithRustSetup
)
{
info
(
"
add_tasks_with_rust
:
Calling
setup
function
"
)
;
await
gAddTasksWithRustSetup
(
)
;
info
(
"
add_tasks_with_rust
:
Done
calling
setup
function
"
)
;
}
let
rv
;
try
{
info
(
"
add_tasks_with_rust
:
Calling
original
task
function
:
"
+
taskFn
.
name
)
;
rv
=
await
taskFn
(
.
.
.
taskFnArgs
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_ABORT
)
{
Assert
.
ok
(
false
"
add_tasks_with_rust
:
The
original
task
function
threw
an
error
:
"
+
e
)
;
}
throw
e
;
}
finally
{
info
(
"
add_tasks_with_rust
:
Done
calling
original
task
function
:
"
+
taskFn
.
name
)
;
info
(
"
add_tasks_with_rust
:
Clearing
rustEnabled
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
info
(
"
add_tasks_with_rust
:
Done
clearing
rustEnabled
"
)
;
info
(
"
add_tasks_with_rust
:
Forcing
sync
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
add_tasks_with_rust
:
Done
forcing
sync
"
)
;
}
return
rv
;
}
;
Object
.
defineProperty
(
newTaskFn
"
name
"
{
value
:
newTaskName
}
)
;
let
addTaskArgs
=
[
]
;
for
(
let
j
=
0
;
j
<
args
.
length
;
j
+
+
)
{
addTaskArgs
[
j
]
=
j
=
=
taskFnIndex
?
newTaskFn
:
Cu
.
cloneInto
(
args
[
j
]
this
{
cloneFunctions
:
true
}
)
;
}
add_task
(
.
.
.
addTaskArgs
)
;
}
}
function
registerAddTasksWithRustSetup
(
setupFn
)
{
gAddTasksWithRustSetup
=
setupFn
;
}
function
makeWikipediaResult
(
{
source
provider
keyword
=
"
wikipedia
"
title
=
"
Wikipedia
Suggestion
"
url
=
"
https
:
/
/
example
.
com
/
wikipedia
"
originalUrl
=
"
https
:
/
/
example
.
com
/
wikipedia
"
icon
=
null
iconBlob
=
new
Blob
(
[
new
Uint8Array
(
[
]
)
]
)
impressionUrl
=
"
https
:
/
/
example
.
com
/
wikipedia
-
impression
"
clickUrl
=
"
https
:
/
/
example
.
com
/
wikipedia
-
click
"
blockId
=
2
advertiser
=
"
Wikipedia
"
iabCategory
=
"
5
-
Education
"
suggestedIndex
=
-
1
isSuggestedIndexRelativeToGroup
=
true
}
)
{
let
result
=
{
suggestedIndex
isSuggestedIndexRelativeToGroup
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
title
url
originalUrl
displayUrl
:
url
.
replace
(
/
^
https
:
\
/
\
/
/
"
"
)
isSponsored
:
false
qsSuggestion
:
keyword
sponsoredAdvertiser
:
"
Wikipedia
"
sponsoredIabCategory
:
"
5
-
Education
"
isBlockable
:
true
blockL10n
:
{
id
:
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
}
isManageable
:
true
telemetryType
:
"
adm_nonsponsored
"
}
}
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRustEnabled
"
)
)
{
result
.
payload
.
source
=
source
|
|
"
rust
"
;
result
.
payload
.
provider
=
provider
|
|
"
Wikipedia
"
;
result
.
payload
.
iconBlob
=
iconBlob
;
}
else
{
result
.
payload
.
source
=
source
|
|
"
remote
-
settings
"
;
result
.
payload
.
provider
=
provider
|
|
"
AdmWikipedia
"
;
result
.
payload
.
icon
=
icon
;
result
.
payload
.
sponsoredImpressionUrl
=
impressionUrl
;
result
.
payload
.
sponsoredClickUrl
=
clickUrl
;
result
.
payload
.
sponsoredBlockId
=
blockId
;
result
.
payload
.
sponsoredAdvertiser
=
advertiser
;
result
.
payload
.
sponsoredIabCategory
=
iabCategory
;
}
return
result
;
}
function
makeAmpResult
(
{
source
provider
keyword
=
"
amp
"
title
=
"
Amp
Suggestion
"
url
=
"
https
:
/
/
example
.
com
/
amp
"
originalUrl
=
"
https
:
/
/
example
.
com
/
amp
"
icon
=
null
iconBlob
=
new
Blob
(
[
new
Uint8Array
(
[
]
)
]
)
impressionUrl
=
"
https
:
/
/
example
.
com
/
amp
-
impression
"
clickUrl
=
"
https
:
/
/
example
.
com
/
amp
-
click
"
blockId
=
1
advertiser
=
"
Amp
"
iabCategory
=
"
22
-
Shopping
"
suggestedIndex
=
0
isSuggestedIndexRelativeToGroup
=
true
requestId
=
undefined
}
=
{
}
)
{
let
result
=
{
suggestedIndex
isSuggestedIndexRelativeToGroup
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
title
url
originalUrl
requestId
displayUrl
:
url
.
replace
(
/
^
https
:
\
/
\
/
/
"
"
)
isSponsored
:
true
qsSuggestion
:
keyword
sponsoredImpressionUrl
:
impressionUrl
sponsoredClickUrl
:
clickUrl
sponsoredBlockId
:
blockId
sponsoredAdvertiser
:
advertiser
sponsoredIabCategory
:
iabCategory
isBlockable
:
true
blockL10n
:
{
id
:
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
}
isManageable
:
true
telemetryType
:
"
adm_sponsored
"
descriptionL10n
:
{
id
:
"
urlbar
-
result
-
action
-
sponsored
"
}
}
}
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRustEnabled
"
)
)
{
result
.
payload
.
source
=
source
|
|
"
rust
"
;
result
.
payload
.
provider
=
provider
|
|
"
Amp
"
;
if
(
result
.
payload
.
source
=
=
"
rust
"
)
{
result
.
payload
.
iconBlob
=
iconBlob
;
}
else
{
result
.
payload
.
icon
=
icon
;
}
}
else
{
result
.
payload
.
source
=
source
|
|
"
remote
-
settings
"
;
result
.
payload
.
provider
=
provider
|
|
"
AdmWikipedia
"
;
result
.
payload
.
icon
=
icon
;
}
return
result
;
}
function
makeMdnResult
(
{
url
title
description
}
)
{
let
finalUrl
=
new
URL
(
url
)
;
finalUrl
.
searchParams
.
set
(
"
utm_medium
"
"
firefox
-
desktop
"
)
;
finalUrl
.
searchParams
.
set
(
"
utm_source
"
"
firefox
-
suggest
"
)
;
finalUrl
.
searchParams
.
set
(
"
utm_campaign
"
"
firefox
-
mdn
-
web
-
docs
-
suggestion
-
experiment
"
)
;
finalUrl
.
searchParams
.
set
(
"
utm_content
"
"
treatment
"
)
;
let
result
=
{
isBestMatch
:
true
suggestedIndex
:
1
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
heuristic
:
false
payload
:
{
telemetryType
:
"
mdn
"
title
url
:
finalUrl
.
href
originalUrl
:
url
displayUrl
:
finalUrl
.
href
.
replace
(
/
^
https
:
\
/
\
/
/
"
"
)
description
icon
:
"
chrome
:
/
/
global
/
skin
/
icons
/
mdn
.
svg
"
shouldShowUrl
:
true
bottomTextL10n
:
{
id
:
"
firefox
-
suggest
-
mdn
-
bottom
-
text
"
}
}
}
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRustEnabled
"
)
)
{
result
.
payload
.
source
=
"
rust
"
;
result
.
payload
.
provider
=
"
Mdn
"
;
}
else
{
result
.
payload
.
source
=
"
remote
-
settings
"
;
result
.
payload
.
provider
=
"
MDNSuggestions
"
;
}
return
result
;
}
function
makeAmoResult
(
{
source
provider
title
=
"
Amo
Suggestion
"
description
=
"
Amo
description
"
url
=
"
https
:
/
/
example
.
com
/
amo
"
originalUrl
=
"
https
:
/
/
example
.
com
/
amo
"
icon
=
null
setUtmParams
=
true
}
)
{
if
(
setUtmParams
)
{
url
=
new
URL
(
url
)
;
url
.
searchParams
.
set
(
"
utm_medium
"
"
firefox
-
desktop
"
)
;
url
.
searchParams
.
set
(
"
utm_source
"
"
firefox
-
suggest
"
)
;
url
=
url
.
href
;
}
let
result
=
{
isBestMatch
:
true
suggestedIndex
:
1
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
source
provider
title
description
url
originalUrl
icon
displayUrl
:
url
.
replace
(
/
^
https
:
\
/
\
/
/
"
"
)
shouldShowUrl
:
true
bottomTextL10n
:
{
id
:
"
firefox
-
suggest
-
addons
-
recommended
"
}
helpUrl
:
QuickSuggest
.
HELP_URL
telemetryType
:
"
amo
"
}
}
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRustEnabled
"
)
)
{
result
.
payload
.
source
=
source
|
|
"
rust
"
;
result
.
payload
.
provider
=
provider
|
|
"
Amo
"
;
}
else
{
result
.
payload
.
source
=
source
|
|
"
remote
-
settings
"
;
result
.
payload
.
provider
=
provider
|
|
"
AddonSuggestions
"
;
}
return
result
;
}
function
makeWeatherResult
(
{
source
provider
telemetryType
=
undefined
temperatureUnit
=
undefined
}
=
{
}
)
{
if
(
!
temperatureUnit
)
{
temperatureUnit
=
Services
.
locale
.
regionalPrefsLocales
[
0
]
=
=
"
en
-
US
"
?
"
f
"
:
"
c
"
;
}
let
result
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
suggestedIndex
:
1
payload
:
{
temperatureUnit
url
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
url
iconId
:
"
6
"
requestId
:
MerinoTestUtils
.
server
.
response
.
body
.
request_id
source
:
"
merino
"
provider
:
"
accuweather
"
dynamicType
:
"
weather
"
city
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
city_name
temperature
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
current_conditions
.
temperature
[
temperatureUnit
]
currentConditions
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
current_conditions
.
summary
forecast
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
forecast
.
summary
high
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
forecast
.
high
[
temperatureUnit
]
low
:
MerinoTestUtils
.
WEATHER_SUGGESTION
.
forecast
.
low
[
temperatureUnit
]
}
}
;
if
(
UrlbarPrefs
.
get
(
"
quickSuggestRustEnabled
"
)
)
{
result
.
payload
.
source
=
source
|
|
"
rust
"
;
result
.
payload
.
provider
=
provider
|
|
"
Weather
"
;
if
(
telemetryType
!
=
=
null
)
{
result
.
payload
.
telemetryType
=
telemetryType
|
|
"
weather
"
;
}
}
else
{
result
.
payload
.
source
=
source
|
|
"
merino
"
;
result
.
payload
.
provider
=
provider
|
|
"
accuweather
"
;
}
return
result
;
}
async
function
doMigrateTest
(
{
testOverrides
scenario
expectedPrefs
initialUserBranch
=
{
}
}
)
{
info
(
"
Testing
migration
:
"
+
JSON
.
stringify
(
{
testOverrides
initialUserBranch
scenario
expectedPrefs
}
)
)
;
function
setPref
(
branch
name
value
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
branch
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
branch
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
branch
.
setCharPref
(
name
value
)
;
break
;
default
:
Assert
.
ok
(
false
Pref
type
not
handled
for
setPref
:
{
name
}
=
{
value
}
)
;
break
;
}
}
function
getPref
(
branch
name
)
{
let
type
=
typeof
UrlbarPrefs
.
get
(
name
)
;
switch
(
type
)
{
case
"
boolean
"
:
return
branch
.
getBoolPref
(
name
)
;
case
"
number
"
:
return
branch
.
getIntPref
(
name
)
;
case
"
string
"
:
return
branch
.
getCharPref
(
name
)
;
default
:
Assert
.
ok
(
false
Pref
type
not
handled
for
getPref
:
{
name
}
{
type
}
)
;
break
;
}
return
null
;
}
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
browser
.
urlbar
.
"
)
;
let
userBranch
=
Services
.
prefs
.
getBranch
(
"
browser
.
urlbar
.
"
)
;
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
true
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
migrationVersion
"
)
;
let
initialDefaultBranch
=
{
"
suggest
.
quicksuggest
.
nonsponsored
"
:
false
"
suggest
.
quicksuggest
.
sponsored
"
:
false
"
quicksuggest
.
dataCollection
.
enabled
"
:
false
}
;
for
(
let
name
of
Object
.
keys
(
initialDefaultBranch
)
)
{
userBranch
.
clearUserPref
(
name
)
;
}
for
(
let
[
branch
prefs
]
of
[
[
defaultBranch
initialDefaultBranch
]
[
userBranch
initialUserBranch
]
]
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
if
(
value
!
=
=
undefined
)
{
setPref
(
branch
name
value
)
;
}
}
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
false
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
info
(
Calling
updateFirefoxSuggestScenario
i
=
{
i
}
)
;
await
UrlbarPrefs
.
updateFirefoxSuggestScenario
(
{
.
.
.
testOverrides
scenario
isStartup
:
true
}
)
;
let
expectedEffectivePrefs
=
{
}
;
let
{
defaultBranch
:
expectedDefaultBranch
userBranch
:
expectedUserBranch
}
=
expectedPrefs
;
expectedDefaultBranch
=
expectedDefaultBranch
|
|
{
}
;
expectedUserBranch
=
expectedUserBranch
|
|
{
}
;
for
(
let
[
branch
prefs
branchType
]
of
[
[
defaultBranch
expectedDefaultBranch
"
default
"
]
[
userBranch
expectedUserBranch
"
user
"
]
]
)
{
let
entries
=
Object
.
entries
(
prefs
)
;
if
(
!
entries
.
length
)
{
continue
;
}
info
(
Checking
expected
prefs
on
{
branchType
}
branch
after
updating
scenario
)
;
for
(
let
[
name
value
]
of
entries
)
{
expectedEffectivePrefs
[
name
]
=
value
;
if
(
branch
=
=
userBranch
)
{
Assert
.
ok
(
userBranch
.
prefHasUserValue
(
name
)
Pref
{
name
}
is
on
user
branch
)
;
}
Assert
.
equal
(
getPref
(
branch
name
)
value
Pref
{
name
}
value
on
{
branchType
}
branch
)
;
}
}
info
(
Making
sure
prefs
on
the
default
branch
without
expected
user
-
branch
values
are
not
on
the
user
branch
)
;
for
(
let
name
of
Object
.
keys
(
initialDefaultBranch
)
)
{
if
(
!
expectedUserBranch
.
hasOwnProperty
(
name
)
)
{
Assert
.
ok
(
!
userBranch
.
prefHasUserValue
(
name
)
Pref
{
name
}
is
not
on
user
branch
)
;
}
}
info
(
Checking
expected
effective
prefs
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
expectedEffectivePrefs
)
)
{
Assert
.
equal
(
UrlbarPrefs
.
get
(
name
)
value
Pref
{
name
}
effective
value
)
;
}
let
currentVersion
=
testOverrides
?
.
migrationVersion
=
=
=
undefined
?
UrlbarPrefs
.
FIREFOX_SUGGEST_MIGRATION_VERSION
:
testOverrides
.
migrationVersion
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
migrationVersion
"
)
currentVersion
"
quicksuggest
.
migrationVersion
is
correct
after
migration
"
)
;
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
true
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
migrationVersion
"
)
;
let
userBranchNames
=
[
.
.
.
Object
.
keys
(
initialUserBranch
)
.
.
.
Object
.
keys
(
expectedPrefs
.
userBranch
|
|
{
}
)
]
;
for
(
let
name
of
userBranchNames
)
{
userBranch
.
clearUserPref
(
name
)
;
}
UrlbarPrefs
.
_updatingFirefoxSuggestScenario
=
false
;
}
async
function
doShowLessFrequentlyTests
(
{
feature
expectedResult
showLessFrequentlyCountPref
nimbusCapVariable
keyword
keywordBaseIndex
=
keyword
.
indexOf
(
"
"
)
}
)
{
if
(
keywordBaseIndex
<
=
0
)
{
throw
new
Error
(
"
keywordBaseIndex
must
be
>
0
but
it
'
s
"
+
keywordBaseIndex
)
;
}
if
(
keyword
.
length
<
keywordBaseIndex
+
3
)
{
throw
new
Error
(
"
keyword
must
have
at
least
two
chars
after
keywordBaseIndex
"
)
;
}
let
tests
=
[
{
showLessFrequentlyCount
:
0
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
-
1
)
]
:
false
[
keyword
.
substring
(
0
keywordBaseIndex
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
1
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
2
)
]
:
true
[
keyword
.
substring
(
0
keywordBaseIndex
+
3
)
]
:
true
}
}
{
showLessFrequentlyCount
:
1
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
)
]
:
false
}
}
{
showLessFrequentlyCount
:
2
canShowLessFrequently
:
true
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
+
1
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
[
keyword
.
substring
(
0
keywordBaseIndex
+
2
)
]
:
false
}
}
{
showLessFrequentlyCount
:
3
canShowLessFrequently
:
false
newSearches
:
{
}
}
]
;
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
3
}
}
)
;
info
(
"
Testing
'
show
less
frequently
'
with
cap
in
Nimbus
and
remote
settings
"
)
;
await
doOneShowLessFrequentlyTest
(
{
tests
feature
expectedResult
showLessFrequentlyCountPref
rs
:
{
show_less_frequently_cap
:
10
}
nimbus
:
{
[
nimbusCapVariable
]
:
3
}
}
)
;
}
async
function
doOneShowLessFrequentlyTest
(
{
feature
expectedResult
showLessFrequentlyCountPref
tests
rs
=
{
}
nimbus
=
{
}
}
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
false
)
;
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
nimbus
)
;
await
QuickSuggestTestUtils
.
withConfig
(
{
config
:
rs
callback
:
async
(
)
=
>
{
let
cumulativeSearches
=
{
}
;
for
(
let
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
of
tests
)
{
info
(
"
Starting
subtest
:
"
+
JSON
.
stringify
(
{
showLessFrequentlyCount
canShowLessFrequently
newSearches
}
)
)
;
Assert
.
equal
(
feature
.
showLessFrequentlyCount
showLessFrequentlyCount
"
showLessFrequentlyCount
should
be
correct
initially
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
showLessFrequentlyCountPref
)
showLessFrequentlyCount
"
Pref
should
be
correct
initially
"
)
;
Assert
.
equal
(
feature
.
canShowLessFrequently
canShowLessFrequently
"
canShowLessFrequently
should
be
correct
initially
"
)
;
cumulativeSearches
=
{
.
.
.
cumulativeSearches
.
.
.
newSearches
}
;
for
(
let
[
searchString
isExpected
]
of
Object
.
entries
(
cumulativeSearches
)
)
{
info
(
"
Doing
search
:
"
+
JSON
.
stringify
(
{
searchString
isExpected
}
)
)
;
let
results
=
[
]
;
if
(
isExpected
)
{
results
.
push
(
typeof
expectedResult
=
=
"
function
"
?
expectedResult
(
searchString
)
:
expectedResult
)
;
}
await
check_results
(
{
context
:
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
results
}
)
;
}
feature
.
incrementShowLessFrequentlyCount
(
)
;
}
}
}
)
;
await
cleanUpNimbus
(
)
;
UrlbarPrefs
.
clear
(
showLessFrequentlyCountPref
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
true
)
;
}
async
function
doRustProvidersTests
(
{
searchString
tests
}
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
for
(
let
{
prefs
expectedUrls
}
of
tests
)
{
info
(
"
Starting
Rust
providers
test
:
"
+
JSON
.
stringify
(
{
prefs
expectedUrls
}
)
)
;
info
(
"
Setting
prefs
and
forcing
sync
"
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
prefs
)
)
{
UrlbarPrefs
.
set
(
name
value
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
info
(
"
Querying
with
search
string
:
"
+
JSON
.
stringify
(
searchString
)
)
;
let
suggestions
=
await
QuickSuggest
.
rustBackend
.
query
(
searchString
)
;
info
(
"
Got
suggestions
:
"
+
JSON
.
stringify
(
suggestions
)
)
;
Assert
.
deepEqual
(
suggestions
.
map
(
s
=
>
s
.
url
)
.
sort
(
)
expectedUrls
.
sort
(
)
"
query
(
)
should
return
the
expected
suggestions
(
by
URL
)
"
)
;
info
(
"
Clearing
prefs
and
forcing
sync
"
)
;
for
(
let
name
of
Object
.
keys
(
prefs
)
)
{
UrlbarPrefs
.
clear
(
name
)
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
info
(
"
Clearing
rustEnabled
pref
and
forcing
sync
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
}
async
function
waitForNewWeatherFetch
(
)
{
let
{
fetchPromise
:
oldFetchPromise
}
=
QuickSuggest
.
weather
;
let
newFetchPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
{
fetchPromise
}
=
QuickSuggest
.
weather
;
if
(
(
oldFetchPromise
&
&
fetchPromise
!
=
oldFetchPromise
)
|
|
(
!
oldFetchPromise
&
&
fetchPromise
)
)
{
newFetchPromise
=
fetchPromise
;
return
true
;
}
return
false
;
}
"
Waiting
for
a
new
weather
fetch
to
start
"
)
;
Assert
.
equal
(
QuickSuggest
.
weather
.
fetchPromise
newFetchPromise
"
Sanity
check
:
fetchPromise
hasn
'
t
changed
since
waitForCondition
returned
"
)
;
await
newFetchPromise
;
}
