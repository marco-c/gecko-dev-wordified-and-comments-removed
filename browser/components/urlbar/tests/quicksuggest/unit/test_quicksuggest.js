"
use
strict
"
;
const
TELEMETRY_REMOTE_SETTINGS_LATENCY
=
"
FX_URLBAR_QUICK_SUGGEST_REMOTE_SETTINGS_LATENCY_MS
"
;
const
SPONSORED_SEARCH_STRING
=
"
frab
"
;
const
NONSPONSORED_SEARCH_STRING
=
"
nonspon
"
;
const
HTTP_SEARCH_STRING
=
"
http
prefix
"
;
const
HTTPS_SEARCH_STRING
=
"
https
prefix
"
;
const
PREFIX_SUGGESTIONS_STRIPPED_URL
=
"
example
.
com
/
prefix
-
test
"
;
const
{
TIMESTAMP_TEMPLATE
TIMESTAMP_LENGTH
}
=
QuickSuggest
;
const
TIMESTAMP_SEARCH_STRING
=
"
timestamp
"
;
const
TIMESTAMP_SUGGESTION_URL
=
http
:
/
/
example
.
com
/
timestamp
-
{
TIMESTAMP_TEMPLATE
}
;
const
TIMESTAMP_SUGGESTION_CLICK_URL
=
http
:
/
/
click
.
reporting
.
test
.
com
/
timestamp
-
{
TIMESTAMP_TEMPLATE
}
-
foo
;
const
REMOTE_SETTINGS_RESULTS
=
[
{
id
:
1
url
:
"
http
:
/
/
test
.
com
/
q
=
frabbits
"
title
:
"
frabbits
"
keywords
:
[
SPONSORED_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
"
advertiser
:
"
TestAdvertiser
"
iab_category
:
"
22
-
Shopping
"
}
{
id
:
2
url
:
"
http
:
/
/
test
.
com
/
?
q
=
nonsponsored
"
title
:
"
Non
-
Sponsored
"
keywords
:
[
NONSPONSORED_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
nonsponsored
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
nonsponsored
"
advertiser
:
"
TestAdvertiserNonSponsored
"
iab_category
:
"
5
-
Education
"
}
{
id
:
3
url
:
"
http
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
title
:
"
http
suggestion
"
keywords
:
[
HTTP_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
prefix
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
prefix
"
advertiser
:
"
TestAdvertiserPrefix
"
iab_category
:
"
22
-
Shopping
"
}
{
id
:
4
url
:
"
https
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
title
:
"
https
suggestion
"
keywords
:
[
HTTPS_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
prefix
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
prefix
"
advertiser
:
"
TestAdvertiserPrefix
"
iab_category
:
"
22
-
Shopping
"
}
{
id
:
5
url
:
TIMESTAMP_SUGGESTION_URL
title
:
"
Timestamp
suggestion
"
keywords
:
[
TIMESTAMP_SEARCH_STRING
]
click_url
:
TIMESTAMP_SUGGESTION_CLICK_URL
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
timestamp
"
advertiser
:
"
TestAdvertiserTimestamp
"
iab_category
:
"
22
-
Shopping
"
}
]
;
const
EXPECTED_SPONSORED_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
telemetryType
:
"
adm_sponsored
"
qsSuggestion
:
"
frab
"
title
:
"
frabbits
"
url
:
"
http
:
/
/
test
.
com
/
q
=
frabbits
"
originalUrl
:
"
http
:
/
/
test
.
com
/
q
=
frabbits
"
icon
:
null
sponsoredImpressionUrl
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
"
sponsoredClickUrl
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
"
sponsoredBlockId
:
1
sponsoredAdvertiser
:
"
TestAdvertiser
"
sponsoredIabCategory
:
"
22
-
Shopping
"
isSponsored
:
true
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
UrlbarPrefs
.
get
(
"
quickSuggestBlockingEnabled
"
)
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
displayUrl
:
"
http
:
/
/
test
.
com
/
q
=
frabbits
"
source
:
"
remote
-
settings
"
}
}
;
const
EXPECTED_NONSPONSORED_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
telemetryType
:
"
adm_nonsponsored
"
qsSuggestion
:
"
nonspon
"
title
:
"
Non
-
Sponsored
"
url
:
"
http
:
/
/
test
.
com
/
?
q
=
nonsponsored
"
originalUrl
:
"
http
:
/
/
test
.
com
/
?
q
=
nonsponsored
"
icon
:
null
sponsoredImpressionUrl
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
nonsponsored
"
sponsoredClickUrl
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
nonsponsored
"
sponsoredBlockId
:
2
sponsoredAdvertiser
:
"
TestAdvertiserNonSponsored
"
sponsoredIabCategory
:
"
5
-
Education
"
isSponsored
:
false
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
UrlbarPrefs
.
get
(
"
quickSuggestBlockingEnabled
"
)
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
displayUrl
:
"
http
:
/
/
test
.
com
/
?
q
=
nonsponsored
"
source
:
"
remote
-
settings
"
}
}
;
const
EXPECTED_HTTP_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
telemetryType
:
"
adm_sponsored
"
qsSuggestion
:
HTTP_SEARCH_STRING
title
:
"
http
suggestion
"
url
:
"
http
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
originalUrl
:
"
http
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
icon
:
null
sponsoredImpressionUrl
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
prefix
"
sponsoredClickUrl
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
prefix
"
sponsoredBlockId
:
3
sponsoredAdvertiser
:
"
TestAdvertiserPrefix
"
sponsoredIabCategory
:
"
22
-
Shopping
"
isSponsored
:
true
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
UrlbarPrefs
.
get
(
"
quickSuggestBlockingEnabled
"
)
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
displayUrl
:
"
http
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
source
:
"
remote
-
settings
"
}
}
;
const
EXPECTED_HTTPS_RESULT
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
telemetryType
:
"
adm_sponsored
"
qsSuggestion
:
HTTPS_SEARCH_STRING
title
:
"
https
suggestion
"
url
:
"
https
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
originalUrl
:
"
https
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
icon
:
null
sponsoredImpressionUrl
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
prefix
"
sponsoredClickUrl
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
prefix
"
sponsoredBlockId
:
4
sponsoredAdvertiser
:
"
TestAdvertiserPrefix
"
sponsoredIabCategory
:
"
22
-
Shopping
"
isSponsored
:
true
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
UrlbarPrefs
.
get
(
"
quickSuggestBlockingEnabled
"
)
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
displayUrl
:
PREFIX_SUGGESTIONS_STRIPPED_URL
source
:
"
remote
-
settings
"
}
}
;
let
cleanUpQuickSuggest
;
add_task
(
async
function
init
(
)
{
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
shouldShowOnboardingDialog
"
false
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
remoteSettings
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
merino
.
enabled
"
false
)
;
let
engine
=
await
addTestSuggestionsEngine
(
)
;
await
Services
.
search
.
setDefault
(
engine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
cleanUpQuickSuggest
=
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsResults
:
REMOTE_SETTINGS_RESULTS
}
)
;
}
)
;
add_task
(
async
function
nonsponsoredOnly_match
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_NONSPONSORED_RESULT
]
}
)
;
}
)
;
add_task
(
async
function
nonsponsoredOnly_noMatch
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_task
(
async
function
sponsoredOnly_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_SPONSORED_RESULT
]
}
)
;
}
)
;
add_task
(
async
function
sponsoredOnly_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_task
(
async
function
both_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_SPONSORED_RESULT
]
}
)
;
}
)
;
add_task
(
async
function
both_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_NONSPONSORED_RESULT
]
}
)
;
}
)
;
add_task
(
async
function
both_noMatch
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
context
=
createContext
(
"
this
doesn
'
t
match
anything
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_task
(
async
function
neither_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_task
(
async
function
neither_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_task
(
async
function
caseInsensitiveAndLeadingSpaces
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
context
=
createContext
(
"
"
+
SPONSORED_SEARCH_STRING
.
toUpperCase
(
)
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_SPONSORED_RESULT
]
}
)
;
}
)
;
add_task
(
async
function
emptySearchStringsAndSpaces
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
searchStrings
=
[
"
"
"
"
"
"
"
"
]
;
for
(
let
str
of
searchStrings
)
{
let
msg
=
JSON
.
stringify
(
str
)
+
(
length
=
{
str
.
length
}
)
;
info
(
"
Testing
search
string
:
"
+
msg
)
;
let
context
=
createContext
(
str
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
isActive
(
context
)
"
Provider
should
not
be
active
for
search
string
:
"
+
msg
)
;
}
}
)
;
add_task
(
async
function
browser_search_suggest_enabled
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_SPONSORED_RESULT
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
}
)
;
add_task
(
async
function
browser_search_suggest_enabled
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_SPONSORED_RESULT
]
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
}
)
;
add_task
(
async
function
privateContext
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
for
(
let
privateSuggestionsEnabled
of
[
true
false
]
)
{
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
.
private
"
privateSuggestionsEnabled
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
true
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
.
private
"
)
;
}
)
;
add_task
(
async
function
suggestionsBeforeGeneral_only
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
true
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
EXPECTED_SPONSORED_RESULT
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
}
)
;
add_task
(
async
function
suggestionsBeforeGeneral_others
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
true
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
historyResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResults
;
i
+
+
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
+
SPONSORED_SEARCH_STRING
+
i
;
historyResults
.
push
(
makeVisitResult
(
context
{
uri
:
url
title
:
"
test
visit
for
"
+
url
}
)
)
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
}
historyResults
=
historyResults
.
reverse
(
)
.
slice
(
0
historyResults
.
length
-
4
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
.
.
.
historyResults
EXPECTED_SPONSORED_RESULT
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
generalBeforeSuggestions_only
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
false
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
EXPECTED_SPONSORED_RESULT
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
}
)
;
add_task
(
async
function
generalBeforeSuggestions_others
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
false
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
historyResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResults
;
i
+
+
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
+
SPONSORED_SEARCH_STRING
+
i
;
historyResults
.
push
(
makeVisitResult
(
context
{
uri
:
url
title
:
"
test
visit
for
"
+
url
}
)
)
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
}
historyResults
=
historyResults
.
reverse
(
)
.
slice
(
0
historyResults
.
length
-
4
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
.
.
.
historyResults
EXPECTED_SPONSORED_RESULT
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
dedupeAgainstURL_samePrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTP_SEARCH_STRING
expectedQuickSuggestResult
:
EXPECTED_HTTP_RESULT
otherPrefix
:
"
http
:
/
/
"
expectOther
:
false
}
)
;
}
)
;
add_task
(
async
function
dedupeAgainstURL_higherPrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTPS_SEARCH_STRING
expectedQuickSuggestResult
:
EXPECTED_HTTPS_RESULT
otherPrefix
:
"
http
:
/
/
"
expectOther
:
false
}
)
;
}
)
;
add_task
(
async
function
dedupeAgainstURL_lowerPrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTP_SEARCH_STRING
expectedQuickSuggestResult
:
EXPECTED_HTTP_RESULT
otherPrefix
:
"
https
:
/
/
"
expectOther
:
true
}
)
;
}
)
;
async
function
doDedupeAgainstURLTest
(
{
searchString
expectedQuickSuggestResult
otherPrefix
expectOther
}
)
{
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
let
otherURL
=
otherPrefix
+
PREFIX_SUGGESTIONS_STRIPPED_URL
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
otherURL
title
:
searchString
}
)
;
info
(
"
Doing
first
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
searchString
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
searchString
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeVisitResult
(
context
{
uri
:
otherURL
title
:
searchString
}
)
]
}
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
context
=
createContext
(
searchString
{
isPrivate
:
false
}
)
;
let
expectedResults
=
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
searchString
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
;
if
(
expectOther
)
{
expectedResults
.
push
(
makeVisitResult
(
context
{
uri
:
otherURL
title
:
searchString
}
)
)
;
}
expectedResults
.
push
(
expectedQuickSuggestResult
)
;
info
(
"
Doing
second
query
"
)
;
await
check_results
(
{
context
matches
:
expectedResults
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
add_task
(
async
function
latencyTelemetry
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
)
;
histogram
.
clear
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
EXPECTED_SPONSORED_RESULT
]
}
)
;
Assert
.
deepEqual
(
Object
.
values
(
histogram
.
snapshot
(
)
.
values
)
.
filter
(
v
=
>
v
>
0
)
[
1
]
"
Latency
histogram
updated
after
search
"
)
;
Assert
.
ok
(
!
TelemetryStopwatch
.
running
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
context
)
"
Stopwatch
not
running
after
search
"
)
;
}
)
;
add_task
(
async
function
setupAndTeardown
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
!
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
is
null
after
disabling
suggest
prefs
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
!
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
is
null
after
disabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
remains
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
remains
non
-
null
after
disabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
!
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
is
null
after
disabling
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
false
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
!
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
is
null
after
disabling
quicksuggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
Assert
.
ok
(
!
QuickSuggest
.
remoteSettings
.
_test_rs
"
Settings
client
remains
null
at
end
of
task
"
)
;
}
)
;
add_task
(
async
function
timestamps
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
let
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
{
input
:
{
isPrivate
:
context
.
isPrivate
onFirstResult
(
)
{
return
false
;
}
getSearchSource
(
)
{
return
"
dummy
-
search
-
source
"
;
}
window
:
{
location
:
{
href
:
AppConstants
.
BROWSER_CHROME_URL
}
}
}
}
)
;
await
controller
.
startQuery
(
context
)
;
Assert
.
equal
(
context
.
results
.
length
1
"
One
result
returned
"
)
;
let
result
=
context
.
results
[
0
]
;
QuickSuggestTestUtils
.
assertTimestampsReplaced
(
result
{
url
:
TIMESTAMP_SUGGESTION_URL
sponsoredClickUrl
:
TIMESTAMP_SUGGESTION_CLICK_URL
}
)
;
}
)
;
add_task
(
async
function
dedupeAgainstURL_timestamps
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
let
dupeURL
=
TIMESTAMP_SUGGESTION_URL
.
replace
(
TIMESTAMP_TEMPLATE
"
2013051113
"
)
;
let
badTimestamps
=
[
"
x
"
.
repeat
(
TIMESTAMP_LENGTH
)
"
5
"
.
repeat
(
TIMESTAMP_LENGTH
-
1
)
"
"
]
;
let
badTimestampURLs
=
badTimestamps
.
map
(
str
=
>
TIMESTAMP_SUGGESTION_URL
.
replace
(
TIMESTAMP_TEMPLATE
str
)
)
;
await
PlacesTestUtils
.
addVisits
(
[
dupeURL
.
.
.
badTimestampURLs
]
.
map
(
uri
=
>
(
{
uri
title
:
TIMESTAMP_SEARCH_STRING
}
)
)
)
;
info
(
"
Doing
first
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
expectedHeuristic
=
makeSearchResult
(
context
{
heuristic
:
true
query
:
TIMESTAMP_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
;
let
expectedDupeResult
=
makeVisitResult
(
context
{
uri
:
dupeURL
title
:
TIMESTAMP_SEARCH_STRING
}
)
;
let
expectedBadTimestampResults
=
[
.
.
.
badTimestampURLs
]
.
reverse
(
)
.
map
(
uri
=
>
makeVisitResult
(
context
{
uri
title
:
TIMESTAMP_SEARCH_STRING
}
)
)
;
await
check_results
(
{
context
matches
:
[
expectedHeuristic
.
.
.
expectedBadTimestampResults
expectedDupeResult
]
}
)
;
info
(
"
Doing
second
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
expectedQuickSuggest
=
{
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
telemetryType
:
"
adm_sponsored
"
originalUrl
:
TIMESTAMP_SUGGESTION_URL
qsSuggestion
:
TIMESTAMP_SEARCH_STRING
title
:
"
Timestamp
suggestion
"
icon
:
null
sponsoredImpressionUrl
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
timestamp
"
sponsoredBlockId
:
5
sponsoredAdvertiser
:
"
TestAdvertiserTimestamp
"
sponsoredIabCategory
:
"
22
-
Shopping
"
isSponsored
:
true
helpUrl
:
QuickSuggest
.
HELP_URL
helpL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
learn
-
more
-
about
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
learn
-
more
"
}
isBlockable
:
UrlbarPrefs
.
get
(
"
quickSuggestBlockingEnabled
"
)
blockL10n
:
{
id
:
UrlbarPrefs
.
get
(
"
resultMenu
"
)
?
"
urlbar
-
result
-
menu
-
dismiss
-
firefox
-
suggest
"
:
"
firefox
-
suggest
-
urlbar
-
block
"
}
source
:
"
remote
-
settings
"
}
}
;
let
expectedResults
=
[
expectedHeuristic
.
.
.
expectedBadTimestampResults
expectedQuickSuggest
]
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
{
input
:
{
isPrivate
:
false
onFirstResult
(
)
{
return
false
;
}
getSearchSource
(
)
{
return
"
dummy
-
search
-
source
"
;
}
window
:
{
location
:
{
href
:
AppConstants
.
BROWSER_CHROME_URL
}
}
}
}
)
;
await
controller
.
startQuery
(
context
)
;
info
(
"
Actual
results
:
"
+
JSON
.
stringify
(
context
.
results
)
)
;
Assert
.
equal
(
context
.
results
.
length
expectedResults
.
length
"
Found
the
expected
number
of
results
"
)
;
function
getPayload
(
result
keysToIgnore
=
[
]
)
{
let
payload
=
{
}
;
for
(
let
[
key
value
]
of
Object
.
entries
(
result
.
payload
)
)
{
if
(
value
!
=
=
undefined
&
&
!
keysToIgnore
.
includes
(
key
)
)
{
payload
[
key
]
=
value
;
}
}
return
payload
;
}
for
(
let
i
=
0
;
i
<
expectedResults
.
length
;
i
+
+
)
{
let
actual
=
context
.
results
[
i
]
;
let
expected
=
expectedResults
[
i
]
;
info
(
Comparing
results
at
index
{
i
}
:
+
"
actual
=
"
+
JSON
.
stringify
(
actual
)
+
"
expected
=
"
+
JSON
.
stringify
(
expected
)
)
;
Assert
.
equal
(
actual
.
type
expected
.
type
result
.
type
at
result
index
{
i
}
)
;
Assert
.
equal
(
actual
.
source
expected
.
source
result
.
source
at
result
index
{
i
}
)
;
Assert
.
equal
(
actual
.
heuristic
expected
.
heuristic
result
.
heuristic
at
result
index
{
i
}
)
;
if
(
i
!
=
expectedResults
.
length
-
1
)
{
Assert
.
deepEqual
(
getPayload
(
context
.
results
[
i
]
)
getPayload
(
expectedResults
[
i
]
)
"
Payload
at
index
"
+
i
)
;
}
}
let
actualQuickSuggest
=
context
.
results
[
context
.
results
.
length
-
1
]
;
let
timestampKeys
=
[
"
displayUrl
"
"
sponsoredClickUrl
"
"
url
"
"
urlTimestampIndex
"
]
;
Assert
.
deepEqual
(
getPayload
(
actualQuickSuggest
timestampKeys
)
getPayload
(
expectedQuickSuggest
timestampKeys
)
"
Quick
suggest
payload
excluding
timestamp
-
related
keys
"
)
;
QuickSuggestTestUtils
.
assertTimestampsReplaced
(
actualQuickSuggest
{
url
:
TIMESTAMP_SUGGESTION_URL
sponsoredClickUrl
:
TIMESTAMP_SUGGESTION_CLICK_URL
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
blockedSuggestionsAPI
(
)
{
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
empty
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
"
"
"
quicksuggest
.
blockedDigests
is
an
empty
string
"
)
;
let
urls
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
urls
.
push
(
"
http
:
/
/
example
.
com
/
"
+
i
)
;
}
for
(
let
i
=
0
;
i
<
urls
.
length
;
i
+
+
)
{
await
QuickSuggest
.
blockedSuggestions
.
add
(
urls
[
i
]
)
;
for
(
let
j
=
0
;
j
<
urls
.
length
;
j
+
+
)
{
Assert
.
equal
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
urls
[
j
]
)
j
<
=
i
Suggestion
at
index
{
j
}
is
blocked
or
not
as
expected
)
;
}
}
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
let
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
Assert
.
ok
(
Array
.
isArray
(
array
)
"
Parsed
value
of
pref
is
an
array
"
)
;
Assert
.
equal
(
array
.
length
urls
.
length
"
Array
has
correct
length
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
blockedDigests
"
"
not
a
json
array
"
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
remains
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
still
has
correct
size
"
)
;
let
newURL
=
"
http
:
/
/
example
.
com
/
new
-
block
"
;
await
QuickSuggest
.
blockedSuggestions
.
add
(
newURL
)
;
urls
.
push
(
newURL
)
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
Assert
.
ok
(
Array
.
isArray
(
array
)
"
Parsed
value
of
pref
is
an
array
"
)
;
Assert
.
equal
(
array
.
length
urls
.
length
"
Array
has
correct
length
"
)
;
newURL
=
"
http
:
/
/
example
.
com
/
direct
-
to
-
pref
"
;
urls
.
push
(
newURL
)
;
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
array
.
push
(
await
QuickSuggest
.
blockedSuggestions
.
_test_getDigest
(
newURL
)
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
blockedDigests
"
JSON
.
stringify
(
array
)
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
blockedDigests
"
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
!
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
)
Suggestion
is
no
longer
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
now
empty
"
)
;
for
(
let
url
of
urls
)
{
await
QuickSuggest
.
blockedSuggestions
.
add
(
url
)
;
}
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
!
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
)
Suggestion
is
no
longer
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
now
empty
"
)
;
}
)
;
add_task
(
async
function
block
(
)
{
for
(
const
result
of
REMOTE_SETTINGS_RESULTS
)
{
await
QuickSuggest
.
blockedSuggestions
.
add
(
result
.
url
)
;
}
for
(
const
result
of
REMOTE_SETTINGS_RESULTS
)
{
const
context
=
createContext
(
result
.
keywords
[
0
]
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
}
)
;
add_task
(
async
function
remoteSettingsDataType
(
)
{
await
cleanUpQuickSuggest
(
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
spy
=
sandbox
.
spy
(
QuickSuggest
.
remoteSettings
.
_test_rs
"
get
"
)
;
for
(
let
dataType
of
[
undefined
"
test
-
data
-
type
"
]
)
{
let
value
=
{
}
;
if
(
dataType
)
{
value
.
quickSuggestRemoteSettingsDataType
=
dataType
;
}
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
value
)
;
await
QuickSuggest
.
remoteSettings
.
enable
(
false
)
;
await
QuickSuggest
.
remoteSettings
.
enable
(
true
)
;
await
QuickSuggest
.
remoteSettings
.
readyPromise
;
let
expectedDataType
=
dataType
|
|
"
data
"
;
Assert
.
ok
(
spy
.
calledWith
(
{
filters
:
{
type
:
expectedDataType
}
}
)
"
#
rs
.
get
(
)
called
with
expected
data
type
:
"
+
expectedDataType
)
;
spy
.
resetHistory
(
)
;
await
cleanUpNimbus
(
)
;
}
sandbox
.
restore
(
)
;
cleanUpQuickSuggest
=
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
REMOTE_SETTINGS_RESULTS
)
;
}
)
;
