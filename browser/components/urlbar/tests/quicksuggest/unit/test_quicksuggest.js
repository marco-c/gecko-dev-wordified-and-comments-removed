"
use
strict
"
;
const
TELEMETRY_REMOTE_SETTINGS_LATENCY
=
"
FX_URLBAR_QUICK_SUGGEST_REMOTE_SETTINGS_LATENCY_MS
"
;
const
SPONSORED_SEARCH_STRING
=
"
amp
"
;
const
NONSPONSORED_SEARCH_STRING
=
"
wikipedia
"
;
const
SPONSORED_AND_NONSPONSORED_SEARCH_STRING
=
"
sponsored
and
non
-
sponsored
"
;
const
HTTP_SEARCH_STRING
=
"
http
prefix
"
;
const
HTTPS_SEARCH_STRING
=
"
https
prefix
"
;
const
PREFIX_SUGGESTIONS_STRIPPED_URL
=
"
example
.
com
/
prefix
-
test
"
;
const
ONE_CHAR_SEARCH_STRINGS
=
[
"
x
"
"
x
"
"
x
"
"
x
"
]
;
const
{
TIMESTAMP_TEMPLATE
TIMESTAMP_LENGTH
}
=
QuickSuggest
;
const
TIMESTAMP_SEARCH_STRING
=
"
timestamp
"
;
const
TIMESTAMP_SUGGESTION_URL
=
http
:
/
/
example
.
com
/
timestamp
-
{
TIMESTAMP_TEMPLATE
}
;
const
TIMESTAMP_SUGGESTION_CLICK_URL
=
http
:
/
/
click
.
reporting
.
test
.
com
/
timestamp
-
{
TIMESTAMP_TEMPLATE
}
-
foo
;
const
REMOTE_SETTINGS_RESULTS
=
[
QuickSuggestTestUtils
.
ampRemoteSettings
(
{
keywords
:
[
SPONSORED_SEARCH_STRING
SPONSORED_AND_NONSPONSORED_SEARCH_STRING
]
}
)
QuickSuggestTestUtils
.
wikipediaRemoteSettings
(
{
keywords
:
[
NONSPONSORED_SEARCH_STRING
SPONSORED_AND_NONSPONSORED_SEARCH_STRING
]
}
)
{
id
:
3
url
:
"
http
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
title
:
"
HTTP
Suggestion
"
keywords
:
[
HTTP_SEARCH_STRING
]
click_url
:
"
http
:
/
/
example
.
com
/
http
-
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
http
-
impression
"
advertiser
:
"
HttpAdvertiser
"
iab_category
:
"
22
-
Shopping
"
icon
:
"
1234
"
}
{
id
:
4
url
:
"
https
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
title
:
"
https
suggestion
"
keywords
:
[
HTTPS_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
prefix
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
prefix
"
advertiser
:
"
TestAdvertiserPrefix
"
iab_category
:
"
22
-
Shopping
"
icon
:
"
1234
"
}
{
id
:
5
url
:
TIMESTAMP_SUGGESTION_URL
title
:
"
Timestamp
suggestion
"
keywords
:
[
TIMESTAMP_SEARCH_STRING
]
click_url
:
TIMESTAMP_SUGGESTION_CLICK_URL
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
timestamp
"
advertiser
:
"
TestAdvertiserTimestamp
"
iab_category
:
"
22
-
Shopping
"
icon
:
"
1234
"
}
QuickSuggestTestUtils
.
ampRemoteSettings
(
{
keywords
:
[
.
.
.
ONE_CHAR_SEARCH_STRINGS
"
12
"
"
a
longer
keyword
"
]
title
:
"
Suggestion
with
1
-
char
keyword
"
url
:
"
http
:
/
/
example
.
com
/
1
-
char
-
keyword
"
}
)
QuickSuggestTestUtils
.
ampRemoteSettings
(
{
keywords
:
[
"
amp
full
key
"
"
amp
full
keyw
"
"
amp
full
keywo
"
"
amp
full
keywor
"
"
amp
full
keyword
"
"
xyz
"
]
title
:
"
AMP
suggestion
with
full
keyword
and
prefix
keywords
"
url
:
"
https
:
/
/
example
.
com
/
amp
-
full
-
keyword
"
}
)
QuickSuggestTestUtils
.
wikipediaRemoteSettings
(
{
keywords
:
[
"
wikipedia
full
key
"
"
wikipedia
full
keyw
"
"
wikipedia
full
keywo
"
"
wikipedia
full
keywor
"
"
wikipedia
full
keyword
"
]
title
:
"
Wikipedia
suggestion
with
full
keyword
and
prefix
keywords
"
url
:
"
https
:
/
/
example
.
com
/
wikipedia
-
full
-
keyword
"
}
)
]
;
let
gMaxResultsSuggestionsCount
;
function
expectedSponsoredPriorityResult
(
)
{
return
{
.
.
.
QuickSuggestTestUtils
.
ampResult
(
)
isBestMatch
:
true
suggestedIndex
:
1
isSuggestedIndexRelativeToGroup
:
false
}
;
}
function
expectedHttpResult
(
)
{
let
suggestion
=
REMOTE_SETTINGS_RESULTS
[
2
]
;
return
QuickSuggestTestUtils
.
ampResult
(
{
keyword
:
HTTP_SEARCH_STRING
title
:
suggestion
.
title
url
:
suggestion
.
url
originalUrl
:
suggestion
.
url
impressionUrl
:
suggestion
.
impression_url
clickUrl
:
suggestion
.
click_url
blockId
:
suggestion
.
id
advertiser
:
suggestion
.
advertiser
}
)
;
}
function
expectedHttpsResult
(
)
{
let
suggestion
=
REMOTE_SETTINGS_RESULTS
[
3
]
;
return
QuickSuggestTestUtils
.
ampResult
(
{
keyword
:
HTTPS_SEARCH_STRING
title
:
suggestion
.
title
url
:
suggestion
.
url
originalUrl
:
suggestion
.
url
impressionUrl
:
suggestion
.
impression_url
clickUrl
:
suggestion
.
click_url
blockId
:
suggestion
.
id
advertiser
:
suggestion
.
advertiser
}
)
;
}
add_setup
(
async
function
init
(
)
{
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
Assert
.
greater
(
maxResults
0
"
This
test
expects
maxRichResults
to
be
>
0
"
)
;
gMaxResultsSuggestionsCount
=
2
*
maxResults
;
for
(
let
i
=
0
;
i
<
gMaxResultsSuggestionsCount
;
i
+
+
)
{
REMOTE_SETTINGS_RESULTS
.
push
(
QuickSuggestTestUtils
.
ampRemoteSettings
(
{
keywords
:
[
"
maxresults
"
]
title
:
"
maxresults
"
+
i
url
:
"
https
:
/
/
example
.
com
/
maxresults
/
"
+
i
}
)
)
;
}
let
engine
=
await
addTestSuggestionsEngine
(
)
;
await
Services
.
search
.
setDefault
(
engine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
const
testDataTypeResults
=
[
Object
.
assign
(
{
}
REMOTE_SETTINGS_RESULTS
[
0
]
{
title
:
"
test
-
data
-
type
"
}
)
]
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsRecords
:
[
{
type
:
"
data
"
attachment
:
REMOTE_SETTINGS_RESULTS
}
{
type
:
"
test
-
data
-
type
"
attachment
:
testDataTypeResults
}
]
}
)
;
}
)
;
add_task
(
async
function
telemetryType_sponsored
(
)
{
Assert
.
equal
(
QuickSuggest
.
getFeature
(
"
AdmWikipedia
"
)
.
getSuggestionTelemetryType
(
{
is_sponsored
:
true
}
)
"
adm_sponsored
"
"
Telemetry
type
should
be
'
adm_sponsored
'
"
)
;
}
)
;
add_task
(
async
function
telemetryType_nonsponsored
(
)
{
Assert
.
equal
(
QuickSuggest
.
getFeature
(
"
AdmWikipedia
"
)
.
getSuggestionTelemetryType
(
{
is_sponsored
:
false
}
)
"
adm_nonsponsored
"
"
Telemetry
type
should
be
'
adm_nonsponsored
'
"
)
;
Assert
.
equal
(
QuickSuggest
.
getFeature
(
"
AdmWikipedia
"
)
.
getSuggestionTelemetryType
(
{
}
)
"
adm_nonsponsored
"
"
Telemetry
type
should
be
'
adm_nonsponsored
'
if
is_sponsored
not
defined
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
nonsponsoredOnly_match
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
wikipediaResult
(
)
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
{
NONSPONSORED_SEARCH_STRING
}
Wikipedia
Suggestion
"
result
.
title
should
be
correct
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
]
"
result
.
titleHighlights
should
be
correct
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
nonsponsoredOnly_noMatch
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredOnly_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
ampResult
(
)
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
{
SPONSORED_SEARCH_STRING
}
Amp
Suggestion
"
result
.
title
should
be
correct
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
]
"
result
.
titleHighlights
should
be
correct
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredOnly_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
both_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
ampResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
both_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
wikipediaResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
both_noMatch
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
"
this
doesn
'
t
match
anything
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
neither_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
neither_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
caseInsensitiveAndLeadingSpaces
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
"
"
+
SPONSORED_SEARCH_STRING
.
toUpperCase
(
)
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
ampResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
emptySearchStringsAndSpaces
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
searchStrings
=
[
"
"
"
"
"
"
"
"
]
;
for
(
let
str
of
searchStrings
)
{
let
msg
=
JSON
.
stringify
(
str
)
+
(
length
=
{
str
.
length
}
)
;
info
(
"
Testing
search
string
:
"
+
msg
)
;
let
context
=
createContext
(
str
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
isActive
(
context
)
"
Provider
should
not
be
active
for
search
string
:
"
+
msg
)
;
}
}
)
;
add_tasks_with_rust
(
async
function
browser_search_suggest_disabled
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
ampResult
(
{
suggestedIndex
:
-
1
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
browser_suggest_searches_disabled
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
ampResult
(
{
suggestedIndex
:
-
1
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
privateContext
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
for
(
let
privateSuggestionsEnabled
of
[
true
false
]
)
{
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
.
private
"
privateSuggestionsEnabled
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
true
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
.
private
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
suggestionsBeforeGeneral_only
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
QuickSuggestTestUtils
.
ampResult
(
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
suggestionsBeforeGeneral_others
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
historyResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResults
;
i
+
+
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
+
SPONSORED_SEARCH_STRING
+
i
;
historyResults
.
push
(
makeVisitResult
(
context
{
uri
:
url
title
:
"
test
visit
for
"
+
url
}
)
)
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
}
historyResults
=
historyResults
.
reverse
(
)
.
slice
(
0
historyResults
.
length
-
4
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
QuickSuggestTestUtils
.
ampResult
(
)
.
.
.
historyResults
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_tasks_with_rust
(
async
function
generalBeforeSuggestions_only
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
QuickSuggestTestUtils
.
ampResult
(
{
suggestedIndex
:
-
1
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
generalBeforeSuggestions_others
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
historyResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResults
;
i
+
+
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
+
SPONSORED_SEARCH_STRING
+
i
;
historyResults
.
push
(
makeVisitResult
(
context
{
uri
:
url
title
:
"
test
visit
for
"
+
url
}
)
)
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
}
historyResults
=
historyResults
.
reverse
(
)
.
slice
(
0
historyResults
.
length
-
4
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
.
.
.
historyResults
QuickSuggestTestUtils
.
ampResult
(
{
suggestedIndex
:
-
1
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_tasks_with_rust
(
async
function
maxResults
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
searchString
=
"
maxresults
"
;
let
suggestions
=
await
QuickSuggest
.
backend
.
query
(
searchString
)
;
Assert
.
equal
(
suggestions
.
length
gMaxResultsSuggestionsCount
"
The
backend
should
return
all
matching
suggestions
"
)
;
let
context
=
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
muxerName
=
context
.
muxer
|
|
"
UnifiedComplete
"
;
let
muxer
=
UrlbarProvidersManager
.
muxers
.
get
(
muxerName
)
;
Assert
.
ok
(
!
!
muxer
"
Muxer
should
exist
"
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
spy
=
sandbox
.
spy
(
muxer
"
sort
"
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
ampResult
(
{
keyword
:
"
maxresults
"
title
:
"
maxresults
0
"
url
:
"
https
:
/
/
example
.
com
/
maxresults
/
0
"
}
)
]
}
)
;
let
calls
=
spy
.
getCalls
(
)
;
Assert
.
greater
(
calls
.
length
0
"
muxer
.
sort
(
)
should
have
been
called
at
least
once
"
)
;
for
(
let
c
of
calls
)
{
let
unsortedResults
=
c
.
args
[
1
]
;
Assert
.
lessOrEqual
(
unsortedResults
.
length
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
"
Provider
should
have
added
no
more
than
maxRichResults
results
"
)
;
}
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
manySuggestResults_visible
(
)
{
await
doManySuggestResultsTest
(
{
expectedSuggestResults
:
[
QuickSuggestTestUtils
.
ampResult
(
{
keyword
:
"
maxresults
"
title
:
"
maxresults
0
"
url
:
"
https
:
/
/
example
.
com
/
maxresults
/
0
"
}
)
]
expectedOtherResultsCount
:
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
-
1
}
)
;
}
)
;
add_task
(
async
function
manySuggestResults_hiddenExposures
(
)
{
UrlbarPrefs
.
set
(
"
exposureResults
"
"
rust_adm_sponsored
"
)
;
UrlbarPrefs
.
set
(
"
showExposureResults
"
false
)
;
let
results
=
[
]
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
suggestResultsCount
=
Math
.
min
(
gMaxResultsSuggestionsCount
maxResults
)
;
for
(
let
i
=
0
;
i
<
suggestResultsCount
;
i
+
+
)
{
let
index
=
maxResults
-
1
-
i
;
results
.
push
(
{
.
.
.
QuickSuggestTestUtils
.
ampResult
(
{
keyword
:
"
maxresults
"
title
:
"
maxresults
"
+
index
url
:
"
https
:
/
/
example
.
com
/
maxresults
/
"
+
index
}
)
exposureTelemetry
:
UrlbarUtils
.
EXPOSURE_TELEMETRY
.
HIDDEN
}
)
;
}
await
doManySuggestResultsTest
(
{
expectedSuggestResults
:
results
expectedOtherResultsCount
:
maxResults
}
)
;
UrlbarPrefs
.
clear
(
"
exposureResults
"
)
;
UrlbarPrefs
.
clear
(
"
showExposureResults
"
)
;
}
)
;
async
function
doManySuggestResultsTest
(
{
expectedSuggestResults
expectedOtherResultsCount
}
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
searchString
=
"
maxresults
"
;
let
suggestions
=
await
QuickSuggest
.
backend
.
query
(
searchString
)
;
Assert
.
equal
(
suggestions
.
length
gMaxResultsSuggestionsCount
"
Sanity
check
:
The
backend
should
return
all
matching
suggestions
"
)
;
Assert
.
greater
(
suggestions
.
length
1
"
Sanity
check
:
There
should
be
more
than
1
matching
suggestion
"
)
;
let
otherResults
=
[
]
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
for
(
let
i
=
0
;
i
<
maxResults
;
i
+
+
)
{
otherResults
.
push
(
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
{
url
:
"
http
:
/
/
example
.
com
/
history
/
"
+
i
}
)
)
;
}
let
provider
=
new
UrlbarTestUtils
.
TestProvider
(
{
results
:
otherResults
}
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
await
check_results
(
{
context
:
createContext
(
searchString
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
provider
.
name
]
isPrivate
:
false
}
)
matches
:
[
.
.
.
expectedSuggestResults
.
.
.
otherResults
.
slice
(
0
expectedOtherResultsCount
)
]
}
)
;
UrlbarProvidersManager
.
unregisterProvider
(
provider
)
;
}
add_tasks_with_rust
(
async
function
dedupeAgainstURL_samePrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTP_SEARCH_STRING
expectedQuickSuggestResult
:
expectedHttpResult
(
)
otherPrefix
:
"
http
:
/
/
"
expectOther
:
false
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
dedupeAgainstURL_higherPrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTPS_SEARCH_STRING
expectedQuickSuggestResult
:
expectedHttpsResult
(
)
otherPrefix
:
"
http
:
/
/
"
expectOther
:
false
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
dedupeAgainstURL_lowerPrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTP_SEARCH_STRING
expectedQuickSuggestResult
:
expectedHttpResult
(
)
otherPrefix
:
"
https
:
/
/
"
expectOther
:
true
}
)
;
}
)
;
async
function
doDedupeAgainstURLTest
(
{
searchString
expectedQuickSuggestResult
otherPrefix
expectOther
}
)
{
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
expectedQuickSuggestResult
.
suggestedIndex
=
-
1
;
let
otherURL
=
otherPrefix
+
PREFIX_SUGGESTIONS_STRIPPED_URL
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
otherURL
title
:
searchString
}
)
;
info
(
"
Doing
first
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
searchString
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
searchString
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeVisitResult
(
context
{
uri
:
otherURL
title
:
searchString
}
)
]
}
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
context
=
createContext
(
searchString
{
isPrivate
:
false
}
)
;
let
expectedResults
=
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
searchString
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
;
if
(
expectOther
)
{
expectedResults
.
push
(
makeVisitResult
(
context
{
uri
:
otherURL
title
:
searchString
}
)
)
;
}
expectedResults
.
push
(
expectedQuickSuggestResult
)
;
info
(
"
Doing
second
query
"
)
;
await
check_results
(
{
context
matches
:
expectedResults
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
add_tasks_with_rust
(
{
skip_if_rust_enabled
:
true
}
async
function
latencyTelemetry
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
)
;
histogram
.
clear
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
QuickSuggestTestUtils
.
ampResult
(
)
]
}
)
;
Assert
.
deepEqual
(
Object
.
values
(
histogram
.
snapshot
(
)
.
values
)
.
filter
(
v
=
>
v
>
0
)
[
1
]
"
Latency
histogram
updated
after
search
"
)
;
Assert
.
ok
(
!
TelemetryStopwatch
.
running
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
context
)
"
Stopwatch
not
running
after
search
"
)
;
}
)
;
add_tasks_with_rust
(
{
skip_if_rust_enabled
:
true
}
async
function
setupAndTeardown
(
)
{
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
is
enabled
initially
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
disabling
suggest
prefs
"
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
remains
enabled
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
disabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
remains
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
remains
non
-
null
after
disabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
disabling
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
false
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
disabling
quicksuggest
.
enabled
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
re
-
enabling
quicksuggest
.
enabled
"
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
is
enabled
after
re
-
enabling
quicksuggest
.
enabled
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
enabling
the
Rust
backend
"
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
is
disabled
after
enabling
the
Rust
backend
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
false
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
disabling
the
Rust
backend
"
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
is
enabled
after
disabling
the
Rust
backend
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
remains
null
at
end
of
task
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
timestamps
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
await
controller
.
startQuery
(
context
)
;
Assert
.
equal
(
context
.
results
.
length
1
"
One
result
returned
"
)
;
let
result
=
context
.
results
[
0
]
;
QuickSuggestTestUtils
.
assertTimestampsReplaced
(
result
{
url
:
TIMESTAMP_SUGGESTION_URL
sponsoredClickUrl
:
TIMESTAMP_SUGGESTION_CLICK_URL
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
dedupeAgainstURL_timestamps
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
let
dupeURL
=
TIMESTAMP_SUGGESTION_URL
.
replace
(
TIMESTAMP_TEMPLATE
"
2013051113
"
)
;
let
badTimestamps
=
[
"
x
"
.
repeat
(
TIMESTAMP_LENGTH
)
"
5
"
.
repeat
(
TIMESTAMP_LENGTH
-
1
)
"
"
]
;
let
badTimestampURLs
=
badTimestamps
.
map
(
str
=
>
TIMESTAMP_SUGGESTION_URL
.
replace
(
TIMESTAMP_TEMPLATE
str
)
)
;
await
PlacesTestUtils
.
addVisits
(
[
dupeURL
.
.
.
badTimestampURLs
]
.
map
(
uri
=
>
(
{
uri
title
:
TIMESTAMP_SEARCH_STRING
}
)
)
)
;
info
(
"
Doing
first
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
expectedHeuristic
=
makeSearchResult
(
context
{
heuristic
:
true
query
:
TIMESTAMP_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
;
let
expectedDupeResult
=
makeVisitResult
(
context
{
uri
:
dupeURL
title
:
TIMESTAMP_SEARCH_STRING
}
)
;
let
expectedBadTimestampResults
=
[
.
.
.
badTimestampURLs
]
.
reverse
(
)
.
map
(
uri
=
>
makeVisitResult
(
context
{
uri
title
:
TIMESTAMP_SEARCH_STRING
}
)
)
;
await
check_results
(
{
context
matches
:
[
expectedHeuristic
.
.
.
expectedBadTimestampResults
expectedDupeResult
]
}
)
;
info
(
"
Doing
second
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
expectedQuickSuggest
=
QuickSuggestTestUtils
.
ampResult
(
{
originalUrl
:
TIMESTAMP_SUGGESTION_URL
keyword
:
TIMESTAMP_SEARCH_STRING
title
:
"
Timestamp
suggestion
"
impressionUrl
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
timestamp
"
blockId
:
5
advertiser
:
"
TestAdvertiserTimestamp
"
iabCategory
:
"
22
-
Shopping
"
suggestedIndex
:
-
1
}
)
;
let
expectedResults
=
[
expectedHeuristic
.
.
.
expectedBadTimestampResults
]
;
const
QUICK_SUGGEST_INDEX
=
expectedResults
.
length
;
expectedResults
.
push
(
expectedQuickSuggest
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
await
controller
.
startQuery
(
context
)
;
info
(
"
Actual
results
:
"
+
JSON
.
stringify
(
context
.
results
)
)
;
Assert
.
equal
(
context
.
results
.
length
expectedResults
.
length
"
Found
the
expected
number
of
results
"
)
;
function
getPayload
(
result
keysToIgnore
=
[
]
)
{
let
payload
=
{
}
;
for
(
let
[
key
value
]
of
Object
.
entries
(
result
.
payload
)
)
{
if
(
value
!
=
=
undefined
&
&
!
keysToIgnore
.
includes
(
key
)
)
{
payload
[
key
]
=
value
;
}
}
return
payload
;
}
for
(
let
i
=
0
;
i
<
expectedResults
.
length
;
i
+
+
)
{
let
actual
=
context
.
results
[
i
]
;
let
expected
=
expectedResults
[
i
]
;
info
(
Comparing
results
at
index
{
i
}
:
+
"
actual
=
"
+
JSON
.
stringify
(
actual
)
+
"
expected
=
"
+
JSON
.
stringify
(
expected
)
)
;
Assert
.
equal
(
actual
.
type
expected
.
type
result
.
type
at
result
index
{
i
}
)
;
Assert
.
equal
(
actual
.
source
expected
.
source
result
.
source
at
result
index
{
i
}
)
;
Assert
.
equal
(
actual
.
heuristic
expected
.
heuristic
result
.
heuristic
at
result
index
{
i
}
)
;
if
(
i
!
=
QUICK_SUGGEST_INDEX
)
{
Assert
.
deepEqual
(
getPayload
(
context
.
results
[
i
]
)
getPayload
(
expectedResults
[
i
]
)
"
Payload
at
index
"
+
i
)
;
}
}
let
actualQuickSuggest
=
context
.
results
[
QUICK_SUGGEST_INDEX
]
;
let
timestampKeys
=
[
"
displayUrl
"
"
sponsoredClickUrl
"
"
url
"
"
urlTimestampIndex
"
]
;
Assert
.
deepEqual
(
getPayload
(
actualQuickSuggest
timestampKeys
)
getPayload
(
expectedQuickSuggest
timestampKeys
)
"
Quick
suggest
payload
excluding
timestamp
-
related
keys
"
)
;
QuickSuggestTestUtils
.
assertTimestampsReplaced
(
actualQuickSuggest
{
url
:
TIMESTAMP_SUGGESTION_URL
sponsoredClickUrl
:
TIMESTAMP_SUGGESTION_CLICK_URL
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
blockedSuggestionsAPI
(
)
{
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
empty
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
"
"
"
quicksuggest
.
blockedDigests
is
an
empty
string
"
)
;
let
urls
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
urls
.
push
(
"
http
:
/
/
example
.
com
/
"
+
i
)
;
}
for
(
let
i
=
0
;
i
<
urls
.
length
;
i
+
+
)
{
await
QuickSuggest
.
blockedSuggestions
.
add
(
urls
[
i
]
)
;
for
(
let
j
=
0
;
j
<
urls
.
length
;
j
+
+
)
{
Assert
.
equal
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
urls
[
j
]
)
j
<
=
i
Suggestion
at
index
{
j
}
is
blocked
or
not
as
expected
)
;
}
}
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
let
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
Assert
.
ok
(
Array
.
isArray
(
array
)
"
Parsed
value
of
pref
is
an
array
"
)
;
Assert
.
equal
(
array
.
length
urls
.
length
"
Array
has
correct
length
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
blockedDigests
"
"
not
a
json
array
"
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
remains
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
still
has
correct
size
"
)
;
let
newURL
=
"
http
:
/
/
example
.
com
/
new
-
block
"
;
await
QuickSuggest
.
blockedSuggestions
.
add
(
newURL
)
;
urls
.
push
(
newURL
)
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
Assert
.
ok
(
Array
.
isArray
(
array
)
"
Parsed
value
of
pref
is
an
array
"
)
;
Assert
.
equal
(
array
.
length
urls
.
length
"
Array
has
correct
length
"
)
;
newURL
=
"
http
:
/
/
example
.
com
/
direct
-
to
-
pref
"
;
urls
.
push
(
newURL
)
;
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
array
.
push
(
await
QuickSuggest
.
blockedSuggestions
.
_test_getDigest
(
newURL
)
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
blockedDigests
"
JSON
.
stringify
(
array
)
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
blockedDigests
"
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
!
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
)
Suggestion
is
no
longer
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
now
empty
"
)
;
for
(
let
url
of
urls
)
{
await
QuickSuggest
.
blockedSuggestions
.
add
(
url
)
;
}
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
!
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
)
Suggestion
is
no
longer
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
now
empty
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
block
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
tests
=
[
[
REMOTE_SETTINGS_RESULTS
[
0
]
QuickSuggestTestUtils
.
ampResult
(
)
]
[
REMOTE_SETTINGS_RESULTS
[
1
]
QuickSuggestTestUtils
.
wikipediaResult
(
)
]
[
REMOTE_SETTINGS_RESULTS
[
2
]
expectedHttpResult
(
)
]
[
REMOTE_SETTINGS_RESULTS
[
3
]
expectedHttpsResult
(
)
]
]
;
for
(
let
[
suggestion
expectedResult
]
of
tests
)
{
info
(
"
Testing
suggestion
:
"
+
JSON
.
stringify
(
suggestion
)
)
;
let
context
=
createContext
(
suggestion
.
keywords
[
0
]
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedResult
]
}
)
;
await
QuickSuggest
.
blockedSuggestions
.
add
(
context
.
results
[
0
]
.
payload
.
url
)
;
await
check_results
(
{
context
:
createContext
(
suggestion
.
keywords
[
0
]
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
}
}
)
;
add_tasks_with_rust
(
async
function
block_timestamp
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
await
controller
.
startQuery
(
context
)
;
Assert
.
equal
(
context
.
results
.
length
1
"
One
result
returned
"
)
;
let
result
=
context
.
results
[
0
]
;
QuickSuggestTestUtils
.
assertTimestampsReplaced
(
result
{
url
:
TIMESTAMP_SUGGESTION_URL
sponsoredClickUrl
:
TIMESTAMP_SUGGESTION_CLICK_URL
}
)
;
Assert
.
ok
(
result
.
payload
.
originalUrl
"
The
actual
result
has
an
originalUrl
"
)
;
Assert
.
equal
(
result
.
payload
.
originalUrl
REMOTE_SETTINGS_RESULTS
[
4
]
.
url
"
The
actual
result
'
s
originalUrl
should
be
the
raw
suggestion
URL
with
a
timestamp
template
"
)
;
await
QuickSuggest
.
blockedSuggestions
.
add
(
result
.
payload
.
originalUrl
)
;
await
check_results
(
{
context
:
createContext
(
TIMESTAMP_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
}
)
;
add_tasks_with_rust
(
{
skip_if_rust_enabled
:
true
}
async
function
remoteSettingsDataType
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
for
(
let
dataType
of
[
undefined
"
test
-
data
-
type
"
]
)
{
let
value
=
{
}
;
if
(
dataType
)
{
value
.
quickSuggestRemoteSettingsDataType
=
dataType
;
}
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
value
)
;
let
expected
=
QuickSuggestTestUtils
.
ampResult
(
)
;
if
(
dataType
)
{
expected
=
JSON
.
parse
(
JSON
.
stringify
(
expected
)
)
;
expected
.
payload
.
title
=
dataType
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expected
]
}
)
;
await
cleanUpNimbus
(
)
;
}
}
)
;
add_tasks_with_rust
(
async
function
sponsoredPriority_normal
(
)
{
await
doSponsoredPriorityTest
(
{
searchWord
:
SPONSORED_SEARCH_STRING
remoteSettingsData
:
[
REMOTE_SETTINGS_RESULTS
[
0
]
]
expectedMatches
:
[
expectedSponsoredPriorityResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredPriority_nonsponsoredSuggestion
(
)
{
await
doSponsoredPriorityTest
(
{
searchWord
:
NONSPONSORED_SEARCH_STRING
remoteSettingsData
:
[
REMOTE_SETTINGS_RESULTS
[
1
]
]
expectedMatches
:
[
QuickSuggestTestUtils
.
wikipediaResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredPriority_sponsoredIndex
(
)
{
await
doSponsoredPriorityTest
(
{
nimbusSettings
:
{
quickSuggestSponsoredIndex
:
2
}
searchWord
:
SPONSORED_SEARCH_STRING
remoteSettingsData
:
[
REMOTE_SETTINGS_RESULTS
[
0
]
]
expectedMatches
:
[
expectedSponsoredPriorityResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredPriority_position
(
)
{
await
doSponsoredPriorityTest
(
{
nimbusSettings
:
{
quickSuggestAllowPositionInSuggestions
:
true
}
searchWord
:
SPONSORED_SEARCH_STRING
remoteSettingsData
:
[
Object
.
assign
(
{
}
REMOTE_SETTINGS_RESULTS
[
0
]
{
position
:
2
}
)
]
expectedMatches
:
[
expectedSponsoredPriorityResult
(
)
]
}
)
;
}
)
;
async
function
doSponsoredPriorityTest
(
{
remoteSettingsConfig
=
{
}
nimbusSettings
=
{
}
searchWord
remoteSettingsData
expectedMatches
}
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
const
cleanUpNimbusEnable
=
await
UrlbarTestUtils
.
initNimbusFeature
(
{
.
.
.
nimbusSettings
quickSuggestSponsoredPriority
:
true
}
)
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
{
type
:
"
data
"
attachment
:
remoteSettingsData
}
]
)
;
await
QuickSuggestTestUtils
.
setConfig
(
remoteSettingsConfig
)
;
await
check_results
(
{
context
:
createContext
(
searchWord
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
expectedMatches
}
)
;
await
cleanUpNimbusEnable
(
)
;
}
add_tasks_with_rust
(
async
function
tabToSearch
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
sponsoredPriority
"
true
)
;
UrlbarPrefs
.
set
(
"
tabToSearch
.
onboard
.
interactionsLeft
"
0
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
let
engineURL
=
https
:
/
/
foo
.
{
SPONSORED_SEARCH_STRING
}
.
com
/
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
Test
"
search_url
:
engineURL
}
{
skipUnload
:
true
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
Test
"
)
;
await
PlacesTestUtils
.
addVisits
(
engineURL
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
await
Services
.
search
.
defaultEngine
.
getIconURL
(
)
heuristic
:
true
}
)
makeSearchResult
(
context
{
engineName
:
engine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
searchUrlDomainWithoutSuffix
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
engine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
satisfiesAutofillThreshold
:
true
}
)
expectedSponsoredPriorityResult
(
)
makeVisitResult
(
context
{
uri
:
engineURL
title
:
test
visit
for
{
engineURL
}
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
UrlbarPrefs
.
clear
(
"
tabToSearch
.
onboard
.
interactionsLeft
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
quicksuggest
.
sponsoredPriority
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
position
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
sponsoredPriority
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
allowPositionInSuggestions
"
true
)
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
{
type
:
"
data
"
attachment
:
[
{
.
.
.
REMOTE_SETTINGS_RESULTS
[
0
]
position
:
9
}
]
}
]
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResultCount
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
visitResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResultCount
;
i
+
+
)
{
let
url
=
http
:
/
/
example
.
com
/
{
SPONSORED_SEARCH_STRING
}
-
{
i
}
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
visitResults
.
unshift
(
makeVisitResult
(
context
{
uri
:
url
title
:
test
visit
for
{
url
}
}
)
)
;
}
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
await
Services
.
search
.
defaultEngine
.
getIconURL
(
)
heuristic
:
true
}
)
expectedSponsoredPriorityResult
(
)
.
.
.
visitResults
.
slice
(
0
maxResultCount
-
2
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
{
type
:
"
data
"
attachment
:
REMOTE_SETTINGS_RESULTS
}
]
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
allowPositionInSuggestions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
quicksuggest
.
sponsoredPriority
"
)
;
}
)
;
add_task
(
async
function
rustProviders
(
)
{
await
doRustProvidersTests
(
{
searchString
:
SPONSORED_AND_NONSPONSORED_SEARCH_STRING
tests
:
[
{
prefs
:
{
"
suggest
.
quicksuggest
.
nonsponsored
"
:
true
"
suggest
.
quicksuggest
.
sponsored
"
:
true
}
expectedUrls
:
[
"
https
:
/
/
example
.
com
/
amp
"
"
https
:
/
/
example
.
com
/
wikipedia
"
]
}
{
prefs
:
{
"
suggest
.
quicksuggest
.
nonsponsored
"
:
true
"
suggest
.
quicksuggest
.
sponsored
"
:
false
}
expectedUrls
:
[
"
https
:
/
/
example
.
com
/
wikipedia
"
]
}
{
prefs
:
{
"
suggest
.
quicksuggest
.
nonsponsored
"
:
false
"
suggest
.
quicksuggest
.
sponsored
"
:
true
}
expectedUrls
:
[
"
https
:
/
/
example
.
com
/
amp
"
]
}
{
prefs
:
{
"
suggest
.
quicksuggest
.
nonsponsored
"
:
false
"
suggest
.
quicksuggest
.
sponsored
"
:
false
}
expectedUrls
:
[
]
}
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
keywordLengthThreshold
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
tests
=
[
.
.
.
ONE_CHAR_SEARCH_STRINGS
.
map
(
keyword
=
>
(
{
keyword
expected
:
false
}
)
)
{
keyword
:
"
12
"
expected
:
true
}
{
keyword
:
"
a
longer
keyword
"
expected
:
true
}
]
;
for
(
let
{
keyword
expected
}
of
tests
)
{
await
check_results
(
{
context
:
createContext
(
keyword
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
!
expected
?
[
]
:
[
QuickSuggestTestUtils
.
ampResult
(
{
keyword
title
:
"
Suggestion
with
1
-
char
keyword
"
url
:
"
http
:
/
/
example
.
com
/
1
-
char
-
keyword
"
originalUrl
:
"
http
:
/
/
example
.
com
/
1
-
char
-
keyword
"
}
)
]
}
)
;
}
}
)
;
add_tasks_with_rust
(
async
function
ampTopPickCharThreshold
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
ampTopPickCharThreshold
"
"
amp
full
keywo
"
.
length
)
;
let
tests
=
[
{
keyword
:
"
amp
full
key
"
amp
:
true
isTopPick
:
false
}
{
keyword
:
"
amp
full
keyw
"
amp
:
true
isTopPick
:
false
}
{
keyword
:
"
amp
full
keywo
"
amp
:
true
isTopPick
:
true
}
{
keyword
:
"
amp
full
keywor
"
amp
:
true
isTopPick
:
true
}
{
keyword
:
"
amp
full
keyword
"
amp
:
true
isTopPick
:
true
}
{
keyword
:
"
AmP
FuLl
KeYwOrD
"
amp
:
true
isTopPick
:
true
}
{
keyword
:
"
xyz
"
fullKeyword
:
"
xyz
"
amp
:
true
isTopPick
:
true
}
{
keyword
:
"
XyZ
"
fullKeyword
:
"
xyz
"
amp
:
true
isTopPick
:
true
}
{
keyword
:
"
wikipedia
full
key
"
isTopPick
:
false
}
{
keyword
:
"
wikipedia
full
keyw
"
isTopPick
:
false
}
{
keyword
:
"
wikipedia
full
keywo
"
isTopPick
:
false
}
{
keyword
:
"
wikipedia
full
keywor
"
isTopPick
:
false
}
{
keyword
:
"
wikipedia
full
keyword
"
isTopPick
:
false
}
]
;
for
(
let
{
keyword
fullKeyword
amp
isTopPick
}
of
tests
)
{
fullKeyword
?
?
=
amp
?
"
amp
full
keyword
"
:
"
wikipedia
full
keyword
"
;
info
(
"
Running
subtest
:
"
+
JSON
.
stringify
(
{
keyword
fullKeyword
amp
isTopPick
}
)
)
;
let
expectedResult
;
if
(
!
amp
)
{
expectedResult
=
QuickSuggestTestUtils
.
wikipediaResult
(
{
keyword
fullKeyword
title
:
"
Wikipedia
suggestion
with
full
keyword
and
prefix
keywords
"
url
:
"
https
:
/
/
example
.
com
/
wikipedia
-
full
-
keyword
"
}
)
;
}
else
if
(
isTopPick
)
{
expectedResult
=
QuickSuggestTestUtils
.
ampResult
(
{
keyword
fullKeyword
title
:
"
AMP
suggestion
with
full
keyword
and
prefix
keywords
"
url
:
"
https
:
/
/
example
.
com
/
amp
-
full
-
keyword
"
suggestedIndex
:
1
isSuggestedIndexRelativeToGroup
:
false
isBestMatch
:
true
descriptionL10n
:
null
}
)
;
}
else
{
expectedResult
=
QuickSuggestTestUtils
.
ampResult
(
{
keyword
fullKeyword
title
:
"
AMP
suggestion
with
full
keyword
and
prefix
keywords
"
url
:
"
https
:
/
/
example
.
com
/
amp
-
full
-
keyword
"
}
)
;
}
await
check_results
(
{
context
:
createContext
(
keyword
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
expectedResult
]
}
)
;
}
UrlbarPrefs
.
clear
(
"
quicksuggest
.
ampTopPickCharThreshold
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
ampTopPickCharThreshold_zero
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
ampTopPickCharThreshold
"
0
)
;
let
tests
=
[
{
keyword
:
"
amp
full
key
"
amp
:
true
}
{
keyword
:
"
amp
full
keyw
"
amp
:
true
}
{
keyword
:
"
amp
full
keywo
"
amp
:
true
}
{
keyword
:
"
amp
full
keywor
"
amp
:
true
}
{
keyword
:
"
amp
full
keyword
"
amp
:
true
}
{
keyword
:
"
AmP
FuLl
KeYwOrD
"
amp
:
true
}
{
keyword
:
"
xyz
"
fullKeyword
:
"
xyz
"
amp
:
true
}
{
keyword
:
"
XyZ
"
fullKeyword
:
"
xyz
"
amp
:
true
}
{
keyword
:
"
wikipedia
full
key
"
}
{
keyword
:
"
wikipedia
full
keyw
"
}
{
keyword
:
"
wikipedia
full
keywo
"
}
{
keyword
:
"
wikipedia
full
keywor
"
}
{
keyword
:
"
wikipedia
full
keyword
"
}
]
;
for
(
let
{
keyword
fullKeyword
amp
}
of
tests
)
{
fullKeyword
?
?
=
amp
?
"
amp
full
keyword
"
:
"
wikipedia
full
keyword
"
;
info
(
"
Running
subtest
:
"
+
JSON
.
stringify
(
{
keyword
fullKeyword
amp
}
)
)
;
let
expectedResult
;
if
(
!
amp
)
{
expectedResult
=
QuickSuggestTestUtils
.
wikipediaResult
(
{
keyword
fullKeyword
title
:
"
Wikipedia
suggestion
with
full
keyword
and
prefix
keywords
"
url
:
"
https
:
/
/
example
.
com
/
wikipedia
-
full
-
keyword
"
}
)
;
}
else
{
expectedResult
=
QuickSuggestTestUtils
.
ampResult
(
{
keyword
fullKeyword
title
:
"
AMP
suggestion
with
full
keyword
and
prefix
keywords
"
url
:
"
https
:
/
/
example
.
com
/
amp
-
full
-
keyword
"
}
)
;
}
await
check_results
(
{
context
:
createContext
(
keyword
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
expectedResult
]
}
)
;
}
UrlbarPrefs
.
clear
(
"
quicksuggest
.
ampTopPickCharThreshold
"
)
;
}
)
;
