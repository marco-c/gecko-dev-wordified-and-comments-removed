"
use
strict
"
;
const
TELEMETRY_REMOTE_SETTINGS_LATENCY
=
"
FX_URLBAR_QUICK_SUGGEST_REMOTE_SETTINGS_LATENCY_MS
"
;
const
SPONSORED_SEARCH_STRING
=
"
amp
"
;
const
NONSPONSORED_SEARCH_STRING
=
"
wikipedia
"
;
const
HTTP_SEARCH_STRING
=
"
http
prefix
"
;
const
HTTPS_SEARCH_STRING
=
"
https
prefix
"
;
const
PREFIX_SUGGESTIONS_STRIPPED_URL
=
"
example
.
com
/
prefix
-
test
"
;
const
{
TIMESTAMP_TEMPLATE
TIMESTAMP_LENGTH
}
=
QuickSuggest
;
const
TIMESTAMP_SEARCH_STRING
=
"
timestamp
"
;
const
TIMESTAMP_SUGGESTION_URL
=
http
:
/
/
example
.
com
/
timestamp
-
{
TIMESTAMP_TEMPLATE
}
;
const
TIMESTAMP_SUGGESTION_CLICK_URL
=
http
:
/
/
click
.
reporting
.
test
.
com
/
timestamp
-
{
TIMESTAMP_TEMPLATE
}
-
foo
;
const
REMOTE_SETTINGS_RESULTS
=
[
{
id
:
1
url
:
"
http
:
/
/
example
.
com
/
amp
"
title
:
"
AMP
Suggestion
"
keywords
:
[
SPONSORED_SEARCH_STRING
]
click_url
:
"
http
:
/
/
example
.
com
/
amp
-
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
amp
-
impression
"
advertiser
:
"
Amp
"
iab_category
:
"
22
-
Shopping
"
icon
:
"
1234
"
}
{
id
:
2
url
:
"
http
:
/
/
example
.
com
/
wikipedia
"
title
:
"
Wikipedia
Suggestion
"
keywords
:
[
NONSPONSORED_SEARCH_STRING
]
click_url
:
"
http
:
/
/
example
.
com
/
wikipedia
-
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
wikipedia
-
impression
"
advertiser
:
"
Wikipedia
"
iab_category
:
"
5
-
Education
"
icon
:
"
1234
"
}
{
id
:
3
url
:
"
http
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
title
:
"
HTTP
Suggestion
"
keywords
:
[
HTTP_SEARCH_STRING
]
click_url
:
"
http
:
/
/
example
.
com
/
http
-
click
"
impression_url
:
"
http
:
/
/
example
.
com
/
http
-
impression
"
advertiser
:
"
HttpAdvertiser
"
iab_category
:
"
22
-
Shopping
"
icon
:
"
1234
"
}
{
id
:
4
url
:
"
https
:
/
/
"
+
PREFIX_SUGGESTIONS_STRIPPED_URL
title
:
"
https
suggestion
"
keywords
:
[
HTTPS_SEARCH_STRING
]
click_url
:
"
http
:
/
/
click
.
reporting
.
test
.
com
/
prefix
"
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
prefix
"
advertiser
:
"
TestAdvertiserPrefix
"
iab_category
:
"
22
-
Shopping
"
icon
:
"
1234
"
}
{
id
:
5
url
:
TIMESTAMP_SUGGESTION_URL
title
:
"
Timestamp
suggestion
"
keywords
:
[
TIMESTAMP_SEARCH_STRING
]
click_url
:
TIMESTAMP_SUGGESTION_CLICK_URL
impression_url
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
timestamp
"
advertiser
:
"
TestAdvertiserTimestamp
"
iab_category
:
"
22
-
Shopping
"
icon
:
"
1234
"
}
]
;
function
expectedNonSponsoredResult
(
)
{
return
makeWikipediaResult
(
{
blockId
:
2
}
)
;
}
function
expectedSponsoredResult
(
)
{
return
makeAmpResult
(
)
;
}
function
expectedSponsoredPriorityResult
(
)
{
return
{
.
.
.
expectedSponsoredResult
(
)
isBestMatch
:
true
suggestedIndex
:
1
isSuggestedIndexRelativeToGroup
:
false
}
;
}
function
expectedHttpResult
(
)
{
let
suggestion
=
REMOTE_SETTINGS_RESULTS
[
2
]
;
return
makeAmpResult
(
{
keyword
:
HTTP_SEARCH_STRING
title
:
suggestion
.
title
url
:
suggestion
.
url
originalUrl
:
suggestion
.
url
impressionUrl
:
suggestion
.
impression_url
clickUrl
:
suggestion
.
click_url
blockId
:
suggestion
.
id
advertiser
:
suggestion
.
advertiser
}
)
;
}
function
expectedHttpsResult
(
)
{
let
suggestion
=
REMOTE_SETTINGS_RESULTS
[
3
]
;
return
makeAmpResult
(
{
keyword
:
HTTPS_SEARCH_STRING
title
:
suggestion
.
title
url
:
suggestion
.
url
originalUrl
:
suggestion
.
url
impressionUrl
:
suggestion
.
impression_url
clickUrl
:
suggestion
.
click_url
blockId
:
suggestion
.
id
advertiser
:
suggestion
.
advertiser
}
)
;
}
add_setup
(
async
function
init
(
)
{
let
engine
=
await
addTestSuggestionsEngine
(
)
;
await
Services
.
search
.
setDefault
(
engine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
const
testDataTypeResults
=
[
Object
.
assign
(
{
}
REMOTE_SETTINGS_RESULTS
[
0
]
{
title
:
"
test
-
data
-
type
"
}
)
]
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
remoteSettingsRecords
:
[
{
type
:
"
data
"
attachment
:
REMOTE_SETTINGS_RESULTS
}
{
type
:
"
test
-
data
-
type
"
attachment
:
testDataTypeResults
}
]
}
)
;
}
)
;
add_task
(
async
function
telemetryType_sponsored
(
)
{
Assert
.
equal
(
QuickSuggest
.
getFeature
(
"
AdmWikipedia
"
)
.
getSuggestionTelemetryType
(
{
is_sponsored
:
true
}
)
"
adm_sponsored
"
"
Telemetry
type
should
be
'
adm_sponsored
'
"
)
;
}
)
;
add_task
(
async
function
telemetryType_nonsponsored
(
)
{
Assert
.
equal
(
QuickSuggest
.
getFeature
(
"
AdmWikipedia
"
)
.
getSuggestionTelemetryType
(
{
is_sponsored
:
false
}
)
"
adm_nonsponsored
"
"
Telemetry
type
should
be
'
adm_nonsponsored
'
"
)
;
Assert
.
equal
(
QuickSuggest
.
getFeature
(
"
AdmWikipedia
"
)
.
getSuggestionTelemetryType
(
{
}
)
"
adm_nonsponsored
"
"
Telemetry
type
should
be
'
adm_nonsponsored
'
if
is_sponsored
not
defined
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
nonsponsoredOnly_match
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedNonSponsoredResult
(
)
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
{
NONSPONSORED_SEARCH_STRING
}
Wikipedia
Suggestion
"
result
.
title
should
be
correct
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
]
"
result
.
titleHighlights
should
be
correct
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
nonsponsoredOnly_noMatch
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredOnly_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedSponsoredResult
(
)
]
}
)
;
let
result
=
context
.
results
[
0
]
;
Assert
.
equal
(
result
.
title
{
SPONSORED_SEARCH_STRING
}
AMP
Suggestion
"
result
.
title
should
be
correct
"
)
;
Assert
.
deepEqual
(
result
.
titleHighlights
[
]
"
result
.
titleHighlights
should
be
correct
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredOnly_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
both_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedSponsoredResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
both_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedNonSponsoredResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
both_noMatch
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
"
this
doesn
'
t
match
anything
"
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
neither_sponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
neither_nonsponsored
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
NONSPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
caseInsensitiveAndLeadingSpaces
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
"
"
+
SPONSORED_SEARCH_STRING
.
toUpperCase
(
)
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedSponsoredResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
emptySearchStringsAndSpaces
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
searchStrings
=
[
"
"
"
"
"
"
"
"
]
;
for
(
let
str
of
searchStrings
)
{
let
msg
=
JSON
.
stringify
(
str
)
+
(
length
=
{
str
.
length
}
)
;
info
(
"
Testing
search
string
:
"
+
msg
)
;
let
context
=
createContext
(
str
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
Assert
.
ok
(
!
UrlbarProviderQuickSuggest
.
isActive
(
context
)
"
Provider
should
not
be
active
for
search
string
:
"
+
msg
)
;
}
}
)
;
add_tasks_with_rust
(
async
function
browser_search_suggest_enabled
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedSponsoredResult
(
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
browser_search_suggest_enabled
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedSponsoredResult
(
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
privateContext
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
for
(
let
privateSuggestionsEnabled
of
[
true
false
]
)
{
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
.
private
"
privateSuggestionsEnabled
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
true
}
)
;
await
check_results
(
{
context
matches
:
[
]
}
)
;
}
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
.
private
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
suggestionsBeforeGeneral_only
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
expectedSponsoredResult
(
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
suggestionsBeforeGeneral_others
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
historyResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResults
;
i
+
+
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
+
SPONSORED_SEARCH_STRING
+
i
;
historyResults
.
push
(
makeVisitResult
(
context
{
uri
:
url
title
:
"
test
visit
for
"
+
url
}
)
)
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
}
historyResults
=
historyResults
.
reverse
(
)
.
slice
(
0
historyResults
.
length
-
4
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
.
.
.
historyResults
expectedSponsoredResult
(
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_tasks_with_rust
(
async
function
generalBeforeSuggestions_only
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
expectedSponsoredResult
(
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
generalBeforeSuggestions_others
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
browser
.
search
.
suggest
.
enabled
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
true
)
;
UrlbarPrefs
.
set
(
"
showSearchSuggestionsFirst
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResults
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
historyResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResults
;
i
+
+
)
{
let
url
=
"
http
:
/
/
example
.
com
/
"
+
SPONSORED_SEARCH_STRING
+
i
;
historyResults
.
push
(
makeVisitResult
(
context
{
uri
:
url
title
:
"
test
visit
for
"
+
url
}
)
)
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
}
historyResults
=
historyResults
.
reverse
(
)
.
slice
(
0
historyResults
.
length
-
4
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
SPONSORED_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
.
.
.
historyResults
expectedSponsoredResult
(
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
foo
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeSearchResult
(
context
{
query
:
SPONSORED_SEARCH_STRING
suggestion
:
SPONSORED_SEARCH_STRING
+
"
bar
"
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
}
)
;
UrlbarPrefs
.
clear
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
UrlbarPrefs
.
clear
(
"
showSearchSuggestionsFirst
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_tasks_with_rust
(
async
function
dedupeAgainstURL_samePrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTP_SEARCH_STRING
expectedQuickSuggestResult
:
expectedHttpResult
(
)
otherPrefix
:
"
http
:
/
/
"
expectOther
:
false
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
dedupeAgainstURL_higherPrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTPS_SEARCH_STRING
expectedQuickSuggestResult
:
expectedHttpsResult
(
)
otherPrefix
:
"
http
:
/
/
"
expectOther
:
false
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
dedupeAgainstURL_lowerPrefix
(
)
{
await
doDedupeAgainstURLTest
(
{
searchString
:
HTTP_SEARCH_STRING
expectedQuickSuggestResult
:
expectedHttpResult
(
)
otherPrefix
:
"
https
:
/
/
"
expectOther
:
true
}
)
;
}
)
;
async
function
doDedupeAgainstURLTest
(
{
searchString
expectedQuickSuggestResult
otherPrefix
expectOther
}
)
{
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
let
otherURL
=
otherPrefix
+
PREFIX_SUGGESTIONS_STRIPPED_URL
;
await
PlacesTestUtils
.
addVisits
(
{
uri
:
otherURL
title
:
searchString
}
)
;
info
(
"
Doing
first
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
searchString
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
searchString
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
makeVisitResult
(
context
{
uri
:
otherURL
title
:
searchString
}
)
]
}
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
context
=
createContext
(
searchString
{
isPrivate
:
false
}
)
;
let
expectedResults
=
[
makeSearchResult
(
context
{
heuristic
:
true
query
:
searchString
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
]
;
if
(
expectOther
)
{
expectedResults
.
push
(
makeVisitResult
(
context
{
uri
:
otherURL
title
:
searchString
}
)
)
;
}
expectedResults
.
push
(
expectedQuickSuggestResult
)
;
info
(
"
Doing
second
query
"
)
;
await
check_results
(
{
context
matches
:
expectedResults
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
add_task
(
async
function
latencyTelemetry
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
)
;
histogram
.
clear
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedSponsoredResult
(
)
]
}
)
;
Assert
.
deepEqual
(
Object
.
values
(
histogram
.
snapshot
(
)
.
values
)
.
filter
(
v
=
>
v
>
0
)
[
1
]
"
Latency
histogram
updated
after
search
"
)
;
Assert
.
ok
(
!
TelemetryStopwatch
.
running
(
TELEMETRY_REMOTE_SETTINGS_LATENCY
context
)
"
Stopwatch
not
running
after
search
"
)
;
}
)
;
add_task
(
async
function
setupAndTeardown
(
)
{
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
is
enabled
initially
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
disabling
suggest
prefs
"
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
remains
enabled
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
disabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
remains
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
remains
non
-
null
after
disabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
disabling
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
enabling
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
false
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
disabling
quicksuggest
.
enabled
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
re
-
enabling
quicksuggest
.
enabled
"
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
is
enabled
after
re
-
enabling
quicksuggest
.
enabled
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
rustEnabled
"
true
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
null
after
enabling
the
Rust
backend
"
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
is
disabled
after
enabling
the
Rust
backend
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
rustEnabled
"
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
is
non
-
null
after
disabling
the
Rust
backend
"
)
;
Assert
.
ok
(
QuickSuggest
.
jsBackend
.
isEnabled
"
Remote
settings
backend
is
enabled
after
disabling
the
Rust
backend
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
enabled
"
true
)
;
Assert
.
ok
(
!
QuickSuggest
.
jsBackend
.
rs
"
Settings
client
remains
null
at
end
of
task
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
timestamps
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
await
controller
.
startQuery
(
context
)
;
Assert
.
equal
(
context
.
results
.
length
1
"
One
result
returned
"
)
;
let
result
=
context
.
results
[
0
]
;
QuickSuggestTestUtils
.
assertTimestampsReplaced
(
result
{
url
:
TIMESTAMP_SUGGESTION_URL
sponsoredClickUrl
:
TIMESTAMP_SUGGESTION_CLICK_URL
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
dedupeAgainstURL_timestamps
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
searches
"
false
)
;
let
dupeURL
=
TIMESTAMP_SUGGESTION_URL
.
replace
(
TIMESTAMP_TEMPLATE
"
2013051113
"
)
;
let
badTimestamps
=
[
"
x
"
.
repeat
(
TIMESTAMP_LENGTH
)
"
5
"
.
repeat
(
TIMESTAMP_LENGTH
-
1
)
"
"
]
;
let
badTimestampURLs
=
badTimestamps
.
map
(
str
=
>
TIMESTAMP_SUGGESTION_URL
.
replace
(
TIMESTAMP_TEMPLATE
str
)
)
;
await
PlacesTestUtils
.
addVisits
(
[
dupeURL
.
.
.
badTimestampURLs
]
.
map
(
uri
=
>
(
{
uri
title
:
TIMESTAMP_SEARCH_STRING
}
)
)
)
;
info
(
"
Doing
first
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
let
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
expectedHeuristic
=
makeSearchResult
(
context
{
heuristic
:
true
query
:
TIMESTAMP_SEARCH_STRING
engineName
:
Services
.
search
.
defaultEngine
.
name
}
)
;
let
expectedDupeResult
=
makeVisitResult
(
context
{
uri
:
dupeURL
title
:
TIMESTAMP_SEARCH_STRING
}
)
;
let
expectedBadTimestampResults
=
[
.
.
.
badTimestampURLs
]
.
reverse
(
)
.
map
(
uri
=
>
makeVisitResult
(
context
{
uri
title
:
TIMESTAMP_SEARCH_STRING
}
)
)
;
await
check_results
(
{
context
matches
:
[
expectedHeuristic
.
.
.
expectedBadTimestampResults
expectedDupeResult
]
}
)
;
info
(
"
Doing
second
query
"
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
expectedQuickSuggest
=
makeAmpResult
(
{
originalUrl
:
TIMESTAMP_SUGGESTION_URL
keyword
:
TIMESTAMP_SEARCH_STRING
title
:
"
Timestamp
suggestion
"
impressionUrl
:
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
timestamp
"
blockId
:
5
advertiser
:
"
TestAdvertiserTimestamp
"
iabCategory
:
"
22
-
Shopping
"
}
)
;
let
expectedResults
=
[
expectedHeuristic
.
.
.
expectedBadTimestampResults
expectedQuickSuggest
]
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
await
controller
.
startQuery
(
context
)
;
info
(
"
Actual
results
:
"
+
JSON
.
stringify
(
context
.
results
)
)
;
Assert
.
equal
(
context
.
results
.
length
expectedResults
.
length
"
Found
the
expected
number
of
results
"
)
;
function
getPayload
(
result
keysToIgnore
=
[
]
)
{
let
payload
=
{
}
;
for
(
let
[
key
value
]
of
Object
.
entries
(
result
.
payload
)
)
{
if
(
value
!
=
=
undefined
&
&
!
keysToIgnore
.
includes
(
key
)
)
{
payload
[
key
]
=
value
;
}
}
return
payload
;
}
for
(
let
i
=
0
;
i
<
expectedResults
.
length
;
i
+
+
)
{
let
actual
=
context
.
results
[
i
]
;
let
expected
=
expectedResults
[
i
]
;
info
(
Comparing
results
at
index
{
i
}
:
+
"
actual
=
"
+
JSON
.
stringify
(
actual
)
+
"
expected
=
"
+
JSON
.
stringify
(
expected
)
)
;
Assert
.
equal
(
actual
.
type
expected
.
type
result
.
type
at
result
index
{
i
}
)
;
Assert
.
equal
(
actual
.
source
expected
.
source
result
.
source
at
result
index
{
i
}
)
;
Assert
.
equal
(
actual
.
heuristic
expected
.
heuristic
result
.
heuristic
at
result
index
{
i
}
)
;
if
(
i
!
=
expectedResults
.
length
-
1
)
{
Assert
.
deepEqual
(
getPayload
(
context
.
results
[
i
]
)
getPayload
(
expectedResults
[
i
]
)
"
Payload
at
index
"
+
i
)
;
}
}
let
actualQuickSuggest
=
context
.
results
[
context
.
results
.
length
-
1
]
;
let
timestampKeys
=
[
"
displayUrl
"
"
sponsoredClickUrl
"
"
url
"
"
urlTimestampIndex
"
]
;
Assert
.
deepEqual
(
getPayload
(
actualQuickSuggest
timestampKeys
)
getPayload
(
expectedQuickSuggest
timestampKeys
)
"
Quick
suggest
payload
excluding
timestamp
-
related
keys
"
)
;
QuickSuggestTestUtils
.
assertTimestampsReplaced
(
actualQuickSuggest
{
url
:
TIMESTAMP_SUGGESTION_URL
sponsoredClickUrl
:
TIMESTAMP_SUGGESTION_CLICK_URL
}
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
searches
"
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
)
;
add_task
(
async
function
blockedSuggestionsAPI
(
)
{
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
empty
"
)
;
Assert
.
equal
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
"
"
"
quicksuggest
.
blockedDigests
is
an
empty
string
"
)
;
let
urls
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
urls
.
push
(
"
http
:
/
/
example
.
com
/
"
+
i
)
;
}
for
(
let
i
=
0
;
i
<
urls
.
length
;
i
+
+
)
{
await
QuickSuggest
.
blockedSuggestions
.
add
(
urls
[
i
]
)
;
for
(
let
j
=
0
;
j
<
urls
.
length
;
j
+
+
)
{
Assert
.
equal
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
urls
[
j
]
)
j
<
=
i
Suggestion
at
index
{
j
}
is
blocked
or
not
as
expected
)
;
}
}
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
let
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
Assert
.
ok
(
Array
.
isArray
(
array
)
"
Parsed
value
of
pref
is
an
array
"
)
;
Assert
.
equal
(
array
.
length
urls
.
length
"
Array
has
correct
length
"
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
blockedDigests
"
"
not
a
json
array
"
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
remains
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
still
has
correct
size
"
)
;
let
newURL
=
"
http
:
/
/
example
.
com
/
new
-
block
"
;
await
QuickSuggest
.
blockedSuggestions
.
add
(
newURL
)
;
urls
.
push
(
newURL
)
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
Assert
.
ok
(
Array
.
isArray
(
array
)
"
Parsed
value
of
pref
is
an
array
"
)
;
Assert
.
equal
(
array
.
length
urls
.
length
"
Array
has
correct
length
"
)
;
newURL
=
"
http
:
/
/
example
.
com
/
direct
-
to
-
pref
"
;
urls
.
push
(
newURL
)
;
array
=
JSON
.
parse
(
UrlbarPrefs
.
get
(
"
quicksuggest
.
blockedDigests
"
)
)
;
array
.
push
(
await
QuickSuggest
.
blockedSuggestions
.
_test_getDigest
(
newURL
)
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
blockedDigests
"
JSON
.
stringify
(
array
)
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
urls
.
length
"
blockedSuggestions
.
_test_digests
has
correct
size
"
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
blockedDigests
"
)
;
await
QuickSuggest
.
blockedSuggestions
.
_test_readyPromise
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
!
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
)
Suggestion
is
no
longer
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
now
empty
"
)
;
for
(
let
url
of
urls
)
{
await
QuickSuggest
.
blockedSuggestions
.
add
(
url
)
;
}
for
(
let
url
of
urls
)
{
Assert
.
ok
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
Suggestion
is
blocked
:
{
url
}
)
;
}
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
for
(
let
url
of
urls
)
{
Assert
.
ok
(
!
(
await
QuickSuggest
.
blockedSuggestions
.
has
(
url
)
)
Suggestion
is
no
longer
blocked
:
{
url
}
)
;
}
Assert
.
equal
(
QuickSuggest
.
blockedSuggestions
.
_test_digests
.
size
0
"
blockedSuggestions
.
_test_digests
is
now
empty
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
block
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
tests
=
[
[
REMOTE_SETTINGS_RESULTS
[
0
]
expectedSponsoredResult
(
)
]
[
REMOTE_SETTINGS_RESULTS
[
1
]
expectedNonSponsoredResult
(
)
]
[
REMOTE_SETTINGS_RESULTS
[
2
]
expectedHttpResult
(
)
]
[
REMOTE_SETTINGS_RESULTS
[
3
]
expectedHttpsResult
(
)
]
]
;
for
(
let
[
suggestion
expectedResult
]
of
tests
)
{
info
(
"
Testing
suggestion
:
"
+
JSON
.
stringify
(
suggestion
)
)
;
let
context
=
createContext
(
suggestion
.
keywords
[
0
]
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expectedResult
]
}
)
;
await
QuickSuggest
.
blockedSuggestions
.
add
(
context
.
results
[
0
]
.
payload
.
url
)
;
await
check_results
(
{
context
:
createContext
(
suggestion
.
keywords
[
0
]
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
}
}
)
;
add_tasks_with_rust
(
async
function
block_timestamp
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
TIMESTAMP_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
let
controller
=
UrlbarTestUtils
.
newMockController
(
)
;
await
controller
.
startQuery
(
context
)
;
Assert
.
equal
(
context
.
results
.
length
1
"
One
result
returned
"
)
;
let
result
=
context
.
results
[
0
]
;
QuickSuggestTestUtils
.
assertTimestampsReplaced
(
result
{
url
:
TIMESTAMP_SUGGESTION_URL
sponsoredClickUrl
:
TIMESTAMP_SUGGESTION_CLICK_URL
}
)
;
Assert
.
ok
(
result
.
payload
.
originalUrl
"
The
actual
result
has
an
originalUrl
"
)
;
Assert
.
equal
(
result
.
payload
.
originalUrl
REMOTE_SETTINGS_RESULTS
[
4
]
.
url
"
The
actual
result
'
s
originalUrl
should
be
the
raw
suggestion
URL
with
a
timestamp
template
"
)
;
await
QuickSuggest
.
blockedSuggestions
.
add
(
result
.
payload
.
originalUrl
)
;
await
check_results
(
{
context
:
createContext
(
TIMESTAMP_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
await
QuickSuggest
.
blockedSuggestions
.
clear
(
)
;
}
)
;
add_task
(
async
function
remoteSettingsDataType
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
false
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
for
(
let
dataType
of
[
undefined
"
test
-
data
-
type
"
]
)
{
let
value
=
{
}
;
if
(
dataType
)
{
value
.
quickSuggestRemoteSettingsDataType
=
dataType
;
}
let
cleanUpNimbus
=
await
UrlbarTestUtils
.
initNimbusFeature
(
value
)
;
let
expected
=
expectedSponsoredResult
(
)
;
if
(
dataType
)
{
expected
=
JSON
.
parse
(
JSON
.
stringify
(
expected
)
)
;
expected
.
payload
.
title
=
dataType
;
}
await
QuickSuggestTestUtils
.
forceSync
(
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
expected
]
}
)
;
await
cleanUpNimbus
(
)
;
}
}
)
;
add_tasks_with_rust
(
async
function
sponsoredPriority_normal
(
)
{
await
doSponsoredPriorityTest
(
{
searchWord
:
SPONSORED_SEARCH_STRING
remoteSettingsData
:
[
REMOTE_SETTINGS_RESULTS
[
0
]
]
expectedMatches
:
[
expectedSponsoredPriorityResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredPriority_nonsponsoredSuggestion
(
)
{
await
doSponsoredPriorityTest
(
{
searchWord
:
NONSPONSORED_SEARCH_STRING
remoteSettingsData
:
[
REMOTE_SETTINGS_RESULTS
[
1
]
]
expectedMatches
:
[
expectedNonSponsoredResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredPriority_sponsoredIndex
(
)
{
await
doSponsoredPriorityTest
(
{
nimbusSettings
:
{
quickSuggestSponsoredIndex
:
2
}
searchWord
:
SPONSORED_SEARCH_STRING
remoteSettingsData
:
[
REMOTE_SETTINGS_RESULTS
[
0
]
]
expectedMatches
:
[
expectedSponsoredPriorityResult
(
)
]
}
)
;
}
)
;
add_tasks_with_rust
(
async
function
sponsoredPriority_position
(
)
{
await
doSponsoredPriorityTest
(
{
nimbusSettings
:
{
quickSuggestAllowPositionInSuggestions
:
true
}
searchWord
:
SPONSORED_SEARCH_STRING
remoteSettingsData
:
[
Object
.
assign
(
{
}
REMOTE_SETTINGS_RESULTS
[
0
]
{
position
:
2
}
)
]
expectedMatches
:
[
expectedSponsoredPriorityResult
(
)
]
}
)
;
}
)
;
async
function
doSponsoredPriorityTest
(
{
remoteSettingsConfig
=
{
}
nimbusSettings
=
{
}
searchWord
remoteSettingsData
expectedMatches
}
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
nonsponsored
"
true
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
const
cleanUpNimbusEnable
=
await
UrlbarTestUtils
.
initNimbusFeature
(
{
.
.
.
nimbusSettings
quickSuggestSponsoredPriority
:
true
}
)
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
{
type
:
"
data
"
attachment
:
remoteSettingsData
}
]
)
;
await
QuickSuggestTestUtils
.
setConfig
(
remoteSettingsConfig
)
;
await
check_results
(
{
context
:
createContext
(
searchWord
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
expectedMatches
}
)
;
await
cleanUpNimbusEnable
(
)
;
}
add_tasks_with_rust
(
async
function
tabToSearch
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
sponsoredPriority
"
true
)
;
UrlbarPrefs
.
set
(
"
tabToSearch
.
onboard
.
interactionsLeft
"
0
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
let
engineURL
=
https
:
/
/
foo
.
{
SPONSORED_SEARCH_STRING
}
.
com
/
;
let
extension
=
await
SearchTestUtils
.
installSearchExtension
(
{
name
:
"
Test
"
search_url
:
engineURL
}
{
skipUnload
:
true
}
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
"
Test
"
)
;
await
PlacesTestUtils
.
addVisits
(
engineURL
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
Services
.
search
.
defaultEngine
.
getIconURL
(
)
heuristic
:
true
}
)
makeSearchResult
(
context
{
engineName
:
engine
.
name
engineIconUri
:
UrlbarUtils
.
ICON
.
SEARCH_GLASS
uri
:
UrlbarUtils
.
stripPublicSuffixFromHost
(
engine
.
searchUrlDomain
)
providesSearchMode
:
true
query
:
"
"
providerName
:
"
TabToSearch
"
satisfiesAutofillThreshold
:
true
}
)
expectedSponsoredPriorityResult
(
)
makeVisitResult
(
context
{
uri
:
engineURL
title
:
test
visit
for
{
engineURL
}
}
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
extension
.
unload
(
)
;
UrlbarPrefs
.
clear
(
"
tabToSearch
.
onboard
.
interactionsLeft
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
quicksuggest
.
sponsoredPriority
"
)
;
}
)
;
add_tasks_with_rust
(
async
function
position
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
true
)
;
await
QuickSuggestTestUtils
.
forceSync
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
sponsoredPriority
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
allowPositionInSuggestions
"
true
)
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
{
type
:
"
data
"
attachment
:
[
{
.
.
.
REMOTE_SETTINGS_RESULTS
[
0
]
position
:
9
}
]
}
]
)
;
let
context
=
createContext
(
SPONSORED_SEARCH_STRING
{
isPrivate
:
false
}
)
;
let
maxResultCount
=
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
visitResults
=
[
]
;
for
(
let
i
=
0
;
i
<
maxResultCount
;
i
+
+
)
{
let
url
=
http
:
/
/
example
.
com
/
{
SPONSORED_SEARCH_STRING
}
-
{
i
}
;
await
PlacesTestUtils
.
addVisits
(
url
)
;
visitResults
.
unshift
(
makeVisitResult
(
context
{
uri
:
url
title
:
test
visit
for
{
url
}
}
)
)
;
}
await
check_results
(
{
context
matches
:
[
makeSearchResult
(
context
{
engineName
:
Services
.
search
.
defaultEngine
.
name
engineIconUri
:
Services
.
search
.
defaultEngine
.
getIconURL
(
)
heuristic
:
true
}
)
expectedSponsoredPriorityResult
(
)
.
.
.
visitResults
.
slice
(
0
maxResultCount
-
2
)
]
}
)
;
await
cleanupPlaces
(
)
;
await
QuickSuggestTestUtils
.
setRemoteSettingsRecords
(
[
{
type
:
"
data
"
attachment
:
REMOTE_SETTINGS_RESULTS
}
]
)
;
UrlbarPrefs
.
clear
(
"
quicksuggest
.
allowPositionInSuggestions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
suggest
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
quicksuggest
.
sponsoredPriority
"
)
;
}
)
;
