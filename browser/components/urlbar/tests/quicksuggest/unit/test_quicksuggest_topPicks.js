"
use
strict
"
;
const
SUGGESTION_SEARCH_STRING
=
"
example
"
;
const
SUGGESTION_URL
=
"
http
:
/
/
example
.
com
/
"
;
const
SUGGESTION_URL_WWW
=
"
http
:
/
/
www
.
example
.
com
/
"
;
const
MERINO_SUGGESTIONS
=
[
{
is_top_pick
:
true
provider
:
"
top_picks
"
url
:
SUGGESTION_URL
title
:
"
title
"
icon
:
"
icon
"
is_sponsored
:
false
score
:
1
}
]
;
add_setup
(
async
function
init
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
suggest
.
enabled
"
false
)
;
await
QuickSuggestTestUtils
.
ensureQuickSuggestInit
(
{
merinoSuggestions
:
MERINO_SUGGESTIONS
prefs
:
[
[
"
suggest
.
quicksuggest
.
all
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
allDisabled
(
)
{
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
sponsored
"
false
)
;
await
check_results
(
{
context
:
createContext
(
SUGGESTION_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
makeExpectedResult
(
{
isBestMatch
:
true
suggestedIndex
:
1
}
)
]
}
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
all
"
false
)
;
await
check_results
(
{
context
:
createContext
(
SUGGESTION_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
]
isPrivate
:
false
}
)
matches
:
[
]
}
)
;
UrlbarPrefs
.
set
(
"
suggest
.
quicksuggest
.
all
"
true
)
;
UrlbarPrefs
.
clear
(
"
suggest
.
quicksuggest
.
sponsored
"
)
;
}
)
;
add_task
(
async
function
heuristicDeduplication
(
)
{
let
expectedNavSuggestResult
=
makeExpectedResult
(
{
isBestMatch
:
true
suggestedIndex
:
1
dupedHeuristic
:
false
}
)
;
let
scenarios
=
[
[
SUGGESTION_URL
false
]
[
SUGGESTION_URL_WWW
false
]
[
"
http
:
/
/
exampledomain
.
com
/
"
true
]
]
;
let
quickSuggestProviderInstance
=
UrlbarProvidersManager
.
getProvider
(
UrlbarProviderQuickSuggest
.
name
)
;
let
addedResults
=
[
]
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
startQueryStub
=
sandbox
.
stub
(
quickSuggestProviderInstance
"
startQuery
"
)
;
startQueryStub
.
callsFake
(
(
queryContext
add
)
=
>
{
let
fakeAdd
=
(
provider
result
)
=
>
{
addedResults
.
push
(
result
)
;
add
(
provider
result
)
;
}
;
return
startQueryStub
.
wrappedMethod
.
call
(
quickSuggestProviderInstance
queryContext
fakeAdd
)
;
}
)
;
for
(
let
[
url
expectBestMatch
]
of
scenarios
)
{
await
PlacesTestUtils
.
addVisits
(
url
)
;
let
context
=
createContext
(
SUGGESTION_SEARCH_STRING
{
providers
:
[
UrlbarProviderQuickSuggest
.
name
UrlbarProviderAutofill
.
name
]
isPrivate
:
false
}
)
;
const
EXPECTED_AUTOFILL_RESULT
=
makeVisitResult
(
context
{
uri
:
url
title
:
test
visit
for
{
url
}
heuristic
:
true
}
)
;
await
check_results
(
{
context
matches
:
expectBestMatch
?
[
EXPECTED_AUTOFILL_RESULT
expectedNavSuggestResult
]
:
[
EXPECTED_AUTOFILL_RESULT
]
}
)
;
Assert
.
equal
(
addedResults
.
length
1
"
The
provider
should
have
added
one
result
"
)
;
Assert
.
equal
(
!
addedResults
[
0
]
.
payload
.
dupedHeuristic
expectBestMatch
"
dupedHeuristic
should
be
the
opposite
of
expectBestMatch
"
)
;
addedResults
=
[
]
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
sandbox
.
restore
(
)
;
}
)
;
function
makeExpectedResult
(
{
isBestMatch
suggestedIndex
dupedHeuristic
telemetryType
=
"
top_picks
"
}
)
{
let
result
=
{
isBestMatch
suggestedIndex
type
:
UrlbarUtils
.
RESULT_TYPE
.
URL
source
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
heuristic
:
false
payload
:
{
dupedHeuristic
telemetryType
title
:
"
title
"
url
:
SUGGESTION_URL
icon
:
"
icon
"
isSponsored
:
false
shouldShowUrl
:
true
source
:
"
merino
"
provider
:
telemetryType
isBlockable
:
true
isManageable
:
true
}
}
;
if
(
typeof
dupedHeuristic
=
=
"
boolean
"
)
{
result
.
payload
.
dupedHeuristic
=
dupedHeuristic
;
}
return
result
;
}
