"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
QuickSuggestTestUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CONTEXTUAL_SERVICES_PING_TYPES
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
ExperimentAPI
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
ExperimentFakes
:
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
jsm
"
ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
PartnerLinkAttribution
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
jsm
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarQuickSuggest
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
UrlbarTestUtils
"
(
)
=
>
{
const
{
UrlbarTestUtils
:
module
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
jsm
"
)
;
module
.
init
(
QuickSuggestTestUtils
.
_testScope
)
;
return
module
;
}
)
;
const
LEARN_MORE_URL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
firefox
-
suggest
"
;
const
SCALARS
=
{
IMPRESSION
:
"
contextual
.
services
.
quicksuggest
.
impression
"
CLICK
:
"
contextual
.
services
.
quicksuggest
.
click
"
HELP
:
"
contextual
.
services
.
quicksuggest
.
help
"
}
;
const
TELEMETRY_EVENT_CATEGORY
=
"
contextservices
.
quicksuggest
"
;
const
UPDATE_TOPIC
=
"
firefox
-
suggest
-
update
"
;
const
TEST_SCOPE_PROPERTIES
=
[
"
Assert
"
"
EventUtils
"
"
info
"
"
registerCleanupFunction
"
]
;
class
QSTestUtils
{
get
LEARN_MORE_URL
(
)
{
return
LEARN_MORE_URL
;
}
get
SCALARS
(
)
{
return
SCALARS
;
}
get
TELEMETRY_EVENT_CATEGORY
(
)
{
return
TELEMETRY_EVENT_CATEGORY
;
}
get
UPDATE_TOPIC
(
)
{
return
UPDATE_TOPIC
;
}
init
(
scope
)
{
if
(
!
scope
)
{
throw
new
Error
(
"
QuickSuggestTestUtils
.
init
(
)
must
be
called
with
a
scope
"
)
;
}
this
.
_testScope
=
scope
;
for
(
let
p
of
TEST_SCOPE_PROPERTIES
)
{
this
[
p
]
=
scope
[
p
]
;
}
Services
.
telemetry
.
clearScalars
(
)
;
}
uninit
(
)
{
this
.
_testScope
=
null
;
for
(
let
p
of
TEST_SCOPE_PROPERTIES
)
{
this
[
p
]
=
null
;
}
Services
.
telemetry
.
clearScalars
(
)
;
}
async
ensureQuickSuggestInit
(
results
=
null
)
{
this
.
info
?
.
(
"
ensureQuickSuggestInit
awaiting
UrlbarQuickSuggest
.
readyPromise
"
)
;
await
UrlbarQuickSuggest
.
readyPromise
;
this
.
info
?
.
(
"
ensureQuickSuggestInit
done
awaiting
UrlbarQuickSuggest
.
readyPromise
"
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
UrlbarQuickSuggest
"
_queueSettingsSync
"
)
;
let
cleanup
=
(
)
=
>
sandbox
.
restore
(
)
;
this
.
registerCleanupFunction
?
.
(
cleanup
)
;
if
(
results
)
{
UrlbarQuickSuggest
.
_addResults
(
results
)
;
}
return
cleanup
;
}
async
initNimbusFeature
(
)
{
this
.
info
?
.
(
"
initNimbusFeature
awaiting
ExperimentManager
.
onStartup
"
)
;
await
ExperimentManager
.
onStartup
(
)
;
this
.
info
?
.
(
"
initNimbusFeature
awaiting
ExperimentAPI
.
ready
"
)
;
await
ExperimentAPI
.
ready
(
)
;
this
.
info
?
.
(
"
initNimbusFeature
awaiting
ExperimentFakes
.
remoteDefaultsHelper
"
)
;
await
ExperimentFakes
.
remoteDefaultsHelper
(
{
feature
:
NimbusFeatures
.
urlbar
configuration
:
{
slug
:
"
QuickSuggestTestUtils
"
variables
:
{
enabled
:
true
}
targeting
:
"
true
"
}
}
)
;
this
.
info
?
.
(
"
initNimbusFeature
done
"
)
;
}
async
setScenario
(
scenario
)
{
await
this
.
waitForScenarioUpdated
(
)
;
await
UrlbarPrefs
.
updateFirefoxSuggestScenario
(
false
scenario
)
;
}
async
waitForScenarioUpdated
(
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
UrlbarPrefs
.
updatingFirefoxSuggestScenario
"
Waiting
for
updatingFirefoxSuggestScenario
to
be
false
"
)
;
}
async
assertIsQuickSuggest
(
{
url
window
index
=
-
1
isSponsored
=
true
}
=
{
}
)
{
if
(
index
<
0
)
{
index
=
UrlbarTestUtils
.
getResultCount
(
window
)
-
1
;
this
.
Assert
.
greater
(
index
-
1
"
Sanity
check
:
Result
count
should
be
>
0
"
)
;
}
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
this
.
Assert
.
equal
(
details
.
type
UrlbarUtils
.
RESULT_TYPE
.
URL
)
;
this
.
Assert
.
equal
(
details
.
isSponsored
isSponsored
"
Result
isSponsored
"
)
;
this
.
Assert
.
equal
(
details
.
url
url
"
Result
URL
"
)
;
this
.
Assert
.
equal
(
details
.
displayed
.
action
isSponsored
?
"
Sponsored
"
:
"
"
"
Result
action
text
"
)
;
let
helpButton
=
details
.
element
.
row
.
_elements
.
get
(
"
helpButton
"
)
;
this
.
Assert
.
ok
(
helpButton
"
The
help
button
should
be
present
"
)
;
this
.
Assert
.
equal
(
details
.
result
.
payload
.
helpUrl
LEARN_MORE_URL
"
Result
helpURL
"
)
;
return
details
;
}
async
assertIsNotQuickSuggest
(
window
index
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
this
.
Assert
.
notEqual
(
details
.
result
.
providerName
"
UrlbarProviderQuickSuggest
"
Result
at
index
{
index
}
is
not
provided
by
UrlbarProviderQuickSuggest
)
;
}
async
assertNoQuickSuggestResults
(
window
)
{
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
await
this
.
assertIsNotQuickSuggest
(
window
i
)
;
}
}
assertScalars
(
expectedIndexesByScalarName
)
{
let
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
true
true
)
;
for
(
let
scalarName
of
Object
.
values
(
SCALARS
)
)
{
if
(
scalarName
in
expectedIndexesByScalarName
)
{
TelemetryTestUtils
.
assertKeyedScalar
(
scalars
scalarName
expectedIndexesByScalarName
[
scalarName
]
1
)
;
}
else
{
this
.
Assert
.
ok
(
!
(
scalarName
in
scalars
)
"
Scalar
should
not
be
present
:
"
+
scalarName
)
;
}
}
}
createTelemetryPingSpy
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
spy
=
sandbox
.
spy
(
PartnerLinkAttribution
.
_pingCentre
"
sendStructuredIngestionPing
"
)
;
let
spyCleanup
=
(
)
=
>
sandbox
.
restore
(
)
;
this
.
registerCleanupFunction
?
.
(
spyCleanup
)
;
return
{
sandbox
spy
spyCleanup
}
;
}
assertImpressionPing
(
{
index
spy
advertiser
=
"
test
-
advertiser
"
block_id
=
1
search_query
=
undefined
matched_keywords
=
search_query
reporting_url
=
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
"
scenario
=
"
offline
"
}
)
{
let
calls
=
spy
.
getCalls
(
)
.
filter
(
call
=
>
{
let
endpoint
=
call
.
args
[
1
]
;
return
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_IMPRESSION
)
;
}
)
;
this
.
Assert
.
equal
(
calls
.
length
1
"
Sent
one
impression
ping
"
)
;
let
payload
=
calls
[
0
]
.
args
[
0
]
;
let
expectedPayload
=
{
advertiser
block_id
matched_keywords
position
:
index
+
1
reporting_url
scenario
search_query
}
;
let
actualPayload
=
{
}
;
for
(
let
key
of
Object
.
keys
(
expectedPayload
)
)
{
actualPayload
[
key
]
=
payload
[
key
]
;
}
this
.
Assert
.
deepEqual
(
actualPayload
expectedPayload
"
Payload
is
correct
"
)
;
this
.
Assert
.
ok
(
!
!
payload
.
context_id
"
Should
set
the
context_id
"
)
;
}
assertNoImpressionPing
(
spy
)
{
let
calls
=
spy
.
getCalls
(
)
.
filter
(
call
=
>
{
let
endpoint
=
call
.
args
[
1
]
;
return
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_IMPRESSION
)
;
}
)
;
this
.
Assert
.
equal
(
calls
.
length
0
"
Did
not
send
an
impression
ping
"
)
;
}
assertClickPing
(
{
index
spy
advertiser
=
"
test
-
advertiser
"
block_id
=
1
reporting_url
=
"
http
:
/
/
click
.
reporting
.
test
.
com
/
"
scenario
=
"
offline
"
}
)
{
let
calls
=
spy
.
getCalls
(
)
.
filter
(
call
=
>
{
let
endpoint
=
call
.
args
[
1
]
;
return
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_SELECTION
)
;
}
)
;
this
.
Assert
.
equal
(
calls
.
length
1
"
Sent
one
click
ping
"
)
;
let
payload
=
calls
[
0
]
.
args
[
0
]
;
let
expectedPayload
=
{
advertiser
block_id
position
:
index
+
1
reporting_url
scenario
}
;
let
actualPayload
=
{
}
;
for
(
let
key
of
Object
.
keys
(
expectedPayload
)
)
{
actualPayload
[
key
]
=
payload
[
key
]
;
}
this
.
Assert
.
deepEqual
(
actualPayload
expectedPayload
"
Payload
is
correct
"
)
;
this
.
Assert
.
ok
(
!
!
payload
.
context_id
"
Should
set
the
context_id
"
)
;
}
assertNoClickPing
(
spy
)
{
let
calls
=
spy
.
getCalls
(
)
.
filter
(
call
=
>
{
let
endpoint
=
call
.
args
[
1
]
;
return
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_SELECTION
)
;
}
)
;
this
.
Assert
.
equal
(
calls
.
length
0
"
Did
not
send
a
click
ping
"
)
;
}
assertTimestampsReplaced
(
result
urls
)
{
let
template
=
"
%
YYYYMMDDHH
%
"
;
urls
=
{
.
.
.
urls
}
;
for
(
let
[
key
url
]
of
Object
.
entries
(
urls
)
)
{
let
index
=
url
.
indexOf
(
template
)
;
this
.
Assert
.
ok
(
index
>
=
0
Timestamp
template
{
template
}
is
in
URL
{
url
}
for
key
{
key
}
)
;
let
value
=
result
.
payload
[
key
]
;
this
.
Assert
.
ok
(
value
"
Key
is
in
result
payload
:
"
+
key
)
;
let
timestamp
=
value
.
substring
(
index
index
+
template
.
length
-
2
)
;
urls
[
key
]
=
{
url
value
timestamp
}
;
}
this
.
info
?
.
(
"
Parsed
timestamps
:
"
+
JSON
.
stringify
(
urls
)
)
;
let
{
timestamp
}
=
Object
.
values
(
urls
)
[
0
]
;
this
.
Assert
.
deepEqual
(
[
.
.
.
new
Set
(
Object
.
values
(
urls
)
.
map
(
o
=
>
o
.
timestamp
)
)
]
[
timestamp
]
"
There
'
s
only
one
unique
timestamp
string
"
)
;
let
year
=
timestamp
.
slice
(
0
-
6
)
;
let
month
=
timestamp
.
slice
(
-
6
-
4
)
;
let
day
=
timestamp
.
slice
(
-
4
-
2
)
;
let
hour
=
timestamp
.
slice
(
-
2
)
;
let
date
=
new
Date
(
year
month
-
1
day
hour
)
;
this
.
Assert
.
less
(
Date
.
now
(
)
-
2
*
60
*
60
*
1000
date
.
getTime
(
)
"
Timestamp
is
within
the
past
two
hours
"
)
;
}
async
withExperiment
(
{
callback
.
.
.
options
}
)
{
let
doExperimentCleanup
=
await
this
.
enrollExperiment
(
options
)
;
await
callback
(
)
;
await
doExperimentCleanup
(
)
;
}
async
enrollExperiment
(
{
valueOverrides
=
{
}
}
)
{
this
.
info
?
.
(
"
Awaiting
ExperimentAPI
.
ready
"
)
;
await
ExperimentAPI
.
ready
(
)
;
await
this
.
waitForScenarioUpdated
(
)
;
let
updatePromise
=
TestUtils
.
topicObserved
(
QuickSuggestTestUtils
.
UPDATE_TOPIC
)
;
let
doExperimentCleanup
=
await
ExperimentFakes
.
enrollWithFeatureConfig
(
{
enabled
:
true
featureId
:
"
urlbar
"
value
:
valueOverrides
}
)
;
this
.
info
?
.
(
"
Awaiting
update
after
enrolling
in
experiment
"
)
;
await
updatePromise
;
return
async
(
)
=
>
{
let
unenrollUpdatePromise
=
TestUtils
.
topicObserved
(
QuickSuggestTestUtils
.
UPDATE_TOPIC
)
;
this
.
info
?
.
(
"
Awaiting
experiment
cleanup
"
)
;
await
doExperimentCleanup
(
)
;
this
.
info
?
.
(
"
Awaiting
update
after
unenrolling
in
experiment
"
)
;
await
unenrollUpdatePromise
;
}
;
}
}
var
QuickSuggestTestUtils
=
new
QSTestUtils
(
)
;
