"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
QuickSuggestTestUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CONTEXTUAL_SERVICES_PING_TYPES
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
ExperimentAPI
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
ExperimentFakes
:
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
jsm
"
ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
PartnerLinkAttribution
:
"
resource
:
/
/
/
modules
/
PartnerLinkAttribution
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
sinon
:
"
resource
:
/
/
testing
-
common
/
Sinon
.
jsm
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
jsm
"
UrlbarQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarQuickSuggest
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
UrlbarTestUtils
"
(
)
=
>
{
const
{
UrlbarTestUtils
:
module
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
jsm
"
)
;
module
.
init
(
QuickSuggestTestUtils
.
_testScope
)
;
return
module
;
}
)
;
const
DEFAULT_CONFIG
=
{
best_match
:
{
blocked_suggestion_ids
:
[
]
min_search_string_length
:
4
}
}
;
const
LEARN_MORE_URL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
firefox
-
suggest
"
;
const
TELEMETRY_EVENT_CATEGORY
=
"
contextservices
.
quicksuggest
"
;
const
UPDATE_TOPIC
=
"
firefox
-
suggest
-
update
"
;
const
UPDATE_SKIPPED_TOPIC
=
"
firefox
-
suggest
-
update
-
skipped
"
;
const
TEST_SCOPE_PROPERTIES
=
[
"
Assert
"
"
EventUtils
"
"
info
"
"
registerCleanupFunction
"
]
;
class
QSTestUtils
{
get
LEARN_MORE_URL
(
)
{
return
LEARN_MORE_URL
;
}
get
BEST_MATCH_LEARN_MORE_URL
(
)
{
return
UrlbarProviderQuickSuggest
.
bestMatchHelpUrl
;
}
get
SCALARS
(
)
{
return
UrlbarProviderQuickSuggest
.
telemetryScalars
;
}
get
TELEMETRY_EVENT_CATEGORY
(
)
{
return
TELEMETRY_EVENT_CATEGORY
;
}
get
UPDATE_TOPIC
(
)
{
return
UPDATE_TOPIC
;
}
get
UPDATE_SKIPPED_TOPIC
(
)
{
return
UPDATE_SKIPPED_TOPIC
;
}
get
DEFAULT_CONFIG
(
)
{
return
Cu
.
cloneInto
(
DEFAULT_CONFIG
this
)
;
}
init
(
scope
)
{
if
(
!
scope
)
{
throw
new
Error
(
"
QuickSuggestTestUtils
.
init
(
)
must
be
called
with
a
scope
"
)
;
}
this
.
_testScope
=
scope
;
for
(
let
p
of
TEST_SCOPE_PROPERTIES
)
{
this
[
p
]
=
scope
[
p
]
;
}
Services
.
telemetry
.
clearScalars
(
)
;
}
uninit
(
)
{
this
.
_testScope
=
null
;
for
(
let
p
of
TEST_SCOPE_PROPERTIES
)
{
this
[
p
]
=
null
;
}
Services
.
telemetry
.
clearScalars
(
)
;
}
async
ensureQuickSuggestInit
(
results
=
null
config
=
DEFAULT_CONFIG
)
{
this
.
info
?
.
(
"
ensureQuickSuggestInit
awaiting
UrlbarQuickSuggest
.
readyPromise
"
)
;
await
UrlbarQuickSuggest
.
readyPromise
;
this
.
info
?
.
(
"
ensureQuickSuggestInit
done
awaiting
UrlbarQuickSuggest
.
readyPromise
"
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
UrlbarQuickSuggest
"
_queueSettingsSync
"
)
;
let
cleanup
=
(
)
=
>
sandbox
.
restore
(
)
;
this
.
registerCleanupFunction
?
.
(
cleanup
)
;
if
(
results
)
{
UrlbarQuickSuggest
.
_addResults
(
results
)
;
}
if
(
config
)
{
this
.
setConfig
(
config
)
;
}
return
cleanup
;
}
async
initNimbusFeature
(
)
{
this
.
info
?
.
(
"
initNimbusFeature
awaiting
ExperimentManager
.
onStartup
"
)
;
await
ExperimentManager
.
onStartup
(
)
;
this
.
info
?
.
(
"
initNimbusFeature
awaiting
ExperimentAPI
.
ready
"
)
;
await
ExperimentAPI
.
ready
(
)
;
this
.
info
?
.
(
"
initNimbusFeature
awaiting
ExperimentFakes
.
enrollWithRollout
"
)
;
let
doCleanup
=
await
ExperimentFakes
.
enrollWithRollout
(
{
featureId
:
NimbusFeatures
.
urlbar
.
featureId
value
:
{
enabled
:
true
}
}
)
;
this
.
info
?
.
(
"
initNimbusFeature
done
"
)
;
this
.
registerCleanupFunction
(
doCleanup
)
;
}
setConfig
(
config
)
{
UrlbarQuickSuggest
.
_config
=
config
;
}
async
withConfig
(
{
config
callback
}
)
{
this
.
setConfig
(
config
)
;
await
callback
(
)
;
this
.
setConfig
(
DEFAULT_CONFIG
)
;
}
async
setScenario
(
scenario
)
{
await
this
.
waitForScenarioUpdated
(
)
;
await
UrlbarPrefs
.
updateFirefoxSuggestScenario
(
{
scenario
}
)
;
}
async
waitForScenarioUpdated
(
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
UrlbarPrefs
.
updatingFirefoxSuggestScenario
"
Waiting
for
updatingFirefoxSuggestScenario
to
be
false
"
)
;
}
async
assertIsQuickSuggest
(
{
url
originalUrl
window
index
=
-
1
isSponsored
=
true
isBestMatch
=
false
}
=
{
}
)
{
this
.
Assert
.
ok
(
url
|
|
originalUrl
"
At
least
one
of
url
and
originalUrl
is
specified
"
)
;
if
(
index
<
0
)
{
let
resultCount
=
UrlbarTestUtils
.
getResultCount
(
window
)
;
if
(
isBestMatch
)
{
index
=
1
;
this
.
Assert
.
greater
(
resultCount
1
"
Sanity
check
:
Result
count
should
be
>
1
"
)
;
}
else
{
index
=
resultCount
-
1
;
this
.
Assert
.
greater
(
resultCount
0
"
Sanity
check
:
Result
count
should
be
>
0
"
)
;
}
}
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
let
{
result
}
=
details
;
this
.
info
?
.
(
Checking
actual
result
at
index
{
index
}
:
+
JSON
.
stringify
(
result
)
)
;
this
.
Assert
.
equal
(
result
.
providerName
"
UrlbarProviderQuickSuggest
"
"
Result
provider
name
is
UrlbarProviderQuickSuggest
"
)
;
this
.
Assert
.
equal
(
details
.
type
UrlbarUtils
.
RESULT_TYPE
.
URL
)
;
this
.
Assert
.
equal
(
details
.
isSponsored
isSponsored
"
Result
isSponsored
"
)
;
if
(
url
)
{
this
.
Assert
.
equal
(
details
.
url
url
"
Result
URL
"
)
;
}
if
(
originalUrl
)
{
this
.
Assert
.
equal
(
result
.
payload
.
originalUrl
originalUrl
"
Result
original
URL
"
)
;
}
this
.
Assert
.
equal
(
!
!
result
.
isBestMatch
isBestMatch
"
Result
isBestMatch
"
)
;
let
{
row
}
=
details
.
element
;
let
sponsoredElement
=
isBestMatch
?
row
.
_elements
.
get
(
"
bottom
"
)
:
row
.
_elements
.
get
(
"
action
"
)
;
this
.
Assert
.
ok
(
sponsoredElement
"
Result
sponsored
label
element
exists
"
)
;
this
.
Assert
.
equal
(
sponsoredElement
.
textContent
isSponsored
?
"
Sponsored
"
:
"
"
"
Result
sponsored
label
"
)
;
let
helpButton
=
row
.
_buttons
.
get
(
"
help
"
)
;
this
.
Assert
.
ok
(
helpButton
"
The
help
button
should
be
present
"
)
;
this
.
Assert
.
equal
(
result
.
payload
.
helpUrl
LEARN_MORE_URL
"
Result
helpURL
"
)
;
let
blockButton
=
row
.
_buttons
.
get
(
"
block
"
)
;
if
(
!
isBestMatch
)
{
this
.
Assert
.
ok
(
!
blockButton
"
The
block
button
is
not
present
since
the
row
is
not
a
best
match
"
)
;
}
else
if
(
!
UrlbarPrefs
.
get
(
"
bestMatch
.
blockingEnabled
"
)
)
{
this
.
Assert
.
ok
(
!
blockButton
"
The
block
button
is
not
present
since
blocking
is
disabled
"
)
;
}
else
{
this
.
Assert
.
ok
(
blockButton
"
The
block
button
is
present
"
)
;
}
return
details
;
}
async
assertIsNotQuickSuggest
(
window
index
)
{
let
details
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
this
.
Assert
.
notEqual
(
details
.
result
.
providerName
"
UrlbarProviderQuickSuggest
"
Result
at
index
{
index
}
is
not
provided
by
UrlbarProviderQuickSuggest
)
;
}
async
assertNoQuickSuggestResults
(
window
)
{
for
(
let
i
=
0
;
i
<
UrlbarTestUtils
.
getResultCount
(
window
)
;
i
+
+
)
{
await
this
.
assertIsNotQuickSuggest
(
window
i
)
;
}
}
assertScalars
(
expectedIndexesByScalarName
)
{
let
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
true
true
)
;
for
(
let
scalarName
of
Object
.
values
(
this
.
SCALARS
)
)
{
if
(
scalarName
in
expectedIndexesByScalarName
)
{
TelemetryTestUtils
.
assertKeyedScalar
(
scalars
scalarName
expectedIndexesByScalarName
[
scalarName
]
1
)
;
}
else
{
this
.
Assert
.
ok
(
!
(
scalarName
in
scalars
)
"
Scalar
should
not
be
present
:
"
+
scalarName
)
;
}
}
}
createTelemetryPingSpy
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
spy
=
sandbox
.
spy
(
PartnerLinkAttribution
.
_pingCentre
"
sendStructuredIngestionPing
"
)
;
let
spyCleanup
=
(
)
=
>
sandbox
.
restore
(
)
;
this
.
registerCleanupFunction
?
.
(
spyCleanup
)
;
return
{
sandbox
spy
spyCleanup
}
;
}
assertImpressionPing
(
{
index
spy
advertiser
=
"
test
-
advertiser
"
block_id
=
1
is_clicked
=
false
match_type
=
"
firefox
-
suggest
"
reporting_url
=
"
http
:
/
/
impression
.
reporting
.
test
.
com
/
"
request_id
=
null
scenario
=
"
offline
"
}
)
{
let
calls
=
spy
.
getCalls
(
)
.
filter
(
call
=
>
{
let
endpoint
=
call
.
args
[
1
]
;
return
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_IMPRESSION
)
;
}
)
;
this
.
Assert
.
equal
(
calls
.
length
1
"
Sent
one
impression
ping
"
)
;
let
payload
=
calls
[
0
]
.
args
[
0
]
;
this
.
_assertPingPayload
(
payload
{
advertiser
block_id
is_clicked
match_type
position
:
index
+
1
reporting_url
request_id
scenario
context_id
:
actual
=
>
!
!
actual
}
)
;
}
assertNoImpressionPing
(
spy
)
{
let
calls
=
spy
.
getCalls
(
)
.
filter
(
call
=
>
{
let
endpoint
=
call
.
args
[
1
]
;
return
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_IMPRESSION
)
;
}
)
;
this
.
Assert
.
equal
(
calls
.
length
0
"
Did
not
send
an
impression
ping
"
)
;
}
assertClickPing
(
{
index
spy
advertiser
=
"
test
-
advertiser
"
block_id
=
1
match_type
=
"
firefox
-
suggest
"
reporting_url
=
"
http
:
/
/
click
.
reporting
.
test
.
com
/
"
request_id
=
null
scenario
=
"
offline
"
}
)
{
let
calls
=
spy
.
getCalls
(
)
.
filter
(
call
=
>
{
let
endpoint
=
call
.
args
[
1
]
;
return
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_SELECTION
)
;
}
)
;
this
.
Assert
.
equal
(
calls
.
length
1
"
Sent
one
click
ping
"
)
;
let
payload
=
calls
[
0
]
.
args
[
0
]
;
this
.
_assertPingPayload
(
payload
{
advertiser
block_id
match_type
position
:
index
+
1
reporting_url
request_id
scenario
context_id
:
actual
=
>
!
!
actual
}
)
;
}
assertNoClickPing
(
spy
)
{
let
calls
=
spy
.
getCalls
(
)
.
filter
(
call
=
>
{
let
endpoint
=
call
.
args
[
1
]
;
return
endpoint
.
includes
(
CONTEXTUAL_SERVICES_PING_TYPES
.
QS_SELECTION
)
;
}
)
;
this
.
Assert
.
equal
(
calls
.
length
0
"
Did
not
send
a
click
ping
"
)
;
}
_assertPingPayload
(
actualPayload
expectedPayload
)
{
this
.
info
?
.
(
"
Checking
ping
payload
:
"
+
JSON
.
stringify
(
actualPayload
)
)
;
this
.
Assert
.
equal
(
Object
.
entries
(
actualPayload
)
.
length
Object
.
entries
(
expectedPayload
)
.
length
"
Payload
has
expected
number
of
properties
"
)
;
for
(
let
[
key
expectedValue
]
of
Object
.
entries
(
expectedPayload
)
)
{
let
actualValue
=
actualPayload
[
key
]
;
if
(
typeof
expectedValue
=
=
"
function
"
)
{
this
.
Assert
.
ok
(
expectedValue
(
actualValue
)
"
Payload
property
:
"
+
key
)
;
}
else
{
this
.
Assert
.
equal
(
actualValue
expectedValue
"
Payload
property
:
"
+
key
)
;
}
}
}
assertTimestampsReplaced
(
result
urls
)
{
let
{
timestampTemplate
timestampLength
}
=
UrlbarProviderQuickSuggest
;
urls
=
{
.
.
.
urls
}
;
for
(
let
[
key
url
]
of
Object
.
entries
(
urls
)
)
{
let
index
=
url
.
indexOf
(
timestampTemplate
)
;
this
.
Assert
.
ok
(
index
>
=
0
Timestamp
template
{
timestampTemplate
}
is
in
URL
{
url
}
for
key
{
key
}
)
;
let
value
=
result
.
payload
[
key
]
;
this
.
Assert
.
ok
(
value
"
Key
is
in
result
payload
:
"
+
key
)
;
let
timestamp
=
value
.
substring
(
index
index
+
timestampLength
)
;
urls
[
key
]
=
{
url
value
timestamp
}
;
}
this
.
info
?
.
(
"
Parsed
timestamps
:
"
+
JSON
.
stringify
(
urls
)
)
;
let
{
timestamp
}
=
Object
.
values
(
urls
)
[
0
]
;
this
.
Assert
.
deepEqual
(
[
.
.
.
new
Set
(
Object
.
values
(
urls
)
.
map
(
o
=
>
o
.
timestamp
)
)
]
[
timestamp
]
"
There
'
s
only
one
unique
timestamp
string
"
)
;
let
year
=
timestamp
.
slice
(
0
-
6
)
;
let
month
=
timestamp
.
slice
(
-
6
-
4
)
;
let
day
=
timestamp
.
slice
(
-
4
-
2
)
;
let
hour
=
timestamp
.
slice
(
-
2
)
;
let
date
=
new
Date
(
year
month
-
1
day
hour
)
;
this
.
Assert
.
less
(
Date
.
now
(
)
-
2
*
60
*
60
*
1000
date
.
getTime
(
)
"
Timestamp
is
within
the
past
two
hours
"
)
;
}
async
withExperiment
(
{
callback
.
.
.
options
}
)
{
let
doExperimentCleanup
=
await
this
.
enrollExperiment
(
options
)
;
await
callback
(
)
;
await
doExperimentCleanup
(
)
;
}
async
enrollExperiment
(
{
valueOverrides
=
{
}
}
)
{
this
.
info
?
.
(
"
Awaiting
ExperimentAPI
.
ready
"
)
;
await
ExperimentAPI
.
ready
(
)
;
await
this
.
waitForScenarioUpdated
(
)
;
let
updatePromise
=
Promise
.
race
(
[
TestUtils
.
topicObserved
(
QuickSuggestTestUtils
.
UPDATE_TOPIC
)
TestUtils
.
topicObserved
(
QuickSuggestTestUtils
.
UPDATE_SKIPPED_TOPIC
)
]
)
;
let
doExperimentCleanup
=
await
ExperimentFakes
.
enrollWithFeatureConfig
(
{
enabled
:
true
featureId
:
"
urlbar
"
value
:
valueOverrides
}
)
;
this
.
info
?
.
(
"
Awaiting
update
after
enrolling
in
experiment
"
)
;
await
updatePromise
;
return
async
(
)
=
>
{
let
unenrollUpdatePromise
=
Promise
.
race
(
[
TestUtils
.
topicObserved
(
QuickSuggestTestUtils
.
UPDATE_TOPIC
)
TestUtils
.
topicObserved
(
QuickSuggestTestUtils
.
UPDATE_SKIPPED_TOPIC
)
]
)
;
this
.
info
?
.
(
"
Awaiting
experiment
cleanup
"
)
;
await
doExperimentCleanup
(
)
;
this
.
info
?
.
(
"
Awaiting
update
after
unenrolling
in
experiment
"
)
;
await
unenrollUpdatePromise
;
}
;
}
async
clearExposureEvent
(
)
{
await
new
Promise
(
resolve
=
>
Services
.
tm
.
idleDispatchToMainThread
(
resolve
)
)
;
Services
.
telemetry
.
clearEvents
(
)
;
NimbusFeatures
.
urlbar
.
_didSendExposureEvent
=
false
;
UrlbarQuickSuggest
.
_recordedExposureEvent
=
false
;
}
async
assertExposureEvent
(
expectedRecorded
)
{
this
.
Assert
.
equal
(
UrlbarQuickSuggest
.
_recordedExposureEvent
expectedRecorded
"
_recordedExposureEvent
is
correct
"
)
;
let
filter
=
{
category
:
"
normandy
"
method
:
"
expose
"
object
:
"
nimbus_experiment
"
}
;
let
expectedEvents
=
[
]
;
if
(
expectedRecorded
)
{
expectedEvents
.
push
(
{
.
.
.
filter
extra
:
{
branchSlug
:
"
control
"
featureId
:
"
urlbar
"
}
}
)
;
}
await
new
Promise
(
resolve
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
TelemetryTestUtils
.
assertEvents
(
expectedEvents
filter
)
;
resolve
(
)
;
}
)
;
}
)
;
}
}
var
QuickSuggestTestUtils
=
new
QSTestUtils
(
)
;
