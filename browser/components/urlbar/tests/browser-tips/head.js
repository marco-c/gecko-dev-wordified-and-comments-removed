"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
mozapps
/
update
/
tests
/
browser
/
head
.
js
"
this
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
HttpServer
:
"
resource
:
/
/
testing
-
common
/
httpd
.
sys
.
mjs
"
ResetProfile
:
"
resource
:
/
/
gre
/
modules
/
ResetProfile
.
sys
.
mjs
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
UrlbarProviderInterventions
:
"
resource
:
/
/
/
modules
/
UrlbarProviderInterventions
.
sys
.
mjs
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
sys
.
mjs
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
sys
.
mjs
"
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
UrlbarTestUtils
"
(
)
=
>
{
const
{
UrlbarTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
SearchTestUtils
"
(
)
=
>
{
const
{
SearchTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
const
SEARCH_STRINGS
=
{
CLEAR
:
"
firefox
history
"
REFRESH
:
"
firefox
slow
"
UPDATE
:
"
firefox
update
"
}
;
registerCleanupFunction
(
(
)
=
>
{
UrlbarProviderInterventions
.
resetAppUpdater
(
)
;
}
)
;
function
adjustGeneralPaths
(
)
{
let
dirProvider
=
{
getFile
(
aProp
aPersistent
)
{
aPersistent
.
value
=
false
;
if
(
aProp
=
=
XRE_EXECUTABLE_FILE
)
{
let
tempPath
=
Services
.
env
.
get
(
"
MOZ_PROCESS_LOG
"
)
;
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
tempPath
)
;
return
file
;
}
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIDirectoryServiceProvider
"
]
)
}
;
let
ds
=
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIDirectoryService
)
;
try
{
ds
.
QueryInterface
(
Ci
.
nsIProperties
)
.
undefine
(
XRE_EXECUTABLE_FILE
)
;
}
catch
(
_ex
)
{
return
;
}
ds
.
registerProvider
(
dirProvider
)
;
registerCleanupFunction
(
(
)
=
>
{
ds
.
unregisterProvider
(
dirProvider
)
;
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
syncManager
.
resetLock
(
)
;
}
)
;
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
syncManager
.
resetLock
(
)
;
}
async
function
initUpdate
(
params
)
{
Services
.
env
.
set
(
"
MOZ_TEST_SLOW_SKIP_UPDATE_STAGE
"
"
1
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
PREF_APP_UPDATE_DISABLEDFORTESTING
false
]
[
PREF_APP_UPDATE_URL_MANUAL
gDetailsURL
]
]
}
)
;
adjustGeneralPaths
(
)
;
await
setupTestUpdater
(
)
;
let
queryString
=
params
.
queryString
?
params
.
queryString
:
"
"
;
let
updateURL
=
URL_HTTP_UPDATE_SJS
+
"
?
detailsURL
=
"
+
gDetailsURL
+
queryString
+
getVersionParams
(
)
;
if
(
params
.
backgroundUpdate
)
{
setUpdateURL
(
updateURL
)
;
gAUS
.
checkForBackgroundUpdates
(
)
;
if
(
params
.
continueFile
)
{
await
continueFileHandler
(
params
.
continueFile
)
;
}
if
(
params
.
waitForUpdateState
)
{
let
whichUpdate
=
params
.
waitForUpdateState
=
=
STATE_DOWNLOADING
?
"
downloadingUpdate
"
:
"
readyUpdate
"
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
gUpdateManager
[
whichUpdate
]
&
&
gUpdateManager
[
whichUpdate
]
.
state
=
=
params
.
waitForUpdateState
"
Waiting
for
update
state
:
"
+
params
.
waitForUpdateState
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
Assert
.
equal
(
gUpdateManager
[
whichUpdate
]
.
state
params
.
waitForUpdateState
"
The
update
state
value
should
equal
"
+
params
.
waitForUpdateState
)
;
}
}
else
{
updateURL
+
=
"
&
slowUpdateCheck
=
1
&
useSlowDownloadMar
=
1
"
;
setUpdateURL
(
updateURL
)
;
}
}
async
function
processUpdateSteps
(
steps
)
{
for
(
let
step
of
steps
)
{
await
processUpdateStep
(
step
)
;
}
}
async
function
processUpdateStep
(
step
)
{
if
(
typeof
step
=
=
"
function
"
)
{
step
(
)
;
return
;
}
const
{
panelId
checkActiveUpdate
continueFile
downloadInfo
}
=
step
;
if
(
panelId
=
=
"
downloading
"
&
&
gAUS
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
{
await
gAUS
.
stateTransition
;
}
if
(
checkActiveUpdate
)
{
let
whichUpdate
=
checkActiveUpdate
.
state
=
=
STATE_DOWNLOADING
?
"
downloadingUpdate
"
:
"
readyUpdate
"
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
gUpdateManager
[
whichUpdate
]
"
Waiting
for
active
update
"
)
;
Assert
.
ok
(
!
!
gUpdateManager
[
whichUpdate
]
"
There
should
be
an
active
update
"
)
;
Assert
.
equal
(
gUpdateManager
[
whichUpdate
]
.
state
checkActiveUpdate
.
state
"
The
active
update
state
should
equal
"
+
checkActiveUpdate
.
state
)
;
}
else
{
Assert
.
ok
(
!
gUpdateManager
.
readyUpdate
"
There
should
not
be
a
ready
update
"
)
;
Assert
.
ok
(
!
gUpdateManager
.
downloadingUpdate
"
There
should
not
be
a
downloadingUpdate
update
"
)
;
}
if
(
panelId
=
=
"
downloading
"
)
{
for
(
let
i
=
0
;
i
<
downloadInfo
.
length
;
+
+
i
)
{
let
data
=
downloadInfo
[
i
]
;
await
continueFileHandler
(
continueFile
)
;
let
patch
=
getPatchOfType
(
data
.
patchType
gUpdateManager
.
downloadingUpdate
)
;
let
isLastPatch
=
i
=
=
downloadInfo
.
length
-
1
;
if
(
!
isLastPatch
|
|
patch
)
{
let
resultName
=
data
.
bitsResult
?
"
bitsResult
"
:
"
internalResult
"
;
patch
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
patch
.
getProperty
(
resultName
)
=
=
data
[
resultName
]
"
Waiting
for
expected
patch
property
"
+
resultName
+
"
value
:
"
+
data
[
resultName
]
undefined
200
)
.
catch
(
e
=
>
{
logTestInfo
(
e
)
;
}
)
;
Assert
.
equal
(
patch
.
getProperty
(
resultName
)
data
[
resultName
]
"
The
patch
property
"
+
resultName
+
"
value
should
equal
"
+
data
[
resultName
]
)
;
}
}
}
else
if
(
continueFile
)
{
await
continueFileHandler
(
continueFile
)
;
}
}
async
function
doUpdateTest
(
{
searchString
tip
title
button
awaitCallback
}
=
{
}
)
{
let
[
result
element
]
=
await
awaitTip
(
searchString
)
;
Assert
.
strictEqual
(
result
.
payload
.
type
tip
"
Tip
type
"
)
;
await
element
.
ownerDocument
.
l10n
.
translateFragment
(
element
)
;
let
actualTitle
=
element
.
_elements
.
get
(
"
title
"
)
.
textContent
;
if
(
typeof
title
=
=
"
string
"
)
{
Assert
.
equal
(
actualTitle
title
"
Title
string
"
)
;
}
else
{
Assert
.
ok
(
title
.
test
(
actualTitle
)
"
Title
regexp
"
)
;
}
let
actualButton
=
element
.
_buttons
.
get
(
"
0
"
)
.
textContent
;
if
(
typeof
button
=
=
"
string
"
)
{
Assert
.
equal
(
actualButton
button
"
Button
string
"
)
;
}
else
{
Assert
.
ok
(
button
.
test
(
actualButton
)
"
Button
regexp
"
)
;
}
Assert
.
ok
(
element
.
_buttons
.
has
(
"
menu
"
)
"
Tip
has
a
menu
button
"
)
;
let
values
=
await
Promise
.
all
(
[
awaitCallback
(
)
pickTip
(
)
]
)
;
const
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
true
true
)
;
TelemetryTestUtils
.
assertKeyedScalar
(
scalars
"
urlbar
.
tips
"
{
tip
}
-
shown
1
)
;
TelemetryTestUtils
.
assertKeyedScalar
(
scalars
"
urlbar
.
tips
"
{
tip
}
-
picked
1
)
;
return
values
[
0
]
|
|
null
;
}
async
function
awaitTip
(
searchString
win
=
window
)
{
let
context
=
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
:
win
value
:
searchString
waitForFocus
fireInputEvent
:
true
}
)
;
Assert
.
ok
(
context
.
results
.
length
>
=
2
"
Number
of
results
is
greater
than
or
equal
to
2
"
)
;
let
result
=
context
.
results
[
1
]
;
Assert
.
equal
(
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
TIP
"
Result
type
"
)
;
let
element
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
win
1
)
;
return
[
result
element
]
;
}
async
function
pickTip
(
)
{
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
1
)
;
let
button
=
result
.
element
.
row
.
_buttons
.
get
(
"
0
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
{
EventUtils
.
synthesizeMouseAtCenter
(
button
{
}
)
;
}
)
;
}
async
function
awaitAppRestartRequest
(
)
{
await
TestUtils
.
topicObserved
(
"
quit
-
application
-
requested
"
(
cancelQuit
data
)
=
>
{
if
(
data
=
=
"
restart
"
)
{
cancelQuit
.
QueryInterface
(
Ci
.
nsISupportsPRBool
)
.
data
=
true
;
return
true
;
}
return
false
;
}
)
;
}
function
makeProfileResettable
(
)
{
let
profileService
=
Cc
[
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
]
.
getService
(
Ci
.
nsIToolkitProfileService
)
;
let
currentProfileDir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
let
profileName
=
"
mochitest
-
test
-
profile
-
temp
-
"
+
Date
.
now
(
)
;
let
tempProfile
=
profileService
.
createProfile
(
currentProfileDir
profileName
)
;
Assert
.
ok
(
ResetProfile
.
resetSupported
(
)
"
Should
be
able
to
reset
from
mochitest
'
s
temporary
profile
once
it
'
s
in
the
profile
manager
.
"
)
;
registerCleanupFunction
(
(
)
=
>
{
tempProfile
.
remove
(
false
)
;
Assert
.
ok
(
!
ResetProfile
.
resetSupported
(
)
"
Shouldn
'
t
be
able
to
reset
from
mochitest
'
s
temporary
profile
once
removed
from
the
profile
manager
.
"
)
;
}
)
;
}
function
checkIntervention
(
{
searchString
tip
title
button
awaitCallback
}
=
{
}
)
{
return
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
(
)
=
>
{
let
[
result
element
]
=
await
awaitTip
(
searchString
)
;
Assert
.
strictEqual
(
result
.
payload
.
type
tip
)
;
await
element
.
ownerDocument
.
l10n
.
translateFragment
(
element
)
;
let
actualTitle
=
element
.
_elements
.
get
(
"
title
"
)
.
textContent
;
if
(
typeof
title
=
=
"
string
"
)
{
Assert
.
equal
(
actualTitle
title
"
Title
string
"
)
;
}
else
{
Assert
.
ok
(
title
.
test
(
actualTitle
)
"
Title
regexp
"
)
;
}
let
actualButton
=
element
.
_buttons
.
get
(
"
0
"
)
.
textContent
;
if
(
typeof
button
=
=
"
string
"
)
{
Assert
.
equal
(
actualButton
button
"
Button
string
"
)
;
}
else
{
Assert
.
ok
(
button
.
test
(
actualButton
)
"
Button
regexp
"
)
;
}
let
menuButton
=
element
.
_buttons
.
get
(
"
menu
"
)
;
Assert
.
ok
(
menuButton
"
Menu
button
exists
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
menuButton
)
"
Menu
button
is
visible
"
)
;
let
values
=
await
Promise
.
all
(
[
awaitCallback
(
)
pickTip
(
)
]
)
;
Assert
.
ok
(
true
"
Refresh
dialog
opened
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
window
(
)
=
>
gURLBar
.
blur
(
)
)
;
const
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
true
true
)
;
TelemetryTestUtils
.
assertKeyedScalar
(
scalars
"
urlbar
.
tips
"
{
tip
}
-
shown
1
)
;
TelemetryTestUtils
.
assertKeyedScalar
(
scalars
"
urlbar
.
tips
"
{
tip
}
-
picked
1
)
;
return
values
[
0
]
|
|
null
;
}
)
;
}
async
function
awaitNoTip
(
searchString
win
=
window
)
{
let
context
=
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
:
win
value
:
searchString
waitForFocus
fireInputEvent
:
true
}
)
;
for
(
let
result
of
context
.
results
)
{
Assert
.
notEqual
(
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
;
}
}
async
function
checkTip
(
win
expectedTip
closeView
=
true
)
{
if
(
!
expectedTip
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
Assert
.
ok
(
!
win
.
gURLBar
.
view
.
isOpen
"
View
is
not
open
"
)
;
return
;
}
await
UrlbarTestUtils
.
promisePopupOpen
(
win
(
)
=
>
{
}
)
;
Assert
.
ok
(
true
"
View
opened
"
)
;
Assert
.
equal
(
UrlbarTestUtils
.
getResultCount
(
win
)
1
"
Number
of
results
"
)
;
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
win
0
)
;
Assert
.
equal
(
result
.
type
UrlbarUtils
.
RESULT_TYPE
.
TIP
"
Result
type
"
)
;
let
heuristic
;
let
title
;
let
name
=
Services
.
search
.
defaultEngine
.
name
;
switch
(
expectedTip
)
{
case
UrlbarProviderSearchTips
.
TIP_TYPE
.
ONBOARD
:
heuristic
=
true
;
title
=
Type
less
find
more
:
Search
{
name
}
right
from
your
+
address
bar
.
;
break
;
case
UrlbarProviderSearchTips
.
TIP_TYPE
.
REDIRECT
:
heuristic
=
false
;
title
=
Start
your
search
in
the
address
bar
to
see
suggestions
from
+
{
name
}
and
your
browsing
history
.
;
break
;
case
UrlbarProviderSearchTips
.
TIP_TYPE
.
PERSIST
:
heuristic
=
false
;
title
=
"
Searching
just
got
simpler
.
"
+
"
Try
making
your
search
more
specific
here
in
the
address
bar
.
"
+
"
To
show
the
URL
instead
visit
Search
in
settings
.
"
;
break
;
}
Assert
.
equal
(
result
.
heuristic
heuristic
"
Result
is
heuristic
"
)
;
Assert
.
equal
(
result
.
displayed
.
title
title
"
Title
"
)
;
Assert
.
equal
(
result
.
element
.
row
.
_buttons
.
get
(
"
0
"
)
.
textContent
expectedTip
=
=
UrlbarProviderSearchTips
.
TIP_TYPE
.
PERSIST
?
Got
it
:
Okay
Got
It
"
Button
text
"
)
;
Assert
.
ok
(
!
result
.
element
.
row
.
_buttons
.
has
(
"
help
"
)
"
Buttons
in
row
does
not
include
help
"
)
;
const
scalars
=
TelemetryTestUtils
.
getProcessScalars
(
"
parent
"
true
true
)
;
TelemetryTestUtils
.
assertKeyedScalar
(
scalars
"
urlbar
.
tips
"
{
expectedTip
}
-
shown
1
)
;
Assert
.
ok
(
!
UrlbarTestUtils
.
getOneOffSearchButtonsVisible
(
window
)
"
One
-
offs
should
be
hidden
when
showing
a
search
tip
"
)
;
if
(
closeView
)
{
await
UrlbarTestUtils
.
promisePopupClose
(
win
)
;
}
}
function
makeTipResult
(
{
buttonUrl
helpUrl
=
undefined
}
)
{
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
TIP
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
{
helpUrl
type
:
"
test
"
titleL10n
:
{
id
:
"
urlbar
-
search
-
tips
-
confirm
"
}
buttons
:
[
{
url
:
buttonUrl
l10n
:
{
id
:
"
urlbar
-
search
-
tips
-
confirm
"
}
}
]
}
)
;
}
async
function
checkTab
(
win
url
expectedTip
reset
=
true
)
{
let
shownCount
;
if
(
expectedTip
)
{
shownCount
=
UrlbarPrefs
.
get
(
tipShownCount
.
{
expectedTip
}
)
;
}
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
:
win
.
gBrowser
url
waitForLoad
:
url
!
=
"
about
:
newtab
"
}
)
;
await
checkTip
(
win
expectedTip
true
)
;
if
(
expectedTip
)
{
Assert
.
equal
(
UrlbarPrefs
.
get
(
tipShownCount
.
{
expectedTip
}
)
shownCount
+
1
"
The
shownCount
pref
should
have
been
incremented
by
one
.
"
)
;
}
if
(
reset
)
{
resetSearchTipsProvider
(
)
;
}
BrowserTestUtils
.
removeTab
(
tab
)
;
}
async
function
withDNSRedirect
(
domain
path
callback
)
{
const
certOverrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
stricttransportsecurity
.
preloadlist
"
false
)
;
Services
.
prefs
.
setIntPref
(
"
security
.
cert_pinning
.
enforcement_level
"
0
)
;
certOverrideService
.
setDisableAllSecurityChecksAndLetAttackersInterceptMyData
(
true
)
;
Services
.
prefs
.
setCharPref
(
"
network
.
dns
.
localDomains
"
domain
)
;
let
server
=
new
HttpServer
(
)
;
server
.
registerPathHandler
(
path
(
req
resp
)
=
>
{
resp
.
write
(
Test
!
http
:
/
/
{
domain
}
{
path
}
)
;
}
)
;
server
.
start
(
-
1
)
;
server
.
identity
.
setPrimary
(
"
http
"
domain
server
.
identity
.
primaryPort
)
;
let
url
=
http
:
/
/
{
domain
}
:
{
server
.
identity
.
primaryPort
}
{
path
}
;
await
callback
(
url
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
dns
.
localDomains
"
)
;
await
new
Promise
(
resolve
=
>
server
.
stop
(
resolve
)
)
;
certOverrideService
.
setDisableAllSecurityChecksAndLetAttackersInterceptMyData
(
false
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
stricttransportsecurity
.
preloadlist
"
)
;
Services
.
prefs
.
clearUserPref
(
"
security
.
cert_pinning
.
enforcement_level
"
)
;
const
sss
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
sss
.
clearAll
(
)
;
}
function
resetSearchTipsProvider
(
)
{
Services
.
prefs
.
clearUserPref
(
browser
.
urlbar
.
tipShownCount
.
{
UrlbarProviderSearchTips
.
TIP_TYPE
.
ONBOARD
}
)
;
Services
.
prefs
.
clearUserPref
(
browser
.
urlbar
.
tipShownCount
.
{
UrlbarProviderSearchTips
.
TIP_TYPE
.
PERSIST
}
)
;
Services
.
prefs
.
clearUserPref
(
browser
.
urlbar
.
tipShownCount
.
{
UrlbarProviderSearchTips
.
TIP_TYPE
.
REDIRECT
}
)
;
UrlbarProviderSearchTips
.
disableTipsForCurrentSession
=
false
;
}
async
function
setDefaultEngine
(
name
)
{
let
engine
=
(
await
Services
.
search
.
getEngines
(
)
)
.
find
(
e
=
>
e
.
name
=
=
name
)
;
Assert
.
ok
(
engine
)
;
await
Services
.
search
.
setDefault
(
engine
Ci
.
nsISearchService
.
CHANGE_REASON_UNKNOWN
)
;
}
