"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxerUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Urlbar
.
Muxer
.
UnifiedComplete
"
)
)
;
function
groupFromResult
(
result
)
{
if
(
result
.
heuristic
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
;
}
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
return
result
.
payload
.
suggestion
?
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
;
default
:
return
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
}
}
class
MuxerUnifiedComplete
extends
UrlbarMuxer
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
sort
(
context
)
{
for
(
let
providerName
of
context
.
activeProviders
)
{
let
provider
=
UrlbarProvidersManager
.
getProvider
(
providerName
)
;
if
(
provider
.
type
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
&
&
!
context
.
heuristicResult
)
{
return
false
;
}
}
let
heuristicResultQuery
;
if
(
context
.
heuristicResult
&
&
context
.
heuristicResult
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
context
.
heuristicResult
.
payload
.
query
)
{
heuristicResultQuery
=
context
.
heuristicResult
.
payload
.
query
.
toLocaleLowerCase
(
)
;
}
let
canShowPrivateSearch
=
context
.
results
.
length
>
1
;
let
resultsWithSuggestedIndex
=
[
]
;
for
(
let
result
of
context
.
results
)
{
if
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
payload
.
keywordOffer
|
|
(
result
.
heuristic
&
&
result
.
payload
.
keyword
)
)
{
canShowPrivateSearch
=
false
;
break
;
}
}
let
unsortedResults
=
[
]
;
for
(
let
result
of
context
.
results
)
{
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
inPrivateWindow
&
&
!
canShowPrivateSearch
)
{
continue
;
}
if
(
result
.
suggestedIndex
>
=
0
)
{
resultsWithSuggestedIndex
.
push
(
result
)
;
continue
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
suggestion
&
&
result
.
payload
.
suggestion
.
toLocaleLowerCase
(
)
=
=
=
heuristicResultQuery
)
{
continue
;
}
unsortedResults
.
push
(
result
)
;
}
let
buckets
=
context
.
heuristicResult
&
&
context
.
heuristicResult
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
?
UrlbarPrefs
.
get
(
"
matchBucketsSearch
"
)
:
UrlbarPrefs
.
get
(
"
matchBuckets
"
)
;
logger
.
debug
(
Buckets
:
{
buckets
}
)
;
let
sortedResults
=
[
]
;
let
handledResults
=
new
Set
(
)
;
let
count
=
Math
.
min
(
unsortedResults
.
length
context
.
maxResults
)
;
for
(
let
b
=
0
;
handledResults
.
size
<
count
&
&
b
<
buckets
.
length
;
b
+
+
)
{
let
[
group
slotCount
]
=
buckets
[
b
]
;
for
(
let
i
=
0
;
slotCount
&
&
handledResults
.
size
<
count
&
&
i
<
unsortedResults
.
length
;
i
+
+
)
{
let
result
=
unsortedResults
[
i
]
;
if
(
!
handledResults
.
has
(
result
)
&
&
group
=
=
groupFromResult
(
result
)
)
{
sortedResults
.
push
(
result
)
;
handledResults
.
add
(
result
)
;
slotCount
-
-
;
}
}
}
resultsWithSuggestedIndex
.
sort
(
(
a
b
)
=
>
a
.
suggestedIndex
-
b
.
suggestedIndex
)
;
for
(
let
result
of
resultsWithSuggestedIndex
)
{
let
index
=
result
.
suggestedIndex
<
=
sortedResults
.
length
?
result
.
suggestedIndex
:
sortedResults
.
length
;
sortedResults
.
splice
(
index
0
result
)
;
}
context
.
results
=
sortedResults
;
return
true
;
}
}
var
UrlbarMuxerUnifiedComplete
=
new
MuxerUnifiedComplete
(
)
;
