"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxerUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Urlbar
.
Muxer
.
UnifiedComplete
"
)
)
;
const
RESULT_TYPE_TO_GROUP
=
new
Map
(
[
[
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
[
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
]
[
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
[
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
[
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
]
[
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
[
UrlbarUtils
.
RESULT_TYPE
.
TIP
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
]
)
;
class
MuxerUnifiedComplete
extends
UrlbarMuxer
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
sort
(
context
)
{
if
(
!
context
.
results
.
length
)
{
return
;
}
let
heuristicResult
=
context
.
results
.
find
(
r
=
>
r
.
heuristic
)
;
let
buckets
=
context
.
preselected
&
&
heuristicResult
&
&
heuristicResult
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
?
UrlbarPrefs
.
get
(
"
matchBucketsSearch
"
)
:
UrlbarPrefs
.
get
(
"
matchBuckets
"
)
;
logger
.
debug
(
Buckets
:
{
buckets
}
)
;
let
reshuffleResults
=
context
.
results
.
filter
(
r
=
>
r
.
suggestedIndex
!
=
-
1
)
.
sort
(
(
a
b
)
=
>
a
.
suggestedIndex
-
b
.
suggestedIndex
)
;
let
sortedResults
=
[
]
;
let
handled
=
new
Set
(
)
;
for
(
let
[
group
slots
]
of
buckets
)
{
for
(
let
result
of
context
.
results
)
{
if
(
slots
=
=
0
)
{
break
;
}
if
(
handled
.
has
(
result
)
)
{
continue
;
}
if
(
group
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
&
&
result
=
=
heuristicResult
&
&
context
.
preselected
)
{
sortedResults
.
unshift
(
result
)
;
handled
.
add
(
result
)
;
context
.
maxResults
-
=
UrlbarUtils
.
getSpanForResult
(
result
)
-
1
;
slots
-
-
;
}
else
if
(
group
=
=
RESULT_TYPE_TO_GROUP
.
get
(
result
.
type
)
)
{
if
(
result
.
suggestedIndex
=
=
-
1
)
{
sortedResults
.
push
(
result
)
;
}
handled
.
add
(
result
)
;
context
.
maxResults
-
=
UrlbarUtils
.
getSpanForResult
(
result
)
-
1
;
slots
-
-
;
}
else
if
(
!
RESULT_TYPE_TO_GROUP
.
has
(
result
.
type
)
)
{
let
errorMsg
=
Result
type
{
result
.
type
}
is
not
mapped
to
a
match
group
.
;
logger
.
error
(
errorMsg
)
;
Cu
.
reportError
(
errorMsg
)
;
}
}
}
for
(
let
result
of
reshuffleResults
)
{
if
(
sortedResults
.
length
>
=
result
.
suggestedIndex
)
{
sortedResults
.
splice
(
result
.
suggestedIndex
0
result
)
;
}
else
{
sortedResults
.
push
(
result
)
;
}
}
context
.
results
=
sortedResults
;
}
}
var
UrlbarMuxerUnifiedComplete
=
new
MuxerUnifiedComplete
(
)
;
