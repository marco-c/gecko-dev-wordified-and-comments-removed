"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxerUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProviderTabToSearch
:
"
resource
:
/
/
/
modules
/
UrlbarProviderTabToSearch
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
UrlbarUtils
.
getLogger
(
{
prefix
:
"
MuxerUnifiedComplete
"
}
)
)
;
class
MuxerUnifiedComplete
extends
UrlbarMuxer
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
sort
(
context
)
{
let
state
=
{
context
resultsByGroup
:
new
Map
(
)
availableResultSpan
:
context
.
maxResults
usedResultSpan
:
0
strippedUrlToTopPrefixAndTitle
:
new
Map
(
)
urlToTabResultType
:
new
Map
(
)
addedRemoteTabUrls
:
new
Set
(
)
canShowPrivateSearch
:
context
.
results
.
length
>
1
canShowTailSuggestions
:
true
suggestions
:
new
Set
(
)
canAddTabToSearch
:
true
hasUnitConversionResult
:
false
}
;
for
(
let
result
of
context
.
results
)
{
if
(
result
.
providerName
=
=
"
UrlbarProviderQuickSuggest
"
)
{
state
.
quickSuggestResult
=
result
;
this
.
_updateStatePreAdd
(
result
state
)
;
continue
;
}
let
group
=
UrlbarUtils
.
getResultGroup
(
result
)
;
let
results
=
state
.
resultsByGroup
.
get
(
group
)
;
if
(
!
results
)
{
results
=
[
]
;
state
.
resultsByGroup
.
set
(
group
results
)
;
}
results
.
push
(
result
)
;
this
.
_updateStatePreAdd
(
result
state
)
;
}
let
suggestedIndexResults
=
state
.
resultsByGroup
.
get
(
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTED_INDEX
)
;
if
(
suggestedIndexResults
)
{
let
span
=
suggestedIndexResults
.
reduce
(
(
sum
result
)
=
>
{
if
(
this
.
_canAddResult
(
result
state
)
)
{
sum
+
=
UrlbarUtils
.
getSpanForResult
(
result
)
;
}
return
sum
;
}
0
)
;
state
.
availableResultSpan
=
Math
.
max
(
state
.
availableResultSpan
-
span
0
)
;
}
let
rootBucket
=
context
.
searchMode
?
.
engineName
?
UrlbarPrefs
.
makeResultBuckets
(
{
showSearchSuggestionsFirst
:
true
}
)
:
UrlbarPrefs
.
get
(
"
resultBuckets
"
)
;
logger
.
debug
(
Buckets
:
{
rootBucket
}
)
;
let
[
sortedResults
]
=
this
.
_fillBuckets
(
rootBucket
state
.
availableResultSpan
state
)
;
this
.
_addSuggestedIndexResults
(
sortedResults
state
)
;
context
.
results
=
sortedResults
;
}
_copyState
(
state
)
{
let
copy
=
Object
.
assign
(
{
}
state
{
resultsByGroup
:
new
Map
(
)
strippedUrlToTopPrefixAndTitle
:
new
Map
(
state
.
strippedUrlToTopPrefixAndTitle
)
urlToTabResultType
:
new
Map
(
state
.
urlToTabResultType
)
addedRemoteTabUrls
:
new
Set
(
state
.
addedRemoteTabUrls
)
suggestions
:
new
Set
(
state
.
suggestions
)
}
)
;
for
(
let
[
group
results
]
of
state
.
resultsByGroup
)
{
copy
.
resultsByGroup
.
set
(
group
[
.
.
.
results
]
)
;
}
return
copy
;
}
_fillBuckets
(
bucket
availableSpan
state
)
{
if
(
!
bucket
.
children
)
{
return
this
.
_addResults
(
bucket
.
group
availableSpan
state
)
;
}
let
stateCopy
;
let
flexSum
=
0
;
let
unfilledChildIndexes
=
[
]
;
let
unfilledChildSpan
=
0
;
if
(
bucket
.
flexChildren
)
{
stateCopy
=
this
.
_copyState
(
state
)
;
for
(
let
child
of
bucket
.
children
)
{
let
flex
=
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
;
flexSum
+
=
flex
;
}
}
let
flexSumFilled
=
flexSum
;
let
results
=
[
]
;
let
usedSpan
=
0
;
for
(
let
i
=
0
;
i
<
bucket
.
children
.
length
&
&
usedSpan
<
availableSpan
;
i
+
+
)
{
let
child
=
bucket
.
children
[
i
]
;
let
availableChildSpan
;
if
(
bucket
.
flexChildren
)
{
let
flex
=
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
;
availableChildSpan
=
Math
.
round
(
availableSpan
*
(
flex
/
flexSum
)
)
;
}
else
{
availableChildSpan
=
Math
.
min
(
typeof
child
.
maxResultCount
=
=
"
number
"
?
child
.
maxResultCount
:
Infinity
availableSpan
-
usedSpan
)
;
}
let
[
childResults
usedChildSpan
]
=
this
.
_fillBuckets
(
child
availableChildSpan
state
)
;
results
=
results
.
concat
(
childResults
)
;
usedSpan
+
=
usedChildSpan
;
if
(
bucket
.
flexChildren
&
&
usedChildSpan
<
availableChildSpan
)
{
let
flex
=
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
;
flexSumFilled
-
=
flex
;
unfilledChildIndexes
.
push
(
i
)
;
unfilledChildSpan
+
=
usedChildSpan
;
}
}
if
(
unfilledChildIndexes
.
length
)
{
results
=
[
]
;
usedSpan
=
0
;
let
remainingSpan
=
availableSpan
-
unfilledChildSpan
;
for
(
let
i
=
0
;
i
<
bucket
.
children
.
length
&
&
usedSpan
<
availableSpan
;
i
+
+
)
{
let
child
=
bucket
.
children
[
i
]
;
let
availableChildSpan
;
if
(
unfilledChildIndexes
.
length
&
&
i
=
=
unfilledChildIndexes
[
0
]
)
{
unfilledChildIndexes
.
shift
(
)
;
availableChildSpan
=
availableSpan
;
}
else
{
let
flex
=
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
;
availableChildSpan
=
flex
?
Math
.
round
(
remainingSpan
*
(
flex
/
flexSumFilled
)
)
:
remainingSpan
;
}
let
[
childResults
usedChildSpan
]
=
this
.
_fillBuckets
(
child
availableChildSpan
stateCopy
)
;
results
=
results
.
concat
(
childResults
)
;
usedSpan
+
=
usedChildSpan
;
}
for
(
let
[
key
value
]
of
Object
.
entries
(
stateCopy
)
)
{
state
[
key
]
=
value
;
}
}
return
[
results
usedSpan
]
;
}
_addResults
(
group
availableSpan
state
)
{
if
(
group
=
=
UrlbarUtils
.
RESULT_GROUP
.
FORM_HISTORY
&
&
!
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
)
{
availableSpan
=
0
;
}
let
addQuickSuggest
=
state
.
quickSuggestResult
&
&
group
=
=
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
&
&
this
.
_canAddResult
(
state
.
quickSuggestResult
state
)
;
if
(
addQuickSuggest
)
{
availableSpan
-
=
UrlbarUtils
.
getSpanForResult
(
state
.
quickSuggestResult
)
;
}
let
addedResults
=
[
]
;
let
usedSpan
=
0
;
let
groupResults
=
state
.
resultsByGroup
.
get
(
group
)
;
while
(
groupResults
?
.
length
&
&
usedSpan
<
availableSpan
&
&
state
.
usedResultSpan
<
state
.
availableResultSpan
)
{
let
result
=
groupResults
[
0
]
;
if
(
this
.
_canAddResult
(
result
state
)
)
{
let
span
=
UrlbarUtils
.
getSpanForResult
(
result
)
;
let
newUsedSpan
=
usedSpan
+
span
;
if
(
availableSpan
<
newUsedSpan
&
&
!
result
.
heuristic
)
{
break
;
}
addedResults
.
push
(
result
)
;
usedSpan
=
newUsedSpan
;
state
.
usedResultSpan
+
=
span
;
this
.
_updateStatePostAdd
(
result
state
)
;
}
groupResults
.
shift
(
)
;
}
if
(
addQuickSuggest
)
{
let
{
quickSuggestResult
}
=
state
;
state
.
quickSuggestResult
=
null
;
let
index
=
UrlbarPrefs
.
get
(
quickSuggestResult
.
payload
.
sponsoredText
?
"
quickSuggestNonSponsoredIndex
"
:
"
quickSuggestSponsoredIndex
"
)
;
if
(
index
<
0
)
{
index
=
Math
.
max
(
index
+
addedResults
.
length
+
1
0
)
;
}
else
{
index
=
Math
.
min
(
index
addedResults
.
length
)
;
}
addedResults
.
splice
(
index
0
quickSuggestResult
)
;
let
span
=
UrlbarUtils
.
getSpanForResult
(
quickSuggestResult
)
;
usedSpan
+
=
span
;
state
.
usedResultSpan
+
=
span
;
this
.
_updateStatePostAdd
(
quickSuggestResult
state
)
;
}
return
[
addedResults
usedSpan
]
;
}
_canAddResult
(
result
state
)
{
if
(
!
result
.
heuristic
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
)
{
let
[
strippedUrl
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
}
)
;
let
topPrefixData
=
state
.
strippedUrlToTopPrefixAndTitle
.
get
(
strippedUrl
)
;
if
(
topPrefixData
&
&
(
prefix
!
=
topPrefixData
.
prefix
|
|
result
.
providerName
!
=
topPrefixData
.
providerName
)
)
{
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
if
(
(
prefixRank
<
topPrefixData
.
rank
&
&
(
prefix
.
endsWith
(
"
www
.
"
)
=
=
topPrefixData
.
prefix
.
endsWith
(
"
www
.
"
)
|
|
result
.
payload
?
.
title
=
=
topPrefixData
.
title
)
)
|
|
(
prefix
=
=
topPrefixData
.
prefix
&
&
result
.
providerName
!
=
topPrefixData
.
providerName
)
)
{
return
false
;
}
}
}
if
(
state
.
context
.
heuristicResult
&
&
state
.
context
.
heuristicResult
.
providerName
=
=
"
Autofill
"
&
&
result
.
providerName
!
=
"
Autofill
"
&
&
state
.
context
.
heuristicResult
.
payload
?
.
url
=
=
result
.
payload
.
url
&
&
state
.
context
.
heuristicResult
.
type
=
=
result
.
type
)
{
return
false
;
}
if
(
!
result
.
heuristic
&
&
result
.
providerName
=
=
"
HeuristicFallback
"
&
&
state
.
context
.
heuristicResult
?
.
providerName
!
=
"
HeuristicFallback
"
)
{
return
false
;
}
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
if
(
!
state
.
canAddTabToSearch
)
{
return
false
;
}
if
(
!
result
.
payload
.
satisfiesAutofillThreshold
)
{
if
(
!
state
.
context
.
heuristicResult
|
|
state
.
context
.
heuristicResult
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
URL
|
|
!
state
.
context
.
heuristicResult
.
autofill
)
{
return
false
;
}
let
autofillHostname
=
new
URL
(
state
.
context
.
heuristicResult
.
payload
.
url
)
.
hostname
;
let
[
autofillDomain
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
autofillHostname
{
stripWww
:
true
}
)
;
autofillDomain
=
UrlbarUtils
.
stripPublicSuffixFromHost
(
autofillDomain
)
;
if
(
!
autofillDomain
)
{
return
false
;
}
let
[
engineDomain
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripWww
:
true
}
)
;
if
(
!
engineDomain
.
endsWith
(
autofillDomain
)
)
{
return
false
;
}
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
inPrivateWindow
&
&
!
state
.
canShowPrivateSearch
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
lowerCaseSuggestion
)
{
let
suggestion
=
result
.
payload
.
lowerCaseSuggestion
.
trim
(
)
;
if
(
!
suggestion
|
|
state
.
suggestions
.
has
(
suggestion
)
)
{
return
false
;
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
tail
&
&
!
state
.
canShowTailSuggestions
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
)
{
if
(
state
.
addedRemoteTabUrls
.
has
(
result
.
payload
.
url
)
)
{
return
false
;
}
let
maybeDupeType
=
state
.
urlToTabResultType
.
get
(
result
.
payload
.
url
)
;
if
(
maybeDupeType
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
)
{
return
false
;
}
}
if
(
!
result
.
heuristic
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
&
&
state
.
urlToTabResultType
.
has
(
result
.
payload
.
url
)
)
{
return
false
;
}
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
)
{
let
submission
=
Services
.
search
.
parseSubmissionURL
(
result
.
payload
.
url
)
;
if
(
submission
)
{
let
resultQuery
=
submission
.
terms
.
trim
(
)
.
toLocaleLowerCase
(
)
;
if
(
state
.
suggestions
.
has
(
resultQuery
)
)
{
let
[
newSerpURL
]
=
UrlbarUtils
.
getSearchQueryUrl
(
submission
.
engine
submission
.
terms
)
;
if
(
UrlbarSearchUtils
.
serpsAreEquivalent
(
result
.
payload
.
url
newSerpURL
)
)
{
return
false
;
}
}
}
}
if
(
state
.
context
.
searchMode
?
.
engineName
&
&
result
.
payload
.
url
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
state
.
context
.
searchMode
.
engineName
)
;
if
(
engine
)
{
let
searchModeRootDomain
=
UrlbarSearchUtils
.
getRootDomainFromEngine
(
engine
)
;
let
resultUrl
=
new
URL
(
result
.
payload
.
url
)
;
if
(
!
resultUrl
.
hostname
.
includes
(
{
searchModeRootDomain
}
.
)
)
{
return
false
;
}
}
}
if
(
result
.
heuristic
&
&
state
.
usedResultSpan
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
engine
=
=
"
Google
"
&
&
result
.
payload
.
suggestion
?
.
startsWith
(
"
=
"
)
&
&
state
.
hasUnitConversionResult
)
{
return
false
;
}
return
true
;
}
_updateStatePreAdd
(
result
state
)
{
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
)
{
let
[
strippedUrl
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
}
)
;
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
let
topPrefixData
=
state
.
strippedUrlToTopPrefixAndTitle
.
get
(
strippedUrl
)
;
let
topPrefixRank
=
topPrefixData
?
topPrefixData
.
rank
:
-
1
;
if
(
topPrefixRank
<
prefixRank
)
{
state
.
strippedUrlToTopPrefixAndTitle
.
set
(
strippedUrl
{
prefix
title
:
result
.
payload
.
title
rank
:
prefixRank
providerName
:
result
.
providerName
}
)
;
}
}
if
(
result
.
payload
.
url
&
&
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
|
|
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
&
&
!
state
.
urlToTabResultType
.
has
(
result
.
payload
.
url
)
)
)
)
{
state
.
urlToTabResultType
.
set
(
result
.
payload
.
url
result
.
type
)
;
}
if
(
state
.
canShowTailSuggestions
&
&
!
result
.
heuristic
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
(
!
result
.
payload
.
inPrivateWindow
&
&
!
result
.
payload
.
tail
)
)
)
{
state
.
canShowTailSuggestions
=
false
;
}
state
.
hasUnitConversionResult
=
state
.
hasUnitConversionResult
|
|
result
.
providerName
=
=
"
UnitConversion
"
;
}
_updateStatePostAdd
(
result
state
)
{
if
(
result
.
heuristic
)
{
state
.
context
.
heuristicResult
=
result
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
query
)
{
let
query
=
result
.
payload
.
query
.
trim
(
)
.
toLocaleLowerCase
(
)
;
if
(
query
)
{
state
.
suggestions
.
add
(
query
)
;
}
}
}
if
(
state
.
canShowPrivateSearch
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
payload
.
providesSearchMode
|
|
(
result
.
heuristic
&
&
result
.
payload
.
keyword
)
)
)
{
state
.
canShowPrivateSearch
=
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
lowerCaseSuggestion
)
{
let
suggestion
=
result
.
payload
.
lowerCaseSuggestion
.
trim
(
)
;
if
(
suggestion
)
{
state
.
suggestions
.
add
(
suggestion
)
;
}
}
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
state
.
canAddTabToSearch
=
false
;
if
(
result
.
payload
.
dynamicType
)
{
UrlbarProviderTabToSearch
.
enginesShown
.
onboarding
.
add
(
result
.
payload
.
engine
)
;
}
else
{
UrlbarProviderTabToSearch
.
enginesShown
.
regular
.
add
(
result
.
payload
.
engine
)
;
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
)
{
state
.
addedRemoteTabUrls
.
add
(
result
.
payload
.
url
)
;
}
}
_addSuggestedIndexResults
(
sortedResults
state
)
{
let
suggestedIndexResults
=
state
.
resultsByGroup
.
get
(
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTED_INDEX
)
;
if
(
!
suggestedIndexResults
)
{
return
;
}
let
positive
=
[
]
;
let
negative
=
[
]
;
for
(
let
result
of
suggestedIndexResults
)
{
let
results
=
result
.
suggestedIndex
<
0
?
negative
:
positive
;
results
.
push
(
result
)
;
}
positive
.
sort
(
(
a
b
)
=
>
a
.
suggestedIndex
-
b
.
suggestedIndex
)
;
negative
.
sort
(
(
a
b
)
=
>
b
.
suggestedIndex
-
a
.
suggestedIndex
)
;
for
(
let
results
of
[
positive
negative
]
)
{
for
(
let
result
of
results
)
{
this
.
_updateStatePreAdd
(
result
state
)
;
if
(
this
.
_canAddResult
(
result
state
)
)
{
let
index
=
result
.
suggestedIndex
>
=
0
?
Math
.
min
(
result
.
suggestedIndex
sortedResults
.
length
)
:
Math
.
max
(
result
.
suggestedIndex
+
sortedResults
.
length
+
1
0
)
;
sortedResults
.
splice
(
index
0
result
)
;
this
.
_updateStatePostAdd
(
result
state
)
;
}
}
}
}
}
var
UrlbarMuxerUnifiedComplete
=
new
MuxerUnifiedComplete
(
)
;
