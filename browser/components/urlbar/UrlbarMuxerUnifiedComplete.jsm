"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxerUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
jsm
"
UrlbarProviderTabToSearch
:
"
resource
:
/
/
/
modules
/
UrlbarProviderTabToSearch
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
UrlbarUtils
.
getLogger
(
{
prefix
:
"
MuxerUnifiedComplete
"
}
)
)
;
class
MuxerUnifiedComplete
extends
UrlbarMuxer
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
sort
(
context
)
{
let
state
=
{
context
resultsByGroup
:
new
Map
(
)
suggestedIndexResultsByGroup
:
new
Map
(
)
availableResultSpan
:
context
.
maxResults
usedResultSpan
:
0
strippedUrlToTopPrefixAndTitle
:
new
Map
(
)
urlToTabResultType
:
new
Map
(
)
addedRemoteTabUrls
:
new
Set
(
)
addedSwitchTabUrls
:
new
Set
(
)
canShowPrivateSearch
:
context
.
results
.
length
>
1
canShowTailSuggestions
:
true
suggestions
:
new
Set
(
)
canAddTabToSearch
:
true
hasUnitConversionResult
:
false
maxHeuristicResultSpan
:
0
maxTabToSearchResultSpan
:
0
}
;
for
(
let
result
of
context
.
results
)
{
let
group
=
UrlbarUtils
.
getResultGroup
(
result
)
;
let
resultsByGroup
=
result
.
hasSuggestedIndex
&
&
result
.
isSuggestedIndexRelativeToGroup
?
state
.
suggestedIndexResultsByGroup
:
state
.
resultsByGroup
;
let
results
=
resultsByGroup
.
get
(
group
)
;
if
(
!
results
)
{
results
=
[
]
;
resultsByGroup
.
set
(
group
results
)
;
}
results
.
push
(
result
)
;
this
.
_updateStatePreAdd
(
result
state
)
;
}
if
(
state
.
maxTabToSearchResultSpan
)
{
state
.
availableResultSpan
=
Math
.
max
(
state
.
availableResultSpan
-
state
.
maxTabToSearchResultSpan
0
)
;
}
if
(
state
.
maxHeuristicResultSpan
)
{
if
(
UrlbarPrefs
.
get
(
"
experimental
.
hideHeuristic
"
)
)
{
state
.
availableResultSpan
+
=
state
.
maxHeuristicResultSpan
;
}
else
if
(
context
.
maxResults
>
0
)
{
state
.
availableResultSpan
=
Math
.
max
(
state
.
availableResultSpan
state
.
maxHeuristicResultSpan
)
;
}
}
let
rootGroup
=
context
.
searchMode
?
.
engineName
?
UrlbarPrefs
.
makeResultGroups
(
{
showSearchSuggestionsFirst
:
true
}
)
:
UrlbarPrefs
.
get
(
"
resultGroups
"
)
;
logger
.
debug
(
Groups
:
{
rootGroup
}
)
;
let
[
sortedResults
]
=
this
.
_fillGroup
(
rootGroup
{
availableSpan
:
state
.
availableResultSpan
maxResultCount
:
Infinity
}
state
)
;
if
(
context
.
maxResults
>
0
)
{
let
suggestedIndexResults
=
state
.
resultsByGroup
.
get
(
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTED_INDEX
)
;
if
(
suggestedIndexResults
)
{
this
.
_addSuggestedIndexResults
(
suggestedIndexResults
sortedResults
state
)
;
}
}
context
.
results
=
sortedResults
;
}
_copyState
(
state
)
{
let
copy
=
Object
.
assign
(
{
}
state
{
resultsByGroup
:
new
Map
(
)
suggestedIndexResultsByGroup
:
new
Map
(
)
strippedUrlToTopPrefixAndTitle
:
new
Map
(
state
.
strippedUrlToTopPrefixAndTitle
)
urlToTabResultType
:
new
Map
(
state
.
urlToTabResultType
)
addedRemoteTabUrls
:
new
Set
(
state
.
addedRemoteTabUrls
)
addedSwitchTabUrls
:
new
Set
(
state
.
addedSwitchTabUrls
)
suggestions
:
new
Set
(
state
.
suggestions
)
}
)
;
for
(
let
key
of
[
"
resultsByGroup
"
"
suggestedIndexResultsByGroup
"
]
)
{
for
(
let
[
group
results
]
of
state
[
key
]
)
{
copy
[
key
]
.
set
(
group
[
.
.
.
results
]
)
;
}
}
return
copy
;
}
_fillGroup
(
group
limits
state
)
{
let
suggestedIndexResults
;
if
(
"
group
"
in
group
)
{
suggestedIndexResults
=
state
.
suggestedIndexResultsByGroup
.
get
(
group
.
group
)
;
if
(
suggestedIndexResults
)
{
let
span
=
suggestedIndexResults
.
reduce
(
(
sum
result
)
=
>
{
sum
+
=
UrlbarUtils
.
getSpanForResult
(
result
)
;
return
sum
;
}
0
)
;
limits
=
{
.
.
.
limits
}
;
limits
.
availableSpan
=
Math
.
max
(
limits
.
availableSpan
-
span
0
)
;
limits
.
maxResultCount
=
Math
.
max
(
limits
.
maxResultCount
-
suggestedIndexResults
.
length
0
)
;
}
}
let
[
results
usedLimits
hasMoreResults
]
=
group
.
children
?
this
.
_fillGroupChildren
(
group
limits
state
)
:
this
.
_addResults
(
group
.
group
limits
state
)
;
if
(
suggestedIndexResults
)
{
let
suggestedIndexUsedLimits
=
this
.
_addSuggestedIndexResults
(
suggestedIndexResults
results
state
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
suggestedIndexUsedLimits
)
)
{
usedLimits
[
key
]
+
=
value
;
}
}
return
[
results
usedLimits
hasMoreResults
]
;
}
_fillGroupChildren
(
group
limits
state
flexDataArray
=
null
)
{
let
stateCopy
;
if
(
group
.
flexChildren
)
{
stateCopy
=
this
.
_copyState
(
state
)
;
flexDataArray
=
this
.
_updateFlexData
(
group
limits
flexDataArray
)
;
}
let
results
=
[
]
;
let
usedLimits
=
{
}
;
for
(
let
key
of
Object
.
keys
(
limits
)
)
{
usedLimits
[
key
]
=
0
;
}
let
anyChildUnderfilled
=
false
;
let
anyChildHasMoreResults
=
false
;
for
(
let
i
=
0
;
i
<
group
.
children
.
length
;
i
+
+
)
{
let
child
=
group
.
children
[
i
]
;
let
flexData
=
flexDataArray
?
.
[
i
]
;
let
childLimits
=
{
}
;
for
(
let
key
of
Object
.
keys
(
limits
)
)
{
childLimits
[
key
]
=
flexData
?
flexData
.
limits
[
key
]
:
Math
.
min
(
typeof
child
[
key
]
=
=
"
number
"
?
child
[
key
]
:
Infinity
limits
[
key
]
-
usedLimits
[
key
]
)
;
}
let
[
childResults
childUsedLimits
childHasMoreResults
]
=
this
.
_fillGroup
(
child
childLimits
state
)
;
results
=
results
.
concat
(
childResults
)
;
for
(
let
key
of
Object
.
keys
(
usedLimits
)
)
{
usedLimits
[
key
]
+
=
childUsedLimits
[
key
]
;
}
anyChildHasMoreResults
=
anyChildHasMoreResults
|
|
childHasMoreResults
;
if
(
flexData
?
.
hasMoreResults
)
{
flexData
.
usedLimits
=
childUsedLimits
;
flexData
.
hasMoreResults
=
childHasMoreResults
;
anyChildUnderfilled
=
anyChildUnderfilled
|
|
(
!
childHasMoreResults
&
&
[
.
.
.
Object
.
entries
(
childLimits
)
]
.
every
(
(
[
key
limit
]
)
=
>
flexData
.
usedLimits
[
key
]
<
limit
)
)
;
}
}
if
(
anyChildUnderfilled
&
&
anyChildHasMoreResults
)
{
[
results
usedLimits
anyChildHasMoreResults
]
=
this
.
_fillGroupChildren
(
group
limits
stateCopy
flexDataArray
)
;
for
(
let
[
key
value
]
of
Object
.
entries
(
stateCopy
)
)
{
state
[
key
]
=
value
;
}
}
return
[
results
usedLimits
anyChildHasMoreResults
]
;
}
_updateFlexData
(
group
limits
flexDataArray
)
{
flexDataArray
=
flexDataArray
|
|
group
.
children
.
map
(
(
child
index
)
=
>
{
let
data
=
{
index
limits
:
{
}
limitFractions
:
{
}
usedLimits
:
{
}
hasMoreResults
:
true
flex
:
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
}
;
for
(
let
key
of
Object
.
keys
(
limits
)
)
{
data
.
limits
[
key
]
=
0
;
data
.
limitFractions
[
key
]
=
0
;
data
.
usedLimits
[
key
]
=
0
;
}
return
data
;
}
)
;
let
fillableDataArray
=
[
]
;
let
fillableFlexSum
=
0
;
for
(
let
data
of
flexDataArray
)
{
if
(
data
.
hasMoreResults
)
{
fillableFlexSum
+
=
data
.
flex
;
fillableDataArray
.
push
(
data
)
;
}
}
for
(
let
[
key
limit
]
of
Object
.
entries
(
limits
)
)
{
let
fillableLimit
=
limit
;
for
(
let
data
of
flexDataArray
)
{
if
(
!
data
.
hasMoreResults
)
{
fillableLimit
-
=
data
.
usedLimits
[
key
]
;
}
}
fillableLimit
=
Math
.
max
(
fillableLimit
0
)
;
let
summedFillableLimit
=
0
;
for
(
let
data
of
fillableDataArray
)
{
let
unroundedLimit
=
fillableLimit
*
(
data
.
flex
/
fillableFlexSum
)
;
data
.
limitFractions
[
key
]
=
unroundedLimit
-
Math
.
floor
(
unroundedLimit
)
;
data
.
limits
[
key
]
=
Math
.
round
(
unroundedLimit
)
;
summedFillableLimit
+
=
data
.
limits
[
key
]
;
}
if
(
summedFillableLimit
!
=
fillableLimit
)
{
let
fractionalDataArray
=
fillableDataArray
.
filter
(
data
=
>
data
.
limitFractions
[
key
]
)
;
let
diff
;
if
(
summedFillableLimit
<
fillableLimit
)
{
diff
=
1
;
fractionalDataArray
.
sort
(
(
a
b
)
=
>
{
let
cmp
=
b
.
limitFractions
[
key
]
-
a
.
limitFractions
[
key
]
;
return
cmp
|
|
a
.
index
-
b
.
index
;
}
)
;
}
else
if
(
fillableLimit
<
summedFillableLimit
)
{
diff
=
-
1
;
fractionalDataArray
.
sort
(
(
a
b
)
=
>
{
let
cmp
=
a
.
limitFractions
[
key
]
-
b
.
limitFractions
[
key
]
;
return
cmp
|
|
b
.
index
-
a
.
index
;
}
)
;
}
while
(
summedFillableLimit
!
=
fillableLimit
)
{
if
(
!
fractionalDataArray
.
length
)
{
logger
.
error
(
"
fractionalDataArray
is
empty
!
"
)
;
break
;
}
let
data
=
flexDataArray
[
fractionalDataArray
.
shift
(
)
.
index
]
;
data
.
limits
[
key
]
+
=
diff
;
summedFillableLimit
+
=
diff
;
}
}
}
return
flexDataArray
;
}
_addResults
(
groupConst
limits
state
)
{
let
usedLimits
=
{
}
;
for
(
let
key
of
Object
.
keys
(
limits
)
)
{
usedLimits
[
key
]
=
0
;
}
if
(
groupConst
=
=
UrlbarUtils
.
RESULT_GROUP
.
FORM_HISTORY
&
&
!
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
)
{
limits
=
{
.
.
.
limits
}
;
limits
.
maxResultCount
=
0
;
}
let
addedResults
=
[
]
;
let
groupResults
=
state
.
resultsByGroup
.
get
(
groupConst
)
;
while
(
groupResults
?
.
length
&
&
state
.
usedResultSpan
<
state
.
availableResultSpan
&
&
[
.
.
.
Object
.
entries
(
limits
)
]
.
every
(
(
[
k
limit
]
)
=
>
usedLimits
[
k
]
<
limit
)
)
{
let
result
=
groupResults
[
0
]
;
if
(
this
.
_canAddResult
(
result
state
)
)
{
let
span
=
UrlbarUtils
.
getSpanForResult
(
result
)
;
let
newUsedSpan
=
usedLimits
.
availableSpan
+
span
;
if
(
limits
.
availableSpan
<
newUsedSpan
)
{
break
;
}
addedResults
.
push
(
result
)
;
usedLimits
.
availableSpan
=
newUsedSpan
;
usedLimits
.
maxResultCount
+
+
;
state
.
usedResultSpan
+
=
span
;
this
.
_updateStatePostAdd
(
result
state
)
;
}
groupResults
.
shift
(
)
;
}
return
[
addedResults
usedLimits
!
!
groupResults
?
.
length
]
;
}
_canAddResult
(
result
state
)
{
if
(
result
.
providerName
=
=
UrlbarProviderQuickSuggest
.
name
)
{
return
true
;
}
if
(
!
result
.
heuristic
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
)
{
let
[
strippedUrl
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
}
)
;
let
topPrefixData
=
state
.
strippedUrlToTopPrefixAndTitle
.
get
(
strippedUrl
)
;
if
(
topPrefixData
&
&
(
prefix
!
=
topPrefixData
.
prefix
|
|
result
.
providerName
!
=
topPrefixData
.
providerName
)
)
{
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
if
(
(
prefixRank
<
topPrefixData
.
rank
&
&
(
prefix
.
endsWith
(
"
www
.
"
)
=
=
topPrefixData
.
prefix
.
endsWith
(
"
www
.
"
)
|
|
result
.
payload
?
.
title
=
=
topPrefixData
.
title
)
)
|
|
(
prefix
=
=
topPrefixData
.
prefix
&
&
result
.
providerName
!
=
topPrefixData
.
providerName
)
)
{
return
false
;
}
}
}
if
(
state
.
context
.
heuristicResult
&
&
state
.
context
.
heuristicResult
.
autofill
&
&
!
result
.
autofill
&
&
state
.
context
.
heuristicResult
.
payload
?
.
url
=
=
result
.
payload
.
url
&
&
state
.
context
.
heuristicResult
.
type
=
=
result
.
type
&
&
!
UrlbarPrefs
.
get
(
"
experimental
.
hideHeuristic
"
)
)
{
return
false
;
}
if
(
!
result
.
heuristic
&
&
result
.
providerName
=
=
"
HeuristicFallback
"
&
&
state
.
context
.
heuristicResult
?
.
providerName
!
=
"
HeuristicFallback
"
)
{
return
false
;
}
if
(
result
.
providerName
=
=
UrlbarProviderTabToSearch
.
name
)
{
if
(
!
state
.
canAddTabToSearch
)
{
return
false
;
}
if
(
state
.
context
.
heuristicResult
?
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
)
{
if
(
!
state
.
context
.
heuristicResult
.
autofill
&
&
!
result
.
payload
.
satisfiesAutofillThreshold
)
{
return
false
;
}
let
autofillHostname
=
new
URL
(
state
.
context
.
heuristicResult
.
payload
.
url
)
.
hostname
;
let
[
autofillDomain
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
autofillHostname
{
stripWww
:
true
}
)
;
autofillDomain
=
UrlbarUtils
.
stripPublicSuffixFromHost
(
autofillDomain
)
;
if
(
!
autofillDomain
)
{
return
false
;
}
let
[
engineDomain
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripWww
:
true
}
)
;
if
(
!
engineDomain
.
endsWith
(
autofillDomain
)
)
{
return
false
;
}
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
inPrivateWindow
&
&
!
state
.
canShowPrivateSearch
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
lowerCaseSuggestion
)
{
let
suggestion
=
result
.
payload
.
lowerCaseSuggestion
.
trim
(
)
;
if
(
!
suggestion
|
|
state
.
suggestions
.
has
(
suggestion
)
)
{
return
false
;
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
tail
&
&
!
state
.
canShowTailSuggestions
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
)
{
if
(
state
.
addedRemoteTabUrls
.
has
(
result
.
payload
.
url
)
)
{
return
false
;
}
let
maybeDupeType
=
state
.
urlToTabResultType
.
get
(
result
.
payload
.
url
)
;
if
(
maybeDupeType
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
)
{
return
false
;
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
&
&
state
.
addedSwitchTabUrls
.
has
(
result
.
payload
.
url
)
)
{
return
false
;
}
if
(
!
result
.
heuristic
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
&
&
state
.
urlToTabResultType
.
has
(
result
.
payload
.
url
)
)
{
return
false
;
}
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
)
{
let
submission
=
Services
.
search
.
parseSubmissionURL
(
result
.
payload
.
url
)
;
if
(
submission
)
{
let
resultQuery
=
submission
.
terms
.
trim
(
)
.
toLocaleLowerCase
(
)
;
if
(
state
.
suggestions
.
has
(
resultQuery
)
)
{
let
[
newSerpURL
]
=
UrlbarUtils
.
getSearchQueryUrl
(
submission
.
engine
submission
.
terms
)
;
if
(
UrlbarSearchUtils
.
serpsAreEquivalent
(
result
.
payload
.
url
newSerpURL
)
)
{
return
false
;
}
}
}
}
if
(
state
.
context
.
searchMode
?
.
engineName
&
&
result
.
payload
.
url
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
state
.
context
.
searchMode
.
engineName
)
;
if
(
engine
)
{
let
searchModeRootDomain
=
UrlbarSearchUtils
.
getRootDomainFromEngine
(
engine
)
;
let
resultUrl
=
new
URL
(
result
.
payload
.
url
)
;
if
(
!
resultUrl
.
hostname
.
includes
(
{
searchModeRootDomain
}
.
)
)
{
return
false
;
}
}
}
if
(
state
.
quickSuggestResult
&
&
!
result
.
heuristic
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
UrlbarProviderQuickSuggest
.
isURLEquivalentToResultURL
(
result
.
payload
.
url
state
.
quickSuggestResult
)
)
{
return
false
;
}
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
)
{
let
param
=
Services
.
prefs
.
getCharPref
(
"
browser
.
newtabpage
.
activity
-
stream
.
hideTopSitesWithSearchParam
"
)
;
if
(
param
)
{
let
[
key
value
]
=
param
.
split
(
"
=
"
)
;
let
searchParams
;
try
{
(
{
searchParams
}
=
new
URL
(
result
.
payload
.
url
)
)
;
}
catch
(
error
)
{
}
if
(
(
value
=
=
=
undefined
&
&
searchParams
?
.
has
(
key
)
)
|
|
(
value
!
=
=
undefined
&
&
searchParams
?
.
getAll
(
key
)
.
includes
(
value
)
)
)
{
return
false
;
}
}
}
if
(
result
.
heuristic
&
&
state
.
usedResultSpan
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
engine
=
=
"
Google
"
&
&
result
.
payload
.
suggestion
?
.
startsWith
(
"
=
"
)
&
&
state
.
hasUnitConversionResult
)
{
return
false
;
}
return
true
;
}
_updateStatePreAdd
(
result
state
)
{
if
(
result
.
heuristic
&
&
this
.
_canAddResult
(
result
state
)
)
{
state
.
maxHeuristicResultSpan
=
Math
.
max
(
state
.
maxHeuristicResultSpan
UrlbarUtils
.
getSpanForResult
(
result
)
)
;
}
if
(
result
.
hasSuggestedIndex
&
&
!
result
.
isSuggestedIndexRelativeToGroup
&
&
this
.
_canAddResult
(
result
state
)
)
{
let
span
=
UrlbarUtils
.
getSpanForResult
(
result
)
;
if
(
result
.
providerName
=
=
UrlbarProviderTabToSearch
.
name
)
{
state
.
maxTabToSearchResultSpan
=
Math
.
max
(
state
.
maxTabToSearchResultSpan
span
)
;
}
else
{
state
.
availableResultSpan
=
Math
.
max
(
state
.
availableResultSpan
-
span
0
)
;
}
}
if
(
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
|
|
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
)
&
&
result
.
payload
.
url
&
&
(
!
result
.
heuristic
|
|
!
UrlbarPrefs
.
get
(
"
experimental
.
hideHeuristic
"
)
)
)
{
let
[
strippedUrl
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
}
)
;
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
let
topPrefixData
=
state
.
strippedUrlToTopPrefixAndTitle
.
get
(
strippedUrl
)
;
let
topPrefixRank
=
topPrefixData
?
topPrefixData
.
rank
:
-
1
;
if
(
topPrefixRank
<
prefixRank
|
|
(
topPrefixRank
=
=
prefixRank
&
&
result
.
providerName
=
=
UrlbarProviderQuickSuggest
.
name
)
)
{
state
.
strippedUrlToTopPrefixAndTitle
.
set
(
strippedUrl
{
prefix
title
:
result
.
payload
.
title
rank
:
prefixRank
providerName
:
result
.
providerName
}
)
;
}
}
if
(
result
.
payload
.
url
&
&
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
|
|
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
&
&
!
state
.
urlToTabResultType
.
has
(
result
.
payload
.
url
)
)
)
)
{
state
.
urlToTabResultType
.
set
(
result
.
payload
.
url
result
.
type
)
;
}
if
(
state
.
canShowTailSuggestions
&
&
!
result
.
heuristic
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
(
!
result
.
payload
.
inPrivateWindow
&
&
!
result
.
payload
.
tail
)
)
)
{
state
.
canShowTailSuggestions
=
false
;
}
if
(
result
.
providerName
=
=
UrlbarProviderQuickSuggest
.
name
)
{
state
.
quickSuggestResult
=
result
;
}
state
.
hasUnitConversionResult
=
state
.
hasUnitConversionResult
|
|
result
.
providerName
=
=
"
UnitConversion
"
;
}
_updateStatePostAdd
(
result
state
)
{
if
(
result
.
heuristic
)
{
state
.
context
.
heuristicResult
=
result
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
query
&
&
!
UrlbarPrefs
.
get
(
"
experimental
.
hideHeuristic
"
)
)
{
let
query
=
result
.
payload
.
query
.
trim
(
)
.
toLocaleLowerCase
(
)
;
if
(
query
)
{
state
.
suggestions
.
add
(
query
)
;
}
}
}
if
(
state
.
canShowPrivateSearch
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
payload
.
providesSearchMode
|
|
(
result
.
heuristic
&
&
result
.
payload
.
keyword
)
)
)
{
state
.
canShowPrivateSearch
=
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
lowerCaseSuggestion
)
{
let
suggestion
=
result
.
payload
.
lowerCaseSuggestion
.
trim
(
)
;
if
(
suggestion
)
{
state
.
suggestions
.
add
(
suggestion
)
;
}
}
if
(
result
.
providerName
=
=
UrlbarProviderTabToSearch
.
name
)
{
state
.
canAddTabToSearch
=
false
;
if
(
result
.
payload
.
dynamicType
)
{
UrlbarProviderTabToSearch
.
enginesShown
.
onboarding
.
add
(
result
.
payload
.
engine
)
;
}
else
{
UrlbarProviderTabToSearch
.
enginesShown
.
regular
.
add
(
result
.
payload
.
engine
)
;
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
)
{
state
.
addedRemoteTabUrls
.
add
(
result
.
payload
.
url
)
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
)
{
state
.
addedSwitchTabUrls
.
add
(
result
.
payload
.
url
)
;
}
}
_addSuggestedIndexResults
(
suggestedIndexResults
sortedResults
state
)
{
let
usedLimits
=
{
availableSpan
:
0
maxResultCount
:
0
}
;
if
(
!
suggestedIndexResults
?
.
length
)
{
return
usedLimits
;
}
let
positive
=
[
]
;
let
negative
=
[
]
;
for
(
let
result
of
suggestedIndexResults
)
{
let
results
=
result
.
suggestedIndex
<
0
?
negative
:
positive
;
results
.
push
(
result
)
;
}
positive
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
suggestedIndex
!
=
=
b
.
suggestedIndex
)
{
return
a
.
suggestedIndex
-
b
.
suggestedIndex
;
}
if
(
a
.
providerName
=
=
=
b
.
providerName
)
{
return
0
;
}
if
(
a
.
providerName
=
=
=
UrlbarProviderTabToSearch
.
name
)
{
return
1
;
}
if
(
b
.
providerName
=
=
=
UrlbarProviderTabToSearch
.
name
)
{
return
-
1
;
}
if
(
a
.
providerName
=
=
=
UrlbarProviderQuickSuggest
.
name
)
{
return
1
;
}
if
(
b
.
providerName
=
=
=
UrlbarProviderQuickSuggest
.
name
)
{
return
-
1
;
}
return
0
;
}
)
;
negative
.
sort
(
(
a
b
)
=
>
b
.
suggestedIndex
-
a
.
suggestedIndex
)
;
for
(
let
results
of
[
positive
negative
]
)
{
let
prevResult
;
let
prevIndex
;
for
(
let
result
of
results
)
{
if
(
this
.
_canAddResult
(
result
state
)
)
{
let
index
;
if
(
prevResult
&
&
prevResult
.
suggestedIndex
=
=
result
.
suggestedIndex
)
{
index
=
prevIndex
;
}
else
{
index
=
result
.
suggestedIndex
>
=
0
?
Math
.
min
(
result
.
suggestedIndex
sortedResults
.
length
)
:
Math
.
max
(
result
.
suggestedIndex
+
sortedResults
.
length
+
1
0
)
;
}
prevResult
=
result
;
prevIndex
=
index
;
sortedResults
.
splice
(
index
0
result
)
;
usedLimits
.
availableSpan
+
=
UrlbarUtils
.
getSpanForResult
(
result
)
;
usedLimits
.
maxResultCount
+
+
;
this
.
_updateStatePostAdd
(
result
state
)
;
}
}
}
return
usedLimits
;
}
}
var
UrlbarMuxerUnifiedComplete
=
new
MuxerUnifiedComplete
(
)
;
