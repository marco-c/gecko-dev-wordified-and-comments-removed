"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxerUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
UrlbarUtils
.
getLogger
(
{
prefix
:
"
MuxerUnifiedComplete
"
}
)
)
;
function
groupFromResult
(
result
)
{
if
(
result
.
heuristic
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
;
}
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
if
(
result
.
payload
.
suggestion
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
;
}
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
;
}
return
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
}
const
HEURISTIC_ORDER
=
[
"
UrlbarProviderSearchTips
"
"
Omnibox
"
"
UnifiedComplete
"
"
Autofill
"
"
TokenAliasEngines
"
"
HeuristicFallback
"
]
;
class
MuxerUnifiedComplete
extends
UrlbarMuxer
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
sort
(
context
)
{
let
state
=
{
context
resultsByGroup
:
new
Map
(
)
totalResultCount
:
0
topHeuristicRank
:
Infinity
strippedUrlToTopPrefixAndTitle
:
new
Map
(
)
canShowPrivateSearch
:
context
.
results
.
length
>
1
canShowTailSuggestions
:
true
formHistorySuggestions
:
new
Set
(
)
}
;
let
resultsWithSuggestedIndex
=
[
]
;
for
(
let
result
of
context
.
results
)
{
if
(
result
.
suggestedIndex
>
=
0
)
{
resultsWithSuggestedIndex
.
push
(
result
)
;
continue
;
}
let
group
=
groupFromResult
(
result
)
;
let
results
=
state
.
resultsByGroup
.
get
(
group
)
;
if
(
!
results
)
{
results
=
[
]
;
state
.
resultsByGroup
.
set
(
group
results
)
;
}
results
.
push
(
result
)
;
this
.
_updateStatePreAdd
(
result
state
)
;
}
if
(
context
.
heuristicResult
?
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
context
.
heuristicResult
?
.
payload
.
query
)
{
state
.
heuristicResultQuery
=
context
.
heuristicResult
.
payload
.
query
.
toLocaleLowerCase
(
)
;
}
let
buckets
=
context
.
heuristicResult
?
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
?
UrlbarPrefs
.
get
(
"
matchBucketsSearch
"
)
:
UrlbarPrefs
.
get
(
"
matchBuckets
"
)
;
logger
.
debug
(
Buckets
:
{
buckets
}
)
;
let
resultsByBucketIndex
=
[
]
;
for
(
let
[
group
maxResultCount
]
of
buckets
)
{
let
results
=
this
.
_addResults
(
group
maxResultCount
state
)
;
resultsByBucketIndex
.
push
(
results
)
;
}
let
sortedResults
=
[
]
;
let
remainingCount
=
context
.
maxResults
;
for
(
let
i
=
0
;
i
<
resultsByBucketIndex
.
length
&
&
remainingCount
;
i
+
+
)
{
let
results
=
resultsByBucketIndex
[
i
]
;
let
count
=
Math
.
min
(
remainingCount
results
.
length
)
;
sortedResults
.
push
(
.
.
.
results
.
slice
(
0
count
)
)
;
remainingCount
-
=
count
;
}
resultsWithSuggestedIndex
.
sort
(
(
a
b
)
=
>
a
.
suggestedIndex
-
b
.
suggestedIndex
)
;
for
(
let
result
of
resultsWithSuggestedIndex
)
{
this
.
_updateStatePreAdd
(
result
state
)
;
this
.
_updateStatePostAdd
(
result
state
)
;
}
for
(
let
result
of
resultsWithSuggestedIndex
)
{
if
(
this
.
_canAddResult
(
result
state
)
)
{
let
index
=
result
.
suggestedIndex
<
=
sortedResults
.
length
?
result
.
suggestedIndex
:
sortedResults
.
length
;
sortedResults
.
splice
(
index
0
result
)
;
}
}
context
.
results
=
sortedResults
;
}
_addResults
(
group
maxResultCount
state
)
{
let
addedResults
=
[
]
;
let
groupResults
=
state
.
resultsByGroup
.
get
(
group
)
;
while
(
groupResults
?
.
length
&
&
addedResults
.
length
<
maxResultCount
&
&
state
.
totalResultCount
<
state
.
context
.
maxResults
)
{
let
result
=
groupResults
.
shift
(
)
;
if
(
this
.
_canAddResult
(
result
state
)
)
{
addedResults
.
push
(
result
)
;
state
.
totalResultCount
+
+
;
this
.
_updateStatePostAdd
(
result
state
)
;
}
}
return
addedResults
;
}
_canAddResult
(
result
state
)
{
if
(
result
.
heuristic
&
&
result
!
=
state
.
context
.
heuristicResult
)
{
return
false
;
}
if
(
!
result
.
heuristic
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
)
{
let
[
strippedUrl
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
}
)
;
let
topPrefixData
=
state
.
strippedUrlToTopPrefixAndTitle
.
get
(
strippedUrl
)
;
if
(
topPrefixData
&
&
prefix
!
=
topPrefixData
.
prefix
)
{
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
if
(
prefixRank
<
topPrefixData
.
rank
&
&
(
prefix
.
endsWith
(
"
www
.
"
)
=
=
topPrefixData
.
prefix
.
endsWith
(
"
www
.
"
)
|
|
result
.
payload
?
.
title
=
=
topPrefixData
.
title
)
)
{
return
false
;
}
}
}
if
(
state
.
context
.
heuristicResult
&
&
state
.
context
.
heuristicResult
.
providerName
=
=
"
Autofill
"
&
&
result
.
providerName
!
=
"
Autofill
"
&
&
state
.
context
.
heuristicResult
.
payload
?
.
url
=
=
result
.
payload
.
url
&
&
state
.
context
.
heuristicResult
.
type
=
=
result
.
type
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
inPrivateWindow
&
&
!
state
.
canShowPrivateSearch
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
result
.
payload
.
lowerCaseSuggestion
=
=
=
state
.
heuristicResultQuery
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
&
&
result
.
payload
.
lowerCaseSuggestion
&
&
result
.
payload
.
lowerCaseSuggestion
=
=
=
state
.
heuristicResultQuery
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
tail
&
&
!
state
.
canShowTailSuggestions
)
{
return
false
;
}
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
)
{
let
submission
=
Services
.
search
.
parseSubmissionURL
(
result
.
payload
.
url
)
;
if
(
submission
)
{
let
resultQuery
=
submission
.
terms
.
toLocaleLowerCase
(
)
;
if
(
state
.
heuristicResultQuery
=
=
=
resultQuery
|
|
state
.
formHistorySuggestions
.
has
(
resultQuery
)
)
{
let
[
newSerpURL
]
=
UrlbarUtils
.
getSearchQueryUrl
(
submission
.
engine
resultQuery
)
;
if
(
this
.
_serpURLsHaveSameParams
(
newSerpURL
result
.
payload
.
url
)
)
{
return
false
;
}
}
}
}
return
true
;
}
_updateStatePreAdd
(
result
state
)
{
if
(
result
.
heuristic
)
{
let
heuristicRank
=
HEURISTIC_ORDER
.
indexOf
(
result
.
providerName
)
+
2
;
if
(
result
.
providerType
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
)
{
heuristicRank
=
1
;
}
else
if
(
result
.
providerName
.
startsWith
(
"
TestProvider
"
)
)
{
heuristicRank
=
0
;
}
else
if
(
heuristicRank
-
2
=
=
-
1
)
{
throw
new
Error
(
Heuristic
result
returned
by
unexpected
provider
:
{
result
.
providerName
}
)
;
}
if
(
heuristicRank
<
=
state
.
topHeuristicRank
)
{
state
.
topHeuristicRank
=
heuristicRank
;
state
.
context
.
heuristicResult
=
result
;
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
)
{
let
[
strippedUrl
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
}
)
;
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
let
topPrefixData
=
state
.
strippedUrlToTopPrefixAndTitle
.
get
(
strippedUrl
)
;
let
topPrefixRank
=
topPrefixData
?
topPrefixData
.
rank
:
-
1
;
if
(
topPrefixRank
<
prefixRank
)
{
state
.
strippedUrlToTopPrefixAndTitle
.
set
(
strippedUrl
{
prefix
title
:
result
.
payload
.
title
rank
:
prefixRank
}
)
;
}
}
if
(
state
.
canShowTailSuggestions
&
&
!
result
.
heuristic
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
(
!
result
.
payload
.
inPrivateWindow
&
&
!
result
.
payload
.
tail
)
)
)
{
state
.
canShowTailSuggestions
=
false
;
}
}
_updateStatePostAdd
(
result
state
)
{
if
(
state
.
canShowPrivateSearch
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
payload
.
keywordOffer
|
|
(
result
.
heuristic
&
&
result
.
payload
.
keyword
)
)
)
{
state
.
canShowPrivateSearch
=
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
{
state
.
formHistorySuggestions
.
add
(
result
.
payload
.
lowerCaseSuggestion
)
;
}
}
_serpURLsHaveSameParams
(
url1
url2
)
{
let
params1
=
new
URL
(
url1
)
.
searchParams
;
let
params2
=
new
URL
(
url2
)
.
searchParams
;
for
(
let
params
of
[
params1
params2
]
)
{
params
.
delete
(
"
client
"
)
;
}
for
(
let
[
p1
p2
]
of
[
[
params1
params2
]
[
params2
params1
]
]
)
{
for
(
let
[
key
value
]
of
p1
)
{
if
(
!
p2
.
getAll
(
key
)
.
includes
(
value
)
)
{
return
false
;
}
}
}
return
true
;
}
}
var
UrlbarMuxerUnifiedComplete
=
new
MuxerUnifiedComplete
(
)
;
