"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxerUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProviderTabToSearch
:
"
resource
:
/
/
/
modules
/
UrlbarProviderTabToSearch
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
UrlbarUtils
.
getLogger
(
{
prefix
:
"
MuxerUnifiedComplete
"
}
)
)
;
class
MuxerUnifiedComplete
extends
UrlbarMuxer
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
sort
(
context
)
{
let
state
=
{
context
resultsByGroup
:
new
Map
(
)
totalResultCount
:
0
strippedUrlToTopPrefixAndTitle
:
new
Map
(
)
canShowPrivateSearch
:
context
.
results
.
length
>
1
canShowTailSuggestions
:
true
suggestions
:
new
Set
(
)
canAddTabToSearch
:
true
}
;
for
(
let
result
of
context
.
results
)
{
let
group
=
UrlbarUtils
.
getResultGroup
(
result
)
;
let
results
=
state
.
resultsByGroup
.
get
(
group
)
;
if
(
!
results
)
{
results
=
[
]
;
state
.
resultsByGroup
.
set
(
group
results
)
;
}
results
.
push
(
result
)
;
this
.
_updateStatePreAdd
(
result
state
)
;
}
let
rootBucket
=
context
.
searchMode
?
.
engineName
?
UrlbarPrefs
.
makeResultBuckets
(
{
showSearchSuggestionsFirst
:
true
}
)
:
UrlbarPrefs
.
get
(
"
resultBuckets
"
)
;
logger
.
debug
(
Buckets
:
{
rootBucket
}
)
;
let
sortedResults
=
this
.
_fillBuckets
(
rootBucket
context
.
maxResults
state
)
;
let
resultsWithSuggestedIndex
=
state
.
resultsByGroup
.
get
(
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTED_INDEX
)
;
if
(
resultsWithSuggestedIndex
)
{
resultsWithSuggestedIndex
.
sort
(
(
a
b
)
=
>
a
.
suggestedIndex
-
b
.
suggestedIndex
)
;
for
(
let
result
of
resultsWithSuggestedIndex
)
{
this
.
_updateStatePreAdd
(
result
state
)
;
}
for
(
let
result
of
resultsWithSuggestedIndex
)
{
if
(
this
.
_canAddResult
(
result
state
)
)
{
let
index
=
result
.
suggestedIndex
<
=
sortedResults
.
length
?
result
.
suggestedIndex
:
sortedResults
.
length
;
sortedResults
.
splice
(
index
0
result
)
;
this
.
_updateStatePostAdd
(
result
state
)
;
}
}
}
context
.
results
=
sortedResults
;
}
_copyState
(
state
)
{
let
copy
=
Object
.
assign
(
{
}
state
{
resultsByGroup
:
new
Map
(
)
strippedUrlToTopPrefixAndTitle
:
new
Map
(
state
.
strippedUrlToTopPrefixAndTitle
)
suggestions
:
new
Set
(
state
.
suggestions
)
}
)
;
for
(
let
[
group
results
]
of
state
.
resultsByGroup
)
{
copy
.
resultsByGroup
.
set
(
group
[
.
.
.
results
]
)
;
}
return
copy
;
}
_fillBuckets
(
bucket
maxResultCount
state
)
{
if
(
!
bucket
.
children
)
{
return
this
.
_addResults
(
bucket
.
group
maxResultCount
state
)
;
}
let
stateCopy
;
let
flexSum
=
0
;
let
unfilledChildIndexes
=
[
]
;
let
unfilledChildResultCount
=
0
;
if
(
bucket
.
flexChildren
)
{
stateCopy
=
this
.
_copyState
(
state
)
;
for
(
let
child
of
bucket
.
children
)
{
let
flex
=
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
;
flexSum
+
=
flex
;
}
}
let
flexSumFilled
=
flexSum
;
let
results
=
[
]
;
for
(
let
i
=
0
;
i
<
bucket
.
children
.
length
&
&
results
.
length
<
maxResultCount
;
i
+
+
)
{
let
child
=
bucket
.
children
[
i
]
;
let
childMaxResultCount
;
if
(
bucket
.
flexChildren
)
{
let
flex
=
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
;
childMaxResultCount
=
Math
.
round
(
maxResultCount
*
(
flex
/
flexSum
)
)
;
}
else
{
childMaxResultCount
=
Math
.
min
(
typeof
child
.
maxResultCount
=
=
"
number
"
?
child
.
maxResultCount
:
Infinity
maxResultCount
-
results
.
length
)
;
}
let
childResults
=
this
.
_fillBuckets
(
child
childMaxResultCount
state
)
;
results
=
results
.
concat
(
childResults
)
;
if
(
bucket
.
flexChildren
&
&
childResults
.
length
<
childMaxResultCount
)
{
let
flex
=
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
;
flexSumFilled
-
=
flex
;
unfilledChildIndexes
.
push
(
i
)
;
unfilledChildResultCount
+
=
childResults
.
length
;
}
}
if
(
unfilledChildIndexes
.
length
)
{
results
=
[
]
;
let
remainingResultCount
=
maxResultCount
-
unfilledChildResultCount
;
for
(
let
i
=
0
;
i
<
bucket
.
children
.
length
&
&
results
.
length
<
maxResultCount
;
i
+
+
)
{
let
child
=
bucket
.
children
[
i
]
;
let
childMaxResultCount
;
if
(
unfilledChildIndexes
.
length
&
&
i
=
=
unfilledChildIndexes
[
0
]
)
{
unfilledChildIndexes
.
shift
(
)
;
childMaxResultCount
=
maxResultCount
;
}
else
{
let
flex
=
typeof
child
.
flex
=
=
"
number
"
?
child
.
flex
:
0
;
childMaxResultCount
=
flex
?
Math
.
round
(
remainingResultCount
*
(
flex
/
flexSumFilled
)
)
:
remainingResultCount
;
}
let
childResults
=
this
.
_fillBuckets
(
child
childMaxResultCount
stateCopy
)
;
results
=
results
.
concat
(
childResults
)
;
}
for
(
let
[
key
value
]
of
Object
.
entries
(
stateCopy
)
)
{
state
[
key
]
=
value
;
}
}
return
results
;
}
_addResults
(
group
maxResultCount
state
)
{
if
(
group
=
=
UrlbarUtils
.
RESULT_GROUP
.
FORM_HISTORY
&
&
!
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
)
{
maxResultCount
=
0
;
}
let
addedResults
=
[
]
;
let
groupResults
=
state
.
resultsByGroup
.
get
(
group
)
;
while
(
groupResults
?
.
length
&
&
addedResults
.
length
<
maxResultCount
&
&
state
.
totalResultCount
<
state
.
context
.
maxResults
)
{
let
result
=
groupResults
.
shift
(
)
;
if
(
this
.
_canAddResult
(
result
state
)
)
{
addedResults
.
push
(
result
)
;
state
.
totalResultCount
+
+
;
this
.
_updateStatePostAdd
(
result
state
)
;
}
}
return
addedResults
;
}
_canAddResult
(
result
state
)
{
if
(
!
result
.
heuristic
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
)
{
let
[
strippedUrl
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
}
)
;
let
topPrefixData
=
state
.
strippedUrlToTopPrefixAndTitle
.
get
(
strippedUrl
)
;
if
(
topPrefixData
&
&
prefix
!
=
topPrefixData
.
prefix
)
{
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
if
(
prefixRank
<
topPrefixData
.
rank
&
&
(
prefix
.
endsWith
(
"
www
.
"
)
=
=
topPrefixData
.
prefix
.
endsWith
(
"
www
.
"
)
|
|
result
.
payload
?
.
title
=
=
topPrefixData
.
title
)
)
{
return
false
;
}
}
}
if
(
state
.
context
.
heuristicResult
&
&
state
.
context
.
heuristicResult
.
providerName
=
=
"
Autofill
"
&
&
result
.
providerName
!
=
"
Autofill
"
&
&
state
.
context
.
heuristicResult
.
payload
?
.
url
=
=
result
.
payload
.
url
&
&
state
.
context
.
heuristicResult
.
type
=
=
result
.
type
)
{
return
false
;
}
if
(
!
result
.
heuristic
&
&
result
.
providerName
=
=
"
HeuristicFallback
"
&
&
state
.
context
.
heuristicResult
?
.
providerName
!
=
"
HeuristicFallback
"
)
{
return
false
;
}
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
if
(
!
state
.
canAddTabToSearch
)
{
return
false
;
}
if
(
!
result
.
payload
.
satisfiesAutofillThreshold
)
{
if
(
!
state
.
context
.
heuristicResult
|
|
state
.
context
.
heuristicResult
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
URL
|
|
!
state
.
context
.
heuristicResult
.
autofill
)
{
return
false
;
}
let
autofillHostname
=
new
URL
(
state
.
context
.
heuristicResult
.
payload
.
url
)
.
hostname
;
let
[
autofillDomain
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
autofillHostname
{
stripWww
:
true
}
)
;
autofillDomain
=
UrlbarUtils
.
stripPublicSuffixFromHost
(
autofillDomain
)
;
if
(
!
autofillDomain
)
{
return
false
;
}
let
[
engineDomain
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripWww
:
true
}
)
;
if
(
!
engineDomain
.
endsWith
(
autofillDomain
)
)
{
return
false
;
}
}
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
inPrivateWindow
&
&
!
state
.
canShowPrivateSearch
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
lowerCaseSuggestion
&
&
state
.
suggestions
.
has
(
result
.
payload
.
lowerCaseSuggestion
)
)
{
return
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
tail
&
&
!
state
.
canShowTailSuggestions
)
{
return
false
;
}
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
)
{
let
submission
=
Services
.
search
.
parseSubmissionURL
(
result
.
payload
.
url
)
;
if
(
submission
)
{
let
resultQuery
=
submission
.
terms
.
toLocaleLowerCase
(
)
;
if
(
state
.
suggestions
.
has
(
resultQuery
)
)
{
let
[
newSerpURL
]
=
UrlbarUtils
.
getSearchQueryUrl
(
submission
.
engine
resultQuery
)
;
if
(
UrlbarSearchUtils
.
serpsAreEquivalent
(
result
.
payload
.
url
newSerpURL
)
)
{
return
false
;
}
}
}
}
if
(
state
.
context
.
searchMode
?
.
engineName
&
&
result
.
payload
.
url
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
state
.
context
.
searchMode
.
engineName
)
;
if
(
engine
)
{
let
searchModeRootDomain
=
UrlbarSearchUtils
.
getRootDomainFromEngine
(
engine
)
;
let
resultUrl
=
new
URL
(
result
.
payload
.
url
)
;
if
(
!
resultUrl
.
hostname
.
includes
(
{
searchModeRootDomain
}
.
)
)
{
return
false
;
}
}
}
if
(
result
.
heuristic
&
&
state
.
totalResultCount
)
{
return
false
;
}
return
true
;
}
_updateStatePreAdd
(
result
state
)
{
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
&
&
result
.
payload
.
url
)
{
let
[
strippedUrl
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
result
.
payload
.
url
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
}
)
;
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
let
topPrefixData
=
state
.
strippedUrlToTopPrefixAndTitle
.
get
(
strippedUrl
)
;
let
topPrefixRank
=
topPrefixData
?
topPrefixData
.
rank
:
-
1
;
if
(
topPrefixRank
<
prefixRank
)
{
state
.
strippedUrlToTopPrefixAndTitle
.
set
(
strippedUrl
{
prefix
title
:
result
.
payload
.
title
rank
:
prefixRank
}
)
;
}
}
if
(
state
.
canShowTailSuggestions
&
&
!
result
.
heuristic
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
(
!
result
.
payload
.
inPrivateWindow
&
&
!
result
.
payload
.
tail
)
)
)
{
state
.
canShowTailSuggestions
=
false
;
}
}
_updateStatePostAdd
(
result
state
)
{
if
(
result
.
heuristic
)
{
state
.
context
.
heuristicResult
=
result
;
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
query
)
{
state
.
suggestions
.
add
(
result
.
payload
.
query
.
toLocaleLowerCase
(
)
)
;
}
}
if
(
state
.
canShowPrivateSearch
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
payload
.
providesSearchMode
|
|
(
result
.
heuristic
&
&
result
.
payload
.
keyword
)
)
)
{
state
.
canShowPrivateSearch
=
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
lowerCaseSuggestion
)
{
state
.
suggestions
.
add
(
result
.
payload
.
lowerCaseSuggestion
)
;
}
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
state
.
canAddTabToSearch
=
false
;
if
(
result
.
payload
.
dynamicType
)
{
UrlbarProviderTabToSearch
.
enginesShown
.
onboarding
.
add
(
result
.
payload
.
engine
)
;
}
else
{
UrlbarProviderTabToSearch
.
enginesShown
.
regular
.
add
(
result
.
payload
.
engine
)
;
}
}
}
}
var
UrlbarMuxerUnifiedComplete
=
new
MuxerUnifiedComplete
(
)
;
