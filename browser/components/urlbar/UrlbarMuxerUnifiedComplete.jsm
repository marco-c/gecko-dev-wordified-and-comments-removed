"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxerUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
UrlbarUtils
.
getLogger
(
{
prefix
:
"
MuxerUnifiedComplete
"
}
)
)
;
function
groupFromResult
(
result
)
{
if
(
result
.
heuristic
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
;
}
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
return
result
.
payload
.
suggestion
?
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
;
default
:
return
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
}
}
const
heuristicOrder
=
[
"
UrlbarProviderSearchTips
"
"
Omnibox
"
"
UnifiedComplete
"
"
Autofill
"
"
TokenAliasEngines
"
"
HeuristicFallback
"
]
;
class
MuxerUnifiedComplete
extends
UrlbarMuxer
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
sort
(
context
)
{
let
topHeuristicRank
=
Infinity
;
for
(
let
result
of
context
.
allHeuristicResults
)
{
if
(
!
result
.
heuristic
)
{
continue
;
}
let
heuristicRank
=
heuristicOrder
.
indexOf
(
result
.
providerName
)
+
2
;
if
(
result
.
providerType
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
)
{
heuristicRank
=
1
;
}
else
if
(
result
.
providerName
.
startsWith
(
"
TestProvider
"
)
)
{
heuristicRank
=
0
;
}
else
if
(
heuristicRank
-
2
=
=
-
1
)
{
throw
new
Error
(
Heuristic
result
returned
by
unexpected
provider
:
{
result
.
providerName
}
)
;
}
if
(
heuristicRank
<
=
topHeuristicRank
)
{
topHeuristicRank
=
heuristicRank
;
context
.
heuristicResult
=
result
;
}
}
let
heuristicResultQuery
;
if
(
context
.
heuristicResult
)
{
if
(
context
.
heuristicResult
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
context
.
heuristicResult
.
payload
.
query
)
{
heuristicResultQuery
=
context
.
heuristicResult
.
payload
.
query
.
toLocaleLowerCase
(
)
;
}
}
let
canShowPrivateSearch
=
context
.
results
.
length
>
1
;
let
canShowTailSuggestions
=
true
;
let
resultsWithSuggestedIndex
=
[
]
;
let
formHistoryResults
=
new
Set
(
)
;
let
formHistorySuggestions
=
new
Set
(
)
;
let
maxFormHistoryCount
=
Math
.
min
(
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
context
.
maxResults
)
;
for
(
let
result
of
context
.
results
)
{
if
(
canShowPrivateSearch
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
result
.
payload
.
keywordOffer
|
|
(
result
.
heuristic
&
&
result
.
payload
.
keyword
)
)
)
{
canShowPrivateSearch
=
false
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
formHistoryResults
.
size
<
maxFormHistoryCount
&
&
result
.
payload
.
lowerCaseSuggestion
&
&
result
.
payload
.
lowerCaseSuggestion
!
=
heuristicResultQuery
)
{
formHistoryResults
.
add
(
result
)
;
formHistorySuggestions
.
add
(
result
.
payload
.
lowerCaseSuggestion
)
;
}
if
(
canShowTailSuggestions
&
&
!
result
.
heuristic
&
&
(
result
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
(
!
result
.
payload
.
inPrivateWindow
&
&
!
result
.
payload
.
tail
)
)
)
{
canShowTailSuggestions
=
false
;
}
}
let
unsortedResults
=
[
]
;
for
(
let
result
of
context
.
results
)
{
if
(
result
.
heuristic
&
&
result
!
=
context
.
heuristicResult
)
{
continue
;
}
if
(
context
.
heuristicResult
&
&
context
.
heuristicResult
.
providerName
=
=
"
Autofill
"
&
&
result
.
providerName
!
=
"
Autofill
"
&
&
context
.
heuristicResult
.
payload
?
.
url
=
=
result
.
payload
.
url
&
&
context
.
heuristicResult
.
type
=
=
result
.
type
)
{
continue
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
payload
.
inPrivateWindow
&
&
!
canShowPrivateSearch
)
{
continue
;
}
if
(
result
.
suggestedIndex
>
=
0
)
{
resultsWithSuggestedIndex
.
push
(
result
)
;
continue
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
!
formHistoryResults
.
has
(
result
)
)
{
continue
;
}
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
&
&
result
.
payload
.
lowerCaseSuggestion
&
&
result
.
payload
.
lowerCaseSuggestion
=
=
=
heuristicResultQuery
)
{
continue
;
}
if
(
!
canShowTailSuggestions
&
&
groupFromResult
(
result
)
=
=
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
&
&
result
.
payload
.
tail
)
{
continue
;
}
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
URL
)
{
let
submission
=
Services
.
search
.
parseSubmissionURL
(
result
.
payload
.
url
)
;
if
(
submission
)
{
let
resultQuery
=
submission
.
terms
.
toLocaleLowerCase
(
)
;
if
(
heuristicResultQuery
=
=
=
resultQuery
|
|
formHistorySuggestions
.
has
(
resultQuery
)
)
{
let
[
newSerpURL
]
=
UrlbarUtils
.
getSearchQueryUrl
(
submission
.
engine
resultQuery
)
;
if
(
this
.
_serpURLsHaveSameParams
(
newSerpURL
result
.
payload
.
url
)
)
{
continue
;
}
}
}
}
unsortedResults
.
push
(
result
)
;
}
let
buckets
=
context
.
heuristicResult
&
&
context
.
heuristicResult
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
?
UrlbarPrefs
.
get
(
"
matchBucketsSearch
"
)
:
UrlbarPrefs
.
get
(
"
matchBuckets
"
)
;
logger
.
debug
(
Buckets
:
{
buckets
}
)
;
let
sortedResults
=
[
]
;
let
handledResults
=
new
Set
(
)
;
let
count
=
Math
.
min
(
unsortedResults
.
length
context
.
maxResults
)
;
for
(
let
b
=
0
;
handledResults
.
size
<
count
&
&
b
<
buckets
.
length
;
b
+
+
)
{
let
[
group
slotCount
]
=
buckets
[
b
]
;
for
(
let
i
=
0
;
slotCount
&
&
handledResults
.
size
<
count
&
&
i
<
unsortedResults
.
length
;
i
+
+
)
{
let
result
=
unsortedResults
[
i
]
;
if
(
!
handledResults
.
has
(
result
)
&
&
group
=
=
groupFromResult
(
result
)
)
{
sortedResults
.
push
(
result
)
;
handledResults
.
add
(
result
)
;
slotCount
-
-
;
}
}
}
resultsWithSuggestedIndex
.
sort
(
(
a
b
)
=
>
a
.
suggestedIndex
-
b
.
suggestedIndex
)
;
for
(
let
result
of
resultsWithSuggestedIndex
)
{
let
index
=
result
.
suggestedIndex
<
=
sortedResults
.
length
?
result
.
suggestedIndex
:
sortedResults
.
length
;
sortedResults
.
splice
(
index
0
result
)
;
}
context
.
results
=
sortedResults
;
}
_serpURLsHaveSameParams
(
url1
url2
)
{
let
params1
=
new
URL
(
url1
)
.
searchParams
;
let
params2
=
new
URL
(
url2
)
.
searchParams
;
for
(
let
params
of
[
params1
params2
]
)
{
params
.
delete
(
"
client
"
)
;
}
for
(
let
[
p1
p2
]
of
[
[
params1
params2
]
[
params2
params1
]
]
)
{
for
(
let
[
key
value
]
of
p1
)
{
if
(
!
p2
.
getAll
(
key
)
.
includes
(
value
)
)
{
return
false
;
}
}
}
return
true
;
}
}
var
UrlbarMuxerUnifiedComplete
=
new
MuxerUnifiedComplete
(
)
;
