"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxerUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarMuxer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Urlbar
.
Muxer
.
UnifiedComplete
"
)
)
;
function
groupFromResult
(
result
)
{
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
return
result
.
payload
.
suggestion
?
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
:
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
;
default
:
return
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
}
}
class
MuxerUnifiedComplete
extends
UrlbarMuxer
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
sort
(
context
)
{
context
.
results
=
this
.
_dedupeSearchHistoryAndSuggestions
(
context
.
results
)
;
let
searchInPrivateWindowIndex
=
context
.
results
.
findIndex
(
r
=
>
r
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
&
&
r
.
payload
.
inPrivateWindow
)
;
if
(
searchInPrivateWindowIndex
!
=
-
1
&
&
(
context
.
results
.
length
=
=
1
|
|
context
.
results
.
some
(
r
=
>
r
.
type
!
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
|
|
r
.
payload
.
keywordOffer
|
|
(
r
.
heuristic
&
&
r
.
payload
.
keyword
)
)
)
)
{
context
.
results
.
splice
(
searchInPrivateWindowIndex
1
)
;
}
if
(
!
context
.
results
.
length
)
{
return
;
}
let
heuristicResult
=
context
.
results
.
find
(
r
=
>
r
.
heuristic
)
;
let
buckets
=
heuristicResult
&
&
heuristicResult
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
?
UrlbarPrefs
.
get
(
"
matchBucketsSearch
"
)
:
UrlbarPrefs
.
get
(
"
matchBuckets
"
)
;
logger
.
debug
(
Buckets
:
{
buckets
}
)
;
let
reshuffleResults
=
context
.
results
.
filter
(
r
=
>
r
.
suggestedIndex
>
=
0
)
.
sort
(
(
a
b
)
=
>
a
.
suggestedIndex
-
b
.
suggestedIndex
)
;
let
sortedResults
=
[
]
;
let
handled
=
new
Set
(
)
;
for
(
let
[
group
slots
]
of
buckets
)
{
for
(
let
result
of
context
.
results
)
{
if
(
slots
=
=
0
)
{
break
;
}
if
(
handled
.
has
(
result
)
)
{
continue
;
}
if
(
group
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
&
&
result
=
=
heuristicResult
)
{
sortedResults
.
unshift
(
result
)
;
handled
.
add
(
result
)
;
slots
-
-
;
}
else
if
(
group
=
=
groupFromResult
(
result
)
)
{
if
(
result
.
suggestedIndex
<
0
)
{
sortedResults
.
push
(
result
)
;
}
handled
.
add
(
result
)
;
slots
-
-
;
}
}
}
for
(
let
result
of
reshuffleResults
)
{
if
(
sortedResults
.
length
>
=
result
.
suggestedIndex
)
{
sortedResults
.
splice
(
result
.
suggestedIndex
0
result
)
;
}
else
{
sortedResults
.
push
(
result
)
;
}
}
context
.
results
=
sortedResults
;
}
_dedupeSearchHistoryAndSuggestions
(
results
)
{
if
(
!
UrlbarPrefs
.
get
(
"
restyleSearches
"
)
|
|
!
UrlbarPrefs
.
get
(
"
browser
.
search
.
suggest
.
enabled
"
)
|
|
!
UrlbarPrefs
.
get
(
"
suggest
.
searches
"
)
)
{
return
results
;
}
let
suggestionResults
=
[
]
;
let
historyEnginesBySuggestion
=
new
Map
(
)
;
for
(
let
i
=
0
;
i
<
results
.
length
;
i
+
+
)
{
let
result
=
results
[
i
]
;
if
(
!
result
.
heuristic
&
&
groupFromResult
(
result
)
=
=
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
)
{
if
(
result
.
payload
.
isSearchHistory
)
{
let
historyEngines
=
historyEnginesBySuggestion
.
get
(
result
.
payload
.
suggestion
)
;
if
(
!
historyEngines
)
{
historyEngines
=
new
Set
(
)
;
historyEnginesBySuggestion
.
set
(
result
.
payload
.
suggestion
historyEngines
)
;
}
historyEngines
.
add
(
result
.
payload
.
engine
)
;
}
else
{
suggestionResults
.
unshift
(
[
result
i
]
)
;
}
}
}
for
(
let
i
=
0
;
historyEnginesBySuggestion
.
size
&
&
i
<
suggestionResults
.
length
;
i
+
+
)
{
let
[
result
index
]
=
suggestionResults
[
i
]
;
let
historyEngines
=
historyEnginesBySuggestion
.
get
(
result
.
payload
.
suggestion
)
;
if
(
historyEngines
&
&
historyEngines
.
has
(
result
.
payload
.
engine
)
)
{
results
.
splice
(
index
1
)
;
historyEngines
.
delete
(
result
.
payload
.
engine
)
;
if
(
!
historyEngines
.
size
)
{
historyEnginesBySuggestion
.
delete
(
result
.
payload
.
suggestion
)
;
}
}
}
return
results
;
}
}
var
UrlbarMuxerUnifiedComplete
=
new
MuxerUnifiedComplete
(
)
;
