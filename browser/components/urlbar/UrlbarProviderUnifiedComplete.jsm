"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderUnifiedComplete
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
UrlbarMatch
:
"
resource
:
/
/
/
modules
/
UrlbarMatch
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
unifiedComplete
"
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
unifiedcomplete
"
"
nsIAutoCompleteSearch
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Places
.
Urlbar
.
Provider
.
UnifiedComplete
"
)
)
;
const
TITLE_TAGS_SEPARATOR
=
"
\
u2013
"
;
class
ProviderUnifiedComplete
{
constructor
(
)
{
this
.
queries
=
new
Map
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
;
}
get
sources
(
)
{
return
[
UrlbarUtils
.
MATCH_SOURCE
.
TABS
]
;
}
async
startQuery
(
queryContext
addCallback
)
{
logger
.
info
(
Starting
query
for
{
queryContext
.
searchString
}
)
;
let
instance
=
{
}
;
this
.
queries
.
set
(
queryContext
instance
)
;
let
params
=
[
"
enable
-
actions
"
]
;
if
(
queryContext
.
isPrivate
)
{
params
.
push
(
"
private
-
window
"
)
;
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
params
.
push
(
"
disable
-
private
-
actions
"
)
;
}
}
if
(
queryContext
.
userContextId
)
{
params
.
push
(
user
-
context
-
id
:
{
queryContext
.
userContextId
}
}
)
;
}
let
urls
=
new
Set
(
)
;
await
new
Promise
(
resolve
=
>
{
let
listener
=
{
onSearchResult
(
_
result
)
{
let
{
done
matches
}
=
convertResultToMatches
(
queryContext
result
urls
)
;
for
(
let
match
of
matches
)
{
addCallback
(
this
match
)
;
}
if
(
done
)
{
resolve
(
)
;
}
}
}
;
unifiedComplete
.
startSearch
(
queryContext
.
searchString
params
.
join
(
"
"
)
null
listener
)
;
}
)
;
this
.
queries
.
delete
(
queryContext
)
;
}
cancelQuery
(
queryContext
)
{
logger
.
info
(
Canceling
query
for
{
queryContext
.
searchString
}
)
;
this
.
queries
.
delete
(
queryContext
)
;
unifiedComplete
.
stopSearch
(
)
;
}
}
var
UrlbarProviderUnifiedComplete
=
new
ProviderUnifiedComplete
(
)
;
function
convertResultToMatches
(
context
result
urls
)
{
let
matches
=
[
]
;
let
done
=
[
Ci
.
nsIAutoCompleteResult
.
RESULT_IGNORED
Ci
.
nsIAutoCompleteResult
.
RESULT_FAILURE
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
]
.
includes
(
result
.
searchResult
)
|
|
result
.
errorDescription
;
for
(
let
i
=
0
;
i
<
result
.
matchCount
;
+
+
i
)
{
let
url
=
result
.
getFinalCompleteValueAt
(
i
)
;
if
(
urls
.
has
(
url
)
)
{
continue
;
}
urls
.
add
(
url
)
;
let
style
=
result
.
getStyleAt
(
i
)
;
let
match
=
makeUrlbarMatch
(
{
url
icon
:
result
.
getImageAt
(
i
)
style
comment
:
result
.
getCommentAt
(
i
)
firstToken
:
context
.
tokens
[
0
]
}
)
;
if
(
!
match
)
{
continue
;
}
matches
.
push
(
match
)
;
if
(
i
=
=
0
&
&
result
.
defaultIndex
=
=
0
)
{
if
(
style
.
includes
(
"
autofill
"
)
)
{
context
.
autofill
=
true
;
}
if
(
style
.
includes
(
"
heuristic
"
)
)
{
context
.
preselected
=
true
;
}
}
}
return
{
matches
done
}
;
}
function
makeUrlbarMatch
(
info
)
{
let
action
=
PlacesUtils
.
parseActionUrl
(
info
.
url
)
;
if
(
action
)
{
switch
(
action
.
type
)
{
case
"
searchengine
"
:
return
new
UrlbarMatch
(
UrlbarUtils
.
MATCH_TYPE
.
SEARCH
UrlbarUtils
.
MATCH_SOURCE
.
SEARCH
{
engine
:
action
.
params
.
engineName
suggestion
:
action
.
params
.
searchSuggestion
keyword
:
action
.
params
.
alias
query
:
action
.
params
.
searchQuery
icon
:
info
.
icon
}
)
;
case
"
keyword
"
:
return
new
UrlbarMatch
(
UrlbarUtils
.
MATCH_TYPE
.
KEYWORD
UrlbarUtils
.
MATCH_SOURCE
.
BOOKMARKS
{
url
:
action
.
params
.
url
keyword
:
info
.
firstToken
postData
:
action
.
params
.
postData
icon
:
info
.
icon
}
)
;
case
"
extension
"
:
return
new
UrlbarMatch
(
UrlbarUtils
.
MATCH_TYPE
.
OMNIBOX
UrlbarUtils
.
MATCH_SOURCE
.
OTHER_NETWORK
{
title
:
info
.
comment
content
:
action
.
params
.
content
keyword
:
action
.
params
.
keyword
icon
:
info
.
icon
}
)
;
case
"
remotetab
"
:
return
new
UrlbarMatch
(
UrlbarUtils
.
MATCH_TYPE
.
REMOTE_TAB
UrlbarUtils
.
MATCH_SOURCE
.
TABS
{
url
:
action
.
params
.
url
title
:
info
.
comment
device
:
action
.
params
.
deviceName
icon
:
info
.
icon
}
)
;
case
"
visiturl
"
:
return
new
UrlbarMatch
(
UrlbarUtils
.
MATCH_TYPE
.
URL
UrlbarUtils
.
MATCH_SOURCE
.
OTHER_LOCAL
{
title
:
info
.
comment
url
:
action
.
params
.
url
icon
:
info
.
icon
}
)
;
default
:
Cu
.
reportError
(
"
Unexpected
action
type
"
)
;
return
null
;
}
}
if
(
info
.
style
.
includes
(
"
priority
-
search
"
)
)
{
return
new
UrlbarMatch
(
UrlbarUtils
.
MATCH_TYPE
.
SEARCH
UrlbarUtils
.
MATCH_SOURCE
.
SEARCH
{
engine
:
info
.
comment
icon
:
info
.
icon
}
)
;
}
let
source
tags
comment
;
let
hasTags
=
info
.
style
.
includes
(
"
tag
"
)
;
if
(
info
.
style
.
includes
(
"
bookmark
"
)
|
|
hasTags
)
{
source
=
UrlbarUtils
.
MATCH_SOURCE
.
BOOKMARKS
;
if
(
info
.
style
.
includes
(
"
tag
"
)
)
{
[
comment
tags
]
=
info
.
comment
.
split
(
TITLE_TAGS_SEPARATOR
)
;
tags
=
tags
.
split
(
"
"
)
.
map
(
t
=
>
t
.
trim
(
)
)
;
}
}
else
if
(
info
.
style
.
includes
(
"
preloaded
-
top
-
sites
"
)
)
{
source
=
UrlbarUtils
.
MATCH_SOURCE
.
OTHER_LOCAL
;
}
else
{
source
=
UrlbarUtils
.
MATCH_SOURCE
.
HISTORY
;
}
return
new
UrlbarMatch
(
UrlbarUtils
.
MATCH_TYPE
.
URL
source
{
url
:
info
.
url
icon
:
info
.
icon
title
:
comment
tags
}
)
;
}
