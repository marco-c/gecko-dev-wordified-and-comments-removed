"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderUnifiedComplete
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
unifiedComplete
"
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
unifiedcomplete
"
"
nsIAutoCompleteSearch
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Places
.
Urlbar
.
Provider
.
UnifiedComplete
"
)
)
;
const
TITLE_TAGS_SEPARATOR
=
"
\
u2013
"
;
class
ProviderUnifiedComplete
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
this
.
queries
=
new
Map
(
)
;
}
get
name
(
)
{
return
"
UnifiedComplete
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
IMMEDIATE
;
}
get
sources
(
)
{
return
[
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
TABS
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
]
;
}
async
startQuery
(
queryContext
addCallback
)
{
logger
.
info
(
Starting
query
for
{
queryContext
.
searchString
}
)
;
let
instance
=
{
}
;
this
.
queries
.
set
(
queryContext
instance
)
;
let
params
=
[
"
enable
-
actions
"
]
;
params
.
push
(
max
-
results
:
{
queryContext
.
maxResults
}
)
;
params
.
push
(
insert
-
method
:
{
UrlbarUtils
.
INSERTMETHOD
.
APPEND
}
)
;
params
.
push
(
"
disable
-
telemetry
"
)
;
if
(
queryContext
.
isPrivate
)
{
params
.
push
(
"
private
-
window
"
)
;
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
params
.
push
(
"
disable
-
private
-
actions
"
)
;
}
}
if
(
queryContext
.
userContextId
)
{
params
.
push
(
user
-
context
-
id
:
{
queryContext
.
userContextId
}
}
)
;
}
if
(
!
queryContext
.
enableAutofill
)
{
params
.
push
(
"
prohibit
-
autofill
"
)
;
}
let
urls
=
new
Set
(
)
;
await
new
Promise
(
resolve
=
>
{
let
listener
=
{
onSearchResult
(
_
result
)
{
let
{
done
matches
}
=
convertResultToMatches
(
queryContext
result
urls
)
;
for
(
let
match
of
matches
)
{
addCallback
(
UrlbarProviderUnifiedComplete
match
)
;
}
if
(
done
)
{
resolve
(
)
;
}
}
}
;
unifiedComplete
.
startSearch
(
queryContext
.
searchString
params
.
join
(
"
"
)
null
listener
)
;
}
)
;
this
.
queries
.
delete
(
queryContext
)
;
}
cancelQuery
(
queryContext
)
{
logger
.
info
(
Canceling
query
for
{
queryContext
.
searchString
}
)
;
this
.
queries
.
delete
(
queryContext
)
;
unifiedComplete
.
stopSearch
(
)
;
}
}
var
UrlbarProviderUnifiedComplete
=
new
ProviderUnifiedComplete
(
)
;
function
convertResultToMatches
(
context
result
urls
)
{
let
matches
=
[
]
;
let
done
=
[
Ci
.
nsIAutoCompleteResult
.
RESULT_IGNORED
Ci
.
nsIAutoCompleteResult
.
RESULT_FAILURE
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
]
.
includes
(
result
.
searchResult
)
|
|
result
.
errorDescription
;
for
(
let
i
=
0
;
i
<
result
.
matchCount
;
+
+
i
)
{
let
url
=
result
.
getFinalCompleteValueAt
(
i
)
;
if
(
urls
.
has
(
url
)
)
{
continue
;
}
urls
.
add
(
url
)
;
let
style
=
result
.
getStyleAt
(
i
)
;
let
match
=
makeUrlbarResult
(
context
.
tokens
{
url
icon
:
result
.
getImageAt
(
i
)
style
comment
:
result
.
getCommentAt
(
i
)
firstToken
:
context
.
tokens
[
0
]
}
)
;
if
(
!
match
)
{
continue
;
}
if
(
i
=
=
0
)
{
if
(
style
.
includes
(
"
autofill
"
)
&
&
result
.
defaultIndex
=
=
0
)
{
let
autofillValue
=
result
.
getValueAt
(
i
)
;
if
(
autofillValue
.
toLocaleLowerCase
(
)
.
startsWith
(
context
.
searchString
.
toLocaleLowerCase
(
)
)
)
{
match
.
autofill
=
{
value
:
context
.
searchString
+
autofillValue
.
substring
(
context
.
searchString
.
length
)
selectionStart
:
context
.
searchString
.
length
selectionEnd
:
autofillValue
.
length
}
;
}
}
if
(
style
.
includes
(
"
heuristic
"
)
)
{
context
.
preselected
=
true
;
match
.
heuristic
=
true
;
}
}
matches
.
push
(
match
)
;
}
return
{
matches
done
}
;
}
function
makeUrlbarResult
(
tokens
info
)
{
let
action
=
PlacesUtils
.
parseActionUrl
(
info
.
url
)
;
if
(
action
)
{
switch
(
action
.
type
)
{
case
"
searchengine
"
:
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
engine
:
[
action
.
params
.
engineName
true
]
suggestion
:
[
action
.
params
.
searchSuggestion
true
]
keyword
:
[
action
.
params
.
alias
true
]
query
:
[
action
.
params
.
searchQuery
true
]
icon
:
[
info
.
icon
false
]
}
)
)
;
case
"
keyword
"
:
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
url
:
[
action
.
params
.
url
true
]
keyword
:
[
info
.
firstToken
true
]
postData
:
[
action
.
params
.
postData
false
]
icon
:
[
info
.
icon
false
]
}
)
)
;
case
"
extension
"
:
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
title
:
[
info
.
comment
true
]
content
:
[
action
.
params
.
content
true
]
keyword
:
[
action
.
params
.
keyword
true
]
icon
:
[
info
.
icon
false
]
}
)
)
;
case
"
remotetab
"
:
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
UrlbarUtils
.
RESULT_SOURCE
.
TABS
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
url
:
[
action
.
params
.
url
true
]
title
:
[
info
.
comment
true
]
device
:
[
action
.
params
.
deviceName
true
]
icon
:
[
info
.
icon
false
]
}
)
)
;
case
"
switchtab
"
:
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
UrlbarUtils
.
RESULT_SOURCE
.
TABS
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
url
:
[
action
.
params
.
url
true
]
title
:
[
info
.
comment
true
]
device
:
[
action
.
params
.
deviceName
true
]
icon
:
[
info
.
icon
false
]
}
)
)
;
case
"
visiturl
"
:
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
title
:
[
info
.
comment
true
]
url
:
[
action
.
params
.
url
true
]
icon
:
[
info
.
icon
false
]
}
)
)
;
default
:
Cu
.
reportError
(
Unexpected
action
type
:
{
action
.
type
}
)
;
return
null
;
}
}
if
(
info
.
style
.
includes
(
"
priority
-
search
"
)
)
{
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
engine
:
[
info
.
comment
true
]
icon
:
[
info
.
icon
false
]
}
)
)
;
}
let
source
;
let
tags
=
[
]
;
let
comment
=
info
.
comment
;
let
hasTags
=
info
.
style
.
includes
(
"
tag
"
)
;
if
(
info
.
style
.
includes
(
"
bookmark
"
)
|
|
hasTags
)
{
source
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
;
if
(
hasTags
)
{
[
comment
tags
]
=
info
.
comment
.
split
(
TITLE_TAGS_SEPARATOR
)
;
tags
=
tags
.
split
(
"
"
)
.
map
(
t
=
>
t
.
trim
(
)
)
.
filter
(
tag
=
>
{
return
tokens
.
some
(
token
=
>
tag
.
includes
(
token
.
value
)
)
;
}
)
.
sort
(
)
;
}
}
else
if
(
info
.
style
.
includes
(
"
preloaded
-
top
-
sites
"
)
)
{
source
=
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
;
}
else
{
source
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
;
}
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
source
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
url
:
[
info
.
url
true
]
icon
:
[
info
.
icon
false
]
title
:
[
comment
true
]
tags
:
[
tags
true
]
}
)
)
;
}
