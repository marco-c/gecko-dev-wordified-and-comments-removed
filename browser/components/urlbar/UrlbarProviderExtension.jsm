"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderExtension
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
SkippableTimer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
class
UrlbarProviderExtension
extends
UrlbarProvider
{
static
getOrCreate
(
name
)
{
let
provider
=
UrlbarProvidersManager
.
getProvider
(
name
)
;
if
(
!
provider
)
{
provider
=
new
UrlbarProviderExtension
(
name
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
}
return
provider
;
}
constructor
(
name
)
{
super
(
)
;
this
.
_name
=
name
;
this
.
_eventListeners
=
new
Map
(
)
;
this
.
behavior
=
"
inactive
"
;
}
get
name
(
)
{
return
this
.
_name
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
;
}
isActive
(
context
)
{
return
this
.
behavior
!
=
"
inactive
"
;
}
getPriority
(
context
)
{
return
this
.
behavior
=
=
"
restricting
"
?
999
:
0
;
}
setEventListener
(
eventName
listener
)
{
if
(
listener
)
{
this
.
_eventListeners
.
set
(
eventName
listener
)
;
}
else
{
this
.
_eventListeners
.
delete
(
eventName
)
;
if
(
!
this
.
_eventListeners
.
size
)
{
UrlbarProvidersManager
.
unregisterProvider
(
this
)
;
}
}
}
async
updateBehavior
(
context
)
{
let
behavior
=
await
this
.
_notifyListener
(
"
behaviorRequested
"
context
)
;
if
(
behavior
)
{
this
.
behavior
=
behavior
;
}
}
async
getViewUpdate
(
result
idsByName
)
{
return
this
.
_notifyListener
(
"
getViewUpdate
"
result
idsByName
)
;
}
async
startQuery
(
context
addCallback
)
{
let
extResults
=
await
this
.
_notifyListener
(
"
resultsRequested
"
context
)
;
if
(
extResults
)
{
for
(
let
extResult
of
extResults
)
{
let
result
=
await
this
.
_makeUrlbarResult
(
context
extResult
)
.
catch
(
Cu
.
reportError
)
;
if
(
result
)
{
addCallback
(
this
result
)
;
}
}
}
}
cancelQuery
(
context
)
{
this
.
_notifyListener
(
"
queryCanceled
"
context
)
;
}
pickResult
(
result
element
)
{
let
dynamicElementName
=
"
"
;
if
(
element
&
&
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
)
{
dynamicElementName
=
element
.
getAttribute
(
"
name
"
)
;
}
this
.
_notifyListener
(
"
resultPicked
"
result
.
payload
dynamicElementName
)
;
}
onEngagement
(
isPrivate
state
)
{
this
.
_notifyListener
(
"
engagement
"
isPrivate
state
)
;
}
async
_notifyListener
(
eventName
.
.
.
args
)
{
let
listener
=
this
.
_eventListeners
.
get
(
eventName
)
;
if
(
!
listener
)
{
return
undefined
;
}
let
result
;
try
{
result
=
listener
(
.
.
.
args
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
return
undefined
;
}
if
(
result
.
catch
)
{
let
timer
=
new
SkippableTimer
(
{
name
:
"
UrlbarProviderExtension
notification
timer
"
time
:
UrlbarPrefs
.
get
(
"
extension
.
timeout
"
)
reportErrorOnTimeout
:
true
logger
:
this
.
logger
}
)
;
result
=
await
Promise
.
race
(
[
timer
.
promise
result
.
catch
(
Cu
.
reportError
)
]
)
;
timer
.
cancel
(
)
;
}
return
result
;
}
async
_makeUrlbarResult
(
context
extResult
)
{
if
(
extResult
.
type
=
=
"
search
"
)
{
let
engine
;
if
(
extResult
.
payload
.
engine
)
{
engine
=
Services
.
search
.
getEngineByName
(
extResult
.
payload
.
engine
)
;
}
else
if
(
extResult
.
payload
.
keyword
)
{
engine
=
await
UrlbarSearchUtils
.
engineForAlias
(
extResult
.
payload
.
keyword
)
;
}
else
if
(
extResult
.
payload
.
url
)
{
let
host
;
try
{
host
=
new
URL
(
extResult
.
payload
.
url
)
.
hostname
;
}
catch
(
err
)
{
}
if
(
host
)
{
engine
=
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
host
)
)
[
0
]
;
}
}
if
(
!
engine
)
{
throw
new
Error
(
"
Invalid
or
missing
engine
specified
by
extension
"
)
;
}
extResult
.
payload
.
engine
=
engine
.
name
;
}
let
type
=
UrlbarProviderExtension
.
RESULT_TYPES
[
extResult
.
type
]
;
if
(
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
TIP
)
{
extResult
.
payload
.
type
=
extResult
.
payload
.
type
|
|
"
extension
"
;
}
let
result
=
new
UrlbarResult
(
UrlbarProviderExtension
.
RESULT_TYPES
[
extResult
.
type
]
UrlbarProviderExtension
.
SOURCE_TYPES
[
extResult
.
source
]
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
context
.
tokens
extResult
.
payload
|
|
{
}
)
)
;
if
(
extResult
.
heuristic
&
&
this
.
behavior
=
=
"
restricting
"
)
{
result
.
heuristic
=
extResult
.
heuristic
;
}
if
(
extResult
.
suggestedIndex
!
=
=
undefined
)
{
result
.
suggestedIndex
=
extResult
.
suggestedIndex
;
}
return
result
;
}
}
UrlbarProviderExtension
.
RESULT_TYPES
=
{
dynamic
:
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
keyword
:
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
omnibox
:
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
remote_tab
:
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
search
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
tab
:
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
tip
:
UrlbarUtils
.
RESULT_TYPE
.
TIP
url
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
;
UrlbarProviderExtension
.
SOURCE_TYPES
=
{
bookmarks
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
history
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
local
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
network
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
search
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
tabs
:
UrlbarUtils
.
RESULT_SOURCE
.
TABS
}
;
