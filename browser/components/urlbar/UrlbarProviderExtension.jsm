"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderExtension
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesSearchAutocompleteProvider
:
"
resource
:
/
/
gre
/
modules
/
PlacesSearchAutocompleteProvider
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
SkippableTimer
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
DEFAULT_NOTIFICATION_TIMEOUT
=
200
;
class
UrlbarProviderExtension
extends
UrlbarProvider
{
static
getOrCreate
(
name
)
{
let
provider
=
UrlbarProvidersManager
.
getProvider
(
name
)
;
if
(
!
provider
)
{
provider
=
new
UrlbarProviderExtension
(
name
)
;
UrlbarProvidersManager
.
registerProvider
(
provider
)
;
}
return
provider
;
}
constructor
(
name
)
{
super
(
)
;
this
.
_name
=
name
;
this
.
_eventListeners
=
new
Map
(
)
;
this
.
behavior
=
"
inactive
"
;
}
get
name
(
)
{
return
this
.
_name
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
;
}
isActive
(
context
)
{
return
this
.
behavior
!
=
"
inactive
"
;
}
isRestricting
(
context
)
{
return
this
.
behavior
=
=
"
restricting
"
;
}
setEventListener
(
eventName
listener
)
{
if
(
listener
)
{
this
.
_eventListeners
.
set
(
eventName
listener
)
;
}
else
{
this
.
_eventListeners
.
delete
(
eventName
)
;
if
(
!
this
.
_eventListeners
.
size
)
{
UrlbarProvidersManager
.
unregisterProvider
(
this
)
;
}
}
}
async
updateBehavior
(
context
)
{
let
behavior
=
await
this
.
_notifyListener
(
"
behaviorRequested
"
context
)
;
if
(
behavior
)
{
this
.
behavior
=
behavior
;
}
}
async
startQuery
(
context
addCallback
)
{
let
extResults
=
await
this
.
_notifyListener
(
"
resultsRequested
"
context
)
;
if
(
extResults
)
{
for
(
let
extResult
of
extResults
)
{
let
result
=
await
this
.
_makeUrlbarResult
(
context
extResult
)
.
catch
(
Cu
.
reportError
)
;
if
(
result
)
{
addCallback
(
this
result
)
;
}
}
}
}
cancelQuery
(
context
)
{
this
.
_notifyListener
(
"
queryCanceled
"
context
)
;
}
pickResult
(
result
)
{
this
.
_notifyListener
(
"
resultPicked
"
result
.
payload
)
;
}
onEngagement
(
isPrivate
state
)
{
this
.
_notifyListener
(
"
engagement
"
isPrivate
state
)
;
}
async
_notifyListener
(
eventName
.
.
.
args
)
{
let
listener
=
this
.
_eventListeners
.
get
(
eventName
)
;
if
(
!
listener
)
{
return
undefined
;
}
let
result
;
try
{
result
=
listener
(
.
.
.
args
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
return
undefined
;
}
if
(
result
.
catch
)
{
let
timer
=
new
SkippableTimer
(
{
name
:
"
UrlbarProviderExtension
notification
timer
"
time
:
UrlbarProviderExtension
.
notificationTimeout
reportErrorOnTimeout
:
true
}
)
;
result
=
await
Promise
.
race
(
[
timer
.
promise
result
.
catch
(
Cu
.
reportError
)
]
)
;
timer
.
cancel
(
)
;
}
return
result
;
}
async
_makeUrlbarResult
(
context
extResult
)
{
if
(
extResult
.
type
=
=
"
search
"
)
{
let
engine
;
if
(
extResult
.
payload
.
engine
)
{
engine
=
Services
.
search
.
getEngineByName
(
extResult
.
payload
.
engine
)
;
}
else
if
(
extResult
.
payload
.
keyword
)
{
engine
=
await
PlacesSearchAutocompleteProvider
.
engineForAlias
(
extResult
.
payload
.
keyword
)
;
}
else
if
(
extResult
.
payload
.
url
)
{
let
host
;
try
{
host
=
new
URL
(
extResult
.
payload
.
url
)
.
hostname
;
}
catch
(
err
)
{
}
if
(
host
)
{
engine
=
await
PlacesSearchAutocompleteProvider
.
engineForDomainPrefix
(
host
)
;
}
}
if
(
!
engine
)
{
throw
new
Error
(
"
Invalid
or
missing
engine
specified
by
extension
"
)
;
}
extResult
.
payload
.
engine
=
engine
.
name
;
}
let
result
=
new
UrlbarResult
(
UrlbarProviderExtension
.
RESULT_TYPES
[
extResult
.
type
]
UrlbarProviderExtension
.
SOURCE_TYPES
[
extResult
.
source
]
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
context
.
tokens
extResult
.
payload
|
|
{
}
)
)
;
if
(
extResult
.
heuristic
&
&
this
.
behavior
=
=
"
restricting
"
)
{
result
.
heuristic
=
extResult
.
heuristic
;
}
if
(
extResult
.
suggestedIndex
!
=
=
undefined
)
{
result
.
suggestedIndex
=
extResult
.
suggestedIndex
;
}
return
result
;
}
}
UrlbarProviderExtension
.
RESULT_TYPES
=
{
keyword
:
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
omnibox
:
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
remote_tab
:
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
search
:
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
tab
:
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
tip
:
UrlbarUtils
.
RESULT_TYPE
.
TIP
url
:
UrlbarUtils
.
RESULT_TYPE
.
URL
}
;
UrlbarProviderExtension
.
SOURCE_TYPES
=
{
bookmarks
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
history
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
local
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
network
:
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_NETWORK
search
:
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
tabs
:
UrlbarUtils
.
RESULT_SOURCE
.
TABS
}
;
UrlbarProviderExtension
.
notificationTimeout
=
DEFAULT_NOTIFICATION_TIMEOUT
;
