"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarController
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
BrowserUsageTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
URLBAR_SELECTED_RESULT_TYPES
:
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
}
)
;
const
TELEMETRY_1ST_RESULT
=
"
PLACES_AUTOCOMPLETE_1ST_RESULT_TIME_MS
"
;
const
TELEMETRY_6_FIRST_RESULTS
=
"
PLACES_AUTOCOMPLETE_6_FIRST_RESULTS_TIME_MS
"
;
const
NOTIFICATIONS
=
{
QUERY_STARTED
:
"
onQueryStarted
"
QUERY_RESULTS
:
"
onQueryResults
"
QUERY_RESULT_REMOVED
:
"
onQueryResultRemoved
"
QUERY_CANCELLED
:
"
onQueryCancelled
"
QUERY_FINISHED
:
"
onQueryFinished
"
VIEW_OPEN
:
"
onViewOpen
"
VIEW_CLOSE
:
"
onViewClose
"
}
;
class
UrlbarController
{
constructor
(
options
=
{
}
)
{
if
(
!
options
.
browserWindow
)
{
throw
new
Error
(
"
Missing
options
:
browserWindow
"
)
;
}
if
(
!
options
.
browserWindow
.
location
|
|
options
.
browserWindow
.
location
.
href
!
=
AppConstants
.
BROWSER_CHROME_URL
)
{
throw
new
Error
(
"
browserWindow
should
be
an
actual
browser
window
.
"
)
;
}
this
.
manager
=
options
.
manager
|
|
UrlbarProvidersManager
;
this
.
browserWindow
=
options
.
browserWindow
;
this
.
_listeners
=
new
Set
(
)
;
this
.
_userSelectionBehavior
=
"
none
"
;
this
.
engagementEvent
=
new
TelemetryEvent
(
options
.
eventTelemetryCategory
)
;
}
get
NOTIFICATIONS
(
)
{
return
NOTIFICATIONS
;
}
setInput
(
input
)
{
this
.
input
=
input
;
}
setView
(
view
)
{
this
.
view
=
view
;
}
async
startQuery
(
queryContext
)
{
this
.
cancelQuery
(
)
;
let
contextWrapper
=
(
this
.
_lastQueryContextWrapper
=
{
queryContext
}
)
;
queryContext
.
lastResultCount
=
0
;
TelemetryStopwatch
.
start
(
TELEMETRY_1ST_RESULT
queryContext
)
;
TelemetryStopwatch
.
start
(
TELEMETRY_6_FIRST_RESULTS
queryContext
)
;
this
.
notify
(
NOTIFICATIONS
.
QUERY_STARTED
queryContext
)
;
await
this
.
manager
.
startQuery
(
queryContext
this
)
;
if
(
contextWrapper
=
=
=
this
.
_lastQueryContextWrapper
&
&
!
contextWrapper
.
done
)
{
contextWrapper
.
done
=
true
;
this
.
manager
.
cancelQuery
(
queryContext
)
;
this
.
notify
(
NOTIFICATIONS
.
QUERY_FINISHED
queryContext
)
;
}
return
queryContext
;
}
cancelQuery
(
)
{
if
(
!
this
.
_lastQueryContextWrapper
|
|
this
.
_lastQueryContextWrapper
.
done
)
{
return
;
}
this
.
_lastQueryContextWrapper
.
done
=
true
;
let
{
queryContext
}
=
this
.
_lastQueryContextWrapper
;
TelemetryStopwatch
.
cancel
(
TELEMETRY_1ST_RESULT
queryContext
)
;
TelemetryStopwatch
.
cancel
(
TELEMETRY_6_FIRST_RESULTS
queryContext
)
;
this
.
manager
.
cancelQuery
(
queryContext
)
;
this
.
notify
(
NOTIFICATIONS
.
QUERY_CANCELLED
queryContext
)
;
this
.
notify
(
NOTIFICATIONS
.
QUERY_FINISHED
queryContext
)
;
}
receiveResults
(
queryContext
)
{
if
(
queryContext
.
lastResultCount
<
1
&
&
queryContext
.
results
.
length
>
=
1
)
{
TelemetryStopwatch
.
finish
(
TELEMETRY_1ST_RESULT
queryContext
)
;
}
if
(
queryContext
.
lastResultCount
<
6
&
&
queryContext
.
results
.
length
>
=
6
)
{
TelemetryStopwatch
.
finish
(
TELEMETRY_6_FIRST_RESULTS
queryContext
)
;
}
if
(
queryContext
.
lastResultCount
=
=
0
&
&
queryContext
.
results
.
length
)
{
if
(
queryContext
.
results
[
0
]
.
autofill
)
{
this
.
input
.
autofillFirstResult
(
queryContext
.
results
[
0
]
)
;
}
this
.
speculativeConnect
(
queryContext
.
results
[
0
]
queryContext
"
resultsadded
"
)
;
}
this
.
notify
(
NOTIFICATIONS
.
QUERY_RESULTS
queryContext
)
;
queryContext
.
lastResultCount
=
queryContext
.
results
.
length
;
}
addQueryListener
(
listener
)
{
if
(
!
listener
|
|
typeof
listener
!
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
listener
to
be
an
object
"
)
;
}
this
.
_listeners
.
add
(
listener
)
;
}
removeQueryListener
(
listener
)
{
this
.
_listeners
.
delete
(
listener
)
;
}
keyEventMovesCaret
(
event
)
{
if
(
this
.
view
.
isOpen
)
{
return
false
;
}
if
(
AppConstants
.
platform
!
=
"
macosx
"
&
&
AppConstants
.
platform
!
=
"
linux
"
)
{
return
false
;
}
let
isArrowUp
=
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_UP
;
let
isArrowDown
=
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_DOWN
;
if
(
!
isArrowUp
&
&
!
isArrowDown
)
{
return
false
;
}
let
start
=
this
.
input
.
selectionStart
;
let
end
=
this
.
input
.
selectionEnd
;
if
(
end
!
=
start
|
|
(
isArrowUp
&
&
start
>
0
)
|
|
(
isArrowDown
&
&
end
<
this
.
input
.
value
.
length
)
)
{
return
true
;
}
return
false
;
}
handleKeyNavigation
(
event
executeAction
=
true
)
{
const
isMac
=
AppConstants
.
platform
=
=
"
macosx
"
;
if
(
isMac
&
&
this
.
view
.
isOpen
&
&
event
.
ctrlKey
&
&
(
event
.
key
=
=
"
n
"
|
|
event
.
key
=
=
"
p
"
)
)
{
if
(
executeAction
)
{
this
.
view
.
selectBy
(
1
{
reverse
:
event
.
key
=
=
"
p
"
}
)
;
}
event
.
preventDefault
(
)
;
return
;
}
if
(
this
.
view
.
isOpen
&
&
executeAction
&
&
this
.
_lastQueryContextWrapper
)
{
let
{
queryContext
}
=
this
.
_lastQueryContextWrapper
;
let
handled
=
this
.
view
.
oneOffSearchButtons
.
handleKeyPress
(
event
this
.
view
.
visibleElementCount
this
.
view
.
allowEmptySelection
queryContext
.
searchString
)
;
if
(
handled
)
{
return
;
}
}
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_ESCAPE
:
if
(
executeAction
)
{
if
(
this
.
view
.
isOpen
)
{
this
.
view
.
close
(
)
;
}
else
{
this
.
input
.
handleRevert
(
)
;
}
}
event
.
preventDefault
(
)
;
break
;
case
KeyEvent
.
DOM_VK_RETURN
:
if
(
executeAction
)
{
this
.
input
.
handleCommand
(
event
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyEvent
.
DOM_VK_TAB
:
if
(
this
.
view
.
isOpen
&
&
!
event
.
ctrlKey
&
&
!
event
.
altKey
)
{
if
(
executeAction
)
{
this
.
userSelectionBehavior
=
"
tab
"
;
this
.
view
.
selectBy
(
1
{
reverse
:
event
.
shiftKey
}
)
;
}
event
.
preventDefault
(
)
;
}
break
;
case
KeyEvent
.
DOM_VK_DOWN
:
case
KeyEvent
.
DOM_VK_UP
:
case
KeyEvent
.
DOM_VK_PAGE_DOWN
:
case
KeyEvent
.
DOM_VK_PAGE_UP
:
if
(
event
.
ctrlKey
|
|
event
.
altKey
)
{
break
;
}
if
(
this
.
view
.
isOpen
)
{
if
(
executeAction
)
{
this
.
userSelectionBehavior
=
"
arrow
"
;
this
.
view
.
selectBy
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_PAGE_DOWN
|
|
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_PAGE_UP
?
UrlbarUtils
.
PAGE_UP_DOWN_DELTA
:
1
{
reverse
:
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_UP
|
|
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_PAGE_UP
}
)
;
}
}
else
{
if
(
this
.
keyEventMovesCaret
(
event
)
)
{
break
;
}
if
(
executeAction
)
{
this
.
userSelectionBehavior
=
"
arrow
"
;
this
.
input
.
startQuery
(
{
searchString
:
this
.
input
.
value
event
}
)
;
}
}
event
.
preventDefault
(
)
;
break
;
case
KeyEvent
.
DOM_VK_LEFT
:
case
KeyEvent
.
DOM_VK_RIGHT
:
case
KeyEvent
.
DOM_VK_HOME
:
case
KeyEvent
.
DOM_VK_END
:
this
.
view
.
removeAccessibleFocus
(
)
;
break
;
case
KeyEvent
.
DOM_VK_DELETE
:
case
KeyEvent
.
DOM_VK_BACK_SPACE
:
if
(
!
this
.
view
.
isOpen
)
{
break
;
}
if
(
event
.
shiftKey
)
{
if
(
!
executeAction
|
|
this
.
_handleDeleteEntry
(
)
)
{
event
.
preventDefault
(
)
;
}
}
else
if
(
executeAction
)
{
this
.
userSelectionBehavior
=
"
none
"
;
}
break
;
}
}
speculativeConnect
(
result
context
reason
)
{
if
(
!
this
.
input
|
|
context
.
isPrivate
|
|
!
context
.
results
.
length
)
{
return
;
}
let
{
url
}
=
UrlbarUtils
.
getUrlFromResult
(
result
)
;
if
(
!
url
)
{
return
;
}
switch
(
reason
)
{
case
"
resultsadded
"
:
{
if
(
(
result
=
=
context
.
results
[
0
]
&
&
context
.
preselected
)
|
|
result
.
autofill
)
{
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
)
{
if
(
UrlbarPrefs
.
get
(
"
suggest
.
searches
"
)
&
&
UrlbarPrefs
.
get
(
"
browser
.
search
.
suggest
.
enabled
"
)
)
{
let
engine
=
Services
.
search
.
defaultEngine
;
UrlbarUtils
.
setupSpeculativeConnection
(
engine
this
.
browserWindow
)
;
}
}
else
if
(
result
.
autofill
)
{
UrlbarUtils
.
setupSpeculativeConnection
(
url
this
.
browserWindow
)
;
}
}
return
;
}
case
"
mousedown
"
:
{
if
(
url
.
startsWith
(
"
http
"
)
)
{
UrlbarUtils
.
setupSpeculativeConnection
(
url
this
.
browserWindow
)
;
}
return
;
}
default
:
{
throw
new
Error
(
"
Invalid
speculative
connection
reason
"
)
;
}
}
}
set
userSelectionBehavior
(
behavior
)
{
if
(
behavior
=
=
"
arrow
"
&
&
this
.
_userSelectionBehavior
=
=
"
tab
"
)
{
return
;
}
this
.
_userSelectionBehavior
=
behavior
;
}
recordSelectedResult
(
event
result
)
{
let
resultIndex
=
result
?
result
.
rowIndex
:
-
1
;
let
selectedResult
=
-
1
;
if
(
resultIndex
>
=
0
)
{
selectedResult
=
resultIndex
>
0
|
|
!
result
.
heuristic
?
resultIndex
:
-
1
;
}
BrowserUsageTelemetry
.
recordUrlbarSelectedResultMethod
(
event
selectedResult
this
.
_userSelectionBehavior
)
;
if
(
!
result
)
{
return
;
}
let
telemetryType
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
telemetryType
=
"
switchtab
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
telemetryType
=
result
.
payload
.
suggestion
?
"
searchsuggestion
"
:
"
searchengine
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
if
(
result
.
autofill
)
{
telemetryType
=
"
autofill
"
;
}
else
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
&
&
result
.
heuristic
)
{
telemetryType
=
"
visiturl
"
;
}
else
{
telemetryType
=
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
?
"
bookmark
"
:
"
history
"
;
}
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
telemetryType
=
"
keyword
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
telemetryType
=
"
extension
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
telemetryType
=
"
remotetab
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
telemetryType
=
"
tip
"
;
break
;
default
:
Cu
.
reportError
(
Unknown
Result
Type
{
result
.
type
}
)
;
return
;
}
Services
.
telemetry
.
getHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_INDEX
"
)
.
add
(
resultIndex
)
;
if
(
telemetryType
in
URLBAR_SELECTED_RESULT_TYPES
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_TYPE
"
)
.
add
(
URLBAR_SELECTED_RESULT_TYPES
[
telemetryType
]
)
;
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_INDEX_BY_TYPE
"
)
.
add
(
telemetryType
resultIndex
)
;
}
else
{
Cu
.
reportError
(
"
Unknown
FX_URLBAR_SELECTED_RESULT_TYPE
type
:
"
+
telemetryType
)
;
}
}
_handleDeleteEntry
(
)
{
if
(
!
this
.
_lastQueryContextWrapper
)
{
Cu
.
reportError
(
"
Cannot
delete
-
the
latest
query
is
not
present
"
)
;
return
false
;
}
const
selectedResult
=
this
.
input
.
view
.
selectedResult
;
if
(
!
selectedResult
|
|
selectedResult
.
source
!
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
{
return
false
;
}
let
{
queryContext
}
=
this
.
_lastQueryContextWrapper
;
let
index
=
queryContext
.
results
.
indexOf
(
selectedResult
)
;
if
(
!
index
)
{
Cu
.
reportError
(
"
Failed
to
find
the
selected
result
in
the
results
"
)
;
return
false
;
}
queryContext
.
results
.
splice
(
index
1
)
;
this
.
notify
(
NOTIFICATIONS
.
QUERY_RESULT_REMOVED
index
)
;
PlacesUtils
.
history
.
remove
(
selectedResult
.
payload
.
url
)
.
catch
(
Cu
.
reportError
)
;
return
true
;
}
notify
(
name
.
.
.
params
)
{
for
(
let
listener
of
this
.
_listeners
)
{
if
(
typeof
listener
[
name
]
!
=
"
undefined
"
)
{
try
{
listener
[
name
]
(
.
.
.
params
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
}
}
class
TelemetryEvent
{
constructor
(
category
)
{
this
.
_category
=
category
;
}
start
(
event
searchString
=
null
)
{
if
(
!
this
.
_category
|
|
this
.
_startEventInfo
)
{
return
;
}
if
(
!
event
)
{
Cu
.
reportError
(
"
Must
always
provide
an
event
"
)
;
return
;
}
const
validEvents
=
[
"
command
"
"
drop
"
"
input
"
"
keydown
"
"
mousedown
"
]
;
if
(
!
validEvents
.
includes
(
event
.
type
)
)
{
Cu
.
reportError
(
"
Can
'
t
start
recording
from
event
type
:
"
+
event
.
type
)
;
return
;
}
let
interactionType
=
"
topsites
"
;
if
(
event
.
type
=
=
"
input
"
)
{
interactionType
=
UrlbarUtils
.
isPasteEvent
(
event
)
?
"
pasted
"
:
"
typed
"
;
}
else
if
(
event
.
type
=
=
"
drop
"
)
{
interactionType
=
"
dropped
"
;
}
else
if
(
searchString
)
{
interactionType
=
"
typed
"
;
}
this
.
_startEventInfo
=
{
timeStamp
:
event
.
timeStamp
|
|
Cu
.
now
(
)
interactionType
}
;
}
record
(
event
details
)
{
try
{
this
.
_internalRecord
(
event
details
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Could
not
record
event
:
"
+
ex
)
;
}
finally
{
this
.
_startEventInfo
=
null
;
}
}
_internalRecord
(
event
details
)
{
if
(
!
this
.
_category
|
|
!
this
.
_startEventInfo
)
{
return
;
}
if
(
!
event
&
&
this
.
_startEventInfo
.
interactionType
!
=
"
pasted
"
&
&
this
.
_startEventInfo
.
interactionType
!
=
"
dropped
"
)
{
throw
new
Error
(
"
Event
must
be
defined
unless
input
was
pasted
/
dropped
"
)
;
}
if
(
!
details
)
{
throw
new
Error
(
"
Invalid
event
details
:
"
+
details
)
;
}
let
endTime
=
(
event
&
&
event
.
timeStamp
)
|
|
Cu
.
now
(
)
;
let
startTime
=
this
.
_startEventInfo
.
timeStamp
|
|
endTime
;
let
elapsed
=
Math
.
abs
(
Math
.
round
(
endTime
-
startTime
)
)
;
let
action
;
if
(
!
event
)
{
action
=
this
.
_startEventInfo
.
interactionType
=
=
"
dropped
"
?
"
drop_go
"
:
"
paste_go
"
;
}
else
if
(
event
.
type
=
=
"
blur
"
)
{
action
=
"
blur
"
;
}
else
{
action
=
event
instanceof
MouseEvent
?
"
click
"
:
"
enter
"
;
}
let
method
=
action
=
=
"
blur
"
?
"
abandonment
"
:
"
engagement
"
;
let
value
=
this
.
_startEventInfo
.
interactionType
;
let
recordingEnabled
=
UrlbarPrefs
.
get
(
"
eventTelemetry
.
enabled
"
)
;
if
(
this
.
_eventRecordingEnabled
!
=
recordingEnabled
)
{
this
.
_eventRecordingEnabled
=
recordingEnabled
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
urlbar
"
recordingEnabled
)
;
}
let
extra
=
{
elapsed
:
elapsed
.
toString
(
)
numChars
:
details
.
numChars
.
toString
(
)
}
;
if
(
method
=
=
"
engagement
"
)
{
extra
.
selIndex
=
details
.
selIndex
.
toString
(
)
;
extra
.
selType
=
details
.
selType
;
}
Services
.
telemetry
.
recordEvent
(
this
.
_category
method
action
value
extra
)
;
}
discard
(
)
{
this
.
_startEventInfo
=
null
;
}
typeFromElement
(
element
)
{
if
(
!
element
)
{
return
"
none
"
;
}
let
row
=
element
.
closest
(
"
.
urlbarView
-
row
"
)
;
if
(
row
.
result
)
{
switch
(
row
.
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
return
"
switchtab
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
return
row
.
result
.
payload
.
suggestion
?
"
searchsuggestion
"
:
"
search
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
if
(
row
.
result
.
autofill
)
{
return
"
autofill
"
;
}
if
(
row
.
result
.
heuristic
)
{
return
"
visit
"
;
}
return
row
.
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
?
"
bookmark
"
:
"
history
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
return
"
keyword
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
"
extension
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
return
"
remotetab
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
if
(
element
.
classList
.
contains
(
"
urlbarView
-
tip
-
help
"
)
)
{
return
"
tiphelp
"
;
}
return
"
tip
"
;
}
}
return
"
none
"
;
}
}
