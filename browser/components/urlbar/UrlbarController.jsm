"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarController
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
BrowserUsageTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
URLBAR_SELECTED_RESULT_TYPES
:
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
}
)
;
const
TELEMETRY_1ST_RESULT
=
"
PLACES_AUTOCOMPLETE_1ST_RESULT_TIME_MS
"
;
const
TELEMETRY_6_FIRST_RESULTS
=
"
PLACES_AUTOCOMPLETE_6_FIRST_RESULTS_TIME_MS
"
;
class
UrlbarController
{
constructor
(
options
=
{
}
)
{
if
(
!
options
.
browserWindow
)
{
throw
new
Error
(
"
Missing
options
:
browserWindow
"
)
;
}
if
(
!
options
.
browserWindow
.
location
|
|
options
.
browserWindow
.
location
.
href
!
=
AppConstants
.
BROWSER_CHROME_URL
)
{
throw
new
Error
(
"
browserWindow
should
be
an
actual
browser
window
.
"
)
;
}
this
.
manager
=
options
.
manager
|
|
UrlbarProvidersManager
;
this
.
browserWindow
=
options
.
browserWindow
;
this
.
_listeners
=
new
Set
(
)
;
this
.
_userSelectionBehavior
=
"
none
"
;
}
setInput
(
input
)
{
this
.
input
=
input
;
}
setView
(
view
)
{
this
.
view
=
view
;
}
async
startQuery
(
queryContext
)
{
this
.
cancelQuery
(
)
;
let
contextWrapper
=
this
.
_lastQueryContextWrapper
=
{
queryContext
}
;
queryContext
.
lastResultCount
=
0
;
TelemetryStopwatch
.
start
(
TELEMETRY_1ST_RESULT
queryContext
)
;
TelemetryStopwatch
.
start
(
TELEMETRY_6_FIRST_RESULTS
queryContext
)
;
this
.
_notify
(
"
onQueryStarted
"
queryContext
)
;
await
this
.
manager
.
startQuery
(
queryContext
this
)
;
if
(
contextWrapper
=
=
=
this
.
_lastQueryContextWrapper
&
&
!
contextWrapper
.
done
)
{
contextWrapper
.
done
=
true
;
this
.
manager
.
cancelQuery
(
queryContext
)
;
this
.
_notify
(
"
onQueryFinished
"
queryContext
)
;
}
return
queryContext
;
}
cancelQuery
(
)
{
if
(
!
this
.
_lastQueryContextWrapper
|
|
this
.
_lastQueryContextWrapper
.
done
)
{
return
;
}
this
.
_lastQueryContextWrapper
.
done
=
true
;
let
{
queryContext
}
=
this
.
_lastQueryContextWrapper
;
TelemetryStopwatch
.
cancel
(
TELEMETRY_1ST_RESULT
queryContext
)
;
TelemetryStopwatch
.
cancel
(
TELEMETRY_6_FIRST_RESULTS
queryContext
)
;
this
.
manager
.
cancelQuery
(
queryContext
)
;
this
.
_notify
(
"
onQueryCancelled
"
queryContext
)
;
this
.
_notify
(
"
onQueryFinished
"
queryContext
)
;
}
receiveResults
(
queryContext
)
{
if
(
queryContext
.
lastResultCount
<
1
&
&
queryContext
.
results
.
length
>
=
1
)
{
TelemetryStopwatch
.
finish
(
TELEMETRY_1ST_RESULT
queryContext
)
;
}
if
(
queryContext
.
lastResultCount
<
6
&
&
queryContext
.
results
.
length
>
=
6
)
{
TelemetryStopwatch
.
finish
(
TELEMETRY_6_FIRST_RESULTS
queryContext
)
;
}
if
(
queryContext
.
lastResultCount
=
=
0
&
&
queryContext
.
results
.
length
)
{
if
(
queryContext
.
results
[
0
]
.
autofill
)
{
this
.
input
.
autofillFirstResult
(
queryContext
.
results
[
0
]
)
;
}
this
.
speculativeConnect
(
queryContext
0
"
resultsadded
"
)
;
}
this
.
_notify
(
"
onQueryResults
"
queryContext
)
;
queryContext
.
lastResultCount
=
queryContext
.
results
.
length
;
}
addQueryListener
(
listener
)
{
if
(
!
listener
|
|
typeof
listener
!
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
listener
to
be
an
object
"
)
;
}
this
.
_listeners
.
add
(
listener
)
;
}
removeQueryListener
(
listener
)
{
this
.
_listeners
.
delete
(
listener
)
;
}
viewContextChanged
(
)
{
this
.
cancelQuery
(
)
;
this
.
_notify
(
"
onViewContextChanged
"
)
;
}
keyEventMovesCaret
(
event
)
{
if
(
this
.
view
.
isOpen
)
{
return
false
;
}
if
(
AppConstants
.
platform
!
=
"
macosx
"
&
&
AppConstants
.
platform
!
=
"
linux
"
)
{
return
false
;
}
let
isArrowUp
=
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_UP
;
let
isArrowDown
=
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_DOWN
;
if
(
!
isArrowUp
&
&
!
isArrowDown
)
{
return
false
;
}
let
start
=
this
.
input
.
selectionStart
;
let
end
=
this
.
input
.
selectionEnd
;
if
(
end
!
=
start
|
|
(
isArrowUp
&
&
start
>
0
)
|
|
(
isArrowDown
&
&
end
<
this
.
input
.
textValue
.
length
)
)
{
return
true
;
}
return
false
;
}
handleKeyNavigation
(
event
executeAction
=
true
)
{
const
isMac
=
AppConstants
.
platform
=
=
"
macosx
"
;
if
(
isMac
&
&
this
.
view
.
isOpen
&
&
event
.
ctrlKey
&
&
(
event
.
key
=
=
"
n
"
|
|
event
.
key
=
=
"
p
"
)
)
{
if
(
executeAction
)
{
this
.
view
.
selectBy
(
1
{
reverse
:
event
.
key
=
=
"
p
"
}
)
;
}
event
.
preventDefault
(
)
;
return
;
}
if
(
this
.
view
.
isOpen
&
&
executeAction
&
&
this
.
_lastQueryContextWrapper
)
{
let
{
queryContext
}
=
this
.
_lastQueryContextWrapper
;
let
handled
=
this
.
view
.
oneOffSearchButtons
.
handleKeyPress
(
event
queryContext
.
results
.
length
this
.
view
.
allowEmptySelection
queryContext
.
searchString
)
;
if
(
handled
)
{
return
;
}
}
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_ESCAPE
:
if
(
executeAction
)
{
this
.
input
.
handleRevert
(
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyEvent
.
DOM_VK_RETURN
:
if
(
isMac
&
&
event
.
metaKey
)
{
event
.
preventDefault
(
)
;
}
if
(
executeAction
)
{
this
.
input
.
handleCommand
(
event
)
;
}
break
;
case
KeyEvent
.
DOM_VK_TAB
:
if
(
this
.
view
.
isOpen
)
{
if
(
executeAction
)
{
this
.
view
.
selectBy
(
1
{
reverse
:
event
.
shiftKey
}
)
;
this
.
userSelectionBehavior
=
"
tab
"
;
}
event
.
preventDefault
(
)
;
}
break
;
case
KeyEvent
.
DOM_VK_DOWN
:
case
KeyEvent
.
DOM_VK_UP
:
case
KeyEvent
.
DOM_VK_PAGE_DOWN
:
case
KeyEvent
.
DOM_VK_PAGE_UP
:
if
(
event
.
ctrlKey
|
|
event
.
altKey
)
{
break
;
}
if
(
this
.
view
.
isOpen
)
{
if
(
executeAction
)
{
this
.
userSelectionBehavior
=
"
arrow
"
;
this
.
view
.
selectBy
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_PAGE_DOWN
|
|
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_PAGE_UP
?
UrlbarUtils
.
PAGE_UP_DOWN_DELTA
:
1
{
reverse
:
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_UP
|
|
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_PAGE_UP
}
)
;
}
}
else
{
if
(
this
.
keyEventMovesCaret
(
event
)
)
{
break
;
}
if
(
executeAction
)
{
this
.
userSelectionBehavior
=
"
arrow
"
;
this
.
input
.
startQuery
(
{
searchString
:
this
.
input
.
textValue
}
)
;
}
}
event
.
preventDefault
(
)
;
break
;
case
KeyEvent
.
DOM_VK_LEFT
:
case
KeyEvent
.
DOM_VK_RIGHT
:
case
KeyEvent
.
DOM_VK_HOME
:
case
KeyEvent
.
DOM_VK_END
:
this
.
view
.
removeAccessibleFocus
(
)
;
break
;
case
KeyEvent
.
DOM_VK_DELETE
:
case
KeyEvent
.
DOM_VK_BACK_SPACE
:
if
(
!
this
.
view
.
isOpen
)
{
break
;
}
if
(
event
.
shiftKey
)
{
if
(
!
executeAction
|
|
this
.
_handleDeleteEntry
(
)
)
{
event
.
preventDefault
(
)
;
}
}
else
if
(
executeAction
)
{
this
.
view
.
removeAccessibleFocus
(
)
;
}
break
;
}
}
speculativeConnect
(
context
resultIndex
reason
)
{
if
(
!
this
.
input
|
|
context
.
isPrivate
|
|
context
.
results
.
length
=
=
0
)
{
return
;
}
let
result
=
context
.
results
[
resultIndex
]
;
let
{
url
}
=
UrlbarUtils
.
getUrlFromResult
(
result
)
;
if
(
!
url
)
{
return
;
}
switch
(
reason
)
{
case
"
resultsadded
"
:
{
if
(
(
resultIndex
=
=
0
&
&
context
.
preselected
)
|
|
result
.
autofill
)
{
if
(
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
)
{
if
(
UrlbarPrefs
.
get
(
"
suggest
.
searches
"
)
&
&
UrlbarPrefs
.
get
(
"
browser
.
search
.
suggest
.
enabled
"
)
)
{
let
engine
=
Services
.
search
.
defaultEngine
;
UrlbarUtils
.
setupSpeculativeConnection
(
engine
this
.
browserWindow
)
;
}
}
else
if
(
result
.
autofill
)
{
UrlbarUtils
.
setupSpeculativeConnection
(
url
this
.
browserWindow
)
;
}
}
return
;
}
case
"
mousedown
"
:
{
if
(
url
.
startsWith
(
"
http
"
)
)
{
UrlbarUtils
.
setupSpeculativeConnection
(
url
this
.
browserWindow
)
;
}
return
;
}
default
:
{
throw
new
Error
(
"
Invalid
speculative
connection
reason
"
)
;
}
}
}
set
userSelectionBehavior
(
behavior
)
{
if
(
behavior
=
=
"
arrow
"
&
&
this
.
_userSelectionBehavior
=
=
"
tab
"
)
{
return
;
}
this
.
_userSelectionBehavior
=
behavior
;
}
recordSelectedResult
(
event
resultIndex
)
{
let
result
;
let
selectedResult
=
-
1
;
if
(
resultIndex
>
=
0
)
{
result
=
this
.
view
.
getResult
(
resultIndex
)
;
selectedResult
=
resultIndex
>
0
|
|
!
result
.
heuristic
?
resultIndex
:
-
1
;
}
BrowserUsageTelemetry
.
recordUrlbarSelectedResultMethod
(
event
selectedResult
this
.
_userSelectionBehavior
)
;
if
(
!
result
)
{
return
;
}
let
telemetryType
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
telemetryType
=
"
switchtab
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
telemetryType
=
result
.
payload
.
suggestion
?
"
searchsuggestion
"
:
"
searchengine
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
if
(
result
.
autofill
)
{
telemetryType
=
"
autofill
"
;
}
else
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
&
&
result
.
heuristic
)
{
telemetryType
=
"
visiturl
"
;
}
else
{
telemetryType
=
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
?
"
bookmark
"
:
"
history
"
;
}
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
telemetryType
=
"
keyword
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
telemetryType
=
"
extension
"
;
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
telemetryType
=
"
remotetab
"
;
break
;
default
:
Cu
.
reportError
(
Unknown
Result
Type
{
result
.
type
}
)
;
return
;
}
Services
.
telemetry
.
getHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_INDEX
"
)
.
add
(
resultIndex
)
;
if
(
telemetryType
in
URLBAR_SELECTED_RESULT_TYPES
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_TYPE
"
)
.
add
(
URLBAR_SELECTED_RESULT_TYPES
[
telemetryType
]
)
;
Services
.
telemetry
.
getKeyedHistogramById
(
"
FX_URLBAR_SELECTED_RESULT_INDEX_BY_TYPE
"
)
.
add
(
telemetryType
resultIndex
)
;
}
else
{
Cu
.
reportError
(
"
Unknown
FX_URLBAR_SELECTED_RESULT_TYPE
type
:
"
+
telemetryType
)
;
}
}
_handleDeleteEntry
(
)
{
if
(
!
this
.
_lastQueryContextWrapper
)
{
Cu
.
reportError
(
"
Cannot
delete
-
the
latest
query
is
not
present
"
)
;
return
false
;
}
const
selectedResult
=
this
.
input
.
view
.
selectedResult
;
if
(
!
selectedResult
|
|
selectedResult
.
source
!
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
{
return
false
;
}
let
{
queryContext
}
=
this
.
_lastQueryContextWrapper
;
let
index
=
queryContext
.
results
.
indexOf
(
selectedResult
)
;
if
(
!
index
)
{
Cu
.
reportError
(
"
Failed
to
find
the
selected
result
in
the
results
"
)
;
return
false
;
}
queryContext
.
results
.
splice
(
index
1
)
;
this
.
_notify
(
"
onQueryResultRemoved
"
index
)
;
PlacesUtils
.
history
.
remove
(
selectedResult
.
payload
.
url
)
.
catch
(
Cu
.
reportError
)
;
return
true
;
}
_notify
(
name
.
.
.
params
)
{
for
(
let
listener
of
this
.
_listeners
)
{
if
(
typeof
listener
[
name
]
!
=
"
undefined
"
)
{
try
{
listener
[
name
]
(
.
.
.
params
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
}
}
