"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
QueryContext
"
"
UrlbarController
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
ProvidersManager
=
{
queryStart
(
queryContext
controller
)
{
queryContext
.
results
=
[
]
;
for
(
let
i
=
0
;
i
<
queryContext
.
maxResults
;
i
+
+
)
{
const
SWITCH_TO_TAB
=
Math
.
random
(
)
<
.
3
;
let
url
=
"
http
:
/
/
www
.
"
+
queryContext
.
searchString
;
while
(
Math
.
random
(
)
<
.
9
)
{
url
+
=
queryContext
.
searchString
;
}
let
title
=
queryContext
.
searchString
;
while
(
Math
.
random
(
)
<
.
5
)
{
title
+
=
queryContext
.
isPrivate
?
"
private
"
:
"
foo
bar
"
;
}
queryContext
.
results
.
push
(
{
title
type
:
SWITCH_TO_TAB
?
"
switchtotab
"
:
"
normal
"
url
}
)
;
}
controller
.
receiveResults
(
queryContext
)
;
}
}
;
class
QueryContext
{
constructor
(
options
=
{
}
)
{
this
.
_checkRequiredOptions
(
options
[
"
searchString
"
"
lastKey
"
"
maxResults
"
"
isPrivate
"
]
)
;
this
.
autoFill
=
!
!
options
.
autoFill
;
}
_checkRequiredOptions
(
options
optionNames
)
{
for
(
let
optionName
of
optionNames
)
{
if
(
!
(
optionName
in
options
)
)
{
throw
new
Error
(
Missing
or
empty
{
optionName
}
provided
to
QueryContext
)
;
}
this
[
optionName
]
=
options
[
optionName
]
;
}
}
}
class
UrlbarController
{
constructor
(
options
=
{
}
)
{
this
.
manager
=
options
.
manager
|
|
ProvidersManager
;
this
.
_listeners
=
new
Set
(
)
;
}
handleQuery
(
queryContext
)
{
queryContext
.
autoFill
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
autoFill
"
true
)
;
this
.
_notify
(
"
onQueryStarted
"
queryContext
)
;
this
.
manager
.
queryStart
(
queryContext
this
)
;
}
cancelQuery
(
queryContext
)
{
this
.
manager
.
queryCancel
(
queryContext
)
;
this
.
_notify
(
"
onQueryCancelled
"
queryContext
)
;
}
receiveResults
(
queryContext
)
{
this
.
_notify
(
"
onQueryResults
"
queryContext
)
;
}
addQueryListener
(
listener
)
{
if
(
!
listener
|
|
typeof
listener
!
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
listener
to
be
an
object
"
)
;
}
this
.
_listeners
.
add
(
listener
)
;
}
removeQueryListener
(
listener
)
{
this
.
_listeners
.
delete
(
listener
)
;
}
_notify
(
name
.
.
.
params
)
{
for
(
let
listener
of
this
.
_listeners
)
{
try
{
listener
[
name
]
(
.
.
.
params
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
}
