"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
QueryContext
"
"
UrlbarController
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
class
QueryContext
{
constructor
(
options
=
{
}
)
{
this
.
_checkRequiredOptions
(
options
[
"
searchString
"
"
lastKey
"
"
maxResults
"
"
isPrivate
"
]
)
;
this
.
autoFill
=
!
!
options
.
autoFill
;
}
_checkRequiredOptions
(
options
optionNames
)
{
for
(
let
optionName
of
optionNames
)
{
if
(
!
(
optionName
in
options
)
)
{
throw
new
Error
(
Missing
or
empty
{
optionName
}
provided
to
QueryContext
)
;
}
this
[
optionName
]
=
options
[
optionName
]
;
}
}
}
class
UrlbarController
{
constructor
(
options
=
{
}
)
{
if
(
!
options
.
window
)
{
throw
new
Error
(
"
Missing
options
:
window
"
)
;
}
this
.
manager
=
options
.
manager
|
|
UrlbarProvidersManager
;
this
.
window
=
options
.
window
;
this
.
_listeners
=
new
Set
(
)
;
}
async
startQuery
(
queryContext
)
{
queryContext
.
autoFill
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
autoFill
"
true
)
;
this
.
_notify
(
"
onQueryStarted
"
queryContext
)
;
await
this
.
manager
.
startQuery
(
queryContext
this
)
;
}
cancelQuery
(
queryContext
)
{
this
.
manager
.
cancelQuery
(
queryContext
)
;
this
.
_notify
(
"
onQueryCancelled
"
queryContext
)
;
}
receiveResults
(
queryContext
)
{
this
.
_notify
(
"
onQueryResults
"
queryContext
)
;
}
handleEnteredText
(
event
text
openWhere
openParams
=
{
}
)
{
let
browser
=
this
.
window
.
gBrowser
.
selectedBrowser
;
let
where
=
openWhere
|
|
this
.
_whereToOpen
(
event
)
;
openParams
.
postData
=
null
;
openParams
.
allowInheritPrincipal
=
false
;
text
=
text
.
trim
(
)
;
try
{
new
URL
(
text
)
;
}
catch
(
ex
)
{
return
;
}
this
.
_loadURL
(
text
browser
where
openParams
)
;
}
resultSelected
(
event
result
openWhere
openParams
=
{
}
)
{
let
where
=
openWhere
|
|
this
.
_whereToOpen
(
event
)
;
openParams
.
postData
=
null
;
openParams
.
allowInheritPrincipal
=
false
;
let
browser
=
this
.
window
.
gBrowser
.
selectedBrowser
;
let
url
=
result
.
url
;
switch
(
result
.
type
)
{
case
UrlbarUtils
.
MATCH_TYPE
.
TAB_SWITCH
:
{
let
prevTab
=
this
.
window
.
gBrowser
.
selectedTab
;
let
loadOpts
=
{
adoptIntoActiveWindow
:
UrlbarPrefs
.
get
(
"
switchTabs
.
adoptIntoActiveWindow
"
)
}
;
if
(
this
.
window
.
switchToTabHavingURI
(
url
false
loadOpts
)
&
&
this
.
window
.
isTabEmpty
(
prevTab
)
)
{
this
.
window
.
gBrowser
.
removeTab
(
prevTab
)
;
}
return
;
}
}
this
.
_loadURL
(
url
browser
where
openParams
)
;
}
addQueryListener
(
listener
)
{
if
(
!
listener
|
|
typeof
listener
!
=
"
object
"
)
{
throw
new
TypeError
(
"
Expected
listener
to
be
an
object
"
)
;
}
this
.
_listeners
.
add
(
listener
)
;
}
removeQueryListener
(
listener
)
{
this
.
_listeners
.
delete
(
listener
)
;
}
tabContextChanged
(
)
{
}
_notify
(
name
.
.
.
params
)
{
for
(
let
listener
of
this
.
_listeners
)
{
try
{
listener
[
name
]
(
.
.
.
params
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
_loadURL
(
url
browser
openUILinkWhere
params
)
{
if
(
this
.
window
.
gInitialPages
.
includes
(
url
)
)
{
browser
.
initialPageLoadedFromURLBar
=
url
;
}
try
{
UrlbarUtils
.
addToUrlbarHistory
(
url
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
params
.
allowThirdPartyFixup
=
true
;
if
(
openUILinkWhere
=
=
"
current
"
)
{
params
.
targetBrowser
=
browser
;
params
.
indicateErrorPageLoad
=
true
;
params
.
allowPinnedTabHostChange
=
true
;
params
.
allowPopups
=
url
.
startsWith
(
"
javascript
:
"
)
;
}
else
{
params
.
initiatingDoc
=
this
.
window
.
document
;
}
browser
.
focus
(
)
;
if
(
openUILinkWhere
!
=
"
current
"
)
{
}
try
{
this
.
window
.
openTrustedLinkIn
(
url
openUILinkWhere
params
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_LOAD_SHOWED_ERRORPAGE
)
{
}
}
}
_whereToOpen
(
event
)
{
let
isMouseEvent
=
event
instanceof
this
.
window
.
MouseEvent
;
let
reuseEmpty
=
!
isMouseEvent
;
let
where
=
undefined
;
if
(
!
isMouseEvent
&
&
event
&
&
event
.
altKey
)
{
where
=
event
.
shiftKey
?
"
tabshifted
"
:
"
tab
"
;
}
else
if
(
!
isMouseEvent
&
&
this
.
_ctrlCanonizesURLs
&
&
event
&
&
event
.
ctrlKey
)
{
where
=
"
current
"
;
}
else
{
where
=
this
.
window
.
whereToOpenLink
(
event
false
false
)
;
}
if
(
this
.
openInTab
)
{
if
(
where
=
=
"
current
"
)
{
where
=
"
tab
"
;
}
else
if
(
where
=
=
"
tab
"
)
{
where
=
"
current
"
;
}
reuseEmpty
=
true
;
}
if
(
where
=
=
"
tab
"
&
&
reuseEmpty
&
&
this
.
window
.
isTabEmpty
(
this
.
window
.
gBrowser
.
selectedTab
)
)
{
where
=
"
current
"
;
}
return
where
;
}
}
