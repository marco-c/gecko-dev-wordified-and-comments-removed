"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderQuickActions
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
UrlbarProvider
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
QuickActionsLoaderDefault
:
"
resource
:
/
/
/
modules
/
QuickActionsLoaderDefault
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
ENABLED_PREF
=
"
quickactions
.
enabled
"
;
const
DYNAMIC_TYPE_NAME
=
"
quickactions
"
;
const
ACTIONS_SHOWN_FOCUS
=
5
;
const
DEFAULT_ICON
=
"
chrome
:
/
/
global
/
skin
/
icons
/
settings
.
svg
"
;
const
SUGGESTED_INDEX
=
1
;
class
ProviderQuickActions
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
UrlbarResult
.
addDynamicResultType
(
DYNAMIC_TYPE_NAME
)
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
QuickActionsLoaderDefault
.
load
(
)
)
;
}
get
name
(
)
{
return
DYNAMIC_TYPE_NAME
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
;
}
getPriority
(
context
)
{
if
(
!
context
.
searchString
)
{
return
1
;
}
return
0
;
}
isActive
(
queryContext
)
{
return
(
UrlbarPrefs
.
get
(
ENABLED_PREF
)
&
&
(
!
queryContext
.
restrictSource
|
|
queryContext
.
restrictSource
=
=
UrlbarTokenizer
.
RESTRICT
.
ACTIONS
)
&
&
!
queryContext
.
searchMode
)
;
}
async
startQuery
(
queryContext
addCallback
)
{
let
results
=
this
.
#
keywords
.
get
(
queryContext
.
trimmedSearchString
.
toLowerCase
(
)
)
;
results
=
results
?
.
filter
(
key
=
>
{
let
action
=
this
.
#
actions
.
get
(
key
)
;
return
!
(
"
isActive
"
in
action
)
|
|
!
action
.
isActive
(
)
;
}
)
;
if
(
!
results
?
.
length
)
{
return
;
}
if
(
results
.
length
>
ACTIONS_SHOWN_FOCUS
&
&
!
queryContext
.
searchString
&
&
!
queryContext
.
searchMode
)
{
results
.
length
=
ACTIONS_SHOWN_FOCUS
;
}
const
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
UrlbarUtils
.
RESULT_SOURCE
.
ACTIONS
{
results
:
results
.
map
(
key
=
>
(
{
key
}
)
)
dynamicType
:
DYNAMIC_TYPE_NAME
}
)
;
result
.
suggestedIndex
=
SUGGESTED_INDEX
;
addCallback
(
this
result
)
;
}
getViewTemplate
(
result
)
{
return
{
children
:
result
.
payload
.
results
.
map
(
(
el
i
)
=
>
(
{
name
:
button
-
{
i
}
tag
:
"
span
"
attributes
:
{
class
:
"
urlbarView
-
quickaction
-
row
"
role
:
"
button
"
}
children
:
[
{
name
:
icon
-
{
i
}
tag
:
"
div
"
attributes
:
{
class
:
"
urlbarView
-
favicon
"
}
children
:
[
{
name
:
image
-
{
i
}
tag
:
"
img
"
attributes
:
{
class
:
"
urlbarView
-
favicon
-
img
"
}
}
]
}
{
name
:
div
-
{
i
}
tag
:
"
div
"
children
:
[
{
name
:
label
-
{
i
}
tag
:
"
span
"
attributes
:
{
class
:
"
urlbarView
-
label
"
}
}
]
}
]
}
)
)
}
;
}
getViewUpdate
(
result
)
{
let
viewUpdate
=
{
}
;
result
.
payload
.
results
.
forEach
(
(
{
key
}
i
)
=
>
{
let
data
=
this
.
#
actions
.
get
(
key
)
|
|
{
icon
:
"
"
label
:
"
"
}
;
let
buttonAttributes
=
{
"
data
-
key
"
:
key
}
;
viewUpdate
[
button
-
{
i
}
]
=
{
attributes
:
buttonAttributes
}
;
viewUpdate
[
image
-
{
i
}
]
=
{
attributes
:
{
src
:
data
.
icon
|
|
DEFAULT_ICON
}
}
;
viewUpdate
[
label
-
{
i
}
]
=
{
attributes
:
{
"
data
-
l10n
-
id
"
:
data
.
label
}
}
;
}
)
;
return
viewUpdate
;
}
pickResult
(
result
itemPicked
)
{
this
.
#
actions
.
get
(
itemPicked
.
dataset
.
key
)
.
onPick
(
)
;
}
addAction
(
key
definition
)
{
this
.
#
actions
.
set
(
key
definition
)
;
this
.
#
loopOverPrefixes
(
definition
.
commands
prefix
=
>
{
let
result
=
this
.
#
keywords
.
get
(
prefix
)
;
if
(
result
)
{
if
(
!
result
.
includes
(
key
)
)
{
result
.
push
(
key
)
;
}
}
else
{
result
=
[
key
]
;
}
this
.
#
keywords
.
set
(
prefix
result
)
;
}
)
;
}
removeAction
(
key
)
{
let
definition
=
this
.
#
actions
.
get
(
key
)
;
this
.
#
actions
.
delete
(
key
)
;
this
.
#
loopOverPrefixes
(
definition
.
commands
prefix
=
>
{
let
result
=
this
.
#
keywords
.
get
(
prefix
)
;
if
(
result
)
{
result
=
result
.
filter
(
val
=
>
val
=
=
key
)
;
}
this
.
#
keywords
.
set
(
prefix
result
)
;
}
)
;
}
#
keywords
=
new
Map
(
)
;
#
actions
=
new
Map
(
)
;
#
loopOverPrefixes
(
commands
fun
)
{
for
(
const
command
of
commands
)
{
for
(
let
i
=
0
;
i
<
=
command
.
length
;
i
+
+
)
{
let
prefix
=
command
.
substring
(
0
command
.
length
-
i
)
;
fun
(
prefix
)
;
}
}
}
}
var
UrlbarProviderQuickActions
=
new
ProviderQuickActions
(
)
;
