"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ONBOARDING_CHOICE
"
"
UrlbarQuickSuggest
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
EventEmitter
:
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
QUICK_SUGGEST_SOURCE
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
TaskQueue
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
TextDecoder
"
]
)
;
const
log
=
console
.
createInstance
(
{
prefix
:
"
QuickSuggest
"
maxLogLevel
:
UrlbarPrefs
.
get
(
"
quicksuggest
.
log
"
)
?
"
All
"
:
"
Warn
"
}
)
;
const
RS_COLLECTION
=
"
quicksuggest
"
;
const
NONSPONSORED_IAB_CATEGORIES
=
new
Set
(
[
"
5
-
Education
"
]
)
;
const
FEATURE_AVAILABLE
=
"
quickSuggestEnabled
"
;
const
SEEN_DIALOG_PREF
=
"
quicksuggest
.
showedOnboardingDialog
"
;
const
RESTARTS_PREF
=
"
quicksuggest
.
seenRestarts
"
;
const
DIALOG_VERSION_PREF
=
"
quicksuggest
.
onboardingDialogVersion
"
;
const
DIALOG_VARIATION_PREF
=
"
quickSuggestOnboardingDialogVariation
"
;
const
ONBOARDING_CHOICE
=
{
ACCEPT_2
:
"
accept_2
"
CLOSE_1
:
"
close_1
"
DISMISS_1
:
"
dismiss_1
"
DISMISS_2
:
"
dismiss_2
"
LEARN_MORE_1
:
"
learn_more_1
"
LEARN_MORE_2
:
"
learn_more_2
"
NOT_NOW_2
:
"
not_now_2
"
REJECT_2
:
"
reject_2
"
}
;
const
ONBOARDING_URI
=
"
chrome
:
/
/
browser
/
content
/
urlbar
/
quicksuggestOnboarding
.
html
"
;
const
DEFAULT_SUGGESTION_SCORE
=
0
.
2
;
const
ADD_RESULTS_CHUNK_SIZE
=
1000
;
class
QuickSuggest
extends
EventEmitter
{
init
(
)
{
UrlbarPrefs
.
addObserver
(
this
)
;
NimbusFeatures
.
urlbar
.
onUpdate
(
(
)
=
>
this
.
_queueSettingsSetup
(
)
)
;
this
.
_settingsTaskQueue
.
queue
(
(
)
=
>
{
return
new
Promise
(
resolve
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
this
.
_queueSettingsSetup
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
}
get
DEFAULT_SUGGESTION_SCORE
(
)
{
return
DEFAULT_SUGGESTION_SCORE
;
}
get
readyPromise
(
)
{
return
this
.
_settingsTaskQueue
.
emptyPromise
;
}
get
config
(
)
{
return
this
.
_config
;
}
async
query
(
phrase
)
{
log
.
info
(
"
Handling
query
for
"
phrase
)
;
phrase
=
phrase
.
toLowerCase
(
)
;
let
object
=
this
.
_resultsByKeyword
.
get
(
phrase
)
;
if
(
!
object
)
{
return
[
]
;
}
let
results
=
[
object
]
.
flat
(
)
;
let
icons
=
await
Promise
.
all
(
results
.
map
(
(
{
icon
}
)
=
>
this
.
_fetchIcon
(
icon
)
)
)
;
return
results
.
map
(
result
=
>
(
{
full_keyword
:
this
.
getFullKeyword
(
phrase
result
.
keywords
)
title
:
result
.
title
url
:
result
.
url
click_url
:
result
.
click_url
impression_url
:
result
.
impression_url
block_id
:
result
.
id
advertiser
:
result
.
advertiser
iab_category
:
result
.
iab_category
is_sponsored
:
!
NONSPONSORED_IAB_CATEGORIES
.
has
(
result
.
iab_category
)
score
:
typeof
result
.
score
=
=
"
number
"
?
result
.
score
:
DEFAULT_SUGGESTION_SCORE
source
:
QUICK_SUGGEST_SOURCE
.
REMOTE_SETTINGS
icon
:
icons
.
shift
(
)
position
:
result
.
position
_test_is_best_match
:
result
.
_test_is_best_match
}
)
)
;
}
ensureExposureEventRecorded
(
)
{
if
(
!
this
.
_recordedExposureEvent
)
{
this
.
_recordedExposureEvent
=
true
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
NimbusFeatures
.
urlbar
.
recordExposureEvent
(
{
once
:
true
}
)
)
;
}
}
getFullKeyword
(
query
keywords
)
{
let
longerPhrase
;
let
trimmedQuery
=
query
.
trim
(
)
;
let
queryWords
=
trimmedQuery
.
split
(
"
"
)
;
for
(
let
phrase
of
keywords
)
{
if
(
phrase
.
startsWith
(
query
)
)
{
let
trimmedPhrase
=
phrase
.
trim
(
)
;
let
phraseWords
=
trimmedPhrase
.
split
(
"
"
)
;
let
extra
=
query
.
endsWith
(
"
"
)
?
1
:
0
;
let
len
=
queryWords
.
length
+
extra
;
if
(
len
<
phraseWords
.
length
)
{
return
phraseWords
.
slice
(
0
len
)
.
join
(
"
"
)
;
}
if
(
query
.
length
<
phrase
.
length
&
&
(
!
longerPhrase
|
|
longerPhrase
.
length
<
trimmedPhrase
.
length
)
)
{
longerPhrase
=
trimmedPhrase
;
}
}
}
return
longerPhrase
|
|
trimmedQuery
;
}
async
maybeShowOnboardingDialog
(
)
{
await
UrlbarPrefs
.
firefoxSuggestScenarioStartupPromise
;
if
(
!
UrlbarPrefs
.
get
(
FEATURE_AVAILABLE
)
|
|
UrlbarPrefs
.
get
(
SEEN_DIALOG_PREF
)
|
|
UrlbarPrefs
.
get
(
"
quicksuggest
.
dataCollection
.
enabled
"
)
)
{
return
false
;
}
let
restartsSeen
=
UrlbarPrefs
.
get
(
RESTARTS_PREF
)
;
if
(
restartsSeen
<
UrlbarPrefs
.
get
(
"
quickSuggestShowOnboardingDialogAfterNRestarts
"
)
)
{
UrlbarPrefs
.
set
(
RESTARTS_PREF
restartsSeen
+
1
)
;
return
false
;
}
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
win
.
gBrowser
?
.
currentURI
?
.
spec
=
=
"
about
:
welcome
"
)
{
return
false
;
}
if
(
UrlbarPrefs
.
get
(
"
experimentType
"
)
=
=
=
"
modal
"
)
{
this
.
ensureExposureEventRecorded
(
)
;
}
if
(
!
UrlbarPrefs
.
get
(
"
quickSuggestShouldShowOnboardingDialog
"
)
)
{
return
false
;
}
let
variationType
;
try
{
variationType
=
UrlbarPrefs
.
get
(
DIALOG_VARIATION_PREF
)
.
toLowerCase
(
)
;
}
catch
(
e
)
{
}
let
params
=
{
choice
:
undefined
variationType
visitedMain
:
false
}
;
await
win
.
gDialogBox
.
open
(
ONBOARDING_URI
params
)
;
UrlbarPrefs
.
set
(
SEEN_DIALOG_PREF
true
)
;
UrlbarPrefs
.
set
(
DIALOG_VERSION_PREF
JSON
.
stringify
(
{
version
:
1
variation
:
variationType
}
)
)
;
let
optedIn
=
params
.
choice
=
=
ONBOARDING_CHOICE
.
ACCEPT_2
;
UrlbarPrefs
.
set
(
"
quicksuggest
.
dataCollection
.
enabled
"
optedIn
)
;
switch
(
params
.
choice
)
{
case
ONBOARDING_CHOICE
.
LEARN_MORE_1
:
case
ONBOARDING_CHOICE
.
LEARN_MORE_2
:
win
.
openTrustedLinkIn
(
UrlbarProviderQuickSuggest
.
helpUrl
"
tab
"
{
fromChrome
:
true
}
)
;
break
;
case
ONBOARDING_CHOICE
.
ACCEPT_2
:
case
ONBOARDING_CHOICE
.
REJECT_2
:
case
ONBOARDING_CHOICE
.
NOT_NOW_2
:
case
ONBOARDING_CHOICE
.
CLOSE_1
:
break
;
default
:
params
.
choice
=
params
.
visitedMain
?
ONBOARDING_CHOICE
.
DISMISS_2
:
ONBOARDING_CHOICE
.
DISMISS_1
;
break
;
}
UrlbarPrefs
.
set
(
"
quicksuggest
.
onboardingDialogChoice
"
params
.
choice
)
;
Services
.
telemetry
.
recordEvent
(
"
contextservices
.
quicksuggest
"
"
opt_in_dialog
"
params
.
choice
)
;
return
true
;
}
onPrefChanged
(
pref
)
{
switch
(
pref
)
{
case
"
suggest
.
quicksuggest
.
nonsponsored
"
:
case
"
suggest
.
quicksuggest
.
sponsored
"
:
this
.
_queueSettingsSetup
(
)
;
break
;
}
}
_rs
=
null
;
_settingsTaskQueue
=
new
TaskQueue
(
)
;
_config
=
{
}
;
_resultsByKeyword
=
new
Map
(
)
;
_addResultsChunkSize
=
ADD_RESULTS_CHUNK_SIZE
;
_queueSettingsSetup
(
)
{
this
.
_settingsTaskQueue
.
queue
(
(
)
=
>
{
let
enabled
=
UrlbarPrefs
.
get
(
FEATURE_AVAILABLE
)
&
&
(
UrlbarPrefs
.
get
(
"
suggest
.
quicksuggest
.
nonsponsored
"
)
|
|
UrlbarPrefs
.
get
(
"
suggest
.
quicksuggest
.
sponsored
"
)
)
;
if
(
enabled
&
&
!
this
.
_rs
)
{
this
.
_onSettingsSync
=
(
.
.
.
args
)
=
>
this
.
_queueSettingsSync
(
.
.
.
args
)
;
this
.
_rs
=
RemoteSettings
(
RS_COLLECTION
)
;
this
.
_rs
.
on
(
"
sync
"
this
.
_onSettingsSync
)
;
this
.
_queueSettingsSync
(
)
;
}
else
if
(
!
enabled
&
&
this
.
_rs
)
{
this
.
_rs
.
off
(
"
sync
"
this
.
_onSettingsSync
)
;
this
.
_rs
=
null
;
this
.
_onSettingsSync
=
null
;
}
}
)
;
}
async
_queueSettingsSync
(
event
=
null
)
{
await
this
.
_settingsTaskQueue
.
queue
(
async
(
)
=
>
{
if
(
event
?
.
data
?
.
deleted
)
{
await
Promise
.
all
(
event
.
data
.
deleted
.
filter
(
d
=
>
d
.
attachment
)
.
map
(
entry
=
>
Promise
.
all
(
[
this
.
_rs
.
attachments
.
deleteDownloaded
(
entry
)
this
.
_rs
.
attachments
.
deleteFromDisk
(
entry
)
]
)
)
)
;
}
let
dataType
=
UrlbarPrefs
.
get
(
"
quickSuggestRemoteSettingsDataType
"
)
;
log
.
debug
(
"
Loading
data
with
type
:
"
dataType
)
;
let
[
configArray
data
]
=
await
Promise
.
all
(
[
this
.
_rs
.
get
(
{
filters
:
{
type
:
"
configuration
"
}
}
)
this
.
_rs
.
get
(
{
filters
:
{
type
:
dataType
}
}
)
this
.
_rs
.
get
(
{
filters
:
{
type
:
"
icon
"
}
}
)
.
then
(
icons
=
>
Promise
.
all
(
icons
.
map
(
i
=
>
this
.
_rs
.
attachments
.
downloadToDisk
(
i
)
)
)
)
]
)
;
log
.
debug
(
"
Got
configuration
:
"
configArray
)
;
this
.
_setConfig
(
configArray
?
.
[
0
]
?
.
configuration
|
|
{
}
)
;
this
.
_resultsByKeyword
.
clear
(
)
;
log
.
debug
(
Got
data
with
{
data
.
length
}
records
)
;
for
(
let
record
of
data
)
{
let
{
buffer
}
=
await
this
.
_rs
.
attachments
.
download
(
record
)
;
let
results
=
JSON
.
parse
(
new
TextDecoder
(
"
utf
-
8
"
)
.
decode
(
buffer
)
)
;
log
.
debug
(
Adding
{
results
.
length
}
results
)
;
await
this
.
_addResults
(
results
)
;
}
}
)
;
}
_setConfig
(
config
)
{
this
.
_config
=
config
|
|
{
}
;
this
.
emit
(
"
config
-
set
"
)
;
}
async
_addResults
(
results
)
{
let
resultIndex
=
0
;
let
keywordIndex
=
0
;
while
(
resultIndex
<
results
.
length
)
{
await
new
Promise
(
resolve
=
>
{
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
let
indexInChunk
=
0
;
while
(
indexInChunk
<
this
.
_addResultsChunkSize
&
&
resultIndex
<
results
.
length
)
{
let
result
=
results
[
resultIndex
]
;
if
(
keywordIndex
=
=
result
.
keywords
.
length
)
{
resultIndex
+
+
;
keywordIndex
=
0
;
continue
;
}
let
keyword
=
result
.
keywords
[
keywordIndex
]
;
let
object
=
this
.
_resultsByKeyword
.
get
(
keyword
)
;
if
(
!
object
)
{
this
.
_resultsByKeyword
.
set
(
keyword
result
)
;
}
else
if
(
!
Array
.
isArray
(
object
)
)
{
this
.
_resultsByKeyword
.
set
(
keyword
[
object
result
]
)
;
}
else
{
object
.
push
(
result
)
;
}
keywordIndex
+
+
;
indexInChunk
+
+
;
}
resolve
(
)
;
}
)
;
}
)
;
}
}
async
_fetchIcon
(
path
)
{
if
(
!
path
|
|
!
this
.
_rs
)
{
return
null
;
}
let
record
=
(
await
this
.
_rs
.
get
(
{
filters
:
{
id
:
icon
-
{
path
}
}
}
)
)
.
pop
(
)
;
if
(
!
record
)
{
return
null
;
}
return
this
.
_rs
.
attachments
.
downloadToDisk
(
record
)
;
}
}
let
UrlbarQuickSuggest
=
new
QuickSuggest
(
)
;
