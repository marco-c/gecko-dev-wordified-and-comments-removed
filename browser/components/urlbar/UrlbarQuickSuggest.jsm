"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
UrlbarQuickSuggest
"
"
KeywordTree
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
TextDecoder
"
]
)
;
const
log
=
console
.
createInstance
(
{
prefix
:
"
QuickSuggest
"
maxLogLevel
:
UrlbarPrefs
.
get
(
"
quicksuggest
.
log
"
)
?
"
All
"
:
"
Warn
"
}
)
;
const
RS_COLLECTION
=
"
quicksuggest
"
;
const
RS_PREF
=
"
quicksuggest
.
enabled
"
;
class
Suggestions
{
_rs
=
null
;
_initPromise
=
null
;
_initResolve
=
null
;
_tree
=
new
KeywordTree
(
)
;
_results
=
new
Map
(
)
;
async
init
(
)
{
if
(
this
.
_initPromise
)
{
return
this
.
_initPromise
;
}
this
.
_initPromise
=
Promise
.
resolve
(
)
;
this
.
_rs
=
RemoteSettings
(
RS_COLLECTION
)
;
if
(
UrlbarPrefs
.
get
(
RS_PREF
)
)
{
this
.
_initPromise
=
new
Promise
(
resolve
=
>
(
this
.
_initResolve
=
resolve
)
)
;
Services
.
tm
.
idleDispatchToMainThread
(
this
.
_setupRemoteSettings
.
bind
(
this
)
)
;
}
else
{
UrlbarPrefs
.
addObserver
(
this
)
;
}
return
this
.
_initPromise
;
}
async
query
(
phrase
)
{
log
.
info
(
"
Handling
query
for
"
phrase
)
;
phrase
=
phrase
.
toLowerCase
(
)
;
let
index
=
this
.
_tree
.
get
(
phrase
)
;
if
(
!
index
|
|
!
this
.
_results
.
has
(
index
)
)
{
return
null
;
}
let
result
=
this
.
_results
.
get
(
index
)
;
let
d
=
new
Date
(
)
;
let
pad
=
number
=
>
number
.
toString
(
)
.
padStart
(
2
"
0
"
)
;
let
date
=
{
d
.
getFullYear
(
)
}
{
pad
(
d
.
getMonth
(
)
+
1
)
}
+
{
pad
(
d
.
getDate
(
)
)
}
{
pad
(
d
.
getHours
(
)
)
}
;
let
icon
=
await
this
.
fetchIcon
(
result
.
icon
)
;
return
{
title
:
result
.
title
url
:
result
.
url
.
replace
(
"
%
YYYYMMDDHH
%
"
date
)
click_url
:
result
.
click_url
.
replace
(
"
%
YYYYMMDDHH
%
"
date
)
impression_url
:
result
.
impression_url
block_id
:
result
.
id
advertiser
:
result
.
advertiser
.
toLocaleLowerCase
(
)
icon
}
;
}
onPrefChanged
(
changedPref
)
{
if
(
changedPref
=
=
RS_PREF
&
&
UrlbarPrefs
.
get
(
RS_PREF
)
)
{
this
.
_setupRemoteSettings
(
)
;
}
}
async
_setupRemoteSettings
(
)
{
this
.
_rs
.
on
(
"
sync
"
this
.
_onSettingsSync
.
bind
(
this
)
)
;
await
this
.
_ensureAttachmentsDownloaded
(
)
;
if
(
this
.
_initResolve
)
{
this
.
_initResolve
(
)
;
this
.
_initResolve
=
null
;
}
}
async
_onSettingsSync
(
{
data
:
{
deleted
}
}
)
{
const
toDelete
=
deleted
?
.
filter
(
d
=
>
d
.
attachment
)
;
if
(
toDelete
)
{
await
Promise
.
all
(
toDelete
.
map
(
entry
=
>
this
.
_rs
.
attachments
.
delete
(
entry
)
)
)
;
}
await
this
.
_ensureAttachmentsDownloaded
(
)
;
}
async
_ensureAttachmentsDownloaded
(
)
{
log
.
info
(
"
_ensureAttachmentsDownloaded
started
"
)
;
let
dataOpts
=
{
useCache
:
true
}
;
let
data
=
await
this
.
_rs
.
get
(
{
filters
:
{
type
:
"
data
"
}
}
)
;
await
Promise
.
all
(
data
.
map
(
r
=
>
this
.
_rs
.
attachments
.
download
(
r
dataOpts
)
)
)
;
let
icons
=
await
this
.
_rs
.
get
(
{
filters
:
{
type
:
"
icon
"
}
}
)
;
await
Promise
.
all
(
icons
.
map
(
r
=
>
this
.
_rs
.
attachments
.
download
(
r
)
)
)
;
await
this
.
_createTree
(
)
;
log
.
info
(
"
_ensureAttachmentsDownloaded
complete
"
)
;
}
async
_createTree
(
)
{
log
.
info
(
"
Building
new
KeywordTree
"
)
;
this
.
_results
=
new
Map
(
)
;
this
.
_tree
=
new
KeywordTree
(
)
;
let
data
=
await
this
.
_rs
.
get
(
{
filters
:
{
type
:
"
data
"
}
}
)
;
for
(
let
record
of
data
)
{
let
{
buffer
}
=
await
this
.
_rs
.
attachments
.
download
(
record
{
useCache
:
true
}
)
;
let
json
=
JSON
.
parse
(
new
TextDecoder
(
"
utf
-
8
"
)
.
decode
(
buffer
)
)
;
this
.
_processSuggestionsJSON
(
json
)
;
}
}
async
_processSuggestionsJSON
(
json
)
{
for
(
let
result
of
json
)
{
this
.
_results
.
set
(
result
.
id
result
)
;
for
(
let
keyword
of
result
.
keywords
)
{
this
.
_tree
.
set
(
keyword
result
.
id
)
;
}
}
}
async
fetchIcon
(
path
)
{
let
record
=
(
await
this
.
_rs
.
get
(
{
filters
:
{
id
:
icon
-
{
path
}
}
}
)
)
.
pop
(
)
;
if
(
!
record
)
{
return
null
;
}
return
this
.
_rs
.
attachments
.
download
(
record
)
;
}
}
const
RESULT_KEY
=
"
^
"
;
class
KeywordTree
{
constructor
(
)
{
this
.
tree
=
new
Map
(
)
;
}
set
(
keyword
id
)
{
if
(
keyword
.
includes
(
RESULT_KEY
)
)
{
throw
new
Error
(
"
{
RESULT_KEY
}
"
is
reserved
)
;
}
let
tree
=
this
.
tree
;
for
(
let
x
=
0
c
=
"
"
;
(
c
=
keyword
.
charAt
(
x
)
)
;
x
+
+
)
{
let
child
=
tree
.
get
(
c
)
|
|
new
Map
(
)
;
tree
.
set
(
c
child
)
;
tree
=
child
;
}
tree
.
set
(
RESULT_KEY
id
)
;
}
get
(
phrase
)
{
let
tree
=
this
.
tree
;
loop
:
while
(
phrase
.
length
)
{
for
(
const
[
key
child
]
of
tree
.
entries
(
)
)
{
if
(
phrase
.
startsWith
(
key
)
|
|
key
.
startsWith
(
phrase
)
)
{
phrase
=
phrase
.
slice
(
key
.
length
)
;
if
(
!
phrase
.
length
)
{
return
child
.
get
(
RESULT_KEY
)
|
|
null
;
}
tree
=
child
;
continue
loop
;
}
}
return
null
;
}
return
null
;
}
flatten
(
)
{
for
(
let
key
of
Array
.
from
(
this
.
tree
.
keys
(
)
)
)
{
this
.
_flatten
(
this
.
tree
key
)
;
}
}
_flatten
(
parent
key
)
{
let
tree
=
parent
.
get
(
key
)
;
let
keys
=
Array
.
from
(
tree
.
keys
(
)
)
.
filter
(
k
=
>
k
!
=
RESULT_KEY
)
;
let
result
=
tree
.
get
(
RESULT_KEY
)
;
if
(
keys
.
length
=
=
1
)
{
let
childKey
=
keys
[
0
]
;
let
child
=
tree
.
get
(
childKey
)
;
let
childResult
=
child
.
get
(
RESULT_KEY
)
;
if
(
result
=
=
childResult
)
{
let
newKey
=
key
+
childKey
;
parent
.
set
(
newKey
child
)
;
parent
.
delete
(
key
)
;
this
.
_flatten
(
parent
newKey
)
;
}
else
{
this
.
_flatten
(
tree
childKey
)
;
}
}
else
{
for
(
let
k
of
keys
)
{
this
.
_flatten
(
tree
k
)
;
}
}
}
toJSONObject
(
map
=
this
.
tree
)
{
let
tmp
=
{
}
;
for
(
let
[
key
val
]
of
map
)
{
if
(
val
instanceof
Map
)
{
tmp
[
key
]
=
this
.
toJSONObject
(
val
)
;
}
else
{
tmp
[
key
]
=
val
;
}
}
return
tmp
;
}
fromJSON
(
json
)
{
this
.
tree
=
this
.
JSONObjectToMap
(
json
)
;
}
JSONObjectToMap
(
obj
)
{
let
map
=
new
Map
(
)
;
for
(
let
key
of
Object
.
keys
(
obj
)
)
{
if
(
typeof
obj
[
key
]
=
=
"
object
"
)
{
map
.
set
(
key
this
.
JSONObjectToMap
(
obj
[
key
]
)
)
;
}
else
{
map
.
set
(
key
obj
[
key
]
)
;
}
}
return
map
;
}
}
let
UrlbarQuickSuggest
=
new
Suggestions
(
)
;
UrlbarQuickSuggest
.
init
(
)
;
