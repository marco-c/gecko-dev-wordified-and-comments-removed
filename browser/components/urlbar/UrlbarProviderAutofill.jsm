"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderAutofill
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutPagesUtils
:
"
resource
:
/
/
gre
/
modules
/
AboutPagesUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
QUERYTYPE
=
{
FILTERED
:
0
AUTOFILL_ORIGIN
:
1
AUTOFILL_URL
:
2
ADAPTIVE
:
3
}
;
const
SQL_AUTOFILL_WITH
=
WITH
frecency_stats
(
count
sum
squares
)
AS
(
SELECT
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
'
origin_frecency_count
'
)
AS
REAL
)
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
'
origin_frecency_sum
'
)
AS
REAL
)
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
'
origin_frecency_sum_of_squares
'
)
AS
REAL
)
)
autofill_frecency_threshold
(
value
)
AS
(
SELECT
CASE
count
WHEN
0
THEN
0
.
0
WHEN
1
THEN
sum
ELSE
(
sum
/
count
)
+
(
:
stddevMultiplier
*
sqrt
(
(
squares
-
(
(
sum
*
sum
)
/
count
)
)
/
count
)
)
END
FROM
frecency_stats
)
;
const
SQL_AUTOFILL_FRECENCY_THRESHOLD
=
host_frecency
>
=
(
SELECT
value
FROM
autofill_frecency_threshold
)
;
function
originQuery
(
where
)
{
let
selectVisited
=
where
.
includes
(
"
visited
"
)
?
MAX
(
EXISTS
(
SELECT
1
FROM
moz_places
WHERE
origin_id
=
o
.
id
AND
visit_count
>
0
)
)
OVER
(
PARTITION
BY
fixup_url
(
host
)
)
>
0
:
"
0
"
;
return
/
*
do
not
warn
(
bug
no
)
:
cannot
use
an
index
to
sort
*
/
{
SQL_AUTOFILL_WITH
}
origins
(
id
prefix
host_prefix
host
fixed
host_frecency
frecency
bookmarked
visited
)
AS
(
SELECT
id
prefix
first_value
(
prefix
)
OVER
(
PARTITION
BY
host
ORDER
BY
frecency
DESC
prefix
=
"
https
:
/
/
"
DESC
id
DESC
)
host
fixup_url
(
host
)
TOTAL
(
frecency
)
OVER
(
PARTITION
BY
fixup_url
(
host
)
)
frecency
MAX
(
EXISTS
(
SELECT
1
FROM
moz_places
WHERE
origin_id
=
o
.
id
AND
foreign_count
>
0
)
)
OVER
(
PARTITION
BY
fixup_url
(
host
)
)
{
selectVisited
}
FROM
moz_origins
o
WHERE
(
host
BETWEEN
:
searchString
AND
:
searchString
|
|
X
'
FFFF
'
)
OR
(
host
BETWEEN
'
www
.
'
|
|
:
searchString
AND
'
www
.
'
|
|
:
searchString
|
|
X
'
FFFF
'
)
)
SELECT
:
query_type
AS
query_type
iif
(
instr
(
host
:
searchString
)
=
1
host
fixed
)
|
|
'
/
'
AS
host_fixed
ifnull
(
:
prefix
host_prefix
)
|
|
host
|
|
'
/
'
AS
url
FROM
origins
{
where
}
ORDER
BY
frecency
DESC
prefix
=
"
https
:
/
/
"
DESC
id
DESC
LIMIT
1
;
}
function
urlQuery
(
where1
where2
)
{
return
/
*
do
not
warn
(
bug
no
)
:
cannot
use
an
index
to
sort
*
/
SELECT
:
query_type
AS
query_type
url
:
strippedURL
AS
stripped_url
frecency
foreign_count
>
0
AS
bookmarked
visit_count
>
0
AS
visited
id
FROM
moz_places
WHERE
rev_host
=
:
revHost
{
where1
}
UNION
ALL
SELECT
:
query_type
AS
query_type
url
:
strippedURL
AS
stripped_url
frecency
foreign_count
>
0
AS
bookmarked
visit_count
>
0
AS
visited
id
FROM
moz_places
WHERE
rev_host
=
:
revHost
|
|
'
www
.
'
{
where2
}
ORDER
BY
frecency
DESC
id
DESC
LIMIT
1
;
}
const
QUERY_ORIGIN_HISTORY_BOOKMARK
=
originQuery
(
WHERE
bookmarked
OR
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
)
;
const
QUERY_ORIGIN_PREFIX_HISTORY_BOOKMARK
=
originQuery
(
WHERE
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
AND
(
bookmarked
OR
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
)
)
;
const
QUERY_ORIGIN_HISTORY
=
originQuery
(
WHERE
visited
AND
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
)
;
const
QUERY_ORIGIN_PREFIX_HISTORY
=
originQuery
(
WHERE
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
AND
visited
AND
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
)
;
const
QUERY_ORIGIN_BOOKMARK
=
originQuery
(
WHERE
bookmarked
)
;
const
QUERY_ORIGIN_PREFIX_BOOKMARK
=
originQuery
(
WHERE
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
AND
bookmarked
)
;
const
QUERY_URL_HISTORY_BOOKMARK
=
urlQuery
(
AND
(
bookmarked
OR
frecency
>
20
)
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
(
bookmarked
OR
frecency
>
20
)
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_PREFIX_HISTORY_BOOKMARK
=
urlQuery
(
AND
(
bookmarked
OR
frecency
>
20
)
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
(
bookmarked
OR
frecency
>
20
)
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_HISTORY
=
urlQuery
(
AND
(
visited
OR
NOT
bookmarked
)
AND
frecency
>
20
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
(
visited
OR
NOT
bookmarked
)
AND
frecency
>
20
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_PREFIX_HISTORY
=
urlQuery
(
AND
(
visited
OR
NOT
bookmarked
)
AND
frecency
>
20
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
(
visited
OR
NOT
bookmarked
)
AND
frecency
>
20
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_BOOKMARK
=
urlQuery
(
AND
bookmarked
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
bookmarked
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_PREFIX_BOOKMARK
=
urlQuery
(
AND
bookmarked
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
bookmarked
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
kProtocolsWithIcons
=
[
"
chrome
:
"
"
moz
-
extension
:
"
"
about
:
"
"
http
:
"
"
https
:
"
"
ftp
:
"
]
;
function
iconHelper
(
url
)
{
if
(
typeof
url
=
=
"
string
"
)
{
return
kProtocolsWithIcons
.
some
(
p
=
>
url
.
startsWith
(
p
)
)
?
"
page
-
icon
:
"
+
url
:
UrlbarUtils
.
ICON
.
DEFAULT
;
}
if
(
url
&
&
url
instanceof
URL
&
&
kProtocolsWithIcons
.
includes
(
url
.
protocol
)
)
{
return
"
page
-
icon
:
"
+
url
.
href
;
}
return
UrlbarUtils
.
ICON
.
DEFAULT
;
}
class
ProviderAutofill
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
}
get
name
(
)
{
return
"
Autofill
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
;
}
async
isActive
(
queryContext
)
{
let
instance
=
this
.
queryInstance
;
this
.
_autofillData
=
null
;
if
(
!
UrlbarPrefs
.
get
(
"
autoFill
"
)
)
{
return
false
;
}
if
(
!
queryContext
.
allowAutofill
)
{
return
false
;
}
if
(
queryContext
.
tokens
.
length
!
=
1
)
{
return
false
;
}
if
(
!
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
&
&
!
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
false
;
}
if
(
queryContext
.
tokens
.
some
(
t
=
>
t
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
|
|
t
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_TITLE
)
)
{
return
false
;
}
[
this
.
_strippedPrefix
this
.
_searchString
]
=
UrlbarUtils
.
stripURLPrefix
(
queryContext
.
searchString
)
;
this
.
_strippedPrefix
=
this
.
_strippedPrefix
.
toLowerCase
(
)
;
if
(
!
this
.
_searchString
|
|
!
this
.
_searchString
.
length
)
{
return
false
;
}
if
(
UrlbarTokenizer
.
REGEXP_SPACES
.
test
(
queryContext
.
searchString
)
)
{
return
false
;
}
let
result
=
await
this
.
_getAutofillResult
(
queryContext
)
;
if
(
!
result
|
|
instance
!
=
this
.
queryInstance
)
{
return
false
;
}
this
.
_autofillData
=
{
result
instance
}
;
return
true
;
}
getPriority
(
queryContext
)
{
if
(
this
.
_autofillData
&
&
this
.
_autofillData
.
instance
=
=
this
.
queryInstance
&
&
this
.
_autofillData
.
result
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
)
{
return
1
;
}
return
0
;
}
async
startQuery
(
queryContext
addCallback
)
{
if
(
!
this
.
_autofillData
|
|
this
.
_autofillData
.
instance
!
=
this
.
queryInstance
)
{
this
.
logger
.
error
(
"
startQuery
invoked
with
an
invalid
_autofillData
"
)
;
return
;
}
this
.
_autofillData
.
result
.
heuristic
=
true
;
addCallback
(
this
this
.
_autofillData
.
result
)
;
this
.
_autofillData
=
null
;
}
cancelQuery
(
queryContext
)
{
if
(
this
.
_autofillData
?
.
instance
=
=
this
.
queryInstance
)
{
this
.
_autofillData
=
null
;
}
}
_getOriginQuery
(
queryContext
)
{
let
searchStr
=
this
.
_searchString
.
endsWith
(
"
/
"
)
?
this
.
_searchString
.
slice
(
0
-
1
)
:
this
.
_searchString
;
let
opts
=
{
query_type
:
QUERYTYPE
.
AUTOFILL_ORIGIN
searchString
:
searchStr
.
toLowerCase
(
)
stddevMultiplier
:
UrlbarPrefs
.
get
(
"
autoFill
.
stddevMultiplier
"
)
}
;
if
(
this
.
_strippedPrefix
)
{
opts
.
prefix
=
this
.
_strippedPrefix
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
&
&
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_ORIGIN_PREFIX_HISTORY_BOOKMARK
:
QUERY_ORIGIN_HISTORY_BOOKMARK
opts
]
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_ORIGIN_PREFIX_HISTORY
:
QUERY_ORIGIN_HISTORY
opts
]
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_ORIGIN_PREFIX_BOOKMARK
:
QUERY_ORIGIN_BOOKMARK
opts
]
;
}
throw
new
Error
(
"
Either
history
or
bookmark
behavior
expected
"
)
;
}
_getUrlQuery
(
queryContext
)
{
const
urlQueryHostRegexp
=
/
^
[
^
/
:
?
]
+
/
;
let
hostMatch
=
urlQueryHostRegexp
.
exec
(
this
.
_searchString
)
;
if
(
!
hostMatch
)
{
return
[
null
null
]
;
}
let
host
=
hostMatch
[
0
]
.
toLowerCase
(
)
;
let
revHost
=
host
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
+
"
.
"
;
let
strippedURL
=
queryContext
.
trimmedSearchString
;
if
(
this
.
_strippedPrefix
)
{
strippedURL
=
strippedURL
.
substr
(
this
.
_strippedPrefix
.
length
)
;
}
strippedURL
=
host
+
strippedURL
.
substr
(
host
.
length
)
;
let
opts
=
{
query_type
:
QUERYTYPE
.
AUTOFILL_URL
revHost
strippedURL
}
;
if
(
this
.
_strippedPrefix
)
{
opts
.
prefix
=
this
.
_strippedPrefix
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
&
&
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_URL_PREFIX_HISTORY_BOOKMARK
:
QUERY_URL_HISTORY_BOOKMARK
opts
]
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_URL_PREFIX_HISTORY
:
QUERY_URL_HISTORY
opts
]
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_URL_PREFIX_BOOKMARK
:
QUERY_URL_BOOKMARK
opts
]
;
}
throw
new
Error
(
"
Either
history
or
bookmark
behavior
expected
"
)
;
}
_processRow
(
row
queryContext
)
{
let
queryType
=
row
.
getResultByName
(
"
query_type
"
)
;
let
autofilledValue
finalCompleteValue
;
switch
(
queryType
)
{
case
QUERYTYPE
.
AUTOFILL_ORIGIN
:
autofilledValue
=
row
.
getResultByName
(
"
host_fixed
"
)
;
finalCompleteValue
=
row
.
getResultByName
(
"
url
"
)
;
break
;
case
QUERYTYPE
.
AUTOFILL_URL
:
let
url
=
row
.
getResultByName
(
"
url
"
)
;
let
strippedURL
=
row
.
getResultByName
(
"
stripped_url
"
)
;
let
strippedURLIndex
=
url
.
indexOf
(
strippedURL
)
;
let
strippedPrefix
=
url
.
substr
(
0
strippedURLIndex
)
;
let
nextSlashIndex
=
url
.
indexOf
(
"
/
"
strippedURLIndex
+
strippedURL
.
length
-
1
)
;
if
(
nextSlashIndex
=
=
-
1
)
{
autofilledValue
=
url
.
substr
(
strippedURLIndex
)
;
}
else
{
autofilledValue
=
url
.
substring
(
strippedURLIndex
nextSlashIndex
+
1
)
;
}
finalCompleteValue
=
strippedPrefix
+
autofilledValue
;
break
;
}
let
[
title
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
finalCompleteValue
{
stripHttp
:
true
trimEmptyQuery
:
true
trimSlash
:
!
this
.
_searchString
.
includes
(
"
/
"
)
}
)
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
title
:
[
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
url
:
[
finalCompleteValue
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
iconHelper
(
finalCompleteValue
)
}
)
)
;
autofilledValue
=
queryContext
.
searchString
+
autofilledValue
.
substring
(
this
.
_searchString
.
length
)
;
result
.
autofill
=
{
value
:
autofilledValue
selectionStart
:
queryContext
.
searchString
.
length
selectionEnd
:
autofilledValue
.
length
}
;
return
result
;
}
async
_getAutofillResult
(
queryContext
)
{
let
result
=
this
.
_matchAboutPageForAutofill
(
queryContext
)
;
if
(
result
)
{
return
result
;
}
result
=
await
this
.
_matchKnownUrl
(
queryContext
)
;
if
(
result
)
{
return
result
;
}
result
=
await
this
.
_matchSearchEnginePartialDomain
(
queryContext
)
;
if
(
result
)
{
return
result
;
}
result
=
await
this
.
_matchSearchEngineDomain
(
queryContext
)
;
if
(
result
)
{
return
result
;
}
return
null
;
}
_matchAboutPageForAutofill
(
queryContext
)
{
if
(
this
.
_strippedPrefix
!
=
"
about
:
"
|
|
!
this
.
_searchString
)
{
return
null
;
}
for
(
const
aboutUrl
of
AboutPagesUtils
.
visibleAboutUrls
)
{
if
(
aboutUrl
.
startsWith
(
about
:
{
this
.
_searchString
.
toLowerCase
(
)
}
)
)
{
let
[
trimmedUrl
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
aboutUrl
{
stripHttp
:
true
trimEmptyQuery
:
true
trimSlash
:
!
this
.
_searchString
.
includes
(
"
/
"
)
}
)
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
title
:
[
trimmedUrl
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
url
:
[
aboutUrl
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
iconHelper
(
aboutUrl
)
}
)
)
;
let
autofilledValue
=
queryContext
.
searchString
+
aboutUrl
.
substring
(
queryContext
.
searchString
.
length
)
;
result
.
autofill
=
{
value
:
autofilledValue
selectionStart
:
queryContext
.
searchString
.
length
selectionEnd
:
autofilledValue
.
length
}
;
return
result
;
}
}
return
null
;
}
async
_matchKnownUrl
(
queryContext
)
{
let
conn
=
await
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
if
(
!
conn
)
{
return
null
;
}
let
query
params
;
if
(
UrlbarTokenizer
.
looksLikeOrigin
(
this
.
_searchString
{
ignoreKnownDomains
:
true
}
)
)
{
[
query
params
]
=
this
.
_getOriginQuery
(
queryContext
)
;
}
else
{
[
query
params
]
=
this
.
_getUrlQuery
(
queryContext
)
;
}
if
(
query
)
{
let
rows
=
await
conn
.
executeCached
(
query
params
)
;
if
(
rows
.
length
)
{
return
this
.
_processRow
(
rows
[
0
]
queryContext
)
;
}
}
return
null
;
}
async
_matchSearchEngineDomain
(
queryContext
)
{
if
(
!
UrlbarPrefs
.
get
(
"
autoFill
.
searchEngines
"
)
)
{
return
null
;
}
let
searchStr
=
this
.
_searchString
;
if
(
searchStr
.
indexOf
(
"
/
"
)
=
=
searchStr
.
length
-
1
)
{
searchStr
=
searchStr
.
slice
(
0
-
1
)
;
}
if
(
!
UrlbarTokenizer
.
looksLikeOrigin
(
searchStr
{
ignoreKnownDomains
:
true
}
)
)
{
return
null
;
}
let
engine
=
(
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
searchStr
)
)
[
0
]
;
if
(
!
engine
)
{
return
null
;
}
let
url
=
engine
.
searchForm
;
let
domain
=
engine
.
getResultDomain
(
)
;
if
(
(
this
.
_strippedPrefix
&
&
!
url
.
startsWith
(
this
.
_strippedPrefix
)
)
|
|
!
(
domain
+
"
/
"
)
.
includes
(
this
.
_searchString
)
)
{
return
null
;
}
let
value
=
this
.
_strippedPrefix
+
domain
.
substr
(
domain
.
indexOf
(
searchStr
)
)
+
"
/
"
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
engine
:
[
engine
.
name
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
engine
.
iconURI
?
.
spec
}
)
)
;
let
autofilledValue
=
queryContext
.
searchString
+
value
.
substring
(
queryContext
.
searchString
.
length
)
;
result
.
autofill
=
{
value
:
autofilledValue
selectionStart
:
queryContext
.
searchString
.
length
selectionEnd
:
autofilledValue
.
length
}
;
return
result
;
}
async
_matchSearchEnginePartialDomain
(
queryContext
)
{
if
(
!
UrlbarTokenizer
.
looksLikeOrigin
(
queryContext
.
searchString
{
ignoreKnownDomains
:
true
}
)
)
{
return
null
;
}
let
trimmedString
=
queryContext
.
searchString
.
startsWith
(
"
www
.
"
)
?
queryContext
.
searchString
.
substring
(
4
)
:
queryContext
.
searchString
;
if
(
trimmedString
.
includes
(
"
.
"
)
)
{
trimmedString
=
UrlbarUtils
.
stripPublicSuffixFromHost
(
trimmedString
)
;
}
let
engines
=
await
UrlbarSearchUtils
.
enginesForDomainPrefix
(
trimmedString
{
matchAllDomainLevels
:
true
}
)
;
let
autofillByHost
=
new
Map
(
)
;
for
(
let
engine
of
engines
)
{
let
host
=
engine
.
getResultDomain
(
)
;
if
(
host
.
startsWith
(
queryContext
.
searchString
)
)
{
continue
;
}
let
indexOfString
=
host
.
indexOf
(
queryContext
.
searchString
)
;
if
(
indexOfString
=
=
-
1
)
{
continue
;
}
autofillByHost
.
set
(
host
queryContext
.
searchString
+
host
.
substring
(
indexOfString
+
queryContext
.
searchString
.
length
)
+
"
/
"
)
;
}
if
(
!
autofillByHost
.
size
)
{
return
null
;
}
let
db
=
await
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
let
hosts
=
Array
.
from
(
autofillByHost
.
keys
(
)
)
;
let
conditions
=
[
]
;
let
params
=
[
UrlbarPrefs
.
get
(
"
autoFill
.
stddevMultiplier
"
)
.
.
.
hosts
]
;
let
sources
=
queryContext
.
sources
;
if
(
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
&
&
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
conditions
.
push
(
(
bookmarked
OR
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
)
)
;
}
else
if
(
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
)
{
conditions
.
push
(
visited
AND
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
)
;
}
else
if
(
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
conditions
.
push
(
"
bookmarked
"
)
;
}
let
rows
=
await
db
.
executeCached
(
{
SQL_AUTOFILL_WITH
}
origins
(
id
prefix
host_prefix
host
fixed
host_frecency
frecency
bookmarked
visited
)
AS
(
SELECT
id
prefix
first_value
(
prefix
)
OVER
(
PARTITION
BY
host
ORDER
BY
frecency
DESC
prefix
=
"
https
:
/
/
"
DESC
id
DESC
)
host
fixup_url
(
host
)
TOTAL
(
frecency
)
OVER
(
PARTITION
BY
fixup_url
(
host
)
)
frecency
MAX
(
EXISTS
(
SELECT
1
FROM
moz_places
WHERE
origin_id
=
o
.
id
AND
foreign_count
>
0
)
)
OVER
(
PARTITION
BY
fixup_url
(
host
)
)
MAX
(
EXISTS
(
SELECT
1
FROM
moz_places
WHERE
origin_id
=
o
.
id
AND
visit_count
>
0
)
)
OVER
(
PARTITION
BY
fixup_url
(
host
)
)
FROM
moz_origins
o
WHERE
o
.
host
IN
(
{
new
Array
(
hosts
.
length
)
.
fill
(
"
?
"
)
.
join
(
"
"
)
}
)
)
SELECT
host_prefix
host
FROM
origins
{
conditions
.
length
?
"
WHERE
"
+
conditions
.
join
(
"
AND
"
)
:
"
"
}
ORDER
BY
frecency
DESC
prefix
=
"
https
:
/
/
"
DESC
id
DESC
LIMIT
1
params
)
;
if
(
!
rows
.
length
)
{
return
null
;
}
let
host
=
rows
[
0
]
.
getResultByName
(
"
host
"
)
;
let
host_prefix
=
rows
[
0
]
.
getResultByName
(
"
host_prefix
"
)
;
let
autofill
=
autofillByHost
.
get
(
host
)
;
let
url
=
host_prefix
+
host
+
"
/
"
;
let
[
title
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
url
{
stripHttp
:
true
trimEmptyQuery
:
true
trimSlash
:
true
}
)
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
title
:
[
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
url
:
[
url
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
iconHelper
(
url
)
}
)
)
;
result
.
autofill
=
{
value
:
autofill
selectionStart
:
queryContext
.
searchString
.
length
selectionEnd
:
autofill
.
length
}
;
return
result
;
}
}
var
UrlbarProviderAutofill
=
new
ProviderAutofill
(
)
;
