"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderAutofill
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutPagesUtils
:
"
resource
:
/
/
gre
/
modules
/
AboutPagesUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
const
QUERYINDEX
=
{
QUERYTYPE
:
0
URL
:
1
TITLE
:
2
BOOKMARKED
:
3
BOOKMARKTITLE
:
4
TAGS
:
5
VISITCOUNT
:
6
TYPED
:
7
PLACEID
:
8
SWITCHTAB
:
9
FRECENCY
:
10
}
;
const
QUERYINDEX_ORIGIN
=
{
AUTOFILLED_VALUE
:
1
URL
:
2
FRECENCY
:
3
}
;
const
QUERYINDEX_URL
=
{
URL
:
1
STRIPPED_URL
:
2
FRECENCY
:
3
}
;
const
QUERYTYPE
=
{
FILTERED
:
0
AUTOFILL_ORIGIN
:
1
AUTOFILL_URL
:
2
ADAPTIVE
:
3
}
;
const
SQL_AUTOFILL_WITH
=
WITH
frecency_stats
(
count
sum
squares
)
AS
(
SELECT
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
'
origin_frecency_count
'
)
AS
REAL
)
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
'
origin_frecency_sum
'
)
AS
REAL
)
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
'
origin_frecency_sum_of_squares
'
)
AS
REAL
)
)
autofill_frecency_threshold
(
value
)
AS
(
SELECT
CASE
count
WHEN
0
THEN
0
.
0
WHEN
1
THEN
sum
ELSE
(
sum
/
count
)
+
(
:
stddevMultiplier
*
sqrt
(
(
squares
-
(
(
sum
*
sum
)
/
count
)
)
/
count
)
)
END
FROM
frecency_stats
)
;
const
SQL_AUTOFILL_FRECENCY_THRESHOLD
=
host_frecency
>
=
(
SELECT
value
FROM
autofill_frecency_threshold
)
;
function
originQuery
(
{
select
=
"
"
where
=
"
"
having
=
"
"
}
)
{
return
{
SQL_AUTOFILL_WITH
}
SELECT
:
query_type
fixed_up_host
|
|
'
/
'
IFNULL
(
:
prefix
prefix
)
|
|
moz_origins
.
host
|
|
'
/
'
frecency
bookmarked
id
FROM
(
SELECT
host
host
AS
fixed_up_host
TOTAL
(
frecency
)
AS
host_frecency
(
SELECT
TOTAL
(
foreign_count
)
>
0
FROM
moz_places
WHERE
moz_places
.
origin_id
=
moz_origins
.
id
)
AS
bookmarked
{
select
}
FROM
moz_origins
WHERE
host
BETWEEN
:
searchString
AND
:
searchString
|
|
X
'
FFFF
'
{
where
}
GROUP
BY
host
HAVING
{
having
}
UNION
ALL
SELECT
host
fixup_url
(
host
)
AS
fixed_up_host
TOTAL
(
frecency
)
AS
host_frecency
(
SELECT
TOTAL
(
foreign_count
)
>
0
FROM
moz_places
WHERE
moz_places
.
origin_id
=
moz_origins
.
id
)
AS
bookmarked
{
select
}
FROM
moz_origins
WHERE
host
BETWEEN
'
www
.
'
|
|
:
searchString
AND
'
www
.
'
|
|
:
searchString
|
|
X
'
FFFF
'
{
where
}
GROUP
BY
host
HAVING
{
having
}
)
AS
grouped_hosts
JOIN
moz_origins
ON
moz_origins
.
host
=
grouped_hosts
.
host
ORDER
BY
frecency
DESC
id
DESC
LIMIT
1
;
}
function
urlQuery
(
where1
where2
)
{
return
/
*
do
not
warn
(
bug
no
)
:
cannot
use
an
index
to
sort
*
/
SELECT
:
query_type
url
:
strippedURL
frecency
foreign_count
>
0
AS
bookmarked
visit_count
>
0
AS
visited
id
FROM
moz_places
WHERE
rev_host
=
:
revHost
{
where1
}
UNION
ALL
SELECT
:
query_type
url
:
strippedURL
frecency
foreign_count
>
0
AS
bookmarked
visit_count
>
0
AS
visited
id
FROM
moz_places
WHERE
rev_host
=
:
revHost
|
|
'
www
.
'
{
where2
}
ORDER
BY
frecency
DESC
id
DESC
LIMIT
1
;
}
const
QUERY_ORIGIN_HISTORY_BOOKMARK
=
originQuery
(
{
having
:
bookmarked
OR
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
}
)
;
const
QUERY_ORIGIN_PREFIX_HISTORY_BOOKMARK
=
originQuery
(
{
where
:
AND
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
having
:
bookmarked
OR
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
}
)
;
const
QUERY_ORIGIN_HISTORY
=
originQuery
(
{
select
:
(
SELECT
TOTAL
(
visit_count
)
>
0
FROM
moz_places
WHERE
moz_places
.
origin_id
=
moz_origins
.
id
)
AS
visited
having
:
visited
AND
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
}
)
;
const
QUERY_ORIGIN_PREFIX_HISTORY
=
originQuery
(
{
select
:
(
SELECT
TOTAL
(
visit_count
)
>
0
FROM
moz_places
WHERE
moz_places
.
origin_id
=
moz_origins
.
id
)
AS
visited
where
:
AND
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
having
:
visited
AND
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
}
)
;
const
QUERY_ORIGIN_BOOKMARK
=
originQuery
(
{
having
:
bookmarked
}
)
;
const
QUERY_ORIGIN_PREFIX_BOOKMARK
=
originQuery
(
{
where
:
AND
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
having
:
bookmarked
}
)
;
const
QUERY_URL_HISTORY_BOOKMARK
=
urlQuery
(
AND
(
bookmarked
OR
frecency
>
20
)
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
(
bookmarked
OR
frecency
>
20
)
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_PREFIX_HISTORY_BOOKMARK
=
urlQuery
(
AND
(
bookmarked
OR
frecency
>
20
)
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
(
bookmarked
OR
frecency
>
20
)
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_HISTORY
=
urlQuery
(
AND
(
visited
OR
NOT
bookmarked
)
AND
frecency
>
20
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
(
visited
OR
NOT
bookmarked
)
AND
frecency
>
20
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_PREFIX_HISTORY
=
urlQuery
(
AND
(
visited
OR
NOT
bookmarked
)
AND
frecency
>
20
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
(
visited
OR
NOT
bookmarked
)
AND
frecency
>
20
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_BOOKMARK
=
urlQuery
(
AND
bookmarked
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
bookmarked
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
QUERY_URL_PREFIX_BOOKMARK
=
urlQuery
(
AND
bookmarked
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
bookmarked
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
kProtocolsWithIcons
=
[
"
chrome
:
"
"
moz
-
extension
:
"
"
about
:
"
"
http
:
"
"
https
:
"
"
ftp
:
"
]
;
function
iconHelper
(
url
)
{
if
(
typeof
url
=
=
"
string
"
)
{
return
kProtocolsWithIcons
.
some
(
p
=
>
url
.
startsWith
(
p
)
)
?
"
page
-
icon
:
"
+
url
:
UrlbarUtils
.
ICON
.
DEFAULT
;
}
if
(
url
&
&
url
instanceof
URL
&
&
kProtocolsWithIcons
.
includes
(
url
.
protocol
)
)
{
return
"
page
-
icon
:
"
+
url
.
href
;
}
return
UrlbarUtils
.
ICON
.
DEFAULT
;
}
class
ProviderAutofill
extends
UrlbarProvider
{
constructor
(
)
{
super
(
)
;
this
.
queries
=
new
Map
(
)
;
}
get
name
(
)
{
return
"
Autofill
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
HEURISTIC
;
}
async
isActive
(
queryContext
)
{
if
(
!
UrlbarPrefs
.
get
(
"
autoFill
"
)
)
{
return
false
;
}
if
(
!
queryContext
.
allowAutofill
)
{
return
false
;
}
if
(
queryContext
.
tokens
.
length
!
=
1
)
{
return
false
;
}
if
(
!
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
&
&
!
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
false
;
}
if
(
queryContext
.
tokens
.
some
(
t
=
>
t
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
|
|
t
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_TITLE
)
)
{
return
false
;
}
[
this
.
_strippedPrefix
this
.
_searchString
]
=
UrlbarUtils
.
stripURLPrefix
(
queryContext
.
searchString
)
;
this
.
_strippedPrefix
=
this
.
_strippedPrefix
.
toLowerCase
(
)
;
if
(
!
this
.
_searchString
|
|
!
this
.
_searchString
.
length
)
{
return
false
;
}
if
(
UrlbarTokenizer
.
REGEXP_SPACES
.
test
(
queryContext
.
searchString
)
)
{
return
false
;
}
let
autofilled
=
await
this
.
_getAutofillResult
(
queryContext
)
;
if
(
!
autofilled
|
|
!
this
.
_autofillResult
)
{
return
false
;
}
return
true
;
}
getPriority
(
queryContext
)
{
if
(
this
.
_autofillResult
&
&
this
.
_autofillResult
.
type
=
=
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
)
{
return
1
;
}
return
0
;
}
async
startQuery
(
queryContext
addCallback
)
{
if
(
!
this
.
_autofillResult
)
{
return
;
}
this
.
_autofillResult
.
heuristic
=
true
;
addCallback
(
this
this
.
_autofillResult
)
;
delete
this
.
_autofillResult
;
}
cancelQuery
(
queryContext
)
{
delete
this
.
_autofillResult
;
}
_getOriginQuery
(
queryContext
)
{
let
searchStr
=
this
.
_searchString
.
endsWith
(
"
/
"
)
?
this
.
_searchString
.
slice
(
0
-
1
)
:
this
.
_searchString
;
let
opts
=
{
query_type
:
QUERYTYPE
.
AUTOFILL_ORIGIN
searchString
:
searchStr
.
toLowerCase
(
)
stddevMultiplier
:
UrlbarPrefs
.
get
(
"
autoFill
.
stddevMultiplier
"
)
}
;
if
(
this
.
_strippedPrefix
)
{
opts
.
prefix
=
this
.
_strippedPrefix
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
&
&
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_ORIGIN_PREFIX_HISTORY_BOOKMARK
:
QUERY_ORIGIN_HISTORY_BOOKMARK
opts
]
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_ORIGIN_PREFIX_HISTORY
:
QUERY_ORIGIN_HISTORY
opts
]
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_ORIGIN_PREFIX_BOOKMARK
:
QUERY_ORIGIN_BOOKMARK
opts
]
;
}
throw
new
Error
(
"
Either
history
or
bookmark
behavior
expected
"
)
;
}
_getUrlQuery
(
queryContext
)
{
const
urlQueryHostRegexp
=
/
^
[
^
/
:
?
]
+
/
;
let
hostMatch
=
urlQueryHostRegexp
.
exec
(
this
.
_searchString
)
;
if
(
!
hostMatch
)
{
return
[
null
null
]
;
}
let
host
=
hostMatch
[
0
]
.
toLowerCase
(
)
;
let
revHost
=
host
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
+
"
.
"
;
let
strippedURL
=
queryContext
.
searchString
.
trim
(
)
;
if
(
this
.
_strippedPrefix
)
{
strippedURL
=
strippedURL
.
substr
(
this
.
_strippedPrefix
.
length
)
;
}
strippedURL
=
host
+
strippedURL
.
substr
(
host
.
length
)
;
let
opts
=
{
query_type
:
QUERYTYPE
.
AUTOFILL_URL
revHost
strippedURL
}
;
if
(
this
.
_strippedPrefix
)
{
opts
.
prefix
=
this
.
_strippedPrefix
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
&
&
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_URL_PREFIX_HISTORY_BOOKMARK
:
QUERY_URL_HISTORY_BOOKMARK
opts
]
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_URL_PREFIX_HISTORY
:
QUERY_URL_HISTORY
opts
]
;
}
if
(
queryContext
.
sources
.
includes
(
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
)
{
return
[
this
.
_strippedPrefix
?
QUERY_URL_PREFIX_BOOKMARK
:
QUERY_URL_BOOKMARK
opts
]
;
}
throw
new
Error
(
"
Either
history
or
bookmark
behavior
expected
"
)
;
}
_onResultRow
(
row
cancel
queryContext
)
{
let
queryType
=
row
.
getResultByIndex
(
QUERYINDEX
.
QUERYTYPE
)
;
let
autofilledValue
finalCompleteValue
;
switch
(
queryType
)
{
case
QUERYTYPE
.
AUTOFILL_ORIGIN
:
autofilledValue
=
row
.
getResultByIndex
(
QUERYINDEX_ORIGIN
.
AUTOFILLED_VALUE
)
;
finalCompleteValue
=
row
.
getResultByIndex
(
QUERYINDEX_ORIGIN
.
URL
)
;
break
;
case
QUERYTYPE
.
AUTOFILL_URL
:
let
url
=
row
.
getResultByIndex
(
QUERYINDEX_URL
.
URL
)
;
let
strippedURL
=
row
.
getResultByIndex
(
QUERYINDEX_URL
.
STRIPPED_URL
)
;
let
strippedURLIndex
=
url
.
indexOf
(
strippedURL
)
;
let
strippedPrefix
=
url
.
substr
(
0
strippedURLIndex
)
;
let
nextSlashIndex
=
url
.
indexOf
(
"
/
"
strippedURLIndex
+
strippedURL
.
length
-
1
)
;
if
(
nextSlashIndex
=
=
-
1
)
{
autofilledValue
=
url
.
substr
(
strippedURLIndex
)
;
}
else
{
autofilledValue
=
url
.
substring
(
strippedURLIndex
nextSlashIndex
+
1
)
;
}
finalCompleteValue
=
strippedPrefix
+
autofilledValue
;
break
;
}
cancel
(
)
;
let
[
title
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
finalCompleteValue
{
stripHttp
:
true
trimEmptyQuery
:
true
trimSlash
:
!
this
.
_searchString
.
includes
(
"
/
"
)
}
)
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
title
:
[
title
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
url
:
[
finalCompleteValue
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
iconHelper
(
finalCompleteValue
)
}
)
)
;
autofilledValue
=
queryContext
.
searchString
+
autofilledValue
.
substring
(
this
.
_searchString
.
length
)
;
result
.
autofill
=
{
value
:
autofilledValue
selectionStart
:
queryContext
.
searchString
.
length
selectionEnd
:
autofilledValue
.
length
}
;
this
.
_autofillResult
=
result
;
}
async
_getAutofillResult
(
queryContext
)
{
this
.
_matchAboutPageForAutofill
(
queryContext
)
;
if
(
this
.
_autofillResult
)
{
return
true
;
}
await
this
.
_matchKnownUrl
(
queryContext
)
;
if
(
this
.
_autofillResult
)
{
return
true
;
}
await
this
.
_matchSearchEngineDomain
(
queryContext
)
;
if
(
this
.
_autofillResult
)
{
return
true
;
}
return
false
;
}
_matchAboutPageForAutofill
(
queryContext
)
{
if
(
this
.
_strippedPrefix
!
=
"
about
:
"
|
|
!
this
.
_searchString
)
{
return
;
}
for
(
const
aboutUrl
of
AboutPagesUtils
.
visibleAboutUrls
)
{
if
(
aboutUrl
.
startsWith
(
about
:
{
this
.
_searchString
.
toLowerCase
(
)
}
)
)
{
let
[
trimmedUrl
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
aboutUrl
{
stripHttp
:
true
trimEmptyQuery
:
true
trimSlash
:
!
this
.
_searchString
.
includes
(
"
/
"
)
}
)
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
title
:
[
trimmedUrl
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
url
:
[
aboutUrl
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
iconHelper
(
aboutUrl
)
}
)
)
;
let
autofilledValue
=
queryContext
.
searchString
+
aboutUrl
.
substring
(
queryContext
.
searchString
.
length
)
;
result
.
autofill
=
{
value
:
autofilledValue
selectionStart
:
queryContext
.
searchString
.
length
selectionEnd
:
autofilledValue
.
length
}
;
this
.
_autofillResult
=
result
;
return
;
}
}
}
async
_matchKnownUrl
(
queryContext
)
{
let
conn
=
await
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
if
(
!
conn
)
{
return
;
}
let
query
params
;
if
(
UrlbarTokenizer
.
looksLikeOrigin
(
this
.
_searchString
{
ignoreKnownDomains
:
true
}
)
)
{
[
query
params
]
=
this
.
_getOriginQuery
(
queryContext
)
;
}
else
{
[
query
params
]
=
this
.
_getUrlQuery
(
queryContext
)
;
}
if
(
query
)
{
await
conn
.
executeCached
(
query
params
(
row
cancel
)
=
>
{
this
.
_onResultRow
(
row
cancel
queryContext
)
;
}
)
;
}
}
async
_matchSearchEngineDomain
(
queryContext
)
{
if
(
!
UrlbarPrefs
.
get
(
"
autoFill
.
searchEngines
"
)
)
{
return
;
}
let
searchStr
=
this
.
_searchString
;
if
(
searchStr
.
indexOf
(
"
/
"
)
=
=
searchStr
.
length
-
1
)
{
searchStr
=
searchStr
.
slice
(
0
-
1
)
;
}
if
(
!
UrlbarTokenizer
.
looksLikeOrigin
(
searchStr
{
ignoreKnownDomains
:
true
}
)
)
{
return
;
}
let
engine
=
await
UrlbarSearchUtils
.
engineForDomainPrefix
(
searchStr
)
;
if
(
!
engine
)
{
return
;
}
let
url
=
engine
.
searchForm
;
let
domain
=
engine
.
getResultDomain
(
)
;
if
(
(
this
.
_strippedPrefix
&
&
!
url
.
startsWith
(
this
.
_strippedPrefix
)
)
|
|
!
(
domain
+
"
/
"
)
.
includes
(
this
.
_searchString
)
)
{
return
;
}
let
value
=
this
.
_strippedPrefix
+
domain
.
substr
(
domain
.
indexOf
(
searchStr
)
)
+
"
/
"
;
let
result
=
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
queryContext
.
tokens
{
engine
:
[
engine
.
name
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
engine
.
iconURI
?
engine
.
iconURI
.
spec
:
"
"
}
)
)
;
let
autofilledValue
=
queryContext
.
searchString
+
value
.
substring
(
queryContext
.
searchString
.
length
)
;
result
.
autofill
=
{
value
:
autofilledValue
selectionStart
:
queryContext
.
searchString
.
length
selectionEnd
:
autofilledValue
.
length
}
;
this
.
_autofillResult
=
result
;
}
}
var
UrlbarProviderAutofill
=
new
ProviderAutofill
(
)
;
