"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
L10nCache
"
"
SkippableTimer
"
"
UrlbarMuxer
"
"
UrlbarProvider
"
"
UrlbarQueryContext
"
"
UrlbarUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
FormHistory
:
"
resource
:
/
/
gre
/
modules
/
FormHistory
.
jsm
"
KeywordUtils
:
"
resource
:
/
/
gre
/
modules
/
KeywordUtils
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
PlacesUIUtils
:
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
SearchSuggestionController
:
"
resource
:
/
/
gre
/
modules
/
SearchSuggestionController
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
}
)
;
var
UrlbarUtils
=
{
MAX_OMNIBOX_RESULT_COUNT
:
6
RESULT_GROUP
:
{
ABOUT_PAGES
:
"
aboutPages
"
GENERAL
:
"
general
"
GENERAL_PARENT
:
"
generalParent
"
FORM_HISTORY
:
"
formHistory
"
HEURISTIC_AUTOFILL
:
"
heuristicAutofill
"
HEURISTIC_ENGINE_ALIAS
:
"
heuristicEngineAlias
"
HEURISTIC_EXTENSION
:
"
heuristicExtension
"
HEURISTIC_FALLBACK
:
"
heuristicFallback
"
HEURISTIC_BOOKMARK_KEYWORD
:
"
heuristicBookmarkKeyword
"
HEURISTIC_OMNIBOX
:
"
heuristicOmnibox
"
HEURISTIC_PRELOADED
:
"
heuristicPreloaded
"
HEURISTIC_SEARCH_TIP
:
"
heuristicSearchTip
"
HEURISTIC_TEST
:
"
heuristicTest
"
HEURISTIC_TOKEN_ALIAS_ENGINE
:
"
heuristicTokenAliasEngine
"
INPUT_HISTORY
:
"
inputHistory
"
OMNIBOX
:
"
extension
"
PRELOADED
:
"
preloaded
"
REMOTE_SUGGESTION
:
"
remoteSuggestion
"
REMOTE_TAB
:
"
remoteTab
"
SUGGESTED_INDEX
:
"
suggestedIndex
"
TAIL_SUGGESTION
:
"
tailSuggestion
"
}
PROVIDER_TYPE
:
{
HEURISTIC
:
1
PROFILE
:
2
NETWORK
:
3
EXTENSION
:
4
}
RESULT_TYPE
:
{
TAB_SWITCH
:
1
SEARCH
:
2
URL
:
3
KEYWORD
:
4
OMNIBOX
:
5
REMOTE_TAB
:
6
TIP
:
7
DYNAMIC
:
8
}
RESULT_SOURCE
:
{
BOOKMARKS
:
1
HISTORY
:
2
SEARCH
:
3
TABS
:
4
OTHER_LOCAL
:
5
OTHER_NETWORK
:
6
}
SELECTED_RESULT_TYPES
:
{
autofill
:
0
bookmark
:
1
history
:
2
keyword
:
3
searchengine
:
4
searchsuggestion
:
5
switchtab
:
6
tag
:
7
visiturl
:
8
remotetab
:
9
extension
:
10
"
preloaded
-
top
-
site
"
:
11
tip
:
12
topsite
:
13
formhistory
:
14
dynamic
:
15
tabtosearch
:
16
}
ICON
:
{
EXTENSION
:
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extension
.
svg
"
HISTORY
:
"
chrome
:
/
/
browser
/
skin
/
history
.
svg
"
SEARCH_GLASS
:
"
chrome
:
/
/
global
/
skin
/
icons
/
search
-
glass
.
svg
"
TIP
:
"
chrome
:
/
/
global
/
skin
/
icons
/
lightbulb
.
svg
"
}
PAGE_UP_DOWN_DELTA
:
5
COMPOSITION
:
{
NONE
:
1
COMPOSING
:
2
COMMIT
:
3
CANCELED
:
4
}
MAX_TEXT_LENGTH
:
255
HIGHLIGHT
:
{
NONE
:
0
TYPED
:
1
SUGGESTED
:
2
}
TITLE_TAGS_SEPARATOR
:
"
\
x1F
"
REGEXP_SINGLE_WORD
:
/
^
[
^
\
s
:
/
?
#
]
+
(
:
\
d
+
)
?
/
SEARCH_MODE_ENTRY
:
new
Set
(
[
"
bookmarkmenu
"
"
handoff
"
"
keywordoffer
"
"
oneoff
"
"
other
"
"
shortcut
"
"
tabmenu
"
"
tabtosearch
"
"
tabtosearch_onboard
"
"
topsites_newtab
"
"
topsites_urlbar
"
"
touchbar
"
"
typed
"
]
)
PROTOCOLS_WITH_ICONS
:
[
"
chrome
:
"
"
moz
-
extension
:
"
"
about
:
"
"
http
:
"
"
https
:
"
"
ftp
:
"
]
get
LOCAL_SEARCH_MODES
(
)
{
return
[
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
restrict
:
UrlbarTokenizer
.
RESTRICT
.
BOOKMARK
icon
:
"
chrome
:
/
/
browser
/
skin
/
bookmark
.
svg
"
pref
:
"
shortcuts
.
bookmarks
"
}
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
TABS
restrict
:
UrlbarTokenizer
.
RESTRICT
.
OPENPAGE
icon
:
"
chrome
:
/
/
browser
/
skin
/
tab
.
svg
"
pref
:
"
shortcuts
.
tabs
"
}
{
source
:
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
restrict
:
UrlbarTokenizer
.
RESTRICT
.
HISTORY
icon
:
"
chrome
:
/
/
browser
/
skin
/
history
.
svg
"
pref
:
"
shortcuts
.
history
"
}
]
;
}
getPayloadSchema
(
type
)
{
return
UrlbarUtils
.
RESULT_PAYLOAD_SCHEMA
[
type
]
;
}
addToUrlbarHistory
(
url
window
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
url
&
&
!
url
.
includes
(
"
"
)
&
&
!
/
[
\
x00
-
\
x1F
]
/
.
test
(
url
)
)
{
PlacesUIUtils
.
markPageAsTyped
(
url
)
;
}
}
async
getShortcutOrURIAndPostData
(
url
)
{
let
mayInheritPrincipal
=
false
;
let
postData
=
null
;
let
[
keyword
param
=
"
"
]
=
url
.
trim
(
)
.
split
(
/
\
s
(
.
+
)
/
2
)
;
if
(
!
keyword
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
let
engine
=
await
Services
.
search
.
getEngineByAlias
(
keyword
)
;
if
(
engine
)
{
let
submission
=
engine
.
getSubmission
(
param
null
"
keyword
"
)
;
return
{
url
:
submission
.
uri
.
spec
postData
:
submission
.
postData
mayInheritPrincipal
}
;
}
let
entry
=
null
;
try
{
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
keyword
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Unable
to
fetch
Places
keyword
"
{
keyword
}
"
:
{
ex
}
)
;
}
if
(
!
entry
|
|
!
entry
.
url
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
try
{
[
url
postData
]
=
await
KeywordUtils
.
parseUrlAndPostData
(
entry
.
url
.
href
entry
.
postData
param
)
;
if
(
postData
)
{
postData
=
this
.
getPostDataStream
(
postData
)
;
}
mayInheritPrincipal
=
true
;
}
catch
(
ex
)
{
}
return
{
url
postData
mayInheritPrincipal
}
;
}
getPostDataStream
(
postDataString
type
=
"
application
/
x
-
www
-
form
-
urlencoded
"
)
{
let
dataStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
dataStream
.
data
=
postDataString
;
let
mimeStream
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
mimeStream
.
addHeader
(
"
Content
-
Type
"
type
)
;
mimeStream
.
setData
(
dataStream
)
;
return
mimeStream
.
QueryInterface
(
Ci
.
nsIInputStream
)
;
}
_compareIgnoringDiacritics
:
null
getTokenMatches
(
tokens
str
highlightType
)
{
str
=
str
.
substring
(
0
UrlbarUtils
.
MAX_TEXT_LENGTH
)
.
toLocaleLowerCase
(
)
;
let
hits
=
new
Array
(
str
.
length
)
.
fill
(
highlightType
=
=
this
.
HIGHLIGHT
.
SUGGESTED
?
1
:
0
)
;
let
compareIgnoringDiacritics
;
for
(
let
i
=
0
totalTokensLength
=
0
;
i
<
tokens
.
length
;
i
+
+
)
{
const
{
lowerCaseValue
:
needle
}
=
tokens
[
i
]
;
if
(
!
needle
)
{
continue
;
}
let
index
=
0
;
let
found
=
false
;
for
(
;
;
)
{
index
=
str
.
indexOf
(
needle
index
)
;
if
(
index
<
0
)
{
break
;
}
if
(
highlightType
=
=
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
)
{
let
previousSpaceIndex
=
str
.
lastIndexOf
(
"
"
index
)
+
1
;
if
(
index
!
=
previousSpaceIndex
)
{
index
+
=
needle
.
length
;
found
=
true
;
continue
;
}
}
hits
.
fill
(
highlightType
=
=
this
.
HIGHLIGHT
.
SUGGESTED
?
0
:
1
index
index
+
needle
.
length
)
;
index
+
=
needle
.
length
;
found
=
true
;
}
if
(
!
found
)
{
if
(
!
compareIgnoringDiacritics
)
{
if
(
!
this
.
_compareIgnoringDiacritics
)
{
this
.
_compareIgnoringDiacritics
=
new
Intl
.
Collator
(
"
en
"
{
sensitivity
:
"
base
"
}
)
.
compare
;
}
compareIgnoringDiacritics
=
this
.
_compareIgnoringDiacritics
;
}
index
=
0
;
while
(
index
<
str
.
length
)
{
let
hay
=
str
.
substr
(
index
needle
.
length
)
;
if
(
compareIgnoringDiacritics
(
needle
hay
)
=
=
=
0
)
{
if
(
highlightType
=
=
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
)
{
let
previousSpaceIndex
=
str
.
lastIndexOf
(
"
"
index
)
+
1
;
if
(
index
!
=
previousSpaceIndex
)
{
index
+
=
needle
.
length
;
continue
;
}
}
hits
.
fill
(
highlightType
=
=
this
.
HIGHLIGHT
.
SUGGESTED
?
0
:
1
index
index
+
needle
.
length
)
;
index
+
=
needle
.
length
;
}
else
{
index
+
+
;
}
}
}
totalTokensLength
+
=
needle
.
length
;
if
(
totalTokensLength
>
UrlbarUtils
.
MAX_TEXT_LENGTH
)
{
break
;
}
}
let
ranges
=
[
]
;
for
(
let
index
=
hits
.
indexOf
(
1
)
;
index
>
=
0
&
&
index
<
hits
.
length
;
)
{
let
len
=
0
;
for
(
let
j
=
index
;
j
<
hits
.
length
&
&
hits
[
j
]
;
+
+
j
+
+
len
)
{
}
ranges
.
push
(
[
index
len
]
)
;
index
=
hits
.
indexOf
(
1
index
+
len
)
;
}
return
ranges
;
}
getResultGroup
(
result
)
{
if
(
result
.
group
)
{
return
result
.
group
;
}
if
(
result
.
hasSuggestedIndex
&
&
!
result
.
isSuggestedIndexRelativeToGroup
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTED_INDEX
;
}
if
(
result
.
heuristic
)
{
switch
(
result
.
providerName
)
{
case
"
AliasEngines
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_ENGINE_ALIAS
;
case
"
Autofill
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_AUTOFILL
;
case
"
BookmarkKeywords
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_BOOKMARK_KEYWORD
;
case
"
HeuristicFallback
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_FALLBACK
;
case
"
Omnibox
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_OMNIBOX
;
case
"
PreloadedSites
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_PRELOADED
;
case
"
TokenAliasEngines
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TOKEN_ALIAS_ENGINE
;
case
"
UrlbarProviderSearchTips
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_SEARCH_TIP
;
default
:
if
(
result
.
providerName
.
startsWith
(
"
TestProvider
"
)
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
;
}
break
;
}
if
(
result
.
providerType
=
=
UrlbarUtils
.
PROVIDER_TYPE
.
EXTENSION
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_EXTENSION
;
}
Cu
.
reportError
(
"
Returning
HEURISTIC_FALLBACK
for
unrecognized
heuristic
result
:
"
+
result
)
;
return
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_FALLBACK
;
}
switch
(
result
.
providerName
)
{
case
"
AboutPages
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
ABOUT_PAGES
;
case
"
InputHistory
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
INPUT_HISTORY
;
case
"
PreloadedSites
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
PRELOADED
;
case
"
UrlbarProviderQuickSuggest
"
:
return
UrlbarUtils
.
RESULT_GROUP
.
GENERAL_PARENT
;
default
:
break
;
}
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
FORM_HISTORY
;
}
if
(
result
.
payload
.
tail
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
TAIL_SUGGESTION
;
}
if
(
result
.
payload
.
suggestion
)
{
return
UrlbarUtils
.
RESULT_GROUP
.
REMOTE_SUGGESTION
;
}
break
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
UrlbarUtils
.
RESULT_GROUP
.
OMNIBOX
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
return
UrlbarUtils
.
RESULT_GROUP
.
REMOTE_TAB
;
}
return
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
}
getUrlFromResult
(
result
)
{
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
return
{
url
:
result
.
payload
.
url
postData
:
null
}
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
return
{
url
:
result
.
payload
.
url
postData
:
result
.
payload
.
postData
?
this
.
getPostDataStream
(
result
.
payload
.
postData
)
:
null
}
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
{
if
(
result
.
payload
.
engine
)
{
const
engine
=
Services
.
search
.
getEngineByName
(
result
.
payload
.
engine
)
;
let
[
url
postData
]
=
this
.
getSearchQueryUrl
(
engine
result
.
payload
.
suggestion
|
|
result
.
payload
.
query
)
;
return
{
url
postData
}
;
}
break
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
{
return
{
url
:
result
.
payload
.
buttonUrl
postData
:
null
}
;
}
}
return
{
url
:
null
postData
:
null
}
;
}
getSearchQueryUrl
(
engine
query
)
{
let
submission
=
engine
.
getSubmission
(
query
null
"
keyword
"
)
;
return
[
submission
.
uri
.
spec
submission
.
postData
]
;
}
getPrefixRank
(
prefix
)
{
return
[
"
http
:
/
/
www
.
"
"
http
:
/
/
"
"
https
:
/
/
www
.
"
"
https
:
/
/
"
]
.
indexOf
(
prefix
)
;
}
getSpanForResult
(
result
)
{
if
(
result
.
resultSpan
)
{
return
result
.
resultSpan
;
}
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
case
UrlbarUtils
.
RESULT_TYPE
.
BOOKMARKS
:
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
1
;
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
return
3
;
}
return
1
;
}
getIconForUrl
(
url
)
{
if
(
typeof
url
=
=
"
string
"
)
{
return
UrlbarUtils
.
PROTOCOLS_WITH_ICONS
.
some
(
p
=
>
url
.
startsWith
(
p
)
)
?
"
page
-
icon
:
"
+
url
:
UrlbarUtils
.
ICON
.
DEFAULT
;
}
if
(
url
instanceof
URL
&
&
UrlbarUtils
.
PROTOCOLS_WITH_ICONS
.
includes
(
url
.
protocol
)
)
{
return
"
page
-
icon
:
"
+
url
.
href
;
}
return
UrlbarUtils
.
ICON
.
DEFAULT
;
}
searchModeForToken
(
token
)
{
if
(
token
=
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
)
{
return
{
engineName
:
UrlbarSearchUtils
.
getDefaultEngine
(
this
.
isPrivate
)
.
name
}
;
}
let
mode
=
UrlbarUtils
.
LOCAL_SEARCH_MODES
.
find
(
m
=
>
m
.
restrict
=
=
token
)
;
if
(
!
mode
)
{
return
null
;
}
return
{
.
.
.
mode
}
;
}
setupSpeculativeConnection
(
urlOrEngine
window
)
{
if
(
!
UrlbarPrefs
.
get
(
"
speculativeConnect
.
enabled
"
)
)
{
return
;
}
if
(
urlOrEngine
instanceof
Ci
.
nsISearchEngine
)
{
try
{
urlOrEngine
.
speculativeConnect
(
{
window
originAttributes
:
window
.
gBrowser
.
contentPrincipal
.
originAttributes
}
)
;
}
catch
(
ex
)
{
}
return
;
}
if
(
urlOrEngine
instanceof
URL
)
{
urlOrEngine
=
urlOrEngine
.
href
;
}
try
{
let
uri
=
urlOrEngine
instanceof
Ci
.
nsIURI
?
urlOrEngine
:
Services
.
io
.
newURI
(
urlOrEngine
)
;
Services
.
io
.
speculativeConnect
(
uri
window
.
gBrowser
.
contentPrincipal
null
)
;
}
catch
(
ex
)
{
}
}
stripPrefixAndTrim
(
spec
options
=
{
}
)
{
let
prefix
=
"
"
;
let
suffix
=
"
"
;
if
(
options
.
stripHttp
&
&
spec
.
startsWith
(
"
http
:
/
/
"
)
)
{
spec
=
spec
.
slice
(
7
)
;
prefix
=
"
http
:
/
/
"
;
}
else
if
(
options
.
stripHttps
&
&
spec
.
startsWith
(
"
https
:
/
/
"
)
)
{
spec
=
spec
.
slice
(
8
)
;
prefix
=
"
https
:
/
/
"
;
}
if
(
options
.
stripWww
&
&
spec
.
startsWith
(
"
www
.
"
)
)
{
spec
=
spec
.
slice
(
4
)
;
prefix
+
=
"
www
.
"
;
}
if
(
options
.
trimEmptyHash
&
&
spec
.
endsWith
(
"
#
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
suffix
=
"
#
"
+
suffix
;
}
if
(
options
.
trimEmptyQuery
&
&
spec
.
endsWith
(
"
?
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
suffix
=
"
?
"
+
suffix
;
}
if
(
options
.
trimSlash
&
&
spec
.
endsWith
(
"
/
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
suffix
=
"
/
"
+
suffix
;
}
if
(
options
.
trimTrailingDot
&
&
spec
.
endsWith
(
"
.
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
suffix
=
"
.
"
+
suffix
;
}
return
[
spec
prefix
suffix
]
;
}
stripPublicSuffixFromHost
(
host
)
{
try
{
return
host
.
substring
(
0
host
.
length
-
Services
.
eTLD
.
getKnownPublicSuffixFromHost
(
host
)
.
length
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
)
{
throw
ex
;
}
}
return
host
;
}
stripUnsafeProtocolOnPaste
(
pasteData
)
{
while
(
true
)
{
let
scheme
=
"
"
;
try
{
scheme
=
Services
.
io
.
extractScheme
(
pasteData
)
;
}
catch
(
ex
)
{
}
if
(
scheme
!
=
"
javascript
"
)
{
break
;
}
pasteData
=
pasteData
.
substring
(
pasteData
.
indexOf
(
"
:
"
)
+
1
)
;
}
return
pasteData
;
}
async
addToInputHistory
(
url
input
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
addToInputHistory
"
db
=
>
{
return
db
.
executeCached
(
INSERT
OR
REPLACE
INTO
moz_inputhistory
SELECT
h
.
id
IFNULL
(
i
.
input
:
input
)
IFNULL
(
i
.
use_count
0
)
*
.
9
+
1
FROM
moz_places
h
LEFT
JOIN
moz_inputhistory
i
ON
i
.
place_id
=
h
.
id
AND
i
.
input
=
:
input
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
input
}
)
;
}
)
;
}
isPasteEvent
(
event
)
{
return
(
event
.
inputType
&
&
(
event
.
inputType
.
startsWith
(
"
insertFromPaste
"
)
|
|
event
.
inputType
=
=
"
insertFromYank
"
)
)
;
}
looksLikeSingleWordHost
(
value
)
{
let
str
=
value
.
trim
(
)
;
return
this
.
REGEXP_SINGLE_WORD
.
test
(
str
)
;
}
substringAt
(
sourceStr
targetStr
)
{
let
index
=
sourceStr
.
indexOf
(
targetStr
)
;
return
index
<
0
?
"
"
:
sourceStr
.
substr
(
index
)
;
}
substringAfter
(
sourceStr
targetStr
)
{
let
index
=
sourceStr
.
indexOf
(
targetStr
)
;
return
index
<
0
?
"
"
:
sourceStr
.
substr
(
index
+
targetStr
.
length
)
;
}
stripURLPrefix
(
str
)
{
let
match
=
UrlbarTokenizer
.
REGEXP_PREFIX
.
exec
(
str
)
;
if
(
!
match
)
{
return
[
"
"
str
]
;
}
let
prefix
=
match
[
0
]
;
if
(
prefix
.
length
<
str
.
length
&
&
str
[
prefix
.
length
]
=
=
"
"
)
{
return
[
"
"
str
]
;
}
return
[
prefix
str
.
substr
(
prefix
.
length
)
]
;
}
async
getHeuristicResultFor
(
searchString
window
=
BrowserWindowTracker
.
getTopWindow
(
)
)
{
if
(
!
searchString
)
{
throw
new
Error
(
"
Must
pass
a
non
-
null
search
string
"
)
;
}
let
options
=
{
allowAutofill
:
false
isPrivate
:
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
maxResults
:
1
searchString
userContextId
:
window
.
gBrowser
.
selectedBrowser
.
getAttribute
(
"
usercontextid
"
)
prohibitRemoteResults
:
true
providers
:
[
"
AliasEngines
"
"
BookmarkKeywords
"
"
HeuristicFallback
"
]
}
;
if
(
window
.
gURLBar
.
searchMode
)
{
let
searchMode
=
window
.
gURLBar
.
searchMode
;
options
.
searchMode
=
searchMode
;
if
(
searchMode
.
source
)
{
options
.
sources
=
[
searchMode
.
source
]
;
}
}
let
context
=
new
UrlbarQueryContext
(
options
)
;
await
UrlbarProvidersManager
.
startQuery
(
context
)
;
if
(
!
context
.
heuristicResult
)
{
throw
new
Error
(
"
There
should
always
be
an
heuristic
result
"
)
;
}
return
context
.
heuristicResult
;
}
getLogger
(
{
prefix
=
"
"
}
=
{
}
)
{
if
(
!
this
.
_logger
)
{
this
.
_logger
=
Log
.
repository
.
getLogger
(
"
urlbar
"
)
;
this
.
_logger
.
manageLevelFromPref
(
"
browser
.
urlbar
.
loglevel
"
)
;
this
.
_logger
.
addAppender
(
new
Log
.
ConsoleAppender
(
new
Log
.
BasicFormatter
(
)
)
)
;
}
if
(
prefix
)
{
return
Log
.
repository
.
getLoggerWithMessagePrefix
(
"
urlbar
"
prefix
+
"
:
:
"
)
;
}
return
this
.
_logger
;
}
getResultSourceName
(
source
)
{
if
(
!
this
.
_resultSourceNamesBySource
)
{
this
.
_resultSourceNamesBySource
=
new
Map
(
)
;
for
(
let
[
name
src
]
of
Object
.
entries
(
this
.
RESULT_SOURCE
)
)
{
this
.
_resultSourceNamesBySource
.
set
(
src
name
.
toLowerCase
(
)
)
;
}
}
return
this
.
_resultSourceNamesBySource
.
get
(
source
)
;
}
addToFormHistory
(
input
value
source
)
{
if
(
!
value
|
|
input
.
isPrivate
|
|
value
.
length
>
SearchSuggestionController
.
SEARCH_HISTORY_MAX_VALUE_LENGTH
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
FormHistory
.
update
(
{
op
:
"
bump
"
fieldname
:
input
.
formHistoryName
value
source
}
{
handleError
:
reject
handleCompletion
:
resolve
}
)
;
}
)
;
}
canAutofillURL
(
url
candidate
checkFragmentOnly
=
false
)
{
if
(
!
checkFragmentOnly
&
&
(
url
.
length
<
=
candidate
.
length
|
|
!
url
.
toLocaleLowerCase
(
)
.
startsWith
(
candidate
.
toLocaleLowerCase
(
)
)
)
)
{
return
false
;
}
if
(
!
UrlbarTokenizer
.
REGEXP_PREFIX
.
test
(
url
)
)
{
url
=
"
http
:
/
/
"
+
url
;
}
if
(
!
UrlbarTokenizer
.
REGEXP_PREFIX
.
test
(
candidate
)
)
{
candidate
=
"
http
:
/
/
"
+
candidate
;
}
try
{
url
=
new
URL
(
url
)
;
candidate
=
new
URL
(
candidate
)
;
}
catch
(
e
)
{
return
false
;
}
if
(
!
checkFragmentOnly
&
&
candidate
.
href
.
endsWith
(
"
/
"
)
&
&
(
url
.
pathname
.
length
>
candidate
.
pathname
.
length
|
|
url
.
hash
)
)
{
return
false
;
}
return
url
.
hash
.
startsWith
(
candidate
.
hash
)
;
}
telemetryTypeFromResult
(
result
)
{
if
(
!
result
)
{
return
"
unknown
"
;
}
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
return
"
switchtab
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
)
{
return
"
formhistory
"
;
}
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
return
"
tabtosearch
"
;
}
return
result
.
payload
.
suggestion
?
"
searchsuggestion
"
:
"
searchengine
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
if
(
result
.
autofill
)
{
return
"
autofill
"
;
}
if
(
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
&
&
result
.
heuristic
)
{
return
"
visiturl
"
;
}
return
result
.
source
=
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
?
"
bookmark
"
:
"
history
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
return
"
keyword
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
"
extension
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
return
"
remotetab
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
return
"
tip
"
;
case
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
:
if
(
result
.
providerName
=
=
"
TabToSearch
"
)
{
return
"
tabtosearch
"
;
}
return
"
dynamic
"
;
}
return
"
unknown
"
;
}
unEscapeURIForUI
(
uri
)
{
return
uri
.
length
>
UrlbarUtils
.
MAX_TEXT_LENGTH
?
uri
:
Services
.
textToSubURI
.
unEscapeURIForUI
(
uri
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
UrlbarUtils
.
ICON
"
DEFAULT
"
(
)
=
>
{
return
PlacesUtils
.
favicons
.
defaultFavicon
.
spec
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
UrlbarUtils
"
strings
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
autocomplete
.
properties
"
)
;
}
)
;
UrlbarUtils
.
RESULT_PAYLOAD_SCHEMA
=
{
[
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
]
:
{
type
:
"
object
"
required
:
[
"
url
"
]
properties
:
{
displayUrl
:
{
type
:
"
string
"
}
icon
:
{
type
:
"
string
"
}
title
:
{
type
:
"
string
"
}
url
:
{
type
:
"
string
"
}
userContextId
:
{
type
:
"
number
"
}
}
}
[
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
]
:
{
type
:
"
object
"
properties
:
{
displayUrl
:
{
type
:
"
string
"
}
engine
:
{
type
:
"
string
"
}
icon
:
{
type
:
"
string
"
}
inPrivateWindow
:
{
type
:
"
boolean
"
}
isPinned
:
{
type
:
"
boolean
"
}
isPrivateEngine
:
{
type
:
"
boolean
"
}
isGeneralPurposeEngine
:
{
type
:
"
boolean
"
}
keyword
:
{
type
:
"
string
"
}
lowerCaseSuggestion
:
{
type
:
"
string
"
}
providesSearchMode
:
{
type
:
"
boolean
"
}
query
:
{
type
:
"
string
"
}
satisfiesAutofillThreshold
:
{
type
:
"
boolean
"
}
suggestion
:
{
type
:
"
string
"
}
tail
:
{
type
:
"
string
"
}
tailPrefix
:
{
type
:
"
string
"
}
tailOffsetIndex
:
{
type
:
"
number
"
}
title
:
{
type
:
"
string
"
}
url
:
{
type
:
"
string
"
}
}
}
[
UrlbarUtils
.
RESULT_TYPE
.
URL
]
:
{
type
:
"
object
"
required
:
[
"
url
"
]
properties
:
{
displayUrl
:
{
type
:
"
string
"
}
helpL10nId
:
{
type
:
"
string
"
}
helpUrl
:
{
type
:
"
string
"
}
icon
:
{
type
:
"
string
"
}
isPinned
:
{
type
:
"
boolean
"
}
isSponsored
:
{
type
:
"
boolean
"
}
qsSuggestion
:
{
type
:
"
string
"
}
sendAttributionRequest
:
{
type
:
"
boolean
"
}
sponsoredAdvertiser
:
{
type
:
"
string
"
}
sponsoredBlockId
:
{
type
:
"
number
"
}
sponsoredClickUrl
:
{
type
:
"
string
"
}
sponsoredImpressionUrl
:
{
type
:
"
string
"
}
sponsoredTileId
:
{
type
:
"
number
"
}
tags
:
{
type
:
"
array
"
items
:
{
type
:
"
string
"
}
}
title
:
{
type
:
"
string
"
}
url
:
{
type
:
"
string
"
}
}
}
[
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
]
:
{
type
:
"
object
"
required
:
[
"
keyword
"
"
url
"
]
properties
:
{
displayUrl
:
{
type
:
"
string
"
}
icon
:
{
type
:
"
string
"
}
input
:
{
type
:
"
string
"
}
keyword
:
{
type
:
"
string
"
}
postData
:
{
type
:
"
string
"
}
title
:
{
type
:
"
string
"
}
url
:
{
type
:
"
string
"
}
}
}
[
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
]
:
{
type
:
"
object
"
required
:
[
"
keyword
"
]
properties
:
{
content
:
{
type
:
"
string
"
}
icon
:
{
type
:
"
string
"
}
keyword
:
{
type
:
"
string
"
}
title
:
{
type
:
"
string
"
}
}
}
[
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
]
:
{
type
:
"
object
"
required
:
[
"
device
"
"
url
"
"
lastUsed
"
]
properties
:
{
device
:
{
type
:
"
string
"
}
displayUrl
:
{
type
:
"
string
"
}
icon
:
{
type
:
"
string
"
}
lastUsed
:
{
type
:
"
number
"
}
title
:
{
type
:
"
string
"
}
url
:
{
type
:
"
string
"
}
}
}
[
UrlbarUtils
.
RESULT_TYPE
.
TIP
]
:
{
type
:
"
object
"
required
:
[
"
type
"
]
properties
:
{
buttonText
:
{
type
:
"
string
"
}
buttonTextData
:
{
type
:
"
object
"
required
:
[
"
id
"
]
properties
:
{
id
:
{
type
:
"
string
"
}
args
:
{
type
:
"
array
"
}
}
}
buttonUrl
:
{
type
:
"
string
"
}
helpUrl
:
{
type
:
"
string
"
}
icon
:
{
type
:
"
string
"
}
text
:
{
type
:
"
string
"
}
textData
:
{
type
:
"
object
"
required
:
[
"
id
"
]
properties
:
{
id
:
{
type
:
"
string
"
}
args
:
{
type
:
"
array
"
}
}
}
type
:
{
type
:
"
string
"
enum
:
[
"
extension
"
"
intervention_clear
"
"
intervention_refresh
"
"
intervention_update_ask
"
"
intervention_update_refresh
"
"
intervention_update_restart
"
"
intervention_update_web
"
"
searchTip_onboard
"
"
searchTip_redirect
"
"
test
"
]
}
}
}
[
UrlbarUtils
.
RESULT_TYPE
.
DYNAMIC
]
:
{
type
:
"
object
"
required
:
[
"
dynamicType
"
]
properties
:
{
dynamicType
:
{
type
:
"
string
"
}
shouldNavigate
:
{
type
:
"
boolean
"
}
}
}
}
;
class
UrlbarQueryContext
{
constructor
(
options
=
{
}
)
{
this
.
_checkRequiredOptions
(
options
[
"
allowAutofill
"
"
isPrivate
"
"
maxResults
"
"
searchString
"
]
)
;
if
(
isNaN
(
parseInt
(
options
.
maxResults
)
)
)
{
throw
new
Error
(
Invalid
maxResults
property
provided
to
UrlbarQueryContext
)
;
}
for
(
let
[
prop
checkFn
defaultValue
]
of
[
[
"
currentPage
"
v
=
>
typeof
v
=
=
"
string
"
&
&
!
!
v
.
length
]
[
"
formHistoryName
"
v
=
>
typeof
v
=
=
"
string
"
&
&
!
!
v
.
length
]
[
"
prohibitRemoteResults
"
v
=
>
true
false
]
[
"
providers
"
v
=
>
Array
.
isArray
(
v
)
&
&
v
.
length
]
[
"
searchMode
"
v
=
>
v
&
&
typeof
v
=
=
"
object
"
]
[
"
sources
"
v
=
>
Array
.
isArray
(
v
)
&
&
v
.
length
]
]
)
{
if
(
prop
in
options
)
{
if
(
!
checkFn
(
options
[
prop
]
)
)
{
throw
new
Error
(
Invalid
value
for
option
"
{
prop
}
"
)
;
}
this
[
prop
]
=
options
[
prop
]
;
}
else
if
(
defaultValue
!
=
=
undefined
)
{
this
[
prop
]
=
defaultValue
;
}
}
this
.
lastResultCount
=
0
;
this
.
pendingHeuristicProviders
=
new
Set
(
)
;
this
.
deferUserSelectionProviders
=
new
Set
(
)
;
this
.
trimmedSearchString
=
this
.
searchString
.
trim
(
)
;
this
.
userContextId
=
options
.
userContextId
|
|
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
}
_checkRequiredOptions
(
options
optionNames
)
{
for
(
let
optionName
of
optionNames
)
{
if
(
!
(
optionName
in
options
)
)
{
throw
new
Error
(
Missing
or
empty
{
optionName
}
provided
to
UrlbarQueryContext
)
;
}
this
[
optionName
]
=
options
[
optionName
]
;
}
}
get
fixupInfo
(
)
{
if
(
this
.
trimmedSearchString
&
&
!
this
.
_fixupInfo
)
{
let
flags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
|
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
if
(
this
.
isPrivate
)
{
flags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
try
{
let
info
=
Services
.
uriFixup
.
getFixupURIInfo
(
this
.
trimmedSearchString
flags
)
;
this
.
_fixupInfo
=
{
href
:
info
.
fixedURI
.
spec
isSearch
:
!
!
info
.
keywordAsSent
}
;
}
catch
(
ex
)
{
this
.
_fixupError
=
ex
.
result
;
}
}
return
this
.
_fixupInfo
|
|
null
;
}
get
fixupError
(
)
{
if
(
!
this
.
fixupInfo
)
{
return
this
.
_fixupError
;
}
return
null
;
}
allowRemoteResults
(
searchString
=
this
.
searchString
)
{
if
(
this
.
prohibitRemoteResults
)
{
return
false
;
}
if
(
searchString
.
length
<
2
)
{
return
false
;
}
if
(
this
.
tokens
.
length
=
=
1
&
&
this
.
tokens
[
0
]
.
type
=
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_ORIGIN
)
{
return
false
;
}
if
(
this
.
fixupInfo
?
.
href
&
&
!
this
.
fixupInfo
?
.
isSearch
)
{
return
false
;
}
return
true
;
}
}
class
UrlbarMuxer
{
get
name
(
)
{
return
"
UrlbarMuxerBase
"
;
}
sort
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
}
class
UrlbarProvider
{
constructor
(
)
{
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
UrlbarUtils
.
getLogger
(
{
prefix
:
Provider
.
{
this
.
name
}
}
)
)
;
}
get
name
(
)
{
return
"
UrlbarProviderBase
"
;
}
get
type
(
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
tryMethod
(
methodName
.
.
.
args
)
{
try
{
return
this
[
methodName
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
undefined
;
}
isActive
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
getPriority
(
queryContext
)
{
return
0
;
}
startQuery
(
queryContext
addCallback
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
cancelQuery
(
queryContext
)
{
}
pickResult
(
result
element
)
{
}
onEngagement
(
isPrivate
state
queryContext
details
)
{
}
onSelection
(
result
element
)
{
}
getViewUpdate
(
result
idsByName
)
{
return
null
;
}
get
deferUserSelection
(
)
{
return
false
;
}
}
class
SkippableTimer
{
constructor
(
{
name
=
"
<
anonymous
timer
>
"
callback
=
null
time
=
0
reportErrorOnTimeout
=
false
logger
=
null
}
=
{
}
)
{
this
.
name
=
name
;
this
.
logger
=
logger
;
let
timerPromise
=
new
Promise
(
resolve
=
>
{
this
.
_timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_timer
.
initWithCallback
(
(
)
=
>
{
this
.
_log
(
Timed
out
!
reportErrorOnTimeout
)
;
resolve
(
)
;
}
time
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
this
.
_log
(
Started
)
;
}
)
;
let
firePromise
=
new
Promise
(
resolve
=
>
{
this
.
fire
=
(
)
=
>
{
this
.
_log
(
Skipped
)
;
resolve
(
)
;
return
this
.
promise
;
}
;
}
)
;
this
.
promise
=
Promise
.
race
(
[
timerPromise
firePromise
]
)
.
then
(
(
)
=
>
{
if
(
this
.
_timer
&
&
callback
)
{
callback
(
)
;
}
}
)
;
}
cancel
(
)
{
this
.
_log
(
Canceling
)
;
this
.
_timer
.
cancel
(
)
;
delete
this
.
_timer
;
return
this
.
fire
(
)
;
}
_log
(
msg
isError
=
false
)
{
let
line
=
SkippableTimer
:
:
{
this
.
name
}
:
:
{
msg
}
;
if
(
this
.
logger
)
{
this
.
logger
.
debug
(
line
)
;
}
if
(
isError
)
{
Cu
.
reportError
(
line
)
;
}
}
}
class
L10nCache
{
constructor
(
l10n
)
{
this
.
l10n
=
Cu
.
getWeakReference
(
l10n
)
;
}
get
(
id
args
=
undefined
)
{
return
this
.
_messagesByKey
.
get
(
this
.
_key
(
id
args
)
)
;
}
async
add
(
id
args
=
undefined
)
{
let
l10n
=
this
.
l10n
.
get
(
)
;
if
(
!
l10n
)
{
return
;
}
let
messages
=
await
l10n
.
formatMessages
(
[
{
id
args
}
]
)
;
if
(
!
messages
?
.
length
)
{
Cu
.
reportError
(
"
l10n
.
formatMessages
returned
an
unexpected
value
for
ID
:
"
+
id
)
;
return
;
}
let
message
=
messages
[
0
]
;
if
(
message
.
attributes
)
{
message
.
attributes
=
message
.
attributes
.
reduce
(
(
valuesByName
{
name
value
}
)
=
>
{
valuesByName
[
name
]
=
value
;
return
valuesByName
;
}
{
}
)
;
}
this
.
_messagesByKey
.
set
(
this
.
_key
(
id
args
)
message
)
;
}
async
ensure
(
id
args
=
undefined
)
{
if
(
!
this
.
get
(
id
args
)
)
{
await
this
.
add
(
id
args
)
;
}
}
async
ensureAll
(
idArgs
)
{
let
promises
=
[
]
;
for
(
let
{
id
args
}
of
idArgs
)
{
promises
.
push
(
this
.
ensure
(
id
args
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
delete
(
id
args
=
undefined
)
{
this
.
_messagesByKey
.
delete
(
this
.
_key
(
id
args
)
)
;
}
clear
(
)
{
this
.
_messagesByKey
.
clear
(
)
;
}
_messagesByKey
=
new
Map
(
)
;
_key
(
id
args
)
{
let
argValues
=
Object
.
entries
(
args
|
|
[
]
)
.
sort
(
(
[
key1
]
[
key2
]
)
=
>
key1
.
localeCompare
(
key2
)
)
.
map
(
(
[
_
value
]
)
=
>
value
)
;
let
parts
=
[
id
]
.
concat
(
argValues
)
;
return
JSON
.
stringify
(
parts
)
;
}
}
