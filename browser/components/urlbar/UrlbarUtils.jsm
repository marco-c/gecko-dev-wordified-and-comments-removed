"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
QueryContext
"
"
UrlbarMuxer
"
"
UrlbarProvider
"
"
UrlbarUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BinarySearch
:
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
PlacesUIUtils
:
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
var
UrlbarUtils
=
{
INSERTMETHOD
:
{
APPEND
:
0
MERGE_RELATED
:
1
MERGE
:
2
}
MAXIMUM_ALLOWED_EXTENSION_MATCHES
:
6
MATCH_GROUP
:
{
HEURISTIC
:
"
heuristic
"
GENERAL
:
"
general
"
SUGGESTION
:
"
suggestion
"
EXTENSION
:
"
extension
"
}
PROVIDER_TYPE
:
{
IMMEDIATE
:
1
PROFILE
:
2
NETWORK
:
3
EXTENSION
:
4
}
MATCH_TYPE
:
{
TAB_SWITCH
:
1
SEARCH
:
2
URL
:
3
KEYWORD
:
4
OMNIBOX
:
5
REMOTE_TAB
:
6
}
MATCH_SOURCE
:
{
BOOKMARKS
:
1
HISTORY
:
2
SEARCH
:
3
TABS
:
4
OTHER_LOCAL
:
5
OTHER_NETWORK
:
6
}
addToUrlbarHistory
(
url
window
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
url
&
&
!
url
.
includes
(
"
"
)
&
&
!
/
[
\
x00
-
\
x1F
]
/
.
test
(
url
)
)
PlacesUIUtils
.
markPageAsTyped
(
url
)
;
}
async
getShortcutOrURIAndPostData
(
url
)
{
let
mayInheritPrincipal
=
false
;
let
postData
=
null
;
let
[
keyword
param
=
"
"
]
=
url
.
trim
(
)
.
split
(
/
\
s
(
.
+
)
/
2
)
;
if
(
!
keyword
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
let
engine
=
Services
.
search
.
getEngineByAlias
(
keyword
)
;
if
(
engine
)
{
let
submission
=
engine
.
getSubmission
(
param
null
"
keyword
"
)
;
return
{
url
:
submission
.
uri
.
spec
postData
:
submission
.
postData
mayInheritPrincipal
}
;
}
let
entry
=
null
;
try
{
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
keyword
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Unable
to
fetch
Places
keyword
"
{
keyword
}
"
:
{
ex
}
)
;
}
if
(
!
entry
|
|
!
entry
.
url
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
try
{
[
url
postData
]
=
await
BrowserUtils
.
parseUrlAndPostData
(
entry
.
url
.
href
entry
.
postData
param
)
;
if
(
postData
)
{
postData
=
this
.
getPostDataStream
(
postData
)
;
}
mayInheritPrincipal
=
true
;
}
catch
(
ex
)
{
}
return
{
url
postData
mayInheritPrincipal
}
;
}
getPostDataStream
(
postDataString
type
=
"
application
/
x
-
www
-
form
-
urlencoded
"
)
{
let
dataStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
dataStream
.
data
=
postDataString
;
let
mimeStream
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
mimeStream
.
addHeader
(
"
Content
-
Type
"
type
)
;
mimeStream
.
setData
(
dataStream
)
;
return
mimeStream
.
QueryInterface
(
Ci
.
nsIInputStream
)
;
}
getTokenMatches
(
tokens
str
)
{
return
tokens
.
reduce
(
(
matches
token
)
=
>
{
let
index
=
0
;
while
(
index
>
=
0
)
{
index
=
str
.
indexOf
(
token
.
value
index
)
;
if
(
index
>
=
0
)
{
let
match
=
[
index
token
.
value
.
length
]
;
let
matchesIndex
=
BinarySearch
.
insertionIndexOf
(
(
a
b
)
=
>
{
return
a
[
0
]
-
b
[
0
]
;
}
matches
match
)
;
matches
.
splice
(
matchesIndex
0
match
)
;
index
+
=
token
.
value
.
length
;
}
}
return
matches
;
}
[
]
)
;
}
}
;
class
QueryContext
{
constructor
(
options
=
{
}
)
{
this
.
_checkRequiredOptions
(
options
[
"
enableAutofill
"
"
isPrivate
"
"
lastKey
"
"
maxResults
"
"
searchString
"
]
)
;
if
(
isNaN
(
parseInt
(
options
.
maxResults
)
)
)
{
throw
new
Error
(
Invalid
maxResults
property
provided
to
QueryContext
)
;
}
if
(
options
.
providers
&
&
(
!
Array
.
isArray
(
options
.
providers
)
|
|
!
options
.
providers
.
length
)
)
{
throw
new
Error
(
Invalid
providers
list
)
;
}
if
(
options
.
sources
&
&
(
!
Array
.
isArray
(
options
.
sources
)
|
|
!
options
.
sources
.
length
)
)
{
throw
new
Error
(
Invalid
sources
list
)
;
}
}
_checkRequiredOptions
(
options
optionNames
)
{
for
(
let
optionName
of
optionNames
)
{
if
(
!
(
optionName
in
options
)
)
{
throw
new
Error
(
Missing
or
empty
{
optionName
}
provided
to
QueryContext
)
;
}
this
[
optionName
]
=
options
[
optionName
]
;
}
}
}
class
UrlbarMuxer
{
get
name
(
)
{
return
"
UrlbarMuxerBase
"
;
}
sort
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
}
class
UrlbarProvider
{
get
name
(
)
{
return
"
UrlbarProviderBase
"
;
}
get
type
(
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
get
sources
(
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
startQuery
(
queryContext
addCallback
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
cancelQuery
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
}
