"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxer
"
"
UrlbarProvider
"
"
UrlbarQueryContext
"
"
UrlbarUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
PlacesUIUtils
:
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
}
)
;
var
UrlbarUtils
=
{
INSERTMETHOD
:
{
APPEND
:
0
MERGE_RELATED
:
1
MERGE
:
2
}
MAXIMUM_ALLOWED_EXTENSION_MATCHES
:
6
RESULT_GROUP
:
{
HEURISTIC
:
"
heuristic
"
GENERAL
:
"
general
"
SUGGESTION
:
"
suggestion
"
EXTENSION
:
"
extension
"
}
PROVIDER_TYPE
:
{
IMMEDIATE
:
1
PROFILE
:
2
NETWORK
:
3
EXTENSION
:
4
}
RESULT_TYPE
:
{
TAB_SWITCH
:
1
SEARCH
:
2
URL
:
3
KEYWORD
:
4
OMNIBOX
:
5
REMOTE_TAB
:
6
}
RESULT_SOURCE
:
{
BOOKMARKS
:
1
HISTORY
:
2
SEARCH
:
3
TABS
:
4
OTHER_LOCAL
:
5
OTHER_NETWORK
:
6
}
ICON
:
{
DEFAULT
:
Ci
.
nsIFaviconService
.
FAVICON_DEFAULT_URL
SEARCH_GLASS
:
"
chrome
:
/
/
browser
/
skin
/
search
-
glass
.
svg
"
}
COMPOSITION
:
{
NONE
:
1
COMPOSING
:
2
COMMIT
:
3
}
CANCEL_REASON
:
{
BLUR
:
2
}
addToUrlbarHistory
(
url
window
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
url
&
&
!
url
.
includes
(
"
"
)
&
&
!
/
[
\
x00
-
\
x1F
]
/
.
test
(
url
)
)
PlacesUIUtils
.
markPageAsTyped
(
url
)
;
}
async
getShortcutOrURIAndPostData
(
url
)
{
let
mayInheritPrincipal
=
false
;
let
postData
=
null
;
let
[
keyword
param
=
"
"
]
=
url
.
trim
(
)
.
split
(
/
\
s
(
.
+
)
/
2
)
;
if
(
!
keyword
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
let
engine
=
Services
.
search
.
getEngineByAlias
(
keyword
)
;
if
(
engine
)
{
let
submission
=
engine
.
getSubmission
(
param
null
"
keyword
"
)
;
return
{
url
:
submission
.
uri
.
spec
postData
:
submission
.
postData
mayInheritPrincipal
}
;
}
let
entry
=
null
;
try
{
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
keyword
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Unable
to
fetch
Places
keyword
"
{
keyword
}
"
:
{
ex
}
)
;
}
if
(
!
entry
|
|
!
entry
.
url
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
try
{
[
url
postData
]
=
await
BrowserUtils
.
parseUrlAndPostData
(
entry
.
url
.
href
entry
.
postData
param
)
;
if
(
postData
)
{
postData
=
this
.
getPostDataStream
(
postData
)
;
}
mayInheritPrincipal
=
true
;
}
catch
(
ex
)
{
}
return
{
url
postData
mayInheritPrincipal
}
;
}
getPostDataStream
(
postDataString
type
=
"
application
/
x
-
www
-
form
-
urlencoded
"
)
{
let
dataStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
dataStream
.
data
=
postDataString
;
let
mimeStream
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
mimeStream
.
addHeader
(
"
Content
-
Type
"
type
)
;
mimeStream
.
setData
(
dataStream
)
;
return
mimeStream
.
QueryInterface
(
Ci
.
nsIInputStream
)
;
}
getTokenMatches
(
tokens
str
)
{
let
hits
=
new
Array
(
str
.
length
)
.
fill
(
0
)
;
for
(
let
token
of
tokens
)
{
for
(
let
index
=
0
needle
=
token
.
value
;
index
>
=
0
&
&
needle
;
)
{
index
=
str
.
indexOf
(
needle
index
)
;
if
(
index
>
=
0
)
{
hits
.
fill
(
1
index
index
+
needle
.
length
)
;
index
+
=
needle
.
length
;
}
}
}
let
ranges
=
[
]
;
for
(
let
index
=
hits
.
indexOf
(
1
)
;
index
>
=
0
&
&
index
<
hits
.
length
;
)
{
let
len
=
0
;
for
(
let
j
=
index
;
j
<
hits
.
length
&
&
hits
[
j
]
;
+
+
j
+
+
len
)
;
ranges
.
push
(
[
index
len
]
)
;
index
=
hits
.
indexOf
(
1
index
+
len
)
;
}
return
ranges
;
}
getUrlFromResult
(
result
)
{
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
return
{
url
:
result
.
payload
.
url
postData
:
null
}
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
return
{
url
:
result
.
payload
.
url
postData
:
result
.
payload
.
postData
?
this
.
getPostDataStream
(
result
.
payload
.
postData
)
:
null
}
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
{
const
engine
=
Services
.
search
.
getEngineByName
(
result
.
payload
.
engine
)
;
let
[
url
postData
]
=
this
.
getSearchQueryUrl
(
engine
result
.
payload
.
suggestion
|
|
result
.
payload
.
query
)
;
return
{
url
postData
}
;
}
}
return
{
url
:
null
postData
:
null
}
;
}
getSearchQueryUrl
(
engine
query
)
{
let
submission
=
engine
.
getSubmission
(
query
null
"
keyword
"
)
;
return
[
submission
.
uri
.
spec
submission
.
postData
]
;
}
setupSpeculativeConnection
(
urlOrEngine
window
)
{
if
(
!
UrlbarPrefs
.
get
(
"
speculativeConnect
.
enabled
"
)
)
{
return
;
}
if
(
urlOrEngine
instanceof
Ci
.
nsISearchEngine
)
{
try
{
urlOrEngine
.
speculativeConnect
(
{
window
originAttributes
:
window
.
gBrowser
.
contentPrincipal
.
originAttributes
}
)
;
}
catch
(
ex
)
{
}
return
;
}
if
(
urlOrEngine
instanceof
URL
)
{
urlOrEngine
=
urlOrEngine
.
href
;
}
try
{
let
uri
=
urlOrEngine
instanceof
Ci
.
nsIURI
?
urlOrEngine
:
Services
.
io
.
newURI
(
urlOrEngine
)
;
Services
.
io
.
speculativeConnect
(
uri
window
.
gBrowser
.
contentPrincipal
null
)
;
}
catch
(
ex
)
{
}
}
stripUnsafeProtocolOnPaste
(
pasteData
)
{
while
(
true
)
{
let
scheme
=
"
"
;
try
{
scheme
=
Services
.
io
.
extractScheme
(
pasteData
)
;
}
catch
(
ex
)
{
}
if
(
scheme
!
=
"
javascript
"
)
{
break
;
}
pasteData
=
pasteData
.
substring
(
pasteData
.
indexOf
(
"
:
"
)
+
1
)
;
}
return
pasteData
;
}
}
;
class
UrlbarQueryContext
{
constructor
(
options
=
{
}
)
{
this
.
_checkRequiredOptions
(
options
[
"
enableAutofill
"
"
isPrivate
"
"
lastKey
"
"
maxResults
"
"
searchString
"
]
)
;
if
(
isNaN
(
parseInt
(
options
.
maxResults
)
)
)
{
throw
new
Error
(
Invalid
maxResults
property
provided
to
UrlbarQueryContext
)
;
}
if
(
options
.
providers
&
&
(
!
Array
.
isArray
(
options
.
providers
)
|
|
!
options
.
providers
.
length
)
)
{
throw
new
Error
(
Invalid
providers
list
)
;
}
if
(
options
.
sources
&
&
(
!
Array
.
isArray
(
options
.
sources
)
|
|
!
options
.
sources
.
length
)
)
{
throw
new
Error
(
Invalid
sources
list
)
;
}
}
_checkRequiredOptions
(
options
optionNames
)
{
for
(
let
optionName
of
optionNames
)
{
if
(
!
(
optionName
in
options
)
)
{
throw
new
Error
(
Missing
or
empty
{
optionName
}
provided
to
UrlbarQueryContext
)
;
}
this
[
optionName
]
=
options
[
optionName
]
;
}
}
}
class
UrlbarMuxer
{
get
name
(
)
{
return
"
UrlbarMuxerBase
"
;
}
sort
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
}
class
UrlbarProvider
{
get
name
(
)
{
return
"
UrlbarProviderBase
"
;
}
get
type
(
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
get
sources
(
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
startQuery
(
queryContext
addCallback
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
cancelQuery
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
}
