"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarMuxer
"
"
UrlbarProvider
"
"
UrlbarQueryContext
"
"
UrlbarUtils
"
"
SkippableTimer
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
PlacesUIUtils
:
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
}
)
;
var
UrlbarUtils
=
{
INSERTMETHOD
:
{
APPEND
:
0
MERGE_RELATED
:
1
MERGE
:
2
}
MAXIMUM_ALLOWED_EXTENSION_MATCHES
:
6
RESULT_GROUP
:
{
HEURISTIC
:
"
heuristic
"
GENERAL
:
"
general
"
SUGGESTION
:
"
suggestion
"
EXTENSION
:
"
extension
"
}
PROVIDER_TYPE
:
{
IMMEDIATE
:
1
PROFILE
:
2
NETWORK
:
3
EXTENSION
:
4
}
RESULT_TYPE
:
{
TAB_SWITCH
:
1
SEARCH
:
2
URL
:
3
KEYWORD
:
4
OMNIBOX
:
5
REMOTE_TAB
:
6
TIP
:
7
}
RESULT_SOURCE
:
{
BOOKMARKS
:
1
HISTORY
:
2
SEARCH
:
3
TABS
:
4
OTHER_LOCAL
:
5
OTHER_NETWORK
:
6
}
ICON
:
{
SEARCH_GLASS
:
"
chrome
:
/
/
browser
/
skin
/
search
-
glass
.
svg
"
TIP
:
"
chrome
:
/
/
browser
/
skin
/
tip
.
svg
"
}
PAGE_UP_DOWN_DELTA
:
5
COMPOSITION
:
{
NONE
:
1
COMPOSING
:
2
COMMIT
:
3
CANCELED
:
4
}
MAX_TEXT_LENGTH
:
255
HIGHLIGHT
:
{
TYPED
:
1
SUGGESTED
:
2
}
KEYWORD_OFFER
:
{
NONE
:
0
SHOW
:
1
HIDE
:
2
}
TITLE_TAGS_SEPARATOR
:
"
\
x1F
"
REGEXP_SINGLE_WORD
:
/
^
[
^
\
s
.
?
:
/
]
+
\
.
?
/
addToUrlbarHistory
(
url
window
)
{
if
(
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
url
&
&
!
url
.
includes
(
"
"
)
&
&
!
/
[
\
x00
-
\
x1F
]
/
.
test
(
url
)
)
{
PlacesUIUtils
.
markPageAsTyped
(
url
)
;
}
}
async
getShortcutOrURIAndPostData
(
url
)
{
let
mayInheritPrincipal
=
false
;
let
postData
=
null
;
let
[
keyword
param
=
"
"
]
=
url
.
trim
(
)
.
split
(
/
\
s
(
.
+
)
/
2
)
;
if
(
!
keyword
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
await
Services
.
search
.
init
(
)
;
let
engine
=
Services
.
search
.
getEngineByAlias
(
keyword
)
;
if
(
engine
)
{
let
submission
=
engine
.
getSubmission
(
param
null
"
keyword
"
)
;
return
{
url
:
submission
.
uri
.
spec
postData
:
submission
.
postData
mayInheritPrincipal
}
;
}
let
entry
=
null
;
try
{
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
keyword
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Unable
to
fetch
Places
keyword
"
{
keyword
}
"
:
{
ex
}
)
;
}
if
(
!
entry
|
|
!
entry
.
url
)
{
return
{
url
postData
mayInheritPrincipal
}
;
}
try
{
[
url
postData
]
=
await
BrowserUtils
.
parseUrlAndPostData
(
entry
.
url
.
href
entry
.
postData
param
)
;
if
(
postData
)
{
postData
=
this
.
getPostDataStream
(
postData
)
;
}
mayInheritPrincipal
=
true
;
}
catch
(
ex
)
{
}
return
{
url
postData
mayInheritPrincipal
}
;
}
getPostDataStream
(
postDataString
type
=
"
application
/
x
-
www
-
form
-
urlencoded
"
)
{
let
dataStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
dataStream
.
data
=
postDataString
;
let
mimeStream
=
Cc
[
"
mozilla
.
org
/
network
/
mime
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIMIMEInputStream
)
;
mimeStream
.
addHeader
(
"
Content
-
Type
"
type
)
;
mimeStream
.
setData
(
dataStream
)
;
return
mimeStream
.
QueryInterface
(
Ci
.
nsIInputStream
)
;
}
getTokenMatches
(
tokens
str
highlightType
)
{
str
=
str
.
toLocaleLowerCase
(
)
;
let
hits
=
new
Array
(
str
.
length
)
.
fill
(
highlightType
=
=
this
.
HIGHLIGHT
.
SUGGESTED
?
1
:
0
)
;
for
(
let
{
lowerCaseValue
}
of
tokens
)
{
for
(
let
index
=
0
needle
=
lowerCaseValue
;
index
>
=
0
&
&
needle
;
)
{
index
=
str
.
indexOf
(
needle
index
)
;
if
(
index
>
=
0
)
{
hits
.
fill
(
highlightType
=
=
this
.
HIGHLIGHT
.
SUGGESTED
?
0
:
1
index
index
+
needle
.
length
)
;
index
+
=
needle
.
length
;
}
}
}
let
ranges
=
[
]
;
for
(
let
index
=
hits
.
indexOf
(
1
)
;
index
>
=
0
&
&
index
<
hits
.
length
;
)
{
let
len
=
0
;
for
(
let
j
=
index
;
j
<
hits
.
length
&
&
hits
[
j
]
;
+
+
j
+
+
len
)
{
}
ranges
.
push
(
[
index
len
]
)
;
index
=
hits
.
indexOf
(
1
index
+
len
)
;
}
return
ranges
;
}
getUrlFromResult
(
result
)
{
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
return
{
url
:
result
.
payload
.
url
postData
:
null
}
;
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
return
{
url
:
result
.
payload
.
url
postData
:
result
.
payload
.
postData
?
this
.
getPostDataStream
(
result
.
payload
.
postData
)
:
null
}
;
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
{
const
engine
=
Services
.
search
.
getEngineByName
(
result
.
payload
.
engine
)
;
let
[
url
postData
]
=
this
.
getSearchQueryUrl
(
engine
result
.
payload
.
suggestion
|
|
result
.
payload
.
query
)
;
return
{
url
postData
}
;
}
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
{
return
{
url
:
result
.
payload
.
buttonUrl
postData
:
null
}
;
}
}
return
{
url
:
null
postData
:
null
}
;
}
getSearchQueryUrl
(
engine
query
)
{
let
submission
=
engine
.
getSubmission
(
query
null
"
keyword
"
)
;
return
[
submission
.
uri
.
spec
submission
.
postData
]
;
}
getSpanForResult
(
result
)
{
switch
(
result
.
type
)
{
case
UrlbarUtils
.
RESULT_TYPE
.
URL
:
case
UrlbarUtils
.
RESULT_TYPE
.
BOOKMARKS
:
case
UrlbarUtils
.
RESULT_TYPE
.
REMOTE_TAB
:
case
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
:
case
UrlbarUtils
.
RESULT_TYPE
.
KEYWORD
:
case
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
:
case
UrlbarUtils
.
RESULT_TYPE
.
OMNIBOX
:
return
1
;
case
UrlbarUtils
.
RESULT_TYPE
.
TIP
:
return
3
;
}
return
1
;
}
setupSpeculativeConnection
(
urlOrEngine
window
)
{
if
(
!
UrlbarPrefs
.
get
(
"
speculativeConnect
.
enabled
"
)
)
{
return
;
}
if
(
urlOrEngine
instanceof
Ci
.
nsISearchEngine
)
{
try
{
urlOrEngine
.
speculativeConnect
(
{
window
originAttributes
:
window
.
gBrowser
.
contentPrincipal
.
originAttributes
}
)
;
}
catch
(
ex
)
{
}
return
;
}
if
(
urlOrEngine
instanceof
URL
)
{
urlOrEngine
=
urlOrEngine
.
href
;
}
try
{
let
uri
=
urlOrEngine
instanceof
Ci
.
nsIURI
?
urlOrEngine
:
Services
.
io
.
newURI
(
urlOrEngine
)
;
Services
.
io
.
speculativeConnect
(
uri
window
.
gBrowser
.
contentPrincipal
null
)
;
}
catch
(
ex
)
{
}
}
stripUnsafeProtocolOnPaste
(
pasteData
)
{
while
(
true
)
{
let
scheme
=
"
"
;
try
{
scheme
=
Services
.
io
.
extractScheme
(
pasteData
)
;
}
catch
(
ex
)
{
}
if
(
scheme
!
=
"
javascript
"
)
{
break
;
}
pasteData
=
pasteData
.
substring
(
pasteData
.
indexOf
(
"
:
"
)
+
1
)
;
}
return
pasteData
;
}
async
addToInputHistory
(
url
input
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
addToInputHistory
"
db
=
>
{
return
db
.
executeCached
(
INSERT
OR
REPLACE
INTO
moz_inputhistory
SELECT
h
.
id
IFNULL
(
i
.
input
:
input
)
IFNULL
(
i
.
use_count
0
)
*
.
9
+
1
FROM
moz_places
h
LEFT
JOIN
moz_inputhistory
i
ON
i
.
place_id
=
h
.
id
AND
i
.
input
=
:
input
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
{
url
input
}
)
;
}
)
;
}
isPasteEvent
(
event
)
{
return
(
event
.
inputType
&
&
(
event
.
inputType
.
startsWith
(
"
insertFromPaste
"
)
|
|
event
.
inputType
=
=
"
insertFromYank
"
)
)
;
}
looksLikeSingleWordHost
(
value
)
{
let
str
=
value
.
trim
(
)
;
return
this
.
REGEXP_SINGLE_WORD
.
test
(
str
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
UrlbarUtils
.
ICON
"
DEFAULT
"
(
)
=
>
{
return
PlacesUtils
.
favicons
.
defaultFavicon
.
spec
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
UrlbarUtils
"
strings
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
autocomplete
.
properties
"
)
;
}
)
;
class
UrlbarQueryContext
{
constructor
(
options
=
{
}
)
{
this
.
_checkRequiredOptions
(
options
[
"
allowAutofill
"
"
isPrivate
"
"
maxResults
"
"
searchString
"
]
)
;
if
(
isNaN
(
parseInt
(
options
.
maxResults
)
)
)
{
throw
new
Error
(
Invalid
maxResults
property
provided
to
UrlbarQueryContext
)
;
}
if
(
options
.
providers
&
&
(
!
Array
.
isArray
(
options
.
providers
)
|
|
!
options
.
providers
.
length
)
)
{
throw
new
Error
(
Invalid
providers
list
)
;
}
if
(
options
.
sources
&
&
(
!
Array
.
isArray
(
options
.
sources
)
|
|
!
options
.
sources
.
length
)
)
{
throw
new
Error
(
Invalid
sources
list
)
;
}
this
.
lastResultCount
=
0
;
this
.
userContextId
=
options
.
userContextId
;
}
_checkRequiredOptions
(
options
optionNames
)
{
for
(
let
optionName
of
optionNames
)
{
if
(
!
(
optionName
in
options
)
)
{
throw
new
Error
(
Missing
or
empty
{
optionName
}
provided
to
UrlbarQueryContext
)
;
}
this
[
optionName
]
=
options
[
optionName
]
;
}
}
}
class
UrlbarMuxer
{
get
name
(
)
{
return
"
UrlbarMuxerBase
"
;
}
sort
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
}
class
UrlbarProvider
{
get
name
(
)
{
return
"
UrlbarProviderBase
"
;
}
get
type
(
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
isActive
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
isRestricting
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
startQuery
(
queryContext
addCallback
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
cancelQuery
(
queryContext
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
pickResult
(
result
)
{
throw
new
Error
(
"
Trying
to
access
the
base
class
must
be
overridden
"
)
;
}
onEngagement
(
isPrivate
state
)
{
}
}
class
SkippableTimer
{
constructor
(
{
name
=
"
<
anonymous
timer
>
"
callback
=
null
time
=
0
reportErrorOnTimeout
=
false
logger
=
null
}
=
{
}
)
{
this
.
name
=
name
;
this
.
logger
=
logger
;
let
timerPromise
=
new
Promise
(
resolve
=
>
{
this
.
_timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_timer
.
initWithCallback
(
(
)
=
>
{
this
.
_log
(
Timed
out
!
reportErrorOnTimeout
)
;
resolve
(
)
;
}
time
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
this
.
_log
(
Started
)
;
}
)
;
let
firePromise
=
new
Promise
(
resolve
=
>
{
this
.
fire
=
(
)
=
>
{
this
.
_log
(
Skipped
)
;
resolve
(
)
;
return
this
.
promise
;
}
;
}
)
;
this
.
promise
=
Promise
.
race
(
[
timerPromise
firePromise
]
)
.
then
(
(
)
=
>
{
if
(
this
.
_timer
&
&
callback
)
{
callback
(
)
;
}
}
)
;
}
cancel
(
)
{
this
.
_log
(
Canceling
)
;
this
.
_timer
.
cancel
(
)
;
delete
this
.
_timer
;
return
this
.
fire
(
)
;
}
_log
(
msg
isError
=
false
)
{
let
line
=
SkippableTimer
:
:
{
this
.
name
}
:
:
{
msg
}
;
if
(
this
.
logger
)
{
this
.
logger
.
debug
(
line
)
;
}
if
(
isError
)
{
Cu
.
reportError
(
line
)
;
}
}
}
