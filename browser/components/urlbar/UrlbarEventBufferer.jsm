"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarEventBufferer
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
repository
.
getLogger
(
"
Urlbar
.
EventBufferer
"
)
)
;
const
DEFERRING_TIMEOUT_MS
=
200
;
const
DEFERRED_KEY_CODES
=
new
Set
(
[
KeyboardEvent
.
DOM_VK_RETURN
KeyboardEvent
.
DOM_VK_DOWN
KeyboardEvent
.
DOM_VK_TAB
]
)
;
const
QUERY_STATUS
=
{
UKNOWN
:
0
RUNNING
:
1
COMPLETE
:
2
}
;
class
UrlbarEventBufferer
{
constructor
(
input
)
{
this
.
input
=
input
;
this
.
input
.
inputField
.
addEventListener
(
"
blur
"
this
)
;
this
.
_eventsQueue
=
[
]
;
this
.
_deferringTimeout
=
null
;
this
.
_lastQuery
=
{
startDate
:
null
status
:
QUERY_STATUS
.
UKNOWN
searchString
:
"
"
results
:
[
]
}
;
this
.
input
.
controller
.
addQueryListener
(
this
)
;
}
onQueryStarted
(
queryContext
)
{
this
.
_lastQuery
=
{
startDate
:
Cu
.
now
(
)
status
:
QUERY_STATUS
.
RUNNING
searchString
:
queryContext
.
searchString
results
:
[
]
}
;
if
(
this
.
_deferringTimeout
)
{
clearTimeout
(
this
.
_deferringTimeout
)
;
this
.
_deferringTimeout
=
null
;
}
}
onQueryCancelled
(
queryContext
)
{
this
.
_lastQuery
.
status
=
QUERY_STATUS
.
COMPLETE
;
}
onQueryFinished
(
queryContext
)
{
this
.
_lastQuery
.
status
=
QUERY_STATUS
.
COMPLETE
;
}
onQueryResults
(
queryContext
)
{
this
.
_lastQuery
.
results
=
queryContext
.
results
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
replayDeferredEvents
(
true
)
;
}
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
blur
"
)
{
logger
.
debug
(
"
Clearing
queue
on
blur
"
)
;
this
.
_eventsQueue
.
length
=
0
;
if
(
this
.
_deferringTimeout
)
{
clearTimeout
(
this
.
_deferringTimeout
)
;
this
.
_deferringTimeout
=
null
;
}
}
}
maybeDeferEvent
(
event
callback
)
{
if
(
!
callback
)
{
throw
new
Error
(
"
Must
provide
a
callback
"
)
;
}
if
(
this
.
shouldDeferEvent
(
event
)
)
{
this
.
deferEvent
(
event
callback
)
;
return
;
}
callback
(
)
;
}
deferEvent
(
event
callback
)
{
if
(
event
.
urlbarDeferred
)
{
throw
new
Error
(
Event
{
event
.
type
}
:
{
event
.
keyCode
}
already
deferred
!
)
;
}
logger
.
debug
(
Deferring
{
event
.
type
}
:
{
event
.
keyCode
}
event
)
;
event
.
urlbarDeferred
=
true
;
event
.
searchString
=
this
.
_lastQuery
.
searchString
;
this
.
_eventsQueue
.
push
(
{
event
callback
}
)
;
if
(
!
this
.
_deferringTimeout
)
{
let
elapsed
=
Cu
.
now
(
)
-
this
.
_lastQuery
.
startDate
;
let
remaining
=
DEFERRING_TIMEOUT_MS
-
elapsed
;
this
.
_deferringTimeout
=
setTimeout
(
(
)
=
>
{
this
.
replayDeferredEvents
(
false
)
;
this
.
_deferringTimeout
=
null
;
}
Math
.
max
(
0
remaining
)
)
;
}
}
replayDeferredEvents
(
onlyIfSafe
)
{
if
(
typeof
onlyIfSafe
!
=
"
boolean
"
)
{
throw
new
Error
(
"
Must
provide
a
boolean
argument
"
)
;
}
if
(
!
this
.
_eventsQueue
.
length
)
{
return
;
}
let
{
event
callback
}
=
this
.
_eventsQueue
[
0
]
;
if
(
onlyIfSafe
&
&
!
this
.
isSafeToPlayDeferredEvent
(
event
)
)
{
return
;
}
this
.
_eventsQueue
.
shift
(
)
;
if
(
event
.
searchString
=
=
this
.
_lastQuery
.
searchString
)
{
callback
(
)
;
}
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
replayDeferredEvents
(
onlyIfSafe
)
;
}
)
;
}
shouldDeferEvent
(
event
)
{
if
(
this
.
_eventsQueue
.
length
>
0
)
{
return
true
;
}
let
isMacNavigation
=
AppConstants
.
platform
=
=
"
macosx
"
&
&
event
.
ctrlKey
&
&
this
.
input
.
view
.
isOpen
&
&
(
event
.
key
=
=
=
"
n
"
|
|
event
.
key
=
=
=
"
p
"
)
;
if
(
!
DEFERRED_KEY_CODES
.
has
(
event
.
keyCode
)
&
&
!
isMacNavigation
)
{
return
false
;
}
if
(
DEFERRED_KEY_CODES
.
has
(
event
.
keyCode
)
&
&
this
.
input
.
controller
.
keyEventMovesCaret
(
event
)
)
{
return
false
;
}
if
(
this
.
_lastQuery
.
startDate
+
DEFERRING_TIMEOUT_MS
<
=
Cu
.
now
(
)
)
{
return
false
;
}
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_TAB
&
&
!
this
.
input
.
view
.
isOpen
)
{
return
false
;
}
return
!
this
.
isSafeToPlayDeferredEvent
(
event
)
;
}
isSafeToPlayDeferredEvent
(
event
)
{
let
waitingFirstResult
=
this
.
_lastQuery
.
status
=
=
QUERY_STATUS
.
RUNNING
&
&
!
this
.
_lastQuery
.
results
.
length
;
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_RETURN
)
{
let
selectedResult
=
this
.
input
.
view
.
selectedResult
;
return
(
(
selectedResult
&
&
!
selectedResult
.
heuristic
)
|
|
!
waitingFirstResult
)
;
}
if
(
waitingFirstResult
|
|
!
this
.
input
.
view
.
isOpen
)
{
return
false
;
}
if
(
this
.
_lastQuery
.
status
=
=
QUERY_STATUS
.
COMPLETE
)
{
return
true
;
}
let
isMacDownNavigation
=
AppConstants
.
platform
=
=
"
macosx
"
&
&
event
.
ctrlKey
&
&
this
.
input
.
view
.
isOpen
&
&
event
.
key
=
=
=
"
n
"
;
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_DOWN
|
|
isMacDownNavigation
)
{
return
!
this
.
lastResultIsSelected
;
}
return
true
;
}
get
lastResultIsSelected
(
)
{
let
results
=
this
.
_lastQuery
.
results
;
return
(
results
.
length
&
&
results
[
results
.
length
-
1
]
=
=
this
.
input
.
view
.
selectedResult
)
;
}
}
