"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UrlbarProviderPlaces
"
]
;
const
QUERYTYPE_FILTERED
=
0
;
const
FRECENCY_DEFAULT
=
1000
;
const
NOTIFYRESULT_DELAY_MS
=
16
;
const
QUERYINDEX_QUERYTYPE
=
0
;
const
QUERYINDEX_URL
=
1
;
const
QUERYINDEX_TITLE
=
2
;
const
QUERYINDEX_BOOKMARKED
=
3
;
const
QUERYINDEX_BOOKMARKTITLE
=
4
;
const
QUERYINDEX_TAGS
=
5
;
const
QUERYINDEX_PLACEID
=
8
;
const
QUERYINDEX_SWITCHTAB
=
9
;
const
QUERYINDEX_FRECENCY
=
10
;
const
SQL_BOOKMARK_TAGS_FRAGMENT
=
EXISTS
(
SELECT
1
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
)
AS
bookmarked
(
SELECT
title
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
AND
title
NOTNULL
ORDER
BY
lastModified
DESC
LIMIT
1
)
AS
btitle
(
SELECT
GROUP_CONCAT
(
t
.
title
'
'
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
+
b
.
parent
AND
t
.
parent
=
:
parent
WHERE
b
.
fk
=
h
.
id
)
AS
tags
;
function
defaultQuery
(
conditions
=
"
"
)
{
let
query
=
SELECT
:
query_type
h
.
url
h
.
title
{
SQL_BOOKMARK_TAGS_FRAGMENT
}
h
.
visit_count
h
.
typed
h
.
id
t
.
open_count
h
.
frecency
FROM
moz_places
h
LEFT
JOIN
moz_openpages_temp
t
ON
t
.
url
=
h
.
url
AND
t
.
userContextId
=
:
userContextId
WHERE
h
.
frecency
<
>
0
AND
CASE
WHEN
bookmarked
THEN
AUTOCOMPLETE_MATCH
(
:
searchString
h
.
url
IFNULL
(
btitle
h
.
title
)
tags
h
.
visit_count
h
.
typed
1
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ELSE
AUTOCOMPLETE_MATCH
(
:
searchString
h
.
url
h
.
title
'
'
h
.
visit_count
h
.
typed
0
t
.
open_count
:
matchBehavior
:
searchBehavior
)
END
{
conditions
?
"
AND
"
:
"
"
}
{
conditions
}
ORDER
BY
h
.
frecency
DESC
h
.
id
DESC
LIMIT
:
maxResults
;
return
query
;
}
const
SQL_SWITCHTAB_QUERY
=
SELECT
:
query_type
t
.
url
t
.
url
NULL
NULL
NULL
NULL
NULL
NULL
t
.
open_count
NULL
FROM
moz_openpages_temp
t
LEFT
JOIN
moz_places
h
ON
h
.
url_hash
=
hash
(
t
.
url
)
AND
h
.
url
=
t
.
url
WHERE
h
.
id
IS
NULL
AND
t
.
userContextId
=
:
userContextId
AND
AUTOCOMPLETE_MATCH
(
:
searchString
t
.
url
t
.
url
NULL
NULL
NULL
NULL
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ORDER
BY
t
.
ROWID
DESC
LIMIT
:
maxResults
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
KeywordUtils
:
"
resource
:
/
/
gre
/
modules
/
KeywordUtils
.
jsm
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProvider
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
UrlbarProviderOpenTabs
:
"
resource
:
/
/
/
modules
/
UrlbarProviderOpenTabs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarResult
:
"
resource
:
/
/
/
modules
/
UrlbarResult
.
jsm
"
UrlbarSearchUtils
:
"
resource
:
/
/
/
modules
/
UrlbarSearchUtils
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
function
setTimeout
(
callback
ms
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
callback
ms
timer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
typeToBehaviorMap
"
(
)
=
>
{
return
new
Map
(
[
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
"
history
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
"
bookmark
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
"
tag
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
"
openpage
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
"
search
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_TITLE
"
title
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_URL
"
url
"
]
]
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
sourceToBehaviorMap
"
(
)
=
>
{
return
new
Map
(
[
[
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
"
history
"
]
[
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
"
bookmark
"
]
[
UrlbarUtils
.
RESULT_SOURCE
.
TABS
"
openpage
"
]
[
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
"
search
"
]
]
)
;
}
)
;
function
makeKeyForMatch
(
match
)
{
let
key
prefix
;
let
action
=
PlacesUtils
.
parseActionUrl
(
match
.
value
)
;
if
(
!
action
)
{
[
key
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
match
.
value
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimSlash
:
true
trimEmptyQuery
:
true
trimEmptyHash
:
true
}
)
;
return
[
key
prefix
null
]
;
}
switch
(
action
.
type
)
{
case
"
searchengine
"
:
key
=
[
action
.
type
action
.
params
.
engineName
(
action
.
params
.
searchSuggestion
|
|
action
.
params
.
searchQuery
)
.
toLocaleLowerCase
(
)
]
;
break
;
default
:
[
key
prefix
]
=
UrlbarUtils
.
stripPrefixAndTrim
(
action
.
params
.
url
|
|
match
.
value
{
stripHttp
:
true
stripHttps
:
true
stripWww
:
true
trimEmptyQuery
:
true
trimSlash
:
true
}
)
;
break
;
}
return
[
key
prefix
action
]
;
}
function
makeActionUrl
(
type
params
)
{
let
encodedParams
=
{
}
;
for
(
let
key
in
params
)
{
if
(
params
[
key
]
=
=
=
null
|
|
params
[
key
]
=
=
=
undefined
)
{
continue
;
}
encodedParams
[
key
]
=
encodeURIComponent
(
params
[
key
]
)
;
}
return
moz
-
action
:
{
type
}
{
JSON
.
stringify
(
encodedParams
)
}
;
}
function
convertLegacyMatches
(
context
matches
urls
)
{
let
results
=
[
]
;
for
(
let
match
of
matches
)
{
let
url
=
match
.
finalCompleteValue
|
|
match
.
value
;
if
(
urls
.
has
(
url
)
)
{
continue
;
}
urls
.
add
(
url
)
;
let
result
=
makeUrlbarResult
(
context
.
tokens
{
url
icon
:
match
.
icon
|
|
undefined
style
:
match
.
style
comment
:
match
.
comment
firstToken
:
context
.
tokens
[
0
]
}
)
;
if
(
!
result
)
{
continue
;
}
results
.
push
(
result
)
;
}
return
results
;
}
function
makeUrlbarResult
(
tokens
info
)
{
let
action
=
PlacesUtils
.
parseActionUrl
(
info
.
url
)
;
if
(
action
)
{
switch
(
action
.
type
)
{
case
"
searchengine
"
:
{
if
(
action
.
params
.
isSearchHistory
)
{
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
engine
:
action
.
params
.
engineName
suggestion
:
[
action
.
params
.
searchSuggestion
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
lowerCaseSuggestion
:
action
.
params
.
searchSuggestion
.
toLocaleLowerCase
(
)
}
)
)
;
}
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
SEARCH
UrlbarUtils
.
RESULT_SOURCE
.
SEARCH
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
engine
:
[
action
.
params
.
engineName
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
suggestion
:
[
action
.
params
.
searchSuggestion
UrlbarUtils
.
HIGHLIGHT
.
SUGGESTED
]
lowerCaseSuggestion
:
action
.
params
.
searchSuggestion
?
.
toLocaleLowerCase
(
)
keyword
:
action
.
params
.
alias
query
:
[
action
.
params
.
searchQuery
.
trim
(
)
UrlbarUtils
.
HIGHLIGHT
.
NONE
]
icon
:
info
.
icon
}
)
)
;
}
case
"
switchtab
"
:
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
TAB_SWITCH
UrlbarUtils
.
RESULT_SOURCE
.
TABS
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
url
:
[
action
.
params
.
url
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
title
:
[
info
.
comment
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
info
.
icon
}
)
)
;
case
"
visiturl
"
:
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
UrlbarUtils
.
RESULT_SOURCE
.
OTHER_LOCAL
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
title
:
[
info
.
comment
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
url
:
[
action
.
params
.
url
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
info
.
icon
}
)
)
;
default
:
Cu
.
reportError
(
Unexpected
action
type
:
{
action
.
type
}
)
;
return
null
;
}
}
let
source
;
let
tags
=
[
]
;
let
comment
=
info
.
comment
;
if
(
info
.
style
.
includes
(
"
bookmark
"
)
)
{
source
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
;
}
else
{
source
=
UrlbarUtils
.
RESULT_SOURCE
.
HISTORY
;
}
if
(
info
.
style
.
includes
(
"
tag
"
)
)
{
[
comment
tags
]
=
info
.
comment
.
split
(
UrlbarUtils
.
TITLE_TAGS_SEPARATOR
)
;
if
(
source
!
=
UrlbarUtils
.
RESULT_SOURCE
.
BOOKMARKS
)
{
tags
=
"
"
;
}
tags
=
tags
.
split
(
"
"
)
.
map
(
t
=
>
t
.
trim
(
)
)
.
filter
(
tag
=
>
{
let
lowerCaseTag
=
tag
.
toLocaleLowerCase
(
)
;
return
tokens
.
some
(
token
=
>
lowerCaseTag
.
includes
(
token
.
lowerCaseValue
)
)
;
}
)
.
sort
(
)
;
}
return
new
UrlbarResult
(
UrlbarUtils
.
RESULT_TYPE
.
URL
source
.
.
.
UrlbarResult
.
payloadAndSimpleHighlights
(
tokens
{
url
:
[
info
.
url
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
icon
:
info
.
icon
title
:
[
comment
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
tags
:
[
tags
UrlbarUtils
.
HIGHLIGHT
.
TYPED
]
}
)
)
;
}
const
MATCH_TYPE
=
{
HEURISTIC
:
"
heuristic
"
GENERAL
:
"
general
"
SUGGESTION
:
"
suggestion
"
EXTENSION
:
"
extension
"
}
;
function
Search
(
queryContext
listener
provider
)
{
this
.
_originalSearchString
=
queryContext
.
searchString
;
this
.
_trimmedOriginalSearchString
=
queryContext
.
trimmedSearchString
;
let
unescapedSearchString
=
UrlbarUtils
.
unEscapeURIForUI
(
this
.
_trimmedOriginalSearchString
)
;
let
[
prefix
suffix
]
=
UrlbarUtils
.
stripURLPrefix
(
unescapedSearchString
)
;
this
.
_searchString
=
suffix
;
this
.
_strippedPrefix
=
prefix
.
toLowerCase
(
)
;
this
.
_matchBehavior
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_BOUNDARY
;
this
.
_behavior
=
this
.
_searchString
?
UrlbarPrefs
.
get
(
"
defaultBehavior
"
)
:
this
.
_emptySearchDefaultBehavior
;
this
.
_inPrivateWindow
=
queryContext
.
isPrivate
;
this
.
_prohibitAutoFill
=
!
queryContext
.
allowAutofill
;
this
.
_maxResults
=
queryContext
.
maxResults
;
this
.
_userContextId
=
queryContext
.
userContextId
;
this
.
_currentPage
=
queryContext
.
currentPage
;
this
.
_searchModeEngine
=
queryContext
.
searchMode
?
.
engineName
;
this
.
_searchMode
=
queryContext
.
searchMode
;
if
(
this
.
_searchModeEngine
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
this
.
_searchModeEngine
)
;
this
.
_filterOnHost
=
engine
.
getResultDomain
(
)
;
}
this
.
_userContextId
=
UrlbarProviderOpenTabs
.
getUserContextIdForOpenPagesTable
(
this
.
_userContextId
this
.
_inPrivateWindow
)
;
let
{
tokens
}
=
UrlbarTokenizer
.
tokenize
(
{
searchString
:
unescapedSearchString
trimmedSearchString
:
unescapedSearchString
.
trim
(
)
}
)
;
this
.
_leadingRestrictionToken
=
null
;
if
(
tokens
.
length
)
{
if
(
UrlbarTokenizer
.
isRestrictionToken
(
tokens
[
0
]
)
&
&
(
tokens
.
length
>
1
|
|
tokens
[
0
]
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
)
)
{
this
.
_leadingRestrictionToken
=
tokens
[
0
]
.
value
;
}
if
(
prefix
&
&
tokens
[
0
]
.
value
.
length
>
prefix
.
length
)
{
tokens
[
0
]
.
value
=
tokens
[
0
]
.
value
.
substring
(
prefix
.
length
)
;
}
}
this
.
_searchTokens
=
!
queryContext
|
|
queryContext
.
restrictToken
?
this
.
filterTokens
(
tokens
)
:
tokens
;
if
(
queryContext
&
&
queryContext
.
restrictSource
&
&
sourceToBehaviorMap
.
has
(
queryContext
.
restrictSource
)
)
{
this
.
_behavior
=
0
;
this
.
setBehavior
(
"
restrict
"
)
;
let
behavior
=
sourceToBehaviorMap
.
get
(
queryContext
.
restrictSource
)
;
this
.
setBehavior
(
behavior
)
;
this
.
_heuristicToken
=
null
;
}
else
{
let
firstToken
=
!
!
this
.
_searchTokens
.
length
&
&
this
.
_searchTokens
[
0
]
.
value
;
this
.
_heuristicToken
=
firstToken
&
&
this
.
_trimmedOriginalSearchString
.
startsWith
(
firstToken
)
?
firstToken
:
null
;
}
if
(
!
UrlbarPrefs
.
get
(
"
filter
.
javascript
"
)
)
{
this
.
setBehavior
(
"
javascript
"
)
;
}
this
.
_listener
=
listener
;
this
.
_provider
=
provider
;
this
.
_matches
=
[
]
;
this
.
_usedURLs
=
[
]
;
this
.
_usedPlaceIds
=
new
Set
(
)
;
this
.
_counts
=
Object
.
values
(
MATCH_TYPE
)
.
reduce
(
(
o
p
)
=
>
{
o
[
p
]
=
0
;
return
o
;
}
{
}
)
;
}
Search
.
prototype
=
{
setBehavior
(
type
)
{
type
=
type
.
toUpperCase
(
)
;
this
.
_behavior
|
=
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
type
]
;
}
hasBehavior
(
type
)
{
let
behavior
=
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
type
.
toUpperCase
(
)
]
;
return
this
.
_behavior
&
behavior
;
}
filterTokens
(
tokens
)
{
let
foundToken
=
false
;
let
filtered
=
[
]
;
for
(
let
token
of
tokens
)
{
if
(
!
UrlbarTokenizer
.
isRestrictionToken
(
token
)
)
{
filtered
.
push
(
token
)
;
continue
;
}
let
behavior
=
typeToBehaviorMap
.
get
(
token
.
type
)
;
if
(
!
behavior
)
{
throw
new
Error
(
Unknown
token
type
{
token
.
type
}
)
;
}
if
(
!
foundToken
)
{
foundToken
=
true
;
this
.
_behavior
=
0
;
this
.
setBehavior
(
"
restrict
"
)
;
}
this
.
setBehavior
(
behavior
)
;
if
(
behavior
=
=
"
tag
"
)
{
this
.
setBehavior
(
"
bookmark
"
)
;
}
}
return
filtered
;
}
stop
(
)
{
if
(
!
this
.
pending
)
{
return
;
}
if
(
this
.
_notifyTimer
)
{
this
.
_notifyTimer
.
cancel
(
)
;
}
this
.
_notifyDelaysCount
=
0
;
if
(
typeof
this
.
interrupt
=
=
"
function
"
)
{
this
.
interrupt
(
)
;
}
this
.
pending
=
false
;
}
pending
:
true
async
execute
(
conn
)
{
if
(
!
this
.
pending
)
{
return
;
}
this
.
interrupt
=
(
)
=
>
{
if
(
!
UrlbarProvidersManager
.
interruptLevel
)
{
conn
.
interrupt
(
)
;
}
}
;
let
tokenAliasEngines
=
await
UrlbarSearchUtils
.
tokenAliasEngines
(
)
;
if
(
this
.
_trimmedOriginalSearchString
=
=
"
"
&
&
tokenAliasEngines
.
length
)
{
this
.
_provider
.
finishSearch
(
true
)
;
return
;
}
this
.
_firstTokenIsKeyword
=
this
.
_firstTokenIsKeyword
|
|
(
await
this
.
_checkIfFirstTokenIsKeyword
(
)
)
;
if
(
!
this
.
pending
)
{
return
;
}
if
(
this
.
_trimmedOriginalSearchString
)
{
let
emptySearchRestriction
=
this
.
_trimmedOriginalSearchString
.
length
<
=
3
&
&
this
.
_leadingRestrictionToken
=
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
&
&
/
\
s
*
\
S
?
/
.
test
(
this
.
_trimmedOriginalSearchString
)
;
if
(
emptySearchRestriction
|
|
(
tokenAliasEngines
&
&
this
.
_trimmedOriginalSearchString
.
startsWith
(
"
"
)
)
|
|
(
this
.
hasBehavior
(
"
search
"
)
&
&
this
.
hasBehavior
(
"
restrict
"
)
)
)
{
this
.
_provider
.
finishSearch
(
true
)
;
return
;
}
}
let
queries
=
[
]
;
if
(
this
.
hasBehavior
(
"
openpage
"
)
)
{
queries
.
push
(
this
.
_switchToTabQuery
)
;
}
queries
.
push
(
this
.
_searchQuery
)
;
for
(
let
[
query
params
]
of
queries
)
{
await
conn
.
executeCached
(
query
params
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
{
return
;
}
}
let
count
=
this
.
_counts
[
MATCH_TYPE
.
GENERAL
]
;
if
(
count
<
this
.
_maxResults
)
{
this
.
_matchBehavior
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_ANYWHERE
;
queries
=
[
this
.
_searchQuery
]
;
if
(
this
.
hasBehavior
(
"
openpage
"
)
)
{
queries
.
unshift
(
this
.
_switchToTabQuery
)
;
}
for
(
let
[
query
params
]
of
queries
)
{
await
conn
.
executeCached
(
query
params
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
{
return
;
}
}
}
}
async
_checkIfFirstTokenIsKeyword
(
)
{
if
(
!
this
.
_heuristicToken
)
{
return
false
;
}
let
aliasEngine
=
await
UrlbarSearchUtils
.
engineForAlias
(
this
.
_heuristicToken
this
.
_originalSearchString
)
;
if
(
aliasEngine
)
{
return
true
;
}
let
{
entry
}
=
await
KeywordUtils
.
getBindableKeyword
(
this
.
_heuristicToken
this
.
_originalSearchString
)
;
if
(
entry
)
{
this
.
_filterOnHost
=
entry
.
url
.
host
;
return
true
;
}
return
false
;
}
_addSearchEngineMatch
(
{
engine
query
=
"
"
alias
=
undefined
historical
=
false
}
)
{
let
actionURLParams
=
{
engineName
:
engine
.
name
searchQuery
:
query
}
;
if
(
alias
&
&
!
query
)
{
actionURLParams
.
input
=
{
alias
}
;
}
else
{
actionURLParams
.
input
=
this
.
_originalSearchString
;
}
let
match
=
{
comment
:
engine
.
name
icon
:
engine
.
iconURI
?
engine
.
iconURI
.
spec
:
null
style
:
"
action
searchengine
"
frecency
:
FRECENCY_DEFAULT
}
;
if
(
alias
)
{
actionURLParams
.
alias
=
alias
;
match
.
style
+
=
"
alias
"
;
}
match
.
value
=
makeActionUrl
(
"
searchengine
"
actionURLParams
)
;
this
.
_addMatch
(
match
)
;
}
_onResultRow
(
row
cancel
)
{
let
queryType
=
row
.
getResultByIndex
(
QUERYINDEX_QUERYTYPE
)
;
switch
(
queryType
)
{
case
QUERYTYPE_FILTERED
:
this
.
_addFilteredQueryMatch
(
row
)
;
break
;
}
let
count
=
this
.
_counts
[
MATCH_TYPE
.
GENERAL
]
;
if
(
!
this
.
pending
|
|
count
>
=
this
.
_maxResults
)
{
cancel
(
)
;
}
}
_maybeRestyleSearchMatch
(
match
)
{
let
historyUrl
=
match
.
value
;
let
parseResult
=
Services
.
search
.
parseSubmissionURL
(
historyUrl
)
;
if
(
!
parseResult
?
.
engine
)
{
return
false
;
}
let
terms
=
parseResult
.
terms
.
toLowerCase
(
)
;
if
(
this
.
_searchTokens
.
length
&
&
this
.
_searchTokens
.
every
(
token
=
>
!
terms
.
includes
(
token
.
value
)
)
)
{
return
false
;
}
let
[
generatedSuggestionUrl
]
=
UrlbarUtils
.
getSearchQueryUrl
(
parseResult
.
engine
this
.
_searchTokens
.
map
(
t
=
>
t
.
value
)
.
join
(
"
"
)
)
;
if
(
!
UrlbarSearchUtils
.
serpsAreEquivalent
(
historyUrl
generatedSuggestionUrl
[
parseResult
.
termsParameterName
]
)
)
{
return
false
;
}
match
.
value
=
makeActionUrl
(
"
searchengine
"
{
engineName
:
parseResult
.
engine
.
name
input
:
parseResult
.
terms
searchSuggestion
:
parseResult
.
terms
searchQuery
:
parseResult
.
terms
isSearchHistory
:
true
}
)
;
match
.
comment
=
parseResult
.
engine
.
name
;
match
.
icon
=
match
.
icon
|
|
match
.
iconUrl
;
match
.
style
=
"
action
searchengine
favicon
suggestion
"
;
return
true
;
}
_addMatch
(
match
)
{
if
(
typeof
match
.
frecency
!
=
"
number
"
)
{
throw
new
Error
(
"
Frecency
not
provided
"
)
;
}
if
(
typeof
match
.
type
!
=
"
string
"
)
{
match
.
type
=
MATCH_TYPE
.
GENERAL
;
}
if
(
!
this
.
pending
)
{
return
;
}
match
.
style
=
match
.
style
|
|
"
favicon
"
;
if
(
match
.
style
=
=
"
favicon
"
&
&
(
UrlbarPrefs
.
get
(
"
restyleSearches
"
)
|
|
this
.
_searchModeEngine
)
)
{
let
restyled
=
this
.
_maybeRestyleSearchMatch
(
match
)
;
if
(
restyled
&
&
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
=
=
0
)
{
return
;
}
}
match
.
icon
=
match
.
icon
|
|
"
"
;
match
.
finalCompleteValue
=
match
.
finalCompleteValue
|
|
"
"
;
let
{
index
replace
}
=
this
.
_getInsertIndexForMatch
(
match
)
;
if
(
index
=
=
-
1
)
{
return
;
}
if
(
replace
)
{
this
.
_matches
.
splice
(
index
1
)
;
}
this
.
_matches
.
splice
(
index
0
match
)
;
this
.
_counts
[
match
.
type
]
+
+
;
this
.
notifyResult
(
true
)
;
}
_getInsertIndexForMatch
(
match
)
{
let
[
urlMapKey
prefix
action
]
=
makeKeyForMatch
(
match
)
;
if
(
(
match
.
placeId
&
&
this
.
_usedPlaceIds
.
has
(
match
.
placeId
)
)
|
|
this
.
_usedURLs
.
some
(
e
=
>
ObjectUtils
.
deepEqual
(
e
.
key
urlMapKey
)
)
)
{
let
isDupe
=
true
;
if
(
action
&
&
[
"
switchtab
"
"
remotetab
"
]
.
includes
(
action
.
type
)
)
{
for
(
let
i
=
0
;
i
<
this
.
_usedURLs
.
length
;
+
+
i
)
{
let
{
key
:
matchKey
action
:
matchAction
}
=
this
.
_usedURLs
[
i
]
;
if
(
ObjectUtils
.
deepEqual
(
matchKey
urlMapKey
)
)
{
isDupe
=
true
;
if
(
!
matchAction
|
|
action
.
type
=
=
"
switchtab
"
)
{
this
.
_usedURLs
[
i
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
prefix
comment
:
match
.
comment
}
;
return
{
index
:
i
replace
:
true
}
;
}
break
;
}
}
}
else
{
let
prefixRank
=
UrlbarUtils
.
getPrefixRank
(
prefix
)
;
for
(
let
i
=
0
;
i
<
this
.
_usedURLs
.
length
;
+
+
i
)
{
if
(
!
this
.
_usedURLs
[
i
]
)
{
continue
;
}
let
{
key
:
existingKey
prefix
:
existingPrefix
}
=
this
.
_usedURLs
[
i
]
;
let
existingPrefixRank
=
UrlbarUtils
.
getPrefixRank
(
existingPrefix
)
;
if
(
ObjectUtils
.
deepEqual
(
existingKey
urlMapKey
)
)
{
isDupe
=
true
;
if
(
prefix
=
=
existingPrefix
)
{
break
;
}
if
(
prefix
.
endsWith
(
"
www
.
"
)
=
=
existingPrefix
.
endsWith
(
"
www
.
"
)
)
{
if
(
prefixRank
<
=
existingPrefixRank
)
{
break
;
}
else
{
this
.
_usedURLs
[
i
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
prefix
comment
:
match
.
comment
}
;
return
{
index
:
i
replace
:
true
}
;
}
}
else
{
isDupe
=
false
;
continue
;
}
}
}
}
if
(
isDupe
)
{
return
{
index
:
-
1
replace
:
false
}
;
}
}
if
(
match
.
placeId
)
{
this
.
_usedPlaceIds
.
add
(
match
.
placeId
)
;
}
let
index
=
0
;
if
(
!
this
.
_buckets
)
{
this
.
_buckets
=
[
]
;
this
.
_makeBuckets
(
UrlbarPrefs
.
get
(
"
resultGroups
"
)
this
.
_maxResults
)
;
}
let
replace
=
0
;
for
(
let
bucket
of
this
.
_buckets
)
{
if
(
match
.
type
!
=
bucket
.
type
|
|
!
bucket
.
available
)
{
index
+
=
bucket
.
count
;
continue
;
}
index
+
=
bucket
.
insertIndex
;
bucket
.
available
-
-
;
if
(
bucket
.
insertIndex
<
bucket
.
count
)
{
replace
=
true
;
}
else
{
bucket
.
count
+
+
;
}
bucket
.
insertIndex
+
+
;
break
;
}
this
.
_usedURLs
[
index
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
prefix
comment
:
match
.
comment
|
|
"
"
}
;
return
{
index
replace
}
;
}
_makeBuckets
(
resultBucket
maxResultCount
)
{
if
(
!
resultBucket
.
children
)
{
let
type
;
switch
(
resultBucket
.
group
)
{
case
UrlbarUtils
.
RESULT_GROUP
.
FORM_HISTORY
:
case
UrlbarUtils
.
RESULT_GROUP
.
REMOTE_SUGGESTION
:
case
UrlbarUtils
.
RESULT_GROUP
.
TAIL_SUGGESTION
:
type
=
MATCH_TYPE
.
SUGGESTION
;
break
;
case
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_AUTOFILL
:
case
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_EXTENSION
:
case
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_FALLBACK
:
case
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_OMNIBOX
:
case
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_SEARCH_TIP
:
case
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TEST
:
case
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC_TOKEN_ALIAS_ENGINE
:
type
=
MATCH_TYPE
.
HEURISTIC
;
break
;
case
UrlbarUtils
.
RESULT_GROUP
.
OMNIBOX
:
type
=
MATCH_TYPE
.
EXTENSION
;
break
;
default
:
type
=
MATCH_TYPE
.
GENERAL
;
break
;
}
if
(
this
.
_buckets
.
length
)
{
let
last
=
this
.
_buckets
[
this
.
_buckets
.
length
-
1
]
;
if
(
last
.
type
=
=
type
)
{
return
;
}
}
this
.
_buckets
.
push
(
{
type
available
:
maxResultCount
insertIndex
:
0
count
:
0
}
)
;
return
;
}
let
initialMaxResultCount
;
if
(
typeof
resultBucket
.
maxResultCount
=
=
"
number
"
)
{
initialMaxResultCount
=
resultBucket
.
maxResultCount
;
}
else
if
(
typeof
resultBucket
.
availableSpan
=
=
"
number
"
)
{
initialMaxResultCount
=
resultBucket
.
availableSpan
;
}
else
{
initialMaxResultCount
=
this
.
_maxResults
;
}
let
childMaxResultCount
=
Math
.
min
(
initialMaxResultCount
maxResultCount
)
;
for
(
let
child
of
resultBucket
.
children
)
{
this
.
_makeBuckets
(
child
childMaxResultCount
)
;
}
}
_addFilteredQueryMatch
(
row
)
{
let
placeId
=
row
.
getResultByIndex
(
QUERYINDEX_PLACEID
)
;
let
url
=
row
.
getResultByIndex
(
QUERYINDEX_URL
)
;
let
openPageCount
=
row
.
getResultByIndex
(
QUERYINDEX_SWITCHTAB
)
|
|
0
;
let
historyTitle
=
row
.
getResultByIndex
(
QUERYINDEX_TITLE
)
|
|
"
"
;
let
bookmarked
=
row
.
getResultByIndex
(
QUERYINDEX_BOOKMARKED
)
;
let
bookmarkTitle
=
bookmarked
?
row
.
getResultByIndex
(
QUERYINDEX_BOOKMARKTITLE
)
:
null
;
let
tags
=
row
.
getResultByIndex
(
QUERYINDEX_TAGS
)
|
|
"
"
;
let
frecency
=
row
.
getResultByIndex
(
QUERYINDEX_FRECENCY
)
;
let
match
=
{
placeId
value
:
url
comment
:
bookmarkTitle
|
|
historyTitle
icon
:
UrlbarUtils
.
getIconForUrl
(
url
)
frecency
:
frecency
|
|
FRECENCY_DEFAULT
}
;
if
(
openPageCount
>
0
&
&
this
.
hasBehavior
(
"
openpage
"
)
)
{
if
(
this
.
_currentPage
=
=
match
.
value
)
{
return
;
}
match
.
value
=
makeActionUrl
(
"
switchtab
"
{
url
:
match
.
value
}
)
;
match
.
style
=
"
action
switchtab
"
;
}
else
if
(
this
.
hasBehavior
(
"
history
"
)
&
&
!
this
.
hasBehavior
(
"
bookmark
"
)
&
&
!
tags
)
{
match
.
style
=
"
favicon
"
;
}
else
if
(
tags
)
{
match
.
comment
+
=
UrlbarUtils
.
TITLE_TAGS_SEPARATOR
+
tags
;
match
.
style
=
this
.
hasBehavior
(
"
bookmark
"
)
?
"
bookmark
-
tag
"
:
"
tag
"
;
}
else
if
(
bookmarked
)
{
match
.
style
=
"
bookmark
"
;
}
this
.
_addMatch
(
match
)
;
}
get
_suggestionPrefQuery
(
)
{
let
conditions
=
[
]
;
if
(
this
.
_filterOnHost
)
{
conditions
.
push
(
"
h
.
rev_host
=
get_unreversed_host
(
:
host
|
|
'
.
'
)
|
|
'
.
'
"
)
;
if
(
UrlbarPrefs
.
get
(
"
restyleSearches
"
)
|
|
this
.
_searchModeEngine
)
{
conditions
.
push
(
NOT
EXISTS
(
WITH
visits
(
type
)
AS
(
SELECT
visit_type
FROM
moz_historyvisits
WHERE
place_id
=
h
.
id
ORDER
BY
visit_date
DESC
LIMIT
10
/
*
limit
to
the
last
10
visits
*
/
)
SELECT
1
FROM
visits
WHERE
type
IN
(
5
6
)
)
)
;
}
else
{
conditions
.
push
(
NOT
EXISTS
(
WITH
visits
(
id
)
AS
(
SELECT
id
FROM
moz_historyvisits
WHERE
place_id
=
h
.
id
ORDER
BY
visit_date
DESC
LIMIT
10
/
*
limit
to
the
last
10
visits
*
/
)
SELECT
1
FROM
visits
src
JOIN
moz_historyvisits
dest
ON
src
.
id
=
dest
.
from_visit
WHERE
dest
.
visit_type
IN
(
5
6
)
)
)
;
conditions
.
push
(
"
(
h
.
foreign_count
>
0
OR
h
.
title
NOTNULL
)
"
)
;
}
}
if
(
this
.
hasBehavior
(
"
restrict
"
)
|
|
(
!
this
.
hasBehavior
(
"
openpage
"
)
&
&
(
!
this
.
hasBehavior
(
"
history
"
)
|
|
!
this
.
hasBehavior
(
"
bookmark
"
)
)
)
)
{
if
(
this
.
hasBehavior
(
"
history
"
)
)
{
conditions
.
push
(
"
+
h
.
visit_count
>
0
"
)
;
}
if
(
this
.
hasBehavior
(
"
bookmark
"
)
)
{
conditions
.
push
(
"
bookmarked
"
)
;
}
if
(
this
.
hasBehavior
(
"
tag
"
)
)
{
conditions
.
push
(
"
tags
NOTNULL
"
)
;
}
}
return
defaultQuery
(
conditions
.
join
(
"
AND
"
)
)
;
}
get
_emptySearchDefaultBehavior
(
)
{
let
val
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_RESTRICT
;
if
(
UrlbarPrefs
.
get
(
"
suggest
.
history
"
)
)
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_HISTORY
;
}
else
if
(
UrlbarPrefs
.
get
(
"
suggest
.
bookmark
"
)
)
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_BOOKMARK
;
}
else
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_OPENPAGE
;
}
return
val
;
}
get
_keywordFilteredSearchString
(
)
{
let
tokens
=
this
.
_searchTokens
.
map
(
t
=
>
t
.
value
)
;
if
(
this
.
_firstTokenIsKeyword
)
{
tokens
=
tokens
.
slice
(
1
)
;
}
return
tokens
.
join
(
"
"
)
;
}
get
_searchQuery
(
)
{
let
params
=
{
parent
:
PlacesUtils
.
tagsFolderId
query_type
:
QUERYTYPE_FILTERED
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
searchString
:
this
.
_keywordFilteredSearchString
userContextId
:
this
.
_userContextId
maxResults
:
this
.
_maxResults
}
;
if
(
this
.
_filterOnHost
)
{
params
.
host
=
this
.
_filterOnHost
;
}
return
[
this
.
_suggestionPrefQuery
params
]
;
}
get
_switchToTabQuery
(
)
{
return
[
SQL_SWITCHTAB_QUERY
{
query_type
:
QUERYTYPE_FILTERED
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
searchString
:
this
.
_keywordFilteredSearchString
userContextId
:
this
.
_userContextId
maxResults
:
this
.
_maxResults
}
]
;
}
_notifyTimer
:
null
_notifyDelaysCount
:
0
notifyResult
(
searchOngoing
)
{
let
notify
=
(
)
=
>
{
if
(
!
this
.
pending
)
{
return
;
}
this
.
_notifyDelaysCount
=
0
;
this
.
_listener
(
this
.
_matches
searchOngoing
)
;
if
(
!
searchOngoing
)
{
this
.
_listener
=
null
;
this
.
_provider
=
null
;
this
.
stop
(
)
;
}
}
;
if
(
this
.
_notifyTimer
)
{
this
.
_notifyTimer
.
cancel
(
)
;
}
if
(
this
.
_notifyDelaysCount
>
3
)
{
notify
(
)
;
}
else
{
this
.
_notifyDelaysCount
+
+
;
this
.
_notifyTimer
=
setTimeout
(
notify
NOTIFYRESULT_DELAY_MS
)
;
}
}
}
;
class
ProviderPlaces
extends
UrlbarProvider
{
_promiseDatabase
=
null
;
get
name
(
)
{
return
"
Places
"
;
}
get
type
(
)
{
return
UrlbarUtils
.
PROVIDER_TYPE
.
PROFILE
;
}
getDatabaseHandle
(
)
{
if
(
!
this
.
_promiseDatabase
)
{
this
.
_promiseDatabase
=
(
async
(
)
=
>
{
let
conn
=
await
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
Sqlite
.
shutdown
.
addBlocker
(
"
UrlbarProviderPlaces
closing
"
(
)
=
>
{
this
.
_currentSearch
=
null
;
}
)
;
return
conn
;
}
)
(
)
.
catch
(
ex
=
>
{
dump
(
"
Couldn
'
t
get
database
handle
:
"
+
ex
+
"
\
n
"
)
;
Cu
.
reportError
(
ex
)
;
}
)
;
}
return
this
.
_promiseDatabase
;
}
isActive
(
queryContext
)
{
if
(
!
queryContext
.
trimmedSearchString
&
&
queryContext
.
searchMode
?
.
engineName
&
&
UrlbarPrefs
.
get
(
"
update2
.
emptySearchBehavior
"
)
<
2
)
{
return
false
;
}
return
true
;
}
startQuery
(
queryContext
addCallback
)
{
let
instance
=
this
.
queryInstance
;
let
urls
=
new
Set
(
)
;
this
.
_startLegacyQuery
(
queryContext
matches
=
>
{
if
(
instance
!
=
this
.
queryInstance
)
{
return
;
}
let
results
=
convertLegacyMatches
(
queryContext
matches
urls
)
;
for
(
let
result
of
results
)
{
addCallback
(
this
result
)
;
}
}
)
;
return
this
.
_deferred
.
promise
;
}
cancelQuery
(
queryContext
)
{
if
(
this
.
_currentSearch
)
{
this
.
_currentSearch
.
stop
(
)
;
}
if
(
this
.
_deferred
)
{
this
.
_deferred
.
resolve
(
)
;
}
this
.
finishSearch
(
)
;
}
finishSearch
(
notify
=
false
)
{
let
search
=
this
.
_currentSearch
;
if
(
!
search
)
{
return
;
}
this
.
_lastLowResultsSearchSuggestion
=
search
.
_lastLowResultsSearchSuggestion
;
if
(
!
notify
|
|
!
search
.
pending
)
{
return
;
}
search
.
notifyResult
(
false
)
;
}
_startLegacyQuery
(
queryContext
callback
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
listener
=
(
matches
searchOngoing
)
=
>
{
callback
(
matches
)
;
if
(
!
searchOngoing
)
{
deferred
.
resolve
(
)
;
}
}
;
this
.
_startSearch
(
queryContext
.
searchString
listener
queryContext
)
;
this
.
_deferred
=
deferred
;
}
_startSearch
(
searchString
listener
queryContext
)
{
if
(
this
.
_currentSearch
)
{
this
.
cancelQuery
(
)
;
}
let
search
=
(
this
.
_currentSearch
=
new
Search
(
queryContext
listener
this
)
)
;
this
.
getDatabaseHandle
(
)
.
then
(
conn
=
>
search
.
execute
(
conn
)
)
.
catch
(
ex
=
>
{
dump
(
Query
failed
:
{
ex
}
\
n
)
;
Cu
.
reportError
(
ex
)
;
}
)
.
then
(
(
)
=
>
{
if
(
search
=
=
this
.
_currentSearch
)
{
this
.
finishSearch
(
true
)
;
}
}
)
;
}
}
var
UrlbarProviderPlaces
=
new
ProviderPlaces
(
)
;
