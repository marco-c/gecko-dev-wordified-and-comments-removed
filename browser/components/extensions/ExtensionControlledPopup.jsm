"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionControlledPopup
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
let
{
makeWidgetId
}
=
ExtensionCommon
;
XPCOMUtils
.
defineLazyGetter
(
this
"
strBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
extensions
.
properties
"
)
;
}
)
;
const
PREF_BRANCH_INSTALLED_ADDON
=
"
extensions
.
installedDistroAddon
.
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
distributionAddonsList
"
function
(
)
{
let
addonList
=
Services
.
prefs
.
getChildList
(
PREF_BRANCH_INSTALLED_ADDON
)
.
map
(
id
=
>
id
.
replace
(
PREF_BRANCH_INSTALLED_ADDON
"
"
)
)
;
return
new
Set
(
addonList
)
;
}
)
;
class
ExtensionControlledPopup
{
constructor
(
opts
)
{
this
.
confirmedType
=
opts
.
confirmedType
;
this
.
observerTopic
=
opts
.
observerTopic
;
this
.
anchorId
=
opts
.
anchorId
;
this
.
popupnotificationId
=
opts
.
popupnotificationId
;
this
.
settingType
=
opts
.
settingType
;
this
.
settingKey
=
opts
.
settingKey
;
this
.
descriptionId
=
opts
.
descriptionId
;
this
.
descriptionMessageId
=
opts
.
descriptionMessageId
;
this
.
getLocalizedDescription
=
opts
.
getLocalizedDescription
;
this
.
learnMoreMessageId
=
opts
.
learnMoreMessageId
;
this
.
learnMoreLink
=
opts
.
learnMoreLink
;
this
.
preferencesLocation
=
opts
.
preferencesLocation
;
this
.
preferencesEntrypoint
=
opts
.
preferencesEntrypoint
;
this
.
onObserverAdded
=
opts
.
onObserverAdded
;
this
.
onObserverRemoved
=
opts
.
onObserverRemoved
;
this
.
beforeDisableAddon
=
opts
.
beforeDisableAddon
;
this
.
observerRegistered
=
false
;
}
get
topWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
}
userHasConfirmed
(
id
)
{
if
(
distributionAddonsList
.
has
(
id
)
)
{
return
true
;
}
let
setting
=
ExtensionSettingsStore
.
getSetting
(
this
.
confirmedType
id
)
;
return
!
!
(
setting
&
&
setting
.
value
)
;
}
async
setConfirmation
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
addSetting
(
id
this
.
confirmedType
id
true
(
)
=
>
false
)
;
}
async
clearConfirmation
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
removeSetting
(
id
this
.
confirmedType
id
)
;
}
observe
(
subject
topic
data
)
{
this
.
removeObserver
(
)
;
let
targetWindow
;
if
(
subject
&
&
subject
.
document
)
{
targetWindow
=
subject
;
}
this
.
topWindow
.
requestIdleCallback
(
(
)
=
>
this
.
open
(
targetWindow
)
)
;
}
removeObserver
(
)
{
if
(
this
.
observerRegistered
)
{
Services
.
obs
.
removeObserver
(
this
this
.
observerTopic
)
;
this
.
observerRegistered
=
false
;
if
(
this
.
onObserverRemoved
)
{
this
.
onObserverRemoved
(
)
;
}
}
}
async
addObserver
(
extensionId
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
if
(
!
this
.
observerRegistered
&
&
!
this
.
userHasConfirmed
(
extensionId
)
)
{
Services
.
obs
.
addObserver
(
this
this
.
observerTopic
)
;
this
.
observerRegistered
=
true
;
if
(
this
.
onObserverAdded
)
{
this
.
onObserverAdded
(
)
;
}
}
}
async
open
(
targetWindow
extensionId
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
this
.
removeObserver
(
)
;
if
(
!
extensionId
)
{
let
item
=
ExtensionSettingsStore
.
getSetting
(
this
.
settingType
this
.
settingKey
)
;
extensionId
=
item
&
&
item
.
id
;
}
let
win
=
targetWindow
|
|
this
.
topWindow
;
let
isPrivate
=
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
;
if
(
isPrivate
&
&
extensionId
&
&
!
WebExtensionPolicy
.
getByID
(
extensionId
)
.
privateBrowsingAllowed
)
{
return
;
}
if
(
!
extensionId
|
|
this
.
userHasConfirmed
(
extensionId
)
)
{
return
;
}
try
{
await
this
.
_ensureWindowReady
(
win
)
;
}
catch
(
ex
)
{
return
;
}
let
doc
=
win
.
document
;
let
panel
=
ExtensionControlledPopup
.
_getAndMaybeCreatePanel
(
doc
)
;
let
popupnotification
=
doc
.
getElementById
(
this
.
popupnotificationId
)
;
let
urlBarWasFocused
=
win
.
gURLBar
.
focused
;
if
(
!
popupnotification
)
{
throw
new
Error
(
No
popupnotification
found
for
id
"
{
this
.
popupnotificationId
}
"
)
;
}
let
elementsToTranslate
=
panel
.
querySelectorAll
(
"
[
data
-
lazy
-
l10n
-
id
]
"
)
;
if
(
elementsToTranslate
.
length
)
{
win
.
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
appMenuNotifications
.
ftl
"
)
;
for
(
let
el
of
elementsToTranslate
)
{
el
.
setAttribute
(
"
data
-
l10n
-
id
"
el
.
getAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
)
;
el
.
removeAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
;
}
await
win
.
document
.
l10n
.
translateFragment
(
panel
)
;
}
let
addon
=
await
AddonManager
.
getAddonByID
(
extensionId
)
;
this
.
populateDescription
(
doc
addon
)
;
let
handleCommand
=
async
event
=
>
{
panel
.
hidePopup
(
)
;
if
(
event
.
originalTarget
=
=
popupnotification
.
button
)
{
await
this
.
setConfirmation
(
extensionId
)
;
}
else
if
(
this
.
preferencesLocation
)
{
let
options
=
this
.
Entrypoint
?
{
urlParams
:
{
entrypoint
:
this
.
Entrypoint
}
}
:
{
}
;
win
.
openPreferences
(
this
.
preferencesLocation
options
)
;
}
else
{
if
(
this
.
beforeDisableAddon
)
{
await
this
.
beforeDisableAddon
(
this
win
)
;
}
await
addon
.
disable
(
)
;
}
if
(
urlBarWasFocused
)
{
win
.
gURLBar
.
focus
(
)
;
}
}
;
panel
.
addEventListener
(
"
command
"
handleCommand
)
;
panel
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
popupnotification
.
hidden
=
true
;
panel
.
removeEventListener
(
"
command
"
handleCommand
)
;
}
{
once
:
true
}
)
;
let
anchorButton
;
if
(
this
.
anchorId
)
{
anchorButton
=
doc
.
getElementById
(
this
.
anchorId
)
;
}
else
{
let
action
=
CustomizableUI
.
getWidget
(
{
makeWidgetId
(
extensionId
)
}
-
browser
-
action
)
;
if
(
action
)
{
action
=
action
.
areaType
=
=
"
toolbar
"
&
&
action
.
forWindow
(
win
)
.
node
;
}
anchorButton
=
action
|
|
doc
.
getElementById
(
"
PanelUI
-
menu
-
button
"
)
;
}
let
anchor
=
anchorButton
.
icon
;
popupnotification
.
show
(
)
;
panel
.
openPopup
(
anchor
)
;
}
getAddonDetails
(
doc
addon
)
{
const
defaultIcon
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
;
let
image
=
doc
.
createXULElement
(
"
image
"
)
;
image
.
setAttribute
(
"
src
"
addon
.
iconURL
|
|
defaultIcon
)
;
image
.
classList
.
add
(
"
extension
-
controlled
-
icon
"
)
;
let
addonDetails
=
doc
.
createDocumentFragment
(
)
;
addonDetails
.
appendChild
(
image
)
;
addonDetails
.
appendChild
(
doc
.
createTextNode
(
"
"
+
addon
.
name
)
)
;
return
addonDetails
;
}
populateDescription
(
doc
addon
)
{
let
description
=
doc
.
getElementById
(
this
.
descriptionId
)
;
description
.
textContent
=
"
"
;
let
addonDetails
=
this
.
getAddonDetails
(
doc
addon
)
;
let
message
=
strBundle
.
GetStringFromName
(
this
.
descriptionMessageId
)
;
if
(
this
.
getLocalizedDescription
)
{
description
.
appendChild
(
this
.
getLocalizedDescription
(
doc
message
addonDetails
)
)
;
}
else
{
description
.
appendChild
(
BrowserUtils
.
getLocalizedFragment
(
doc
message
addonDetails
)
)
;
}
let
link
=
doc
.
createXULElement
(
"
label
"
{
is
:
"
text
-
link
"
}
)
;
link
.
setAttribute
(
"
class
"
"
learnMore
"
)
;
link
.
href
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
this
.
learnMoreLink
;
link
.
textContent
=
strBundle
.
GetStringFromName
(
this
.
learnMoreMessageId
)
;
description
.
appendChild
(
link
)
;
}
async
_ensureWindowReady
(
win
)
{
if
(
win
.
closed
)
{
throw
new
Error
(
"
window
is
closed
"
)
;
}
let
promises
=
[
]
;
let
listenersToRemove
=
[
]
;
function
promiseEvent
(
type
)
{
promises
.
push
(
new
Promise
(
resolve
=
>
{
let
listener
=
(
)
=
>
{
win
.
removeEventListener
(
type
listener
)
;
resolve
(
)
;
}
;
win
.
addEventListener
(
type
listener
)
;
listenersToRemove
.
push
(
[
type
listener
]
)
;
}
)
)
;
}
let
{
focusedWindow
activeWindow
}
=
Services
.
focus
;
if
(
activeWindow
!
=
win
)
{
promiseEvent
(
"
activate
"
)
;
}
if
(
focusedWindow
)
{
let
{
rootTreeItem
}
=
focusedWindow
.
docShell
;
rootTreeItem
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
focusedWindow
=
rootTreeItem
.
contentViewer
.
DOMDocument
.
defaultView
;
}
if
(
focusedWindow
!
=
win
)
{
promiseEvent
(
"
focus
"
)
;
}
let
unloadListener
;
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
if
(
promises
.
length
)
{
unloadListener
=
(
)
=
>
{
for
(
let
[
type
listener
]
of
listenersToRemove
)
{
win
.
removeEventListener
(
type
listener
)
;
}
reject
(
)
;
}
;
win
.
addEventListener
(
"
unload
"
unloadListener
{
once
:
true
}
)
;
}
let
error
;
try
{
await
Promise
.
all
(
promises
)
;
}
catch
(
ex
)
{
error
=
ex
;
}
if
(
unloadListener
)
{
win
.
removeEventListener
(
"
unload
"
unloadListener
)
;
}
if
(
error
)
{
reject
(
new
Error
(
"
window
unloaded
"
)
)
;
}
else
{
resolve
(
)
;
}
}
)
;
}
static
_getAndMaybeCreatePanel
(
doc
)
{
let
template
=
doc
.
getElementById
(
"
extensionNotificationTemplate
"
)
;
if
(
template
)
{
template
.
replaceWith
(
template
.
content
)
;
}
return
doc
.
getElementById
(
"
extension
-
notification
-
panel
"
)
;
}
}
