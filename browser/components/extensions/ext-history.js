"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
let
History
=
PlacesUtils
.
history
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
const
{
normalizeTime
}
=
ExtensionUtils
;
const
TRANSITION_TO_TRANSITION_TYPES_MAP
=
new
Map
(
[
[
"
link
"
History
.
TRANSITION_LINK
]
[
"
typed
"
History
.
TRANSITION_TYPED
]
[
"
auto_bookmark
"
History
.
TRANSITION_BOOKMARK
]
[
"
auto_subframe
"
History
.
TRANSITION_EMBED
]
[
"
manual_subframe
"
History
.
TRANSITION_FRAMED_LINK
]
]
)
;
function
getTransitionType
(
transition
)
{
transition
=
transition
|
|
"
link
"
;
let
transitionType
=
TRANSITION_TO_TRANSITION_TYPES_MAP
.
get
(
transition
)
;
if
(
!
transitionType
)
{
throw
new
Error
(
|
{
transition
}
|
is
not
a
supported
transition
for
history
)
;
}
return
transitionType
;
}
function
convertNavHistoryResultNode
(
node
)
{
return
{
id
:
node
.
pageGuid
url
:
node
.
uri
title
:
node
.
title
lastVisitTime
:
PlacesUtils
.
toDate
(
node
.
time
)
.
getTime
(
)
visitCount
:
node
.
accessCount
}
;
}
function
convertNavHistoryContainerResultNode
(
container
)
{
let
results
=
[
]
;
container
.
containerOpen
=
true
;
for
(
let
i
=
0
;
i
<
container
.
childCount
;
i
+
+
)
{
let
node
=
container
.
getChild
(
i
)
;
results
.
push
(
convertNavHistoryResultNode
(
node
)
)
;
}
container
.
containerOpen
=
false
;
return
results
;
}
extensions
.
registerSchemaAPI
(
"
history
"
"
history
"
(
extension
context
)
=
>
{
return
{
history
:
{
addUrl
:
function
(
details
)
{
let
transition
date
;
try
{
transition
=
getTransitionType
(
details
.
transition
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
{
message
:
error
.
message
}
)
;
}
if
(
details
.
visitTime
)
{
date
=
normalizeTime
(
details
.
visitTime
)
;
}
let
pageInfo
=
{
title
:
details
.
title
url
:
details
.
url
visits
:
[
{
transition
date
}
]
}
;
try
{
return
History
.
insert
(
pageInfo
)
.
then
(
(
)
=
>
undefined
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
{
message
:
error
.
message
}
)
;
}
}
deleteAll
:
function
(
)
{
return
History
.
clear
(
)
;
}
deleteRange
:
function
(
filter
)
{
let
newFilter
=
{
beginDate
:
normalizeTime
(
filter
.
startTime
)
endDate
:
normalizeTime
(
filter
.
endTime
)
}
;
return
History
.
removeVisitsByFilter
(
newFilter
)
.
then
(
(
)
=
>
undefined
)
;
}
deleteUrl
:
function
(
details
)
{
let
url
=
details
.
url
;
return
History
.
remove
(
url
)
.
then
(
(
)
=
>
undefined
)
;
}
search
:
function
(
query
)
{
let
beginTime
=
(
query
.
startTime
=
=
null
)
?
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
-
24
*
60
*
60
*
1000
)
:
PlacesUtils
.
toPRTime
(
normalizeTime
(
query
.
startTime
)
)
;
let
endTime
=
(
query
.
endTime
=
=
null
)
?
Number
.
MAX_VALUE
:
PlacesUtils
.
toPRTime
(
normalizeTime
(
query
.
endTime
)
)
;
if
(
beginTime
>
endTime
)
{
return
Promise
.
reject
(
{
message
:
"
The
startTime
cannot
be
after
the
endTime
"
}
)
;
}
let
options
=
History
.
getNewQueryOptions
(
)
;
options
.
sortingMode
=
options
.
SORT_BY_DATE_DESCENDING
;
options
.
maxResults
=
query
.
maxResults
|
|
100
;
let
historyQuery
=
History
.
getNewQuery
(
)
;
historyQuery
.
searchTerms
=
query
.
text
;
historyQuery
.
beginTime
=
beginTime
;
historyQuery
.
endTime
=
endTime
;
let
queryResult
=
History
.
executeQuery
(
historyQuery
options
)
.
root
;
let
results
=
convertNavHistoryContainerResultNode
(
queryResult
)
;
return
Promise
.
resolve
(
results
)
;
}
}
}
;
}
)
;
