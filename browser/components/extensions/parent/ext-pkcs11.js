"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ctypes
:
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
NativeManifests
:
"
resource
:
/
/
gre
/
modules
/
NativeManifests
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
pkcs11db
"
"
mozilla
.
org
/
security
/
pkcs11moduledb
;
1
"
"
nsIPKCS11ModuleDB
"
)
;
Cu
.
importGlobalProperties
(
[
"
PathUtils
"
]
)
;
var
{
DefaultMap
}
=
ExtensionUtils
;
const
findModuleByPath
=
function
(
path
)
{
for
(
let
module
of
pkcs11db
.
listModules
(
)
)
{
if
(
module
&
&
module
.
libName
=
=
=
path
)
{
return
module
;
}
}
return
null
;
}
;
this
.
pkcs11
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
let
manifestCache
=
new
DefaultMap
(
async
name
=
>
{
let
hostInfo
=
await
NativeManifests
.
lookupManifest
(
"
pkcs11
"
name
context
)
;
if
(
hostInfo
)
{
let
absolutePath
=
PathUtils
.
isAbsolute
(
hostInfo
.
manifest
.
path
)
?
hostInfo
.
manifest
.
path
:
PathUtils
.
joinRelative
(
PathUtils
.
parent
(
hostInfo
.
path
)
hostInfo
.
manifest
.
path
)
;
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
absolutePath
=
PathUtils
.
normalize
(
absolutePath
)
;
hostInfo
.
manifest
.
path
=
absolutePath
;
}
let
manifestLib
=
PathUtils
.
filename
(
absolutePath
)
;
if
(
AppConstants
.
platform
!
=
=
"
linux
"
)
{
manifestLib
=
manifestLib
.
toLowerCase
(
manifestLib
)
;
}
if
(
manifestLib
!
=
=
ctypes
.
libraryName
(
"
nssckbi
"
)
&
&
manifestLib
!
=
=
ctypes
.
libraryName
(
"
osclientcerts
"
)
&
&
manifestLib
!
=
=
ctypes
.
libraryName
(
"
ipcclientcerts
"
)
)
{
return
hostInfo
.
manifest
;
}
}
return
Promise
.
reject
(
{
message
:
No
such
PKCS
#
11
module
{
name
}
}
)
;
}
)
;
return
{
pkcs11
:
{
async
isModuleInstalled
(
name
)
{
let
manifest
=
await
manifestCache
.
get
(
name
)
;
return
findModuleByPath
(
manifest
.
path
)
!
=
=
null
;
}
async
installModule
(
name
flags
=
0
)
{
let
manifest
=
await
manifestCache
.
get
(
name
)
;
if
(
!
manifest
.
description
)
{
return
Promise
.
reject
(
{
message
:
The
description
field
in
the
manifest
for
PKCS
#
11
module
{
name
}
must
have
a
value
}
)
;
}
pkcs11db
.
addModule
(
manifest
.
description
manifest
.
path
flags
0
)
;
}
async
uninstallModule
(
name
)
{
let
manifest
=
await
manifestCache
.
get
(
name
)
;
let
module
=
findModuleByPath
(
manifest
.
path
)
;
if
(
!
module
)
{
return
Promise
.
reject
(
{
message
:
The
PKCS
#
11
module
{
name
}
is
not
loaded
}
)
;
}
pkcs11db
.
deleteModule
(
module
.
name
)
;
}
async
getModuleSlots
(
name
)
{
let
manifest
=
await
manifestCache
.
get
(
name
)
;
let
module
=
findModuleByPath
(
manifest
.
path
)
;
if
(
!
module
)
{
return
Promise
.
reject
(
{
message
:
The
module
{
name
}
is
not
installed
}
)
;
}
let
rv
=
[
]
;
for
(
let
slot
of
module
.
listSlots
(
)
)
{
let
token
=
slot
.
getToken
(
)
;
let
slotobj
=
{
name
:
slot
.
name
token
:
null
}
;
if
(
slot
.
status
!
=
1
)
{
slotobj
.
token
=
{
name
:
token
.
tokenName
manufacturer
:
token
.
tokenManID
HWVersion
:
token
.
tokenHWVersion
FWVersion
:
token
.
tokenFWVersion
serial
:
token
.
tokenSerialNumber
isLoggedIn
:
token
.
isLoggedIn
(
)
}
;
}
rv
.
push
(
slotobj
)
;
}
return
rv
;
}
}
}
;
}
}
;
