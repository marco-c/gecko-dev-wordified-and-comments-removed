"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionTelemetry
"
"
resource
:
/
/
gre
/
modules
/
ExtensionTelemetry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PageActions
"
"
resource
:
/
/
/
modules
/
PageActions
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PanelPopup
"
"
resource
:
/
/
/
modules
/
ExtensionPopups
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUsageTelemetry
"
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
)
;
var
{
DefaultWeakMap
}
=
ExtensionUtils
;
var
{
ExtensionParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
var
{
PageActionBase
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionActions
.
jsm
"
)
;
let
pageActionMap
=
new
WeakMap
(
)
;
class
PageAction
extends
PageActionBase
{
constructor
(
extension
buttonDelegate
)
{
let
tabContext
=
new
TabContext
(
tab
=
>
this
.
getContextData
(
null
)
)
;
super
(
tabContext
extension
)
;
this
.
buttonDelegate
=
buttonDelegate
;
}
updateOnChange
(
target
)
{
this
.
buttonDelegate
.
updateButton
(
target
.
ownerGlobal
)
;
}
dispatchClick
(
tab
clickInfo
)
{
this
.
buttonDelegate
.
emit
(
"
click
"
tab
clickInfo
)
;
}
getTab
(
tabId
)
{
if
(
tabId
!
=
=
null
)
{
return
tabTracker
.
getTab
(
tabId
)
;
}
return
null
;
}
}
this
.
pageAction
=
class
extends
ExtensionAPI
{
static
for
(
extension
)
{
return
pageActionMap
.
get
(
extension
)
;
}
static
onUpdate
(
id
manifest
)
{
if
(
!
(
"
page_action
"
in
manifest
)
)
{
BrowserUsageTelemetry
.
recordWidgetChange
(
makeWidgetId
(
id
)
null
"
addon
"
)
;
}
}
static
onDisable
(
id
)
{
BrowserUsageTelemetry
.
recordWidgetChange
(
makeWidgetId
(
id
)
null
"
addon
"
)
;
}
static
onUninstall
(
id
)
{
BrowserUsageTelemetry
.
recordWidgetChange
(
makeWidgetId
(
id
)
null
"
addon
"
)
;
}
async
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
let
options
=
extension
.
manifest
.
page_action
;
this
.
action
=
new
PageAction
(
extension
this
)
;
await
this
.
action
.
loadIconData
(
)
;
let
widgetId
=
makeWidgetId
(
extension
.
id
)
;
this
.
id
=
widgetId
+
"
-
page
-
action
"
;
this
.
tabManager
=
extension
.
tabManager
;
this
.
browserStyle
=
options
.
browser_style
;
pageActionMap
.
set
(
extension
this
)
;
this
.
lastValues
=
new
DefaultWeakMap
(
(
)
=
>
(
{
}
)
)
;
if
(
!
this
.
browserPageAction
)
{
let
onPlacedHandler
=
(
buttonNode
isPanel
)
=
>
{
buttonNode
.
addEventListener
(
"
auxclick
"
event
=
>
{
if
(
event
.
button
!
=
=
1
|
|
event
.
target
.
disabled
)
{
return
;
}
if
(
isPanel
)
{
buttonNode
.
closest
(
"
#
pageActionPanel
"
)
.
hidePopup
(
)
;
}
let
window
=
event
.
target
.
ownerGlobal
;
let
tab
=
window
.
gBrowser
.
selectedTab
;
this
.
action
.
dispatchClick
(
tab
{
button
:
event
.
button
modifiers
:
clickModifiersFromEvent
(
event
)
}
)
;
}
)
;
}
;
this
.
browserPageAction
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
widgetId
extensionID
:
extension
.
id
title
:
this
.
action
.
getProperty
(
null
"
title
"
)
iconURL
:
this
.
action
.
getProperty
(
null
"
title
"
)
pinnedToUrlbar
:
this
.
action
.
getPinned
(
)
disabled
:
!
this
.
action
.
getProperty
(
null
"
enabled
"
)
onCommand
:
(
event
buttonNode
)
=
>
{
this
.
handleClick
(
event
.
target
.
ownerGlobal
{
button
:
event
.
button
|
|
0
modifiers
:
clickModifiersFromEvent
(
event
)
}
)
;
}
onBeforePlacedInWindow
:
browserWindow
=
>
{
if
(
this
.
extension
.
hasPermission
(
"
menus
"
)
|
|
this
.
extension
.
hasPermission
(
"
contextMenus
"
)
)
{
browserWindow
.
document
.
addEventListener
(
"
popupshowing
"
this
)
;
}
}
onPlacedInPanel
:
buttonNode
=
>
onPlacedHandler
(
buttonNode
true
)
onPlacedInUrlbar
:
buttonNode
=
>
onPlacedHandler
(
buttonNode
false
)
onRemovedFromWindow
:
browserWindow
=
>
{
browserWindow
.
document
.
removeEventListener
(
"
popupshowing
"
this
)
;
}
}
)
)
;
if
(
this
.
extension
.
startupReason
!
=
"
APP_STARTUP
"
)
{
ExtensionParent
.
browserStartupPromise
.
then
(
(
)
=
>
{
BrowserUsageTelemetry
.
recordWidgetChange
(
widgetId
this
.
browserPageAction
.
pinnedToUrlbar
?
"
page
-
action
-
buttons
"
:
null
"
addon
"
)
;
}
)
;
}
if
(
this
.
action
.
getProperty
(
null
"
enabled
"
)
=
=
=
undefined
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
let
tab
=
window
.
gBrowser
.
selectedTab
;
if
(
this
.
action
.
isShownForTab
(
tab
)
)
{
this
.
updateButton
(
window
)
;
}
}
}
}
}
onShutdown
(
isAppShutdown
)
{
pageActionMap
.
delete
(
this
.
extension
)
;
this
.
action
.
onShutdown
(
)
;
if
(
!
isAppShutdown
&
&
this
.
browserPageAction
)
{
this
.
browserPageAction
.
remove
(
)
;
this
.
browserPageAction
=
null
;
}
}
updateButton
(
window
)
{
let
tab
=
window
.
gBrowser
.
selectedTab
;
let
tabData
=
this
.
action
.
getContextData
(
tab
)
;
let
last
=
this
.
lastValues
.
get
(
window
)
;
window
.
requestAnimationFrame
(
(
)
=
>
{
if
(
!
this
.
browserPageAction
)
{
return
;
}
let
title
=
tabData
.
title
|
|
this
.
extension
.
name
;
if
(
last
.
title
!
=
=
title
)
{
this
.
browserPageAction
.
setTitle
(
title
window
)
;
last
.
title
=
title
;
}
let
enabled
=
tabData
.
enabled
!
=
null
?
tabData
.
enabled
:
tabData
.
patternMatching
;
if
(
last
.
enabled
!
=
=
enabled
)
{
this
.
browserPageAction
.
setDisabled
(
!
enabled
window
)
;
last
.
enabled
=
enabled
;
}
let
icon
=
tabData
.
icon
;
if
(
last
.
icon
!
=
=
icon
)
{
this
.
browserPageAction
.
setIconURL
(
icon
window
)
;
last
.
icon
=
icon
;
}
}
)
;
}
triggerAction
(
window
)
{
this
.
handleClick
(
window
{
button
:
0
modifiers
:
[
]
}
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
popupshowing
"
:
const
menu
=
event
.
target
;
const
trigger
=
menu
.
triggerNode
;
let
actionId
=
trigger
?
.
getAttribute
(
"
actionid
"
)
;
if
(
trigger
&
&
!
actionId
)
{
for
(
let
n
=
trigger
.
parentNode
;
n
&
&
!
actionId
;
n
=
n
.
parentNode
)
{
if
(
n
.
id
=
=
"
page
-
action
-
buttons
"
|
|
n
.
localName
=
=
"
panelview
"
)
{
break
;
}
actionId
=
n
.
getAttribute
(
"
actionid
"
)
;
}
}
if
(
menu
.
id
=
=
=
"
pageActionContextMenu
"
&
&
trigger
&
&
actionId
=
=
=
this
.
browserPageAction
.
id
&
&
!
this
.
browserPageAction
.
getDisabled
(
trigger
.
ownerGlobal
)
)
{
global
.
actionContextMenu
(
{
extension
:
this
.
extension
onPageAction
:
true
menu
:
menu
}
)
;
}
break
;
}
}
async
handleClick
(
window
clickInfo
)
{
const
{
extension
}
=
this
;
ExtensionTelemetry
.
pageActionPopupOpen
.
stopwatchStart
(
extension
this
)
;
let
tab
=
window
.
gBrowser
.
selectedTab
;
let
popupURL
=
this
.
action
.
triggerClickOrPopup
(
tab
clickInfo
)
;
if
(
popupURL
)
{
if
(
this
.
popupNode
&
&
this
.
popupNode
.
panel
.
state
!
=
=
"
closed
"
)
{
ExtensionTelemetry
.
pageActionPopupOpen
.
stopwatchCancel
(
extension
this
)
;
window
.
BrowserPageActions
.
togglePanelForAction
(
this
.
browserPageAction
this
.
popupNode
.
panel
)
;
return
;
}
this
.
popupNode
=
new
PanelPopup
(
extension
window
.
document
popupURL
this
.
browserStyle
)
;
this
.
popupNode
.
panel
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
this
.
popupNode
=
undefined
;
}
{
once
:
true
}
)
;
await
this
.
popupNode
.
contentReady
;
window
.
BrowserPageActions
.
togglePanelForAction
(
this
.
browserPageAction
this
.
popupNode
.
panel
)
;
ExtensionTelemetry
.
pageActionPopupOpen
.
stopwatchFinish
(
extension
this
)
;
}
else
{
ExtensionTelemetry
.
pageActionPopupOpen
.
stopwatchCancel
(
extension
this
)
;
}
}
getAPI
(
context
)
{
const
{
extension
}
=
context
;
const
{
tabManager
}
=
extension
;
const
{
action
}
=
this
;
return
{
pageAction
:
{
.
.
.
action
.
api
(
context
)
onClicked
:
new
EventManager
(
{
context
name
:
"
pageAction
.
onClicked
"
inputHandling
:
true
register
:
fire
=
>
{
let
listener
=
(
evt
tab
clickInfo
)
=
>
{
context
.
withPendingBrowser
(
tab
.
linkedBrowser
(
)
=
>
fire
.
sync
(
tabManager
.
convert
(
tab
)
clickInfo
)
)
;
}
;
this
.
on
(
"
click
"
listener
)
;
return
(
)
=
>
{
this
.
off
(
"
click
"
listener
)
;
}
;
}
}
)
.
api
(
)
openPopup
:
(
)
=
>
{
let
window
=
windowTracker
.
topWindow
;
this
.
triggerAction
(
window
)
;
}
}
}
;
}
}
;
global
.
pageActionFor
=
this
.
pageAction
.
for
;
