"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
let
findResults
=
new
WeakMap
(
)
;
function
getActorForBrowsingContext
(
browsingContext
)
{
let
windowGlobal
=
browsingContext
.
currentWindowGlobal
;
return
windowGlobal
?
windowGlobal
.
getActor
(
"
ExtFind
"
)
:
null
;
}
function
getTopLevelActor
(
browser
)
{
return
getActorForBrowsingContext
(
browser
.
browsingContext
)
;
}
function
gatherActors
(
browsingContext
)
{
let
list
=
[
]
;
let
actor
=
getActorForBrowsingContext
(
browsingContext
)
;
if
(
actor
)
{
list
.
push
(
{
actor
result
:
null
}
)
;
}
let
children
=
browsingContext
.
children
;
for
(
let
child
of
children
)
{
list
.
push
(
.
.
.
gatherActors
(
child
)
)
;
}
return
list
;
}
function
mergeFindResults
(
params
list
)
{
let
finalResult
=
{
count
:
0
}
;
if
(
params
.
includeRangeData
)
{
finalResult
.
rangeData
=
[
]
;
}
if
(
params
.
includeRectData
)
{
finalResult
.
rectData
=
[
]
;
}
let
currentFramePos
=
-
1
;
for
(
let
item
of
list
)
{
if
(
item
.
result
.
count
=
=
0
)
{
continue
;
}
currentFramePos
+
+
;
finalResult
.
count
+
=
item
.
result
.
count
;
if
(
params
.
includeRangeData
&
&
item
.
result
.
rangeData
)
{
for
(
let
range
of
item
.
result
.
rangeData
)
{
range
.
framePos
=
currentFramePos
;
}
finalResult
.
rangeData
.
push
(
.
.
.
item
.
result
.
rangeData
)
;
}
if
(
params
.
includeRectData
&
&
item
.
result
.
rectData
)
{
finalResult
.
rectData
.
push
(
.
.
.
item
.
result
.
rectData
)
;
}
}
return
finalResult
;
}
function
sendMessageToAllActors
(
browser
message
params
)
{
for
(
let
{
actor
}
of
gatherActors
(
browser
.
browsingContext
)
)
{
actor
.
sendAsyncMessage
(
"
ext
-
Finder
:
"
+
message
params
)
;
}
}
async
function
getFindResultsForActor
(
findContext
message
params
)
{
findContext
.
result
=
await
findContext
.
actor
.
sendQuery
(
"
ext
-
Finder
:
"
+
message
params
)
;
return
findContext
;
}
function
queryAllActors
(
browser
message
params
)
{
let
promises
=
[
]
;
for
(
let
findContext
of
gatherActors
(
browser
.
browsingContext
)
)
{
promises
.
push
(
getFindResultsForActor
(
findContext
message
params
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
async
function
collectFindResults
(
browser
findResults
params
)
{
let
results
=
await
queryAllActors
(
browser
"
CollectResults
"
params
)
;
findResults
.
set
(
getTopLevelActor
(
browser
)
results
)
;
return
mergeFindResults
(
params
results
)
;
}
async
function
runHighlight
(
browser
params
)
{
let
hasResults
=
false
;
let
foundResults
=
false
;
let
list
=
findResults
.
get
(
getTopLevelActor
(
browser
)
)
;
if
(
!
list
)
{
return
Promise
.
reject
(
{
message
:
"
no
search
results
to
highlight
"
}
)
;
}
let
highlightPromises
=
[
]
;
let
index
=
params
.
rangeIndex
;
for
(
let
c
=
0
;
c
<
list
.
length
;
c
+
+
)
{
if
(
list
[
c
]
.
result
.
count
)
{
hasResults
=
true
;
}
let
actor
=
list
[
c
]
.
actor
;
if
(
!
foundResults
&
&
index
<
list
[
c
]
.
result
.
count
)
{
foundResults
=
true
;
params
.
rangeIndex
=
index
;
highlightPromises
.
push
(
actor
.
sendQuery
(
"
ext
-
Finder
:
HighlightResults
"
params
)
)
;
}
else
{
highlightPromises
.
push
(
actor
.
sendQuery
(
"
ext
-
Finder
:
ClearHighlighting
"
params
)
)
;
}
index
-
=
list
[
c
]
.
result
.
count
;
}
let
responses
=
await
Promise
.
all
(
highlightPromises
)
;
if
(
hasResults
)
{
if
(
responses
.
includes
(
"
OutOfRange
"
)
|
|
index
>
=
0
)
{
return
Promise
.
reject
(
{
message
:
"
index
supplied
was
out
of
range
"
}
)
;
}
else
if
(
responses
.
includes
(
"
Success
"
)
)
{
return
;
}
}
return
Promise
.
reject
(
{
message
:
"
no
search
results
to
highlight
"
}
)
;
}
function
runFindOperation
(
context
params
message
)
{
let
{
tabId
}
=
params
;
let
tab
=
tabId
?
tabTracker
.
getTab
(
tabId
)
:
tabTracker
.
activeTab
;
let
browser
=
tab
.
linkedBrowser
;
tabId
=
tabId
|
|
tabTracker
.
getId
(
tab
)
;
if
(
!
context
.
privateBrowsingAllowed
&
&
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
return
Promise
.
reject
(
{
message
:
Unable
to
search
:
{
tabId
}
}
)
;
}
if
(
tab
.
linkedBrowser
.
contentPrincipal
.
isSystemPrincipal
|
|
(
[
"
about
"
"
chrome
"
"
resource
"
]
.
includes
(
tab
.
linkedBrowser
.
currentURI
.
scheme
)
&
&
tab
.
linkedBrowser
.
currentURI
.
spec
!
=
"
about
:
blank
"
)
)
{
return
Promise
.
reject
(
{
message
:
Unable
to
search
:
{
tabId
}
}
)
;
}
if
(
message
=
=
"
HighlightResults
"
)
{
return
runHighlight
(
browser
params
)
;
}
else
if
(
message
=
=
"
CollectResults
"
)
{
findResults
.
delete
(
getTopLevelActor
(
browser
)
)
;
return
collectFindResults
(
browser
findResults
params
)
;
}
}
this
.
find
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
return
{
find
:
{
find
(
queryphrase
params
)
{
params
=
params
|
|
{
}
;
params
.
queryphrase
=
queryphrase
;
return
runFindOperation
(
context
params
"
CollectResults
"
)
;
}
highlightResults
(
params
)
{
params
=
params
|
|
{
}
;
return
runFindOperation
(
context
params
"
HighlightResults
"
)
;
}
removeHighlighting
(
tabId
)
{
let
tab
=
tabId
?
tabTracker
.
getTab
(
tabId
)
:
tabTracker
.
activeTab
;
if
(
!
context
.
privateBrowsingAllowed
&
&
PrivateBrowsingUtils
.
isBrowserPrivate
(
tab
.
linkedBrowser
)
)
{
throw
new
ExtensionError
(
Invalid
tab
ID
:
{
tabId
}
)
;
}
sendMessageToAllActors
(
tab
.
linkedBrowser
"
ClearHighlighting
"
{
}
)
;
}
}
}
;
}
}
;
