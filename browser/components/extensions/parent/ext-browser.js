"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserWindowTracker
"
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AboutReaderParent
"
"
resource
:
/
/
/
actors
/
AboutReaderParent
.
jsm
"
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
var
{
defineLazyGetter
}
=
ExtensionCommon
;
const
READER_MODE_PREFIX
=
"
about
:
reader
"
;
let
tabTracker
;
let
windowTracker
;
function
isPrivateTab
(
nativeTab
)
{
return
PrivateBrowsingUtils
.
isBrowserPrivate
(
nativeTab
.
linkedBrowser
)
;
}
extensions
.
on
(
"
uninstalling
"
(
msg
extension
)
=
>
{
if
(
extension
.
uninstallURL
)
{
let
browser
=
windowTracker
.
topWindow
.
gBrowser
;
browser
.
addTab
(
extension
.
uninstallURL
{
disallowInheritPrincipal
:
true
relatedToCurrent
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
}
)
;
}
}
)
;
extensions
.
on
(
"
page
-
shutdown
"
(
type
context
)
=
>
{
if
(
context
.
viewType
=
=
"
tab
"
)
{
if
(
context
.
extension
.
id
!
=
=
context
.
xulBrowser
.
contentPrincipal
.
addonId
)
{
return
;
}
let
{
gBrowser
}
=
context
.
xulBrowser
.
ownerGlobal
;
if
(
gBrowser
&
&
gBrowser
.
getTabForBrowser
)
{
let
nativeTab
=
gBrowser
.
getTabForBrowser
(
context
.
xulBrowser
)
;
if
(
nativeTab
)
{
gBrowser
.
removeTab
(
nativeTab
)
;
}
}
}
}
)
;
global
.
openOptionsPage
=
extension
=
>
{
let
window
=
windowTracker
.
topWindow
;
if
(
!
window
)
{
return
Promise
.
reject
(
{
message
:
"
No
browser
window
available
"
}
)
;
}
if
(
extension
.
manifest
.
options_ui
.
open_in_tab
)
{
window
.
switchToTabHavingURI
(
extension
.
manifest
.
options_ui
.
page
true
{
triggeringPrincipal
:
extension
.
principal
}
)
;
return
Promise
.
resolve
(
)
;
}
let
viewId
=
addons
:
/
/
detail
/
{
encodeURIComponent
(
extension
.
id
)
}
/
preferences
;
return
window
.
BrowserOpenAddonsMgr
(
viewId
)
;
}
;
global
.
makeWidgetId
=
id
=
>
{
id
=
id
.
toLowerCase
(
)
;
return
id
.
replace
(
/
[
^
a
-
z0
-
9_
-
]
/
g
"
_
"
)
;
}
;
global
.
clickModifiersFromEvent
=
event
=
>
{
const
map
=
{
shiftKey
:
"
Shift
"
altKey
:
"
Alt
"
metaKey
:
"
Command
"
ctrlKey
:
"
Ctrl
"
}
;
let
modifiers
=
Object
.
keys
(
map
)
.
filter
(
key
=
>
event
[
key
]
)
.
map
(
key
=
>
map
[
key
]
)
;
if
(
event
.
ctrlKey
&
&
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
modifiers
.
push
(
"
MacCtrl
"
)
;
}
return
modifiers
;
}
;
global
.
waitForTabLoaded
=
(
tab
url
)
=
>
{
return
new
Promise
(
resolve
=
>
{
windowTracker
.
addListener
(
"
progress
"
{
onLocationChange
(
browser
webProgress
request
locationURI
flags
)
{
if
(
webProgress
.
isTopLevel
&
&
browser
.
ownerGlobal
.
gBrowser
.
getTabForBrowser
(
browser
)
=
=
tab
&
&
(
!
url
|
|
locationURI
.
spec
=
=
url
)
)
{
windowTracker
.
removeListener
(
"
progress
"
this
)
;
resolve
(
)
;
}
}
}
)
;
}
)
;
}
;
global
.
replaceUrlInTab
=
(
gBrowser
tab
url
)
=
>
{
let
loaded
=
waitForTabLoaded
(
tab
url
)
;
gBrowser
.
loadURI
(
url
{
flags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_REPLACE_HISTORY
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
return
loaded
;
}
;
global
.
TabContext
=
class
extends
EventEmitter
{
constructor
(
getDefaultPrototype
)
{
super
(
)
;
this
.
getDefaultPrototype
=
getDefaultPrototype
;
this
.
tabData
=
new
WeakMap
(
)
;
windowTracker
.
addListener
(
"
progress
"
this
)
;
windowTracker
.
addListener
(
"
TabSelect
"
this
)
;
this
.
tabAdopted
=
this
.
tabAdopted
.
bind
(
this
)
;
tabTracker
.
on
(
"
tab
-
adopted
"
this
.
tabAdopted
)
;
}
get
(
keyObject
)
{
if
(
!
this
.
tabData
.
has
(
keyObject
)
)
{
let
data
=
Object
.
create
(
this
.
getDefaultPrototype
(
keyObject
)
)
;
this
.
tabData
.
set
(
keyObject
data
)
;
}
return
this
.
tabData
.
get
(
keyObject
)
;
}
clear
(
keyObject
)
{
this
.
tabData
.
delete
(
keyObject
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
TabSelect
"
)
{
let
nativeTab
=
event
.
target
;
this
.
emit
(
"
tab
-
select
"
nativeTab
)
;
this
.
emit
(
"
location
-
change
"
nativeTab
)
;
}
}
onLocationChange
(
browser
webProgress
request
locationURI
flags
)
{
if
(
!
webProgress
.
isTopLevel
)
{
return
;
}
let
gBrowser
=
browser
.
ownerGlobal
.
gBrowser
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
let
fromBrowse
=
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
;
this
.
emit
(
"
location
-
change
"
tab
fromBrowse
)
;
}
tabAdopted
(
eventType
adoptingTab
adoptedTab
)
{
if
(
!
this
.
tabData
.
has
(
adoptedTab
)
)
{
return
;
}
let
newData
=
this
.
get
(
adoptingTab
)
;
let
oldData
=
this
.
tabData
.
get
(
adoptedTab
)
;
this
.
tabData
.
delete
(
adoptedTab
)
;
Object
.
assign
(
newData
oldData
)
;
}
shutdown
(
)
{
windowTracker
.
removeListener
(
"
progress
"
this
)
;
windowTracker
.
removeListener
(
"
TabSelect
"
this
)
;
tabTracker
.
off
(
"
tab
-
adopted
"
this
.
tabAdopted
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
global
"
searchInitialized
"
(
)
=
>
{
if
(
Services
.
search
.
isInitialized
)
{
return
Promise
.
resolve
(
)
;
}
return
ExtensionUtils
.
promiseObserved
(
"
browser
-
search
-
service
"
(
_
data
)
=
>
data
=
=
"
init
-
complete
"
)
;
}
)
;
class
WindowTracker
extends
WindowTrackerBase
{
addProgressListener
(
window
listener
)
{
window
.
gBrowser
.
addTabsProgressListener
(
listener
)
;
}
removeProgressListener
(
window
listener
)
{
window
.
gBrowser
.
removeTabsProgressListener
(
listener
)
;
}
getTopNormalWindow
(
context
)
{
let
options
=
{
allowPopups
:
false
}
;
if
(
!
context
.
privateBrowsingAllowed
)
{
options
.
private
=
false
;
}
return
BrowserWindowTracker
.
getTopWindow
(
options
)
;
}
}
class
TabTracker
extends
TabTrackerBase
{
constructor
(
)
{
super
(
)
;
this
.
_tabs
=
new
WeakMap
(
)
;
this
.
_browsers
=
new
WeakMap
(
)
;
this
.
_tabIds
=
new
Map
(
)
;
this
.
_nextId
=
1
;
this
.
_deferredTabOpenEvents
=
new
WeakMap
(
)
;
this
.
_handleTabDestroyed
=
this
.
_handleTabDestroyed
.
bind
(
this
)
;
}
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
this
.
adoptedTabs
=
new
WeakSet
(
)
;
this
.
_handleWindowOpen
=
this
.
_handleWindowOpen
.
bind
(
this
)
;
this
.
_handleWindowClose
=
this
.
_handleWindowClose
.
bind
(
this
)
;
windowTracker
.
addListener
(
"
TabClose
"
this
)
;
windowTracker
.
addListener
(
"
TabOpen
"
this
)
;
windowTracker
.
addListener
(
"
TabSelect
"
this
)
;
windowTracker
.
addListener
(
"
TabMultiSelect
"
this
)
;
windowTracker
.
addOpenListener
(
this
.
_handleWindowOpen
)
;
windowTracker
.
addCloseListener
(
this
.
_handleWindowClose
)
;
AboutReaderParent
.
addMessageListener
(
"
Reader
:
UpdateReaderButton
"
this
)
;
this
.
on
(
"
tab
-
detached
"
this
.
_handleTabDestroyed
)
;
this
.
on
(
"
tab
-
removed
"
this
.
_handleTabDestroyed
)
;
}
getId
(
nativeTab
)
{
let
id
=
this
.
_tabs
.
get
(
nativeTab
)
;
if
(
id
)
{
return
id
;
}
this
.
init
(
)
;
id
=
this
.
_nextId
+
+
;
this
.
setId
(
nativeTab
id
)
;
return
id
;
}
getBrowserTabId
(
browser
)
{
let
id
=
this
.
_browsers
.
get
(
browser
)
;
if
(
id
)
{
return
id
;
}
let
tab
=
browser
.
ownerGlobal
.
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
id
=
this
.
getId
(
tab
)
;
this
.
_browsers
.
set
(
browser
id
)
;
return
id
;
}
return
-
1
;
}
setId
(
nativeTab
id
)
{
if
(
!
nativeTab
.
parentNode
)
{
throw
new
Error
(
"
Cannot
attach
ID
to
a
destroyed
tab
.
"
)
;
}
if
(
nativeTab
.
ownerGlobal
.
closed
)
{
throw
new
Error
(
"
Cannot
attach
ID
to
a
tab
in
a
closed
window
.
"
)
;
}
this
.
_tabs
.
set
(
nativeTab
id
)
;
if
(
nativeTab
.
linkedBrowser
)
{
this
.
_browsers
.
set
(
nativeTab
.
linkedBrowser
id
)
;
}
this
.
_tabIds
.
set
(
id
nativeTab
)
;
}
adopt
(
adoptingTab
adoptedTab
)
{
if
(
this
.
adoptedTabs
.
has
(
adoptedTab
)
)
{
return
;
}
this
.
adoptedTabs
.
add
(
adoptedTab
)
;
let
tabId
=
this
.
getId
(
adoptedTab
)
;
this
.
setId
(
adoptingTab
tabId
)
;
this
.
emit
(
"
tab
-
adopted
"
adoptingTab
adoptedTab
)
;
if
(
this
.
has
(
"
tab
-
detached
"
)
)
{
let
nativeTab
=
adoptedTab
;
let
adoptedBy
=
adoptingTab
;
let
oldWindowId
=
windowTracker
.
getId
(
nativeTab
.
ownerGlobal
)
;
let
oldPosition
=
nativeTab
.
_tPos
;
this
.
emit
(
"
tab
-
detached
"
{
nativeTab
adoptedBy
tabId
oldWindowId
oldPosition
}
)
;
}
if
(
this
.
has
(
"
tab
-
attached
"
)
)
{
let
nativeTab
=
adoptingTab
;
let
newWindowId
=
windowTracker
.
getId
(
nativeTab
.
ownerGlobal
)
;
let
newPosition
=
nativeTab
.
_tPos
;
this
.
emit
(
"
tab
-
attached
"
{
nativeTab
tabId
newWindowId
newPosition
}
)
;
}
}
_handleTabDestroyed
(
event
{
nativeTab
}
)
{
let
id
=
this
.
_tabs
.
get
(
nativeTab
)
;
if
(
id
)
{
this
.
_tabs
.
delete
(
nativeTab
)
;
if
(
this
.
_tabIds
.
get
(
id
)
=
=
=
nativeTab
)
{
this
.
_tabIds
.
delete
(
id
)
;
}
}
}
getTab
(
tabId
default_
=
undefined
)
{
let
nativeTab
=
this
.
_tabIds
.
get
(
tabId
)
;
if
(
nativeTab
)
{
return
nativeTab
;
}
if
(
default_
!
=
=
undefined
)
{
return
default_
;
}
throw
new
ExtensionError
(
Invalid
tab
ID
:
{
tabId
}
)
;
}
setOpener
(
tab
openerTab
)
{
if
(
tab
.
ownerDocument
!
=
=
openerTab
.
ownerDocument
)
{
throw
new
Error
(
"
Tab
must
be
in
the
same
window
as
its
opener
"
)
;
}
tab
.
openerTab
=
openerTab
;
}
deferredForTabOpen
(
nativeTab
)
{
let
deferred
=
this
.
_deferredTabOpenEvents
.
get
(
nativeTab
)
;
if
(
!
deferred
)
{
deferred
=
PromiseUtils
.
defer
(
)
;
this
.
_deferredTabOpenEvents
.
set
(
nativeTab
deferred
)
;
deferred
.
promise
.
then
(
(
)
=
>
{
this
.
_deferredTabOpenEvents
.
delete
(
nativeTab
)
;
}
)
;
}
return
deferred
;
}
async
maybeWaitForTabOpen
(
nativeTab
)
{
let
deferred
=
this
.
_deferredTabOpenEvents
.
get
(
nativeTab
)
;
return
deferred
&
&
deferred
.
promise
;
}
handleEvent
(
event
)
{
let
nativeTab
=
event
.
target
;
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
let
{
adoptedTab
}
=
event
.
detail
;
if
(
adoptedTab
)
{
this
.
adopt
(
nativeTab
adoptedTab
)
;
}
else
{
const
currentTab
=
nativeTab
.
ownerGlobal
.
gBrowser
.
selectedTab
;
const
{
frameLoader
}
=
currentTab
.
linkedBrowser
;
const
currentTabSize
=
{
width
:
frameLoader
.
lazyWidth
height
:
frameLoader
.
lazyHeight
}
;
let
deferred
=
this
.
deferredForTabOpen
(
event
.
originalTarget
)
;
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
deferred
.
resolve
(
)
;
if
(
!
event
.
originalTarget
.
parentNode
)
{
return
;
}
this
.
emitCreated
(
event
.
originalTarget
currentTabSize
)
;
}
)
;
}
break
;
case
"
TabClose
"
:
let
{
adoptedBy
}
=
event
.
detail
;
if
(
adoptedBy
)
{
this
.
adopt
(
adoptedBy
nativeTab
)
;
}
else
{
this
.
emitRemoved
(
nativeTab
false
)
;
}
break
;
case
"
TabSelect
"
:
this
.
maybeWaitForTabOpen
(
nativeTab
)
.
then
(
(
)
=
>
{
if
(
!
nativeTab
.
parentNode
)
{
return
;
}
this
.
emitActivated
(
nativeTab
event
.
detail
.
previousTab
)
;
}
)
;
break
;
case
"
TabMultiSelect
"
:
if
(
this
.
has
(
"
tabs
-
highlighted
"
)
)
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
this
.
emitHighlighted
(
event
.
target
.
ownerGlobal
)
;
}
)
;
}
break
;
}
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
Reader
:
UpdateReaderButton
"
:
if
(
message
.
data
&
&
message
.
data
.
isArticle
!
=
=
undefined
)
{
this
.
emit
(
"
tab
-
isarticle
"
message
)
;
}
break
;
}
}
_handleWindowOpen
(
window
)
{
const
tabToAdopt
=
window
.
gBrowserInit
.
getTabToAdopt
(
)
;
if
(
tabToAdopt
)
{
let
adoptedBy
=
window
.
gBrowser
.
tabs
[
0
]
;
this
.
adopt
(
adoptedBy
tabToAdopt
)
;
}
else
{
for
(
let
nativeTab
of
window
.
gBrowser
.
tabs
)
{
this
.
emitCreated
(
nativeTab
)
;
}
this
.
emitActivated
(
window
.
gBrowser
.
tabs
[
0
]
)
;
if
(
this
.
has
(
"
tabs
-
highlighted
"
)
)
{
this
.
emitHighlighted
(
window
)
;
}
}
}
_handleWindowClose
(
window
)
{
for
(
let
nativeTab
of
window
.
gBrowser
.
tabs
)
{
if
(
!
this
.
adoptedTabs
.
has
(
nativeTab
)
)
{
this
.
emitRemoved
(
nativeTab
true
)
;
}
}
}
emitActivated
(
nativeTab
previousTab
=
undefined
)
{
let
previousTabIsPrivate
previousTabId
;
if
(
previousTab
&
&
!
previousTab
.
closing
)
{
previousTabId
=
this
.
getId
(
previousTab
)
;
previousTabIsPrivate
=
isPrivateTab
(
previousTab
)
;
}
this
.
emit
(
"
tab
-
activated
"
{
tabId
:
this
.
getId
(
nativeTab
)
previousTabId
previousTabIsPrivate
windowId
:
windowTracker
.
getId
(
nativeTab
.
ownerGlobal
)
nativeTab
}
)
;
}
emitHighlighted
(
window
)
{
let
tabIds
=
window
.
gBrowser
.
selectedTabs
.
map
(
tab
=
>
this
.
getId
(
tab
)
)
;
let
windowId
=
windowTracker
.
getId
(
window
)
;
this
.
emit
(
"
tabs
-
highlighted
"
{
tabIds
windowId
}
)
;
}
emitCreated
(
nativeTab
currentTabSize
)
{
this
.
emit
(
"
tab
-
created
"
{
nativeTab
currentTabSize
}
)
;
}
emitRemoved
(
nativeTab
isWindowClosing
)
{
let
windowId
=
windowTracker
.
getId
(
nativeTab
.
ownerGlobal
)
;
let
tabId
=
this
.
getId
(
nativeTab
)
;
this
.
emit
(
"
tab
-
removed
"
{
nativeTab
tabId
windowId
isWindowClosing
}
)
;
}
getBrowserData
(
browser
)
{
let
window
=
browser
.
ownerGlobal
;
if
(
!
window
)
{
return
{
tabId
:
-
1
windowId
:
-
1
}
;
}
let
{
gBrowser
}
=
window
;
if
(
!
gBrowser
|
|
!
gBrowser
.
getTabForBrowser
)
{
if
(
window
.
top
.
document
.
documentURI
=
=
=
"
about
:
addons
"
)
{
browser
=
window
.
docShell
.
chromeEventHandler
;
(
{
gBrowser
}
=
browser
.
ownerGlobal
)
;
}
else
{
return
{
tabId
:
-
1
windowId
:
-
1
}
;
}
}
return
{
tabId
:
this
.
getBrowserTabId
(
browser
)
windowId
:
windowTracker
.
getId
(
browser
.
ownerGlobal
)
}
;
}
get
activeTab
(
)
{
let
window
=
windowTracker
.
topWindow
;
if
(
window
&
&
window
.
gBrowser
)
{
return
window
.
gBrowser
.
selectedTab
;
}
return
null
;
}
}
windowTracker
=
new
WindowTracker
(
)
;
tabTracker
=
new
TabTracker
(
)
;
Object
.
assign
(
global
{
tabTracker
windowTracker
}
)
;
class
Tab
extends
TabBase
{
get
_favIconUrl
(
)
{
return
this
.
window
.
gBrowser
.
getIcon
(
this
.
nativeTab
)
;
}
get
attention
(
)
{
return
this
.
nativeTab
.
hasAttribute
(
"
attention
"
)
;
}
get
audible
(
)
{
return
this
.
nativeTab
.
soundPlaying
;
}
get
browser
(
)
{
return
this
.
nativeTab
.
linkedBrowser
;
}
get
discarded
(
)
{
return
!
this
.
nativeTab
.
linkedPanel
;
}
get
frameLoader
(
)
{
return
super
.
frameLoader
|
|
{
lazyWidth
:
0
lazyHeight
:
0
}
;
}
get
hidden
(
)
{
return
this
.
nativeTab
.
hidden
;
}
get
sharingState
(
)
{
return
this
.
window
.
gBrowser
.
getTabSharingState
(
this
.
nativeTab
)
;
}
get
cookieStoreId
(
)
{
return
getCookieStoreIdForTab
(
this
this
.
nativeTab
)
;
}
get
openerTabId
(
)
{
let
opener
=
this
.
nativeTab
.
openerTab
;
if
(
opener
&
&
opener
.
parentNode
&
&
opener
.
ownerDocument
=
=
this
.
nativeTab
.
ownerDocument
)
{
return
tabTracker
.
getId
(
opener
)
;
}
return
null
;
}
get
height
(
)
{
return
this
.
frameLoader
.
lazyHeight
;
}
get
index
(
)
{
return
this
.
nativeTab
.
_tPos
;
}
get
mutedInfo
(
)
{
let
{
nativeTab
}
=
this
;
let
mutedInfo
=
{
muted
:
nativeTab
.
muted
}
;
if
(
nativeTab
.
muteReason
=
=
=
null
)
{
mutedInfo
.
reason
=
"
user
"
;
}
else
if
(
nativeTab
.
muteReason
)
{
mutedInfo
.
reason
=
"
extension
"
;
mutedInfo
.
extensionId
=
nativeTab
.
muteReason
;
}
return
mutedInfo
;
}
get
lastAccessed
(
)
{
return
this
.
nativeTab
.
lastAccessed
;
}
get
pinned
(
)
{
return
this
.
nativeTab
.
pinned
;
}
get
active
(
)
{
return
this
.
nativeTab
.
selected
;
}
get
highlighted
(
)
{
let
{
selected
multiselected
}
=
this
.
nativeTab
;
return
selected
|
|
multiselected
;
}
get
status
(
)
{
if
(
this
.
nativeTab
.
getAttribute
(
"
busy
"
)
=
=
=
"
true
"
)
{
return
"
loading
"
;
}
return
"
complete
"
;
}
get
width
(
)
{
return
this
.
frameLoader
.
lazyWidth
;
}
get
window
(
)
{
return
this
.
nativeTab
.
ownerGlobal
;
}
get
windowId
(
)
{
return
windowTracker
.
getId
(
this
.
window
)
;
}
get
isArticle
(
)
{
return
this
.
nativeTab
.
linkedBrowser
.
isArticle
;
}
get
isInReaderMode
(
)
{
return
this
.
url
&
&
this
.
url
.
startsWith
(
READER_MODE_PREFIX
)
;
}
get
successorTabId
(
)
{
const
{
successor
}
=
this
.
nativeTab
;
return
successor
?
tabTracker
.
getId
(
successor
)
:
-
1
;
}
static
convertFromSessionStoreClosedData
(
extension
tabData
window
=
null
)
{
let
result
=
{
sessionId
:
String
(
tabData
.
closedId
)
index
:
tabData
.
pos
?
tabData
.
pos
:
0
windowId
:
window
&
&
windowTracker
.
getId
(
window
)
highlighted
:
false
active
:
false
pinned
:
false
hidden
:
tabData
.
state
?
tabData
.
state
.
hidden
:
tabData
.
hidden
incognito
:
Boolean
(
tabData
.
state
&
&
tabData
.
state
.
isPrivate
)
lastAccessed
:
tabData
.
state
?
tabData
.
state
.
lastAccessed
:
tabData
.
lastAccessed
}
;
let
entries
=
tabData
.
state
?
tabData
.
state
.
entries
:
tabData
.
entries
;
let
lastTabIndex
=
tabData
.
state
?
tabData
.
state
.
index
:
tabData
.
index
;
if
(
entries
.
length
)
{
let
entry
=
entries
[
lastTabIndex
-
1
]
;
if
(
extension
.
hasPermission
(
"
tabs
"
)
|
|
extension
.
allowedOrigins
.
matches
(
entry
.
url
)
)
{
result
.
url
=
entry
.
url
;
result
.
title
=
entry
.
title
;
if
(
tabData
.
image
)
{
result
.
favIconUrl
=
tabData
.
image
;
}
}
}
return
result
;
}
}
class
Window
extends
WindowBase
{
updateGeometry
(
options
)
{
let
{
window
}
=
this
;
if
(
options
.
left
!
=
=
null
|
|
options
.
top
!
=
=
null
)
{
let
left
=
options
.
left
!
=
=
null
?
options
.
left
:
window
.
screenX
;
let
top
=
options
.
top
!
=
=
null
?
options
.
top
:
window
.
screenY
;
window
.
moveTo
(
left
top
)
;
}
if
(
options
.
width
!
=
=
null
|
|
options
.
height
!
=
=
null
)
{
let
width
=
options
.
width
!
=
=
null
?
options
.
width
:
window
.
outerWidth
;
let
height
=
options
.
height
!
=
=
null
?
options
.
height
:
window
.
outerHeight
;
window
.
resizeTo
(
width
height
)
;
}
}
get
_title
(
)
{
return
this
.
window
.
document
.
title
;
}
setTitlePreface
(
titlePreface
)
{
this
.
window
.
document
.
documentElement
.
setAttribute
(
"
titlepreface
"
titlePreface
)
;
}
get
focused
(
)
{
return
this
.
window
.
document
.
hasFocus
(
)
;
}
get
top
(
)
{
return
this
.
window
.
screenY
;
}
get
left
(
)
{
return
this
.
window
.
screenX
;
}
get
width
(
)
{
return
this
.
window
.
outerWidth
;
}
get
height
(
)
{
return
this
.
window
.
outerHeight
;
}
get
incognito
(
)
{
return
PrivateBrowsingUtils
.
isWindowPrivate
(
this
.
window
)
;
}
get
alwaysOnTop
(
)
{
return
this
.
appWindow
.
zLevel
>
=
Ci
.
nsIAppWindow
.
raisedZ
;
}
get
isLastFocused
(
)
{
return
this
.
window
=
=
=
windowTracker
.
topWindow
;
}
static
getState
(
window
)
{
const
STATES
=
{
[
window
.
STATE_MAXIMIZED
]
:
"
maximized
"
[
window
.
STATE_MINIMIZED
]
:
"
minimized
"
[
window
.
STATE_FULLSCREEN
]
:
"
fullscreen
"
[
window
.
STATE_NORMAL
]
:
"
normal
"
}
;
return
STATES
[
window
.
windowState
]
;
}
get
state
(
)
{
return
Window
.
getState
(
this
.
window
)
;
}
async
setState
(
state
)
{
let
{
window
}
=
this
;
const
expectedState
=
(
function
(
)
{
switch
(
state
)
{
case
"
maximized
"
:
return
window
.
STATE_MAXIMIZED
;
case
"
minimized
"
:
case
"
docked
"
:
return
window
.
STATE_MINIMIZED
;
case
"
normal
"
:
return
window
.
STATE_NORMAL
;
case
"
fullscreen
"
:
return
window
.
STATE_FULLSCREEN
;
}
throw
new
Error
(
Unexpected
window
state
:
{
state
}
)
;
}
)
(
)
;
const
initialState
=
window
.
windowState
;
if
(
expectedState
=
=
initialState
)
{
return
;
}
if
(
initialState
=
=
window
.
STATE_FULLSCREEN
|
|
window
.
fullScreen
)
{
window
.
fullScreen
=
false
;
}
switch
(
expectedState
)
{
case
window
.
STATE_MAXIMIZED
:
window
.
maximize
(
)
;
break
;
case
window
.
STATE_MINIMIZED
:
window
.
minimize
(
)
;
break
;
case
window
.
STATE_NORMAL
:
window
.
restore
(
)
;
if
(
window
.
windowState
!
=
=
window
.
STATE_NORMAL
)
{
window
.
restore
(
)
;
}
if
(
window
.
windowState
!
=
=
window
.
STATE_NORMAL
)
{
window
.
sizeToContent
(
)
;
}
break
;
case
window
.
STATE_FULLSCREEN
:
window
.
fullScreen
=
true
;
break
;
default
:
throw
new
Error
(
Unexpected
window
state
:
{
state
}
)
;
}
if
(
window
.
windowState
!
=
expectedState
)
{
const
noWindowManagerTimeout
=
2000
;
let
onSizeModeChange
;
const
promiseExpectedSizeMode
=
new
Promise
(
resolve
=
>
{
onSizeModeChange
=
function
(
)
{
if
(
window
.
windowState
=
=
expectedState
)
{
resolve
(
)
;
}
}
;
window
.
addEventListener
(
"
sizemodechange
"
onSizeModeChange
)
;
}
)
;
await
Promise
.
any
(
[
promiseExpectedSizeMode
new
Promise
(
resolve
=
>
setTimeout
(
resolve
noWindowManagerTimeout
)
)
]
)
;
window
.
removeEventListener
(
"
sizemodechange
"
onSizeModeChange
)
;
}
}
*
getTabs
(
)
{
if
(
this
.
window
.
gBrowserInit
.
isAdoptingTab
(
)
)
{
return
;
}
let
{
tabManager
}
=
this
.
extension
;
for
(
let
nativeTab
of
this
.
window
.
gBrowser
.
tabs
)
{
let
tab
=
tabManager
.
getWrapper
(
nativeTab
)
;
if
(
tab
)
{
yield
tab
;
}
}
}
*
getHighlightedTabs
(
)
{
let
{
tabManager
}
=
this
.
extension
;
for
(
let
nativeTab
of
this
.
window
.
gBrowser
.
selectedTabs
)
{
let
tab
=
tabManager
.
getWrapper
(
nativeTab
)
;
if
(
tab
)
{
yield
tab
;
}
}
}
get
activeTab
(
)
{
let
{
tabManager
}
=
this
.
extension
;
if
(
this
.
window
.
gBrowserInit
.
isAdoptingTab
(
)
)
{
return
null
;
}
return
tabManager
.
getWrapper
(
this
.
window
.
gBrowser
.
selectedTab
)
;
}
getTabAtIndex
(
index
)
{
let
nativeTab
=
this
.
window
.
gBrowser
.
tabs
[
index
]
;
if
(
nativeTab
)
{
return
this
.
extension
.
tabManager
.
getWrapper
(
nativeTab
)
;
}
}
static
convertFromSessionStoreClosedData
(
extension
windowData
)
{
let
result
=
{
sessionId
:
String
(
windowData
.
closedId
)
focused
:
false
incognito
:
false
type
:
"
normal
"
state
:
"
normal
"
alwaysOnTop
:
false
}
;
if
(
windowData
.
tabs
.
length
)
{
result
.
tabs
=
windowData
.
tabs
.
map
(
tabData
=
>
{
return
Tab
.
convertFromSessionStoreClosedData
(
extension
tabData
)
;
}
)
;
}
return
result
;
}
}
Object
.
assign
(
global
{
Tab
Window
}
)
;
class
TabManager
extends
TabManagerBase
{
get
(
tabId
default_
=
undefined
)
{
let
nativeTab
=
tabTracker
.
getTab
(
tabId
default_
)
;
if
(
nativeTab
)
{
if
(
!
this
.
canAccessTab
(
nativeTab
)
)
{
throw
new
ExtensionError
(
Invalid
tab
ID
:
{
tabId
}
)
;
}
return
this
.
getWrapper
(
nativeTab
)
;
}
return
default_
;
}
addActiveTabPermission
(
nativeTab
=
tabTracker
.
activeTab
)
{
return
super
.
addActiveTabPermission
(
nativeTab
)
;
}
revokeActiveTabPermission
(
nativeTab
=
tabTracker
.
activeTab
)
{
return
super
.
revokeActiveTabPermission
(
nativeTab
)
;
}
canAccessTab
(
nativeTab
)
{
if
(
!
this
.
extension
.
canAccessWindow
(
nativeTab
.
ownerGlobal
)
)
{
return
false
;
}
if
(
this
.
extension
.
userContextIsolation
&
&
!
this
.
extension
.
canAccessContainer
(
nativeTab
.
userContextId
)
)
{
return
false
;
}
return
true
;
}
wrapTab
(
nativeTab
)
{
return
new
Tab
(
this
.
extension
nativeTab
tabTracker
.
getId
(
nativeTab
)
)
;
}
}
class
WindowManager
extends
WindowManagerBase
{
get
(
windowId
context
)
{
let
window
=
windowTracker
.
getWindow
(
windowId
context
)
;
return
this
.
getWrapper
(
window
)
;
}
*
getAll
(
context
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
if
(
!
this
.
canAccessWindow
(
window
context
)
)
{
continue
;
}
let
wrapped
=
this
.
getWrapper
(
window
)
;
if
(
wrapped
)
{
yield
wrapped
;
}
}
}
wrapWindow
(
window
)
{
return
new
Window
(
this
.
extension
window
windowTracker
.
getId
(
window
)
)
;
}
}
extensions
.
on
(
"
startup
"
(
type
extension
)
=
>
{
defineLazyGetter
(
extension
"
tabManager
"
(
)
=
>
new
TabManager
(
extension
)
)
;
defineLazyGetter
(
extension
"
windowManager
"
(
)
=
>
new
WindowManager
(
extension
)
)
;
}
)
;
