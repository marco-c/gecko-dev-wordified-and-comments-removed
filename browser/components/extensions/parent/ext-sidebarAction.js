"
use
strict
"
;
var
{
ExtensionParent
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
sys
.
mjs
"
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
var
{
IconDetails
}
=
ExtensionParent
;
let
sidebarActionMap
=
new
WeakMap
(
)
;
this
.
sidebarAction
=
class
extends
ExtensionAPI
{
static
for
(
extension
)
{
return
sidebarActionMap
.
get
(
extension
)
;
}
onManifestEntry
(
)
{
let
{
extension
}
=
this
;
extension
.
once
(
"
ready
"
this
.
onReady
.
bind
(
this
)
)
;
let
options
=
extension
.
manifest
.
sidebar_action
;
let
widgetId
=
makeWidgetId
(
extension
.
id
)
;
this
.
id
=
{
widgetId
}
-
sidebar
-
action
;
this
.
menuId
=
menubar_menu_
{
this
.
id
}
;
this
.
browserStyle
=
options
.
browser_style
;
this
.
defaults
=
{
enabled
:
true
title
:
options
.
default_title
|
|
extension
.
name
icon
:
IconDetails
.
normalize
(
{
path
:
options
.
default_icon
}
extension
)
panel
:
options
.
default_panel
|
|
"
"
}
;
this
.
globals
=
Object
.
create
(
this
.
defaults
)
;
this
.
tabContext
=
new
TabContext
(
target
=
>
{
let
window
=
target
.
ownerGlobal
;
if
(
target
=
=
=
window
)
{
return
this
.
globals
;
}
return
this
.
tabContext
.
get
(
window
)
;
}
)
;
this
.
windowOpenListener
=
window
=
>
{
this
.
createMenuItem
(
window
this
.
globals
)
;
}
;
windowTracker
.
addOpenListener
(
this
.
windowOpenListener
)
;
sidebarActionMap
.
set
(
extension
this
)
;
}
onReady
(
)
{
this
.
build
(
)
;
}
onShutdown
(
isAppShutdown
)
{
sidebarActionMap
.
delete
(
this
.
extension
)
;
this
.
tabContext
.
shutdown
(
)
;
if
(
isAppShutdown
)
{
return
;
}
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
let
{
SidebarController
}
=
window
;
SidebarController
.
removeExtension
(
this
.
id
)
;
}
windowTracker
.
removeOpenListener
(
this
.
windowOpenListener
)
;
}
static
onUninstall
(
id
)
{
const
sidebarId
=
{
makeWidgetId
(
id
)
}
-
sidebar
-
action
;
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
let
{
SidebarController
}
=
window
;
if
(
SidebarController
.
lastOpenedId
=
=
=
sidebarId
)
{
SidebarController
.
lastOpenedId
=
null
;
}
}
}
build
(
)
{
this
.
tabContext
.
on
(
"
tab
-
select
"
(
evt
tab
)
=
>
{
this
.
updateWindow
(
tab
.
ownerGlobal
)
;
}
)
;
let
install
=
this
.
extension
.
startupReason
=
=
=
"
ADDON_INSTALL
"
;
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
updateWindow
(
window
)
;
let
{
SidebarController
}
=
window
;
if
(
(
install
&
&
this
.
extension
.
manifest
.
sidebar_action
.
open_at_install
)
|
|
SidebarController
.
lastOpenedId
=
=
this
.
id
)
{
SidebarController
.
show
(
this
.
id
)
;
}
}
}
createMenuItem
(
window
details
)
{
if
(
!
this
.
extension
.
canAccessWindow
(
window
)
)
{
return
;
}
this
.
panel
=
details
.
panel
;
let
{
SidebarController
}
=
window
;
SidebarController
.
registerExtension
(
this
.
id
{
icon
:
this
.
getMenuIcon
(
details
)
menuId
:
this
.
menuId
title
:
details
.
title
extensionId
:
this
.
extension
.
id
onload
:
(
)
=
>
SidebarController
.
browser
.
contentWindow
.
loadPanel
(
this
.
extension
.
id
this
.
panel
this
.
browserStyle
)
}
)
;
}
getMenuIcon
(
details
)
{
let
getIcon
=
size
=
>
IconDetails
.
escapeUrl
(
IconDetails
.
getPreferredIcon
(
details
.
icon
this
.
extension
size
)
.
icon
)
;
return
image
-
set
(
url
(
"
{
getIcon
(
16
)
}
"
)
url
(
"
{
getIcon
(
32
)
}
"
)
2x
)
;
}
updateButton
(
window
tabData
)
{
let
{
document
SidebarController
}
=
window
;
let
title
=
tabData
.
title
|
|
this
.
extension
.
name
;
if
(
!
document
.
getElementById
(
this
.
menuId
)
)
{
this
.
createMenuItem
(
window
tabData
)
;
}
let
urlChanged
=
tabData
.
panel
!
=
=
this
.
panel
;
if
(
urlChanged
)
{
this
.
panel
=
tabData
.
panel
;
}
SidebarController
.
setExtensionAttributes
(
this
.
id
{
icon
:
this
.
getMenuIcon
(
tabData
)
label
:
title
}
urlChanged
)
;
}
updateWindow
(
window
)
{
if
(
!
this
.
extension
.
canAccessWindow
(
window
)
)
{
return
;
}
let
nativeTab
=
window
.
gBrowser
.
selectedTab
;
this
.
updateButton
(
window
this
.
tabContext
.
get
(
nativeTab
)
)
;
}
updateOnChange
(
target
)
{
if
(
target
)
{
let
window
=
target
.
ownerGlobal
;
if
(
target
=
=
=
window
|
|
target
.
selected
)
{
this
.
updateWindow
(
window
)
;
}
}
else
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
updateWindow
(
window
)
;
}
}
}
getTargetFromDetails
(
{
tabId
windowId
}
)
{
if
(
tabId
!
=
null
&
&
windowId
!
=
null
)
{
throw
new
ExtensionError
(
"
Only
one
of
tabId
and
windowId
can
be
specified
.
"
)
;
}
let
target
=
null
;
if
(
tabId
!
=
null
)
{
target
=
tabTracker
.
getTab
(
tabId
)
;
if
(
!
this
.
extension
.
canAccessWindow
(
target
.
ownerGlobal
)
)
{
throw
new
ExtensionError
(
Invalid
tab
ID
:
{
tabId
}
)
;
}
}
else
if
(
windowId
!
=
null
)
{
target
=
windowTracker
.
getWindow
(
windowId
)
;
if
(
!
this
.
extension
.
canAccessWindow
(
target
)
)
{
throw
new
ExtensionError
(
Invalid
window
ID
:
{
windowId
}
)
;
}
}
return
target
;
}
getContextData
(
target
)
{
if
(
target
)
{
return
this
.
tabContext
.
get
(
target
)
;
}
return
this
.
globals
;
}
setProperty
(
target
prop
value
)
{
let
values
=
this
.
getContextData
(
target
)
;
if
(
value
=
=
=
null
)
{
delete
values
[
prop
]
;
}
else
{
values
[
prop
]
=
value
;
}
this
.
updateOnChange
(
target
)
;
}
getProperty
(
target
prop
)
{
return
this
.
getContextData
(
target
)
[
prop
]
;
}
setPropertyFromDetails
(
details
prop
value
)
{
return
this
.
setProperty
(
this
.
getTargetFromDetails
(
details
)
prop
value
)
;
}
getPropertyFromDetails
(
details
prop
)
{
return
this
.
getProperty
(
this
.
getTargetFromDetails
(
details
)
prop
)
;
}
triggerAction
(
window
)
{
let
{
SidebarController
}
=
window
;
if
(
SidebarController
&
&
this
.
extension
.
canAccessWindow
(
window
)
)
{
SidebarController
.
toggle
(
this
.
id
)
;
}
}
open
(
window
)
{
let
{
SidebarController
}
=
window
;
if
(
SidebarController
&
&
this
.
extension
.
canAccessWindow
(
window
)
)
{
SidebarController
.
show
(
this
.
id
)
;
}
}
close
(
window
)
{
if
(
this
.
isOpen
(
window
)
)
{
window
.
SidebarController
.
hide
(
)
;
}
}
toggle
(
window
)
{
let
{
SidebarController
}
=
window
;
if
(
!
SidebarController
|
|
!
this
.
extension
.
canAccessWindow
(
window
)
)
{
return
;
}
if
(
!
this
.
isOpen
(
window
)
)
{
SidebarController
.
show
(
this
.
id
)
;
}
else
{
SidebarController
.
hide
(
)
;
}
}
isOpen
(
window
)
{
let
{
SidebarController
}
=
window
;
return
SidebarController
.
isOpen
&
&
this
.
id
=
=
SidebarController
.
currentID
;
}
getAPI
(
context
)
{
let
{
extension
}
=
context
;
const
sidebarAction
=
this
;
return
{
sidebarAction
:
{
async
setTitle
(
details
)
{
sidebarAction
.
setPropertyFromDetails
(
details
"
title
"
details
.
title
)
;
}
getTitle
(
details
)
{
return
sidebarAction
.
getPropertyFromDetails
(
details
"
title
"
)
;
}
async
setIcon
(
details
)
{
let
icon
=
IconDetails
.
normalize
(
details
extension
context
)
;
if
(
!
Object
.
keys
(
icon
)
.
length
)
{
icon
=
null
;
}
sidebarAction
.
setPropertyFromDetails
(
details
"
icon
"
icon
)
;
}
async
setPanel
(
details
)
{
let
url
;
if
(
!
details
.
panel
)
{
url
=
null
;
}
else
{
url
=
context
.
uri
.
resolve
(
details
.
panel
)
;
if
(
!
context
.
checkLoadURL
(
url
)
)
{
return
Promise
.
reject
(
{
message
:
Access
denied
for
URL
{
url
}
}
)
;
}
}
sidebarAction
.
setPropertyFromDetails
(
details
"
panel
"
url
)
;
}
getPanel
(
details
)
{
return
sidebarAction
.
getPropertyFromDetails
(
details
"
panel
"
)
;
}
open
(
)
{
let
window
=
windowTracker
.
topWindow
;
if
(
context
.
canAccessWindow
(
window
)
)
{
sidebarAction
.
open
(
window
)
;
}
}
close
(
)
{
let
window
=
windowTracker
.
topWindow
;
if
(
context
.
canAccessWindow
(
window
)
)
{
sidebarAction
.
close
(
window
)
;
}
}
toggle
(
)
{
let
window
=
windowTracker
.
topWindow
;
if
(
context
.
canAccessWindow
(
window
)
)
{
sidebarAction
.
toggle
(
window
)
;
}
}
isOpen
(
details
)
{
let
{
windowId
}
=
details
;
if
(
windowId
=
=
null
)
{
windowId
=
Window
.
WINDOW_ID_CURRENT
;
}
let
window
=
windowTracker
.
getWindow
(
windowId
context
)
;
return
sidebarAction
.
isOpen
(
window
)
;
}
}
}
;
}
}
;
global
.
sidebarActionFor
=
this
.
sidebarAction
.
for
;
