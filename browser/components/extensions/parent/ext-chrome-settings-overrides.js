"
use
strict
"
;
var
{
ExtensionPreferencesManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionPreferencesManager
.
jsm
"
)
;
var
{
ExtensionParent
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionControlledPopup
"
"
resource
:
/
/
/
modules
/
ExtensionControlledPopup
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
HomePage
"
"
resource
:
/
/
/
modules
/
HomePage
.
jsm
"
)
;
const
DEFAULT_SEARCH_STORE_TYPE
=
"
default_search
"
;
const
DEFAULT_SEARCH_SETTING_NAME
=
"
defaultSearch
"
;
const
ENGINE_ADDED_SETTING_NAME
=
"
engineAdded
"
;
const
HOMEPAGE_PREF
=
"
browser
.
startup
.
homepage
"
;
const
HOMEPAGE_PRIVATE_ALLOWED
=
"
browser
.
startup
.
homepage_override
.
privateAllowed
"
;
const
HOMEPAGE_EXTENSION_CONTROLLED
=
"
browser
.
startup
.
homepage_override
.
extensionControlled
"
;
const
HOMEPAGE_CONFIRMED_TYPE
=
"
homepageNotification
"
;
const
HOMEPAGE_SETTING_TYPE
=
"
prefs
"
;
const
HOMEPAGE_SETTING_NAME
=
"
homepage_override
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
homepagePopup
"
(
)
=
>
{
return
new
ExtensionControlledPopup
(
{
confirmedType
:
HOMEPAGE_CONFIRMED_TYPE
observerTopic
:
"
browser
-
open
-
homepage
-
start
"
popupnotificationId
:
"
extension
-
homepage
-
notification
"
settingType
:
HOMEPAGE_SETTING_TYPE
settingKey
:
HOMEPAGE_SETTING_NAME
descriptionId
:
"
extension
-
homepage
-
notification
-
description
"
descriptionMessageId
:
"
homepageControlled
.
message
"
learnMoreMessageId
:
"
homepageControlled
.
learnMore
"
learnMoreLink
:
"
extension
-
home
"
async
beforeDisableAddon
(
popup
win
)
{
let
gBrowser
=
win
.
gBrowser
;
let
tab
=
gBrowser
.
selectedTab
;
await
replaceUrlInTab
(
gBrowser
tab
"
about
:
blank
"
)
;
Services
.
prefs
.
addObserver
(
HOMEPAGE_PREF
async
function
prefObserver
(
)
{
Services
.
prefs
.
removeObserver
(
HOMEPAGE_PREF
prefObserver
)
;
let
loaded
=
waitForTabLoaded
(
tab
)
;
win
.
BrowserHome
(
)
;
await
loaded
;
popup
.
open
(
)
;
}
)
;
}
}
)
;
}
)
;
async
function
handleInitialHomepagePopup
(
extensionId
homepageUrl
)
{
if
(
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
page
"
)
=
=
1
&
&
windowTracker
.
topWindow
)
{
let
{
gBrowser
}
=
windowTracker
.
topWindow
;
let
tab
=
gBrowser
.
selectedTab
;
let
currentUrl
=
gBrowser
.
currentURI
.
spec
;
if
(
currentUrl
!
=
homepageUrl
&
&
currentUrl
=
=
"
about
:
blank
"
)
{
await
waitForTabLoaded
(
tab
)
;
currentUrl
=
gBrowser
.
currentURI
.
spec
;
}
if
(
currentUrl
=
=
homepageUrl
&
&
gBrowser
.
selectedTab
=
=
tab
)
{
homepagePopup
.
open
(
)
;
return
;
}
}
homepagePopup
.
addObserver
(
extensionId
)
;
}
async
function
handleHomepageUrl
(
extension
homepageUrl
)
{
let
inControl
;
if
(
extension
.
startupReason
=
=
"
ADDON_INSTALL
"
|
|
extension
.
startupReason
=
=
"
ADDON_ENABLE
"
)
{
inControl
=
await
ExtensionPreferencesManager
.
setSetting
(
extension
.
id
"
homepage_override
"
homepageUrl
)
;
}
else
{
let
item
=
await
ExtensionPreferencesManager
.
getSetting
(
"
homepage_override
"
)
;
inControl
=
item
&
&
item
.
id
=
=
extension
.
id
;
}
if
(
inControl
)
{
Services
.
prefs
.
setBoolPref
(
HOMEPAGE_PRIVATE_ALLOWED
extension
.
privateBrowsingAllowed
)
;
Services
.
prefs
.
setBoolPref
(
HOMEPAGE_EXTENSION_CONTROLLED
true
)
;
if
(
extension
.
startupReason
=
=
"
APP_STARTUP
"
)
{
handleInitialHomepagePopup
(
extension
.
id
homepageUrl
)
;
}
else
{
homepagePopup
.
addObserver
(
extension
.
id
)
;
}
}
extension
.
on
(
"
add
-
permissions
"
async
(
ignoreEvent
permissions
)
=
>
{
if
(
permissions
.
permissions
.
includes
(
"
internal
:
privateBrowsingAllowed
"
)
)
{
let
item
=
await
ExtensionPreferencesManager
.
getSetting
(
"
homepage_override
"
)
;
if
(
item
&
&
item
.
id
=
=
extension
.
id
)
{
Services
.
prefs
.
setBoolPref
(
HOMEPAGE_PRIVATE_ALLOWED
true
)
;
}
}
}
)
;
extension
.
on
(
"
remove
-
permissions
"
async
(
ignoreEvent
permissions
)
=
>
{
if
(
permissions
.
permissions
.
includes
(
"
internal
:
privateBrowsingAllowed
"
)
)
{
let
item
=
await
ExtensionPreferencesManager
.
getSetting
(
"
homepage_override
"
)
;
if
(
item
&
&
item
.
id
=
=
extension
.
id
)
{
Services
.
prefs
.
setBoolPref
(
HOMEPAGE_PRIVATE_ALLOWED
false
)
;
}
}
}
)
;
}
var
pendingSearchSetupTasks
=
new
Map
(
)
;
this
.
chrome_settings_overrides
=
class
extends
ExtensionAPI
{
static
async
processDefaultSearchSetting
(
action
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
item
=
ExtensionSettingsStore
.
getSetting
(
DEFAULT_SEARCH_STORE_TYPE
DEFAULT_SEARCH_SETTING_NAME
)
;
if
(
!
item
)
{
return
;
}
if
(
Services
.
search
.
defaultEngine
.
name
!
=
item
.
value
&
&
Services
.
search
.
defaultEngine
.
name
!
=
item
.
initialValue
)
{
ExtensionSettingsStore
.
removeSetting
(
id
DEFAULT_SEARCH_STORE_TYPE
DEFAULT_SEARCH_SETTING_NAME
)
;
return
;
}
item
=
ExtensionSettingsStore
[
action
]
(
id
DEFAULT_SEARCH_STORE_TYPE
DEFAULT_SEARCH_SETTING_NAME
)
;
if
(
item
)
{
try
{
let
engine
=
Services
.
search
.
getEngineByName
(
item
.
value
|
|
item
.
initialValue
)
;
if
(
engine
)
{
Services
.
search
.
defaultEngine
=
engine
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
static
async
removeEngine
(
id
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
let
item
=
await
ExtensionSettingsStore
.
getSetting
(
DEFAULT_SEARCH_STORE_TYPE
ENGINE_ADDED_SETTING_NAME
id
)
;
if
(
item
)
{
ExtensionSettingsStore
.
removeSetting
(
id
DEFAULT_SEARCH_STORE_TYPE
ENGINE_ADDED_SETTING_NAME
)
;
}
if
(
!
Services
.
search
.
isInitialized
)
{
return
;
}
try
{
let
engines
=
await
Services
.
search
.
getEnginesByExtensionID
(
id
)
;
if
(
engines
.
length
)
{
await
Services
.
search
.
removeWebExtensionEngine
(
id
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
static
removeSearchSettings
(
id
)
{
return
Promise
.
all
(
[
this
.
processDefaultSearchSetting
(
"
removeSetting
"
id
)
this
.
removeEngine
(
id
)
]
)
;
}
static
async
onUninstall
(
id
)
{
let
searchStartupPromise
=
pendingSearchSetupTasks
.
get
(
id
)
;
if
(
searchStartupPromise
)
{
await
searchStartupPromise
;
}
return
Promise
.
all
(
[
this
.
removeSearchSettings
(
id
)
homepagePopup
.
clearConfirmation
(
id
)
]
)
;
}
static
async
onUpdate
(
id
manifest
)
{
let
haveHomepage
=
manifest
&
&
manifest
.
chrome_settings_overrides
&
&
manifest
.
chrome_settings_overrides
.
homepage
;
if
(
!
haveHomepage
)
{
ExtensionPreferencesManager
.
removeSetting
(
id
"
homepage_override
"
)
;
}
let
haveSearchProvider
=
manifest
&
&
manifest
.
chrome_settings_overrides
&
&
manifest
.
chrome_settings_overrides
.
search_provider
;
if
(
!
haveSearchProvider
)
{
this
.
removeSearchSettings
(
id
)
;
}
else
if
(
!
!
haveSearchProvider
.
is_default
&
&
(
await
ExtensionSettingsStore
.
initialize
(
)
)
&
&
ExtensionSettingsStore
.
hasSetting
(
id
DEFAULT_SEARCH_STORE_TYPE
DEFAULT_SEARCH_SETTING_NAME
)
)
{
chrome_settings_overrides
.
processDefaultSearchSetting
(
"
removeSetting
"
id
)
;
}
}
static
onDisable
(
id
)
{
homepagePopup
.
clearConfirmation
(
id
)
;
chrome_settings_overrides
.
processDefaultSearchSetting
(
"
disable
"
id
)
;
chrome_settings_overrides
.
removeEngine
(
id
)
;
}
async
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
let
{
manifest
}
=
extension
;
let
homepageUrl
=
manifest
.
chrome_settings_overrides
.
homepage
;
if
(
homepageUrl
)
{
const
ignoreHomePageUrl
=
await
HomePage
.
shouldIgnore
(
homepageUrl
)
;
if
(
ignoreHomePageUrl
)
{
Services
.
telemetry
.
recordEvent
(
"
homepage
"
"
preference
"
"
ignore
"
"
set_blocked_extension
"
{
webExtensionId
:
extension
.
id
}
)
;
}
else
{
await
handleHomepageUrl
(
extension
homepageUrl
)
;
}
}
if
(
manifest
.
chrome_settings_overrides
.
search_provider
)
{
let
searchStartupPromise
=
this
.
processSearchProviderManifestEntry
(
)
.
finally
(
(
)
=
>
{
if
(
pendingSearchSetupTasks
.
get
(
extension
.
id
)
=
=
=
searchStartupPromise
)
{
pendingSearchSetupTasks
.
delete
(
extension
.
id
)
;
}
}
)
;
pendingSearchSetupTasks
.
set
(
extension
.
id
searchStartupPromise
)
;
}
}
async
processSearchProviderManifestEntry
(
)
{
let
{
extension
}
=
this
;
let
{
manifest
}
=
extension
;
let
searchProvider
=
manifest
.
chrome_settings_overrides
.
search_provider
;
if
(
searchProvider
.
is_default
)
{
await
searchInitialized
;
if
(
!
this
.
extension
)
{
Cu
.
reportError
(
Extension
shut
down
before
search
provider
was
registered
)
;
return
;
}
}
let
engineName
=
searchProvider
.
name
.
trim
(
)
;
if
(
searchProvider
.
is_default
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
engineName
)
;
let
defaultEngines
=
await
Services
.
search
.
getDefaultEngines
(
)
;
if
(
engine
&
&
defaultEngines
.
some
(
defaultEngine
=
>
defaultEngine
.
name
=
=
engineName
)
)
{
await
this
.
setDefault
(
engineName
)
;
return
;
}
}
await
this
.
addSearchEngine
(
)
;
if
(
searchProvider
.
is_default
)
{
if
(
extension
.
startupReason
=
=
=
"
ADDON_INSTALL
"
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
engineName
)
;
let
defaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
if
(
defaultEngine
.
name
!
=
engine
.
name
)
{
let
subject
=
{
wrappedJSObject
:
{
browser
:
windowTracker
.
topWindow
.
gBrowser
.
selectedBrowser
name
:
this
.
extension
.
name
icon
:
this
.
extension
.
iconURL
currentEngine
:
defaultEngine
.
name
newEngine
:
engineName
async
respond
(
allow
)
{
if
(
allow
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
ExtensionSettingsStore
.
addSetting
(
extension
.
id
DEFAULT_SEARCH_STORE_TYPE
DEFAULT_SEARCH_SETTING_NAME
engineName
(
)
=
>
defaultEngine
.
name
)
;
Services
.
search
.
defaultEngine
=
Services
.
search
.
getEngineByName
(
engineName
)
;
}
}
}
}
;
Services
.
obs
.
notifyObservers
(
subject
"
webextension
-
defaultsearch
-
prompt
"
)
;
}
}
else
{
this
.
setDefault
(
engineName
)
;
}
}
}
async
setDefault
(
engineName
)
{
let
{
extension
}
=
this
;
if
(
extension
.
startupReason
=
=
=
"
ADDON_INSTALL
"
)
{
let
defaultEngine
=
await
Services
.
search
.
getDefault
(
)
;
await
ExtensionSettingsStore
.
initialize
(
)
;
let
item
=
await
ExtensionSettingsStore
.
addSetting
(
extension
.
id
DEFAULT_SEARCH_STORE_TYPE
DEFAULT_SEARCH_SETTING_NAME
engineName
(
)
=
>
defaultEngine
.
name
)
;
await
Services
.
search
.
setDefault
(
Services
.
search
.
getEngineByName
(
item
.
value
)
)
;
}
else
if
(
extension
.
startupReason
=
=
=
"
ADDON_ENABLE
"
)
{
chrome_settings_overrides
.
processDefaultSearchSetting
(
"
enable
"
extension
.
id
)
;
}
}
async
addSearchEngine
(
)
{
let
{
extension
}
=
this
;
let
isCurrent
=
false
;
let
index
=
-
1
;
if
(
extension
.
startupReason
=
=
=
"
ADDON_UPGRADE
"
&
&
!
extension
.
addonData
.
builtIn
)
{
let
engines
=
await
Services
.
search
.
getEnginesByExtensionID
(
extension
.
id
)
;
if
(
engines
.
length
)
{
let
firstEngine
=
engines
[
0
]
;
let
firstEngineName
=
firstEngine
.
name
;
isCurrent
=
(
await
Services
.
search
.
getDefault
(
)
)
.
name
=
=
firstEngineName
;
index
=
(
await
Services
.
search
.
getEngines
(
)
)
.
map
(
engine
=
>
engine
.
name
)
.
indexOf
(
firstEngineName
)
;
await
Services
.
search
.
removeEngine
(
firstEngine
)
;
}
}
try
{
let
engines
=
await
Services
.
search
.
addEnginesFromExtension
(
extension
)
;
if
(
engines
.
length
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
await
ExtensionSettingsStore
.
addSetting
(
extension
.
id
DEFAULT_SEARCH_STORE_TYPE
ENGINE_ADDED_SETTING_NAME
engines
[
0
]
.
name
)
;
}
if
(
extension
.
startupReason
=
=
=
"
ADDON_UPGRADE
"
&
&
!
extension
.
addonData
.
builtIn
)
{
let
engines
=
await
Services
.
search
.
getEnginesByExtensionID
(
extension
.
id
)
;
let
engine
=
Services
.
search
.
getEngineByName
(
engines
[
0
]
.
name
)
;
if
(
isCurrent
)
{
await
Services
.
search
.
setDefault
(
engine
)
;
}
if
(
index
!
=
-
1
)
{
await
Services
.
search
.
moveEngine
(
engine
index
)
;
}
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
false
;
}
return
true
;
}
}
;
ExtensionPreferencesManager
.
addSetting
(
"
homepage_override
"
{
prefNames
:
[
HOMEPAGE_PREF
HOMEPAGE_EXTENSION_CONTROLLED
]
onPrefsChanged
(
item
)
{
if
(
item
.
id
)
{
homepagePopup
.
addObserver
(
item
.
id
)
;
let
policy
=
ExtensionParent
.
WebExtensionPolicy
.
getByID
(
item
.
id
)
;
Services
.
prefs
.
setBoolPref
(
HOMEPAGE_PRIVATE_ALLOWED
policy
&
&
policy
.
privateBrowsingAllowed
)
;
Services
.
prefs
.
setBoolPref
(
HOMEPAGE_EXTENSION_CONTROLLED
true
)
;
}
else
{
homepagePopup
.
removeObserver
(
)
;
Services
.
prefs
.
clearUserPref
(
HOMEPAGE_PRIVATE_ALLOWED
)
;
Services
.
prefs
.
clearUserPref
(
HOMEPAGE_EXTENSION_CONTROLLED
)
;
}
}
setCallback
(
value
)
{
return
{
[
HOMEPAGE_PREF
]
:
value
[
HOMEPAGE_EXTENSION_CONTROLLED
]
:
!
!
value
}
;
}
}
)
;
