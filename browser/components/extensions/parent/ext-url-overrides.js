"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionControlledPopup
"
"
resource
:
/
/
/
modules
/
ExtensionControlledPopup
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aboutNewTabService
"
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
"
nsIAboutNewTabService
"
)
;
const
STORE_TYPE
=
"
url_overrides
"
;
const
NEW_TAB_SETTING_NAME
=
"
newTabURL
"
;
const
NEW_TAB_CONFIRMED_TYPE
=
"
newTabNotification
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
newTabPopup
"
(
)
=
>
{
return
new
ExtensionControlledPopup
(
{
confirmedType
:
NEW_TAB_CONFIRMED_TYPE
observerTopic
:
"
browser
-
open
-
newtab
-
start
"
popupnotificationId
:
"
extension
-
new
-
tab
-
notification
"
settingType
:
STORE_TYPE
settingKey
:
NEW_TAB_SETTING_NAME
descriptionId
:
"
extension
-
new
-
tab
-
notification
-
description
"
descriptionMessageId
:
"
newTabControlled
.
message2
"
learnMoreMessageId
:
"
newTabControlled
.
learnMore
"
learnMoreLink
:
"
extension
-
home
"
onObserverAdded
(
)
{
aboutNewTabService
.
willNotifyUser
=
true
;
}
onObserverRemoved
(
)
{
aboutNewTabService
.
willNotifyUser
=
false
;
}
async
beforeDisableAddon
(
popup
win
)
{
let
gBrowser
=
win
.
gBrowser
;
let
tab
=
gBrowser
.
selectedTab
;
await
replaceUrlInTab
(
gBrowser
tab
"
about
:
blank
"
)
;
Services
.
obs
.
addObserver
(
{
async
observe
(
)
{
await
replaceUrlInTab
(
gBrowser
tab
aboutNewTabService
.
newTabURL
)
;
popup
.
open
(
)
;
Services
.
obs
.
removeObserver
(
this
"
newtab
-
url
-
changed
"
)
;
}
}
"
newtab
-
url
-
changed
"
)
;
}
}
)
;
}
)
;
function
setNewTabURL
(
extensionId
url
)
{
if
(
extensionId
)
{
newTabPopup
.
addObserver
(
extensionId
)
;
}
else
{
newTabPopup
.
removeObserver
(
)
;
}
aboutNewTabService
.
newTabURL
=
url
;
}
this
.
urlOverrides
=
class
extends
ExtensionAPI
{
static
onUninstall
(
id
)
{
newTabPopup
.
clearConfirmation
(
id
)
;
}
processNewTabSetting
(
action
)
{
let
{
extension
}
=
this
;
let
item
=
ExtensionSettingsStore
[
action
]
(
extension
.
id
STORE_TYPE
NEW_TAB_SETTING_NAME
)
;
if
(
item
)
{
setNewTabURL
(
item
.
id
item
.
value
|
|
item
.
initialValue
)
;
}
}
async
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
let
{
manifest
}
=
extension
;
await
ExtensionSettingsStore
.
initialize
(
)
;
if
(
manifest
.
chrome_url_overrides
.
newtab
)
{
extension
.
callOnClose
(
{
close
:
(
)
=
>
{
switch
(
extension
.
shutdownReason
)
{
case
"
ADDON_DISABLE
"
:
this
.
processNewTabSetting
(
"
disable
"
)
;
newTabPopup
.
clearConfirmation
(
extension
.
id
)
;
break
;
case
"
ADDON_DOWNGRADE
"
:
case
"
ADDON_UPGRADE
"
:
case
"
ADDON_UNINSTALL
"
:
this
.
processNewTabSetting
(
"
removeSetting
"
)
;
break
;
}
}
}
)
;
let
url
=
extension
.
baseURI
.
resolve
(
manifest
.
chrome_url_overrides
.
newtab
)
;
let
item
=
await
ExtensionSettingsStore
.
addSetting
(
extension
.
id
STORE_TYPE
NEW_TAB_SETTING_NAME
url
(
)
=
>
aboutNewTabService
.
newTabURL
)
;
if
(
[
"
ADDON_ENABLE
"
"
ADDON_UPGRADE
"
"
ADDON_DOWNGRADE
"
]
.
includes
(
extension
.
startupReason
)
)
{
item
=
ExtensionSettingsStore
.
enable
(
extension
.
id
STORE_TYPE
NEW_TAB_SETTING_NAME
)
;
}
if
(
item
)
{
setNewTabURL
(
item
.
id
item
.
value
|
|
item
.
initialValue
)
;
}
}
}
}
;
