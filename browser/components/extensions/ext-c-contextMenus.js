"
use
strict
"
;
var
gNextMenuItemID
=
0
;
var
gPropHandlers
=
new
Map
(
)
;
class
ContextMenusClickPropHandler
{
constructor
(
context
)
{
this
.
context
=
context
;
this
.
onclickMap
=
new
Map
(
)
;
this
.
dispatchEvent
=
this
.
dispatchEvent
.
bind
(
this
)
;
}
dispatchEvent
(
info
tab
)
{
let
onclick
=
this
.
onclickMap
.
get
(
info
.
menuItemId
)
;
if
(
onclick
)
{
onclick
(
info
tab
)
;
}
}
setListener
(
id
onclick
)
{
if
(
this
.
onclickMap
.
size
=
=
=
0
)
{
this
.
context
.
childManager
.
getParentEvent
(
"
contextMenus
.
onClicked
"
)
.
addListener
(
this
.
dispatchEvent
)
;
this
.
context
.
callOnClose
(
this
)
;
}
this
.
onclickMap
.
set
(
id
onclick
)
;
let
propHandlerMap
=
gPropHandlers
.
get
(
this
.
context
.
extension
)
;
if
(
!
propHandlerMap
)
{
propHandlerMap
=
new
Map
(
)
;
}
else
{
let
propHandler
=
propHandlerMap
.
get
(
id
)
;
if
(
propHandler
&
&
propHandler
!
=
=
this
)
{
propHandler
.
unsetListener
(
id
)
;
}
}
propHandlerMap
.
set
(
id
this
)
;
gPropHandlers
.
set
(
this
.
context
.
extension
propHandlerMap
)
;
}
unsetListener
(
id
)
{
if
(
!
this
.
onclickMap
.
delete
(
id
)
)
{
return
;
}
if
(
this
.
onclickMap
.
size
=
=
=
0
)
{
this
.
context
.
childManager
.
getParentEvent
(
"
contextMenus
.
onClicked
"
)
.
removeListener
(
this
.
dispatchEvent
)
;
this
.
context
.
forgetOnClose
(
this
)
;
}
let
propHandlerMap
=
gPropHandlers
.
get
(
this
.
context
.
extension
)
;
propHandlerMap
.
delete
(
id
)
;
if
(
propHandlerMap
.
size
=
=
=
0
)
{
gPropHandlers
.
delete
(
this
.
context
.
extension
)
;
}
}
unsetListenerFromAnyContext
(
id
)
{
let
propHandlerMap
=
gPropHandlers
.
get
(
this
.
context
.
extension
)
;
let
propHandler
=
propHandlerMap
&
&
propHandlerMap
.
get
(
id
)
;
if
(
propHandler
)
{
propHandler
.
unsetListener
(
id
)
;
}
}
deleteAllListenersFromExtension
(
)
{
let
propHandlerMap
=
gPropHandlers
.
get
(
this
.
context
.
extension
)
;
if
(
propHandlerMap
)
{
for
(
let
[
id
propHandler
]
of
propHandlerMap
)
{
propHandler
.
unsetListener
(
id
)
;
}
}
}
close
(
)
{
for
(
let
id
of
this
.
onclickMap
.
keys
(
)
)
{
this
.
unsetListener
(
id
)
;
}
}
}
extensions
.
registerSchemaAPI
(
"
contextMenus
"
"
addon_child
"
context
=
>
{
let
onClickedProp
=
new
ContextMenusClickPropHandler
(
context
)
;
return
{
contextMenus
:
{
create
(
createProperties
callback
)
{
if
(
createProperties
.
id
=
=
=
null
)
{
createProperties
.
id
=
+
+
gNextMenuItemID
;
}
let
{
onclick
}
=
createProperties
;
delete
createProperties
.
onclick
;
context
.
childManager
.
callParentAsyncFunction
(
"
contextMenus
.
createInternal
"
[
createProperties
]
)
.
then
(
(
)
=
>
{
if
(
onclick
)
{
onClickedProp
.
setListener
(
createProperties
.
id
onclick
)
;
}
if
(
callback
)
{
callback
(
)
;
}
}
)
;
return
createProperties
.
id
;
}
update
(
id
updateProperties
)
{
let
{
onclick
}
=
updateProperties
;
delete
updateProperties
.
onclick
;
return
context
.
childManager
.
callParentAsyncFunction
(
"
contextMenus
.
update
"
[
id
updateProperties
]
)
.
then
(
(
)
=
>
{
if
(
onclick
)
{
onClickedProp
.
setListener
(
id
onclick
)
;
}
else
if
(
onclick
=
=
=
null
)
{
onClickedProp
.
unsetListenerFromAnyContext
(
id
)
;
}
}
)
;
}
remove
(
id
)
{
onClickedProp
.
unsetListenerFromAnyContext
(
id
)
;
return
context
.
childManager
.
callParentAsyncFunction
(
"
contextMenus
.
remove
"
[
id
]
)
;
}
removeAll
(
)
{
onClickedProp
.
deleteAllListenersFromExtension
(
)
;
return
context
.
childManager
.
callParentAsyncFunction
(
"
contextMenus
.
removeAll
"
[
]
)
;
}
}
}
;
}
)
;
