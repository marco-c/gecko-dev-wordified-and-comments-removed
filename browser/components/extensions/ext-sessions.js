"
use
strict
"
;
var
{
promiseObserved
SingletonEventManager
}
=
ExtensionUtils
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SessionStore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
)
;
const
SS_ON_CLOSED_OBJECTS_CHANGED
=
"
sessionstore
-
closed
-
objects
-
changed
"
;
function
getRecentlyClosed
(
maxResults
extension
)
{
let
recentlyClosed
=
[
]
;
let
closedWindowData
=
SessionStore
.
getClosedWindowData
(
false
)
;
for
(
let
window
of
closedWindowData
)
{
recentlyClosed
.
push
(
{
lastModified
:
window
.
closedAt
window
:
Window
.
convertFromSessionStoreClosedData
(
extension
window
)
}
)
;
}
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
let
closedTabData
=
SessionStore
.
getClosedTabData
(
window
false
)
;
for
(
let
tab
of
closedTabData
)
{
recentlyClosed
.
push
(
{
lastModified
:
tab
.
closedAt
tab
:
Tab
.
convertFromSessionStoreClosedData
(
extension
tab
window
)
}
)
;
}
}
recentlyClosed
.
sort
(
(
a
b
)
=
>
b
.
lastModified
-
a
.
lastModified
)
;
return
recentlyClosed
.
slice
(
0
maxResults
)
;
}
function
createSession
(
restored
extension
sessionId
)
{
if
(
!
restored
)
{
return
Promise
.
reject
(
{
message
:
Could
not
restore
object
using
sessionId
{
sessionId
}
.
}
)
;
}
let
sessionObj
=
{
lastModified
:
Date
.
now
(
)
}
;
if
(
restored
instanceof
Ci
.
nsIDOMChromeWindow
)
{
return
promiseObserved
(
"
sessionstore
-
single
-
window
-
restored
"
subject
=
>
subject
=
=
restored
)
.
then
(
(
)
=
>
{
sessionObj
.
window
=
extension
.
windowManager
.
convert
(
restored
{
populate
:
true
}
)
;
return
Promise
.
resolve
(
[
sessionObj
]
)
;
}
)
;
}
sessionObj
.
tab
=
extension
.
tabManager
.
convert
(
restored
)
;
return
Promise
.
resolve
(
[
sessionObj
]
)
;
}
this
.
sessions
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
let
{
extension
}
=
context
;
return
{
sessions
:
{
getRecentlyClosed
:
function
(
filter
)
{
let
maxResults
=
filter
.
maxResults
=
=
undefined
?
this
.
MAX_SESSION_RESULTS
:
filter
.
maxResults
;
return
Promise
.
resolve
(
getRecentlyClosed
(
maxResults
extension
)
)
;
}
restore
:
function
(
sessionId
)
{
let
session
closedId
;
if
(
sessionId
)
{
closedId
=
sessionId
;
session
=
SessionStore
.
undoCloseById
(
closedId
)
;
}
else
if
(
SessionStore
.
lastClosedObjectType
=
=
"
window
"
)
{
session
=
SessionStore
.
undoCloseWindow
(
0
)
;
}
else
{
let
recentlyClosedTabs
=
[
]
;
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
let
closedTabData
=
SessionStore
.
getClosedTabData
(
window
false
)
;
for
(
let
tab
of
closedTabData
)
{
recentlyClosedTabs
.
push
(
tab
)
;
}
}
recentlyClosedTabs
.
sort
(
(
a
b
)
=
>
b
.
closedAt
-
a
.
closedAt
)
;
closedId
=
recentlyClosedTabs
[
0
]
.
closedId
;
session
=
SessionStore
.
undoCloseById
(
closedId
)
;
}
return
createSession
(
session
extension
closedId
)
;
}
onChanged
:
new
SingletonEventManager
(
context
"
sessions
.
onChanged
"
fire
=
>
{
let
observer
=
(
)
=
>
{
fire
.
async
(
)
;
}
;
Services
.
obs
.
addObserver
(
observer
SS_ON_CLOSED_OBJECTS_CHANGED
false
)
;
return
(
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
SS_ON_CLOSED_OBJECTS_CHANGED
)
;
}
;
}
)
.
api
(
)
}
}
;
}
}
;
