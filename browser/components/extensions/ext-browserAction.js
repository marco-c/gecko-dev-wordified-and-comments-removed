"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
clearTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ViewPopup
"
"
resource
:
/
/
/
modules
/
ExtensionPopups
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
DOMUtils
"
"
mozilla
.
org
/
inspector
/
dom
-
utils
;
1
"
"
inIDOMUtils
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
var
{
IconDetails
SingletonEventManager
}
=
ExtensionUtils
;
const
POPUP_PRELOAD_TIMEOUT_MS
=
200
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
function
isAncestorOrSelf
(
target
node
)
{
for
(
;
node
;
node
=
node
.
parentNode
)
{
if
(
node
=
=
=
target
)
{
return
true
;
}
}
return
false
;
}
var
browserActionMap
=
new
WeakMap
(
)
;
function
BrowserAction
(
options
extension
)
{
this
.
extension
=
extension
;
let
widgetId
=
makeWidgetId
(
extension
.
id
)
;
this
.
id
=
{
widgetId
}
-
browser
-
action
;
this
.
viewId
=
PanelUI
-
webext
-
{
widgetId
}
-
browser
-
action
-
view
;
this
.
widget
=
null
;
this
.
pendingPopup
=
null
;
this
.
pendingPopupTimeout
=
null
;
this
.
tabManager
=
extension
.
tabManager
;
this
.
defaults
=
{
enabled
:
true
title
:
options
.
default_title
|
|
extension
.
name
badgeText
:
"
"
badgeBackgroundColor
:
null
icon
:
IconDetails
.
normalize
(
{
path
:
options
.
default_icon
}
extension
)
popup
:
options
.
default_popup
|
|
"
"
}
;
this
.
browserStyle
=
options
.
browser_style
|
|
false
;
if
(
options
.
browser_style
=
=
=
null
)
{
this
.
extension
.
logger
.
warn
(
"
Please
specify
whether
you
want
browser_style
"
+
"
or
not
in
your
browser_action
options
.
"
)
;
}
this
.
tabContext
=
new
TabContext
(
tab
=
>
Object
.
create
(
this
.
defaults
)
extension
)
;
EventEmitter
.
decorate
(
this
)
;
}
BrowserAction
.
prototype
=
{
build
(
)
{
let
widget
=
CustomizableUI
.
createWidget
(
{
id
:
this
.
id
viewId
:
this
.
viewId
type
:
"
view
"
removable
:
true
label
:
this
.
defaults
.
title
|
|
this
.
extension
.
name
tooltiptext
:
this
.
defaults
.
title
|
|
"
"
defaultArea
:
CustomizableUI
.
AREA_NAVBAR
onBeforeCreated
:
document
=
>
{
let
view
=
document
.
createElementNS
(
XUL_NS
"
panelview
"
)
;
view
.
id
=
this
.
viewId
;
view
.
setAttribute
(
"
flex
"
"
1
"
)
;
document
.
getElementById
(
"
PanelUI
-
multiView
"
)
.
appendChild
(
view
)
;
document
.
addEventListener
(
"
popupshowing
"
this
)
;
}
onDestroyed
:
document
=
>
{
let
view
=
document
.
getElementById
(
this
.
viewId
)
;
if
(
view
)
{
this
.
clearPopup
(
)
;
CustomizableUI
.
hidePanelForNode
(
view
)
;
view
.
remove
(
)
;
}
document
.
removeEventListener
(
"
popupshowing
"
this
)
;
}
onCreated
:
node
=
>
{
node
.
classList
.
add
(
"
badged
-
button
"
)
;
node
.
classList
.
add
(
"
webextension
-
browser
-
action
"
)
;
node
.
setAttribute
(
"
constrain
-
size
"
"
true
"
)
;
node
.
onmousedown
=
event
=
>
this
.
handleEvent
(
event
)
;
this
.
updateButton
(
node
this
.
defaults
)
;
}
onViewShowing
:
event
=
>
{
let
document
=
event
.
target
.
ownerDocument
;
let
tabbrowser
=
document
.
defaultView
.
gBrowser
;
let
tab
=
tabbrowser
.
selectedTab
;
let
popupURL
=
this
.
getProperty
(
tab
"
popup
"
)
;
this
.
tabManager
.
addActiveTabPermission
(
tab
)
;
if
(
popupURL
)
{
try
{
let
popup
=
this
.
getPopup
(
document
.
defaultView
popupURL
)
;
event
.
detail
.
addBlocker
(
popup
.
attach
(
event
.
target
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
event
.
preventDefault
(
)
;
}
}
else
{
event
.
preventDefault
(
)
;
this
.
emit
(
"
click
"
)
;
}
}
}
)
;
this
.
tabContext
.
on
(
"
tab
-
select
"
(
evt
tab
)
=
>
{
this
.
updateWindow
(
tab
.
ownerGlobal
)
;
}
)
;
this
.
widget
=
widget
;
}
triggerAction
:
Task
.
async
(
function
*
(
window
)
{
let
popup
=
ViewPopup
.
for
(
this
.
extension
window
)
;
if
(
popup
)
{
popup
.
closePopup
(
)
;
return
;
}
let
widget
=
this
.
widget
.
forWindow
(
window
)
;
let
tab
=
window
.
gBrowser
.
selectedTab
;
if
(
!
widget
|
|
!
this
.
getProperty
(
tab
"
enabled
"
)
)
{
return
;
}
if
(
this
.
getProperty
(
tab
"
popup
"
)
)
{
if
(
this
.
widget
.
areaType
=
=
CustomizableUI
.
TYPE_MENU_PANEL
)
{
yield
window
.
PanelUI
.
show
(
)
;
}
let
event
=
new
window
.
CustomEvent
(
"
command
"
{
bubbles
:
true
cancelable
:
true
}
)
;
widget
.
node
.
dispatchEvent
(
event
)
;
}
else
{
this
.
emit
(
"
click
"
)
;
}
}
)
handleEvent
(
event
)
{
let
button
=
event
.
target
;
let
window
=
button
.
ownerGlobal
;
switch
(
event
.
type
)
{
case
"
mousedown
"
:
if
(
event
.
button
=
=
0
)
{
let
tab
=
window
.
gBrowser
.
selectedTab
;
let
popupURL
=
this
.
getProperty
(
tab
"
popup
"
)
;
let
enabled
=
this
.
getProperty
(
tab
"
enabled
"
)
;
if
(
popupURL
&
&
enabled
)
{
if
(
!
this
.
pendingPopup
&
&
!
this
.
tabManager
.
hasActiveTabPermission
(
tab
)
)
{
this
.
tabManager
.
addActiveTabPermission
(
tab
)
;
this
.
tabToRevokeDuringClearPopup
=
tab
;
}
this
.
pendingPopup
=
this
.
getPopup
(
window
popupURL
)
;
window
.
addEventListener
(
"
mouseup
"
this
true
)
;
}
else
{
this
.
clearPopup
(
)
;
}
}
break
;
case
"
mouseup
"
:
if
(
event
.
button
=
=
0
)
{
this
.
clearPopupTimeout
(
)
;
if
(
this
.
pendingPopup
)
{
let
node
=
window
.
gBrowser
&
&
this
.
widget
.
forWindow
(
window
)
.
node
;
if
(
isAncestorOrSelf
(
node
event
.
originalTarget
)
)
{
this
.
pendingPopupTimeout
=
setTimeout
(
(
)
=
>
this
.
clearPopup
(
)
POPUP_PRELOAD_TIMEOUT_MS
)
;
}
else
{
this
.
clearPopup
(
)
;
}
}
}
break
;
case
"
popupshowing
"
:
const
menu
=
event
.
target
;
const
trigger
=
menu
.
triggerNode
;
const
node
=
window
.
document
.
getElementById
(
this
.
id
)
;
const
contexts
=
[
"
toolbar
-
context
-
menu
"
"
customizationPanelItemContextMenu
"
]
;
if
(
contexts
.
includes
(
menu
.
id
)
&
&
node
&
&
isAncestorOrSelf
(
node
trigger
)
)
{
global
.
actionContextMenu
(
{
extension
:
this
.
extension
onBrowserAction
:
true
menu
:
menu
}
)
;
}
break
;
}
}
getPopup
(
window
popupURL
)
{
this
.
clearPopupTimeout
(
)
;
let
{
pendingPopup
}
=
this
;
this
.
pendingPopup
=
null
;
if
(
pendingPopup
)
{
if
(
pendingPopup
.
window
=
=
=
window
&
&
pendingPopup
.
popupURL
=
=
=
popupURL
)
{
return
pendingPopup
;
}
pendingPopup
.
destroy
(
)
;
}
let
fixedWidth
=
this
.
widget
.
areaType
=
=
CustomizableUI
.
TYPE_MENU_PANEL
;
return
new
ViewPopup
(
this
.
extension
window
popupURL
this
.
browserStyle
fixedWidth
)
;
}
clearPopup
(
)
{
this
.
clearPopupTimeout
(
)
;
if
(
this
.
pendingPopup
)
{
if
(
this
.
tabToRevokeDuringClearPopup
)
{
this
.
tabManager
.
revokeActiveTabPermission
(
this
.
tabToRevokeDuringClearPopup
)
;
this
.
tabToRevokeDuringClearPopup
=
null
;
}
this
.
pendingPopup
.
destroy
(
)
;
this
.
pendingPopup
=
null
;
}
}
clearPopupTimeout
(
)
{
if
(
this
.
pendingPopup
)
{
this
.
pendingPopup
.
window
.
removeEventListener
(
"
mouseup
"
this
true
)
;
}
if
(
this
.
pendingPopupTimeout
)
{
clearTimeout
(
this
.
pendingPopupTimeout
)
;
this
.
pendingPopupTimeout
=
null
;
}
}
updateButton
(
node
tabData
)
{
let
title
=
tabData
.
title
|
|
this
.
extension
.
name
;
node
.
setAttribute
(
"
tooltiptext
"
title
)
;
node
.
setAttribute
(
"
label
"
title
)
;
if
(
tabData
.
badgeText
)
{
node
.
setAttribute
(
"
badge
"
tabData
.
badgeText
)
;
}
else
{
node
.
removeAttribute
(
"
badge
"
)
;
}
if
(
tabData
.
enabled
)
{
node
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
node
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
let
badgeNode
=
node
.
ownerDocument
.
getAnonymousElementByAttribute
(
node
"
class
"
"
toolbarbutton
-
badge
"
)
;
if
(
badgeNode
)
{
let
color
=
tabData
.
badgeBackgroundColor
;
if
(
color
)
{
color
=
rgba
(
{
color
[
0
]
}
{
color
[
1
]
}
{
color
[
2
]
}
{
color
[
3
]
/
255
}
)
;
}
badgeNode
.
style
.
backgroundColor
=
color
|
|
"
"
;
}
const
LEGACY_CLASS
=
"
toolbarbutton
-
legacy
-
addon
"
;
node
.
classList
.
remove
(
LEGACY_CLASS
)
;
let
baseSize
=
16
;
let
{
icon
size
}
=
IconDetails
.
getPreferredIcon
(
tabData
.
icon
this
.
extension
baseSize
)
;
if
(
size
%
16
&
&
!
icon
.
endsWith
(
"
.
svg
"
)
)
{
let
result
=
IconDetails
.
getPreferredIcon
(
tabData
.
icon
this
.
extension
18
)
;
if
(
result
.
size
%
18
=
=
0
)
{
baseSize
=
18
;
icon
=
result
.
icon
;
node
.
classList
.
add
(
LEGACY_CLASS
)
;
}
}
let
getIcon
=
size
=
>
IconDetails
.
escapeUrl
(
IconDetails
.
getPreferredIcon
(
tabData
.
icon
this
.
extension
size
)
.
icon
)
;
node
.
setAttribute
(
"
style
"
-
-
webextension
-
menupanel
-
image
:
url
(
"
{
getIcon
(
32
)
}
"
)
;
-
-
webextension
-
menupanel
-
image
-
2x
:
url
(
"
{
getIcon
(
64
)
}
"
)
;
-
-
webextension
-
toolbar
-
image
:
url
(
"
{
IconDetails
.
escapeUrl
(
icon
)
}
"
)
;
-
-
webextension
-
toolbar
-
image
-
2x
:
url
(
"
{
getIcon
(
baseSize
*
2
)
}
"
)
;
)
;
}
updateWindow
(
window
)
{
let
widget
=
this
.
widget
.
forWindow
(
window
)
;
if
(
widget
)
{
let
tab
=
window
.
gBrowser
.
selectedTab
;
this
.
updateButton
(
widget
.
node
this
.
tabContext
.
get
(
tab
)
)
;
}
}
updateOnChange
(
tab
)
{
if
(
tab
)
{
if
(
tab
.
selected
)
{
this
.
updateWindow
(
tab
.
ownerGlobal
)
;
}
}
else
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
updateWindow
(
window
)
;
}
}
}
setProperty
(
tab
prop
value
)
{
if
(
tab
=
=
null
)
{
this
.
defaults
[
prop
]
=
value
;
}
else
if
(
value
!
=
null
)
{
this
.
tabContext
.
get
(
tab
)
[
prop
]
=
value
;
}
else
{
delete
this
.
tabContext
.
get
(
tab
)
[
prop
]
;
}
this
.
updateOnChange
(
tab
)
;
}
getProperty
(
tab
prop
)
{
if
(
tab
=
=
null
)
{
return
this
.
defaults
[
prop
]
;
}
return
this
.
tabContext
.
get
(
tab
)
[
prop
]
;
}
shutdown
(
)
{
this
.
tabContext
.
shutdown
(
)
;
CustomizableUI
.
destroyWidget
(
this
.
id
)
;
}
}
;
BrowserAction
.
for
=
(
extension
)
=
>
{
return
browserActionMap
.
get
(
extension
)
;
}
;
global
.
browserActionFor
=
BrowserAction
.
for
;
extensions
.
on
(
"
manifest_browser_action
"
(
type
directive
extension
manifest
)
=
>
{
let
browserAction
=
new
BrowserAction
(
manifest
.
browser_action
extension
)
;
browserAction
.
build
(
)
;
browserActionMap
.
set
(
extension
browserAction
)
;
}
)
;
extensions
.
on
(
"
shutdown
"
(
type
extension
)
=
>
{
if
(
browserActionMap
.
has
(
extension
)
)
{
browserActionMap
.
get
(
extension
)
.
shutdown
(
)
;
browserActionMap
.
delete
(
extension
)
;
}
}
)
;
extensions
.
registerSchemaAPI
(
"
browserAction
"
"
addon_parent
"
context
=
>
{
let
{
extension
}
=
context
;
let
{
tabManager
}
=
extension
;
function
getTab
(
tabId
)
{
if
(
tabId
!
=
=
null
)
{
return
tabTracker
.
getTab
(
tabId
)
;
}
return
null
;
}
return
{
browserAction
:
{
onClicked
:
new
SingletonEventManager
(
context
"
browserAction
.
onClicked
"
fire
=
>
{
let
listener
=
(
)
=
>
{
fire
.
async
(
tabManager
.
convert
(
tabTracker
.
activeTab
)
)
;
}
;
BrowserAction
.
for
(
extension
)
.
on
(
"
click
"
listener
)
;
return
(
)
=
>
{
BrowserAction
.
for
(
extension
)
.
off
(
"
click
"
listener
)
;
}
;
}
)
.
api
(
)
enable
:
function
(
tabId
)
{
let
tab
=
getTab
(
tabId
)
;
BrowserAction
.
for
(
extension
)
.
setProperty
(
tab
"
enabled
"
true
)
;
}
disable
:
function
(
tabId
)
{
let
tab
=
getTab
(
tabId
)
;
BrowserAction
.
for
(
extension
)
.
setProperty
(
tab
"
enabled
"
false
)
;
}
setTitle
:
function
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
title
=
details
.
title
;
if
(
tab
&
&
title
=
=
"
"
)
{
title
=
null
;
}
BrowserAction
.
for
(
extension
)
.
setProperty
(
tab
"
title
"
title
)
;
}
getTitle
:
function
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
title
=
BrowserAction
.
for
(
extension
)
.
getProperty
(
tab
"
title
"
)
;
return
Promise
.
resolve
(
title
)
;
}
setIcon
:
function
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
icon
=
IconDetails
.
normalize
(
details
extension
context
)
;
BrowserAction
.
for
(
extension
)
.
setProperty
(
tab
"
icon
"
icon
)
;
}
setBadgeText
:
function
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
BrowserAction
.
for
(
extension
)
.
setProperty
(
tab
"
badgeText
"
details
.
text
)
;
}
getBadgeText
:
function
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
text
=
BrowserAction
.
for
(
extension
)
.
getProperty
(
tab
"
badgeText
"
)
;
return
Promise
.
resolve
(
text
)
;
}
setPopup
:
function
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
url
=
details
.
popup
&
&
context
.
uri
.
resolve
(
details
.
popup
)
;
BrowserAction
.
for
(
extension
)
.
setProperty
(
tab
"
popup
"
url
)
;
}
getPopup
:
function
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
popup
=
BrowserAction
.
for
(
extension
)
.
getProperty
(
tab
"
popup
"
)
;
return
Promise
.
resolve
(
popup
)
;
}
setBadgeBackgroundColor
:
function
(
details
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
color
=
details
.
color
;
if
(
!
Array
.
isArray
(
color
)
)
{
let
col
=
DOMUtils
.
colorToRGBA
(
color
)
;
color
=
col
&
&
[
col
.
r
col
.
g
col
.
b
Math
.
round
(
col
.
a
*
255
)
]
;
}
BrowserAction
.
for
(
extension
)
.
setProperty
(
tab
"
badgeBackgroundColor
"
color
)
;
}
getBadgeBackgroundColor
:
function
(
details
callback
)
{
let
tab
=
getTab
(
details
.
tabId
)
;
let
color
=
BrowserAction
.
for
(
extension
)
.
getProperty
(
tab
"
badgeBackgroundColor
"
)
;
return
Promise
.
resolve
(
color
|
|
[
0xd9
0
0
255
]
)
;
}
}
}
;
}
)
;
