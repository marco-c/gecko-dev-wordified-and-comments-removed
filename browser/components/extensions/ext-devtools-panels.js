"
use
strict
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
var
{
IconDetails
watchExtensionProxyContextLoad
}
=
ExtensionParent
;
var
{
promiseEvent
}
=
ExtensionUtils
;
var
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
class
ParentDevToolsPanel
{
constructor
(
context
panelOptions
)
{
const
toolbox
=
context
.
devToolsToolbox
;
if
(
!
toolbox
)
{
throw
Error
(
"
Missing
mandatory
toolbox
"
)
;
}
this
.
extension
=
context
.
extension
;
this
.
viewType
=
"
devtools_panel
"
;
this
.
visible
=
false
;
this
.
toolbox
=
toolbox
;
this
.
context
=
context
;
this
.
panelOptions
=
panelOptions
;
this
.
context
.
callOnClose
(
this
)
;
this
.
id
=
this
.
panelOptions
.
id
;
this
.
onToolboxPanelSelect
=
this
.
onToolboxPanelSelect
.
bind
(
this
)
;
this
.
onToolboxHostWillChange
=
this
.
onToolboxHostWillChange
.
bind
(
this
)
;
this
.
onToolboxHostChanged
=
this
.
onToolboxHostChanged
.
bind
(
this
)
;
this
.
unwatchExtensionProxyContextLoad
=
null
;
this
.
waitTopLevelContext
=
new
Promise
(
resolve
=
>
{
this
.
_resolveTopLevelContext
=
resolve
;
}
)
;
this
.
browser
=
null
;
this
.
browserContainerWindow
=
null
;
this
.
panelAdded
=
false
;
this
.
addPanel
(
)
;
}
addPanel
(
)
{
const
{
icon
title
}
=
this
.
panelOptions
;
const
extensionName
=
this
.
context
.
extension
.
name
;
this
.
toolbox
.
addAdditionalTool
(
{
id
:
this
.
id
url
:
"
about
:
blank
"
icon
:
icon
label
:
title
tooltip
:
DevTools
Panel
added
by
"
{
extensionName
}
"
add
-
on
.
visibilityswitch
:
devtools
.
webext
-
{
this
.
id
}
.
enabled
isTargetSupported
:
target
=
>
target
.
isLocalTab
build
:
(
window
toolbox
)
=
>
{
if
(
toolbox
!
=
=
this
.
toolbox
)
{
throw
new
Error
(
"
Unexpected
toolbox
received
on
addAdditionalTool
build
property
"
)
;
}
const
destroy
=
this
.
buildPanel
(
window
)
;
return
{
toolbox
destroy
}
;
}
}
)
;
this
.
panelAdded
=
true
;
}
buildPanel
(
window
)
{
const
{
toolbox
}
=
this
;
this
.
createBrowserElement
(
window
)
;
this
.
browserContainerWindow
=
window
;
toolbox
.
on
(
"
select
"
this
.
onToolboxPanelSelect
)
;
toolbox
.
on
(
"
host
-
will
-
change
"
this
.
onToolboxHostWillChange
)
;
toolbox
.
on
(
"
host
-
changed
"
this
.
onToolboxHostChanged
)
;
return
(
)
=
>
{
this
.
destroyBrowserElement
(
)
;
this
.
browserContainerWindow
=
null
;
toolbox
.
off
(
"
select
"
this
.
onToolboxPanelSelect
)
;
toolbox
.
off
(
"
host
-
will
-
change
"
this
.
onToolboxHostWillChange
)
;
toolbox
.
off
(
"
host
-
changed
"
this
.
onToolboxHostChanged
)
;
}
;
}
onToolboxHostWillChange
(
)
{
if
(
this
.
browser
)
{
if
(
this
.
visible
)
{
this
.
context
.
parentMessageManager
.
sendAsyncMessage
(
"
Extension
:
DevToolsPanelHidden
"
{
toolboxPanelId
:
this
.
id
}
)
;
}
this
.
destroyBrowserElement
(
)
;
}
}
async
onToolboxHostChanged
(
)
{
if
(
this
.
browserContainerWindow
)
{
this
.
createBrowserElement
(
this
.
browserContainerWindow
)
;
if
(
this
.
visible
)
{
await
this
.
waitTopLevelContext
;
this
.
context
.
parentMessageManager
.
sendAsyncMessage
(
"
Extension
:
DevToolsPanelShown
"
{
toolboxPanelId
:
this
.
id
}
)
;
}
}
}
async
onToolboxPanelSelect
(
what
id
)
{
if
(
!
this
.
waitTopLevelContext
|
|
!
this
.
panelAdded
)
{
return
;
}
await
this
.
waitTopLevelContext
;
if
(
!
this
.
visible
&
&
id
=
=
=
this
.
id
)
{
this
.
visible
=
true
;
}
else
if
(
this
.
visible
&
&
id
!
=
=
this
.
id
)
{
this
.
visible
=
false
;
}
const
extensionMessage
=
Extension
:
DevToolsPanel
{
this
.
visible
?
"
Shown
"
:
"
Hidden
"
}
;
this
.
context
.
parentMessageManager
.
sendAsyncMessage
(
extensionMessage
{
toolboxPanelId
:
this
.
id
}
)
;
}
close
(
)
{
const
{
toolbox
}
=
this
;
if
(
!
toolbox
)
{
throw
new
Error
(
"
Unable
to
destroy
a
closed
devtools
panel
"
)
;
}
if
(
this
.
panelAdded
&
&
toolbox
.
isToolRegistered
(
this
.
id
)
)
{
toolbox
.
removeAdditionalTool
(
this
.
id
)
;
}
this
.
waitTopLevelContext
=
null
;
this
.
_resolveTopLevelContext
=
null
;
this
.
context
=
null
;
this
.
toolbox
=
null
;
this
.
browser
=
null
;
this
.
browserContainerWindow
=
null
;
}
createBrowserElement
(
window
)
{
const
{
toolbox
}
=
this
;
const
{
extension
}
=
this
.
context
;
const
{
url
}
=
this
.
panelOptions
;
const
{
document
}
=
window
;
const
browser
=
document
.
createElementNS
(
XUL_NS
"
browser
"
)
;
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
browser
.
setAttribute
(
"
disableglobalhistory
"
"
true
"
)
;
browser
.
setAttribute
(
"
style
"
"
width
:
100
%
;
height
:
100
%
;
"
)
;
browser
.
setAttribute
(
"
transparent
"
"
true
"
)
;
browser
.
setAttribute
(
"
class
"
"
webextension
-
devtoolsPanel
-
browser
"
)
;
browser
.
setAttribute
(
"
webextension
-
view
-
type
"
"
devtools_panel
"
)
;
browser
.
setAttribute
(
"
flex
"
"
1
"
)
;
browser
.
sameProcessAsFrameLoader
=
extension
.
groupFrameLoader
;
this
.
browser
=
browser
;
let
awaitFrameLoader
=
Promise
.
resolve
(
)
;
if
(
extension
.
remote
)
{
browser
.
setAttribute
(
"
remote
"
"
true
"
)
;
browser
.
setAttribute
(
"
remoteType
"
E10SUtils
.
EXTENSION_REMOTE_TYPE
)
;
awaitFrameLoader
=
promiseEvent
(
browser
"
XULFrameLoaderCreated
"
)
;
}
let
hasTopLevelContext
=
false
;
this
.
unwatchExtensionProxyContextLoad
=
watchExtensionProxyContextLoad
(
this
context
=
>
{
context
.
devToolsToolbox
=
toolbox
;
if
(
!
hasTopLevelContext
)
{
hasTopLevelContext
=
true
;
awaitFrameLoader
.
then
(
(
)
=
>
this
.
_resolveTopLevelContext
(
context
)
)
;
}
}
)
;
document
.
body
.
setAttribute
(
"
style
"
"
margin
:
0
;
padding
:
0
;
"
)
;
document
.
body
.
appendChild
(
browser
)
;
extensions
.
emit
(
"
extension
-
browser
-
inserted
"
browser
{
devtoolsToolboxInfo
:
{
toolboxPanelId
:
this
.
id
inspectedWindowTabId
:
getTargetTabIdForToolbox
(
toolbox
)
}
}
)
;
browser
.
loadURI
(
url
)
;
}
destroyBrowserElement
(
)
{
const
{
browser
unwatchExtensionProxyContextLoad
}
=
this
;
if
(
unwatchExtensionProxyContextLoad
)
{
this
.
unwatchExtensionProxyContextLoad
=
null
;
unwatchExtensionProxyContextLoad
(
)
;
}
if
(
browser
)
{
browser
.
remove
(
)
;
this
.
browser
=
null
;
}
this
.
waitTopLevelContext
=
new
Promise
(
resolve
=
>
{
this
.
_resolveTopLevelContext
=
resolve
;
}
)
;
}
}
class
DevToolsSelectionObserver
extends
EventEmitter
{
constructor
(
context
)
{
if
(
!
context
.
devToolsToolbox
)
{
throw
Error
(
"
Missing
mandatory
toolbox
"
)
;
}
super
(
)
;
context
.
callOnClose
(
this
)
;
this
.
toolbox
=
context
.
devToolsToolbox
;
this
.
onSelected
=
this
.
onSelected
.
bind
(
this
)
;
this
.
initialized
=
false
;
}
on
(
.
.
.
args
)
{
this
.
lazyInit
(
)
;
super
.
on
.
apply
(
this
args
)
;
}
once
(
.
.
.
args
)
{
this
.
lazyInit
(
)
;
super
.
once
.
apply
(
this
args
)
;
}
async
lazyInit
(
)
{
if
(
!
this
.
initialized
)
{
this
.
initialized
=
true
;
this
.
toolbox
.
on
(
"
selection
-
changed
"
this
.
onSelected
)
;
}
}
close
(
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Unable
to
close
a
destroyed
DevToolsSelectionObserver
"
)
;
}
if
(
this
.
initialized
)
{
this
.
toolbox
.
off
(
"
selection
-
changed
"
this
.
onSelected
)
;
}
this
.
toolbox
=
null
;
this
.
destroyed
=
true
;
}
onSelected
(
event
)
{
this
.
emit
(
"
selectionChanged
"
)
;
}
}
class
ParentDevToolsInspectorSidebar
{
constructor
(
context
sidebarOptions
)
{
const
toolbox
=
context
.
devToolsToolbox
;
if
(
!
toolbox
)
{
throw
Error
(
"
Missing
mandatory
toolbox
"
)
;
}
this
.
extension
=
context
.
extension
;
this
.
visible
=
false
;
this
.
destroyed
=
false
;
this
.
toolbox
=
toolbox
;
this
.
context
=
context
;
this
.
sidebarOptions
=
sidebarOptions
;
this
.
context
.
callOnClose
(
this
)
;
this
.
id
=
this
.
sidebarOptions
.
id
;
this
.
onSidebarSelect
=
this
.
onSidebarSelect
.
bind
(
this
)
;
this
.
onSidebarCreated
=
this
.
onSidebarCreated
.
bind
(
this
)
;
this
.
toolbox
.
once
(
extension
-
sidebar
-
created
-
{
this
.
id
}
this
.
onSidebarCreated
)
;
this
.
toolbox
.
on
(
inspector
-
sidebar
-
select
this
.
onSidebarSelect
)
;
this
.
_initializeSidebar
=
null
;
this
.
toolbox
.
registerInspectorExtensionSidebar
(
this
.
id
{
title
:
sidebarOptions
.
title
}
)
;
}
close
(
)
{
if
(
this
.
destroyed
)
{
throw
new
Error
(
"
Unable
to
close
a
destroyed
DevToolsSelectionObserver
"
)
;
}
this
.
toolbox
.
off
(
extension
-
sidebar
-
created
-
{
this
.
id
}
this
.
onSidebarCreated
)
;
this
.
toolbox
.
off
(
inspector
-
sidebar
-
select
this
.
onSidebarSelect
)
;
this
.
toolbox
.
unregisterInspectorExtensionSidebar
(
this
.
id
)
;
this
.
extensionSidebar
=
null
;
this
.
_initializeSidebar
=
null
;
this
.
destroyed
=
true
;
}
onSidebarCreated
(
evt
sidebar
)
{
this
.
extensionSidebar
=
sidebar
;
if
(
typeof
this
.
_initializeSidebar
=
=
=
"
function
"
)
{
this
.
_initializeSidebar
(
)
;
this
.
_initializeSidebar
=
null
;
}
}
onSidebarSelect
(
what
id
)
{
if
(
!
this
.
extensionSidebar
)
{
return
;
}
if
(
!
this
.
visible
&
&
id
=
=
=
this
.
id
)
{
this
.
visible
=
true
;
this
.
context
.
parentMessageManager
.
sendAsyncMessage
(
"
Extension
:
DevToolsInspectorSidebarShown
"
{
inspectorSidebarId
:
this
.
id
}
)
;
}
else
if
(
this
.
visible
&
&
id
!
=
=
this
.
id
)
{
this
.
visible
=
false
;
this
.
context
.
parentMessageManager
.
sendAsyncMessage
(
"
Extension
:
DevToolsInspectorSidebarHidden
"
{
inspectorSidebarId
:
this
.
id
}
)
;
}
}
setObject
(
object
rootTitle
)
{
if
(
rootTitle
)
{
object
=
{
[
rootTitle
]
:
object
}
;
}
if
(
this
.
extensionSidebar
)
{
this
.
extensionSidebar
.
setObject
(
object
)
;
}
else
{
this
.
_initializeSidebar
=
(
)
=
>
this
.
extensionSidebar
.
setObject
(
object
)
;
}
}
}
const
sidebarsById
=
new
Map
(
)
;
this
.
devtools_panels
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
let
waitForInspectedWindowFront
;
const
callerInfo
=
{
addonId
:
context
.
extension
.
id
url
:
context
.
extension
.
baseURI
.
spec
}
;
let
nextPanelId
=
0
;
const
toolboxSelectionObserver
=
new
DevToolsSelectionObserver
(
context
)
;
function
newBasePanelId
(
)
{
return
{
context
.
extension
.
id
}
-
{
context
.
contextId
}
-
{
nextPanelId
+
+
}
;
}
return
{
devtools
:
{
panels
:
{
elements
:
{
onSelectionChanged
:
new
EventManager
(
context
"
devtools
.
panels
.
elements
.
onSelectionChanged
"
fire
=
>
{
const
listener
=
(
eventName
)
=
>
{
fire
.
async
(
)
;
}
;
toolboxSelectionObserver
.
on
(
"
selectionChanged
"
listener
)
;
return
(
)
=
>
{
toolboxSelectionObserver
.
off
(
"
selectionChanged
"
listener
)
;
}
;
}
)
.
api
(
)
createSidebarPane
(
title
)
{
const
id
=
devtools
-
inspector
-
sidebar
-
{
makeWidgetId
(
newBasePanelId
(
)
)
}
;
const
parentSidebar
=
new
ParentDevToolsInspectorSidebar
(
context
{
title
id
}
)
;
sidebarsById
.
set
(
id
parentSidebar
)
;
context
.
callOnClose
(
{
close
(
)
{
sidebarsById
.
delete
(
id
)
;
}
}
)
;
return
Promise
.
resolve
(
id
)
;
}
Sidebar
:
{
setObject
(
sidebarId
jsonObject
rootTitle
)
{
const
sidebar
=
sidebarsById
.
get
(
sidebarId
)
;
return
sidebar
.
setObject
(
jsonObject
rootTitle
)
;
}
async
setExpression
(
sidebarId
evalExpression
rootTitle
)
{
const
sidebar
=
sidebarsById
.
get
(
sidebarId
)
;
if
(
!
waitForInspectedWindowFront
)
{
waitForInspectedWindowFront
=
getInspectedWindowFront
(
context
)
;
}
const
front
=
await
waitForInspectedWindowFront
;
const
evalOptions
=
Object
.
assign
(
{
}
getToolboxEvalOptions
(
context
)
)
;
const
evalResult
=
await
front
.
eval
(
callerInfo
evalExpression
evalOptions
)
;
let
jsonObject
;
if
(
evalResult
.
exceptionInfo
)
{
jsonObject
=
evalResult
.
exceptionInfo
;
}
else
{
jsonObject
=
evalResult
.
value
;
}
return
sidebar
.
setObject
(
jsonObject
rootTitle
)
;
}
}
}
create
(
title
icon
url
)
{
if
(
icon
=
=
=
"
"
&
&
context
.
extension
.
manifest
.
icons
)
{
const
iconInfo
=
IconDetails
.
getPreferredIcon
(
context
.
extension
.
manifest
.
icons
context
.
extension
128
)
;
icon
=
iconInfo
?
iconInfo
.
icon
:
"
"
;
}
icon
=
context
.
extension
.
baseURI
.
resolve
(
icon
)
;
url
=
context
.
extension
.
baseURI
.
resolve
(
url
)
;
const
id
=
{
makeWidgetId
(
newBasePanelId
(
)
)
}
-
devtools
-
panel
;
new
ParentDevToolsPanel
(
context
{
title
icon
url
id
}
)
;
return
Promise
.
resolve
(
id
)
;
}
}
}
}
;
}
}
;
