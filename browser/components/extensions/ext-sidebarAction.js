"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
var
{
ExtensionError
}
=
ExtensionUtils
;
var
{
IconDetails
}
=
ExtensionParent
;
var
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
let
sidebarActionMap
=
new
WeakMap
(
)
;
const
sidebarURL
=
"
chrome
:
/
/
browser
/
content
/
webext
-
panels
.
xul
"
;
this
.
sidebarAction
=
class
extends
ExtensionAPI
{
static
for
(
extension
)
{
return
sidebarActionMap
.
get
(
extension
)
;
}
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
extension
.
once
(
"
ready
"
this
.
onReady
.
bind
(
this
)
)
;
let
options
=
extension
.
manifest
.
sidebar_action
;
let
widgetId
=
makeWidgetId
(
extension
.
id
)
;
this
.
id
=
{
widgetId
}
-
sidebar
-
action
;
this
.
menuId
=
menu_
{
this
.
id
}
;
this
.
buttonId
=
button_
{
this
.
id
}
;
this
.
browserStyle
=
options
.
browser_style
|
|
options
.
browser_style
=
=
=
null
;
this
.
defaults
=
{
enabled
:
true
title
:
options
.
default_title
|
|
extension
.
name
icon
:
IconDetails
.
normalize
(
{
path
:
options
.
default_icon
}
extension
)
panel
:
options
.
default_panel
|
|
"
"
}
;
this
.
tabContext
=
new
TabContext
(
tab
=
>
Object
.
create
(
this
.
defaults
)
extension
)
;
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
createMenuItem
(
window
this
.
defaults
)
;
}
this
.
windowOpenListener
=
(
window
)
=
>
{
this
.
createMenuItem
(
window
this
.
defaults
)
;
}
;
windowTracker
.
addOpenListener
(
this
.
windowOpenListener
)
;
this
.
updateHeader
=
(
event
)
=
>
{
let
window
=
event
.
target
.
ownerGlobal
;
let
details
=
this
.
tabContext
.
get
(
window
.
gBrowser
.
selectedTab
)
;
let
header
=
window
.
document
.
getElementById
(
"
sidebar
-
switcher
-
target
"
)
;
if
(
window
.
SidebarUI
.
currentID
=
=
=
this
.
id
)
{
this
.
setMenuIcon
(
header
details
)
;
}
}
;
this
.
windowCloseListener
=
(
window
)
=
>
{
let
header
=
window
.
document
.
getElementById
(
"
sidebar
-
switcher
-
target
"
)
;
if
(
header
)
{
header
.
removeEventListener
(
"
SidebarShown
"
this
.
updateHeader
)
;
}
}
;
windowTracker
.
addCloseListener
(
this
.
windowCloseListener
)
;
sidebarActionMap
.
set
(
extension
this
)
;
}
onReady
(
)
{
this
.
build
(
)
;
}
onShutdown
(
reason
)
{
sidebarActionMap
.
delete
(
this
.
this
)
;
this
.
tabContext
.
shutdown
(
)
;
if
(
reason
=
=
=
"
APP_SHUTDOWN
"
)
{
return
;
}
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
let
{
document
SidebarUI
}
=
window
;
if
(
SidebarUI
.
currentID
=
=
=
this
.
id
)
{
SidebarUI
.
hide
(
)
;
}
let
menu
=
document
.
getElementById
(
this
.
menuId
)
;
if
(
menu
)
{
menu
.
remove
(
)
;
}
let
button
=
document
.
getElementById
(
this
.
buttonId
)
;
if
(
button
)
{
button
.
remove
(
)
;
}
let
broadcaster
=
document
.
getElementById
(
this
.
id
)
;
if
(
broadcaster
)
{
broadcaster
.
remove
(
)
;
}
let
header
=
document
.
getElementById
(
"
sidebar
-
switcher
-
target
"
)
;
header
.
removeEventListener
(
"
SidebarShown
"
this
.
updateHeader
)
;
}
windowTracker
.
removeOpenListener
(
this
.
windowOpenListener
)
;
windowTracker
.
removeCloseListener
(
this
.
windowCloseListener
)
;
}
build
(
)
{
this
.
tabContext
.
on
(
"
tab
-
select
"
(
evt
tab
)
=
>
{
this
.
updateWindow
(
tab
.
ownerGlobal
)
;
}
)
;
let
install
=
this
.
extension
.
startupReason
=
=
=
"
ADDON_INSTALL
"
;
let
upgrade
=
[
"
ADDON_UPGRADE
"
"
ADDON_DOWNGRADE
"
]
.
includes
(
this
.
extension
.
startupReason
)
;
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
updateWindow
(
window
)
;
let
{
SidebarUI
}
=
window
;
if
(
install
|
|
(
upgrade
&
&
SidebarUI
.
lastOpenedId
=
=
this
.
id
)
)
{
SidebarUI
.
show
(
this
.
id
)
;
}
}
if
(
install
&
&
!
Services
.
prefs
.
prefHasUserValue
(
"
extensions
.
sidebar
-
button
.
shown
"
)
)
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
sidebar
-
button
.
shown
"
true
)
;
let
widget
=
CustomizableUI
.
getWidget
(
"
sidebar
-
button
"
)
;
if
(
!
widget
.
areaType
)
{
CustomizableUI
.
addWidgetToArea
(
"
sidebar
-
button
"
CustomizableUI
.
AREA_NAVBAR
0
)
;
}
}
}
sidebarUrl
(
panel
)
{
let
url
=
{
sidebarURL
}
?
panel
=
{
encodeURIComponent
(
panel
)
}
;
if
(
this
.
extension
.
remote
)
{
url
+
=
"
&
remote
=
1
"
;
}
if
(
this
.
browserStyle
)
{
url
+
=
"
&
browser
-
style
=
1
"
;
}
return
url
;
}
createMenuItem
(
window
details
)
{
let
{
document
}
=
window
;
let
broadcaster
=
document
.
createElementNS
(
XUL_NS
"
broadcaster
"
)
;
broadcaster
.
setAttribute
(
"
id
"
this
.
id
)
;
broadcaster
.
setAttribute
(
"
autoCheck
"
"
false
"
)
;
broadcaster
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
broadcaster
.
setAttribute
(
"
group
"
"
sidebar
"
)
;
broadcaster
.
setAttribute
(
"
label
"
details
.
title
)
;
broadcaster
.
setAttribute
(
"
sidebarurl
"
this
.
sidebarUrl
(
details
.
panel
)
)
;
broadcaster
.
setAttribute
(
"
oncommand
"
"
SidebarUI
.
show
(
this
.
getAttribute
(
'
observes
'
)
)
"
)
;
let
header
=
document
.
getElementById
(
"
sidebar
-
switcher
-
target
"
)
;
header
.
addEventListener
(
"
SidebarShown
"
this
.
updateHeader
)
;
let
menuitem
=
document
.
createElementNS
(
XUL_NS
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
id
"
this
.
menuId
)
;
menuitem
.
setAttribute
(
"
observes
"
this
.
id
)
;
menuitem
.
setAttribute
(
"
class
"
"
menuitem
-
iconic
webextension
-
menuitem
"
)
;
this
.
setMenuIcon
(
menuitem
details
)
;
let
toolbarbutton
=
document
.
createElementNS
(
XUL_NS
"
toolbarbutton
"
)
;
toolbarbutton
.
setAttribute
(
"
id
"
this
.
buttonId
)
;
toolbarbutton
.
setAttribute
(
"
observes
"
this
.
id
)
;
toolbarbutton
.
setAttribute
(
"
class
"
"
subviewbutton
subviewbutton
-
iconic
webextension
-
menuitem
"
)
;
this
.
setMenuIcon
(
toolbarbutton
details
)
;
document
.
getElementById
(
"
mainBroadcasterSet
"
)
.
appendChild
(
broadcaster
)
;
document
.
getElementById
(
"
viewSidebarMenu
"
)
.
appendChild
(
menuitem
)
;
document
.
getElementById
(
"
sidebar
-
extensions
"
)
.
appendChild
(
toolbarbutton
)
;
return
menuitem
;
}
setMenuIcon
(
menuitem
details
)
{
let
getIcon
=
size
=
>
IconDetails
.
escapeUrl
(
IconDetails
.
getPreferredIcon
(
details
.
icon
this
.
extension
size
)
.
icon
)
;
menuitem
.
setAttribute
(
"
style
"
-
-
webextension
-
menuitem
-
image
:
url
(
"
{
getIcon
(
16
)
}
"
)
;
-
-
webextension
-
menuitem
-
image
-
2x
:
url
(
"
{
getIcon
(
32
)
}
"
)
;
)
;
}
updateButton
(
window
tabData
)
{
let
{
document
SidebarUI
}
=
window
;
let
title
=
tabData
.
title
|
|
this
.
extension
.
name
;
let
menu
=
document
.
getElementById
(
this
.
menuId
)
;
if
(
!
menu
)
{
menu
=
this
.
createMenuItem
(
window
tabData
)
;
}
let
broadcaster
=
document
.
getElementById
(
this
.
id
)
;
broadcaster
.
setAttribute
(
"
tooltiptext
"
title
)
;
broadcaster
.
setAttribute
(
"
label
"
title
)
;
let
url
=
this
.
sidebarUrl
(
tabData
.
panel
)
;
let
urlChanged
=
url
!
=
=
broadcaster
.
getAttribute
(
"
sidebarurl
"
)
;
if
(
urlChanged
)
{
broadcaster
.
setAttribute
(
"
sidebarurl
"
url
)
;
}
this
.
setMenuIcon
(
menu
tabData
)
;
let
button
=
document
.
getElementById
(
this
.
buttonId
)
;
this
.
setMenuIcon
(
button
tabData
)
;
if
(
SidebarUI
.
currentID
=
=
=
this
.
id
)
{
SidebarUI
.
title
=
title
;
let
header
=
document
.
getElementById
(
"
sidebar
-
switcher
-
target
"
)
;
this
.
setMenuIcon
(
header
tabData
)
;
if
(
SidebarUI
.
isOpen
&
&
urlChanged
)
{
SidebarUI
.
show
(
this
.
id
)
;
}
}
}
updateWindow
(
window
)
{
let
nativeTab
=
window
.
gBrowser
.
selectedTab
;
this
.
updateButton
(
window
this
.
tabContext
.
get
(
nativeTab
)
)
;
}
updateOnChange
(
nativeTab
)
{
if
(
nativeTab
)
{
if
(
nativeTab
.
selected
)
{
this
.
updateWindow
(
nativeTab
.
ownerGlobal
)
;
}
}
else
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
updateWindow
(
window
)
;
}
}
}
setProperty
(
nativeTab
prop
value
)
{
if
(
nativeTab
=
=
=
null
)
{
this
.
defaults
[
prop
]
=
value
;
}
else
if
(
value
!
=
=
null
)
{
this
.
tabContext
.
get
(
nativeTab
)
[
prop
]
=
value
;
}
else
{
delete
this
.
tabContext
.
get
(
nativeTab
)
[
prop
]
;
}
this
.
updateOnChange
(
nativeTab
)
;
}
getProperty
(
nativeTab
prop
)
{
if
(
nativeTab
=
=
=
null
)
{
return
this
.
defaults
[
prop
]
;
}
return
this
.
tabContext
.
get
(
nativeTab
)
[
prop
]
;
}
triggerAction
(
window
)
{
let
{
SidebarUI
}
=
window
;
if
(
SidebarUI
)
{
SidebarUI
.
toggle
(
this
.
id
)
;
}
}
open
(
window
)
{
let
{
SidebarUI
}
=
window
;
if
(
SidebarUI
)
{
SidebarUI
.
show
(
this
.
id
)
;
}
}
close
(
window
)
{
let
{
SidebarUI
}
=
window
;
if
(
SidebarUI
.
isOpen
&
&
this
.
id
=
=
SidebarUI
.
currentID
)
{
SidebarUI
.
hide
(
)
;
}
}
getAPI
(
context
)
{
let
{
extension
}
=
context
;
const
sidebarAction
=
this
;
function
getTab
(
tabId
)
{
if
(
tabId
!
=
=
null
)
{
return
tabTracker
.
getTab
(
tabId
)
;
}
return
null
;
}
return
{
sidebarAction
:
{
async
setTitle
(
details
)
{
let
nativeTab
=
getTab
(
details
.
tabId
)
;
let
title
=
details
.
title
;
if
(
nativeTab
&
&
title
=
=
=
"
"
)
{
title
=
null
;
}
sidebarAction
.
setProperty
(
nativeTab
"
title
"
title
)
;
}
getTitle
(
details
)
{
let
nativeTab
=
getTab
(
details
.
tabId
)
;
let
title
=
sidebarAction
.
getProperty
(
nativeTab
"
title
"
)
;
return
Promise
.
resolve
(
title
)
;
}
async
setIcon
(
details
)
{
let
nativeTab
=
getTab
(
details
.
tabId
)
;
let
icon
=
IconDetails
.
normalize
(
details
extension
context
)
;
sidebarAction
.
setProperty
(
nativeTab
"
icon
"
icon
)
;
}
async
setPanel
(
details
)
{
let
nativeTab
=
getTab
(
details
.
tabId
)
;
let
url
;
if
(
nativeTab
&
&
details
.
panel
=
=
=
"
"
)
{
url
=
null
;
}
else
if
(
details
.
panel
!
=
=
"
"
)
{
url
=
context
.
uri
.
resolve
(
details
.
panel
)
;
}
else
{
throw
new
ExtensionError
(
"
Invalid
url
for
sidebar
panel
.
"
)
;
}
sidebarAction
.
setProperty
(
nativeTab
"
panel
"
url
)
;
}
getPanel
(
details
)
{
let
nativeTab
=
getTab
(
details
.
tabId
)
;
let
panel
=
sidebarAction
.
getProperty
(
nativeTab
"
panel
"
)
;
return
Promise
.
resolve
(
panel
)
;
}
open
(
)
{
let
window
=
windowTracker
.
topWindow
;
sidebarAction
.
open
(
window
)
;
}
close
(
)
{
let
window
=
windowTracker
.
topWindow
;
sidebarAction
.
close
(
window
)
;
}
}
}
;
}
}
;
global
.
sidebarActionFor
=
this
.
sidebarAction
.
for
;
