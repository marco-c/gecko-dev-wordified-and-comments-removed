"
use
strict
"
;
const
{
UrlbarTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
jsm
"
)
;
const
{
Management
:
{
global
:
{
windowTracker
}
}
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
null
)
;
add_task
(
async
function
test_contextual_tip_without_urlbar_permission
(
)
{
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
background
(
)
{
browser
.
test
.
assertEq
(
browser
.
urlbar
undefined
"
'
urlbar
'
permission
is
required
"
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
ext
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_contextual_tip_with_urlbar_permission
(
)
{
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
background
(
)
{
browser
.
test
.
assertTrue
(
!
!
browser
.
urlbar
.
contextualTip
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
ext
.
unload
(
)
;
}
)
;
add_task
(
async
function
set_contextual_tip_and_set_contextual_tip_again
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
Contextual
tip
'
s
title
"
buttonTitle
:
"
Button
"
linkTitle
:
"
Link
"
}
)
;
browser
.
test
.
onMessage
.
addListener
(
(
)
=
>
{
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
Updated
title
"
buttonTitle
:
"
Updated
button
title
"
linkTitle
:
"
Updated
link
title
"
}
)
;
browser
.
test
.
sendMessage
(
"
updated
"
)
;
}
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
title
.
textContent
"
Contextual
tip
'
s
title
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
button
.
textContent
"
Button
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
link
.
textContent
"
Link
"
)
;
ext
.
sendMessage
(
"
update
tip
'
s
texts
"
)
;
await
ext
.
awaitMessage
(
"
updated
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
title
.
textContent
"
Updated
title
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
button
.
textContent
"
Updated
button
title
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
link
.
textContent
"
Updated
link
title
"
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
win
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
container
)
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
:
win
waitForFocus
value
:
"
"
}
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
container
)
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
win
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
hiding_contextual_tip_closing_popup_panel
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
Contextual
tip
'
s
title
"
buttonTitle
:
"
Button
"
linkTitle
:
"
Link
"
}
)
;
browser
.
test
.
onMessage
.
addListener
(
async
msg
=
>
{
browser
.
urlbar
.
contextualTip
.
remove
(
)
;
browser
.
test
.
sendMessage
(
"
next
-
test
"
)
;
}
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
ext
.
sendMessage
(
"
hide
-
contextual
-
tip
"
)
;
await
ext
.
awaitMessage
(
"
next
-
test
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
container
)
)
;
Assert
.
ok
(
!
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
:
win
waitForFocus
value
:
"
"
}
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
container
)
)
;
await
UrlbarTestUtils
.
promisePopupClose
(
win
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
hiding_contextual_tip_and_leaving_popup_panel_open
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
Contextual
tip
'
s
title
"
buttonTitle
:
"
Button
"
linkTitle
:
"
Link
"
}
)
;
browser
.
test
.
onMessage
.
addListener
(
async
msg
=
>
{
browser
.
urlbar
.
contextualTip
.
remove
(
)
;
browser
.
test
.
sendMessage
(
"
next
-
test
"
)
;
}
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
title
.
textContent
"
Contextual
tip
'
s
title
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
button
.
textContent
"
Button
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
link
.
textContent
"
Link
"
)
;
await
UrlbarTestUtils
.
promiseAutocompleteResultPopup
(
{
window
:
win
waitForFocus
value
:
"
hello
world
"
}
)
;
ext
.
sendMessage
(
"
hide
-
contextual
-
tip
"
)
;
await
ext
.
awaitMessage
(
"
next
-
test
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
container
)
)
;
Assert
.
ok
(
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
hide_button_and_link
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
contextual
tip
'
s
title
"
buttonTitle
:
"
contextual
tip
'
s
button
title
"
linkTitle
:
"
contextual
tip
'
s
link
title
"
}
)
;
browser
.
test
.
onMessage
.
addListener
(
msg
=
>
{
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
contextual
tip
'
s
title
"
}
)
;
browser
.
test
.
sendMessage
(
"
next
-
test
"
)
;
}
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
title
.
textContent
"
contextual
tip
'
s
title
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
button
.
textContent
"
contextual
tip
'
s
button
title
"
)
;
Assert
.
equal
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
link
.
textContent
"
contextual
tip
'
s
link
title
"
)
;
ext
.
sendMessage
(
"
hide
button
and
link
"
)
;
await
ext
.
awaitMessage
(
"
next
-
test
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
button
)
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
link
)
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_showing_contextual_tip
(
)
{
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
background
(
)
{
browser
.
test
.
assertThrows
(
(
)
=
>
browser
.
urlbar
.
contextualTip
.
set
(
{
buttonTitle
:
"
button
title
"
linkTitle
:
"
link
title
"
}
)
/
Type
error
for
parameter
/
"
Throws
error
because
there
'
s
no
title
property
in
the
argument
"
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
ext
.
unload
(
)
;
}
)
;
add_task
(
async
function
contextual_tip_removed_onShutdown
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
Hello
World
!
"
buttonTitle
:
"
Click
Me
"
linkTitle
:
"
Link
"
}
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
!
win
.
gURLBar
.
view
.
contextualTip
.
_elements
)
;
Assert
.
ok
(
win
.
document
.
getElementById
(
"
urlbar
-
contextual
-
tip
"
)
)
;
await
ext
.
unload
(
)
;
Assert
.
ok
(
!
win
.
document
.
getElementById
(
"
urlbar
-
contextual
-
tip
"
)
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
async
function
add_onclick_to_element
(
elementType
shouldAddListenerBeforeTip
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
windowId
=
windowTracker
.
getId
(
win
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
background
(
)
{
browser
.
test
.
onMessage
.
addListener
(
(
msg
elementType
shouldAddListenerBeforeTip
)
=
>
{
if
(
msg
=
=
"
elementType
"
)
{
const
capitalizedElementType
=
elementType
[
0
]
.
toUpperCase
(
)
+
elementType
.
substring
(
1
)
;
const
addListener
=
(
)
=
>
{
browser
.
urlbar
.
contextualTip
[
on
{
capitalizedElementType
}
Clicked
]
.
addListener
(
windowId
=
>
{
browser
.
test
.
sendMessage
(
on
-
{
elementType
}
-
clicked
windowId
)
;
}
)
;
}
;
if
(
shouldAddListenerBeforeTip
)
{
addListener
(
)
;
}
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
Title
"
[
{
elementType
}
Title
]
:
"
Click
Me
!
"
}
)
;
if
(
!
shouldAddListenerBeforeTip
)
{
addListener
(
)
;
}
browser
.
test
.
sendMessage
(
"
next
-
test
"
)
;
}
}
)
;
}
}
)
;
await
ext
.
startup
(
)
;
ext
.
sendMessage
(
"
elementType
"
elementType
shouldAddListenerBeforeTip
)
;
await
ext
.
awaitMessage
(
"
next
-
test
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
!
win
.
gURLBar
.
view
.
contextualTip
.
_elements
)
;
win
.
gURLBar
.
view
.
contextualTip
.
_elements
[
elementType
]
.
click
(
)
;
const
windowIdFromExtension
=
await
ext
.
awaitMessage
(
on
-
{
elementType
}
-
clicked
)
;
Assert
.
equal
(
windowId
windowIdFromExtension
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
add_task
(
async
(
)
=
>
{
await
add_onclick_to_element
(
"
button
"
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
add_onclick_to_element
(
"
link
"
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
add_onclick_to_element
(
"
button
"
true
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
add_onclick_to_element
(
"
link
"
true
)
;
}
)
;
add_task
(
async
function
test_set_icon_given_path
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
files
:
{
"
icons
/
icon
.
png
"
:
imageBuffer
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
icon
:
{
defaultIcon
:
"
icons
/
icon
.
png
"
}
title
:
"
the
title
is
required
"
}
)
;
browser
.
test
.
sendMessage
(
"
ready
"
browser
.
runtime
.
getURL
(
"
icons
/
icon
.
png
"
)
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
const
iconURL
=
await
ext
.
awaitMessage
(
"
ready
"
)
;
const
backgroundImageProperty
=
url
(
"
{
iconURL
}
"
)
;
const
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
backgroundImageProperty
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_set_icon_given_path
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
icons
:
{
"
19
"
:
"
extension_icon
.
png
"
}
}
files
:
{
"
extension_icon
.
png
"
:
imageBuffer
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
title
:
"
the
title
is
required
"
}
)
;
browser
.
test
.
sendMessage
(
"
ready
"
browser
.
runtime
.
getURL
(
"
extension_icon
.
png
"
)
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
const
iconURL
=
await
ext
.
awaitMessage
(
"
ready
"
)
;
const
backgroundImageProperty
=
url
(
"
{
iconURL
}
"
)
;
const
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
backgroundImageProperty
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_themeIcons
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
files
:
{
"
icons
/
default
.
png
"
:
imageBuffer
"
icons
/
light
.
png
"
:
imageBuffer
"
icons
/
dark
.
png
"
:
imageBuffer
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
icon
:
{
defaultIcon
:
"
icons
/
default
.
png
"
themeIcons
:
[
{
light
:
"
icons
/
light
.
png
"
dark
:
"
icons
/
dark
.
png
"
size
:
19
}
]
}
title
:
"
the
title
is
required
"
}
)
;
browser
.
test
.
sendMessage
(
"
ready
"
{
expectedDefaultIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
default
.
png
"
)
expectedLightIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
light
.
png
"
)
expectedDarkIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
dark
.
png
"
)
}
)
;
}
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
const
{
expectedDefaultIconURL
expectedLightIconURL
expectedDarkIconURL
}
=
await
ext
.
awaitMessage
(
"
ready
"
)
;
let
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedDefaultIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
let
lightThemeExt
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
theme
:
{
colors
:
{
popup
:
"
#
fff
"
popup_text
:
"
#
0c0c0d
"
popup_border
:
"
#
ccc
"
}
}
}
}
)
;
await
lightThemeExt
.
startup
(
)
;
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedDarkIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
await
lightThemeExt
.
unload
(
)
;
let
darkThemeExt
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
theme
:
{
colors
:
{
popup
:
"
#
4a4a4f
"
popup_text
:
"
rgb
(
249
249
250
)
"
popup_border
:
"
#
27272b
"
}
}
}
}
)
;
await
darkThemeExt
.
startup
(
)
;
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedLightIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
await
darkThemeExt
.
unload
(
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
const
RESOLUTION_PREF
=
"
layout
.
css
.
devPixelsPerPx
"
;
add_task
(
async
function
test_themeIcons_size_16
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
files
:
{
"
icons
/
default
.
png
"
:
imageBuffer
"
icons
/
light
-
16
.
png
"
:
imageBuffer
"
icons
/
dark
-
16
.
png
"
:
imageBuffer
"
icons
/
light
-
32
.
png
"
:
imageBuffer
"
icons
/
dark
-
32
.
png
"
:
imageBuffer
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
icon
:
{
defaultIcon
:
"
icons
/
default
.
png
"
themeIcons
:
[
{
light
:
"
icons
/
light
-
16
.
png
"
dark
:
"
icons
/
dark
-
16
.
png
"
size
:
16
}
{
light
:
"
icons
/
light
-
32
.
png
"
dark
:
"
icons
/
dark
-
32
.
png
"
size
:
32
}
]
}
title
:
"
the
title
is
required
"
}
)
;
browser
.
test
.
sendMessage
(
"
ready
"
{
expectedDefaultIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
default
.
png
"
)
expectedLightIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
light
-
16
.
png
"
)
expectedDarkIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
dark
-
16
.
png
"
)
}
)
;
}
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
RESOLUTION_PREF
1
]
]
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
const
{
expectedDefaultIconURL
expectedLightIconURL
expectedDarkIconURL
}
=
await
ext
.
awaitMessage
(
"
ready
"
)
;
let
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedDefaultIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
let
lightThemeExt
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
theme
:
{
colors
:
{
popup
:
"
#
fff
"
popup_text
:
"
#
0c0c0d
"
popup_border
:
"
#
ccc
"
}
}
}
}
)
;
await
lightThemeExt
.
startup
(
)
;
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedDarkIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
await
lightThemeExt
.
unload
(
)
;
let
darkThemeExt
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
theme
:
{
colors
:
{
popup
:
"
#
4a4a4f
"
popup_text
:
"
rgb
(
249
249
250
)
"
popup_border
:
"
#
27272b
"
}
}
}
}
)
;
await
darkThemeExt
.
startup
(
)
;
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedLightIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
await
darkThemeExt
.
unload
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_themeIcons_size_32
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
ext
=
ExtensionTestUtils
.
loadExtension
(
{
isPrivileged
:
true
manifest
:
{
permissions
:
[
"
urlbar
"
]
}
files
:
{
"
icons
/
default
.
png
"
:
imageBuffer
"
icons
/
light
-
16
.
png
"
:
imageBuffer
"
icons
/
dark
-
16
.
png
"
:
imageBuffer
"
icons
/
light
-
32
.
png
"
:
imageBuffer
"
icons
/
dark
-
32
.
png
"
:
imageBuffer
}
background
(
)
{
browser
.
urlbar
.
contextualTip
.
set
(
{
icon
:
{
defaultIcon
:
"
icons
/
default
.
png
"
themeIcons
:
[
{
light
:
"
icons
/
light
-
16
.
png
"
dark
:
"
icons
/
dark
-
16
.
png
"
size
:
16
}
{
light
:
"
icons
/
light
-
32
.
png
"
dark
:
"
icons
/
dark
-
32
.
png
"
size
:
32
}
]
}
title
:
"
the
title
is
required
"
}
)
;
browser
.
test
.
sendMessage
(
"
ready
"
{
expectedDefaultIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
default
.
png
"
)
expectedLightIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
light
-
32
.
png
"
)
expectedDarkIconURL
:
browser
.
runtime
.
getURL
(
"
icons
/
dark
-
32
.
png
"
)
}
)
;
}
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
RESOLUTION_PREF
2
]
]
}
)
;
await
ext
.
startup
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
UrlbarTestUtils
.
isPopupOpen
(
win
)
)
;
const
{
expectedDefaultIconURL
expectedLightIconURL
expectedDarkIconURL
}
=
await
ext
.
awaitMessage
(
"
ready
"
)
;
let
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedDefaultIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
let
lightThemeExt
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
theme
:
{
colors
:
{
popup
:
"
#
fff
"
popup_text
:
"
#
0c0c0d
"
popup_border
:
"
#
ccc
"
}
}
}
}
)
;
await
lightThemeExt
.
startup
(
)
;
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedDarkIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
await
lightThemeExt
.
unload
(
)
;
let
darkThemeExt
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
theme
:
{
colors
:
{
popup
:
"
#
4a4a4f
"
popup_text
:
"
rgb
(
249
249
250
)
"
popup_border
:
"
#
27272b
"
}
}
}
}
)
;
await
darkThemeExt
.
startup
(
)
;
iconElement
=
win
.
gURLBar
.
view
.
contextualTip
.
_elements
.
icon
;
Assert
.
equal
(
url
(
"
{
expectedLightIconURL
}
"
)
win
.
getComputedStyle
(
iconElement
)
.
backgroundImage
)
;
await
darkThemeExt
.
unload
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
ext
.
unload
(
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
