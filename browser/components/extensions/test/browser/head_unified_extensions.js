"
use
strict
"
;
const
getListView
=
(
win
=
window
)
=
>
{
const
{
panel
}
=
win
.
gUnifiedExtensions
;
ok
(
panel
"
expected
panel
to
be
created
"
)
;
return
panel
.
querySelector
(
"
#
unified
-
extensions
-
view
"
)
;
}
;
const
openExtensionsPanel
=
async
(
win
=
window
)
=
>
{
const
{
button
}
=
win
.
gUnifiedExtensions
;
ok
(
button
"
expected
button
"
)
;
const
listView
=
getListView
(
win
)
;
ok
(
listView
"
expected
list
view
"
)
;
const
viewShown
=
BrowserTestUtils
.
waitForEvent
(
listView
"
ViewShown
"
)
;
button
.
click
(
)
;
await
viewShown
;
}
;
const
closeExtensionsPanel
=
async
(
win
=
window
)
=
>
{
const
{
button
}
=
win
.
gUnifiedExtensions
;
ok
(
button
"
expected
button
"
)
;
const
hidden
=
BrowserTestUtils
.
waitForEvent
(
win
.
gUnifiedExtensions
.
panel
"
popuphidden
"
true
)
;
button
.
click
(
)
;
await
hidden
;
}
;
const
getUnifiedExtensionsItem
=
(
extensionId
win
=
window
)
=
>
{
const
view
=
getListView
(
win
)
;
return
(
view
.
querySelector
(
toolbaritem
[
data
-
extensionid
=
"
{
extensionId
}
"
]
)
|
|
view
.
querySelector
(
unified
-
extensions
-
item
[
extension
-
id
=
"
{
extensionId
}
"
]
)
)
;
}
;
const
openUnifiedExtensionsContextMenu
=
async
(
extensionId
win
=
window
)
=
>
{
const
item
=
getUnifiedExtensionsItem
(
extensionId
win
)
;
ok
(
item
expected
item
for
extensionId
=
{
extensionId
}
)
;
const
button
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
button
"
expected
menu
button
"
)
;
button
.
scrollIntoView
(
{
block
:
"
center
"
}
)
;
const
menu
=
win
.
document
.
getElementById
(
"
unified
-
extensions
-
context
-
menu
"
)
;
ok
(
menu
"
expected
menu
"
)
;
const
shown
=
BrowserTestUtils
.
waitForEvent
(
menu
"
popupshown
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
button
{
}
win
)
;
await
shown
;
return
menu
;
}
;
const
clickUnifiedExtensionsItem
=
async
(
win
extensionId
forceEnableButton
=
false
)
=
>
{
await
openExtensionsPanel
(
win
)
;
const
item
=
getUnifiedExtensionsItem
(
extensionId
win
)
;
ok
(
item
expected
item
for
{
extensionId
}
)
;
if
(
forceEnableButton
)
{
let
actionButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
actionButton
.
disabled
=
false
;
ok
(
!
actionButton
.
disabled
"
action
button
was
force
-
enabled
"
)
;
}
item
.
scrollIntoView
(
{
block
:
"
center
"
}
)
;
const
popupHidden
=
BrowserTestUtils
.
waitForEvent
(
win
.
document
"
popuphidden
"
true
)
;
EventUtils
.
synthesizeMouseAtCenter
(
item
{
}
win
)
;
await
popupHidden
;
}
;
const
createExtensions
=
(
arrayOfManifestData
{
useAddonManager
=
true
incognitoOverride
files
}
=
{
}
)
=
>
{
return
arrayOfManifestData
.
map
(
manifestData
=
>
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
default
-
extension
-
name
"
.
.
.
manifestData
}
useAddonManager
:
useAddonManager
?
"
temporary
"
:
undefined
incognitoOverride
files
}
)
)
;
}
;
const
ensureMaximizedWindow
=
async
win
=
>
{
info
(
"
ensuring
maximized
window
.
.
.
"
)
;
let
samePositionTimes
=
0
;
let
lastScreenTop
=
win
.
screen
.
top
;
let
lastScreenLeft
=
win
.
screen
.
left
;
win
.
moveTo
(
0
0
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
isSamePosition
=
lastScreenTop
=
=
=
win
.
screen
.
top
&
&
lastScreenLeft
=
=
=
win
.
screen
.
left
;
if
(
!
isSamePosition
)
{
lastScreenTop
=
win
.
screen
.
top
;
lastScreenLeft
=
win
.
screen
.
left
;
}
samePositionTimes
=
isSamePosition
?
samePositionTimes
+
1
:
0
;
return
samePositionTimes
=
=
=
10
;
}
"
Wait
for
the
chrome
window
position
to
settle
"
)
;
const
widthDiff
=
Math
.
max
(
win
.
screen
.
availWidth
-
win
.
outerWidth
0
)
;
const
heightDiff
=
Math
.
max
(
win
.
screen
.
availHeight
-
win
.
outerHeight
0
)
;
if
(
widthDiff
|
|
heightDiff
)
{
info
(
resizing
window
.
.
.
widthDiff
=
{
widthDiff
}
-
heightDiff
=
{
heightDiff
}
)
;
win
.
windowUtils
.
ensureDirtyRootFrame
(
)
;
win
.
resizeBy
(
widthDiff
heightDiff
)
;
}
else
{
info
(
not
resizing
window
!
)
;
}
let
lastOuterWidth
=
win
.
outerWidth
;
let
lastOuterHeight
=
win
.
outerHeight
;
let
sameSizeTimes
=
0
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
const
isSameSize
=
win
.
outerWidth
=
=
=
lastOuterWidth
&
&
win
.
outerHeight
=
=
=
lastOuterHeight
;
if
(
!
isSameSize
)
{
lastOuterWidth
=
win
.
outerWidth
;
lastOuterHeight
=
win
.
outerHeight
;
}
sameSizeTimes
=
isSameSize
?
sameSizeTimes
+
1
:
0
;
return
sameSizeTimes
=
=
=
10
;
}
"
Wait
for
the
chrome
window
size
to
settle
"
)
;
}
;
const
promiseSetToolbarVisibility
=
(
toolbar
visible
)
=
>
{
const
visibilityChanged
=
BrowserTestUtils
.
waitForMutationCondition
(
toolbar
{
attributeFilter
:
[
"
collapsed
"
]
}
(
)
=
>
toolbar
.
collapsed
!
=
visible
)
;
setToolbarVisibility
(
toolbar
visible
undefined
false
)
;
return
visibilityChanged
;
}
;
const
getMessageBars
=
(
win
=
window
)
=
>
{
const
{
panel
}
=
win
.
gUnifiedExtensions
;
return
panel
.
querySelectorAll
(
"
#
unified
-
extensions
-
messages
-
container
>
message
-
bar
"
)
;
}
;
