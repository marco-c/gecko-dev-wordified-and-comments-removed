"
use
strict
"
;
add_task
(
async
function
(
)
{
let
keyword
=
"
VeryUniqueKeywordThatDoesNeverMatchAnyTestUrl
"
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
"
omnibox
"
:
{
"
keyword
"
:
keyword
}
}
background
:
function
(
)
{
browser
.
omnibox
.
onInputStarted
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
started
-
fired
"
)
;
}
)
;
let
synchronous
=
true
;
let
suggestions
=
null
;
let
suggestCallback
=
null
;
browser
.
omnibox
.
onInputChanged
.
addListener
(
(
text
suggest
)
=
>
{
if
(
synchronous
&
&
suggestions
)
{
suggest
(
suggestions
)
;
}
else
{
suggestCallback
=
suggest
;
}
browser
.
test
.
sendMessage
(
"
on
-
input
-
changed
-
fired
"
{
text
}
)
;
}
)
;
browser
.
omnibox
.
onInputCancelled
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
cancelled
-
fired
"
)
;
}
)
;
browser
.
omnibox
.
onInputEntered
.
addListener
(
(
text
disposition
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
}
)
;
}
)
;
browser
.
test
.
onMessage
.
addListener
(
(
msg
data
)
=
>
{
switch
(
msg
)
{
case
"
set
-
suggestions
"
:
suggestions
=
data
.
suggestions
;
browser
.
test
.
sendMessage
(
"
suggestions
-
set
"
)
;
break
;
case
"
set
-
default
-
suggestion
"
:
browser
.
omnibox
.
setDefaultSuggestion
(
data
.
suggestion
)
;
browser
.
test
.
sendMessage
(
"
default
-
suggestion
-
set
"
)
;
break
;
case
"
set
-
synchronous
"
:
synchronous
=
data
.
synchronous
;
break
;
case
"
test
-
multiple
-
suggest
-
calls
"
:
suggestions
.
forEach
(
suggestion
=
>
suggestCallback
(
[
suggestion
]
)
)
;
browser
.
test
.
sendMessage
(
"
test
-
ready
"
)
;
break
;
case
"
test
-
suggestions
-
after
-
delay
"
:
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
suggestCallback
(
suggestions
)
;
browser
.
test
.
sendMessage
(
"
test
-
ready
"
)
;
}
)
;
break
;
}
}
)
;
}
}
)
;
async
function
expectEvent
(
event
expected
=
{
}
)
{
let
actual
=
await
extension
.
awaitMessage
(
event
)
;
if
(
expected
.
text
)
{
is
(
actual
.
text
expected
.
text
Expected
"
{
event
}
"
to
have
fired
with
text
:
"
{
expected
.
text
}
"
.
)
;
}
if
(
expected
.
disposition
)
{
is
(
actual
.
disposition
expected
.
disposition
Expected
"
{
event
}
"
to
have
fired
with
disposition
:
"
{
expected
.
disposition
}
"
.
)
;
}
}
async
function
waitForAutocompleteResultAt
(
index
)
{
let
searchString
=
gURLBar
.
controller
.
searchString
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
gURLBar
.
popup
.
richlistbox
.
children
.
length
>
index
&
&
gURLBar
.
popup
.
richlistbox
.
children
[
index
]
.
getAttribute
(
"
ac
-
text
"
)
=
=
searchString
Waiting
for
the
autocomplete
result
for
"
{
searchString
}
"
at
[
{
index
}
]
to
appear
)
;
await
new
Promise
(
resolve
=
>
window
.
requestIdleCallback
(
resolve
{
timeout
:
1000
}
)
)
;
return
gURLBar
.
popup
.
richlistbox
.
children
[
index
]
;
}
async
function
promiseClickOnItem
(
item
details
)
{
let
clicked
=
false
;
item
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
clicked
=
true
;
}
{
once
:
true
}
)
;
while
(
!
clicked
)
{
EventUtils
.
synthesizeMouseAtCenter
(
item
details
)
;
await
new
Promise
(
r
=
>
window
.
requestIdleCallback
(
r
{
timeout
:
1000
}
)
)
;
}
}
let
inputSessionSerial
=
0
;
async
function
startInputSession
(
indexToWaitFor
)
{
gURLBar
.
focus
(
)
;
gURLBar
.
value
=
keyword
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
let
char
=
(
(
inputSessionSerial
+
+
)
%
10
)
.
toString
(
)
;
EventUtils
.
sendString
(
char
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
char
}
)
;
await
waitForAutocompleteResultAt
(
indexToWaitFor
)
;
return
char
;
}
async
function
testInputEvents
(
)
{
gURLBar
.
focus
(
)
;
EventUtils
.
sendString
(
keyword
+
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
expectEvent
(
"
on
-
input
-
entered
-
fired
"
)
;
gURLBar
.
focus
(
)
;
EventUtils
.
sendString
(
keyword
+
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
sendString
(
"
b
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
b
"
}
)
;
EventUtils
.
sendString
(
"
c
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
bc
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
b
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
"
}
)
;
gURLBar
.
blur
(
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
}
async
function
testHeuristicResult
(
expectedText
setDefaultSuggestion
)
{
if
(
setDefaultSuggestion
)
{
extension
.
sendMessage
(
"
set
-
default
-
suggestion
"
{
suggestion
:
{
description
:
expectedText
}
}
)
;
await
extension
.
awaitMessage
(
"
default
-
suggestion
-
set
"
)
;
}
let
text
=
await
startInputSession
(
0
)
;
let
item
=
gURLBar
.
popup
.
richlistbox
.
children
[
0
]
;
is
(
item
.
getAttribute
(
"
title
"
)
expectedText
Expected
heuristic
result
to
have
title
:
"
{
expectedText
}
"
.
)
;
is
(
item
.
getAttribute
(
"
displayurl
"
)
{
keyword
}
{
text
}
Expected
heuristic
result
to
have
displayurl
:
"
{
keyword
}
{
text
}
"
.
)
;
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
:
"
currentTab
"
}
)
;
await
promiseClickOnItem
(
item
{
}
)
;
await
promiseEvent
;
}
async
function
testDisposition
(
suggestionIndex
expectedDisposition
expectedText
)
{
await
startInputSession
(
suggestionIndex
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
repeat
:
suggestionIndex
}
)
;
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
:
expectedText
disposition
:
expectedDisposition
}
)
;
let
item
=
gURLBar
.
popup
.
richlistbox
.
children
[
suggestionIndex
]
;
if
(
expectedDisposition
=
=
"
currentTab
"
)
{
await
promiseClickOnItem
(
item
{
}
)
;
}
else
if
(
expectedDisposition
=
=
"
newForegroundTab
"
)
{
await
promiseClickOnItem
(
item
{
accelKey
:
true
}
)
;
}
else
if
(
expectedDisposition
=
=
"
newBackgroundTab
"
)
{
await
promiseClickOnItem
(
item
{
shiftKey
:
true
accelKey
:
true
}
)
;
}
await
promiseEvent
;
}
async
function
testSuggestions
(
info
)
{
extension
.
sendMessage
(
"
set
-
synchronous
"
{
synchronous
:
false
}
)
;
function
expectSuggestion
(
{
content
description
}
index
)
{
let
item
=
gURLBar
.
popup
.
richlistbox
.
children
[
index
+
1
]
;
ok
(
!
!
item
"
Expected
item
to
exist
"
)
;
is
(
item
.
getAttribute
(
"
title
"
)
description
Expected
suggestion
to
have
title
:
"
{
description
}
"
.
)
;
is
(
item
.
getAttribute
(
"
displayurl
"
)
{
keyword
}
{
content
}
Expected
suggestion
to
have
displayurl
:
"
{
keyword
}
{
content
}
"
.
)
;
}
let
text
=
await
startInputSession
(
info
.
suggestions
.
length
-
1
)
;
extension
.
sendMessage
(
info
.
test
)
;
await
extension
.
awaitMessage
(
"
test
-
ready
"
)
;
info
.
suggestions
.
forEach
(
expectSuggestion
)
;
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
:
"
currentTab
"
}
)
;
await
promiseClickOnItem
(
gURLBar
.
popup
.
richlistbox
.
children
[
0
]
{
}
)
;
await
promiseEvent
;
}
await
extension
.
startup
(
)
;
await
SimpleTest
.
promiseFocus
(
window
)
;
await
testInputEvents
(
)
;
await
testHeuristicResult
(
"
Generated
extension
"
false
)
;
await
testHeuristicResult
(
"
hello
world
"
true
)
;
await
testHeuristicResult
(
"
foo
bar
"
true
)
;
let
suggestions
=
[
{
content
:
"
a
"
description
:
"
select
a
"
}
{
content
:
"
b
"
description
:
"
select
b
"
}
{
content
:
"
c
"
description
:
"
select
c
"
}
]
;
extension
.
sendMessage
(
"
set
-
suggestions
"
{
suggestions
}
)
;
await
extension
.
awaitMessage
(
"
suggestions
-
set
"
)
;
await
testDisposition
(
1
"
currentTab
"
suggestions
[
0
]
.
content
)
;
await
testDisposition
(
2
"
newForegroundTab
"
suggestions
[
1
]
.
content
)
;
await
testDisposition
(
3
"
newBackgroundTab
"
suggestions
[
2
]
.
content
)
;
extension
.
sendMessage
(
"
set
-
suggestions
"
{
suggestions
}
)
;
await
extension
.
awaitMessage
(
"
suggestions
-
set
"
)
;
await
testSuggestions
(
{
test
:
"
test
-
multiple
-
suggest
-
calls
"
suggestions
}
)
;
await
testSuggestions
(
{
test
:
"
test
-
suggestions
-
after
-
delay
"
suggestions
}
)
;
let
waitForConsole
=
new
Promise
(
resolve
=
>
{
SimpleTest
.
monitorConsole
(
resolve
[
{
message
:
new
RegExp
(
The
keyword
provided
is
already
registered
:
"
{
keyword
}
"
)
}
]
)
;
}
)
;
let
extension2
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
"
omnibox
"
:
{
"
keyword
"
:
keyword
}
}
}
)
;
await
extension2
.
startup
(
)
;
SimpleTest
.
endMonitorConsole
(
)
;
await
waitForConsole
;
await
extension2
.
unload
(
)
;
await
extension
.
unload
(
)
;
}
)
;
