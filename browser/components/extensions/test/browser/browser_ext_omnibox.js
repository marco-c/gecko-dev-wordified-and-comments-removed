"
use
strict
"
;
const
{
UrlbarTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
jsm
"
)
;
add_task
(
async
function
(
)
{
let
keyword
=
"
VeryUniqueKeywordThatDoesNeverMatchAnyTestUrl
"
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
omnibox
:
{
keyword
:
keyword
}
}
background
:
function
(
)
{
browser
.
omnibox
.
onInputStarted
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
started
-
fired
"
)
;
}
)
;
let
synchronous
=
true
;
let
suggestions
=
null
;
let
suggestCallback
=
null
;
browser
.
omnibox
.
onInputChanged
.
addListener
(
(
text
suggest
)
=
>
{
if
(
synchronous
&
&
suggestions
)
{
suggest
(
suggestions
)
;
}
else
{
suggestCallback
=
suggest
;
}
browser
.
test
.
sendMessage
(
"
on
-
input
-
changed
-
fired
"
{
text
}
)
;
}
)
;
browser
.
omnibox
.
onInputCancelled
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
cancelled
-
fired
"
)
;
}
)
;
browser
.
omnibox
.
onInputEntered
.
addListener
(
(
text
disposition
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
}
)
;
}
)
;
browser
.
test
.
onMessage
.
addListener
(
(
msg
data
)
=
>
{
switch
(
msg
)
{
case
"
set
-
suggestions
"
:
suggestions
=
data
.
suggestions
;
browser
.
test
.
sendMessage
(
"
suggestions
-
set
"
)
;
break
;
case
"
set
-
default
-
suggestion
"
:
browser
.
omnibox
.
setDefaultSuggestion
(
data
.
suggestion
)
;
browser
.
test
.
sendMessage
(
"
default
-
suggestion
-
set
"
)
;
break
;
case
"
set
-
synchronous
"
:
synchronous
=
data
.
synchronous
;
browser
.
test
.
sendMessage
(
"
set
-
synchronous
-
set
"
)
;
break
;
case
"
test
-
multiple
-
suggest
-
calls
"
:
suggestions
.
forEach
(
suggestion
=
>
suggestCallback
(
[
suggestion
]
)
)
;
browser
.
test
.
sendMessage
(
"
test
-
ready
"
)
;
break
;
case
"
test
-
suggestions
-
after
-
delay
"
:
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
suggestCallback
(
suggestions
)
;
browser
.
test
.
sendMessage
(
"
test
-
ready
"
)
;
}
)
;
break
;
}
}
)
;
}
}
)
;
async
function
expectEvent
(
event
expected
=
{
}
)
{
let
actual
=
await
extension
.
awaitMessage
(
event
)
;
if
(
expected
.
text
)
{
is
(
actual
.
text
expected
.
text
Expected
"
{
event
}
"
to
have
fired
with
text
:
"
{
expected
.
text
}
"
.
)
;
}
if
(
expected
.
disposition
)
{
is
(
actual
.
disposition
expected
.
disposition
Expected
"
{
event
}
"
to
have
fired
with
disposition
:
"
{
expected
.
disposition
}
"
.
)
;
}
}
async
function
waitForResult
(
index
searchString
)
{
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
await
new
Promise
(
resolve
=
>
window
.
requestIdleCallback
(
resolve
{
timeout
:
1000
}
)
)
;
return
result
;
}
async
function
promiseClickOnItem
(
index
details
)
{
let
clicked
=
false
;
let
element
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
index
)
;
element
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
clicked
=
true
;
}
{
once
:
true
}
)
;
while
(
!
clicked
)
{
EventUtils
.
synthesizeMouseAtCenter
(
element
details
)
;
await
new
Promise
(
r
=
>
window
.
requestIdleCallback
(
r
{
timeout
:
1000
}
)
)
;
}
}
let
inputSessionSerial
=
0
;
async
function
startInputSession
(
)
{
gURLBar
.
focus
(
)
;
gURLBar
.
value
=
keyword
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
let
char
=
(
inputSessionSerial
+
+
%
10
)
.
toString
(
)
;
EventUtils
.
sendString
(
char
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
char
}
)
;
return
char
;
}
async
function
testInputEvents
(
)
{
gURLBar
.
focus
(
)
;
EventUtils
.
sendString
(
keyword
+
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
expectEvent
(
"
on
-
input
-
entered
-
fired
"
)
;
gURLBar
.
focus
(
)
;
EventUtils
.
sendString
(
keyword
+
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
sendString
(
"
b
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
b
"
}
)
;
EventUtils
.
sendString
(
"
c
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
bc
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
b
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
"
}
)
;
gURLBar
.
blur
(
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
}
async
function
testHeuristicResult
(
expectedText
setDefaultSuggestion
)
{
if
(
setDefaultSuggestion
)
{
extension
.
sendMessage
(
"
set
-
default
-
suggestion
"
{
suggestion
:
{
description
:
expectedText
}
}
)
;
await
extension
.
awaitMessage
(
"
default
-
suggestion
-
set
"
)
;
}
let
text
=
await
startInputSession
(
)
;
let
result
=
await
waitForResult
(
0
)
;
Assert
.
equal
(
result
.
displayed
.
title
expectedText
Expected
heuristic
result
to
have
title
:
"
{
expectedText
}
"
.
)
;
Assert
.
equal
(
result
.
displayed
.
action
{
keyword
}
{
text
}
Expected
heuristic
result
to
have
displayurl
:
"
{
keyword
}
{
text
}
"
.
)
;
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
:
"
currentTab
"
}
)
;
await
promiseClickOnItem
(
0
{
}
)
;
await
promiseEvent
;
}
async
function
testDisposition
(
suggestionIndex
expectedDisposition
expectedText
)
{
await
startInputSession
(
)
;
await
waitForResult
(
suggestionIndex
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
repeat
:
suggestionIndex
}
)
;
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
:
expectedText
disposition
:
expectedDisposition
}
)
;
if
(
expectedDisposition
=
=
"
currentTab
"
)
{
await
promiseClickOnItem
(
suggestionIndex
{
}
)
;
}
else
if
(
expectedDisposition
=
=
"
newForegroundTab
"
)
{
await
promiseClickOnItem
(
suggestionIndex
{
accelKey
:
true
}
)
;
}
else
if
(
expectedDisposition
=
=
"
newBackgroundTab
"
)
{
await
promiseClickOnItem
(
suggestionIndex
{
shiftKey
:
true
accelKey
:
true
}
)
;
}
await
promiseEvent
;
}
async
function
testSuggestions
(
info
)
{
extension
.
sendMessage
(
"
set
-
synchronous
"
{
synchronous
:
false
}
)
;
await
extension
.
awaitMessage
(
"
set
-
synchronous
-
set
"
)
;
let
text
=
await
startInputSession
(
)
;
extension
.
sendMessage
(
info
.
test
)
;
await
extension
.
awaitMessage
(
"
test
-
ready
"
)
;
await
waitForResult
(
info
.
suggestions
.
length
-
1
)
;
let
index
=
1
;
for
(
let
{
content
description
}
of
info
.
suggestions
)
{
let
item
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
Assert
.
equal
(
item
.
displayed
.
title
description
Expected
suggestion
to
have
title
:
"
{
description
}
"
.
)
;
Assert
.
equal
(
item
.
displayed
.
action
{
keyword
}
{
content
}
Expected
suggestion
to
have
displayurl
:
"
{
keyword
}
{
content
}
"
.
)
;
index
+
+
;
}
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
:
"
currentTab
"
}
)
;
await
promiseClickOnItem
(
0
{
}
)
;
await
promiseEvent
;
}
await
extension
.
startup
(
)
;
await
SimpleTest
.
promiseFocus
(
window
)
;
await
testInputEvents
(
)
;
await
testHeuristicResult
(
"
Generated
extension
"
false
)
;
await
testHeuristicResult
(
"
hello
world
"
true
)
;
await
testHeuristicResult
(
"
foo
bar
"
true
)
;
let
suggestions
=
[
{
content
:
"
a
"
description
:
"
select
a
"
}
{
content
:
"
b
"
description
:
"
select
b
"
}
{
content
:
"
c
"
description
:
"
select
c
"
}
]
;
extension
.
sendMessage
(
"
set
-
suggestions
"
{
suggestions
}
)
;
await
extension
.
awaitMessage
(
"
suggestions
-
set
"
)
;
await
testDisposition
(
1
"
currentTab
"
suggestions
[
0
]
.
content
)
;
await
testDisposition
(
2
"
newForegroundTab
"
suggestions
[
1
]
.
content
)
;
await
testDisposition
(
3
"
newBackgroundTab
"
suggestions
[
2
]
.
content
)
;
extension
.
sendMessage
(
"
set
-
suggestions
"
{
suggestions
}
)
;
await
extension
.
awaitMessage
(
"
suggestions
-
set
"
)
;
await
testSuggestions
(
{
test
:
"
test
-
multiple
-
suggest
-
calls
"
suggestions
}
)
;
await
testSuggestions
(
{
test
:
"
test
-
suggestions
-
after
-
delay
"
suggestions
}
)
;
SimpleTest
.
waitForExplicitFinish
(
)
;
let
waitForConsole
=
new
Promise
(
resolve
=
>
{
SimpleTest
.
monitorConsole
(
resolve
[
{
message
:
new
RegExp
(
The
keyword
provided
is
already
registered
:
"
{
keyword
}
"
)
}
]
)
;
}
)
;
let
extension2
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
omnibox
:
{
keyword
:
keyword
}
}
}
)
;
await
extension2
.
startup
(
)
;
SimpleTest
.
endMonitorConsole
(
)
;
await
waitForConsole
;
await
extension2
.
unload
(
)
;
await
extension
.
unload
(
)
;
}
)
;
