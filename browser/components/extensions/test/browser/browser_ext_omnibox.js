"
use
strict
"
;
const
{
UrlbarTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
UrlbarTestUtils
.
sys
.
mjs
"
)
;
const
keyword
=
"
VeryUniqueKeywordThatDoesNeverMatchAnyTestUrl
"
;
function
getCallerLines
(
)
{
const
lines
=
Array
.
from
(
new
Error
(
)
.
stack
.
split
(
"
\
n
"
)
.
slice
(
1
)
line
=
>
/
browser_ext_omnibox
.
js
:
(
\
d
+
)
:
\
d
+
/
.
exec
(
line
)
?
.
[
1
]
)
;
return
"
Caller
lines
:
"
+
lines
.
filter
(
lineno
=
>
lineno
!
=
null
)
.
join
(
"
"
)
;
}
add_setup
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
extension
.
omnibox
.
timeout
"
500
]
]
}
)
;
}
)
;
add_task
(
async
function
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
omnibox
:
{
keyword
:
keyword
}
}
background
:
function
(
)
{
browser
.
omnibox
.
onInputStarted
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
started
-
fired
"
)
;
}
)
;
let
synchronous
=
true
;
let
suggestions
=
null
;
let
suggestCallback
=
null
;
browser
.
omnibox
.
onInputChanged
.
addListener
(
(
text
suggest
)
=
>
{
if
(
synchronous
&
&
suggestions
)
{
suggest
(
suggestions
)
;
}
else
{
suggestCallback
=
suggest
;
}
browser
.
test
.
sendMessage
(
"
on
-
input
-
changed
-
fired
"
{
text
}
)
;
}
)
;
browser
.
omnibox
.
onInputCancelled
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
cancelled
-
fired
"
)
;
}
)
;
browser
.
omnibox
.
onInputEntered
.
addListener
(
(
text
disposition
)
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
}
)
;
}
)
;
browser
.
omnibox
.
onDeleteSuggestion
.
addListener
(
text
=
>
{
browser
.
test
.
sendMessage
(
"
on
-
delete
-
suggestion
-
fired
"
{
text
}
)
;
}
)
;
browser
.
test
.
onMessage
.
addListener
(
(
msg
data
)
=
>
{
switch
(
msg
)
{
case
"
set
-
suggestions
"
:
suggestions
=
data
.
suggestions
;
browser
.
test
.
sendMessage
(
"
suggestions
-
set
"
)
;
break
;
case
"
set
-
default
-
suggestion
"
:
browser
.
omnibox
.
setDefaultSuggestion
(
data
.
suggestion
)
;
browser
.
test
.
sendMessage
(
"
default
-
suggestion
-
set
"
)
;
break
;
case
"
set
-
synchronous
"
:
synchronous
=
data
.
synchronous
;
browser
.
test
.
sendMessage
(
"
set
-
synchronous
-
set
"
)
;
break
;
case
"
test
-
multiple
-
suggest
-
calls
"
:
suggestions
.
forEach
(
suggestion
=
>
suggestCallback
(
[
suggestion
]
)
)
;
browser
.
test
.
sendMessage
(
"
test
-
ready
"
)
;
break
;
case
"
test
-
suggestions
-
after
-
delay
"
:
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
suggestCallback
(
suggestions
)
;
browser
.
test
.
sendMessage
(
"
test
-
ready
"
)
;
}
)
;
break
;
}
}
)
;
}
}
)
;
async
function
expectEvent
(
event
expected
)
{
info
(
Waiting
for
event
:
{
event
}
(
{
getCallerLines
(
)
}
)
)
;
let
actual
=
await
extension
.
awaitMessage
(
event
)
;
if
(
!
expected
)
{
ok
(
true
Expected
"
{
event
}
to
have
fired
.
"
)
;
return
;
}
if
(
expected
.
text
!
=
undefined
)
{
is
(
actual
.
text
expected
.
text
Expected
"
{
event
}
"
to
have
fired
with
text
:
"
{
expected
.
text
}
"
.
)
;
}
if
(
expected
.
disposition
)
{
is
(
actual
.
disposition
expected
.
disposition
Expected
"
{
event
}
"
to
have
fired
with
disposition
:
"
{
expected
.
disposition
}
"
.
)
;
}
}
async
function
waitForResult
(
index
)
{
info
(
waitForResult
(
{
getCallerLines
(
)
}
)
)
;
let
result
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
await
new
Promise
(
resolve
=
>
window
.
requestIdleCallback
(
resolve
{
timeout
:
1000
}
)
)
;
return
result
;
}
async
function
promiseClickOnItem
(
index
details
)
{
let
clicked
=
false
;
let
element
=
await
UrlbarTestUtils
.
waitForAutocompleteResultAt
(
window
index
)
;
element
.
addEventListener
(
"
mousedown
"
(
)
=
>
{
clicked
=
true
;
}
{
once
:
true
}
)
;
while
(
!
clicked
)
{
EventUtils
.
synthesizeMouseAtCenter
(
element
details
)
;
await
new
Promise
(
r
=
>
window
.
requestIdleCallback
(
r
{
timeout
:
1000
}
)
)
;
}
}
let
inputSessionSerial
=
0
;
async
function
startInputSession
(
)
{
gURLBar
.
focus
(
)
;
gURLBar
.
value
=
keyword
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
let
char
=
(
inputSessionSerial
+
+
%
10
)
.
toString
(
)
;
EventUtils
.
sendString
(
char
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
char
}
)
;
return
char
;
}
async
function
testInputEvents
(
)
{
gURLBar
.
focus
(
)
;
EventUtils
.
sendString
(
keyword
+
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
expectEvent
(
"
on
-
input
-
entered
-
fired
"
)
;
gURLBar
.
focus
(
)
;
EventUtils
.
sendString
(
keyword
+
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
sendString
(
"
b
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
b
"
}
)
;
EventUtils
.
sendString
(
"
c
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
bc
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
b
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
"
}
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Backspace
"
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
started
-
fired
"
)
;
EventUtils
.
sendString
(
"
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
{
text
:
"
"
}
)
;
gURLBar
.
blur
(
)
;
await
expectEvent
(
"
on
-
input
-
cancelled
-
fired
"
)
;
}
async
function
testSuggestionDeletion
(
)
{
extension
.
sendMessage
(
"
set
-
suggestions
"
{
suggestions
:
[
{
content
:
"
a
"
description
:
"
select
a
"
deletable
:
true
}
]
}
)
;
await
extension
.
awaitMessage
(
"
suggestions
-
set
"
)
;
gURLBar
.
focus
(
)
;
EventUtils
.
sendString
(
keyword
)
;
EventUtils
.
sendString
(
"
select
a
"
)
;
await
expectEvent
(
"
on
-
input
-
changed
-
fired
"
)
;
await
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
await
EventUtils
.
synthesizeKey
(
"
KEY_Delete
"
{
shiftKey
:
true
}
)
;
await
expectEvent
(
"
on
-
delete
-
suggestion
-
fired
"
{
text
:
"
select
a
"
}
)
;
}
async
function
testHeuristicResult
(
expectedText
setDefaultSuggestion
)
{
if
(
setDefaultSuggestion
)
{
extension
.
sendMessage
(
"
set
-
default
-
suggestion
"
{
suggestion
:
{
description
:
expectedText
}
}
)
;
await
extension
.
awaitMessage
(
"
default
-
suggestion
-
set
"
)
;
}
let
text
=
await
startInputSession
(
)
;
let
result
=
await
waitForResult
(
0
)
;
Assert
.
equal
(
result
.
displayed
.
title
expectedText
Expected
heuristic
result
to
have
title
:
"
{
expectedText
}
"
.
)
;
Assert
.
equal
(
result
.
displayed
.
action
{
keyword
}
{
text
}
Expected
heuristic
result
to
have
displayurl
:
"
{
keyword
}
{
text
}
"
.
)
;
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
:
"
currentTab
"
}
)
;
await
promiseClickOnItem
(
0
{
}
)
;
await
promiseEvent
;
}
async
function
testDisposition
(
suggestionIndex
expectedDisposition
expectedText
)
{
await
startInputSession
(
)
;
await
waitForResult
(
suggestionIndex
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
{
repeat
:
suggestionIndex
}
)
;
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
:
expectedText
disposition
:
expectedDisposition
}
)
;
if
(
expectedDisposition
=
=
"
currentTab
"
)
{
await
promiseClickOnItem
(
suggestionIndex
{
}
)
;
}
else
if
(
expectedDisposition
=
=
"
newForegroundTab
"
)
{
await
promiseClickOnItem
(
suggestionIndex
{
accelKey
:
true
}
)
;
}
else
if
(
expectedDisposition
=
=
"
newBackgroundTab
"
)
{
await
promiseClickOnItem
(
suggestionIndex
{
shiftKey
:
true
accelKey
:
true
}
)
;
}
await
promiseEvent
;
}
async
function
testSuggestions
(
info
)
{
extension
.
sendMessage
(
"
set
-
synchronous
"
{
synchronous
:
false
}
)
;
await
extension
.
awaitMessage
(
"
set
-
synchronous
-
set
"
)
;
let
text
=
await
startInputSession
(
)
;
extension
.
sendMessage
(
info
.
test
)
;
await
extension
.
awaitMessage
(
"
test
-
ready
"
)
;
await
waitForResult
(
info
.
suggestions
.
length
-
1
)
;
let
index
=
1
;
for
(
let
{
content
description
}
of
info
.
suggestions
)
{
let
item
=
await
UrlbarTestUtils
.
getDetailsOfResultAt
(
window
index
)
;
Assert
.
equal
(
item
.
displayed
.
title
description
Expected
suggestion
to
have
title
:
"
{
description
}
"
.
)
;
Assert
.
equal
(
item
.
displayed
.
action
{
keyword
}
{
content
}
Expected
suggestion
to
have
displayurl
:
"
{
keyword
}
{
content
}
"
.
)
;
index
+
+
;
}
let
promiseEvent
=
expectEvent
(
"
on
-
input
-
entered
-
fired
"
{
text
disposition
:
"
currentTab
"
}
)
;
await
promiseClickOnItem
(
0
{
}
)
;
await
promiseEvent
;
}
await
extension
.
startup
(
)
;
await
SimpleTest
.
promiseFocus
(
window
)
;
await
testInputEvents
(
)
;
await
testSuggestionDeletion
(
)
;
await
testHeuristicResult
(
"
Generated
extension
"
false
)
;
await
testHeuristicResult
(
"
hello
world
"
true
)
;
await
testHeuristicResult
(
"
foo
bar
"
true
)
;
let
suggestions
=
[
{
content
:
"
a
"
description
:
"
select
a
"
}
{
content
:
"
b
"
description
:
"
select
b
"
}
{
content
:
"
c
"
description
:
"
select
c
"
}
]
;
extension
.
sendMessage
(
"
set
-
suggestions
"
{
suggestions
}
)
;
await
extension
.
awaitMessage
(
"
suggestions
-
set
"
)
;
await
testDisposition
(
1
"
currentTab
"
suggestions
[
0
]
.
content
)
;
await
testDisposition
(
2
"
newForegroundTab
"
suggestions
[
1
]
.
content
)
;
await
testDisposition
(
3
"
newBackgroundTab
"
suggestions
[
2
]
.
content
)
;
extension
.
sendMessage
(
"
set
-
suggestions
"
{
suggestions
}
)
;
await
extension
.
awaitMessage
(
"
suggestions
-
set
"
)
;
await
testSuggestions
(
{
test
:
"
test
-
multiple
-
suggest
-
calls
"
suggestions
}
)
;
await
testSuggestions
(
{
test
:
"
test
-
suggestions
-
after
-
delay
"
suggestions
}
)
;
SimpleTest
.
waitForExplicitFinish
(
)
;
let
waitForConsole
=
new
Promise
(
resolve
=
>
{
SimpleTest
.
monitorConsole
(
resolve
[
{
message
:
new
RegExp
(
The
keyword
provided
is
already
registered
:
"
{
keyword
}
"
)
}
]
)
;
}
)
;
let
extension2
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
omnibox
:
{
keyword
:
keyword
}
}
}
)
;
await
extension2
.
startup
(
)
;
SimpleTest
.
endMonitorConsole
(
)
;
await
waitForConsole
;
await
extension2
.
unload
(
)
;
await
extension
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_omnibox_event_page
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
extensions
.
eventPages
.
enabled
"
true
]
]
}
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
"
eventpage
omnibox
"
}
}
omnibox
:
{
keyword
:
keyword
}
background
:
{
persistent
:
false
}
}
background
(
)
{
browser
.
omnibox
.
onInputStarted
.
addListener
(
(
)
=
>
{
browser
.
test
.
sendMessage
(
"
onInputStarted
"
)
;
}
)
;
browser
.
omnibox
.
onInputEntered
.
addListener
(
(
)
=
>
{
}
)
;
browser
.
omnibox
.
onInputChanged
.
addListener
(
(
)
=
>
{
}
)
;
browser
.
omnibox
.
onInputCancelled
.
addListener
(
(
)
=
>
{
}
)
;
browser
.
omnibox
.
onDeleteSuggestion
.
addListener
(
(
)
=
>
{
}
)
;
browser
.
test
.
sendMessage
(
"
ready
"
)
;
}
}
)
;
const
EVENTS
=
[
"
onInputStarted
"
"
onInputEntered
"
"
onInputChanged
"
"
onInputCancelled
"
"
onDeleteSuggestion
"
]
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
ready
"
)
;
for
(
let
event
of
EVENTS
)
{
assertPersistentListeners
(
extension
"
omnibox
"
event
{
primed
:
false
}
)
;
}
await
extension
.
terminateBackground
(
)
;
for
(
let
event
of
EVENTS
)
{
assertPersistentListeners
(
extension
"
omnibox
"
event
{
primed
:
true
}
)
;
}
gURLBar
.
focus
(
)
;
gURLBar
.
value
=
keyword
;
EventUtils
.
sendString
(
"
"
)
;
await
extension
.
awaitMessage
(
"
ready
"
)
;
await
extension
.
awaitMessage
(
"
onInputStarted
"
)
;
ok
(
true
"
persistent
event
woke
background
"
)
;
for
(
let
event
of
EVENTS
)
{
assertPersistentListeners
(
extension
"
omnibox
"
event
{
primed
:
false
}
)
;
}
await
extension
.
unload
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_omnibox_input_is_user_interaction
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
"
user
-
interaction
omnibox
"
}
}
omnibox
:
{
keyword
:
keyword
}
}
async
background
(
)
{
async
function
checkIsHandlingUserInput
(
)
{
try
{
let
granted
=
await
browser
.
permissions
.
request
(
{
}
)
;
browser
.
test
.
assertTrue
(
granted
"
empty
permissions
granted
"
)
;
return
true
;
}
catch
(
e
)
{
browser
.
test
.
assertEq
(
e
?
.
message
"
permissions
.
request
may
only
be
called
from
a
user
input
handler
"
"
Expected
error
when
permissions
.
request
rejects
"
)
;
return
false
;
}
}
browser
.
omnibox
.
onInputEntered
.
addListener
(
async
(
)
=
>
{
browser
.
test
.
assertTrue
(
await
checkIsHandlingUserInput
(
)
"
omnibox
.
onInputEntered
is
handling
user
input
"
)
;
browser
.
test
.
notifyPass
(
"
action
-
clicked
"
)
;
}
)
;
browser
.
test
.
assertFalse
(
await
checkIsHandlingUserInput
(
)
"
not
handling
user
input
by
default
"
)
;
browser
.
test
.
sendMessage
(
"
ready
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
ready
"
)
;
gURLBar
.
focus
(
)
;
gURLBar
.
value
=
keyword
;
EventUtils
.
sendString
(
"
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
await
extension
.
awaitFinish
(
"
action
-
clicked
"
)
;
await
extension
.
unload
(
)
;
}
)
;
