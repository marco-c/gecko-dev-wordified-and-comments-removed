"
use
strict
"
;
loadTestSubscript
(
"
head_unified_extensions
.
js
"
)
;
const
PREF_ALWAYS_VISIBLE
=
"
extensions
.
unifiedExtensions
.
button
.
always_visible
"
;
function
showButtonWithPref
(
)
{
info
(
showButtonWithPref
:
Setting
{
PREF_ALWAYS_VISIBLE
}
to
true
)
;
Services
.
prefs
.
setBoolPref
(
PREF_ALWAYS_VISIBLE
true
)
;
}
function
hideButtonWithPref
(
)
{
info
(
hideButtonWithPref
:
Setting
{
PREF_ALWAYS_VISIBLE
}
to
false
)
;
Services
.
prefs
.
setBoolPref
(
PREF_ALWAYS_VISIBLE
false
)
;
}
function
resetButtonVisibilityToDefault
(
)
{
Services
.
prefs
.
clearUserPref
(
PREF_ALWAYS_VISIBLE
)
;
}
function
assertTelemetryValueMatchesAlwaysVisiblePref
(
)
{
is
(
Glean
.
extensionsButton
.
prefersHiddenButton
.
testGetValue
(
)
!
Services
.
prefs
.
getBoolPref
(
PREF_ALWAYS_VISIBLE
)
"
extensions_button
.
prefers_hidden_button
is
inverse
of
pref
value
"
)
;
}
async
function
checkAndDismissPostHideNotification
(
win
)
{
info
(
"
Verifying
that
the
'
Moved
to
menu
'
hint
is
shown
"
)
;
let
hintElem
=
win
.
ConfirmationHint
.
_panel
;
if
(
hintElem
.
state
!
=
=
"
open
"
)
{
info
(
"
Waiting
for
hint
to
be
shown
"
)
;
await
BrowserTestUtils
.
waitForEvent
(
hintElem
"
popupshown
"
)
;
}
is
(
hintElem
.
state
"
open
"
"
Hint
popup
is
open
"
)
;
is
(
hintElem
.
anchorNode
.
id
"
PanelUI
-
menu
-
button
"
"
Anchored
to
appmenu
"
)
;
is
(
win
.
ConfirmationHint
.
_message
.
getAttribute
(
"
data
-
l10n
-
id
"
)
"
confirmation
-
hint
-
extensions
-
button
-
hidden
"
"
Shown
'
Moved
to
menu
'
notification
"
)
;
let
hiddenpromise
=
BrowserTestUtils
.
waitForEvent
(
hintElem
"
popuphidden
"
)
;
hintElem
.
hidePopup
(
)
;
info
(
"
Waiting
for
hint
to
be
dismissed
"
)
;
await
hiddenpromise
;
}
registerCleanupFunction
(
resetButtonVisibilityToDefault
)
;
add_task
(
async
function
test_default_button_visibility
(
)
{
assertExtensionsButtonVisible
(
)
;
is
(
Glean
.
extensionsButton
.
prefersHiddenButton
.
testGetValue
(
)
false
"
extensions_button
.
prefers_hidden_button
is
false
by
default
"
)
;
}
)
;
add_task
(
async
function
test_hide_button_before_new_window
(
)
{
hideButtonWithPref
(
)
;
assertTelemetryValueMatchesAlwaysVisiblePref
(
)
;
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
assertExtensionsButtonHidden
(
win
)
;
showButtonWithPref
(
)
;
assertTelemetryValueMatchesAlwaysVisiblePref
(
)
;
assertExtensionsButtonVisible
(
win
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
resetButtonVisibilityToDefault
(
)
;
}
)
;
add_task
(
async
function
test_show_button_before_new_window
(
)
{
showButtonWithPref
(
)
;
assertTelemetryValueMatchesAlwaysVisiblePref
(
)
;
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
assertExtensionsButtonVisible
(
win
)
;
hideButtonWithPref
(
)
;
assertTelemetryValueMatchesAlwaysVisiblePref
(
)
;
assertExtensionsButtonHidden
(
win
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
resetButtonVisibilityToDefault
(
)
;
}
)
;
add_task
(
async
function
test_delay_hide_button_while_mouse_is_on_toolbar
(
)
{
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
resetExtensionsButtonTelemetry
(
)
;
hideButtonWithPref
(
)
;
const
navbar
=
win
.
document
.
getElementById
(
"
nav
-
bar
"
)
;
navbar
.
dispatchEvent
(
new
win
.
MouseEvent
(
"
mouseover
"
)
)
;
win
.
gUnifiedExtensions
.
updateButtonVisibility
(
)
;
info
(
"
Mouse
on
navbar
does
not
show
the
button
"
)
;
win
.
gUnifiedExtensions
.
updateButtonVisibility
(
)
;
assertExtensionsButtonHidden
(
win
)
;
info
(
"
Simulate
button
being
visible
while
the
mouse
is
on
the
toolbar
"
)
;
win
.
gUnifiedExtensions
.
button
.
hidden
=
false
;
win
.
gUnifiedExtensions
.
updateButtonVisibility
(
)
;
info
(
"
Extensions
button
should
still
be
hidden
in
another
window
"
)
;
assertExtensionsButtonHidden
(
window
)
;
info
(
"
Extensions
button
should
still
be
shown
while
mouse
is
on
toolbar
"
)
;
assertExtensionsButtonVisible
(
win
)
;
info
(
"
Extensions
button
should
still
be
shown
when
mouse
moves
over
toolbar
"
)
;
const
relatedTarget
=
navbar
.
querySelector
(
"
#
urlbar
"
)
;
ok
(
relatedTarget
"
Sanity
check
:
Has
other
element
within
navbar
"
)
;
navbar
.
dispatchEvent
(
new
win
.
MouseEvent
(
"
mouseout
"
{
relatedTarget
}
)
)
;
assertExtensionsButtonVisible
(
win
)
;
info
(
"
Extensions
button
should
hide
after
the
mouse
goes
off
the
toolbar
"
)
;
navbar
.
dispatchEvent
(
new
win
.
MouseEvent
(
"
mouseout
"
)
)
;
assertExtensionsButtonHidden
(
win
)
;
assertExtensionsButtonTelemetry
(
{
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
resetButtonVisibilityToDefault
(
)
;
}
)
;
add_task
(
async
function
test_hide_button_via_contextmenu
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
contextMenu
=
await
openChromeContextMenu
(
"
toolbar
-
context
-
menu
"
"
#
unified
-
extensions
-
button
"
win
)
;
const
removeFromToolbar
=
contextMenu
.
querySelector
(
"
.
customize
-
context
-
removeFromToolbar
"
)
;
is
(
removeFromToolbar
.
hidden
false
"
removeFromToolbar
is
visible
"
)
;
ok
(
!
removeFromToolbar
.
hasAttribute
(
"
disabled
"
)
"
removeFromToolbar
enabled
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
removeFromToolbar
win
)
;
info
(
"
Extensions
button
should
hide
after
choosing
'
Remove
from
Toolbar
'
"
)
;
assertExtensionsButtonHidden
(
win
)
;
info
(
"
Extensions
button
should
also
be
hidden
in
another
window
"
)
;
assertExtensionsButtonHidden
(
window
)
;
Assert
.
deepEqual
(
Glean
.
extensionsButton
.
toggleVisibility
.
testGetValue
(
)
.
map
(
e
=
>
e
.
extra
)
[
{
is_customizing
:
"
false
"
is_extensions_panel_empty
:
"
false
"
is_temporarily_shown
:
"
false
"
should_hide
:
"
true
"
}
]
"
Expected
extensions_button
.
toggle_visibility
telemetry
after
hiding
"
)
;
await
checkAndDismissPostHideNotification
(
win
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
resetButtonVisibilityToDefault
(
)
;
}
)
;
add_task
(
async
function
test_menu_items_on_hidden_button
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
hideButtonWithPref
(
)
;
gUnifiedExtensions
.
button
.
hidden
=
false
;
const
contextMenu
=
await
openChromeContextMenu
(
"
toolbar
-
context
-
menu
"
"
#
unified
-
extensions
-
button
"
)
;
gUnifiedExtensions
.
button
.
hidden
=
true
;
assertExtensionsButtonHidden
(
)
;
const
removeFromToolbar
=
contextMenu
.
querySelector
(
"
.
customize
-
context
-
removeFromToolbar
"
)
;
is
(
removeFromToolbar
.
hidden
true
"
removeFromToolbar
is
hidden
"
)
;
ok
(
removeFromToolbar
.
hasAttribute
(
"
disabled
"
)
"
removeFromToolbar
disabled
"
)
;
const
item
=
contextMenu
.
querySelector
(
"
#
toolbar
-
context
-
always
-
show
-
extensions
-
button
"
)
;
is
(
item
.
hidden
false
"
'
Always
Show
in
Toolbar
'
menu
item
shown
"
)
;
ok
(
!
item
.
hasAttribute
(
"
checked
"
)
"
Should
be
unchecked
to
reflect
pref
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
item
)
;
assertExtensionsButtonVisible
(
)
;
Assert
.
deepEqual
(
Glean
.
extensionsButton
.
toggleVisibility
.
testGetValue
(
)
.
map
(
e
=
>
e
.
extra
)
[
{
is_extensions_panel_empty
:
"
false
"
is_customizing
:
"
false
"
is_temporarily_shown
:
"
false
"
should_hide
:
"
false
"
}
]
"
Expected
extensions_button
.
toggle_visibility
telemetry
after
showing
"
)
;
info
(
"
Checking
context
menu
after
unhiding
the
button
"
)
;
const
contextMenu2
=
await
openChromeContextMenu
(
"
toolbar
-
context
-
menu
"
"
#
unified
-
extensions
-
button
"
)
;
is
(
contextMenu
contextMenu2
"
Context
menu
is
the
same
"
)
;
is
(
removeFromToolbar
.
hidden
false
"
removeFromToolbar
is
visible
"
)
;
ok
(
!
removeFromToolbar
.
hasAttribute
(
"
disabled
"
)
"
removeFromToolbar
enabled
"
)
;
is
(
item
.
hidden
true
"
'
Always
Show
in
Toolbar
'
menu
item
is
hidden
"
)
;
await
closeChromeContextMenu
(
contextMenu2
.
id
)
;
resetButtonVisibilityToDefault
(
)
;
}
)
;
add_task
(
async
function
test_customization_option_hidden_if_not_customizing
(
)
{
const
contextMenu
=
await
openChromeContextMenu
(
"
toolbar
-
context
-
menu
"
"
#
unified
-
extensions
-
button
"
)
;
const
item
=
document
.
getElementById
(
"
toolbar
-
context
-
always
-
show
-
extensions
-
button
"
)
;
is
(
item
.
hidden
true
"
Not
expecting
menu
item
to
hide
button
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
)
;
}
)
;
add_task
(
async
function
test_customization_button_and_menu_item_visibility
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
resetExtensionsButtonTelemetry
(
)
;
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
openCustomizationUI
(
win
)
;
assertExtensionsButtonVisible
(
)
;
assertExtensionsButtonTelemetry
(
{
}
)
;
{
info
(
"
Toggle
checkbox
via
context
menu
from
on
to
off
"
)
;
const
contextMenu
=
await
openChromeContextMenu
(
"
toolbar
-
context
-
menu
"
"
#
wrapper
-
unified
-
extensions
-
button
"
win
)
;
const
item
=
win
.
document
.
getElementById
(
"
toolbar
-
context
-
always
-
show
-
extensions
-
button
"
)
;
is
(
item
.
hidden
false
"
Menu
item
should
be
visible
"
)
;
ok
(
item
.
hasAttribute
(
"
checked
"
)
"
Should
be
checked
by
default
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
item
win
)
;
info
(
"
The
button
should
still
be
visible
while
customizing
"
)
;
assertExtensionsButtonVisible
(
win
)
;
info
(
"
The
button
should
be
hidden
in
windows
that
are
not
customizing
"
)
;
assertExtensionsButtonHidden
(
)
;
await
checkAndDismissPostHideNotification
(
win
)
;
}
assertExtensionsButtonTelemetry
(
{
}
)
;
Assert
.
deepEqual
(
Glean
.
extensionsButton
.
toggleVisibility
.
testGetValue
(
)
.
map
(
e
=
>
e
.
extra
)
[
{
is_customizing
:
"
true
"
is_extensions_panel_empty
:
"
false
"
is_temporarily_shown
:
"
true
"
should_hide
:
"
true
"
}
]
"
Expected
extensions_button
.
toggle_visibility
telemetry
after
hiding
"
)
;
Services
.
fog
.
testResetFOG
(
)
;
{
info
(
"
Open
context
menu
to
verify
checked
state
then
cancel
menu
"
)
;
const
contextMenu
=
await
openChromeContextMenu
(
"
toolbar
-
context
-
menu
"
"
#
wrapper
-
unified
-
extensions
-
button
"
win
)
;
const
item
=
win
.
document
.
getElementById
(
"
toolbar
-
context
-
always
-
show
-
extensions
-
button
"
)
;
is
(
item
.
hidden
false
"
Menu
item
should
be
visible
"
)
;
ok
(
!
item
.
hasAttribute
(
"
checked
"
)
"
Should
be
unchecked
by
earlier
action
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
null
win
)
;
}
await
closeCustomizationUI
(
win
)
;
info
(
"
The
button
should
be
hidden
after
exiting
customization
"
)
;
assertExtensionsButtonHidden
(
win
)
;
await
openCustomizationUI
(
win
)
;
info
(
"
The
button
should
be
visible
upon
entering
customization
"
)
;
assertExtensionsButtonVisible
(
win
)
;
assertExtensionsButtonTelemetry
(
{
customize
:
1
}
)
;
{
info
(
"
Toggle
checkbox
via
context
menu
from
off
to
on
"
)
;
const
contextMenu
=
await
openChromeContextMenu
(
"
toolbar
-
context
-
menu
"
"
#
wrapper
-
unified
-
extensions
-
button
"
win
)
;
const
item
=
win
.
document
.
getElementById
(
"
toolbar
-
context
-
always
-
show
-
extensions
-
button
"
)
;
is
(
item
.
hidden
false
"
Menu
item
should
be
visible
"
)
;
ok
(
!
item
.
hasAttribute
(
"
checked
"
)
"
Should
be
unchecked
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
item
win
)
;
info
(
"
After
checking
the
option
buttons
should
be
shown
in
all
windows
"
)
;
assertExtensionsButtonVisible
(
win
)
;
assertExtensionsButtonVisible
(
)
;
}
Assert
.
deepEqual
(
Glean
.
extensionsButton
.
toggleVisibility
.
testGetValue
(
)
.
map
(
e
=
>
e
.
extra
)
[
{
is_extensions_panel_empty
:
"
false
"
is_customizing
:
"
true
"
is_temporarily_shown
:
"
true
"
should_hide
:
"
false
"
}
]
"
Expected
extensions_button
.
toggle_visibility
telemetry
after
showing
"
)
;
await
closeCustomizationUI
(
win
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
assertExtensionsButtonTelemetry
(
{
customize
:
1
}
)
;
resetButtonVisibilityToDefault
(
)
;
}
)
;
