"
use
strict
"
;
loadTestSubscript
(
"
head_unified_extensions
.
js
"
)
;
requestLongerTimeout
(
2
)
;
const
NUM_EXTENSIONS
=
5
;
const
OVERFLOW_WINDOW_WIDTH_PX
=
450
;
const
DEFAULT_WIDGET_IDS
=
[
"
home
-
button
"
"
library
-
button
"
"
zoom
-
controls
"
"
search
-
container
"
"
sidebar
-
button
"
]
;
const
OVERFLOWED_EXTENSIONS_LIST_ID
=
"
overflowed
-
extensions
-
list
"
;
add_setup
(
async
function
(
)
{
let
existingWidgetIDs
=
CustomizableUI
.
getWidgetIdsInArea
(
CustomizableUI
.
AREA_NAVBAR
)
;
for
(
let
widgetID
of
existingWidgetIDs
)
{
if
(
CustomizableUI
.
isWidgetRemovable
(
widgetID
)
)
{
CustomizableUI
.
removeWidgetFromArea
(
widgetID
)
;
}
}
for
(
const
widgetID
of
DEFAULT_WIDGET_IDS
)
{
CustomizableUI
.
addWidgetToArea
(
widgetID
CustomizableUI
.
AREA_NAVBAR
)
;
}
registerCleanupFunction
(
async
(
)
=
>
{
await
CustomizableUI
.
reset
(
)
;
}
)
;
}
)
;
function
getChildrenIDs
(
parent
)
{
return
Array
.
from
(
parent
.
children
)
.
map
(
child
=
>
child
.
id
)
;
}
function
getVisibleMenuItems
(
popup
)
{
return
popup
.
querySelectorAll
(
"
:
scope
>
:
is
(
menu
menuitem
menuseparator
)
:
not
(
[
hidden
]
)
"
)
;
}
async
function
withWindowOverflowed
(
win
{
beforeOverflowed
=
async
(
)
=
>
{
}
whenOverflowed
=
async
(
)
=
>
{
}
afterUnderflowed
=
async
(
)
=
>
{
}
}
=
{
}
)
{
const
doc
=
win
.
document
;
doc
.
documentElement
.
removeAttribute
(
"
persist
"
)
;
const
navbar
=
doc
.
getElementById
(
CustomizableUI
.
AREA_NAVBAR
)
;
await
ensureMaximizedWindow
(
win
)
;
const
signpostWidgetID
=
"
home
-
button
"
;
CustomizableUI
.
getWidget
(
signpostWidgetID
)
.
forWindow
(
win
)
.
node
.
style
=
"
width
:
150px
"
;
const
extWithMenuBrowserAction
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Extension
#
0
"
browser_specific_settings
:
{
gecko
:
{
id
:
"
unified
-
extensions
-
overflowable
-
toolbar
ext
-
0
"
}
}
browser_action
:
{
default_area
:
"
navbar
"
}
permissions
:
[
"
activeTab
"
"
contextMenus
"
]
}
background
(
)
{
browser
.
contextMenus
.
create
(
{
id
:
"
some
-
menu
-
id
"
title
:
"
Click
me
!
"
contexts
:
[
"
all
"
]
}
(
)
=
>
browser
.
test
.
sendMessage
(
"
menu
-
created
"
)
)
;
}
useAddonManager
:
"
temporary
"
}
)
;
const
extWithSubMenuBrowserAction
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Extension
#
1
"
browser_specific_settings
:
{
gecko
:
{
id
:
"
unified
-
extensions
-
overflowable
-
toolbar
ext
-
1
"
}
}
browser_action
:
{
default_area
:
"
navbar
"
}
permissions
:
[
"
contextMenus
"
]
}
background
(
)
{
browser
.
contextMenus
.
create
(
{
id
:
"
some
-
menu
-
id
"
title
:
"
Open
sub
-
menu
"
contexts
:
[
"
all
"
]
}
)
;
browser
.
contextMenus
.
create
(
{
id
:
"
some
-
sub
-
menu
-
id
"
parentId
:
"
some
-
menu
-
id
"
title
:
"
Click
me
!
"
contexts
:
[
"
all
"
]
}
(
)
=
>
browser
.
test
.
sendMessage
(
"
menu
-
created
"
)
)
;
}
useAddonManager
:
"
temporary
"
}
)
;
const
manifests
=
[
]
;
for
(
let
i
=
2
;
i
<
NUM_EXTENSIONS
;
+
+
i
)
{
manifests
.
push
(
{
name
:
Extension
#
{
i
}
browser_action
:
{
default_area
:
"
navbar
"
}
browser_specific_settings
:
{
gecko
:
{
id
:
unified
-
extensions
-
overflowable
-
toolbar
ext
-
{
i
}
}
}
}
)
;
}
const
extensions
=
[
extWithMenuBrowserAction
extWithSubMenuBrowserAction
.
.
.
createExtensions
(
manifests
)
]
;
let
listener
=
{
_remainingBrowserActions
:
NUM_EXTENSIONS
_deferred
:
PromiseUtils
.
defer
(
)
get
promise
(
)
{
return
this
.
_deferred
.
promise
;
}
onWidgetAdded
(
widgetID
area
)
{
if
(
widgetID
.
endsWith
(
"
-
browser
-
action
"
)
)
{
this
.
_remainingBrowserActions
-
-
;
}
if
(
!
this
.
_remainingBrowserActions
)
{
this
.
_deferred
.
resolve
(
)
;
}
}
}
;
CustomizableUI
.
addListener
(
listener
)
;
for
(
const
extension
of
extensions
)
{
await
extension
.
startup
(
)
;
}
await
Promise
.
all
(
[
extWithMenuBrowserAction
.
awaitMessage
(
"
menu
-
created
"
)
extWithSubMenuBrowserAction
.
awaitMessage
(
"
menu
-
created
"
)
]
)
;
await
listener
.
promise
;
CustomizableUI
.
removeListener
(
listener
)
;
const
extensionIDs
=
extensions
.
map
(
extension
=
>
extension
.
id
)
;
try
{
info
(
"
Running
beforeOverflowed
task
"
)
;
await
beforeOverflowed
(
extensionIDs
)
;
}
finally
{
const
browserActionIDs
=
extensionIDs
.
map
(
id
=
>
AppUiTestInternals
.
getBrowserActionWidgetId
(
id
)
)
;
const
browserActionsInNavBar
=
browserActionIDs
.
filter
(
widgetID
=
>
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
widgetID
)
;
return
placement
.
area
=
=
CustomizableUI
.
AREA_NAVBAR
;
}
)
;
let
widgetOverflowListener
=
{
_remainingOverflowables
:
browserActionsInNavBar
.
length
+
DEFAULT_WIDGET_IDS
.
length
_deferred
:
PromiseUtils
.
defer
(
)
get
promise
(
)
{
return
this
.
_deferred
.
promise
;
}
onWidgetOverflow
(
widgetNode
areaNode
)
{
this
.
_remainingOverflowables
-
-
;
if
(
!
this
.
_remainingOverflowables
)
{
this
.
_deferred
.
resolve
(
)
;
}
}
}
;
CustomizableUI
.
addListener
(
widgetOverflowListener
)
;
win
.
resizeTo
(
OVERFLOW_WINDOW_WIDTH_PX
win
.
outerHeight
)
;
await
widgetOverflowListener
.
promise
;
CustomizableUI
.
removeListener
(
widgetOverflowListener
)
;
Assert
.
ok
(
navbar
.
hasAttribute
(
"
overflowing
"
)
"
Should
have
an
overflowing
toolbar
.
"
)
;
const
defaultList
=
doc
.
getElementById
(
navbar
.
getAttribute
(
"
default
-
overflowtarget
"
)
)
;
const
unifiedExtensionList
=
doc
.
getElementById
(
navbar
.
getAttribute
(
"
addon
-
webext
-
overflowtarget
"
)
)
;
try
{
info
(
"
Running
whenOverflowed
task
"
)
;
await
whenOverflowed
(
defaultList
unifiedExtensionList
extensionIDs
)
;
}
finally
{
await
ensureMaximizedWindow
(
win
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
doc
.
getElementById
(
signpostWidgetID
)
.
hasAttribute
(
"
overflowedItem
"
)
;
}
)
;
try
{
info
(
"
Running
afterUnderflowed
task
"
)
;
await
afterUnderflowed
(
)
;
}
finally
{
await
Promise
.
all
(
extensions
.
map
(
extension
=
>
extension
.
unload
(
)
)
)
;
}
}
}
}
async
function
verifyExtensionWidget
(
widget
win
=
window
)
{
Assert
.
ok
(
widget
"
expected
widget
"
)
;
let
actionButton
=
widget
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
Assert
.
ok
(
actionButton
.
classList
.
contains
(
"
unified
-
extensions
-
item
-
action
-
button
"
)
"
expected
action
class
on
the
button
"
)
;
ok
(
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
the
.
subviewbutton
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
panel
"
)
;
let
menuButton
=
widget
.
lastElementChild
;
Assert
.
ok
(
menuButton
.
classList
.
contains
(
"
unified
-
extensions
-
item
-
menu
-
button
"
)
"
expected
class
on
the
button
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
the
.
subviewbutton
CSS
class
on
the
menu
button
in
the
panel
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
panel
"
)
;
let
contents
=
actionButton
.
querySelector
(
"
.
unified
-
extensions
-
item
-
contents
"
)
;
Assert
.
ok
(
contents
"
expected
contents
element
"
)
;
Assert
.
equal
(
contents
.
getAttribute
(
"
move
-
after
-
stack
"
)
"
true
"
"
expected
move
-
after
-
stack
attribute
to
be
set
"
)
;
Assert
.
deepEqual
(
Array
.
from
(
actionButton
.
childNodes
.
values
(
)
)
.
map
(
child
=
>
child
.
classList
[
0
]
)
[
"
toolbarbutton
-
badge
-
stack
"
"
toolbarbutton
-
text
"
"
unified
-
extensions
-
item
-
contents
"
]
"
expected
the
correct
order
for
the
children
of
the
action
button
"
)
;
let
name
=
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
name
"
)
;
Assert
.
ok
(
name
"
expected
name
element
"
)
;
Assert
.
ok
(
name
.
textContent
.
startsWith
(
"
Extension
"
)
"
expected
name
to
not
be
empty
"
)
;
Assert
.
ok
(
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
"
expected
message
default
element
"
)
;
Assert
.
ok
(
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
hover
"
)
"
expected
message
hover
element
"
)
;
Assert
.
equal
(
win
.
document
.
l10n
.
getAttributes
(
menuButton
)
.
id
"
unified
-
extensions
-
item
-
open
-
menu
"
"
expected
l10n
id
attribute
for
the
extension
"
)
;
Assert
.
deepEqual
(
Object
.
keys
(
win
.
document
.
l10n
.
getAttributes
(
menuButton
)
.
args
)
[
"
extensionName
"
]
"
expected
l10n
args
attribute
for
the
extension
"
)
;
Assert
.
ok
(
win
.
document
.
l10n
.
getAttributes
(
menuButton
)
.
args
.
extensionName
.
startsWith
(
"
Extension
"
)
"
expected
l10n
args
attribute
to
start
with
the
correct
name
"
)
;
Assert
.
ok
(
menuButton
.
getAttribute
(
"
aria
-
label
"
)
!
=
=
"
"
"
expected
menu
button
to
have
non
-
empty
localized
content
"
)
;
}
add_task
(
async
function
test_overflowable_toolbar
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
movedNode
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
let
defaultListIDs
=
getChildrenIDs
(
defaultList
)
;
for
(
const
widgetID
of
DEFAULT_WIDGET_IDS
)
{
Assert
.
ok
(
defaultListIDs
.
includes
(
widgetID
)
Default
overflow
list
should
have
{
widgetID
}
)
;
}
Assert
.
ok
(
unifiedExtensionList
.
children
.
length
"
Should
have
items
in
the
Unified
Extension
list
.
"
)
;
for
(
const
child
of
Array
.
from
(
unifiedExtensionList
.
children
)
)
{
Assert
.
ok
(
extensionIDs
.
includes
(
child
.
dataset
.
extensionid
)
Unified
Extensions
overflow
list
should
have
{
child
.
dataset
.
extensionid
}
)
;
await
verifyExtensionWidget
(
child
win
)
;
}
let
extensionWidgetID
=
AppUiTestInternals
.
getBrowserActionWidgetId
(
extensionIDs
.
at
(
-
1
)
)
;
movedNode
=
CustomizableUI
.
getWidget
(
extensionWidgetID
)
.
forWindow
(
win
)
.
node
;
Assert
.
equal
(
movedNode
.
getAttribute
(
"
cui
-
areatype
"
)
"
toolbar
"
)
;
CustomizableUI
.
addWidgetToArea
(
extensionWidgetID
CustomizableUI
.
AREA_ADDONS
)
;
Assert
.
equal
(
movedNode
.
getAttribute
(
"
cui
-
areatype
"
)
"
panel
"
"
The
moved
browser
action
button
should
have
the
right
cui
-
areatype
set
.
"
)
;
}
afterUnderflowed
:
async
(
)
=
>
{
Assert
.
equal
(
movedNode
.
parentElement
.
id
CustomizableUI
.
AREA_ADDONS
"
The
browser
action
should
still
be
in
the
addons
panel
"
)
;
CustomizableUI
.
addWidgetToArea
(
movedNode
.
id
CustomizableUI
.
AREA_NAVBAR
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_context_menu
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
Assert
.
ok
(
unifiedExtensionList
.
children
.
length
"
Should
have
items
in
the
Unified
Extension
list
.
"
)
;
await
openExtensionsPanel
(
win
)
;
info
(
"
extension
with
browser
action
and
a
menu
"
)
;
const
firstExtensionWidget
=
unifiedExtensionList
.
children
[
0
]
;
Assert
.
ok
(
firstExtensionWidget
"
expected
extension
widget
"
)
;
let
contextMenu
=
await
openUnifiedExtensionsContextMenu
(
firstExtensionWidget
.
dataset
.
extensionid
win
)
;
Assert
.
ok
(
contextMenu
"
expected
a
context
menu
"
)
;
let
visibleItems
=
getVisibleMenuItems
(
contextMenu
)
;
is
(
visibleItems
.
length
7
"
expected
a
custom
context
menu
item
a
menu
separator
the
pin
to
"
+
"
toolbar
menu
item
a
menu
separator
and
the
3
default
menu
items
"
)
;
const
[
item
separator
]
=
visibleItems
;
is
(
item
.
getAttribute
(
"
label
"
)
"
Click
me
!
"
"
expected
menu
item
as
first
child
"
)
;
is
(
separator
.
tagName
"
menuseparator
"
"
expected
separator
after
last
menu
item
created
by
the
extension
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
null
win
)
;
info
(
"
extension
with
browser
action
and
a
menu
with
submenu
"
)
;
const
secondExtensionWidget
=
unifiedExtensionList
.
children
[
1
]
;
Assert
.
ok
(
secondExtensionWidget
"
expected
extension
widget
"
)
;
contextMenu
=
await
openUnifiedExtensionsContextMenu
(
secondExtensionWidget
.
dataset
.
extensionid
win
)
;
visibleItems
=
getVisibleMenuItems
(
contextMenu
)
;
is
(
visibleItems
.
length
7
"
expected
7
menu
items
"
)
;
const
popup
=
await
openSubmenu
(
visibleItems
[
0
]
)
;
is
(
popup
.
children
.
length
1
"
expected
1
submenu
item
"
)
;
is
(
popup
.
children
[
0
]
.
getAttribute
(
"
label
"
)
"
Click
me
!
"
"
expected
menu
item
"
)
;
visibleItems
=
getVisibleMenuItems
(
contextMenu
)
;
is
(
visibleItems
.
length
7
"
expected
7
menu
items
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
null
win
)
;
info
(
"
extension
with
no
browser
action
and
no
menu
"
)
;
const
thirdExtensionWidget
=
unifiedExtensionList
.
children
[
2
]
;
Assert
.
ok
(
thirdExtensionWidget
"
expected
extension
widget
"
)
;
contextMenu
=
await
openUnifiedExtensionsContextMenu
(
thirdExtensionWidget
.
dataset
.
extensionid
win
)
;
Assert
.
ok
(
contextMenu
"
expected
a
context
menu
"
)
;
visibleItems
=
getVisibleMenuItems
(
contextMenu
)
;
is
(
visibleItems
.
length
5
"
expected
5
menu
items
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
null
win
)
;
await
closeExtensionsPanel
(
win
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_message_deck
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
Assert
.
ok
(
unifiedExtensionList
.
children
.
length
"
Should
have
items
in
the
Unified
Extension
list
.
"
)
;
const
firstExtensionWidget
=
unifiedExtensionList
.
children
[
0
]
;
Assert
.
ok
(
firstExtensionWidget
"
expected
extension
widget
"
)
;
Assert
.
ok
(
firstExtensionWidget
.
dataset
.
extensionid
"
expected
data
attribute
for
extension
ID
"
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
win
.
gBrowser
url
:
"
https
:
/
/
example
.
com
/
"
}
async
(
)
=
>
{
await
openExtensionsPanel
(
win
)
;
info
(
"
verify
message
when
focusing
the
action
button
"
)
;
const
item
=
getUnifiedExtensionsItem
(
firstExtensionWidget
.
dataset
.
extensionid
win
)
;
Assert
.
ok
(
item
"
expected
an
item
for
the
extension
"
)
;
const
actionButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
Assert
.
ok
(
actionButton
"
expected
action
button
"
)
;
const
menuButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
Assert
.
ok
(
menuButton
"
expected
menu
button
"
)
;
const
messageDeck
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
deck
"
)
;
Assert
.
ok
(
messageDeck
"
expected
message
deck
"
)
;
is
(
messageDeck
.
selectedIndex
win
.
gUnifiedExtensions
.
MESSAGE_DECK_INDEX_DEFAULT
"
expected
selected
message
in
the
deck
to
be
the
default
message
"
)
;
const
defaultMessage
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
defaultMessage
)
{
id
:
"
origin
-
controls
-
state
-
when
-
clicked
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
default
message
"
)
;
Assert
.
ok
(
defaultMessage
.
textContent
!
=
=
"
"
"
expected
default
message
to
not
be
empty
"
)
;
const
hoverMessage
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
hover
"
)
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
hoverMessage
)
{
id
:
"
origin
-
controls
-
state
-
hover
-
run
-
visit
-
only
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
hover
message
"
)
;
Assert
.
ok
(
hoverMessage
.
textContent
!
=
=
"
"
"
expected
hover
message
to
not
be
empty
"
)
;
const
hoverMenuButtonMessage
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
hover
-
menu
-
button
"
)
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
hoverMenuButtonMessage
)
{
id
:
"
unified
-
extensions
-
item
-
message
-
manage
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
message
when
hovering
the
menu
button
"
)
;
Assert
.
ok
(
hoverMenuButtonMessage
.
textContent
!
=
=
"
"
"
expected
message
for
when
the
menu
button
is
hovered
to
not
be
empty
"
)
;
let
focused
=
BrowserTestUtils
.
waitForEvent
(
actionButton
"
focus
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
}
win
)
;
await
focused
;
is
(
actionButton
win
.
document
.
activeElement
"
expected
action
button
of
the
first
extension
item
to
be
focused
"
)
;
is
(
messageDeck
.
selectedIndex
win
.
gUnifiedExtensions
.
MESSAGE_DECK_INDEX_HOVER
"
expected
selected
message
in
the
deck
to
be
the
hover
message
"
)
;
focused
=
BrowserTestUtils
.
waitForEvent
(
menuButton
"
focus
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
}
win
)
;
await
focused
;
is
(
menuButton
win
.
document
.
activeElement
"
expected
menu
button
of
the
first
extension
item
to
be
focused
"
)
;
is
(
messageDeck
.
selectedIndex
win
.
gUnifiedExtensions
.
MESSAGE_DECK_INDEX_MENU_HOVER
"
expected
selected
message
in
the
deck
to
be
the
message
when
focusing
the
menu
button
"
)
;
await
closeExtensionsPanel
(
win
)
;
info
(
"
verify
message
when
hovering
the
action
button
"
)
;
await
openExtensionsPanel
(
win
)
;
is
(
messageDeck
.
selectedIndex
win
.
gUnifiedExtensions
.
MESSAGE_DECK_INDEX_DEFAULT
"
expected
selected
message
in
the
deck
to
be
the
default
message
"
)
;
let
hovered
=
BrowserTestUtils
.
waitForEvent
(
actionButton
"
mouseover
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
actionButton
{
type
:
"
mouseover
"
}
win
)
;
await
hovered
;
is
(
messageDeck
.
selectedIndex
win
.
gUnifiedExtensions
.
MESSAGE_DECK_INDEX_HOVER
"
expected
selected
message
in
the
deck
to
be
the
hover
message
"
)
;
hovered
=
BrowserTestUtils
.
waitForEvent
(
menuButton
"
mouseover
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuButton
{
type
:
"
mouseover
"
}
win
)
;
await
hovered
;
is
(
messageDeck
.
selectedIndex
win
.
gUnifiedExtensions
.
MESSAGE_DECK_INDEX_MENU_HOVER
"
expected
selected
message
in
the
deck
to
be
the
message
when
hovering
the
menu
button
"
)
;
await
closeExtensionsPanel
(
win
)
;
}
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_pinning_to_toolbar_when_overflowed
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
movedNode
;
let
extensionWidgetID
;
let
actionButton
;
let
menuButton
;
await
withWindowOverflowed
(
win
{
beforeOverflowed
:
async
extensionIDs
=
>
{
extensionWidgetID
=
AppUiTestInternals
.
getBrowserActionWidgetId
(
extensionIDs
.
at
(
-
1
)
)
;
movedNode
=
CustomizableUI
.
getWidget
(
extensionWidgetID
)
.
forWindow
(
win
)
.
node
;
actionButton
=
movedNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
navbar
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
action
button
in
the
navbar
"
)
;
menuButton
=
movedNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
navbar
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
menu
button
in
the
navbar
"
)
;
CustomizableUI
.
addWidgetToArea
(
extensionWidgetID
CustomizableUI
.
AREA_ADDONS
)
;
ok
(
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
.
subviewbutton
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
.
subviewbutton
CSS
class
on
the
menu
button
in
the
panel
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
panel
"
)
;
}
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
ok
(
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
.
subviewbutton
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
.
subviewbutton
CSS
class
on
the
menu
button
in
the
panel
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
panel
"
)
;
CustomizableUI
.
addWidgetToArea
(
extensionWidgetID
CustomizableUI
.
AREA_NAVBAR
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
movedNode
.
hasAttribute
(
"
overflowedItem
"
)
;
}
)
;
Assert
.
equal
(
movedNode
.
parentElement
unifiedExtensionList
"
Should
have
overflowed
the
extension
button
to
the
right
list
.
"
)
;
ok
(
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
.
subviewbutton
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
.
subviewbutton
CSS
class
on
the
menu
button
in
the
panel
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
panel
"
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_unpin_overflowed_widget
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
extensionID
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
const
firstExtensionWidget
=
unifiedExtensionList
.
children
[
0
]
;
Assert
.
ok
(
firstExtensionWidget
"
expected
an
extension
widget
"
)
;
extensionID
=
firstExtensionWidget
.
dataset
.
extensionid
;
let
movedNode
=
CustomizableUI
.
getWidget
(
firstExtensionWidget
.
id
)
.
forWindow
(
win
)
.
node
;
Assert
.
equal
(
movedNode
.
getAttribute
(
"
cui
-
areatype
"
)
"
toolbar
"
"
expected
extension
widget
to
be
in
the
toolbar
"
)
;
Assert
.
ok
(
movedNode
.
hasAttribute
(
"
overflowedItem
"
)
"
expected
extension
widget
to
be
overflowed
"
)
;
let
actionButton
=
movedNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
the
.
subviewbutton
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
panel
"
)
;
let
menuButton
=
movedNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
the
.
subviewbutton
CSS
class
on
the
menu
button
in
the
panel
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
panel
"
)
;
await
openExtensionsPanel
(
win
)
;
const
contextMenu
=
await
openUnifiedExtensionsContextMenu
(
extensionID
win
)
;
Assert
.
ok
(
contextMenu
"
expected
a
context
menu
"
)
;
const
pinToToolbar
=
contextMenu
.
querySelector
(
"
.
unified
-
extensions
-
context
-
menu
-
pin
-
to
-
toolbar
"
)
;
Assert
.
ok
(
pinToToolbar
"
expected
a
'
Pin
to
Toolbar
'
menu
item
"
)
;
Assert
.
ok
(
!
pinToToolbar
.
hidden
"
expected
'
Pin
to
Toolbar
'
to
be
visible
"
)
;
Assert
.
equal
(
pinToToolbar
.
getAttribute
(
"
checked
"
)
"
true
"
"
expected
'
Pin
to
Toolbar
'
to
be
checked
"
)
;
const
hidden
=
BrowserTestUtils
.
waitForEvent
(
win
.
gUnifiedExtensions
.
panel
"
popuphidden
"
true
)
;
contextMenu
.
activateItem
(
pinToToolbar
)
;
await
hidden
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
movedNode
.
hasAttribute
(
"
overflowedItem
"
)
;
}
)
;
Assert
.
equal
(
movedNode
.
parentElement
.
id
CustomizableUI
.
AREA_ADDONS
"
expected
extension
widget
to
have
been
unpinned
and
placed
in
the
addons
area
"
)
;
Assert
.
equal
(
movedNode
.
getAttribute
(
"
cui
-
areatype
"
)
"
panel
"
"
expected
extension
widget
to
be
in
the
unified
extensions
panel
"
)
;
}
afterUnderflowed
:
async
(
)
=
>
{
await
openExtensionsPanel
(
win
)
;
const
item
=
getUnifiedExtensionsItem
(
extensionID
win
)
;
Assert
.
ok
(
item
"
expected
extension
widget
to
be
listed
in
the
unified
extensions
panel
"
)
;
let
actionButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
the
.
subviewbutton
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
panel
"
)
;
let
menuButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
the
.
subviewbutton
CSS
class
on
the
menu
button
in
the
panel
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
panel
"
)
;
await
closeExtensionsPanel
(
win
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_overflow_with_a_second_window
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
secondWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
ensureMaximizedWindow
(
secondWin
)
;
await
BrowserTestUtils
.
openNewForegroundTab
(
secondWin
.
gBrowser
"
https
:
/
/
example
.
com
/
"
)
;
let
windowActivePromise
=
new
Promise
(
resolve
=
>
{
if
(
Services
.
focus
.
activeWindow
=
=
win
)
{
resolve
(
)
;
}
else
{
win
.
addEventListener
(
"
activate
"
(
)
=
>
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
}
)
;
win
.
focus
(
)
;
await
windowActivePromise
;
let
extensionWidgetID
;
let
aNode
;
let
aNodeInSecondWindow
;
await
withWindowOverflowed
(
win
{
beforeOverflowed
:
async
extensionIDs
=
>
{
extensionWidgetID
=
AppUiTestInternals
.
getBrowserActionWidgetId
(
extensionIDs
.
at
(
-
1
)
)
;
aNode
=
CustomizableUI
.
getWidget
(
extensionWidgetID
)
.
forWindow
(
win
)
.
node
;
Assert
.
ok
(
!
aNode
.
hasAttribute
(
"
overflowedItem
"
)
"
expected
extension
widget
to
NOT
be
overflowed
"
)
;
let
actionButton
=
aNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
action
button
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
action
button
"
)
;
let
menuButton
=
aNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
menu
button
"
)
;
aNodeInSecondWindow
=
CustomizableUI
.
getWidget
(
extensionWidgetID
)
.
forWindow
(
secondWin
)
.
node
;
let
actionButtonInSecondWindow
=
aNodeInSecondWindow
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButtonInSecondWindow
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
second
window
"
)
;
ok
(
!
actionButtonInSecondWindow
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
action
button
in
the
second
window
"
)
;
let
menuButtonInSecondWindow
=
aNodeInSecondWindow
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButtonInSecondWindow
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
second
window
"
)
;
ok
(
!
menuButtonInSecondWindow
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
menu
button
in
the
second
window
"
)
;
}
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
Assert
.
ok
(
aNode
.
hasAttribute
(
"
overflowedItem
"
)
"
expected
extension
widget
to
be
overflowed
"
)
;
Assert
.
equal
(
aNode
.
getAttribute
(
"
widget
-
id
"
)
extensionWidgetID
"
expected
the
CUI
widget
ID
to
be
set
on
the
DOM
node
"
)
;
let
actionButton
=
aNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
the
.
subviewbutton
CSS
class
on
the
action
button
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
action
button
"
)
;
let
menuButton
=
aNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
the
.
subviewbutton
CSS
class
on
the
menu
button
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
no
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
"
)
;
Assert
.
ok
(
!
aNodeInSecondWindow
.
hasAttribute
(
"
overflowedItem
"
)
"
expected
extension
widget
to
NOT
be
overflowed
in
the
other
window
"
)
;
Assert
.
equal
(
aNodeInSecondWindow
.
getAttribute
(
"
widget
-
id
"
)
extensionWidgetID
"
expected
the
CUI
widget
ID
to
be
set
on
the
DOM
node
"
)
;
let
actionButtonInSecondWindow
=
aNodeInSecondWindow
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButtonInSecondWindow
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
second
window
"
)
;
ok
(
!
actionButtonInSecondWindow
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
action
button
in
the
second
window
"
)
;
let
menuButtonInSecondWindow
=
aNodeInSecondWindow
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButtonInSecondWindow
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
second
window
"
)
;
ok
(
!
menuButtonInSecondWindow
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
menu
button
in
the
second
window
"
)
;
}
afterUnderflowed
:
async
(
)
=
>
{
let
actionButton
=
aNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
panel
"
)
;
ok
(
!
actionButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
action
button
in
the
panel
"
)
;
let
menuButton
=
aNode
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButton
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
panel
"
)
;
ok
(
!
menuButton
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
menu
button
in
the
panel
"
)
;
let
actionButtonInSecondWindow
=
aNodeInSecondWindow
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
;
ok
(
actionButtonInSecondWindow
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
action
button
in
the
second
window
"
)
;
ok
(
!
actionButtonInSecondWindow
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
action
button
in
the
second
window
"
)
;
let
menuButtonInSecondWindow
=
aNodeInSecondWindow
.
querySelector
(
"
.
unified
-
extensions
-
item
-
menu
-
button
"
)
;
ok
(
menuButtonInSecondWindow
.
classList
.
contains
(
"
toolbarbutton
-
1
"
)
"
expected
.
toolbarbutton
-
1
CSS
class
on
the
menu
button
in
the
second
window
"
)
;
ok
(
!
menuButtonInSecondWindow
.
classList
.
contains
(
"
subviewbutton
"
)
"
expected
no
.
subviewbutton
CSS
class
on
the
menu
button
in
the
second
window
"
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
BrowserTestUtils
.
closeWindow
(
secondWin
)
;
}
)
;
add_task
(
async
function
test_overflow_with_extension_in_collapsed_area
(
)
{
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
bookmarksToolbar
=
win
.
document
.
getElementById
(
CustomizableUI
.
AREA_BOOKMARKS
)
;
let
movedNode
;
let
extensionWidgetID
;
let
extensionWidgetPosition
;
await
withWindowOverflowed
(
win
{
beforeOverflowed
:
async
extensionIDs
=
>
{
extensionWidgetID
=
AppUiTestInternals
.
getBrowserActionWidgetId
(
extensionIDs
.
at
(
-
1
)
)
;
movedNode
=
CustomizableUI
.
getWidget
(
extensionWidgetID
)
.
forWindow
(
win
)
.
node
;
await
promiseSetToolbarVisibility
(
bookmarksToolbar
true
)
;
CustomizableUI
.
addWidgetToArea
(
extensionWidgetID
CustomizableUI
.
AREA_BOOKMARKS
)
;
Assert
.
equal
(
movedNode
.
parentElement
.
id
CustomizableUI
.
AREA_BOOKMARKS
"
expected
extension
widget
to
be
in
the
bookmarks
toolbar
"
)
;
Assert
.
ok
(
!
movedNode
.
hasAttribute
(
"
artificallyOverflowed
"
)
"
expected
node
to
not
have
any
artificallyOverflowed
prop
"
)
;
extensionWidgetPosition
=
CustomizableUI
.
getPlacementOfWidget
(
extensionWidgetID
)
.
position
;
}
whenOverflowed
:
async
(
)
=
>
{
await
promiseSetToolbarVisibility
(
bookmarksToolbar
false
)
;
Assert
.
equal
(
movedNode
.
parentElement
.
id
OVERFLOWED_EXTENSIONS_LIST_ID
"
expected
extension
widget
to
be
in
the
extensions
panel
"
)
;
Assert
.
ok
(
movedNode
.
getAttribute
(
"
artificallyOverflowed
"
)
"
expected
node
to
be
artifically
overflowed
"
)
;
}
afterUnderflowed
:
async
(
)
=
>
{
Assert
.
equal
(
movedNode
.
parentElement
.
id
OVERFLOWED_EXTENSIONS_LIST_ID
"
expected
extension
widget
to
still
be
in
the
extensions
panel
"
)
;
Assert
.
ok
(
movedNode
.
getAttribute
(
"
artificallyOverflowed
"
)
"
expected
node
to
still
be
artifically
overflowed
"
)
;
await
promiseSetToolbarVisibility
(
bookmarksToolbar
true
)
;
Assert
.
equal
(
movedNode
.
parentElement
.
id
CustomizableUI
.
AREA_BOOKMARKS
"
expected
extension
widget
to
be
in
the
bookmarks
toolbar
"
)
;
Assert
.
ok
(
!
movedNode
.
hasAttribute
(
"
artificallyOverflowed
"
)
"
expected
node
to
not
have
any
artificallyOverflowed
prop
"
)
;
Assert
.
equal
(
CustomizableUI
.
getPlacementOfWidget
(
extensionWidgetID
)
.
position
extensionWidgetPosition
"
expected
the
extension
to
be
back
at
the
same
position
in
the
bookmarks
toolbar
"
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
