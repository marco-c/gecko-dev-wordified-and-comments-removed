"
use
strict
"
;
loadTestSubscript
(
"
head_unified_extensions
.
js
"
)
;
const
NUM_EXTENSIONS
=
5
;
const
OVERFLOW_WINDOW_WIDTH_PX
=
450
;
const
DEFAULT_WIDGET_IDS
=
[
"
home
-
button
"
"
library
-
button
"
"
zoom
-
controls
"
"
search
-
container
"
"
sidebar
-
button
"
]
;
add_setup
(
async
function
(
)
{
let
existingWidgetIDs
=
CustomizableUI
.
getWidgetIdsInArea
(
CustomizableUI
.
AREA_NAVBAR
)
;
for
(
let
widgetID
of
existingWidgetIDs
)
{
if
(
CustomizableUI
.
isWidgetRemovable
(
widgetID
)
)
{
CustomizableUI
.
removeWidgetFromArea
(
widgetID
)
;
}
}
for
(
const
widgetID
of
DEFAULT_WIDGET_IDS
)
{
CustomizableUI
.
addWidgetToArea
(
widgetID
CustomizableUI
.
AREA_NAVBAR
)
;
}
registerCleanupFunction
(
async
(
)
=
>
{
await
CustomizableUI
.
reset
(
)
;
}
)
;
}
)
;
function
getChildrenIDs
(
parent
)
{
return
Array
.
from
(
parent
.
children
)
.
map
(
child
=
>
child
.
id
)
;
}
function
getVisibleMenuItems
(
popup
)
{
return
popup
.
querySelectorAll
(
"
:
scope
>
:
is
(
menu
menuitem
menuseparator
)
:
not
(
[
hidden
]
)
"
)
;
}
async
function
withWindowOverflowed
(
win
{
beforeOverflowed
=
async
(
)
=
>
{
}
whenOverflowed
=
async
(
)
=
>
{
}
afterUnderflowed
=
async
(
)
=
>
{
}
}
=
{
}
)
{
const
doc
=
win
.
document
;
doc
.
documentElement
.
removeAttribute
(
"
persist
"
)
;
const
navbar
=
doc
.
getElementById
(
CustomizableUI
.
AREA_NAVBAR
)
;
win
.
moveTo
(
0
0
)
;
const
widthDiff
=
win
.
screen
.
availWidth
-
win
.
outerWidth
;
const
heightDiff
=
win
.
screen
.
availHeight
-
win
.
outerHeight
;
if
(
widthDiff
|
|
heightDiff
)
{
let
resizeDone
=
BrowserTestUtils
.
waitForEvent
(
win
"
resize
"
false
)
;
win
.
resizeBy
(
widthDiff
heightDiff
)
;
await
resizeDone
;
}
const
signpostWidgetID
=
"
home
-
button
"
;
CustomizableUI
.
getWidget
(
signpostWidgetID
)
.
forWindow
(
win
)
.
node
.
style
=
"
width
:
150px
"
;
const
extWithMenuBrowserAction
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Extension
#
0
"
browser_specific_settings
:
{
gecko
:
{
id
:
"
unified
-
extensions
-
overflowable
-
toolbar
ext
-
0
"
}
}
browser_action
:
{
default_area
:
"
navbar
"
}
permissions
:
[
"
activeTab
"
"
contextMenus
"
]
}
background
(
)
{
browser
.
contextMenus
.
create
(
{
id
:
"
some
-
menu
-
id
"
title
:
"
Click
me
!
"
contexts
:
[
"
all
"
]
}
(
)
=
>
browser
.
test
.
sendMessage
(
"
menu
-
created
"
)
)
;
}
useAddonManager
:
"
temporary
"
}
)
;
const
extWithSubMenuBrowserAction
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
name
:
"
Extension
#
1
"
browser_specific_settings
:
{
gecko
:
{
id
:
"
unified
-
extensions
-
overflowable
-
toolbar
ext
-
1
"
}
}
browser_action
:
{
default_area
:
"
navbar
"
}
permissions
:
[
"
contextMenus
"
]
}
background
(
)
{
browser
.
contextMenus
.
create
(
{
id
:
"
some
-
menu
-
id
"
title
:
"
Open
sub
-
menu
"
contexts
:
[
"
all
"
]
}
)
;
browser
.
contextMenus
.
create
(
{
id
:
"
some
-
sub
-
menu
-
id
"
parentId
:
"
some
-
menu
-
id
"
title
:
"
Click
me
!
"
contexts
:
[
"
all
"
]
}
(
)
=
>
browser
.
test
.
sendMessage
(
"
menu
-
created
"
)
)
;
}
useAddonManager
:
"
temporary
"
}
)
;
const
manifests
=
[
]
;
for
(
let
i
=
2
;
i
<
NUM_EXTENSIONS
;
+
+
i
)
{
manifests
.
push
(
{
name
:
Extension
#
{
i
}
browser_action
:
{
default_area
:
"
navbar
"
}
browser_specific_settings
:
{
gecko
:
{
id
:
unified
-
extensions
-
overflowable
-
toolbar
ext
-
{
i
}
}
}
}
)
;
}
const
extensions
=
[
extWithMenuBrowserAction
extWithSubMenuBrowserAction
.
.
.
createExtensions
(
manifests
)
]
;
let
listener
=
{
_remainingBrowserActions
:
NUM_EXTENSIONS
_deferred
:
PromiseUtils
.
defer
(
)
get
promise
(
)
{
return
this
.
_deferred
.
promise
;
}
onWidgetAdded
(
widgetID
area
)
{
if
(
widgetID
.
endsWith
(
"
-
browser
-
action
"
)
)
{
this
.
_remainingBrowserActions
-
-
;
}
if
(
!
this
.
_remainingBrowserActions
)
{
this
.
_deferred
.
resolve
(
)
;
}
}
}
;
CustomizableUI
.
addListener
(
listener
)
;
for
(
const
extension
of
extensions
)
{
await
extension
.
startup
(
)
;
}
await
Promise
.
all
(
[
extWithMenuBrowserAction
.
awaitMessage
(
"
menu
-
created
"
)
extWithSubMenuBrowserAction
.
awaitMessage
(
"
menu
-
created
"
)
]
)
;
await
listener
.
promise
;
CustomizableUI
.
removeListener
(
listener
)
;
const
extensionIDs
=
extensions
.
map
(
extension
=
>
extension
.
id
)
;
try
{
info
(
"
Running
beforeOverflowed
task
"
)
;
await
beforeOverflowed
(
extensionIDs
)
;
}
finally
{
const
originalWindowWidth
=
win
.
outerWidth
;
const
browserActionIDs
=
extensionIDs
.
map
(
id
=
>
AppUiTestInternals
.
getBrowserActionWidgetId
(
id
)
)
;
const
browserActionsInNavBar
=
browserActionIDs
.
filter
(
widgetID
=
>
{
let
placement
=
CustomizableUI
.
getPlacementOfWidget
(
widgetID
)
;
return
placement
.
area
=
=
CustomizableUI
.
AREA_NAVBAR
;
}
)
;
let
widgetOverflowListener
=
{
_remainingOverflowables
:
browserActionsInNavBar
.
length
+
DEFAULT_WIDGET_IDS
.
length
_deferred
:
PromiseUtils
.
defer
(
)
get
promise
(
)
{
return
this
.
_deferred
.
promise
;
}
onWidgetOverflow
(
widgetNode
areaNode
)
{
this
.
_remainingOverflowables
-
-
;
if
(
!
this
.
_remainingOverflowables
)
{
this
.
_deferred
.
resolve
(
)
;
}
}
}
;
CustomizableUI
.
addListener
(
widgetOverflowListener
)
;
win
.
resizeTo
(
OVERFLOW_WINDOW_WIDTH_PX
win
.
outerHeight
)
;
await
widgetOverflowListener
.
promise
;
CustomizableUI
.
removeListener
(
widgetOverflowListener
)
;
Assert
.
ok
(
navbar
.
hasAttribute
(
"
overflowing
"
)
"
Should
have
an
overflowing
toolbar
.
"
)
;
const
defaultList
=
doc
.
getElementById
(
navbar
.
getAttribute
(
"
default
-
overflowtarget
"
)
)
;
const
unifiedExtensionList
=
doc
.
getElementById
(
navbar
.
getAttribute
(
"
addon
-
webext
-
overflowtarget
"
)
)
;
try
{
info
(
"
Running
whenOverflowed
task
"
)
;
await
whenOverflowed
(
defaultList
unifiedExtensionList
extensionIDs
)
;
}
finally
{
win
.
resizeTo
(
originalWindowWidth
win
.
outerHeight
)
;
await
BrowserTestUtils
.
waitForEvent
(
win
"
resize
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
doc
.
getElementById
(
signpostWidgetID
)
.
hasAttribute
(
"
overflowedItem
"
)
;
}
)
;
try
{
info
(
"
Running
afterUnderflowed
task
"
)
;
await
afterUnderflowed
(
)
;
}
finally
{
await
Promise
.
all
(
extensions
.
map
(
extension
=
>
extension
.
unload
(
)
)
)
;
}
}
}
}
async
function
verifyExtensionWidget
(
win
widget
unifiedExtensionsEnabled
)
{
Assert
.
ok
(
widget
"
expected
widget
"
)
;
Assert
.
equal
(
widget
.
getAttribute
(
"
unified
-
extensions
"
)
unifiedExtensionsEnabled
?
"
true
"
:
"
false
"
expected
unified
-
extensions
attribute
to
be
{
String
(
unifiedExtensionsEnabled
)
}
)
;
let
actionButton
=
widget
.
firstElementChild
;
Assert
.
ok
(
actionButton
.
classList
.
contains
(
"
unified
-
extensions
-
item
-
action
"
)
"
expected
action
class
on
the
button
"
)
;
let
menuButton
=
widget
.
lastElementChild
;
Assert
.
ok
(
menuButton
.
classList
.
contains
(
"
unified
-
extensions
-
item
-
open
-
menu
"
)
"
expected
open
-
menu
class
on
the
button
"
)
;
let
contents
=
actionButton
.
querySelector
(
"
.
unified
-
extensions
-
item
-
contents
"
)
;
if
(
unifiedExtensionsEnabled
)
{
Assert
.
ok
(
contents
expected
contents
element
when
unifiedExtensionsEnabled
=
{
unifiedExtensionsEnabled
}
)
;
Assert
.
equal
(
contents
.
getAttribute
(
"
move
-
after
-
stack
"
)
"
true
"
"
expected
move
-
after
-
stack
attribute
to
be
set
"
)
;
Assert
.
deepEqual
(
Array
.
from
(
actionButton
.
childNodes
.
values
(
)
)
.
map
(
child
=
>
child
.
classList
[
0
]
)
[
"
toolbarbutton
-
badge
-
stack
"
"
toolbarbutton
-
text
"
"
unified
-
extensions
-
item
-
contents
"
]
"
expected
the
correct
order
for
the
children
of
the
action
button
"
)
;
let
name
=
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
name
"
)
;
Assert
.
ok
(
name
"
expected
name
element
"
)
;
Assert
.
ok
(
name
.
textContent
.
startsWith
(
"
Extension
"
)
"
expected
name
to
not
be
empty
"
)
;
Assert
.
ok
(
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
"
expected
message
default
element
"
)
;
Assert
.
ok
(
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
hover
"
)
"
expected
message
hover
element
"
)
;
Assert
.
equal
(
win
.
document
.
l10n
.
getAttributes
(
menuButton
)
.
id
"
unified
-
extensions
-
item
-
open
-
menu
"
"
expected
l10n
id
attribute
for
the
extension
"
)
;
Assert
.
deepEqual
(
Object
.
keys
(
win
.
document
.
l10n
.
getAttributes
(
menuButton
)
.
args
)
[
"
extensionName
"
]
"
expected
l10n
args
attribute
for
the
extension
"
)
;
Assert
.
ok
(
win
.
document
.
l10n
.
getAttributes
(
menuButton
)
.
args
.
extensionName
.
startsWith
(
"
Extension
"
)
"
expected
l10n
args
attribute
to
start
with
the
correct
name
"
)
;
Assert
.
ok
(
menuButton
.
getAttribute
(
"
aria
-
label
"
)
!
=
=
"
"
"
expected
menu
button
to
have
non
-
empty
localized
content
"
)
;
}
else
{
Assert
.
ok
(
!
contents
expected
no
contents
element
when
unifiedExtensionsEnabled
=
{
unifiedExtensionsEnabled
}
)
;
Assert
.
ok
(
actionButton
.
getAttribute
(
"
label
"
)
?
.
startsWith
(
"
Extension
"
)
"
expected
button
'
s
label
to
not
be
empty
"
)
;
}
}
add_task
(
async
function
test_overflowable_toolbar
(
)
{
let
win
=
await
promiseEnableUnifiedExtensions
(
)
;
let
movedNode
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
let
defaultListIDs
=
getChildrenIDs
(
defaultList
)
;
for
(
const
widgetID
of
DEFAULT_WIDGET_IDS
)
{
Assert
.
ok
(
defaultListIDs
.
includes
(
widgetID
)
Default
overflow
list
should
have
{
widgetID
}
)
;
}
Assert
.
ok
(
unifiedExtensionList
.
children
.
length
"
Should
have
items
in
the
Unified
Extension
list
.
"
)
;
for
(
const
child
of
Array
.
from
(
unifiedExtensionList
.
children
)
)
{
Assert
.
ok
(
extensionIDs
.
includes
(
child
.
dataset
.
extensionid
)
Unified
Extensions
overflow
list
should
have
{
child
.
dataset
.
extensionid
}
)
;
await
verifyExtensionWidget
(
win
child
true
)
;
}
let
extensionWidgetID
=
AppUiTestInternals
.
getBrowserActionWidgetId
(
extensionIDs
.
at
(
-
1
)
)
;
movedNode
=
CustomizableUI
.
getWidget
(
extensionWidgetID
)
.
forWindow
(
win
)
.
node
;
Assert
.
equal
(
movedNode
.
getAttribute
(
"
cui
-
areatype
"
)
"
toolbar
"
)
;
CustomizableUI
.
addWidgetToArea
(
extensionWidgetID
CustomizableUI
.
AREA_ADDONS
)
;
Assert
.
equal
(
movedNode
.
getAttribute
(
"
cui
-
areatype
"
)
"
panel
"
"
The
moved
browser
action
button
should
have
the
right
cui
-
areatype
set
.
"
)
;
}
afterUnderflowed
:
async
(
)
=
>
{
Assert
.
equal
(
movedNode
.
parentElement
.
id
CustomizableUI
.
AREA_ADDONS
"
The
browser
action
should
still
be
in
the
addons
panel
"
)
;
CustomizableUI
.
addWidgetToArea
(
movedNode
.
id
CustomizableUI
.
AREA_NAVBAR
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_overflowable_toolbar_legacy
(
)
{
let
win
=
await
promiseDisableUnifiedExtensions
(
)
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
const
defaultListIDs
=
getChildrenIDs
(
defaultList
)
;
for
(
const
widgetID
of
DEFAULT_WIDGET_IDS
)
{
Assert
.
ok
(
defaultListIDs
.
includes
(
widgetID
)
Default
overflow
list
should
have
{
widgetID
}
)
;
}
for
(
const
extensionID
of
extensionIDs
)
{
const
widget
=
defaultList
.
querySelector
(
[
data
-
extensionid
=
'
{
extensionID
}
'
]
)
;
Assert
.
ok
(
widget
Default
list
should
have
{
extensionID
}
)
;
await
verifyExtensionWidget
(
win
widget
false
)
;
}
Assert
.
equal
(
unifiedExtensionList
.
children
.
length
0
"
Unified
Extension
overflow
list
should
be
empty
.
"
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_menu_button
(
)
{
let
win
=
await
promiseEnableUnifiedExtensions
(
)
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
Assert
.
ok
(
unifiedExtensionList
.
children
.
length
"
Should
have
items
in
the
Unified
Extension
list
.
"
)
;
const
firstExtensionWidget
=
unifiedExtensionList
.
children
[
0
]
;
Assert
.
ok
(
firstExtensionWidget
"
expected
extension
widget
"
)
;
await
openExtensionsPanel
(
win
)
;
info
(
"
verifying
message
when
hovering
the
menu
button
"
)
;
const
item
=
getUnifiedExtensionsItem
(
win
firstExtensionWidget
.
dataset
.
extensionid
)
;
Assert
.
ok
(
item
"
expected
an
item
for
the
extension
"
)
;
const
actionButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
"
)
;
Assert
.
ok
(
actionButton
"
expected
action
button
"
)
;
const
menuButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
open
-
menu
"
)
;
Assert
.
ok
(
menuButton
"
expected
'
open
menu
'
button
"
)
;
const
message
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
;
const
messageHover
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
hover
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
message
)
"
expected
message
to
be
visible
"
)
;
Assert
.
ok
(
message
.
textContent
!
=
=
"
"
"
expected
message
on
hover
to
not
be
empty
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
messageHover
)
"
expected
'
hover
message
'
to
be
hidden
"
)
;
let
hovered
=
BrowserTestUtils
.
waitForEvent
(
menuButton
"
mouseover
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuButton
{
type
:
"
mouseover
"
}
win
)
;
await
hovered
;
is
(
item
.
getAttribute
(
"
secondary
-
button
-
hovered
"
)
"
true
"
"
expected
secondary
-
button
-
hovered
attr
on
the
item
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
)
"
expected
message
to
be
hidden
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
messageHover
)
"
expected
'
hover
message
'
to
be
visible
"
)
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
messageHover
)
{
id
:
"
unified
-
extensions
-
item
-
message
-
manage
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
message
displayed
on
secondary
button
hovered
"
)
;
Assert
.
ok
(
messageHover
.
textContent
!
=
=
"
"
"
expected
message
on
hover
to
not
be
empty
"
)
;
let
notHovered
=
BrowserTestUtils
.
waitForEvent
(
menuButton
"
mouseout
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
item
{
type
:
"
mouseover
"
}
win
)
;
await
notHovered
;
Assert
.
ok
(
!
item
.
hasAttribute
(
"
secondary
-
button
-
hovered
"
)
"
expected
no
secondary
-
button
-
hovered
attr
on
the
item
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
)
"
expected
message
to
be
visible
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
messageHover
)
"
expected
'
hover
message
'
to
be
hidden
"
)
;
await
closeExtensionsPanel
(
win
)
;
await
openExtensionsPanel
(
win
)
;
info
(
"
moving
focus
to
first
extension
with
keyboard
navigation
"
)
;
let
focused
=
BrowserTestUtils
.
waitForEvent
(
actionButton
"
focus
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
}
win
)
;
await
focused
;
is
(
actionButton
win
.
document
.
activeElement
"
expected
action
button
of
the
first
extension
item
to
be
focused
"
)
;
Assert
.
ok
(
!
item
.
hasAttribute
(
"
secondary
-
button
-
hovered
"
)
"
expected
no
secondary
-
button
-
hovered
attr
on
the
item
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
)
"
expected
message
to
be
visible
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
messageHover
)
"
expected
'
hover
message
'
to
be
hidden
"
)
;
info
(
"
moving
focus
to
menu
button
"
)
;
focused
=
BrowserTestUtils
.
waitForEvent
(
menuButton
"
focus
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
}
win
)
;
await
focused
;
is
(
menuButton
win
.
document
.
activeElement
"
expected
menu
button
of
the
first
extension
to
be
focused
"
)
;
Assert
.
ok
(
item
.
hasAttribute
(
"
secondary
-
button
-
hovered
"
)
"
expected
secondary
-
button
-
hovered
attr
on
the
item
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
)
"
expected
message
to
be
hidden
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
messageHover
)
"
expected
'
hover
message
'
to
be
visible
"
)
;
await
closeExtensionsPanel
(
win
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_context_menu
(
)
{
let
win
=
await
promiseEnableUnifiedExtensions
(
)
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
Assert
.
ok
(
unifiedExtensionList
.
children
.
length
"
Should
have
items
in
the
Unified
Extension
list
.
"
)
;
await
openExtensionsPanel
(
win
)
;
info
(
"
extension
with
browser
action
and
a
menu
"
)
;
const
firstExtensionWidget
=
unifiedExtensionList
.
children
[
0
]
;
Assert
.
ok
(
firstExtensionWidget
"
expected
extension
widget
"
)
;
let
contextMenu
=
await
openUnifiedExtensionsContextMenu
(
win
firstExtensionWidget
.
dataset
.
extensionid
)
;
Assert
.
ok
(
contextMenu
"
expected
a
context
menu
"
)
;
let
visibleItems
=
getVisibleMenuItems
(
contextMenu
)
;
is
(
visibleItems
.
length
7
"
expected
a
custom
context
menu
item
a
menu
separator
the
pin
to
"
+
"
toolbar
menu
item
a
menu
separator
and
the
3
default
menu
items
"
)
;
const
[
item
separator
]
=
visibleItems
;
is
(
item
.
getAttribute
(
"
label
"
)
"
Click
me
!
"
"
expected
menu
item
as
first
child
"
)
;
is
(
separator
.
tagName
"
menuseparator
"
"
expected
separator
after
last
menu
item
created
by
the
extension
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
null
win
)
;
info
(
"
extension
with
browser
action
and
a
menu
with
submenu
"
)
;
const
secondExtensionWidget
=
unifiedExtensionList
.
children
[
1
]
;
Assert
.
ok
(
secondExtensionWidget
"
expected
extension
widget
"
)
;
contextMenu
=
await
openUnifiedExtensionsContextMenu
(
win
secondExtensionWidget
.
dataset
.
extensionid
)
;
visibleItems
=
getVisibleMenuItems
(
contextMenu
)
;
is
(
visibleItems
.
length
7
"
expected
7
menu
items
"
)
;
const
popup
=
await
openSubmenu
(
visibleItems
[
0
]
)
;
is
(
popup
.
children
.
length
1
"
expected
1
submenu
item
"
)
;
is
(
popup
.
children
[
0
]
.
getAttribute
(
"
label
"
)
"
Click
me
!
"
"
expected
menu
item
"
)
;
visibleItems
=
getVisibleMenuItems
(
contextMenu
)
;
is
(
visibleItems
.
length
7
"
expected
7
menu
items
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
null
win
)
;
info
(
"
extension
with
no
browser
action
and
no
menu
"
)
;
const
thirdExtensionWidget
=
unifiedExtensionList
.
children
[
2
]
;
Assert
.
ok
(
thirdExtensionWidget
"
expected
extension
widget
"
)
;
contextMenu
=
await
openUnifiedExtensionsContextMenu
(
win
thirdExtensionWidget
.
dataset
.
extensionid
)
;
Assert
.
ok
(
contextMenu
"
expected
a
context
menu
"
)
;
visibleItems
=
getVisibleMenuItems
(
contextMenu
)
;
is
(
visibleItems
.
length
5
"
expected
5
menu
items
"
)
;
await
closeChromeContextMenu
(
contextMenu
.
id
null
win
)
;
await
closeExtensionsPanel
(
win
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_action_button
(
)
{
let
win
=
await
promiseEnableUnifiedExtensions
(
)
;
await
withWindowOverflowed
(
win
{
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
Assert
.
ok
(
unifiedExtensionList
.
children
.
length
"
Should
have
items
in
the
Unified
Extension
list
.
"
)
;
const
firstExtensionWidget
=
unifiedExtensionList
.
children
[
0
]
;
Assert
.
ok
(
firstExtensionWidget
"
expected
extension
widget
"
)
;
Assert
.
ok
(
firstExtensionWidget
.
dataset
.
extensionid
"
expected
data
attribute
for
extension
ID
"
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
win
.
gBrowser
url
:
"
https
:
/
/
example
.
com
/
"
}
async
(
)
=
>
{
await
openExtensionsPanel
(
win
)
;
info
(
"
verify
message
when
focusing
the
action
button
"
)
;
const
item
=
getUnifiedExtensionsItem
(
win
firstExtensionWidget
.
dataset
.
extensionid
)
;
Assert
.
ok
(
item
"
expected
an
item
for
the
extension
"
)
;
const
actionButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
"
)
;
Assert
.
ok
(
actionButton
"
expected
action
button
"
)
;
const
menuButton
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
open
-
menu
"
)
;
Assert
.
ok
(
menuButton
"
expected
menu
button
"
)
;
const
message
=
item
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
message
)
{
id
:
"
origin
-
controls
-
state
-
when
-
clicked
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
message
displayed
by
default
"
)
;
Assert
.
ok
(
message
.
textContent
!
=
=
"
"
"
expected
message
to
not
be
empty
"
)
;
let
focused
=
BrowserTestUtils
.
waitForEvent
(
actionButton
"
focus
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
}
win
)
;
await
focused
;
is
(
actionButton
win
.
document
.
activeElement
"
expected
action
button
of
the
first
extension
item
to
be
focused
"
)
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
message
)
{
id
:
"
origin
-
controls
-
state
-
hover
-
run
-
visit
-
only
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
message
displayed
when
focusing
the
action
button
"
)
;
Assert
.
ok
(
message
.
textContent
!
=
=
"
"
"
expected
message
to
not
be
empty
"
)
;
focused
=
BrowserTestUtils
.
waitForEvent
(
menuButton
"
focus
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_TAB
"
{
}
win
)
;
await
focused
;
is
(
menuButton
win
.
document
.
activeElement
"
expected
menu
button
of
the
first
extension
item
to
be
focused
"
)
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
message
)
{
id
:
"
origin
-
controls
-
state
-
when
-
clicked
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
message
displayed
by
default
"
)
;
await
closeExtensionsPanel
(
win
)
;
info
(
"
verify
message
when
hovering
the
action
button
"
)
;
await
openExtensionsPanel
(
win
)
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
message
)
{
id
:
"
origin
-
controls
-
state
-
when
-
clicked
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
message
displayed
by
default
"
)
;
let
hovered
=
BrowserTestUtils
.
waitForEvent
(
actionButton
"
mouseover
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
actionButton
{
type
:
"
mouseover
"
}
win
)
;
await
hovered
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
message
)
{
id
:
"
origin
-
controls
-
state
-
hover
-
run
-
visit
-
only
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
message
displayed
when
hovering
the
action
button
"
)
;
hovered
=
BrowserTestUtils
.
waitForEvent
(
menuButton
"
mouseover
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuButton
{
type
:
"
mouseover
"
}
win
)
;
await
hovered
;
Assert
.
deepEqual
(
win
.
document
.
l10n
.
getAttributes
(
message
)
{
id
:
"
origin
-
controls
-
state
-
when
-
clicked
"
args
:
null
}
"
expected
correct
l10n
attributes
for
the
message
displayed
by
default
"
)
;
await
closeExtensionsPanel
(
win
)
;
}
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_pinning_to_toolbar_when_overflowed
(
)
{
let
win
=
await
promiseEnableUnifiedExtensions
(
)
;
let
movedNode
;
let
extensionWidgetID
;
await
withWindowOverflowed
(
win
{
beforeOverflowed
:
async
extensionIDs
=
>
{
extensionWidgetID
=
AppUiTestInternals
.
getBrowserActionWidgetId
(
extensionIDs
.
at
(
-
1
)
)
;
movedNode
=
CustomizableUI
.
getWidget
(
extensionWidgetID
)
.
forWindow
(
win
)
.
node
;
CustomizableUI
.
addWidgetToArea
(
extensionWidgetID
CustomizableUI
.
AREA_ADDONS
)
;
}
whenOverflowed
:
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
CustomizableUI
.
addWidgetToArea
(
extensionWidgetID
CustomizableUI
.
AREA_NAVBAR
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
movedNode
.
hasAttribute
(
"
overflowedItem
"
)
;
}
)
;
Assert
.
equal
(
movedNode
.
parentElement
unifiedExtensionList
"
Should
have
overflowed
the
extension
button
to
the
right
list
.
"
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
