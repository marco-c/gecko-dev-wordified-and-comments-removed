"
use
strict
"
;
loadTestSubscript
(
"
head_unified_extensions
.
js
"
)
;
const
NUM_EXTENSIONS
=
5
;
const
OVERFLOW_WINDOW_WIDTH_PX
=
450
;
const
DEFAULT_WIDGET_IDS
=
[
"
home
-
button
"
"
library
-
button
"
"
zoom
-
controls
"
"
search
-
container
"
"
sidebar
-
button
"
]
;
add_setup
(
async
function
(
)
{
let
existingWidgetIDs
=
CustomizableUI
.
getWidgetIdsInArea
(
CustomizableUI
.
AREA_NAVBAR
)
;
for
(
let
widgetID
of
existingWidgetIDs
)
{
if
(
CustomizableUI
.
isWidgetRemovable
(
widgetID
)
)
{
CustomizableUI
.
removeWidgetFromArea
(
widgetID
)
;
}
}
for
(
const
widgetID
of
DEFAULT_WIDGET_IDS
)
{
CustomizableUI
.
addWidgetToArea
(
widgetID
CustomizableUI
.
AREA_NAVBAR
)
;
}
registerCleanupFunction
(
async
(
)
=
>
{
await
CustomizableUI
.
reset
(
)
;
}
)
;
}
)
;
function
getChildrenIDs
(
parent
)
{
return
Array
.
from
(
parent
.
children
)
.
map
(
child
=
>
child
.
id
)
;
}
async
function
withWindowOverflowed
(
win
taskFn
)
{
const
doc
=
win
.
document
;
doc
.
documentElement
.
removeAttribute
(
"
persist
"
)
;
const
navbar
=
doc
.
getElementById
(
CustomizableUI
.
AREA_NAVBAR
)
;
const
signpostWidgetID
=
"
home
-
button
"
;
CustomizableUI
.
getWidget
(
signpostWidgetID
)
.
forWindow
(
win
)
.
node
.
style
=
"
width
:
150px
"
;
const
manifests
=
[
]
;
for
(
let
i
=
0
;
i
<
NUM_EXTENSIONS
;
+
+
i
)
{
manifests
.
push
(
{
name
:
Extension
#
{
i
}
browser_action
:
{
}
}
)
;
}
const
extensions
=
createExtensions
(
manifests
)
;
let
listener
=
{
_remainingBrowserActions
:
NUM_EXTENSIONS
_deferred
:
PromiseUtils
.
defer
(
)
get
promise
(
)
{
return
this
.
_deferred
.
promise
;
}
onWidgetAdded
(
widgetID
area
)
{
if
(
widgetID
.
endsWith
(
"
-
browser
-
action
"
)
)
{
this
.
_remainingBrowserActions
-
-
;
}
if
(
!
this
.
_remainingBrowserActions
)
{
this
.
_deferred
.
resolve
(
)
;
}
}
}
;
CustomizableUI
.
addListener
(
listener
)
;
await
Promise
.
all
(
extensions
.
map
(
extension
=
>
extension
.
startup
(
)
)
)
;
await
listener
.
promise
;
CustomizableUI
.
removeListener
(
listener
)
;
const
originalWindowWidth
=
win
.
outerWidth
;
win
.
resizeTo
(
OVERFLOW_WINDOW_WIDTH_PX
win
.
outerHeight
)
;
const
extensionIDs
=
extensions
.
map
(
extension
=
>
extension
.
id
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
(
navbar
.
hasAttribute
(
"
overflowing
"
)
&
&
doc
.
getElementById
(
signpostWidgetID
)
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
&
&
doc
.
querySelector
(
[
data
-
extensionid
=
'
{
extensionIDs
[
0
]
}
'
]
)
?
.
getAttribute
(
"
overflowedItem
"
)
=
=
"
true
"
)
;
}
)
;
Assert
.
ok
(
navbar
.
hasAttribute
(
"
overflowing
"
)
"
Should
have
an
overflowing
toolbar
.
"
)
;
const
defaultList
=
doc
.
getElementById
(
navbar
.
getAttribute
(
"
default
-
overflowtarget
"
)
)
;
const
unifiedExtensionList
=
doc
.
getElementById
(
navbar
.
getAttribute
(
"
addon
-
webext
-
overflowtarget
"
)
)
;
try
{
await
taskFn
(
defaultList
unifiedExtensionList
extensionIDs
)
;
}
finally
{
win
.
resizeTo
(
originalWindowWidth
win
.
outerHeight
)
;
await
BrowserTestUtils
.
waitForEvent
(
win
"
resize
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
doc
.
getElementById
(
signpostWidgetID
)
.
hasAttribute
(
"
overflowedItem
"
)
;
}
)
;
await
Promise
.
all
(
extensions
.
map
(
extension
=
>
extension
.
unload
(
)
)
)
;
}
}
function
verifyExtensionWidget
(
widget
unifiedExtensionsEnabled
)
{
Assert
.
ok
(
widget
"
expected
widget
"
)
;
Assert
.
equal
(
widget
.
getAttribute
(
"
unified
-
extensions
"
)
unifiedExtensionsEnabled
?
"
true
"
:
"
false
"
expected
unified
-
extensions
attribute
to
be
{
String
(
unifiedExtensionsEnabled
)
}
)
;
let
actionButton
=
widget
.
firstElementChild
;
Assert
.
ok
(
actionButton
.
classList
.
contains
(
"
unified
-
extensions
-
item
-
action
"
)
"
expected
action
class
on
the
button
"
)
;
let
contents
=
actionButton
.
querySelector
(
"
.
unified
-
extensions
-
item
-
contents
"
)
;
if
(
unifiedExtensionsEnabled
)
{
Assert
.
ok
(
contents
expected
contents
element
when
unifiedExtensionsEnabled
=
{
unifiedExtensionsEnabled
}
)
;
Assert
.
equal
(
contents
.
getAttribute
(
"
move
-
after
-
stack
"
)
"
true
"
"
expected
move
-
after
-
stack
attribute
to
be
set
"
)
;
Assert
.
deepEqual
(
Array
.
from
(
actionButton
.
childNodes
.
values
(
)
)
.
map
(
child
=
>
child
.
classList
[
0
]
)
[
"
toolbarbutton
-
badge
-
stack
"
"
toolbarbutton
-
text
"
"
unified
-
extensions
-
item
-
contents
"
]
"
expected
the
correct
order
for
the
children
of
the
action
button
"
)
;
let
name
=
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
name
"
)
;
Assert
.
ok
(
name
"
expected
name
element
"
)
;
Assert
.
ok
(
name
.
textContent
.
startsWith
(
"
Extension
"
)
"
expected
name
to
not
be
empty
"
)
;
Assert
.
ok
(
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
default
"
)
"
expected
message
default
element
"
)
;
Assert
.
ok
(
contents
.
querySelector
(
"
.
unified
-
extensions
-
item
-
message
-
hover
"
)
"
expected
message
hover
element
"
)
;
}
else
{
Assert
.
ok
(
!
contents
expected
no
contents
element
when
unifiedExtensionsEnabled
=
{
unifiedExtensionsEnabled
}
)
;
Assert
.
ok
(
actionButton
.
getAttribute
(
"
label
"
)
?
.
startsWith
(
"
Extension
"
)
"
expected
button
'
s
label
to
not
be
empty
"
)
;
}
}
add_task
(
async
function
test_overflowable_toolbar
(
)
{
let
win
=
await
promiseEnableUnifiedExtensions
(
)
;
await
withWindowOverflowed
(
win
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
let
defaultListIDs
=
getChildrenIDs
(
defaultList
)
;
for
(
const
widgetID
of
DEFAULT_WIDGET_IDS
)
{
Assert
.
ok
(
defaultListIDs
.
includes
(
widgetID
)
Default
overflow
list
should
have
{
widgetID
}
)
;
}
Assert
.
ok
(
unifiedExtensionList
.
children
.
length
"
Should
have
items
in
the
Unified
Extension
list
.
"
)
;
for
(
const
child
of
Array
.
from
(
unifiedExtensionList
.
children
)
)
{
Assert
.
ok
(
extensionIDs
.
includes
(
child
.
dataset
.
extensionid
)
Unified
Extensions
overflow
list
should
have
{
child
.
dataset
.
extensionid
}
)
;
verifyExtensionWidget
(
child
true
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
add_task
(
async
function
test_overflowable_toolbar_legacy
(
)
{
let
win
=
await
promiseDisableUnifiedExtensions
(
)
;
await
withWindowOverflowed
(
win
async
(
defaultList
unifiedExtensionList
extensionIDs
)
=
>
{
const
defaultListIDs
=
getChildrenIDs
(
defaultList
)
;
for
(
const
widgetID
of
DEFAULT_WIDGET_IDS
)
{
Assert
.
ok
(
defaultListIDs
.
includes
(
widgetID
)
Default
overflow
list
should
have
{
widgetID
}
)
;
}
for
(
const
extensionID
of
extensionIDs
)
{
const
widget
=
defaultList
.
querySelector
(
[
data
-
extensionid
=
'
{
extensionID
}
'
]
)
;
Assert
.
ok
(
widget
Default
list
should
have
{
extensionID
}
)
;
verifyExtensionWidget
(
widget
false
)
;
}
Assert
.
equal
(
unifiedExtensionList
.
children
.
length
0
"
Unified
Extension
overflow
list
should
be
empty
.
"
)
;
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
