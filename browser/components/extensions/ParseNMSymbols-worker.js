"
use
strict
"
;
importScripts
(
"
resource
:
/
/
/
modules
/
ParseSymbols
.
jsm
"
)
;
class
WorkerNMParser
{
constructor
(
)
{
this
.
_decoder
=
new
TextDecoder
(
)
;
this
.
_addrToSymMap
=
new
Map
(
)
;
this
.
_approximateLength
=
0
;
}
consume
(
arrayBuffer
)
{
const
data
=
this
.
_decoder
.
decode
(
arrayBuffer
{
stream
:
true
}
)
;
const
lineRegex
=
/
.
*
\
n
?
/
g
;
const
buffer
=
this
.
_currentLine
+
data
;
let
match
;
while
(
(
match
=
lineRegex
.
exec
(
buffer
)
)
)
{
let
[
line
]
=
match
;
if
(
line
[
line
.
length
-
1
]
=
=
=
"
\
n
"
)
{
this
.
_processLine
(
line
)
;
}
else
{
this
.
_currentLine
=
line
;
break
;
}
}
}
finish
(
)
{
this
.
_processLine
(
this
.
_currentLine
)
;
return
{
syms
:
this
.
_addrToSymMap
approximateLength
:
this
.
_approximateLength
}
;
}
_processLine
(
line
)
{
const
regex
=
/
(
[
^
]
+
)
(
?
:
.
)
?
(
.
*
)
/
;
let
match
=
regex
.
exec
(
line
)
;
if
(
match
)
{
const
[
address
symbol
]
=
match
;
this
.
_addrToSymMap
.
set
(
parseInt
(
address
16
)
symbol
)
;
this
.
_approximateLength
+
=
symbol
.
length
;
}
}
}
let
nmParser
;
onmessage
=
async
e
=
>
{
try
{
if
(
!
nmParser
)
{
nmParser
=
new
WorkerNMParser
(
)
;
}
if
(
e
.
data
.
finish
)
{
const
{
syms
approximateLength
}
=
nmParser
.
finish
(
)
;
let
result
;
if
(
e
.
data
.
isDarwin
)
{
result
=
ParseSymbols
.
convertSymsMapToDemanglerFormat
(
syms
)
;
}
else
{
result
=
ParseSymbols
.
convertSymsMapToExpectedSymFormat
(
syms
approximateLength
)
;
}
postMessage
(
{
result
}
result
.
map
(
r
=
>
r
.
buffer
)
)
;
close
(
)
;
}
else
{
nmParser
.
consume
(
e
.
data
.
buffer
)
;
}
}
catch
(
error
)
{
postMessage
(
{
error
:
error
.
toString
(
)
}
)
;
}
}
;
