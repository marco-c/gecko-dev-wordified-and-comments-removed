"
use
strict
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
let
themeMap
=
new
WeakMap
(
)
;
class
Theme
{
constructor
(
baseURI
)
{
this
.
lwtStyles
=
{
}
;
this
.
baseURI
=
baseURI
;
}
load
(
details
)
{
if
(
details
.
colors
)
{
this
.
loadColors
(
details
.
colors
)
;
}
if
(
details
.
images
)
{
this
.
loadImages
(
details
.
images
)
;
}
if
(
this
.
lwtStyles
.
headerURL
&
&
this
.
lwtStyles
.
accentcolor
&
&
this
.
lwtStyles
.
textcolor
)
{
Services
.
obs
.
notifyObservers
(
null
"
lightweight
-
theme
-
styling
-
update
"
JSON
.
stringify
(
this
.
lwtStyles
)
)
;
}
}
loadColors
(
colors
)
{
for
(
let
color
of
Object
.
keys
(
colors
)
)
{
Services
.
console
.
logStringMessage
(
parsing
color
=
{
color
}
)
;
let
val
=
colors
[
color
]
;
if
(
!
val
)
{
continue
;
}
let
cssColor
=
val
;
if
(
Array
.
isArray
(
val
)
)
{
cssColor
=
"
rgb
"
+
(
val
.
length
>
3
?
"
a
"
:
"
"
)
+
"
(
"
+
val
.
join
(
"
"
)
+
"
)
"
;
}
switch
(
color
)
{
case
"
accentcolor
"
:
case
"
frame
"
:
this
.
lwtStyles
.
accentcolor
=
cssColor
;
break
;
case
"
textcolor
"
:
case
"
tab_text
"
:
this
.
lwtStyles
.
textcolor
=
cssColor
;
break
;
}
}
}
loadImages
(
images
)
{
for
(
let
image
of
Object
.
keys
(
images
)
)
{
let
val
=
images
[
image
]
;
if
(
!
val
)
{
continue
;
}
switch
(
image
)
{
case
"
headerURL
"
:
case
"
theme_frame
"
:
{
let
resolvedURL
=
this
.
baseURI
.
resolve
(
val
)
;
this
.
lwtStyles
.
headerURL
=
resolvedURL
;
break
;
}
}
}
}
unload
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
lightweight
-
theme
-
styling
-
update
"
null
)
;
}
}
extensions
.
on
(
"
manifest_theme
"
(
type
directive
extension
manifest
)
=
>
{
if
(
!
Preferences
.
get
(
"
extensions
.
webextensions
.
themes
.
enabled
"
)
)
{
return
;
}
let
theme
=
new
Theme
(
extension
.
baseURI
)
;
theme
.
load
(
manifest
.
theme
)
;
themeMap
.
set
(
extension
theme
)
;
}
)
;
extensions
.
on
(
"
shutdown
"
(
type
extension
)
=
>
{
let
theme
=
themeMap
.
get
(
extension
)
;
if
(
!
theme
)
{
return
;
}
theme
.
unload
(
)
;
}
)
;
extensions
.
registerSchemaAPI
(
"
theme
"
"
addon_parent
"
context
=
>
{
let
{
extension
}
=
context
;
return
{
theme
:
{
update
(
details
)
{
let
theme
=
themeMap
.
get
(
extension
)
;
if
(
!
theme
)
{
return
;
}
theme
.
load
(
details
)
;
}
}
}
;
}
)
;
