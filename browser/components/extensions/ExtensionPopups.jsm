"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BasePopup
"
"
PanelPopup
"
"
ViewPopup
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
/
modules
/
E10SUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionParent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
DefaultWeakMap
promiseEvent
}
=
ExtensionUtils
;
const
POPUP_LOAD_TIMEOUT_MS
=
200
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
function
makeWidgetId
(
id
)
{
id
=
id
.
toLowerCase
(
)
;
return
id
.
replace
(
/
[
^
a
-
z0
-
9_
-
]
/
g
"
_
"
)
;
}
function
promisePopupShown
(
popup
)
{
return
new
Promise
(
resolve
=
>
{
if
(
popup
.
state
=
=
"
open
"
)
{
resolve
(
)
;
}
else
{
popup
.
addEventListener
(
"
popupshown
"
function
(
event
)
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
popupStylesheets
"
(
)
=
>
{
let
stylesheets
=
[
"
chrome
:
/
/
browser
/
content
/
extension
.
css
"
]
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
stylesheets
.
push
(
"
chrome
:
/
/
browser
/
content
/
extension
-
mac
.
css
"
)
;
}
return
stylesheets
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
standaloneStylesheets
"
(
)
=
>
{
let
stylesheets
=
[
]
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
stylesheets
.
push
(
"
chrome
:
/
/
browser
/
content
/
extension
-
mac
-
panel
.
css
"
)
;
}
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
stylesheets
.
push
(
"
chrome
:
/
/
browser
/
content
/
extension
-
win
-
panel
.
css
"
)
;
}
return
stylesheets
;
}
)
;
class
BasePopup
{
constructor
(
extension
viewNode
popupURL
browserStyle
fixedWidth
=
false
)
{
this
.
extension
=
extension
;
this
.
popupURL
=
popupURL
;
this
.
viewNode
=
viewNode
;
this
.
browserStyle
=
browserStyle
;
this
.
window
=
viewNode
.
ownerGlobal
;
this
.
destroyed
=
false
;
this
.
fixedWidth
=
fixedWidth
;
extension
.
callOnClose
(
this
)
;
this
.
contentReady
=
new
Promise
(
resolve
=
>
{
this
.
_resolveContentReady
=
resolve
;
}
)
;
this
.
viewNode
.
addEventListener
(
this
.
DESTROY_EVENT
this
)
;
let
doc
=
viewNode
.
ownerDocument
;
let
arrowContent
=
doc
.
getAnonymousElementByAttribute
(
this
.
panel
"
class
"
"
panel
-
arrowcontent
"
)
;
this
.
borderColor
=
doc
.
defaultView
.
getComputedStyle
(
arrowContent
)
.
borderTopColor
;
this
.
browser
=
null
;
this
.
browserLoaded
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
browserLoadedDeferred
=
{
resolve
reject
}
;
}
)
;
this
.
browserReady
=
this
.
createBrowser
(
viewNode
popupURL
)
;
BasePopup
.
instances
.
get
(
this
.
window
)
.
set
(
extension
this
)
;
}
static
for
(
extension
window
)
{
return
BasePopup
.
instances
.
get
(
window
)
.
get
(
extension
)
;
}
close
(
)
{
this
.
closePopup
(
)
;
}
destroy
(
)
{
this
.
extension
.
forgetOnClose
(
this
)
;
this
.
destroyed
=
true
;
this
.
browserLoadedDeferred
.
reject
(
new
Error
(
"
Popup
destroyed
"
)
)
;
return
this
.
browserReady
.
then
(
(
)
=
>
{
this
.
destroyBrowser
(
this
.
browser
true
)
;
this
.
browser
.
remove
(
)
;
if
(
this
.
viewNode
)
{
this
.
viewNode
.
removeEventListener
(
this
.
DESTROY_EVENT
this
)
;
this
.
viewNode
.
style
.
maxHeight
=
"
"
;
}
if
(
this
.
panel
)
{
this
.
panel
.
style
.
removeProperty
(
"
-
-
arrowpanel
-
background
"
)
;
this
.
panel
.
style
.
removeProperty
(
"
-
-
panel
-
arrow
-
image
-
vertical
"
)
;
}
BasePopup
.
instances
.
get
(
this
.
window
)
.
delete
(
this
.
extension
)
;
this
.
browser
=
null
;
this
.
viewNode
=
null
;
}
)
;
}
destroyBrowser
(
browser
finalize
=
false
)
{
let
mm
=
browser
.
messageManager
;
if
(
mm
)
{
mm
.
removeMessageListener
(
"
DOMTitleChanged
"
this
)
;
mm
.
removeMessageListener
(
"
Extension
:
BrowserBackgroundChanged
"
this
)
;
mm
.
removeMessageListener
(
"
Extension
:
BrowserContentLoaded
"
this
)
;
mm
.
removeMessageListener
(
"
Extension
:
BrowserResized
"
this
)
;
mm
.
removeMessageListener
(
"
Extension
:
DOMWindowClose
"
this
)
;
}
else
if
(
finalize
)
{
this
.
receiveMessage
=
(
)
=
>
{
}
;
}
}
get
DESTROY_EVENT
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
get
STYLESHEETS
(
)
{
let
sheets
=
[
]
;
if
(
this
.
browserStyle
)
{
sheets
.
push
(
.
.
.
popupStylesheets
)
;
}
if
(
!
this
.
fixedWidth
)
{
sheets
.
push
(
.
.
.
standaloneStylesheets
)
;
}
return
sheets
;
}
get
panel
(
)
{
let
panel
=
this
.
viewNode
;
while
(
panel
&
&
panel
.
localName
!
=
"
panel
"
)
{
panel
=
panel
.
parentNode
;
}
return
panel
;
}
receiveMessage
(
{
name
data
}
)
{
switch
(
name
)
{
case
"
DOMTitleChanged
"
:
this
.
viewNode
.
setAttribute
(
"
aria
-
label
"
this
.
browser
.
contentTitle
)
;
break
;
case
"
Extension
:
BrowserBackgroundChanged
"
:
this
.
setBackground
(
data
.
background
)
;
break
;
case
"
Extension
:
BrowserContentLoaded
"
:
this
.
browserLoadedDeferred
.
resolve
(
)
;
break
;
case
"
Extension
:
BrowserResized
"
:
this
.
_resolveContentReady
(
)
;
if
(
this
.
ignoreResizes
)
{
this
.
dimensions
=
data
;
}
else
{
this
.
resizeBrowser
(
data
)
;
}
break
;
case
"
Extension
:
DOMWindowClose
"
:
this
.
closePopup
(
)
;
break
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
this
.
DESTROY_EVENT
:
if
(
!
this
.
destroyed
)
{
this
.
destroy
(
)
;
}
break
;
}
}
createBrowser
(
viewNode
popupURL
=
null
)
{
let
document
=
viewNode
.
ownerDocument
;
let
browser
=
document
.
createElementNS
(
XUL_NS
"
browser
"
)
;
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
browser
.
setAttribute
(
"
disableglobalhistory
"
"
true
"
)
;
browser
.
setAttribute
(
"
transparent
"
"
true
"
)
;
browser
.
setAttribute
(
"
class
"
"
webextension
-
popup
-
browser
"
)
;
browser
.
setAttribute
(
"
webextension
-
view
-
type
"
"
popup
"
)
;
browser
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
if
(
this
.
extension
.
remote
)
{
browser
.
setAttribute
(
"
remote
"
"
true
"
)
;
browser
.
setAttribute
(
"
remoteType
"
E10SUtils
.
EXTENSION_REMOTE_TYPE
)
;
}
browser
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
browser
=
browser
;
let
readyPromise
;
if
(
this
.
extension
.
remote
)
{
readyPromise
=
promiseEvent
(
browser
"
XULFrameLoaderCreated
"
)
;
}
else
{
readyPromise
=
promiseEvent
(
browser
"
load
"
)
;
}
viewNode
.
appendChild
(
browser
)
;
ExtensionParent
.
apiManager
.
emit
(
"
extension
-
browser
-
inserted
"
browser
)
;
let
setupBrowser
=
browser
=
>
{
let
mm
=
browser
.
messageManager
;
mm
.
addMessageListener
(
"
DOMTitleChanged
"
this
)
;
mm
.
addMessageListener
(
"
Extension
:
BrowserBackgroundChanged
"
this
)
;
mm
.
addMessageListener
(
"
Extension
:
BrowserContentLoaded
"
this
)
;
mm
.
addMessageListener
(
"
Extension
:
BrowserResized
"
this
)
;
mm
.
addMessageListener
(
"
Extension
:
DOMWindowClose
"
this
true
)
;
return
browser
;
}
;
if
(
!
popupURL
)
{
if
(
this
.
extension
.
remote
)
{
return
readyPromise
.
then
(
(
)
=
>
setupBrowser
(
browser
)
)
;
}
return
setupBrowser
(
browser
)
;
}
return
readyPromise
.
then
(
(
)
=
>
{
setupBrowser
(
browser
)
;
let
mm
=
browser
.
messageManager
;
mm
.
loadFrameScript
(
"
chrome
:
/
/
extensions
/
content
/
ext
-
browser
-
content
.
js
"
false
)
;
mm
.
sendAsyncMessage
(
"
Extension
:
InitBrowser
"
{
allowScriptsToClose
:
true
fixedWidth
:
this
.
fixedWidth
maxWidth
:
800
maxHeight
:
600
stylesheets
:
this
.
STYLESHEETS
}
)
;
browser
.
loadURI
(
popupURL
)
;
}
)
;
}
resizeBrowser
(
{
width
height
detail
}
)
{
if
(
this
.
fixedWidth
)
{
let
side
=
this
.
panel
.
getAttribute
(
"
side
"
)
=
=
"
top
"
?
"
bottom
"
:
"
top
"
;
let
maxHeight
=
this
.
viewHeight
+
this
.
extraHeight
[
side
]
;
height
=
Math
.
min
(
height
maxHeight
)
;
this
.
browser
.
style
.
height
=
{
height
}
px
;
height
=
Math
.
max
(
height
this
.
viewHeight
)
;
this
.
viewNode
.
style
.
maxHeight
=
{
height
}
px
;
}
else
{
this
.
browser
.
style
.
width
=
{
width
}
px
;
this
.
browser
.
style
.
minWidth
=
{
width
}
px
;
this
.
browser
.
style
.
height
=
{
height
}
px
;
this
.
browser
.
style
.
minHeight
=
{
height
}
px
;
}
let
event
=
new
this
.
window
.
CustomEvent
(
"
WebExtPopupResized
"
{
detail
}
)
;
this
.
browser
.
dispatchEvent
(
event
)
;
}
setBackground
(
background
)
{
let
panelBackground
=
"
"
;
let
panelArrow
=
"
"
;
if
(
background
)
{
let
borderColor
=
this
.
borderColor
|
|
background
;
panelBackground
=
background
;
panelArrow
=
url
(
"
data
:
image
/
svg
+
xml
{
encodeURIComponent
(
<
?
xml
version
=
"
1
.
0
"
encoding
=
"
UTF
-
8
"
?
>
<
svg
xmlns
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
width
=
"
20
"
height
=
"
10
"
>
<
path
d
=
"
M
0
10
L
10
0
20
10
z
"
fill
=
"
{
borderColor
}
"
/
>
<
path
d
=
"
M
1
10
L
10
1
19
10
z
"
fill
=
"
{
background
}
"
/
>
<
/
svg
>
)
}
"
)
;
}
this
.
panel
.
style
.
setProperty
(
"
-
-
arrowpanel
-
background
"
panelBackground
)
;
this
.
panel
.
style
.
setProperty
(
"
-
-
panel
-
arrow
-
image
-
vertical
"
panelArrow
)
;
this
.
background
=
background
;
}
}
BasePopup
.
instances
=
new
DefaultWeakMap
(
(
)
=
>
new
WeakMap
(
)
)
;
class
PanelPopup
extends
BasePopup
{
constructor
(
extension
imageNode
popupURL
browserStyle
)
{
let
document
=
imageNode
.
ownerDocument
;
let
panel
=
document
.
createElement
(
"
panel
"
)
;
panel
.
setAttribute
(
"
id
"
makeWidgetId
(
extension
.
id
)
+
"
-
panel
"
)
;
panel
.
setAttribute
(
"
class
"
"
browser
-
extension
-
panel
"
)
;
panel
.
setAttribute
(
"
tabspecific
"
"
true
"
)
;
panel
.
setAttribute
(
"
type
"
"
arrow
"
)
;
panel
.
setAttribute
(
"
role
"
"
group
"
)
;
document
.
getElementById
(
"
mainPopupSet
"
)
.
appendChild
(
panel
)
;
super
(
extension
panel
popupURL
browserStyle
)
;
this
.
contentReady
.
then
(
(
)
=
>
{
panel
.
openPopup
(
imageNode
"
bottomcenter
topright
"
0
0
false
false
)
;
let
event
=
new
this
.
window
.
CustomEvent
(
"
WebExtPopupLoaded
"
{
bubbles
:
true
detail
:
{
extension
}
}
)
;
this
.
browser
.
dispatchEvent
(
event
)
;
}
)
;
}
get
DESTROY_EVENT
(
)
{
return
"
popuphidden
"
;
}
destroy
(
)
{
super
.
destroy
(
)
;
this
.
viewNode
.
remove
(
)
;
this
.
viewNode
=
null
;
}
closePopup
(
)
{
promisePopupShown
(
this
.
viewNode
)
.
then
(
(
)
=
>
{
if
(
this
.
viewNode
&
&
this
.
viewNode
.
hidePopup
)
{
this
.
viewNode
.
hidePopup
(
)
;
}
}
)
;
}
}
class
ViewPopup
extends
BasePopup
{
constructor
(
extension
window
popupURL
browserStyle
fixedWidth
)
{
let
document
=
window
.
document
;
let
panel
=
document
.
createElement
(
"
panel
"
)
;
panel
.
setAttribute
(
"
type
"
"
arrow
"
)
;
document
.
getElementById
(
"
mainPopupSet
"
)
.
appendChild
(
panel
)
;
super
(
extension
panel
popupURL
browserStyle
fixedWidth
)
;
this
.
ignoreResizes
=
true
;
this
.
attached
=
false
;
this
.
shown
=
false
;
this
.
tempPanel
=
panel
;
this
.
browser
.
classList
.
add
(
"
webextension
-
preload
-
browser
"
)
;
}
attach
(
viewNode
)
{
return
Task
.
spawn
(
function
*
(
)
{
this
.
viewNode
=
viewNode
;
this
.
viewNode
.
addEventListener
(
this
.
DESTROY_EVENT
this
)
;
yield
Promise
.
all
(
[
this
.
browserReady
Promise
.
race
(
[
this
.
browserLoaded
.
catch
(
(
)
=
>
{
}
)
new
Promise
(
resolve
=
>
setTimeout
(
resolve
POPUP_LOAD_TIMEOUT_MS
)
)
]
)
]
)
;
if
(
!
this
.
destroyed
&
&
!
this
.
panel
)
{
this
.
destroy
(
)
;
}
if
(
this
.
destroyed
)
{
CustomizableUI
.
hidePanelForNode
(
viewNode
)
;
return
false
;
}
this
.
attached
=
true
;
this
.
viewHeight
=
this
.
viewNode
.
boxObject
.
height
;
let
popupRect
=
this
.
panel
.
getBoundingClientRect
(
)
;
this
.
setBackground
(
this
.
background
)
;
let
win
=
this
.
window
;
let
popupBottom
=
win
.
mozInnerScreenY
+
popupRect
.
bottom
;
let
popupTop
=
win
.
mozInnerScreenY
+
popupRect
.
top
;
let
screenBottom
=
win
.
screen
.
availTop
+
win
.
screen
.
availHeight
;
this
.
extraHeight
=
{
bottom
:
Math
.
max
(
0
screenBottom
-
popupBottom
)
top
:
Math
.
max
(
0
popupTop
-
win
.
screen
.
availTop
)
}
;
let
browser
=
this
.
browser
;
yield
this
.
createBrowser
(
this
.
viewNode
)
;
this
.
ignoreResizes
=
false
;
this
.
browser
.
swapDocShells
(
browser
)
;
this
.
destroyBrowser
(
browser
)
;
if
(
this
.
dimensions
&
&
!
this
.
fixedWidth
)
{
this
.
resizeBrowser
(
this
.
dimensions
)
;
}
this
.
tempPanel
.
remove
(
)
;
this
.
tempPanel
=
null
;
this
.
shown
=
true
;
if
(
this
.
destroyed
)
{
this
.
closePopup
(
)
;
this
.
destroy
(
)
;
return
false
;
}
let
event
=
new
this
.
window
.
CustomEvent
(
"
WebExtPopupLoaded
"
{
bubbles
:
true
detail
:
{
extension
:
this
.
extension
}
}
)
;
this
.
browser
.
dispatchEvent
(
event
)
;
return
true
;
}
.
bind
(
this
)
)
;
}
destroy
(
)
{
return
super
.
destroy
(
)
.
then
(
(
)
=
>
{
if
(
this
.
tempPanel
)
{
this
.
tempPanel
.
remove
(
)
;
this
.
tempPanel
=
null
;
}
}
)
;
}
get
DESTROY_EVENT
(
)
{
return
"
ViewHiding
"
;
}
closePopup
(
)
{
if
(
this
.
shown
)
{
CustomizableUI
.
hidePanelForNode
(
this
.
viewNode
)
;
}
else
if
(
this
.
attached
)
{
this
.
destroyed
=
true
;
}
else
{
this
.
destroy
(
)
;
}
}
}
