"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
gDevTools
"
"
resource
:
/
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
const
{
HiddenExtensionPage
watchExtensionProxyContextLoad
}
=
ExtensionParent
;
let
devtoolsPageDefinitionMap
=
new
Map
(
)
;
global
.
getDevToolsTargetForContext
=
(
context
)
=
>
{
return
Task
.
spawn
(
function
*
asyncGetTabTarget
(
)
{
if
(
context
.
devToolsTarget
)
{
return
context
.
devToolsTarget
;
}
if
(
!
context
.
devToolsToolbox
|
|
!
context
.
devToolsToolbox
.
target
)
{
throw
new
Error
(
"
Unable
to
get
a
TabTarget
for
a
context
not
associated
to
any
toolbox
"
)
;
}
if
(
!
context
.
devToolsToolbox
.
target
.
isLocalTab
)
{
throw
new
Error
(
"
Unexpected
target
type
:
only
local
tabs
are
currently
supported
.
"
)
;
}
const
{
TabTarget
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
context
.
devToolsTarget
=
new
TabTarget
(
context
.
devToolsToolbox
.
target
.
tab
)
;
yield
context
.
devToolsTarget
.
makeRemote
(
)
;
return
context
.
devToolsTarget
;
}
)
;
}
;
global
.
getTargetTabIdForToolbox
=
(
toolbox
)
=
>
{
let
{
target
}
=
toolbox
;
if
(
!
target
.
isLocalTab
)
{
throw
new
Error
(
"
Unexpected
target
type
:
only
local
tabs
are
currently
supported
.
"
)
;
}
let
parentWindow
=
target
.
tab
.
linkedBrowser
.
ownerDocument
.
defaultView
;
let
tab
=
parentWindow
.
gBrowser
.
getTabForBrowser
(
target
.
tab
.
linkedBrowser
)
;
return
TabManager
.
getId
(
tab
)
;
}
;
class
DevToolsPage
extends
HiddenExtensionPage
{
constructor
(
extension
options
)
{
super
(
extension
"
devtools_page
"
)
;
this
.
url
=
extension
.
baseURI
.
resolve
(
options
.
url
)
;
this
.
toolbox
=
options
.
toolbox
;
this
.
devToolsPageDefinition
=
options
.
devToolsPageDefinition
;
this
.
unwatchExtensionProxyContextLoad
=
null
;
this
.
waitForTopLevelContext
=
new
Promise
(
resolve
=
>
{
this
.
resolveTopLevelContext
=
resolve
;
}
)
;
}
build
(
)
{
return
Task
.
spawn
(
function
*
(
)
{
yield
this
.
createBrowserElement
(
)
;
this
.
unwatchExtensionProxyContextLoad
=
watchExtensionProxyContextLoad
(
this
context
=
>
{
context
.
devToolsToolbox
=
this
.
toolbox
;
if
(
!
this
.
topLevelContext
)
{
this
.
topLevelContext
=
context
;
this
.
topLevelContext
.
callOnClose
(
this
)
;
this
.
resolveTopLevelContext
(
context
)
;
}
}
)
;
extensions
.
emit
(
"
extension
-
browser
-
inserted
"
this
.
browser
{
devtoolsToolboxInfo
:
{
inspectedWindowTabId
:
getTargetTabIdForToolbox
(
this
.
toolbox
)
}
}
)
;
this
.
browser
.
loadURI
(
this
.
url
)
;
yield
this
.
waitForTopLevelContext
;
}
.
bind
(
this
)
)
;
}
close
(
)
{
if
(
this
.
closed
)
{
throw
new
Error
(
"
Unable
to
shutdown
a
closed
DevToolsPage
instance
"
)
;
}
this
.
closed
=
true
;
this
.
devToolsPageDefinition
.
forgetForTarget
(
this
.
toolbox
.
target
)
;
if
(
this
.
topLevelContext
)
{
this
.
topLevelContext
.
forgetOnClose
(
this
)
;
}
if
(
this
.
unwatchExtensionProxyContextLoad
)
{
this
.
unwatchExtensionProxyContextLoad
(
)
;
this
.
unwatchExtensionProxyContextLoad
=
null
;
}
super
.
shutdown
(
)
;
}
}
class
DevToolsPageDefinition
{
constructor
(
extension
url
)
{
this
.
url
=
url
;
this
.
extension
=
extension
;
this
.
devtoolsPageForTarget
=
new
Map
(
)
;
}
buildForToolbox
(
toolbox
)
{
if
(
this
.
devtoolsPageForTarget
.
has
(
toolbox
.
target
)
)
{
return
Promise
.
reject
(
new
Error
(
"
DevtoolsPage
has
been
already
created
for
this
toolbox
"
)
)
;
}
const
devtoolsPage
=
new
DevToolsPage
(
this
.
extension
{
toolbox
url
:
this
.
url
devToolsPageDefinition
:
this
}
)
;
this
.
devtoolsPageForTarget
.
set
(
toolbox
.
target
devtoolsPage
)
;
return
devtoolsPage
.
build
(
)
;
}
shutdownForTarget
(
target
)
{
if
(
this
.
devtoolsPageForTarget
.
has
(
target
)
)
{
const
devtoolsPage
=
this
.
devtoolsPageForTarget
.
get
(
target
)
;
devtoolsPage
.
close
(
)
;
if
(
this
.
devtoolsPageForTarget
.
has
(
target
)
)
{
throw
new
Error
(
Leaked
DevToolsPage
instance
for
target
"
{
target
.
toString
(
)
}
"
)
;
}
}
}
forgetForTarget
(
target
)
{
this
.
devtoolsPageForTarget
.
delete
(
target
)
;
}
shutdown
(
)
{
for
(
let
target
of
this
.
devtoolsPageForTarget
.
keys
(
)
)
{
this
.
shutdownForTarget
(
target
)
;
}
if
(
this
.
devtoolsPageForTarget
.
size
>
0
)
{
throw
new
Error
(
Leaked
{
this
.
devtoolsPageForTarget
.
size
}
DevToolsPage
instances
in
devtoolsPageForTarget
Map
)
;
}
}
}
gDevTools
.
on
(
"
toolbox
-
created
"
(
evt
toolbox
)
=
>
{
if
(
!
toolbox
.
target
.
isLocalTab
)
{
let
msg
=
Ignoring
DevTools
Toolbox
for
target
"
{
toolbox
.
target
.
toString
(
)
}
"
:
+
"
{
toolbox
.
target
.
name
}
"
(
"
{
toolbox
.
target
.
url
}
"
)
.
+
"
Only
local
tab
are
currently
supported
by
the
WebExtensions
DevTools
API
.
"
;
let
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
init
(
msg
null
null
null
null
Ci
.
nsIScriptError
.
warningFlag
"
content
javascript
"
)
;
let
consoleService
=
Cc
[
"
mozilla
.
org
/
consoleservice
;
1
"
]
.
getService
(
Ci
.
nsIConsoleService
)
;
consoleService
.
logMessage
(
scriptError
)
;
return
;
}
for
(
let
devtoolsPage
of
devtoolsPageDefinitionMap
.
values
(
)
)
{
devtoolsPage
.
buildForToolbox
(
toolbox
)
;
}
}
)
;
gDevTools
.
on
(
"
toolbox
-
destroy
"
(
evt
target
)
=
>
{
if
(
!
target
.
isLocalTab
)
{
return
;
}
for
(
let
devtoolsPageDefinition
of
devtoolsPageDefinitionMap
.
values
(
)
)
{
devtoolsPageDefinition
.
shutdownForTarget
(
target
)
;
}
}
)
;
extensions
.
on
(
"
manifest_devtools_page
"
(
type
directive
extension
manifest
)
=
>
{
let
devtoolsPageDefinition
=
new
DevToolsPageDefinition
(
extension
manifest
[
directive
]
)
;
devtoolsPageDefinitionMap
.
set
(
extension
devtoolsPageDefinition
)
;
}
)
;
extensions
.
on
(
"
shutdown
"
(
type
extension
)
=
>
{
if
(
devtoolsPageDefinitionMap
.
has
(
extension
)
)
{
devtoolsPageDefinitionMap
.
get
(
extension
)
.
shutdown
(
)
;
devtoolsPageDefinitionMap
.
delete
(
extension
)
;
}
}
)
;
