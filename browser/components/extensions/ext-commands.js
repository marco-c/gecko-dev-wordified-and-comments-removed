"
use
strict
"
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
SingletonEventManager
PlatformInfo
}
=
ExtensionUtils
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
var
commandsMap
=
new
WeakMap
(
)
;
function
CommandList
(
manifest
extension
)
{
this
.
extension
=
extension
;
this
.
id
=
makeWidgetId
(
extension
.
id
)
;
this
.
windowOpenListener
=
null
;
this
.
commands
=
this
.
loadCommandsFromManifest
(
manifest
)
;
this
.
keysetsMap
=
new
WeakMap
(
)
;
this
.
register
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
CommandList
.
prototype
=
{
register
(
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
registerKeysToDocument
(
window
)
;
}
this
.
windowOpenListener
=
(
window
)
=
>
{
if
(
!
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
registerKeysToDocument
(
window
)
;
}
}
;
windowTracker
.
addOpenListener
(
this
.
windowOpenListener
)
;
}
unregister
(
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
if
(
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
keysetsMap
.
get
(
window
)
.
remove
(
)
;
}
}
windowTracker
.
removeOpenListener
(
this
.
windowOpenListener
)
;
}
loadCommandsFromManifest
(
manifest
)
{
let
commands
=
new
Map
(
)
;
let
os
=
PlatformInfo
.
os
=
=
"
win
"
?
"
windows
"
:
PlatformInfo
.
os
;
for
(
let
[
name
command
]
of
Object
.
entries
(
manifest
.
commands
)
)
{
let
suggested_key
=
command
.
suggested_key
|
|
{
}
;
let
shortcut
=
suggested_key
[
os
]
|
|
suggested_key
.
default
;
shortcut
=
shortcut
?
shortcut
.
replace
(
/
\
s
+
/
g
"
"
)
:
null
commands
.
set
(
name
{
description
:
command
.
description
shortcut
}
)
;
}
return
commands
;
}
registerKeysToDocument
(
window
)
{
let
doc
=
window
.
document
;
let
keyset
=
doc
.
createElementNS
(
XUL_NS
"
keyset
"
)
;
keyset
.
id
=
ext
-
keyset
-
id
-
{
this
.
id
}
;
this
.
commands
.
forEach
(
(
command
name
)
=
>
{
if
(
command
.
shortcut
)
{
let
keyElement
=
this
.
buildKey
(
doc
name
command
.
shortcut
)
;
keyset
.
appendChild
(
keyElement
)
;
}
}
)
;
doc
.
documentElement
.
appendChild
(
keyset
)
;
this
.
keysetsMap
.
set
(
window
keyset
)
;
}
buildKey
(
doc
name
shortcut
)
{
let
keyElement
=
this
.
buildKeyFromShortcut
(
doc
shortcut
)
;
keyElement
.
setAttribute
(
"
oncommand
"
"
/
/
"
)
;
keyElement
.
addEventListener
(
"
command
"
(
event
)
=
>
{
let
action
;
if
(
name
=
=
"
_execute_page_action
"
)
{
action
=
pageActionFor
(
this
.
extension
)
;
}
else
if
(
name
=
=
"
_execute_browser_action
"
)
{
action
=
browserActionFor
(
this
.
extension
)
;
}
else
if
(
name
=
=
"
_execute_sidebar_action
"
)
{
action
=
sidebarActionFor
(
this
.
extension
)
;
}
else
{
this
.
extension
.
tabManager
.
addActiveTabPermission
(
)
;
this
.
emit
(
"
command
"
name
)
;
return
;
}
if
(
action
)
{
let
win
=
event
.
target
.
ownerGlobal
;
action
.
triggerAction
(
win
)
;
}
}
)
;
return
keyElement
;
}
buildKeyFromShortcut
(
doc
shortcut
)
{
let
keyElement
=
doc
.
createElementNS
(
XUL_NS
"
key
"
)
;
let
parts
=
shortcut
.
split
(
"
+
"
)
;
let
chromeKey
=
parts
.
pop
(
)
;
keyElement
.
setAttribute
(
"
modifiers
"
this
.
getModifiersAttribute
(
parts
)
)
;
if
(
/
^
[
A
-
Z0
-
9
]
/
.
test
(
chromeKey
)
)
{
keyElement
.
setAttribute
(
"
key
"
chromeKey
)
;
}
else
{
keyElement
.
setAttribute
(
"
keycode
"
this
.
getKeycodeAttribute
(
chromeKey
)
)
;
}
return
keyElement
;
}
getKeycodeAttribute
(
chromeKey
)
{
return
VK
{
chromeKey
.
replace
(
/
(
[
A
-
Z
]
)
/
g
"
_
&
"
)
.
toUpperCase
(
)
}
;
}
getModifiersAttribute
(
chromeModifiers
)
{
let
modifiersMap
=
{
"
Alt
"
:
"
alt
"
"
Command
"
:
"
accel
"
"
Ctrl
"
:
"
accel
"
"
MacCtrl
"
:
"
control
"
"
Shift
"
:
"
shift
"
}
;
return
Array
.
from
(
chromeModifiers
modifier
=
>
{
return
modifiersMap
[
modifier
]
;
}
)
.
join
(
"
"
)
;
}
}
;
extensions
.
on
(
"
manifest_commands
"
(
type
directive
extension
manifest
)
=
>
{
commandsMap
.
set
(
extension
new
CommandList
(
manifest
extension
)
)
;
}
)
;
extensions
.
on
(
"
shutdown
"
(
type
extension
)
=
>
{
let
commandsList
=
commandsMap
.
get
(
extension
)
;
if
(
commandsList
)
{
commandsList
.
unregister
(
)
;
commandsMap
.
delete
(
extension
)
;
}
}
)
;
extensions
.
registerSchemaAPI
(
"
commands
"
"
addon_parent
"
context
=
>
{
let
{
extension
}
=
context
;
return
{
commands
:
{
getAll
(
)
{
let
commands
=
commandsMap
.
get
(
extension
)
.
commands
;
return
Promise
.
resolve
(
Array
.
from
(
commands
(
[
name
command
]
)
=
>
{
return
(
{
name
description
:
command
.
description
shortcut
:
command
.
shortcut
}
)
;
}
)
)
;
}
onCommand
:
new
SingletonEventManager
(
context
"
commands
.
onCommand
"
fire
=
>
{
let
listener
=
(
eventName
commandName
)
=
>
{
fire
.
async
(
commandName
)
;
}
;
commandsMap
.
get
(
extension
)
.
on
(
"
command
"
listener
)
;
return
(
)
=
>
{
commandsMap
.
get
(
extension
)
.
off
(
"
command
"
listener
)
;
}
;
}
)
.
api
(
)
}
}
;
}
)
;
