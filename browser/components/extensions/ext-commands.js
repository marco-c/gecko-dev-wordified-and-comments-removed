"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionParent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
var
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
this
.
commands
=
class
extends
ExtensionAPI
{
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
this
.
id
=
makeWidgetId
(
extension
.
id
)
;
this
.
windowOpenListener
=
null
;
this
.
commands
=
this
.
loadCommandsFromManifest
(
this
.
extension
.
manifest
)
;
this
.
keysetsMap
=
new
WeakMap
(
)
;
this
.
register
(
)
;
}
onShutdown
(
reason
)
{
this
.
unregister
(
)
;
}
register
(
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
this
.
registerKeysToDocument
(
window
)
;
}
this
.
windowOpenListener
=
(
window
)
=
>
{
if
(
!
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
registerKeysToDocument
(
window
)
;
}
}
;
windowTracker
.
addOpenListener
(
this
.
windowOpenListener
)
;
}
unregister
(
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
if
(
this
.
keysetsMap
.
has
(
window
)
)
{
this
.
keysetsMap
.
get
(
window
)
.
remove
(
)
;
}
}
windowTracker
.
removeOpenListener
(
this
.
windowOpenListener
)
;
}
loadCommandsFromManifest
(
manifest
)
{
let
commands
=
new
Map
(
)
;
let
{
PlatformInfo
}
=
ExtensionParent
;
let
os
=
PlatformInfo
.
os
=
=
"
win
"
?
"
windows
"
:
PlatformInfo
.
os
;
for
(
let
[
name
command
]
of
Object
.
entries
(
manifest
.
commands
)
)
{
let
suggested_key
=
command
.
suggested_key
|
|
{
}
;
let
shortcut
=
suggested_key
[
os
]
|
|
suggested_key
.
default
;
shortcut
=
shortcut
?
shortcut
.
replace
(
/
\
s
+
/
g
"
"
)
:
null
;
commands
.
set
(
name
{
description
:
command
.
description
shortcut
}
)
;
}
return
commands
;
}
registerKeysToDocument
(
window
)
{
let
doc
=
window
.
document
;
let
keyset
=
doc
.
createElementNS
(
XUL_NS
"
keyset
"
)
;
keyset
.
id
=
ext
-
keyset
-
id
-
{
this
.
id
}
;
this
.
commands
.
forEach
(
(
command
name
)
=
>
{
if
(
command
.
shortcut
)
{
let
keyElement
=
this
.
buildKey
(
doc
name
command
.
shortcut
)
;
keyset
.
appendChild
(
keyElement
)
;
}
}
)
;
doc
.
documentElement
.
appendChild
(
keyset
)
;
this
.
keysetsMap
.
set
(
window
keyset
)
;
}
buildKey
(
doc
name
shortcut
)
{
let
keyElement
=
this
.
buildKeyFromShortcut
(
doc
name
shortcut
)
;
keyElement
.
setAttribute
(
"
oncommand
"
"
/
/
"
)
;
keyElement
.
addEventListener
(
"
command
"
(
event
)
=
>
{
let
action
;
if
(
name
=
=
"
_execute_page_action
"
)
{
action
=
pageActionFor
(
this
.
extension
)
;
}
else
if
(
name
=
=
"
_execute_browser_action
"
)
{
action
=
browserActionFor
(
this
.
extension
)
;
}
else
if
(
name
=
=
"
_execute_sidebar_action
"
)
{
action
=
sidebarActionFor
(
this
.
extension
)
;
}
else
{
this
.
extension
.
tabManager
.
addActiveTabPermission
(
)
;
this
.
emit
(
"
command
"
name
)
;
return
;
}
if
(
action
)
{
let
win
=
event
.
target
.
ownerGlobal
;
action
.
triggerAction
(
win
)
;
}
}
)
;
return
keyElement
;
}
buildKeyFromShortcut
(
doc
name
shortcut
)
{
let
keyElement
=
doc
.
createElementNS
(
XUL_NS
"
key
"
)
;
let
parts
=
shortcut
.
split
(
"
+
"
)
;
let
chromeKey
=
parts
.
pop
(
)
;
keyElement
.
setAttribute
(
"
modifiers
"
this
.
getModifiersAttribute
(
parts
)
)
;
if
(
name
=
=
"
_execute_sidebar_action
"
)
{
let
id
=
ext
-
key
-
id
-
{
this
.
id
}
-
sidebar
-
action
;
keyElement
.
setAttribute
(
"
id
"
id
)
;
}
if
(
/
^
[
A
-
Z
]
/
.
test
(
chromeKey
)
)
{
keyElement
.
setAttribute
(
"
key
"
chromeKey
)
;
}
else
{
keyElement
.
setAttribute
(
"
keycode
"
this
.
getKeycodeAttribute
(
chromeKey
)
)
;
keyElement
.
setAttribute
(
"
event
"
"
keydown
"
)
;
}
return
keyElement
;
}
getKeycodeAttribute
(
chromeKey
)
{
if
(
/
[
0
-
9
]
/
.
test
(
chromeKey
)
)
{
return
VK_
{
chromeKey
}
;
}
return
VK
{
chromeKey
.
replace
(
/
(
[
A
-
Z
]
)
/
g
"
_
&
"
)
.
toUpperCase
(
)
}
;
}
getModifiersAttribute
(
chromeModifiers
)
{
let
modifiersMap
=
{
"
Alt
"
:
"
alt
"
"
Command
"
:
"
accel
"
"
Ctrl
"
:
"
accel
"
"
MacCtrl
"
:
"
control
"
"
Shift
"
:
"
shift
"
}
;
return
Array
.
from
(
chromeModifiers
modifier
=
>
{
return
modifiersMap
[
modifier
]
;
}
)
.
join
(
"
"
)
;
}
getAPI
(
context
)
{
return
{
commands
:
{
getAll
:
(
)
=
>
{
let
commands
=
this
.
commands
;
return
Promise
.
resolve
(
Array
.
from
(
commands
(
[
name
command
]
)
=
>
{
return
(
{
name
description
:
command
.
description
shortcut
:
command
.
shortcut
}
)
;
}
)
)
;
}
onCommand
:
new
EventManager
(
context
"
commands
.
onCommand
"
fire
=
>
{
let
listener
=
(
eventName
commandName
)
=
>
{
fire
.
async
(
commandName
)
;
}
;
this
.
on
(
"
command
"
listener
)
;
return
(
)
=
>
{
this
.
off
(
"
command
"
listener
)
;
}
;
}
)
.
api
(
)
}
}
;
}
}
;
