"
use
strict
"
;
var
{
withHandlingUserInput
}
=
ExtensionCommon
;
var
{
ExtensionError
}
=
ExtensionUtils
;
var
gNextMenuItemID
=
0
;
var
gPropHandlers
=
new
Map
(
)
;
class
ContextMenusClickPropHandler
{
constructor
(
context
)
{
this
.
context
=
context
;
this
.
onclickMap
=
new
Map
(
)
;
this
.
dispatchEvent
=
this
.
dispatchEvent
.
bind
(
this
)
;
}
dispatchEvent
(
info
tab
)
{
let
onclick
=
this
.
onclickMap
.
get
(
info
.
menuItemId
)
;
if
(
onclick
)
{
withHandlingUserInput
(
this
.
context
.
contentWindow
(
)
=
>
onclick
(
info
tab
)
)
;
}
}
setListener
(
id
onclick
)
{
if
(
this
.
onclickMap
.
size
=
=
=
0
)
{
this
.
context
.
childManager
.
getParentEvent
(
"
menusInternal
.
onClicked
"
)
.
addListener
(
this
.
dispatchEvent
)
;
this
.
context
.
callOnClose
(
this
)
;
}
this
.
onclickMap
.
set
(
id
onclick
)
;
let
propHandlerMap
=
gPropHandlers
.
get
(
this
.
context
.
extension
)
;
if
(
!
propHandlerMap
)
{
propHandlerMap
=
new
Map
(
)
;
}
else
{
let
propHandler
=
propHandlerMap
.
get
(
id
)
;
if
(
propHandler
&
&
propHandler
!
=
=
this
)
{
propHandler
.
unsetListener
(
id
)
;
}
}
propHandlerMap
.
set
(
id
this
)
;
gPropHandlers
.
set
(
this
.
context
.
extension
propHandlerMap
)
;
}
unsetListener
(
id
)
{
if
(
!
this
.
onclickMap
.
delete
(
id
)
)
{
return
;
}
if
(
this
.
onclickMap
.
size
=
=
=
0
)
{
this
.
context
.
childManager
.
getParentEvent
(
"
menusInternal
.
onClicked
"
)
.
removeListener
(
this
.
dispatchEvent
)
;
this
.
context
.
forgetOnClose
(
this
)
;
}
let
propHandlerMap
=
gPropHandlers
.
get
(
this
.
context
.
extension
)
;
propHandlerMap
.
delete
(
id
)
;
if
(
propHandlerMap
.
size
=
=
=
0
)
{
gPropHandlers
.
delete
(
this
.
context
.
extension
)
;
}
}
unsetListenerFromAnyContext
(
id
)
{
let
propHandlerMap
=
gPropHandlers
.
get
(
this
.
context
.
extension
)
;
let
propHandler
=
propHandlerMap
&
&
propHandlerMap
.
get
(
id
)
;
if
(
propHandler
)
{
propHandler
.
unsetListener
(
id
)
;
}
}
deleteAllListenersFromExtension
(
)
{
let
propHandlerMap
=
gPropHandlers
.
get
(
this
.
context
.
extension
)
;
if
(
propHandlerMap
)
{
for
(
let
[
id
propHandler
]
of
propHandlerMap
)
{
propHandler
.
unsetListener
(
id
)
;
}
}
}
close
(
)
{
for
(
let
id
of
this
.
onclickMap
.
keys
(
)
)
{
this
.
unsetListener
(
id
)
;
}
}
}
this
.
menusInternal
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
let
{
extension
}
=
context
;
let
onClickedProp
=
new
ContextMenusClickPropHandler
(
context
)
;
let
pendingMenuEvent
;
let
api
=
{
menus
:
{
create
(
createProperties
callback
)
{
let
caller
=
context
.
getCaller
(
)
;
if
(
extension
.
persistentBackground
&
&
createProperties
.
id
=
=
=
null
)
{
createProperties
.
id
=
+
+
gNextMenuItemID
;
}
let
{
onclick
}
=
createProperties
;
if
(
onclick
&
&
!
context
.
extension
.
persistentBackground
)
{
throw
new
ExtensionError
(
Property
"
onclick
"
cannot
be
used
in
menus
.
create
replace
with
an
"
onClicked
"
event
listener
.
)
;
}
delete
createProperties
.
onclick
;
context
.
childManager
.
callParentAsyncFunction
(
"
menusInternal
.
create
"
[
createProperties
]
)
.
then
(
(
)
=
>
{
if
(
onclick
)
{
onClickedProp
.
setListener
(
createProperties
.
id
onclick
)
;
}
if
(
callback
)
{
context
.
runSafeWithoutClone
(
callback
)
;
}
}
)
.
catch
(
error
=
>
{
context
.
withLastError
(
error
caller
(
)
=
>
{
if
(
callback
)
{
context
.
runSafeWithoutClone
(
callback
)
;
}
}
)
;
}
)
;
return
createProperties
.
id
;
}
update
(
id
updateProperties
)
{
let
{
onclick
}
=
updateProperties
;
if
(
onclick
&
&
!
context
.
extension
.
persistentBackground
)
{
throw
new
ExtensionError
(
Property
"
onclick
"
cannot
be
used
in
menus
.
update
replace
with
an
"
onClicked
"
event
listener
.
)
;
}
delete
updateProperties
.
onclick
;
return
context
.
childManager
.
callParentAsyncFunction
(
"
menusInternal
.
update
"
[
id
updateProperties
]
)
.
then
(
(
)
=
>
{
if
(
onclick
)
{
onClickedProp
.
setListener
(
id
onclick
)
;
}
else
if
(
onclick
=
=
=
null
)
{
onClickedProp
.
unsetListenerFromAnyContext
(
id
)
;
}
}
)
;
}
remove
(
id
)
{
onClickedProp
.
unsetListenerFromAnyContext
(
id
)
;
return
context
.
childManager
.
callParentAsyncFunction
(
"
menusInternal
.
remove
"
[
id
]
)
;
}
removeAll
(
)
{
onClickedProp
.
deleteAllListenersFromExtension
(
)
;
return
context
.
childManager
.
callParentAsyncFunction
(
"
menusInternal
.
removeAll
"
[
]
)
;
}
overrideContext
(
contextOptions
)
{
let
checkValidArg
=
(
contextType
propKey
)
=
>
{
if
(
contextOptions
.
context
!
=
=
contextType
)
{
if
(
contextOptions
[
propKey
]
)
{
throw
new
ExtensionError
(
Property
"
{
propKey
}
"
can
only
be
used
with
context
"
{
contextType
}
"
)
;
}
return
false
;
}
if
(
contextOptions
.
showDefaults
)
{
throw
new
ExtensionError
(
Property
"
showDefaults
"
cannot
be
used
with
context
"
{
contextType
}
"
)
;
}
if
(
!
contextOptions
[
propKey
]
)
{
throw
new
ExtensionError
(
Property
"
{
propKey
}
"
is
required
for
context
"
{
contextType
}
"
)
;
}
return
true
;
}
;
if
(
checkValidArg
(
"
tab
"
"
tabId
"
)
)
{
if
(
!
context
.
extension
.
hasPermission
(
"
tabs
"
)
)
{
throw
new
ExtensionError
(
The
"
tab
"
context
requires
the
"
tabs
"
permission
.
)
;
}
}
if
(
checkValidArg
(
"
bookmark
"
"
bookmarkId
"
)
)
{
if
(
!
context
.
extension
.
hasPermission
(
"
bookmarks
"
)
)
{
throw
new
ExtensionError
(
The
"
bookmark
"
context
requires
the
"
bookmarks
"
permission
.
)
;
}
}
let
webExtContextData
=
{
extensionId
:
context
.
extension
.
id
showDefaults
:
contextOptions
.
showDefaults
overrideContext
:
contextOptions
.
context
bookmarkId
:
contextOptions
.
bookmarkId
tabId
:
contextOptions
.
tabId
}
;
if
(
pendingMenuEvent
)
{
pendingMenuEvent
.
webExtContextData
=
webExtContextData
;
return
;
}
pendingMenuEvent
=
{
webExtContextData
observe
(
subject
topic
data
)
{
pendingMenuEvent
=
null
;
Services
.
obs
.
removeObserver
(
this
"
on
-
prepare
-
contextmenu
"
)
;
subject
=
subject
.
wrappedJSObject
;
if
(
context
.
principal
.
subsumes
(
subject
.
context
.
principal
)
)
{
subject
.
webExtContextData
=
this
.
webExtContextData
;
}
}
run
(
)
{
if
(
pendingMenuEvent
=
=
=
this
)
{
pendingMenuEvent
=
null
;
Services
.
obs
.
removeObserver
(
this
"
on
-
prepare
-
contextmenu
"
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
pendingMenuEvent
"
on
-
prepare
-
contextmenu
"
)
;
Services
.
tm
.
dispatchToMainThread
(
pendingMenuEvent
)
;
}
onClicked
:
new
EventManager
(
{
context
name
:
"
menus
.
onClicked
"
register
:
fire
=
>
{
let
listener
=
(
info
tab
)
=
>
{
withHandlingUserInput
(
context
.
contentWindow
(
)
=
>
fire
.
sync
(
info
tab
)
)
;
}
;
let
event
=
context
.
childManager
.
getParentEvent
(
"
menusInternal
.
onClicked
"
)
;
event
.
addListener
(
listener
)
;
return
(
)
=
>
{
event
.
removeListener
(
listener
)
;
}
;
}
}
)
.
api
(
)
}
}
;
const
result
=
{
}
;
if
(
context
.
extension
.
hasPermission
(
"
menus
"
)
)
{
result
.
menus
=
api
.
menus
;
}
if
(
context
.
extension
.
hasPermission
(
"
contextMenus
"
)
)
{
result
.
contextMenus
=
api
.
menus
;
}
return
result
;
}
}
;
