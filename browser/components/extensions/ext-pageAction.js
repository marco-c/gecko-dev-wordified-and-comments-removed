"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
PageActions
"
"
resource
:
/
/
/
modules
/
PageActions
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PanelPopup
"
"
resource
:
/
/
/
modules
/
ExtensionPopups
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryStopwatch
"
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
var
{
IconDetails
StartupCache
}
=
ExtensionParent
;
const
popupOpenTimingHistogram
=
"
WEBEXT_PAGEACTION_POPUP_OPEN_MS
"
;
let
pageActionMap
=
new
WeakMap
(
)
;
this
.
pageAction
=
class
extends
ExtensionAPI
{
static
for
(
extension
)
{
return
pageActionMap
.
get
(
extension
)
;
}
async
onManifestEntry
(
entryName
)
{
let
{
extension
}
=
this
;
let
options
=
extension
.
manifest
.
page_action
;
let
widgetId
=
makeWidgetId
(
extension
.
id
)
;
this
.
id
=
widgetId
+
"
-
page
-
action
"
;
this
.
tabManager
=
extension
.
tabManager
;
let
show
showMatches
hideMatches
;
let
show_matches
=
options
.
show_matches
|
|
[
]
;
let
hide_matches
=
options
.
hide_matches
|
|
[
]
;
if
(
!
show_matches
.
length
)
{
show
=
false
;
}
else
{
showMatches
=
new
MatchPatternSet
(
show_matches
)
;
hideMatches
=
new
MatchPatternSet
(
hide_matches
)
;
}
this
.
defaults
=
{
show
showMatches
hideMatches
title
:
options
.
default_title
|
|
extension
.
name
popup
:
options
.
default_popup
|
|
"
"
}
;
this
.
browserStyle
=
options
.
browser_style
|
|
false
;
if
(
options
.
browser_style
=
=
=
null
)
{
this
.
extension
.
logger
.
warn
(
"
Please
specify
whether
you
want
browser_style
"
+
"
or
not
in
your
page_action
options
.
"
)
;
}
this
.
tabContext
=
new
TabContext
(
tab
=
>
Object
.
create
(
this
.
defaults
)
extension
)
;
this
.
tabContext
.
on
(
"
location
-
change
"
this
.
handleLocationChange
.
bind
(
this
)
)
;
pageActionMap
.
set
(
extension
this
)
;
this
.
defaults
.
icon
=
await
StartupCache
.
get
(
extension
[
"
pageAction
"
"
default_icon
"
]
(
)
=
>
IconDetails
.
normalize
(
{
path
:
options
.
default_icon
}
extension
)
)
;
if
(
!
this
.
browserPageAction
)
{
this
.
browserPageAction
=
PageActions
.
addAction
(
new
PageActions
.
Action
(
{
id
:
widgetId
extensionID
:
extension
.
id
title
:
this
.
defaults
.
title
iconURL
:
this
.
getIconData
(
this
.
defaults
.
icon
)
pinnedToUrlbar
:
true
disabled
:
!
this
.
defaults
.
show
onCommand
:
(
event
buttonNode
)
=
>
{
this
.
handleClick
(
event
.
target
.
ownerGlobal
)
;
}
onBeforePlacedInWindow
:
browserWindow
=
>
{
if
(
this
.
extension
.
hasPermission
(
"
menus
"
)
|
|
this
.
extension
.
hasPermission
(
"
contextMenus
"
)
)
{
browserWindow
.
document
.
addEventListener
(
"
popupshowing
"
this
)
;
}
}
onRemovedFromWindow
:
browserWindow
=
>
{
browserWindow
.
document
.
removeEventListener
(
"
popupshowing
"
this
)
;
}
}
)
)
;
if
(
show
=
=
=
undefined
)
{
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
let
tab
=
window
.
gBrowser
.
selectedTab
;
if
(
this
.
isShown
(
tab
)
)
{
this
.
updateButton
(
window
)
;
}
}
}
}
}
onShutdown
(
reason
)
{
pageActionMap
.
delete
(
this
.
extension
)
;
this
.
tabContext
.
shutdown
(
)
;
if
(
reason
!
=
"
APP_SHUTDOWN
"
&
&
this
.
browserPageAction
)
{
this
.
browserPageAction
.
remove
(
)
;
this
.
browserPageAction
=
null
;
}
}
getProperty
(
tab
prop
)
{
return
this
.
tabContext
.
get
(
tab
)
[
prop
]
;
}
setProperty
(
tab
prop
value
)
{
if
(
value
!
=
null
)
{
this
.
tabContext
.
get
(
tab
)
[
prop
]
=
value
;
}
else
{
delete
this
.
tabContext
.
get
(
tab
)
[
prop
]
;
}
if
(
tab
.
selected
)
{
this
.
updateButton
(
tab
.
ownerGlobal
)
;
}
}
updateButton
(
window
)
{
let
tab
=
window
.
gBrowser
.
selectedTab
;
let
tabData
=
this
.
tabContext
.
get
(
tab
)
;
let
title
=
tabData
.
title
|
|
this
.
extension
.
name
;
this
.
browserPageAction
.
setTitle
(
title
window
)
;
this
.
browserPageAction
.
setTooltip
(
title
window
)
;
let
{
show
=
tabData
.
patternMatching
}
=
tabData
;
this
.
browserPageAction
.
setDisabled
(
!
show
window
)
;
let
iconURL
;
if
(
typeof
(
tabData
.
icon
)
=
=
"
string
"
)
{
iconURL
=
IconDetails
.
escapeUrl
(
tabData
.
icon
)
;
}
else
{
iconURL
=
this
.
getIconData
(
tabData
.
icon
)
;
}
this
.
browserPageAction
.
setIconURL
(
iconURL
window
)
;
}
isShown
(
tab
)
{
let
tabData
=
this
.
tabContext
.
get
(
tab
)
;
if
(
tabData
.
show
!
=
=
undefined
)
{
return
tabData
.
show
;
}
if
(
tabData
.
patternMatching
=
=
=
undefined
)
{
let
uri
=
tab
.
linkedBrowser
.
currentURI
;
tabData
.
patternMatching
=
tabData
.
showMatches
.
matches
(
uri
)
&
&
!
tabData
.
hideMatches
.
matches
(
uri
)
;
}
return
tabData
.
patternMatching
;
}
getIconData
(
icons
)
{
let
getIcon
=
size
=
>
{
let
{
icon
}
=
IconDetails
.
getPreferredIcon
(
icons
this
.
extension
size
)
;
return
IconDetails
.
escapeUrl
(
icon
)
;
}
;
return
{
"
16
"
:
getIcon
(
16
)
"
32
"
:
getIcon
(
32
)
}
;
}
triggerAction
(
window
)
{
let
pageAction
=
pageActionMap
.
get
(
this
.
extension
)
;
if
(
pageAction
.
getProperty
(
window
.
gBrowser
.
selectedTab
"
show
"
)
)
{
pageAction
.
handleClick
(
window
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
popupshowing
"
:
const
menu
=
event
.
target
;
const
trigger
=
menu
.
triggerNode
;
if
(
menu
.
id
=
=
=
"
pageActionContextMenu
"
&
&
trigger
&
&
trigger
.
getAttribute
(
"
actionid
"
)
=
=
=
this
.
browserPageAction
.
id
&
&
!
this
.
browserPageAction
.
getDisabled
(
trigger
.
ownerGlobal
)
)
{
global
.
actionContextMenu
(
{
extension
:
this
.
extension
onPageAction
:
true
menu
:
menu
}
)
;
}
break
;
}
}
async
handleClick
(
window
)
{
TelemetryStopwatch
.
start
(
popupOpenTimingHistogram
this
)
;
let
tab
=
window
.
gBrowser
.
selectedTab
;
let
popupURL
=
this
.
tabContext
.
get
(
tab
)
.
popup
;
this
.
tabManager
.
addActiveTabPermission
(
tab
)
;
if
(
popupURL
)
{
let
popup
=
new
PanelPopup
(
this
.
extension
window
.
document
popupURL
this
.
browserStyle
)
;
await
popup
.
contentReady
;
window
.
BrowserPageActions
.
togglePanelForAction
(
this
.
browserPageAction
popup
.
panel
)
;
TelemetryStopwatch
.
finish
(
popupOpenTimingHistogram
this
)
;
}
else
{
TelemetryStopwatch
.
cancel
(
popupOpenTimingHistogram
this
)
;
this
.
emit
(
"
click
"
tab
)
;
}
}
handleLocationChange
(
eventType
tab
fromBrowse
)
{
if
(
fromBrowse
=
=
=
true
)
{
this
.
tabContext
.
clear
(
tab
)
;
}
else
if
(
fromBrowse
=
=
=
false
)
{
let
tabData
=
this
.
tabContext
.
get
(
tab
)
;
if
(
tabData
.
patternMatching
!
=
=
undefined
)
{
tabData
.
patternMatching
=
undefined
;
}
}
if
(
tab
.
selected
)
{
this
.
isShown
(
tab
)
;
this
.
updateButton
(
tab
.
ownerGlobal
)
;
}
}
getAPI
(
context
)
{
let
{
extension
}
=
context
;
const
{
tabManager
}
=
extension
;
const
pageAction
=
this
;
return
{
pageAction
:
{
onClicked
:
new
InputEventManager
(
context
"
pageAction
.
onClicked
"
fire
=
>
{
let
listener
=
(
evt
tab
)
=
>
{
context
.
withPendingBrowser
(
tab
.
linkedBrowser
(
)
=
>
fire
.
sync
(
tabManager
.
convert
(
tab
)
)
)
;
}
;
pageAction
.
on
(
"
click
"
listener
)
;
return
(
)
=
>
{
pageAction
.
off
(
"
click
"
listener
)
;
}
;
}
)
.
api
(
)
show
(
tabId
)
{
let
tab
=
tabTracker
.
getTab
(
tabId
)
;
pageAction
.
setProperty
(
tab
"
show
"
true
)
;
}
hide
(
tabId
)
{
let
tab
=
tabTracker
.
getTab
(
tabId
)
;
pageAction
.
setProperty
(
tab
"
show
"
false
)
;
}
isShown
(
details
)
{
let
tab
=
tabTracker
.
getTab
(
details
.
tabId
)
;
return
pageAction
.
isShown
(
tab
)
;
}
setTitle
(
details
)
{
let
tab
=
tabTracker
.
getTab
(
details
.
tabId
)
;
pageAction
.
setProperty
(
tab
"
title
"
details
.
title
)
;
}
getTitle
(
details
)
{
let
tab
=
tabTracker
.
getTab
(
details
.
tabId
)
;
let
title
=
pageAction
.
getProperty
(
tab
"
title
"
)
;
return
Promise
.
resolve
(
title
)
;
}
setIcon
(
details
)
{
let
tab
=
tabTracker
.
getTab
(
details
.
tabId
)
;
let
icon
=
IconDetails
.
normalize
(
details
extension
context
)
;
if
(
!
Object
.
keys
(
icon
)
.
length
)
{
icon
=
null
;
}
pageAction
.
setProperty
(
tab
"
icon
"
icon
)
;
}
setPopup
(
details
)
{
let
tab
=
tabTracker
.
getTab
(
details
.
tabId
)
;
let
url
=
details
.
popup
&
&
context
.
uri
.
resolve
(
details
.
popup
)
;
if
(
url
&
&
!
context
.
checkLoadURL
(
url
)
)
{
return
Promise
.
reject
(
{
message
:
Access
denied
for
URL
{
url
}
}
)
;
}
pageAction
.
setProperty
(
tab
"
popup
"
url
)
;
}
getPopup
(
details
)
{
let
tab
=
tabTracker
.
getTab
(
details
.
tabId
)
;
let
popup
=
pageAction
.
getProperty
(
tab
"
popup
"
)
;
return
Promise
.
resolve
(
popup
)
;
}
openPopup
:
function
(
)
{
let
window
=
windowTracker
.
topWindow
;
pageAction
.
triggerAction
(
window
)
;
}
}
}
;
}
}
;
global
.
pageActionFor
=
this
.
pageAction
.
for
;
