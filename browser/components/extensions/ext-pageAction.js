"
use
strict
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
EventManager
IconDetails
}
=
ExtensionUtils
;
var
pageActionMap
=
new
WeakMap
(
)
;
function
PageAction
(
options
extension
)
{
this
.
extension
=
extension
;
this
.
id
=
makeWidgetId
(
extension
.
id
)
+
"
-
page
-
action
"
;
this
.
tabManager
=
TabManager
.
for
(
extension
)
;
this
.
defaults
=
{
show
:
false
title
:
options
.
default_title
|
|
extension
.
name
icon
:
IconDetails
.
normalize
(
{
path
:
options
.
default_icon
}
extension
)
popup
:
options
.
default_popup
|
|
"
"
}
;
this
.
browserStyle
=
options
.
browser_style
|
|
false
;
if
(
options
.
browser_style
=
=
=
null
)
{
this
.
extension
.
logger
.
warn
(
"
Please
specify
whether
you
want
browser_style
"
+
"
or
not
in
your
page_action
options
.
"
)
;
}
this
.
tabContext
=
new
TabContext
(
tab
=
>
Object
.
create
(
this
.
defaults
)
extension
)
;
this
.
tabContext
.
on
(
"
location
-
change
"
this
.
handleLocationChange
.
bind
(
this
)
)
;
this
.
buttons
=
new
WeakMap
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
PageAction
.
prototype
=
{
getProperty
(
tab
prop
)
{
return
this
.
tabContext
.
get
(
tab
)
[
prop
]
;
}
setProperty
(
tab
prop
value
)
{
if
(
value
!
=
null
)
{
this
.
tabContext
.
get
(
tab
)
[
prop
]
=
value
;
}
else
{
delete
this
.
tabContext
.
get
(
tab
)
[
prop
]
;
}
if
(
tab
.
selected
)
{
this
.
updateButton
(
tab
.
ownerGlobal
)
;
}
}
updateButton
(
window
)
{
let
tabData
=
this
.
tabContext
.
get
(
window
.
gBrowser
.
selectedTab
)
;
if
(
!
(
tabData
.
show
|
|
this
.
buttons
.
has
(
window
)
)
)
{
return
;
}
let
button
=
this
.
getButton
(
window
)
;
if
(
tabData
.
show
)
{
let
title
=
tabData
.
title
|
|
this
.
extension
.
name
;
button
.
setAttribute
(
"
tooltiptext
"
title
)
;
button
.
setAttribute
(
"
aria
-
label
"
title
)
;
let
escape
=
str
=
>
str
.
replace
(
/
[
\
\
\
s
"
]
/
g
encodeURIComponent
)
;
let
getIcon
=
size
=
>
escape
(
IconDetails
.
getPreferredIcon
(
tabData
.
icon
this
.
extension
size
)
.
icon
)
;
button
.
setAttribute
(
"
style
"
-
-
webextension
-
urlbar
-
image
:
url
(
"
{
getIcon
(
16
)
}
"
)
;
-
-
webextension
-
urlbar
-
image
-
2x
:
url
(
"
{
getIcon
(
32
)
}
"
)
;
)
;
button
.
classList
.
add
(
"
webextension
-
page
-
action
"
)
;
}
button
.
hidden
=
!
tabData
.
show
;
}
addButton
(
window
)
{
let
document
=
window
.
document
;
let
button
=
document
.
createElement
(
"
image
"
)
;
button
.
id
=
this
.
id
;
button
.
setAttribute
(
"
class
"
"
urlbar
-
icon
"
)
;
button
.
addEventListener
(
"
click
"
event
=
>
{
if
(
event
.
button
=
=
0
)
{
this
.
handleClick
(
window
)
;
}
}
)
;
document
.
getElementById
(
"
urlbar
-
icons
"
)
.
appendChild
(
button
)
;
return
button
;
}
getButton
(
window
)
{
if
(
!
this
.
buttons
.
has
(
window
)
)
{
let
button
=
this
.
addButton
(
window
)
;
this
.
buttons
.
set
(
window
button
)
;
}
return
this
.
buttons
.
get
(
window
)
;
}
triggerAction
(
window
)
{
let
pageAction
=
pageActionMap
.
get
(
this
.
extension
)
;
if
(
pageAction
.
getProperty
(
window
.
gBrowser
.
selectedTab
"
show
"
)
)
{
pageAction
.
handleClick
(
window
)
;
}
}
handleClick
(
window
)
{
let
tab
=
window
.
gBrowser
.
selectedTab
;
let
popupURL
=
this
.
tabContext
.
get
(
tab
)
.
popup
;
this
.
tabManager
.
addActiveTabPermission
(
tab
)
;
if
(
popupURL
)
{
new
PanelPopup
(
this
.
extension
this
.
getButton
(
window
)
popupURL
this
.
browserStyle
)
;
}
else
{
this
.
emit
(
"
click
"
tab
)
;
}
}
handleLocationChange
(
eventType
tab
fromBrowse
)
{
if
(
fromBrowse
)
{
this
.
tabContext
.
clear
(
tab
)
;
}
this
.
updateButton
(
tab
.
ownerGlobal
)
;
}
shutdown
(
)
{
this
.
tabContext
.
shutdown
(
)
;
for
(
let
window
of
WindowListManager
.
browserWindows
(
)
)
{
if
(
this
.
buttons
.
has
(
window
)
)
{
this
.
buttons
.
get
(
window
)
.
remove
(
)
;
}
}
}
}
;
extensions
.
on
(
"
manifest_page_action
"
(
type
directive
extension
manifest
)
=
>
{
let
pageAction
=
new
PageAction
(
manifest
.
page_action
extension
)
;
pageActionMap
.
set
(
extension
pageAction
)
;
}
)
;
extensions
.
on
(
"
shutdown
"
(
type
extension
)
=
>
{
if
(
pageActionMap
.
has
(
extension
)
)
{
pageActionMap
.
get
(
extension
)
.
shutdown
(
)
;
pageActionMap
.
delete
(
extension
)
;
}
}
)
;
PageAction
.
for
=
extension
=
>
{
return
pageActionMap
.
get
(
extension
)
;
}
;
global
.
pageActionFor
=
PageAction
.
for
;
extensions
.
registerSchemaAPI
(
"
pageAction
"
"
addon_parent
"
context
=
>
{
let
{
extension
}
=
context
;
return
{
pageAction
:
{
onClicked
:
new
EventManager
(
context
"
pageAction
.
onClicked
"
fire
=
>
{
let
listener
=
(
evt
tab
)
=
>
{
fire
(
TabManager
.
convert
(
extension
tab
)
)
;
}
;
let
pageAction
=
PageAction
.
for
(
extension
)
;
pageAction
.
on
(
"
click
"
listener
)
;
return
(
)
=
>
{
pageAction
.
off
(
"
click
"
listener
)
;
}
;
}
)
.
api
(
)
show
(
tabId
)
{
let
tab
=
TabManager
.
getTab
(
tabId
context
)
;
PageAction
.
for
(
extension
)
.
setProperty
(
tab
"
show
"
true
)
;
}
hide
(
tabId
)
{
let
tab
=
TabManager
.
getTab
(
tabId
context
)
;
PageAction
.
for
(
extension
)
.
setProperty
(
tab
"
show
"
false
)
;
}
setTitle
(
details
)
{
let
tab
=
TabManager
.
getTab
(
details
.
tabId
context
)
;
PageAction
.
for
(
extension
)
.
setProperty
(
tab
"
title
"
details
.
title
|
|
null
)
;
}
getTitle
(
details
)
{
let
tab
=
TabManager
.
getTab
(
details
.
tabId
context
)
;
let
title
=
PageAction
.
for
(
extension
)
.
getProperty
(
tab
"
title
"
)
;
return
Promise
.
resolve
(
title
)
;
}
setIcon
(
details
)
{
let
tab
=
TabManager
.
getTab
(
details
.
tabId
context
)
;
let
icon
=
IconDetails
.
normalize
(
details
extension
context
)
;
PageAction
.
for
(
extension
)
.
setProperty
(
tab
"
icon
"
icon
)
;
}
setPopup
(
details
)
{
let
tab
=
TabManager
.
getTab
(
details
.
tabId
context
)
;
let
url
=
details
.
popup
&
&
context
.
uri
.
resolve
(
details
.
popup
)
;
PageAction
.
for
(
extension
)
.
setProperty
(
tab
"
popup
"
url
)
;
}
getPopup
(
details
)
{
let
tab
=
TabManager
.
getTab
(
details
.
tabId
context
)
;
let
popup
=
PageAction
.
for
(
extension
)
.
getProperty
(
tab
"
popup
"
)
;
return
Promise
.
resolve
(
popup
)
;
}
}
}
;
}
)
;
