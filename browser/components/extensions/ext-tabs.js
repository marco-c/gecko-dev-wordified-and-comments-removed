"
use
strict
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
strBundle
"
function
(
)
{
const
stringSvc
=
Cc
[
"
mozilla
.
org
/
intl
/
stringbundle
;
1
"
]
.
getService
(
Ci
.
nsIStringBundleService
)
;
return
stringSvc
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
extensions
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aboutNewTabService
"
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
"
nsIAboutNewTabService
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
let
tabListener
=
{
tabReadyInitialized
:
false
tabReadyPromises
:
new
WeakMap
(
)
initializingTabs
:
new
WeakSet
(
)
initTabReady
(
)
{
if
(
!
this
.
tabReadyInitialized
)
{
windowTracker
.
addListener
(
"
progress
"
this
)
;
this
.
tabReadyInitialized
=
true
;
}
}
onLocationChange
(
browser
webProgress
request
locationURI
flags
)
{
if
(
webProgress
.
isTopLevel
)
{
let
{
gBrowser
}
=
browser
.
ownerGlobal
;
let
nativeTab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
this
.
initializingTabs
.
delete
(
nativeTab
)
;
let
deferred
=
this
.
tabReadyPromises
.
get
(
nativeTab
)
;
if
(
deferred
)
{
deferred
.
resolve
(
nativeTab
)
;
this
.
tabReadyPromises
.
delete
(
nativeTab
)
;
}
}
}
awaitTabReady
(
nativeTab
)
{
let
deferred
=
this
.
tabReadyPromises
.
get
(
nativeTab
)
;
if
(
!
deferred
)
{
deferred
=
PromiseUtils
.
defer
(
)
;
if
(
!
this
.
initializingTabs
.
has
(
nativeTab
)
&
&
(
nativeTab
.
linkedBrowser
.
innerWindowID
|
|
nativeTab
.
linkedBrowser
.
currentURI
.
spec
=
=
=
"
about
:
blank
"
)
)
{
deferred
.
resolve
(
nativeTab
)
;
}
else
{
this
.
initTabReady
(
)
;
this
.
tabReadyPromises
.
set
(
nativeTab
deferred
)
;
}
}
return
deferred
.
promise
;
}
}
;
this
.
tabs
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
let
{
extension
}
=
context
;
let
{
tabManager
}
=
extension
;
function
getTabOrActive
(
tabId
)
{
if
(
tabId
!
=
=
null
)
{
return
tabTracker
.
getTab
(
tabId
)
;
}
return
tabTracker
.
activeTab
;
}
async
function
promiseTabWhenReady
(
tabId
)
{
let
tab
;
if
(
tabId
!
=
=
null
)
{
tab
=
tabManager
.
get
(
tabId
)
;
}
else
{
tab
=
tabManager
.
getWrapper
(
tabTracker
.
activeTab
)
;
}
await
tabListener
.
awaitTabReady
(
tab
.
nativeTab
)
;
return
tab
;
}
let
self
=
{
tabs
:
{
onActivated
:
new
EventManager
(
context
"
tabs
.
onActivated
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
)
;
}
;
tabTracker
.
on
(
"
tab
-
activated
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
activated
"
listener
)
;
}
;
}
)
.
api
(
)
onCreated
:
new
EventManager
(
context
"
tabs
.
onCreated
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
tabManager
.
convert
(
event
.
nativeTab
event
.
currentTab
)
)
;
}
;
tabTracker
.
on
(
"
tab
-
created
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
created
"
listener
)
;
}
;
}
)
.
api
(
)
onHighlighted
:
new
EventManager
(
context
"
tabs
.
onHighlighted
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
{
tabIds
:
[
event
.
tabId
]
windowId
:
event
.
windowId
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
activated
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
activated
"
listener
)
;
}
;
}
)
.
api
(
)
onAttached
:
new
EventManager
(
context
"
tabs
.
onAttached
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
.
tabId
{
newWindowId
:
event
.
newWindowId
newPosition
:
event
.
newPosition
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
attached
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
attached
"
listener
)
;
}
;
}
)
.
api
(
)
onDetached
:
new
EventManager
(
context
"
tabs
.
onDetached
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
.
tabId
{
oldWindowId
:
event
.
oldWindowId
oldPosition
:
event
.
oldPosition
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
detached
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
detached
"
listener
)
;
}
;
}
)
.
api
(
)
onRemoved
:
new
EventManager
(
context
"
tabs
.
onRemoved
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
.
tabId
{
windowId
:
event
.
windowId
isWindowClosing
:
event
.
isWindowClosing
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
removed
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
removed
"
listener
)
;
}
;
}
)
.
api
(
)
onReplaced
:
new
EventManager
(
context
"
tabs
.
onReplaced
"
fire
=
>
{
return
(
)
=
>
{
}
;
}
)
.
api
(
)
onMoved
:
new
EventManager
(
context
"
tabs
.
onMoved
"
fire
=
>
{
let
ignoreNextMove
=
new
WeakSet
(
)
;
let
openListener
=
event
=
>
{
ignoreNextMove
.
add
(
event
.
target
)
;
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
ignoreNextMove
.
delete
(
event
.
target
)
;
}
)
;
}
;
let
moveListener
=
event
=
>
{
let
nativeTab
=
event
.
originalTarget
;
if
(
ignoreNextMove
.
has
(
nativeTab
)
)
{
ignoreNextMove
.
delete
(
nativeTab
)
;
return
;
}
fire
.
async
(
tabTracker
.
getId
(
nativeTab
)
{
windowId
:
windowTracker
.
getId
(
nativeTab
.
ownerGlobal
)
fromIndex
:
event
.
detail
toIndex
:
nativeTab
.
_tPos
}
)
;
}
;
windowTracker
.
addListener
(
"
TabMove
"
moveListener
)
;
windowTracker
.
addListener
(
"
TabOpen
"
openListener
)
;
return
(
)
=
>
{
windowTracker
.
removeListener
(
"
TabMove
"
moveListener
)
;
windowTracker
.
removeListener
(
"
TabOpen
"
openListener
)
;
}
;
}
)
.
api
(
)
onUpdated
:
new
EventManager
(
context
"
tabs
.
onUpdated
"
fire
=
>
{
const
restricted
=
[
"
url
"
"
favIconUrl
"
"
title
"
]
;
function
sanitize
(
extension
changeInfo
)
{
let
result
=
{
}
;
let
nonempty
=
false
;
for
(
let
prop
in
changeInfo
)
{
if
(
extension
.
hasPermission
(
"
tabs
"
)
|
|
!
restricted
.
includes
(
prop
)
)
{
nonempty
=
true
;
result
[
prop
]
=
changeInfo
[
prop
]
;
}
}
return
[
nonempty
result
]
;
}
let
fireForTab
=
(
tab
changed
)
=
>
{
let
[
needed
changeInfo
]
=
sanitize
(
extension
changed
)
;
if
(
needed
)
{
fire
.
async
(
tab
.
id
changeInfo
tab
.
convert
(
)
)
;
}
}
;
let
listener
=
event
=
>
{
let
needed
=
[
]
;
if
(
event
.
type
=
=
"
TabAttrModified
"
)
{
let
changed
=
event
.
detail
.
changed
;
if
(
changed
.
includes
(
"
image
"
)
)
{
needed
.
push
(
"
favIconUrl
"
)
;
}
if
(
changed
.
includes
(
"
muted
"
)
)
{
needed
.
push
(
"
mutedInfo
"
)
;
}
if
(
changed
.
includes
(
"
soundplaying
"
)
)
{
needed
.
push
(
"
audible
"
)
;
}
if
(
changed
.
includes
(
"
label
"
)
)
{
needed
.
push
(
"
title
"
)
;
}
}
else
if
(
event
.
type
=
=
"
TabPinned
"
)
{
needed
.
push
(
"
pinned
"
)
;
}
else
if
(
event
.
type
=
=
"
TabUnpinned
"
)
{
needed
.
push
(
"
pinned
"
)
;
}
let
tab
=
tabManager
.
getWrapper
(
event
.
originalTarget
)
;
let
changeInfo
=
{
}
;
for
(
let
prop
of
needed
)
{
changeInfo
[
prop
]
=
tab
[
prop
]
;
}
fireForTab
(
tab
changeInfo
)
;
}
;
let
statusListener
=
(
{
browser
status
url
}
)
=
>
{
let
{
gBrowser
}
=
browser
.
ownerGlobal
;
let
tabElem
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tabElem
)
{
let
changed
=
{
status
}
;
if
(
url
)
{
changed
.
url
=
url
;
}
fireForTab
(
tabManager
.
wrapTab
(
tabElem
)
changed
)
;
}
}
;
windowTracker
.
addListener
(
"
status
"
statusListener
)
;
windowTracker
.
addListener
(
"
TabAttrModified
"
listener
)
;
windowTracker
.
addListener
(
"
TabPinned
"
listener
)
;
windowTracker
.
addListener
(
"
TabUnpinned
"
listener
)
;
return
(
)
=
>
{
windowTracker
.
removeListener
(
"
status
"
statusListener
)
;
windowTracker
.
removeListener
(
"
TabAttrModified
"
listener
)
;
windowTracker
.
removeListener
(
"
TabPinned
"
listener
)
;
windowTracker
.
removeListener
(
"
TabUnpinned
"
listener
)
;
}
;
}
)
.
api
(
)
create
(
createProperties
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
window
=
createProperties
.
windowId
!
=
=
null
?
windowTracker
.
getWindow
(
createProperties
.
windowId
context
)
:
windowTracker
.
topWindow
;
if
(
!
window
.
gBrowser
)
{
let
obs
=
(
finishedWindow
topic
data
)
=
>
{
if
(
finishedWindow
!
=
window
)
{
return
;
}
Services
.
obs
.
removeObserver
(
obs
"
browser
-
delayed
-
startup
-
finished
"
)
;
resolve
(
window
)
;
}
;
Services
.
obs
.
addObserver
(
obs
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
else
{
resolve
(
window
)
;
}
}
)
.
then
(
window
=
>
{
let
url
;
if
(
createProperties
.
url
!
=
=
null
)
{
url
=
context
.
uri
.
resolve
(
createProperties
.
url
)
;
if
(
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
URL
:
{
url
}
}
)
;
}
}
if
(
createProperties
.
cookieStoreId
&
&
!
extension
.
hasPermission
(
"
cookies
"
)
)
{
return
Promise
.
reject
(
{
message
:
No
permission
for
cookieStoreId
:
{
createProperties
.
cookieStoreId
}
}
)
;
}
let
options
=
{
}
;
if
(
createProperties
.
cookieStoreId
)
{
if
(
!
global
.
isValidCookieStoreId
(
createProperties
.
cookieStoreId
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
cookieStoreId
:
{
createProperties
.
cookieStoreId
}
}
)
;
}
let
privateWindow
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
window
.
gBrowser
)
;
if
(
privateWindow
&
&
!
global
.
isPrivateCookieStoreId
(
createProperties
.
cookieStoreId
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
to
set
non
-
private
cookieStoreId
in
a
private
window
}
)
;
}
if
(
!
privateWindow
&
&
global
.
isPrivateCookieStoreId
(
createProperties
.
cookieStoreId
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
to
set
private
cookieStoreId
in
a
non
-
private
window
}
)
;
}
if
(
global
.
isContainerCookieStoreId
(
createProperties
.
cookieStoreId
)
)
{
let
containerId
=
global
.
getContainerForCookieStoreId
(
createProperties
.
cookieStoreId
)
;
if
(
!
containerId
)
{
return
Promise
.
reject
(
{
message
:
No
cookie
store
exists
with
ID
{
createProperties
.
cookieStoreId
}
}
)
;
}
options
.
userContextId
=
containerId
;
}
}
options
.
disallowInheritPrincipal
=
true
;
tabListener
.
initTabReady
(
)
;
let
currentTab
=
window
.
gBrowser
.
selectedTab
;
let
nativeTab
=
window
.
gBrowser
.
addTab
(
url
|
|
window
.
BROWSER_NEW_TAB_URL
options
)
;
let
active
=
true
;
if
(
createProperties
.
active
!
=
=
null
)
{
active
=
createProperties
.
active
;
}
if
(
active
)
{
window
.
gBrowser
.
selectedTab
=
nativeTab
;
}
if
(
createProperties
.
index
!
=
=
null
)
{
window
.
gBrowser
.
moveTabTo
(
nativeTab
createProperties
.
index
)
;
}
if
(
createProperties
.
pinned
)
{
window
.
gBrowser
.
pinTab
(
nativeTab
)
;
}
if
(
active
&
&
!
url
)
{
window
.
focusAndSelectUrlBar
(
)
;
}
if
(
createProperties
.
url
&
&
createProperties
.
url
!
=
=
window
.
BROWSER_NEW_TAB_URL
)
{
tabListener
.
initializingTabs
.
add
(
nativeTab
)
;
}
return
tabManager
.
convert
(
nativeTab
currentTab
)
;
}
)
;
}
async
remove
(
tabs
)
{
if
(
!
Array
.
isArray
(
tabs
)
)
{
tabs
=
[
tabs
]
;
}
for
(
let
tabId
of
tabs
)
{
let
nativeTab
=
tabTracker
.
getTab
(
tabId
)
;
nativeTab
.
ownerGlobal
.
gBrowser
.
removeTab
(
nativeTab
)
;
}
}
async
update
(
tabId
updateProperties
)
{
let
nativeTab
=
getTabOrActive
(
tabId
)
;
let
tabbrowser
=
nativeTab
.
ownerGlobal
.
gBrowser
;
if
(
updateProperties
.
url
!
=
=
null
)
{
let
url
=
context
.
uri
.
resolve
(
updateProperties
.
url
)
;
if
(
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
URL
:
{
url
}
}
)
;
}
nativeTab
.
linkedBrowser
.
loadURI
(
url
)
;
}
if
(
updateProperties
.
active
!
=
=
null
)
{
if
(
updateProperties
.
active
)
{
tabbrowser
.
selectedTab
=
nativeTab
;
}
else
{
}
}
if
(
updateProperties
.
muted
!
=
=
null
)
{
if
(
nativeTab
.
muted
!
=
updateProperties
.
muted
)
{
nativeTab
.
toggleMuteAudio
(
extension
.
uuid
)
;
}
}
if
(
updateProperties
.
pinned
!
=
=
null
)
{
if
(
updateProperties
.
pinned
)
{
tabbrowser
.
pinTab
(
nativeTab
)
;
}
else
{
tabbrowser
.
unpinTab
(
nativeTab
)
;
}
}
return
tabManager
.
convert
(
nativeTab
)
;
}
async
reload
(
tabId
reloadProperties
)
{
let
nativeTab
=
getTabOrActive
(
tabId
)
;
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
reloadProperties
&
&
reloadProperties
.
bypassCache
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
;
}
nativeTab
.
linkedBrowser
.
reloadWithFlags
(
flags
)
;
}
async
get
(
tabId
)
{
return
tabManager
.
get
(
tabId
)
.
convert
(
)
;
}
getCurrent
(
)
{
let
tabData
;
if
(
context
.
tabId
)
{
tabData
=
tabManager
.
get
(
context
.
tabId
)
.
convert
(
)
;
}
return
Promise
.
resolve
(
tabData
)
;
}
async
query
(
queryInfo
)
{
if
(
queryInfo
.
url
!
=
=
null
)
{
if
(
!
extension
.
hasPermission
(
"
tabs
"
)
)
{
return
Promise
.
reject
(
{
message
:
'
The
"
tabs
"
permission
is
required
to
use
the
query
API
with
the
"
url
"
parameter
'
}
)
;
}
queryInfo
=
Object
.
assign
(
{
}
queryInfo
)
;
queryInfo
.
url
=
new
MatchPatternSet
(
[
]
.
concat
(
queryInfo
.
url
)
)
;
}
return
Array
.
from
(
tabManager
.
query
(
queryInfo
context
)
tab
=
>
tab
.
convert
(
)
)
;
}
async
captureVisibleTab
(
windowId
options
)
{
let
window
=
windowId
=
=
null
?
windowTracker
.
topWindow
:
windowTracker
.
getWindow
(
windowId
context
)
;
let
tab
=
tabManager
.
wrapTab
(
window
.
gBrowser
.
selectedTab
)
;
await
tabListener
.
awaitTabReady
(
tab
.
nativeTab
)
;
return
tab
.
capture
(
context
options
)
;
}
async
detectLanguage
(
tabId
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
sendMessage
(
context
"
Extension
:
DetectLanguage
"
)
;
}
async
executeScript
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
executeScript
(
context
details
)
;
}
async
insertCSS
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
insertCSS
(
context
details
)
;
}
async
removeCSS
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
removeCSS
(
context
details
)
;
}
async
move
(
tabIds
moveProperties
)
{
let
tabsMoved
=
[
]
;
if
(
!
Array
.
isArray
(
tabIds
)
)
{
tabIds
=
[
tabIds
]
;
}
let
destinationWindow
=
null
;
if
(
moveProperties
.
windowId
!
=
=
null
)
{
destinationWindow
=
windowTracker
.
getWindow
(
moveProperties
.
windowId
)
;
if
(
!
destinationWindow
)
{
return
Promise
.
reject
(
{
message
:
Invalid
window
ID
:
{
moveProperties
.
windowId
}
}
)
;
}
}
let
indexMap
=
new
Map
(
)
;
let
lastInsertion
=
new
Map
(
)
;
let
tabs
=
tabIds
.
map
(
tabId
=
>
tabTracker
.
getTab
(
tabId
)
)
;
for
(
let
nativeTab
of
tabs
)
{
let
window
=
destinationWindow
|
|
nativeTab
.
ownerGlobal
;
let
gBrowser
=
window
.
gBrowser
;
let
insertionPoint
=
indexMap
.
get
(
window
)
|
|
moveProperties
.
index
;
if
(
insertionPoint
=
=
-
1
)
{
insertionPoint
=
gBrowser
.
tabs
.
length
;
}
let
numPinned
=
gBrowser
.
_numPinnedTabs
;
let
ok
=
nativeTab
.
pinned
?
insertionPoint
<
=
numPinned
:
insertionPoint
>
=
numPinned
;
if
(
!
ok
)
{
continue
;
}
if
(
lastInsertion
.
has
(
window
)
&
&
lastInsertion
.
get
(
window
)
=
=
=
insertionPoint
&
&
nativeTab
.
_tPos
>
insertionPoint
)
{
insertionPoint
+
+
;
indexMap
.
set
(
window
insertionPoint
)
;
}
if
(
nativeTab
.
ownerGlobal
!
=
window
)
{
nativeTab
=
gBrowser
.
adoptTab
(
nativeTab
insertionPoint
false
)
;
}
else
{
gBrowser
.
moveTabTo
(
nativeTab
insertionPoint
)
;
}
lastInsertion
.
set
(
window
nativeTab
.
_tPos
)
;
tabsMoved
.
push
(
nativeTab
)
;
}
return
tabsMoved
.
map
(
nativeTab
=
>
tabManager
.
convert
(
nativeTab
)
)
;
}
duplicate
(
tabId
)
{
let
nativeTab
=
tabTracker
.
getTab
(
tabId
)
;
let
gBrowser
=
nativeTab
.
ownerGlobal
.
gBrowser
;
let
newTab
=
gBrowser
.
duplicateTab
(
nativeTab
)
;
return
new
Promise
(
resolve
=
>
{
newTab
.
addEventListener
(
"
SSTabRestoring
"
function
(
)
{
if
(
nativeTab
.
pinned
)
{
gBrowser
.
pinTab
(
newTab
)
;
}
gBrowser
.
moveTabTo
(
newTab
nativeTab
.
_tPos
+
1
)
;
}
{
once
:
true
}
)
;
newTab
.
addEventListener
(
"
SSTabRestored
"
function
(
)
{
gBrowser
.
selectedTab
=
newTab
;
resolve
(
tabManager
.
convert
(
newTab
)
)
;
}
{
once
:
true
}
)
;
}
)
;
}
getZoom
(
tabId
)
{
let
nativeTab
=
getTabOrActive
(
tabId
)
;
let
{
ZoomManager
}
=
nativeTab
.
ownerGlobal
;
let
zoom
=
ZoomManager
.
getZoomForBrowser
(
nativeTab
.
linkedBrowser
)
;
return
Promise
.
resolve
(
zoom
)
;
}
setZoom
(
tabId
zoom
)
{
let
nativeTab
=
getTabOrActive
(
tabId
)
;
let
{
FullZoom
ZoomManager
}
=
nativeTab
.
ownerGlobal
;
if
(
zoom
=
=
=
0
)
{
return
FullZoom
.
reset
(
nativeTab
.
linkedBrowser
)
;
}
else
if
(
zoom
>
=
ZoomManager
.
MIN
&
&
zoom
<
=
ZoomManager
.
MAX
)
{
FullZoom
.
setZoom
(
zoom
nativeTab
.
linkedBrowser
)
;
}
else
{
return
Promise
.
reject
(
{
message
:
Zoom
value
{
zoom
}
out
of
range
(
must
be
between
{
ZoomManager
.
MIN
}
and
{
ZoomManager
.
MAX
}
)
}
)
;
}
return
Promise
.
resolve
(
)
;
}
_getZoomSettings
(
tabId
)
{
let
nativeTab
=
getTabOrActive
(
tabId
)
;
let
{
FullZoom
}
=
nativeTab
.
ownerGlobal
;
return
{
mode
:
"
automatic
"
scope
:
FullZoom
.
siteSpecific
?
"
per
-
origin
"
:
"
per
-
tab
"
defaultZoomFactor
:
1
}
;
}
getZoomSettings
(
tabId
)
{
return
Promise
.
resolve
(
this
.
_getZoomSettings
(
tabId
)
)
;
}
setZoomSettings
(
tabId
settings
)
{
let
nativeTab
=
getTabOrActive
(
tabId
)
;
let
currentSettings
=
this
.
_getZoomSettings
(
tabTracker
.
getId
(
nativeTab
)
)
;
if
(
!
Object
.
keys
(
settings
)
.
every
(
key
=
>
settings
[
key
]
=
=
=
currentSettings
[
key
]
)
)
{
return
Promise
.
reject
(
Unsupported
zoom
settings
:
{
JSON
.
stringify
(
settings
)
}
)
;
}
return
Promise
.
resolve
(
)
;
}
onZoomChange
:
new
EventManager
(
context
"
tabs
.
onZoomChange
"
fire
=
>
{
let
getZoomLevel
=
browser
=
>
{
let
{
ZoomManager
}
=
browser
.
ownerGlobal
;
return
ZoomManager
.
getZoomForBrowser
(
browser
)
;
}
;
let
zoomLevels
=
new
WeakMap
(
)
;
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
for
(
let
nativeTab
of
window
.
gBrowser
.
tabs
)
{
let
browser
=
nativeTab
.
linkedBrowser
;
zoomLevels
.
set
(
browser
getZoomLevel
(
browser
)
)
;
}
}
let
tabCreated
=
(
eventName
event
)
=
>
{
let
browser
=
event
.
nativeTab
.
linkedBrowser
;
zoomLevels
.
set
(
browser
getZoomLevel
(
browser
)
)
;
}
;
let
zoomListener
=
event
=
>
{
let
browser
=
event
.
originalTarget
;
if
(
browser
instanceof
Ci
.
nsIDOMDocument
)
{
browser
=
browser
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
;
}
let
{
gBrowser
}
=
browser
.
ownerGlobal
;
let
nativeTab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
!
nativeTab
)
{
return
;
}
let
oldZoomFactor
=
zoomLevels
.
get
(
browser
)
;
let
newZoomFactor
=
getZoomLevel
(
browser
)
;
if
(
oldZoomFactor
!
=
newZoomFactor
)
{
zoomLevels
.
set
(
browser
newZoomFactor
)
;
let
tabId
=
tabTracker
.
getId
(
nativeTab
)
;
fire
.
async
(
{
tabId
oldZoomFactor
newZoomFactor
zoomSettings
:
self
.
tabs
.
_getZoomSettings
(
tabId
)
}
)
;
}
}
;
tabTracker
.
on
(
"
tab
-
attached
"
tabCreated
)
;
tabTracker
.
on
(
"
tab
-
created
"
tabCreated
)
;
windowTracker
.
addListener
(
"
FullZoomChange
"
zoomListener
)
;
windowTracker
.
addListener
(
"
TextZoomChange
"
zoomListener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
attached
"
tabCreated
)
;
tabTracker
.
off
(
"
tab
-
created
"
tabCreated
)
;
windowTracker
.
removeListener
(
"
FullZoomChange
"
zoomListener
)
;
windowTracker
.
removeListener
(
"
TextZoomChange
"
zoomListener
)
;
}
;
}
)
.
api
(
)
print
(
)
{
let
activeTab
=
getTabOrActive
(
null
)
;
let
{
PrintUtils
}
=
activeTab
.
ownerGlobal
;
PrintUtils
.
printWindow
(
activeTab
.
linkedBrowser
.
outerWindowID
activeTab
.
linkedBrowser
)
;
}
printPreview
(
)
{
let
activeTab
=
getTabOrActive
(
null
)
;
let
{
PrintUtils
PrintPreviewListener
}
=
activeTab
.
ownerGlobal
;
return
new
Promise
(
resolve
=
>
{
let
ppBrowser
=
PrintUtils
.
_shouldSimplify
?
PrintPreviewListener
.
getSimplifiedPrintPreviewBrowser
(
)
:
PrintPreviewListener
.
getPrintPreviewBrowser
(
)
;
let
mm
=
ppBrowser
.
messageManager
;
let
onEntered
=
(
message
)
=
>
{
mm
.
removeMessageListener
(
"
Printing
:
Preview
:
Entered
"
onEntered
)
;
if
(
message
.
data
.
failed
)
{
throw
new
ExtensionError
(
"
Print
preview
failed
"
)
;
}
resolve
(
)
;
}
;
mm
.
addMessageListener
(
"
Printing
:
Preview
:
Entered
"
onEntered
)
;
PrintUtils
.
printPreview
(
PrintPreviewListener
)
;
}
)
;
}
saveAsPDF
(
pageSettings
)
{
let
activeTab
=
getTabOrActive
(
null
)
;
let
picker
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
title
=
strBundle
.
GetStringFromName
(
"
saveaspdf
.
saveasdialog
.
title
"
)
;
picker
.
init
(
activeTab
.
ownerGlobal
title
Ci
.
nsIFilePicker
.
modeSave
)
;
picker
.
appendFilter
(
"
PDF
"
"
*
.
pdf
"
)
;
picker
.
defaultExtension
=
"
pdf
"
;
picker
.
defaultString
=
activeTab
.
linkedBrowser
.
contentTitle
+
"
.
pdf
"
;
return
new
Promise
(
resolve
=
>
{
picker
.
open
(
function
(
retval
)
{
if
(
retval
=
=
0
|
|
retval
=
=
2
)
{
try
{
let
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
fstream
.
init
(
picker
.
file
0x2A
0x1B6
0
)
;
fstream
.
close
(
)
;
}
catch
(
e
)
{
resolve
(
retval
=
=
0
?
"
Not
saved
"
:
"
Not
replaced
"
)
;
return
;
}
let
psService
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
let
printSettings
=
psService
.
newPrintSettings
;
printSettings
.
printToFile
=
true
;
printSettings
.
toFileName
=
picker
.
file
.
path
;
printSettings
.
printSilent
=
true
;
printSettings
.
showPrintProgress
=
false
;
printSettings
.
printFrameType
=
Ci
.
nsIPrintSettings
.
kFramesAsIs
;
printSettings
.
outputFormat
=
Ci
.
nsIPrintSettings
.
kOutputFormatPDF
;
if
(
pageSettings
.
orientation
!
=
=
null
)
{
printSettings
.
orientation
=
pageSettings
.
orientation
;
}
if
(
pageSettings
.
scaling
!
=
=
null
)
{
printSettings
.
scaling
=
pageSettings
.
scaling
;
}
if
(
pageSettings
.
shrinkToFit
!
=
=
null
)
{
printSettings
.
shrinkToFit
=
pageSettings
.
shrinkToFit
;
}
if
(
pageSettings
.
showBackgroundColors
!
=
=
null
)
{
printSettings
.
printBGColors
=
pageSettings
.
showBackgroundColors
;
}
if
(
pageSettings
.
showBackgroundImages
!
=
=
null
)
{
printSettings
.
printBGImages
=
pageSettings
.
showBackgroundImages
;
}
if
(
pageSettings
.
paperSizeUnit
!
=
=
null
)
{
printSettings
.
paperSizeUnit
=
pageSettings
.
paperSizeUnit
;
}
if
(
pageSettings
.
paperWidth
!
=
=
null
)
{
printSettings
.
paperWidth
=
pageSettings
.
paperWidth
;
}
if
(
pageSettings
.
paperHeight
!
=
=
null
)
{
printSettings
.
paperHeight
=
pageSettings
.
paperHeight
;
}
if
(
pageSettings
.
headerLeft
!
=
=
null
)
{
printSettings
.
headerStrLeft
=
pageSettings
.
headerLeft
;
}
if
(
pageSettings
.
headerCenter
!
=
=
null
)
{
printSettings
.
headerStrCenter
=
pageSettings
.
headerCenter
;
}
if
(
pageSettings
.
headerRight
!
=
=
null
)
{
printSettings
.
headerStrRight
=
pageSettings
.
headerRight
;
}
if
(
pageSettings
.
footerLeft
!
=
=
null
)
{
printSettings
.
footerStrLeft
=
pageSettings
.
footerLeft
;
}
if
(
pageSettings
.
footerCenter
!
=
=
null
)
{
printSettings
.
footerStrCenter
=
pageSettings
.
footerCenter
;
}
if
(
pageSettings
.
footerRight
!
=
=
null
)
{
printSettings
.
footerStrRight
=
pageSettings
.
footerRight
;
}
if
(
pageSettings
.
marginLeft
!
=
=
null
)
{
printSettings
.
marginLeft
=
pageSettings
.
marginLeft
;
}
if
(
pageSettings
.
marginRight
!
=
=
null
)
{
printSettings
.
marginRight
=
pageSettings
.
marginRight
;
}
if
(
pageSettings
.
marginTop
!
=
=
null
)
{
printSettings
.
marginTop
=
pageSettings
.
marginTop
;
}
if
(
pageSettings
.
marginBottom
!
=
=
null
)
{
printSettings
.
marginBottom
=
pageSettings
.
marginBottom
;
}
activeTab
.
linkedBrowser
.
print
(
activeTab
.
linkedBrowser
.
outerWindowID
printSettings
null
)
;
resolve
(
retval
=
=
0
?
"
Saved
"
:
"
Replaced
"
)
;
}
else
{
resolve
(
"
Cancelled
"
)
;
}
}
)
;
}
)
;
}
}
}
;
return
self
;
}
}
;
