"
use
strict
"
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
aboutNewTabService
"
"
mozilla
.
org
/
browser
/
aboutnewtab
-
service
;
1
"
"
nsIAboutNewTabService
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
MatchPattern
"
"
resource
:
/
/
gre
/
modules
/
MatchPattern
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PromiseUtils
"
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
)
;
var
{
SingletonEventManager
ignoreEvent
}
=
ExtensionUtils
;
function
getSender
(
extension
target
sender
)
{
let
tabId
;
if
(
"
tabId
"
in
sender
)
{
tabId
=
sender
.
tabId
;
delete
sender
.
tabId
;
}
else
if
(
target
instanceof
Ci
.
nsIDOMXULElement
)
{
tabId
=
tabTracker
.
getBrowserData
(
target
)
.
tabId
;
}
if
(
tabId
)
{
let
tab
=
extension
.
tabManager
.
get
(
tabId
null
)
;
if
(
tab
)
{
sender
.
tab
=
tab
.
convert
(
)
;
}
}
}
global
.
tabGetSender
=
getSender
;
extensions
.
on
(
"
page
-
shutdown
"
(
type
context
)
=
>
{
if
(
context
.
viewType
=
=
"
tab
"
)
{
if
(
context
.
extension
.
id
!
=
=
context
.
xulBrowser
.
contentPrincipal
.
addonId
)
{
return
;
}
let
{
gBrowser
}
=
context
.
xulBrowser
.
ownerGlobal
;
if
(
gBrowser
)
{
let
tab
=
gBrowser
.
getTabForBrowser
(
context
.
xulBrowser
)
;
if
(
tab
)
{
gBrowser
.
removeTab
(
tab
)
;
}
}
}
}
)
;
let
tabListener
=
{
tabReadyInitialized
:
false
tabReadyPromises
:
new
WeakMap
(
)
initializingTabs
:
new
WeakSet
(
)
initTabReady
(
)
{
if
(
!
this
.
tabReadyInitialized
)
{
windowTracker
.
addListener
(
"
progress
"
this
)
;
this
.
tabReadyInitialized
=
true
;
}
}
onLocationChange
(
browser
webProgress
request
locationURI
flags
)
{
if
(
webProgress
.
isTopLevel
)
{
let
{
gBrowser
}
=
browser
.
ownerGlobal
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
this
.
initializingTabs
.
delete
(
tab
)
;
let
deferred
=
this
.
tabReadyPromises
.
get
(
tab
)
;
if
(
deferred
)
{
deferred
.
resolve
(
tab
)
;
this
.
tabReadyPromises
.
delete
(
tab
)
;
}
}
}
awaitTabReady
(
tab
)
{
let
deferred
=
this
.
tabReadyPromises
.
get
(
tab
)
;
if
(
!
deferred
)
{
deferred
=
PromiseUtils
.
defer
(
)
;
if
(
!
this
.
initializingTabs
.
has
(
tab
)
&
&
(
tab
.
linkedBrowser
.
innerWindowID
|
|
tab
.
linkedBrowser
.
currentURI
.
spec
=
=
=
"
about
:
blank
"
)
)
{
deferred
.
resolve
(
tab
)
;
}
else
{
this
.
initTabReady
(
)
;
this
.
tabReadyPromises
.
set
(
tab
deferred
)
;
}
}
return
deferred
.
promise
;
}
}
;
extensions
.
registerSchemaAPI
(
"
tabs
"
"
addon_parent
"
context
=
>
{
let
{
extension
}
=
context
;
let
{
tabManager
}
=
extension
;
function
getTabOrActive
(
tabId
)
{
if
(
tabId
!
=
=
null
)
{
return
tabTracker
.
getTab
(
tabId
)
;
}
return
tabTracker
.
activeTab
;
}
async
function
promiseTabWhenReady
(
tabId
)
{
let
tab
;
if
(
tabId
!
=
=
null
)
{
tab
=
tabManager
.
get
(
tabId
)
;
}
else
{
tab
=
tabManager
.
getWrapper
(
tabTracker
.
activeTab
)
;
}
await
tabListener
.
awaitTabReady
(
tab
.
tab
)
;
return
tab
;
}
let
self
=
{
tabs
:
{
onActivated
:
new
WindowEventManager
(
context
"
tabs
.
onActivated
"
"
TabSelect
"
(
fire
event
)
=
>
{
let
tab
=
event
.
originalTarget
;
let
tabId
=
tabTracker
.
getId
(
tab
)
;
let
windowId
=
windowTracker
.
getId
(
tab
.
ownerGlobal
)
;
fire
.
async
(
{
tabId
windowId
}
)
;
}
)
.
api
(
)
onCreated
:
new
SingletonEventManager
(
context
"
tabs
.
onCreated
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
tabManager
.
convert
(
event
.
tab
)
)
;
}
;
tabTracker
.
on
(
"
tab
-
created
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
created
"
listener
)
;
}
;
}
)
.
api
(
)
onHighlighted
:
new
WindowEventManager
(
context
"
tabs
.
onHighlighted
"
"
TabSelect
"
(
fire
event
)
=
>
{
let
tab
=
event
.
originalTarget
;
let
tabIds
=
[
tabTracker
.
getId
(
tab
)
]
;
let
windowId
=
windowTracker
.
getId
(
tab
.
ownerGlobal
)
;
fire
.
async
(
{
tabIds
windowId
}
)
;
}
)
.
api
(
)
onAttached
:
new
SingletonEventManager
(
context
"
tabs
.
onAttached
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
.
tabId
{
newWindowId
:
event
.
newWindowId
newPosition
:
event
.
newPosition
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
attached
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
attached
"
listener
)
;
}
;
}
)
.
api
(
)
onDetached
:
new
SingletonEventManager
(
context
"
tabs
.
onDetached
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
.
tabId
{
oldWindowId
:
event
.
oldWindowId
oldPosition
:
event
.
oldPosition
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
detached
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
detached
"
listener
)
;
}
;
}
)
.
api
(
)
onRemoved
:
new
SingletonEventManager
(
context
"
tabs
.
onRemoved
"
fire
=
>
{
let
listener
=
(
eventName
event
)
=
>
{
fire
.
async
(
event
.
tabId
{
windowId
:
event
.
windowId
isWindowClosing
:
event
.
isWindowClosing
}
)
;
}
;
tabTracker
.
on
(
"
tab
-
removed
"
listener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
removed
"
listener
)
;
}
;
}
)
.
api
(
)
onReplaced
:
ignoreEvent
(
context
"
tabs
.
onReplaced
"
)
onMoved
:
new
SingletonEventManager
(
context
"
tabs
.
onMoved
"
fire
=
>
{
let
ignoreNextMove
=
new
WeakSet
(
)
;
let
openListener
=
event
=
>
{
ignoreNextMove
.
add
(
event
.
target
)
;
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
ignoreNextMove
.
delete
(
event
.
target
)
;
}
)
;
}
;
let
moveListener
=
event
=
>
{
let
tab
=
event
.
originalTarget
;
if
(
ignoreNextMove
.
has
(
tab
)
)
{
ignoreNextMove
.
delete
(
tab
)
;
return
;
}
fire
.
async
(
tabTracker
.
getId
(
tab
)
{
windowId
:
windowTracker
.
getId
(
tab
.
ownerGlobal
)
fromIndex
:
event
.
detail
toIndex
:
tab
.
_tPos
}
)
;
}
;
windowTracker
.
addListener
(
"
TabMove
"
moveListener
)
;
windowTracker
.
addListener
(
"
TabOpen
"
openListener
)
;
return
(
)
=
>
{
windowTracker
.
removeListener
(
"
TabMove
"
moveListener
)
;
windowTracker
.
removeListener
(
"
TabOpen
"
openListener
)
;
}
;
}
)
.
api
(
)
onUpdated
:
new
SingletonEventManager
(
context
"
tabs
.
onUpdated
"
fire
=
>
{
const
restricted
=
[
"
url
"
"
favIconUrl
"
"
title
"
]
;
function
sanitize
(
extension
changeInfo
)
{
let
result
=
{
}
;
let
nonempty
=
false
;
for
(
let
prop
in
changeInfo
)
{
if
(
extension
.
hasPermission
(
"
tabs
"
)
|
|
!
restricted
.
includes
(
prop
)
)
{
nonempty
=
true
;
result
[
prop
]
=
changeInfo
[
prop
]
;
}
}
return
[
nonempty
result
]
;
}
let
fireForTab
=
(
tab
changed
)
=
>
{
let
[
needed
changeInfo
]
=
sanitize
(
extension
changed
)
;
if
(
needed
)
{
fire
.
async
(
tab
.
id
changeInfo
tab
.
convert
(
)
)
;
}
}
;
let
listener
=
event
=
>
{
let
needed
=
[
]
;
if
(
event
.
type
=
=
"
TabAttrModified
"
)
{
let
changed
=
event
.
detail
.
changed
;
if
(
changed
.
includes
(
"
image
"
)
)
{
needed
.
push
(
"
favIconUrl
"
)
;
}
if
(
changed
.
includes
(
"
muted
"
)
)
{
needed
.
push
(
"
mutedInfo
"
)
;
}
if
(
changed
.
includes
(
"
soundplaying
"
)
)
{
needed
.
push
(
"
audible
"
)
;
}
if
(
changed
.
includes
(
"
label
"
)
)
{
needed
.
push
(
"
title
"
)
;
}
}
else
if
(
event
.
type
=
=
"
TabPinned
"
)
{
needed
.
push
(
"
pinned
"
)
;
}
else
if
(
event
.
type
=
=
"
TabUnpinned
"
)
{
needed
.
push
(
"
pinned
"
)
;
}
let
tab
=
tabManager
.
getWrapper
(
event
.
originalTarget
)
;
let
changeInfo
=
{
}
;
for
(
let
prop
of
needed
)
{
changeInfo
[
prop
]
=
tab
[
prop
]
;
}
fireForTab
(
tab
changeInfo
)
;
}
;
let
statusListener
=
(
{
browser
status
url
}
)
=
>
{
let
{
gBrowser
}
=
browser
.
ownerGlobal
;
let
tabElem
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
tabElem
)
{
let
changed
=
{
status
}
;
if
(
url
)
{
changed
.
url
=
url
;
}
fireForTab
(
tabManager
.
wrapTab
(
tabElem
)
changed
)
;
}
}
;
windowTracker
.
addListener
(
"
status
"
statusListener
)
;
windowTracker
.
addListener
(
"
TabAttrModified
"
listener
)
;
windowTracker
.
addListener
(
"
TabPinned
"
listener
)
;
windowTracker
.
addListener
(
"
TabUnpinned
"
listener
)
;
return
(
)
=
>
{
windowTracker
.
removeListener
(
"
status
"
statusListener
)
;
windowTracker
.
removeListener
(
"
TabAttrModified
"
listener
)
;
windowTracker
.
removeListener
(
"
TabPinned
"
listener
)
;
windowTracker
.
removeListener
(
"
TabUnpinned
"
listener
)
;
}
;
}
)
.
api
(
)
create
(
createProperties
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
window
=
createProperties
.
windowId
!
=
=
null
?
windowTracker
.
getWindow
(
createProperties
.
windowId
context
)
:
windowTracker
.
topWindow
;
if
(
!
window
.
gBrowser
)
{
let
obs
=
(
finishedWindow
topic
data
)
=
>
{
if
(
finishedWindow
!
=
window
)
{
return
;
}
Services
.
obs
.
removeObserver
(
obs
"
browser
-
delayed
-
startup
-
finished
"
)
;
resolve
(
window
)
;
}
;
Services
.
obs
.
addObserver
(
obs
"
browser
-
delayed
-
startup
-
finished
"
false
)
;
}
else
{
resolve
(
window
)
;
}
}
)
.
then
(
window
=
>
{
let
url
;
if
(
createProperties
.
url
!
=
=
null
)
{
url
=
context
.
uri
.
resolve
(
createProperties
.
url
)
;
if
(
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
URL
:
{
url
}
}
)
;
}
}
if
(
createProperties
.
cookieStoreId
&
&
!
extension
.
hasPermission
(
"
cookies
"
)
)
{
return
Promise
.
reject
(
{
message
:
No
permission
for
cookieStoreId
:
{
createProperties
.
cookieStoreId
}
}
)
;
}
let
options
=
{
}
;
if
(
createProperties
.
cookieStoreId
)
{
if
(
!
global
.
isValidCookieStoreId
(
createProperties
.
cookieStoreId
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
cookieStoreId
:
{
createProperties
.
cookieStoreId
}
}
)
;
}
let
privateWindow
=
PrivateBrowsingUtils
.
isBrowserPrivate
(
window
.
gBrowser
)
;
if
(
privateWindow
&
&
!
global
.
isPrivateCookieStoreId
(
createProperties
.
cookieStoreId
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
to
set
non
-
private
cookieStoreId
in
a
private
window
}
)
;
}
if
(
!
privateWindow
&
&
global
.
isPrivateCookieStoreId
(
createProperties
.
cookieStoreId
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
to
set
private
cookieStoreId
in
a
non
-
private
window
}
)
;
}
if
(
global
.
isContainerCookieStoreId
(
createProperties
.
cookieStoreId
)
)
{
let
containerId
=
global
.
getContainerForCookieStoreId
(
createProperties
.
cookieStoreId
)
;
if
(
!
containerId
)
{
return
Promise
.
reject
(
{
message
:
No
cookie
store
exists
with
ID
{
createProperties
.
cookieStoreId
}
}
)
;
}
options
.
userContextId
=
containerId
;
}
}
options
.
disallowInheritPrincipal
=
true
;
tabListener
.
initTabReady
(
)
;
let
tab
=
window
.
gBrowser
.
addTab
(
url
|
|
window
.
BROWSER_NEW_TAB_URL
options
)
;
let
active
=
true
;
if
(
createProperties
.
active
!
=
=
null
)
{
active
=
createProperties
.
active
;
}
if
(
active
)
{
window
.
gBrowser
.
selectedTab
=
tab
;
}
if
(
createProperties
.
index
!
=
=
null
)
{
window
.
gBrowser
.
moveTabTo
(
tab
createProperties
.
index
)
;
}
if
(
createProperties
.
pinned
)
{
window
.
gBrowser
.
pinTab
(
tab
)
;
}
if
(
createProperties
.
url
&
&
createProperties
.
url
!
=
=
window
.
BROWSER_NEW_TAB_URL
)
{
tabListener
.
initializingTabs
.
add
(
tab
)
;
}
return
tabManager
.
convert
(
tab
)
;
}
)
;
}
async
remove
(
tabs
)
{
if
(
!
Array
.
isArray
(
tabs
)
)
{
tabs
=
[
tabs
]
;
}
for
(
let
tabId
of
tabs
)
{
let
tab
=
tabTracker
.
getTab
(
tabId
)
;
tab
.
ownerGlobal
.
gBrowser
.
removeTab
(
tab
)
;
}
}
async
update
(
tabId
updateProperties
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
let
tabbrowser
=
tab
.
ownerGlobal
.
gBrowser
;
if
(
updateProperties
.
url
!
=
=
null
)
{
let
url
=
context
.
uri
.
resolve
(
updateProperties
.
url
)
;
if
(
!
context
.
checkLoadURL
(
url
{
dontReportErrors
:
true
}
)
)
{
return
Promise
.
reject
(
{
message
:
Illegal
URL
:
{
url
}
}
)
;
}
tab
.
linkedBrowser
.
loadURI
(
url
)
;
}
if
(
updateProperties
.
active
!
=
=
null
)
{
if
(
updateProperties
.
active
)
{
tabbrowser
.
selectedTab
=
tab
;
}
else
{
}
}
if
(
updateProperties
.
muted
!
=
=
null
)
{
if
(
tab
.
muted
!
=
updateProperties
.
muted
)
{
tab
.
toggleMuteAudio
(
extension
.
uuid
)
;
}
}
if
(
updateProperties
.
pinned
!
=
=
null
)
{
if
(
updateProperties
.
pinned
)
{
tabbrowser
.
pinTab
(
tab
)
;
}
else
{
tabbrowser
.
unpinTab
(
tab
)
;
}
}
return
tabManager
.
convert
(
tab
)
;
}
async
reload
(
tabId
reloadProperties
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
let
flags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
reloadProperties
&
&
reloadProperties
.
bypassCache
)
{
flags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
;
}
tab
.
linkedBrowser
.
reloadWithFlags
(
flags
)
;
}
async
get
(
tabId
)
{
let
tab
=
tabTracker
.
getTab
(
tabId
)
;
return
tabManager
.
convert
(
tab
)
;
}
getCurrent
(
)
{
let
tab
;
if
(
context
.
tabId
)
{
tab
=
tabManager
.
get
(
context
.
tabId
)
.
convert
(
)
;
}
return
Promise
.
resolve
(
tab
)
;
}
async
query
(
queryInfo
)
{
if
(
queryInfo
.
url
!
=
=
null
)
{
if
(
!
extension
.
hasPermission
(
"
tabs
"
)
)
{
return
Promise
.
reject
(
{
message
:
'
The
"
tabs
"
permission
is
required
to
use
the
query
API
with
the
"
url
"
parameter
'
}
)
;
}
queryInfo
=
Object
.
assign
(
{
}
queryInfo
)
;
queryInfo
.
url
=
new
MatchPattern
(
queryInfo
.
url
)
;
}
return
Array
.
from
(
tabManager
.
query
(
queryInfo
context
)
tab
=
>
tab
.
convert
(
)
)
;
}
captureVisibleTab
(
windowId
options
)
{
if
(
!
extension
.
hasPermission
(
"
<
all_urls
>
"
)
)
{
return
Promise
.
reject
(
{
message
:
"
The
<
all_urls
>
permission
is
required
to
use
the
captureVisibleTab
API
"
}
)
;
}
let
window
=
windowId
=
=
null
?
windowTracker
.
topWindow
:
windowTracker
.
getWindow
(
windowId
context
)
;
let
tab
=
window
.
gBrowser
.
selectedTab
;
return
tabListener
.
awaitTabReady
(
tab
)
.
then
(
(
)
=
>
{
let
browser
=
tab
.
linkedBrowser
;
let
recipient
=
{
innerWindowID
:
browser
.
innerWindowID
}
;
if
(
!
options
)
{
options
=
{
}
;
}
if
(
options
.
format
=
=
null
)
{
options
.
format
=
"
png
"
;
}
if
(
options
.
quality
=
=
null
)
{
options
.
quality
=
92
;
}
let
message
=
{
options
width
:
browser
.
clientWidth
height
:
browser
.
clientHeight
}
;
return
context
.
sendMessage
(
browser
.
messageManager
"
Extension
:
Capture
"
message
{
recipient
}
)
;
}
)
;
}
async
detectLanguage
(
tabId
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
return
tabListener
.
awaitTabReady
(
tab
)
.
then
(
(
)
=
>
{
let
browser
=
tab
.
linkedBrowser
;
let
recipient
=
{
innerWindowID
:
browser
.
innerWindowID
}
;
return
context
.
sendMessage
(
browser
.
messageManager
"
Extension
:
DetectLanguage
"
{
}
{
recipient
}
)
;
}
)
;
}
async
executeScript
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
executeScript
(
context
details
)
;
}
async
insertCSS
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
insertCSS
(
context
details
)
;
}
async
removeCSS
(
tabId
details
)
{
let
tab
=
await
promiseTabWhenReady
(
tabId
)
;
return
tab
.
removeCSS
(
context
details
)
;
}
async
move
(
tabIds
moveProperties
)
{
let
index
=
moveProperties
.
index
;
let
tabsMoved
=
[
]
;
if
(
!
Array
.
isArray
(
tabIds
)
)
{
tabIds
=
[
tabIds
]
;
}
let
destinationWindow
=
null
;
if
(
moveProperties
.
windowId
!
=
=
null
)
{
destinationWindow
=
windowTracker
.
getWindow
(
moveProperties
.
windowId
)
;
if
(
!
destinationWindow
)
{
return
Promise
.
reject
(
{
message
:
Invalid
window
ID
:
{
moveProperties
.
windowId
}
}
)
;
}
}
let
indexMap
=
new
Map
(
)
;
let
tabs
=
tabIds
.
map
(
tabId
=
>
tabTracker
.
getTab
(
tabId
)
)
;
for
(
let
tab
of
tabs
)
{
let
window
=
destinationWindow
|
|
tab
.
ownerGlobal
;
let
gBrowser
=
window
.
gBrowser
;
let
insertionPoint
=
indexMap
.
get
(
window
)
|
|
index
;
if
(
insertionPoint
=
=
-
1
)
{
insertionPoint
=
gBrowser
.
tabs
.
length
;
}
let
numPinned
=
gBrowser
.
_numPinnedTabs
;
let
ok
=
tab
.
pinned
?
insertionPoint
<
=
numPinned
:
insertionPoint
>
=
numPinned
;
if
(
!
ok
)
{
continue
;
}
indexMap
.
set
(
window
insertionPoint
+
1
)
;
if
(
tab
.
ownerGlobal
!
=
window
)
{
tab
=
gBrowser
.
adoptTab
(
tab
insertionPoint
false
)
;
}
else
{
gBrowser
.
moveTabTo
(
tab
insertionPoint
)
;
}
tabsMoved
.
push
(
tab
)
;
}
return
tabsMoved
.
map
(
tab
=
>
tabManager
.
convert
(
tab
)
)
;
}
duplicate
(
tabId
)
{
let
tab
=
tabTracker
.
getTab
(
tabId
)
;
let
gBrowser
=
tab
.
ownerGlobal
.
gBrowser
;
let
newTab
=
gBrowser
.
duplicateTab
(
tab
)
;
return
new
Promise
(
resolve
=
>
{
newTab
.
addEventListener
(
"
SSTabRestoring
"
function
(
)
{
if
(
tab
.
pinned
)
{
gBrowser
.
pinTab
(
newTab
)
;
}
gBrowser
.
moveTabTo
(
newTab
tab
.
_tPos
+
1
)
;
}
{
once
:
true
}
)
;
newTab
.
addEventListener
(
"
SSTabRestored
"
function
(
)
{
gBrowser
.
selectedTab
=
newTab
;
resolve
(
tabManager
.
convert
(
newTab
)
)
;
}
{
once
:
true
}
)
;
}
)
;
}
getZoom
(
tabId
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
let
{
ZoomManager
}
=
tab
.
ownerGlobal
;
let
zoom
=
ZoomManager
.
getZoomForBrowser
(
tab
.
linkedBrowser
)
;
return
Promise
.
resolve
(
zoom
)
;
}
setZoom
(
tabId
zoom
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
let
{
FullZoom
ZoomManager
}
=
tab
.
ownerGlobal
;
if
(
zoom
=
=
=
0
)
{
return
FullZoom
.
reset
(
tab
.
linkedBrowser
)
;
}
else
if
(
zoom
>
=
ZoomManager
.
MIN
&
&
zoom
<
=
ZoomManager
.
MAX
)
{
FullZoom
.
setZoom
(
zoom
tab
.
linkedBrowser
)
;
}
else
{
return
Promise
.
reject
(
{
message
:
Zoom
value
{
zoom
}
out
of
range
(
must
be
between
{
ZoomManager
.
MIN
}
and
{
ZoomManager
.
MAX
}
)
}
)
;
}
return
Promise
.
resolve
(
)
;
}
_getZoomSettings
(
tabId
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
let
{
FullZoom
}
=
tab
.
ownerGlobal
;
return
{
mode
:
"
automatic
"
scope
:
FullZoom
.
siteSpecific
?
"
per
-
origin
"
:
"
per
-
tab
"
defaultZoomFactor
:
1
}
;
}
getZoomSettings
(
tabId
)
{
return
Promise
.
resolve
(
this
.
_getZoomSettings
(
tabId
)
)
;
}
setZoomSettings
(
tabId
settings
)
{
let
tab
=
getTabOrActive
(
tabId
)
;
let
currentSettings
=
this
.
_getZoomSettings
(
tab
.
id
)
;
if
(
!
Object
.
keys
(
settings
)
.
every
(
key
=
>
settings
[
key
]
=
=
=
currentSettings
[
key
]
)
)
{
return
Promise
.
reject
(
Unsupported
zoom
settings
:
{
JSON
.
stringify
(
settings
)
}
)
;
}
return
Promise
.
resolve
(
)
;
}
onZoomChange
:
new
SingletonEventManager
(
context
"
tabs
.
onZoomChange
"
fire
=
>
{
let
getZoomLevel
=
browser
=
>
{
let
{
ZoomManager
}
=
browser
.
ownerGlobal
;
return
ZoomManager
.
getZoomForBrowser
(
browser
)
;
}
;
let
zoomLevels
=
new
WeakMap
(
)
;
for
(
let
window
of
windowTracker
.
browserWindows
(
)
)
{
for
(
let
tab
of
window
.
gBrowser
.
tabs
)
{
let
browser
=
tab
.
linkedBrowser
;
zoomLevels
.
set
(
browser
getZoomLevel
(
browser
)
)
;
}
}
let
tabCreated
=
(
eventName
event
)
=
>
{
let
browser
=
event
.
tab
.
linkedBrowser
;
zoomLevels
.
set
(
browser
getZoomLevel
(
browser
)
)
;
}
;
let
zoomListener
=
event
=
>
{
let
browser
=
event
.
originalTarget
;
if
(
browser
instanceof
Ci
.
nsIDOMDocument
)
{
browser
=
browser
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
;
}
let
{
gBrowser
}
=
browser
.
ownerGlobal
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
let
oldZoomFactor
=
zoomLevels
.
get
(
browser
)
;
let
newZoomFactor
=
getZoomLevel
(
browser
)
;
if
(
oldZoomFactor
!
=
newZoomFactor
)
{
zoomLevels
.
set
(
browser
newZoomFactor
)
;
let
tabId
=
tabTracker
.
getId
(
tab
)
;
fire
.
async
(
{
tabId
oldZoomFactor
newZoomFactor
zoomSettings
:
self
.
tabs
.
_getZoomSettings
(
tabId
)
}
)
;
}
}
;
tabTracker
.
on
(
"
tab
-
attached
"
tabCreated
)
;
tabTracker
.
on
(
"
tab
-
created
"
tabCreated
)
;
windowTracker
.
addListener
(
"
FullZoomChange
"
zoomListener
)
;
windowTracker
.
addListener
(
"
TextZoomChange
"
zoomListener
)
;
return
(
)
=
>
{
tabTracker
.
off
(
"
tab
-
attached
"
tabCreated
)
;
tabTracker
.
off
(
"
tab
-
created
"
tabCreated
)
;
windowTracker
.
removeListener
(
"
FullZoomChange
"
zoomListener
)
;
windowTracker
.
removeListener
(
"
TextZoomChange
"
zoomListener
)
;
}
;
}
)
.
api
(
)
}
}
;
return
self
;
}
)
;
