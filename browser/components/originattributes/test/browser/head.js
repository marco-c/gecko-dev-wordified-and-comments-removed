"
use
strict
"
;
const
TEST_URL_PATH
=
"
/
browser
/
browser
/
components
/
originattributes
/
test
/
browser
/
"
;
const
TEST_MODE_FIRSTPARTY
=
0
;
const
TEST_MODE_NO_ISOLATION
=
1
;
const
TEST_MODE_CONTAINERS
=
2
;
const
TEST_MODE_NAMES
=
[
"
first
party
isolation
"
"
no
isolation
"
"
containers
"
]
;
const
TEST_TYPE_FRAME
=
0
;
const
TEST_TYPE_IFRAME
=
1
;
const
DEFAULT_FRAME_SETTING
=
[
TEST_TYPE_IFRAME
]
;
let
gFirstPartyBasicPage
=
TEST_URL_PATH
+
"
file_firstPartyBasic
.
html
"
;
async
function
openTabInUserContext
(
aURL
aUserContextId
)
{
let
originAttributes
=
{
userContextId
:
aUserContextId
}
;
let
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
makeURI
(
aURL
)
originAttributes
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
aURL
{
userContextId
:
aUserContextId
triggeringPrincipal
}
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
return
{
tab
browser
}
;
}
async
function
openTabInFirstParty
(
aURL
aFirstPartyDomain
aFrameSetting
=
DEFAULT_FRAME_SETTING
)
{
if
(
aFirstPartyDomain
.
endsWith
(
"
/
"
)
)
{
aFirstPartyDomain
=
aFirstPartyDomain
.
slice
(
0
-
1
)
;
}
let
basicPageURL
=
aFirstPartyDomain
+
gFirstPartyBasicPage
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
basicPageURL
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
pageArgs
=
{
url
:
aURL
frames
:
aFrameSetting
typeFrame
:
TEST_TYPE_FRAME
typeIFrame
:
TEST_TYPE_IFRAME
basicFrameSrc
:
basicPageURL
}
;
await
ContentTask
.
spawn
(
browser
pageArgs
async
function
(
arg
)
{
let
typeFrame
=
arg
.
typeFrame
;
let
typeIFrame
=
arg
.
typeIFrame
;
this
.
frameWindow
=
content
;
Object
.
defineProperty
(
this
"
content
"
{
get
:
(
)
=
>
this
.
frameWindow
}
)
;
let
frameElement
;
let
numOfLayers
=
0
;
for
(
let
type
of
arg
.
frames
)
{
let
document
=
content
.
document
;
numOfLayers
+
+
;
if
(
type
=
=
=
typeFrame
)
{
let
frameSet
=
document
.
createElement
(
"
frameset
"
)
;
frameSet
.
cols
=
"
50
%
50
%
"
;
let
frame
=
document
.
createElement
(
"
frame
"
)
;
let
dummyFrame
=
document
.
createElement
(
"
frame
"
)
;
frameSet
.
appendChild
(
frame
)
;
frameSet
.
appendChild
(
dummyFrame
)
;
document
.
body
.
appendChild
(
frameSet
)
;
frameElement
=
frame
;
}
else
if
(
type
=
=
=
typeIFrame
)
{
let
iframe
=
document
.
createElement
(
"
iframe
"
)
;
document
.
body
.
appendChild
(
iframe
)
;
frameElement
=
iframe
;
}
else
{
ok
(
false
"
Invalid
frame
type
.
"
)
;
break
;
}
await
new
Promise
(
done
=
>
{
frameElement
.
addEventListener
(
"
load
"
function
(
)
{
done
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
if
(
numOfLayers
=
=
=
arg
.
frames
.
length
)
{
frameElement
.
setAttribute
(
"
src
"
arg
.
url
)
;
}
else
{
frameElement
.
setAttribute
(
"
src
"
arg
.
basicFrameSrc
)
;
}
}
)
;
this
.
frameWindow
=
frameElement
.
contentWindow
;
}
}
)
;
return
{
tab
browser
}
;
}
this
.
IsolationTestTools
=
{
_add_task
(
aTask
)
{
let
testSettings
=
[
{
mode
:
TEST_MODE_FIRSTPARTY
skip
:
false
prefs
:
[
[
"
privacy
.
firstparty
.
isolate
"
true
]
]
}
{
mode
:
TEST_MODE_NO_ISOLATION
skip
:
false
prefs
:
[
[
"
privacy
.
firstparty
.
isolate
"
false
]
]
}
{
mode
:
TEST_MODE_CONTAINERS
skip
:
false
prefs
:
[
[
"
privacy
.
userContext
.
enabled
"
true
]
]
}
]
;
for
(
let
testSetting
of
testSettings
)
{
IsolationTestTools
.
_addTaskForMode
(
testSetting
.
mode
testSetting
.
prefs
testSetting
.
skip
aTask
)
;
}
}
_addTaskForMode
(
aMode
aPref
aSkip
aTask
)
{
if
(
aSkip
)
{
return
;
}
add_task
(
async
function
(
)
{
info
(
"
Starting
the
test
for
"
+
TEST_MODE_NAMES
[
aMode
]
)
;
await
SpecialPowers
.
flushPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
aPref
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processCount
"
1
]
]
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
network
.
auth
.
non
-
web
-
content
-
triggered
-
resources
-
http
-
auth
-
allow
"
true
]
]
}
)
;
await
aTask
(
aMode
)
;
}
)
;
}
_addTab
(
aMode
aURL
aTabSettingObj
aFrameSetting
)
{
if
(
aMode
=
=
=
TEST_MODE_CONTAINERS
)
{
return
openTabInUserContext
(
aURL
aTabSettingObj
.
userContextId
)
;
}
return
openTabInFirstParty
(
aURL
aTabSettingObj
.
firstPartyDomain
aFrameSetting
)
;
}
runTests
(
aURL
aGetResultFuncs
aCompareResultFunc
aBeforeFunc
aGetResultImmediately
aUseHttps
)
{
let
pageURL
;
let
firstFrameSetting
;
let
secondFrameSetting
;
requestLongerTimeout
(
3
)
;
if
(
typeof
aURL
=
=
=
"
string
"
)
{
pageURL
=
aURL
;
}
else
if
(
typeof
aURL
=
=
=
"
object
"
)
{
pageURL
=
aURL
.
url
;
firstFrameSetting
=
aURL
.
firstFrameSetting
;
secondFrameSetting
=
aURL
.
secondFrameSetting
;
}
if
(
!
Array
.
isArray
(
aGetResultFuncs
)
)
{
aGetResultFuncs
=
[
aGetResultFuncs
]
;
}
let
tabSettings
=
aUseHttps
?
[
{
firstPartyDomain
:
"
https
:
/
/
example
.
com
"
userContextId
:
1
}
{
firstPartyDomain
:
"
https
:
/
/
example
.
org
"
userContextId
:
2
}
]
:
[
{
firstPartyDomain
:
"
http
:
/
/
example
.
com
"
userContextId
:
1
}
{
firstPartyDomain
:
"
http
:
/
/
example
.
org
"
userContextId
:
2
}
]
;
this
.
_add_task
(
async
function
(
aMode
)
{
let
tabSettingA
=
0
;
for
(
let
tabSettingB
of
[
0
1
]
)
{
if
(
aBeforeFunc
)
{
await
aBeforeFunc
(
aMode
)
;
}
let
tabInfoA
=
await
IsolationTestTools
.
_addTab
(
aMode
pageURL
tabSettings
[
tabSettingA
]
firstFrameSetting
)
;
let
resultsA
=
[
]
;
if
(
aGetResultImmediately
)
{
for
(
let
getResultFunc
of
aGetResultFuncs
)
{
resultsA
.
push
(
await
getResultFunc
(
tabInfoA
.
browser
)
)
;
}
}
let
tabInfoB
=
await
IsolationTestTools
.
_addTab
(
aMode
pageURL
tabSettings
[
tabSettingB
]
secondFrameSetting
)
;
let
i
=
0
;
for
(
let
getResultFunc
of
aGetResultFuncs
)
{
let
resultA
=
aGetResultImmediately
?
resultsA
[
i
+
+
]
:
await
getResultFunc
(
tabInfoA
.
browser
)
;
let
resultB
=
await
getResultFunc
(
tabInfoB
.
browser
)
;
let
result
=
false
;
let
shouldIsolate
=
aMode
!
=
=
TEST_MODE_NO_ISOLATION
&
&
tabSettingA
!
=
=
tabSettingB
;
if
(
aCompareResultFunc
)
{
result
=
await
aCompareResultFunc
(
shouldIsolate
resultA
resultB
)
;
}
else
{
result
=
shouldIsolate
?
resultA
!
=
=
resultB
:
resultA
=
=
=
resultB
;
}
let
msg
=
Testing
{
TEST_MODE_NAMES
[
aMode
]
}
for
+
isolation
{
shouldIsolate
?
"
on
"
:
"
off
"
}
with
TabSettingA
+
{
tabSettingA
}
and
tabSettingB
{
tabSettingB
}
+
resultA
=
{
resultA
}
resultB
=
{
resultB
}
;
ok
(
result
msg
)
;
}
BrowserTestUtils
.
removeTab
(
tabInfoA
.
tab
)
;
BrowserTestUtils
.
removeTab
(
tabInfoB
.
tab
)
;
}
}
)
;
}
}
;
