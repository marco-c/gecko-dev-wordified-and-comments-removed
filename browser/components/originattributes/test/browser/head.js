'
use
strict
'
;
const
TEST_URL_PATH
=
"
/
browser
/
browser
/
components
/
originattributes
/
test
/
browser
/
"
;
const
TEST_MODE_FIRSTPARTY
=
0
;
const
TEST_MODE_NO_ISOLATION
=
1
;
const
TEST_MODE_CONTAINERS
=
2
;
const
TEST_MODE_NAMES
=
[
"
first
party
isolation
"
"
no
isolation
"
"
containers
"
]
;
const
TEST_TYPE_FRAME
=
0
;
const
TEST_TYPE_IFRAME
=
1
;
const
DEFAULT_FRAME_SETTING
=
[
TEST_TYPE_IFRAME
]
;
let
gFirstPartyBasicPage
=
TEST_URL_PATH
+
"
file_firstPartyBasic
.
html
"
;
function
*
openTabInUserContext
(
aURL
aUserContextId
)
{
let
tab
=
gBrowser
.
addTab
(
aURL
{
userContextId
:
aUserContextId
}
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
yield
BrowserTestUtils
.
browserLoaded
(
browser
)
;
return
{
tab
browser
}
;
}
function
*
openTabInFirstParty
(
aURL
aFirstPartyDomain
aFrameSetting
=
DEFAULT_FRAME_SETTING
)
{
if
(
aFirstPartyDomain
.
endsWith
(
'
/
'
)
)
{
aFirstPartyDomain
=
aFirstPartyDomain
.
slice
(
0
-
1
)
;
}
let
basicPageURL
=
aFirstPartyDomain
+
gFirstPartyBasicPage
;
let
tab
=
gBrowser
.
addTab
(
basicPageURL
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
yield
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
pageArgs
=
{
url
:
aURL
frames
:
aFrameSetting
typeFrame
:
TEST_TYPE_FRAME
typeIFrame
:
TEST_TYPE_IFRAME
basicFrameSrc
:
basicPageURL
}
;
yield
ContentTask
.
spawn
(
browser
pageArgs
function
*
(
arg
)
{
let
typeFrame
=
arg
.
typeFrame
;
let
typeIFrame
=
arg
.
typeIFrame
;
this
.
frameWindow
=
content
;
Object
.
defineProperty
(
this
"
content
"
{
get
:
(
)
=
>
this
.
frameWindow
}
)
;
let
frameElement
;
let
numOfLayers
=
0
;
for
(
let
type
of
arg
.
frames
)
{
let
document
=
content
.
document
;
numOfLayers
+
+
;
if
(
type
=
=
=
typeFrame
)
{
let
frameSet
=
document
.
createElement
(
'
frameset
'
)
;
frameSet
.
cols
=
"
50
%
50
%
"
;
let
frame
=
document
.
createElement
(
'
frame
'
)
;
let
dummyFrame
=
document
.
createElement
(
'
frame
'
)
;
frameSet
.
appendChild
(
frame
)
;
frameSet
.
appendChild
(
dummyFrame
)
;
document
.
body
.
appendChild
(
frameSet
)
;
frameElement
=
frame
;
}
else
if
(
type
=
=
=
typeIFrame
)
{
let
iframe
=
document
.
createElement
(
'
iframe
'
)
;
document
.
body
.
appendChild
(
iframe
)
;
frameElement
=
iframe
;
}
else
{
ok
(
false
"
Invalid
frame
type
.
"
)
;
break
;
}
yield
new
Promise
(
done
=
>
{
frameElement
.
addEventListener
(
"
load
"
function
loadEnd
(
)
{
frameElement
.
removeEventListener
(
"
load
"
loadEnd
true
)
;
done
(
)
;
}
true
)
;
if
(
numOfLayers
=
=
=
arg
.
frames
.
length
)
{
frameElement
.
setAttribute
(
"
src
"
arg
.
url
)
;
}
else
{
frameElement
.
setAttribute
(
"
src
"
arg
.
basicFrameSrc
)
;
}
}
)
;
this
.
frameWindow
=
frameElement
.
contentWindow
;
}
}
)
;
return
{
tab
browser
}
;
}
this
.
IsolationTestTools
=
{
_add_task
(
aTask
)
{
add_task
(
function
*
addTaskForIsolationTests
(
)
{
let
testSettings
=
[
{
mode
:
TEST_MODE_FIRSTPARTY
skip
:
false
prefs
:
[
[
"
privacy
.
firstparty
.
isolate
"
true
]
]
}
{
mode
:
TEST_MODE_NO_ISOLATION
skip
:
false
prefs
:
[
[
"
privacy
.
firstparty
.
isolate
"
false
]
]
}
{
mode
:
TEST_MODE_CONTAINERS
skip
:
false
prefs
:
[
[
"
privacy
.
userContext
.
enabled
"
true
]
]
}
]
;
for
(
let
testSetting
of
testSettings
)
{
IsolationTestTools
.
_addTaskForMode
(
testSetting
.
mode
testSetting
.
prefs
testSetting
.
skip
aTask
)
;
}
}
)
;
}
_addTaskForMode
(
aMode
aPref
aSkip
aTask
)
{
if
(
aSkip
)
{
return
;
}
add_task
(
function
*
(
)
{
info
(
"
Starting
the
test
for
"
+
TEST_MODE_NAMES
[
aMode
]
)
;
yield
SpecialPowers
.
flushPrefEnv
(
)
;
yield
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
aPref
}
)
;
yield
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
dom
.
ipc
.
processCount
"
1
]
]
}
)
;
yield
aTask
(
aMode
)
;
}
)
;
}
_addTab
(
aMode
aURL
aTabSettingObj
aFrameSetting
)
{
if
(
aMode
=
=
=
TEST_MODE_CONTAINERS
)
{
return
openTabInUserContext
(
aURL
aTabSettingObj
.
userContextId
)
;
}
return
openTabInFirstParty
(
aURL
aTabSettingObj
.
firstPartyDomain
aFrameSetting
)
;
}
runTests
(
aURL
aGetResultFuncs
aCompareResultFunc
aBeforeFunc
)
{
let
pageURL
;
let
firstFrameSetting
;
let
secondFrameSetting
;
if
(
typeof
aURL
=
=
=
"
string
"
)
{
pageURL
=
aURL
;
}
else
if
(
typeof
aURL
=
=
=
"
object
"
)
{
pageURL
=
aURL
.
url
;
firstFrameSetting
=
aURL
.
firstFrameSetting
;
secondFrameSetting
=
aURL
.
secondFrameSetting
;
}
if
(
!
Array
.
isArray
(
aGetResultFuncs
)
)
{
aGetResultFuncs
=
[
aGetResultFuncs
]
;
}
let
tabSettings
=
[
{
firstPartyDomain
:
"
http
:
/
/
example
.
com
"
userContextId
:
1
}
{
firstPartyDomain
:
"
http
:
/
/
example
.
org
"
userContextId
:
2
}
]
;
this
.
_add_task
(
function
*
(
aMode
)
{
let
tabSettingA
=
0
;
for
(
let
tabSettingB
of
[
0
1
]
)
{
if
(
aBeforeFunc
)
{
yield
aBeforeFunc
(
)
;
}
let
tabInfoA
=
yield
IsolationTestTools
.
_addTab
(
aMode
pageURL
tabSettings
[
tabSettingA
]
firstFrameSetting
)
;
let
tabInfoB
=
yield
IsolationTestTools
.
_addTab
(
aMode
pageURL
tabSettings
[
tabSettingB
]
secondFrameSetting
)
;
for
(
let
getResultFunc
of
aGetResultFuncs
)
{
let
resultA
=
yield
getResultFunc
(
tabInfoA
.
browser
)
;
let
resultB
=
yield
getResultFunc
(
tabInfoB
.
browser
)
;
let
result
=
false
;
let
shouldIsolate
=
(
aMode
!
=
=
TEST_MODE_NO_ISOLATION
)
&
&
tabSettingA
!
=
=
tabSettingB
;
if
(
aCompareResultFunc
)
{
result
=
yield
aCompareResultFunc
(
shouldIsolate
resultA
resultB
)
;
}
else
{
result
=
shouldIsolate
?
resultA
!
=
=
resultB
:
resultA
=
=
=
resultB
;
}
let
msg
=
Testing
{
TEST_MODE_NAMES
[
aMode
]
}
for
+
isolation
{
shouldIsolate
?
"
on
"
:
"
off
"
}
with
TabSettingA
+
{
tabSettingA
}
and
tabSettingB
{
tabSettingB
}
+
resultA
=
{
resultA
}
resultB
=
{
resultB
}
;
ok
(
result
msg
)
;
}
yield
BrowserTestUtils
.
removeTab
(
tabInfoA
.
tab
)
;
yield
BrowserTestUtils
.
removeTab
(
tabInfoB
.
tab
)
;
}
}
)
;
}
}
;
