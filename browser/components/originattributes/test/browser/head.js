"
use
strict
"
;
const
TEST_URL_PATH
=
"
/
browser
/
browser
/
components
/
originattributes
/
test
/
browser
/
"
;
const
TEST_MODE_FIRSTPARTY
=
0
;
const
TEST_MODE_NO_ISOLATION
=
1
;
const
TEST_MODE_CONTAINERS
=
2
;
const
TEST_MODE_NAMES
=
[
"
first
party
isolation
"
"
no
isolation
"
"
containers
"
]
;
const
TEST_TYPE_FRAME
=
1
;
const
TEST_TYPE_IFRAME
=
2
;
const
DEFAULT_FRAME_SETTING
=
[
TEST_TYPE_IFRAME
]
;
let
gFirstPartyBasicPage
=
TEST_URL_PATH
+
"
file_firstPartyBasic
.
html
"
;
async
function
openTabInUserContext
(
aURL
aUserContextId
)
{
info
(
Start
to
open
tab
in
specific
userContextID
:
{
aUserContextId
}
.
)
;
let
originAttributes
=
{
userContextId
:
aUserContextId
}
;
info
(
"
Create
triggeringPrincipal
.
"
)
;
let
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
makeURI
(
aURL
)
originAttributes
)
;
info
(
"
Open
the
tab
and
wait
for
it
to
be
loaded
.
"
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
aURL
{
userContextId
:
aUserContextId
triggeringPrincipal
}
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
info
(
"
Finished
tab
opening
.
"
)
;
return
{
tab
browser
}
;
}
async
function
openTabInFirstParty
(
aURL
aFirstPartyDomain
aFrameSetting
=
DEFAULT_FRAME_SETTING
)
{
info
(
Start
to
open
tab
under
first
party
domain
"
{
aFirstPartyDomain
}
"
.
)
;
if
(
aFirstPartyDomain
.
endsWith
(
"
/
"
)
)
{
aFirstPartyDomain
=
aFirstPartyDomain
.
slice
(
0
-
1
)
;
}
let
basicPageURL
=
aFirstPartyDomain
+
gFirstPartyBasicPage
;
info
(
"
Open
the
tab
and
then
wait
for
it
to
be
loaded
.
"
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
basicPageURL
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
frameSetting
=
aFrameSetting
.
slice
(
0
)
;
let
frameType
;
let
targetBrowsingContext
;
info
(
"
Create
the
frame
structure
.
"
)
;
while
(
(
frameType
=
frameSetting
.
shift
(
)
)
)
{
if
(
!
targetBrowsingContext
)
{
targetBrowsingContext
=
browser
;
}
let
frameURL
=
!
frameSetting
.
length
?
aURL
:
basicPageURL
;
if
(
frameType
=
=
TEST_TYPE_FRAME
)
{
info
(
"
Add
the
frameset
.
"
)
;
targetBrowsingContext
=
await
SpecialPowers
.
spawn
(
targetBrowsingContext
[
frameURL
]
async
function
(
aFrameURL
)
{
let
frameSet
=
content
.
document
.
createElement
(
"
frameset
"
)
;
frameSet
.
cols
=
"
50
%
50
%
"
;
let
frame
=
content
.
document
.
createElement
(
"
frame
"
)
;
let
dummyFrame
=
content
.
document
.
createElement
(
"
frame
"
)
;
frameSet
.
appendChild
(
frame
)
;
frameSet
.
appendChild
(
dummyFrame
)
;
content
.
document
.
body
.
appendChild
(
frameSet
)
;
await
new
Promise
(
done
=
>
{
frame
.
addEventListener
(
"
load
"
function
(
)
{
done
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
frame
.
setAttribute
(
"
src
"
aFrameURL
)
;
}
)
;
return
frame
.
browsingContext
;
}
)
;
}
else
if
(
frameType
=
=
TEST_TYPE_IFRAME
)
{
info
(
"
Add
the
iframe
.
"
)
;
targetBrowsingContext
=
await
SpecialPowers
.
spawn
(
targetBrowsingContext
[
frameURL
]
async
function
(
aFrameURL
)
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
await
new
Promise
(
done
=
>
{
frame
.
addEventListener
(
"
load
"
function
(
)
{
done
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
frame
.
setAttribute
(
"
src
"
aFrameURL
)
;
}
)
;
return
frame
.
browsingContext
;
}
)
;
}
else
{
ok
(
false
"
Invalid
frame
type
.
"
)
;
break
;
}
info
(
"
Successfully
added
a
frame
"
)
;
}
info
(
"
Finished
the
frame
structure
"
)
;
return
{
tab
browser
:
targetBrowsingContext
}
;
}
this
.
IsolationTestTools
=
{
_add_task
(
aTask
)
{
let
testSettings
=
[
{
mode
:
TEST_MODE_FIRSTPARTY
skip
:
false
prefs
:
[
[
"
privacy
.
firstparty
.
isolate
"
true
]
]
}
{
mode
:
TEST_MODE_NO_ISOLATION
skip
:
false
prefs
:
[
[
"
privacy
.
firstparty
.
isolate
"
false
]
]
}
{
mode
:
TEST_MODE_CONTAINERS
skip
:
false
prefs
:
[
[
"
privacy
.
userContext
.
enabled
"
true
]
]
}
]
;
for
(
let
testSetting
of
testSettings
)
{
IsolationTestTools
.
_addTaskForMode
(
testSetting
.
mode
testSetting
.
prefs
testSetting
.
skip
aTask
)
;
}
}
_addTaskForMode
(
aMode
aPref
aSkip
aTask
)
{
if
(
aSkip
)
{
return
;
}
add_task
(
async
function
(
)
{
info
(
Starting
the
test
for
{
TEST_MODE_NAMES
[
aMode
]
}
.
)
;
await
SpecialPowers
.
flushPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
aPref
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processCount
"
1
]
]
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
network
.
auth
.
non
-
web
-
content
-
triggered
-
resources
-
http
-
auth
-
allow
"
true
]
]
}
)
;
await
aTask
(
aMode
)
;
}
)
;
}
_addTab
(
aMode
aURL
aTabSettingObj
aFrameSetting
)
{
if
(
aMode
=
=
=
TEST_MODE_CONTAINERS
)
{
return
openTabInUserContext
(
aURL
aTabSettingObj
.
userContextId
)
;
}
return
openTabInFirstParty
(
aURL
aTabSettingObj
.
firstPartyDomain
aFrameSetting
)
;
}
runTests
(
aURL
aGetResultFuncs
aCompareResultFunc
aBeforeFunc
aGetResultImmediately
aUseHttps
)
{
let
pageURL
;
let
firstFrameSetting
;
let
secondFrameSetting
;
requestLongerTimeout
(
3
)
;
if
(
typeof
aURL
=
=
=
"
string
"
)
{
pageURL
=
aURL
;
}
else
if
(
typeof
aURL
=
=
=
"
object
"
)
{
pageURL
=
aURL
.
url
;
firstFrameSetting
=
aURL
.
firstFrameSetting
;
secondFrameSetting
=
aURL
.
secondFrameSetting
;
}
if
(
!
Array
.
isArray
(
aGetResultFuncs
)
)
{
aGetResultFuncs
=
[
aGetResultFuncs
]
;
}
let
tabSettings
=
aUseHttps
?
[
{
firstPartyDomain
:
"
https
:
/
/
example
.
com
"
userContextId
:
1
}
{
firstPartyDomain
:
"
https
:
/
/
example
.
org
"
userContextId
:
2
}
]
:
[
{
firstPartyDomain
:
"
http
:
/
/
example
.
com
"
userContextId
:
1
}
{
firstPartyDomain
:
"
http
:
/
/
example
.
org
"
userContextId
:
2
}
]
;
this
.
_add_task
(
async
function
(
aMode
)
{
let
tabSettingA
=
0
;
for
(
let
tabSettingB
of
[
0
1
]
)
{
if
(
aBeforeFunc
)
{
try
{
await
aBeforeFunc
(
aMode
)
;
}
catch
(
e
)
{
ok
(
false
Caught
error
while
doing
testing
setup
:
{
e
}
.
)
;
}
}
info
(
Create
tab
A
for
{
TEST_MODE_NAMES
[
aMode
]
}
test
.
)
;
let
tabInfoA
=
await
IsolationTestTools
.
_addTab
(
aMode
pageURL
tabSettings
[
tabSettingA
]
firstFrameSetting
)
;
info
(
Finished
Create
tab
A
for
{
TEST_MODE_NAMES
[
aMode
]
}
test
.
)
;
let
resultsA
=
[
]
;
if
(
aGetResultImmediately
)
{
try
{
info
(
Immediately
get
result
from
tab
A
for
{
TEST_MODE_NAMES
[
aMode
]
}
test
)
;
for
(
let
getResultFunc
of
aGetResultFuncs
)
{
resultsA
.
push
(
await
getResultFunc
(
tabInfoA
.
browser
)
)
;
}
}
catch
(
e
)
{
ok
(
false
Caught
error
while
getting
result
from
Tab
A
:
{
e
}
.
)
;
}
}
info
(
Create
tab
B
for
{
TEST_MODE_NAMES
[
aMode
]
}
.
)
;
let
tabInfoB
=
await
IsolationTestTools
.
_addTab
(
aMode
pageURL
tabSettings
[
tabSettingB
]
secondFrameSetting
)
;
info
(
Finished
Create
tab
B
for
{
TEST_MODE_NAMES
[
aMode
]
}
test
.
)
;
let
i
=
0
;
for
(
let
getResultFunc
of
aGetResultFuncs
)
{
info
(
Fetching
result
from
tab
A
for
{
TEST_MODE_NAMES
[
aMode
]
}
.
)
;
let
resultA
;
try
{
resultA
=
aGetResultImmediately
?
resultsA
[
i
+
+
]
:
await
getResultFunc
(
tabInfoA
.
browser
)
;
}
catch
(
e
)
{
ok
(
false
Caught
error
while
getting
result
from
Tab
A
:
{
e
}
.
)
;
}
info
(
Fetching
result
from
tab
B
for
{
TEST_MODE_NAMES
[
aMode
]
}
.
)
;
let
resultB
;
try
{
resultB
=
await
getResultFunc
(
tabInfoB
.
browser
)
;
}
catch
(
e
)
{
ok
(
false
Caught
error
while
getting
result
from
Tab
B
:
{
e
}
.
)
;
}
let
result
=
false
;
let
shouldIsolate
=
aMode
!
=
=
TEST_MODE_NO_ISOLATION
&
&
tabSettingA
!
=
=
tabSettingB
;
if
(
aCompareResultFunc
)
{
result
=
await
aCompareResultFunc
(
shouldIsolate
resultA
resultB
)
;
}
else
{
result
=
shouldIsolate
?
resultA
!
=
=
resultB
:
resultA
=
=
=
resultB
;
}
let
msg
=
Result
of
Testing
{
TEST_MODE_NAMES
[
aMode
]
}
for
+
isolation
{
shouldIsolate
?
"
on
"
:
"
off
"
}
with
TabSettingA
+
{
tabSettingA
}
and
tabSettingB
{
tabSettingB
}
+
resultA
=
{
resultA
}
resultB
=
{
resultB
}
;
ok
(
result
msg
)
;
}
BrowserTestUtils
.
removeTab
(
tabInfoA
.
tab
)
;
BrowserTestUtils
.
removeTab
(
tabInfoB
.
tab
)
;
if
(
SpecialPowers
.
useRemoteSubframes
)
{
await
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
)
=
>
{
if
(
topic
=
=
=
"
ipc
:
content
-
shutdown
"
)
{
Services
.
obs
.
removeObserver
(
observer
"
ipc
:
content
-
shutdown
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
ipc
:
content
-
shutdown
"
)
;
}
)
;
}
}
}
)
;
}
}
;
