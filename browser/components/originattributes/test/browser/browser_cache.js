const
{
classes
:
Cc
Constructor
:
CC
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
let
{
LoadContextInfo
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoadContextInfo
.
jsm
"
{
}
)
;
let
protocolProxyService
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
]
.
getService
(
Ci
.
nsIProtocolProxyService
)
;
const
TEST_DOMAIN
=
"
http
:
/
/
example
.
net
"
;
const
TEST_PATH
=
"
/
browser
/
browser
/
components
/
originattributes
/
test
/
browser
/
"
;
const
TEST_PAGE
=
TEST_DOMAIN
+
TEST_PATH
+
"
file_cache
.
html
"
;
let
suffixes
=
[
"
iframe
.
html
"
"
link
.
css
"
"
script
.
js
"
"
img
.
png
"
"
object
.
png
"
"
embed
.
png
"
"
xhr
.
html
"
"
worker
.
xhr
.
html
"
"
audio
.
ogg
"
"
video
.
ogv
"
"
track
.
vtt
"
"
fetch
.
html
"
"
worker
.
fetch
.
html
"
"
request
.
html
"
"
worker
.
request
.
html
"
"
import
.
js
"
"
worker
.
js
"
"
sharedworker
.
js
"
]
;
let
randomSuffix
;
function
clearAllImageCaches
(
)
{
let
tools
=
SpecialPowers
.
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
SpecialPowers
.
Ci
.
imgITools
)
;
let
imageCache
=
tools
.
getImgCacheForDocument
(
window
.
document
)
;
imageCache
.
clearCache
(
true
)
;
imageCache
.
clearCache
(
false
)
;
}
function
cacheDataForContext
(
loadContextInfo
)
{
return
new
Promise
(
resolve
=
>
{
let
cacheEntries
=
[
]
;
let
cacheVisitor
=
{
onCacheStorageInfo
(
num
consumption
)
{
}
onCacheEntryInfo
(
uri
idEnhance
)
{
cacheEntries
.
push
(
{
uri
idEnhance
}
)
;
}
onCacheEntryVisitCompleted
(
)
{
resolve
(
cacheEntries
)
;
}
QueryInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsICacheStorageVisitor
)
)
return
this
;
throw
Components
.
results
.
NS_ERROR_NO_INTERFACE
;
}
}
;
let
storage
=
Services
.
cache2
.
diskCacheStorage
(
loadContextInfo
false
)
;
storage
.
asyncVisitStorage
(
cacheVisitor
true
)
;
}
)
;
}
let
countMatchingCacheEntries
=
function
(
cacheEntries
domain
fileSuffix
)
{
return
cacheEntries
.
map
(
entry
=
>
entry
.
uri
.
asciiSpec
)
.
filter
(
spec
=
>
spec
.
includes
(
domain
)
)
.
filter
(
spec
=
>
spec
.
includes
(
"
file_thirdPartyChild
.
"
+
fileSuffix
)
)
.
length
;
}
;
function
observeChannels
(
onChannel
)
{
let
proxyFilter
=
{
applyFilter
(
aProxyService
aChannel
aProxy
)
{
onChannel
(
aChannel
)
;
return
aProxy
;
}
}
;
protocolProxyService
.
registerChannelFilter
(
proxyFilter
0
)
;
return
(
)
=
>
protocolProxyService
.
unregisterChannelFilter
(
proxyFilter
)
;
}
function
startObservingChannels
(
aMode
)
{
let
stopObservingChannels
=
observeChannels
(
function
(
channel
)
{
let
originalURISpec
=
channel
.
originalURI
.
spec
;
if
(
originalURISpec
.
includes
(
"
example
.
net
"
)
)
{
let
loadInfo
=
channel
.
loadInfo
;
switch
(
aMode
)
{
case
TEST_MODE_FIRSTPARTY
:
ok
(
loadInfo
.
originAttributes
.
firstPartyDomain
=
=
=
"
example
.
com
"
|
|
loadInfo
.
originAttributes
.
firstPartyDomain
=
=
=
"
example
.
org
"
"
first
party
for
"
+
originalURISpec
+
"
is
"
+
loadInfo
.
originAttributes
.
firstPartyDomain
)
;
break
;
case
TEST_MODE_NO_ISOLATION
:
ok
(
ChromeUtils
.
isOriginAttributesEqual
(
loadInfo
.
originAttributes
ChromeUtils
.
fillNonDefaultOriginAttributes
(
)
)
"
OriginAttributes
for
"
+
originalURISpec
+
"
is
default
.
"
)
;
break
;
case
TEST_MODE_CONTAINERS
:
ok
(
loadInfo
.
originAttributes
.
userContextId
=
=
=
1
|
|
loadInfo
.
originAttributes
.
userContextId
=
=
=
2
"
userContextId
for
"
+
originalURISpec
+
"
is
"
+
loadInfo
.
originAttributes
.
userContextId
)
;
break
;
default
:
ok
(
false
"
Unknown
test
mode
.
"
)
;
}
}
}
)
;
return
stopObservingChannels
;
}
let
stopObservingChannels
;
function
*
doInit
(
aMode
)
{
yield
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
network
.
predictor
.
enabled
"
false
]
[
"
network
.
predictor
.
enable
-
prefetch
"
false
]
]
}
)
;
clearAllImageCaches
(
)
;
let
networkCache
=
Cc
[
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
]
.
getService
(
Ci
.
nsICacheStorageService
)
;
networkCache
.
clear
(
)
;
randomSuffix
=
Math
.
random
(
)
;
stopObservingChannels
=
startObservingChannels
(
aMode
)
;
}
function
*
doTest
(
aBrowser
)
{
let
argObj
=
{
randomSuffix
urlPrefix
:
TEST_DOMAIN
+
TEST_PATH
}
;
yield
ContentTask
.
spawn
(
aBrowser
argObj
function
*
(
arg
)
{
let
videoURL
=
arg
.
urlPrefix
+
"
file_thirdPartyChild
.
video
.
ogv
"
;
let
audioURL
=
arg
.
urlPrefix
+
"
file_thirdPartyChild
.
audio
.
ogg
"
;
let
trackURL
=
arg
.
urlPrefix
+
"
file_thirdPartyChild
.
track
.
vtt
"
;
let
URLSuffix
=
"
?
r
=
"
+
arg
.
randomSuffix
;
let
audio
=
content
.
document
.
createElement
(
'
audio
'
)
;
let
video
=
content
.
document
.
createElement
(
'
video
'
)
;
let
audioSource
=
content
.
document
.
createElement
(
'
source
'
)
;
let
audioTrack
=
content
.
document
.
createElement
(
'
track
'
)
;
yield
new
Promise
(
resolve
=
>
{
let
audioLoaded
=
false
;
let
trackLoaded
=
false
;
let
audioListener
=
(
)
=
>
{
audio
.
removeEventListener
(
"
canplaythrough
"
audioListener
)
;
audioLoaded
=
true
;
if
(
audioLoaded
&
&
trackLoaded
)
{
resolve
(
)
;
}
}
;
let
trackListener
=
(
)
=
>
{
audioTrack
.
removeEventListener
(
"
load
"
trackListener
)
;
trackLoaded
=
true
;
if
(
audioLoaded
&
&
trackLoaded
)
{
resolve
(
)
;
}
}
;
audioTrack
.
addEventListener
(
"
load
"
trackListener
false
)
;
audio
.
addEventListener
(
"
canplaythrough
"
audioListener
false
)
;
audioSource
.
setAttribute
(
"
src
"
audioURL
+
URLSuffix
)
;
audioSource
.
setAttribute
(
"
type
"
"
audio
/
ogg
"
)
;
audioTrack
.
setAttribute
(
"
src
"
trackURL
)
;
audioTrack
.
setAttribute
(
"
kind
"
"
subtitles
"
)
;
audio
.
appendChild
(
audioSource
)
;
audio
.
appendChild
(
audioTrack
)
;
audio
.
autoplay
=
true
;
content
.
document
.
body
.
appendChild
(
audio
)
;
}
)
;
yield
new
Promise
(
resolve
=
>
{
let
listener
=
(
)
=
>
{
video
.
removeEventListener
(
"
canplaythrough
"
listener
)
;
resolve
(
)
;
}
;
video
.
addEventListener
(
"
canplaythrough
"
listener
false
)
;
video
.
setAttribute
(
"
src
"
videoURL
+
URLSuffix
)
;
video
.
setAttribute
(
"
type
"
"
video
/
ogg
"
)
;
content
.
document
.
body
.
appendChild
(
video
)
;
}
)
;
}
)
;
return
0
;
}
function
*
doCheck
(
aShouldIsolate
aInputA
aInputB
)
{
let
expectedEntryCount
=
1
;
let
data
=
[
]
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
default
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
private
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
true
{
}
)
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
false
{
userContextId
:
1
}
)
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
true
{
userContextId
:
1
}
)
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
false
{
userContextId
:
2
}
)
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
true
{
userContextId
:
2
}
)
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
false
{
firstPartyDomain
:
"
example
.
com
"
}
)
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
true
{
firstPartyDomain
:
"
example
.
com
"
}
)
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
false
{
firstPartyDomain
:
"
example
.
org
"
}
)
)
)
;
data
=
data
.
concat
(
yield
cacheDataForContext
(
LoadContextInfo
.
custom
(
true
{
firstPartyDomain
:
"
example
.
org
"
}
)
)
)
;
if
(
aShouldIsolate
)
{
expectedEntryCount
=
2
;
}
for
(
let
suffix
of
suffixes
)
{
let
foundEntryCount
=
countMatchingCacheEntries
(
data
"
example
.
net
"
suffix
)
;
let
result
=
(
expectedEntryCount
=
=
=
foundEntryCount
)
;
ok
(
result
"
Cache
entries
expected
for
"
+
suffix
+
"
:
"
+
expectedEntryCount
+
"
and
found
"
+
foundEntryCount
)
;
}
stopObservingChannels
(
)
;
stopObservingChannels
=
undefined
;
return
true
;
}
let
testArgs
=
{
url
:
TEST_PAGE
firstFrameSetting
:
DEFAULT_FRAME_SETTING
secondFrameSetting
:
[
TEST_TYPE_FRAME
]
}
;
IsolationTestTools
.
runTests
(
testArgs
doTest
doCheck
doInit
)
;
