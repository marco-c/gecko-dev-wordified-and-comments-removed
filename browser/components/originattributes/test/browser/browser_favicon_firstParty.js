const
CC
=
Components
.
Constructor
;
const
{
PlacesUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
let
EventUtils
=
{
}
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
EventUtils
)
;
const
FIRST_PARTY_ONE
=
"
example
.
com
"
;
const
FIRST_PARTY_TWO
=
"
example
.
org
"
;
const
THIRD_PARTY
=
"
mochi
.
test
:
8888
"
;
const
TEST_SITE_ONE
=
"
http
:
/
/
"
+
FIRST_PARTY_ONE
;
const
TEST_SITE_TWO
=
"
http
:
/
/
"
+
FIRST_PARTY_TWO
;
const
THIRD_PARTY_SITE
=
"
http
:
/
/
"
+
THIRD_PARTY
;
const
TEST_DIRECTORY
=
"
/
browser
/
browser
/
components
/
originattributes
/
test
/
browser
/
"
;
const
TEST_PAGE
=
TEST_DIRECTORY
+
"
file_favicon
.
html
"
;
const
TEST_THIRD_PARTY_PAGE
=
TEST_DIRECTORY
+
"
file_favicon_thirdParty
.
html
"
;
const
TEST_CACHE_PAGE
=
TEST_DIRECTORY
+
"
file_favicon_cache
.
html
"
;
const
FAVICON_URI
=
TEST_DIRECTORY
+
"
file_favicon
.
png
"
;
const
TEST_FAVICON_CACHE_URI
=
TEST_DIRECTORY
+
"
file_favicon_cache
.
png
"
;
const
ICON_DATA
=
"
data
:
image
/
png
;
base64
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABH0lEQVRYw2P8
/
/
/
/
f4YBBEwMAwxGHcBCUMX
/
91DGOSj
/
BpT
/
DkpzQChGBSjfBErLQsVZhmoI
/
L8LpRdD6X1QietQGhYy7FB5aAgwmkLpBKi4BZTPMThDgBGjHIDF
+
f9mKD0fKvGBRKNdoF7sgPL1saaJwZgGDkJ9vpZMn8PAHqg5G9FyifBgD4H
/
W9HyOWrU
/
f
+
DIzHhkoeZxxgzZEIAVtJ9RxX
+
Q6DAxCmP3byhXxkxshAs5odqbcioAY3UC1CBLyTGOTqAmsfAOWRCwBvqxV0oIUB2OQAzDy3
/
D
+
a6wB7q8mCU2vD
/
nw94GziYIQOtDRn9oXz
+
IZMGBKGMbCjNh9Ii
+
v8HR4uIAUeLiEEbb9twELaIRlqrmHG0bzjiHQAA1LVfww8jwM4AAAAASUVORK5CYII
=
"
;
let
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
let
makeURI
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
{
}
)
.
BrowserUtils
.
makeURI
;
function
clearAllImageCaches
(
)
{
let
tools
=
SpecialPowers
.
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
SpecialPowers
.
Ci
.
imgITools
)
;
let
imageCache
=
tools
.
getImgCacheForDocument
(
window
.
document
)
;
imageCache
.
clearCache
(
true
)
;
imageCache
.
clearCache
(
false
)
;
}
function
clearAllPlacesFavicons
(
)
{
let
faviconService
=
Cc
[
"
mozilla
.
org
/
browser
/
favicon
-
service
;
1
"
]
.
getService
(
Ci
.
nsIFaviconService
)
;
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
=
"
places
-
favicons
-
expired
"
)
{
resolve
(
)
;
Services
.
obs
.
removeObserver
(
observer
"
places
-
favicons
-
expired
"
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
places
-
favicons
-
expired
"
)
;
faviconService
.
expireAllFavicons
(
)
;
}
)
;
}
function
observeFavicon
(
aFirstPartyDomain
aExpectedCookie
aPageURI
)
{
let
expectedPrincipal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
aPageURI
{
firstPartyDomain
:
aFirstPartyDomain
}
)
;
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
=
"
http
-
on
-
modify
-
request
"
)
{
let
httpChannel
=
aSubject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
let
reqLoadInfo
=
httpChannel
.
loadInfo
;
let
loadingPrincipal
=
reqLoadInfo
.
loadingPrincipal
;
let
triggeringPrincipal
=
reqLoadInfo
.
triggeringPrincipal
;
if
(
!
httpChannel
.
URI
.
spec
.
endsWith
(
FAVICON_URI
)
)
{
return
;
}
is
(
reqLoadInfo
.
originAttributes
.
firstPartyDomain
aFirstPartyDomain
"
The
loadInfo
has
correct
first
party
domain
"
)
;
ok
(
loadingPrincipal
.
equals
(
expectedPrincipal
)
"
The
loadingPrincipal
of
favicon
loads
should
be
the
content
prinicpal
"
)
;
ok
(
triggeringPrincipal
.
equals
(
expectedPrincipal
)
"
The
triggeringPrincipal
of
favicon
loads
should
be
the
content
prinicpal
"
)
;
let
faviconCookie
=
httpChannel
.
getRequestHeader
(
"
cookie
"
)
;
is
(
faviconCookie
aExpectedCookie
"
The
cookie
of
the
favicon
loading
is
correct
.
"
)
;
}
else
{
ok
(
false
"
Received
unexpected
topic
:
"
aTopic
)
;
}
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
modify
-
request
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
modify
-
request
"
)
;
}
)
;
}
function
waitOnFaviconResponse
(
aFaviconURL
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
=
"
http
-
on
-
examine
-
response
"
|
|
aTopic
=
=
=
"
http
-
on
-
examine
-
cached
-
response
"
)
{
let
httpChannel
=
aSubject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
let
loadInfo
=
httpChannel
.
loadInfo
;
if
(
httpChannel
.
URI
.
spec
!
=
=
aFaviconURL
)
{
return
;
}
let
result
=
{
topic
:
aTopic
firstPartyDomain
:
loadInfo
.
originAttributes
.
firstPartyDomain
}
;
resolve
(
result
)
;
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
examine
-
response
"
)
;
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
examine
-
cached
-
response
"
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
examine
-
response
"
)
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
examine
-
cached
-
response
"
)
;
}
)
;
}
function
waitOnFaviconLoaded
(
aFaviconURL
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
onPageChanged
(
uri
attr
value
id
)
{
if
(
attr
=
=
=
Ci
.
nsINavHistoryObserver
.
ATTRIBUTE_FAVICON
&
&
value
=
=
=
aFaviconURL
)
{
resolve
(
)
;
PlacesUtils
.
history
.
removeObserver
(
observer
false
)
;
}
}
}
;
PlacesUtils
.
history
.
addObserver
(
observer
)
;
}
)
;
}
async
function
openTab
(
aURL
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
aURL
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
return
{
tab
browser
}
;
}
async
function
assignCookiesUnderFirstParty
(
aURL
aFirstParty
aCookieValue
)
{
let
tabInfo
=
await
openTabInFirstParty
(
aURL
aFirstParty
)
;
await
ContentTask
.
spawn
(
tabInfo
.
browser
aCookieValue
async
function
(
value
)
{
content
.
document
.
cookie
=
value
;
}
)
;
BrowserTestUtils
.
removeTab
(
tabInfo
.
tab
)
;
}
async
function
generateCookies
(
aThirdParty
)
{
let
cookies
=
[
]
;
cookies
.
push
(
Math
.
random
(
)
.
toString
(
)
+
"
=
1
"
)
;
cookies
.
push
(
Math
.
random
(
)
.
toString
(
)
+
"
=
1
"
)
;
let
firstSiteURL
;
let
secondSiteURL
;
if
(
aThirdParty
)
{
firstSiteURL
=
THIRD_PARTY_SITE
;
secondSiteURL
=
THIRD_PARTY_SITE
;
}
else
{
firstSiteURL
=
TEST_SITE_ONE
;
secondSiteURL
=
TEST_SITE_TWO
;
}
await
assignCookiesUnderFirstParty
(
firstSiteURL
TEST_SITE_ONE
cookies
[
0
]
)
;
await
assignCookiesUnderFirstParty
(
secondSiteURL
TEST_SITE_TWO
cookies
[
1
]
)
;
return
cookies
;
}
function
assertIconIsData
(
item
)
{
let
icon
=
item
.
getAttribute
(
"
image
"
)
;
is
(
icon
.
substring
(
0
5
)
"
data
:
"
"
Expected
the
image
element
to
be
a
data
URI
"
)
;
is
(
icon
ICON_DATA
"
Expected
to
see
the
correct
data
.
"
)
;
}
async
function
doTest
(
aTestPage
aExpectedCookies
aFaviconURL
)
{
let
firstPageURI
=
makeURI
(
TEST_SITE_ONE
+
aTestPage
)
;
let
secondPageURI
=
makeURI
(
TEST_SITE_TWO
+
aTestPage
)
;
let
promiseFaviconLoaded
=
waitOnFaviconLoaded
(
aFaviconURL
)
;
let
promiseObserveFavicon
=
observeFavicon
(
FIRST_PARTY_ONE
aExpectedCookies
[
0
]
firstPageURI
)
;
let
tabInfo
=
await
openTab
(
TEST_SITE_ONE
+
aTestPage
)
;
await
promiseObserveFavicon
;
await
promiseFaviconLoaded
;
assertIconIsData
(
tabInfo
.
tab
)
;
BrowserTestUtils
.
removeTab
(
tabInfo
.
tab
)
;
await
new
Promise
(
executeSoon
)
;
promiseObserveFavicon
=
observeFavicon
(
FIRST_PARTY_TWO
aExpectedCookies
[
1
]
secondPageURI
)
;
tabInfo
=
await
openTab
(
TEST_SITE_TWO
+
aTestPage
)
;
await
promiseObserveFavicon
;
BrowserTestUtils
.
removeTab
(
tabInfo
.
tab
)
;
}
async
function
doTestForAllTabsFavicon
(
aTestPage
aExpectedCookies
aIsThirdParty
)
{
let
faviconURI
=
aIsThirdParty
?
THIRD_PARTY_SITE
+
FAVICON_URI
:
TEST_SITE_ONE
+
FAVICON_URI
;
let
tabBrowser
=
document
.
getElementById
(
"
tabbrowser
-
tabs
"
)
;
tabBrowser
.
setAttribute
(
"
overflow
"
true
)
;
let
promiseFaviconLoaded
=
waitOnFaviconLoaded
(
faviconURI
)
;
let
tabInfo
=
await
openTab
(
TEST_SITE_ONE
+
aTestPage
)
;
await
promiseFaviconLoaded
;
assertIconIsData
(
tabInfo
.
tab
)
;
let
allTabsView
=
document
.
getElementById
(
"
allTabsMenu
-
allTabsView
"
)
;
let
allTabsPopupShownPromise
=
BrowserTestUtils
.
waitForEvent
(
allTabsView
"
ViewShown
"
)
;
gTabsPanel
.
showAllTabsPanel
(
)
;
await
allTabsPopupShownPromise
;
assertIconIsData
(
gTabsPanel
.
allTabsViewTabs
.
lastElementChild
.
firstElementChild
)
;
let
allTabsPopupHiddenPromise
=
BrowserTestUtils
.
waitForEvent
(
allTabsView
.
panelMultiView
"
PanelMultiViewHidden
"
)
;
gTabsPanel
.
hideAllTabsPanel
(
)
;
await
allTabsPopupHiddenPromise
;
BrowserTestUtils
.
removeTab
(
tabInfo
.
tab
)
;
faviconURI
=
aIsThirdParty
?
THIRD_PARTY_SITE
+
FAVICON_URI
:
TEST_SITE_TWO
+
FAVICON_URI
;
promiseFaviconLoaded
=
waitOnFaviconLoaded
(
faviconURI
)
;
tabInfo
=
await
openTab
(
TEST_SITE_TWO
+
aTestPage
)
;
await
promiseFaviconLoaded
;
assertIconIsData
(
tabInfo
.
tab
)
;
allTabsPopupShownPromise
=
BrowserTestUtils
.
waitForEvent
(
allTabsView
"
ViewShown
"
)
;
gTabsPanel
.
showAllTabsPanel
(
)
;
await
allTabsPopupShownPromise
;
assertIconIsData
(
gTabsPanel
.
allTabsViewTabs
.
lastElementChild
.
firstElementChild
)
;
allTabsPopupHiddenPromise
=
BrowserTestUtils
.
waitForEvent
(
allTabsView
.
panelMultiView
"
PanelMultiViewHidden
"
)
;
gTabsPanel
.
hideAllTabsPanel
(
)
;
await
allTabsPopupHiddenPromise
;
BrowserTestUtils
.
removeTab
(
tabInfo
.
tab
)
;
tabBrowser
.
removeAttribute
(
"
overflow
"
)
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
privacy
.
firstparty
.
isolate
"
true
]
]
}
)
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
cookies
.
removeAll
(
)
;
clearAllImageCaches
(
)
;
Services
.
cache2
.
clear
(
)
;
}
)
;
add_task
(
async
function
test_favicon_firstParty
(
)
{
for
(
let
testThirdParty
of
[
false
true
]
)
{
clearAllImageCaches
(
)
;
Services
.
cache2
.
clear
(
)
;
await
clearAllPlacesFavicons
(
)
;
let
cookies
=
await
generateCookies
(
testThirdParty
)
;
if
(
testThirdParty
)
{
await
doTest
(
TEST_THIRD_PARTY_PAGE
cookies
THIRD_PARTY_SITE
+
FAVICON_URI
)
;
}
else
{
await
doTest
(
TEST_PAGE
cookies
TEST_SITE_ONE
+
FAVICON_URI
)
;
}
}
}
)
;
add_task
(
async
function
test_allTabs_favicon_firstParty
(
)
{
for
(
let
testThirdParty
of
[
false
true
]
)
{
clearAllImageCaches
(
)
;
Services
.
cache2
.
clear
(
)
;
await
clearAllPlacesFavicons
(
)
;
let
cookies
=
await
generateCookies
(
testThirdParty
)
;
if
(
testThirdParty
)
{
await
doTestForAllTabsFavicon
(
TEST_THIRD_PARTY_PAGE
cookies
testThirdParty
)
;
}
else
{
await
doTestForAllTabsFavicon
(
TEST_PAGE
cookies
testThirdParty
)
;
}
}
}
)
;
add_task
(
async
function
test_favicon_cache_firstParty
(
)
{
clearAllImageCaches
(
)
;
Services
.
cache2
.
clear
(
)
;
let
promiseForFaviconLoaded
=
waitOnFaviconLoaded
(
THIRD_PARTY_SITE
+
TEST_FAVICON_CACHE_URI
)
;
let
responsePromise
=
waitOnFaviconResponse
(
THIRD_PARTY_SITE
+
TEST_FAVICON_CACHE_URI
)
;
let
tabInfoA
=
await
openTab
(
TEST_SITE_ONE
+
TEST_CACHE_PAGE
)
;
let
response
=
await
responsePromise
;
is
(
response
.
topic
"
http
-
on
-
examine
-
response
"
"
The
favicon
image
should
be
loaded
through
network
.
"
)
;
is
(
response
.
firstPartyDomain
FIRST_PARTY_ONE
"
We
should
only
observe
the
network
response
for
the
first
first
party
.
"
)
;
await
promiseForFaviconLoaded
;
let
promiseForFaviconResponse
=
waitOnFaviconResponse
(
THIRD_PARTY_SITE
+
TEST_FAVICON_CACHE_URI
)
;
let
tabInfoB
=
await
openTab
(
TEST_SITE_TWO
+
TEST_CACHE_PAGE
)
;
response
=
await
promiseForFaviconResponse
;
is
(
response
.
topic
"
http
-
on
-
examine
-
response
"
"
The
favicon
image
should
be
loaded
through
network
again
.
"
)
;
is
(
response
.
firstPartyDomain
FIRST_PARTY_TWO
"
We
should
only
observe
the
network
response
for
the
second
first
party
.
"
)
;
BrowserTestUtils
.
removeTab
(
tabInfoA
.
tab
)
;
BrowserTestUtils
.
removeTab
(
tabInfoB
.
tab
)
;
}
)
;
