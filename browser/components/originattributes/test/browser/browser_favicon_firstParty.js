const
{
classes
:
Cc
Constructor
:
CC
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
FIRST_PARTY_ONE
=
"
example
.
com
"
;
const
FIRST_PARTY_TWO
=
"
example
.
org
"
;
const
THIRD_PARTY
=
"
mochi
.
test
:
8888
"
;
const
TEST_SITE_ONE
=
"
http
:
/
/
"
+
FIRST_PARTY_ONE
;
const
TEST_SITE_TWO
=
"
http
:
/
/
"
+
FIRST_PARTY_TWO
;
const
THIRD_PARTY_SITE
=
"
http
:
/
/
"
+
THIRD_PARTY
;
const
TEST_DIRECTORY
=
"
/
browser
/
browser
/
components
/
originattributes
/
test
/
browser
/
"
;
const
TEST_PAGE
=
TEST_DIRECTORY
+
"
file_favicon
.
html
"
;
const
TEST_THIRD_PARTY_PAGE
=
TEST_DIRECTORY
+
"
file_favicon_thirdParty
.
html
"
;
const
TEST_CACHE_PAGE
=
TEST_DIRECTORY
+
"
file_favicon_cache
.
html
"
;
const
FAVICON_URI
=
TEST_DIRECTORY
+
"
file_favicon
.
png
"
;
const
TEST_FAVICON_CACHE_URI
=
TEST_DIRECTORY
+
"
file_favicon_cache
.
png
"
;
let
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
let
makeURI
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
{
}
)
.
BrowserUtils
.
makeURI
;
function
clearAllImageCaches
(
)
{
let
tools
=
SpecialPowers
.
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
SpecialPowers
.
Ci
.
imgITools
)
;
let
imageCache
=
tools
.
getImgCacheForDocument
(
window
.
document
)
;
imageCache
.
clearCache
(
true
)
;
imageCache
.
clearCache
(
false
)
;
}
function
observeFavicon
(
aFirstPartyDomain
aExpectedCookie
aPageURI
)
{
let
faviconReqXUL
=
false
;
let
faviconReqPlaces
=
false
;
let
expectedPrincipal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
aPageURI
{
firstPartyDomain
:
aFirstPartyDomain
}
)
;
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
=
"
http
-
on
-
modify
-
request
"
)
{
let
httpChannel
=
aSubject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
let
reqLoadInfo
=
httpChannel
.
loadInfo
;
let
loadingPrincipal
=
reqLoadInfo
.
loadingPrincipal
;
let
triggeringPrincipal
=
reqLoadInfo
.
triggeringPrincipal
;
if
(
!
httpChannel
.
URI
.
spec
.
endsWith
(
FAVICON_URI
)
)
{
return
;
}
is
(
reqLoadInfo
.
originAttributes
.
firstPartyDomain
aFirstPartyDomain
"
The
loadInfo
has
correct
first
party
domain
"
)
;
if
(
loadingPrincipal
.
equals
(
systemPrincipal
)
)
{
faviconReqXUL
=
true
;
ok
(
triggeringPrincipal
.
equals
(
expectedPrincipal
)
"
The
triggeringPrincipal
of
favicon
loading
from
XUL
should
be
the
content
principal
.
"
)
;
}
else
{
faviconReqPlaces
=
true
;
ok
(
loadingPrincipal
.
equals
(
expectedPrincipal
)
"
The
loadingPrincipal
of
favicon
loading
from
Places
should
be
the
content
prinicpal
"
)
;
}
let
faviconCookie
=
httpChannel
.
getRequestHeader
(
"
cookie
"
)
;
is
(
faviconCookie
aExpectedCookie
"
The
cookie
of
the
favicon
loading
is
correct
.
"
)
;
}
else
{
ok
(
false
"
Received
unexpected
topic
:
"
aTopic
)
;
}
if
(
faviconReqXUL
&
&
faviconReqPlaces
)
{
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
modify
-
request
"
false
)
;
resolve
(
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
modify
-
request
"
false
)
;
}
)
;
}
function
waitOnFaviconResponse
(
aFaviconURL
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
=
"
http
-
on
-
examine
-
response
"
|
|
aTopic
=
=
=
"
http
-
on
-
examine
-
cached
-
response
"
)
{
let
httpChannel
=
aSubject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
let
loadInfo
=
httpChannel
.
loadInfo
;
if
(
httpChannel
.
URI
.
spec
!
=
=
aFaviconURL
)
{
return
;
}
let
result
=
{
topic
:
aTopic
firstPartyDomain
:
loadInfo
.
originAttributes
.
firstPartyDomain
}
;
resolve
(
result
)
;
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
examine
-
response
"
false
)
;
Services
.
obs
.
removeObserver
(
observer
"
http
-
on
-
examine
-
cached
-
response
"
false
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
examine
-
response
"
false
)
;
Services
.
obs
.
addObserver
(
observer
"
http
-
on
-
examine
-
cached
-
response
"
false
)
;
}
)
;
}
function
waitOnFaviconLoaded
(
aFaviconURL
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
onPageChanged
(
uri
attr
value
id
)
{
if
(
attr
=
=
=
Ci
.
nsINavHistoryObserver
.
ATTRIBUTE_FAVICON
&
&
value
=
=
=
aFaviconURL
)
{
resolve
(
)
;
PlacesUtils
.
history
.
removeObserver
(
observer
false
)
;
}
}
}
;
PlacesUtils
.
history
.
addObserver
(
observer
false
)
;
}
)
;
}
function
*
openTab
(
aURL
)
{
let
tab
=
gBrowser
.
addTab
(
aURL
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
yield
BrowserTestUtils
.
browserLoaded
(
browser
)
;
return
{
tab
browser
}
;
}
function
*
assignCookiesUnderFirstParty
(
aURL
aFirstParty
aCookieValue
)
{
let
tabInfo
=
yield
openTabInFirstParty
(
aURL
aFirstParty
)
;
yield
ContentTask
.
spawn
(
tabInfo
.
browser
aCookieValue
function
*
(
value
)
{
content
.
document
.
cookie
=
value
;
}
)
;
yield
BrowserTestUtils
.
removeTab
(
tabInfo
.
tab
)
;
}
function
*
generateCookies
(
aThirdParty
)
{
let
cookies
=
[
]
;
cookies
.
push
(
Math
.
random
(
)
.
toString
(
)
)
;
cookies
.
push
(
Math
.
random
(
)
.
toString
(
)
)
;
let
firstSiteURL
;
let
secondSiteURL
;
if
(
aThirdParty
)
{
firstSiteURL
=
THIRD_PARTY_SITE
;
secondSiteURL
=
THIRD_PARTY_SITE
;
}
else
{
firstSiteURL
=
TEST_SITE_ONE
;
secondSiteURL
=
TEST_SITE_TWO
;
}
yield
assignCookiesUnderFirstParty
(
firstSiteURL
TEST_SITE_ONE
cookies
[
0
]
)
;
yield
assignCookiesUnderFirstParty
(
secondSiteURL
TEST_SITE_TWO
cookies
[
1
]
)
;
return
cookies
;
}
function
*
doTest
(
aTestPage
aExpectedCookies
aFaviconURL
)
{
let
firstPageURI
=
makeURI
(
TEST_SITE_ONE
+
aTestPage
)
;
let
secondPageURI
=
makeURI
(
TEST_SITE_TWO
+
aTestPage
)
;
let
faviconURI
=
makeURI
(
aFaviconURL
)
;
let
tabInfo
=
yield
openTab
(
TEST_SITE_ONE
+
aTestPage
)
;
yield
observeFavicon
(
FIRST_PARTY_ONE
aExpectedCookies
[
0
]
firstPageURI
)
;
yield
BrowserTestUtils
.
removeTab
(
tabInfo
.
tab
)
;
tabInfo
=
yield
openTab
(
TEST_SITE_TWO
+
aTestPage
)
;
yield
observeFavicon
(
FIRST_PARTY_TWO
aExpectedCookies
[
1
]
secondPageURI
)
;
yield
BrowserTestUtils
.
removeTab
(
tabInfo
.
tab
)
;
}
add_task
(
function
*
setup
(
)
{
yield
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
privacy
.
firstparty
.
isolate
"
true
]
]
}
)
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
let
cookieMgr
=
Cc
[
"
mozilla
.
org
/
cookiemanager
;
1
"
]
.
getService
(
Ci
.
nsICookieManager
)
;
cookieMgr
.
removeAll
(
)
;
clearAllImageCaches
(
)
;
let
networkCache
=
Cc
[
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
]
.
getService
(
Ci
.
nsICacheStorageService
)
;
networkCache
.
clear
(
)
;
}
)
;
add_task
(
function
*
test_favicon_firstParty
(
)
{
for
(
let
testThirdParty
of
[
false
true
]
)
{
clearAllImageCaches
(
)
;
let
cookies
=
yield
generateCookies
(
testThirdParty
)
;
if
(
testThirdParty
)
{
yield
doTest
(
TEST_THIRD_PARTY_PAGE
cookies
THIRD_PARTY_SITE
+
FAVICON_URI
)
;
}
else
{
yield
doTest
(
TEST_PAGE
cookies
TEST_SITE_TWO
+
FAVICON_URI
)
;
}
}
}
)
;
add_task
(
function
*
test_favicon_cache_firstParty
(
)
{
clearAllImageCaches
(
)
;
let
networkCache
=
Cc
[
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
]
.
getService
(
Ci
.
nsICacheStorageService
)
;
networkCache
.
clear
(
)
;
let
tabInfoA
=
yield
openTab
(
TEST_SITE_ONE
+
TEST_CACHE_PAGE
)
;
let
promiseForFaviconLoaded
=
waitOnFaviconLoaded
(
THIRD_PARTY_SITE
+
TEST_FAVICON_CACHE_URI
)
;
let
response
=
yield
waitOnFaviconResponse
(
THIRD_PARTY_SITE
+
TEST_FAVICON_CACHE_URI
)
;
is
(
response
.
topic
"
http
-
on
-
examine
-
response
"
"
The
favicon
image
should
be
loaded
through
network
.
"
)
;
is
(
response
.
firstPartyDomain
FIRST_PARTY_ONE
"
We
should
only
observe
the
network
response
for
the
first
first
party
.
"
)
;
yield
promiseForFaviconLoaded
;
let
tabInfoB
=
yield
openTab
(
TEST_SITE_ONE
+
TEST_CACHE_PAGE
)
;
let
promiseForFaviconResponse
=
waitOnFaviconResponse
(
THIRD_PARTY_SITE
+
TEST_FAVICON_CACHE_URI
)
;
let
tabInfoC
=
yield
openTab
(
TEST_SITE_TWO
+
TEST_CACHE_PAGE
)
;
response
=
yield
promiseForFaviconResponse
;
is
(
response
.
topic
"
http
-
on
-
examine
-
response
"
"
The
favicon
image
should
be
loaded
through
network
again
.
"
)
;
is
(
response
.
firstPartyDomain
FIRST_PARTY_TWO
"
We
should
only
observe
the
network
response
for
the
second
first
party
.
"
)
;
yield
BrowserTestUtils
.
removeTab
(
tabInfoA
.
tab
)
;
yield
BrowserTestUtils
.
removeTab
(
tabInfoB
.
tab
)
;
yield
BrowserTestUtils
.
removeTab
(
tabInfoC
.
tab
)
;
}
)
;
