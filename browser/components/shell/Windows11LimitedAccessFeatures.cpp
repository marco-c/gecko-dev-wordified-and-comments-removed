#
include
"
Windows11LimitedAccessFeatures
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
static
mozilla
:
:
LazyLogModule
sLog
(
"
Windows11LimitedAccessFeatures
"
)
;
#
define
LAF_LOG
(
level
msg
.
.
.
)
MOZ_LOG
(
sLog
level
(
msg
#
#
__VA_ARGS__
)
)
#
ifndef
__MINGW32__
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Char16
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
<
wrl
.
h
>
#
include
<
inspectable
.
h
>
#
include
<
roapi
.
h
>
#
include
<
windows
.
services
.
store
.
h
>
#
include
<
windows
.
foundation
.
h
>
using
namespace
Microsoft
:
:
WRL
;
using
namespace
Microsoft
:
:
WRL
:
:
Wrappers
;
using
namespace
ABI
:
:
Windows
;
using
namespace
ABI
:
:
Windows
:
:
Foundation
;
using
namespace
ABI
:
:
Windows
:
:
ApplicationModel
;
using
namespace
mozilla
;
static
mozilla
:
:
Result
<
LimitedAccessFeatureInfo
nsresult
>
GenerateLimitedAccessFeatureInfo
(
const
nsCString
&
debugName
const
nsString
&
lafId
)
{
nsresult
rv
;
nsAutoString
keyData
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
const
nsAutoString
regPath
=
u
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
AppModel
\
\
LimitedAccessFeatures
\
\
"
_ns
+
lafId
;
rv
=
regKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_LOCAL_MACHINE
regPath
nsIWindowsRegKey
:
:
ACCESS_READ
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
rv
=
regKey
-
>
ReadStringValue
(
u
"
"
_ns
keyData
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
nsAutoCString
hashStringResult
;
nsAutoString
encodedToken
;
nsAutoString
familyName
;
if
(
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
familyName
=
nsDependentString
(
mozilla
:
:
GetPackageFamilyName
(
)
.
get
(
)
)
;
}
else
{
familyName
=
u
"
MozillaFirefox_pcsmm0jrprpb2
"
_ns
;
}
const
nsAutoCString
hashString
=
NS_ConvertUTF16toUTF8
(
lafId
+
u
"
!
"
_ns
+
keyData
+
u
"
!
"
_ns
+
familyName
)
;
nsCOMPtr
<
nsICryptoHash
>
cryptoHash
=
do_CreateInstance
(
"
mozilla
.
org
/
security
/
hash
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
rv
=
cryptoHash
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
rv
=
cryptoHash
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
hashString
.
get
(
)
)
hashString
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
rv
=
cryptoHash
-
>
Finish
(
false
hashStringResult
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
hashStringResult
.
Truncate
(
hashStringResult
.
Length
(
)
-
16
)
;
rv
=
Base64Encode
(
hashStringResult
encodedToken
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
familyName
.
Cut
(
0
familyName
.
Length
(
)
-
13
)
;
nsAutoString
attestation
=
familyName
+
u
"
has
registered
their
use
of
"
_ns
+
lafId
+
u
"
with
Microsoft
and
agrees
to
the
terms
of
use
.
"
_ns
;
LimitedAccessFeatureInfo
result
=
{
debugName
lafId
encodedToken
attestation
}
;
return
result
;
}
class
Win11LimitedAccessFeatures
:
public
Win11LimitedAccessFeaturesInterface
{
public
:
using
AtomicState
=
Atomic
<
int
SequentiallyConsistent
>
;
Result
<
bool
HRESULT
>
Unlock
(
Win11LimitedAccessFeatureType
feature
)
override
;
private
:
AtomicState
&
GetState
(
Win11LimitedAccessFeatureType
feature
)
;
Result
<
bool
HRESULT
>
UnlockImplementation
(
const
LimitedAccessFeatureInfo
&
lafInfo
)
;
static
AtomicState
mTaskbarState
;
static
AtomicState
mDefaultState
;
enum
State
{
Uninitialized
Locked
Unlocked
}
;
}
;
Win11LimitedAccessFeatures
:
:
AtomicState
Win11LimitedAccessFeatures
:
:
mTaskbarState
(
Win11LimitedAccessFeatures
:
:
Uninitialized
)
;
Win11LimitedAccessFeatures
:
:
AtomicState
Win11LimitedAccessFeatures
:
:
mDefaultState
(
Win11LimitedAccessFeatures
:
:
Uninitialized
)
;
RefPtr
<
Win11LimitedAccessFeaturesInterface
>
CreateWin11LimitedAccessFeaturesInterface
(
)
{
RefPtr
<
Win11LimitedAccessFeaturesInterface
>
result
(
new
Win11LimitedAccessFeatures
(
)
)
;
return
result
;
}
Result
<
bool
HRESULT
>
Win11LimitedAccessFeatures
:
:
Unlock
(
Win11LimitedAccessFeatureType
feature
)
{
AtomicState
&
atomicState
=
GetState
(
feature
)
;
auto
taskbarLafInfo
=
GenerateLimitedAccessFeatureInfo
(
"
Win11LimitedAccessFeatureType
:
:
Taskbar
"
_ns
u
"
com
.
microsoft
.
windows
.
taskbar
.
pin
"
_ns
)
;
if
(
taskbarLafInfo
.
isErr
(
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
Unlocking
taskbar
failed
with
error
%
d
"
NS_ERROR_GET_CODE
(
taskbarLafInfo
.
unwrapErr
(
)
)
)
;
return
Err
(
E_FAIL
)
;
}
LimitedAccessFeatureInfo
limitedAccessFeatureInfo
[
]
=
{
taskbarLafInfo
.
unwrap
(
)
}
;
const
auto
&
lafInfo
=
limitedAccessFeatureInfo
[
static_cast
<
int
>
(
feature
)
]
;
LAF_LOG
(
LogLevel
:
:
Debug
"
Limited
Access
Feature
Info
for
%
s
.
Feature
%
ls
%
ls
%
ls
"
lafInfo
.
debugName
.
get
(
)
lafInfo
.
token
.
getW
(
)
lafInfo
.
token
.
getW
(
)
lafInfo
.
attestation
.
getW
(
)
)
;
int
state
=
atomicState
;
if
(
state
!
=
Uninitialized
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
already
initialized
!
State
=
%
s
"
lafInfo
.
debugName
.
get
(
)
(
state
=
=
Unlocked
)
?
"
true
"
:
"
false
"
)
;
return
(
state
=
=
Unlocked
)
;
}
auto
result
=
UnlockImplementation
(
lafInfo
)
;
int
newState
=
Locked
;
if
(
!
result
.
isErr
(
)
&
&
result
.
unwrap
(
)
)
{
newState
=
Unlocked
;
}
atomicState
=
newState
;
return
result
;
}
Win11LimitedAccessFeatures
:
:
AtomicState
&
Win11LimitedAccessFeatures
:
:
GetState
(
Win11LimitedAccessFeatureType
feature
)
{
switch
(
feature
)
{
case
Win11LimitedAccessFeatureType
:
:
Taskbar
:
return
mTaskbarState
;
default
:
LAF_LOG
(
LogLevel
:
:
Debug
"
Missing
feature
type
for
%
d
"
static_cast
<
int
>
(
feature
)
)
;
MOZ_ASSERT
(
false
"
Unhandled
feature
type
!
Add
a
new
atomic
state
variable
add
"
"
that
entry
to
the
switch
statement
above
and
add
the
proper
"
"
entries
for
the
feature
and
the
token
.
"
)
;
return
mDefaultState
;
}
}
Result
<
bool
HRESULT
>
Win11LimitedAccessFeatures
:
:
UnlockImplementation
(
const
LimitedAccessFeatureInfo
&
lafInfo
)
{
ComPtr
<
ILimitedAccessFeaturesStatics
>
limitedAccessFeatures
;
ComPtr
<
ILimitedAccessFeatureRequestResult
>
limitedAccessFeaturesResult
;
HRESULT
hr
=
RoGetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_ApplicationModel_LimitedAccessFeatures
)
.
Get
(
)
IID_ILimitedAccessFeaturesStatics
&
limitedAccessFeatures
)
;
if
(
!
SUCCEEDED
(
hr
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
activation
error
.
HRESULT
=
0x
%
lx
"
lafInfo
.
debugName
.
get
(
)
hr
)
;
return
Err
(
hr
)
;
}
hr
=
limitedAccessFeatures
-
>
TryUnlockFeature
(
HStringReference
(
lafInfo
.
feature
.
get
(
)
)
.
Get
(
)
HStringReference
(
lafInfo
.
token
.
get
(
)
)
.
Get
(
)
HStringReference
(
lafInfo
.
attestation
.
get
(
)
)
.
Get
(
)
&
limitedAccessFeaturesResult
)
;
if
(
!
SUCCEEDED
(
hr
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
unlock
error
.
HRESULT
=
0x
%
lx
"
lafInfo
.
debugName
.
get
(
)
hr
)
;
return
Err
(
hr
)
;
}
LimitedAccessFeatureStatus
status
;
hr
=
limitedAccessFeaturesResult
-
>
get_Status
(
&
status
)
;
if
(
!
SUCCEEDED
(
hr
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
get
status
error
.
HRESULT
=
0x
%
lx
"
lafInfo
.
debugName
.
get
(
)
hr
)
;
return
Err
(
hr
)
;
}
int
state
=
Unlocked
;
if
(
(
status
!
=
LimitedAccessFeatureStatus_Available
)
&
&
(
status
!
=
LimitedAccessFeatureStatus_AvailableWithoutToken
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
not
available
.
HRESULT
=
0x
%
lx
"
lafInfo
.
debugName
.
get
(
)
hr
)
;
state
=
Locked
;
}
return
(
state
=
=
Unlocked
)
;
}
#
else
RefPtr
<
Win11LimitedAccessFeaturesInterface
>
CreateWin11LimitedAccessFeaturesInterface
(
)
{
RefPtr
<
Win11LimitedAccessFeaturesInterface
>
result
;
return
result
;
}
static
mozilla
:
:
Result
<
LimitedAccessFeatureInfo
nsresult
>
GenerateLimitedAccessFeatureInfo
(
const
nsCString
&
debugName
const
nsString
&
lafId
)
{
return
mozilla
:
:
Err
(
NS_ERROR_NOT_IMPLEMENTED
)
;
}
#
endif
