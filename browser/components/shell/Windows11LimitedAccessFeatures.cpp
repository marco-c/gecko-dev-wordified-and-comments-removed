#
include
"
Windows11LimitedAccessFeatures
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
static
mozilla
:
:
LazyLogModule
sLog
(
"
Windows11LimitedAccessFeatures
"
)
;
#
define
LAF_LOG
(
level
msg
.
.
.
)
MOZ_LOG
(
sLog
level
(
msg
#
#
__VA_ARGS__
)
)
#
ifndef
__MINGW32__
#
include
"
nsString
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
<
wrl
.
h
>
#
include
<
inspectable
.
h
>
#
include
<
roapi
.
h
>
#
include
<
windows
.
services
.
store
.
h
>
#
include
<
windows
.
foundation
.
h
>
using
namespace
Microsoft
:
:
WRL
;
using
namespace
Microsoft
:
:
WRL
:
:
Wrappers
;
using
namespace
ABI
:
:
Windows
;
using
namespace
ABI
:
:
Windows
:
:
Foundation
;
using
namespace
ABI
:
:
Windows
:
:
ApplicationModel
;
using
namespace
mozilla
;
struct
LimitedAccessFeatureInfo
{
const
char
*
debugName
;
const
WCHAR
*
feature
;
const
WCHAR
*
token
;
const
WCHAR
*
attestation
;
}
;
static
LimitedAccessFeatureInfo
limitedAccessFeatureInfo
[
]
=
{
{
"
Win11LimitedAccessFeatureType
:
:
Taskbar
"
MOZ_WINDOWS_TASKBAR_PINNING_API_FEATURE
MOZ_WINDOWS_TASKBAR_PINNING_API_KEY
MOZ_WINDOWS_TASKBAR_PINNING_API_ATTRIBUTION
}
}
;
static_assert
(
mozilla
:
:
ArrayLength
(
limitedAccessFeatureInfo
)
=
=
kWin11LimitedAccessFeatureTypeCount
)
;
class
Win11LimitedAccessFeatures
:
public
Win11LimitedAccessFeaturesInterface
{
public
:
using
AtomicState
=
Atomic
<
int
SequentiallyConsistent
>
;
Result
<
bool
HRESULT
>
Unlock
(
Win11LimitedAccessFeatureType
feature
)
override
;
private
:
AtomicState
&
GetState
(
Win11LimitedAccessFeatureType
feature
)
;
Result
<
bool
HRESULT
>
UnlockImplementation
(
Win11LimitedAccessFeatureType
feature
)
;
static
AtomicState
mTaskbarState
;
static
AtomicState
mDefaultState
;
enum
State
{
Uninitialized
Locked
Unlocked
}
;
}
;
Win11LimitedAccessFeatures
:
:
AtomicState
Win11LimitedAccessFeatures
:
:
mTaskbarState
(
Win11LimitedAccessFeatures
:
:
Uninitialized
)
;
Win11LimitedAccessFeatures
:
:
AtomicState
Win11LimitedAccessFeatures
:
:
mDefaultState
(
Win11LimitedAccessFeatures
:
:
Uninitialized
)
;
RefPtr
<
Win11LimitedAccessFeaturesInterface
>
CreateWin11LimitedAccessFeaturesInterface
(
)
{
RefPtr
<
Win11LimitedAccessFeaturesInterface
>
result
(
new
Win11LimitedAccessFeatures
(
)
)
;
return
result
;
}
Result
<
bool
HRESULT
>
Win11LimitedAccessFeatures
:
:
Unlock
(
Win11LimitedAccessFeatureType
feature
)
{
AtomicState
&
atomicState
=
GetState
(
feature
)
;
const
auto
&
lafInfo
=
limitedAccessFeatureInfo
[
static_cast
<
int
>
(
feature
)
]
;
LAF_LOG
(
LogLevel
:
:
Debug
"
Limited
Access
Feature
Info
for
%
s
.
Feature
%
S
%
S
%
S
"
lafInfo
.
debugName
lafInfo
.
feature
lafInfo
.
token
lafInfo
.
attestation
)
;
int
state
=
atomicState
;
if
(
state
!
=
Uninitialized
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
already
initialized
!
State
=
%
s
"
lafInfo
.
debugName
(
state
=
=
Unlocked
)
?
"
true
"
:
"
false
"
)
;
return
(
state
=
=
Unlocked
)
;
}
auto
result
=
UnlockImplementation
(
feature
)
;
int
newState
=
Locked
;
if
(
!
result
.
isErr
(
)
&
&
result
.
unwrap
(
)
)
{
newState
=
Unlocked
;
}
atomicState
=
newState
;
return
result
;
}
Win11LimitedAccessFeatures
:
:
AtomicState
&
Win11LimitedAccessFeatures
:
:
GetState
(
Win11LimitedAccessFeatureType
feature
)
{
switch
(
feature
)
{
case
Win11LimitedAccessFeatureType
:
:
Taskbar
:
return
mTaskbarState
;
default
:
LAF_LOG
(
LogLevel
:
:
Debug
"
Missing
feature
type
for
%
d
"
static_cast
<
int
>
(
feature
)
)
;
MOZ_ASSERT
(
false
"
Unhandled
feature
type
!
Add
a
new
atomic
state
variable
add
"
"
that
entry
to
the
switch
statement
above
and
add
the
proper
"
"
entries
for
the
feature
and
the
token
.
"
)
;
return
mDefaultState
;
}
}
Result
<
bool
HRESULT
>
Win11LimitedAccessFeatures
:
:
UnlockImplementation
(
Win11LimitedAccessFeatureType
feature
)
{
ComPtr
<
ILimitedAccessFeaturesStatics
>
limitedAccessFeatures
;
ComPtr
<
ILimitedAccessFeatureRequestResult
>
limitedAccessFeaturesResult
;
const
auto
&
lafInfo
=
limitedAccessFeatureInfo
[
static_cast
<
int
>
(
feature
)
]
;
HRESULT
hr
=
RoGetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_ApplicationModel_LimitedAccessFeatures
)
.
Get
(
)
IID_ILimitedAccessFeaturesStatics
&
limitedAccessFeatures
)
;
if
(
!
SUCCEEDED
(
hr
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
activation
error
.
HRESULT
=
0x
%
lx
"
lafInfo
.
debugName
hr
)
;
return
Err
(
hr
)
;
}
hr
=
limitedAccessFeatures
-
>
TryUnlockFeature
(
HStringReference
(
lafInfo
.
feature
)
.
Get
(
)
HStringReference
(
lafInfo
.
token
)
.
Get
(
)
HStringReference
(
lafInfo
.
attestation
)
.
Get
(
)
&
limitedAccessFeaturesResult
)
;
if
(
!
SUCCEEDED
(
hr
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
unlock
error
.
HRESULT
=
0x
%
lx
"
lafInfo
.
debugName
hr
)
;
return
Err
(
hr
)
;
}
LimitedAccessFeatureStatus
status
;
hr
=
limitedAccessFeaturesResult
-
>
get_Status
(
&
status
)
;
if
(
!
SUCCEEDED
(
hr
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
get
status
error
.
HRESULT
=
0x
%
lx
"
lafInfo
.
debugName
hr
)
;
return
Err
(
hr
)
;
}
int
state
=
Unlocked
;
if
(
(
status
!
=
LimitedAccessFeatureStatus_Available
)
&
&
(
status
!
=
LimitedAccessFeatureStatus_AvailableWithoutToken
)
)
{
LAF_LOG
(
LogLevel
:
:
Debug
"
%
s
not
available
.
HRESULT
=
0x
%
lx
"
lafInfo
.
debugName
hr
)
;
state
=
Locked
;
}
return
(
state
=
=
Unlocked
)
;
}
#
else
RefPtr
<
Win11LimitedAccessFeaturesInterface
>
CreateWin11LimitedAccessFeaturesInterface
(
)
{
RefPtr
<
Win11LimitedAccessFeaturesInterface
>
result
;
return
result
;
}
#
endif
