"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
HeadlessShell
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
progressListeners
=
new
Map
(
)
;
function
loadContentWindow
(
webNavigation
url
principal
)
{
let
uri
;
try
{
uri
=
Services
.
io
.
newURI
(
url
)
;
}
catch
(
e
)
{
let
msg
=
Invalid
URL
passed
to
loadContentWindow
(
)
:
{
url
}
;
Cu
.
reportError
(
msg
)
;
return
Promise
.
reject
(
new
Error
(
msg
)
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
loadURIOptions
=
{
triggeringPrincipal
:
principal
}
;
webNavigation
.
loadURI
(
uri
.
spec
loadURIOptions
)
;
let
docShell
=
webNavigation
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
let
progressListener
=
{
onLocationChange
(
progress
request
location
flags
)
{
if
(
progress
!
=
webProgress
)
{
return
;
}
if
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
{
return
;
}
if
(
location
.
spec
=
=
"
about
:
blank
"
&
&
uri
.
spec
!
=
"
about
:
blank
"
)
{
return
;
}
let
contentWindow
=
docShell
.
domWindow
;
progressListeners
.
delete
(
progressListener
)
;
webProgress
.
removeProgressListener
(
progressListener
)
;
contentWindow
.
addEventListener
(
"
load
"
event
=
>
{
resolve
(
contentWindow
)
;
}
{
once
:
true
}
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
}
;
progressListeners
.
set
(
progressListener
progressListener
)
;
webProgress
.
addProgressListener
(
progressListener
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
)
;
}
async
function
takeScreenshot
(
fullWidth
fullHeight
contentWidth
contentHeight
path
url
)
{
try
{
var
windowlessBrowser
=
Services
.
appShell
.
createWindowlessBrowser
(
false
)
;
let
contentWindow
=
await
loadContentWindow
(
windowlessBrowser
url
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
contentWindow
.
resizeTo
(
contentWidth
contentHeight
)
;
let
canvas
=
contentWindow
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
html
:
canvas
"
)
;
let
context
=
canvas
.
getContext
(
"
2d
"
)
;
let
width
=
fullWidth
?
contentWindow
.
innerWidth
+
contentWindow
.
scrollMaxX
-
contentWindow
.
scrollMinX
:
contentWindow
.
innerWidth
;
let
height
=
fullHeight
?
contentWindow
.
innerHeight
+
contentWindow
.
scrollMaxY
-
contentWindow
.
scrollMinY
:
contentWindow
.
innerHeight
;
canvas
.
width
=
width
;
canvas
.
height
=
height
;
context
.
drawWindow
(
contentWindow
0
0
width
height
"
rgb
(
255
255
255
)
"
)
;
function
getBlob
(
)
{
return
new
Promise
(
resolve
=
>
canvas
.
toBlob
(
resolve
)
)
;
}
function
readBlob
(
blob
)
{
return
new
Promise
(
resolve
=
>
{
let
reader
=
new
FileReader
(
)
;
reader
.
onloadend
=
(
)
=
>
resolve
(
reader
)
;
reader
.
readAsArrayBuffer
(
blob
)
;
}
)
;
}
let
blob
=
await
getBlob
(
)
;
let
reader
=
await
readBlob
(
blob
)
;
await
OS
.
File
.
writeAtomic
(
path
new
Uint8Array
(
reader
.
result
)
{
flush
:
true
}
)
;
dump
(
"
Screenshot
saved
to
:
"
+
path
+
"
\
n
"
)
;
}
catch
(
e
)
{
dump
(
"
Failure
taking
screenshot
:
"
+
e
+
"
\
n
"
)
;
}
finally
{
if
(
windowlessBrowser
)
{
windowlessBrowser
.
close
(
)
;
}
}
}
let
HeadlessShell
=
{
async
handleCmdLineArgs
(
cmdLine
URLlist
)
{
try
{
Services
.
startup
.
enterLastWindowClosingSurvivalArea
(
)
;
let
fullWidth
=
true
;
let
fullHeight
=
true
;
let
contentWidth
=
1366
;
let
contentHeight
=
768
;
try
{
var
dimensionsStr
=
cmdLine
.
handleFlagWithParam
(
"
window
-
size
"
true
)
;
}
catch
(
e
)
{
dump
(
"
expected
format
:
-
-
window
-
size
width
[
height
]
\
n
"
)
;
return
;
}
if
(
dimensionsStr
)
{
let
success
;
let
dimensions
=
dimensionsStr
.
split
(
"
"
2
)
;
if
(
dimensions
.
length
=
=
1
)
{
success
=
dimensions
[
0
]
>
0
;
if
(
success
)
{
fullWidth
=
false
;
fullHeight
=
true
;
contentWidth
=
dimensions
[
0
]
;
}
}
else
{
success
=
dimensions
[
0
]
>
0
&
&
dimensions
[
1
]
>
0
;
if
(
success
)
{
fullWidth
=
false
;
fullHeight
=
false
;
contentWidth
=
dimensions
[
0
]
;
contentHeight
=
dimensions
[
1
]
;
}
}
if
(
!
success
)
{
dump
(
"
expected
format
:
-
-
window
-
size
width
[
height
]
\
n
"
)
;
return
;
}
}
try
{
var
path
=
cmdLine
.
handleFlagWithParam
(
"
screenshot
"
true
)
;
if
(
!
cmdLine
.
length
&
&
!
URLlist
.
length
)
{
URLlist
.
push
(
path
)
;
path
=
OS
.
Path
.
join
(
cmdLine
.
workingDirectory
.
path
"
screenshot
.
png
"
)
;
}
}
catch
(
e
)
{
path
=
OS
.
Path
.
join
(
cmdLine
.
workingDirectory
.
path
"
screenshot
.
png
"
)
;
cmdLine
.
handleFlag
(
"
screenshot
"
true
)
;
}
for
(
let
i
=
0
;
i
<
cmdLine
.
length
;
+
+
i
)
{
URLlist
.
push
(
cmdLine
.
getArgument
(
i
)
)
;
}
if
(
URLlist
.
length
=
=
1
)
{
await
takeScreenshot
(
fullWidth
fullHeight
contentWidth
contentHeight
path
URLlist
[
0
]
)
;
}
else
{
dump
(
"
expected
exactly
one
URL
when
using
screenshot
\
n
"
)
;
}
}
finally
{
Services
.
startup
.
exitLastWindowClosingSurvivalArea
(
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eForceQuit
)
;
}
}
}
;
