"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ShellService
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
Subprocess
:
"
resource
:
/
/
gre
/
modules
/
Subprocess
.
sys
.
mjs
"
WindowsRegistry
:
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
XreDirProvider
"
"
mozilla
.
org
/
xre
/
directory
-
provider
;
1
"
"
nsIXREDirProvider
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Console
.
sys
.
mjs
"
)
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
browser
.
shell
.
loglevel
"
prefix
:
"
ShellService
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
let
ShellServiceInternal
=
{
get
canSetDesktopBackground
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
)
{
return
true
;
}
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
if
(
this
.
shellService
)
{
let
linuxShellService
=
this
.
shellService
.
QueryInterface
(
Ci
.
nsIGNOMEShellService
)
;
return
linuxShellService
.
canSetDesktopBackground
;
}
}
return
false
;
}
isDefaultBrowserOptOut
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
optOutValue
=
lazy
.
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
"
Software
\
\
Mozilla
\
\
Firefox
"
"
DefaultBrowserOptOut
"
)
;
lazy
.
WindowsRegistry
.
removeRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
"
Software
\
\
Mozilla
\
\
Firefox
"
"
DefaultBrowserOptOut
"
)
;
if
(
optOutValue
=
=
"
True
"
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
shell
.
checkDefaultBrowser
"
false
)
;
return
true
;
}
}
return
false
;
}
_checkedThisSession
:
false
get
shouldCheckDefaultBrowser
(
)
{
if
(
this
.
_checkedThisSession
)
{
return
false
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
shell
.
checkDefaultBrowser
"
)
)
{
return
false
;
}
if
(
this
.
isDefaultBrowserOptOut
(
)
)
{
return
false
;
}
return
true
;
}
set
shouldCheckDefaultBrowser
(
shouldCheck
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
shell
.
checkDefaultBrowser
"
!
!
shouldCheck
)
;
}
isDefaultBrowser
(
startupCheck
forAllTypes
)
{
if
(
startupCheck
)
{
this
.
_checkedThisSession
=
true
;
}
if
(
this
.
shellService
)
{
return
this
.
shellService
.
isDefaultBrowser
(
forAllTypes
)
;
}
return
false
;
}
_callExternalDefaultBrowserAgent
(
options
=
{
}
)
{
const
wdba
=
Services
.
dirsvc
.
get
(
"
XREExeF
"
Ci
.
nsIFile
)
;
wdba
.
leafName
=
"
default
-
browser
-
agent
.
exe
"
;
return
lazy
.
Subprocess
.
call
(
{
.
.
.
options
command
:
options
.
command
|
|
wdba
.
path
}
)
;
}
_userChoiceImpossibleTelemetryResult
(
)
{
if
(
!
ShellService
.
checkAllProgIDsExist
(
)
)
{
return
"
ErrProgID
"
;
}
if
(
!
ShellService
.
checkBrowserUserChoiceHashes
(
)
)
{
return
"
ErrHash
"
;
}
return
null
;
}
_shouldSetDefaultPDFHandler
(
)
{
if
(
!
lazy
.
NimbusFeatures
.
shellService
.
getVariable
(
"
setDefaultPDFHandlerOnlyReplaceBrowsers
"
)
)
{
return
true
;
}
const
handler
=
this
.
getDefaultPDFHandler
(
)
;
if
(
handler
=
=
=
null
)
{
lazy
.
log
.
warn
(
"
Could
not
determine
default
PDF
handler
:
not
setting
Firefox
as
"
+
"
default
PDF
handler
!
"
)
;
return
false
;
}
if
(
!
handler
.
registered
)
{
lazy
.
log
.
debug
(
"
Current
default
PDF
handler
has
no
registered
association
;
"
+
"
should
set
as
default
PDF
handler
.
"
)
;
return
true
;
}
if
(
handler
.
knownBrowser
)
{
lazy
.
log
.
debug
(
"
Current
default
PDF
handler
progID
matches
known
browser
;
should
"
+
"
set
as
default
PDF
handler
.
"
)
;
return
true
;
}
lazy
.
log
.
debug
(
"
Current
default
PDF
handler
progID
does
not
match
known
browser
"
+
"
prefix
;
should
not
set
as
default
PDF
handler
.
"
)
;
return
false
;
}
getDefaultPDFHandler
(
)
{
const
knownBrowserPrefixes
=
[
"
AppXq0fevzme2pys62n3e0fbqa7peapykr8v
"
"
Brave
"
"
Chrome
"
"
Firefox
"
"
IE
"
"
MSEdge
"
"
Opera
"
"
Yandex
"
]
;
let
currentProgID
=
"
"
;
try
{
currentProgID
=
this
.
queryCurrentDefaultHandlerFor
(
"
.
pdf
"
)
;
}
catch
(
e
)
{
lazy
.
log
.
warn
(
"
Failed
to
queryCurrentDefaultHandlerFor
:
"
)
;
return
null
;
}
if
(
currentProgID
=
=
"
"
)
{
return
{
registered
:
false
knownBrowser
:
false
}
;
}
const
knownBrowserPrefix
=
knownBrowserPrefixes
.
find
(
it
=
>
currentProgID
.
startsWith
(
it
)
)
;
if
(
knownBrowserPrefix
)
{
lazy
.
log
.
debug
(
Found
known
browser
prefix
:
{
knownBrowserPrefix
}
)
;
}
return
{
registered
:
true
knownBrowser
:
!
!
knownBrowserPrefix
}
;
}
async
setAsDefaultUserChoice
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
new
Error
(
"
Windows
-
only
"
)
;
}
lazy
.
log
.
info
(
"
Setting
Firefox
as
default
using
UserChoice
"
)
;
let
telemetryResult
=
"
ErrOther
"
;
try
{
telemetryResult
=
this
.
_userChoiceImpossibleTelemetryResult
(
)
?
?
"
ErrOther
"
;
if
(
telemetryResult
=
=
"
ErrProgID
"
)
{
throw
new
Error
(
"
checkAllProgIDsExist
(
)
failed
"
)
;
}
if
(
telemetryResult
=
=
"
ErrHash
"
)
{
throw
new
Error
(
"
checkBrowserUserChoiceHashes
(
)
failed
"
)
;
}
const
aumi
=
lazy
.
XreDirProvider
.
getInstallHash
(
)
;
telemetryResult
=
"
ErrLaunchExe
"
;
const
exeArgs
=
[
"
set
-
default
-
browser
-
user
-
choice
"
aumi
]
;
if
(
lazy
.
NimbusFeatures
.
shellService
.
getVariable
(
"
setDefaultPDFHandler
"
)
)
{
if
(
this
.
_shouldSetDefaultPDFHandler
(
)
)
{
lazy
.
log
.
info
(
"
Setting
Firefox
as
default
PDF
handler
"
)
;
exeArgs
.
push
(
"
.
pdf
"
"
FirefoxPDF
"
)
;
}
else
{
lazy
.
log
.
info
(
"
Not
setting
Firefox
as
default
PDF
handler
"
)
;
}
}
const
exeProcess
=
await
this
.
_callExternalDefaultBrowserAgent
(
{
arguments
:
exeArgs
}
)
;
telemetryResult
=
"
ErrOther
"
;
this
.
_handleWDBAResult
(
exeProcess
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
WDBAError
)
{
telemetryResult
=
ex
.
telemetryResult
;
}
throw
ex
;
}
finally
{
try
{
const
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_SET_DEFAULT_USER_CHOICE_RESULT
"
)
;
histogram
.
add
(
telemetryResult
)
;
}
catch
(
ex
)
{
}
}
}
async
setAsDefaultPDFHandlerUserChoice
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
new
Error
(
"
Windows
-
only
"
)
;
}
let
telemetryResult
=
"
ErrOther
"
;
try
{
const
aumi
=
lazy
.
XreDirProvider
.
getInstallHash
(
)
;
const
exeProcess
=
await
this
.
_callExternalDefaultBrowserAgent
(
{
arguments
:
[
"
set
-
default
-
extension
-
handlers
-
user
-
choice
"
aumi
"
.
pdf
"
"
FirefoxPDF
"
]
}
)
;
telemetryResult
=
"
ErrOther
"
;
this
.
_handleWDBAResult
(
exeProcess
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
WDBAError
)
{
telemetryResult
=
ex
.
telemetryResult
;
}
throw
ex
;
}
finally
{
try
{
const
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_SET_DEFAULT_PDF_HANDLER_USER_CHOICE_RESULT
"
)
;
histogram
.
add
(
telemetryResult
)
;
}
catch
(
ex
)
{
}
}
}
setDefaultBrowser
(
claimAllTypes
forAllUsers
)
{
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
"
)
&
&
lazy
.
NimbusFeatures
.
shellService
.
getVariable
(
"
setDefaultBrowserUserChoice
"
)
)
{
this
.
setAsDefaultUserChoice
(
)
.
catch
(
err
=
>
{
console
.
error
(
err
)
;
this
.
shellService
.
setDefaultBrowser
(
claimAllTypes
forAllUsers
)
;
}
)
;
return
;
}
this
.
shellService
.
setDefaultBrowser
(
claimAllTypes
forAllUsers
)
;
}
setAsDefault
(
)
{
let
claimAllTypes
=
true
;
let
setAsDefaultError
=
false
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
try
{
let
version
=
Services
.
sysinfo
.
getProperty
(
"
version
"
)
;
claimAllTypes
=
parseFloat
(
version
)
<
6
.
2
;
}
catch
(
ex
)
{
}
}
try
{
ShellService
.
setDefaultBrowser
(
claimAllTypes
false
)
;
}
catch
(
ex
)
{
setAsDefaultError
=
true
;
console
.
error
(
ex
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_IS_USER_DEFAULT
"
)
.
add
(
!
setAsDefaultError
)
;
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_SET_DEFAULT_ERROR
"
)
.
add
(
setAsDefaultError
)
;
}
setAsDefaultPDFHandler
(
onlyIfKnownBrowser
=
false
)
{
if
(
onlyIfKnownBrowser
&
&
!
this
.
getDefaultPDFHandler
(
)
.
knownBrowser
)
{
return
;
}
if
(
AppConstants
.
isPlatformAndVersionAtLeast
(
"
win
"
"
10
"
)
)
{
this
.
setAsDefaultPDFHandlerUserChoice
(
)
;
}
}
isDefaultHandlerFor
(
aFileExtensionOrProtocol
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
return
this
.
shellService
.
QueryInterface
(
Ci
.
nsIWindowsShellService
)
.
isDefaultHandlerFor
(
aFileExtensionOrProtocol
)
;
}
return
false
;
}
async
doesAppNeedPin
(
privateBrowsing
=
false
)
{
if
(
Services
.
appinfo
.
processType
!
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Components
.
Exception
(
"
Can
'
t
determine
pinned
from
child
process
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
lazy
.
NimbusFeatures
.
shellService
.
getVariable
(
"
disablePin
"
)
)
{
return
false
;
}
try
{
await
this
.
shellService
.
QueryInterface
(
Ci
.
nsIWindowsShellService
)
.
checkPinCurrentAppToTaskbarAsync
(
privateBrowsing
)
;
let
winTaskbar
=
Cc
[
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
]
.
getService
(
Ci
.
nsIWinTaskbar
)
;
return
!
(
await
this
.
shellService
.
isCurrentAppPinnedToTaskbarAsync
(
privateBrowsing
?
winTaskbar
.
defaultPrivateGroupId
:
winTaskbar
.
defaultGroupId
)
)
;
}
catch
(
ex
)
{
}
try
{
const
isInDock
=
this
.
macDockSupport
.
isAppInDock
;
return
privateBrowsing
?
false
:
!
isInDock
;
}
catch
(
ex
)
{
}
return
false
;
}
async
pinToTaskbar
(
privateBrowsing
=
false
)
{
if
(
await
this
.
doesAppNeedPin
(
privateBrowsing
)
)
{
try
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
await
this
.
shellService
.
pinCurrentAppToTaskbarAsync
(
privateBrowsing
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
macDockSupport
.
ensureAppIsPinnedToDock
(
)
;
}
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
}
async
_handleWDBAResult
(
exeProcess
exeWaitTimeoutMs
=
2000
)
{
const
S_OK
=
0
;
const
STILL_ACTIVE
=
0x103
;
const
MOZ_E_NO_PROGID
=
0xa0000001
;
const
MOZ_E_HASH_CHECK
=
0xa0000002
;
const
MOZ_E_REJECTED
=
0xa0000003
;
const
MOZ_E_BUILD
=
0xa0000004
;
const
exeWaitPromise
=
exeProcess
.
wait
(
)
;
const
timeoutPromise
=
new
Promise
(
function
(
resolve
)
{
lazy
.
setTimeout
(
(
)
=
>
resolve
(
{
exitCode
:
STILL_ACTIVE
}
)
exeWaitTimeoutMs
)
;
}
)
;
const
{
exitCode
}
=
await
Promise
.
race
(
[
exeWaitPromise
timeoutPromise
]
)
;
if
(
exitCode
!
=
S_OK
)
{
const
telemetryResult
=
new
Map
(
[
[
STILL_ACTIVE
"
ErrExeTimeout
"
]
[
MOZ_E_NO_PROGID
"
ErrExeProgID
"
]
[
MOZ_E_HASH_CHECK
"
ErrExeHash
"
]
[
MOZ_E_REJECTED
"
ErrExeRejected
"
]
[
MOZ_E_BUILD
"
ErrBuild
"
]
]
)
.
get
(
exitCode
)
?
?
"
ErrExeOther
"
;
throw
new
WDBAError
(
exitCode
telemetryResult
)
;
}
}
}
;
XPCOMUtils
.
defineLazyServiceGetters
(
ShellServiceInternal
{
shellService
:
[
"
mozilla
.
org
/
browser
/
shell
-
service
;
1
"
"
nsIShellService
"
]
macDockSupport
:
[
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
"
nsIMacDockSupport
"
]
}
)
;
var
ShellService
=
new
Proxy
(
ShellServiceInternal
{
get
(
target
name
)
{
if
(
name
in
target
)
{
return
target
[
name
]
;
}
if
(
target
.
shellService
)
{
return
target
.
shellService
[
name
]
;
}
Services
.
console
.
logStringMessage
(
{
name
}
not
found
in
ShellService
:
{
target
.
shellService
}
)
;
return
undefined
;
}
}
)
;
class
WDBAError
extends
Error
{
constructor
(
exitCode
telemetryResult
)
{
super
(
WDBA
nonzero
exit
code
{
exitCode
}
:
{
telemetryResult
}
)
;
this
.
exitCode
=
exitCode
;
this
.
telemetryResult
=
telemetryResult
;
}
}
