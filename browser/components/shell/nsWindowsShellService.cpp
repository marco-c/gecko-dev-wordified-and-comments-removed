#
define
UNICODE
#
include
"
nsWindowsShellService
.
h
"
#
include
"
nsWindowsShellServiceInternal
.
h
"
#
include
"
BinaryPath
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
intl
/
Localization
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
widget
/
WinTaskbar
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
nsINIParser
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsLocalFile
.
h
"
#
include
"
nsNativeAppSupportWin
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsShellService
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
Windows11TaskbarPinning
.
h
"
#
include
"
WindowsDefaultBrowser
.
h
"
#
include
"
WindowsUserChoice
.
h
"
#
include
"
WinUtils
.
h
"
#
include
<
comutil
.
h
>
#
include
<
knownfolders
.
h
>
#
include
<
mbstring
.
h
>
#
include
<
objbase
.
h
>
#
include
<
propkey
.
h
>
#
include
<
propvarutil
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
strsafe
.
h
>
#
include
<
windows
.
h
>
#
include
<
windows
.
foundation
.
h
>
#
include
<
wrl
.
h
>
#
include
<
wrl
/
wrappers
/
corewrappers
.
h
>
using
namespace
ABI
:
:
Windows
;
using
namespace
ABI
:
:
Windows
:
:
Foundation
;
using
namespace
ABI
:
:
Windows
:
:
Foundation
:
:
Collections
;
using
namespace
Microsoft
:
:
WRL
;
using
namespace
Microsoft
:
:
WRL
:
:
Wrappers
;
#
ifndef
__MINGW32__
#
include
<
windows
.
applicationmodel
.
h
>
#
include
<
windows
.
applicationmodel
.
activation
.
h
>
#
include
<
windows
.
applicationmodel
.
core
.
h
>
#
include
<
windows
.
ui
.
startscreen
.
h
>
using
namespace
ABI
:
:
Windows
:
:
ApplicationModel
;
using
namespace
ABI
:
:
Windows
:
:
ApplicationModel
:
:
Core
;
using
namespace
ABI
:
:
Windows
:
:
UI
:
:
StartScreen
;
#
endif
#
define
PRIVATE_BROWSING_BINARY
L
"
private_browsing
.
exe
"
#
undef
ACCESS_READ
#
ifndef
MAX_BUF
#
define
MAX_BUF
4096
#
endif
#
define
REG_SUCCEEDED
(
val
)
(
val
=
=
ERROR_SUCCESS
)
#
define
REG_FAILED
(
val
)
(
val
!
=
ERROR_SUCCESS
)
#
ifdef
DEBUG
#
define
NS_ENSURE_HRESULT
(
hres
ret
)
\
do
{
\
HRESULT
result
=
hres
;
\
if
(
MOZ_UNLIKELY
(
FAILED
(
result
)
)
)
{
\
mozilla
:
:
SmprintfPointer
msg
=
mozilla
:
:
Smprintf
(
\
"
NS_ENSURE_HRESULT
(
%
s
%
s
)
failed
with
"
\
"
result
0x
%
"
PRIX32
\
#
hres
#
ret
static_cast
<
uint32_t
>
(
result
)
)
;
\
NS_WARNING
(
msg
.
get
(
)
)
;
\
return
ret
;
\
}
\
}
while
(
false
)
#
else
#
define
NS_ENSURE_HRESULT
(
hres
ret
)
\
if
(
MOZ_UNLIKELY
(
FAILED
(
hres
)
)
)
return
ret
#
endif
using
namespace
mozilla
;
using
mozilla
:
:
intl
:
:
Localization
;
struct
SysFreeStringDeleter
{
void
operator
(
)
(
BSTR
aPtr
)
{
:
:
SysFreeString
(
aPtr
)
;
}
}
;
using
BStrPtr
=
mozilla
:
:
UniquePtr
<
OLECHAR
SysFreeStringDeleter
>
;
NS_IMPL_ISUPPORTS
(
nsWindowsShellService
nsIToolkitShellService
nsIShellService
nsIWindowsShellService
)
static
LazyLogModule
sLog
(
"
nsWindowsShellService
"
)
;
static
bool
PollAppsFolderForShortcut
(
const
nsAString
&
aAppUserModelId
const
TimeDuration
aTimeout
)
;
static
nsresult
PinCurrentAppToTaskbarWin10
(
bool
aCheckOnly
const
nsAString
&
aAppUserModelId
const
nsAString
&
aShortcutPath
)
;
static
nsresult
WriteBitmap
(
nsIFile
*
aFile
imgIContainer
*
aImage
)
;
static
nsresult
WriteIcon
(
nsIFile
*
aIcoFile
gfx
:
:
DataSourceSurface
*
aSurface
)
;
static
nsresult
OpenKeyForReading
(
HKEY
aKeyRoot
const
nsAString
&
aKeyName
HKEY
*
aKey
)
{
const
nsString
&
flatName
=
PromiseFlatString
(
aKeyName
)
;
DWORD
res
=
:
:
RegOpenKeyExW
(
aKeyRoot
flatName
.
get
(
)
0
KEY_READ
aKey
)
;
switch
(
res
)
{
case
ERROR_SUCCESS
:
break
;
case
ERROR_ACCESS_DENIED
:
return
NS_ERROR_FILE_ACCESS_DENIED
;
case
ERROR_FILE_NOT_FOUND
:
return
NS_ERROR_NOT_AVAILABLE
;
}
return
NS_OK
;
}
nsresult
GetHelperPath
(
nsAutoString
&
aPath
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
directoryService
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
appHelper
;
rv
=
directoryService
-
>
Get
(
XRE_EXECUTABLE_FILE
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
appHelper
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
appHelper
-
>
SetNativeLeafName
(
"
uninstall
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
appHelper
-
>
AppendNative
(
"
helper
.
exe
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
appHelper
-
>
GetPath
(
aPath
)
;
aPath
.
Insert
(
L
'
"
'
0
)
;
aPath
.
Append
(
L
'
"
'
)
;
return
rv
;
}
nsresult
LaunchHelper
(
nsAutoString
&
aPath
)
{
STARTUPINFOW
si
=
{
sizeof
(
si
)
0
}
;
PROCESS_INFORMATION
pi
=
{
0
}
;
if
(
!
CreateProcessW
(
nullptr
(
LPWSTR
)
aPath
.
get
(
)
nullptr
nullptr
FALSE
0
nullptr
nullptr
&
si
&
pi
)
)
{
return
NS_ERROR_FAILURE
;
}
CloseHandle
(
pi
.
hProcess
)
;
CloseHandle
(
pi
.
hThread
)
;
return
NS_OK
;
}
static
bool
IsPathDefaultForClass
(
const
RefPtr
<
IApplicationAssociationRegistration
>
&
pAAR
wchar_t
*
exePath
LPCWSTR
aClassName
)
{
LPWSTR
registeredApp
;
bool
isProtocol
=
*
aClassName
!
=
L
'
.
'
;
ASSOCIATIONTYPE
queryType
=
isProtocol
?
AT_URLPROTOCOL
:
AT_FILEEXTENSION
;
HRESULT
hr
=
pAAR
-
>
QueryCurrentDefault
(
aClassName
queryType
AL_EFFECTIVE
&
registeredApp
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
nsAutoString
regAppName
(
registeredApp
)
;
CoTaskMemFree
(
registeredApp
)
;
regAppName
.
AppendLiteral
(
"
\
\
shell
\
\
open
\
\
command
"
)
;
HKEY
theKey
;
nsresult
rv
=
OpenKeyForReading
(
HKEY_CLASSES_ROOT
regAppName
&
theKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
wchar_t
cmdFromReg
[
MAX_BUF
]
=
L
"
"
;
DWORD
len
=
sizeof
(
cmdFromReg
)
;
DWORD
res
=
:
:
RegQueryValueExW
(
theKey
nullptr
nullptr
nullptr
(
LPBYTE
)
cmdFromReg
&
len
)
;
:
:
RegCloseKey
(
theKey
)
;
if
(
REG_FAILED
(
res
)
)
{
return
false
;
}
nsAutoString
pathFromReg
(
cmdFromReg
)
;
nsLocalFile
:
:
CleanupCmdHandlerPath
(
pathFromReg
)
;
return
_wcsicmp
(
exePath
pathFromReg
.
Data
(
)
)
=
=
0
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
IsDefaultBrowser
(
bool
aForAllTypes
bool
*
aIsDefaultBrowser
)
{
*
aIsDefaultBrowser
=
false
;
RefPtr
<
IApplicationAssociationRegistration
>
pAAR
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_ApplicationAssociationRegistration
nullptr
CLSCTX_INPROC
IID_IApplicationAssociationRegistration
getter_AddRefs
(
pAAR
)
)
;
if
(
FAILED
(
hr
)
)
{
return
NS_OK
;
}
wchar_t
exePath
[
MAXPATHLEN
]
=
L
"
"
;
nsresult
rv
=
BinaryPath
:
:
GetLong
(
exePath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
*
aIsDefaultBrowser
=
IsPathDefaultForClass
(
pAAR
exePath
L
"
http
"
)
;
if
(
*
aIsDefaultBrowser
&
&
aForAllTypes
)
{
*
aIsDefaultBrowser
=
IsPathDefaultForClass
(
pAAR
exePath
L
"
.
html
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
IsDefaultHandlerFor
(
const
nsAString
&
aFileExtensionOrProtocol
bool
*
aIsDefaultHandlerFor
)
{
*
aIsDefaultHandlerFor
=
false
;
RefPtr
<
IApplicationAssociationRegistration
>
pAAR
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_ApplicationAssociationRegistration
nullptr
CLSCTX_INPROC
IID_IApplicationAssociationRegistration
getter_AddRefs
(
pAAR
)
)
;
if
(
FAILED
(
hr
)
)
{
return
NS_OK
;
}
wchar_t
exePath
[
MAXPATHLEN
]
=
L
"
"
;
nsresult
rv
=
BinaryPath
:
:
GetLong
(
exePath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
const
nsString
&
flatClass
=
PromiseFlatString
(
aFileExtensionOrProtocol
)
;
*
aIsDefaultHandlerFor
=
IsPathDefaultForClass
(
pAAR
exePath
flatClass
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
QueryCurrentDefaultHandlerFor
(
const
nsAString
&
aFileExtensionOrProtocol
nsAString
&
aResult
)
{
aResult
.
Truncate
(
)
;
RefPtr
<
IApplicationAssociationRegistration
>
pAAR
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_ApplicationAssociationRegistration
nullptr
CLSCTX_INPROC
IID_IApplicationAssociationRegistration
getter_AddRefs
(
pAAR
)
)
;
if
(
FAILED
(
hr
)
)
{
return
NS_OK
;
}
const
nsString
&
flatClass
=
PromiseFlatString
(
aFileExtensionOrProtocol
)
;
LPWSTR
registeredApp
;
bool
isProtocol
=
flatClass
.
First
(
)
!
=
L
'
.
'
;
ASSOCIATIONTYPE
queryType
=
isProtocol
?
AT_URLPROTOCOL
:
AT_FILEEXTENSION
;
hr
=
pAAR
-
>
QueryCurrentDefault
(
flatClass
.
get
(
)
queryType
AL_EFFECTIVE
&
registeredApp
)
;
if
(
hr
=
=
HRESULT_FROM_WIN32
(
ERROR_NO_ASSOCIATION
)
)
{
return
NS_OK
;
}
NS_ENSURE_HRESULT
(
hr
NS_ERROR_FAILURE
)
;
aResult
=
registeredApp
;
CoTaskMemFree
(
registeredApp
)
;
return
NS_OK
;
}
nsresult
nsWindowsShellService
:
:
LaunchControlPanelDefaultsSelectionUI
(
)
{
IApplicationAssociationRegistrationUI
*
pAARUI
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_ApplicationAssociationRegistrationUI
NULL
CLSCTX_INPROC
IID_IApplicationAssociationRegistrationUI
(
void
*
*
)
&
pAARUI
)
;
if
(
SUCCEEDED
(
hr
)
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
appRegName
;
GetAppRegName
(
appRegName
)
;
hr
=
pAARUI
-
>
LaunchAdvancedAssociationUI
(
appRegName
.
get
(
)
)
;
pAARUI
-
>
Release
(
)
;
}
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
CheckAllProgIDsExist
(
bool
*
aResult
)
{
*
aResult
=
false
;
nsAutoString
aumid
;
if
(
!
mozilla
:
:
widget
:
:
WinTaskbar
:
:
GetAppUserModelID
(
aumid
)
)
{
return
NS_OK
;
}
if
(
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
UniquePtr
<
wchar_t
[
]
>
extraProgID
;
nsresult
rv
;
bool
result
=
true
;
rv
=
GetMsixProgId
(
L
"
https
"
extraProgID
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
result
=
result
&
&
CheckProgIDExists
(
extraProgID
.
get
(
)
)
;
rv
=
GetMsixProgId
(
L
"
.
htm
"
extraProgID
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
result
=
result
&
&
CheckProgIDExists
(
extraProgID
.
get
(
)
)
;
rv
=
GetMsixProgId
(
L
"
.
pdf
"
extraProgID
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
result
=
result
&
&
CheckProgIDExists
(
extraProgID
.
get
(
)
)
;
*
aResult
=
result
;
}
else
{
*
aResult
=
CheckProgIDExists
(
FormatProgID
(
L
"
FirefoxURL
"
aumid
.
get
(
)
)
.
get
(
)
)
&
&
CheckProgIDExists
(
FormatProgID
(
L
"
FirefoxHTML
"
aumid
.
get
(
)
)
.
get
(
)
)
&
&
CheckProgIDExists
(
FormatProgID
(
L
"
FirefoxPDF
"
aumid
.
get
(
)
)
.
get
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
CheckBrowserUserChoiceHashes
(
bool
*
aResult
)
{
*
aResult
=
:
:
CheckBrowserUserChoiceHashes
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
CheckCurrentProcessAUMIDForTesting
(
nsAString
&
aRetAumid
)
{
PWSTR
id
;
HRESULT
hr
=
GetCurrentProcessExplicitAppUserModelID
(
&
id
)
;
if
(
FAILED
(
hr
)
)
{
if
(
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
aRetAumid
.
Assign
(
u
"
MSIXAumidTestValue
"
_ns
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
aRetAumid
.
Assign
(
id
)
;
CoTaskMemFree
(
id
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
CanSetDefaultBrowserUserChoice
(
bool
*
aResult
)
{
*
aResult
=
false
;
#
ifdef
MOZ_DEFAULT_BROWSER_AGENT
bool
progIDsExist
=
false
;
bool
hashOk
=
false
;
*
aResult
=
NS_SUCCEEDED
(
CheckAllProgIDsExist
(
&
progIDsExist
)
)
&
&
progIDsExist
&
&
NS_SUCCEEDED
(
CheckBrowserUserChoiceHashes
(
&
hashOk
)
)
&
&
hashOk
;
#
endif
return
NS_OK
;
}
nsresult
nsWindowsShellService
:
:
LaunchModernSettingsDialogDefaultApps
(
)
{
return
:
:
LaunchModernSettingsDialogDefaultApps
(
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
SetDefaultBrowser
(
bool
aForAllUsers
)
{
nsresult
rv
=
NS_OK
;
if
(
!
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
nsAutoString
appHelperPath
;
if
(
NS_FAILED
(
GetHelperPath
(
appHelperPath
)
)
)
return
NS_ERROR_FAILURE
;
if
(
aForAllUsers
)
{
appHelperPath
.
AppendLiteral
(
"
/
SetAsDefaultAppGlobal
"
)
;
}
else
{
appHelperPath
.
AppendLiteral
(
"
/
SetAsDefaultAppUser
"
)
;
}
rv
=
LaunchHelper
(
appHelperPath
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
LaunchModernSettingsDialogDefaultApps
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
LaunchControlPanelDefaultsSelectionUI
(
)
;
}
}
nsCOMPtr
<
nsIPrefBranch
>
prefs
(
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
)
;
if
(
prefs
)
{
(
void
)
prefs
-
>
SetBoolPref
(
PREF_CHECKDEFAULTBROWSER
true
)
;
(
void
)
prefs
-
>
SetIntPref
(
PREF_DEFAULTBROWSERCHECKCOUNT
0
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
CreateWindowsIcon
(
nsIFile
*
aIcoFile
imgIContainer
*
aImage
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
NS_ENSURE_ARG_POINTER
(
aIcoFile
)
;
NS_ENSURE_ARG_POINTER
(
aImage
)
;
NS_ENSURE_ARG_POINTER
(
aCx
)
;
NS_ENSURE_ARG_POINTER
(
aPromise
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
CreateWindowsIcon
promise
"
promise
)
;
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
%
s
:
%
d
-
Reading
input
image
.
.
.
\
n
"
__FILE__
__LINE__
)
)
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
aImage
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
NS_ENSURE_TRUE
(
surface
NS_ERROR_FAILURE
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
%
s
:
%
d
-
Surface
found
writing
icon
.
.
.
\
n
"
__FILE__
__LINE__
)
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
CreateWindowsIcon
"
[
icoFile
=
nsCOMPtr
<
nsIFile
>
(
aIcoFile
)
dataSurface
promiseHolder
]
{
nsresult
rv
=
WriteIcon
(
icoFile
dataSurface
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
CreateWindowsIcon
callback
"
[
rv
promiseHolder
]
{
dom
:
:
Promise
*
promise
=
promiseHolder
.
get
(
)
-
>
get
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
else
{
promise
-
>
MaybeReject
(
rv
)
;
}
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
static
nsresult
WriteIcon
(
nsIFile
*
aIcoFile
gfx
:
:
DataSourceSurface
*
aSurface
)
{
NS_ENSURE_ARG
(
aIcoFile
)
;
NS_ENSURE_ARG
(
aSurface
)
;
const
gfx
:
:
IntSize
size
=
aSurface
-
>
GetSize
(
)
;
if
(
size
.
IsEmpty
(
)
)
{
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
%
s
:
%
d
-
The
input
image
looks
empty
:
(
\
n
"
__FILE__
__LINE__
)
)
;
return
NS_ERROR_FAILURE
;
}
int32_t
width
=
aSurface
-
>
GetSize
(
)
.
width
;
int32_t
height
=
aSurface
-
>
GetSize
(
)
.
height
;
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
%
s
:
%
d
-
Input
image
dimensions
are
:
%
dx
%
d
pixels
\
n
"
__FILE__
__LINE__
width
height
)
)
;
NS_ENSURE_TRUE
(
height
>
0
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
width
>
0
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
width
=
=
height
NS_ERROR_FAILURE
)
;
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
%
s
:
%
d
-
Opening
file
for
writing
.
.
.
\
n
"
__FILE__
__LINE__
)
)
;
ScopedCloseFile
file
;
nsresult
rv
=
aIcoFile
-
>
OpenANSIFileDesc
(
"
wb
"
getter_Transfers
(
file
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
%
s
:
%
d
-
Writing
icon
.
.
.
\
n
"
__FILE__
__LINE__
)
)
;
rv
=
gfxUtils
:
:
EncodeSourceSurface
(
aSurface
ImageType
:
:
ICO
u
"
"
_ns
gfxUtils
:
:
eBinaryEncode
file
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
%
s
:
%
d
-
Could
not
write
the
icon
!
\
n
"
__FILE__
__LINE__
)
)
;
return
rv
;
}
MOZ_LOG
(
sLog
LogLevel
:
:
Debug
(
"
%
s
:
%
d
-
Icon
written
!
\
n
"
__FILE__
__LINE__
)
)
;
return
NS_OK
;
}
static
nsresult
WriteBitmap
(
nsIFile
*
aFile
imgIContainer
*
aImage
)
{
nsresult
rv
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
aImage
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
NS_ENSURE_TRUE
(
surface
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
surface
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
|
|
surface
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
int32_t
width
=
dataSurface
-
>
GetSize
(
)
.
width
;
int32_t
height
=
dataSurface
-
>
GetSize
(
)
.
height
;
int32_t
bytesPerPixel
=
4
*
sizeof
(
uint8_t
)
;
uint32_t
bytesPerRow
=
bytesPerPixel
*
width
;
BITMAPINFOHEADER
bmi
;
bmi
.
biSize
=
sizeof
(
BITMAPINFOHEADER
)
;
bmi
.
biWidth
=
width
;
bmi
.
biHeight
=
height
;
bmi
.
biPlanes
=
1
;
bmi
.
biBitCount
=
(
WORD
)
bytesPerPixel
*
8
;
bmi
.
biCompression
=
BI_RGB
;
bmi
.
biSizeImage
=
bytesPerRow
*
height
;
bmi
.
biXPelsPerMeter
=
0
;
bmi
.
biYPelsPerMeter
=
0
;
bmi
.
biClrUsed
=
0
;
bmi
.
biClrImportant
=
0
;
BITMAPFILEHEADER
bf
;
bf
.
bfType
=
0x4D42
;
bf
.
bfReserved1
=
0
;
bf
.
bfReserved2
=
0
;
bf
.
bfOffBits
=
sizeof
(
BITMAPFILEHEADER
)
+
sizeof
(
BITMAPINFOHEADER
)
;
bf
.
bfSize
=
bf
.
bfOffBits
+
bmi
.
biSizeImage
;
nsCOMPtr
<
nsIOutputStream
>
stream
;
rv
=
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
stream
)
aFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
NS_WARN_IF
(
!
stream
)
)
{
MOZ_ASSERT
(
stream
"
rv
should
have
failed
when
stream
is
not
initialized
.
"
)
;
return
NS_ERROR_FAILURE
;
}
gfx
:
:
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dataSurface
-
>
Map
(
gfx
:
:
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
rv
=
NS_ERROR_FAILURE
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
written
;
rv
=
stream
-
>
Write
(
(
const
char
*
)
&
bf
sizeof
(
BITMAPFILEHEADER
)
&
written
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
stream
-
>
Write
(
(
const
char
*
)
&
bmi
sizeof
(
BITMAPINFOHEADER
)
&
written
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
i
=
map
.
mStride
*
height
;
do
{
i
-
=
map
.
mStride
;
rv
=
stream
-
>
Write
(
(
(
const
char
*
)
map
.
mData
)
+
i
bytesPerRow
&
written
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
while
(
i
!
=
0
)
;
}
}
dataSurface
-
>
Unmap
(
)
;
}
stream
-
>
Close
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
aFile
-
>
Remove
(
PR_FALSE
)
)
)
)
{
MOZ_LOG
(
sLog
LogLevel
:
:
Warning
(
"
Failed
to
remove
empty
bitmap
file
:
%
s
"
aFile
-
>
HumanReadablePath
(
)
.
get
(
)
)
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
SetDesktopBackground
(
dom
:
:
Element
*
aElement
int32_t
aPosition
const
nsACString
&
aImageName
)
{
if
(
!
aElement
|
|
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageContent
=
do_QueryInterface
(
aElement
&
rv
)
;
if
(
!
imageContent
)
return
rv
;
nsCOMPtr
<
imgIRequest
>
request
;
rv
=
imageContent
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
request
)
)
;
if
(
!
request
)
return
rv
;
nsCOMPtr
<
imgIContainer
>
container
;
rv
=
request
-
>
GetImage
(
getter_AddRefs
(
container
)
)
;
if
(
!
container
)
return
NS_ERROR_FAILURE
;
nsTArray
<
nsCString
>
resIds
=
{
"
browser
/
setDesktopBackground
.
ftl
"
_ns
}
;
RefPtr
<
Localization
>
l10n
=
Localization
:
:
Create
(
resIds
true
)
;
nsAutoCString
fileLeafNameUtf8
;
IgnoredErrorResult
locRv
;
l10n
-
>
FormatValueSync
(
"
set
-
desktop
-
background
-
filename
"
_ns
{
}
fileLeafNameUtf8
locRv
)
;
nsAutoString
fileLeafName
=
NS_ConvertUTF8toUTF16
(
fileLeafNameUtf8
)
;
fileLeafName
.
AppendLiteral
(
"
.
bmp
"
)
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_APPLICATION_REGISTRY_DIR
getter_AddRefs
(
file
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
file
-
>
Append
(
fileLeafName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
path
;
rv
=
file
-
>
GetPath
(
path
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WriteBitmap
(
file
container
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
regKey
-
>
Create
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
u
"
Control
Panel
\
\
Desktop
"
_ns
nsIWindowsRegKey
:
:
ACCESS_SET_VALUE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
tile
;
nsAutoString
style
;
switch
(
aPosition
)
{
case
BACKGROUND_TILE
:
style
.
Assign
(
'
0
'
)
;
tile
.
Assign
(
'
1
'
)
;
break
;
case
BACKGROUND_CENTER
:
style
.
Assign
(
'
0
'
)
;
tile
.
Assign
(
'
0
'
)
;
break
;
case
BACKGROUND_STRETCH
:
style
.
Assign
(
'
2
'
)
;
tile
.
Assign
(
'
0
'
)
;
break
;
case
BACKGROUND_FILL
:
style
.
AssignLiteral
(
"
10
"
)
;
tile
.
Assign
(
'
0
'
)
;
break
;
case
BACKGROUND_FIT
:
style
.
Assign
(
'
6
'
)
;
tile
.
Assign
(
'
0
'
)
;
break
;
case
BACKGROUND_SPAN
:
style
.
AssignLiteral
(
"
22
"
)
;
tile
.
Assign
(
'
0
'
)
;
break
;
}
rv
=
regKey
-
>
WriteStringValue
(
u
"
TileWallpaper
"
_ns
tile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
regKey
-
>
WriteStringValue
(
u
"
WallpaperStyle
"
_ns
style
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
regKey
-
>
Close
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
:
:
SystemParametersInfoW
(
SPI_SETDESKWALLPAPER
0
(
PVOID
)
path
.
get
(
)
SPIF_UPDATEINIFILE
|
SPIF_SENDCHANGE
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
GetDesktopBackgroundColor
(
uint32_t
*
aColor
)
{
uint32_t
color
=
:
:
GetSysColor
(
COLOR_DESKTOP
)
;
*
aColor
=
(
GetRValue
(
color
)
<
<
16
)
|
(
GetGValue
(
color
)
<
<
8
)
|
GetBValue
(
color
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
SetDesktopBackgroundColor
(
uint32_t
aColor
)
{
int
aParameters
[
2
]
=
{
COLOR_BACKGROUND
COLOR_DESKTOP
}
;
BYTE
r
=
(
aColor
>
>
16
)
;
BYTE
g
=
(
aColor
<
<
16
)
>
>
24
;
BYTE
b
=
(
aColor
<
<
24
)
>
>
24
;
COLORREF
colors
[
2
]
=
{
RGB
(
r
g
b
)
RGB
(
r
g
b
)
}
;
:
:
SetSysColors
(
sizeof
(
aParameters
)
/
sizeof
(
int
)
aParameters
colors
)
;
nsresult
rv
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
regKey
-
>
Create
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
u
"
Control
Panel
\
\
Colors
"
_ns
nsIWindowsRegKey
:
:
ACCESS_SET_VALUE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
wchar_t
rgb
[
12
]
;
_snwprintf
(
rgb
12
L
"
%
u
%
u
%
u
"
r
g
b
)
;
rv
=
regKey
-
>
WriteStringValue
(
u
"
Background
"
_ns
nsDependentString
(
rgb
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
regKey
-
>
Close
(
)
;
}
enum
class
ShortcutsLogChange
{
Add
Remove
}
;
static
nsresult
UpdateShortcutInLog
(
nsIFile
*
aShortcutsLogDir
KNOWNFOLDERID
aFolderId
ShortcutsLogChange
aChange
const
nsAString
&
aShortcutRelativePath
)
{
nsAutoCString
section
;
if
(
aFolderId
=
=
FOLDERID_CommonPrograms
|
|
aFolderId
=
=
FOLDERID_Programs
)
{
section
.
Assign
(
"
STARTMENU
"
)
;
}
else
if
(
aFolderId
=
=
FOLDERID_PublicDesktop
|
|
aFolderId
=
=
FOLDERID_Desktop
)
{
section
.
Assign
(
"
DESKTOP
"
)
;
}
else
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIFile
>
shortcutsLog
;
nsresult
rv
=
aShortcutsLogDir
-
>
GetParent
(
getter_AddRefs
(
shortcutsLog
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
appName
;
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
rv
=
appInfo
-
>
GetName
(
appName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
auto
userSid
=
GetCurrentUserStringSid
(
)
;
if
(
!
userSid
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
nsAutoString
filename
;
filename
.
AppendPrintf
(
"
%
s_
%
ls_shortcuts
.
ini
"
appName
.
get
(
)
userSid
.
get
(
)
)
;
rv
=
shortcutsLog
-
>
Append
(
filename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsINIParser
parser
;
bool
shortcutsLogEntryExists
=
false
;
nsAutoCString
keyName
shortcutRelativePath
iniShortcut
;
shortcutRelativePath
=
NS_ConvertUTF16toUTF8
(
aShortcutRelativePath
)
;
nsAutoCString
lastValidKey
;
nsAutoCString
fileFoundAtKeyName
;
rv
=
parser
.
Init
(
shortcutsLog
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
int
i
=
0
;
;
i
+
+
)
{
keyName
.
AssignLiteral
(
"
Shortcut
"
)
;
keyName
.
AppendInt
(
i
)
;
rv
=
parser
.
GetString
(
section
.
get
(
)
keyName
.
get
(
)
iniShortcut
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FAILURE
)
{
return
rv
;
}
if
(
rv
=
=
NS_ERROR_FAILURE
)
{
break
;
}
else
if
(
iniShortcut
.
Equals
(
shortcutRelativePath
)
)
{
shortcutsLogEntryExists
=
true
;
fileFoundAtKeyName
=
keyName
;
}
lastValidKey
=
keyName
;
}
}
else
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
)
{
keyName
.
AssignLiteral
(
"
Shortcut0
"
)
;
}
else
{
return
rv
;
}
bool
changed
=
false
;
if
(
aChange
=
=
ShortcutsLogChange
:
:
Add
&
&
!
shortcutsLogEntryExists
)
{
parser
.
SetString
(
section
.
get
(
)
keyName
.
get
(
)
shortcutRelativePath
.
get
(
)
)
;
changed
=
true
;
}
else
if
(
aChange
=
=
ShortcutsLogChange
:
:
Remove
&
&
shortcutsLogEntryExists
)
{
parser
.
SetString
(
section
.
get
(
)
fileFoundAtKeyName
.
get
(
)
iniShortcut
.
get
(
)
)
;
parser
.
DeleteString
(
section
.
get
(
)
lastValidKey
.
get
(
)
)
;
changed
=
true
;
}
if
(
changed
)
{
nsAutoCString
formatted
;
parser
.
WriteToString
(
formatted
)
;
FILE
*
writeFile
;
rv
=
shortcutsLog
-
>
OpenANSIFileDesc
(
"
w
ccs
=
UTF
-
16LE
"
&
writeFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF8toUTF16
formattedUTF16
(
formatted
)
;
if
(
fwrite
(
formattedUTF16
.
get
(
)
sizeof
(
wchar_t
)
formattedUTF16
.
Length
(
)
writeFile
)
!
=
formattedUTF16
.
Length
(
)
)
{
fclose
(
writeFile
)
;
return
NS_ERROR_FAILURE
;
}
fclose
(
writeFile
)
;
}
return
NS_OK
;
}
nsresult
CreateShellLinkObject
(
nsIFile
*
aBinary
const
CopyableTArray
<
nsString
>
&
aArguments
const
nsAString
&
aDescription
nsIFile
*
aIconFile
uint16_t
aIconIndex
const
nsAString
&
aAppUserModelId
IShellLinkW
*
*
aLink
)
{
RefPtr
<
IShellLinkW
>
link
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_ShellLink
nullptr
CLSCTX_INPROC_SERVER
IID_IShellLinkW
getter_AddRefs
(
link
)
)
;
NS_ENSURE_HRESULT
(
hr
NS_ERROR_FAILURE
)
;
nsString
path
(
aBinary
-
>
NativePath
(
)
)
;
link
-
>
SetPath
(
path
.
get
(
)
)
;
wchar_t
workingDir
[
MAX_PATH
+
1
]
;
wcscpy_s
(
workingDir
MAX_PATH
+
1
aBinary
-
>
NativePath
(
)
.
get
(
)
)
;
PathRemoveFileSpecW
(
workingDir
)
;
link
-
>
SetWorkingDirectory
(
workingDir
)
;
if
(
!
aDescription
.
IsEmpty
(
)
)
{
link
-
>
SetDescription
(
PromiseFlatString
(
aDescription
)
.
get
(
)
)
;
}
nsString
arguments
;
for
(
const
auto
&
arg
:
aArguments
)
{
arguments
+
=
u
"
\
"
"
_ns
+
arg
+
u
"
\
"
"
_ns
;
}
link
-
>
SetArguments
(
arguments
.
get
(
)
)
;
if
(
aIconFile
)
{
nsString
icon
(
aIconFile
-
>
NativePath
(
)
)
;
link
-
>
SetIconLocation
(
icon
.
get
(
)
aIconIndex
)
;
}
if
(
!
aAppUserModelId
.
IsEmpty
(
)
)
{
RefPtr
<
IPropertyStore
>
propStore
;
hr
=
link
-
>
QueryInterface
(
IID_IPropertyStore
getter_AddRefs
(
propStore
)
)
;
NS_ENSURE_HRESULT
(
hr
NS_ERROR_FAILURE
)
;
PROPVARIANT
pv
;
if
(
FAILED
(
InitPropVariantFromString
(
PromiseFlatString
(
aAppUserModelId
)
.
get
(
)
&
pv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
hr
=
propStore
-
>
SetValue
(
PKEY_AppUserModel_ID
pv
)
;
PropVariantClear
(
&
pv
)
;
NS_ENSURE_HRESULT
(
hr
NS_ERROR_FAILURE
)
;
hr
=
propStore
-
>
Commit
(
)
;
NS_ENSURE_HRESULT
(
hr
NS_ERROR_FAILURE
)
;
}
link
.
forget
(
aLink
)
;
return
NS_OK
;
}
struct
ShortcutLocations
{
KNOWNFOLDERID
folderId
;
nsCOMPtr
<
nsIFile
>
shortcutsLogDir
;
nsCOMPtr
<
nsIFile
>
shortcutFile
;
}
;
static
nsresult
CreateShortcutImpl
(
nsIFile
*
aBinary
const
CopyableTArray
<
nsString
>
&
aArguments
const
nsAString
&
aDescription
nsIFile
*
aIconFile
uint16_t
aIconIndex
const
nsAString
&
aAppUserModelId
const
ShortcutLocations
&
location
const
nsAString
&
aShortcutRelativePath
)
{
NS_ENSURE_ARG
(
aBinary
)
;
NS_ENSURE_ARG
(
aIconFile
)
;
nsresult
rv
=
UpdateShortcutInLog
(
location
.
shortcutsLogDir
location
.
folderId
ShortcutsLogChange
:
:
Add
aShortcutRelativePath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
IShellLinkW
>
link
;
rv
=
CreateShellLinkObject
(
aBinary
aArguments
aDescription
aIconFile
aIconIndex
aAppUserModelId
getter_AddRefs
(
link
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
IPersistFile
>
persist
;
HRESULT
hr
=
link
-
>
QueryInterface
(
IID_IPersistFile
getter_AddRefs
(
persist
)
)
;
NS_ENSURE_HRESULT
(
hr
NS_ERROR_FAILURE
)
;
hr
=
persist
-
>
Save
(
location
.
shortcutFile
-
>
NativePath
(
)
.
get
(
)
TRUE
)
;
NS_ENSURE_HRESULT
(
hr
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
static
Result
<
ShortcutLocations
nsresult
>
GetShortcutPaths
(
const
nsAString
&
aShortcutFolder
const
nsAString
&
aShortcutRelativePath
)
{
using
Err
=
Result
<
ShortcutLocations
nsresult
>
;
KNOWNFOLDERID
folderId
;
if
(
aShortcutFolder
.
Equals
(
L
"
Programs
"
)
)
{
folderId
=
FOLDERID_Programs
;
}
else
if
(
aShortcutFolder
.
Equals
(
L
"
Desktop
"
)
)
{
folderId
=
FOLDERID_Desktop
;
}
else
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
nsCOMPtr
<
nsIFile
>
updRoot
shortcutsLogDir
;
nsresult
nsrv
=
NS_GetSpecialDirectory
(
XRE_UPDATE_ROOT_DIR
getter_AddRefs
(
updRoot
)
)
;
NS_ENSURE_SUCCESS
(
nsrv
Err
(
nsrv
)
)
;
nsrv
=
updRoot
-
>
GetParent
(
getter_AddRefs
(
shortcutsLogDir
)
)
;
NS_ENSURE_SUCCESS
(
nsrv
Err
(
nsrv
)
)
;
nsCOMPtr
<
nsIFile
>
shortcutFile
;
if
(
folderId
=
=
FOLDERID_Programs
)
{
nsrv
=
NS_GetSpecialDirectory
(
NS_WIN_PROGRAMS_DIR
getter_AddRefs
(
shortcutFile
)
)
;
}
else
if
(
folderId
=
=
FOLDERID_Desktop
)
{
nsrv
=
NS_GetSpecialDirectory
(
NS_OS_DESKTOP_DIR
getter_AddRefs
(
shortcutFile
)
)
;
}
else
{
return
Err
(
NS_ERROR_FILE_NOT_FOUND
)
;
}
if
(
NS_FAILED
(
nsrv
)
)
{
return
Err
(
NS_ERROR_FILE_NOT_FOUND
)
;
}
nsrv
=
shortcutFile
-
>
AppendRelativePath
(
aShortcutRelativePath
)
;
NS_ENSURE_SUCCESS
(
nsrv
Err
(
nsrv
)
)
;
ShortcutLocations
result
{
}
;
result
.
folderId
=
folderId
;
result
.
shortcutsLogDir
=
std
:
:
move
(
shortcutsLogDir
)
;
result
.
shortcutFile
=
std
:
:
move
(
shortcutFile
)
;
return
result
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
CreateShortcut
(
nsIFile
*
aBinary
const
nsTArray
<
nsString
>
&
aArguments
const
nsAString
&
aDescription
nsIFile
*
aIconFile
uint16_t
aIconIndex
const
nsAString
&
aAppUserModelId
const
nsAString
&
aShortcutFolder
const
nsAString
&
aShortcutRelativePath
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
ShortcutLocations
location
=
MOZ_TRY
(
GetShortcutPaths
(
aShortcutFolder
aShortcutRelativePath
)
)
;
nsCOMPtr
<
nsIFile
>
parentDirectory
;
nsresult
nsrv
;
nsrv
=
location
.
shortcutFile
-
>
GetParent
(
getter_AddRefs
(
parentDirectory
)
)
;
NS_ENSURE_SUCCESS
(
nsrv
nsrv
)
;
nsrv
=
parentDirectory
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
if
(
NS_FAILED
(
nsrv
)
&
&
nsrv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
)
{
return
nsrv
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
CreateShortcut
promise
"
promise
)
;
nsCOMPtr
<
nsIFile
>
binary
(
aBinary
)
;
nsCOMPtr
<
nsIFile
>
iconFile
(
aIconFile
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
CreateShortcut
"
[
binary
aArguments
=
CopyableTArray
<
nsString
>
(
aArguments
)
aDescription
=
nsString
{
aDescription
}
iconFile
aIconIndex
aAppUserModelId
=
nsString
{
aAppUserModelId
}
location
=
std
:
:
move
(
location
)
aShortcutFolder
=
nsString
{
aShortcutFolder
}
aShortcutRelativePath
=
nsString
{
aShortcutRelativePath
}
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
nsresult
rv
=
CreateShortcutImpl
(
binary
.
get
(
)
aArguments
aDescription
iconFile
.
get
(
)
aIconIndex
aAppUserModelId
location
aShortcutRelativePath
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
CreateShortcut
callback
"
[
rv
shortcutFile
=
location
.
shortcutFile
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
dom
:
:
Promise
*
promise
=
promiseHolder
.
get
(
)
-
>
get
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
promise
-
>
MaybeResolve
(
shortcutFile
-
>
NativePath
(
)
)
;
}
else
{
promise
-
>
MaybeReject
(
rv
)
;
}
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
static
nsresult
DeleteShortcutImpl
(
const
ShortcutLocations
&
aLocation
const
nsAString
&
aShortcutRelativePath
)
{
nsresult
rv
=
aLocation
.
shortcutFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
UpdateShortcutInLog
(
aLocation
.
shortcutsLogDir
aLocation
.
folderId
ShortcutsLogChange
:
:
Remove
aShortcutRelativePath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
DeleteShortcut
(
const
nsAString
&
aShortcutFolder
const
nsAString
&
aShortcutRelativePath
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
ShortcutLocations
location
=
MOZ_TRY
(
GetShortcutPaths
(
aShortcutFolder
aShortcutRelativePath
)
)
;
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
DeleteShortcut
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
DeleteShortcut
"
[
aShortcutFolder
=
nsString
{
aShortcutFolder
}
aShortcutRelativePath
=
nsString
{
aShortcutRelativePath
}
location
=
std
:
:
move
(
location
)
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
nsresult
rv
=
DeleteShortcutImpl
(
location
aShortcutRelativePath
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
DeleteShortcut
callback
"
[
rv
shortcutFile
=
location
.
shortcutFile
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
dom
:
:
Promise
*
promise
=
promiseHolder
.
get
(
)
-
>
get
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
promise
-
>
MaybeResolve
(
shortcutFile
-
>
NativePath
(
)
)
;
}
else
{
promise
-
>
MaybeReject
(
rv
)
;
}
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
GetLaunchOnLoginShortcuts
(
nsTArray
<
nsString
>
&
aShortcutPaths
)
{
aShortcutPaths
.
Clear
(
)
;
RefPtr
<
IKnownFolderManager
>
fManager
;
RefPtr
<
IKnownFolder
>
roamingAppData
;
LPWSTR
roamingAppDataW
;
nsString
roamingAppDataNS
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_KnownFolderManager
nullptr
CLSCTX_INPROC_SERVER
IID_IKnownFolderManager
getter_AddRefs
(
fManager
)
)
;
if
(
FAILED
(
hr
)
)
{
return
NS_ERROR_ABORT
;
}
fManager
-
>
GetFolder
(
FOLDERID_RoamingAppData
roamingAppData
.
StartAssignment
(
)
)
;
hr
=
roamingAppData
-
>
GetPath
(
0
&
roamingAppDataW
)
;
if
(
FAILED
(
hr
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
roamingAppDataNS
.
Assign
(
roamingAppDataW
)
;
CoTaskMemFree
(
roamingAppDataW
)
;
nsString
startupFolder
=
roamingAppDataNS
+
u
"
\
\
Microsoft
\
\
Windows
\
\
Start
Menu
\
\
Programs
\
\
Startup
"
_ns
;
nsString
startupFolderWildcard
=
startupFolder
+
u
"
\
\
*
.
lnk
"
_ns
;
RefPtr
<
nsIFile
>
binFile
;
nsString
binPath
;
nsresult
rv
=
XRE_GetBinaryPath
(
binFile
.
StartAssignment
(
)
)
;
if
(
FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
binFile
-
>
GetPath
(
binPath
)
;
if
(
FAILED
(
rv
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
WIN32_FIND_DATAW
ffd
;
HANDLE
fileHandle
=
INVALID_HANDLE_VALUE
;
fileHandle
=
FindFirstFileW
(
startupFolderWildcard
.
get
(
)
&
ffd
)
;
if
(
fileHandle
=
=
INVALID_HANDLE_VALUE
)
{
return
NS_OK
;
}
do
{
nsString
fileName
(
ffd
.
cFileName
)
;
RefPtr
<
IShellLinkW
>
link
;
RefPtr
<
IPersistFile
>
ppf
;
nsString
target
;
target
.
SetLength
(
MAX_PATH
)
;
CoCreateInstance
(
CLSID_ShellLink
nullptr
CLSCTX_INPROC_SERVER
IID_IShellLinkW
getter_AddRefs
(
link
)
)
;
hr
=
link
-
>
QueryInterface
(
IID_IPersistFile
getter_AddRefs
(
ppf
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
nsString
filePath
=
startupFolder
+
u
"
\
\
"
_ns
+
fileName
;
hr
=
ppf
-
>
Load
(
filePath
.
get
(
)
STGM_READ
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
hr
=
link
-
>
GetPath
(
target
.
get
(
)
MAX_PATH
nullptr
0
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
if
(
_wcsnicmp
(
target
.
get
(
)
binPath
.
get
(
)
binPath
.
Length
(
)
)
=
=
0
)
{
aShortcutPaths
.
AppendElement
(
filePath
)
;
}
}
while
(
FindNextFile
(
fileHandle
&
ffd
)
!
=
0
)
;
FindClose
(
fileHandle
)
;
return
NS_OK
;
}
static
nsresult
GetMatchingShortcut
(
int
aCSIDL
const
nsAString
&
aAUMID
const
wchar_t
aExePath
[
MAXPATHLEN
]
const
nsAString
&
aShortcutSubstring
nsAutoString
&
aShortcutPath
)
{
nsresult
result
=
NS_ERROR_FAILURE
;
wchar_t
folderPath
[
MAX_PATH
]
=
{
}
;
HRESULT
hr
=
SHGetFolderPathW
(
nullptr
aCSIDL
nullptr
SHGFP_TYPE_CURRENT
folderPath
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
wcscat_s
(
folderPath
MAX_PATH
L
"
\
\
"
)
!
=
0
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
pattern
(
folderPath
)
;
pattern
.
AppendLiteral
(
"
*
.
lnk
"
)
;
WIN32_FIND_DATAW
findData
=
{
}
;
HANDLE
hFindFile
=
FindFirstFileW
(
pattern
.
get
(
)
&
findData
)
;
if
(
hFindFile
=
=
INVALID_HANDLE_VALUE
)
{
Unused
<
<
NS_WARN_IF
(
GetLastError
(
)
!
=
ERROR_FILE_NOT_FOUND
)
;
return
NS_ERROR_FILE_NOT_FOUND
;
}
do
{
if
(
StrStrIW
(
findData
.
cFileName
aShortcutSubstring
.
Data
(
)
)
=
=
NULL
)
{
continue
;
}
nsAutoString
path
(
folderPath
)
;
path
.
Append
(
findData
.
cFileName
)
;
RefPtr
<
IShellLinkW
>
link
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_ShellLink
nullptr
CLSCTX_INPROC_SERVER
IID_IShellLinkW
getter_AddRefs
(
link
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
RefPtr
<
IPersistFile
>
persist
;
hr
=
link
-
>
QueryInterface
(
IID_IPersistFile
getter_AddRefs
(
persist
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
hr
=
persist
-
>
Load
(
path
.
get
(
)
STGM_READ
)
;
if
(
FAILED
(
hr
)
)
{
if
(
NS_WARN_IF
(
hr
!
=
HRESULT_FROM_WIN32
(
ERROR_FILE_NOT_FOUND
)
)
)
{
}
else
{
if
(
result
!
=
NS_ERROR_FILE_ALREADY_EXISTS
)
{
result
=
NS_ERROR_FILE_NOT_FOUND
;
}
}
continue
;
}
result
=
NS_ERROR_FILE_ALREADY_EXISTS
;
RefPtr
<
IPropertyStore
>
propStore
;
hr
=
link
-
>
QueryInterface
(
IID_IPropertyStore
getter_AddRefs
(
propStore
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
PROPVARIANT
pv
;
hr
=
propStore
-
>
GetValue
(
PKEY_AppUserModel_ID
&
pv
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
wchar_t
storedAUMID
[
MAX_PATH
]
;
hr
=
PropVariantToString
(
pv
storedAUMID
MAX_PATH
)
;
PropVariantClear
(
&
pv
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
if
(
!
aAUMID
.
Equals
(
storedAUMID
)
)
{
continue
;
}
static_assert
(
MAXPATHLEN
=
=
MAX_PATH
)
;
wchar_t
storedExePath
[
MAX_PATH
]
=
{
}
;
hr
=
link
-
>
GetPath
(
storedExePath
std
:
:
size
(
storedExePath
)
nullptr
0
)
;
if
(
FAILED
(
hr
)
|
|
hr
=
=
S_FALSE
)
{
continue
;
}
if
(
wcsnicmp
(
storedExePath
aExePath
MAXPATHLEN
)
=
=
0
)
{
aShortcutPath
.
Assign
(
path
)
;
result
=
NS_OK
;
break
;
}
}
while
(
FindNextFileW
(
hFindFile
&
findData
)
)
;
FindClose
(
hFindFile
)
;
return
result
;
}
static
nsresult
FindPinnableShortcut
(
const
nsAString
&
aAppUserModelId
const
nsAString
&
aShortcutSubstring
const
bool
aPrivateBrowsing
nsAutoString
&
aShortcutPath
)
{
wchar_t
exePath
[
MAXPATHLEN
]
=
{
}
;
if
(
NS_WARN_IF
(
NS_FAILED
(
BinaryPath
:
:
GetLong
(
exePath
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aPrivateBrowsing
)
{
if
(
!
PathRemoveFileSpecW
(
exePath
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
PathAppendW
(
exePath
L
"
private_browsing
.
exe
"
)
)
{
return
NS_ERROR_FAILURE
;
}
}
int
shortcutCSIDLs
[
]
=
{
CSIDL_COMMON_PROGRAMS
CSIDL_PROGRAMS
}
;
for
(
int
shortcutCSIDL
:
shortcutCSIDLs
)
{
nsresult
rv
=
GetMatchingShortcut
(
shortcutCSIDL
aAppUserModelId
exePath
aShortcutSubstring
aShortcutPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_OK
;
}
}
return
NS_ERROR_FILE_NOT_FOUND
;
}
static
bool
HasPinnableShortcutImpl
(
const
nsAString
&
aAppUserModelId
const
bool
aPrivateBrowsing
const
nsAutoString
&
aShortcutSubstring
)
{
nsAutoString
shortcutPath
;
nsresult
rv
=
FindPinnableShortcut
(
aAppUserModelId
aShortcutSubstring
aPrivateBrowsing
shortcutPath
)
;
if
(
SUCCEEDED
(
rv
)
)
{
return
true
;
}
return
false
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
HasPinnableShortcut
(
const
nsAString
&
aAppUserModelId
const
bool
aPrivateBrowsing
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
HasPinnableShortcut
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
HasPinnableShortcut
"
[
aAppUserModelId
=
nsString
{
aAppUserModelId
}
aPrivateBrowsing
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
bool
rv
=
false
;
HRESULT
hr
=
CoInitialize
(
nullptr
)
;
if
(
SUCCEEDED
(
hr
)
)
{
nsAutoString
shortcutSubstring
;
shortcutSubstring
.
AssignLiteral
(
MOZ_APP_DISPLAYNAME
)
;
rv
=
HasPinnableShortcutImpl
(
aAppUserModelId
aPrivateBrowsing
shortcutSubstring
)
;
CoUninitialize
(
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
HasPinnableShortcut
callback
"
[
rv
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
dom
:
:
Promise
*
promise
=
promiseHolder
.
get
(
)
-
>
get
(
)
;
promise
-
>
MaybeResolve
(
rv
)
;
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
static
bool
IsCurrentAppPinnedToTaskbarSync
(
const
nsAString
&
aumid
)
{
if
(
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
auto
pinWithWin11TaskbarAPIResults
=
IsCurrentAppPinnedToTaskbarWin11
(
false
)
;
switch
(
pinWithWin11TaskbarAPIResults
.
result
)
{
case
Win11PinToTaskBarResultStatus
:
:
NotPinned
:
return
false
;
break
;
case
Win11PinToTaskBarResultStatus
:
:
AlreadyPinned
:
return
true
;
break
;
default
:
break
;
}
}
wchar_t
exePath
[
MAXPATHLEN
]
=
{
}
;
wchar_t
pbExePath
[
MAXPATHLEN
]
=
{
}
;
if
(
NS_WARN_IF
(
NS_FAILED
(
BinaryPath
:
:
GetLong
(
exePath
)
)
)
)
{
return
false
;
}
wcscpy_s
(
pbExePath
MAXPATHLEN
exePath
)
;
if
(
!
PathRemoveFileSpecW
(
pbExePath
)
)
{
return
false
;
}
if
(
!
PathAppendW
(
pbExePath
L
"
private_browsing
.
exe
"
)
)
{
return
false
;
}
wchar_t
folderChars
[
MAX_PATH
]
=
{
}
;
HRESULT
hr
=
SHGetFolderPathW
(
nullptr
CSIDL_APPDATA
nullptr
SHGFP_TYPE_CURRENT
folderChars
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
return
false
;
}
nsAutoString
folder
;
folder
.
Assign
(
folderChars
)
;
if
(
NS_WARN_IF
(
folder
.
IsEmpty
(
)
)
)
{
return
false
;
}
if
(
folder
[
folder
.
Length
(
)
-
1
]
!
=
'
\
\
'
)
{
folder
.
AppendLiteral
(
"
\
\
"
)
;
}
folder
.
AppendLiteral
(
"
Microsoft
\
\
Internet
Explorer
\
\
Quick
Launch
\
\
User
Pinned
\
\
TaskBar
"
)
;
nsAutoString
pattern
;
pattern
.
Assign
(
folder
)
;
pattern
.
AppendLiteral
(
"
\
\
*
.
lnk
"
)
;
WIN32_FIND_DATAW
findData
=
{
}
;
HANDLE
hFindFile
=
FindFirstFileW
(
pattern
.
get
(
)
&
findData
)
;
if
(
hFindFile
=
=
INVALID_HANDLE_VALUE
)
{
Unused
<
<
NS_WARN_IF
(
GetLastError
(
)
!
=
ERROR_FILE_NOT_FOUND
)
;
return
false
;
}
bool
isPinned
=
false
;
do
{
nsAutoString
fileName
;
fileName
.
Assign
(
folder
)
;
fileName
.
AppendLiteral
(
"
\
\
"
)
;
fileName
.
Append
(
findData
.
cFileName
)
;
RefPtr
<
IShellLinkW
>
link
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_ShellLink
nullptr
CLSCTX_INPROC_SERVER
IID_IShellLinkW
getter_AddRefs
(
link
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
RefPtr
<
IPersistFile
>
persist
;
hr
=
link
-
>
QueryInterface
(
IID_IPersistFile
getter_AddRefs
(
persist
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
hr
=
persist
-
>
Load
(
fileName
.
get
(
)
STGM_READ
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
static_assert
(
MAXPATHLEN
=
=
MAX_PATH
)
;
wchar_t
storedExePath
[
MAX_PATH
]
=
{
}
;
hr
=
link
-
>
GetPath
(
storedExePath
std
:
:
size
(
storedExePath
)
nullptr
0
)
;
if
(
FAILED
(
hr
)
|
|
hr
=
=
S_FALSE
)
{
continue
;
}
if
(
wcsnicmp
(
storedExePath
exePath
MAXPATHLEN
)
=
=
0
|
|
wcsnicmp
(
storedExePath
pbExePath
MAXPATHLEN
)
=
=
0
)
{
RefPtr
<
IPropertyStore
>
propStore
;
hr
=
link
-
>
QueryInterface
(
IID_IPropertyStore
getter_AddRefs
(
propStore
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
PROPVARIANT
pv
;
hr
=
propStore
-
>
GetValue
(
PKEY_AppUserModel_ID
&
pv
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
wchar_t
storedAUMID
[
MAX_PATH
]
;
hr
=
PropVariantToString
(
pv
storedAUMID
MAX_PATH
)
;
PropVariantClear
(
&
pv
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
if
(
aumid
.
Equals
(
storedAUMID
)
)
{
isPinned
=
true
;
break
;
}
}
}
while
(
FindNextFileW
(
hFindFile
&
findData
)
)
;
FindClose
(
hFindFile
)
;
return
isPinned
;
}
static
nsresult
ManageShortcutTaskbarPins
(
bool
aCheckOnly
bool
aPinType
const
nsAString
&
aShortcutPath
)
{
enum
PINNEDLISTMODIFYCALLER
{
PLMC_INT_MAX
=
INT_MAX
}
;
static
constexpr
GUID
CLSID_TaskbandPin
=
{
0x90aa3a4e
0x1cba
0x4233
{
0xb8
0xbb
0x53
0x57
0x73
0xd4
0x84
0x49
}
}
;
static
constexpr
GUID
IID_IPinnedList3
=
{
0x0dd79ae2
0xd156
0x45d4
{
0x9e
0xeb
0x3b
0x54
0x97
0x69
0xe9
0x40
}
}
;
struct
IPinnedList3Vtbl
;
struct
IPinnedList3
{
IPinnedList3Vtbl
*
vtbl
;
}
;
typedef
ULONG
STDMETHODCALLTYPE
ReleaseFunc
(
IPinnedList3
*
that
)
;
typedef
HRESULT
STDMETHODCALLTYPE
ModifyFunc
(
IPinnedList3
*
that
PCIDLIST_ABSOLUTE
unpin
PCIDLIST_ABSOLUTE
pin
PINNEDLISTMODIFYCALLER
caller
)
;
struct
IPinnedList3Vtbl
{
void
*
QueryInterface
;
void
*
AddRef
;
ReleaseFunc
*
Release
;
void
*
Other
[
13
]
;
ModifyFunc
*
Modify
;
}
;
struct
ILFreeDeleter
{
void
operator
(
)
(
LPITEMIDLIST
aPtr
)
{
if
(
aPtr
)
{
ILFree
(
aPtr
)
;
}
}
}
;
mozilla
:
:
UniquePtr
<
__unaligned
ITEMIDLIST
ILFreeDeleter
>
path
(
ILCreateFromPathW
(
nsString
(
aShortcutPath
)
.
get
(
)
)
)
;
if
(
NS_WARN_IF
(
!
path
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
IPinnedList3
*
pinnedList
=
nullptr
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_TaskbandPin
NULL
CLSCTX_INPROC_SERVER
IID_IPinnedList3
(
void
*
*
)
&
pinnedList
)
;
if
(
FAILED
(
hr
)
|
|
!
pinnedList
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
aCheckOnly
)
{
hr
=
pinnedList
-
>
vtbl
-
>
Modify
(
pinnedList
aPinType
?
NULL
:
path
.
get
(
)
aPinType
?
path
.
get
(
)
:
NULL
PLMC_INT_MAX
)
;
}
pinnedList
-
>
vtbl
-
>
Release
(
pinnedList
)
;
if
(
FAILED
(
hr
)
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
return
NS_OK
;
}
static
nsresult
PinShortcutToTaskbarImpl
(
bool
aCheckOnly
const
nsAString
&
aAppUserModelId
const
nsAString
&
aShortcutPath
)
{
if
(
!
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
&
&
!
aCheckOnly
&
&
!
PollAppsFolderForShortcut
(
aAppUserModelId
TimeDuration
:
:
FromSeconds
(
15
)
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
auto
pinWithWin11TaskbarAPIResults
=
PinCurrentAppToTaskbarWin11
(
aCheckOnly
aAppUserModelId
)
;
switch
(
pinWithWin11TaskbarAPIResults
.
result
)
{
case
Win11PinToTaskBarResultStatus
:
:
NotSupported
:
break
;
case
Win11PinToTaskBarResultStatus
:
:
Success
:
case
Win11PinToTaskBarResultStatus
:
:
AlreadyPinned
:
return
NS_OK
;
case
Win11PinToTaskBarResultStatus
:
:
NotPinned
:
case
Win11PinToTaskBarResultStatus
:
:
NotCurrentlyAllowed
:
case
Win11PinToTaskBarResultStatus
:
:
Failed
:
break
;
}
return
PinCurrentAppToTaskbarWin10
(
aCheckOnly
aAppUserModelId
aShortcutPath
)
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
PinShortcutToTaskbar
(
const
nsAString
&
aAppUserModelId
const
nsAString
&
aShortcutPath
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
NS_ENSURE_ARG_POINTER
(
aPromise
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
!
IsWin10Sep2018UpdateOrLater
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
pinShortcutToTaskbar
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
pinShortcutToTaskbar
"
[
aumid
=
nsString
{
aAppUserModelId
}
shortcutPath
=
nsString
(
aShortcutPath
)
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
nsresult
rv
=
NS_ERROR_FAILURE
;
HRESULT
hr
=
CoInitialize
(
nullptr
)
;
if
(
SUCCEEDED
(
hr
)
)
{
rv
=
PinShortcutToTaskbarImpl
(
false
aumid
shortcutPath
)
;
CoUninitialize
(
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
pinShortcutToTaskbar
callback
"
[
rv
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
dom
:
:
Promise
*
promise
=
promiseHolder
.
get
(
)
-
>
get
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
else
{
promise
-
>
MaybeReject
(
rv
)
;
}
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
UnpinShortcutFromTaskbar
(
const
nsAString
&
aShortcutPath
)
{
const
bool
pinType
=
false
;
const
bool
runInTestMode
=
false
;
return
ManageShortcutTaskbarPins
(
runInTestMode
pinType
aShortcutPath
)
;
}
static
void
ValidateFilename
(
nsAString
&
aFilename
)
{
nsCOMPtr
<
nsIMIMEService
>
mimeService
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mimeService
)
)
{
aFilename
.
Truncate
(
)
;
return
;
}
uint32_t
flags
=
nsIMIMEService
:
:
VALIDATE_SANITIZE_ONLY
|
nsIMIMEService
:
:
VALIDATE_DONT_COLLAPSE_WHITESPACE
;
nsAutoString
outFilename
;
mimeService
-
>
ValidateFileNameForSaving
(
aFilename
EmptyCString
(
)
flags
outFilename
)
;
aFilename
=
outFilename
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
GetTaskbarTabShortcutPath
(
const
nsAString
&
aShortcutName
nsAString
&
aRetPath
)
{
nsAutoString
sanitizedShortcutName
(
aShortcutName
)
;
ValidateFilename
(
sanitizedShortcutName
)
;
if
(
sanitizedShortcutName
!
=
aShortcutName
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
RefPtr
<
IKnownFolderManager
>
fManager
;
RefPtr
<
IKnownFolder
>
progFolder
;
LPWSTR
progFolderW
;
nsString
progFolderNS
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_KnownFolderManager
nullptr
CLSCTX_INPROC_SERVER
IID_IKnownFolderManager
getter_AddRefs
(
fManager
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
return
NS_ERROR_ABORT
;
}
fManager
-
>
GetFolder
(
FOLDERID_Programs
progFolder
.
StartAssignment
(
)
)
;
hr
=
progFolder
-
>
GetPath
(
0
&
progFolderW
)
;
if
(
FAILED
(
hr
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
progFolderNS
.
Assign
(
progFolderW
)
;
nsTArray
<
nsCString
>
resIds
=
{
"
branding
/
brand
.
ftl
"
_ns
"
preview
/
taskbartabs
.
ftl
"
_ns
}
;
RefPtr
<
Localization
>
l10n
=
Localization
:
:
Create
(
resIds
true
)
;
nsAutoCString
dirname
;
IgnoredErrorResult
rv
;
l10n
-
>
FormatValueSync
(
"
taskbar
-
tab
-
shortcut
-
folder
"
_ns
{
}
dirname
rv
)
;
aRetPath
=
progFolderNS
+
u
"
\
\
"
_ns
+
NS_ConvertUTF8toUTF16
(
dirname
)
+
u
"
\
\
"
_ns
+
aShortcutName
+
u
"
.
lnk
"
_ns
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
GetTaskbarTabPins
(
nsTArray
<
nsString
>
&
aShortcutPaths
)
{
#
ifdef
__MINGW32__
return
NS_ERROR_NOT_IMPLEMENTED
;
#
else
aShortcutPaths
.
Clear
(
)
;
RefPtr
<
IKnownFolderManager
>
fManager
;
RefPtr
<
IKnownFolder
>
roamingAppData
;
LPWSTR
roamingAppDataW
;
nsString
roamingAppDataNS
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_KnownFolderManager
nullptr
CLSCTX_INPROC_SERVER
IID_IKnownFolderManager
getter_AddRefs
(
fManager
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
return
NS_ERROR_ABORT
;
}
fManager
-
>
GetFolder
(
FOLDERID_RoamingAppData
roamingAppData
.
StartAssignment
(
)
)
;
hr
=
roamingAppData
-
>
GetPath
(
0
&
roamingAppDataW
)
;
if
(
FAILED
(
hr
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
roamingAppDataNS
.
Assign
(
roamingAppDataW
)
;
CoTaskMemFree
(
roamingAppDataW
)
;
nsString
taskbarFolder
=
roamingAppDataNS
+
u
"
\
\
Microsoft
\
\
Windows
\
\
Start
Menu
\
\
Programs
"
_ns
;
nsString
taskbarFolderWildcard
=
taskbarFolder
+
u
"
\
\
*
.
lnk
"
_ns
;
RefPtr
<
nsIFile
>
binFile
;
nsString
binPath
;
nsresult
rv
=
XRE_GetBinaryPath
(
binFile
.
StartAssignment
(
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
binFile
-
>
GetPath
(
binPath
)
;
if
(
NS_WARN_IF
(
FAILED
(
rv
)
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
WIN32_FIND_DATAW
ffd
;
HANDLE
fileHandle
=
INVALID_HANDLE_VALUE
;
fileHandle
=
FindFirstFileW
(
taskbarFolderWildcard
.
get
(
)
&
ffd
)
;
if
(
fileHandle
=
=
INVALID_HANDLE_VALUE
)
{
return
NS_OK
;
}
do
{
nsString
fileName
(
ffd
.
cFileName
)
;
RefPtr
<
IShellLinkW
>
link
;
RefPtr
<
IPropertyStore
>
pps
;
nsString
target
;
target
.
SetLength
(
MAX_PATH
)
;
hr
=
CoCreateInstance
(
CLSID_ShellLink
nullptr
CLSCTX_INPROC_SERVER
IID_IShellLinkW
getter_AddRefs
(
link
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
nsString
filePath
=
taskbarFolder
+
u
"
\
\
"
_ns
+
fileName
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
hr
=
SHGetPropertyStoreFromParsingName
(
filePath
.
get
(
)
nullptr
GPS_READWRITE
IID_IPropertyStore
getter_AddRefs
(
pps
)
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
|
|
pps
=
=
nullptr
)
{
continue
;
}
PROPVARIANT
propVar
;
PropVariantInit
(
&
propVar
)
;
auto
cleanupPropVariant
=
MakeScopeExit
(
[
&
]
{
PropVariantClear
(
&
propVar
)
;
}
)
;
hr
=
pps
-
>
GetValue
(
PKEY_Link_Arguments
&
propVar
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
if
(
!
(
propVar
.
vt
=
=
VT_LPWSTR
&
&
propVar
.
pwszVal
!
=
nullptr
&
&
wcsstr
(
propVar
.
pwszVal
L
"
-
taskbar
-
tab
"
)
!
=
nullptr
)
)
{
continue
;
}
hr
=
link
-
>
GetPath
(
target
.
get
(
)
MAX_PATH
nullptr
0
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
if
(
_wcsnicmp
(
target
.
get
(
)
binPath
.
get
(
)
binPath
.
Length
(
)
)
=
=
0
)
{
aShortcutPaths
.
AppendElement
(
filePath
)
;
}
}
while
(
FindNextFile
(
fileHandle
&
ffd
)
!
=
0
)
;
FindClose
(
fileHandle
)
;
return
NS_OK
;
#
endif
}
static
nsresult
PinCurrentAppToTaskbarWin10
(
bool
aCheckOnly
const
nsAString
&
aAppUserModelId
const
nsAString
&
aShortcutPath
)
{
if
(
!
aCheckOnly
)
{
aCheckOnly
=
IsCurrentAppPinnedToTaskbarSync
(
aAppUserModelId
)
;
}
const
bool
pinType
=
true
;
return
ManageShortcutTaskbarPins
(
aCheckOnly
pinType
aShortcutPath
)
;
}
static
bool
PollAppsFolderForShortcut
(
const
nsAString
&
aAppUserModelId
const
TimeDuration
aTimeout
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
NS_IsMainThread
(
)
"
PollAppsFolderForShortcut
blocks
and
should
be
called
"
"
off
main
thread
only
"
)
;
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
ComPtr
<
IShellItem
>
appsFolder
;
HRESULT
hr
=
SHGetKnownFolderItem
(
FOLDERID_AppsFolder
KF_FLAG_DEFAULT
nullptr
IID_PPV_ARGS
(
&
appsFolder
)
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
do
{
ComPtr
<
IEnumShellItems
>
shortcutIter
;
hr
=
appsFolder
-
>
BindToHandler
(
nullptr
BHID_EnumItems
IID_PPV_ARGS
(
&
shortcutIter
)
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
ComPtr
<
IShellItem
>
shortcut
;
while
(
shortcutIter
-
>
Next
(
1
&
shortcut
nullptr
)
=
=
S_OK
)
{
ComPtr
<
IShellItem2
>
shortcut2
;
hr
=
shortcut
.
As
(
&
shortcut2
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
mozilla
:
:
UniquePtr
<
WCHAR
mozilla
:
:
CoTaskMemFreeDeleter
>
shortcutAumid
;
hr
=
shortcut2
-
>
GetString
(
PKEY_AppUserModel_ID
getter_Transfers
(
shortcutAumid
)
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
if
(
aAppUserModelId
=
=
nsDependentString
(
shortcutAumid
.
get
(
)
)
)
{
return
true
;
}
}
:
:
Sleep
(
250
)
;
}
while
(
(
TimeStamp
:
:
Now
(
)
-
start
)
<
aTimeout
)
;
return
false
;
}
static
nsresult
PinCurrentAppToTaskbarImpl
(
bool
aCheckOnly
bool
aPrivateBrowsing
const
nsAString
&
aAppUserModelId
const
nsAString
&
aShortcutName
const
nsAString
&
aShortcutSubstring
nsIFile
*
aGreDir
const
ShortcutLocations
&
location
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
NS_IsMainThread
(
)
"
PinCurrentAppToTaskbarImpl
should
be
called
off
main
thread
only
"
)
;
nsAutoString
shortcutPath
;
nsresult
rv
=
FindPinnableShortcut
(
aAppUserModelId
aShortcutSubstring
aPrivateBrowsing
shortcutPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
shortcutPath
.
Truncate
(
)
;
}
if
(
shortcutPath
.
IsEmpty
(
)
)
{
if
(
aCheckOnly
)
{
return
NS_OK
;
}
nsAutoString
linkName
(
aShortcutName
)
;
nsCOMPtr
<
nsIFile
>
exeFile
(
aGreDir
)
;
if
(
aPrivateBrowsing
)
{
nsAutoString
pbExeStr
(
PRIVATE_BROWSING_BINARY
)
;
nsresult
rv
=
exeFile
-
>
Append
(
pbExeStr
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
wchar_t
exePath
[
MAXPATHLEN
]
=
{
}
;
if
(
NS_WARN_IF
(
NS_FAILED
(
BinaryPath
:
:
GetLong
(
exePath
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
exeStr
(
exePath
)
;
nsresult
rv
=
NS_NewLocalFile
(
exeStr
getter_AddRefs
(
exeFile
)
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
}
nsTArray
<
nsString
>
arguments
;
rv
=
CreateShortcutImpl
(
exeFile
arguments
aShortcutName
exeFile
IDI_APPICON
-
1
aAppUserModelId
location
linkName
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
}
return
PinShortcutToTaskbarImpl
(
aCheckOnly
aAppUserModelId
shortcutPath
)
;
}
static
nsresult
PinCurrentAppToTaskbarAsyncImpl
(
bool
aCheckOnly
bool
aPrivateBrowsing
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
!
IsWin10Sep2018UpdateOrLater
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
nsAutoString
aumid
;
if
(
NS_WARN_IF
(
!
mozilla
:
:
widget
:
:
WinTaskbar
:
:
GetAppUserModelID
(
aumid
aPrivateBrowsing
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
shortcutName
;
if
(
aPrivateBrowsing
)
{
nsTArray
<
nsCString
>
resIds
=
{
"
branding
/
brand
.
ftl
"
_ns
"
browser
/
browser
.
ftl
"
_ns
}
;
RefPtr
<
Localization
>
l10n
=
Localization
:
:
Create
(
resIds
true
)
;
nsAutoCString
pbStr
;
IgnoredErrorResult
rv
;
l10n
-
>
FormatValueSync
(
"
private
-
browsing
-
shortcut
-
text
-
2
"
_ns
{
}
pbStr
rv
)
;
shortcutName
.
Append
(
NS_ConvertUTF8toUTF16
(
pbStr
)
)
;
shortcutName
.
AppendLiteral
(
"
.
lnk
"
)
;
}
else
{
shortcutName
.
AppendLiteral
(
MOZ_APP_DISPLAYNAME
"
.
lnk
"
)
;
}
nsCOMPtr
<
nsIFile
>
greDir
;
nsresult
nsrv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
greDir
)
)
;
NS_ENSURE_SUCCESS
(
nsrv
nsrv
)
;
ShortcutLocations
location
=
MOZ_TRY
(
GetShortcutPaths
(
nsString
(
L
"
Programs
"
)
shortcutName
)
)
;
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
CheckPinCurrentAppToTaskbarAsync
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
CheckPinCurrentAppToTaskbarAsync
"
[
aCheckOnly
aPrivateBrowsing
shortcutName
aumid
=
nsString
{
aumid
}
greDir
location
=
std
:
:
move
(
location
)
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
nsresult
rv
=
NS_ERROR_FAILURE
;
HRESULT
hr
=
CoInitialize
(
nullptr
)
;
if
(
SUCCEEDED
(
hr
)
)
{
nsAutoString
shortcutSubstring
;
shortcutSubstring
.
AssignLiteral
(
MOZ_APP_DISPLAYNAME
)
;
rv
=
PinCurrentAppToTaskbarImpl
(
aCheckOnly
aPrivateBrowsing
aumid
shortcutName
shortcutSubstring
greDir
.
get
(
)
location
)
;
CoUninitialize
(
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
CheckPinCurrentAppToTaskbarAsync
callback
"
[
rv
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
dom
:
:
Promise
*
promise
=
promiseHolder
.
get
(
)
-
>
get
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
else
{
promise
-
>
MaybeReject
(
rv
)
;
}
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
PinCurrentAppToTaskbarAsync
(
bool
aPrivateBrowsing
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
return
PinCurrentAppToTaskbarAsyncImpl
(
false
aPrivateBrowsing
aCx
aPromise
)
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
CheckPinCurrentAppToTaskbarAsync
(
bool
aPrivateBrowsing
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
return
PinCurrentAppToTaskbarAsyncImpl
(
true
aPrivateBrowsing
aCx
aPromise
)
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
IsCurrentAppPinnedToTaskbarAsync
(
const
nsAString
&
aumid
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
IsCurrentAppPinnedToTaskbarAsync
promise
"
promise
)
;
nsAutoString
capturedAumid
(
aumid
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
IsCurrentAppPinnedToTaskbarAsync
"
[
capturedAumid
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
bool
isPinned
=
false
;
HRESULT
hr
=
CoInitialize
(
nullptr
)
;
if
(
SUCCEEDED
(
hr
)
)
{
isPinned
=
IsCurrentAppPinnedToTaskbarSync
(
capturedAumid
)
;
CoUninitialize
(
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
IsCurrentAppPinnedToTaskbarAsync
callback
"
[
isPinned
promiseHolder
=
std
:
:
move
(
promiseHolder
)
]
{
promiseHolder
.
get
(
)
-
>
get
(
)
-
>
MaybeResolve
(
isPinned
)
;
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
#
ifndef
__MINGW32__
#
define
RESOLVE_AND_RETURN
(
HOLDER
RESOLVE
RETURN
)
\
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
\
__func__
[
resolveVal
=
(
RESOLVE
)
promiseHolder
=
HOLDER
]
{
\
promiseHolder
.
get
(
)
-
>
get
(
)
-
>
MaybeResolve
(
resolveVal
)
;
\
}
)
)
;
\
return
RETURN
#
define
REJECT_AND_RETURN
(
HOLDER
REJECT
RETURN
)
\
NS_DispatchToMainThread
(
\
NS_NewRunnableFunction
(
__func__
[
promiseHolder
=
HOLDER
]
{
\
promiseHolder
.
get
(
)
-
>
get
(
)
-
>
MaybeReject
(
REJECT
)
;
\
}
)
)
;
\
return
RETURN
static
void
EnableLaunchOnLoginMSIXAsyncImpl
(
const
nsString
&
capturedTaskId
const
RefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
promiseHolder
)
{
ComPtr
<
IStartupTaskStatics
>
startupTaskStatics
;
HRESULT
hr
=
GetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_ApplicationModel_StartupTask
)
.
Get
(
)
&
startupTaskStatics
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
ComPtr
<
IAsyncOperation
<
StartupTask
*
>
>
getTaskOperation
=
nullptr
;
hr
=
startupTaskStatics
-
>
GetAsync
(
HStringReference
(
capturedTaskId
.
get
(
)
)
.
Get
(
)
&
getTaskOperation
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
auto
getTaskCallback
=
Callback
<
IAsyncOperationCompletedHandler
<
StartupTask
*
>
>
(
[
promiseHolder
]
(
IAsyncOperation
<
StartupTask
*
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
if
(
status
!
=
AsyncStatus
:
:
Completed
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IStartupTask
>
startupTask
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
startupTask
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IAsyncOperation
<
StartupTaskState
>
>
enableOperation
;
hr
=
startupTask
-
>
RequestEnableAsync
(
&
enableOperation
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
auto
enableHandler
=
Callback
<
IAsyncOperationCompletedHandler
<
StartupTaskState
>
>
(
[
promiseHolder
]
(
IAsyncOperation
<
StartupTaskState
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
StartupTaskState
resultState
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
resultState
)
;
if
(
SUCCEEDED
(
hr
)
&
&
status
=
=
AsyncStatus
:
:
Completed
)
{
RESOLVE_AND_RETURN
(
promiseHolder
true
S_OK
)
;
}
RESOLVE_AND_RETURN
(
promiseHolder
false
S_OK
)
;
}
)
;
hr
=
enableOperation
-
>
put_Completed
(
enableHandler
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
hr
)
;
}
return
hr
;
}
)
;
hr
=
getTaskOperation
-
>
put_Completed
(
getTaskCallback
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
}
static
void
DisableLaunchOnLoginMSIXAsyncImpl
(
const
nsString
&
capturedTaskId
const
RefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
promiseHolder
)
{
ComPtr
<
IStartupTaskStatics
>
startupTaskStatics
;
HRESULT
hr
=
GetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_ApplicationModel_StartupTask
)
.
Get
(
)
&
startupTaskStatics
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
ComPtr
<
IAsyncOperation
<
StartupTask
*
>
>
getTaskOperation
=
nullptr
;
hr
=
startupTaskStatics
-
>
GetAsync
(
HStringReference
(
capturedTaskId
.
get
(
)
)
.
Get
(
)
&
getTaskOperation
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
auto
getTaskCallback
=
Callback
<
IAsyncOperationCompletedHandler
<
StartupTask
*
>
>
(
[
promiseHolder
]
(
IAsyncOperation
<
StartupTask
*
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
if
(
status
!
=
AsyncStatus
:
:
Completed
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IStartupTask
>
startupTask
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
startupTask
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
hr
=
startupTask
-
>
Disable
(
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
RESOLVE_AND_RETURN
(
promiseHolder
true
S_OK
)
;
}
)
;
hr
=
getTaskOperation
-
>
put_Completed
(
getTaskCallback
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
}
static
void
GetLaunchOnLoginEnabledMSIXAsyncImpl
(
const
nsString
&
capturedTaskId
const
RefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
promiseHolder
)
{
ComPtr
<
IStartupTaskStatics
>
startupTaskStatics
;
HRESULT
hr
=
GetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_ApplicationModel_StartupTask
)
.
Get
(
)
&
startupTaskStatics
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
ComPtr
<
IAsyncOperation
<
StartupTask
*
>
>
getTaskOperation
=
nullptr
;
hr
=
startupTaskStatics
-
>
GetAsync
(
HStringReference
(
capturedTaskId
.
get
(
)
)
.
Get
(
)
&
getTaskOperation
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
auto
getTaskCallback
=
Callback
<
IAsyncOperationCompletedHandler
<
StartupTask
*
>
>
(
[
promiseHolder
]
(
IAsyncOperation
<
StartupTask
*
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
if
(
status
!
=
AsyncStatus
:
:
Completed
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IStartupTask
>
startupTask
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
startupTask
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
StartupTaskState
state
;
hr
=
startupTask
-
>
get_State
(
&
state
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
switch
(
state
)
{
case
StartupTaskState_EnabledByPolicy
:
RESOLVE_AND_RETURN
(
promiseHolder
nsIWindowsShellService
:
:
LaunchOnLoginEnabledEnumerator
:
:
LAUNCH_ON_LOGIN_ENABLED_BY_POLICY
S_OK
)
;
break
;
case
StartupTaskState_Enabled
:
RESOLVE_AND_RETURN
(
promiseHolder
nsIWindowsShellService
:
:
LaunchOnLoginEnabledEnumerator
:
:
LAUNCH_ON_LOGIN_ENABLED
S_OK
)
;
break
;
case
StartupTaskState_DisabledByUser
:
case
StartupTaskState_DisabledByPolicy
:
RESOLVE_AND_RETURN
(
promiseHolder
nsIWindowsShellService
:
:
LaunchOnLoginEnabledEnumerator
:
:
LAUNCH_ON_LOGIN_DISABLED_BY_SETTINGS
S_OK
)
;
break
;
default
:
RESOLVE_AND_RETURN
(
promiseHolder
nsIWindowsShellService
:
:
LaunchOnLoginEnabledEnumerator
:
:
LAUNCH_ON_LOGIN_DISABLED
S_OK
)
;
}
}
)
;
hr
=
getTaskOperation
-
>
put_Completed
(
getTaskCallback
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
}
NS_IMETHODIMP
nsWindowsShellService
:
:
EnableLaunchOnLoginMSIXAsync
(
const
nsAString
&
aTaskId
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
EnableLaunchOnLoginMSIXAsync
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
EnableLaunchOnLoginMSIXAsync
"
[
taskId
=
nsString
(
aTaskId
)
promiseHolder
]
{
EnableLaunchOnLoginMSIXAsyncImpl
(
taskId
promiseHolder
)
;
}
)
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
DisableLaunchOnLoginMSIXAsync
(
const
nsAString
&
aTaskId
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
DisableLaunchOnLoginMSIXAsync
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
DisableLaunchOnLoginMSIXAsync
"
[
taskId
=
nsString
(
aTaskId
)
promiseHolder
]
{
DisableLaunchOnLoginMSIXAsyncImpl
(
taskId
promiseHolder
)
;
}
)
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
GetLaunchOnLoginEnabledMSIXAsync
(
const
nsAString
&
aTaskId
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
GetLaunchOnLoginEnabledMSIXAsync
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
GetLaunchOnLoginEnabledMSIXAsync
"
[
taskId
=
nsString
(
aTaskId
)
promiseHolder
]
{
GetLaunchOnLoginEnabledMSIXAsyncImpl
(
taskId
promiseHolder
)
;
}
)
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
static
HRESULT
GetPackage3
(
ComPtr
<
IPackage3
>
&
package3
)
{
ComPtr
<
IPackageStatics
>
packageStatics
;
HRESULT
hr
=
GetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_ApplicationModel_Package
)
.
Get
(
)
&
packageStatics
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
ComPtr
<
IPackage
>
package
;
hr
=
packageStatics
-
>
get_Current
(
&
package
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
hr
=
package
.
As
(
&
package3
)
;
return
hr
;
}
static
HRESULT
GetStartScreenManager
(
ComPtr
<
IVectorView
<
AppListEntry
*
>
>
&
appListEntries
ComPtr
<
IAppListEntry
>
&
entry
ComPtr
<
IStartScreenManager
>
&
startScreenManager
)
{
unsigned
int
numEntries
=
0
;
HRESULT
hr
=
appListEntries
-
>
get_Size
(
&
numEntries
)
;
if
(
FAILED
(
hr
)
|
|
numEntries
=
=
0
)
{
return
E_FAIL
;
}
hr
=
appListEntries
-
>
GetAt
(
0
&
entry
)
;
ComPtr
<
IStartScreenManagerStatics
>
startScreenManagerStatics
;
hr
=
GetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_UI_StartScreen_StartScreenManager
)
.
Get
(
)
&
startScreenManagerStatics
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
hr
=
startScreenManagerStatics
-
>
GetDefault
(
&
startScreenManager
)
;
return
hr
;
}
static
void
PinCurrentAppToStartMenuAsyncImpl
(
bool
aCheckOnly
const
RefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
promiseHolder
)
{
ComPtr
<
IPackage3
>
package3
;
HRESULT
hr
=
GetPackage3
(
package3
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
ComPtr
<
IVectorView
<
AppListEntry
*
>
>
appListEntries
;
ComPtr
<
IAsyncOperation
<
IVectorView
<
AppListEntry
*
>
*
>
>
getAppListEntriesOperation
;
hr
=
package3
-
>
GetAppListEntriesAsync
(
&
getAppListEntriesOperation
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
auto
getAppListEntriesCallback
=
Callback
<
IAsyncOperationCompletedHandler
<
IVectorView
<
AppListEntry
*
>
*
>
>
(
[
promiseHolder
aCheckOnly
]
(
IAsyncOperation
<
IVectorView
<
AppListEntry
*
>
*
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
if
(
status
!
=
AsyncStatus
:
:
Completed
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IVectorView
<
AppListEntry
*
>
>
appListEntries
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
appListEntries
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IStartScreenManager
>
startScreenManager
;
ComPtr
<
IAppListEntry
>
entry
;
hr
=
GetStartScreenManager
(
appListEntries
entry
startScreenManager
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IAsyncOperation
<
bool
>
>
getPinnedOperation
;
hr
=
startScreenManager
-
>
ContainsAppListEntryAsync
(
entry
.
Get
(
)
&
getPinnedOperation
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
auto
getPinnedCallback
=
Callback
<
IAsyncOperationCompletedHandler
<
bool
>
>
(
[
promiseHolder
entry
startScreenManager
aCheckOnly
]
(
IAsyncOperation
<
bool
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
if
(
status
!
=
AsyncStatus
:
:
Completed
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
boolean
isAlreadyPinned
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
isAlreadyPinned
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
if
(
isAlreadyPinned
|
|
aCheckOnly
)
{
RESOLVE_AND_RETURN
(
promiseHolder
true
S_OK
)
;
}
ComPtr
<
IAsyncOperation
<
bool
>
>
pinOperation
;
startScreenManager
-
>
RequestAddAppListEntryAsync
(
entry
.
Get
(
)
&
pinOperation
)
;
auto
pinOperationCallback
=
Callback
<
IAsyncOperationCompletedHandler
<
bool
>
>
(
[
promiseHolder
]
(
IAsyncOperation
<
bool
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
if
(
status
!
=
AsyncStatus
:
:
Completed
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
;
boolean
pinSuccess
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
pinSuccess
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
RESOLVE_AND_RETURN
(
promiseHolder
pinSuccess
?
true
:
false
S_OK
)
;
}
)
;
hr
=
pinOperation
-
>
put_Completed
(
pinOperationCallback
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
hr
)
;
}
return
hr
;
}
)
;
hr
=
getPinnedOperation
-
>
put_Completed
(
getPinnedCallback
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
hr
)
;
}
return
hr
;
}
)
;
hr
=
getAppListEntriesOperation
-
>
put_Completed
(
getAppListEntriesCallback
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
}
NS_IMETHODIMP
nsWindowsShellService
:
:
PinCurrentAppToStartMenuAsync
(
bool
aCheckOnly
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
!
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
PinCurrentAppToStartMenuAsync
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
PinCurrentAppToStartMenuAsync
"
[
aCheckOnly
promiseHolder
]
{
PinCurrentAppToStartMenuAsyncImpl
(
aCheckOnly
promiseHolder
)
;
}
)
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
static
void
IsCurrentAppPinnedToStartMenuAsyncImpl
(
const
RefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
promiseHolder
)
{
ComPtr
<
IPackage3
>
package3
;
HRESULT
hr
=
GetPackage3
(
package3
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
ComPtr
<
IVectorView
<
AppListEntry
*
>
>
appListEntries
;
ComPtr
<
IAsyncOperation
<
IVectorView
<
AppListEntry
*
>
*
>
>
getAppListEntriesOperation
;
hr
=
package3
-
>
GetAppListEntriesAsync
(
&
getAppListEntriesOperation
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
auto
getAppListEntriesCallback
=
Callback
<
IAsyncOperationCompletedHandler
<
IVectorView
<
AppListEntry
*
>
*
>
>
(
[
promiseHolder
]
(
IAsyncOperation
<
IVectorView
<
AppListEntry
*
>
*
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
if
(
status
!
=
AsyncStatus
:
:
Completed
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IVectorView
<
AppListEntry
*
>
>
appListEntries
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
appListEntries
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IStartScreenManager
>
startScreenManager
;
ComPtr
<
IAppListEntry
>
entry
;
hr
=
GetStartScreenManager
(
appListEntries
entry
startScreenManager
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
ComPtr
<
IAsyncOperation
<
bool
>
>
getPinnedOperation
;
hr
=
startScreenManager
-
>
ContainsAppListEntryAsync
(
entry
.
Get
(
)
&
getPinnedOperation
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
auto
getPinnedCallback
=
Callback
<
IAsyncOperationCompletedHandler
<
bool
>
>
(
[
promiseHolder
entry
startScreenManager
]
(
IAsyncOperation
<
bool
>
*
operation
AsyncStatus
status
)
-
>
HRESULT
{
if
(
status
!
=
AsyncStatus
:
:
Completed
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
boolean
isAlreadyPinned
;
HRESULT
hr
=
operation
-
>
GetResults
(
&
isAlreadyPinned
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
E_FAIL
)
;
}
RESOLVE_AND_RETURN
(
promiseHolder
isAlreadyPinned
?
true
:
false
S_OK
)
;
}
)
;
hr
=
getPinnedOperation
-
>
put_Completed
(
getPinnedCallback
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
hr
)
;
}
return
hr
;
}
)
;
hr
=
getAppListEntriesOperation
-
>
put_Completed
(
getAppListEntriesCallback
.
Get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
REJECT_AND_RETURN
(
promiseHolder
NS_ERROR_FAILURE
)
;
}
}
NS_IMETHODIMP
nsWindowsShellService
:
:
IsCurrentAppPinnedToStartMenuAsync
(
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
!
widget
:
:
WinUtils
:
:
HasPackageIdentity
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
IsCurrentAppPinnedToStartMenuAsync
promise
"
promise
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
IsCurrentAppPinnedToStartMenuAsync
"
[
promiseHolder
]
{
IsCurrentAppPinnedToStartMenuAsyncImpl
(
promiseHolder
)
;
}
)
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
#
else
NS_IMETHODIMP
nsWindowsShellService
:
:
EnableLaunchOnLoginMSIXAsync
(
const
nsAString
&
aTaskId
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
DisableLaunchOnLoginMSIXAsync
(
const
nsAString
&
aTaskId
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
GetLaunchOnLoginEnabledMSIXAsync
(
const
nsAString
&
aTaskId
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
PinCurrentAppToStartMenuAsync
(
bool
aCheckOnly
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsWindowsShellService
:
:
IsCurrentAppPinnedToStartMenuAsync
(
JSContext
*
aCx
dom
:
:
Promise
*
*
aPromise
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
#
endif
NS_IMETHODIMP
nsWindowsShellService
:
:
ClassifyShortcut
(
const
nsAString
&
aPath
nsAString
&
aResult
)
{
aResult
.
Truncate
(
)
;
nsAutoString
shortcutPath
(
PromiseFlatString
(
aPath
)
)
;
struct
{
KNOWNFOLDERID
folderId
;
const
char16_t
*
postfix
;
const
char16_t
*
classification
;
}
folders
[
]
=
{
{
FOLDERID_CommonStartMenu
u
"
\
\
"
u
"
StartMenu
"
}
{
FOLDERID_StartMenu
u
"
\
\
"
u
"
StartMenu
"
}
{
FOLDERID_PublicDesktop
u
"
\
\
"
u
"
Desktop
"
}
{
FOLDERID_Desktop
u
"
\
\
"
u
"
Desktop
"
}
{
FOLDERID_UserPinned
u
"
\
\
TaskBar
\
\
"
u
"
Taskbar
"
}
{
FOLDERID_UserPinned
u
"
\
\
StartMenu
\
\
"
u
"
StartMenu
"
}
}
;
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
folders
)
;
+
+
i
)
{
nsAutoString
knownPath
;
DWORD
flags
=
KF_FLAG_SIMPLE_IDLIST
|
KF_FLAG_DONT_VERIFY
|
KF_FLAG_NO_ALIAS
;
PWSTR
rawPath
=
nullptr
;
if
(
FAILED
(
SHGetKnownFolderPath
(
folders
[
i
]
.
folderId
flags
nullptr
&
rawPath
)
)
)
{
continue
;
}
knownPath
=
nsDependentString
(
rawPath
)
;
CoTaskMemFree
(
rawPath
)
;
knownPath
.
Append
(
folders
[
i
]
.
postfix
)
;
if
(
wcsnicmp
(
shortcutPath
.
get
(
)
knownPath
.
get
(
)
knownPath
.
Length
(
)
)
=
=
0
)
{
aResult
.
Assign
(
folders
[
i
]
.
classification
)
;
nsTArray
<
nsCString
>
resIds
=
{
"
branding
/
brand
.
ftl
"
_ns
"
browser
/
browser
.
ftl
"
_ns
}
;
RefPtr
<
Localization
>
l10n
=
Localization
:
:
Create
(
resIds
true
)
;
nsAutoCString
pbStr
;
IgnoredErrorResult
rv
;
l10n
-
>
FormatValueSync
(
"
private
-
browsing
-
shortcut
-
text
-
2
"
_ns
{
}
pbStr
rv
)
;
NS_ConvertUTF8toUTF16
widePbStr
(
pbStr
)
;
if
(
wcsstr
(
shortcutPath
.
get
(
)
widePbStr
.
get
(
)
)
)
{
aResult
.
AppendLiteral
(
"
Private
"
)
;
}
return
NS_OK
;
}
}
return
NS_OK
;
}
nsWindowsShellService
:
:
nsWindowsShellService
(
)
{
}
nsWindowsShellService
:
:
~
nsWindowsShellService
(
)
{
}
