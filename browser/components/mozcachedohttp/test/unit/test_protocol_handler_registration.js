"
use
strict
"
;
add_task
(
async
function
test_protocol_handler_registration
(
)
{
let
protocolHandler
;
try
{
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
moz
-
cached
-
ohttp
"
)
.
QueryInterface
(
Ci
.
nsIProtocolHandler
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
moz
-
cached
-
ohttp
protocol
handler
should
be
registered
"
)
;
return
;
}
Assert
.
ok
(
protocolHandler
"
Protocol
handler
should
exist
"
)
;
Assert
.
equal
(
protocolHandler
.
scheme
"
moz
-
cached
-
ohttp
"
"
Correct
scheme
"
)
;
}
)
;
add_task
(
async
function
test_port_handling
(
)
{
const
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
moz
-
cached
-
ohttp
"
)
.
QueryInterface
(
Ci
.
nsIProtocolHandler
)
;
Assert
.
equal
(
protocolHandler
.
allowPort
(
80
"
moz
-
cached
-
ohttp
"
)
false
"
Should
not
allow
any
ports
"
)
;
Assert
.
equal
(
protocolHandler
.
allowPort
(
443
"
moz
-
cached
-
ohttp
"
)
false
"
Should
not
allow
any
ports
"
)
;
}
)
;
add_task
(
async
function
test_invalid_context_rejection
(
)
{
const
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
moz
-
cached
-
ohttp
"
)
.
QueryInterface
(
Ci
.
nsIProtocolHandler
)
;
const
testURI
=
Services
.
io
.
newURI
(
createTestOHTTPResourceURI
(
"
https
:
/
/
example
.
com
/
image
.
jpg
"
)
)
;
const
webURI
=
Services
.
io
.
newURI
(
"
https
:
/
/
example
.
com
"
)
;
const
webPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
webURI
{
}
)
;
const
httpURI
=
Services
.
io
.
newURI
(
"
https
:
/
/
example
.
com
/
test
"
)
;
const
loadInfo
=
NetUtil
.
newChannel
(
{
uri
:
httpURI
loadingPrincipal
:
webPrincipal
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_IMAGE
}
)
.
loadInfo
;
Assert
.
throws
(
(
)
=
>
protocolHandler
.
newChannel
(
testURI
loadInfo
)
/
moz
-
cached
-
ohttp
protocol
only
accessible
from
privileged
about
content
/
"
Should
reject
non
-
privileged
contexts
"
)
;
}
)
;
