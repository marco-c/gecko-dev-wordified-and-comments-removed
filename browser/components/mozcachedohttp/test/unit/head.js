"
use
strict
"
;
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
const
{
MockRegistrar
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
)
;
const
{
MozCachedOHTTPProtocolHandler
}
=
ChromeUtils
.
importESModule
(
"
moz
-
src
:
/
/
/
browser
/
components
/
mozcachedohttp
/
MozCachedOHTTPProtocolHandler
.
sys
.
mjs
"
)
;
do_get_profile
(
)
;
ChromeUtils
.
registerProcessActor
(
"
MozCachedOHTTP
"
{
parent
:
{
esModuleURI
:
"
moz
-
src
:
/
/
/
browser
/
components
/
mozcachedohttp
/
actors
/
MozCachedOHTTPParent
.
sys
.
mjs
"
}
includeParent
:
true
}
)
;
function
createTestOHTTPResourceURI
(
resourceURL
)
{
const
encodedURL
=
encodeURIComponent
(
resourceURL
)
;
return
moz
-
cached
-
ohttp
:
/
/
newtab
-
image
/
?
url
=
{
encodedURL
}
;
}
function
createTestChannel
(
uri
)
{
const
testURI
=
Services
.
io
.
newURI
(
uri
)
;
const
principal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
const
protocolHandler
=
new
MozCachedOHTTPProtocolHandler
(
)
;
protocolHandler
.
injectOHTTPService
(
MockOHTTPService
)
;
const
loadInfo
=
createLoadInfo
(
testURI
principal
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT
Ci
.
nsIContentPolicy
.
TYPE_OTHER
)
;
return
protocolHandler
.
newChannel
(
testURI
loadInfo
)
;
}
function
createLoadInfo
(
uri
loadingPrincipal
securityFlags
contentPolicyType
)
{
return
NetUtil
.
newChannel
(
{
uri
loadingPrincipal
securityFlags
contentPolicyType
}
)
.
loadInfo
;
}
function
createDataCollectingListener
(
onComplete
)
{
let
receivedData
=
"
"
;
return
{
onStartRequest
(
)
{
}
onDataAvailable
(
request
inputStream
offset
count
)
{
const
binaryInputStream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
binaryInputStream
.
setInputStream
(
inputStream
)
;
receivedData
+
=
binaryInputStream
.
readBytes
(
count
)
;
}
onStopRequest
(
request
status
)
{
const
success
=
Components
.
isSuccessCode
(
status
)
;
onComplete
(
receivedData
success
)
;
}
}
;
}
function
createCompletionListener
(
onComplete
)
{
let
receivedData
=
false
;
return
{
onStartRequest
(
)
{
}
onDataAvailable
(
)
{
receivedData
=
true
;
}
onStopRequest
(
request
status
)
{
const
success
=
Components
.
isSuccessCode
(
status
)
;
onComplete
(
success
receivedData
)
;
}
}
;
}
const
MockOHTTPService
=
{
channelCreated
:
false
totalChannels
:
0
lastRelayURI
:
null
lastTargetURI
:
null
lastConfig
:
null
shouldSucceed
:
true
newChannel
(
relayURI
targetURI
config
)
{
this
.
channelCreated
=
true
;
this
.
lastRelayURI
=
relayURI
;
this
.
lastTargetURI
=
targetURI
;
this
.
lastConfig
=
config
;
this
.
totalChannels
+
+
;
return
this
.
_createMockChannel
(
targetURI
this
.
shouldSucceed
)
;
}
_createMockChannel
(
targetURI
shouldSucceed
)
{
return
{
URI
:
targetURI
loadInfo
:
null
loadFlags
:
0
notificationCallbacks
:
null
loadGroup
:
null
asyncOpen
(
listener
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
_simulateChannelResponse
(
listener
shouldSucceed
)
;
}
)
;
}
_simulateChannelResponse
(
listener
success
)
{
try
{
listener
.
onStartRequest
(
this
)
;
if
(
success
)
{
const
data
=
new
ArrayBuffer
(
1024
)
;
const
inputStream
=
Cc
[
"
mozilla
.
org
/
io
/
arraybuffer
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIArrayBufferInputStream
)
;
inputStream
.
setData
(
data
0
data
.
byteLength
)
;
listener
.
onDataAvailable
(
this
inputStream
0
data
.
byteLength
)
;
}
listener
.
onStopRequest
(
this
success
?
Cr
.
NS_OK
:
Cr
.
NS_ERROR_FAILURE
)
;
}
catch
(
e
)
{
listener
.
onStopRequest
(
this
Cr
.
NS_ERROR_FAILURE
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIChannel
"
"
nsIRequest
"
]
)
}
;
}
reset
(
)
{
this
.
channelCreated
=
false
;
this
.
totalChannels
=
0
;
this
.
lastRelayURI
=
null
;
this
.
lastTargetURI
=
null
;
this
.
lastConfig
=
null
;
this
.
shouldSucceed
=
true
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObliviousHttpService
"
]
)
}
;
