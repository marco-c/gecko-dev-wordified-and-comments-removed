"
use
strict
"
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
AboutProtectionsHandler
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
RemotePages
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
remotepagemanager
/
RemotePageManagerParent
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
TrackingDBService
"
"
mozilla
.
org
/
tracking
-
db
-
service
;
1
"
"
nsITrackingDBService
"
)
;
let
idToTextMap
=
new
Map
(
[
[
Ci
.
nsITrackingDBService
.
TRACKERS_ID
"
tracker
"
]
[
Ci
.
nsITrackingDBService
.
TRACKING_COOKIES_ID
"
cookie
"
]
[
Ci
.
nsITrackingDBService
.
CRYPTOMINERS_ID
"
cryptominer
"
]
[
Ci
.
nsITrackingDBService
.
FINGERPRINTERS_ID
"
fingerprinter
"
]
]
)
;
const
MONITOR_API_ENDPOINT
=
"
https
:
/
/
monitor
.
firefox
.
com
/
user
/
breach
-
stats
"
;
const
SCOPE_MONITOR
=
[
"
profile
:
uid
"
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
monitor
"
]
;
const
INVALID_OAUTH_TOKEN
=
"
Invalid
OAuth
token
"
;
const
USER_UNSUBSCRIBED_TO_MONITOR
=
"
User
is
not
subscribed
to
Monitor
"
;
const
SERVICE_UNAVAILABLE
=
"
Service
unavailable
"
;
const
UNEXPECTED_RESPONSE
=
"
Unexpected
response
"
;
const
UNKNOWN_ERROR
=
"
Unknown
error
"
;
const
MONITOR_RESPONSE_PROPS
=
[
"
monitoredEmails
"
"
numBreaches
"
"
passwords
"
]
;
var
AboutProtectionsHandler
=
{
_inited
:
false
_topics
:
[
"
OpenAboutLogins
"
"
OpenContentBlockingPreferences
"
"
OpenSyncPreferences
"
"
FetchContentBlockingEvents
"
"
FetchMonitorData
"
"
FetchUserLoginsData
"
]
init
(
)
{
this
.
receiveMessage
=
this
.
receiveMessage
.
bind
(
this
)
;
this
.
pageListener
=
new
RemotePages
(
"
about
:
protections
"
)
;
for
(
let
topic
of
this
.
_topics
)
{
this
.
pageListener
.
addMessageListener
(
topic
this
.
receiveMessage
)
;
}
this
.
_inited
=
true
;
}
uninit
(
)
{
if
(
!
this
.
_inited
)
{
return
;
}
for
(
let
topic
of
this
.
_topics
)
{
this
.
pageListener
.
removeMessageListener
(
topic
this
.
receiveMessage
)
;
}
this
.
pageListener
.
destroy
(
)
;
}
async
fetchUserBreachStats
(
token
)
{
let
monitorResponse
=
null
;
const
headers
=
new
Headers
(
)
;
headers
.
append
(
"
Authorization
"
Bearer
{
token
}
)
;
const
request
=
new
Request
(
MONITOR_API_ENDPOINT
{
headers
}
)
;
const
response
=
await
fetch
(
request
)
;
if
(
response
.
ok
)
{
const
json
=
await
response
.
json
(
)
;
let
isValid
=
null
;
for
(
let
prop
in
json
)
{
isValid
=
MONITOR_RESPONSE_PROPS
.
includes
(
prop
)
;
if
(
!
isValid
)
{
break
;
}
}
monitorResponse
=
isValid
?
json
:
new
Error
(
UNEXPECTED_RESPONSE
)
;
}
else
{
switch
(
response
.
status
)
{
case
400
:
case
401
:
monitorResponse
=
new
Error
(
INVALID_OAUTH_TOKEN
)
;
break
;
case
404
:
monitorResponse
=
new
Error
(
USER_UNSUBSCRIBED_TO_MONITOR
)
;
break
;
case
503
:
monitorResponse
=
new
Error
(
SERVICE_UNAVAILABLE
)
;
break
;
default
:
monitorResponse
=
new
Error
(
UNKNOWN_ERROR
)
;
break
;
}
}
if
(
monitorResponse
instanceof
Error
)
{
throw
monitorResponse
;
}
return
monitorResponse
;
}
async
getLoginData
(
)
{
let
syncedDevices
=
[
]
;
const
hasFxa
=
await
fxAccounts
.
accountStatus
(
)
;
if
(
hasFxa
)
{
syncedDevices
=
await
fxAccounts
.
getDeviceList
(
)
;
}
return
{
hasFxa
numLogins
:
Services
.
logins
.
countLogins
(
"
"
"
"
"
"
)
numSyncedDevices
:
syncedDevices
.
length
}
;
}
async
getMonitorData
(
)
{
let
monitorData
=
{
}
;
let
potentiallyBreachedLogins
=
null
;
const
hasFxa
=
await
fxAccounts
.
accountStatus
(
)
;
if
(
hasFxa
)
{
let
token
=
await
this
.
getMonitorScopedOAuthToken
(
)
;
if
(
!
token
)
{
return
{
error
:
true
}
;
}
try
{
monitorData
=
await
this
.
fetchUserBreachStats
(
token
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
.
message
)
;
if
(
e
.
message
=
=
=
INVALID_OAUTH_TOKEN
)
{
await
fxAccounts
.
removeCachedOAuthToken
(
{
token
}
)
;
token
=
await
await
this
.
getMonitorScopedOAuthToken
(
)
;
try
{
monitorData
=
await
this
.
fetchUserBreachStats
(
token
)
;
}
catch
(
_
)
{
Cu
.
reportError
(
e
.
message
)
;
monitorData
.
errorMessage
=
INVALID_OAUTH_TOKEN
;
}
}
else
{
monitorData
.
errorMessage
=
e
.
message
;
}
}
if
(
!
LoginHelper
.
isMasterPasswordSet
(
)
)
{
const
logins
=
await
LoginHelper
.
getAllUserFacingLogins
(
)
;
potentiallyBreachedLogins
=
await
LoginHelper
.
getBreachesForLogins
(
logins
)
;
}
}
else
{
monitorData
=
{
errorMessage
:
"
No
account
"
}
;
}
return
{
.
.
.
monitorData
potentiallyBreachedLogins
:
potentiallyBreachedLogins
?
potentiallyBreachedLogins
.
size
:
0
error
:
!
!
monitorData
.
errorMessage
}
;
}
async
getMonitorScopedOAuthToken
(
)
{
let
token
=
null
;
try
{
token
=
await
fxAccounts
.
getOAuthToken
(
{
scope
:
SCOPE_MONITOR
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
There
was
an
error
fetching
the
user
'
s
token
:
"
e
.
message
)
;
}
return
token
;
}
sendMessage
(
target
message
payload
)
{
if
(
target
.
browser
)
{
target
.
sendAsyncMessage
(
message
payload
)
;
}
}
async
receiveMessage
(
aMessage
)
{
let
win
=
aMessage
.
target
.
browser
.
ownerGlobal
;
switch
(
aMessage
.
name
)
{
case
"
OpenAboutLogins
"
:
win
.
openTrustedLinkIn
(
"
about
:
logins
"
"
tab
"
)
;
break
;
case
"
OpenContentBlockingPreferences
"
:
win
.
openPreferences
(
"
privacy
-
trackingprotection
"
{
origin
:
"
about
-
protections
"
}
)
;
break
;
case
"
OpenSyncPreferences
"
:
win
.
openTrustedLinkIn
(
"
about
:
preferences
#
sync
"
"
tab
"
)
;
break
;
case
"
FetchContentBlockingEvents
"
:
let
sumEvents
=
await
TrackingDBService
.
sumAllEvents
(
)
;
let
earliestDate
=
await
TrackingDBService
.
getEarliestRecordedDate
(
)
;
let
eventsByDate
=
await
TrackingDBService
.
getEventsByDateRange
(
aMessage
.
data
.
from
aMessage
.
data
.
to
)
;
let
dataToSend
=
{
}
;
let
largest
=
0
;
for
(
let
result
of
eventsByDate
)
{
let
count
=
result
.
getResultByName
(
"
count
"
)
;
let
type
=
result
.
getResultByName
(
"
type
"
)
;
let
timestamp
=
result
.
getResultByName
(
"
timestamp
"
)
;
dataToSend
[
timestamp
]
=
dataToSend
[
timestamp
]
|
|
{
total
:
0
}
;
dataToSend
[
timestamp
]
[
idToTextMap
.
get
(
type
)
]
=
count
;
dataToSend
[
timestamp
]
.
total
+
=
count
;
if
(
largest
<
dataToSend
[
timestamp
]
.
total
)
{
largest
=
dataToSend
[
timestamp
]
.
total
;
}
dataToSend
.
largest
=
largest
;
}
dataToSend
.
earliestDate
=
earliestDate
;
dataToSend
.
sumEvents
=
sumEvents
;
this
.
sendMessage
(
aMessage
.
target
"
SendContentBlockingRecords
"
dataToSend
)
;
break
;
case
"
FetchMonitorData
"
:
this
.
sendMessage
(
aMessage
.
target
"
SendMonitorData
"
await
this
.
getMonitorData
(
)
)
;
break
;
case
"
FetchUserLoginsData
"
:
this
.
sendMessage
(
aMessage
.
target
"
SendUserLoginsData
"
await
this
.
getLoginData
(
)
)
;
break
;
}
}
}
;
