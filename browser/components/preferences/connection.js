document
.
documentElement
.
addEventListener
(
"
dialoghelp
"
window
.
top
.
openPrefsHelp
)
;
Preferences
.
addAll
(
[
{
id
:
"
network
.
proxy
.
autoconfig_url
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
type
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
http
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
http_port
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
ftp
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
ftp_port
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
ssl
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
ssl_port
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
socks
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
socks_port
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
socks_version
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
socks_remote_dns
"
type
:
"
bool
"
}
{
id
:
"
network
.
proxy
.
no_proxies_on
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
share_proxy_settings
"
type
:
"
bool
"
}
{
id
:
"
signon
.
autologin
.
proxy
"
type
:
"
bool
"
}
{
id
:
"
pref
.
advanced
.
proxies
.
disable_button
.
reload
"
type
:
"
bool
"
}
{
id
:
"
network
.
proxy
.
backup
.
ftp
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
backup
.
ftp_port
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
backup
.
ssl
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
backup
.
ssl_port
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
backup
.
socks
"
type
:
"
string
"
}
{
id
:
"
network
.
proxy
.
backup
.
socks_port
"
type
:
"
int
"
}
{
id
:
"
network
.
trr
.
mode
"
type
:
"
int
"
}
{
id
:
"
network
.
trr
.
uri
"
type
:
"
string
"
}
{
id
:
"
network
.
trr
.
resolvers
"
type
:
"
string
"
}
{
id
:
"
network
.
trr
.
custom_uri
"
type
:
"
string
"
}
]
)
;
window
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
Preferences
.
get
(
"
network
.
proxy
.
type
"
)
.
on
(
"
change
"
gConnectionsDialog
.
proxyTypeChanged
.
bind
(
gConnectionsDialog
)
)
;
Preferences
.
get
(
"
network
.
proxy
.
socks_version
"
)
.
on
(
"
change
"
gConnectionsDialog
.
updateDNSPref
.
bind
(
gConnectionsDialog
)
)
;
Preferences
.
get
(
"
network
.
trr
.
uri
"
)
.
on
(
"
change
"
(
)
=
>
{
gConnectionsDialog
.
updateDnsOverHttpsUI
(
)
;
}
)
;
Preferences
.
get
(
"
network
.
trr
.
resolvers
"
)
.
on
(
"
change
"
(
)
=
>
{
gConnectionsDialog
.
initDnsOverHttpsUI
(
)
;
}
)
;
gConnectionsDialog
.
uiReady
=
new
Promise
(
resolve
=
>
{
gConnectionsDialog
.
_areTrrPrefsReady
=
false
;
gConnectionsDialog
.
_handleTrrPrefsReady
=
resolve
;
}
)
.
then
(
(
)
=
>
{
gConnectionsDialog
.
initDnsOverHttpsUI
(
)
;
}
)
;
document
.
getElementById
(
"
disableProxyExtension
"
)
.
addEventListener
(
"
command
"
makeDisableControllingExtension
(
PREF_SETTING_TYPE
PROXY_KEY
)
.
bind
(
gConnectionsDialog
)
)
;
gConnectionsDialog
.
updateProxySettingsUI
(
)
;
initializeProxyUI
(
gConnectionsDialog
)
;
}
{
once
:
true
capture
:
true
}
)
;
var
gConnectionsDialog
=
{
beforeAccept
(
)
{
let
dnsOverHttpsResolverChoice
=
document
.
getElementById
(
"
networkDnsOverHttpsResolverChoices
"
)
.
value
;
if
(
dnsOverHttpsResolverChoice
=
=
"
custom
"
)
{
let
customValue
=
document
.
getElementById
(
"
networkCustomDnsOverHttpsInput
"
)
.
value
.
trim
(
)
;
if
(
customValue
)
{
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
uri
"
customValue
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
"
network
.
trr
.
uri
"
)
;
}
}
else
{
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
uri
"
dnsOverHttpsResolverChoice
)
;
}
var
proxyTypePref
=
Preferences
.
get
(
"
network
.
proxy
.
type
"
)
;
if
(
proxyTypePref
.
value
=
=
2
)
{
this
.
doAutoconfigURLFixup
(
)
;
return
true
;
}
if
(
proxyTypePref
.
value
!
=
1
)
{
return
true
;
}
var
httpProxyURLPref
=
Preferences
.
get
(
"
network
.
proxy
.
http
"
)
;
var
httpProxyPortPref
=
Preferences
.
get
(
"
network
.
proxy
.
http_port
"
)
;
var
shareProxiesPref
=
Preferences
.
get
(
"
network
.
proxy
.
share_proxy_settings
"
)
;
for
(
let
prefName
of
[
"
http
"
"
ssl
"
"
ftp
"
"
socks
"
]
)
{
let
proxyPortPref
=
Preferences
.
get
(
"
network
.
proxy
.
"
+
prefName
+
"
_port
"
)
;
let
proxyPref
=
Preferences
.
get
(
"
network
.
proxy
.
"
+
prefName
)
;
if
(
proxyPref
.
value
!
=
"
"
&
&
proxyPortPref
.
value
=
=
0
&
&
(
prefName
=
=
"
http
"
|
|
!
shareProxiesPref
.
value
)
)
{
document
.
getElementById
(
"
networkProxy
"
+
prefName
.
toUpperCase
(
)
+
"
_Port
"
)
.
focus
(
)
;
return
false
;
}
}
if
(
shareProxiesPref
.
value
)
{
var
proxyPrefs
=
[
"
ssl
"
"
ftp
"
"
socks
"
]
;
for
(
var
i
=
0
;
i
<
proxyPrefs
.
length
;
+
+
i
)
{
var
proxyServerURLPref
=
Preferences
.
get
(
"
network
.
proxy
.
"
+
proxyPrefs
[
i
]
)
;
var
proxyPortPref
=
Preferences
.
get
(
"
network
.
proxy
.
"
+
proxyPrefs
[
i
]
+
"
_port
"
)
;
var
backupServerURLPref
=
Preferences
.
get
(
"
network
.
proxy
.
backup
.
"
+
proxyPrefs
[
i
]
)
;
var
backupPortPref
=
Preferences
.
get
(
"
network
.
proxy
.
backup
.
"
+
proxyPrefs
[
i
]
+
"
_port
"
)
;
backupServerURLPref
.
value
=
backupServerURLPref
.
value
|
|
proxyServerURLPref
.
value
;
backupPortPref
.
value
=
backupPortPref
.
value
|
|
proxyPortPref
.
value
;
proxyServerURLPref
.
value
=
httpProxyURLPref
.
value
;
proxyPortPref
.
value
=
httpProxyPortPref
.
value
;
}
}
this
.
sanitizeNoProxiesPref
(
)
;
return
true
;
}
checkForSystemProxy
(
)
{
if
(
"
mozilla
.
org
/
system
-
proxy
-
settings
;
1
"
in
Cc
)
{
document
.
getElementById
(
"
systemPref
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
}
proxyTypeChanged
(
)
{
var
proxyTypePref
=
Preferences
.
get
(
"
network
.
proxy
.
type
"
)
;
var
httpProxyURLPref
=
Preferences
.
get
(
"
network
.
proxy
.
http
"
)
;
httpProxyURLPref
.
disabled
=
proxyTypePref
.
value
!
=
1
;
var
httpProxyPortPref
=
Preferences
.
get
(
"
network
.
proxy
.
http_port
"
)
;
httpProxyPortPref
.
disabled
=
proxyTypePref
.
value
!
=
1
;
this
.
updateProtocolPrefs
(
)
;
var
shareProxiesPref
=
Preferences
.
get
(
"
network
.
proxy
.
share_proxy_settings
"
)
;
shareProxiesPref
.
disabled
=
proxyTypePref
.
value
!
=
1
|
|
shareProxiesPref
.
locked
;
var
autologinProxyPref
=
Preferences
.
get
(
"
signon
.
autologin
.
proxy
"
)
;
autologinProxyPref
.
disabled
=
proxyTypePref
.
value
=
=
0
|
|
autologinProxyPref
.
locked
;
var
noProxiesPref
=
Preferences
.
get
(
"
network
.
proxy
.
no_proxies_on
"
)
;
noProxiesPref
.
disabled
=
proxyTypePref
.
value
=
=
0
|
|
noProxiesPref
.
locked
;
var
autoconfigURLPref
=
Preferences
.
get
(
"
network
.
proxy
.
autoconfig_url
"
)
;
autoconfigURLPref
.
disabled
=
proxyTypePref
.
value
!
=
2
|
|
autoconfigURLPref
.
locked
;
this
.
updateReloadButton
(
)
;
document
.
getElementById
(
"
networkProxyNoneLocalhost
"
)
.
hidden
=
Services
.
prefs
.
getBoolPref
(
"
network
.
proxy
.
allow_hijacking_localhost
"
false
)
;
}
updateDNSPref
(
)
{
var
socksVersionPref
=
Preferences
.
get
(
"
network
.
proxy
.
socks_version
"
)
;
var
socksDNSPref
=
Preferences
.
get
(
"
network
.
proxy
.
socks_remote_dns
"
)
;
var
proxyTypePref
=
Preferences
.
get
(
"
network
.
proxy
.
type
"
)
;
var
isDefinitelySocks4
=
!
socksVersionPref
.
disabled
&
&
socksVersionPref
.
value
=
=
4
;
socksDNSPref
.
disabled
=
isDefinitelySocks4
|
|
proxyTypePref
.
value
=
=
0
;
return
undefined
;
}
updateReloadButton
(
)
{
var
typedURL
=
document
.
getElementById
(
"
networkProxyAutoconfigURL
"
)
.
value
;
var
proxyTypeCur
=
Preferences
.
get
(
"
network
.
proxy
.
type
"
)
.
value
;
var
pacURL
=
Services
.
prefs
.
getCharPref
(
"
network
.
proxy
.
autoconfig_url
"
)
;
var
proxyType
=
Services
.
prefs
.
getIntPref
(
"
network
.
proxy
.
type
"
)
;
var
disableReloadPref
=
Preferences
.
get
(
"
pref
.
advanced
.
proxies
.
disable_button
.
reload
"
)
;
disableReloadPref
.
disabled
=
proxyTypeCur
!
=
2
|
|
proxyType
!
=
2
|
|
typedURL
!
=
pacURL
;
}
readProxyType
(
)
{
this
.
proxyTypeChanged
(
)
;
return
undefined
;
}
updateProtocolPrefs
(
)
{
var
proxyTypePref
=
Preferences
.
get
(
"
network
.
proxy
.
type
"
)
;
var
shareProxiesPref
=
Preferences
.
get
(
"
network
.
proxy
.
share_proxy_settings
"
)
;
var
proxyPrefs
=
[
"
ssl
"
"
ftp
"
"
socks
"
]
;
for
(
var
i
=
0
;
i
<
proxyPrefs
.
length
;
+
+
i
)
{
var
proxyServerURLPref
=
Preferences
.
get
(
"
network
.
proxy
.
"
+
proxyPrefs
[
i
]
)
;
var
proxyPortPref
=
Preferences
.
get
(
"
network
.
proxy
.
"
+
proxyPrefs
[
i
]
+
"
_port
"
)
;
if
(
!
shareProxiesPref
.
value
)
{
var
backupServerURLPref
=
Preferences
.
get
(
"
network
.
proxy
.
backup
.
"
+
proxyPrefs
[
i
]
)
;
var
backupPortPref
=
Preferences
.
get
(
"
network
.
proxy
.
backup
.
"
+
proxyPrefs
[
i
]
+
"
_port
"
)
;
if
(
backupServerURLPref
.
hasUserValue
)
{
proxyServerURLPref
.
value
=
backupServerURLPref
.
value
;
backupServerURLPref
.
reset
(
)
;
}
if
(
backupPortPref
.
hasUserValue
)
{
proxyPortPref
.
value
=
backupPortPref
.
value
;
backupPortPref
.
reset
(
)
;
}
}
proxyServerURLPref
.
updateElements
(
)
;
proxyPortPref
.
updateElements
(
)
;
proxyServerURLPref
.
disabled
=
proxyTypePref
.
value
!
=
1
|
|
shareProxiesPref
.
value
;
proxyPortPref
.
disabled
=
proxyServerURLPref
.
disabled
;
}
var
socksVersionPref
=
Preferences
.
get
(
"
network
.
proxy
.
socks_version
"
)
;
socksVersionPref
.
disabled
=
proxyTypePref
.
value
!
=
1
|
|
shareProxiesPref
.
value
;
this
.
updateDNSPref
(
)
;
return
undefined
;
}
readProxyProtocolPref
(
aProtocol
aIsPort
)
{
var
shareProxiesPref
=
Preferences
.
get
(
"
network
.
proxy
.
share_proxy_settings
"
)
;
if
(
shareProxiesPref
.
value
)
{
var
pref
=
Preferences
.
get
(
"
network
.
proxy
.
http
"
+
(
aIsPort
?
"
_port
"
:
"
"
)
)
;
return
pref
.
value
;
}
var
backupPref
=
Preferences
.
get
(
"
network
.
proxy
.
backup
.
"
+
aProtocol
+
(
aIsPort
?
"
_port
"
:
"
"
)
)
;
return
backupPref
.
hasUserValue
?
backupPref
.
value
:
undefined
;
}
reloadPAC
(
)
{
Cc
[
"
mozilla
.
org
/
network
/
protocol
-
proxy
-
service
;
1
"
]
.
getService
(
)
.
reloadPAC
(
)
;
}
doAutoconfigURLFixup
(
)
{
var
autoURL
=
document
.
getElementById
(
"
networkProxyAutoconfigURL
"
)
;
var
autoURLPref
=
Preferences
.
get
(
"
network
.
proxy
.
autoconfig_url
"
)
;
try
{
autoURLPref
.
value
=
autoURL
.
value
=
Services
.
uriFixup
.
createFixupURI
(
autoURL
.
value
0
)
.
spec
;
}
catch
(
ex
)
{
}
}
sanitizeNoProxiesPref
(
)
{
var
noProxiesPref
=
Preferences
.
get
(
"
network
.
proxy
.
no_proxies_on
"
)
;
noProxiesPref
.
value
=
noProxiesPref
.
value
.
replace
(
/
(
[
^
\
n
;
]
)
[
;
\
n
]
+
(
?
!
[
\
n
;
]
)
/
g
"
1
"
)
;
noProxiesPref
.
value
=
noProxiesPref
.
value
.
replace
(
/
[
;
\
n
]
/
g
"
"
)
;
}
readHTTPProxyServer
(
)
{
var
shareProxiesPref
=
Preferences
.
get
(
"
network
.
proxy
.
share_proxy_settings
"
)
;
if
(
shareProxiesPref
.
value
)
{
this
.
updateProtocolPrefs
(
)
;
}
return
undefined
;
}
readHTTPProxyPort
(
)
{
var
shareProxiesPref
=
Preferences
.
get
(
"
network
.
proxy
.
share_proxy_settings
"
)
;
if
(
shareProxiesPref
.
value
)
{
this
.
updateProtocolPrefs
(
)
;
}
return
undefined
;
}
getProxyControls
(
)
{
let
controlGroup
=
document
.
getElementById
(
"
networkProxyType
"
)
;
return
[
.
.
.
controlGroup
.
querySelectorAll
(
"
:
scope
>
radio
"
)
.
.
.
controlGroup
.
querySelectorAll
(
"
label
"
)
.
.
.
controlGroup
.
querySelectorAll
(
"
textbox
"
)
.
.
.
controlGroup
.
querySelectorAll
(
"
checkbox
"
)
.
.
.
document
.
querySelectorAll
(
"
#
networkProxySOCKSVersion
>
radio
"
)
.
.
.
document
.
querySelectorAll
(
"
#
ConnectionsDialogPane
>
checkbox
"
)
]
;
}
async
updateProxySettingsUI
(
)
{
let
isLocked
=
API_PROXY_PREFS
.
some
(
pref
=
>
Services
.
prefs
.
prefIsLocked
(
pref
)
)
;
function
setInputsDisabledState
(
isControlled
)
{
for
(
let
element
of
gConnectionsDialog
.
getProxyControls
(
)
)
{
element
.
disabled
=
isControlled
;
}
gConnectionsDialog
.
proxyTypeChanged
(
)
;
}
if
(
isLocked
)
{
hideControllingExtension
(
PROXY_KEY
)
;
}
else
{
handleControllingExtension
(
PREF_SETTING_TYPE
PROXY_KEY
)
.
then
(
setInputsDisabledState
)
;
}
}
get
dnsOverHttpsResolvers
(
)
{
let
rawValue
=
Preferences
.
get
(
"
network
.
trr
.
resolvers
"
"
"
)
.
value
;
let
defaultURI
=
Preferences
.
get
(
"
network
.
trr
.
uri
"
"
"
)
.
defaultValue
;
let
providers
=
[
]
;
if
(
rawValue
)
{
try
{
providers
=
JSON
.
parse
(
rawValue
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Bad
JSON
data
in
pref
network
.
trr
.
resolvers
:
{
rawValue
}
)
;
}
}
if
(
!
Array
.
isArray
(
providers
)
)
{
Cu
.
reportError
(
Expected
a
JSON
array
in
network
.
trr
.
resolvers
:
{
rawValue
}
)
;
providers
=
[
]
;
}
let
defaultIndex
=
providers
.
findIndex
(
p
=
>
p
.
url
=
=
defaultURI
)
;
if
(
defaultIndex
=
=
-
1
&
&
defaultURI
)
{
providers
.
unshift
(
{
url
:
defaultURI
}
)
;
}
return
providers
;
}
isDnsOverHttpsLocked
(
)
{
return
Services
.
prefs
.
prefIsLocked
(
"
network
.
trr
.
mode
"
)
;
}
isDnsOverHttpsEnabled
(
)
{
let
trrPref
=
Preferences
.
get
(
"
network
.
trr
.
mode
"
)
;
let
enabled
=
trrPref
.
value
>
0
&
&
trrPref
.
value
<
5
;
return
enabled
;
}
readDnsOverHttpsMode
(
)
{
let
enabled
=
this
.
isDnsOverHttpsEnabled
(
)
;
let
uriPref
=
Preferences
.
get
(
"
network
.
trr
.
uri
"
)
;
uriPref
.
disabled
=
!
enabled
|
|
this
.
isDnsOverHttpsLocked
(
)
;
if
(
!
this
.
_areTrrPrefsReady
)
{
this
.
_areTrrPrefsReady
=
true
;
this
.
_handleTrrPrefsReady
(
)
;
}
else
{
this
.
updateDnsOverHttpsUI
(
)
;
}
return
enabled
;
}
writeDnsOverHttpsMode
(
)
{
let
trrModeCheckbox
=
document
.
getElementById
(
"
networkDnsOverHttps
"
)
;
return
trrModeCheckbox
.
checked
?
2
:
0
;
}
updateDnsOverHttpsUI
(
)
{
if
(
!
this
.
_areTrrPrefsReady
)
{
return
;
}
let
[
menu
customInput
]
=
this
.
getDnsOverHttpsControls
(
)
;
let
customContainer
=
document
.
getElementById
(
"
customDnsOverHttpsContainer
"
)
;
let
customURI
=
Preferences
.
get
(
"
network
.
trr
.
custom_uri
"
)
.
value
;
let
currentURI
=
Preferences
.
get
(
"
network
.
trr
.
uri
"
)
.
value
;
let
resolvers
=
this
.
dnsOverHttpsResolvers
;
let
isCustom
=
menu
.
value
=
=
"
custom
"
;
if
(
this
.
isDnsOverHttpsEnabled
(
)
)
{
this
.
toggleDnsOverHttpsUI
(
false
)
;
if
(
isCustom
)
{
if
(
currentURI
&
&
!
customURI
&
&
!
resolvers
.
find
(
r
=
>
r
.
url
=
=
currentURI
)
)
{
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
custom_uri
"
currentURI
)
;
}
}
}
else
{
this
.
toggleDnsOverHttpsUI
(
true
)
;
}
if
(
!
menu
.
disabled
&
&
isCustom
)
{
customContainer
.
hidden
=
false
;
customInput
.
disabled
=
false
;
customContainer
.
scrollIntoView
(
)
;
}
else
{
customContainer
.
hidden
=
true
;
customInput
.
disabled
=
true
;
}
requestAnimationFrame
(
(
)
=
>
{
let
dialogs
=
window
.
opener
.
gSubDialog
.
_dialogs
;
let
dialog
=
dialogs
.
find
(
d
=
>
d
.
_frame
.
contentDocument
=
=
document
)
;
if
(
dialog
)
{
dialog
.
resizeVertically
(
)
;
}
}
)
;
}
getDnsOverHttpsControls
(
)
{
return
[
document
.
getElementById
(
"
networkDnsOverHttpsResolverChoices
"
)
document
.
getElementById
(
"
networkCustomDnsOverHttpsInput
"
)
document
.
getElementById
(
"
networkDnsOverHttpsResolverChoicesLabel
"
)
document
.
getElementById
(
"
networkCustomDnsOverHttpsInputLabel
"
)
]
;
}
toggleDnsOverHttpsUI
(
disabled
)
{
for
(
let
element
of
this
.
getDnsOverHttpsControls
(
)
)
{
element
.
disabled
=
disabled
;
}
}
initDnsOverHttpsUI
(
)
{
let
resolvers
=
this
.
dnsOverHttpsResolvers
;
let
defaultURI
=
Preferences
.
get
(
"
network
.
trr
.
uri
"
)
.
defaultValue
;
let
currentURI
=
Preferences
.
get
(
"
network
.
trr
.
uri
"
)
.
value
;
let
menu
=
document
.
getElementById
(
"
networkDnsOverHttpsResolverChoices
"
)
;
menu
.
removeAllItems
(
)
;
for
(
let
resolver
of
resolvers
)
{
let
item
=
menu
.
appendItem
(
undefined
resolver
.
url
)
;
if
(
resolver
.
url
=
=
defaultURI
)
{
document
.
l10n
.
setAttributes
(
item
"
connection
-
dns
-
over
-
https
-
url
-
item
-
default
"
{
name
:
resolver
.
name
|
|
resolver
.
url
}
)
;
}
else
{
item
.
label
=
resolver
.
name
|
|
resolver
.
url
;
}
}
let
lastItem
=
menu
.
appendItem
(
undefined
"
custom
"
)
;
document
.
l10n
.
setAttributes
(
lastItem
"
connection
-
dns
-
over
-
https
-
url
-
custom
"
)
;
let
selectedIndex
=
currentURI
?
resolvers
.
findIndex
(
r
=
>
r
.
url
=
=
currentURI
)
:
0
;
if
(
selectedIndex
=
=
-
1
)
{
selectedIndex
=
menu
.
itemCount
-
1
;
}
menu
.
selectedIndex
=
selectedIndex
;
if
(
this
.
isDnsOverHttpsLocked
(
)
)
{
this
.
toggleDnsOverHttpsUI
(
true
)
;
document
.
getElementById
(
"
networkDnsOverHttps
"
)
.
disabled
=
true
;
}
else
{
this
.
toggleDnsOverHttpsUI
(
false
)
;
this
.
updateDnsOverHttpsUI
(
)
;
document
.
getElementById
(
"
networkDnsOverHttps
"
)
.
disabled
=
false
;
}
}
}
;
