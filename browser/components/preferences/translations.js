const
TRANSLATIONS_PERMISSION
=
"
translations
"
;
const
ALWAYS_TRANSLATE_LANGS_PREF
=
"
browser
.
translations
.
alwaysTranslateLanguages
"
;
const
NEVER_TRANSLATE_LANGS_PREF
=
"
browser
.
translations
.
neverTranslateLanguages
"
;
let
gTranslationsPane
=
{
alwaysTranslateLanguages
:
[
]
neverTranslateLanguages
:
[
]
neverTranslateSites
:
[
]
downloadPhases
:
new
Map
(
)
supportedLanguages
:
{
}
supportedLanguageTagsNames
:
[
]
elements
:
undefined
async
init
(
)
{
if
(
!
this
.
elements
)
{
this
.
_defineLazyElements
(
document
{
downloadLanguageSection
:
"
translations
-
settings
-
download
-
section
"
alwaysTranslateMenuList
:
"
translations
-
settings
-
always
-
translate
-
list
"
neverTranslateMenuList
:
"
translations
-
settings
-
never
-
translate
-
list
"
alwaysTranslateMenuPopup
:
"
translations
-
settings
-
always
-
translate
-
popup
"
neverTranslateMenuPopup
:
"
translations
-
settings
-
never
-
translate
-
popup
"
downloadLanguageList
:
"
translations
-
settings
-
download
-
language
-
list
"
alwaysTranslateLanguageList
:
"
translations
-
settings
-
always
-
translate
-
language
-
list
"
neverTranslateLanguageList
:
"
translations
-
settings
-
never
-
translate
-
language
-
list
"
neverTranslateSiteList
:
"
translations
-
settings
-
never
-
translate
-
site
-
list
"
translationsSettingsBackButton
:
"
translations
-
settings
-
back
-
button
"
translationsSettingsHeader
:
"
translations
-
settings
-
header
"
translationsSettingsDescription
:
"
translations
-
settings
-
description
"
translateAlwaysHeader
:
"
translations
-
settings
-
always
-
translate
"
translateNeverHeader
:
"
translations
-
settings
-
never
-
translate
"
translateNeverSiteHeader
:
"
translations
-
settings
-
never
-
sites
-
header
"
translateNeverSiteDesc
:
"
translations
-
settings
-
never
-
sites
"
translateDownloadLanguagesLearnMore
:
"
download
-
languages
-
learn
-
more
"
}
)
;
}
this
.
elements
.
translationsSettingsBackButton
.
addEventListener
(
"
click
"
function
(
)
{
gotoPref
(
"
general
"
)
;
}
)
;
this
.
elements
.
alwaysTranslateMenuList
.
addEventListener
(
"
keydown
"
this
)
;
this
.
elements
.
alwaysTranslateMenuPopup
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
elements
.
neverTranslateMenuList
.
addEventListener
(
"
keydown
"
this
)
;
this
.
elements
.
neverTranslateMenuPopup
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
supportedLanguages
=
await
TranslationsParent
.
getSupportedLanguages
(
)
;
this
.
supportedLanguageTagsNames
=
TranslationsParent
.
getLanguageList
(
this
.
supportedLanguages
)
;
this
.
neverTranslateSites
=
TranslationsParent
.
listNeverTranslateSites
(
)
;
Services
.
obs
.
addObserver
(
this
"
perm
-
changed
"
)
;
Services
.
obs
.
addObserver
(
this
"
translations
:
always
-
translate
-
languages
-
changed
"
)
;
Services
.
obs
.
addObserver
(
this
"
translations
:
never
-
translate
-
languages
-
changed
"
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
this
.
removeObservers
(
)
)
;
this
.
buildLanguageDropDowns
(
)
;
this
.
elements
.
alwaysTranslateLanguageList
.
addEventListener
(
"
keydown
"
this
)
;
this
.
elements
.
neverTranslateLanguageList
.
addEventListener
(
"
keydown
"
this
)
;
this
.
elements
.
neverTranslateSiteList
.
addEventListener
(
"
keydown
"
this
)
;
this
.
populateLanguageList
(
ALWAYS_TRANSLATE_LANGS_PREF
)
;
this
.
populateLanguageList
(
NEVER_TRANSLATE_LANGS_PREF
)
;
this
.
populateSiteList
(
)
;
await
this
.
initDownloadInfo
(
)
;
this
.
buildDownloadLanguageList
(
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
translationsSettingsInit
"
{
bubbles
:
true
cancelable
:
true
}
)
)
;
}
_defineLazyElements
(
document
entries
)
{
this
.
elements
=
{
}
;
for
(
const
[
name
elementId
]
of
Object
.
entries
(
entries
)
)
{
ChromeUtils
.
defineLazyGetter
(
this
.
elements
name
(
)
=
>
{
const
element
=
document
.
getElementById
(
elementId
)
;
if
(
!
element
)
{
throw
new
Error
(
Could
not
find
"
{
name
}
"
at
"
#
{
elementId
}
"
.
)
;
}
return
element
;
}
)
;
}
}
buildLanguageDropDowns
(
)
{
const
{
fromLanguages
}
=
this
.
supportedLanguages
;
const
{
alwaysTranslateMenuPopup
neverTranslateMenuPopup
}
=
this
.
elements
;
for
(
const
{
langTag
displayName
}
of
fromLanguages
)
{
const
alwaysLang
=
document
.
createXULElement
(
"
menuitem
"
)
;
alwaysLang
.
setAttribute
(
"
value
"
langTag
)
;
alwaysLang
.
setAttribute
(
"
label
"
displayName
)
;
alwaysTranslateMenuPopup
.
appendChild
(
alwaysLang
)
;
const
neverLang
=
document
.
createXULElement
(
"
menuitem
"
)
;
neverLang
.
setAttribute
(
"
value
"
langTag
)
;
neverLang
.
setAttribute
(
"
label
"
displayName
)
;
neverTranslateMenuPopup
.
appendChild
(
neverLang
)
;
}
}
async
initDownloadInfo
(
)
{
let
downloadCount
=
0
;
let
allDownloadSize
=
0
;
this
.
downloadPhases
=
new
Map
(
)
;
for
(
const
language
of
this
.
supportedLanguageTagsNames
)
{
let
downloadSize
=
await
TranslationsParent
.
getLanguageSize
(
language
.
langTag
)
;
allDownloadSize
+
=
downloadSize
;
const
hasAllFilesForLanguage
=
await
TranslationsParent
.
hasAllFilesForLanguage
(
language
.
langTag
)
;
const
downloadPhase
=
hasAllFilesForLanguage
?
"
downloaded
"
:
"
removed
"
;
this
.
downloadPhases
.
set
(
language
.
langTag
{
downloadPhase
size
:
downloadSize
}
)
;
downloadCount
+
=
downloadPhase
=
=
=
"
downloaded
"
?
1
:
0
;
}
const
allDownloadPhase
=
downloadCount
=
=
=
this
.
supportedLanguageTagsNames
.
length
?
"
downloaded
"
:
"
removed
"
;
this
.
downloadPhases
.
set
(
"
all
"
{
downloadPhase
:
allDownloadPhase
size
:
allDownloadSize
}
)
;
}
buildDownloadLanguageList
(
)
{
const
{
downloadLanguageList
}
=
this
.
elements
;
function
createSizeElement
(
downloadSize
)
{
const
languageSize
=
document
.
createElement
(
"
span
"
)
;
languageSize
.
classList
.
add
(
"
translations
-
settings
-
download
-
size
"
)
;
const
[
size
units
]
=
DownloadUtils
.
convertByteUnits
(
downloadSize
)
;
document
.
l10n
.
setAttributes
(
languageSize
"
translations
-
settings
-
download
-
size
"
{
size
:
size
+
"
"
+
units
}
)
;
return
languageSize
;
}
const
allLangElement
=
downloadLanguageList
.
firstElementChild
;
let
allLangButton
=
allLangElement
.
querySelector
(
"
moz
-
button
"
)
;
downloadLanguageList
.
setAttribute
(
"
aria
-
activedescendant
"
allLangElement
.
id
)
;
downloadLanguageList
.
addEventListener
(
"
keydown
"
this
)
;
allLangButton
.
addEventListener
(
"
click
"
this
)
;
allLangElement
.
addEventListener
(
"
keydown
"
this
)
;
for
(
const
language
of
this
.
supportedLanguageTagsNames
)
{
const
downloadSize
=
this
.
downloadPhases
.
get
(
language
.
langTag
)
.
size
;
const
languageSize
=
createSizeElement
(
downloadSize
)
;
const
languageLabel
=
this
.
createLangLabel
(
language
.
displayName
language
.
langTag
"
translations
-
settings
-
download
-
"
+
language
.
langTag
)
;
const
isDownloaded
=
this
.
downloadPhases
.
get
(
language
.
langTag
)
.
downloadPhase
=
=
=
"
downloaded
"
;
const
mozButton
=
isDownloaded
?
this
.
createIconButton
(
[
"
translations
-
settings
-
remove
-
icon
"
"
translations
-
settings
-
manage
-
downloaded
-
language
-
button
"
]
"
translations
-
settings
-
remove
-
button
"
language
.
displayName
)
:
this
.
createIconButton
(
[
"
translations
-
settings
-
download
-
icon
"
"
translations
-
settings
-
manage
-
downloaded
-
language
-
button
"
]
"
translations
-
settings
-
download
-
button
"
language
.
displayName
)
;
const
languageElement
=
this
.
createLangElement
(
[
mozButton
languageLabel
languageSize
]
"
translations
-
settings
-
download
-
"
+
language
.
langTag
+
"
-
language
-
id
"
)
;
downloadLanguageList
.
appendChild
(
languageElement
)
;
}
if
(
this
.
downloadPhases
.
get
(
"
all
"
)
.
downloadPhase
=
=
=
"
downloaded
"
)
{
this
.
changeButtonState
(
{
langButton
:
allLangButton
langTag
:
"
all
"
langState
:
"
downloaded
"
}
)
;
}
const
allDownloadSize
=
this
.
downloadPhases
.
get
(
"
all
"
)
.
size
;
const
languageSize
=
createSizeElement
(
allDownloadSize
)
;
allLangElement
.
appendChild
(
languageSize
)
;
}
handleEvent
(
event
)
{
const
eventNode
=
event
.
target
;
const
eventNodeParent
=
eventNode
.
parentNode
;
const
eventNodeClassList
=
eventNode
.
classList
;
for
(
const
err
of
document
.
querySelectorAll
(
"
.
translations
-
settings
-
language
-
error
"
)
)
{
this
.
removeError
(
err
)
;
}
switch
(
event
.
type
)
{
case
"
keydown
"
:
this
.
handleKeys
(
event
)
;
break
;
case
"
popuphidden
"
:
if
(
eventNodeParent
.
id
=
=
=
"
translations
-
settings
-
always
-
translate
-
list
"
)
{
this
.
handleAddAlwaysTranslateLanguage
(
event
.
target
.
parentNode
.
getAttribute
(
"
value
"
)
)
;
}
else
if
(
eventNodeParent
.
id
=
=
=
"
translations
-
settings
-
never
-
translate
-
list
"
)
{
this
.
handleAddNeverTranslateLanguage
(
event
.
target
.
parentNode
.
getAttribute
(
"
value
"
)
)
;
}
break
;
case
"
click
"
:
if
(
eventNodeClassList
.
contains
(
"
translations
-
settings
-
site
-
button
"
)
)
{
this
.
handleRemoveNeverTranslateSite
(
event
)
;
}
else
if
(
eventNodeClassList
.
contains
(
"
translations
-
settings
-
language
-
never
-
button
"
)
)
{
this
.
handleRemoveNeverTranslateLanguage
(
event
)
;
}
else
if
(
eventNodeClassList
.
contains
(
"
translations
-
settings
-
language
-
always
-
button
"
)
)
{
this
.
handleRemoveAlwaysTranslateLanguage
(
event
)
;
}
else
if
(
eventNodeClassList
.
contains
(
"
translations
-
settings
-
manage
-
downloaded
-
language
-
button
"
)
)
{
if
(
eventNodeClassList
.
contains
(
"
translations
-
settings
-
download
-
icon
"
)
)
{
if
(
eventNodeParent
.
querySelector
(
"
label
"
)
.
id
=
=
=
"
translations
-
settings
-
download
-
all
-
languages
"
)
{
this
.
handleDownloadAllLanguages
(
event
)
;
}
else
{
this
.
handleDownloadLanguage
(
event
)
;
}
}
else
if
(
eventNodeClassList
.
contains
(
"
translations
-
settings
-
remove
-
icon
"
)
)
{
if
(
eventNodeParent
.
querySelector
(
"
label
"
)
.
id
=
=
=
"
translations
-
settings
-
download
-
all
-
languages
"
)
{
this
.
handleRemoveAllDownloadLanguages
(
event
)
;
}
else
{
this
.
handleRemoveDownloadLanguage
(
event
)
;
}
}
}
break
;
}
}
handleKeys
(
event
)
{
switch
(
event
.
key
)
{
case
"
Enter
"
:
if
(
event
.
target
.
id
=
=
=
"
translations
-
settings
-
always
-
translate
-
list
"
)
{
this
.
handleAddAlwaysTranslateLanguage
(
event
.
target
.
getAttribute
(
"
value
"
)
)
;
}
else
if
(
event
.
target
.
id
=
=
=
"
translations
-
settings
-
never
-
translate
-
list
"
)
{
this
.
handleAddNeverTranslateLanguage
(
event
.
target
.
getAttribute
(
"
value
"
)
)
;
}
break
;
case
"
ArrowUp
"
:
if
(
event
.
target
.
classList
.
contains
(
"
translations
-
settings
-
language
-
list
"
)
)
{
event
.
target
.
children
[
0
]
.
querySelector
(
"
moz
-
button
"
)
.
focus
(
)
;
event
.
target
.
setAttribute
(
"
aria
-
activedescendant
"
event
.
target
.
children
[
0
]
.
id
)
;
}
else
if
(
event
.
target
.
tagName
=
=
=
"
moz
-
button
"
)
{
if
(
event
.
target
.
parentNode
.
previousElementSibling
)
{
event
.
target
.
parentNode
.
previousElementSibling
.
querySelector
(
"
moz
-
button
"
)
.
focus
(
)
;
event
.
target
.
parentNode
.
parentNode
.
setAttribute
(
"
aria
-
activedescendant
"
event
.
target
.
parentNode
.
previousElementSibling
.
id
)
;
event
.
preventDefault
(
)
;
}
}
break
;
case
"
ArrowDown
"
:
if
(
event
.
target
.
classList
.
contains
(
"
translations
-
settings
-
language
-
list
"
)
)
{
event
.
target
.
children
[
0
]
.
querySelector
(
"
moz
-
button
"
)
.
focus
(
)
;
event
.
target
.
setAttribute
(
"
aria
-
activedescendant
"
event
.
target
.
children
[
0
]
.
id
)
;
}
else
if
(
event
.
target
.
tagName
=
=
=
"
moz
-
button
"
)
{
if
(
event
.
target
.
parentNode
.
nextElementSibling
)
{
event
.
target
.
parentNode
.
nextElementSibling
.
querySelector
(
"
moz
-
button
"
)
.
focus
(
)
;
event
.
target
.
parentNode
.
parentNode
.
setAttribute
(
"
aria
-
activedescendant
"
event
.
target
.
parentNode
.
nextElementSibling
.
id
)
;
event
.
preventDefault
(
)
;
}
}
break
;
}
}
async
handleAddAlwaysTranslateLanguage
(
langTag
)
{
const
{
alwaysTranslateMenuList
}
=
this
.
elements
;
TranslationsParent
.
addLangTagToPref
(
langTag
ALWAYS_TRANSLATE_LANGS_PREF
)
;
await
document
.
l10n
.
translateElements
(
[
alwaysTranslateMenuList
]
)
;
}
async
handleAddNeverTranslateLanguage
(
langTag
)
{
const
{
neverTranslateMenuList
}
=
this
.
elements
;
TranslationsParent
.
addLangTagToPref
(
langTag
NEVER_TRANSLATE_LANGS_PREF
)
;
await
document
.
l10n
.
translateElements
(
[
neverTranslateMenuList
]
)
;
}
setDifference
(
currentSet
newSet
)
{
const
added
=
newSet
.
filter
(
lang
=
>
!
currentSet
.
includes
(
lang
)
)
;
const
removed
=
currentSet
.
filter
(
lang
=
>
!
newSet
.
includes
(
lang
)
)
;
return
{
added
removed
}
;
}
populateLanguageList
(
pref
)
{
const
{
languageList
curLangTags
otherPref
prefix
}
=
pref
=
=
=
NEVER_TRANSLATE_LANGS_PREF
?
{
languageList
:
this
.
elements
.
neverTranslateLanguageList
curLangTags
:
Array
.
from
(
this
.
neverTranslateLanguages
)
otherPref
:
ALWAYS_TRANSLATE_LANGS_PREF
prefix
:
"
never
"
}
:
{
languageList
:
this
.
elements
.
alwaysTranslateLanguageList
curLangTags
:
Array
.
from
(
this
.
alwaysTranslateLanguages
)
otherPref
:
NEVER_TRANSLATE_LANGS_PREF
prefix
:
"
always
"
}
;
const
updatedLangTags
=
pref
=
=
=
NEVER_TRANSLATE_LANGS_PREF
?
Array
.
from
(
TranslationsParent
.
getNeverTranslateLanguages
(
)
)
:
Array
.
from
(
TranslationsParent
.
getAlwaysTranslateLanguages
(
)
)
;
const
{
added
removed
}
=
this
.
setDifference
(
curLangTags
updatedLangTags
)
;
for
(
const
lang
of
removed
)
{
this
.
removeTranslateLanguage
(
lang
languageList
)
;
}
for
(
const
lang
of
added
)
{
this
.
addTranslateLanguage
(
lang
languageList
prefix
)
;
TranslationsParent
.
removeLangTagFromPref
(
lang
otherPref
)
;
}
if
(
pref
=
=
=
NEVER_TRANSLATE_LANGS_PREF
)
{
this
.
neverTranslateLanguages
=
updatedLangTags
;
}
else
{
this
.
alwaysTranslateLanguages
=
updatedLangTags
;
}
}
addSite
(
site
)
{
const
{
neverTranslateSiteList
}
=
this
.
elements
;
const
languageLabel
=
this
.
createLangLabel
(
site
site
"
translations
-
settings
-
"
+
site
)
;
const
mozButton
=
this
.
createIconButton
(
[
"
translations
-
settings
-
remove
-
icon
"
"
translations
-
settings
-
site
-
button
"
]
"
translations
-
settings
-
remove
-
site
-
button
-
2
"
site
)
;
const
languageElement
=
this
.
createLangElement
(
[
mozButton
languageLabel
]
"
translations
-
settings
-
"
+
site
+
"
-
id
"
)
;
neverTranslateSiteList
.
insertBefore
(
languageElement
neverTranslateSiteList
.
firstElementChild
)
;
neverTranslateSiteList
.
setAttribute
(
"
aria
-
activedescendant
"
languageElement
.
id
)
;
if
(
neverTranslateSiteList
.
childElementCount
)
{
neverTranslateSiteList
.
parentNode
.
hidden
=
false
;
}
}
removeSite
(
site
)
{
const
{
neverTranslateSiteList
}
=
this
.
elements
;
const
langSite
=
neverTranslateSiteList
.
querySelector
(
label
[
value
=
"
{
site
}
"
]
)
;
langSite
.
parentNode
.
remove
(
)
;
if
(
!
neverTranslateSiteList
.
childElementCount
)
{
neverTranslateSiteList
.
parentNode
.
hidden
=
true
;
}
}
populateSiteList
(
)
{
const
siteList
=
TranslationsParent
.
listNeverTranslateSites
(
)
;
for
(
const
site
of
siteList
)
{
this
.
addSite
(
site
)
;
}
this
.
neverTranslateSites
=
siteList
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
perm
-
changed
"
)
{
if
(
data
=
=
=
"
cleared
"
)
{
const
{
neverTranslateSiteList
}
=
this
.
elements
;
this
.
neverTranslateSites
=
[
]
;
for
(
const
elem
of
neverTranslateSiteList
.
children
)
{
elem
.
remove
(
)
;
}
if
(
!
neverTranslateSiteList
.
childElementCount
)
{
neverTranslateSiteList
.
parentNode
.
hidden
=
true
;
}
}
else
{
const
perm
=
subject
.
QueryInterface
(
Ci
.
nsIPermission
)
;
if
(
perm
.
type
!
=
TRANSLATIONS_PERMISSION
)
{
return
;
}
if
(
data
=
=
=
"
added
"
)
{
if
(
perm
.
capability
!
=
Services
.
perms
.
DENY_ACTION
)
{
return
;
}
this
.
neverTranslateSites
=
TranslationsParent
.
listNeverTranslateSites
(
)
;
this
.
addSite
(
perm
.
principal
.
origin
)
;
}
else
if
(
data
=
=
=
"
deleted
"
)
{
this
.
neverTranslateSites
=
TranslationsParent
.
listNeverTranslateSites
(
)
;
this
.
removeSite
(
perm
.
principal
.
origin
)
;
}
}
}
else
if
(
topic
=
=
=
"
translations
:
never
-
translate
-
languages
-
changed
"
)
{
this
.
populateLanguageList
(
NEVER_TRANSLATE_LANGS_PREF
)
;
}
else
if
(
topic
=
=
=
"
translations
:
always
-
translate
-
languages
-
changed
"
)
{
this
.
populateLanguageList
(
ALWAYS_TRANSLATE_LANGS_PREF
)
;
}
}
removeObservers
(
)
{
Services
.
obs
.
removeObserver
(
this
"
perm
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
translations
:
always
-
translate
-
languages
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
translations
:
never
-
translate
-
languages
-
changed
"
)
;
}
createLangElement
(
langChildren
langId
)
{
const
languageElement
=
document
.
createElement
(
"
div
"
)
;
languageElement
.
classList
.
add
(
"
translations
-
settings
-
language
"
)
;
languageElement
.
setAttribute
(
"
role
"
"
option
"
)
;
languageElement
.
id
=
langId
;
languageElement
.
addEventListener
(
"
keydown
"
this
)
;
for
(
const
child
of
langChildren
)
{
languageElement
.
appendChild
(
child
)
;
}
return
languageElement
;
}
createIconButton
(
classNames
buttonFluentID
accessibleName
)
{
const
mozButton
=
document
.
createElement
(
"
moz
-
button
"
)
;
for
(
const
className
of
classNames
)
{
mozButton
.
classList
.
add
(
className
)
;
}
mozButton
.
setAttribute
(
"
type
"
"
ghost
icon
"
)
;
document
.
l10n
.
setAttributes
(
mozButton
buttonFluentID
{
name
:
accessibleName
}
)
;
mozButton
.
addEventListener
(
"
click
"
this
)
;
mozButton
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
return
mozButton
;
}
addTranslateLanguage
(
langTag
languageList
translatePrefix
)
{
const
languageDisplayNames
=
TranslationsParent
.
createLanguageDisplayNames
(
)
;
let
languageDisplayName
;
try
{
languageDisplayName
=
languageDisplayNames
.
of
(
langTag
)
;
}
catch
(
error
)
{
console
.
warn
(
Failed
to
retrieve
language
display
name
for
'
{
langTag
}
'
.
)
;
return
;
}
const
languageLabel
=
this
.
createLangLabel
(
languageDisplayName
langTag
"
translations
-
settings
-
language
-
"
+
translatePrefix
+
"
-
"
+
langTag
)
;
const
mozButton
=
this
.
createIconButton
(
[
"
translations
-
settings
-
remove
-
icon
"
"
translations
-
settings
-
language
-
"
+
translatePrefix
+
"
-
button
"
]
"
translations
-
settings
-
remove
-
language
-
button
-
2
"
languageDisplayName
)
;
const
languageElement
=
this
.
createLangElement
(
[
mozButton
languageLabel
]
"
translations
-
settings
-
language
-
"
+
translatePrefix
+
"
-
"
+
langTag
+
"
-
id
"
)
;
languageList
.
insertBefore
(
languageElement
languageList
.
firstElementChild
)
;
languageList
.
setAttribute
(
"
aria
-
activedescendant
"
languageElement
.
id
)
;
if
(
languageList
.
childElementCount
)
{
languageList
.
parentNode
.
hidden
=
false
;
}
}
createLangLabel
(
textContent
value
id
)
{
const
languageLabel
=
document
.
createElement
(
"
label
"
)
;
languageLabel
.
textContent
=
textContent
;
languageLabel
.
setAttribute
(
"
value
"
value
)
;
languageLabel
.
id
=
id
;
return
languageLabel
;
}
removeTranslateLanguage
(
langTag
languageList
)
{
const
langElem
=
languageList
.
querySelector
(
label
[
value
=
{
langTag
}
]
)
;
if
(
langElem
)
{
langElem
.
parentNode
.
remove
(
)
;
}
if
(
!
languageList
.
childElementCount
)
{
languageList
.
parentNode
.
hidden
=
true
;
}
}
handleRemoveAlwaysTranslateLanguage
(
event
)
{
TranslationsParent
.
removeLangTagFromPref
(
event
.
target
.
parentNode
.
querySelector
(
"
label
"
)
.
getAttribute
(
"
value
"
)
ALWAYS_TRANSLATE_LANGS_PREF
)
;
}
handleRemoveNeverTranslateLanguage
(
event
)
{
TranslationsParent
.
removeLangTagFromPref
(
event
.
target
.
parentNode
.
querySelector
(
"
label
"
)
.
getAttribute
(
"
value
"
)
NEVER_TRANSLATE_LANGS_PREF
)
;
}
handleRemoveNeverTranslateSite
(
event
)
{
TranslationsParent
.
setNeverTranslateSiteByOrigin
(
false
event
.
target
.
parentNode
.
querySelector
(
"
label
"
)
.
getAttribute
(
"
value
"
)
)
;
}
updateDownloadPhase
(
langTag
downloadPhase
)
{
if
(
!
this
.
downloadPhases
.
has
(
langTag
)
)
{
console
.
error
(
Expected
downloadPhases
entry
for
{
langTag
}
but
found
none
.
)
;
}
else
{
this
.
downloadPhases
.
get
(
langTag
)
.
downloadPhase
=
downloadPhase
;
}
}
async
reloadDownloadPhases
(
)
{
let
downloadCount
=
0
;
const
{
downloadLanguageList
}
=
this
.
elements
;
const
allLangElem
=
downloadLanguageList
.
firstElementChild
;
const
allLangButton
=
allLangElem
.
querySelector
(
"
moz
-
button
"
)
;
const
updatePromises
=
[
]
;
for
(
const
langElem
of
downloadLanguageList
.
querySelectorAll
(
"
.
translations
-
settings
-
language
:
not
(
:
first
-
child
)
"
)
)
{
const
langLabel
=
langElem
.
querySelector
(
"
label
"
)
;
const
langTag
=
langLabel
.
getAttribute
(
"
value
"
)
;
const
langButton
=
langElem
.
querySelector
(
"
moz
-
button
"
)
;
updatePromises
.
push
(
TranslationsParent
.
hasAllFilesForLanguage
(
langTag
)
.
then
(
hasAllFilesForLanguage
=
>
{
if
(
hasAllFilesForLanguage
)
{
downloadCount
+
=
1
;
this
.
changeButtonState
(
{
langButton
langTag
langState
:
"
downloaded
"
}
)
;
}
else
{
this
.
changeButtonState
(
{
langButton
langTag
langState
:
"
removed
"
}
)
;
}
langButton
.
removeAttribute
(
"
disabled
"
)
;
}
)
)
;
}
await
Promise
.
allSettled
(
updatePromises
)
;
const
allDownloaded
=
downloadCount
=
=
=
this
.
supportedLanguageTagsNames
.
length
;
if
(
allDownloaded
)
{
this
.
changeButtonState
(
{
langButton
:
allLangButton
langTag
:
"
all
"
langState
:
"
downloaded
"
}
)
;
}
else
{
this
.
changeButtonState
(
{
langButton
:
allLangButton
langTag
:
"
all
"
langState
:
"
removed
"
}
)
;
}
}
showErrorMessage
(
parentNode
fluentId
language
)
{
const
errorElement
=
document
.
createElement
(
"
moz
-
message
-
bar
"
)
;
errorElement
.
setAttribute
(
"
type
"
"
error
"
)
;
document
.
l10n
.
setAttributes
(
errorElement
fluentId
{
name
:
language
}
)
;
errorElement
.
classList
.
add
(
"
translations
-
settings
-
language
-
error
"
)
;
parentNode
.
appendChild
(
errorElement
)
;
}
removeError
(
errorNode
)
{
errorNode
?
.
remove
(
)
;
}
async
handleDownloadLanguage
(
event
)
{
let
eventButton
=
event
.
target
;
const
langTag
=
eventButton
.
parentNode
.
querySelector
(
"
label
"
)
.
getAttribute
(
"
value
"
)
;
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
langState
:
"
loading
"
}
)
;
try
{
await
TranslationsParent
.
downloadLanguageFiles
(
langTag
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
const
languageDisplayNames
=
TranslationsParent
.
createLanguageDisplayNames
(
)
;
this
.
showErrorMessage
(
eventButton
.
parentNode
"
translations
-
settings
-
language
-
download
-
error
"
languageDisplayNames
.
of
(
langTag
)
)
;
const
hasAllFilesForLanguage
=
await
TranslationsParent
.
hasAllFilesForLanguage
(
langTag
)
;
if
(
!
hasAllFilesForLanguage
)
{
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
langState
:
"
removed
"
}
)
;
return
;
}
}
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
langState
:
"
downloaded
"
}
)
;
const
haveRemovedItem
=
[
.
.
.
this
.
downloadPhases
]
.
some
(
(
[
k
v
]
)
=
>
v
.
downloadPhase
!
=
"
downloaded
"
&
&
k
!
=
"
all
"
)
;
if
(
!
haveRemovedItem
&
&
this
.
downloadPhases
.
get
(
"
all
"
)
.
downloadPhase
!
=
=
"
downloaded
"
)
{
this
.
changeButtonState
(
{
langButton
:
this
.
elements
.
downloadLanguageList
.
firstElementChild
.
querySelector
(
"
moz
-
button
"
)
langTag
:
"
all
"
langState
:
"
downloaded
"
}
)
;
}
}
async
handleRemoveDownloadLanguage
(
event
)
{
let
eventButton
=
event
.
target
;
const
langTag
=
eventButton
.
parentNode
.
querySelector
(
"
label
"
)
.
getAttribute
(
"
value
"
)
;
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
langState
:
"
loading
"
}
)
;
try
{
await
TranslationsParent
.
deleteLanguageFiles
(
langTag
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
const
languageDisplayNames
=
TranslationsParent
.
createLanguageDisplayNames
(
)
;
this
.
showErrorMessage
(
eventButton
.
parentNode
"
translations
-
settings
-
language
-
remove
-
error
"
languageDisplayNames
.
of
(
langTag
)
)
;
const
hasAllFilesForLanguage
=
await
TranslationsParent
.
hasAllFilesForLanguage
(
langTag
)
;
if
(
hasAllFilesForLanguage
)
{
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
langState
:
"
downloaded
"
}
)
;
return
;
}
}
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
langState
:
"
removed
"
}
)
;
if
(
this
.
downloadPhases
.
get
(
"
all
"
)
.
downloadPhase
=
=
=
"
downloaded
"
)
{
this
.
changeButtonState
(
{
langButton
:
this
.
elements
.
downloadLanguageList
.
firstElementChild
.
querySelector
(
"
moz
-
button
"
)
langTag
:
"
all
"
langState
:
"
removed
"
}
)
;
}
}
async
handleDownloadAllLanguages
(
event
)
{
this
.
disableDownloadButtons
(
)
;
let
eventButton
=
event
.
target
;
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
:
"
all
"
langState
:
"
loading
"
}
)
;
try
{
await
TranslationsParent
.
downloadAllFiles
(
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
await
this
.
reloadDownloadPhases
(
)
;
this
.
showErrorMessage
(
eventButton
.
parentNode
"
translations
-
settings
-
language
-
download
-
error
"
"
all
"
)
;
return
;
}
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
:
"
all
"
langState
:
"
downloaded
"
}
)
;
this
.
updateAllLanguageDownloadButtons
(
"
downloaded
"
)
;
}
async
handleRemoveAllDownloadLanguages
(
event
)
{
let
eventButton
=
event
.
target
;
this
.
disableDownloadButtons
(
)
;
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
:
"
all
"
langState
:
"
loading
"
}
)
;
try
{
await
TranslationsParent
.
deleteAllLanguageFiles
(
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
await
this
.
reloadDownloadPhases
(
)
;
this
.
showErrorMessage
(
eventButton
.
parentNode
"
translations
-
settings
-
language
-
remove
-
error
"
"
all
"
)
;
return
;
}
this
.
changeButtonState
(
{
langButton
:
eventButton
langTag
:
"
all
"
langState
:
"
removed
"
}
)
;
this
.
updateAllLanguageDownloadButtons
(
"
removed
"
)
;
}
disableDownloadButtons
(
)
{
const
{
downloadLanguageList
}
=
this
.
elements
;
for
(
const
langElem
of
downloadLanguageList
.
querySelectorAll
(
"
.
translations
-
settings
-
language
:
not
(
:
first
-
child
)
"
)
)
{
const
langButton
=
langElem
.
querySelector
(
"
moz
-
button
"
)
;
langButton
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
updateAllLanguageDownloadButtons
(
allLanguageDownloadStatus
)
{
const
{
downloadLanguageList
}
=
this
.
elements
;
for
(
const
langElem
of
downloadLanguageList
.
querySelectorAll
(
"
.
translations
-
settings
-
language
:
not
(
:
first
-
child
)
"
)
)
{
let
langButton
=
langElem
.
querySelector
(
"
moz
-
button
"
)
;
const
langLabel
=
langElem
.
querySelector
(
"
label
"
)
;
const
downloadPhase
=
this
.
downloadPhases
.
get
(
langLabel
.
getAttribute
(
"
value
"
)
)
.
downloadPhase
;
langButton
.
removeAttribute
(
"
disabled
"
)
;
if
(
downloadPhase
!
=
=
"
downloaded
"
&
&
allLanguageDownloadStatus
=
=
=
"
downloaded
"
)
{
this
.
changeButtonState
(
{
langButton
langTag
:
langLabel
.
getAttribute
(
"
value
"
)
langState
:
"
downloaded
"
}
)
;
}
else
if
(
downloadPhase
=
=
=
"
downloaded
"
&
&
allLanguageDownloadStatus
=
=
=
"
removed
"
)
{
this
.
changeButtonState
(
{
langButton
langTag
:
langLabel
.
getAttribute
(
"
value
"
)
langState
:
"
removed
"
}
)
;
}
}
}
changeButtonState
(
{
langButton
langTag
langState
}
)
{
langButton
.
classList
.
remove
(
"
translations
-
settings
-
download
-
icon
"
"
translations
-
settings
-
loading
-
icon
"
"
translations
-
settings
-
remove
-
icon
"
)
;
switch
(
langState
)
{
case
"
downloaded
"
:
langButton
.
classList
.
add
(
"
translations
-
settings
-
remove
-
icon
"
)
;
if
(
langTag
=
=
=
"
all
"
)
{
document
.
l10n
.
setAttributes
(
langButton
"
translations
-
settings
-
remove
-
all
-
button
"
)
;
}
else
{
document
.
l10n
.
setAttributes
(
langButton
"
translations
-
settings
-
remove
-
button
"
{
name
:
document
.
l10n
.
getAttributes
(
langButton
)
.
args
.
name
}
)
;
}
break
;
case
"
removed
"
:
langButton
.
classList
.
add
(
"
translations
-
settings
-
download
-
icon
"
)
;
if
(
langTag
=
=
=
"
all
"
)
{
document
.
l10n
.
setAttributes
(
langButton
"
translations
-
settings
-
download
-
all
-
button
"
)
;
}
else
{
document
.
l10n
.
setAttributes
(
langButton
"
translations
-
settings
-
download
-
button
"
{
name
:
document
.
l10n
.
getAttributes
(
langButton
)
.
args
.
name
}
)
;
}
break
;
case
"
loading
"
:
langButton
.
classList
.
add
(
"
translations
-
settings
-
loading
-
icon
"
)
;
if
(
langTag
=
=
=
"
all
"
)
{
document
.
l10n
.
setAttributes
(
langButton
"
translations
-
settings
-
loading
-
all
-
button
"
)
;
}
else
{
document
.
l10n
.
setAttributes
(
langButton
"
translations
-
settings
-
loading
-
button
"
{
name
:
document
.
l10n
.
getAttributes
(
langButton
)
.
args
.
name
}
)
;
}
break
;
}
this
.
updateDownloadPhase
(
langTag
langState
)
;
}
}
;
