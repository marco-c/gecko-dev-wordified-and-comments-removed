"
use
strict
"
;
const
ALWAYS_TRANSLATE_LANGS_PREF
=
"
browser
.
translations
.
alwaysTranslateLanguages
"
;
const
NEVER_TRANSLATE_LANGS_PREF
=
"
browser
.
translations
.
neverTranslateLanguages
"
;
const
TOPIC_TRANSLATIONS_PREF_CHANGED
=
"
translations
:
pref
-
changed
"
;
const
ALWAYS_LANGUAGE_ITEM_CLASS
=
"
translations
-
always
-
language
-
item
"
;
const
ALWAYS_LANGUAGE_REMOVE_BUTTON_CLASS
=
"
translations
-
always
-
remove
-
button
"
;
const
TranslationsSettings
=
{
initialized
:
false
initPromise
:
null
paneRenderPromise
:
null
supportedLanguages
:
null
languageDisplayNames
:
null
alwaysLanguageTags
:
new
Set
(
)
elements
:
null
async
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
paneshown
"
:
await
this
.
handlePaneShown
(
(
event
)
.
detail
?
.
category
)
;
break
;
case
"
change
"
:
if
(
event
.
target
=
=
=
this
.
elements
?
.
alwaysTranslateLanguagesSelect
)
{
await
this
.
onAlwaysLanguageChosen
(
(
event
.
target
)
.
value
)
;
}
break
;
case
"
click
"
:
{
const
target
=
(
event
.
target
)
;
const
removeButton
=
(
target
.
closest
?
.
(
.
{
ALWAYS_LANGUAGE_REMOVE_BUTTON_CLASS
}
)
)
;
if
(
removeButton
?
.
dataset
.
langTag
)
{
this
.
removeAlwaysLanguage
(
removeButton
.
dataset
.
langTag
)
;
}
break
;
}
case
"
unload
"
:
this
.
teardown
(
)
;
break
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
TOPIC_TRANSLATIONS_PREF_CHANGED
&
&
data
=
=
=
ALWAYS_TRANSLATE_LANGS_PREF
)
{
this
.
refreshAlwaysLanguages
(
)
.
catch
(
console
.
error
)
;
}
}
async
handlePaneShown
(
category
)
{
if
(
category
!
=
=
"
paneTranslations
"
)
{
return
;
}
if
(
this
.
initPromise
)
{
await
this
.
initPromise
;
await
this
.
refreshAlwaysLanguages
(
)
;
return
;
}
if
(
this
.
initialized
)
{
await
this
.
refreshAlwaysLanguages
(
)
;
return
;
}
this
.
initPromise
=
this
.
init
(
)
;
await
this
.
initPromise
;
this
.
initPromise
=
null
;
}
async
ensurePaneRendered
(
)
{
if
(
this
.
paneRenderPromise
)
{
await
this
.
paneRenderPromise
;
return
;
}
const
pane
=
(
document
.
querySelector
(
'
setting
-
pane
[
data
-
category
=
"
paneTranslations
"
]
'
)
)
;
const
group
=
(
document
.
querySelector
(
'
setting
-
group
[
groupid
=
"
moreTranslationSettings
"
]
'
)
)
;
const
promises
=
[
]
;
if
(
pane
?
.
getUpdateComplete
)
{
promises
.
push
(
pane
.
getUpdateComplete
(
)
)
;
}
if
(
group
?
.
getUpdateComplete
)
{
promises
.
push
(
group
.
getUpdateComplete
(
)
)
;
}
if
(
promises
.
length
)
{
this
.
paneRenderPromise
=
(
async
(
)
=
>
{
const
results
=
await
Promise
.
allSettled
(
promises
)
;
const
failure
=
results
.
find
(
result
=
>
result
.
status
=
=
=
"
rejected
"
)
;
if
(
failure
&
&
failure
.
reason
)
{
console
.
warn
(
"
Translations
pane
render
wait
failed
"
failure
.
reason
)
;
}
}
)
(
)
;
await
this
.
paneRenderPromise
;
}
}
async
init
(
)
{
await
this
.
ensurePaneRendered
(
)
;
this
.
cacheElements
(
)
;
if
(
!
this
.
elements
?
.
alwaysTranslateLanguagesGroup
|
|
!
this
.
elements
?
.
alwaysTranslateLanguagesSelect
|
|
!
this
.
elements
?
.
alwaysTranslateLanguagesNoneRow
)
{
return
;
}
try
{
this
.
languageDisplayNames
=
TranslationsParent
.
createLanguageDisplayNames
(
)
;
this
.
supportedLanguages
=
await
TranslationsParent
.
getSupportedLanguages
(
)
;
}
catch
(
error
)
{
console
.
error
(
"
Failed
to
initialize
translations
settings
UI
"
error
)
;
this
.
elements
.
alwaysTranslateLanguagesSelect
.
disabled
=
true
;
return
;
}
this
.
elements
.
alwaysTranslateLanguagesSelect
.
disabled
=
false
;
await
this
.
buildAlwaysSelectOptions
(
)
;
this
.
elements
.
alwaysTranslateLanguagesSelect
.
addEventListener
(
"
change
"
this
)
;
this
.
elements
.
alwaysTranslateLanguagesGroup
.
addEventListener
(
"
click
"
this
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_TRANSLATIONS_PREF_CHANGED
)
;
window
.
addEventListener
(
"
unload
"
this
)
;
await
this
.
refreshAlwaysLanguages
(
)
;
this
.
initialized
=
true
;
}
cacheElements
(
)
{
if
(
this
.
elements
)
{
return
;
}
const
elements
=
{
alwaysTranslateLanguagesGroup
:
(
document
.
getElementById
(
"
translationsAlwaysTranslateLanguagesGroup
"
)
)
alwaysTranslateLanguagesSelect
:
(
document
.
getElementById
(
"
translationsAlwaysTranslateLanguagesSelect
"
)
)
alwaysTranslateLanguagesNoneRow
:
(
document
.
getElementById
(
"
translationsAlwaysTranslateLanguagesNoneRow
"
)
)
}
;
if
(
!
elements
.
alwaysTranslateLanguagesGroup
|
|
!
elements
.
alwaysTranslateLanguagesSelect
|
|
!
elements
.
alwaysTranslateLanguagesNoneRow
)
{
return
;
}
this
.
elements
=
elements
;
}
async
onAlwaysLanguageChosen
(
langTag
)
{
if
(
!
langTag
)
{
return
;
}
TranslationsParent
.
addLangTagToPref
(
langTag
ALWAYS_TRANSLATE_LANGS_PREF
)
;
TranslationsParent
.
removeLangTagFromPref
(
langTag
NEVER_TRANSLATE_LANGS_PREF
)
;
await
this
.
resetAlwaysSelect
(
)
;
}
removeAlwaysLanguage
(
langTag
)
{
TranslationsParent
.
removeLangTagFromPref
(
langTag
ALWAYS_TRANSLATE_LANGS_PREF
)
;
}
async
resetSelect
(
select
settingId
)
{
const
setting
=
Preferences
.
getSetting
?
.
(
settingId
)
;
if
(
setting
)
{
setting
.
value
=
"
"
;
}
if
(
!
select
)
{
return
;
}
if
(
select
.
updateComplete
)
{
await
select
.
updateComplete
;
}
select
.
value
=
"
"
;
if
(
select
.
inputEl
)
{
select
.
inputEl
.
value
=
"
"
;
}
if
(
select
.
updateComplete
)
{
await
select
.
updateComplete
;
}
}
async
resetAlwaysSelect
(
)
{
await
this
.
resetSelect
(
this
.
elements
?
.
alwaysTranslateLanguagesSelect
"
translationsAlwaysTranslateLanguagesSelect
"
)
;
}
async
refreshAlwaysLanguages
(
)
{
if
(
!
this
.
elements
?
.
alwaysTranslateLanguagesGroup
)
{
return
;
}
const
langTags
=
Array
.
from
(
TranslationsParent
.
getAlwaysTranslateLanguages
?
.
(
)
?
?
[
]
)
;
if
(
this
.
alwaysLanguageTags
)
{
for
(
const
langTag
of
langTags
)
{
if
(
this
.
alwaysLanguageTags
.
has
(
langTag
)
)
{
continue
;
}
TranslationsParent
.
removeLangTagFromPref
(
langTag
NEVER_TRANSLATE_LANGS_PREF
)
;
}
}
this
.
alwaysLanguageTags
=
new
Set
(
langTags
)
;
this
.
renderAlwaysLanguages
(
langTags
)
;
await
this
.
updateAlwaysSelectOptionState
(
)
;
}
renderAlwaysLanguages
(
langTags
)
{
const
{
alwaysTranslateLanguagesGroup
alwaysTranslateLanguagesNoneRow
}
=
this
.
elements
;
for
(
const
item
of
alwaysTranslateLanguagesGroup
.
querySelectorAll
(
.
{
ALWAYS_LANGUAGE_ITEM_CLASS
}
)
)
{
item
.
remove
(
)
;
}
if
(
alwaysTranslateLanguagesNoneRow
)
{
const
hasLanguages
=
!
!
langTags
.
length
;
alwaysTranslateLanguagesNoneRow
.
hidden
=
hasLanguages
;
if
(
hasLanguages
&
&
alwaysTranslateLanguagesNoneRow
.
isConnected
)
{
alwaysTranslateLanguagesNoneRow
.
remove
(
)
;
}
else
if
(
!
hasLanguages
&
&
!
alwaysTranslateLanguagesNoneRow
.
isConnected
)
{
alwaysTranslateLanguagesGroup
.
appendChild
(
alwaysTranslateLanguagesNoneRow
)
;
}
}
const
sortedLangTags
=
[
.
.
.
langTags
]
.
sort
(
(
langTagA
langTagB
)
=
>
{
const
labelA
=
this
.
formatLanguageLabel
(
langTagA
)
?
?
langTagA
;
const
labelB
=
this
.
formatLanguageLabel
(
langTagB
)
?
?
langTagB
;
return
labelA
.
localeCompare
(
labelB
)
;
}
)
;
for
(
const
langTag
of
sortedLangTags
)
{
const
label
=
this
.
formatLanguageLabel
(
langTag
)
;
if
(
!
label
)
{
continue
;
}
const
removeButton
=
document
.
createElement
(
"
moz
-
button
"
)
;
removeButton
.
setAttribute
(
"
slot
"
"
actions
-
start
"
)
;
removeButton
.
setAttribute
(
"
type
"
"
icon
ghost
"
)
;
removeButton
.
setAttribute
(
"
iconsrc
"
"
chrome
:
/
/
global
/
skin
/
icons
/
delete
.
svg
"
)
;
removeButton
.
classList
.
add
(
ALWAYS_LANGUAGE_REMOVE_BUTTON_CLASS
)
;
removeButton
.
dataset
.
langTag
=
langTag
;
removeButton
.
setAttribute
(
"
aria
-
label
"
label
)
;
const
item
=
document
.
createElement
(
"
moz
-
box
-
item
"
)
;
item
.
classList
.
add
(
ALWAYS_LANGUAGE_ITEM_CLASS
)
;
item
.
setAttribute
(
"
label
"
label
)
;
item
.
dataset
.
langTag
=
langTag
;
item
.
appendChild
(
removeButton
)
;
if
(
alwaysTranslateLanguagesNoneRow
&
&
alwaysTranslateLanguagesNoneRow
.
parentElement
=
=
=
alwaysTranslateLanguagesGroup
)
{
alwaysTranslateLanguagesGroup
.
insertBefore
(
item
alwaysTranslateLanguagesNoneRow
)
;
}
else
{
alwaysTranslateLanguagesGroup
.
appendChild
(
item
)
;
}
}
}
formatLanguageLabel
(
langTag
)
{
try
{
return
this
.
languageDisplayNames
?
.
of
(
langTag
)
?
?
null
;
}
catch
(
error
)
{
console
.
warn
(
Failed
to
format
language
label
for
{
langTag
}
error
)
;
return
null
;
}
}
async
buildAlwaysSelectOptions
(
)
{
const
select
=
this
.
elements
?
.
alwaysTranslateLanguagesSelect
;
if
(
!
select
|
|
!
this
.
supportedLanguages
?
.
sourceLanguages
?
.
length
)
{
return
;
}
const
placeholder
=
select
.
querySelector
(
'
moz
-
option
[
value
=
"
"
]
'
)
;
for
(
const
option
of
select
.
querySelectorAll
(
"
moz
-
option
"
)
)
{
if
(
option
!
=
=
placeholder
)
{
option
.
remove
(
)
;
}
}
const
sourceLanguages
=
[
.
.
.
this
.
supportedLanguages
.
sourceLanguages
]
.
sort
(
(
a
b
)
=
>
a
.
displayName
.
localeCompare
(
b
.
displayName
)
)
;
for
(
const
{
langTag
displayName
}
of
sourceLanguages
)
{
const
option
=
document
.
createElement
(
"
moz
-
option
"
)
;
option
.
setAttribute
(
"
value
"
langTag
)
;
option
.
setAttribute
(
"
label
"
displayName
)
;
select
.
appendChild
(
option
)
;
}
await
this
.
resetAlwaysSelect
(
)
;
}
async
updateAlwaysSelectOptionState
(
)
{
const
select
=
this
.
elements
?
.
alwaysTranslateLanguagesSelect
;
if
(
!
select
)
{
return
;
}
for
(
const
option
of
select
.
querySelectorAll
(
"
moz
-
option
"
)
)
{
const
value
=
option
.
getAttribute
(
"
value
"
)
;
if
(
!
value
)
{
continue
;
}
option
.
disabled
=
this
.
alwaysLanguageTags
.
has
(
value
)
;
}
await
this
.
resetAlwaysSelect
(
)
;
}
teardown
(
)
{
try
{
Services
.
obs
.
removeObserver
(
this
TOPIC_TRANSLATIONS_PREF_CHANGED
)
;
}
catch
(
e
)
{
}
document
.
removeEventListener
(
"
paneshown
"
this
)
;
window
.
removeEventListener
(
"
unload
"
this
)
;
this
.
elements
?
.
alwaysTranslateLanguagesSelect
?
.
removeEventListener
(
"
change
"
this
)
;
this
.
elements
?
.
alwaysTranslateLanguagesGroup
?
.
removeEventListener
(
"
click
"
this
)
;
}
}
;
document
.
addEventListener
(
"
paneshown
"
TranslationsSettings
)
;
