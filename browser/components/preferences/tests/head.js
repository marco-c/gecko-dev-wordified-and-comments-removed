const
{
NimbusTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
sys
.
mjs
"
)
;
const
{
PermissionTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PermissionTestUtils
.
sys
.
mjs
"
)
;
const
{
PromptTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PromptTestUtils
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
QuickSuggestTestUtils
"
(
)
=
>
{
const
{
QuickSuggestTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
QuickSuggestTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
return
module
;
}
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ExperimentAPI
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
QuickSuggest
:
"
moz
-
src
:
/
/
/
browser
/
components
/
urlbar
/
QuickSuggest
.
sys
.
mjs
"
}
)
;
NimbusTestUtils
.
init
(
this
)
;
const
kDefaultWait
=
2000
;
function
is_element_visible
(
aElement
aMsg
)
{
isnot
(
aElement
null
"
Element
should
not
be
null
when
checking
visibility
"
)
;
ok
(
!
BrowserTestUtils
.
isHidden
(
aElement
)
aMsg
)
;
}
function
is_element_hidden
(
aElement
aMsg
)
{
isnot
(
aElement
null
"
Element
should
not
be
null
when
checking
visibility
"
)
;
ok
(
BrowserTestUtils
.
isHidden
(
aElement
)
aMsg
)
;
}
function
open_preferences
(
aCallback
)
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
preferences
"
)
;
let
newTabBrowser
=
gBrowser
.
getBrowserForTab
(
gBrowser
.
selectedTab
)
;
newTabBrowser
.
addEventListener
(
"
Initialized
"
function
(
)
{
aCallback
(
gBrowser
.
contentWindow
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
function
openAndLoadSubDialog
(
aURL
aFeatures
=
null
aParams
=
null
aClosingCallback
=
null
)
{
let
promise
=
promiseLoadSubDialog
(
aURL
)
;
content
.
gSubDialog
.
open
(
aURL
{
features
:
aFeatures
closingCallback
:
aClosingCallback
}
aParams
)
;
return
promise
;
}
function
promiseLoadSubDialog
(
aURL
)
{
return
new
Promise
(
resolve
=
>
{
content
.
gSubDialog
.
_dialogStack
.
addEventListener
(
"
dialogopen
"
function
dialogopen
(
aEvent
)
{
if
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
.
location
=
=
"
about
:
blank
"
)
{
return
;
}
content
.
gSubDialog
.
_dialogStack
.
removeEventListener
(
"
dialogopen
"
dialogopen
)
;
is
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
.
location
.
toString
(
)
aURL
"
Check
the
proper
URL
is
loaded
"
)
;
is_element_visible
(
aEvent
.
detail
.
dialog
.
_overlay
"
Overlay
is
visible
"
)
;
let
expectedStyleSheetURLs
=
aEvent
.
detail
.
dialog
.
_injectedStyleSheets
.
slice
(
0
)
;
for
(
let
styleSheet
of
aEvent
.
detail
.
dialog
.
_frame
.
contentDocument
.
styleSheets
)
{
let
i
=
expectedStyleSheetURLs
.
indexOf
(
styleSheet
.
href
)
;
if
(
i
>
=
0
)
{
info
(
"
found
"
+
styleSheet
.
href
)
;
expectedStyleSheetURLs
.
splice
(
i
1
)
;
}
}
is
(
expectedStyleSheetURLs
.
length
0
"
All
expectedStyleSheetURLs
should
have
been
found
"
)
;
executeSoon
(
(
)
=
>
resolve
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
)
)
;
}
)
;
}
)
;
}
async
function
openPreferencesViaOpenPreferencesAPI
(
aPane
aOptions
)
{
let
finalPaneEvent
=
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
enabled
"
)
?
"
sync
-
pane
-
loaded
"
:
"
privacy
-
pane
-
loaded
"
;
let
finalPrefPaneLoaded
=
TestUtils
.
topicObserved
(
finalPaneEvent
(
)
=
>
true
)
;
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
{
allowInheritPrincipal
:
true
}
)
;
openPreferences
(
aPane
aOptions
)
;
let
newTabBrowser
=
gBrowser
.
selectedBrowser
;
if
(
!
newTabBrowser
.
contentWindow
)
{
await
BrowserTestUtils
.
waitForEvent
(
newTabBrowser
"
Initialized
"
true
)
;
if
(
newTabBrowser
.
contentDocument
.
readyState
!
=
"
complete
"
)
{
await
BrowserTestUtils
.
waitForEvent
(
newTabBrowser
.
contentWindow
"
load
"
)
;
}
await
finalPrefPaneLoaded
;
}
let
win
=
gBrowser
.
contentWindow
;
let
selectedPane
=
win
.
history
.
state
;
if
(
!
aOptions
|
|
!
aOptions
.
leaveOpen
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
return
{
selectedPane
}
;
}
async
function
runSearchInput
(
input
)
{
let
searchInput
=
gBrowser
.
contentDocument
.
getElementById
(
"
searchInput
"
)
;
searchInput
.
focus
(
)
;
let
searchCompletedPromise
=
BrowserTestUtils
.
waitForEvent
(
gBrowser
.
contentWindow
"
PreferencesSearchCompleted
"
evt
=
>
evt
.
detail
=
=
input
)
;
EventUtils
.
sendString
(
input
)
;
await
searchCompletedPromise
;
}
async
function
evaluateSearchResults
(
keyword
searchResults
includeExperiments
=
false
)
{
searchResults
=
Array
.
isArray
(
searchResults
)
?
searchResults
:
[
searchResults
]
;
searchResults
.
push
(
"
header
-
searchResults
"
)
;
await
runSearchInput
(
keyword
)
;
let
mainPrefTag
=
gBrowser
.
contentDocument
.
getElementById
(
"
mainPrefPane
"
)
;
for
(
let
i
=
0
;
i
<
mainPrefTag
.
childElementCount
;
i
+
+
)
{
let
child
=
mainPrefTag
.
children
[
i
]
;
if
(
!
includeExperiments
&
&
child
.
id
?
.
startsWith
(
"
pane
-
experimental
"
)
)
{
continue
;
}
if
(
searchResults
.
includes
(
child
.
id
)
)
{
is_element_visible
(
child
{
child
.
id
}
should
be
in
search
results
)
;
}
else
if
(
child
.
id
)
{
is_element_hidden
(
child
{
child
.
id
}
should
not
be
in
search
results
)
;
}
}
}
function
waitForMutation
(
target
opts
cb
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
new
MutationObserver
(
(
)
=
>
{
if
(
!
cb
|
|
cb
(
target
)
)
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
}
)
;
observer
.
observe
(
target
opts
)
;
}
)
;
}
function
createObserveAllPromise
(
observances
)
{
return
new
Promise
(
resolve
=
>
{
let
permObserver
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
!
=
"
perm
-
changed
"
)
{
return
;
}
if
(
!
observances
.
length
)
{
return
;
}
let
permission
=
aSubject
.
QueryInterface
(
Ci
.
nsIPermission
)
;
let
expected
=
observances
.
shift
(
)
;
info
(
observed
perm
-
changed
for
{
permission
.
principal
.
origin
}
(
remaining
{
observances
.
length
}
)
)
;
is
(
aData
expected
.
data
"
type
of
message
should
be
the
same
"
)
;
for
(
let
prop
of
[
"
type
"
"
capability
"
"
expireType
"
]
)
{
if
(
expected
[
prop
]
)
{
is
(
permission
[
prop
]
expected
[
prop
]
property
:
"
{
prop
}
"
should
be
equal
(
{
permission
.
principal
.
origin
}
)
)
;
}
}
if
(
expected
.
origin
)
{
is
(
permission
.
principal
.
origin
expected
.
origin
property
:
"
origin
"
should
be
equal
(
{
permission
.
principal
.
origin
}
)
)
;
}
if
(
!
observances
.
length
)
{
Services
.
obs
.
removeObserver
(
permObserver
"
perm
-
changed
"
)
;
executeSoon
(
resolve
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
permObserver
"
perm
-
changed
"
)
;
}
)
;
}
async
function
waitForAndAssertPrefState
(
pref
expectedValue
message
)
{
await
TestUtils
.
waitForPrefChange
(
pref
value
=
>
{
if
(
value
!
=
expectedValue
)
{
return
false
;
}
is
(
value
expectedValue
message
)
;
return
true
;
}
)
;
}
async
function
mockDefaultFxAInstance
(
)
{
const
defaultPrefs
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
const
userPrefs
=
Services
.
prefs
.
getBranch
(
"
"
)
;
const
realAuth
=
defaultPrefs
.
getCharPref
(
"
identity
.
fxaccounts
.
auth
.
uri
"
)
;
const
realRoot
=
defaultPrefs
.
getCharPref
(
"
identity
.
fxaccounts
.
remote
.
root
"
)
;
const
mockAuth
=
userPrefs
.
getCharPref
(
"
identity
.
fxaccounts
.
auth
.
uri
"
)
;
const
mockRoot
=
userPrefs
.
getCharPref
(
"
identity
.
fxaccounts
.
remote
.
root
"
)
;
const
mock
=
(
)
=
>
{
defaultPrefs
.
setCharPref
(
"
identity
.
fxaccounts
.
auth
.
uri
"
mockAuth
)
;
defaultPrefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
root
"
mockRoot
)
;
userPrefs
.
clearUserPref
(
"
identity
.
fxaccounts
.
auth
.
uri
"
)
;
userPrefs
.
clearUserPref
(
"
identity
.
fxaccounts
.
remote
.
root
"
)
;
}
;
const
unmock
=
(
)
=
>
{
defaultPrefs
.
setCharPref
(
"
identity
.
fxaccounts
.
auth
.
uri
"
realAuth
)
;
defaultPrefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
root
"
realRoot
)
;
userPrefs
.
setCharPref
(
"
identity
.
fxaccounts
.
auth
.
uri
"
mockAuth
)
;
userPrefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
root
"
mockRoot
)
;
}
;
mock
(
)
;
registerCleanupFunction
(
unmock
)
;
return
{
mock
unmock
}
;
}
async
function
doSuggestVisibilityTest
(
{
initialSuggestEnabled
initialExpected
nimbusVariables
newExpected
=
initialExpected
pane
=
"
search
"
}
)
{
info
(
"
Running
Suggest
visibility
test
:
"
+
JSON
.
stringify
(
{
initialSuggestEnabled
initialExpected
nimbusVariables
newExpected
}
null
2
)
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
quicksuggest
.
enabled
"
initialSuggestEnabled
]
]
}
)
;
await
openPreferencesViaOpenPreferencesAPI
(
pane
{
leaveOpen
:
true
}
)
;
await
assertSuggestVisibility
(
initialExpected
)
;
await
QuickSuggestTestUtils
.
withExperiment
(
{
valueOverrides
:
nimbusVariables
callback
:
async
(
)
=
>
{
await
assertSuggestVisibility
(
newExpected
)
;
gBrowser
.
removeCurrentTab
(
)
;
await
openPreferencesViaOpenPreferencesAPI
(
pane
{
leaveOpen
:
true
}
)
;
await
assertSuggestVisibility
(
newExpected
)
;
}
}
)
;
gBrowser
.
removeCurrentTab
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
async
function
assertSuggestVisibility
(
expectedByElementId
)
{
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
for
(
let
[
elementId
{
isVisible
l10nId
}
]
of
Object
.
entries
(
expectedByElementId
)
)
{
let
element
=
doc
.
getElementById
(
elementId
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BrowserTestUtils
.
isVisible
(
element
)
=
=
isVisible
"
Waiting
for
element
visbility
:
"
+
JSON
.
stringify
(
{
elementId
isVisible
}
)
)
;
Assert
.
strictEqual
(
BrowserTestUtils
.
isVisible
(
element
)
isVisible
"
Element
should
have
expected
visibility
:
"
+
elementId
)
;
if
(
l10nId
)
{
Assert
.
equal
(
element
.
dataset
.
l10nId
l10nId
"
The
l10n
ID
should
be
correct
for
element
:
"
+
elementId
)
;
}
}
}
const
DEFAULT_LABS_RECIPES
=
[
NimbusTestUtils
.
factories
.
recipe
(
"
nimbus
-
qa
-
1
"
{
targeting
:
"
true
"
isRollout
:
true
isFirefoxLabsOptIn
:
true
firefoxLabsTitle
:
"
experimental
-
features
-
ime
-
search
"
firefoxLabsDescription
:
"
experimental
-
features
-
ime
-
search
-
description
"
firefoxLabsDescriptionLinks
:
null
firefoxLabsGroup
:
"
experimental
-
features
-
group
-
customize
-
browsing
"
requiresRestart
:
false
branches
:
[
{
slug
:
"
control
"
ratio
:
1
features
:
[
{
featureId
:
"
nimbus
-
qa
-
1
"
value
:
{
value
:
"
recipe
-
value
-
1
"
}
}
]
}
]
}
)
NimbusTestUtils
.
factories
.
recipe
(
"
nimbus
-
qa
-
2
"
{
targeting
:
"
true
"
isRollout
:
true
isFirefoxLabsOptIn
:
true
firefoxLabsTitle
:
"
experimental
-
features
-
media
-
jxl
"
firefoxLabsDescription
:
"
experimental
-
features
-
media
-
jxl
-
description
"
firefoxLabsDescriptionLinks
:
{
bugzilla
:
"
https
:
/
/
example
.
com
"
}
firefoxLabsGroup
:
"
experimental
-
features
-
group
-
webpage
-
display
"
branches
:
[
{
slug
:
"
control
"
ratio
:
1
features
:
[
{
featureId
:
"
nimbus
-
qa
-
2
"
value
:
{
value
:
"
recipe
-
value
-
2
"
}
}
]
}
]
}
)
NimbusTestUtils
.
factories
.
recipe
(
"
targeting
-
false
"
{
targeting
:
"
false
"
isRollout
:
true
isFirefoxLabsOptIn
:
true
firefoxLabsTitle
:
"
experimental
-
features
-
ime
-
search
"
firefoxLabsDescription
:
"
experimental
-
features
-
ime
-
search
-
description
"
firefoxLabsDescriptionLinks
:
null
firefoxLabsGroup
:
"
experimental
-
features
-
group
-
developer
-
tools
"
requiresRestart
:
false
}
)
NimbusTestUtils
.
factories
.
recipe
(
"
bucketing
-
false
"
{
bucketConfig
:
{
.
.
.
NimbusTestUtils
.
factories
.
recipe
.
bucketConfig
count
:
0
}
isRollout
:
true
targeting
:
"
true
"
isFirefoxLabsOptIn
:
true
firefoxLabsTitle
:
"
experimental
-
features
-
ime
-
search
"
firefoxLabsDescription
:
"
experimental
-
features
-
ime
-
search
-
description
"
firefoxLabsDescriptionLinks
:
null
firefoxLabsGroup
:
"
experimental
-
features
-
group
-
developer
-
tools
"
requiresRestart
:
false
}
)
]
;
async
function
setupLabsTest
(
recipes
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
app
.
normandy
.
run_interval_seconds
"
0
]
[
"
app
.
shield
.
optoutstudies
.
enabled
"
true
]
[
"
datareporting
.
healthreport
.
uploadEnabled
"
true
]
[
"
messaging
-
system
.
log
"
"
debug
"
]
]
clear
:
[
[
"
browser
.
preferences
.
experimental
"
]
[
"
browser
.
preferences
.
experimental
.
hidden
"
]
]
}
)
;
await
ExperimentAPI
.
ready
(
)
;
await
ExperimentAPI
.
_rsLoader
.
finishedUpdating
(
)
;
await
ExperimentAPI
.
_rsLoader
.
remoteSettingsClients
.
experiments
.
db
.
importChanges
(
{
}
Date
.
now
(
)
recipes
?
?
DEFAULT_LABS_RECIPES
{
clear
:
true
}
)
;
await
ExperimentAPI
.
_rsLoader
.
remoteSettingsClients
.
secureExperiments
.
db
.
importChanges
(
{
}
Date
.
now
(
)
[
]
{
clear
:
true
}
)
;
await
ExperimentAPI
.
_rsLoader
.
updateRecipes
(
"
test
"
)
;
return
async
function
cleanup
(
)
{
await
NimbusTestUtils
.
removeStore
(
ExperimentAPI
.
manager
.
store
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
;
}
function
promiseNimbusStoreUpdate
(
wantedSlug
wantedActive
)
{
const
deferred
=
Promise
.
withResolvers
(
)
;
const
listener
=
(
_event
{
slug
active
}
)
=
>
{
info
(
promiseNimbusStoreUpdate
:
received
update
for
{
slug
}
active
=
{
active
}
)
;
if
(
slug
=
=
=
wantedSlug
&
&
active
=
=
=
wantedActive
)
{
ExperimentAPI
.
_manager
.
store
.
off
(
"
update
"
listener
)
;
deferred
.
resolve
(
)
;
}
}
;
ExperimentAPI
.
_manager
.
store
.
on
(
"
update
"
listener
)
;
return
deferred
.
promise
;
}
function
enrollByClick
(
el
wantedActive
)
{
const
slug
=
el
.
dataset
.
nimbusSlug
;
info
(
Enrolling
in
{
slug
}
:
{
el
.
dataset
.
nimbusBranchSlug
}
.
.
.
)
;
const
promise
=
promiseNimbusStoreUpdate
(
slug
wantedActive
)
;
EventUtils
.
synthesizeMouseAtCenter
(
el
.
inputEl
{
}
gBrowser
.
contentWindow
)
;
return
promise
;
}
async
function
clickCheckboxAndWaitForPrefChange
(
doc
checkboxId
prefName
expectedValue
)
{
let
checkbox
=
doc
.
getElementById
(
checkboxId
)
;
let
prefChange
=
waitForAndAssertPrefState
(
prefName
expectedValue
)
;
checkbox
.
click
(
)
;
await
prefChange
;
is
(
checkbox
.
checked
expectedValue
The
checkbox
#
{
checkboxId
}
should
be
in
the
expected
state
after
being
clicked
.
)
;
return
checkbox
;
}
async
function
clickCheckboxWithConfirmDialog
(
doc
checkboxId
prefName
expectedValue
buttonNumClick
)
{
let
checkbox
=
doc
.
getElementById
(
checkboxId
)
;
let
promptPromise
=
PromptTestUtils
.
handleNextPrompt
(
gBrowser
.
selectedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
}
)
;
let
prefChangePromise
=
null
;
if
(
buttonNumClick
=
=
=
1
)
{
prefChangePromise
=
waitForAndAssertPrefState
(
prefName
expectedValue
)
;
}
checkbox
.
click
(
)
;
await
promptPromise
;
if
(
prefChangePromise
)
{
await
prefChangePromise
;
}
is
(
checkbox
.
checked
expectedValue
The
checkbox
#
{
checkboxId
}
should
be
in
the
expected
state
after
dialog
interaction
.
)
;
return
checkbox
;
}
async
function
selectHistoryMode
(
win
value
)
{
let
historyMode
=
win
.
document
.
getElementById
(
"
historyMode
"
)
.
inputEl
;
let
optionIndexStr
=
Array
.
from
(
historyMode
.
children
)
.
findIndex
(
option
=
>
option
.
value
=
=
value
)
?
.
toString
(
)
;
if
(
optionIndexStr
=
=
null
)
{
throw
new
Error
(
"
Could
not
find
history
mode
option
item
for
value
:
"
+
value
)
;
}
historyMode
.
scrollIntoView
(
)
;
let
popupShownPromise
=
BrowserTestUtils
.
waitForSelectPopupShown
(
window
)
;
await
EventUtils
.
synthesizeMouseAtCenter
(
historyMode
{
}
historyMode
.
ownerGlobal
)
;
let
popup
=
await
popupShownPromise
;
let
popupItems
=
Array
.
from
(
popup
.
children
)
;
let
targetItem
=
popupItems
.
find
(
item
=
>
item
.
value
=
=
optionIndexStr
)
;
if
(
!
targetItem
)
{
throw
new
Error
(
"
Could
not
find
history
mode
popup
item
for
value
:
"
+
value
)
;
}
let
popupHiddenPromise
=
BrowserTestUtils
.
waitForPopupEvent
(
popup
"
hidden
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
targetItem
{
}
targetItem
.
ownerGlobal
)
;
await
popupHiddenPromise
;
}
async
function
selectRedesignedHistoryMode
(
win
value
)
{
let
historyMode
=
win
.
document
.
querySelector
(
"
setting
-
group
[
groupid
=
'
history2
'
]
#
historyMode
"
)
;
let
updated
=
waitForSettingControlChange
(
historyMode
)
;
let
optionItems
=
Array
.
from
(
historyMode
.
children
)
;
let
targetItem
=
optionItems
.
find
(
option
=
>
option
.
value
=
=
value
)
;
if
(
!
targetItem
)
{
throw
new
Error
(
"
Could
not
find
history
mode
popup
item
for
value
:
"
+
value
)
;
}
if
(
historyMode
.
value
=
=
value
)
{
return
;
}
targetItem
.
click
(
)
;
await
updated
;
}
async
function
updateCheckBoxElement
(
checkbox
value
)
{
ok
(
checkbox
"
the
"
+
checkbox
.
id
+
"
checkbox
should
exist
"
)
;
is_element_visible
(
checkbox
"
the
"
+
checkbox
.
id
+
"
checkbox
should
be
visible
"
)
;
if
(
checkbox
.
checked
=
=
=
value
)
{
return
;
}
checkbox
.
scrollIntoView
(
)
;
await
EventUtils
.
synthesizeMouseAtCenter
(
checkbox
{
}
checkbox
.
ownerGlobal
)
;
}
async
function
updateCheckBox
(
win
id
value
)
{
let
checkbox
=
win
.
document
.
getElementById
(
id
)
;
ok
(
checkbox
"
the
"
+
id
+
"
checkbox
should
exist
"
)
;
is_element_visible
(
checkbox
"
the
"
+
id
+
"
checkbox
should
be
visible
"
)
;
if
(
checkbox
.
checked
=
=
=
value
)
{
return
;
}
checkbox
.
scrollIntoView
(
)
;
await
EventUtils
.
synthesizeMouseAtCenter
(
checkbox
{
}
checkbox
.
ownerGlobal
)
;
}
function
waitForSettingChange
(
setting
)
{
return
new
Promise
(
resolve
=
>
{
setting
.
on
(
"
change
"
function
handler
(
)
{
setting
.
off
(
"
change
"
handler
)
;
resolve
(
)
;
}
)
;
}
)
;
}
async
function
waitForSettingControlChange
(
control
)
{
await
waitForSettingChange
(
control
.
setting
)
;
await
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
}
async
function
waitForPaneChange
(
paneId
)
{
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
event
=
await
BrowserTestUtils
.
waitForEvent
(
doc
"
paneshown
"
)
;
let
expectId
=
paneId
.
startsWith
(
"
pane
"
)
?
paneId
:
pane
{
paneId
[
0
]
.
toUpperCase
(
)
}
{
paneId
.
substring
(
1
)
}
;
is
(
event
.
detail
.
category
expectId
"
Loaded
the
correct
pane
"
)
;
}
function
getControl
(
doc
id
)
{
let
control
=
doc
.
getElementById
(
id
)
;
ok
(
control
Control
{
id
}
exists
)
;
return
control
;
}
function
synthesizeClick
(
el
)
{
let
target
=
el
.
buttonEl
?
?
el
.
inputEl
?
?
el
;
target
.
scrollIntoView
(
{
block
:
"
center
"
}
)
;
EventUtils
.
synthesizeMouseAtCenter
(
target
{
}
target
.
ownerGlobal
)
;
}
function
getControlWrapper
(
doc
id
)
{
return
getControl
(
doc
id
)
.
closest
(
"
setting
-
control
"
)
;
}
async
function
openEtpPage
(
)
{
await
openPreferencesViaOpenPreferencesAPI
(
"
etp
"
{
leaveOpen
:
true
}
)
;
let
doc
=
gBrowser
.
contentDocument
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
doc
.
getElementById
(
"
contentBlockingCategoryRadioGroup
"
)
"
Wait
for
the
ETP
advanced
radio
group
to
render
"
)
;
return
{
win
:
gBrowser
.
contentWindow
doc
tab
:
gBrowser
.
selectedTab
}
;
}
async
function
openEtpCustomizePage
(
)
{
await
openPreferencesViaOpenPreferencesAPI
(
"
etpCustomize
"
{
leaveOpen
:
true
}
)
;
let
doc
=
gBrowser
.
contentDocument
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
doc
.
getElementById
(
"
etpAllowListBaselineEnabledCustom
"
)
"
Wait
for
the
ETP
customize
controls
to
render
"
)
;
return
{
win
:
gBrowser
.
contentWindow
doc
}
;
}
async
function
changeMozSelectValue
(
selectEl
value
)
{
let
control
=
selectEl
.
control
;
let
changePromise
=
waitForSettingControlChange
(
control
)
;
selectEl
.
value
=
value
;
selectEl
.
dispatchEvent
(
new
Event
(
"
change
"
{
bubbles
:
true
}
)
)
;
await
changePromise
;
}
async
function
clickEtpBaselineCheckboxWithConfirm
(
doc
controlId
prefName
expectedValue
buttonNumClick
)
{
let
checkbox
=
getControl
(
doc
controlId
)
;
let
promptPromise
=
PromptTestUtils
.
handleNextPrompt
(
gBrowser
.
selectedBrowser
{
modalType
:
Services
.
prompt
.
MODAL_TYPE_CONTENT
}
{
buttonNumClick
}
)
;
let
prefChangePromise
=
null
;
if
(
buttonNumClick
=
=
=
1
)
{
prefChangePromise
=
waitForAndAssertPrefState
(
prefName
expectedValue
{
prefName
}
updated
)
;
}
synthesizeClick
(
checkbox
)
;
await
promptPromise
;
if
(
prefChangePromise
)
{
await
prefChangePromise
;
}
is
(
checkbox
.
checked
expectedValue
Checkbox
{
controlId
}
should
be
{
expectedValue
}
)
;
return
checkbox
;
}
