"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
UrlbarProviderQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarProviderQuickSuggest
.
sys
.
mjs
"
UrlbarQuickSuggest
:
"
resource
:
/
/
/
modules
/
UrlbarQuickSuggest
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
QuickSuggestTestUtils
"
(
)
=
>
{
const
{
QuickSuggestTestUtils
:
module
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
QuickSuggestTestUtils
.
sys
.
mjs
"
)
;
module
.
init
(
this
)
;
registerCleanupFunction
(
(
)
=
>
module
.
uninit
(
)
)
;
return
module
;
}
)
;
const
CONTAINER_ID
=
"
firefoxSuggestContainer
"
;
const
NONSPONSORED_CHECKBOX_ID
=
"
firefoxSuggestNonsponsoredToggle
"
;
const
SPONSORED_CHECKBOX_ID
=
"
firefoxSuggestSponsoredToggle
"
;
const
DATA_COLLECTION_CHECKBOX_ID
=
"
firefoxSuggestDataCollectionToggle
"
;
const
INFO_BOX_ID
=
"
firefoxSuggestInfoBox
"
;
const
INFO_TEXT_ID
=
"
firefoxSuggestInfoText
"
;
const
LEARN_MORE_CLASS
=
"
firefoxSuggestLearnMore
"
;
const
BEST_MATCH_CONTAINER_ID
=
"
firefoxSuggestBestMatchContainer
"
;
const
BEST_MATCH_CHECKBOX_ID
=
"
firefoxSuggestBestMatch
"
;
const
EXPECTED_L10N_IDS
=
{
locationBarGroupHeader
:
{
enabled
:
"
addressbar
-
header
-
firefox
-
suggest
"
disabled
:
"
addressbar
-
header
"
}
locationBarSuggestionLabel
:
{
enabled
:
"
addressbar
-
suggest
-
firefox
-
suggest
"
disabled
:
"
addressbar
-
suggest
"
}
}
;
requestLongerTimeout
(
10
)
;
add_task
(
async
function
historyToOffline
(
)
{
await
doVisibilityTest
(
{
initialScenario
:
"
history
"
initialExpectedVisibility
:
false
newScenario
:
"
offline
"
newExpectedVisibility
:
true
}
)
;
}
)
;
add_task
(
async
function
historyToOnline
(
)
{
await
doVisibilityTest
(
{
initialScenario
:
"
history
"
initialExpectedVisibility
:
false
newScenario
:
"
online
"
newExpectedVisibility
:
true
}
)
;
}
)
;
add_task
(
async
function
offlineToHistory
(
)
{
await
doVisibilityTest
(
{
initialScenario
:
"
offline
"
initialExpectedVisibility
:
true
newScenario
:
"
history
"
newExpectedVisibility
:
false
}
)
;
}
)
;
add_task
(
async
function
offlineToOnline
(
)
{
await
doVisibilityTest
(
{
initialScenario
:
"
offline
"
initialExpectedVisibility
:
true
newScenario
:
"
online
"
newExpectedVisibility
:
true
}
)
;
}
)
;
add_task
(
async
function
onlineToHistory
(
)
{
await
doVisibilityTest
(
{
initialScenario
:
"
online
"
initialExpectedVisibility
:
true
newScenario
:
"
history
"
newExpectedVisibility
:
false
}
)
;
}
)
;
add_task
(
async
function
onlineToOffline
(
)
{
await
doVisibilityTest
(
{
initialScenario
:
"
online
"
initialExpectedVisibility
:
true
newScenario
:
"
offline
"
newExpectedVisibility
:
true
}
)
;
}
)
;
async
function
doVisibilityTest
(
{
initialScenario
initialExpectedVisibility
newScenario
newExpectedVisibility
}
)
{
info
(
"
Running
visibility
test
:
"
+
JSON
.
stringify
(
{
initialScenario
initialExpectedVisibility
newScenario
newExpectedVisibility
}
null
2
)
)
;
await
QuickSuggestTestUtils
.
setScenario
(
initialScenario
)
;
Assert
.
equal
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
enabled
"
)
initialExpectedVisibility
quicksuggest
.
enabled
is
correct
after
setting
initial
scenario
initialExpectedVisibility
=
{
initialExpectedVisibility
}
)
;
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
container
=
doc
.
getElementById
(
CONTAINER_ID
)
;
Assert
.
equal
(
BrowserTestUtils
.
is_visible
(
container
)
initialExpectedVisibility
The
container
has
the
expected
initial
visibility
initialExpectedVisibility
=
{
initialExpectedVisibility
}
)
;
for
(
let
[
id
{
enabled
disabled
}
]
of
Object
.
entries
(
EXPECTED_L10N_IDS
)
)
{
Assert
.
equal
(
doc
.
getElementById
(
id
)
.
dataset
.
l10nId
initialExpectedVisibility
?
enabled
:
disabled
Initial
l10n
ID
for
element
with
ID
{
id
}
initialExpectedVisibility
=
{
initialExpectedVisibility
}
)
;
}
await
QuickSuggestTestUtils
.
setScenario
(
newScenario
)
;
Assert
.
equal
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
enabled
"
)
newExpectedVisibility
quicksuggest
.
enabled
is
correct
after
setting
new
scenario
newExpectedVisibility
=
{
newExpectedVisibility
}
)
;
Assert
.
equal
(
BrowserTestUtils
.
is_visible
(
container
)
newExpectedVisibility
The
container
has
the
expected
visibility
after
setting
new
scenario
newExpectedVisibility
=
{
newExpectedVisibility
}
)
;
for
(
let
[
id
{
enabled
disabled
}
]
of
Object
.
entries
(
EXPECTED_L10N_IDS
)
)
{
Assert
.
equal
(
doc
.
getElementById
(
id
)
.
dataset
.
l10nId
newExpectedVisibility
?
enabled
:
disabled
New
l10n
ID
for
element
with
ID
{
id
}
newExpectedVisibility
=
{
newExpectedVisibility
}
)
;
}
gBrowser
.
removeCurrentTab
(
)
;
await
QuickSuggestTestUtils
.
setScenario
(
null
)
;
}
add_task
(
async
function
togglesAndInfoBox
(
)
{
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
true
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
true
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
true
[
SPONSORED_CHECKBOX_ID
]
:
true
[
DATA_COLLECTION_CHECKBOX_ID
]
:
true
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
all
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
true
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
false
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
true
[
SPONSORED_CHECKBOX_ID
]
:
true
[
DATA_COLLECTION_CHECKBOX_ID
]
:
false
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
nonsponsored
-
sponsored
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
true
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
false
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
true
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
true
[
SPONSORED_CHECKBOX_ID
]
:
false
[
DATA_COLLECTION_CHECKBOX_ID
]
:
true
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
nonsponsored
-
data
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
true
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
false
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
false
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
true
[
SPONSORED_CHECKBOX_ID
]
:
false
[
DATA_COLLECTION_CHECKBOX_ID
]
:
false
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
nonsponsored
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
false
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
true
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
false
[
SPONSORED_CHECKBOX_ID
]
:
true
[
DATA_COLLECTION_CHECKBOX_ID
]
:
true
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
sponsored
-
data
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
false
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
false
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
false
[
SPONSORED_CHECKBOX_ID
]
:
true
[
DATA_COLLECTION_CHECKBOX_ID
]
:
false
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
sponsored
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
false
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
false
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
true
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
false
[
SPONSORED_CHECKBOX_ID
]
:
false
[
DATA_COLLECTION_CHECKBOX_ID
]
:
true
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
data
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
false
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
false
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
false
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
false
[
SPONSORED_CHECKBOX_ID
]
:
false
[
DATA_COLLECTION_CHECKBOX_ID
]
:
false
}
)
;
await
assertInfoBox
(
null
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
add_task
(
async
function
clickToggles
(
)
{
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
addressBarSection
=
doc
.
getElementById
(
"
locationBarGroup
"
)
;
addressBarSection
.
scrollIntoView
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
true
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
true
]
]
}
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
true
[
SPONSORED_CHECKBOX_ID
]
:
true
[
DATA_COLLECTION_CHECKBOX_ID
]
:
true
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
all
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
"
+
NONSPONSORED_CHECKBOX_ID
{
}
gBrowser
.
selectedBrowser
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
)
"
suggest
.
quicksuggest
.
nonsponsored
is
false
after
clicking
non
-
sponsored
toggle
"
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
false
[
SPONSORED_CHECKBOX_ID
]
:
true
[
DATA_COLLECTION_CHECKBOX_ID
]
:
true
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
sponsored
-
data
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
"
+
SPONSORED_CHECKBOX_ID
{
}
gBrowser
.
selectedBrowser
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
)
"
suggest
.
quicksuggest
.
nonsponsored
remains
false
after
clicking
sponsored
toggle
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
)
"
suggest
.
quicksuggest
.
sponsored
is
false
after
clicking
sponsored
toggle
"
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
false
[
SPONSORED_CHECKBOX_ID
]
:
false
[
DATA_COLLECTION_CHECKBOX_ID
]
:
true
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
data
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
"
+
DATA_COLLECTION_CHECKBOX_ID
{
}
gBrowser
.
selectedBrowser
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
)
"
suggest
.
quicksuggest
.
nonsponsored
remains
false
after
clicking
sponsored
toggle
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
)
"
suggest
.
quicksuggest
.
sponsored
remains
false
after
clicking
data
collection
toggle
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
)
"
quicksuggest
.
dataCollection
.
enabled
is
false
after
clicking
data
collection
toggle
"
)
;
assertCheckboxes
(
{
[
NONSPONSORED_CHECKBOX_ID
]
:
false
[
SPONSORED_CHECKBOX_ID
]
:
false
[
DATA_COLLECTION_CHECKBOX_ID
]
:
false
}
)
;
await
assertInfoBox
(
null
)
;
gBrowser
.
removeCurrentTab
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
clickLearnMore
(
)
{
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
addressBarSection
=
doc
.
getElementById
(
"
locationBarGroup
"
)
;
addressBarSection
.
scrollIntoView
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
true
]
[
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
true
]
[
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
true
]
]
}
)
;
await
assertInfoBox
(
"
addressbar
-
firefox
-
suggest
-
info
-
all
"
)
;
let
learnMoreLinks
=
doc
.
querySelectorAll
(
"
.
"
+
LEARN_MORE_CLASS
)
;
Assert
.
equal
(
learnMoreLinks
.
length
2
"
Expected
number
of
learn
-
more
links
are
present
"
)
;
for
(
let
link
of
learnMoreLinks
)
{
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
link
)
"
Learn
-
more
link
is
visible
:
"
+
link
.
id
)
;
}
let
prefsTab
=
gBrowser
.
selectedTab
;
for
(
let
link
of
learnMoreLinks
)
{
let
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
UrlbarProviderQuickSuggest
.
helpUrl
)
;
info
(
"
Clicking
learn
-
more
link
:
"
+
link
.
id
)
;
Assert
.
ok
(
link
.
id
"
Sanity
check
:
Learn
-
more
link
has
an
ID
"
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
"
+
link
.
id
{
}
gBrowser
.
selectedBrowser
)
;
info
(
"
Waiting
for
help
page
to
load
in
a
new
tab
"
)
;
await
tabPromise
;
gBrowser
.
removeCurrentTab
(
)
;
gBrowser
.
selectedTab
=
prefsTab
;
}
gBrowser
.
removeCurrentTab
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
bestMatchVisibility
(
)
{
for
(
let
initialQuickSuggest
of
[
false
true
]
)
{
for
(
let
initialBestMatch
of
[
false
true
]
)
{
for
(
let
newQuickSuggest
of
[
false
true
]
)
{
for
(
let
newBestMatch
of
[
false
true
]
)
{
await
doBestMatchVisibilityTest
(
{
initialQuickSuggest
initialBestMatch
newQuickSuggest
newBestMatch
}
)
;
}
}
}
}
}
)
;
async
function
doBestMatchVisibilityTest
(
{
initialQuickSuggest
initialBestMatch
newQuickSuggest
newBestMatch
}
)
{
info
(
"
Running
best
match
visibility
test
:
"
+
JSON
.
stringify
(
{
initialQuickSuggest
initialBestMatch
newQuickSuggest
newBestMatch
}
null
2
)
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
enabled
"
initialQuickSuggest
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
bestMatch
.
enabled
"
initialBestMatch
)
;
await
UrlbarQuickSuggest
.
readyPromise
;
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
container
=
doc
.
getElementById
(
BEST_MATCH_CONTAINER_ID
)
;
Assert
.
equal
(
BrowserTestUtils
.
is_visible
(
container
)
initialBestMatch
"
The
checkbox
container
has
the
expected
initial
visibility
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
quicksuggest
.
enabled
"
newQuickSuggest
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
bestMatch
.
enabled
"
newBestMatch
)
;
await
UrlbarQuickSuggest
.
readyPromise
;
Assert
.
equal
(
BrowserTestUtils
.
is_visible
(
container
)
newBestMatch
"
The
checkbox
container
has
the
expected
visibility
after
setting
prefs
"
)
;
gBrowser
.
removeCurrentTab
(
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
quicksuggest
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
bestMatch
.
enabled
"
)
;
await
UrlbarQuickSuggest
.
readyPromise
;
}
add_task
(
async
function
bestMatchVisibility_experiment_beforeOpen
(
)
{
await
QuickSuggestTestUtils
.
withExperiment
(
{
valueOverrides
:
{
bestMatchEnabled
:
true
}
callback
:
async
(
)
=
>
{
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
container
=
doc
.
getElementById
(
BEST_MATCH_CONTAINER_ID
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
container
)
"
The
checkbox
container
is
visible
"
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
}
)
;
add_task
(
async
function
bestMatchVisibility_experiment_afterOpen
(
)
{
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
container
=
doc
.
getElementById
(
BEST_MATCH_CONTAINER_ID
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
container
)
"
The
checkbox
container
is
hidden
initially
"
)
;
await
QuickSuggestTestUtils
.
withExperiment
(
{
valueOverrides
:
{
bestMatchEnabled
:
true
}
callback
:
(
)
=
>
{
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
container
)
"
The
checkbox
container
is
visible
after
installing
the
experiment
"
)
;
}
}
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
container
)
"
The
checkbox
container
is
hidden
again
after
the
experiment
is
uninstalled
"
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
add_task
(
async
function
bestMatchToggle
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
bestMatch
.
enabled
"
true
]
]
}
)
;
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
const
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
const
checkbox
=
doc
.
getElementById
(
BEST_MATCH_CHECKBOX_ID
)
;
checkbox
.
scrollIntoView
(
)
;
info
(
"
Check
if
the
checkbox
stauts
reflects
the
pref
value
"
)
;
for
(
const
isEnabled
of
[
true
false
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
suggest
.
bestmatch
"
isEnabled
]
]
}
)
;
assertCheckboxes
(
{
[
BEST_MATCH_CHECKBOX_ID
]
:
isEnabled
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
info
(
"
Check
if
the
pref
value
reflects
the
checkbox
status
"
)
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
const
initialValue
=
checkbox
.
checked
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
"
+
BEST_MATCH_CHECKBOX_ID
{
}
gBrowser
.
selectedBrowser
)
;
Assert
.
ok
(
initialValue
!
=
=
checkbox
.
checked
)
;
Assert
.
equal
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
urlbar
.
suggest
.
bestmatch
"
)
checkbox
.
checked
)
;
}
Services
.
prefs
.
clearUserPref
(
"
browser
.
urlbar
.
suggest
.
bestmatch
"
)
;
gBrowser
.
removeCurrentTab
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
clickBestMatchLearnMore
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
urlbar
.
bestMatch
.
enabled
"
true
]
]
}
)
;
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
const
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
const
link
=
doc
.
getElementById
(
"
firefoxSuggestBestMatchLearnMore
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
link
)
"
Learn
-
more
link
is
visible
"
)
;
const
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
UrlbarProviderQuickSuggest
.
bestMatchHelpUrl
)
;
info
(
"
Clicking
learn
-
more
link
"
)
;
link
.
scrollIntoView
(
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
#
firefoxSuggestBestMatchLearnMore
"
{
}
gBrowser
.
selectedBrowser
)
;
info
(
"
Waiting
for
help
page
to
load
in
a
new
tab
"
)
;
const
tab
=
await
tabPromise
;
gBrowser
.
removeTab
(
tab
)
;
gBrowser
.
removeCurrentTab
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
function
assertCheckboxes
(
checkedByElementID
)
{
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
container
=
doc
.
getElementById
(
CONTAINER_ID
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
container
)
"
The
container
is
visible
"
)
;
for
(
let
[
id
checked
]
of
Object
.
entries
(
checkedByElementID
)
)
{
let
checkbox
=
doc
.
getElementById
(
id
)
;
Assert
.
equal
(
checkbox
.
checked
checked
"
Checkbox
checked
state
for
ID
:
"
+
id
)
;
}
}
async
function
assertInfoBox
(
expectedL10nID
)
{
info
(
"
Checking
info
box
with
expected
l10n
ID
:
"
+
expectedL10nID
)
;
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
infoBox
=
doc
.
getElementById
(
INFO_BOX_ID
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
BrowserTestUtils
.
is_visible
(
infoBox
)
=
=
!
!
expectedL10nID
"
Waiting
for
expected
info
box
visibility
:
"
+
!
!
expectedL10nID
)
;
let
infoIcon
=
infoBox
.
querySelector
(
"
.
info
-
icon
"
)
;
Assert
.
equal
(
BrowserTestUtils
.
is_visible
(
infoIcon
)
!
!
expectedL10nID
"
The
info
icon
is
visible
iff
a
description
should
be
shown
"
)
;
let
learnMore
=
infoBox
.
querySelector
(
"
.
"
+
LEARN_MORE_CLASS
)
;
Assert
.
ok
(
learnMore
"
Found
the
info
box
learn
more
link
"
)
;
Assert
.
equal
(
BrowserTestUtils
.
is_visible
(
learnMore
)
!
!
expectedL10nID
"
The
info
box
learn
more
link
is
visible
iff
a
description
should
be
shown
"
)
;
if
(
expectedL10nID
)
{
let
infoText
=
doc
.
getElementById
(
INFO_TEXT_ID
)
;
Assert
.
equal
(
infoText
.
dataset
.
l10nId
expectedL10nID
"
Info
text
has
expected
l10n
ID
"
)
;
}
}
