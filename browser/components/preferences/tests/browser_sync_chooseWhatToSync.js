"
use
strict
"
;
const
{
Service
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
services
-
sync
/
service
.
sys
.
mjs
"
)
;
const
{
UIState
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
services
-
sync
/
UIState
.
sys
.
mjs
"
)
;
const
syncPrefs
=
{
"
services
.
sync
.
engine
.
addons
"
:
false
"
services
.
sync
.
engine
.
bookmarks
"
:
true
"
services
.
sync
.
engine
.
history
"
:
true
"
services
.
sync
.
engine
.
tabs
"
:
false
"
services
.
sync
.
engine
.
prefs
"
:
false
"
services
.
sync
.
engine
.
passwords
"
:
false
"
services
.
sync
.
engine
.
addresses
"
:
false
"
services
.
sync
.
engine
.
creditcards
"
:
false
}
;
add_setup
(
async
(
)
=
>
{
UIState
.
_internal
.
notifyStateUpdated
=
(
)
=
>
{
}
;
const
origNotifyStateUpdated
=
UIState
.
_internal
.
notifyStateUpdated
;
const
origGet
=
UIState
.
get
;
UIState
.
get
=
(
)
=
>
{
return
{
status
:
UIState
.
STATUS_SIGNED_IN
email
:
"
foo
bar
.
com
"
}
;
}
;
registerCleanupFunction
(
(
)
=
>
{
UIState
.
_internal
.
notifyStateUpdated
=
origNotifyStateUpdated
;
UIState
.
get
=
origGet
;
}
)
;
}
)
;
add_task
(
async
function
testDialogAccept
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
identity
.
fxaccounts
.
enabled
"
true
]
]
}
)
;
await
openPreferencesViaOpenPreferencesAPI
(
"
paneGeneral
"
{
leaveOpen
:
true
}
)
;
let
callbackCalled
=
false
;
let
syncWindow
=
await
openAndLoadSubDialog
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
syncChooseWhatToSync
.
xhtml
"
null
{
}
(
)
=
>
{
for
(
const
[
prefKey
prefValue
]
of
Object
.
entries
(
syncPrefs
)
)
{
Assert
.
equal
(
Services
.
prefs
.
getBoolPref
(
prefKey
)
prefValue
{
prefValue
}
is
expected
value
)
;
}
callbackCalled
=
true
;
}
)
;
Assert
.
ok
(
syncWindow
"
Choose
what
to
sync
window
opened
"
)
;
let
syncChooseDialog
=
syncWindow
.
document
.
getElementById
(
"
syncChooseOptions
"
)
;
let
syncCheckboxes
=
syncChooseDialog
.
querySelectorAll
(
"
checkbox
[
preference
]
"
)
;
[
.
.
.
syncCheckboxes
]
.
forEach
(
checkbox
=
>
{
if
(
syncPrefs
[
checkbox
.
getAttribute
(
"
preference
"
)
]
!
=
=
checkbox
.
checked
)
{
checkbox
.
click
(
)
;
}
}
)
;
syncChooseDialog
.
acceptDialog
(
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
Assert
.
ok
(
callbackCalled
"
Accept
callback
was
called
"
)
;
}
)
;
add_task
(
async
function
testDialogCancel
(
)
{
const
cancelSyncPrefs
=
{
"
services
.
sync
.
engine
.
addons
"
:
true
"
services
.
sync
.
engine
.
bookmarks
"
:
false
"
services
.
sync
.
engine
.
history
"
:
true
"
services
.
sync
.
engine
.
tabs
"
:
true
"
services
.
sync
.
engine
.
prefs
"
:
false
"
services
.
sync
.
engine
.
passwords
"
:
true
"
services
.
sync
.
engine
.
addresses
"
:
true
"
services
.
sync
.
engine
.
creditcards
"
:
false
}
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
identity
.
fxaccounts
.
enabled
"
true
]
]
}
)
;
await
openPreferencesViaOpenPreferencesAPI
(
"
paneGeneral
"
{
leaveOpen
:
true
}
)
;
let
callbackCalled
=
false
;
let
syncWindow
=
await
openAndLoadSubDialog
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
syncChooseWhatToSync
.
xhtml
"
null
{
}
(
)
=
>
{
for
(
const
[
prefKey
prefValue
]
of
Object
.
entries
(
syncPrefs
)
)
{
Assert
.
equal
(
Services
.
prefs
.
getBoolPref
(
prefKey
)
prefValue
{
prefValue
}
is
expected
value
)
;
}
callbackCalled
=
true
;
}
)
;
ok
(
syncWindow
"
Choose
what
to
sync
window
opened
"
)
;
let
syncChooseDialog
=
syncWindow
.
document
.
getElementById
(
"
syncChooseOptions
"
)
;
let
syncCheckboxes
=
syncChooseDialog
.
querySelectorAll
(
"
checkbox
[
preference
]
"
)
;
[
.
.
.
syncCheckboxes
]
.
forEach
(
checkbox
=
>
{
if
(
cancelSyncPrefs
[
checkbox
.
getAttribute
(
"
preference
"
)
]
!
=
=
checkbox
.
checked
)
{
checkbox
.
click
(
)
;
}
}
)
;
syncChooseDialog
.
cancelDialog
(
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
Assert
.
ok
(
callbackCalled
"
Cancel
callback
was
called
"
)
;
}
)
;
add_task
(
async
function
testDialogLaunchFromURI
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
identity
.
fxaccounts
.
enabled
"
true
]
]
}
)
;
let
dialogEventPromise
=
BrowserTestUtils
.
waitForEvent
(
window
"
dialogopen
"
true
)
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
?
action
=
choose
-
what
-
to
-
sync
#
sync
"
async
(
)
=
>
{
let
dialogEvent
=
await
dialogEventPromise
;
Assert
.
equal
(
dialogEvent
.
detail
.
dialog
.
_frame
.
contentWindow
.
location
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
syncChooseWhatToSync
.
xhtml
"
)
;
}
)
;
}
)
;
add_task
(
async
function
testSyncCalledAfterSavingCWTS
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
identity
.
fxaccounts
.
enabled
"
true
]
]
}
)
;
const
svc
=
Weave
.
Service
;
const
origLocked
=
svc
.
_locked
;
const
origSync
=
svc
.
sync
;
let
syncCalls
=
0
;
svc
.
_locked
=
false
;
svc
.
sync
=
(
)
=
>
{
syncCalls
+
+
;
return
Promise
.
resolve
(
)
;
}
;
await
runWithCWTSDialog
(
async
win
=
>
{
let
doc
=
win
.
document
;
let
syncDialog
=
doc
.
getElementById
(
"
syncChooseOptions
"
)
;
let
promiseUnloaded
=
BrowserTestUtils
.
waitForEvent
(
win
"
unload
"
)
;
syncDialog
.
acceptDialog
(
)
;
info
(
"
waiting
for
dialog
to
unload
"
)
;
await
promiseUnloaded
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
syncCalls
=
=
1
"
Immediate
sync
(
)
call
when
service
.
_locked
is
false
"
)
;
}
)
;
svc
.
_locked
=
origLocked
;
svc
.
sync
=
origSync
;
}
)
;
add_task
(
async
function
testSyncScheduledWhileSyncing
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
identity
.
fxaccounts
.
enabled
"
true
]
]
}
)
;
const
svc
=
Weave
.
Service
;
const
origLocked
=
svc
.
_locked
;
const
origSync
=
svc
.
sync
;
let
syncCalls
=
0
;
svc
.
_locked
=
true
;
svc
.
sync
=
(
)
=
>
{
syncCalls
+
+
;
return
Promise
.
resolve
(
)
;
}
;
await
runWithCWTSDialog
(
async
win
=
>
{
let
doc
=
win
.
document
;
let
syncDialog
=
doc
.
getElementById
(
"
syncChooseOptions
"
)
;
let
promiseUnloaded
=
BrowserTestUtils
.
waitForEvent
(
win
"
unload
"
)
;
syncDialog
.
acceptDialog
(
)
;
info
(
"
waiting
for
dialog
to
unload
"
)
;
await
promiseUnloaded
;
Assert
.
equal
(
syncCalls
0
"
No
immediate
sync
when
_locked
is
true
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
service
:
sync
:
finish
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
syncCalls
=
=
=
1
"
Pending
sync
should
fire
once
service
finishes
"
)
;
}
)
;
svc
.
_locked
=
origLocked
;
svc
.
sync
=
origSync
;
}
)
;
add_task
(
async
function
testTelemetrySentOnDialogAccept
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
services
.
sync
.
engine
.
addons
"
true
]
[
"
services
.
sync
.
engine
.
bookmarks
"
false
]
[
"
services
.
sync
.
engine
.
history
"
false
]
[
"
services
.
sync
.
engine
.
tabs
"
false
]
[
"
services
.
sync
.
engine
.
prefs
"
true
]
[
"
services
.
sync
.
engine
.
passwords
"
true
]
[
"
services
.
sync
.
engine
.
addresses
"
false
]
[
"
services
.
sync
.
engine
.
creditcards
"
true
]
[
"
identity
.
fxaccounts
.
enabled
"
true
]
]
}
)
;
const
expectedEngineSettings
=
{
"
services
.
sync
.
engine
.
addons
"
:
false
"
services
.
sync
.
engine
.
bookmarks
"
:
true
"
services
.
sync
.
engine
.
history
"
:
true
"
services
.
sync
.
engine
.
tabs
"
:
true
"
services
.
sync
.
engine
.
prefs
"
:
false
"
services
.
sync
.
engine
.
passwords
"
:
false
"
services
.
sync
.
engine
.
addresses
"
:
true
"
services
.
sync
.
engine
.
creditcards
"
:
false
}
;
await
openPreferencesViaOpenPreferencesAPI
(
"
paneGeneral
"
{
leaveOpen
:
true
}
)
;
let
callbackCalled
=
false
;
let
syncWindow
=
await
openAndLoadSubDialog
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
syncChooseWhatToSync
.
xhtml
"
null
{
}
(
)
=
>
{
var
expectedEnabledEngines
=
[
]
;
var
expectedDisabledEngines
=
[
]
;
for
(
const
[
prefKey
prefValue
]
of
Object
.
entries
(
expectedEngineSettings
)
)
{
Assert
.
equal
(
Services
.
prefs
.
getBoolPref
(
prefKey
)
prefValue
{
prefValue
}
is
expected
value
)
;
let
engineName
=
prefKey
.
replace
(
"
services
.
sync
.
engine
.
"
"
"
)
;
if
(
prefValue
=
=
=
true
)
{
expectedEnabledEngines
.
push
(
engineName
)
;
}
else
{
expectedDisabledEngines
.
push
(
engineName
)
;
}
}
callbackCalled
=
true
;
const
actual
=
Glean
.
syncSettings
.
save
.
testGetValue
(
)
[
0
]
;
const
expectedCategory
=
"
sync_settings
"
;
const
expectedName
=
"
save
"
;
const
actualEnabledEngines
=
actual
.
extra
.
enabled_engines
.
split
(
"
"
)
;
const
actualDisabledEngines
=
actual
.
extra
.
disabled_engines
.
split
(
"
"
)
;
Assert
.
equal
(
actual
.
category
expectedCategory
telemetry
category
is
{
expectedCategory
}
)
;
Assert
.
equal
(
actual
.
name
expectedName
telemetry
name
is
{
expectedName
}
)
;
Assert
.
equal
(
actualEnabledEngines
.
length
expectedEnabledEngines
.
length
reported
{
expectedEnabledEngines
.
length
}
engines
enabled
)
;
Assert
.
equal
(
actualDisabledEngines
.
length
expectedDisabledEngines
.
length
reported
{
expectedDisabledEngines
.
length
}
engines
disabled
)
;
actualEnabledEngines
.
forEach
(
engine
=
>
{
Assert
.
ok
(
expectedEnabledEngines
.
includes
(
engine
)
reported
enabled
engines
should
include
{
engine
}
engine
)
;
}
)
;
actualDisabledEngines
.
forEach
(
engine
=
>
{
Assert
.
ok
(
expectedDisabledEngines
.
includes
(
engine
)
reported
disabled
engines
should
include
{
engine
}
engine
)
;
}
)
;
}
)
;
Assert
.
ok
(
syncWindow
"
Choose
what
to
sync
window
opened
"
)
;
let
syncChooseDialog
=
syncWindow
.
document
.
getElementById
(
"
syncChooseOptions
"
)
;
let
syncCheckboxes
=
syncChooseDialog
.
querySelectorAll
(
"
checkbox
[
preference
]
"
)
;
[
.
.
.
syncCheckboxes
]
.
forEach
(
checkbox
=
>
{
if
(
expectedEngineSettings
[
checkbox
.
getAttribute
(
"
preference
"
)
]
!
=
=
checkbox
.
checked
)
{
checkbox
.
click
(
)
;
}
}
)
;
syncChooseDialog
.
acceptDialog
(
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
Assert
.
ok
(
callbackCalled
"
Accept
callback
was
called
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
async
function
runWithCWTSDialog
(
test
)
{
await
openPreferencesViaOpenPreferencesAPI
(
"
paneSync
"
{
leaveOpen
:
true
}
)
;
let
promiseSubDialogLoaded
=
promiseLoadSubDialog
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
syncChooseWhatToSync
.
xhtml
"
)
;
gBrowser
.
contentWindow
.
SyncHelpers
.
_chooseWhatToSync
(
true
)
;
let
win
=
await
promiseSubDialogLoaded
;
await
test
(
win
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
