const
MozButton
=
customElements
.
get
(
"
button
"
)
;
class
HighlightableButton
extends
MozButton
{
static
get
inheritedAttributes
(
)
{
return
Object
.
assign
(
{
}
super
.
inheritedAttributes
{
"
.
button
-
text
"
:
"
text
=
label
accesskey
crop
"
}
)
;
}
}
customElements
.
define
(
"
highlightable
-
button
"
HighlightableButton
{
extends
:
"
button
"
}
)
;
var
gSearchResultsPane
=
{
listSearchTooltips
:
new
Set
(
)
listSearchMenuitemIndicators
:
new
Set
(
)
searchInput
:
null
searchKeywords
:
new
WeakMap
(
)
inited
:
false
subItems
:
new
Map
(
)
searchResultsHighlighted
:
false
searchableNodes
:
new
Set
(
[
"
button
"
"
label
"
"
description
"
"
menulist
"
"
menuitem
"
"
checkbox
"
]
)
init
(
)
{
if
(
this
.
inited
)
{
return
;
}
this
.
inited
=
true
;
this
.
searchInput
=
document
.
getElementById
(
"
searchInput
"
)
;
window
.
addEventListener
(
"
resize
"
(
)
=
>
{
this
.
_recomputeTooltipPositions
(
)
;
}
)
;
if
(
!
this
.
searchInput
.
hidden
)
{
this
.
searchInput
.
addEventListener
(
"
input
"
this
)
;
this
.
searchInput
.
addEventListener
(
"
command
"
this
)
;
window
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
this
.
searchInput
.
focus
(
)
;
window
.
requestIdleCallback
(
(
)
=
>
this
.
initializeCategories
(
)
)
;
}
)
;
}
ensureScrollPadding
(
)
;
}
async
handleEvent
(
event
)
{
await
this
.
initializeCategories
(
)
;
this
.
searchFunction
(
event
)
;
}
fixInputPosition
(
)
{
let
innerContainer
=
document
.
querySelector
(
"
.
sticky
-
inner
-
container
"
)
;
let
width
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
innerContainer
)
.
width
;
innerContainer
.
style
.
maxWidth
=
width
+
"
px
"
;
}
queryMatchesContent
(
content
query
)
{
if
(
!
content
|
|
!
query
)
{
return
false
;
}
return
content
.
toLowerCase
(
)
.
includes
(
query
.
toLowerCase
(
)
)
;
}
categoriesInitialized
:
false
async
initializeCategories
(
)
{
if
(
!
this
.
categoriesInitialized
)
{
this
.
categoriesInitialized
=
true
;
for
(
let
category
of
gCategoryInits
.
values
(
)
)
{
category
.
init
(
)
;
}
if
(
document
.
hasPendingL10nMutations
)
{
await
new
Promise
(
r
=
>
document
.
addEventListener
(
"
L10nMutationsFinished
"
r
{
once
:
true
}
)
)
;
}
}
}
textNodeDescendants
(
node
)
{
if
(
!
node
)
{
return
[
]
;
}
let
all
=
[
]
;
for
(
node
=
node
.
firstChild
;
node
;
node
=
node
.
nextSibling
)
{
if
(
node
.
nodeType
=
=
=
node
.
TEXT_NODE
)
{
all
.
push
(
node
)
;
}
else
{
all
=
all
.
concat
(
this
.
textNodeDescendants
(
node
)
)
;
}
}
return
all
;
}
highlightMatches
(
textNodes
nodeSizes
textSearch
searchPhrase
)
{
if
(
!
searchPhrase
)
{
return
false
;
}
let
indices
=
[
]
;
let
i
=
-
1
;
while
(
(
i
=
textSearch
.
indexOf
(
searchPhrase
i
+
1
)
)
>
=
0
)
{
indices
.
push
(
i
)
;
}
for
(
let
startValue
of
indices
)
{
let
endValue
=
startValue
+
searchPhrase
.
length
;
let
startNode
=
null
;
let
endNode
=
null
;
let
nodeStartIndex
=
null
;
for
(
let
index
=
0
;
index
<
nodeSizes
.
length
;
index
+
+
)
{
let
lengthNodes
=
nodeSizes
[
index
]
;
if
(
!
startNode
&
&
lengthNodes
>
=
startValue
)
{
startNode
=
textNodes
[
index
]
;
nodeStartIndex
=
index
;
if
(
index
>
0
)
{
startValue
-
=
nodeSizes
[
index
-
1
]
;
}
}
if
(
!
endNode
&
&
lengthNodes
>
=
endValue
)
{
endNode
=
textNodes
[
index
]
;
if
(
index
!
=
nodeStartIndex
|
|
index
>
0
)
{
endValue
-
=
nodeSizes
[
index
-
1
]
;
}
}
}
let
range
=
document
.
createRange
(
)
;
range
.
setStart
(
startNode
startValue
)
;
range
.
setEnd
(
endNode
endValue
)
;
this
.
getFindSelection
(
startNode
.
ownerGlobal
)
.
addRange
(
range
)
;
this
.
searchResultsHighlighted
=
true
;
}
return
!
!
indices
.
length
;
}
getFindSelection
(
win
)
{
let
docShell
=
win
.
docShell
;
let
controller
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsISelectionDisplay
)
.
QueryInterface
(
Ci
.
nsISelectionController
)
;
let
selection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
selection
.
setColors
(
"
currentColor
"
"
#
ffe900
"
"
currentColor
"
"
#
003eaa
"
)
;
return
selection
;
}
async
searchFunction
(
event
)
{
let
query
=
event
.
target
.
value
.
trim
(
)
.
toLowerCase
(
)
;
if
(
this
.
query
=
=
query
)
{
return
;
}
let
firstQuery
=
!
this
.
query
&
&
query
;
let
endQuery
=
!
query
&
&
this
.
query
;
let
subQuery
=
this
.
query
&
&
query
.
includes
(
this
.
query
)
;
this
.
query
=
query
;
this
.
removeAllSearchIndicators
(
window
!
query
.
length
)
;
let
srHeader
=
document
.
getElementById
(
"
header
-
searchResults
"
)
;
let
noResultsEl
=
document
.
getElementById
(
"
no
-
results
-
message
"
)
;
if
(
this
.
query
)
{
if
(
firstQuery
)
{
this
.
fixInputPosition
(
)
;
}
await
gotoPref
(
"
paneSearchResults
"
)
;
srHeader
.
hidden
=
false
;
let
resultsFound
=
false
;
let
rootPreferencesChildren
=
[
.
.
.
document
.
querySelectorAll
(
"
#
mainPrefPane
>
*
:
not
(
[
data
-
hidden
-
from
-
search
]
script
stringbundle
)
"
)
]
;
if
(
subQuery
)
{
rootPreferencesChildren
=
rootPreferencesChildren
.
filter
(
el
=
>
!
el
.
hidden
)
;
}
for
(
let
child
of
rootPreferencesChildren
)
{
if
(
child
.
hidden
)
{
child
.
classList
.
add
(
"
visually
-
hidden
"
)
;
child
.
hidden
=
false
;
}
}
let
ts
=
performance
.
now
(
)
;
let
FRAME_THRESHOLD
=
1000
/
60
;
for
(
let
child
of
rootPreferencesChildren
)
{
if
(
performance
.
now
(
)
-
ts
>
FRAME_THRESHOLD
)
{
for
(
let
anchorNode
of
this
.
listSearchTooltips
)
{
this
.
createSearchTooltip
(
anchorNode
this
.
query
)
;
}
ts
=
await
new
Promise
(
resolve
=
>
window
.
requestAnimationFrame
(
resolve
)
)
;
if
(
query
!
=
=
this
.
query
)
{
return
;
}
}
if
(
!
child
.
classList
.
contains
(
"
header
"
)
&
&
!
child
.
classList
.
contains
(
"
subcategory
"
)
&
&
(
await
this
.
searchWithinNode
(
child
this
.
query
)
)
)
{
child
.
classList
.
remove
(
"
visually
-
hidden
"
)
;
let
groupbox
=
child
.
closest
(
"
groupbox
"
)
|
|
child
.
closest
(
"
[
data
-
category
]
"
)
;
let
groupHeader
=
groupbox
&
&
groupbox
.
querySelector
(
"
.
search
-
header
"
)
;
if
(
groupHeader
)
{
groupHeader
.
hidden
=
false
;
}
resultsFound
=
true
;
}
else
{
child
.
classList
.
add
(
"
visually
-
hidden
"
)
;
}
}
if
(
this
.
subItems
.
size
)
{
for
(
let
[
subItem
matches
]
of
this
.
subItems
)
{
subItem
.
classList
.
toggle
(
"
visually
-
hidden
"
!
matches
)
;
}
}
noResultsEl
.
hidden
=
!
!
resultsFound
;
noResultsEl
.
setAttribute
(
"
query
"
this
.
query
)
;
let
msgQueryElem
=
document
.
getElementById
(
"
sorry
-
message
-
query
"
)
;
msgQueryElem
.
textContent
=
this
.
query
;
if
(
resultsFound
)
{
for
(
let
anchorNode
of
this
.
listSearchTooltips
)
{
this
.
createSearchTooltip
(
anchorNode
this
.
query
)
;
}
}
}
else
{
if
(
endQuery
)
{
document
.
querySelector
(
"
.
sticky
-
inner
-
container
"
)
.
style
.
removeProperty
(
"
max
-
width
"
)
;
}
noResultsEl
.
hidden
=
true
;
document
.
getElementById
(
"
sorry
-
message
-
query
"
)
.
textContent
=
"
"
;
await
gotoPref
(
"
paneGeneral
"
)
;
srHeader
.
hidden
=
true
;
for
(
let
element
of
document
.
querySelectorAll
(
"
.
search
-
header
"
)
)
{
element
.
hidden
=
true
;
}
}
window
.
dispatchEvent
(
new
CustomEvent
(
"
PreferencesSearchCompleted
"
{
detail
:
query
}
)
)
;
}
async
searchWithinNode
(
nodeObject
searchPhrase
)
{
let
matchesFound
=
false
;
if
(
nodeObject
.
childElementCount
=
=
0
|
|
this
.
searchableNodes
.
has
(
nodeObject
.
localName
)
|
|
(
nodeObject
.
localName
?
.
startsWith
(
"
moz
-
"
)
&
&
nodeObject
.
localName
!
=
=
"
moz
-
input
-
box
"
)
)
{
let
simpleTextNodes
=
this
.
textNodeDescendants
(
nodeObject
)
;
if
(
nodeObject
.
shadowRoot
)
{
simpleTextNodes
.
push
(
.
.
.
this
.
textNodeDescendants
(
nodeObject
.
shadowRoot
)
)
;
}
for
(
let
node
of
simpleTextNodes
)
{
let
result
=
this
.
highlightMatches
(
[
node
]
[
node
.
length
]
node
.
textContent
.
toLowerCase
(
)
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
let
nodeSizes
=
[
]
;
let
allNodeText
=
"
"
;
let
runningSize
=
0
;
let
accessKeyTextNodes
=
[
]
;
if
(
nodeObject
.
localName
=
=
"
label
"
|
|
nodeObject
.
localName
=
=
"
description
"
)
{
accessKeyTextNodes
.
push
(
.
.
.
simpleTextNodes
)
;
}
for
(
let
node
of
accessKeyTextNodes
)
{
runningSize
+
=
node
.
textContent
.
length
;
allNodeText
+
=
node
.
textContent
;
nodeSizes
.
push
(
runningSize
)
;
}
let
complexTextNodesResult
=
this
.
highlightMatches
(
accessKeyTextNodes
nodeSizes
allNodeText
.
toLowerCase
(
)
searchPhrase
)
;
let
labelResult
=
this
.
queryMatchesContent
(
nodeObject
.
getAttribute
(
"
label
"
)
searchPhrase
)
;
let
valueResult
=
nodeObject
.
localName
!
=
=
"
menuitem
"
&
&
nodeObject
.
localName
!
=
=
"
radio
"
?
this
.
queryMatchesContent
(
nodeObject
.
getAttribute
(
"
value
"
)
searchPhrase
)
:
false
;
let
keywordsResult
=
nodeObject
.
hasAttribute
(
"
search
-
l10n
-
ids
"
)
&
&
(
await
this
.
matchesSearchL10nIDs
(
nodeObject
searchPhrase
)
)
;
if
(
!
keywordsResult
)
{
keywordsResult
=
!
keywordsResult
&
&
nodeObject
.
hasAttribute
(
"
searchkeywords
"
)
&
&
this
.
queryMatchesContent
(
nodeObject
.
getAttribute
(
"
searchkeywords
"
)
searchPhrase
)
;
}
if
(
keywordsResult
&
&
(
nodeObject
.
localName
=
=
=
"
button
"
|
|
nodeObject
.
localName
=
=
"
menulist
"
)
)
{
this
.
listSearchTooltips
.
add
(
nodeObject
)
;
}
if
(
keywordsResult
&
&
nodeObject
.
localName
=
=
=
"
menuitem
"
)
{
nodeObject
.
setAttribute
(
"
indicator
"
"
true
"
)
;
this
.
listSearchMenuitemIndicators
.
add
(
nodeObject
)
;
let
menulist
=
nodeObject
.
closest
(
"
menulist
"
)
;
menulist
.
setAttribute
(
"
indicator
"
"
true
"
)
;
this
.
listSearchMenuitemIndicators
.
add
(
menulist
)
;
}
if
(
(
nodeObject
.
localName
=
=
"
menulist
"
|
|
nodeObject
.
localName
=
=
"
menuitem
"
)
&
&
(
labelResult
|
|
valueResult
|
|
keywordsResult
)
)
{
nodeObject
.
setAttribute
(
"
highlightable
"
"
true
"
)
;
}
matchesFound
=
matchesFound
|
|
complexTextNodesResult
|
|
labelResult
|
|
valueResult
|
|
keywordsResult
;
}
if
(
nodeObject
.
localName
=
=
"
deck
"
&
&
nodeObject
.
id
!
=
"
historyPane
"
)
{
let
index
=
nodeObject
.
selectedIndex
;
if
(
index
!
=
-
1
)
{
let
result
=
await
this
.
searchChildNodeIfVisible
(
nodeObject
index
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
}
else
{
for
(
let
i
=
0
;
i
<
nodeObject
.
childNodes
.
length
;
i
+
+
)
{
let
result
=
await
this
.
searchChildNodeIfVisible
(
nodeObject
i
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
}
return
matchesFound
;
}
async
searchChildNodeIfVisible
(
nodeObject
index
searchPhrase
)
{
let
result
=
false
;
let
child
=
nodeObject
.
childNodes
[
index
]
;
if
(
!
child
.
hidden
&
&
nodeObject
.
getAttribute
(
"
data
-
hidden
-
from
-
search
"
)
!
=
=
"
true
"
)
{
result
=
await
this
.
searchWithinNode
(
child
searchPhrase
)
;
if
(
result
&
&
nodeObject
.
localName
=
=
=
"
menulist
"
)
{
this
.
listSearchTooltips
.
add
(
nodeObject
)
;
}
if
(
Element
.
isInstance
(
child
)
&
&
(
child
.
classList
.
contains
(
"
featureGate
"
)
|
|
child
.
classList
.
contains
(
"
mozilla
-
product
-
item
"
)
)
)
{
this
.
subItems
.
set
(
child
result
)
;
}
}
return
result
;
}
async
matchesSearchL10nIDs
(
nodeObject
searchPhrase
)
{
if
(
!
this
.
searchKeywords
.
has
(
nodeObject
)
)
{
const
refs
=
nodeObject
.
getAttribute
(
"
search
-
l10n
-
ids
"
)
.
split
(
"
"
)
.
map
(
s
=
>
s
.
trim
(
)
.
split
(
"
.
"
)
)
.
filter
(
s
=
>
!
!
s
[
0
]
.
length
)
;
const
messages
=
await
document
.
l10n
.
formatMessages
(
refs
.
map
(
ref
=
>
(
{
id
:
ref
[
0
]
}
)
)
)
;
let
keywords
=
messages
.
map
(
(
msg
i
)
=
>
{
let
[
refId
refAttr
]
=
refs
[
i
]
;
if
(
!
msg
)
{
console
.
error
(
Missing
search
l10n
id
"
{
refId
}
"
)
;
return
null
;
}
if
(
refAttr
)
{
let
attr
=
msg
.
attributes
&
&
msg
.
attributes
.
find
(
a
=
>
a
.
name
=
=
=
refAttr
)
;
if
(
!
attr
)
{
console
.
error
(
Missing
search
l10n
id
"
{
refId
}
.
{
refAttr
}
"
)
;
return
null
;
}
if
(
attr
.
value
=
=
=
"
"
)
{
console
.
error
(
Empty
value
added
to
search
-
l10n
-
ids
"
{
refId
}
.
{
refAttr
}
"
)
;
}
return
attr
.
value
;
}
if
(
msg
.
value
=
=
=
"
"
)
{
console
.
error
(
Empty
value
added
to
search
-
l10n
-
ids
"
{
refId
}
"
)
;
}
return
msg
.
value
;
}
)
.
filter
(
keyword
=
>
keyword
!
=
=
null
)
.
join
(
"
"
)
;
this
.
searchKeywords
.
set
(
nodeObject
keywords
)
;
return
this
.
queryMatchesContent
(
keywords
searchPhrase
)
;
}
return
this
.
queryMatchesContent
(
this
.
searchKeywords
.
get
(
nodeObject
)
searchPhrase
)
;
}
createSearchTooltip
(
anchorNode
query
)
{
if
(
anchorNode
.
tooltipNode
)
{
return
;
}
let
searchTooltip
=
anchorNode
.
ownerDocument
.
createElement
(
"
span
"
)
;
let
searchTooltipText
=
anchorNode
.
ownerDocument
.
createElement
(
"
span
"
)
;
searchTooltip
.
className
=
"
search
-
tooltip
"
;
searchTooltipText
.
textContent
=
query
;
searchTooltip
.
appendChild
(
searchTooltipText
)
;
anchorNode
.
tooltipNode
=
searchTooltip
;
anchorNode
.
parentElement
.
classList
.
add
(
"
search
-
tooltip
-
parent
"
)
;
anchorNode
.
parentElement
.
appendChild
(
searchTooltip
)
;
this
.
_applyTooltipPosition
(
searchTooltip
this
.
_computeTooltipPosition
(
anchorNode
searchTooltip
)
)
;
}
_recomputeTooltipPositions
(
)
{
let
positions
=
[
]
;
for
(
let
anchorNode
of
this
.
listSearchTooltips
)
{
let
searchTooltip
=
anchorNode
.
tooltipNode
;
if
(
!
searchTooltip
)
{
continue
;
}
let
position
=
this
.
_computeTooltipPosition
(
anchorNode
searchTooltip
)
;
positions
.
push
(
{
searchTooltip
position
}
)
;
}
for
(
let
{
searchTooltip
position
}
of
positions
)
{
this
.
_applyTooltipPosition
(
searchTooltip
position
)
;
}
}
_applyTooltipPosition
(
searchTooltip
position
)
{
searchTooltip
.
style
.
left
=
position
.
left
+
"
px
"
;
searchTooltip
.
style
.
top
=
position
.
top
+
"
px
"
;
}
_computeTooltipPosition
(
anchorNode
searchTooltip
)
{
let
anchorRect
=
anchorNode
.
getBoundingClientRect
(
)
;
let
containerRect
=
anchorNode
.
parentElement
.
getBoundingClientRect
(
)
;
let
tooltipRect
=
searchTooltip
.
getBoundingClientRect
(
)
;
let
left
=
anchorRect
.
left
-
containerRect
.
left
+
anchorRect
.
width
/
2
-
tooltipRect
.
width
/
2
;
let
top
=
anchorRect
.
top
-
containerRect
.
top
;
return
{
left
top
}
;
}
removeAllSearchIndicators
(
window
showSubItems
)
{
if
(
this
.
searchResultsHighlighted
)
{
this
.
getFindSelection
(
window
)
.
removeAllRanges
(
)
;
this
.
searchResultsHighlighted
=
false
;
}
this
.
removeAllSearchTooltips
(
)
;
this
.
removeAllSearchMenuitemIndicators
(
)
;
if
(
showSubItems
&
&
this
.
subItems
.
size
)
{
for
(
let
subItem
of
this
.
subItems
.
keys
(
)
)
{
subItem
.
classList
.
remove
(
"
visually
-
hidden
"
)
;
}
this
.
subItems
.
clear
(
)
;
}
}
removeAllSearchTooltips
(
)
{
for
(
let
anchorNode
of
this
.
listSearchTooltips
)
{
anchorNode
.
parentElement
.
classList
.
remove
(
"
search
-
tooltip
-
parent
"
)
;
if
(
anchorNode
.
tooltipNode
)
{
anchorNode
.
tooltipNode
.
remove
(
)
;
}
anchorNode
.
tooltipNode
=
null
;
}
this
.
listSearchTooltips
.
clear
(
)
;
}
removeAllSearchMenuitemIndicators
(
)
{
for
(
let
node
of
this
.
listSearchMenuitemIndicators
)
{
node
.
removeAttribute
(
"
indicator
"
)
;
}
this
.
listSearchMenuitemIndicators
.
clear
(
)
;
}
}
;
