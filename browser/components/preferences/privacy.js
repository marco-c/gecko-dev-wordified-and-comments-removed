const
PREF_UPLOAD_ENABLED
=
"
datareporting
.
healthreport
.
uploadEnabled
"
;
const
TRACKING_PROTECTION_KEY
=
"
websites
.
trackingProtectionMode
"
;
const
TRACKING_PROTECTION_PREFS
=
[
"
privacy
.
trackingprotection
.
enabled
"
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
]
;
const
CONTENT_BLOCKING_PREFS
=
[
"
privacy
.
trackingprotection
.
enabled
"
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
"
network
.
cookie
.
cookieBehavior
"
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
"
privacy
.
firstparty
.
isolate
"
"
privacy
.
trackingprotection
.
emailtracking
.
enabled
"
"
privacy
.
trackingprotection
.
emailtracking
.
pbmode
.
enabled
"
"
privacy
.
fingerprintingProtection
"
"
privacy
.
fingerprintingProtection
.
pbmode
"
"
privacy
.
trackingprotection
.
allow_list
.
baseline
.
enabled
"
"
privacy
.
trackingprotection
.
allow_list
.
convenience
.
enabled
"
]
;
const
PREF_OPT_OUT_STUDIES_ENABLED
=
"
app
.
shield
.
optoutstudies
.
enabled
"
;
const
PREF_NORMANDY_ENABLED
=
"
app
.
normandy
.
enabled
"
;
const
PREF_ADDON_RECOMMENDATIONS_ENABLED
=
"
browser
.
discovery
.
enabled
"
;
const
PREF_PASSWORD_GENERATION_AVAILABLE
=
"
signon
.
generation
.
available
"
;
const
{
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
}
=
Ci
.
nsICookieService
;
const
PASSWORD_MANAGER_PREF_ID
=
"
services
.
passwordSavingEnabled
"
;
ChromeUtils
.
defineLazyGetter
(
this
"
AlertsServiceDND
"
function
(
)
{
try
{
let
alertsService
=
Cc
[
"
mozilla
.
org
/
alerts
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAlertsService
)
.
QueryInterface
(
Ci
.
nsIAlertsDoNotDisturb
)
;
alertsService
.
manualDoNotDisturb
;
return
alertsService
;
}
catch
(
ex
)
{
return
undefined
;
}
}
)
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
AboutLoginsL10n
"
(
)
=
>
{
return
new
Localization
(
[
"
branding
/
brand
.
ftl
"
"
browser
/
aboutLogins
.
ftl
"
]
)
;
}
)
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
gParentalControlsService
"
(
)
=
>
"
mozilla
.
org
/
parental
-
controls
-
service
;
1
"
in
Cc
?
Cc
[
"
mozilla
.
org
/
parental
-
controls
-
service
;
1
"
]
.
getService
(
Ci
.
nsIParentalControlsService
)
:
null
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
TrackingDBService
"
"
mozilla
.
org
/
tracking
-
db
-
service
;
1
"
"
nsITrackingDBService
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gIsFirstPartyIsolated
"
"
privacy
.
firstparty
.
isolate
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
useOldClearHistoryDialog
"
"
privacy
.
sanitize
.
useOldClearHistoryDialog
"
false
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AppUpdater
:
"
resource
:
/
/
gre
/
modules
/
AppUpdater
.
sys
.
mjs
"
DoHConfigController
:
"
moz
-
src
:
/
/
/
toolkit
/
components
/
doh
/
DoHConfig
.
sys
.
mjs
"
Sanitizer
:
"
resource
:
/
/
/
modules
/
Sanitizer
.
sys
.
mjs
"
SelectableProfileService
:
"
resource
:
/
/
/
modules
/
profiles
/
SelectableProfileService
.
sys
.
mjs
"
}
)
;
const
SANITIZE_ON_SHUTDOWN_MAPPINGS
=
{
history
:
"
privacy
.
clearOnShutdown
.
history
"
downloads
:
"
privacy
.
clearOnShutdown
.
downloads
"
formdata
:
"
privacy
.
clearOnShutdown
.
formdata
"
sessions
:
"
privacy
.
clearOnShutdown
.
sessions
"
siteSettings
:
"
privacy
.
clearOnShutdown
.
siteSettings
"
cookies
:
"
privacy
.
clearOnShutdown
.
cookies
"
cache
:
"
privacy
.
clearOnShutdown
.
cache
"
offlineApps
:
"
privacy
.
clearOnShutdown
.
offlineApps
"
}
;
const
SANITIZE_ON_SHUTDOWN_PREFS_ONLY
=
[
"
privacy
.
clearOnShutdown
.
history
"
"
privacy
.
clearOnShutdown
.
downloads
"
"
privacy
.
clearOnShutdown
.
sessions
"
"
privacy
.
clearOnShutdown
.
formdata
"
"
privacy
.
clearOnShutdown
.
siteSettings
"
]
;
const
SANITIZE_ON_SHUTDOWN_PREFS_ONLY_V2
=
[
"
privacy
.
clearOnShutdown_v2
.
browsingHistoryAndDownloads
"
"
privacy
.
clearOnShutdown_v2
.
siteSettings
"
]
;
Preferences
.
addAll
(
[
{
id
:
"
privacy
.
trackingprotection
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
emailtracking
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
emailtracking
.
pbmode
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
allow_list
.
baseline
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
allow_list
.
convenience
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
fingerprintingProtection
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
fingerprintingProtection
.
pbmode
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
resistFingerprinting
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
resistFingerprinting
.
pbmode
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
socialtracking
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
socialtracking
.
block_cookies
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
urlclassifier
.
trackingTable
"
type
:
"
string
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
cookie_exceptions
"
type
:
"
bool
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
tracking_protection_exceptions
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
bookmark
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
clipboard
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
history
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
openpage
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
topsites
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
engines
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
nonsponsored
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
quicksuggest
.
sponsored
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
quicksuggest
.
dataCollection
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
places
.
history
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
formfill
.
enable
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
history
.
custom
"
type
:
"
bool
"
}
{
id
:
"
network
.
cookie
.
cookieBehavior
"
type
:
"
int
"
}
{
id
:
"
network
.
cookie
.
blockFutureCookies
"
type
:
"
bool
"
}
{
id
:
"
browser
.
contentblocking
.
category
"
type
:
"
string
"
}
{
id
:
"
browser
.
contentblocking
.
features
.
strict
"
type
:
"
string
"
}
{
id
:
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
sanitize
.
timeSpan
"
type
:
"
int
"
}
{
id
:
"
privacy
.
clearOnShutdown
.
cookies
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown_v2
.
cookiesAndStorage
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown
.
cache
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown_v2
.
cache
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown
.
offlineApps
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown
.
history
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown_v2
.
browsingHistoryAndDownloads
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown
.
downloads
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown
.
sessions
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown
.
formdata
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown
.
siteSettings
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
clearOnShutdown_v2
.
siteSettings
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
donottrackheader
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
globalprivacycontrol
.
functionality
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
globalprivacycontrol
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
media
.
autoplay
.
default
"
type
:
"
int
"
}
{
id
:
"
dom
.
disable_open_during_load
"
type
:
"
bool
"
}
{
id
:
"
signon
.
rememberSignons
"
type
:
"
bool
"
}
{
id
:
"
signon
.
generation
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
signon
.
autofillForms
"
type
:
"
bool
"
}
{
id
:
"
signon
.
management
.
page
.
breach
-
alerts
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
signon
.
firefoxRelay
.
feature
"
type
:
"
string
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
view_passwords
"
type
:
"
bool
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
view_passwords_exceptions
"
type
:
"
bool
"
}
{
id
:
"
security
.
default_personal_cert
"
type
:
"
string
"
}
{
id
:
"
security
.
disable_button
.
openCertManager
"
type
:
"
bool
"
}
{
id
:
"
security
.
disable_button
.
openDeviceManager
"
type
:
"
bool
"
}
{
id
:
"
security
.
enterprise_roots
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
xpinstall
.
whitelist
.
required
"
type
:
"
bool
"
}
{
id
:
"
browser
.
safebrowsing
.
malware
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
safebrowsing
.
phishing
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
safebrowsing
.
downloads
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
urlclassifier
.
malwareTable
"
type
:
"
string
"
}
{
id
:
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_potentially_unwanted
"
type
:
"
bool
"
}
{
id
:
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_uncommon
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
firstparty
.
isolate
"
type
:
"
bool
"
}
{
id
:
"
dom
.
security
.
https_only_mode
"
type
:
"
bool
"
}
{
id
:
"
dom
.
security
.
https_only_mode_pbm
"
type
:
"
bool
"
}
{
id
:
"
dom
.
security
.
https_first
"
type
:
"
bool
"
}
{
id
:
"
dom
.
security
.
https_first_pbm
"
type
:
"
bool
"
}
{
id
:
"
network
.
http
.
windows
-
sso
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
quickactions
.
showPrefs
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
quickactions
"
type
:
"
bool
"
}
{
id
:
"
cookiebanners
.
ui
.
desktop
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
cookiebanners
.
service
.
mode
.
privateBrowsing
"
type
:
"
int
"
}
{
id
:
"
network
.
trr
.
mode
"
type
:
"
int
"
}
{
id
:
"
network
.
trr
.
uri
"
type
:
"
string
"
}
{
id
:
"
network
.
trr
.
default_provider_uri
"
type
:
"
string
"
}
{
id
:
"
network
.
trr
.
custom_uri
"
type
:
"
string
"
}
{
id
:
"
doh
-
rollout
.
disable
-
heuristics
"
type
:
"
bool
"
}
{
id
:
"
network
.
lna
.
blocking
"
type
:
"
bool
"
}
]
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
ui
.
status_card
"
false
)
)
{
Preferences
.
addAll
(
[
{
id
:
"
privacy
.
ui
.
status_card
.
testing
.
show_issue
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningTest
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningAllowFingerprinters
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningThirdPartyCookies
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningPasswordManager
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningPopupBlocker
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningExtensionInstall
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningSafeBrowsing
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningDoH
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningECH
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningCT
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningCRLite
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningCertificatePinning
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningTLSMin
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningTLSMax
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningProxyAutodetection
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningPrivelegedConstraint
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningProcessSandbox
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningContentResourceURI
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningWorkerMIME
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningTopLevelDataURI
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningActiveMixedContent
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningInnerHTMLltgt
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
config_warning
.
warningFileURIOrigin
.
dismissed
"
type
:
"
bool
"
}
{
id
:
"
services
.
passwordSavingEnabled
"
type
:
"
bool
"
}
{
id
:
"
network
.
dns
.
echconfig
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
network
.
dns
.
http3_echconfig
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
pki
.
certificate_transparency
.
mode
"
type
:
"
int
"
}
{
id
:
"
security
.
pki
.
crlite_mode
"
type
:
"
int
"
}
{
id
:
"
security
.
cert_pinning
.
enforcement_level
"
type
:
"
int
"
}
{
id
:
"
security
.
tls
.
version
.
min
"
type
:
"
int
"
}
{
id
:
"
security
.
tls
.
version
.
fallback
-
limit
"
type
:
"
int
"
}
{
id
:
"
security
.
tls
.
version
.
enable
-
deprecated
"
type
:
"
bool
"
}
{
id
:
"
security
.
tls
.
version
.
max
"
type
:
"
int
"
}
{
id
:
"
network
.
proxy
.
type
"
type
:
"
int
"
}
{
id
:
"
security
.
all_resource_uri_content_accessible
"
type
:
"
bool
"
}
{
id
:
"
security
.
block_Worker_with_wrong_mime
"
type
:
"
bool
"
}
{
id
:
"
security
.
data_uri
.
block_toplevel_data_uri_navigations
"
type
:
"
bool
"
}
{
id
:
"
security
.
mixed_content
.
block_active_content
"
type
:
"
bool
"
}
{
id
:
"
dom
.
security
.
html_serialization_escape_lt_gt
"
type
:
"
bool
"
}
{
id
:
"
security
.
fileuri
.
strict_origin_policy
"
type
:
"
bool
"
}
{
id
:
"
security
.
disallow_privilegedabout_remote_script_loads
"
type
:
"
bool
"
}
{
id
:
"
dom
.
security
.
skip_html_fragment_assertion
"
type
:
"
bool
"
}
{
id
:
"
security
.
browser_xhtml_csp
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
allow_unsafe_dangerous_privileged_evil_eval
"
type
:
"
bool
"
}
{
id
:
"
security
.
allow_eval_in_parent_process
"
type
:
"
bool
"
}
{
id
:
"
security
.
allow_eval_with_system_principal
"
type
:
"
bool
"
}
{
id
:
"
security
.
allow_unsafe_parent_loads
"
type
:
"
bool
"
}
{
id
:
"
security
.
allow_parent_unrestricted_js_loads
"
type
:
"
bool
"
}
{
id
:
"
dom
.
security
.
skip_remote_script_assertion_in_system_priv_context
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
content
.
mac
.
disconnect
-
windowserver
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
content
.
write_path_whitelist
"
type
:
"
string
"
}
{
id
:
"
security
.
sandbox
.
content
.
read_path_whitelist
"
type
:
"
string
"
}
{
id
:
"
security
.
sandbox
.
content
.
syscall_whitelist
"
type
:
"
string
"
}
{
id
:
"
security
.
sandbox
.
content
.
level
"
type
:
"
int
"
}
{
id
:
"
security
.
sandbox
.
socket
.
process
.
level
"
type
:
"
int
"
}
{
id
:
"
security
.
sandbox
.
gpu
.
level
"
type
:
"
int
"
}
{
id
:
"
security
.
sandbox
.
content
.
win32k
-
disable
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
gmp
.
win32k
-
disable
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
gmp
.
acg
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
socket
.
win32k
-
disable
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
rdd
.
shadow
-
stack
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
socket
.
shadow
-
stack
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
gpu
.
shadow
-
stack
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
gmp
.
shadow
-
stack
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
utility
-
wmf
-
cdm
.
lpac
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
rdd
.
acg
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
security
.
sandbox
.
utility
-
wmf
.
acg
.
enabled
"
type
:
"
bool
"
}
]
)
;
Preferences
.
addSetting
(
{
id
:
"
etpStrictEnabled
"
pref
:
"
browser
.
contentblocking
.
category
"
get
:
prefValue
=
>
prefValue
=
=
"
strict
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
trackerCount
"
cachedValue
:
null
async
setup
(
emitChange
)
{
const
now
=
Date
.
now
(
)
;
const
aMonthAgo
=
new
Date
(
now
-
30
*
24
*
60
*
60
*
1000
)
;
const
events
=
await
lazy
.
TrackingDBService
.
getEventsByDateRange
(
now
aMonthAgo
)
;
const
total
=
events
.
reduce
(
(
acc
day
)
=
>
{
return
acc
+
day
.
getResultByName
(
"
count
"
)
;
}
0
)
;
this
.
cachedValue
=
total
;
emitChange
(
)
;
}
get
(
)
{
return
this
.
cachedValue
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
appUpdateStatus
"
cachedValue
:
AppUpdater
.
STATUS
.
NO_UPDATER
async
setup
(
emitChange
)
{
if
(
AppConstants
.
MOZ_UPDATER
&
&
!
gIsPackagedApp
)
{
let
appUpdater
=
new
AppUpdater
(
)
;
let
listener
=
(
status
.
.
.
_args
)
=
>
{
this
.
cachedValue
=
status
;
emitChange
(
)
;
}
;
appUpdater
.
addListener
(
listener
)
;
await
appUpdater
.
check
(
)
;
return
(
)
=
>
{
appUpdater
.
removeListener
(
listener
)
;
appUpdater
.
stop
(
)
;
}
;
}
return
(
)
=
>
{
}
;
}
get
(
)
{
return
this
.
cachedValue
;
}
set
(
value
)
{
this
.
cachedValue
=
value
;
}
}
)
;
}
class
WarningSettingConfig
{
constructor
(
id
prefMapping
problematic
isDismissable
)
{
this
.
id
=
id
;
this
.
prefMapping
=
prefMapping
;
if
(
isDismissable
)
{
this
.
dismissedPrefId
=
browser
.
preferences
.
config_warning
.
{
this
.
id
}
.
dismissed
;
this
.
prefMapping
.
dismissed
=
this
.
dismissedPrefId
;
}
this
.
problematic
=
problematic
;
}
visible
(
)
{
return
!
this
.
dismissed
?
.
value
&
&
this
.
problematic
(
this
)
;
}
reset
(
)
{
for
(
let
getter
of
Object
.
keys
(
this
.
prefMapping
)
)
{
if
(
this
[
getter
]
.
hasUserValue
)
{
this
[
getter
]
.
reset
(
)
;
}
}
}
dismiss
(
)
{
if
(
this
.
dismissed
)
{
this
.
dismissed
.
value
=
true
;
}
}
setup
(
emitChange
)
{
for
(
let
[
getter
prefId
]
of
Object
.
entries
(
this
.
prefMapping
)
)
{
this
[
getter
]
=
Preferences
.
get
(
prefId
)
;
this
[
getter
]
.
on
(
"
change
"
emitChange
)
;
}
return
(
)
=
>
{
for
(
let
getter
of
Object
.
keys
(
this
.
prefMapping
)
)
{
this
[
getter
]
.
off
(
emitChange
)
;
}
}
;
}
onUserClick
(
event
)
{
switch
(
event
.
target
.
id
)
{
case
"
reset
"
:
{
this
.
reset
(
)
;
break
;
}
case
"
dismiss
"
:
{
this
.
dismiss
(
)
;
break
;
}
}
}
}
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
ui
.
status_card
"
false
)
)
{
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningTest
"
{
showIssue
:
"
privacy
.
ui
.
status_card
.
testing
.
show_issue
"
}
(
{
showIssue
}
)
=
>
showIssue
.
hasUserValue
&
&
!
showIssue
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningAllowFingerprinters
"
{
fingerprintingEnabled
:
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
}
(
{
fingerprintingEnabled
}
)
=
>
!
fingerprintingEnabled
.
value
&
&
!
fingerprintingEnabled
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningThirdPartyCookies
"
{
cookieBehavior
:
"
network
.
cookie
.
cookieBehavior
"
}
(
{
cookieBehavior
}
)
=
>
(
cookieBehavior
.
value
=
=
0
|
|
cookieBehavior
.
value
=
=
3
|
|
cookieBehavior
.
value
=
=
4
)
&
&
!
cookieBehavior
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningPasswordManager
"
{
enabled
:
"
signon
.
rememberSignons
"
extentionAllows
:
"
services
.
passwordSavingEnabled
"
}
(
{
enabled
extentionAllows
}
)
=
>
!
enabled
.
value
&
&
!
enabled
.
locked
&
&
!
extentionAllows
.
value
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningPopupBlocker
"
{
enabled
:
"
dom
.
disable_open_during_load
"
}
(
{
enabled
}
)
=
>
!
enabled
.
value
&
&
!
enabled
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningExtensionInstall
"
{
blockInstalls
:
"
xpinstall
.
whitelist
.
required
"
}
(
{
blockInstalls
}
)
=
>
!
blockInstalls
.
value
&
&
!
blockInstalls
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningSafeBrowsing
"
{
malware
:
"
browser
.
safebrowsing
.
malware
.
enabled
"
phishing
:
"
browser
.
safebrowsing
.
phishing
.
enabled
"
downloads
:
"
browser
.
safebrowsing
.
downloads
.
enabled
"
unwantedDownloads
:
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_potentially_unwanted
"
uncommonDownloads
:
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_potentially_unwanted
"
}
(
{
malware
phishing
downloads
unwantedDownloads
uncommonDownloads
}
)
=
>
(
!
malware
.
value
&
&
!
malware
.
locked
)
|
|
(
!
phishing
.
value
&
&
!
phishing
.
locked
)
|
|
(
!
downloads
.
value
&
&
!
downloads
.
locked
)
|
|
(
!
unwantedDownloads
.
value
&
&
!
unwantedDownloads
.
locked
)
|
|
(
!
uncommonDownloads
.
value
&
&
!
uncommonDownloads
.
locked
)
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningDoH
"
{
dohMode
:
"
network
.
trr
.
mode
"
}
(
{
dohMode
}
)
=
>
dohMode
.
value
=
=
5
&
&
!
dohMode
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningECH
"
{
echEnabled
:
"
network
.
dns
.
echconfig
.
enabled
"
https3echEnabled
:
"
network
.
dns
.
http3_echconfig
.
enabled
"
}
(
{
echEnabled
https3echEnabled
}
)
=
>
(
!
echEnabled
.
value
&
&
!
echEnabled
.
locked
)
|
|
(
!
https3echEnabled
.
value
&
&
!
https3echEnabled
.
locked
)
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningCT
"
{
ctMode
:
"
security
.
pki
.
certificate_transparency
.
mode
"
}
(
{
ctMode
}
)
=
>
ctMode
.
value
!
=
2
&
&
!
ctMode
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningCRLite
"
{
crliteMode
:
"
security
.
pki
.
crlite_mode
"
}
(
{
crliteMode
}
)
=
>
crliteMode
.
value
!
=
2
&
&
!
crliteMode
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningCertificatePinning
"
{
pinningLevel
:
"
security
.
cert_pinning
.
enforcement_level
"
}
(
{
pinningLevel
}
)
=
>
pinningLevel
.
value
<
1
&
&
!
pinningLevel
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningTLSMin
"
{
tlsMin
:
"
security
.
tls
.
version
.
min
"
enableDeprecated
:
"
security
.
tls
.
version
.
enable
-
deprecated
"
fallbackLimit
:
"
security
.
tls
.
version
.
fallback
-
limit
"
}
(
{
tlsMin
enableDeprecated
fallbackLimit
}
)
=
>
(
tlsMin
.
value
<
3
&
&
!
tlsMin
.
locked
)
|
|
(
enableDeprecated
.
value
&
&
!
tlsMin
.
locked
)
|
|
(
fallbackLimit
.
value
<
4
&
&
!
tlsMin
.
locked
)
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningTLSMax
"
{
tlsMax
:
"
security
.
tls
.
version
.
max
"
}
(
{
tlsMax
}
)
=
>
tlsMax
.
value
<
4
&
&
!
tlsMax
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningProxyAutodetection
"
{
proxyType
:
"
network
.
proxy
.
type
"
}
(
{
proxyType
}
)
=
>
proxyType
.
value
=
=
2
&
&
!
proxyType
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningContentResourceURI
"
{
contentResourceURIAccessible
:
"
security
.
all_resource_uri_content_accessible
"
}
(
{
contentResourceURIAccessible
}
)
=
>
contentResourceURIAccessible
.
value
&
&
!
contentResourceURIAccessible
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningWorkerMIME
"
{
workerMimeTypeBlock
:
"
security
.
block_Worker_with_wrong_mime
"
}
(
{
workerMimeTypeBlock
}
)
=
>
!
workerMimeTypeBlock
.
value
&
&
!
workerMimeTypeBlock
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningTopLevelDataURI
"
{
blockNav
:
"
security
.
data_uri
.
block_toplevel_data_uri_navigations
"
}
(
{
blockNav
}
)
=
>
!
blockNav
.
value
&
&
!
blockNav
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningActiveMixedContent
"
{
blockedMixedContent
:
"
security
.
mixed_content
.
block_active_content
"
}
(
{
blockedMixedContent
}
)
=
>
!
blockedMixedContent
.
value
&
&
!
blockedMixedContent
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningInnerHTMLltgt
"
{
escapeLtGt
:
"
dom
.
security
.
html_serialization_escape_lt_gt
"
}
(
{
escapeLtGt
}
)
=
>
!
escapeLtGt
.
value
&
&
!
escapeLtGt
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningFileURIOrigin
"
{
fileURIStrictOrigin
:
"
security
.
fileuri
.
strict_origin_policy
"
}
(
{
fileURIStrictOrigin
}
)
=
>
!
fileURIStrictOrigin
.
value
&
&
!
fileURIStrictOrigin
.
locked
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningPrivelegedConstraint
"
{
rsl
:
"
security
.
disallow_privilegedabout_remote_script_loads
"
shfa
:
"
dom
.
security
.
skip_html_fragment_assertion
"
xhtmlcsp
:
"
security
.
browser_xhtml_csp
.
enabled
"
allowUDPEE
:
"
security
.
allow_unsafe_dangerous_privileged_evil_eval
"
allowEvalInParent
:
"
security
.
allow_eval_in_parent_process
"
allowEvalBySystem
:
"
security
.
allow_eval_with_system_principal
"
allowUnsafeParentLoads
:
"
security
.
allow_unsafe_parent_loads
"
allowParentUnrestrictedJSLoads
:
"
security
.
allow_parent_unrestricted_js_loads
"
skipRemoteScriptAssertionInSystem
:
"
dom
.
security
.
skip_remote_script_assertion_in_system_priv_context
"
}
(
{
rsl
shfa
xhtmlcsp
allowUDPEE
allowEvalInParent
allowEvalBySystem
allowUnsafeParentLoads
allowParentUnrestrictedJSLoads
skipRemoteScriptAssertionInSystem
}
)
=
>
(
!
rsl
.
value
&
&
!
rsl
.
locked
)
|
|
(
!
xhtmlcsp
.
value
&
&
!
xhtmlcsp
.
locked
)
|
|
(
shfa
.
value
&
&
!
shfa
.
locked
)
|
|
(
allowUDPEE
.
value
&
&
!
allowUDPEE
.
locked
)
|
|
(
allowEvalInParent
.
value
&
&
!
allowEvalInParent
.
locked
)
|
|
(
allowEvalBySystem
.
value
&
&
!
allowEvalBySystem
.
locked
)
|
|
(
allowUnsafeParentLoads
.
value
&
&
!
allowUnsafeParentLoads
.
locked
)
|
|
(
allowParentUnrestrictedJSLoads
.
value
&
&
!
allowParentUnrestrictedJSLoads
.
locked
)
|
|
(
skipRemoteScriptAssertionInSystem
.
value
&
&
!
skipRemoteScriptAssertionInSystem
.
locked
)
true
)
)
;
Preferences
.
addSetting
(
new
WarningSettingConfig
(
"
warningProcessSandbox
"
{
macNoWindowServer
:
"
security
.
sandbox
.
content
.
mac
.
disconnect
-
windowserver
"
contentWriteWhitelist
:
"
security
.
sandbox
.
content
.
write_path_whitelist
"
contentReadWhitelist
:
"
security
.
sandbox
.
content
.
read_path_whitelist
"
contentSyscallWhitelist
:
"
security
.
sandbox
.
content
.
syscall_whitelist
"
contentSandboxLevel
:
"
security
.
sandbox
.
content
.
level
"
socketSandboxLevel
:
"
security
.
sandbox
.
socket
.
process
.
level
"
gpuSandboxLevel
:
"
security
.
sandbox
.
gpu
.
level
"
content32kDisable
:
"
security
.
sandbox
.
content
.
win32k
-
disable
"
gmp32kDisable
:
"
security
.
sandbox
.
gmp
.
win32k
-
disable
"
gmpACGEnable
:
"
security
.
sandbox
.
gmp
.
acg
.
enabled
"
socket32kDisable
:
"
security
.
sandbox
.
socket
.
win32k
-
disable
"
rddShadowStackEnabled
:
"
security
.
sandbox
.
rdd
.
shadow
-
stack
.
enabled
"
socketShadowStackEnabled
:
"
security
.
sandbox
.
socket
.
shadow
-
stack
.
enabled
"
gpuShadowStackEnabled
:
"
security
.
sandbox
.
gpu
.
shadow
-
stack
.
enabled
"
gmpShadowStackEnabled
:
"
security
.
sandbox
.
gmp
.
shadow
-
stack
.
enabled
"
utilityWmfCdmLpacEnabled
:
"
security
.
sandbox
.
utility
-
wmf
-
cdm
.
lpac
.
enabled
"
rddACGEnabled
:
"
security
.
sandbox
.
rdd
.
acg
.
enabled
"
utilityWmfACGEnabled
:
"
security
.
sandbox
.
utility
-
wmf
.
acg
.
enabled
"
}
(
{
macNoWindowServer
contentWriteWhitelist
contentReadWhitelist
contentSyscallWhitelist
contentSandboxLevel
socketSandboxLevel
gpuSandboxLevel
content32kDisable
gmp32kDisable
gmpACGEnable
socket32kDisable
rddShadowStackEnabled
socketShadowStackEnabled
gpuShadowStackEnabled
gmpShadowStackEnabled
utilityWmfCdmLpacEnabled
rddACGEnabled
utilityWmfACGEnabled
}
)
=
>
(
macNoWindowServer
.
hasUserValue
&
&
!
macNoWindowServer
.
locked
)
|
|
(
contentWriteWhitelist
.
hasUserValue
&
&
!
contentWriteWhitelist
.
locked
)
|
|
(
contentReadWhitelist
.
hasUserValue
&
&
!
contentReadWhitelist
.
locked
)
|
|
(
contentSyscallWhitelist
.
hasUserValue
&
&
!
contentSyscallWhitelist
.
locked
)
|
|
(
contentSandboxLevel
.
hasUserValue
&
&
!
contentSandboxLevel
.
locked
)
|
|
(
socketSandboxLevel
.
hasUserValue
&
&
!
socketSandboxLevel
.
locked
)
|
|
(
gpuSandboxLevel
.
hasUserValue
&
&
!
gpuSandboxLevel
.
locked
)
|
|
(
content32kDisable
.
hasUserValue
&
&
!
content32kDisable
.
locked
)
|
|
(
gmp32kDisable
.
hasUserValue
&
&
!
gmp32kDisable
.
locked
)
|
|
(
gmpACGEnable
.
hasUserValue
&
&
!
gmpACGEnable
.
locked
)
|
|
(
socket32kDisable
.
hasUserValue
&
&
!
socket32kDisable
.
locked
)
|
|
(
rddShadowStackEnabled
.
hasUserValue
&
&
!
rddShadowStackEnabled
.
locked
)
|
|
(
socketShadowStackEnabled
.
hasUserValue
&
&
!
socketShadowStackEnabled
.
locked
)
|
|
(
gpuShadowStackEnabled
.
hasUserValue
&
&
!
gpuShadowStackEnabled
.
locked
)
|
|
(
gmpShadowStackEnabled
.
hasUserValue
&
&
!
gmpShadowStackEnabled
.
locked
)
|
|
(
utilityWmfCdmLpacEnabled
.
hasUserValue
&
&
!
utilityWmfCdmLpacEnabled
.
locked
)
|
|
(
rddACGEnabled
.
hasUserValue
&
&
!
rddACGEnabled
.
locked
)
|
|
(
utilityWmfACGEnabled
.
hasUserValue
&
&
!
utilityWmfACGEnabled
.
locked
)
true
)
)
;
}
const
SECURITY_WARNINGS
=
[
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
test
"
id
:
"
warningTest
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
fingerprinters
"
id
:
"
warningAllowFingerprinters
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
third
-
party
-
cookies
"
id
:
"
warningThirdPartyCookies
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
password
-
manager
"
id
:
"
warningPasswordManager
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
popup
-
blocker
"
id
:
"
warningPopupBlocker
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
extension
-
install
"
id
:
"
warningExtensionInstall
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
safe
-
browsing
"
id
:
"
warningSafeBrowsing
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
doh
"
id
:
"
warningDoH
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
ech
"
id
:
"
warningECH
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
ct
"
id
:
"
warningCT
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
crlite
"
id
:
"
warningCRLite
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
certificate
-
pinning
"
id
:
"
warningCertificatePinning
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
tlsmin
"
id
:
"
warningTLSMin
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
tlsmax
"
id
:
"
warningTLSMax
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
proxy
-
autodetection
"
id
:
"
warningProxyAutodetection
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
content
-
resource
-
uri
"
id
:
"
warningContentResourceURI
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
worker
-
mime
"
id
:
"
warningWorkerMIME
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
top
-
level
-
data
-
uri
"
id
:
"
warningTopLevelDataURI
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
active
-
mixed
-
content
"
id
:
"
warningActiveMixedContent
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
inner
-
html
-
ltgt
"
id
:
"
warningInnerHTMLltgt
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
file
-
uri
-
origin
"
id
:
"
warningFileURIOrigin
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
priveleged
-
constraint
"
id
:
"
warningPrivelegedConstraint
"
}
{
l10nId
:
"
security
-
privacy
-
issue
-
warning
-
process
-
sandbox
"
id
:
"
warningProcessSandbox
"
}
]
;
Preferences
.
addSetting
(
{
id
:
"
securityWarningsGroup
"
makeSecurityWarningItems
(
)
{
return
SECURITY_WARNINGS
.
map
(
(
{
id
l10nId
}
)
=
>
(
{
id
l10nId
control
:
"
moz
-
box
-
item
"
options
:
[
{
control
:
"
moz
-
button
"
l10nId
:
"
issue
-
card
-
reset
-
button
"
controlAttrs
:
{
slot
:
"
actions
"
size
:
"
small
"
id
:
"
reset
"
}
}
{
control
:
"
moz
-
button
"
l10nId
:
"
issue
-
card
-
dismiss
-
button
"
controlAttrs
:
{
slot
:
"
actions
"
size
:
"
small
"
iconsrc
:
"
chrome
:
/
/
global
/
skin
/
icons
/
close
.
svg
"
id
:
"
dismiss
"
}
}
]
}
)
)
;
}
getControlConfig
(
config
)
{
if
(
!
config
.
items
)
{
return
{
.
.
.
config
items
:
this
.
makeSecurityWarningItems
(
)
}
;
}
return
config
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
privacyCard
"
deps
:
[
"
appUpdateStatus
"
"
trackerCount
"
"
etpStrictEnabled
"
.
.
.
SECURITY_WARNINGS
.
map
(
warning
=
>
warning
.
id
)
]
}
)
;
if
(
AppConstants
.
MOZ_DATA_REPORTING
)
{
Preferences
.
addAll
(
[
{
id
:
PREF_OPT_OUT_STUDIES_ENABLED
type
:
"
bool
"
}
{
id
:
PREF_ADDON_RECOMMENDATIONS_ENABLED
type
:
"
bool
"
}
{
id
:
PREF_UPLOAD_ENABLED
type
:
"
bool
"
}
{
id
:
"
datareporting
.
usage
.
uploadEnabled
"
type
:
"
bool
"
}
{
id
:
"
dom
.
private
-
attribution
.
submission
.
enabled
"
type
:
"
bool
"
}
]
)
;
}
Preferences
.
add
(
{
id
:
"
browser
.
dataFeatureRecommendations
.
enabled
"
type
:
"
bool
"
}
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
Preferences
.
add
(
{
id
:
"
browser
.
crashReports
.
unsubmittedCheck
.
autoSubmit2
"
type
:
"
bool
"
}
)
;
}
Preferences
.
addSetting
(
{
id
:
"
gpcFunctionalityEnabled
"
pref
:
"
privacy
.
globalprivacycontrol
.
functionality
.
enabled
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
gpcEnabled
"
pref
:
"
privacy
.
globalprivacycontrol
.
enabled
"
deps
:
[
"
gpcFunctionalityEnabled
"
]
visible
:
(
{
gpcFunctionalityEnabled
}
)
=
>
{
return
gpcFunctionalityEnabled
.
value
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
dntHeaderEnabled
"
pref
:
"
privacy
.
donottrackheader
.
enabled
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
dntRemoval
"
deps
:
[
"
dntHeaderEnabled
"
]
visible
:
(
{
dntHeaderEnabled
}
)
=
>
{
return
dntHeaderEnabled
.
value
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
httpsOnlyEnabled
"
pref
:
"
dom
.
security
.
https_only_mode
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
httpsOnlyEnabledPBM
"
pref
:
"
dom
.
security
.
https_only_mode_pbm
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
httpsOnlyRadioGroup
"
deps
:
[
"
httpsOnlyEnabled
"
"
httpsOnlyEnabledPBM
"
]
get
:
(
_value
deps
)
=
>
{
if
(
deps
.
httpsOnlyEnabled
.
value
)
{
return
"
enabled
"
;
}
if
(
deps
.
httpsOnlyEnabledPBM
.
value
)
{
return
"
privateOnly
"
;
}
return
"
disabled
"
;
}
set
:
(
value
deps
)
=
>
{
if
(
value
=
=
"
enabled
"
)
{
deps
.
httpsOnlyEnabled
.
value
=
true
;
deps
.
httpsOnlyEnabledPBM
.
value
=
false
;
}
else
if
(
value
=
=
"
privateOnly
"
)
{
deps
.
httpsOnlyEnabled
.
value
=
false
;
deps
.
httpsOnlyEnabledPBM
.
value
=
true
;
}
else
if
(
value
=
=
"
disabled
"
)
{
deps
.
httpsOnlyEnabled
.
value
=
false
;
deps
.
httpsOnlyEnabledPBM
.
value
=
false
;
}
}
disabled
:
deps
=
>
{
return
deps
.
httpsOnlyEnabled
.
locked
|
|
deps
.
httpsOnlyEnabledPBM
.
locked
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
httpsFirstEnabled
"
pref
:
"
dom
.
security
.
https_first
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
httpsFirstEnabledPBM
"
pref
:
"
dom
.
security
.
https_first_pbm
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
httpsOnlyExceptionButton
"
deps
:
[
"
httpsOnlyEnabled
"
"
httpsOnlyEnabledPBM
"
"
httpsFirstEnabled
"
"
httpsFirstEnabledPBM
"
]
disabled
:
deps
=
>
{
return
(
!
deps
.
httpsOnlyEnabled
.
value
&
&
!
deps
.
httpsOnlyEnabledPBM
.
value
&
&
!
deps
.
httpsFirstEnabled
.
value
&
&
!
deps
.
httpsFirstEnabledPBM
.
value
)
;
}
onUserClick
:
(
)
=
>
{
gPrivacyPane
.
showHttpsOnlyModeExceptions
(
)
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
enableSafeBrowsingPhishing
"
pref
:
"
browser
.
safebrowsing
.
phishing
.
enabled
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
enableSafeBrowsingMalware
"
pref
:
"
browser
.
safebrowsing
.
malware
.
enabled
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
enableSafeBrowsing
"
deps
:
[
"
enableSafeBrowsingPhishing
"
"
enableSafeBrowsingMalware
"
]
get
:
(
_value
deps
)
=
>
{
return
(
deps
.
enableSafeBrowsingPhishing
.
value
&
&
deps
.
enableSafeBrowsingMalware
.
value
)
;
}
set
:
(
value
deps
)
=
>
{
deps
.
enableSafeBrowsingPhishing
.
value
=
value
;
deps
.
enableSafeBrowsingMalware
.
value
=
value
;
}
disabled
:
deps
=
>
{
return
(
deps
.
enableSafeBrowsingPhishing
.
locked
|
|
deps
.
enableSafeBrowsingMalware
.
locked
)
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
blockDownloads
"
pref
:
"
browser
.
safebrowsing
.
downloads
.
enabled
"
deps
:
[
"
enableSafeBrowsing
"
]
disabled
:
(
deps
self
)
=
>
{
return
!
deps
.
enableSafeBrowsing
.
value
|
|
self
.
locked
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
malwareTable
"
pref
:
"
urlclassifier
.
malwareTable
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
blockUncommonDownloads
"
pref
:
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_uncommon
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
blockUnwantedDownloads
"
pref
:
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_potentially_unwanted
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
blockUncommonUnwanted
"
deps
:
[
"
enableSafeBrowsing
"
"
blockDownloads
"
"
blockUncommonDownloads
"
"
blockUnwantedDownloads
"
]
get
:
(
_value
deps
)
=
>
{
return
(
deps
.
blockUncommonDownloads
.
value
&
&
deps
.
blockUnwantedDownloads
.
value
)
;
}
set
:
(
value
deps
)
=
>
{
deps
.
blockUncommonDownloads
.
value
=
value
;
deps
.
blockUnwantedDownloads
.
value
=
value
;
let
malwareTable
=
Preferences
.
get
(
"
urlclassifier
.
malwareTable
"
)
;
let
malware
=
malwareTable
.
value
.
split
(
"
"
)
.
filter
(
x
=
>
x
!
=
=
"
goog
-
unwanted
-
proto
"
&
&
x
!
=
=
"
goog
-
unwanted
-
shavar
"
&
&
x
!
=
=
"
moztest
-
unwanted
-
simple
"
)
;
if
(
value
)
{
if
(
malware
.
includes
(
"
goog
-
malware
-
shavar
"
)
)
{
malware
.
push
(
"
goog
-
unwanted
-
shavar
"
)
;
}
else
{
malware
.
push
(
"
goog
-
unwanted
-
proto
"
)
;
}
malware
.
push
(
"
moztest
-
unwanted
-
simple
"
)
;
}
malware
.
sort
(
)
;
malwareTable
.
value
=
malware
.
join
(
"
"
)
;
listManager
.
forceUpdates
(
malwareTable
.
value
)
;
}
disabled
:
deps
=
>
{
return
(
!
deps
.
enableSafeBrowsing
.
value
|
|
!
deps
.
blockDownloads
.
value
|
|
deps
.
blockUncommonDownloads
.
locked
|
|
deps
.
blockUnwantedDownloads
.
locked
)
;
}
}
)
;
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gPrivacyPane
)
)
;
}
function
setSyncFromPrefListener
(
aId
aCallback
)
{
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
aId
)
aCallback
)
;
}
function
setSyncToPrefListener
(
aId
aCallback
)
{
Preferences
.
addSyncToPrefListener
(
document
.
getElementById
(
aId
)
aCallback
)
;
}
function
dataCollectionCheckboxHandler
(
{
checkbox
pref
matchPref
=
(
)
=
>
true
isDisabled
=
(
)
=
>
false
}
)
{
function
updateCheckbox
(
)
{
let
collectionEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_UPLOAD_ENABLED
false
)
;
if
(
collectionEnabled
&
&
matchPref
(
)
)
{
if
(
Services
.
prefs
.
getBoolPref
(
pref
false
)
)
{
checkbox
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
checkbox
.
removeAttribute
(
"
checked
"
)
;
}
checkbox
.
setAttribute
(
"
preference
"
pref
)
;
}
else
{
checkbox
.
removeAttribute
(
"
preference
"
)
;
checkbox
.
removeAttribute
(
"
checked
"
)
;
}
checkbox
.
disabled
=
!
collectionEnabled
|
|
Services
.
prefs
.
prefIsLocked
(
pref
)
|
|
isDisabled
(
)
;
}
Preferences
.
get
(
PREF_UPLOAD_ENABLED
)
.
on
(
"
change
"
updateCheckbox
)
;
updateCheckbox
(
)
;
}
function
setUpContentBlockingWarnings
(
)
{
document
.
getElementById
(
"
fpiIncompatibilityWarning
"
)
.
hidden
=
!
gIsFirstPartyIsolated
;
document
.
getElementById
(
"
rfpIncompatibilityWarning
"
)
.
hidden
=
!
Preferences
.
get
(
"
privacy
.
resistFingerprinting
"
)
.
value
&
&
!
Preferences
.
get
(
"
privacy
.
resistFingerprinting
.
pbmode
"
)
.
value
;
}
function
initTCPStandardSection
(
)
{
let
cookieBehaviorPref
=
Preferences
.
get
(
"
network
.
cookie
.
cookieBehavior
"
)
;
let
updateTCPSectionVisibilityState
=
(
)
=
>
{
document
.
getElementById
(
"
etpStandardTCPBox
"
)
.
hidden
=
cookieBehaviorPref
.
value
!
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
;
}
;
cookieBehaviorPref
.
on
(
"
change
"
updateTCPSectionVisibilityState
)
;
updateTCPSectionVisibilityState
(
)
;
}
var
gPrivacyPane
=
{
_pane
:
null
_shouldPromptForRestart
:
true
_updateTrackingProtectionUI
(
)
{
let
cBPrefisLocked
=
CONTENT_BLOCKING_PREFS
.
some
(
pref
=
>
Services
.
prefs
.
prefIsLocked
(
pref
)
)
;
let
tPPrefisLocked
=
TRACKING_PROTECTION_PREFS
.
some
(
pref
=
>
Services
.
prefs
.
prefIsLocked
(
pref
)
)
;
function
setInputsDisabledState
(
isControlled
)
{
let
tpDisabled
=
tPPrefisLocked
|
|
isControlled
;
let
disabled
=
cBPrefisLocked
|
|
isControlled
;
let
tpCheckbox
=
document
.
getElementById
(
"
contentBlockingTrackingProtectionCheckbox
"
)
;
document
.
getElementById
(
"
trackingProtectionMenu
"
)
.
disabled
=
tpDisabled
|
|
!
tpCheckbox
.
checked
;
tpCheckbox
.
disabled
=
tpDisabled
;
document
.
getElementById
(
"
standardRadio
"
)
.
disabled
=
disabled
;
document
.
getElementById
(
"
strictRadio
"
)
.
disabled
=
disabled
;
document
.
getElementById
(
"
contentBlockingOptionStrict
"
)
.
classList
.
toggle
(
"
disabled
"
disabled
)
;
document
.
getElementById
(
"
contentBlockingOptionStandard
"
)
.
classList
.
toggle
(
"
disabled
"
disabled
)
;
let
arrowButtons
=
document
.
querySelectorAll
(
"
button
.
arrowhead
"
)
;
for
(
let
button
of
arrowButtons
)
{
button
.
disabled
=
disabled
;
}
Services
.
obs
.
notifyObservers
(
window
"
privacy
-
pane
-
tp
-
ui
-
updated
"
)
;
}
let
policy
=
Services
.
policies
.
getActivePolicies
(
)
;
if
(
policy
&
&
(
(
policy
.
EnableTrackingProtection
&
&
policy
.
EnableTrackingProtection
.
Locked
)
|
|
(
policy
.
Cookies
&
&
policy
.
Cookies
.
Locked
)
)
)
{
setInputsDisabledState
(
true
)
;
}
if
(
tPPrefisLocked
)
{
hideControllingExtension
(
TRACKING_PROTECTION_KEY
)
;
setInputsDisabledState
(
false
)
;
}
else
{
handleControllingExtension
(
PREF_SETTING_TYPE
TRACKING_PROTECTION_KEY
)
.
then
(
setInputsDisabledState
)
;
}
}
_initTrackingProtectionExtensionControl
(
)
{
setEventListener
(
"
contentBlockingDisableTrackingProtectionExtension
"
"
command
"
makeDisableControllingExtension
(
PREF_SETTING_TYPE
TRACKING_PROTECTION_KEY
)
)
;
let
trackingProtectionObserver
=
{
observe
(
)
{
gPrivacyPane
.
_updateTrackingProtectionUI
(
)
;
}
}
;
for
(
let
pref
of
TRACKING_PROTECTION_PREFS
)
{
Services
.
prefs
.
addObserver
(
pref
trackingProtectionObserver
)
;
}
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
for
(
let
pref
of
TRACKING_PROTECTION_PREFS
)
{
Services
.
prefs
.
removeObserver
(
pref
trackingProtectionObserver
)
;
}
}
)
;
}
_ensureTrackingProtectionExceptionListMigration
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
trackingprotection
.
allow_list
.
hasMigratedCategoryPrefs
"
false
)
)
{
return
;
}
let
exceptionListService
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
exception
-
list
-
service
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierExceptionListService
)
;
exceptionListService
.
maybeMigrateCategoryPrefs
(
)
;
}
_initThirdPartyCertsToggle
(
)
{
let
canConfigureThirdPartyCerts
=
(
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
)
&
&
typeof
Services
.
policies
.
getActivePolicies
(
)
?
.
Certificates
?
.
ImportEnterpriseRoots
=
=
"
undefined
"
;
document
.
getElementById
(
"
certEnableThirdPartyToggleBox
"
)
.
hidden
=
!
canConfigureThirdPartyCerts
;
}
get
dnsOverHttpsResolvers
(
)
{
let
providers
=
DoHConfigController
.
currentConfig
.
providerList
;
let
defaultURI
=
DoHConfigController
.
currentConfig
.
fallbackProviderURI
;
let
defaultIndex
=
providers
.
findIndex
(
p
=
>
p
.
uri
=
=
defaultURI
)
;
if
(
defaultIndex
=
=
-
1
&
&
defaultURI
)
{
providers
.
unshift
(
{
uri
:
defaultURI
}
)
;
}
return
providers
;
}
updateDoHResolverList
(
mode
)
{
let
resolvers
=
this
.
dnsOverHttpsResolvers
;
let
currentURI
=
Preferences
.
get
(
"
network
.
trr
.
uri
"
)
.
value
;
if
(
!
currentURI
)
{
currentURI
=
Preferences
.
get
(
"
network
.
trr
.
default_provider_uri
"
)
.
value
;
}
let
menu
=
document
.
getElementById
(
{
mode
}
ResolverChoices
)
;
let
selectedIndex
=
currentURI
?
resolvers
.
findIndex
(
r
=
>
r
.
uri
=
=
currentURI
)
:
0
;
if
(
selectedIndex
=
=
-
1
)
{
selectedIndex
=
menu
.
itemCount
-
1
;
}
menu
.
selectedIndex
=
selectedIndex
;
let
customInput
=
document
.
getElementById
(
{
mode
}
InputField
)
;
customInput
.
hidden
=
menu
.
value
!
=
"
custom
"
;
}
populateDoHResolverList
(
mode
)
{
let
resolvers
=
this
.
dnsOverHttpsResolvers
;
let
defaultURI
=
DoHConfigController
.
currentConfig
.
fallbackProviderURI
;
let
menu
=
document
.
getElementById
(
{
mode
}
ResolverChoices
)
;
menu
.
removeAllItems
(
)
;
for
(
let
resolver
of
resolvers
)
{
let
item
=
menu
.
appendItem
(
undefined
resolver
.
uri
)
;
if
(
resolver
.
uri
=
=
defaultURI
)
{
document
.
l10n
.
setAttributes
(
item
"
connection
-
dns
-
over
-
https
-
url
-
item
-
default
"
{
name
:
resolver
.
UIName
|
|
resolver
.
uri
}
)
;
}
else
{
item
.
label
=
resolver
.
UIName
|
|
resolver
.
uri
;
}
}
let
lastItem
=
menu
.
appendItem
(
undefined
"
custom
"
)
;
document
.
l10n
.
setAttributes
(
lastItem
"
connection
-
dns
-
over
-
https
-
url
-
custom
"
)
;
this
.
updateDoHResolverList
(
mode
)
;
let
customInput
=
document
.
getElementById
(
{
mode
}
InputField
)
;
function
updateURIPref
(
)
{
if
(
customInput
.
value
=
=
"
"
)
{
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
uri
"
"
"
)
;
}
else
{
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
uri
"
customInput
.
value
)
;
}
}
menu
.
addEventListener
(
"
command
"
(
)
=
>
{
if
(
menu
.
value
=
=
"
custom
"
)
{
customInput
.
hidden
=
false
;
updateURIPref
(
)
;
}
else
{
customInput
.
hidden
=
true
;
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
uri
"
menu
.
value
)
;
}
Glean
.
securityDohSettings
.
providerChoiceValue
.
record
(
{
value
:
menu
.
value
}
)
;
let
otherMode
=
mode
=
=
"
dohEnabled
"
?
"
dohStrict
"
:
"
dohEnabled
"
;
let
otherMenu
=
document
.
getElementById
(
{
otherMode
}
ResolverChoices
)
;
let
otherInput
=
document
.
getElementById
(
{
otherMode
}
InputField
)
;
otherMenu
.
value
=
menu
.
value
;
otherInput
.
hidden
=
otherMenu
.
value
!
=
"
custom
"
;
}
)
;
customInput
.
addEventListener
(
"
change
"
(
)
=
>
{
updateURIPref
(
)
;
}
)
;
}
async
updateDoHStatus
(
)
{
let
trrURI
=
Services
.
dns
.
currentTrrURI
;
let
hostname
=
URL
.
parse
(
trrURI
)
?
.
hostname
;
if
(
!
hostname
)
{
hostname
=
await
document
.
l10n
.
formatValue
(
"
preferences
-
doh
-
bad
-
url
"
)
;
}
let
steering
=
document
.
getElementById
(
"
dohSteeringStatus
"
)
;
steering
.
hidden
=
true
;
let
dohResolver
=
document
.
getElementById
(
"
dohResolver
"
)
;
dohResolver
.
hidden
=
true
;
let
status
=
document
.
getElementById
(
"
dohStatus
"
)
;
async
function
setStatus
(
localizedStringName
options
)
{
let
opts
=
options
|
|
{
}
;
let
statusString
=
await
document
.
l10n
.
formatValue
(
localizedStringName
opts
)
;
document
.
l10n
.
setAttributes
(
status
"
preferences
-
doh
-
status
"
{
status
:
statusString
}
)
;
}
function
computeStatus
(
)
{
let
mode
=
Services
.
dns
.
currentTrrMode
;
if
(
mode
=
=
Ci
.
nsIDNSService
.
MODE_TRRFIRST
|
|
mode
=
=
Ci
.
nsIDNSService
.
MODE_TRRONLY
)
{
if
(
lazy
.
gParentalControlsService
?
.
parentalControlsEnabled
)
{
return
"
preferences
-
doh
-
status
-
not
-
active
"
;
}
let
confirmationState
=
Services
.
dns
.
currentTrrConfirmationState
;
switch
(
confirmationState
)
{
case
Ci
.
nsIDNSService
.
CONFIRM_TRYING_OK
:
case
Ci
.
nsIDNSService
.
CONFIRM_OK
:
case
Ci
.
nsIDNSService
.
CONFIRM_DISABLED
:
return
"
preferences
-
doh
-
status
-
active
"
;
default
:
return
"
preferences
-
doh
-
status
-
not
-
active
"
;
}
}
return
"
preferences
-
doh
-
status
-
disabled
"
;
}
let
errReason
=
"
"
;
let
confirmationStatus
=
Services
.
dns
.
lastConfirmationStatus
;
let
mode
=
Services
.
dns
.
currentTrrMode
;
if
(
(
mode
=
=
Ci
.
nsIDNSService
.
MODE_TRRFIRST
|
|
mode
=
=
Ci
.
nsIDNSService
.
MODE_TRRONLY
)
&
&
lazy
.
gParentalControlsService
?
.
parentalControlsEnabled
)
{
errReason
=
Services
.
dns
.
getTRRSkipReasonName
(
Ci
.
nsITRRSkipReason
.
TRR_PARENTAL_CONTROL
)
;
}
else
if
(
confirmationStatus
!
=
Cr
.
NS_OK
)
{
errReason
=
ChromeUtils
.
getXPCOMErrorName
(
confirmationStatus
)
;
}
else
{
errReason
=
Services
.
dns
.
getTRRSkipReasonName
(
Services
.
dns
.
lastConfirmationSkipReason
)
;
}
let
statusLabel
=
computeStatus
(
)
;
setStatus
(
statusLabel
{
reason
:
errReason
}
)
;
dohResolver
.
hidden
=
statusLabel
=
=
"
preferences
-
doh
-
status
-
disabled
"
;
let
statusLearnMore
=
document
.
getElementById
(
"
dohStatusLearnMore
"
)
;
statusLearnMore
.
hidden
=
statusLabel
!
=
"
preferences
-
doh
-
status
-
not
-
active
"
;
if
(
statusLabel
=
=
"
preferences
-
doh
-
status
-
disabled
"
)
{
return
;
}
function
nameOrDomain
(
)
{
for
(
let
resolver
of
DoHConfigController
.
currentConfig
.
providerList
)
{
if
(
resolver
.
uri
=
=
trrURI
)
{
return
resolver
.
UIName
|
|
hostname
|
|
trrURI
;
}
}
for
(
let
resolver
of
DoHConfigController
.
currentConfig
.
providerSteering
.
providerList
)
{
if
(
resolver
.
uri
=
=
trrURI
)
{
steering
.
hidden
=
false
;
return
resolver
.
UIName
|
|
hostname
|
|
trrURI
;
}
}
return
hostname
;
}
let
resolverNameOrDomain
=
nameOrDomain
(
)
;
document
.
l10n
.
setAttributes
(
dohResolver
"
preferences
-
doh
-
resolver
"
{
name
:
resolverNameOrDomain
}
)
;
}
highlightDoHCategoryAndUpdateStatus
(
)
{
let
value
=
Preferences
.
get
(
"
network
.
trr
.
mode
"
)
.
value
;
let
defaultOption
=
document
.
getElementById
(
"
dohOptionDefault
"
)
;
let
enabledOption
=
document
.
getElementById
(
"
dohOptionEnabled
"
)
;
let
strictOption
=
document
.
getElementById
(
"
dohOptionStrict
"
)
;
let
offOption
=
document
.
getElementById
(
"
dohOptionOff
"
)
;
defaultOption
.
classList
.
remove
(
"
selected
"
)
;
enabledOption
.
classList
.
remove
(
"
selected
"
)
;
strictOption
.
classList
.
remove
(
"
selected
"
)
;
offOption
.
classList
.
remove
(
"
selected
"
)
;
switch
(
value
)
{
case
Ci
.
nsIDNSService
.
MODE_NATIVEONLY
:
defaultOption
.
classList
.
add
(
"
selected
"
)
;
break
;
case
Ci
.
nsIDNSService
.
MODE_TRRFIRST
:
enabledOption
.
classList
.
add
(
"
selected
"
)
;
break
;
case
Ci
.
nsIDNSService
.
MODE_TRRONLY
:
strictOption
.
classList
.
add
(
"
selected
"
)
;
break
;
case
Ci
.
nsIDNSService
.
MODE_TRROFF
:
offOption
.
classList
.
add
(
"
selected
"
)
;
break
;
default
:
offOption
.
classList
.
add
(
"
selected
"
)
;
document
.
getElementById
(
"
dohCategoryRadioGroup
"
)
.
selectedIndex
=
3
;
break
;
}
if
(
value
=
=
Ci
.
nsIDNSService
.
MODE_NATIVEONLY
)
{
Services
.
prefs
.
clearUserPref
(
"
network
.
trr
.
uri
"
)
;
Services
.
prefs
.
clearUserPref
(
"
doh
-
rollout
.
disable
-
heuristics
"
)
;
}
if
(
value
=
=
Ci
.
nsIDNSService
.
MODE_TRRFIRST
|
|
value
=
=
Ci
.
nsIDNSService
.
MODE_TRRONLY
)
{
if
(
!
Services
.
prefs
.
getStringPref
(
"
network
.
trr
.
uri
"
)
)
{
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
uri
"
DoHConfigController
.
currentConfig
.
fallbackProviderURI
)
;
}
}
if
(
value
=
=
Ci
.
nsIDNSService
.
MODE_TRROFF
)
{
Services
.
prefs
.
clearUserPref
(
"
network
.
trr
.
uri
"
)
;
}
gPrivacyPane
.
updateDoHStatus
(
)
;
}
initDoH
(
)
{
setEventListener
(
"
dohDefaultArrow
"
"
command
"
this
.
toggleExpansion
)
;
setEventListener
(
"
dohEnabledArrow
"
"
command
"
this
.
toggleExpansion
)
;
setEventListener
(
"
dohStrictArrow
"
"
command
"
this
.
toggleExpansion
)
;
function
modeButtonPressed
(
e
)
{
if
(
parseInt
(
e
.
target
.
value
)
=
=
Preferences
.
get
(
"
network
.
trr
.
mode
"
)
.
value
)
{
return
;
}
Glean
.
securityDohSettings
.
modeChangedButton
.
record
(
{
value
:
e
.
target
.
id
}
)
;
}
setEventListener
(
"
dohDefaultRadio
"
"
command
"
modeButtonPressed
)
;
setEventListener
(
"
dohEnabledRadio
"
"
command
"
modeButtonPressed
)
;
setEventListener
(
"
dohStrictRadio
"
"
command
"
modeButtonPressed
)
;
setEventListener
(
"
dohOffRadio
"
"
command
"
modeButtonPressed
)
;
this
.
populateDoHResolverList
(
"
dohEnabled
"
)
;
this
.
populateDoHResolverList
(
"
dohStrict
"
)
;
Preferences
.
get
(
"
network
.
trr
.
uri
"
)
.
on
(
"
change
"
(
)
=
>
{
gPrivacyPane
.
updateDoHResolverList
(
"
dohEnabled
"
)
;
gPrivacyPane
.
updateDoHResolverList
(
"
dohStrict
"
)
;
gPrivacyPane
.
updateDoHStatus
(
)
;
}
)
;
Preferences
.
get
(
"
network
.
trr
.
mode
"
)
.
on
(
"
change
"
gPrivacyPane
.
highlightDoHCategoryAndUpdateStatus
)
;
this
.
highlightDoHCategoryAndUpdateStatus
(
)
;
Services
.
obs
.
addObserver
(
this
"
network
:
trr
-
uri
-
changed
"
)
;
Services
.
obs
.
addObserver
(
this
"
network
:
trr
-
mode
-
changed
"
)
;
Services
.
obs
.
addObserver
(
this
"
network
:
trr
-
confirmation
"
)
;
let
unload
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
this
"
network
:
trr
-
uri
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
network
:
trr
-
mode
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
network
:
trr
-
confirmation
"
)
;
}
;
window
.
addEventListener
(
"
unload
"
unload
{
once
:
true
}
)
;
let
uriPref
=
Services
.
prefs
.
getStringPref
(
"
network
.
trr
.
uri
"
)
;
if
(
uriPref
&
&
!
this
.
dnsOverHttpsResolvers
.
some
(
e
=
>
e
.
uri
=
=
uriPref
)
)
{
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
custom_uri
"
Services
.
prefs
.
getStringPref
(
"
network
.
trr
.
uri
"
)
)
;
}
if
(
Services
.
prefs
.
prefIsLocked
(
"
network
.
trr
.
mode
"
)
)
{
document
.
getElementById
(
"
dohCategoryRadioGroup
"
)
.
disabled
=
true
;
Services
.
prefs
.
setStringPref
(
"
network
.
trr
.
custom_uri
"
uriPref
)
;
}
}
initWebAuthn
(
)
{
document
.
getElementById
(
"
openWindowsPasskeySettings
"
)
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
security
.
webauthn
.
show_ms_settings_link
"
true
)
;
}
updateNonTechnicalPrivacySectionVisibility
(
)
{
let
allDisabled
=
!
Preferences
.
get
(
"
privacy
.
globalprivacycontrol
.
functionality
.
enabled
"
)
.
value
&
&
!
Preferences
.
get
(
"
privacy
.
donottrackheader
.
enabled
"
)
.
value
;
let
nonTechnicalPrivacyGroup
=
document
.
getElementById
(
"
nonTechnicalPrivacyGroup
"
)
;
if
(
allDisabled
)
{
nonTechnicalPrivacyGroup
.
style
.
display
=
"
none
"
;
}
else
{
nonTechnicalPrivacyGroup
.
style
.
display
=
"
"
;
}
}
initNonTechnicalPrivacySection
(
)
{
Preferences
.
get
(
"
privacy
.
globalprivacycontrol
.
functionality
.
enabled
"
)
.
on
(
"
change
"
gPrivacyPane
.
updateNonTechnicalPrivacySectionVisibility
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
privacy
.
donottrackheader
.
enabled
"
)
.
on
(
"
change
"
gPrivacyPane
.
updateNonTechnicalPrivacySectionVisibility
.
bind
(
gPrivacyPane
)
)
;
gPrivacyPane
.
updateNonTechnicalPrivacySectionVisibility
(
)
;
}
init
(
)
{
initSettingGroup
(
"
nonTechnicalPrivacy
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
ui
.
status_card
"
false
)
)
{
initSettingGroup
(
"
securityPrivacyStatus
"
)
;
}
initSettingGroup
(
"
httpsOnly
"
)
;
initSettingGroup
(
"
browsingProtection
"
)
;
this
.
initNonTechnicalPrivacySection
(
)
;
this
.
_updateSanitizeSettingsButton
(
)
;
this
.
initDeleteOnCloseBox
(
)
;
this
.
syncSanitizationPrefsWithDeleteOnClose
(
)
;
this
.
initializeHistoryMode
(
)
;
this
.
updateHistoryModePane
(
)
;
this
.
updatePrivacyMicroControls
(
)
;
this
.
initAutoStartPrivateBrowsingReverter
(
)
;
this
.
initContentBlocking
(
)
;
this
.
trackingProtectionReadPrefs
(
)
;
this
.
fingerprintingProtectionReadPrefs
(
)
;
this
.
networkCookieBehaviorReadPrefs
(
)
;
this
.
_initTrackingProtectionExtensionControl
(
)
;
this
.
_ensureTrackingProtectionExceptionListMigration
(
)
;
this
.
_initThirdPartyCertsToggle
(
)
;
this
.
_initProfilesInfo
(
)
;
Preferences
.
get
(
"
privacy
.
trackingprotection
.
enabled
"
)
.
on
(
"
change
"
gPrivacyPane
.
trackingProtectionReadPrefs
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
.
on
(
"
change
"
gPrivacyPane
.
trackingProtectionReadPrefs
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
network
.
cookie
.
cookieBehavior
"
)
.
on
(
"
change
"
gPrivacyPane
.
networkCookieBehaviorReadPrefs
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
on
(
"
change
"
gPrivacyPane
.
networkCookieBehaviorReadPrefs
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
privacy
.
firstparty
.
isolate
"
)
.
on
(
"
change
"
gPrivacyPane
.
networkCookieBehaviorReadPrefs
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
privacy
.
fingerprintingProtection
"
)
.
on
(
"
change
"
gPrivacyPane
.
fingerprintingProtectionReadPrefs
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
privacy
.
fingerprintingProtection
.
pbmode
"
)
.
on
(
"
change
"
gPrivacyPane
.
fingerprintingProtectionReadPrefs
.
bind
(
gPrivacyPane
)
)
;
setEventListener
(
"
trackingProtectionExceptions
"
"
command
"
gPrivacyPane
.
showTrackingProtectionExceptions
)
;
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
on
(
"
change
"
gPrivacyPane
.
_updateSanitizeSettingsButton
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
on
(
"
change
"
gPrivacyPane
.
updatePrivacyMicroControls
.
bind
(
gPrivacyPane
)
)
;
setEventListener
(
"
historyMode
"
"
command
"
function
(
)
{
gPrivacyPane
.
updateHistoryModePane
(
)
;
gPrivacyPane
.
updateHistoryModePrefs
(
)
;
gPrivacyPane
.
updatePrivacyMicroControls
(
)
;
gPrivacyPane
.
updateAutostart
(
)
;
}
)
;
setEventListener
(
"
clearHistoryButton
"
"
command
"
function
(
)
{
let
historyMode
=
document
.
getElementById
(
"
historyMode
"
)
;
gPrivacyPane
.
clearPrivateDataNow
(
historyMode
.
value
=
=
"
dontremember
"
)
;
}
)
;
setEventListener
(
"
privateBrowsingAutoStart
"
"
command
"
gPrivacyPane
.
updateAutostart
)
;
setEventListener
(
"
cookieExceptions
"
"
command
"
gPrivacyPane
.
showCookieExceptions
)
;
setEventListener
(
"
dohExceptionsButton
"
"
command
"
gPrivacyPane
.
showDoHExceptions
)
;
setEventListener
(
"
clearDataSettings
"
"
command
"
gPrivacyPane
.
showClearPrivateDataSettings
)
;
setEventListener
(
"
passwordExceptions
"
"
command
"
gPrivacyPane
.
showPasswordExceptions
)
;
setEventListener
(
"
useMasterPassword
"
"
command
"
gPrivacyPane
.
updateMasterPasswordButton
)
;
setEventListener
(
"
changeMasterPassword
"
"
command
"
gPrivacyPane
.
changeMasterPassword
)
;
setEventListener
(
"
showPasswords
"
"
command
"
gPrivacyPane
.
showPasswords
)
;
setEventListener
(
"
addonExceptions
"
"
command
"
gPrivacyPane
.
showAddonExceptions
)
;
setEventListener
(
"
viewCertificatesButton
"
"
command
"
gPrivacyPane
.
showCertificates
)
;
setEventListener
(
"
viewSecurityDevicesButton
"
"
command
"
gPrivacyPane
.
showSecurityDevices
)
;
this
.
_pane
=
document
.
getElementById
(
"
panePrivacy
"
)
;
this
.
_initPasswordGenerationUI
(
)
;
this
.
_initRelayIntegrationUI
(
)
;
this
.
_initMasterPasswordUI
(
)
;
this
.
_initOSAuthentication
(
)
;
this
.
initListenersForExtensionControllingPasswordManager
(
)
;
setEventListener
(
"
autoplaySettingsButton
"
"
command
"
gPrivacyPane
.
showAutoplayMediaExceptions
)
;
setEventListener
(
"
notificationSettingsButton
"
"
command
"
gPrivacyPane
.
showNotificationExceptions
)
;
setEventListener
(
"
locationSettingsButton
"
"
command
"
gPrivacyPane
.
showLocationExceptions
)
;
setEventListener
(
"
localHostSettingsButton
"
"
command
"
gPrivacyPane
.
showLocalHostExceptions
)
;
setEventListener
(
"
localNetworkSettingsButton
"
"
command
"
gPrivacyPane
.
showLocalNetworkExceptions
)
;
setEventListener
(
"
xrSettingsButton
"
"
command
"
gPrivacyPane
.
showXRExceptions
)
;
setEventListener
(
"
cameraSettingsButton
"
"
command
"
gPrivacyPane
.
showCameraExceptions
)
;
setEventListener
(
"
microphoneSettingsButton
"
"
command
"
gPrivacyPane
.
showMicrophoneExceptions
)
;
document
.
getElementById
(
"
speakerSettingsRow
"
)
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
media
.
setsinkid
.
enabled
"
false
)
;
setEventListener
(
"
speakerSettingsButton
"
"
command
"
gPrivacyPane
.
showSpeakerExceptions
)
;
setEventListener
(
"
popupPolicyButton
"
"
command
"
gPrivacyPane
.
showPopupExceptions
)
;
setEventListener
(
"
notificationsDoNotDisturb
"
"
command
"
gPrivacyPane
.
toggleDoNotDisturbNotifications
)
;
setSyncFromPrefListener
(
"
contentBlockingBlockCookiesCheckbox
"
(
)
=
>
this
.
readBlockCookies
(
)
)
;
setSyncToPrefListener
(
"
contentBlockingBlockCookiesCheckbox
"
(
)
=
>
this
.
writeBlockCookies
(
)
)
;
setSyncFromPrefListener
(
"
blockCookiesMenu
"
(
)
=
>
this
.
readBlockCookiesFrom
(
)
)
;
setSyncToPrefListener
(
"
blockCookiesMenu
"
(
)
=
>
this
.
writeBlockCookiesFrom
(
)
)
;
setSyncFromPrefListener
(
"
savePasswords
"
(
)
=
>
this
.
readSavePasswords
(
)
)
;
let
microControlHandler
=
el
=
>
this
.
ensurePrivacyMicroControlUncheckedWhenDisabled
(
el
)
;
setSyncFromPrefListener
(
"
rememberHistory
"
microControlHandler
)
;
setSyncFromPrefListener
(
"
rememberForms
"
microControlHandler
)
;
setSyncFromPrefListener
(
"
alwaysClear
"
microControlHandler
)
;
setSyncFromPrefListener
(
"
popupPolicy
"
(
)
=
>
this
.
updateButtons
(
"
popupPolicyButton
"
"
dom
.
disable_open_during_load
"
)
)
;
setSyncFromPrefListener
(
"
warnAddonInstall
"
(
)
=
>
this
.
readWarnAddonInstall
(
)
)
;
if
(
AlertsServiceDND
)
{
let
notificationsDoNotDisturbBox
=
document
.
getElementById
(
"
notificationsDoNotDisturbBox
"
)
;
notificationsDoNotDisturbBox
.
removeAttribute
(
"
hidden
"
)
;
let
checkbox
=
document
.
getElementById
(
"
notificationsDoNotDisturb
"
)
;
document
.
l10n
.
setAttributes
(
checkbox
"
permissions
-
notification
-
pause
"
)
;
if
(
AlertsServiceDND
.
manualDoNotDisturb
)
{
let
notificationsDoNotDisturb
=
document
.
getElementById
(
"
notificationsDoNotDisturb
"
)
;
notificationsDoNotDisturb
.
setAttribute
(
"
checked
"
true
)
;
}
}
let
onNimbus
=
(
)
=
>
this
.
_updateFirefoxSuggestToggle
(
)
;
NimbusFeatures
.
urlbar
.
onUpdate
(
onNimbus
)
;
this
.
_updateFirefoxSuggestToggle
(
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
NimbusFeatures
.
urlbar
.
offUpdate
(
onNimbus
)
;
}
)
;
this
.
initSiteDataControls
(
)
;
setEventListener
(
"
clearSiteDataButton
"
"
command
"
gPrivacyPane
.
clearSiteData
)
;
setEventListener
(
"
siteDataSettings
"
"
command
"
gPrivacyPane
.
showSiteDataSettings
)
;
this
.
initCookieBannerHandling
(
)
;
this
.
initDataCollection
(
)
;
if
(
AppConstants
.
MOZ_DATA_REPORTING
)
{
this
.
updateSubmitHealthReportFromPref
(
)
;
Preferences
.
get
(
PREF_UPLOAD_ENABLED
)
.
on
(
"
change
"
gPrivacyPane
.
updateSubmitHealthReportFromPref
)
;
setEventListener
(
"
submitHealthReportBox
"
"
command
"
gPrivacyPane
.
updateSubmitHealthReportToPref
)
;
if
(
AppConstants
.
MOZ_NORMANDY
)
{
this
.
initOptOutStudyCheckbox
(
)
;
}
this
.
initAddonRecommendationsCheckbox
(
)
;
}
let
signonBundle
=
document
.
getElementById
(
"
signonBundle
"
)
;
let
pkiBundle
=
document
.
getElementById
(
"
pkiBundle
"
)
;
appendSearchKeywords
(
"
showPasswords
"
[
signonBundle
.
getString
(
"
loginsDescriptionAll2
"
)
]
)
;
appendSearchKeywords
(
"
viewSecurityDevicesButton
"
[
pkiBundle
.
getString
(
"
enable_fips
"
)
]
)
;
if
(
!
PrivateBrowsingUtils
.
enabled
)
{
document
.
getElementById
(
"
privateBrowsingAutoStart
"
)
.
hidden
=
true
;
document
.
querySelector
(
"
menuitem
[
value
=
'
dontremember
'
]
"
)
.
hidden
=
true
;
}
let
privateBrowsingPref
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
if
(
privateBrowsingPref
.
locked
)
{
document
.
querySelector
(
"
menuitem
[
value
=
'
dontremember
'
]
"
)
.
disabled
=
!
privateBrowsingPref
.
value
;
document
.
getElementById
(
"
historyMode
"
)
.
disabled
=
privateBrowsingPref
.
value
;
}
setEventListener
(
"
contentBlockingBaselineExceptionsStrict
"
"
change
"
gPrivacyPane
.
onBaselineCheckboxChange
)
;
setEventListener
(
"
contentBlockingBaselineExceptionsCustom
"
"
change
"
gPrivacyPane
.
onBaselineCheckboxChange
)
;
setEventListener
(
"
contentBlockingConvenienceExceptionsStrict
"
"
change
"
gPrivacyPane
.
maybeNotifyUserToReload
)
;
setEventListener
(
"
contentBlockingConvenienceExceptionsCustom
"
"
change
"
gPrivacyPane
.
maybeNotifyUserToReload
)
;
this
.
initDoH
(
)
;
this
.
initWebAuthn
(
)
;
Preferences
.
get
(
"
network
.
lna
.
blocking
"
)
.
on
(
"
change
"
this
.
setUpLocalNetworkAccessPermissionUI
)
;
this
.
setUpLocalNetworkAccessPermissionUI
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
privacy
-
pane
-
loaded
"
)
;
}
initSiteDataControls
(
)
{
Services
.
obs
.
addObserver
(
this
"
sitedatamanager
:
sites
-
updated
"
)
;
Services
.
obs
.
addObserver
(
this
"
sitedatamanager
:
updating
-
sites
"
)
;
let
unload
=
(
)
=
>
{
window
.
removeEventListener
(
"
unload
"
unload
)
;
Services
.
obs
.
removeObserver
(
this
"
sitedatamanager
:
sites
-
updated
"
)
;
Services
.
obs
.
removeObserver
(
this
"
sitedatamanager
:
updating
-
sites
"
)
;
}
;
window
.
addEventListener
(
"
unload
"
unload
)
;
SiteDataManager
.
updateSites
(
)
;
}
initContentBlocking
(
)
{
setEventListener
(
"
contentBlockingTrackingProtectionCheckbox
"
"
command
"
this
.
trackingProtectionWritePrefs
)
;
setEventListener
(
"
contentBlockingTrackingProtectionCheckbox
"
"
command
"
this
.
_updateTrackingProtectionUI
)
;
setEventListener
(
"
contentBlockingCryptominersCheckbox
"
"
command
"
this
.
updateCryptominingLists
)
;
setEventListener
(
"
contentBlockingFingerprintersCheckbox
"
"
command
"
this
.
updateFingerprintingLists
)
;
setEventListener
(
"
trackingProtectionMenu
"
"
command
"
this
.
trackingProtectionWritePrefs
)
;
setEventListener
(
"
contentBlockingFingerprintingProtectionCheckbox
"
"
command
"
e
=
>
{
const
extra
=
{
checked
:
e
.
target
.
checked
}
;
Glean
.
privacyUiFppClick
.
checkbox
.
record
(
extra
)
;
this
.
fingerprintingProtectionWritePrefs
(
)
;
}
)
;
setEventListener
(
"
fingerprintingProtectionMenu
"
"
command
"
e
=
>
{
const
extra
=
{
value
:
e
.
target
.
value
}
;
Glean
.
privacyUiFppClick
.
menu
.
record
(
extra
)
;
this
.
fingerprintingProtectionWritePrefs
(
)
;
}
)
;
setEventListener
(
"
standardArrow
"
"
command
"
this
.
toggleExpansion
)
;
setEventListener
(
"
strictArrow
"
"
command
"
this
.
toggleExpansion
)
;
setEventListener
(
"
customArrow
"
"
command
"
this
.
toggleExpansion
)
;
Preferences
.
get
(
"
network
.
cookie
.
cookieBehavior
"
)
.
on
(
"
change
"
gPrivacyPane
.
readBlockCookies
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
browser
.
contentblocking
.
category
"
)
.
on
(
"
change
"
gPrivacyPane
.
highlightCBCategory
)
;
for
(
let
pref
of
CONTENT_BLOCKING_PREFS
)
{
if
(
pref
=
=
"
privacy
.
trackingprotection
.
allow_list
.
baseline
.
enabled
"
|
|
pref
=
=
"
privacy
.
trackingprotection
.
allow_list
.
convenience
.
enabled
"
)
{
continue
;
}
Preferences
.
get
(
pref
)
.
on
(
"
change
"
gPrivacyPane
.
maybeNotifyUserToReload
)
;
Preferences
.
get
(
pref
)
.
on
(
"
change
"
gPrivacyPane
.
populateCategoryContents
)
;
}
Preferences
.
get
(
"
urlclassifier
.
trackingTable
"
)
.
on
(
"
change
"
gPrivacyPane
.
maybeNotifyUserToReload
)
;
for
(
let
button
of
document
.
querySelectorAll
(
"
.
reload
-
tabs
-
button
"
)
)
{
button
.
addEventListener
(
"
command
"
gPrivacyPane
.
reloadAllOtherTabs
)
;
}
let
cryptoMinersOption
=
document
.
getElementById
(
"
contentBlockingCryptominersOption
"
)
;
let
fingerprintersOption
=
document
.
getElementById
(
"
contentBlockingFingerprintersOption
"
)
;
let
trackingAndIsolateOption
=
document
.
querySelector
(
"
#
blockCookiesMenu
menuitem
[
value
=
'
trackers
-
plus
-
isolate
'
]
"
)
;
cryptoMinersOption
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
contentblocking
.
cryptomining
.
preferences
.
ui
.
enabled
"
)
;
fingerprintersOption
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
contentblocking
.
fingerprinting
.
preferences
.
ui
.
enabled
"
)
;
let
updateTrackingAndIsolateOption
=
(
)
=
>
{
trackingAndIsolateOption
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
contentblocking
.
reject
-
and
-
isolate
-
cookies
.
preferences
.
ui
.
enabled
"
false
)
|
|
gIsFirstPartyIsolated
;
}
;
Preferences
.
get
(
"
privacy
.
firstparty
.
isolate
"
)
.
on
(
"
change
"
updateTrackingAndIsolateOption
)
;
updateTrackingAndIsolateOption
(
)
;
Preferences
.
get
(
"
browser
.
contentblocking
.
features
.
strict
"
)
.
on
(
"
change
"
this
.
populateCategoryContents
)
;
this
.
populateCategoryContents
(
)
;
this
.
highlightCBCategory
(
)
;
this
.
readBlockCookies
(
)
;
const
STP_COOKIES_PREF
=
"
privacy
.
socialtracking
.
block_cookies
.
enabled
"
;
if
(
Services
.
prefs
.
getBoolPref
(
STP_COOKIES_PREF
)
)
{
let
contentBlockOptionSocialMedia
=
document
.
getElementById
(
"
blockCookiesSocialMedia
"
)
;
document
.
l10n
.
setAttributes
(
contentBlockOptionSocialMedia
"
sitedata
-
option
-
block
-
cross
-
site
-
tracking
-
cookies
"
)
;
}
Preferences
.
get
(
"
privacy
.
resistFingerprinting
"
)
.
on
(
"
change
"
setUpContentBlockingWarnings
)
;
Preferences
.
get
(
"
privacy
.
resistFingerprinting
.
pbmode
"
)
.
on
(
"
change
"
setUpContentBlockingWarnings
)
;
setUpContentBlockingWarnings
(
)
;
initTCPStandardSection
(
)
;
}
populateCategoryContents
(
)
{
for
(
let
type
of
[
"
strict
"
"
standard
"
]
)
{
let
rulesArray
=
[
]
;
let
selector
;
if
(
type
=
=
"
strict
"
)
{
selector
=
"
#
contentBlockingOptionStrict
"
;
rulesArray
=
Services
.
prefs
.
getStringPref
(
"
browser
.
contentblocking
.
features
.
strict
"
)
.
split
(
"
"
)
;
if
(
gIsFirstPartyIsolated
)
{
let
idx
=
rulesArray
.
indexOf
(
"
cookieBehavior5
"
)
;
if
(
idx
!
=
-
1
)
{
rulesArray
[
idx
]
=
"
cookieBehavior4
"
;
}
}
}
else
{
selector
=
"
#
contentBlockingOptionStandard
"
;
let
defaults
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
let
cookieBehavior
=
defaults
.
getIntPref
(
"
network
.
cookie
.
cookieBehavior
"
)
;
switch
(
cookieBehavior
)
{
case
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
:
rulesArray
.
push
(
"
cookieBehavior0
"
)
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
:
rulesArray
.
push
(
"
cookieBehavior1
"
)
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
:
rulesArray
.
push
(
"
cookieBehavior2
"
)
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_LIMIT_FOREIGN
:
rulesArray
.
push
(
"
cookieBehavior3
"
)
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
:
rulesArray
.
push
(
"
cookieBehavior4
"
)
;
break
;
case
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
:
rulesArray
.
push
(
gIsFirstPartyIsolated
?
"
cookieBehavior4
"
:
"
cookieBehavior5
"
)
;
break
;
}
let
cookieBehaviorPBM
=
defaults
.
getIntPref
(
"
network
.
cookie
.
cookieBehavior
.
pbmode
"
)
;
switch
(
cookieBehaviorPBM
)
{
case
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
:
rulesArray
.
push
(
"
cookieBehaviorPBM0
"
)
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
:
rulesArray
.
push
(
"
cookieBehaviorPBM1
"
)
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
:
rulesArray
.
push
(
"
cookieBehaviorPBM2
"
)
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_LIMIT_FOREIGN
:
rulesArray
.
push
(
"
cookieBehaviorPBM3
"
)
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
:
rulesArray
.
push
(
"
cookieBehaviorPBM4
"
)
;
break
;
case
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
:
rulesArray
.
push
(
gIsFirstPartyIsolated
?
"
cookieBehaviorPBM4
"
:
"
cookieBehaviorPBM5
"
)
;
break
;
}
rulesArray
.
push
(
defaults
.
getBoolPref
(
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
)
?
"
cryptoTP
"
:
"
-
cryptoTP
"
)
;
rulesArray
.
push
(
defaults
.
getBoolPref
(
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
)
?
"
fp
"
:
"
-
fp
"
)
;
rulesArray
.
push
(
Services
.
prefs
.
getBoolPref
(
"
privacy
.
socialtracking
.
block_cookies
.
enabled
"
)
?
"
stp
"
:
"
-
stp
"
)
;
rulesArray
.
push
(
defaults
.
getBoolPref
(
"
privacy
.
trackingprotection
.
enabled
"
)
?
"
tp
"
:
"
-
tp
"
)
;
rulesArray
.
push
(
defaults
.
getBoolPref
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
?
"
tpPrivate
"
:
"
-
tpPrivate
"
)
;
}
document
.
querySelector
(
selector
+
"
.
all
-
cookies
-
option
"
)
.
hidden
=
true
;
document
.
querySelector
(
selector
+
"
.
unvisited
-
cookies
-
option
"
)
.
hidden
=
true
;
document
.
querySelector
(
selector
+
"
.
cross
-
site
-
cookies
-
option
"
)
.
hidden
=
true
;
document
.
querySelector
(
selector
+
"
.
third
-
party
-
tracking
-
cookies
-
option
"
)
.
hidden
=
true
;
document
.
querySelector
(
selector
+
"
.
all
-
third
-
party
-
cookies
-
private
-
windows
-
option
"
)
.
hidden
=
true
;
document
.
querySelector
(
selector
+
"
.
all
-
third
-
party
-
cookies
-
option
"
)
.
hidden
=
true
;
document
.
querySelector
(
selector
+
"
.
social
-
media
-
option
"
)
.
hidden
=
true
;
for
(
let
item
of
rulesArray
)
{
switch
(
item
)
{
case
"
tp
"
:
document
.
querySelector
(
selector
+
"
.
trackers
-
option
"
)
.
hidden
=
false
;
break
;
case
"
-
tp
"
:
document
.
querySelector
(
selector
+
"
.
trackers
-
option
"
)
.
hidden
=
true
;
break
;
case
"
tpPrivate
"
:
document
.
querySelector
(
selector
+
"
.
pb
-
trackers
-
option
"
)
.
hidden
=
false
;
break
;
case
"
-
tpPrivate
"
:
document
.
querySelector
(
selector
+
"
.
pb
-
trackers
-
option
"
)
.
hidden
=
true
;
break
;
case
"
fp
"
:
document
.
querySelector
(
selector
+
"
.
fingerprinters
-
option
"
)
.
hidden
=
false
;
break
;
case
"
-
fp
"
:
document
.
querySelector
(
selector
+
"
.
fingerprinters
-
option
"
)
.
hidden
=
true
;
break
;
case
"
cryptoTP
"
:
document
.
querySelector
(
selector
+
"
.
cryptominers
-
option
"
)
.
hidden
=
false
;
break
;
case
"
-
cryptoTP
"
:
document
.
querySelector
(
selector
+
"
.
cryptominers
-
option
"
)
.
hidden
=
true
;
break
;
case
"
stp
"
:
{
const
STP_COOKIES_PREF
=
"
privacy
.
socialtracking
.
block_cookies
.
enabled
"
;
if
(
Services
.
prefs
.
getBoolPref
(
STP_COOKIES_PREF
)
)
{
document
.
querySelector
(
selector
+
"
.
social
-
media
-
option
"
)
.
hidden
=
false
;
}
break
;
}
case
"
-
stp
"
:
document
.
querySelector
(
selector
+
"
.
social
-
media
-
option
"
)
.
hidden
=
true
;
break
;
case
"
cookieBehavior1
"
:
document
.
querySelector
(
selector
+
"
.
all
-
third
-
party
-
cookies
-
option
"
)
.
hidden
=
false
;
break
;
case
"
cookieBehavior2
"
:
document
.
querySelector
(
selector
+
"
.
all
-
cookies
-
option
"
)
.
hidden
=
false
;
break
;
case
"
cookieBehavior3
"
:
document
.
querySelector
(
selector
+
"
.
unvisited
-
cookies
-
option
"
)
.
hidden
=
false
;
break
;
case
"
cookieBehavior4
"
:
document
.
querySelector
(
selector
+
"
.
third
-
party
-
tracking
-
cookies
-
option
"
)
.
hidden
=
false
;
break
;
case
"
cookieBehavior5
"
:
document
.
querySelector
(
selector
+
"
.
cross
-
site
-
cookies
-
option
"
)
.
hidden
=
false
;
break
;
case
"
cookieBehaviorPBM5
"
:
if
(
!
rulesArray
.
includes
(
"
cookieBehavior5
"
)
)
{
document
.
querySelector
(
selector
+
"
.
all
-
third
-
party
-
cookies
-
private
-
windows
-
option
"
)
.
hidden
=
false
;
}
break
;
}
}
if
(
!
document
.
querySelector
(
selector
+
"
.
trackers
-
option
"
)
.
hidden
)
{
document
.
querySelector
(
selector
+
"
.
pb
-
trackers
-
option
"
)
.
hidden
=
true
;
}
}
}
highlightCBCategory
(
)
{
let
value
=
Preferences
.
get
(
"
browser
.
contentblocking
.
category
"
)
.
value
;
let
standardEl
=
document
.
getElementById
(
"
contentBlockingOptionStandard
"
)
;
let
strictEl
=
document
.
getElementById
(
"
contentBlockingOptionStrict
"
)
;
let
customEl
=
document
.
getElementById
(
"
contentBlockingOptionCustom
"
)
;
standardEl
.
classList
.
remove
(
"
selected
"
)
;
strictEl
.
classList
.
remove
(
"
selected
"
)
;
customEl
.
classList
.
remove
(
"
selected
"
)
;
switch
(
value
)
{
case
"
strict
"
:
strictEl
.
classList
.
add
(
"
selected
"
)
;
break
;
case
"
custom
"
:
customEl
.
classList
.
add
(
"
selected
"
)
;
break
;
case
"
standard
"
:
default
:
standardEl
.
classList
.
add
(
"
selected
"
)
;
break
;
}
}
updateCryptominingLists
(
)
{
let
listPrefs
=
[
"
urlclassifier
.
features
.
cryptomining
.
blacklistTables
"
"
urlclassifier
.
features
.
cryptomining
.
whitelistTables
"
]
;
let
listValue
=
listPrefs
.
map
(
l
=
>
Services
.
prefs
.
getStringPref
(
l
)
)
.
join
(
"
"
)
;
listManager
.
forceUpdates
(
listValue
)
;
}
updateFingerprintingLists
(
)
{
let
listPrefs
=
[
"
urlclassifier
.
features
.
fingerprinting
.
blacklistTables
"
"
urlclassifier
.
features
.
fingerprinting
.
whitelistTables
"
]
;
let
listValue
=
listPrefs
.
map
(
l
=
>
Services
.
prefs
.
getStringPref
(
l
)
)
.
join
(
"
"
)
;
listManager
.
forceUpdates
(
listValue
)
;
}
trackingProtectionReadPrefs
(
)
{
let
enabledPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
enabled
"
)
;
let
pbmPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
;
let
tpMenu
=
document
.
getElementById
(
"
trackingProtectionMenu
"
)
;
let
tpCheckbox
=
document
.
getElementById
(
"
contentBlockingTrackingProtectionCheckbox
"
)
;
this
.
_updateTrackingProtectionUI
(
)
;
if
(
enabledPref
.
value
)
{
tpMenu
.
value
=
"
always
"
;
tpCheckbox
.
checked
=
true
;
}
else
if
(
pbmPref
.
value
)
{
tpMenu
.
value
=
"
private
"
;
tpCheckbox
.
checked
=
true
;
}
else
{
tpMenu
.
value
=
"
never
"
;
tpCheckbox
.
checked
=
false
;
}
}
fingerprintingProtectionReadPrefs
(
)
{
let
enabledPref
=
Preferences
.
get
(
"
privacy
.
fingerprintingProtection
"
)
;
let
pbmPref
=
Preferences
.
get
(
"
privacy
.
fingerprintingProtection
.
pbmode
"
)
;
let
fppMenu
=
document
.
getElementById
(
"
fingerprintingProtectionMenu
"
)
;
let
fppCheckbox
=
document
.
getElementById
(
"
contentBlockingFingerprintingProtectionCheckbox
"
)
;
if
(
enabledPref
.
value
)
{
fppMenu
.
value
=
"
always
"
;
fppCheckbox
.
checked
=
true
;
}
else
if
(
pbmPref
.
value
)
{
fppMenu
.
value
=
"
private
"
;
fppCheckbox
.
checked
=
true
;
}
else
{
fppMenu
.
value
=
"
never
"
;
fppCheckbox
.
checked
=
false
;
}
fppMenu
.
disabled
=
!
fppCheckbox
.
checked
|
|
enabledPref
.
locked
;
fppCheckbox
.
disabled
=
enabledPref
.
locked
;
}
networkCookieBehaviorReadPrefs
(
)
{
let
behavior
=
Services
.
cookies
.
getCookieBehavior
(
false
)
;
let
blockCookiesMenu
=
document
.
getElementById
(
"
blockCookiesMenu
"
)
;
let
deleteOnCloseCheckbox
=
document
.
getElementById
(
"
deleteOnClose
"
)
;
let
deleteOnCloseNote
=
document
.
getElementById
(
"
deleteOnCloseNote
"
)
;
let
blockCookies
=
behavior
!
=
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
;
let
cookieBehaviorLocked
=
Services
.
prefs
.
prefIsLocked
(
"
network
.
cookie
.
cookieBehavior
"
)
;
let
blockCookiesControlsDisabled
=
!
blockCookies
|
|
cookieBehaviorLocked
;
blockCookiesMenu
.
disabled
=
blockCookiesControlsDisabled
;
let
completelyBlockCookies
=
behavior
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
;
let
privateBrowsing
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
value
;
deleteOnCloseCheckbox
.
disabled
=
privateBrowsing
|
|
completelyBlockCookies
;
deleteOnCloseNote
.
hidden
=
!
privateBrowsing
;
switch
(
behavior
)
{
case
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
:
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
:
blockCookiesMenu
.
value
=
"
all
-
third
-
parties
"
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
:
blockCookiesMenu
.
value
=
"
always
"
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_LIMIT_FOREIGN
:
blockCookiesMenu
.
value
=
"
unvisited
"
;
break
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
:
blockCookiesMenu
.
value
=
"
trackers
"
;
break
;
case
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
:
blockCookiesMenu
.
value
=
"
trackers
-
plus
-
isolate
"
;
break
;
}
}
trackingProtectionWritePrefs
(
)
{
let
enabledPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
enabled
"
)
;
let
pbmPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
;
let
stpPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
socialtracking
.
enabled
"
)
;
let
stpCookiePref
=
Preferences
.
get
(
"
privacy
.
socialtracking
.
block_cookies
.
enabled
"
)
;
let
emailTPPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
emailtracking
.
enabled
"
)
;
let
emailTPPBMPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
emailtracking
.
pbmode
.
enabled
"
)
;
let
tpMenu
=
document
.
getElementById
(
"
trackingProtectionMenu
"
)
;
let
tpCheckbox
=
document
.
getElementById
(
"
contentBlockingTrackingProtectionCheckbox
"
)
;
let
value
;
if
(
tpCheckbox
.
checked
)
{
if
(
tpMenu
.
value
=
=
"
never
"
)
{
tpMenu
.
value
=
"
private
"
;
}
value
=
tpMenu
.
value
;
}
else
{
tpMenu
.
value
=
"
never
"
;
value
=
"
never
"
;
}
switch
(
value
)
{
case
"
always
"
:
enabledPref
.
value
=
true
;
pbmPref
.
value
=
true
;
emailTPPref
.
value
=
true
;
emailTPPBMPref
.
value
=
true
;
if
(
stpCookiePref
.
value
)
{
stpPref
.
value
=
true
;
}
break
;
case
"
private
"
:
enabledPref
.
value
=
false
;
pbmPref
.
value
=
true
;
emailTPPref
.
value
=
false
;
emailTPPBMPref
.
value
=
true
;
if
(
stpCookiePref
.
value
)
{
stpPref
.
value
=
false
;
}
break
;
case
"
never
"
:
enabledPref
.
value
=
false
;
pbmPref
.
value
=
false
;
emailTPPref
.
value
=
false
;
emailTPPBMPref
.
value
=
false
;
if
(
stpCookiePref
.
value
)
{
stpPref
.
value
=
false
;
}
break
;
}
}
fingerprintingProtectionWritePrefs
(
)
{
let
enabledPref
=
Preferences
.
get
(
"
privacy
.
fingerprintingProtection
"
)
;
let
pbmPref
=
Preferences
.
get
(
"
privacy
.
fingerprintingProtection
.
pbmode
"
)
;
let
fppMenu
=
document
.
getElementById
(
"
fingerprintingProtectionMenu
"
)
;
let
fppCheckbox
=
document
.
getElementById
(
"
contentBlockingFingerprintingProtectionCheckbox
"
)
;
let
value
;
if
(
fppCheckbox
.
checked
)
{
if
(
fppMenu
.
value
=
=
"
never
"
)
{
fppMenu
.
value
=
"
private
"
;
}
value
=
fppMenu
.
value
;
}
else
{
fppMenu
.
value
=
"
never
"
;
value
=
"
never
"
;
}
fppMenu
.
disabled
=
!
fppCheckbox
.
checked
;
switch
(
value
)
{
case
"
always
"
:
enabledPref
.
value
=
true
;
pbmPref
.
value
=
true
;
break
;
case
"
private
"
:
enabledPref
.
value
=
false
;
pbmPref
.
value
=
true
;
break
;
case
"
never
"
:
enabledPref
.
value
=
false
;
pbmPref
.
value
=
false
;
break
;
}
}
toggleExpansion
(
e
)
{
let
carat
=
e
.
target
;
carat
.
classList
.
toggle
(
"
up
"
)
;
carat
.
closest
(
"
.
privacy
-
detailedoption
"
)
.
classList
.
toggle
(
"
expanded
"
)
;
carat
.
setAttribute
(
"
aria
-
expanded
"
carat
.
getAttribute
(
"
aria
-
expanded
"
)
=
=
=
"
false
"
)
;
}
prefsForKeepingHistory
:
{
"
places
.
history
.
enabled
"
:
true
"
browser
.
formfill
.
enable
"
:
true
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
:
false
}
dependentControls
:
[
"
rememberHistory
"
"
rememberForms
"
"
alwaysClear
"
"
clearDataSettings
"
]
_checkHistoryValues
(
aPrefs
)
{
for
(
let
pref
of
Object
.
keys
(
aPrefs
)
)
{
if
(
Preferences
.
get
(
pref
)
.
value
!
=
aPrefs
[
pref
]
)
{
return
false
;
}
}
return
true
;
}
initializeHistoryMode
(
)
{
let
mode
;
let
getVal
=
aPref
=
>
Preferences
.
get
(
aPref
)
.
value
;
if
(
getVal
(
"
privacy
.
history
.
custom
"
)
)
{
mode
=
"
custom
"
;
}
else
if
(
this
.
_checkHistoryValues
(
this
.
prefsForKeepingHistory
)
)
{
if
(
getVal
(
"
browser
.
privatebrowsing
.
autostart
"
)
)
{
mode
=
"
dontremember
"
;
}
else
{
mode
=
"
remember
"
;
}
}
else
{
mode
=
"
custom
"
;
}
document
.
getElementById
(
"
historyMode
"
)
.
value
=
mode
;
}
updateHistoryModePane
(
)
{
let
selectedIndex
=
-
1
;
switch
(
document
.
getElementById
(
"
historyMode
"
)
.
value
)
{
case
"
remember
"
:
selectedIndex
=
0
;
break
;
case
"
dontremember
"
:
selectedIndex
=
1
;
break
;
case
"
custom
"
:
selectedIndex
=
2
;
break
;
}
document
.
getElementById
(
"
historyPane
"
)
.
selectedIndex
=
selectedIndex
;
Preferences
.
get
(
"
privacy
.
history
.
custom
"
)
.
value
=
selectedIndex
=
=
2
;
}
updateHistoryModePrefs
(
)
{
let
pref
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
switch
(
document
.
getElementById
(
"
historyMode
"
)
.
value
)
{
case
"
remember
"
:
if
(
pref
.
value
)
{
pref
.
value
=
false
;
}
Preferences
.
get
(
"
places
.
history
.
enabled
"
)
.
value
=
true
;
Preferences
.
get
(
"
browser
.
formfill
.
enable
"
)
.
value
=
true
;
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
=
false
;
break
;
case
"
dontremember
"
:
if
(
!
pref
.
value
)
{
pref
.
value
=
true
;
}
break
;
}
}
updatePrivacyMicroControls
(
)
{
let
clearDataSettings
=
document
.
getElementById
(
"
clearDataSettings
"
)
;
if
(
document
.
getElementById
(
"
historyMode
"
)
.
value
=
=
"
custom
"
)
{
let
disabled
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
value
;
this
.
dependentControls
.
forEach
(
aElement
=
>
{
let
control
=
document
.
getElementById
(
aElement
)
;
let
preferenceId
=
control
.
getAttribute
(
"
preference
"
)
;
if
(
!
preferenceId
)
{
let
dependentControlId
=
control
.
getAttribute
(
"
control
"
)
;
if
(
dependentControlId
)
{
let
dependentControl
=
document
.
getElementById
(
dependentControlId
)
;
preferenceId
=
dependentControl
.
getAttribute
(
"
preference
"
)
;
}
}
let
preference
=
preferenceId
?
Preferences
.
get
(
preferenceId
)
:
{
}
;
control
.
disabled
=
disabled
|
|
preference
.
locked
;
if
(
control
!
=
clearDataSettings
)
{
this
.
ensurePrivacyMicroControlUncheckedWhenDisabled
(
control
)
;
}
}
)
;
clearDataSettings
.
removeAttribute
(
"
hidden
"
)
;
if
(
!
disabled
)
{
this
.
_updateSanitizeSettingsButton
(
)
;
}
}
else
{
clearDataSettings
.
hidden
=
true
;
}
}
ensurePrivacyMicroControlUncheckedWhenDisabled
(
el
)
{
if
(
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
value
)
{
el
.
checked
=
false
;
return
false
;
}
return
undefined
;
}
showClearPrivateDataSettings
(
)
{
let
dialogFile
=
useOldClearHistoryDialog
?
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sanitize
.
xhtml
"
:
"
chrome
:
/
/
browser
/
content
/
sanitize_v2
.
xhtml
"
;
gSubDialog
.
open
(
dialogFile
{
features
:
"
resizable
=
no
"
}
{
mode
:
"
clearOnShutdown
"
}
)
;
}
clearPrivateDataNow
(
aClearEverything
)
{
var
ts
=
Preferences
.
get
(
"
privacy
.
sanitize
.
timeSpan
"
)
;
var
timeSpanOrig
=
ts
.
value
;
if
(
aClearEverything
)
{
ts
.
value
=
0
;
}
let
dialogFile
=
useOldClearHistoryDialog
?
"
chrome
:
/
/
browser
/
content
/
sanitize
.
xhtml
"
:
"
chrome
:
/
/
browser
/
content
/
sanitize_v2
.
xhtml
"
;
gSubDialog
.
open
(
dialogFile
{
features
:
"
resizable
=
no
"
closingCallback
:
(
)
=
>
{
if
(
aClearEverything
)
{
ts
.
value
=
timeSpanOrig
;
}
Services
.
obs
.
notifyObservers
(
null
"
clear
-
private
-
data
"
)
;
}
}
)
;
}
initDeleteOnCloseBox
(
)
{
Sanitizer
.
maybeMigratePrefs
(
"
clearOnShutdown
"
)
;
let
deleteOnCloseBox
=
document
.
getElementById
(
"
deleteOnClose
"
)
;
let
isCookiesAndStorageClearingOnShutdown
;
if
(
useOldClearHistoryDialog
)
{
isCookiesAndStorageClearingOnShutdown
=
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
cookies
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
cache
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
offlineApps
"
)
.
value
;
}
else
{
isCookiesAndStorageClearingOnShutdown
=
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown_v2
.
cookiesAndStorage
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown_v2
.
cache
"
)
.
value
;
}
deleteOnCloseBox
.
checked
=
isCookiesAndStorageClearingOnShutdown
|
|
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
value
;
}
syncSanitizationPrefsWithDeleteOnClose
(
)
{
let
deleteOnCloseBox
=
document
.
getElementById
(
"
deleteOnClose
"
)
;
let
historyMode
=
Preferences
.
get
(
"
privacy
.
history
.
custom
"
)
;
let
sanitizeOnShutdownPref
=
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
;
let
cookiePref
=
useOldClearHistoryDialog
?
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
cookies
"
)
:
Preferences
.
get
(
"
privacy
.
clearOnShutdown_v2
.
cookiesAndStorage
"
)
;
let
cachePref
=
useOldClearHistoryDialog
?
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
cache
"
)
:
Preferences
.
get
(
"
privacy
.
clearOnShutdown_v2
.
cache
"
)
;
let
offlineAppsPref
=
useOldClearHistoryDialog
?
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
offlineApps
"
)
:
Preferences
.
get
(
"
privacy
.
clearOnShutdown_v2
.
cookiesAndStorage
"
)
;
deleteOnCloseBox
.
addEventListener
(
"
command
"
(
)
=
>
{
let
{
checked
}
=
deleteOnCloseBox
;
cookiePref
.
value
=
checked
;
cachePref
.
value
=
checked
;
offlineAppsPref
.
value
=
checked
;
if
(
!
sanitizeOnShutdownPref
.
value
)
{
this
.
_resetCleaningPrefs
(
)
;
}
sanitizeOnShutdownPref
.
value
=
this
.
_isCustomCleaningPrefPresent
(
)
|
|
checked
;
if
(
checked
&
&
!
historyMode
.
value
)
{
historyMode
.
value
=
"
custom
"
;
this
.
initializeHistoryMode
(
)
;
this
.
updateHistoryModePane
(
)
;
this
.
updatePrivacyMicroControls
(
)
;
}
}
)
;
cookiePref
.
on
(
"
change
"
this
.
_onSanitizePrefChangeSyncClearOnClose
)
;
cachePref
.
on
(
"
change
"
this
.
_onSanitizePrefChangeSyncClearOnClose
)
;
offlineAppsPref
.
on
(
"
change
"
this
.
_onSanitizePrefChangeSyncClearOnClose
)
;
sanitizeOnShutdownPref
.
on
(
"
change
"
this
.
_onSanitizePrefChangeSyncClearOnClose
)
;
}
_onSanitizePrefChangeSyncClearOnClose
(
)
{
let
deleteOnCloseBox
=
document
.
getElementById
(
"
deleteOnClose
"
)
;
if
(
useOldClearHistoryDialog
)
{
deleteOnCloseBox
.
checked
=
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
cookies
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
cache
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown
.
offlineApps
"
)
.
value
;
}
else
{
deleteOnCloseBox
.
checked
=
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown_v2
.
cookiesAndStorage
"
)
.
value
&
&
Preferences
.
get
(
"
privacy
.
clearOnShutdown_v2
.
cache
"
)
.
value
;
}
}
_resetCleaningPrefs
(
)
{
let
sanitizeOnShutdownPrefsArray
=
useOldClearHistoryDialog
?
SANITIZE_ON_SHUTDOWN_PREFS_ONLY
:
SANITIZE_ON_SHUTDOWN_PREFS_ONLY_V2
;
return
sanitizeOnShutdownPrefsArray
.
forEach
(
pref
=
>
(
Preferences
.
get
(
pref
)
.
value
=
false
)
)
;
}
_isCustomCleaningPrefPresent
(
)
{
let
sanitizeOnShutdownPrefsArray
=
useOldClearHistoryDialog
?
SANITIZE_ON_SHUTDOWN_PREFS_ONLY
:
SANITIZE_ON_SHUTDOWN_PREFS_ONLY_V2
;
return
sanitizeOnShutdownPrefsArray
.
some
(
pref
=
>
Preferences
.
get
(
pref
)
.
value
)
;
}
_updateSanitizeSettingsButton
(
)
{
var
settingsButton
=
document
.
getElementById
(
"
clearDataSettings
"
)
;
var
sanitizeOnShutdownPref
=
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
;
settingsButton
.
disabled
=
!
sanitizeOnShutdownPref
.
value
;
}
toggleDoNotDisturbNotifications
(
event
)
{
AlertsServiceDND
.
manualDoNotDisturb
=
event
.
target
.
checked
;
}
initAutoStartPrivateBrowsingReverter
(
)
{
let
mode
=
document
.
getElementById
(
"
historyMode
"
)
;
this
.
_lastMode
=
mode
.
selectedIndex
;
this
.
_lastCheckState
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
value
;
}
_lastMode
:
null
_lastCheckState
:
null
async
updateAutostart
(
)
{
let
mode
=
document
.
getElementById
(
"
historyMode
"
)
;
let
autoStart
=
document
.
getElementById
(
"
privateBrowsingAutoStart
"
)
;
let
pref
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
if
(
(
mode
.
value
=
=
"
custom
"
&
&
this
.
_lastCheckState
=
=
autoStart
.
checked
)
|
|
(
mode
.
value
=
=
"
remember
"
&
&
!
this
.
_lastCheckState
)
|
|
(
mode
.
value
=
=
"
dontremember
"
&
&
this
.
_lastCheckState
)
)
{
this
.
_lastMode
=
mode
.
selectedIndex
;
this
.
_lastCheckState
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
return
;
}
if
(
!
this
.
_shouldPromptForRestart
)
{
return
;
}
let
buttonIndex
=
await
confirmRestartPrompt
(
autoStart
.
checked
1
true
false
)
;
if
(
buttonIndex
=
=
CONFIRM_RESTART_PROMPT_RESTART_NOW
)
{
pref
.
value
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
return
;
}
this
.
_shouldPromptForRestart
=
false
;
if
(
this
.
_lastCheckState
)
{
autoStart
.
checked
=
"
checked
"
;
}
else
{
autoStart
.
removeAttribute
(
"
checked
"
)
;
}
pref
.
value
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
mode
.
selectedIndex
=
this
.
_lastMode
;
mode
.
doCommand
(
)
;
this
.
_shouldPromptForRestart
=
true
;
}
showTrackingProtectionExceptions
(
)
{
let
params
=
{
permissionType
:
"
trackingprotection
"
disableETPVisible
:
true
prefilledHost
:
"
"
hideStatusColumn
:
true
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
permissions
.
xhtml
"
undefined
params
)
;
}
readBlockCookies
(
)
{
let
bcControl
=
document
.
getElementById
(
"
blockCookiesMenu
"
)
;
bcControl
.
disabled
=
Services
.
cookies
.
getCookieBehavior
(
false
)
=
=
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
;
}
writeBlockCookies
(
)
{
let
block
=
document
.
getElementById
(
"
contentBlockingBlockCookiesCheckbox
"
)
;
let
blockCookiesMenu
=
document
.
getElementById
(
"
blockCookiesMenu
"
)
;
if
(
block
.
checked
)
{
blockCookiesMenu
.
selectedIndex
=
0
;
return
this
.
writeBlockCookiesFrom
(
)
;
}
return
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
;
}
readBlockCookiesFrom
(
)
{
switch
(
Services
.
cookies
.
getCookieBehavior
(
false
)
)
{
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
:
return
"
all
-
third
-
parties
"
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
:
return
"
always
"
;
case
Ci
.
nsICookieService
.
BEHAVIOR_LIMIT_FOREIGN
:
return
"
unvisited
"
;
case
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
:
return
"
trackers
"
;
case
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
:
return
"
trackers
-
plus
-
isolate
"
;
default
:
return
undefined
;
}
}
writeBlockCookiesFrom
(
)
{
let
block
=
document
.
getElementById
(
"
blockCookiesMenu
"
)
.
selectedItem
;
switch
(
block
.
value
)
{
case
"
trackers
"
:
return
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
;
case
"
unvisited
"
:
return
Ci
.
nsICookieService
.
BEHAVIOR_LIMIT_FOREIGN
;
case
"
always
"
:
return
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
;
case
"
all
-
third
-
parties
"
:
return
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
;
case
"
trackers
-
plus
-
isolate
"
:
return
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
;
default
:
return
undefined
;
}
}
reloadAllOtherTabs
(
)
{
let
ourTab
=
window
.
browsingContext
.
topChromeWindow
.
gBrowser
.
selectedTab
;
BrowserWindowTracker
.
orderedWindows
.
forEach
(
win
=
>
{
let
otherGBrowser
=
win
.
gBrowser
;
for
(
let
tab
of
otherGBrowser
.
tabs
)
{
if
(
tab
=
=
ourTab
)
{
continue
;
}
if
(
tab
.
pinned
|
|
tab
.
selected
)
{
otherGBrowser
.
reloadTab
(
tab
)
;
}
else
{
otherGBrowser
.
discardBrowser
(
tab
)
;
}
}
}
)
;
for
(
let
notification
of
document
.
querySelectorAll
(
"
.
reload
-
tabs
"
)
)
{
notification
.
hidden
=
true
;
}
}
maybeNotifyUserToReload
(
)
{
let
shouldShow
=
false
;
if
(
window
.
BrowserWindowTracker
.
orderedWindows
.
length
>
1
)
{
shouldShow
=
true
;
}
else
{
let
tabbrowser
=
window
.
browsingContext
.
topChromeWindow
.
gBrowser
;
if
(
tabbrowser
.
tabs
.
length
>
1
)
{
shouldShow
=
true
;
}
}
if
(
shouldShow
)
{
for
(
let
notification
of
document
.
querySelectorAll
(
"
.
reload
-
tabs
"
)
)
{
notification
.
hidden
=
false
;
}
}
}
showCookieExceptions
(
)
{
var
params
=
{
blockVisible
:
true
sessionVisible
:
true
allowVisible
:
true
prefilledHost
:
"
"
permissionType
:
"
cookie
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
permissions
.
xhtml
"
undefined
params
)
;
}
showHttpsOnlyModeExceptions
(
)
{
var
params
=
{
blockVisible
:
false
sessionVisible
:
true
allowVisible
:
false
prefilledHost
:
"
"
permissionType
:
"
https
-
only
-
load
-
insecure
"
forcedHTTP
:
true
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
permissions
.
xhtml
"
undefined
params
)
;
}
showDoHExceptions
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
dohExceptions
.
xhtml
"
undefined
)
;
}
showSiteDataSettings
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
siteDataSettings
.
xhtml
"
)
;
}
toggleSiteData
(
shouldShow
)
{
let
clearButton
=
document
.
getElementById
(
"
clearSiteDataButton
"
)
;
let
settingsButton
=
document
.
getElementById
(
"
siteDataSettings
"
)
;
clearButton
.
disabled
=
!
shouldShow
;
settingsButton
.
disabled
=
!
shouldShow
;
}
showSiteDataLoading
(
)
{
let
totalSiteDataSizeLabel
=
document
.
getElementById
(
"
totalSiteDataSize
"
)
;
document
.
l10n
.
setAttributes
(
totalSiteDataSizeLabel
"
sitedata
-
total
-
size
-
calculating
"
)
;
}
updateTotalDataSizeLabel
(
siteDataUsage
)
{
SiteDataManager
.
getCacheSize
(
)
.
then
(
function
(
cacheUsage
)
{
let
totalSiteDataSizeLabel
=
document
.
getElementById
(
"
totalSiteDataSize
"
)
;
let
totalUsage
=
siteDataUsage
+
cacheUsage
;
let
[
value
unit
]
=
DownloadUtils
.
convertByteUnits
(
totalUsage
)
;
document
.
l10n
.
setAttributes
(
totalSiteDataSizeLabel
"
sitedata
-
total
-
size
"
{
value
unit
}
)
;
}
)
;
}
clearSiteData
(
)
{
let
dialogFile
=
useOldClearHistoryDialog
?
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
clearSiteData
.
xhtml
"
:
"
chrome
:
/
/
browser
/
content
/
sanitize_v2
.
xhtml
"
;
gSubDialog
.
open
(
dialogFile
{
features
:
"
resizable
=
no
"
}
{
mode
:
"
clearSiteData
"
}
)
;
}
initCookieBannerHandling
(
)
{
setSyncFromPrefListener
(
"
handleCookieBanners
"
(
)
=
>
this
.
readCookieBannerMode
(
)
)
;
setSyncToPrefListener
(
"
handleCookieBanners
"
(
)
=
>
this
.
writeCookieBannerMode
(
)
)
;
let
preference
=
Preferences
.
get
(
"
cookiebanners
.
ui
.
desktop
.
enabled
"
)
;
preference
.
on
(
"
change
"
(
)
=
>
this
.
updateCookieBannerHandlingVisibility
(
)
)
;
this
.
updateCookieBannerHandlingVisibility
(
)
;
}
readCookieBannerMode
(
)
{
return
(
Preferences
.
get
(
"
cookiebanners
.
service
.
mode
.
privateBrowsing
"
)
.
value
!
=
Ci
.
nsICookieBannerService
.
MODE_DISABLED
)
;
}
writeCookieBannerMode
(
)
{
let
checkbox
=
document
.
getElementById
(
"
handleCookieBanners
"
)
;
if
(
!
checkbox
.
checked
)
{
Services
.
prefs
.
setIntPref
(
"
cookiebanners
.
service
.
mode
"
Ci
.
nsICookieBannerService
.
MODE_DISABLED
)
;
return
Ci
.
nsICookieBannerService
.
MODE_DISABLED
;
}
return
Ci
.
nsICookieBannerService
.
MODE_REJECT
;
}
updateCookieBannerHandlingVisibility
(
)
{
let
groupbox
=
document
.
getElementById
(
"
cookieBannerHandlingGroup
"
)
;
let
isEnabled
=
Preferences
.
get
(
"
cookiebanners
.
ui
.
desktop
.
enabled
"
)
.
value
;
if
(
isEnabled
)
{
groupbox
.
removeAttribute
(
"
style
"
)
;
}
else
{
groupbox
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
}
}
_updateFirefoxSuggestToggle
(
)
{
document
.
getElementById
(
"
firefoxSuggestDataCollectionPrivacyToggle
"
)
.
hidden
=
!
UrlbarPrefs
.
get
(
"
quickSuggestEnabled
"
)
|
|
UrlbarPrefs
.
get
(
"
quickSuggestSettingsUi
"
)
!
=
QuickSuggest
.
SETTINGS_UI
.
FULL
;
}
showLocationExceptions
(
)
{
let
params
=
{
permissionType
:
"
geo
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showLocalHostExceptions
(
)
{
let
params
=
{
permissionType
:
"
localhost
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showLocalNetworkExceptions
(
)
{
let
params
=
{
permissionType
:
"
local
-
network
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showXRExceptions
(
)
{
let
params
=
{
permissionType
:
"
xr
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showCameraExceptions
(
)
{
let
params
=
{
permissionType
:
"
camera
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showMicrophoneExceptions
(
)
{
let
params
=
{
permissionType
:
"
microphone
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showSpeakerExceptions
(
)
{
let
params
=
{
permissionType
:
"
speaker
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showNotificationExceptions
(
)
{
let
params
=
{
permissionType
:
"
desktop
-
notification
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showAutoplayMediaExceptions
(
)
{
var
params
=
{
permissionType
:
"
autoplay
-
media
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
sitePermissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
showPopupExceptions
(
)
{
var
params
=
{
blockVisible
:
false
sessionVisible
:
false
allowVisible
:
true
prefilledHost
:
"
"
permissionType
:
"
popup
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
permissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
}
updateButtons
(
aButtonID
aPreferenceID
)
{
var
button
=
document
.
getElementById
(
aButtonID
)
;
var
preference
=
Preferences
.
get
(
aPreferenceID
)
;
button
.
disabled
=
!
preference
.
value
|
|
preference
.
locked
;
return
undefined
;
}
showPasswordExceptions
(
)
{
var
params
=
{
blockVisible
:
true
sessionVisible
:
false
allowVisible
:
false
hideStatusColumn
:
true
prefilledHost
:
"
"
permissionType
:
"
login
-
saving
"
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
permissions
.
xhtml
"
undefined
params
)
;
}
_initMasterPasswordUI
(
)
{
var
noMP
=
!
LoginHelper
.
isPrimaryPasswordSet
(
)
;
var
button
=
document
.
getElementById
(
"
changeMasterPassword
"
)
;
button
.
disabled
=
noMP
;
var
checkbox
=
document
.
getElementById
(
"
useMasterPassword
"
)
;
checkbox
.
checked
=
!
noMP
;
checkbox
.
disabled
=
(
noMP
&
&
!
Services
.
policies
.
isAllowed
(
"
createMasterPassword
"
)
)
|
|
(
!
noMP
&
&
!
Services
.
policies
.
isAllowed
(
"
removeMasterPassword
"
)
)
;
}
async
updateMasterPasswordButton
(
)
{
var
checkbox
=
document
.
getElementById
(
"
useMasterPassword
"
)
;
var
button
=
document
.
getElementById
(
"
changeMasterPassword
"
)
;
button
.
disabled
=
!
checkbox
.
checked
;
if
(
!
checkbox
.
checked
)
{
await
this
.
_removeMasterPassword
(
)
;
}
else
{
await
this
.
changeMasterPassword
(
)
;
}
this
.
_initMasterPasswordUI
(
)
;
}
async
_removeMasterPassword
(
)
{
var
secmodDB
=
Cc
[
"
mozilla
.
org
/
security
/
pkcs11moduledb
;
1
"
]
.
getService
(
Ci
.
nsIPKCS11ModuleDB
)
;
if
(
secmodDB
.
isFIPSEnabled
)
{
let
title
=
document
.
getElementById
(
"
fips
-
title
"
)
.
textContent
;
let
desc
=
document
.
getElementById
(
"
fips
-
desc
"
)
.
textContent
;
Services
.
prompt
.
alert
(
window
title
desc
)
;
this
.
_initMasterPasswordUI
(
)
;
}
else
{
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
preferences
/
removemp
.
xhtml
"
{
closingCallback
:
this
.
_initMasterPasswordUI
.
bind
(
this
)
}
)
;
}
}
async
changeMasterPassword
(
)
{
if
(
!
LoginHelper
.
isPrimaryPasswordSet
(
)
&
&
LoginHelper
.
getOSAuthEnabled
(
)
)
{
let
messageId
=
"
primary
-
password
-
os
-
auth
-
dialog
-
message
-
"
+
AppConstants
.
platform
;
let
[
messageText
captionText
]
=
await
document
.
l10n
.
formatMessages
(
[
{
id
:
messageId
}
{
id
:
"
master
-
password
-
os
-
auth
-
dialog
-
caption
"
}
]
)
;
let
win
=
Services
.
wm
.
getMostRecentBrowserWindow
(
)
;
let
loggedIn
=
await
OSKeyStore
.
ensureLoggedIn
(
messageText
.
value
captionText
.
value
win
false
)
;
const
result
=
loggedIn
.
authenticated
?
"
success
"
:
"
fail_user_canceled
"
;
Glean
.
pwmgr
.
promptShownOsReauth
.
record
(
{
trigger
:
"
toggle_pref_primary_password
"
result
}
)
;
if
(
!
loggedIn
.
authenticated
)
{
return
;
}
}
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
preferences
/
changemp
.
xhtml
"
{
features
:
"
resizable
=
no
"
closingCallback
:
this
.
_initMasterPasswordUI
.
bind
(
this
)
}
)
;
}
_initPasswordGenerationUI
(
)
{
let
prefValue
=
Services
.
prefs
.
getBoolPref
(
PREF_PASSWORD_GENERATION_AVAILABLE
false
)
;
document
.
getElementById
(
"
generatePasswordsBox
"
)
.
hidden
=
!
prefValue
;
}
toggleRelayIntegration
(
)
{
const
checkbox
=
document
.
getElementById
(
"
relayIntegration
"
)
;
if
(
checkbox
.
checked
)
{
FirefoxRelay
.
markAsAvailable
(
)
;
Glean
.
relayIntegration
.
enabledPrefChange
.
record
(
)
;
}
else
{
FirefoxRelay
.
markAsDisabled
(
)
;
Glean
.
relayIntegration
.
disabledPrefChange
.
record
(
)
;
}
}
_updateRelayIntegrationUI
(
)
{
document
.
getElementById
(
"
relayIntegrationBox
"
)
.
hidden
=
!
FirefoxRelay
.
isAvailable
;
document
.
getElementById
(
"
relayIntegration
"
)
.
checked
=
FirefoxRelay
.
isAvailable
&
&
!
FirefoxRelay
.
isDisabled
;
}
_initRelayIntegrationUI
(
)
{
document
.
getElementById
(
"
relayIntegrationLearnMoreLink
"
)
.
setAttribute
(
"
href
"
FirefoxRelay
.
learnMoreUrl
)
;
setEventListener
(
"
relayIntegration
"
"
command
"
gPrivacyPane
.
toggleRelayIntegration
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
signon
.
firefoxRelay
.
feature
"
)
.
on
(
"
change
"
gPrivacyPane
.
_updateRelayIntegrationUI
.
bind
(
gPrivacyPane
)
)
;
this
.
_updateRelayIntegrationUI
(
)
;
}
async
_toggleOSAuth
(
)
{
let
osReauthCheckbox
=
document
.
getElementById
(
"
osReauthCheckbox
"
)
;
const
messageText
=
await
lazy
.
AboutLoginsL10n
.
formatValue
(
"
about
-
logins
-
os
-
auth
-
dialog
-
message
"
)
;
const
captionText
=
await
lazy
.
AboutLoginsL10n
.
formatValue
(
"
about
-
logins
-
os
-
auth
-
dialog
-
caption
"
)
;
let
win
=
osReauthCheckbox
.
ownerGlobal
.
docShell
.
chromeEventHandler
.
ownerGlobal
;
let
isAuthorized
=
(
await
OSKeyStore
.
ensureLoggedIn
(
messageText
captionText
win
false
)
)
.
authenticated
;
Glean
.
pwmgr
.
promptShownOsReauth
.
record
(
{
trigger
:
"
toggle_pref_os_auth
"
result
:
isAuthorized
?
"
success
"
:
"
fail_user_canceled
"
}
)
;
if
(
!
isAuthorized
)
{
osReauthCheckbox
.
checked
=
!
osReauthCheckbox
.
checked
;
return
;
}
LoginHelper
.
setOSAuthEnabled
(
osReauthCheckbox
.
checked
)
;
Glean
.
pwmgr
.
requireOsReauthToggle
.
record
(
{
toggle_state
:
osReauthCheckbox
.
checked
}
)
;
}
_initOSAuthentication
(
)
{
let
osReauthCheckbox
=
document
.
getElementById
(
"
osReauthCheckbox
"
)
;
if
(
!
OSKeyStore
.
canReauth
(
)
|
|
Services
.
prefs
.
getBoolPref
(
"
security
.
nocertdb
"
false
)
)
{
osReauthCheckbox
.
hidden
=
true
;
return
;
}
osReauthCheckbox
.
setAttribute
(
"
checked
"
LoginHelper
.
getOSAuthEnabled
(
)
)
;
setEventListener
(
"
osReauthCheckbox
"
"
command
"
gPrivacyPane
.
_toggleOSAuth
.
bind
(
gPrivacyPane
)
)
;
}
showPasswords
(
)
{
let
loginManager
=
window
.
windowGlobalChild
.
getActor
(
"
LoginManager
"
)
;
loginManager
.
sendAsyncMessage
(
"
PasswordManager
:
OpenPreferences
"
{
entryPoint
:
"
Preferences
"
}
)
;
}
readSavePasswords
(
)
{
var
prefValue
=
Preferences
.
get
(
"
signon
.
rememberSignons
"
)
.
value
;
document
.
getElementById
(
"
passwordExceptions
"
)
.
disabled
=
!
prefValue
;
document
.
getElementById
(
"
generatePasswords
"
)
.
disabled
=
!
prefValue
;
document
.
getElementById
(
"
passwordAutofillCheckbox
"
)
.
disabled
=
!
prefValue
;
document
.
getElementById
(
"
relayIntegration
"
)
.
disabled
=
!
prefValue
|
|
Services
.
prefs
.
prefIsLocked
(
"
signon
.
firefoxRelay
.
feature
"
)
;
return
undefined
;
}
initListenersForExtensionControllingPasswordManager
(
)
{
this
.
_passwordManagerCheckbox
=
document
.
getElementById
(
"
savePasswords
"
)
;
this
.
_disableExtensionButton
=
document
.
getElementById
(
"
disablePasswordManagerExtension
"
)
;
this
.
_disableExtensionButton
.
addEventListener
(
"
command
"
makeDisableControllingExtension
(
PREF_SETTING_TYPE
PASSWORD_MANAGER_PREF_ID
)
)
;
initListenersForPrefChange
(
PREF_SETTING_TYPE
PASSWORD_MANAGER_PREF_ID
this
.
_passwordManagerCheckbox
)
;
}
readWarnAddonInstall
(
)
{
var
warn
=
Preferences
.
get
(
"
xpinstall
.
whitelist
.
required
"
)
;
var
exceptions
=
document
.
getElementById
(
"
addonExceptions
"
)
;
exceptions
.
disabled
=
!
warn
.
value
|
|
warn
.
locked
;
return
undefined
;
}
showAddonExceptions
(
)
{
var
params
=
this
.
_addonParams
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
permissions
.
xhtml
"
undefined
params
)
;
}
_addonParams
:
{
blockVisible
:
false
sessionVisible
:
false
allowVisible
:
true
prefilledHost
:
"
"
permissionType
:
"
install
"
}
showCertificates
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
pippki
/
content
/
certManager
.
xhtml
"
)
;
}
showSecurityDevices
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
pippki
/
content
/
device_manager
.
xhtml
"
)
;
}
initDataCollection
(
)
{
if
(
!
AppConstants
.
MOZ_DATA_REPORTING
&
&
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
privacySegmentation
.
preferences
.
show
"
)
)
{
document
.
getElementById
(
"
dataCollectionCategory
"
)
.
remove
(
)
;
document
.
getElementById
(
"
dataCollectionGroup
"
)
.
remove
(
)
;
return
;
}
this
.
_setupLearnMoreLink
(
"
toolkit
.
datacollection
.
infoURL
"
"
dataCollectionPrivacyNotice
"
)
;
this
.
initPrivacySegmentation
(
)
;
}
initPrivacySegmentation
(
)
{
let
section
=
document
.
getElementById
(
"
privacySegmentationSection
"
)
;
let
updatePrivacySegmentationSectionVisibilityState
=
(
)
=
>
{
section
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
privacySegmentation
.
preferences
.
show
"
)
;
}
;
Services
.
prefs
.
addObserver
(
"
browser
.
privacySegmentation
.
preferences
.
show
"
updatePrivacySegmentationSectionVisibilityState
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Services
.
prefs
.
removeObserver
(
"
browser
.
privacySegmentation
.
preferences
.
show
"
updatePrivacySegmentationSectionVisibilityState
)
;
}
)
;
updatePrivacySegmentationSectionVisibilityState
(
)
;
}
_setupLearnMoreLink
(
pref
element
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
pref
)
;
let
el
=
document
.
getElementById
(
element
)
;
if
(
url
)
{
el
.
setAttribute
(
"
href
"
url
)
;
}
else
{
el
.
hidden
=
true
;
}
}
updateSubmitHealthReportFromPref
(
)
{
let
checkbox
=
document
.
getElementById
(
"
submitHealthReportBox
"
)
;
let
telemetryContainer
=
document
.
getElementById
(
"
telemetry
-
container
"
)
;
if
(
Services
.
prefs
.
prefIsLocked
(
PREF_UPLOAD_ENABLED
)
|
|
!
AppConstants
.
MOZ_TELEMETRY_REPORTING
)
{
checkbox
.
setAttribute
(
"
disabled
"
"
true
"
)
;
return
;
}
checkbox
.
checked
=
Services
.
prefs
.
getBoolPref
(
PREF_UPLOAD_ENABLED
)
&
&
AppConstants
.
MOZ_TELEMETRY_REPORTING
;
telemetryContainer
.
hidden
=
checkbox
.
checked
;
}
updateSubmitHealthReportToPref
(
)
{
let
checkbox
=
document
.
getElementById
(
"
submitHealthReportBox
"
)
;
let
telemetryContainer
=
document
.
getElementById
(
"
telemetry
-
container
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_UPLOAD_ENABLED
checkbox
.
checked
)
;
telemetryContainer
.
hidden
=
checkbox
.
checked
;
}
initOptOutStudyCheckbox
(
)
{
const
allowedByPolicy
=
Services
.
policies
.
isAllowed
(
"
Shield
"
)
;
const
checkbox
=
document
.
getElementById
(
"
optOutStudiesEnabled
"
)
;
function
updateCheckbox
(
)
{
if
(
allowedByPolicy
&
&
Services
.
prefs
.
getBoolPref
(
PREF_UPLOAD_ENABLED
false
)
&
&
Services
.
prefs
.
getBoolPref
(
PREF_NORMANDY_ENABLED
false
)
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_OPT_OUT_STUDIES_ENABLED
false
)
)
{
checkbox
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
checkbox
.
removeAttribute
(
"
checked
"
)
;
}
checkbox
.
setAttribute
(
"
preference
"
PREF_OPT_OUT_STUDIES_ENABLED
)
;
checkbox
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
checkbox
.
removeAttribute
(
"
preference
"
)
;
checkbox
.
removeAttribute
(
"
checked
"
)
;
checkbox
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
Preferences
.
get
(
PREF_UPLOAD_ENABLED
)
.
on
(
"
change
"
updateCheckbox
)
;
updateCheckbox
(
)
;
}
initAddonRecommendationsCheckbox
(
)
{
dataCollectionCheckboxHandler
(
{
checkbox
:
document
.
getElementById
(
"
addonRecommendationEnabled
"
)
pref
:
PREF_ADDON_RECOMMENDATIONS_ENABLED
}
)
;
}
observe
(
aSubject
aTopic
)
{
switch
(
aTopic
)
{
case
"
sitedatamanager
:
updating
-
sites
"
:
this
.
toggleSiteData
(
false
)
;
this
.
showSiteDataLoading
(
)
;
break
;
case
"
sitedatamanager
:
sites
-
updated
"
:
this
.
toggleSiteData
(
true
)
;
SiteDataManager
.
getTotalUsage
(
)
.
then
(
this
.
updateTotalDataSizeLabel
.
bind
(
this
)
)
;
break
;
case
"
network
:
trr
-
uri
-
changed
"
:
case
"
network
:
trr
-
mode
-
changed
"
:
case
"
network
:
trr
-
confirmation
"
:
gPrivacyPane
.
updateDoHStatus
(
)
;
break
;
}
}
_initProfilesInfo
(
)
{
setEventListener
(
"
dataCollectionViewProfiles
"
"
click
"
gMainPane
.
manageProfiles
)
;
let
listener
=
(
)
=
>
gPrivacyPane
.
updateProfilesPrivacyInfo
(
)
;
SelectableProfileService
.
on
(
"
enableChanged
"
listener
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
SelectableProfileService
.
off
(
"
enableChanged
"
listener
)
)
;
this
.
updateProfilesPrivacyInfo
(
)
;
}
setUpLocalNetworkAccessPermissionUI
(
)
{
const
isLNADisabled
=
!
Preferences
.
get
(
"
network
.
lna
.
blocking
"
)
.
value
;
document
.
getElementById
(
"
localHostSettingsRow
"
)
.
hidden
=
isLNADisabled
;
document
.
getElementById
(
"
localNetworkSettingsRow
"
)
.
hidden
=
isLNADisabled
;
}
updateProfilesPrivacyInfo
(
)
{
let
profilesInfo
=
document
.
getElementById
(
"
preferences
-
privacy
-
profiles
"
)
;
profilesInfo
.
hidden
=
!
SelectableProfileService
.
isEnabled
;
}
async
onBaselineCheckboxChange
(
event
)
{
if
(
event
.
target
.
slot
=
=
=
"
nested
"
)
{
return
;
}
if
(
event
.
target
.
checked
)
{
this
.
maybeNotifyUserToReload
(
)
;
return
;
}
let
[
title
body
okButtonText
cancelButtonText
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
content
-
blocking
-
baseline
-
uncheck
-
warning
-
dialog
-
title
"
}
{
id
:
"
content
-
blocking
-
baseline
-
uncheck
-
warning
-
dialog
-
body
"
}
{
id
:
"
content
-
blocking
-
baseline
-
uncheck
-
warning
-
dialog
-
ok
-
button
"
}
{
id
:
"
content
-
blocking
-
baseline
-
uncheck
-
warning
-
dialog
-
cancel
-
button
"
}
]
)
;
let
flags
=
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
*
Services
.
prompt
.
BUTTON_POS_1
+
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
*
Services
.
prompt
.
BUTTON_POS_0
+
Services
.
prompt
.
BUTTON_POS_0_DEFAULT
;
const
result
=
await
Services
.
prompt
.
asyncConfirmEx
(
window
.
browsingContext
Services
.
prompt
.
MODAL_TYPE_CONTENT
title
body
flags
cancelButtonText
okButtonText
null
null
false
{
useTitle
:
true
}
)
;
const
propertyBag
=
result
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
if
(
propertyBag
.
get
(
"
buttonNumClicked
"
)
=
=
1
)
{
event
.
target
.
checked
=
false
;
this
.
maybeNotifyUserToReload
(
)
;
}
else
{
event
.
target
.
checked
=
true
;
Services
.
prefs
.
setBoolPref
(
"
privacy
.
trackingprotection
.
allow_list
.
baseline
.
enabled
"
true
)
;
}
}
}
;
