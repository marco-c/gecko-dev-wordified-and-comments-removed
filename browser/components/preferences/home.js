ChromeUtils
.
defineESModuleGetters
(
this
{
ExtensionUtils
:
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
sys
.
mjs
"
}
)
;
Preferences
.
addAll
(
[
{
id
:
"
browser
.
startup
.
homepage
"
type
:
"
wstring
"
}
{
id
:
"
pref
.
browser
.
homepage
.
disable_button
.
current_page
"
type
:
"
bool
"
}
{
id
:
"
pref
.
browser
.
homepage
.
disable_button
.
bookmark_page
"
type
:
"
bool
"
}
{
id
:
"
pref
.
browser
.
homepage
.
disable_button
.
restore_default
"
type
:
"
bool
"
}
{
id
:
"
browser
.
newtabpage
.
enabled
"
type
:
"
bool
"
}
]
)
;
const
HOMEPAGE_OVERRIDE_KEY
=
"
homepage_override
"
;
const
URL_OVERRIDES_TYPE
=
"
url_overrides
"
;
const
NEW_TAB_KEY
=
"
newTabURL
"
;
const
BLANK_HOMEPAGE_URL
=
"
chrome
:
/
/
browser
/
content
/
blanktab
.
html
"
;
var
gHomePane
=
{
HOME_MODE_FIREFOX_HOME
:
"
0
"
HOME_MODE_BLANK
:
"
1
"
HOME_MODE_CUSTOM
:
"
2
"
HOMEPAGE_PREF
:
"
browser
.
startup
.
homepage
"
NEWTAB_ENABLED_PREF
:
"
browser
.
newtabpage
.
enabled
"
ACTIVITY_STREAM_PREF_BRANCH
:
"
browser
.
newtabpage
.
activity
-
stream
.
"
get
homePanePrefs
(
)
{
return
Preferences
.
getAll
(
)
.
filter
(
pref
=
>
pref
.
id
.
includes
(
this
.
ACTIVITY_STREAM_PREF_BRANCH
)
)
;
}
get
isPocketNewtabEnabled
(
)
{
const
value
=
Services
.
prefs
.
getStringPref
(
"
browser
.
newtabpage
.
activity
-
stream
.
discoverystream
.
config
"
"
"
)
;
if
(
value
)
{
try
{
return
JSON
.
parse
(
value
)
.
enabled
;
}
catch
(
e
)
{
console
.
error
(
"
Failed
to
parse
Discovery
Stream
pref
.
"
)
;
}
}
return
false
;
}
async
syncToNewTabPref
(
)
{
let
menulist
=
document
.
getElementById
(
"
newTabMode
"
)
;
if
(
[
"
0
"
"
1
"
]
.
includes
(
menulist
.
value
)
)
{
let
newtabEnabledPref
=
Services
.
prefs
.
getBoolPref
(
this
.
NEWTAB_ENABLED_PREF
true
)
;
let
newValue
=
menulist
.
value
!
=
=
this
.
HOME_MODE_BLANK
;
if
(
newtabEnabledPref
!
=
=
newValue
)
{
Services
.
prefs
.
setBoolPref
(
this
.
NEWTAB_ENABLED_PREF
newValue
)
;
}
let
selectedAddon
=
ExtensionSettingsStore
.
getSetting
(
URL_OVERRIDES_TYPE
NEW_TAB_KEY
)
;
if
(
selectedAddon
)
{
ExtensionSettingsStore
.
select
(
null
URL_OVERRIDES_TYPE
NEW_TAB_KEY
)
;
}
}
else
{
let
addon
=
await
AddonManager
.
getAddonByID
(
menulist
.
value
)
;
if
(
addon
&
&
addon
.
isActive
)
{
ExtensionSettingsStore
.
select
(
addon
.
id
URL_OVERRIDES_TYPE
NEW_TAB_KEY
)
;
}
}
}
async
syncFromNewTabPref
(
)
{
let
menulist
=
document
.
getElementById
(
"
newTabMode
"
)
;
if
(
AboutNewTab
.
newTabURL
=
=
=
"
about
:
newtab
"
|
|
AboutNewTab
.
newTabURL
=
=
=
"
about
:
blank
"
|
|
AboutNewTab
.
newTabURL
=
=
=
BLANK_HOMEPAGE_URL
)
{
let
newtabEnabledPref
=
Services
.
prefs
.
getBoolPref
(
this
.
NEWTAB_ENABLED_PREF
true
)
;
let
newValue
=
newtabEnabledPref
?
this
.
HOME_MODE_FIREFOX_HOME
:
this
.
HOME_MODE_BLANK
;
if
(
newValue
!
=
=
menulist
.
value
)
{
menulist
.
value
=
newValue
;
}
menulist
.
disabled
=
Preferences
.
get
(
this
.
NEWTAB_ENABLED_PREF
)
.
locked
;
}
else
{
let
selectedAddon
=
ExtensionSettingsStore
.
getSetting
(
URL_OVERRIDES_TYPE
NEW_TAB_KEY
)
;
if
(
selectedAddon
&
&
menulist
.
value
!
=
=
selectedAddon
.
id
)
{
menulist
.
value
=
selectedAddon
.
id
;
}
}
}
async
_updateMenuInterface
(
selectId
)
{
let
selects
;
if
(
selectId
)
{
selects
=
[
document
.
getElementById
(
selectId
)
]
;
}
else
{
let
newTabSelect
=
document
.
getElementById
(
"
newTabMode
"
)
;
let
homeSelect
=
document
.
getElementById
(
"
homeMode
"
)
;
selects
=
[
homeSelect
newTabSelect
]
;
}
for
(
let
select
of
selects
)
{
let
menuOptions
=
Array
.
from
(
select
.
menupopup
.
childNodes
)
;
for
(
let
option
of
menuOptions
)
{
if
(
!
/
^
\
d
+
/
.
test
(
option
.
value
)
)
{
let
addon
=
await
AddonManager
.
getAddonByID
(
option
.
value
)
;
if
(
option
&
&
(
!
addon
|
|
!
addon
.
isActive
)
)
{
option
.
remove
(
)
;
}
}
}
let
extensionOptions
;
await
ExtensionSettingsStore
.
initialize
(
)
;
if
(
select
.
id
=
=
=
"
homeMode
"
)
{
extensionOptions
=
ExtensionSettingsStore
.
getAllSettings
(
PREF_SETTING_TYPE
HOMEPAGE_OVERRIDE_KEY
)
;
}
else
{
extensionOptions
=
ExtensionSettingsStore
.
getAllSettings
(
URL_OVERRIDES_TYPE
NEW_TAB_KEY
)
;
}
let
addons
=
await
AddonManager
.
getAddonsByIDs
(
extensionOptions
.
map
(
a
=
>
a
.
id
)
)
;
let
menupopup
=
select
.
querySelector
(
"
menupopup
"
)
;
for
(
let
addon
of
addons
)
{
if
(
!
addon
|
|
!
addon
.
id
|
|
!
addon
.
isActive
)
{
continue
;
}
let
currentOption
=
select
.
querySelector
(
[
value
=
"
{
CSS
.
escape
(
addon
.
id
)
}
"
]
)
;
if
(
!
currentOption
)
{
let
option
=
document
.
createXULElement
(
"
menuitem
"
)
;
option
.
value
=
addon
.
id
;
option
.
label
=
addon
.
name
;
menupopup
.
append
(
option
)
;
}
let
setting
=
extensionOptions
.
find
(
o
=
>
o
.
id
=
=
addon
.
id
)
;
if
(
(
select
.
id
=
=
=
"
homeMode
"
&
&
setting
.
value
=
=
HomePage
.
get
(
)
)
|
|
(
select
.
id
=
=
=
"
newTabMode
"
&
&
setting
.
value
=
=
AboutNewTab
.
newTabURL
)
)
{
select
.
value
=
addon
.
id
;
}
}
}
}
watchNewTab
(
)
{
let
newTabObserver
=
(
)
=
>
{
this
.
syncFromNewTabPref
(
)
;
this
.
_updateMenuInterface
(
"
newTabMode
"
)
;
}
;
Services
.
obs
.
addObserver
(
newTabObserver
"
newtab
-
url
-
changed
"
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Services
.
obs
.
removeObserver
(
newTabObserver
"
newtab
-
url
-
changed
"
)
;
}
)
;
}
watchHomePrefChange
(
)
{
const
homePrefObserver
=
(
subject
topic
data
)
=
>
{
if
(
data
&
&
data
!
=
this
.
HOMEPAGE_PREF
)
{
return
;
}
this
.
_updateUseCurrentButton
(
)
;
this
.
_renderCustomSettings
(
)
;
this
.
_handleHomePageOverrides
(
)
;
this
.
_updateMenuInterface
(
"
homeMode
"
)
;
}
;
Services
.
prefs
.
addObserver
(
this
.
HOMEPAGE_PREF
homePrefObserver
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Services
.
prefs
.
removeObserver
(
this
.
HOMEPAGE_PREF
homePrefObserver
)
;
}
)
;
}
watchExtensionPrefChange
(
)
{
const
extensionSettingChanged
=
(
evt
setting
)
=
>
{
if
(
setting
.
key
=
=
"
homepage_override
"
&
&
setting
.
type
=
=
"
prefs
"
)
{
this
.
_updateMenuInterface
(
"
homeMode
"
)
;
}
else
if
(
setting
.
key
=
=
"
newTabURL
"
&
&
setting
.
type
=
=
"
url_overrides
"
)
{
this
.
_updateMenuInterface
(
"
newTabMode
"
)
;
}
}
;
Management
.
on
(
"
extension
-
setting
-
changed
"
extensionSettingChanged
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Management
.
off
(
"
extension
-
setting
-
changed
"
extensionSettingChanged
)
;
}
)
;
}
watchHomeTabPrefChange
(
)
{
const
observer
=
(
)
=
>
this
.
toggleRestoreDefaultsBtn
(
)
;
Services
.
prefs
.
addObserver
(
this
.
ACTIVITY_STREAM_PREF_BRANCH
observer
)
;
Services
.
prefs
.
addObserver
(
this
.
HOMEPAGE_PREF
observer
)
;
Services
.
prefs
.
addObserver
(
this
.
NEWTAB_ENABLED_PREF
observer
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Services
.
prefs
.
removeObserver
(
this
.
ACTIVITY_STREAM_PREF_BRANCH
observer
)
;
Services
.
prefs
.
removeObserver
(
this
.
HOMEPAGE_PREF
observer
)
;
Services
.
prefs
.
removeObserver
(
this
.
NEWTAB_ENABLED_PREF
observer
)
;
}
)
;
}
_renderCustomSettings
(
options
=
{
}
)
{
let
{
shouldShow
isControlled
}
=
options
;
const
customSettingsContainerEl
=
document
.
getElementById
(
"
customSettings
"
)
;
const
customUrlEl
=
document
.
getElementById
(
"
homePageUrl
"
)
;
const
homePage
=
HomePage
.
get
(
)
;
const
isHomePageCustom
=
(
!
this
.
_isHomePageDefaultValue
(
)
&
&
!
this
.
isHomePageBlank
(
)
&
&
!
isControlled
)
|
|
homePage
.
locked
;
if
(
typeof
shouldShow
=
=
=
"
undefined
"
)
{
shouldShow
=
isHomePageCustom
;
}
customSettingsContainerEl
.
hidden
=
!
shouldShow
;
let
newValue
;
if
(
this
.
_isBlankPage
(
homePage
)
|
|
(
HomePage
.
isDefault
&
&
!
HomePage
.
locked
)
)
{
newValue
=
"
"
;
}
else
{
newValue
=
homePage
;
}
if
(
customUrlEl
.
value
!
=
=
newValue
)
{
customUrlEl
.
value
=
newValue
;
}
}
_isHomePageDefaultValue
(
)
{
const
startupPref
=
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
;
return
(
startupPref
.
value
!
=
=
gMainPane
.
STARTUP_PREF_BLANK
&
&
HomePage
.
isDefault
)
;
}
isHomePageBlank
(
)
{
const
startupPref
=
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
;
return
(
[
"
about
:
blank
"
BLANK_HOMEPAGE_URL
"
"
]
.
includes
(
HomePage
.
get
(
)
)
|
|
startupPref
.
value
=
=
=
gMainPane
.
STARTUP_PREF_BLANK
)
;
}
_isTabAboutPreferencesOrSettings
(
aTab
)
{
return
(
aTab
.
linkedBrowser
.
currentURI
.
spec
.
startsWith
(
"
about
:
preferences
"
)
|
|
aTab
.
linkedBrowser
.
currentURI
.
spec
.
startsWith
(
"
about
:
settings
"
)
)
;
}
_getTabsForHomePage
(
)
{
let
tabs
=
[
]
;
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
win
&
&
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
=
"
navigator
:
browser
"
)
{
tabs
=
win
.
gBrowser
.
visibleTabs
.
slice
(
win
.
gBrowser
.
pinnedTabCount
)
;
tabs
=
tabs
.
filter
(
tab
=
>
!
this
.
_isTabAboutPreferencesOrSettings
(
tab
)
)
;
tabs
=
tabs
.
filter
(
tab
=
>
!
tab
.
closing
)
;
}
return
tabs
;
}
_renderHomepageMode
(
controllingExtension
)
{
const
isDefault
=
this
.
_isHomePageDefaultValue
(
)
;
const
isBlank
=
this
.
isHomePageBlank
(
)
;
const
el
=
document
.
getElementById
(
"
homeMode
"
)
;
let
newValue
;
if
(
controllingExtension
&
&
controllingExtension
.
id
)
{
newValue
=
controllingExtension
.
id
;
}
else
if
(
isDefault
)
{
newValue
=
this
.
HOME_MODE_FIREFOX_HOME
;
}
else
if
(
isBlank
)
{
newValue
=
this
.
HOME_MODE_BLANK
;
}
else
{
newValue
=
this
.
HOME_MODE_CUSTOM
;
}
if
(
el
.
value
!
=
=
newValue
)
{
el
.
value
=
newValue
;
}
}
_setInputDisabledStates
(
isControlled
)
{
let
tabCount
=
this
.
_getTabsForHomePage
(
)
.
length
;
document
.
querySelectorAll
(
"
.
check
-
home
-
page
-
controlled
"
)
.
forEach
(
element
=
>
{
let
isDisabled
;
let
pref
=
element
.
getAttribute
(
"
preference
"
)
|
|
element
.
getAttribute
(
"
data
-
preference
-
related
"
)
;
if
(
!
pref
)
{
throw
new
Error
(
Element
with
id
{
element
.
id
}
did
not
have
preference
or
data
-
preference
-
related
attribute
defined
.
)
;
}
if
(
pref
=
=
=
this
.
HOMEPAGE_PREF
)
{
isDisabled
=
HomePage
.
locked
;
}
else
{
isDisabled
=
Preferences
.
get
(
pref
)
.
locked
|
|
isControlled
;
}
if
(
pref
=
=
=
"
pref
.
browser
.
disable_button
.
current_page
"
)
{
isDisabled
=
isDisabled
|
|
tabCount
<
1
;
}
element
.
disabled
=
isDisabled
;
}
)
;
}
async
_handleHomePageOverrides
(
)
{
let
controllingExtension
;
if
(
HomePage
.
locked
)
{
this
.
_renderCustomSettings
(
)
;
this
.
_setInputDisabledStates
(
false
)
;
}
else
{
if
(
ExtensionUtils
.
isExtensionUrl
(
HomePage
.
get
(
)
)
)
{
controllingExtension
=
await
getControllingExtension
(
PREF_SETTING_TYPE
HOMEPAGE_OVERRIDE_KEY
)
;
}
this
.
_setInputDisabledStates
(
)
;
this
.
_renderCustomSettings
(
{
isControlled
:
!
!
controllingExtension
}
)
;
}
this
.
_renderHomepageMode
(
controllingExtension
)
;
}
onMenuChange
(
event
)
{
const
{
value
}
=
event
.
target
;
const
startupPref
=
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
;
let
selectedAddon
=
ExtensionSettingsStore
.
getSetting
(
PREF_SETTING_TYPE
HOMEPAGE_OVERRIDE_KEY
)
;
switch
(
value
)
{
case
this
.
HOME_MODE_FIREFOX_HOME
:
if
(
startupPref
.
value
=
=
=
gMainPane
.
STARTUP_PREF_BLANK
)
{
startupPref
.
value
=
gMainPane
.
STARTUP_PREF_HOMEPAGE
;
}
if
(
!
HomePage
.
isDefault
)
{
HomePage
.
reset
(
)
;
}
else
{
this
.
_renderCustomSettings
(
{
shouldShow
:
false
}
)
;
}
if
(
selectedAddon
)
{
ExtensionSettingsStore
.
select
(
null
PREF_SETTING_TYPE
HOMEPAGE_OVERRIDE_KEY
)
;
}
break
;
case
this
.
HOME_MODE_BLANK
:
if
(
!
this
.
_isBlankPage
(
HomePage
.
get
(
)
)
)
{
HomePage
.
safeSet
(
BLANK_HOMEPAGE_URL
)
;
}
else
{
this
.
_renderCustomSettings
(
{
shouldShow
:
false
}
)
;
}
if
(
selectedAddon
)
{
ExtensionSettingsStore
.
select
(
null
PREF_SETTING_TYPE
HOMEPAGE_OVERRIDE_KEY
)
;
}
break
;
case
this
.
HOME_MODE_CUSTOM
:
if
(
startupPref
.
value
=
=
=
gMainPane
.
STARTUP_PREF_BLANK
)
{
Services
.
prefs
.
clearUserPref
(
startupPref
.
id
)
;
}
if
(
HomePage
.
getDefault
(
)
!
=
HomePage
.
getOriginalDefault
(
)
)
{
HomePage
.
clear
(
)
;
}
this
.
_renderCustomSettings
(
{
shouldShow
:
true
}
)
;
if
(
selectedAddon
)
{
ExtensionSettingsStore
.
select
(
null
PREF_SETTING_TYPE
HOMEPAGE_OVERRIDE_KEY
)
;
}
break
;
default
:
AddonManager
.
getAddonByID
(
value
)
.
then
(
addon
=
>
{
if
(
addon
&
&
addon
.
isActive
)
{
ExtensionPreferencesManager
.
selectSetting
(
addon
.
id
HOMEPAGE_OVERRIDE_KEY
)
;
}
this
.
_renderCustomSettings
(
{
shouldShow
:
false
}
)
;
}
)
;
}
}
async
_updateUseCurrentButton
(
)
{
let
useCurrent
=
document
.
getElementById
(
"
useCurrentBtn
"
)
;
let
tabs
=
this
.
_getTabsForHomePage
(
)
;
const
tabCount
=
tabs
.
length
;
document
.
l10n
.
setAttributes
(
useCurrent
"
use
-
current
-
pages
"
{
tabCount
}
)
;
if
(
await
getControllingExtensionInfo
(
PREF_SETTING_TYPE
HOMEPAGE_OVERRIDE_KEY
)
)
{
return
;
}
let
prefName
=
"
pref
.
browser
.
homepage
.
disable_button
.
current_page
"
;
if
(
Preferences
.
get
(
prefName
)
.
locked
)
{
return
;
}
useCurrent
.
disabled
=
tabCount
<
1
;
}
setHomePageToCurrent
(
)
{
let
tabs
=
this
.
_getTabsForHomePage
(
)
;
function
getTabURI
(
t
)
{
return
t
.
linkedBrowser
.
currentURI
.
spec
;
}
if
(
tabs
.
length
)
{
HomePage
.
set
(
tabs
.
map
(
getTabURI
)
.
join
(
"
|
"
)
)
.
catch
(
console
.
error
)
;
}
}
_setHomePageToBookmarkClosed
(
rv
aEvent
)
{
if
(
aEvent
.
detail
.
button
!
=
"
accept
"
)
{
return
;
}
if
(
rv
.
urls
&
&
rv
.
names
)
{
HomePage
.
set
(
rv
.
urls
.
join
(
"
|
"
)
)
.
catch
(
console
.
error
)
;
}
}
setHomePageToBookmark
(
)
{
const
rv
=
{
urls
:
null
names
:
null
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
selectBookmark
.
xhtml
"
{
features
:
"
resizable
=
yes
modal
=
yes
"
closingCallback
:
this
.
_setHomePageToBookmarkClosed
.
bind
(
this
rv
)
}
rv
)
;
}
restoreDefaultHomePage
(
)
{
HomePage
.
reset
(
)
;
this
.
_handleHomePageOverrides
(
)
;
Services
.
prefs
.
clearUserPref
(
this
.
NEWTAB_ENABLED_PREF
)
;
AboutNewTab
.
resetNewTabURL
(
)
;
}
onCustomHomePageChange
(
event
)
{
const
value
=
event
.
target
.
value
|
|
HomePage
.
getDefault
(
)
;
HomePage
.
set
(
value
)
.
catch
(
console
.
error
)
;
}
_changedHomeTabDefaultPrefs
(
)
{
const
homeContentChanged
=
!
this
.
isPocketNewtabEnabled
&
&
this
.
homePanePrefs
.
some
(
pref
=
>
pref
.
hasUserValue
)
;
const
newtabPref
=
Preferences
.
get
(
this
.
NEWTAB_ENABLED_PREF
)
;
const
extensionControlled
=
Preferences
.
get
(
"
browser
.
startup
.
homepage_override
.
extensionControlled
"
)
;
return
(
homeContentChanged
|
|
HomePage
.
overridden
|
|
newtabPref
.
hasUserValue
|
|
AboutNewTab
.
newTabURLOverridden
|
|
extensionControlled
)
;
}
_isBlankPage
(
url
)
{
return
url
=
=
"
about
:
blank
"
|
|
url
=
=
BLANK_HOMEPAGE_URL
;
}
toggleRestoreDefaultsBtn
(
)
{
const
btn
=
document
.
getElementById
(
"
restoreDefaultHomePageBtn
"
)
;
const
prefChanged
=
this
.
_changedHomeTabDefaultPrefs
(
)
;
if
(
prefChanged
)
{
btn
.
style
.
removeProperty
(
"
visibility
"
)
;
}
else
{
btn
.
style
.
visibility
=
"
hidden
"
;
}
}
restoreDefaultPrefsForHome
(
)
{
this
.
restoreDefaultHomePage
(
)
;
if
(
!
this
.
isPocketNewtabEnabled
)
{
this
.
homePanePrefs
.
forEach
(
pref
=
>
Services
.
prefs
.
clearUserPref
(
pref
.
id
)
)
;
}
}
init
(
)
{
document
.
getElementById
(
"
homePageUrl
"
)
.
addEventListener
(
"
change
"
this
.
onCustomHomePageChange
.
bind
(
this
)
)
;
document
.
getElementById
(
"
useCurrentBtn
"
)
.
addEventListener
(
"
command
"
this
.
setHomePageToCurrent
.
bind
(
this
)
)
;
document
.
getElementById
(
"
useBookmarkBtn
"
)
.
addEventListener
(
"
command
"
this
.
setHomePageToBookmark
.
bind
(
this
)
)
;
document
.
getElementById
(
"
restoreDefaultHomePageBtn
"
)
.
addEventListener
(
"
command
"
this
.
restoreDefaultPrefsForHome
.
bind
(
this
)
)
;
this
.
_updateMenuInterface
(
)
;
document
.
getElementById
(
"
newTabMode
"
)
.
addEventListener
(
"
command
"
this
.
syncToNewTabPref
.
bind
(
this
)
)
;
document
.
getElementById
(
"
homeMode
"
)
.
addEventListener
(
"
command
"
this
.
onMenuChange
.
bind
(
this
)
)
;
this
.
_updateUseCurrentButton
(
)
;
this
.
_handleHomePageOverrides
(
)
;
this
.
syncFromNewTabPref
(
)
;
window
.
addEventListener
(
"
focus
"
this
.
_updateUseCurrentButton
.
bind
(
this
)
)
;
this
.
watchNewTab
(
)
;
this
.
watchHomePrefChange
(
)
;
this
.
watchExtensionPrefChange
(
)
;
this
.
watchHomeTabPrefChange
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
home
-
pane
-
loaded
"
)
;
}
}
;
