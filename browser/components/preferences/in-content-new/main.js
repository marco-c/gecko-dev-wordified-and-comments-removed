Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
TransientPrefs
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoadContextInfo
.
jsm
"
)
;
const
TYPE_MAYBE_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
feed
"
;
const
TYPE_MAYBE_VIDEO_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
video
.
feed
"
;
const
TYPE_MAYBE_AUDIO_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
audio
.
feed
"
;
const
TYPE_PDF
=
"
application
/
pdf
"
;
const
PREF_PDFJS_DISABLED
=
"
pdfjs
.
disabled
"
;
const
TOPIC_PDFJS_HANDLER_CHANGED
=
"
pdfjs
:
handlerChanged
"
;
const
PREF_DISABLED_PLUGIN_TYPES
=
"
plugin
.
disable_full_page_plugin_for_types
"
;
const
PREF_SHOW_PLUGINS_IN_LIST
=
"
browser
.
download
.
show_plugins_in_list
"
;
const
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
=
"
browser
.
download
.
hide_plugins_without_extensions
"
;
const
PREF_FEED_SELECTED_APP
=
"
browser
.
feeds
.
handlers
.
application
"
;
const
PREF_FEED_SELECTED_WEB
=
"
browser
.
feeds
.
handlers
.
webservice
"
;
const
PREF_FEED_SELECTED_ACTION
=
"
browser
.
feeds
.
handler
"
;
const
PREF_FEED_SELECTED_READER
=
"
browser
.
feeds
.
handler
.
default
"
;
const
PREF_VIDEO_FEED_SELECTED_APP
=
"
browser
.
videoFeeds
.
handlers
.
application
"
;
const
PREF_VIDEO_FEED_SELECTED_WEB
=
"
browser
.
videoFeeds
.
handlers
.
webservice
"
;
const
PREF_VIDEO_FEED_SELECTED_ACTION
=
"
browser
.
videoFeeds
.
handler
"
;
const
PREF_VIDEO_FEED_SELECTED_READER
=
"
browser
.
videoFeeds
.
handler
.
default
"
;
const
PREF_AUDIO_FEED_SELECTED_APP
=
"
browser
.
audioFeeds
.
handlers
.
application
"
;
const
PREF_AUDIO_FEED_SELECTED_WEB
=
"
browser
.
audioFeeds
.
handlers
.
webservice
"
;
const
PREF_AUDIO_FEED_SELECTED_ACTION
=
"
browser
.
audioFeeds
.
handler
"
;
const
PREF_AUDIO_FEED_SELECTED_READER
=
"
browser
.
audioFeeds
.
handler
.
default
"
;
const
kActionUsePlugin
=
5
;
const
ICON_URL_APP
=
AppConstants
.
platform
=
=
"
linux
"
?
"
moz
-
icon
:
/
/
dummy
.
exe
?
size
=
16
"
:
"
chrome
:
/
/
browser
/
skin
/
preferences
/
application
.
png
"
;
const
APP_ICON_ATTR_NAME
=
"
appHandlerIcon
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
if
(
AppConstants
.
E10S_TESTING_ONLY
)
{
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
}
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
}
var
gMainPane
=
{
_handledTypes
:
{
}
_visibleTypes
:
[
]
_visibleTypeDescriptionCount
:
{
}
_brandShortName
:
null
_prefsBundle
:
null
_list
:
null
_filter
:
null
_prefSvc
:
Cc
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrefBranch
)
_mimeSvc
:
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
_helperAppSvc
:
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
helper
-
app
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalHelperAppService
)
_handlerSvc
:
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
_ioSvc
:
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
init
(
)
{
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gMainPane
)
)
;
}
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
this
.
updateSetDefaultBrowser
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
pollForDefaultBrowser
=
(
)
=
>
{
let
uri
=
win
.
gBrowser
.
currentURI
.
spec
;
if
(
(
uri
=
=
"
about
:
preferences
"
|
|
uri
=
=
"
about
:
preferences
#
general
"
)
&
&
document
.
visibilityState
=
=
"
visible
"
)
{
this
.
updateSetDefaultBrowser
(
)
;
}
window
.
setTimeout
(
(
)
=
>
{
window
.
requestIdleCallback
(
pollForDefaultBrowser
)
;
}
1000
)
;
}
;
window
.
setTimeout
(
(
)
=
>
{
window
.
requestIdleCallback
(
pollForDefaultBrowser
)
;
}
1000
)
;
}
}
this
.
initBrowserContainers
(
)
;
this
.
buildContentProcessCountMenuList
(
)
;
let
performanceSettingsLink
=
document
.
getElementById
(
"
performanceSettingsLearnMore
"
)
;
let
performanceSettingsUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
performance
"
;
performanceSettingsLink
.
setAttribute
(
"
href
"
performanceSettingsUrl
)
;
this
.
updateDefaultPerformanceSettingsPref
(
)
;
let
defaultPerformancePref
=
document
.
getElementById
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
defaultPerformancePref
.
addEventListener
(
"
change
"
(
)
=
>
{
this
.
updatePerformanceSettingsBox
(
{
duringChangeEvent
:
true
}
)
;
}
)
;
this
.
updatePerformanceSettingsBox
(
{
duringChangeEvent
:
false
}
)
;
this
.
_updateUseCurrentButton
(
)
;
window
.
addEventListener
(
"
focus
"
this
.
_updateUseCurrentButton
.
bind
(
this
)
)
;
this
.
updateBrowserStartupLastSession
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
try
{
let
sysInfo
=
Cc
[
"
mozilla
.
org
/
system
-
info
;
1
"
]
.
getService
(
Ci
.
nsIPropertyBag2
)
;
let
ver
=
parseFloat
(
sysInfo
.
getProperty
(
"
version
"
)
)
;
let
showTabsInTaskbar
=
document
.
getElementById
(
"
showTabsInTaskbar
"
)
;
showTabsInTaskbar
.
hidden
=
ver
<
6
.
1
;
}
catch
(
ex
)
{
}
}
if
(
!
TransientPrefs
.
prefShouldBeVisible
(
"
browser
.
tabs
.
warnOnClose
"
)
)
document
.
getElementById
(
"
warnCloseMultiple
"
)
.
hidden
=
true
;
if
(
!
TransientPrefs
.
prefShouldBeVisible
(
"
browser
.
tabs
.
warnOnOpen
"
)
)
document
.
getElementById
(
"
warnOpenMany
"
)
.
hidden
=
true
;
setEventListener
(
"
browser
.
privatebrowsing
.
autostart
"
"
change
"
gMainPane
.
updateBrowserStartupLastSession
)
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
setEventListener
(
"
setDefaultButton
"
"
command
"
gMainPane
.
setDefaultBrowser
)
;
}
setEventListener
(
"
useCurrent
"
"
command
"
gMainPane
.
setHomePageToCurrent
)
;
setEventListener
(
"
useBookmark
"
"
command
"
gMainPane
.
setHomePageToBookmark
)
;
setEventListener
(
"
restoreDefaultHomePage
"
"
command
"
gMainPane
.
restoreDefaultHomePage
)
;
setEventListener
(
"
chooseLanguage
"
"
command
"
gMainPane
.
showLanguages
)
;
setEventListener
(
"
translationAttributionImage
"
"
click
"
gMainPane
.
openTranslationProviderAttribution
)
;
setEventListener
(
"
translateButton
"
"
command
"
gMainPane
.
showTranslationExceptions
)
;
setEventListener
(
"
font
.
language
.
group
"
"
change
"
gMainPane
.
_rebuildFonts
)
;
setEventListener
(
"
advancedFonts
"
"
command
"
gMainPane
.
configureFonts
)
;
setEventListener
(
"
colors
"
"
command
"
gMainPane
.
configureColors
)
;
setEventListener
(
"
layers
.
acceleration
.
disabled
"
"
change
"
gMainPane
.
updateHardwareAcceleration
)
;
setEventListener
(
"
connectionSettings
"
"
command
"
gMainPane
.
showConnections
)
;
setEventListener
(
"
browserContainersCheckbox
"
"
command
"
gMainPane
.
checkBrowserContainers
)
;
setEventListener
(
"
browserContainersSettings
"
"
command
"
gMainPane
.
showContainerSettings
)
;
this
.
_rebuildFonts
(
)
;
this
.
updateOnScreenKeyboardVisibility
(
)
;
const
prefName
=
"
browser
.
translation
.
ui
.
show
"
;
if
(
Services
.
prefs
.
getBoolPref
(
prefName
)
)
{
let
row
=
document
.
getElementById
(
"
translationBox
"
)
;
row
.
removeAttribute
(
"
hidden
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
translation
/
Translation
.
jsm
"
)
;
if
(
Translation
.
translationEngine
=
=
"
bing
"
)
{
document
.
getElementById
(
"
bingAttribution
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
}
if
(
AppConstants
.
E10S_TESTING_ONLY
)
{
setEventListener
(
"
e10sAutoStart
"
"
command
"
gMainPane
.
enableE10SChange
)
;
let
e10sCheckbox
=
document
.
getElementById
(
"
e10sAutoStart
"
)
;
let
e10sPref
=
document
.
getElementById
(
"
browser
.
tabs
.
remote
.
autostart
"
)
;
let
e10sTempPref
=
document
.
getElementById
(
"
e10sTempPref
"
)
;
let
e10sForceEnable
=
document
.
getElementById
(
"
e10sForceEnable
"
)
;
let
preffedOn
=
e10sPref
.
value
|
|
e10sTempPref
.
value
|
|
e10sForceEnable
.
value
;
if
(
preffedOn
)
{
e10sCheckbox
.
checked
=
Services
.
appinfo
.
browserTabsRemoteAutostart
;
e10sCheckbox
.
disabled
=
!
Services
.
appinfo
.
browserTabsRemoteAutostart
;
}
}
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
let
uAppData
=
OS
.
Constants
.
Path
.
userApplicationDataDir
;
let
ignoreSeparateProfile
=
OS
.
Path
.
join
(
uAppData
"
ignore
-
dev
-
edition
-
profile
"
)
;
setEventListener
(
"
separateProfileMode
"
"
command
"
gMainPane
.
separateProfileModeChange
)
;
let
separateProfileModeCheckbox
=
document
.
getElementById
(
"
separateProfileMode
"
)
;
setEventListener
(
"
getStarted
"
"
click
"
gMainPane
.
onGetStarted
)
;
OS
.
File
.
stat
(
ignoreSeparateProfile
)
.
then
(
(
)
=
>
separateProfileModeCheckbox
.
checked
=
false
(
)
=
>
separateProfileModeCheckbox
.
checked
=
true
)
;
fxAccounts
.
getSignedInUser
(
)
.
then
(
data
=
>
{
document
.
getElementById
(
"
getStarted
"
)
.
selectedIndex
=
data
?
1
:
0
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
let
version
=
AppConstants
.
MOZ_APP_VERSION_DISPLAY
;
if
(
/
a
\
d
+
/
.
test
(
version
)
)
{
let
buildID
=
Services
.
appinfo
.
appBuildID
;
let
year
=
buildID
.
slice
(
0
4
)
;
let
month
=
buildID
.
slice
(
4
6
)
;
let
day
=
buildID
.
slice
(
6
8
)
;
version
+
=
(
{
year
}
-
{
month
}
-
{
day
}
)
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
archResource
=
Services
.
appinfo
.
is64Bit
?
"
aboutDialog
.
architecture
.
sixtyFourBit
"
:
"
aboutDialog
.
architecture
.
thirtyTwoBit
"
;
let
arch
=
bundle
.
GetStringFromName
(
archResource
)
;
version
+
=
(
{
arch
}
)
;
document
.
getElementById
(
"
version
"
)
.
textContent
=
version
;
let
relNotesLink
=
document
.
getElementById
(
"
releasenotes
"
)
;
let
relNotesPrefType
=
Services
.
prefs
.
getPrefType
(
"
app
.
releaseNotesURL
"
)
;
if
(
relNotesPrefType
!
=
Services
.
prefs
.
PREF_INVALID
)
{
let
relNotesURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
releaseNotesURL
"
)
;
if
(
relNotesURL
!
=
"
about
:
blank
"
)
{
relNotesLink
.
href
=
relNotesURL
;
relNotesLink
.
hidden
=
false
;
}
}
let
distroId
=
Services
.
prefs
.
getCharPref
(
"
distribution
.
id
"
"
"
)
;
if
(
distroId
)
{
let
distroVersion
=
Services
.
prefs
.
getCharPref
(
"
distribution
.
version
"
)
;
let
distroIdField
=
document
.
getElementById
(
"
distributionId
"
)
;
distroIdField
.
value
=
distroId
+
"
-
"
+
distroVersion
;
distroIdField
.
hidden
=
false
;
let
distroAbout
=
Services
.
prefs
.
getStringPref
(
"
distribution
.
about
"
"
"
)
;
if
(
distroAbout
)
{
let
distroField
=
document
.
getElementById
(
"
distribution
"
)
;
distroField
.
value
=
distroAbout
;
distroField
.
hidden
=
false
;
}
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
gAppUpdater
=
new
appUpdater
(
)
;
let
onUnload
=
(
)
=
>
{
window
.
removeEventListener
(
"
unload
"
onUnload
)
;
Services
.
prefs
.
removeObserver
(
"
app
.
update
.
"
this
)
;
}
;
window
.
addEventListener
(
"
unload
"
onUnload
)
;
Services
.
prefs
.
addObserver
(
"
app
.
update
.
"
this
)
;
this
.
updateReadPrefs
(
)
;
setEventListener
(
"
updateRadioGroup
"
"
command
"
gMainPane
.
updateWritePrefs
)
;
setEventListener
(
"
showUpdateHistory
"
"
command
"
gMainPane
.
showUpdates
)
;
}
this
.
_brandShortName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
this
.
_prefsBundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
this
.
_list
=
document
.
getElementById
(
"
handlersView
"
)
;
this
.
_filter
=
document
.
getElementById
(
"
filter
"
)
;
this
.
_prefSvc
.
addObserver
(
PREF_SHOW_PLUGINS_IN_LIST
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_FEED_SELECTED_APP
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_FEED_SELECTED_WEB
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_FEED_SELECTED_ACTION
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_FEED_SELECTED_READER
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_VIDEO_FEED_SELECTED_APP
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_VIDEO_FEED_SELECTED_WEB
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_VIDEO_FEED_SELECTED_ACTION
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_VIDEO_FEED_SELECTED_READER
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_AUDIO_FEED_SELECTED_APP
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_AUDIO_FEED_SELECTED_WEB
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_AUDIO_FEED_SELECTED_ACTION
this
)
;
this
.
_prefSvc
.
addObserver
(
PREF_AUDIO_FEED_SELECTED_READER
this
)
;
setEventListener
(
"
focusSearch1
"
"
command
"
gMainPane
.
focusFilterBox
)
;
setEventListener
(
"
focusSearch2
"
"
command
"
gMainPane
.
focusFilterBox
)
;
setEventListener
(
"
filter
"
"
command
"
gMainPane
.
filter
)
;
setEventListener
(
"
handlersView
"
"
select
"
gMainPane
.
onSelectionChanged
)
;
setEventListener
(
"
typeColumn
"
"
click
"
gMainPane
.
sort
)
;
setEventListener
(
"
actionColumn
"
"
click
"
gMainPane
.
sort
)
;
setEventListener
(
"
chooseFolder
"
"
command
"
gMainPane
.
chooseFolder
)
;
setEventListener
(
"
browser
.
download
.
dir
"
"
change
"
gMainPane
.
displayDownloadDirPref
)
;
window
.
addEventListener
(
"
unload
"
this
)
;
if
(
document
.
getElementById
(
"
actionColumn
"
)
.
hasAttribute
(
"
sortDirection
"
)
)
{
this
.
_sortColumn
=
document
.
getElementById
(
"
actionColumn
"
)
;
document
.
getElementById
(
"
typeColumn
"
)
.
removeAttribute
(
"
sortDirection
"
)
;
}
else
{
this
.
_sortColumn
=
document
.
getElementById
(
"
typeColumn
"
)
;
}
var
_delayedPaneLoad
=
function
(
self
)
{
self
.
_loadData
(
)
;
self
.
_rebuildVisibleTypes
(
)
;
self
.
_sortVisibleTypes
(
)
;
self
.
_rebuildView
(
)
;
}
setTimeout
(
_delayedPaneLoad
0
this
)
;
let
browserBundle
=
document
.
getElementById
(
"
browserBundle
"
)
;
appendSearchKeywords
(
"
browserContainersSettings
"
[
browserBundle
.
getString
(
"
userContextPersonal
.
label
"
)
browserBundle
.
getString
(
"
userContextWork
.
label
"
)
browserBundle
.
getString
(
"
userContextBanking
.
label
"
)
browserBundle
.
getString
(
"
userContextShopping
.
label
"
)
]
)
;
Components
.
classes
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIObserverService
)
.
notifyObservers
(
window
"
main
-
pane
-
loaded
"
)
;
}
initBrowserContainers
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
ui
.
enabled
"
)
)
{
document
.
getElementById
(
"
browserContainersbox
"
)
.
setAttribute
(
"
data
-
hidden
-
from
-
search
"
"
true
"
)
;
return
;
}
let
link
=
document
.
getElementById
(
"
browserContainersLearnMore
"
)
;
link
.
href
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
containers
"
;
document
.
getElementById
(
"
browserContainersbox
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
browserContainersCheckbox
"
)
.
checked
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
;
}
isE10SEnabled
(
)
{
let
e10sEnabled
;
try
{
let
e10sStatus
=
Components
.
classes
[
"
mozilla
.
org
/
supports
-
PRUint64
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRUint64
)
;
let
appinfo
=
Services
.
appinfo
.
QueryInterface
(
Ci
.
nsIObserver
)
;
appinfo
.
observe
(
e10sStatus
"
getE10SBlocked
"
"
"
)
;
e10sEnabled
=
e10sStatus
.
data
<
2
;
}
catch
(
e
)
{
e10sEnabled
=
false
;
}
return
e10sEnabled
;
}
enableE10SChange
(
)
{
if
(
AppConstants
.
E10S_TESTING_ONLY
)
{
let
e10sCheckbox
=
document
.
getElementById
(
"
e10sAutoStart
"
)
;
let
e10sPref
=
document
.
getElementById
(
"
browser
.
tabs
.
remote
.
autostart
"
)
;
let
e10sTempPref
=
document
.
getElementById
(
"
e10sTempPref
"
)
;
let
prefsToChange
;
if
(
e10sCheckbox
.
checked
)
{
prefsToChange
=
[
e10sPref
]
;
}
else
{
prefsToChange
=
[
e10sPref
]
;
if
(
e10sTempPref
.
value
)
{
prefsToChange
.
push
(
e10sTempPref
)
;
}
}
let
buttonIndex
=
confirmRestartPrompt
(
e10sCheckbox
.
checked
0
true
false
)
;
if
(
buttonIndex
=
=
CONFIRM_RESTART_PROMPT_RESTART_NOW
)
{
for
(
let
prefToChange
of
prefsToChange
)
{
prefToChange
.
value
=
e10sCheckbox
.
checked
;
}
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
}
e10sCheckbox
.
checked
=
e10sPref
.
value
|
|
e10sTempPref
.
value
;
}
}
separateProfileModeChange
(
)
{
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
function
quitApp
(
)
{
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestartNotSameProfile
)
;
}
function
revertCheckbox
(
error
)
{
separateProfileModeCheckbox
.
checked
=
!
separateProfileModeCheckbox
.
checked
;
if
(
error
)
{
Cu
.
reportError
(
"
Failed
to
toggle
separate
profile
mode
:
"
+
error
)
;
}
}
function
createOrRemoveSpecialDevEditionFile
(
onSuccess
)
{
let
uAppData
=
OS
.
Constants
.
Path
.
userApplicationDataDir
;
let
ignoreSeparateProfile
=
OS
.
Path
.
join
(
uAppData
"
ignore
-
dev
-
edition
-
profile
"
)
;
if
(
separateProfileModeCheckbox
.
checked
)
{
OS
.
File
.
remove
(
ignoreSeparateProfile
)
.
then
(
onSuccess
revertCheckbox
)
;
}
else
{
OS
.
File
.
writeAtomic
(
ignoreSeparateProfile
new
Uint8Array
(
)
)
.
then
(
onSuccess
revertCheckbox
)
;
}
}
let
separateProfileModeCheckbox
=
document
.
getElementById
(
"
separateProfileMode
"
)
;
let
button_index
=
confirmRestartPrompt
(
separateProfileModeCheckbox
.
checked
0
false
true
)
;
switch
(
button_index
)
{
case
CONFIRM_RESTART_PROMPT_CANCEL
:
revertCheckbox
(
)
;
return
;
case
CONFIRM_RESTART_PROMPT_RESTART_NOW
:
const
Cc
=
Components
.
classes
Ci
=
Components
.
interfaces
;
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
!
cancelQuit
.
data
)
{
createOrRemoveSpecialDevEditionFile
(
quitApp
)
;
return
;
}
revertCheckbox
(
)
;
return
;
case
CONFIRM_RESTART_PROMPT_RESTART_LATER
:
createOrRemoveSpecialDevEditionFile
(
)
;
}
}
}
onGetStarted
(
aEvent
)
{
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
const
Cc
=
Components
.
classes
Ci
=
Components
.
interfaces
;
let
wm
=
Cc
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
let
win
=
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
fxAccounts
.
getSignedInUser
(
)
.
then
(
data
=
>
{
if
(
win
)
{
if
(
data
)
{
win
.
openUILinkIn
(
"
about
:
preferences
#
sync
"
"
current
"
)
;
return
;
}
let
accountsTab
=
win
.
gBrowser
.
addTab
(
"
about
:
accounts
?
action
=
signin
&
entrypoint
=
dev
-
edition
-
setup
"
)
;
win
.
gBrowser
.
selectedTab
=
accountsTab
;
}
}
)
;
}
}
syncFromHomePref
(
)
{
let
homePref
=
document
.
getElementById
(
"
browser
.
startup
.
homepage
"
)
;
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
let
defaultValue
=
defaultBranch
.
getComplexValue
(
"
browser
.
startup
.
homepage
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
let
currentValue
=
homePref
.
value
.
toLowerCase
(
)
;
if
(
currentValue
=
=
"
about
:
home
"
|
|
(
currentValue
=
=
defaultValue
&
&
currentValue
=
=
"
about
:
newtab
"
)
)
{
return
"
"
;
}
if
(
homePref
.
value
=
=
"
"
)
return
"
about
:
blank
"
;
return
undefined
;
}
syncToHomePref
(
value
)
{
if
(
value
=
=
"
"
)
return
"
about
:
home
"
;
return
undefined
;
}
setHomePageToCurrent
(
)
{
let
homePage
=
document
.
getElementById
(
"
browser
.
startup
.
homepage
"
)
;
let
tabs
=
this
.
_getTabsForHomePage
(
)
;
function
getTabURI
(
t
)
{
return
t
.
linkedBrowser
.
currentURI
.
spec
;
}
if
(
tabs
.
length
)
homePage
.
value
=
tabs
.
map
(
getTabURI
)
.
join
(
"
|
"
)
;
}
setHomePageToBookmark
(
)
{
var
rv
=
{
urls
:
null
names
:
null
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
selectBookmark
.
xul
"
"
resizable
=
yes
modal
=
yes
"
rv
this
.
_setHomePageToBookmarkClosed
.
bind
(
this
rv
)
)
;
}
_setHomePageToBookmarkClosed
(
rv
aEvent
)
{
if
(
aEvent
.
detail
.
button
!
=
"
accept
"
)
return
;
if
(
rv
.
urls
&
&
rv
.
names
)
{
var
homePage
=
document
.
getElementById
(
"
browser
.
startup
.
homepage
"
)
;
homePage
.
value
=
rv
.
urls
.
join
(
"
|
"
)
;
}
}
_updateUseCurrentButton
(
)
{
let
useCurrent
=
document
.
getElementById
(
"
useCurrent
"
)
;
let
tabs
=
this
.
_getTabsForHomePage
(
)
;
if
(
tabs
.
length
>
1
)
useCurrent
.
label
=
useCurrent
.
getAttribute
(
"
label2
"
)
;
else
useCurrent
.
label
=
useCurrent
.
getAttribute
(
"
label1
"
)
;
let
prefName
=
"
pref
.
browser
.
homepage
.
disable_button
.
current_page
"
;
if
(
document
.
getElementById
(
prefName
)
.
locked
)
return
;
useCurrent
.
disabled
=
!
tabs
.
length
}
_getTabsForHomePage
(
)
{
var
win
;
var
tabs
=
[
]
;
const
Cc
=
Components
.
classes
Ci
=
Components
.
interfaces
;
var
wm
=
Cc
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
win
=
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
win
&
&
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
{
tabs
=
win
.
gBrowser
.
visibleTabs
.
slice
(
win
.
gBrowser
.
_numPinnedTabs
)
;
tabs
=
tabs
.
filter
(
this
.
isNotAboutPreferences
)
;
}
return
tabs
;
}
isNotAboutPreferences
(
aElement
aIndex
aArray
)
{
return
!
aElement
.
linkedBrowser
.
currentURI
.
spec
.
startsWith
(
"
about
:
preferences
"
)
;
}
restoreDefaultHomePage
(
)
{
var
homePage
=
document
.
getElementById
(
"
browser
.
startup
.
homepage
"
)
;
homePage
.
value
=
homePage
.
defaultValue
;
}
updateButtons
(
aButtonID
aPreferenceID
)
{
var
button
=
document
.
getElementById
(
aButtonID
)
;
var
preference
=
document
.
getElementById
(
aPreferenceID
)
;
button
.
disabled
=
preference
.
value
!
=
true
;
return
undefined
;
}
updateBrowserStartupLastSession
(
)
{
let
pbAutoStartPref
=
document
.
getElementById
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
let
startupPref
=
document
.
getElementById
(
"
browser
.
startup
.
page
"
)
;
let
menu
=
document
.
getElementById
(
"
browserStartupPage
"
)
;
let
option
=
document
.
getElementById
(
"
browserStartupLastSession
"
)
;
if
(
pbAutoStartPref
.
value
)
{
option
.
setAttribute
(
"
disabled
"
"
true
"
)
;
if
(
option
.
selected
)
{
menu
.
selectedItem
=
document
.
getElementById
(
"
browserStartupHomePage
"
)
;
}
}
else
{
option
.
removeAttribute
(
"
disabled
"
)
;
startupPref
.
updateElements
(
)
;
}
}
readLinkTarget
(
)
{
var
openNewWindow
=
document
.
getElementById
(
"
browser
.
link
.
open_newwindow
"
)
;
return
openNewWindow
.
value
!
=
2
;
}
writeLinkTarget
(
)
{
var
linkTargeting
=
document
.
getElementById
(
"
linkTargeting
"
)
;
return
linkTargeting
.
checked
?
3
:
2
;
}
updateSetDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
shellSvc
=
getShellService
(
)
;
let
defaultBrowserBox
=
document
.
getElementById
(
"
defaultBrowserBox
"
)
;
if
(
!
shellSvc
)
{
defaultBrowserBox
.
hidden
=
true
;
return
;
}
let
setDefaultPane
=
document
.
getElementById
(
"
setDefaultPane
"
)
;
let
isDefault
=
shellSvc
.
isDefaultBrowser
(
false
true
)
;
setDefaultPane
.
selectedIndex
=
isDefault
?
1
:
0
;
let
alwaysCheck
=
document
.
getElementById
(
"
alwaysCheckDefault
"
)
;
alwaysCheck
.
disabled
=
alwaysCheck
.
disabled
|
|
isDefault
&
&
alwaysCheck
.
checked
;
}
}
setDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
alwaysCheckPref
=
document
.
getElementById
(
"
browser
.
shell
.
checkDefaultBrowser
"
)
;
alwaysCheckPref
.
value
=
true
;
let
shellSvc
=
getShellService
(
)
;
if
(
!
shellSvc
)
return
;
try
{
shellSvc
.
setDefaultBrowser
(
true
false
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
return
;
}
let
selectedIndex
=
shellSvc
.
isDefaultBrowser
(
false
true
)
?
1
:
0
;
document
.
getElementById
(
"
setDefaultPane
"
)
.
selectedIndex
=
selectedIndex
;
}
}
showLanguages
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
languages
.
xul
"
)
;
}
showTranslationExceptions
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
translation
.
xul
"
)
;
}
openTranslationProviderAttribution
(
)
{
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
translation
/
Translation
.
jsm
"
)
;
Translation
.
openProviderAttribution
(
)
;
}
configureFonts
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
fonts
.
xul
"
"
resizable
=
no
"
)
;
}
configureColors
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
colors
.
xul
"
"
resizable
=
no
"
)
;
}
showConnections
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
connection
.
xul
"
)
;
}
checkBrowserContainers
(
event
)
{
let
checkbox
=
document
.
getElementById
(
"
browserContainersCheckbox
"
)
;
if
(
checkbox
.
checked
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
true
)
;
return
;
}
let
count
=
ContextualIdentityService
.
countContainerTabs
(
)
;
if
(
count
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
title
=
bundlePreferences
.
getString
(
"
disableContainersAlertTitle
"
)
;
let
message
=
PluralForm
.
get
(
count
bundlePreferences
.
getString
(
"
disableContainersMsg
"
)
)
.
replace
(
"
#
S
"
count
)
let
okButton
=
PluralForm
.
get
(
count
bundlePreferences
.
getString
(
"
disableContainersOkButton
"
)
)
.
replace
(
"
#
S
"
count
)
let
cancelButton
=
bundlePreferences
.
getString
(
"
disableContainersButton2
"
)
;
let
buttonFlags
=
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
)
+
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
)
;
let
rv
=
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
if
(
rv
=
=
0
)
{
ContextualIdentityService
.
closeContainerTabs
(
)
;
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
checkbox
.
checked
=
true
;
}
showContainerSettings
(
)
{
gotoPref
(
"
containers
"
)
;
}
updateOnScreenKeyboardVisibility
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
minVersion
=
Services
.
prefs
.
getBoolPref
(
"
ui
.
osk
.
require_win10
"
)
?
10
:
6
.
2
;
if
(
Services
.
vc
.
compare
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
minVersion
)
>
=
0
)
{
document
.
getElementById
(
"
useOnScreenKeyboard
"
)
.
hidden
=
false
;
}
}
}
updateHardwareAcceleration
(
)
{
}
_rebuildFonts
(
)
{
var
preferences
=
document
.
getElementById
(
"
mainPreferences
"
)
;
preferences
.
hidden
=
false
;
preferences
.
clientHeight
;
var
langGroupPref
=
document
.
getElementById
(
"
font
.
language
.
group
"
)
;
this
.
_selectDefaultLanguageGroup
(
langGroupPref
.
value
this
.
_readDefaultFontTypeForLanguage
(
langGroupPref
.
value
)
=
=
"
serif
"
)
;
}
_readDefaultFontTypeForLanguage
(
aLanguageGroup
)
{
const
kDefaultFontType
=
"
font
.
default
.
%
LANG
%
"
;
var
defaultFontTypePref
=
kDefaultFontType
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
;
var
preference
=
document
.
getElementById
(
defaultFontTypePref
)
;
if
(
!
preference
)
{
preference
=
document
.
createElement
(
"
preference
"
)
;
preference
.
id
=
defaultFontTypePref
;
preference
.
setAttribute
(
"
name
"
defaultFontTypePref
)
;
preference
.
setAttribute
(
"
type
"
"
string
"
)
;
preference
.
setAttribute
(
"
onchange
"
"
gMainPane
.
_rebuildFonts
(
)
;
"
)
;
document
.
getElementById
(
"
mainPreferences
"
)
.
appendChild
(
preference
)
;
}
return
preference
.
value
;
}
_selectDefaultLanguageGroup
(
aLanguageGroup
aIsSerif
)
{
const
kFontNameFmtSerif
=
"
font
.
name
.
serif
.
%
LANG
%
"
;
const
kFontNameFmtSansSerif
=
"
font
.
name
.
sans
-
serif
.
%
LANG
%
"
;
const
kFontNameListFmtSerif
=
"
font
.
name
-
list
.
serif
.
%
LANG
%
"
;
const
kFontNameListFmtSansSerif
=
"
font
.
name
-
list
.
sans
-
serif
.
%
LANG
%
"
;
const
kFontSizeFmtVariable
=
"
font
.
size
.
variable
.
%
LANG
%
"
;
var
preferences
=
document
.
getElementById
(
"
mainPreferences
"
)
;
var
prefs
=
[
{
format
:
aIsSerif
?
kFontNameFmtSerif
:
kFontNameFmtSansSerif
type
:
"
fontname
"
element
:
"
defaultFont
"
fonttype
:
aIsSerif
?
"
serif
"
:
"
sans
-
serif
"
}
{
format
:
aIsSerif
?
kFontNameListFmtSerif
:
kFontNameListFmtSansSerif
type
:
"
unichar
"
element
:
null
fonttype
:
aIsSerif
?
"
serif
"
:
"
sans
-
serif
"
}
{
format
:
kFontSizeFmtVariable
type
:
"
int
"
element
:
"
defaultFontSize
"
fonttype
:
null
}
]
;
for
(
var
i
=
0
;
i
<
prefs
.
length
;
+
+
i
)
{
var
preference
=
document
.
getElementById
(
prefs
[
i
]
.
format
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
)
;
if
(
!
preference
)
{
preference
=
document
.
createElement
(
"
preference
"
)
;
var
name
=
prefs
[
i
]
.
format
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
;
preference
.
id
=
name
;
preference
.
setAttribute
(
"
name
"
name
)
;
preference
.
setAttribute
(
"
type
"
prefs
[
i
]
.
type
)
;
preferences
.
appendChild
(
preference
)
;
}
if
(
!
prefs
[
i
]
.
element
)
continue
;
var
element
=
document
.
getElementById
(
prefs
[
i
]
.
element
)
;
if
(
element
)
{
element
.
setAttribute
(
"
preference
"
preference
.
id
)
;
if
(
prefs
[
i
]
.
fonttype
)
FontBuilder
.
buildFontList
(
aLanguageGroup
prefs
[
i
]
.
fonttype
element
)
;
preference
.
setElementValue
(
element
)
;
}
}
}
_storedSpellCheck
:
0
readCheckSpelling
(
)
{
var
pref
=
document
.
getElementById
(
"
layout
.
spellcheckDefault
"
)
;
this
.
_storedSpellCheck
=
pref
.
value
;
return
(
pref
.
value
!
=
0
)
;
}
writeCheckSpelling
(
)
{
var
checkbox
=
document
.
getElementById
(
"
checkSpelling
"
)
;
if
(
checkbox
.
checked
)
{
if
(
this
.
_storedSpellCheck
=
=
2
)
{
return
2
;
}
return
1
;
}
return
0
;
}
updateDefaultPerformanceSettingsPref
(
)
{
let
defaultPerformancePref
=
document
.
getElementById
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
let
processCountPref
=
document
.
getElementById
(
"
dom
.
ipc
.
processCount
"
)
;
let
accelerationPref
=
document
.
getElementById
(
"
layers
.
acceleration
.
disabled
"
)
;
if
(
processCountPref
.
value
!
=
processCountPref
.
defaultValue
|
|
accelerationPref
.
value
!
=
accelerationPref
.
defaultValue
)
{
defaultPerformancePref
.
value
=
false
;
}
}
updatePerformanceSettingsBox
(
{
duringChangeEvent
}
)
{
let
defaultPerformancePref
=
document
.
getElementById
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
let
performanceSettings
=
document
.
getElementById
(
"
performanceSettings
"
)
;
let
processCountPref
=
document
.
getElementById
(
"
dom
.
ipc
.
processCount
"
)
;
if
(
defaultPerformancePref
.
value
)
{
let
accelerationPref
=
document
.
getElementById
(
"
layers
.
acceleration
.
disabled
"
)
;
processCountPref
.
value
=
processCountPref
.
defaultValue
;
accelerationPref
.
value
=
accelerationPref
.
defaultValue
;
performanceSettings
.
hidden
=
true
;
}
else
{
let
e10sRolloutProcessCountPref
=
document
.
getElementById
(
"
dom
.
ipc
.
processCount
.
web
"
)
;
if
(
duringChangeEvent
&
&
e10sRolloutProcessCountPref
.
value
&
&
processCountPref
.
value
=
=
processCountPref
.
defaultValue
)
{
processCountPref
.
value
=
e10sRolloutProcessCountPref
.
value
;
}
performanceSettings
.
hidden
=
false
;
}
}
buildContentProcessCountMenuList
(
)
{
if
(
gMainPane
.
isE10SEnabled
(
)
)
{
let
processCountPref
=
document
.
getElementById
(
"
dom
.
ipc
.
processCount
"
)
;
let
e10sRolloutProcessCountPref
=
document
.
getElementById
(
"
dom
.
ipc
.
processCount
.
web
"
)
;
let
defaultProcessCount
=
e10sRolloutProcessCountPref
.
value
|
|
processCountPref
.
defaultValue
;
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
label
=
bundlePreferences
.
getFormattedString
(
"
defaultContentProcessCount
"
[
defaultProcessCount
]
)
;
let
contentProcessCount
=
document
.
querySelector
(
#
contentProcessCount
>
menupopup
>
menuitem
[
value
=
"
{
defaultProcessCount
}
"
]
)
;
contentProcessCount
.
label
=
label
;
document
.
getElementById
(
"
limitContentProcess
"
)
.
disabled
=
false
;
document
.
getElementById
(
"
contentProcessCount
"
)
.
disabled
=
false
;
document
.
getElementById
(
"
contentProcessCountEnabledDescription
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
contentProcessCountDisabledDescription
"
)
.
hidden
=
true
;
}
else
{
document
.
getElementById
(
"
limitContentProcess
"
)
.
disabled
=
true
;
document
.
getElementById
(
"
contentProcessCount
"
)
.
disabled
=
true
;
document
.
getElementById
(
"
contentProcessCountEnabledDescription
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
contentProcessCountDisabledDescription
"
)
.
hidden
=
false
;
}
}
updateReadPrefs
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
)
{
var
enabledPref
=
document
.
getElementById
(
"
app
.
update
.
enabled
"
)
;
var
autoPref
=
document
.
getElementById
(
"
app
.
update
.
auto
"
)
;
var
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
if
(
!
enabledPref
.
value
)
radiogroup
.
value
=
"
manual
"
;
else
if
(
autoPref
.
value
)
radiogroup
.
value
=
"
auto
"
;
else
radiogroup
.
value
=
"
checkOnly
"
;
var
canCheck
=
Components
.
classes
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIApplicationUpdateService
)
.
canCheckForUpdates
;
radiogroup
.
disabled
=
!
canCheck
|
|
enabledPref
.
locked
|
|
autoPref
.
locked
;
if
(
AppConstants
.
MOZ_MAINTENANCE_SERVICE
)
{
var
installed
;
try
{
var
wrk
=
Components
.
classes
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIWindowsRegKey
)
;
wrk
.
open
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
"
SOFTWARE
\
\
Mozilla
\
\
MaintenanceService
"
wrk
.
ACCESS_READ
|
wrk
.
WOW64_64
)
;
installed
=
wrk
.
readIntValue
(
"
Installed
"
)
;
wrk
.
close
(
)
;
}
catch
(
e
)
{
}
if
(
installed
!
=
1
)
{
document
.
getElementById
(
"
useService
"
)
.
hidden
=
true
;
}
}
}
}
updateWritePrefs
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
)
{
var
enabledPref
=
document
.
getElementById
(
"
app
.
update
.
enabled
"
)
;
var
autoPref
=
document
.
getElementById
(
"
app
.
update
.
auto
"
)
;
var
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
switch
(
radiogroup
.
value
)
{
case
"
auto
"
:
enabledPref
.
value
=
true
;
autoPref
.
value
=
true
;
break
;
case
"
checkOnly
"
:
enabledPref
.
value
=
true
;
autoPref
.
value
=
false
;
break
;
case
"
manual
"
:
enabledPref
.
value
=
false
;
autoPref
.
value
=
false
;
}
}
}
showUpdates
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
update
/
history
.
xul
"
)
;
}
destroy
(
)
{
window
.
removeEventListener
(
"
unload
"
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_SHOW_PLUGINS_IN_LIST
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_FEED_SELECTED_APP
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_FEED_SELECTED_WEB
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_FEED_SELECTED_ACTION
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_FEED_SELECTED_READER
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_VIDEO_FEED_SELECTED_APP
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_VIDEO_FEED_SELECTED_WEB
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_VIDEO_FEED_SELECTED_ACTION
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_VIDEO_FEED_SELECTED_READER
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_AUDIO_FEED_SELECTED_APP
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_AUDIO_FEED_SELECTED_WEB
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_AUDIO_FEED_SELECTED_ACTION
this
)
;
this
.
_prefSvc
.
removeObserver
(
PREF_AUDIO_FEED_SELECTED_READER
this
)
;
}
QueryInterface
(
aIID
)
{
if
(
aIID
.
equals
(
Ci
.
nsIObserver
)
|
|
aIID
.
equals
(
Ci
.
nsIDOMEventListener
|
|
aIID
.
equals
(
Ci
.
nsISupports
)
)
)
return
this
;
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
if
(
!
this
.
_storingAction
)
{
if
(
aData
=
=
PREF_SHOW_PLUGINS_IN_LIST
|
|
aData
=
=
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
)
{
this
.
_rebuildVisibleTypes
(
)
;
this
.
_sortVisibleTypes
(
)
;
}
this
.
_rebuildView
(
)
;
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
this
.
updateReadPrefs
(
)
;
}
}
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
=
=
"
unload
"
)
{
this
.
destroy
(
)
;
}
}
_loadData
(
)
{
this
.
_loadFeedHandler
(
)
;
this
.
_loadInternalHandlers
(
)
;
this
.
_loadPluginHandlers
(
)
;
this
.
_loadApplicationHandlers
(
)
;
}
_loadFeedHandler
(
)
{
this
.
_handledTypes
[
TYPE_MAYBE_FEED
]
=
feedHandlerInfo
;
feedHandlerInfo
.
handledOnlyByPlugin
=
false
;
this
.
_handledTypes
[
TYPE_MAYBE_VIDEO_FEED
]
=
videoFeedHandlerInfo
;
videoFeedHandlerInfo
.
handledOnlyByPlugin
=
false
;
this
.
_handledTypes
[
TYPE_MAYBE_AUDIO_FEED
]
=
audioFeedHandlerInfo
;
audioFeedHandlerInfo
.
handledOnlyByPlugin
=
false
;
}
_loadInternalHandlers
(
)
{
var
internalHandlers
=
[
pdfHandlerInfo
]
;
for
(
let
internalHandler
of
internalHandlers
)
{
if
(
internalHandler
.
enabled
)
{
this
.
_handledTypes
[
internalHandler
.
type
]
=
internalHandler
;
}
}
}
_loadPluginHandlers
(
)
{
"
use
strict
"
;
let
mimeTypes
=
navigator
.
mimeTypes
;
for
(
let
mimeType
of
mimeTypes
)
{
let
handlerInfoWrapper
;
if
(
mimeType
.
type
in
this
.
_handledTypes
)
{
handlerInfoWrapper
=
this
.
_handledTypes
[
mimeType
.
type
]
;
}
else
{
let
wrappedHandlerInfo
=
this
.
_mimeSvc
.
getFromTypeAndExtension
(
mimeType
.
type
null
)
;
handlerInfoWrapper
=
new
HandlerInfoWrapper
(
mimeType
.
type
wrappedHandlerInfo
)
;
handlerInfoWrapper
.
handledOnlyByPlugin
=
true
;
this
.
_handledTypes
[
mimeType
.
type
]
=
handlerInfoWrapper
;
}
handlerInfoWrapper
.
pluginName
=
mimeType
.
enabledPlugin
.
name
;
}
}
_loadApplicationHandlers
(
)
{
var
wrappedHandlerInfos
=
this
.
_handlerSvc
.
enumerate
(
)
;
while
(
wrappedHandlerInfos
.
hasMoreElements
(
)
)
{
let
wrappedHandlerInfo
=
wrappedHandlerInfos
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIHandlerInfo
)
;
let
type
=
wrappedHandlerInfo
.
type
;
let
handlerInfoWrapper
;
if
(
type
in
this
.
_handledTypes
)
handlerInfoWrapper
=
this
.
_handledTypes
[
type
]
;
else
{
handlerInfoWrapper
=
new
HandlerInfoWrapper
(
type
wrappedHandlerInfo
)
;
this
.
_handledTypes
[
type
]
=
handlerInfoWrapper
;
}
handlerInfoWrapper
.
handledOnlyByPlugin
=
false
;
}
}
_rebuildVisibleTypes
(
)
{
this
.
_visibleTypes
=
[
]
;
this
.
_visibleTypeDescriptionCount
=
{
}
;
var
showPlugins
=
this
.
_prefSvc
.
getBoolPref
(
PREF_SHOW_PLUGINS_IN_LIST
)
;
var
hidePluginsWithoutExtensions
=
this
.
_prefSvc
.
getBoolPref
(
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
)
;
for
(
let
type
in
this
.
_handledTypes
)
{
let
handlerInfo
=
this
.
_handledTypes
[
type
]
;
if
(
hidePluginsWithoutExtensions
&
&
handlerInfo
.
handledOnlyByPlugin
&
&
handlerInfo
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
!
handlerInfo
.
primaryExtension
)
continue
;
if
(
handlerInfo
.
handledOnlyByPlugin
&
&
!
showPlugins
)
continue
;
this
.
_visibleTypes
.
push
(
handlerInfo
)
;
if
(
handlerInfo
.
description
in
this
.
_visibleTypeDescriptionCount
)
this
.
_visibleTypeDescriptionCount
[
handlerInfo
.
description
]
+
+
;
else
this
.
_visibleTypeDescriptionCount
[
handlerInfo
.
description
]
=
1
;
}
}
_rebuildView
(
)
{
while
(
this
.
_list
.
childNodes
.
length
>
1
)
this
.
_list
.
removeChild
(
this
.
_list
.
lastChild
)
;
var
visibleTypes
=
this
.
_visibleTypes
;
if
(
this
.
_filter
.
value
)
visibleTypes
=
visibleTypes
.
filter
(
this
.
_matchesFilter
this
)
;
for
(
let
visibleType
of
visibleTypes
)
{
let
item
=
document
.
createElement
(
"
richlistitem
"
)
;
item
.
setAttribute
(
"
type
"
visibleType
.
type
)
;
item
.
setAttribute
(
"
typeDescription
"
this
.
_describeType
(
visibleType
)
)
;
if
(
visibleType
.
smallIcon
)
item
.
setAttribute
(
"
typeIcon
"
visibleType
.
smallIcon
)
;
item
.
setAttribute
(
"
actionDescription
"
this
.
_describePreferredAction
(
visibleType
)
)
;
if
(
!
this
.
_setIconClassForPreferredAction
(
visibleType
item
)
)
{
item
.
setAttribute
(
"
actionIcon
"
this
.
_getIconURLForPreferredAction
(
visibleType
)
)
;
}
this
.
_list
.
appendChild
(
item
)
;
}
this
.
_selectLastSelectedType
(
)
;
}
_matchesFilter
(
aType
)
{
var
filterValue
=
this
.
_filter
.
value
.
toLowerCase
(
)
;
return
this
.
_describeType
(
aType
)
.
toLowerCase
(
)
.
indexOf
(
filterValue
)
!
=
-
1
|
|
this
.
_describePreferredAction
(
aType
)
.
toLowerCase
(
)
.
indexOf
(
filterValue
)
!
=
-
1
;
}
_describeType
(
aHandlerInfo
)
{
if
(
this
.
_visibleTypeDescriptionCount
[
aHandlerInfo
.
description
]
>
1
)
return
this
.
_prefsBundle
.
getFormattedString
(
"
typeDescriptionWithType
"
[
aHandlerInfo
.
description
aHandlerInfo
.
type
]
)
;
return
aHandlerInfo
.
description
;
}
_describePreferredAction
(
aHandlerInfo
)
{
if
(
aHandlerInfo
.
alwaysAskBeforeHandling
)
{
if
(
isFeedType
(
aHandlerInfo
.
type
)
)
return
this
.
_prefsBundle
.
getFormattedString
(
"
previewInApp
"
[
this
.
_brandShortName
]
)
;
return
this
.
_prefsBundle
.
getString
(
"
alwaysAsk
"
)
;
}
switch
(
aHandlerInfo
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
return
this
.
_prefsBundle
.
getString
(
"
saveFile
"
)
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
var
preferredApp
=
aHandlerInfo
.
preferredApplicationHandler
;
var
name
;
if
(
preferredApp
instanceof
Ci
.
nsILocalHandlerApp
)
name
=
getFileDisplayName
(
preferredApp
.
executable
)
;
else
name
=
preferredApp
.
name
;
return
this
.
_prefsBundle
.
getFormattedString
(
"
useApp
"
[
name
]
)
;
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
isFeedType
(
aHandlerInfo
.
type
)
)
{
return
this
.
_prefsBundle
.
getFormattedString
(
"
addLiveBookmarksInApp
"
[
this
.
_brandShortName
]
)
;
}
if
(
aHandlerInfo
instanceof
InternalHandlerInfoWrapper
)
{
return
this
.
_prefsBundle
.
getFormattedString
(
"
previewInApp
"
[
this
.
_brandShortName
]
)
;
}
if
(
this
.
isValidHandlerApp
(
aHandlerInfo
.
preferredApplicationHandler
)
)
return
aHandlerInfo
.
preferredApplicationHandler
.
name
;
return
aHandlerInfo
.
defaultDescription
;
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
return
this
.
_prefsBundle
.
getFormattedString
(
"
useDefault
"
[
aHandlerInfo
.
defaultDescription
]
)
;
case
kActionUsePlugin
:
return
this
.
_prefsBundle
.
getFormattedString
(
"
usePluginIn
"
[
aHandlerInfo
.
pluginName
this
.
_brandShortName
]
)
;
default
:
throw
new
Error
(
Unexpected
preferredAction
:
{
aHandlerInfo
.
preferredAction
}
)
;
}
}
_selectLastSelectedType
(
)
{
if
(
this
.
_list
.
disabled
)
return
;
var
lastSelectedType
=
this
.
_list
.
getAttribute
(
"
lastSelectedType
"
)
;
if
(
!
lastSelectedType
)
return
;
var
item
=
this
.
_list
.
getElementsByAttribute
(
"
type
"
lastSelectedType
)
[
0
]
;
if
(
!
item
)
return
;
this
.
_list
.
selectedItem
=
item
;
}
isValidHandlerApp
(
aHandlerApp
)
{
if
(
!
aHandlerApp
)
return
false
;
if
(
aHandlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
return
this
.
_isValidHandlerExecutable
(
aHandlerApp
.
executable
)
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
return
aHandlerApp
.
uriTemplate
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebContentHandlerInfo
)
return
aHandlerApp
.
uri
;
return
false
;
}
_isValidHandlerExecutable
(
aExecutable
)
{
let
leafName
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
leafName
=
{
AppConstants
.
MOZ_APP_NAME
}
.
exe
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
leafName
=
AppConstants
.
MOZ_MACBUNDLE_NAME
;
}
else
{
leafName
=
{
AppConstants
.
MOZ_APP_NAME
}
-
bin
;
}
return
aExecutable
&
&
aExecutable
.
exists
(
)
&
&
aExecutable
.
isExecutable
(
)
&
&
aExecutable
.
leafName
!
=
leafName
;
}
rebuildActionsMenu
(
)
{
var
typeItem
=
this
.
_list
.
selectedItem
;
var
handlerInfo
=
this
.
_handledTypes
[
typeItem
.
type
]
;
var
menu
=
document
.
getAnonymousElementByAttribute
(
typeItem
"
class
"
"
actionsMenu
"
)
;
var
menuPopup
=
menu
.
menupopup
;
while
(
menuPopup
.
hasChildNodes
(
)
)
menuPopup
.
removeChild
(
menuPopup
.
lastChild
)
;
let
internalMenuItem
;
if
(
handlerInfo
instanceof
InternalHandlerInfoWrapper
)
{
internalMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
internalMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
handleInternally
)
;
let
label
=
this
.
_prefsBundle
.
getFormattedString
(
"
previewInApp
"
[
this
.
_brandShortName
]
)
;
internalMenuItem
.
setAttribute
(
"
label
"
label
)
;
internalMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
internalMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
ask
"
)
;
menuPopup
.
appendChild
(
internalMenuItem
)
;
}
{
var
askMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
askMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
alwaysAsk
)
;
let
label
;
if
(
isFeedType
(
handlerInfo
.
type
)
)
label
=
this
.
_prefsBundle
.
getFormattedString
(
"
previewInApp
"
[
this
.
_brandShortName
]
)
;
else
label
=
this
.
_prefsBundle
.
getString
(
"
alwaysAsk
"
)
;
askMenuItem
.
setAttribute
(
"
label
"
label
)
;
askMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
askMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
ask
"
)
;
menuPopup
.
appendChild
(
askMenuItem
)
;
}
if
(
(
handlerInfo
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
&
&
!
isFeedType
(
handlerInfo
.
type
)
)
{
var
saveMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
saveMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
saveToDisk
)
;
let
label
=
this
.
_prefsBundle
.
getString
(
"
saveFile
"
)
;
saveMenuItem
.
setAttribute
(
"
label
"
label
)
;
saveMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
saveMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
save
"
)
;
menuPopup
.
appendChild
(
saveMenuItem
)
;
}
if
(
isFeedType
(
handlerInfo
.
type
)
)
{
internalMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
internalMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
handleInternally
)
;
let
label
=
this
.
_prefsBundle
.
getFormattedString
(
"
addLiveBookmarksInApp
"
[
this
.
_brandShortName
]
)
;
internalMenuItem
.
setAttribute
(
"
label
"
label
)
;
internalMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
internalMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
feed
"
)
;
menuPopup
.
appendChild
(
internalMenuItem
)
;
}
let
menuseparator
=
document
.
createElement
(
"
menuseparator
"
)
;
menuPopup
.
appendChild
(
menuseparator
)
;
if
(
handlerInfo
.
hasDefaultHandler
)
{
var
defaultMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
defaultMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useSystemDefault
)
;
let
label
=
this
.
_prefsBundle
.
getFormattedString
(
"
useDefault
"
[
handlerInfo
.
defaultDescription
]
)
;
defaultMenuItem
.
setAttribute
(
"
label
"
label
)
;
defaultMenuItem
.
setAttribute
(
"
tooltiptext
"
handlerInfo
.
defaultDescription
)
;
defaultMenuItem
.
setAttribute
(
"
image
"
this
.
_getIconURLForSystemDefault
(
handlerInfo
)
)
;
menuPopup
.
appendChild
(
defaultMenuItem
)
;
}
let
preferredApp
=
handlerInfo
.
preferredApplicationHandler
;
let
possibleApps
=
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
)
;
var
possibleAppMenuItems
=
[
]
;
while
(
possibleApps
.
hasMoreElements
(
)
)
{
let
possibleApp
=
possibleApps
.
getNext
(
)
;
if
(
!
this
.
isValidHandlerApp
(
possibleApp
)
)
continue
;
let
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
let
label
;
if
(
possibleApp
instanceof
Ci
.
nsILocalHandlerApp
)
label
=
getFileDisplayName
(
possibleApp
.
executable
)
;
else
label
=
possibleApp
.
name
;
label
=
this
.
_prefsBundle
.
getFormattedString
(
"
useApp
"
[
label
]
)
;
menuItem
.
setAttribute
(
"
label
"
label
)
;
menuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
menuItem
.
setAttribute
(
"
image
"
this
.
_getIconURLForHandlerApp
(
possibleApp
)
)
;
menuItem
.
handlerApp
=
possibleApp
;
menuPopup
.
appendChild
(
menuItem
)
;
possibleAppMenuItems
.
push
(
menuItem
)
;
}
if
(
handlerInfo
.
pluginName
)
{
var
pluginMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
pluginMenuItem
.
setAttribute
(
"
action
"
kActionUsePlugin
)
;
let
label
=
this
.
_prefsBundle
.
getFormattedString
(
"
usePluginIn
"
[
handlerInfo
.
pluginName
this
.
_brandShortName
]
)
;
pluginMenuItem
.
setAttribute
(
"
label
"
label
)
;
pluginMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
pluginMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
plugin
"
)
;
menuPopup
.
appendChild
(
pluginMenuItem
)
;
}
let
canOpenWithOtherApp
=
true
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
executableType
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
.
getTypeFromExtension
(
"
exe
"
)
;
canOpenWithOtherApp
=
handlerInfo
.
type
!
=
executableType
;
}
if
(
canOpenWithOtherApp
)
{
let
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
menuItem
.
className
=
"
choose
-
app
-
item
"
;
menuItem
.
addEventListener
(
"
command
"
function
(
e
)
{
gMainPane
.
chooseApp
(
e
)
;
}
)
;
let
label
=
this
.
_prefsBundle
.
getString
(
"
useOtherApp
"
)
;
menuItem
.
setAttribute
(
"
label
"
label
)
;
menuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
menuPopup
.
appendChild
(
menuItem
)
;
}
if
(
possibleAppMenuItems
.
length
)
{
let
menuItem
=
document
.
createElement
(
"
menuseparator
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
menuItem
.
className
=
"
manage
-
app
-
item
"
;
menuItem
.
addEventListener
(
"
command
"
function
(
e
)
{
gMainPane
.
manageApp
(
e
)
;
}
)
;
menuItem
.
setAttribute
(
"
label
"
this
.
_prefsBundle
.
getString
(
"
manageApp
"
)
)
;
menuPopup
.
appendChild
(
menuItem
)
;
}
if
(
handlerInfo
.
alwaysAskBeforeHandling
)
menu
.
selectedItem
=
askMenuItem
;
else
switch
(
handlerInfo
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
internalMenuItem
)
{
menu
.
selectedItem
=
internalMenuItem
;
}
else
{
Cu
.
reportError
(
"
No
menu
item
defined
to
set
!
"
)
}
break
;
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
menu
.
selectedItem
=
defaultMenuItem
;
break
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
if
(
preferredApp
)
menu
.
selectedItem
=
possibleAppMenuItems
.
filter
(
v
=
>
v
.
handlerApp
.
equals
(
preferredApp
)
)
[
0
]
;
break
;
case
kActionUsePlugin
:
menu
.
selectedItem
=
pluginMenuItem
;
break
;
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
menu
.
selectedItem
=
saveMenuItem
;
break
;
}
}
_sortColumn
:
null
sort
(
event
)
{
var
column
=
event
.
target
;
if
(
this
.
_sortColumn
&
&
this
.
_sortColumn
!
=
column
)
this
.
_sortColumn
.
removeAttribute
(
"
sortDirection
"
)
;
this
.
_sortColumn
=
column
;
if
(
column
.
getAttribute
(
"
sortDirection
"
)
=
=
"
ascending
"
)
column
.
setAttribute
(
"
sortDirection
"
"
descending
"
)
;
else
column
.
setAttribute
(
"
sortDirection
"
"
ascending
"
)
;
this
.
_sortVisibleTypes
(
)
;
this
.
_rebuildView
(
)
;
}
_sortVisibleTypes
(
)
{
if
(
!
this
.
_sortColumn
)
return
;
var
t
=
this
;
function
sortByType
(
a
b
)
{
return
t
.
_describeType
(
a
)
.
toLowerCase
(
)
.
localeCompare
(
t
.
_describeType
(
b
)
.
toLowerCase
(
)
)
;
}
function
sortByAction
(
a
b
)
{
return
t
.
_describePreferredAction
(
a
)
.
toLowerCase
(
)
.
localeCompare
(
t
.
_describePreferredAction
(
b
)
.
toLowerCase
(
)
)
;
}
switch
(
this
.
_sortColumn
.
getAttribute
(
"
value
"
)
)
{
case
"
type
"
:
this
.
_visibleTypes
.
sort
(
sortByType
)
;
break
;
case
"
action
"
:
this
.
_visibleTypes
.
sort
(
sortByAction
)
;
break
;
}
if
(
this
.
_sortColumn
.
getAttribute
(
"
sortDirection
"
)
=
=
"
descending
"
)
this
.
_visibleTypes
.
reverse
(
)
;
}
filter
(
)
{
this
.
_rebuildView
(
)
;
}
focusFilterBox
(
)
{
this
.
_filter
.
focus
(
)
;
this
.
_filter
.
select
(
)
;
}
onSelectAction
(
aActionItem
)
{
this
.
_storingAction
=
true
;
try
{
this
.
_storeAction
(
aActionItem
)
;
}
finally
{
this
.
_storingAction
=
false
;
}
}
_storeAction
(
aActionItem
)
{
var
typeItem
=
this
.
_list
.
selectedItem
;
var
handlerInfo
=
this
.
_handledTypes
[
typeItem
.
type
]
;
let
action
=
parseInt
(
aActionItem
.
getAttribute
(
"
action
"
)
)
;
if
(
action
=
=
kActionUsePlugin
)
handlerInfo
.
enablePluginType
(
)
;
else
if
(
handlerInfo
.
pluginName
&
&
!
handlerInfo
.
isDisabledPluginType
)
handlerInfo
.
disablePluginType
(
)
;
if
(
action
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
)
handlerInfo
.
preferredApplicationHandler
=
aActionItem
.
handlerApp
;
if
(
action
=
=
Ci
.
nsIHandlerInfo
.
alwaysAsk
)
handlerInfo
.
alwaysAskBeforeHandling
=
true
;
else
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
handlerInfo
.
preferredAction
=
action
;
handlerInfo
.
store
(
)
;
handlerInfo
.
handledOnlyByPlugin
=
false
;
typeItem
.
setAttribute
(
"
actionDescription
"
this
.
_describePreferredAction
(
handlerInfo
)
)
;
if
(
!
this
.
_setIconClassForPreferredAction
(
handlerInfo
typeItem
)
)
{
typeItem
.
setAttribute
(
"
actionIcon
"
this
.
_getIconURLForPreferredAction
(
handlerInfo
)
)
;
}
}
manageApp
(
aEvent
)
{
aEvent
.
stopPropagation
(
)
;
var
typeItem
=
this
.
_list
.
selectedItem
;
var
handlerInfo
=
this
.
_handledTypes
[
typeItem
.
type
]
;
let
onComplete
=
(
)
=
>
{
this
.
rebuildActionsMenu
(
)
;
typeItem
.
setAttribute
(
"
actionDescription
"
this
.
_describePreferredAction
(
handlerInfo
)
)
;
if
(
!
this
.
_setIconClassForPreferredAction
(
handlerInfo
typeItem
)
)
{
typeItem
.
setAttribute
(
"
actionIcon
"
this
.
_getIconURLForPreferredAction
(
handlerInfo
)
)
;
}
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
applicationManager
.
xul
"
"
resizable
=
no
"
handlerInfo
onComplete
)
;
}
chooseApp
(
aEvent
)
{
aEvent
.
stopPropagation
(
)
;
var
handlerApp
;
let
chooseAppCallback
=
aHandlerApp
=
>
{
this
.
rebuildActionsMenu
(
)
;
if
(
aHandlerApp
)
{
let
typeItem
=
this
.
_list
.
selectedItem
;
let
actionsMenu
=
document
.
getAnonymousElementByAttribute
(
typeItem
"
class
"
"
actionsMenu
"
)
;
let
menuItems
=
actionsMenu
.
menupopup
.
childNodes
;
for
(
let
i
=
0
;
i
<
menuItems
.
length
;
i
+
+
)
{
let
menuItem
=
menuItems
[
i
]
;
if
(
menuItem
.
handlerApp
&
&
menuItem
.
handlerApp
.
equals
(
aHandlerApp
)
)
{
actionsMenu
.
selectedIndex
=
i
;
this
.
onSelectAction
(
menuItem
)
;
break
;
}
}
}
}
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
var
params
=
{
}
;
var
handlerInfo
=
this
.
_handledTypes
[
this
.
_list
.
selectedItem
.
type
]
;
if
(
isFeedType
(
handlerInfo
.
type
)
)
{
params
.
mimeInfo
=
this
.
_mimeSvc
.
getFromTypeAndExtension
(
handlerInfo
.
type
handlerInfo
.
primaryExtension
)
;
}
else
{
params
.
mimeInfo
=
handlerInfo
.
wrappedHandlerInfo
;
}
params
.
title
=
this
.
_prefsBundle
.
getString
(
"
fpTitleChooseApp
"
)
;
params
.
description
=
handlerInfo
.
description
;
params
.
filename
=
null
;
params
.
handlerApp
=
null
;
let
onAppSelected
=
(
)
=
>
{
if
(
this
.
isValidHandlerApp
(
params
.
handlerApp
)
)
{
handlerApp
=
params
.
handlerApp
;
handlerInfo
.
addPossibleApplicationHandler
(
handlerApp
)
;
}
chooseAppCallback
(
handlerApp
)
;
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
global
/
content
/
appPicker
.
xul
"
null
params
onAppSelected
)
;
}
else
{
let
winTitle
=
this
.
_prefsBundle
.
getString
(
"
fpTitleChooseApp
"
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
fpCallback
=
aResult
=
>
{
if
(
aResult
=
=
Ci
.
nsIFilePicker
.
returnOK
&
&
fp
.
file
&
&
this
.
_isValidHandlerExecutable
(
fp
.
file
)
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
name
=
getFileDisplayName
(
fp
.
file
)
;
handlerApp
.
executable
=
fp
.
file
;
let
handler
=
this
.
_handledTypes
[
this
.
_list
.
selectedItem
.
type
]
;
handler
.
addPossibleApplicationHandler
(
handlerApp
)
;
chooseAppCallback
(
handlerApp
)
;
}
}
;
fp
.
init
(
window
winTitle
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterApps
)
;
fp
.
open
(
fpCallback
)
;
}
}
onSelectionChanged
(
)
{
if
(
this
.
_list
.
selectedItem
)
this
.
_list
.
setAttribute
(
"
lastSelectedType
"
this
.
_list
.
selectedItem
.
getAttribute
(
"
type
"
)
)
;
}
_setIconClassForPreferredAction
(
aHandlerInfo
aElement
)
{
aElement
.
removeAttribute
(
"
actionIcon
"
)
;
if
(
aHandlerInfo
.
alwaysAskBeforeHandling
)
{
aElement
.
setAttribute
(
APP_ICON_ATTR_NAME
"
ask
"
)
;
return
true
;
}
switch
(
aHandlerInfo
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
aElement
.
setAttribute
(
APP_ICON_ATTR_NAME
"
save
"
)
;
return
true
;
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
isFeedType
(
aHandlerInfo
.
type
)
)
{
aElement
.
setAttribute
(
APP_ICON_ATTR_NAME
"
feed
"
)
;
return
true
;
}
else
if
(
aHandlerInfo
instanceof
InternalHandlerInfoWrapper
)
{
aElement
.
setAttribute
(
APP_ICON_ATTR_NAME
"
ask
"
)
;
return
true
;
}
break
;
case
kActionUsePlugin
:
aElement
.
setAttribute
(
APP_ICON_ATTR_NAME
"
plugin
"
)
;
return
true
;
}
aElement
.
removeAttribute
(
APP_ICON_ATTR_NAME
)
;
return
false
;
}
_getIconURLForPreferredAction
(
aHandlerInfo
)
{
switch
(
aHandlerInfo
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
return
this
.
_getIconURLForSystemDefault
(
aHandlerInfo
)
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
let
preferredApp
=
aHandlerInfo
.
preferredApplicationHandler
;
if
(
this
.
isValidHandlerApp
(
preferredApp
)
)
return
this
.
_getIconURLForHandlerApp
(
preferredApp
)
;
default
:
return
ICON_URL_APP
;
}
}
_getIconURLForHandlerApp
(
aHandlerApp
)
{
if
(
aHandlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
return
this
.
_getIconURLForFile
(
aHandlerApp
.
executable
)
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
return
this
.
_getIconURLForWebApp
(
aHandlerApp
.
uriTemplate
)
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebContentHandlerInfo
)
return
this
.
_getIconURLForWebApp
(
aHandlerApp
.
uri
)
return
"
"
;
}
_getIconURLForFile
(
aFile
)
{
var
fph
=
this
.
_ioSvc
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
var
urlSpec
=
fph
.
getURLSpecFromFile
(
aFile
)
;
return
"
moz
-
icon
:
/
/
"
+
urlSpec
+
"
?
size
=
16
"
;
}
_getIconURLForWebApp
(
aWebAppURITemplate
)
{
var
uri
=
this
.
_ioSvc
.
newURI
(
aWebAppURITemplate
)
;
if
(
/
^
https
?
/
.
test
(
uri
.
scheme
)
&
&
this
.
_prefSvc
.
getBoolPref
(
"
browser
.
chrome
.
favicons
"
)
)
return
uri
.
prePath
+
"
/
favicon
.
ico
"
;
return
"
"
;
}
_getIconURLForSystemDefault
(
aHandlerInfo
)
{
if
(
"
wrappedHandlerInfo
"
in
aHandlerInfo
)
{
let
wrappedHandlerInfo
=
aHandlerInfo
.
wrappedHandlerInfo
;
if
(
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
wrappedHandlerInfo
instanceof
Ci
.
nsIPropertyBag
)
{
try
{
let
url
=
wrappedHandlerInfo
.
getProperty
(
"
defaultApplicationIconURL
"
)
;
if
(
url
)
return
url
+
"
?
size
=
16
"
;
}
catch
(
ex
)
{
}
}
}
return
ICON_URL_APP
;
}
readUseDownloadDir
(
)
{
var
downloadFolder
=
document
.
getElementById
(
"
downloadFolder
"
)
;
var
chooseFolder
=
document
.
getElementById
(
"
chooseFolder
"
)
;
var
preference
=
document
.
getElementById
(
"
browser
.
download
.
useDownloadDir
"
)
;
downloadFolder
.
disabled
=
!
preference
.
value
|
|
preference
.
locked
;
chooseFolder
.
disabled
=
!
preference
.
value
|
|
preference
.
locked
;
return
undefined
;
}
chooseFolder
(
)
{
return
this
.
chooseFolderTask
(
)
.
catch
(
Components
.
utils
.
reportError
)
;
}
async
chooseFolderTask
(
)
{
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
title
=
bundlePreferences
.
getString
(
"
chooseDownloadFolderTitle
"
)
;
let
folderListPref
=
document
.
getElementById
(
"
browser
.
download
.
folderList
"
)
;
let
currentDirPref
=
await
this
.
_indexToFolder
(
folderListPref
.
value
)
;
let
defDownloads
=
await
this
.
_indexToFolder
(
1
)
;
let
fp
=
Components
.
classes
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIFilePicker
)
;
fp
.
init
(
window
title
Components
.
interfaces
.
nsIFilePicker
.
modeGetFolder
)
;
fp
.
appendFilters
(
Components
.
interfaces
.
nsIFilePicker
.
filterAll
)
;
if
(
currentDirPref
&
&
currentDirPref
.
exists
(
)
)
{
fp
.
displayDirectory
=
currentDirPref
;
}
else
if
(
defDownloads
&
&
defDownloads
.
exists
(
)
)
{
fp
.
displayDirectory
=
defDownloads
;
}
else
{
fp
.
displayDirectory
=
await
this
.
_indexToFolder
(
0
)
;
}
let
result
=
await
new
Promise
(
resolve
=
>
fp
.
open
(
resolve
)
)
;
if
(
result
!
=
Components
.
interfaces
.
nsIFilePicker
.
returnOK
)
{
return
;
}
let
downloadDirPref
=
document
.
getElementById
(
"
browser
.
download
.
dir
"
)
;
downloadDirPref
.
value
=
fp
.
file
;
folderListPref
.
value
=
await
this
.
_folderToIndex
(
fp
.
file
)
;
}
displayDownloadDirPref
(
)
{
this
.
displayDownloadDirPrefTask
(
)
.
catch
(
Components
.
utils
.
reportError
)
;
return
undefined
;
}
async
displayDownloadDirPrefTask
(
)
{
var
folderListPref
=
document
.
getElementById
(
"
browser
.
download
.
folderList
"
)
;
var
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
downloadFolder
=
document
.
getElementById
(
"
downloadFolder
"
)
;
var
currentDirPref
=
document
.
getElementById
(
"
browser
.
download
.
dir
"
)
;
var
ios
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIIOService
)
;
var
fph
=
ios
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Components
.
interfaces
.
nsIFileProtocolHandler
)
;
var
iconUrlSpec
;
if
(
folderListPref
.
value
=
=
2
)
{
downloadFolder
.
label
=
this
.
_getDisplayNameOfFile
(
currentDirPref
.
value
)
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
currentDirPref
.
value
)
;
}
else
if
(
folderListPref
.
value
=
=
1
)
{
downloadFolder
.
label
=
bundlePreferences
.
getString
(
"
downloadsFolderName
"
)
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
await
this
.
_indexToFolder
(
1
)
)
;
}
else
{
downloadFolder
.
label
=
bundlePreferences
.
getString
(
"
desktopFolderName
"
)
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
await
this
.
_getDownloadsFolder
(
"
Desktop
"
)
)
;
}
downloadFolder
.
image
=
"
moz
-
icon
:
/
/
"
+
iconUrlSpec
+
"
?
size
=
16
"
;
}
_getDisplayNameOfFile
(
aFolder
)
{
return
aFolder
?
aFolder
.
path
:
"
"
;
}
async
_getDownloadsFolder
(
aFolder
)
{
switch
(
aFolder
)
{
case
"
Desktop
"
:
var
fileLoc
=
Components
.
classes
[
"
mozilla
.
org
/
file
/
directory_service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIProperties
)
;
return
fileLoc
.
get
(
"
Desk
"
Components
.
interfaces
.
nsIFile
)
;
case
"
Downloads
"
:
let
downloadsDir
=
await
Downloads
.
getSystemDownloadsDirectory
(
)
;
return
new
FileUtils
.
File
(
downloadsDir
)
;
}
throw
"
ASSERTION
FAILED
:
folder
type
should
be
'
Desktop
'
or
'
Downloads
'
"
;
}
async
_folderToIndex
(
aFolder
)
{
if
(
!
aFolder
|
|
aFolder
.
equals
(
await
this
.
_getDownloadsFolder
(
"
Desktop
"
)
)
)
return
0
;
else
if
(
aFolder
.
equals
(
await
this
.
_getDownloadsFolder
(
"
Downloads
"
)
)
)
return
1
;
return
2
;
}
_indexToFolder
(
aIndex
)
{
switch
(
aIndex
)
{
case
0
:
return
this
.
_getDownloadsFolder
(
"
Desktop
"
)
;
case
1
:
return
this
.
_getDownloadsFolder
(
"
Downloads
"
)
;
}
var
currentDirPref
=
document
.
getElementById
(
"
browser
.
download
.
dir
"
)
;
return
currentDirPref
.
value
;
}
}
;
function
getFileDisplayName
(
file
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileWin
)
{
try
{
return
file
.
getVersionInfoField
(
"
FileDescription
"
)
;
}
catch
(
e
)
{
}
}
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileMac
)
{
try
{
return
file
.
bundleDisplayName
;
}
catch
(
e
)
{
}
}
}
return
file
.
leafName
;
}
function
getLocalHandlerApp
(
aFile
)
{
var
localHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandlerApp
.
name
=
getFileDisplayName
(
aFile
)
;
localHandlerApp
.
executable
=
aFile
;
return
localHandlerApp
;
}
function
ArrayEnumerator
(
aItems
)
{
this
.
_index
=
0
;
this
.
_contents
=
aItems
;
}
ArrayEnumerator
.
prototype
=
{
_index
:
0
hasMoreElements
(
)
{
return
this
.
_index
<
this
.
_contents
.
length
;
}
getNext
(
)
{
return
this
.
_contents
[
this
.
_index
+
+
]
;
}
}
;
function
isFeedType
(
t
)
{
return
t
=
=
TYPE_MAYBE_FEED
|
|
t
=
=
TYPE_MAYBE_VIDEO_FEED
|
|
t
=
=
TYPE_MAYBE_AUDIO_FEED
;
}
function
HandlerInfoWrapper
(
aType
aHandlerInfo
)
{
this
.
_type
=
aType
;
this
.
wrappedHandlerInfo
=
aHandlerInfo
;
}
HandlerInfoWrapper
.
prototype
=
{
wrappedHandlerInfo
:
null
_handlerSvc
:
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
_prefSvc
:
Cc
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrefBranch
)
_categoryMgr
:
Cc
[
"
mozilla
.
org
/
categorymanager
;
1
"
]
.
getService
(
Ci
.
nsICategoryManager
)
element
(
aID
)
{
return
document
.
getElementById
(
aID
)
;
}
_type
:
null
get
type
(
)
{
return
this
.
_type
;
}
get
description
(
)
{
if
(
this
.
wrappedHandlerInfo
.
description
)
return
this
.
wrappedHandlerInfo
.
description
;
if
(
this
.
primaryExtension
)
{
var
extension
=
this
.
primaryExtension
.
toUpperCase
(
)
;
return
this
.
element
(
"
bundlePreferences
"
)
.
getFormattedString
(
"
fileEnding
"
[
extension
]
)
;
}
return
this
.
type
;
}
get
preferredApplicationHandler
(
)
{
return
this
.
wrappedHandlerInfo
.
preferredApplicationHandler
;
}
set
preferredApplicationHandler
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
preferredApplicationHandler
=
aNewValue
;
if
(
aNewValue
)
this
.
addPossibleApplicationHandler
(
aNewValue
)
}
get
possibleApplicationHandlers
(
)
{
return
this
.
wrappedHandlerInfo
.
possibleApplicationHandlers
;
}
addPossibleApplicationHandler
(
aNewHandler
)
{
var
possibleApps
=
this
.
possibleApplicationHandlers
.
enumerate
(
)
;
while
(
possibleApps
.
hasMoreElements
(
)
)
{
if
(
possibleApps
.
getNext
(
)
.
equals
(
aNewHandler
)
)
return
;
}
this
.
possibleApplicationHandlers
.
appendElement
(
aNewHandler
)
;
}
removePossibleApplicationHandler
(
aHandler
)
{
var
defaultApp
=
this
.
preferredApplicationHandler
;
if
(
defaultApp
&
&
aHandler
.
equals
(
defaultApp
)
)
{
this
.
alwaysAskBeforeHandling
=
true
;
this
.
preferredApplicationHandler
=
null
;
}
var
handlers
=
this
.
possibleApplicationHandlers
;
for
(
var
i
=
0
;
i
<
handlers
.
length
;
+
+
i
)
{
var
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
equals
(
aHandler
)
)
{
handlers
.
removeElementAt
(
i
)
;
break
;
}
}
}
get
hasDefaultHandler
(
)
{
return
this
.
wrappedHandlerInfo
.
hasDefaultHandler
;
}
get
defaultDescription
(
)
{
return
this
.
wrappedHandlerInfo
.
defaultDescription
;
}
get
preferredAction
(
)
{
if
(
this
.
pluginName
&
&
!
this
.
isDisabledPluginType
)
return
kActionUsePlugin
;
if
(
this
.
wrappedHandlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
&
&
!
gMainPane
.
isValidHandlerApp
(
this
.
preferredApplicationHandler
)
)
{
if
(
this
.
wrappedHandlerInfo
.
hasDefaultHandler
)
return
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
return
Ci
.
nsIHandlerInfo
.
saveToDisk
;
}
return
this
.
wrappedHandlerInfo
.
preferredAction
;
}
set
preferredAction
(
aNewValue
)
{
if
(
(
aNewValue
=
=
kActionUsePlugin
)
&
&
(
this
.
preferredAction
!
=
Ci
.
nsIHandlerInfo
.
saveToDisk
)
)
{
aNewValue
=
Ci
.
nsIHandlerInfo
.
saveToDisk
;
}
if
(
aNewValue
!
=
kActionUsePlugin
)
this
.
wrappedHandlerInfo
.
preferredAction
=
aNewValue
;
}
get
alwaysAskBeforeHandling
(
)
{
if
(
this
.
pluginName
&
&
this
.
handledOnlyByPlugin
)
return
false
;
if
(
!
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
&
&
this
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
saveToDisk
)
return
true
;
return
this
.
wrappedHandlerInfo
.
alwaysAskBeforeHandling
;
}
set
alwaysAskBeforeHandling
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
alwaysAskBeforeHandling
=
aNewValue
;
}
get
primaryExtension
(
)
{
try
{
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
this
.
wrappedHandlerInfo
.
primaryExtension
)
return
this
.
wrappedHandlerInfo
.
primaryExtension
}
catch
(
ex
)
{
}
return
null
;
}
plugin
:
null
handledOnlyByPlugin
:
undefined
get
isDisabledPluginType
(
)
{
return
this
.
_getDisabledPluginTypes
(
)
.
indexOf
(
this
.
type
)
!
=
-
1
;
}
_getDisabledPluginTypes
(
)
{
var
types
=
"
"
;
if
(
this
.
_prefSvc
.
prefHasUserValue
(
PREF_DISABLED_PLUGIN_TYPES
)
)
types
=
this
.
_prefSvc
.
getCharPref
(
PREF_DISABLED_PLUGIN_TYPES
)
;
if
(
types
!
=
"
"
)
return
types
.
split
(
"
"
)
;
return
[
]
;
}
disablePluginType
(
)
{
var
disabledPluginTypes
=
this
.
_getDisabledPluginTypes
(
)
;
if
(
disabledPluginTypes
.
indexOf
(
this
.
type
)
=
=
-
1
)
disabledPluginTypes
.
push
(
this
.
type
)
;
this
.
_prefSvc
.
setCharPref
(
PREF_DISABLED_PLUGIN_TYPES
disabledPluginTypes
.
join
(
"
"
)
)
;
this
.
_categoryMgr
.
deleteCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
this
.
type
false
)
;
}
enablePluginType
(
)
{
var
disabledPluginTypes
=
this
.
_getDisabledPluginTypes
(
)
;
var
type
=
this
.
type
;
disabledPluginTypes
=
disabledPluginTypes
.
filter
(
v
=
>
v
!
=
type
)
;
this
.
_prefSvc
.
setCharPref
(
PREF_DISABLED_PLUGIN_TYPES
disabledPluginTypes
.
join
(
"
"
)
)
;
this
.
_categoryMgr
.
addCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
this
.
type
"
mozilla
.
org
/
content
/
plugin
/
document
-
loader
-
factory
;
1
"
false
true
)
;
}
store
(
)
{
this
.
_handlerSvc
.
store
(
this
.
wrappedHandlerInfo
)
;
}
get
smallIcon
(
)
{
return
this
.
_getIcon
(
16
)
;
}
_getIcon
(
aSize
)
{
if
(
this
.
primaryExtension
)
return
"
moz
-
icon
:
/
/
goat
.
"
+
this
.
primaryExtension
+
"
?
size
=
"
+
aSize
;
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
return
"
moz
-
icon
:
/
/
goat
?
size
=
"
+
aSize
+
"
&
contentType
=
"
+
this
.
type
;
return
null
;
}
}
;
function
FeedHandlerInfo
(
aMIMEType
)
{
HandlerInfoWrapper
.
call
(
this
aMIMEType
null
)
;
}
FeedHandlerInfo
.
prototype
=
{
__proto__
:
HandlerInfoWrapper
.
prototype
_converterSvc
:
Cc
[
"
mozilla
.
org
/
embeddor
.
implemented
/
web
-
content
-
handler
-
registrar
;
1
"
]
.
getService
(
Ci
.
nsIWebContentConverterService
)
_shellSvc
:
AppConstants
.
HAVE_SHELL_SERVICE
?
getShellService
(
)
:
null
get
description
(
)
{
return
this
.
element
(
"
bundlePreferences
"
)
.
getString
(
this
.
_appPrefLabel
)
;
}
get
preferredApplicationHandler
(
)
{
switch
(
this
.
element
(
this
.
_prefSelectedReader
)
.
value
)
{
case
"
client
"
:
var
file
=
this
.
element
(
this
.
_prefSelectedApp
)
.
value
;
if
(
file
)
return
getLocalHandlerApp
(
file
)
;
return
null
;
case
"
web
"
:
var
uri
=
this
.
element
(
this
.
_prefSelectedWeb
)
.
value
;
if
(
!
uri
)
return
null
;
return
this
.
_converterSvc
.
getWebContentHandlerByURI
(
this
.
type
uri
)
;
case
"
bookmarks
"
:
default
:
return
null
;
}
}
set
preferredApplicationHandler
(
aNewValue
)
{
if
(
aNewValue
instanceof
Ci
.
nsILocalHandlerApp
)
{
this
.
element
(
this
.
_prefSelectedApp
)
.
value
=
aNewValue
.
executable
;
this
.
element
(
this
.
_prefSelectedReader
)
.
value
=
"
client
"
;
}
else
if
(
aNewValue
instanceof
Ci
.
nsIWebContentHandlerInfo
)
{
this
.
element
(
this
.
_prefSelectedWeb
)
.
value
=
aNewValue
.
uri
;
this
.
element
(
this
.
_prefSelectedReader
)
.
value
=
"
web
"
;
this
.
_converterSvc
.
setAutoHandler
(
this
.
type
aNewValue
)
;
}
}
_possibleApplicationHandlers
:
null
get
possibleApplicationHandlers
(
)
{
if
(
this
.
_possibleApplicationHandlers
)
return
this
.
_possibleApplicationHandlers
;
this
.
_possibleApplicationHandlers
=
{
_inner
:
[
]
_removed
:
[
]
QueryInterface
(
aIID
)
{
if
(
aIID
.
equals
(
Ci
.
nsIMutableArray
)
|
|
aIID
.
equals
(
Ci
.
nsIArray
)
|
|
aIID
.
equals
(
Ci
.
nsISupports
)
)
return
this
;
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
get
length
(
)
{
return
this
.
_inner
.
length
;
}
enumerate
(
)
{
return
new
ArrayEnumerator
(
this
.
_inner
)
;
}
appendElement
(
aHandlerApp
aWeak
)
{
this
.
_inner
.
push
(
aHandlerApp
)
;
}
removeElementAt
(
aIndex
)
{
this
.
_removed
.
push
(
this
.
_inner
[
aIndex
]
)
;
this
.
_inner
.
splice
(
aIndex
1
)
;
}
queryElementAt
(
aIndex
aInterface
)
{
return
this
.
_inner
[
aIndex
]
.
QueryInterface
(
aInterface
)
;
}
}
;
var
preferredAppFile
=
this
.
element
(
this
.
_prefSelectedApp
)
.
value
;
if
(
preferredAppFile
)
{
let
preferredApp
=
getLocalHandlerApp
(
preferredAppFile
)
;
let
defaultApp
=
this
.
_defaultApplicationHandler
;
if
(
!
defaultApp
|
|
!
defaultApp
.
equals
(
preferredApp
)
)
this
.
_possibleApplicationHandlers
.
appendElement
(
preferredApp
)
;
}
var
webHandlers
=
this
.
_converterSvc
.
getContentHandlers
(
this
.
type
)
;
for
(
let
webHandler
of
webHandlers
)
this
.
_possibleApplicationHandlers
.
appendElement
(
webHandler
)
;
return
this
.
_possibleApplicationHandlers
;
}
__defaultApplicationHandler
:
undefined
get
_defaultApplicationHandler
(
)
{
if
(
typeof
this
.
__defaultApplicationHandler
!
=
"
undefined
"
)
return
this
.
__defaultApplicationHandler
;
var
defaultFeedReader
=
null
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
try
{
defaultFeedReader
=
this
.
_shellSvc
.
defaultFeedReader
;
}
catch
(
ex
)
{
}
}
if
(
defaultFeedReader
)
{
let
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIHandlerApp
)
;
handlerApp
.
name
=
getFileDisplayName
(
defaultFeedReader
)
;
handlerApp
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
executable
=
defaultFeedReader
;
this
.
__defaultApplicationHandler
=
handlerApp
;
}
else
{
this
.
__defaultApplicationHandler
=
null
;
}
return
this
.
__defaultApplicationHandler
;
}
get
hasDefaultHandler
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
try
{
if
(
this
.
_shellSvc
.
defaultFeedReader
)
return
true
;
}
catch
(
ex
)
{
}
}
return
false
;
}
get
defaultDescription
(
)
{
if
(
this
.
hasDefaultHandler
)
return
this
.
_defaultApplicationHandler
.
name
;
return
"
"
;
}
get
preferredAction
(
)
{
switch
(
this
.
element
(
this
.
_prefSelectedAction
)
.
value
)
{
case
"
bookmarks
"
:
return
Ci
.
nsIHandlerInfo
.
handleInternally
;
case
"
reader
"
:
{
let
preferredApp
=
this
.
preferredApplicationHandler
;
let
defaultApp
=
this
.
_defaultApplicationHandler
;
if
(
gMainPane
.
isValidHandlerApp
(
preferredApp
)
)
{
if
(
defaultApp
&
&
defaultApp
.
equals
(
preferredApp
)
)
return
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
return
Ci
.
nsIHandlerInfo
.
useHelperApp
;
}
return
Ci
.
nsIHandlerInfo
.
handleInternally
;
}
case
"
ask
"
:
default
:
return
Ci
.
nsIHandlerInfo
.
handleInternally
;
}
}
set
preferredAction
(
aNewValue
)
{
switch
(
aNewValue
)
{
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
this
.
element
(
this
.
_prefSelectedReader
)
.
value
=
"
bookmarks
"
;
break
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
this
.
element
(
this
.
_prefSelectedAction
)
.
value
=
"
reader
"
;
break
;
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
this
.
element
(
this
.
_prefSelectedAction
)
.
value
=
"
reader
"
;
this
.
preferredApplicationHandler
=
this
.
_defaultApplicationHandler
;
break
;
}
}
get
alwaysAskBeforeHandling
(
)
{
return
this
.
element
(
this
.
_prefSelectedAction
)
.
value
=
=
"
ask
"
;
}
set
alwaysAskBeforeHandling
(
aNewValue
)
{
if
(
aNewValue
=
=
true
)
this
.
element
(
this
.
_prefSelectedAction
)
.
value
=
"
ask
"
;
else
this
.
element
(
this
.
_prefSelectedAction
)
.
value
=
"
reader
"
;
}
_storingAction
:
false
get
primaryExtension
(
)
{
return
"
xml
"
;
}
store
(
)
{
for
(
let
app
of
this
.
_possibleApplicationHandlers
.
_removed
)
{
if
(
app
instanceof
Ci
.
nsILocalHandlerApp
)
{
let
pref
=
this
.
element
(
PREF_FEED_SELECTED_APP
)
;
var
preferredAppFile
=
pref
.
value
;
if
(
preferredAppFile
)
{
let
preferredApp
=
getLocalHandlerApp
(
preferredAppFile
)
;
if
(
app
.
equals
(
preferredApp
)
)
pref
.
reset
(
)
;
}
}
else
{
app
.
QueryInterface
(
Ci
.
nsIWebContentHandlerInfo
)
;
this
.
_converterSvc
.
removeContentHandler
(
app
.
contentType
app
.
uri
)
;
}
}
this
.
_possibleApplicationHandlers
.
_removed
=
[
]
;
}
get
smallIcon
(
)
{
return
this
.
_smallIcon
;
}
}
;
var
feedHandlerInfo
=
{
__proto__
:
new
FeedHandlerInfo
(
TYPE_MAYBE_FEED
)
_prefSelectedApp
:
PREF_FEED_SELECTED_APP
_prefSelectedWeb
:
PREF_FEED_SELECTED_WEB
_prefSelectedAction
:
PREF_FEED_SELECTED_ACTION
_prefSelectedReader
:
PREF_FEED_SELECTED_READER
_smallIcon
:
"
chrome
:
/
/
browser
/
skin
/
feeds
/
feedIcon16
.
png
"
_appPrefLabel
:
"
webFeed
"
}
var
videoFeedHandlerInfo
=
{
__proto__
:
new
FeedHandlerInfo
(
TYPE_MAYBE_VIDEO_FEED
)
_prefSelectedApp
:
PREF_VIDEO_FEED_SELECTED_APP
_prefSelectedWeb
:
PREF_VIDEO_FEED_SELECTED_WEB
_prefSelectedAction
:
PREF_VIDEO_FEED_SELECTED_ACTION
_prefSelectedReader
:
PREF_VIDEO_FEED_SELECTED_READER
_smallIcon
:
"
chrome
:
/
/
browser
/
skin
/
feeds
/
videoFeedIcon16
.
png
"
_appPrefLabel
:
"
videoPodcastFeed
"
}
var
audioFeedHandlerInfo
=
{
__proto__
:
new
FeedHandlerInfo
(
TYPE_MAYBE_AUDIO_FEED
)
_prefSelectedApp
:
PREF_AUDIO_FEED_SELECTED_APP
_prefSelectedWeb
:
PREF_AUDIO_FEED_SELECTED_WEB
_prefSelectedAction
:
PREF_AUDIO_FEED_SELECTED_ACTION
_prefSelectedReader
:
PREF_AUDIO_FEED_SELECTED_READER
_smallIcon
:
"
chrome
:
/
/
browser
/
skin
/
feeds
/
audioFeedIcon16
.
png
"
_appPrefLabel
:
"
audioPodcastFeed
"
}
function
InternalHandlerInfoWrapper
(
aMIMEType
)
{
var
mimeSvc
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
;
var
handlerInfo
=
mimeSvc
.
getFromTypeAndExtension
(
aMIMEType
null
)
;
HandlerInfoWrapper
.
call
(
this
aMIMEType
handlerInfo
)
;
}
InternalHandlerInfoWrapper
.
prototype
=
{
__proto__
:
HandlerInfoWrapper
.
prototype
store
(
)
{
HandlerInfoWrapper
.
prototype
.
store
.
call
(
this
)
;
Services
.
obs
.
notifyObservers
(
null
this
.
_handlerChanged
)
;
}
get
enabled
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
get
description
(
)
{
return
this
.
element
(
"
bundlePreferences
"
)
.
getString
(
this
.
_appPrefLabel
)
;
}
}
;
var
pdfHandlerInfo
=
{
__proto__
:
new
InternalHandlerInfoWrapper
(
TYPE_PDF
)
_handlerChanged
:
TOPIC_PDFJS_HANDLER_CHANGED
_appPrefLabel
:
"
portableDocumentFormat
"
get
enabled
(
)
{
return
!
Services
.
prefs
.
getBoolPref
(
PREF_PDFJS_DISABLED
)
;
}
}
;
