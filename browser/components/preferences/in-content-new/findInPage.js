var
gSearchResultsPane
=
{
listSearchTooltips
:
new
Set
(
)
listSearchMenuitemIndicators
:
new
Set
(
)
searchResultsCategory
:
null
searchInput
:
null
init
(
)
{
this
.
searchResultsCategory
=
document
.
getElementById
(
"
category
-
search
-
results
"
)
;
this
.
searchInput
=
document
.
getElementById
(
"
searchInput
"
)
;
this
.
searchInput
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
preferences
.
search
"
)
;
if
(
!
this
.
searchInput
.
hidden
)
{
this
.
searchInput
.
addEventListener
(
"
command
"
this
)
;
this
.
searchInput
.
addEventListener
(
"
focus
"
this
)
;
let
callbackId
;
window
.
addEventListener
(
"
resize
"
(
)
=
>
{
if
(
!
callbackId
)
{
callbackId
=
window
.
requestAnimationFrame
(
(
)
=
>
{
this
.
listSearchTooltips
.
forEach
(
(
anchorNode
)
=
>
{
this
.
calculateTooltipPosition
(
anchorNode
)
;
}
)
;
callbackId
=
null
;
}
)
;
}
}
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
command
"
)
{
this
.
searchFunction
(
event
)
;
}
else
if
(
event
.
type
=
=
=
"
focus
"
)
{
this
.
initializeCategories
(
)
;
}
}
stringMatchesFilters
(
str
filter
)
{
if
(
!
filter
|
|
!
str
)
{
return
false
;
}
let
searchStr
=
str
.
toLowerCase
(
)
;
let
filterStrings
=
filter
.
toLowerCase
(
)
.
split
(
/
\
s
+
/
)
;
return
!
filterStrings
.
some
(
f
=
>
searchStr
.
indexOf
(
f
)
=
=
-
1
)
;
}
categoriesInitialized
:
false
initializeCategories
(
)
{
if
(
!
this
.
categoriesInitialized
)
{
this
.
categoriesInitialized
=
true
;
for
(
let
[
category
]
of
gCategoryInits
)
{
if
(
!
category
.
inited
)
{
category
.
init
(
)
;
}
}
}
}
textNodeDescendants
(
node
)
{
if
(
!
node
)
{
return
[
]
;
}
let
all
=
[
]
;
for
(
node
=
node
.
firstChild
;
node
;
node
=
node
.
nextSibling
)
{
if
(
node
.
nodeType
=
=
=
node
.
TEXT_NODE
)
{
all
.
push
(
node
)
;
}
else
{
all
=
all
.
concat
(
this
.
textNodeDescendants
(
node
)
)
;
}
}
return
all
;
}
highlightMatches
(
textNodes
nodeSizes
textSearch
searchPhrase
)
{
if
(
!
searchPhrase
)
{
return
false
;
}
let
indices
=
[
]
;
let
i
=
-
1
;
while
(
(
i
=
textSearch
.
indexOf
(
searchPhrase
i
+
1
)
)
>
=
0
)
{
indices
.
push
(
i
)
;
}
for
(
let
startValue
of
indices
)
{
let
endValue
=
startValue
+
searchPhrase
.
length
;
let
startNode
=
null
;
let
endNode
=
null
;
let
nodeStartIndex
=
null
;
nodeSizes
.
forEach
(
function
(
lengthNodes
index
)
{
if
(
!
startNode
&
&
lengthNodes
>
=
startValue
)
{
startNode
=
textNodes
[
index
]
;
nodeStartIndex
=
index
;
if
(
index
>
0
)
{
startValue
-
=
nodeSizes
[
index
-
1
]
;
}
}
if
(
!
endNode
&
&
lengthNodes
>
=
endValue
)
{
endNode
=
textNodes
[
index
]
;
if
(
index
!
=
nodeStartIndex
|
|
index
>
0
)
{
endValue
-
=
nodeSizes
[
index
-
1
]
;
}
}
}
)
;
let
range
=
document
.
createRange
(
)
;
range
.
setStart
(
startNode
startValue
)
;
range
.
setEnd
(
endNode
endValue
)
;
this
.
getFindSelection
(
startNode
.
ownerGlobal
)
.
addRange
(
range
)
;
}
return
indices
.
length
>
0
;
}
getFindSelection
(
win
)
{
let
docShell
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
let
controller
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsISelectionDisplay
)
.
QueryInterface
(
Ci
.
nsISelectionController
)
;
let
selection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
selection
.
setColors
(
"
currentColor
"
"
#
ffe900
"
"
currentColor
"
"
#
003eaa
"
)
;
return
selection
;
}
get
strings
(
)
{
delete
this
.
strings
;
return
this
.
strings
=
document
.
getElementById
(
"
searchResultBundle
"
)
;
}
searchFunction
(
event
)
{
this
.
query
=
event
.
target
.
value
.
trim
(
)
.
toLowerCase
(
)
;
this
.
getFindSelection
(
window
)
.
removeAllRanges
(
)
;
this
.
removeAllSearchTooltips
(
)
;
this
.
removeAllSearchMenuitemIndicators
(
)
;
let
srHeader
=
document
.
getElementById
(
"
header
-
searchResults
"
)
;
if
(
this
.
query
)
{
gotoPref
(
"
paneSearchResults
"
)
;
this
.
searchResultsCategory
.
hidden
=
false
;
let
resultsFound
=
false
;
let
rootPreferencesChildren
=
document
.
querySelectorAll
(
"
#
mainPrefPane
>
*
:
not
(
[
data
-
hidden
-
from
-
search
]
)
"
)
;
for
(
let
i
=
0
;
i
<
rootPreferencesChildren
.
length
;
i
+
+
)
{
rootPreferencesChildren
[
i
]
.
hidden
=
false
;
}
for
(
let
i
=
0
;
i
<
rootPreferencesChildren
.
length
;
i
+
+
)
{
if
(
rootPreferencesChildren
[
i
]
.
className
!
=
"
header
"
&
&
rootPreferencesChildren
[
i
]
.
className
!
=
"
no
-
results
-
message
"
&
&
this
.
searchWithinNode
(
rootPreferencesChildren
[
i
]
this
.
query
)
)
{
rootPreferencesChildren
[
i
]
.
hidden
=
false
;
resultsFound
=
true
;
}
else
{
rootPreferencesChildren
[
i
]
.
hidden
=
true
;
}
}
srHeader
.
hidden
=
false
;
if
(
!
resultsFound
)
{
let
noResultsEl
=
document
.
querySelector
(
"
.
no
-
results
-
message
"
)
;
noResultsEl
.
hidden
=
false
;
let
strings
=
this
.
strings
;
document
.
getElementById
(
"
sorry
-
message
"
)
.
textContent
=
AppConstants
.
platform
=
=
"
win
"
?
strings
.
getFormattedString
(
"
searchResults
.
sorryMessageWin
"
[
this
.
query
]
)
:
strings
.
getFormattedString
(
"
searchResults
.
sorryMessageUnix
"
[
this
.
query
]
)
;
let
helpUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
preferences
"
;
let
brandName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
document
.
getElementById
(
"
need
-
help
"
)
.
innerHTML
=
strings
.
getFormattedString
(
"
searchResults
.
needHelp2
"
[
helpUrl
brandName
]
)
;
}
else
{
this
.
listSearchTooltips
.
forEach
(
(
anchorNode
)
=
>
this
.
createSearchTooltip
(
anchorNode
this
.
query
)
)
;
}
}
else
{
this
.
searchResultsCategory
.
hidden
=
true
;
document
.
getElementById
(
"
sorry
-
message
"
)
.
textContent
=
"
"
;
gotoPref
(
"
paneGeneral
"
)
;
}
}
searchWithinNode
(
nodeObject
searchPhrase
)
{
let
matchesFound
=
false
;
if
(
nodeObject
.
childElementCount
=
=
0
|
|
nodeObject
.
tagName
=
=
"
label
"
|
|
nodeObject
.
tagName
=
=
"
description
"
|
|
nodeObject
.
tagName
=
=
"
menulist
"
)
{
let
simpleTextNodes
=
this
.
textNodeDescendants
(
nodeObject
)
;
for
(
let
node
of
simpleTextNodes
)
{
let
result
=
this
.
highlightMatches
(
[
node
]
[
node
.
length
]
node
.
textContent
.
toLowerCase
(
)
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
let
nodeSizes
=
[
]
;
let
allNodeText
=
"
"
;
let
runningSize
=
0
;
let
accessKeyTextNodes
=
this
.
textNodeDescendants
(
nodeObject
.
boxObject
)
;
if
(
nodeObject
.
tagName
=
=
"
label
"
|
|
nodeObject
.
tagName
=
=
"
description
"
)
{
accessKeyTextNodes
.
push
(
.
.
.
this
.
textNodeDescendants
(
nodeObject
)
)
;
}
for
(
let
node
of
accessKeyTextNodes
)
{
runningSize
+
=
node
.
textContent
.
length
;
allNodeText
+
=
node
.
textContent
;
nodeSizes
.
push
(
runningSize
)
;
}
let
complexTextNodesResult
=
this
.
highlightMatches
(
accessKeyTextNodes
nodeSizes
allNodeText
.
toLowerCase
(
)
searchPhrase
)
;
let
labelResult
=
this
.
stringMatchesFilters
(
nodeObject
.
getAttribute
(
"
label
"
)
searchPhrase
)
;
let
valueResult
=
nodeObject
.
tagName
!
=
=
"
menuitem
"
?
this
.
stringMatchesFilters
(
nodeObject
.
getAttribute
(
"
value
"
)
searchPhrase
)
:
false
;
let
keywordsResult
=
this
.
stringMatchesFilters
(
nodeObject
.
getAttribute
(
"
searchkeywords
"
)
searchPhrase
)
;
if
(
keywordsResult
&
&
(
nodeObject
.
tagName
=
=
=
"
button
"
|
|
nodeObject
.
tagName
=
=
"
menulist
"
)
)
{
this
.
listSearchTooltips
.
add
(
nodeObject
)
;
}
if
(
keywordsResult
&
&
nodeObject
.
tagName
=
=
=
"
menuitem
"
)
{
nodeObject
.
setAttribute
(
"
indicator
"
"
true
"
)
;
this
.
listSearchMenuitemIndicators
.
add
(
nodeObject
)
;
let
menulist
=
nodeObject
.
closest
(
"
menulist
"
)
;
menulist
.
setAttribute
(
"
indicator
"
"
true
"
)
;
this
.
listSearchMenuitemIndicators
.
add
(
menulist
)
;
}
if
(
(
nodeObject
.
tagName
=
=
"
button
"
|
|
nodeObject
.
tagName
=
=
"
menulist
"
|
|
nodeObject
.
tagName
=
=
"
menuitem
"
)
&
&
(
labelResult
|
|
valueResult
|
|
keywordsResult
)
)
{
nodeObject
.
setAttribute
(
"
highlightable
"
"
true
"
)
;
}
matchesFound
=
matchesFound
|
|
complexTextNodesResult
|
|
labelResult
|
|
valueResult
|
|
keywordsResult
;
}
if
(
nodeObject
.
tagName
=
=
"
deck
"
&
&
nodeObject
.
id
!
=
"
historyPane
"
)
{
let
index
=
nodeObject
.
selectedIndex
;
if
(
index
!
=
-
1
)
{
let
result
=
this
.
searchChildNodeIfVisible
(
nodeObject
index
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
}
else
{
for
(
let
i
=
0
;
i
<
nodeObject
.
childNodes
.
length
;
i
+
+
)
{
let
result
=
this
.
searchChildNodeIfVisible
(
nodeObject
i
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
}
return
matchesFound
;
}
searchChildNodeIfVisible
(
nodeObject
index
searchPhrase
)
{
let
result
=
false
;
if
(
!
nodeObject
.
childNodes
[
index
]
.
hidden
&
&
nodeObject
.
getAttribute
(
"
data
-
hidden
-
from
-
search
"
)
!
=
=
"
true
"
)
{
result
=
this
.
searchWithinNode
(
nodeObject
.
childNodes
[
index
]
searchPhrase
)
;
if
(
result
&
&
nodeObject
.
tagName
=
=
=
"
menulist
"
)
{
this
.
listSearchTooltips
.
add
(
nodeObject
)
;
}
}
return
result
;
}
createSearchTooltip
(
anchorNode
query
)
{
let
searchTooltip
=
anchorNode
.
ownerDocument
.
createElement
(
"
span
"
)
;
searchTooltip
.
setAttribute
(
"
class
"
"
search
-
tooltip
"
)
;
searchTooltip
.
textContent
=
query
;
anchorNode
.
setAttribute
(
"
data
-
has
-
tooltip
"
"
true
"
)
;
anchorNode
.
parentElement
.
classList
.
add
(
"
search
-
tooltip
-
parent
"
)
;
anchorNode
.
parentElement
.
appendChild
(
searchTooltip
)
;
this
.
calculateTooltipPosition
(
anchorNode
)
;
}
calculateTooltipPosition
(
anchorNode
)
{
let
searchTooltip
=
anchorNode
.
parentElement
.
querySelector
(
"
:
scope
>
.
search
-
tooltip
"
)
;
let
anchorRect
=
anchorNode
.
getBoundingClientRect
(
)
;
let
tooltipRect
=
searchTooltip
.
getBoundingClientRect
(
)
;
let
parentRect
=
anchorNode
.
parentElement
.
getBoundingClientRect
(
)
;
let
offSet
=
(
anchorRect
.
width
/
2
)
-
(
tooltipRect
.
width
/
2
)
;
let
relativeOffset
=
anchorRect
.
left
-
parentRect
.
left
;
offSet
+
=
relativeOffset
>
0
?
relativeOffset
:
0
;
searchTooltip
.
style
.
setProperty
(
"
left
"
{
offSet
}
px
)
;
}
removeAllSearchTooltips
(
)
{
let
searchTooltips
=
Array
.
from
(
document
.
querySelectorAll
(
"
.
search
-
tooltip
"
)
)
;
for
(
let
searchTooltip
of
searchTooltips
)
{
searchTooltip
.
parentElement
.
classList
.
remove
(
"
search
-
tooltip
-
parent
"
)
;
searchTooltip
.
remove
(
)
;
}
this
.
listSearchTooltips
.
forEach
(
(
anchorNode
)
=
>
anchorNode
.
removeAttribute
(
"
data
-
has
-
tooltip
"
)
)
;
this
.
listSearchTooltips
.
clear
(
)
;
}
removeAllSearchMenuitemIndicators
(
)
{
this
.
listSearchMenuitemIndicators
.
forEach
(
(
node
)
=
>
node
.
removeAttribute
(
"
indicator
"
)
)
;
this
.
listSearchMenuitemIndicators
.
clear
(
)
;
}
}
