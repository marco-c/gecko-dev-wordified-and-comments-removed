Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
LoadContextInfo
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
SiteDataManager
"
"
resource
:
/
/
/
modules
/
SiteDataManager
.
jsm
"
)
;
const
PREF_UPLOAD_ENABLED
=
"
datareporting
.
healthreport
.
uploadEnabled
"
;
var
gAdvancedPane
=
{
_inited
:
false
init
(
)
{
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gAdvancedPane
)
)
;
}
this
.
_inited
=
true
;
var
advancedPrefs
=
document
.
getElementById
(
"
advancedPrefs
"
)
;
var
preference
=
document
.
getElementById
(
"
browser
.
preferences
.
advanced
.
selectedTabIndex
"
)
;
if
(
preference
.
value
!
=
=
null
)
advancedPrefs
.
selectedIndex
=
preference
.
value
;
if
(
AppConstants
.
MOZ_UPDATER
)
{
let
onUnload
=
function
(
)
{
window
.
removeEventListener
(
"
unload
"
onUnload
)
;
Services
.
prefs
.
removeObserver
(
"
app
.
update
.
"
this
)
;
}
.
bind
(
this
)
;
window
.
addEventListener
(
"
unload
"
onUnload
)
;
Services
.
prefs
.
addObserver
(
"
app
.
update
.
"
this
false
)
;
this
.
updateReadPrefs
(
)
;
}
this
.
updateOfflineApps
(
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
this
.
initSubmitCrashes
(
)
;
}
this
.
initTelemetry
(
)
;
if
(
AppConstants
.
MOZ_TELEMETRY_REPORTING
)
{
this
.
initSubmitHealthReport
(
)
;
}
this
.
updateOnScreenKeyboardVisibility
(
)
;
this
.
updateCacheSizeInputField
(
)
;
this
.
updateActualCacheSize
(
)
;
this
.
updateActualAppCacheSize
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
storageManager
.
enabled
"
)
)
{
Services
.
obs
.
addObserver
(
this
"
sitedatamanager
:
sites
-
updated
"
false
)
;
let
unload
=
(
)
=
>
{
window
.
removeEventListener
(
"
unload
"
unload
)
;
Services
.
obs
.
removeObserver
(
this
"
sitedatamanager
:
sites
-
updated
"
)
;
}
;
window
.
addEventListener
(
"
unload
"
unload
)
;
SiteDataManager
.
updateSites
(
)
;
setEventListener
(
"
clearSiteDataButton
"
"
command
"
gAdvancedPane
.
clearSiteData
)
;
setEventListener
(
"
siteDataSettings
"
"
command
"
gAdvancedPane
.
showSiteDataSettings
)
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
storage
-
permissions
"
;
document
.
getElementById
(
"
siteDataLearnMoreLink
"
)
.
setAttribute
(
"
href
"
url
)
;
}
setEventListener
(
"
layers
.
acceleration
.
disabled
"
"
change
"
gAdvancedPane
.
updateHardwareAcceleration
)
;
setEventListener
(
"
advancedPrefs
"
"
select
"
gAdvancedPane
.
tabSelectionChanged
)
;
if
(
AppConstants
.
MOZ_TELEMETRY_REPORTING
)
{
setEventListener
(
"
submitHealthReportBox
"
"
command
"
gAdvancedPane
.
updateSubmitHealthReport
)
;
}
setEventListener
(
"
connectionSettings
"
"
command
"
gAdvancedPane
.
showConnections
)
;
setEventListener
(
"
clearCacheButton
"
"
command
"
gAdvancedPane
.
clearCache
)
;
setEventListener
(
"
clearOfflineAppCacheButton
"
"
command
"
gAdvancedPane
.
clearOfflineAppCache
)
;
setEventListener
(
"
offlineNotifyExceptions
"
"
command
"
gAdvancedPane
.
showOfflineExceptions
)
;
setEventListener
(
"
offlineAppsList
"
"
select
"
gAdvancedPane
.
offlineAppSelected
)
;
let
bundlePrefs
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
document
.
getElementById
(
"
offlineAppsList
"
)
.
style
.
height
=
bundlePrefs
.
getString
(
"
offlineAppsList
.
height
"
)
;
setEventListener
(
"
offlineAppsListRemove
"
"
command
"
gAdvancedPane
.
removeOfflineApp
)
;
if
(
AppConstants
.
MOZ_UPDATER
)
{
setEventListener
(
"
updateRadioGroup
"
"
command
"
gAdvancedPane
.
updateWritePrefs
)
;
setEventListener
(
"
showUpdateHistory
"
"
command
"
gAdvancedPane
.
showUpdates
)
;
}
setEventListener
(
"
viewCertificatesButton
"
"
command
"
gAdvancedPane
.
showCertificates
)
;
setEventListener
(
"
viewSecurityDevicesButton
"
"
command
"
gAdvancedPane
.
showSecurityDevices
)
;
setEventListener
(
"
cacheSize
"
"
change
"
gAdvancedPane
.
updateCacheSizePref
)
;
if
(
AppConstants
.
MOZ_WIDGET_GTK
)
{
let
tabsElement
=
document
.
getElementById
(
"
tabsElement
"
)
;
tabsElement
.
addEventListener
(
"
DOMMouseScroll
"
event
=
>
{
event
.
stopPropagation
(
)
;
}
true
)
;
}
}
tabSelectionChanged
(
)
{
if
(
!
this
.
_inited
)
return
;
var
advancedPrefs
=
document
.
getElementById
(
"
advancedPrefs
"
)
;
var
preference
=
document
.
getElementById
(
"
browser
.
preferences
.
advanced
.
selectedTabIndex
"
)
;
if
(
preference
.
valueFromPreferences
!
=
advancedPrefs
.
selectedIndex
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_PREFERENCES_CATEGORY_OPENED
"
)
.
add
(
telemetryBucketForCategory
(
"
advanced
"
)
)
;
}
preference
.
valueFromPreferences
=
advancedPrefs
.
selectedIndex
;
}
_storedSpellCheck
:
0
readCheckSpelling
(
)
{
var
pref
=
document
.
getElementById
(
"
layout
.
spellcheckDefault
"
)
;
this
.
_storedSpellCheck
=
pref
.
value
;
return
(
pref
.
value
!
=
0
)
;
}
writeCheckSpelling
(
)
{
var
checkbox
=
document
.
getElementById
(
"
checkSpelling
"
)
;
if
(
checkbox
.
checked
)
{
if
(
this
.
_storedSpellCheck
=
=
2
)
{
return
2
;
}
return
1
;
}
return
0
;
}
readEnableOCSP
(
)
{
var
preference
=
document
.
getElementById
(
"
security
.
OCSP
.
enabled
"
)
;
if
(
preference
.
value
=
=
=
undefined
)
{
return
true
;
}
return
preference
.
value
=
=
1
;
}
writeEnableOCSP
(
)
{
var
checkbox
=
document
.
getElementById
(
"
enableOCSP
"
)
;
return
checkbox
.
checked
?
1
:
0
;
}
updateHardwareAcceleration
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
var
fromPref
=
document
.
getElementById
(
"
layers
.
acceleration
.
disabled
"
)
;
var
toPref
=
document
.
getElementById
(
"
gfx
.
direct2d
.
disabled
"
)
;
toPref
.
value
=
fromPref
.
value
;
}
}
_setupLearnMoreLink
(
pref
element
)
{
let
url
=
Services
.
prefs
.
getCharPref
(
pref
)
;
let
el
=
document
.
getElementById
(
element
)
;
if
(
url
)
{
el
.
setAttribute
(
"
href
"
url
)
;
}
else
{
el
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
initSubmitCrashes
(
)
{
this
.
_setupLearnMoreLink
(
"
toolkit
.
crashreporter
.
infoURL
"
"
crashReporterLearnMore
"
)
;
}
initTelemetry
(
)
{
if
(
AppConstants
.
MOZ_TELEMETRY_REPORTING
)
{
this
.
_setupLearnMoreLink
(
"
toolkit
.
telemetry
.
infoURL
"
"
telemetryLearnMore
"
)
;
}
}
setTelemetrySectionEnabled
(
aEnabled
)
{
if
(
AppConstants
.
MOZ_TELEMETRY_REPORTING
)
{
let
disabled
=
!
aEnabled
;
document
.
getElementById
(
"
submitTelemetryBox
"
)
.
disabled
=
disabled
;
if
(
disabled
)
{
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
enabled
"
false
)
;
}
document
.
getElementById
(
"
telemetryDataDesc
"
)
.
disabled
=
disabled
;
}
}
initSubmitHealthReport
(
)
{
if
(
AppConstants
.
MOZ_TELEMETRY_REPORTING
)
{
this
.
_setupLearnMoreLink
(
"
datareporting
.
healthreport
.
infoURL
"
"
FHRLearnMore
"
)
;
let
checkbox
=
document
.
getElementById
(
"
submitHealthReportBox
"
)
;
if
(
Services
.
prefs
.
prefIsLocked
(
PREF_UPLOAD_ENABLED
)
)
{
checkbox
.
setAttribute
(
"
disabled
"
"
true
"
)
;
return
;
}
checkbox
.
checked
=
Services
.
prefs
.
getBoolPref
(
PREF_UPLOAD_ENABLED
)
;
this
.
setTelemetrySectionEnabled
(
checkbox
.
checked
)
;
}
}
updateSubmitHealthReport
(
)
{
if
(
AppConstants
.
MOZ_TELEMETRY_REPORTING
)
{
let
checkbox
=
document
.
getElementById
(
"
submitHealthReportBox
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_UPLOAD_ENABLED
checkbox
.
checked
)
;
this
.
setTelemetrySectionEnabled
(
checkbox
.
checked
)
;
}
}
updateOnScreenKeyboardVisibility
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
minVersion
=
Services
.
prefs
.
getBoolPref
(
"
ui
.
osk
.
require_win10
"
)
?
10
:
6
.
2
;
if
(
Services
.
vc
.
compare
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
minVersion
)
>
=
0
)
{
document
.
getElementById
(
"
useOnScreenKeyboard
"
)
.
hidden
=
false
;
}
}
}
showConnections
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
connection
.
xul
"
)
;
}
showSiteDataSettings
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
siteDataSettings
.
xul
"
)
;
}
updateTotalSiteDataSize
(
)
{
SiteDataManager
.
getTotalUsage
(
)
.
then
(
usage
=
>
{
let
size
=
DownloadUtils
.
convertByteUnits
(
usage
)
;
let
prefStrBundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
totalSiteDataSizeLabel
=
document
.
getElementById
(
"
totalSiteDataSize
"
)
;
totalSiteDataSizeLabel
.
textContent
=
prefStrBundle
.
getFormattedString
(
"
totalSiteDataSize
"
size
)
;
let
siteDataGroup
=
document
.
getElementById
(
"
siteDataGroup
"
)
;
siteDataGroup
.
hidden
=
false
;
}
)
;
}
updateActualCacheSize
(
)
{
var
actualSizeLabel
=
document
.
getElementById
(
"
actualDiskCacheSize
"
)
;
var
prefStrBundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
this
.
observer
=
{
onNetworkCacheDiskConsumption
(
consumption
)
{
var
size
=
DownloadUtils
.
convertByteUnits
(
consumption
)
;
if
(
!
prefStrBundle
.
getFormattedString
)
{
return
;
}
actualSizeLabel
.
value
=
prefStrBundle
.
getFormattedString
(
"
actualDiskCacheSize
"
size
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Components
.
interfaces
.
nsICacheStorageConsumptionObserver
Components
.
interfaces
.
nsISupportsWeakReference
]
)
}
;
actualSizeLabel
.
value
=
prefStrBundle
.
getString
(
"
actualDiskCacheSizeCalculated
"
)
;
try
{
var
cacheService
=
Components
.
classes
[
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsICacheStorageService
)
;
cacheService
.
asyncGetDiskConsumption
(
this
.
observer
)
;
}
catch
(
e
)
{
}
}
updateActualAppCacheSize
(
)
{
var
visitor
=
{
onCacheStorageInfo
(
aEntryCount
aConsumption
aCapacity
aDiskDirectory
)
{
var
actualSizeLabel
=
document
.
getElementById
(
"
actualAppCacheSize
"
)
;
var
sizeStrings
=
DownloadUtils
.
convertByteUnits
(
aConsumption
)
;
var
prefStrBundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
if
(
!
prefStrBundle
.
getFormattedString
)
{
return
;
}
var
sizeStr
=
prefStrBundle
.
getFormattedString
(
"
actualAppCacheSize
"
sizeStrings
)
;
actualSizeLabel
.
value
=
sizeStr
;
}
}
;
try
{
var
cacheService
=
Components
.
classes
[
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsICacheStorageService
)
;
var
storage
=
cacheService
.
appCacheStorage
(
LoadContextInfo
.
default
null
)
;
storage
.
asyncVisitStorage
(
visitor
false
)
;
}
catch
(
e
)
{
}
}
updateCacheSizeUI
(
smartSizeEnabled
)
{
document
.
getElementById
(
"
useCacheBefore
"
)
.
disabled
=
smartSizeEnabled
;
document
.
getElementById
(
"
cacheSize
"
)
.
disabled
=
smartSizeEnabled
;
document
.
getElementById
(
"
useCacheAfter
"
)
.
disabled
=
smartSizeEnabled
;
}
readSmartSizeEnabled
(
)
{
var
disabled
=
document
.
getElementById
(
"
browser
.
cache
.
disk
.
smart_size
.
enabled
"
)
.
value
;
this
.
updateCacheSizeUI
(
!
disabled
)
;
}
updateCacheSizeInputField
(
)
{
let
cacheSizeElem
=
document
.
getElementById
(
"
cacheSize
"
)
;
let
cachePref
=
document
.
getElementById
(
"
browser
.
cache
.
disk
.
capacity
"
)
;
cacheSizeElem
.
value
=
cachePref
.
value
/
1024
;
if
(
cachePref
.
locked
)
cacheSizeElem
.
disabled
=
true
;
}
updateCacheSizePref
(
)
{
let
cacheSizeElem
=
document
.
getElementById
(
"
cacheSize
"
)
;
let
cachePref
=
document
.
getElementById
(
"
browser
.
cache
.
disk
.
capacity
"
)
;
let
intValue
=
parseInt
(
cacheSizeElem
.
value
10
)
;
cachePref
.
value
=
isNaN
(
intValue
)
?
0
:
intValue
*
1024
;
}
clearCache
(
)
{
try
{
var
cache
=
Components
.
classes
[
"
mozilla
.
org
/
netwerk
/
cache
-
storage
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsICacheStorageService
)
;
cache
.
clear
(
)
;
}
catch
(
ex
)
{
}
this
.
updateActualCacheSize
(
)
;
}
clearOfflineAppCache
(
)
{
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
offlineAppCache
.
jsm
"
)
;
OfflineAppCacheHelper
.
clear
(
)
;
this
.
updateActualAppCacheSize
(
)
;
this
.
updateOfflineApps
(
)
;
}
clearSiteData
(
)
{
let
flags
=
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
*
Services
.
prompt
.
BUTTON_POS_0
+
Services
.
prompt
.
BUTTON_TITLE_CANCEL
*
Services
.
prompt
.
BUTTON_POS_1
+
Services
.
prompt
.
BUTTON_POS_0_DEFAULT
;
let
prefStrBundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
title
=
prefStrBundle
.
getString
(
"
clearSiteDataPromptTitle
"
)
;
let
text
=
prefStrBundle
.
getString
(
"
clearSiteDataPromptText
"
)
;
let
btn0Label
=
prefStrBundle
.
getString
(
"
clearSiteDataNow
"
)
;
let
result
=
Services
.
prompt
.
confirmEx
(
window
title
text
flags
btn0Label
null
null
null
{
}
)
;
if
(
result
=
=
0
)
{
SiteDataManager
.
removeAll
(
)
;
}
}
readOfflineNotify
(
)
{
var
pref
=
document
.
getElementById
(
"
browser
.
offline
-
apps
.
notify
"
)
;
var
button
=
document
.
getElementById
(
"
offlineNotifyExceptions
"
)
;
button
.
disabled
=
!
pref
.
value
;
return
pref
.
value
;
}
showOfflineExceptions
(
)
{
var
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
params
=
{
blockVisible
:
false
sessionVisible
:
false
allowVisible
:
false
prefilledHost
:
"
"
permissionType
:
"
offline
-
app
"
manageCapability
:
Components
.
interfaces
.
nsIPermissionManager
.
DENY_ACTION
windowTitle
:
bundlePreferences
.
getString
(
"
offlinepermissionstitle
"
)
introText
:
bundlePreferences
.
getString
(
"
offlinepermissionstext
"
)
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
null
params
)
;
}
_getOfflineAppUsage
(
perm
groups
)
{
let
cacheService
=
Cc
[
"
mozilla
.
org
/
network
/
application
-
cache
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationCacheService
)
;
if
(
!
groups
)
{
try
{
groups
=
cacheService
.
getGroups
(
)
;
}
catch
(
ex
)
{
return
0
;
}
}
let
usage
=
0
;
for
(
let
group
of
groups
)
{
let
uri
=
Services
.
io
.
newURI
(
group
)
;
if
(
perm
.
matchesURI
(
uri
true
)
)
{
let
cache
=
cacheService
.
getActiveCache
(
group
)
;
usage
+
=
cache
.
usage
;
}
}
return
usage
;
}
updateOfflineApps
(
)
{
var
pm
=
Components
.
classes
[
"
mozilla
.
org
/
permissionmanager
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIPermissionManager
)
;
var
list
=
document
.
getElementById
(
"
offlineAppsList
"
)
;
while
(
list
.
firstChild
)
{
list
.
firstChild
.
remove
(
)
;
}
var
groups
;
try
{
var
cacheService
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
application
-
cache
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIApplicationCacheService
)
;
groups
=
cacheService
.
getGroups
(
)
;
}
catch
(
e
)
{
return
;
}
var
bundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
enumerator
=
pm
.
enumerator
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
var
perm
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Components
.
interfaces
.
nsIPermission
)
;
if
(
perm
.
type
=
=
"
offline
-
app
"
&
&
perm
.
capability
!
=
Components
.
interfaces
.
nsIPermissionManager
.
DEFAULT_ACTION
&
&
perm
.
capability
!
=
Components
.
interfaces
.
nsIPermissionManager
.
DENY_ACTION
)
{
var
row
=
document
.
createElement
(
"
listitem
"
)
;
row
.
id
=
"
"
;
row
.
className
=
"
offlineapp
"
;
row
.
setAttribute
(
"
origin
"
perm
.
principal
.
origin
)
;
var
converted
=
DownloadUtils
.
convertByteUnits
(
this
.
_getOfflineAppUsage
(
perm
groups
)
)
;
row
.
setAttribute
(
"
usage
"
bundle
.
getFormattedString
(
"
offlineAppUsage
"
converted
)
)
;
list
.
appendChild
(
row
)
;
}
}
}
offlineAppSelected
(
)
{
var
removeButton
=
document
.
getElementById
(
"
offlineAppsListRemove
"
)
;
var
list
=
document
.
getElementById
(
"
offlineAppsList
"
)
;
if
(
list
.
selectedItem
)
{
removeButton
.
setAttribute
(
"
disabled
"
"
false
"
)
;
}
else
{
removeButton
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
removeOfflineApp
(
)
{
var
list
=
document
.
getElementById
(
"
offlineAppsList
"
)
;
var
item
=
list
.
selectedItem
;
var
origin
=
item
.
getAttribute
(
"
origin
"
)
;
var
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
origin
)
;
var
prompts
=
Components
.
classes
[
"
mozilla
.
org
/
embedcomp
/
prompt
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIPromptService
)
;
var
flags
=
prompts
.
BUTTON_TITLE_IS_STRING
*
prompts
.
BUTTON_POS_0
+
prompts
.
BUTTON_TITLE_CANCEL
*
prompts
.
BUTTON_POS_1
;
var
bundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
title
=
bundle
.
getString
(
"
offlineAppRemoveTitle
"
)
;
var
prompt
=
bundle
.
getFormattedString
(
"
offlineAppRemovePrompt
"
[
principal
.
URI
.
prePath
]
)
;
var
confirm
=
bundle
.
getString
(
"
offlineAppRemoveConfirm
"
)
;
var
result
=
prompts
.
confirmEx
(
window
title
prompt
flags
confirm
null
null
null
{
}
)
;
if
(
result
!
=
0
)
return
;
var
pm
=
Components
.
classes
[
"
mozilla
.
org
/
permissionmanager
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIPermissionManager
)
;
var
perm
=
pm
.
getPermissionObject
(
principal
"
offline
-
app
"
true
)
;
if
(
perm
)
{
try
{
var
cacheService
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
application
-
cache
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIApplicationCacheService
)
;
var
groups
=
cacheService
.
getGroups
(
)
;
for
(
var
i
=
0
;
i
<
groups
.
length
;
i
+
+
)
{
var
uri
=
Services
.
io
.
newURI
(
groups
[
i
]
)
;
if
(
perm
.
matchesURI
(
uri
true
)
)
{
var
cache
=
cacheService
.
getActiveCache
(
groups
[
i
]
)
;
cache
.
discard
(
)
;
}
}
}
catch
(
e
)
{
}
pm
.
removePermission
(
perm
)
;
}
list
.
removeChild
(
item
)
;
gAdvancedPane
.
offlineAppSelected
(
)
;
this
.
updateActualAppCacheSize
(
)
;
}
updateReadPrefs
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
)
{
var
enabledPref
=
document
.
getElementById
(
"
app
.
update
.
enabled
"
)
;
var
autoPref
=
document
.
getElementById
(
"
app
.
update
.
auto
"
)
;
var
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
if
(
!
enabledPref
.
value
)
radiogroup
.
value
=
"
manual
"
;
else
if
(
autoPref
.
value
)
radiogroup
.
value
=
"
auto
"
;
else
radiogroup
.
value
=
"
checkOnly
"
;
var
canCheck
=
Components
.
classes
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIApplicationUpdateService
)
.
canCheckForUpdates
;
radiogroup
.
disabled
=
!
canCheck
|
|
enabledPref
.
locked
|
|
autoPref
.
locked
;
if
(
AppConstants
.
MOZ_MAINTENANCE_SERVICE
)
{
var
installed
;
try
{
var
wrk
=
Components
.
classes
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIWindowsRegKey
)
;
wrk
.
open
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
"
SOFTWARE
\
\
Mozilla
\
\
MaintenanceService
"
wrk
.
ACCESS_READ
|
wrk
.
WOW64_64
)
;
installed
=
wrk
.
readIntValue
(
"
Installed
"
)
;
wrk
.
close
(
)
;
}
catch
(
e
)
{
}
if
(
installed
!
=
1
)
{
document
.
getElementById
(
"
useService
"
)
.
hidden
=
true
;
}
}
}
}
updateWritePrefs
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
)
{
var
enabledPref
=
document
.
getElementById
(
"
app
.
update
.
enabled
"
)
;
var
autoPref
=
document
.
getElementById
(
"
app
.
update
.
auto
"
)
;
var
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
switch
(
radiogroup
.
value
)
{
case
"
auto
"
:
enabledPref
.
value
=
true
;
autoPref
.
value
=
true
;
break
;
case
"
checkOnly
"
:
enabledPref
.
value
=
true
;
autoPref
.
value
=
false
;
break
;
case
"
manual
"
:
enabledPref
.
value
=
false
;
autoPref
.
value
=
false
;
}
}
}
showUpdates
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
update
/
history
.
xul
"
)
;
}
showCertificates
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
pippki
/
content
/
certManager
.
xul
"
)
;
}
showSecurityDevices
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
pippki
/
content
/
device_manager
.
xul
"
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
AppConstants
.
MOZ_UPDATER
)
{
switch
(
aTopic
)
{
case
"
nsPref
:
changed
"
:
this
.
updateReadPrefs
(
)
;
break
;
case
"
sitedatamanager
:
sites
-
updated
"
:
this
.
updateTotalSiteDataSize
(
)
;
break
;
}
}
}
}
;
