ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
this
)
;
const
kDefaultWait
=
2000
;
function
is_element_visible
(
aElement
aMsg
)
{
isnot
(
aElement
null
"
Element
should
not
be
null
when
checking
visibility
"
)
;
ok
(
!
BrowserTestUtils
.
is_hidden
(
aElement
)
aMsg
)
;
}
function
is_element_hidden
(
aElement
aMsg
)
{
isnot
(
aElement
null
"
Element
should
not
be
null
when
checking
visibility
"
)
;
ok
(
BrowserTestUtils
.
is_hidden
(
aElement
)
aMsg
)
;
}
function
open_preferences
(
aCallback
)
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
preferences
"
)
;
let
newTabBrowser
=
gBrowser
.
getBrowserForTab
(
gBrowser
.
selectedTab
)
;
newTabBrowser
.
addEventListener
(
"
Initialized
"
function
(
)
{
aCallback
(
gBrowser
.
contentWindow
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
function
openAndLoadSubDialog
(
aURL
aFeatures
=
null
aParams
=
null
aClosingCallback
=
null
)
{
let
promise
=
promiseLoadSubDialog
(
aURL
)
;
content
.
gSubDialog
.
open
(
aURL
aFeatures
aParams
aClosingCallback
)
;
return
promise
;
}
function
promiseLoadSubDialog
(
aURL
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
content
.
gSubDialog
.
_dialogStack
.
addEventListener
(
"
dialogopen
"
function
dialogopen
(
aEvent
)
{
if
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
.
location
=
=
"
about
:
blank
"
)
{
return
;
}
content
.
gSubDialog
.
_dialogStack
.
removeEventListener
(
"
dialogopen
"
dialogopen
)
;
is
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
.
location
.
toString
(
)
aURL
"
Check
the
proper
URL
is
loaded
"
)
;
is_element_visible
(
aEvent
.
detail
.
dialog
.
_overlay
"
Overlay
is
visible
"
)
;
let
expectedStyleSheetURLs
=
aEvent
.
detail
.
dialog
.
_injectedStyleSheets
.
slice
(
0
)
;
for
(
let
styleSheet
of
aEvent
.
detail
.
dialog
.
_frame
.
contentDocument
.
styleSheets
)
{
let
i
=
expectedStyleSheetURLs
.
indexOf
(
styleSheet
.
href
)
;
if
(
i
>
=
0
)
{
info
(
"
found
"
+
styleSheet
.
href
)
;
expectedStyleSheetURLs
.
splice
(
i
1
)
;
}
}
is
(
expectedStyleSheetURLs
.
length
0
"
All
expectedStyleSheetURLs
should
have
been
found
"
)
;
executeSoon
(
(
)
=
>
resolve
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
)
)
;
}
)
;
}
)
;
}
function
waitForEvent
(
aSubject
aEventName
aTimeoutMs
aTarget
)
{
let
eventDeferred
=
Promise
.
defer
(
)
;
let
timeoutMs
=
aTimeoutMs
|
|
kDefaultWait
;
let
stack
=
new
Error
(
)
.
stack
;
let
timerID
=
setTimeout
(
function
wfe_canceller
(
)
{
aSubject
.
removeEventListener
(
aEventName
listener
)
;
eventDeferred
.
reject
(
new
Error
(
aEventName
+
"
event
timeout
at
"
+
stack
)
)
;
}
timeoutMs
)
;
var
listener
=
function
(
aEvent
)
{
if
(
aTarget
&
&
aTarget
!
=
=
aEvent
.
target
)
{
return
;
}
clearTimeout
(
timerID
)
;
eventDeferred
.
resolve
(
aEvent
)
;
}
;
function
cleanup
(
aEventOrError
)
{
aSubject
.
removeEventListener
(
aEventName
listener
)
;
return
aEventOrError
;
}
aSubject
.
addEventListener
(
aEventName
listener
)
;
return
eventDeferred
.
promise
.
then
(
cleanup
cleanup
)
;
}
function
openPreferencesViaOpenPreferencesAPI
(
aPane
aOptions
)
{
return
new
Promise
(
resolve
=
>
{
let
finalPaneEvent
=
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
enabled
"
)
?
"
sync
-
pane
-
loaded
"
:
"
privacy
-
pane
-
loaded
"
;
let
finalPrefPaneLoaded
=
TestUtils
.
topicObserved
(
finalPaneEvent
(
)
=
>
true
)
;
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
)
;
openPreferences
(
aPane
)
;
let
newTabBrowser
=
gBrowser
.
selectedBrowser
;
newTabBrowser
.
addEventListener
(
"
Initialized
"
function
(
)
{
newTabBrowser
.
contentWindow
.
addEventListener
(
"
load
"
async
function
(
)
{
let
win
=
gBrowser
.
contentWindow
;
let
selectedPane
=
win
.
history
.
state
;
await
finalPrefPaneLoaded
;
if
(
!
aOptions
|
|
!
aOptions
.
leaveOpen
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
resolve
(
{
selectedPane
}
)
;
}
{
once
:
true
}
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
)
;
}
async
function
evaluateSearchResults
(
keyword
searchReults
)
{
searchReults
=
Array
.
isArray
(
searchReults
)
?
searchReults
:
[
searchReults
]
;
searchReults
.
push
(
"
header
-
searchResults
"
)
;
let
searchInput
=
gBrowser
.
contentDocument
.
getElementById
(
"
searchInput
"
)
;
searchInput
.
focus
(
)
;
let
searchCompletedPromise
=
BrowserTestUtils
.
waitForEvent
(
gBrowser
.
contentWindow
"
PreferencesSearchCompleted
"
evt
=
>
evt
.
detail
=
=
keyword
)
;
EventUtils
.
sendString
(
keyword
)
;
await
searchCompletedPromise
;
let
mainPrefTag
=
gBrowser
.
contentDocument
.
getElementById
(
"
mainPrefPane
"
)
;
for
(
let
i
=
0
;
i
<
mainPrefTag
.
childElementCount
;
i
+
+
)
{
let
child
=
mainPrefTag
.
children
[
i
]
;
if
(
searchReults
.
includes
(
child
.
id
)
)
{
is_element_visible
(
child
{
child
.
id
}
should
be
in
search
results
)
;
}
else
if
(
child
.
id
)
{
is_element_hidden
(
child
{
child
.
id
}
should
not
be
in
search
results
)
;
}
}
}
function
waitForMutation
(
target
opts
cb
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
new
MutationObserver
(
(
)
=
>
{
if
(
!
cb
|
|
cb
(
target
)
)
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
}
)
;
observer
.
observe
(
target
opts
)
;
}
)
;
}
