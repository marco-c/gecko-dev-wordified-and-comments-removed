"
use
strict
"
;
var
{
SitePermissions
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
SitePermissions
.
jsm
"
)
;
async
function
testClearData
(
clearSiteData
clearCache
)
{
let
quotaURI
=
Services
.
io
.
newURI
(
TEST_QUOTA_USAGE_ORIGIN
)
;
SitePermissions
.
set
(
quotaURI
"
persistent
-
storage
"
SitePermissions
.
ALLOW
)
;
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_OFFLINE_URL
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_QUOTA_USAGE_URL
false
)
;
await
BrowserTestUtils
.
waitForContentEvent
(
gBrowser
.
selectedBrowser
"
test
-
indexedDB
-
done
"
false
null
true
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
await
loadServiceWorkerTestPage
(
TEST_SERVICE_WORKER_URL
)
;
await
promiseServiceWorkerRegisteredFor
(
TEST_SERVICE_WORKER_URL
)
;
await
openPreferencesViaOpenPreferencesAPI
(
"
privacy
"
{
leaveOpen
:
true
}
)
;
let
cacheUsage
=
await
SiteDataManager
.
getCacheSize
(
)
;
let
quotaUsage
=
await
SiteDataTestUtils
.
getQuotaUsage
(
TEST_QUOTA_USAGE_ORIGIN
)
;
let
totalUsage
=
await
SiteDataManager
.
getTotalUsage
(
)
;
Assert
.
greater
(
cacheUsage
0
"
The
cache
usage
should
not
be
0
"
)
;
Assert
.
greater
(
quotaUsage
0
"
The
quota
usage
should
not
be
0
"
)
;
Assert
.
greater
(
totalUsage
0
"
The
total
usage
should
not
be
0
"
)
;
let
initialSizeLabelValue
=
await
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
async
function
(
)
{
let
sizeLabel
=
content
.
document
.
getElementById
(
"
totalSiteDataSize
"
)
;
return
sizeLabel
.
textContent
;
}
)
;
let
doc
=
gBrowser
.
selectedBrowser
.
contentDocument
;
let
clearSiteDataButton
=
doc
.
getElementById
(
"
clearSiteDataButton
"
)
;
let
dialogOpened
=
promiseLoadSubDialog
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
clearSiteData
.
xul
"
)
;
clearSiteDataButton
.
doCommand
(
)
;
let
dialogWin
=
await
dialogOpened
;
let
[
convertedTotalUsage
]
=
DownloadUtils
.
convertByteUnits
(
totalUsage
)
;
let
[
convertedCacheUnit
]
=
DownloadUtils
.
convertByteUnits
(
cacheUsage
)
;
let
clearSiteDataCheckbox
=
dialogWin
.
document
.
getElementById
(
"
clearSiteData
"
)
;
let
clearCacheCheckbox
=
dialogWin
.
document
.
getElementById
(
"
clearCache
"
)
;
await
Promise
.
all
(
[
TestUtils
.
waitForCondition
(
(
)
=
>
clearSiteDataCheckbox
.
label
&
&
clearSiteDataCheckbox
.
label
.
includes
(
convertedTotalUsage
)
"
Should
show
the
quota
usage
"
)
TestUtils
.
waitForCondition
(
(
)
=
>
clearCacheCheckbox
.
label
&
&
clearCacheCheckbox
.
label
.
includes
(
convertedCacheUnit
)
"
Should
show
the
cache
usage
"
)
]
)
;
clearSiteDataCheckbox
.
checked
=
clearSiteData
;
clearCacheCheckbox
.
checked
=
clearCache
;
let
acceptPromise
;
let
updatePromise
;
let
cookiesClearedPromise
;
if
(
clearSiteData
)
{
acceptPromise
=
BrowserTestUtils
.
promiseAlertDialogOpen
(
"
accept
"
)
;
updatePromise
=
promiseSiteDataManagerSitesUpdated
(
)
;
cookiesClearedPromise
=
promiseCookiesCleared
(
)
;
}
let
dialogClosed
=
BrowserTestUtils
.
waitForEvent
(
dialogWin
"
unload
"
)
;
let
clearButton
=
dialogWin
.
document
.
getElementById
(
"
clearButton
"
)
;
if
(
!
clearSiteData
&
&
!
clearCache
)
{
clearCacheCheckbox
.
doCommand
(
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
clearButton
.
disabled
"
Clear
button
should
be
disabled
"
)
;
let
cancelButton
=
dialogWin
.
document
.
getElementById
(
"
cancelButton
"
)
;
cancelButton
.
click
(
)
;
}
else
{
clearButton
.
click
(
)
;
}
if
(
clearSiteData
)
{
await
acceptPromise
;
}
await
dialogClosed
;
if
(
clearCache
)
{
TestUtils
.
waitForCondition
(
async
function
(
)
{
let
usage
=
await
SiteDataManager
.
getCacheSize
(
)
;
return
usage
=
=
0
;
}
"
The
cache
usage
should
be
removed
"
)
;
}
else
{
Assert
.
greater
(
await
SiteDataManager
.
getCacheSize
(
)
0
"
The
cache
usage
should
not
be
0
"
)
;
}
if
(
clearSiteData
)
{
await
updatePromise
;
await
cookiesClearedPromise
;
await
promiseServiceWorkersCleared
(
)
;
TestUtils
.
waitForCondition
(
async
function
(
)
{
let
usage
=
await
SiteDataManager
.
getTotalUsage
(
)
;
return
usage
=
=
0
;
}
"
The
total
usage
should
be
removed
"
)
;
}
else
{
quotaUsage
=
await
SiteDataTestUtils
.
getQuotaUsage
(
TEST_QUOTA_USAGE_ORIGIN
)
;
totalUsage
=
await
SiteDataManager
.
getTotalUsage
(
)
;
Assert
.
greater
(
quotaUsage
0
"
The
quota
usage
should
not
be
0
"
)
;
Assert
.
greater
(
totalUsage
0
"
The
total
usage
should
not
be
0
"
)
;
}
if
(
clearCache
|
|
clearSiteData
)
{
await
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
initialSizeLabelValue
}
async
function
(
opts
)
{
let
sizeLabel
=
content
.
document
.
getElementById
(
"
totalSiteDataSize
"
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
sizeLabel
.
textContent
!
=
opts
.
initialSizeLabelValue
"
Site
data
size
label
should
have
updated
.
"
)
;
}
)
;
}
let
desiredPermissionState
=
clearSiteData
?
SitePermissions
.
UNKNOWN
:
SitePermissions
.
ALLOW
;
let
permission
=
SitePermissions
.
get
(
quotaURI
"
persistent
-
storage
"
)
;
is
(
permission
.
state
desiredPermissionState
"
Should
have
the
correct
permission
state
.
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
await
SiteDataManager
.
removeAll
(
)
;
}
add_task
(
async
function
(
)
{
await
testClearData
(
false
false
)
;
}
)
;
add_task
(
async
function
(
)
{
await
testClearData
(
true
false
)
;
}
)
;
add_task
(
async
function
(
)
{
await
testClearData
(
false
true
)
;
}
)
;
add_task
(
async
function
(
)
{
await
testClearData
(
true
true
)
;
}
)
;
