"
use
strict
"
;
function
SubDialog
(
{
template
parentElement
id
}
)
{
this
.
_id
=
id
;
this
.
_overlay
=
template
.
cloneNode
(
true
)
;
this
.
_frame
=
this
.
_overlay
.
querySelector
(
"
.
dialogFrame
"
)
;
this
.
_box
=
this
.
_overlay
.
querySelector
(
"
.
dialogBox
"
)
;
this
.
_closeButton
=
this
.
_overlay
.
querySelector
(
"
.
dialogClose
"
)
;
this
.
_titleElement
=
this
.
_overlay
.
querySelector
(
"
.
dialogTitle
"
)
;
this
.
_overlay
.
id
=
dialogOverlay
-
{
id
}
;
this
.
_frame
.
setAttribute
(
"
name
"
dialogFrame
-
{
id
}
)
;
this
.
_frameCreated
=
new
Promise
(
resolve
=
>
{
this
.
_frame
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
}
)
;
parentElement
.
appendChild
(
this
.
_overlay
)
;
this
.
_overlay
.
hidden
=
false
;
}
SubDialog
.
prototype
=
{
_closingCallback
:
null
_closingEvent
:
null
_isClosing
:
false
_frame
:
null
_frameCreated
:
null
_overlay
:
null
_box
:
null
_openedURL
:
null
_injectedStyleSheets
:
[
"
chrome
:
/
/
browser
/
skin
/
preferences
/
preferences
.
css
"
"
chrome
:
/
/
global
/
skin
/
in
-
content
/
common
.
css
"
"
chrome
:
/
/
browser
/
skin
/
preferences
/
in
-
content
/
preferences
.
css
"
"
chrome
:
/
/
browser
/
skin
/
preferences
/
in
-
content
/
dialog
.
css
"
]
_resizeObserver
:
null
_template
:
null
_id
:
null
_titleElement
:
null
_closeButton
:
null
updateTitle
(
aEvent
)
{
if
(
aEvent
.
target
!
=
this
.
_frame
.
contentDocument
)
return
;
this
.
_titleElement
.
textContent
=
this
.
_frame
.
contentDocument
.
title
;
}
injectXMLStylesheet
(
aStylesheetURL
)
{
let
contentStylesheet
=
this
.
_frame
.
contentDocument
.
createProcessingInstruction
(
"
xml
-
stylesheet
"
'
href
=
"
'
+
aStylesheetURL
+
'
"
type
=
"
text
/
css
"
'
)
;
this
.
_frame
.
contentDocument
.
insertBefore
(
contentStylesheet
this
.
_frame
.
contentDocument
.
documentElement
)
;
}
async
open
(
aURL
aFeatures
=
null
aParams
=
null
aClosingCallback
=
null
)
{
await
this
.
_frameCreated
;
if
(
this
.
_openedURL
|
|
this
.
_isClosing
)
{
if
(
!
this
.
_isClosing
)
{
this
.
close
(
)
;
}
let
args
=
Array
.
from
(
arguments
)
;
this
.
_closingPromise
.
then
(
(
)
=
>
{
this
.
open
.
apply
(
this
args
)
;
}
)
;
return
;
}
this
.
_addDialogEventListeners
(
)
;
let
features
=
(
aFeatures
?
aFeatures
+
"
"
:
"
"
)
+
"
resizable
dialog
=
no
centerscreen
"
;
let
dialog
=
window
.
openDialog
(
aURL
dialogFrame
-
{
this
.
_id
}
features
aParams
)
;
if
(
aClosingCallback
)
{
this
.
_closingCallback
=
aClosingCallback
.
bind
(
dialog
)
;
}
this
.
_closingEvent
=
null
;
this
.
_isClosing
=
false
;
this
.
_openedURL
=
aURL
;
features
=
features
.
replace
(
/
/
g
"
&
"
)
;
let
featureParams
=
new
URLSearchParams
(
features
.
toLowerCase
(
)
)
;
this
.
_box
.
setAttribute
(
"
resizable
"
featureParams
.
has
(
"
resizable
"
)
&
&
featureParams
.
get
(
"
resizable
"
)
!
=
"
no
"
&
&
featureParams
.
get
(
"
resizable
"
)
!
=
"
0
"
)
;
}
close
(
aEvent
=
null
)
{
if
(
this
.
_isClosing
)
{
return
;
}
this
.
_isClosing
=
true
;
this
.
_closingPromise
=
new
Promise
(
resolve
=
>
{
this
.
_resolveClosePromise
=
resolve
;
}
)
;
if
(
this
.
_closingCallback
)
{
try
{
this
.
_closingCallback
.
call
(
null
aEvent
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
this
.
_closingCallback
=
null
;
}
this
.
_removeDialogEventListeners
(
)
;
this
.
_overlay
.
style
.
visibility
=
"
"
;
this
.
_frame
.
removeAttribute
(
"
style
"
)
;
this
.
_box
.
removeAttribute
(
"
width
"
)
;
this
.
_box
.
removeAttribute
(
"
height
"
)
;
this
.
_box
.
style
.
removeProperty
(
"
min
-
height
"
)
;
this
.
_box
.
style
.
removeProperty
(
"
min
-
width
"
)
;
this
.
_overlay
.
dispatchEvent
(
new
CustomEvent
(
"
dialogclose
"
{
bubbles
:
true
detail
:
{
dialog
:
this
}
}
)
)
;
setTimeout
(
(
)
=
>
{
let
onBlankLoad
=
e
=
>
{
if
(
this
.
_frame
.
contentWindow
.
location
.
href
=
=
"
about
:
blank
"
)
{
this
.
_frame
.
removeEventListener
(
"
load
"
onBlankLoad
)
;
this
.
_openedURL
=
null
;
this
.
_isClosing
=
false
;
this
.
_resolveClosePromise
(
)
;
}
}
;
this
.
_frame
.
addEventListener
(
"
load
"
onBlankLoad
)
;
this
.
_frame
.
loadURI
(
"
about
:
blank
"
)
;
}
0
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
click
"
:
if
(
aEvent
.
target
=
=
=
this
.
_overlay
)
{
this
.
_frame
.
contentWindow
.
close
(
)
;
}
break
;
case
"
command
"
:
this
.
_frame
.
contentWindow
.
close
(
)
;
break
;
case
"
dialogclosing
"
:
this
.
_onDialogClosing
(
aEvent
)
;
break
;
case
"
DOMTitleChanged
"
:
this
.
updateTitle
(
aEvent
)
;
break
;
case
"
DOMFrameContentLoaded
"
:
this
.
_onContentLoaded
(
aEvent
)
;
break
;
case
"
load
"
:
this
.
_onLoad
(
aEvent
)
;
break
;
case
"
unload
"
:
this
.
_onUnload
(
aEvent
)
;
break
;
case
"
keydown
"
:
this
.
_onKeyDown
(
aEvent
)
;
break
;
case
"
focus
"
:
this
.
_onParentWinFocus
(
aEvent
)
;
break
;
}
}
_onUnload
(
aEvent
)
{
if
(
aEvent
.
target
.
location
.
href
=
=
this
.
_openedURL
)
{
this
.
_frame
.
contentWindow
.
close
(
)
;
}
}
_onContentLoaded
(
aEvent
)
{
if
(
aEvent
.
target
!
=
this
.
_frame
|
|
aEvent
.
target
.
contentWindow
.
location
=
=
"
about
:
blank
"
)
{
return
;
}
for
(
let
styleSheetURL
of
this
.
_injectedStyleSheets
)
{
this
.
injectXMLStylesheet
(
styleSheetURL
)
;
}
this
.
_frame
.
contentDocument
.
documentElement
.
setAttribute
(
"
subdialog
"
"
true
"
)
;
this
.
_frame
.
contentWindow
.
addEventListener
(
"
dialogclosing
"
this
)
;
let
oldResizeBy
=
this
.
_frame
.
contentWindow
.
resizeBy
;
this
.
_frame
.
contentWindow
.
resizeBy
=
(
resizeByWidth
resizeByHeight
)
=
>
{
let
frameHeight
=
this
.
_frame
.
clientHeight
;
let
boxMinHeight
=
parseFloat
(
getComputedStyle
(
this
.
_box
)
.
minHeight
10
)
;
this
.
_frame
.
style
.
height
=
(
frameHeight
+
resizeByHeight
)
+
"
px
"
;
this
.
_box
.
style
.
minHeight
=
(
boxMinHeight
+
resizeByHeight
)
+
"
px
"
;
oldResizeBy
.
call
(
this
.
_frame
.
contentWindow
resizeByWidth
resizeByHeight
)
;
}
;
let
oldClose
=
this
.
_frame
.
contentWindow
.
close
;
this
.
_frame
.
contentWindow
.
close
=
(
)
=
>
{
var
closingEvent
=
this
.
_closingEvent
;
if
(
!
closingEvent
)
{
closingEvent
=
new
CustomEvent
(
"
dialogclosing
"
{
bubbles
:
true
detail
:
{
button
:
null
}
}
)
;
this
.
_frame
.
contentWindow
.
dispatchEvent
(
closingEvent
)
;
}
this
.
close
(
closingEvent
)
;
oldClose
.
call
(
this
.
_frame
.
contentWindow
)
;
}
;
this
.
_overlay
.
style
.
visibility
=
"
visible
"
;
this
.
_overlay
.
style
.
opacity
=
"
0
.
01
"
;
}
_onLoad
(
aEvent
)
{
if
(
aEvent
.
target
.
contentWindow
.
location
=
=
"
about
:
blank
"
)
{
return
;
}
let
docEl
=
this
.
_frame
.
contentDocument
.
documentElement
;
let
groupBoxTitle
=
document
.
getAnonymousElementByAttribute
(
this
.
_box
"
class
"
"
groupbox
-
title
"
)
;
let
groupBoxTitleHeight
=
groupBoxTitle
.
clientHeight
+
parseFloat
(
getComputedStyle
(
groupBoxTitle
)
.
borderBottomWidth
)
;
let
groupBoxBody
=
document
.
getAnonymousElementByAttribute
(
this
.
_box
"
class
"
"
groupbox
-
body
"
)
;
let
boxVerticalPadding
=
2
*
parseFloat
(
getComputedStyle
(
groupBoxBody
)
.
paddingTop
)
;
let
boxHorizontalPadding
=
2
*
parseFloat
(
getComputedStyle
(
groupBoxBody
)
.
paddingLeft
)
;
let
boxHorizontalBorder
=
2
*
parseFloat
(
getComputedStyle
(
this
.
_box
)
.
borderLeftWidth
)
;
let
boxVerticalBorder
=
2
*
parseFloat
(
getComputedStyle
(
this
.
_box
)
.
borderTopWidth
)
;
let
boxRect
=
this
.
_box
.
getBoundingClientRect
(
)
;
let
frameRect
=
this
.
_frame
.
getBoundingClientRect
(
)
;
let
frameSizeDifference
=
(
frameRect
.
top
-
boxRect
.
top
)
+
(
boxRect
.
bottom
-
frameRect
.
bottom
)
;
let
frameMinWidth
=
docEl
.
style
.
width
|
|
docEl
.
scrollWidth
+
"
px
"
;
let
frameWidth
=
docEl
.
getAttribute
(
"
width
"
)
?
docEl
.
getAttribute
(
"
width
"
)
+
"
px
"
:
frameMinWidth
;
this
.
_frame
.
style
.
width
=
frameWidth
;
this
.
_box
.
style
.
minWidth
=
"
calc
(
"
+
(
boxHorizontalBorder
+
boxHorizontalPadding
)
+
"
px
+
"
+
frameMinWidth
+
"
)
"
;
let
frameMinHeight
=
docEl
.
style
.
height
|
|
docEl
.
scrollHeight
+
"
px
"
;
let
frameHeight
=
docEl
.
getAttribute
(
"
height
"
)
?
docEl
.
getAttribute
(
"
height
"
)
+
"
px
"
:
frameMinHeight
;
let
maxHeight
=
window
.
innerHeight
-
frameSizeDifference
-
30
;
let
comparisonFrameHeight
;
if
(
frameHeight
.
endsWith
(
"
em
"
)
)
{
let
fontSize
=
parseFloat
(
getComputedStyle
(
this
.
_frame
)
.
fontSize
)
;
comparisonFrameHeight
=
parseFloat
(
frameHeight
10
)
*
fontSize
;
}
else
if
(
frameHeight
.
endsWith
(
"
px
"
)
)
{
comparisonFrameHeight
=
parseFloat
(
frameHeight
10
)
;
}
else
{
Cu
.
reportError
(
"
This
dialog
(
"
+
this
.
_frame
.
contentWindow
.
location
.
href
+
"
)
"
+
"
set
a
height
in
non
-
px
-
non
-
em
units
(
'
"
+
frameHeight
+
"
'
)
"
+
"
which
is
likely
to
lead
to
bad
sizing
in
in
-
content
preferences
.
"
+
"
Please
consider
changing
this
.
"
)
;
comparisonFrameHeight
=
parseFloat
(
frameHeight
)
;
}
if
(
comparisonFrameHeight
>
maxHeight
)
{
frameHeight
=
maxHeight
+
"
px
"
;
frameMinHeight
=
maxHeight
+
"
px
"
;
let
containers
=
this
.
_frame
.
contentDocument
.
querySelectorAll
(
"
.
largeDialogContainer
"
)
;
for
(
let
container
of
containers
)
{
container
.
classList
.
add
(
"
doScroll
"
)
;
}
}
this
.
_frame
.
style
.
height
=
frameHeight
;
this
.
_box
.
style
.
minHeight
=
"
calc
(
"
+
(
boxVerticalBorder
+
groupBoxTitleHeight
+
boxVerticalPadding
)
+
"
px
+
"
+
frameMinHeight
+
"
)
"
;
this
.
_overlay
.
dispatchEvent
(
new
CustomEvent
(
"
dialogopen
"
{
bubbles
:
true
detail
:
{
dialog
:
this
}
}
)
)
;
this
.
_overlay
.
style
.
visibility
=
"
visible
"
;
this
.
_overlay
.
style
.
opacity
=
"
"
;
if
(
this
.
_box
.
getAttribute
(
"
resizable
"
)
=
=
"
true
"
)
{
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
this
.
_resizeObserver
=
new
MutationObserver
(
this
.
_onResize
)
;
this
.
_resizeObserver
.
observe
(
this
.
_box
{
attributes
:
true
}
)
;
}
this
.
_trapFocus
(
)
;
gSearchResultsPane
.
searchWithinNode
(
this
.
_titleElement
gSearchResultsPane
.
query
)
;
gSearchResultsPane
.
searchWithinNode
(
this
.
_frame
.
contentDocument
.
firstElementChild
gSearchResultsPane
.
query
)
;
for
(
let
node
of
gSearchResultsPane
.
listSearchTooltips
)
{
if
(
!
node
.
tooltipNode
)
{
gSearchResultsPane
.
createSearchTooltip
(
node
gSearchResultsPane
.
query
)
;
}
}
}
_onResize
(
mutations
)
{
let
frame
=
this
.
_frame
;
frame
.
style
.
removeProperty
(
"
width
"
)
;
frame
.
style
.
removeProperty
(
"
height
"
)
;
let
docEl
=
frame
.
contentDocument
.
documentElement
;
let
persistedAttributes
=
docEl
.
getAttribute
(
"
persist
"
)
;
if
(
!
persistedAttributes
|
|
(
!
persistedAttributes
.
includes
(
"
width
"
)
&
&
!
persistedAttributes
.
includes
(
"
height
"
)
)
)
{
return
;
}
for
(
let
mutation
of
mutations
)
{
if
(
mutation
.
attributeName
=
=
"
width
"
)
{
docEl
.
setAttribute
(
"
width
"
docEl
.
scrollWidth
)
;
}
else
if
(
mutation
.
attributeName
=
=
"
height
"
)
{
docEl
.
setAttribute
(
"
height
"
docEl
.
scrollHeight
)
;
}
}
}
_onDialogClosing
(
aEvent
)
{
this
.
_frame
.
contentWindow
.
removeEventListener
(
"
dialogclosing
"
this
)
;
this
.
_closingEvent
=
aEvent
;
}
_onKeyDown
(
aEvent
)
{
if
(
aEvent
.
currentTarget
=
=
window
&
&
aEvent
.
keyCode
=
=
aEvent
.
DOM_VK_ESCAPE
&
&
!
aEvent
.
defaultPrevented
)
{
this
.
close
(
aEvent
)
;
return
;
}
if
(
aEvent
.
keyCode
!
=
aEvent
.
DOM_VK_TAB
|
|
aEvent
.
ctrlKey
|
|
aEvent
.
altKey
|
|
aEvent
.
metaKey
)
{
return
;
}
let
fm
=
Services
.
focus
;
let
isLastFocusableElement
=
el
=
>
{
let
rv
=
el
=
=
fm
.
moveFocus
(
this
.
_frame
.
contentWindow
null
fm
.
MOVEFOCUS_LAST
0
)
;
fm
.
setFocus
(
el
0
)
;
return
rv
;
}
;
let
forward
=
!
aEvent
.
shiftKey
;
if
(
(
aEvent
.
target
=
=
this
.
_closeButton
&
&
!
forward
)
|
|
(
isLastFocusableElement
(
aEvent
.
originalTarget
)
&
&
forward
)
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopImmediatePropagation
(
)
;
let
parentWin
=
this
.
_getBrowser
(
)
.
ownerGlobal
;
if
(
forward
)
{
fm
.
moveFocus
(
parentWin
null
fm
.
MOVEFOCUS_FIRST
fm
.
FLAG_BYKEY
)
;
}
else
{
fm
.
moveFocus
(
window
null
fm
.
MOVEFOCUS_ROOT
fm
.
FLAG_BYKEY
)
;
fm
.
moveFocus
(
parentWin
null
fm
.
MOVEFOCUS_BACKWARD
fm
.
FLAG_BYKEY
)
;
}
}
}
_onParentWinFocus
(
aEvent
)
{
if
(
aEvent
.
target
!
=
this
.
_closeButton
&
&
aEvent
.
target
!
=
window
)
{
this
.
_closeButton
.
focus
(
)
;
}
}
_addDialogEventListeners
(
)
{
this
.
_closeButton
.
addEventListener
(
"
command
"
this
)
;
let
chromeBrowser
=
this
.
_getBrowser
(
)
;
chromeBrowser
.
addEventListener
(
"
DOMTitleChanged
"
this
true
)
;
window
.
addEventListener
(
"
DOMFrameContentLoaded
"
this
true
)
;
this
.
_frame
.
addEventListener
(
"
load
"
this
)
;
chromeBrowser
.
addEventListener
(
"
unload
"
this
true
)
;
window
.
addEventListener
(
"
keydown
"
this
true
)
;
this
.
_overlay
.
addEventListener
(
"
click
"
this
true
)
;
}
_removeDialogEventListeners
(
)
{
let
chromeBrowser
=
this
.
_getBrowser
(
)
;
chromeBrowser
.
removeEventListener
(
"
DOMTitleChanged
"
this
true
)
;
chromeBrowser
.
removeEventListener
(
"
unload
"
this
true
)
;
this
.
_closeButton
.
removeEventListener
(
"
command
"
this
)
;
window
.
removeEventListener
(
"
DOMFrameContentLoaded
"
this
true
)
;
this
.
_frame
.
removeEventListener
(
"
load
"
this
)
;
this
.
_frame
.
contentWindow
.
removeEventListener
(
"
dialogclosing
"
this
)
;
window
.
removeEventListener
(
"
keydown
"
this
true
)
;
this
.
_overlay
.
removeEventListener
(
"
click
"
this
true
)
;
if
(
this
.
_resizeObserver
)
{
this
.
_resizeObserver
.
disconnect
(
)
;
this
.
_resizeObserver
=
null
;
}
this
.
_untrapFocus
(
)
;
}
_trapFocus
(
)
{
let
fm
=
Services
.
focus
;
fm
.
moveFocus
(
this
.
_frame
.
contentWindow
null
fm
.
MOVEFOCUS_FIRST
0
)
;
this
.
_frame
.
contentDocument
.
addEventListener
(
"
keydown
"
this
true
)
;
this
.
_closeButton
.
addEventListener
(
"
keydown
"
this
)
;
window
.
addEventListener
(
"
focus
"
this
true
)
;
}
_untrapFocus
(
)
{
this
.
_frame
.
contentDocument
.
removeEventListener
(
"
keydown
"
this
true
)
;
this
.
_closeButton
.
removeEventListener
(
"
keydown
"
this
)
;
window
.
removeEventListener
(
"
focus
"
this
)
;
}
_getBrowser
(
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
;
}
}
;
var
gSubDialog
=
{
_dialogs
:
[
]
_dialogStack
:
null
_dialogTemplate
:
null
_nextDialogID
:
0
_preloadDialog
:
null
get
_topDialog
(
)
{
return
this
.
_dialogs
.
length
>
0
?
this
.
_dialogs
[
this
.
_dialogs
.
length
-
1
]
:
undefined
;
}
init
(
)
{
this
.
_dialogStack
=
document
.
getElementById
(
"
dialogStack
"
)
;
this
.
_dialogTemplate
=
document
.
getElementById
(
"
dialogTemplate
"
)
;
this
.
_preloadDialog
=
new
SubDialog
(
{
template
:
this
.
_dialogTemplate
parentElement
:
this
.
_dialogStack
id
:
this
.
_nextDialogID
+
+
}
)
;
}
open
(
aURL
aFeatures
=
null
aParams
=
null
aClosingCallback
=
null
)
{
if
(
this
.
_topDialog
&
&
this
.
_topDialog
.
_openedURL
=
=
aURL
)
{
return
;
}
this
.
_preloadDialog
.
open
(
aURL
aFeatures
aParams
aClosingCallback
)
;
this
.
_dialogs
.
push
(
this
.
_preloadDialog
)
;
this
.
_preloadDialog
=
new
SubDialog
(
{
template
:
this
.
_dialogTemplate
parentElement
:
this
.
_dialogStack
id
:
this
.
_nextDialogID
+
+
}
)
;
if
(
this
.
_dialogs
.
length
=
=
1
)
{
this
.
_dialogStack
.
hidden
=
false
;
this
.
_ensureStackEventListeners
(
)
;
}
}
close
(
)
{
this
.
_topDialog
.
close
(
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
dialogopen
"
:
{
this
.
_onDialogOpen
(
)
;
break
;
}
case
"
dialogclose
"
:
{
this
.
_onDialogClose
(
aEvent
.
detail
.
dialog
)
;
break
;
}
}
}
_onDialogOpen
(
)
{
let
lowerDialog
=
this
.
_dialogs
.
length
>
1
?
this
.
_dialogs
[
this
.
_dialogs
.
length
-
2
]
:
undefined
;
if
(
lowerDialog
)
{
lowerDialog
.
_overlay
.
removeAttribute
(
"
topmost
"
)
;
lowerDialog
.
_removeDialogEventListeners
(
)
;
}
}
_onDialogClose
(
dialog
)
{
let
fm
=
Services
.
focus
;
if
(
this
.
_topDialog
=
=
dialog
)
{
this
.
_preloadDialog
.
_overlay
.
remove
(
)
;
this
.
_preloadDialog
=
this
.
_dialogs
.
pop
(
)
;
}
else
{
dialog
.
_overlay
.
remove
(
)
;
this
.
_dialogs
.
splice
(
this
.
_dialogs
.
indexOf
(
dialog
)
1
)
;
}
if
(
this
.
_topDialog
)
{
fm
.
moveFocus
(
this
.
_topDialog
.
_frame
.
contentWindow
null
fm
.
MOVEFOCUS_FIRST
fm
.
FLAG_BYKEY
)
;
this
.
_topDialog
.
_overlay
.
setAttribute
(
"
topmost
"
true
)
;
this
.
_topDialog
.
_addDialogEventListeners
(
)
;
}
else
{
fm
.
moveFocus
(
window
null
fm
.
MOVEFOCUS_ROOT
fm
.
FLAG_BYKEY
)
;
this
.
_dialogStack
.
hidden
=
true
;
this
.
_removeStackEventListeners
(
)
;
}
}
_ensureStackEventListeners
(
)
{
this
.
_dialogStack
.
addEventListener
(
"
dialogopen
"
this
)
;
this
.
_dialogStack
.
addEventListener
(
"
dialogclose
"
this
)
;
}
_removeStackEventListeners
(
)
{
this
.
_dialogStack
.
removeEventListener
(
"
dialogopen
"
this
)
;
this
.
_dialogStack
.
removeEventListener
(
"
dialogclose
"
this
)
;
}
}
;
