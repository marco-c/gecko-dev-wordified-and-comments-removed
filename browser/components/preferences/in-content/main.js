ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
TransientPrefs
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CloudStorage
"
"
resource
:
/
/
gre
/
modules
/
CloudStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
gCategoryManager
:
[
"
mozilla
.
org
/
categorymanager
;
1
"
"
nsICategoryManager
"
]
gHandlerService
:
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
"
nsIHandlerService
"
]
gMIMEService
:
[
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
]
gWebContentContentConverterService
:
[
"
mozilla
.
org
/
embeddor
.
implemented
/
web
-
content
-
handler
-
registrar
;
1
"
"
nsIWebContentConverterService
"
]
}
)
;
const
TYPE_MAYBE_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
feed
"
;
const
TYPE_MAYBE_VIDEO_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
video
.
feed
"
;
const
TYPE_MAYBE_AUDIO_FEED
=
"
application
/
vnd
.
mozilla
.
maybe
.
audio
.
feed
"
;
const
TYPE_PDF
=
"
application
/
pdf
"
;
const
PREF_PDFJS_DISABLED
=
"
pdfjs
.
disabled
"
;
const
TOPIC_PDFJS_HANDLER_CHANGED
=
"
pdfjs
:
handlerChanged
"
;
const
PREF_DISABLED_PLUGIN_TYPES
=
"
plugin
.
disable_full_page_plugin_for_types
"
;
const
PREF_CONTAINERS_EXTENSION
=
"
privacy
.
userContext
.
extension
"
;
const
PREF_SHOW_PLUGINS_IN_LIST
=
"
browser
.
download
.
show_plugins_in_list
"
;
const
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
=
"
browser
.
download
.
hide_plugins_without_extensions
"
;
const
CONTAINERS_KEY
=
"
privacy
.
containers
"
;
const
PREF_FEED_SELECTED_APP
=
"
browser
.
feeds
.
handlers
.
application
"
;
const
PREF_FEED_SELECTED_WEB
=
"
browser
.
feeds
.
handlers
.
webservice
"
;
const
PREF_FEED_SELECTED_ACTION
=
"
browser
.
feeds
.
handler
"
;
const
PREF_FEED_SELECTED_READER
=
"
browser
.
feeds
.
handler
.
default
"
;
const
PREF_VIDEO_FEED_SELECTED_APP
=
"
browser
.
videoFeeds
.
handlers
.
application
"
;
const
PREF_VIDEO_FEED_SELECTED_WEB
=
"
browser
.
videoFeeds
.
handlers
.
webservice
"
;
const
PREF_VIDEO_FEED_SELECTED_ACTION
=
"
browser
.
videoFeeds
.
handler
"
;
const
PREF_VIDEO_FEED_SELECTED_READER
=
"
browser
.
videoFeeds
.
handler
.
default
"
;
const
PREF_AUDIO_FEED_SELECTED_APP
=
"
browser
.
audioFeeds
.
handlers
.
application
"
;
const
PREF_AUDIO_FEED_SELECTED_WEB
=
"
browser
.
audioFeeds
.
handlers
.
webservice
"
;
const
PREF_AUDIO_FEED_SELECTED_ACTION
=
"
browser
.
audioFeeds
.
handler
"
;
const
PREF_AUDIO_FEED_SELECTED_READER
=
"
browser
.
audioFeeds
.
handler
.
default
"
;
const
kActionUsePlugin
=
5
;
const
ICON_URL_APP
=
AppConstants
.
platform
=
=
"
linux
"
?
"
moz
-
icon
:
/
/
dummy
.
exe
?
size
=
16
"
:
"
chrome
:
/
/
browser
/
skin
/
preferences
/
application
.
png
"
;
const
APP_ICON_ATTR_NAME
=
"
appHandlerIcon
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
ChromeUtils
.
defineModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
}
Preferences
.
addAll
(
[
{
id
:
"
browser
.
startup
.
page
"
type
:
"
int
"
}
{
id
:
"
browser
.
privatebrowsing
.
autostart
"
type
:
"
bool
"
}
{
id
:
"
browser
.
download
.
useDownloadDir
"
type
:
"
bool
"
}
{
id
:
"
browser
.
download
.
folderList
"
type
:
"
int
"
}
{
id
:
"
browser
.
download
.
dir
"
type
:
"
file
"
}
{
id
:
"
browser
.
link
.
open_newwindow
"
type
:
"
int
"
}
{
id
:
"
browser
.
tabs
.
loadInBackground
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
browser
.
tabs
.
warnOnClose
"
type
:
"
bool
"
}
{
id
:
"
browser
.
tabs
.
warnOnOpen
"
type
:
"
bool
"
}
{
id
:
"
browser
.
sessionstore
.
restore_on_demand
"
type
:
"
bool
"
}
{
id
:
"
browser
.
ctrlTab
.
recentlyUsedOrder
"
type
:
"
bool
"
}
{
id
:
"
font
.
language
.
group
"
type
:
"
wstring
"
}
{
id
:
"
browser
.
translation
.
detectLanguage
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
browsewithcaret
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
typeaheadfind
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
blockautorefresh
"
type
:
"
bool
"
}
{
id
:
"
general
.
autoScroll
"
type
:
"
bool
"
}
{
id
:
"
general
.
smoothScroll
"
type
:
"
bool
"
}
{
id
:
"
layout
.
spellcheckDefault
"
type
:
"
int
"
}
{
id
:
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
dom
.
ipc
.
processCount
"
type
:
"
int
"
}
{
id
:
"
dom
.
ipc
.
processCount
.
web
"
type
:
"
int
"
}
{
id
:
"
layers
.
acceleration
.
disabled
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
browser
.
feeds
.
handler
"
type
:
"
string
"
}
{
id
:
"
browser
.
feeds
.
handler
.
default
"
type
:
"
string
"
}
{
id
:
"
browser
.
feeds
.
handlers
.
application
"
type
:
"
file
"
}
{
id
:
"
browser
.
feeds
.
handlers
.
webservice
"
type
:
"
string
"
}
{
id
:
"
browser
.
videoFeeds
.
handler
"
type
:
"
string
"
}
{
id
:
"
browser
.
videoFeeds
.
handler
.
default
"
type
:
"
string
"
}
{
id
:
"
browser
.
videoFeeds
.
handlers
.
application
"
type
:
"
file
"
}
{
id
:
"
browser
.
videoFeeds
.
handlers
.
webservice
"
type
:
"
string
"
}
{
id
:
"
browser
.
audioFeeds
.
handler
"
type
:
"
string
"
}
{
id
:
"
browser
.
audioFeeds
.
handler
.
default
"
type
:
"
string
"
}
{
id
:
"
browser
.
audioFeeds
.
handlers
.
application
"
type
:
"
file
"
}
{
id
:
"
browser
.
audioFeeds
.
handlers
.
webservice
"
type
:
"
string
"
}
{
id
:
"
pref
.
downloads
.
disable_button
.
edit_actions
"
type
:
"
bool
"
}
{
id
:
"
media
.
eme
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
advanced
.
selectedTabIndex
"
type
:
"
int
"
}
{
id
:
"
browser
.
search
.
update
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
userContext
.
enabled
"
type
:
"
bool
"
}
]
)
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
Preferences
.
addAll
(
[
{
id
:
"
browser
.
shell
.
checkDefaultBrowser
"
type
:
"
bool
"
}
{
id
:
"
pref
.
general
.
disable_button
.
default_browser
"
type
:
"
bool
"
}
]
)
;
}
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
Preferences
.
addAll
(
[
{
id
:
"
browser
.
taskbar
.
previews
.
enable
"
type
:
"
bool
"
}
{
id
:
"
ui
.
osk
.
enabled
"
type
:
"
bool
"
}
]
)
;
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
Preferences
.
addAll
(
[
{
id
:
"
app
.
update
.
auto
"
type
:
"
bool
"
}
{
id
:
"
app
.
update
.
disable_button
.
showUpdateHistory
"
type
:
"
bool
"
}
]
)
;
if
(
AppConstants
.
MOZ_MAINTENANCE_SERVICE
)
{
Preferences
.
addAll
(
[
{
id
:
"
app
.
update
.
service
.
enabled
"
type
:
"
bool
"
}
]
)
;
}
}
var
promiseLoadHandlersList
;
var
gNodeToObjectMap
=
new
WeakMap
(
)
;
var
gMainPane
=
{
_handledTypes
:
{
}
_visibleTypes
:
[
]
STARTUP_PREF_BLANK
:
0
STARTUP_PREF_HOMEPAGE
:
1
STARTUP_PREF_RESTORE_SESSION
:
3
get
_brandShortName
(
)
{
delete
this
.
_brandShortName
;
return
this
.
_brandShortName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
}
get
_prefsBundle
(
)
{
delete
this
.
_prefsBundle
;
return
this
.
_prefsBundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
}
get
_list
(
)
{
delete
this
.
_list
;
return
this
.
_list
=
document
.
getElementById
(
"
handlersView
"
)
;
}
get
_filter
(
)
{
delete
this
.
_filter
;
return
this
.
_filter
=
document
.
getElementById
(
"
filter
"
)
;
}
_backoffIndex
:
0
init
(
)
{
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gMainPane
)
)
;
}
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
this
.
updateSetDefaultBrowser
(
)
;
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
backoffTimes
=
[
1000
1000
1000
1000
2000
2000
2000
5000
5000
10000
]
;
let
pollForDefaultBrowser
=
(
)
=
>
{
let
uri
=
win
.
gBrowser
.
currentURI
.
spec
;
if
(
(
uri
=
=
"
about
:
preferences
"
|
|
uri
=
=
"
about
:
preferences
#
general
"
)
&
&
document
.
visibilityState
=
=
"
visible
"
)
{
this
.
updateSetDefaultBrowser
(
)
;
}
window
.
setTimeout
(
(
)
=
>
{
window
.
requestIdleCallback
(
pollForDefaultBrowser
)
;
}
backoffTimes
[
this
.
_backoffIndex
+
1
<
backoffTimes
.
length
?
this
.
_backoffIndex
+
+
:
backoffTimes
.
length
-
1
]
)
;
}
;
window
.
setTimeout
(
(
)
=
>
{
window
.
requestIdleCallback
(
pollForDefaultBrowser
)
;
}
backoffTimes
[
this
.
_backoffIndex
]
)
;
}
this
.
initBrowserContainers
(
)
;
this
.
buildContentProcessCountMenuList
(
)
;
let
performanceSettingsLink
=
document
.
getElementById
(
"
performanceSettingsLearnMore
"
)
;
let
performanceSettingsUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
performance
"
;
performanceSettingsLink
.
setAttribute
(
"
href
"
performanceSettingsUrl
)
;
this
.
updateDefaultPerformanceSettingsPref
(
)
;
let
defaultPerformancePref
=
Preferences
.
get
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
defaultPerformancePref
.
on
(
"
change
"
(
)
=
>
{
this
.
updatePerformanceSettingsBox
(
{
duringChangeEvent
:
true
}
)
;
}
)
;
this
.
updatePerformanceSettingsBox
(
{
duringChangeEvent
:
false
}
)
;
let
connectionSettingsLink
=
document
.
getElementById
(
"
connectionSettingsLearnMore
"
)
;
let
connectionSettingsUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
prefs
-
connection
-
settings
"
;
connectionSettingsLink
.
setAttribute
(
"
href
"
connectionSettingsUrl
)
;
this
.
updateProxySettingsUI
(
)
;
initializeProxyUI
(
gMainPane
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
try
{
let
ver
=
parseFloat
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
)
;
let
showTabsInTaskbar
=
document
.
getElementById
(
"
showTabsInTaskbar
"
)
;
showTabsInTaskbar
.
hidden
=
ver
<
6
.
1
;
}
catch
(
ex
)
{
}
}
if
(
!
TransientPrefs
.
prefShouldBeVisible
(
"
browser
.
tabs
.
warnOnClose
"
)
)
document
.
getElementById
(
"
warnCloseMultiple
"
)
.
hidden
=
true
;
if
(
!
TransientPrefs
.
prefShouldBeVisible
(
"
browser
.
tabs
.
warnOnOpen
"
)
)
document
.
getElementById
(
"
warnOpenMany
"
)
.
hidden
=
true
;
setEventListener
(
"
browserRestoreSession
"
"
command
"
gMainPane
.
onBrowserRestoreSessionChange
)
;
gMainPane
.
updateBrowserStartupUI
=
gMainPane
.
updateBrowserStartupUI
.
bind
(
gMainPane
)
;
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
on
(
"
change
"
gMainPane
.
updateBrowserStartupUI
)
;
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
.
on
(
"
change
"
gMainPane
.
updateBrowserStartupUI
)
;
Preferences
.
get
(
"
browser
.
startup
.
homepage
"
)
.
on
(
"
change
"
gMainPane
.
updateBrowserStartupUI
)
;
gMainPane
.
updateBrowserStartupUI
(
)
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
setEventListener
(
"
setDefaultButton
"
"
command
"
gMainPane
.
setDefaultBrowser
)
;
}
setEventListener
(
"
disableContainersExtension
"
"
command
"
makeDisableControllingExtension
(
PREF_SETTING_TYPE
CONTAINERS_KEY
)
)
;
setEventListener
(
"
chooseLanguage
"
"
command
"
gMainPane
.
showLanguages
)
;
setEventListener
(
"
translationAttributionImage
"
"
click
"
gMainPane
.
openTranslationProviderAttribution
)
;
setEventListener
(
"
translateButton
"
"
command
"
gMainPane
.
showTranslationExceptions
)
;
Preferences
.
get
(
"
font
.
language
.
group
"
)
.
on
(
"
change
"
gMainPane
.
_rebuildFonts
.
bind
(
gMainPane
)
)
;
setEventListener
(
"
advancedFonts
"
"
command
"
gMainPane
.
configureFonts
)
;
setEventListener
(
"
colors
"
"
command
"
gMainPane
.
configureColors
)
;
Preferences
.
get
(
"
layers
.
acceleration
.
disabled
"
)
.
on
(
"
change
"
gMainPane
.
updateHardwareAcceleration
.
bind
(
gMainPane
)
)
;
setEventListener
(
"
connectionSettings
"
"
command
"
gMainPane
.
showConnections
)
;
setEventListener
(
"
browserContainersCheckbox
"
"
command
"
gMainPane
.
checkBrowserContainers
)
;
setEventListener
(
"
browserContainersSettings
"
"
command
"
gMainPane
.
showContainerSettings
)
;
this
.
_rebuildFonts
(
)
;
this
.
updateOnScreenKeyboardVisibility
(
)
;
const
prefName
=
"
browser
.
translation
.
ui
.
show
"
;
if
(
Services
.
prefs
.
getBoolPref
(
prefName
)
)
{
let
row
=
document
.
getElementById
(
"
translationBox
"
)
;
row
.
removeAttribute
(
"
hidden
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
translation
/
Translation
.
jsm
"
)
;
if
(
Translation
.
translationEngine
=
=
"
bing
"
)
{
document
.
getElementById
(
"
bingAttribution
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
}
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
let
uAppData
=
OS
.
Constants
.
Path
.
userApplicationDataDir
;
let
ignoreSeparateProfile
=
OS
.
Path
.
join
(
uAppData
"
ignore
-
dev
-
edition
-
profile
"
)
;
setEventListener
(
"
separateProfileMode
"
"
command
"
gMainPane
.
separateProfileModeChange
)
;
let
separateProfileModeCheckbox
=
document
.
getElementById
(
"
separateProfileMode
"
)
;
setEventListener
(
"
getStarted
"
"
click
"
gMainPane
.
onGetStarted
)
;
OS
.
File
.
stat
(
ignoreSeparateProfile
)
.
then
(
(
)
=
>
separateProfileModeCheckbox
.
checked
=
false
(
)
=
>
separateProfileModeCheckbox
.
checked
=
true
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
enabled
"
)
)
{
document
.
getElementById
(
"
sync
-
dev
-
edition
-
root
"
)
.
hidden
=
false
;
fxAccounts
.
getSignedInUser
(
)
.
then
(
data
=
>
{
document
.
getElementById
(
"
getStarted
"
)
.
selectedIndex
=
data
?
1
:
0
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
}
let
version
=
AppConstants
.
MOZ_APP_VERSION_DISPLAY
;
if
(
/
a
\
d
+
/
.
test
(
version
)
)
{
let
buildID
=
Services
.
appinfo
.
appBuildID
;
let
year
=
buildID
.
slice
(
0
4
)
;
let
month
=
buildID
.
slice
(
4
6
)
;
let
day
=
buildID
.
slice
(
6
8
)
;
version
+
=
(
{
year
}
-
{
month
}
-
{
day
}
)
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
archResource
=
Services
.
appinfo
.
is64Bit
?
"
aboutDialog
.
architecture
.
sixtyFourBit
"
:
"
aboutDialog
.
architecture
.
thirtyTwoBit
"
;
let
arch
=
bundle
.
GetStringFromName
(
archResource
)
;
version
+
=
(
{
arch
}
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
updateAppInfo
"
)
"
update
-
application
-
version
"
{
version
}
)
;
let
relNotesLink
=
document
.
getElementById
(
"
releasenotes
"
)
;
let
relNotesPrefType
=
Services
.
prefs
.
getPrefType
(
"
app
.
releaseNotesURL
"
)
;
if
(
relNotesPrefType
!
=
Services
.
prefs
.
PREF_INVALID
)
{
let
relNotesURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
releaseNotesURL
"
)
;
if
(
relNotesURL
!
=
"
about
:
blank
"
)
{
relNotesLink
.
href
=
relNotesURL
;
relNotesLink
.
hidden
=
false
;
}
}
let
distroId
=
Services
.
prefs
.
getCharPref
(
"
distribution
.
id
"
"
"
)
;
if
(
distroId
)
{
let
distroString
=
distroId
;
let
distroVersion
=
Services
.
prefs
.
getCharPref
(
"
distribution
.
version
"
"
"
)
;
if
(
distroVersion
)
{
distroString
+
=
"
-
"
+
distroVersion
;
}
let
distroIdField
=
document
.
getElementById
(
"
distributionId
"
)
;
distroIdField
.
value
=
distroString
;
distroIdField
.
hidden
=
false
;
let
distroAbout
=
Services
.
prefs
.
getStringPref
(
"
distribution
.
about
"
"
"
)
;
if
(
distroAbout
)
{
let
distroField
=
document
.
getElementById
(
"
distribution
"
)
;
distroField
.
value
=
distroAbout
;
distroField
.
hidden
=
false
;
}
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
gAppUpdater
=
new
appUpdater
(
)
;
setEventListener
(
"
showUpdateHistory
"
"
command
"
gMainPane
.
showUpdates
)
;
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
{
document
.
getElementById
(
"
updateAllowDescription
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
updateRadioGroup
"
)
.
hidden
=
true
;
if
(
AppConstants
.
MOZ_MAINTENANCE_SERVICE
)
{
document
.
getElementById
(
"
useService
"
)
.
hidden
=
true
;
}
}
if
(
AppConstants
.
MOZ_MAINTENANCE_SERVICE
)
{
let
installed
;
try
{
let
wrk
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
wrk
.
open
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
"
SOFTWARE
\
\
Mozilla
\
\
MaintenanceService
"
wrk
.
ACCESS_READ
|
wrk
.
WOW64_64
)
;
installed
=
wrk
.
readIntValue
(
"
Installed
"
)
;
wrk
.
close
(
)
;
}
catch
(
e
)
{
}
if
(
installed
!
=
1
)
{
document
.
getElementById
(
"
useService
"
)
.
hidden
=
true
;
}
}
}
Services
.
prefs
.
addObserver
(
PREF_SHOW_PLUGINS_IN_LIST
this
)
;
Services
.
prefs
.
addObserver
(
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
this
)
;
Services
.
prefs
.
addObserver
(
PREF_FEED_SELECTED_APP
this
)
;
Services
.
prefs
.
addObserver
(
PREF_FEED_SELECTED_WEB
this
)
;
Services
.
prefs
.
addObserver
(
PREF_FEED_SELECTED_ACTION
this
)
;
Services
.
prefs
.
addObserver
(
PREF_FEED_SELECTED_READER
this
)
;
Services
.
prefs
.
addObserver
(
PREF_VIDEO_FEED_SELECTED_APP
this
)
;
Services
.
prefs
.
addObserver
(
PREF_VIDEO_FEED_SELECTED_WEB
this
)
;
Services
.
prefs
.
addObserver
(
PREF_VIDEO_FEED_SELECTED_ACTION
this
)
;
Services
.
prefs
.
addObserver
(
PREF_VIDEO_FEED_SELECTED_READER
this
)
;
Services
.
prefs
.
addObserver
(
PREF_AUDIO_FEED_SELECTED_APP
this
)
;
Services
.
prefs
.
addObserver
(
PREF_AUDIO_FEED_SELECTED_WEB
this
)
;
Services
.
prefs
.
addObserver
(
PREF_AUDIO_FEED_SELECTED_ACTION
this
)
;
Services
.
prefs
.
addObserver
(
PREF_AUDIO_FEED_SELECTED_READER
this
)
;
setEventListener
(
"
filter
"
"
command
"
gMainPane
.
filter
)
;
setEventListener
(
"
typeColumn
"
"
click
"
gMainPane
.
sort
)
;
setEventListener
(
"
actionColumn
"
"
click
"
gMainPane
.
sort
)
;
setEventListener
(
"
chooseFolder
"
"
command
"
gMainPane
.
chooseFolder
)
;
setEventListener
(
"
saveWhere
"
"
command
"
gMainPane
.
handleSaveToCommand
)
;
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
.
on
(
"
change
"
gMainPane
.
displayDownloadDirPref
.
bind
(
gMainPane
)
)
;
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
.
on
(
"
change
"
gMainPane
.
displayDownloadDirPref
.
bind
(
gMainPane
)
)
;
gMainPane
.
displayDownloadDirPref
(
)
;
window
.
addEventListener
(
"
unload
"
this
)
;
if
(
document
.
getElementById
(
"
actionColumn
"
)
.
hasAttribute
(
"
sortDirection
"
)
)
{
this
.
_sortColumn
=
document
.
getElementById
(
"
actionColumn
"
)
;
document
.
getElementById
(
"
typeColumn
"
)
.
removeAttribute
(
"
sortDirection
"
)
;
}
else
{
this
.
_sortColumn
=
document
.
getElementById
(
"
typeColumn
"
)
;
}
let
browserBundle
=
document
.
getElementById
(
"
browserBundle
"
)
;
appendSearchKeywords
(
"
browserContainersSettings
"
[
browserBundle
.
getString
(
"
userContextPersonal
.
label
"
)
browserBundle
.
getString
(
"
userContextWork
.
label
"
)
browserBundle
.
getString
(
"
userContextBanking
.
label
"
)
browserBundle
.
getString
(
"
userContextShopping
.
label
"
)
]
)
;
Services
.
obs
.
notifyObservers
(
window
"
main
-
pane
-
loaded
"
)
;
}
preInit
(
)
{
promiseLoadHandlersList
=
new
Promise
(
(
resolve
reject
)
=
>
{
window
.
addEventListener
(
"
pageshow
"
async
(
)
=
>
{
try
{
this
.
_initListEventHandlers
(
)
;
this
.
_loadData
(
)
;
await
this
.
_rebuildVisibleTypes
(
)
;
this
.
_sortVisibleTypes
(
)
;
this
.
_rebuildView
(
)
;
resolve
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
{
once
:
true
}
)
;
}
)
;
}
readBrowserContainersCheckbox
(
)
{
const
pref
=
Preferences
.
get
(
"
privacy
.
userContext
.
enabled
"
)
;
const
settings
=
document
.
getElementById
(
"
browserContainersSettings
"
)
;
settings
.
disabled
=
!
pref
.
value
;
const
containersEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
;
const
containersCheckbox
=
document
.
getElementById
(
"
browserContainersCheckbox
"
)
;
containersCheckbox
.
checked
=
containersEnabled
;
handleControllingExtension
(
PREF_SETTING_TYPE
CONTAINERS_KEY
)
.
then
(
(
isControlled
)
=
>
{
containersCheckbox
.
disabled
=
isControlled
;
}
)
;
}
initBrowserContainers
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
ui
.
enabled
"
)
)
{
document
.
getElementById
(
"
browserContainersbox
"
)
.
setAttribute
(
"
data
-
hidden
-
from
-
search
"
"
true
"
)
;
return
;
}
Services
.
prefs
.
addObserver
(
PREF_CONTAINERS_EXTENSION
this
)
;
const
link
=
document
.
getElementById
(
"
browserContainersLearnMore
"
)
;
link
.
href
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
containers
"
;
document
.
getElementById
(
"
browserContainersbox
"
)
.
hidden
=
false
;
this
.
readBrowserContainersCheckbox
(
)
;
}
async
separateProfileModeChange
(
)
{
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
function
quitApp
(
)
{
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestartNotSameProfile
)
;
}
function
revertCheckbox
(
error
)
{
separateProfileModeCheckbox
.
checked
=
!
separateProfileModeCheckbox
.
checked
;
if
(
error
)
{
Cu
.
reportError
(
"
Failed
to
toggle
separate
profile
mode
:
"
+
error
)
;
}
}
function
createOrRemoveSpecialDevEditionFile
(
onSuccess
)
{
let
uAppData
=
OS
.
Constants
.
Path
.
userApplicationDataDir
;
let
ignoreSeparateProfile
=
OS
.
Path
.
join
(
uAppData
"
ignore
-
dev
-
edition
-
profile
"
)
;
if
(
separateProfileModeCheckbox
.
checked
)
{
OS
.
File
.
remove
(
ignoreSeparateProfile
)
.
then
(
onSuccess
revertCheckbox
)
;
}
else
{
OS
.
File
.
writeAtomic
(
ignoreSeparateProfile
new
Uint8Array
(
)
)
.
then
(
onSuccess
revertCheckbox
)
;
}
}
let
separateProfileModeCheckbox
=
document
.
getElementById
(
"
separateProfileMode
"
)
;
let
button_index
=
await
confirmRestartPrompt
(
separateProfileModeCheckbox
.
checked
0
false
true
)
;
switch
(
button_index
)
{
case
CONFIRM_RESTART_PROMPT_CANCEL
:
revertCheckbox
(
)
;
return
;
case
CONFIRM_RESTART_PROMPT_RESTART_NOW
:
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
!
cancelQuit
.
data
)
{
createOrRemoveSpecialDevEditionFile
(
quitApp
)
;
return
;
}
revertCheckbox
(
)
;
return
;
case
CONFIRM_RESTART_PROMPT_RESTART_LATER
:
createOrRemoveSpecialDevEditionFile
(
)
;
}
}
}
async
onGetStarted
(
aEvent
)
{
if
(
!
AppConstants
.
MOZ_DEV_EDITION
)
{
return
;
}
const
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
!
win
)
{
return
;
}
const
user
=
await
fxAccounts
.
getSignedInUser
(
)
;
if
(
user
)
{
win
.
openTrustedLinkIn
(
"
about
:
preferences
#
sync
"
"
current
"
)
;
return
;
}
let
url
=
await
FxAccounts
.
config
.
promiseSignInURI
(
"
dev
-
edition
-
setup
"
)
;
let
accountsTab
=
win
.
gBrowser
.
addTab
(
url
)
;
win
.
gBrowser
.
selectedTab
=
accountsTab
;
}
updateButtons
(
aButtonID
aPreferenceID
)
{
var
button
=
document
.
getElementById
(
aButtonID
)
;
var
preference
=
Preferences
.
get
(
aPreferenceID
)
;
button
.
disabled
=
!
preference
.
value
;
return
undefined
;
}
updateBrowserStartupUI
(
)
{
const
pbAutoStartPref
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
const
startupPref
=
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
;
let
newValue
;
let
checkbox
=
document
.
getElementById
(
"
browserRestoreSession
"
)
;
if
(
pbAutoStartPref
.
value
|
|
startupPref
.
locked
)
{
checkbox
.
setAttribute
(
"
disabled
"
"
true
"
)
;
newValue
=
false
;
}
else
{
checkbox
.
removeAttribute
(
"
disabled
"
)
;
newValue
=
startupPref
.
value
=
=
=
this
.
STARTUP_PREF_RESTORE_SESSION
;
}
if
(
checkbox
.
checked
!
=
=
newValue
)
{
checkbox
.
checked
=
newValue
;
}
}
onBrowserRestoreSessionChange
(
event
)
{
const
value
=
event
.
target
.
checked
;
const
startupPref
=
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
;
let
newValue
;
if
(
value
)
{
if
(
startupPref
.
value
=
=
=
this
.
STARTUP_PREF_BLANK
)
{
Preferences
.
get
(
"
browser
.
startup
.
homepage
"
)
.
value
=
"
about
:
blank
"
;
}
newValue
=
this
.
STARTUP_PREF_RESTORE_SESSION
;
}
else
{
newValue
=
this
.
STARTUP_PREF_HOMEPAGE
;
}
startupPref
.
value
=
newValue
;
}
readLinkTarget
(
)
{
var
openNewWindow
=
Preferences
.
get
(
"
browser
.
link
.
open_newwindow
"
)
;
return
openNewWindow
.
value
!
=
2
;
}
writeLinkTarget
(
)
{
var
linkTargeting
=
document
.
getElementById
(
"
linkTargeting
"
)
;
return
linkTargeting
.
checked
?
3
:
2
;
}
updateSetDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
shellSvc
=
getShellService
(
)
;
let
defaultBrowserBox
=
document
.
getElementById
(
"
defaultBrowserBox
"
)
;
if
(
!
shellSvc
)
{
defaultBrowserBox
.
hidden
=
true
;
return
;
}
let
setDefaultPane
=
document
.
getElementById
(
"
setDefaultPane
"
)
;
let
isDefault
=
shellSvc
.
isDefaultBrowser
(
false
true
)
;
setDefaultPane
.
selectedIndex
=
isDefault
?
1
:
0
;
let
alwaysCheck
=
document
.
getElementById
(
"
alwaysCheckDefault
"
)
;
alwaysCheck
.
disabled
=
alwaysCheck
.
disabled
|
|
isDefault
&
&
alwaysCheck
.
checked
;
}
}
setDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
alwaysCheckPref
=
Preferences
.
get
(
"
browser
.
shell
.
checkDefaultBrowser
"
)
;
alwaysCheckPref
.
value
=
true
;
this
.
_backoffIndex
=
0
;
let
shellSvc
=
getShellService
(
)
;
if
(
!
shellSvc
)
return
;
try
{
shellSvc
.
setDefaultBrowser
(
true
false
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
return
;
}
let
selectedIndex
=
shellSvc
.
isDefaultBrowser
(
false
true
)
?
1
:
0
;
document
.
getElementById
(
"
setDefaultPane
"
)
.
selectedIndex
=
selectedIndex
;
}
}
showLanguages
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
languages
.
xul
"
)
;
}
showTranslationExceptions
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
translation
.
xul
"
)
;
}
openTranslationProviderAttribution
(
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
translation
/
Translation
.
jsm
"
)
;
Translation
.
openProviderAttribution
(
)
;
}
configureFonts
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
fonts
.
xul
"
"
resizable
=
no
"
)
;
}
configureColors
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
colors
.
xul
"
"
resizable
=
no
"
)
;
}
showConnections
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
connection
.
xul
"
null
null
this
.
updateProxySettingsUI
.
bind
(
this
)
)
;
}
async
updateProxySettingsUI
(
)
{
let
controllingExtension
=
await
getControllingExtension
(
PREF_SETTING_TYPE
PROXY_KEY
)
;
let
description
=
document
.
getElementById
(
"
connectionSettingsDescription
"
)
;
if
(
controllingExtension
)
{
setControllingExtensionDescription
(
description
controllingExtension
"
proxy
.
settings
"
)
;
}
else
{
setControllingExtensionDescription
(
description
null
"
network
-
proxy
-
connection
-
description
"
)
;
}
}
async
checkBrowserContainers
(
event
)
{
let
checkbox
=
document
.
getElementById
(
"
browserContainersCheckbox
"
)
;
if
(
checkbox
.
checked
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
true
)
;
return
;
}
let
count
=
ContextualIdentityService
.
countContainerTabs
(
)
;
if
(
count
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
let
[
title
message
okButton
cancelButton
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
containers
-
disable
-
alert
-
title
"
}
{
id
:
"
containers
-
disable
-
alert
-
desc
"
args
:
{
tabCount
:
count
}
}
{
id
:
"
containers
-
disable
-
alert
-
ok
-
button
"
args
:
{
tabCount
:
count
}
}
{
id
:
"
containers
-
disable
-
alert
-
cancel
-
button
"
}
]
)
;
let
buttonFlags
=
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
)
+
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
)
;
let
rv
=
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
if
(
rv
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
checkbox
.
checked
=
true
;
}
showContainerSettings
(
)
{
gotoPref
(
"
containers
"
)
;
}
updateOnScreenKeyboardVisibility
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
minVersion
=
Services
.
prefs
.
getBoolPref
(
"
ui
.
osk
.
require_win10
"
)
?
10
:
6
.
2
;
if
(
Services
.
vc
.
compare
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
minVersion
)
>
=
0
)
{
document
.
getElementById
(
"
useOnScreenKeyboard
"
)
.
hidden
=
false
;
}
}
}
updateHardwareAcceleration
(
)
{
}
_rebuildFonts
(
)
{
var
langGroupPref
=
Preferences
.
get
(
"
font
.
language
.
group
"
)
;
var
isSerif
=
this
.
_readDefaultFontTypeForLanguage
(
langGroupPref
.
value
)
=
=
"
serif
"
;
this
.
_selectDefaultLanguageGroup
(
langGroupPref
.
value
isSerif
)
;
}
_readDefaultFontTypeForLanguage
(
aLanguageGroup
)
{
const
kDefaultFontType
=
"
font
.
default
.
%
LANG
%
"
;
var
defaultFontTypePref
=
kDefaultFontType
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
;
var
preference
=
Preferences
.
get
(
defaultFontTypePref
)
;
if
(
!
preference
)
{
preference
=
Preferences
.
add
(
{
id
:
defaultFontTypePref
type
:
"
string
"
}
)
;
preference
.
on
(
"
change
"
gMainPane
.
_rebuildFonts
.
bind
(
gMainPane
)
)
;
}
return
preference
.
value
;
}
_selectDefaultLanguageGroupPromise
:
Promise
.
resolve
(
)
_selectDefaultLanguageGroup
(
aLanguageGroup
aIsSerif
)
{
this
.
_selectDefaultLanguageGroupPromise
=
(
async
(
)
=
>
{
await
this
.
_selectDefaultLanguageGroupPromise
;
const
kFontNameFmtSerif
=
"
font
.
name
.
serif
.
%
LANG
%
"
;
const
kFontNameFmtSansSerif
=
"
font
.
name
.
sans
-
serif
.
%
LANG
%
"
;
const
kFontNameListFmtSerif
=
"
font
.
name
-
list
.
serif
.
%
LANG
%
"
;
const
kFontNameListFmtSansSerif
=
"
font
.
name
-
list
.
sans
-
serif
.
%
LANG
%
"
;
const
kFontSizeFmtVariable
=
"
font
.
size
.
variable
.
%
LANG
%
"
;
var
prefs
=
[
{
format
:
aIsSerif
?
kFontNameFmtSerif
:
kFontNameFmtSansSerif
type
:
"
fontname
"
element
:
"
defaultFont
"
fonttype
:
aIsSerif
?
"
serif
"
:
"
sans
-
serif
"
}
{
format
:
aIsSerif
?
kFontNameListFmtSerif
:
kFontNameListFmtSansSerif
type
:
"
unichar
"
element
:
null
fonttype
:
aIsSerif
?
"
serif
"
:
"
sans
-
serif
"
}
{
format
:
kFontSizeFmtVariable
type
:
"
int
"
element
:
"
defaultFontSize
"
fonttype
:
null
}
]
;
for
(
var
i
=
0
;
i
<
prefs
.
length
;
+
+
i
)
{
var
preference
=
Preferences
.
get
(
prefs
[
i
]
.
format
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
)
;
if
(
!
preference
)
{
var
name
=
prefs
[
i
]
.
format
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
;
preference
=
Preferences
.
add
(
{
id
:
name
type
:
prefs
[
i
]
.
type
}
)
;
}
if
(
!
prefs
[
i
]
.
element
)
continue
;
var
element
=
document
.
getElementById
(
prefs
[
i
]
.
element
)
;
if
(
element
)
{
element
.
setAttribute
(
"
preference
"
preference
.
id
)
;
if
(
prefs
[
i
]
.
fonttype
)
await
FontBuilder
.
buildFontList
(
aLanguageGroup
prefs
[
i
]
.
fonttype
element
)
;
preference
.
setElementValue
(
element
)
;
}
}
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
_storedSpellCheck
:
0
readCheckSpelling
(
)
{
var
pref
=
Preferences
.
get
(
"
layout
.
spellcheckDefault
"
)
;
this
.
_storedSpellCheck
=
pref
.
value
;
return
(
pref
.
value
!
=
0
)
;
}
writeCheckSpelling
(
)
{
var
checkbox
=
document
.
getElementById
(
"
checkSpelling
"
)
;
if
(
checkbox
.
checked
)
{
if
(
this
.
_storedSpellCheck
=
=
2
)
{
return
2
;
}
return
1
;
}
return
0
;
}
updateDefaultPerformanceSettingsPref
(
)
{
let
defaultPerformancePref
=
Preferences
.
get
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
let
processCountPref
=
Preferences
.
get
(
"
dom
.
ipc
.
processCount
"
)
;
let
accelerationPref
=
Preferences
.
get
(
"
layers
.
acceleration
.
disabled
"
)
;
if
(
processCountPref
.
value
!
=
processCountPref
.
defaultValue
|
|
accelerationPref
.
value
!
=
accelerationPref
.
defaultValue
)
{
defaultPerformancePref
.
value
=
false
;
}
}
updatePerformanceSettingsBox
(
{
duringChangeEvent
}
)
{
let
defaultPerformancePref
=
Preferences
.
get
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
let
performanceSettings
=
document
.
getElementById
(
"
performanceSettings
"
)
;
let
processCountPref
=
Preferences
.
get
(
"
dom
.
ipc
.
processCount
"
)
;
if
(
defaultPerformancePref
.
value
)
{
let
accelerationPref
=
Preferences
.
get
(
"
layers
.
acceleration
.
disabled
"
)
;
processCountPref
.
value
=
processCountPref
.
defaultValue
;
accelerationPref
.
value
=
accelerationPref
.
defaultValue
;
performanceSettings
.
hidden
=
true
;
}
else
{
performanceSettings
.
hidden
=
false
;
}
}
buildContentProcessCountMenuList
(
)
{
if
(
Services
.
appinfo
.
browserTabsRemoteAutostart
)
{
let
processCountPref
=
Preferences
.
get
(
"
dom
.
ipc
.
processCount
"
)
;
let
defaultProcessCount
=
processCountPref
.
defaultValue
;
let
contentProcessCount
=
document
.
querySelector
(
#
contentProcessCount
>
menupopup
>
menuitem
[
value
=
"
{
defaultProcessCount
}
"
]
)
;
document
.
l10n
.
setAttributes
(
contentProcessCount
"
performance
-
default
-
content
-
process
-
count
"
{
num
:
defaultProcessCount
}
)
;
document
.
getElementById
(
"
limitContentProcess
"
)
.
disabled
=
false
;
document
.
getElementById
(
"
contentProcessCount
"
)
.
disabled
=
false
;
document
.
getElementById
(
"
contentProcessCountEnabledDescription
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
contentProcessCountDisabledDescription
"
)
.
hidden
=
true
;
}
else
{
document
.
getElementById
(
"
limitContentProcess
"
)
.
disabled
=
true
;
document
.
getElementById
(
"
contentProcessCount
"
)
.
disabled
=
true
;
document
.
getElementById
(
"
contentProcessCountEnabledDescription
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
contentProcessCountDisabledDescription
"
)
.
hidden
=
false
;
}
}
showUpdates
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
update
/
history
.
xul
"
)
;
}
destroy
(
)
{
window
.
removeEventListener
(
"
unload
"
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_SHOW_PLUGINS_IN_LIST
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_FEED_SELECTED_APP
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_FEED_SELECTED_WEB
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_FEED_SELECTED_ACTION
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_FEED_SELECTED_READER
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_VIDEO_FEED_SELECTED_APP
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_VIDEO_FEED_SELECTED_WEB
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_VIDEO_FEED_SELECTED_ACTION
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_VIDEO_FEED_SELECTED_READER
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_AUDIO_FEED_SELECTED_APP
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_AUDIO_FEED_SELECTED_WEB
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_AUDIO_FEED_SELECTED_ACTION
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_AUDIO_FEED_SELECTED_READER
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_CONTAINERS_EXTENSION
this
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
async
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
if
(
aData
=
=
PREF_CONTAINERS_EXTENSION
)
{
this
.
readBrowserContainersCheckbox
(
)
;
return
;
}
if
(
!
this
.
_storingAction
)
{
if
(
aData
=
=
PREF_SHOW_PLUGINS_IN_LIST
|
|
aData
=
=
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
)
{
await
this
.
_rebuildVisibleTypes
(
)
;
this
.
_sortVisibleTypes
(
)
;
}
this
.
_rebuildView
(
)
;
}
}
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
=
=
"
unload
"
)
{
this
.
destroy
(
)
;
}
}
_loadData
(
)
{
this
.
_loadFeedHandler
(
)
;
this
.
_loadInternalHandlers
(
)
;
this
.
_loadPluginHandlers
(
)
;
this
.
_loadApplicationHandlers
(
)
;
}
_loadFeedHandler
(
)
{
this
.
_handledTypes
[
TYPE_MAYBE_FEED
]
=
feedHandlerInfo
;
feedHandlerInfo
.
handledOnlyByPlugin
=
false
;
this
.
_handledTypes
[
TYPE_MAYBE_VIDEO_FEED
]
=
videoFeedHandlerInfo
;
videoFeedHandlerInfo
.
handledOnlyByPlugin
=
false
;
this
.
_handledTypes
[
TYPE_MAYBE_AUDIO_FEED
]
=
audioFeedHandlerInfo
;
audioFeedHandlerInfo
.
handledOnlyByPlugin
=
false
;
}
_loadInternalHandlers
(
)
{
var
internalHandlers
=
[
new
PDFHandlerInfoWrapper
(
)
]
;
for
(
let
internalHandler
of
internalHandlers
)
{
if
(
internalHandler
.
enabled
)
{
this
.
_handledTypes
[
internalHandler
.
type
]
=
internalHandler
;
}
}
}
_loadPluginHandlers
(
)
{
"
use
strict
"
;
let
mimeTypes
=
navigator
.
mimeTypes
;
for
(
let
mimeType
of
mimeTypes
)
{
let
handlerInfoWrapper
;
if
(
mimeType
.
type
in
this
.
_handledTypes
)
{
handlerInfoWrapper
=
this
.
_handledTypes
[
mimeType
.
type
]
;
}
else
{
let
wrappedHandlerInfo
=
gMIMEService
.
getFromTypeAndExtension
(
mimeType
.
type
null
)
;
handlerInfoWrapper
=
new
HandlerInfoWrapper
(
mimeType
.
type
wrappedHandlerInfo
)
;
handlerInfoWrapper
.
handledOnlyByPlugin
=
true
;
this
.
_handledTypes
[
mimeType
.
type
]
=
handlerInfoWrapper
;
}
handlerInfoWrapper
.
pluginName
=
mimeType
.
enabledPlugin
.
name
;
}
}
_loadApplicationHandlers
(
)
{
var
wrappedHandlerInfos
=
gHandlerService
.
enumerate
(
)
;
while
(
wrappedHandlerInfos
.
hasMoreElements
(
)
)
{
let
wrappedHandlerInfo
=
wrappedHandlerInfos
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIHandlerInfo
)
;
let
type
=
wrappedHandlerInfo
.
type
;
let
handlerInfoWrapper
;
if
(
type
in
this
.
_handledTypes
)
handlerInfoWrapper
=
this
.
_handledTypes
[
type
]
;
else
{
handlerInfoWrapper
=
new
HandlerInfoWrapper
(
type
wrappedHandlerInfo
)
;
this
.
_handledTypes
[
type
]
=
handlerInfoWrapper
;
}
handlerInfoWrapper
.
handledOnlyByPlugin
=
false
;
}
}
selectedHandlerListItem
:
null
_initListEventHandlers
(
)
{
this
.
_list
.
addEventListener
(
"
select
"
event
=
>
{
if
(
event
.
target
!
=
this
.
_list
)
{
return
;
}
let
handlerListItem
=
this
.
_list
.
selectedItem
&
&
HandlerListItem
.
forNode
(
this
.
_list
.
selectedItem
)
;
if
(
this
.
selectedHandlerListItem
=
=
handlerListItem
)
{
return
;
}
if
(
this
.
selectedHandlerListItem
)
{
this
.
selectedHandlerListItem
.
showActionsMenu
=
false
;
}
this
.
selectedHandlerListItem
=
handlerListItem
;
if
(
handlerListItem
)
{
this
.
rebuildActionsMenu
(
)
;
handlerListItem
.
showActionsMenu
=
true
;
}
}
)
;
}
async
_rebuildVisibleTypes
(
)
{
this
.
_visibleTypes
=
[
]
;
let
visibleDescriptions
=
new
Map
(
)
;
var
showPlugins
=
Services
.
prefs
.
getBoolPref
(
PREF_SHOW_PLUGINS_IN_LIST
)
;
var
hidePluginsWithoutExtensions
=
Services
.
prefs
.
getBoolPref
(
PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS
)
;
for
(
let
type
in
this
.
_handledTypes
)
{
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
let
handlerInfo
=
this
.
_handledTypes
[
type
]
;
if
(
hidePluginsWithoutExtensions
&
&
handlerInfo
.
handledOnlyByPlugin
&
&
handlerInfo
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
!
handlerInfo
.
primaryExtension
)
continue
;
if
(
handlerInfo
.
handledOnlyByPlugin
&
&
!
showPlugins
)
continue
;
this
.
_visibleTypes
.
push
(
handlerInfo
)
;
let
otherHandlerInfo
=
visibleDescriptions
.
get
(
handlerInfo
.
description
)
;
if
(
!
otherHandlerInfo
)
{
handlerInfo
.
disambiguateDescription
=
false
;
visibleDescriptions
.
set
(
handlerInfo
.
description
handlerInfo
)
;
}
else
{
handlerInfo
.
disambiguateDescription
=
true
;
otherHandlerInfo
.
disambiguateDescription
=
true
;
}
}
}
_rebuildView
(
)
{
let
lastSelectedType
=
this
.
selectedHandlerListItem
&
&
this
.
selectedHandlerListItem
.
handlerInfoWrapper
.
type
;
this
.
selectedHandlerListItem
=
null
;
while
(
this
.
_list
.
childNodes
.
length
>
1
)
this
.
_list
.
removeChild
(
this
.
_list
.
lastChild
)
;
var
visibleTypes
=
this
.
_visibleTypes
;
if
(
this
.
_filter
.
value
)
visibleTypes
=
visibleTypes
.
filter
(
this
.
_matchesFilter
this
)
;
for
(
let
visibleType
of
visibleTypes
)
{
let
item
=
new
HandlerListItem
(
visibleType
)
;
item
.
connectAndAppendToList
(
this
.
_list
)
;
if
(
visibleType
.
type
=
=
=
lastSelectedType
)
{
this
.
_list
.
selectedItem
=
item
.
node
;
}
}
}
_matchesFilter
(
aType
)
{
var
filterValue
=
this
.
_filter
.
value
.
toLowerCase
(
)
;
return
aType
.
typeDescription
.
toLowerCase
(
)
.
includes
(
filterValue
)
|
|
aType
.
actionDescription
.
toLowerCase
(
)
.
includes
(
filterValue
)
;
}
isValidHandlerApp
(
aHandlerApp
)
{
if
(
!
aHandlerApp
)
return
false
;
if
(
aHandlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
return
this
.
_isValidHandlerExecutable
(
aHandlerApp
.
executable
)
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
return
aHandlerApp
.
uriTemplate
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebContentHandlerInfo
)
return
aHandlerApp
.
uri
;
if
(
aHandlerApp
instanceof
Ci
.
nsIGIOMimeApp
)
return
aHandlerApp
.
command
;
return
false
;
}
_isValidHandlerExecutable
(
aExecutable
)
{
let
leafName
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
leafName
=
{
AppConstants
.
MOZ_APP_NAME
}
.
exe
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
leafName
=
AppConstants
.
MOZ_MACBUNDLE_NAME
;
}
else
{
leafName
=
{
AppConstants
.
MOZ_APP_NAME
}
-
bin
;
}
return
aExecutable
&
&
aExecutable
.
exists
(
)
&
&
aExecutable
.
isExecutable
(
)
&
&
aExecutable
.
leafName
!
=
leafName
;
}
rebuildActionsMenu
(
)
{
var
typeItem
=
this
.
_list
.
selectedItem
;
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
var
menu
=
typeItem
.
querySelector
(
"
.
actionsMenu
"
)
;
var
menuPopup
=
menu
.
menupopup
;
while
(
menuPopup
.
hasChildNodes
(
)
)
menuPopup
.
removeChild
(
menuPopup
.
lastChild
)
;
let
internalMenuItem
;
if
(
handlerInfo
instanceof
InternalHandlerInfoWrapper
)
{
internalMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
internalMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
handleInternally
)
;
let
label
=
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
previewInApp
"
[
this
.
_brandShortName
]
)
;
internalMenuItem
.
setAttribute
(
"
label
"
label
)
;
internalMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
internalMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
ask
"
)
;
menuPopup
.
appendChild
(
internalMenuItem
)
;
}
{
var
askMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
askMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
alwaysAsk
)
;
let
label
;
if
(
isFeedType
(
handlerInfo
.
type
)
)
label
=
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
previewInApp
"
[
this
.
_brandShortName
]
)
;
else
label
=
gMainPane
.
_prefsBundle
.
getString
(
"
alwaysAsk
"
)
;
askMenuItem
.
setAttribute
(
"
label
"
label
)
;
askMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
askMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
ask
"
)
;
menuPopup
.
appendChild
(
askMenuItem
)
;
}
if
(
(
handlerInfo
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
&
&
!
isFeedType
(
handlerInfo
.
type
)
)
{
var
saveMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
saveMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
saveToDisk
)
;
let
label
=
gMainPane
.
_prefsBundle
.
getString
(
"
saveFile
"
)
;
saveMenuItem
.
setAttribute
(
"
label
"
label
)
;
saveMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
saveMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
save
"
)
;
menuPopup
.
appendChild
(
saveMenuItem
)
;
}
if
(
isFeedType
(
handlerInfo
.
type
)
)
{
internalMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
internalMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
handleInternally
)
;
let
label
=
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
addLiveBookmarksInApp
"
[
this
.
_brandShortName
]
)
;
internalMenuItem
.
setAttribute
(
"
label
"
label
)
;
internalMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
internalMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
feed
"
)
;
menuPopup
.
appendChild
(
internalMenuItem
)
;
}
let
menuseparator
=
document
.
createElement
(
"
menuseparator
"
)
;
menuPopup
.
appendChild
(
menuseparator
)
;
if
(
handlerInfo
.
hasDefaultHandler
)
{
var
defaultMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
defaultMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useSystemDefault
)
;
let
label
=
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
useDefault
"
[
handlerInfo
.
defaultDescription
]
)
;
defaultMenuItem
.
setAttribute
(
"
label
"
label
)
;
defaultMenuItem
.
setAttribute
(
"
tooltiptext
"
handlerInfo
.
defaultDescription
)
;
defaultMenuItem
.
setAttribute
(
"
image
"
handlerInfo
.
iconURLForSystemDefault
)
;
menuPopup
.
appendChild
(
defaultMenuItem
)
;
}
let
preferredApp
=
handlerInfo
.
preferredApplicationHandler
;
let
possibleApps
=
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
)
;
var
possibleAppMenuItems
=
[
]
;
while
(
possibleApps
.
hasMoreElements
(
)
)
{
let
possibleApp
=
possibleApps
.
getNext
(
)
;
if
(
!
this
.
isValidHandlerApp
(
possibleApp
)
)
continue
;
let
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
let
label
;
if
(
possibleApp
instanceof
Ci
.
nsILocalHandlerApp
)
label
=
getFileDisplayName
(
possibleApp
.
executable
)
;
else
label
=
possibleApp
.
name
;
label
=
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
useApp
"
[
label
]
)
;
menuItem
.
setAttribute
(
"
label
"
label
)
;
menuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
menuItem
.
setAttribute
(
"
image
"
this
.
_getIconURLForHandlerApp
(
possibleApp
)
)
;
menuItem
.
handlerApp
=
possibleApp
;
menuPopup
.
appendChild
(
menuItem
)
;
possibleAppMenuItems
.
push
(
menuItem
)
;
}
if
(
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
)
{
let
gIOSvc
=
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
.
getService
(
Ci
.
nsIGIOService
)
;
var
gioApps
=
gIOSvc
.
getAppsForURIScheme
(
handlerInfo
.
type
)
;
let
enumerator
=
gioApps
.
enumerate
(
)
;
let
possibleHandlers
=
handlerInfo
.
possibleApplicationHandlers
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
handler
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
name
=
=
handlerInfo
.
defaultDescription
)
{
continue
;
}
let
appAlreadyInHandlers
=
false
;
for
(
let
i
=
possibleHandlers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
app
=
possibleHandlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
equals
(
app
)
)
{
appAlreadyInHandlers
=
true
;
break
;
}
}
if
(
!
appAlreadyInHandlers
)
{
let
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
let
label
=
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
useApp
"
[
handler
.
name
]
)
;
menuItem
.
setAttribute
(
"
label
"
label
)
;
menuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
menuItem
.
setAttribute
(
"
image
"
this
.
_getIconURLForHandlerApp
(
handler
)
)
;
menuItem
.
handlerApp
=
handler
;
menuPopup
.
appendChild
(
menuItem
)
;
possibleAppMenuItems
.
push
(
menuItem
)
;
}
}
}
if
(
handlerInfo
.
pluginName
)
{
var
pluginMenuItem
=
document
.
createElement
(
"
menuitem
"
)
;
pluginMenuItem
.
setAttribute
(
"
action
"
kActionUsePlugin
)
;
let
label
=
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
usePluginIn
"
[
handlerInfo
.
pluginName
this
.
_brandShortName
]
)
;
pluginMenuItem
.
setAttribute
(
"
label
"
label
)
;
pluginMenuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
pluginMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
plugin
"
)
;
menuPopup
.
appendChild
(
pluginMenuItem
)
;
}
let
canOpenWithOtherApp
=
true
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
executableType
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
.
getTypeFromExtension
(
"
exe
"
)
;
canOpenWithOtherApp
=
handlerInfo
.
type
!
=
executableType
;
}
if
(
canOpenWithOtherApp
)
{
let
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
menuItem
.
className
=
"
choose
-
app
-
item
"
;
menuItem
.
addEventListener
(
"
command
"
function
(
e
)
{
gMainPane
.
chooseApp
(
e
)
;
}
)
;
let
label
=
gMainPane
.
_prefsBundle
.
getString
(
"
useOtherApp
"
)
;
menuItem
.
setAttribute
(
"
label
"
label
)
;
menuItem
.
setAttribute
(
"
tooltiptext
"
label
)
;
menuPopup
.
appendChild
(
menuItem
)
;
}
if
(
possibleAppMenuItems
.
length
)
{
let
menuItem
=
document
.
createElement
(
"
menuseparator
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
menuItem
=
document
.
createElement
(
"
menuitem
"
)
;
menuItem
.
className
=
"
manage
-
app
-
item
"
;
menuItem
.
addEventListener
(
"
command
"
function
(
e
)
{
gMainPane
.
manageApp
(
e
)
;
}
)
;
menuItem
.
setAttribute
(
"
label
"
gMainPane
.
_prefsBundle
.
getString
(
"
manageApp
"
)
)
;
menuPopup
.
appendChild
(
menuItem
)
;
}
if
(
handlerInfo
.
alwaysAskBeforeHandling
)
menu
.
selectedItem
=
askMenuItem
;
else
switch
(
handlerInfo
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
internalMenuItem
)
{
menu
.
selectedItem
=
internalMenuItem
;
}
else
{
Cu
.
reportError
(
"
No
menu
item
defined
to
set
!
"
)
;
}
break
;
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
menu
.
selectedItem
=
defaultMenuItem
;
break
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
if
(
preferredApp
)
menu
.
selectedItem
=
possibleAppMenuItems
.
filter
(
v
=
>
v
.
handlerApp
.
equals
(
preferredApp
)
)
[
0
]
;
break
;
case
kActionUsePlugin
:
menu
.
selectedItem
=
pluginMenuItem
;
break
;
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
menu
.
selectedItem
=
saveMenuItem
;
break
;
}
}
_sortColumn
:
null
sort
(
event
)
{
var
column
=
event
.
target
;
if
(
this
.
_sortColumn
&
&
this
.
_sortColumn
!
=
column
)
this
.
_sortColumn
.
removeAttribute
(
"
sortDirection
"
)
;
this
.
_sortColumn
=
column
;
if
(
column
.
getAttribute
(
"
sortDirection
"
)
=
=
"
ascending
"
)
column
.
setAttribute
(
"
sortDirection
"
"
descending
"
)
;
else
column
.
setAttribute
(
"
sortDirection
"
"
ascending
"
)
;
this
.
_sortVisibleTypes
(
)
;
this
.
_rebuildView
(
)
;
}
_sortVisibleTypes
(
)
{
if
(
!
this
.
_sortColumn
)
return
;
function
sortByType
(
a
b
)
{
return
a
.
typeDescription
.
toLowerCase
(
)
.
localeCompare
(
b
.
typeDescription
.
toLowerCase
(
)
)
;
}
function
sortByAction
(
a
b
)
{
return
a
.
actionDescription
.
toLowerCase
(
)
.
localeCompare
(
b
.
actionDescription
.
toLowerCase
(
)
)
;
}
switch
(
this
.
_sortColumn
.
getAttribute
(
"
value
"
)
)
{
case
"
type
"
:
this
.
_visibleTypes
.
sort
(
sortByType
)
;
break
;
case
"
action
"
:
this
.
_visibleTypes
.
sort
(
sortByAction
)
;
break
;
}
if
(
this
.
_sortColumn
.
getAttribute
(
"
sortDirection
"
)
=
=
"
descending
"
)
this
.
_visibleTypes
.
reverse
(
)
;
}
filter
(
)
{
this
.
_rebuildView
(
)
;
}
focusFilterBox
(
)
{
this
.
_filter
.
focus
(
)
;
this
.
_filter
.
select
(
)
;
}
_storingAction
:
false
onSelectAction
(
aActionItem
)
{
this
.
_storingAction
=
true
;
try
{
this
.
_storeAction
(
aActionItem
)
;
}
finally
{
this
.
_storingAction
=
false
;
}
}
_storeAction
(
aActionItem
)
{
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
let
action
=
parseInt
(
aActionItem
.
getAttribute
(
"
action
"
)
)
;
if
(
action
=
=
kActionUsePlugin
)
handlerInfo
.
enablePluginType
(
)
;
else
if
(
handlerInfo
.
pluginName
&
&
!
handlerInfo
.
isDisabledPluginType
)
handlerInfo
.
disablePluginType
(
)
;
if
(
action
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
)
handlerInfo
.
preferredApplicationHandler
=
aActionItem
.
handlerApp
;
if
(
action
=
=
Ci
.
nsIHandlerInfo
.
alwaysAsk
)
handlerInfo
.
alwaysAskBeforeHandling
=
true
;
else
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
handlerInfo
.
preferredAction
=
action
;
handlerInfo
.
store
(
)
;
handlerInfo
.
handledOnlyByPlugin
=
false
;
this
.
selectedHandlerListItem
.
refreshAction
(
)
;
}
manageApp
(
aEvent
)
{
aEvent
.
stopPropagation
(
)
;
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
let
onComplete
=
(
)
=
>
{
this
.
rebuildActionsMenu
(
)
;
this
.
selectedHandlerListItem
.
refreshAction
(
)
;
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
applicationManager
.
xul
"
"
resizable
=
no
"
handlerInfo
onComplete
)
;
}
chooseApp
(
aEvent
)
{
aEvent
.
stopPropagation
(
)
;
var
handlerApp
;
let
chooseAppCallback
=
aHandlerApp
=
>
{
this
.
rebuildActionsMenu
(
)
;
if
(
aHandlerApp
)
{
let
typeItem
=
this
.
_list
.
selectedItem
;
let
actionsMenu
=
typeItem
.
querySelector
(
"
.
actionsMenu
"
)
;
let
menuItems
=
actionsMenu
.
menupopup
.
childNodes
;
for
(
let
i
=
0
;
i
<
menuItems
.
length
;
i
+
+
)
{
let
menuItem
=
menuItems
[
i
]
;
if
(
menuItem
.
handlerApp
&
&
menuItem
.
handlerApp
.
equals
(
aHandlerApp
)
)
{
actionsMenu
.
selectedIndex
=
i
;
this
.
onSelectAction
(
menuItem
)
;
break
;
}
}
}
}
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
var
params
=
{
}
;
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
if
(
isFeedType
(
handlerInfo
.
type
)
)
{
params
.
mimeInfo
=
gMIMEService
.
getFromTypeAndExtension
(
handlerInfo
.
type
handlerInfo
.
primaryExtension
)
;
}
else
{
params
.
mimeInfo
=
handlerInfo
.
wrappedHandlerInfo
;
}
params
.
title
=
gMainPane
.
_prefsBundle
.
getString
(
"
fpTitleChooseApp
"
)
;
params
.
description
=
handlerInfo
.
description
;
params
.
filename
=
null
;
params
.
handlerApp
=
null
;
let
onAppSelected
=
(
)
=
>
{
if
(
this
.
isValidHandlerApp
(
params
.
handlerApp
)
)
{
handlerApp
=
params
.
handlerApp
;
handlerInfo
.
addPossibleApplicationHandler
(
handlerApp
)
;
}
chooseAppCallback
(
handlerApp
)
;
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
global
/
content
/
appPicker
.
xul
"
null
params
onAppSelected
)
;
}
else
{
let
winTitle
=
gMainPane
.
_prefsBundle
.
getString
(
"
fpTitleChooseApp
"
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
fpCallback
=
aResult
=
>
{
if
(
aResult
=
=
Ci
.
nsIFilePicker
.
returnOK
&
&
fp
.
file
&
&
this
.
_isValidHandlerExecutable
(
fp
.
file
)
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
name
=
getFileDisplayName
(
fp
.
file
)
;
handlerApp
.
executable
=
fp
.
file
;
let
handler
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
handler
.
addPossibleApplicationHandler
(
handlerApp
)
;
chooseAppCallback
(
handlerApp
)
;
}
}
;
fp
.
init
(
window
winTitle
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterApps
)
;
fp
.
open
(
fpCallback
)
;
}
}
_getIconURLForHandlerApp
(
aHandlerApp
)
{
if
(
aHandlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
return
this
.
_getIconURLForFile
(
aHandlerApp
.
executable
)
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
return
this
.
_getIconURLForWebApp
(
aHandlerApp
.
uriTemplate
)
;
if
(
aHandlerApp
instanceof
Ci
.
nsIWebContentHandlerInfo
)
return
this
.
_getIconURLForWebApp
(
aHandlerApp
.
uri
)
;
return
"
"
;
}
_getIconURLForFile
(
aFile
)
{
var
fph
=
Services
.
io
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
var
urlSpec
=
fph
.
getURLSpecFromFile
(
aFile
)
;
return
"
moz
-
icon
:
/
/
"
+
urlSpec
+
"
?
size
=
16
"
;
}
_getIconURLForWebApp
(
aWebAppURITemplate
)
{
var
uri
=
Services
.
io
.
newURI
(
aWebAppURITemplate
)
;
if
(
/
^
https
?
/
.
test
(
uri
.
scheme
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
chrome
.
site_icons
"
)
)
return
uri
.
prePath
+
"
/
favicon
.
ico
"
;
return
"
"
;
}
readUseDownloadDir
(
)
{
var
downloadFolder
=
document
.
getElementById
(
"
downloadFolder
"
)
;
var
chooseFolder
=
document
.
getElementById
(
"
chooseFolder
"
)
;
var
preference
=
Preferences
.
get
(
"
browser
.
download
.
useDownloadDir
"
)
;
downloadFolder
.
disabled
=
!
preference
.
value
|
|
preference
.
locked
;
chooseFolder
.
disabled
=
!
preference
.
value
|
|
preference
.
locked
;
this
.
readCloudStorage
(
)
.
catch
(
Cu
.
reportError
)
;
return
undefined
;
}
async
readCloudStorage
(
)
{
let
providerDisplayName
=
await
CloudStorage
.
getProviderIfInUse
(
)
;
if
(
providerDisplayName
)
{
let
saveToCloudRadio
=
document
.
getElementById
(
"
saveToCloud
"
)
;
let
cloudStrings
=
Services
.
strings
.
createBundle
(
"
resource
:
/
/
cloudstorage
/
preferences
.
properties
"
)
;
saveToCloudRadio
.
label
=
cloudStrings
.
formatStringFromName
(
"
saveFilesToCloudStorage
"
[
providerDisplayName
]
1
)
;
saveToCloudRadio
.
hidden
=
false
;
let
useDownloadDirPref
=
Preferences
.
get
(
"
browser
.
download
.
useDownloadDir
"
)
;
let
folderListPref
=
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
;
if
(
useDownloadDirPref
.
value
&
&
folderListPref
.
value
=
=
=
3
)
{
document
.
getElementById
(
"
saveWhere
"
)
.
selectedItem
=
saveToCloudRadio
;
document
.
getElementById
(
"
downloadFolder
"
)
.
disabled
=
true
;
document
.
getElementById
(
"
chooseFolder
"
)
.
disabled
=
true
;
}
}
}
handleSaveToCommand
(
event
)
{
return
this
.
handleSaveToCommandTask
(
event
)
.
catch
(
Cu
.
reportError
)
;
}
async
handleSaveToCommandTask
(
event
)
{
if
(
event
.
target
.
id
!
=
=
"
saveToCloud
"
&
&
event
.
target
.
id
!
=
=
"
saveTo
"
)
{
return
;
}
let
saveToCloudRadio
=
document
.
getElementById
(
"
saveToCloud
"
)
;
if
(
!
saveToCloudRadio
.
hidden
)
{
let
saveWhere
=
document
.
getElementById
(
"
saveWhere
"
)
;
let
useDownloadDirPref
=
Preferences
.
get
(
"
browser
.
download
.
useDownloadDir
"
)
;
if
(
useDownloadDirPref
.
value
)
{
let
downloadFolder
=
document
.
getElementById
(
"
downloadFolder
"
)
;
let
chooseFolder
=
document
.
getElementById
(
"
chooseFolder
"
)
;
downloadFolder
.
disabled
=
saveWhere
.
selectedIndex
|
|
useDownloadDirPref
.
locked
;
chooseFolder
.
disabled
=
saveWhere
.
selectedIndex
|
|
useDownloadDirPref
.
locked
;
}
let
folderListPref
=
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
;
let
saveTo
=
document
.
getElementById
(
"
saveTo
"
)
;
if
(
saveWhere
.
selectedItem
=
=
saveToCloudRadio
)
{
folderListPref
.
value
=
3
;
}
else
if
(
saveWhere
.
selectedItem
=
=
saveTo
)
{
let
currentDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
folderListPref
.
value
=
currentDirPref
.
value
?
await
this
.
_folderToIndex
(
currentDirPref
.
value
)
:
1
;
}
}
}
chooseFolder
(
)
{
return
this
.
chooseFolderTask
(
)
.
catch
(
Cu
.
reportError
)
;
}
async
chooseFolderTask
(
)
{
let
title
=
gMainPane
.
_prefsBundle
.
getString
(
"
chooseDownloadFolderTitle
"
)
;
let
folderListPref
=
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
;
let
currentDirPref
=
await
this
.
_indexToFolder
(
folderListPref
.
value
)
;
let
defDownloads
=
await
this
.
_indexToFolder
(
1
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
title
Ci
.
nsIFilePicker
.
modeGetFolder
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterAll
)
;
if
(
currentDirPref
&
&
currentDirPref
.
exists
(
)
)
{
fp
.
displayDirectory
=
currentDirPref
;
}
else
if
(
defDownloads
&
&
defDownloads
.
exists
(
)
)
{
fp
.
displayDirectory
=
defDownloads
;
}
else
{
fp
.
displayDirectory
=
await
this
.
_indexToFolder
(
0
)
;
}
let
result
=
await
new
Promise
(
resolve
=
>
fp
.
open
(
resolve
)
)
;
if
(
result
!
=
Ci
.
nsIFilePicker
.
returnOK
)
{
return
;
}
let
downloadDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
downloadDirPref
.
value
=
fp
.
file
;
folderListPref
.
value
=
await
this
.
_folderToIndex
(
fp
.
file
)
;
}
displayDownloadDirPref
(
)
{
this
.
displayDownloadDirPrefTask
(
)
.
catch
(
Cu
.
reportError
)
;
return
undefined
;
}
async
displayDownloadDirPrefTask
(
)
{
var
folderListPref
=
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
;
var
downloadFolder
=
document
.
getElementById
(
"
downloadFolder
"
)
;
var
currentDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
var
fph
=
Services
.
io
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
var
iconUrlSpec
;
let
folderIndex
=
folderListPref
.
value
;
if
(
folderIndex
=
=
3
)
{
folderIndex
=
currentDirPref
.
value
?
await
this
.
_folderToIndex
(
currentDirPref
.
value
)
:
1
;
}
if
(
folderIndex
=
=
2
)
{
downloadFolder
.
value
=
currentDirPref
.
value
?
\
u2066
{
currentDirPref
.
value
.
path
}
\
u2069
:
"
"
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
currentDirPref
.
value
)
;
}
else
if
(
folderIndex
=
=
1
)
{
downloadFolder
.
value
=
gMainPane
.
_prefsBundle
.
getString
(
"
downloadsFolderName
"
)
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
await
this
.
_indexToFolder
(
1
)
)
;
}
else
{
downloadFolder
.
value
=
gMainPane
.
_prefsBundle
.
getString
(
"
desktopFolderName
"
)
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
await
this
.
_getDownloadsFolder
(
"
Desktop
"
)
)
;
}
downloadFolder
.
style
.
backgroundImage
=
"
url
(
moz
-
icon
:
/
/
"
+
iconUrlSpec
+
"
?
size
=
16
)
"
;
}
async
_getDownloadsFolder
(
aFolder
)
{
switch
(
aFolder
)
{
case
"
Desktop
"
:
return
Services
.
dirsvc
.
get
(
"
Desk
"
Ci
.
nsIFile
)
;
case
"
Downloads
"
:
let
downloadsDir
=
await
Downloads
.
getSystemDownloadsDirectory
(
)
;
return
new
FileUtils
.
File
(
downloadsDir
)
;
}
throw
"
ASSERTION
FAILED
:
folder
type
should
be
'
Desktop
'
or
'
Downloads
'
"
;
}
async
_folderToIndex
(
aFolder
)
{
if
(
!
aFolder
|
|
aFolder
.
equals
(
await
this
.
_getDownloadsFolder
(
"
Desktop
"
)
)
)
return
0
;
else
if
(
aFolder
.
equals
(
await
this
.
_getDownloadsFolder
(
"
Downloads
"
)
)
)
return
1
;
return
2
;
}
_indexToFolder
(
aIndex
)
{
switch
(
aIndex
)
{
case
0
:
return
this
.
_getDownloadsFolder
(
"
Desktop
"
)
;
case
1
:
return
this
.
_getDownloadsFolder
(
"
Downloads
"
)
;
}
var
currentDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
return
currentDirPref
.
value
;
}
}
;
function
getFileDisplayName
(
file
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileWin
)
{
try
{
return
file
.
getVersionInfoField
(
"
FileDescription
"
)
;
}
catch
(
e
)
{
}
}
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileMac
)
{
try
{
return
file
.
bundleDisplayName
;
}
catch
(
e
)
{
}
}
}
return
file
.
leafName
;
}
function
getLocalHandlerApp
(
aFile
)
{
var
localHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandlerApp
.
name
=
getFileDisplayName
(
aFile
)
;
localHandlerApp
.
executable
=
aFile
;
return
localHandlerApp
;
}
function
ArrayEnumerator
(
aItems
)
{
this
.
_index
=
0
;
this
.
_contents
=
aItems
;
}
ArrayEnumerator
.
prototype
=
{
_index
:
0
hasMoreElements
(
)
{
return
this
.
_index
<
this
.
_contents
.
length
;
}
getNext
(
)
{
return
this
.
_contents
[
this
.
_index
+
+
]
;
}
}
;
function
isFeedType
(
t
)
{
return
t
=
=
TYPE_MAYBE_FEED
|
|
t
=
=
TYPE_MAYBE_VIDEO_FEED
|
|
t
=
=
TYPE_MAYBE_AUDIO_FEED
;
}
let
gHandlerListItemFragment
=
MozXULElement
.
parseXULToFragment
(
<
richlistitem
>
<
hbox
flex
=
"
1
"
equalsize
=
"
always
"
>
<
hbox
class
=
"
typeContainer
"
flex
=
"
1
"
align
=
"
center
"
>
<
image
class
=
"
typeIcon
"
width
=
"
16
"
height
=
"
16
"
src
=
"
moz
-
icon
:
/
/
goat
?
size
=
16
"
/
>
<
label
class
=
"
typeDescription
"
flex
=
"
1
"
crop
=
"
end
"
/
>
<
/
hbox
>
<
hbox
class
=
"
actionContainer
"
flex
=
"
1
"
align
=
"
center
"
>
<
image
class
=
"
actionIcon
"
width
=
"
16
"
height
=
"
16
"
/
>
<
label
class
=
"
actionDescription
"
flex
=
"
1
"
crop
=
"
end
"
/
>
<
/
hbox
>
<
hbox
class
=
"
actionsMenuContainer
"
flex
=
"
1
"
>
<
menulist
class
=
"
actionsMenu
"
flex
=
"
1
"
crop
=
"
end
"
selectedIndex
=
"
1
"
>
<
menupopup
/
>
<
/
menulist
>
<
/
hbox
>
<
/
hbox
>
<
/
richlistitem
>
)
;
class
HandlerListItem
{
static
forNode
(
node
)
{
return
gNodeToObjectMap
.
get
(
node
)
;
}
constructor
(
handlerInfoWrapper
)
{
this
.
handlerInfoWrapper
=
handlerInfoWrapper
;
}
setOrRemoveAttributes
(
iterable
)
{
for
(
let
[
selector
name
value
]
of
iterable
)
{
let
node
=
selector
?
this
.
node
.
querySelector
(
selector
)
:
this
.
node
;
if
(
value
)
{
node
.
setAttribute
(
name
value
)
;
}
else
{
node
.
removeAttribute
(
name
)
;
}
}
}
connectAndAppendToList
(
list
)
{
list
.
appendChild
(
document
.
importNode
(
gHandlerListItemFragment
true
)
)
;
this
.
node
=
list
.
lastChild
;
gNodeToObjectMap
.
set
(
this
.
node
this
)
;
this
.
node
.
querySelector
(
"
.
actionsMenu
"
)
.
addEventListener
(
"
command
"
event
=
>
gMainPane
.
onSelectAction
(
event
.
originalTarget
)
)
;
let
typeDescription
=
this
.
handlerInfoWrapper
.
typeDescription
;
this
.
setOrRemoveAttributes
(
[
[
null
"
type
"
this
.
handlerInfoWrapper
.
type
]
[
"
.
typeContainer
"
"
tooltiptext
"
typeDescription
]
[
"
.
typeDescription
"
"
value
"
typeDescription
]
[
"
.
typeIcon
"
"
src
"
this
.
handlerInfoWrapper
.
smallIcon
]
]
)
;
this
.
refreshAction
(
)
;
this
.
showActionsMenu
=
false
;
}
refreshAction
(
)
{
let
{
actionIconClass
actionDescription
}
=
this
.
handlerInfoWrapper
;
this
.
setOrRemoveAttributes
(
[
[
null
APP_ICON_ATTR_NAME
actionIconClass
]
[
"
.
actionContainer
"
"
tooltiptext
"
actionDescription
]
[
"
.
actionDescription
"
"
value
"
actionDescription
]
[
"
.
actionIcon
"
"
src
"
actionIconClass
?
null
:
this
.
handlerInfoWrapper
.
actionIcon
]
]
)
;
}
set
showActionsMenu
(
value
)
{
this
.
setOrRemoveAttributes
(
[
[
"
.
actionContainer
"
"
hidden
"
value
]
[
"
.
actionsMenuContainer
"
"
hidden
"
!
value
]
]
)
;
}
}
class
HandlerInfoWrapper
{
constructor
(
type
handlerInfo
)
{
this
.
type
=
type
;
this
.
wrappedHandlerInfo
=
handlerInfo
;
this
.
disambiguateDescription
=
false
;
this
.
pluginName
=
"
"
;
this
.
handledOnlyByPlugin
=
false
;
}
get
description
(
)
{
if
(
this
.
wrappedHandlerInfo
.
description
)
return
this
.
wrappedHandlerInfo
.
description
;
if
(
this
.
primaryExtension
)
{
var
extension
=
this
.
primaryExtension
.
toUpperCase
(
)
;
return
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
fileEnding
"
[
extension
]
)
;
}
return
this
.
type
;
}
get
typeDescription
(
)
{
if
(
this
.
disambiguateDescription
)
{
return
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
typeDescriptionWithType
"
[
this
.
description
this
.
type
]
)
;
}
return
this
.
description
;
}
get
actionDescription
(
)
{
if
(
this
.
alwaysAskBeforeHandling
)
{
if
(
isFeedType
(
this
.
type
)
)
return
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
previewInApp
"
[
gMainPane
.
_brandShortName
]
)
;
return
gMainPane
.
_prefsBundle
.
getString
(
"
alwaysAsk
"
)
;
}
switch
(
this
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
return
gMainPane
.
_prefsBundle
.
getString
(
"
saveFile
"
)
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
var
preferredApp
=
this
.
preferredApplicationHandler
;
var
name
;
if
(
preferredApp
instanceof
Ci
.
nsILocalHandlerApp
)
name
=
getFileDisplayName
(
preferredApp
.
executable
)
;
else
name
=
preferredApp
.
name
;
return
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
useApp
"
[
name
]
)
;
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
isFeedType
(
this
.
type
)
)
{
return
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
addLiveBookmarksInApp
"
[
gMainPane
.
_brandShortName
]
)
;
}
if
(
this
instanceof
InternalHandlerInfoWrapper
)
{
return
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
previewInApp
"
[
gMainPane
.
_brandShortName
]
)
;
}
if
(
gMainPane
.
isValidHandlerApp
(
this
.
preferredApplicationHandler
)
)
return
this
.
preferredApplicationHandler
.
name
;
return
this
.
defaultDescription
;
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
return
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
useDefault
"
[
this
.
defaultDescription
]
)
;
case
kActionUsePlugin
:
return
gMainPane
.
_prefsBundle
.
getFormattedString
(
"
usePluginIn
"
[
this
.
pluginName
gMainPane
.
_brandShortName
]
)
;
default
:
throw
new
Error
(
Unexpected
preferredAction
:
{
this
.
preferredAction
}
)
;
}
}
get
actionIconClass
(
)
{
if
(
this
.
alwaysAskBeforeHandling
)
{
return
"
ask
"
;
}
switch
(
this
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
return
"
save
"
;
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
isFeedType
(
this
.
type
)
)
{
return
"
feed
"
;
}
else
if
(
this
instanceof
InternalHandlerInfoWrapper
)
{
return
"
ask
"
;
}
case
kActionUsePlugin
:
return
"
plugin
"
;
}
return
"
"
;
}
get
actionIcon
(
)
{
switch
(
this
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
return
this
.
iconURLForSystemDefault
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
let
preferredApp
=
this
.
preferredApplicationHandler
;
if
(
gMainPane
.
isValidHandlerApp
(
preferredApp
)
)
{
return
gMainPane
.
_getIconURLForHandlerApp
(
preferredApp
)
;
}
default
:
return
ICON_URL_APP
;
}
}
get
iconURLForSystemDefault
(
)
{
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIPropertyBag
)
{
try
{
let
url
=
this
.
wrappedHandlerInfo
.
getProperty
(
"
defaultApplicationIconURL
"
)
;
if
(
url
)
{
return
url
+
"
?
size
=
16
"
;
}
}
catch
(
ex
)
{
}
}
return
ICON_URL_APP
;
}
get
preferredApplicationHandler
(
)
{
return
this
.
wrappedHandlerInfo
.
preferredApplicationHandler
;
}
set
preferredApplicationHandler
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
preferredApplicationHandler
=
aNewValue
;
if
(
aNewValue
)
this
.
addPossibleApplicationHandler
(
aNewValue
)
;
}
get
possibleApplicationHandlers
(
)
{
return
this
.
wrappedHandlerInfo
.
possibleApplicationHandlers
;
}
addPossibleApplicationHandler
(
aNewHandler
)
{
var
possibleApps
=
this
.
possibleApplicationHandlers
.
enumerate
(
)
;
while
(
possibleApps
.
hasMoreElements
(
)
)
{
if
(
possibleApps
.
getNext
(
)
.
equals
(
aNewHandler
)
)
return
;
}
this
.
possibleApplicationHandlers
.
appendElement
(
aNewHandler
)
;
}
removePossibleApplicationHandler
(
aHandler
)
{
var
defaultApp
=
this
.
preferredApplicationHandler
;
if
(
defaultApp
&
&
aHandler
.
equals
(
defaultApp
)
)
{
this
.
alwaysAskBeforeHandling
=
true
;
this
.
preferredApplicationHandler
=
null
;
}
var
handlers
=
this
.
possibleApplicationHandlers
;
for
(
var
i
=
0
;
i
<
handlers
.
length
;
+
+
i
)
{
var
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
equals
(
aHandler
)
)
{
handlers
.
removeElementAt
(
i
)
;
break
;
}
}
}
get
hasDefaultHandler
(
)
{
return
this
.
wrappedHandlerInfo
.
hasDefaultHandler
;
}
get
defaultDescription
(
)
{
return
this
.
wrappedHandlerInfo
.
defaultDescription
;
}
get
preferredAction
(
)
{
if
(
this
.
pluginName
&
&
!
this
.
isDisabledPluginType
)
return
kActionUsePlugin
;
if
(
this
.
wrappedHandlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
&
&
!
gMainPane
.
isValidHandlerApp
(
this
.
preferredApplicationHandler
)
)
{
if
(
this
.
wrappedHandlerInfo
.
hasDefaultHandler
)
return
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
return
Ci
.
nsIHandlerInfo
.
saveToDisk
;
}
return
this
.
wrappedHandlerInfo
.
preferredAction
;
}
set
preferredAction
(
aNewValue
)
{
if
(
(
aNewValue
=
=
kActionUsePlugin
)
&
&
(
this
.
preferredAction
!
=
Ci
.
nsIHandlerInfo
.
saveToDisk
)
)
{
aNewValue
=
Ci
.
nsIHandlerInfo
.
saveToDisk
;
}
if
(
aNewValue
!
=
kActionUsePlugin
)
this
.
wrappedHandlerInfo
.
preferredAction
=
aNewValue
;
}
get
alwaysAskBeforeHandling
(
)
{
if
(
this
.
pluginName
&
&
this
.
handledOnlyByPlugin
)
return
false
;
if
(
!
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
&
&
this
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
saveToDisk
)
return
true
;
return
this
.
wrappedHandlerInfo
.
alwaysAskBeforeHandling
;
}
set
alwaysAskBeforeHandling
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
alwaysAskBeforeHandling
=
aNewValue
;
}
get
primaryExtension
(
)
{
try
{
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
this
.
wrappedHandlerInfo
.
primaryExtension
)
return
this
.
wrappedHandlerInfo
.
primaryExtension
;
}
catch
(
ex
)
{
}
return
null
;
}
get
isDisabledPluginType
(
)
{
return
this
.
_getDisabledPluginTypes
(
)
.
includes
(
this
.
type
)
;
}
_getDisabledPluginTypes
(
)
{
var
types
=
"
"
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_DISABLED_PLUGIN_TYPES
)
)
types
=
Services
.
prefs
.
getCharPref
(
PREF_DISABLED_PLUGIN_TYPES
)
;
if
(
types
!
=
"
"
)
return
types
.
split
(
"
"
)
;
return
[
]
;
}
disablePluginType
(
)
{
var
disabledPluginTypes
=
this
.
_getDisabledPluginTypes
(
)
;
if
(
!
disabledPluginTypes
.
includes
(
this
.
type
)
)
disabledPluginTypes
.
push
(
this
.
type
)
;
Services
.
prefs
.
setCharPref
(
PREF_DISABLED_PLUGIN_TYPES
disabledPluginTypes
.
join
(
"
"
)
)
;
gCategoryManager
.
deleteCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
this
.
type
false
)
;
}
enablePluginType
(
)
{
var
disabledPluginTypes
=
this
.
_getDisabledPluginTypes
(
)
;
var
type
=
this
.
type
;
disabledPluginTypes
=
disabledPluginTypes
.
filter
(
v
=
>
v
!
=
type
)
;
Services
.
prefs
.
setCharPref
(
PREF_DISABLED_PLUGIN_TYPES
disabledPluginTypes
.
join
(
"
"
)
)
;
gCategoryManager
.
addCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
this
.
type
"
mozilla
.
org
/
content
/
plugin
/
document
-
loader
-
factory
;
1
"
false
true
)
;
}
store
(
)
{
gHandlerService
.
store
(
this
.
wrappedHandlerInfo
)
;
}
get
smallIcon
(
)
{
return
this
.
_getIcon
(
16
)
;
}
_getIcon
(
aSize
)
{
if
(
this
.
primaryExtension
)
return
"
moz
-
icon
:
/
/
goat
.
"
+
this
.
primaryExtension
+
"
?
size
=
"
+
aSize
;
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
return
"
moz
-
icon
:
/
/
goat
?
size
=
"
+
aSize
+
"
&
contentType
=
"
+
this
.
type
;
return
null
;
}
}
class
FeedHandlerInfo
extends
HandlerInfoWrapper
{
constructor
(
aMIMEType
properties
)
{
super
(
aMIMEType
null
)
;
Object
.
assign
(
this
properties
)
;
}
get
description
(
)
{
return
gMainPane
.
_prefsBundle
.
getString
(
this
.
_appPrefLabel
)
;
}
get
preferredApplicationHandler
(
)
{
switch
(
Preferences
.
get
(
this
.
_prefSelectedReader
)
.
value
)
{
case
"
client
"
:
var
file
=
Preferences
.
get
(
this
.
_prefSelectedApp
)
.
value
;
if
(
file
)
return
getLocalHandlerApp
(
file
)
;
return
null
;
case
"
web
"
:
var
uri
=
Preferences
.
get
(
this
.
_prefSelectedWeb
)
.
value
;
if
(
!
uri
)
return
null
;
return
gWebContentContentConverterService
.
getWebContentHandlerByURI
(
this
.
type
uri
)
;
case
"
bookmarks
"
:
default
:
return
null
;
}
}
set
preferredApplicationHandler
(
aNewValue
)
{
if
(
aNewValue
instanceof
Ci
.
nsILocalHandlerApp
)
{
Preferences
.
get
(
this
.
_prefSelectedApp
)
.
value
=
aNewValue
.
executable
;
Preferences
.
get
(
this
.
_prefSelectedReader
)
.
value
=
"
client
"
;
}
else
if
(
aNewValue
instanceof
Ci
.
nsIWebContentHandlerInfo
)
{
Preferences
.
get
(
this
.
_prefSelectedWeb
)
.
value
=
aNewValue
.
uri
;
Preferences
.
get
(
this
.
_prefSelectedReader
)
.
value
=
"
web
"
;
gWebContentContentConverterService
.
setAutoHandler
(
this
.
type
aNewValue
)
;
}
}
get
possibleApplicationHandlers
(
)
{
if
(
this
.
_possibleApplicationHandlers
)
return
this
.
_possibleApplicationHandlers
;
this
.
_possibleApplicationHandlers
=
{
_inner
:
[
]
_removed
:
[
]
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIMutableArray
"
"
nsIArray
"
]
)
get
length
(
)
{
return
this
.
_inner
.
length
;
}
enumerate
(
)
{
return
new
ArrayEnumerator
(
this
.
_inner
)
;
}
appendElement
(
aHandlerApp
aWeak
)
{
this
.
_inner
.
push
(
aHandlerApp
)
;
}
removeElementAt
(
aIndex
)
{
this
.
_removed
.
push
(
this
.
_inner
[
aIndex
]
)
;
this
.
_inner
.
splice
(
aIndex
1
)
;
}
queryElementAt
(
aIndex
aInterface
)
{
return
this
.
_inner
[
aIndex
]
.
QueryInterface
(
aInterface
)
;
}
}
;
var
preferredAppFile
=
Preferences
.
get
(
this
.
_prefSelectedApp
)
.
value
;
if
(
preferredAppFile
)
{
let
preferredApp
=
getLocalHandlerApp
(
preferredAppFile
)
;
let
defaultApp
=
this
.
_defaultApplicationHandler
;
if
(
!
defaultApp
|
|
!
defaultApp
.
equals
(
preferredApp
)
)
this
.
_possibleApplicationHandlers
.
appendElement
(
preferredApp
)
;
}
var
webHandlers
=
gWebContentContentConverterService
.
getContentHandlers
(
this
.
type
)
;
for
(
let
webHandler
of
webHandlers
)
this
.
_possibleApplicationHandlers
.
appendElement
(
webHandler
)
;
return
this
.
_possibleApplicationHandlers
;
}
get
_defaultApplicationHandler
(
)
{
if
(
typeof
this
.
__defaultApplicationHandler
!
=
"
undefined
"
)
return
this
.
__defaultApplicationHandler
;
var
defaultFeedReader
=
null
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
try
{
defaultFeedReader
=
getShellService
(
)
.
defaultFeedReader
;
}
catch
(
ex
)
{
}
}
if
(
defaultFeedReader
)
{
let
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIHandlerApp
)
;
handlerApp
.
name
=
getFileDisplayName
(
defaultFeedReader
)
;
handlerApp
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
executable
=
defaultFeedReader
;
this
.
__defaultApplicationHandler
=
handlerApp
;
}
else
{
this
.
__defaultApplicationHandler
=
null
;
}
return
this
.
__defaultApplicationHandler
;
}
get
hasDefaultHandler
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
try
{
if
(
getShellService
(
)
.
defaultFeedReader
)
return
true
;
}
catch
(
ex
)
{
}
}
return
false
;
}
get
defaultDescription
(
)
{
if
(
this
.
hasDefaultHandler
)
return
this
.
_defaultApplicationHandler
.
name
;
return
"
"
;
}
get
preferredAction
(
)
{
switch
(
Preferences
.
get
(
this
.
_prefSelectedAction
)
.
value
)
{
case
"
bookmarks
"
:
return
Ci
.
nsIHandlerInfo
.
handleInternally
;
case
"
reader
"
:
{
let
preferredApp
=
this
.
preferredApplicationHandler
;
let
defaultApp
=
this
.
_defaultApplicationHandler
;
if
(
gMainPane
.
isValidHandlerApp
(
preferredApp
)
)
{
if
(
defaultApp
&
&
defaultApp
.
equals
(
preferredApp
)
)
return
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
return
Ci
.
nsIHandlerInfo
.
useHelperApp
;
}
return
Ci
.
nsIHandlerInfo
.
handleInternally
;
}
case
"
ask
"
:
default
:
return
Ci
.
nsIHandlerInfo
.
handleInternally
;
}
}
set
preferredAction
(
aNewValue
)
{
switch
(
aNewValue
)
{
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
Preferences
.
get
(
this
.
_prefSelectedReader
)
.
value
=
"
bookmarks
"
;
break
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
Preferences
.
get
(
this
.
_prefSelectedAction
)
.
value
=
"
reader
"
;
break
;
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
Preferences
.
get
(
this
.
_prefSelectedAction
)
.
value
=
"
reader
"
;
this
.
preferredApplicationHandler
=
this
.
_defaultApplicationHandler
;
break
;
}
}
get
alwaysAskBeforeHandling
(
)
{
return
Preferences
.
get
(
this
.
_prefSelectedAction
)
.
value
=
=
"
ask
"
;
}
set
alwaysAskBeforeHandling
(
aNewValue
)
{
if
(
aNewValue
)
Preferences
.
get
(
this
.
_prefSelectedAction
)
.
value
=
"
ask
"
;
else
Preferences
.
get
(
this
.
_prefSelectedAction
)
.
value
=
"
reader
"
;
}
get
primaryExtension
(
)
{
return
"
xml
"
;
}
store
(
)
{
for
(
let
app
of
this
.
_possibleApplicationHandlers
.
_removed
)
{
if
(
app
instanceof
Ci
.
nsILocalHandlerApp
)
{
let
pref
=
Preferences
.
get
(
PREF_FEED_SELECTED_APP
)
;
var
preferredAppFile
=
pref
.
value
;
if
(
preferredAppFile
)
{
let
preferredApp
=
getLocalHandlerApp
(
preferredAppFile
)
;
if
(
app
.
equals
(
preferredApp
)
)
pref
.
reset
(
)
;
}
}
else
{
app
.
QueryInterface
(
Ci
.
nsIWebContentHandlerInfo
)
;
gWebContentContentConverterService
.
removeContentHandler
(
app
.
contentType
app
.
uri
)
;
}
}
this
.
_possibleApplicationHandlers
.
_removed
=
[
]
;
}
get
smallIcon
(
)
{
return
this
.
_smallIcon
;
}
}
var
feedHandlerInfo
=
new
FeedHandlerInfo
(
TYPE_MAYBE_FEED
{
_prefSelectedApp
:
PREF_FEED_SELECTED_APP
_prefSelectedWeb
:
PREF_FEED_SELECTED_WEB
_prefSelectedAction
:
PREF_FEED_SELECTED_ACTION
_prefSelectedReader
:
PREF_FEED_SELECTED_READER
_smallIcon
:
"
chrome
:
/
/
browser
/
skin
/
feeds
/
feedIcon16
.
png
"
_appPrefLabel
:
"
webFeed
"
}
)
;
var
videoFeedHandlerInfo
=
new
FeedHandlerInfo
(
TYPE_MAYBE_VIDEO_FEED
{
_prefSelectedApp
:
PREF_VIDEO_FEED_SELECTED_APP
_prefSelectedWeb
:
PREF_VIDEO_FEED_SELECTED_WEB
_prefSelectedAction
:
PREF_VIDEO_FEED_SELECTED_ACTION
_prefSelectedReader
:
PREF_VIDEO_FEED_SELECTED_READER
_smallIcon
:
"
chrome
:
/
/
browser
/
skin
/
feeds
/
videoFeedIcon16
.
png
"
_appPrefLabel
:
"
videoPodcastFeed
"
}
)
;
var
audioFeedHandlerInfo
=
new
FeedHandlerInfo
(
TYPE_MAYBE_AUDIO_FEED
{
_prefSelectedApp
:
PREF_AUDIO_FEED_SELECTED_APP
_prefSelectedWeb
:
PREF_AUDIO_FEED_SELECTED_WEB
_prefSelectedAction
:
PREF_AUDIO_FEED_SELECTED_ACTION
_prefSelectedReader
:
PREF_AUDIO_FEED_SELECTED_READER
_smallIcon
:
"
chrome
:
/
/
browser
/
skin
/
feeds
/
audioFeedIcon16
.
png
"
_appPrefLabel
:
"
audioPodcastFeed
"
}
)
;
class
InternalHandlerInfoWrapper
extends
HandlerInfoWrapper
{
constructor
(
mimeType
)
{
super
(
mimeType
gMIMEService
.
getFromTypeAndExtension
(
mimeType
null
)
)
;
}
store
(
)
{
super
.
store
(
)
;
Services
.
obs
.
notifyObservers
(
null
this
.
_handlerChanged
)
;
}
get
enabled
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
get
description
(
)
{
return
gMainPane
.
_prefsBundle
.
getString
(
this
.
_appPrefLabel
)
;
}
}
class
PDFHandlerInfoWrapper
extends
InternalHandlerInfoWrapper
{
constructor
(
)
{
super
(
TYPE_PDF
)
;
}
get
_handlerChanged
(
)
{
return
TOPIC_PDFJS_HANDLER_CHANGED
;
}
get
_appPrefLabel
(
)
{
return
"
portableDocumentFormat
"
;
}
get
enabled
(
)
{
return
!
Services
.
prefs
.
getBoolPref
(
PREF_PDFJS_DISABLED
)
&
&
Services
.
policies
.
isAllowed
(
"
PDF
.
js
"
)
;
}
}
