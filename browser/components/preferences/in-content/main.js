Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
TransientPrefs
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
if
(
AppConstants
.
E10S_TESTING_ONLY
)
{
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
}
var
gMainPane
=
{
init
(
)
{
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gMainPane
)
)
;
}
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
this
.
updateSetDefaultBrowser
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
window
.
setInterval
(
this
.
updateSetDefaultBrowser
.
bind
(
this
)
1000
)
;
}
}
this
.
_updateUseCurrentButton
(
)
;
window
.
addEventListener
(
"
focus
"
this
.
_updateUseCurrentButton
.
bind
(
this
)
false
)
;
this
.
updateBrowserStartupLastSession
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
try
{
let
sysInfo
=
Cc
[
"
mozilla
.
org
/
system
-
info
;
1
"
]
.
getService
(
Ci
.
nsIPropertyBag2
)
;
let
ver
=
parseFloat
(
sysInfo
.
getProperty
(
"
version
"
)
)
;
let
showTabsInTaskbar
=
document
.
getElementById
(
"
showTabsInTaskbar
"
)
;
showTabsInTaskbar
.
hidden
=
ver
<
6
.
1
;
}
catch
(
ex
)
{
}
}
if
(
!
TransientPrefs
.
prefShouldBeVisible
(
"
browser
.
tabs
.
warnOnClose
"
)
)
document
.
getElementById
(
"
warnCloseMultiple
"
)
.
hidden
=
true
;
if
(
!
TransientPrefs
.
prefShouldBeVisible
(
"
browser
.
tabs
.
warnOnOpen
"
)
)
document
.
getElementById
(
"
warnOpenMany
"
)
.
hidden
=
true
;
setEventListener
(
"
browser
.
privatebrowsing
.
autostart
"
"
change
"
gMainPane
.
updateBrowserStartupLastSession
)
;
setEventListener
(
"
browser
.
download
.
dir
"
"
change
"
gMainPane
.
displayDownloadDirPref
)
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
setEventListener
(
"
setDefaultButton
"
"
command
"
gMainPane
.
setDefaultBrowser
)
;
}
setEventListener
(
"
useCurrent
"
"
command
"
gMainPane
.
setHomePageToCurrent
)
;
setEventListener
(
"
useBookmark
"
"
command
"
gMainPane
.
setHomePageToBookmark
)
;
setEventListener
(
"
restoreDefaultHomePage
"
"
command
"
gMainPane
.
restoreDefaultHomePage
)
;
setEventListener
(
"
chooseFolder
"
"
command
"
gMainPane
.
chooseFolder
)
;
if
(
AppConstants
.
E10S_TESTING_ONLY
)
{
setEventListener
(
"
e10sAutoStart
"
"
command
"
gMainPane
.
enableE10SChange
)
;
let
e10sCheckbox
=
document
.
getElementById
(
"
e10sAutoStart
"
)
;
let
e10sPref
=
document
.
getElementById
(
"
browser
.
tabs
.
remote
.
autostart
"
)
;
let
e10sTempPref
=
document
.
getElementById
(
"
e10sTempPref
"
)
;
let
e10sForceEnable
=
document
.
getElementById
(
"
e10sForceEnable
"
)
;
let
preffedOn
=
e10sPref
.
value
|
|
e10sTempPref
.
value
|
|
e10sForceEnable
.
value
;
if
(
preffedOn
)
{
e10sCheckbox
.
checked
=
Services
.
appinfo
.
browserTabsRemoteAutostart
;
e10sCheckbox
.
disabled
=
!
Services
.
appinfo
.
browserTabsRemoteAutostart
;
}
}
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
let
uAppData
=
OS
.
Constants
.
Path
.
userApplicationDataDir
;
let
ignoreSeparateProfile
=
OS
.
Path
.
join
(
uAppData
"
ignore
-
dev
-
edition
-
profile
"
)
;
setEventListener
(
"
separateProfileMode
"
"
command
"
gMainPane
.
separateProfileModeChange
)
;
let
separateProfileModeCheckbox
=
document
.
getElementById
(
"
separateProfileMode
"
)
;
setEventListener
(
"
getStarted
"
"
click
"
gMainPane
.
onGetStarted
)
;
OS
.
File
.
stat
(
ignoreSeparateProfile
)
.
then
(
(
)
=
>
separateProfileModeCheckbox
.
checked
=
false
(
)
=
>
separateProfileModeCheckbox
.
checked
=
true
)
;
}
Components
.
classes
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIObserverService
)
.
notifyObservers
(
window
"
main
-
pane
-
loaded
"
null
)
;
}
enableE10SChange
(
)
{
if
(
AppConstants
.
E10S_TESTING_ONLY
)
{
let
e10sCheckbox
=
document
.
getElementById
(
"
e10sAutoStart
"
)
;
let
e10sPref
=
document
.
getElementById
(
"
browser
.
tabs
.
remote
.
autostart
"
)
;
let
e10sTempPref
=
document
.
getElementById
(
"
e10sTempPref
"
)
;
let
prefsToChange
;
if
(
e10sCheckbox
.
checked
)
{
prefsToChange
=
[
e10sPref
]
;
}
else
{
prefsToChange
=
[
e10sPref
]
;
if
(
e10sTempPref
.
value
)
{
prefsToChange
.
push
(
e10sTempPref
)
;
}
}
let
buttonIndex
=
confirmRestartPrompt
(
e10sCheckbox
.
checked
0
true
false
)
;
if
(
buttonIndex
=
=
CONFIRM_RESTART_PROMPT_RESTART_NOW
)
{
for
(
let
prefToChange
of
prefsToChange
)
{
prefToChange
.
value
=
e10sCheckbox
.
checked
;
}
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
}
e10sCheckbox
.
checked
=
e10sPref
.
value
|
|
e10sTempPref
.
value
;
}
}
separateProfileModeChange
(
)
{
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
function
quitApp
(
)
{
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestartNotSameProfile
)
;
}
function
revertCheckbox
(
error
)
{
separateProfileModeCheckbox
.
checked
=
!
separateProfileModeCheckbox
.
checked
;
if
(
error
)
{
Cu
.
reportError
(
"
Failed
to
toggle
separate
profile
mode
:
"
+
error
)
;
}
}
function
createOrRemoveSpecialDevEditionFile
(
onSuccess
)
{
let
uAppData
=
OS
.
Constants
.
Path
.
userApplicationDataDir
;
let
ignoreSeparateProfile
=
OS
.
Path
.
join
(
uAppData
"
ignore
-
dev
-
edition
-
profile
"
)
;
if
(
separateProfileModeCheckbox
.
checked
)
{
OS
.
File
.
remove
(
ignoreSeparateProfile
)
.
then
(
onSuccess
revertCheckbox
)
;
}
else
{
OS
.
File
.
writeAtomic
(
ignoreSeparateProfile
new
Uint8Array
(
)
)
.
then
(
onSuccess
revertCheckbox
)
;
}
}
let
separateProfileModeCheckbox
=
document
.
getElementById
(
"
separateProfileMode
"
)
;
let
button_index
=
confirmRestartPrompt
(
separateProfileModeCheckbox
.
checked
0
false
true
)
;
switch
(
button_index
)
{
case
CONFIRM_RESTART_PROMPT_CANCEL
:
revertCheckbox
(
)
;
return
;
case
CONFIRM_RESTART_PROMPT_RESTART_NOW
:
const
Cc
=
Components
.
classes
Ci
=
Components
.
interfaces
;
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
!
cancelQuit
.
data
)
{
createOrRemoveSpecialDevEditionFile
(
quitApp
)
;
return
;
}
revertCheckbox
(
)
;
return
;
case
CONFIRM_RESTART_PROMPT_RESTART_LATER
:
createOrRemoveSpecialDevEditionFile
(
)
;
}
}
}
onGetStarted
(
aEvent
)
{
if
(
AppConstants
.
MOZ_DEV_EDITION
)
{
const
Cc
=
Components
.
classes
Ci
=
Components
.
interfaces
;
let
wm
=
Cc
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
let
win
=
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
win
)
{
let
accountsTab
=
win
.
gBrowser
.
addTab
(
"
about
:
accounts
?
action
=
signin
&
entrypoint
=
dev
-
edition
-
setup
"
)
;
win
.
gBrowser
.
selectedTab
=
accountsTab
;
}
}
}
syncFromHomePref
(
)
{
let
homePref
=
document
.
getElementById
(
"
browser
.
startup
.
homepage
"
)
;
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
let
defaultValue
=
defaultBranch
.
getComplexValue
(
"
browser
.
startup
.
homepage
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
let
currentValue
=
homePref
.
value
.
toLowerCase
(
)
;
if
(
currentValue
=
=
"
about
:
home
"
|
|
(
currentValue
=
=
defaultValue
&
&
currentValue
=
=
"
about
:
newtab
"
)
)
{
return
"
"
;
}
if
(
homePref
.
value
=
=
"
"
)
return
"
about
:
blank
"
;
return
undefined
;
}
syncToHomePref
(
value
)
{
if
(
value
=
=
"
"
)
return
"
about
:
home
"
;
return
undefined
;
}
setHomePageToCurrent
(
)
{
let
homePage
=
document
.
getElementById
(
"
browser
.
startup
.
homepage
"
)
;
let
tabs
=
this
.
_getTabsForHomePage
(
)
;
function
getTabURI
(
t
)
{
return
t
.
linkedBrowser
.
currentURI
.
spec
;
}
if
(
tabs
.
length
)
homePage
.
value
=
tabs
.
map
(
getTabURI
)
.
join
(
"
|
"
)
;
}
setHomePageToBookmark
(
)
{
var
rv
=
{
urls
:
null
names
:
null
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
selectBookmark
.
xul
"
"
resizable
=
yes
modal
=
yes
"
rv
this
.
_setHomePageToBookmarkClosed
.
bind
(
this
rv
)
)
;
}
_setHomePageToBookmarkClosed
(
rv
aEvent
)
{
if
(
aEvent
.
detail
.
button
!
=
"
accept
"
)
return
;
if
(
rv
.
urls
&
&
rv
.
names
)
{
var
homePage
=
document
.
getElementById
(
"
browser
.
startup
.
homepage
"
)
;
homePage
.
value
=
rv
.
urls
.
join
(
"
|
"
)
;
}
}
_updateUseCurrentButton
(
)
{
let
useCurrent
=
document
.
getElementById
(
"
useCurrent
"
)
;
let
tabs
=
this
.
_getTabsForHomePage
(
)
;
if
(
tabs
.
length
>
1
)
useCurrent
.
label
=
useCurrent
.
getAttribute
(
"
label2
"
)
;
else
useCurrent
.
label
=
useCurrent
.
getAttribute
(
"
label1
"
)
;
let
prefName
=
"
pref
.
browser
.
homepage
.
disable_button
.
current_page
"
;
if
(
document
.
getElementById
(
prefName
)
.
locked
)
return
;
useCurrent
.
disabled
=
!
tabs
.
length
}
_getTabsForHomePage
(
)
{
var
win
;
var
tabs
=
[
]
;
const
Cc
=
Components
.
classes
Ci
=
Components
.
interfaces
;
var
wm
=
Cc
[
"
mozilla
.
org
/
appshell
/
window
-
mediator
;
1
"
]
.
getService
(
Ci
.
nsIWindowMediator
)
;
win
=
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
win
&
&
win
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
{
tabs
=
win
.
gBrowser
.
visibleTabs
.
slice
(
win
.
gBrowser
.
_numPinnedTabs
)
;
tabs
=
tabs
.
filter
(
this
.
isNotAboutPreferences
)
;
}
return
tabs
;
}
isNotAboutPreferences
(
aElement
aIndex
aArray
)
{
return
!
aElement
.
linkedBrowser
.
currentURI
.
spec
.
startsWith
(
"
about
:
preferences
"
)
;
}
restoreDefaultHomePage
(
)
{
var
homePage
=
document
.
getElementById
(
"
browser
.
startup
.
homepage
"
)
;
homePage
.
value
=
homePage
.
defaultValue
;
}
readUseDownloadDir
(
)
{
var
downloadFolder
=
document
.
getElementById
(
"
downloadFolder
"
)
;
var
chooseFolder
=
document
.
getElementById
(
"
chooseFolder
"
)
;
var
preference
=
document
.
getElementById
(
"
browser
.
download
.
useDownloadDir
"
)
;
downloadFolder
.
disabled
=
!
preference
.
value
|
|
preference
.
locked
;
chooseFolder
.
disabled
=
!
preference
.
value
|
|
preference
.
locked
;
return
undefined
;
}
chooseFolder
(
)
{
return
this
.
chooseFolderTask
(
)
.
catch
(
Components
.
utils
.
reportError
)
;
}
chooseFolderTask
:
Task
.
async
(
function
*
(
)
{
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
title
=
bundlePreferences
.
getString
(
"
chooseDownloadFolderTitle
"
)
;
let
folderListPref
=
document
.
getElementById
(
"
browser
.
download
.
folderList
"
)
;
let
currentDirPref
=
yield
this
.
_indexToFolder
(
folderListPref
.
value
)
;
let
defDownloads
=
yield
this
.
_indexToFolder
(
1
)
;
let
fp
=
Components
.
classes
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Components
.
interfaces
.
nsIFilePicker
)
;
fp
.
init
(
window
title
Components
.
interfaces
.
nsIFilePicker
.
modeGetFolder
)
;
fp
.
appendFilters
(
Components
.
interfaces
.
nsIFilePicker
.
filterAll
)
;
if
(
currentDirPref
&
&
currentDirPref
.
exists
(
)
)
{
fp
.
displayDirectory
=
currentDirPref
;
}
else
if
(
defDownloads
&
&
defDownloads
.
exists
(
)
)
{
fp
.
displayDirectory
=
defDownloads
;
}
else
{
fp
.
displayDirectory
=
yield
this
.
_indexToFolder
(
0
)
;
}
let
result
=
yield
new
Promise
(
resolve
=
>
fp
.
open
(
resolve
)
)
;
if
(
result
!
=
Components
.
interfaces
.
nsIFilePicker
.
returnOK
)
{
return
;
}
let
downloadDirPref
=
document
.
getElementById
(
"
browser
.
download
.
dir
"
)
;
downloadDirPref
.
value
=
fp
.
file
;
folderListPref
.
value
=
yield
this
.
_folderToIndex
(
fp
.
file
)
;
}
)
displayDownloadDirPref
(
)
{
this
.
displayDownloadDirPrefTask
(
)
.
catch
(
Components
.
utils
.
reportError
)
;
return
undefined
;
}
displayDownloadDirPrefTask
:
Task
.
async
(
function
*
(
)
{
var
folderListPref
=
document
.
getElementById
(
"
browser
.
download
.
folderList
"
)
;
var
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
downloadFolder
=
document
.
getElementById
(
"
downloadFolder
"
)
;
var
currentDirPref
=
document
.
getElementById
(
"
browser
.
download
.
dir
"
)
;
var
ios
=
Components
.
classes
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIIOService
)
;
var
fph
=
ios
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Components
.
interfaces
.
nsIFileProtocolHandler
)
;
var
iconUrlSpec
;
if
(
folderListPref
.
value
=
=
2
)
{
downloadFolder
.
label
=
this
.
_getDisplayNameOfFile
(
currentDirPref
.
value
)
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
currentDirPref
.
value
)
;
}
else
if
(
folderListPref
.
value
=
=
1
)
{
downloadFolder
.
label
=
bundlePreferences
.
getString
(
"
downloadsFolderName
"
)
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
yield
this
.
_indexToFolder
(
1
)
)
;
}
else
{
downloadFolder
.
label
=
bundlePreferences
.
getString
(
"
desktopFolderName
"
)
;
iconUrlSpec
=
fph
.
getURLSpecFromFile
(
yield
this
.
_getDownloadsFolder
(
"
Desktop
"
)
)
;
}
downloadFolder
.
image
=
"
moz
-
icon
:
/
/
"
+
iconUrlSpec
+
"
?
size
=
16
"
;
}
)
_getDisplayNameOfFile
(
aFolder
)
{
return
aFolder
?
aFolder
.
path
:
"
"
;
}
_getDownloadsFolder
:
Task
.
async
(
function
*
(
aFolder
)
{
switch
(
aFolder
)
{
case
"
Desktop
"
:
var
fileLoc
=
Components
.
classes
[
"
mozilla
.
org
/
file
/
directory_service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIProperties
)
;
return
fileLoc
.
get
(
"
Desk
"
Components
.
interfaces
.
nsILocalFile
)
;
case
"
Downloads
"
:
let
downloadsDir
=
yield
Downloads
.
getSystemDownloadsDirectory
(
)
;
return
new
FileUtils
.
File
(
downloadsDir
)
;
}
throw
"
ASSERTION
FAILED
:
folder
type
should
be
'
Desktop
'
or
'
Downloads
'
"
;
}
)
_folderToIndex
:
Task
.
async
(
function
*
(
aFolder
)
{
if
(
!
aFolder
|
|
aFolder
.
equals
(
yield
this
.
_getDownloadsFolder
(
"
Desktop
"
)
)
)
return
0
;
else
if
(
aFolder
.
equals
(
yield
this
.
_getDownloadsFolder
(
"
Downloads
"
)
)
)
return
1
;
return
2
;
}
)
_indexToFolder
:
Task
.
async
(
function
*
(
aIndex
)
{
switch
(
aIndex
)
{
case
0
:
return
yield
this
.
_getDownloadsFolder
(
"
Desktop
"
)
;
case
1
:
return
yield
this
.
_getDownloadsFolder
(
"
Downloads
"
)
;
}
var
currentDirPref
=
document
.
getElementById
(
"
browser
.
download
.
dir
"
)
;
return
currentDirPref
.
value
;
}
)
updateBrowserStartupLastSession
(
)
{
let
pbAutoStartPref
=
document
.
getElementById
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
let
startupPref
=
document
.
getElementById
(
"
browser
.
startup
.
page
"
)
;
let
menu
=
document
.
getElementById
(
"
browserStartupPage
"
)
;
let
option
=
document
.
getElementById
(
"
browserStartupLastSession
"
)
;
if
(
pbAutoStartPref
.
value
)
{
option
.
setAttribute
(
"
disabled
"
"
true
"
)
;
if
(
option
.
selected
)
{
menu
.
selectedItem
=
document
.
getElementById
(
"
browserStartupHomePage
"
)
;
}
}
else
{
option
.
removeAttribute
(
"
disabled
"
)
;
startupPref
.
updateElements
(
)
;
}
}
readLinkTarget
(
)
{
var
openNewWindow
=
document
.
getElementById
(
"
browser
.
link
.
open_newwindow
"
)
;
return
openNewWindow
.
value
!
=
2
;
}
writeLinkTarget
(
)
{
var
linkTargeting
=
document
.
getElementById
(
"
linkTargeting
"
)
;
return
linkTargeting
.
checked
?
3
:
2
;
}
updateSetDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
shellSvc
=
getShellService
(
)
;
let
defaultBrowserBox
=
document
.
getElementById
(
"
defaultBrowserBox
"
)
;
if
(
!
shellSvc
)
{
defaultBrowserBox
.
hidden
=
true
;
return
;
}
let
setDefaultPane
=
document
.
getElementById
(
"
setDefaultPane
"
)
;
let
isDefault
=
shellSvc
.
isDefaultBrowser
(
false
true
)
;
setDefaultPane
.
selectedIndex
=
isDefault
?
1
:
0
;
let
alwaysCheck
=
document
.
getElementById
(
"
alwaysCheckDefault
"
)
;
alwaysCheck
.
disabled
=
alwaysCheck
.
disabled
|
|
isDefault
&
&
alwaysCheck
.
checked
;
}
}
setDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
alwaysCheckPref
=
document
.
getElementById
(
"
browser
.
shell
.
checkDefaultBrowser
"
)
;
alwaysCheckPref
.
value
=
true
;
let
shellSvc
=
getShellService
(
)
;
if
(
!
shellSvc
)
return
;
try
{
shellSvc
.
setDefaultBrowser
(
true
false
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
return
;
}
let
selectedIndex
=
shellSvc
.
isDefaultBrowser
(
false
true
)
?
1
:
0
;
document
.
getElementById
(
"
setDefaultPane
"
)
.
selectedIndex
=
selectedIndex
;
}
}
}
;
