var
gSearchResultsPane
=
{
findSelection
:
null
listSearchTooltips
:
[
]
searchResultsCategory
:
null
searchInput
:
null
init
(
)
{
let
controller
=
this
.
getSelectionController
(
)
;
this
.
findSelection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
this
.
findSelection
.
setColors
(
"
currentColor
"
"
#
ffe900
"
"
currentColor
"
"
#
540ead
"
)
;
this
.
searchResultsCategory
=
document
.
getElementById
(
"
category
-
search
-
results
"
)
;
this
.
searchInput
=
document
.
getElementById
(
"
searchInput
"
)
;
this
.
searchInput
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
preferences
.
search
"
)
;
if
(
!
this
.
searchInput
.
hidden
)
{
this
.
searchInput
.
addEventListener
(
"
command
"
this
)
;
this
.
searchInput
.
addEventListener
(
"
focus
"
this
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
command
"
)
{
this
.
searchFunction
(
event
)
;
}
else
if
(
event
.
type
=
=
=
"
focus
"
)
{
this
.
initializeCategories
(
)
;
}
}
stringMatchesFilters
(
str
filter
)
{
if
(
!
filter
|
|
!
str
)
{
return
true
;
}
let
searchStr
=
str
.
toLowerCase
(
)
;
let
filterStrings
=
filter
.
toLowerCase
(
)
.
split
(
/
\
s
+
/
)
;
return
!
filterStrings
.
some
(
f
=
>
searchStr
.
indexOf
(
f
)
=
=
-
1
)
;
}
categoriesInitialized
:
false
initializeCategories
(
)
{
if
(
!
this
.
categoriesInitialized
)
{
this
.
categoriesInitialized
=
true
;
for
(
let
[
category
]
of
gCategoryInits
)
{
if
(
!
category
.
inited
)
{
category
.
init
(
)
;
}
}
}
}
textNodeDescendants
(
node
)
{
if
(
!
node
)
{
return
[
]
;
}
let
all
=
[
]
;
for
(
node
=
node
.
firstChild
;
node
;
node
=
node
.
nextSibling
)
{
if
(
node
.
nodeType
=
=
=
node
.
TEXT_NODE
)
{
all
.
push
(
node
)
;
}
else
{
all
=
all
.
concat
(
this
.
textNodeDescendants
(
node
)
)
;
}
}
return
all
;
}
highlightMatches
(
textNodes
nodeSizes
textSearch
searchPhrase
)
{
let
indices
=
[
]
;
let
i
=
-
1
;
while
(
(
i
=
textSearch
.
indexOf
(
searchPhrase
i
+
1
)
)
>
=
0
)
{
indices
.
push
(
i
)
;
}
for
(
let
startValue
of
indices
)
{
let
endValue
=
startValue
+
searchPhrase
.
length
;
let
startNode
=
null
;
let
endNode
=
null
;
let
nodeStartIndex
=
null
;
nodeSizes
.
forEach
(
function
(
lengthNodes
index
)
{
if
(
!
startNode
&
&
lengthNodes
>
=
startValue
)
{
startNode
=
textNodes
[
index
]
;
nodeStartIndex
=
index
;
if
(
index
>
0
)
{
startValue
-
=
nodeSizes
[
index
-
1
]
;
}
}
if
(
!
endNode
&
&
lengthNodes
>
=
endValue
)
{
endNode
=
textNodes
[
index
]
;
if
(
index
!
=
nodeStartIndex
|
|
index
>
0
)
{
endValue
-
=
nodeSizes
[
index
-
1
]
;
}
}
}
)
;
let
range
=
document
.
createRange
(
)
;
range
.
setStart
(
startNode
startValue
)
;
range
.
setEnd
(
endNode
endValue
)
;
this
.
findSelection
.
addRange
(
range
)
;
}
return
indices
.
length
>
0
;
}
getSelectionController
(
)
{
let
docShell
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
let
controller
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsISelectionDisplay
)
.
QueryInterface
(
Ci
.
nsISelectionController
)
;
return
controller
;
}
get
strings
(
)
{
delete
this
.
strings
;
return
this
.
strings
=
document
.
getElementById
(
"
searchResultBundle
"
)
;
}
searchFunction
(
event
)
{
let
query
=
event
.
target
.
value
.
trim
(
)
.
toLowerCase
(
)
;
this
.
findSelection
.
removeAllRanges
(
)
;
let
searchTooltips
=
Array
.
from
(
document
.
querySelectorAll
(
"
.
search
-
tooltip
"
)
)
;
for
(
let
searchTooltip
of
searchTooltips
)
{
searchTooltip
.
parentElement
.
classList
.
remove
(
"
search
-
tooltip
-
parent
"
)
;
searchTooltip
.
remove
(
)
;
}
this
.
listSearchTooltips
=
[
]
;
let
srHeader
=
document
.
getElementById
(
"
header
-
searchResults
"
)
;
if
(
query
)
{
gotoPref
(
"
paneSearchResults
"
)
;
this
.
searchResultsCategory
.
hidden
=
false
;
let
resultsFound
=
false
;
let
rootPreferencesChildren
=
document
.
querySelectorAll
(
"
#
mainPrefPane
>
*
:
not
(
[
data
-
hidden
-
from
-
search
]
)
"
)
;
for
(
let
i
=
0
;
i
<
rootPreferencesChildren
.
length
;
i
+
+
)
{
rootPreferencesChildren
[
i
]
.
hidden
=
false
;
}
for
(
let
i
=
0
;
i
<
rootPreferencesChildren
.
length
;
i
+
+
)
{
if
(
rootPreferencesChildren
[
i
]
.
className
!
=
"
header
"
&
&
rootPreferencesChildren
[
i
]
.
className
!
=
"
no
-
results
-
message
"
&
&
this
.
searchWithinNode
(
rootPreferencesChildren
[
i
]
query
)
)
{
rootPreferencesChildren
[
i
]
.
hidden
=
false
;
resultsFound
=
true
;
}
else
{
rootPreferencesChildren
[
i
]
.
hidden
=
true
;
}
}
srHeader
.
hidden
=
false
;
if
(
!
resultsFound
)
{
let
noResultsEl
=
document
.
querySelector
(
"
.
no
-
results
-
message
"
)
;
noResultsEl
.
hidden
=
false
;
let
strings
=
this
.
strings
;
document
.
getElementById
(
"
sorry
-
message
"
)
.
textContent
=
AppConstants
.
platform
=
=
"
win
"
?
strings
.
getFormattedString
(
"
searchResults
.
sorryMessageWin
"
[
query
]
)
:
strings
.
getFormattedString
(
"
searchResults
.
sorryMessageUnix
"
[
query
]
)
;
let
brandName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
document
.
getElementById
(
"
need
-
help
"
)
.
innerHTML
=
strings
.
getFormattedString
(
"
searchResults
.
needHelp
"
[
brandName
]
)
;
}
else
{
for
(
let
node
of
this
.
listSearchTooltips
)
{
this
.
createSearchTooltip
(
node
query
)
;
}
}
}
else
{
this
.
searchResultsCategory
.
hidden
=
true
;
document
.
getElementById
(
"
sorry
-
message
"
)
.
textContent
=
"
"
;
gotoPref
(
"
paneGeneral
"
)
;
}
}
searchWithinNode
(
nodeObject
searchPhrase
)
{
let
matchesFound
=
false
;
if
(
nodeObject
.
childElementCount
=
=
0
|
|
nodeObject
.
tagName
=
=
"
menulist
"
)
{
let
simpleTextNodes
=
this
.
textNodeDescendants
(
nodeObject
)
;
for
(
let
node
of
simpleTextNodes
)
{
let
result
=
this
.
highlightMatches
(
[
node
]
[
node
.
length
]
node
.
textContent
.
toLowerCase
(
)
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
let
nodeSizes
=
[
]
;
let
allNodeText
=
"
"
;
let
runningSize
=
0
;
let
labelResult
=
false
;
let
valueResult
=
false
;
let
accessKeyTextNodes
=
this
.
textNodeDescendants
(
nodeObject
.
boxObject
)
;
for
(
let
node
of
accessKeyTextNodes
)
{
runningSize
+
=
node
.
textContent
.
length
;
allNodeText
+
=
node
.
textContent
;
nodeSizes
.
push
(
runningSize
)
;
}
let
complexTextNodesResult
=
this
.
highlightMatches
(
accessKeyTextNodes
nodeSizes
allNodeText
.
toLowerCase
(
)
searchPhrase
)
;
if
(
nodeObject
.
getAttribute
(
"
label
"
)
)
{
labelResult
=
this
.
stringMatchesFilters
(
nodeObject
.
getAttribute
(
"
label
"
)
searchPhrase
)
;
}
if
(
labelResult
&
&
nodeObject
.
tagName
=
=
=
"
button
"
)
{
this
.
listSearchTooltips
.
push
(
nodeObject
)
;
}
if
(
nodeObject
.
getAttribute
(
"
value
"
)
)
{
valueResult
=
this
.
stringMatchesFilters
(
nodeObject
.
getAttribute
(
"
value
"
)
searchPhrase
)
;
}
if
(
(
nodeObject
.
tagName
=
=
"
button
"
|
|
nodeObject
.
tagName
=
=
"
menulist
"
|
|
nodeObject
.
tagName
=
=
"
menuitem
"
)
&
&
(
labelResult
|
|
valueResult
)
)
{
nodeObject
.
setAttribute
(
"
highlightable
"
"
true
"
)
;
}
if
(
valueResult
&
&
nodeObject
.
tagName
=
=
=
"
button
"
)
{
this
.
listSearchTooltips
.
push
(
nodeObject
)
;
}
matchesFound
=
matchesFound
|
|
complexTextNodesResult
|
|
labelResult
|
|
valueResult
;
}
for
(
let
i
=
0
;
i
<
nodeObject
.
childNodes
.
length
;
i
+
+
)
{
if
(
!
nodeObject
.
childNodes
[
i
]
.
hidden
&
&
nodeObject
.
getAttribute
(
"
data
-
hidden
-
from
-
search
"
)
!
=
=
"
true
"
)
{
let
result
=
this
.
searchWithinNode
(
nodeObject
.
childNodes
[
i
]
searchPhrase
)
;
if
(
result
&
&
nodeObject
.
tagName
=
=
=
"
menulist
"
)
{
this
.
listSearchTooltips
.
push
(
nodeObject
)
;
}
matchesFound
=
matchesFound
|
|
result
;
}
}
return
matchesFound
;
}
createSearchTooltip
(
currentNode
query
)
{
let
searchTooltip
=
document
.
createElement
(
"
span
"
)
;
searchTooltip
.
setAttribute
(
"
class
"
"
search
-
tooltip
"
)
;
searchTooltip
.
textContent
=
query
;
currentNode
.
parentElement
.
classList
.
add
(
"
search
-
tooltip
-
parent
"
)
;
currentNode
.
parentElement
.
appendChild
(
searchTooltip
)
;
let
anchorRect
=
currentNode
.
getBoundingClientRect
(
)
;
let
tooltipRect
=
searchTooltip
.
getBoundingClientRect
(
)
;
let
parentRect
=
currentNode
.
parentElement
.
getBoundingClientRect
(
)
;
let
offSet
=
(
anchorRect
.
width
/
2
)
-
(
tooltipRect
.
width
/
2
)
;
let
relativeOffset
=
anchorRect
.
left
-
parentRect
.
left
;
offSet
+
=
relativeOffset
>
0
?
relativeOffset
:
0
;
searchTooltip
.
style
.
setProperty
(
"
left
"
{
offSet
}
px
)
;
}
}
