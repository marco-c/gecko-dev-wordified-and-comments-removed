var
gSearchResultsPane
=
{
listSearchTooltips
:
new
Set
(
)
listSearchMenuitemIndicators
:
new
Set
(
)
searchInput
:
null
inited
:
false
init
(
)
{
if
(
this
.
inited
)
{
return
;
}
this
.
inited
=
true
;
this
.
searchInput
=
document
.
getElementById
(
"
searchInput
"
)
;
this
.
searchInput
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
preferences
.
search
"
)
;
if
(
!
this
.
searchInput
.
hidden
)
{
this
.
searchInput
.
addEventListener
(
"
input
"
this
)
;
this
.
searchInput
.
addEventListener
(
"
command
"
this
)
;
window
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
this
.
searchInput
.
focus
(
)
;
}
)
;
window
.
requestIdleCallback
(
(
)
=
>
this
.
initializeCategories
(
)
)
;
}
let
strings
=
this
.
strings
;
this
.
searchInput
.
placeholder
=
AppConstants
.
platform
=
=
"
win
"
?
strings
.
getString
(
"
searchInput
.
labelWin
"
)
:
strings
.
getString
(
"
searchInput
.
labelUnix
"
)
;
}
handleEvent
(
event
)
{
this
.
initializeCategories
(
)
;
this
.
searchFunction
(
event
)
;
}
queryMatchesContent
(
content
query
)
{
if
(
!
content
|
|
!
query
)
{
return
false
;
}
return
content
.
toLowerCase
(
)
.
includes
(
query
.
toLowerCase
(
)
)
;
}
categoriesInitialized
:
false
initializeCategories
(
)
{
if
(
!
this
.
categoriesInitialized
)
{
this
.
categoriesInitialized
=
true
;
for
(
let
[
category
]
of
gCategoryInits
)
{
if
(
!
category
.
inited
)
{
category
.
init
(
)
;
}
}
}
}
textNodeDescendants
(
node
)
{
if
(
!
node
)
{
return
[
]
;
}
let
all
=
[
]
;
for
(
node
=
node
.
firstChild
;
node
;
node
=
node
.
nextSibling
)
{
if
(
node
.
nodeType
=
=
=
node
.
TEXT_NODE
)
{
all
.
push
(
node
)
;
}
else
{
all
=
all
.
concat
(
this
.
textNodeDescendants
(
node
)
)
;
}
}
return
all
;
}
highlightMatches
(
textNodes
nodeSizes
textSearch
searchPhrase
)
{
if
(
!
searchPhrase
)
{
return
false
;
}
let
indices
=
[
]
;
let
i
=
-
1
;
while
(
(
i
=
textSearch
.
indexOf
(
searchPhrase
i
+
1
)
)
>
=
0
)
{
indices
.
push
(
i
)
;
}
for
(
let
startValue
of
indices
)
{
let
endValue
=
startValue
+
searchPhrase
.
length
;
let
startNode
=
null
;
let
endNode
=
null
;
let
nodeStartIndex
=
null
;
for
(
let
index
=
0
;
index
<
nodeSizes
.
length
;
index
+
+
)
{
let
lengthNodes
=
nodeSizes
[
index
]
;
if
(
!
startNode
&
&
lengthNodes
>
=
startValue
)
{
startNode
=
textNodes
[
index
]
;
nodeStartIndex
=
index
;
if
(
index
>
0
)
{
startValue
-
=
nodeSizes
[
index
-
1
]
;
}
}
if
(
!
endNode
&
&
lengthNodes
>
=
endValue
)
{
endNode
=
textNodes
[
index
]
;
if
(
index
!
=
nodeStartIndex
|
|
index
>
0
)
{
endValue
-
=
nodeSizes
[
index
-
1
]
;
}
}
}
let
range
=
document
.
createRange
(
)
;
range
.
setStart
(
startNode
startValue
)
;
range
.
setEnd
(
endNode
endValue
)
;
this
.
getFindSelection
(
startNode
.
ownerGlobal
)
.
addRange
(
range
)
;
}
return
indices
.
length
>
0
;
}
getFindSelection
(
win
)
{
let
docShell
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
let
controller
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsISelectionDisplay
)
.
QueryInterface
(
Ci
.
nsISelectionController
)
;
let
selection
=
controller
.
getSelection
(
Ci
.
nsISelectionController
.
SELECTION_FIND
)
;
selection
.
setColors
(
"
currentColor
"
"
#
ffe900
"
"
currentColor
"
"
#
003eaa
"
)
;
return
selection
;
}
get
strings
(
)
{
delete
this
.
strings
;
return
this
.
strings
=
document
.
getElementById
(
"
searchResultBundle
"
)
;
}
async
searchFunction
(
event
)
{
let
query
=
event
.
target
.
value
.
trim
(
)
.
toLowerCase
(
)
;
if
(
this
.
query
=
=
query
)
{
return
;
}
let
subQuery
=
this
.
query
&
&
query
.
indexOf
(
this
.
query
)
!
=
=
-
1
;
this
.
query
=
query
;
this
.
getFindSelection
(
window
)
.
removeAllRanges
(
)
;
this
.
removeAllSearchTooltips
(
)
;
this
.
removeAllSearchMenuitemIndicators
(
)
;
if
(
this
.
telemetryTimer
)
{
clearTimeout
(
this
.
telemetryTimer
)
;
}
let
srHeader
=
document
.
getElementById
(
"
header
-
searchResults
"
)
;
if
(
this
.
query
)
{
gotoPref
(
"
paneSearchResults
"
)
;
let
resultsFound
=
false
;
let
rootPreferencesChildren
=
document
.
querySelectorAll
(
"
#
mainPrefPane
>
*
:
not
(
[
data
-
hidden
-
from
-
search
]
)
"
)
;
for
(
let
element
of
document
.
querySelectorAll
(
"
caption
.
search
-
header
"
)
)
{
element
.
hidden
=
false
;
}
if
(
subQuery
)
{
rootPreferencesChildren
=
Array
.
prototype
.
filter
.
call
(
rootPreferencesChildren
el
=
>
!
el
.
hidden
)
;
}
for
(
let
i
=
0
;
i
<
rootPreferencesChildren
.
length
;
i
+
+
)
{
rootPreferencesChildren
[
i
]
.
hidden
=
false
;
rootPreferencesChildren
[
i
]
.
classList
.
add
(
"
visually
-
hidden
"
)
;
}
let
ts
=
performance
.
now
(
)
;
let
FRAME_THRESHOLD
=
1000
/
60
;
for
(
let
i
=
0
;
i
<
rootPreferencesChildren
.
length
;
i
+
+
)
{
if
(
performance
.
now
(
)
-
ts
>
FRAME_THRESHOLD
)
{
for
(
let
anchorNode
of
this
.
listSearchTooltips
)
{
this
.
createSearchTooltip
(
anchorNode
this
.
query
)
;
}
srHeader
.
hidden
=
false
;
srHeader
.
classList
.
remove
(
"
visually
-
hidden
"
)
;
ts
=
await
new
Promise
(
resolve
=
>
window
.
requestAnimationFrame
(
resolve
)
)
;
if
(
query
!
=
=
this
.
query
)
{
return
;
}
}
rootPreferencesChildren
[
i
]
.
classList
.
remove
(
"
visually
-
hidden
"
)
;
if
(
!
rootPreferencesChildren
[
i
]
.
classList
.
contains
(
"
header
"
)
&
&
!
rootPreferencesChildren
[
i
]
.
classList
.
contains
(
"
subcategory
"
)
&
&
!
rootPreferencesChildren
[
i
]
.
classList
.
contains
(
"
no
-
results
-
message
"
)
&
&
this
.
searchWithinNode
(
rootPreferencesChildren
[
i
]
this
.
query
)
)
{
rootPreferencesChildren
[
i
]
.
hidden
=
false
;
resultsFound
=
true
;
}
else
{
rootPreferencesChildren
[
i
]
.
hidden
=
true
;
}
}
srHeader
.
hidden
=
false
;
srHeader
.
classList
.
remove
(
"
visually
-
hidden
"
)
;
if
(
!
resultsFound
)
{
let
noResultsEl
=
document
.
querySelector
(
"
.
no
-
results
-
message
"
)
;
noResultsEl
.
setAttribute
(
"
query
"
this
.
query
)
;
noResultsEl
.
hidden
=
false
;
let
strings
=
this
.
strings
;
document
.
getElementById
(
"
sorry
-
message
"
)
.
textContent
=
AppConstants
.
platform
=
=
"
win
"
?
strings
.
getFormattedString
(
"
searchResults
.
sorryMessageWin
"
[
this
.
query
]
)
:
strings
.
getFormattedString
(
"
searchResults
.
sorryMessageUnix
"
[
this
.
query
]
)
;
let
helpUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
preferences
"
;
let
brandName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
document
.
getElementById
(
"
need
-
help
"
)
.
innerHTML
=
strings
.
getFormattedString
(
"
searchResults
.
needHelp2
"
[
helpUrl
brandName
]
)
;
}
else
{
for
(
let
anchorNode
of
this
.
listSearchTooltips
)
{
this
.
createSearchTooltip
(
anchorNode
this
.
query
)
;
}
if
(
this
.
query
.
length
>
=
2
)
{
this
.
telemetryTimer
=
setTimeout
(
(
)
=
>
{
Services
.
telemetry
.
keyedScalarAdd
(
"
preferences
.
search_query
"
this
.
query
1
)
;
}
1000
)
;
}
}
}
else
{
document
.
getElementById
(
"
sorry
-
message
"
)
.
textContent
=
"
"
;
gotoPref
(
"
paneGeneral
"
)
;
for
(
let
element
of
document
.
querySelectorAll
(
"
caption
.
search
-
header
"
)
)
{
element
.
hidden
=
true
;
}
}
window
.
dispatchEvent
(
new
CustomEvent
(
"
PreferencesSearchCompleted
"
{
detail
:
query
}
)
)
;
}
searchWithinNode
(
nodeObject
searchPhrase
)
{
let
matchesFound
=
false
;
if
(
nodeObject
.
childElementCount
=
=
0
|
|
nodeObject
.
tagName
=
=
"
label
"
|
|
nodeObject
.
tagName
=
=
"
description
"
|
|
nodeObject
.
tagName
=
=
"
menulist
"
)
{
let
simpleTextNodes
=
this
.
textNodeDescendants
(
nodeObject
)
;
for
(
let
node
of
simpleTextNodes
)
{
let
result
=
this
.
highlightMatches
(
[
node
]
[
node
.
length
]
node
.
textContent
.
toLowerCase
(
)
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
let
nodeSizes
=
[
]
;
let
allNodeText
=
"
"
;
let
runningSize
=
0
;
let
accessKeyTextNodes
=
this
.
textNodeDescendants
(
nodeObject
.
boxObject
)
;
if
(
nodeObject
.
tagName
=
=
"
label
"
|
|
nodeObject
.
tagName
=
=
"
description
"
)
{
accessKeyTextNodes
.
push
(
.
.
.
this
.
textNodeDescendants
(
nodeObject
)
)
;
}
for
(
let
node
of
accessKeyTextNodes
)
{
runningSize
+
=
node
.
textContent
.
length
;
allNodeText
+
=
node
.
textContent
;
nodeSizes
.
push
(
runningSize
)
;
}
let
complexTextNodesResult
=
this
.
highlightMatches
(
accessKeyTextNodes
nodeSizes
allNodeText
.
toLowerCase
(
)
searchPhrase
)
;
let
labelResult
=
this
.
queryMatchesContent
(
nodeObject
.
getAttribute
(
"
label
"
)
searchPhrase
)
;
let
valueResult
=
nodeObject
.
tagName
!
=
=
"
menuitem
"
?
this
.
queryMatchesContent
(
nodeObject
.
getAttribute
(
"
value
"
)
searchPhrase
)
:
false
;
let
keywordsResult
=
this
.
queryMatchesContent
(
nodeObject
.
getAttribute
(
"
searchkeywords
"
)
searchPhrase
)
;
if
(
keywordsResult
&
&
(
nodeObject
.
tagName
=
=
=
"
button
"
|
|
nodeObject
.
tagName
=
=
"
menulist
"
)
)
{
this
.
listSearchTooltips
.
add
(
nodeObject
)
;
}
if
(
keywordsResult
&
&
nodeObject
.
tagName
=
=
=
"
menuitem
"
)
{
nodeObject
.
setAttribute
(
"
indicator
"
"
true
"
)
;
this
.
listSearchMenuitemIndicators
.
add
(
nodeObject
)
;
let
menulist
=
nodeObject
.
closest
(
"
menulist
"
)
;
menulist
.
setAttribute
(
"
indicator
"
"
true
"
)
;
this
.
listSearchMenuitemIndicators
.
add
(
menulist
)
;
}
if
(
(
nodeObject
.
tagName
=
=
"
button
"
|
|
nodeObject
.
tagName
=
=
"
menulist
"
|
|
nodeObject
.
tagName
=
=
"
menuitem
"
)
&
&
(
labelResult
|
|
valueResult
|
|
keywordsResult
)
)
{
nodeObject
.
setAttribute
(
"
highlightable
"
"
true
"
)
;
}
matchesFound
=
matchesFound
|
|
complexTextNodesResult
|
|
labelResult
|
|
valueResult
|
|
keywordsResult
;
}
if
(
nodeObject
.
tagName
=
=
"
deck
"
&
&
nodeObject
.
id
!
=
"
historyPane
"
)
{
let
index
=
nodeObject
.
selectedIndex
;
if
(
index
!
=
-
1
)
{
let
result
=
this
.
searchChildNodeIfVisible
(
nodeObject
index
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
}
else
{
for
(
let
i
=
0
;
i
<
nodeObject
.
childNodes
.
length
;
i
+
+
)
{
let
result
=
this
.
searchChildNodeIfVisible
(
nodeObject
i
searchPhrase
)
;
matchesFound
=
matchesFound
|
|
result
;
}
}
return
matchesFound
;
}
searchChildNodeIfVisible
(
nodeObject
index
searchPhrase
)
{
let
result
=
false
;
if
(
!
nodeObject
.
childNodes
[
index
]
.
hidden
&
&
nodeObject
.
getAttribute
(
"
data
-
hidden
-
from
-
search
"
)
!
=
=
"
true
"
)
{
result
=
this
.
searchWithinNode
(
nodeObject
.
childNodes
[
index
]
searchPhrase
)
;
if
(
result
&
&
nodeObject
.
tagName
=
=
=
"
menulist
"
)
{
this
.
listSearchTooltips
.
add
(
nodeObject
)
;
}
}
return
result
;
}
createSearchTooltip
(
anchorNode
query
)
{
if
(
anchorNode
.
tooltipNode
)
{
return
;
}
let
searchTooltip
=
anchorNode
.
ownerDocument
.
createElement
(
"
span
"
)
;
let
searchTooltipText
=
anchorNode
.
ownerDocument
.
createElement
(
"
span
"
)
;
searchTooltip
.
setAttribute
(
"
class
"
"
search
-
tooltip
"
)
;
searchTooltipText
.
textContent
=
query
;
searchTooltip
.
appendChild
(
searchTooltipText
)
;
anchorNode
.
tooltipNode
=
searchTooltip
;
anchorNode
.
parentElement
.
classList
.
add
(
"
search
-
tooltip
-
parent
"
)
;
anchorNode
.
parentElement
.
appendChild
(
searchTooltip
)
;
this
.
calculateTooltipPosition
(
anchorNode
)
;
}
calculateTooltipPosition
(
anchorNode
)
{
let
searchTooltip
=
anchorNode
.
tooltipNode
;
let
tooltipRect
=
searchTooltip
.
getBoundingClientRect
(
)
;
searchTooltip
.
style
.
setProperty
(
"
left
"
calc
(
50
%
-
{
(
tooltipRect
.
width
/
2
)
}
px
)
)
;
}
removeAllSearchTooltips
(
)
{
let
searchTooltips
=
Array
.
from
(
document
.
querySelectorAll
(
"
.
search
-
tooltip
"
)
)
;
for
(
let
searchTooltip
of
searchTooltips
)
{
searchTooltip
.
parentElement
.
classList
.
remove
(
"
search
-
tooltip
-
parent
"
)
;
searchTooltip
.
remove
(
)
;
}
for
(
let
anchorNode
of
this
.
listSearchTooltips
)
{
anchorNode
.
tooltipNode
.
remove
(
)
;
anchorNode
.
tooltipNode
=
null
;
}
this
.
listSearchTooltips
.
clear
(
)
;
}
removeAllSearchMenuitemIndicators
(
)
{
for
(
let
node
of
this
.
listSearchMenuitemIndicators
)
{
node
.
removeAttribute
(
"
indicator
"
)
;
}
this
.
listSearchMenuitemIndicators
.
clear
(
)
;
}
}
;
