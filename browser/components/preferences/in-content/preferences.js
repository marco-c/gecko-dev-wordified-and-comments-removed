"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ExtensionSettingsStore
"
"
resource
:
/
/
gre
/
modules
/
ExtensionSettingsStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
formAutofillParent
"
"
resource
:
/
/
formautofill
/
FormAutofillParent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
trackingprotectionUiEnabled
"
"
privacy
.
trackingprotection
.
ui
.
enabled
"
)
;
var
gLastHash
=
"
"
;
var
gCategoryInits
=
new
Map
(
)
;
function
init_category_if_required
(
category
)
{
let
categoryInfo
=
gCategoryInits
.
get
(
category
)
;
if
(
!
categoryInfo
)
{
throw
"
Unknown
in
-
content
prefs
category
!
Can
'
t
init
"
+
category
;
}
if
(
categoryInfo
.
inited
)
{
return
;
}
categoryInfo
.
init
(
)
;
}
function
register_module
(
categoryName
categoryObject
)
{
gCategoryInits
.
set
(
categoryName
{
inited
:
false
init
(
)
{
categoryObject
.
init
(
)
;
this
.
inited
=
true
;
}
}
)
;
}
document
.
addEventListener
(
"
DOMContentLoaded
"
init_all
{
once
:
true
}
)
;
function
init_all
(
)
{
Preferences
.
forceEnableInstantApply
(
)
;
gSubDialog
.
init
(
)
;
register_module
(
"
paneGeneral
"
gMainPane
)
;
register_module
(
"
paneSearch
"
gSearchPane
)
;
register_module
(
"
panePrivacy
"
gPrivacyPane
)
;
register_module
(
"
paneContainers
"
gContainersPane
)
;
register_module
(
"
paneSync
"
gSyncPane
)
;
register_module
(
"
paneSearchResults
"
gSearchResultsPane
)
;
gSearchResultsPane
.
init
(
)
;
gMainPane
.
preInit
(
)
;
let
categories
=
document
.
getElementById
(
"
categories
"
)
;
categories
.
addEventListener
(
"
select
"
event
=
>
gotoPref
(
event
.
target
.
value
)
)
;
document
.
documentElement
.
addEventListener
(
"
keydown
"
function
(
event
)
{
if
(
event
.
keyCode
=
=
KeyEvent
.
DOM_VK_TAB
)
{
categories
.
setAttribute
(
"
keyboard
-
navigation
"
"
true
"
)
;
}
}
)
;
categories
.
addEventListener
(
"
mousedown
"
function
(
)
{
this
.
removeAttribute
(
"
keyboard
-
navigation
"
)
;
}
)
;
window
.
addEventListener
(
"
hashchange
"
onHashChange
)
;
gotoPref
(
)
;
let
helpButton
=
document
.
querySelector
(
"
.
help
-
button
>
.
text
-
link
"
)
;
let
helpUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
preferences
"
;
helpButton
.
setAttribute
(
"
href
"
helpUrl
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
Initialized
"
{
"
bubbles
"
:
true
"
cancelable
"
:
true
}
)
)
;
}
function
telemetryBucketForCategory
(
category
)
{
category
=
category
.
toLowerCase
(
)
;
switch
(
category
)
{
case
"
containers
"
:
case
"
general
"
:
case
"
privacy
"
:
case
"
search
"
:
case
"
sync
"
:
case
"
searchresults
"
:
return
category
;
default
:
return
"
unknown
"
;
}
}
function
onHashChange
(
)
{
gotoPref
(
)
;
}
function
gotoPref
(
aCategory
)
{
let
categories
=
document
.
getElementById
(
"
categories
"
)
;
const
kDefaultCategoryInternalName
=
"
paneGeneral
"
;
const
kDefaultCategory
=
"
general
"
;
let
hash
=
document
.
location
.
hash
;
let
category
=
aCategory
|
|
hash
.
substr
(
1
)
|
|
kDefaultCategoryInternalName
;
let
breakIndex
=
category
.
indexOf
(
"
-
"
)
;
let
subcategory
=
breakIndex
!
=
-
1
&
&
category
.
substring
(
breakIndex
+
1
)
;
if
(
subcategory
)
{
category
=
category
.
substring
(
0
breakIndex
)
;
}
category
=
friendlyPrefCategoryNameToInternalName
(
category
)
;
if
(
category
!
=
"
paneSearchResults
"
)
{
gSearchResultsPane
.
query
=
null
;
gSearchResultsPane
.
searchInput
.
value
=
"
"
;
gSearchResultsPane
.
getFindSelection
(
window
)
.
removeAllRanges
(
)
;
gSearchResultsPane
.
removeAllSearchTooltips
(
)
;
gSearchResultsPane
.
removeAllSearchMenuitemIndicators
(
)
;
}
else
if
(
!
gSearchResultsPane
.
searchInput
.
value
)
{
category
=
kDefaultCategoryInternalName
;
document
.
location
.
hash
=
kDefaultCategory
;
gSearchResultsPane
.
query
=
null
;
}
if
(
gLastHash
=
=
category
&
&
!
subcategory
)
return
;
let
item
;
if
(
category
!
=
"
paneSearchResults
"
)
{
item
=
categories
.
querySelector
(
"
.
category
[
value
=
"
+
category
+
"
]
"
)
;
if
(
!
item
)
{
category
=
kDefaultCategoryInternalName
;
item
=
categories
.
querySelector
(
"
.
category
[
value
=
"
+
category
+
"
]
"
)
;
}
}
try
{
init_category_if_required
(
category
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Error
initializing
preference
category
"
+
category
+
"
:
"
+
ex
)
;
throw
ex
;
}
let
friendlyName
=
internalPrefCategoryNameToFriendlyName
(
category
)
;
if
(
gLastHash
|
|
category
!
=
kDefaultCategoryInternalName
|
|
subcategory
)
{
document
.
location
.
hash
=
friendlyName
;
}
gLastHash
=
category
;
if
(
item
)
{
categories
.
selectedItem
=
item
;
}
else
{
categories
.
clearSelection
(
)
;
}
window
.
history
.
replaceState
(
category
document
.
title
)
;
search
(
category
"
data
-
category
"
)
;
let
mainContent
=
document
.
querySelector
(
"
.
main
-
content
"
)
;
mainContent
.
scrollTop
=
0
;
spotlight
(
subcategory
)
;
Services
.
telemetry
.
getHistogramById
(
"
FX_PREFERENCES_CATEGORY_OPENED_V2
"
)
.
add
(
telemetryBucketForCategory
(
friendlyName
)
)
;
}
function
search
(
aQuery
aAttribute
)
{
let
mainPrefPane
=
document
.
getElementById
(
"
mainPrefPane
"
)
;
let
elements
=
mainPrefPane
.
children
;
for
(
let
element
of
elements
)
{
if
(
element
.
getAttribute
(
"
data
-
hidden
-
from
-
search
"
)
!
=
"
true
"
|
|
element
.
getAttribute
(
"
data
-
subpanel
"
)
=
=
"
true
"
)
{
let
attributeValue
=
element
.
getAttribute
(
aAttribute
)
;
if
(
attributeValue
=
=
aQuery
)
{
element
.
hidden
=
false
;
}
else
{
element
.
hidden
=
true
;
}
}
element
.
classList
.
remove
(
"
visually
-
hidden
"
)
;
}
let
keysets
=
mainPrefPane
.
getElementsByTagName
(
"
keyset
"
)
;
for
(
let
element
of
keysets
)
{
let
attributeValue
=
element
.
getAttribute
(
aAttribute
)
;
if
(
attributeValue
=
=
aQuery
)
element
.
removeAttribute
(
"
disabled
"
)
;
else
element
.
setAttribute
(
"
disabled
"
true
)
;
}
}
async
function
spotlight
(
subcategory
)
{
let
highlightedElements
=
document
.
querySelectorAll
(
"
.
spotlight
"
)
;
if
(
highlightedElements
.
length
)
{
for
(
let
element
of
highlightedElements
)
{
element
.
classList
.
remove
(
"
spotlight
"
)
;
}
}
if
(
subcategory
)
{
if
(
!
gSearchResultsPane
.
categoriesInitialized
)
{
await
waitForSystemAddonInjectionsFinished
(
[
{
isGoingToInject
:
formAutofillParent
.
initialized
elementId
:
"
formAutofillGroup
"
}
]
)
;
}
scrollAndHighlight
(
subcategory
)
;
}
function
waitForSystemAddonInjectionsFinished
(
addons
)
{
return
new
Promise
(
resolve
=
>
{
let
elementIdSet
=
new
Set
(
)
;
for
(
let
addon
of
addons
)
{
if
(
addon
.
isGoingToInject
)
{
elementIdSet
.
add
(
addon
.
elementId
)
;
}
}
if
(
elementIdSet
.
size
)
{
let
observer
=
new
MutationObserver
(
mutations
=
>
{
for
(
let
mutation
of
mutations
)
{
for
(
let
node
of
mutation
.
addedNodes
)
{
elementIdSet
.
delete
(
node
.
id
)
;
if
(
elementIdSet
.
size
=
=
=
0
)
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
}
}
}
)
;
let
mainContent
=
document
.
querySelector
(
"
.
main
-
content
"
)
;
observer
.
observe
(
mainContent
{
childList
:
true
subtree
:
true
}
)
;
mainContent
.
addEventListener
(
"
scroll
"
disconnectMutationObserver
)
;
window
.
addEventListener
(
"
mousedown
"
disconnectMutationObserver
)
;
window
.
addEventListener
(
"
keydown
"
disconnectMutationObserver
)
;
function
disconnectMutationObserver
(
)
{
mainContent
.
removeEventListener
(
"
scroll
"
disconnectMutationObserver
)
;
window
.
removeEventListener
(
"
mousedown
"
disconnectMutationObserver
)
;
window
.
removeEventListener
(
"
keydown
"
disconnectMutationObserver
)
;
observer
.
disconnect
(
)
;
}
}
else
{
resolve
(
)
;
}
}
)
;
}
}
function
scrollAndHighlight
(
subcategory
)
{
let
element
=
document
.
querySelector
(
[
data
-
subcategory
=
"
{
subcategory
}
"
]
)
;
if
(
element
)
{
let
header
=
getClosestDisplayedHeader
(
element
)
;
scrollContentTo
(
header
)
;
element
.
classList
.
add
(
"
spotlight
"
)
;
}
}
function
getClosestDisplayedHeader
(
element
)
{
let
header
=
element
.
closest
(
"
groupbox
"
)
;
let
searchHeader
=
header
.
querySelector
(
"
caption
.
search
-
header
"
)
;
if
(
searchHeader
&
&
searchHeader
.
hidden
&
&
header
.
previousSibling
.
classList
.
contains
(
"
subcategory
"
)
)
{
header
=
header
.
previousSibling
;
}
return
header
;
}
function
scrollContentTo
(
element
)
{
const
SEARCH_CONTAINER_HEIGHT
=
document
.
querySelector
(
"
.
search
-
container
"
)
.
clientHeight
;
let
mainContent
=
document
.
querySelector
(
"
.
main
-
content
"
)
;
let
top
=
element
.
getBoundingClientRect
(
)
.
top
-
SEARCH_CONTAINER_HEIGHT
;
mainContent
.
scroll
(
{
top
behavior
:
"
smooth
"
}
)
;
}
function
friendlyPrefCategoryNameToInternalName
(
aName
)
{
if
(
aName
.
startsWith
(
"
pane
"
)
)
return
aName
;
return
"
pane
"
+
aName
.
substring
(
0
1
)
.
toUpperCase
(
)
+
aName
.
substr
(
1
)
;
}
function
internalPrefCategoryNameToFriendlyName
(
aName
)
{
return
(
aName
|
|
"
"
)
.
replace
(
/
^
pane
.
/
function
(
toReplace
)
{
return
toReplace
[
4
]
.
toLowerCase
(
)
;
}
)
;
}
const
CONFIRM_RESTART_PROMPT_RESTART_NOW
=
0
;
const
CONFIRM_RESTART_PROMPT_CANCEL
=
1
;
const
CONFIRM_RESTART_PROMPT_RESTART_LATER
=
2
;
function
confirmRestartPrompt
(
aRestartToEnable
aDefaultButtonIndex
aWantRevertAsCancelButton
aWantRestartLaterButton
)
{
let
brandName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
let
bundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
msg
=
bundle
.
getFormattedString
(
aRestartToEnable
?
"
featureEnableRequiresRestart
"
:
"
featureDisableRequiresRestart
"
[
brandName
]
)
;
let
title
=
bundle
.
getFormattedString
(
"
shouldRestartTitle
"
[
brandName
]
)
;
let
button0Text
=
bundle
.
getFormattedString
(
"
okToRestartButton
"
[
brandName
]
)
;
let
buttonFlags
=
(
Services
.
prompt
.
BUTTON_POS_0
*
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
)
;
let
button1Text
=
null
;
if
(
aWantRevertAsCancelButton
)
{
button1Text
=
bundle
.
getString
(
"
revertNoRestartButton
"
)
;
buttonFlags
+
=
(
Services
.
prompt
.
BUTTON_POS_1
*
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
)
;
}
else
{
buttonFlags
+
=
(
Services
.
prompt
.
BUTTON_POS_1
*
Services
.
prompt
.
BUTTON_TITLE_CANCEL
)
;
}
let
button2Text
=
null
;
if
(
aWantRestartLaterButton
)
{
button2Text
=
bundle
.
getString
(
"
restartLater
"
)
;
buttonFlags
+
=
(
Services
.
prompt
.
BUTTON_POS_2
*
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
)
;
}
switch
(
aDefaultButtonIndex
)
{
case
0
:
buttonFlags
+
=
Services
.
prompt
.
BUTTON_POS_0_DEFAULT
;
break
;
case
1
:
buttonFlags
+
=
Services
.
prompt
.
BUTTON_POS_1_DEFAULT
;
break
;
case
2
:
buttonFlags
+
=
Services
.
prompt
.
BUTTON_POS_2_DEFAULT
;
break
;
default
:
break
;
}
let
buttonIndex
=
Services
.
prompt
.
confirmEx
(
window
title
msg
buttonFlags
button0Text
button1Text
button2Text
null
{
}
)
;
if
(
buttonIndex
=
=
CONFIRM_RESTART_PROMPT_RESTART_NOW
)
{
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
cancelQuit
.
data
)
{
buttonIndex
=
CONFIRM_RESTART_PROMPT_CANCEL
;
}
}
return
buttonIndex
;
}
function
appendSearchKeywords
(
aId
keywords
)
{
let
element
=
document
.
getElementById
(
aId
)
;
let
searchKeywords
=
element
.
getAttribute
(
"
searchkeywords
"
)
;
if
(
searchKeywords
)
{
keywords
.
push
(
searchKeywords
)
;
}
element
.
setAttribute
(
"
searchkeywords
"
keywords
.
join
(
"
"
)
)
;
}
const
PREF_SETTING_TYPE
=
"
prefs
"
;
let
extensionControlledContentIds
=
{
"
privacy
.
containers
"
:
"
browserContainersExtensionContent
"
"
homepage_override
"
:
"
browserHomePageExtensionContent
"
"
newTabURL
"
:
"
browserNewTabExtensionContent
"
"
defaultSearch
"
:
"
browserDefaultSearchExtensionContent
"
get
"
websites
.
trackingProtectionMode
"
(
)
{
return
{
button
:
"
trackingProtectionExtensionContentButton
"
section
:
trackingprotectionUiEnabled
?
"
trackingProtectionExtensionContentLabel
"
:
"
trackingProtectionPBMExtensionContentLabel
"
}
;
}
}
;
let
extensionControlledIds
=
{
}
;
async
function
getControllingExtensionInfo
(
type
settingName
)
{
await
ExtensionSettingsStore
.
initialize
(
)
;
return
ExtensionSettingsStore
.
getSetting
(
type
settingName
)
;
}
function
getControllingExtensionEls
(
settingName
)
{
let
idInfo
=
extensionControlledContentIds
[
settingName
]
;
let
section
=
document
.
getElementById
(
idInfo
.
section
|
|
idInfo
)
;
let
button
=
idInfo
.
button
?
document
.
getElementById
(
idInfo
.
button
)
:
section
.
querySelector
(
"
button
"
)
;
return
{
section
button
description
:
section
.
querySelector
(
"
description
"
)
}
;
}
async
function
handleControllingExtension
(
type
settingName
)
{
let
info
=
await
getControllingExtensionInfo
(
type
settingName
)
;
let
addon
=
info
&
&
info
.
id
&
&
await
AddonManager
.
getAddonByID
(
info
.
id
)
;
if
(
addon
)
{
extensionControlledIds
[
settingName
]
=
info
.
id
;
showControllingExtension
(
settingName
addon
)
;
}
else
{
let
elements
=
getControllingExtensionEls
(
settingName
)
;
if
(
extensionControlledIds
[
settingName
]
&
&
!
document
.
hidden
&
&
elements
.
button
)
{
showEnableExtensionMessage
(
settingName
)
;
}
else
{
hideControllingExtension
(
settingName
)
;
}
delete
extensionControlledIds
[
settingName
]
;
}
return
!
!
addon
;
}
async
function
showControllingExtension
(
settingName
addon
)
{
let
elements
=
getControllingExtensionEls
(
settingName
)
;
elements
.
section
.
classList
.
remove
(
"
extension
-
controlled
-
disabled
"
)
;
let
description
=
elements
.
description
;
while
(
description
.
firstChild
)
{
description
.
firstChild
.
remove
(
)
;
}
let
msg
=
document
.
getElementById
(
"
bundlePreferences
"
)
.
getString
(
extensionControlled
.
{
settingName
}
)
;
let
image
=
document
.
createElement
(
"
image
"
)
;
const
defaultIcon
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
.
svg
"
;
image
.
setAttribute
(
"
src
"
addon
.
iconURL
|
|
defaultIcon
)
;
image
.
classList
.
add
(
"
extension
-
controlled
-
icon
"
)
;
let
addonBit
=
document
.
createDocumentFragment
(
)
;
addonBit
.
appendChild
(
image
)
;
addonBit
.
appendChild
(
document
.
createTextNode
(
"
"
+
addon
.
name
)
)
;
let
fragment
=
BrowserUtils
.
getLocalizedFragment
(
document
msg
addonBit
)
;
description
.
appendChild
(
fragment
)
;
if
(
elements
.
button
)
{
elements
.
button
.
hidden
=
false
;
}
elements
.
section
.
hidden
=
false
;
}
function
hideControllingExtension
(
settingName
)
{
let
elements
=
getControllingExtensionEls
(
settingName
)
;
elements
.
section
.
hidden
=
true
;
if
(
elements
.
button
)
{
elements
.
button
.
hidden
=
true
;
}
}
function
showEnableExtensionMessage
(
settingName
)
{
let
elements
=
getControllingExtensionEls
(
settingName
)
;
elements
.
button
.
hidden
=
true
;
elements
.
section
.
classList
.
add
(
"
extension
-
controlled
-
disabled
"
)
;
let
icon
=
url
=
>
{
let
img
=
document
.
createElement
(
"
image
"
)
;
img
.
src
=
url
;
img
.
className
=
"
extension
-
controlled
-
icon
"
;
return
img
;
}
;
let
addonIcon
=
icon
(
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extensionGeneric
-
16
.
svg
"
)
;
let
toolbarIcon
=
icon
(
"
chrome
:
/
/
browser
/
skin
/
menu
.
svg
"
)
;
let
message
=
document
.
getElementById
(
"
bundlePreferences
"
)
.
getString
(
"
extensionControlled
.
enable
"
)
;
let
frag
=
BrowserUtils
.
getLocalizedFragment
(
document
message
addonIcon
toolbarIcon
)
;
elements
.
description
.
innerHTML
=
"
"
;
elements
.
description
.
appendChild
(
frag
)
;
let
dismissButton
=
document
.
createElement
(
"
image
"
)
;
dismissButton
.
setAttribute
(
"
class
"
"
extension
-
controlled
-
icon
close
-
icon
"
)
;
dismissButton
.
addEventListener
(
"
click
"
function
dismissHandler
(
)
{
hideControllingExtension
(
settingName
)
;
dismissButton
.
removeEventListener
(
"
click
"
dismissHandler
)
;
}
)
;
elements
.
description
.
appendChild
(
dismissButton
)
;
}
function
makeDisableControllingExtension
(
type
settingName
)
{
return
async
function
disableExtension
(
)
{
let
{
id
}
=
await
getControllingExtensionInfo
(
type
settingName
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
addon
.
userDisabled
=
true
;
}
;
}
