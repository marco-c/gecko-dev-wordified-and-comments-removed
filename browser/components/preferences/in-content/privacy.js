Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ContextualIdentityService
"
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PluralForm
"
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
var
gPrivacyPane
=
{
_autoStartPrivateBrowsing
:
false
_shouldPromptForRestart
:
true
_initTrackingProtection
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
trackingprotection
.
ui
.
enabled
"
)
)
{
return
;
}
let
link
=
document
.
getElementById
(
"
trackingProtectionLearnMore
"
)
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
tracking
-
protection
"
;
link
.
setAttribute
(
"
href
"
url
)
;
this
.
trackingProtectionReadPrefs
(
)
;
document
.
getElementById
(
"
trackingprotectionbox
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
trackingprotectionpbmbox
"
)
.
hidden
=
true
;
}
_initTrackingProtectionPBM
(
)
{
let
link
=
document
.
getElementById
(
"
trackingProtectionPBMLearnMore
"
)
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
tracking
-
protection
-
pbm
"
;
link
.
setAttribute
(
"
href
"
url
)
;
}
_initAutocomplete
(
)
{
Components
.
classes
[
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
unifiedcomplete
"
]
.
getService
(
Components
.
interfaces
.
mozIPlacesAutoComplete
)
;
}
_initBrowserContainers
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
ui
.
enabled
"
)
)
{
return
;
}
let
link
=
document
.
getElementById
(
"
browserContainersLearnMore
"
)
;
link
.
href
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
containers
"
;
document
.
getElementById
(
"
browserContainersbox
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
browserContainersCheckbox
"
)
.
checked
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
;
}
_checkBrowserContainers
(
event
)
{
let
checkbox
=
document
.
getElementById
(
"
browserContainersCheckbox
"
)
;
if
(
checkbox
.
checked
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
true
)
;
return
;
}
let
count
=
ContextualIdentityService
.
countContainerTabs
(
)
;
if
(
count
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
title
=
bundlePreferences
.
getString
(
"
disableContainersAlertTitle
"
)
;
let
message
=
PluralForm
.
get
(
count
bundlePreferences
.
getString
(
"
disableContainersMsg
"
)
)
.
replace
(
"
#
S
"
count
)
let
okButton
=
PluralForm
.
get
(
count
bundlePreferences
.
getString
(
"
disableContainersOkButton
"
)
)
.
replace
(
"
#
S
"
count
)
let
cancelButton
=
bundlePreferences
.
getString
(
"
disableContainersButton2
"
)
;
let
buttonFlags
=
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
)
+
(
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
)
;
let
rv
=
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
if
(
rv
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
checkbox
.
checked
=
true
;
}
init
(
)
{
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gPrivacyPane
)
)
;
}
this
.
_updateSanitizeSettingsButton
(
)
;
this
.
initializeHistoryMode
(
)
;
this
.
updateHistoryModePane
(
)
;
this
.
updatePrivacyMicroControls
(
)
;
this
.
initAutoStartPrivateBrowsingReverter
(
)
;
this
.
_initTrackingProtection
(
)
;
this
.
_initTrackingProtectionPBM
(
)
;
this
.
_initAutocomplete
(
)
;
this
.
_initBrowserContainers
(
)
;
setEventListener
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
"
change
"
gPrivacyPane
.
_updateSanitizeSettingsButton
)
;
setEventListener
(
"
browser
.
privatebrowsing
.
autostart
"
"
change
"
gPrivacyPane
.
updatePrivacyMicroControls
)
;
setEventListener
(
"
historyMode
"
"
command
"
function
(
)
{
gPrivacyPane
.
updateHistoryModePane
(
)
;
gPrivacyPane
.
updateHistoryModePrefs
(
)
;
gPrivacyPane
.
updatePrivacyMicroControls
(
)
;
gPrivacyPane
.
updateAutostart
(
)
;
}
)
;
setEventListener
(
"
historyRememberClear
"
"
click
"
function
(
)
{
gPrivacyPane
.
clearPrivateDataNow
(
false
)
;
return
false
;
}
)
;
setEventListener
(
"
historyRememberCookies
"
"
click
"
function
(
)
{
gPrivacyPane
.
showCookies
(
)
;
return
false
;
}
)
;
setEventListener
(
"
historyDontRememberClear
"
"
click
"
function
(
)
{
gPrivacyPane
.
clearPrivateDataNow
(
true
)
;
return
false
;
}
)
;
setEventListener
(
"
doNotTrackSettings
"
"
click
"
function
(
)
{
gPrivacyPane
.
showDoNotTrackSettings
(
)
;
return
false
;
}
)
;
setEventListener
(
"
privateBrowsingAutoStart
"
"
command
"
gPrivacyPane
.
updateAutostart
)
;
setEventListener
(
"
cookieExceptions
"
"
command
"
gPrivacyPane
.
showCookieExceptions
)
;
setEventListener
(
"
showCookiesButton
"
"
command
"
gPrivacyPane
.
showCookies
)
;
setEventListener
(
"
clearDataSettings
"
"
command
"
gPrivacyPane
.
showClearPrivateDataSettings
)
;
setEventListener
(
"
trackingProtectionRadioGroup
"
"
command
"
gPrivacyPane
.
trackingProtectionWritePrefs
)
;
setEventListener
(
"
trackingProtectionExceptions
"
"
command
"
gPrivacyPane
.
showTrackingProtectionExceptions
)
;
setEventListener
(
"
changeBlockList
"
"
command
"
gPrivacyPane
.
showBlockLists
)
;
setEventListener
(
"
changeBlockListPBM
"
"
command
"
gPrivacyPane
.
showBlockLists
)
;
setEventListener
(
"
browserContainersCheckbox
"
"
command
"
gPrivacyPane
.
_checkBrowserContainers
)
;
setEventListener
(
"
browserContainersSettings
"
"
command
"
gPrivacyPane
.
showContainerSettings
)
;
}
trackingProtectionReadPrefs
(
)
{
let
enabledPref
=
document
.
getElementById
(
"
privacy
.
trackingprotection
.
enabled
"
)
;
let
pbmPref
=
document
.
getElementById
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
;
let
radiogroup
=
document
.
getElementById
(
"
trackingProtectionRadioGroup
"
)
;
if
(
enabledPref
.
value
)
{
radiogroup
.
value
=
"
always
"
;
}
else
if
(
pbmPref
.
value
)
{
radiogroup
.
value
=
"
private
"
;
}
else
{
radiogroup
.
value
=
"
never
"
;
}
}
trackingProtectionWritePrefs
(
)
{
let
enabledPref
=
document
.
getElementById
(
"
privacy
.
trackingprotection
.
enabled
"
)
;
let
pbmPref
=
document
.
getElementById
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
;
let
radiogroup
=
document
.
getElementById
(
"
trackingProtectionRadioGroup
"
)
;
switch
(
radiogroup
.
value
)
{
case
"
always
"
:
enabledPref
.
value
=
true
;
pbmPref
.
value
=
true
;
break
;
case
"
private
"
:
enabledPref
.
value
=
false
;
pbmPref
.
value
=
true
;
break
;
case
"
never
"
:
enabledPref
.
value
=
false
;
pbmPref
.
value
=
false
;
break
;
}
}
prefsForKeepingHistory
:
{
"
places
.
history
.
enabled
"
:
true
"
browser
.
formfill
.
enable
"
:
true
"
network
.
cookie
.
cookieBehavior
"
:
0
"
network
.
cookie
.
lifetimePolicy
"
:
0
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
:
false
}
dependentControls
:
[
"
rememberHistory
"
"
rememberForms
"
"
keepUntil
"
"
keepCookiesUntil
"
"
alwaysClear
"
"
clearDataSettings
"
]
_checkHistoryValues
(
aPrefs
)
{
for
(
let
pref
of
Object
.
keys
(
aPrefs
)
)
{
if
(
document
.
getElementById
(
pref
)
.
value
!
=
aPrefs
[
pref
]
)
return
false
;
}
return
true
;
}
initializeHistoryMode
(
)
{
let
mode
;
let
getVal
=
aPref
=
>
document
.
getElementById
(
aPref
)
.
value
;
if
(
getVal
(
"
privacy
.
history
.
custom
"
)
)
mode
=
"
custom
"
;
else
if
(
this
.
_checkHistoryValues
(
this
.
prefsForKeepingHistory
)
)
{
if
(
getVal
(
"
browser
.
privatebrowsing
.
autostart
"
)
)
mode
=
"
dontremember
"
;
else
mode
=
"
remember
"
;
}
else
mode
=
"
custom
"
;
document
.
getElementById
(
"
historyMode
"
)
.
value
=
mode
;
}
updateHistoryModePane
(
)
{
let
selectedIndex
=
-
1
;
switch
(
document
.
getElementById
(
"
historyMode
"
)
.
value
)
{
case
"
remember
"
:
selectedIndex
=
0
;
break
;
case
"
dontremember
"
:
selectedIndex
=
1
;
break
;
case
"
custom
"
:
selectedIndex
=
2
;
break
;
}
document
.
getElementById
(
"
historyPane
"
)
.
selectedIndex
=
selectedIndex
;
document
.
getElementById
(
"
privacy
.
history
.
custom
"
)
.
value
=
selectedIndex
=
=
2
;
}
updateHistoryModePrefs
(
)
{
let
pref
=
document
.
getElementById
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
switch
(
document
.
getElementById
(
"
historyMode
"
)
.
value
)
{
case
"
remember
"
:
if
(
pref
.
value
)
pref
.
value
=
false
;
document
.
getElementById
(
"
places
.
history
.
enabled
"
)
.
value
=
true
;
document
.
getElementById
(
"
browser
.
formfill
.
enable
"
)
.
value
=
true
;
document
.
getElementById
(
"
network
.
cookie
.
cookieBehavior
"
)
.
value
=
0
;
document
.
getElementById
(
"
network
.
cookie
.
lifetimePolicy
"
)
.
value
=
0
;
document
.
getElementById
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
=
false
;
break
;
case
"
dontremember
"
:
if
(
!
pref
.
value
)
pref
.
value
=
true
;
break
;
}
}
updatePrivacyMicroControls
(
)
{
if
(
document
.
getElementById
(
"
historyMode
"
)
.
value
=
=
"
custom
"
)
{
let
disabled
=
this
.
_autoStartPrivateBrowsing
=
document
.
getElementById
(
"
privateBrowsingAutoStart
"
)
.
checked
;
this
.
dependentControls
.
forEach
(
function
(
aElement
)
{
let
control
=
document
.
getElementById
(
aElement
)
;
let
preferenceId
=
control
.
getAttribute
(
"
preference
"
)
;
if
(
!
preferenceId
)
{
let
dependentControlId
=
control
.
getAttribute
(
"
control
"
)
;
if
(
dependentControlId
)
{
let
dependentControl
=
document
.
getElementById
(
dependentControlId
)
;
preferenceId
=
dependentControl
.
getAttribute
(
"
preference
"
)
;
}
}
let
preference
=
preferenceId
?
document
.
getElementById
(
preferenceId
)
:
{
}
;
control
.
disabled
=
disabled
|
|
preference
.
locked
;
}
)
;
this
.
readAcceptCookies
(
)
;
let
lifetimePolicy
=
document
.
getElementById
(
"
network
.
cookie
.
lifetimePolicy
"
)
.
value
;
if
(
lifetimePolicy
!
=
Ci
.
nsICookieService
.
ACCEPT_NORMALLY
&
&
lifetimePolicy
!
=
Ci
.
nsICookieService
.
ACCEPT_SESSION
&
&
lifetimePolicy
!
=
Ci
.
nsICookieService
.
ACCEPT_FOR_N_DAYS
)
{
lifetimePolicy
=
Ci
.
nsICookieService
.
ACCEPT_NORMALLY
;
}
document
.
getElementById
(
"
keepCookiesUntil
"
)
.
value
=
disabled
?
2
:
lifetimePolicy
;
document
.
getElementById
(
"
alwaysClear
"
)
.
checked
=
disabled
?
false
:
document
.
getElementById
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
;
document
.
getElementById
(
"
rememberHistory
"
)
.
checked
=
disabled
?
false
:
document
.
getElementById
(
"
places
.
history
.
enabled
"
)
.
value
;
document
.
getElementById
(
"
rememberForms
"
)
.
checked
=
disabled
?
false
:
document
.
getElementById
(
"
browser
.
formfill
.
enable
"
)
.
value
;
if
(
!
disabled
)
{
this
.
_updateSanitizeSettingsButton
(
)
;
}
}
}
initAutoStartPrivateBrowsingReverter
(
)
{
let
mode
=
document
.
getElementById
(
"
historyMode
"
)
;
let
autoStart
=
document
.
getElementById
(
"
privateBrowsingAutoStart
"
)
;
this
.
_lastMode
=
mode
.
selectedIndex
;
this
.
_lastCheckState
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
}
_lastMode
:
null
_lastCheckState
:
null
updateAutostart
(
)
{
let
mode
=
document
.
getElementById
(
"
historyMode
"
)
;
let
autoStart
=
document
.
getElementById
(
"
privateBrowsingAutoStart
"
)
;
let
pref
=
document
.
getElementById
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
if
(
(
mode
.
value
=
=
"
custom
"
&
&
this
.
_lastCheckState
=
=
autoStart
.
checked
)
|
|
(
mode
.
value
=
=
"
remember
"
&
&
!
this
.
_lastCheckState
)
|
|
(
mode
.
value
=
=
"
dontremember
"
&
&
this
.
_lastCheckState
)
)
{
this
.
_lastMode
=
mode
.
selectedIndex
;
this
.
_lastCheckState
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
return
;
}
if
(
!
this
.
_shouldPromptForRestart
)
{
return
;
}
let
buttonIndex
=
confirmRestartPrompt
(
autoStart
.
checked
1
true
false
)
;
if
(
buttonIndex
=
=
CONFIRM_RESTART_PROMPT_RESTART_NOW
)
{
pref
.
value
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
let
appStartup
=
Cc
[
"
mozilla
.
org
/
toolkit
/
app
-
startup
;
1
"
]
.
getService
(
Ci
.
nsIAppStartup
)
;
appStartup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
return
;
}
this
.
_shouldPromptForRestart
=
false
;
if
(
this
.
_lastCheckState
)
{
autoStart
.
checked
=
"
checked
"
;
}
else
{
autoStart
.
removeAttribute
(
"
checked
"
)
;
}
pref
.
value
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
mode
.
selectedIndex
=
this
.
_lastMode
;
mode
.
doCommand
(
)
;
this
.
_shouldPromptForRestart
=
true
;
}
showTrackingProtectionExceptions
(
)
{
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
params
=
{
permissionType
:
"
trackingprotection
"
hideStatusColumn
:
true
windowTitle
:
bundlePreferences
.
getString
(
"
trackingprotectionpermissionstitle
"
)
introText
:
bundlePreferences
.
getString
(
"
trackingprotectionpermissionstext2
"
)
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
null
params
)
;
}
showContainerSettings
(
)
{
gotoPref
(
"
containers
"
)
;
}
showBlockLists
(
)
{
var
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
brandName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
var
params
=
{
brandShortName
:
brandName
windowTitle
:
bundlePreferences
.
getString
(
"
blockliststitle
"
)
introText
:
bundlePreferences
.
getString
(
"
blockliststext
"
)
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
blocklists
.
xul
"
null
params
)
;
}
showDoNotTrackSettings
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
donottrack
.
xul
"
"
resizable
=
no
"
)
;
}
readAcceptCookies
(
)
{
var
pref
=
document
.
getElementById
(
"
network
.
cookie
.
cookieBehavior
"
)
;
var
acceptThirdPartyLabel
=
document
.
getElementById
(
"
acceptThirdPartyLabel
"
)
;
var
acceptThirdPartyMenu
=
document
.
getElementById
(
"
acceptThirdPartyMenu
"
)
;
var
keepUntil
=
document
.
getElementById
(
"
keepUntil
"
)
;
var
menu
=
document
.
getElementById
(
"
keepCookiesUntil
"
)
;
var
acceptCookies
=
(
pref
.
value
!
=
2
)
;
acceptThirdPartyLabel
.
disabled
=
acceptThirdPartyMenu
.
disabled
=
!
acceptCookies
;
keepUntil
.
disabled
=
menu
.
disabled
=
this
.
_autoStartPrivateBrowsing
|
|
!
acceptCookies
;
return
acceptCookies
;
}
writeAcceptCookies
(
)
{
var
accept
=
document
.
getElementById
(
"
acceptCookies
"
)
;
var
acceptThirdPartyMenu
=
document
.
getElementById
(
"
acceptThirdPartyMenu
"
)
;
if
(
accept
.
checked
)
acceptThirdPartyMenu
.
selectedIndex
=
0
;
return
accept
.
checked
?
0
:
2
;
}
readAcceptThirdPartyCookies
(
)
{
var
pref
=
document
.
getElementById
(
"
network
.
cookie
.
cookieBehavior
"
)
;
switch
(
pref
.
value
)
{
case
0
:
return
"
always
"
;
case
1
:
return
"
never
"
;
case
2
:
return
"
never
"
;
case
3
:
return
"
visited
"
;
default
:
return
undefined
;
}
}
writeAcceptThirdPartyCookies
(
)
{
var
accept
=
document
.
getElementById
(
"
acceptThirdPartyMenu
"
)
.
selectedItem
;
switch
(
accept
.
value
)
{
case
"
always
"
:
return
0
;
case
"
visited
"
:
return
3
;
case
"
never
"
:
return
1
;
default
:
return
undefined
;
}
}
showCookieExceptions
(
)
{
var
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
params
=
{
blockVisible
:
true
sessionVisible
:
true
allowVisible
:
true
prefilledHost
:
"
"
permissionType
:
"
cookie
"
windowTitle
:
bundlePreferences
.
getString
(
"
cookiepermissionstitle
"
)
introText
:
bundlePreferences
.
getString
(
"
cookiepermissionstext
"
)
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
null
params
)
;
}
showCookies
(
aCategory
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
cookies
.
xul
"
)
;
}
showClearPrivateDataSettings
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
sanitize
.
xul
"
"
resizable
=
no
"
)
;
}
clearPrivateDataNow
(
aClearEverything
)
{
var
ts
=
document
.
getElementById
(
"
privacy
.
sanitize
.
timeSpan
"
)
;
var
timeSpanOrig
=
ts
.
value
;
if
(
aClearEverything
)
{
ts
.
value
=
0
;
}
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
sanitize
.
xul
"
"
resizable
=
no
"
null
(
)
=
>
{
if
(
aClearEverything
)
{
ts
.
value
=
timeSpanOrig
;
}
Services
.
obs
.
notifyObservers
(
null
"
clear
-
private
-
data
"
)
;
}
)
;
}
_updateSanitizeSettingsButton
(
)
{
var
settingsButton
=
document
.
getElementById
(
"
clearDataSettings
"
)
;
var
sanitizeOnShutdownPref
=
document
.
getElementById
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
;
settingsButton
.
disabled
=
!
sanitizeOnShutdownPref
.
value
;
}
readBrowserContainersCheckbox
(
)
{
var
pref
=
document
.
getElementById
(
"
privacy
.
userContext
.
enabled
"
)
;
var
settings
=
document
.
getElementById
(
"
browserContainersSettings
"
)
;
settings
.
disabled
=
!
pref
.
value
;
}
}
;
