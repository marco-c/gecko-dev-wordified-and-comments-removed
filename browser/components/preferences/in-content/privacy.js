ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PluralForm
"
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LoginHelper
"
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SiteDataManager
"
"
resource
:
/
/
/
modules
/
SiteDataManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
trackingprotectionUiEnabled
"
"
privacy
.
trackingprotection
.
ui
.
enabled
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
PREF_UPLOAD_ENABLED
=
"
datareporting
.
healthreport
.
uploadEnabled
"
;
const
TRACKING_PROTECTION_KEY
=
"
websites
.
trackingProtectionMode
"
;
const
TRACKING_PROTECTION_PREFS
=
[
"
privacy
.
trackingprotection
.
enabled
"
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
AlertsServiceDND
"
function
(
)
{
try
{
let
alertsService
=
Cc
[
"
mozilla
.
org
/
alerts
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAlertsService
)
.
QueryInterface
(
Ci
.
nsIAlertsDoNotDisturb
)
;
alertsService
.
manualDoNotDisturb
;
return
alertsService
;
}
catch
(
ex
)
{
return
undefined
;
}
}
)
;
Preferences
.
addAll
(
[
{
id
:
"
privacy
.
trackingprotection
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
cookie_exceptions
"
type
:
"
bool
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
view_cookies
"
type
:
"
bool
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
change_blocklist
"
type
:
"
bool
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
tracking_protection_exceptions
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
autocomplete
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
bookmark
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
history
"
type
:
"
bool
"
}
{
id
:
"
browser
.
urlbar
.
suggest
.
openpage
"
type
:
"
bool
"
}
{
id
:
"
places
.
history
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
formfill
.
enable
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
history
.
custom
"
type
:
"
bool
"
}
{
id
:
"
network
.
cookie
.
cookieBehavior
"
type
:
"
int
"
}
{
id
:
"
network
.
cookie
.
lifetimePolicy
"
type
:
"
int
"
}
{
id
:
"
network
.
cookie
.
blockFutureCookies
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
sanitize
.
timeSpan
"
type
:
"
int
"
}
{
id
:
"
privacy
.
donottrackheader
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
dom
.
disable_open_during_load
"
type
:
"
bool
"
}
{
id
:
"
signon
.
rememberSignons
"
type
:
"
bool
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
view_passwords
"
type
:
"
bool
"
}
{
id
:
"
pref
.
privacy
.
disable_button
.
view_passwords_exceptions
"
type
:
"
bool
"
}
{
id
:
"
security
.
default_personal_cert
"
type
:
"
string
"
}
{
id
:
"
security
.
disable_button
.
openCertManager
"
type
:
"
bool
"
}
{
id
:
"
security
.
disable_button
.
openDeviceManager
"
type
:
"
bool
"
}
{
id
:
"
security
.
OCSP
.
enabled
"
type
:
"
int
"
}
{
id
:
"
xpinstall
.
whitelist
.
required
"
type
:
"
bool
"
}
{
id
:
"
browser
.
safebrowsing
.
malware
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
safebrowsing
.
phishing
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
safebrowsing
.
downloads
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
urlclassifier
.
malwareTable
"
type
:
"
string
"
}
{
id
:
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_potentially_unwanted
"
type
:
"
bool
"
}
{
id
:
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_uncommon
"
type
:
"
bool
"
}
{
id
:
"
browser
.
cache
.
disk
.
capacity
"
type
:
"
int
"
}
{
id
:
"
browser
.
cache
.
disk
.
smart_size
.
enabled
"
type
:
"
bool
"
inverted
:
"
true
"
}
]
)
;
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
Preferences
.
add
(
{
id
:
"
browser
.
chrome
.
errorReporter
.
enabled
"
type
:
"
bool
"
}
)
;
}
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
Preferences
.
add
(
{
id
:
"
browser
.
crashReports
.
unsubmittedCheck
.
autoSubmit2
"
type
:
"
bool
"
}
)
;
}
var
gPrivacyPane
=
{
_pane
:
null
_autoStartPrivateBrowsing
:
false
_shouldPromptForRestart
:
true
_initTrackingProtection
(
)
{
if
(
!
trackingprotectionUiEnabled
)
{
return
;
}
let
link
=
document
.
getElementById
(
"
trackingProtectionLearnMore
"
)
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
tracking
-
protection
"
;
link
.
setAttribute
(
"
href
"
url
)
;
this
.
trackingProtectionReadPrefs
(
)
;
document
.
getElementById
(
"
trackingProtectionExceptions
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
trackingProtectionBox
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
trackingProtectionPBMBox
"
)
.
hidden
=
true
;
}
_initTrackingProtectionPBM
(
)
{
if
(
trackingprotectionUiEnabled
)
{
return
;
}
let
link
=
document
.
getElementById
(
"
trackingProtectionLearnMore
"
)
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
tracking
-
protection
-
pbm
"
;
link
.
setAttribute
(
"
href
"
url
)
;
this
.
_updateTrackingProtectionUI
(
)
;
}
_updateTrackingProtectionUI
(
)
{
let
isLocked
=
TRACKING_PROTECTION_PREFS
.
some
(
pref
=
>
Services
.
prefs
.
prefIsLocked
(
pref
)
)
;
function
setInputsDisabledState
(
isControlled
)
{
let
disabled
=
isLocked
|
|
isControlled
;
if
(
trackingprotectionUiEnabled
)
{
document
.
querySelectorAll
(
"
#
trackingProtectionRadioGroup
>
radio
"
)
.
forEach
(
(
element
)
=
>
{
element
.
disabled
=
disabled
;
}
)
;
document
.
querySelector
(
"
#
trackingProtectionDesc
>
label
"
)
.
disabled
=
disabled
;
}
else
{
document
.
getElementById
(
"
trackingProtectionPBM
"
)
.
disabled
=
disabled
;
document
.
getElementById
(
"
trackingProtectionPBMLabel
"
)
.
disabled
=
disabled
;
}
}
if
(
isLocked
)
{
hideControllingExtension
(
TRACKING_PROTECTION_KEY
)
;
setInputsDisabledState
(
false
)
;
}
else
{
handleControllingExtension
(
PREF_SETTING_TYPE
TRACKING_PROTECTION_KEY
)
.
then
(
setInputsDisabledState
)
;
}
}
_initTrackingProtectionExtensionControl
(
)
{
let
trackingProtectionObserver
=
{
observe
(
subject
topic
data
)
{
gPrivacyPane
.
_updateTrackingProtectionUI
(
)
;
}
}
;
for
(
let
pref
of
TRACKING_PROTECTION_PREFS
)
{
Services
.
prefs
.
addObserver
(
pref
trackingProtectionObserver
)
;
}
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
for
(
let
pref
of
TRACKING_PROTECTION_PREFS
)
{
Services
.
prefs
.
removeObserver
(
pref
trackingProtectionObserver
)
;
}
}
)
;
}
_initAutocomplete
(
)
{
Components
.
classes
[
"
mozilla
.
org
/
autocomplete
/
search
;
1
?
name
=
unifiedcomplete
"
]
.
getService
(
Components
.
interfaces
.
mozIPlacesAutoComplete
)
;
}
init
(
)
{
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gPrivacyPane
)
)
;
}
this
.
_updateSanitizeSettingsButton
(
)
;
this
.
initializeHistoryMode
(
)
;
this
.
updateHistoryModePane
(
)
;
this
.
updatePrivacyMicroControls
(
)
;
this
.
initAutoStartPrivateBrowsingReverter
(
)
;
this
.
_initTrackingProtection
(
)
;
this
.
_initTrackingProtectionPBM
(
)
;
this
.
_initTrackingProtectionExtensionControl
(
)
;
this
.
_initAutocomplete
(
)
;
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
on
(
"
change
"
gPrivacyPane
.
_updateSanitizeSettingsButton
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
on
(
"
change
"
gPrivacyPane
.
updatePrivacyMicroControls
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
privacy
.
trackingprotection
.
enabled
"
)
.
on
(
"
change
"
gPrivacyPane
.
trackingProtectionReadPrefs
.
bind
(
gPrivacyPane
)
)
;
Preferences
.
get
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
.
on
(
"
change
"
gPrivacyPane
.
trackingProtectionReadPrefs
.
bind
(
gPrivacyPane
)
)
;
setEventListener
(
"
historyMode
"
"
command
"
function
(
)
{
gPrivacyPane
.
updateHistoryModePane
(
)
;
gPrivacyPane
.
updateHistoryModePrefs
(
)
;
gPrivacyPane
.
updatePrivacyMicroControls
(
)
;
gPrivacyPane
.
updateAutostart
(
)
;
}
)
;
setEventListener
(
"
historyRememberClear
"
"
click
"
function
(
event
)
{
if
(
event
.
button
=
=
0
)
{
gPrivacyPane
.
clearPrivateDataNow
(
false
)
;
}
return
false
;
}
)
;
setEventListener
(
"
historyRememberCookies
"
"
click
"
function
(
event
)
{
if
(
event
.
button
=
=
0
)
{
gPrivacyPane
.
showCookies
(
)
;
}
return
false
;
}
)
;
setEventListener
(
"
historyDontRememberClear
"
"
click
"
function
(
event
)
{
if
(
event
.
button
=
=
0
)
{
gPrivacyPane
.
clearPrivateDataNow
(
true
)
;
}
return
false
;
}
)
;
setEventListener
(
"
openSearchEnginePreferences
"
"
click
"
function
(
event
)
{
if
(
event
.
button
=
=
0
)
{
gotoPref
(
"
search
"
)
;
}
return
false
;
}
)
;
setEventListener
(
"
privateBrowsingAutoStart
"
"
command
"
gPrivacyPane
.
updateAutostart
)
;
setEventListener
(
"
cookieExceptions
"
"
command
"
gPrivacyPane
.
showCookieExceptions
)
;
setEventListener
(
"
showCookiesButton
"
"
command
"
gPrivacyPane
.
showCookies
)
;
setEventListener
(
"
clearDataSettings
"
"
command
"
gPrivacyPane
.
showClearPrivateDataSettings
)
;
setEventListener
(
"
disableTrackingProtectionExtension
"
"
command
"
makeDisableControllingExtension
(
PREF_SETTING_TYPE
TRACKING_PROTECTION_KEY
)
)
;
setEventListener
(
"
trackingProtectionRadioGroup
"
"
command
"
gPrivacyPane
.
trackingProtectionWritePrefs
)
;
setEventListener
(
"
trackingProtectionExceptions
"
"
command
"
gPrivacyPane
.
showTrackingProtectionExceptions
)
;
setEventListener
(
"
changeBlockList
"
"
command
"
gPrivacyPane
.
showBlockLists
)
;
setEventListener
(
"
passwordExceptions
"
"
command
"
gPrivacyPane
.
showPasswordExceptions
)
;
setEventListener
(
"
useMasterPassword
"
"
command
"
gPrivacyPane
.
updateMasterPasswordButton
)
;
setEventListener
(
"
changeMasterPassword
"
"
command
"
gPrivacyPane
.
changeMasterPassword
)
;
setEventListener
(
"
showPasswords
"
"
command
"
gPrivacyPane
.
showPasswords
)
;
setEventListener
(
"
addonExceptions
"
"
command
"
gPrivacyPane
.
showAddonExceptions
)
;
setEventListener
(
"
viewCertificatesButton
"
"
command
"
gPrivacyPane
.
showCertificates
)
;
setEventListener
(
"
viewSecurityDevicesButton
"
"
command
"
gPrivacyPane
.
showSecurityDevices
)
;
setEventListener
(
"
clearCacheButton
"
"
command
"
gPrivacyPane
.
clearCache
)
;
this
.
_pane
=
document
.
getElementById
(
"
panePrivacy
"
)
;
this
.
_initMasterPasswordUI
(
)
;
this
.
_initSafeBrowsing
(
)
;
this
.
updateCacheSizeInputField
(
)
;
this
.
updateActualCacheSize
(
)
;
setEventListener
(
"
notificationSettingsButton
"
"
command
"
gPrivacyPane
.
showNotificationExceptions
)
;
setEventListener
(
"
locationSettingsButton
"
"
command
"
gPrivacyPane
.
showLocationExceptions
)
;
setEventListener
(
"
cameraSettingsButton
"
"
command
"
gPrivacyPane
.
showCameraExceptions
)
;
setEventListener
(
"
microphoneSettingsButton
"
"
command
"
gPrivacyPane
.
showMicrophoneExceptions
)
;
setEventListener
(
"
popupPolicyButton
"
"
command
"
gPrivacyPane
.
showPopupExceptions
)
;
setEventListener
(
"
notificationsDoNotDisturb
"
"
command
"
gPrivacyPane
.
toggleDoNotDisturbNotifications
)
;
let
bundlePrefs
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
if
(
AlertsServiceDND
)
{
let
notificationsDoNotDisturbBox
=
document
.
getElementById
(
"
notificationsDoNotDisturbBox
"
)
;
notificationsDoNotDisturbBox
.
removeAttribute
(
"
hidden
"
)
;
let
checkbox
=
document
.
getElementById
(
"
notificationsDoNotDisturb
"
)
;
let
brandName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
checkbox
.
setAttribute
(
"
label
"
bundlePrefs
.
getFormattedString
(
"
pauseNotifications
.
label
"
[
brandName
]
)
)
;
checkbox
.
setAttribute
(
"
accesskey
"
bundlePrefs
.
getString
(
"
pauseNotifications
.
accesskey
"
)
)
;
if
(
AlertsServiceDND
.
manualDoNotDisturb
)
{
let
notificationsDoNotDisturb
=
document
.
getElementById
(
"
notificationsDoNotDisturb
"
)
;
notificationsDoNotDisturb
.
setAttribute
(
"
checked
"
true
)
;
}
}
setEventListener
(
"
cacheSize
"
"
change
"
gPrivacyPane
.
updateCacheSizePref
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
storageManager
.
enabled
"
)
)
{
Services
.
obs
.
addObserver
(
this
"
sitedatamanager
:
sites
-
updated
"
)
;
Services
.
obs
.
addObserver
(
this
"
sitedatamanager
:
updating
-
sites
"
)
;
let
unload
=
(
)
=
>
{
window
.
removeEventListener
(
"
unload
"
unload
)
;
Services
.
obs
.
removeObserver
(
this
"
sitedatamanager
:
sites
-
updated
"
)
;
Services
.
obs
.
removeObserver
(
this
"
sitedatamanager
:
updating
-
sites
"
)
;
}
;
window
.
addEventListener
(
"
unload
"
unload
)
;
SiteDataManager
.
updateSites
(
)
;
setEventListener
(
"
clearSiteDataButton
"
"
command
"
gPrivacyPane
.
clearSiteData
)
;
setEventListener
(
"
siteDataSettings
"
"
command
"
gPrivacyPane
.
showSiteDataSettings
)
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
storage
-
permissions
"
;
document
.
getElementById
(
"
siteDataLearnMoreLink
"
)
.
setAttribute
(
"
href
"
url
)
;
let
siteDataGroup
=
document
.
getElementById
(
"
siteDataGroup
"
)
;
siteDataGroup
.
removeAttribute
(
"
data
-
hidden
-
from
-
search
"
)
;
}
let
notificationInfoURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
push
"
;
document
.
getElementById
(
"
notificationPermissionsLearnMore
"
)
.
setAttribute
(
"
href
"
notificationInfoURL
)
;
let
drmInfoURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
drm
-
content
"
;
document
.
getElementById
(
"
playDRMContentLink
"
)
.
setAttribute
(
"
href
"
drmInfoURL
)
;
let
emeUIEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
eme
.
ui
.
enabled
"
)
;
if
(
navigator
.
platform
.
toLowerCase
(
)
.
startsWith
(
"
win
"
)
)
{
emeUIEnabled
=
emeUIEnabled
&
&
parseFloat
(
Services
.
sysinfo
.
get
(
"
version
"
)
)
>
=
6
;
}
if
(
!
emeUIEnabled
)
{
document
.
getElementById
(
"
drmGroup
"
)
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
}
if
(
AppConstants
.
MOZ_DATA_REPORTING
)
{
this
.
initDataCollection
(
)
;
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
this
.
initCollectBrowserErrors
(
)
;
}
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
this
.
initSubmitCrashes
(
)
;
}
this
.
initSubmitHealthReport
(
)
;
setEventListener
(
"
submitHealthReportBox
"
"
command
"
gPrivacyPane
.
updateSubmitHealthReport
)
;
}
this
.
_initA11yState
(
)
;
let
signonBundle
=
document
.
getElementById
(
"
signonBundle
"
)
;
let
pkiBundle
=
document
.
getElementById
(
"
pkiBundle
"
)
;
appendSearchKeywords
(
"
passwordExceptions
"
[
bundlePrefs
.
getString
(
"
savedLoginsExceptions_title
"
)
bundlePrefs
.
getString
(
"
savedLoginsExceptions_desc3
"
)
]
)
;
appendSearchKeywords
(
"
showPasswords
"
[
signonBundle
.
getString
(
"
loginsDescriptionAll2
"
)
]
)
;
appendSearchKeywords
(
"
cookieExceptions
"
[
bundlePrefs
.
getString
(
"
cookiepermissionstext
"
)
]
)
;
appendSearchKeywords
(
"
showCookiesButton
"
[
bundlePrefs
.
getString
(
"
cookiesAll
"
)
bundlePrefs
.
getString
(
"
removeAllCookies
.
label
"
)
bundlePrefs
.
getString
(
"
removeAllShownCookies
.
label
"
)
bundlePrefs
.
getString
(
"
removeSelectedCookies
.
label
"
)
]
)
;
appendSearchKeywords
(
"
trackingProtectionExceptions
"
[
bundlePrefs
.
getString
(
"
trackingprotectionpermissionstitle
"
)
bundlePrefs
.
getString
(
"
trackingprotectionpermissionstext2
"
)
]
)
;
appendSearchKeywords
(
"
changeBlockList
"
[
bundlePrefs
.
getString
(
"
blockliststitle
"
)
bundlePrefs
.
getString
(
"
blockliststext
"
)
]
)
;
appendSearchKeywords
(
"
popupPolicyButton
"
[
bundlePrefs
.
getString
(
"
popuppermissionstitle2
"
)
bundlePrefs
.
getString
(
"
popuppermissionstext
"
)
]
)
;
appendSearchKeywords
(
"
notificationSettingsButton
"
[
bundlePrefs
.
getString
(
"
notificationspermissionstitle2
"
)
bundlePrefs
.
getString
(
"
notificationspermissionstext6
"
)
bundlePrefs
.
getString
(
"
notificationspermissionsdisablelabel
"
)
bundlePrefs
.
getString
(
"
notificationspermissionsdisabledescription
"
)
]
)
;
appendSearchKeywords
(
"
locationSettingsButton
"
[
bundlePrefs
.
getString
(
"
locationpermissionstitle
"
)
bundlePrefs
.
getString
(
"
locationpermissionstext2
"
)
bundlePrefs
.
getString
(
"
locationpermissionsdisablelabel
"
)
bundlePrefs
.
getString
(
"
locationpermissionsdisabledescription
"
)
]
)
;
appendSearchKeywords
(
"
cameraSettingsButton
"
[
bundlePrefs
.
getString
(
"
camerapermissionstitle
"
)
bundlePrefs
.
getString
(
"
camerapermissionstext2
"
)
bundlePrefs
.
getString
(
"
camerapermissionsdisablelabel
"
)
bundlePrefs
.
getString
(
"
camerapermissionsdisabledescription
"
)
]
)
;
appendSearchKeywords
(
"
microphoneSettingsButton
"
[
bundlePrefs
.
getString
(
"
microphonepermissionstitle
"
)
bundlePrefs
.
getString
(
"
microphonepermissionstext2
"
)
bundlePrefs
.
getString
(
"
microphonepermissionsdisablelabel
"
)
bundlePrefs
.
getString
(
"
microphonepermissionsdisabledescription
"
)
]
)
;
appendSearchKeywords
(
"
addonExceptions
"
[
bundlePrefs
.
getString
(
"
addons_permissions_title2
"
)
bundlePrefs
.
getString
(
"
addonspermissionstext
"
)
]
)
;
appendSearchKeywords
(
"
viewSecurityDevicesButton
"
[
pkiBundle
.
getString
(
"
enable_fips
"
)
]
)
;
appendSearchKeywords
(
"
siteDataSettings
"
[
bundlePrefs
.
getString
(
"
siteDataSettings2
.
description
"
)
bundlePrefs
.
getString
(
"
removeAllCookies
.
label
"
)
bundlePrefs
.
getString
(
"
removeSelectedCookies
.
label
"
)
]
)
;
Services
.
obs
.
notifyObservers
(
window
"
privacy
-
pane
-
loaded
"
)
;
}
trackingProtectionReadPrefs
(
)
{
let
enabledPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
enabled
"
)
;
let
pbmPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
;
let
radiogroup
=
document
.
getElementById
(
"
trackingProtectionRadioGroup
"
)
;
this
.
_updateTrackingProtectionUI
(
)
;
if
(
enabledPref
.
value
)
{
radiogroup
.
value
=
"
always
"
;
}
else
if
(
pbmPref
.
value
)
{
radiogroup
.
value
=
"
private
"
;
}
else
{
radiogroup
.
value
=
"
never
"
;
}
}
trackingProtectionWritePrefs
(
)
{
let
enabledPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
enabled
"
)
;
let
pbmPref
=
Preferences
.
get
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
;
let
radiogroup
=
document
.
getElementById
(
"
trackingProtectionRadioGroup
"
)
;
switch
(
radiogroup
.
value
)
{
case
"
always
"
:
enabledPref
.
value
=
true
;
pbmPref
.
value
=
true
;
break
;
case
"
private
"
:
enabledPref
.
value
=
false
;
pbmPref
.
value
=
true
;
break
;
case
"
never
"
:
enabledPref
.
value
=
false
;
pbmPref
.
value
=
false
;
break
;
}
}
prefsForKeepingHistory
:
{
"
places
.
history
.
enabled
"
:
true
"
browser
.
formfill
.
enable
"
:
true
"
network
.
cookie
.
cookieBehavior
"
:
0
"
network
.
cookie
.
lifetimePolicy
"
:
0
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
:
false
}
dependentControls
:
[
"
rememberHistory
"
"
rememberForms
"
"
keepUntil
"
"
keepCookiesUntil
"
"
alwaysClear
"
"
clearDataSettings
"
]
_checkHistoryValues
(
aPrefs
)
{
for
(
let
pref
of
Object
.
keys
(
aPrefs
)
)
{
if
(
Preferences
.
get
(
pref
)
.
value
!
=
aPrefs
[
pref
]
)
return
false
;
}
return
true
;
}
initializeHistoryMode
(
)
{
let
mode
;
let
getVal
=
aPref
=
>
Preferences
.
get
(
aPref
)
.
value
;
if
(
getVal
(
"
privacy
.
history
.
custom
"
)
)
mode
=
"
custom
"
;
else
if
(
this
.
_checkHistoryValues
(
this
.
prefsForKeepingHistory
)
)
{
if
(
getVal
(
"
browser
.
privatebrowsing
.
autostart
"
)
)
mode
=
"
dontremember
"
;
else
mode
=
"
remember
"
;
}
else
mode
=
"
custom
"
;
document
.
getElementById
(
"
historyMode
"
)
.
value
=
mode
;
}
updateHistoryModePane
(
)
{
let
selectedIndex
=
-
1
;
switch
(
document
.
getElementById
(
"
historyMode
"
)
.
value
)
{
case
"
remember
"
:
selectedIndex
=
0
;
break
;
case
"
dontremember
"
:
selectedIndex
=
1
;
break
;
case
"
custom
"
:
selectedIndex
=
2
;
break
;
}
document
.
getElementById
(
"
historyPane
"
)
.
selectedIndex
=
selectedIndex
;
Preferences
.
get
(
"
privacy
.
history
.
custom
"
)
.
value
=
selectedIndex
=
=
2
;
}
updateHistoryModePrefs
(
)
{
let
pref
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
switch
(
document
.
getElementById
(
"
historyMode
"
)
.
value
)
{
case
"
remember
"
:
if
(
pref
.
value
)
pref
.
value
=
false
;
Preferences
.
get
(
"
places
.
history
.
enabled
"
)
.
value
=
true
;
Preferences
.
get
(
"
browser
.
formfill
.
enable
"
)
.
value
=
true
;
Preferences
.
get
(
"
network
.
cookie
.
cookieBehavior
"
)
.
value
=
0
;
Preferences
.
get
(
"
network
.
cookie
.
lifetimePolicy
"
)
.
value
=
0
;
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
=
false
;
break
;
case
"
dontremember
"
:
if
(
!
pref
.
value
)
pref
.
value
=
true
;
break
;
}
}
updatePrivacyMicroControls
(
)
{
if
(
document
.
getElementById
(
"
historyMode
"
)
.
value
=
=
"
custom
"
)
{
let
disabled
=
this
.
_autoStartPrivateBrowsing
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
value
;
this
.
dependentControls
.
forEach
(
function
(
aElement
)
{
let
control
=
document
.
getElementById
(
aElement
)
;
let
preferenceId
=
control
.
getAttribute
(
"
preference
"
)
;
if
(
!
preferenceId
)
{
let
dependentControlId
=
control
.
getAttribute
(
"
control
"
)
;
if
(
dependentControlId
)
{
let
dependentControl
=
document
.
getElementById
(
dependentControlId
)
;
preferenceId
=
dependentControl
.
getAttribute
(
"
preference
"
)
;
}
}
let
preference
=
preferenceId
?
Preferences
.
get
(
preferenceId
)
:
{
}
;
control
.
disabled
=
disabled
|
|
preference
.
locked
;
}
)
;
this
.
readAcceptCookies
(
)
;
let
lifetimePolicy
=
Preferences
.
get
(
"
network
.
cookie
.
lifetimePolicy
"
)
.
value
;
if
(
lifetimePolicy
!
=
Ci
.
nsICookieService
.
ACCEPT_NORMALLY
&
&
lifetimePolicy
!
=
Ci
.
nsICookieService
.
ACCEPT_SESSION
&
&
lifetimePolicy
!
=
Ci
.
nsICookieService
.
ACCEPT_FOR_N_DAYS
)
{
lifetimePolicy
=
Ci
.
nsICookieService
.
ACCEPT_NORMALLY
;
}
document
.
getElementById
(
"
keepCookiesUntil
"
)
.
value
=
disabled
?
2
:
lifetimePolicy
;
document
.
getElementById
(
"
alwaysClear
"
)
.
checked
=
disabled
?
false
:
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
.
value
;
document
.
getElementById
(
"
rememberHistory
"
)
.
checked
=
disabled
?
false
:
Preferences
.
get
(
"
places
.
history
.
enabled
"
)
.
value
;
document
.
getElementById
(
"
rememberForms
"
)
.
checked
=
disabled
?
false
:
Preferences
.
get
(
"
browser
.
formfill
.
enable
"
)
.
value
;
if
(
!
disabled
)
{
this
.
_updateSanitizeSettingsButton
(
)
;
}
}
}
initAutoStartPrivateBrowsingReverter
(
)
{
let
mode
=
document
.
getElementById
(
"
historyMode
"
)
;
let
autoStart
=
document
.
getElementById
(
"
privateBrowsingAutoStart
"
)
;
this
.
_lastMode
=
mode
.
selectedIndex
;
this
.
_lastCheckState
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
}
_lastMode
:
null
_lastCheckState
:
null
updateAutostart
(
)
{
let
mode
=
document
.
getElementById
(
"
historyMode
"
)
;
let
autoStart
=
document
.
getElementById
(
"
privateBrowsingAutoStart
"
)
;
let
pref
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
if
(
(
mode
.
value
=
=
"
custom
"
&
&
this
.
_lastCheckState
=
=
autoStart
.
checked
)
|
|
(
mode
.
value
=
=
"
remember
"
&
&
!
this
.
_lastCheckState
)
|
|
(
mode
.
value
=
=
"
dontremember
"
&
&
this
.
_lastCheckState
)
)
{
this
.
_lastMode
=
mode
.
selectedIndex
;
this
.
_lastCheckState
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
return
;
}
if
(
!
this
.
_shouldPromptForRestart
)
{
return
;
}
let
buttonIndex
=
confirmRestartPrompt
(
autoStart
.
checked
1
true
false
)
;
if
(
buttonIndex
=
=
CONFIRM_RESTART_PROMPT_RESTART_NOW
)
{
pref
.
value
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
return
;
}
this
.
_shouldPromptForRestart
=
false
;
if
(
this
.
_lastCheckState
)
{
autoStart
.
checked
=
"
checked
"
;
}
else
{
autoStart
.
removeAttribute
(
"
checked
"
)
;
}
pref
.
value
=
autoStart
.
hasAttribute
(
"
checked
"
)
;
mode
.
selectedIndex
=
this
.
_lastMode
;
mode
.
doCommand
(
)
;
this
.
_shouldPromptForRestart
=
true
;
}
showTrackingProtectionExceptions
(
)
{
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
params
=
{
permissionType
:
"
trackingprotection
"
hideStatusColumn
:
true
windowTitle
:
bundlePreferences
.
getString
(
"
trackingprotectionpermissionstitle
"
)
introText
:
bundlePreferences
.
getString
(
"
trackingprotectionpermissionstext2
"
)
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
null
params
)
;
}
showBlockLists
(
)
{
var
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
brandName
=
document
.
getElementById
(
"
bundleBrand
"
)
.
getString
(
"
brandShortName
"
)
;
var
params
=
{
brandShortName
:
brandName
windowTitle
:
bundlePreferences
.
getString
(
"
blockliststitle
"
)
introText
:
bundlePreferences
.
getString
(
"
blockliststext
"
)
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
blocklists
.
xul
"
null
params
)
;
}
readAcceptCookies
(
)
{
var
pref
=
Preferences
.
get
(
"
network
.
cookie
.
cookieBehavior
"
)
;
var
acceptThirdPartyLabel
=
document
.
getElementById
(
"
acceptThirdPartyLabel
"
)
;
var
acceptThirdPartyMenu
=
document
.
getElementById
(
"
acceptThirdPartyMenu
"
)
;
var
keepUntil
=
document
.
getElementById
(
"
keepUntil
"
)
;
var
menu
=
document
.
getElementById
(
"
keepCookiesUntil
"
)
;
var
acceptCookies
=
(
pref
.
value
!
=
2
)
;
acceptThirdPartyLabel
.
disabled
=
acceptThirdPartyMenu
.
disabled
=
!
acceptCookies
;
keepUntil
.
disabled
=
menu
.
disabled
=
this
.
_autoStartPrivateBrowsing
|
|
!
acceptCookies
;
return
acceptCookies
;
}
writeAcceptCookies
(
)
{
var
accept
=
document
.
getElementById
(
"
acceptCookies
"
)
;
var
acceptThirdPartyMenu
=
document
.
getElementById
(
"
acceptThirdPartyMenu
"
)
;
if
(
accept
.
checked
)
acceptThirdPartyMenu
.
selectedIndex
=
0
;
return
accept
.
checked
?
0
:
2
;
}
readAcceptThirdPartyCookies
(
)
{
var
pref
=
Preferences
.
get
(
"
network
.
cookie
.
cookieBehavior
"
)
;
switch
(
pref
.
value
)
{
case
0
:
return
"
always
"
;
case
1
:
return
"
never
"
;
case
2
:
return
"
never
"
;
case
3
:
return
"
visited
"
;
default
:
return
undefined
;
}
}
writeAcceptThirdPartyCookies
(
)
{
var
accept
=
document
.
getElementById
(
"
acceptThirdPartyMenu
"
)
.
selectedItem
;
switch
(
accept
.
value
)
{
case
"
always
"
:
return
0
;
case
"
visited
"
:
return
3
;
case
"
never
"
:
return
1
;
default
:
return
undefined
;
}
}
showCookieExceptions
(
)
{
var
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
params
=
{
blockVisible
:
true
sessionVisible
:
true
allowVisible
:
true
prefilledHost
:
"
"
permissionType
:
"
cookie
"
windowTitle
:
bundlePreferences
.
getString
(
"
cookiepermissionstitle
"
)
introText
:
bundlePreferences
.
getString
(
"
cookiepermissionstext
"
)
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
null
params
)
;
}
showCookies
(
aCategory
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
cookies
.
xul
"
)
;
}
showClearPrivateDataSettings
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
sanitize
.
xul
"
"
resizable
=
no
"
)
;
}
clearPrivateDataNow
(
aClearEverything
)
{
var
ts
=
Preferences
.
get
(
"
privacy
.
sanitize
.
timeSpan
"
)
;
var
timeSpanOrig
=
ts
.
value
;
if
(
aClearEverything
)
{
ts
.
value
=
0
;
}
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
sanitize
.
xul
"
"
resizable
=
no
"
null
(
)
=
>
{
if
(
aClearEverything
)
{
ts
.
value
=
timeSpanOrig
;
}
Services
.
obs
.
notifyObservers
(
null
"
clear
-
private
-
data
"
)
;
}
)
;
}
_updateSanitizeSettingsButton
(
)
{
var
settingsButton
=
document
.
getElementById
(
"
clearDataSettings
"
)
;
var
sanitizeOnShutdownPref
=
Preferences
.
get
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
;
settingsButton
.
disabled
=
!
sanitizeOnShutdownPref
.
value
;
}
toggleDoNotDisturbNotifications
(
event
)
{
AlertsServiceDND
.
manualDoNotDisturb
=
event
.
target
.
checked
;
}
showLocationExceptions
(
)
{
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
params
=
{
permissionType
:
"
geo
"
}
;
params
.
windowTitle
=
bundlePreferences
.
getString
(
"
locationpermissionstitle
"
)
;
params
.
introText
=
bundlePreferences
.
getString
(
"
locationpermissionstext2
"
)
;
params
.
disablePermissionsLabel
=
bundlePreferences
.
getString
(
"
locationpermissionsdisablelabel
"
)
;
params
.
disablePermissionsDescription
=
bundlePreferences
.
getString
(
"
locationpermissionsdisabledescription
"
)
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
sitePermissions
.
xul
"
"
resizable
=
yes
"
params
)
;
}
showCameraExceptions
(
)
{
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
params
=
{
permissionType
:
"
camera
"
}
;
params
.
windowTitle
=
bundlePreferences
.
getString
(
"
camerapermissionstitle
"
)
;
params
.
introText
=
bundlePreferences
.
getString
(
"
camerapermissionstext2
"
)
;
params
.
disablePermissionsLabel
=
bundlePreferences
.
getString
(
"
camerapermissionsdisablelabel
"
)
;
params
.
disablePermissionsDescription
=
bundlePreferences
.
getString
(
"
camerapermissionsdisabledescription
"
)
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
sitePermissions
.
xul
"
"
resizable
=
yes
"
params
)
;
}
showMicrophoneExceptions
(
)
{
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
params
=
{
permissionType
:
"
microphone
"
}
;
params
.
windowTitle
=
bundlePreferences
.
getString
(
"
microphonepermissionstitle
"
)
;
params
.
introText
=
bundlePreferences
.
getString
(
"
microphonepermissionstext2
"
)
;
params
.
disablePermissionsLabel
=
bundlePreferences
.
getString
(
"
microphonepermissionsdisablelabel
"
)
;
params
.
disablePermissionsDescription
=
bundlePreferences
.
getString
(
"
microphonepermissionsdisabledescription
"
)
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
sitePermissions
.
xul
"
"
resizable
=
yes
"
params
)
;
}
showNotificationExceptions
(
)
{
let
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
params
=
{
permissionType
:
"
desktop
-
notification
"
}
;
params
.
windowTitle
=
bundlePreferences
.
getString
(
"
notificationspermissionstitle2
"
)
;
params
.
introText
=
bundlePreferences
.
getString
(
"
notificationspermissionstext6
"
)
;
params
.
disablePermissionsLabel
=
bundlePreferences
.
getString
(
"
notificationspermissionsdisablelabel
"
)
;
params
.
disablePermissionsDescription
=
bundlePreferences
.
getString
(
"
notificationspermissionsdisabledescription
"
)
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
sitePermissions
.
xul
"
"
resizable
=
yes
"
params
)
;
try
{
Services
.
telemetry
.
getHistogramById
(
"
WEB_NOTIFICATION_EXCEPTIONS_OPENED
"
)
.
add
(
)
;
}
catch
(
e
)
{
}
}
showPopupExceptions
(
)
{
var
bundlePreferences
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
params
=
{
blockVisible
:
false
sessionVisible
:
false
allowVisible
:
true
prefilledHost
:
"
"
permissionType
:
"
popup
"
}
;
params
.
windowTitle
=
bundlePreferences
.
getString
(
"
popuppermissionstitle2
"
)
;
params
.
introText
=
bundlePreferences
.
getString
(
"
popuppermissionstext
"
)
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
"
resizable
=
yes
"
params
)
;
}
updateButtons
(
aButtonID
aPreferenceID
)
{
var
button
=
document
.
getElementById
(
aButtonID
)
;
var
preference
=
Preferences
.
get
(
aPreferenceID
)
;
button
.
disabled
=
preference
.
value
!
=
true
;
return
undefined
;
}
showPasswordExceptions
(
)
{
var
bundlePrefs
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
params
=
{
blockVisible
:
true
sessionVisible
:
false
allowVisible
:
false
hideStatusColumn
:
true
prefilledHost
:
"
"
permissionType
:
"
login
-
saving
"
windowTitle
:
bundlePrefs
.
getString
(
"
savedLoginsExceptions_title
"
)
introText
:
bundlePrefs
.
getString
(
"
savedLoginsExceptions_desc3
"
)
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
null
params
)
;
}
_initMasterPasswordUI
(
)
{
var
noMP
=
!
LoginHelper
.
isMasterPasswordSet
(
)
;
var
button
=
document
.
getElementById
(
"
changeMasterPassword
"
)
;
button
.
disabled
=
noMP
;
var
checkbox
=
document
.
getElementById
(
"
useMasterPassword
"
)
;
checkbox
.
checked
=
!
noMP
;
}
updateMasterPasswordButton
(
)
{
var
checkbox
=
document
.
getElementById
(
"
useMasterPassword
"
)
;
var
button
=
document
.
getElementById
(
"
changeMasterPassword
"
)
;
button
.
disabled
=
!
checkbox
.
checked
;
if
(
!
checkbox
.
checked
)
this
.
_removeMasterPassword
(
)
;
else
this
.
changeMasterPassword
(
)
;
this
.
_initMasterPasswordUI
(
)
;
}
_removeMasterPassword
(
)
{
var
secmodDB
=
Cc
[
"
mozilla
.
org
/
security
/
pkcs11moduledb
;
1
"
]
.
getService
(
Ci
.
nsIPKCS11ModuleDB
)
;
if
(
secmodDB
.
isFIPSEnabled
)
{
var
bundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
Services
.
prompt
.
alert
(
window
bundle
.
getString
(
"
pw_change_failed_title
"
)
bundle
.
getString
(
"
pw_change2empty_in_fips_mode
"
)
)
;
this
.
_initMasterPasswordUI
(
)
;
}
else
{
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
preferences
/
removemp
.
xul
"
null
null
this
.
_initMasterPasswordUI
.
bind
(
this
)
)
;
}
}
changeMasterPassword
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
preferences
/
changemp
.
xul
"
"
resizable
=
no
"
null
this
.
_initMasterPasswordUI
.
bind
(
this
)
)
;
}
showPasswords
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
passwordmgr
/
content
/
passwordManager
.
xul
"
)
;
}
readSavePasswords
(
)
{
var
pref
=
Preferences
.
get
(
"
signon
.
rememberSignons
"
)
;
var
excepts
=
document
.
getElementById
(
"
passwordExceptions
"
)
;
if
(
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
document
.
getElementById
(
"
savePasswords
"
)
.
disabled
=
true
;
excepts
.
disabled
=
true
;
return
false
;
}
excepts
.
disabled
=
!
pref
.
value
;
return
undefined
;
}
readWarnAddonInstall
(
)
{
var
warn
=
Preferences
.
get
(
"
xpinstall
.
whitelist
.
required
"
)
;
var
exceptions
=
document
.
getElementById
(
"
addonExceptions
"
)
;
exceptions
.
disabled
=
!
warn
.
value
;
return
undefined
;
}
_initSafeBrowsing
(
)
{
let
enableSafeBrowsing
=
document
.
getElementById
(
"
enableSafeBrowsing
"
)
;
let
blockDownloads
=
document
.
getElementById
(
"
blockDownloads
"
)
;
let
blockUncommonUnwanted
=
document
.
getElementById
(
"
blockUncommonUnwanted
"
)
;
let
safeBrowsingPhishingPref
=
Preferences
.
get
(
"
browser
.
safebrowsing
.
phishing
.
enabled
"
)
;
let
safeBrowsingMalwarePref
=
Preferences
.
get
(
"
browser
.
safebrowsing
.
malware
.
enabled
"
)
;
let
blockDownloadsPref
=
Preferences
.
get
(
"
browser
.
safebrowsing
.
downloads
.
enabled
"
)
;
let
malwareTable
=
Preferences
.
get
(
"
urlclassifier
.
malwareTable
"
)
;
let
blockUnwantedPref
=
Preferences
.
get
(
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_potentially_unwanted
"
)
;
let
blockUncommonPref
=
Preferences
.
get
(
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_uncommon
"
)
;
let
learnMoreLink
=
document
.
getElementById
(
"
enableSafeBrowsingLearnMore
"
)
;
let
phishingUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
"
phishing
-
malware
"
;
learnMoreLink
.
setAttribute
(
"
href
"
phishingUrl
)
;
enableSafeBrowsing
.
addEventListener
(
"
command
"
function
(
)
{
safeBrowsingPhishingPref
.
value
=
enableSafeBrowsing
.
checked
;
safeBrowsingMalwarePref
.
value
=
enableSafeBrowsing
.
checked
;
if
(
enableSafeBrowsing
.
checked
)
{
if
(
blockDownloads
)
{
blockDownloads
.
removeAttribute
(
"
disabled
"
)
;
if
(
blockDownloads
.
checked
)
{
blockUncommonUnwanted
.
removeAttribute
(
"
disabled
"
)
;
}
}
else
{
blockUncommonUnwanted
.
removeAttribute
(
"
disabled
"
)
;
}
}
else
{
if
(
blockDownloads
)
{
blockDownloads
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
blockUncommonUnwanted
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
)
;
if
(
blockDownloads
)
{
blockDownloads
.
addEventListener
(
"
command
"
function
(
)
{
blockDownloadsPref
.
value
=
blockDownloads
.
checked
;
if
(
blockDownloads
.
checked
)
{
blockUncommonUnwanted
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
blockUncommonUnwanted
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
)
;
}
blockUncommonUnwanted
.
addEventListener
(
"
command
"
function
(
)
{
blockUnwantedPref
.
value
=
blockUncommonUnwanted
.
checked
;
blockUncommonPref
.
value
=
blockUncommonUnwanted
.
checked
;
let
malware
=
malwareTable
.
value
.
split
(
"
"
)
.
filter
(
x
=
>
x
!
=
=
"
goog
-
unwanted
-
proto
"
&
&
x
!
=
=
"
goog
-
unwanted
-
shavar
"
&
&
x
!
=
=
"
test
-
unwanted
-
simple
"
)
;
if
(
blockUncommonUnwanted
.
checked
)
{
if
(
malware
.
includes
(
"
goog
-
malware
-
shavar
"
)
)
{
malware
.
push
(
"
goog
-
unwanted
-
shavar
"
)
;
}
else
{
malware
.
push
(
"
goog
-
unwanted
-
proto
"
)
;
}
malware
.
push
(
"
test
-
unwanted
-
simple
"
)
;
}
malware
.
sort
(
)
;
malwareTable
.
value
=
malware
.
join
(
"
"
)
;
let
listmanager
=
Components
.
classes
[
"
mozilla
.
org
/
url
-
classifier
/
listmanager
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIUrlListManager
)
;
if
(
listmanager
)
{
listmanager
.
forceUpdates
(
malwareTable
.
value
)
;
}
}
)
;
enableSafeBrowsing
.
checked
=
safeBrowsingPhishingPref
.
value
&
&
safeBrowsingMalwarePref
.
value
;
if
(
!
enableSafeBrowsing
.
checked
)
{
if
(
blockDownloads
)
{
blockDownloads
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
blockUncommonUnwanted
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
blockDownloads
)
{
blockDownloads
.
checked
=
blockDownloadsPref
.
value
;
if
(
!
blockDownloadsPref
.
value
)
{
blockUncommonUnwanted
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
blockUncommonUnwanted
.
checked
=
blockUnwantedPref
.
value
&
&
blockUncommonPref
.
value
;
}
showAddonExceptions
(
)
{
var
bundlePrefs
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
var
params
=
this
.
_addonParams
;
if
(
!
params
.
windowTitle
|
|
!
params
.
introText
)
{
params
.
windowTitle
=
bundlePrefs
.
getString
(
"
addons_permissions_title2
"
)
;
params
.
introText
=
bundlePrefs
.
getString
(
"
addonspermissionstext
"
)
;
}
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
permissions
.
xul
"
null
params
)
;
}
_addonParams
:
{
blockVisible
:
false
sessionVisible
:
false
allowVisible
:
true
prefilledHost
:
"
"
permissionType
:
"
install
"
}
readEnableOCSP
(
)
{
var
preference
=
Preferences
.
get
(
"
security
.
OCSP
.
enabled
"
)
;
if
(
preference
.
value
=
=
=
undefined
)
{
return
true
;
}
return
preference
.
value
!
=
0
;
}
writeEnableOCSP
(
)
{
var
checkbox
=
document
.
getElementById
(
"
enableOCSP
"
)
;
var
defaults
=
Services
.
prefs
.
getDefaultBranch
(
null
)
;
var
defaultValue
=
defaults
.
getIntPref
(
"
security
.
OCSP
.
enabled
"
)
;
return
checkbox
.
checked
?
defaultValue
:
0
;
}
showCertificates
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
pippki
/
content
/
certManager
.
xul
"
)
;
}
showSecurityDevices
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
pippki
/
content
/
device_manager
.
xul
"
)
;
}
clearCache
(
)
{
try
{
Services
.
cache2
.
clear
(
)
;
}
catch
(
ex
)
{
}
this
.
updateActualCacheSize
(
)
;
}
showSiteDataSettings
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
siteDataSettings
.
xul
"
)
;
}
toggleSiteData
(
shouldShow
)
{
let
clearButton
=
document
.
getElementById
(
"
clearSiteDataButton
"
)
;
let
settingsButton
=
document
.
getElementById
(
"
siteDataSettings
"
)
;
clearButton
.
disabled
=
!
shouldShow
;
settingsButton
.
disabled
=
!
shouldShow
;
}
updateTotalDataSizeLabel
(
usage
)
{
let
prefStrBundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
let
totalSiteDataSizeLabel
=
document
.
getElementById
(
"
totalSiteDataSize
"
)
;
if
(
usage
<
0
)
{
totalSiteDataSizeLabel
.
textContent
=
prefStrBundle
.
getString
(
"
loadingSiteDataSize
"
)
;
}
else
{
let
size
=
DownloadUtils
.
convertByteUnits
(
usage
)
;
totalSiteDataSizeLabel
.
textContent
=
prefStrBundle
.
getFormattedString
(
"
totalSiteDataSize
"
size
)
;
}
}
updateActualCacheSize
(
)
{
var
actualSizeLabel
=
document
.
getElementById
(
"
actualDiskCacheSize
"
)
;
var
prefStrBundle
=
document
.
getElementById
(
"
bundlePreferences
"
)
;
this
.
observer
=
{
onNetworkCacheDiskConsumption
(
consumption
)
{
var
size
=
DownloadUtils
.
convertByteUnits
(
consumption
)
;
if
(
!
prefStrBundle
.
getFormattedString
)
{
return
;
}
actualSizeLabel
.
textContent
=
prefStrBundle
.
getFormattedString
(
"
actualDiskCacheSize
"
size
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Components
.
interfaces
.
nsICacheStorageConsumptionObserver
Components
.
interfaces
.
nsISupportsWeakReference
]
)
}
;
actualSizeLabel
.
textContent
=
prefStrBundle
.
getString
(
"
actualDiskCacheSizeCalculated
"
)
;
try
{
Services
.
cache2
.
asyncGetDiskConsumption
(
this
.
observer
)
;
}
catch
(
e
)
{
}
}
updateCacheSizeUI
(
smartSizeEnabled
)
{
document
.
getElementById
(
"
useCacheBefore
"
)
.
disabled
=
smartSizeEnabled
;
document
.
getElementById
(
"
cacheSize
"
)
.
disabled
=
smartSizeEnabled
;
document
.
getElementById
(
"
useCacheAfter
"
)
.
disabled
=
smartSizeEnabled
;
}
readSmartSizeEnabled
(
)
{
var
disabled
=
Preferences
.
get
(
"
browser
.
cache
.
disk
.
smart_size
.
enabled
"
)
.
value
;
this
.
updateCacheSizeUI
(
!
disabled
)
;
}
updateCacheSizeInputField
(
)
{
let
cacheSizeElem
=
document
.
getElementById
(
"
cacheSize
"
)
;
let
cachePref
=
Preferences
.
get
(
"
browser
.
cache
.
disk
.
capacity
"
)
;
cacheSizeElem
.
value
=
cachePref
.
value
/
1024
;
if
(
cachePref
.
locked
)
cacheSizeElem
.
disabled
=
true
;
}
updateCacheSizePref
(
)
{
let
cacheSizeElem
=
document
.
getElementById
(
"
cacheSize
"
)
;
let
cachePref
=
Preferences
.
get
(
"
browser
.
cache
.
disk
.
capacity
"
)
;
let
intValue
=
parseInt
(
cacheSizeElem
.
value
10
)
;
cachePref
.
value
=
isNaN
(
intValue
)
?
0
:
intValue
*
1024
;
}
clearSiteData
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
clearSiteData
.
xul
"
)
;
}
initDataCollection
(
)
{
this
.
_setupLearnMoreLink
(
"
toolkit
.
datacollection
.
infoURL
"
"
dataCollectionPrivacyNotice
"
)
;
}
initCollectBrowserErrors
(
)
{
this
.
_setupLearnMoreLink
(
"
browser
.
chrome
.
errorReporter
.
infoURL
"
"
collectBrowserErrorsLearnMore
"
)
;
}
initSubmitCrashes
(
)
{
this
.
_setupLearnMoreLink
(
"
toolkit
.
crashreporter
.
infoURL
"
"
crashReporterLearnMore
"
)
;
}
_setupLearnMoreLink
(
pref
element
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
pref
)
;
let
el
=
document
.
getElementById
(
element
)
;
if
(
url
)
{
el
.
setAttribute
(
"
href
"
url
)
;
}
else
{
el
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
initSubmitHealthReport
(
)
{
this
.
_setupLearnMoreLink
(
"
datareporting
.
healthreport
.
infoURL
"
"
FHRLearnMore
"
)
;
let
checkbox
=
document
.
getElementById
(
"
submitHealthReportBox
"
)
;
if
(
Services
.
prefs
.
prefIsLocked
(
PREF_UPLOAD_ENABLED
)
|
|
!
AppConstants
.
MOZ_TELEMETRY_REPORTING
)
{
checkbox
.
setAttribute
(
"
disabled
"
"
true
"
)
;
return
;
}
checkbox
.
checked
=
Services
.
prefs
.
getBoolPref
(
PREF_UPLOAD_ENABLED
)
&
&
AppConstants
.
MOZ_TELEMETRY_REPORTING
;
}
updateSubmitHealthReport
(
)
{
let
checkbox
=
document
.
getElementById
(
"
submitHealthReportBox
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_UPLOAD_ENABLED
checkbox
.
checked
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
sitedatamanager
:
updating
-
sites
"
:
this
.
toggleSiteData
(
false
)
;
this
.
updateTotalDataSizeLabel
(
-
1
)
;
break
;
case
"
sitedatamanager
:
sites
-
updated
"
:
this
.
toggleSiteData
(
true
)
;
SiteDataManager
.
getTotalUsage
(
)
.
then
(
this
.
updateTotalDataSizeLabel
.
bind
(
this
)
)
;
break
;
}
}
_initA11yState
(
)
{
this
.
_initA11yString
(
)
;
let
checkbox
=
document
.
getElementById
(
"
a11yPrivacyCheckbox
"
)
;
switch
(
Services
.
prefs
.
getIntPref
(
"
accessibility
.
force_disabled
"
)
)
{
case
1
:
checkbox
.
checked
=
true
;
break
;
case
-
1
:
case
0
:
checkbox
.
checked
=
false
;
break
;
}
}
_initA11yString
(
)
{
let
a11yLearnMoreLink
=
Services
.
urlFormatter
.
formatURLPref
(
"
accessibility
.
support
.
url
"
)
;
document
.
getElementById
(
"
a11yLearnMoreLink
"
)
.
setAttribute
(
"
href
"
a11yLearnMoreLink
)
;
}
updateA11yPrefs
(
checked
)
{
let
buttonIndex
=
confirmRestartPrompt
(
checked
0
true
false
)
;
if
(
buttonIndex
=
=
CONFIRM_RESTART_PROMPT_RESTART_NOW
)
{
Services
.
prefs
.
setIntPref
(
"
accessibility
.
force_disabled
"
checked
?
1
:
0
)
;
Services
.
telemetry
.
scalarSet
(
"
preferences
.
prevent_accessibility_services
"
true
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
}
document
.
getElementById
(
"
a11yPrivacyCheckbox
"
)
.
checked
=
!
checked
;
}
}
;
