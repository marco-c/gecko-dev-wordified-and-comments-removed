"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OfflineAppCacheHelper
"
"
resource
:
/
/
/
modules
/
offlineAppCache
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContextualIdentityService
"
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
serviceWorkerManager
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
SiteDataManager
"
]
;
this
.
SiteDataManager
=
{
_qms
:
Services
.
qms
_appCache
:
Cc
[
"
mozilla
.
org
/
network
/
application
-
cache
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationCacheService
)
_sites
:
new
Map
(
)
_getQuotaUsagePromise
:
null
_quotaUsageRequest
:
null
async
updateSites
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
sitedatamanager
:
updating
-
sites
"
)
;
await
this
.
_getQuotaUsage
(
)
;
this
.
_updateAppCache
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
sitedatamanager
:
sites
-
updated
"
)
;
}
_getQuotaUsage
(
)
{
this
.
_sites
.
clear
(
)
;
this
.
_cancelGetQuotaUsage
(
)
;
this
.
_getQuotaUsagePromise
=
new
Promise
(
resolve
=
>
{
let
onUsageResult
=
request
=
>
{
if
(
request
.
resultCode
=
=
Cr
.
NS_OK
)
{
let
items
=
request
.
result
;
for
(
let
item
of
items
)
{
if
(
!
item
.
persisted
&
&
item
.
usage
<
=
0
)
{
continue
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
item
.
origin
)
;
let
uri
=
principal
.
URI
;
if
(
uri
.
scheme
=
=
"
http
"
|
|
uri
.
scheme
=
=
"
https
"
)
{
let
site
=
this
.
_sites
.
get
(
uri
.
host
)
;
if
(
!
site
)
{
site
=
{
persisted
:
false
quotaUsage
:
0
principals
:
[
]
appCacheList
:
[
]
}
;
}
if
(
item
.
persisted
)
{
site
.
persisted
=
true
;
}
site
.
principals
.
push
(
principal
)
;
site
.
quotaUsage
+
=
item
.
usage
;
this
.
_sites
.
set
(
uri
.
host
site
)
;
}
}
}
resolve
(
)
;
}
;
this
.
_quotaUsageRequest
=
this
.
_qms
.
getUsage
(
onUsageResult
)
;
}
)
;
return
this
.
_getQuotaUsagePromise
;
}
_cancelGetQuotaUsage
(
)
{
if
(
this
.
_quotaUsageRequest
)
{
this
.
_quotaUsageRequest
.
cancel
(
)
;
this
.
_quotaUsageRequest
=
null
;
}
}
_updateAppCache
(
)
{
let
groups
=
this
.
_appCache
.
getGroups
(
)
;
for
(
let
group
of
groups
)
{
let
cache
=
this
.
_appCache
.
getActiveCache
(
group
)
;
if
(
cache
.
usage
<
=
0
)
{
continue
;
}
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
group
)
;
let
uri
=
principal
.
URI
;
let
site
=
this
.
_sites
.
get
(
uri
.
host
)
;
if
(
!
site
)
{
site
=
{
persisted
:
false
quotaUsage
:
0
principals
:
[
principal
]
appCacheList
:
[
]
}
;
this
.
_sites
.
set
(
uri
.
host
site
)
;
}
else
if
(
!
site
.
principals
.
some
(
p
=
>
p
.
origin
=
=
principal
.
origin
)
)
{
site
.
principals
.
push
(
principal
)
;
}
site
.
appCacheList
.
push
(
cache
)
;
}
}
getTotalUsage
(
)
{
return
this
.
_getQuotaUsagePromise
.
then
(
(
)
=
>
{
let
usage
=
0
;
for
(
let
site
of
this
.
_sites
.
values
(
)
)
{
for
(
let
cache
of
site
.
appCacheList
)
{
usage
+
=
cache
.
usage
;
}
usage
+
=
site
.
quotaUsage
;
}
return
usage
;
}
)
;
}
getSites
(
)
{
return
this
.
_getQuotaUsagePromise
.
then
(
(
)
=
>
{
let
list
=
[
]
;
for
(
let
[
host
site
]
of
this
.
_sites
)
{
let
usage
=
site
.
quotaUsage
;
for
(
let
cache
of
site
.
appCacheList
)
{
usage
+
=
cache
.
usage
;
}
list
.
push
(
{
host
usage
persisted
:
site
.
persisted
}
)
;
}
return
list
;
}
)
;
}
_removePermission
(
site
)
{
let
removals
=
new
Set
(
)
;
for
(
let
principal
of
site
.
principals
)
{
let
{
originNoSuffix
}
=
principal
;
if
(
removals
.
has
(
originNoSuffix
)
)
{
continue
;
}
removals
.
add
(
originNoSuffix
)
;
Services
.
perms
.
removeFromPrincipal
(
principal
"
persistent
-
storage
"
)
;
}
}
_removeQuotaUsage
(
site
)
{
let
promises
=
[
]
;
let
removals
=
new
Set
(
)
;
for
(
let
principal
of
site
.
principals
)
{
let
{
originNoSuffix
}
=
principal
;
if
(
removals
.
has
(
originNoSuffix
)
)
{
continue
;
}
removals
.
add
(
originNoSuffix
)
;
promises
.
push
(
new
Promise
(
resolve
=
>
{
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
originNoSuffix
)
;
let
request
=
this
.
_qms
.
clearStoragesForPrincipal
(
principal
null
true
)
;
request
.
callback
=
resolve
;
}
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
_removeAppCache
(
site
)
{
for
(
let
cache
of
site
.
appCacheList
)
{
cache
.
discard
(
)
;
}
}
_removeCookie
(
site
)
{
for
(
let
principal
of
site
.
principals
)
{
let
e
=
Services
.
cookies
.
getCookiesFromHost
(
principal
.
URI
.
host
principal
.
originAttributes
)
;
while
(
e
.
hasMoreElements
(
)
)
{
let
cookie
=
e
.
getNext
(
)
;
if
(
cookie
instanceof
Components
.
interfaces
.
nsICookie
)
{
if
(
this
.
isPrivateCookie
(
cookie
)
)
{
continue
;
}
Services
.
cookies
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
false
cookie
.
originAttributes
)
;
}
}
Services
.
obs
.
notifyObservers
(
null
"
browser
:
purge
-
domain
-
data
"
principal
.
URI
.
host
)
;
}
}
_unregisterServiceWorker
(
serviceWorker
)
{
return
new
Promise
(
resolve
=
>
{
let
unregisterCallback
=
{
unregisterSucceeded
:
resolve
unregisterFailed
:
resolve
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIServiceWorkerUnregisterCallback
]
)
}
;
serviceWorkerManager
.
propagateUnregister
(
serviceWorker
.
principal
unregisterCallback
serviceWorker
.
scope
)
;
}
)
;
}
_removeServiceWorkersForSites
(
sites
)
{
let
promises
=
[
]
;
let
targetHosts
=
sites
.
map
(
s
=
>
s
.
principals
[
0
]
.
URI
.
host
)
;
let
serviceWorkers
=
serviceWorkerManager
.
getAllRegistrations
(
)
;
for
(
let
i
=
0
;
i
<
serviceWorkers
.
length
;
i
+
+
)
{
let
sw
=
serviceWorkers
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
if
(
targetHosts
.
includes
(
sw
.
principal
.
URI
.
host
)
)
{
promises
.
push
(
this
.
_unregisterServiceWorker
(
sw
)
)
;
}
}
return
Promise
.
all
(
promises
)
;
}
remove
(
hosts
)
{
let
unknownHost
=
"
"
;
let
targetSites
=
[
]
;
for
(
let
host
of
hosts
)
{
let
site
=
this
.
_sites
.
get
(
host
)
;
if
(
site
)
{
this
.
_removePermission
(
site
)
;
this
.
_removeAppCache
(
site
)
;
this
.
_removeCookie
(
site
)
;
targetSites
.
push
(
site
)
;
}
else
{
unknownHost
=
host
;
break
;
}
}
if
(
targetSites
.
length
>
0
)
{
this
.
_removeServiceWorkersForSites
(
targetSites
)
.
then
(
(
)
=
>
{
let
promises
=
targetSites
.
map
(
s
=
>
this
.
_removeQuotaUsage
(
s
)
)
;
return
Promise
.
all
(
promises
)
;
}
)
.
then
(
(
)
=
>
this
.
updateSites
(
)
)
;
}
if
(
unknownHost
)
{
throw
SiteDataManager
:
removing
unknown
site
of
{
unknownHost
}
;
}
}
async
removeAll
(
)
{
Services
.
cache2
.
clear
(
)
;
Services
.
cookies
.
removeAll
(
)
;
OfflineAppCacheHelper
.
clear
(
)
;
let
promises
=
[
]
;
let
serviceWorkers
=
serviceWorkerManager
.
getAllRegistrations
(
)
;
for
(
let
i
=
0
;
i
<
serviceWorkers
.
length
;
i
+
+
)
{
let
sw
=
serviceWorkers
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
promises
.
push
(
this
.
_unregisterServiceWorker
(
sw
)
)
;
}
await
Promise
.
all
(
promises
)
;
await
this
.
_getQuotaUsage
(
)
;
promises
=
[
]
;
for
(
let
site
of
this
.
_sites
.
values
(
)
)
{
this
.
_removePermission
(
site
)
;
promises
.
push
(
this
.
_removeQuotaUsage
(
site
)
)
;
}
return
Promise
.
all
(
promises
)
.
then
(
(
)
=
>
this
.
updateSites
(
)
)
;
}
isPrivateCookie
(
cookie
)
{
let
{
userContextId
}
=
cookie
.
originAttributes
;
return
userContextId
&
&
!
ContextualIdentityService
.
getPublicIdentityFromId
(
userContextId
)
;
}
}
;
