ChromeUtils
.
defineESModuleGetters
(
this
{
BackgroundUpdate
:
"
resource
:
/
/
gre
/
modules
/
BackgroundUpdate
.
sys
.
mjs
"
UpdateListener
:
"
resource
:
/
/
gre
/
modules
/
UpdateListener
.
sys
.
mjs
"
MigrationUtils
:
"
resource
:
/
/
/
modules
/
MigrationUtils
.
sys
.
mjs
"
TranslationsParent
:
"
resource
:
/
/
gre
/
actors
/
TranslationsParent
.
sys
.
mjs
"
WindowsLaunchOnLogin
:
"
resource
:
/
/
gre
/
modules
/
WindowsLaunchOnLogin
.
sys
.
mjs
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
}
)
;
const
TYPE_PDF
=
"
application
/
pdf
"
;
const
PREF_PDFJS_DISABLED
=
"
pdfjs
.
disabled
"
;
const
PREF_CONTAINERS_EXTENSION
=
"
privacy
.
userContext
.
extension
"
;
const
CONTAINERS_KEY
=
"
privacy
.
containers
"
;
const
PREF_USE_SYSTEM_COLORS
=
"
browser
.
display
.
use_system_colors
"
;
const
PREF_CONTENT_APPEARANCE
=
"
layout
.
css
.
prefers
-
color
-
scheme
.
content
-
override
"
;
const
FORCED_COLORS_QUERY
=
matchMedia
(
"
(
forced
-
colors
)
"
)
;
const
AUTO_UPDATE_CHANGED_TOPIC
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
"
app
.
update
.
auto
"
]
.
observerTopic
;
const
BACKGROUND_UPDATE_CHANGED_TOPIC
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
"
app
.
update
.
background
.
enabled
"
]
.
observerTopic
;
const
ICON_URL_APP
=
AppConstants
.
platform
=
=
"
linux
"
?
"
moz
-
icon
:
/
/
dummy
.
exe
?
size
=
16
"
:
"
chrome
:
/
/
browser
/
skin
/
preferences
/
application
.
png
"
;
const
APP_ICON_ATTR_NAME
=
"
appHandlerIcon
"
;
Preferences
.
addAll
(
[
{
id
:
"
browser
.
startup
.
page
"
type
:
"
int
"
}
{
id
:
"
browser
.
privatebrowsing
.
autostart
"
type
:
"
bool
"
}
{
id
:
"
browser
.
download
.
useDownloadDir
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
browser
.
download
.
always_ask_before_handling_new_types
"
type
:
"
bool
"
}
{
id
:
"
browser
.
download
.
folderList
"
type
:
"
int
"
}
{
id
:
"
browser
.
download
.
dir
"
type
:
"
file
"
}
{
id
:
"
browser
.
link
.
open_newwindow
"
type
:
"
int
"
}
{
id
:
"
browser
.
tabs
.
loadInBackground
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
browser
.
tabs
.
warnOnClose
"
type
:
"
bool
"
}
{
id
:
"
browser
.
warnOnQuitShortcut
"
type
:
"
bool
"
}
{
id
:
"
browser
.
tabs
.
warnOnOpen
"
type
:
"
bool
"
}
{
id
:
"
browser
.
ctrlTab
.
sortByRecentlyUsed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
tabs
.
hoverPreview
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
tabs
.
hoverPreview
.
showThumbnails
"
type
:
"
bool
"
}
{
id
:
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
addons
"
type
:
"
bool
"
}
{
id
:
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
features
"
type
:
"
bool
"
}
{
id
:
"
font
.
language
.
group
"
type
:
"
wstring
"
}
{
id
:
"
intl
.
regional_prefs
.
use_os_locales
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
browsewithcaret
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
typeaheadfind
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
blockautorefresh
"
type
:
"
bool
"
}
{
id
:
"
general
.
autoScroll
"
type
:
"
bool
"
}
{
id
:
"
general
.
smoothScroll
"
type
:
"
bool
"
}
{
id
:
"
widget
.
gtk
.
overlay
-
scrollbars
.
enabled
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
layout
.
css
.
always_underline_links
"
type
:
"
bool
"
}
{
id
:
"
layout
.
spellcheckDefault
"
type
:
"
int
"
}
{
id
:
"
accessibility
.
tabfocus
"
type
:
"
int
"
}
{
id
:
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
dom
.
ipc
.
processCount
"
type
:
"
int
"
}
{
id
:
"
dom
.
ipc
.
processCount
.
web
"
type
:
"
int
"
}
{
id
:
"
layers
.
acceleration
.
disabled
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
pref
.
downloads
.
disable_button
.
edit_actions
"
type
:
"
bool
"
}
{
id
:
"
media
.
eme
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
advanced
.
selectedTabIndex
"
type
:
"
int
"
}
{
id
:
"
browser
.
search
.
update
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
userContext
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
userContext
.
newTabContainerOnLeftClick
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
media
.
hardwaremediakeys
.
enabled
"
type
:
"
bool
"
}
]
)
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
Preferences
.
addAll
(
[
{
id
:
"
browser
.
shell
.
checkDefaultBrowser
"
type
:
"
bool
"
}
{
id
:
"
pref
.
general
.
disable_button
.
default_browser
"
type
:
"
bool
"
}
]
)
;
}
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
Preferences
.
addAll
(
[
{
id
:
"
browser
.
taskbar
.
previews
.
enable
"
type
:
"
bool
"
}
{
id
:
"
ui
.
osk
.
enabled
"
type
:
"
bool
"
}
]
)
;
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
Preferences
.
addAll
(
[
{
id
:
"
app
.
update
.
disable_button
.
showUpdateHistory
"
type
:
"
bool
"
}
]
)
;
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
Preferences
.
addAll
(
[
{
id
:
"
app
.
update
.
suppressPrompts
"
type
:
"
bool
"
}
]
)
;
}
}
ChromeUtils
.
defineLazyGetter
(
this
"
gIsPackagedApp
"
(
)
=
>
{
return
Services
.
sysinfo
.
getProperty
(
"
isPackagedApp
"
)
;
}
)
;
var
promiseLoadHandlersList
;
function
getBundleForLocales
(
newLocales
)
{
let
locales
=
Array
.
from
(
new
Set
(
[
.
.
.
newLocales
.
.
.
Services
.
locale
.
requestedLocales
Services
.
locale
.
lastFallbackLocale
]
)
)
;
return
new
Localization
(
[
"
browser
/
preferences
/
preferences
.
ftl
"
"
branding
/
brand
.
ftl
"
]
false
undefined
locales
)
;
}
var
gNodeToObjectMap
=
new
WeakMap
(
)
;
var
gMainPane
=
{
_handledTypes
:
{
}
_visibleTypes
:
[
]
STARTUP_PREF_BLANK
:
0
STARTUP_PREF_HOMEPAGE
:
1
STARTUP_PREF_RESTORE_SESSION
:
3
get
_list
(
)
{
delete
this
.
_list
;
return
(
this
.
_list
=
document
.
getElementById
(
"
handlersView
"
)
)
;
}
get
_filter
(
)
{
delete
this
.
_filter
;
return
(
this
.
_filter
=
document
.
getElementById
(
"
filter
"
)
)
;
}
_backoffIndex
:
0
init
(
)
{
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gMainPane
)
)
;
}
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
this
.
updateSetDefaultBrowser
(
)
;
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
backoffTimes
=
[
1000
1000
1000
1000
2000
2000
2000
5000
5000
10000
]
;
let
pollForDefaultBrowser
=
(
)
=
>
{
let
uri
=
win
.
gBrowser
.
currentURI
.
spec
;
if
(
(
uri
=
=
"
about
:
preferences
"
|
|
uri
=
=
"
about
:
preferences
#
general
"
|
|
uri
=
=
"
about
:
settings
"
|
|
uri
=
=
"
about
:
settings
#
general
"
)
&
&
document
.
visibilityState
=
=
"
visible
"
)
{
this
.
updateSetDefaultBrowser
(
)
;
}
window
.
setTimeout
(
(
)
=
>
{
window
.
requestIdleCallback
(
pollForDefaultBrowser
)
;
}
backoffTimes
[
this
.
_backoffIndex
+
1
<
backoffTimes
.
length
?
this
.
_backoffIndex
+
+
:
backoffTimes
.
length
-
1
]
)
;
}
;
window
.
setTimeout
(
(
)
=
>
{
window
.
requestIdleCallback
(
pollForDefaultBrowser
)
;
}
backoffTimes
[
this
.
_backoffIndex
]
)
;
}
this
.
initBrowserContainers
(
)
;
this
.
buildContentProcessCountMenuList
(
)
;
this
.
updateDefaultPerformanceSettingsPref
(
)
;
let
defaultPerformancePref
=
Preferences
.
get
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
defaultPerformancePref
.
on
(
"
change
"
(
)
=
>
{
this
.
updatePerformanceSettingsBox
(
{
duringChangeEvent
:
true
}
)
;
}
)
;
this
.
updatePerformanceSettingsBox
(
{
duringChangeEvent
:
false
}
)
;
this
.
displayUseSystemLocale
(
)
;
this
.
updateProxySettingsUI
(
)
;
initializeProxyUI
(
gMainPane
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
enabled
"
)
)
{
gMainPane
.
initPrimaryBrowserLanguageUI
(
)
;
}
gMainPane
.
initDefaultZoomValues
(
)
;
gMainPane
.
initTranslations
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
media
.
videocontrols
.
picture
-
in
-
picture
.
enabled
"
)
)
{
document
.
getElementById
(
"
pictureInPictureBox
"
)
.
hidden
=
false
;
setEventListener
(
"
pictureInPictureToggleEnabled
"
"
command
"
function
(
event
)
{
if
(
!
event
.
target
.
checked
)
{
Glean
.
pictureinpictureSettings
.
disableSettings
.
record
(
)
;
}
}
)
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
try
{
let
ver
=
parseFloat
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
)
;
let
showTabsInTaskbar
=
document
.
getElementById
(
"
showTabsInTaskbar
"
)
;
showTabsInTaskbar
.
hidden
=
ver
<
6
.
1
;
}
catch
(
ex
)
{
}
}
let
thumbsCheckbox
=
document
.
getElementById
(
"
tabPreviewShowThumbnails
"
)
;
let
cardPreviewEnabledPref
=
Preferences
.
get
(
"
browser
.
tabs
.
hoverPreview
.
enabled
"
)
;
let
maybeShowThumbsCheckbox
=
(
)
=
>
(
thumbsCheckbox
.
hidden
=
!
cardPreviewEnabledPref
.
value
)
;
cardPreviewEnabledPref
.
on
(
"
change
"
maybeShowThumbsCheckbox
)
;
maybeShowThumbsCheckbox
(
)
;
if
(
!
TransientPrefs
.
prefShouldBeVisible
(
"
browser
.
tabs
.
warnOnOpen
"
)
)
{
document
.
getElementById
(
"
warnOpenMany
"
)
.
hidden
=
true
;
}
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
let
quitKeyElement
=
window
.
browsingContext
.
topChromeWindow
.
document
.
getElementById
(
"
key_quitApplication
"
)
;
if
(
quitKeyElement
)
{
let
quitKey
=
ShortcutUtils
.
prettifyShortcut
(
quitKeyElement
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
warnOnQuitKey
"
)
"
confirm
-
on
-
quit
-
with
-
key
"
{
quitKey
}
)
;
}
else
{
document
.
getElementById
(
"
warnOnQuitKey
"
)
.
hidden
=
true
;
}
}
setEventListener
(
"
ctrlTabRecentlyUsedOrder
"
"
command
"
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
ctrlTab
.
migrated
"
)
;
}
)
;
setEventListener
(
"
manageBrowserLanguagesButton
"
"
command
"
function
(
)
{
gMainPane
.
showBrowserLanguagesSubDialog
(
{
search
:
false
}
)
;
}
)
;
if
(
AppConstants
.
MOZ_UPDATER
)
{
setEventListener
(
"
checkForUpdatesButton
"
"
command
"
function
(
)
{
gAppUpdater
.
checkForUpdates
(
)
;
}
)
;
setEventListener
(
"
downloadAndInstallButton
"
"
command
"
function
(
)
{
gAppUpdater
.
startDownload
(
)
;
}
)
;
setEventListener
(
"
updateButton
"
"
command
"
function
(
)
{
gAppUpdater
.
buttonRestartAfterDownload
(
)
;
}
)
;
setEventListener
(
"
checkForUpdatesButton2
"
"
command
"
function
(
)
{
gAppUpdater
.
checkForUpdates
(
)
;
}
)
;
setEventListener
(
"
checkForUpdatesButton3
"
"
command
"
function
(
)
{
gAppUpdater
.
checkForUpdates
(
)
;
}
)
;
setEventListener
(
"
checkForUpdatesButton4
"
"
command
"
function
(
)
{
gAppUpdater
.
checkForUpdates
(
)
;
}
)
;
}
setEventListener
(
"
browserRestoreSession
"
"
command
"
gMainPane
.
onBrowserRestoreSessionChange
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
setEventListener
(
"
windowsLaunchOnLogin
"
"
command
"
gMainPane
.
onWindowsLaunchOnLoginChange
)
;
if
(
Cc
[
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
]
.
getService
(
Ci
.
nsIToolkitProfileService
)
.
startWithLastProfile
)
{
NimbusFeatures
.
windowsLaunchOnLogin
.
recordExposureEvent
(
{
once
:
true
}
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
windowsLaunchOnLogin
.
enabled
"
false
)
)
{
document
.
getElementById
(
"
windowsLaunchOnLoginBox
"
)
.
hidden
=
false
;
}
}
}
gMainPane
.
updateBrowserStartupUI
=
gMainPane
.
updateBrowserStartupUI
.
bind
(
gMainPane
)
;
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
.
on
(
"
change
"
gMainPane
.
updateBrowserStartupUI
)
;
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
.
on
(
"
change
"
gMainPane
.
updateBrowserStartupUI
)
;
Preferences
.
get
(
"
browser
.
startup
.
homepage
"
)
.
on
(
"
change
"
gMainPane
.
updateBrowserStartupUI
)
;
gMainPane
.
updateBrowserStartupUI
(
)
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
setEventListener
(
"
setDefaultButton
"
"
command
"
gMainPane
.
setDefaultBrowser
)
;
}
setEventListener
(
"
disableContainersExtension
"
"
command
"
makeDisableControllingExtension
(
PREF_SETTING_TYPE
CONTAINERS_KEY
)
)
;
setEventListener
(
"
chooseLanguage
"
"
command
"
gMainPane
.
showLanguages
)
;
setEventListener
(
"
fxtranslateButton
"
"
command
"
gMainPane
.
showTranslationExceptions
)
;
Preferences
.
get
(
"
font
.
language
.
group
"
)
.
on
(
"
change
"
gMainPane
.
_rebuildFonts
.
bind
(
gMainPane
)
)
;
setEventListener
(
"
advancedFonts
"
"
command
"
gMainPane
.
configureFonts
)
;
setEventListener
(
"
colors
"
"
command
"
gMainPane
.
configureColors
)
;
Preferences
.
get
(
"
layers
.
acceleration
.
disabled
"
)
.
on
(
"
change
"
gMainPane
.
updateHardwareAcceleration
.
bind
(
gMainPane
)
)
;
setEventListener
(
"
connectionSettings
"
"
command
"
gMainPane
.
showConnections
)
;
setEventListener
(
"
browserContainersCheckbox
"
"
command
"
gMainPane
.
checkBrowserContainers
)
;
setEventListener
(
"
browserContainersSettings
"
"
command
"
gMainPane
.
showContainerSettings
)
;
setEventListener
(
"
data
-
migration
"
"
command
"
gMainPane
.
onMigrationButtonCommand
)
;
document
.
getElementById
(
"
migrationWizardDialog
"
)
.
addEventListener
(
"
MigrationWizard
:
Close
"
function
(
e
)
{
e
.
currentTarget
.
close
(
)
;
}
)
;
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
profileImport
"
)
)
{
document
.
getElementById
(
"
dataMigrationGroup
"
)
.
remove
(
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
backup
.
preferences
.
ui
.
enabled
"
false
)
)
{
let
backupGroup
=
document
.
getElementById
(
"
dataBackupGroup
"
)
;
backupGroup
.
removeAttribute
(
"
data
-
hidden
-
from
-
search
"
)
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
|
|
AppConstants
.
MOZ_WIDGET_GTK
)
{
document
.
getElementById
(
"
mediaControlBox
"
)
.
hidden
=
false
;
}
this
.
_rebuildFonts
(
)
;
const
fxtranslationsDisabledPrefName
=
"
extensions
.
translations
.
disabled
"
;
if
(
!
Services
.
prefs
.
getBoolPref
(
fxtranslationsDisabledPrefName
true
)
)
{
let
fxtranslationRow
=
document
.
getElementById
(
"
fxtranslationsBox
"
)
;
fxtranslationRow
.
hidden
=
false
;
}
let
emeUIEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
eme
.
ui
.
enabled
"
)
;
if
(
navigator
.
platform
.
toLowerCase
(
)
.
startsWith
(
"
win
"
)
)
{
emeUIEnabled
=
emeUIEnabled
&
&
parseFloat
(
Services
.
sysinfo
.
get
(
"
version
"
)
)
>
=
6
;
}
if
(
!
emeUIEnabled
)
{
document
.
getElementById
(
"
drmGroup
"
)
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
}
let
version
=
AppConstants
.
MOZ_APP_VERSION_DISPLAY
;
if
(
/
a
\
d
+
/
.
test
(
version
)
)
{
let
buildID
=
Services
.
appinfo
.
appBuildID
;
let
year
=
buildID
.
slice
(
0
4
)
;
let
month
=
buildID
.
slice
(
4
6
)
;
let
day
=
buildID
.
slice
(
6
8
)
;
version
+
=
(
{
year
}
-
{
month
}
-
{
day
}
)
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
archResource
=
Services
.
appinfo
.
is64Bit
?
"
aboutDialog
.
architecture
.
sixtyFourBit
"
:
"
aboutDialog
.
architecture
.
thirtyTwoBit
"
;
let
arch
=
bundle
.
GetStringFromName
(
archResource
)
;
version
+
=
(
{
arch
}
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
updateAppInfo
"
)
"
update
-
application
-
version
"
{
version
}
)
;
let
relNotesLink
=
document
.
getElementById
(
"
releasenotes
"
)
;
let
relNotesPrefType
=
Services
.
prefs
.
getPrefType
(
"
app
.
releaseNotesURL
"
)
;
if
(
relNotesPrefType
!
=
Services
.
prefs
.
PREF_INVALID
)
{
let
relNotesURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
releaseNotesURL
"
)
;
if
(
relNotesURL
!
=
"
about
:
blank
"
)
{
relNotesLink
.
href
=
relNotesURL
;
relNotesLink
.
hidden
=
false
;
}
}
let
defaults
=
Services
.
prefs
.
getDefaultBranch
(
null
)
;
let
distroId
=
defaults
.
getCharPref
(
"
distribution
.
id
"
"
"
)
;
if
(
distroId
)
{
let
distroString
=
distroId
;
let
distroVersion
=
defaults
.
getCharPref
(
"
distribution
.
version
"
"
"
)
;
if
(
distroVersion
)
{
distroString
+
=
"
-
"
+
distroVersion
;
}
let
distroIdField
=
document
.
getElementById
(
"
distributionId
"
)
;
distroIdField
.
value
=
distroString
;
distroIdField
.
hidden
=
false
;
let
distroAbout
=
defaults
.
getStringPref
(
"
distribution
.
about
"
"
"
)
;
if
(
distroAbout
)
{
let
distroField
=
document
.
getElementById
(
"
distribution
"
)
;
distroField
.
value
=
distroAbout
;
distroField
.
hidden
=
false
;
}
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
gAppUpdater
=
new
appUpdater
(
)
;
setEventListener
(
"
showUpdateHistory
"
"
command
"
gMainPane
.
showUpdates
)
;
let
updateDisabled
=
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
;
if
(
gIsPackagedApp
)
{
document
.
getElementById
(
"
updatesCategory
"
)
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
document
.
getElementById
(
"
updateApp
"
)
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
}
else
if
(
updateDisabled
|
|
UpdateUtils
.
appUpdateAutoSettingIsLocked
(
)
|
|
gApplicationUpdateService
.
manualUpdateOnly
)
{
document
.
getElementById
(
"
updateAllowDescription
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
updateSettingsContainer
"
)
.
hidden
=
true
;
}
else
{
document
.
getElementById
(
"
autoDesktop
"
)
.
removeAttribute
(
"
selected
"
)
;
document
.
getElementById
(
"
manualDesktop
"
)
.
removeAttribute
(
"
selected
"
)
;
this
.
readUpdateAutoPref
(
)
;
setEventListener
(
"
updateRadioGroup
"
"
command
"
event
=
>
{
if
(
event
.
target
.
id
=
=
"
backgroundUpdate
"
)
{
this
.
writeBackgroundUpdatePref
(
)
;
}
else
{
this
.
writeUpdateAutoPref
(
)
;
}
}
)
;
if
(
this
.
isBackgroundUpdateUIAvailable
(
)
)
{
document
.
getElementById
(
"
backgroundUpdate
"
)
.
hidden
=
false
;
this
.
readBackgroundUpdatePref
(
)
;
}
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
launchOnLoginCheckbox
=
document
.
getElementById
(
"
windowsLaunchOnLogin
"
)
;
WindowsLaunchOnLogin
.
getLaunchOnLoginEnabled
(
)
.
then
(
enabled
=
>
{
launchOnLoginCheckbox
.
checked
=
enabled
;
}
)
;
WindowsLaunchOnLogin
.
getLaunchOnLoginApproved
(
)
.
then
(
approvedByWindows
=
>
{
launchOnLoginCheckbox
.
disabled
=
!
approvedByWindows
;
document
.
getElementById
(
"
windowsLaunchOnLoginDisabledBox
"
)
.
hidden
=
approvedByWindows
;
}
)
;
let
updateContainer
=
document
.
getElementById
(
"
updateSettingsContainer
"
)
;
updateContainer
.
classList
.
add
(
"
updateSettingCrossUserWarningContainer
"
)
;
document
.
getElementById
(
"
updateSettingCrossUserWarningDesc
"
)
.
hidden
=
false
;
}
}
Services
.
obs
.
addObserver
(
this
AUTO_UPDATE_CHANGED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
BACKGROUND_UPDATE_CHANGED_TOPIC
)
;
setEventListener
(
"
filter
"
"
command
"
gMainPane
.
filter
)
;
setEventListener
(
"
typeColumn
"
"
click
"
gMainPane
.
sort
)
;
setEventListener
(
"
actionColumn
"
"
click
"
gMainPane
.
sort
)
;
setEventListener
(
"
chooseFolder
"
"
command
"
gMainPane
.
chooseFolder
)
;
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
.
on
(
"
change
"
gMainPane
.
displayDownloadDirPref
.
bind
(
gMainPane
)
)
;
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
.
on
(
"
change
"
gMainPane
.
displayDownloadDirPref
.
bind
(
gMainPane
)
)
;
gMainPane
.
displayDownloadDirPref
(
)
;
window
.
addEventListener
(
"
unload
"
this
)
;
if
(
document
.
getElementById
(
"
actionColumn
"
)
.
hasAttribute
(
"
sortDirection
"
)
)
{
this
.
_sortColumn
=
document
.
getElementById
(
"
actionColumn
"
)
;
document
.
getElementById
(
"
typeColumn
"
)
.
removeAttribute
(
"
sortDirection
"
)
;
}
else
{
this
.
_sortColumn
=
document
.
getElementById
(
"
typeColumn
"
)
;
}
appendSearchKeywords
(
"
browserContainersSettings
"
[
"
user
-
context
-
personal
"
"
user
-
context
-
work
"
"
user
-
context
-
banking
"
"
user
-
context
-
shopping
"
]
.
map
(
ContextualIdentityService
.
formatContextLabel
)
)
;
AppearanceChooser
.
init
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
main
-
pane
-
loaded
"
)
;
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
defaultFont
"
)
element
=
>
FontBuilder
.
readFontSelection
(
element
)
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
useFullKeyboardNavigation
"
)
(
)
=
>
this
.
readUseFullKeyboardNavigation
(
)
)
;
Preferences
.
addSyncToPrefListener
(
document
.
getElementById
(
"
useFullKeyboardNavigation
"
)
(
)
=
>
this
.
writeUseFullKeyboardNavigation
(
)
)
;
}
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
checkSpelling
"
)
(
)
=
>
this
.
readCheckSpelling
(
)
)
;
Preferences
.
addSyncToPrefListener
(
document
.
getElementById
(
"
checkSpelling
"
)
(
)
=
>
this
.
writeCheckSpelling
(
)
)
;
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
alwaysAsk
"
)
(
)
=
>
this
.
readUseDownloadDir
(
)
)
;
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
linkTargeting
"
)
(
)
=
>
this
.
readLinkTarget
(
)
)
;
Preferences
.
addSyncToPrefListener
(
document
.
getElementById
(
"
linkTargeting
"
)
(
)
=
>
this
.
writeLinkTarget
(
)
)
;
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
browserContainersCheckbox
"
)
(
)
=
>
this
.
readBrowserContainersCheckbox
(
)
)
;
this
.
setInitialized
(
)
;
}
preInit
(
)
{
promiseLoadHandlersList
=
new
Promise
(
(
resolve
reject
)
=
>
{
window
.
addEventListener
(
"
pageshow
"
async
(
)
=
>
{
await
this
.
initialized
;
try
{
this
.
_initListEventHandlers
(
)
;
this
.
_loadData
(
)
;
await
this
.
_rebuildVisibleTypes
(
)
;
await
this
.
_rebuildView
(
)
;
await
this
.
_sortListView
(
)
;
resolve
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
{
once
:
true
}
)
;
}
)
;
}
handleSubcategory
(
subcategory
)
{
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
profileImport
"
)
)
{
return
false
;
}
if
(
subcategory
=
=
"
migrate
"
)
{
this
.
showMigrationWizardDialog
(
)
;
return
true
;
}
if
(
subcategory
=
=
"
migrate
-
autoclose
"
)
{
this
.
showMigrationWizardDialog
(
{
closeTabWhenDone
:
true
}
)
;
}
return
false
;
}
readBrowserContainersCheckbox
(
)
{
const
pref
=
Preferences
.
get
(
"
privacy
.
userContext
.
enabled
"
)
;
const
settings
=
document
.
getElementById
(
"
browserContainersSettings
"
)
;
settings
.
disabled
=
!
pref
.
value
;
const
containersEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
;
const
containersCheckbox
=
document
.
getElementById
(
"
browserContainersCheckbox
"
)
;
containersCheckbox
.
checked
=
containersEnabled
;
handleControllingExtension
(
PREF_SETTING_TYPE
CONTAINERS_KEY
)
.
then
(
isControlled
=
>
{
containersCheckbox
.
disabled
=
isControlled
;
}
)
;
}
initBrowserContainers
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
ui
.
enabled
"
)
)
{
document
.
getElementById
(
"
browserContainersbox
"
)
.
setAttribute
(
"
data
-
hidden
-
from
-
search
"
"
true
"
)
;
return
;
}
Services
.
prefs
.
addObserver
(
PREF_CONTAINERS_EXTENSION
this
)
;
document
.
getElementById
(
"
browserContainersbox
"
)
.
hidden
=
false
;
this
.
readBrowserContainersCheckbox
(
)
;
}
async
onGetStarted
(
)
{
if
(
!
AppConstants
.
MOZ_DEV_EDITION
)
{
return
;
}
const
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
!
win
)
{
return
;
}
const
user
=
await
fxAccounts
.
getSignedInUser
(
)
;
if
(
user
)
{
win
.
openTrustedLinkIn
(
"
about
:
preferences
#
sync
"
"
current
"
)
;
return
;
}
if
(
!
(
await
FxAccounts
.
canConnectAccount
(
)
)
)
{
return
;
}
let
url
=
await
FxAccounts
.
config
.
promiseConnectAccountURI
(
"
dev
-
edition
-
setup
"
)
;
let
accountsTab
=
win
.
gBrowser
.
addWebTab
(
url
)
;
win
.
gBrowser
.
selectedTab
=
accountsTab
;
}
updateButtons
(
aButtonID
aPreferenceID
)
{
var
button
=
document
.
getElementById
(
aButtonID
)
;
var
preference
=
Preferences
.
get
(
aPreferenceID
)
;
button
.
disabled
=
!
preference
.
value
;
return
undefined
;
}
updateBrowserStartupUI
(
)
{
const
pbAutoStartPref
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
const
startupPref
=
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
;
let
newValue
;
let
checkbox
=
document
.
getElementById
(
"
browserRestoreSession
"
)
;
checkbox
.
disabled
=
pbAutoStartPref
.
value
|
|
startupPref
.
locked
;
newValue
=
pbAutoStartPref
.
value
?
false
:
startupPref
.
value
=
=
=
this
.
STARTUP_PREF_RESTORE_SESSION
;
if
(
checkbox
.
checked
!
=
=
newValue
)
{
checkbox
.
checked
=
newValue
;
}
}
async
initDefaultZoomValues
(
)
{
let
win
=
window
.
browsingContext
.
topChromeWindow
;
let
selected
=
await
win
.
ZoomUI
.
getGlobalValue
(
)
;
let
menulist
=
document
.
getElementById
(
"
defaultZoom
"
)
;
new
SelectionChangedMenulist
(
menulist
event
=
>
{
let
parsedZoom
=
parseFloat
(
(
event
.
target
.
value
/
100
)
.
toFixed
(
2
)
)
;
gMainPane
.
handleDefaultZoomChange
(
parsedZoom
)
;
}
)
;
setEventListener
(
"
zoomText
"
"
command
"
function
(
)
{
win
.
ZoomManager
.
toggleZoom
(
)
;
document
.
getElementById
(
"
text
-
zoom
-
override
-
warning
"
)
.
hidden
=
!
document
.
getElementById
(
"
zoomText
"
)
.
checked
;
}
)
;
let
zoomValues
=
win
.
ZoomManager
.
zoomValues
.
map
(
a
=
>
{
return
Math
.
round
(
a
*
100
)
;
}
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
zoomLevel
of
zoomValues
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
document
.
l10n
.
setAttributes
(
menuitem
"
preferences
-
default
-
zoom
-
value
"
{
percentage
:
zoomLevel
}
)
;
menuitem
.
setAttribute
(
"
value
"
zoomLevel
)
;
fragment
.
appendChild
(
menuitem
)
;
}
let
menupopup
=
menulist
.
querySelector
(
"
menupopup
"
)
;
menupopup
.
appendChild
(
fragment
)
;
menulist
.
value
=
Math
.
round
(
selected
*
100
)
;
let
checkbox
=
document
.
getElementById
(
"
zoomText
"
)
;
checkbox
.
checked
=
!
win
.
ZoomManager
.
useFullZoom
;
document
.
getElementById
(
"
text
-
zoom
-
override
-
warning
"
)
.
hidden
=
!
checkbox
.
checked
;
document
.
getElementById
(
"
zoomBox
"
)
.
hidden
=
false
;
}
async
initTranslations
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
translations
.
enable
"
)
)
{
return
;
}
document
.
getElementById
(
"
translationsGroup
"
)
.
hidden
=
false
;
class
TranslationsState
{
constructor
(
supportedLanguages
languageList
downloadPhases
)
{
this
.
supportedLanguages
=
supportedLanguages
;
this
.
languageList
=
languageList
;
this
.
downloadPhases
=
downloadPhases
;
}
static
async
create
(
)
{
const
supportedLanguages
=
await
TranslationsParent
.
getSupportedLanguages
(
)
;
const
languageList
=
TranslationsParent
.
getLanguageList
(
supportedLanguages
)
;
const
downloadPhases
=
await
TranslationsState
.
createDownloadPhases
(
languageList
)
;
if
(
supportedLanguages
.
languagePairs
.
length
=
=
=
0
)
{
throw
new
Error
(
"
The
supported
languages
list
was
empty
.
RemoteSettings
may
not
be
available
at
the
moment
.
"
)
;
}
return
new
TranslationsState
(
supportedLanguages
languageList
downloadPhases
)
;
}
static
async
createDownloadPhases
(
languageList
)
{
const
downloadPhases
=
new
Map
(
)
;
for
(
const
{
langTag
}
of
languageList
)
{
downloadPhases
.
set
(
langTag
(
await
TranslationsParent
.
hasAllFilesForLanguage
(
langTag
)
)
?
"
downloaded
"
:
"
uninstalled
"
)
;
}
return
downloadPhases
;
}
}
class
TranslationsView
{
deleteButtons
=
new
Map
(
)
;
downloadButtons
=
new
Map
(
)
;
constructor
(
state
)
{
this
.
state
=
state
;
this
.
elements
=
{
settingsButton
:
document
.
getElementById
(
"
translations
-
manage
-
settings
-
button
"
)
installList
:
document
.
getElementById
(
"
translations
-
manage
-
install
-
list
"
)
installAll
:
document
.
getElementById
(
"
translations
-
manage
-
install
-
all
"
)
deleteAll
:
document
.
getElementById
(
"
translations
-
manage
-
delete
-
all
"
)
error
:
document
.
getElementById
(
"
translations
-
manage
-
error
"
)
}
;
this
.
setup
(
)
;
}
setup
(
)
{
this
.
buildLanguageList
(
)
;
this
.
elements
.
settingsButton
.
addEventListener
(
"
command
"
gMainPane
.
showTranslationsSettings
)
;
this
.
elements
.
installAll
.
addEventListener
(
"
command
"
this
.
handleInstallAll
)
;
this
.
elements
.
deleteAll
.
addEventListener
(
"
command
"
this
.
handleDeleteAll
)
;
}
handleInstallAll
=
async
(
)
=
>
{
this
.
hideError
(
)
;
this
.
disableButtons
(
true
)
;
try
{
await
TranslationsParent
.
downloadAllFiles
(
)
;
this
.
markAllDownloadPhases
(
"
downloaded
"
)
;
}
catch
(
error
)
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
download
"
error
)
;
await
this
.
reloadDownloadPhases
(
)
;
this
.
updateAllButtons
(
)
;
}
this
.
disableButtons
(
false
)
;
}
;
handleDeleteAll
=
async
(
)
=
>
{
this
.
hideError
(
)
;
this
.
disableButtons
(
true
)
;
try
{
await
TranslationsParent
.
deleteAllLanguageFiles
(
)
;
this
.
markAllDownloadPhases
(
"
uninstalled
"
)
;
}
catch
(
error
)
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
remove
"
error
)
;
await
this
.
reloadDownloadPhases
(
)
;
console
.
error
(
error
)
;
}
this
.
disableButtons
(
false
)
;
}
;
getDownloadButtonHandler
(
langTag
)
{
return
async
(
)
=
>
{
this
.
hideError
(
)
;
this
.
updateDownloadPhase
(
langTag
"
loading
"
)
;
try
{
await
TranslationsParent
.
downloadLanguageFiles
(
langTag
)
;
this
.
updateDownloadPhase
(
langTag
"
downloaded
"
)
;
}
catch
(
error
)
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
download
"
error
)
;
this
.
updateDownloadPhase
(
langTag
"
uninstalled
"
)
;
}
}
;
}
getDeleteButtonHandler
(
langTag
)
{
return
async
(
)
=
>
{
this
.
hideError
(
)
;
this
.
updateDownloadPhase
(
langTag
"
loading
"
)
;
try
{
await
TranslationsParent
.
deleteLanguageFiles
(
langTag
)
;
this
.
updateDownloadPhase
(
langTag
"
uninstalled
"
)
;
}
catch
(
error
)
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
remove
"
error
)
;
await
this
.
reloadDownloadPhases
(
)
;
}
}
;
}
buildLanguageList
(
)
{
const
listFragment
=
document
.
createDocumentFragment
(
)
;
for
(
const
{
langTag
displayName
}
of
this
.
state
.
languageList
)
{
const
hboxRow
=
document
.
createXULElement
(
"
hbox
"
)
;
hboxRow
.
classList
.
add
(
"
translations
-
manage
-
language
"
)
;
const
languageLabel
=
document
.
createXULElement
(
"
label
"
)
;
languageLabel
.
textContent
=
displayName
;
const
downloadButton
=
document
.
createXULElement
(
"
button
"
)
;
const
deleteButton
=
document
.
createXULElement
(
"
button
"
)
;
downloadButton
.
addEventListener
(
"
command
"
this
.
getDownloadButtonHandler
(
langTag
)
)
;
deleteButton
.
addEventListener
(
"
command
"
this
.
getDeleteButtonHandler
(
langTag
)
)
;
document
.
l10n
.
setAttributes
(
downloadButton
"
translations
-
manage
-
language
-
download
-
button
"
)
;
document
.
l10n
.
setAttributes
(
deleteButton
"
translations
-
manage
-
language
-
remove
-
button
"
)
;
downloadButton
.
hidden
=
true
;
deleteButton
.
hidden
=
true
;
this
.
deleteButtons
.
set
(
langTag
deleteButton
)
;
this
.
downloadButtons
.
set
(
langTag
downloadButton
)
;
hboxRow
.
appendChild
(
languageLabel
)
;
hboxRow
.
appendChild
(
downloadButton
)
;
hboxRow
.
appendChild
(
deleteButton
)
;
listFragment
.
appendChild
(
hboxRow
)
;
}
this
.
updateAllButtons
(
)
;
this
.
elements
.
installList
.
appendChild
(
listFragment
)
;
this
.
elements
.
installList
.
hidden
=
false
;
}
updateDownloadPhase
(
langTag
downloadPhase
)
{
this
.
state
.
downloadPhases
.
set
(
langTag
downloadPhase
)
;
this
.
updateButton
(
langTag
downloadPhase
)
;
this
.
updateHeaderButtons
(
)
;
}
async
reloadDownloadPhases
(
)
{
this
.
state
.
downloadPhases
=
await
TranslationsState
.
createDownloadPhases
(
this
.
state
.
languageList
)
;
this
.
updateAllButtons
(
)
;
}
markAllDownloadPhases
(
downloadPhase
)
{
const
{
downloadPhases
}
=
this
.
state
;
for
(
const
key
of
downloadPhases
.
keys
(
)
)
{
downloadPhases
.
set
(
key
downloadPhase
)
;
}
this
.
updateAllButtons
(
)
;
}
updateHeaderButtons
(
)
{
let
allDownloaded
=
true
;
let
allUninstalled
=
true
;
for
(
const
downloadPhase
of
this
.
state
.
downloadPhases
.
values
(
)
)
{
if
(
downloadPhase
=
=
=
"
loading
"
)
{
continue
;
}
allDownloaded
&
&
=
downloadPhase
=
=
=
"
downloaded
"
;
allUninstalled
&
&
=
downloadPhase
=
=
=
"
uninstalled
"
;
}
this
.
elements
.
installAll
.
hidden
=
allDownloaded
;
this
.
elements
.
deleteAll
.
hidden
=
allUninstalled
;
}
updateAllButtons
(
)
{
this
.
updateHeaderButtons
(
)
;
for
(
const
[
langTag
downloadPhase
]
of
this
.
state
.
downloadPhases
)
{
this
.
updateButton
(
langTag
downloadPhase
)
;
}
}
updateButton
(
langTag
downloadPhase
)
{
const
downloadButton
=
this
.
downloadButtons
.
get
(
langTag
)
;
const
deleteButton
=
this
.
deleteButtons
.
get
(
langTag
)
;
switch
(
downloadPhase
)
{
case
"
downloaded
"
:
downloadButton
.
hidden
=
true
;
deleteButton
.
hidden
=
false
;
downloadButton
.
removeAttribute
(
"
disabled
"
)
;
break
;
case
"
uninstalled
"
:
downloadButton
.
hidden
=
false
;
deleteButton
.
hidden
=
true
;
downloadButton
.
removeAttribute
(
"
disabled
"
)
;
break
;
case
"
loading
"
:
downloadButton
.
hidden
=
false
;
deleteButton
.
hidden
=
true
;
downloadButton
.
setAttribute
(
"
disabled
"
true
)
;
break
;
}
}
disableButtons
(
isDisabled
)
{
this
.
elements
.
installAll
.
disabled
=
isDisabled
;
this
.
elements
.
deleteAll
.
disabled
=
isDisabled
;
for
(
const
button
of
this
.
downloadButtons
.
values
(
)
)
{
button
.
disabled
=
isDisabled
;
}
for
(
const
button
of
this
.
deleteButtons
.
values
(
)
)
{
button
.
disabled
=
isDisabled
;
}
}
static
showError
(
l10nId
error
)
{
console
.
error
(
error
)
;
const
errorMessage
=
document
.
getElementById
(
"
translations
-
manage
-
error
"
)
;
errorMessage
.
hidden
=
false
;
document
.
l10n
.
setAttributes
(
errorMessage
l10nId
)
;
}
hideError
(
)
{
this
.
elements
.
error
.
hidden
=
true
;
}
}
TranslationsState
.
create
(
)
.
then
(
state
=
>
{
new
TranslationsView
(
state
)
;
}
error
=
>
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
list
"
error
)
;
}
)
;
}
initPrimaryBrowserLanguageUI
(
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
"
intl
.
ui
.
browserLanguage
"
true
)
;
let
menulist
=
document
.
getElementById
(
"
primaryBrowserLocale
"
)
;
new
SelectionChangedMenulist
(
menulist
event
=
>
{
gMainPane
.
onPrimaryBrowserLanguageMenuChange
(
event
)
;
}
)
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
}
async
updatePrimaryBrowserLanguageUI
(
selected
)
{
let
available
=
await
LangPackMatcher
.
getAvailableLocales
(
)
;
let
localeNames
=
Services
.
intl
.
getLocaleDisplayNames
(
undefined
available
{
preferNative
:
true
}
)
;
let
locales
=
available
.
map
(
(
code
i
)
=
>
(
{
code
name
:
localeNames
[
i
]
}
)
)
;
locales
.
sort
(
(
a
b
)
=
>
a
.
name
>
b
.
name
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
{
code
name
}
of
locales
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
value
"
code
)
;
menuitem
.
setAttribute
(
"
label
"
name
)
;
fragment
.
appendChild
(
menuitem
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
downloadEnabled
"
)
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
id
=
"
primaryBrowserLocaleSearch
"
;
menuitem
.
setAttribute
(
"
label
"
await
document
.
l10n
.
formatValue
(
"
browser
-
languages
-
search
"
)
)
;
menuitem
.
setAttribute
(
"
value
"
"
search
"
)
;
fragment
.
appendChild
(
menuitem
)
;
}
let
menulist
=
document
.
getElementById
(
"
primaryBrowserLocale
"
)
;
let
menupopup
=
menulist
.
querySelector
(
"
menupopup
"
)
;
menupopup
.
textContent
=
"
"
;
menupopup
.
appendChild
(
fragment
)
;
menulist
.
value
=
selected
;
document
.
getElementById
(
"
browserLanguagesBox
"
)
.
hidden
=
false
;
}
async
showConfirmLanguageChangeMessageBar
(
locales
)
{
let
messageBar
=
document
.
getElementById
(
"
confirmBrowserLanguage
"
)
;
let
newBundle
=
getBundleForLocales
(
locales
)
;
let
messages
=
await
Promise
.
all
(
[
newBundle
document
.
l10n
]
.
map
(
async
bundle
=
>
bundle
.
formatValue
(
"
confirm
-
browser
-
language
-
change
-
description
"
)
)
)
;
let
buttonLabels
=
await
Promise
.
all
(
[
newBundle
document
.
l10n
]
.
map
(
async
bundle
=
>
bundle
.
formatValue
(
"
confirm
-
browser
-
language
-
change
-
button
"
)
)
)
;
if
(
messages
[
0
]
=
=
messages
[
1
]
&
&
buttonLabels
[
0
]
=
=
buttonLabels
[
1
]
)
{
messages
.
pop
(
)
;
buttonLabels
.
pop
(
)
;
}
let
contentContainer
=
messageBar
.
querySelector
(
"
.
message
-
bar
-
content
-
container
"
)
;
contentContainer
.
textContent
=
"
"
;
for
(
let
i
=
0
;
i
<
messages
.
length
;
i
+
+
)
{
let
messageContainer
=
document
.
createXULElement
(
"
hbox
"
)
;
messageContainer
.
classList
.
add
(
"
message
-
bar
-
content
"
)
;
messageContainer
.
style
.
flex
=
"
1
50
%
"
;
messageContainer
.
setAttribute
(
"
align
"
"
center
"
)
;
let
description
=
document
.
createXULElement
(
"
description
"
)
;
description
.
classList
.
add
(
"
message
-
bar
-
description
"
)
;
if
(
i
=
=
0
&
&
Services
.
intl
.
getScriptDirection
(
locales
[
0
]
)
=
=
=
"
rtl
"
)
{
description
.
classList
.
add
(
"
rtl
-
locale
"
)
;
}
description
.
setAttribute
(
"
flex
"
"
1
"
)
;
description
.
textContent
=
messages
[
i
]
;
messageContainer
.
appendChild
(
description
)
;
let
button
=
document
.
createXULElement
(
"
button
"
)
;
button
.
addEventListener
(
"
command
"
gMainPane
.
confirmBrowserLanguageChange
)
;
button
.
classList
.
add
(
"
message
-
bar
-
button
"
)
;
button
.
setAttribute
(
"
locales
"
locales
.
join
(
"
"
)
)
;
button
.
setAttribute
(
"
label
"
buttonLabels
[
i
]
)
;
messageContainer
.
appendChild
(
button
)
;
contentContainer
.
appendChild
(
messageContainer
)
;
}
messageBar
.
hidden
=
false
;
gMainPane
.
selectedLocalesForRestart
=
locales
;
}
hideConfirmLanguageChangeMessageBar
(
)
{
let
messageBar
=
document
.
getElementById
(
"
confirmBrowserLanguage
"
)
;
messageBar
.
hidden
=
true
;
let
contentContainer
=
messageBar
.
querySelector
(
"
.
message
-
bar
-
content
-
container
"
)
;
contentContainer
.
textContent
=
"
"
;
gMainPane
.
requestingLocales
=
null
;
}
confirmBrowserLanguageChange
(
event
)
{
let
localesString
=
(
event
.
target
.
getAttribute
(
"
locales
"
)
|
|
"
"
)
.
trim
(
)
;
if
(
!
localesString
|
|
!
localesString
.
length
)
{
return
;
}
let
locales
=
localesString
.
split
(
"
"
)
;
Services
.
locale
.
requestedLocales
=
locales
;
gMainPane
.
recordBrowserLanguagesTelemetry
(
"
apply
"
)
;
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
!
cancelQuit
.
data
)
{
Services
.
startup
.
quit
(
Services
.
startup
.
eAttemptQuit
|
Services
.
startup
.
eRestart
)
;
}
}
onPrimaryBrowserLanguageMenuChange
(
event
)
{
let
locale
=
event
.
target
.
value
;
if
(
locale
=
=
"
search
"
)
{
gMainPane
.
showBrowserLanguagesSubDialog
(
{
search
:
true
}
)
;
return
;
}
else
if
(
locale
=
=
Services
.
locale
.
appLocaleAsBCP47
)
{
this
.
hideConfirmLanguageChangeMessageBar
(
)
;
return
;
}
let
newLocales
=
Array
.
from
(
new
Set
(
[
locale
.
.
.
Services
.
locale
.
requestedLocales
]
)
.
values
(
)
)
;
gMainPane
.
recordBrowserLanguagesTelemetry
(
"
reorder
"
)
;
switch
(
gMainPane
.
getLanguageSwitchTransitionType
(
newLocales
)
)
{
case
"
requires
-
restart
"
:
gMainPane
.
showConfirmLanguageChangeMessageBar
(
newLocales
)
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
newLocales
[
0
]
)
;
break
;
case
"
live
-
reload
"
:
Services
.
locale
.
requestedLocales
=
newLocales
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
gMainPane
.
hideConfirmLanguageChangeMessageBar
(
)
;
break
;
case
"
locales
-
match
"
:
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
gMainPane
.
hideConfirmLanguageChangeMessageBar
(
)
;
break
;
default
:
throw
new
Error
(
"
Unhandled
transition
type
.
"
)
;
}
}
handleDefaultZoomChange
(
newZoom
)
{
let
cps2
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
let
nonPrivateLoadContext
=
Cu
.
createLoadContext
(
)
;
let
win
=
window
.
browsingContext
.
topChromeWindow
;
cps2
.
setGlobal
(
win
.
FullZoom
.
name
newZoom
nonPrivateLoadContext
)
;
}
onBrowserRestoreSessionChange
(
event
)
{
const
value
=
event
.
target
.
checked
;
const
startupPref
=
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
;
let
newValue
;
if
(
value
)
{
if
(
startupPref
.
value
=
=
=
this
.
STARTUP_PREF_BLANK
)
{
HomePage
.
safeSet
(
"
about
:
blank
"
)
;
}
newValue
=
this
.
STARTUP_PREF_RESTORE_SESSION
;
}
else
{
newValue
=
this
.
STARTUP_PREF_HOMEPAGE
;
}
startupPref
.
value
=
newValue
;
}
async
onWindowsLaunchOnLoginChange
(
event
)
{
if
(
AppConstants
.
platform
!
=
=
"
win
"
)
{
return
;
}
if
(
event
.
target
.
checked
)
{
await
WindowsLaunchOnLogin
.
createLaunchOnLogin
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
startup
.
windowsLaunchOnLogin
.
disableLaunchOnLoginPrompt
"
true
)
;
}
else
{
await
WindowsLaunchOnLogin
.
removeLaunchOnLogin
(
)
;
}
}
readLinkTarget
(
)
{
var
openNewWindow
=
Preferences
.
get
(
"
browser
.
link
.
open_newwindow
"
)
;
return
openNewWindow
.
value
!
=
2
;
}
writeLinkTarget
(
)
{
var
linkTargeting
=
document
.
getElementById
(
"
linkTargeting
"
)
;
return
linkTargeting
.
checked
?
3
:
2
;
}
updateSetDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
shellSvc
=
getShellService
(
)
;
let
defaultBrowserBox
=
document
.
getElementById
(
"
defaultBrowserBox
"
)
;
let
isInFlatpak
=
gGIOService
?
.
isRunningUnderFlatpak
;
if
(
!
shellSvc
|
|
isInFlatpak
)
{
defaultBrowserBox
.
hidden
=
true
;
return
;
}
let
isDefault
=
shellSvc
.
isDefaultBrowser
(
false
true
)
;
let
setDefaultPane
=
document
.
getElementById
(
"
setDefaultPane
"
)
;
setDefaultPane
.
classList
.
toggle
(
"
is
-
default
"
isDefault
)
;
let
alwaysCheck
=
document
.
getElementById
(
"
alwaysCheckDefault
"
)
;
let
alwaysCheckPref
=
Preferences
.
get
(
"
browser
.
shell
.
checkDefaultBrowser
"
)
;
alwaysCheck
.
disabled
=
alwaysCheckPref
.
locked
|
|
isDefault
;
}
}
async
setDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
alwaysCheckPref
=
Preferences
.
get
(
"
browser
.
shell
.
checkDefaultBrowser
"
)
;
alwaysCheckPref
.
value
=
true
;
this
.
_backoffIndex
=
0
;
let
shellSvc
=
getShellService
(
)
;
if
(
!
shellSvc
)
{
return
;
}
let
setDefaultButton
=
document
.
getElementById
(
"
setDefaultButton
"
)
;
setDefaultButton
.
disabled
=
true
;
try
{
await
shellSvc
.
setDefaultBrowser
(
false
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
return
;
}
finally
{
setDefaultButton
.
disabled
=
false
;
}
let
isDefault
=
shellSvc
.
isDefaultBrowser
(
false
true
)
;
let
setDefaultPane
=
document
.
getElementById
(
"
setDefaultPane
"
)
;
setDefaultPane
.
classList
.
toggle
(
"
is
-
default
"
isDefault
)
;
}
}
showLanguages
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
languages
.
xhtml
"
)
;
}
recordBrowserLanguagesTelemetry
(
method
value
=
null
)
{
Glean
.
intlUiBrowserLanguage
[
method
+
"
Main
"
]
.
record
(
value
?
{
value
}
:
undefined
)
;
}
showBrowserLanguagesSubDialog
(
{
search
}
)
{
let
telemetryId
=
parseInt
(
Services
.
telemetry
.
msSinceProcessStart
(
)
10
)
.
toString
(
)
;
let
method
=
search
?
"
search
"
:
"
manage
"
;
gMainPane
.
recordBrowserLanguagesTelemetry
(
method
telemetryId
)
;
let
opts
=
{
selectedLocalesForRestart
:
gMainPane
.
selectedLocalesForRestart
search
telemetryId
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
browserLanguages
.
xhtml
"
{
closingCallback
:
this
.
browserLanguagesClosed
}
opts
)
;
}
getLanguageSwitchTransitionType
(
newLocales
)
{
const
{
appLocalesAsBCP47
}
=
Services
.
locale
;
if
(
appLocalesAsBCP47
.
join
(
"
"
)
=
=
=
newLocales
.
join
(
"
"
)
)
{
return
"
locales
-
match
"
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
liveReload
"
)
)
{
if
(
Services
.
intl
.
getScriptDirection
(
newLocales
[
0
]
)
!
=
=
Services
.
intl
.
getScriptDirection
(
appLocalesAsBCP47
[
0
]
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
liveReloadBidirectional
"
)
)
{
return
"
requires
-
restart
"
;
}
return
"
live
-
reload
"
;
}
return
"
requires
-
restart
"
;
}
browserLanguagesClosed
(
)
{
let
{
selected
}
=
this
.
gBrowserLanguagesDialog
;
this
.
gBrowserLanguagesDialog
.
recordTelemetry
(
selected
?
"
accept
"
:
"
cancel
"
)
;
if
(
!
selected
)
{
return
;
}
const
prevLocales
=
Services
.
locale
.
requestedLocales
.
filter
(
lc
=
>
selected
.
indexOf
(
lc
)
>
0
)
;
const
newLocales
=
selected
.
filter
(
(
lc
i
)
=
>
i
>
0
&
&
prevLocales
.
includes
(
lc
)
)
;
if
(
prevLocales
.
some
(
(
lc
i
)
=
>
newLocales
[
i
]
!
=
lc
)
)
{
this
.
gBrowserLanguagesDialog
.
recordTelemetry
(
"
setFallback
"
)
;
}
switch
(
gMainPane
.
getLanguageSwitchTransitionType
(
selected
)
)
{
case
"
requires
-
restart
"
:
gMainPane
.
showConfirmLanguageChangeMessageBar
(
selected
)
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
selected
[
0
]
)
;
break
;
case
"
live
-
reload
"
:
Services
.
locale
.
requestedLocales
=
selected
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
gMainPane
.
hideConfirmLanguageChangeMessageBar
(
)
;
break
;
case
"
locales
-
match
"
:
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
gMainPane
.
hideConfirmLanguageChangeMessageBar
(
)
;
break
;
default
:
throw
new
Error
(
"
Unhandled
transition
type
.
"
)
;
}
}
displayUseSystemLocale
(
)
{
let
appLocale
=
Services
.
locale
.
appLocaleAsBCP47
;
let
regionalPrefsLocales
=
Services
.
locale
.
regionalPrefsLocales
;
if
(
!
regionalPrefsLocales
.
length
)
{
return
;
}
let
systemLocale
=
regionalPrefsLocales
[
0
]
;
let
localeDisplayname
=
Services
.
intl
.
getLocaleDisplayNames
(
undefined
[
systemLocale
]
{
preferNative
:
true
}
)
;
if
(
!
localeDisplayname
.
length
)
{
return
;
}
let
localeName
=
localeDisplayname
[
0
]
;
if
(
appLocale
.
split
(
"
-
u
-
"
)
[
0
]
!
=
systemLocale
.
split
(
"
-
u
-
"
)
[
0
]
)
{
let
checkbox
=
document
.
getElementById
(
"
useSystemLocale
"
)
;
document
.
l10n
.
setAttributes
(
checkbox
"
use
-
system
-
locale
"
{
localeName
}
)
;
checkbox
.
hidden
=
false
;
}
}
showTranslationExceptions
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
translationExceptions
.
xhtml
"
)
;
}
showTranslationsSettings
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
translations
.
newSettingsUI
.
enable
"
)
)
{
const
translationsSettings
=
document
.
getElementById
(
"
translations
-
settings
-
page
"
)
;
translationsSettings
.
setAttribute
(
"
data
-
hidden
-
from
-
search
"
"
false
"
)
;
translationsSettings
.
hidden
=
false
;
gotoPref
(
"
translations
"
)
;
}
else
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
translations
.
xhtml
"
)
;
}
}
configureFonts
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
fonts
.
xhtml
"
{
features
:
"
resizable
=
no
"
}
)
;
}
configureColors
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
colors
.
xhtml
"
{
features
:
"
resizable
=
no
"
}
)
;
}
showConnections
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
connection
.
xhtml
"
{
closingCallback
:
this
.
updateProxySettingsUI
.
bind
(
this
)
}
)
;
}
async
updateProxySettingsUI
(
)
{
let
controllingExtension
=
await
getControllingExtension
(
PREF_SETTING_TYPE
PROXY_KEY
)
;
let
description
=
document
.
getElementById
(
"
connectionSettingsDescription
"
)
;
if
(
controllingExtension
)
{
setControllingExtensionDescription
(
description
controllingExtension
"
proxy
.
settings
"
)
;
}
else
{
setControllingExtensionDescription
(
description
null
"
network
-
proxy
-
connection
-
description
"
)
;
}
}
async
checkBrowserContainers
(
)
{
let
checkbox
=
document
.
getElementById
(
"
browserContainersCheckbox
"
)
;
if
(
checkbox
.
checked
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
true
)
;
return
;
}
let
count
=
ContextualIdentityService
.
countContainerTabs
(
)
;
if
(
count
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
let
[
title
message
okButton
cancelButton
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
containers
-
disable
-
alert
-
title
"
}
{
id
:
"
containers
-
disable
-
alert
-
desc
"
args
:
{
tabCount
:
count
}
}
{
id
:
"
containers
-
disable
-
alert
-
ok
-
button
"
args
:
{
tabCount
:
count
}
}
{
id
:
"
containers
-
disable
-
alert
-
cancel
-
button
"
}
]
)
;
let
buttonFlags
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
+
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
;
let
rv
=
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
if
(
rv
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
checkbox
.
checked
=
true
;
}
showContainerSettings
(
)
{
gotoPref
(
"
containers
"
)
;
}
updateHardwareAcceleration
(
)
{
}
_rebuildFonts
(
)
{
var
langGroupPref
=
Preferences
.
get
(
"
font
.
language
.
group
"
)
;
var
isSerif
=
this
.
_readDefaultFontTypeForLanguage
(
langGroupPref
.
value
)
=
=
"
serif
"
;
this
.
_selectDefaultLanguageGroup
(
langGroupPref
.
value
isSerif
)
;
}
_readDefaultFontTypeForLanguage
(
aLanguageGroup
)
{
const
kDefaultFontType
=
"
font
.
default
.
%
LANG
%
"
;
var
defaultFontTypePref
=
kDefaultFontType
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
;
var
preference
=
Preferences
.
get
(
defaultFontTypePref
)
;
if
(
!
preference
)
{
preference
=
Preferences
.
add
(
{
id
:
defaultFontTypePref
type
:
"
string
"
}
)
;
preference
.
on
(
"
change
"
gMainPane
.
_rebuildFonts
.
bind
(
gMainPane
)
)
;
}
return
preference
.
value
;
}
_selectDefaultLanguageGroupPromise
:
Promise
.
resolve
(
)
_selectDefaultLanguageGroup
(
aLanguageGroup
aIsSerif
)
{
this
.
_selectDefaultLanguageGroupPromise
=
(
async
(
)
=
>
{
await
this
.
_selectDefaultLanguageGroupPromise
;
const
kFontNameFmtSerif
=
"
font
.
name
.
serif
.
%
LANG
%
"
;
const
kFontNameFmtSansSerif
=
"
font
.
name
.
sans
-
serif
.
%
LANG
%
"
;
const
kFontNameListFmtSerif
=
"
font
.
name
-
list
.
serif
.
%
LANG
%
"
;
const
kFontNameListFmtSansSerif
=
"
font
.
name
-
list
.
sans
-
serif
.
%
LANG
%
"
;
const
kFontSizeFmtVariable
=
"
font
.
size
.
variable
.
%
LANG
%
"
;
var
prefs
=
[
{
format
:
aIsSerif
?
kFontNameFmtSerif
:
kFontNameFmtSansSerif
type
:
"
fontname
"
element
:
"
defaultFont
"
fonttype
:
aIsSerif
?
"
serif
"
:
"
sans
-
serif
"
}
{
format
:
aIsSerif
?
kFontNameListFmtSerif
:
kFontNameListFmtSansSerif
type
:
"
unichar
"
element
:
null
fonttype
:
aIsSerif
?
"
serif
"
:
"
sans
-
serif
"
}
{
format
:
kFontSizeFmtVariable
type
:
"
int
"
element
:
"
defaultFontSize
"
fonttype
:
null
}
]
;
for
(
var
i
=
0
;
i
<
prefs
.
length
;
+
+
i
)
{
var
preference
=
Preferences
.
get
(
prefs
[
i
]
.
format
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
)
;
if
(
!
preference
)
{
var
name
=
prefs
[
i
]
.
format
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
;
preference
=
Preferences
.
add
(
{
id
:
name
type
:
prefs
[
i
]
.
type
}
)
;
}
if
(
!
prefs
[
i
]
.
element
)
{
continue
;
}
var
element
=
document
.
getElementById
(
prefs
[
i
]
.
element
)
;
if
(
element
)
{
element
.
setAttribute
(
"
preference
"
preference
.
id
)
;
if
(
prefs
[
i
]
.
fonttype
)
{
await
FontBuilder
.
buildFontList
(
aLanguageGroup
prefs
[
i
]
.
fonttype
element
)
;
}
preference
.
setElementValue
(
element
)
;
}
}
}
)
(
)
.
catch
(
console
.
error
)
;
}
onMigrationButtonCommand
(
)
{
const
browserWindow
=
window
.
browsingContext
.
topChromeWindow
;
MigrationUtils
.
showMigrationWizard
(
browserWindow
{
entrypoint
:
MigrationUtils
.
MIGRATION_ENTRYPOINTS
.
PREFERENCES
}
)
;
}
async
showMigrationWizardDialog
(
{
closeTabWhenDone
=
false
}
=
{
}
)
{
let
migrationWizardDialog
=
document
.
getElementById
(
"
migrationWizardDialog
"
)
;
if
(
migrationWizardDialog
.
open
)
{
return
;
}
await
customElements
.
whenDefined
(
"
migration
-
wizard
"
)
;
if
(
!
migrationWizardDialog
.
firstElementChild
)
{
let
wizard
=
document
.
createElement
(
"
migration
-
wizard
"
)
;
wizard
.
toggleAttribute
(
"
dialog
-
mode
"
true
)
;
migrationWizardDialog
.
appendChild
(
wizard
)
;
}
migrationWizardDialog
.
firstElementChild
.
requestState
(
)
;
migrationWizardDialog
.
addEventListener
(
"
close
"
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
migrationWizardDialog
"
MigrationWizard
:
Closed
"
)
;
if
(
closeTabWhenDone
)
{
window
.
close
(
)
;
}
}
{
once
:
true
}
)
;
migrationWizardDialog
.
showModal
(
)
;
}
_storedFullKeyboardNavigation
:
Preferences
.
get
(
"
accessibility
.
tabfocus
"
)
readUseFullKeyboardNavigation
(
)
{
var
pref
=
Preferences
.
get
(
"
accessibility
.
tabfocus
"
)
;
this
.
_storedFullKeyboardNavigation
=
pref
.
value
;
return
pref
.
value
=
=
7
;
}
writeUseFullKeyboardNavigation
(
)
{
var
checkbox
=
document
.
getElementById
(
"
useFullKeyboardNavigation
"
)
;
if
(
checkbox
.
checked
)
{
return
7
;
}
if
(
this
.
_storedFullKeyboardNavigation
!
=
7
)
{
return
this
.
_storedFullKeyboardNavigation
;
}
return
1
;
}
_storedSpellCheck
:
0
readCheckSpelling
(
)
{
var
pref
=
Preferences
.
get
(
"
layout
.
spellcheckDefault
"
)
;
this
.
_storedSpellCheck
=
pref
.
value
;
return
pref
.
value
!
=
0
;
}
writeCheckSpelling
(
)
{
var
checkbox
=
document
.
getElementById
(
"
checkSpelling
"
)
;
if
(
checkbox
.
checked
)
{
if
(
this
.
_storedSpellCheck
=
=
2
)
{
return
2
;
}
return
1
;
}
return
0
;
}
updateDefaultPerformanceSettingsPref
(
)
{
let
defaultPerformancePref
=
Preferences
.
get
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
let
processCountPref
=
Preferences
.
get
(
"
dom
.
ipc
.
processCount
"
)
;
let
accelerationPref
=
Preferences
.
get
(
"
layers
.
acceleration
.
disabled
"
)
;
if
(
processCountPref
.
value
!
=
processCountPref
.
defaultValue
|
|
accelerationPref
.
value
!
=
accelerationPref
.
defaultValue
)
{
defaultPerformancePref
.
value
=
false
;
}
}
updatePerformanceSettingsBox
(
)
{
let
defaultPerformancePref
=
Preferences
.
get
(
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
)
;
let
performanceSettings
=
document
.
getElementById
(
"
performanceSettings
"
)
;
let
processCountPref
=
Preferences
.
get
(
"
dom
.
ipc
.
processCount
"
)
;
if
(
defaultPerformancePref
.
value
)
{
let
accelerationPref
=
Preferences
.
get
(
"
layers
.
acceleration
.
disabled
"
)
;
processCountPref
.
value
=
processCountPref
.
defaultValue
;
accelerationPref
.
value
=
accelerationPref
.
defaultValue
;
performanceSettings
.
hidden
=
true
;
}
else
{
performanceSettings
.
hidden
=
false
;
}
}
buildContentProcessCountMenuList
(
)
{
if
(
Services
.
appinfo
.
fissionAutostart
)
{
document
.
getElementById
(
"
limitContentProcess
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
contentProcessCount
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
contentProcessCountEnabledDescription
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
contentProcessCountDisabledDescription
"
)
.
hidden
=
true
;
return
;
}
if
(
Services
.
appinfo
.
browserTabsRemoteAutostart
)
{
let
processCountPref
=
Preferences
.
get
(
"
dom
.
ipc
.
processCount
"
)
;
let
defaultProcessCount
=
processCountPref
.
defaultValue
;
let
contentProcessCount
=
document
.
querySelector
(
#
contentProcessCount
>
menupopup
>
menuitem
[
value
=
"
{
defaultProcessCount
}
"
]
)
;
document
.
l10n
.
setAttributes
(
contentProcessCount
"
performance
-
default
-
content
-
process
-
count
"
{
num
:
defaultProcessCount
}
)
;
document
.
getElementById
(
"
limitContentProcess
"
)
.
disabled
=
false
;
document
.
getElementById
(
"
contentProcessCount
"
)
.
disabled
=
false
;
document
.
getElementById
(
"
contentProcessCountEnabledDescription
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
contentProcessCountDisabledDescription
"
)
.
hidden
=
true
;
}
else
{
document
.
getElementById
(
"
limitContentProcess
"
)
.
disabled
=
true
;
document
.
getElementById
(
"
contentProcessCount
"
)
.
disabled
=
true
;
document
.
getElementById
(
"
contentProcessCountEnabledDescription
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
contentProcessCountDisabledDescription
"
)
.
hidden
=
false
;
}
}
_minUpdatePrefDisableTime
:
1000
async
readUpdateAutoPref
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
&
&
(
!
Services
.
policies
|
|
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
&
&
!
gIsPackagedApp
)
{
let
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
radiogroup
.
disabled
=
true
;
let
enabled
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
radiogroup
.
value
=
enabled
;
radiogroup
.
disabled
=
false
;
this
.
maybeDisableBackgroundUpdateControls
(
)
;
}
}
async
writeUpdateAutoPref
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
&
&
(
!
Services
.
policies
|
|
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
&
&
!
gIsPackagedApp
)
{
let
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
let
updateAutoValue
=
radiogroup
.
value
=
=
"
true
"
;
let
_disableTimeOverPromise
=
new
Promise
(
r
=
>
setTimeout
(
r
this
.
_minUpdatePrefDisableTime
)
)
;
radiogroup
.
disabled
=
true
;
try
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
updateAutoValue
)
;
await
_disableTimeOverPromise
;
radiogroup
.
disabled
=
false
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
await
Promise
.
all
(
[
this
.
readUpdateAutoPref
(
)
this
.
reportUpdatePrefWriteError
(
)
]
)
;
return
;
}
this
.
maybeDisableBackgroundUpdateControls
(
)
;
if
(
!
updateAutoValue
)
{
await
this
.
checkUpdateInProgress
(
)
;
}
radiogroup
.
dispatchEvent
(
new
CustomEvent
(
"
ProcessedUpdatePrefChange
"
)
)
;
}
}
isBackgroundUpdateUIAvailable
(
)
{
return
(
AppConstants
.
MOZ_UPDATE_AGENT
&
&
UpdateUtils
.
PER_INSTALLATION_PREFS_SUPPORTED
&
&
(
!
Services
.
policies
|
|
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
&
&
!
gIsPackagedApp
&
&
!
UpdateUtils
.
appUpdateSettingIsLocked
(
"
app
.
update
.
background
.
enabled
"
)
)
;
}
maybeDisableBackgroundUpdateControls
(
)
{
if
(
this
.
isBackgroundUpdateUIAvailable
(
)
)
{
let
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
let
updateAutoEnabled
=
radiogroup
.
value
=
=
"
true
"
;
document
.
getElementById
(
"
backgroundUpdate
"
)
.
disabled
=
!
updateAutoEnabled
;
}
}
async
readBackgroundUpdatePref
(
)
{
const
prefName
=
"
app
.
update
.
background
.
enabled
"
;
if
(
this
.
isBackgroundUpdateUIAvailable
(
)
)
{
let
backgroundCheckbox
=
document
.
getElementById
(
"
backgroundUpdate
"
)
;
backgroundCheckbox
.
disabled
=
true
;
await
BackgroundUpdate
.
ensureExperimentToRolloutTransitionPerformed
(
)
;
let
enabled
=
await
UpdateUtils
.
readUpdateConfigSetting
(
prefName
)
;
backgroundCheckbox
.
checked
=
enabled
;
this
.
maybeDisableBackgroundUpdateControls
(
)
;
}
}
async
writeBackgroundUpdatePref
(
)
{
const
prefName
=
"
app
.
update
.
background
.
enabled
"
;
if
(
this
.
isBackgroundUpdateUIAvailable
(
)
)
{
let
backgroundCheckbox
=
document
.
getElementById
(
"
backgroundUpdate
"
)
;
backgroundCheckbox
.
disabled
=
true
;
let
backgroundUpdateEnabled
=
backgroundCheckbox
.
checked
;
try
{
await
UpdateUtils
.
writeUpdateConfigSetting
(
prefName
backgroundUpdateEnabled
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
await
this
.
readBackgroundUpdatePref
(
)
;
await
this
.
reportUpdatePrefWriteError
(
)
;
return
;
}
this
.
maybeDisableBackgroundUpdateControls
(
)
;
}
}
async
reportUpdatePrefWriteError
(
)
{
let
[
title
message
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
update
-
setting
-
write
-
failure
-
title2
"
}
{
id
:
"
update
-
setting
-
write
-
failure
-
message2
"
args
:
{
path
:
UpdateUtils
.
configFilePath
}
}
]
)
;
let
buttonFlags
=
Services
.
prompt
.
BUTTON_POS_0
*
Services
.
prompt
.
BUTTON_TITLE_OK
;
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
null
null
null
null
{
}
)
;
}
async
checkUpdateInProgress
(
)
{
const
aus
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationUpdateService
)
;
let
um
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
;
await
aus
.
init
(
)
;
if
(
aus
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
{
return
;
}
let
[
title
message
okButton
cancelButton
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
update
-
in
-
progress
-
title
"
}
{
id
:
"
update
-
in
-
progress
-
message
"
}
{
id
:
"
update
-
in
-
progress
-
ok
-
button
"
}
{
id
:
"
update
-
in
-
progress
-
cancel
-
button
"
}
]
)
;
let
buttonFlags
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
+
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
+
Ci
.
nsIPrompt
.
BUTTON_POS_1_DEFAULT
;
let
rv
=
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
if
(
rv
!
=
1
)
{
await
aus
.
stopDownload
(
)
;
await
um
.
cleanupActiveUpdates
(
)
;
UpdateListener
.
clearPendingAndActiveNotifications
(
)
;
}
}
showUpdates
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
update
/
history
.
xhtml
"
)
;
}
destroy
(
)
{
window
.
removeEventListener
(
"
unload
"
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_CONTAINERS_EXTENSION
this
)
;
Services
.
obs
.
removeObserver
(
this
AUTO_UPDATE_CHANGED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
BACKGROUND_UPDATE_CHANGED_TOPIC
)
;
AppearanceChooser
.
destroy
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
async
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
if
(
aData
=
=
PREF_CONTAINERS_EXTENSION
)
{
this
.
readBrowserContainersCheckbox
(
)
;
return
;
}
if
(
!
this
.
_storingAction
)
{
await
this
.
_rebuildView
(
)
;
}
}
else
if
(
aTopic
=
=
AUTO_UPDATE_CHANGED_TOPIC
)
{
if
(
!
AppConstants
.
MOZ_UPDATER
)
{
return
;
}
if
(
aData
!
=
"
true
"
&
&
aData
!
=
"
false
"
)
{
throw
new
Error
(
"
Invalid
preference
value
for
app
.
update
.
auto
"
)
;
}
document
.
getElementById
(
"
updateRadioGroup
"
)
.
value
=
aData
;
this
.
maybeDisableBackgroundUpdateControls
(
)
;
}
else
if
(
aTopic
=
=
BACKGROUND_UPDATE_CHANGED_TOPIC
)
{
if
(
!
AppConstants
.
MOZ_UPDATE_AGENT
)
{
return
;
}
if
(
aData
!
=
"
true
"
&
&
aData
!
=
"
false
"
)
{
throw
new
Error
(
"
Invalid
preference
value
for
app
.
update
.
background
.
enabled
"
)
;
}
document
.
getElementById
(
"
backgroundUpdate
"
)
.
checked
=
aData
=
=
"
true
"
;
}
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
=
=
"
unload
"
)
{
this
.
destroy
(
)
;
if
(
AppConstants
.
MOZ_UPDATER
)
{
onUnload
(
)
;
}
}
}
_loadData
(
)
{
this
.
_loadInternalHandlers
(
)
;
this
.
_loadApplicationHandlers
(
)
;
}
_loadInternalHandlers
(
)
{
let
internalHandlers
=
[
new
PDFHandlerInfoWrapper
(
)
]
;
let
enabledHandlers
=
Services
.
prefs
.
getCharPref
(
"
browser
.
download
.
viewableInternally
.
enabledTypes
"
"
"
)
.
trim
(
)
;
if
(
enabledHandlers
)
{
for
(
let
ext
of
enabledHandlers
.
split
(
"
"
)
)
{
internalHandlers
.
push
(
new
ViewableInternallyHandlerInfoWrapper
(
null
ext
.
trim
(
)
)
)
;
}
}
for
(
let
internalHandler
of
internalHandlers
)
{
if
(
internalHandler
.
enabled
)
{
this
.
_handledTypes
[
internalHandler
.
type
]
=
internalHandler
;
}
}
}
_loadApplicationHandlers
(
)
{
for
(
let
wrappedHandlerInfo
of
gHandlerService
.
enumerate
(
)
)
{
let
type
=
wrappedHandlerInfo
.
type
;
let
handlerInfoWrapper
;
if
(
type
in
this
.
_handledTypes
)
{
handlerInfoWrapper
=
this
.
_handledTypes
[
type
]
;
}
else
{
if
(
DownloadIntegration
.
shouldViewDownloadInternally
(
type
)
)
{
handlerInfoWrapper
=
new
ViewableInternallyHandlerInfoWrapper
(
type
)
;
}
else
{
handlerInfoWrapper
=
new
HandlerInfoWrapper
(
type
wrappedHandlerInfo
)
;
}
this
.
_handledTypes
[
type
]
=
handlerInfoWrapper
;
}
}
}
selectedHandlerListItem
:
null
_initListEventHandlers
(
)
{
this
.
_list
.
addEventListener
(
"
select
"
event
=
>
{
if
(
event
.
target
!
=
this
.
_list
)
{
return
;
}
let
handlerListItem
=
this
.
_list
.
selectedItem
&
&
HandlerListItem
.
forNode
(
this
.
_list
.
selectedItem
)
;
if
(
this
.
selectedHandlerListItem
=
=
handlerListItem
)
{
return
;
}
if
(
this
.
selectedHandlerListItem
)
{
this
.
selectedHandlerListItem
.
showActionsMenu
=
false
;
}
this
.
selectedHandlerListItem
=
handlerListItem
;
if
(
handlerListItem
)
{
this
.
rebuildActionsMenu
(
)
;
handlerListItem
.
showActionsMenu
=
true
;
}
}
)
;
}
async
_rebuildVisibleTypes
(
)
{
this
.
_visibleTypes
=
[
]
;
let
visibleDescriptions
=
new
Map
(
)
;
for
(
let
type
in
this
.
_handledTypes
)
{
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
let
handlerInfo
=
this
.
_handledTypes
[
type
]
;
this
.
_visibleTypes
.
push
(
handlerInfo
)
;
let
key
=
JSON
.
stringify
(
handlerInfo
.
description
)
;
let
otherHandlerInfo
=
visibleDescriptions
.
get
(
key
)
;
if
(
!
otherHandlerInfo
)
{
handlerInfo
.
disambiguateDescription
=
false
;
visibleDescriptions
.
set
(
key
handlerInfo
)
;
}
else
{
handlerInfo
.
disambiguateDescription
=
true
;
otherHandlerInfo
.
disambiguateDescription
=
true
;
}
}
}
async
_rebuildView
(
)
{
let
lastSelectedType
=
this
.
selectedHandlerListItem
&
&
this
.
selectedHandlerListItem
.
handlerInfoWrapper
.
type
;
this
.
selectedHandlerListItem
=
null
;
this
.
_list
.
textContent
=
"
"
;
var
visibleTypes
=
this
.
_visibleTypes
;
let
items
=
visibleTypes
.
map
(
visibleType
=
>
new
HandlerListItem
(
visibleType
)
)
;
let
itemsFragment
=
document
.
createDocumentFragment
(
)
;
let
lastSelectedItem
;
for
(
let
item
of
items
)
{
item
.
createNode
(
itemsFragment
)
;
if
(
item
.
handlerInfoWrapper
.
type
=
=
lastSelectedType
)
{
lastSelectedItem
=
item
;
}
}
for
(
let
item
of
items
)
{
item
.
setupNode
(
)
;
this
.
rebuildActionsMenu
(
item
.
node
item
.
handlerInfoWrapper
)
;
item
.
refreshAction
(
)
;
}
if
(
this
.
_filter
.
value
)
{
await
document
.
l10n
.
translateFragment
(
itemsFragment
)
;
this
.
_filterView
(
itemsFragment
)
;
document
.
l10n
.
pauseObserving
(
)
;
this
.
_list
.
appendChild
(
itemsFragment
)
;
document
.
l10n
.
resumeObserving
(
)
;
}
else
{
this
.
_list
.
appendChild
(
itemsFragment
)
;
}
if
(
lastSelectedItem
)
{
this
.
_list
.
selectedItem
=
lastSelectedItem
.
node
;
}
}
isValidHandlerApp
(
aHandlerApp
)
{
if
(
!
aHandlerApp
)
{
return
false
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
{
return
this
.
_isValidHandlerExecutable
(
aHandlerApp
.
executable
)
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
{
return
aHandlerApp
.
uriTemplate
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIGIOMimeApp
)
{
return
aHandlerApp
.
command
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIGIOHandlerApp
)
{
return
aHandlerApp
.
id
;
}
return
false
;
}
_isValidHandlerExecutable
(
aExecutable
)
{
let
leafName
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
leafName
=
{
AppConstants
.
MOZ_APP_NAME
}
.
exe
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
leafName
=
AppConstants
.
MOZ_MACBUNDLE_NAME
;
}
else
{
leafName
=
{
AppConstants
.
MOZ_APP_NAME
}
-
bin
;
}
return
(
aExecutable
&
&
aExecutable
.
exists
(
)
&
&
aExecutable
.
isExecutable
(
)
&
&
aExecutable
.
leafName
!
=
leafName
)
;
}
rebuildActionsMenu
(
typeItem
=
this
.
_list
.
selectedItem
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
)
{
var
menu
=
typeItem
.
querySelector
(
"
.
actionsMenu
"
)
;
var
menuPopup
=
menu
.
menupopup
;
while
(
menuPopup
.
hasChildNodes
(
)
)
{
menuPopup
.
removeChild
(
menuPopup
.
lastChild
)
;
}
let
internalMenuItem
;
if
(
handlerInfo
instanceof
InternalHandlerInfoWrapper
&
&
!
handlerInfo
.
preventInternalViewing
)
{
internalMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
internalMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
handleInternally
)
;
document
.
l10n
.
setAttributes
(
internalMenuItem
"
applications
-
open
-
inapp
"
)
;
internalMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
handleInternally
"
)
;
menuPopup
.
appendChild
(
internalMenuItem
)
;
}
var
askMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
askMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
alwaysAsk
)
;
document
.
l10n
.
setAttributes
(
askMenuItem
"
applications
-
always
-
ask
"
)
;
askMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
ask
"
)
;
menuPopup
.
appendChild
(
askMenuItem
)
;
if
(
handlerInfo
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
{
var
saveMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
saveMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
saveToDisk
)
;
document
.
l10n
.
setAttributes
(
saveMenuItem
"
applications
-
action
-
save
"
)
;
saveMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
save
"
)
;
menuPopup
.
appendChild
(
saveMenuItem
)
;
}
let
menuseparator
=
document
.
createXULElement
(
"
menuseparator
"
)
;
menuPopup
.
appendChild
(
menuseparator
)
;
if
(
handlerInfo
.
hasDefaultHandler
)
{
var
defaultMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
defaultMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useSystemDefault
)
;
if
(
internalMenuItem
)
{
document
.
l10n
.
setAttributes
(
defaultMenuItem
"
applications
-
use
-
os
-
default
"
)
;
defaultMenuItem
.
setAttribute
(
"
image
"
ICON_URL_APP
)
;
}
else
{
document
.
l10n
.
setAttributes
(
defaultMenuItem
"
applications
-
use
-
app
-
default
"
{
"
app
-
name
"
:
handlerInfo
.
defaultDescription
}
)
;
defaultMenuItem
.
setAttribute
(
"
image
"
handlerInfo
.
iconURLForSystemDefault
)
;
}
menuPopup
.
appendChild
(
defaultMenuItem
)
;
}
let
preferredApp
=
handlerInfo
.
preferredApplicationHandler
;
var
possibleAppMenuItems
=
[
]
;
for
(
let
possibleApp
of
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
)
)
{
if
(
!
this
.
isValidHandlerApp
(
possibleApp
)
)
{
continue
;
}
let
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
let
label
;
if
(
possibleApp
instanceof
Ci
.
nsILocalHandlerApp
)
{
label
=
getFileDisplayName
(
possibleApp
.
executable
)
;
}
else
{
label
=
possibleApp
.
name
;
}
document
.
l10n
.
setAttributes
(
menuItem
"
applications
-
use
-
app
"
{
"
app
-
name
"
:
label
}
)
;
menuItem
.
setAttribute
(
"
image
"
this
.
_getIconURLForHandlerApp
(
possibleApp
)
)
;
menuItem
.
handlerApp
=
possibleApp
;
menuPopup
.
appendChild
(
menuItem
)
;
possibleAppMenuItems
.
push
(
menuItem
)
;
}
if
(
gGIOService
)
{
var
gioApps
=
gGIOService
.
getAppsForURIScheme
(
handlerInfo
.
type
)
;
let
possibleHandlers
=
handlerInfo
.
possibleApplicationHandlers
;
for
(
let
handler
of
gioApps
.
enumerate
(
Ci
.
nsIHandlerApp
)
)
{
if
(
handler
.
name
=
=
handlerInfo
.
defaultDescription
)
{
continue
;
}
let
appAlreadyInHandlers
=
false
;
for
(
let
i
=
possibleHandlers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
app
=
possibleHandlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
equals
(
app
)
)
{
appAlreadyInHandlers
=
true
;
break
;
}
}
if
(
!
appAlreadyInHandlers
)
{
let
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
document
.
l10n
.
setAttributes
(
menuItem
"
applications
-
use
-
app
"
{
"
app
-
name
"
:
handler
.
name
}
)
;
menuItem
.
setAttribute
(
"
image
"
this
.
_getIconURLForHandlerApp
(
handler
)
)
;
menuItem
.
handlerApp
=
handler
;
menuPopup
.
appendChild
(
menuItem
)
;
possibleAppMenuItems
.
push
(
menuItem
)
;
}
}
}
let
canOpenWithOtherApp
=
true
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
executableType
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
.
getTypeFromExtension
(
"
exe
"
)
;
canOpenWithOtherApp
=
handlerInfo
.
type
!
=
executableType
;
}
if
(
canOpenWithOtherApp
)
{
let
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
className
=
"
choose
-
app
-
item
"
;
menuItem
.
addEventListener
(
"
command
"
function
(
e
)
{
gMainPane
.
chooseApp
(
e
)
;
}
)
;
document
.
l10n
.
setAttributes
(
menuItem
"
applications
-
use
-
other
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
}
if
(
possibleAppMenuItems
.
length
)
{
let
menuItem
=
document
.
createXULElement
(
"
menuseparator
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
className
=
"
manage
-
app
-
item
"
;
menuItem
.
addEventListener
(
"
command
"
function
(
e
)
{
gMainPane
.
manageApp
(
e
)
;
}
)
;
document
.
l10n
.
setAttributes
(
menuItem
"
applications
-
manage
-
app
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
}
if
(
handlerInfo
.
alwaysAskBeforeHandling
)
{
menu
.
selectedItem
=
askMenuItem
;
}
else
{
const
kActionUsePlugin
=
5
;
switch
(
handlerInfo
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
internalMenuItem
)
{
menu
.
selectedItem
=
internalMenuItem
;
}
else
{
console
.
error
(
"
No
menu
item
defined
to
set
!
"
)
;
}
break
;
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
menu
.
selectedItem
=
defaultMenuItem
|
|
askMenuItem
;
break
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
if
(
preferredApp
)
{
let
preferredItem
=
possibleAppMenuItems
.
find
(
v
=
>
v
.
handlerApp
.
equals
(
preferredApp
)
)
;
if
(
preferredItem
)
{
menu
.
selectedItem
=
preferredItem
;
}
else
{
let
possible
=
possibleAppMenuItems
.
map
(
v
=
>
v
.
handlerApp
&
&
v
.
handlerApp
.
name
)
.
join
(
"
"
)
;
console
.
error
(
new
Error
(
Preferred
handler
for
{
handlerInfo
.
type
}
not
in
list
of
possible
handlers
!
?
(
List
:
{
possible
}
)
)
)
;
menu
.
selectedItem
=
askMenuItem
;
}
}
break
;
case
kActionUsePlugin
:
menu
.
selectedItem
=
askMenuItem
;
break
;
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
menu
.
selectedItem
=
saveMenuItem
;
break
;
}
}
}
_sortColumn
:
null
sort
(
event
)
{
if
(
event
.
button
!
=
0
)
{
return
;
}
var
column
=
event
.
target
;
if
(
this
.
_sortColumn
&
&
this
.
_sortColumn
!
=
column
)
{
this
.
_sortColumn
.
removeAttribute
(
"
sortDirection
"
)
;
}
this
.
_sortColumn
=
column
;
if
(
column
.
getAttribute
(
"
sortDirection
"
)
=
=
"
ascending
"
)
{
column
.
setAttribute
(
"
sortDirection
"
"
descending
"
)
;
}
else
{
column
.
setAttribute
(
"
sortDirection
"
"
ascending
"
)
;
}
this
.
_sortListView
(
)
;
}
async
_sortListView
(
)
{
if
(
!
this
.
_sortColumn
)
{
return
;
}
let
comp
=
new
Services
.
intl
.
Collator
(
undefined
{
usage
:
"
sort
"
}
)
;
await
document
.
l10n
.
translateFragment
(
this
.
_list
)
;
let
items
=
Array
.
from
(
this
.
_list
.
children
)
;
let
textForNode
;
if
(
this
.
_sortColumn
.
getAttribute
(
"
value
"
)
=
=
=
"
type
"
)
{
textForNode
=
n
=
>
n
.
querySelector
(
"
.
typeDescription
"
)
.
textContent
;
}
else
{
textForNode
=
n
=
>
n
.
querySelector
(
"
.
actionsMenu
"
)
.
getAttribute
(
"
label
"
)
;
}
let
sortDir
=
this
.
_sortColumn
.
getAttribute
(
"
sortDirection
"
)
;
let
multiplier
=
sortDir
=
=
"
descending
"
?
-
1
:
1
;
items
.
sort
(
(
a
b
)
=
>
multiplier
*
comp
.
compare
(
textForNode
(
a
)
textForNode
(
b
)
)
)
;
items
.
forEach
(
item
=
>
this
.
_list
.
appendChild
(
item
)
)
;
}
_filterView
(
frag
=
this
.
_list
)
{
const
filterValue
=
this
.
_filter
.
value
.
toLowerCase
(
)
;
for
(
let
elem
of
frag
.
children
)
{
const
typeDescription
=
elem
.
querySelector
(
"
.
typeDescription
"
)
.
textContent
;
const
actionDescription
=
elem
.
querySelector
(
"
.
actionDescription
"
)
.
getAttribute
(
"
value
"
)
;
elem
.
hidden
=
!
typeDescription
.
toLowerCase
(
)
.
includes
(
filterValue
)
&
&
!
actionDescription
.
toLowerCase
(
)
.
includes
(
filterValue
)
;
}
}
filter
(
)
{
this
.
_rebuildView
(
)
;
}
focusFilterBox
(
)
{
this
.
_filter
.
focus
(
)
;
this
.
_filter
.
select
(
)
;
}
_storingAction
:
false
onSelectAction
(
aActionItem
)
{
this
.
_storingAction
=
true
;
try
{
this
.
_storeAction
(
aActionItem
)
;
}
finally
{
this
.
_storingAction
=
false
;
}
}
_storeAction
(
aActionItem
)
{
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
let
action
=
parseInt
(
aActionItem
.
getAttribute
(
"
action
"
)
)
;
if
(
action
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
)
{
handlerInfo
.
preferredApplicationHandler
=
aActionItem
.
handlerApp
;
}
if
(
action
=
=
Ci
.
nsIHandlerInfo
.
alwaysAsk
)
{
handlerInfo
.
alwaysAskBeforeHandling
=
true
;
}
else
{
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
}
handlerInfo
.
preferredAction
=
action
;
handlerInfo
.
store
(
)
;
this
.
selectedHandlerListItem
.
refreshAction
(
)
;
}
manageApp
(
aEvent
)
{
aEvent
.
stopPropagation
(
)
;
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
let
onComplete
=
(
)
=
>
{
this
.
rebuildActionsMenu
(
)
;
this
.
selectedHandlerListItem
.
refreshAction
(
)
;
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
applicationManager
.
xhtml
"
{
features
:
"
resizable
=
no
"
closingCallback
:
onComplete
}
handlerInfo
)
;
}
async
chooseApp
(
aEvent
)
{
aEvent
.
stopPropagation
(
)
;
var
handlerApp
;
let
chooseAppCallback
=
aHandlerApp
=
>
{
this
.
rebuildActionsMenu
(
)
;
if
(
aHandlerApp
)
{
let
typeItem
=
this
.
_list
.
selectedItem
;
let
actionsMenu
=
typeItem
.
querySelector
(
"
.
actionsMenu
"
)
;
let
menuItems
=
actionsMenu
.
menupopup
.
childNodes
;
for
(
let
i
=
0
;
i
<
menuItems
.
length
;
i
+
+
)
{
let
menuItem
=
menuItems
[
i
]
;
if
(
menuItem
.
handlerApp
&
&
menuItem
.
handlerApp
.
equals
(
aHandlerApp
)
)
{
actionsMenu
.
selectedIndex
=
i
;
this
.
onSelectAction
(
menuItem
)
;
break
;
}
}
}
}
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
var
params
=
{
}
;
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
params
.
mimeInfo
=
handlerInfo
.
wrappedHandlerInfo
;
params
.
title
=
await
document
.
l10n
.
formatValue
(
"
applications
-
select
-
helper
"
)
;
if
(
"
id
"
in
handlerInfo
.
description
)
{
params
.
description
=
await
document
.
l10n
.
formatValue
(
handlerInfo
.
description
.
id
handlerInfo
.
description
.
args
)
;
}
else
{
params
.
description
=
handlerInfo
.
typeDescription
.
raw
;
}
params
.
filename
=
null
;
params
.
handlerApp
=
null
;
let
onAppSelected
=
(
)
=
>
{
if
(
this
.
isValidHandlerApp
(
params
.
handlerApp
)
)
{
handlerApp
=
params
.
handlerApp
;
handlerInfo
.
addPossibleApplicationHandler
(
handlerApp
)
;
}
chooseAppCallback
(
handlerApp
)
;
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
global
/
content
/
appPicker
.
xhtml
"
{
closingCallback
:
onAppSelected
}
params
)
;
}
else
{
let
winTitle
=
await
document
.
l10n
.
formatValue
(
"
applications
-
select
-
helper
"
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
fpCallback
=
aResult
=
>
{
if
(
aResult
=
=
Ci
.
nsIFilePicker
.
returnOK
&
&
fp
.
file
&
&
this
.
_isValidHandlerExecutable
(
fp
.
file
)
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
name
=
getFileDisplayName
(
fp
.
file
)
;
handlerApp
.
executable
=
fp
.
file
;
let
handler
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
handler
.
addPossibleApplicationHandler
(
handlerApp
)
;
chooseAppCallback
(
handlerApp
)
;
}
}
;
fp
.
init
(
window
.
browsingContext
winTitle
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterApps
)
;
fp
.
open
(
fpCallback
)
;
}
}
_getIconURLForHandlerApp
(
aHandlerApp
)
{
if
(
aHandlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
{
return
this
.
_getIconURLForFile
(
aHandlerApp
.
executable
)
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
{
return
this
.
_getIconURLForWebApp
(
aHandlerApp
.
uriTemplate
)
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIGIOHandlerApp
)
{
return
this
.
_getIconURLForAppId
(
aHandlerApp
.
id
)
;
}
return
"
"
;
}
_getIconURLForAppId
(
aAppId
)
{
return
"
moz
-
icon
:
/
/
"
+
aAppId
+
"
?
size
=
16
"
;
}
_getIconURLForFile
(
aFile
)
{
var
fph
=
Services
.
io
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
var
urlSpec
=
fph
.
getURLSpecFromActualFile
(
aFile
)
;
return
"
moz
-
icon
:
/
/
"
+
urlSpec
+
"
?
size
=
16
"
;
}
_getIconURLForWebApp
(
aWebAppURITemplate
)
{
var
uri
=
Services
.
io
.
newURI
(
aWebAppURITemplate
)
;
if
(
/
^
https
?
/
.
test
(
uri
.
scheme
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
chrome
.
site_icons
"
)
)
{
return
uri
.
prePath
+
"
/
favicon
.
ico
"
;
}
return
"
"
;
}
readUseDownloadDir
(
)
{
document
.
getElementById
(
"
downloadFolder
"
)
.
disabled
=
document
.
getElementById
(
"
chooseFolder
"
)
.
disabled
=
document
.
getElementById
(
"
saveTo
"
)
.
disabled
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
.
locked
|
|
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
.
locked
;
return
undefined
;
}
chooseFolder
(
)
{
return
this
.
chooseFolderTask
(
)
.
catch
(
console
.
error
)
;
}
async
chooseFolderTask
(
)
{
let
[
title
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
choose
-
download
-
folder
-
title
"
}
]
)
;
let
folderListPref
=
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
;
let
currentDirPref
=
await
this
.
_indexToFolder
(
folderListPref
.
value
)
;
let
defDownloads
=
await
this
.
_indexToFolder
(
1
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
.
browsingContext
title
Ci
.
nsIFilePicker
.
modeGetFolder
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterAll
)
;
if
(
currentDirPref
&
&
currentDirPref
.
exists
(
)
)
{
fp
.
displayDirectory
=
currentDirPref
;
}
else
if
(
defDownloads
&
&
defDownloads
.
exists
(
)
)
{
fp
.
displayDirectory
=
defDownloads
;
}
else
{
fp
.
displayDirectory
=
await
this
.
_indexToFolder
(
0
)
;
}
let
result
=
await
new
Promise
(
resolve
=
>
fp
.
open
(
resolve
)
)
;
if
(
result
!
=
Ci
.
nsIFilePicker
.
returnOK
)
{
return
;
}
let
downloadDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
downloadDirPref
.
value
=
fp
.
file
;
folderListPref
.
value
=
await
this
.
_folderToIndex
(
fp
.
file
)
;
}
displayDownloadDirPref
(
)
{
this
.
displayDownloadDirPrefTask
(
)
.
catch
(
console
.
error
)
;
return
undefined
;
}
async
displayDownloadDirPrefTask
(
)
{
let
token
=
{
}
;
this
.
_downloadDisplayToken
=
token
;
var
downloadFolder
=
document
.
getElementById
(
"
downloadFolder
"
)
;
let
folderIndex
=
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
.
value
;
if
(
folderIndex
=
=
3
)
{
let
currentDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
folderIndex
=
currentDirPref
.
value
?
await
this
.
_folderToIndex
(
currentDirPref
.
value
)
:
1
;
}
let
{
folderDisplayName
file
}
=
await
this
.
_getSystemDownloadFolderDetails
(
folderIndex
)
;
let
fph
=
Services
.
io
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
let
iconUrlSpec
=
fph
.
getURLSpecFromDir
(
file
)
;
if
(
this
.
_downloadDisplayToken
!
=
token
)
{
return
;
}
downloadFolder
.
value
=
folderDisplayName
;
downloadFolder
.
style
.
backgroundImage
=
"
url
(
moz
-
icon
:
/
/
"
+
iconUrlSpec
+
"
?
size
=
16
)
"
;
}
async
_getSystemDownloadFolderDetails
(
folderIndex
)
{
let
downloadsDir
=
await
this
.
_getDownloadsFolder
(
"
Downloads
"
)
;
let
desktopDir
=
await
this
.
_getDownloadsFolder
(
"
Desktop
"
)
;
let
currentDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
let
file
;
let
firefoxLocalizedName
;
if
(
folderIndex
=
=
2
&
&
currentDirPref
.
value
)
{
file
=
currentDirPref
.
value
;
if
(
file
.
equals
(
downloadsDir
)
)
{
folderIndex
=
1
;
}
else
if
(
file
.
equals
(
desktopDir
)
)
{
folderIndex
=
0
;
}
}
switch
(
folderIndex
)
{
case
2
:
break
;
case
1
:
{
file
=
downloadsDir
;
firefoxLocalizedName
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
downloads
-
folder
-
name
"
}
]
)
;
break
;
}
case
0
:
default
:
{
file
=
desktopDir
;
firefoxLocalizedName
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
desktop
-
folder
-
name
"
}
]
)
;
}
}
if
(
file
)
{
let
displayName
=
file
.
path
;
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
try
{
displayName
=
await
file
.
hostPath
(
)
;
}
catch
(
error
)
{
}
if
(
displayName
)
{
if
(
displayName
=
=
downloadsDir
.
path
)
{
firefoxLocalizedName
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
downloads
-
folder
-
name
"
}
]
)
;
}
else
if
(
displayName
=
=
desktopDir
.
path
)
{
firefoxLocalizedName
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
desktop
-
folder
-
name
"
}
]
)
;
}
}
}
if
(
firefoxLocalizedName
)
{
let
folderDisplayName
leafName
;
try
{
folderDisplayName
=
file
.
displayName
;
}
catch
(
ex
)
{
}
try
{
leafName
=
file
.
leafName
;
}
catch
(
ex
)
{
}
if
(
folderDisplayName
&
&
folderDisplayName
!
=
leafName
)
{
return
{
file
folderDisplayName
}
;
}
if
(
firefoxLocalizedName
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
leafName
=
=
firefoxLocalizedName
)
{
return
{
file
folderDisplayName
:
firefoxLocalizedName
}
;
}
}
}
return
{
file
folderDisplayName
:
\
u2066
{
displayName
}
\
u2069
}
;
}
file
=
desktopDir
;
return
{
file
folderDisplayName
:
"
"
}
;
}
async
_getDownloadsFolder
(
aFolder
)
{
switch
(
aFolder
)
{
case
"
Desktop
"
:
return
Services
.
dirsvc
.
get
(
"
Desk
"
Ci
.
nsIFile
)
;
case
"
Downloads
"
:
let
downloadsDir
=
await
Downloads
.
getSystemDownloadsDirectory
(
)
;
return
new
FileUtils
.
File
(
downloadsDir
)
;
}
throw
new
Error
(
"
ASSERTION
FAILED
:
folder
type
should
be
'
Desktop
'
or
'
Downloads
'
"
)
;
}
async
_folderToIndex
(
aFolder
)
{
if
(
!
aFolder
|
|
aFolder
.
equals
(
await
this
.
_getDownloadsFolder
(
"
Desktop
"
)
)
)
{
return
0
;
}
else
if
(
aFolder
.
equals
(
await
this
.
_getDownloadsFolder
(
"
Downloads
"
)
)
)
{
return
1
;
}
return
2
;
}
_indexToFolder
(
aIndex
)
{
switch
(
aIndex
)
{
case
0
:
return
this
.
_getDownloadsFolder
(
"
Desktop
"
)
;
case
1
:
return
this
.
_getDownloadsFolder
(
"
Downloads
"
)
;
}
var
currentDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
return
currentDirPref
.
value
;
}
}
;
gMainPane
.
initialized
=
new
Promise
(
res
=
>
{
gMainPane
.
setInitialized
=
res
;
}
)
;
function
getFileDisplayName
(
file
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileWin
)
{
try
{
return
file
.
getVersionInfoField
(
"
FileDescription
"
)
;
}
catch
(
e
)
{
}
}
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileMac
)
{
try
{
return
file
.
bundleDisplayName
;
}
catch
(
e
)
{
}
}
}
return
file
.
leafName
;
}
function
getLocalHandlerApp
(
aFile
)
{
var
localHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandlerApp
.
name
=
getFileDisplayName
(
aFile
)
;
localHandlerApp
.
executable
=
aFile
;
return
localHandlerApp
;
}
let
gHandlerListItemFragment
=
MozXULElement
.
parseXULToFragment
(
<
richlistitem
>
<
hbox
class
=
"
typeContainer
"
flex
=
"
1
"
align
=
"
center
"
>
<
image
class
=
"
typeIcon
"
width
=
"
16
"
height
=
"
16
"
src
=
"
moz
-
icon
:
/
/
goat
?
size
=
16
"
/
>
<
label
class
=
"
typeDescription
"
flex
=
"
1
"
crop
=
"
end
"
/
>
<
/
hbox
>
<
hbox
class
=
"
actionContainer
"
flex
=
"
1
"
align
=
"
center
"
>
<
image
class
=
"
actionIcon
"
width
=
"
16
"
height
=
"
16
"
/
>
<
label
class
=
"
actionDescription
"
flex
=
"
1
"
crop
=
"
end
"
/
>
<
/
hbox
>
<
hbox
class
=
"
actionsMenuContainer
"
flex
=
"
1
"
>
<
menulist
class
=
"
actionsMenu
"
flex
=
"
1
"
crop
=
"
end
"
selectedIndex
=
"
1
"
aria
-
labelledby
=
"
actionColumn
"
>
<
menupopup
/
>
<
/
menulist
>
<
/
hbox
>
<
/
richlistitem
>
)
;
class
HandlerListItem
{
static
forNode
(
node
)
{
return
gNodeToObjectMap
.
get
(
node
)
;
}
constructor
(
handlerInfoWrapper
)
{
this
.
handlerInfoWrapper
=
handlerInfoWrapper
;
}
setOrRemoveAttributes
(
iterable
)
{
for
(
let
[
selector
name
value
]
of
iterable
)
{
let
node
=
selector
?
this
.
node
.
querySelector
(
selector
)
:
this
.
node
;
if
(
value
)
{
node
.
setAttribute
(
name
value
)
;
}
else
{
node
.
removeAttribute
(
name
)
;
}
}
}
createNode
(
list
)
{
list
.
appendChild
(
document
.
importNode
(
gHandlerListItemFragment
true
)
)
;
this
.
node
=
list
.
lastChild
;
gNodeToObjectMap
.
set
(
this
.
node
this
)
;
}
setupNode
(
)
{
this
.
node
.
querySelector
(
"
.
actionsMenu
"
)
.
addEventListener
(
"
command
"
event
=
>
gMainPane
.
onSelectAction
(
event
.
originalTarget
)
)
;
let
typeDescription
=
this
.
handlerInfoWrapper
.
typeDescription
;
this
.
setOrRemoveAttributes
(
[
[
null
"
type
"
this
.
handlerInfoWrapper
.
type
]
[
"
.
typeIcon
"
"
src
"
this
.
handlerInfoWrapper
.
smallIcon
]
]
)
;
localizeElement
(
this
.
node
.
querySelector
(
"
.
typeDescription
"
)
typeDescription
)
;
this
.
showActionsMenu
=
false
;
}
refreshAction
(
)
{
let
{
actionIconClass
}
=
this
.
handlerInfoWrapper
;
this
.
setOrRemoveAttributes
(
[
[
null
APP_ICON_ATTR_NAME
actionIconClass
]
[
"
.
actionIcon
"
"
src
"
actionIconClass
?
null
:
this
.
handlerInfoWrapper
.
actionIcon
]
]
)
;
const
selectedItem
=
this
.
node
.
querySelector
(
"
[
selected
=
true
]
"
)
;
if
(
!
selectedItem
)
{
console
.
error
(
"
No
selected
item
for
"
+
this
.
handlerInfoWrapper
.
type
)
;
return
;
}
const
{
id
args
}
=
document
.
l10n
.
getAttributes
(
selectedItem
)
;
localizeElement
(
this
.
node
.
querySelector
(
"
.
actionDescription
"
)
{
id
:
id
+
"
-
label
"
args
}
)
;
localizeElement
(
this
.
node
.
querySelector
(
"
.
actionsMenu
"
)
{
id
args
}
)
;
}
set
showActionsMenu
(
value
)
{
this
.
setOrRemoveAttributes
(
[
[
"
.
actionContainer
"
"
hidden
"
value
]
[
"
.
actionsMenuContainer
"
"
hidden
"
!
value
]
]
)
;
}
}
function
localizeElement
(
node
l10n
)
{
if
(
l10n
.
hasOwnProperty
(
"
raw
"
)
)
{
node
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
node
.
textContent
=
l10n
.
raw
;
}
else
{
document
.
l10n
.
setAttributes
(
node
l10n
.
id
l10n
.
args
)
;
}
}
class
HandlerInfoWrapper
{
constructor
(
type
handlerInfo
)
{
this
.
type
=
type
;
this
.
wrappedHandlerInfo
=
handlerInfo
;
this
.
disambiguateDescription
=
false
;
}
get
description
(
)
{
if
(
this
.
wrappedHandlerInfo
.
description
)
{
return
{
raw
:
this
.
wrappedHandlerInfo
.
description
}
;
}
if
(
this
.
primaryExtension
)
{
var
extension
=
this
.
primaryExtension
.
toUpperCase
(
)
;
return
{
id
:
"
applications
-
file
-
ending
"
args
:
{
extension
}
}
;
}
return
{
raw
:
this
.
type
}
;
}
get
typeDescription
(
)
{
if
(
this
.
disambiguateDescription
)
{
const
description
=
this
.
description
;
if
(
description
.
id
)
{
let
{
args
=
{
}
}
=
description
;
args
.
type
=
this
.
type
;
return
{
id
:
description
.
id
+
"
-
with
-
type
"
args
}
;
}
return
{
id
:
"
applications
-
type
-
description
-
with
-
type
"
args
:
{
"
type
-
description
"
:
description
.
raw
type
:
this
.
type
}
}
;
}
return
this
.
description
;
}
get
actionIconClass
(
)
{
if
(
this
.
alwaysAskBeforeHandling
)
{
return
"
ask
"
;
}
switch
(
this
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
return
"
save
"
;
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
this
instanceof
InternalHandlerInfoWrapper
)
{
return
"
handleInternally
"
;
}
break
;
}
return
"
"
;
}
get
actionIcon
(
)
{
switch
(
this
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
return
this
.
iconURLForSystemDefault
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
let
preferredApp
=
this
.
preferredApplicationHandler
;
if
(
gMainPane
.
isValidHandlerApp
(
preferredApp
)
)
{
return
gMainPane
.
_getIconURLForHandlerApp
(
preferredApp
)
;
}
default
:
return
ICON_URL_APP
;
}
}
get
iconURLForSystemDefault
(
)
{
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIPropertyBag
)
{
try
{
let
url
=
this
.
wrappedHandlerInfo
.
getProperty
(
"
defaultApplicationIconURL
"
)
;
if
(
url
)
{
return
url
+
"
?
size
=
16
"
;
}
}
catch
(
ex
)
{
}
}
return
ICON_URL_APP
;
}
get
preferredApplicationHandler
(
)
{
return
this
.
wrappedHandlerInfo
.
preferredApplicationHandler
;
}
set
preferredApplicationHandler
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
preferredApplicationHandler
=
aNewValue
;
if
(
aNewValue
)
{
this
.
addPossibleApplicationHandler
(
aNewValue
)
;
}
}
get
possibleApplicationHandlers
(
)
{
return
this
.
wrappedHandlerInfo
.
possibleApplicationHandlers
;
}
addPossibleApplicationHandler
(
aNewHandler
)
{
for
(
let
app
of
this
.
possibleApplicationHandlers
.
enumerate
(
)
)
{
if
(
app
.
equals
(
aNewHandler
)
)
{
return
;
}
}
this
.
possibleApplicationHandlers
.
appendElement
(
aNewHandler
)
;
}
removePossibleApplicationHandler
(
aHandler
)
{
var
defaultApp
=
this
.
preferredApplicationHandler
;
if
(
defaultApp
&
&
aHandler
.
equals
(
defaultApp
)
)
{
this
.
alwaysAskBeforeHandling
=
true
;
this
.
preferredApplicationHandler
=
null
;
}
var
handlers
=
this
.
possibleApplicationHandlers
;
for
(
var
i
=
0
;
i
<
handlers
.
length
;
+
+
i
)
{
var
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
equals
(
aHandler
)
)
{
handlers
.
removeElementAt
(
i
)
;
break
;
}
}
}
get
hasDefaultHandler
(
)
{
return
this
.
wrappedHandlerInfo
.
hasDefaultHandler
;
}
get
defaultDescription
(
)
{
return
this
.
wrappedHandlerInfo
.
defaultDescription
;
}
get
preferredAction
(
)
{
if
(
this
.
wrappedHandlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
&
&
!
gMainPane
.
isValidHandlerApp
(
this
.
preferredApplicationHandler
)
)
{
if
(
this
.
wrappedHandlerInfo
.
hasDefaultHandler
)
{
return
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
}
return
Ci
.
nsIHandlerInfo
.
saveToDisk
;
}
return
this
.
wrappedHandlerInfo
.
preferredAction
;
}
set
preferredAction
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
preferredAction
=
aNewValue
;
}
get
alwaysAskBeforeHandling
(
)
{
if
(
!
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
&
&
this
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
saveToDisk
)
{
return
true
;
}
return
this
.
wrappedHandlerInfo
.
alwaysAskBeforeHandling
;
}
set
alwaysAskBeforeHandling
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
alwaysAskBeforeHandling
=
aNewValue
;
}
get
primaryExtension
(
)
{
try
{
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
this
.
wrappedHandlerInfo
.
primaryExtension
)
{
return
this
.
wrappedHandlerInfo
.
primaryExtension
;
}
}
catch
(
ex
)
{
}
return
null
;
}
store
(
)
{
gHandlerService
.
store
(
this
.
wrappedHandlerInfo
)
;
}
get
smallIcon
(
)
{
return
this
.
_getIcon
(
16
)
;
}
_getIcon
(
aSize
)
{
if
(
this
.
primaryExtension
)
{
return
"
moz
-
icon
:
/
/
goat
.
"
+
this
.
primaryExtension
+
"
?
size
=
"
+
aSize
;
}
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
{
return
"
moz
-
icon
:
/
/
goat
?
size
=
"
+
aSize
+
"
&
contentType
=
"
+
this
.
type
;
}
return
null
;
}
}
class
InternalHandlerInfoWrapper
extends
HandlerInfoWrapper
{
constructor
(
mimeType
extension
)
{
let
type
=
gMIMEService
.
getFromTypeAndExtension
(
mimeType
extension
)
;
super
(
mimeType
|
|
type
.
type
type
)
;
}
store
(
)
{
super
.
store
(
)
;
}
get
preventInternalViewing
(
)
{
return
false
;
}
get
enabled
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
}
class
PDFHandlerInfoWrapper
extends
InternalHandlerInfoWrapper
{
constructor
(
)
{
super
(
TYPE_PDF
null
)
;
}
get
preventInternalViewing
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_PDFJS_DISABLED
)
;
}
get
enabled
(
)
{
return
true
;
}
}
class
ViewableInternallyHandlerInfoWrapper
extends
InternalHandlerInfoWrapper
{
get
enabled
(
)
{
return
DownloadIntegration
.
shouldViewDownloadInternally
(
this
.
type
)
;
}
}
const
AppearanceChooser
=
{
choices
:
[
"
dark
"
"
light
"
"
auto
"
]
chooser
:
null
radios
:
null
warning
:
null
init
(
)
{
this
.
chooser
=
document
.
getElementById
(
"
web
-
appearance
-
chooser
"
)
;
this
.
radios
=
[
.
.
.
this
.
chooser
.
querySelectorAll
(
"
input
"
)
]
;
for
(
let
radio
of
this
.
radios
)
{
radio
.
addEventListener
(
"
change
"
e
=
>
{
let
index
=
this
.
choices
.
indexOf
(
e
.
target
.
value
)
;
if
(
index
>
=
0
)
{
Services
.
prefs
.
setIntPref
(
PREF_CONTENT_APPEARANCE
index
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
PREF_CONTENT_APPEARANCE
)
;
}
}
)
;
}
let
webAppearanceSettings
=
document
.
getElementById
(
"
webAppearanceSettings
"
)
;
webAppearanceSettings
.
addEventListener
(
"
click
"
this
)
;
this
.
warning
=
document
.
getElementById
(
"
web
-
appearance
-
override
-
warning
"
)
;
FORCED_COLORS_QUERY
.
addEventListener
(
"
change
"
this
)
;
Services
.
prefs
.
addObserver
(
PREF_USE_SYSTEM_COLORS
this
)
;
Services
.
obs
.
addObserver
(
this
"
look
-
and
-
feel
-
changed
"
)
;
this
.
_update
(
)
;
}
_update
(
)
{
this
.
_updateWarning
(
)
;
this
.
_updateOptions
(
)
;
}
handleEvent
(
e
)
{
if
(
e
.
type
=
=
"
click
"
)
{
switch
(
e
.
target
.
id
)
{
case
"
web
-
appearance
-
manage
-
colors
-
button
"
:
document
.
getElementById
(
"
colors
"
)
.
click
(
)
;
e
.
preventDefault
(
)
;
break
;
case
"
web
-
appearance
-
manage
-
themes
-
link
"
:
window
.
browsingContext
.
topChromeWindow
.
BrowserAddonUI
.
openAddonsMgr
(
"
addons
:
/
/
list
/
theme
"
)
;
e
.
preventDefault
(
)
;
break
;
default
:
break
;
}
}
this
.
_update
(
)
;
}
observe
(
)
{
this
.
_update
(
)
;
}
destroy
(
)
{
Services
.
prefs
.
removeObserver
(
PREF_USE_SYSTEM_COLORS
this
)
;
Services
.
obs
.
removeObserver
(
this
"
look
-
and
-
feel
-
changed
"
)
;
FORCED_COLORS_QUERY
.
removeEventListener
(
"
change
"
this
)
;
}
_isValueDark
(
value
)
{
switch
(
value
)
{
case
"
light
"
:
return
false
;
case
"
dark
"
:
return
true
;
case
"
auto
"
:
return
Services
.
appinfo
.
contentThemeDerivedColorSchemeIsDark
;
}
throw
new
Error
(
"
Unknown
value
"
)
;
}
_updateOptions
(
)
{
let
index
=
Services
.
prefs
.
getIntPref
(
PREF_CONTENT_APPEARANCE
)
;
if
(
index
<
0
|
|
index
>
=
this
.
choices
.
length
)
{
index
=
Services
.
prefs
.
getDefaultBranch
(
null
)
.
getIntPref
(
PREF_CONTENT_APPEARANCE
)
;
}
let
value
=
this
.
choices
[
index
]
;
for
(
let
radio
of
this
.
radios
)
{
let
checked
=
radio
.
value
=
=
value
;
let
isDark
=
this
.
_isValueDark
(
radio
.
value
)
;
radio
.
checked
=
checked
;
radio
.
closest
(
"
label
"
)
.
classList
.
toggle
(
"
dark
"
isDark
)
;
}
}
_updateWarning
(
)
{
let
forcingColorsAndNoColorSchemeSupport
=
FORCED_COLORS_QUERY
.
matches
&
&
(
AppConstants
.
platform
=
=
"
win
"
|
|
!
Services
.
prefs
.
getBoolPref
(
PREF_USE_SYSTEM_COLORS
)
)
;
this
.
warning
.
hidden
=
!
forcingColorsAndNoColorSchemeSupport
;
}
}
;
