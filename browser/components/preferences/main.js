ChromeUtils
.
defineESModuleGetters
(
this
{
BackgroundUpdate
:
"
resource
:
/
/
gre
/
modules
/
BackgroundUpdate
.
sys
.
mjs
"
UpdateListener
:
"
resource
:
/
/
gre
/
modules
/
UpdateListener
.
sys
.
mjs
"
LinkPreview
:
"
moz
-
src
:
/
/
/
browser
/
components
/
genai
/
LinkPreview
.
sys
.
mjs
"
MigrationUtils
:
"
resource
:
/
/
/
modules
/
MigrationUtils
.
sys
.
mjs
"
SelectableProfileService
:
"
resource
:
/
/
/
modules
/
profiles
/
SelectableProfileService
.
sys
.
mjs
"
TranslationsParent
:
"
resource
:
/
/
gre
/
actors
/
TranslationsParent
.
sys
.
mjs
"
WindowsLaunchOnLogin
:
"
resource
:
/
/
gre
/
modules
/
WindowsLaunchOnLogin
.
sys
.
mjs
"
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
sys
.
mjs
"
}
)
;
const
TYPE_PDF
=
"
application
/
pdf
"
;
const
PREF_PDFJS_DISABLED
=
"
pdfjs
.
disabled
"
;
const
PREF_CONTAINERS_EXTENSION
=
"
privacy
.
userContext
.
extension
"
;
const
CONTAINERS_KEY
=
"
privacy
.
containers
"
;
const
FORCED_COLORS_QUERY
=
matchMedia
(
"
(
forced
-
colors
)
"
)
;
const
AUTO_UPDATE_CHANGED_TOPIC
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
"
app
.
update
.
auto
"
]
.
observerTopic
;
const
BACKGROUND_UPDATE_CHANGED_TOPIC
=
UpdateUtils
.
PER_INSTALLATION_PREFS
[
"
app
.
update
.
background
.
enabled
"
]
.
observerTopic
;
const
ICON_URL_APP
=
AppConstants
.
platform
=
=
"
linux
"
?
"
moz
-
icon
:
/
/
dummy
.
exe
?
size
=
16
"
:
"
chrome
:
/
/
browser
/
skin
/
preferences
/
application
.
png
"
;
const
APP_ICON_ATTR_NAME
=
"
appHandlerIcon
"
;
Preferences
.
addAll
(
[
{
id
:
"
browser
.
startup
.
page
"
type
:
"
int
"
}
{
id
:
"
browser
.
privatebrowsing
.
autostart
"
type
:
"
bool
"
}
{
id
:
"
browser
.
download
.
useDownloadDir
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
browser
.
download
.
enableDeletePrivate
"
type
:
"
bool
"
}
{
id
:
"
browser
.
download
.
deletePrivate
"
type
:
"
bool
"
}
{
id
:
"
browser
.
download
.
always_ask_before_handling_new_types
"
type
:
"
bool
"
}
{
id
:
"
browser
.
download
.
folderList
"
type
:
"
int
"
}
{
id
:
"
browser
.
download
.
dir
"
type
:
"
file
"
}
{
id
:
"
browser
.
link
.
open_newwindow
"
type
:
"
int
"
}
{
id
:
"
browser
.
tabs
.
loadInBackground
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
browser
.
tabs
.
warnOnClose
"
type
:
"
bool
"
}
{
id
:
"
browser
.
warnOnQuitShortcut
"
type
:
"
bool
"
}
{
id
:
"
browser
.
tabs
.
warnOnOpen
"
type
:
"
bool
"
}
{
id
:
"
browser
.
ctrlTab
.
sortByRecentlyUsed
"
type
:
"
bool
"
}
{
id
:
"
browser
.
tabs
.
hoverPreview
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
tabs
.
hoverPreview
.
showThumbnails
"
type
:
"
bool
"
}
{
id
:
"
browser
.
tabs
.
groups
.
smart
.
userEnabled
"
type
:
"
bool
"
}
{
id
:
"
sidebar
.
verticalTabs
"
type
:
"
bool
"
}
{
id
:
"
sidebar
.
revamp
"
type
:
"
bool
"
}
{
id
:
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
addons
"
type
:
"
bool
"
}
{
id
:
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
features
"
type
:
"
bool
"
}
{
id
:
"
browser
.
display
.
document_color_use
"
type
:
"
int
"
}
{
id
:
"
font
.
language
.
group
"
type
:
"
wstring
"
}
{
id
:
"
intl
.
regional_prefs
.
use_os_locales
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
browsewithcaret
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
typeaheadfind
"
type
:
"
bool
"
}
{
id
:
"
accessibility
.
blockautorefresh
"
type
:
"
bool
"
}
{
id
:
"
general
.
autoScroll
"
type
:
"
bool
"
}
{
id
:
"
general
.
smoothScroll
"
type
:
"
bool
"
}
{
id
:
"
widget
.
gtk
.
overlay
-
scrollbars
.
enabled
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
layout
.
css
.
always_underline_links
"
type
:
"
bool
"
}
{
id
:
"
layout
.
spellcheckDefault
"
type
:
"
int
"
}
{
id
:
"
accessibility
.
tabfocus
"
type
:
"
int
"
}
{
id
:
"
browser
.
ml
.
linkPreview
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
ml
.
linkPreview
.
optin
"
type
:
"
bool
"
}
{
id
:
"
browser
.
ml
.
linkPreview
.
longPress
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
dom
.
ipc
.
processCount
"
type
:
"
int
"
}
{
id
:
"
dom
.
ipc
.
processCount
.
web
"
type
:
"
int
"
}
{
id
:
"
layers
.
acceleration
.
disabled
"
type
:
"
bool
"
inverted
:
true
}
{
id
:
"
pref
.
downloads
.
disable_button
.
edit_actions
"
type
:
"
bool
"
}
{
id
:
"
media
.
eme
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
browser
.
preferences
.
advanced
.
selectedTabIndex
"
type
:
"
int
"
}
{
id
:
"
browser
.
search
.
update
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
userContext
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
privacy
.
userContext
.
newTabContainerOnLeftClick
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
media
.
hardwaremediakeys
.
enabled
"
type
:
"
bool
"
}
{
id
:
"
layout
.
css
.
prefers
-
color
-
scheme
.
content
-
override
"
type
:
"
int
"
}
]
)
;
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
Preferences
.
addAll
(
[
{
id
:
"
browser
.
shell
.
checkDefaultBrowser
"
type
:
"
bool
"
}
{
id
:
"
pref
.
general
.
disable_button
.
default_browser
"
type
:
"
bool
"
}
]
)
;
}
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
Preferences
.
addAll
(
[
{
id
:
"
browser
.
taskbar
.
previews
.
enable
"
type
:
"
bool
"
}
{
id
:
"
ui
.
osk
.
enabled
"
type
:
"
bool
"
}
]
)
;
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
Preferences
.
addAll
(
[
{
id
:
"
app
.
update
.
disable_button
.
showUpdateHistory
"
type
:
"
bool
"
}
]
)
;
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
Preferences
.
addAll
(
[
{
id
:
"
app
.
update
.
suppressPrompts
"
type
:
"
bool
"
}
]
)
;
}
}
Preferences
.
addSetting
(
{
id
:
"
privateBrowsingAutoStart
"
pref
:
"
browser
.
privatebrowsing
.
autostart
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
browserRestoreSession
"
pref
:
"
browser
.
startup
.
page
"
deps
:
[
"
privateBrowsingAutoStart
"
]
get
:
value
=
>
{
const
pbAutoStartPref
=
Preferences
.
get
(
"
browser
.
privatebrowsing
.
autostart
"
)
;
let
newValue
=
pbAutoStartPref
.
value
?
false
:
value
=
=
=
gMainPane
.
STARTUP_PREF_RESTORE_SESSION
;
return
newValue
;
}
set
:
checked
=
>
{
const
startupPref
=
Preferences
.
get
(
"
browser
.
startup
.
page
"
)
;
let
newValue
;
if
(
checked
)
{
if
(
startupPref
.
value
=
=
=
gMainPane
.
STARTUP_PREF_BLANK
)
{
HomePage
.
safeSet
(
"
about
:
blank
"
)
;
}
newValue
=
gMainPane
.
STARTUP_PREF_RESTORE_SESSION
;
}
else
{
newValue
=
gMainPane
.
STARTUP_PREF_HOMEPAGE
;
}
return
newValue
;
}
disabled
:
deps
=
>
{
return
deps
.
privateBrowsingAutoStart
.
value
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
useAutoScroll
"
pref
:
"
general
.
autoScroll
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
useSmoothScrolling
"
pref
:
"
general
.
smoothScroll
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
useOverlayScrollbars
"
pref
:
"
widget
.
gtk
.
overlay
-
scrollbars
.
enabled
"
visible
:
(
)
=
>
AppConstants
.
MOZ_WIDGET_GTK
}
)
;
Preferences
.
addSetting
(
{
id
:
"
useOnScreenKeyboard
"
pref
:
"
ui
.
osk
.
enabled
"
visible
:
(
)
=
>
AppConstants
.
platform
=
=
"
win
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
useCursorNavigation
"
pref
:
"
accessibility
.
browsewithcaret
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
useFullKeyboardNavigation
"
pref
:
"
accessibility
.
tabfocus
"
visible
:
(
)
=
>
AppConstants
.
platform
=
=
"
macosx
"
get
(
prefVal
)
{
this
.
_storedFullKeyboardNavigation
=
prefVal
;
return
prefVal
=
=
7
;
}
set
(
checked
)
{
if
(
checked
)
{
return
7
;
}
if
(
this
.
_storedFullKeyboardNavigation
!
=
7
)
{
return
this
.
_storedFullKeyboardNavigation
;
}
return
1
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
linkPreviewEnabled
"
pref
:
"
browser
.
ml
.
linkPreview
.
enabled
"
visible
:
(
)
=
>
LinkPreview
.
canShowPreferences
}
)
;
Preferences
.
addSetting
(
{
id
:
"
linkPreviewKeyPoints
"
pref
:
"
browser
.
ml
.
linkPreview
.
optin
"
visible
:
(
)
=
>
LinkPreview
.
canShowKeyPoints
}
)
;
Preferences
.
addSetting
(
{
id
:
"
linkPreviewLongPress
"
pref
:
"
browser
.
ml
.
linkPreview
.
longPress
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
alwaysUnderlineLinks
"
pref
:
"
layout
.
css
.
always_underline_links
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
searchStartTyping
"
pref
:
"
accessibility
.
typeaheadfind
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
pictureInPictureToggleEnabled
"
pref
:
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
enabled
"
visible
:
(
)
=
>
Services
.
prefs
.
getBoolPref
(
"
media
.
videocontrols
.
picture
-
in
-
picture
.
enabled
"
)
onUserChange
(
checked
)
{
if
(
!
checked
)
{
Glean
.
pictureinpictureSettings
.
disableSettings
.
record
(
)
;
}
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
mediaControlToggleEnabled
"
pref
:
"
media
.
hardwaremediakeys
.
enabled
"
visible
:
(
)
=
>
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
|
|
AppConstants
.
MOZ_WIDGET_GTK
}
)
;
Preferences
.
addSetting
(
{
id
:
"
cfrRecommendations
"
pref
:
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
addons
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
cfrRecommendations
-
features
"
pref
:
"
browser
.
newtabpage
.
activity
-
stream
.
asrouter
.
userprefs
.
cfr
.
features
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
web
-
appearance
-
override
-
warning
"
setup
:
emitChange
=
>
{
FORCED_COLORS_QUERY
.
addEventListener
(
"
change
"
emitChange
)
;
return
(
)
=
>
FORCED_COLORS_QUERY
.
removeEventListener
(
"
change
"
emitChange
)
;
}
visible
:
(
)
=
>
{
return
FORCED_COLORS_QUERY
.
matches
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
web
-
appearance
-
chooser
"
themeNames
:
[
"
dark
"
"
light
"
"
auto
"
]
pref
:
"
layout
.
css
.
prefers
-
color
-
scheme
.
content
-
override
"
setup
(
emitChange
)
{
Services
.
obs
.
addObserver
(
emitChange
"
look
-
and
-
feel
-
changed
"
)
;
return
(
)
=
>
Services
.
obs
.
removeObserver
(
emitChange
"
look
-
and
-
feel
-
changed
"
)
;
}
get
(
val
_
setting
)
{
return
this
.
themeNames
[
val
]
|
|
this
.
themeNames
[
setting
.
pref
.
defaultValue
]
;
}
set
(
val
)
{
return
this
.
themeNames
.
indexOf
(
val
)
;
}
getControlConfig
(
config
)
{
let
systemThemeIndex
=
Services
.
appinfo
.
contentThemeDerivedColorSchemeIsDark
?
2
:
1
;
config
.
options
[
0
]
.
controlAttrs
=
{
.
.
.
config
.
options
[
0
]
.
controlAttrs
imagesrc
:
config
.
options
[
systemThemeIndex
]
.
controlAttrs
.
imagesrc
}
;
return
config
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
web
-
appearance
-
manage
-
themes
-
link
"
onUserClick
:
e
=
>
{
e
.
preventDefault
(
)
;
window
.
browsingContext
.
topChromeWindow
.
BrowserAddonUI
.
openAddonsMgr
(
"
addons
:
/
/
list
/
theme
"
)
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
zoomPlaceholder
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
containersPane
"
onUserClick
(
e
)
{
e
.
preventDefault
(
)
;
gotoPref
(
"
paneContainers2
"
)
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
containersPlaceholder
"
}
)
;
const
DownloadsHelpers
=
new
(
class
DownloadsHelpers
{
folder
;
folderPath
;
folderHostPath
;
displayName
;
downloadsDir
;
desktopDir
;
downloadsFolderLocalizedName
;
desktopFolderLocalizedName
;
setupDownloadsHelpersFields
=
async
(
)
=
>
{
this
.
downloadsDir
=
await
this
.
_getDownloadsFolder
(
"
Downloads
"
)
;
this
.
desktopDir
=
await
this
.
_getDownloadsFolder
(
"
Desktop
"
)
;
[
this
.
downloadsFolderLocalizedName
this
.
desktopFolderLocalizedName
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
downloads
-
folder
-
name
"
}
{
id
:
"
desktop
-
folder
-
name
"
}
]
)
;
}
;
async
_getDownloadsFolder
(
aFolder
)
{
switch
(
aFolder
)
{
case
"
Desktop
"
:
return
Services
.
dirsvc
.
get
(
"
Desk
"
Ci
.
nsIFile
)
;
case
"
Downloads
"
:
{
let
downloadsDir
=
await
Downloads
.
getSystemDownloadsDirectory
(
)
;
return
new
FileUtils
.
File
(
downloadsDir
)
;
}
}
throw
new
Error
(
"
ASSERTION
FAILED
:
folder
type
should
be
'
Desktop
'
or
'
Downloads
'
"
)
;
}
_getSystemDownloadFolderDetails
(
folderIndex
)
{
let
currentDirPref
=
Preferences
.
get
(
"
browser
.
download
.
dir
"
)
;
let
file
;
let
firefoxLocalizedName
;
if
(
folderIndex
=
=
2
&
&
currentDirPref
.
value
)
{
file
=
currentDirPref
.
value
;
if
(
file
.
equals
(
this
.
downloadsDir
)
)
{
folderIndex
=
1
;
}
else
if
(
file
.
equals
(
this
.
desktopDir
)
)
{
folderIndex
=
0
;
}
}
switch
(
folderIndex
)
{
case
2
:
break
;
case
1
:
{
file
=
this
.
downloadsDir
;
firefoxLocalizedName
=
this
.
downloadsFolderLocalizedName
;
break
;
}
case
0
:
default
:
{
file
=
this
.
desktopDir
;
firefoxLocalizedName
=
this
.
desktopFolderLocalizedName
;
}
}
if
(
file
)
{
let
displayName
=
file
.
path
;
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
if
(
this
.
folderHostPath
&
&
displayName
=
=
this
.
folderPath
)
{
displayName
=
this
.
folderHostPath
;
if
(
displayName
=
=
this
.
downloadsDir
.
path
)
{
firefoxLocalizedName
=
this
.
downloadsFolderLocalizedName
;
}
else
if
(
displayName
=
=
this
.
desktopDir
.
path
)
{
firefoxLocalizedName
=
this
.
desktopFolderLocalizedName
;
}
}
else
if
(
displayName
!
=
this
.
folderPath
)
{
this
.
folderHostPath
=
null
;
try
{
file
.
hostPath
(
)
.
then
(
folderHostPath
=
>
{
this
.
folderHostPath
=
folderHostPath
;
Preferences
.
getSetting
(
"
downloadFolder
"
)
?
.
onChange
(
)
;
}
)
;
}
catch
(
error
)
{
}
}
}
if
(
firefoxLocalizedName
)
{
let
folderDisplayName
leafName
;
try
{
folderDisplayName
=
file
.
displayName
;
}
catch
(
ex
)
{
}
try
{
leafName
=
file
.
leafName
;
}
catch
(
ex
)
{
}
if
(
folderDisplayName
&
&
folderDisplayName
!
=
leafName
)
{
return
{
file
folderDisplayName
}
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
leafName
=
=
firefoxLocalizedName
)
{
return
{
file
folderDisplayName
:
firefoxLocalizedName
}
;
}
}
return
{
file
folderDisplayName
:
\
u2066
{
displayName
}
\
u2069
}
;
}
file
=
this
.
desktopDir
;
return
{
file
folderDisplayName
:
"
"
}
;
}
_folderToIndex
(
aFolder
)
{
if
(
!
aFolder
|
|
aFolder
.
equals
(
this
.
desktopDir
)
)
{
return
0
;
}
else
if
(
aFolder
.
equals
(
this
.
downloadsDir
)
)
{
return
1
;
}
return
2
;
}
getFolderDetails
(
)
{
let
folderIndex
=
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
.
value
;
let
{
folderDisplayName
file
}
=
this
.
_getSystemDownloadFolderDetails
(
folderIndex
)
;
this
.
folderPath
=
file
?
.
path
?
?
"
"
;
this
.
displayName
=
folderDisplayName
;
}
setFolder
(
folder
)
{
this
.
folder
=
folder
;
let
folderListPref
=
Preferences
.
get
(
"
browser
.
download
.
folderList
"
)
;
folderListPref
.
value
=
this
.
_folderToIndex
(
this
.
folder
)
;
}
}
)
(
)
;
Preferences
.
addSetting
(
{
id
:
"
browserDownloadFolderList
"
pref
:
"
browser
.
download
.
folderList
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
downloadFolder
"
pref
:
"
browser
.
download
.
dir
"
deps
:
[
"
browserDownloadFolderList
"
]
get
(
)
{
DownloadsHelpers
.
getFolderDetails
(
)
;
return
DownloadsHelpers
.
folderPath
;
}
set
(
folder
)
{
DownloadsHelpers
.
setFolder
(
folder
)
;
return
DownloadsHelpers
.
folder
;
}
getControlConfig
(
config
)
{
if
(
DownloadsHelpers
.
displayName
)
{
return
{
.
.
.
config
controlAttrs
:
{
.
.
.
config
.
controlAttrs
"
.
displayValue
"
:
DownloadsHelpers
.
displayName
}
}
;
}
return
{
.
.
.
config
}
;
}
setup
(
emitChange
)
{
DownloadsHelpers
.
setupDownloadsHelpersFields
(
)
.
then
(
emitChange
)
;
}
disabled
:
(
{
browserDownloadFolderList
}
)
=
>
{
return
browserDownloadFolderList
.
locked
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
alwaysAsk
"
pref
:
"
browser
.
download
.
useDownloadDir
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
enableDeletePrivate
"
pref
:
"
browser
.
download
.
enableDeletePrivate
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
deletePrivate
"
pref
:
"
browser
.
download
.
deletePrivate
"
deps
:
[
"
enableDeletePrivate
"
]
visible
:
(
{
enableDeletePrivate
}
)
=
>
enableDeletePrivate
.
value
onUserChange
(
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
download
.
deletePrivate
.
chosen
"
true
)
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
contentProcessCount
"
pref
:
"
dom
.
ipc
.
processCount
"
}
)
;
Preferences
.
addSetting
(
{
id
:
"
allowHWAccel
"
pref
:
"
layers
.
acceleration
.
disabled
"
deps
:
[
"
useRecommendedPerformanceSettings
"
]
visible
(
{
useRecommendedPerformanceSettings
}
)
{
return
!
useRecommendedPerformanceSettings
.
value
;
}
}
)
;
Preferences
.
addSetting
(
{
id
:
"
useRecommendedPerformanceSettings
"
pref
:
"
browser
.
preferences
.
defaultPerformanceSettings
.
enabled
"
deps
:
[
"
contentProcessCount
"
"
allowHWAccel
"
]
get
(
val
{
allowHWAccel
contentProcessCount
}
)
{
if
(
allowHWAccel
.
value
!
=
allowHWAccel
.
pref
.
defaultValue
|
|
contentProcessCount
.
value
!
=
contentProcessCount
.
pref
.
defaultValue
)
{
return
false
;
}
return
val
;
}
set
(
val
{
allowHWAccel
contentProcessCount
}
)
{
if
(
val
)
{
contentProcessCount
.
value
=
contentProcessCount
.
pref
.
defaultValue
;
allowHWAccel
.
value
=
allowHWAccel
.
pref
.
defaultValue
;
}
return
val
;
}
}
)
;
let
SETTINGS_CONFIG
=
{
containers
:
{
inProgress
:
true
items
:
[
{
id
:
"
containersPlaceholder
"
control
:
"
moz
-
message
-
bar
"
controlAttrs
:
{
message
:
"
Placeholder
for
updated
containers
"
}
}
]
}
startup
:
{
items
:
[
{
id
:
"
browserRestoreSession
"
l10nId
:
"
startup
-
restore
-
windows
-
and
-
tabs
"
}
]
}
zoom
:
{
inProgress
:
true
items
:
[
{
id
:
"
zoomPlaceholder
"
control
:
"
moz
-
message
-
bar
"
controlAttrs
:
{
message
:
"
Placeholder
for
updated
zoom
controls
"
}
}
{
id
:
"
containersPane
"
control
:
"
moz
-
button
"
controlAttrs
:
{
label
:
"
Manage
container
settings
"
}
}
]
}
appearance
:
{
l10nId
:
"
web
-
appearance
-
group
"
items
:
[
{
id
:
"
web
-
appearance
-
override
-
warning
"
l10nId
:
"
preferences
-
web
-
appearance
-
override
-
warning3
"
control
:
"
moz
-
message
-
bar
"
}
{
id
:
"
web
-
appearance
-
chooser
"
control
:
"
moz
-
visual
-
picker
"
options
:
[
{
value
:
"
auto
"
l10nId
:
"
preferences
-
web
-
appearance
-
choice
-
auto2
"
controlAttrs
:
{
id
:
"
preferences
-
web
-
appearance
-
choice
-
auto
"
class
:
"
appearance
-
chooser
-
item
"
imagesrc
:
"
chrome
:
/
/
browser
/
content
/
preferences
/
web
-
appearance
-
light
.
svg
"
}
}
{
value
:
"
light
"
l10nId
:
"
preferences
-
web
-
appearance
-
choice
-
light2
"
controlAttrs
:
{
id
:
"
preferences
-
web
-
appearance
-
choice
-
light
"
class
:
"
appearance
-
chooser
-
item
"
imagesrc
:
"
chrome
:
/
/
browser
/
content
/
preferences
/
web
-
appearance
-
light
.
svg
"
}
}
{
value
:
"
dark
"
l10nId
:
"
preferences
-
web
-
appearance
-
choice
-
dark2
"
controlAttrs
:
{
id
:
"
preferences
-
web
-
appearance
-
choice
-
dark
"
class
:
"
appearance
-
chooser
-
item
"
imagesrc
:
"
chrome
:
/
/
browser
/
content
/
preferences
/
web
-
appearance
-
dark
.
svg
"
}
}
]
}
{
id
:
"
web
-
appearance
-
manage
-
themes
-
link
"
l10nId
:
"
preferences
-
web
-
appearance
-
link
"
control
:
"
moz
-
box
-
link
"
controlAttrs
:
{
href
:
"
about
:
addons
"
}
}
]
}
downloads
:
{
l10nId
:
"
downloads
-
header
-
2
"
headingLevel
:
2
items
:
[
{
id
:
"
downloadFolder
"
l10nId
:
"
download
-
save
-
where
-
2
"
control
:
"
moz
-
input
-
folder
"
controlAttrs
:
{
id
:
"
chooseFolder
"
}
}
{
id
:
"
alwaysAsk
"
l10nId
:
"
download
-
always
-
ask
-
where
"
}
{
id
:
"
deletePrivate
"
l10nId
:
"
download
-
private
-
browsing
-
delete
"
}
]
}
browsing
:
{
l10nId
:
"
browsing
-
group
-
label
"
items
:
[
{
id
:
"
useAutoScroll
"
l10nId
:
"
browsing
-
use
-
autoscroll
"
}
{
id
:
"
useSmoothScrolling
"
l10nId
:
"
browsing
-
use
-
smooth
-
scrolling
"
}
{
id
:
"
useOverlayScrollbars
"
l10nId
:
"
browsing
-
gtk
-
use
-
non
-
overlay
-
scrollbars
"
}
{
id
:
"
useOnScreenKeyboard
"
l10nId
:
"
browsing
-
use
-
onscreen
-
keyboard
"
}
{
id
:
"
useCursorNavigation
"
l10nId
:
"
browsing
-
use
-
cursor
-
navigation
"
}
{
id
:
"
useFullKeyboardNavigation
"
l10nId
:
"
browsing
-
use
-
full
-
keyboard
-
navigation
"
}
{
id
:
"
alwaysUnderlineLinks
"
l10nId
:
"
browsing
-
always
-
underline
-
links
"
}
{
id
:
"
searchStartTyping
"
l10nId
:
"
browsing
-
search
-
on
-
start
-
typing
"
}
{
id
:
"
pictureInPictureToggleEnabled
"
l10nId
:
"
browsing
-
picture
-
in
-
picture
-
toggle
-
enabled
"
supportPage
:
"
picture
-
in
-
picture
"
}
{
id
:
"
mediaControlToggleEnabled
"
l10nId
:
"
browsing
-
media
-
control
"
supportPage
:
"
media
-
keyboard
-
control
"
}
{
id
:
"
cfrRecommendations
"
l10nId
:
"
browsing
-
cfr
-
recommendations
"
supportPage
:
"
extensionrecommendations
"
subcategory
:
"
cfraddons
"
}
{
id
:
"
cfrRecommendations
-
features
"
l10nId
:
"
browsing
-
cfr
-
features
"
supportPage
:
"
extensionrecommendations
"
subcategory
:
"
cfrfeatures
"
}
{
id
:
"
linkPreviewEnabled
"
l10nId
:
"
link
-
preview
-
settings
-
enable
"
subcategory
:
"
link
-
preview
"
items
:
[
{
id
:
"
linkPreviewKeyPoints
"
l10nId
:
"
link
-
preview
-
settings
-
key
-
points
"
}
{
id
:
"
linkPreviewLongPress
"
l10nId
:
"
link
-
preview
-
settings
-
long
-
press
"
}
]
}
]
}
httpsOnly
:
{
items
:
[
{
id
:
"
httpsOnlyRadioGroup
"
control
:
"
moz
-
radio
-
group
"
l10nId
:
"
httpsonly
-
label
"
supportPage
:
"
https
-
only
-
prefs
"
options
:
[
{
id
:
"
httpsOnlyRadioEnabled
"
value
:
"
enabled
"
l10nId
:
"
httpsonly
-
radio
-
enabled
"
}
{
id
:
"
httpsOnlyRadioEnabledPBM
"
value
:
"
privateOnly
"
l10nId
:
"
httpsonly
-
radio
-
enabled
-
pbm
"
}
{
id
:
"
httpsOnlyRadioDisabled
"
value
:
"
disabled
"
l10nId
:
"
httpsonly
-
radio
-
disabled3
"
supportPage
:
"
connection
-
upgrades
"
}
]
}
{
id
:
"
httpsOnlyExceptionButton
"
l10nId
:
"
sitedata
-
cookies
-
exceptions
"
control
:
"
moz
-
box
-
button
"
controlAttrs
:
{
"
search
-
l10n
-
ids
"
:
"
permissions
-
address
permissions
-
allow
.
label
permissions
-
remove
.
label
permissions
-
remove
-
all
.
label
permissions
-
exceptions
-
https
-
only
-
desc2
"
}
}
]
}
browsingProtection
:
{
items
:
[
{
id
:
"
enableSafeBrowsing
"
l10nId
:
"
security
-
enable
-
safe
-
browsing
"
supportPage
:
"
phishing
-
malware
"
control
:
"
moz
-
checkbox
"
items
:
[
{
id
:
"
blockDownloads
"
l10nId
:
"
security
-
block
-
downloads
"
}
{
id
:
"
blockUncommonUnwanted
"
l10nId
:
"
security
-
block
-
uncommon
-
software
"
}
]
}
]
}
nonTechnicalPrivacy
:
{
l10nId
:
"
non
-
technical
-
privacy
-
label
"
items
:
[
{
id
:
"
gpcEnabled
"
l10nId
:
"
global
-
privacy
-
control
-
description
"
supportPage
:
"
global
-
privacy
-
control
"
controlAttrs
:
{
"
search
-
l10n
-
ids
"
:
"
global
-
privacy
-
control
-
search
"
}
}
{
id
:
"
dntRemoval
"
l10nId
:
"
do
-
not
-
track
-
removal2
"
control
:
"
moz
-
box
-
link
"
supportPage
:
"
how
-
do
-
i
-
turn
-
do
-
not
-
track
-
feature
"
}
]
}
securityPrivacyStatus
:
{
items
:
[
{
id
:
"
privacyCard
"
control
:
"
security
-
privacy
-
card
"
}
{
id
:
"
securityWarningsGroup
"
control
:
"
moz
-
box
-
group
"
controlAttrs
:
{
type
:
"
list
"
}
}
]
}
performance
:
{
items
:
[
{
id
:
"
useRecommendedPerformanceSettings
"
l10nId
:
"
performance
-
use
-
recommended
-
settings
-
checkbox
"
supportPage
:
"
performance
"
}
{
id
:
"
allowHWAccel
"
l10nId
:
"
performance
-
allow
-
hw
-
accel
"
}
]
}
cookiesAndSiteData
:
{
l10nId
:
"
sitedata
-
label
"
items
:
[
{
id
:
"
clearSiteDataButton
"
l10nId
:
"
sitedata
-
clear2
"
control
:
"
moz
-
box
-
button
"
iconSrc
:
"
chrome
:
/
/
browser
/
skin
/
flame
.
svg
"
controlAttrs
:
{
"
search
-
l10n
-
ids
"
:
clear
-
site
-
data
-
cookies
-
empty
.
label
clear
-
site
-
data
-
cache
-
empty
.
label
}
}
{
id
:
"
deleteOnCloseInfo
"
l10nId
:
"
sitedata
-
delete
-
on
-
close
-
private
-
browsing3
"
control
:
"
moz
-
message
-
bar
"
}
{
id
:
"
manageDataSettingsGroup
"
control
:
"
moz
-
box
-
group
"
controlAttrs
:
{
type
:
"
default
"
}
items
:
[
{
id
:
"
siteDataSize
"
l10nId
:
"
sitedata
-
total
-
size
-
calculating
"
control
:
"
moz
-
box
-
item
"
supportPage
:
"
sitedata
-
learn
-
more
"
}
{
id
:
"
siteDataSettings
"
l10nId
:
"
sitedata
-
settings2
"
control
:
"
moz
-
box
-
button
"
controlAttrs
:
{
"
search
-
l10n
-
ids
"
:
site
-
data
-
settings
-
window
.
title
site
-
data
-
column
-
host
.
label
site
-
data
-
column
-
cookies
.
label
site
-
data
-
column
-
storage
.
label
site
-
data
-
settings
-
description
site
-
data
-
remove
-
all
.
label
}
}
{
id
:
"
cookieExceptions
"
l10nId
:
"
sitedata
-
cookies
-
exceptions2
"
control
:
"
moz
-
box
-
button
"
controlAttrs
:
{
"
search
-
l10n
-
ids
"
:
permissions
-
address
permissions
-
block
.
label
permissions
-
allow
.
label
permissions
-
remove
.
label
permissions
-
remove
-
all
.
label
permissions
-
exceptions
-
cookie
-
desc
}
}
]
}
{
id
:
"
deleteOnClose
"
l10nId
:
"
sitedata
-
delete
-
on
-
close
"
}
]
}
}
;
function
initSettingGroup
(
id
)
{
let
group
=
document
.
querySelector
(
setting
-
group
[
groupid
=
{
id
}
]
)
;
const
config
=
SETTINGS_CONFIG
[
id
]
;
if
(
group
&
&
config
)
{
if
(
config
.
inProgress
&
&
!
srdSectionEnabled
(
id
)
)
{
group
.
remove
(
)
;
return
;
}
let
legacySections
=
document
.
querySelectorAll
(
[
data
-
srd
-
groupid
=
{
id
}
]
)
;
for
(
let
section
of
legacySections
)
{
section
.
hidden
=
true
;
section
.
removeAttribute
(
"
data
-
category
"
)
;
section
.
setAttribute
(
"
data
-
hidden
-
from
-
search
"
"
true
"
)
;
}
group
.
config
=
config
;
group
.
getSetting
=
Preferences
.
getSetting
.
bind
(
Preferences
)
;
}
}
ChromeUtils
.
defineLazyGetter
(
this
"
gIsPackagedApp
"
(
)
=
>
{
return
Services
.
sysinfo
.
getProperty
(
"
isPackagedApp
"
)
;
}
)
;
var
promiseLoadHandlersList
;
function
getBundleForLocales
(
newLocales
)
{
let
locales
=
Array
.
from
(
new
Set
(
[
.
.
.
newLocales
.
.
.
Services
.
locale
.
requestedLocales
Services
.
locale
.
lastFallbackLocale
]
)
)
;
return
new
Localization
(
[
"
browser
/
preferences
/
preferences
.
ftl
"
"
branding
/
brand
.
ftl
"
]
false
undefined
locales
)
;
}
var
gNodeToObjectMap
=
new
WeakMap
(
)
;
var
gMainPane
=
{
_handledTypes
:
{
}
_visibleTypes
:
[
]
STARTUP_PREF_BLANK
:
0
STARTUP_PREF_HOMEPAGE
:
1
STARTUP_PREF_RESTORE_SESSION
:
3
get
_list
(
)
{
delete
this
.
_list
;
return
(
this
.
_list
=
document
.
getElementById
(
"
handlersView
"
)
)
;
}
get
_filter
(
)
{
delete
this
.
_filter
;
return
(
this
.
_filter
=
document
.
getElementById
(
"
filter
"
)
)
;
}
_backoffIndex
:
0
init
(
)
{
function
setEventListener
(
aId
aEventType
aCallback
)
{
document
.
getElementById
(
aId
)
.
addEventListener
(
aEventType
aCallback
.
bind
(
gMainPane
)
)
;
}
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
this
.
updateSetDefaultBrowser
(
)
;
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
backoffTimes
=
[
1000
1000
1000
1000
2000
2000
2000
5000
5000
10000
]
;
let
pollForDefaultBrowser
=
(
)
=
>
{
let
uri
=
win
.
gBrowser
.
currentURI
.
spec
;
if
(
(
uri
=
=
"
about
:
preferences
"
|
|
uri
=
=
"
about
:
preferences
#
general
"
|
|
uri
=
=
"
about
:
settings
"
|
|
uri
=
=
"
about
:
settings
#
general
"
)
&
&
document
.
visibilityState
=
=
"
visible
"
)
{
this
.
updateSetDefaultBrowser
(
)
;
}
window
.
setTimeout
(
(
)
=
>
{
window
.
requestIdleCallback
(
pollForDefaultBrowser
)
;
}
backoffTimes
[
this
.
_backoffIndex
+
1
<
backoffTimes
.
length
?
this
.
_backoffIndex
+
+
:
backoffTimes
.
length
-
1
]
)
;
}
;
window
.
setTimeout
(
(
)
=
>
{
window
.
requestIdleCallback
(
pollForDefaultBrowser
)
;
}
backoffTimes
[
this
.
_backoffIndex
]
)
;
}
this
.
initBrowserContainers
(
)
;
this
.
displayUseSystemLocale
(
)
;
this
.
updateProxySettingsUI
(
)
;
initializeProxyUI
(
gMainPane
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
enabled
"
)
)
{
gMainPane
.
initPrimaryBrowserLanguageUI
(
)
;
}
gMainPane
.
initDefaultZoomValues
(
)
;
gMainPane
.
initTranslations
(
)
;
initSettingGroup
(
"
appearance
"
)
;
initSettingGroup
(
"
downloads
"
)
;
initSettingGroup
(
"
browsing
"
)
;
initSettingGroup
(
"
zoom
"
)
;
initSettingGroup
(
"
performance
"
)
;
initSettingGroup
(
"
startup
"
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
try
{
let
ver
=
parseFloat
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
)
;
let
showTabsInTaskbar
=
document
.
getElementById
(
"
showTabsInTaskbar
"
)
;
showTabsInTaskbar
.
hidden
=
ver
<
6
.
1
;
}
catch
(
ex
)
{
}
}
let
thumbsCheckbox
=
document
.
getElementById
(
"
tabPreviewShowThumbnails
"
)
;
let
cardPreviewEnabledPref
=
Preferences
.
get
(
"
browser
.
tabs
.
hoverPreview
.
enabled
"
)
;
let
maybeShowThumbsCheckbox
=
(
)
=
>
(
thumbsCheckbox
.
hidden
=
!
cardPreviewEnabledPref
.
value
)
;
cardPreviewEnabledPref
.
on
(
"
change
"
maybeShowThumbsCheckbox
)
;
maybeShowThumbsCheckbox
(
)
;
const
tabGroupSuggestionsCheckbox
=
document
.
getElementById
(
"
tabGroupSuggestions
"
)
;
const
smartTabGroupFeatureEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
groups
.
smart
.
enabled
"
false
)
&
&
Services
.
locale
.
appLocaleAsBCP47
.
startsWith
(
"
en
"
)
;
tabGroupSuggestionsCheckbox
.
hidden
=
!
smartTabGroupFeatureEnabled
;
if
(
!
TransientPrefs
.
prefShouldBeVisible
(
"
browser
.
tabs
.
warnOnOpen
"
)
)
{
document
.
getElementById
(
"
warnOpenMany
"
)
.
hidden
=
true
;
}
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
let
quitKeyElement
=
window
.
browsingContext
.
topChromeWindow
.
document
.
getElementById
(
"
key_quitApplication
"
)
;
if
(
quitKeyElement
)
{
let
quitKey
=
ShortcutUtils
.
prettifyShortcut
(
quitKeyElement
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
warnOnQuitKey
"
)
"
ask
-
on
-
quit
-
with
-
key
"
{
quitKey
}
)
;
}
else
{
document
.
getElementById
(
"
warnOnQuitKey
"
)
.
hidden
=
true
;
}
}
setEventListener
(
"
ctrlTabRecentlyUsedOrder
"
"
command
"
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
ctrlTab
.
migrated
"
)
;
}
)
;
setEventListener
(
"
manageBrowserLanguagesButton
"
"
command
"
function
(
)
{
gMainPane
.
showBrowserLanguagesSubDialog
(
{
search
:
false
}
)
;
}
)
;
if
(
AppConstants
.
MOZ_UPDATER
)
{
setEventListener
(
"
checkForUpdatesButton
"
"
command
"
function
(
)
{
gAppUpdater
.
checkForUpdates
(
)
;
}
)
;
setEventListener
(
"
downloadAndInstallButton
"
"
command
"
function
(
)
{
gAppUpdater
.
startDownload
(
)
;
}
)
;
setEventListener
(
"
updateButton
"
"
command
"
function
(
)
{
gAppUpdater
.
buttonRestartAfterDownload
(
)
;
}
)
;
setEventListener
(
"
checkForUpdatesButton2
"
"
command
"
function
(
)
{
gAppUpdater
.
checkForUpdates
(
)
;
}
)
;
setEventListener
(
"
checkForUpdatesButton3
"
"
command
"
function
(
)
{
gAppUpdater
.
checkForUpdates
(
)
;
}
)
;
setEventListener
(
"
checkForUpdatesButton4
"
"
command
"
function
(
)
{
gAppUpdater
.
checkForUpdates
(
)
;
}
)
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
setEventListener
(
"
windowsLaunchOnLogin
"
"
command
"
gMainPane
.
onWindowsLaunchOnLoginChange
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
windowsLaunchOnLogin
.
enabled
"
false
)
)
{
document
.
getElementById
(
"
windowsLaunchOnLoginBox
"
)
.
hidden
=
false
;
NimbusFeatures
.
windowsLaunchOnLogin
.
recordExposureEvent
(
{
once
:
true
}
)
;
}
}
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
setEventListener
(
"
setDefaultButton
"
"
command
"
gMainPane
.
setDefaultBrowser
)
;
}
setEventListener
(
"
disableContainersExtension
"
"
command
"
makeDisableControllingExtension
(
PREF_SETTING_TYPE
CONTAINERS_KEY
)
)
;
setEventListener
(
"
chooseLanguage
"
"
command
"
gMainPane
.
showLanguages
)
;
setEventListener
(
"
fxtranslateButton
"
"
command
"
gMainPane
.
showTranslationExceptions
)
;
Preferences
.
get
(
"
font
.
language
.
group
"
)
.
on
(
"
change
"
gMainPane
.
_rebuildFonts
.
bind
(
gMainPane
)
)
;
setEventListener
(
"
advancedFonts
"
"
command
"
gMainPane
.
configureFonts
)
;
setEventListener
(
"
colors
"
"
command
"
gMainPane
.
configureColors
)
;
Preferences
.
get
(
"
browser
.
display
.
document_color_use
"
)
.
on
(
"
change
"
gMainPane
.
updateColorsButton
.
bind
(
gMainPane
)
)
;
gMainPane
.
updateColorsButton
(
)
;
setEventListener
(
"
connectionSettings
"
"
command
"
gMainPane
.
showConnections
)
;
setEventListener
(
"
browserContainersCheckbox
"
"
command
"
gMainPane
.
checkBrowserContainers
)
;
setEventListener
(
"
browserContainersSettings
"
"
command
"
gMainPane
.
showContainerSettings
)
;
setEventListener
(
"
data
-
migration
"
"
command
"
gMainPane
.
onMigrationButtonCommand
)
;
document
.
getElementById
(
"
browserLayoutShowSidebar
"
)
.
addEventListener
(
"
command
"
gMainPane
.
onShowSidebarCommand
.
bind
(
gMainPane
)
{
capture
:
true
}
)
;
document
.
getElementById
(
"
migrationWizardDialog
"
)
.
addEventListener
(
"
MigrationWizard
:
Close
"
function
(
e
)
{
e
.
currentTarget
.
close
(
)
;
}
)
;
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
profileImport
"
)
)
{
document
.
getElementById
(
"
dataMigrationGroup
"
)
.
remove
(
)
;
}
if
(
!
SelectableProfileService
.
isEnabled
)
{
document
.
getElementById
(
"
profilesGroup
"
)
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
}
else
{
setEventListener
(
"
manage
-
profiles
"
"
command
"
gMainPane
.
manageProfiles
)
;
}
this
.
_rebuildFonts
(
)
;
const
fxtranslationsDisabledPrefName
=
"
extensions
.
translations
.
disabled
"
;
if
(
!
Services
.
prefs
.
getBoolPref
(
fxtranslationsDisabledPrefName
true
)
)
{
let
fxtranslationRow
=
document
.
getElementById
(
"
fxtranslationsBox
"
)
;
fxtranslationRow
.
hidden
=
false
;
}
let
emeUIEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
eme
.
ui
.
enabled
"
)
;
if
(
navigator
.
platform
.
toLowerCase
(
)
.
startsWith
(
"
win
"
)
)
{
emeUIEnabled
=
emeUIEnabled
&
&
parseFloat
(
Services
.
sysinfo
.
get
(
"
version
"
)
)
>
=
6
;
}
if
(
!
emeUIEnabled
)
{
document
.
getElementById
(
"
drmGroup
"
)
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
}
let
version
=
AppConstants
.
MOZ_APP_VERSION_DISPLAY
;
if
(
/
a
\
d
+
/
.
test
(
version
)
)
{
let
buildID
=
Services
.
appinfo
.
appBuildID
;
let
year
=
buildID
.
slice
(
0
4
)
;
let
month
=
buildID
.
slice
(
4
6
)
;
let
day
=
buildID
.
slice
(
6
8
)
;
version
+
=
(
{
year
}
-
{
month
}
-
{
day
}
)
;
}
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
archResource
=
Services
.
appinfo
.
is64Bit
?
"
aboutDialog
.
architecture
.
sixtyFourBit
"
:
"
aboutDialog
.
architecture
.
thirtyTwoBit
"
;
let
arch
=
bundle
.
GetStringFromName
(
archResource
)
;
version
+
=
(
{
arch
}
)
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
updateAppInfo
"
)
"
update
-
application
-
version
"
{
version
}
)
;
let
relNotesLink
=
document
.
getElementById
(
"
releasenotes
"
)
;
let
relNotesPrefType
=
Services
.
prefs
.
getPrefType
(
"
app
.
releaseNotesURL
"
)
;
if
(
relNotesPrefType
!
=
Services
.
prefs
.
PREF_INVALID
)
{
let
relNotesURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
releaseNotesURL
"
)
;
if
(
relNotesURL
!
=
"
about
:
blank
"
)
{
relNotesLink
.
href
=
relNotesURL
;
relNotesLink
.
hidden
=
false
;
}
}
let
defaults
=
Services
.
prefs
.
getDefaultBranch
(
null
)
;
let
distroId
=
defaults
.
getCharPref
(
"
distribution
.
id
"
"
"
)
;
if
(
distroId
)
{
let
distroString
=
distroId
;
let
distroVersion
=
defaults
.
getCharPref
(
"
distribution
.
version
"
"
"
)
;
if
(
distroVersion
)
{
distroString
+
=
"
-
"
+
distroVersion
;
}
let
distroIdField
=
document
.
getElementById
(
"
distributionId
"
)
;
distroIdField
.
value
=
distroString
;
distroIdField
.
hidden
=
false
;
let
distroAbout
=
defaults
.
getStringPref
(
"
distribution
.
about
"
"
"
)
;
if
(
distroAbout
)
{
let
distroField
=
document
.
getElementById
(
"
distribution
"
)
;
distroField
.
value
=
distroAbout
;
distroField
.
hidden
=
false
;
}
}
if
(
AppConstants
.
MOZ_UPDATER
)
{
gAppUpdater
=
new
appUpdater
(
)
;
setEventListener
(
"
showUpdateHistory
"
"
command
"
gMainPane
.
showUpdates
)
;
let
updateDisabled
=
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
;
if
(
gIsPackagedApp
)
{
document
.
getElementById
(
"
updatesCategory
"
)
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
document
.
getElementById
(
"
updateApp
"
)
.
setAttribute
(
"
style
"
"
display
:
none
!
important
"
)
;
}
else
if
(
updateDisabled
|
|
UpdateUtils
.
appUpdateAutoSettingIsLocked
(
)
|
|
gApplicationUpdateService
.
manualUpdateOnly
)
{
document
.
getElementById
(
"
updateAllowDescription
"
)
.
hidden
=
true
;
document
.
getElementById
(
"
updateSettingsContainer
"
)
.
hidden
=
true
;
}
else
{
document
.
getElementById
(
"
autoDesktop
"
)
.
removeAttribute
(
"
selected
"
)
;
document
.
getElementById
(
"
manualDesktop
"
)
.
removeAttribute
(
"
selected
"
)
;
this
.
readUpdateAutoPref
(
)
;
setEventListener
(
"
updateRadioGroup
"
"
command
"
event
=
>
{
if
(
event
.
target
.
id
=
=
"
backgroundUpdate
"
)
{
this
.
writeBackgroundUpdatePref
(
)
;
}
else
{
this
.
writeUpdateAutoPref
(
)
;
}
}
)
;
if
(
this
.
isBackgroundUpdateUIAvailable
(
)
)
{
document
.
getElementById
(
"
backgroundUpdate
"
)
.
hidden
=
false
;
this
.
readBackgroundUpdatePref
(
)
;
}
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
launchOnLoginCheckbox
=
document
.
getElementById
(
"
windowsLaunchOnLogin
"
)
;
let
startWithLastProfile
=
Cc
[
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
]
.
getService
(
Ci
.
nsIToolkitProfileService
)
.
startWithLastProfile
;
document
.
getElementById
(
"
windowsLaunchOnLoginDisabledProfileBox
"
)
.
hidden
=
startWithLastProfile
;
launchOnLoginCheckbox
.
disabled
=
!
startWithLastProfile
;
if
(
!
startWithLastProfile
)
{
launchOnLoginCheckbox
.
checked
=
false
;
}
else
{
WindowsLaunchOnLogin
.
getLaunchOnLoginEnabled
(
)
.
then
(
enabled
=
>
{
launchOnLoginCheckbox
.
checked
=
enabled
;
}
)
;
WindowsLaunchOnLogin
.
getLaunchOnLoginApproved
(
)
.
then
(
approvedByWindows
=
>
{
launchOnLoginCheckbox
.
disabled
=
!
approvedByWindows
;
document
.
getElementById
(
"
windowsLaunchOnLoginDisabledBox
"
)
.
hidden
=
approvedByWindows
;
}
)
;
}
let
updateContainer
=
document
.
getElementById
(
"
updateSettingsContainer
"
)
;
updateContainer
.
classList
.
add
(
"
updateSettingCrossUserWarningContainer
"
)
;
document
.
getElementById
(
"
updateSettingCrossUserWarningDesc
"
)
.
hidden
=
false
;
}
}
Services
.
obs
.
addObserver
(
this
AUTO_UPDATE_CHANGED_TOPIC
)
;
Services
.
obs
.
addObserver
(
this
BACKGROUND_UPDATE_CHANGED_TOPIC
)
;
setEventListener
(
"
filter
"
"
MozInputSearch
:
search
"
gMainPane
.
filter
)
;
setEventListener
(
"
typeColumn
"
"
click
"
gMainPane
.
sort
)
;
setEventListener
(
"
actionColumn
"
"
click
"
gMainPane
.
sort
)
;
window
.
addEventListener
(
"
unload
"
this
)
;
if
(
document
.
getElementById
(
"
actionColumn
"
)
.
hasAttribute
(
"
sortDirection
"
)
)
{
this
.
_sortColumn
=
document
.
getElementById
(
"
actionColumn
"
)
;
document
.
getElementById
(
"
typeColumn
"
)
.
removeAttribute
(
"
sortDirection
"
)
;
}
else
{
this
.
_sortColumn
=
document
.
getElementById
(
"
typeColumn
"
)
;
}
appendSearchKeywords
(
"
browserContainersSettings
"
[
"
user
-
context
-
personal
"
"
user
-
context
-
work
"
"
user
-
context
-
banking
"
"
user
-
context
-
shopping
"
]
.
map
(
ContextualIdentityService
.
formatContextLabel
)
)
;
Services
.
obs
.
notifyObservers
(
window
"
main
-
pane
-
loaded
"
)
;
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
defaultFont
"
)
element
=
>
FontBuilder
.
readFontSelection
(
element
)
)
;
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
checkSpelling
"
)
(
)
=
>
this
.
readCheckSpelling
(
)
)
;
Preferences
.
addSyncToPrefListener
(
document
.
getElementById
(
"
checkSpelling
"
)
(
)
=
>
this
.
writeCheckSpelling
(
)
)
;
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
linkTargeting
"
)
(
)
=
>
this
.
readLinkTarget
(
)
)
;
Preferences
.
addSyncToPrefListener
(
document
.
getElementById
(
"
linkTargeting
"
)
(
)
=
>
this
.
writeLinkTarget
(
)
)
;
Preferences
.
addSyncFromPrefListener
(
document
.
getElementById
(
"
browserContainersCheckbox
"
)
(
)
=
>
this
.
readBrowserContainersCheckbox
(
)
)
;
this
.
setInitialized
(
)
;
}
preInit
(
)
{
promiseLoadHandlersList
=
new
Promise
(
(
resolve
reject
)
=
>
{
window
.
addEventListener
(
"
pageshow
"
async
(
)
=
>
{
await
this
.
initialized
;
try
{
this
.
_initListEventHandlers
(
)
;
this
.
_loadData
(
)
;
await
this
.
_rebuildVisibleTypes
(
)
;
await
this
.
_rebuildView
(
)
;
await
this
.
_sortListView
(
)
;
resolve
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
{
once
:
true
}
)
;
}
)
;
}
handleSubcategory
(
subcategory
)
{
if
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
profileImport
"
)
)
{
return
false
;
}
if
(
subcategory
=
=
"
migrate
"
)
{
this
.
showMigrationWizardDialog
(
)
;
return
true
;
}
if
(
subcategory
=
=
"
migrate
-
autoclose
"
)
{
this
.
showMigrationWizardDialog
(
{
closeTabWhenDone
:
true
}
)
;
}
return
false
;
}
onShowSidebarCommand
(
event
)
{
const
willEnable
=
event
.
target
.
checked
;
if
(
willEnable
)
{
window
.
browsingContext
.
topChromeWindow
.
SidebarController
?
.
enabledViaSettings
(
true
)
;
}
}
readBrowserContainersCheckbox
(
)
{
const
pref
=
Preferences
.
get
(
"
privacy
.
userContext
.
enabled
"
)
;
const
settings
=
document
.
getElementById
(
"
browserContainersSettings
"
)
;
settings
.
disabled
=
!
pref
.
value
;
const
containersEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
;
const
containersCheckbox
=
document
.
getElementById
(
"
browserContainersCheckbox
"
)
;
containersCheckbox
.
checked
=
containersEnabled
;
handleControllingExtension
(
PREF_SETTING_TYPE
CONTAINERS_KEY
)
.
then
(
isControlled
=
>
{
containersCheckbox
.
disabled
=
isControlled
;
}
)
;
}
initBrowserContainers
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
ui
.
enabled
"
)
)
{
document
.
getElementById
(
"
browserContainersbox
"
)
.
setAttribute
(
"
data
-
hidden
-
from
-
search
"
"
true
"
)
;
return
;
}
Services
.
prefs
.
addObserver
(
PREF_CONTAINERS_EXTENSION
this
)
;
document
.
getElementById
(
"
browserContainersbox
"
)
.
hidden
=
false
;
this
.
readBrowserContainersCheckbox
(
)
;
}
async
onGetStarted
(
)
{
if
(
!
AppConstants
.
MOZ_DEV_EDITION
)
{
return
;
}
const
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
!
win
)
{
return
;
}
const
user
=
await
fxAccounts
.
getSignedInUser
(
)
;
if
(
user
)
{
win
.
openTrustedLinkIn
(
"
about
:
preferences
#
sync
"
"
current
"
)
;
return
;
}
if
(
!
(
await
FxAccounts
.
canConnectAccount
(
)
)
)
{
return
;
}
let
url
=
await
FxAccounts
.
config
.
promiseConnectAccountURI
(
"
dev
-
edition
-
setup
"
)
;
let
accountsTab
=
win
.
gBrowser
.
addWebTab
(
url
)
;
win
.
gBrowser
.
selectedTab
=
accountsTab
;
}
updateButtons
(
aButtonID
aPreferenceID
)
{
var
button
=
document
.
getElementById
(
aButtonID
)
;
var
preference
=
Preferences
.
get
(
aPreferenceID
)
;
button
.
disabled
=
!
preference
.
value
;
return
undefined
;
}
async
initDefaultZoomValues
(
)
{
let
win
=
window
.
browsingContext
.
topChromeWindow
;
let
selected
=
await
win
.
ZoomUI
.
getGlobalValue
(
)
;
let
menulist
=
document
.
getElementById
(
"
defaultZoom
"
)
;
new
SelectionChangedMenulist
(
menulist
event
=
>
{
let
parsedZoom
=
parseFloat
(
(
event
.
target
.
value
/
100
)
.
toFixed
(
2
)
)
;
gMainPane
.
handleDefaultZoomChange
(
parsedZoom
)
;
}
)
;
setEventListener
(
"
zoomText
"
"
command
"
function
(
)
{
win
.
ZoomManager
.
toggleZoom
(
)
;
document
.
getElementById
(
"
text
-
zoom
-
override
-
warning
"
)
.
hidden
=
!
document
.
getElementById
(
"
zoomText
"
)
.
checked
;
}
)
;
let
zoomValues
=
win
.
ZoomManager
.
zoomValues
.
map
(
a
=
>
{
return
Math
.
round
(
a
*
100
)
;
}
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
zoomLevel
of
zoomValues
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
document
.
l10n
.
setAttributes
(
menuitem
"
preferences
-
default
-
zoom
-
value
"
{
percentage
:
zoomLevel
}
)
;
menuitem
.
setAttribute
(
"
value
"
zoomLevel
)
;
fragment
.
appendChild
(
menuitem
)
;
}
let
menupopup
=
menulist
.
querySelector
(
"
menupopup
"
)
;
menupopup
.
appendChild
(
fragment
)
;
menulist
.
value
=
Math
.
round
(
selected
*
100
)
;
let
checkbox
=
document
.
getElementById
(
"
zoomText
"
)
;
checkbox
.
checked
=
!
win
.
ZoomManager
.
useFullZoom
;
document
.
getElementById
(
"
text
-
zoom
-
override
-
warning
"
)
.
hidden
=
!
checkbox
.
checked
;
document
.
getElementById
(
"
zoomBox
"
)
.
hidden
=
false
;
}
updateColorsButton
(
)
{
document
.
getElementById
(
"
colors
"
)
.
disabled
=
Preferences
.
get
(
"
browser
.
display
.
document_color_use
"
)
.
value
!
=
2
;
}
async
initTranslations
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
translations
.
enable
"
)
)
{
return
;
}
document
.
getElementById
(
"
translationsGroup
"
)
.
hidden
=
false
;
class
TranslationsState
{
constructor
(
supportedLanguages
languageList
downloadPhases
)
{
this
.
supportedLanguages
=
supportedLanguages
;
this
.
languageList
=
languageList
;
this
.
downloadPhases
=
downloadPhases
;
}
static
async
create
(
)
{
const
supportedLanguages
=
await
TranslationsParent
.
getSupportedLanguages
(
)
;
const
languageList
=
TranslationsParent
.
getLanguageList
(
supportedLanguages
)
;
const
downloadPhases
=
await
TranslationsState
.
createDownloadPhases
(
languageList
)
;
if
(
supportedLanguages
.
languagePairs
.
length
=
=
=
0
)
{
throw
new
Error
(
"
The
supported
languages
list
was
empty
.
RemoteSettings
may
not
be
available
at
the
moment
.
"
)
;
}
return
new
TranslationsState
(
supportedLanguages
languageList
downloadPhases
)
;
}
static
async
createDownloadPhases
(
languageList
)
{
const
downloadPhases
=
new
Map
(
)
;
for
(
const
{
langTag
}
of
languageList
)
{
downloadPhases
.
set
(
langTag
(
await
TranslationsParent
.
hasAllFilesForLanguage
(
langTag
)
)
?
"
downloaded
"
:
"
uninstalled
"
)
;
}
return
downloadPhases
;
}
}
class
TranslationsView
{
deleteButtons
=
new
Map
(
)
;
downloadButtons
=
new
Map
(
)
;
constructor
(
state
)
{
this
.
state
=
state
;
this
.
elements
=
{
settingsButton
:
document
.
getElementById
(
"
translations
-
manage
-
settings
-
button
"
)
installList
:
document
.
getElementById
(
"
translations
-
manage
-
install
-
list
"
)
installAll
:
document
.
getElementById
(
"
translations
-
manage
-
install
-
all
"
)
deleteAll
:
document
.
getElementById
(
"
translations
-
manage
-
delete
-
all
"
)
error
:
document
.
getElementById
(
"
translations
-
manage
-
error
"
)
}
;
this
.
setup
(
)
;
}
setup
(
)
{
this
.
buildLanguageList
(
)
;
this
.
elements
.
settingsButton
.
addEventListener
(
"
command
"
gMainPane
.
showTranslationsSettings
)
;
this
.
elements
.
installAll
.
addEventListener
(
"
command
"
this
.
handleInstallAll
)
;
this
.
elements
.
deleteAll
.
addEventListener
(
"
command
"
this
.
handleDeleteAll
)
;
Services
.
obs
.
addObserver
(
this
"
intl
:
app
-
locales
-
changed
"
)
;
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
intl
:
app
-
locales
-
changed
"
)
;
}
handleInstallAll
=
async
(
)
=
>
{
this
.
hideError
(
)
;
this
.
disableButtons
(
true
)
;
try
{
await
TranslationsParent
.
downloadAllFiles
(
)
;
this
.
markAllDownloadPhases
(
"
downloaded
"
)
;
}
catch
(
error
)
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
download
"
error
)
;
await
this
.
reloadDownloadPhases
(
)
;
this
.
updateAllButtons
(
)
;
}
this
.
disableButtons
(
false
)
;
}
;
handleDeleteAll
=
async
(
)
=
>
{
this
.
hideError
(
)
;
this
.
disableButtons
(
true
)
;
try
{
await
TranslationsParent
.
deleteAllLanguageFiles
(
)
;
this
.
markAllDownloadPhases
(
"
uninstalled
"
)
;
}
catch
(
error
)
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
remove
"
error
)
;
await
this
.
reloadDownloadPhases
(
)
;
console
.
error
(
error
)
;
}
this
.
disableButtons
(
false
)
;
}
;
getDownloadButtonHandler
(
langTag
)
{
return
async
(
)
=
>
{
this
.
hideError
(
)
;
this
.
updateDownloadPhase
(
langTag
"
loading
"
)
;
try
{
await
TranslationsParent
.
downloadLanguageFiles
(
langTag
)
;
this
.
updateDownloadPhase
(
langTag
"
downloaded
"
)
;
}
catch
(
error
)
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
download
"
error
)
;
this
.
updateDownloadPhase
(
langTag
"
uninstalled
"
)
;
}
}
;
}
getDeleteButtonHandler
(
langTag
)
{
return
async
(
)
=
>
{
this
.
hideError
(
)
;
this
.
updateDownloadPhase
(
langTag
"
loading
"
)
;
try
{
await
TranslationsParent
.
deleteLanguageFiles
(
langTag
)
;
this
.
updateDownloadPhase
(
langTag
"
uninstalled
"
)
;
}
catch
(
error
)
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
remove
"
error
)
;
await
this
.
reloadDownloadPhases
(
)
;
}
}
;
}
buildLanguageList
(
)
{
const
listFragment
=
document
.
createDocumentFragment
(
)
;
for
(
const
{
langTag
displayName
}
of
this
.
state
.
languageList
)
{
const
hboxRow
=
document
.
createXULElement
(
"
hbox
"
)
;
hboxRow
.
classList
.
add
(
"
translations
-
manage
-
language
"
)
;
hboxRow
.
setAttribute
(
"
data
-
lang
-
tag
"
langTag
)
;
const
languageLabel
=
document
.
createXULElement
(
"
label
"
)
;
languageLabel
.
textContent
=
displayName
;
const
downloadButton
=
document
.
createXULElement
(
"
button
"
)
;
const
deleteButton
=
document
.
createXULElement
(
"
button
"
)
;
downloadButton
.
addEventListener
(
"
command
"
this
.
getDownloadButtonHandler
(
langTag
)
)
;
deleteButton
.
addEventListener
(
"
command
"
this
.
getDeleteButtonHandler
(
langTag
)
)
;
document
.
l10n
.
setAttributes
(
downloadButton
"
translations
-
manage
-
language
-
download
-
button
"
)
;
document
.
l10n
.
setAttributes
(
deleteButton
"
translations
-
manage
-
language
-
remove
-
button
"
)
;
downloadButton
.
hidden
=
true
;
deleteButton
.
hidden
=
true
;
this
.
deleteButtons
.
set
(
langTag
deleteButton
)
;
this
.
downloadButtons
.
set
(
langTag
downloadButton
)
;
hboxRow
.
appendChild
(
languageLabel
)
;
hboxRow
.
appendChild
(
downloadButton
)
;
hboxRow
.
appendChild
(
deleteButton
)
;
listFragment
.
appendChild
(
hboxRow
)
;
}
this
.
updateAllButtons
(
)
;
this
.
elements
.
installList
.
appendChild
(
listFragment
)
;
}
updateDownloadPhase
(
langTag
downloadPhase
)
{
this
.
state
.
downloadPhases
.
set
(
langTag
downloadPhase
)
;
this
.
updateButton
(
langTag
downloadPhase
)
;
this
.
updateHeaderButtons
(
)
;
}
async
reloadDownloadPhases
(
)
{
this
.
state
.
downloadPhases
=
await
TranslationsState
.
createDownloadPhases
(
this
.
state
.
languageList
)
;
this
.
updateAllButtons
(
)
;
}
markAllDownloadPhases
(
downloadPhase
)
{
const
{
downloadPhases
}
=
this
.
state
;
for
(
const
key
of
downloadPhases
.
keys
(
)
)
{
downloadPhases
.
set
(
key
downloadPhase
)
;
}
this
.
updateAllButtons
(
)
;
}
updateHeaderButtons
(
)
{
let
allDownloaded
=
true
;
let
allUninstalled
=
true
;
for
(
const
downloadPhase
of
this
.
state
.
downloadPhases
.
values
(
)
)
{
if
(
downloadPhase
=
=
=
"
loading
"
)
{
continue
;
}
allDownloaded
&
&
=
downloadPhase
=
=
=
"
downloaded
"
;
allUninstalled
&
&
=
downloadPhase
=
=
=
"
uninstalled
"
;
}
this
.
elements
.
installAll
.
hidden
=
allDownloaded
;
this
.
elements
.
deleteAll
.
hidden
=
allUninstalled
;
}
updateAllButtons
(
)
{
this
.
updateHeaderButtons
(
)
;
for
(
const
[
langTag
downloadPhase
]
of
this
.
state
.
downloadPhases
)
{
this
.
updateButton
(
langTag
downloadPhase
)
;
}
}
updateButton
(
langTag
downloadPhase
)
{
const
downloadButton
=
this
.
downloadButtons
.
get
(
langTag
)
;
const
deleteButton
=
this
.
deleteButtons
.
get
(
langTag
)
;
switch
(
downloadPhase
)
{
case
"
downloaded
"
:
downloadButton
.
hidden
=
true
;
deleteButton
.
hidden
=
false
;
downloadButton
.
removeAttribute
(
"
disabled
"
)
;
break
;
case
"
uninstalled
"
:
downloadButton
.
hidden
=
false
;
deleteButton
.
hidden
=
true
;
downloadButton
.
removeAttribute
(
"
disabled
"
)
;
break
;
case
"
loading
"
:
downloadButton
.
hidden
=
false
;
deleteButton
.
hidden
=
true
;
downloadButton
.
setAttribute
(
"
disabled
"
true
)
;
break
;
}
}
disableButtons
(
isDisabled
)
{
this
.
elements
.
installAll
.
disabled
=
isDisabled
;
this
.
elements
.
deleteAll
.
disabled
=
isDisabled
;
for
(
const
button
of
this
.
downloadButtons
.
values
(
)
)
{
button
.
disabled
=
isDisabled
;
}
for
(
const
button
of
this
.
deleteButtons
.
values
(
)
)
{
button
.
disabled
=
isDisabled
;
}
}
static
showError
(
l10nId
error
)
{
console
.
error
(
error
)
;
const
errorMessage
=
document
.
getElementById
(
"
translations
-
manage
-
error
"
)
;
errorMessage
.
hidden
=
false
;
document
.
l10n
.
setAttributes
(
errorMessage
l10nId
)
;
}
hideError
(
)
{
this
.
elements
.
error
.
hidden
=
true
;
}
observe
(
_subject
topic
_data
)
{
if
(
topic
=
=
=
"
intl
:
app
-
locales
-
changed
"
)
{
this
.
refreshLanguageListDisplay
(
)
;
}
}
refreshLanguageListDisplay
(
)
{
try
{
const
languageDisplayNames
=
TranslationsParent
.
createLanguageDisplayNames
(
)
;
for
(
const
row
of
this
.
elements
.
installList
.
children
)
{
const
rowLangTag
=
row
.
getAttribute
(
"
data
-
lang
-
tag
"
)
;
if
(
!
rowLangTag
)
{
continue
;
}
const
label
=
row
.
querySelector
(
"
label
"
)
;
if
(
label
)
{
const
newDisplayName
=
languageDisplayNames
.
of
(
rowLangTag
)
;
if
(
label
.
textContent
!
=
=
newDisplayName
)
{
label
.
textContent
=
newDisplayName
;
}
}
}
}
catch
(
error
)
{
console
.
error
(
error
)
;
}
}
}
TranslationsState
.
create
(
)
.
then
(
state
=
>
{
this
.
_translationsView
=
new
TranslationsView
(
state
)
;
}
error
=
>
{
TranslationsView
.
showError
(
"
translations
-
manage
-
error
-
list
"
error
)
;
}
)
;
}
initPrimaryBrowserLanguageUI
(
)
{
let
menulist
=
document
.
getElementById
(
"
primaryBrowserLocale
"
)
;
new
SelectionChangedMenulist
(
menulist
event
=
>
{
gMainPane
.
onPrimaryBrowserLanguageMenuChange
(
event
)
;
}
)
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
}
async
updatePrimaryBrowserLanguageUI
(
selected
)
{
let
available
=
await
LangPackMatcher
.
getAvailableLocales
(
)
;
let
localeNames
=
Services
.
intl
.
getLocaleDisplayNames
(
undefined
available
{
preferNative
:
true
}
)
;
let
locales
=
available
.
map
(
(
code
i
)
=
>
(
{
code
name
:
localeNames
[
i
]
}
)
)
;
locales
.
sort
(
(
a
b
)
=
>
a
.
name
>
b
.
name
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
{
code
name
}
of
locales
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
value
"
code
)
;
menuitem
.
setAttribute
(
"
label
"
name
)
;
fragment
.
appendChild
(
menuitem
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
downloadEnabled
"
)
)
{
let
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
id
=
"
primaryBrowserLocaleSearch
"
;
menuitem
.
setAttribute
(
"
label
"
await
document
.
l10n
.
formatValue
(
"
browser
-
languages
-
search
"
)
)
;
menuitem
.
setAttribute
(
"
value
"
"
search
"
)
;
fragment
.
appendChild
(
menuitem
)
;
}
let
menulist
=
document
.
getElementById
(
"
primaryBrowserLocale
"
)
;
let
menupopup
=
menulist
.
querySelector
(
"
menupopup
"
)
;
menupopup
.
textContent
=
"
"
;
menupopup
.
appendChild
(
fragment
)
;
menulist
.
value
=
selected
;
document
.
getElementById
(
"
browserLanguagesBox
"
)
.
hidden
=
false
;
}
async
showConfirmLanguageChangeMessageBar
(
locales
)
{
let
messageBar
=
document
.
getElementById
(
"
confirmBrowserLanguage
"
)
;
let
newBundle
=
getBundleForLocales
(
locales
)
;
let
messages
=
await
Promise
.
all
(
[
newBundle
document
.
l10n
]
.
map
(
async
bundle
=
>
bundle
.
formatValue
(
"
confirm
-
browser
-
language
-
change
-
description
"
)
)
)
;
let
buttonLabels
=
await
Promise
.
all
(
[
newBundle
document
.
l10n
]
.
map
(
async
bundle
=
>
bundle
.
formatValue
(
"
confirm
-
browser
-
language
-
change
-
button
"
)
)
)
;
if
(
messages
[
0
]
=
=
messages
[
1
]
&
&
buttonLabels
[
0
]
=
=
buttonLabels
[
1
]
)
{
messages
.
pop
(
)
;
buttonLabels
.
pop
(
)
;
}
let
contentContainer
=
messageBar
.
querySelector
(
"
.
message
-
bar
-
content
-
container
"
)
;
contentContainer
.
textContent
=
"
"
;
for
(
let
i
=
0
;
i
<
messages
.
length
;
i
+
+
)
{
let
messageContainer
=
document
.
createXULElement
(
"
hbox
"
)
;
messageContainer
.
classList
.
add
(
"
message
-
bar
-
content
"
)
;
messageContainer
.
style
.
flex
=
"
1
50
%
"
;
messageContainer
.
setAttribute
(
"
align
"
"
center
"
)
;
let
description
=
document
.
createXULElement
(
"
description
"
)
;
description
.
classList
.
add
(
"
message
-
bar
-
description
"
)
;
if
(
i
=
=
0
&
&
Services
.
intl
.
getScriptDirection
(
locales
[
0
]
)
=
=
=
"
rtl
"
)
{
description
.
classList
.
add
(
"
rtl
-
locale
"
)
;
}
description
.
setAttribute
(
"
flex
"
"
1
"
)
;
description
.
textContent
=
messages
[
i
]
;
messageContainer
.
appendChild
(
description
)
;
let
button
=
document
.
createXULElement
(
"
button
"
)
;
button
.
addEventListener
(
"
command
"
gMainPane
.
confirmBrowserLanguageChange
)
;
button
.
classList
.
add
(
"
message
-
bar
-
button
"
)
;
button
.
setAttribute
(
"
locales
"
locales
.
join
(
"
"
)
)
;
button
.
setAttribute
(
"
label
"
buttonLabels
[
i
]
)
;
messageContainer
.
appendChild
(
button
)
;
contentContainer
.
appendChild
(
messageContainer
)
;
}
messageBar
.
hidden
=
false
;
gMainPane
.
selectedLocalesForRestart
=
locales
;
}
hideConfirmLanguageChangeMessageBar
(
)
{
let
messageBar
=
document
.
getElementById
(
"
confirmBrowserLanguage
"
)
;
messageBar
.
hidden
=
true
;
let
contentContainer
=
messageBar
.
querySelector
(
"
.
message
-
bar
-
content
-
container
"
)
;
contentContainer
.
textContent
=
"
"
;
gMainPane
.
requestingLocales
=
null
;
}
confirmBrowserLanguageChange
(
event
)
{
let
localesString
=
(
event
.
target
.
getAttribute
(
"
locales
"
)
|
|
"
"
)
.
trim
(
)
;
if
(
!
localesString
|
|
!
localesString
.
length
)
{
return
;
}
let
locales
=
localesString
.
split
(
"
"
)
;
Services
.
locale
.
requestedLocales
=
locales
;
gMainPane
.
recordBrowserLanguagesTelemetry
(
"
apply
"
)
;
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
!
cancelQuit
.
data
)
{
Services
.
startup
.
quit
(
Services
.
startup
.
eAttemptQuit
|
Services
.
startup
.
eRestart
)
;
}
}
onPrimaryBrowserLanguageMenuChange
(
event
)
{
let
locale
=
event
.
target
.
value
;
if
(
locale
=
=
"
search
"
)
{
gMainPane
.
showBrowserLanguagesSubDialog
(
{
search
:
true
}
)
;
return
;
}
else
if
(
locale
=
=
Services
.
locale
.
appLocaleAsBCP47
)
{
this
.
hideConfirmLanguageChangeMessageBar
(
)
;
return
;
}
let
newLocales
=
Array
.
from
(
new
Set
(
[
locale
.
.
.
Services
.
locale
.
requestedLocales
]
)
.
values
(
)
)
;
gMainPane
.
recordBrowserLanguagesTelemetry
(
"
reorder
"
)
;
switch
(
gMainPane
.
getLanguageSwitchTransitionType
(
newLocales
)
)
{
case
"
requires
-
restart
"
:
gMainPane
.
showConfirmLanguageChangeMessageBar
(
newLocales
)
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
newLocales
[
0
]
)
;
break
;
case
"
live
-
reload
"
:
Services
.
locale
.
requestedLocales
=
newLocales
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
gMainPane
.
hideConfirmLanguageChangeMessageBar
(
)
;
break
;
case
"
locales
-
match
"
:
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
gMainPane
.
hideConfirmLanguageChangeMessageBar
(
)
;
break
;
default
:
throw
new
Error
(
"
Unhandled
transition
type
.
"
)
;
}
}
handleDefaultZoomChange
(
newZoom
)
{
let
cps2
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
let
nonPrivateLoadContext
=
Cu
.
createLoadContext
(
)
;
let
win
=
window
.
browsingContext
.
topChromeWindow
;
cps2
.
setGlobal
(
win
.
FullZoom
.
name
newZoom
nonPrivateLoadContext
)
;
}
async
onWindowsLaunchOnLoginChange
(
event
)
{
if
(
AppConstants
.
platform
!
=
=
"
win
"
)
{
return
;
}
if
(
event
.
target
.
checked
)
{
await
WindowsLaunchOnLogin
.
createLaunchOnLogin
(
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
startup
.
windowsLaunchOnLogin
.
disableLaunchOnLoginPrompt
"
true
)
;
}
else
{
await
WindowsLaunchOnLogin
.
removeLaunchOnLogin
(
)
;
}
}
readLinkTarget
(
)
{
var
openNewWindow
=
Preferences
.
get
(
"
browser
.
link
.
open_newwindow
"
)
;
return
openNewWindow
.
value
!
=
2
;
}
writeLinkTarget
(
)
{
var
linkTargeting
=
document
.
getElementById
(
"
linkTargeting
"
)
;
return
linkTargeting
.
checked
?
3
:
2
;
}
updateSetDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
shellSvc
=
getShellService
(
)
;
let
defaultBrowserBox
=
document
.
getElementById
(
"
defaultBrowserBox
"
)
;
let
isInFlatpak
=
gGIOService
?
.
isRunningUnderFlatpak
;
if
(
!
shellSvc
|
|
isInFlatpak
)
{
defaultBrowserBox
.
hidden
=
true
;
return
;
}
let
isDefault
=
shellSvc
.
isDefaultBrowser
(
false
true
)
;
let
setDefaultPane
=
document
.
getElementById
(
"
setDefaultPane
"
)
;
setDefaultPane
.
classList
.
toggle
(
"
is
-
default
"
isDefault
)
;
let
alwaysCheck
=
document
.
getElementById
(
"
alwaysCheckDefault
"
)
;
let
alwaysCheckPref
=
Preferences
.
get
(
"
browser
.
shell
.
checkDefaultBrowser
"
)
;
alwaysCheck
.
disabled
=
alwaysCheckPref
.
locked
|
|
isDefault
;
}
}
async
setDefaultBrowser
(
)
{
if
(
AppConstants
.
HAVE_SHELL_SERVICE
)
{
let
alwaysCheckPref
=
Preferences
.
get
(
"
browser
.
shell
.
checkDefaultBrowser
"
)
;
alwaysCheckPref
.
value
=
true
;
this
.
_backoffIndex
=
0
;
let
shellSvc
=
getShellService
(
)
;
if
(
!
shellSvc
)
{
return
;
}
let
setDefaultButton
=
document
.
getElementById
(
"
setDefaultButton
"
)
;
setDefaultButton
.
disabled
=
true
;
try
{
await
shellSvc
.
setDefaultBrowser
(
false
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
return
;
}
finally
{
setDefaultButton
.
disabled
=
false
;
}
let
isDefault
=
shellSvc
.
isDefaultBrowser
(
false
true
)
;
let
setDefaultPane
=
document
.
getElementById
(
"
setDefaultPane
"
)
;
setDefaultPane
.
classList
.
toggle
(
"
is
-
default
"
isDefault
)
;
}
}
manageProfiles
(
)
{
SelectableProfileService
.
maybeSetupDataStore
(
)
.
then
(
(
)
=
>
{
gSubDialog
.
open
(
"
about
:
profilemanager
"
)
;
}
)
;
}
showLanguages
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
languages
.
xhtml
"
)
;
}
recordBrowserLanguagesTelemetry
(
method
value
=
null
)
{
Glean
.
intlUiBrowserLanguage
[
method
+
"
Main
"
]
.
record
(
value
?
{
value
}
:
undefined
)
;
}
showBrowserLanguagesSubDialog
(
{
search
}
)
{
let
telemetryId
=
parseInt
(
Services
.
telemetry
.
msSinceProcessStart
(
)
10
)
.
toString
(
)
;
let
method
=
search
?
"
search
"
:
"
manage
"
;
gMainPane
.
recordBrowserLanguagesTelemetry
(
method
telemetryId
)
;
let
opts
=
{
selectedLocalesForRestart
:
gMainPane
.
selectedLocalesForRestart
search
telemetryId
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
browserLanguages
.
xhtml
"
{
closingCallback
:
this
.
browserLanguagesClosed
}
opts
)
;
}
getLanguageSwitchTransitionType
(
newLocales
)
{
const
{
appLocalesAsBCP47
}
=
Services
.
locale
;
if
(
appLocalesAsBCP47
.
join
(
"
"
)
=
=
=
newLocales
.
join
(
"
"
)
)
{
return
"
locales
-
match
"
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
liveReload
"
)
)
{
if
(
Services
.
intl
.
getScriptDirection
(
newLocales
[
0
]
)
!
=
=
Services
.
intl
.
getScriptDirection
(
appLocalesAsBCP47
[
0
]
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
liveReloadBidirectional
"
)
)
{
return
"
requires
-
restart
"
;
}
return
"
live
-
reload
"
;
}
return
"
requires
-
restart
"
;
}
browserLanguagesClosed
(
)
{
let
{
selected
}
=
this
.
gBrowserLanguagesDialog
;
this
.
gBrowserLanguagesDialog
.
recordTelemetry
(
selected
?
"
accept
"
:
"
cancel
"
)
;
if
(
!
selected
)
{
return
;
}
const
prevLocales
=
Services
.
locale
.
requestedLocales
.
filter
(
lc
=
>
selected
.
indexOf
(
lc
)
>
0
)
;
const
newLocales
=
selected
.
filter
(
(
lc
i
)
=
>
i
>
0
&
&
prevLocales
.
includes
(
lc
)
)
;
if
(
prevLocales
.
some
(
(
lc
i
)
=
>
newLocales
[
i
]
!
=
lc
)
)
{
this
.
gBrowserLanguagesDialog
.
recordTelemetry
(
"
setFallback
"
)
;
}
switch
(
gMainPane
.
getLanguageSwitchTransitionType
(
selected
)
)
{
case
"
requires
-
restart
"
:
gMainPane
.
showConfirmLanguageChangeMessageBar
(
selected
)
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
selected
[
0
]
)
;
break
;
case
"
live
-
reload
"
:
Services
.
locale
.
requestedLocales
=
selected
;
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
gMainPane
.
hideConfirmLanguageChangeMessageBar
(
)
;
break
;
case
"
locales
-
match
"
:
gMainPane
.
updatePrimaryBrowserLanguageUI
(
Services
.
locale
.
appLocaleAsBCP47
)
;
gMainPane
.
hideConfirmLanguageChangeMessageBar
(
)
;
break
;
default
:
throw
new
Error
(
"
Unhandled
transition
type
.
"
)
;
}
}
displayUseSystemLocale
(
)
{
let
appLocale
=
Services
.
locale
.
appLocaleAsBCP47
;
let
regionalPrefsLocales
=
Services
.
locale
.
regionalPrefsLocales
;
if
(
!
regionalPrefsLocales
.
length
)
{
return
;
}
let
systemLocale
=
regionalPrefsLocales
[
0
]
;
let
localeDisplayname
=
Services
.
intl
.
getLocaleDisplayNames
(
undefined
[
systemLocale
]
{
preferNative
:
true
}
)
;
if
(
!
localeDisplayname
.
length
)
{
return
;
}
let
localeName
=
localeDisplayname
[
0
]
;
if
(
appLocale
.
split
(
"
-
u
-
"
)
[
0
]
!
=
systemLocale
.
split
(
"
-
u
-
"
)
[
0
]
)
{
let
checkbox
=
document
.
getElementById
(
"
useSystemLocale
"
)
;
document
.
l10n
.
setAttributes
(
checkbox
"
use
-
system
-
locale
"
{
localeName
}
)
;
checkbox
.
hidden
=
false
;
}
}
showTranslationExceptions
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
translationExceptions
.
xhtml
"
)
;
}
showTranslationsSettings
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
translations
.
newSettingsUI
.
enable
"
)
)
{
const
translationsSettings
=
document
.
getElementById
(
"
translations
-
settings
-
page
"
)
;
translationsSettings
.
setAttribute
(
"
data
-
hidden
-
from
-
search
"
"
false
"
)
;
translationsSettings
.
hidden
=
false
;
gotoPref
(
"
translations
"
)
;
}
else
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
translations
.
xhtml
"
)
;
}
}
configureFonts
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
fonts
.
xhtml
"
{
features
:
"
resizable
=
no
"
}
)
;
}
configureColors
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
colors
.
xhtml
"
{
features
:
"
resizable
=
no
"
}
)
;
}
showConnections
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
connection
.
xhtml
"
{
closingCallback
:
this
.
updateProxySettingsUI
.
bind
(
this
)
}
)
;
}
async
updateProxySettingsUI
(
)
{
let
controllingExtension
=
await
getControllingExtension
(
PREF_SETTING_TYPE
PROXY_KEY
)
;
let
description
=
document
.
getElementById
(
"
connectionSettingsDescription
"
)
;
if
(
controllingExtension
)
{
setControllingExtensionDescription
(
description
controllingExtension
"
proxy
.
settings
"
)
;
}
else
{
setControllingExtensionDescription
(
description
null
"
network
-
proxy
-
connection
-
description
"
)
;
}
}
async
checkBrowserContainers
(
)
{
let
checkbox
=
document
.
getElementById
(
"
browserContainersCheckbox
"
)
;
if
(
checkbox
.
checked
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
true
)
;
return
;
}
let
count
=
ContextualIdentityService
.
countContainerTabs
(
)
;
if
(
count
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
let
[
title
message
okButton
cancelButton
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
containers
-
disable
-
alert
-
title
"
}
{
id
:
"
containers
-
disable
-
alert
-
desc
"
args
:
{
tabCount
:
count
}
}
{
id
:
"
containers
-
disable
-
alert
-
ok
-
button
"
args
:
{
tabCount
:
count
}
}
{
id
:
"
containers
-
disable
-
alert
-
cancel
-
button
"
}
]
)
;
let
buttonFlags
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
+
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
;
let
rv
=
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
if
(
rv
=
=
0
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
;
return
;
}
checkbox
.
checked
=
true
;
}
showContainerSettings
(
)
{
gotoPref
(
"
containers
"
)
;
}
_rebuildFonts
(
)
{
var
langGroupPref
=
Preferences
.
get
(
"
font
.
language
.
group
"
)
;
var
isSerif
=
this
.
_readDefaultFontTypeForLanguage
(
langGroupPref
.
value
)
=
=
"
serif
"
;
this
.
_selectDefaultLanguageGroup
(
langGroupPref
.
value
isSerif
)
;
}
_readDefaultFontTypeForLanguage
(
aLanguageGroup
)
{
const
kDefaultFontType
=
"
font
.
default
.
%
LANG
%
"
;
var
defaultFontTypePref
=
kDefaultFontType
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
;
var
preference
=
Preferences
.
get
(
defaultFontTypePref
)
;
if
(
!
preference
)
{
preference
=
Preferences
.
add
(
{
id
:
defaultFontTypePref
type
:
"
string
"
}
)
;
preference
.
on
(
"
change
"
gMainPane
.
_rebuildFonts
.
bind
(
gMainPane
)
)
;
}
return
preference
.
value
;
}
_selectDefaultLanguageGroupPromise
:
Promise
.
resolve
(
)
_selectDefaultLanguageGroup
(
aLanguageGroup
aIsSerif
)
{
this
.
_selectDefaultLanguageGroupPromise
=
(
async
(
)
=
>
{
await
this
.
_selectDefaultLanguageGroupPromise
;
const
kFontNameFmtSerif
=
"
font
.
name
.
serif
.
%
LANG
%
"
;
const
kFontNameFmtSansSerif
=
"
font
.
name
.
sans
-
serif
.
%
LANG
%
"
;
const
kFontNameListFmtSerif
=
"
font
.
name
-
list
.
serif
.
%
LANG
%
"
;
const
kFontNameListFmtSansSerif
=
"
font
.
name
-
list
.
sans
-
serif
.
%
LANG
%
"
;
const
kFontSizeFmtVariable
=
"
font
.
size
.
variable
.
%
LANG
%
"
;
var
prefs
=
[
{
format
:
aIsSerif
?
kFontNameFmtSerif
:
kFontNameFmtSansSerif
type
:
"
fontname
"
element
:
"
defaultFont
"
fonttype
:
aIsSerif
?
"
serif
"
:
"
sans
-
serif
"
}
{
format
:
aIsSerif
?
kFontNameListFmtSerif
:
kFontNameListFmtSansSerif
type
:
"
unichar
"
element
:
null
fonttype
:
aIsSerif
?
"
serif
"
:
"
sans
-
serif
"
}
{
format
:
kFontSizeFmtVariable
type
:
"
int
"
element
:
"
defaultFontSize
"
fonttype
:
null
}
]
;
for
(
var
i
=
0
;
i
<
prefs
.
length
;
+
+
i
)
{
var
preference
=
Preferences
.
get
(
prefs
[
i
]
.
format
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
)
;
if
(
!
preference
)
{
var
name
=
prefs
[
i
]
.
format
.
replace
(
/
%
LANG
%
/
aLanguageGroup
)
;
preference
=
Preferences
.
add
(
{
id
:
name
type
:
prefs
[
i
]
.
type
}
)
;
}
if
(
!
prefs
[
i
]
.
element
)
{
continue
;
}
var
element
=
document
.
getElementById
(
prefs
[
i
]
.
element
)
;
if
(
element
)
{
element
.
setAttribute
(
"
preference
"
preference
.
id
)
;
if
(
prefs
[
i
]
.
fonttype
)
{
await
FontBuilder
.
buildFontList
(
aLanguageGroup
prefs
[
i
]
.
fonttype
element
)
;
}
preference
.
setElementValue
(
element
)
;
}
}
}
)
(
)
.
catch
(
console
.
error
)
;
}
onMigrationButtonCommand
(
)
{
const
browserWindow
=
window
.
browsingContext
.
topChromeWindow
;
MigrationUtils
.
showMigrationWizard
(
browserWindow
{
entrypoint
:
MigrationUtils
.
MIGRATION_ENTRYPOINTS
.
PREFERENCES
}
)
;
}
async
showMigrationWizardDialog
(
{
closeTabWhenDone
=
false
}
=
{
}
)
{
let
migrationWizardDialog
=
document
.
getElementById
(
"
migrationWizardDialog
"
)
;
if
(
migrationWizardDialog
.
open
)
{
return
;
}
await
customElements
.
whenDefined
(
"
migration
-
wizard
"
)
;
if
(
!
migrationWizardDialog
.
firstElementChild
)
{
let
wizard
=
document
.
createElement
(
"
migration
-
wizard
"
)
;
wizard
.
toggleAttribute
(
"
dialog
-
mode
"
true
)
;
migrationWizardDialog
.
appendChild
(
wizard
)
;
}
migrationWizardDialog
.
firstElementChild
.
requestState
(
)
;
migrationWizardDialog
.
addEventListener
(
"
close
"
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
migrationWizardDialog
"
MigrationWizard
:
Closed
"
)
;
if
(
closeTabWhenDone
)
{
window
.
close
(
)
;
}
}
{
once
:
true
}
)
;
migrationWizardDialog
.
showModal
(
)
;
}
_storedSpellCheck
:
0
readCheckSpelling
(
)
{
var
pref
=
Preferences
.
get
(
"
layout
.
spellcheckDefault
"
)
;
this
.
_storedSpellCheck
=
pref
.
value
;
return
pref
.
value
!
=
0
;
}
writeCheckSpelling
(
)
{
var
checkbox
=
document
.
getElementById
(
"
checkSpelling
"
)
;
if
(
checkbox
.
checked
)
{
if
(
this
.
_storedSpellCheck
=
=
2
)
{
return
2
;
}
return
1
;
}
return
0
;
}
_minUpdatePrefDisableTime
:
1000
async
readUpdateAutoPref
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
&
&
(
!
Services
.
policies
|
|
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
&
&
!
gIsPackagedApp
)
{
let
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
radiogroup
.
disabled
=
true
;
let
enabled
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
radiogroup
.
value
=
enabled
;
radiogroup
.
disabled
=
false
;
this
.
maybeDisableBackgroundUpdateControls
(
)
;
}
}
async
writeUpdateAutoPref
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
&
&
(
!
Services
.
policies
|
|
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
&
&
!
gIsPackagedApp
)
{
let
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
let
updateAutoValue
=
radiogroup
.
value
=
=
"
true
"
;
let
_disableTimeOverPromise
=
new
Promise
(
r
=
>
setTimeout
(
r
this
.
_minUpdatePrefDisableTime
)
)
;
radiogroup
.
disabled
=
true
;
try
{
await
UpdateUtils
.
setAppUpdateAutoEnabled
(
updateAutoValue
)
;
await
_disableTimeOverPromise
;
radiogroup
.
disabled
=
false
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
await
Promise
.
all
(
[
this
.
readUpdateAutoPref
(
)
this
.
reportUpdatePrefWriteError
(
)
]
)
;
return
;
}
this
.
maybeDisableBackgroundUpdateControls
(
)
;
if
(
!
updateAutoValue
)
{
await
this
.
checkUpdateInProgress
(
)
;
}
radiogroup
.
dispatchEvent
(
new
CustomEvent
(
"
ProcessedUpdatePrefChange
"
)
)
;
}
}
isBackgroundUpdateUIAvailable
(
)
{
return
(
AppConstants
.
MOZ_UPDATE_AGENT
&
&
UpdateUtils
.
PER_INSTALLATION_PREFS_SUPPORTED
&
&
(
!
Services
.
policies
|
|
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
&
&
!
gIsPackagedApp
&
&
!
UpdateUtils
.
appUpdateSettingIsLocked
(
"
app
.
update
.
background
.
enabled
"
)
)
;
}
maybeDisableBackgroundUpdateControls
(
)
{
if
(
this
.
isBackgroundUpdateUIAvailable
(
)
)
{
let
radiogroup
=
document
.
getElementById
(
"
updateRadioGroup
"
)
;
let
updateAutoEnabled
=
radiogroup
.
value
=
=
"
true
"
;
document
.
getElementById
(
"
backgroundUpdate
"
)
.
disabled
=
!
updateAutoEnabled
;
}
}
async
readBackgroundUpdatePref
(
)
{
const
prefName
=
"
app
.
update
.
background
.
enabled
"
;
if
(
this
.
isBackgroundUpdateUIAvailable
(
)
)
{
let
backgroundCheckbox
=
document
.
getElementById
(
"
backgroundUpdate
"
)
;
backgroundCheckbox
.
disabled
=
true
;
await
BackgroundUpdate
.
ensureExperimentToRolloutTransitionPerformed
(
)
;
let
enabled
=
await
UpdateUtils
.
readUpdateConfigSetting
(
prefName
)
;
backgroundCheckbox
.
checked
=
enabled
;
this
.
maybeDisableBackgroundUpdateControls
(
)
;
}
}
async
writeBackgroundUpdatePref
(
)
{
const
prefName
=
"
app
.
update
.
background
.
enabled
"
;
if
(
this
.
isBackgroundUpdateUIAvailable
(
)
)
{
let
backgroundCheckbox
=
document
.
getElementById
(
"
backgroundUpdate
"
)
;
backgroundCheckbox
.
disabled
=
true
;
let
backgroundUpdateEnabled
=
backgroundCheckbox
.
checked
;
try
{
await
UpdateUtils
.
writeUpdateConfigSetting
(
prefName
backgroundUpdateEnabled
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
await
this
.
readBackgroundUpdatePref
(
)
;
await
this
.
reportUpdatePrefWriteError
(
)
;
return
;
}
this
.
maybeDisableBackgroundUpdateControls
(
)
;
}
}
async
reportUpdatePrefWriteError
(
)
{
let
[
title
message
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
update
-
setting
-
write
-
failure
-
title2
"
}
{
id
:
"
update
-
setting
-
write
-
failure
-
message2
"
args
:
{
path
:
UpdateUtils
.
configFilePath
}
}
]
)
;
let
buttonFlags
=
Services
.
prompt
.
BUTTON_POS_0
*
Services
.
prompt
.
BUTTON_TITLE_OK
;
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
null
null
null
null
{
}
)
;
}
async
checkUpdateInProgress
(
)
{
const
aus
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationUpdateService
)
;
let
um
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
;
await
aus
.
init
(
)
;
if
(
aus
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
{
return
;
}
let
[
title
message
okButton
cancelButton
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
update
-
in
-
progress
-
title
"
}
{
id
:
"
update
-
in
-
progress
-
message
"
}
{
id
:
"
update
-
in
-
progress
-
ok
-
button
"
}
{
id
:
"
update
-
in
-
progress
-
cancel
-
button
"
}
]
)
;
let
buttonFlags
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
+
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
+
Ci
.
nsIPrompt
.
BUTTON_POS_1_DEFAULT
;
let
rv
=
Services
.
prompt
.
confirmEx
(
window
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
if
(
rv
!
=
1
)
{
await
aus
.
stopDownload
(
)
;
await
um
.
cleanupActiveUpdates
(
)
;
UpdateListener
.
clearPendingAndActiveNotifications
(
)
;
}
}
showUpdates
(
)
{
gSubDialog
.
open
(
"
chrome
:
/
/
mozapps
/
content
/
update
/
history
.
xhtml
"
)
;
}
destroy
(
)
{
window
.
removeEventListener
(
"
unload
"
this
)
;
Services
.
prefs
.
removeObserver
(
PREF_CONTAINERS_EXTENSION
this
)
;
Services
.
obs
.
removeObserver
(
this
AUTO_UPDATE_CHANGED_TOPIC
)
;
Services
.
obs
.
removeObserver
(
this
BACKGROUND_UPDATE_CHANGED_TOPIC
)
;
if
(
this
.
_translationsView
)
{
this
.
_translationsView
.
destroy
(
)
;
this
.
_translationsView
=
null
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
async
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
)
{
if
(
aData
=
=
PREF_CONTAINERS_EXTENSION
)
{
this
.
readBrowserContainersCheckbox
(
)
;
return
;
}
if
(
!
this
.
_storingAction
)
{
await
this
.
_rebuildView
(
)
;
}
}
else
if
(
aTopic
=
=
AUTO_UPDATE_CHANGED_TOPIC
)
{
if
(
!
AppConstants
.
MOZ_UPDATER
)
{
return
;
}
if
(
aData
!
=
"
true
"
&
&
aData
!
=
"
false
"
)
{
throw
new
Error
(
"
Invalid
preference
value
for
app
.
update
.
auto
"
)
;
}
document
.
getElementById
(
"
updateRadioGroup
"
)
.
value
=
aData
;
this
.
maybeDisableBackgroundUpdateControls
(
)
;
}
else
if
(
aTopic
=
=
BACKGROUND_UPDATE_CHANGED_TOPIC
)
{
if
(
!
AppConstants
.
MOZ_UPDATE_AGENT
)
{
return
;
}
if
(
aData
!
=
"
true
"
&
&
aData
!
=
"
false
"
)
{
throw
new
Error
(
"
Invalid
preference
value
for
app
.
update
.
background
.
enabled
"
)
;
}
document
.
getElementById
(
"
backgroundUpdate
"
)
.
checked
=
aData
=
=
"
true
"
;
}
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
=
=
"
unload
"
)
{
this
.
destroy
(
)
;
if
(
AppConstants
.
MOZ_UPDATER
)
{
onUnload
(
)
;
}
}
}
_loadData
(
)
{
this
.
_loadInternalHandlers
(
)
;
this
.
_loadApplicationHandlers
(
)
;
}
_loadInternalHandlers
(
)
{
let
internalHandlers
=
[
new
PDFHandlerInfoWrapper
(
)
]
;
let
enabledHandlers
=
Services
.
prefs
.
getCharPref
(
"
browser
.
download
.
viewableInternally
.
enabledTypes
"
"
"
)
.
trim
(
)
;
if
(
enabledHandlers
)
{
for
(
let
ext
of
enabledHandlers
.
split
(
"
"
)
)
{
internalHandlers
.
push
(
new
ViewableInternallyHandlerInfoWrapper
(
null
ext
.
trim
(
)
)
)
;
}
}
for
(
let
internalHandler
of
internalHandlers
)
{
if
(
internalHandler
.
enabled
)
{
this
.
_handledTypes
[
internalHandler
.
type
]
=
internalHandler
;
}
}
}
_loadApplicationHandlers
(
)
{
for
(
let
wrappedHandlerInfo
of
gHandlerService
.
enumerate
(
)
)
{
let
type
=
wrappedHandlerInfo
.
type
;
let
handlerInfoWrapper
;
if
(
type
in
this
.
_handledTypes
)
{
handlerInfoWrapper
=
this
.
_handledTypes
[
type
]
;
}
else
{
if
(
DownloadIntegration
.
shouldViewDownloadInternally
(
type
)
)
{
handlerInfoWrapper
=
new
ViewableInternallyHandlerInfoWrapper
(
type
)
;
}
else
{
handlerInfoWrapper
=
new
HandlerInfoWrapper
(
type
wrappedHandlerInfo
)
;
}
this
.
_handledTypes
[
type
]
=
handlerInfoWrapper
;
}
}
}
selectedHandlerListItem
:
null
_initListEventHandlers
(
)
{
this
.
_list
.
addEventListener
(
"
select
"
event
=
>
{
if
(
event
.
target
!
=
this
.
_list
)
{
return
;
}
let
handlerListItem
=
this
.
_list
.
selectedItem
&
&
HandlerListItem
.
forNode
(
this
.
_list
.
selectedItem
)
;
if
(
this
.
selectedHandlerListItem
=
=
handlerListItem
)
{
return
;
}
if
(
this
.
selectedHandlerListItem
)
{
this
.
selectedHandlerListItem
.
showActionsMenu
=
false
;
}
this
.
selectedHandlerListItem
=
handlerListItem
;
if
(
handlerListItem
)
{
this
.
rebuildActionsMenu
(
)
;
handlerListItem
.
showActionsMenu
=
true
;
}
}
)
;
}
async
_rebuildVisibleTypes
(
)
{
this
.
_visibleTypes
=
[
]
;
let
visibleDescriptions
=
new
Map
(
)
;
for
(
let
type
in
this
.
_handledTypes
)
{
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
let
handlerInfo
=
this
.
_handledTypes
[
type
]
;
this
.
_visibleTypes
.
push
(
handlerInfo
)
;
let
key
=
JSON
.
stringify
(
handlerInfo
.
description
)
;
let
otherHandlerInfo
=
visibleDescriptions
.
get
(
key
)
;
if
(
!
otherHandlerInfo
)
{
handlerInfo
.
disambiguateDescription
=
false
;
visibleDescriptions
.
set
(
key
handlerInfo
)
;
}
else
{
handlerInfo
.
disambiguateDescription
=
true
;
otherHandlerInfo
.
disambiguateDescription
=
true
;
}
}
}
async
_rebuildView
(
)
{
let
lastSelectedType
=
this
.
selectedHandlerListItem
&
&
this
.
selectedHandlerListItem
.
handlerInfoWrapper
.
type
;
this
.
selectedHandlerListItem
=
null
;
this
.
_list
.
textContent
=
"
"
;
var
visibleTypes
=
this
.
_visibleTypes
;
let
items
=
visibleTypes
.
map
(
visibleType
=
>
new
HandlerListItem
(
visibleType
)
)
;
let
itemsFragment
=
document
.
createDocumentFragment
(
)
;
let
lastSelectedItem
;
for
(
let
item
of
items
)
{
item
.
createNode
(
itemsFragment
)
;
if
(
item
.
handlerInfoWrapper
.
type
=
=
lastSelectedType
)
{
lastSelectedItem
=
item
;
}
}
for
(
let
item
of
items
)
{
item
.
setupNode
(
)
;
this
.
rebuildActionsMenu
(
item
.
node
item
.
handlerInfoWrapper
)
;
item
.
refreshAction
(
)
;
}
if
(
this
.
_filter
.
value
)
{
await
document
.
l10n
.
translateFragment
(
itemsFragment
)
;
this
.
_filterView
(
itemsFragment
)
;
document
.
l10n
.
pauseObserving
(
)
;
this
.
_list
.
appendChild
(
itemsFragment
)
;
document
.
l10n
.
resumeObserving
(
)
;
}
else
{
this
.
_list
.
appendChild
(
itemsFragment
)
;
}
if
(
lastSelectedItem
)
{
this
.
_list
.
selectedItem
=
lastSelectedItem
.
node
;
}
}
isValidHandlerApp
(
aHandlerApp
)
{
if
(
!
aHandlerApp
)
{
return
false
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
{
return
this
.
_isValidHandlerExecutable
(
aHandlerApp
.
executable
)
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
{
return
aHandlerApp
.
uriTemplate
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIGIOMimeApp
)
{
return
aHandlerApp
.
command
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIGIOHandlerApp
)
{
return
aHandlerApp
.
id
;
}
return
false
;
}
_isValidHandlerExecutable
(
aExecutable
)
{
let
leafName
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
leafName
=
{
AppConstants
.
MOZ_APP_NAME
}
.
exe
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
leafName
=
AppConstants
.
MOZ_MACBUNDLE_NAME
;
}
else
{
leafName
=
{
AppConstants
.
MOZ_APP_NAME
}
-
bin
;
}
return
(
aExecutable
&
&
aExecutable
.
exists
(
)
&
&
aExecutable
.
isExecutable
(
)
&
&
aExecutable
.
leafName
!
=
leafName
)
;
}
rebuildActionsMenu
(
typeItem
=
this
.
_list
.
selectedItem
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
)
{
var
menu
=
typeItem
.
querySelector
(
"
.
actionsMenu
"
)
;
var
menuPopup
=
menu
.
menupopup
;
while
(
menuPopup
.
hasChildNodes
(
)
)
{
menuPopup
.
removeChild
(
menuPopup
.
lastChild
)
;
}
let
internalMenuItem
;
if
(
handlerInfo
instanceof
InternalHandlerInfoWrapper
&
&
!
handlerInfo
.
preventInternalViewing
)
{
internalMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
internalMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
handleInternally
)
;
internalMenuItem
.
className
=
"
menuitem
-
iconic
"
;
document
.
l10n
.
setAttributes
(
internalMenuItem
"
applications
-
open
-
inapp
"
)
;
internalMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
handleInternally
"
)
;
menuPopup
.
appendChild
(
internalMenuItem
)
;
}
var
askMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
askMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
alwaysAsk
)
;
askMenuItem
.
className
=
"
menuitem
-
iconic
"
;
document
.
l10n
.
setAttributes
(
askMenuItem
"
applications
-
always
-
ask
"
)
;
askMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
ask
"
)
;
menuPopup
.
appendChild
(
askMenuItem
)
;
if
(
handlerInfo
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
{
var
saveMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
saveMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
saveToDisk
)
;
document
.
l10n
.
setAttributes
(
saveMenuItem
"
applications
-
action
-
save
"
)
;
saveMenuItem
.
setAttribute
(
APP_ICON_ATTR_NAME
"
save
"
)
;
saveMenuItem
.
className
=
"
menuitem
-
iconic
"
;
menuPopup
.
appendChild
(
saveMenuItem
)
;
}
let
menuseparator
=
document
.
createXULElement
(
"
menuseparator
"
)
;
menuPopup
.
appendChild
(
menuseparator
)
;
if
(
handlerInfo
.
hasDefaultHandler
)
{
var
defaultMenuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
defaultMenuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useSystemDefault
)
;
if
(
internalMenuItem
)
{
document
.
l10n
.
setAttributes
(
defaultMenuItem
"
applications
-
use
-
os
-
default
"
)
;
defaultMenuItem
.
setAttribute
(
"
image
"
ICON_URL_APP
)
;
}
else
{
document
.
l10n
.
setAttributes
(
defaultMenuItem
"
applications
-
use
-
app
-
default
"
{
"
app
-
name
"
:
handlerInfo
.
defaultDescription
}
)
;
let
image
=
handlerInfo
.
iconURLForSystemDefault
;
if
(
image
)
{
defaultMenuItem
.
setAttribute
(
"
image
"
image
)
;
}
}
menuPopup
.
appendChild
(
defaultMenuItem
)
;
}
let
preferredApp
=
handlerInfo
.
preferredApplicationHandler
;
var
possibleAppMenuItems
=
[
]
;
for
(
let
possibleApp
of
handlerInfo
.
possibleApplicationHandlers
.
enumerate
(
)
)
{
if
(
!
this
.
isValidHandlerApp
(
possibleApp
)
)
{
continue
;
}
let
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
let
label
;
if
(
possibleApp
instanceof
Ci
.
nsILocalHandlerApp
)
{
label
=
getFileDisplayName
(
possibleApp
.
executable
)
;
}
else
{
label
=
possibleApp
.
name
;
}
document
.
l10n
.
setAttributes
(
menuItem
"
applications
-
use
-
app
"
{
"
app
-
name
"
:
label
}
)
;
let
image
=
this
.
_getIconURLForHandlerApp
(
possibleApp
)
;
if
(
image
)
{
menuItem
.
setAttribute
(
"
image
"
image
)
;
}
menuItem
.
handlerApp
=
possibleApp
;
menuPopup
.
appendChild
(
menuItem
)
;
possibleAppMenuItems
.
push
(
menuItem
)
;
}
if
(
gGIOService
)
{
var
gioApps
=
gGIOService
.
getAppsForURIScheme
(
handlerInfo
.
type
)
;
let
possibleHandlers
=
handlerInfo
.
possibleApplicationHandlers
;
for
(
let
handler
of
gioApps
.
enumerate
(
Ci
.
nsIHandlerApp
)
)
{
if
(
handler
.
name
=
=
handlerInfo
.
defaultDescription
)
{
continue
;
}
let
appAlreadyInHandlers
=
false
;
for
(
let
i
=
possibleHandlers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
app
=
possibleHandlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
equals
(
app
)
)
{
appAlreadyInHandlers
=
true
;
break
;
}
}
if
(
!
appAlreadyInHandlers
)
{
let
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
setAttribute
(
"
action
"
Ci
.
nsIHandlerInfo
.
useHelperApp
)
;
document
.
l10n
.
setAttributes
(
menuItem
"
applications
-
use
-
app
"
{
"
app
-
name
"
:
handler
.
name
}
)
;
let
image
=
this
.
_getIconURLForHandlerApp
(
handler
)
;
if
(
image
)
{
menuItem
.
setAttribute
(
"
image
"
image
)
;
}
menuItem
.
handlerApp
=
handler
;
menuPopup
.
appendChild
(
menuItem
)
;
possibleAppMenuItems
.
push
(
menuItem
)
;
}
}
}
let
canOpenWithOtherApp
=
true
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
executableType
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
.
getTypeFromExtension
(
"
exe
"
)
;
canOpenWithOtherApp
=
handlerInfo
.
type
!
=
executableType
;
}
if
(
canOpenWithOtherApp
)
{
let
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
className
=
"
choose
-
app
-
item
"
;
menuItem
.
addEventListener
(
"
command
"
function
(
e
)
{
gMainPane
.
chooseApp
(
e
)
;
}
)
;
document
.
l10n
.
setAttributes
(
menuItem
"
applications
-
use
-
other
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
}
if
(
possibleAppMenuItems
.
length
)
{
let
menuItem
=
document
.
createXULElement
(
"
menuseparator
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
menuItem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuItem
.
className
=
"
manage
-
app
-
item
"
;
menuItem
.
addEventListener
(
"
command
"
function
(
e
)
{
gMainPane
.
manageApp
(
e
)
;
}
)
;
document
.
l10n
.
setAttributes
(
menuItem
"
applications
-
manage
-
app
"
)
;
menuPopup
.
appendChild
(
menuItem
)
;
}
if
(
handlerInfo
.
alwaysAskBeforeHandling
)
{
menu
.
selectedItem
=
askMenuItem
;
}
else
{
const
kActionUsePlugin
=
5
;
switch
(
handlerInfo
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
internalMenuItem
)
{
menu
.
selectedItem
=
internalMenuItem
;
}
else
{
console
.
error
(
"
No
menu
item
defined
to
set
!
"
)
;
}
break
;
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
menu
.
selectedItem
=
defaultMenuItem
|
|
askMenuItem
;
break
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
if
(
preferredApp
)
{
let
preferredItem
=
possibleAppMenuItems
.
find
(
v
=
>
v
.
handlerApp
.
equals
(
preferredApp
)
)
;
if
(
preferredItem
)
{
menu
.
selectedItem
=
preferredItem
;
}
else
{
let
possible
=
possibleAppMenuItems
.
map
(
v
=
>
v
.
handlerApp
&
&
v
.
handlerApp
.
name
)
.
join
(
"
"
)
;
console
.
error
(
new
Error
(
Preferred
handler
for
{
handlerInfo
.
type
}
not
in
list
of
possible
handlers
!
?
(
List
:
{
possible
}
)
)
)
;
menu
.
selectedItem
=
askMenuItem
;
}
}
break
;
case
kActionUsePlugin
:
menu
.
selectedItem
=
askMenuItem
;
break
;
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
menu
.
selectedItem
=
saveMenuItem
;
break
;
}
}
}
_sortColumn
:
null
sort
(
event
)
{
if
(
event
.
button
!
=
0
)
{
return
;
}
var
column
=
event
.
target
;
if
(
this
.
_sortColumn
&
&
this
.
_sortColumn
!
=
column
)
{
this
.
_sortColumn
.
removeAttribute
(
"
sortDirection
"
)
;
}
this
.
_sortColumn
=
column
;
if
(
column
.
getAttribute
(
"
sortDirection
"
)
=
=
"
ascending
"
)
{
column
.
setAttribute
(
"
sortDirection
"
"
descending
"
)
;
}
else
{
column
.
setAttribute
(
"
sortDirection
"
"
ascending
"
)
;
}
this
.
_sortListView
(
)
;
}
async
_sortListView
(
)
{
if
(
!
this
.
_sortColumn
)
{
return
;
}
let
comp
=
new
Services
.
intl
.
Collator
(
undefined
{
usage
:
"
sort
"
}
)
;
await
document
.
l10n
.
translateFragment
(
this
.
_list
)
;
let
items
=
Array
.
from
(
this
.
_list
.
children
)
;
let
textForNode
;
if
(
this
.
_sortColumn
.
getAttribute
(
"
value
"
)
=
=
=
"
type
"
)
{
textForNode
=
n
=
>
n
.
querySelector
(
"
.
typeDescription
"
)
.
textContent
;
}
else
{
textForNode
=
n
=
>
n
.
querySelector
(
"
.
actionsMenu
"
)
.
getAttribute
(
"
label
"
)
;
}
let
sortDir
=
this
.
_sortColumn
.
getAttribute
(
"
sortDirection
"
)
;
let
multiplier
=
sortDir
=
=
"
descending
"
?
-
1
:
1
;
items
.
sort
(
(
a
b
)
=
>
multiplier
*
comp
.
compare
(
textForNode
(
a
)
textForNode
(
b
)
)
)
;
items
.
forEach
(
item
=
>
this
.
_list
.
appendChild
(
item
)
)
;
}
_filterView
(
frag
=
this
.
_list
)
{
const
filterValue
=
this
.
_filter
.
value
.
toLowerCase
(
)
;
for
(
let
elem
of
frag
.
children
)
{
const
typeDescription
=
elem
.
querySelector
(
"
.
typeDescription
"
)
.
textContent
;
const
actionDescription
=
elem
.
querySelector
(
"
.
actionDescription
"
)
.
getAttribute
(
"
value
"
)
;
elem
.
hidden
=
!
typeDescription
.
toLowerCase
(
)
.
includes
(
filterValue
)
&
&
!
actionDescription
.
toLowerCase
(
)
.
includes
(
filterValue
)
;
}
}
filter
(
)
{
this
.
_rebuildView
(
)
;
}
focusFilterBox
(
)
{
this
.
_filter
.
focus
(
)
;
this
.
_filter
.
select
(
)
;
}
_storingAction
:
false
onSelectAction
(
aActionItem
)
{
this
.
_storingAction
=
true
;
try
{
this
.
_storeAction
(
aActionItem
)
;
}
finally
{
this
.
_storingAction
=
false
;
}
}
_storeAction
(
aActionItem
)
{
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
let
action
=
parseInt
(
aActionItem
.
getAttribute
(
"
action
"
)
)
;
if
(
action
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
)
{
handlerInfo
.
preferredApplicationHandler
=
aActionItem
.
handlerApp
;
}
if
(
action
=
=
Ci
.
nsIHandlerInfo
.
alwaysAsk
)
{
handlerInfo
.
alwaysAskBeforeHandling
=
true
;
}
else
{
handlerInfo
.
alwaysAskBeforeHandling
=
false
;
}
handlerInfo
.
preferredAction
=
action
;
handlerInfo
.
store
(
)
;
this
.
selectedHandlerListItem
.
refreshAction
(
)
;
}
manageApp
(
aEvent
)
{
aEvent
.
stopPropagation
(
)
;
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
let
onComplete
=
(
)
=
>
{
this
.
rebuildActionsMenu
(
)
;
this
.
selectedHandlerListItem
.
refreshAction
(
)
;
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
applicationManager
.
xhtml
"
{
features
:
"
resizable
=
no
"
closingCallback
:
onComplete
}
handlerInfo
)
;
}
async
chooseApp
(
aEvent
)
{
aEvent
.
stopPropagation
(
)
;
var
handlerApp
;
let
chooseAppCallback
=
aHandlerApp
=
>
{
this
.
rebuildActionsMenu
(
)
;
if
(
aHandlerApp
)
{
let
typeItem
=
this
.
_list
.
selectedItem
;
let
actionsMenu
=
typeItem
.
querySelector
(
"
.
actionsMenu
"
)
;
let
menuItems
=
actionsMenu
.
menupopup
.
childNodes
;
for
(
let
i
=
0
;
i
<
menuItems
.
length
;
i
+
+
)
{
let
menuItem
=
menuItems
[
i
]
;
if
(
menuItem
.
handlerApp
&
&
menuItem
.
handlerApp
.
equals
(
aHandlerApp
)
)
{
actionsMenu
.
selectedIndex
=
i
;
this
.
onSelectAction
(
menuItem
)
;
break
;
}
}
}
}
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
var
params
=
{
}
;
var
handlerInfo
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
params
.
mimeInfo
=
handlerInfo
.
wrappedHandlerInfo
;
params
.
title
=
await
document
.
l10n
.
formatValue
(
"
applications
-
select
-
helper
"
)
;
if
(
"
id
"
in
handlerInfo
.
description
)
{
params
.
description
=
await
document
.
l10n
.
formatValue
(
handlerInfo
.
description
.
id
handlerInfo
.
description
.
args
)
;
}
else
{
params
.
description
=
handlerInfo
.
typeDescription
.
raw
;
}
params
.
filename
=
null
;
params
.
handlerApp
=
null
;
let
onAppSelected
=
(
)
=
>
{
if
(
this
.
isValidHandlerApp
(
params
.
handlerApp
)
)
{
handlerApp
=
params
.
handlerApp
;
handlerInfo
.
addPossibleApplicationHandler
(
handlerApp
)
;
}
chooseAppCallback
(
handlerApp
)
;
}
;
gSubDialog
.
open
(
"
chrome
:
/
/
global
/
content
/
appPicker
.
xhtml
"
{
closingCallback
:
onAppSelected
}
params
)
;
}
else
{
let
winTitle
=
await
document
.
l10n
.
formatValue
(
"
applications
-
select
-
helper
"
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
let
fpCallback
=
aResult
=
>
{
if
(
aResult
=
=
Ci
.
nsIFilePicker
.
returnOK
&
&
fp
.
file
&
&
this
.
_isValidHandlerExecutable
(
fp
.
file
)
)
{
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
name
=
getFileDisplayName
(
fp
.
file
)
;
handlerApp
.
executable
=
fp
.
file
;
let
handler
=
this
.
selectedHandlerListItem
.
handlerInfoWrapper
;
handler
.
addPossibleApplicationHandler
(
handlerApp
)
;
chooseAppCallback
(
handlerApp
)
;
}
}
;
fp
.
init
(
window
.
browsingContext
winTitle
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterApps
)
;
fp
.
open
(
fpCallback
)
;
}
}
_getIconURLForHandlerApp
(
aHandlerApp
)
{
if
(
aHandlerApp
instanceof
Ci
.
nsILocalHandlerApp
)
{
return
this
.
_getIconURLForFile
(
aHandlerApp
.
executable
)
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIWebHandlerApp
)
{
return
this
.
_getIconURLForWebApp
(
aHandlerApp
.
uriTemplate
)
;
}
if
(
aHandlerApp
instanceof
Ci
.
nsIGIOHandlerApp
)
{
return
this
.
_getIconURLForAppId
(
aHandlerApp
.
id
)
;
}
return
"
"
;
}
_getIconURLForAppId
(
aAppId
)
{
return
"
moz
-
icon
:
/
/
"
+
aAppId
+
"
?
size
=
16
"
;
}
_getIconURLForFile
(
aFile
)
{
var
fph
=
Services
.
io
.
getProtocolHandler
(
"
file
"
)
.
QueryInterface
(
Ci
.
nsIFileProtocolHandler
)
;
var
urlSpec
=
fph
.
getURLSpecFromActualFile
(
aFile
)
;
return
"
moz
-
icon
:
/
/
"
+
urlSpec
+
"
?
size
=
16
"
;
}
_getIconURLForWebApp
(
aWebAppURITemplate
)
{
var
uri
=
Services
.
io
.
newURI
(
aWebAppURITemplate
)
;
if
(
/
^
https
?
/
.
test
(
uri
.
scheme
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
chrome
.
site_icons
"
)
)
{
return
uri
.
prePath
+
"
/
favicon
.
ico
"
;
}
return
"
"
;
}
}
;
gMainPane
.
initialized
=
new
Promise
(
res
=
>
{
gMainPane
.
setInitialized
=
res
;
}
)
;
function
getFileDisplayName
(
file
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileWin
)
{
try
{
return
file
.
getVersionInfoField
(
"
FileDescription
"
)
;
}
catch
(
e
)
{
}
}
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
if
(
file
instanceof
Ci
.
nsILocalFileMac
)
{
try
{
return
file
.
bundleDisplayName
;
}
catch
(
e
)
{
}
}
}
return
file
.
leafName
;
}
function
getLocalHandlerApp
(
aFile
)
{
var
localHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandlerApp
.
name
=
getFileDisplayName
(
aFile
)
;
localHandlerApp
.
executable
=
aFile
;
return
localHandlerApp
;
}
let
gHandlerListItemFragment
=
MozXULElement
.
parseXULToFragment
(
<
richlistitem
>
<
hbox
class
=
"
typeContainer
"
flex
=
"
1
"
align
=
"
center
"
>
<
html
:
img
class
=
"
typeIcon
"
width
=
"
16
"
height
=
"
16
"
/
>
<
label
class
=
"
typeDescription
"
flex
=
"
1
"
crop
=
"
end
"
/
>
<
/
hbox
>
<
hbox
class
=
"
actionContainer
"
flex
=
"
1
"
align
=
"
center
"
>
<
html
:
img
class
=
"
actionIcon
"
width
=
"
16
"
height
=
"
16
"
/
>
<
label
class
=
"
actionDescription
"
flex
=
"
1
"
crop
=
"
end
"
/
>
<
/
hbox
>
<
hbox
class
=
"
actionsMenuContainer
"
flex
=
"
1
"
>
<
menulist
class
=
"
actionsMenu
"
flex
=
"
1
"
crop
=
"
end
"
selectedIndex
=
"
1
"
aria
-
labelledby
=
"
actionColumn
"
>
<
menupopup
/
>
<
/
menulist
>
<
/
hbox
>
<
/
richlistitem
>
)
;
class
HandlerListItem
{
static
forNode
(
node
)
{
return
gNodeToObjectMap
.
get
(
node
)
;
}
constructor
(
handlerInfoWrapper
)
{
this
.
handlerInfoWrapper
=
handlerInfoWrapper
;
}
setOrRemoveAttributes
(
iterable
)
{
for
(
let
[
selector
name
value
]
of
iterable
)
{
let
node
=
selector
?
this
.
node
.
querySelector
(
selector
)
:
this
.
node
;
if
(
value
)
{
node
.
setAttribute
(
name
value
)
;
}
else
{
node
.
removeAttribute
(
name
)
;
}
}
}
createNode
(
list
)
{
list
.
appendChild
(
document
.
importNode
(
gHandlerListItemFragment
true
)
)
;
this
.
node
=
list
.
lastChild
;
gNodeToObjectMap
.
set
(
this
.
node
this
)
;
}
setupNode
(
)
{
this
.
node
.
querySelector
(
"
.
actionsMenu
"
)
.
addEventListener
(
"
command
"
event
=
>
gMainPane
.
onSelectAction
(
event
.
originalTarget
)
)
;
let
typeDescription
=
this
.
handlerInfoWrapper
.
typeDescription
;
this
.
setOrRemoveAttributes
(
[
[
null
"
type
"
this
.
handlerInfoWrapper
.
type
]
[
"
.
typeIcon
"
"
srcset
"
this
.
handlerInfoWrapper
.
iconSrcSet
]
]
)
;
localizeElement
(
this
.
node
.
querySelector
(
"
.
typeDescription
"
)
typeDescription
)
;
this
.
showActionsMenu
=
false
;
}
refreshAction
(
)
{
let
{
actionIconClass
}
=
this
.
handlerInfoWrapper
;
this
.
setOrRemoveAttributes
(
[
[
null
APP_ICON_ATTR_NAME
actionIconClass
]
[
"
.
actionIcon
"
"
srcset
"
actionIconClass
?
null
:
this
.
handlerInfoWrapper
.
actionIconSrcset
]
]
)
;
const
selectedItem
=
this
.
node
.
querySelector
(
"
[
selected
=
true
]
"
)
;
if
(
!
selectedItem
)
{
console
.
error
(
"
No
selected
item
for
"
+
this
.
handlerInfoWrapper
.
type
)
;
return
;
}
const
{
id
args
}
=
document
.
l10n
.
getAttributes
(
selectedItem
)
;
const
messageIDs
=
{
"
applications
-
action
-
save
"
:
"
applications
-
action
-
save
-
label
"
"
applications
-
always
-
ask
"
:
"
applications
-
always
-
ask
-
label
"
"
applications
-
open
-
inapp
"
:
"
applications
-
open
-
inapp
-
label
"
"
applications
-
use
-
app
-
default
"
:
"
applications
-
use
-
app
-
default
-
label
"
"
applications
-
use
-
app
"
:
"
applications
-
use
-
app
-
label
"
"
applications
-
use
-
os
-
default
"
:
"
applications
-
use
-
os
-
default
-
label
"
"
applications
-
use
-
other
"
:
"
applications
-
use
-
other
-
label
"
}
;
localizeElement
(
this
.
node
.
querySelector
(
"
.
actionDescription
"
)
{
id
:
messageIDs
[
id
]
args
}
)
;
localizeElement
(
this
.
node
.
querySelector
(
"
.
actionsMenu
"
)
{
id
args
}
)
;
}
set
showActionsMenu
(
value
)
{
this
.
setOrRemoveAttributes
(
[
[
"
.
actionContainer
"
"
hidden
"
value
]
[
"
.
actionsMenuContainer
"
"
hidden
"
!
value
]
]
)
;
}
}
function
localizeElement
(
node
l10n
)
{
if
(
l10n
.
hasOwnProperty
(
"
raw
"
)
)
{
node
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
node
.
textContent
=
l10n
.
raw
;
}
else
{
document
.
l10n
.
setAttributes
(
node
l10n
.
id
l10n
.
args
)
;
}
}
class
HandlerInfoWrapper
{
constructor
(
type
handlerInfo
)
{
this
.
type
=
type
;
this
.
wrappedHandlerInfo
=
handlerInfo
;
this
.
disambiguateDescription
=
false
;
}
get
description
(
)
{
if
(
this
.
wrappedHandlerInfo
.
description
)
{
return
{
raw
:
this
.
wrappedHandlerInfo
.
description
}
;
}
if
(
this
.
primaryExtension
)
{
var
extension
=
this
.
primaryExtension
.
toUpperCase
(
)
;
return
{
id
:
"
applications
-
file
-
ending
"
args
:
{
extension
}
}
;
}
return
{
raw
:
this
.
type
}
;
}
get
typeDescription
(
)
{
if
(
this
.
disambiguateDescription
)
{
const
description
=
this
.
description
;
if
(
description
.
id
)
{
let
{
args
=
{
}
}
=
description
;
args
.
type
=
this
.
type
;
return
{
id
:
description
.
id
+
"
-
with
-
type
"
args
}
;
}
return
{
id
:
"
applications
-
type
-
description
-
with
-
type
"
args
:
{
"
type
-
description
"
:
description
.
raw
type
:
this
.
type
}
}
;
}
return
this
.
description
;
}
get
actionIconClass
(
)
{
if
(
this
.
alwaysAskBeforeHandling
)
{
return
"
ask
"
;
}
switch
(
this
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
saveToDisk
:
return
"
save
"
;
case
Ci
.
nsIHandlerInfo
.
handleInternally
:
if
(
this
instanceof
InternalHandlerInfoWrapper
)
{
return
"
handleInternally
"
;
}
break
;
}
return
"
"
;
}
get
actionIconSrcset
(
)
{
let
icon
=
this
.
actionIcon
;
if
(
!
icon
|
|
!
icon
.
startsWith
(
"
moz
-
icon
:
"
)
)
{
return
icon
;
}
let
srcset
=
[
]
;
for
(
let
scale
of
[
1
2
3
]
)
{
let
scaledIcon
=
icon
+
"
&
scale
=
"
+
scale
;
srcset
.
push
(
{
scaledIcon
}
{
scale
}
x
)
;
}
return
srcset
.
join
(
"
"
)
;
}
get
actionIcon
(
)
{
switch
(
this
.
preferredAction
)
{
case
Ci
.
nsIHandlerInfo
.
useSystemDefault
:
return
this
.
iconURLForSystemDefault
;
case
Ci
.
nsIHandlerInfo
.
useHelperApp
:
{
let
preferredApp
=
this
.
preferredApplicationHandler
;
if
(
gMainPane
.
isValidHandlerApp
(
preferredApp
)
)
{
return
gMainPane
.
_getIconURLForHandlerApp
(
preferredApp
)
;
}
}
default
:
return
ICON_URL_APP
;
}
}
get
iconURLForSystemDefault
(
)
{
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIPropertyBag
)
{
try
{
let
url
=
this
.
wrappedHandlerInfo
.
getProperty
(
"
defaultApplicationIconURL
"
)
;
if
(
url
)
{
return
url
+
"
?
size
=
16
"
;
}
}
catch
(
ex
)
{
}
}
return
ICON_URL_APP
;
}
get
preferredApplicationHandler
(
)
{
return
this
.
wrappedHandlerInfo
.
preferredApplicationHandler
;
}
set
preferredApplicationHandler
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
preferredApplicationHandler
=
aNewValue
;
if
(
aNewValue
)
{
this
.
addPossibleApplicationHandler
(
aNewValue
)
;
}
}
get
possibleApplicationHandlers
(
)
{
return
this
.
wrappedHandlerInfo
.
possibleApplicationHandlers
;
}
addPossibleApplicationHandler
(
aNewHandler
)
{
for
(
let
app
of
this
.
possibleApplicationHandlers
.
enumerate
(
)
)
{
if
(
app
.
equals
(
aNewHandler
)
)
{
return
;
}
}
this
.
possibleApplicationHandlers
.
appendElement
(
aNewHandler
)
;
}
removePossibleApplicationHandler
(
aHandler
)
{
var
defaultApp
=
this
.
preferredApplicationHandler
;
if
(
defaultApp
&
&
aHandler
.
equals
(
defaultApp
)
)
{
this
.
alwaysAskBeforeHandling
=
true
;
this
.
preferredApplicationHandler
=
null
;
}
var
handlers
=
this
.
possibleApplicationHandlers
;
for
(
var
i
=
0
;
i
<
handlers
.
length
;
+
+
i
)
{
var
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
equals
(
aHandler
)
)
{
handlers
.
removeElementAt
(
i
)
;
break
;
}
}
}
get
hasDefaultHandler
(
)
{
return
this
.
wrappedHandlerInfo
.
hasDefaultHandler
;
}
get
defaultDescription
(
)
{
return
this
.
wrappedHandlerInfo
.
defaultDescription
;
}
get
preferredAction
(
)
{
if
(
this
.
wrappedHandlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
&
&
!
gMainPane
.
isValidHandlerApp
(
this
.
preferredApplicationHandler
)
)
{
if
(
this
.
wrappedHandlerInfo
.
hasDefaultHandler
)
{
return
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
}
return
Ci
.
nsIHandlerInfo
.
saveToDisk
;
}
return
this
.
wrappedHandlerInfo
.
preferredAction
;
}
set
preferredAction
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
preferredAction
=
aNewValue
;
}
get
alwaysAskBeforeHandling
(
)
{
if
(
!
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
&
&
this
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
saveToDisk
)
{
return
true
;
}
return
this
.
wrappedHandlerInfo
.
alwaysAskBeforeHandling
;
}
set
alwaysAskBeforeHandling
(
aNewValue
)
{
this
.
wrappedHandlerInfo
.
alwaysAskBeforeHandling
=
aNewValue
;
}
get
primaryExtension
(
)
{
try
{
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
&
&
this
.
wrappedHandlerInfo
.
primaryExtension
)
{
return
this
.
wrappedHandlerInfo
.
primaryExtension
;
}
}
catch
(
ex
)
{
}
return
null
;
}
store
(
)
{
gHandlerService
.
store
(
this
.
wrappedHandlerInfo
)
;
}
get
iconSrcSet
(
)
{
let
srcset
=
[
]
;
for
(
let
scale
of
[
1
2
]
)
{
let
icon
=
this
.
_getIcon
(
16
scale
)
;
if
(
!
icon
)
{
return
null
;
}
srcset
.
push
(
{
icon
}
{
scale
}
x
)
;
}
return
srcset
.
join
(
"
"
)
;
}
_getIcon
(
aSize
aScale
=
1
)
{
if
(
this
.
primaryExtension
)
{
return
moz
-
icon
:
/
/
goat
.
{
this
.
primaryExtension
}
?
size
=
{
aSize
}
&
scale
=
{
aScale
}
;
}
if
(
this
.
wrappedHandlerInfo
instanceof
Ci
.
nsIMIMEInfo
)
{
return
moz
-
icon
:
/
/
goat
?
size
=
{
aSize
}
&
scale
=
{
aScale
}
&
contentType
=
{
this
.
type
}
;
}
return
null
;
}
}
class
InternalHandlerInfoWrapper
extends
HandlerInfoWrapper
{
constructor
(
mimeType
extension
)
{
let
type
=
gMIMEService
.
getFromTypeAndExtension
(
mimeType
extension
)
;
super
(
mimeType
|
|
type
.
type
type
)
;
}
store
(
)
{
super
.
store
(
)
;
}
get
preventInternalViewing
(
)
{
return
false
;
}
get
enabled
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
}
class
PDFHandlerInfoWrapper
extends
InternalHandlerInfoWrapper
{
constructor
(
)
{
super
(
TYPE_PDF
null
)
;
}
get
preventInternalViewing
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_PDFJS_DISABLED
)
;
}
get
enabled
(
)
{
return
true
;
}
}
class
ViewableInternallyHandlerInfoWrapper
extends
InternalHandlerInfoWrapper
{
get
enabled
(
)
{
return
DownloadIntegration
.
shouldViewDownloadInternally
(
this
.
type
)
;
}
}
