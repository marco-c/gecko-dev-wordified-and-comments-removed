"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DoHController
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
sys
.
mjs
"
ClientID
:
"
resource
:
/
/
gre
/
modules
/
ClientID
.
sys
.
mjs
"
Preferences
:
"
resource
:
/
/
gre
/
modules
/
Preferences
.
sys
.
mjs
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
DoHConfigController
:
"
resource
:
/
/
/
modules
/
DoHConfig
.
jsm
"
Heuristics
:
"
resource
:
/
/
/
modules
/
DoHHeuristics
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
kIsInAutomation
"
"
doh
-
rollout
.
_testing
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
kNetworkDebounceTimeout
"
"
doh
-
rollout
.
network
-
debounce
-
timeout
"
1000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
kHeuristicsThrottleTimeout
"
"
doh
-
rollout
.
heuristics
-
throttle
-
timeout
"
15000
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
kHeuristicsRateLimit
"
"
doh
-
rollout
.
heuristics
-
throttle
-
rate
-
limit
"
2
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gCaptivePortalService
"
"
mozilla
.
org
/
network
/
captive
-
portal
-
service
;
1
"
"
nsICaptivePortalService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gNetworkLinkService
"
"
mozilla
.
org
/
network
/
network
-
link
-
service
;
1
"
"
nsINetworkLinkService
"
)
;
const
FIRST_RUN_PREF
=
"
doh
-
rollout
.
doneFirstRun
"
;
const
DISABLED_PREF
=
"
doh
-
rollout
.
disable
-
heuristics
"
;
const
SKIP_HEURISTICS_PREF
=
"
doh
-
rollout
.
skipHeuristicsCheck
"
;
const
CLEAR_ON_SHUTDOWN_PREF
=
"
doh
-
rollout
.
clearModeOnShutdown
"
;
const
BREADCRUMB_PREF
=
"
doh
-
rollout
.
self
-
enabled
"
;
const
NETWORK_TRR_MODE_PREF
=
"
network
.
trr
.
mode
"
;
const
NETWORK_TRR_URI_PREF
=
"
network
.
trr
.
uri
"
;
const
ROLLOUT_MODE_PREF
=
"
doh
-
rollout
.
mode
"
;
const
ROLLOUT_URI_PREF
=
"
doh
-
rollout
.
uri
"
;
const
TRR_SELECT_DRY_RUN_RESULT_PREF
=
"
doh
-
rollout
.
trr
-
selection
.
dry
-
run
-
result
"
;
const
NATIVE_FALLBACK_WARNING_PREF
=
"
network
.
trr
.
display_fallback_warning
"
;
const
NATIVE_FALLBACK_WARNING_HEURISTIC_LIST_PREF
=
"
network
.
trr
.
fallback_warning_heuristic_list
"
;
const
HEURISTICS_TELEMETRY_CATEGORY
=
"
doh
"
;
const
TRRSELECT_TELEMETRY_CATEGORY
=
"
security
.
doh
.
trrPerformance
"
;
const
kLinkStatusChangedTopic
=
"
network
:
link
-
status
-
changed
"
;
const
kConnectivityTopic
=
"
network
:
captive
-
portal
-
connectivity
-
changed
"
;
const
kPrefChangedTopic
=
"
nsPref
:
changed
"
;
function
getHashedNetworkID
(
)
{
let
currentNetworkID
=
lazy
.
gNetworkLinkService
.
networkID
;
if
(
!
currentNetworkID
)
{
return
"
"
;
}
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
Ci
.
nsICryptoHash
.
SHA256
)
;
let
clientNetworkID
=
lazy
.
ClientID
.
getClientID
(
)
+
currentNetworkID
;
hasher
.
update
(
clientNetworkID
.
split
(
"
"
)
.
map
(
c
=
>
c
.
charCodeAt
(
0
)
)
clientNetworkID
.
length
)
;
return
hasher
.
finish
(
true
)
;
}
const
DoHController
=
{
_heuristicsAreEnabled
:
false
async
init
(
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
HEURISTICS_TELEMETRY_CATEGORY
true
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
TRRSELECT_TELEMETRY_CATEGORY
true
)
;
await
lazy
.
DoHConfigController
.
initComplete
;
Services
.
obs
.
addObserver
(
this
lazy
.
DoHConfigController
.
kConfigUpdateTopic
)
;
lazy
.
Preferences
.
observe
(
NETWORK_TRR_MODE_PREF
this
)
;
lazy
.
Preferences
.
observe
(
NETWORK_TRR_URI_PREF
this
)
;
lazy
.
Preferences
.
observe
(
NATIVE_FALLBACK_WARNING_PREF
this
)
;
lazy
.
Preferences
.
observe
(
NATIVE_FALLBACK_WARNING_HEURISTIC_LIST_PREF
this
)
;
if
(
lazy
.
DoHConfigController
.
currentConfig
.
enabled
)
{
await
this
.
maybeEnableHeuristics
(
)
;
}
else
if
(
lazy
.
Preferences
.
get
(
FIRST_RUN_PREF
false
)
)
{
await
this
.
rollback
(
)
;
}
this
.
_asyncShutdownBlocker
=
async
(
)
=
>
{
await
this
.
disableHeuristics
(
"
shutdown
"
)
;
}
;
lazy
.
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
DoHController
:
clear
state
and
remove
observers
"
this
.
_asyncShutdownBlocker
)
;
lazy
.
Preferences
.
set
(
FIRST_RUN_PREF
true
)
;
}
async
_uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
lazy
.
DoHConfigController
.
kConfigUpdateTopic
)
;
lazy
.
Preferences
.
ignore
(
NETWORK_TRR_MODE_PREF
this
)
;
lazy
.
Preferences
.
ignore
(
NETWORK_TRR_URI_PREF
this
)
;
lazy
.
AsyncShutdown
.
profileBeforeChange
.
removeBlocker
(
this
.
_asyncShutdownBlocker
)
;
await
this
.
disableHeuristics
(
"
shutdown
"
)
;
}
resetPromise
:
Promise
.
resolve
(
)
async
reset
(
)
{
this
.
resetPromise
=
this
.
resetPromise
.
then
(
async
(
)
=
>
{
await
this
.
_uninit
(
)
;
await
this
.
init
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
doh
:
controller
-
reloaded
"
)
;
}
)
;
return
this
.
resetPromise
;
}
async
maybeEnableHeuristics
(
)
{
if
(
lazy
.
Preferences
.
get
(
DISABLED_PREF
)
)
{
return
;
}
let
policyResult
=
await
lazy
.
Heuristics
.
checkEnterprisePolicy
(
)
;
if
(
[
"
policy_without_doh
"
"
disable_doh
"
]
.
includes
(
policyResult
)
)
{
await
this
.
setState
(
"
policyDisabled
"
)
;
lazy
.
Preferences
.
set
(
SKIP_HEURISTICS_PREF
true
)
;
return
;
}
lazy
.
Preferences
.
reset
(
SKIP_HEURISTICS_PREF
)
;
if
(
lazy
.
Preferences
.
isSet
(
NETWORK_TRR_MODE_PREF
)
|
|
lazy
.
Preferences
.
isSet
(
NETWORK_TRR_URI_PREF
)
)
{
await
this
.
setState
(
"
manuallyDisabled
"
)
;
lazy
.
Preferences
.
set
(
DISABLED_PREF
true
)
;
return
;
}
await
this
.
runTRRSelection
(
)
;
if
(
!
lazy
.
Preferences
.
isSet
(
ROLLOUT_URI_PREF
)
)
{
lazy
.
Preferences
.
set
(
ROLLOUT_URI_PREF
lazy
.
DoHConfigController
.
currentConfig
.
fallbackProviderURI
)
;
}
this
.
runHeuristicsThrottled
(
"
startup
"
)
;
Services
.
obs
.
addObserver
(
this
kLinkStatusChangedTopic
)
;
Services
.
obs
.
addObserver
(
this
kConnectivityTopic
)
;
this
.
_heuristicsAreEnabled
=
true
;
}
_runsWhileThrottling
:
0
_wasThrottleExtended
:
false
_throttleHeuristics
(
)
{
if
(
lazy
.
kHeuristicsThrottleTimeout
<
0
)
{
return
false
;
}
if
(
this
.
_throttleTimer
)
{
this
.
_runsWhileThrottling
+
+
;
return
true
;
}
this
.
_runsWhileThrottling
=
0
;
this
.
_throttleTimer
=
lazy
.
setTimeout
(
this
.
_handleThrottleTimeout
.
bind
(
this
)
lazy
.
kHeuristicsThrottleTimeout
)
;
return
false
;
}
_handleThrottleTimeout
(
)
{
delete
this
.
_throttleTimer
;
if
(
this
.
_runsWhileThrottling
>
lazy
.
kHeuristicsRateLimit
)
{
this
.
_wasThrottleExtended
=
true
;
this
.
_throttleHeuristics
(
)
;
if
(
lazy
.
kIsInAutomation
)
{
Services
.
obs
.
notifyObservers
(
null
"
doh
:
heuristics
-
throttle
-
extend
"
)
;
}
return
;
}
if
(
this
.
_runsWhileThrottling
>
0
|
|
this
.
_wasThrottleExtended
)
{
this
.
runHeuristicsThrottled
(
"
throttled
"
)
;
}
this
.
_wasThrottleExtended
=
false
;
if
(
lazy
.
kIsInAutomation
)
{
Services
.
obs
.
notifyObservers
(
null
"
doh
:
heuristics
-
throttle
-
done
"
)
;
}
}
runHeuristicsThrottled
(
evaluateReason
)
{
if
(
this
.
_throttleHeuristics
(
)
)
{
return
;
}
this
.
runHeuristics
(
evaluateReason
)
;
}
async
runHeuristics
(
evaluateReason
)
{
let
start
=
Date
.
now
(
)
;
let
results
=
await
lazy
.
Heuristics
.
run
(
)
;
if
(
!
lazy
.
gNetworkLinkService
.
isLinkUp
|
|
this
.
_lastDebounceTimestamp
>
start
|
|
lazy
.
gCaptivePortalService
.
state
=
=
lazy
.
gCaptivePortalService
.
LOCKED_PORTAL
)
{
return
;
}
let
decision
=
Object
.
values
(
results
)
.
includes
(
lazy
.
Heuristics
.
DISABLE_DOH
)
?
lazy
.
Heuristics
.
DISABLE_DOH
:
lazy
.
Heuristics
.
ENABLE_DOH
;
let
getCaptiveStateString
=
(
)
=
>
{
switch
(
lazy
.
gCaptivePortalService
.
state
)
{
case
lazy
.
gCaptivePortalService
.
NOT_CAPTIVE
:
return
"
not_captive
"
;
case
lazy
.
gCaptivePortalService
.
UNLOCKED_PORTAL
:
return
"
unlocked
"
;
case
lazy
.
gCaptivePortalService
.
LOCKED_PORTAL
:
return
"
locked
"
;
default
:
return
"
unknown
"
;
}
}
;
let
resultsForTelemetry
=
{
evaluateReason
steeredProvider
:
"
"
captiveState
:
getCaptiveStateString
(
)
networkID
:
getHashedNetworkID
(
)
}
;
if
(
results
.
steeredProvider
)
{
Services
.
dns
.
setDetectedTrrURI
(
results
.
steeredProvider
.
uri
)
;
resultsForTelemetry
.
steeredProvider
=
results
.
steeredProvider
.
id
;
}
try
{
Services
.
dns
.
setHeuristicDetectionResult
(
Ci
.
nsITRRSkipReason
.
TRR_OK
)
;
}
catch
(
e
)
{
}
if
(
decision
=
=
=
lazy
.
Heuristics
.
DISABLE_DOH
)
{
let
fallbackHeuristicTripped
=
undefined
;
if
(
lazy
.
Preferences
.
get
(
NATIVE_FALLBACK_WARNING_PREF
false
)
)
{
let
heuristics
=
lazy
.
Preferences
.
get
(
NATIVE_FALLBACK_WARNING_HEURISTIC_LIST_PREF
"
"
)
.
split
(
"
"
)
;
for
(
let
[
heuristicName
result
]
of
Object
.
entries
(
results
)
)
{
if
(
result
!
=
=
lazy
.
Heuristics
.
DISABLE_DOH
)
{
continue
;
}
if
(
heuristics
.
includes
(
heuristicName
)
)
{
fallbackHeuristicTripped
=
heuristicName
;
break
;
}
}
}
if
(
fallbackHeuristicTripped
!
=
undefined
)
{
await
this
.
setState
(
"
enabled
"
)
;
try
{
Services
.
dns
.
setHeuristicDetectionResult
(
lazy
.
Heuristics
.
heuristicNameToSkipReason
(
fallbackHeuristicTripped
)
)
;
}
catch
(
e
)
{
}
}
else
{
await
this
.
setState
(
"
disabled
"
)
;
}
}
else
{
await
this
.
setState
(
"
enabled
"
)
;
}
let
canaries
=
[
]
;
let
filtering
=
[
]
;
let
enterprise
=
[
]
;
let
platform
=
[
]
;
for
(
let
[
heuristicName
result
]
of
Object
.
entries
(
results
)
)
{
if
(
result
!
=
=
lazy
.
Heuristics
.
DISABLE_DOH
)
{
continue
;
}
if
(
[
"
canary
"
"
zscalerCanary
"
]
.
includes
(
heuristicName
)
)
{
canaries
.
push
(
heuristicName
)
;
}
else
if
(
[
"
browserParent
"
"
google
"
"
youtube
"
]
.
includes
(
heuristicName
)
)
{
filtering
.
push
(
heuristicName
)
;
}
else
if
(
[
"
policy
"
"
modifiedRoots
"
"
thirdPartyRoots
"
]
.
includes
(
heuristicName
)
)
{
enterprise
.
push
(
heuristicName
)
;
}
else
if
(
[
"
vpn
"
"
proxy
"
"
nrpt
"
]
.
includes
(
heuristicName
)
)
{
platform
.
push
(
heuristicName
)
;
}
}
resultsForTelemetry
.
canaries
=
canaries
.
join
(
"
"
)
;
resultsForTelemetry
.
filtering
=
filtering
.
join
(
"
"
)
;
resultsForTelemetry
.
enterprise
=
enterprise
.
join
(
"
"
)
;
resultsForTelemetry
.
platform
=
platform
.
join
(
"
"
)
;
Services
.
telemetry
.
recordEvent
(
HEURISTICS_TELEMETRY_CATEGORY
"
evaluate_v2
"
"
heuristics
"
decision
resultsForTelemetry
)
;
}
async
setState
(
state
)
{
switch
(
state
)
{
case
"
disabled
"
:
lazy
.
Preferences
.
set
(
ROLLOUT_MODE_PREF
0
)
;
break
;
case
"
UIOk
"
:
lazy
.
Preferences
.
set
(
BREADCRUMB_PREF
true
)
;
break
;
case
"
enabled
"
:
lazy
.
Preferences
.
set
(
ROLLOUT_MODE_PREF
2
)
;
lazy
.
Preferences
.
set
(
BREADCRUMB_PREF
true
)
;
break
;
case
"
policyDisabled
"
:
case
"
manuallyDisabled
"
:
case
"
UIDisabled
"
:
lazy
.
Preferences
.
reset
(
BREADCRUMB_PREF
)
;
case
"
rollback
"
:
lazy
.
Preferences
.
reset
(
ROLLOUT_MODE_PREF
)
;
break
;
case
"
shutdown
"
:
if
(
lazy
.
Preferences
.
get
(
CLEAR_ON_SHUTDOWN_PREF
true
)
)
{
lazy
.
Preferences
.
reset
(
ROLLOUT_MODE_PREF
)
;
}
break
;
}
Services
.
telemetry
.
recordEvent
(
HEURISTICS_TELEMETRY_CATEGORY
"
state
"
state
"
null
"
)
;
}
async
disableHeuristics
(
state
)
{
await
this
.
setState
(
state
)
;
if
(
!
this
.
_heuristicsAreEnabled
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
kLinkStatusChangedTopic
)
;
Services
.
obs
.
removeObserver
(
this
kConnectivityTopic
)
;
if
(
this
.
_debounceTimer
)
{
lazy
.
clearTimeout
(
this
.
_debounceTimer
)
;
delete
this
.
_debounceTimer
;
}
if
(
this
.
_throttleTimer
)
{
lazy
.
clearTimeout
(
this
.
_throttleTimer
)
;
delete
this
.
_throttleTimer
;
}
this
.
_heuristicsAreEnabled
=
false
;
}
async
rollback
(
)
{
await
this
.
disableHeuristics
(
"
rollback
"
)
;
}
async
runTRRSelection
(
)
{
if
(
!
lazy
.
DoHConfigController
.
currentConfig
.
trrSelection
.
commitResult
)
{
lazy
.
Preferences
.
reset
(
ROLLOUT_URI_PREF
)
;
}
if
(
!
lazy
.
DoHConfigController
.
currentConfig
.
trrSelection
.
enabled
)
{
return
;
}
if
(
lazy
.
Preferences
.
isSet
(
ROLLOUT_URI_PREF
)
&
&
lazy
.
Preferences
.
get
(
ROLLOUT_URI_PREF
)
=
=
lazy
.
Preferences
.
get
(
TRR_SELECT_DRY_RUN_RESULT_PREF
)
)
{
return
;
}
await
this
.
runTRRSelectionDryRun
(
)
;
if
(
!
lazy
.
DoHConfigController
.
currentConfig
.
trrSelection
.
commitResult
)
{
return
;
}
lazy
.
Preferences
.
set
(
ROLLOUT_URI_PREF
lazy
.
Preferences
.
get
(
TRR_SELECT_DRY_RUN_RESULT_PREF
)
)
;
}
async
runTRRSelectionDryRun
(
)
{
if
(
lazy
.
Preferences
.
isSet
(
TRR_SELECT_DRY_RUN_RESULT_PREF
)
)
{
let
dryRunResult
=
lazy
.
Preferences
.
get
(
TRR_SELECT_DRY_RUN_RESULT_PREF
)
;
let
dryRunResultIsValid
=
lazy
.
DoHConfigController
.
currentConfig
.
providerList
.
some
(
trr
=
>
trr
.
uri
=
=
dryRunResult
)
;
if
(
dryRunResultIsValid
)
{
return
;
}
}
let
setDryRunResultAndRecordTelemetry
=
trrUri
=
>
{
lazy
.
Preferences
.
set
(
TRR_SELECT_DRY_RUN_RESULT_PREF
trrUri
)
;
Services
.
telemetry
.
recordEvent
(
TRRSELECT_TELEMETRY_CATEGORY
"
trrselect
"
"
dryrunresult
"
trrUri
.
substring
(
0
40
)
)
;
}
;
if
(
lazy
.
kIsInAutomation
)
{
setDryRunResultAndRecordTelemetry
(
"
https
:
/
/
example
.
com
/
dns
-
query
"
)
;
return
;
}
let
{
TRRRacer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
TRRPerformance
.
jsm
"
)
;
await
new
Promise
(
resolve
=
>
{
let
trrList
=
lazy
.
DoHConfigController
.
currentConfig
.
trrSelection
.
providerList
.
map
(
trr
=
>
trr
.
uri
)
;
let
racer
=
new
TRRRacer
(
(
)
=
>
{
setDryRunResultAndRecordTelemetry
(
racer
.
getFastestTRR
(
true
)
)
;
resolve
(
)
;
}
trrList
)
;
racer
.
run
(
)
;
}
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
kLinkStatusChangedTopic
:
this
.
onConnectionChanged
(
)
;
break
;
case
kConnectivityTopic
:
this
.
onConnectivityAvailable
(
)
;
break
;
case
kPrefChangedTopic
:
this
.
onPrefChanged
(
data
)
;
break
;
case
lazy
.
DoHConfigController
.
kConfigUpdateTopic
:
this
.
reset
(
)
;
break
;
}
}
async
onPrefChanged
(
pref
)
{
switch
(
pref
)
{
case
NETWORK_TRR_URI_PREF
:
case
NETWORK_TRR_MODE_PREF
:
lazy
.
Preferences
.
set
(
DISABLED_PREF
true
)
;
await
this
.
disableHeuristics
(
"
manuallyDisabled
"
)
;
try
{
Services
.
dns
.
setHeuristicDetectionResult
(
Ci
.
nsITRRSkipReason
.
TRR_OK
)
;
}
catch
(
e
)
{
}
break
;
case
NATIVE_FALLBACK_WARNING_PREF
:
case
NATIVE_FALLBACK_WARNING_HEURISTIC_LIST_PREF
:
this
.
runHeuristics
(
"
native
-
fallback
-
warning
-
changed
"
)
;
break
;
}
}
_debounceTimer
:
null
_cancelDebounce
(
)
{
if
(
!
this
.
_debounceTimer
)
{
return
;
}
lazy
.
clearTimeout
(
this
.
_debounceTimer
)
;
this
.
_debounceTimer
=
null
;
}
_lastDebounceTimestamp
:
0
onConnectionChanged
(
)
{
if
(
!
lazy
.
gNetworkLinkService
.
isLinkUp
)
{
this
.
_cancelDebounce
(
)
;
return
;
}
if
(
this
.
_debounceTimer
)
{
return
;
}
if
(
lazy
.
kNetworkDebounceTimeout
<
0
)
{
this
.
onConnectionChangedDebounced
(
)
;
return
;
}
this
.
_lastDebounceTimestamp
=
Date
.
now
(
)
;
this
.
_debounceTimer
=
lazy
.
setTimeout
(
(
)
=
>
{
this
.
_cancelDebounce
(
)
;
this
.
onConnectionChangedDebounced
(
)
;
}
lazy
.
kNetworkDebounceTimeout
)
;
}
onConnectionChangedDebounced
(
)
{
if
(
!
lazy
.
gNetworkLinkService
.
isLinkUp
)
{
return
;
}
if
(
lazy
.
gCaptivePortalService
.
state
=
=
lazy
.
gCaptivePortalService
.
LOCKED_PORTAL
)
{
return
;
}
this
.
runHeuristicsThrottled
(
"
netchange
"
)
;
}
onConnectivityAvailable
(
)
{
if
(
this
.
_debounceTimer
)
{
return
;
}
this
.
runHeuristicsThrottled
(
"
connectivity
"
)
;
}
}
;
