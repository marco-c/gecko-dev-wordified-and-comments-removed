"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TRRRacer
"
"
DNSLookup
"
"
LookupAggregator
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
security
.
doh
.
trrPerformance
"
true
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gNetworkLinkService
"
"
mozilla
.
org
/
network
/
network
-
link
-
service
;
1
"
"
nsINetworkLinkService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gCaptivePortalService
"
"
mozilla
.
org
/
network
/
captive
-
portal
-
service
;
1
"
"
nsICaptivePortalService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gDNSService
"
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
"
nsIDNSService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUUIDGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
kTRRs
"
"
doh
-
rollout
.
trrRace
.
trrList
"
null
null
val
=
>
val
?
val
.
split
(
"
"
)
.
map
(
t
=
>
t
.
trim
(
)
)
:
[
"
https
:
/
/
mozilla
.
cloudflare
-
dns
.
com
/
dns
-
query
"
"
https
:
/
/
trr
.
dns
.
nextdns
.
io
/
"
"
https
:
/
/
doh
.
xfinity
.
com
/
dns
-
query
"
]
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
kCanonicalDomain
"
"
doh
-
rollout
.
trrRace
.
canonicalDomain
"
"
firefox
-
dns
-
perf
-
test
.
net
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
kRepeats
"
"
doh
-
rollout
.
trrRace
.
randomSubdomainCount
"
5
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
kPopularDomains
"
"
doh
-
rollout
.
trrRace
.
popularDomains
"
null
null
val
=
>
val
?
val
.
split
(
"
"
)
.
map
(
t
=
>
t
.
trim
(
)
)
:
[
"
google
.
com
"
"
youtube
.
com
"
"
amazon
.
com
"
"
facebook
.
com
"
"
yahoo
.
com
"
]
)
;
function
getRandomSubdomain
(
)
{
let
uuid
=
gUUIDGenerator
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
return
{
uuid
}
.
{
kCanonicalDomain
}
;
}
class
DNSLookup
{
constructor
(
domain
trrServer
callback
)
{
this
.
_domain
=
domain
;
this
.
trrServer
=
trrServer
;
this
.
callback
=
callback
;
this
.
retryCount
=
0
;
}
doLookup
(
)
{
this
.
retryCount
+
+
;
try
{
this
.
usedDomain
=
this
.
_domain
|
|
getRandomSubdomain
(
)
;
gDNSService
.
asyncResolveWithTrrServer
(
this
.
usedDomain
this
.
trrServer
Ci
.
nsIDNSService
.
RESOLVE_BYPASS_CACHE
this
Services
.
tm
.
currentThread
{
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
onLookupComplete
(
request
record
status
)
{
if
(
!
Components
.
isSuccessCode
(
status
)
&
&
this
.
retryCount
<
3
)
{
this
.
doLookup
(
)
;
return
;
}
this
.
callback
(
request
record
status
this
.
usedDomain
this
.
retryCount
)
;
}
}
DNSLookup
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIDNSListener
]
)
;
class
LookupAggregator
{
constructor
(
onCompleteCallback
)
{
this
.
onCompleteCallback
=
onCompleteCallback
;
this
.
aborted
=
false
;
this
.
networkUnstable
=
false
;
this
.
captivePortal
=
false
;
this
.
domains
=
[
]
;
for
(
let
i
=
0
;
i
<
kRepeats
;
+
+
i
)
{
this
.
domains
.
push
(
null
)
;
}
this
.
domains
.
push
(
.
.
.
kPopularDomains
)
;
this
.
totalLookups
=
kTRRs
.
length
*
this
.
domains
.
length
;
this
.
completedLookups
=
0
;
this
.
results
=
[
]
;
}
run
(
)
{
if
(
this
.
_ran
|
|
this
.
_aborted
)
{
Cu
.
reportError
(
"
Trying
to
re
-
run
a
LookupAggregator
.
"
)
;
return
;
}
this
.
_ran
=
true
;
for
(
let
trr
of
kTRRs
)
{
for
(
let
domain
of
this
.
domains
)
{
new
DNSLookup
(
domain
trr
(
request
record
status
usedDomain
retryCount
)
=
>
{
this
.
results
.
push
(
{
domain
:
usedDomain
trr
status
time
:
record
?
record
.
trrFetchDurationNetworkOnly
:
-
1
retryCount
}
)
;
this
.
completedLookups
+
+
;
if
(
this
.
completedLookups
=
=
this
.
totalLookups
)
{
this
.
recordResults
(
)
;
}
}
)
.
doLookup
(
)
;
}
}
}
abort
(
)
{
this
.
aborted
=
true
;
}
markUnstableNetwork
(
)
{
this
.
networkUnstable
=
true
;
}
markCaptivePortal
(
)
{
this
.
captivePortal
=
true
;
}
recordResults
(
)
{
if
(
this
.
aborted
)
{
return
;
}
for
(
let
{
domain
trr
status
time
retryCount
}
of
this
.
results
)
{
if
(
!
(
kPopularDomains
.
includes
(
domain
)
|
|
domain
.
includes
(
kCanonicalDomain
)
)
)
{
Cu
.
reportError
(
"
Expected
known
domain
for
reporting
got
"
+
domain
)
;
return
;
}
Services
.
telemetry
.
recordEvent
(
"
security
.
doh
.
trrPerformance
"
"
resolved
"
"
record
"
"
success
"
{
domain
trr
status
:
status
.
toString
(
)
time
:
time
.
toString
(
)
retryCount
:
retryCount
.
toString
(
)
networkUnstable
:
this
.
networkUnstable
.
toString
(
)
captivePortal
:
this
.
captivePortal
.
toString
(
)
}
)
;
}
this
.
onCompleteCallback
(
)
;
}
}
class
TRRRacer
{
constructor
(
onCompleteCallback
)
{
this
.
_aggregator
=
null
;
this
.
_retryCount
=
0
;
this
.
_onCompleteCallback
=
onCompleteCallback
;
}
run
(
)
{
if
(
gNetworkLinkService
.
isLinkUp
&
&
gCaptivePortalService
.
state
!
=
gCaptivePortalService
.
LOCKED_PORTAL
)
{
this
.
_runNewAggregator
(
)
;
if
(
gCaptivePortalService
.
state
=
=
gCaptivePortalService
.
UNLOCKED_PORTAL
)
{
this
.
_aggregator
.
markCaptivePortal
(
)
;
}
}
Services
.
obs
.
addObserver
(
this
"
ipc
:
network
:
captive
-
portal
-
set
-
state
"
)
;
Services
.
obs
.
addObserver
(
this
"
network
:
link
-
status
-
changed
"
)
;
}
onComplete
(
)
{
Services
.
obs
.
removeObserver
(
this
"
ipc
:
network
:
captive
-
portal
-
set
-
state
"
)
;
Services
.
obs
.
removeObserver
(
this
"
network
:
link
-
status
-
changed
"
)
;
if
(
this
.
_onCompleteCallback
)
{
this
.
_onCompleteCallback
(
)
;
}
}
_runNewAggregator
(
)
{
this
.
_aggregator
=
new
LookupAggregator
(
(
)
=
>
this
.
onComplete
(
)
)
;
this
.
_aggregator
.
run
(
)
;
this
.
_retryCount
+
+
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
network
:
link
-
status
-
changed
"
:
if
(
this
.
_aggregator
&
&
data
=
=
"
down
"
)
{
if
(
this
.
_retryCount
<
5
)
{
this
.
_aggregator
.
abort
(
)
;
}
else
{
this
.
_aggregator
.
markUnstableNetwork
(
)
;
}
}
else
if
(
data
=
=
"
up
"
&
&
(
!
this
.
_aggregator
|
|
this
.
_aggregator
.
aborted
)
)
{
this
.
_runNewAggregator
(
)
;
}
break
;
case
"
ipc
:
network
:
captive
-
portal
-
set
-
state
"
:
if
(
this
.
_aggregator
&
&
gCaptivePortalService
.
state
=
=
gCaptivePortalService
.
LOCKED_PORTAL
)
{
if
(
this
.
_retryCount
<
5
)
{
this
.
_aggregator
.
abort
(
)
;
}
else
{
this
.
_aggregator
.
markCaptivePortal
(
)
;
}
}
else
if
(
gCaptivePortalService
.
state
=
=
gCaptivePortalService
.
UNLOCKED_PORTAL
&
&
(
!
this
.
_aggregator
|
|
this
.
_aggregator
.
aborted
)
)
{
this
.
_runNewAggregator
(
)
;
}
break
;
}
}
}
