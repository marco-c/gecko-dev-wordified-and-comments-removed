"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Pocket
"
"
chrome
:
/
/
pocket
/
content
/
Pocket
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ReaderMode
"
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AboutReaderParent
"
"
resource
:
/
/
/
actors
/
AboutReaderParent
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
SaveToPocket
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gStrings
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
aboutReader
.
properties
"
)
;
}
)
;
var
PocketCustomizableWidget
=
{
init
(
)
{
CustomizableUI
.
createWidget
(
{
id
:
"
save
-
to
-
pocket
-
button
"
l10nId
:
"
save
-
to
-
pocket
-
button
"
type
:
"
view
"
viewId
:
"
PanelUI
-
savetopocket
"
locationSpecific
:
true
onViewShowing
(
aEvent
)
{
let
panelView
=
aEvent
.
target
;
let
panelNode
=
panelView
.
querySelector
(
"
.
PanelUI
-
savetopocket
-
container
"
)
;
let
doc
=
panelNode
.
ownerDocument
;
let
frame
=
doc
.
createXULElement
(
"
browser
"
)
;
frame
.
setAttribute
(
"
type
"
"
content
"
)
;
frame
.
setAttribute
(
"
remote
"
true
)
;
panelNode
.
appendChild
(
frame
)
;
SaveToPocket
.
onShownInToolbarPanel
(
panelNode
frame
)
;
}
onViewHiding
(
aEvent
)
{
let
panelView
=
aEvent
.
target
;
let
panelNode
=
panelView
.
querySelector
(
"
.
PanelUI
-
savetopocket
-
container
"
)
;
panelNode
.
textContent
=
"
"
;
SaveToPocket
.
updateToolbarNodeState
(
panelNode
.
ownerGlobal
)
;
}
}
)
;
}
shutdown
(
)
{
CustomizableUI
.
destroyWidget
(
"
save
-
to
-
pocket
-
button
"
)
;
}
}
;
var
PocketContextMenu
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
on
-
build
-
contextmenu
"
)
;
}
shutdown
(
)
{
Services
.
obs
.
removeObserver
(
this
"
on
-
build
-
contextmenu
"
)
;
}
observe
(
aSubject
aTopic
aData
)
{
let
subject
=
aSubject
.
wrappedJSObject
;
let
document
=
subject
.
menu
.
ownerDocument
;
let
pocketEnabled
=
SaveToPocket
.
prefEnabled
;
let
showSaveCurrentPageToPocket
=
!
(
subject
.
onTextInput
|
|
subject
.
onLink
|
|
subject
.
isContentSelected
|
|
subject
.
onImage
|
|
subject
.
onCanvas
|
|
subject
.
onVideo
|
|
subject
.
onAudio
)
;
let
targetUrl
targetURI
;
if
(
subject
.
onLink
)
{
targetUrl
=
subject
.
linkUrl
;
targetURI
=
subject
.
linkURI
;
}
else
{
targetUrl
=
subject
.
pageUrl
;
targetURI
=
Services
.
io
.
newURI
(
targetUrl
)
;
}
let
canPocket
=
pocketEnabled
&
&
targetURI
&
&
(
targetURI
.
schemeIs
(
"
http
"
)
|
|
targetURI
.
schemeIs
(
"
https
"
)
|
|
(
targetURI
.
schemeIs
(
"
about
"
)
&
&
ReaderMode
.
getOriginalUrl
(
targetUrl
)
)
)
;
let
showSaveLinkToPocket
=
canPocket
&
&
!
showSaveCurrentPageToPocket
&
&
subject
.
onLink
;
let
menu
=
document
.
getElementById
(
"
context
-
pocket
"
)
;
menu
.
hidden
=
!
(
canPocket
&
&
showSaveCurrentPageToPocket
)
;
menu
=
document
.
getElementById
(
"
context
-
savelinktopocket
"
)
;
menu
.
hidden
=
!
showSaveLinkToPocket
;
}
}
;
var
PocketOverlay
=
{
startup
(
)
{
PocketCustomizableWidget
.
init
(
)
;
PocketContextMenu
.
init
(
)
;
}
shutdown
(
)
{
PocketCustomizableWidget
.
shutdown
(
)
;
PocketContextMenu
.
shutdown
(
)
;
}
}
;
function
browserWindows
(
)
{
return
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
}
var
SaveToPocket
=
{
init
(
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
pocket
.
enabled
"
)
)
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
pocket
.
enabled
"
Services
.
prefs
.
getBoolPref
(
"
browser
.
pocket
.
enabled
"
)
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
pocket
.
enabled
"
)
;
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
prefEnabled
"
"
extensions
.
pocket
.
enabled
"
true
this
.
onPrefChange
.
bind
(
this
)
)
;
if
(
this
.
prefEnabled
)
{
PocketOverlay
.
startup
(
)
;
}
else
{
this
.
updateElements
(
false
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
AboutReaderParent
.
addMessageListener
(
"
Reader
:
OnSetup
"
this
)
;
AboutReaderParent
.
addMessageListener
(
"
Reader
:
Clicked
-
pocket
-
button
"
this
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
browser
-
delayed
-
startup
-
finished
"
)
{
this
.
updateElementsInWindow
(
subject
false
)
;
}
}
_readerButtonData
:
{
id
:
"
pocket
-
button
"
telemetryId
:
"
save
-
to
-
pocket
"
label
:
gStrings
.
formatStringFromName
(
"
readerView
.
savetopocket
.
label
"
[
"
Pocket
"
]
)
image
:
"
chrome
:
/
/
global
/
skin
/
icons
/
pocket
.
svg
"
width
:
16
height
:
16
}
onPrefChange
(
pref
oldValue
newValue
)
{
if
(
!
newValue
)
{
AboutReaderParent
.
broadcastAsyncMessage
(
"
Reader
:
RemoveButton
"
{
id
:
"
pocket
-
button
"
}
)
;
PocketOverlay
.
shutdown
(
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
else
{
AboutReaderParent
.
broadcastAsyncMessage
(
"
Reader
:
AddButton
"
this
.
_readerButtonData
)
;
Services
.
obs
.
removeObserver
(
this
"
browser
-
delayed
-
startup
-
finished
"
)
;
PocketOverlay
.
startup
(
)
;
}
this
.
updateElements
(
newValue
)
;
}
updateToolbarNodeState
(
browserWindow
)
{
const
toolbarNode
=
browserWindow
.
document
.
getElementById
(
"
save
-
to
-
pocket
-
button
"
)
;
if
(
!
toolbarNode
|
|
toolbarNode
.
hidden
)
{
return
;
}
let
browser
=
browserWindow
.
gBrowser
.
selectedBrowser
;
let
pocketedInnerWindowID
=
this
.
innerWindowIDsByBrowser
.
get
(
browser
)
;
if
(
pocketedInnerWindowID
=
=
browser
.
innerWindowID
)
{
toolbarNode
.
setAttribute
(
"
pocketed
"
"
true
"
)
;
}
else
{
toolbarNode
.
removeAttribute
(
"
pocketed
"
)
;
}
}
get
innerWindowIDsByBrowser
(
)
{
delete
this
.
innerWindowIDsByBrowser
;
return
(
this
.
innerWindowIDsByBrowser
=
new
WeakMap
(
)
)
;
}
onLocationChange
(
browserWindow
)
{
this
.
updateToolbarNodeState
(
browserWindow
)
;
}
onShownInToolbarPanel
(
panel
frame
)
{
let
window
=
panel
.
ownerGlobal
;
window
.
pktUI
.
setToolbarPanelFrame
(
frame
)
;
Pocket
.
_initPanelView
(
window
)
;
}
itemSaved
(
)
{
const
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
const
browser
=
browserWindow
.
gBrowser
.
selectedBrowser
;
SaveToPocket
.
innerWindowIDsByBrowser
.
set
(
browser
browser
.
innerWindowID
)
;
}
itemDeleted
(
)
{
const
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
const
browser
=
browserWindow
.
gBrowser
.
selectedBrowser
;
SaveToPocket
.
innerWindowIDsByBrowser
.
delete
(
browser
)
;
}
updateElements
(
enabled
)
{
for
(
let
win
of
browserWindows
(
)
)
{
this
.
updateElementsInWindow
(
win
enabled
)
;
}
}
updateElementsInWindow
(
win
enabled
)
{
if
(
enabled
)
{
win
.
document
.
documentElement
.
removeAttribute
(
"
pocketdisabled
"
)
;
}
else
{
let
savePageMenu
=
win
.
document
.
getElementById
(
"
context
-
pocket
"
)
;
let
saveLinkMenu
=
win
.
document
.
getElementById
(
"
context
-
savelinktopocket
"
)
;
savePageMenu
.
hidden
=
saveLinkMenu
.
hidden
=
true
;
win
.
document
.
documentElement
.
setAttribute
(
"
pocketdisabled
"
"
true
"
)
;
}
}
receiveMessage
(
message
)
{
if
(
!
this
.
prefEnabled
)
{
return
;
}
switch
(
message
.
name
)
{
case
"
Reader
:
OnSetup
"
:
{
message
.
target
.
sendMessageToActor
(
"
Reader
:
AddButton
"
this
.
_readerButtonData
"
AboutReader
"
)
;
break
;
}
case
"
Reader
:
Clicked
-
pocket
-
button
"
:
{
let
pocketPanel
=
message
.
target
.
ownerDocument
.
querySelector
(
"
#
customizationui
-
widget
-
panel
"
)
;
if
(
pocketPanel
?
.
getAttribute
(
"
panelopen
"
)
)
{
pocketPanel
.
hidePopup
(
)
;
}
else
{
Pocket
.
savePage
(
message
.
target
)
;
}
break
;
}
}
}
}
;
