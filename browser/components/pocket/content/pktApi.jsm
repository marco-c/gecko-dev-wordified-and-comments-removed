var
EXPORTED_SYMBOLS
=
[
"
pktApi
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
IndexedDB
"
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
gCookieFirstPartyIsolate
"
"
privacy
.
firstparty
.
isolate
"
false
)
;
const
DB_NAME
=
"
SaveToPocket
"
;
const
STORE_NAME
=
"
pktAPI
"
;
const
DB_VERSION
=
1
;
const
RECENT_SAVES_UPDATE_TIME
=
5
*
60
*
1000
;
function
openDatabase
(
)
{
return
lazy
.
IndexedDB
.
open
(
DB_NAME
DB_VERSION
db
=
>
{
db
.
createObjectStore
(
STORE_NAME
)
;
}
)
;
}
let
databasePromise
;
function
getDatabase
(
)
{
if
(
!
databasePromise
)
{
databasePromise
=
openDatabase
(
)
;
}
return
databasePromise
;
}
var
pktApi
=
(
function
(
)
{
var
pocketAPIhost
=
Services
.
prefs
.
getCharPref
(
"
extensions
.
pocket
.
api
"
)
;
var
pocketSiteHost
=
Services
.
prefs
.
getCharPref
(
"
extensions
.
pocket
.
site
"
)
;
var
baseAPIUrl
=
"
https
:
/
/
"
+
pocketAPIhost
+
"
/
v3
"
;
var
oAuthConsumerKey
=
Services
.
prefs
.
getCharPref
(
"
extensions
.
pocket
.
oAuthConsumerKey
"
)
;
var
prefBranch
=
Services
.
prefs
.
getBranch
(
"
extensions
.
pocket
.
settings
.
"
)
;
var
extend
=
function
(
out
)
{
out
=
out
|
|
{
}
;
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
if
(
!
arguments
[
i
]
)
{
continue
;
}
for
(
var
key
in
arguments
[
i
]
)
{
if
(
arguments
[
i
]
.
hasOwnProperty
(
key
)
)
{
out
[
key
]
=
arguments
[
i
]
[
key
]
;
}
}
}
return
out
;
}
;
var
parseJSON
=
function
(
jsonString
)
{
try
{
var
o
=
JSON
.
parse
(
jsonString
)
;
if
(
o
&
&
typeof
o
=
=
=
"
object
"
&
&
o
!
=
=
null
)
{
return
o
;
}
}
catch
(
e
)
{
}
return
undefined
;
}
;
function
getSetting
(
key
)
{
if
(
!
prefBranch
.
prefHasUserValue
(
key
)
)
{
return
undefined
;
}
return
prefBranch
.
getStringPref
(
key
)
;
}
function
setSetting
(
key
value
)
{
if
(
!
value
)
{
prefBranch
.
clearUserPref
(
key
)
;
}
else
{
prefBranch
.
setStringPref
(
key
value
)
;
}
}
function
getCookiesFromPocket
(
)
{
var
cookies
=
{
}
;
let
oa
=
{
}
;
if
(
lazy
.
gCookieFirstPartyIsolate
)
{
oa
.
firstPartyDomain
=
pocketSiteHost
;
}
oa
.
privateBrowsingId
=
lazy
.
PrivateBrowsingUtils
.
permanentPrivateBrowsing
?
1
:
0
;
for
(
let
cookie
of
Services
.
cookies
.
getCookiesFromHost
(
pocketSiteHost
oa
)
)
{
if
(
cookie
.
host
=
=
=
pocketSiteHost
)
{
cookies
[
cookie
.
name
]
=
cookie
.
value
;
}
}
return
cookies
;
}
function
getAccessToken
(
)
{
var
pocketCookies
=
getCookiesFromPocket
(
)
;
if
(
typeof
pocketCookies
.
ftv1
=
=
=
"
undefined
"
)
{
return
undefined
;
}
var
sessionId
=
pocketCookies
.
fsv1
;
var
lastSessionId
=
getSetting
(
"
fsv1
"
)
;
if
(
sessionId
!
=
=
lastSessionId
)
{
clearUserData
(
)
;
setSetting
(
"
fsv1
"
sessionId
)
;
}
return
pocketCookies
.
ftv1
;
}
function
getPremiumStatus
(
)
{
var
premiumStatus
=
getSetting
(
"
premium_status
"
)
;
if
(
typeof
premiumStatus
=
=
=
"
undefined
"
)
{
var
pocketCookies
=
getCookiesFromPocket
(
)
;
premiumStatus
=
pocketCookies
.
ps
;
}
return
premiumStatus
;
}
function
isPremiumUser
(
)
{
return
getPremiumStatus
(
)
=
=
1
;
}
function
isUserLoggedIn
(
)
{
return
typeof
getAccessToken
(
)
!
=
=
"
undefined
"
;
}
function
apiRequest
(
options
)
{
if
(
typeof
options
=
=
=
"
undefined
"
|
|
typeof
options
.
path
=
=
=
"
undefined
"
)
{
return
false
;
}
var
url
=
baseAPIUrl
+
options
.
path
;
var
data
=
options
.
data
|
|
{
}
;
data
.
locale_lang
=
Services
.
locale
.
appLocaleAsBCP47
;
data
.
consumer_key
=
oAuthConsumerKey
;
var
request
=
new
XMLHttpRequest
(
)
;
request
.
open
(
"
POST
"
url
true
)
;
request
.
onreadystatechange
=
function
(
e
)
{
if
(
request
.
readyState
=
=
4
)
{
if
(
options
.
done
)
{
options
.
done
(
)
;
}
if
(
request
.
status
=
=
=
200
)
{
var
response
=
parseJSON
(
request
.
response
)
;
if
(
options
.
success
&
&
response
&
&
response
.
status
=
=
1
)
{
options
.
success
(
response
request
)
;
return
;
}
}
if
(
options
.
error
)
{
if
(
request
.
status
=
=
=
401
)
{
clearUserData
(
)
;
}
var
errorMessage
;
if
(
request
.
status
!
=
=
200
)
{
errorMessage
=
request
.
getResponseHeader
(
"
X
-
Error
"
)
|
|
request
.
statusText
;
errorMessage
=
JSON
.
parse
(
'
"
'
+
errorMessage
+
'
"
'
)
;
}
var
error
=
{
message
:
errorMessage
}
;
options
.
error
(
error
request
)
;
}
}
}
;
request
.
setRequestHeader
(
"
Content
-
Type
"
"
application
/
x
-
www
-
form
-
urlencoded
;
charset
=
UTF
-
8
"
)
;
request
.
setRequestHeader
(
"
X
-
Accept
"
"
application
/
json
"
)
;
var
str
=
[
]
;
for
(
var
p
in
data
)
{
if
(
data
.
hasOwnProperty
(
p
)
)
{
str
.
push
(
encodeURIComponent
(
p
)
+
"
=
"
+
encodeURIComponent
(
data
[
p
]
)
)
;
}
}
request
.
send
(
str
.
join
(
"
&
"
)
)
;
return
true
;
}
function
clearUserData
(
)
{
setSetting
(
"
premium_status
"
undefined
)
;
setSetting
(
"
latestSince
"
undefined
)
;
setSetting
(
"
tags
"
undefined
)
;
setSetting
(
"
usedTags
"
undefined
)
;
setSetting
(
"
fsv1
"
undefined
)
;
_clearRecentSavesCache
(
)
;
}
function
addLink
(
url
options
)
{
var
since
=
getSetting
(
"
latestSince
"
)
;
var
accessToken
=
getAccessToken
(
)
;
var
sendData
=
{
access_token
:
accessToken
url
since
:
since
?
since
:
0
}
;
if
(
options
.
title
)
{
sendData
.
title
=
options
.
title
;
}
return
apiRequest
(
{
path
:
"
/
firefox
/
save
"
data
:
sendData
success
(
data
)
{
var
tags
=
data
.
tags
;
if
(
typeof
tags
!
=
=
"
undefined
"
&
&
Array
.
isArray
(
tags
)
)
{
setSetting
(
"
tags
"
JSON
.
stringify
(
data
.
tags
)
)
;
}
var
premiumStatus
=
data
.
premium_status
;
if
(
typeof
premiumStatus
!
=
=
"
undefined
"
)
{
setSetting
(
"
premium_status
"
premiumStatus
)
;
}
setSetting
(
"
latestSince
"
data
.
since
)
;
if
(
data
.
flags
)
{
var
showHo2
=
Services
.
locale
.
appLocaleAsBCP47
=
=
=
"
en
-
US
"
?
data
.
flags
.
show_ffx_mobile_prompt
:
"
control
"
;
setSetting
(
"
test
.
ho2
"
showHo2
)
;
}
data
.
ho2
=
getSetting
(
"
test
.
ho2
"
)
;
_expireRecentSavesCache
(
)
;
if
(
options
.
success
)
{
options
.
success
.
apply
(
options
Array
.
apply
(
null
arguments
)
)
;
}
}
error
:
options
.
error
}
)
;
}
function
getRecsForItem
(
itemId
options
)
{
return
apiRequest
(
{
path
:
"
/
discover
/
recIt
"
data
:
{
item_id
:
itemId
module
:
"
ff_plugin
"
count
:
3
}
success
(
data
)
{
if
(
options
.
success
)
{
options
.
success
.
apply
(
options
Array
.
apply
(
null
arguments
)
)
;
}
}
error
:
options
.
error
}
)
;
}
function
getArticleInfo
(
url
options
)
{
return
apiRequest
(
{
path
:
"
/
getItemPreview
"
data
:
{
access_token
:
getAccessToken
(
)
url
}
success
(
data
)
{
if
(
options
.
success
)
{
options
.
success
.
apply
(
options
Array
.
apply
(
null
arguments
)
)
;
}
}
error
:
options
.
error
done
:
options
.
done
}
)
;
}
function
getMobileDownload
(
options
)
{
return
apiRequest
(
{
path
:
"
/
firefox
/
get
-
app
"
data
:
{
access_token
:
getAccessToken
(
)
}
success
(
data
)
{
if
(
options
.
success
)
{
options
.
success
.
apply
(
options
Array
.
apply
(
null
arguments
)
)
;
}
}
error
:
options
.
error
}
)
;
}
function
deleteItem
(
itemId
options
)
{
var
action
=
{
action
:
"
delete
"
item_id
:
itemId
}
;
return
sendAction
(
action
options
)
;
}
function
archiveItem
(
itemId
options
)
{
var
action
=
{
action
:
"
archive
"
item_id
:
itemId
}
;
return
sendAction
(
action
options
)
;
}
function
sendAction
(
action
options
)
{
if
(
typeof
options
.
actionInfo
!
=
=
"
undefined
"
)
{
action
=
extend
(
action
options
.
actionInfo
)
;
}
return
sendActions
(
[
action
]
options
)
;
}
function
sendActions
(
actions
options
)
{
return
apiRequest
(
{
path
:
"
/
send
"
data
:
{
access_token
:
getAccessToken
(
)
actions
:
JSON
.
stringify
(
actions
)
}
success
:
options
.
success
error
:
options
.
error
}
)
;
}
function
addTagsToItem
(
itemId
tags
options
)
{
return
addTags
(
{
item_id
:
itemId
}
tags
options
)
;
}
function
addTagsToURL
(
url
tags
options
)
{
return
addTags
(
{
url
}
tags
options
)
;
}
function
addTags
(
actionPart
tags
options
)
{
var
action
=
{
action
:
"
tags_add
"
tags
}
;
action
=
extend
(
action
actionPart
)
;
return
sendAction
(
action
options
)
;
}
function
getTags
(
)
{
var
tagsFromSettings
=
function
(
)
{
var
tagsJSON
=
getSetting
(
"
tags
"
)
;
if
(
typeof
tagsJSON
!
=
=
"
undefined
"
)
{
return
JSON
.
parse
(
tagsJSON
)
;
}
return
[
]
;
}
;
return
{
tags
:
tagsFromSettings
(
)
}
;
}
function
getSuggestedTagsForItem
(
itemId
options
)
{
return
getSuggestedTags
(
{
item_id
:
itemId
}
options
)
;
}
function
getSuggestedTagsForURL
(
url
options
)
{
return
getSuggestedTags
(
{
url
}
options
)
;
}
function
getSuggestedTags
(
data
options
)
{
data
=
data
|
|
{
}
;
options
=
options
|
|
{
}
;
data
.
access_token
=
getAccessToken
(
)
;
return
apiRequest
(
{
path
:
"
/
getSuggestedTags
"
data
success
:
options
.
success
error
:
options
.
error
}
)
;
}
function
retrieve
(
data
=
{
}
options
=
{
}
)
{
const
requestData
=
Object
.
assign
(
{
}
data
{
access_token
:
getAccessToken
(
)
}
)
;
return
apiRequest
(
{
path
:
"
/
firefox
/
get
"
data
:
requestData
success
:
options
.
success
error
:
options
.
error
}
)
;
}
async
function
_getRecentSavesCache
(
)
{
const
db
=
await
getDatabase
(
)
;
return
db
.
objectStore
(
STORE_NAME
"
readonly
"
)
.
get
(
"
recentSaves
"
)
;
}
async
function
_setRecentSavesCache
(
data
)
{
const
db
=
await
getDatabase
(
)
;
db
.
objectStore
(
STORE_NAME
"
readwrite
"
)
.
put
(
data
"
recentSaves
"
)
;
}
async
function
_expireRecentSavesCache
(
)
{
const
cache
=
await
_getRecentSavesCache
(
)
;
_setRecentSavesCache
(
{
.
.
.
cache
lastUpdated
:
0
}
)
;
}
async
function
_clearRecentSavesCache
(
)
{
const
db
=
await
getDatabase
(
)
;
db
.
objectStore
(
STORE_NAME
"
readwrite
"
)
.
delete
(
"
recentSaves
"
)
;
}
async
function
getRecentSavesCache
(
)
{
const
cache
=
await
_getRecentSavesCache
(
)
;
if
(
cache
?
.
lastUpdated
&
&
Date
.
now
(
)
-
cache
.
lastUpdated
<
RECENT_SAVES_UPDATE_TIME
)
{
return
cache
.
list
;
}
return
null
;
}
async
function
getRecentSaves
(
options
=
{
}
)
{
pktApi
.
retrieve
(
{
count
:
4
}
{
success
(
data
)
{
const
results
=
{
lastUpdated
:
Date
.
now
(
)
list
:
Object
.
values
(
data
.
list
)
.
map
(
item
=
>
(
{
.
.
.
item
time_added
:
parseInt
(
item
.
time_added
)
}
)
)
.
sort
(
(
a
b
)
=
>
b
.
time_added
-
a
.
time_added
)
}
;
_setRecentSavesCache
(
results
)
;
options
.
success
?
.
(
results
.
list
)
;
}
error
(
error
)
{
options
.
error
?
.
(
error
)
;
}
}
)
;
}
return
{
isUserLoggedIn
clearUserData
addLink
getRecsForItem
deleteItem
archiveItem
addTagsToItem
addTagsToURL
getTags
isPremiumUser
getSuggestedTagsForItem
getSuggestedTagsForURL
retrieve
getRecentSavesCache
getRecentSaves
getArticleInfo
getMobileDownload
}
;
}
)
(
)
;
