var
EXPORTED_SYMBOLS
=
[
"
WebProtocolHandlerRegistrar
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
STRING_BUNDLE_URI
=
"
chrome
:
/
/
browser
/
locale
/
feeds
/
subscribe
.
properties
"
;
function
WebProtocolHandlerRegistrar
(
)
{
}
WebProtocolHandlerRegistrar
.
prototype
=
{
get
stringBundle
(
)
{
let
sb
=
Services
.
strings
.
createBundle
(
STRING_BUNDLE_URI
)
;
delete
WebProtocolHandlerRegistrar
.
prototype
.
stringBundle
;
return
WebProtocolHandlerRegistrar
.
prototype
.
stringBundle
=
sb
;
}
_getFormattedString
(
key
params
)
{
return
this
.
stringBundle
.
formatStringFromName
(
key
params
params
.
length
)
;
}
_getString
(
key
)
{
return
this
.
stringBundle
.
GetStringFromName
(
key
)
;
}
removeProtocolHandler
(
aProtocol
aURITemplate
)
{
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
aProtocol
)
;
let
handlers
=
handlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
0
;
i
<
handlers
.
length
;
i
+
+
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
if
(
handler
.
uriTemplate
=
=
aURITemplate
)
{
handlers
.
removeElementAt
(
i
)
;
let
hs
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
hs
.
store
(
handlerInfo
)
;
return
;
}
}
catch
(
e
)
{
}
}
}
_protocolHandlerRegistered
(
aProtocol
aURITemplate
)
{
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
aProtocol
)
;
let
handlers
=
handlerInfo
.
possibleApplicationHandlers
;
for
(
let
i
=
0
;
i
<
handlers
.
length
;
i
+
+
)
{
try
{
let
handler
=
handlers
.
queryElementAt
(
i
Ci
.
nsIWebHandlerApp
)
;
if
(
handler
.
uriTemplate
=
=
aURITemplate
)
{
return
true
;
}
}
catch
(
e
)
{
}
}
return
false
;
}
registerProtocolHandler
(
aProtocol
aURI
aTitle
aDocumentURI
aBrowserOrWindow
)
{
aProtocol
=
(
aProtocol
|
|
"
"
)
.
toLowerCase
(
)
;
if
(
!
aURI
|
|
!
aDocumentURI
)
{
return
;
}
let
browser
=
aBrowserOrWindow
;
if
(
aBrowserOrWindow
instanceof
Ci
.
nsIDOMWindow
)
{
let
rootDocShell
=
aBrowserOrWindow
.
docShell
.
sameTypeRootTreeItem
;
browser
=
rootDocShell
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
;
}
let
browserWindow
=
browser
.
ownerGlobal
;
try
{
browserWindow
.
navigator
.
checkProtocolHandlerAllowed
(
aProtocol
aURI
aDocumentURI
)
;
}
catch
(
ex
)
{
return
;
}
if
(
this
.
_protocolHandlerRegistered
(
aProtocol
aURI
.
spec
)
)
{
return
;
}
let
message
=
this
.
_getFormattedString
(
"
addProtocolHandlerMessage
"
[
aURI
.
host
aProtocol
]
)
;
let
notificationIcon
=
aURI
.
prePath
+
"
/
favicon
.
ico
"
;
let
notificationValue
=
"
Protocol
Registration
:
"
+
aProtocol
;
let
addButton
=
{
label
:
this
.
_getString
(
"
addProtocolHandlerAddButton
"
)
accessKey
:
this
.
_getString
(
"
addProtocolHandlerAddButtonAccesskey
"
)
protocolInfo
:
{
protocol
:
aProtocol
uri
:
aURI
.
spec
name
:
aTitle
}
callback
(
aNotification
aButtonInfo
)
{
let
protocol
=
aButtonInfo
.
protocolInfo
.
protocol
;
let
name
=
aButtonInfo
.
protocolInfo
.
name
;
let
handler
=
Cc
[
"
mozilla
.
org
/
uriloader
/
web
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsIWebHandlerApp
)
;
handler
.
name
=
name
;
handler
.
uriTemplate
=
aButtonInfo
.
protocolInfo
.
uri
;
let
eps
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
;
let
handlerInfo
=
eps
.
getProtocolHandlerInfo
(
protocol
)
;
handlerInfo
.
possibleApplicationHandlers
.
appendElement
(
handler
)
;
handlerInfo
.
alwaysAskBeforeHandling
=
true
;
let
hs
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
hs
.
store
(
handlerInfo
)
;
}
}
;
let
notificationBox
=
browser
.
getTabBrowser
(
)
.
getNotificationBox
(
browser
)
;
notificationBox
.
appendNotification
(
message
notificationValue
notificationIcon
notificationBox
.
PRIORITY_INFO_LOW
[
addButton
]
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProtocolHandlerRegistrar
]
)
}
;
