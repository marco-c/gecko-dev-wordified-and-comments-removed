"
use
strict
"
;
const
{
BuiltInThemes
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
BuiltInThemes
.
jsm
"
)
;
const
{
AddonManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
INTENSITY_SOFT
=
"
soft
"
;
const
INTENSITY_BALANCED
=
"
balanced
"
;
const
INTENSITY_BOLD
=
"
bold
"
;
const
ID_SUFFIX_FOR_PRIMARY_INTENSITY
=
-
{
INTENSITY_BALANCED
}
-
colorway
mozilla
.
org
;
const
ID_SUFFIXES_FOR_SECONDARY_INTENSITIES
=
new
RegExp
(
-
(
{
INTENSITY_SOFT
}
|
{
INTENSITY_BOLD
}
)
-
colorway
mozilla
\
\
.
org
)
;
const
MATCH_INTENSITY_FROM_ID
=
new
RegExp
(
-
(
{
INTENSITY_SOFT
}
|
{
INTENSITY_BALANCED
}
|
{
INTENSITY_BOLD
}
)
-
colorway
mozilla
\
\
.
org
)
;
const
ColorwaySelector
=
{
revertToPreviousTheme
:
true
colorwayRadios
:
document
.
getElementById
(
"
colorway
-
selector
"
)
intensityContainer
:
document
.
getElementById
(
"
colorway
-
intensities
"
)
init
(
)
{
this
.
_displayCollectionData
(
)
;
AddonManager
.
addAddonListener
(
this
)
;
window
.
addEventListener
(
"
unload
"
this
)
;
this
.
_initColorwayRadios
(
)
;
this
.
colorwayRadios
.
addEventListener
(
"
change
"
this
)
;
this
.
intensityContainer
.
addEventListener
(
"
change
"
this
)
;
document
.
getElementById
(
"
set
-
colorway
"
)
.
onclick
=
(
)
=
>
{
this
.
revertToPreviousTheme
=
false
;
window
.
close
(
)
;
}
;
}
async
_initColorwayRadios
(
)
{
BuiltInThemes
.
ensureBuiltInThemes
(
)
;
let
themes
=
await
AddonManager
.
getAddonsByTypes
(
[
"
theme
"
]
)
;
this
.
previousTheme
=
themes
.
find
(
theme
=
>
theme
.
isActive
)
;
this
.
colorways
=
themes
.
filter
(
theme
=
>
BuiltInThemes
.
isColorwayFromCurrentCollection
(
theme
.
id
)
)
;
this
.
colorwayGroups
=
this
.
colorways
.
filter
(
colorway
=
>
!
ID_SUFFIXES_FOR_SECONDARY_INTENSITIES
.
test
(
colorway
.
id
)
)
;
for
(
const
addon
of
this
.
colorwayGroups
)
{
let
input
=
document
.
createElement
(
"
input
"
)
;
input
.
type
=
"
radio
"
;
input
.
name
=
"
colorway
"
;
input
.
value
=
addon
.
id
;
input
.
setAttribute
(
"
title
"
addon
.
name
)
;
input
.
style
.
setProperty
(
"
-
-
colorway
-
icon
"
url
(
{
addon
.
iconURL
}
)
)
;
this
.
colorwayRadios
.
appendChild
(
input
)
;
}
this
.
selectedColorway
=
this
.
colorways
.
find
(
colorway
=
>
colorway
.
isActive
)
;
if
(
this
.
selectedColorway
)
{
this
.
refresh
(
)
;
}
else
{
this
.
colorwayGroups
[
0
]
.
enable
(
)
;
}
}
_displayCollectionData
(
)
{
const
collection
=
BuiltInThemes
.
findActiveColorwayCollection
(
)
;
if
(
!
collection
)
{
window
.
close
(
)
;
}
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
collection
-
title
"
)
collection
.
l10nId
.
title
)
;
document
.
l10n
.
setAttributes
(
document
.
querySelector
(
"
#
collection
-
expiry
-
date
>
span
"
)
"
colorway
-
collection
-
expiry
-
date
-
span
"
{
expiryDate
:
collection
.
expiry
.
getTime
(
)
}
)
;
}
_displayColorwayData
(
)
{
document
.
getElementById
(
"
colorway
-
name
"
)
.
innerText
=
this
.
selectedColorway
.
name
;
document
.
getElementById
(
"
colorway
-
description
"
)
.
innerText
=
this
.
groupIdForSelectedColorway
;
this
.
intensityContainer
.
hidden
=
!
this
.
hasIntensities
;
if
(
this
.
hasIntensities
)
{
let
selectedIntensity
=
this
.
selectedColorway
.
id
.
match
(
MATCH_INTENSITY_FROM_ID
)
[
1
]
;
for
(
let
radio
of
document
.
querySelectorAll
(
"
.
colorway
-
intensity
-
radio
"
)
)
{
let
intensity
=
radio
.
getAttribute
(
"
data
-
intensity
"
)
;
radio
.
value
=
this
.
selectedColorway
.
id
.
replace
(
MATCH_INTENSITY_FROM_ID
-
{
intensity
}
-
colorway
mozilla
.
org
)
;
if
(
intensity
=
=
selectedIntensity
)
{
radio
.
checked
=
true
;
}
}
}
}
_getColorwayGroupId
(
colorwayId
)
{
let
groupId
=
colorwayId
.
replace
(
ID_SUFFIXES_FOR_SECONDARY_INTENSITIES
ID_SUFFIX_FOR_PRIMARY_INTENSITY
)
;
return
this
.
colorwayGroups
.
map
(
addon
=
>
addon
.
id
)
.
includes
(
groupId
)
?
groupId
:
null
;
}
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
change
"
:
this
.
colorways
.
find
(
colorway
=
>
colorway
.
id
=
=
e
.
target
.
value
)
.
enable
(
)
;
break
;
case
"
unload
"
:
AddonManager
.
removeAddonListener
(
this
)
;
if
(
this
.
revertToPreviousTheme
)
{
this
.
previousTheme
.
enable
(
)
;
}
break
;
}
}
onEnabled
(
addon
)
{
if
(
addon
.
type
=
=
"
theme
"
)
{
if
(
!
this
.
colorways
.
find
(
colorway
=
>
colorway
.
id
=
=
addon
.
id
)
)
{
this
.
revertToPreviousTheme
=
false
;
window
.
close
(
)
;
return
;
}
this
.
selectedColorway
=
addon
;
this
.
refresh
(
)
;
}
}
refresh
(
)
{
this
.
groupIdForSelectedColorway
=
this
.
_getColorwayGroupId
(
this
.
selectedColorway
.
id
)
;
this
.
hasIntensities
=
this
.
groupIdForSelectedColorway
.
endsWith
(
ID_SUFFIX_FOR_PRIMARY_INTENSITY
)
;
for
(
let
input
of
this
.
colorwayRadios
.
children
)
{
if
(
input
.
value
=
=
this
.
groupIdForSelectedColorway
)
{
input
.
checked
=
true
;
this
.
_displayColorwayData
(
)
;
break
;
}
}
}
}
;
function
showUseFXHomeControls
(
)
{
const
{
HomePage
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
HomePage
.
jsm
"
)
;
const
useFXHomeControls
=
document
.
getElementById
(
"
use
-
fx
-
home
-
controls
"
)
;
useFXHomeControls
.
hidden
=
HomePage
.
isDefault
;
if
(
!
HomePage
.
isDefault
)
{
let
homeState
;
useFXHomeControls
.
querySelector
(
"
.
reset
-
prompt
>
button
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
homeState
=
HomePage
.
get
(
)
;
HomePage
.
reset
(
)
;
useFXHomeControls
.
classList
.
add
(
"
success
"
)
;
}
)
;
useFXHomeControls
.
querySelector
(
"
.
success
-
prompt
>
button
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
HomePage
.
set
(
homeState
)
;
useFXHomeControls
.
classList
.
remove
(
"
success
"
)
;
}
)
;
}
}
ColorwaySelector
.
init
(
)
;
showUseFXHomeControls
(
)
;
