"
use
strict
"
;
const
{
ASRouter
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
asrouter
/
ASRouter
.
sys
.
mjs
"
)
;
const
{
ERRORS
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
browser
/
content
/
ipprotection
/
ipprotection
-
constants
.
mjs
"
)
;
const
{
AddonTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
sys
.
mjs
"
)
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
)
;
AddonTestUtils
.
initMochitest
(
this
)
;
DEFAULT_EXPERIMENT
=
null
;
add_task
(
async
function
test_IPProtectionService_updateEligibility
(
)
{
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
Assert
.
ok
(
IPProtectionService
.
isEligible
"
Should
be
in
the
experiment
"
)
;
let
buttonOn
=
document
.
getElementById
(
IPProtectionWidget
.
WIDGET_ID
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
buttonOn
)
"
IP
Protection
widget
should
be
added
to
the
navbar
"
)
;
await
cleanupAlpha
(
)
;
let
cleanupControl
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
control
"
}
)
;
Assert
.
ok
(
!
IPProtectionService
.
isEligible
"
Should
not
be
in
the
experiment
"
)
;
let
buttonOff
=
document
.
getElementById
(
IPProtectionWidget
.
WIDGET_ID
)
;
Assert
.
ok
(
!
buttonOff
"
IP
Protection
widget
should
not
be
added
to
the
navbar
"
)
;
await
cleanupControl
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_updateEnrollment
(
)
{
setupService
(
{
isSignedIn
:
true
isEnrolled
:
true
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
ipProtection
.
enabled
"
true
]
]
}
)
;
await
waitForWidgetAdded
(
)
;
let
button
=
document
.
getElementById
(
IPProtectionWidget
.
WIDGET_ID
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
button
)
"
IP
Protection
widget
should
be
added
to
the
navbar
"
)
;
cleanupService
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_enroll
(
)
{
setupService
(
{
isEnrolled
:
false
canEnroll
:
true
}
)
;
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
await
waitForWidgetAdded
(
)
;
setupService
(
{
isSignedIn
:
true
}
)
;
await
IPProtectionService
.
updateSignInStatus
(
)
;
await
openPanel
(
)
;
await
IPProtectionService
.
enrolling
;
Assert
.
ok
(
IPProtectionService
.
isEnrolled
"
User
should
now
be
enrolled
"
)
;
cleanupService
(
)
;
await
cleanupAlpha
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_enroll_when_enrolled_in_experiment
(
)
{
setupService
(
{
isEnrolled
:
false
isSignedIn
:
true
canEnroll
:
true
}
)
;
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
await
waitForWidgetAdded
(
)
;
let
content
=
await
openPanel
(
)
;
await
IPProtectionService
.
enrolling
;
Assert
.
ok
(
IPProtectionService
.
isEnrolled
"
User
should
now
be
enrolled
"
)
;
Assert
.
ok
(
content
.
connectionToggleEl
"
Status
card
connection
toggle
should
be
present
"
)
;
cleanupService
(
)
;
await
cleanupAlpha
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_updateEntitlement_in_experiment
(
)
{
setupService
(
{
isEnrolled
:
false
isSignedIn
:
true
canEnroll
:
true
}
)
;
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
await
waitForWidgetAdded
(
)
;
await
IPProtectionService
.
updateSignInStatus
(
)
;
await
openPanel
(
)
;
await
IPProtectionService
.
enrolling
;
Assert
.
equal
(
IPProtectionService
.
isEntitled
true
"
Entitlement
set
the
user
as
entitled
"
)
;
cleanupService
(
)
;
await
cleanupAlpha
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_updateEntitlement
(
)
{
setupService
(
{
isSignedIn
:
true
isEnrolled
:
true
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
ipProtection
.
enabled
"
true
]
]
}
)
;
await
waitForWidgetAdded
(
)
;
Assert
.
equal
(
IPProtectionService
.
isEntitled
true
"
Entitlement
set
the
user
as
entitled
"
)
;
cleanupService
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_ipprotection_ready
(
)
{
setupService
(
{
isSignedIn
:
true
isEnrolled
:
true
}
)
;
const
sandbox
=
sinon
.
createSandbox
(
)
;
const
receivedTrigger
=
new
Promise
(
resolve
=
>
{
sandbox
.
stub
(
ASRouter
"
sendTriggerMessage
"
)
.
callsFake
(
(
{
id
}
)
=
>
{
if
(
id
=
=
=
"
ipProtectionReady
"
)
{
resolve
(
true
)
;
}
}
)
;
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
ipProtection
.
enabled
"
true
]
]
}
)
;
let
ipProtectionReadyTrigger
=
await
receivedTrigger
;
Assert
.
ok
(
ipProtectionReadyTrigger
"
ipProtectionReady
trigger
sent
"
)
;
sandbox
.
restore
(
)
;
cleanupService
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_pass_errors
(
)
{
setupService
(
{
isSignedIn
:
true
proxyPass
:
{
status
:
403
}
}
)
;
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
await
IPProtectionService
.
updateSignInStatus
(
)
;
let
content
=
await
openPanel
(
)
;
let
messageBarLoadedPromise
=
BrowserTestUtils
.
waitForMutationCondition
(
content
.
shadowRoot
{
childList
:
true
subtree
:
true
}
(
)
=
>
content
.
shadowRoot
.
querySelector
(
"
ipprotection
-
message
-
bar
"
)
)
;
IPProtectionService
.
proxyManager
.
reset
(
)
;
content
.
connectionToggleEl
.
click
(
)
;
Assert
.
ok
(
!
IPProtectionService
.
isActive
"
Proxy
is
not
active
"
)
;
await
messageBarLoadedPromise
;
let
messageBar
=
content
.
shadowRoot
.
querySelector
(
"
ipprotection
-
message
-
bar
"
)
;
Assert
.
ok
(
!
content
.
connectionToggleEl
.
pressed
"
Toggle
is
off
"
)
;
Assert
.
ok
(
messageBar
"
Message
bar
should
be
present
"
)
;
Assert
.
equal
(
content
.
state
.
error
ERRORS
.
GENERIC
"
Should
have
a
generic
error
"
)
;
let
button
=
document
.
getElementById
(
IPProtectionWidget
.
WIDGET_ID
)
;
Assert
.
ok
(
button
.
classList
.
contains
(
"
ipprotection
-
error
"
)
"
Toolbar
icon
should
show
the
error
status
"
)
;
await
closePanel
(
)
;
Assert
.
equal
(
content
.
state
.
error
"
"
"
Should
have
no
error
"
)
;
IPProtectionService
.
hasError
=
false
;
IPProtectionService
.
errors
=
[
]
;
await
cleanupAlpha
(
)
;
cleanupService
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_retry_errors
(
)
{
setupService
(
{
isSignedIn
:
true
isEnrolled
:
true
canEnroll
:
true
}
)
;
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
await
IPProtectionService
.
updateSignInStatus
(
)
;
let
content
=
await
openPanel
(
)
;
IPProtectionService
.
isEnrolled
=
false
;
IPProtectionService
.
hasError
=
true
;
let
startedEventPromise
=
BrowserTestUtils
.
waitForEvent
(
IPProtectionService
"
IPProtectionService
:
Started
"
)
;
content
.
connectionToggleEl
.
click
(
)
;
await
startedEventPromise
;
Assert
.
ok
(
IPProtectionService
.
isActive
"
Proxy
is
active
"
)
;
Assert
.
ok
(
IPProtectionService
.
isEnrolled
"
User
is
now
enrolled
"
)
;
Assert
.
ok
(
!
IPProtectionService
.
hasError
"
There
is
no
longer
an
error
"
)
;
IPProtectionService
.
stop
(
)
;
await
closePanel
(
)
;
await
cleanupAlpha
(
)
;
cleanupService
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_stop_on_signout
(
)
{
setupService
(
{
isSignedIn
:
true
canEnroll
:
true
}
)
;
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
await
IPProtectionService
.
updateSignInStatus
(
)
;
let
content
=
await
openPanel
(
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
content
)
"
ipprotection
content
component
should
be
present
"
)
;
Assert
.
ok
(
content
.
connectionToggleEl
"
Status
card
connection
toggle
should
be
present
"
)
;
let
startedEventPromise
=
BrowserTestUtils
.
waitForEvent
(
IPProtectionService
"
IPProtectionService
:
Started
"
)
;
content
.
connectionToggleEl
.
click
(
)
;
await
startedEventPromise
;
Assert
.
ok
(
IPProtectionService
.
isActive
"
Proxy
is
active
"
)
;
let
vpnOffPromise
=
BrowserTestUtils
.
waitForEvent
(
IPProtectionService
"
IPProtectionService
:
Stopped
"
)
;
setupService
(
{
isSignedIn
:
false
}
)
;
let
signedOut
=
IPProtectionService
.
updateSignInStatus
(
)
;
await
Promise
.
all
(
[
signedOut
vpnOffPromise
]
)
;
Assert
.
ok
(
!
IPProtectionService
.
isActive
"
Proxy
has
stopped
"
)
;
await
closePanel
(
)
;
await
cleanupAlpha
(
)
;
cleanupService
(
)
;
}
)
;
function
waitForTabReloaded
(
tab
)
{
return
new
Promise
(
resolve
=
>
{
gBrowser
.
addTabsProgressListener
(
{
async
onLocationChange
(
aBrowser
)
{
if
(
tab
.
linkedBrowser
=
=
aBrowser
)
{
gBrowser
.
removeTabsProgressListener
(
this
)
;
await
Promise
.
resolve
(
)
;
resolve
(
)
;
}
}
}
)
;
}
)
;
}
add_task
(
async
function
test_IPProtectionService_reload
(
)
{
setupService
(
{
isSignedIn
:
true
canEnroll
:
true
}
)
;
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
IPProtectionService
.
isSignedIn
=
false
;
await
IPProtectionService
.
updateSignInStatus
(
)
;
let
content
=
await
openPanel
(
)
;
Assert
.
ok
(
IPProtectionService
.
isEnrolled
"
User
should
be
enrolled
"
)
;
Assert
.
equal
(
IPProtectionService
.
isEntitled
true
"
User
should
be
entitled
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
content
)
"
ipprotection
content
component
should
be
present
"
)
;
Assert
.
ok
(
content
.
connectionToggleEl
"
Status
card
connection
toggle
should
be
present
"
)
;
let
tabReloaded
=
waitForTabReloaded
(
gBrowser
.
selectedTab
)
;
content
.
connectionToggleEl
.
click
(
)
;
await
tabReloaded
;
Assert
.
ok
(
IPProtectionService
.
isActive
"
Proxy
is
active
"
)
;
tabReloaded
=
waitForTabReloaded
(
gBrowser
.
selectedTab
)
;
content
.
connectionToggleEl
.
click
(
)
;
await
tabReloaded
;
Assert
.
ok
(
!
IPProtectionService
.
isActive
"
Proxy
is
not
active
"
)
;
await
closePanel
(
)
;
await
cleanupAlpha
(
)
;
cleanupService
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_addon
(
)
{
let
widget
=
document
.
getElementById
(
IPProtectionWidget
.
WIDGET_ID
)
;
let
prevPosition
=
CustomizableUI
.
getPlacementOfWidget
(
IPProtectionWidget
.
WIDGET_ID
)
.
position
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
widget
)
"
IP
-
Protection
toolbaritem
is
enabled
"
)
;
IPProtectionService
.
hasUpgraded
=
true
;
const
extension
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
manifest_version
:
2
name
:
"
Test
VPN
"
version
:
"
1
.
0
"
applications
:
{
gecko
:
{
id
:
"
vpn
mozilla
.
com
"
}
}
}
}
)
;
await
extension
.
startup
(
)
;
Assert
.
ok
(
!
BrowserTestUtils
.
isVisible
(
widget
)
"
IP
-
Protection
toolbaritem
is
removed
"
)
;
CustomizableUI
.
addWidgetToArea
(
IPProtectionWidget
.
WIDGET_ID
CustomizableUI
.
AREA_NAVBAR
prevPosition
)
;
widget
=
document
.
getElementById
(
IPProtectionWidget
.
WIDGET_ID
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
widget
)
"
IP
-
Protection
toolbaritem
is
re
-
added
"
)
;
await
extension
.
unload
(
)
;
IPProtectionService
.
hasUpgraded
=
false
;
const
extension2
=
ExtensionTestUtils
.
loadExtension
(
{
useAddonManager
:
"
permanent
"
manifest
:
{
manifest_version
:
2
name
:
"
Test
VPN
"
version
:
"
2
.
0
"
applications
:
{
gecko
:
{
id
:
"
vpn
mozilla
.
com
"
}
}
}
}
)
;
await
extension2
.
startup
(
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
widget
)
"
IP
-
Protection
toolbaritem
does
not
change
when
user
has
not
upgraded
"
)
;
await
extension2
.
unload
(
)
;
}
)
;
add_task
(
async
function
test_IPProtectionService_exposure
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
let
cleanupAlpha
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
alpha
"
}
)
;
await
cleanupAlpha
(
)
;
let
cleanupControl
=
await
setupExperiment
(
{
enabled
:
true
variant
:
"
control
"
}
)
;
await
cleanupControl
(
)
;
TelemetryTestUtils
.
assertEvents
(
[
{
method
:
"
expose
"
object
:
"
nimbus_experiment
"
value
:
"
vpn
-
test
"
extra
:
{
branchSlug
:
"
alpha
"
featureId
:
"
ipProtection
"
}
}
{
method
:
"
expose
"
object
:
"
nimbus_experiment
"
value
:
"
vpn
-
test
"
extra
:
{
branchSlug
:
"
control
"
featureId
:
"
ipProtection
"
}
}
]
{
method
:
"
expose
"
}
)
;
}
)
;
