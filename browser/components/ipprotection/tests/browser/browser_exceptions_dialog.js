"
use
strict
"
;
const
{
IPPExceptionsManager
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
ipprotection
/
IPPExceptionsManager
.
sys
.
mjs
"
)
;
const
MODE_PREF
=
"
browser
.
ipProtection
.
exceptionsMode
"
;
const
ALL_MODE
=
"
all
"
;
const
SELECT_MODE
=
"
select
"
;
const
ONBOARDING_MESSAGE_MASK_PREF
=
"
browser
.
ipProtection
.
onboardingMessageMask
"
;
const
PERM_NAME
=
"
ipp
-
vpn
"
;
async
function
openDialog
(
browser
capabilityFilter
)
{
let
params
=
{
hideStatusColumn
:
true
prefilledHost
:
"
"
permissionType
:
PERM_NAME
capabilityFilter
}
;
let
dialogLoaded
=
TestUtils
.
topicObserved
(
"
subdialog
-
loaded
"
)
;
browser
.
contentWindow
.
gSubDialog
.
open
(
"
chrome
:
/
/
browser
/
content
/
preferences
/
dialogs
/
permissions
.
xhtml
"
{
features
:
"
resizable
=
yes
"
}
params
)
;
let
[
dialogWin
]
=
await
dialogLoaded
;
return
dialogWin
;
}
function
addMockPrincipalToIPPVPN
(
site
capability
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
site
)
;
Services
.
perms
.
addFromPrincipal
(
principal
PERM_NAME
capability
)
;
}
function
setupTestExceptions
(
mode
)
{
const
site1
=
"
https
:
/
/
www
.
example
.
com
"
;
const
site2
=
"
https
:
/
/
www
.
another
.
example
.
com
"
;
const
site3
=
"
https
:
/
/
www
.
shouldbeignored
.
example
.
org
"
;
let
expectedCapability
;
let
unexpectedCapability
;
if
(
mode
=
=
=
ALL_MODE
)
{
expectedCapability
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
;
unexpectedCapability
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
}
else
{
expectedCapability
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
unexpectedCapability
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
;
}
addMockPrincipalToIPPVPN
(
site1
expectedCapability
)
;
addMockPrincipalToIPPVPN
(
site2
expectedCapability
)
;
addMockPrincipalToIPPVPN
(
site3
unexpectedCapability
)
;
let
expectedExceptions
=
Services
.
perms
.
getAllByTypes
(
[
PERM_NAME
]
)
.
filter
(
perm
=
>
perm
.
capability
=
=
=
expectedCapability
)
;
let
unexpectedExceptions
=
Services
.
perms
.
getAllByTypes
(
[
PERM_NAME
]
)
.
filter
(
perm
=
>
perm
.
capability
=
=
=
unexpectedCapability
)
;
let
expectedTypeName
=
mode
=
=
=
ALL_MODE
?
"
exclusions
"
:
"
inclusions
"
;
let
unexpectedTypeName
=
mode
=
=
=
ALL_MODE
?
"
inclusion
"
:
"
exclusion
"
;
Assert
.
equal
(
expectedExceptions
.
length
2
There
should
be
2
{
expectedTypeName
}
)
;
Assert
.
equal
(
unexpectedExceptions
.
length
1
There
should
be
1
{
unexpectedTypeName
}
)
;
return
expectedExceptions
.
map
(
permission
=
>
permission
.
principal
.
prePath
)
;
}
async
function
testExceptionsInDialog
(
expectedSites
capabilityFilter
)
{
await
BrowserTestUtils
.
withNewTab
(
"
about
:
preferences
"
async
browser
=
>
{
let
dialog
=
await
openDialog
(
browser
capabilityFilter
)
;
Assert
.
ok
(
dialog
"
Dialog
was
found
"
)
;
let
permissionsBox
=
dialog
.
document
.
getElementById
(
"
permissionsBox
"
)
;
await
BrowserTestUtils
.
waitForMutationCondition
(
permissionsBox
{
childList
:
true
subtree
:
true
}
(
)
=
>
{
return
permissionsBox
.
itemCount
=
=
=
2
;
}
)
;
let
numberOfExceptions
=
permissionsBox
.
itemCount
;
Assert
.
equal
(
numberOfExceptions
2
"
There
should
be
2
inclusions
in
the
dialog
"
)
;
let
displayedSites
=
Array
.
from
(
permissionsBox
.
children
)
.
map
(
entry
=
>
entry
.
getAttribute
(
"
origin
"
)
)
;
Assert
.
ok
(
displayedSites
.
includes
(
expectedSites
[
0
]
)
{
expectedSites
[
0
]
}
was
displayed
in
the
dialog
as
an
exception
)
;
Assert
.
ok
(
displayedSites
.
includes
(
expectedSites
[
1
]
)
{
expectedSites
[
1
]
}
was
displayed
in
the
dialog
as
an
exception
)
;
}
)
;
}
function
cleanupExceptions
(
)
{
Services
.
perms
.
removeByType
(
PERM_NAME
)
;
}
add_task
(
async
function
test_filter_dialog_exclusions_only
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
MODE_PREF
ALL_MODE
]
]
}
)
;
let
exclusions
=
setupTestExceptions
(
ALL_MODE
)
;
const
capabilityFilter
=
Ci
.
nsIPermissionManager
.
DENY_ACTION
;
await
testExceptionsInDialog
(
exclusions
capabilityFilter
)
;
cleanupExceptions
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
Services
.
prefs
.
clearUserPref
(
ONBOARDING_MESSAGE_MASK_PREF
)
;
}
)
;
add_task
(
async
function
test_filter_dialog_inclusions_only
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
MODE_PREF
SELECT_MODE
]
]
}
)
;
let
inclusions
=
setupTestExceptions
(
SELECT_MODE
)
;
const
capabilityFilter
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
await
testExceptionsInDialog
(
inclusions
capabilityFilter
)
;
cleanupExceptions
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
Services
.
prefs
.
clearUserPref
(
ONBOARDING_MESSAGE_MASK_PREF
)
;
}
)
;
