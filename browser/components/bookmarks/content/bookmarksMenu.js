#
-
*
-
Mode
:
Java
;
tab
-
width
:
2
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
#
*
*
*
*
*
BEGIN
LICENSE
BLOCK
*
*
*
*
*
#
Version
:
MPL
1
.
1
/
GPL
2
.
0
/
LGPL
2
.
1
#
#
The
contents
of
this
file
are
subject
to
the
Mozilla
Public
License
Version
#
1
.
1
(
the
"
License
"
)
;
you
may
not
use
this
file
except
in
compliance
with
#
the
License
.
You
may
obtain
a
copy
of
the
License
at
#
http
:
#
#
Software
distributed
under
the
License
is
distributed
on
an
"
AS
IS
"
basis
#
WITHOUT
WARRANTY
OF
ANY
KIND
either
express
or
implied
.
See
the
License
#
for
the
specific
language
governing
rights
and
limitations
under
the
#
License
.
#
#
The
Original
Code
is
mozilla
.
org
code
.
#
#
The
Initial
Developer
of
the
Original
Code
is
#
Pierre
Chanial
<
chanial
noos
.
fr
>
.
#
Portions
created
by
the
Initial
Developer
are
Copyright
(
C
)
1998
#
the
Initial
Developer
.
All
Rights
Reserved
.
#
#
Contributor
(
s
)
:
#
David
Hyatt
<
hyatt
apple
.
com
>
#
#
Alternatively
the
contents
of
this
file
may
be
used
under
the
terms
of
#
either
the
GNU
General
Public
License
Version
2
or
later
(
the
"
GPL
"
)
or
#
the
GNU
Lesser
General
Public
License
Version
2
.
1
or
later
(
the
"
LGPL
"
)
#
in
which
case
the
provisions
of
the
GPL
or
the
LGPL
are
applicable
instead
#
of
those
above
.
If
you
wish
to
allow
use
of
your
version
of
this
file
only
#
under
the
terms
of
either
the
GPL
or
the
LGPL
and
not
to
allow
others
to
#
use
your
version
of
this
file
under
the
terms
of
the
MPL
indicate
your
#
decision
by
deleting
the
provisions
above
and
replace
them
with
the
notice
#
and
other
provisions
required
by
the
GPL
or
the
LGPL
.
If
you
do
not
delete
#
the
provisions
above
a
recipient
may
use
your
version
of
this
file
under
#
the
terms
of
any
one
of
the
MPL
the
GPL
or
the
LGPL
.
#
#
*
*
*
*
*
END
LICENSE
BLOCK
*
*
*
*
*
var
BookmarksMenu
=
{
_selection
:
null
_target
:
null
_orientation
:
null
onShowMenu
:
function
(
aTarget
)
{
this
.
showOpenInTabsMenuItem
(
aTarget
)
;
this
.
showEmptyItem
(
aTarget
)
;
}
onHideMenu
:
function
(
aTarget
)
{
this
.
hideOpenInTabsMenuItem
(
aTarget
)
;
this
.
hideEmptyItem
(
aTarget
)
;
}
showOpenInTabsMenuItem
:
function
(
aTarget
)
{
if
(
!
this
.
validOpenInTabsMenuItem
(
aTarget
)
|
|
aTarget
.
lastChild
.
getAttribute
(
"
class
"
)
=
=
"
openintabs
-
menuitem
"
)
return
;
var
element
=
document
.
createElementNS
(
gXUL_NS
"
menuseparator
"
)
;
element
.
setAttribute
(
"
class
"
"
openintabs
-
menuseparator
"
)
;
aTarget
.
appendChild
(
element
)
;
element
=
document
.
createElementNS
(
gXUL_NS
"
menuitem
"
)
;
element
.
setAttribute
(
"
class
"
"
openintabs
-
menuitem
"
)
;
element
.
setAttribute
(
"
label
"
BookmarksUtils
.
getLocaleString
(
"
cmd_bm_openfolder
"
)
)
;
element
.
setAttribute
(
"
accesskey
"
BookmarksUtils
.
getLocaleString
(
"
cmd_bm_openfolder_accesskey
"
)
)
;
aTarget
.
appendChild
(
element
)
;
}
realHideOpenInTabsMenuItem
:
function
(
aParent
)
{
if
(
!
aParent
.
hasChildNodes
(
)
)
return
;
var
child
=
aParent
.
lastChild
;
var
removed
=
0
;
while
(
child
)
{
var
cclass
=
child
.
getAttribute
(
"
class
"
)
;
if
(
cclass
=
=
"
openintabs
-
menuitem
"
|
|
cclass
=
=
"
openintabs
-
menuseparator
"
)
{
var
prevchild
=
child
.
previousSibling
;
aParent
.
removeChild
(
child
)
;
child
=
prevchild
;
removed
+
+
;
if
(
removed
=
=
2
)
break
;
}
else
{
child
=
child
.
previousSibling
;
}
}
}
#
ifdef
XP_MACOSX
hideOpenInTabsMenuItem
:
function
(
aTarget
)
{
setTimeout
(
function
(
)
{
BookmarksMenu
.
realHideOpenInTabsMenuItem
(
aTarget
)
;
}
0
)
;
}
#
else
hideOpenInTabsMenuItem
:
function
(
aTarget
)
{
BookmarksMenu
.
realHideOpenInTabsMenuItem
(
aTarget
)
;
}
#
endif
validOpenInTabsMenuItem
:
function
(
aTarget
)
{
var
rParent
=
RDF
.
GetResource
(
aTarget
.
parentNode
.
id
)
var
type
=
BookmarksUtils
.
resolveType
(
rParent
)
;
if
(
type
!
=
"
Folder
"
&
&
type
!
=
"
PersonalToolbarFolder
"
&
&
type
!
=
"
Livemark
"
)
return
false
;
var
count
=
0
;
if
(
!
aTarget
.
hasChildNodes
(
)
)
return
false
;
var
curr
=
aTarget
.
firstChild
;
do
{
type
=
BookmarksUtils
.
resolveType
(
curr
.
id
)
;
if
(
type
=
=
"
Bookmark
"
&
&
+
+
count
=
=
2
)
return
true
;
curr
=
curr
.
nextSibling
;
}
while
(
curr
)
;
return
false
;
}
showEmptyItem
:
function
(
aTarget
)
{
if
(
aTarget
.
hasChildNodes
(
)
)
return
;
var
EmptyMsg
=
BookmarksUtils
.
getLocaleString
(
"
emptyFolder
"
)
;
var
emptyElement
=
document
.
createElementNS
(
gXUL_NS
"
menuitem
"
)
;
emptyElement
.
setAttribute
(
"
id
"
"
empty
-
menuitem
"
)
;
emptyElement
.
setAttribute
(
"
label
"
EmptyMsg
)
;
emptyElement
.
setAttribute
(
"
disabled
"
"
true
"
)
;
aTarget
.
appendChild
(
emptyElement
)
;
}
hideEmptyItem
:
function
(
aTarget
)
{
if
(
!
aTarget
.
hasChildNodes
(
)
)
return
;
if
(
aTarget
.
firstChild
.
id
=
=
"
empty
-
menuitem
"
)
aTarget
.
removeChild
(
aTarget
.
firstChild
)
;
else
if
(
aTarget
.
lastChild
.
id
=
=
"
empty
-
menuitem
"
)
aTarget
.
removeChild
(
aTarget
.
lastChild
)
;
}
createContextMenu
:
function
(
aEvent
)
{
var
target
=
document
.
popupNode
;
if
(
!
this
.
isBTBookmark
(
target
.
id
)
)
{
target
.
removeAttribute
(
"
open
"
)
;
return
false
;
}
var
targettype
=
BookmarksUtils
.
resolveType
(
target
.
id
)
;
if
(
targettype
=
=
"
ImmutableFolder
"
)
{
target
.
removeAttribute
(
"
open
"
)
;
return
false
;
}
document
.
getElementById
(
"
PersonalToolbar
"
)
.
focus
(
)
;
this
.
_selection
=
this
.
getBTSelection
(
target
)
;
this
.
_orientation
=
this
.
getBTOrientation
(
aEvent
target
)
;
if
(
targettype
!
=
"
ImmutableBookmark
"
)
this
.
_target
=
this
.
getBTTarget
(
target
this
.
_orientation
)
;
var
p
=
target
;
while
(
p
&
&
!
p
.
database
)
p
=
p
.
parentNode
;
if
(
p
)
this
.
_db
=
p
.
database
;
BookmarksCommand
.
createContextMenu
(
aEvent
this
.
_selection
this
.
_db
)
;
this
.
onCommandUpdate
(
)
;
aEvent
.
target
.
addEventListener
(
"
mousemove
"
BookmarksMenuController
.
onMouseMove
false
)
;
return
true
;
}
destroyContextMenu
:
function
(
aEvent
)
{
if
(
content
)
content
.
focus
(
)
;
BookmarksMenuDNDObserver
.
mCurrentDragOverTarget
=
null
;
BookmarksMenuDNDObserver
.
onDragCloseTarget
(
)
;
BookmarksMenuDNDObserver
.
onDragRemoveFeedBack
(
document
.
popupNode
)
;
aEvent
.
target
.
removeEventListener
(
"
mousemove
"
BookmarksMenuController
.
onMouseMove
false
)
;
this
.
_target
=
null
;
this
.
_selection
=
null
;
}
getBTSelection
:
function
(
aNode
)
{
var
item
;
switch
(
aNode
.
id
)
{
case
"
bookmarks
-
ptf
"
:
item
=
BMSVC
.
getBookmarksToolbarFolder
(
)
.
Value
;
break
;
case
"
bookmarks
-
menu
"
:
item
=
"
NC
:
BookmarksRoot
"
;
break
;
default
:
item
=
aNode
.
id
;
if
(
!
this
.
isBTBookmark
(
item
)
)
return
{
length
:
0
}
;
}
var
parent
=
this
.
getBTContainer
(
aNode
)
;
var
isExpanded
=
aNode
.
hasAttribute
(
"
open
"
)
&
&
aNode
.
open
;
var
selection
=
{
}
;
selection
.
item
=
[
RDF
.
GetResource
(
item
)
]
;
selection
.
parent
=
[
RDF
.
GetResource
(
parent
)
]
;
selection
.
isExpanded
=
[
isExpanded
]
;
selection
.
length
=
selection
.
item
.
length
;
BookmarksUtils
.
checkSelection
(
selection
)
;
return
selection
;
}
getBTTarget
:
function
(
aNode
aOrientation
)
{
var
item
parent
index
;
switch
(
aNode
.
id
)
{
case
"
bookmarks
-
ptf
"
:
parent
=
BMSVC
.
getBookmarksToolbarFolder
(
)
.
Value
;
item
=
BookmarksToolbar
.
getLastVisibleBookmark
(
)
;
break
;
case
"
bookmarks
-
menu
"
:
parent
=
"
NC
:
BookmarksRoot
"
;
break
;
case
"
bookmarks
-
chevron
"
:
parent
=
BMSVC
.
getBookmarksToolbarFolder
(
)
.
Value
;
break
;
default
:
if
(
aOrientation
=
=
BookmarksUtils
.
DROP_ON
)
parent
=
aNode
.
id
else
{
parent
=
this
.
getBTContainer
(
aNode
)
;
item
=
aNode
;
}
}
parent
=
RDF
.
GetResource
(
parent
)
;
if
(
aOrientation
=
=
BookmarksUtils
.
DROP_ON
)
return
BookmarksUtils
.
getTargetFromFolder
(
parent
)
;
item
=
RDF
.
GetResource
(
item
.
id
)
;
RDFC
.
Init
(
BMDS
parent
)
;
index
=
RDFC
.
IndexOf
(
item
)
;
if
(
aOrientation
=
=
BookmarksUtils
.
DROP_AFTER
)
+
+
index
;
return
{
parent
:
parent
index
:
index
}
;
}
getBTContainer
:
function
(
aNode
)
{
var
parent
;
var
item
=
aNode
.
id
;
if
(
!
this
.
isBTBookmark
(
item
)
)
return
"
NC
:
BookmarksRoot
"
parent
=
aNode
.
parentNode
.
parentNode
;
parent
=
parent
.
id
;
switch
(
parent
)
{
case
"
bookmarks
-
chevron
"
:
case
"
bookmarks
-
stack
"
:
case
"
bookmarks
-
toolbar
"
:
return
BMSVC
.
getBookmarksToolbarFolder
(
)
.
Value
;
case
"
bookmarks
-
menu
"
:
return
"
NC
:
BookmarksRoot
"
;
default
:
return
parent
;
}
}
isBTBookmark
:
function
(
aURI
)
{
if
(
!
aURI
|
|
aURI
=
=
"
bookmarkAllCmd
"
)
return
false
;
var
type
=
BookmarksUtils
.
resolveType
(
aURI
)
;
return
(
type
=
=
"
BookmarkSeparator
"
|
|
type
=
=
"
Bookmark
"
|
|
type
=
=
"
Folder
"
|
|
type
=
=
"
PersonalToolbarFolder
"
|
|
type
=
=
"
Livemark
"
|
|
type
=
=
"
ImmutableBookmark
"
|
|
type
=
=
"
ImmutableFolder
"
|
|
aURI
=
=
"
bookmarks
-
ptf
"
)
}
isBTContainer
:
function
(
aTarget
)
{
return
aTarget
.
localName
=
=
"
menu
"
|
|
(
aTarget
.
localName
=
=
"
toolbarbutton
"
&
&
(
aTarget
.
getAttribute
(
"
container
"
)
=
=
"
true
"
)
)
;
}
getBTOrientation
:
function
(
aEvent
aTarget
)
{
var
target
if
(
!
aTarget
)
target
=
aEvent
.
target
;
else
target
=
aTarget
;
if
(
target
.
localName
=
=
"
menu
"
&
&
target
.
parentNode
.
localName
!
=
"
menupopup
"
|
|
target
.
id
=
=
"
bookmarks
-
chevron
"
)
return
BookmarksUtils
.
DROP_ON
;
if
(
target
.
id
=
=
"
bookmarks
-
ptf
"
)
{
return
target
.
hasChildNodes
(
)
?
BookmarksUtils
.
DROP_AFTER
:
BookmarksUtils
.
DROP_ON
;
}
var
overButtonBoxObject
=
target
.
boxObject
.
QueryInterface
(
Components
.
interfaces
.
nsIBoxObject
)
;
var
overParentBoxObject
=
target
.
parentNode
.
boxObject
.
QueryInterface
(
Components
.
interfaces
.
nsIBoxObject
)
;
var
size
border
;
var
coordValue
clientCoordValue
;
switch
(
target
.
localName
)
{
case
"
toolbarseparator
"
:
case
"
toolbarbutton
"
:
size
=
overButtonBoxObject
.
width
;
coordValue
=
overButtonBoxObject
.
x
;
clientCoordValue
=
aEvent
.
clientX
;
break
;
case
"
menuseparator
"
:
case
"
menu
"
:
case
"
menuitem
"
:
size
=
overButtonBoxObject
.
height
;
coordValue
=
overButtonBoxObject
.
screenY
;
clientCoordValue
=
aEvent
.
screenY
;
break
;
default
:
return
BookmarksUtils
.
DROP_ON
;
}
if
(
this
.
isBTContainer
(
target
)
)
if
(
target
.
localName
=
=
"
toolbarbutton
"
)
{
var
iconNode
=
document
.
getAnonymousElementByAttribute
(
target
"
class
"
"
toolbarbutton
-
icon
"
)
;
border
=
parseInt
(
document
.
defaultView
.
getComputedStyle
(
target
"
"
)
.
getPropertyValue
(
"
padding
-
left
"
)
)
+
parseInt
(
document
.
defaultView
.
getComputedStyle
(
iconNode
"
"
)
.
getPropertyValue
(
"
width
"
)
)
;
border
=
Math
.
min
(
size
/
5
Math
.
max
(
border
4
)
)
;
}
else
border
=
size
/
5
;
else
border
=
size
/
2
;
if
(
clientCoordValue
-
coordValue
<
border
)
return
BookmarksUtils
.
DROP_BEFORE
;
else
if
(
clientCoordValue
-
coordValue
>
=
size
-
border
)
return
BookmarksUtils
.
DROP_AFTER
;
else
return
BookmarksUtils
.
DROP_ON
;
}
expandBTFolder
:
function
(
)
{
var
target
=
document
.
popupNode
.
lastChild
;
if
(
document
.
popupNode
.
open
)
target
.
hidePopup
(
)
;
else
target
.
showPopup
(
document
.
popupNode
)
;
}
onCommandUpdate
:
function
(
)
{
var
selection
=
this
.
_selection
;
var
target
=
this
.
_target
;
BookmarksController
.
onCommandUpdate
(
selection
target
)
;
if
(
document
.
popupNode
.
id
=
=
"
bookmarks
-
ptf
"
)
{
var
commandNode
=
document
.
getElementById
(
"
cmd_cut
"
)
;
commandNode
.
setAttribute
(
"
disabled
"
"
true
"
)
;
commandNode
=
document
.
getElementById
(
"
cmd_copy
"
)
;
commandNode
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
loadBookmark
:
function
(
aEvent
aTarget
aDS
)
{
if
(
aTarget
.
getAttribute
(
"
class
"
)
=
=
"
openintabs
-
menuitem
"
)
aTarget
=
aTarget
.
parentNode
.
parentNode
;
if
(
!
this
.
isBTBookmark
(
aTarget
.
id
)
)
return
;
var
rSource
=
RDF
.
GetResource
(
aTarget
.
id
)
;
var
selection
=
BookmarksUtils
.
getSelectionFromResource
(
rSource
)
;
var
browserTarget
=
whereToOpenLink
(
aEvent
)
;
BookmarksCommand
.
openBookmark
(
selection
browserTarget
aDS
)
;
aEvent
.
stopPropagation
(
)
;
}
loadBookmarkMiddleClick
:
function
(
aEvent
aDS
)
{
if
(
aEvent
.
button
!
=
1
)
return
;
BookmarksMenuDNDObserver
.
mCurrentDragOverTarget
=
null
;
BookmarksMenuDNDObserver
.
onDragCloseTarget
(
)
;
this
.
loadBookmark
(
aEvent
aEvent
.
target
aDS
)
;
}
}
var
BookmarksMenuController
=
{
supportsCommand
:
BookmarksController
.
supportsCommand
isCommandEnabled
:
function
(
aCommand
)
{
var
selection
=
BookmarksMenu
.
_selection
;
var
target
=
BookmarksMenu
.
_target
;
if
(
selection
)
return
BookmarksController
.
isCommandEnabled
(
aCommand
selection
target
)
;
return
false
;
}
doCommand
:
function
(
aCommand
)
{
if
(
content
)
content
.
focus
(
)
;
BookmarksMenuDNDObserver
.
onDragRemoveFeedBack
(
document
.
popupNode
)
;
var
element
=
document
.
popupNode
.
firstChild
;
if
(
element
&
&
element
.
localName
=
=
"
menupopup
"
)
element
.
hidePopup
(
)
;
var
selection
=
BookmarksMenu
.
_selection
;
var
target
=
BookmarksMenu
.
_target
;
var
db
=
BookmarksMenu
.
_db
;
switch
(
aCommand
)
{
case
"
cmd_bm_expandfolder
"
:
BookmarksMenu
.
expandBTFolder
(
)
;
break
;
default
:
BookmarksController
.
doCommand
(
aCommand
selection
target
db
)
;
}
}
onMouseMove
:
function
(
aEvent
)
{
var
command
=
aEvent
.
target
.
getAttribute
(
"
command
"
)
;
var
isDisabled
=
aEvent
.
target
.
getAttribute
(
"
disabled
"
)
if
(
isDisabled
!
=
"
true
"
&
&
(
command
=
=
"
cmd_bm_newfolder
"
|
|
command
=
=
"
cmd_paste
"
)
)
{
BookmarksMenuDNDObserver
.
onDragSetFeedBack
(
document
.
popupNode
BookmarksMenu
.
_orientation
)
;
}
else
{
BookmarksMenuDNDObserver
.
onDragRemoveFeedBack
(
document
.
popupNode
)
;
}
}
}
var
BookmarksMenuDNDObserver
=
{
onDragStart
:
function
(
aEvent
aXferData
aDragAction
)
{
var
target
=
aEvent
.
target
;
if
(
target
.
id
=
=
"
bookmarks
-
menu
"
|
|
target
.
id
=
=
"
bookmarks
-
chevron
"
|
|
target
.
id
=
=
"
bookmarks
-
ptf
"
)
return
false
;
if
(
!
BookmarksMenu
.
isBTBookmark
(
target
.
id
)
)
return
false
;
if
(
navigator
.
platform
!
=
"
Win32
"
&
&
target
.
localName
!
=
"
toolbarbutton
"
)
return
false
;
if
(
this
.
isContainer
(
target
)
)
{
if
(
this
.
isPlatformNotSupported
)
return
false
;
if
(
!
aEvent
.
shiftKey
&
&
!
aEvent
.
altKey
&
&
!
aEvent
.
ctrlKey
)
return
false
;
target
.
firstChild
.
hidePopup
(
)
;
}
var
selection
=
BookmarksMenu
.
getBTSelection
(
target
)
;
aXferData
.
data
=
BookmarksUtils
.
getXferDataFromSelection
(
selection
)
;
return
true
;
}
onDragOver
:
function
(
aEvent
aFlavour
aDragSession
)
{
var
orientation
=
BookmarksMenu
.
getBTOrientation
(
aEvent
)
if
(
aDragSession
.
canDrop
)
this
.
onDragSetFeedBack
(
aEvent
.
target
orientation
)
;
if
(
orientation
!
=
this
.
mCurrentDropPosition
)
{
this
.
onDragExit
(
aEvent
aDragSession
)
;
this
.
onDragEnter
(
aEvent
aDragSession
)
;
}
if
(
this
.
isPlatformNotSupported
)
return
;
if
(
this
.
isTimerSupported
|
|
!
aDragSession
.
sourceNode
)
return
;
this
.
onDragOverCheckTimers
(
)
;
}
onDragEnter
:
function
(
aEvent
aDragSession
)
{
var
target
=
aEvent
.
target
;
var
orientation
=
BookmarksMenu
.
getBTOrientation
(
aEvent
)
;
if
(
target
.
localName
=
=
"
menupopup
"
|
|
target
.
id
=
=
"
bookmarks
-
ptf
"
)
target
=
target
.
parentNode
;
if
(
aDragSession
.
canDrop
)
{
this
.
onDragSetFeedBack
(
target
orientation
)
;
this
.
onDragEnterSetTimer
(
target
aDragSession
)
;
}
this
.
mCurrentDragOverTarget
=
target
;
this
.
mCurrentDropPosition
=
orientation
;
}
onDragExit
:
function
(
aEvent
aDragSession
)
{
var
target
=
aEvent
.
target
;
if
(
target
.
localName
=
=
"
menupopup
"
|
|
target
.
id
=
=
"
bookmarks
-
ptf
"
)
target
=
target
.
parentNode
;
this
.
onDragRemoveFeedBack
(
target
)
;
this
.
onDragExitSetTimer
(
target
aDragSession
)
;
this
.
mCurrentDragOverTarget
=
null
;
this
.
mCurrentDropPosition
=
null
;
}
onDrop
:
function
(
aEvent
aXferData
aDragSession
)
{
var
target
=
aEvent
.
target
;
this
.
onDragRemoveFeedBack
(
target
)
;
var
selection
=
BookmarksUtils
.
getSelectionFromXferData
(
aDragSession
)
;
var
orientation
=
BookmarksMenu
.
getBTOrientation
(
aEvent
)
;
var
PBStyle
=
window
.
getComputedStyle
(
document
.
getElementById
(
"
PersonalToolbar
"
)
'
'
)
;
var
isHorizontal
=
(
target
.
localName
=
=
"
toolbarbutton
"
)
;
if
(
(
PBStyle
.
direction
=
=
'
rtl
'
)
&
&
isHorizontal
)
{
if
(
orientation
=
=
BookmarksUtils
.
DROP_AFTER
)
orientation
=
BookmarksUtils
.
DROP_BEFORE
;
else
if
(
orientation
=
=
BookmarksUtils
.
DROP_BEFORE
)
orientation
=
BookmarksUtils
.
DROP_AFTER
;
}
var
selTarget
=
BookmarksMenu
.
getBTTarget
(
target
orientation
)
;
var
checkCopy
=
aDragSession
.
isDataFlavorSupported
(
"
moz
/
rdfitem
"
)
;
const
kDSIID
=
Components
.
interfaces
.
nsIDragService
;
const
kCopyAction
=
kDSIID
.
DRAGDROP_ACTION_COPY
+
kDSIID
.
DRAGDROP_ACTION_LINK
;
var
menuSeparator
=
null
;
var
menuTarget
=
(
target
.
localName
=
=
"
toolbarbutton
"
|
|
target
.
localName
=
=
"
menu
"
)
&
&
orientation
=
=
BookmarksUtils
.
DROP_ON
?
target
.
lastChild
:
target
.
parentNode
;
if
(
menuTarget
.
hasChildNodes
(
)
&
&
menuTarget
.
lastChild
.
getAttribute
(
"
class
"
)
=
=
"
openintabs
-
menuitem
"
)
{
menuSeparator
=
menuTarget
.
lastChild
.
previousSibling
;
menuTarget
.
removeChild
(
menuSeparator
)
;
}
var
doCopy
=
true
;
if
(
checkCopy
&
&
!
(
aDragSession
.
dragAction
&
kCopyAction
)
)
doCopy
=
BookmarksUtils
.
shouldCopySelection
(
"
drag
"
selection
)
;
if
(
doCopy
)
BookmarksUtils
.
insertAndCheckSelection
(
"
drag
"
selection
selTarget
)
;
else
BookmarksUtils
.
moveAndCheckSelection
(
"
drag
"
selection
selTarget
)
;
if
(
menuSeparator
)
menuTarget
.
insertBefore
(
menuSeparator
menuTarget
.
lastChild
)
;
}
canDrop
:
function
(
aEvent
aDragSession
)
{
var
target
=
aEvent
.
target
;
if
(
!
BookmarksMenu
.
isBTBookmark
(
target
.
id
)
)
return
false
;
var
btype
=
BookmarksUtils
.
resolveType
(
target
.
id
)
;
return
target
.
id
=
=
"
bookmarks
-
menu
"
|
|
target
.
id
=
=
"
bookmarks
-
chevron
"
|
|
target
.
id
=
=
"
bookmarks
-
ptf
"
|
|
(
target
.
id
!
=
"
NC
:
SystemBookmarksStaticRoot
"
&
&
btype
=
=
"
Folder
"
|
|
btype
=
=
"
Bookmark
"
)
;
}
canHandleMultipleItems
:
true
getSupportedFlavours
:
function
(
)
{
var
flavourSet
=
new
FlavourSet
(
)
;
flavourSet
.
appendFlavour
(
"
moz
/
rdfitem
"
)
;
flavourSet
.
appendFlavour
(
"
text
/
x
-
moz
-
url
"
)
;
flavourSet
.
appendFlavour
(
"
application
/
x
-
moz
-
file
"
"
nsIFile
"
)
;
flavourSet
.
appendFlavour
(
"
text
/
unicode
"
)
;
return
flavourSet
;
}
springLoadedMenuDelay
:
350
isPlatformNotSupported
:
navigator
.
platform
.
indexOf
(
"
Mac
"
)
!
=
-
1
isTimerSupported
:
navigator
.
platform
.
indexOf
(
"
Win
"
)
=
=
-
1
mCurrentDragOverTarget
:
null
mCurrentDropPosition
:
null
loadTimer
:
null
closeTimer
:
null
loadTarget
:
null
closeTarget
:
null
_observers
:
null
get
mObservers
(
)
{
if
(
!
this
.
_observers
)
{
this
.
_observers
=
[
document
.
getElementById
(
"
bookmarks
-
ptf
"
)
document
.
getElementById
(
"
bookmarks
-
menu
"
)
.
firstChild
document
.
getElementById
(
"
bookmarks
-
chevron
"
)
.
parentNode
]
}
return
this
.
_observers
;
}
getObserverForNode
:
function
(
aNode
)
{
if
(
!
aNode
)
return
null
;
var
node
=
aNode
;
var
observer
;
while
(
node
)
{
for
(
var
i
=
0
;
i
<
this
.
mObservers
.
length
;
i
+
+
)
{
observer
=
this
.
mObservers
[
i
]
;
if
(
observer
=
=
node
)
return
observer
;
}
node
=
node
.
parentNode
;
}
return
null
;
}
onDragCloseMenu
:
function
(
aNode
)
{
var
children
=
aNode
.
childNodes
;
for
(
var
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
if
(
this
.
isContainer
(
children
[
i
]
)
&
&
children
[
i
]
.
getAttribute
(
"
open
"
)
=
=
"
true
"
)
{
this
.
onDragCloseMenu
(
children
[
i
]
.
lastChild
)
;
if
(
children
[
i
]
!
=
this
.
mCurrentDragOverTarget
|
|
this
.
mCurrentDropPosition
!
=
BookmarksUtils
.
DROP_ON
)
children
[
i
]
.
lastChild
.
hidePopup
(
)
;
}
}
}
onDragCloseTarget
:
function
(
)
{
var
currentObserver
=
this
.
getObserverForNode
(
this
.
mCurrentDragOverTarget
)
;
for
(
var
i
=
0
;
i
<
this
.
mObservers
.
length
;
i
+
+
)
{
if
(
currentObserver
!
=
this
.
mObservers
[
i
]
)
{
this
.
onDragCloseMenu
(
this
.
mObservers
[
i
]
)
;
if
(
this
.
mObservers
[
i
]
.
parentNode
.
id
=
=
"
bookmarks
-
menu
"
)
this
.
mObservers
[
i
]
.
hidePopup
(
)
;
}
else
this
.
onDragCloseMenu
(
this
.
mCurrentDragOverTarget
.
parentNode
)
;
}
}
onDragLoadTarget
:
function
(
aTarget
)
{
if
(
!
this
.
mCurrentDragOverTarget
)
return
;
if
(
this
.
mCurrentDropPosition
=
=
BookmarksUtils
.
DROP_ON
&
&
this
.
isContainer
(
aTarget
)
)
aTarget
.
lastChild
.
showPopup
(
aTarget
)
;
}
onDragOverCheckTimers
:
function
(
)
{
var
now
=
new
Date
(
)
.
getTime
(
)
;
if
(
this
.
closeTimer
&
&
now
-
this
.
springLoadedMenuDelay
>
this
.
closeTimer
)
{
this
.
onDragCloseTarget
(
)
;
this
.
closeTimer
=
null
;
}
if
(
this
.
loadTimer
&
&
(
now
-
this
.
springLoadedMenuDelay
>
this
.
loadTimer
)
)
{
this
.
onDragLoadTarget
(
this
.
loadTarget
)
;
this
.
loadTimer
=
null
;
}
}
onDragEnterSetTimer
:
function
(
aTarget
aDragSession
)
{
if
(
this
.
isPlatformNotSupported
)
return
;
if
(
this
.
isTimerSupported
|
|
!
aDragSession
.
sourceNode
)
{
var
targetToBeLoaded
=
aTarget
;
clearTimeout
(
this
.
loadTimer
)
;
if
(
aTarget
=
=
aDragSession
.
sourceNode
)
return
;
var
This
=
this
;
this
.
loadTimer
=
setTimeout
(
function
(
)
{
This
.
onDragLoadTarget
(
targetToBeLoaded
)
}
This
.
springLoadedMenuDelay
)
;
}
else
{
var
now
=
new
Date
(
)
.
getTime
(
)
;
this
.
loadTimer
=
now
;
this
.
loadTarget
=
aTarget
;
}
}
onDragExitSetTimer
:
function
(
aTarget
aDragSession
)
{
if
(
this
.
isPlatformNotSupported
)
return
;
var
This
=
this
;
if
(
this
.
isTimerSupported
|
|
!
aDragSession
.
sourceNode
)
{
clearTimeout
(
this
.
closeTimer
)
this
.
closeTimer
=
setTimeout
(
function
(
)
{
This
.
onDragCloseTarget
(
)
}
This
.
springLoadedMenuDelay
)
;
}
else
{
var
now
=
new
Date
(
)
.
getTime
(
)
;
this
.
closeTimer
=
now
;
this
.
closeTarget
=
aTarget
;
this
.
loadTimer
=
null
;
if
(
aDragSession
.
sourceNode
.
localName
!
=
"
menuitem
"
&
&
aDragSession
.
sourceNode
.
localName
!
=
"
menu
"
)
setTimeout
(
function
(
)
{
if
(
This
.
mCurrentDragOverTarget
)
{
This
.
onDragRemoveFeedBack
(
This
.
mCurrentDragOverTarget
)
;
This
.
mCurrentDragOverTarget
=
null
}
This
.
loadTimer
=
null
;
This
.
onDragCloseTarget
(
)
}
0
)
;
}
}
onDragSetFeedBack
:
function
(
aTarget
aOrientation
)
{
switch
(
aTarget
.
localName
)
{
case
"
toolbarseparator
"
:
case
"
toolbarbutton
"
:
switch
(
aOrientation
)
{
case
BookmarksUtils
.
DROP_BEFORE
:
aTarget
.
setAttribute
(
"
dragover
-
left
"
"
true
"
)
;
break
;
case
BookmarksUtils
.
DROP_AFTER
:
aTarget
.
setAttribute
(
"
dragover
-
right
"
"
true
"
)
;
break
;
case
BookmarksUtils
.
DROP_ON
:
aTarget
.
setAttribute
(
"
dragover
-
top
"
"
true
"
)
;
aTarget
.
setAttribute
(
"
dragover
-
bottom
"
"
true
"
)
;
aTarget
.
setAttribute
(
"
dragover
-
left
"
"
true
"
)
;
aTarget
.
setAttribute
(
"
dragover
-
right
"
"
true
"
)
;
break
;
}
break
;
case
"
menuseparator
"
:
case
"
menu
"
:
case
"
menuitem
"
:
switch
(
aOrientation
)
{
case
BookmarksUtils
.
DROP_BEFORE
:
aTarget
.
setAttribute
(
"
dragover
-
top
"
"
true
"
)
;
break
;
case
BookmarksUtils
.
DROP_AFTER
:
aTarget
.
setAttribute
(
"
dragover
-
bottom
"
"
true
"
)
;
break
;
case
BookmarksUtils
.
DROP_ON
:
break
;
}
break
;
case
"
hbox
"
:
var
newTarget
=
BookmarksToolbar
.
getLastVisibleBookmark
(
)
;
if
(
newTarget
)
newTarget
.
setAttribute
(
"
dragover
-
right
"
"
true
"
)
;
break
;
case
"
stack
"
:
case
"
menupopup
"
:
break
;
default
:
dump
(
"
No
feedback
for
:
"
+
aTarget
.
localName
+
"
\
n
"
)
;
}
}
onDragRemoveFeedBack
:
function
(
aTarget
)
{
var
newTarget
;
var
bt
;
if
(
aTarget
.
id
=
=
"
bookmarks
-
ptf
"
)
{
newTarget
=
BookmarksToolbar
.
getLastVisibleBookmark
(
)
;
if
(
newTarget
)
newTarget
.
removeAttribute
(
"
dragover
-
right
"
)
;
}
else
if
(
aTarget
.
id
=
=
"
bookmarks
-
stack
"
)
{
newTarget
=
BookmarksToolbar
.
getLastVisibleBookmark
(
)
;
newTarget
.
removeAttribute
(
"
dragover
-
right
"
)
;
}
else
{
aTarget
.
removeAttribute
(
"
dragover
-
left
"
)
;
aTarget
.
removeAttribute
(
"
dragover
-
right
"
)
;
aTarget
.
removeAttribute
(
"
dragover
-
top
"
)
;
aTarget
.
removeAttribute
(
"
dragover
-
bottom
"
)
;
}
}
onDropSetFeedBack
:
function
(
aTarget
)
{
}
isContainer
:
function
(
aTarget
)
{
return
aTarget
.
localName
=
=
"
menu
"
|
|
aTarget
.
localName
=
=
"
toolbarbutton
"
&
&
aTarget
.
getAttribute
(
"
type
"
)
=
=
"
menu
"
;
}
}
var
BookmarksToolbar
=
{
openedMenuButton
:
null
autoOpenMenu
:
function
(
aEvent
)
{
var
target
=
aEvent
.
target
;
if
(
BookmarksToolbar
.
openedMenuButton
!
=
target
&
&
target
.
nodeName
=
=
"
toolbarbutton
"
&
&
target
.
type
=
=
"
menu
"
)
{
BookmarksToolbar
.
openedMenuButton
.
open
=
false
;
target
.
open
=
true
;
}
}
setOpenedMenu
:
function
(
aEvent
)
{
if
(
aEvent
.
target
.
parentNode
.
localName
=
=
'
toolbarbutton
'
)
{
if
(
!
this
.
openedMenuButton
)
aEvent
.
currentTarget
.
addEventListener
(
"
mouseover
"
this
.
autoOpenMenu
true
)
;
this
.
openedMenuButton
=
aEvent
.
target
.
parentNode
;
}
}
unsetOpenedMenu
:
function
(
aEvent
)
{
if
(
aEvent
.
target
.
parentNode
.
localName
=
=
'
toolbarbutton
'
)
{
aEvent
.
currentTarget
.
removeEventListener
(
"
mouseover
"
this
.
autoOpenMenu
true
)
;
this
.
openedMenuButton
=
null
;
}
}
getLastVisibleBookmark
:
function
(
)
{
var
buttons
=
document
.
getElementById
(
"
bookmarks
-
ptf
"
)
;
var
button
=
buttons
.
firstChild
;
if
(
!
button
)
return
null
;
do
{
if
(
button
.
collapsed
)
return
button
.
previousSibling
;
button
=
button
.
nextSibling
;
}
while
(
button
)
return
buttons
.
lastChild
;
}
updateOverflowMenu
:
function
(
aMenuPopup
)
{
var
hbox
=
document
.
getElementById
(
"
bookmarks
-
ptf
"
)
;
for
(
var
i
=
0
;
i
<
hbox
.
childNodes
.
length
;
i
+
+
)
{
var
button
=
hbox
.
childNodes
[
i
]
;
var
menu
=
aMenuPopup
.
childNodes
[
i
]
;
if
(
menu
.
collapsed
=
=
button
.
collapsed
)
menu
.
collapsed
=
!
menu
.
collapsed
;
}
}
resizeFunc
:
function
(
event
)
{
BookmarksToolbarRDFObserver
.
_overflowTimerInEffect
=
false
;
if
(
event
&
&
event
.
type
=
=
'
focus
'
)
window
.
removeEventListener
(
'
focus
'
BookmarksToolbar
.
resizeFunc
false
)
;
var
buttons
=
document
.
getElementById
(
"
bookmarks
-
ptf
"
)
;
if
(
!
buttons
)
return
;
var
chevron
=
document
.
getElementById
(
"
bookmarks
-
chevron
"
)
;
var
myToolbarItem
=
buttons
.
parentNode
.
parentNode
;
var
width
=
myToolbarItem
.
boxObject
.
width
;
if
(
width
<
=
0
)
{
window
.
addEventListener
(
'
focus
'
BookmarksToolbar
.
resizeFunc
false
)
;
return
;
}
if
(
buttons
.
childNodes
.
length
=
=
0
)
{
chevron
.
collapsed
=
true
;
return
;
}
var
chevronWidth
=
0
;
chevron
.
collapsed
=
false
;
chevronWidth
=
chevron
.
boxObject
.
width
;
chevron
.
collapsed
=
true
;
var
overflowed
=
false
;
var
usedWidth
=
3
;
for
(
var
i
=
0
;
i
<
buttons
.
childNodes
.
length
;
i
+
+
)
{
var
button
=
buttons
.
childNodes
[
i
]
;
button
.
collapsed
=
overflowed
;
if
(
i
=
=
buttons
.
childNodes
.
length
-
1
)
chevronWidth
=
0
;
if
(
usedWidth
+
button
.
boxObject
.
width
+
chevronWidth
>
width
)
{
overflowed
=
true
;
if
(
!
button
.
collapsed
)
button
.
collapsed
=
true
;
if
(
chevron
.
collapsed
)
{
chevron
.
collapsed
=
false
;
var
overflowPadder
=
document
.
getElementById
(
"
overflow
-
padder
"
)
;
overflowPadder
.
width
=
width
-
chevron
.
boxObject
.
width
;
}
}
usedWidth
+
=
button
.
boxObject
.
width
;
}
}
fillInBTTooltip
:
function
(
tipElement
)
{
var
title
=
tipElement
.
label
;
var
url
=
tipElement
.
statusText
;
if
(
!
title
&
&
!
url
)
{
return
false
;
}
var
tooltipTitle
=
document
.
getElementById
(
"
btTitleText
"
)
;
var
tooltipUrl
=
document
.
getElementById
(
"
btUrlText
"
)
;
if
(
title
&
&
title
!
=
url
)
{
tooltipTitle
.
removeAttribute
(
"
hidden
"
)
;
tooltipTitle
.
setAttribute
(
"
value
"
title
)
;
}
else
{
tooltipTitle
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
if
(
url
)
{
tooltipUrl
.
removeAttribute
(
"
hidden
"
)
;
tooltipUrl
.
setAttribute
(
"
value
"
url
)
;
}
else
{
tooltipUrl
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
return
true
;
}
}
var
BookmarksToolbarRDFObserver
=
{
onAssert
:
function
(
aDataSource
aSource
aProperty
aTarget
)
{
if
(
aProperty
.
Value
=
=
gNC_NS
+
"
BookmarksToolbarFolder
"
)
{
var
bt
=
document
.
getElementById
(
"
bookmarks
-
ptf
"
)
;
if
(
bt
)
{
bt
.
ref
=
aSource
.
Value
;
document
.
getElementById
(
"
bookmarks
-
chevron
"
)
.
ref
=
aSource
.
Value
;
}
}
this
.
setOverflowTimeout
(
aSource
aProperty
)
;
}
onUnassert
:
function
(
aDataSource
aSource
aProperty
aTarget
)
{
this
.
setOverflowTimeout
(
aSource
aProperty
)
;
}
onChange
:
function
(
aDataSource
aSource
aProperty
aOldTarget
aNewTarget
)
{
this
.
setOverflowTimeout
(
aSource
aProperty
)
;
}
onMove
:
function
(
aDataSource
aOldSource
aNewSource
aProperty
aTarget
)
{
}
onBeginUpdateBatch
:
function
(
aDataSource
)
{
}
onEndUpdateBatch
:
function
(
aDataSource
)
{
this
.
_overflowTimerInEffect
=
true
;
setTimeout
(
BookmarksToolbar
.
resizeFunc
0
null
)
;
}
_overflowTimerInEffect
:
false
setOverflowTimeout
:
function
(
aSource
aProperty
)
{
if
(
this
.
_overflowTimerInEffect
)
return
;
if
(
aProperty
.
Value
=
=
gWEB_NS
+
"
LastModifiedDate
"
)
return
;
this
.
_overflowTimerInEffect
=
true
;
setTimeout
(
BookmarksToolbar
.
resizeFunc
0
null
)
;
}
}
