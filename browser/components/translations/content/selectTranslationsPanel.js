ChromeUtils
.
defineESModuleGetters
(
this
{
LanguageDetector
:
"
resource
:
/
/
gre
/
modules
/
translation
/
LanguageDetector
.
sys
.
mjs
"
TranslationsPanelShared
:
"
chrome
:
/
/
browser
/
content
/
translations
/
TranslationsPanelShared
.
sys
.
mjs
"
Translator
:
"
chrome
:
/
/
global
/
content
/
translations
/
Translator
.
mjs
"
}
)
;
var
SelectTranslationsPanel
=
new
(
class
{
#
console
;
get
console
(
)
{
if
(
!
this
.
#
console
)
{
try
{
this
.
#
console
=
console
.
createInstance
(
{
maxLogLevelPref
:
"
browser
.
translations
.
logLevel
"
prefix
:
"
Translations
"
}
)
;
}
catch
{
}
}
return
this
.
#
console
;
}
#
shortTextHeight
=
"
8em
"
;
get
shortTextHeight
(
)
{
return
this
.
#
shortTextHeight
;
}
#
longTextHeight
=
"
16em
"
;
get
longTextHeight
(
)
{
return
this
.
#
longTextHeight
;
}
#
textLengthThreshold
=
800
;
get
textLengthThreshold
(
)
{
return
this
.
#
textLengthThreshold
;
}
#
idlePlaceholderText
;
#
translatingPlaceholderText
;
#
lazyElements
;
#
translationState
=
{
phase
:
"
closed
"
}
;
#
translator
;
#
translationId
=
0
;
get
elements
(
)
{
if
(
!
this
.
#
lazyElements
)
{
const
wrapper
=
document
.
getElementById
(
"
template
-
select
-
translations
-
panel
"
)
;
const
panel
=
wrapper
.
content
.
firstElementChild
;
const
settingsButton
=
document
.
getElementById
(
"
translations
-
panel
-
settings
"
)
;
wrapper
.
replaceWith
(
wrapper
.
content
)
;
this
.
#
lazyElements
=
{
panel
settingsButton
}
;
TranslationsPanelShared
.
defineLazyElements
(
document
this
.
#
lazyElements
{
betaIcon
:
"
select
-
translations
-
panel
-
beta
-
icon
"
copyButton
:
"
select
-
translations
-
panel
-
copy
-
button
"
doneButton
:
"
select
-
translations
-
panel
-
done
-
button
"
fromLabel
:
"
select
-
translations
-
panel
-
from
-
label
"
fromMenuList
:
"
select
-
translations
-
panel
-
from
"
fromMenuPopup
:
"
select
-
translations
-
panel
-
from
-
menupopup
"
header
:
"
select
-
translations
-
panel
-
header
"
multiview
:
"
select
-
translations
-
panel
-
multiview
"
textArea
:
"
select
-
translations
-
panel
-
text
-
area
"
toLabel
:
"
select
-
translations
-
panel
-
to
-
label
"
toMenuList
:
"
select
-
translations
-
panel
-
to
"
toMenuPopup
:
"
select
-
translations
-
panel
-
to
-
menupopup
"
translateFullPageButton
:
"
select
-
translations
-
panel
-
translate
-
full
-
page
-
button
"
}
)
;
}
return
this
.
#
lazyElements
;
}
async
getLangPairPromise
(
textToTranslate
)
{
const
[
fromLang
toLang
]
=
await
Promise
.
all
(
[
LanguageDetector
.
detectLanguage
(
textToTranslate
)
.
then
(
(
{
language
}
)
=
>
language
)
TranslationsParent
.
getTopPreferredSupportedToLang
(
)
]
)
;
return
{
fromLang
toLang
:
fromLang
=
=
=
toLang
?
undefined
:
toLang
}
;
}
close
(
)
{
PanelMultiView
.
hidePopup
(
this
.
elements
.
panel
)
;
}
async
#
ensureLangListsBuilt
(
)
{
try
{
await
TranslationsPanelShared
.
ensureLangListsBuilt
(
document
this
.
elements
.
panel
gBrowser
.
selectedBrowser
.
innerWindowID
)
;
}
catch
(
error
)
{
this
.
console
?
.
error
(
error
)
;
}
}
async
#
initializeLanguageMenuList
(
langTag
menuList
)
{
const
isLangTagSupported
=
menuList
.
id
=
=
=
this
.
elements
.
fromMenuList
.
id
?
await
TranslationsParent
.
isSupportedAsFromLang
(
langTag
)
:
await
TranslationsParent
.
isSupportedAsToLang
(
langTag
)
;
if
(
isLangTagSupported
)
{
menuList
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
menuList
.
value
=
langTag
;
}
else
{
await
this
.
#
deselectLanguage
(
menuList
)
;
}
}
async
#
initializeLanguageMenuLists
(
langPairPromise
)
{
const
{
fromLang
toLang
}
=
await
langPairPromise
;
const
{
fromMenuList
toMenuList
}
=
this
.
elements
;
await
Promise
.
all
(
[
this
.
#
initializeLanguageMenuList
(
fromLang
fromMenuList
)
this
.
#
initializeLanguageMenuList
(
toLang
toMenuList
)
]
)
;
}
async
open
(
event
sourceText
langPairPromise
)
{
if
(
this
.
#
isOpen
(
)
)
{
return
;
}
this
.
#
registerSourceText
(
sourceText
)
;
await
this
.
#
ensureLangListsBuilt
(
)
;
await
Promise
.
all
(
[
this
.
#
cachePlaceholderText
(
)
this
.
#
initializeLanguageMenuLists
(
langPairPromise
)
]
)
;
this
.
#
displayIdlePlaceholder
(
)
;
this
.
#
maybeRequestTranslation
(
)
;
await
this
.
#
openPopup
(
event
)
;
}
async
#
openPopup
(
event
)
{
this
.
console
?
.
log
(
"
Showing
SelectTranslationsPanel
"
)
;
const
{
panel
}
=
this
.
elements
;
const
appMenuButton
=
document
.
getElementById
(
"
PanelUI
-
menu
-
button
"
)
;
await
PanelMultiView
.
openPopup
(
panel
appMenuButton
{
position
:
"
bottomright
topright
"
triggerEvent
:
event
}
)
.
catch
(
error
=
>
this
.
console
?
.
error
(
error
)
)
;
}
#
registerSourceText
(
sourceText
)
{
const
{
textArea
}
=
this
.
elements
;
this
.
#
changeStateTo
(
"
idle
"
/
*
retainEntries
*
/
false
{
sourceText
}
)
;
if
(
sourceText
.
length
<
SelectTranslationsPanel
.
textLengthThreshold
)
{
textArea
.
style
.
height
=
SelectTranslationsPanel
.
shortTextHeight
;
}
else
{
textArea
.
style
.
height
=
SelectTranslationsPanel
.
longTextHeight
;
}
}
async
#
cachePlaceholderText
(
)
{
const
[
idleText
translatingText
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
select
-
translations
-
panel
-
idle
-
placeholder
-
text
"
}
{
id
:
"
select
-
translations
-
panel
-
translating
-
placeholder
-
text
"
}
]
)
;
this
.
#
idlePlaceholderText
=
idleText
;
this
.
#
translatingPlaceholderText
=
translatingText
;
}
handlePanelPopupShownEvent
(
event
)
{
const
{
panel
fromMenuPopup
toMenuPopup
}
=
this
.
elements
;
switch
(
event
.
target
.
id
)
{
case
panel
.
id
:
{
this
.
#
updatePanelUIFromState
(
)
;
break
;
}
case
fromMenuPopup
.
id
:
{
this
.
#
maybeTranslateOnEvents
(
[
"
popuphidden
"
]
fromMenuPopup
)
;
break
;
}
case
toMenuPopup
.
id
:
{
this
.
#
maybeTranslateOnEvents
(
[
"
popuphidden
"
]
toMenuPopup
)
;
break
;
}
}
}
handlePanelPopupHiddenEvent
(
event
)
{
const
{
panel
}
=
this
.
elements
;
switch
(
event
.
target
.
id
)
{
case
panel
.
id
:
{
this
.
#
changeStateToClosed
(
)
;
break
;
}
}
}
onChangeFromLanguage
(
)
{
const
{
fromMenuList
toMenuList
}
=
this
.
elements
;
this
.
#
maybeTranslateOnEvents
(
[
"
blur
"
"
keypress
"
]
fromMenuList
)
;
this
.
#
maybeStealLanguageFrom
(
toMenuList
)
;
}
onChangeToLanguage
(
)
{
const
{
toMenuList
fromMenuList
}
=
this
.
elements
;
this
.
#
maybeTranslateOnEvents
(
[
"
blur
"
"
keypress
"
]
toMenuList
)
;
this
.
#
maybeStealLanguageFrom
(
fromMenuList
)
;
}
async
#
deselectLanguage
(
menuList
)
{
menuList
.
value
=
"
"
;
document
.
l10n
.
setAttributes
(
menuList
"
translations
-
panel
-
choose
-
language
"
)
;
await
document
.
l10n
.
translateElements
(
[
menuList
]
)
;
}
async
#
maybeStealLanguageFrom
(
menuList
)
{
const
{
fromLanguage
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
if
(
fromLanguage
=
=
=
toLanguage
)
{
await
this
.
#
deselectLanguage
(
menuList
)
;
this
.
#
maybeFocusMenuList
(
menuList
)
;
}
}
#
maybeFocusMenuList
(
menuList
)
{
if
(
menuList
&
&
!
menuList
.
value
)
{
menuList
.
focus
(
{
focusVisible
:
true
}
)
;
return
;
}
const
{
fromMenuList
toMenuList
}
=
this
.
elements
;
if
(
!
fromMenuList
.
value
)
{
fromMenuList
.
focus
(
{
focusVisible
:
true
}
)
;
}
else
if
(
!
toMenuList
.
value
)
{
toMenuList
.
focus
(
{
focusVisible
:
true
}
)
;
}
}
#
indicateTranslatedTextArea
(
{
overflow
}
)
{
const
{
textArea
}
=
this
.
elements
;
textArea
.
focus
(
{
focusVisible
:
true
}
)
;
requestAnimationFrame
(
(
)
=
>
{
requestAnimationFrame
(
(
)
=
>
{
textArea
.
style
.
overflow
=
overflow
;
textArea
.
scrollTop
=
0
;
}
)
;
}
)
;
}
#
isSelectedLangPair
(
fromLanguage
toLanguage
)
{
const
{
fromLanguage
:
selectedFromLang
toLanguage
:
selectedToLang
}
=
this
.
#
getSelectedLanguagePair
(
)
;
return
fromLanguage
=
=
=
selectedFromLang
&
&
toLanguage
=
=
=
selectedToLang
;
}
#
translatorMatchesLangPair
(
fromLanguage
toLanguage
)
{
return
(
this
.
#
translator
?
.
fromLanguage
=
=
=
fromLanguage
&
&
this
.
#
translator
?
.
toLanguage
=
=
=
toLanguage
)
;
}
#
getSelectedLanguagePair
(
)
{
const
{
fromMenuList
toMenuList
}
=
this
.
elements
;
return
{
fromLanguage
:
fromMenuList
.
value
toLanguage
:
toMenuList
.
value
}
;
}
getSourceText
(
)
{
return
this
.
#
translationState
?
.
sourceText
;
}
getTranslatedText
(
)
{
return
this
.
#
translationState
?
.
translatedText
;
}
#
phase
(
)
{
return
this
.
#
translationState
.
phase
;
}
#
isOpen
(
)
{
return
this
.
#
phase
(
)
!
=
=
"
closed
"
;
}
#
isClosed
(
)
{
return
this
.
#
phase
(
)
=
=
=
"
closed
"
;
}
#
changeStateTo
(
phase
retainEntries
data
=
null
)
{
const
{
textArea
}
=
this
.
elements
;
switch
(
phase
)
{
case
"
translating
"
:
{
textArea
.
classList
.
add
(
"
translating
"
)
;
break
;
}
case
"
closed
"
:
case
"
idle
"
:
case
"
translatable
"
:
case
"
translated
"
:
{
textArea
.
classList
.
remove
(
"
translating
"
)
;
break
;
}
default
:
{
throw
new
Error
(
Invalid
state
change
to
'
{
phase
}
'
)
;
}
}
const
previousPhase
=
this
.
#
phase
(
)
;
if
(
data
&
&
retainEntries
)
{
this
.
#
translationState
=
{
.
.
.
this
.
#
translationState
phase
.
.
.
data
}
;
}
else
if
(
data
)
{
this
.
#
translationState
=
{
phase
.
.
.
data
}
;
}
else
if
(
retainEntries
)
{
this
.
#
translationState
.
phase
=
phase
;
}
else
{
this
.
#
translationState
=
{
phase
}
;
}
if
(
previousPhase
=
=
=
this
.
#
phase
(
)
)
{
return
;
}
const
{
fromLanguage
toLanguage
}
=
this
.
#
translationState
;
this
.
console
?
.
debug
(
SelectTranslationsPanel
(
{
fromLanguage
?
fromLanguage
:
"
?
?
"
}
-
{
toLanguage
?
toLanguage
:
"
?
?
"
}
)
state
change
(
{
previousPhase
}
=
>
{
phase
}
)
)
;
this
.
#
updatePanelUIFromState
(
)
;
}
#
changeStateToClosed
(
)
{
this
.
#
changeStateTo
(
"
closed
"
/
*
retainEntries
*
/
false
)
;
}
#
changeStateToTranslating
(
)
{
const
phase
=
this
.
#
phase
(
)
;
if
(
phase
!
=
=
"
translatable
"
)
{
throw
new
Error
(
Invalid
state
change
(
{
phase
}
=
>
translating
)
)
;
}
this
.
#
changeStateTo
(
"
translating
"
/
*
retainEntries
*
/
true
)
;
}
#
changeStateToTranslated
(
translatedText
)
{
const
phase
=
this
.
#
phase
(
)
;
if
(
phase
!
=
=
"
translating
"
)
{
throw
new
Error
(
Invalid
state
change
(
{
phase
}
=
>
translated
)
)
;
}
this
.
#
changeStateTo
(
"
translated
"
/
*
retainEntries
*
/
true
{
translatedText
}
)
;
}
#
changeStateByLanguagePair
(
fromLanguage
toLanguage
)
{
const
{
phase
:
previousPhase
fromLanguage
:
previousFromLanguage
toLanguage
:
previousToLanguage
}
=
this
.
#
translationState
;
let
nextPhase
=
"
translatable
"
;
if
(
!
fromLanguage
|
|
!
toLanguage
|
|
fromLanguage
=
=
=
toLanguage
)
{
nextPhase
=
"
idle
"
;
}
else
if
(
previousFromLanguage
=
=
=
fromLanguage
&
&
previousToLanguage
=
=
=
toLanguage
)
{
nextPhase
=
previousPhase
;
}
this
.
#
changeStateTo
(
nextPhase
/
*
retainEntries
*
/
true
{
fromLanguage
toLanguage
}
)
;
return
nextPhase
;
}
#
shouldContinueTranslation
(
translationId
fromLanguage
toLanguage
)
{
return
(
this
.
#
isOpen
(
)
&
&
translationId
=
=
=
this
.
#
translationId
&
&
this
.
#
isSelectedLangPair
(
fromLanguage
toLanguage
)
&
&
this
.
#
translatorMatchesLangPair
(
fromLanguage
toLanguage
)
)
;
}
#
displayIdlePlaceholder
(
)
{
const
{
textArea
}
=
SelectTranslationsPanel
.
elements
;
textArea
.
value
=
this
.
#
idlePlaceholderText
;
this
.
#
updateTextDirection
(
)
;
this
.
#
updateConditionalUIEnabledState
(
)
;
this
.
#
maybeFocusMenuList
(
)
;
}
#
displayTranslatingPlaceholder
(
)
{
const
{
textArea
}
=
SelectTranslationsPanel
.
elements
;
textArea
.
value
=
this
.
#
translatingPlaceholderText
;
this
.
#
updateTextDirection
(
)
;
this
.
#
updateConditionalUIEnabledState
(
)
;
this
.
#
indicateTranslatedTextArea
(
{
overflow
:
"
hidden
"
}
)
;
}
#
displayTranslatedText
(
)
{
const
{
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
const
{
textArea
}
=
SelectTranslationsPanel
.
elements
;
textArea
.
value
=
this
.
getTranslatedText
(
)
;
this
.
#
updateTextDirection
(
toLanguage
)
;
this
.
#
updateConditionalUIEnabledState
(
)
;
this
.
#
indicateTranslatedTextArea
(
{
overflow
:
"
auto
"
}
)
;
}
#
updateConditionalUIEnabledState
(
)
{
const
{
fromLanguage
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
const
{
copyButton
translateFullPageButton
textArea
}
=
this
.
elements
;
const
invalidLangPairSelected
=
!
fromLanguage
|
|
!
toLanguage
;
const
isTranslating
=
this
.
#
phase
(
)
=
=
=
"
translating
"
;
textArea
.
disabled
=
invalidLangPairSelected
;
translateFullPageButton
.
disabled
=
invalidLangPairSelected
;
copyButton
.
disabled
=
invalidLangPairSelected
|
|
isTranslating
;
}
#
updatePanelUIFromState
(
)
{
switch
(
this
.
#
phase
(
)
)
{
case
"
idle
"
:
{
this
.
#
displayIdlePlaceholder
(
)
;
break
;
}
case
"
translating
"
:
{
this
.
#
displayTranslatingPlaceholder
(
)
;
break
;
}
case
"
translated
"
:
{
this
.
#
displayTranslatedText
(
)
;
break
;
}
}
}
#
updateTextDirection
(
langTag
)
{
const
{
textArea
}
=
this
.
elements
;
if
(
langTag
)
{
const
scriptDirection
=
Services
.
intl
.
getScriptDirection
(
langTag
)
;
textArea
.
setAttribute
(
"
dir
"
scriptDirection
)
;
}
else
{
textArea
.
removeAttribute
(
"
dir
"
)
;
}
}
async
#
requestTranslationsPort
(
fromLanguage
toLanguage
)
{
const
innerWindowId
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
innerWindowID
;
if
(
!
innerWindowId
)
{
return
undefined
;
}
const
port
=
await
TranslationsParent
.
requestTranslationsPort
(
innerWindowId
fromLanguage
toLanguage
)
;
return
port
;
}
async
#
getOrCreateTranslator
(
fromLanguage
toLanguage
)
{
if
(
this
.
#
translatorMatchesLangPair
(
fromLanguage
toLanguage
)
)
{
return
this
.
#
translator
;
}
this
.
console
?
.
log
(
Creating
new
Translator
(
{
fromLanguage
}
-
{
toLanguage
}
)
)
;
if
(
this
.
#
translator
)
{
this
.
#
translator
.
destroy
(
)
;
this
.
#
translator
=
null
;
}
this
.
#
translator
=
await
Translator
.
create
(
fromLanguage
toLanguage
this
.
#
requestTranslationsPort
)
;
return
this
.
#
translator
;
}
#
maybeRequestTranslation
(
)
{
if
(
this
.
#
isClosed
(
)
)
{
return
;
}
const
{
fromLanguage
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
const
nextState
=
this
.
#
changeStateByLanguagePair
(
fromLanguage
toLanguage
)
;
if
(
nextState
!
=
=
"
translatable
"
)
{
return
;
}
const
translationId
=
+
+
this
.
#
translationId
;
this
.
#
getOrCreateTranslator
(
fromLanguage
toLanguage
)
.
then
(
translator
=
>
{
if
(
this
.
#
shouldContinueTranslation
(
translationId
fromLanguage
toLanguage
)
)
{
this
.
#
changeStateToTranslating
(
)
;
return
translator
.
translate
(
this
.
getSourceText
(
)
)
;
}
return
null
;
}
)
.
then
(
translatedText
=
>
{
if
(
translatedText
&
&
this
.
#
shouldContinueTranslation
(
translationId
fromLanguage
toLanguage
)
)
{
this
.
#
changeStateToTranslated
(
translatedText
)
;
}
else
if
(
this
.
#
isOpen
(
)
)
{
this
.
#
changeStateTo
(
"
idle
"
/
*
retainEntires
*
/
false
{
sourceText
:
this
.
getSourceText
(
)
}
)
;
}
}
)
.
catch
(
error
=
>
this
.
console
?
.
error
(
error
)
)
;
}
#
maybeTranslateOnEvents
(
eventTypes
target
)
{
if
(
!
target
.
translationListenerCallbacks
)
{
target
.
translationListenerCallbacks
=
[
]
;
}
if
(
target
.
translationListenerCallbacks
.
length
=
=
=
0
)
{
for
(
const
eventType
of
eventTypes
)
{
let
callback
;
switch
(
eventType
)
{
case
"
blur
"
:
case
"
popuphidden
"
:
{
callback
=
(
)
=
>
{
this
.
#
maybeRequestTranslation
(
)
;
this
.
#
removeTranslationListeners
(
target
)
;
}
;
break
;
}
case
"
keypress
"
:
{
callback
=
event
=
>
{
if
(
event
.
key
=
=
=
"
Enter
"
)
{
this
.
#
maybeRequestTranslation
(
)
;
}
this
.
#
removeTranslationListeners
(
target
)
;
}
;
break
;
}
default
:
{
throw
new
Error
(
Invalid
translation
event
type
given
:
'
{
eventType
}
)
;
}
}
target
.
addEventListener
(
eventType
callback
{
once
:
true
}
)
;
target
.
translationListenerCallbacks
.
push
(
{
eventType
callback
}
)
;
}
}
}
#
removeTranslationListeners
(
target
)
{
for
(
const
{
eventType
callback
}
of
target
.
translationListenerCallbacks
)
{
target
.
removeEventListener
(
eventType
callback
)
;
}
target
.
translationListenerCallbacks
=
[
]
;
}
}
)
(
)
;
