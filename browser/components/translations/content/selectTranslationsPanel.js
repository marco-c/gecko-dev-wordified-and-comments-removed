ChromeUtils
.
defineESModuleGetters
(
this
{
LanguageDetector
:
"
resource
:
/
/
gre
/
modules
/
translation
/
LanguageDetector
.
sys
.
mjs
"
TranslationsPanelShared
:
"
chrome
:
/
/
browser
/
content
/
translations
/
TranslationsPanelShared
.
sys
.
mjs
"
Translator
:
"
chrome
:
/
/
global
/
content
/
translations
/
Translator
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ClipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
GfxInfo
"
"
mozilla
.
org
/
gfx
/
info
;
1
"
"
nsIGfxInfo
"
)
;
var
SelectTranslationsPanel
=
new
(
class
{
#
console
;
get
console
(
)
{
if
(
!
this
.
#
console
)
{
try
{
this
.
#
console
=
console
.
createInstance
(
{
maxLogLevelPref
:
"
browser
.
translations
.
logLevel
"
prefix
:
"
Translations
"
}
)
;
}
catch
{
}
}
return
this
.
#
console
;
}
#
shortTextHeight
=
"
8em
"
;
get
shortTextHeight
(
)
{
return
this
.
#
shortTextHeight
;
}
#
longTextHeight
=
"
16em
"
;
#
alignmentPosition
=
"
"
;
#
mostRecentUIPhase
=
"
closed
"
;
#
sourceTextWordCount
=
undefined
;
#
languageInfo
=
{
docLangTag
:
undefined
isDocLangTagSupported
:
undefined
topPreferredLanguage
:
undefined
}
;
get
longTextHeight
(
)
{
return
this
.
#
longTextHeight
;
}
#
textLengthThreshold
=
800
;
get
textLengthThreshold
(
)
{
return
this
.
#
textLengthThreshold
;
}
#
idlePlaceholderText
;
#
translatingPlaceholderText
;
#
lazyElements
;
#
eventListenersInitialized
=
false
;
#
isFullPageTranslationsRestrictedForPage
=
true
;
#
translationState
=
{
phase
:
"
closed
"
}
;
#
translationId
=
0
;
get
elements
(
)
{
if
(
!
this
.
#
lazyElements
)
{
const
wrapper
=
document
.
getElementById
(
"
template
-
select
-
translations
-
panel
"
)
;
const
panel
=
wrapper
.
content
.
firstElementChild
;
const
settingsButton
=
document
.
getElementById
(
"
translations
-
panel
-
settings
"
)
;
wrapper
.
replaceWith
(
wrapper
.
content
)
;
this
.
#
lazyElements
=
{
panel
settingsButton
}
;
TranslationsPanelShared
.
defineLazyElements
(
document
this
.
#
lazyElements
{
betaIcon
:
"
select
-
translations
-
panel
-
beta
-
icon
"
cancelButton
:
"
select
-
translations
-
panel
-
cancel
-
button
"
copyButton
:
"
select
-
translations
-
panel
-
copy
-
button
"
doneButtonPrimary
:
"
select
-
translations
-
panel
-
done
-
button
-
primary
"
doneButtonSecondary
:
"
select
-
translations
-
panel
-
done
-
button
-
secondary
"
fromLabel
:
"
select
-
translations
-
panel
-
from
-
label
"
fromMenuList
:
"
select
-
translations
-
panel
-
from
"
fromMenuPopup
:
"
select
-
translations
-
panel
-
from
-
menupopup
"
header
:
"
select
-
translations
-
panel
-
header
"
initFailureContent
:
"
select
-
translations
-
panel
-
init
-
failure
-
content
"
initFailureMessageBar
:
"
select
-
translations
-
panel
-
init
-
failure
-
message
-
bar
"
mainContent
:
"
select
-
translations
-
panel
-
main
-
content
"
settingsButton
:
"
select
-
translations
-
panel
-
settings
-
button
"
textArea
:
"
select
-
translations
-
panel
-
text
-
area
"
toLabel
:
"
select
-
translations
-
panel
-
to
-
label
"
toMenuList
:
"
select
-
translations
-
panel
-
to
"
toMenuPopup
:
"
select
-
translations
-
panel
-
to
-
menupopup
"
translateButton
:
"
select
-
translations
-
panel
-
translate
-
button
"
translateFullPageButton
:
"
select
-
translations
-
panel
-
translate
-
full
-
page
-
button
"
translationFailureMessageBar
:
"
select
-
translations
-
panel
-
translation
-
failure
-
message
-
bar
"
tryAgainButton
:
"
select
-
translations
-
panel
-
try
-
again
-
button
"
tryAnotherSourceMenuList
:
"
select
-
translations
-
panel
-
try
-
another
-
language
"
tryAnotherSourceMenuPopup
:
"
select
-
translations
-
panel
-
try
-
another
-
language
-
menupopup
"
unsupportedLanguageContent
:
"
select
-
translations
-
panel
-
unsupported
-
language
-
content
"
unsupportedLanguageMessageBar
:
"
select
-
translations
-
panel
-
unsupported
-
language
-
message
-
bar
"
}
)
;
}
return
this
.
#
lazyElements
;
}
async
getTopSupportedDetectedLanguage
(
textToTranslate
)
{
const
{
language
languages
}
=
await
LanguageDetector
.
detectLanguage
(
textToTranslate
)
;
for
(
const
{
languageCode
}
of
languages
)
{
const
isSupported
=
await
TranslationsParent
.
isSupportedAsFromLang
(
languageCode
)
;
if
(
isSupported
)
{
return
languageCode
;
}
}
const
{
docLangTag
isDocLangTagSupported
}
=
this
.
#
getLanguageInfo
(
true
)
;
if
(
isDocLangTagSupported
)
{
return
docLangTag
;
}
return
language
;
}
#
getLanguageInfo
(
forceFetch
=
false
)
{
if
(
!
forceFetch
&
&
this
.
#
languageInfo
.
docLangTag
!
=
=
undefined
)
{
return
this
.
#
languageInfo
;
}
this
.
#
languageInfo
=
{
docLangTag
:
undefined
isDocLangTagSupported
:
undefined
topPreferredLanguage
:
undefined
}
;
try
{
const
actor
=
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
;
const
{
detectedLanguages
:
{
docLangTag
isDocLangTagSupported
}
}
=
actor
.
languageState
;
const
preferredLanguages
=
TranslationsParent
.
getPreferredLanguages
(
)
;
const
topPreferredLanguage
=
preferredLanguages
?
.
[
0
]
;
this
.
#
languageInfo
=
{
docLangTag
isDocLangTagSupported
topPreferredLanguage
}
;
}
catch
(
error
)
{
if
(
!
TranslationsParent
.
isFullPageTranslationsRestrictedForPage
(
gBrowser
)
)
{
this
.
console
?
.
warn
(
"
Failed
to
retrieve
the
TranslationsParent
actor
on
a
page
where
Full
Page
Translations
is
not
restricted
.
"
)
;
this
.
console
?
.
error
(
error
)
;
}
}
return
this
.
#
languageInfo
;
}
async
getLangPairPromise
(
textToTranslate
)
{
if
(
TranslationsParent
.
isInAutomation
(
)
&
&
!
TranslationsParent
.
isTranslationsEngineMocked
(
)
)
{
return
{
toLang
:
"
en
"
}
;
}
const
[
fromLanguage
toLanguage
]
=
await
Promise
.
all
(
[
SelectTranslationsPanel
.
getTopSupportedDetectedLanguage
(
textToTranslate
)
TranslationsParent
.
getTopPreferredSupportedToLang
(
)
]
)
;
return
{
fromLanguage
toLanguage
}
;
}
close
(
)
{
PanelMultiView
.
hidePopup
(
this
.
elements
.
panel
)
;
this
.
#
mostRecentUIPhase
=
"
closed
"
;
}
async
#
ensureLangListsBuilt
(
)
{
await
TranslationsPanelShared
.
ensureLangListsBuilt
(
document
this
)
;
}
async
#
initializeLanguageMenuList
(
langTag
menuList
)
{
const
isLangTagSupported
=
menuList
.
id
=
=
=
this
.
elements
.
fromMenuList
.
id
?
await
TranslationsParent
.
isSupportedAsFromLang
(
langTag
)
:
await
TranslationsParent
.
isSupportedAsToLang
(
langTag
)
;
if
(
isLangTagSupported
)
{
menuList
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
menuList
.
value
=
langTag
;
}
else
{
await
this
.
#
deselectLanguage
(
menuList
)
;
}
}
async
#
initializeLanguageMenuLists
(
langPairPromise
)
{
const
{
fromLanguage
toLanguage
}
=
await
langPairPromise
;
const
{
fromMenuList
fromMenuPopup
toMenuList
toMenuPopup
tryAnotherSourceMenuList
}
=
this
.
elements
;
await
Promise
.
all
(
[
this
.
#
initializeLanguageMenuList
(
fromLanguage
fromMenuList
)
this
.
#
initializeLanguageMenuList
(
toLanguage
toMenuList
)
this
.
#
initializeLanguageMenuList
(
null
tryAnotherSourceMenuList
)
]
)
;
this
.
#
maybeTranslateOnEvents
(
[
"
keypress
"
]
fromMenuList
)
;
this
.
#
maybeTranslateOnEvents
(
[
"
keypress
"
]
toMenuList
)
;
this
.
#
maybeTranslateOnEvents
(
[
"
popuphidden
"
]
fromMenuPopup
)
;
this
.
#
maybeTranslateOnEvents
(
[
"
popuphidden
"
]
toMenuPopup
)
;
}
#
initializeEventListeners
(
)
{
if
(
this
.
#
eventListenersInitialized
)
{
return
;
}
const
{
panel
fromMenuList
toMenuList
tryAnotherSourceMenuList
}
=
this
.
elements
;
panel
.
addEventListener
(
"
popupshown
"
this
)
;
panel
.
addEventListener
(
"
popuphidden
"
this
)
;
panel
.
addEventListener
(
"
command
"
this
)
;
fromMenuList
.
addEventListener
(
"
command
"
this
)
;
toMenuList
.
addEventListener
(
"
command
"
this
)
;
tryAnotherSourceMenuList
.
addEventListener
(
"
command
"
this
)
;
this
.
#
eventListenersInitialized
=
true
;
}
async
open
(
event
screenX
screenY
sourceText
langPairPromise
maintainFlow
=
false
)
{
if
(
this
.
#
isOpen
(
)
)
{
await
this
.
#
forceReopen
(
event
screenX
screenY
sourceText
langPairPromise
)
;
return
;
}
const
{
fromLanguage
toLanguage
}
=
await
langPairPromise
;
const
{
docLangTag
topPreferredLanguage
}
=
this
.
#
getLanguageInfo
(
)
;
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onOpen
(
{
maintainFlow
docLangTag
fromLanguage
toLanguage
topPreferredLanguage
}
)
;
try
{
this
.
#
sourceTextWordCount
=
undefined
;
this
.
#
isFullPageTranslationsRestrictedForPage
=
TranslationsParent
.
isFullPageTranslationsRestrictedForPage
(
gBrowser
)
;
this
.
#
initializeEventListeners
(
)
;
await
this
.
#
ensureLangListsBuilt
(
)
;
await
Promise
.
all
(
[
this
.
#
cachePlaceholderText
(
)
this
.
#
initializeLanguageMenuLists
(
langPairPromise
)
this
.
#
registerSourceText
(
sourceText
langPairPromise
)
]
)
;
this
.
#
maybeRequestTranslation
(
)
;
}
catch
(
error
)
{
this
.
console
?
.
error
(
error
)
;
this
.
#
changeStateToInitFailure
(
event
screenX
screenY
sourceText
langPairPromise
)
;
}
this
.
#
openPopup
(
event
screenX
screenY
)
;
}
async
#
forceReopen
(
event
screenX
screenY
sourceText
langPairPromise
)
{
this
.
console
?
.
warn
(
"
The
SelectTranslationsPanel
was
forced
to
reopen
.
"
)
;
this
.
close
(
)
;
this
.
#
changeStateToClosed
(
)
;
await
this
.
open
(
event
screenX
screenY
sourceText
langPairPromise
)
;
}
#
openPopup
(
event
screenX
screenY
)
{
this
.
console
?
.
log
(
"
Showing
SelectTranslationsPanel
"
)
;
const
{
panel
}
=
this
.
elements
;
this
.
#
cacheAlignmentPositionOnOpen
(
)
;
panel
.
openPopupAtScreenRect
(
"
after_start
"
screenX
screenY
0
0
false
false
event
)
;
}
#
cacheAlignmentPositionOnOpen
(
)
{
const
{
panel
}
=
this
.
elements
;
this
.
#
alignmentPosition
=
"
"
;
panel
.
addEventListener
(
"
popuppositioned
"
popupPositionedEvent
=
>
{
this
.
#
alignmentPosition
=
popupPositionedEvent
.
alignmentPosition
;
}
{
once
:
true
}
)
;
}
async
#
registerSourceText
(
sourceText
langPairPromise
)
{
const
{
textArea
}
=
this
.
elements
;
const
{
fromLanguage
toLanguage
}
=
await
langPairPromise
;
const
isFromLangSupported
=
await
TranslationsParent
.
isSupportedAsFromLang
(
fromLanguage
)
;
if
(
isFromLangSupported
)
{
this
.
#
changeStateTo
(
"
idle
"
/
*
retainEntries
*
/
false
{
sourceText
fromLanguage
toLanguage
}
)
;
}
else
{
this
.
#
changeStateTo
(
"
unsupported
"
/
*
retainEntries
*
/
false
{
sourceText
detectedLanguage
:
fromLanguage
toLanguage
}
)
;
}
textArea
.
value
=
"
"
;
textArea
.
style
.
resize
=
"
none
"
;
textArea
.
style
.
maxHeight
=
null
;
if
(
sourceText
.
length
<
SelectTranslationsPanel
.
textLengthThreshold
)
{
textArea
.
style
.
height
=
SelectTranslationsPanel
.
shortTextHeight
;
}
else
{
textArea
.
style
.
height
=
SelectTranslationsPanel
.
longTextHeight
;
}
this
.
#
maybeTranslateOnEvents
(
[
"
focus
"
]
textArea
)
;
}
async
#
cachePlaceholderText
(
)
{
const
[
idleText
translatingText
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
select
-
translations
-
panel
-
idle
-
placeholder
-
text
"
}
{
id
:
"
select
-
translations
-
panel
-
translating
-
placeholder
-
text
"
}
]
)
;
this
.
#
idlePlaceholderText
=
idleText
;
this
.
#
translatingPlaceholderText
=
translatingText
;
}
#
openSettingsPopup
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onOpenSettingsMenu
(
)
;
const
{
settingsButton
}
=
this
.
elements
;
const
popup
=
settingsButton
.
ownerDocument
.
getElementById
(
"
select
-
translations
-
panel
-
settings
-
menupopup
"
)
;
popup
.
openPopup
(
settingsButton
"
after_start
"
)
;
}
onAboutTranslations
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onAboutTranslations
(
)
;
this
.
close
(
)
;
const
window
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
window
.
openTrustedLinkIn
(
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
website
-
translation
"
"
tab
"
{
forceForeground
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
openTranslationsSettingsPage
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onTranslationSettings
(
)
;
this
.
close
(
)
;
const
window
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
window
.
openTrustedLinkIn
(
"
about
:
preferences
#
general
-
translations
"
"
tab
"
)
;
}
#
handleCommandEvent
(
target
)
{
const
{
cancelButton
copyButton
doneButtonPrimary
doneButtonSecondary
fromMenuList
fromMenuPopup
settingsButton
toMenuList
toMenuPopup
translateButton
translateFullPageButton
tryAgainButton
tryAnotherSourceMenuList
tryAnotherSourceMenuPopup
}
=
this
.
elements
;
switch
(
target
.
id
)
{
case
cancelButton
.
id
:
{
this
.
onClickCancelButton
(
)
;
break
;
}
case
copyButton
.
id
:
{
this
.
onClickCopyButton
(
)
;
break
;
}
case
doneButtonPrimary
.
id
:
case
doneButtonSecondary
.
id
:
{
this
.
onClickDoneButton
(
)
;
break
;
}
case
fromMenuList
.
id
:
case
fromMenuPopup
.
id
:
{
this
.
onChangeFromLanguage
(
)
;
break
;
}
case
settingsButton
.
id
:
{
this
.
#
openSettingsPopup
(
)
;
break
;
}
case
toMenuList
.
id
:
case
toMenuPopup
.
id
:
{
this
.
onChangeToLanguage
(
)
;
break
;
}
case
translateButton
.
id
:
{
this
.
onClickTranslateButton
(
)
;
break
;
}
case
translateFullPageButton
.
id
:
{
this
.
onClickTranslateFullPageButton
(
)
;
break
;
}
case
tryAgainButton
.
id
:
{
this
.
onClickTryAgainButton
(
)
;
break
;
}
case
tryAnotherSourceMenuList
.
id
:
case
tryAnotherSourceMenuPopup
.
id
:
{
this
.
onChangeTryAnotherSourceLanguage
(
)
;
break
;
}
}
}
#
maybeEnableTextAreaResizer
(
)
{
switch
(
this
.
#
alignmentPosition
)
{
case
"
after_start
"
:
case
"
after_end
"
:
{
break
;
}
case
"
before_start
"
:
case
"
before_end
"
:
{
this
.
console
?
.
debug
(
Disabling
text
-
area
resizer
due
to
panel
alignment
position
:
"
{
this
.
#
alignmentPosition
}
"
)
;
return
;
}
default
:
{
this
.
console
?
.
debug
(
Disabling
text
-
area
resizer
due
to
unexpected
panel
alignment
position
:
"
{
this
.
#
alignmentPosition
}
"
)
;
return
;
}
}
const
{
panel
textArea
}
=
this
.
elements
;
if
(
textArea
.
style
.
maxHeight
)
{
this
.
console
?
.
debug
(
"
The
text
-
area
resizer
has
already
been
enabled
at
the
current
panel
location
.
"
)
;
return
;
}
const
textAreaClientHeight
=
textArea
.
clientHeight
;
const
textAreaScrollHeight
=
textArea
.
scrollHeight
;
if
(
textAreaScrollHeight
<
=
textAreaClientHeight
)
{
this
.
console
?
.
debug
(
"
Disabling
text
-
area
resizer
because
the
text
content
fits
within
the
text
area
.
"
)
;
return
;
}
let
isWayland
=
false
;
try
{
isWayland
=
GfxInfo
.
windowProtocol
=
=
=
"
wayland
"
;
}
catch
(
error
)
{
if
(
AppConstants
.
platform
=
=
=
"
linux
"
)
{
this
.
console
?
.
warn
(
error
)
;
this
.
console
?
.
debug
(
"
Disabling
text
-
area
resizer
because
we
were
unable
to
retrieve
the
window
protocol
on
Linux
.
"
)
;
return
;
}
}
const
{
top
:
panelTop
left
:
panelLeft
bottom
:
panelBottom
right
:
panelRight
}
=
isWayland
?
panel
.
getBoundingClientRect
(
)
:
panel
.
getOuterScreenRect
(
)
;
const
window
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
if
(
isWayland
)
{
if
(
panelTop
<
0
)
{
this
.
console
?
.
debug
(
"
Disabling
text
-
area
resizer
because
the
panel
outside
the
top
edge
of
the
window
on
Wayland
.
"
)
;
return
;
}
if
(
panelBottom
>
window
.
innerHeight
)
{
this
.
console
?
.
debug
(
"
Disabling
text
-
area
resizer
because
the
panel
is
outside
the
bottom
edge
of
the
window
on
Wayland
.
"
)
;
return
;
}
if
(
panelLeft
<
0
)
{
this
.
console
?
.
debug
(
"
Disabling
text
-
area
resizer
because
the
panel
outside
the
left
edge
of
the
window
on
Wayland
.
"
)
;
return
;
}
if
(
panelRight
>
window
.
innerWidth
)
{
this
.
console
?
.
debug
(
"
Disabling
text
-
area
resizer
because
the
panel
is
outside
the
right
edge
of
the
window
on
Wayland
.
"
)
;
return
;
}
}
else
if
(
!
panelBottom
)
{
this
.
console
?
.
debug
(
"
Disabling
text
-
area
resizer
because
the
location
of
the
bottom
edge
of
the
panel
was
unavailable
.
"
)
;
return
;
}
const
availableHeight
=
isWayland
?
window
.
innerHeight
:
screen
.
availHeight
;
const
panelBottomToBottomEdge
=
availableHeight
-
panelBottom
;
const
BOTTOM_EDGE_PIXEL_BUFFER
=
20
;
if
(
panelBottomToBottomEdge
<
BOTTOM_EDGE_PIXEL_BUFFER
)
{
this
.
console
?
.
debug
(
"
Disabling
text
-
area
resizer
because
the
bottom
of
the
panel
is
already
close
to
the
bottom
edge
.
"
)
;
return
;
}
const
textAreaHeightLimitForEdge
=
textAreaClientHeight
+
panelBottomToBottomEdge
-
BOTTOM_EDGE_PIXEL_BUFFER
;
const
textAreaHeightLimitUpperBound
=
Math
.
trunc
(
availableHeight
/
2
)
;
const
textAreaMaxHeight
=
Math
.
min
(
textAreaScrollHeight
textAreaHeightLimitForEdge
textAreaHeightLimitUpperBound
)
;
textArea
.
style
.
resize
=
"
vertical
"
;
textArea
.
style
.
maxHeight
=
{
textAreaMaxHeight
}
px
;
this
.
console
?
.
debug
(
Enabling
text
-
area
resizer
with
a
maximum
height
of
{
textAreaMaxHeight
}
pixels
)
;
}
#
handlePopupShownEvent
(
target
)
{
const
{
panel
}
=
this
.
elements
;
switch
(
target
.
id
)
{
case
panel
.
id
:
{
this
.
#
updatePanelUIFromState
(
)
;
break
;
}
}
}
#
handlePopupHiddenEvent
(
target
)
{
const
{
panel
}
=
this
.
elements
;
switch
(
target
.
id
)
{
case
panel
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onClose
(
)
;
this
.
#
changeStateToClosed
(
)
;
this
.
#
removeActiveTranslationListeners
(
)
;
break
;
}
}
}
handleEvent
(
event
)
{
let
target
=
event
.
target
;
while
(
!
target
.
id
&
&
target
.
parentElement
)
{
target
=
target
.
parentElement
;
}
switch
(
event
.
type
)
{
case
"
command
"
:
{
this
.
#
handleCommandEvent
(
target
)
;
break
;
}
case
"
popupshown
"
:
{
this
.
#
handlePopupShownEvent
(
target
)
;
break
;
}
case
"
popuphidden
"
:
{
this
.
#
handlePopupHiddenEvent
(
target
)
;
break
;
}
}
}
onChangeFromLanguage
(
)
{
this
.
#
sourceTextWordCount
=
undefined
;
this
.
#
updateConditionalUIEnabledState
(
)
;
}
onChangeToLanguage
(
)
{
this
.
#
updateConditionalUIEnabledState
(
)
;
}
onChangeTryAnotherSourceLanguage
(
)
{
const
{
tryAnotherSourceMenuList
translateButton
}
=
this
.
elements
;
if
(
tryAnotherSourceMenuList
.
value
)
{
translateButton
.
disabled
=
false
;
}
}
onClickCancelButton
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onCancelButton
(
)
;
this
.
close
(
)
;
}
onClickCopyButton
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onCopyButton
(
)
;
try
{
ClipboardHelper
.
copyString
(
this
.
getTranslatedText
(
)
)
;
}
catch
(
error
)
{
this
.
console
?
.
error
(
error
)
;
return
;
}
this
.
#
checkCopyButton
(
)
;
}
onClickDoneButton
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onDoneButton
(
)
;
this
.
close
(
)
;
}
onClickTranslateButton
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onTranslateButton
(
)
;
const
{
fromMenuList
tryAnotherSourceMenuList
}
=
this
.
elements
;
fromMenuList
.
value
=
tryAnotherSourceMenuList
.
value
;
this
.
#
maybeRequestTranslation
(
)
;
}
onClickTranslateFullPageButton
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onTranslateFullPageButton
(
)
;
const
{
panel
}
=
this
.
elements
;
const
{
fromLanguage
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
try
{
const
actor
=
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
;
panel
.
addEventListener
(
"
popuphidden
"
(
)
=
>
actor
.
translate
(
fromLanguage
toLanguage
false
)
{
once
:
true
}
)
;
}
catch
(
error
)
{
this
.
console
?
.
error
(
error
)
;
}
this
.
close
(
)
;
}
onClickTryAgainButton
(
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onTryAgainButton
(
)
;
switch
(
this
.
phase
(
)
)
{
case
"
translation
-
failure
"
:
{
this
.
#
maybeRequestTranslation
(
)
;
break
;
}
case
"
init
-
failure
"
:
{
const
{
panel
}
=
this
.
elements
;
const
{
event
screenX
screenY
sourceText
langPairPromise
}
=
this
.
#
translationState
;
panel
.
addEventListener
(
"
popuphidden
"
(
)
=
>
this
.
open
(
event
screenX
screenY
sourceText
langPairPromise
true
)
{
once
:
true
}
)
;
this
.
close
(
)
;
break
;
}
default
:
{
this
.
console
?
.
error
(
Unexpected
state
"
{
this
.
phase
(
)
}
"
on
try
-
again
button
click
.
)
;
}
}
}
#
checkCopyButton
(
)
{
const
{
copyButton
}
=
this
.
elements
;
copyButton
.
classList
.
add
(
"
copied
"
)
;
document
.
l10n
.
setAttributes
(
copyButton
"
select
-
translations
-
panel
-
copy
-
button
-
copied
"
)
;
}
#
uncheckCopyButton
(
)
{
const
{
copyButton
}
=
this
.
elements
;
copyButton
.
classList
.
remove
(
"
copied
"
)
;
document
.
l10n
.
setAttributes
(
copyButton
"
select
-
translations
-
panel
-
copy
-
button
"
)
;
}
async
#
deselectLanguage
(
menuList
)
{
menuList
.
value
=
"
"
;
document
.
l10n
.
setAttributes
(
menuList
"
translations
-
panel
-
choose
-
language
"
)
;
await
document
.
l10n
.
translateElements
(
[
menuList
]
)
;
}
#
maybeFocusMenuList
(
menuList
)
{
if
(
menuList
&
&
!
menuList
.
value
)
{
menuList
.
focus
(
{
focusVisible
:
false
}
)
;
return
;
}
const
{
fromMenuList
toMenuList
}
=
this
.
elements
;
if
(
!
fromMenuList
.
value
)
{
fromMenuList
.
focus
(
{
focusVisible
:
false
}
)
;
}
else
if
(
!
toMenuList
.
value
)
{
toMenuList
.
focus
(
{
focusVisible
:
false
}
)
;
}
}
#
indicateTranslatedTextArea
(
{
overflow
}
)
{
const
{
textArea
}
=
this
.
elements
;
textArea
.
focus
(
{
focusVisible
:
true
}
)
;
requestAnimationFrame
(
(
)
=
>
{
requestAnimationFrame
(
(
)
=
>
{
textArea
.
style
.
overflow
=
overflow
;
textArea
.
scrollTop
=
0
;
}
)
;
}
)
;
}
#
isSelectedLangPair
(
fromLanguage
toLanguage
)
{
const
{
fromLanguage
:
selectedFromLang
toLanguage
:
selectedToLang
}
=
this
.
#
getSelectedLanguagePair
(
)
;
return
fromLanguage
=
=
=
selectedFromLang
&
&
toLanguage
=
=
=
selectedToLang
;
}
#
getSelectedLanguagePair
(
)
{
const
{
fromMenuList
toMenuList
}
=
this
.
elements
;
return
{
fromLanguage
:
fromMenuList
.
value
toLanguage
:
toMenuList
.
value
}
;
}
getSourceText
(
)
{
return
this
.
#
translationState
?
.
sourceText
;
}
getTranslatedText
(
)
{
return
this
.
#
translationState
?
.
translatedText
;
}
phase
(
)
{
return
this
.
#
translationState
.
phase
;
}
#
isOpen
(
)
{
return
this
.
phase
(
)
!
=
=
"
closed
"
;
}
#
isClosed
(
)
{
return
this
.
phase
(
)
=
=
=
"
closed
"
;
}
#
changeStateTo
(
phase
retainEntries
data
=
null
)
{
switch
(
phase
)
{
case
"
closed
"
:
case
"
idle
"
:
case
"
init
-
failure
"
:
case
"
translation
-
failure
"
:
case
"
translatable
"
:
case
"
translating
"
:
case
"
translated
"
:
case
"
unsupported
"
:
{
break
;
}
default
:
{
throw
new
Error
(
Invalid
state
change
to
'
{
phase
}
'
)
;
}
}
const
previousPhase
=
this
.
phase
(
)
;
if
(
data
&
&
retainEntries
)
{
this
.
#
translationState
=
{
.
.
.
this
.
#
translationState
phase
.
.
.
data
}
;
}
else
if
(
data
)
{
this
.
#
translationState
=
{
phase
.
.
.
data
}
;
}
else
if
(
retainEntries
)
{
this
.
#
translationState
.
phase
=
phase
;
}
else
{
this
.
#
translationState
=
{
phase
}
;
}
if
(
previousPhase
=
=
=
this
.
phase
(
)
)
{
return
;
}
const
{
fromLanguage
toLanguage
detectedLanguage
}
=
this
.
#
translationState
;
const
sourceLanguage
=
fromLanguage
?
fromLanguage
:
detectedLanguage
;
this
.
console
?
.
debug
(
SelectTranslationsPanel
(
{
sourceLanguage
?
sourceLanguage
:
"
?
?
"
}
-
{
toLanguage
?
toLanguage
:
"
?
?
"
}
)
state
change
(
{
previousPhase
}
=
>
{
phase
}
)
)
;
this
.
#
updatePanelUIFromState
(
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
SelectTranslationsPanelStateChanged
"
{
detail
:
{
phase
}
}
)
)
;
}
#
changeStateToClosed
(
)
{
this
.
#
changeStateTo
(
"
closed
"
/
*
retainEntries
*
/
false
)
;
}
#
changeStateToTranslating
(
)
{
const
phase
=
this
.
phase
(
)
;
if
(
phase
!
=
=
"
translatable
"
)
{
throw
new
Error
(
Invalid
state
change
(
{
phase
}
=
>
translating
)
)
;
}
this
.
#
changeStateTo
(
"
translating
"
/
*
retainEntries
*
/
true
)
;
}
#
changeStateToTranslated
(
translatedText
)
{
const
phase
=
this
.
phase
(
)
;
if
(
phase
!
=
=
"
translating
"
)
{
throw
new
Error
(
Invalid
state
change
(
{
phase
}
=
>
translated
)
)
;
}
this
.
#
changeStateTo
(
"
translated
"
/
*
retainEntries
*
/
true
{
translatedText
}
)
;
}
#
changeStateToInitFailure
(
event
screenX
screenY
sourceText
langPairPromise
)
{
this
.
#
changeStateTo
(
"
init
-
failure
"
/
*
retainEntries
*
/
true
{
event
screenX
screenY
sourceText
langPairPromise
}
)
;
}
#
changeStateToTranslationFailure
(
)
{
const
phase
=
this
.
phase
(
)
;
if
(
phase
!
=
=
"
translating
"
)
{
this
.
console
?
.
error
(
Invalid
state
change
(
{
phase
}
=
>
translation
-
failure
)
)
;
}
this
.
#
changeStateTo
(
"
translation
-
failure
"
/
*
retainEntries
*
/
true
)
;
}
#
maybeChangeStateToTranslatable
(
fromLanguage
toLanguage
)
{
const
{
fromLanguage
:
previousFromLanguage
toLanguage
:
previousToLanguage
}
=
this
.
#
translationState
;
const
langSelectionChanged
=
(
)
=
>
previousFromLanguage
!
=
=
fromLanguage
|
|
previousToLanguage
!
=
=
toLanguage
;
const
shouldTranslateEvenIfLangSelectionHasNotChanged
=
(
)
=
>
{
const
phase
=
this
.
phase
(
)
;
return
(
phase
=
=
=
"
idle
"
|
|
phase
=
=
=
"
translation
-
failure
"
)
;
}
;
if
(
fromLanguage
&
&
toLanguage
&
&
(
langSelectionChanged
(
)
|
|
shouldTranslateEvenIfLangSelectionHasNotChanged
(
)
)
)
{
this
.
#
changeStateTo
(
"
translatable
"
/
*
retainEntries
*
/
true
{
fromLanguage
toLanguage
}
)
;
}
}
#
handleCopyButtonChanges
(
phase
)
{
switch
(
phase
)
{
case
"
closed
"
:
case
"
translation
-
failure
"
:
case
"
translated
"
:
{
this
.
#
uncheckCopyButton
(
)
;
break
;
}
case
"
idle
"
:
case
"
init
-
failure
"
:
case
"
translatable
"
:
case
"
translating
"
:
case
"
unsupported
"
:
{
break
;
}
default
:
{
throw
new
Error
(
Invalid
state
change
to
'
{
phase
}
'
)
;
}
}
}
#
handleTextAreaBackgroundChanges
(
phase
)
{
const
{
textArea
}
=
this
.
elements
;
switch
(
phase
)
{
case
"
translating
"
:
{
textArea
.
classList
.
add
(
"
translating
"
)
;
break
;
}
case
"
closed
"
:
case
"
idle
"
:
case
"
init
-
failure
"
:
case
"
translation
-
failure
"
:
case
"
translatable
"
:
case
"
translated
"
:
case
"
unsupported
"
:
{
textArea
.
classList
.
remove
(
"
translating
"
)
;
break
;
}
default
:
{
throw
new
Error
(
Invalid
state
change
to
'
{
phase
}
'
)
;
}
}
}
#
handlePrimaryUIChanges
(
phase
)
{
switch
(
phase
)
{
case
"
closed
"
:
case
"
idle
"
:
{
this
.
#
displayIdlePlaceholder
(
)
;
break
;
}
case
"
init
-
failure
"
:
{
this
.
#
displayInitFailureMessage
(
)
;
break
;
}
case
"
translation
-
failure
"
:
{
this
.
#
displayTranslationFailureMessage
(
)
;
break
;
}
case
"
translatable
"
:
{
break
;
}
case
"
translating
"
:
{
this
.
#
displayTranslatingPlaceholder
(
)
;
break
;
}
case
"
translated
"
:
{
this
.
#
displayTranslatedText
(
)
;
break
;
}
case
"
unsupported
"
:
{
this
.
#
displayUnsupportedLanguageMessage
(
)
;
break
;
}
default
:
{
throw
new
Error
(
Invalid
state
change
to
'
{
phase
}
'
)
;
}
}
}
#
shouldContinueTranslation
(
translationId
fromLanguage
toLanguage
)
{
return
(
this
.
#
isOpen
(
)
&
&
translationId
=
=
=
this
.
#
translationId
&
&
this
.
#
isSelectedLangPair
(
fromLanguage
toLanguage
)
)
;
}
#
displayIdlePlaceholder
(
)
{
this
.
#
showMainContent
(
)
;
const
{
textArea
}
=
SelectTranslationsPanel
.
elements
;
textArea
.
value
=
this
.
#
idlePlaceholderText
;
this
.
#
updateTextDirection
(
)
;
this
.
#
updateConditionalUIEnabledState
(
)
;
this
.
#
maybeFocusMenuList
(
)
;
}
#
displayTranslatingPlaceholder
(
)
{
this
.
#
showMainContent
(
)
;
const
{
textArea
}
=
SelectTranslationsPanel
.
elements
;
textArea
.
value
=
this
.
#
translatingPlaceholderText
;
this
.
#
updateTextDirection
(
)
;
this
.
#
updateConditionalUIEnabledState
(
)
;
this
.
#
indicateTranslatedTextArea
(
{
overflow
:
"
hidden
"
}
)
;
}
#
displayTranslatedText
(
)
{
this
.
#
showMainContent
(
)
;
const
{
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
const
{
textArea
}
=
SelectTranslationsPanel
.
elements
;
textArea
.
value
=
this
.
getTranslatedText
(
)
;
this
.
#
updateTextDirection
(
toLanguage
)
;
this
.
#
updateConditionalUIEnabledState
(
)
;
this
.
#
indicateTranslatedTextArea
(
{
overflow
:
"
auto
"
}
)
;
this
.
#
maybeEnableTextAreaResizer
(
)
;
const
window
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
window
.
A11yUtils
.
announce
(
{
id
:
"
select
-
translations
-
panel
-
translation
-
complete
-
announcement
"
}
)
;
}
#
setPanelElementAttributes
(
{
makeHidden
=
[
]
makeVisible
=
[
]
}
)
{
for
(
const
element
of
makeHidden
)
{
element
.
hidden
=
true
;
}
for
(
const
element
of
makeVisible
)
{
element
.
hidden
=
false
;
}
}
#
updateConditionalUIEnabledState
(
)
{
const
{
fromLanguage
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
const
{
copyButton
textArea
translateButton
translateFullPageButton
tryAnotherSourceMenuList
}
=
this
.
elements
;
const
invalidLangPairSelected
=
!
fromLanguage
|
|
!
toLanguage
;
const
isTranslating
=
this
.
phase
(
)
=
=
=
"
translating
"
;
textArea
.
disabled
=
invalidLangPairSelected
;
copyButton
.
disabled
=
invalidLangPairSelected
|
|
isTranslating
;
translateButton
.
disabled
=
!
tryAnotherSourceMenuList
.
value
;
translateFullPageButton
.
disabled
=
invalidLangPairSelected
|
|
fromLanguage
=
=
=
toLanguage
|
|
this
.
#
isFullPageTranslationsRestrictedForPage
;
}
#
updatePanelUIFromState
(
)
{
const
phase
=
this
.
phase
(
)
;
this
.
#
handlePrimaryUIChanges
(
phase
)
;
this
.
#
handleCopyButtonChanges
(
phase
)
;
this
.
#
handleTextAreaBackgroundChanges
(
phase
)
;
this
.
#
mostRecentUIPhase
=
phase
;
}
#
showMainContent
(
)
{
const
{
cancelButton
copyButton
doneButtonPrimary
doneButtonSecondary
initFailureContent
mainContent
unsupportedLanguageContent
textArea
translateButton
translateFullPageButton
translationFailureMessageBar
tryAgainButton
}
=
this
.
elements
;
this
.
#
setPanelElementAttributes
(
{
makeHidden
:
[
cancelButton
doneButtonSecondary
initFailureContent
translateButton
translationFailureMessageBar
tryAgainButton
unsupportedLanguageContent
.
.
.
(
this
.
#
isFullPageTranslationsRestrictedForPage
?
[
translateFullPageButton
]
:
[
]
)
]
makeVisible
:
[
mainContent
copyButton
doneButtonPrimary
textArea
.
.
.
(
this
.
#
isFullPageTranslationsRestrictedForPage
?
[
]
:
[
translateFullPageButton
]
)
]
}
)
;
}
#
showUnsupportedLanguageContent
(
)
{
const
{
cancelButton
copyButton
doneButtonPrimary
doneButtonSecondary
initFailureContent
mainContent
unsupportedLanguageContent
translateButton
translateFullPageButton
tryAgainButton
}
=
this
.
elements
;
this
.
#
setPanelElementAttributes
(
{
makeHidden
:
[
cancelButton
doneButtonPrimary
copyButton
initFailureContent
mainContent
translateFullPageButton
tryAgainButton
]
makeVisible
:
[
doneButtonSecondary
translateButton
unsupportedLanguageContent
]
}
)
;
}
#
displayInitFailureMessage
(
)
{
if
(
this
.
#
mostRecentUIPhase
!
=
=
"
init
-
failure
"
)
{
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onInitializationFailureMessage
(
)
;
}
const
{
cancelButton
copyButton
doneButtonPrimary
doneButtonSecondary
initFailureContent
mainContent
unsupportedLanguageContent
translateButton
translateFullPageButton
tryAgainButton
}
=
this
.
elements
;
this
.
#
setPanelElementAttributes
(
{
makeHidden
:
[
doneButtonPrimary
doneButtonSecondary
copyButton
mainContent
translateButton
translateFullPageButton
unsupportedLanguageContent
]
makeVisible
:
[
initFailureContent
cancelButton
tryAgainButton
]
}
)
;
tryAgainButton
.
setAttribute
(
"
aria
-
describedby
"
"
select
-
translations
-
panel
-
init
-
failure
-
message
-
bar
"
)
;
tryAgainButton
.
focus
(
{
focusVisible
:
false
}
)
;
}
#
displayTranslationFailureMessage
(
)
{
if
(
this
.
#
mostRecentUIPhase
!
=
=
"
translation
-
failure
"
)
{
const
{
fromLanguage
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onTranslationFailureMessage
(
{
fromLanguage
toLanguage
}
)
;
}
const
{
cancelButton
copyButton
doneButtonPrimary
doneButtonSecondary
initFailureContent
mainContent
textArea
translateButton
translateFullPageButton
translationFailureMessageBar
tryAgainButton
unsupportedLanguageContent
}
=
this
.
elements
;
this
.
#
setPanelElementAttributes
(
{
makeHidden
:
[
doneButtonPrimary
doneButtonSecondary
copyButton
initFailureContent
translateButton
translateFullPageButton
textArea
unsupportedLanguageContent
]
makeVisible
:
[
cancelButton
mainContent
translationFailureMessageBar
tryAgainButton
]
}
)
;
tryAgainButton
.
setAttribute
(
"
aria
-
describedby
"
"
select
-
translations
-
panel
-
translation
-
failure
-
message
-
bar
"
)
;
tryAgainButton
.
focus
(
{
focusVisible
:
false
}
)
;
}
#
displayUnsupportedLanguageMessage
(
)
{
const
{
detectedLanguage
}
=
this
.
#
translationState
;
if
(
this
.
#
mostRecentUIPhase
!
=
=
"
unsupported
"
)
{
const
{
docLangTag
}
=
this
.
#
getLanguageInfo
(
)
;
TranslationsParent
.
telemetry
(
)
.
selectTranslationsPanel
(
)
.
onUnsupportedLanguageMessage
(
{
docLangTag
detectedLanguage
}
)
;
}
const
{
unsupportedLanguageMessageBar
tryAnotherSourceMenuList
}
=
this
.
elements
;
const
displayNames
=
new
Services
.
intl
.
DisplayNames
(
undefined
{
type
:
"
language
"
}
)
;
try
{
const
language
=
displayNames
.
of
(
detectedLanguage
)
;
if
(
language
)
{
document
.
l10n
.
setAttributes
(
unsupportedLanguageMessageBar
"
select
-
translations
-
panel
-
unsupported
-
language
-
message
-
known
"
{
language
}
)
;
}
else
{
throw
new
Error
(
)
;
}
}
catch
{
document
.
l10n
.
setAttributes
(
unsupportedLanguageMessageBar
"
select
-
translations
-
panel
-
unsupported
-
language
-
message
-
unknown
"
)
;
}
this
.
#
updateConditionalUIEnabledState
(
)
;
this
.
#
showUnsupportedLanguageContent
(
)
;
this
.
#
maybeFocusMenuList
(
tryAnotherSourceMenuList
)
;
}
#
updateTextDirection
(
langTag
)
{
const
{
textArea
}
=
this
.
elements
;
if
(
langTag
)
{
const
scriptDirection
=
Services
.
intl
.
getScriptDirection
(
langTag
)
;
textArea
.
setAttribute
(
"
dir
"
scriptDirection
)
;
}
else
{
textArea
.
removeAttribute
(
"
dir
"
)
;
}
}
async
#
requestTranslationsPort
(
fromLanguage
toLanguage
)
{
const
innerWindowId
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
innerWindowID
;
if
(
!
innerWindowId
)
{
return
undefined
;
}
const
port
=
await
TranslationsParent
.
requestTranslationsPort
(
innerWindowId
fromLanguage
toLanguage
)
;
return
port
;
}
async
#
createTranslator
(
fromLanguage
toLanguage
)
{
this
.
console
?
.
log
(
Creating
new
Translator
(
{
fromLanguage
}
-
{
toLanguage
}
)
)
;
const
translator
=
await
Translator
.
create
(
fromLanguage
toLanguage
{
allowSameLanguage
:
true
requestTranslationsPort
:
this
.
#
requestTranslationsPort
}
)
;
return
translator
;
}
#
maybeRequestTranslation
(
)
{
if
(
this
.
#
isClosed
(
)
)
{
return
;
}
const
{
fromLanguage
toLanguage
}
=
this
.
#
getSelectedLanguagePair
(
)
;
this
.
#
maybeChangeStateToTranslatable
(
fromLanguage
toLanguage
)
;
if
(
this
.
phase
(
)
!
=
=
"
translatable
"
)
{
return
;
}
const
{
docLangTag
topPreferredLanguage
}
=
this
.
#
getLanguageInfo
(
)
;
const
sourceText
=
this
.
getSourceText
(
)
;
const
translationId
=
+
+
this
.
#
translationId
;
this
.
#
createTranslator
(
fromLanguage
toLanguage
)
.
then
(
translator
=
>
{
if
(
this
.
#
shouldContinueTranslation
(
translationId
fromLanguage
toLanguage
)
)
{
this
.
#
changeStateToTranslating
(
)
;
return
translator
.
translate
(
this
.
getSourceText
(
)
)
;
}
return
null
;
}
)
.
then
(
translatedText
=
>
{
if
(
translatedText
&
&
this
.
#
shouldContinueTranslation
(
translationId
fromLanguage
toLanguage
)
)
{
this
.
#
changeStateToTranslated
(
translatedText
)
;
}
}
)
.
catch
(
error
=
>
{
this
.
console
?
.
error
(
error
)
;
this
.
#
changeStateToTranslationFailure
(
)
;
}
)
;
try
{
if
(
!
this
.
#
sourceTextWordCount
)
{
this
.
#
sourceTextWordCount
=
TranslationsParent
.
countWords
(
fromLanguage
sourceText
)
;
}
}
catch
(
error
)
{
this
.
console
?
.
warn
(
error
)
;
}
TranslationsParent
.
telemetry
(
)
.
onTranslate
(
{
docLangTag
fromLanguage
toLanguage
topPreferredLanguage
autoTranslate
:
false
requestTarget
:
"
select
"
sourceTextCodeUnits
:
sourceText
.
length
sourceTextWordCount
:
this
.
#
sourceTextWordCount
}
)
;
}
#
maybeTranslateOnEvents
(
eventTypes
target
)
{
if
(
!
target
.
translationListenerCallbacks
)
{
target
.
translationListenerCallbacks
=
[
]
;
}
if
(
target
.
translationListenerCallbacks
.
length
=
=
=
0
)
{
for
(
const
eventType
of
eventTypes
)
{
let
callback
;
switch
(
eventType
)
{
case
"
focus
"
:
case
"
popuphidden
"
:
{
callback
=
(
)
=
>
{
this
.
#
maybeRequestTranslation
(
)
;
}
;
break
;
}
case
"
keypress
"
:
{
callback
=
event
=
>
{
if
(
event
.
key
=
=
=
"
Enter
"
)
{
this
.
#
maybeRequestTranslation
(
)
;
}
}
;
break
;
}
default
:
{
throw
new
Error
(
Invalid
translation
event
type
given
:
'
{
eventType
}
)
;
}
}
target
.
addEventListener
(
eventType
callback
)
;
target
.
translationListenerCallbacks
.
push
(
{
eventType
callback
}
)
;
}
}
}
#
removeActiveTranslationListeners
(
)
{
const
{
fromMenuList
fromMenuPopup
textArea
toMenuList
toMenuPopup
}
=
SelectTranslationsPanel
.
elements
;
this
.
#
removeTranslationListenersFrom
(
fromMenuList
)
;
this
.
#
removeTranslationListenersFrom
(
fromMenuPopup
)
;
this
.
#
removeTranslationListenersFrom
(
textArea
)
;
this
.
#
removeTranslationListenersFrom
(
toMenuList
)
;
this
.
#
removeTranslationListenersFrom
(
toMenuPopup
)
;
}
#
removeTranslationListenersFrom
(
target
)
{
if
(
!
target
.
translationListenerCallbacks
)
{
return
;
}
for
(
const
{
eventType
callback
}
of
target
.
translationListenerCallbacks
)
{
target
.
removeEventListener
(
eventType
callback
)
;
}
target
.
translationListenerCallbacks
=
[
]
;
}
}
)
(
)
;
