ChromeUtils
.
defineESModuleGetters
(
this
{
PageActions
:
"
resource
:
/
/
/
modules
/
PageActions
.
sys
.
mjs
"
TranslationsTelemetry
:
"
chrome
:
/
/
browser
/
content
/
translations
/
TranslationsTelemetry
.
sys
.
mjs
"
TranslationsPanelShared
:
"
chrome
:
/
/
browser
/
content
/
translations
/
TranslationsPanelShared
.
sys
.
mjs
"
}
)
;
const
PageAction
=
Object
.
freeze
(
{
NO_CHANGE
:
"
NO_CHANGE
"
RESTORE_PAGE
:
"
RESTORE_PAGE
"
TRANSLATE_PAGE
:
"
TRANSLATE_PAGE
"
CLOSE_PANEL
:
"
CLOSE_PANEL
"
}
)
;
class
CheckboxPageAction
{
#
translationsActive
=
false
;
#
alwaysTranslateLanguage
=
false
;
#
neverTranslateLanguage
=
false
;
#
neverTranslateSite
=
false
;
constructor
(
translationsActive
alwaysTranslateLanguage
neverTranslateLanguage
neverTranslateSite
)
{
this
.
#
translationsActive
=
translationsActive
;
this
.
#
alwaysTranslateLanguage
=
alwaysTranslateLanguage
;
this
.
#
neverTranslateLanguage
=
neverTranslateLanguage
;
this
.
#
neverTranslateSite
=
neverTranslateSite
;
}
static
#
computeState
(
translationsActive
alwaysTranslateLanguage
neverTranslateLanguage
neverTranslateSite
)
{
return
(
(
translationsActive
<
<
3
)
|
(
alwaysTranslateLanguage
<
<
2
)
|
(
neverTranslateLanguage
<
<
1
)
|
neverTranslateSite
)
;
}
#
state
(
)
{
return
CheckboxPageAction
.
#
computeState
(
Number
(
this
.
#
translationsActive
)
Number
(
this
.
#
alwaysTranslateLanguage
)
Number
(
this
.
#
neverTranslateLanguage
)
Number
(
this
.
#
neverTranslateSite
)
)
;
}
alwaysTranslateLanguage
(
)
{
switch
(
this
.
#
state
(
)
)
{
case
CheckboxPageAction
.
#
computeState
(
1
1
0
1
)
:
case
CheckboxPageAction
.
#
computeState
(
1
1
0
0
)
:
return
PageAction
.
RESTORE_PAGE
;
case
CheckboxPageAction
.
#
computeState
(
0
0
1
0
)
:
case
CheckboxPageAction
.
#
computeState
(
0
0
0
0
)
:
return
PageAction
.
TRANSLATE_PAGE
;
}
return
PageAction
.
NO_CHANGE
;
}
neverTranslateLanguage
(
)
{
switch
(
this
.
#
state
(
)
)
{
case
CheckboxPageAction
.
#
computeState
(
1
1
0
1
)
:
case
CheckboxPageAction
.
#
computeState
(
1
1
0
0
)
:
case
CheckboxPageAction
.
#
computeState
(
1
0
0
1
)
:
case
CheckboxPageAction
.
#
computeState
(
1
0
0
0
)
:
return
PageAction
.
RESTORE_PAGE
;
case
CheckboxPageAction
.
#
computeState
(
0
1
0
0
)
:
case
CheckboxPageAction
.
#
computeState
(
0
0
0
1
)
:
case
CheckboxPageAction
.
#
computeState
(
0
1
0
1
)
:
case
CheckboxPageAction
.
#
computeState
(
0
0
0
0
)
:
return
PageAction
.
CLOSE_PANEL
;
}
return
PageAction
.
NO_CHANGE
;
}
neverTranslateSite
(
)
{
switch
(
this
.
#
state
(
)
)
{
case
CheckboxPageAction
.
#
computeState
(
1
1
0
0
)
:
case
CheckboxPageAction
.
#
computeState
(
1
0
1
0
)
:
case
CheckboxPageAction
.
#
computeState
(
1
0
0
0
)
:
return
PageAction
.
RESTORE_PAGE
;
case
CheckboxPageAction
.
#
computeState
(
0
1
0
1
)
:
return
PageAction
.
TRANSLATE_PAGE
;
case
CheckboxPageAction
.
#
computeState
(
0
0
1
0
)
:
case
CheckboxPageAction
.
#
computeState
(
0
1
0
0
)
:
case
CheckboxPageAction
.
#
computeState
(
0
0
0
0
)
:
return
PageAction
.
CLOSE_PANEL
;
}
return
PageAction
.
NO_CHANGE
;
}
}
var
FullPageTranslationsPanel
=
new
(
class
{
#
console
;
detectedLanguages
=
null
;
get
console
(
)
{
if
(
!
this
.
#
console
)
{
try
{
this
.
#
console
=
console
.
createInstance
(
{
maxLogLevelPref
:
"
browser
.
translations
.
logLevel
"
prefix
:
"
Translations
"
}
)
;
}
catch
{
}
}
return
this
.
#
console
;
}
#
isPopupOpen
=
false
;
#
lazyElements
;
get
elements
(
)
{
if
(
!
this
.
#
lazyElements
)
{
const
wrapper
=
document
.
getElementById
(
"
template
-
translations
-
panel
"
)
;
const
panel
=
wrapper
.
content
.
firstElementChild
;
wrapper
.
replaceWith
(
wrapper
.
content
)
;
panel
.
addEventListener
(
"
command
"
this
)
;
panel
.
addEventListener
(
"
click
"
this
)
;
panel
.
addEventListener
(
"
popupshown
"
this
)
;
panel
.
addEventListener
(
"
popuphidden
"
this
)
;
const
settingsButton
=
document
.
getElementById
(
"
translations
-
panel
-
settings
"
)
;
for
(
const
header
of
panel
.
querySelectorAll
(
"
.
panel
-
header
"
)
)
{
if
(
header
.
contains
(
settingsButton
)
)
{
continue
;
}
const
settingsButtonClone
=
settingsButton
.
cloneNode
(
true
)
;
settingsButtonClone
.
removeAttribute
(
"
id
"
)
;
header
.
appendChild
(
settingsButtonClone
)
;
}
this
.
#
lazyElements
=
{
panel
settingsButton
}
;
TranslationsPanelShared
.
defineLazyElements
(
document
this
.
#
lazyElements
{
alwaysTranslateLanguageMenuItem
:
"
.
always
-
translate
-
language
-
menuitem
"
appMenuButton
:
"
PanelUI
-
menu
-
button
"
cancelButton
:
"
full
-
page
-
translations
-
panel
-
cancel
"
changeSourceLanguageButton
:
"
full
-
page
-
translations
-
panel
-
change
-
source
-
language
"
dismissErrorButton
:
"
full
-
page
-
translations
-
panel
-
dismiss
-
error
"
error
:
"
full
-
page
-
translations
-
panel
-
error
"
errorMessage
:
"
full
-
page
-
translations
-
panel
-
error
-
message
"
errorMessageHint
:
"
full
-
page
-
translations
-
panel
-
error
-
message
-
hint
"
errorHintAction
:
"
full
-
page
-
translations
-
panel
-
translate
-
hint
-
action
"
fromLabel
:
"
full
-
page
-
translations
-
panel
-
from
-
label
"
fromMenuList
:
"
full
-
page
-
translations
-
panel
-
from
"
fromMenuPopup
:
"
full
-
page
-
translations
-
panel
-
from
-
menupopup
"
header
:
"
full
-
page
-
translations
-
panel
-
header
"
intro
:
"
full
-
page
-
translations
-
panel
-
intro
"
introLearnMoreLink
:
"
full
-
page
-
translations
-
panel
-
intro
-
learn
-
more
-
link
"
langSelection
:
"
full
-
page
-
translations
-
panel
-
lang
-
selection
"
manageLanguagesMenuItem
:
"
.
manage
-
languages
-
menuitem
"
multiview
:
"
full
-
page
-
translations
-
panel
-
multiview
"
neverTranslateLanguageMenuItem
:
"
.
never
-
translate
-
language
-
menuitem
"
neverTranslateSiteMenuItem
:
"
.
never
-
translate
-
site
-
menuitem
"
restoreButton
:
"
full
-
page
-
translations
-
panel
-
restore
-
button
"
toLabel
:
"
full
-
page
-
translations
-
panel
-
to
-
label
"
toMenuList
:
"
full
-
page
-
translations
-
panel
-
to
"
toMenuPopup
:
"
full
-
page
-
translations
-
panel
-
to
-
menupopup
"
translateButton
:
"
full
-
page
-
translations
-
panel
-
translate
"
unsupportedHeader
:
"
full
-
page
-
translations
-
panel
-
unsupported
-
language
-
header
"
unsupportedHint
:
"
full
-
page
-
translations
-
panel
-
error
-
unsupported
-
hint
"
unsupportedLearnMoreLink
:
"
full
-
page
-
translations
-
panel
-
unsupported
-
learn
-
more
-
link
"
}
)
;
}
return
this
.
#
lazyElements
;
}
#
lazyButtonElements
=
null
;
/
*
*
*
When
accessing
this
.
elements
the
first
time
it
de
-
lazifies
the
custom
components
*
that
are
needed
for
the
popup
.
Avoid
that
by
having
a
second
element
lookup
*
just
for
modifying
the
button
.
*
/
get
buttonElements
(
)
{
if
(
!
this
.
#
lazyButtonElements
)
{
this
.
#
lazyButtonElements
=
{
button
:
document
.
getElementById
(
"
translations
-
button
"
)
buttonLocale
:
document
.
getElementById
(
"
translations
-
button
-
locale
"
)
buttonCircleArrows
:
document
.
getElementById
(
"
translations
-
button
-
circle
-
arrows
"
)
}
;
}
return
this
.
#
lazyButtonElements
;
}
/
*
*
*
Cache
the
last
command
used
for
error
hints
so
that
it
can
be
later
removed
.
*
/
#
lastHintCommand
=
null
;
/
*
*
*
param
{
object
}
options
*
param
{
string
}
options
.
message
-
l10n
id
*
param
{
string
}
options
.
hint
-
l10n
id
*
param
{
string
}
options
.
actionText
-
l10n
id
*
param
{
Function
}
options
.
actionCommand
-
The
action
to
perform
.
*
/
#
showError
(
{
message
hint
actionText
:
hintCommandText
actionCommand
:
hintCommand
}
)
{
const
{
error
errorMessage
errorMessageHint
errorHintAction
intro
}
=
this
.
elements
;
error
.
hidden
=
false
;
intro
.
hidden
=
true
;
document
.
l10n
.
setAttributes
(
errorMessage
message
)
;
if
(
hint
)
{
errorMessageHint
.
hidden
=
false
;
document
.
l10n
.
setAttributes
(
errorMessageHint
hint
)
;
}
else
{
errorMessageHint
.
hidden
=
true
;
}
if
(
hintCommand
&
&
hintCommandText
)
{
errorHintAction
.
removeEventListener
(
"
command
"
this
.
#
lastHintCommand
)
;
this
.
#
lastHintCommand
=
hintCommand
;
errorHintAction
.
addEventListener
(
"
command
"
hintCommand
)
;
errorHintAction
.
hidden
=
false
;
document
.
l10n
.
setAttributes
(
errorHintAction
hintCommandText
)
;
}
else
{
errorHintAction
.
hidden
=
true
;
}
}
/
*
*
*
Fetches
the
language
tags
for
the
document
and
the
user
and
caches
the
results
*
Use
#
getCachedDetectedLanguages
when
the
lang
tags
do
not
need
to
be
re
-
fetched
.
*
This
requires
a
bit
of
work
to
do
so
prefer
the
cached
version
when
possible
.
*
*
returns
{
Promise
<
LangTags
>
}
*
/
async
#
fetchDetectedLanguages
(
)
{
this
.
detectedLanguages
=
await
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
.
getDetectedLanguages
(
)
;
return
this
.
detectedLanguages
;
}
/
*
*
*
If
the
detected
language
tags
have
been
retrieved
previously
return
the
cached
*
version
.
Otherwise
do
a
fresh
lookup
of
the
document
'
s
language
tag
.
*
*
returns
{
Promise
<
LangTags
>
}
*
/
async
#
getCachedDetectedLanguages
(
)
{
if
(
!
this
.
detectedLanguages
)
{
return
this
.
#
fetchDetectedLanguages
(
)
;
}
return
this
.
detectedLanguages
;
}
/
*
*
*
Builds
the
<
menulist
>
of
languages
for
both
the
"
from
"
and
"
to
"
.
This
can
be
*
called
every
time
the
popup
is
shown
as
it
will
retry
when
there
is
an
error
*
(
such
as
a
network
error
)
or
be
a
noop
if
it
'
s
already
initialized
.
*
/
async
#
ensureLangListsBuilt
(
)
{
try
{
await
TranslationsPanelShared
.
ensureLangListsBuilt
(
document
this
)
;
}
catch
(
error
)
{
this
.
console
?
.
error
(
error
)
;
}
}
/
*
*
*
Reactively
sets
the
views
based
on
the
async
state
changes
of
the
engine
and
*
other
component
state
changes
.
*
*
param
{
TranslationsLanguageState
}
languageState
*
/
#
updateViewFromTranslationStatus
(
languageState
=
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
.
languageState
)
{
const
{
translateButton
toMenuList
fromMenuList
header
cancelButton
}
=
this
.
elements
;
const
{
requestedTranslationPair
isEngineReady
}
=
languageState
;
if
(
requestedTranslationPair
&
&
!
isEngineReady
&
&
toMenuList
.
value
=
=
=
requestedTranslationPair
.
toLanguage
&
&
fromMenuList
.
value
=
=
=
requestedTranslationPair
.
fromLanguage
)
{
/
/
A
translation
has
been
requested
but
is
not
ready
yet
.
document
.
l10n
.
setAttributes
(
translateButton
"
translations
-
panel
-
translate
-
button
-
loading
"
)
;
translateButton
.
disabled
=
true
;
cancelButton
.
hidden
=
false
;
this
.
updateUIForReTranslation
(
false
/
*
isReTranslation
*
/
)
;
}
else
{
document
.
l10n
.
setAttributes
(
translateButton
"
translations
-
panel
-
translate
-
button
"
)
;
translateButton
.
disabled
=
toMenuList
.
value
=
=
=
fromMenuList
.
value
|
|
!
toMenuList
.
value
|
|
!
fromMenuList
.
value
|
|
(
requestedTranslationPair
&
&
requestedTranslationPair
.
fromLanguage
=
=
=
fromMenuList
.
value
&
&
requestedTranslationPair
.
toLanguage
=
=
=
toMenuList
.
value
)
;
}
if
(
requestedTranslationPair
&
&
isEngineReady
)
{
const
{
fromLanguage
toLanguage
}
=
requestedTranslationPair
;
const
displayNames
=
new
Services
.
intl
.
DisplayNames
(
undefined
{
type
:
"
language
"
}
)
;
cancelButton
.
hidden
=
true
;
this
.
updateUIForReTranslation
(
true
)
;
document
.
l10n
.
setAttributes
(
header
"
translations
-
panel
-
revisit
-
header
"
{
fromLanguage
:
displayNames
.
of
(
fromLanguage
)
toLanguage
:
displayNames
.
of
(
toLanguage
)
}
)
;
}
else
{
document
.
l10n
.
setAttributes
(
header
"
translations
-
panel
-
header
"
)
;
}
}
updateUIForReTranslation
(
isReTranslation
)
{
const
{
restoreButton
fromLabel
fromMenuList
toLabel
}
=
this
.
elements
;
restoreButton
.
hidden
=
!
isReTranslation
;
fromLabel
.
hidden
=
isReTranslation
;
fromMenuList
.
hidden
=
isReTranslation
;
if
(
isReTranslation
)
{
fromLabel
.
style
.
marginBlockStart
=
"
"
;
toLabel
.
style
.
marginBlockStart
=
0
;
}
else
{
fromLabel
.
style
.
marginBlockStart
=
0
;
toLabel
.
style
.
marginBlockStart
=
"
"
;
}
}
#
isShowingDefaultView
(
)
{
if
(
!
this
.
#
lazyElements
)
{
return
false
;
}
const
{
multiview
}
=
this
.
elements
;
return
(
multiview
.
getAttribute
(
"
mainViewId
"
)
=
=
=
"
full
-
page
-
translations
-
panel
-
view
-
default
"
)
;
}
async
#
showDefaultView
(
actor
force
=
false
)
{
const
{
fromMenuList
multiview
panel
error
toMenuList
translateButton
langSelection
intro
header
}
=
this
.
elements
;
this
.
#
updateViewFromTranslationStatus
(
)
;
intro
.
hidden
=
true
;
if
(
TranslationsPanelShared
.
getLangListsInitState
(
this
)
=
=
=
"
error
"
)
{
const
{
cancelButton
errorHintAction
}
=
this
.
elements
;
this
.
#
showError
(
{
message
:
"
translations
-
panel
-
error
-
load
-
languages
"
hint
:
"
translations
-
panel
-
error
-
load
-
languages
-
hint
"
actionText
:
"
translations
-
panel
-
error
-
load
-
languages
-
hint
-
button
"
actionCommand
:
(
)
=
>
this
.
#
reloadLangList
(
actor
)
}
)
;
translateButton
.
disabled
=
true
;
this
.
updateUIForReTranslation
(
false
)
;
cancelButton
.
hidden
=
false
;
langSelection
.
hidden
=
true
;
errorHintAction
.
disabled
=
false
;
return
;
}
fromMenuList
.
value
=
"
"
;
error
.
hidden
=
true
;
langSelection
.
hidden
=
false
;
const
{
userLangTag
docLangTag
isDocLangTagSupported
}
=
await
this
.
#
fetchDetectedLanguages
(
)
.
then
(
langTags
=
>
langTags
?
?
{
}
)
;
if
(
isDocLangTagSupported
|
|
force
)
{
const
{
cancelButton
}
=
this
.
elements
;
if
(
isDocLangTagSupported
)
{
fromMenuList
.
value
=
docLangTag
?
?
"
"
;
}
else
{
fromMenuList
.
value
=
"
"
;
}
if
(
userLangTag
&
&
userLangTag
!
=
=
docLangTag
)
{
toMenuList
.
value
=
userLangTag
;
}
else
{
toMenuList
.
value
=
await
TranslationsParent
.
getTopPreferredSupportedToLang
(
{
excludeLangTags
:
[
docLangTag
fromMenuList
.
value
]
}
)
;
}
if
(
fromMenuList
.
value
=
=
=
toMenuList
.
value
)
{
toMenuList
.
value
=
"
"
;
}
this
.
onChangeLanguages
(
)
;
this
.
updateUIForReTranslation
(
false
)
;
cancelButton
.
hidden
=
false
;
multiview
.
setAttribute
(
"
mainViewId
"
"
full
-
page
-
translations
-
panel
-
view
-
default
"
)
;
if
(
!
this
.
_hasShownPanel
)
{
actor
.
firstShowUriSpec
=
gBrowser
.
currentURI
.
spec
;
}
if
(
this
.
_hasShownPanel
&
&
gBrowser
.
currentURI
.
spec
!
=
=
actor
.
firstShowUriSpec
)
{
document
.
l10n
.
setAttributes
(
header
"
translations
-
panel
-
header
"
)
;
actor
.
firstShowUriSpec
=
null
;
intro
.
hidden
=
true
;
}
else
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
translations
.
panelShown
"
true
)
;
intro
.
hidden
=
false
;
document
.
l10n
.
setAttributes
(
header
"
translations
-
panel
-
intro
-
header
"
)
;
}
}
else
{
const
{
unsupportedHint
}
=
this
.
elements
;
multiview
.
setAttribute
(
"
mainViewId
"
"
full
-
page
-
translations
-
panel
-
view
-
unsupported
-
language
"
)
;
let
language
;
if
(
docLangTag
)
{
const
displayNames
=
new
Intl
.
DisplayNames
(
undefined
{
type
:
"
language
"
fallback
:
"
none
"
}
)
;
language
=
displayNames
.
of
(
docLangTag
)
;
}
if
(
language
)
{
document
.
l10n
.
setAttributes
(
unsupportedHint
"
translations
-
panel
-
error
-
unsupported
-
hint
-
known
"
{
language
}
)
;
}
else
{
document
.
l10n
.
setAttributes
(
unsupportedHint
"
translations
-
panel
-
error
-
unsupported
-
hint
-
unknown
"
)
;
}
}
panel
.
addEventListener
(
"
ViewShown
"
(
)
=
>
{
if
(
!
fromMenuList
.
value
)
{
fromMenuList
.
focus
(
)
;
}
if
(
!
toMenuList
.
value
)
{
toMenuList
.
focus
(
)
;
}
}
{
once
:
true
}
)
;
}
async
#
updateSettingsMenuLanguageCheckboxStates
(
)
{
const
langTags
=
await
this
.
#
getCachedDetectedLanguages
(
)
;
const
{
docLangTag
isDocLangTagSupported
}
=
langTags
;
const
{
panel
}
=
this
.
elements
;
const
alwaysTranslateMenuItems
=
panel
.
ownerDocument
.
querySelectorAll
(
"
.
always
-
translate
-
language
-
menuitem
"
)
;
const
neverTranslateMenuItems
=
panel
.
ownerDocument
.
querySelectorAll
(
"
.
never
-
translate
-
language
-
menuitem
"
)
;
const
alwaysOfferTranslationsMenuItems
=
panel
.
ownerDocument
.
querySelectorAll
(
"
.
always
-
offer
-
translations
-
menuitem
"
)
;
const
alwaysOfferTranslations
=
TranslationsParent
.
shouldAlwaysOfferTranslations
(
)
;
const
alwaysTranslateLanguage
=
TranslationsParent
.
shouldAlwaysTranslateLanguage
(
langTags
)
;
const
neverTranslateLanguage
=
TranslationsParent
.
shouldNeverTranslateLanguage
(
docLangTag
)
;
const
shouldDisable
=
!
docLangTag
|
|
!
isDocLangTagSupported
|
|
docLangTag
=
=
=
(
await
TranslationsParent
.
getTopPreferredSupportedToLang
(
)
)
;
for
(
const
menuitem
of
alwaysOfferTranslationsMenuItems
)
{
menuitem
.
setAttribute
(
"
checked
"
alwaysOfferTranslations
?
"
true
"
:
"
false
"
)
;
}
for
(
const
menuitem
of
alwaysTranslateMenuItems
)
{
menuitem
.
setAttribute
(
"
checked
"
alwaysTranslateLanguage
?
"
true
"
:
"
false
"
)
;
menuitem
.
disabled
=
shouldDisable
;
}
for
(
const
menuitem
of
neverTranslateMenuItems
)
{
menuitem
.
setAttribute
(
"
checked
"
neverTranslateLanguage
?
"
true
"
:
"
false
"
)
;
menuitem
.
disabled
=
shouldDisable
;
}
}
async
#
updateSettingsMenuSiteCheckboxStates
(
)
{
const
{
panel
}
=
this
.
elements
;
const
neverTranslateSiteMenuItems
=
panel
.
ownerDocument
.
querySelectorAll
(
"
.
never
-
translate
-
site
-
menuitem
"
)
;
const
neverTranslateSite
=
await
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
.
shouldNeverTranslateSite
(
)
;
for
(
const
menuitem
of
neverTranslateSiteMenuItems
)
{
menuitem
.
setAttribute
(
"
checked
"
neverTranslateSite
?
"
true
"
:
"
false
"
)
;
}
}
async
#
populateSettingsMenuItems
(
)
{
const
{
docLangTag
}
=
await
this
.
#
getCachedDetectedLanguages
(
)
;
const
{
panel
}
=
this
.
elements
;
const
alwaysTranslateMenuItems
=
panel
.
ownerDocument
.
querySelectorAll
(
"
.
always
-
translate
-
language
-
menuitem
"
)
;
const
neverTranslateMenuItems
=
panel
.
ownerDocument
.
querySelectorAll
(
"
.
never
-
translate
-
language
-
menuitem
"
)
;
let
docLangDisplayName
;
if
(
docLangTag
)
{
const
displayNames
=
new
Services
.
intl
.
DisplayNames
(
undefined
{
type
:
"
language
"
fallback
:
"
none
"
}
)
;
docLangDisplayName
=
displayNames
.
of
(
docLangTag
)
;
}
for
(
const
menuitem
of
alwaysTranslateMenuItems
)
{
if
(
docLangDisplayName
)
{
document
.
l10n
.
setAttributes
(
menuitem
"
translations
-
panel
-
settings
-
always
-
translate
-
language
"
{
language
:
docLangDisplayName
}
)
;
}
else
{
document
.
l10n
.
setAttributes
(
menuitem
"
translations
-
panel
-
settings
-
always
-
translate
-
unknown
-
language
"
)
;
}
}
for
(
const
menuitem
of
neverTranslateMenuItems
)
{
if
(
docLangDisplayName
)
{
document
.
l10n
.
setAttributes
(
menuitem
"
translations
-
panel
-
settings
-
never
-
translate
-
language
"
{
language
:
docLangDisplayName
}
)
;
}
else
{
document
.
l10n
.
setAttributes
(
menuitem
"
translations
-
panel
-
settings
-
never
-
translate
-
unknown
-
language
"
)
;
}
}
await
Promise
.
all
(
[
this
.
#
updateSettingsMenuLanguageCheckboxStates
(
)
this
.
#
updateSettingsMenuSiteCheckboxStates
(
)
]
)
;
}
async
#
showRevisitView
(
{
fromLanguage
toLanguage
}
)
{
const
{
fromMenuList
toMenuList
intro
}
=
this
.
elements
;
if
(
!
this
.
#
isShowingDefaultView
(
)
)
{
await
this
.
#
showDefaultView
(
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
)
;
}
intro
.
hidden
=
true
;
fromMenuList
.
value
=
fromLanguage
;
toMenuList
.
value
=
await
TranslationsParent
.
getTopPreferredSupportedToLang
(
{
excludeLangTags
:
[
fromLanguage
toLanguage
]
}
)
;
this
.
onChangeLanguages
(
)
;
}
onChangeRevisitTo
(
)
{
const
{
revisitTranslate
revisitMenuList
}
=
this
.
elements
;
revisitTranslate
.
disabled
=
!
revisitMenuList
.
value
;
}
onChangeFromLanguage
(
event
)
{
const
{
target
}
=
event
;
if
(
target
?
.
value
)
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onChangeFromLanguage
(
target
.
value
)
;
}
this
.
onChangeLanguages
(
)
;
}
onChangeToLanguage
(
event
)
{
const
{
target
}
=
event
;
if
(
target
?
.
value
)
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onChangeToLanguage
(
target
.
value
)
;
}
this
.
onChangeLanguages
(
)
;
}
onChangeLanguages
(
)
{
this
.
#
updateViewFromTranslationStatus
(
)
;
}
close
(
)
{
PanelMultiView
.
hidePopup
(
this
.
elements
.
panel
)
;
}
onLearnMoreLink
(
)
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onLearnMoreLink
(
)
;
FullPageTranslationsPanel
.
close
(
)
;
}
onAboutTranslations
(
)
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onAboutTranslations
(
)
;
PanelMultiView
.
hidePopup
(
this
.
elements
.
panel
)
;
const
window
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
window
.
openTrustedLinkIn
(
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
website
-
translation
"
"
tab
"
{
forceForeground
:
true
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
)
;
}
async
onChangeSourceLanguage
(
event
)
{
const
{
panel
}
=
this
.
elements
;
PanelMultiView
.
hidePopup
(
panel
)
;
await
this
.
#
showDefaultView
(
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
true
)
;
await
this
.
#
openPanelPopup
(
this
.
elements
.
appMenuButton
{
event
viewName
:
"
defaultView
"
maintainFlow
:
true
}
)
;
}
async
#
reloadLangList
(
actor
)
{
try
{
await
this
.
#
ensureLangListsBuilt
(
)
;
await
this
.
#
showDefaultView
(
actor
)
;
}
catch
(
error
)
{
this
.
elements
.
errorHintAction
.
disabled
=
false
;
}
}
handlePanelButtonEvent
(
event
)
{
const
{
cancelButton
changeSourceLanguageButton
dismissErrorButton
restoreButton
translateButton
}
=
this
.
elements
;
switch
(
event
.
target
.
id
)
{
case
cancelButton
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onCancelButton
(
)
;
break
;
}
case
changeSourceLanguageButton
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onChangeSourceLanguageButton
(
)
;
break
;
}
case
dismissErrorButton
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onDismissErrorButton
(
)
;
break
;
}
case
restoreButton
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onRestorePageButton
(
)
;
break
;
}
case
translateButton
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onTranslateButton
(
)
;
break
;
}
}
}
handlePanelPopupShownEvent
(
event
)
{
const
{
panel
fromMenuList
toMenuList
}
=
this
.
elements
;
switch
(
event
.
target
.
id
)
{
case
panel
.
id
:
{
break
;
}
case
fromMenuList
.
firstChild
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onOpenFromLanguageMenu
(
)
;
break
;
}
case
toMenuList
.
firstChild
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onOpenToLanguageMenu
(
)
;
break
;
}
}
}
handlePanelPopupHiddenEvent
(
event
)
{
const
{
panel
fromMenuList
toMenuList
}
=
this
.
elements
;
switch
(
event
.
target
.
id
)
{
case
panel
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onClose
(
)
;
this
.
#
isPopupOpen
=
false
;
this
.
elements
.
error
.
hidden
=
true
;
break
;
}
case
fromMenuList
.
firstChild
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onCloseFromLanguageMenu
(
)
;
break
;
}
case
toMenuList
.
firstChild
.
id
:
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onCloseToLanguageMenu
(
)
;
break
;
}
}
}
handleSettingsPopupShownEvent
(
)
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onOpenSettingsMenu
(
)
;
}
handleSettingsPopupHiddenEvent
(
)
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onCloseSettingsMenu
(
)
;
}
async
#
openPanelPopup
(
target
{
event
=
null
viewName
=
null
autoShow
=
false
maintainFlow
=
false
}
)
{
const
{
panel
appMenuButton
}
=
this
.
elements
;
const
openedFromAppMenu
=
target
.
id
=
=
=
appMenuButton
.
id
;
const
{
docLangTag
}
=
await
this
.
#
getCachedDetectedLanguages
(
)
;
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onOpen
(
{
viewName
autoShow
docLangTag
maintainFlow
openedFromAppMenu
}
)
;
this
.
#
isPopupOpen
=
true
;
PanelMultiView
.
openPopup
(
panel
target
{
position
:
"
bottomright
topright
"
triggerEvent
:
event
}
)
.
catch
(
error
=
>
this
.
console
?
.
error
(
error
)
)
;
}
#
openPromise
=
null
;
async
open
(
event
reportAsAutoShow
=
false
)
{
if
(
this
.
#
openPromise
)
{
return
;
}
this
.
#
openPromise
=
this
.
#
openImpl
(
event
reportAsAutoShow
)
;
this
.
#
openPromise
.
finally
(
(
)
=
>
{
this
.
#
openPromise
=
null
;
}
)
;
}
async
#
openImpl
(
event
reportAsAutoShow
)
{
event
.
stopPropagation
(
)
;
if
(
(
event
.
type
=
=
"
click
"
&
&
event
.
button
!
=
0
)
|
|
(
event
.
type
=
=
"
keypress
"
&
&
event
.
charCode
!
=
KeyEvent
.
DOM_VK_SPACE
&
&
event
.
keyCode
!
=
KeyEvent
.
DOM_VK_RETURN
)
)
{
return
;
}
const
{
button
}
=
this
.
buttonElements
;
const
{
requestedTranslationPair
}
=
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
.
languageState
;
await
this
.
#
ensureLangListsBuilt
(
)
;
if
(
requestedTranslationPair
)
{
await
this
.
#
showRevisitView
(
requestedTranslationPair
)
.
catch
(
error
=
>
{
this
.
console
?
.
error
(
error
)
;
}
)
;
}
else
{
await
this
.
#
showDefaultView
(
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
)
.
catch
(
error
=
>
{
this
.
console
?
.
error
(
error
)
;
}
)
;
}
this
.
#
populateSettingsMenuItems
(
)
;
const
targetButton
=
button
.
contains
(
event
.
target
)
|
|
event
.
type
=
=
=
"
TranslationsParent
:
OfferTranslation
"
?
button
:
this
.
elements
.
appMenuButton
;
this
.
console
?
.
log
(
Showing
a
translation
panel
gBrowser
.
currentURI
.
spec
)
;
await
this
.
#
openPanelPopup
(
targetButton
{
event
autoShow
:
reportAsAutoShow
viewName
:
requestedTranslationPair
?
"
revisitView
"
:
"
defaultView
"
maintainFlow
:
false
}
)
;
}
#
isTranslationsActive
(
)
{
const
{
requestedTranslationPair
}
=
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
.
languageState
;
return
requestedTranslationPair
!
=
=
null
;
}
async
onTranslate
(
)
{
PanelMultiView
.
hidePopup
(
this
.
elements
.
panel
)
;
const
actor
=
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
;
actor
.
translate
(
this
.
elements
.
fromMenuList
.
value
this
.
elements
.
toMenuList
.
value
false
)
;
}
onCancel
(
)
{
PanelMultiView
.
hidePopup
(
this
.
elements
.
panel
)
;
}
openSettingsPopup
(
button
)
{
this
.
#
updateSettingsMenuLanguageCheckboxStates
(
)
;
this
.
#
updateSettingsMenuSiteCheckboxStates
(
)
;
const
popup
=
button
.
ownerDocument
.
getElementById
(
"
full
-
page
-
translations
-
panel
-
settings
-
menupopup
"
)
;
popup
.
openPopup
(
button
"
after_end
"
)
;
}
getCheckboxPageActionFor
(
)
{
const
{
alwaysTranslateLanguageMenuItem
neverTranslateLanguageMenuItem
neverTranslateSiteMenuItem
}
=
this
.
elements
;
const
alwaysTranslateLanguage
=
alwaysTranslateLanguageMenuItem
.
getAttribute
(
"
checked
"
)
=
=
=
"
true
"
;
const
neverTranslateLanguage
=
neverTranslateLanguageMenuItem
.
getAttribute
(
"
checked
"
)
=
=
=
"
true
"
;
const
neverTranslateSite
=
neverTranslateSiteMenuItem
.
getAttribute
(
"
checked
"
)
=
=
=
"
true
"
;
return
new
CheckboxPageAction
(
this
.
#
isTranslationsActive
(
)
alwaysTranslateLanguage
neverTranslateLanguage
neverTranslateSite
)
;
}
openManageLanguages
(
)
{
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onManageLanguages
(
)
;
const
window
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
window
.
openTrustedLinkIn
(
"
about
:
preferences
#
general
-
translations
"
"
tab
"
)
;
}
async
#
doPageAction
(
pageAction
)
{
switch
(
pageAction
)
{
case
PageAction
.
NO_CHANGE
:
{
break
;
}
case
PageAction
.
RESTORE_PAGE
:
{
await
this
.
onRestore
(
)
;
break
;
}
case
PageAction
.
TRANSLATE_PAGE
:
{
await
this
.
onTranslate
(
)
;
break
;
}
case
PageAction
.
CLOSE_PANEL
:
{
PanelMultiView
.
hidePopup
(
this
.
elements
.
panel
)
;
break
;
}
}
}
async
onAlwaysTranslateLanguage
(
)
{
const
langTags
=
await
this
.
#
getCachedDetectedLanguages
(
)
;
const
{
docLangTag
}
=
langTags
;
if
(
!
docLangTag
)
{
throw
new
Error
(
"
Expected
to
have
a
document
language
tag
.
"
)
;
}
const
pageAction
=
this
.
getCheckboxPageActionFor
(
)
.
alwaysTranslateLanguage
(
)
;
const
toggledOn
=
TranslationsParent
.
toggleAlwaysTranslateLanguagePref
(
langTags
)
;
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onAlwaysTranslateLanguage
(
docLangTag
toggledOn
)
;
this
.
#
updateSettingsMenuLanguageCheckboxStates
(
)
;
await
this
.
#
doPageAction
(
pageAction
)
;
}
async
onAlwaysOfferTranslations
(
)
{
const
toggledOn
=
TranslationsParent
.
toggleAutomaticallyPopupPref
(
)
;
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onAlwaysOfferTranslations
(
toggledOn
)
;
}
async
onNeverTranslateLanguage
(
)
{
const
{
docLangTag
}
=
await
this
.
#
getCachedDetectedLanguages
(
)
;
if
(
!
docLangTag
)
{
throw
new
Error
(
"
Expected
to
have
a
document
language
tag
.
"
)
;
}
const
pageAction
=
this
.
getCheckboxPageActionFor
(
)
.
neverTranslateLanguage
(
)
;
const
toggledOn
=
TranslationsParent
.
toggleNeverTranslateLanguagePref
(
docLangTag
)
;
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onNeverTranslateLanguage
(
docLangTag
toggledOn
)
;
this
.
#
updateSettingsMenuLanguageCheckboxStates
(
)
;
await
this
.
#
doPageAction
(
pageAction
)
;
}
async
onNeverTranslateSite
(
)
{
const
pageAction
=
this
.
getCheckboxPageActionFor
(
)
.
neverTranslateSite
(
)
;
const
toggledOn
=
await
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
.
toggleNeverTranslateSitePermissions
(
)
;
TranslationsParent
.
telemetry
(
)
.
fullPagePanel
(
)
.
onNeverTranslateSite
(
toggledOn
)
;
this
.
#
updateSettingsMenuSiteCheckboxStates
(
)
;
await
this
.
#
doPageAction
(
pageAction
)
;
}
async
onRestore
(
)
{
const
{
panel
}
=
this
.
elements
;
PanelMultiView
.
hidePopup
(
panel
)
;
const
{
docLangTag
}
=
await
this
.
#
getCachedDetectedLanguages
(
)
;
if
(
!
docLangTag
)
{
throw
new
Error
(
"
Expected
to
have
a
document
language
tag
.
"
)
;
}
TranslationsParent
.
getTranslationsActor
(
gBrowser
.
selectedBrowser
)
.
restorePage
(
docLangTag
)
;
}
onLocationChange
(
browser
)
{
if
(
browser
.
currentURI
.
spec
.
startsWith
(
"
about
:
reader
"
)
)
{
this
.
buttonElements
.
button
.
hidden
=
true
;
}
}
async
#
showEngineError
(
actor
)
{
const
{
button
}
=
this
.
buttonElements
;
await
this
.
#
ensureLangListsBuilt
(
)
;
if
(
!
this
.
#
isShowingDefaultView
(
)
)
{
await
this
.
#
showDefaultView
(
actor
)
.
catch
(
e
=
>
{
this
.
console
?
.
error
(
e
)
;
}
)
;
}
this
.
elements
.
error
.
hidden
=
false
;
this
.
#
showError
(
{
message
:
"
translations
-
panel
-
error
-
translating
"
}
)
;
const
targetButton
=
button
.
hidden
?
this
.
elements
.
appMenuButton
:
button
;
await
this
.
#
openPanelPopup
(
targetButton
{
autoShow
:
true
viewName
:
"
errorView
"
maintainFlow
:
true
}
)
;
}
handleEvent
=
event
=
>
{
const
target
=
event
.
target
;
let
{
id
}
=
target
;
if
(
!
id
)
{
id
=
target
.
closest
(
"
[
id
]
"
)
?
.
id
;
}
switch
(
event
.
type
)
{
case
"
command
"
:
{
switch
(
id
)
{
case
"
translations
-
panel
-
settings
"
:
this
.
openSettingsPopup
(
target
)
;
break
;
case
"
full
-
page
-
translations
-
panel
-
from
-
menupopup
"
:
this
.
onChangeFromLanguage
(
event
)
;
break
;
case
"
full
-
page
-
translations
-
panel
-
to
-
menupopup
"
:
this
.
onChangeToLanguage
(
event
)
;
break
;
case
"
full
-
page
-
translations
-
panel
-
restore
-
button
"
:
this
.
onRestore
(
event
)
;
break
;
case
"
full
-
page
-
translations
-
panel
-
cancel
"
:
case
"
full
-
page
-
translations
-
panel
-
dismiss
-
error
"
:
this
.
onCancel
(
event
)
;
break
;
case
"
full
-
page
-
translations
-
panel
-
translate
"
:
this
.
onTranslate
(
event
)
;
break
;
case
"
full
-
page
-
translations
-
panel
-
change
-
source
-
language
"
:
this
.
onChangeSourceLanguage
(
event
)
;
break
;
}
break
;
}
case
"
click
"
:
{
switch
(
id
)
{
case
"
full
-
page
-
translations
-
panel
-
intro
-
learn
-
more
-
link
"
:
case
"
full
-
page
-
translations
-
panel
-
unsupported
-
learn
-
more
-
link
"
:
this
.
onLearnMoreLink
(
)
;
break
;
default
:
this
.
handlePanelButtonEvent
(
event
)
;
}
break
;
}
case
"
popupshown
"
:
this
.
handlePanelPopupShownEvent
(
event
)
;
break
;
case
"
popuphidden
"
:
this
.
handlePanelPopupHiddenEvent
(
event
)
;
break
;
case
"
TranslationsParent
:
OfferTranslation
"
:
{
if
(
Services
.
wm
.
getMostRecentBrowserWindow
(
)
?
.
gBrowser
=
=
=
gBrowser
)
{
this
.
open
(
event
true
)
;
}
break
;
}
case
"
TranslationsParent
:
LanguageState
"
:
{
const
{
actor
reason
}
=
event
.
detail
;
const
innerWindowId
=
gBrowser
.
selectedBrowser
.
browsingContext
.
top
.
embedderElement
.
innerWindowID
;
this
.
console
?
.
debug
(
"
TranslationsParent
:
LanguageState
"
{
reason
currentId
:
innerWindowId
originatorId
:
actor
.
innerWindowId
}
)
;
if
(
innerWindowId
!
=
=
actor
.
innerWindowId
)
{
return
;
}
const
{
detectedLanguages
requestedTranslationPair
error
isEngineReady
}
=
actor
.
languageState
;
const
{
button
buttonLocale
buttonCircleArrows
}
=
this
.
buttonElements
;
const
hasSupportedLanguage
=
detectedLanguages
?
.
docLangTag
&
&
detectedLanguages
?
.
userLangTag
&
&
detectedLanguages
?
.
isDocLangTagSupported
;
if
(
detectedLanguages
)
{
FullPageTranslationsPanel
.
detectedLanguages
=
detectedLanguages
;
}
if
(
this
.
#
isPopupOpen
)
{
this
.
#
updateViewFromTranslationStatus
(
actor
.
languageState
)
;
}
if
(
requestedTranslationPair
|
|
error
|
|
(
hasSupportedLanguage
&
&
TranslationsParent
.
getIsTranslationsEngineSupported
(
)
)
)
{
const
wasButtonHidden
=
button
.
hidden
;
button
.
hidden
=
false
;
if
(
requestedTranslationPair
)
{
button
.
setAttribute
(
"
translationsactive
"
true
)
;
if
(
isEngineReady
)
{
const
displayNames
=
new
Services
.
intl
.
DisplayNames
(
undefined
{
type
:
"
language
"
}
)
;
document
.
l10n
.
setAttributes
(
button
"
urlbar
-
translations
-
button
-
translated
"
{
fromLanguage
:
displayNames
.
of
(
requestedTranslationPair
.
fromLanguage
)
toLanguage
:
displayNames
.
of
(
requestedTranslationPair
.
toLanguage
)
}
)
;
buttonLocale
.
hidden
=
false
;
buttonCircleArrows
.
hidden
=
true
;
buttonLocale
.
innerText
=
requestedTranslationPair
.
toLanguage
;
}
else
{
document
.
l10n
.
setAttributes
(
button
"
urlbar
-
translations
-
button
-
loading
"
)
;
buttonCircleArrows
.
hidden
=
false
;
buttonLocale
.
hidden
=
true
;
}
}
else
{
button
.
removeAttribute
(
"
translationsactive
"
)
;
buttonLocale
.
hidden
=
true
;
buttonCircleArrows
.
hidden
=
true
;
if
(
this
.
_hasShownPanel
&
&
gBrowser
.
currentURI
.
spec
!
=
=
actor
.
firstShowUriSpec
)
{
document
.
l10n
.
setAttributes
(
button
"
urlbar
-
translations
-
button2
"
)
;
}
else
{
document
.
l10n
.
setAttributes
(
button
"
urlbar
-
translations
-
button
-
intro
"
)
;
}
}
if
(
wasButtonHidden
)
{
PageActions
.
sendPlacedInUrlbarTrigger
(
button
)
;
}
}
else
if
(
!
button
.
hidden
)
{
button
.
hidden
=
true
;
}
switch
(
error
)
{
case
null
:
break
;
case
"
engine
-
load
-
failure
"
:
this
.
#
showEngineError
(
actor
)
.
catch
(
viewError
=
>
this
.
console
?
.
error
(
viewError
)
)
;
break
;
default
:
console
.
error
(
"
Unknown
translation
error
"
error
)
;
}
break
;
}
}
}
;
}
)
(
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
FullPageTranslationsPanel
"
_hasShownPanel
"
"
browser
.
translations
.
panelShown
"
false
)
;
