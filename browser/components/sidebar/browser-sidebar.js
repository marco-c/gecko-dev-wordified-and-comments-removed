const
{
DeferredTask
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
sys
.
mjs
"
)
;
const
toolsNameMap
=
{
viewGenaiChatSidebar
:
"
aichat
"
viewTabsSidebar
:
"
syncedtabs
"
viewHistorySidebar
:
"
history
"
viewBookmarksSidebar
:
"
bookmarks
"
viewCPMSidebar
:
"
passwords
"
}
;
const
EXPAND_ON_HOVER_DEBOUNCE_RATE_MS
=
200
;
const
EXPAND_ON_HOVER_DEBOUNCE_TIMEOUT_MS
=
1000
;
const
LAUNCHER_SPLITTER_WIDTH
=
4
;
var
SidebarController
=
{
makeSidebar
(
{
elementId
.
.
.
rest
}
commandID
)
{
const
sidebar
=
{
get
sourceL10nEl
(
)
{
return
document
.
getElementById
(
elementId
)
;
}
get
title
(
)
{
let
element
=
document
.
getElementById
(
elementId
)
;
return
element
?
.
getAttribute
(
"
label
"
)
;
}
.
.
.
rest
}
;
const
toolID
=
toolsNameMap
[
commandID
]
;
if
(
toolID
)
{
XPCOMUtils
.
defineLazyPreferenceGetter
(
sidebar
"
attention
"
sidebar
.
notification
.
badge
.
{
toolID
}
false
(
_pref
_prev
)
=
>
this
.
handleToolBadges
(
toolID
)
)
;
sidebar
.
attention
;
}
return
sidebar
;
}
registerPrefSidebar
(
pref
commandID
config
)
{
const
sidebar
=
this
.
makeSidebar
(
config
commandID
)
;
this
.
_sidebars
.
set
(
commandID
sidebar
)
;
let
switcherMenuitem
;
const
updateMenus
=
visible
=
>
{
if
(
!
visible
&
&
this
.
_state
.
command
=
=
commandID
)
{
this
.
_state
.
command
=
"
"
;
this
.
lastOpenedId
=
null
;
this
.
hide
(
)
;
}
const
viewItem
=
document
.
getElementById
(
sidebar
.
menuId
)
;
if
(
viewItem
)
{
viewItem
.
hidden
=
!
visible
;
}
let
menuItem
=
document
.
getElementById
(
config
.
elementId
)
;
if
(
visible
&
&
!
menuItem
)
{
switcherMenuitem
=
this
.
createMenuItem
(
commandID
sidebar
)
;
switcherMenuitem
.
setAttribute
(
"
id
"
config
.
elementId
)
;
switcherMenuitem
.
removeAttribute
(
"
type
"
)
;
const
separator
=
this
.
_switcherPanel
.
querySelector
(
"
menuseparator
"
)
;
separator
.
parentNode
.
insertBefore
(
switcherMenuitem
separator
)
;
}
else
{
switcherMenuitem
?
.
remove
(
)
;
}
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemChanged
"
)
)
;
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
sidebar
"
visible
"
pref
false
(
_pref
_prev
val
)
=
>
updateMenus
(
val
)
)
;
this
.
promiseInitialized
.
then
(
(
)
=
>
updateMenus
(
sidebar
.
visible
)
)
;
}
get
sidebars
(
)
{
if
(
this
.
_sidebars
)
{
return
this
.
_sidebars
;
}
return
this
.
generateSidebarsMap
(
)
;
}
generateSidebarsMap
(
)
{
this
.
_sidebars
=
new
Map
(
[
[
"
viewHistorySidebar
"
this
.
makeSidebar
(
{
name
:
"
history
"
elementId
:
"
sidebar
-
switcher
-
history
"
url
:
this
.
sidebarRevampEnabled
?
"
chrome
:
/
/
browser
/
content
/
sidebar
/
sidebar
-
history
.
html
"
:
"
chrome
:
/
/
browser
/
content
/
places
/
historySidebar
.
xhtml
"
menuId
:
"
menu_historySidebar
"
triggerButtonId
:
"
appMenuViewHistorySidebar
"
keyId
:
"
key_gotoHistory
"
menuL10nId
:
"
menu
-
view
-
history
-
button
"
revampL10nId
:
"
sidebar
-
menu
-
history
-
label
"
iconUrl
:
"
chrome
:
/
/
browser
/
skin
/
history
.
svg
"
contextMenuId
:
this
.
sidebarRevampEnabled
?
"
sidebar
-
history
-
context
-
menu
"
:
undefined
gleanEvent
:
Glean
.
history
.
sidebarToggle
gleanClickEvent
:
Glean
.
sidebar
.
historyIconClick
recordSidebarVersion
:
true
}
)
]
[
"
viewTabsSidebar
"
this
.
makeSidebar
(
{
name
:
"
syncedtabs
"
elementId
:
"
sidebar
-
switcher
-
tabs
"
url
:
this
.
sidebarRevampEnabled
?
"
chrome
:
/
/
browser
/
content
/
sidebar
/
sidebar
-
syncedtabs
.
html
"
:
"
chrome
:
/
/
browser
/
content
/
syncedtabs
/
sidebar
.
xhtml
"
menuId
:
"
menu_tabsSidebar
"
classAttribute
:
"
sync
-
ui
-
item
"
menuL10nId
:
"
menu
-
view
-
synced
-
tabs
-
sidebar
"
revampL10nId
:
"
sidebar
-
menu
-
synced
-
tabs
-
label
"
iconUrl
:
"
chrome
:
/
/
browser
/
skin
/
synced
-
tabs
.
svg
"
contextMenuId
:
this
.
sidebarRevampEnabled
?
"
sidebar
-
synced
-
tabs
-
context
-
menu
"
:
undefined
gleanClickEvent
:
Glean
.
sidebar
.
syncedTabsIconClick
}
)
]
[
"
viewBookmarksSidebar
"
this
.
makeSidebar
(
{
name
:
"
bookmarks
"
elementId
:
"
sidebar
-
switcher
-
bookmarks
"
url
:
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarksSidebar
.
xhtml
"
menuId
:
"
menu_bookmarksSidebar
"
keyId
:
"
viewBookmarksSidebarKb
"
menuL10nId
:
"
menu
-
view
-
bookmarks
"
revampL10nId
:
"
sidebar
-
menu
-
bookmarks
-
label
"
iconUrl
:
"
chrome
:
/
/
browser
/
skin
/
bookmark
-
hollow
.
svg
"
disabled
:
true
gleanEvent
:
Glean
.
bookmarks
.
sidebarToggle
gleanClickEvent
:
Glean
.
sidebar
.
bookmarksIconClick
recordSidebarVersion
:
true
}
)
]
]
)
;
this
.
registerPrefSidebar
(
"
browser
.
ml
.
chat
.
enabled
"
"
viewGenaiChatSidebar
"
{
name
:
"
aichat
"
elementId
:
"
sidebar
-
switcher
-
genai
-
chat
"
url
:
"
chrome
:
/
/
browser
/
content
/
genai
/
chat
.
html
"
keyId
:
"
viewGenaiChatSidebarKb
"
menuId
:
"
menu_genaiChatSidebar
"
menuL10nId
:
"
menu
-
view
-
genai
-
chat
"
revampL10nId
:
"
sidebar
-
menu
-
genai
-
chat
-
label
"
iconUrl
:
"
chrome
:
/
/
global
/
skin
/
icons
/
highlights
.
svg
"
gleanClickEvent
:
Glean
.
sidebar
.
chatbotIconClick
toolContextMenuId
:
"
aichat
"
}
)
;
this
.
registerPrefSidebar
(
"
browser
.
contextual
-
password
-
manager
.
enabled
"
"
viewCPMSidebar
"
{
name
:
"
passwords
"
elementId
:
"
sidebar
-
switcher
-
megalist
"
url
:
"
chrome
:
/
/
global
/
content
/
megalist
/
megalist
.
html
"
menuId
:
"
menu_megalistSidebar
"
menuL10nId
:
"
menu
-
view
-
contextual
-
password
-
manager
"
revampL10nId
:
"
sidebar
-
menu
-
contextual
-
password
-
manager
-
label
"
iconUrl
:
"
chrome
:
/
/
browser
/
skin
/
login
.
svg
"
gleanEvent
:
Glean
.
contextualManager
.
sidebarToggle
}
)
;
if
(
this
.
sidebarRevampEnabled
)
{
this
.
_sidebars
.
set
(
"
viewCustomizeSidebar
"
{
url
:
"
chrome
:
/
/
browser
/
content
/
sidebar
/
sidebar
-
customize
.
html
"
revampL10nId
:
"
sidebar
-
menu
-
customize
-
label
"
iconUrl
:
"
chrome
:
/
/
global
/
skin
/
icons
/
settings
.
svg
"
gleanEvent
:
Glean
.
sidebarCustomize
.
panelToggle
visible
:
false
}
)
;
}
return
this
.
_sidebars
;
}
get
toolsAndExtensions
(
)
{
if
(
this
.
_toolsAndExtensions
)
{
return
this
.
_toolsAndExtensions
;
}
this
.
_toolsAndExtensions
=
new
Map
(
)
;
this
.
getTools
(
)
.
forEach
(
tool
=
>
{
this
.
_toolsAndExtensions
.
set
(
tool
.
commandID
tool
)
;
}
)
;
this
.
getExtensions
(
)
.
forEach
(
extension
=
>
{
this
.
_toolsAndExtensions
.
set
(
extension
.
commandID
extension
)
;
}
)
;
return
this
.
_toolsAndExtensions
;
}
get
browser
(
)
{
if
(
this
.
_browser
)
{
return
this
.
_browser
;
}
return
(
this
.
_browser
=
document
.
getElementById
(
"
sidebar
"
)
)
;
}
POSITION_START_PREF
:
"
sidebar
.
position_start
"
DEFAULT_SIDEBAR_ID
:
"
viewBookmarksSidebar
"
VISIBILITY_PREF
:
"
sidebar
.
visibility
"
TOOLS_PREF
:
"
sidebar
.
main
.
tools
"
INSTALLED_EXTENSIONS
:
"
sidebar
.
installed
.
extensions
"
lastOpenedId
:
null
_box
:
null
_pinnedTabsContainer
:
null
_pinnedTabsItemsWrapper
:
null
get
_title
(
)
{
if
(
this
.
__title
)
{
return
this
.
__title
;
}
return
(
this
.
__title
=
document
.
getElementById
(
"
sidebar
-
title
"
)
)
;
}
_splitter
:
null
_reversePositionButton
:
null
_switcherPanel
:
null
_switcherTarget
:
null
_switcherArrow
:
null
_inited
:
false
_uninitializing
:
false
_switcherListenersAdded
:
false
_verticalNewTabListenerAdded
:
false
_localesObserverAdded
:
false
_mainResizeObserverAdded
:
false
_mainResizeObserver
:
null
_ongoingAnimations
:
[
]
_observer
:
null
_initDeferred
:
Promise
.
withResolvers
(
)
get
promiseInitialized
(
)
{
return
this
.
_initDeferred
.
promise
;
}
get
initialized
(
)
{
return
this
.
_inited
;
}
get
uninitializing
(
)
{
return
this
.
_uninitializing
;
}
get
inSingleTabWindow
(
)
{
return
(
!
window
.
toolbar
.
visible
|
|
window
.
document
.
documentElement
.
hasAttribute
(
"
taskbartab
"
)
)
;
}
get
sidebarContainer
(
)
{
if
(
!
this
.
_sidebarContainer
)
{
this
.
_sidebarContainer
=
document
.
getElementById
(
"
sidebar
-
main
"
)
;
}
return
this
.
_sidebarContainer
;
}
get
sidebarMain
(
)
{
if
(
!
this
.
_sidebarMain
)
{
this
.
_sidebarMain
=
document
.
querySelector
(
"
sidebar
-
main
"
)
;
}
return
this
.
_sidebarMain
;
}
get
contentArea
(
)
{
if
(
!
this
.
_contentArea
)
{
this
.
_contentArea
=
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
}
return
this
.
_contentArea
;
}
get
toolbarButton
(
)
{
if
(
!
this
.
_toolbarButton
)
{
this
.
_toolbarButton
=
document
.
getElementById
(
"
sidebar
-
button
"
)
;
}
return
this
.
_toolbarButton
;
}
get
isLauncherDragging
(
)
{
return
this
.
_launcherSplitter
.
getAttribute
(
"
state
"
)
=
=
=
"
dragging
"
;
}
get
isPinnedTabsDragging
(
)
{
return
this
.
_pinnedTabsSplitter
.
getAttribute
(
"
state
"
)
=
=
=
"
dragging
"
;
}
get
sidebarTools
(
)
{
return
this
.
sidebarRevampTools
?
this
.
sidebarRevampTools
.
split
(
"
"
)
:
[
]
;
}
get
sidebarExtensions
(
)
{
return
this
.
installedExtensions
?
this
.
installedExtensions
.
split
(
"
"
)
:
[
]
;
}
init
(
)
{
this
.
SidebarManager
;
if
(
!
this
.
_state
)
{
this
.
_state
=
new
this
.
SidebarState
(
this
)
;
}
this
.
_pinnedTabsContainer
=
document
.
getElementById
(
"
pinned
-
tabs
-
container
"
)
;
this
.
_pinnedTabsItemsWrapper
=
this
.
_pinnedTabsContainer
.
shadowRoot
.
querySelector
(
"
[
part
=
items
-
wrapper
]
"
)
;
this
.
_box
=
document
.
getElementById
(
"
sidebar
-
box
"
)
;
this
.
_splitter
=
document
.
getElementById
(
"
sidebar
-
splitter
"
)
;
this
.
_launcherSplitter
=
document
.
getElementById
(
"
sidebar
-
launcher
-
splitter
"
)
;
this
.
_pinnedTabsSplitter
=
document
.
getElementById
(
"
vertical
-
pinned
-
tabs
-
splitter
"
)
;
this
.
_reversePositionButton
=
document
.
getElementById
(
"
sidebar
-
reverse
-
position
"
)
;
this
.
_switcherPanel
=
document
.
getElementById
(
"
sidebarMenu
-
popup
"
)
;
this
.
_switcherTarget
=
document
.
getElementById
(
"
sidebar
-
switcher
-
target
"
)
;
this
.
_switcherArrow
=
document
.
getElementById
(
"
sidebar
-
switcher
-
arrow
"
)
;
this
.
_hoverBlockerCount
=
0
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
allow_transparent_browser
"
false
)
)
{
this
.
browser
.
setAttribute
(
"
transparent
"
"
true
"
)
;
}
const
menubar
=
document
.
getElementById
(
"
viewSidebarMenu
"
)
;
const
currentMenuItems
=
new
Set
(
Array
.
from
(
menubar
.
childNodes
item
=
>
item
.
id
)
)
;
for
(
const
[
commandID
sidebar
]
of
this
.
sidebars
.
entries
(
)
)
{
if
(
!
Object
.
hasOwn
(
sidebar
"
extensionId
"
)
&
&
commandID
!
=
=
"
viewCustomizeSidebar
"
&
&
!
currentMenuItems
.
has
(
sidebar
.
menuId
)
)
{
const
menuitem
=
this
.
createMenuItem
(
commandID
sidebar
)
;
menubar
.
appendChild
(
menuitem
)
;
}
}
if
(
this
.
_mainResizeObserver
)
{
this
.
_mainResizeObserver
.
disconnect
(
)
;
this
.
_mainResizeObserverAdded
=
false
;
}
this
.
_mainResizeObserver
=
new
ResizeObserver
(
(
[
entry
]
)
=
>
this
.
_handleLauncherResize
(
entry
)
)
;
if
(
this
.
sidebarRevampEnabled
&
&
!
BrowserHandler
.
kiosk
)
{
if
(
!
customElements
.
get
(
"
sidebar
-
main
"
)
)
{
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
browser
/
content
/
sidebar
/
sidebar
-
main
.
mjs
"
{
global
:
"
current
"
}
)
;
}
this
.
revampComponentsLoaded
=
true
;
this
.
_state
.
initializeState
(
)
;
document
.
getElementById
(
"
sidebar
-
header
"
)
.
hidden
=
true
;
if
(
!
this
.
_mainResizeObserverAdded
)
{
this
.
_mainResizeObserver
.
observe
(
this
.
sidebarMain
)
;
this
.
_mainResizeObserverAdded
=
true
;
}
if
(
!
this
.
_browserResizeObserver
)
{
this
.
_browserResizeObserver
=
(
)
=
>
{
const
current
=
this
.
browser
.
getBoundingClientRect
(
)
.
width
;
const
previous
=
this
.
_browserWidth
;
const
percentage
=
(
current
/
window
.
innerWidth
)
*
100
;
Glean
.
sidebar
.
resize
.
record
(
{
current
:
Math
.
round
(
current
)
previous
:
Math
.
round
(
previous
)
percentage
:
Math
.
round
(
percentage
)
}
)
;
this
.
_recordBrowserSize
(
)
;
}
;
this
.
_splitter
.
addEventListener
(
"
command
"
this
.
_browserResizeObserver
)
;
}
this
.
_enableLauncherDragging
(
)
;
this
.
_enablePinnedTabsSplitterDragging
(
)
;
this
.
recordVisibilitySetting
(
)
;
this
.
recordPositionSetting
(
)
;
this
.
recordTabsLayoutSetting
(
)
;
}
else
{
this
.
_switcherCloseButton
=
document
.
getElementById
(
"
sidebar
-
close
"
)
;
if
(
!
this
.
_switcherListenersAdded
)
{
this
.
_switcherCloseButton
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
hide
(
)
;
}
)
;
this
.
_switcherTarget
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
toggleSwitcherPanel
(
)
;
}
)
;
this
.
_switcherTarget
.
addEventListener
(
"
keydown
"
event
=
>
{
this
.
handleKeydown
(
event
)
;
}
)
;
this
.
_switcherListenersAdded
=
true
;
}
this
.
_disableLauncherDragging
(
)
;
this
.
_disablePinnedTabsDragging
(
)
;
}
if
(
CustomizableUI
.
verticalTabsEnabled
)
{
this
.
toggleTabstrip
(
)
;
}
this
.
setPosition
(
)
;
this
.
_inited
=
true
;
if
(
!
this
.
_localesObserverAdded
)
{
Services
.
obs
.
addObserver
(
this
"
intl
:
app
-
locales
-
changed
"
)
;
this
.
_localesObserverAdded
=
true
;
}
if
(
!
this
.
_tabstripOrientationObserverAdded
)
{
Services
.
obs
.
addObserver
(
this
"
tabstrip
-
orientation
-
change
"
)
;
this
.
_tabstripOrientationObserverAdded
=
true
;
}
requestIdleCallback
(
(
)
=
>
{
const
windowPrivacyMatches
=
!
window
.
opener
|
|
this
.
windowPrivacyMatches
(
window
.
opener
window
)
;
if
(
!
this
.
uiStateInitialized
&
&
!
this
.
inSingleTabWindow
&
&
(
this
.
sidebarRevampEnabled
|
|
windowPrivacyMatches
)
)
{
const
backupState
=
this
.
SidebarManager
.
getBackupState
(
)
;
this
.
initializeUIState
(
backupState
)
;
}
}
)
;
this
.
_initDeferred
.
resolve
(
)
;
}
uninit
(
)
{
this
.
_uninitializing
=
true
;
let
enumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
if
(
!
enumerator
.
hasMoreElements
(
)
)
{
let
xulStore
=
Services
.
xulStore
;
xulStore
.
persist
(
this
.
_title
"
value
"
)
;
const
currentState
=
this
.
getUIState
(
)
;
this
.
SidebarManager
.
setBackupState
(
currentState
)
;
}
Services
.
obs
.
removeObserver
(
this
"
intl
:
app
-
locales
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
tabstrip
-
orientation
-
change
"
)
;
delete
this
.
_tabstripOrientationObserverAdded
;
CustomizableUI
.
removeListener
(
this
)
;
if
(
this
.
_observer
)
{
this
.
_observer
.
disconnect
(
)
;
this
.
_observer
=
null
;
}
if
(
this
.
_mainResizeObserver
)
{
this
.
_mainResizeObserver
.
disconnect
(
)
;
this
.
_mainResizeObserver
=
null
;
}
if
(
this
.
revampComponentsLoaded
)
{
this
.
sidebarMain
.
remove
(
)
;
}
this
.
_splitter
.
removeEventListener
(
"
command
"
this
.
_browserResizeObserver
)
;
this
.
_disableLauncherDragging
(
)
;
this
.
_disablePinnedTabsDragging
(
)
;
}
_handleLauncherResize
(
entry
)
{
this
.
_state
.
launcherWidth
=
entry
.
contentBoxSize
[
0
]
.
inlineSize
;
if
(
this
.
isLauncherDragging
)
{
this
.
_state
.
launcherDragActive
=
true
;
}
if
(
this
.
_state
.
visibilitySetting
=
=
=
"
expand
-
on
-
hover
"
)
{
this
.
setLauncherCollapsedWidth
(
)
;
}
}
getUIState
(
)
{
if
(
this
.
inSingleTabWindow
)
{
return
null
;
}
return
this
.
_state
.
getProperties
(
)
;
}
async
initializeUIState
(
state
)
{
if
(
!
state
)
{
return
;
}
const
isValidSidebar
=
!
state
.
command
|
|
this
.
sidebars
.
has
(
state
.
command
)
;
if
(
!
isValidSidebar
)
{
state
.
command
=
"
"
;
}
const
hasOpenPanel
=
state
.
panelOpen
&
&
state
.
command
&
&
this
.
sidebars
.
has
(
state
.
command
)
&
&
this
.
currentID
!
=
=
state
.
command
;
if
(
hasOpenPanel
)
{
delete
state
.
hidden
;
}
await
this
.
promiseInitialized
;
await
this
.
waitUntilStable
(
)
;
await
this
.
_state
.
loadInitialState
(
state
)
;
await
this
.
waitUntilStable
(
)
;
this
.
updateToolbarButton
(
)
;
if
(
this
.
sidebarRevampVisibility
=
=
=
"
expand
-
on
-
hover
"
)
{
await
this
.
toggleExpandOnHover
(
true
)
;
}
this
.
uiStateInitialized
=
true
;
}
toggleVerticalTabs
(
)
{
Services
.
prefs
.
setBoolPref
(
"
sidebar
.
verticalTabs
"
!
this
.
sidebarVerticalTabsEnabled
)
;
}
observe
(
_subject
topic
_data
)
{
switch
(
topic
)
{
case
"
intl
:
app
-
locales
-
changed
"
:
{
if
(
this
.
isOpen
)
{
this
.
hide
(
{
dismissPanel
:
false
}
)
;
this
.
showInitially
(
this
.
lastOpenedId
)
;
break
;
}
if
(
this
.
revampComponentsLoaded
)
{
this
.
sidebarMain
.
requestUpdate
(
)
;
}
break
;
}
case
"
tabstrip
-
orientation
-
change
"
:
{
this
.
promiseInitialized
.
then
(
(
)
=
>
this
.
toggleTabstrip
(
)
)
;
break
;
}
}
}
observeTitleChanges
(
element
)
{
if
(
!
element
)
{
return
;
}
let
observer
=
this
.
_observer
;
if
(
!
observer
)
{
observer
=
new
MutationObserver
(
(
)
=
>
{
this
.
title
=
this
.
sidebars
.
get
(
this
.
lastOpenedId
)
?
.
title
;
}
)
;
this
.
_observer
=
observer
;
}
observer
.
disconnect
(
)
;
observer
.
observe
(
element
{
attributes
:
true
attributeFilter
:
[
"
label
"
]
}
)
;
}
toggleSwitcherPanel
(
)
{
if
(
this
.
_switcherPanel
.
state
=
=
"
open
"
|
|
this
.
_switcherPanel
.
state
=
=
"
showing
"
)
{
this
.
hideSwitcherPanel
(
)
;
}
else
if
(
this
.
_switcherPanel
.
state
=
=
"
closed
"
)
{
this
.
showSwitcherPanel
(
)
;
}
}
handleKeydown
(
event
)
{
switch
(
event
.
key
)
{
case
"
Enter
"
:
case
"
"
:
{
this
.
toggleSwitcherPanel
(
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
break
;
}
case
"
Escape
"
:
{
this
.
hideSwitcherPanel
(
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
break
;
}
}
}
hideSwitcherPanel
(
)
{
this
.
_switcherPanel
.
hidePopup
(
)
;
}
showSwitcherPanel
(
)
{
this
.
_switcherPanel
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
this
.
_switcherTarget
.
classList
.
remove
(
"
active
"
)
;
this
.
_switcherTarget
.
setAttribute
(
"
aria
-
expanded
"
false
)
;
}
{
once
:
true
}
)
;
let
label
=
this
.
_positionStart
=
=
RTL_UI
?
gNavigatorBundle
.
getString
(
"
sidebar
.
moveToLeft
"
)
:
gNavigatorBundle
.
getString
(
"
sidebar
.
moveToRight
"
)
;
this
.
_reversePositionButton
.
setAttribute
(
"
label
"
label
)
;
this
.
_switcherPanel
.
hidden
=
false
;
this
.
_switcherPanel
.
openPopup
(
this
.
_switcherTarget
)
;
this
.
_switcherTarget
.
classList
.
add
(
"
active
"
)
;
this
.
_switcherTarget
.
setAttribute
(
"
aria
-
expanded
"
true
)
;
}
updateShortcut
(
{
keyId
}
)
{
let
menuitem
=
this
.
_switcherPanel
?
.
querySelector
(
[
key
=
"
{
keyId
}
"
]
)
;
if
(
!
menuitem
)
{
return
;
}
menuitem
.
removeAttribute
(
"
acceltext
"
)
;
}
reversePosition
(
)
{
Services
.
prefs
.
setBoolPref
(
this
.
POSITION_START_PREF
!
this
.
_positionStart
)
;
}
setPosition
(
)
{
let
contentArea
=
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
let
browser
=
document
.
getElementById
(
"
browser
"
)
;
[
.
.
.
browser
.
children
]
.
forEach
(
(
node
i
)
=
>
{
node
.
style
.
order
=
i
+
1
;
}
)
;
let
sidebarContainer
=
document
.
getElementById
(
"
sidebar
-
main
"
)
;
let
sidebarMain
=
document
.
querySelector
(
"
sidebar
-
main
"
)
;
if
(
!
this
.
_positionStart
)
{
let
mainOrdinal
=
this
.
sidebarContainer
.
style
.
order
;
this
.
sidebarContainer
.
style
.
order
=
contentArea
.
style
.
order
;
contentArea
.
style
.
order
=
mainOrdinal
;
let
splitterOrdinal
=
this
.
_splitter
.
style
.
order
;
this
.
_splitter
.
style
.
order
=
this
.
_launcherSplitter
.
style
.
order
;
this
.
_launcherSplitter
.
style
.
order
=
splitterOrdinal
;
}
this
.
_box
.
toggleAttribute
(
"
sidebar
-
positionend
"
!
this
.
_positionStart
)
;
sidebarMain
.
toggleAttribute
(
"
sidebar
-
positionend
"
!
this
.
_positionStart
)
;
contentArea
.
toggleAttribute
(
"
sidebar
-
positionend
"
!
this
.
_positionStart
)
;
sidebarContainer
.
toggleAttribute
(
"
sidebar
-
positionend
"
!
this
.
_positionStart
)
;
this
.
toolbarButton
&
&
this
.
toolbarButton
.
toggleAttribute
(
"
sidebar
-
positionend
"
!
this
.
_positionStart
)
;
this
.
hideSwitcherPanel
(
)
;
let
content
=
SidebarController
.
browser
.
contentWindow
;
if
(
content
&
&
content
.
updatePosition
)
{
content
.
updatePosition
(
)
;
}
}
async
toggleRevampSidebar
(
)
{
await
this
.
promiseInitialized
;
let
wasOpen
=
this
.
isOpen
;
if
(
wasOpen
)
{
this
.
hide
(
{
dismissPanel
:
false
}
)
;
}
let
extensionsArr
=
[
]
;
for
(
const
[
commandID
sidebar
]
of
this
.
sidebars
.
entries
(
)
)
{
if
(
sidebar
.
hasOwnProperty
(
"
extensionId
"
)
)
{
extensionsArr
.
push
(
{
commandID
sidebar
}
)
;
}
}
this
.
sidebars
=
this
.
generateSidebarsMap
(
)
;
for
(
const
extension
of
extensionsArr
)
{
this
.
sidebars
.
set
(
extension
.
commandID
extension
.
sidebar
)
;
}
if
(
!
this
.
sidebarRevampEnabled
)
{
this
.
_state
.
launcherVisible
=
false
;
document
.
getElementById
(
"
sidebar
-
header
"
)
.
hidden
=
false
;
if
(
this
.
sidebarVerticalTabsEnabled
)
{
Services
.
prefs
.
setBoolPref
(
"
sidebar
.
verticalTabs
"
false
)
;
}
}
else
{
this
.
_state
.
launcherVisible
=
this
.
_state
.
defaultLauncherVisible
;
}
if
(
!
this
.
_sidebars
.
get
(
this
.
lastOpenedId
)
)
{
this
.
lastOpenedId
=
this
.
DEFAULT_SIDEBAR_ID
;
wasOpen
=
false
;
}
this
.
updateToolbarButton
(
)
;
this
.
_inited
=
false
;
this
.
init
(
)
;
if
(
wasOpen
)
{
this
.
toggle
(
)
;
}
}
async
adoptFromWindow
(
sourceWindow
)
{
let
sourceController
=
sourceWindow
.
SidebarController
;
if
(
!
sourceController
|
|
!
sourceController
.
_box
)
{
return
false
;
}
if
(
this
.
inSingleTabWindow
&
&
this
.
sidebarRevampEnabled
)
{
document
.
getElementById
(
"
sidebar
-
main
"
)
.
hidden
=
true
;
return
false
;
}
const
sourceState
=
sourceController
.
inPopup
?
null
:
sourceController
.
_state
?
.
getProperties
(
)
;
await
this
.
initializeUIState
(
sourceState
)
;
return
true
;
}
windowPrivacyMatches
(
w1
w2
)
{
return
(
PrivateBrowsingUtils
.
isWindowPrivate
(
w1
)
=
=
=
PrivateBrowsingUtils
.
isWindowPrivate
(
w2
)
)
;
}
async
startDelayedLoad
(
)
{
if
(
this
.
inSingleTabWindow
)
{
this
.
_state
.
launcherVisible
=
false
;
return
;
}
let
sourceWindow
=
window
.
opener
;
if
(
sourceWindow
)
{
if
(
sourceWindow
.
closed
|
|
sourceWindow
.
location
.
protocol
!
=
"
chrome
:
"
|
|
(
!
this
.
sidebarRevampEnabled
&
&
!
this
.
windowPrivacyMatches
(
sourceWindow
window
)
)
)
{
return
;
}
if
(
await
this
.
adoptFromWindow
(
sourceWindow
)
)
{
this
.
uiStateInitialized
=
true
;
return
;
}
}
let
wasOpen
=
this
.
_box
.
getAttribute
(
"
checked
"
)
;
if
(
!
wasOpen
)
{
return
;
}
let
commandID
=
this
.
_state
.
command
;
if
(
commandID
&
&
this
.
sidebars
.
has
(
commandID
)
)
{
this
.
showInitially
(
commandID
)
;
}
else
{
this
.
_box
.
removeAttribute
(
"
checked
"
)
;
this
.
_state
.
command
=
"
"
;
this
.
lastOpenedId
=
commandID
;
}
this
.
uiStateInitialized
=
true
;
}
_fireShowEvent
(
)
{
let
event
=
new
CustomEvent
(
"
SidebarShown
"
{
bubbles
:
true
}
)
;
this
.
_switcherTarget
.
dispatchEvent
(
event
)
;
}
_recordBrowserSize
(
)
{
this
.
_browserWidth
=
this
.
browser
.
getBoundingClientRect
(
)
.
width
;
Glean
.
sidebar
.
width
.
set
(
this
.
_browserWidth
)
;
}
_fireFocusedEvent
(
)
{
let
event
=
new
CustomEvent
(
"
SidebarFocused
"
{
bubbles
:
true
}
)
;
this
.
browser
.
contentWindow
.
dispatchEvent
(
event
)
;
}
get
isOpen
(
)
{
return
this
.
_box
?
!
this
.
_box
.
hidden
:
false
;
}
get
currentID
(
)
{
return
this
.
isOpen
?
this
.
_state
.
command
:
"
"
;
}
get
currentContextMenu
(
)
{
const
sidebar
=
this
.
sidebars
.
get
(
this
.
currentID
)
;
if
(
!
sidebar
)
{
return
null
;
}
return
document
.
getElementById
(
sidebar
.
contextMenuId
)
;
}
get
launcherVisible
(
)
{
return
this
.
_state
?
.
launcherVisible
;
}
get
launcherEverVisible
(
)
{
return
this
.
_state
?
.
launcherEverVisible
;
}
get
title
(
)
{
return
this
.
_title
.
value
;
}
set
title
(
value
)
{
this
.
_title
.
value
=
value
;
}
toggle
(
commandID
=
this
.
lastOpenedId
triggerNode
)
{
if
(
CustomizationHandler
.
isCustomizing
(
)
|
|
CustomizationHandler
.
isExitingCustomizeMode
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
commandID
)
{
commandID
=
this
.
_state
.
command
;
}
if
(
!
commandID
|
|
!
this
.
sidebars
.
has
(
commandID
)
)
{
if
(
this
.
sidebarRevampEnabled
&
&
this
.
sidebars
.
size
)
{
commandID
=
this
.
sidebars
.
keys
(
)
.
next
(
)
.
value
;
}
else
{
commandID
=
this
.
DEFAULT_SIDEBAR_ID
;
}
}
if
(
this
.
isOpen
&
&
commandID
=
=
this
.
currentID
)
{
this
.
hide
(
{
triggerNode
dismissPanel
:
this
.
sidebarRevampEnabled
}
)
;
this
.
updateToolbarButton
(
)
;
return
Promise
.
resolve
(
)
;
}
return
this
.
show
(
commandID
triggerNode
)
;
}
_getRects
(
animatingElements
)
{
return
animatingElements
.
map
(
e
=
>
[
e
.
hidden
e
.
getBoundingClientRect
(
)
.
toJSON
(
)
]
)
;
}
async
waitUntilStable
(
)
{
if
(
!
this
.
sidebarRevampEnabled
)
{
return
null
;
}
const
tasks
=
[
this
.
sidebarMain
.
updateComplete
]
;
if
(
this
.
_ongoingAnimations
?
.
length
)
{
tasks
.
push
(
.
.
.
this
.
_ongoingAnimations
.
map
(
animation
=
>
animation
.
finished
)
)
;
}
return
Promise
.
allSettled
(
tasks
)
;
}
async
_animateSidebarMain
(
)
{
let
tabbox
=
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
let
animatingElements
;
let
expandOnHoverEnabled
=
document
.
documentElement
.
hasAttribute
(
"
sidebar
-
expand
-
on
-
hover
"
)
;
if
(
expandOnHoverEnabled
)
{
animatingElements
=
[
this
.
sidebarContainer
]
;
this
.
_addHoverStateBlocker
(
)
;
}
else
{
animatingElements
=
[
this
.
sidebarContainer
this
.
_box
this
.
_splitter
tabbox
]
;
}
let
resetElements
=
(
)
=
>
{
for
(
let
el
of
animatingElements
)
{
el
.
style
.
minWidth
=
el
.
style
.
maxWidth
=
el
.
style
.
marginLeft
=
el
.
style
.
marginRight
=
el
.
style
.
display
=
"
"
;
}
this
.
sidebarContainer
.
toggleAttribute
(
"
sidebar
-
ongoing
-
animations
"
false
)
;
this
.
_box
.
toggleAttribute
(
"
sidebar
-
ongoing
-
animations
"
false
)
;
tabbox
.
toggleAttribute
(
"
sidebar
-
ongoing
-
animations
"
false
)
;
}
;
if
(
this
.
_ongoingAnimations
.
length
)
{
this
.
_ongoingAnimations
.
forEach
(
a
=
>
a
.
cancel
(
)
)
;
this
.
_ongoingAnimations
=
[
]
;
resetElements
(
)
;
}
let
fromRects
=
this
.
_getRects
(
animatingElements
)
;
await
new
Promise
(
resolve
=
>
{
queueMicrotask
(
(
)
=
>
resolve
(
this
.
sidebarMain
.
updateComplete
)
)
;
}
)
;
let
toRects
=
this
.
_getRects
(
animatingElements
)
;
const
options
=
{
duration
:
document
.
documentElement
.
hasAttribute
(
"
sidebar
-
expand
-
on
-
hover
"
)
?
this
.
_animationExpandOnHoverDurationMs
:
this
.
_animationDurationMs
easing
:
"
ease
-
in
-
out
"
}
;
let
animations
=
[
]
;
let
sidebarOnLeft
=
this
.
_positionStart
!
=
RTL_UI
;
let
sidebarShift
=
0
;
for
(
let
i
=
0
;
i
<
animatingElements
.
length
;
+
+
i
)
{
const
el
=
animatingElements
[
i
]
;
const
[
wasHidden
from
]
=
fromRects
[
i
]
;
const
[
isHidden
to
]
=
toRects
[
i
]
;
const
isSidebar
=
el
=
=
=
this
.
sidebarContainer
;
if
(
wasHidden
!
=
isHidden
)
{
if
(
wasHidden
)
{
from
.
left
=
from
.
right
=
sidebarOnLeft
?
to
.
left
:
to
.
right
;
}
else
{
to
.
left
=
to
.
right
=
sidebarOnLeft
?
from
.
left
:
from
.
right
;
}
}
const
widthGrowth
=
to
.
width
-
from
.
width
;
if
(
isSidebar
)
{
sidebarShift
=
widthGrowth
;
}
let
fromTranslate
=
sidebarOnLeft
?
from
.
left
-
to
.
left
:
from
.
right
-
to
.
right
;
let
toTranslate
=
0
;
el
.
style
.
minWidth
=
el
.
style
.
maxWidth
=
el
.
style
.
marginLeft
=
el
.
style
.
marginRight
=
el
.
style
.
display
=
"
"
;
if
(
isHidden
&
&
!
wasHidden
)
{
el
.
style
.
display
=
"
flex
"
;
}
if
(
widthGrowth
<
0
)
{
el
.
style
.
minWidth
=
el
.
style
.
maxWidth
=
from
.
width
+
"
px
"
;
el
.
style
[
"
margin
-
"
+
(
sidebarOnLeft
?
"
right
"
:
"
left
"
)
]
=
widthGrowth
+
"
px
"
;
if
(
isSidebar
)
{
toTranslate
=
sidebarOnLeft
?
widthGrowth
:
-
widthGrowth
;
}
else
if
(
el
=
=
=
this
.
_box
)
{
fromTranslate
=
sidebarOnLeft
?
-
sidebarShift
:
sidebarShift
;
toTranslate
=
sidebarOnLeft
?
fromTranslate
+
widthGrowth
:
fromTranslate
-
widthGrowth
;
}
}
else
if
(
isSidebar
)
{
fromTranslate
+
=
sidebarOnLeft
?
-
widthGrowth
:
widthGrowth
;
}
animations
.
push
(
el
.
animate
(
[
{
translate
:
{
fromTranslate
}
px
0
0
}
{
translate
:
{
toTranslate
}
px
0
0
}
]
options
)
)
;
if
(
!
isSidebar
|
|
!
this
.
_positionStart
)
{
continue
;
}
if
(
!
this
.
_state
.
launcherExpanded
)
{
animations
.
push
(
this
.
sidebarMain
.
animate
(
[
{
translate
:
"
0
"
}
{
translate
:
{
-
toTranslate
}
px
0
0
}
]
options
)
)
;
}
else
{
animations
.
push
(
this
.
sidebarMain
.
animate
(
[
{
translate
:
{
-
fromTranslate
}
px
0
0
}
{
translate
:
"
0
"
}
]
options
)
)
;
}
}
this
.
_ongoingAnimations
=
animations
;
this
.
sidebarContainer
.
toggleAttribute
(
"
sidebar
-
ongoing
-
animations
"
true
)
;
this
.
sidebarMain
.
toggleAttribute
(
"
sidebar
-
ongoing
-
animations
"
true
)
;
this
.
_box
.
toggleAttribute
(
"
sidebar
-
ongoing
-
animations
"
true
)
;
tabbox
.
toggleAttribute
(
"
sidebar
-
ongoing
-
animations
"
true
)
;
await
Promise
.
allSettled
(
animations
.
map
(
a
=
>
a
.
finished
)
)
;
if
(
this
.
_ongoingAnimations
=
=
=
animations
)
{
this
.
_ongoingAnimations
=
[
]
;
resetElements
(
)
;
}
if
(
expandOnHoverEnabled
)
{
await
this
.
_removeHoverStateBlocker
(
)
;
}
}
async
handleToolbarButtonClick
(
)
{
if
(
this
.
inSingleTabWindow
|
|
this
.
uninitializing
)
{
return
;
}
const
initialExpandedValue
=
this
.
_state
.
launcherExpanded
;
const
expandOnToggle
=
[
"
always
-
show
"
"
expand
-
on
-
hover
"
]
.
includes
(
this
.
sidebarRevampVisibility
)
;
if
(
this
.
sidebarRevampVisibility
=
=
=
"
expand
-
on
-
hover
"
)
{
await
this
.
toggleExpandOnHover
(
initialExpandedValue
)
;
}
if
(
this
.
_animationEnabled
&
&
!
window
.
gReduceMotion
)
{
this
.
_animateSidebarMain
(
)
;
}
if
(
expandOnToggle
)
{
this
.
_state
.
updateVisibility
(
true
!
initialExpandedValue
)
;
this
.
updateToolbarButton
(
)
;
return
;
}
const
shouldShowLauncher
=
!
this
.
_state
.
launcherVisible
;
this
.
_state
.
updateVisibility
(
shouldShowLauncher
)
;
if
(
shouldShowLauncher
&
&
this
.
_state
.
command
)
{
await
this
.
show
(
this
.
_state
.
command
)
;
}
else
if
(
!
shouldShowLauncher
)
{
this
.
hide
(
{
dismissPanel
:
false
}
)
;
}
this
.
updateToolbarButton
(
)
;
}
updateToolbarButton
(
toolbarButton
=
this
.
toolbarButton
)
{
if
(
!
toolbarButton
|
|
this
.
inSingleTabWindow
)
{
return
;
}
if
(
!
this
.
sidebarRevampEnabled
)
{
toolbarButton
.
dataset
.
l10nId
=
"
show
-
sidebars
"
;
toolbarButton
.
checked
=
this
.
isOpen
;
}
else
{
let
sidebarToggleKey
=
document
.
getElementById
(
"
toggleSidebarKb
"
)
;
const
shortcut
=
ShortcutUtils
.
prettifyShortcut
(
sidebarToggleKey
)
;
toolbarButton
.
dataset
.
l10nArgs
=
JSON
.
stringify
(
{
shortcut
}
)
;
const
isVerticalTabs
=
Services
.
prefs
.
getBoolPref
(
"
sidebar
.
verticalTabs
"
)
;
if
(
isVerticalTabs
)
{
toolbarButton
.
toggleAttribute
(
"
expanded
"
this
.
sidebarMain
.
expanded
)
;
}
else
{
toolbarButton
.
toggleAttribute
(
"
expanded
"
false
)
;
}
this
.
handleToolBadges
(
)
;
switch
(
this
.
sidebarRevampVisibility
)
{
case
"
always
-
show
"
:
case
"
expand
-
on
-
hover
"
:
toolbarButton
.
checked
=
this
.
sidebarMain
.
expanded
;
toolbarButton
.
dataset
.
l10nId
=
toolbarButton
.
checked
?
"
sidebar
-
widget
-
collapse
-
sidebar2
"
:
"
sidebar
-
widget
-
expand
-
sidebar2
"
;
break
;
case
"
hide
-
sidebar
"
:
toolbarButton
.
checked
=
!
this
.
sidebarContainer
.
hidden
;
toolbarButton
.
dataset
.
l10nId
=
toolbarButton
.
checked
?
"
sidebar
-
widget
-
hide
-
sidebar2
"
:
"
sidebar
-
widget
-
show
-
sidebar2
"
;
break
;
}
}
}
handleToolBadges
(
toolID
=
null
)
{
const
toolPrefList
=
this
.
SidebarManager
.
getBadgeTools
(
)
;
for
(
const
pref
of
toolPrefList
)
{
if
(
toolID
&
&
toolID
!
=
=
pref
)
{
continue
;
}
const
badgePref
=
Services
.
prefs
.
getBoolPref
(
sidebar
.
notification
.
badge
.
{
pref
}
false
)
;
const
commandID
=
[
.
.
.
this
.
toolsAndExtensions
.
keys
(
)
]
.
find
(
id
=
>
toolsNameMap
[
id
]
=
=
=
pref
)
;
if
(
!
commandID
)
{
continue
;
}
const
isSidebarClosed
=
!
this
.
_state
?
.
launcherVisible
;
const
isCurrentView
=
this
.
_state
?
.
command
=
=
=
commandID
;
if
(
badgePref
&
&
isCurrentView
&
&
this
.
isOpen
)
{
this
.
dismissSidebarBadge
(
commandID
)
;
}
if
(
this
.
sidebarRevampEnabled
&
&
badgePref
&
&
isSidebarClosed
)
{
this
.
_showToolbarButtonBadge
(
)
;
}
else
{
this
.
_clearToolbarButtonBadge
(
)
;
}
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemChanged
"
)
)
;
}
}
_addHoverStateBlocker
(
)
{
this
.
_hoverBlockerCount
+
+
;
MousePosTracker
.
removeListener
(
this
)
;
}
async
_removeHoverStateBlocker
(
)
{
if
(
this
.
_hoverBlockerCount
=
=
1
)
{
let
isHovered
;
MousePosTracker
.
_callListener
(
{
onMouseEnter
:
(
)
=
>
(
isHovered
=
true
)
onMouseLeave
:
(
)
=
>
(
isHovered
=
false
)
getMouseTargetRect
:
(
)
=
>
this
.
getMouseTargetRect
(
)
}
)
;
if
(
this
.
_state
.
launcherExpanded
&
&
!
isHovered
)
{
if
(
this
.
_animationEnabled
&
&
!
window
.
gReduceMotion
)
{
this
.
_animateSidebarMain
(
)
;
}
this
.
_state
.
launcherExpanded
=
false
;
await
this
.
waitUntilStable
(
)
;
}
MousePosTracker
.
addListener
(
this
)
;
}
this
.
_hoverBlockerCount
-
-
;
}
_showToolbarButtonBadge
(
)
{
const
badgeEl
=
this
.
toolbarButton
?
.
querySelector
(
"
.
toolbarbutton
-
badge
"
)
;
return
badgeEl
?
.
classList
.
add
(
"
feature
-
callout
"
)
;
}
_clearToolbarButtonBadge
(
)
{
const
badgeEl
=
this
.
toolbarButton
?
.
querySelector
(
"
.
toolbarbutton
-
badge
"
)
;
return
badgeEl
?
.
classList
.
remove
(
"
feature
-
callout
"
)
;
}
dismissSidebarBadge
(
view
)
{
const
prefName
=
sidebar
.
notification
.
badge
.
{
toolsNameMap
[
view
]
}
;
if
(
Services
.
prefs
.
getBoolPref
(
prefName
false
)
)
{
Services
.
prefs
.
setBoolPref
(
prefName
false
)
;
}
}
_enableLauncherDragging
(
)
{
if
(
!
this
.
_launcherSplitter
.
hidden
)
{
return
;
}
this
.
_panelResizeObserver
=
new
ResizeObserver
(
(
[
entry
]
)
=
>
(
this
.
_state
.
panelWidth
=
entry
.
contentBoxSize
[
0
]
.
inlineSize
)
)
;
this
.
_panelResizeObserver
.
observe
(
this
.
_box
)
;
this
.
_launcherDropHandler
=
(
)
=
>
(
this
.
_state
.
launcherDragActive
=
false
)
;
this
.
_launcherSplitter
.
addEventListener
(
"
command
"
this
.
_launcherDropHandler
)
;
this
.
_launcherSplitter
.
hidden
=
false
;
}
_enablePinnedTabsSplitterDragging
(
)
{
if
(
!
this
.
_pinnedTabsSplitter
.
hidden
)
{
return
;
}
this
.
_pinnedTabsResizeObserver
=
new
ResizeObserver
(
(
)
=
>
{
if
(
this
.
isPinnedTabsDragging
)
{
this
.
_state
.
pinnedTabsDragActive
=
true
;
}
}
)
;
this
.
_itemsWrapperResizeObserver
=
new
ResizeObserver
(
async
(
)
=
>
{
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
requestAnimationFrame
(
(
)
=
>
{
if
(
this
.
_pinnedTabsContainer
.
hasAttribute
(
"
dragActive
"
)
)
{
return
;
}
this
.
updatePinnedTabsHeightOnResize
(
)
;
}
)
;
}
)
;
}
)
;
this
.
_pinnedTabsResizeObserver
.
observe
(
this
.
_pinnedTabsContainer
)
;
this
.
_itemsWrapperResizeObserver
.
observe
(
this
.
_pinnedTabsItemsWrapper
)
;
this
.
_pinnedTabsDropHandler
=
(
)
=
>
(
this
.
_state
.
pinnedTabsDragActive
=
false
)
;
this
.
_pinnedTabsSplitter
.
addEventListener
(
"
command
"
this
.
_pinnedTabsDropHandler
)
;
this
.
_pinnedTabsSplitter
.
hidden
=
false
;
}
_disableLauncherDragging
(
)
{
if
(
this
.
_panelResizeObserver
)
{
this
.
_panelResizeObserver
.
disconnect
(
)
;
}
this
.
_launcherSplitter
.
removeEventListener
(
"
command
"
this
.
_launcherDropHandler
)
;
this
.
_launcherSplitter
.
hidden
=
true
;
}
_disablePinnedTabsDragging
(
)
{
if
(
this
.
_pinnedTabsResizeObserver
)
{
this
.
_pinnedTabsResizeObserver
.
disconnect
(
)
;
}
if
(
this
.
_itemsWrapperResizeObserver
)
{
this
.
_itemsWrapperResizeObserver
.
disconnect
(
)
;
}
this
.
_pinnedTabsSplitter
.
hidden
=
true
;
}
_loadSidebarExtension
(
commandID
)
{
let
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
if
(
typeof
sidebar
?
.
onload
=
=
=
"
function
"
)
{
sidebar
.
onload
(
)
;
}
}
updatePinnedTabsHeightOnResize
(
)
{
let
itemsWrapperHeight
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
_pinnedTabsItemsWrapper
)
.
height
;
if
(
this
.
_state
.
pinnedTabsHeight
>
itemsWrapperHeight
)
{
this
.
_state
.
pinnedTabsHeight
=
itemsWrapperHeight
;
if
(
this
.
_state
.
launcherExpanded
)
{
this
.
_state
.
expandedPinnedTabsHeight
=
this
.
_state
.
pinnedTabsHeight
;
}
else
{
this
.
_state
.
collapsedPinnedTabsHeight
=
this
.
_state
.
pinnedTabsHeight
;
}
}
}
refreshTools
(
)
{
let
changed
=
false
;
const
tools
=
new
Set
(
this
.
sidebarRevampTools
.
split
(
"
"
)
)
;
this
.
toolsAndExtensions
.
forEach
(
tool
=
>
{
const
expected
=
!
tools
.
has
(
tool
.
name
)
;
if
(
tool
.
disabled
!
=
expected
)
{
tool
.
disabled
=
expected
;
changed
=
true
;
}
}
)
;
if
(
changed
)
{
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemChanged
"
)
)
;
}
}
toggleTool
(
commandID
)
{
const
toggledTool
=
this
.
toolsAndExtensions
.
get
(
commandID
)
;
const
toolName
=
toggledTool
.
name
;
toggledTool
.
disabled
=
!
toggledTool
.
disabled
;
if
(
!
toggledTool
.
disabled
)
{
this
.
toolsAndExtensions
.
delete
(
commandID
)
;
this
.
toolsAndExtensions
.
set
(
commandID
toggledTool
)
;
}
this
.
SidebarManager
.
updateToolsPref
(
toolName
toggledTool
.
disabled
)
;
if
(
toggledTool
.
disabled
)
{
this
.
dismissSidebarBadge
(
commandID
)
;
}
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemChanged
"
)
)
;
}
addOrUpdateExtension
(
commandID
extension
)
{
if
(
this
.
inSingleTabWindow
)
{
return
;
}
if
(
this
.
toolsAndExtensions
.
has
(
commandID
)
)
{
let
extensionToUpdate
=
this
.
toolsAndExtensions
.
get
(
commandID
)
;
extensionToUpdate
.
icon
=
extension
.
icon
;
extensionToUpdate
.
iconUrl
=
extension
.
iconUrl
;
extensionToUpdate
.
tooltiptext
=
extension
.
label
;
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemChanged
"
)
)
;
}
else
{
const
name
=
extension
.
extensionId
;
this
.
toolsAndExtensions
.
set
(
commandID
{
view
:
commandID
extensionId
:
extension
.
extensionId
icon
:
extension
.
icon
iconUrl
:
extension
.
iconUrl
tooltiptext
:
extension
.
label
disabled
:
!
this
.
sidebarTools
.
includes
(
name
)
name
}
)
;
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemAdded
"
)
)
;
}
}
registerExtension
(
commandID
props
)
{
const
sidebarTools
=
this
.
sidebarTools
;
const
installedExtensions
=
this
.
sidebarExtensions
;
const
name
=
props
.
extensionId
;
if
(
!
installedExtensions
.
includes
(
name
)
&
&
!
sidebarTools
.
includes
(
name
)
)
{
sidebarTools
.
push
(
name
)
;
installedExtensions
.
push
(
name
)
;
Services
.
prefs
.
setStringPref
(
this
.
TOOLS_PREF
sidebarTools
.
join
(
)
)
;
Services
.
prefs
.
setStringPref
(
this
.
INSTALLED_EXTENSIONS
installedExtensions
.
join
(
)
)
;
}
const
sidebar
=
{
title
:
props
.
title
url
:
"
chrome
:
/
/
browser
/
content
/
webext
-
panels
.
xhtml
"
menuId
:
props
.
menuId
switcherMenuId
:
sidebarswitcher_menu_
{
commandID
}
keyId
:
ext
-
key
-
id
-
{
commandID
}
label
:
props
.
title
icon
:
props
.
icon
iconUrl
:
props
.
iconUrl
classAttribute
:
"
menuitem
-
iconic
webextension
-
menuitem
"
extensionId
:
props
.
extensionId
onload
:
props
.
onload
name
}
;
this
.
sidebars
.
set
(
commandID
sidebar
)
;
const
menuitem
=
this
.
createMenuItem
(
commandID
sidebar
)
;
document
.
getElementById
(
"
viewSidebarMenu
"
)
.
appendChild
(
menuitem
)
;
this
.
addOrUpdateExtension
(
commandID
sidebar
)
;
if
(
!
this
.
sidebarRevampEnabled
)
{
let
switcherMenuitem
=
this
.
createMenuItem
(
commandID
sidebar
)
;
switcherMenuitem
.
setAttribute
(
"
id
"
sidebar
.
switcherMenuId
)
;
switcherMenuitem
.
removeAttribute
(
"
type
"
)
;
let
separator
=
document
.
getElementById
(
"
sidebar
-
extensions
-
separator
"
)
;
separator
.
parentNode
.
insertBefore
(
switcherMenuitem
separator
)
;
}
this
.
_setExtensionAttributes
(
commandID
{
icon
:
props
.
icon
iconUrl
:
props
.
iconUrl
label
:
props
.
title
}
sidebar
)
;
}
createMenuItem
(
commandID
sidebar
)
{
const
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
id
"
sidebar
.
menuId
)
;
menuitem
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
menuitem
.
addEventListener
(
"
command
"
(
)
=
>
this
[
menuitem
.
hasAttribute
(
"
type
"
)
?
"
toggle
"
:
"
show
"
]
(
commandID
)
)
;
if
(
sidebar
.
classAttribute
)
{
menuitem
.
setAttribute
(
"
class
"
sidebar
.
classAttribute
)
;
}
if
(
sidebar
.
keyId
)
{
menuitem
.
setAttribute
(
"
key
"
sidebar
.
keyId
)
;
}
if
(
sidebar
.
menuL10nId
)
{
menuitem
.
dataset
.
l10nId
=
sidebar
.
menuL10nId
;
}
if
(
this
.
inSingleTabWindow
)
{
menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
return
menuitem
;
}
setExtensionAttributes
(
commandID
attributes
needsRefresh
)
{
const
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
this
.
_setExtensionAttributes
(
commandID
attributes
sidebar
needsRefresh
)
;
this
.
addOrUpdateExtension
(
commandID
sidebar
)
;
}
_setExtensionAttributes
(
commandID
{
icon
iconUrl
label
}
sidebar
needsRefresh
=
false
)
{
sidebar
.
icon
=
icon
;
sidebar
.
iconUrl
=
iconUrl
;
sidebar
.
label
=
label
;
const
updateAttributes
=
el
=
>
{
el
.
style
.
setProperty
(
"
-
-
webextension
-
menuitem
-
image
"
sidebar
.
icon
)
;
el
.
setAttribute
(
"
label
"
sidebar
.
label
)
;
}
;
updateAttributes
(
document
.
getElementById
(
sidebar
.
menuId
)
sidebar
)
;
const
switcherMenu
=
document
.
getElementById
(
sidebar
.
switcherMenuId
)
;
if
(
switcherMenu
)
{
updateAttributes
(
switcherMenu
sidebar
)
;
}
if
(
this
.
initialized
&
&
this
.
currentID
=
=
=
commandID
)
{
this
.
title
=
label
;
if
(
this
.
isOpen
&
&
needsRefresh
)
{
this
.
show
(
commandID
)
;
}
}
}
getExtensions
(
)
{
const
extensions
=
[
]
;
for
(
const
[
commandID
sidebar
]
of
this
.
sidebars
.
entries
(
)
)
{
if
(
Object
.
hasOwn
(
sidebar
"
extensionId
"
)
)
{
const
disabled
=
!
this
.
sidebarTools
.
includes
(
sidebar
.
name
)
;
extensions
.
push
(
{
commandID
view
:
commandID
extensionId
:
sidebar
.
extensionId
iconUrl
:
sidebar
.
iconUrl
tooltiptext
:
sidebar
.
label
disabled
name
:
sidebar
.
name
}
)
;
}
}
return
extensions
;
}
getTools
(
)
{
return
Object
.
keys
(
toolsNameMap
)
.
filter
(
commandID
=
>
this
.
sidebars
.
get
(
commandID
)
)
.
map
(
commandID
=
>
{
const
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
const
disabled
=
!
this
.
sidebarTools
.
includes
(
toolsNameMap
[
commandID
]
)
;
return
{
commandID
view
:
commandID
name
:
sidebar
.
name
iconUrl
:
sidebar
.
iconUrl
l10nId
:
sidebar
.
revampL10nId
disabled
get
hidden
(
)
{
return
!
(
sidebar
.
visible
?
?
true
)
;
}
get
attention
(
)
{
return
sidebar
.
attention
?
?
false
;
}
contextMenu
:
sidebar
.
toolContextMenuId
}
;
}
)
;
}
removeExtension
(
commandID
)
{
if
(
this
.
inSingleTabWindow
)
{
return
;
}
const
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
if
(
!
sidebar
)
{
return
;
}
if
(
this
.
currentID
=
=
=
commandID
)
{
this
.
hide
(
{
dismissPanel
:
false
}
)
;
}
document
.
getElementById
(
sidebar
.
menuId
)
?
.
remove
(
)
;
document
.
getElementById
(
sidebar
.
switcherMenuId
)
?
.
remove
(
)
;
this
.
sidebars
.
delete
(
commandID
)
;
this
.
toolsAndExtensions
.
delete
(
commandID
)
;
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemRemoved
"
)
)
;
}
async
show
(
commandID
triggerNode
)
{
if
(
this
.
inSingleTabWindow
)
{
return
false
;
}
if
(
this
.
currentID
&
&
commandID
!
=
=
this
.
currentID
)
{
this
.
_recordPanelToggle
(
this
.
currentID
false
)
;
}
this
.
_recordPanelToggle
(
commandID
true
)
;
if
(
!
this
.
sidebars
.
has
(
commandID
)
)
{
return
false
;
}
return
this
.
_show
(
commandID
)
.
then
(
(
)
=
>
{
this
.
_loadSidebarExtension
(
commandID
)
;
if
(
triggerNode
)
{
updateToggleControlLabel
(
triggerNode
)
;
}
this
.
updateToolbarButton
(
)
;
this
.
dismissSidebarBadge
(
commandID
)
;
this
.
_fireFocusedEvent
(
)
;
return
true
;
}
)
;
}
async
showInitially
(
commandID
)
{
if
(
this
.
inSingleTabWindow
)
{
return
false
;
}
this
.
_recordPanelToggle
(
commandID
true
)
;
if
(
!
this
.
sidebars
.
has
(
commandID
)
)
{
return
false
;
}
return
this
.
_show
(
commandID
)
.
then
(
(
)
=
>
{
this
.
_loadSidebarExtension
(
commandID
)
;
return
true
;
}
)
;
}
_show
(
commandID
)
{
return
new
Promise
(
resolve
=
>
{
const
willShowEvent
=
new
CustomEvent
(
"
SidebarWillShow
"
)
;
this
.
browser
.
contentWindow
?
.
dispatchEvent
(
willShowEvent
)
;
this
.
_state
.
panelOpen
=
true
;
if
(
this
.
sidebarRevampEnabled
)
{
this
.
_box
.
dispatchEvent
(
new
CustomEvent
(
"
sidebar
-
show
"
{
detail
:
{
viewId
:
commandID
}
}
)
)
;
}
else
{
this
.
hideSwitcherPanel
(
)
;
}
this
.
selectMenuItem
(
commandID
)
;
this
.
_box
.
hidden
=
this
.
_splitter
.
hidden
=
false
;
this
.
_box
.
setAttribute
(
"
checked
"
"
true
"
)
;
this
.
_state
.
command
=
commandID
;
let
{
icon
url
title
sourceL10nEl
contextMenuId
}
=
this
.
sidebars
.
get
(
commandID
)
;
if
(
icon
)
{
this
.
_switcherTarget
.
style
.
setProperty
(
"
-
-
webextension
-
menuitem
-
image
"
icon
)
;
}
else
{
this
.
_switcherTarget
.
style
.
removeProperty
(
"
-
-
webextension
-
menuitem
-
image
"
)
;
}
if
(
contextMenuId
)
{
this
.
_box
.
setAttribute
(
"
context
"
contextMenuId
)
;
}
else
{
this
.
_box
.
removeAttribute
(
"
context
"
)
;
}
this
.
lastOpenedId
=
commandID
;
if
(
!
this
.
sidebarRevampEnabled
)
{
this
.
title
=
title
;
this
.
observeTitleChanges
(
sourceL10nEl
)
;
}
this
.
browser
.
setAttribute
(
"
src
"
url
)
;
if
(
this
.
browser
.
contentDocument
.
location
.
href
!
=
url
)
{
this
.
browser
.
addEventListener
(
"
unload
"
(
)
=
>
{
if
(
this
.
browser
.
loadingTimerID
)
{
clearTimeout
(
this
.
browser
.
loadingTimerID
)
;
delete
this
.
browser
.
loadingTimerID
;
resolve
(
)
;
}
}
)
;
this
.
browser
.
addEventListener
(
"
load
"
(
)
=
>
{
this
.
browser
.
loadingTimerID
=
setTimeout
(
(
)
=
>
{
delete
this
.
browser
.
loadingTimerID
;
resolve
(
)
;
this
.
_fireShowEvent
(
)
;
this
.
_recordBrowserSize
(
)
;
}
0
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
else
{
resolve
(
)
;
this
.
_fireShowEvent
(
)
;
this
.
_recordBrowserSize
(
)
;
}
}
)
;
}
hide
(
{
triggerNode
dismissPanel
=
this
.
sidebarRevampEnabled
}
=
{
}
)
{
if
(
!
this
.
isOpen
)
{
return
;
}
const
willHideEvent
=
new
CustomEvent
(
"
SidebarWillHide
"
{
cancelable
:
true
}
)
;
this
.
browser
.
contentWindow
?
.
dispatchEvent
(
willHideEvent
)
;
if
(
willHideEvent
.
defaultPrevented
)
{
return
;
}
this
.
hideSwitcherPanel
(
)
;
this
.
_recordPanelToggle
(
this
.
currentID
false
)
;
this
.
_state
.
panelOpen
=
false
;
if
(
dismissPanel
)
{
this
.
_state
.
command
=
"
"
;
this
.
lastOpenedId
=
null
;
}
if
(
this
.
sidebarRevampEnabled
)
{
this
.
_box
.
dispatchEvent
(
new
CustomEvent
(
"
sidebar
-
hide
"
)
)
;
}
this
.
selectMenuItem
(
"
"
)
;
this
.
browser
.
setAttribute
(
"
src
"
"
about
:
blank
"
)
;
this
.
browser
.
docShell
?
.
createAboutBlankDocumentViewer
(
null
null
)
;
this
.
_box
.
removeAttribute
(
"
checked
"
)
;
this
.
_box
.
removeAttribute
(
"
context
"
)
;
this
.
_box
.
hidden
=
this
.
_splitter
.
hidden
=
true
;
let
selBrowser
=
gBrowser
.
selectedBrowser
;
selBrowser
.
focus
(
)
;
if
(
triggerNode
)
{
updateToggleControlLabel
(
triggerNode
)
;
}
this
.
updateToolbarButton
(
)
;
}
_recordPanelToggle
(
commandID
opened
)
{
const
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
if
(
!
sidebar
)
{
return
;
}
const
isExtension
=
sidebar
&
&
Object
.
hasOwn
(
sidebar
"
extensionId
"
)
;
const
version
=
this
.
sidebarRevampEnabled
?
"
new
"
:
"
old
"
;
if
(
isExtension
)
{
const
addonId
=
sidebar
.
extensionId
;
const
addonName
=
WebExtensionPolicy
.
getByID
(
addonId
)
?
.
name
;
Glean
.
extension
.
sidebarToggle
.
record
(
{
opened
version
addon_id
:
AMTelemetry
.
getTrimmedString
(
addonId
)
addon_name
:
addonName
&
&
AMTelemetry
.
getTrimmedString
(
addonName
)
}
)
;
}
else
if
(
sidebar
.
gleanEvent
&
&
sidebar
.
recordSidebarVersion
)
{
sidebar
.
gleanEvent
.
record
(
{
opened
version
}
)
;
}
else
if
(
sidebar
.
gleanEvent
)
{
sidebar
.
gleanEvent
.
record
(
{
opened
}
)
;
}
}
recordIconClick
(
commandID
expanded
)
{
const
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
const
isExtension
=
sidebar
&
&
Object
.
hasOwn
(
sidebar
"
extensionId
"
)
;
if
(
isExtension
)
{
const
addonId
=
sidebar
.
extensionId
;
Glean
.
sidebar
.
addonIconClick
.
record
(
{
sidebar_open
:
expanded
addon_id
:
AMTelemetry
.
getTrimmedString
(
addonId
)
}
)
;
}
else
if
(
sidebar
.
gleanClickEvent
)
{
sidebar
.
gleanClickEvent
.
record
(
{
sidebar_open
:
expanded
}
)
;
}
}
selectMenuItem
(
commandID
)
{
for
(
let
[
id
{
menuId
triggerButtonId
}
]
of
this
.
sidebars
)
{
let
menu
=
document
.
getElementById
(
menuId
)
;
if
(
!
menu
)
{
continue
;
}
let
triggerbutton
=
triggerButtonId
&
&
document
.
getElementById
(
triggerButtonId
)
;
if
(
id
=
=
commandID
)
{
menu
.
setAttribute
(
"
checked
"
"
true
"
)
;
if
(
triggerbutton
)
{
triggerbutton
.
setAttribute
(
"
checked
"
"
true
"
)
;
updateToggleControlLabel
(
triggerbutton
)
;
}
}
else
{
menu
.
removeAttribute
(
"
checked
"
)
;
if
(
triggerbutton
)
{
triggerbutton
.
removeAttribute
(
"
checked
"
)
;
updateToggleControlLabel
(
triggerbutton
)
;
}
}
}
}
toggleTabstrip
(
)
{
let
toVerticalTabs
=
CustomizableUI
.
verticalTabsEnabled
;
let
tabStrip
=
gBrowser
.
tabContainer
;
let
arrowScrollbox
=
tabStrip
.
arrowScrollbox
;
let
currentScrollOrientation
=
arrowScrollbox
.
getAttribute
(
"
orient
"
)
;
if
(
(
!
toVerticalTabs
&
&
currentScrollOrientation
!
=
=
"
vertical
"
)
|
|
(
toVerticalTabs
&
&
currentScrollOrientation
=
=
=
"
vertical
"
)
)
{
return
;
}
if
(
toVerticalTabs
)
{
arrowScrollbox
.
setAttribute
(
"
orient
"
"
vertical
"
)
;
tabStrip
.
setAttribute
(
"
orient
"
"
vertical
"
)
;
this
.
_clearToolbarButtonBadge
(
)
;
}
else
{
arrowScrollbox
.
setAttribute
(
"
orient
"
"
horizontal
"
)
;
tabStrip
.
removeAttribute
(
"
expanded
"
)
;
tabStrip
.
setAttribute
(
"
orient
"
"
horizontal
"
)
;
}
let
verticalToolbar
=
document
.
getElementById
(
CustomizableUI
.
AREA_VERTICAL_TABSTRIP
)
;
verticalToolbar
.
toggleAttribute
(
"
visible
"
toVerticalTabs
)
;
this
.
sidebarMain
.
requestUpdate
(
)
;
if
(
!
this
.
verticalTabsEnabled
&
&
this
.
sidebarRevampVisibility
=
=
"
hide
-
sidebar
"
)
{
this
.
_state
.
launcherExpanded
=
false
;
}
}
debouncedMouseEnter
(
)
{
const
contentArea
=
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
this
.
_box
.
toggleAttribute
(
"
sidebar
-
launcher
-
hovered
"
true
)
;
contentArea
.
toggleAttribute
(
"
sidebar
-
launcher
-
hovered
"
true
)
;
this
.
_state
.
launcherHoverActive
=
true
;
if
(
this
.
_animationEnabled
&
&
!
window
.
gReduceMotion
)
{
this
.
_animateSidebarMain
(
)
;
}
this
.
_state
.
launcherExpanded
=
true
;
}
onMouseLeave
(
)
{
this
.
mouseEnterTask
.
disarm
(
)
;
const
contentArea
=
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
this
.
_box
.
toggleAttribute
(
"
sidebar
-
launcher
-
hovered
"
false
)
;
contentArea
.
toggleAttribute
(
"
sidebar
-
launcher
-
hovered
"
false
)
;
this
.
_state
.
launcherHoverActive
=
false
;
if
(
this
.
_animationEnabled
&
&
!
window
.
gReduceMotion
)
{
this
.
_animateSidebarMain
(
)
;
}
this
.
_state
.
launcherExpanded
=
false
;
}
onMouseEnter
(
)
{
this
.
mouseEnterTask
=
new
DeferredTask
(
(
)
=
>
{
this
.
debouncedMouseEnter
(
)
;
}
EXPAND_ON_HOVER_DEBOUNCE_RATE_MS
EXPAND_ON_HOVER_DEBOUNCE_TIMEOUT_MS
)
;
this
.
mouseEnterTask
?
.
arm
(
)
;
}
async
setLauncherCollapsedWidth
(
)
{
let
browserEl
=
document
.
getElementById
(
"
browser
"
)
;
if
(
this
.
getUIState
(
)
.
launcherExpanded
)
{
this
.
_state
.
launcherExpanded
=
false
;
}
await
this
.
waitUntilStable
(
)
;
let
collapsedWidth
=
await
new
Promise
(
resolve
=
>
{
requestAnimationFrame
(
(
)
=
>
{
resolve
(
this
.
_getRects
(
[
this
.
sidebarMain
]
)
[
0
]
[
1
]
.
width
)
;
}
)
;
}
)
;
browserEl
.
style
.
setProperty
(
"
-
-
sidebar
-
launcher
-
collapsed
-
width
"
{
collapsedWidth
}
px
)
;
}
getMouseTargetRect
(
)
{
let
launcherRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
SidebarController
.
sidebarMain
)
;
return
{
top
:
launcherRect
.
top
bottom
:
launcherRect
.
bottom
left
:
this
.
_positionStart
?
launcherRect
.
left
:
launcherRect
.
left
+
LAUNCHER_SPLITTER_WIDTH
right
:
this
.
_positionStart
?
launcherRect
.
right
-
LAUNCHER_SPLITTER_WIDTH
:
launcherRect
.
right
}
;
}
async
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
popupshown
"
:
if
(
e
.
composedTarget
.
id
!
=
=
"
tab
-
preview
-
panel
"
)
{
this
.
_addHoverStateBlocker
(
)
;
}
break
;
case
"
popuphidden
"
:
if
(
e
.
composedTarget
.
id
!
=
=
"
tab
-
preview
-
panel
"
)
{
await
this
.
_removeHoverStateBlocker
(
)
;
}
break
;
default
:
break
;
}
}
async
toggleExpandOnHover
(
isEnabled
isDragEnded
)
{
document
.
documentElement
.
toggleAttribute
(
"
sidebar
-
expand
-
on
-
hover
"
isEnabled
)
;
if
(
isEnabled
)
{
if
(
!
this
.
_state
)
{
this
.
_state
=
new
this
.
SidebarState
(
this
)
;
}
await
this
.
waitUntilStable
(
)
;
MousePosTracker
.
addListener
(
this
)
;
if
(
!
isDragEnded
)
{
await
this
.
setLauncherCollapsedWidth
(
)
;
}
document
.
addEventListener
(
"
popupshown
"
this
)
;
document
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
sidebarMain
.
buttonGroup
.
style
.
height
=
this
.
_state
.
launcherExpanded
?
"
"
:
"
0
"
;
}
else
{
MousePosTracker
.
removeListener
(
this
)
;
if
(
!
this
.
mouseOverTask
?
.
isFinalized
)
{
this
.
mouseOverTask
?
.
finalize
(
)
;
}
document
.
removeEventListener
(
"
popupshown
"
this
)
;
document
.
removeEventListener
(
"
popuphidden
"
this
)
;
if
(
this
.
_state
.
launcherExpanded
&
&
this
.
_state
.
expandedToolsHeight
!
=
=
undefined
&
&
this
.
sidebarMain
.
buttonGroup
)
{
this
.
sidebarMain
.
buttonGroup
.
style
.
height
=
this
.
_state
.
expandedToolsHeight
;
}
else
if
(
!
this
.
_state
.
launcherExpanded
&
&
this
.
_state
.
collapsedToolsHeight
!
=
=
undefined
&
&
this
.
sidebarMain
.
buttonGroup
)
{
this
.
sidebarMain
.
buttonGroup
.
style
.
height
=
this
.
_state
.
collapsedToolsHeight
;
}
}
document
.
documentElement
.
toggleAttribute
(
"
sidebar
-
expand
-
on
-
hover
"
isEnabled
)
;
}
recordVisibilitySetting
(
value
=
this
.
sidebarRevampVisibility
)
{
let
visibilitySetting
=
"
hide
"
;
if
(
value
=
=
=
"
always
-
show
"
)
{
visibilitySetting
=
"
always
"
;
}
else
if
(
value
=
=
=
"
expand
-
on
-
hover
"
)
{
visibilitySetting
=
"
expand
-
on
-
hover
"
;
}
Glean
.
sidebar
.
displaySettings
.
set
(
visibilitySetting
)
;
}
recordPositionSetting
(
value
=
this
.
_positionStart
)
{
Glean
.
sidebar
.
positionSettings
.
set
(
value
!
=
=
RTL_UI
?
"
left
"
:
"
right
"
)
;
}
recordTabsLayoutSetting
(
value
=
this
.
sidebarVerticalTabsEnabled
)
{
Glean
.
sidebar
.
tabsLayout
.
set
(
value
?
"
vertical
"
:
"
horizontal
"
)
;
}
}
;
ChromeUtils
.
defineESModuleGetters
(
SidebarController
{
SidebarManager
:
"
moz
-
src
:
/
/
/
browser
/
components
/
sidebar
/
SidebarManager
.
sys
.
mjs
"
SidebarState
:
"
moz
-
src
:
/
/
/
browser
/
components
/
sidebar
/
SidebarState
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
_positionStart
"
SidebarController
.
POSITION_START_PREF
true
(
_aPreference
_previousValue
newValue
)
=
>
{
if
(
!
SidebarController
.
uninitializing
&
&
!
SidebarController
.
inSingleTabWindow
)
{
SidebarController
.
setPosition
(
)
;
SidebarController
.
recordPositionSetting
(
newValue
)
;
}
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
_animationEnabled
"
"
sidebar
.
animation
.
enabled
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
_animationDurationMs
"
"
sidebar
.
animation
.
duration
-
ms
"
200
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
_animationExpandOnHoverDurationMs
"
"
sidebar
.
animation
.
expand
-
on
-
hover
.
duration
-
ms
"
400
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
sidebarRevampEnabled
"
"
sidebar
.
revamp
"
false
(
_aPreference
_previousValue
newValue
)
=
>
{
if
(
!
SidebarController
.
uninitializing
)
{
SidebarController
.
toggleRevampSidebar
(
)
;
SidebarController
.
_state
.
revampEnabled
=
newValue
;
}
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
sidebarRevampTools
"
"
sidebar
.
main
.
tools
"
"
"
(
)
=
>
{
if
(
!
SidebarController
.
inSingleTabWindow
&
&
!
SidebarController
.
uninitializing
)
{
SidebarController
.
refreshTools
(
)
;
}
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
installedExtensions
"
"
sidebar
.
installed
.
extensions
"
"
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
sidebarRevampVisibility
"
"
sidebar
.
visibility
"
"
always
-
show
"
(
_aPreference
_previousValue
newValue
)
=
>
{
if
(
!
SidebarController
.
inSingleTabWindow
&
&
!
SidebarController
.
uninitializing
)
{
SidebarController
.
toggleExpandOnHover
(
newValue
=
=
=
"
expand
-
on
-
hover
"
)
;
SidebarController
.
recordVisibilitySetting
(
newValue
)
;
if
(
SidebarController
.
_state
)
{
const
isVerticalTabs
=
Services
.
prefs
.
getBoolPref
(
"
sidebar
.
verticalTabs
"
)
;
SidebarController
.
_state
.
revampVisibility
=
newValue
;
if
(
SidebarController
.
_animationEnabled
&
&
!
window
.
gReduceMotion
&
&
newValue
!
=
=
"
expand
-
on
-
hover
"
)
{
SidebarController
.
_animateSidebarMain
(
)
;
}
let
forceExpand
=
false
;
if
(
isVerticalTabs
&
&
[
"
always
-
show
"
"
hide
-
sidebar
"
]
.
includes
(
newValue
)
)
{
forceExpand
=
true
;
}
let
showLauncher
=
true
;
if
(
newValue
=
=
"
hide
-
sidebar
"
&
&
isVerticalTabs
)
{
showLauncher
=
false
;
}
SidebarController
.
_state
.
updateVisibility
(
showLauncher
forceExpand
)
;
}
SidebarController
.
updateToolbarButton
(
)
;
}
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
sidebarVerticalTabsEnabled
"
"
sidebar
.
verticalTabs
"
false
(
_aPreference
_previousValue
newValue
)
=
>
{
if
(
!
SidebarController
.
uninitializing
&
&
!
SidebarController
.
inSingleTabWindow
)
{
SidebarController
.
recordTabsLayoutSetting
(
newValue
)
;
if
(
newValue
)
{
SidebarController
.
_enablePinnedTabsSplitterDragging
(
)
;
}
else
{
SidebarController
.
_disablePinnedTabsDragging
(
)
;
}
SidebarController
.
_state
.
updatePinnedTabsHeight
(
)
;
SidebarController
.
_state
.
updateToolsHeight
(
)
;
}
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
revampDefaultLauncherVisible
"
"
sidebar
.
revamp
.
defaultLauncherVisible
"
false
(
_aPreference
_previousValue
_newValue
)
=
>
{
if
(
!
SidebarController
.
uninitializing
&
&
!
SidebarController
.
inSingleTabWindow
)
{
SidebarController
.
_state
.
updateVisibility
(
)
;
}
}
)
;
