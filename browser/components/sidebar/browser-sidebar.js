var
SidebarController
=
{
makeSidebar
(
{
elementId
.
.
.
rest
}
)
{
return
{
get
sourceL10nEl
(
)
{
return
document
.
getElementById
(
elementId
)
;
}
get
title
(
)
{
return
document
.
getElementById
(
elementId
)
.
getAttribute
(
"
label
"
)
;
}
.
.
.
rest
}
;
}
registerPrefSidebar
(
pref
commandID
config
)
{
const
sidebar
=
this
.
makeSidebar
(
config
)
;
this
.
_sidebars
.
set
(
commandID
sidebar
)
;
let
switcherMenuitem
;
const
updateMenus
=
visible
=
>
{
const
viewItem
=
document
.
getElementById
(
sidebar
.
menuId
)
;
viewItem
.
hidden
=
!
visible
;
if
(
visible
)
{
switcherMenuitem
=
this
.
createMenuItem
(
commandID
sidebar
)
;
switcherMenuitem
.
setAttribute
(
"
id
"
config
.
elementId
)
;
switcherMenuitem
.
removeAttribute
(
"
type
"
)
;
const
separator
=
this
.
_switcherPanel
.
querySelector
(
"
menuseparator
"
)
;
separator
.
parentNode
.
insertBefore
(
switcherMenuitem
separator
)
;
}
else
{
switcherMenuitem
?
.
remove
(
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
sidebar
"
visible
"
pref
false
(
_pref
_prev
val
)
=
>
updateMenus
(
val
)
)
;
this
.
promiseInitialized
.
then
(
(
)
=
>
updateMenus
(
sidebar
.
visible
)
)
;
}
get
sidebars
(
)
{
if
(
this
.
_sidebars
)
{
return
this
.
_sidebars
;
}
this
.
_sidebars
=
new
Map
(
[
[
"
viewHistorySidebar
"
this
.
makeSidebar
(
{
elementId
:
"
sidebar
-
switcher
-
history
"
url
:
this
.
sidebarRevampEnabled
?
"
chrome
:
/
/
browser
/
content
/
sidebar
/
sidebar
-
history
.
html
"
:
"
chrome
:
/
/
browser
/
content
/
places
/
historySidebar
.
xhtml
"
menuId
:
"
menu_historySidebar
"
triggerButtonId
:
"
appMenuViewHistorySidebar
"
keyId
:
"
key_gotoHistory
"
menuL10nId
:
"
menu
-
view
-
history
-
button
"
revampL10nId
:
"
sidebar
-
menu
-
history
"
iconUrl
:
"
chrome
:
/
/
browser
/
content
/
firefoxview
/
view
-
history
.
svg
"
}
)
]
[
"
viewTabsSidebar
"
this
.
makeSidebar
(
{
elementId
:
"
sidebar
-
switcher
-
tabs
"
url
:
this
.
sidebarRevampEnabled
?
"
chrome
:
/
/
browser
/
content
/
sidebar
/
sidebar
-
syncedtabs
.
html
"
:
"
chrome
:
/
/
browser
/
content
/
syncedtabs
/
sidebar
.
xhtml
"
menuId
:
"
menu_tabsSidebar
"
classAttribute
:
"
sync
-
ui
-
item
"
menuL10nId
:
"
menu
-
view
-
synced
-
tabs
-
sidebar
"
revampL10nId
:
"
sidebar
-
menu
-
synced
-
tabs
"
iconUrl
:
"
chrome
:
/
/
browser
/
content
/
firefoxview
/
view
-
syncedtabs
.
svg
"
}
)
]
[
"
viewBookmarksSidebar
"
this
.
makeSidebar
(
{
elementId
:
"
sidebar
-
switcher
-
bookmarks
"
url
:
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarksSidebar
.
xhtml
"
menuId
:
"
menu_bookmarksSidebar
"
keyId
:
"
viewBookmarksSidebarKb
"
menuL10nId
:
"
menu
-
view
-
bookmarks
"
revampL10nId
:
"
sidebar
-
menu
-
bookmarks
"
iconUrl
:
"
chrome
:
/
/
browser
/
skin
/
bookmark
-
hollow
.
svg
"
disabled
:
true
}
)
]
]
)
;
if
(
!
this
.
sidebarRevampEnabled
)
{
this
.
registerPrefSidebar
(
"
browser
.
megalist
.
enabled
"
"
viewMegalistSidebar
"
{
elementId
:
"
sidebar
-
switcher
-
megalist
"
url
:
"
chrome
:
/
/
global
/
content
/
megalist
/
megalist
.
html
"
menuId
:
"
menu_megalistSidebar
"
menuL10nId
:
"
menu
-
view
-
megalist
-
sidebar
"
revampL10nId
:
"
sidebar
-
menu
-
megalist
"
}
)
;
}
else
{
this
.
_sidebars
.
set
(
"
viewCustomizeSidebar
"
{
url
:
"
chrome
:
/
/
browser
/
content
/
sidebar
/
sidebar
-
customize
.
html
"
revampL10nId
:
"
sidebar
-
menu
-
customize
"
iconUrl
:
"
chrome
:
/
/
browser
/
skin
/
preferences
/
category
-
general
.
svg
"
}
)
;
}
return
this
.
_sidebars
;
}
get
toolsAndExtensions
(
)
{
if
(
this
.
_toolsAndExtensions
)
{
return
this
.
_toolsAndExtensions
;
}
this
.
_toolsAndExtensions
=
new
Map
(
)
;
this
.
getTools
(
)
.
forEach
(
tool
=
>
{
this
.
_toolsAndExtensions
.
set
(
tool
.
commandID
tool
)
;
}
)
;
this
.
getExtensions
(
)
.
forEach
(
extension
=
>
{
this
.
_toolsAndExtensions
.
set
(
extension
.
commandID
extension
)
;
}
)
;
return
this
.
_toolsAndExtensions
;
}
get
browser
(
)
{
if
(
this
.
_browser
)
{
return
this
.
_browser
;
}
return
(
this
.
_browser
=
document
.
getElementById
(
"
sidebar
"
)
)
;
}
POSITION_START_PREF
:
"
sidebar
.
position_start
"
DEFAULT_SIDEBAR_ID
:
"
viewBookmarksSidebar
"
lastOpenedId
:
null
_box
:
null
get
_title
(
)
{
if
(
this
.
__title
)
{
return
this
.
__title
;
}
return
(
this
.
__title
=
document
.
getElementById
(
"
sidebar
-
title
"
)
)
;
}
_splitter
:
null
_reversePositionButton
:
null
_switcherPanel
:
null
_switcherTarget
:
null
_switcherArrow
:
null
_inited
:
false
_observer
:
null
_initDeferred
:
Promise
.
withResolvers
(
)
get
promiseInitialized
(
)
{
return
this
.
_initDeferred
.
promise
;
}
get
initialized
(
)
{
return
this
.
_inited
;
}
async
init
(
)
{
this
.
_box
=
document
.
getElementById
(
"
sidebar
-
box
"
)
;
this
.
_splitter
=
document
.
getElementById
(
"
sidebar
-
splitter
"
)
;
this
.
_reversePositionButton
=
document
.
getElementById
(
"
sidebar
-
reverse
-
position
"
)
;
this
.
_switcherPanel
=
document
.
getElementById
(
"
sidebarMenu
-
popup
"
)
;
this
.
_switcherTarget
=
document
.
getElementById
(
"
sidebar
-
switcher
-
target
"
)
;
this
.
_switcherArrow
=
document
.
getElementById
(
"
sidebar
-
switcher
-
arrow
"
)
;
const
menubar
=
document
.
getElementById
(
"
viewSidebarMenu
"
)
;
for
(
const
[
commandID
sidebar
]
of
this
.
sidebars
.
entries
(
)
)
{
if
(
!
Object
.
hasOwn
(
sidebar
"
extensionId
"
)
&
&
commandID
!
=
=
"
viewCustomizeSidebar
"
)
{
const
menuitem
=
this
.
createMenuItem
(
commandID
sidebar
)
;
menubar
.
appendChild
(
menuitem
)
;
}
}
if
(
this
.
sidebarRevampEnabled
)
{
await
import
(
"
chrome
:
/
/
browser
/
content
/
sidebar
/
sidebar
-
main
.
mjs
"
)
;
document
.
getElementById
(
"
sidebar
-
main
"
)
.
hidden
=
!
window
.
toolbar
.
visible
;
document
.
getElementById
(
"
sidebar
-
header
"
)
.
hidden
=
true
;
this
.
_sidebarMain
=
document
.
querySelector
(
"
sidebar
-
main
"
)
;
}
else
{
this
.
_switcherTarget
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
toggleSwitcherPanel
(
)
;
}
)
;
this
.
_switcherTarget
.
addEventListener
(
"
keydown
"
event
=
>
{
this
.
handleKeydown
(
event
)
;
}
)
;
}
this
.
_inited
=
true
;
Services
.
obs
.
addObserver
(
this
"
intl
:
app
-
locales
-
changed
"
)
;
this
.
_initDeferred
.
resolve
(
)
;
}
uninit
(
)
{
let
enumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
if
(
!
enumerator
.
hasMoreElements
(
)
)
{
let
xulStore
=
Services
.
xulStore
;
xulStore
.
persist
(
this
.
_title
"
value
"
)
;
}
Services
.
obs
.
removeObserver
(
this
"
intl
:
app
-
locales
-
changed
"
)
;
if
(
this
.
_observer
)
{
this
.
_observer
.
disconnect
(
)
;
this
.
_observer
=
null
;
}
}
observe
(
_subject
topic
_data
)
{
switch
(
topic
)
{
case
"
intl
:
app
-
locales
-
changed
"
:
{
if
(
this
.
isOpen
)
{
this
.
hide
(
)
;
this
.
showInitially
(
this
.
lastOpenedId
)
;
break
;
}
}
}
}
observeTitleChanges
(
element
)
{
if
(
!
element
)
{
return
;
}
let
observer
=
this
.
_observer
;
if
(
!
observer
)
{
observer
=
new
MutationObserver
(
(
)
=
>
{
this
.
title
=
this
.
sidebars
.
get
(
this
.
lastOpenedId
)
.
title
;
}
)
;
this
.
_observer
=
observer
;
}
observer
.
disconnect
(
)
;
observer
.
observe
(
element
{
attributes
:
true
attributeFilter
:
[
"
label
"
]
}
)
;
}
toggleSwitcherPanel
(
)
{
if
(
this
.
_switcherPanel
.
state
=
=
"
open
"
|
|
this
.
_switcherPanel
.
state
=
=
"
showing
"
)
{
this
.
hideSwitcherPanel
(
)
;
}
else
if
(
this
.
_switcherPanel
.
state
=
=
"
closed
"
)
{
this
.
showSwitcherPanel
(
)
;
}
}
handleKeydown
(
event
)
{
switch
(
event
.
key
)
{
case
"
Enter
"
:
case
"
"
:
{
this
.
toggleSwitcherPanel
(
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
break
;
}
case
"
Escape
"
:
{
this
.
hideSwitcherPanel
(
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
break
;
}
}
}
hideSwitcherPanel
(
)
{
this
.
_switcherPanel
.
hidePopup
(
)
;
}
showSwitcherPanel
(
)
{
this
.
_switcherPanel
.
addEventListener
(
"
popuphiding
"
(
)
=
>
{
this
.
_switcherTarget
.
classList
.
remove
(
"
active
"
)
;
this
.
_switcherTarget
.
setAttribute
(
"
aria
-
expanded
"
false
)
;
}
{
once
:
true
}
)
;
let
label
=
this
.
_positionStart
=
=
RTL_UI
?
gNavigatorBundle
.
getString
(
"
sidebar
.
moveToLeft
"
)
:
gNavigatorBundle
.
getString
(
"
sidebar
.
moveToRight
"
)
;
this
.
_reversePositionButton
.
setAttribute
(
"
label
"
label
)
;
this
.
_switcherPanel
.
hidden
=
false
;
this
.
_switcherPanel
.
openPopup
(
this
.
_switcherTarget
)
;
this
.
_switcherTarget
.
classList
.
add
(
"
active
"
)
;
this
.
_switcherTarget
.
setAttribute
(
"
aria
-
expanded
"
true
)
;
}
updateShortcut
(
{
keyId
}
)
{
let
menuitem
=
this
.
_switcherPanel
?
.
querySelector
(
[
key
=
"
{
keyId
}
"
]
)
;
if
(
!
menuitem
)
{
return
;
}
menuitem
.
removeAttribute
(
"
acceltext
"
)
;
}
reversePosition
(
)
{
Services
.
prefs
.
setBoolPref
(
this
.
POSITION_START_PREF
!
this
.
_positionStart
)
;
}
setPosition
(
)
{
let
browser
=
document
.
getElementById
(
"
browser
"
)
;
[
.
.
.
browser
.
children
]
.
forEach
(
(
node
i
)
=
>
{
node
.
style
.
order
=
i
+
1
;
}
)
;
let
sidebarMain
=
document
.
getElementById
(
"
sidebar
-
main
"
)
;
if
(
!
this
.
_positionStart
)
{
let
appcontent
=
document
.
getElementById
(
"
appcontent
"
)
;
let
boxOrdinal
=
this
.
_box
.
style
.
order
;
this
.
_box
.
style
.
order
=
appcontent
.
style
.
order
;
appcontent
.
style
.
order
=
boxOrdinal
;
sidebarMain
.
style
.
order
=
parseInt
(
this
.
_box
.
style
.
order
)
+
1
;
this
.
_box
.
setAttribute
(
"
positionend
"
true
)
;
sidebarMain
.
setAttribute
(
"
positionend
"
true
)
;
}
else
{
this
.
_box
.
removeAttribute
(
"
positionend
"
)
;
sidebarMain
.
removeAttribute
(
"
positionend
"
)
;
}
this
.
hideSwitcherPanel
(
)
;
let
content
=
SidebarController
.
browser
.
contentWindow
;
if
(
content
&
&
content
.
updatePosition
)
{
content
.
updatePosition
(
)
;
}
}
adoptFromWindow
(
sourceWindow
)
{
let
sourceController
=
sourceWindow
.
SidebarController
;
if
(
!
sourceController
|
|
!
sourceController
.
_box
)
{
return
false
;
}
if
(
!
window
.
toolbar
.
visible
&
&
this
.
sidebarRevampEnabled
)
{
document
.
getElementById
(
"
sidebar
-
main
"
)
.
hidden
=
true
;
return
false
;
}
let
commandID
=
sourceController
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
;
if
(
commandID
)
{
this
.
_box
.
setAttribute
(
"
sidebarcommand
"
commandID
)
;
}
if
(
sourceController
.
_box
.
hidden
)
{
return
true
;
}
if
(
!
this
.
sidebars
.
has
(
commandID
)
)
{
return
true
;
}
this
.
_box
.
style
.
width
=
sourceController
.
_box
.
getBoundingClientRect
(
)
.
width
+
"
px
"
;
this
.
showInitially
(
commandID
)
;
return
true
;
}
windowPrivacyMatches
(
w1
w2
)
{
return
(
PrivateBrowsingUtils
.
isWindowPrivate
(
w1
)
=
=
=
PrivateBrowsingUtils
.
isWindowPrivate
(
w2
)
)
;
}
startDelayedLoad
(
)
{
let
sourceWindow
=
window
.
opener
;
if
(
sourceWindow
)
{
if
(
sourceWindow
.
closed
|
|
sourceWindow
.
location
.
protocol
!
=
"
chrome
:
"
|
|
!
this
.
windowPrivacyMatches
(
sourceWindow
window
)
)
{
return
;
}
if
(
this
.
adoptFromWindow
(
sourceWindow
)
)
{
return
;
}
}
let
wasOpen
=
this
.
_box
.
getAttribute
(
"
checked
"
)
;
if
(
!
wasOpen
)
{
return
;
}
let
commandID
=
this
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
;
if
(
commandID
&
&
this
.
sidebars
.
has
(
commandID
)
)
{
this
.
showInitially
(
commandID
)
;
}
else
{
this
.
_box
.
removeAttribute
(
"
checked
"
)
;
this
.
_box
.
setAttribute
(
"
sidebarcommand
"
"
"
)
;
this
.
lastOpenedId
=
commandID
;
}
}
_fireShowEvent
(
)
{
let
event
=
new
CustomEvent
(
"
SidebarShown
"
{
bubbles
:
true
}
)
;
this
.
_switcherTarget
.
dispatchEvent
(
event
)
;
}
_fireFocusedEvent
(
)
{
let
event
=
new
CustomEvent
(
"
SidebarFocused
"
{
bubbles
:
true
}
)
;
this
.
browser
.
contentWindow
.
dispatchEvent
(
event
)
;
}
get
isOpen
(
)
{
return
!
this
.
_box
.
hidden
;
}
get
currentID
(
)
{
return
this
.
isOpen
?
this
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
:
"
"
;
}
get
title
(
)
{
return
this
.
_title
.
value
;
}
set
title
(
value
)
{
this
.
_title
.
value
=
value
;
}
toggle
(
commandID
=
this
.
lastOpenedId
triggerNode
)
{
if
(
CustomizationHandler
.
isCustomizing
(
)
|
|
CustomizationHandler
.
isExitingCustomizeMode
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
commandID
)
{
commandID
=
this
.
_box
.
getAttribute
(
"
sidebarcommand
"
)
;
}
if
(
!
commandID
|
|
!
this
.
sidebars
.
has
(
commandID
)
)
{
if
(
this
.
sidebarRevampEnabled
&
&
this
.
sidebars
.
size
)
{
commandID
=
this
.
sidebars
.
keys
(
)
.
next
(
)
.
value
;
}
else
{
commandID
=
this
.
DEFAULT_SIDEBAR_ID
;
}
}
if
(
this
.
isOpen
&
&
commandID
=
=
this
.
currentID
)
{
this
.
hide
(
triggerNode
)
;
return
Promise
.
resolve
(
)
;
}
return
this
.
show
(
commandID
triggerNode
)
;
}
toggleExpanded
(
)
{
this
.
_sidebarMain
.
expanded
=
!
this
.
_sidebarMain
.
expanded
;
}
_loadSidebarExtension
(
commandID
)
{
let
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
if
(
typeof
sidebar
.
onload
=
=
=
"
function
"
)
{
sidebar
.
onload
(
)
;
}
}
toggleTool
(
commandID
)
{
let
toggledTool
=
this
.
toolsAndExtensions
.
get
(
commandID
)
;
toggledTool
.
disabled
=
!
toggledTool
.
disabled
;
if
(
!
toggledTool
.
disabled
)
{
this
.
toolsAndExtensions
.
delete
(
commandID
)
;
this
.
toolsAndExtensions
.
set
(
commandID
toggledTool
)
;
}
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemChanged
"
)
)
;
}
addOrUpdateExtension
(
commandID
extension
)
{
if
(
this
.
toolsAndExtensions
.
has
(
commandID
)
)
{
let
extensionToUpdate
=
this
.
toolsAndExtensions
.
get
(
commandID
)
;
extensionToUpdate
.
icon
=
extension
.
icon
;
extensionToUpdate
.
iconUrl
=
extension
.
iconUrl
;
extensionToUpdate
.
tooltiptext
=
extension
.
label
;
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemChanged
"
)
)
;
}
else
{
this
.
toolsAndExtensions
.
set
(
commandID
{
view
:
commandID
extensionId
:
extension
.
extensionId
icon
:
extension
.
icon
iconUrl
:
extension
.
iconUrl
tooltiptext
:
extension
.
label
disabled
:
false
}
)
;
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemAdded
"
)
)
;
}
}
registerExtension
(
commandID
props
)
{
const
sidebar
=
{
title
:
props
.
title
url
:
"
chrome
:
/
/
browser
/
content
/
webext
-
panels
.
xhtml
"
menuId
:
props
.
menuId
switcherMenuId
:
sidebarswitcher_menu_
{
commandID
}
keyId
:
ext
-
key
-
id
-
{
commandID
}
label
:
props
.
title
icon
:
props
.
icon
iconUrl
:
props
.
iconUrl
classAttribute
:
"
menuitem
-
iconic
webextension
-
menuitem
"
extensionId
:
props
.
extensionId
onload
:
props
.
onload
}
;
this
.
sidebars
.
set
(
commandID
sidebar
)
;
const
menuitem
=
this
.
createMenuItem
(
commandID
sidebar
)
;
document
.
getElementById
(
"
viewSidebarMenu
"
)
.
appendChild
(
menuitem
)
;
this
.
addOrUpdateExtension
(
commandID
sidebar
)
;
if
(
!
this
.
sidebarRevampEnabled
)
{
let
switcherMenuitem
=
this
.
createMenuItem
(
commandID
sidebar
)
;
switcherMenuitem
.
setAttribute
(
"
id
"
sidebar
.
switcherMenuId
)
;
switcherMenuitem
.
removeAttribute
(
"
type
"
)
;
let
separator
=
document
.
getElementById
(
"
sidebar
-
extensions
-
separator
"
)
;
separator
.
parentNode
.
insertBefore
(
switcherMenuitem
separator
)
;
}
this
.
_setExtensionAttributes
(
commandID
{
icon
:
props
.
icon
iconUrl
:
props
.
iconUrl
label
:
props
.
title
}
sidebar
)
;
}
createMenuItem
(
commandID
sidebar
)
{
const
menuitem
=
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
id
"
sidebar
.
menuId
)
;
menuitem
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
menuitem
.
addEventListener
(
"
command
"
(
)
=
>
this
.
toggle
(
commandID
)
)
;
if
(
sidebar
.
classAttribute
)
{
menuitem
.
setAttribute
(
"
class
"
sidebar
.
classAttribute
)
;
}
if
(
sidebar
.
keyId
)
{
menuitem
.
setAttribute
(
"
key
"
sidebar
.
keyId
)
;
}
if
(
sidebar
.
menuL10nId
)
{
menuitem
.
dataset
.
l10nId
=
sidebar
.
menuL10nId
;
}
if
(
!
window
.
toolbar
.
visible
)
{
menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
return
menuitem
;
}
setExtensionAttributes
(
commandID
attributes
needsRefresh
)
{
const
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
this
.
_setExtensionAttributes
(
commandID
attributes
sidebar
needsRefresh
)
;
this
.
addOrUpdateExtension
(
commandID
sidebar
)
;
}
_setExtensionAttributes
(
commandID
{
icon
iconUrl
label
}
sidebar
needsRefresh
=
false
)
{
sidebar
.
icon
=
icon
;
sidebar
.
iconUrl
=
iconUrl
;
sidebar
.
label
=
label
;
const
updateAttributes
=
el
=
>
{
el
.
style
.
setProperty
(
"
-
-
webextension
-
menuitem
-
image
"
sidebar
.
icon
)
;
el
.
setAttribute
(
"
label
"
sidebar
.
label
)
;
}
;
updateAttributes
(
document
.
getElementById
(
sidebar
.
menuId
)
sidebar
)
;
const
switcherMenu
=
document
.
getElementById
(
sidebar
.
switcherMenuId
)
;
if
(
switcherMenu
)
{
updateAttributes
(
switcherMenu
sidebar
)
;
}
if
(
this
.
initialized
&
&
this
.
currentID
=
=
=
commandID
)
{
updateAttributes
(
this
.
_switcherTarget
sidebar
)
;
this
.
title
=
label
;
if
(
this
.
isOpen
&
&
needsRefresh
)
{
this
.
show
(
commandID
)
;
}
}
}
getExtensions
(
)
{
const
extensions
=
[
]
;
for
(
const
[
commandID
sidebar
]
of
this
.
sidebars
.
entries
(
)
)
{
if
(
Object
.
hasOwn
(
sidebar
"
extensionId
"
)
)
{
extensions
.
push
(
{
commandID
view
:
commandID
extensionId
:
sidebar
.
extensionId
iconUrl
:
sidebar
.
iconUrl
tooltiptext
:
sidebar
.
label
disabled
:
false
}
)
;
}
}
return
extensions
;
}
getTools
(
)
{
const
toolIds
=
[
"
viewHistorySidebar
"
"
viewTabsSidebar
"
"
viewBookmarksSidebar
"
]
;
return
toolIds
.
map
(
commandID
=
>
{
const
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
return
{
commandID
view
:
commandID
iconUrl
:
sidebar
.
iconUrl
l10nId
:
sidebar
.
revampL10nId
disabled
:
sidebar
.
disabled
?
?
false
}
;
}
)
;
}
removeExtension
(
commandID
)
{
const
sidebar
=
this
.
sidebars
.
get
(
commandID
)
;
if
(
!
sidebar
)
{
return
;
}
if
(
this
.
currentID
=
=
=
commandID
)
{
this
.
hide
(
)
;
}
document
.
getElementById
(
sidebar
.
menuId
)
?
.
remove
(
)
;
document
.
getElementById
(
sidebar
.
switcherMenuId
)
?
.
remove
(
)
;
this
.
sidebars
.
delete
(
commandID
)
;
this
.
toolsAndExtensions
.
delete
(
commandID
)
;
window
.
dispatchEvent
(
new
CustomEvent
(
"
SidebarItemRemoved
"
)
)
;
}
async
show
(
commandID
triggerNode
)
{
let
panelType
=
commandID
.
substring
(
4
commandID
.
length
-
7
)
;
Services
.
telemetry
.
keyedScalarAdd
(
"
sidebar
.
opened
"
panelType
1
)
;
if
(
!
this
.
sidebars
.
has
(
commandID
)
)
{
return
false
;
}
return
this
.
_show
(
commandID
)
.
then
(
(
)
=
>
{
this
.
_loadSidebarExtension
(
commandID
)
;
if
(
triggerNode
)
{
updateToggleControlLabel
(
triggerNode
)
;
}
this
.
_fireFocusedEvent
(
)
;
return
true
;
}
)
;
}
async
showInitially
(
commandID
)
{
let
panelType
=
commandID
.
substring
(
4
commandID
.
length
-
7
)
;
Services
.
telemetry
.
keyedScalarAdd
(
"
sidebar
.
opened
"
panelType
1
)
;
if
(
!
this
.
sidebars
.
has
(
commandID
)
)
{
return
false
;
}
return
this
.
_show
(
commandID
)
.
then
(
(
)
=
>
{
this
.
_loadSidebarExtension
(
commandID
)
;
return
true
;
}
)
;
}
_show
(
commandID
)
{
return
new
Promise
(
resolve
=
>
{
if
(
this
.
sidebarRevampEnabled
)
{
this
.
_box
.
dispatchEvent
(
new
CustomEvent
(
"
sidebar
-
show
"
{
detail
:
{
viewId
:
commandID
}
}
)
)
;
}
else
{
this
.
hideSwitcherPanel
(
)
;
}
this
.
selectMenuItem
(
commandID
)
;
this
.
_box
.
hidden
=
this
.
_splitter
.
hidden
=
false
;
this
.
setPosition
(
)
;
this
.
_box
.
setAttribute
(
"
checked
"
"
true
"
)
;
this
.
_box
.
setAttribute
(
"
sidebarcommand
"
commandID
)
;
let
{
icon
url
title
sourceL10nEl
}
=
this
.
sidebars
.
get
(
commandID
)
;
if
(
icon
)
{
this
.
_switcherTarget
.
style
.
setProperty
(
"
-
-
webextension
-
menuitem
-
image
"
icon
)
;
}
else
{
this
.
_switcherTarget
.
style
.
removeProperty
(
"
-
-
webextension
-
menuitem
-
image
"
)
;
}
this
.
lastOpenedId
=
commandID
;
if
(
!
this
.
sidebarRevampEnabled
)
{
this
.
title
=
title
;
this
.
observeTitleChanges
(
sourceL10nEl
)
;
}
this
.
browser
.
setAttribute
(
"
src
"
url
)
;
if
(
this
.
browser
.
contentDocument
.
location
.
href
!
=
url
)
{
this
.
browser
.
addEventListener
(
"
load
"
(
)
=
>
{
setTimeout
(
(
)
=
>
{
resolve
(
)
;
this
.
_fireShowEvent
(
)
;
}
0
)
;
}
{
capture
:
true
once
:
true
}
)
;
}
else
{
resolve
(
)
;
this
.
_fireShowEvent
(
)
;
}
}
)
;
}
hide
(
triggerNode
)
{
if
(
!
this
.
isOpen
)
{
return
;
}
this
.
hideSwitcherPanel
(
)
;
if
(
this
.
sidebarRevampEnabled
)
{
this
.
_box
.
dispatchEvent
(
new
CustomEvent
(
"
sidebar
-
hide
"
)
)
;
}
this
.
selectMenuItem
(
"
"
)
;
this
.
browser
.
setAttribute
(
"
src
"
"
about
:
blank
"
)
;
this
.
browser
.
docShell
.
createAboutBlankDocumentViewer
(
null
null
)
;
this
.
_box
.
removeAttribute
(
"
checked
"
)
;
this
.
_box
.
hidden
=
this
.
_splitter
.
hidden
=
true
;
let
selBrowser
=
gBrowser
.
selectedBrowser
;
selBrowser
.
focus
(
)
;
if
(
triggerNode
)
{
updateToggleControlLabel
(
triggerNode
)
;
}
}
selectMenuItem
(
commandID
)
{
for
(
let
[
id
{
menuId
triggerButtonId
}
]
of
this
.
sidebars
)
{
let
menu
=
document
.
getElementById
(
menuId
)
;
if
(
!
menu
)
{
return
;
}
let
triggerbutton
=
triggerButtonId
&
&
document
.
getElementById
(
triggerButtonId
)
;
if
(
id
=
=
commandID
)
{
menu
.
setAttribute
(
"
checked
"
"
true
"
)
;
if
(
triggerbutton
)
{
triggerbutton
.
setAttribute
(
"
checked
"
"
true
"
)
;
updateToggleControlLabel
(
triggerbutton
)
;
}
}
else
{
menu
.
removeAttribute
(
"
checked
"
)
;
if
(
triggerbutton
)
{
triggerbutton
.
removeAttribute
(
"
checked
"
)
;
updateToggleControlLabel
(
triggerbutton
)
;
}
}
}
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
_positionStart
"
SidebarController
.
POSITION_START_PREF
true
SidebarController
.
setPosition
.
bind
(
SidebarController
)
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SidebarController
"
sidebarRevampEnabled
"
"
sidebar
.
revamp
"
false
)
;
