let
isRounded
=
(
x
expectedPrecision
)
=
>
{
let
rounded
=
Math
.
floor
(
x
/
expectedPrecision
)
*
expectedPrecision
;
if
(
rounded
=
=
=
x
|
|
x
=
=
=
0
)
{
return
true
;
}
if
(
Math
.
abs
(
rounded
-
x
+
expectedPrecision
)
<
0
.
0005
)
{
return
true
;
}
else
if
(
Math
.
abs
(
rounded
-
x
)
<
0
.
0005
)
{
return
true
;
}
if
(
expectedPrecision
<
1
&
&
Math
.
round
(
x
)
=
=
x
)
{
if
(
Math
.
round
(
rounded
)
=
=
x
)
{
return
true
;
}
}
ok
(
false
"
Looming
Test
Failure
Additional
Debugging
Info
:
Expected
Precision
:
"
+
expectedPrecision
+
"
Measured
Value
:
"
+
x
+
"
Rounded
Vaue
:
"
+
rounded
+
"
Fuzzy1
:
"
+
Math
.
abs
(
rounded
-
x
+
expectedPrecision
)
+
"
Fuzzy
2
:
"
+
Math
.
abs
(
rounded
-
x
)
)
;
return
false
;
}
;
let
setupTest
=
async
function
(
resistFingerprinting
reduceTimerPrecision
crossOriginIsolated
expectedPrecision
runTests
workerCall
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
resistFingerprinting
]
[
"
privacy
.
reduceTimerPrecision
"
reduceTimerPrecision
]
[
"
privacy
.
resistFingerprinting
.
reduceTimerPrecision
.
microseconds
"
expectedPrecision
*
1000
]
[
"
browser
.
tabs
.
remote
.
useCrossOriginOpenerPolicy
"
crossOriginIsolated
]
[
"
browser
.
tabs
.
remote
.
useCrossOriginEmbedderPolicy
"
crossOriginIsolated
]
[
"
browser
.
tabs
.
documentchannel
"
crossOriginIsolated
]
]
}
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
https
:
/
/
example
.
com
/
browser
/
browser
/
components
/
resistfingerprinting
+
/
test
/
browser
/
coop_header
.
sjs
?
crossOriginIsolated
=
{
crossOriginIsolated
}
)
;
if
(
resistFingerprinting
)
{
expectedPrecision
=
expectedPrecision
<
100
?
100
:
expectedPrecision
;
}
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
{
precision
:
expectedPrecision
isRoundedFunc
:
isRounded
.
toString
(
)
workerCall
}
]
runTests
)
;
if
(
crossOriginIsolated
)
{
let
remoteType
=
tab
.
linkedBrowser
.
remoteType
;
ok
(
remoteType
.
startsWith
(
E10SUtils
.
WEB_REMOTE_COOP_COEP_TYPE_PREFIX
)
{
remoteType
}
expected
to
be
coop
+
coep
)
;
}
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
;
let
runWorkerTest
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
await
new
Promise
(
resolve
=
>
{
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
worker
=
new
content
.
Worker
(
"
coop_header
.
sjs
?
crossOriginIsolated
=
true
&
worker
=
true
"
)
;
worker
.
postMessage
(
{
type
:
"
runCmdAndGetResult
"
cmd
:
performance
.
timeOrigin
}
)
;
const
expectedAllEntriesLength
=
data
.
workerCall
=
=
"
runRPTests
"
?
0
:
3
;
const
expectedResourceEntriesLength
=
data
.
workerCall
=
=
"
runRPTests
"
?
0
:
2
;
const
expectedTestAndMarkEntriesLength
=
data
.
workerCall
=
=
"
runRPTests
"
?
0
:
1
;
worker
.
onmessage
=
function
(
e
)
{
if
(
e
.
data
.
type
=
=
"
result
"
)
{
if
(
e
.
data
.
resultOf
=
=
"
performance
.
timeOrigin
"
)
{
ok
(
isRounded
(
e
.
data
.
result
expectedPrecision
)
In
a
worker
for
reduceTimerPrecision
performance
.
timeOrigin
is
+
not
correctly
rounded
:
{
e
.
data
.
result
}
)
;
worker
.
postMessage
(
{
type
:
"
runCmds
"
cmds
:
[
performance
.
mark
(
"
Test
"
)
;
performance
.
mark
(
"
Test
-
End
"
)
;
performance
.
measure
(
"
Test
-
Measure
"
"
Test
"
"
Test
-
End
"
)
;
]
}
)
;
}
else
if
(
e
.
data
.
resultOf
=
=
"
entriesLength
"
)
{
is
(
e
.
data
.
result
expectedAllEntriesLength
In
a
worker
for
reduceTimerPrecision
:
Incorrect
number
of
+
entries
for
performance
.
getEntries
(
)
for
workers
:
+
{
e
.
data
.
result
}
)
;
if
(
data
.
workerCall
=
=
"
runRTPTests
"
)
{
worker
.
postMessage
(
{
type
:
"
getResult
"
resultOf
:
"
startTimeAndDuration
"
num
:
0
}
)
;
}
else
{
worker
.
postMessage
(
{
type
:
"
getResult
"
resultOf
:
"
getEntriesByTypeLength
"
}
)
;
}
}
else
if
(
e
.
data
.
resultOf
=
=
"
startTimeAndDuration
"
)
{
let
index
=
e
.
data
.
result
.
index
;
let
startTime
=
e
.
data
.
result
.
startTime
;
let
duration
=
e
.
data
.
result
.
duration
;
ok
(
isRounded
(
startTime
expectedPrecision
)
In
a
worker
for
reduceTimerPrecision
(
{
expectedPrecision
}
+
performance
.
getEntries
(
{
index
}
)
.
startTime
is
not
rounded
:
+
{
startTime
}
)
;
ok
(
isRounded
(
duration
expectedPrecision
)
In
a
worker
for
reduceTimerPrecision
(
{
expectedPrecision
}
)
+
performance
.
getEntries
(
{
index
}
)
.
duration
is
not
rounded
:
+
{
duration
}
)
;
if
(
index
<
2
)
{
worker
.
postMessage
(
{
type
:
"
getResult
"
resultOf
:
"
startTimeAndDuration
"
num
:
index
+
1
}
)
;
}
else
{
worker
.
postMessage
(
{
type
:
"
getResult
"
resultOf
:
"
getEntriesByTypeLength
"
}
)
;
}
}
else
if
(
e
.
data
.
resultOf
=
=
"
entriesByTypeLength
"
)
{
is
(
e
.
data
.
result
.
markLength
expectedResourceEntriesLength
In
a
worker
for
reduceTimerPrecision
:
Incorrect
number
of
+
entries
for
performance
.
getEntriesByType
(
)
for
workers
:
+
{
e
.
data
.
result
.
resourceLength
}
)
;
is
(
e
.
data
.
result
.
testAndMarkLength
expectedTestAndMarkEntriesLength
In
a
worker
for
reduceTimerPrecision
:
Incorrect
number
of
+
entries
for
performance
.
getEntriesByName
(
)
for
workers
:
+
{
e
.
data
.
result
.
testAndMarkLength
}
)
;
worker
.
terminate
(
)
;
resolve
(
)
;
}
}
else
{
ok
(
false
Unknown
message
type
got
{
e
.
data
.
type
}
)
;
worker
.
terminate
(
)
;
resolve
(
)
;
}
}
;
}
)
;
}
;
add_task
(
async
function
runTestsForWorker
(
)
{
await
setupTest
(
true
true
true
100
runWorkerTest
"
runRPTests
"
)
;
await
setupTest
(
true
false
true
13
runWorkerTest
"
runRPTests
"
)
;
await
setupTest
(
true
true
true
0
.
13
runWorkerTest
"
runRPTests
"
)
;
await
setupTest
(
false
true
false
0
.
13
runWorkerTest
"
runRTPTests
"
)
;
await
setupTest
(
false
true
true
0
.
005
runWorkerTest
"
runRTPTests
"
)
;
}
)
;
add_task
(
async
function
runRTPTestDOM
(
)
{
let
runTests
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
audioContext
=
new
content
.
AudioContext
(
)
;
const
timeStampCodes
=
[
"
content
.
performance
.
now
(
)
"
"
new
content
.
Date
(
)
.
getTime
(
)
"
'
new
content
.
Event
(
"
"
)
.
timeStamp
'
'
new
content
.
File
(
[
]
"
"
)
.
lastModified
'
]
;
var
timeStampCodesDOM
=
timeStampCodes
.
concat
(
[
"
audioContext
.
currentTime
*
1000
"
]
)
;
for
(
let
timeStampCode
of
timeStampCodesDOM
)
{
let
timeStamp
=
eval
(
timeStampCode
)
;
if
(
timeStampCode
.
includes
(
"
audioContext
"
)
&
&
expectedPrecision
<
5
.
4
)
{
continue
;
}
ok
(
isRounded
(
timeStamp
expectedPrecision
)
Should
be
rounded
to
nearest
{
expectedPrecision
}
ms
;
saw
{
timeStamp
}
)
;
}
}
;
await
setupTest
(
true
true
true
100
runTests
)
;
await
setupTest
(
true
false
true
13
runTests
)
;
await
setupTest
(
true
false
true
0
.
13
runTests
)
;
await
setupTest
(
false
true
false
0
.
13
runTests
)
;
await
setupTest
(
false
true
true
0
.
005
runTests
)
;
}
)
;
let
runWorkerTest1
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
await
new
Promise
(
resolve
=
>
{
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
worker
=
new
content
.
Worker
(
"
coop_header
.
sjs
?
crossOriginIsolated
=
true
&
worker
=
true
"
)
;
const
timeStampCodes
=
[
"
performance
.
now
(
)
"
"
new
Date
(
)
.
getTime
(
)
"
'
new
Event
(
"
"
)
.
timeStamp
'
'
new
File
(
[
]
"
"
)
.
lastModified
'
]
;
let
promises
=
[
]
;
for
(
let
timeStampCode
of
timeStampCodes
)
{
promises
.
push
(
new
Promise
(
res
=
>
{
worker
.
postMessage
(
{
type
:
"
runCmdAndGetResult
"
cmd
:
timeStampCode
}
)
;
worker
.
addEventListener
(
"
message
"
function
(
e
)
{
if
(
e
.
data
.
type
=
=
"
result
"
)
{
if
(
e
.
data
.
resultOf
=
=
timeStampCode
)
{
ok
(
isRounded
(
e
.
data
.
result
expectedPrecision
)
The
result
of
{
e
.
data
.
resultOf
}
should
be
rounded
to
+
nearest
{
expectedPrecision
}
ms
in
workers
;
saw
+
{
e
.
data
.
result
}
)
;
worker
.
removeEventListener
(
"
message
"
this
)
;
res
(
)
;
}
return
;
}
ok
(
false
Unknown
message
type
.
Got
{
e
.
data
.
type
}
)
;
res
(
)
;
}
)
;
}
)
)
;
}
Promise
.
all
(
promises
)
.
then
(
_
=
>
{
worker
.
terminate
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
;
add_task
(
async
function
runRTPTestsForWorker
(
)
{
await
setupTest
(
true
true
true
100
runWorkerTest1
)
;
await
setupTest
(
true
false
true
13
runWorkerTest1
)
;
await
setupTest
(
true
false
true
0
.
13
runWorkerTest1
)
;
await
setupTest
(
false
true
false
0
.
13
runWorkerTest1
)
;
await
setupTest
(
false
true
true
0
.
005
runWorkerTest1
)
;
}
)
;
