add_task
(
async
function
runRTPTestAnimation
(
)
{
let
runTests
=
async
function
(
data
)
{
function
waitForCondition
(
aCond
aCallback
aErrorMsg
)
{
var
tries
=
0
;
var
interval
=
content
.
setInterval
(
(
)
=
>
{
if
(
tries
>
=
30
)
{
ok
(
false
aErrorMsg
)
;
moveOn
(
)
;
return
;
}
var
conditionPassed
;
try
{
conditionPassed
=
aCond
(
)
;
}
catch
(
e
)
{
ok
(
false
{
e
}
\
n
{
e
.
stack
}
)
;
conditionPassed
=
false
;
}
if
(
conditionPassed
)
{
moveOn
(
)
;
}
tries
+
+
;
}
100
)
;
var
moveOn
=
(
)
=
>
{
content
.
clearInterval
(
interval
)
;
aCallback
(
)
;
}
;
}
let
expectedPrecision
=
data
.
precision
;
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
const
testDiv
=
content
.
document
.
getElementById
(
"
testDiv
"
)
;
const
animation
=
testDiv
.
animate
(
{
opacity
:
[
0
1
]
}
100000
)
;
animation
.
play
(
)
;
let
done
;
let
promise
=
new
Promise
(
resolve
=
>
{
done
=
resolve
;
}
)
;
waitForCondition
(
(
)
=
>
animation
.
currentTime
>
100
(
)
=
>
{
var
maybeAcceptEverything
=
function
(
value
)
{
if
(
data
.
reduceTimerPrecision
&
&
!
data
.
resistFingerprinting
)
{
return
true
;
}
return
value
;
}
;
ok
(
maybeAcceptEverything
(
isRounded
(
animation
.
startTime
expectedPrecision
)
)
Animation
.
startTime
with
precision
{
expectedPrecision
}
is
not
+
rounded
:
{
animation
.
startTime
}
)
;
ok
(
maybeAcceptEverything
(
isRounded
(
animation
.
currentTime
expectedPrecision
)
)
Animation
.
currentTime
with
precision
{
expectedPrecision
}
is
+
not
rounded
:
{
animation
.
currentTime
}
)
;
ok
(
maybeAcceptEverything
(
isRounded
(
animation
.
timeline
.
currentTime
expectedPrecision
)
)
Animation
.
timeline
.
currentTime
with
precision
+
{
expectedPrecision
}
is
not
rounded
:
+
{
animation
.
timeline
.
currentTime
}
)
;
if
(
content
.
document
.
timeline
)
{
ok
(
maybeAcceptEverything
(
isRounded
(
content
.
document
.
timeline
.
currentTime
expectedPrecision
)
)
Document
.
timeline
.
currentTime
with
precision
+
{
expectedPrecision
}
is
not
rounded
:
+
{
content
.
document
.
timeline
.
currentTime
}
)
;
}
done
(
)
;
}
"
animation
failed
to
start
"
)
;
await
promise
;
}
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
100
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
false
crossOriginIsolated
:
true
}
50
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
false
crossOriginIsolated
:
true
}
0
.
1
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
0
.
013
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
false
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
0
.
005
runTests
)
;
}
)
;
