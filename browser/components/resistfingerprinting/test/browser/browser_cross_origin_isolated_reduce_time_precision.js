add_task
(
async
function
runRTPTestDOM
(
)
{
let
runTests
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
audioContext
=
new
content
.
AudioContext
(
)
;
const
timeStampCodes
=
[
"
content
.
performance
.
now
(
)
"
"
new
content
.
Date
(
)
.
getTime
(
)
"
'
new
content
.
Event
(
"
"
)
.
timeStamp
'
'
new
content
.
File
(
[
]
"
"
)
.
lastModified
'
]
;
var
timeStampCodesDOM
=
timeStampCodes
.
concat
(
[
"
audioContext
.
currentTime
*
1000
"
]
)
;
for
(
let
timeStampCode
of
timeStampCodesDOM
)
{
let
timeStamp
=
eval
(
timeStampCode
)
;
if
(
timeStampCode
.
includes
(
"
audioContext
"
)
&
&
expectedPrecision
<
5
.
4
)
{
continue
;
}
ok
(
isRounded
(
timeStamp
expectedPrecision
)
Should
be
rounded
to
nearest
{
expectedPrecision
}
ms
;
saw
{
timeStamp
}
)
;
}
}
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
100
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
false
crossOriginIsolated
:
true
}
13
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
false
crossOriginIsolated
:
true
}
0
.
13
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
false
reduceTimerPrecision
:
true
crossOriginIsolated
:
false
}
0
.
13
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
false
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
0
.
005
runTests
)
;
}
)
;
let
runWorkerTest
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
await
new
Promise
(
resolve
=
>
{
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
worker
=
new
content
.
Worker
(
"
coop_header
.
sjs
?
crossOriginIsolated
=
true
&
worker
=
true
"
)
;
const
timeStampCodes
=
[
"
performance
.
now
(
)
"
"
new
Date
(
)
.
getTime
(
)
"
'
new
Event
(
"
"
)
.
timeStamp
'
'
new
File
(
[
]
"
"
)
.
lastModified
'
]
;
let
promises
=
[
]
;
for
(
let
timeStampCode
of
timeStampCodes
)
{
promises
.
push
(
new
Promise
(
res
=
>
{
worker
.
postMessage
(
{
type
:
"
runCmdAndGetResult
"
cmd
:
timeStampCode
}
)
;
worker
.
addEventListener
(
"
message
"
function
(
e
)
{
if
(
e
.
data
.
type
=
=
"
result
"
)
{
if
(
e
.
data
.
resultOf
=
=
timeStampCode
)
{
ok
(
isRounded
(
e
.
data
.
result
expectedPrecision
)
The
result
of
{
e
.
data
.
resultOf
}
should
be
rounded
to
+
nearest
{
expectedPrecision
}
ms
in
workers
;
saw
+
{
e
.
data
.
result
}
)
;
worker
.
removeEventListener
(
"
message
"
this
)
;
res
(
)
;
}
return
;
}
ok
(
false
Unknown
message
type
.
Got
{
e
.
data
.
type
}
)
;
res
(
)
;
}
)
;
}
)
)
;
}
Promise
.
all
(
promises
)
.
then
(
_
=
>
{
worker
.
terminate
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
;
add_task
(
async
function
runRTPTestsForWorker
(
)
{
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
100
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
false
crossOriginIsolated
:
true
}
13
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
false
crossOriginIsolated
:
true
}
0
.
13
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
false
reduceTimerPrecision
:
true
crossOriginIsolated
:
false
}
0
.
13
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
false
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
0
.
005
runWorkerTest
)
;
}
)
;
