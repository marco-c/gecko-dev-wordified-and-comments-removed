const
TEST_SCENARIO_1
=
1
;
const
TEST_SCENARIO_2
=
2
;
const
TEST_SCENARIO_3
=
3
;
const
TEST_SCENARIO_4
=
4
;
const
TEST_SCENARIO_5
=
5
;
const
TEST_SCENARIO_6
=
6
;
const
TEST_SCENARIO_7
=
7
;
const
TEST_SCENARIO_8
=
8
;
const
TEST_SCENARIO_9
=
9
;
const
TEST_SCENARIO_10
=
10
;
const
TEST_SCENARIO_11
=
11
;
const
TEST_SCENARIO_101
=
101
;
const
TEST_SCENARIO_102
=
102
;
const
TEST_SCENARIO_103
=
103
;
const
TEST_SCENARIO_104
=
104
;
const
TEST_SCENARIO_105
=
105
;
const
TEST_SCENARIO_106
=
106
;
const
TEST_SCENARIO_107
=
107
;
const
TEST_SCENARIO_108
=
108
;
const
TEST_SCENARIO_109
=
109
;
const
TEST_SCENARIO_110
=
110
;
const
TEST_SCENARIO_111
=
111
;
requestLongerTimeout
(
2
)
;
let
processResultsGlobal
=
(
data
successes
failures
)
=
>
{
let
expectedPrecision
=
data
.
precision
;
let
scenario
=
data
.
options
.
scenario
;
let
shouldBeRounded
=
data
.
options
.
shouldBeRounded
;
for
(
let
success
of
successes
)
{
ok
(
true
(
shouldBeRounded
?
"
Should
"
:
"
Should
not
"
)
+
have
rounded
'
{
success
[
0
]
}
'
to
nearest
{
expectedPrecision
}
ms
;
saw
{
success
[
1
]
}
.
+
scenario
:
TEST_SCENARIO_
{
scenario
}
)
;
}
if
(
failures
.
length
>
2
)
{
for
(
let
failure
of
failures
)
{
ok
(
false
(
shouldBeRounded
?
"
Should
"
:
"
Should
not
"
)
+
have
rounded
'
{
failure
[
0
]
}
'
to
nearest
{
expectedPrecision
}
ms
;
saw
{
failure
[
1
]
}
.
+
scenario
:
TEST_SCENARIO_
{
scenario
}
)
;
}
}
else
if
(
failures
.
length
=
=
2
&
&
expectedPrecision
<
10
&
&
failures
[
0
]
[
0
]
.
indexOf
(
"
Date
(
)
.
getTime
(
)
"
)
>
0
&
&
failures
[
1
]
[
0
]
.
indexOf
(
'
File
(
[
]
"
"
)
.
lastModified
'
)
>
0
)
{
ok
(
true
"
Two
Free
Failures
that
"
+
(
data
.
options
.
shouldBeRounded
?
"
ahould
"
:
"
should
not
"
)
+
be
rounded
on
the
epoch
dates
and
precision
:
{
expectedPrecision
}
.
+
scenario
:
TEST_SCENARIO_
{
data
.
options
.
scenario
}
)
;
}
else
if
(
failures
.
length
=
=
1
)
{
ok
(
true
"
Free
Failure
:
"
+
(
data
.
options
.
shouldBeRounded
?
"
Should
"
:
"
Should
not
"
)
+
have
rounded
'
{
failures
[
0
]
[
0
]
}
'
to
nearest
{
expectedPrecision
}
ms
;
saw
{
failures
[
0
]
[
1
]
}
.
+
scenario
:
TEST_SCENARIO_
{
data
.
options
.
scenario
}
)
;
}
}
;
add_setup
(
function
(
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
allow_eval_with_system_principal
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
runRTPTestDOM
(
)
{
let
runTests
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
processResults
=
eval
(
data
.
options
.
processResultsFunc
)
;
let
audioContext
=
new
content
.
AudioContext
(
)
;
const
timeStampCodes
=
[
"
new
content
.
Date
(
)
.
getTime
(
)
"
'
new
content
.
File
(
[
]
"
"
)
.
lastModified
'
"
content
.
performance
.
now
(
)
"
'
new
content
.
Event
(
"
"
)
.
timeStamp
'
]
;
var
timeStampCodesDOM
=
timeStampCodes
.
concat
(
[
"
audioContext
.
currentTime
*
1000
"
]
)
;
let
resultSwitchisRounded
=
function
(
timeStamp
)
{
if
(
timeStamp
=
=
0
)
{
return
true
;
}
let
result
=
isRounded
(
timeStamp
expectedPrecision
content
.
console
)
;
return
data
.
options
.
shouldBeRounded
?
result
:
!
result
;
}
;
let
successes
=
[
]
failures
=
[
]
;
for
(
let
timeStampCode
of
timeStampCodesDOM
)
{
let
timeStamp
=
eval
(
timeStampCode
)
;
if
(
timeStampCode
.
includes
(
"
audioContext
"
)
&
&
expectedPrecision
<
5
.
4
)
{
continue
;
}
if
(
timeStamp
!
=
0
&
&
resultSwitchisRounded
(
timeStamp
)
)
{
successes
=
successes
.
concat
(
[
[
timeStampCode
timeStamp
]
]
)
;
}
else
if
(
timeStamp
!
=
0
)
{
failures
=
failures
.
concat
(
[
[
timeStampCode
timeStamp
]
]
)
;
}
}
processResults
(
data
successes
failures
)
;
}
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_1
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
100
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
shouldBeRounded
:
false
scenario
:
TEST_SCENARIO_2
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
100
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_3
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
100
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_4
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
13
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_6
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
13
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_7
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
7
.
97
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_9
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
7
.
97
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
reduceTimerPrecision
:
true
scenario
:
TEST_SCENARIO_10
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
7
.
97
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_11
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
0
.
005
runTests
)
;
}
)
;
let
runWorkerTest
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
await
new
Promise
(
resolve
=
>
{
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
processResults
=
eval
(
data
.
options
.
processResultsFunc
)
;
let
worker
=
new
content
.
Worker
(
"
coop_header
.
sjs
?
crossOriginIsolated
=
true
&
worker
=
true
"
)
;
const
timeStampCodes
=
[
"
new
Date
(
)
.
getTime
(
)
"
'
new
File
(
[
]
"
"
)
.
lastModified
'
"
performance
.
now
(
)
"
'
new
Event
(
"
"
)
.
timeStamp
'
]
;
let
promises
=
[
]
successes
=
[
]
failures
=
[
]
;
for
(
let
timeStampCode
of
timeStampCodes
)
{
promises
.
push
(
new
Promise
(
res
=
>
{
worker
.
postMessage
(
{
type
:
"
runCmdAndGetResult
"
cmd
:
timeStampCode
}
)
;
worker
.
addEventListener
(
"
message
"
function
(
e
)
{
let
resultSwitchisRounded
=
function
(
timeStamp
)
{
if
(
timeStamp
=
=
0
)
{
return
true
;
}
let
result
=
isRounded
(
timeStamp
expectedPrecision
)
;
return
data
.
options
.
shouldBeRounded
?
result
:
!
result
;
}
;
if
(
e
.
data
.
type
=
=
"
result
"
)
{
if
(
e
.
data
.
resultOf
=
=
timeStampCode
)
{
if
(
resultSwitchisRounded
(
e
.
data
.
result
)
)
{
successes
=
successes
.
concat
(
[
[
timeStampCode
e
.
data
.
result
]
]
)
;
}
else
{
failures
=
failures
.
concat
(
[
[
timeStampCode
e
.
data
.
result
]
]
)
;
}
worker
.
removeEventListener
(
"
message
"
this
)
;
res
(
)
;
}
return
;
}
ok
(
false
Unknown
message
type
.
Got
{
e
.
data
.
type
}
)
;
res
(
)
;
}
)
;
}
)
)
;
}
Promise
.
all
(
promises
)
.
then
(
_
=
>
{
worker
.
terminate
(
)
;
processResults
(
data
successes
failures
)
;
resolve
(
)
;
}
)
;
}
)
;
}
;
add_task
(
async
function
runRTPTestsForWorker
(
)
{
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_101
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
100
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
shouldBeRounded
:
false
scenario
:
TEST_SCENARIO_102
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
100
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_103
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
100
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_104
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
13
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_106
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
13
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_107
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
7
.
97
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_109
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
7
.
97
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
reduceTimerPrecision
:
true
scenario
:
TEST_SCENARIO_110
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
7
.
97
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_111
processResultsFunc
:
processResultsGlobal
.
toString
(
)
}
0
.
005
runWorkerTest
)
;
}
)
;
