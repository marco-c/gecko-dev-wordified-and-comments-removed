const
TEST_SCENARIO_1
=
1
;
const
TEST_SCENARIO_2
=
2
;
const
TEST_SCENARIO_3
=
3
;
const
TEST_SCENARIO_4
=
4
;
const
TEST_SCENARIO_5
=
5
;
const
TEST_SCENARIO_6
=
6
;
const
TEST_SCENARIO_7
=
7
;
const
TEST_SCENARIO_8
=
8
;
const
TEST_SCENARIO_9
=
9
;
const
TEST_SCENARIO_10
=
10
;
const
TEST_SCENARIO_11
=
11
;
add_task
(
async
function
runRTPTestDOM
(
)
{
let
runTests
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
audioContext
=
new
content
.
AudioContext
(
)
;
const
timeStampCodes
=
[
"
new
content
.
Date
(
)
.
getTime
(
)
"
'
new
content
.
File
(
[
]
"
"
)
.
lastModified
'
"
content
.
performance
.
now
(
)
"
'
new
content
.
Event
(
"
"
)
.
timeStamp
'
]
;
var
timeStampCodesDOM
=
timeStampCodes
.
concat
(
[
"
audioContext
.
currentTime
*
1000
"
]
)
;
let
resultSwitchisRounded
=
function
(
timeStamp
)
{
if
(
timeStamp
=
=
0
)
{
return
true
;
}
let
result
=
isRounded
(
timeStamp
expectedPrecision
content
.
console
)
;
return
data
.
options
.
shouldBeRounded
?
result
:
!
result
;
}
;
let
successes
=
[
]
failures
=
[
]
;
for
(
let
timeStampCode
of
timeStampCodesDOM
)
{
let
timeStamp
=
eval
(
timeStampCode
)
;
if
(
timeStampCode
.
includes
(
"
audioContext
"
)
&
&
expectedPrecision
<
5
.
4
)
{
continue
;
}
if
(
timeStamp
!
=
0
&
&
resultSwitchisRounded
(
timeStamp
)
)
{
successes
=
successes
.
concat
(
[
[
timeStampCode
timeStamp
]
]
)
;
}
else
if
(
timeStamp
!
=
0
)
{
failures
=
failures
.
concat
(
[
[
timeStampCode
timeStamp
]
]
)
;
}
}
for
(
let
success
of
successes
)
{
ok
(
resultSwitchisRounded
(
success
[
1
]
)
(
data
.
options
.
shouldBeRounded
?
"
Should
"
:
"
Should
not
"
)
+
have
rounded
'
{
success
[
0
]
}
'
to
nearest
{
expectedPrecision
}
ms
;
saw
{
success
[
1
]
}
.
+
Scenario
:
{
data
.
options
.
scenario
}
)
;
}
if
(
failures
.
length
>
2
)
{
for
(
let
failure
of
failures
)
{
ok
(
resultSwitchisRounded
(
failure
[
1
]
)
(
data
.
options
.
shouldBeRounded
?
"
Should
"
:
"
Should
not
"
)
+
have
rounded
'
{
failure
[
0
]
}
'
to
nearest
{
expectedPrecision
}
ms
;
saw
{
failure
[
1
]
}
.
+
Scenario
:
{
data
.
options
.
scenario
}
)
;
}
}
else
if
(
failures
.
length
=
=
2
&
&
expectedPrecision
<
10
&
&
failures
[
0
]
[
0
]
=
=
timeStampCodes
[
0
]
&
&
failures
[
1
]
[
0
]
=
=
timeStampCodes
[
1
]
)
{
ok
(
true
"
Two
Free
Failures
that
"
+
(
data
.
options
.
shouldBeRounded
?
"
ahould
"
:
"
should
not
"
)
+
be
rounded
on
the
epoch
dates
and
precision
:
{
expectedPrecision
}
.
+
Scenario
:
{
data
.
options
.
scenario
}
)
;
}
else
if
(
failures
.
length
=
=
1
)
{
ok
(
true
"
Free
Failure
:
"
+
(
data
.
options
.
shouldBeRounded
?
"
Should
"
:
"
Should
not
"
)
+
have
rounded
'
{
failures
[
0
]
[
0
]
}
'
to
nearest
{
expectedPrecision
}
ms
;
saw
{
failures
[
0
]
[
1
]
}
.
+
Scenario
:
{
data
.
options
.
scenario
}
)
;
}
}
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_1
}
100
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
shouldBeRounded
:
false
scenario
:
TEST_SCENARIO_2
}
100
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_3
}
100
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_4
}
13
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
crossOriginIsolated
:
true
shouldBeRounded
:
false
scenario
:
TEST_SCENARIO_5
}
13
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_6
}
13
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_7
}
7
.
97
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
crossOriginIsolated
:
true
shouldBeRounded
:
false
scenario
:
TEST_SCENARIO_8
}
7
.
97
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprintingPBMOnly
:
true
openPrivateWindow
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_9
}
7
.
97
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
reduceTimerPrecision
:
true
scenario
:
TEST_SCENARIO_10
}
7
.
97
runTests
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
scenario
:
TEST_SCENARIO_11
}
0
.
005
runTests
)
;
}
)
;
let
runWorkerTest
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
await
new
Promise
(
resolve
=
>
{
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
let
worker
=
new
content
.
Worker
(
"
coop_header
.
sjs
?
crossOriginIsolated
=
true
&
worker
=
true
"
)
;
const
timeStampCodes
=
[
"
performance
.
now
(
)
"
"
new
Date
(
)
.
getTime
(
)
"
'
new
Event
(
"
"
)
.
timeStamp
'
'
new
File
(
[
]
"
"
)
.
lastModified
'
]
;
let
promises
=
[
]
;
for
(
let
timeStampCode
of
timeStampCodes
)
{
promises
.
push
(
new
Promise
(
res
=
>
{
worker
.
postMessage
(
{
type
:
"
runCmdAndGetResult
"
cmd
:
timeStampCode
}
)
;
worker
.
addEventListener
(
"
message
"
function
(
e
)
{
let
resultSwitchisRounded
=
function
(
timeStamp
)
{
if
(
timeStamp
=
=
0
)
{
return
true
;
}
let
result
=
isRounded
(
timeStamp
expectedPrecision
)
;
return
data
.
options
.
shouldBeRounded
?
result
:
!
result
;
}
;
if
(
e
.
data
.
type
=
=
"
result
"
)
{
if
(
e
.
data
.
resultOf
=
=
timeStampCode
)
{
ok
(
resultSwitchisRounded
(
e
.
data
.
result
)
The
result
of
{
e
.
data
.
resultOf
}
should
be
rounded
to
+
nearest
{
expectedPrecision
}
ms
in
workers
;
saw
+
{
e
.
data
.
result
}
)
;
worker
.
removeEventListener
(
"
message
"
this
)
;
res
(
)
;
}
return
;
}
ok
(
false
Unknown
message
type
.
Got
{
e
.
data
.
type
}
)
;
res
(
)
;
}
)
;
}
)
)
;
}
Promise
.
all
(
promises
)
.
then
(
_
=
>
{
worker
.
terminate
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
;
add_task
(
async
function
runRTPTestsForWorker
(
)
{
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
100
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
crossOriginIsolated
:
true
}
13
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
resistFingerprinting
:
true
crossOriginIsolated
:
true
}
0
.
13
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
reduceTimerPrecision
:
true
}
0
.
13
runWorkerTest
)
;
await
setupAndRunCrossOriginIsolatedTest
(
{
reduceTimerPrecision
:
true
crossOriginIsolated
:
true
}
0
.
005
runWorkerTest
)
;
}
)
;
