const
TEST_PATH
=
"
http
:
/
/
example
.
net
/
browser
/
browser
/
"
+
"
components
/
resistfingerprinting
/
test
/
browser
/
"
;
const
PERFORMANCE_TIMINGS
=
[
"
navigationStart
"
"
unloadEventStart
"
"
unloadEventEnd
"
"
redirectStart
"
"
redirectEnd
"
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
secureConnectionStart
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
"
domLoading
"
"
domInteractive
"
"
domContentLoadedEventStart
"
"
domContentLoadedEventEnd
"
"
domComplete
"
"
loadEventStart
"
"
loadEventEnd
"
]
;
let
isRounded
=
(
x
expectedPrecision
)
=
>
{
let
rounded
=
Math
.
floor
(
x
/
expectedPrecision
)
*
expectedPrecision
;
if
(
rounded
=
=
=
x
|
|
x
=
=
=
0
)
{
return
true
;
}
if
(
Math
.
abs
(
rounded
-
x
+
expectedPrecision
)
<
0
.
0005
)
{
return
true
;
}
else
if
(
Math
.
abs
(
rounded
-
x
)
<
0
.
0005
)
{
return
true
;
}
if
(
expectedPrecision
<
1
&
&
Math
.
round
(
x
)
=
=
x
)
{
if
(
Math
.
round
(
rounded
)
=
=
x
)
{
return
true
;
}
}
ok
(
false
"
Looming
Test
Failure
Additional
Debugging
Info
:
Expected
Precision
:
"
+
expectedPrecision
+
"
Measured
Value
:
"
+
x
+
"
Rounded
Vaue
:
"
+
rounded
+
"
Fuzzy1
:
"
+
Math
.
abs
(
rounded
-
x
+
expectedPrecision
)
+
"
Fuzzy
2
:
"
+
Math
.
abs
(
rounded
-
x
)
)
;
return
false
;
}
;
let
setupTest
=
async
function
(
tab
resistFingerprinting
reduceTimerPrecision
expectedPrecision
runTests
workerCall
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
resistFingerprinting
]
[
"
privacy
.
reduceTimerPrecision
"
reduceTimerPrecision
]
[
"
privacy
.
resistFingerprinting
.
reduceTimerPrecision
.
microseconds
"
expectedPrecision
*
1000
]
]
}
)
;
if
(
resistFingerprinting
)
{
expectedPrecision
=
expectedPrecision
<
100
?
100
:
expectedPrecision
;
}
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
list
:
PERFORMANCE_TIMINGS
precision
:
expectedPrecision
isRoundedFunc
:
isRounded
.
toString
(
)
workerCall
}
runTests
)
;
}
;
add_task
(
async
function
runRPTests
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PATH
+
"
file_dummy
.
html
"
)
;
let
runTests
=
async
function
(
data
)
{
let
timerlist
=
data
.
list
;
let
expectedPrecision
=
data
.
precision
;
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
ok
(
isRounded
(
content
.
performance
.
timeOrigin
expectedPrecision
)
For
resistFingerprinting
performance
.
timeOrigin
is
not
correctly
rounded
:
+
content
.
performance
.
timeOrigin
)
;
for
(
let
time
of
timerlist
)
{
is
(
content
.
performance
.
timing
[
time
]
0
For
resistFingerprinting
the
timing
(
{
time
}
)
is
not
correctly
spoofed
.
)
;
}
content
.
performance
.
mark
(
"
Test
"
)
;
content
.
performance
.
mark
(
"
Test
-
End
"
)
;
content
.
performance
.
measure
(
"
Test
-
Measure
"
"
Test
"
"
Test
-
End
"
)
;
is
(
content
.
performance
.
getEntries
(
)
.
length
0
"
For
resistFingerprinting
there
should
be
no
entries
for
performance
.
getEntries
(
)
"
)
;
is
(
content
.
performance
.
getEntriesByType
(
"
resource
"
)
.
length
0
"
For
resistFingerprinting
there
should
be
no
entries
for
performance
.
getEntriesByType
(
)
"
)
;
is
(
content
.
performance
.
getEntriesByName
(
"
Test
"
"
mark
"
)
.
length
0
"
For
resistFingerprinting
there
should
be
no
entries
for
performance
.
getEntriesByName
(
)
"
)
;
}
;
await
setupTest
(
tab
true
true
100
runTests
)
;
await
setupTest
(
tab
true
false
13
runTests
)
;
await
setupTest
(
tab
true
false
0
.
13
runTests
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
runRTPTests
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PATH
+
"
file_dummy
.
html
"
)
;
let
runTests
=
async
function
(
data
)
{
let
timerlist
=
data
.
list
;
let
expectedPrecision
=
data
.
precision
;
let
isRounded
=
eval
(
data
.
isRoundedFunc
)
;
ok
(
isRounded
(
content
.
performance
.
timeOrigin
expectedPrecision
)
For
reduceTimerPrecision
performance
.
timeOrigin
is
not
correctly
rounded
:
+
content
.
performance
.
timeOrigin
)
;
for
(
let
time
of
timerlist
)
{
ok
(
isRounded
(
content
.
performance
.
timing
[
time
]
expectedPrecision
)
For
reduceTimerPrecision
(
+
expectedPrecision
+
)
the
timing
(
{
time
}
)
is
not
correctly
rounded
:
+
content
.
performance
.
timing
[
time
]
)
;
}
content
.
performance
.
mark
(
"
Test
"
)
;
content
.
performance
.
mark
(
"
Test
-
End
"
)
;
content
.
performance
.
measure
(
"
Test
-
Measure
"
"
Test
"
"
Test
-
End
"
)
;
is
(
content
.
performance
.
getEntries
(
)
.
length
4
"
For
reduceTimerPrecision
there
should
be
4
entries
for
performance
.
getEntries
(
)
"
)
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
{
let
startTime
=
content
.
performance
.
getEntries
(
)
[
i
]
.
startTime
;
let
duration
=
content
.
performance
.
getEntries
(
)
[
i
]
.
duration
;
ok
(
isRounded
(
startTime
expectedPrecision
)
"
For
reduceTimerPrecision
(
"
+
expectedPrecision
+
"
)
performance
.
getEntries
(
"
+
i
+
"
)
.
startTime
is
not
rounded
:
"
+
startTime
)
;
ok
(
isRounded
(
duration
expectedPrecision
)
"
For
reduceTimerPrecision
(
"
+
expectedPrecision
+
"
)
performance
.
getEntries
(
"
+
i
+
"
)
.
duration
is
not
rounded
:
"
+
duration
)
;
}
is
(
content
.
performance
.
getEntriesByType
(
"
mark
"
)
.
length
2
"
For
reduceTimerPrecision
there
should
be
2
entries
for
performance
.
getEntriesByType
(
)
"
)
;
is
(
content
.
performance
.
getEntriesByName
(
"
Test
"
"
mark
"
)
.
length
1
"
For
reduceTimerPrecision
there
should
be
1
entry
for
performance
.
getEntriesByName
(
)
"
)
;
content
.
performance
.
clearMarks
(
)
;
content
.
performance
.
clearMeasures
(
)
;
content
.
performance
.
clearResourceTimings
(
)
;
}
;
await
setupTest
(
tab
false
true
100
runTests
)
;
await
setupTest
(
tab
false
true
13
runTests
)
;
await
setupTest
(
tab
false
true
0
.
13
runTests
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
let
runWorkerTest
=
async
function
(
data
)
{
let
expectedPrecision
=
data
.
precision
;
let
workerCall
=
data
.
workerCall
;
await
new
Promise
(
resolve
=
>
{
let
worker
=
new
content
.
Worker
(
"
file_workerPerformance
.
js
"
)
;
worker
.
onmessage
=
function
(
e
)
{
if
(
e
.
data
.
type
=
=
"
status
"
)
{
ok
(
e
.
data
.
status
e
.
data
.
msg
)
;
}
else
if
(
e
.
data
.
type
=
=
"
finish
"
)
{
worker
.
terminate
(
)
;
resolve
(
)
;
}
else
{
ok
(
false
"
Unknown
message
type
"
)
;
worker
.
terminate
(
)
;
resolve
(
)
;
}
}
;
worker
.
postMessage
(
{
type
:
workerCall
precision
:
expectedPrecision
}
)
;
}
)
;
}
;
add_task
(
async
function
runRPTestsForWorker
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PATH
+
"
file_dummy
.
html
"
)
;
await
setupTest
(
tab
true
true
100
runWorkerTest
"
runRPTests
"
)
;
await
setupTest
(
tab
true
false
13
runWorkerTest
"
runRPTests
"
)
;
await
setupTest
(
tab
true
true
0
.
13
runWorkerTest
"
runRPTests
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
runRTPTestsForWorker
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PATH
+
"
file_dummy
.
html
"
)
;
await
setupTest
(
tab
false
true
100
runWorkerTest
"
runRTPTests
"
)
;
await
setupTest
(
tab
false
true
13
runWorkerTest
"
runRTPTests
"
)
;
await
setupTest
(
tab
false
true
0
.
13
runWorkerTest
"
runRTPTests
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
