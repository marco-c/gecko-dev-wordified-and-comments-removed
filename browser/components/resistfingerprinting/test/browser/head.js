"
use
strict
"
;
async
function
calcMaximumAvailSize
(
aChromeWidth
aChromeHeight
)
{
let
chromeUIWidth
;
let
chromeUIHeight
;
let
testPath
=
"
http
:
/
/
example
.
net
/
browser
/
browser
/
"
+
"
components
/
resistfingerprinting
/
test
/
browser
/
"
;
if
(
!
aChromeWidth
|
|
!
aChromeHeight
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
testPath
+
"
file_dummy
.
html
"
)
;
let
contentSize
=
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
async
function
(
)
{
let
result
=
{
width
:
content
.
innerWidth
height
:
content
.
innerHeight
}
;
return
result
;
}
)
;
chromeUIWidth
=
win
.
outerWidth
-
contentSize
.
width
;
chromeUIHeight
=
win
.
outerHeight
-
contentSize
.
height
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
else
{
chromeUIWidth
=
aChromeWidth
;
chromeUIHeight
=
aChromeHeight
;
}
let
availWidth
=
window
.
screen
.
availWidth
;
let
availHeight
=
window
.
screen
.
availHeight
;
let
availContentWidth
=
Math
.
min
(
1000
availWidth
-
chromeUIWidth
)
;
let
availContentHeight
;
if
(
AppConstants
.
MOZ_WIDGET_GTK
)
{
availContentHeight
=
Math
.
min
(
1000
-
40
+
availHeight
-
chromeUIHeight
)
;
}
else
{
availContentHeight
=
Math
.
min
(
1000
availHeight
-
chromeUIHeight
)
;
}
let
maxAvailWidth
=
availContentWidth
-
(
availContentWidth
%
200
)
;
let
maxAvailHeight
=
availContentHeight
-
(
availContentHeight
%
100
)
;
return
{
maxAvailWidth
maxAvailHeight
}
;
}
async
function
calcPopUpWindowChromeUISize
(
)
{
let
testPath
=
"
http
:
/
/
example
.
net
/
browser
/
browser
/
"
+
"
components
/
resistFingerprinting
/
test
/
browser
/
"
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
testPath
+
"
file_dummy
.
html
"
)
;
let
result
=
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
async
function
(
)
{
let
win
;
await
new
Promise
(
resolve
=
>
{
win
=
content
.
open
(
"
about
:
blank
"
"
"
"
width
=
1000
height
=
1000
"
)
;
win
.
onload
=
(
)
=
>
resolve
(
)
;
}
)
;
let
res
=
{
chromeWidth
:
win
.
outerWidth
-
win
.
innerWidth
chromeHeight
:
win
.
outerHeight
-
win
.
innerHeight
}
;
win
.
close
(
)
;
return
res
;
}
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
return
result
;
}
async
function
testWindowOpen
(
aBrowser
aSettingWidth
aSettingHeight
aTargetWidth
aTargetHeight
aTestOuter
aMaxAvailWidth
aMaxAvailHeight
aPopupChromeUIWidth
aPopupChromeUIHeight
)
{
if
(
aTargetWidth
>
aMaxAvailWidth
)
{
aTargetWidth
=
aMaxAvailWidth
;
}
if
(
aTargetHeight
>
aMaxAvailHeight
)
{
aTargetHeight
=
aMaxAvailHeight
;
}
let
winFeatures
;
if
(
aTestOuter
)
{
winFeatures
=
"
outerWidth
=
"
+
(
aSettingWidth
+
aPopupChromeUIWidth
)
+
"
outerHeight
=
"
+
(
aSettingHeight
+
aPopupChromeUIHeight
)
;
}
else
{
winFeatures
=
"
width
=
"
+
aSettingWidth
+
"
height
=
"
+
aSettingHeight
;
}
let
testParams
=
{
winFeatures
targetWidth
:
aTargetWidth
targetHeight
:
aTargetHeight
}
;
await
ContentTask
.
spawn
(
aBrowser
testParams
async
function
(
input
)
{
await
new
Promise
(
resolve
=
>
{
let
win
=
content
.
open
(
"
http
:
/
/
example
.
net
/
"
"
"
input
.
winFeatures
)
;
win
.
onload
=
(
)
=
>
{
is
(
win
.
screen
.
width
input
.
targetWidth
"
The
screen
.
width
has
a
correct
rounded
value
"
)
;
is
(
win
.
screen
.
height
input
.
targetHeight
"
The
screen
.
height
has
a
correct
rounded
value
"
)
;
is
(
win
.
innerWidth
input
.
targetWidth
"
The
window
.
innerWidth
has
a
correct
rounded
value
"
)
;
is
(
win
.
innerHeight
input
.
targetHeight
"
The
window
.
innerHeight
has
a
correct
rounded
value
"
)
;
win
.
close
(
)
;
resolve
(
)
;
}
;
}
)
;
}
)
;
}
async
function
testWindowSizeSetting
(
aBrowser
aSettingWidth
aSettingHeight
aTargetWidth
aTargetHeight
aInitWidth
aInitHeight
aTestOuter
aMaxAvailWidth
aMaxAvailHeight
aPopupChromeUIWidth
aPopupChromeUIHeight
)
{
if
(
aTargetWidth
>
aMaxAvailWidth
)
{
aTargetWidth
=
aMaxAvailWidth
;
}
if
(
aTargetHeight
>
aMaxAvailHeight
)
{
aTargetHeight
=
aMaxAvailHeight
;
}
let
testParams
=
{
initWidth
:
aInitWidth
initHeight
:
aInitHeight
settingWidth
:
aSettingWidth
+
(
aTestOuter
?
aPopupChromeUIWidth
:
0
)
settingHeight
:
aSettingHeight
+
(
aTestOuter
?
aPopupChromeUIHeight
:
0
)
targetWidth
:
aTargetWidth
targetHeight
:
aTargetHeight
testOuter
:
aTestOuter
}
;
await
ContentTask
.
spawn
(
aBrowser
testParams
async
function
(
input
)
{
let
win
;
await
new
Promise
(
resolve
=
>
{
let
initWinFeatures
=
"
width
=
"
+
input
.
initWidth
+
"
height
=
"
+
input
.
initHeight
;
win
=
content
.
open
(
"
http
:
/
/
example
.
net
/
"
"
"
initWinFeatures
)
;
win
.
onload
=
(
)
=
>
resolve
(
)
;
}
)
;
await
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
resize
"
(
)
=
>
{
is
(
win
.
screen
.
width
input
.
targetWidth
"
The
screen
.
width
has
a
correct
rounded
value
"
)
;
is
(
win
.
innerWidth
input
.
targetWidth
"
The
window
.
innerWidth
has
a
correct
rounded
value
"
)
;
resolve
(
)
;
}
{
once
:
true
}
)
;
if
(
input
.
testOuter
)
{
win
.
outerWidth
=
input
.
settingWidth
;
}
else
{
win
.
innerWidth
=
input
.
settingWidth
;
}
}
)
;
win
.
close
(
)
;
await
new
Promise
(
resolve
=
>
{
let
initWinFeatures
=
"
width
=
"
+
input
.
initWidth
+
"
height
=
"
+
input
.
initHeight
;
win
=
content
.
open
(
"
http
:
/
/
example
.
net
/
"
"
"
initWinFeatures
)
;
win
.
onload
=
(
)
=
>
resolve
(
)
;
}
)
;
await
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
resize
"
(
)
=
>
{
is
(
win
.
screen
.
height
input
.
targetHeight
"
The
screen
.
height
has
a
correct
rounded
value
"
)
;
is
(
win
.
innerHeight
input
.
targetHeight
"
The
window
.
innerHeight
has
a
correct
rounded
value
"
)
;
resolve
(
)
;
}
{
once
:
true
}
)
;
if
(
input
.
testOuter
)
{
win
.
outerHeight
=
input
.
settingHeight
;
}
else
{
win
.
innerHeight
=
input
.
settingHeight
;
}
}
)
;
win
.
close
(
)
;
}
)
;
}
class
RoundedWindowTest
{
static
run
(
testCases
testOuter
)
{
let
test
=
new
this
(
testCases
)
;
add_task
(
async
(
)
=
>
test
.
setup
(
)
)
;
add_task
(
async
(
)
=
>
{
if
(
testOuter
=
=
undefined
)
{
await
test
.
doTests
(
false
)
;
await
test
.
doTests
(
true
)
;
}
else
{
await
test
.
doTests
(
testOuter
)
;
}
}
)
;
}
get
TEST_PATH
(
)
{
return
"
http
:
/
/
example
.
net
/
browser
/
browser
/
components
/
resistfingerprinting
/
test
/
browser
/
"
;
}
constructor
(
testCases
)
{
this
.
testCases
=
testCases
;
}
async
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
privacy
.
resistFingerprinting
"
true
]
]
}
)
;
let
popUpChromeUISize
=
await
calcPopUpWindowChromeUISize
(
)
;
this
.
popupChromeUIWidth
=
popUpChromeUISize
.
chromeWidth
;
this
.
popupChromeUIHeight
=
popUpChromeUISize
.
chromeHeight
;
let
maxAvailSize
=
await
calcMaximumAvailSize
(
this
.
popupChromeUIWidth
this
.
popupChromeUIHeight
)
;
this
.
maxAvailWidth
=
maxAvailSize
.
maxAvailWidth
;
this
.
maxAvailHeight
=
maxAvailSize
.
maxAvailHeight
;
}
async
doTests
(
testOuter
)
{
this
.
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
this
.
TEST_PATH
+
"
file_dummy
.
html
"
)
;
for
(
let
test
of
this
.
testCases
)
{
await
this
.
doTest
(
test
testOuter
)
;
}
BrowserTestUtils
.
removeTab
(
this
.
tab
)
;
}
async
doTest
(
)
{
throw
new
Error
(
"
RoundedWindowTest
.
doTest
must
be
overridden
.
"
)
;
}
}
class
WindowSettingTest
extends
RoundedWindowTest
{
async
doTest
(
test
testOuter
)
{
await
testWindowSizeSetting
(
this
.
tab
.
linkedBrowser
test
.
settingWidth
test
.
settingHeight
test
.
targetWidth
test
.
targetHeight
test
.
initWidth
test
.
initHeight
testOuter
this
.
maxAvailWidth
this
.
maxAvailHeight
this
.
popupChromeUIWidth
this
.
popupChromeUIHeight
)
;
}
}
class
OpenTest
extends
RoundedWindowTest
{
async
doTest
(
test
testOuter
)
{
await
testWindowOpen
(
this
.
tab
.
linkedBrowser
test
.
settingWidth
test
.
settingHeight
test
.
targetWidth
test
.
targetHeight
testOuter
this
.
maxAvailWidth
this
.
maxAvailHeight
this
.
popupChromeUIWidth
this
.
popupChromeUIHeight
)
;
}
}
