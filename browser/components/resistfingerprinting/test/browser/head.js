"
use
strict
"
;
const
TEST_PATH
=
"
http
:
/
/
example
.
net
/
browser
/
browser
/
"
+
"
components
/
resistfingerprinting
/
test
/
browser
/
"
;
const
PERFORMANCE_TIMINGS
=
[
"
navigationStart
"
"
unloadEventStart
"
"
unloadEventEnd
"
"
redirectStart
"
"
redirectEnd
"
"
fetchStart
"
"
domainLookupStart
"
"
domainLookupEnd
"
"
connectStart
"
"
connectEnd
"
"
secureConnectionStart
"
"
requestStart
"
"
responseStart
"
"
responseEnd
"
"
domLoading
"
"
domInteractive
"
"
domContentLoadedEventStart
"
"
domContentLoadedEventEnd
"
"
domComplete
"
"
loadEventStart
"
"
loadEventEnd
"
]
;
let
setupPerformanceAPISpoofAndDisableTest
=
async
function
(
resistFingerprinting
reduceTimerPrecision
crossOriginIsolated
expectedPrecision
runTests
workerCall
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
resistFingerprinting
]
[
"
privacy
.
reduceTimerPrecision
"
reduceTimerPrecision
]
[
"
privacy
.
resistFingerprinting
.
reduceTimerPrecision
.
microseconds
"
expectedPrecision
*
1000
]
[
"
browser
.
tabs
.
remote
.
useCrossOriginOpenerPolicy
"
crossOriginIsolated
]
[
"
browser
.
tabs
.
remote
.
useCrossOriginEmbedderPolicy
"
crossOriginIsolated
]
]
}
)
;
let
url
=
crossOriginIsolated
?
https
:
/
/
example
.
com
/
browser
/
browser
/
components
/
resistfingerprinting
+
/
test
/
browser
/
coop_header
.
sjs
?
crossOriginIsolated
=
{
crossOriginIsolated
}
:
TEST_PATH
+
"
file_dummy
.
html
"
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
url
)
;
if
(
resistFingerprinting
)
{
const
RFP_TIME_ATOM_MS
=
16
.
667
;
expectedPrecision
=
Math
.
max
(
RFP_TIME_ATOM_MS
expectedPrecision
)
;
}
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
{
list
:
PERFORMANCE_TIMINGS
precision
:
expectedPrecision
isRoundedFunc
:
isTimeValueRounded
.
toString
(
)
workerCall
}
]
runTests
)
;
if
(
crossOriginIsolated
)
{
let
remoteType
=
tab
.
linkedBrowser
.
remoteType
;
ok
(
remoteType
.
startsWith
(
E10SUtils
.
WEB_REMOTE_COOP_COEP_TYPE_PREFIX
)
{
remoteType
}
expected
to
be
coop
+
coep
)
;
}
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
;
let
isTimeValueRounded
=
(
x
expectedPrecision
)
=
>
{
const
nearestExpected
=
Math
.
round
(
x
/
expectedPrecision
)
*
expectedPrecision
;
if
(
x
=
=
=
nearestExpected
)
{
return
true
;
}
const
error
=
Math
.
abs
(
x
-
nearestExpected
)
;
if
(
Math
.
abs
(
error
)
<
0
.
0005
)
{
return
true
;
}
if
(
Math
.
round
(
expectedPrecision
)
!
=
expectedPrecision
&
&
Math
.
round
(
x
)
=
=
x
)
{
let
acceptableIntRounding
=
false
;
acceptableIntRounding
|
=
Math
.
floor
(
nearestExpected
)
=
=
x
;
acceptableIntRounding
|
=
Math
.
ceil
(
nearestExpected
)
=
=
x
;
if
(
acceptableIntRounding
)
{
return
true
;
}
}
ok
(
false
"
Looming
Test
Failure
Additional
Debugging
Info
:
Expected
Precision
:
"
+
expectedPrecision
+
"
Measured
Value
:
"
+
x
+
"
Nearest
Expected
Vaue
:
"
+
nearestExpected
+
"
Error
:
"
+
error
)
;
return
false
;
}
;
let
setupAndRunCrossOriginIsolatedTest
=
async
function
(
resistFingerprinting
reduceTimerPrecision
crossOriginIsolated
expectedPrecision
runTests
workerCall
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
resistFingerprinting
]
[
"
privacy
.
reduceTimerPrecision
"
reduceTimerPrecision
]
[
"
privacy
.
resistFingerprinting
.
reduceTimerPrecision
.
microseconds
"
expectedPrecision
*
1000
]
[
"
browser
.
tabs
.
remote
.
useCrossOriginOpenerPolicy
"
crossOriginIsolated
]
[
"
browser
.
tabs
.
remote
.
useCrossOriginEmbedderPolicy
"
crossOriginIsolated
]
]
}
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
https
:
/
/
example
.
com
/
browser
/
browser
/
components
/
resistfingerprinting
+
/
test
/
browser
/
coop_header
.
sjs
?
crossOriginIsolated
=
{
crossOriginIsolated
}
)
;
if
(
resistFingerprinting
)
{
const
RFP_TIME_ATOM_MS
=
16
.
667
;
expectedPrecision
=
Math
.
max
(
RFP_TIME_ATOM_MS
expectedPrecision
)
;
}
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
{
precision
:
expectedPrecision
isRoundedFunc
:
isTimeValueRounded
.
toString
(
)
workerCall
resistFingerprinting
reduceTimerPrecision
}
]
runTests
)
;
if
(
crossOriginIsolated
)
{
let
remoteType
=
tab
.
linkedBrowser
.
remoteType
;
ok
(
remoteType
.
startsWith
(
E10SUtils
.
WEB_REMOTE_COOP_COEP_TYPE_PREFIX
)
{
remoteType
}
expected
to
be
coop
+
coep
)
;
}
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
;
async
function
calcMaximumAvailSize
(
aChromeWidth
aChromeHeight
)
{
let
chromeUIWidth
;
let
chromeUIHeight
;
let
testPath
=
"
http
:
/
/
example
.
net
/
browser
/
browser
/
"
+
"
components
/
resistfingerprinting
/
test
/
browser
/
"
;
if
(
!
aChromeWidth
|
|
!
aChromeHeight
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
testPath
+
"
file_dummy
.
html
"
)
;
let
contentSize
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
function
(
)
{
let
result
=
{
width
:
content
.
innerWidth
height
:
content
.
innerHeight
}
;
return
result
;
}
)
;
chromeUIWidth
=
win
.
outerWidth
-
contentSize
.
width
;
chromeUIHeight
=
win
.
outerHeight
-
contentSize
.
height
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
else
{
chromeUIWidth
=
aChromeWidth
;
chromeUIHeight
=
aChromeHeight
;
}
let
availWidth
=
window
.
screen
.
availWidth
;
let
availHeight
=
window
.
screen
.
availHeight
;
let
availContentWidth
=
Math
.
min
(
1000
availWidth
-
chromeUIWidth
)
;
let
availContentHeight
;
if
(
AppConstants
.
MOZ_WIDGET_GTK
)
{
availContentHeight
=
Math
.
min
(
1000
-
40
+
availHeight
-
chromeUIHeight
)
;
}
else
{
availContentHeight
=
Math
.
min
(
1000
availHeight
-
chromeUIHeight
)
;
}
let
maxAvailWidth
=
availContentWidth
-
(
availContentWidth
%
200
)
;
let
maxAvailHeight
=
availContentHeight
-
(
availContentHeight
%
100
)
;
return
{
maxAvailWidth
maxAvailHeight
}
;
}
async
function
calcPopUpWindowChromeUISize
(
)
{
let
testPath
=
"
http
:
/
/
example
.
net
/
browser
/
browser
/
"
+
"
components
/
resistFingerprinting
/
test
/
browser
/
"
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
testPath
+
"
file_dummy
.
html
"
)
;
let
result
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
function
(
)
{
let
win
;
await
new
Promise
(
resolve
=
>
{
win
=
content
.
open
(
"
about
:
blank
"
"
"
"
width
=
1000
height
=
1000
"
)
;
win
.
onload
=
(
)
=
>
resolve
(
)
;
}
)
;
let
res
=
{
chromeWidth
:
win
.
outerWidth
-
win
.
innerWidth
chromeHeight
:
win
.
outerHeight
-
win
.
innerHeight
}
;
win
.
close
(
)
;
return
res
;
}
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
return
result
;
}
async
function
testWindowOpen
(
aBrowser
aSettingWidth
aSettingHeight
aTargetWidth
aTargetHeight
aMaxAvailWidth
aMaxAvailHeight
aPopupChromeUIWidth
aPopupChromeUIHeight
)
{
if
(
aTargetWidth
>
aMaxAvailWidth
)
{
aTargetWidth
=
aMaxAvailWidth
;
}
if
(
aTargetHeight
>
aMaxAvailHeight
)
{
aTargetHeight
=
aMaxAvailHeight
;
}
let
winFeatures
=
"
width
=
"
+
aSettingWidth
+
"
height
=
"
+
aSettingHeight
;
let
testParams
=
{
winFeatures
targetWidth
:
aTargetWidth
targetHeight
:
aTargetHeight
}
;
await
SpecialPowers
.
spawn
(
aBrowser
[
testParams
]
async
function
(
input
)
{
await
new
Promise
(
resolve
=
>
{
let
win
=
content
.
open
(
"
http
:
/
/
example
.
net
/
"
"
"
input
.
winFeatures
)
;
win
.
onload
=
(
)
=
>
{
is
(
win
.
screen
.
width
input
.
targetWidth
"
The
screen
.
width
has
a
correct
rounded
value
"
)
;
is
(
win
.
screen
.
height
input
.
targetHeight
"
The
screen
.
height
has
a
correct
rounded
value
"
)
;
is
(
win
.
innerWidth
input
.
targetWidth
"
The
window
.
innerWidth
has
a
correct
rounded
value
"
)
;
is
(
win
.
innerHeight
input
.
targetHeight
"
The
window
.
innerHeight
has
a
correct
rounded
value
"
)
;
win
.
close
(
)
;
resolve
(
)
;
}
;
}
)
;
}
)
;
}
async
function
testWindowSizeSetting
(
aBrowser
aSettingWidth
aSettingHeight
aTargetWidth
aTargetHeight
aInitWidth
aInitHeight
aTestOuter
aMaxAvailWidth
aMaxAvailHeight
aPopupChromeUIWidth
aPopupChromeUIHeight
)
{
if
(
aTargetWidth
>
aMaxAvailWidth
)
{
aTargetWidth
=
aMaxAvailWidth
;
}
if
(
aTargetHeight
>
aMaxAvailHeight
)
{
aTargetHeight
=
aMaxAvailHeight
;
}
let
testParams
=
{
initWidth
:
aInitWidth
initHeight
:
aInitHeight
settingWidth
:
aSettingWidth
+
(
aTestOuter
?
aPopupChromeUIWidth
:
0
)
settingHeight
:
aSettingHeight
+
(
aTestOuter
?
aPopupChromeUIHeight
:
0
)
targetWidth
:
aTargetWidth
targetHeight
:
aTargetHeight
testOuter
:
aTestOuter
}
;
await
SpecialPowers
.
spawn
(
aBrowser
[
testParams
]
async
function
(
input
)
{
let
win
;
await
new
Promise
(
resolve
=
>
{
let
initWinFeatures
=
"
width
=
"
+
input
.
initWidth
+
"
height
=
"
+
input
.
initHeight
;
win
=
content
.
open
(
"
http
:
/
/
example
.
net
/
"
"
"
initWinFeatures
)
;
win
.
onload
=
(
)
=
>
resolve
(
)
;
}
)
;
await
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
resize
"
(
)
=
>
{
is
(
win
.
screen
.
width
input
.
targetWidth
"
The
screen
.
width
has
a
correct
rounded
value
"
)
;
is
(
win
.
innerWidth
input
.
targetWidth
"
The
window
.
innerWidth
has
a
correct
rounded
value
"
)
;
resolve
(
)
;
}
{
once
:
true
}
)
;
if
(
input
.
testOuter
)
{
win
.
outerWidth
=
input
.
settingWidth
;
}
else
{
win
.
innerWidth
=
input
.
settingWidth
;
}
}
)
;
win
.
close
(
)
;
await
new
Promise
(
resolve
=
>
{
let
initWinFeatures
=
"
width
=
"
+
input
.
initWidth
+
"
height
=
"
+
input
.
initHeight
;
win
=
content
.
open
(
"
http
:
/
/
example
.
net
/
"
"
"
initWinFeatures
)
;
win
.
onload
=
(
)
=
>
resolve
(
)
;
}
)
;
await
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
resize
"
(
)
=
>
{
is
(
win
.
screen
.
height
input
.
targetHeight
"
The
screen
.
height
has
a
correct
rounded
value
"
)
;
is
(
win
.
innerHeight
input
.
targetHeight
"
The
window
.
innerHeight
has
a
correct
rounded
value
"
)
;
resolve
(
)
;
}
{
once
:
true
}
)
;
if
(
input
.
testOuter
)
{
win
.
outerHeight
=
input
.
settingHeight
;
}
else
{
win
.
innerHeight
=
input
.
settingHeight
;
}
}
)
;
win
.
close
(
)
;
}
)
;
}
class
RoundedWindowTest
{
static
run
(
testCases
testOuter
)
{
let
test
=
new
this
(
testCases
)
;
add_task
(
async
(
)
=
>
test
.
setup
(
)
)
;
add_task
(
async
(
)
=
>
{
if
(
testOuter
=
=
undefined
)
{
await
test
.
doTests
(
false
)
;
await
test
.
doTests
(
true
)
;
}
else
{
await
test
.
doTests
(
testOuter
)
;
}
}
)
;
}
constructor
(
testCases
)
{
this
.
testCases
=
testCases
;
}
async
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
true
]
]
}
)
;
let
popUpChromeUISize
=
await
calcPopUpWindowChromeUISize
(
)
;
this
.
popupChromeUIWidth
=
popUpChromeUISize
.
chromeWidth
;
this
.
popupChromeUIHeight
=
popUpChromeUISize
.
chromeHeight
;
let
maxAvailSize
=
await
calcMaximumAvailSize
(
this
.
popupChromeUIWidth
this
.
popupChromeUIHeight
)
;
this
.
maxAvailWidth
=
maxAvailSize
.
maxAvailWidth
;
this
.
maxAvailHeight
=
maxAvailSize
.
maxAvailHeight
;
}
async
doTests
(
testOuter
)
{
this
.
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PATH
+
"
file_dummy
.
html
"
)
;
for
(
let
test
of
this
.
testCases
)
{
await
this
.
doTest
(
test
testOuter
)
;
}
BrowserTestUtils
.
removeTab
(
this
.
tab
)
;
}
async
doTest
(
)
{
throw
new
Error
(
"
RoundedWindowTest
.
doTest
must
be
overridden
.
"
)
;
}
}
class
WindowSettingTest
extends
RoundedWindowTest
{
async
doTest
(
test
testOuter
)
{
await
testWindowSizeSetting
(
this
.
tab
.
linkedBrowser
test
.
settingWidth
test
.
settingHeight
test
.
targetWidth
test
.
targetHeight
test
.
initWidth
test
.
initHeight
testOuter
this
.
maxAvailWidth
this
.
maxAvailHeight
this
.
popupChromeUIWidth
this
.
popupChromeUIHeight
)
;
}
}
class
OpenTest
extends
RoundedWindowTest
{
async
doTest
(
test
)
{
await
testWindowOpen
(
this
.
tab
.
linkedBrowser
test
.
settingWidth
test
.
settingHeight
test
.
targetWidth
test
.
targetHeight
this
.
maxAvailWidth
this
.
maxAvailHeight
this
.
popupChromeUIWidth
this
.
popupChromeUIHeight
)
;
}
}
