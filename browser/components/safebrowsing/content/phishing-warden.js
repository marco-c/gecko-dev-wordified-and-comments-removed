const
kPhishWardenEnabledPref
=
"
browser
.
safebrowsing
.
enabled
"
;
const
kPhishWardenRemoteLookups
=
"
browser
.
safebrowsing
.
remoteLookups
"
;
const
kTestUrls
=
{
"
http
:
/
/
www
.
google
.
com
/
tools
/
firefox
/
safebrowsing
/
phish
-
o
-
rama
.
html
"
:
true
"
http
:
/
/
www
.
mozilla
.
org
/
projects
/
bonecho
/
anti
-
phishing
/
its
-
a
-
trap
.
html
"
:
true
"
http
:
/
/
www
.
mozilla
.
com
/
firefox
/
its
-
a
-
trap
.
html
"
:
true
}
function
PROT_PhishingWarden
(
progressListener
tabbrowser
)
{
PROT_ListWarden
.
call
(
this
)
;
this
.
debugZone
=
"
phishwarden
"
;
this
.
testing_
=
false
;
this
.
browserViews_
=
[
]
;
this
.
prefs_
=
new
G_Preferences
(
)
;
this
.
displayers_
=
{
"
afterload
"
:
PROT_PhishMsgDisplayer
}
;
this
.
fetcher_
=
new
PROT_TRFetcher
(
)
;
this
.
checkRemote_
=
this
.
prefs_
.
getPref
(
kPhishWardenRemoteLookups
null
)
;
this
.
checkWhitelists_
=
false
;
var
checkRemotePrefObserver
=
BindToObject
(
this
.
onCheckRemotePrefChanged
this
)
;
this
.
prefs_
.
addObserver
(
kPhishWardenRemoteLookups
checkRemotePrefObserver
)
;
this
.
phishWardenEnabled_
=
this
.
prefs_
.
getPref
(
kPhishWardenEnabledPref
null
)
;
var
phishWardenPrefObserver
=
BindToObject
(
this
.
onPhishWardenEnabledPrefChanged
this
)
;
this
.
prefs_
.
addObserver
(
kPhishWardenEnabledPref
phishWardenPrefObserver
)
;
var
dataProviderPrefObserver
=
BindToObject
(
this
.
onDataProviderPrefChanged
this
)
;
this
.
prefs_
.
addObserver
(
kDataProviderIdPref
dataProviderPrefObserver
)
;
this
.
progressListener_
=
progressListener
;
this
.
progressListener_
.
callback
=
this
;
this
.
tabbrowser_
=
tabbrowser
;
tabbrowser
.
mTabBox
.
addEventListener
(
"
TabOpen
"
BindToObject
(
this
.
onTabOpen_
this
)
false
)
;
tabbrowser
.
mTabBox
.
addEventListener
(
"
TabClose
"
BindToObject
(
this
.
onTabClose_
this
)
false
)
;
if
(
this
.
phishWardenEnabled_
)
{
this
.
addWebProgressToAllTabs_
(
)
;
}
this
.
progressListener_
.
delay
=
1500
;
this
.
requestBackoff_
=
new
RequestBackoff
(
3
10
*
60
*
1000
10
*
60
*
1000
6
*
60
*
60
*
1000
)
;
G_Debug
(
this
"
phishWarden
initialized
"
)
;
}
PROT_PhishingWarden
.
inherits
(
PROT_ListWarden
)
;
PROT_PhishingWarden
.
prototype
.
QueryInterface
=
function
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsISupports
)
|
|
iid
.
equals
(
Ci
.
nsIWebProgressListener
)
|
|
iid
.
equals
(
Ci
.
nsISupportsWeakReference
)
)
return
this
;
throw
Components
.
results
.
NS_ERROR_NO_INTERFACE
;
}
PROT_PhishingWarden
.
prototype
.
shutdown
=
function
(
)
{
this
.
progressListener_
.
callback
=
null
;
this
.
progressListener_
=
null
;
this
.
listManager_
=
null
;
}
PROT_PhishingWarden
.
prototype
.
maybeToggleUpdateChecking
=
function
(
)
{
if
(
this
.
testing_
)
return
;
var
phishWardenEnabled
=
this
.
prefs_
.
getPref
(
kPhishWardenEnabledPref
null
)
;
this
.
checkRemote_
=
this
.
prefs_
.
getPref
(
kPhishWardenRemoteLookups
null
)
;
G_Debug
(
this
"
Maybe
toggling
update
checking
.
"
+
"
Warden
enabled
?
"
+
phishWardenEnabled
+
"
|
|
"
+
"
Check
remote
?
"
+
this
.
checkRemote_
)
;
if
(
phishWardenEnabled
=
=
=
null
|
|
this
.
checkRemote_
=
=
=
null
)
return
;
if
(
phishWardenEnabled
=
=
=
true
)
{
this
.
enableBlacklistTableUpdates
(
)
;
this
.
enableWhitelistTableUpdates
(
)
;
if
(
this
.
checkRemote_
=
=
=
true
)
{
var
ioService
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
var
updateHost
=
'
'
;
var
lookupHost
=
'
'
;
try
{
var
url
=
ioService
.
newURI
(
gDataProvider
.
getUpdateURL
(
)
null
null
)
;
updateHost
=
url
.
asciiHost
;
}
catch
(
e
)
{
}
try
{
var
url
=
ioService
.
newURI
(
gDataProvider
.
getLookupURL
(
)
null
null
)
;
lookupHost
=
url
.
asciiHost
;
}
catch
(
e
)
{
}
if
(
updateHost
&
&
lookupHost
&
&
updateHost
=
=
lookupHost
)
{
this
.
checkWhitelists_
=
true
;
}
else
{
this
.
checkWhitelists_
=
false
;
}
}
}
else
{
this
.
disableBlacklistTableUpdates
(
)
;
this
.
disableWhitelistTableUpdates
(
)
;
}
}
PROT_PhishingWarden
.
prototype
.
addBrowserView
=
function
(
view
)
{
G_Debug
(
this
"
New
browser
view
registered
.
"
)
;
this
.
browserViews_
.
push
(
view
)
;
}
PROT_PhishingWarden
.
prototype
.
removeBrowserView
=
function
(
view
)
{
for
(
var
i
=
0
;
i
<
this
.
browserViews_
.
length
;
i
+
+
)
if
(
this
.
browserViews_
[
i
]
=
=
=
view
)
{
G_Debug
(
this
"
Browser
view
unregistered
.
"
)
;
this
.
browserViews_
.
splice
(
i
1
)
;
return
;
}
G_Assert
(
this
false
"
Tried
to
unregister
non
-
existent
browser
view
!
"
)
;
}
PROT_PhishingWarden
.
prototype
.
onCheckRemotePrefChanged
=
function
(
prefName
)
{
this
.
checkRemote_
=
this
.
prefs_
.
getBoolPrefOrDefault
(
prefName
this
.
checkRemote_
)
;
this
.
requestBackoff_
.
reset
(
)
;
this
.
maybeToggleUpdateChecking
(
)
;
}
PROT_PhishingWarden
.
prototype
.
onPhishWardenEnabledPrefChanged
=
function
(
prefName
)
{
if
(
prefName
!
=
"
browser
.
safebrowsing
.
enabled
"
)
return
;
this
.
phishWardenEnabled_
=
this
.
prefs_
.
getBoolPrefOrDefault
(
prefName
this
.
phishWardenEnabled_
)
;
this
.
requestBackoff_
.
reset
(
)
;
this
.
maybeToggleUpdateChecking
(
)
;
if
(
this
.
phishWardenEnabled_
)
{
this
.
addWebProgressToAllTabs_
(
)
;
}
else
{
for
(
var
i
=
0
tab
=
null
;
tab
=
this
.
tabbrowser_
.
mTabs
[
i
]
;
+
+
i
)
{
var
browser
=
tab
.
linkedBrowser
;
browser
.
webProgress
.
removeProgressListener
(
this
.
progressListener_
)
;
}
}
}
PROT_PhishingWarden
.
prototype
.
onDataProviderPrefChanged
=
function
(
prefName
)
{
this
.
requestBackoff_
.
reset
(
)
;
if
(
this
.
checkRemote_
)
{
this
.
maybeToggleUpdateChecking
(
)
;
}
}
PROT_PhishingWarden
.
prototype
.
onTabOpen_
=
function
(
event
)
{
if
(
!
this
.
phishWardenEnabled_
)
return
;
var
browser
=
event
.
target
.
linkedBrowser
;
browser
.
webProgress
.
addProgressListener
(
this
.
progressListener_
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
PROT_PhishingWarden
.
prototype
.
onTabClose_
=
function
(
event
)
{
if
(
!
this
.
phishWardenEnabled_
)
return
;
var
browser
=
event
.
target
.
linkedBrowser
;
browser
.
webProgress
.
removeProgressListener
(
this
.
progressListener_
)
;
}
PROT_PhishingWarden
.
prototype
.
addWebProgressToAllTabs_
=
function
(
)
{
for
(
var
i
=
0
tab
=
null
;
tab
=
this
.
tabbrowser_
.
mTabs
[
i
]
;
+
+
i
)
{
var
browser
=
tab
.
linkedBrowser
;
browser
.
webProgress
.
addProgressListener
(
this
.
progressListener_
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
}
PROT_PhishingWarden
.
prototype
.
onDocNavStart
=
function
(
request
url
)
{
G_Debug
(
this
"
checkRemote
:
"
+
(
this
.
checkRemote_
?
"
yes
"
:
"
no
"
)
)
;
if
(
this
.
isBlacklistTestURL
(
url
)
)
{
this
.
houstonWeHaveAProblem_
(
request
)
;
return
;
}
if
(
this
.
checkRemote_
&
&
this
.
requestBackoff_
.
canMakeRequest
(
)
)
{
if
(
this
.
checkWhitelists_
)
{
var
maybeRemoteCheck
=
BindToObject
(
this
.
maybeMakeRemoteCheck_
this
url
request
)
;
this
.
isWhiteURL
(
url
maybeRemoteCheck
)
;
}
else
{
this
.
fetcher_
.
get
(
url
BindToObject
(
this
.
onTRFetchComplete
this
url
request
)
)
;
}
}
else
{
var
evilCallback
=
BindToObject
(
this
.
localListMatch_
this
url
request
)
;
this
.
isEvilURL
(
url
evilCallback
)
;
}
}
PROT_PhishingWarden
.
prototype
.
maybeMakeRemoteCheck_
=
function
(
url
request
status
)
{
if
(
PROT_ListWarden
.
IN_WHITELIST
=
=
status
)
return
;
G_Debug
(
this
"
Local
whitelist
lookup
failed
"
)
;
this
.
fetcher_
.
get
(
url
BindToObject
(
this
.
onTRFetchComplete
this
url
request
)
)
;
}
PROT_PhishingWarden
.
prototype
.
onTRFetchComplete
=
function
(
url
request
trValues
status
)
{
if
(
status
=
=
Components
.
results
.
NS_ERROR_NOT_AVAILABLE
|
|
this
.
requestBackoff_
.
isErrorStatus_
(
status
)
)
{
this
.
requestBackoff_
.
noteServerResponse
(
status
)
;
G_Debug
(
this
"
remote
check
failed
using
local
lists
instead
"
)
;
var
evilCallback
=
BindToObject
(
this
.
localListMatch_
this
url
request
)
;
this
.
isEvilURL
(
url
evilCallback
)
;
}
else
{
var
callback
=
BindToObject
(
this
.
houstonWeHaveAProblem_
this
request
)
;
this
.
checkRemoteData
(
callback
trValues
)
;
}
}
PROT_PhishingWarden
.
prototype
.
houstonWeHaveAProblem_
=
function
(
request
)
{
if
(
this
.
maybeLocateProblem_
(
request
)
)
return
;
if
(
request
.
isPending
(
)
)
{
G_Debug
(
this
"
Can
'
t
find
problem
Doc
;
Req
pending
.
Retrying
.
"
)
;
new
G_Alarm
(
BindToObject
(
this
.
houstonWeHaveAProblem_
this
request
)
200
)
;
}
else
{
G_Debug
(
this
"
Can
'
t
find
problem
Doc
;
Req
completed
.
Retrying
at
most
twice
.
"
)
;
new
G_ConditionalAlarm
(
BindToObject
(
this
.
maybeLocateProblem_
this
request
)
0
true
2
)
;
}
}
PROT_PhishingWarden
.
prototype
.
maybeLocateProblem_
=
function
(
request
)
{
G_Debug
(
this
"
Trying
to
find
the
problem
.
"
)
;
G_Debug
(
this
this
.
browserViews_
.
length
+
"
browser
views
to
check
.
"
)
;
for
(
var
i
=
0
;
i
<
this
.
browserViews_
.
length
;
i
+
+
)
{
if
(
this
.
browserViews_
[
i
]
.
tryToHandleProblemRequest
(
this
request
)
)
{
G_Debug
(
this
"
Found
browser
view
willing
to
handle
problem
!
"
)
;
return
true
;
}
G_Debug
(
this
"
wrong
browser
view
"
)
;
}
return
false
;
}
PROT_PhishingWarden
.
prototype
.
isBlacklistTestURL
=
function
(
url
)
{
if
(
kTestUrls
[
url
]
)
return
true
;
return
false
;
}
PROT_PhishingWarden
.
prototype
.
localListMatch_
=
function
(
url
request
status
)
{
if
(
PROT_ListWarden
.
IN_BLACKLIST
!
=
status
)
return
;
(
new
PROT_Reporter
)
.
report
(
"
phishblhit
"
url
)
;
this
.
houstonWeHaveAProblem_
(
request
)
;
}
PROT_PhishingWarden
.
prototype
.
checkRemoteData
=
function
(
callback
trValues
)
{
if
(
!
trValues
)
{
G_Debug
(
this
"
Didn
'
t
get
TR
values
from
the
server
.
"
)
;
return
;
}
G_Debug
(
this
"
Page
has
phishiness
"
+
trValues
[
"
phishy
"
]
)
;
if
(
trValues
[
"
phishy
"
]
=
=
1
)
{
G_Debug
(
this
"
Remote
blacklist
hit
"
)
;
callback
(
this
)
;
}
else
{
G_Debug
(
this
"
Remote
blacklist
miss
"
)
;
}
}
#
ifdef
0
var
warden
=
safebrowsing
.
phishWarden
;
function
expectLocalCheck
(
)
{
warden
.
isEvilURL
=
function
(
)
{
dump
(
"
checkurl
:
ok
\
n
"
)
;
}
warden
.
checkRemoteData
=
function
(
)
{
throw
"
unexpected
remote
check
"
;
}
}
function
expectRemoteCheck
(
)
{
warden
.
isEvilURL
=
function
(
)
{
throw
"
unexpected
local
check
"
;
}
warden
.
checkRemoteData
=
function
(
)
{
dump
(
"
checkremote
:
ok
\
n
"
)
;
}
}
warden
.
requestBackoff_
.
reset
(
)
;
expectRemoteCheck
(
)
;
warden
.
onTRFetchComplete
(
null
null
null
200
)
;
expectLocalCheck
(
)
;
warden
.
onTRFetchComplete
(
null
null
null
500
)
;
warden
.
onTRFetchComplete
(
null
null
null
502
)
;
if
(
!
warden
.
requestBackoff_
.
canMakeRequest
(
)
)
throw
"
expected
ok
"
;
warden
.
onTRFetchComplete
(
null
null
null
Components
.
results
.
NS_ERROR_NOT_AVAILABLE
)
;
if
(
!
warden
.
requestBackoff_
.
canMakeRequest
(
)
)
throw
"
expected
ok
"
;
expectLocalCheck
(
)
;
warden
.
onTRFetchComplete
(
null
null
null
303
)
;
if
(
warden
.
requestBackoff_
.
canMakeRequest
(
)
)
throw
"
expected
failed
"
;
#
endif
