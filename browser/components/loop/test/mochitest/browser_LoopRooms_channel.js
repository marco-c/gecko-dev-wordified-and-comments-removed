"
use
strict
"
;
var
{
WebChannel
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
jsm
"
{
}
)
;
var
{
Chat
}
=
Cu
.
import
(
"
resource
:
/
/
/
modules
/
Chat
.
jsm
"
{
}
)
;
const
TEST_URI
=
"
example
.
com
/
browser
/
browser
/
components
/
loop
/
test
/
mochitest
/
test_loopLinkClicker_channel
.
html
"
;
const
TEST_URI_GOOD
=
Services
.
io
.
newURI
(
"
https
:
/
/
"
+
TEST_URI
null
null
)
;
const
TEST_URI_BAD
=
Services
.
io
.
newURI
(
"
http
:
/
/
"
+
TEST_URI
null
null
)
;
const
ROOM_TOKEN
=
"
fake1234
"
;
const
LINKCLICKER_URL_PREFNAME
=
"
loop
.
linkClicker
.
url
"
;
var
openChatOrig
=
Chat
.
open
;
var
fakeRoomList
=
new
Map
(
[
[
ROOM_TOKEN
{
roomToken
:
ROOM_TOKEN
}
]
]
)
;
function
promiseNewChannelResponse
(
uri
hash
)
{
let
waitForChannelPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
channel
=
new
WebChannel
(
"
test
-
loop
-
link
-
clicker
-
backchannel
"
uri
)
;
channel
.
listen
(
(
id
data
target
)
=
>
{
channel
.
stopListening
(
)
;
resolve
(
data
)
;
}
)
;
}
)
;
return
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
gBrowser
url
:
uri
.
spec
+
"
#
"
+
hash
}
(
)
=
>
waitForChannelPromise
)
;
}
add_task
(
function
*
test_loopRooms_webChannel_permissions
(
)
{
let
got
=
yield
promiseNewChannelResponse
(
TEST_URI_GOOD
"
checkWillOpenRoom
"
)
;
Assert
.
ok
(
got
.
message
=
=
=
undefined
"
should
have
failed
to
get
any
data
"
)
;
Services
.
prefs
.
setCharPref
(
LINKCLICKER_URL_PREFNAME
TEST_URI_GOOD
.
spec
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
LINKCLICKER_URL_PREFNAME
)
;
}
)
;
got
=
yield
promiseNewChannelResponse
(
TEST_URI_GOOD
"
checkWillOpenRoom
"
)
;
Assert
.
equal
(
got
.
message
.
response
false
"
should
have
got
a
response
of
false
"
)
;
got
=
yield
promiseNewChannelResponse
(
TEST_URI_BAD
"
checkWillOpenRoom
"
)
;
Assert
.
ok
(
got
.
message
=
=
=
undefined
"
should
have
failed
to
get
any
data
"
)
;
}
)
;
add_task
(
function
*
test_loopRooms_webchannel_checkWillOpenRoom
(
)
{
LoopRooms
.
_setRoomsCache
(
fakeRoomList
)
;
let
got
=
yield
promiseNewChannelResponse
(
TEST_URI_GOOD
"
checkWillOpenRoom
"
)
;
Assert
.
equal
(
got
.
message
.
response
true
"
should
have
got
a
response
of
true
"
)
;
}
)
;
add_task
(
function
*
test_loopRooms_webchannel_openRoom
(
)
{
let
openedUrl
;
Chat
.
open
=
function
(
contentWindow
origin
title
url
)
{
openedUrl
=
url
;
}
;
registerCleanupFunction
(
(
)
=
>
{
Chat
.
open
=
openChatOrig
;
}
)
;
LoopRooms
.
_setRoomsCache
(
)
;
let
got
=
yield
promiseNewChannelResponse
(
TEST_URI_GOOD
"
openRoom
"
)
;
Assert
.
ok
(
!
openedUrl
"
should
not
open
a
chat
window
"
)
;
Assert
.
equal
(
got
.
message
.
response
false
"
should
have
got
a
response
of
false
"
)
;
LoopRooms
.
_setRoomsCache
(
fakeRoomList
)
;
got
=
yield
promiseNewChannelResponse
(
TEST_URI_GOOD
"
openRoom
"
)
;
Assert
.
ok
(
openedUrl
"
should
open
a
chat
window
"
)
;
let
windowId
=
openedUrl
.
match
(
/
about
:
loopconversation
\
#
(
\
w
+
)
/
)
[
1
]
;
let
windowData
=
MozLoopService
.
getConversationWindowData
(
windowId
)
;
Assert
.
equal
(
windowData
.
type
"
room
"
"
window
data
should
contain
room
as
the
type
"
)
;
Assert
.
equal
(
windowData
.
roomToken
ROOM_TOKEN
"
window
data
should
have
the
roomToken
"
)
;
Assert
.
equal
(
got
.
message
.
response
true
"
should
have
got
a
response
of
true
"
)
;
}
)
;
