var
LoopMochaUtils
=
(
function
(
global
_
)
{
"
use
strict
"
;
var
gStubbedRequests
;
var
gListenerCallbacks
=
[
]
;
var
gPushListenerCallbacks
=
[
]
;
var
gOldAddMessageListener
gOldSendAsyncMessage
;
function
syncThenable
(
asyncFn
)
{
var
continuations
=
[
]
;
var
resolved
=
false
;
var
resolvedWith
=
null
;
this
.
then
=
function
(
contFn
)
{
if
(
resolved
)
{
contFn
(
resolvedWith
)
;
return
this
;
}
continuations
.
push
(
contFn
)
;
return
this
;
}
;
this
.
resolve
=
function
(
result
)
{
resolved
=
true
;
resolvedWith
=
result
;
if
(
!
continuations
.
length
)
{
return
this
;
}
var
contFn
=
continuations
.
shift
(
)
;
while
(
contFn
)
{
contFn
(
result
)
;
contFn
=
continuations
.
shift
(
)
;
}
return
this
;
}
;
this
.
reject
=
function
(
result
)
{
throw
result
;
}
;
asyncFn
(
this
.
resolve
.
bind
(
this
)
this
.
reject
.
bind
(
this
)
)
;
}
syncThenable
.
all
=
function
(
promises
)
{
return
new
syncThenable
(
function
(
resolve
)
{
var
results
=
[
]
;
promises
.
forEach
(
function
(
promise
)
{
promise
.
then
(
function
(
result
)
{
results
.
push
(
result
)
;
}
)
;
}
)
;
resolve
(
results
)
;
}
)
;
}
;
function
createSandbox
(
)
{
var
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
global
"
Promise
"
syncThenable
)
;
return
sandbox
;
}
function
invokeListenerCallbacks
(
data
)
{
gListenerCallbacks
.
forEach
(
function
(
cb
)
{
cb
(
data
)
;
}
)
;
}
function
handleIncomingRequest
(
data
isBatch
)
{
var
seq
=
data
.
shift
(
)
;
var
action
=
data
.
shift
(
)
;
var
result
;
if
(
action
=
=
=
"
Batch
"
)
{
result
=
{
}
;
data
[
0
]
.
forEach
(
function
(
req
)
{
result
[
req
[
0
]
]
=
handleIncomingRequest
(
req
true
)
;
}
)
;
invokeListenerCallbacks
(
{
data
:
[
seq
result
]
}
)
;
}
else
{
if
(
!
gStubbedRequests
[
action
]
)
{
throw
new
Error
(
"
Action
'
"
+
action
+
"
'
not
part
of
stubbed
requests
!
Please
add
it
!
"
)
;
}
result
=
gStubbedRequests
[
action
]
.
apply
(
gStubbedRequests
data
)
;
if
(
isBatch
)
{
return
result
;
}
invokeListenerCallbacks
(
{
data
:
[
seq
result
]
}
)
;
}
}
function
addMessageListenerInternal
(
name
listenerCallback
)
{
if
(
name
=
=
=
"
Loop
:
Message
"
)
{
gListenerCallbacks
.
push
(
listenerCallback
)
;
}
else
if
(
name
=
=
=
"
Loop
:
Message
:
Push
"
)
{
gPushListenerCallbacks
.
push
(
listenerCallback
)
;
}
}
function
sendAsyncMessageInternal
(
messageName
data
)
{
handleIncomingRequest
(
data
)
;
}
function
stubLoopRequest
(
stubbedRequests
)
{
if
(
!
global
.
addMessageListener
|
|
global
.
addMessageListener
!
=
=
addMessageListenerInternal
)
{
if
(
!
gOldSendAsyncMessage
)
{
gOldAddMessageListener
=
global
.
addMessageListener
;
}
if
(
!
gOldSendAsyncMessage
)
{
gOldSendAsyncMessage
=
global
.
sendAsyncMessage
;
}
global
.
addMessageListener
=
addMessageListenerInternal
;
global
.
sendAsyncMessage
=
sendAsyncMessageInternal
;
gStubbedRequests
=
{
}
;
}
_
.
extend
(
gStubbedRequests
stubbedRequests
)
;
}
function
publish
(
)
{
var
args
=
Array
.
slice
(
arguments
)
;
var
name
=
args
.
shift
(
)
;
gPushListenerCallbacks
.
forEach
(
function
(
cb
)
{
cb
(
{
data
:
[
name
args
]
}
)
;
}
)
;
}
function
restore
(
)
{
if
(
!
global
.
addMessageListener
)
{
return
;
}
if
(
gOldAddMessageListener
)
{
global
.
addMessageListener
=
gOldAddMessageListener
;
}
else
{
delete
global
.
addMessageListener
;
}
if
(
gOldSendAsyncMessage
)
{
global
.
sendAsyncMessage
=
gOldSendAsyncMessage
;
}
else
{
delete
global
.
sendAsyncMessage
;
}
gStubbedRequests
=
null
;
gListenerCallbacks
=
[
]
;
gPushListenerCallbacks
=
[
]
;
loop
.
request
.
reset
(
)
;
loop
.
subscribe
.
reset
(
)
;
}
return
{
createSandbox
:
createSandbox
stubLoopRequest
:
stubLoopRequest
restore
:
restore
publish
:
publish
}
;
}
)
(
this
_
)
;
