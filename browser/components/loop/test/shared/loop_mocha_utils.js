var
LoopMochaUtils
=
(
function
(
global
_
)
{
"
use
strict
"
;
var
gStubbedRequests
;
var
gListenerCallbacks
=
[
]
;
var
gPushListenerCallbacks
=
[
]
;
var
gOldAddMessageListener
gOldSendAsyncMessage
;
var
gUncaughtError
;
var
gCaughtIssues
=
[
]
;
function
syncThenable
(
asyncFn
)
{
var
continuations
=
[
]
;
var
resolved
=
false
;
var
resolvedWith
=
null
;
this
.
then
=
function
(
contFn
)
{
if
(
resolved
)
{
contFn
(
resolvedWith
)
;
return
this
;
}
continuations
.
push
(
contFn
)
;
return
this
;
}
;
this
.
resolve
=
function
(
result
)
{
resolved
=
true
;
resolvedWith
=
result
;
if
(
!
continuations
.
length
)
{
return
this
;
}
var
contFn
=
continuations
.
shift
(
)
;
while
(
contFn
)
{
contFn
(
result
)
;
contFn
=
continuations
.
shift
(
)
;
}
return
this
;
}
;
this
.
reject
=
function
(
result
)
{
throw
result
;
}
;
asyncFn
(
this
.
resolve
.
bind
(
this
)
this
.
reject
.
bind
(
this
)
)
;
}
syncThenable
.
all
=
function
(
promises
)
{
return
new
syncThenable
(
function
(
resolve
)
{
var
results
=
[
]
;
promises
.
forEach
(
function
(
promise
)
{
promise
.
then
(
function
(
result
)
{
results
.
push
(
result
)
;
}
)
;
}
)
;
resolve
(
results
)
;
}
)
;
}
;
function
createSandbox
(
)
{
var
sandbox
=
sinon
.
sandbox
.
create
(
)
;
sandbox
.
stub
(
global
"
Promise
"
syncThenable
)
;
return
sandbox
;
}
function
invokeListenerCallbacks
(
data
)
{
gListenerCallbacks
.
forEach
(
function
(
cb
)
{
cb
(
data
)
;
}
)
;
}
function
handleIncomingRequest
(
data
isBatch
)
{
var
seq
=
data
.
shift
(
)
;
var
action
=
data
.
shift
(
)
;
var
result
;
if
(
action
=
=
=
"
Batch
"
)
{
result
=
{
}
;
data
[
0
]
.
forEach
(
function
(
req
)
{
result
[
req
[
0
]
]
=
handleIncomingRequest
(
req
true
)
;
}
)
;
invokeListenerCallbacks
(
{
data
:
[
seq
result
]
}
)
;
}
else
{
if
(
!
gStubbedRequests
[
action
]
)
{
throw
new
Error
(
"
Action
'
"
+
action
+
"
'
not
part
of
stubbed
requests
!
Please
add
it
!
"
)
;
}
result
=
gStubbedRequests
[
action
]
.
apply
(
gStubbedRequests
data
)
;
if
(
isBatch
)
{
return
result
;
}
invokeListenerCallbacks
(
{
data
:
[
seq
result
]
}
)
;
}
}
function
addMessageListenerInternal
(
name
listenerCallback
)
{
if
(
name
=
=
=
"
Loop
:
Message
"
)
{
gListenerCallbacks
.
push
(
listenerCallback
)
;
}
else
if
(
name
=
=
=
"
Loop
:
Message
:
Push
"
)
{
gPushListenerCallbacks
.
push
(
listenerCallback
)
;
}
}
function
sendAsyncMessageInternal
(
messageName
data
)
{
handleIncomingRequest
(
data
)
;
}
function
stubLoopRequest
(
stubbedRequests
)
{
if
(
!
global
.
addMessageListener
|
|
global
.
addMessageListener
!
=
=
addMessageListenerInternal
)
{
if
(
!
gOldSendAsyncMessage
)
{
gOldAddMessageListener
=
global
.
addMessageListener
;
}
if
(
!
gOldSendAsyncMessage
)
{
gOldSendAsyncMessage
=
global
.
sendAsyncMessage
;
}
global
.
addMessageListener
=
addMessageListenerInternal
;
global
.
sendAsyncMessage
=
sendAsyncMessageInternal
;
gStubbedRequests
=
{
}
;
}
_
.
extend
(
gStubbedRequests
stubbedRequests
)
;
}
function
publish
(
)
{
var
args
=
Array
.
slice
(
arguments
)
;
var
name
=
args
.
shift
(
)
;
gPushListenerCallbacks
.
forEach
(
function
(
cb
)
{
cb
(
{
data
:
[
name
args
]
}
)
;
}
)
;
}
function
restore
(
)
{
if
(
!
global
.
addMessageListener
)
{
return
;
}
if
(
gOldAddMessageListener
)
{
global
.
addMessageListener
=
gOldAddMessageListener
;
}
else
{
delete
global
.
addMessageListener
;
}
if
(
gOldSendAsyncMessage
)
{
global
.
sendAsyncMessage
=
gOldSendAsyncMessage
;
}
else
{
delete
global
.
sendAsyncMessage
;
}
gStubbedRequests
=
null
;
gListenerCallbacks
=
[
]
;
gPushListenerCallbacks
=
[
]
;
loop
.
request
.
reset
(
)
;
loop
.
subscribe
.
reset
(
)
;
}
function
trapErrors
(
)
{
window
.
addEventListener
(
"
error
"
function
(
error
)
{
gUncaughtError
=
error
;
}
)
;
var
consoleWarn
=
console
.
warn
;
var
consoleError
=
console
.
error
;
console
.
warn
=
function
(
)
{
var
args
=
Array
.
slice
(
arguments
)
;
try
{
throw
new
Error
(
)
;
}
catch
(
e
)
{
gCaughtIssues
.
push
(
[
args
e
.
stack
]
)
;
}
consoleWarn
.
apply
(
console
args
)
;
}
;
console
.
error
=
function
(
)
{
var
args
=
Array
.
slice
(
arguments
)
;
gCaughtIssues
.
push
(
args
)
;
consoleError
.
apply
(
console
args
)
;
}
;
}
function
addErrorCheckingTests
(
)
{
describe
(
"
Uncaught
Error
Check
"
function
(
)
{
it
(
"
should
load
the
tests
without
errors
"
function
(
)
{
chai
.
expect
(
gUncaughtError
&
&
gUncaughtError
.
message
)
.
to
.
be
.
undefined
;
}
)
;
}
)
;
describe
(
"
Unexpected
Logged
Warnings
and
Errors
Check
"
function
(
)
{
it
(
"
should
not
log
any
warnings
nor
errors
"
function
(
)
{
if
(
gCaughtIssues
.
length
)
{
throw
new
Error
(
gCaughtIssues
)
;
}
else
{
chai
.
expect
(
gCaughtIssues
.
length
)
.
to
.
eql
(
0
)
;
}
}
)
;
}
)
;
}
function
runTests
(
)
{
mocha
.
run
(
function
(
)
{
var
completeNode
=
document
.
createElement
(
"
p
"
)
;
completeNode
.
setAttribute
(
"
id
"
"
complete
"
)
;
completeNode
.
appendChild
(
document
.
createTextNode
(
"
Complete
"
)
)
;
document
.
getElementById
(
"
mocha
"
)
.
appendChild
(
completeNode
)
;
}
)
;
}
return
{
addErrorCheckingTests
:
addErrorCheckingTests
createSandbox
:
createSandbox
publish
:
publish
restore
:
restore
runTests
:
runTests
stubLoopRequest
:
stubLoopRequest
trapErrors
:
trapErrors
}
;
}
)
(
this
_
)
;
