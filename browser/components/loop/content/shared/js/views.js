var
loop
=
loop
|
|
{
}
;
loop
.
shared
=
loop
.
shared
|
|
{
}
;
loop
.
shared
.
views
=
(
function
(
_
mozL10n
)
{
"
use
strict
"
;
var
sharedActions
=
loop
.
shared
.
actions
;
var
sharedModels
=
loop
.
shared
.
models
;
var
sharedMixins
=
loop
.
shared
.
mixins
;
var
SCREEN_SHARE_STATES
=
loop
.
shared
.
utils
.
SCREEN_SHARE_STATES
;
var
MediaControlButton
=
React
.
createClass
(
{
displayName
:
"
MediaControlButton
"
propTypes
:
{
action
:
React
.
PropTypes
.
func
.
isRequired
enabled
:
React
.
PropTypes
.
bool
.
isRequired
scope
:
React
.
PropTypes
.
string
.
isRequired
title
:
React
.
PropTypes
.
string
type
:
React
.
PropTypes
.
string
.
isRequired
visible
:
React
.
PropTypes
.
bool
.
isRequired
}
getDefaultProps
:
function
(
)
{
return
{
enabled
:
true
visible
:
true
}
;
}
handleClick
:
function
(
)
{
this
.
props
.
action
(
)
;
}
_getClasses
:
function
(
)
{
var
cx
=
React
.
addons
.
classSet
;
var
classesObj
=
{
"
btn
"
:
true
"
media
-
control
"
:
true
"
transparent
-
button
"
:
true
"
local
-
media
"
:
this
.
props
.
scope
=
=
=
"
local
"
"
muted
"
:
!
this
.
props
.
enabled
"
hide
"
:
!
this
.
props
.
visible
}
;
classesObj
[
"
btn
-
mute
-
"
+
this
.
props
.
type
]
=
true
;
return
cx
(
classesObj
)
;
}
_getTitle
:
function
(
enabled
)
{
if
(
this
.
props
.
title
)
{
return
this
.
props
.
title
;
}
var
prefix
=
this
.
props
.
enabled
?
"
mute
"
:
"
unmute
"
;
var
suffix
=
(
this
.
props
.
type
=
=
=
"
video
"
)
?
"
button_title2
"
:
"
button_title
"
;
var
msgId
=
[
prefix
this
.
props
.
scope
this
.
props
.
type
suffix
]
.
join
(
"
_
"
)
;
return
mozL10n
.
get
(
msgId
)
;
}
render
:
function
(
)
{
return
(
React
.
createElement
(
"
button
"
{
className
:
this
.
_getClasses
(
)
onClick
:
this
.
handleClick
title
:
this
.
_getTitle
(
)
}
)
)
;
}
}
)
;
var
ScreenShareControlButton
=
React
.
createClass
(
{
displayName
:
"
ScreenShareControlButton
"
mixins
:
[
sharedMixins
.
DropdownMenuMixin
(
)
]
propTypes
:
{
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
state
:
React
.
PropTypes
.
string
.
isRequired
visible
:
React
.
PropTypes
.
bool
.
isRequired
}
getInitialState
:
function
(
)
{
var
os
=
loop
.
shared
.
utils
.
getOS
(
)
;
var
osVersion
=
loop
.
shared
.
utils
.
getOSVersion
(
)
;
if
(
(
os
.
indexOf
(
"
mac
"
)
>
-
1
&
&
osVersion
.
major
<
=
10
&
&
osVersion
.
minor
<
=
6
)
|
|
(
os
.
indexOf
(
"
win
"
)
>
-
1
&
&
osVersion
.
major
<
=
5
&
&
osVersion
.
minor
<
=
2
)
)
{
return
{
windowSharingDisabled
:
true
}
;
}
return
{
windowSharingDisabled
:
false
}
;
}
handleClick
:
function
(
)
{
if
(
this
.
props
.
state
=
=
=
SCREEN_SHARE_STATES
.
ACTIVE
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
EndScreenShare
(
{
}
)
)
;
}
else
{
this
.
toggleDropdownMenu
(
)
;
}
}
_startScreenShare
:
function
(
type
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
StartScreenShare
(
{
type
:
type
}
)
)
;
}
_handleShareTabs
:
function
(
)
{
this
.
_startScreenShare
(
"
browser
"
)
;
}
_handleShareWindows
:
function
(
)
{
this
.
_startScreenShare
(
"
window
"
)
;
}
_getTitle
:
function
(
)
{
var
prefix
=
this
.
props
.
state
=
=
=
SCREEN_SHARE_STATES
.
ACTIVE
?
"
active
"
:
"
inactive
"
;
return
mozL10n
.
get
(
prefix
+
"
_screenshare_button_title
"
)
;
}
render
:
function
(
)
{
if
(
!
this
.
props
.
visible
)
{
return
null
;
}
var
cx
=
React
.
addons
.
classSet
;
var
isActive
=
this
.
props
.
state
=
=
=
SCREEN_SHARE_STATES
.
ACTIVE
;
var
screenShareClasses
=
cx
(
{
"
btn
"
:
true
"
btn
-
screen
-
share
"
:
true
"
transparent
-
button
"
:
true
"
menu
-
showing
"
:
this
.
state
.
showMenu
"
active
"
:
isActive
"
disabled
"
:
this
.
props
.
state
=
=
=
SCREEN_SHARE_STATES
.
PENDING
}
)
;
var
dropdownMenuClasses
=
cx
(
{
"
native
-
dropdown
-
menu
"
:
true
"
conversation
-
window
-
dropdown
"
:
true
"
hide
"
:
!
this
.
state
.
showMenu
"
visually
-
hidden
"
:
true
}
)
;
var
windowSharingClasses
=
cx
(
{
"
disabled
"
:
this
.
state
.
windowSharingDisabled
}
)
;
return
(
React
.
createElement
(
"
div
"
null
React
.
createElement
(
"
button
"
{
className
:
screenShareClasses
onClick
:
this
.
handleClick
ref
:
"
menu
-
button
"
title
:
this
.
_getTitle
(
)
}
isActive
?
null
:
React
.
createElement
(
"
span
"
{
className
:
"
chevron
"
}
)
)
React
.
createElement
(
"
ul
"
{
className
:
dropdownMenuClasses
ref
:
"
menu
"
}
React
.
createElement
(
"
li
"
{
onClick
:
this
.
_handleShareTabs
}
mozL10n
.
get
(
"
share_tabs_button_title2
"
)
)
React
.
createElement
(
"
li
"
{
className
:
windowSharingClasses
onClick
:
this
.
_handleShareWindows
}
mozL10n
.
get
(
"
share_windows_button_title
"
)
)
)
)
)
;
}
}
)
;
var
SettingsControlButton
=
React
.
createClass
(
{
displayName
:
"
SettingsControlButton
"
propTypes
:
{
menuBelow
:
React
.
PropTypes
.
bool
menuItems
:
React
.
PropTypes
.
array
mozLoop
:
React
.
PropTypes
.
object
}
mixins
:
[
sharedMixins
.
DropdownMenuMixin
(
)
React
.
addons
.
PureRenderMixin
]
getDefaultProps
:
function
(
)
{
return
{
menuBelow
:
false
}
;
}
handleClick
:
function
(
event
)
{
event
.
preventDefault
(
)
;
this
.
toggleDropdownMenu
(
)
;
}
getHandleToggleEdit
:
function
(
editItem
)
{
return
function
_handleToglleEdit
(
event
)
{
event
.
preventDefault
(
)
;
if
(
editItem
.
onClick
)
{
editItem
.
onClick
(
!
editItem
.
enabled
)
;
}
}
;
}
handleHelpEntry
:
function
(
event
)
{
event
.
preventDefault
(
)
;
var
helloSupportUrl
=
this
.
props
.
mozLoop
.
getLoopPref
(
"
support_url
"
)
;
this
.
props
.
mozLoop
.
openURL
(
helloSupportUrl
)
;
}
handleSubmitFeedback
:
function
(
event
)
{
event
.
preventDefault
(
)
;
var
helloFeedbackUrl
=
this
.
props
.
mozLoop
.
getLoopPref
(
"
feedback
.
formURL
"
)
;
this
.
props
.
mozLoop
.
openURL
(
helloFeedbackUrl
)
;
}
getItemInfo
:
function
(
menuItem
)
{
var
cx
=
React
.
addons
.
classSet
;
switch
(
menuItem
.
id
)
{
case
"
feedback
"
:
return
{
cssClasses
:
"
dropdown
-
menu
-
item
"
handler
:
this
.
handleSubmitFeedback
label
:
mozL10n
.
get
(
"
feedback_request_button
"
)
}
;
case
"
help
"
:
return
{
cssClasses
:
"
dropdown
-
menu
-
item
"
handler
:
this
.
handleHelpEntry
label
:
mozL10n
.
get
(
"
help_label
"
)
}
;
case
"
edit
"
:
return
{
cssClasses
:
cx
(
{
"
dropdown
-
menu
-
item
"
:
true
"
entry
-
settings
-
edit
"
:
true
"
hide
"
:
!
menuItem
.
visible
}
)
handler
:
this
.
getHandleToggleEdit
(
menuItem
)
label
:
mozL10n
.
get
(
menuItem
.
enabled
?
"
conversation_settings_menu_edit_context
"
:
"
conversation_settings_menu_hide_context
"
)
scope
:
"
local
"
type
:
"
edit
"
}
;
default
:
console
.
error
(
"
Invalid
menu
item
"
menuItem
)
;
return
null
;
}
}
generateMenuItem
:
function
(
menuItem
)
{
var
itemInfo
=
this
.
getItemInfo
(
menuItem
)
;
if
(
!
itemInfo
)
{
return
null
;
}
return
(
React
.
createElement
(
"
li
"
{
className
:
itemInfo
.
cssClasses
key
:
menuItem
.
id
onClick
:
itemInfo
.
handler
scope
:
itemInfo
.
scope
|
|
"
"
type
:
itemInfo
.
type
|
|
"
"
}
itemInfo
.
label
)
)
;
}
render
:
function
(
)
{
if
(
!
this
.
props
.
menuItems
|
|
!
this
.
props
.
menuItems
.
length
)
{
return
null
;
}
var
menuItemRows
=
this
.
props
.
menuItems
.
map
(
this
.
generateMenuItem
)
.
filter
(
function
(
item
)
{
return
item
;
}
)
;
if
(
!
menuItemRows
|
|
!
menuItemRows
.
length
)
{
return
null
;
}
var
cx
=
React
.
addons
.
classSet
;
var
settingsDropdownMenuClasses
=
cx
(
{
"
settings
-
menu
"
:
true
"
dropdown
-
menu
"
:
true
"
menu
-
below
"
:
this
.
props
.
menuBelow
"
hide
"
:
!
this
.
state
.
showMenu
}
)
;
return
(
React
.
createElement
(
"
div
"
{
className
:
"
settings
-
control
"
}
React
.
createElement
(
"
button
"
{
className
:
"
btn
btn
-
settings
transparent
-
button
"
onClick
:
this
.
toggleDropdownMenu
ref
:
"
anchor
"
title
:
mozL10n
.
get
(
"
settings_menu_button_tooltip
"
)
}
)
React
.
createElement
(
"
ul
"
{
className
:
settingsDropdownMenuClasses
ref
:
"
menu
"
}
menuItemRows
)
)
)
;
}
}
)
;
var
ConversationToolbar
=
React
.
createClass
(
{
displayName
:
"
ConversationToolbar
"
getDefaultProps
:
function
(
)
{
return
{
video
:
{
enabled
:
true
visible
:
true
}
audio
:
{
enabled
:
true
visible
:
true
}
screenShare
:
{
state
:
SCREEN_SHARE_STATES
.
INACTIVE
visible
:
false
}
settingsMenuItems
:
null
enableHangup
:
true
}
;
}
getInitialState
:
function
(
)
{
return
{
idle
:
false
}
;
}
propTypes
:
{
audio
:
React
.
PropTypes
.
object
.
isRequired
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
enableHangup
:
React
.
PropTypes
.
bool
hangup
:
React
.
PropTypes
.
func
.
isRequired
hangupButtonLabel
:
React
.
PropTypes
.
string
mozLoop
:
React
.
PropTypes
.
object
publishStream
:
React
.
PropTypes
.
func
.
isRequired
screenShare
:
React
.
PropTypes
.
object
settingsMenuItems
:
React
.
PropTypes
.
array
video
:
React
.
PropTypes
.
object
.
isRequired
}
handleClickHangup
:
function
(
)
{
this
.
props
.
hangup
(
)
;
}
handleToggleVideo
:
function
(
)
{
this
.
props
.
publishStream
(
"
video
"
!
this
.
props
.
video
.
enabled
)
;
}
handleToggleAudio
:
function
(
)
{
this
.
props
.
publishStream
(
"
audio
"
!
this
.
props
.
audio
.
enabled
)
;
}
componentDidMount
:
function
(
)
{
this
.
userActivity
=
false
;
this
.
startIdleCountDown
(
)
;
document
.
body
.
addEventListener
(
"
mousemove
"
this
.
_onBodyMouseMove
)
;
}
componentWillUnmount
:
function
(
)
{
clearTimeout
(
this
.
inactivityTimeout
)
;
clearInterval
(
this
.
inactivityPollInterval
)
;
document
.
body
.
removeEventListener
(
"
mousemove
"
this
.
_onBodyMouseMove
)
;
}
_onBodyMouseMove
:
function
(
)
{
if
(
this
.
state
.
idle
)
{
this
.
setState
(
{
idle
:
false
}
)
;
this
.
startIdleCountDown
(
)
;
}
else
{
this
.
userActivity
=
true
;
}
}
checkUserActivity
:
function
(
)
{
this
.
inactivityPollInterval
=
setInterval
(
function
(
)
{
if
(
this
.
userActivity
)
{
this
.
userActivity
=
false
;
this
.
restartIdleCountDown
(
)
;
}
}
.
bind
(
this
)
4000
)
;
}
restartIdleCountDown
:
function
(
)
{
clearTimeout
(
this
.
inactivityTimeout
)
;
this
.
startIdleCountDown
(
)
;
}
startIdleCountDown
:
function
(
)
{
this
.
checkUserActivity
(
)
;
this
.
inactivityTimeout
=
setTimeout
(
function
(
)
{
this
.
setState
(
{
idle
:
true
}
)
;
clearInterval
(
this
.
inactivityPollInterval
)
;
}
.
bind
(
this
)
6000
)
;
}
_getHangupButtonLabel
:
function
(
)
{
return
this
.
props
.
hangupButtonLabel
|
|
mozL10n
.
get
(
"
hangup_button_caption2
"
)
;
}
render
:
function
(
)
{
var
cx
=
React
.
addons
.
classSet
;
var
conversationToolbarCssClasses
=
cx
(
{
"
conversation
-
toolbar
"
:
true
"
idle
"
:
this
.
state
.
idle
}
)
;
var
mediaButtonGroupCssClasses
=
cx
(
{
"
conversation
-
toolbar
-
media
-
btn
-
group
-
box
"
:
true
"
hide
"
:
(
!
this
.
props
.
video
.
visible
&
&
!
this
.
props
.
audio
.
visible
)
}
)
;
return
(
React
.
createElement
(
"
ul
"
{
className
:
conversationToolbarCssClasses
}
React
.
createElement
(
"
li
"
{
className
:
"
conversation
-
toolbar
-
btn
-
box
btn
-
hangup
-
entry
"
}
React
.
createElement
(
"
button
"
{
className
:
"
btn
btn
-
hangup
"
disabled
:
!
this
.
props
.
enableHangup
onClick
:
this
.
handleClickHangup
title
:
mozL10n
.
get
(
"
hangup_button_title
"
)
}
this
.
_getHangupButtonLabel
(
)
)
)
React
.
createElement
(
"
li
"
{
className
:
"
conversation
-
toolbar
-
btn
-
box
"
}
React
.
createElement
(
"
div
"
{
className
:
mediaButtonGroupCssClasses
}
React
.
createElement
(
MediaControlButton
{
action
:
this
.
handleToggleVideo
enabled
:
this
.
props
.
video
.
enabled
scope
:
"
local
"
type
:
"
video
"
visible
:
this
.
props
.
video
.
visible
}
)
React
.
createElement
(
MediaControlButton
{
action
:
this
.
handleToggleAudio
enabled
:
this
.
props
.
audio
.
enabled
scope
:
"
local
"
type
:
"
audio
"
visible
:
this
.
props
.
audio
.
visible
}
)
)
)
React
.
createElement
(
"
li
"
{
className
:
"
conversation
-
toolbar
-
btn
-
box
"
}
React
.
createElement
(
ScreenShareControlButton
{
dispatcher
:
this
.
props
.
dispatcher
state
:
this
.
props
.
screenShare
.
state
visible
:
this
.
props
.
screenShare
.
visible
}
)
)
React
.
createElement
(
"
li
"
{
className
:
"
conversation
-
toolbar
-
btn
-
box
btn
-
edit
-
entry
"
}
React
.
createElement
(
SettingsControlButton
{
menuItems
:
this
.
props
.
settingsMenuItems
mozLoop
:
this
.
props
.
mozLoop
}
)
)
)
)
;
}
}
)
;
var
ConversationView
=
React
.
createClass
(
{
displayName
:
"
ConversationView
"
mixins
:
[
Backbone
.
Events
sharedMixins
.
AudioMixin
sharedMixins
.
MediaSetupMixin
]
propTypes
:
{
audio
:
React
.
PropTypes
.
object
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
initiate
:
React
.
PropTypes
.
bool
isDesktop
:
React
.
PropTypes
.
bool
model
:
React
.
PropTypes
.
object
.
isRequired
mozLoop
:
React
.
PropTypes
.
object
sdk
:
React
.
PropTypes
.
object
.
isRequired
video
:
React
.
PropTypes
.
object
}
getDefaultProps
:
function
(
)
{
return
{
initiate
:
true
isDesktop
:
false
video
:
{
enabled
:
true
visible
:
true
}
audio
:
{
enabled
:
true
visible
:
true
}
}
;
}
getInitialState
:
function
(
)
{
return
{
video
:
this
.
props
.
video
audio
:
this
.
props
.
audio
}
;
}
componentDidMount
:
function
(
)
{
if
(
this
.
props
.
initiate
)
{
if
(
this
.
props
.
isDesktop
&
&
!
window
.
MediaStreamTrack
.
getSources
)
{
window
.
MediaStreamTrack
.
getSources
=
function
(
callback
)
{
callback
(
[
{
kind
:
"
audio
"
}
{
kind
:
"
video
"
}
]
)
;
}
;
}
this
.
listenTo
(
this
.
props
.
sdk
"
exception
"
this
.
_handleSdkException
)
;
this
.
listenTo
(
this
.
props
.
model
"
session
:
connected
"
this
.
_onSessionConnected
)
;
this
.
listenTo
(
this
.
props
.
model
"
session
:
stream
-
created
"
this
.
_streamCreated
)
;
this
.
listenTo
(
this
.
props
.
model
[
"
session
:
peer
-
hungup
"
"
session
:
network
-
disconnected
"
"
session
:
ended
"
]
.
join
(
"
"
)
this
.
stopPublishing
)
;
this
.
props
.
model
.
startSession
(
)
;
}
}
componentWillUnmount
:
function
(
)
{
this
.
stopListening
(
)
;
this
.
hangup
(
)
;
}
hangup
:
function
(
)
{
this
.
stopPublishing
(
)
;
this
.
props
.
model
.
endSession
(
)
;
}
_onSessionConnected
:
function
(
event
)
{
this
.
startPublishing
(
event
)
;
this
.
play
(
"
connected
"
)
;
}
_streamCreated
:
function
(
event
)
{
var
incoming
=
this
.
getDOMNode
(
)
.
querySelector
(
"
.
remote
"
)
;
this
.
props
.
model
.
subscribe
(
event
.
stream
incoming
this
.
getDefaultPublisherConfig
(
{
publishVideo
:
this
.
props
.
video
.
enabled
}
)
)
;
}
_handleSdkException
:
function
(
event
)
{
if
(
this
.
publisher
&
&
event
.
code
=
=
=
OT
.
ExceptionCodes
.
UNABLE_TO_PUBLISH
&
&
event
.
message
=
=
=
"
GetUserMedia
"
&
&
this
.
state
.
video
.
enabled
)
{
this
.
state
.
video
.
enabled
=
false
;
window
.
MediaStreamTrack
.
getSources
=
function
(
callback
)
{
callback
(
[
{
kind
:
"
audio
"
}
]
)
;
}
;
this
.
stopListening
(
this
.
publisher
)
;
this
.
publisher
.
destroy
(
)
;
this
.
startPublishing
(
)
;
}
}
startPublishing
:
function
(
event
)
{
var
outgoing
=
this
.
getDOMNode
(
)
.
querySelector
(
"
.
local
"
)
;
this
.
publisher
=
this
.
props
.
sdk
.
initPublisher
(
outgoing
this
.
getDefaultPublisherConfig
(
{
publishVideo
:
this
.
props
.
video
.
enabled
}
)
)
;
this
.
listenTo
(
this
.
publisher
"
accessDialogOpened
accessDenied
"
function
(
ev
)
{
ev
.
preventDefault
(
)
;
}
)
;
this
.
listenTo
(
this
.
publisher
"
streamCreated
"
function
(
ev
)
{
this
.
setState
(
{
audio
:
{
enabled
:
ev
.
stream
.
hasAudio
}
video
:
{
enabled
:
ev
.
stream
.
hasVideo
}
}
)
;
}
)
;
this
.
listenTo
(
this
.
publisher
"
streamDestroyed
"
function
(
)
{
this
.
setState
(
{
audio
:
{
enabled
:
false
}
video
:
{
enabled
:
false
}
}
)
;
}
)
;
this
.
props
.
model
.
publish
(
this
.
publisher
)
;
}
publishStream
:
function
(
type
enabled
)
{
if
(
type
=
=
=
"
audio
"
)
{
this
.
publisher
.
publishAudio
(
enabled
)
;
this
.
setState
(
{
audio
:
{
enabled
:
enabled
}
}
)
;
}
else
{
this
.
publisher
.
publishVideo
(
enabled
)
;
this
.
setState
(
{
video
:
{
enabled
:
enabled
}
}
)
;
}
}
stopPublishing
:
function
(
)
{
if
(
this
.
publisher
)
{
this
.
stopListening
(
this
.
publisher
)
;
this
.
props
.
model
.
session
.
unpublish
(
this
.
publisher
)
;
}
}
render
:
function
(
)
{
var
localStreamClasses
=
React
.
addons
.
classSet
(
{
local
:
true
"
local
-
stream
"
:
true
"
local
-
stream
-
audio
"
:
!
this
.
state
.
video
.
enabled
}
)
;
return
(
React
.
createElement
(
"
div
"
{
className
:
"
video
-
layout
-
wrapper
"
}
React
.
createElement
(
"
div
"
{
className
:
"
conversation
in
-
call
"
}
React
.
createElement
(
"
div
"
{
className
:
"
media
nested
"
}
React
.
createElement
(
"
div
"
{
className
:
"
video_wrapper
remote_wrapper
"
}
React
.
createElement
(
"
div
"
{
className
:
"
video_inner
remote
focus
-
stream
"
}
React
.
createElement
(
ConversationToolbar
{
audio
:
this
.
state
.
audio
dispatcher
:
this
.
props
.
dispatcher
hangup
:
this
.
hangup
mozLoop
:
this
.
props
.
mozLoop
publishStream
:
this
.
publishStream
video
:
this
.
state
.
video
}
)
)
)
React
.
createElement
(
"
div
"
{
className
:
localStreamClasses
}
)
)
)
)
)
;
}
}
)
;
var
NotificationView
=
React
.
createClass
(
{
displayName
:
"
NotificationView
"
mixins
:
[
Backbone
.
Events
]
propTypes
:
{
notification
:
React
.
PropTypes
.
object
.
isRequired
}
render
:
function
(
)
{
var
notification
=
this
.
props
.
notification
;
return
(
React
.
createElement
(
"
div
"
{
className
:
"
notificationContainer
"
}
React
.
createElement
(
"
div
"
{
className
:
"
alert
alert
-
"
+
notification
.
get
(
"
level
"
)
}
React
.
createElement
(
"
span
"
{
className
:
"
message
"
}
notification
.
get
(
"
message
"
)
)
)
React
.
createElement
(
"
div
"
{
className
:
"
detailsBar
details
-
"
+
notification
.
get
(
"
level
"
)
hidden
:
!
notification
.
get
(
"
details
"
)
}
React
.
createElement
(
"
button
"
{
className
:
"
detailsButton
btn
-
info
"
hidden
:
!
notification
.
get
(
"
detailsButtonLabel
"
)
|
|
!
notification
.
get
(
"
detailsButtonCallback
"
)
onClick
:
notification
.
get
(
"
detailsButtonCallback
"
)
}
notification
.
get
(
"
detailsButtonLabel
"
)
)
React
.
createElement
(
"
span
"
{
className
:
"
details
"
}
notification
.
get
(
"
details
"
)
)
)
)
)
;
}
}
)
;
var
NotificationListView
=
React
.
createClass
(
{
displayName
:
"
NotificationListView
"
mixins
:
[
Backbone
.
Events
sharedMixins
.
DocumentVisibilityMixin
]
propTypes
:
{
clearOnDocumentHidden
:
React
.
PropTypes
.
bool
notifications
:
React
.
PropTypes
.
object
.
isRequired
}
getDefaultProps
:
function
(
)
{
return
{
clearOnDocumentHidden
:
false
}
;
}
componentDidMount
:
function
(
)
{
this
.
listenTo
(
this
.
props
.
notifications
"
reset
add
remove
"
function
(
)
{
this
.
forceUpdate
(
)
;
}
)
;
}
componentWillUnmount
:
function
(
)
{
this
.
stopListening
(
this
.
props
.
notifications
)
;
}
onDocumentHidden
:
function
(
)
{
if
(
this
.
props
.
clearOnDocumentHidden
&
&
this
.
props
.
notifications
.
length
>
0
)
{
this
.
props
.
notifications
.
reset
(
[
]
{
silent
:
true
}
)
;
this
.
forceUpdate
(
)
;
}
}
render
:
function
(
)
{
return
(
React
.
createElement
(
"
div
"
{
className
:
"
messages
"
}
this
.
props
.
notifications
.
map
(
function
(
notification
key
)
{
return
React
.
createElement
(
NotificationView
{
key
:
key
notification
:
notification
}
)
;
}
)
)
)
;
}
}
)
;
var
Button
=
React
.
createClass
(
{
displayName
:
"
Button
"
propTypes
:
{
additionalClass
:
React
.
PropTypes
.
string
caption
:
React
.
PropTypes
.
string
.
isRequired
children
:
React
.
PropTypes
.
element
disabled
:
React
.
PropTypes
.
bool
htmlId
:
React
.
PropTypes
.
string
onClick
:
React
.
PropTypes
.
func
.
isRequired
}
getDefaultProps
:
function
(
)
{
return
{
disabled
:
false
additionalClass
:
"
"
htmlId
:
"
"
}
;
}
render
:
function
(
)
{
var
cx
=
React
.
addons
.
classSet
;
var
classObject
=
{
button
:
true
disabled
:
this
.
props
.
disabled
}
;
if
(
this
.
props
.
additionalClass
)
{
classObject
[
this
.
props
.
additionalClass
]
=
true
;
}
return
(
React
.
createElement
(
"
button
"
{
className
:
cx
(
classObject
)
disabled
:
this
.
props
.
disabled
id
:
this
.
props
.
htmlId
onClick
:
this
.
props
.
onClick
}
React
.
createElement
(
"
span
"
{
className
:
"
button
-
caption
"
}
this
.
props
.
caption
)
this
.
props
.
children
)
)
;
}
}
)
;
var
ButtonGroup
=
React
.
createClass
(
{
displayName
:
"
ButtonGroup
"
propTypes
:
{
additionalClass
:
React
.
PropTypes
.
string
children
:
React
.
PropTypes
.
oneOfType
(
[
React
.
PropTypes
.
element
React
.
PropTypes
.
arrayOf
(
React
.
PropTypes
.
element
)
]
)
}
getDefaultProps
:
function
(
)
{
return
{
additionalClass
:
"
"
}
;
}
render
:
function
(
)
{
var
cx
=
React
.
addons
.
classSet
;
var
classObject
=
{
"
button
-
group
"
:
true
}
;
if
(
this
.
props
.
additionalClass
)
{
classObject
[
this
.
props
.
additionalClass
]
=
true
;
}
return
(
React
.
createElement
(
"
div
"
{
className
:
cx
(
classObject
)
}
this
.
props
.
children
)
)
;
}
}
)
;
var
Checkbox
=
React
.
createClass
(
{
displayName
:
"
Checkbox
"
propTypes
:
{
additionalClass
:
React
.
PropTypes
.
string
checked
:
React
.
PropTypes
.
bool
disabled
:
React
.
PropTypes
.
bool
label
:
React
.
PropTypes
.
string
onChange
:
React
.
PropTypes
.
func
.
isRequired
useEllipsis
:
React
.
PropTypes
.
bool
value
:
React
.
PropTypes
.
string
}
getDefaultProps
:
function
(
)
{
return
{
additionalClass
:
"
"
checked
:
false
disabled
:
false
label
:
null
useEllipsis
:
false
value
:
"
"
}
;
}
componentWillReceiveProps
:
function
(
nextProps
)
{
if
(
this
.
props
.
checked
!
=
=
nextProps
.
checked
&
&
this
.
state
.
checked
!
=
=
nextProps
.
checked
)
{
this
.
setState
(
{
checked
:
nextProps
.
checked
}
)
;
}
}
getInitialState
:
function
(
)
{
return
{
checked
:
this
.
props
.
checked
value
:
this
.
props
.
checked
?
this
.
props
.
value
:
"
"
}
;
}
_handleClick
:
function
(
event
)
{
event
.
preventDefault
(
)
;
var
newState
=
{
checked
:
!
this
.
state
.
checked
value
:
this
.
state
.
checked
?
"
"
:
this
.
props
.
value
}
;
this
.
setState
(
newState
)
;
this
.
props
.
onChange
(
newState
)
;
}
render
:
function
(
)
{
var
cx
=
React
.
addons
.
classSet
;
var
wrapperClasses
=
{
"
checkbox
-
wrapper
"
:
true
disabled
:
this
.
props
.
disabled
}
;
var
checkClasses
=
{
checkbox
:
true
checked
:
this
.
state
.
checked
disabled
:
this
.
props
.
disabled
}
;
var
labelClasses
=
{
"
checkbox
-
label
"
:
true
"
ellipsis
"
:
this
.
props
.
useEllipsis
}
;
if
(
this
.
props
.
additionalClass
)
{
wrapperClasses
[
this
.
props
.
additionalClass
]
=
true
;
}
return
(
React
.
createElement
(
"
div
"
{
className
:
cx
(
wrapperClasses
)
disabled
:
this
.
props
.
disabled
onClick
:
this
.
_handleClick
}
React
.
createElement
(
"
div
"
{
className
:
cx
(
checkClasses
)
}
)
this
.
props
.
label
?
React
.
createElement
(
"
div
"
{
className
:
cx
(
labelClasses
)
title
:
this
.
props
.
useEllipsis
?
this
.
props
.
label
:
"
"
}
this
.
props
.
label
)
:
null
)
)
;
}
}
)
;
var
AvatarView
=
React
.
createClass
(
{
displayName
:
"
AvatarView
"
mixins
:
[
React
.
addons
.
PureRenderMixin
]
render
:
function
(
)
{
return
React
.
createElement
(
"
div
"
{
className
:
"
avatar
"
}
)
;
}
}
)
;
var
LoadingView
=
React
.
createClass
(
{
displayName
:
"
LoadingView
"
mixins
:
[
React
.
addons
.
PureRenderMixin
]
render
:
function
(
)
{
return
(
React
.
createElement
(
"
div
"
{
className
:
"
loading
-
background
"
}
React
.
createElement
(
"
div
"
{
className
:
"
loading
-
stream
"
}
)
)
)
;
}
}
)
;
var
ContextUrlView
=
React
.
createClass
(
{
displayName
:
"
ContextUrlView
"
mixins
:
[
React
.
addons
.
PureRenderMixin
]
propTypes
:
{
allowClick
:
React
.
PropTypes
.
bool
.
isRequired
description
:
React
.
PropTypes
.
string
.
isRequired
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
showContextTitle
:
React
.
PropTypes
.
bool
.
isRequired
thumbnail
:
React
.
PropTypes
.
string
url
:
React
.
PropTypes
.
string
useDesktopPaths
:
React
.
PropTypes
.
bool
.
isRequired
}
handleLinkClick
:
function
(
)
{
if
(
!
this
.
props
.
allowClick
)
{
return
;
}
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
RecordClick
(
{
linkInfo
:
"
Shared
URL
"
}
)
)
;
}
renderContextTitle
:
function
(
)
{
if
(
!
this
.
props
.
showContextTitle
)
{
return
null
;
}
return
React
.
createElement
(
"
p
"
null
mozL10n
.
get
(
"
context_inroom_label
"
)
)
;
}
render
:
function
(
)
{
var
hostname
;
try
{
hostname
=
new
URL
(
this
.
props
.
url
)
.
hostname
;
}
catch
(
ex
)
{
return
null
;
}
var
thumbnail
=
this
.
props
.
thumbnail
;
if
(
!
thumbnail
)
{
thumbnail
=
this
.
props
.
useDesktopPaths
?
"
loop
/
shared
/
img
/
icons
-
16x16
.
svg
#
globe
"
:
"
shared
/
img
/
icons
-
16x16
.
svg
#
globe
"
;
}
var
wrapperClasses
=
React
.
addons
.
classSet
(
{
"
context
-
wrapper
"
:
true
"
clicks
-
allowed
"
:
this
.
props
.
allowClick
}
)
;
return
(
React
.
createElement
(
"
div
"
{
className
:
"
context
-
content
"
}
this
.
renderContextTitle
(
)
React
.
createElement
(
"
a
"
{
className
:
wrapperClasses
href
:
this
.
props
.
allowClick
?
this
.
props
.
url
:
null
onClick
:
this
.
handleLinkClick
rel
:
"
noreferrer
"
target
:
"
_blank
"
}
React
.
createElement
(
"
img
"
{
className
:
"
context
-
preview
"
src
:
thumbnail
}
)
React
.
createElement
(
"
span
"
{
className
:
"
context
-
info
"
}
this
.
props
.
description
React
.
createElement
(
"
span
"
{
className
:
"
context
-
url
"
}
hostname
)
)
)
)
)
;
}
}
)
;
var
MediaView
=
React
.
createClass
(
{
displayName
:
"
MediaView
"
mixins
:
[
React
.
addons
.
PureRenderMixin
]
propTypes
:
{
displayAvatar
:
React
.
PropTypes
.
bool
.
isRequired
isLoading
:
React
.
PropTypes
.
bool
.
isRequired
mediaType
:
React
.
PropTypes
.
string
.
isRequired
posterUrl
:
React
.
PropTypes
.
string
srcVideoObject
:
React
.
PropTypes
.
object
}
componentDidMount
:
function
(
)
{
if
(
!
this
.
props
.
displayAvatar
)
{
this
.
attachVideo
(
this
.
props
.
srcVideoObject
)
;
}
}
componentDidUpdate
:
function
(
)
{
if
(
!
this
.
props
.
displayAvatar
)
{
this
.
attachVideo
(
this
.
props
.
srcVideoObject
)
;
}
}
attachVideo
:
function
(
srcVideoObject
)
{
if
(
!
srcVideoObject
)
{
return
;
}
var
videoElement
=
this
.
getDOMNode
(
)
;
if
(
videoElement
.
tagName
.
toLowerCase
(
)
!
=
=
"
video
"
)
{
return
;
}
var
attrName
=
"
"
;
if
(
"
srcObject
"
in
videoElement
)
{
attrName
=
"
srcObject
"
;
}
else
if
(
"
mozSrcObject
"
in
videoElement
)
{
attrName
=
"
mozSrcObject
"
;
}
else
if
(
"
src
"
in
videoElement
)
{
attrName
=
"
src
"
;
}
else
{
console
.
error
(
"
Error
attaching
stream
to
element
-
no
supported
"
+
"
attribute
found
"
)
;
return
;
}
if
(
videoElement
[
attrName
]
!
=
=
srcVideoObject
[
attrName
]
)
{
videoElement
[
attrName
]
=
srcVideoObject
[
attrName
]
;
}
videoElement
.
play
(
)
;
}
render
:
function
(
)
{
if
(
this
.
props
.
isLoading
)
{
return
React
.
createElement
(
LoadingView
null
)
;
}
if
(
this
.
props
.
displayAvatar
)
{
return
React
.
createElement
(
AvatarView
null
)
;
}
if
(
!
this
.
props
.
srcVideoObject
&
&
!
this
.
props
.
posterUrl
)
{
return
React
.
createElement
(
"
div
"
{
className
:
"
no
-
video
"
}
)
;
}
var
optionalPoster
=
{
}
;
if
(
this
.
props
.
posterUrl
)
{
optionalPoster
.
poster
=
this
.
props
.
posterUrl
;
}
return
(
React
.
createElement
(
"
video
"
React
.
__spread
(
{
}
optionalPoster
{
className
:
this
.
props
.
mediaType
+
"
-
video
"
muted
:
true
}
)
)
)
;
}
}
)
;
var
MediaLayoutView
=
React
.
createClass
(
{
displayName
:
"
MediaLayoutView
"
propTypes
:
{
children
:
React
.
PropTypes
.
node
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
displayScreenShare
:
React
.
PropTypes
.
bool
.
isRequired
isLocalLoading
:
React
.
PropTypes
.
bool
.
isRequired
isRemoteLoading
:
React
.
PropTypes
.
bool
.
isRequired
isScreenShareLoading
:
React
.
PropTypes
.
bool
.
isRequired
localPosterUrl
:
React
.
PropTypes
.
string
localSrcVideoObject
:
React
.
PropTypes
.
object
localVideoMuted
:
React
.
PropTypes
.
bool
.
isRequired
matchMedia
:
React
.
PropTypes
.
func
.
isRequired
remotePosterUrl
:
React
.
PropTypes
.
string
remoteSrcVideoObject
:
React
.
PropTypes
.
object
renderRemoteVideo
:
React
.
PropTypes
.
bool
.
isRequired
screenSharePosterUrl
:
React
.
PropTypes
.
string
screenShareVideoObject
:
React
.
PropTypes
.
object
showContextRoomName
:
React
.
PropTypes
.
bool
.
isRequired
useDesktopPaths
:
React
.
PropTypes
.
bool
.
isRequired
}
isLocalMediaAbsolutelyPositioned
:
function
(
matchMedia
)
{
if
(
!
matchMedia
)
{
matchMedia
=
this
.
props
.
matchMedia
;
}
return
matchMedia
&
&
(
(
matchMedia
(
"
screen
and
(
max
-
width
:
640px
)
"
)
.
matches
&
&
!
this
.
props
.
displayScreenShare
)
|
|
(
matchMedia
(
"
screen
and
(
max
-
width
:
300px
)
"
)
.
matches
)
)
;
}
getInitialState
:
function
(
)
{
return
{
localMediaAboslutelyPositioned
:
this
.
isLocalMediaAbsolutelyPositioned
(
)
}
;
}
componentWillReceiveProps
:
function
(
nextProps
)
{
if
(
this
.
props
.
matchMedia
!
=
=
nextProps
.
matchMedia
)
{
this
.
updateLocalMediaState
(
null
nextProps
.
matchMedia
)
;
}
}
componentDidMount
:
function
(
)
{
window
.
addEventListener
(
"
resize
"
this
.
updateLocalMediaState
)
;
}
componentWillUnmount
:
function
(
)
{
window
.
removeEventListener
(
"
resize
"
this
.
updateLocalMediaState
)
;
}
updateLocalMediaState
:
function
(
event
matchMedia
)
{
var
newState
=
this
.
isLocalMediaAbsolutelyPositioned
(
matchMedia
)
;
if
(
this
.
state
.
localMediaAboslutelyPositioned
!
=
=
newState
)
{
this
.
setState
(
{
localMediaAboslutelyPositioned
:
newState
}
)
;
}
}
renderLocalVideo
:
function
(
)
{
return
(
React
.
createElement
(
"
div
"
{
className
:
"
local
"
}
React
.
createElement
(
MediaView
{
displayAvatar
:
this
.
props
.
localVideoMuted
isLoading
:
this
.
props
.
isLocalLoading
mediaType
:
"
local
"
posterUrl
:
this
.
props
.
localPosterUrl
srcVideoObject
:
this
.
props
.
localSrcVideoObject
}
)
)
)
;
}
render
:
function
(
)
{
var
remoteStreamClasses
=
React
.
addons
.
classSet
(
{
"
remote
"
:
true
"
focus
-
stream
"
:
!
this
.
props
.
displayScreenShare
}
)
;
var
screenShareStreamClasses
=
React
.
addons
.
classSet
(
{
"
screen
"
:
true
"
focus
-
stream
"
:
this
.
props
.
displayScreenShare
}
)
;
var
mediaWrapperClasses
=
React
.
addons
.
classSet
(
{
"
media
-
wrapper
"
:
true
"
receiving
-
screen
-
share
"
:
this
.
props
.
displayScreenShare
"
showing
-
local
-
streams
"
:
this
.
props
.
localSrcVideoObject
|
|
this
.
props
.
localPosterUrl
"
showing
-
remote
-
streams
"
:
this
.
props
.
remoteSrcVideoObject
|
|
this
.
props
.
remotePosterUrl
|
|
this
.
props
.
isRemoteLoading
}
)
;
return
(
React
.
createElement
(
"
div
"
{
className
:
"
media
-
layout
"
}
React
.
createElement
(
"
div
"
{
className
:
mediaWrapperClasses
}
React
.
createElement
(
"
span
"
{
className
:
"
self
-
view
-
hidden
-
message
"
}
mozL10n
.
get
(
"
self_view_hidden_message
"
)
)
React
.
createElement
(
"
div
"
{
className
:
remoteStreamClasses
}
React
.
createElement
(
MediaView
{
displayAvatar
:
!
this
.
props
.
renderRemoteVideo
isLoading
:
this
.
props
.
isRemoteLoading
mediaType
:
"
remote
"
posterUrl
:
this
.
props
.
remotePosterUrl
srcVideoObject
:
this
.
props
.
remoteSrcVideoObject
}
)
this
.
state
.
localMediaAboslutelyPositioned
?
this
.
renderLocalVideo
(
)
:
null
this
.
props
.
children
)
React
.
createElement
(
"
div
"
{
className
:
screenShareStreamClasses
}
React
.
createElement
(
MediaView
{
displayAvatar
:
false
isLoading
:
this
.
props
.
isScreenShareLoading
mediaType
:
"
screen
-
share
"
posterUrl
:
this
.
props
.
screenSharePosterUrl
srcVideoObject
:
this
.
props
.
screenShareVideoObject
}
)
)
React
.
createElement
(
loop
.
shared
.
views
.
chat
.
TextChatView
{
dispatcher
:
this
.
props
.
dispatcher
showRoomName
:
this
.
props
.
showContextRoomName
useDesktopPaths
:
this
.
props
.
useDesktopPaths
}
)
this
.
state
.
localMediaAboslutelyPositioned
?
null
:
this
.
renderLocalVideo
(
)
)
)
)
;
}
}
)
;
return
{
AvatarView
:
AvatarView
Button
:
Button
ButtonGroup
:
ButtonGroup
Checkbox
:
Checkbox
ContextUrlView
:
ContextUrlView
ConversationView
:
ConversationView
ConversationToolbar
:
ConversationToolbar
MediaControlButton
:
MediaControlButton
MediaLayoutView
:
MediaLayoutView
MediaView
:
MediaView
LoadingView
:
LoadingView
SettingsControlButton
:
SettingsControlButton
ScreenShareControlButton
:
ScreenShareControlButton
NotificationListView
:
NotificationListView
}
;
}
)
(
_
navigator
.
mozL10n
|
|
document
.
mozL10n
)
;
