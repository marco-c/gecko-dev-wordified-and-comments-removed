var
loop
=
loop
|
|
{
}
;
loop
.
standaloneRoomViews
=
(
function
(
mozL10n
)
{
"
use
strict
"
;
var
FAILURE_DETAILS
=
loop
.
shared
.
utils
.
FAILURE_DETAILS
;
var
ROOM_INFO_FAILURES
=
loop
.
shared
.
utils
.
ROOM_INFO_FAILURES
;
var
ROOM_STATES
=
loop
.
store
.
ROOM_STATES
;
var
sharedActions
=
loop
.
shared
.
actions
;
var
sharedMixins
=
loop
.
shared
.
mixins
;
var
sharedUtils
=
loop
.
shared
.
utils
;
var
sharedViews
=
loop
.
shared
.
views
;
var
ToSView
=
React
.
createClass
(
{
displayName
:
"
ToSView
"
propTypes
:
{
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
}
_getContent
:
function
(
)
{
return
mozL10n
.
get
(
"
legal_text_and_links
"
{
"
clientShortname
"
:
mozL10n
.
get
(
"
clientShortname2
"
)
"
terms_of_use_url
"
:
React
.
renderToStaticMarkup
(
React
.
createElement
(
"
a
"
{
href
:
loop
.
config
.
legalWebsiteUrl
rel
:
"
noreferrer
"
target
:
"
_blank
"
}
mozL10n
.
get
(
"
terms_of_use_link_text
"
)
)
)
"
privacy_notice_url
"
:
React
.
renderToStaticMarkup
(
React
.
createElement
(
"
a
"
{
href
:
loop
.
config
.
privacyWebsiteUrl
rel
:
"
noreferrer
"
target
:
"
_blank
"
}
mozL10n
.
get
(
"
privacy_notice_link_text
"
)
)
)
}
)
;
}
recordClick
:
function
(
event
)
{
if
(
event
.
target
&
&
event
.
target
.
href
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
RecordClick
(
{
linkInfo
:
event
.
target
.
href
}
)
)
;
}
}
render
:
function
(
)
{
return
(
React
.
createElement
(
"
p
"
{
className
:
"
terms
-
service
"
dangerouslySetInnerHTML
:
{
__html
:
this
.
_getContent
(
)
}
onClick
:
this
.
recordClick
}
)
)
;
}
}
)
;
var
StandaloneRoomFailureView
=
React
.
createClass
(
{
displayName
:
"
StandaloneRoomFailureView
"
propTypes
:
{
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
failureReason
:
React
.
PropTypes
.
string
}
handleRetryButton
:
function
(
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
RetryAfterRoomFailure
(
)
)
;
}
getFailureString
:
function
(
)
{
switch
(
this
.
props
.
failureReason
)
{
case
FAILURE_DETAILS
.
MEDIA_DENIED
:
case
FAILURE_DETAILS
.
NO_MEDIA
:
return
mozL10n
.
get
(
"
rooms_media_denied_message
"
)
;
case
FAILURE_DETAILS
.
EXPIRED_OR_INVALID
:
return
mozL10n
.
get
(
"
rooms_unavailable_notification_message
"
)
;
case
FAILURE_DETAILS
.
TOS_FAILURE
:
return
mozL10n
.
get
(
"
tos_failure_message
"
{
clientShortname
:
mozL10n
.
get
(
"
clientShortname2
"
)
}
)
;
default
:
return
mozL10n
.
get
(
"
status_error
"
)
;
}
}
renderRetryButton
:
function
(
)
{
if
(
this
.
props
.
failureReason
=
=
=
FAILURE_DETAILS
.
EXPIRED_OR_INVALID
|
|
this
.
props
.
failureReason
=
=
=
FAILURE_DETAILS
.
TOS_FAILURE
)
{
return
null
;
}
return
(
React
.
createElement
(
"
button
"
{
className
:
"
btn
btn
-
join
btn
-
info
"
onClick
:
this
.
handleRetryButton
}
mozL10n
.
get
(
"
retry_call_button
"
)
)
)
;
}
render
:
function
(
)
{
return
(
React
.
createElement
(
"
div
"
{
className
:
"
room
-
inner
-
info
-
area
"
}
React
.
createElement
(
"
p
"
{
className
:
"
failed
-
room
-
message
"
}
this
.
getFailureString
(
)
)
this
.
renderRetryButton
(
)
)
)
;
}
}
)
;
var
StandaloneRoomInfoArea
=
React
.
createClass
(
{
displayName
:
"
StandaloneRoomInfoArea
"
statics
:
{
RENDER_WAITING_DELAY
:
2000
}
propTypes
:
{
activeRoomStore
:
React
.
PropTypes
.
instanceOf
(
loop
.
store
.
ActiveRoomStore
)
.
isRequired
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
failureReason
:
React
.
PropTypes
.
string
isFirefox
:
React
.
PropTypes
.
bool
.
isRequired
joinRoom
:
React
.
PropTypes
.
func
.
isRequired
roomState
:
React
.
PropTypes
.
string
.
isRequired
roomUsed
:
React
.
PropTypes
.
bool
.
isRequired
}
getInitialState
:
function
(
)
{
return
{
waitToRenderWaiting
:
true
}
;
}
componentDidMount
:
function
(
)
{
window
.
addEventListener
(
"
message
"
this
.
recordTileClick
)
;
}
_allowRenderWaiting
:
function
(
)
{
delete
this
.
_waitTimer
;
switch
(
this
.
props
.
roomState
)
{
case
ROOM_STATES
.
JOINING
:
case
ROOM_STATES
.
JOINED
:
case
ROOM_STATES
.
SESSION_CONNECTED
:
this
.
setState
(
{
waitToRenderWaiting
:
false
}
)
;
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
TileShown
(
)
)
;
break
;
}
}
componentDidUpdate
:
function
(
)
{
if
(
(
this
.
props
.
roomState
=
=
=
ROOM_STATES
.
JOINING
|
|
this
.
props
.
roomState
=
=
=
ROOM_STATES
.
SESSION_CONNECTED
)
&
&
this
.
state
.
waitToRenderWaiting
&
&
this
.
_waitTimer
=
=
=
undefined
)
{
this
.
_waitTimer
=
setTimeout
(
this
.
_allowRenderWaiting
this
.
constructor
.
RENDER_WAITING_DELAY
)
;
}
}
componentWillReceiveProps
:
function
(
nextProps
)
{
switch
(
nextProps
.
roomState
)
{
case
ROOM_STATES
.
ENDED
:
case
ROOM_STATES
.
READY
:
if
(
!
this
.
state
.
waitToRenderWaiting
)
{
this
.
setState
(
{
waitToRenderWaiting
:
true
}
)
;
}
if
(
this
.
_waitTimer
!
=
=
undefined
)
{
clearTimeout
(
this
.
_waitTimer
)
;
delete
this
.
_waitTimer
;
}
break
;
}
}
componentWillUnmount
:
function
(
)
{
window
.
removeEventListener
(
"
message
"
this
.
recordTileClick
)
;
}
recordTileClick
:
function
(
event
)
{
if
(
event
.
data
=
=
=
"
tile
-
click
"
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
RecordClick
(
{
linkInfo
:
"
Tiles
iframe
click
"
}
)
)
;
}
}
recordTilesSupport
:
function
(
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
RecordClick
(
{
linkInfo
:
"
Tiles
support
link
click
"
}
)
)
;
}
_renderCallToActionLink
:
function
(
)
{
if
(
this
.
props
.
isFirefox
)
{
return
(
React
.
createElement
(
"
a
"
{
className
:
"
btn
btn
-
info
"
href
:
loop
.
config
.
learnMoreUrl
}
mozL10n
.
get
(
"
rooms_room_full_call_to_action_label
"
{
clientShortname
:
mozL10n
.
get
(
"
clientShortname2
"
)
}
)
)
)
;
}
return
(
React
.
createElement
(
"
a
"
{
className
:
"
btn
btn
-
info
"
href
:
loop
.
config
.
downloadFirefoxUrl
}
mozL10n
.
get
(
"
rooms_room_full_call_to_action_nonFx_label
"
{
brandShortname
:
mozL10n
.
get
(
"
brandShortname
"
)
}
)
)
)
;
}
render
:
function
(
)
{
switch
(
this
.
props
.
roomState
)
{
case
ROOM_STATES
.
ENDED
:
case
ROOM_STATES
.
READY
:
{
return
(
React
.
createElement
(
"
div
"
{
className
:
"
room
-
inner
-
info
-
area
"
}
React
.
createElement
(
"
button
"
{
className
:
"
btn
btn
-
join
btn
-
info
"
onClick
:
this
.
props
.
joinRoom
}
mozL10n
.
get
(
"
rooms_room_join_label
"
)
)
)
)
;
}
case
ROOM_STATES
.
MEDIA_WAIT
:
{
var
msg
=
mozL10n
.
get
(
"
call_progress_getting_media_description
"
{
clientShortname
:
mozL10n
.
get
(
"
clientShortname2
"
)
}
)
;
var
utils
=
loop
.
shared
.
utils
;
var
isChrome
=
utils
.
isChrome
(
navigator
.
userAgent
)
;
var
isFirefox
=
utils
.
isFirefox
(
navigator
.
userAgent
)
;
var
isOpera
=
utils
.
isOpera
(
navigator
.
userAgent
)
;
var
promptMediaMessageClasses
=
React
.
addons
.
classSet
(
{
"
prompt
-
media
-
message
"
:
true
"
chrome
"
:
isChrome
"
firefox
"
:
isFirefox
"
opera
"
:
isOpera
"
other
"
:
!
isChrome
&
&
!
isFirefox
&
&
!
isOpera
}
)
;
return
(
React
.
createElement
(
"
div
"
{
className
:
"
room
-
inner
-
info
-
area
"
}
React
.
createElement
(
"
p
"
{
className
:
promptMediaMessageClasses
}
msg
)
)
)
;
}
case
ROOM_STATES
.
JOINING
:
case
ROOM_STATES
.
JOINED
:
case
ROOM_STATES
.
SESSION_CONNECTED
:
{
if
(
this
.
state
.
waitToRenderWaiting
)
{
return
null
;
}
return
(
React
.
createElement
(
"
div
"
{
className
:
"
room
-
inner
-
info
-
area
"
}
React
.
createElement
(
"
p
"
{
className
:
"
empty
-
room
-
message
"
}
mozL10n
.
get
(
"
rooms_only_occupant_label2
"
)
)
React
.
createElement
(
"
p
"
{
className
:
"
room
-
waiting
-
area
"
}
mozL10n
.
get
(
"
rooms_read_while_wait_offer
"
)
React
.
createElement
(
"
a
"
{
href
:
loop
.
config
.
tilesSupportUrl
onClick
:
this
.
recordTilesSupport
rel
:
"
noreferrer
"
target
:
"
_blank
"
}
React
.
createElement
(
"
i
"
{
className
:
"
room
-
waiting
-
help
"
}
)
)
)
React
.
createElement
(
"
iframe
"
{
className
:
"
room
-
waiting
-
tile
"
src
:
loop
.
config
.
tilesIframeUrl
}
)
)
)
;
}
case
ROOM_STATES
.
FULL
:
{
return
(
React
.
createElement
(
"
div
"
{
className
:
"
room
-
inner
-
info
-
area
"
}
React
.
createElement
(
"
p
"
{
className
:
"
full
-
room
-
message
"
}
mozL10n
.
get
(
"
rooms_room_full_label
"
)
)
React
.
createElement
(
"
p
"
null
this
.
_renderCallToActionLink
(
)
)
)
)
;
}
case
ROOM_STATES
.
FAILED
:
{
return
(
React
.
createElement
(
StandaloneRoomFailureView
{
dispatcher
:
this
.
props
.
dispatcher
failureReason
:
this
.
props
.
failureReason
}
)
)
;
}
case
ROOM_STATES
.
INIT
:
case
ROOM_STATES
.
GATHER
:
default
:
{
return
null
;
}
}
}
}
)
;
var
StandaloneRoomHeader
=
React
.
createClass
(
{
displayName
:
"
StandaloneRoomHeader
"
propTypes
:
{
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
}
recordClick
:
function
(
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
RecordClick
(
{
linkInfo
:
"
Support
link
click
"
}
)
)
;
}
render
:
function
(
)
{
return
(
React
.
createElement
(
"
header
"
null
React
.
createElement
(
"
h1
"
null
mozL10n
.
get
(
"
clientShortname2
"
)
)
React
.
createElement
(
"
a
"
{
href
:
loop
.
config
.
generalSupportUrl
onClick
:
this
.
recordClick
rel
:
"
noreferrer
"
target
:
"
_blank
"
}
React
.
createElement
(
"
i
"
{
className
:
"
icon
icon
-
help
"
}
)
)
)
)
;
}
}
)
;
var
StandaloneRoomFooter
=
React
.
createClass
(
{
displayName
:
"
StandaloneRoomFooter
"
propTypes
:
{
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
}
render
:
function
(
)
{
return
(
React
.
createElement
(
"
footer
"
{
className
:
"
rooms
-
footer
"
}
React
.
createElement
(
"
div
"
{
className
:
"
footer
-
logo
"
}
)
React
.
createElement
(
ToSView
{
dispatcher
:
this
.
props
.
dispatcher
}
)
)
)
;
}
}
)
;
var
StandaloneRoomView
=
React
.
createClass
(
{
displayName
:
"
StandaloneRoomView
"
mixins
:
[
Backbone
.
Events
sharedMixins
.
MediaSetupMixin
sharedMixins
.
RoomsAudioMixin
sharedMixins
.
DocumentTitleMixin
]
propTypes
:
{
activeRoomStore
:
React
.
PropTypes
.
instanceOf
(
loop
.
store
.
ActiveRoomStore
)
.
isRequired
dispatcher
:
React
.
PropTypes
.
instanceOf
(
loop
.
Dispatcher
)
.
isRequired
isFirefox
:
React
.
PropTypes
.
bool
.
isRequired
localPosterUrl
:
React
.
PropTypes
.
string
remotePosterUrl
:
React
.
PropTypes
.
string
roomState
:
React
.
PropTypes
.
string
screenSharePosterUrl
:
React
.
PropTypes
.
string
}
getInitialState
:
function
(
)
{
var
storeState
=
this
.
props
.
activeRoomStore
.
getStoreState
(
)
;
return
_
.
extend
(
{
}
storeState
{
roomState
:
this
.
props
.
roomState
|
|
storeState
.
roomState
}
)
;
}
componentWillMount
:
function
(
)
{
this
.
props
.
activeRoomStore
.
on
(
"
change
"
function
(
)
{
this
.
setState
(
this
.
props
.
activeRoomStore
.
getStoreState
(
)
)
;
}
this
)
;
}
componentWillUnmount
:
function
(
)
{
this
.
props
.
activeRoomStore
.
off
(
"
change
"
null
this
)
;
}
componentDidMount
:
function
(
)
{
document
.
body
.
classList
.
add
(
"
is
-
standalone
-
room
"
)
;
}
componentWillUpdate
:
function
(
nextProps
nextState
)
{
if
(
this
.
state
.
roomState
!
=
=
ROOM_STATES
.
READY
&
&
nextState
.
roomState
=
=
=
ROOM_STATES
.
READY
)
{
this
.
setTitle
(
mozL10n
.
get
(
"
standalone_title_with_room_name
"
{
roomName
:
nextState
.
roomName
|
|
this
.
state
.
roomName
clientShortname
:
mozL10n
.
get
(
"
clientShortname2
"
)
}
)
)
;
}
if
(
this
.
state
.
roomState
!
=
=
ROOM_STATES
.
MEDIA_WAIT
&
&
nextState
.
roomState
=
=
=
ROOM_STATES
.
MEDIA_WAIT
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
SetupStreamElements
(
{
publisherConfig
:
this
.
getDefaultPublisherConfig
(
{
publishVideo
:
true
}
)
}
)
)
;
}
if
(
!
this
.
state
.
roomInfoFailure
&
&
nextState
.
roomInfoFailure
)
{
if
(
nextState
.
roomInfoFailure
=
=
=
ROOM_INFO_FAILURES
.
WEB_CRYPTO_UNSUPPORTED
)
{
console
.
error
(
mozL10n
.
get
(
"
room_information_failure_unsupported_browser
"
)
)
;
}
else
{
console
.
error
(
mozL10n
.
get
(
"
room_information_failure_not_available
"
)
)
;
}
}
}
joinRoom
:
function
(
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
JoinRoom
(
)
)
;
}
leaveRoom
:
function
(
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
LeaveRoom
(
)
)
;
}
publishStream
:
function
(
type
enabled
)
{
this
.
props
.
dispatcher
.
dispatch
(
new
sharedActions
.
SetMute
(
{
type
:
type
enabled
:
enabled
}
)
)
;
}
_roomIsActive
:
function
(
)
{
return
this
.
state
.
roomState
=
=
=
ROOM_STATES
.
JOINED
|
|
this
.
state
.
roomState
=
=
=
ROOM_STATES
.
SESSION_CONNECTED
|
|
this
.
state
.
roomState
=
=
=
ROOM_STATES
.
HAS_PARTICIPANTS
;
}
shouldRenderRemoteVideo
:
function
(
)
{
switch
(
this
.
state
.
roomState
)
{
case
ROOM_STATES
.
HAS_PARTICIPANTS
:
if
(
this
.
state
.
remoteVideoEnabled
)
{
return
true
;
}
if
(
this
.
state
.
mediaConnected
)
{
return
false
;
}
return
true
;
case
ROOM_STATES
.
READY
:
case
ROOM_STATES
.
GATHER
:
case
ROOM_STATES
.
INIT
:
case
ROOM_STATES
.
JOINING
:
case
ROOM_STATES
.
SESSION_CONNECTED
:
case
ROOM_STATES
.
JOINED
:
case
ROOM_STATES
.
MEDIA_WAIT
:
return
true
;
case
ROOM_STATES
.
FAILED
:
case
ROOM_STATES
.
CLOSING
:
case
ROOM_STATES
.
FULL
:
case
ROOM_STATES
.
ENDED
:
return
true
;
default
:
console
.
warn
(
"
StandaloneRoomView
.
shouldRenderRemoteVideo
:
"
+
"
unexpected
roomState
:
"
this
.
state
.
roomState
)
;
return
true
;
}
}
_isLocalLoading
:
function
(
)
{
return
this
.
state
.
roomState
=
=
=
ROOM_STATES
.
MEDIA_WAIT
&
&
!
this
.
state
.
localSrcMediaElement
;
}
_isRemoteLoading
:
function
(
)
{
return
!
!
(
this
.
state
.
roomState
=
=
=
ROOM_STATES
.
HAS_PARTICIPANTS
&
&
!
this
.
state
.
remoteSrcMediaElement
&
&
!
this
.
state
.
mediaConnected
)
;
}
_isScreenShareLoading
:
function
(
)
{
return
this
.
state
.
receivingScreenShare
&
&
!
this
.
state
.
screenShareMediaElement
&
&
!
this
.
props
.
screenSharePosterUrl
;
}
render
:
function
(
)
{
var
displayScreenShare
=
!
!
(
this
.
state
.
receivingScreenShare
|
|
this
.
props
.
screenSharePosterUrl
)
;
return
(
React
.
createElement
(
"
div
"
{
className
:
"
room
-
conversation
-
wrapper
standalone
-
room
-
wrapper
"
}
React
.
createElement
(
"
div
"
{
className
:
"
beta
-
logo
"
}
)
React
.
createElement
(
StandaloneRoomHeader
{
dispatcher
:
this
.
props
.
dispatcher
}
)
React
.
createElement
(
sharedViews
.
MediaLayoutView
{
dispatcher
:
this
.
props
.
dispatcher
displayScreenShare
:
displayScreenShare
isLocalLoading
:
this
.
_isLocalLoading
(
)
isRemoteLoading
:
this
.
_isRemoteLoading
(
)
isScreenShareLoading
:
this
.
_isScreenShareLoading
(
)
localPosterUrl
:
this
.
props
.
localPosterUrl
localSrcMediaElement
:
this
.
state
.
localSrcMediaElement
localVideoMuted
:
this
.
state
.
videoMuted
matchMedia
:
this
.
state
.
matchMedia
|
|
window
.
matchMedia
.
bind
(
window
)
remotePosterUrl
:
this
.
props
.
remotePosterUrl
remoteSrcMediaElement
:
this
.
state
.
remoteSrcMediaElement
renderRemoteVideo
:
this
.
shouldRenderRemoteVideo
(
)
screenShareMediaElement
:
this
.
state
.
screenShareMediaElement
screenSharePosterUrl
:
this
.
props
.
screenSharePosterUrl
showContextRoomName
:
true
useDesktopPaths
:
false
}
React
.
createElement
(
StandaloneRoomInfoArea
{
activeRoomStore
:
this
.
props
.
activeRoomStore
dispatcher
:
this
.
props
.
dispatcher
failureReason
:
this
.
state
.
failureReason
isFirefox
:
this
.
props
.
isFirefox
joinRoom
:
this
.
joinRoom
roomState
:
this
.
state
.
roomState
roomUsed
:
this
.
state
.
used
}
)
React
.
createElement
(
sharedViews
.
ConversationToolbar
{
audio
:
{
enabled
:
!
this
.
state
.
audioMuted
visible
:
this
.
_roomIsActive
(
)
}
dispatcher
:
this
.
props
.
dispatcher
enableHangup
:
this
.
_roomIsActive
(
)
hangup
:
this
.
leaveRoom
hangupButtonLabel
:
mozL10n
.
get
(
"
rooms_leave_button_label
"
)
publishStream
:
this
.
publishStream
show
:
true
video
:
{
enabled
:
!
this
.
state
.
videoMuted
visible
:
this
.
_roomIsActive
(
)
}
}
)
)
React
.
createElement
(
StandaloneRoomFooter
{
dispatcher
:
this
.
props
.
dispatcher
}
)
)
)
;
}
}
)
;
return
{
StandaloneRoomFailureView
:
StandaloneRoomFailureView
StandaloneRoomFooter
:
StandaloneRoomFooter
StandaloneRoomHeader
:
StandaloneRoomHeader
StandaloneRoomInfoArea
:
StandaloneRoomInfoArea
StandaloneRoomView
:
StandaloneRoomView
ToSView
:
ToSView
}
;
}
)
(
navigator
.
mozL10n
)
;
