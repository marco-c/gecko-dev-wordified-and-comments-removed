const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
SiteSpecificBrowser
:
"
resource
:
/
/
/
modules
/
SiteSpecificBrowserService
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
WindowsSupport
:
"
resource
:
/
/
/
modules
/
ssb
/
WindowsSupport
.
jsm
"
}
)
;
let
gSSBBrowser
=
null
;
var
gSSB
=
null
;
function
init
(
)
{
gSSB
=
SiteSpecificBrowser
.
get
(
window
.
arguments
[
0
]
)
;
let
uri
=
gSSB
.
startURI
;
if
(
window
.
arguments
.
length
>
1
)
{
uri
=
Services
.
io
.
newURI
(
window
.
arguments
[
1
]
)
;
}
window
.
browserDOMWindow
=
new
BrowserDOMWindow
(
)
;
gSSBBrowser
=
document
.
createXULElement
(
"
browser
"
)
;
gSSBBrowser
.
setAttribute
(
"
id
"
"
browser
"
)
;
gSSBBrowser
.
setAttribute
(
"
type
"
"
content
"
)
;
gSSBBrowser
.
setAttribute
(
"
remote
"
"
true
"
)
;
gSSBBrowser
.
setAttribute
(
"
nodefaultsrc
"
"
true
"
)
;
document
.
getElementById
(
"
browser
-
container
"
)
.
appendChild
(
gSSBBrowser
)
;
let
actor
=
gSSBBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
SiteSpecificBrowser
"
)
;
actor
.
sendAsyncMessage
(
"
SetSSB
"
gSSB
.
id
)
;
gSSBBrowser
.
addProgressListener
(
new
ProgressListener
(
)
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
gSSBBrowser
.
src
=
uri
.
spec
;
}
class
ProgressListener
{
constructor
(
)
{
this
.
isInitial
=
true
;
}
async
onStateChange
(
webProgress
request
state
status
)
{
if
(
!
webProgress
.
isTopLevel
)
{
return
;
}
let
final
=
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
+
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
if
(
(
state
&
final
)
!
=
final
)
{
return
;
}
let
{
isInitial
}
=
this
;
this
.
isInitial
=
false
;
if
(
isInitial
&
&
gSSB
.
needsUpdate
)
{
await
gSSB
.
updateFromBrowser
(
gSSBBrowser
)
;
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
WindowsSupport
.
applyOSIntegration
(
gSSB
window
)
;
}
}
let
event
=
new
CustomEvent
(
"
SSBLoad
"
)
;
gSSBBrowser
.
dispatchEvent
(
event
)
;
}
}
ProgressListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
;
class
BrowserDOMWindow
{
createContentWindow
(
uri
opener
where
flags
triggeringPrincipal
csp
)
{
console
.
error
(
"
createContentWindow
should
never
be
called
from
a
remote
browser
"
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
openURI
(
uri
opener
where
flags
triggeringPrincipal
csp
)
{
console
.
error
(
"
openURI
should
never
be
called
from
a
remote
browser
"
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
getContentWindowOrOpenURIInFrame
(
uri
params
where
flags
nextRemoteTabId
name
shouldOpen
)
{
if
(
gSSB
.
canLoad
(
uri
)
)
{
return
gSSBBrowser
;
}
let
win
=
BrowserWindowTracker
.
getTopWindow
(
{
private
:
params
.
isPrivate
allowPopups
:
false
}
)
;
if
(
win
)
{
win
.
focus
(
)
;
return
win
.
browserDOMWindow
.
openURIInFrame
(
shouldOpen
?
uri
:
null
params
where
flags
nextRemoteTabId
name
)
;
}
return
null
;
}
createContentWindowInFrame
(
uri
params
where
flags
nextRemoteTabId
name
)
{
return
this
.
getContentWindowOrOpenURIInFrame
(
uri
params
where
flags
nextRemoteTabId
name
false
)
;
}
openURIInFrame
(
uri
params
where
flags
nextRemoteTabId
name
)
{
return
this
.
getContentWindowOrOpenURIInFrame
(
uri
params
where
flags
nextRemoteTabId
name
true
)
;
}
isTabContentWindow
(
window
)
{
return
gSSBBrowser
.
contentWindow
=
=
window
;
}
canClose
(
)
{
return
BrowserUtils
.
canCloseWindow
(
window
)
;
}
get
tabCount
(
)
{
return
1
;
}
}
BrowserDOMWindow
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIBrowserDOMWindow
]
)
;
window
.
addEventListener
(
"
DOMContentLoaded
"
init
true
)
;
