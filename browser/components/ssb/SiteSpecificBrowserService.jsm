var
EXPORTED_SYMBOLS
=
[
"
SiteSpecificBrowserService
"
"
SiteSpecificBrowserBase
"
"
SiteSpecificBrowser
"
"
SSBCommandLineHandler
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ManifestObtainer
:
"
resource
:
/
/
gre
/
modules
/
ManifestObtainer
.
jsm
"
ManifestProcessor
:
"
resource
:
/
/
gre
/
modules
/
ManifestProcessor
.
jsm
"
KeyValueService
:
"
resource
:
/
/
gre
/
modules
/
kvstore
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
ImageTools
:
"
resource
:
/
/
/
modules
/
ssb
/
ImageTools
.
jsm
"
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
}
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
ChromeUtils
.
defineModuleGetter
(
this
"
WindowsSupport
"
"
resource
:
/
/
/
modules
/
ssb
/
WindowsSupport
.
jsm
"
)
;
}
const
DATA_VERSION
=
1
;
const
SSB_STORE_PREFIX
=
"
ssb
:
"
;
const
SSB_STORE_LAST
=
"
ssb
;
"
;
function
uuid
(
)
{
return
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
}
const
sharedDataKey
=
id
=
>
SiteSpecificBrowserBase
:
{
id
}
;
const
storeKey
=
id
=
>
SSB_STORE_PREFIX
+
id
;
function
buildIconList
(
icons
)
{
let
iconList
=
[
]
;
for
(
let
icon
of
icons
)
{
for
(
let
sizeSpec
of
icon
.
sizes
)
{
let
size
=
sizeSpec
=
=
"
any
"
?
Number
.
MAX_SAFE_INTEGER
:
parseInt
(
sizeSpec
)
;
iconList
.
push
(
{
icon
size
}
)
;
}
}
iconList
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
size
<
b
.
size
)
{
return
-
1
;
}
if
(
a
.
size
>
b
.
size
)
{
return
1
;
}
return
0
;
}
)
;
return
iconList
;
}
const
IS_MAIN_PROCESS
=
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
;
function
scopeIncludes
(
scope
uri
)
{
if
(
scope
.
prePath
!
=
uri
.
prePath
)
{
return
false
;
}
return
uri
.
filePath
.
startsWith
(
scope
.
filePath
)
;
}
function
manifestForURI
(
uri
)
{
try
{
let
manifestURI
=
Services
.
io
.
newURI
(
"
/
manifest
.
json
"
null
uri
)
;
return
ManifestProcessor
.
process
(
{
jsonText
:
"
{
}
"
manifestURL
:
manifestURI
.
spec
docURL
:
uri
.
spec
}
)
;
}
catch
(
e
)
{
console
.
error
(
Failed
to
generate
a
SSB
manifest
for
{
uri
.
spec
}
.
e
)
;
throw
e
;
}
}
async
function
getIconResource
(
iconData
)
{
let
imageData
=
await
ImageTools
.
loadImage
(
Services
.
io
.
newURI
(
iconData
.
iconURL
)
)
;
if
(
imageData
.
container
.
type
=
=
Ci
.
imgIContainer
.
TYPE_VECTOR
)
{
return
{
src
:
iconData
.
iconURL
purpose
:
[
"
any
"
]
type
:
imageData
.
type
sizes
:
[
"
any
"
]
}
;
}
return
{
src
:
iconData
.
iconURL
purpose
:
[
"
any
"
]
type
:
imageData
.
type
sizes
:
[
{
imageData
.
container
.
width
}
x
{
imageData
.
container
.
height
}
]
}
;
}
async
function
buildManifestForBrowser
(
browser
)
{
let
manifest
=
null
;
try
{
manifest
=
await
ManifestObtainer
.
browserObtainManifest
(
browser
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
if
(
!
manifest
|
|
!
scopeIncludes
(
Services
.
io
.
newURI
(
manifest
.
scope
)
browser
.
currentURI
)
)
{
manifest
=
manifestForURI
(
browser
.
currentURI
)
;
}
manifest
.
icons
=
(
await
Promise
.
all
(
manifest
.
icons
.
map
(
async
icon
=
>
{
if
(
icon
.
src
.
startsWith
(
"
data
:
"
)
)
{
return
icon
;
}
let
actor
=
browser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
SiteSpecificBrowser
"
)
;
try
{
icon
.
src
=
await
actor
.
sendQuery
(
"
LoadIcon
"
icon
.
src
)
;
}
catch
(
e
)
{
return
null
;
}
return
icon
;
}
)
)
)
.
filter
(
icon
=
>
icon
)
;
if
(
!
manifest
.
icons
.
length
)
{
let
linkHandler
=
browser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
LinkHandler
"
)
;
for
(
let
icon
of
[
linkHandler
.
icon
linkHandler
.
richIcon
]
)
{
if
(
!
icon
)
{
continue
;
}
try
{
manifest
.
icons
.
push
(
await
getIconResource
(
icon
)
)
;
}
catch
(
e
)
{
console
.
warn
(
Failed
to
load
icon
resource
{
icon
.
originalURL
}
e
)
;
}
}
}
return
manifest
;
}
const
SSBMap
=
new
Map
(
)
;
class
SiteSpecificBrowserBase
{
constructor
(
scope
)
{
this
.
_scope
=
scope
;
}
static
get
(
id
)
{
if
(
IS_MAIN_PROCESS
)
{
return
SiteSpecificBrowser
.
get
(
id
)
;
}
let
key
=
sharedDataKey
(
id
)
;
if
(
!
Services
.
cpmm
.
sharedData
.
has
(
key
)
)
{
return
null
;
}
let
scope
=
Services
.
io
.
newURI
(
Services
.
cpmm
.
sharedData
.
get
(
key
)
)
;
return
new
SiteSpecificBrowserBase
(
scope
)
;
}
canLoad
(
uri
)
{
if
(
uri
.
spec
=
=
"
about
:
blank
"
)
{
return
true
;
}
return
scopeIncludes
(
this
.
_scope
uri
)
;
}
}
class
SiteSpecificBrowser
extends
SiteSpecificBrowserBase
{
constructor
(
id
manifest
config
=
{
}
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
SiteSpecificBrowser
instances
are
only
available
in
the
main
process
.
"
)
;
}
super
(
Services
.
io
.
newURI
(
manifest
.
scope
)
)
;
this
.
_id
=
id
;
this
.
_manifest
=
manifest
;
this
.
_config
=
Object
.
assign
(
{
needsUpdate
:
true
persisted
:
false
}
config
)
;
SSBMap
.
set
(
id
this
)
;
this
.
_updateSharedData
(
)
;
}
static
async
load
(
id
data
=
null
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
SiteSpecificBrowser
instances
are
only
available
in
the
main
process
.
"
)
;
}
if
(
SSBMap
.
has
(
id
)
)
{
return
SSBMap
.
get
(
id
)
;
}
if
(
!
data
)
{
let
kvstore
=
await
SiteSpecificBrowserService
.
getKVStore
(
)
;
data
=
await
kvstore
.
get
(
storeKey
(
id
)
null
)
;
}
if
(
!
data
)
{
return
null
;
}
try
{
let
parsed
=
JSON
.
parse
(
data
)
;
parsed
.
config
.
persisted
=
true
;
return
new
SiteSpecificBrowser
(
id
parsed
.
manifest
parsed
.
config
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
return
null
;
}
static
get
(
id
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
SiteSpecificBrowser
instances
are
only
available
in
the
main
process
.
"
)
;
}
return
SSBMap
.
get
(
id
)
;
}
static
async
createFromManifest
(
manifest
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
throw
new
Error
(
"
Site
specific
browsing
is
disabled
.
"
)
;
}
if
(
!
manifest
.
scope
.
startsWith
(
"
https
:
"
)
)
{
throw
new
Error
(
"
Site
specific
browsers
can
only
be
opened
for
secure
sites
.
"
)
;
}
return
new
SiteSpecificBrowser
(
uuid
(
)
manifest
{
needsUpdate
:
false
}
)
;
}
static
async
createFromBrowser
(
browser
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
throw
new
Error
(
"
Site
specific
browsing
is
disabled
.
"
)
;
}
if
(
!
browser
.
currentURI
.
schemeIs
(
"
https
"
)
)
{
throw
new
Error
(
"
Site
specific
browsers
can
only
be
opened
for
secure
sites
.
"
)
;
}
let
manifest
=
await
buildManifestForBrowser
(
browser
)
;
let
ssb
=
await
SiteSpecificBrowser
.
createFromManifest
(
manifest
)
;
if
(
!
manifest
.
name
)
{
ssb
.
name
=
browser
.
contentTitle
;
}
return
ssb
;
}
static
createFromURI
(
uri
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
throw
new
Error
(
"
Site
specific
browsing
is
disabled
.
"
)
;
}
if
(
!
uri
.
schemeIs
(
"
https
"
)
)
{
throw
new
Error
(
"
Site
specific
browsers
can
only
be
opened
for
secure
sites
.
"
)
;
}
return
new
SiteSpecificBrowser
(
uuid
(
)
manifestForURI
(
uri
)
)
;
}
_updateSharedData
(
)
{
Services
.
ppmm
.
sharedData
.
set
(
sharedDataKey
(
this
.
id
)
this
.
_scope
.
spec
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
}
async
_maybeSave
(
)
{
if
(
this
.
_config
.
persisted
)
{
let
data
=
{
manifest
:
this
.
_manifest
config
:
this
.
_config
}
;
let
kvstore
=
await
SiteSpecificBrowserService
.
getKVStore
(
)
;
await
kvstore
.
put
(
storeKey
(
this
.
id
)
JSON
.
stringify
(
data
)
)
;
}
}
async
install
(
)
{
if
(
this
.
_config
.
persisted
)
{
return
;
}
this
.
_config
.
persisted
=
true
;
await
this
.
_maybeSave
(
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
await
WindowsSupport
.
install
(
this
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
site
-
specific
-
browser
-
install
"
this
.
id
)
;
}
async
uninstall
(
)
{
if
(
!
this
.
_config
.
persisted
)
{
return
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
await
WindowsSupport
.
uninstall
(
this
)
;
}
this
.
_config
.
persisted
=
false
;
let
kvstore
=
await
SiteSpecificBrowserService
.
getKVStore
(
)
;
await
kvstore
.
delete
(
storeKey
(
this
.
id
)
)
;
Services
.
obs
.
notifyObservers
(
null
"
site
-
specific
-
browser
-
uninstall
"
this
.
id
)
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
name
(
)
{
if
(
this
.
_config
.
name
)
{
return
this
.
_config
.
name
;
}
if
(
this
.
_manifest
.
name
)
{
return
this
.
_manifest
.
name
;
}
return
this
.
startURI
.
host
;
}
set
name
(
val
)
{
this
.
_config
.
name
=
val
;
this
.
_maybeSave
(
)
;
}
get
startURI
(
)
{
return
Services
.
io
.
newURI
(
this
.
_manifest
.
start_url
)
;
}
get
needsUpdate
(
)
{
return
this
.
_config
.
needsUpdate
;
}
getIcon
(
size
)
{
if
(
!
this
.
_iconSizes
)
{
this
.
_iconSizes
=
buildIconList
(
this
.
_manifest
.
icons
)
;
}
if
(
!
this
.
_iconSizes
.
length
)
{
return
null
;
}
let
i
=
0
;
while
(
i
<
this
.
_iconSizes
.
length
&
&
this
.
_iconSizes
[
i
]
.
size
<
size
)
{
i
+
+
;
}
return
i
<
this
.
_iconSizes
.
length
?
this
.
_iconSizes
[
i
]
.
icon
:
this
.
_iconSizes
[
this
.
_iconSizes
.
length
-
1
]
.
icon
;
}
async
getScaledIcon
(
size
)
{
let
icon
=
this
.
getIcon
(
size
)
;
if
(
!
icon
)
{
return
null
;
}
let
{
container
}
=
await
ImageTools
.
loadImage
(
Services
.
io
.
newURI
(
icon
.
src
)
)
;
return
ImageTools
.
scaleImage
(
container
size
size
)
;
}
async
updateFromManifest
(
manifest
)
{
this
.
_manifest
=
manifest
;
this
.
_iconSizes
=
null
;
this
.
_scope
=
Services
.
io
.
newURI
(
this
.
_manifest
.
scope
)
;
this
.
_config
.
needsUpdate
=
false
;
this
.
_updateSharedData
(
)
;
await
this
.
_maybeSave
(
)
;
}
async
updateFromBrowser
(
browser
)
{
let
manifest
=
await
buildManifestForBrowser
(
browser
)
;
await
this
.
updateFromManifest
(
manifest
)
;
}
launch
(
uri
=
null
)
{
let
sa
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
idstr
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
idstr
.
data
=
this
.
id
;
sa
.
appendElement
(
idstr
)
;
if
(
uri
)
{
let
uristr
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
uristr
.
data
=
uri
.
spec
;
sa
.
appendElement
(
uristr
)
;
}
let
win
=
Services
.
ww
.
openWindow
(
null
"
chrome
:
/
/
browser
/
content
/
ssb
/
ssb
.
html
"
"
_blank
"
"
chrome
dialog
=
no
all
"
sa
)
;
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
WindowsSupport
.
applyOSIntegration
(
this
win
)
;
}
}
}
async
function
loadKVStore
(
)
{
let
dir
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
ssb
"
)
;
async
function
createStore
(
)
{
await
OS
.
File
.
makeDir
(
dir
)
;
let
kvstore
=
await
KeyValueService
.
getOrCreate
(
dir
"
ssb
"
)
;
await
kvstore
.
put
(
"
_meta
"
JSON
.
stringify
(
{
version
:
DATA_VERSION
}
)
)
;
return
kvstore
;
}
try
{
let
info
=
await
OS
.
File
.
stat
(
dir
)
;
if
(
!
info
.
isDir
)
{
await
OS
.
File
.
remove
(
dir
{
ignoreAbsent
:
true
}
)
;
return
createStore
(
)
;
}
}
catch
(
e
)
{
if
(
e
.
becauseNoSuchFile
)
{
return
createStore
(
)
;
}
throw
e
;
}
try
{
let
kvstore
=
await
KeyValueService
.
getOrCreate
(
dir
"
ssb
"
)
;
let
meta
=
await
kvstore
.
get
(
"
_meta
"
null
)
;
if
(
meta
)
{
let
data
=
JSON
.
parse
(
meta
)
;
if
(
data
.
version
=
=
DATA_VERSION
)
{
return
kvstore
;
}
console
.
error
(
SSB
store
is
an
unexpected
version
{
data
.
version
}
)
;
}
else
{
console
.
error
(
"
SSB
store
was
missing
meta
data
.
"
)
;
}
await
kvstore
.
clear
(
)
;
await
kvstore
.
put
(
"
_meta
"
JSON
.
stringify
(
{
version
:
DATA_VERSION
}
)
)
;
return
kvstore
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
await
OS
.
File
.
removeDir
(
dir
)
;
return
createStore
(
)
;
}
}
const
SiteSpecificBrowserService
=
{
kvstore
:
null
getKVStore
(
)
{
if
(
!
this
.
kvstore
)
{
this
.
kvstore
=
loadKVStore
(
)
;
}
return
this
.
kvstore
;
}
get
useOSIntegration
(
)
{
if
(
Services
.
appinfo
.
OS
!
=
"
WINNT
"
)
{
return
false
;
}
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
ssb
.
osintegration
"
true
)
;
}
async
list
(
)
{
let
kvstore
=
await
this
.
getKVStore
(
)
;
let
list
=
await
kvstore
.
enumerate
(
SSB_STORE_PREFIX
SSB_STORE_LAST
)
;
return
Promise
.
all
(
Array
.
from
(
list
)
.
map
(
(
{
key
:
id
value
:
data
}
)
=
>
SiteSpecificBrowser
.
load
(
id
.
substring
(
SSB_STORE_PREFIX
.
length
)
data
)
)
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SiteSpecificBrowserService
"
isEnabled
"
"
browser
.
ssb
.
enabled
"
false
)
;
async
function
startSSB
(
id
)
{
Services
.
startup
.
enterLastWindowClosingSurvivalArea
(
)
;
try
{
let
ssb
=
await
SiteSpecificBrowser
.
load
(
id
)
;
if
(
ssb
)
{
ssb
.
launch
(
)
;
}
else
{
dump
(
No
SSB
installed
as
ID
{
id
}
\
n
)
;
}
}
finally
{
Services
.
startup
.
exitLastWindowClosingSurvivalArea
(
)
;
}
}
class
SSBCommandLineHandler
{
handle
(
cmdLine
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
return
;
}
let
site
=
cmdLine
.
handleFlagWithParam
(
"
ssb
"
false
)
;
if
(
site
)
{
cmdLine
.
preventDefault
=
true
;
try
{
let
fixupInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
site
Services
.
uriFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
)
;
let
uri
=
fixupInfo
.
preferredURI
;
if
(
!
uri
)
{
dump
(
Unable
to
parse
'
{
site
}
'
as
a
URI
.
\
n
)
;
return
;
}
if
(
fixupInfo
.
fixupChangedProtocol
&
&
uri
.
schemeIs
(
"
http
"
)
)
{
uri
=
uri
.
mutate
(
)
.
setScheme
(
"
https
"
)
.
finalize
(
)
;
}
let
ssb
=
SiteSpecificBrowser
.
createFromURI
(
uri
)
;
ssb
.
launch
(
)
;
}
catch
(
e
)
{
dump
(
Unable
to
parse
'
{
site
}
'
as
a
URI
:
{
e
}
\
n
)
;
}
return
;
}
let
id
=
cmdLine
.
handleFlagWithParam
(
"
start
-
ssb
"
false
)
;
if
(
id
)
{
cmdLine
.
preventDefault
=
true
;
startSSB
(
id
)
;
}
}
get
helpInfo
(
)
{
return
"
-
-
ssb
<
uri
>
Open
a
site
specific
browser
for
<
uri
>
.
\
n
"
;
}
}
SSBCommandLineHandler
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsICommandLineHandler
"
]
)
;
