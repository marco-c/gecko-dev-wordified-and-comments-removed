var
EXPORTED_SYMBOLS
=
[
"
SiteSpecificBrowserService
"
"
SiteSpecificBrowserBase
"
"
SiteSpecificBrowser
"
"
SSBCommandLineHandler
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
function
uuid
(
)
{
return
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
}
const
sharedDataKey
=
id
=
>
SiteSpecificBrowserBase
:
{
id
}
;
const
IS_MAIN_PROCESS
=
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
;
const
SSBMap
=
new
Map
(
)
;
class
SiteSpecificBrowserBase
{
constructor
(
uri
)
{
this
.
_uri
=
uri
;
}
static
get
(
id
)
{
if
(
IS_MAIN_PROCESS
)
{
return
SiteSpecificBrowser
.
get
(
id
)
;
}
let
key
=
sharedDataKey
(
id
)
;
if
(
!
Services
.
cpmm
.
sharedData
.
has
(
key
)
)
{
return
null
;
}
let
uri
=
Services
.
io
.
newURI
(
Services
.
cpmm
.
sharedData
.
get
(
key
)
)
;
return
new
SiteSpecificBrowserBase
(
uri
)
;
}
canLoad
(
uri
)
{
if
(
uri
.
spec
=
=
"
about
:
blank
"
)
{
return
true
;
}
return
uri
.
prePath
=
=
this
.
_uri
.
prePath
;
}
}
class
SiteSpecificBrowser
extends
SiteSpecificBrowserBase
{
constructor
(
id
uri
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
SiteSpecificBrowser
instances
are
only
available
in
the
main
process
.
"
)
;
}
super
(
uri
)
;
this
.
_id
=
id
;
SSBMap
.
set
(
id
this
)
;
Services
.
ppmm
.
sharedData
.
set
(
sharedDataKey
(
id
)
this
.
_uri
.
spec
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
}
static
get
(
id
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
SiteSpecificBrowser
instances
are
only
available
in
the
main
process
.
"
)
;
}
return
SSBMap
.
get
(
id
)
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
startURI
(
)
{
return
this
.
_uri
;
}
launch
(
)
{
let
sa
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
idstr
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
idstr
.
data
=
this
.
id
;
sa
.
appendElement
(
idstr
)
;
Services
.
ww
.
openWindow
(
null
"
chrome
:
/
/
browser
/
content
/
ssb
/
ssb
.
html
"
"
_blank
"
"
chrome
dialog
=
no
all
"
sa
)
;
}
}
const
SiteSpecificBrowserService
=
{
launchFromURI
(
uri
)
{
if
(
!
this
.
isEnabled
)
{
throw
new
Error
(
"
Site
specific
browsing
is
disabled
.
"
)
;
}
if
(
!
uri
.
schemeIs
(
"
https
"
)
)
{
throw
new
Error
(
"
Site
specific
browsers
can
only
be
opened
for
secure
sites
.
"
)
;
}
let
ssb
=
new
SiteSpecificBrowser
(
uuid
(
)
uri
)
;
ssb
.
launch
(
)
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SiteSpecificBrowserService
"
isEnabled
"
"
browser
.
ssb
.
enabled
"
false
)
;
class
SSBCommandLineHandler
{
handle
(
cmdLine
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
return
;
}
let
site
=
cmdLine
.
handleFlagWithParam
(
"
ssb
"
false
)
;
if
(
site
)
{
cmdLine
.
preventDefault
=
true
;
try
{
let
fixupInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
site
Services
.
uriFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
)
;
let
uri
=
fixupInfo
.
preferredURI
;
if
(
!
uri
)
{
dump
(
Unable
to
parse
'
{
site
}
'
as
a
URI
.
\
n
)
;
return
;
}
if
(
fixupInfo
.
fixupChangedProtocol
&
&
uri
.
schemeIs
(
"
http
"
)
)
{
uri
=
uri
.
mutate
(
)
.
setScheme
(
"
https
"
)
.
finalize
(
)
;
}
SiteSpecificBrowserService
.
launchFromURI
(
uri
)
;
}
catch
(
e
)
{
dump
(
Unable
to
parse
'
{
site
}
'
as
a
URI
:
{
e
}
\
n
)
;
}
}
}
get
helpInfo
(
)
{
return
"
-
-
ssb
<
uri
>
Open
a
site
specific
browser
for
<
uri
>
.
\
n
"
;
}
}
SSBCommandLineHandler
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsICommandLineHandler
]
)
;
