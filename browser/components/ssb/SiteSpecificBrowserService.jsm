var
EXPORTED_SYMBOLS
=
[
"
SiteSpecificBrowserService
"
"
SiteSpecificBrowserBase
"
"
SiteSpecificBrowser
"
"
SSBCommandLineHandler
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ManifestObtainer
:
"
resource
:
/
/
gre
/
modules
/
ManifestObtainer
.
jsm
"
ManifestProcessor
:
"
resource
:
/
/
gre
/
modules
/
ManifestProcessor
.
jsm
"
}
)
;
function
uuid
(
)
{
return
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
}
const
sharedDataKey
=
id
=
>
SiteSpecificBrowserBase
:
{
id
}
;
const
IS_MAIN_PROCESS
=
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
;
function
scopeIncludes
(
scope
uri
)
{
if
(
scope
.
prePath
!
=
uri
.
prePath
)
{
return
false
;
}
return
uri
.
filePath
.
startsWith
(
scope
.
filePath
)
;
}
function
manifestForURI
(
uri
)
{
try
{
let
manifestURI
=
Services
.
io
.
newURI
(
"
/
manifest
.
json
"
null
uri
)
;
return
ManifestProcessor
.
process
(
{
jsonText
:
"
{
}
"
manifestURL
:
manifestURI
.
spec
docURL
:
uri
.
spec
}
)
;
}
catch
(
e
)
{
console
.
error
(
Failed
to
generate
a
SSB
manifest
for
{
uri
.
spec
}
.
e
)
;
throw
e
;
}
}
async
function
buildManifestForBrowser
(
browser
)
{
let
manifest
=
null
;
try
{
manifest
=
await
ManifestObtainer
.
browserObtainManifest
(
browser
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
if
(
!
manifest
|
|
!
scopeIncludes
(
Services
.
io
.
newURI
(
manifest
.
scope
)
browser
.
currentURI
)
)
{
manifest
=
manifestForURI
(
browser
.
currentURI
)
;
}
return
manifest
;
}
const
SSBMap
=
new
Map
(
)
;
class
SiteSpecificBrowserBase
{
constructor
(
scope
)
{
this
.
_scope
=
scope
;
}
static
get
(
id
)
{
if
(
IS_MAIN_PROCESS
)
{
return
SiteSpecificBrowser
.
get
(
id
)
;
}
let
key
=
sharedDataKey
(
id
)
;
if
(
!
Services
.
cpmm
.
sharedData
.
has
(
key
)
)
{
return
null
;
}
let
scope
=
Services
.
io
.
newURI
(
Services
.
cpmm
.
sharedData
.
get
(
key
)
)
;
return
new
SiteSpecificBrowserBase
(
scope
)
;
}
canLoad
(
uri
)
{
if
(
uri
.
spec
=
=
"
about
:
blank
"
)
{
return
true
;
}
return
scopeIncludes
(
this
.
_scope
uri
)
;
}
}
class
SiteSpecificBrowser
extends
SiteSpecificBrowserBase
{
constructor
(
id
manifest
config
=
{
}
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
SiteSpecificBrowser
instances
are
only
available
in
the
main
process
.
"
)
;
}
super
(
Services
.
io
.
newURI
(
manifest
.
scope
)
)
;
this
.
_id
=
id
;
this
.
_manifest
=
manifest
;
this
.
_config
=
Object
.
assign
(
{
needsUpdate
:
true
}
config
)
;
SSBMap
.
set
(
id
this
)
;
this
.
_updateSharedData
(
)
;
}
static
get
(
id
)
{
if
(
!
IS_MAIN_PROCESS
)
{
throw
new
Error
(
"
SiteSpecificBrowser
instances
are
only
available
in
the
main
process
.
"
)
;
}
return
SSBMap
.
get
(
id
)
;
}
static
async
createFromManifest
(
manifest
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
throw
new
Error
(
"
Site
specific
browsing
is
disabled
.
"
)
;
}
if
(
!
manifest
.
scope
.
startsWith
(
"
https
:
"
)
)
{
throw
new
Error
(
"
Site
specific
browsers
can
only
be
opened
for
secure
sites
.
"
)
;
}
return
new
SiteSpecificBrowser
(
uuid
(
)
manifest
{
needsUpdate
:
false
}
)
;
}
static
async
createFromBrowser
(
browser
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
throw
new
Error
(
"
Site
specific
browsing
is
disabled
.
"
)
;
}
if
(
!
browser
.
currentURI
.
schemeIs
(
"
https
"
)
)
{
throw
new
Error
(
"
Site
specific
browsers
can
only
be
opened
for
secure
sites
.
"
)
;
}
return
SiteSpecificBrowser
.
createFromManifest
(
await
buildManifestForBrowser
(
browser
)
)
;
}
static
createFromURI
(
uri
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
throw
new
Error
(
"
Site
specific
browsing
is
disabled
.
"
)
;
}
if
(
!
uri
.
schemeIs
(
"
https
"
)
)
{
throw
new
Error
(
"
Site
specific
browsers
can
only
be
opened
for
secure
sites
.
"
)
;
}
return
new
SiteSpecificBrowser
(
uuid
(
)
manifestForURI
(
uri
)
)
;
}
_updateSharedData
(
)
{
Services
.
ppmm
.
sharedData
.
set
(
sharedDataKey
(
this
.
id
)
this
.
_scope
.
spec
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
startURI
(
)
{
return
Services
.
io
.
newURI
(
this
.
_manifest
.
start_url
)
;
}
get
needsUpdate
(
)
{
return
this
.
_config
.
needsUpdate
;
}
async
updateFromManifest
(
manifest
)
{
this
.
_manifest
=
manifest
;
this
.
_scope
=
Services
.
io
.
newURI
(
this
.
_manifest
.
scope
)
;
this
.
_config
.
needsUpdate
=
false
;
this
.
_updateSharedData
(
)
;
}
async
updateFromBrowser
(
browser
)
{
let
manifest
=
await
buildManifestForBrowser
(
browser
)
;
await
this
.
updateFromManifest
(
manifest
)
;
}
launch
(
uri
=
null
)
{
let
sa
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
idstr
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
idstr
.
data
=
this
.
id
;
sa
.
appendElement
(
idstr
)
;
if
(
uri
)
{
let
uristr
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
uristr
.
data
=
uri
.
spec
;
sa
.
appendElement
(
uristr
)
;
}
Services
.
ww
.
openWindow
(
null
"
chrome
:
/
/
browser
/
content
/
ssb
/
ssb
.
html
"
"
_blank
"
"
chrome
dialog
=
no
all
"
sa
)
;
}
}
const
SiteSpecificBrowserService
=
{
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
SiteSpecificBrowserService
"
isEnabled
"
"
browser
.
ssb
.
enabled
"
false
)
;
class
SSBCommandLineHandler
{
handle
(
cmdLine
)
{
if
(
!
SiteSpecificBrowserService
.
isEnabled
)
{
return
;
}
let
site
=
cmdLine
.
handleFlagWithParam
(
"
ssb
"
false
)
;
if
(
site
)
{
cmdLine
.
preventDefault
=
true
;
try
{
let
fixupInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
site
Services
.
uriFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
)
;
let
uri
=
fixupInfo
.
preferredURI
;
if
(
!
uri
)
{
dump
(
Unable
to
parse
'
{
site
}
'
as
a
URI
.
\
n
)
;
return
;
}
if
(
fixupInfo
.
fixupChangedProtocol
&
&
uri
.
schemeIs
(
"
http
"
)
)
{
uri
=
uri
.
mutate
(
)
.
setScheme
(
"
https
"
)
.
finalize
(
)
;
}
let
ssb
=
SiteSpecificBrowser
.
createFromURI
(
uri
)
;
ssb
.
launch
(
)
;
}
catch
(
e
)
{
dump
(
Unable
to
parse
'
{
site
}
'
as
a
URI
:
{
e
}
\
n
)
;
}
}
}
get
helpInfo
(
)
{
return
"
-
-
ssb
<
uri
>
Open
a
site
specific
browser
for
<
uri
>
.
\
n
"
;
}
}
SSBCommandLineHandler
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsICommandLineHandler
]
)
;
