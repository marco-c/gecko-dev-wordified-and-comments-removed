"
use
strict
"
;
const
moveOverThresholdPercent
=
Math
.
min
(
1
.
0
Math
.
max
(
0
.
5
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
dragDrop
.
moveOverThresholdPercent
"
)
/
100
)
)
;
const
overlapPixels
=
size
=
>
Math
.
ceil
(
moveOverThresholdPercent
*
size
)
+
1
;
async
function
move
(
source
target
clientX
clientY
)
{
await
customDragAndDrop
(
source
target
null
waitForTabMove
(
source
)
{
clientX
clientY
}
)
;
}
async
function
moveHorizontalLTR
(
itemToDrag
itemToDrop
shouldDropAfter
)
{
const
sourceRect
=
bounds
(
itemToDrag
)
;
const
targetRect
=
bounds
(
itemToDrop
)
;
const
verticalMidline
=
targetRect
.
top
+
0
.
5
*
targetRect
.
height
;
const
overlap
=
overlapPixels
(
targetRect
.
width
)
;
if
(
shouldDropAfter
)
{
const
targetPoint
=
targetRect
.
left
+
overlap
;
const
dragTo
=
targetPoint
-
Math
.
floor
(
sourceRect
.
width
/
2
)
;
await
move
(
itemToDrag
itemToDrop
dragTo
verticalMidline
)
;
}
else
{
const
targetPoint
=
targetRect
.
right
-
overlap
;
const
dragTo
=
targetPoint
+
Math
.
floor
(
sourceRect
.
width
/
2
)
;
await
move
(
itemToDrag
itemToDrop
dragTo
verticalMidline
)
;
}
}
async
function
moveHorizontalRTL
(
itemToDrag
itemToDrop
shouldDropAfter
)
{
const
sourceRect
=
bounds
(
itemToDrag
)
;
const
targetRect
=
bounds
(
itemToDrop
)
;
const
verticalMidline
=
targetRect
.
top
+
0
.
5
*
targetRect
.
height
;
const
overlap
=
overlapPixels
(
targetRect
.
width
)
;
if
(
shouldDropAfter
)
{
const
targetPoint
=
targetRect
.
right
-
overlap
;
const
dragTo
=
targetPoint
+
Math
.
floor
(
sourceRect
.
width
/
2
)
;
await
move
(
itemToDrag
itemToDrop
dragTo
verticalMidline
)
;
}
else
{
const
targetPoint
=
targetRect
.
left
+
overlap
;
const
dragTo
=
targetPoint
-
Math
.
floor
(
sourceRect
.
width
/
2
)
;
await
move
(
itemToDrag
itemToDrop
dragTo
verticalMidline
)
;
}
}
async
function
moveVertical
(
itemToDrag
itemToDrop
shouldDropAfter
)
{
const
sourceRect
=
bounds
(
itemToDrag
)
;
const
targetRect
=
bounds
(
itemToDrop
)
;
const
horizontalMidline
=
Math
.
round
(
targetRect
.
left
+
0
.
5
*
targetRect
.
width
)
;
const
overlap
=
overlapPixels
(
targetRect
.
height
)
;
if
(
shouldDropAfter
)
{
const
targetPoint
=
targetRect
.
top
+
overlap
;
const
dragTo
=
targetPoint
-
Math
.
floor
(
sourceRect
.
height
/
2
)
;
await
move
(
itemToDrag
itemToDrop
horizontalMidline
dragTo
)
;
}
else
{
const
targetPoint
=
targetRect
.
bottom
-
overlap
;
const
dragTo
=
targetPoint
+
Math
.
floor
(
sourceRect
.
height
/
2
)
;
await
move
(
itemToDrag
itemToDrop
horizontalMidline
dragTo
)
;
}
}
function
moveAfter
(
itemToDrag
itemToDropAfter
)
{
if
(
gBrowser
.
tabContainer
.
verticalMode
)
{
return
moveVertical
(
itemToDrag
itemToDropAfter
true
)
;
}
if
(
RTL_UI
)
{
return
moveHorizontalRTL
(
itemToDrag
itemToDropAfter
true
)
;
}
return
moveHorizontalLTR
(
itemToDrag
itemToDropAfter
true
)
;
}
async
function
moveBefore
(
itemToDrag
itemToDropBefore
)
{
if
(
gBrowser
.
tabContainer
.
verticalMode
)
{
return
moveVertical
(
itemToDrag
itemToDropBefore
false
)
;
}
if
(
RTL_UI
)
{
return
moveHorizontalRTL
(
itemToDrag
itemToDropBefore
false
)
;
}
return
moveHorizontalLTR
(
itemToDrag
itemToDropBefore
false
)
;
}
function
validateTab
(
tab
)
{
Assert
.
ok
(
!
tab
.
pinned
"
tab
should
not
have
been
pinned
"
)
;
Assert
.
ok
(
!
tab
.
group
"
tab
should
not
have
been
put
into
a
tab
group
"
)
;
}
async
function
test_unpinned_tab_strip_movements
(
)
{
const
[
tab1
tab2
tab3
tab4
tab5
]
=
await
Promise
.
all
(
Array
.
from
(
{
length
:
5
}
)
.
map
(
(
_
index
)
=
>
addTab
(
data
:
text
/
plain
tab
{
index
+
1
}
)
)
)
;
const
startingTab
=
gBrowser
.
tabs
[
0
]
;
gBrowser
.
pinTab
(
startingTab
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab1
tab2
tab3
tab4
tab5
]
"
confirm
tabs
'
starting
order
"
)
;
let
{
outerWidth
:
originalOuterWidth
outerHeight
:
originalOuterHeight
}
=
window
;
try
{
await
ensureNotOverflowing
(
)
;
info
(
"
validating
that
dragging
and
dropping
into
the
same
position
will
result
in
the
tab
not
moving
"
)
;
for
(
const
tab
of
[
tab1
tab2
tab3
tab4
tab5
]
)
{
EventUtils
.
synthesizeDrop
(
tab
tab
null
"
move
"
window
window
{
}
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab1
tab2
tab3
tab4
tab5
]
"
confirm
that
the
tabs
'
order
did
not
change
"
)
;
validateTab
(
tab
)
;
}
info
(
"
validate
that
it
'
s
possible
to
move
tabs
forward
into
each
position
"
)
;
await
moveAfter
(
tab1
tab2
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab2
tab1
tab3
tab4
tab5
]
"
confirm
that
tab1
moved
after
tab2
"
)
;
validateTab
(
tab1
)
;
await
moveAfter
(
tab1
tab3
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab2
tab3
tab1
tab4
tab5
]
"
confirm
that
tab1
moved
after
tab3
"
)
;
validateTab
(
tab1
)
;
await
moveAfter
(
tab1
tab4
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab2
tab3
tab4
tab1
tab5
]
"
confirm
that
tab1
moved
after
tab4
"
)
;
validateTab
(
tab1
)
;
await
moveAfter
(
tab1
tab5
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab2
tab3
tab4
tab5
tab1
]
"
confirm
that
tab1
moved
after
tab5
"
)
;
validateTab
(
tab1
)
;
info
(
"
Validate
that
it
'
s
possible
to
move
tabs
backward
into
each
position
"
)
;
await
moveBefore
(
tab1
tab5
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab2
tab3
tab4
tab1
tab5
]
"
confirm
that
tab1
moved
before
tab5
"
)
;
validateTab
(
tab1
)
;
await
moveBefore
(
tab1
tab4
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab2
tab3
tab1
tab4
tab5
]
"
confirm
that
tab1
moved
before
tab4
"
)
;
validateTab
(
tab1
)
;
await
moveBefore
(
tab1
tab3
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab2
tab1
tab3
tab4
tab5
]
"
confirm
that
tab1
moved
before
tab3
"
)
;
validateTab
(
tab1
)
;
await
moveBefore
(
tab1
tab2
)
;
Assert
.
deepEqual
(
gBrowser
.
tabs
[
startingTab
tab1
tab2
tab3
tab4
tab5
]
"
confirm
that
tab1
moved
before
tab2
"
)
;
validateTab
(
tab1
)
;
}
finally
{
if
(
window
.
outerWidth
!
=
originalOuterWidth
|
|
window
.
outerHeight
!
=
originalOuterHeight
)
{
window
.
resizeTo
(
originalOuterWidth
originalOuterHeight
)
;
}
gBrowser
.
unpinTab
(
startingTab
)
;
BrowserTestUtils
.
removeTab
(
tab1
)
;
BrowserTestUtils
.
removeTab
(
tab2
)
;
BrowserTestUtils
.
removeTab
(
tab3
)
;
BrowserTestUtils
.
removeTab
(
tab4
)
;
BrowserTestUtils
.
removeTab
(
tab5
)
;
}
}
async
function
ensureNotOverflowing
(
)
{
if
(
!
gBrowser
.
tabContainer
.
arrowScrollbox
.
overflowing
)
{
return
;
}
const
isVertical
=
gBrowser
.
tabContainer
.
verticalMode
;
const
maximumTabSize
=
isVertical
?
bounds
(
gBrowser
.
tabs
[
0
]
)
.
height
:
225
;
const
requiredTabSpace
=
maximumTabSize
*
gBrowser
.
tabs
.
length
;
const
scrollboxSize
=
gBrowser
.
tabContainer
.
arrowScrollbox
.
scrollSize
;
const
increaseBy
=
requiredTabSpace
-
scrollboxSize
;
const
tabStripUnderflows
=
BrowserTestUtils
.
waitForEvent
(
gBrowser
.
tabContainer
.
arrowScrollbox
"
underflow
"
)
;
if
(
isVertical
)
{
info
(
increasing
window
height
by
{
increaseBy
}
to
fit
tabs
without
overflowing
)
;
window
.
resizeBy
(
0
increaseBy
)
;
}
else
{
info
(
increasing
window
width
by
{
increaseBy
}
to
fit
tabs
without
overflowing
)
;
window
.
resizeBy
(
increaseBy
0
)
;
}
await
tabStripUnderflows
;
}
add_task
(
function
test_move_unpinned_horizontal_ltr
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
sidebar
.
verticalTabs
"
false
)
)
{
Assert
.
ok
(
true
"
skipping
horizontal
tab
strip
tests
when
browser
is
using
vertical
tab
strip
"
)
;
return
Promise
.
resolve
(
)
;
}
return
runAndCleanup
(
"
ltr
"
test_unpinned_tab_strip_movements
)
;
}
)
;
add_task
(
function
test_move_unpinned_horizontal_rtl
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
sidebar
.
verticalTabs
"
false
)
)
{
Assert
.
ok
(
true
"
skipping
horizontal
tab
strip
tests
when
browser
is
using
vertical
tab
strip
"
)
;
return
Promise
.
resolve
(
)
;
}
return
runAndCleanup
(
"
rtl
"
test_unpinned_tab_strip_movements
)
;
}
)
;
