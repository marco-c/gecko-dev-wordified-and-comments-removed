async
function
openTabMenuFor
(
tab
)
{
let
tabMenu
=
tab
.
ownerDocument
.
getElementById
(
"
tabContextMenu
"
)
;
let
tabMenuShown
=
BrowserTestUtils
.
waitForPopupEvent
(
tabMenu
"
shown
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
tab
{
type
:
"
contextmenu
"
}
tab
.
ownerGlobal
)
;
await
tabMenuShown
;
return
tabMenu
;
}
async
function
addBrowserTabs
(
numberOfTabs
)
{
let
tabs
=
[
]
;
for
(
let
i
=
0
;
i
<
numberOfTabs
;
i
+
+
)
{
tabs
.
push
(
await
addTab
(
http
:
/
/
mochi
.
test
:
8888
/
#
{
i
}
)
)
;
}
return
tabs
;
}
add_setup
(
async
function
(
)
{
await
promiseTabLoadEvent
(
gBrowser
.
selectedTab
"
http
:
/
/
mochi
.
test
:
8888
/
#
originalTab
"
)
;
let
originalTab
=
gBrowser
.
selectedTab
;
FirefoxViewHandler
.
openTab
(
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
originalTab
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
tabs
.
unloadTabInContextMenu
"
true
]
]
}
)
;
}
)
;
function
checkEventCommon
(
e
)
{
Assert
.
equal
(
e
.
category
"
browser
.
engagement
"
"
correct
category
"
)
;
Assert
.
equal
(
e
.
name
"
tab_explicit_unload
"
"
correct
name
"
)
;
let
memoryBefore
=
parseInt
(
e
.
extra
.
memory_before
10
)
;
let
memoryAfter
=
parseInt
(
e
.
extra
.
memory_after
10
)
;
Assert
.
less
(
memoryAfter
-
memoryBefore
100000
Memory
should
go
down
after
unload
(
before
:
{
memoryBefore
}
after
{
memoryAfter
}
)
)
;
Assert
.
greaterOrEqual
(
parseInt
(
e
.
extra
.
time_to_unload_in_ms
10
)
0
"
time_to_unload
should
be
>
=
0
"
)
;
Assert
.
less
(
parseInt
(
e
.
extra
.
time_to_unload_in_ms
10
)
10000
"
time_to_unload
should
be
within
reason
"
)
;
}
function
getWaitForUnloadedPromise
(
tab
)
{
return
BrowserTestUtils
.
waitForEvent
(
tab
"
TabBrowserDiscarded
"
)
;
}
async
function
waitForTelemetryEvent
(
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
events
=
Glean
.
browserEngagement
.
tabExplicitUnload
.
testGetValue
(
)
;
if
(
!
events
)
{
return
false
;
}
return
!
!
events
.
length
;
}
)
;
}
add_task
(
async
function
test_unload_selected_and_one_other_tab
(
)
{
let
[
tab1
tab2
tab3
]
=
await
addBrowserTabs
(
3
)
;
let
menuItemUnload
=
document
.
getElementById
(
"
context_unloadTab
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab1
)
;
await
triggerClickOn
(
tab2
{
ctrlKey
:
true
}
)
;
Services
.
fog
.
testResetFOG
(
)
;
updateTabContextMenu
(
tab1
)
;
let
tab1UnloadedPromise
=
getWaitForUnloadedPromise
(
tab1
)
;
let
tab2UnloadedPromise
=
getWaitForUnloadedPromise
(
tab2
)
;
{
let
menu
=
await
openTabMenuFor
(
tab1
)
;
let
menuHiddenPromise
=
BrowserTestUtils
.
waitForPopupEvent
(
menu
"
hidden
"
)
;
menu
.
activateItem
(
menuItemUnload
)
;
await
menuHiddenPromise
;
}
await
Promise
.
all
(
[
tab1UnloadedPromise
tab2UnloadedPromise
]
)
;
await
waitForTelemetryEvent
(
)
;
let
unloadTelemetry
=
Glean
.
browserEngagement
.
tabExplicitUnload
.
testGetValue
(
)
;
Assert
.
equal
(
unloadTelemetry
.
length
1
"
should
get
exactly
one
telemetry
event
"
)
;
let
e
=
unloadTelemetry
[
0
]
;
checkEventCommon
(
e
)
;
Assert
.
equal
(
e
.
extra
.
unload_selected_tab
"
true
"
"
did
unload
selected
tab
"
)
;
Assert
.
equal
(
e
.
extra
.
all_tabs_unloaded
"
false
"
"
did
not
unload
everything
"
)
;
Assert
.
equal
(
e
.
extra
.
tabs_unloaded
"
2
"
"
correct
number
of
tabs
unloaded
"
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
BrowserTestUtils
.
removeTab
(
tab3
)
;
await
BrowserTestUtils
.
removeTab
(
tab2
)
;
await
BrowserTestUtils
.
removeTab
(
tab1
)
;
}
)
;
add_task
(
async
function
test_unload_one_unselected_tab
(
)
{
let
[
tab1
tab2
tab3
]
=
await
addBrowserTabs
(
3
)
;
let
menuItemUnload
=
document
.
getElementById
(
"
context_unloadTab
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab1
)
;
updateTabContextMenu
(
tab2
)
;
Services
.
fog
.
testResetFOG
(
)
;
let
tab2UnloadedPromise
=
getWaitForUnloadedPromise
(
tab2
)
;
{
let
menu
=
await
openTabMenuFor
(
tab2
)
;
let
menuHiddenPromise
=
BrowserTestUtils
.
waitForPopupEvent
(
menu
"
hidden
"
)
;
menu
.
activateItem
(
menuItemUnload
)
;
await
menuHiddenPromise
;
}
await
tab2UnloadedPromise
;
await
waitForTelemetryEvent
(
)
;
let
unloadTelemetry
=
Glean
.
browserEngagement
.
tabExplicitUnload
.
testGetValue
(
)
;
Assert
.
equal
(
unloadTelemetry
.
length
1
"
should
get
exactly
one
telemetry
event
"
)
;
let
e
=
unloadTelemetry
[
0
]
;
checkEventCommon
(
e
)
;
Assert
.
equal
(
e
.
extra
.
unload_selected_tab
"
false
"
"
did
not
unload
selected
tab
"
)
;
Assert
.
equal
(
e
.
extra
.
all_tabs_unloaded
"
false
"
"
did
not
unload
everything
"
)
;
Assert
.
equal
(
e
.
extra
.
tabs_unloaded
"
1
"
"
correct
number
of
tabs
unloaded
"
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
BrowserTestUtils
.
removeTab
(
tab3
)
;
await
BrowserTestUtils
.
removeTab
(
tab2
)
;
await
BrowserTestUtils
.
removeTab
(
tab1
)
;
}
)
;
add_task
(
async
function
test_unload_selected_tab
(
)
{
let
[
tab1
tab2
tab3
]
=
await
addBrowserTabs
(
3
)
;
let
menuItemUnload
=
document
.
getElementById
(
"
context_unloadTab
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab1
)
;
Services
.
fog
.
testResetFOG
(
)
;
let
tab1UnloadedPromise
=
getWaitForUnloadedPromise
(
tab1
)
;
{
let
menu
=
await
openTabMenuFor
(
tab1
)
;
let
menuHiddenPromise
=
BrowserTestUtils
.
waitForPopupEvent
(
menu
"
hidden
"
)
;
menu
.
activateItem
(
menuItemUnload
)
;
await
menuHiddenPromise
;
}
await
tab1UnloadedPromise
;
await
waitForTelemetryEvent
(
)
;
let
unloadTelemetry
=
Glean
.
browserEngagement
.
tabExplicitUnload
.
testGetValue
(
)
;
Assert
.
equal
(
unloadTelemetry
.
length
1
"
should
get
exactly
one
telemetry
event
"
)
;
let
e
=
unloadTelemetry
[
0
]
;
checkEventCommon
(
e
)
;
Assert
.
equal
(
e
.
extra
.
unload_selected_tab
"
true
"
"
did
unload
selected
tab
"
)
;
Assert
.
equal
(
e
.
extra
.
all_tabs_unloaded
"
false
"
"
did
not
unload
everything
"
)
;
Assert
.
equal
(
e
.
extra
.
tabs_unloaded
"
1
"
"
correct
number
of
tabs
unloaded
"
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
BrowserTestUtils
.
removeTab
(
tab3
)
;
await
BrowserTestUtils
.
removeTab
(
tab2
)
;
await
BrowserTestUtils
.
removeTab
(
tab1
)
;
}
)
;
add_task
(
async
function
test_unload_all_tabs
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
let
[
tab1
tab2
tab3
]
=
await
addBrowserTabs
(
3
)
;
let
menuItemUnload
=
document
.
getElementById
(
"
context_unloadTab
"
)
;
await
triggerClickOn
(
tab1
{
ctrlKey
:
true
}
)
;
await
triggerClickOn
(
tab2
{
ctrlKey
:
true
}
)
;
await
triggerClickOn
(
tab3
{
ctrlKey
:
true
}
)
;
updateTabContextMenu
(
originalTab
)
;
Services
.
fog
.
testResetFOG
(
)
;
let
allTabsUnloadedPromises
=
[
originalTab
tab1
tab2
tab3
]
.
map
(
getWaitForUnloadedPromise
)
;
{
let
menu
=
await
openTabMenuFor
(
originalTab
)
;
let
menuHiddenPromise
=
BrowserTestUtils
.
waitForPopupEvent
(
menu
"
hidden
"
)
;
menu
.
activateItem
(
menuItemUnload
)
;
await
menuHiddenPromise
;
}
await
Promise
.
all
(
allTabsUnloadedPromises
)
;
await
waitForTelemetryEvent
(
)
;
let
unloadTelemetry
=
Glean
.
browserEngagement
.
tabExplicitUnload
.
testGetValue
(
)
;
Assert
.
equal
(
unloadTelemetry
.
length
1
"
should
get
exactly
one
telemetry
event
"
)
;
let
e
=
unloadTelemetry
[
0
]
;
checkEventCommon
(
e
)
;
Assert
.
equal
(
e
.
extra
.
unload_selected_tab
"
true
"
"
did
unload
selected
tab
"
)
;
Assert
.
equal
(
e
.
extra
.
all_tabs_unloaded
"
true
"
"
did
unload
everything
"
)
;
Assert
.
equal
(
e
.
extra
.
tabs_unloaded
"
4
"
"
correct
number
of
tabs
unloaded
"
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
BrowserTestUtils
.
removeTab
(
tab3
)
;
await
BrowserTestUtils
.
removeTab
(
tab2
)
;
await
BrowserTestUtils
.
removeTab
(
tab1
)
;
}
)
;
add_task
(
async
function
test_cleanup
(
)
{
await
BrowserTestUtils
.
removeTab
(
FirefoxViewHandler
.
tab
)
;
}
)
;
