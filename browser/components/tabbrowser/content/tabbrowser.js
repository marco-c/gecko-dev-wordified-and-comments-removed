{
const
FAVICON_DEFAULTS
=
{
"
about
:
newtab
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
home
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
welcome
"
:
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
"
about
:
privatebrowsing
"
:
"
chrome
:
/
/
browser
/
skin
/
privatebrowsing
/
favicon
.
svg
"
}
;
const
{
LOAD_FLAGS_NONE
LOAD_FLAGS_FROM_EXTERNAL
LOAD_FLAGS_FIRST_LOAD
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
LOAD_FLAGS_FORCE_ALLOW_DATA_URI
LOAD_FLAGS_DISABLE_TRR
}
=
Ci
.
nsIWebNavigation
;
const
DIRECTION_FORWARD
=
1
;
const
DIRECTION_BACKWARD
=
-
1
;
function
updateUserContextUIIndicator
(
)
{
function
replaceContainerClass
(
classType
element
value
)
{
let
prefix
=
"
identity
-
"
+
classType
+
"
-
"
;
if
(
value
&
&
element
.
classList
.
contains
(
prefix
+
value
)
)
{
return
;
}
for
(
let
className
of
element
.
classList
)
{
if
(
className
.
startsWith
(
prefix
)
)
{
element
.
classList
.
remove
(
className
)
;
}
}
if
(
value
)
{
element
.
classList
.
add
(
prefix
+
value
)
;
}
}
let
hbox
=
document
.
getElementById
(
"
userContext
-
icons
"
)
;
let
userContextId
=
gBrowser
.
selectedBrowser
.
getAttribute
(
"
usercontextid
"
)
;
if
(
!
userContextId
)
{
replaceContainerClass
(
"
color
"
hbox
"
"
)
;
hbox
.
hidden
=
true
;
return
;
}
let
identity
=
ContextualIdentityService
.
getPublicIdentityFromId
(
userContextId
)
;
if
(
!
identity
)
{
replaceContainerClass
(
"
color
"
hbox
"
"
)
;
hbox
.
hidden
=
true
;
return
;
}
replaceContainerClass
(
"
color
"
hbox
identity
.
color
)
;
let
label
=
ContextualIdentityService
.
getUserContextLabel
(
userContextId
)
;
document
.
getElementById
(
"
userContext
-
label
"
)
.
textContent
=
label
;
hbox
.
setAttribute
(
"
tooltiptext
"
label
)
;
let
indicator
=
document
.
getElementById
(
"
userContext
-
indicator
"
)
;
replaceContainerClass
(
"
icon
"
indicator
identity
.
icon
)
;
hbox
.
hidden
=
false
;
}
async
function
getTotalMemoryUsage
(
)
{
const
procInfo
=
await
ChromeUtils
.
requestProcInfo
(
)
;
let
totalMemoryUsage
=
procInfo
.
memory
;
for
(
const
child
of
procInfo
.
children
)
{
totalMemoryUsage
+
=
child
.
memory
;
}
return
totalMemoryUsage
;
}
window
.
Tabbrowser
=
class
{
init
(
)
{
this
.
tabContainer
=
document
.
getElementById
(
"
tabbrowser
-
tabs
"
)
;
this
.
tabGroupMenu
=
document
.
getElementById
(
"
tab
-
group
-
editor
"
)
;
this
.
tabbox
=
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
this
.
tabpanels
=
document
.
getElementById
(
"
tabbrowser
-
tabpanels
"
)
;
this
.
verticalPinnedTabsContainer
=
document
.
getElementById
(
"
vertical
-
pinned
-
tabs
-
container
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
AsyncTabSwitcher
:
"
resource
:
/
/
/
modules
/
AsyncTabSwitcher
.
sys
.
mjs
"
PictureInPicture
:
"
resource
:
/
/
gre
/
modules
/
PictureInPicture
.
sys
.
mjs
"
UrlbarProviderOpenTabs
:
"
resource
:
/
/
/
modules
/
UrlbarProviderOpenTabs
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
MacSharingService
:
[
"
mozilla
.
org
/
widget
/
macsharingservice
;
1
"
"
nsIMacSharingService
"
]
}
)
;
ChromeUtils
.
defineLazyGetter
(
this
"
tabLocalization
"
(
)
=
>
{
return
new
Localization
(
[
"
browser
/
tabbrowser
.
ftl
"
"
branding
/
brand
.
ftl
"
]
true
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_shouldExposeContentTitle
"
"
privacy
.
exposeContentTitleInWindow
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_shouldExposeContentTitlePbm
"
"
privacy
.
exposeContentTitleInWindow
.
pbm
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_showTabCardPreview
"
"
browser
.
tabs
.
hoverPreview
.
enabled
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_allowTransparentBrowser
"
"
browser
.
tabs
.
allow_transparent_browser
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
showPidAndActiveness
"
"
browser
.
tabs
.
tooltipsShowPidAndActiveness
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_unloadTabInContextMenu
"
"
browser
.
tabs
.
unloadTabInContextMenu
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_notificationEnableDelay
"
"
security
.
notification_enable_delay
"
500
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
ChromeUtils
.
defineESModuleGetters
(
this
{
TabCrashHandler
:
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
sys
.
mjs
"
}
)
;
}
Services
.
obs
.
addObserver
(
this
"
contextual
-
identity
-
updated
"
)
;
document
.
addEventListener
(
"
keydown
"
this
{
mozSystemGroup
:
true
}
)
;
document
.
addEventListener
(
"
keypress
"
this
{
mozSystemGroup
:
true
}
)
;
document
.
addEventListener
(
"
visibilitychange
"
this
)
;
window
.
addEventListener
(
"
framefocusrequested
"
this
)
;
window
.
addEventListener
(
"
activate
"
this
)
;
window
.
addEventListener
(
"
deactivate
"
this
)
;
window
.
addEventListener
(
"
TabGroupCreate
"
this
)
;
this
.
tabContainer
.
init
(
)
;
this
.
_setupInitialBrowserAndTab
(
)
;
if
(
Services
.
prefs
.
getIntPref
(
"
browser
.
display
.
document_color_use
"
)
=
=
2
)
{
this
.
tabpanels
.
style
.
backgroundColor
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
display
.
use_system_colors
"
)
?
"
canvas
"
:
Services
.
prefs
.
getCharPref
(
"
browser
.
display
.
background_color
"
)
;
}
this
.
_setFindbarData
(
)
;
document
.
querySelector
(
"
title
"
)
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
this
.
_setupEventListeners
(
)
;
this
.
_initialized
=
true
;
}
ownerGlobal
=
window
;
ownerDocument
=
document
;
closingTabsEnum
=
{
ALL
:
0
OTHER
:
1
TO_START
:
2
TO_END
:
3
MULTI_SELECTED
:
4
DUPLICATES
:
6
ALL_DUPLICATES
:
7
}
;
_lastRelatedTabMap
=
new
WeakMap
(
)
;
mProgressListeners
=
[
]
;
mTabsProgressListeners
=
[
]
;
_tabListeners
=
new
Map
(
)
;
_tabFilters
=
new
Map
(
)
;
_isBusy
=
false
;
_awaitingToggleCaretBrowsingPrompt
=
false
;
_previewMode
=
false
;
_lastFindValue
=
"
"
;
_contentWaitingCount
=
0
;
_tabLayerCache
=
[
]
;
tabAnimationsInProgress
=
0
;
_tabForBrowser
=
new
WeakMap
(
)
;
_browserBindingProperties
=
[
"
canGoBack
"
"
canGoForward
"
"
goBack
"
"
goForward
"
"
permitUnload
"
"
reload
"
"
reloadWithFlags
"
"
stop
"
"
loadURI
"
"
fixupAndLoadURIString
"
"
gotoIndex
"
"
currentURI
"
"
documentURI
"
"
remoteType
"
"
preferences
"
"
imageDocument
"
"
isRemoteBrowser
"
"
messageManager
"
"
getTabBrowser
"
"
finder
"
"
fastFind
"
"
sessionHistory
"
"
contentTitle
"
"
characterSet
"
"
fullZoom
"
"
textZoom
"
"
tabHasCustomZoom
"
"
webProgress
"
"
addProgressListener
"
"
removeProgressListener
"
"
audioPlaybackStarted
"
"
audioPlaybackStopped
"
"
resumeMedia
"
"
mute
"
"
unmute
"
"
blockedPopups
"
"
lastURI
"
"
purgeSessionHistory
"
"
stopScroll
"
"
startScroll
"
"
userTypedValue
"
"
userTypedClear
"
"
didStartLoadSinceLastUserTyping
"
"
audioMuted
"
]
;
_removingTabs
=
new
Set
(
)
;
_multiSelectedTabsSet
=
new
WeakSet
(
)
;
_lastMultiSelectedTabRef
=
null
;
_clearMultiSelectionLocked
=
false
;
_clearMultiSelectionLockedOnce
=
false
;
_multiSelectChangeStarted
=
false
;
_multiSelectChangeAdditions
=
new
Set
(
)
;
_multiSelectChangeRemovals
=
new
Set
(
)
;
_multiSelectChangeSelected
=
false
;
_windowIsClosing
=
false
;
preloadedBrowser
=
null
;
browsers
=
new
Proxy
(
[
]
{
has
:
(
target
name
)
=
>
{
if
(
typeof
name
=
=
"
string
"
&
&
Number
.
isInteger
(
parseInt
(
name
)
)
)
{
return
name
in
gBrowser
.
tabs
;
}
return
false
;
}
get
:
(
target
name
)
=
>
{
if
(
name
=
=
"
length
"
)
{
return
gBrowser
.
tabs
.
length
;
}
if
(
typeof
name
=
=
"
string
"
&
&
Number
.
isInteger
(
parseInt
(
name
)
)
)
{
if
(
!
(
name
in
gBrowser
.
tabs
)
)
{
return
undefined
;
}
return
gBrowser
.
tabs
[
name
]
.
linkedBrowser
;
}
return
target
[
name
]
;
}
}
)
;
_printPreviewBrowsers
=
new
Set
(
)
;
_switcher
=
null
;
_soundPlayingAttrRemovalTimer
=
0
;
_hoverTabTimer
=
null
;
get
_tabGroupsEnabled
(
)
{
return
NimbusFeatures
.
tabGroups
.
getVariable
(
"
enabled
"
)
;
}
get
tabs
(
)
{
return
this
.
tabContainer
.
allTabs
;
}
get
tabGroups
(
)
{
return
this
.
tabContainer
.
allGroups
;
}
get
tabsInCollapsedTabGroups
(
)
{
return
this
.
tabGroups
.
filter
(
tabGroup
=
>
tabGroup
.
collapsed
)
.
flatMap
(
tabGroup
=
>
tabGroup
.
tabs
)
.
filter
(
tab
=
>
!
tab
.
hidden
&
&
!
tab
.
isClosing
)
;
}
addEventListener
(
.
.
.
args
)
{
this
.
tabpanels
.
addEventListener
(
.
.
.
args
)
;
}
removeEventListener
(
.
.
.
args
)
{
this
.
tabpanels
.
removeEventListener
(
.
.
.
args
)
;
}
dispatchEvent
(
.
.
.
args
)
{
return
this
.
tabpanels
.
dispatchEvent
(
.
.
.
args
)
;
}
get
openTabs
(
)
{
return
this
.
tabContainer
.
openTabs
;
}
get
visibleTabs
(
)
{
return
this
.
tabContainer
.
visibleTabs
;
}
get
pinnedTabCount
(
)
{
for
(
var
i
=
0
;
i
<
this
.
tabs
.
length
;
i
+
+
)
{
if
(
!
this
.
tabs
[
i
]
.
pinned
)
{
break
;
}
}
return
i
;
}
set
selectedTab
(
val
)
{
if
(
gSharedTabWarning
.
willShowSharedTabWarning
(
val
)
|
|
document
.
documentElement
.
hasAttribute
(
"
window
-
modal
-
open
"
)
|
|
(
gNavToolbox
.
collapsed
&
&
!
this
.
_allowTabChange
)
)
{
return
;
}
this
.
tabbox
.
selectedTab
=
val
;
}
get
selectedTab
(
)
{
return
this
.
_selectedTab
;
}
get
selectedBrowser
(
)
{
return
this
.
_selectedBrowser
;
}
_setupInitialBrowserAndTab
(
)
{
let
userContextId
=
window
.
arguments
&
&
window
.
arguments
[
5
]
;
let
openWindowInfo
=
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
.
initialOpenWindowInfo
;
if
(
!
openWindowInfo
&
&
window
.
arguments
&
&
window
.
arguments
[
11
]
)
{
openWindowInfo
=
window
.
arguments
[
11
]
;
}
let
tabArgument
=
gBrowserInit
.
getTabToAdopt
(
)
;
let
remoteType
;
let
initialBrowsingContextGroupId
;
if
(
tabArgument
&
&
tabArgument
.
hasAttribute
(
"
usercontextid
"
)
)
{
userContextId
=
parseInt
(
tabArgument
.
getAttribute
(
"
usercontextid
"
)
10
)
;
}
if
(
tabArgument
&
&
tabArgument
.
linkedBrowser
)
{
remoteType
=
tabArgument
.
linkedBrowser
.
remoteType
;
initialBrowsingContextGroupId
=
tabArgument
.
linkedBrowser
.
browsingContext
?
.
group
.
id
;
}
else
if
(
openWindowInfo
)
{
userContextId
=
openWindowInfo
.
originAttributes
.
userContextId
;
if
(
openWindowInfo
.
isRemote
)
{
remoteType
=
E10SUtils
.
DEFAULT_REMOTE_TYPE
;
}
else
{
remoteType
=
E10SUtils
.
NOT_REMOTE
;
}
}
else
{
let
uriToLoad
=
gBrowserInit
.
uriToLoadPromise
;
if
(
uriToLoad
&
&
Array
.
isArray
(
uriToLoad
)
)
{
uriToLoad
=
uriToLoad
[
0
]
;
}
if
(
uriToLoad
&
&
typeof
uriToLoad
=
=
"
string
"
)
{
let
oa
=
E10SUtils
.
predictOriginAttributes
(
{
window
userContextId
}
)
;
remoteType
=
E10SUtils
.
getRemoteTypeForURI
(
uriToLoad
gMultiProcessBrowser
gFissionBrowser
E10SUtils
.
DEFAULT_REMOTE_TYPE
null
oa
)
;
}
else
{
remoteType
=
E10SUtils
.
PRIVILEGEDABOUT_REMOTE_TYPE
;
}
}
let
createOptions
=
{
uriIsAboutBlank
:
false
userContextId
initialBrowsingContextGroupId
remoteType
openWindowInfo
}
;
let
browser
=
this
.
createBrowser
(
createOptions
)
;
browser
.
setAttribute
(
"
primary
"
"
true
"
)
;
if
(
gBrowserAllowScriptsToCloseInitialTabs
)
{
browser
.
setAttribute
(
"
allowscriptstoclose
"
"
true
"
)
;
}
browser
.
droppedLinkHandler
=
handleDroppedLink
;
browser
.
loadURI
=
URILoadingWrapper
.
loadURI
.
bind
(
URILoadingWrapper
browser
)
;
browser
.
fixupAndLoadURIString
=
URILoadingWrapper
.
fixupAndLoadURIString
.
bind
(
URILoadingWrapper
browser
)
;
let
uniqueId
=
this
.
_generateUniquePanelID
(
)
;
let
panel
=
this
.
getPanel
(
browser
)
;
panel
.
id
=
uniqueId
;
this
.
tabpanels
.
appendChild
(
panel
)
;
let
tab
=
this
.
tabs
[
0
]
;
tab
.
linkedPanel
=
uniqueId
;
this
.
_selectedTab
=
tab
;
this
.
_selectedBrowser
=
browser
;
tab
.
permanentKey
=
browser
.
permanentKey
;
tab
.
_tPos
=
0
;
tab
.
_fullyOpen
=
true
;
tab
.
linkedBrowser
=
browser
;
if
(
userContextId
)
{
tab
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
ContextualIdentityService
.
setTabStyle
(
tab
)
;
}
this
.
_tabForBrowser
.
set
(
browser
tab
)
;
this
.
_appendStatusPanel
(
)
;
browser
.
docShellIsActive
=
this
.
shouldActivateDocShell
(
browser
)
;
let
tabListener
=
new
TabProgressListener
(
tab
browser
true
false
)
;
let
filter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
filter
.
addProgressListener
(
tabListener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
this
.
_tabListeners
.
set
(
tab
tabListener
)
;
this
.
_tabFilters
.
set
(
tab
filter
)
;
browser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
}
get
canGoBack
(
)
{
return
this
.
selectedBrowser
.
canGoBack
;
}
get
canGoBackIgnoringUserInteraction
(
)
{
return
this
.
selectedBrowser
.
canGoBackIgnoringUserInteraction
;
}
get
canGoForward
(
)
{
return
this
.
selectedBrowser
.
canGoForward
;
}
goBack
(
requireUserInteraction
)
{
return
this
.
selectedBrowser
.
goBack
(
requireUserInteraction
)
;
}
goForward
(
requireUserInteraction
)
{
return
this
.
selectedBrowser
.
goForward
(
requireUserInteraction
)
;
}
reload
(
)
{
return
this
.
selectedBrowser
.
reload
(
)
;
}
reloadWithFlags
(
aFlags
)
{
return
this
.
selectedBrowser
.
reloadWithFlags
(
aFlags
)
;
}
stop
(
)
{
return
this
.
selectedBrowser
.
stop
(
)
;
}
loadURI
(
uri
params
)
{
return
this
.
selectedBrowser
.
loadURI
(
uri
params
)
;
}
fixupAndLoadURIString
(
uriString
params
)
{
return
this
.
selectedBrowser
.
fixupAndLoadURIString
(
uriString
params
)
;
}
gotoIndex
(
aIndex
)
{
return
this
.
selectedBrowser
.
gotoIndex
(
aIndex
)
;
}
get
currentURI
(
)
{
return
this
.
selectedBrowser
.
currentURI
;
}
get
finder
(
)
{
return
this
.
selectedBrowser
.
finder
;
}
get
docShell
(
)
{
return
this
.
selectedBrowser
.
docShell
;
}
get
webNavigation
(
)
{
return
this
.
selectedBrowser
.
webNavigation
;
}
get
webProgress
(
)
{
return
this
.
selectedBrowser
.
webProgress
;
}
get
contentWindow
(
)
{
return
this
.
selectedBrowser
.
contentWindow
;
}
get
sessionHistory
(
)
{
return
this
.
selectedBrowser
.
sessionHistory
;
}
get
contentDocument
(
)
{
return
this
.
selectedBrowser
.
contentDocument
;
}
get
contentTitle
(
)
{
return
this
.
selectedBrowser
.
contentTitle
;
}
get
contentPrincipal
(
)
{
return
this
.
selectedBrowser
.
contentPrincipal
;
}
get
securityUI
(
)
{
return
this
.
selectedBrowser
.
securityUI
;
}
set
fullZoom
(
val
)
{
this
.
selectedBrowser
.
fullZoom
=
val
;
}
get
fullZoom
(
)
{
return
this
.
selectedBrowser
.
fullZoom
;
}
set
textZoom
(
val
)
{
this
.
selectedBrowser
.
textZoom
=
val
;
}
get
textZoom
(
)
{
return
this
.
selectedBrowser
.
textZoom
;
}
get
isSyntheticDocument
(
)
{
return
this
.
selectedBrowser
.
isSyntheticDocument
;
}
set
userTypedValue
(
val
)
{
this
.
selectedBrowser
.
userTypedValue
=
val
;
}
get
userTypedValue
(
)
{
return
this
.
selectedBrowser
.
userTypedValue
;
}
_setFindbarData
(
)
{
let
{
sharedData
}
=
Services
.
ppmm
;
if
(
!
sharedData
.
has
(
"
Findbar
:
Shortcut
"
)
)
{
let
keyEl
=
document
.
getElementById
(
"
key_find
"
)
;
let
mods
=
keyEl
.
getAttribute
(
"
modifiers
"
)
.
replace
(
/
accel
/
i
AppConstants
.
platform
=
=
"
macosx
"
?
"
meta
"
:
"
control
"
)
;
sharedData
.
set
(
"
Findbar
:
Shortcut
"
{
key
:
keyEl
.
getAttribute
(
"
key
"
)
shiftKey
:
mods
.
includes
(
"
shift
"
)
ctrlKey
:
mods
.
includes
(
"
control
"
)
altKey
:
mods
.
includes
(
"
alt
"
)
metaKey
:
mods
.
includes
(
"
meta
"
)
}
)
;
}
}
isFindBarInitialized
(
aTab
)
{
return
(
aTab
|
|
this
.
selectedTab
)
.
_findBar
!
=
undefined
;
}
getCachedFindBar
(
aTab
=
this
.
selectedTab
)
{
return
aTab
.
_findBar
;
}
async
getFindBar
(
aTab
=
this
.
selectedTab
)
{
let
findBar
=
this
.
getCachedFindBar
(
aTab
)
;
if
(
findBar
)
{
return
findBar
;
}
if
(
!
aTab
.
_pendingFindBar
)
{
aTab
.
_pendingFindBar
=
this
.
_createFindBar
(
aTab
)
;
}
return
aTab
.
_pendingFindBar
;
}
async
_createFindBar
(
aTab
)
{
let
findBar
=
document
.
createXULElement
(
"
findbar
"
)
;
let
browser
=
this
.
getBrowserForTab
(
aTab
)
;
browser
.
parentNode
.
insertAdjacentElement
(
"
afterend
"
findBar
)
;
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
delete
aTab
.
_pendingFindBar
;
if
(
window
.
closed
|
|
aTab
.
closing
)
{
return
null
;
}
findBar
.
browser
=
browser
;
findBar
.
_findField
.
value
=
this
.
_lastFindValue
;
aTab
.
_findBar
=
findBar
;
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
TabFindInitialized
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
return
findBar
;
}
_appendStatusPanel
(
)
{
this
.
selectedBrowser
.
insertAdjacentElement
(
"
afterend
"
StatusPanel
.
panel
)
;
}
_updateTabBarForPinnedTabs
(
)
{
this
.
tabContainer
.
_unlockTabSizing
(
)
;
this
.
tabContainer
.
_positionPinnedTabs
(
)
;
this
.
tabContainer
.
_updateCloseButtons
(
)
;
}
_notifyPinnedStatus
(
aTab
)
{
if
(
aTab
.
linkedBrowser
.
browsingContext
)
{
aTab
.
linkedBrowser
.
browsingContext
.
isAppTab
=
aTab
.
pinned
;
}
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
aTab
.
pinned
?
"
TabPinned
"
:
"
TabUnpinned
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
}
pinTab
(
aTab
)
{
if
(
aTab
.
pinned
)
{
return
;
}
this
.
showTab
(
aTab
)
;
if
(
this
.
tabContainer
.
verticalMode
)
{
this
.
_handleTabMove
(
aTab
(
)
=
>
this
.
verticalPinnedTabsContainer
.
appendChild
(
aTab
)
)
;
}
else
{
this
.
moveTabTo
(
aTab
this
.
pinnedTabCount
{
forceStandaloneTab
:
true
}
)
;
}
aTab
.
setAttribute
(
"
pinned
"
"
true
"
)
;
this
.
_updateTabBarForPinnedTabs
(
)
;
this
.
_notifyPinnedStatus
(
aTab
)
;
}
unpinTab
(
aTab
)
{
if
(
!
aTab
.
pinned
)
{
return
;
}
if
(
this
.
tabContainer
.
verticalMode
)
{
this
.
_handleTabMove
(
aTab
(
)
=
>
{
aTab
.
removeAttribute
(
"
pinned
"
)
;
this
.
tabContainer
.
arrowScrollbox
.
prepend
(
aTab
)
;
}
)
;
}
else
{
this
.
moveTabTo
(
aTab
this
.
pinnedTabCount
-
1
{
forceStandaloneTab
:
true
}
)
;
aTab
.
removeAttribute
(
"
pinned
"
)
;
}
aTab
.
style
.
marginInlineStart
=
"
"
;
aTab
.
_pinnedUnscrollable
=
false
;
this
.
_updateTabBarForPinnedTabs
(
)
;
this
.
_notifyPinnedStatus
(
aTab
)
;
}
previewTab
(
aTab
aCallback
)
{
let
currentTab
=
this
.
selectedTab
;
try
{
this
.
_previewMode
=
true
;
this
.
selectedTab
=
aTab
;
aCallback
(
)
;
}
finally
{
this
.
selectedTab
=
currentTab
;
this
.
_previewMode
=
false
;
}
}
getBrowserAtIndex
(
aIndex
)
{
return
this
.
browsers
[
aIndex
]
;
}
getBrowserForOuterWindowID
(
aID
)
{
for
(
let
b
of
this
.
browsers
)
{
if
(
b
.
outerWindowID
=
=
aID
)
{
return
b
;
}
}
return
null
;
}
getTabForBrowser
(
aBrowser
)
{
return
this
.
_tabForBrowser
.
get
(
aBrowser
)
;
}
getPanel
(
aBrowser
)
{
return
this
.
getBrowserContainer
(
aBrowser
)
.
parentNode
;
}
getBrowserContainer
(
aBrowser
)
{
return
(
aBrowser
|
|
this
.
selectedBrowser
)
.
parentNode
.
parentNode
;
}
getTabNotificationDeck
(
)
{
if
(
!
this
.
_tabNotificationDeck
)
{
let
template
=
document
.
getElementById
(
"
tab
-
notification
-
deck
-
template
"
)
;
template
.
replaceWith
(
template
.
content
)
;
this
.
_tabNotificationDeck
=
document
.
getElementById
(
"
tab
-
notification
-
deck
"
)
;
}
return
this
.
_tabNotificationDeck
;
}
_nextNotificationBoxId
=
0
;
getNotificationBox
(
aBrowser
)
{
let
browser
=
aBrowser
|
|
this
.
selectedBrowser
;
if
(
!
browser
.
_notificationBox
)
{
browser
.
_notificationBox
=
new
MozElements
.
NotificationBox
(
element
=
>
{
element
.
setAttribute
(
"
notificationside
"
"
top
"
)
;
element
.
setAttribute
(
"
name
"
tab
-
notification
-
box
-
{
this
.
_nextNotificationBoxId
+
+
}
)
;
this
.
getTabNotificationDeck
(
)
.
append
(
element
)
;
if
(
browser
=
=
this
.
selectedBrowser
)
{
this
.
_updateVisibleNotificationBox
(
browser
)
;
}
}
this
.
_notificationEnableDelay
)
;
}
return
browser
.
_notificationBox
;
}
readNotificationBox
(
aBrowser
)
{
let
browser
=
aBrowser
|
|
this
.
selectedBrowser
;
return
browser
.
_notificationBox
|
|
null
;
}
_updateVisibleNotificationBox
(
aBrowser
)
{
if
(
!
this
.
_tabNotificationDeck
)
{
return
;
}
let
notificationBox
=
this
.
readNotificationBox
(
aBrowser
)
;
this
.
getTabNotificationDeck
(
)
.
selectedViewName
=
notificationBox
?
notificationBox
.
stack
.
getAttribute
(
"
name
"
)
:
"
"
;
}
getTabDialogBox
(
aBrowser
)
{
if
(
!
aBrowser
)
{
throw
new
Error
(
"
aBrowser
is
required
"
)
;
}
if
(
!
aBrowser
.
tabDialogBox
)
{
aBrowser
.
tabDialogBox
=
new
TabDialogBox
(
aBrowser
)
;
}
return
aBrowser
.
tabDialogBox
;
}
getTabFromAudioEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
null
;
}
var
browser
=
aEvent
.
originalTarget
;
var
tab
=
this
.
getTabForBrowser
(
browser
)
;
return
tab
;
}
_callProgressListeners
(
aBrowser
aMethod
aArguments
aCallGlobalListeners
=
true
aCallTabsListeners
=
true
)
{
var
rv
=
true
;
function
callListeners
(
listeners
args
)
{
for
(
let
p
of
listeners
)
{
if
(
aMethod
in
p
)
{
try
{
if
(
!
p
[
aMethod
]
.
apply
(
p
args
)
)
{
rv
=
false
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
}
}
aBrowser
=
aBrowser
|
|
this
.
selectedBrowser
;
if
(
aCallGlobalListeners
&
&
aBrowser
=
=
this
.
selectedBrowser
)
{
callListeners
(
this
.
mProgressListeners
aArguments
)
;
}
if
(
aCallTabsListeners
)
{
aArguments
.
unshift
(
aBrowser
)
;
callListeners
(
this
.
mTabsProgressListeners
aArguments
)
;
}
return
rv
;
}
setDefaultIcon
(
aTab
aURI
)
{
if
(
aURI
&
&
aURI
.
spec
in
FAVICON_DEFAULTS
)
{
this
.
setIcon
(
aTab
FAVICON_DEFAULTS
[
aURI
.
spec
]
)
;
}
}
setIcon
(
aTab
aIconURL
=
"
"
aOriginalURL
=
aIconURL
aLoadingPrincipal
=
null
aClearImageFirst
=
false
)
{
let
makeString
=
url
=
>
(
url
instanceof
Ci
.
nsIURI
?
url
.
spec
:
url
)
;
aIconURL
=
makeString
(
aIconURL
)
;
aOriginalURL
=
makeString
(
aOriginalURL
)
;
let
LOCAL_PROTOCOLS
=
[
"
chrome
:
"
"
about
:
"
"
resource
:
"
"
data
:
"
]
;
if
(
aIconURL
&
&
!
aLoadingPrincipal
&
&
!
LOCAL_PROTOCOLS
.
some
(
protocol
=
>
aIconURL
.
startsWith
(
protocol
)
)
)
{
console
.
error
(
Attempt
to
set
a
remote
URL
{
aIconURL
}
as
a
tab
icon
without
a
loading
principal
.
)
;
return
;
}
let
browser
=
this
.
getBrowserForTab
(
aTab
)
;
browser
.
mIconURL
=
aIconURL
;
if
(
aIconURL
!
=
aTab
.
getAttribute
(
"
image
"
)
)
{
if
(
aClearImageFirst
)
{
aTab
.
removeAttribute
(
"
image
"
)
;
}
if
(
aIconURL
)
{
if
(
aLoadingPrincipal
)
{
aTab
.
setAttribute
(
"
iconloadingprincipal
"
aLoadingPrincipal
)
;
}
else
{
aTab
.
removeAttribute
(
"
iconloadingprincipal
"
)
;
}
aTab
.
setAttribute
(
"
image
"
aIconURL
)
;
}
else
{
aTab
.
removeAttribute
(
"
image
"
)
;
aTab
.
removeAttribute
(
"
iconloadingprincipal
"
)
;
}
this
.
_tabAttrModified
(
aTab
[
"
image
"
]
)
;
}
this
.
_callProgressListeners
(
browser
"
onLinkIconAvailable
"
[
aIconURL
aOriginalURL
]
)
;
}
getIcon
(
aTab
)
{
let
browser
=
aTab
?
this
.
getBrowserForTab
(
aTab
)
:
this
.
selectedBrowser
;
return
browser
.
mIconURL
;
}
setPageInfo
(
aURL
aDescription
aPreviewImage
)
{
if
(
aURL
)
{
let
pageInfo
=
{
url
:
aURL
description
:
aDescription
previewImageURL
:
aPreviewImage
}
;
PlacesUtils
.
history
.
update
(
pageInfo
)
.
catch
(
console
.
error
)
;
}
}
getWindowTitleForBrowser
(
aBrowser
)
{
let
docElement
=
document
.
documentElement
;
let
title
=
"
"
;
let
dataSuffix
=
docElement
.
getAttribute
(
"
privatebrowsingmode
"
)
=
=
"
temporary
"
?
"
Private
"
:
"
Default
"
;
if
(
SelectableProfileService
?
.
isEnabled
&
&
SelectableProfileService
.
currentProfile
)
{
dataSuffix
+
=
"
WithProfile
"
;
}
let
defaultTitle
=
docElement
.
dataset
[
"
title
"
+
dataSuffix
]
.
replace
(
"
PROFILENAME
"
(
)
=
>
SelectableProfileService
.
currentProfile
.
name
.
replace
(
/
\
0
/
g
"
"
)
)
;
if
(
!
this
.
_shouldExposeContentTitle
|
|
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
!
this
.
_shouldExposeContentTitlePbm
)
)
{
return
defaultTitle
;
}
try
{
if
(
docElement
.
getAttribute
(
"
chromehidden
"
)
.
includes
(
"
location
"
)
)
{
const
uri
=
Services
.
io
.
createExposableURI
(
aBrowser
.
currentURI
)
;
let
prefix
=
uri
.
prePath
;
if
(
uri
.
scheme
=
=
"
about
"
)
{
prefix
=
uri
.
spec
;
}
else
if
(
uri
.
scheme
=
=
"
moz
-
extension
"
)
{
const
ext
=
WebExtensionPolicy
.
getByHostname
(
uri
.
host
)
;
if
(
ext
&
&
ext
.
name
)
{
let
extensionLabel
=
document
.
getElementById
(
"
urlbar
-
label
-
extension
"
)
;
prefix
=
{
extensionLabel
.
value
}
(
{
ext
.
name
}
)
;
}
}
title
=
prefix
+
"
-
"
;
}
}
catch
(
e
)
{
}
if
(
docElement
.
hasAttribute
(
"
titlepreface
"
)
)
{
title
+
=
docElement
.
getAttribute
(
"
titlepreface
"
)
;
}
let
tab
=
this
.
getTabForBrowser
(
aBrowser
)
;
if
(
tab
.
_labelIsContentTitle
)
{
title
+
=
tab
.
getAttribute
(
"
label
"
)
.
replace
(
/
\
0
/
g
"
"
)
;
}
if
(
title
)
{
return
docElement
.
dataset
[
"
contentTitle
"
+
dataSuffix
]
.
replace
(
"
CONTENTTITLE
"
(
)
=
>
title
)
.
replace
(
"
PROFILENAME
"
(
)
=
>
SelectableProfileService
?
.
currentProfile
?
.
name
.
replace
(
/
\
0
/
g
"
"
)
?
?
"
"
)
;
}
return
defaultTitle
;
}
updateTitlebar
(
)
{
document
.
title
=
this
.
getWindowTitleForBrowser
(
this
.
selectedBrowser
)
;
}
updateCurrentBrowser
(
aForceUpdate
)
{
let
newBrowser
=
this
.
getBrowserAtIndex
(
this
.
tabContainer
.
selectedIndex
)
;
if
(
this
.
selectedBrowser
=
=
newBrowser
&
&
!
aForceUpdate
)
{
return
;
}
let
oldBrowser
=
this
.
selectedBrowser
;
gURLBar
?
.
saveSelectionStateForBrowser
(
oldBrowser
)
;
let
newTab
=
this
.
getTabForBrowser
(
newBrowser
)
;
if
(
!
aForceUpdate
)
{
TelemetryStopwatch
.
start
(
"
FX_TAB_SWITCH_UPDATE_MS
"
)
;
if
(
gMultiProcessBrowser
)
{
this
.
_asyncTabSwitching
=
true
;
this
.
_getSwitcher
(
)
.
requestTab
(
newTab
)
;
this
.
_asyncTabSwitching
=
false
;
}
document
.
commandDispatcher
.
lock
(
)
;
}
let
oldTab
=
this
.
selectedTab
;
if
(
!
this
.
_previewMode
&
&
!
oldTab
.
selected
)
{
oldTab
.
owner
=
null
;
}
let
lastRelatedTab
=
this
.
_lastRelatedTabMap
.
get
(
oldTab
)
;
if
(
lastRelatedTab
)
{
if
(
!
lastRelatedTab
.
selected
)
{
lastRelatedTab
.
owner
=
null
;
}
}
this
.
_lastRelatedTabMap
=
new
WeakMap
(
)
;
if
(
!
gMultiProcessBrowser
)
{
oldBrowser
.
removeAttribute
(
"
primary
"
)
;
oldBrowser
.
docShellIsActive
=
false
;
newBrowser
.
setAttribute
(
"
primary
"
"
true
"
)
;
newBrowser
.
docShellIsActive
=
!
document
.
hidden
;
}
this
.
_selectedBrowser
=
newBrowser
;
this
.
_selectedTab
=
newTab
;
this
.
showTab
(
newTab
)
;
this
.
_appendStatusPanel
(
)
;
this
.
_updateVisibleNotificationBox
(
newBrowser
)
;
let
oldBrowserPopupsBlocked
=
oldBrowser
.
popupBlocker
.
getBlockedPopupCount
(
)
;
let
newBrowserPopupsBlocked
=
newBrowser
.
popupBlocker
.
getBlockedPopupCount
(
)
;
if
(
oldBrowserPopupsBlocked
!
=
newBrowserPopupsBlocked
)
{
newBrowser
.
popupBlocker
.
updateBlockedPopupsUI
(
)
;
}
let
webProgress
=
newBrowser
.
webProgress
;
this
.
_callProgressListeners
(
null
"
onLocationChange
"
[
webProgress
null
newBrowser
.
currentURI
0
true
]
true
false
)
;
let
securityUI
=
newBrowser
.
securityUI
;
if
(
securityUI
)
{
this
.
_callProgressListeners
(
null
"
onSecurityChange
"
[
webProgress
null
securityUI
.
state
]
true
false
)
;
this
.
_callProgressListeners
(
null
"
onContentBlockingEvent
"
[
webProgress
null
newBrowser
.
getContentBlockingEvents
(
)
true
]
true
false
)
;
}
let
listener
=
this
.
_tabListeners
.
get
(
newTab
)
;
if
(
listener
&
&
listener
.
mStateFlags
)
{
this
.
_callProgressListeners
(
null
"
onUpdateCurrentBrowser
"
[
listener
.
mStateFlags
listener
.
mStatus
listener
.
mMessage
listener
.
mTotalProgress
]
true
false
)
;
}
if
(
!
this
.
_previewMode
)
{
newTab
.
recordTimeFromUnloadToReload
(
)
;
newTab
.
updateLastAccessed
(
)
;
oldTab
.
updateLastAccessed
(
)
;
if
(
this
.
ownerGlobal
=
=
BrowserWindowTracker
.
getTopWindow
(
)
)
{
newTab
.
updateLastSeenActive
(
)
;
oldTab
.
updateLastSeenActive
(
)
;
}
let
oldFindBar
=
oldTab
.
_findBar
;
if
(
oldFindBar
&
&
oldFindBar
.
findMode
=
=
oldFindBar
.
FIND_NORMAL
&
&
!
oldFindBar
.
hidden
)
{
this
.
_lastFindValue
=
oldFindBar
.
_findField
.
value
;
}
this
.
updateTitlebar
(
)
;
newTab
.
removeAttribute
(
"
titlechanged
"
)
;
newTab
.
attention
=
false
;
newBrowser
.
unselectedTabHover
(
false
)
;
}
if
(
newTab
.
hasAttribute
(
"
busy
"
)
&
&
!
this
.
_isBusy
)
{
this
.
_isBusy
=
true
;
this
.
_callProgressListeners
(
null
"
onStateChange
"
[
webProgress
null
Ci
.
nsIWebProgressListener
.
STATE_START
|
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
0
]
true
false
)
;
}
if
(
!
newTab
.
hasAttribute
(
"
busy
"
)
&
&
this
.
_isBusy
)
{
this
.
_isBusy
=
false
;
this
.
_callProgressListeners
(
null
"
onStateChange
"
[
webProgress
null
Ci
.
nsIWebProgressListener
.
STATE_STOP
|
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
0
]
true
false
)
;
}
if
(
!
this
.
_previewMode
)
{
let
event
=
new
CustomEvent
(
"
TabSelect
"
{
bubbles
:
true
cancelable
:
false
detail
:
{
previousTab
:
oldTab
}
}
)
;
newTab
.
dispatchEvent
(
event
)
;
this
.
_tabAttrModified
(
oldTab
[
"
selected
"
]
)
;
this
.
_tabAttrModified
(
newTab
[
"
selected
"
]
)
;
this
.
_startMultiSelectChange
(
)
;
this
.
_multiSelectChangeSelected
=
true
;
this
.
clearMultiSelectedTabs
(
)
;
if
(
this
.
_multiSelectChangeAdditions
.
size
)
{
this
.
addToMultiSelectedTabs
(
oldTab
)
;
}
if
(
!
gMultiProcessBrowser
)
{
this
.
_adjustFocusBeforeTabSwitch
(
oldTab
newTab
)
;
this
.
_adjustFocusAfterTabSwitch
(
newTab
)
;
}
if
(
aForceUpdate
|
|
!
gMultiProcessBrowser
)
{
gURLBar
.
afterTabSwitchFocusChange
(
)
;
}
}
updateUserContextUIIndicator
(
)
;
gPermissionPanel
.
updateSharingIndicator
(
)
;
oldTab
.
removeAttribute
(
"
touchdownstartsdrag
"
)
;
newTab
.
setAttribute
(
"
touchdownstartsdrag
"
"
true
"
)
;
if
(
!
gMultiProcessBrowser
)
{
document
.
commandDispatcher
.
unlock
(
)
;
let
event
=
new
CustomEvent
(
"
TabSwitchDone
"
{
bubbles
:
true
cancelable
:
true
}
)
;
this
.
dispatchEvent
(
event
)
;
}
if
(
!
aForceUpdate
)
{
TelemetryStopwatch
.
finish
(
"
FX_TAB_SWITCH_UPDATE_MS
"
)
;
}
}
_adjustFocusBeforeTabSwitch
(
oldTab
newTab
)
{
if
(
this
.
_previewMode
)
{
return
;
}
let
oldBrowser
=
oldTab
.
linkedBrowser
;
let
newBrowser
=
newTab
.
linkedBrowser
;
gURLBar
.
getBrowserState
(
oldBrowser
)
.
urlbarFocused
=
gURLBar
.
focused
;
if
(
this
.
_asyncTabSwitching
)
{
newBrowser
.
_userTypedValueAtBeforeTabSwitch
=
newBrowser
.
userTypedValue
;
}
if
(
this
.
isFindBarInitialized
(
oldTab
)
)
{
let
findBar
=
this
.
getCachedFindBar
(
oldTab
)
;
oldTab
.
_findBarFocused
=
!
findBar
.
hidden
&
&
findBar
.
_findField
.
getAttribute
(
"
focused
"
)
=
=
"
true
"
;
}
let
activeEl
=
document
.
activeElement
;
if
(
activeEl
=
=
oldTab
)
{
newTab
.
focus
(
)
;
}
else
if
(
gMultiProcessBrowser
&
&
activeEl
!
=
newBrowser
&
&
activeEl
!
=
newTab
)
{
let
keepFocusOnUrlBar
=
newBrowser
&
&
gURLBar
.
getBrowserState
(
newBrowser
)
.
urlbarFocused
&
&
gURLBar
.
focused
;
if
(
!
keepFocusOnUrlBar
)
{
document
.
activeElement
.
blur
(
)
;
}
}
}
_adjustFocusAfterTabSwitch
(
newTab
)
{
if
(
document
.
activeElement
=
=
newTab
)
{
return
;
}
let
newBrowser
=
this
.
getBrowserForTab
(
newTab
)
;
if
(
newBrowser
.
hasAttribute
(
"
tabDialogShowing
"
)
)
{
newBrowser
.
tabDialogBox
.
focus
(
)
;
return
;
}
if
(
gURLBar
.
getBrowserState
(
newBrowser
)
.
urlbarFocused
)
{
let
selectURL
=
(
)
=
>
{
if
(
this
.
_asyncTabSwitching
)
{
newBrowser
.
_awaitingSetURI
=
true
;
const
currentActiveElement
=
document
.
activeElement
;
gURLBar
.
inputField
.
addEventListener
(
"
SetURI
"
(
)
=
>
{
delete
newBrowser
.
_awaitingSetURI
;
let
userTypedValueAtBeforeTabSwitch
=
newBrowser
.
_userTypedValueAtBeforeTabSwitch
;
delete
newBrowser
.
_userTypedValueAtBeforeTabSwitch
;
if
(
newBrowser
.
userTypedValue
&
&
newBrowser
.
userTypedValue
!
=
userTypedValueAtBeforeTabSwitch
)
{
return
;
}
if
(
currentActiveElement
!
=
document
.
activeElement
)
{
return
;
}
gURLBar
.
restoreSelectionStateForBrowser
(
newBrowser
)
;
}
{
once
:
true
}
)
;
}
else
{
gURLBar
.
restoreSelectionStateForBrowser
(
newBrowser
)
;
}
}
;
if
(
window
.
document
.
documentElement
.
hasAttribute
(
"
inDOMFullscreen
"
)
)
{
window
.
addEventListener
(
"
MozDOMFullscreen
:
Exited
"
selectURL
{
once
:
true
wantsUntrusted
:
false
}
)
;
return
;
}
if
(
!
window
.
fullScreen
|
|
newTab
.
isEmpty
)
{
selectURL
(
)
;
return
;
}
}
if
(
gFindBarInitialized
&
&
!
gFindBar
.
hidden
&
&
this
.
selectedTab
.
_findBarFocused
)
{
gFindBar
.
_findField
.
focus
(
)
;
return
;
}
if
(
gMultiProcessBrowser
&
&
document
.
activeElement
!
=
document
.
body
)
{
return
;
}
let
fm
=
Services
.
focus
;
let
focusFlags
=
fm
.
FLAG_NOSCROLL
;
if
(
!
gMultiProcessBrowser
)
{
let
newFocusedElement
=
fm
.
getFocusedElementForWindow
(
window
.
content
true
{
}
)
;
if
(
newFocusedElement
&
&
(
HTMLAnchorElement
.
isInstance
(
newFocusedElement
)
|
|
newFocusedElement
.
getAttributeNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
"
"
type
"
)
=
=
"
simple
"
)
)
{
focusFlags
|
=
fm
.
FLAG_SHOWRING
;
}
}
fm
.
setFocus
(
newBrowser
focusFlags
)
;
}
_tabAttrModified
(
aTab
aChanged
)
{
if
(
aTab
.
closing
)
{
return
;
}
let
event
=
new
CustomEvent
(
"
TabAttrModified
"
{
bubbles
:
true
cancelable
:
false
detail
:
{
changed
:
aChanged
}
}
)
;
aTab
.
dispatchEvent
(
event
)
;
}
resetBrowserSharing
(
aBrowser
)
{
let
tab
=
this
.
getTabForBrowser
(
aBrowser
)
;
if
(
!
tab
)
{
return
;
}
tab
.
_sharingState
=
tab
.
_sharingState
?
.
webRTC
?
{
webRTC
:
{
}
}
:
{
}
;
tab
.
removeAttribute
(
"
sharing
"
)
;
this
.
_tabAttrModified
(
tab
[
"
sharing
"
]
)
;
if
(
aBrowser
=
=
this
.
selectedBrowser
)
{
gPermissionPanel
.
updateSharingIndicator
(
)
;
}
}
updateBrowserSharing
(
aBrowser
aState
)
{
let
tab
=
this
.
getTabForBrowser
(
aBrowser
)
;
if
(
!
tab
)
{
return
;
}
if
(
tab
.
_sharingState
=
=
null
)
{
tab
.
_sharingState
=
{
}
;
}
tab
.
_sharingState
=
Object
.
assign
(
tab
.
_sharingState
aState
)
;
if
(
"
webRTC
"
in
aState
)
{
if
(
tab
.
_sharingState
.
webRTC
?
.
sharing
)
{
if
(
tab
.
_sharingState
.
webRTC
.
paused
)
{
tab
.
removeAttribute
(
"
sharing
"
)
;
}
else
{
tab
.
setAttribute
(
"
sharing
"
aState
.
webRTC
.
sharing
)
;
}
}
else
{
tab
.
removeAttribute
(
"
sharing
"
)
;
}
this
.
_tabAttrModified
(
tab
[
"
sharing
"
]
)
;
}
if
(
aBrowser
=
=
this
.
selectedBrowser
)
{
gPermissionPanel
.
updateSharingIndicator
(
)
;
}
}
getTabSharingState
(
aTab
)
{
let
state
=
Object
.
assign
(
{
}
aTab
.
_sharingState
&
&
aTab
.
_sharingState
.
webRTC
)
;
return
{
camera
:
!
!
state
.
camera
microphone
:
!
!
state
.
microphone
screen
:
state
.
screen
&
&
state
.
screen
.
replace
(
"
Paused
"
"
"
)
}
;
}
setInitialTabTitle
(
aTab
aTitle
aOptions
=
{
}
)
{
if
(
!
aOptions
.
isContentTitle
&
&
isBlankPageURL
(
aTitle
)
)
{
aTitle
=
this
.
tabContainer
.
emptyTabTitle
;
}
if
(
aTitle
)
{
if
(
!
aTab
.
getAttribute
(
"
label
"
)
)
{
aTab
.
_labelIsInitialTitle
=
true
;
}
this
.
_setTabLabel
(
aTab
aTitle
aOptions
)
;
}
}
_dataURLRegEx
=
/
^
data
:
[
^
]
+
;
base64
/
i
;
_nonPrintingRegEx
=
/
^
[
\
p
{
Z
}
\
p
{
C
}
\
p
{
M
}
\
u
{
115f
}
\
u
{
1160
}
\
u
{
2800
}
\
u
{
3164
}
\
u
{
ffa0
}
]
*
/
u
;
setTabTitle
(
aTab
)
{
var
browser
=
this
.
getBrowserForTab
(
aTab
)
;
var
title
=
browser
.
contentTitle
;
if
(
aTab
.
hasAttribute
(
"
customizemode
"
)
)
{
title
=
this
.
tabLocalization
.
formatValueSync
(
"
tabbrowser
-
customizemode
-
tab
-
title
"
)
;
}
if
(
aTab
.
_labelIsInitialTitle
)
{
if
(
!
title
)
{
return
false
;
}
delete
aTab
.
_labelIsInitialTitle
;
}
let
isURL
=
false
;
title
=
title
.
trim
(
)
;
if
(
this
.
_nonPrintingRegEx
.
test
(
title
)
)
{
title
=
"
"
;
}
let
isContentTitle
=
!
!
title
;
if
(
!
title
)
{
if
(
browser
.
currentURI
.
displaySpec
)
{
try
{
title
=
Services
.
io
.
createExposableURI
(
browser
.
currentURI
)
.
displaySpec
;
}
catch
(
ex
)
{
title
=
browser
.
currentURI
.
displaySpec
;
}
}
if
(
title
&
&
!
isBlankPageURL
(
title
)
)
{
isURL
=
true
;
if
(
title
.
length
<
=
500
|
|
!
this
.
_dataURLRegEx
.
test
(
title
)
)
{
try
{
let
characterSet
=
browser
.
characterSet
;
title
=
Services
.
textToSubURI
.
unEscapeNonAsciiURI
(
characterSet
title
)
;
}
catch
(
ex
)
{
}
}
}
else
{
title
=
this
.
tabContainer
.
emptyTabTitle
;
}
}
return
this
.
_setTabLabel
(
aTab
title
{
isContentTitle
isURL
}
)
;
}
setTabLabelForAuthPrompts
(
aTab
aLabel
)
{
return
this
.
_setTabLabel
(
aTab
aLabel
)
;
}
_setTabLabel
(
aTab
aLabel
{
beforeTabOpen
isContentTitle
isURL
}
=
{
}
)
{
if
(
!
aLabel
|
|
aLabel
.
includes
(
"
about
:
reader
?
"
)
)
{
return
false
;
}
if
(
isURL
&
&
aLabel
.
length
>
500
&
&
this
.
_dataURLRegEx
.
test
(
aLabel
)
)
{
aLabel
=
aLabel
.
substring
(
0
500
)
+
"
\
u2026
"
;
}
aTab
.
_fullLabel
=
aLabel
;
if
(
!
isContentTitle
)
{
if
(
!
(
"
_regex_shortenURLForTabLabel
"
in
this
)
)
{
this
.
_regex_shortenURLForTabLabel
=
/
^
[
^
:
]
+
:
\
/
\
/
(
?
:
www
\
.
)
?
/
;
}
aLabel
=
aLabel
.
replace
(
this
.
_regex_shortenURLForTabLabel
"
"
)
;
}
aTab
.
_labelIsContentTitle
=
isContentTitle
;
if
(
aTab
.
getAttribute
(
"
label
"
)
=
=
aLabel
)
{
return
false
;
}
let
dwu
=
window
.
windowUtils
;
let
isRTL
=
dwu
.
getDirectionFromText
(
aLabel
)
=
=
Ci
.
nsIDOMWindowUtils
.
DIRECTION_RTL
;
aTab
.
setAttribute
(
"
label
"
aLabel
)
;
aTab
.
setAttribute
(
"
labeldirection
"
isRTL
?
"
rtl
"
:
"
ltr
"
)
;
aTab
.
toggleAttribute
(
"
labelendaligned
"
isRTL
!
=
(
document
.
dir
=
=
"
rtl
"
)
)
;
if
(
!
beforeTabOpen
)
{
this
.
_tabAttrModified
(
aTab
[
"
label
"
]
)
;
}
if
(
aTab
.
selected
)
{
this
.
updateTitlebar
(
)
;
}
return
true
;
}
loadTabs
(
aURIs
{
allowInheritPrincipal
allowThirdPartyFixup
inBackground
newIndex
postDatas
replace
targetTab
triggeringPrincipal
csp
userContextId
fromExternal
}
=
{
}
)
{
if
(
!
aURIs
.
length
)
{
return
;
}
var
multiple
=
aURIs
.
length
>
1
;
var
owner
=
multiple
|
|
inBackground
?
null
:
this
.
selectedTab
;
var
firstTabAdded
=
null
;
var
targetTabIndex
=
-
1
;
if
(
typeof
newIndex
!
=
"
number
"
)
{
newIndex
=
-
1
;
}
if
(
multiple
&
&
newIndex
<
0
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
insertAfterCurrent
"
)
)
{
newIndex
=
this
.
selectedTab
.
_tPos
+
1
;
}
if
(
replace
)
{
let
browser
;
if
(
targetTab
)
{
browser
=
this
.
getBrowserForTab
(
targetTab
)
;
targetTabIndex
=
targetTab
.
_tPos
;
}
else
{
browser
=
this
.
selectedBrowser
;
targetTabIndex
=
this
.
tabContainer
.
selectedIndex
;
}
let
loadFlags
=
LOAD_FLAGS_NONE
;
if
(
allowThirdPartyFixup
)
{
loadFlags
|
=
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
|
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
;
}
if
(
!
allowInheritPrincipal
)
{
loadFlags
|
=
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
fromExternal
)
{
loadFlags
|
=
LOAD_FLAGS_FROM_EXTERNAL
;
}
try
{
browser
.
fixupAndLoadURIString
(
aURIs
[
0
]
{
loadFlags
postData
:
postDatas
&
&
postDatas
[
0
]
triggeringPrincipal
csp
}
)
;
}
catch
(
e
)
{
}
}
else
{
let
params
=
{
allowInheritPrincipal
ownerTab
:
owner
skipAnimation
:
multiple
allowThirdPartyFixup
postData
:
postDatas
&
&
postDatas
[
0
]
userContextId
triggeringPrincipal
bulkOrderedOpen
:
multiple
csp
fromExternal
}
;
if
(
newIndex
>
-
1
)
{
params
.
index
=
newIndex
;
}
firstTabAdded
=
this
.
addTab
(
aURIs
[
0
]
params
)
;
if
(
newIndex
>
-
1
)
{
targetTabIndex
=
firstTabAdded
.
_tPos
;
}
}
let
tabNum
=
targetTabIndex
;
for
(
let
i
=
1
;
i
<
aURIs
.
length
;
+
+
i
)
{
let
params
=
{
allowInheritPrincipal
skipAnimation
:
true
allowThirdPartyFixup
postData
:
postDatas
&
&
postDatas
[
i
]
userContextId
triggeringPrincipal
bulkOrderedOpen
:
true
csp
fromExternal
}
;
if
(
targetTabIndex
>
-
1
)
{
params
.
index
=
+
+
tabNum
;
}
this
.
addTab
(
aURIs
[
i
]
params
)
;
}
if
(
firstTabAdded
&
&
!
inBackground
)
{
this
.
selectedTab
=
firstTabAdded
;
}
}
updateBrowserRemoteness
(
aBrowser
{
newFrameloader
remoteType
}
=
{
}
)
{
let
isRemote
=
aBrowser
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
;
if
(
remoteType
=
=
=
undefined
)
{
throw
new
Error
(
"
Remote
type
must
be
set
!
"
)
;
}
let
shouldBeRemote
=
remoteType
!
=
=
E10SUtils
.
NOT_REMOTE
;
if
(
!
gMultiProcessBrowser
&
&
shouldBeRemote
)
{
throw
new
Error
(
"
Cannot
switch
to
remote
browser
in
a
window
"
+
"
without
the
remote
tabs
load
context
.
"
)
;
}
let
oldRemoteType
=
aBrowser
.
remoteType
;
if
(
isRemote
=
=
shouldBeRemote
&
&
!
newFrameloader
&
&
(
!
isRemote
|
|
oldRemoteType
=
=
remoteType
)
)
{
return
false
;
}
let
tab
=
this
.
getTabForBrowser
(
aBrowser
)
;
this
.
_insertBrowser
(
tab
)
;
let
evt
=
document
.
createEvent
(
"
Events
"
)
;
evt
.
initEvent
(
"
BeforeTabRemotenessChange
"
true
false
)
;
tab
.
dispatchEvent
(
evt
)
;
let
filter
=
this
.
_tabFilters
.
get
(
tab
)
;
let
listener
=
this
.
_tabListeners
.
get
(
tab
)
;
aBrowser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
let
oldDroppedLinkHandler
=
aBrowser
.
droppedLinkHandler
;
let
oldUserTypedValue
=
aBrowser
.
userTypedValue
;
let
hadStartedLoad
=
aBrowser
.
didStartLoadSinceLastUserTyping
(
)
;
aBrowser
.
destroy
(
)
;
if
(
shouldBeRemote
)
{
aBrowser
.
setAttribute
(
"
remote
"
"
true
"
)
;
aBrowser
.
setAttribute
(
"
remoteType
"
remoteType
)
;
}
else
{
aBrowser
.
setAttribute
(
"
remote
"
"
false
"
)
;
aBrowser
.
removeAttribute
(
"
remoteType
"
)
;
}
aBrowser
.
changeRemoteness
(
{
remoteType
}
)
;
aBrowser
.
construct
(
)
;
aBrowser
.
userTypedValue
=
oldUserTypedValue
;
if
(
hadStartedLoad
)
{
aBrowser
.
urlbarChangeTracker
.
startedLoad
(
)
;
}
aBrowser
.
droppedLinkHandler
=
oldDroppedLinkHandler
;
aBrowser
.
docShellIsActive
=
aBrowser
.
docShellIsActive
;
listener
=
new
TabProgressListener
(
tab
aBrowser
true
false
)
;
this
.
_tabListeners
.
set
(
tab
listener
)
;
filter
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
aBrowser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
let
securityUI
=
aBrowser
.
securityUI
;
let
state
=
securityUI
?
securityUI
.
state
:
Ci
.
nsIWebProgressListener
.
STATE_IS_INSECURE
;
this
.
_callProgressListeners
(
aBrowser
"
onSecurityChange
"
[
aBrowser
.
webProgress
null
state
]
true
false
)
;
let
event
=
aBrowser
.
getContentBlockingEvents
(
)
;
this
.
_callProgressListeners
(
aBrowser
"
onContentBlockingEvent
"
[
aBrowser
.
webProgress
null
event
true
]
true
false
)
;
if
(
shouldBeRemote
)
{
tab
.
removeAttribute
(
"
crashed
"
)
;
}
if
(
this
.
isFindBarInitialized
(
tab
)
)
{
this
.
getCachedFindBar
(
tab
)
.
browser
=
aBrowser
;
}
evt
=
document
.
createEvent
(
"
Events
"
)
;
evt
.
initEvent
(
"
TabRemotenessChange
"
true
false
)
;
tab
.
dispatchEvent
(
evt
)
;
return
true
;
}
updateBrowserRemotenessByURL
(
aBrowser
aURL
aOptions
=
{
}
)
{
if
(
!
gMultiProcessBrowser
)
{
return
this
.
updateBrowserRemoteness
(
aBrowser
{
remoteType
:
E10SUtils
.
NOT_REMOTE
}
)
;
}
let
oldRemoteType
=
aBrowser
.
remoteType
;
let
oa
=
E10SUtils
.
predictOriginAttributes
(
{
browser
:
aBrowser
}
)
;
aOptions
.
remoteType
=
E10SUtils
.
getRemoteTypeForURI
(
aURL
gMultiProcessBrowser
gFissionBrowser
oldRemoteType
aBrowser
.
currentURI
oa
)
;
if
(
oldRemoteType
!
=
aOptions
.
remoteType
|
|
aOptions
.
newFrameloader
)
{
return
this
.
updateBrowserRemoteness
(
aBrowser
aOptions
)
;
}
return
false
;
}
createBrowser
(
{
isPreloadBrowser
name
openWindowInfo
remoteType
initialBrowsingContextGroupId
uriIsAboutBlank
userContextId
skipLoad
}
=
{
}
)
{
let
b
=
document
.
createXULElement
(
"
browser
"
)
;
b
.
permanentKey
=
new
(
Cu
.
getGlobalForObject
(
Services
)
.
Object
)
(
)
;
const
defaultBrowserAttributes
=
{
contextmenu
:
"
contentAreaContextMenu
"
message
:
"
true
"
messagemanagergroup
:
"
browsers
"
tooltip
:
"
aHTMLTooltip
"
type
:
"
content
"
manualactiveness
:
"
true
"
}
;
for
(
let
attribute
in
defaultBrowserAttributes
)
{
b
.
setAttribute
(
attribute
defaultBrowserAttributes
[
attribute
]
)
;
}
if
(
gMultiProcessBrowser
|
|
remoteType
)
{
b
.
setAttribute
(
"
maychangeremoteness
"
"
true
"
)
;
}
if
(
userContextId
)
{
b
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
}
if
(
remoteType
)
{
b
.
setAttribute
(
"
remoteType
"
remoteType
)
;
b
.
setAttribute
(
"
remote
"
"
true
"
)
;
}
if
(
!
isPreloadBrowser
)
{
b
.
setAttribute
(
"
autocompletepopup
"
"
PopupAutoComplete
"
)
;
}
if
(
isPreloadBrowser
)
{
b
.
setAttribute
(
"
preloadedState
"
"
preloaded
"
)
;
}
if
(
initialBrowsingContextGroupId
)
{
b
.
setAttribute
(
"
initialBrowsingContextGroupId
"
initialBrowsingContextGroupId
)
;
}
if
(
openWindowInfo
)
{
b
.
openWindowInfo
=
openWindowInfo
;
}
if
(
name
)
{
b
.
setAttribute
(
"
name
"
name
)
;
}
if
(
this
.
_allowTransparentBrowser
)
{
b
.
setAttribute
(
"
transparent
"
"
true
"
)
;
}
let
stack
=
document
.
createXULElement
(
"
stack
"
)
;
stack
.
className
=
"
browserStack
"
;
stack
.
appendChild
(
b
)
;
let
browserContainer
=
document
.
createXULElement
(
"
vbox
"
)
;
browserContainer
.
className
=
"
browserContainer
"
;
browserContainer
.
appendChild
(
stack
)
;
let
browserSidebarContainer
=
document
.
createXULElement
(
"
hbox
"
)
;
browserSidebarContainer
.
className
=
"
browserSidebarContainer
"
;
browserSidebarContainer
.
appendChild
(
browserContainer
)
;
let
visibility
=
Services
.
prefs
.
getStringPref
(
"
sidebar
.
visibility
"
"
always
-
show
"
)
;
let
expandOnHover
=
Services
.
prefs
.
getBoolPref
(
"
sidebar
.
expandOnHover
"
false
)
;
if
(
visibility
=
=
=
"
expand
-
on
-
hover
"
&
&
expandOnHover
)
{
SidebarController
.
toggleExpandOnHover
(
true
)
;
}
if
(
!
uriIsAboutBlank
|
|
skipLoad
)
{
b
.
setAttribute
(
"
nodefaultsrc
"
"
true
"
)
;
}
return
b
;
}
_createLazyBrowser
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
let
names
=
this
.
_browserBindingProperties
;
for
(
let
i
=
0
;
i
<
names
.
length
;
i
+
+
)
{
let
name
=
names
[
i
]
;
let
getter
;
let
setter
;
switch
(
name
)
{
case
"
audioMuted
"
:
getter
=
(
)
=
>
aTab
.
hasAttribute
(
"
muted
"
)
;
break
;
case
"
contentTitle
"
:
getter
=
(
)
=
>
SessionStore
.
getLazyTabValue
(
aTab
"
title
"
)
;
break
;
case
"
currentURI
"
:
getter
=
(
)
=
>
{
if
(
browser
.
_cachedCurrentURI
)
{
return
browser
.
_cachedCurrentURI
;
}
let
url
=
SessionStore
.
getLazyTabValue
(
aTab
"
url
"
)
|
|
"
about
:
blank
"
;
return
(
browser
.
_cachedCurrentURI
=
Services
.
io
.
newURI
(
url
)
)
;
}
;
break
;
case
"
didStartLoadSinceLastUserTyping
"
:
getter
=
(
)
=
>
(
)
=
>
false
;
break
;
case
"
fullZoom
"
:
case
"
textZoom
"
:
getter
=
(
)
=
>
1
;
break
;
case
"
tabHasCustomZoom
"
:
getter
=
(
)
=
>
false
;
break
;
case
"
getTabBrowser
"
:
getter
=
(
)
=
>
(
)
=
>
this
;
break
;
case
"
isRemoteBrowser
"
:
getter
=
(
)
=
>
browser
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
;
break
;
case
"
permitUnload
"
:
getter
=
(
)
=
>
(
)
=
>
(
{
permitUnload
:
true
}
)
;
break
;
case
"
reload
"
:
case
"
reloadWithFlags
"
:
getter
=
(
)
=
>
params
=
>
{
aTab
.
addEventListener
(
"
SSTabRestoring
"
(
)
=
>
{
browser
[
name
]
(
params
)
;
}
{
once
:
true
}
)
;
gBrowser
.
_insertBrowser
(
aTab
)
;
}
;
break
;
case
"
remoteType
"
:
getter
=
(
)
=
>
{
let
url
=
SessionStore
.
getLazyTabValue
(
aTab
"
url
"
)
|
|
"
about
:
blank
"
;
let
uri
;
if
(
browser
.
_cachedCurrentURI
)
{
uri
=
browser
.
_cachedCurrentURI
;
}
else
{
uri
=
browser
.
_cachedCurrentURI
=
Services
.
io
.
newURI
(
url
)
;
}
let
oa
=
E10SUtils
.
predictOriginAttributes
(
{
browser
userContextId
:
aTab
.
getAttribute
(
"
usercontextid
"
)
}
)
;
return
E10SUtils
.
getRemoteTypeForURI
(
url
gMultiProcessBrowser
gFissionBrowser
undefined
uri
oa
)
;
}
;
break
;
case
"
userTypedValue
"
:
case
"
userTypedClear
"
:
getter
=
(
)
=
>
SessionStore
.
getLazyTabValue
(
aTab
name
)
;
break
;
default
:
getter
=
(
)
=
>
{
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
let
message
=
[
bug
1345098
]
Lazy
browser
prematurely
inserted
via
'
{
name
}
'
property
access
:
\
n
;
Services
.
console
.
logStringMessage
(
message
+
new
Error
(
)
.
stack
)
;
}
this
.
_insertBrowser
(
aTab
)
;
return
browser
[
name
]
;
}
;
setter
=
value
=
>
{
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
let
message
=
[
bug
1345098
]
Lazy
browser
prematurely
inserted
via
'
{
name
}
'
property
access
:
\
n
;
Services
.
console
.
logStringMessage
(
message
+
new
Error
(
)
.
stack
)
;
}
this
.
_insertBrowser
(
aTab
)
;
return
(
browser
[
name
]
=
value
)
;
}
;
}
Object
.
defineProperty
(
browser
name
{
get
:
getter
set
:
setter
configurable
:
true
enumerable
:
true
}
)
;
}
}
_insertBrowser
(
aTab
aInsertedOnTabCreation
)
{
"
use
strict
"
;
if
(
aTab
.
linkedPanel
|
|
window
.
closed
)
{
return
;
}
let
browser
=
aTab
.
linkedBrowser
;
if
(
this
.
_browserBindingProperties
[
0
]
in
browser
)
{
for
(
let
name
of
this
.
_browserBindingProperties
)
{
delete
browser
[
name
]
;
}
}
let
{
uriIsAboutBlank
usingPreloadedContent
}
=
aTab
.
_browserParams
;
delete
aTab
.
_browserParams
;
delete
browser
.
_cachedCurrentURI
;
let
panel
=
this
.
getPanel
(
browser
)
;
let
uniqueId
=
this
.
_generateUniquePanelID
(
)
;
panel
.
id
=
uniqueId
;
aTab
.
linkedPanel
=
uniqueId
;
if
(
!
panel
.
parentNode
)
{
this
.
tabpanels
.
appendChild
(
panel
)
;
}
let
tabListener
=
new
TabProgressListener
(
aTab
browser
uriIsAboutBlank
usingPreloadedContent
)
;
const
filter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
filter
.
addProgressListener
(
tabListener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
browser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
this
.
_tabListeners
.
set
(
aTab
tabListener
)
;
this
.
_tabFilters
.
set
(
aTab
filter
)
;
browser
.
droppedLinkHandler
=
handleDroppedLink
;
browser
.
loadURI
=
URILoadingWrapper
.
loadURI
.
bind
(
URILoadingWrapper
browser
)
;
browser
.
fixupAndLoadURIString
=
URILoadingWrapper
.
fixupAndLoadURIString
.
bind
(
URILoadingWrapper
browser
)
;
if
(
!
usingPreloadedContent
)
{
browser
.
docShellIsActive
=
false
;
}
if
(
this
.
tabs
.
length
=
=
2
)
{
this
.
tabs
[
0
]
.
linkedBrowser
.
browsingContext
.
hasSiblings
=
true
;
this
.
tabs
[
1
]
.
linkedBrowser
.
browsingContext
.
hasSiblings
=
true
;
}
else
{
aTab
.
linkedBrowser
.
browsingContext
.
hasSiblings
=
this
.
tabs
.
length
>
1
;
}
if
(
aTab
.
userContextId
)
{
browser
.
setAttribute
(
"
usercontextid
"
aTab
.
userContextId
)
;
}
browser
.
browsingContext
.
isAppTab
=
aTab
.
pinned
;
if
(
aTab
.
selected
)
{
updateUserContextUIIndicator
(
)
;
}
if
(
aTab
.
isConnected
)
{
var
evt
=
new
CustomEvent
(
"
TabBrowserInserted
"
{
bubbles
:
true
detail
:
{
insertedOnTabCreation
:
aInsertedOnTabCreation
}
}
)
;
aTab
.
dispatchEvent
(
evt
)
;
}
}
_mayDiscardBrowser
(
aTab
aForceDiscard
)
{
let
browser
=
aTab
.
linkedBrowser
;
let
action
=
aForceDiscard
?
"
unload
"
:
"
dontUnload
"
;
if
(
!
aTab
|
|
aTab
.
selected
|
|
aTab
.
closing
|
|
this
.
_windowIsClosing
|
|
!
browser
.
isConnected
|
|
!
browser
.
isRemoteBrowser
|
|
!
browser
.
permitUnload
(
action
)
.
permitUnload
)
{
return
false
;
}
return
true
;
}
discardBrowser
(
aTab
aForceDiscard
)
{
"
use
strict
"
;
let
browser
=
aTab
.
linkedBrowser
;
if
(
!
this
.
_mayDiscardBrowser
(
aTab
aForceDiscard
)
)
{
return
false
;
}
if
(
aTab
.
_sharingState
)
{
this
.
resetBrowserSharing
(
browser
)
;
}
webrtcUI
.
forgetStreamsFromBrowserContext
(
browser
.
browsingContext
)
;
aTab
.
_browserParams
=
{
uriIsAboutBlank
:
browser
.
currentURI
.
spec
=
=
"
about
:
blank
"
remoteType
:
browser
.
remoteType
usingPreloadedContent
:
false
}
;
SessionStore
.
resetBrowserToLazyState
(
aTab
)
;
let
filter
=
this
.
_tabFilters
.
get
(
aTab
)
;
let
listener
=
this
.
_tabListeners
.
get
(
aTab
)
;
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
this
.
_tabListeners
.
delete
(
aTab
)
;
this
.
_tabFilters
.
delete
(
aTab
)
;
if
(
aTab
.
_findBar
)
{
aTab
.
_findBar
.
close
(
true
)
;
aTab
.
_findBar
.
remove
(
)
;
delete
aTab
.
_findBar
;
}
let
attributesToRemove
=
[
"
activemedia
-
blocked
"
"
busy
"
"
pendingicon
"
"
progress
"
"
soundplaying
"
]
;
let
removedAttributes
=
[
]
;
for
(
let
attr
of
attributesToRemove
)
{
if
(
aTab
.
hasAttribute
(
attr
)
)
{
removedAttributes
.
push
(
attr
)
;
aTab
.
removeAttribute
(
attr
)
;
}
}
if
(
removedAttributes
.
length
)
{
this
.
_tabAttrModified
(
aTab
removedAttributes
)
;
}
browser
.
destroy
(
)
;
this
.
getPanel
(
browser
)
.
remove
(
)
;
aTab
.
removeAttribute
(
"
linkedpanel
"
)
;
this
.
_createLazyBrowser
(
aTab
)
;
let
evt
=
new
CustomEvent
(
"
TabBrowserDiscarded
"
{
bubbles
:
true
}
)
;
aTab
.
dispatchEvent
(
evt
)
;
return
true
;
}
addWebTab
(
aURI
params
=
{
}
)
{
if
(
!
params
.
triggeringPrincipal
)
{
params
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
:
params
.
userContextId
}
)
;
}
if
(
params
.
triggeringPrincipal
.
isSystemPrincipal
)
{
throw
new
Error
(
"
System
principal
should
never
be
passed
into
addWebTab
(
)
"
)
;
}
return
this
.
addTab
(
aURI
params
)
;
}
addAdjacentNewTab
(
tab
)
{
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
new
Promise
(
resolve
=
>
{
this
.
selectedTab
=
this
.
addTrustedTab
(
BROWSER_NEW_TAB_URL
{
index
:
tab
.
_tPos
+
1
userContextId
:
tab
.
userContextId
tabGroup
:
tab
.
group
}
)
;
resolve
(
this
.
selectedBrowser
)
;
}
)
}
"
browser
-
open
-
newtab
-
start
"
)
;
}
addTrustedTab
(
aURI
options
=
{
}
)
{
options
.
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
return
this
.
addTab
(
aURI
options
)
;
}
addTab
(
uriString
{
allowInheritPrincipal
allowThirdPartyFixup
bulkOrderedOpen
charset
createLazyBrowser
disableTRR
eventDetail
focusUrlBar
forceNotRemote
forceAllowDataURI
fromExternal
inBackground
=
true
index
lazyTabTitle
name
noInitialLabel
openWindowInfo
openerBrowser
originPrincipal
originStoragePrincipal
ownerTab
pinned
postData
preferredRemoteType
referrerInfo
relatedToCurrent
initialBrowsingContextGroupId
skipAnimation
skipBackgroundNotify
tabGroup
triggeringPrincipal
userContextId
csp
skipLoad
=
createLazyBrowser
insertTab
=
true
globalHistoryOptions
triggeringRemoteType
schemelessInput
hasValidUserGestureActivation
=
false
textDirectiveUserActivation
=
false
}
=
{
}
)
{
if
(
!
triggeringPrincipal
)
{
throw
new
Error
(
"
Required
argument
triggeringPrincipal
missing
within
addTab
"
)
;
}
if
(
!
UserInteraction
.
running
(
"
browser
.
tabs
.
opening
"
window
)
)
{
UserInteraction
.
start
(
"
browser
.
tabs
.
opening
"
"
initting
"
window
)
;
}
ownerTab
?
?
=
inBackground
?
null
:
this
.
selectedTab
;
if
(
this
.
selectedTab
.
owner
)
{
this
.
selectedTab
.
owner
=
null
;
}
if
(
relatedToCurrent
=
=
null
)
{
relatedToCurrent
=
!
!
(
referrerInfo
&
&
referrerInfo
.
originalReferrer
)
;
}
let
openerTab
=
(
openerBrowser
&
&
this
.
getTabForBrowser
(
openerBrowser
)
)
|
|
(
relatedToCurrent
&
&
this
.
selectedTab
)
|
|
null
;
let
animate
=
!
skipAnimation
&
&
!
pinned
&
&
!
this
.
tabContainer
.
verticalMode
&
&
!
this
.
tabContainer
.
overflowing
&
&
!
gReduceMotion
;
let
uriInfo
=
this
.
_determineURIToLoad
(
uriString
createLazyBrowser
)
;
let
{
uri
uriIsAboutBlank
lazyBrowserURI
}
=
uriInfo
;
(
{
uriString
}
=
uriInfo
)
;
let
usingPreloadedContent
=
false
;
let
b
t
;
try
{
t
=
this
.
_createTab
(
{
uriString
animate
userContextId
openerTab
pinned
noInitialLabel
skipBackgroundNotify
}
)
;
if
(
insertTab
)
{
this
.
_insertTabAtIndex
(
t
{
index
ownerTab
openerTab
pinned
bulkOrderedOpen
tabGroup
:
tabGroup
?
?
openerTab
?
.
group
}
)
;
}
(
{
browser
:
b
usingPreloadedContent
}
=
this
.
_createBrowserForTab
(
t
{
uriString
uri
preferredRemoteType
openerBrowser
uriIsAboutBlank
referrerInfo
forceNotRemote
name
initialBrowsingContextGroupId
openWindowInfo
skipLoad
}
)
)
;
if
(
focusUrlBar
)
{
gURLBar
.
getBrowserState
(
b
)
.
urlbarFocused
=
true
;
}
if
(
createLazyBrowser
)
{
this
.
_createLazyBrowser
(
t
)
;
if
(
lazyBrowserURI
)
{
this
.
UrlbarProviderOpenTabs
.
registerOpenTab
(
lazyBrowserURI
.
spec
t
.
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
b
.
registeredOpenURI
=
lazyBrowserURI
;
}
if
(
insertTab
)
{
SessionStore
.
setTabState
(
t
{
entries
:
[
{
url
:
lazyBrowserURI
?
.
spec
|
|
"
about
:
blank
"
title
:
lazyTabTitle
triggeringPrincipal_base64
:
E10SUtils
.
serializePrincipal
(
triggeringPrincipal
)
}
]
userContextId
}
)
;
}
}
else
{
this
.
_insertBrowser
(
t
true
)
;
if
(
openerBrowser
&
&
!
openWindowInfo
)
{
b
.
browsingContext
.
crossGroupOpener
=
openerBrowser
.
browsingContext
;
}
}
}
catch
(
e
)
{
console
.
error
(
"
Failed
to
create
tab
"
)
;
console
.
error
(
e
)
;
t
?
.
remove
(
)
;
if
(
t
?
.
linkedBrowser
)
{
this
.
_tabFilters
.
delete
(
t
)
;
this
.
_tabListeners
.
delete
(
t
)
;
this
.
getPanel
(
t
.
linkedBrowser
)
.
remove
(
)
;
}
return
null
;
}
if
(
insertTab
)
{
this
.
_fireTabOpen
(
t
eventDetail
)
;
this
.
_kickOffBrowserLoad
(
b
{
uri
uriString
usingPreloadedContent
triggeringPrincipal
originPrincipal
originStoragePrincipal
uriIsAboutBlank
allowInheritPrincipal
allowThirdPartyFixup
fromExternal
disableTRR
forceAllowDataURI
skipLoad
referrerInfo
charset
postData
csp
globalHistoryOptions
triggeringRemoteType
schemelessInput
hasValidUserGestureActivation
:
hasValidUserGestureActivation
|
|
!
!
openWindowInfo
?
.
hasValidUserGestureActivation
textDirectiveUserActivation
:
textDirectiveUserActivation
|
|
!
!
openWindowInfo
?
.
textDirectiveUserActivation
}
)
;
}
this
.
tabAnimationsInProgress
+
+
;
if
(
animate
)
{
if
(
usingPreloadedContent
)
{
requestAnimationFrame
(
(
)
=
>
{
requestAnimationFrame
(
(
)
=
>
{
t
.
setAttribute
(
"
fadein
"
"
true
"
)
;
}
)
;
}
)
;
}
else
{
requestAnimationFrame
(
(
)
=
>
{
t
.
setAttribute
(
"
fadein
"
"
true
"
)
;
}
)
;
}
}
if
(
pinned
)
{
this
.
_notifyPinnedStatus
(
t
)
;
}
gSharedTabWarning
.
tabAdded
(
t
)
;
if
(
!
inBackground
)
{
this
.
selectedTab
=
t
;
}
return
t
;
}
_createTabGroup
(
id
color
collapsed
label
=
"
"
)
{
let
group
=
document
.
createXULElement
(
"
tab
-
group
"
{
is
:
"
tab
-
group
"
}
)
;
group
.
id
=
id
;
group
.
collapsed
=
collapsed
;
group
.
color
=
color
;
group
.
label
=
label
;
return
group
;
}
addTabGroup
(
tabs
{
id
=
null
color
=
null
label
=
"
"
insertBefore
=
null
showCreateUI
=
false
}
=
{
}
)
{
if
(
!
tabs
?
.
length
)
{
throw
new
Error
(
"
Cannot
create
tab
group
with
zero
tabs
"
)
;
}
if
(
!
color
)
{
color
=
this
.
tabGroupMenu
.
nextUnusedColor
;
}
if
(
!
id
)
{
id
=
{
Date
.
now
(
)
}
-
{
Math
.
round
(
Math
.
random
(
)
*
100
)
}
;
}
let
group
=
this
.
_createTabGroup
(
id
color
false
label
)
;
this
.
tabContainer
.
insertBefore
(
group
insertBefore
?
.
group
?
?
insertBefore
)
;
group
.
addTabs
(
tabs
)
;
if
(
!
group
.
tabs
.
length
)
{
group
.
remove
(
)
;
return
null
;
}
group
.
dispatchEvent
(
new
CustomEvent
(
"
TabGroupCreate
"
{
bubbles
:
true
detail
:
{
showCreateUI
}
}
)
)
;
return
group
;
}
removeTabGroup
(
group
options
=
{
}
)
{
if
(
this
.
tabGroupMenu
.
panel
.
state
!
=
"
closed
"
)
{
this
.
tabGroupMenu
.
panel
.
hidePopup
(
options
.
animate
)
;
}
group
.
dispatchEvent
(
new
CustomEvent
(
"
TabGroupRemoveRequested
"
{
bubbles
:
true
}
)
)
;
options
.
skipSessionStore
=
true
;
this
.
removeTabs
(
group
.
tabs
options
)
;
}
ungroupTab
(
tab
)
{
if
(
!
tab
.
group
)
{
return
;
}
this
.
_handleTabMove
(
tab
(
)
=
>
gBrowser
.
tabContainer
.
insertBefore
(
tab
tab
.
group
.
nextElementSibling
)
)
;
}
adoptTabGroup
(
group
index
)
{
if
(
group
.
ownerDocument
=
=
document
)
{
return
group
;
}
let
newTabs
=
[
]
;
for
(
let
tab
of
group
.
tabs
)
{
newTabs
.
push
(
this
.
adoptTab
(
tab
index
)
)
;
}
return
this
.
addTabGroup
(
newTabs
{
id
:
group
.
id
label
:
group
.
label
color
:
group
.
color
}
)
;
}
getAllTabGroups
(
)
{
return
BrowserWindowTracker
.
getOrderedWindows
(
{
private
:
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
}
)
.
reduce
(
(
acc
thisWindow
)
=
>
acc
.
concat
(
thisWindow
.
gBrowser
.
tabGroups
)
[
]
)
;
}
getTabGroupById
(
id
)
{
for
(
const
win
of
BrowserWindowTracker
.
getOrderedWindows
(
{
private
:
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
}
)
)
{
for
(
const
group
of
win
.
gBrowser
.
tabGroups
)
{
if
(
group
.
id
=
=
=
id
)
{
return
group
;
}
}
}
return
null
;
}
_determineURIToLoad
(
uriString
createLazyBrowser
)
{
uriString
=
uriString
|
|
"
about
:
blank
"
;
let
aURIObject
=
null
;
try
{
aURIObject
=
Services
.
io
.
newURI
(
uriString
)
;
}
catch
(
ex
)
{
}
let
lazyBrowserURI
;
if
(
createLazyBrowser
&
&
uriString
!
=
"
about
:
blank
"
)
{
lazyBrowserURI
=
aURIObject
;
uriString
=
"
about
:
blank
"
;
}
let
uriIsAboutBlank
=
uriString
=
=
"
about
:
blank
"
;
return
{
uri
:
aURIObject
uriIsAboutBlank
lazyBrowserURI
uriString
}
;
}
_createTab
(
{
uriString
userContextId
openerTab
pinned
noInitialLabel
skipBackgroundNotify
animate
}
)
{
var
t
=
document
.
createXULElement
(
"
tab
"
{
is
:
"
tabbrowser
-
tab
"
}
)
;
t
.
initializingTab
=
true
;
t
.
openerTab
=
openerTab
;
if
(
userContextId
=
=
null
&
&
openerTab
)
{
userContextId
=
openerTab
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
}
if
(
!
noInitialLabel
)
{
if
(
isBlankPageURL
(
uriString
)
)
{
t
.
setAttribute
(
"
label
"
this
.
tabContainer
.
emptyTabTitle
)
;
}
else
{
this
.
setInitialTabTitle
(
t
uriString
{
beforeTabOpen
:
true
isURL
:
true
}
)
;
}
}
if
(
userContextId
)
{
t
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
ContextualIdentityService
.
setTabStyle
(
t
)
;
}
if
(
skipBackgroundNotify
)
{
t
.
setAttribute
(
"
skipbackgroundnotify
"
true
)
;
}
if
(
pinned
)
{
t
.
setAttribute
(
"
pinned
"
"
true
"
)
;
}
t
.
classList
.
add
(
"
tabbrowser
-
tab
"
)
;
this
.
tabContainer
.
_unlockTabSizing
(
)
;
if
(
!
animate
)
{
UserInteraction
.
update
(
"
browser
.
tabs
.
opening
"
"
not
-
animated
"
window
)
;
t
.
setAttribute
(
"
fadein
"
"
true
"
)
;
setTimeout
(
function
(
tabContainer
)
{
tabContainer
.
_handleNewTab
(
t
)
;
}
0
this
.
tabContainer
)
;
}
else
{
UserInteraction
.
update
(
"
browser
.
tabs
.
opening
"
"
animated
"
window
)
;
}
return
t
;
}
_createBrowserForTab
(
tab
{
uriString
uri
name
preferredRemoteType
openerBrowser
uriIsAboutBlank
referrerInfo
forceNotRemote
initialBrowsingContextGroupId
openWindowInfo
skipLoad
}
)
{
if
(
!
preferredRemoteType
&
&
openerBrowser
)
{
preferredRemoteType
=
openerBrowser
.
remoteType
;
}
let
{
userContextId
}
=
tab
;
var
oa
=
E10SUtils
.
predictOriginAttributes
(
{
window
userContextId
}
)
;
if
(
uriIsAboutBlank
&
&
!
preferredRemoteType
&
&
referrerInfo
&
&
referrerInfo
.
originalReferrer
)
{
preferredRemoteType
=
E10SUtils
.
getRemoteTypeForURI
(
referrerInfo
.
originalReferrer
.
spec
gMultiProcessBrowser
gFissionBrowser
E10SUtils
.
DEFAULT_REMOTE_TYPE
null
oa
)
;
}
let
remoteType
=
forceNotRemote
?
E10SUtils
.
NOT_REMOTE
:
E10SUtils
.
getRemoteTypeForURI
(
uriString
gMultiProcessBrowser
gFissionBrowser
preferredRemoteType
null
oa
)
;
let
b
usingPreloadedContent
=
false
;
if
(
uriString
=
=
BROWSER_NEW_TAB_URL
&
&
!
userContextId
)
{
b
=
NewTabPagePreloading
.
getPreloadedBrowser
(
window
)
;
if
(
b
)
{
usingPreloadedContent
=
true
;
}
}
if
(
!
b
)
{
b
=
this
.
createBrowser
(
{
remoteType
uriIsAboutBlank
userContextId
initialBrowsingContextGroupId
openWindowInfo
name
skipLoad
}
)
;
}
tab
.
linkedBrowser
=
b
;
this
.
_tabForBrowser
.
set
(
b
tab
)
;
tab
.
permanentKey
=
b
.
permanentKey
;
tab
.
_browserParams
=
{
uriIsAboutBlank
remoteType
usingPreloadedContent
}
;
this
.
setDefaultIcon
(
tab
uri
)
;
return
{
browser
:
b
usingPreloadedContent
}
;
}
_kickOffBrowserLoad
(
browser
{
uri
uriString
usingPreloadedContent
triggeringPrincipal
originPrincipal
originStoragePrincipal
uriIsAboutBlank
allowInheritPrincipal
allowThirdPartyFixup
fromExternal
disableTRR
forceAllowDataURI
skipLoad
referrerInfo
charset
postData
csp
globalHistoryOptions
triggeringRemoteType
schemelessInput
hasValidUserGestureActivation
textDirectiveUserActivation
}
)
{
if
(
!
usingPreloadedContent
&
&
originPrincipal
&
&
originStoragePrincipal
&
&
uriString
)
{
let
{
URI_INHERITS_SECURITY_CONTEXT
}
=
Ci
.
nsIProtocolHandler
;
if
(
!
uri
|
|
doGetProtocolFlags
(
uri
)
&
URI_INHERITS_SECURITY_CONTEXT
)
{
browser
.
createAboutBlankDocumentViewer
(
originPrincipal
originStoragePrincipal
)
;
}
}
if
(
!
usingPreloadedContent
&
&
(
!
uriIsAboutBlank
|
|
!
allowInheritPrincipal
)
&
&
!
skipLoad
)
{
if
(
uriString
&
&
!
gInitialPages
.
includes
(
uriString
)
)
{
browser
.
userTypedValue
=
uriString
;
}
let
loadFlags
=
LOAD_FLAGS_NONE
;
if
(
allowThirdPartyFixup
)
{
loadFlags
|
=
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
|
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
;
}
if
(
fromExternal
)
{
loadFlags
|
=
LOAD_FLAGS_FROM_EXTERNAL
;
}
else
if
(
!
triggeringPrincipal
.
isSystemPrincipal
)
{
loadFlags
|
=
LOAD_FLAGS_FIRST_LOAD
;
}
if
(
!
allowInheritPrincipal
)
{
loadFlags
|
=
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
if
(
disableTRR
)
{
loadFlags
|
=
LOAD_FLAGS_DISABLE_TRR
;
}
if
(
forceAllowDataURI
)
{
loadFlags
|
=
LOAD_FLAGS_FORCE_ALLOW_DATA_URI
;
}
try
{
browser
.
fixupAndLoadURIString
(
uriString
{
loadFlags
triggeringPrincipal
referrerInfo
charset
postData
csp
globalHistoryOptions
triggeringRemoteType
schemelessInput
hasValidUserGestureActivation
textDirectiveUserActivation
}
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
}
createTabsForSessionRestore
(
restoreTabsLazily
selectTab
tabDataList
tabGroupDataList
)
{
let
tabs
=
[
]
;
let
tabsFragment
=
document
.
createDocumentFragment
(
)
;
let
tabToSelect
=
null
;
let
hiddenTabs
=
new
Map
(
)
;
let
shouldUpdateForPinnedTabs
=
false
;
let
tabGroupWorkingData
=
new
Map
(
)
;
for
(
const
tabGroupData
of
tabGroupDataList
)
{
tabGroupWorkingData
.
set
(
tabGroupData
.
id
{
stateData
:
tabGroupData
node
:
undefined
containingTabsFragment
:
document
.
createDocumentFragment
(
)
}
)
;
}
for
(
var
i
=
0
;
i
<
tabDataList
.
length
;
i
+
+
)
{
let
tabData
=
tabDataList
[
i
]
;
let
userContextId
=
tabData
.
userContextId
;
let
select
=
i
=
=
selectTab
-
1
;
let
tab
;
let
tabWasReused
=
false
;
if
(
select
&
&
this
.
selectedTab
.
userContextId
=
=
userContextId
&
&
!
SessionStore
.
isTabRestoring
(
this
.
selectedTab
)
&
&
!
this
.
tabContainer
.
verticalMode
)
{
tabWasReused
=
true
;
tab
=
this
.
selectedTab
;
if
(
!
tabData
.
pinned
)
{
this
.
unpinTab
(
tab
)
;
}
else
{
this
.
pinTab
(
tab
)
;
}
}
if
(
!
tab
)
{
let
createLazyBrowser
=
restoreTabsLazily
&
&
!
select
&
&
!
tabData
.
pinned
;
let
url
=
"
about
:
blank
"
;
if
(
tabData
.
entries
?
.
length
)
{
let
activeIndex
=
(
tabData
.
index
|
|
tabData
.
entries
.
length
)
-
1
;
activeIndex
=
Math
.
min
(
activeIndex
tabData
.
entries
.
length
-
1
)
;
activeIndex
=
Math
.
max
(
activeIndex
0
)
;
url
=
tabData
.
entries
[
activeIndex
]
.
url
;
}
let
preferredRemoteType
=
E10SUtils
.
getRemoteTypeForURI
(
url
gMultiProcessBrowser
gFissionBrowser
E10SUtils
.
DEFAULT_REMOTE_TYPE
null
E10SUtils
.
predictOriginAttributes
(
{
window
userContextId
}
)
)
;
tab
=
this
.
addTrustedTab
(
createLazyBrowser
?
url
:
"
about
:
blank
"
{
createLazyBrowser
skipAnimation
:
true
noInitialLabel
:
true
userContextId
skipBackgroundNotify
:
true
bulkOrderedOpen
:
true
insertTab
:
false
skipLoad
:
true
preferredRemoteType
}
)
;
if
(
select
)
{
tabToSelect
=
tab
;
}
}
tabs
.
push
(
tab
)
;
if
(
tabData
.
pinned
)
{
if
(
!
tab
.
parentNode
)
{
tab
.
_tPos
=
this
.
pinnedTabCount
;
this
.
tabContainer
.
insertBefore
(
tab
this
.
tabs
[
this
.
pinnedTabCount
]
)
;
tab
.
toggleAttribute
(
"
pinned
"
true
)
;
this
.
tabContainer
.
_invalidateCachedTabs
(
)
;
this
.
_fireTabOpen
(
tab
{
}
)
;
this
.
_notifyPinnedStatus
(
tab
)
;
shouldUpdateForPinnedTabs
=
true
;
}
}
else
if
(
tabData
.
groupId
)
{
let
{
groupId
}
=
tabData
;
const
tabGroup
=
tabGroupWorkingData
.
get
(
groupId
)
;
if
(
tabGroup
)
{
tabGroup
.
containingTabsFragment
.
appendChild
(
tab
)
;
if
(
!
tabGroup
.
node
)
{
tabGroup
.
node
=
this
.
_createTabGroup
(
tabGroup
.
stateData
.
id
tabGroup
.
stateData
.
color
tabGroup
.
stateData
.
collapsed
tabGroup
.
stateData
.
name
)
;
tabsFragment
.
appendChild
(
tabGroup
.
node
)
;
}
}
}
else
{
if
(
tab
.
hidden
)
{
tab
.
hidden
=
true
;
hiddenTabs
.
set
(
tab
tabData
.
extData
&
&
tabData
.
extData
.
hiddenBy
)
;
}
tabsFragment
.
appendChild
(
tab
)
;
if
(
tabWasReused
)
{
this
.
tabContainer
.
_invalidateCachedTabs
(
)
;
}
}
tab
.
initialize
(
)
;
}
this
.
tabContainer
.
appendChild
(
tabsFragment
)
;
for
(
const
tabGroup
of
tabGroupWorkingData
.
values
(
)
)
{
if
(
tabGroup
.
node
)
{
tabGroup
.
node
.
appendChild
(
tabGroup
.
containingTabsFragment
)
;
}
}
for
(
let
[
tab
hiddenBy
]
of
hiddenTabs
)
{
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
TabHide
"
true
false
)
;
tab
.
dispatchEvent
(
event
)
;
if
(
hiddenBy
)
{
SessionStore
.
setCustomTabValue
(
tab
"
hiddenBy
"
hiddenBy
)
;
}
}
this
.
tabContainer
.
_invalidateCachedTabs
(
)
;
if
(
shouldUpdateForPinnedTabs
)
{
this
.
_updateTabBarForPinnedTabs
(
)
;
}
if
(
tabToSelect
)
{
let
leftoverTab
=
this
.
selectedTab
;
this
.
selectedTab
=
tabToSelect
;
this
.
removeTab
(
leftoverTab
)
;
}
if
(
tabs
.
length
>
1
|
|
!
tabs
[
0
]
.
selected
)
{
this
.
_updateTabsAfterInsert
(
)
;
TabBarVisibility
.
update
(
)
;
for
(
let
tab
of
tabs
)
{
if
(
tabToSelect
|
|
!
tab
.
selected
)
{
if
(
!
tab
.
pinned
)
{
this
.
_fireTabOpen
(
tab
{
}
)
;
}
if
(
tab
.
linkedPanel
)
{
var
evt
=
new
CustomEvent
(
"
TabBrowserInserted
"
{
bubbles
:
true
detail
:
{
insertedOnTabCreation
:
true
}
}
)
;
tab
.
dispatchEvent
(
evt
)
;
}
}
}
}
return
tabs
;
}
moveTabsToStart
(
contextTab
)
{
let
tabs
=
contextTab
.
multiselected
?
this
.
selectedTabs
:
[
contextTab
]
;
for
(
let
i
=
tabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
moveTabToStart
(
tabs
[
i
]
)
;
}
}
moveTabsToEnd
(
contextTab
)
{
let
tabs
=
contextTab
.
multiselected
?
this
.
selectedTabs
:
[
contextTab
]
;
for
(
let
tab
of
tabs
)
{
this
.
moveTabToEnd
(
tab
)
;
}
}
warnAboutClosingTabs
(
tabsToClose
aCloseTabs
)
{
const
shownDupeDialogPref
=
"
browser
.
tabs
.
haveShownCloseAllDuplicateTabsWarning
"
;
var
ps
=
Services
.
prompt
;
if
(
aCloseTabs
=
=
this
.
closingTabsEnum
.
ALL_DUPLICATES
&
&
!
Services
.
prefs
.
getBoolPref
(
shownDupeDialogPref
false
)
)
{
Services
.
prefs
.
setBoolPref
(
shownDupeDialogPref
true
)
;
window
.
focus
(
)
;
const
[
title
text
button
]
=
this
.
tabLocalization
.
formatValuesSync
(
[
{
id
:
"
tabbrowser
-
confirm
-
close
-
all
-
duplicate
-
tabs
-
title
"
}
{
id
:
"
tabbrowser
-
confirm
-
close
-
all
-
duplicate
-
tabs
-
text
"
}
{
id
:
"
tabbrowser
-
confirm
-
close
-
all
-
duplicate
-
tabs
-
button
-
closetabs
"
}
]
)
;
const
flags
=
ps
.
BUTTON_POS_0
*
ps
.
BUTTON_TITLE_IS_STRING
+
ps
.
BUTTON_POS_1
*
ps
.
BUTTON_TITLE_CANCEL
+
ps
.
BUTTON_POS_0_DEFAULT
;
const
buttonPressed
=
ps
.
confirmEx
(
window
title
text
flags
button
null
null
null
{
}
)
;
return
buttonPressed
=
=
0
;
}
if
(
tabsToClose
<
=
1
)
{
return
true
;
}
const
pref
=
aCloseTabs
=
=
this
.
closingTabsEnum
.
ALL
?
"
browser
.
tabs
.
warnOnClose
"
:
"
browser
.
tabs
.
warnOnCloseOtherTabs
"
;
var
shouldPrompt
=
Services
.
prefs
.
getBoolPref
(
pref
)
;
if
(
!
shouldPrompt
)
{
return
true
;
}
const
maxTabsUndo
=
Services
.
prefs
.
getIntPref
(
"
browser
.
sessionstore
.
max_tabs_undo
"
)
;
if
(
aCloseTabs
!
=
this
.
closingTabsEnum
.
ALL
&
&
tabsToClose
<
=
maxTabsUndo
)
{
return
true
;
}
gDialogBox
.
replaceDialogIfOpen
(
)
;
var
warnOnClose
=
{
value
:
true
}
;
window
.
focus
(
)
;
const
[
title
button
checkbox
]
=
this
.
tabLocalization
.
formatValuesSync
(
[
{
id
:
"
tabbrowser
-
confirm
-
close
-
tabs
-
title
"
args
:
{
tabCount
:
tabsToClose
}
}
{
id
:
"
tabbrowser
-
confirm
-
close
-
tabs
-
button
"
}
{
id
:
"
tabbrowser
-
ask
-
close
-
tabs
-
checkbox
"
}
]
)
;
let
flags
=
ps
.
BUTTON_TITLE_IS_STRING
*
ps
.
BUTTON_POS_0
+
ps
.
BUTTON_TITLE_CANCEL
*
ps
.
BUTTON_POS_1
;
let
checkboxLabel
=
aCloseTabs
=
=
this
.
closingTabsEnum
.
ALL
?
checkbox
:
null
;
var
buttonPressed
=
ps
.
confirmEx
(
window
title
null
flags
button
null
null
checkboxLabel
warnOnClose
)
;
var
reallyClose
=
buttonPressed
=
=
0
;
if
(
aCloseTabs
=
=
this
.
closingTabsEnum
.
ALL
&
&
reallyClose
&
&
!
warnOnClose
.
value
)
{
Services
.
prefs
.
setBoolPref
(
pref
false
)
;
}
return
reallyClose
;
}
_insertTabAtIndex
(
tab
{
index
ownerTab
openerTab
pinned
bulkOrderedOpen
tabGroup
}
=
{
}
)
{
if
(
ownerTab
)
{
tab
.
owner
=
ownerTab
;
}
if
(
typeof
index
!
=
"
number
"
)
{
index
=
Infinity
;
if
(
!
bulkOrderedOpen
&
&
(
(
openerTab
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
insertRelatedAfterCurrent
"
)
)
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
insertAfterCurrent
"
)
)
)
{
let
lastRelatedTab
=
openerTab
&
&
this
.
_lastRelatedTabMap
.
get
(
openerTab
)
;
let
previousTab
=
lastRelatedTab
|
|
openerTab
|
|
this
.
selectedTab
;
if
(
!
tabGroup
)
{
tabGroup
=
previousTab
.
group
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
insertAfterCurrentExceptPinned
"
)
&
&
previousTab
.
pinned
)
{
index
=
Infinity
;
}
else
if
(
previousTab
.
visible
)
{
index
=
previousTab
.
_tPos
+
1
;
}
else
if
(
previousTab
=
=
FirefoxViewHandler
.
tab
)
{
index
=
0
;
}
if
(
lastRelatedTab
)
{
lastRelatedTab
.
owner
=
null
;
}
else
if
(
openerTab
)
{
tab
.
owner
=
openerTab
;
}
if
(
openerTab
)
{
this
.
_lastRelatedTabMap
.
set
(
openerTab
tab
)
;
}
}
}
tab
.
initialize
(
)
;
if
(
tab
.
pinned
)
{
index
=
Math
.
max
(
index
0
)
;
index
=
Math
.
min
(
index
this
.
pinnedTabCount
)
;
}
else
{
index
=
Math
.
max
(
index
this
.
pinnedTabCount
)
;
index
=
Math
.
min
(
index
this
.
tabs
.
length
)
;
}
let
tabAfter
=
this
.
tabs
.
at
(
index
)
;
this
.
tabContainer
.
_invalidateCachedTabs
(
)
;
if
(
tabGroup
)
{
if
(
tabAfter
&
&
tabAfter
.
group
=
=
tabGroup
)
{
this
.
tabContainer
.
insertBefore
(
tab
tabAfter
)
;
}
else
{
this
.
moveTabToGroup
(
tab
tabGroup
)
;
}
}
else
{
this
.
tabContainer
.
insertBefore
(
tab
tabAfter
?
.
group
?
?
tabAfter
)
;
}
this
.
_updateTabsAfterInsert
(
)
;
if
(
pinned
)
{
this
.
_updateTabBarForPinnedTabs
(
)
;
}
TabBarVisibility
.
update
(
)
;
}
_fireTabOpen
(
tab
eventDetail
)
{
delete
tab
.
initializingTab
;
let
evt
=
new
CustomEvent
(
"
TabOpen
"
{
bubbles
:
true
detail
:
eventDetail
|
|
{
}
}
)
;
tab
.
dispatchEvent
(
evt
)
;
}
_getTabsToTheStartFrom
(
aTab
)
{
let
tabsToStart
=
[
]
;
if
(
!
aTab
.
visible
)
{
return
tabsToStart
;
}
let
tabs
=
this
.
openTabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
+
+
i
)
{
if
(
tabs
[
i
]
=
=
aTab
)
{
break
;
}
if
(
tabs
[
i
]
.
pinned
|
|
tabs
[
i
]
.
hidden
)
{
continue
;
}
if
(
aTab
.
multiselected
&
&
tabs
[
i
]
.
multiselected
)
{
continue
;
}
tabsToStart
.
push
(
tabs
[
i
]
)
;
}
return
tabsToStart
;
}
_getTabsToTheEndFrom
(
aTab
)
{
let
tabsToEnd
=
[
]
;
if
(
!
aTab
.
visible
)
{
return
tabsToEnd
;
}
let
tabs
=
this
.
openTabs
;
for
(
let
i
=
tabs
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
tabs
[
i
]
=
=
aTab
)
{
break
;
}
if
(
tabs
[
i
]
.
pinned
|
|
tabs
[
i
]
.
hidden
)
{
continue
;
}
if
(
aTab
.
multiselected
&
&
tabs
[
i
]
.
multiselected
)
{
continue
;
}
tabsToEnd
.
push
(
tabs
[
i
]
)
;
}
return
tabsToEnd
;
}
getDuplicateTabsToClose
(
aTab
)
{
let
keys
=
[
]
;
let
keyForTab
=
tab
=
>
{
let
uri
=
tab
.
linkedBrowser
?
.
currentURI
;
if
(
!
uri
)
{
return
null
;
}
return
{
uri
userContextId
:
tab
.
userContextId
}
;
}
;
let
keyEquals
=
(
a
b
)
=
>
{
return
a
.
userContextId
=
=
b
.
userContextId
&
&
a
.
uri
.
equals
(
b
.
uri
)
;
}
;
if
(
aTab
.
multiselected
)
{
for
(
let
tab
of
this
.
selectedTabs
)
{
let
key
=
keyForTab
(
tab
)
;
if
(
key
)
{
keys
.
push
(
key
)
;
}
}
}
else
{
let
key
=
keyForTab
(
aTab
)
;
if
(
key
)
{
keys
.
push
(
key
)
;
}
}
if
(
!
keys
.
length
)
{
return
[
]
;
}
let
duplicateTabs
=
[
]
;
for
(
let
tab
of
this
.
tabs
)
{
if
(
tab
=
=
aTab
|
|
tab
.
pinned
)
{
continue
;
}
if
(
aTab
.
multiselected
&
&
tab
.
multiselected
)
{
continue
;
}
let
key
=
keyForTab
(
tab
)
;
if
(
key
&
&
keys
.
some
(
k
=
>
keyEquals
(
k
key
)
)
)
{
duplicateTabs
.
push
(
tab
)
;
}
}
return
duplicateTabs
;
}
getAllDuplicateTabsToClose
(
)
{
let
lastSeenTabs
=
this
.
tabs
.
toSorted
(
(
a
b
)
=
>
b
.
lastSeenActive
-
a
.
lastSeenActive
)
;
let
duplicateTabs
=
[
]
;
let
keys
=
[
]
;
for
(
let
tab
of
lastSeenTabs
)
{
const
uri
=
tab
.
linkedBrowser
?
.
currentURI
;
if
(
!
uri
)
{
continue
;
}
const
key
=
{
uri
userContextId
:
tab
.
userContextId
}
;
if
(
!
tab
.
pinned
&
&
keys
.
some
(
k
=
>
k
.
userContextId
=
=
key
.
userContextId
&
&
k
.
uri
.
equals
(
key
.
uri
)
)
)
{
duplicateTabs
.
push
(
tab
)
;
}
keys
.
push
(
key
)
;
}
return
duplicateTabs
;
}
removeDuplicateTabs
(
aTab
)
{
this
.
_removeDuplicateTabs
(
aTab
this
.
getDuplicateTabsToClose
(
aTab
)
this
.
closingTabsEnum
.
DUPLICATES
)
;
}
_removeDuplicateTabs
(
aConfirmationAnchor
tabs
aCloseTabs
)
{
if
(
!
tabs
.
length
)
{
return
;
}
if
(
!
this
.
warnAboutClosingTabs
(
tabs
.
length
aCloseTabs
)
)
{
return
;
}
this
.
removeTabs
(
tabs
)
;
ConfirmationHint
.
show
(
aConfirmationAnchor
"
confirmation
-
hint
-
duplicate
-
tabs
-
closed
"
{
l10nArgs
:
{
tabCount
:
tabs
.
length
}
}
)
;
}
removeAllDuplicateTabs
(
)
{
let
alltabsButton
=
document
.
getElementById
(
"
alltabs
-
button
"
)
;
this
.
_removeDuplicateTabs
(
alltabsButton
this
.
getAllDuplicateTabsToClose
(
)
this
.
closingTabsEnum
.
ALL_DUPLICATES
)
;
}
removeTabsToTheStartFrom
(
aTab
)
{
let
tabs
=
this
.
_getTabsToTheStartFrom
(
aTab
)
;
if
(
!
this
.
warnAboutClosingTabs
(
tabs
.
length
this
.
closingTabsEnum
.
TO_START
)
)
{
return
;
}
this
.
removeTabs
(
tabs
)
;
}
removeTabsToTheEndFrom
(
aTab
)
{
let
tabs
=
this
.
_getTabsToTheEndFrom
(
aTab
)
;
if
(
!
this
.
warnAboutClosingTabs
(
tabs
.
length
this
.
closingTabsEnum
.
TO_END
)
)
{
return
;
}
this
.
removeTabs
(
tabs
)
;
}
removeAllTabsBut
(
aTab
aParams
=
{
}
)
{
let
{
skipWarnAboutClosingTabs
=
false
skipPinnedOrSelectedTabs
=
true
}
=
aParams
;
let
filterFn
;
if
(
skipPinnedOrSelectedTabs
)
{
if
(
aTab
?
.
multiselected
)
{
filterFn
=
tab
=
>
!
tab
.
multiselected
&
&
!
tab
.
pinned
&
&
!
tab
.
hidden
;
}
else
{
filterFn
=
tab
=
>
tab
!
=
aTab
&
&
!
tab
.
pinned
&
&
!
tab
.
hidden
;
}
}
else
{
filterFn
=
tab
=
>
tab
!
=
aTab
;
}
let
tabsToRemove
=
this
.
openTabs
.
filter
(
filterFn
)
;
if
(
!
skipWarnAboutClosingTabs
&
&
!
this
.
warnAboutClosingTabs
(
tabsToRemove
.
length
this
.
closingTabsEnum
.
OTHER
)
)
{
return
;
}
this
.
removeTabs
(
tabsToRemove
aParams
)
;
}
removeMultiSelectedTabs
(
)
{
let
selectedTabs
=
this
.
selectedTabs
;
if
(
!
this
.
warnAboutClosingTabs
(
selectedTabs
.
length
this
.
closingTabsEnum
.
MULTI_SELECTED
)
)
{
return
;
}
this
.
removeTabs
(
selectedTabs
)
;
}
_startRemoveTabs
(
tabs
{
animate
suppressWarnAboutClosingWindow
skipPermitUnload
skipRemoves
skipSessionStore
}
)
{
let
tabsWithBeforeUnloadPrompt
=
[
]
;
let
tabsWithoutBeforeUnload
=
[
]
;
let
beforeUnloadPromises
=
[
]
;
let
lastToClose
;
let
tabGroupsSurvivingTabs
=
new
Map
(
)
;
for
(
let
tab
of
tabs
)
{
if
(
!
skipRemoves
)
{
tab
.
_closedInMultiselection
=
true
;
}
if
(
!
skipRemoves
&
&
!
skipSessionStore
)
{
if
(
tab
.
group
)
{
if
(
!
tabGroupsSurvivingTabs
.
has
(
tab
.
group
)
)
{
tabGroupsSurvivingTabs
.
set
(
tab
.
group
new
Set
(
tab
.
group
.
tabs
)
)
;
}
tabGroupsSurvivingTabs
.
get
(
tab
.
group
)
.
delete
(
tab
)
;
}
}
if
(
!
skipRemoves
&
&
tab
.
selected
)
{
lastToClose
=
tab
;
let
toBlurTo
=
this
.
_findTabToBlurTo
(
lastToClose
tabs
)
;
if
(
toBlurTo
)
{
this
.
_getSwitcher
(
)
.
warmupTab
(
toBlurTo
)
;
}
}
else
if
(
!
skipPermitUnload
&
&
this
.
_hasBeforeUnload
(
tab
)
)
{
TelemetryStopwatch
.
start
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
tab
)
;
tab
.
_pendingPermitUnload
=
true
;
beforeUnloadPromises
.
push
(
tab
.
linkedBrowser
.
asyncPermitUnload
(
"
dontUnload
"
)
.
then
(
(
{
permitUnload
}
)
=
>
{
tab
.
_pendingPermitUnload
=
false
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
tab
)
;
if
(
tab
.
closing
)
{
}
else
if
(
permitUnload
)
{
if
(
!
skipRemoves
)
{
this
.
removeTab
(
tab
{
animate
prewarmed
:
true
skipPermitUnload
:
true
skipSessionStore
}
)
;
}
}
else
{
tabsWithBeforeUnloadPrompt
.
push
(
tab
)
;
}
}
err
=
>
{
console
.
error
(
"
error
while
calling
asyncPermitUnload
"
err
)
;
tab
.
_pendingPermitUnload
=
false
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
tab
)
;
}
)
)
;
}
else
{
tabsWithoutBeforeUnload
.
push
(
tab
)
;
}
}
if
(
!
skipRemoves
&
&
!
skipSessionStore
)
{
for
(
let
[
tabGroup
survivingTabs
]
of
tabGroupsSurvivingTabs
.
entries
(
)
)
{
if
(
!
survivingTabs
.
size
)
{
tabGroup
.
save
(
)
;
this
.
removeTabGroup
(
tabGroup
)
;
}
}
}
if
(
!
skipRemoves
)
{
for
(
let
tab
of
tabsWithoutBeforeUnload
)
{
this
.
removeTab
(
tab
{
animate
prewarmed
:
true
skipPermitUnload
skipSessionStore
}
)
;
}
}
return
{
beforeUnloadComplete
:
Promise
.
all
(
beforeUnloadPromises
)
tabsWithBeforeUnloadPrompt
lastToClose
}
;
}
async
runBeforeUnloadForTabs
(
tabs
)
{
try
{
let
{
beforeUnloadComplete
tabsWithBeforeUnloadPrompt
}
=
this
.
_startRemoveTabs
(
tabs
{
animate
:
false
suppressWarnAboutClosingWindow
:
false
skipPermitUnload
:
false
skipRemoves
:
true
}
)
;
await
beforeUnloadComplete
;
for
(
let
tab
of
tabsWithBeforeUnloadPrompt
)
{
tab
.
_pendingPermitUnload
=
true
;
let
{
permitUnload
}
=
this
.
getBrowserForTab
(
tab
)
.
permitUnload
(
)
;
tab
.
_pendingPermitUnload
=
false
;
if
(
!
permitUnload
)
{
return
true
;
}
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
return
false
;
}
removeTabs
(
tabs
{
animate
=
true
suppressWarnAboutClosingWindow
=
false
skipPermitUnload
=
false
skipSessionStore
=
false
}
=
{
}
)
{
if
(
this
.
tabs
.
length
=
=
tabs
.
length
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
closeWindowWithLastTab
"
)
)
{
window
.
closeWindow
(
true
suppressWarnAboutClosingWindow
?
null
:
window
.
warnAboutClosingWindow
"
close
-
last
-
tab
"
)
;
return
;
}
if
(
!
skipSessionStore
)
{
SessionStore
.
resetLastClosedTabCount
(
window
)
;
}
this
.
_clearMultiSelectionLocked
=
true
;
try
{
let
{
beforeUnloadComplete
tabsWithBeforeUnloadPrompt
lastToClose
}
=
this
.
_startRemoveTabs
(
tabs
{
animate
suppressWarnAboutClosingWindow
skipPermitUnload
skipRemoves
:
false
skipSessionStore
}
)
;
let
done
=
false
;
beforeUnloadComplete
.
then
(
(
)
=
>
{
done
=
true
;
}
)
;
Services
.
tm
.
spinEventLoopUntilOrQuit
(
"
tabbrowser
.
js
:
removeTabs
"
(
)
=
>
done
|
|
window
.
closed
)
;
if
(
!
done
)
{
return
;
}
let
aParams
=
{
animate
prewarmed
:
true
skipPermitUnload
skipSessionStore
}
;
for
(
let
tab
of
tabsWithBeforeUnloadPrompt
)
{
this
.
removeTab
(
tab
aParams
)
;
if
(
!
tab
.
closing
)
{
tab
.
_closedInMultiselection
=
false
;
}
}
if
(
lastToClose
)
{
this
.
removeTab
(
lastToClose
aParams
)
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
this
.
_clearMultiSelectionLocked
=
false
;
this
.
_avoidSingleSelectedTab
(
)
;
}
removeCurrentTab
(
aParams
)
{
this
.
removeTab
(
this
.
selectedTab
aParams
)
;
}
removeTab
(
aTab
{
animate
triggeringEvent
skipPermitUnload
closeWindowWithLastTab
prewarmed
skipSessionStore
}
=
{
}
)
{
if
(
UserInteraction
.
running
(
"
browser
.
tabs
.
opening
"
window
)
)
{
UserInteraction
.
finish
(
"
browser
.
tabs
.
opening
"
window
)
;
}
if
(
!
TelemetryStopwatch
.
running
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
)
&
&
!
TelemetryStopwatch
.
running
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
)
)
{
TelemetryStopwatch
.
start
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
)
;
TelemetryStopwatch
.
start
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
)
;
}
if
(
!
animate
&
&
aTab
.
closing
)
{
this
.
_endRemoveTab
(
aTab
)
;
return
;
}
let
isVisibleTab
=
aTab
.
visible
;
let
isLastTab
=
isVisibleTab
&
&
this
.
visibleTabs
.
length
=
=
1
;
let
tabWidth
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
aTab
)
.
width
;
if
(
!
this
.
_beginRemoveTab
(
aTab
{
closeWindowFastpath
:
true
skipPermitUnload
closeWindowWithLastTab
prewarmed
skipSessionStore
}
)
)
{
TelemetryStopwatch
.
cancel
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
)
;
TelemetryStopwatch
.
cancel
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
)
;
return
;
}
let
lockTabSizing
=
!
this
.
tabContainer
.
verticalMode
&
&
!
aTab
.
pinned
&
&
isVisibleTab
&
&
aTab
.
_fullyOpen
&
&
triggeringEvent
?
.
inputSource
=
=
MouseEvent
.
MOZ_SOURCE_MOUSE
&
&
triggeringEvent
?
.
target
.
closest
(
"
.
tabbrowser
-
tab
"
)
;
if
(
lockTabSizing
)
{
this
.
tabContainer
.
_lockTabSizing
(
aTab
tabWidth
)
;
}
else
{
this
.
tabContainer
.
_unlockTabSizing
(
)
;
}
if
(
!
animate
|
|
gReduceMotion
|
|
isLastTab
|
|
aTab
.
pinned
|
|
!
isVisibleTab
|
|
this
.
tabContainer
.
verticalMode
|
|
this
.
_removingTabs
.
size
>
3
|
|
!
aTab
.
hasAttribute
(
"
fadein
"
)
|
|
tabWidth
=
=
0
)
{
TelemetryStopwatch
.
cancel
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
)
;
this
.
_endRemoveTab
(
aTab
)
;
return
;
}
TelemetryStopwatch
.
cancel
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
)
;
aTab
.
style
.
maxWidth
=
"
"
;
aTab
.
removeAttribute
(
"
fadein
"
)
;
aTab
.
removeAttribute
(
"
bursting
"
)
;
setTimeout
(
function
(
tab
tabbrowser
)
{
if
(
tab
.
container
&
&
window
.
getComputedStyle
(
tab
)
.
maxWidth
=
=
"
0
.
1px
"
)
{
console
.
assert
(
false
"
Giving
up
waiting
for
the
tab
closing
animation
to
finish
(
bug
608589
)
"
)
;
tabbrowser
.
_endRemoveTab
(
tab
)
;
}
}
3000
aTab
this
)
;
}
_hasBeforeUnload
(
aTab
)
{
let
browser
=
aTab
.
linkedBrowser
;
if
(
browser
.
isRemoteBrowser
&
&
browser
.
frameLoader
)
{
return
browser
.
hasBeforeUnload
;
}
return
false
;
}
_beginRemoveTab
(
aTab
{
adoptedByTab
closeWindowWithLastTab
closeWindowFastpath
skipPermitUnload
prewarmed
skipSessionStore
=
false
}
=
{
}
)
{
if
(
aTab
.
closing
|
|
this
.
_windowIsClosing
)
{
return
false
;
}
var
browser
=
this
.
getBrowserForTab
(
aTab
)
;
if
(
!
skipPermitUnload
&
&
!
adoptedByTab
&
&
aTab
.
linkedPanel
&
&
!
aTab
.
_pendingPermitUnload
&
&
(
!
browser
.
isRemoteBrowser
|
|
this
.
_hasBeforeUnload
(
aTab
)
)
)
{
if
(
!
prewarmed
)
{
let
blurTab
=
this
.
_findTabToBlurTo
(
aTab
)
;
if
(
blurTab
)
{
this
.
warmupTab
(
blurTab
)
;
}
}
TelemetryStopwatch
.
start
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
aTab
)
;
aTab
.
_pendingPermitUnload
=
true
;
let
{
permitUnload
}
=
browser
.
permitUnload
(
)
;
aTab
.
_pendingPermitUnload
=
false
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS
"
aTab
)
;
if
(
aTab
.
closing
|
|
!
permitUnload
)
{
return
false
;
}
}
let
tabCacheIndex
=
this
.
_tabLayerCache
.
indexOf
(
aTab
)
;
if
(
tabCacheIndex
!
=
-
1
)
{
this
.
_tabLayerCache
.
splice
(
tabCacheIndex
1
)
;
}
let
screenShareInActiveTab
=
aTab
=
=
this
.
selectedTab
&
&
aTab
.
_sharingState
?
.
webRTC
?
.
screen
;
if
(
!
screenShareInActiveTab
)
{
this
.
_blurTab
(
aTab
)
;
}
var
closeWindow
=
false
;
var
newTab
=
false
;
let
anyRemainingTabsInCollapsedTabGroups
=
!
!
this
.
tabsInCollapsedTabGroups
.
length
;
if
(
aTab
.
visible
&
&
this
.
visibleTabs
.
length
=
=
1
&
&
!
anyRemainingTabsInCollapsedTabGroups
)
{
closeWindow
=
closeWindowWithLastTab
!
=
null
?
closeWindowWithLastTab
:
!
window
.
toolbar
.
visible
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
closeWindowWithLastTab
"
)
;
if
(
closeWindow
)
{
window
.
skipNextCanClose
=
true
;
}
if
(
closeWindow
&
&
closeWindowFastpath
&
&
!
this
.
_removingTabs
.
size
)
{
this
.
_windowIsClosing
=
window
.
closeWindow
(
true
window
.
warnAboutClosingWindow
"
close
-
last
-
tab
"
)
;
return
false
;
}
newTab
=
true
;
}
aTab
.
_endRemoveArgs
=
[
closeWindow
newTab
]
;
if
(
closeWindow
&
&
adoptedByTab
)
{
if
(
aTab
.
linkedPanel
)
{
const
filter
=
this
.
_tabFilters
.
get
(
aTab
)
;
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
const
listener
=
this
.
_tabListeners
.
get
(
aTab
)
;
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
this
.
_tabListeners
.
delete
(
aTab
)
;
this
.
_tabFilters
.
delete
(
aTab
)
;
}
return
true
;
}
if
(
!
aTab
.
_fullyOpen
)
{
this
.
tabAnimationsInProgress
-
-
;
}
this
.
tabAnimationsInProgress
+
+
;
if
(
!
adoptedByTab
&
&
aTab
.
hasAttribute
(
"
soundplaying
"
)
)
{
aTab
.
linkedBrowser
.
mute
(
true
)
;
}
aTab
.
closing
=
true
;
this
.
_removingTabs
.
add
(
aTab
)
;
this
.
tabContainer
.
_invalidateCachedTabs
(
)
;
aTab
.
_mouseleave
(
)
;
if
(
newTab
)
{
this
.
addTrustedTab
(
BROWSER_NEW_TAB_URL
{
skipAnimation
:
true
}
)
;
}
else
{
TabBarVisibility
.
update
(
)
;
}
this
.
replaceInSuccession
(
aTab
aTab
.
successor
)
;
this
.
setSuccessor
(
aTab
null
)
;
let
evt
=
new
CustomEvent
(
"
TabClose
"
{
bubbles
:
true
detail
:
{
adoptedBy
:
adoptedByTab
skipSessionStore
}
}
)
;
aTab
.
dispatchEvent
(
evt
)
;
if
(
this
.
tabs
.
length
=
=
2
)
{
for
(
let
tab
of
this
.
tabs
)
{
let
bc
=
tab
.
linkedBrowser
.
browsingContext
;
if
(
bc
)
{
bc
.
hasSiblings
=
false
;
}
}
}
let
notificationBox
=
this
.
readNotificationBox
(
browser
)
;
notificationBox
?
.
_stack
?
.
remove
(
)
;
if
(
aTab
.
linkedPanel
)
{
if
(
!
adoptedByTab
&
&
!
gMultiProcessBrowser
)
{
browser
.
contentWindow
.
windowUtils
.
disableDialogs
(
)
;
}
const
filter
=
this
.
_tabFilters
.
get
(
aTab
)
;
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
const
listener
=
this
.
_tabListeners
.
get
(
aTab
)
;
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
}
if
(
browser
.
registeredOpenURI
&
&
!
adoptedByTab
)
{
let
userContextId
=
browser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
this
.
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
browser
.
registeredOpenURI
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
delete
browser
.
registeredOpenURI
;
}
browser
.
removeAttribute
(
"
primary
"
)
;
return
true
;
}
_endRemoveTab
(
aTab
)
{
if
(
!
aTab
|
|
!
aTab
.
_endRemoveArgs
)
{
return
;
}
var
[
aCloseWindow
aNewTab
]
=
aTab
.
_endRemoveArgs
;
aTab
.
_endRemoveArgs
=
null
;
if
(
this
.
_windowIsClosing
)
{
aCloseWindow
=
false
;
aNewTab
=
false
;
}
this
.
tabAnimationsInProgress
-
-
;
this
.
_lastRelatedTabMap
=
new
WeakMap
(
)
;
aTab
.
collapsed
=
true
;
this
.
_blurTab
(
aTab
)
;
this
.
_removingTabs
.
delete
(
aTab
)
;
if
(
aCloseWindow
)
{
this
.
_windowIsClosing
=
true
;
for
(
let
tab
of
this
.
_removingTabs
)
{
this
.
_endRemoveTab
(
tab
)
;
}
}
else
if
(
!
this
.
_windowIsClosing
)
{
if
(
aNewTab
)
{
gURLBar
.
select
(
)
;
}
}
this
.
_tabFilters
.
delete
(
aTab
)
;
this
.
_tabListeners
.
delete
(
aTab
)
;
var
browser
=
this
.
getBrowserForTab
(
aTab
)
;
if
(
aTab
.
linkedPanel
)
{
browser
.
destroy
(
)
;
}
var
wasPinned
=
aTab
.
pinned
;
aTab
.
remove
(
)
;
this
.
tabContainer
.
_invalidateCachedTabs
(
)
;
for
(
let
i
=
aTab
.
_tPos
;
i
<
this
.
tabs
.
length
;
i
+
+
)
{
this
.
tabs
[
i
]
.
_tPos
=
i
;
}
if
(
!
this
.
_windowIsClosing
)
{
if
(
wasPinned
)
{
this
.
tabContainer
.
_positionPinnedTabs
(
)
;
}
this
.
tabContainer
.
_updateCloseButtons
(
)
;
setTimeout
(
function
(
tabs
)
{
tabs
.
_lastTabClosedByMouse
=
false
;
}
0
this
.
tabContainer
)
;
}
this
.
selectedTab
.
_selected
=
true
;
var
panel
=
this
.
getPanel
(
browser
)
;
if
(
this
.
_switcher
)
{
this
.
_switcher
.
onTabRemoved
(
aTab
)
;
}
browser
.
remove
(
)
;
this
.
_tabForBrowser
.
delete
(
aTab
.
linkedBrowser
)
;
aTab
.
linkedBrowser
=
null
;
panel
.
remove
(
)
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_TIME_ANIM_MS
"
aTab
true
)
;
TelemetryStopwatch
.
finish
(
"
FX_TAB_CLOSE_TIME_NO_ANIM_MS
"
aTab
true
)
;
if
(
aCloseWindow
)
{
this
.
_windowIsClosing
=
closeWindow
(
true
window
.
warnAboutClosingWindow
"
close
-
last
-
tab
"
)
;
}
}
async
closeTabsByURI
(
urisToClose
)
{
let
tabsToRemove
=
[
]
;
for
(
let
tab
of
this
.
tabs
)
{
let
currentURI
=
tab
.
linkedBrowser
.
currentURI
;
const
matchedIndex
=
urisToClose
.
findIndex
(
uriToClose
=
>
uriToClose
.
equals
(
currentURI
)
)
;
if
(
matchedIndex
>
-
1
)
{
tabsToRemove
.
push
(
tab
)
;
}
}
let
closedCount
=
0
;
if
(
tabsToRemove
.
length
)
{
const
{
beforeUnloadComplete
lastToClose
}
=
this
.
_startRemoveTabs
(
tabsToRemove
{
animate
:
false
suppressWarnAboutClosingWindow
:
true
skipPermitUnload
:
false
skipRemoves
:
false
skipSessionStore
:
false
}
)
;
await
beforeUnloadComplete
;
closedCount
=
tabsToRemove
.
length
-
(
lastToClose
?
1
:
0
)
;
if
(
lastToClose
)
{
this
.
removeTab
(
lastToClose
)
;
closedCount
+
+
;
}
}
return
closedCount
;
}
async
explicitUnloadTabs
(
tabs
)
{
let
unloadBlocked
=
await
this
.
runBeforeUnloadForTabs
(
tabs
)
;
if
(
unloadBlocked
)
{
return
;
}
let
unloadSelectedTab
=
false
;
let
allTabsUnloaded
=
false
;
if
(
tabs
.
some
(
tab
=
>
tab
.
selected
)
)
{
unloadSelectedTab
=
true
;
const
tabsToExclude
=
tabs
.
concat
(
this
.
tabContainer
.
allTabs
.
filter
(
tab
=
>
!
tab
.
linkedPanel
)
)
;
let
newTab
=
this
.
_findTabToBlurTo
(
this
.
selectedTab
tabsToExclude
)
;
if
(
newTab
)
{
this
.
selectedTab
=
newTab
;
}
else
{
FirefoxViewHandler
.
openTab
(
"
opentabs
"
)
;
allTabsUnloaded
=
true
;
}
}
let
memoryUsageBeforeUnload
=
await
getTotalMemoryUsage
(
)
;
let
timeBeforeUnload
=
performance
.
now
(
)
;
let
numberOfTabsUnloaded
=
0
;
for
(
let
tab
of
tabs
)
{
numberOfTabsUnloaded
+
=
this
.
discardBrowser
(
tab
true
)
?
1
:
0
;
}
let
timeElapsed
=
Math
.
floor
(
performance
.
now
(
)
-
timeBeforeUnload
)
;
Glean
.
browserEngagement
.
tabExplicitUnload
.
record
(
{
unload_selected_tab
:
unloadSelectedTab
all_tabs_unloaded
:
allTabsUnloaded
tabs_unloaded
:
numberOfTabsUnloaded
memory_before
:
memoryUsageBeforeUnload
memory_after
:
await
getTotalMemoryUsage
(
)
time_to_unload_in_ms
:
timeElapsed
}
)
;
}
handleNewTabMiddleClick
(
node
event
)
{
if
(
node
.
getAttribute
(
"
disabled
"
)
=
=
"
true
"
)
{
return
;
}
if
(
event
.
button
=
=
1
)
{
BrowserCommands
.
openTab
(
{
event
}
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
_findTabToBlurTo
(
aTab
aExcludeTabs
=
[
]
)
{
if
(
!
aTab
.
selected
)
{
return
null
;
}
if
(
FirefoxViewHandler
.
tab
)
{
aExcludeTabs
.
push
(
FirefoxViewHandler
.
tab
)
;
}
let
excludeTabs
=
new
Set
(
aExcludeTabs
)
;
if
(
aTab
.
successor
&
&
!
excludeTabs
.
has
(
aTab
.
successor
)
)
{
return
aTab
.
successor
;
}
if
(
aTab
.
owner
?
.
visible
&
&
!
excludeTabs
.
has
(
aTab
.
owner
)
&
&
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
selectOwnerOnClose
"
)
)
{
return
aTab
.
owner
;
}
let
remainingTabs
=
Array
.
prototype
.
filter
.
call
(
this
.
visibleTabs
tab
=
>
!
excludeTabs
.
has
(
tab
)
)
;
let
tab
=
this
.
tabContainer
.
findNextTab
(
aTab
{
direction
:
1
filter
:
_tab
=
>
remainingTabs
.
includes
(
_tab
)
}
)
;
if
(
!
tab
)
{
tab
=
this
.
tabContainer
.
findNextTab
(
aTab
{
direction
:
-
1
filter
:
_tab
=
>
remainingTabs
.
includes
(
_tab
)
}
)
;
}
if
(
tab
)
{
return
tab
;
}
let
eligibleTabs
=
new
Set
(
this
.
tabsInCollapsedTabGroups
)
.
difference
(
excludeTabs
)
;
tab
=
this
.
tabContainer
.
findNextTab
(
aTab
{
direction
:
1
filter
:
_tab
=
>
eligibleTabs
.
has
(
_tab
)
}
)
;
if
(
!
tab
)
{
tab
=
this
.
tabContainer
.
findNextTab
(
aTab
{
direction
:
-
1
filter
:
_tab
=
>
eligibleTabs
.
has
(
_tab
)
}
)
;
}
return
tab
;
}
_blurTab
(
aTab
)
{
this
.
selectedTab
=
this
.
_findTabToBlurTo
(
aTab
)
;
}
swapBrowsersAndCloseOther
(
aOurTab
aOtherTab
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
!
=
PrivateBrowsingUtils
.
isWindowPrivate
(
aOtherTab
.
ownerGlobal
)
)
{
return
false
;
}
if
(
gFissionBrowser
!
=
aOtherTab
.
ownerGlobal
.
gFissionBrowser
)
{
return
false
;
}
let
ourBrowser
=
this
.
getBrowserForTab
(
aOurTab
)
;
let
otherBrowser
=
aOtherTab
.
linkedBrowser
;
if
(
ourBrowser
.
isRemoteBrowser
!
=
otherBrowser
.
isRemoteBrowser
)
{
return
false
;
}
if
(
otherBrowser
.
hasAttribute
(
"
usercontextid
"
)
)
{
ourBrowser
.
setAttribute
(
"
usercontextid
"
otherBrowser
.
getAttribute
(
"
usercontextid
"
)
)
;
}
var
remoteBrowser
=
aOtherTab
.
ownerGlobal
.
gBrowser
;
var
isPending
=
aOtherTab
.
hasAttribute
(
"
pending
"
)
;
let
otherTabListener
=
remoteBrowser
.
_tabListeners
.
get
(
aOtherTab
)
;
let
stateFlags
=
0
;
if
(
otherTabListener
)
{
stateFlags
=
otherTabListener
.
mStateFlags
;
}
if
(
aOtherTab
.
_soundPlayingAttrRemovalTimer
)
{
clearTimeout
(
aOtherTab
.
_soundPlayingAttrRemovalTimer
)
;
aOtherTab
.
_soundPlayingAttrRemovalTimer
=
0
;
aOtherTab
.
removeAttribute
(
"
soundplaying
"
)
;
remoteBrowser
.
_tabAttrModified
(
aOtherTab
[
"
soundplaying
"
]
)
;
}
if
(
!
remoteBrowser
.
_beginRemoveTab
(
aOtherTab
{
adoptedByTab
:
aOurTab
closeWindowWithLastTab
:
true
}
)
)
{
return
false
;
}
let
[
closeWindow
]
=
aOtherTab
.
_endRemoveArgs
;
if
(
closeWindow
)
{
let
win
=
aOtherTab
.
ownerGlobal
;
win
.
windowUtils
.
suppressAnimation
(
true
)
;
let
baseWin
=
win
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIBaseWindow
)
;
baseWin
.
visibility
=
false
;
}
let
modifiedAttrs
=
[
]
;
if
(
aOtherTab
.
hasAttribute
(
"
muted
"
)
)
{
aOurTab
.
toggleAttribute
(
"
muted
"
true
)
;
aOurTab
.
muteReason
=
aOtherTab
.
muteReason
;
if
(
aOurTab
.
linkedPanel
)
{
ourBrowser
.
mute
(
)
;
}
modifiedAttrs
.
push
(
"
muted
"
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
undiscardable
"
)
)
{
aOurTab
.
toggleAttribute
(
"
undiscardable
"
true
)
;
modifiedAttrs
.
push
(
"
undiscardable
"
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
soundplaying
"
)
)
{
aOurTab
.
toggleAttribute
(
"
soundplaying
"
true
)
;
modifiedAttrs
.
push
(
"
soundplaying
"
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
usercontextid
"
)
)
{
aOurTab
.
setUserContextId
(
aOtherTab
.
getAttribute
(
"
usercontextid
"
)
)
;
modifiedAttrs
.
push
(
"
usercontextid
"
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
sharing
"
)
)
{
aOurTab
.
setAttribute
(
"
sharing
"
aOtherTab
.
getAttribute
(
"
sharing
"
)
)
;
modifiedAttrs
.
push
(
"
sharing
"
)
;
aOurTab
.
_sharingState
=
aOtherTab
.
_sharingState
;
webrtcUI
.
swapBrowserForNotification
(
otherBrowser
ourBrowser
)
;
}
if
(
aOtherTab
.
hasAttribute
(
"
pictureinpicture
"
)
)
{
aOurTab
.
toggleAttribute
(
"
pictureinpicture
"
true
)
;
modifiedAttrs
.
push
(
"
pictureinpicture
"
)
;
let
event
=
new
CustomEvent
(
"
TabSwapPictureInPicture
"
{
detail
:
aOurTab
}
)
;
aOtherTab
.
dispatchEvent
(
event
)
;
}
if
(
otherBrowser
.
isDistinctProductPageVisit
)
{
ourBrowser
.
isDistinctProductPageVisit
=
true
;
}
SitePermissions
.
copyTemporaryPermissions
(
otherBrowser
ourBrowser
)
;
if
(
isPending
)
{
aOurTab
.
initializingTab
=
true
;
delete
ourBrowser
.
_cachedCurrentURI
;
SessionStore
.
setTabState
(
aOurTab
SessionStore
.
getTabState
(
aOtherTab
)
)
;
delete
aOurTab
.
initializingTab
;
this
.
_swapRegisteredOpenURIs
(
ourBrowser
otherBrowser
)
;
}
else
{
if
(
!
ourBrowser
.
mIconURL
&
&
otherBrowser
.
mIconURL
)
{
this
.
setIcon
(
aOurTab
otherBrowser
.
mIconURL
)
;
}
var
isBusy
=
aOtherTab
.
hasAttribute
(
"
busy
"
)
;
if
(
isBusy
)
{
aOurTab
.
setAttribute
(
"
busy
"
"
true
"
)
;
modifiedAttrs
.
push
(
"
busy
"
)
;
if
(
aOurTab
.
selected
)
{
this
.
_isBusy
=
true
;
}
}
this
.
_swapBrowserDocShells
(
aOurTab
otherBrowser
stateFlags
)
;
}
if
(
otherBrowser
.
registeredOpenURI
)
{
let
userContextId
=
otherBrowser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
this
.
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
otherBrowser
.
registeredOpenURI
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
delete
otherBrowser
.
registeredOpenURI
;
}
let
otherFindBar
=
aOtherTab
.
_findBar
;
if
(
otherFindBar
&
&
otherFindBar
.
findMode
=
=
otherFindBar
.
FIND_NORMAL
)
{
let
oldValue
=
otherFindBar
.
_findField
.
value
;
let
wasHidden
=
otherFindBar
.
hidden
;
let
ourFindBarPromise
=
this
.
getFindBar
(
aOurTab
)
;
ourFindBarPromise
.
then
(
ourFindBar
=
>
{
if
(
!
ourFindBar
)
{
return
;
}
ourFindBar
.
_findField
.
value
=
oldValue
;
if
(
!
wasHidden
)
{
ourFindBar
.
onFindCommand
(
)
;
}
}
)
;
}
if
(
closeWindow
)
{
aOtherTab
.
ownerGlobal
.
close
(
)
;
}
else
{
remoteBrowser
.
_endRemoveTab
(
aOtherTab
)
;
}
this
.
setTabTitle
(
aOurTab
)
;
if
(
aOurTab
.
selected
)
{
this
.
updateCurrentBrowser
(
true
)
;
}
if
(
modifiedAttrs
.
length
)
{
this
.
_tabAttrModified
(
aOurTab
modifiedAttrs
)
;
}
return
true
;
}
swapBrowsers
(
aOurTab
aOtherTab
)
{
let
otherBrowser
=
aOtherTab
.
linkedBrowser
;
let
otherTabBrowser
=
otherBrowser
.
getTabBrowser
(
)
;
let
filter
=
otherTabBrowser
.
_tabFilters
.
get
(
aOtherTab
)
;
let
tabListener
=
otherTabBrowser
.
_tabListeners
.
get
(
aOtherTab
)
;
otherBrowser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
tabListener
)
;
this
.
_swapBrowserDocShells
(
aOurTab
otherBrowser
)
;
tabListener
=
new
otherTabBrowser
.
ownerGlobal
.
TabProgressListener
(
aOtherTab
otherBrowser
false
false
)
;
otherTabBrowser
.
_tabListeners
.
set
(
aOtherTab
tabListener
)
;
const
notifyAll
=
Ci
.
nsIWebProgress
.
NOTIFY_ALL
;
filter
.
addProgressListener
(
tabListener
notifyAll
)
;
otherBrowser
.
webProgress
.
addProgressListener
(
filter
notifyAll
)
;
}
_swapBrowserDocShells
(
aOurTab
aOtherBrowser
aStateFlags
)
{
this
.
_insertBrowser
(
aOurTab
)
;
const
filter
=
this
.
_tabFilters
.
get
(
aOurTab
)
;
let
tabListener
=
this
.
_tabListeners
.
get
(
aOurTab
)
;
let
ourBrowser
=
this
.
getBrowserForTab
(
aOurTab
)
;
ourBrowser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
tabListener
)
;
this
.
_swapRegisteredOpenURIs
(
ourBrowser
aOtherBrowser
)
;
let
remoteBrowser
=
aOtherBrowser
.
ownerGlobal
.
gBrowser
;
if
(
!
this
.
_switcher
)
{
aOtherBrowser
.
docShellIsActive
=
this
.
shouldActivateDocShell
(
ourBrowser
)
;
}
let
ourBrowserContainer
=
ourBrowser
.
ownerDocument
.
getElementById
(
"
browser
"
)
;
let
otherBrowserContainer
=
aOtherBrowser
.
ownerDocument
.
getElementById
(
"
browser
"
)
;
let
ourBrowserContainerWasHidden
=
ourBrowserContainer
.
hidden
;
let
otherBrowserContainerWasHidden
=
otherBrowserContainer
.
hidden
;
ourBrowserContainer
.
hidden
=
otherBrowserContainer
.
hidden
=
false
;
ourBrowser
.
swapDocShells
(
aOtherBrowser
)
;
ourBrowserContainer
.
hidden
=
ourBrowserContainerWasHidden
;
otherBrowserContainer
.
hidden
=
otherBrowserContainerWasHidden
;
let
ourPermanentKey
=
ourBrowser
.
permanentKey
;
ourBrowser
.
permanentKey
=
aOtherBrowser
.
permanentKey
;
aOtherBrowser
.
permanentKey
=
ourPermanentKey
;
aOurTab
.
permanentKey
=
ourBrowser
.
permanentKey
;
if
(
remoteBrowser
)
{
let
otherTab
=
remoteBrowser
.
getTabForBrowser
(
aOtherBrowser
)
;
if
(
otherTab
)
{
otherTab
.
permanentKey
=
aOtherBrowser
.
permanentKey
;
}
}
tabListener
=
new
TabProgressListener
(
aOurTab
ourBrowser
false
false
aStateFlags
)
;
this
.
_tabListeners
.
set
(
aOurTab
tabListener
)
;
const
notifyAll
=
Ci
.
nsIWebProgress
.
NOTIFY_ALL
;
filter
.
addProgressListener
(
tabListener
notifyAll
)
;
ourBrowser
.
webProgress
.
addProgressListener
(
filter
notifyAll
)
;
}
_swapRegisteredOpenURIs
(
aOurBrowser
aOtherBrowser
)
{
let
tmp
=
aOurBrowser
.
registeredOpenURI
;
delete
aOurBrowser
.
registeredOpenURI
;
if
(
aOtherBrowser
.
registeredOpenURI
)
{
aOurBrowser
.
registeredOpenURI
=
aOtherBrowser
.
registeredOpenURI
;
delete
aOtherBrowser
.
registeredOpenURI
;
}
if
(
tmp
)
{
aOtherBrowser
.
registeredOpenURI
=
tmp
;
}
}
reloadMultiSelectedTabs
(
)
{
this
.
reloadTabs
(
this
.
selectedTabs
)
;
}
reloadTabs
(
tabs
)
{
for
(
let
tab
of
tabs
)
{
try
{
this
.
getBrowserForTab
(
tab
)
.
reload
(
)
;
}
catch
(
e
)
{
}
}
}
reloadTab
(
aTab
)
{
let
browser
=
this
.
getBrowserForTab
(
aTab
)
;
SitePermissions
.
clearTemporaryBlockPermissions
(
browser
)
;
delete
browser
.
authPromptAbuseCounter
;
gIdentityHandler
.
hidePopup
(
)
;
gPermissionPanel
.
hidePopup
(
)
;
browser
.
reload
(
)
;
}
addProgressListener
(
aListener
)
{
if
(
arguments
.
length
!
=
1
)
{
console
.
error
(
"
gBrowser
.
addProgressListener
was
"
+
"
called
with
a
second
argument
"
+
"
which
is
not
supported
.
See
bug
"
+
"
608628
.
Call
stack
:
"
new
Error
(
)
.
stack
)
;
}
this
.
mProgressListeners
.
push
(
aListener
)
;
}
removeProgressListener
(
aListener
)
{
this
.
mProgressListeners
=
this
.
mProgressListeners
.
filter
(
l
=
>
l
!
=
aListener
)
;
}
addTabsProgressListener
(
aListener
)
{
this
.
mTabsProgressListeners
.
push
(
aListener
)
;
}
removeTabsProgressListener
(
aListener
)
{
this
.
mTabsProgressListeners
=
this
.
mTabsProgressListeners
.
filter
(
l
=
>
l
!
=
aListener
)
;
}
getBrowserForTab
(
aTab
)
{
return
aTab
.
linkedBrowser
;
}
showTab
(
aTab
)
{
if
(
!
aTab
.
hidden
|
|
aTab
=
=
FirefoxViewHandler
.
tab
)
{
return
;
}
aTab
.
removeAttribute
(
"
hidden
"
)
;
this
.
tabContainer
.
_invalidateCachedVisibleTabs
(
)
;
this
.
tabContainer
.
_updateCloseButtons
(
)
;
if
(
aTab
.
multiselected
)
{
this
.
_updateMultiselectedTabCloseButtonTooltip
(
)
;
}
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
TabShow
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
SessionStore
.
deleteCustomTabValue
(
aTab
"
hiddenBy
"
)
;
}
hideTab
(
aTab
aSource
)
{
if
(
aTab
.
hidden
|
|
aTab
.
pinned
|
|
aTab
.
selected
|
|
aTab
.
closing
|
|
aTab
.
_sharingState
?
.
webRTC
?
.
sharing
)
{
return
;
}
aTab
.
setAttribute
(
"
hidden
"
"
true
"
)
;
this
.
tabContainer
.
_invalidateCachedVisibleTabs
(
)
;
this
.
tabContainer
.
_updateCloseButtons
(
)
;
if
(
aTab
.
multiselected
)
{
this
.
_updateMultiselectedTabCloseButtonTooltip
(
)
;
}
this
.
replaceInSuccession
(
aTab
aTab
.
successor
)
;
this
.
setSuccessor
(
aTab
null
)
;
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
TabHide
"
true
false
)
;
aTab
.
dispatchEvent
(
event
)
;
if
(
aSource
)
{
SessionStore
.
setCustomTabValue
(
aTab
"
hiddenBy
"
aSource
)
;
}
}
selectTabAtIndex
(
aIndex
aEvent
)
{
let
tabs
=
this
.
visibleTabs
;
if
(
aIndex
<
0
)
{
aIndex
+
=
tabs
.
length
;
if
(
aIndex
<
0
)
{
aIndex
=
0
;
}
}
else
if
(
aIndex
>
=
tabs
.
length
)
{
aIndex
=
tabs
.
length
-
1
;
}
this
.
selectedTab
=
tabs
[
aIndex
]
;
if
(
aEvent
)
{
aEvent
.
preventDefault
(
)
;
aEvent
.
stopPropagation
(
)
;
}
}
replaceTabWithWindow
(
aTab
aOptions
)
{
if
(
this
.
tabs
.
length
=
=
1
)
{
return
null
;
}
var
options
=
"
chrome
dialog
=
no
all
"
;
for
(
var
name
in
aOptions
)
{
options
+
=
"
"
+
name
+
"
=
"
+
aOptions
[
name
]
;
}
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
options
+
=
"
private
=
1
"
;
}
if
(
!
gReduceMotion
)
{
aTab
.
style
.
maxWidth
=
"
"
;
aTab
.
removeAttribute
(
"
fadein
"
)
;
}
return
window
.
openDialog
(
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
options
aTab
)
;
}
replaceTabsWithWindow
(
contextTab
aOptions
=
{
}
)
{
let
tabs
;
if
(
contextTab
.
multiselected
)
{
tabs
=
this
.
selectedTabs
;
}
else
{
tabs
=
[
contextTab
]
;
}
if
(
this
.
tabs
.
length
=
=
tabs
.
length
)
{
return
null
;
}
if
(
tabs
.
length
=
=
1
)
{
return
this
.
replaceTabWithWindow
(
tabs
[
0
]
aOptions
)
;
}
if
(
!
gReduceMotion
)
{
for
(
let
tab
of
tabs
)
{
tab
.
style
.
maxWidth
=
"
"
;
tab
.
removeAttribute
(
"
fadein
"
)
;
}
}
let
{
selectedTab
}
=
gBrowser
;
if
(
!
tabs
.
includes
(
selectedTab
)
)
{
selectedTab
=
tabs
[
0
]
;
}
let
win
=
this
.
replaceTabWithWindow
(
selectedTab
aOptions
)
;
win
.
addEventListener
(
"
before
-
initial
-
tab
-
adopted
"
(
)
=
>
{
let
index
=
0
;
for
(
let
tab
of
tabs
)
{
if
(
tab
!
=
=
selectedTab
)
{
const
newTab
=
win
.
gBrowser
.
adoptTab
(
tab
index
)
;
if
(
!
newTab
)
{
tab
.
setAttribute
(
"
fadein
"
"
true
"
)
;
continue
;
}
}
+
+
index
;
}
let
winVisibleTabs
=
win
.
gBrowser
.
visibleTabs
;
let
winTabLength
=
winVisibleTabs
.
length
;
win
.
gBrowser
.
addRangeToMultiSelectedTabs
(
winVisibleTabs
[
0
]
winVisibleTabs
[
winTabLength
-
1
]
)
;
win
.
gBrowser
.
lockClearMultiSelectionOnce
(
)
;
}
{
once
:
true
}
)
;
return
win
;
}
replaceGroupWithWindow
(
group
)
{
let
selectedIndex
=
group
.
tabs
.
indexOf
(
gBrowser
.
selectedTab
)
;
if
(
selectedIndex
<
0
)
{
selectedIndex
=
0
;
}
let
firstTab
=
group
.
tabs
[
selectedIndex
]
;
let
newWindow
=
this
.
replaceTabWithWindow
(
firstTab
)
;
newWindow
.
addEventListener
(
"
before
-
initial
-
tab
-
adopted
"
(
)
=
>
{
let
tabsToGroup
=
group
.
tabs
.
map
(
(
tab
i
)
=
>
{
if
(
i
=
=
selectedIndex
)
{
return
newWindow
.
gBrowser
.
visibleTabs
[
0
]
;
}
return
tab
;
}
)
;
newWindow
.
gBrowser
.
addTabGroup
(
tabsToGroup
{
color
:
group
.
color
label
:
group
.
label
id
:
group
.
id
}
)
;
}
{
once
:
true
}
)
;
return
newWindow
;
}
_updateTabsAfterInsert
(
)
{
for
(
let
i
=
0
;
i
<
this
.
tabs
.
length
;
i
+
+
)
{
this
.
tabs
[
i
]
.
_tPos
=
i
;
this
.
tabs
[
i
]
.
_selected
=
false
;
}
this
.
selectedTab
.
_selected
=
true
;
}
moveTabTo
(
aTab
aIndex
{
forceStandaloneTab
=
false
}
=
{
}
)
{
if
(
aTab
.
pinned
)
{
aIndex
=
Math
.
min
(
aIndex
this
.
pinnedTabCount
-
1
)
;
}
else
{
aIndex
=
Math
.
max
(
aIndex
this
.
pinnedTabCount
)
;
}
if
(
aTab
.
_tPos
=
=
aIndex
&
&
!
(
aTab
.
group
&
&
forceStandaloneTab
)
)
{
return
;
}
this
.
_handleTabMove
(
aTab
(
)
=
>
{
let
neighbor
=
this
.
tabs
[
aIndex
]
;
if
(
forceStandaloneTab
&
&
neighbor
.
group
)
{
neighbor
=
neighbor
.
group
;
}
if
(
neighbor
&
&
aIndex
>
aTab
.
_tPos
)
{
neighbor
.
after
(
aTab
)
;
}
else
{
this
.
tabContainer
.
insertBefore
(
aTab
neighbor
)
;
}
}
)
;
}
dropTab
(
tab
targetElement
dropBefore
)
{
this
.
_handleTabMove
(
tab
(
)
=
>
{
if
(
dropBefore
)
{
this
.
tabContainer
.
insertBefore
(
tab
targetElement
)
;
}
else
{
targetElement
.
after
(
tab
)
;
}
}
)
;
}
dropTabs
(
tabs
targetElement
dropBefore
)
{
this
.
dropTab
(
tabs
[
0
]
targetElement
dropBefore
)
;
for
(
let
i
=
1
;
i
<
tabs
.
length
;
i
+
+
)
{
this
.
dropTab
(
tabs
[
i
]
tabs
[
i
-
1
]
)
;
}
}
moveTabToGroup
(
aTab
aGroup
)
{
if
(
aTab
.
pinned
)
{
return
;
}
if
(
aTab
.
group
&
&
aTab
.
group
.
id
=
=
=
aGroup
.
id
)
{
return
;
}
aGroup
.
collapsed
=
false
;
this
.
_handleTabMove
(
aTab
(
)
=
>
aGroup
.
appendChild
(
aTab
)
)
;
this
.
removeFromMultiSelectedTabs
(
aTab
)
;
this
.
tabContainer
.
_notifyBackgroundTab
(
aTab
)
;
}
_handleTabMove
(
aTab
moveActionCallback
)
{
let
wasFocused
=
document
.
activeElement
=
=
this
.
selectedTab
;
let
oldPosition
=
aTab
.
_tPos
;
moveActionCallback
(
)
;
this
.
tabContainer
.
_invalidateCachedTabs
(
)
;
this
.
_lastRelatedTabMap
=
new
WeakMap
(
)
;
this
.
_updateTabsAfterInsert
(
)
;
if
(
wasFocused
)
{
this
.
selectedTab
.
focus
(
)
;
}
this
.
tabContainer
.
_handleTabSelect
(
true
)
;
if
(
aTab
.
pinned
)
{
this
.
tabContainer
.
_positionPinnedTabs
(
)
;
}
if
(
oldPosition
=
=
aTab
.
_tPos
)
{
return
;
}
var
evt
=
document
.
createEvent
(
"
UIEvents
"
)
;
evt
.
initUIEvent
(
"
TabMove
"
true
false
window
oldPosition
)
;
aTab
.
dispatchEvent
(
evt
)
;
}
adoptTab
(
aTab
aIndex
aSelectTab
)
{
let
linkedBrowser
=
aTab
.
linkedBrowser
;
let
createLazyBrowser
=
!
aTab
.
linkedPanel
;
let
params
=
{
eventDetail
:
{
adoptedTab
:
aTab
}
preferredRemoteType
:
linkedBrowser
.
remoteType
initialBrowsingContextGroupId
:
linkedBrowser
.
browsingContext
?
.
group
.
id
skipAnimation
:
true
index
:
aIndex
tabGroup
:
typeof
aIndex
=
=
"
number
"
&
&
aIndex
>
-
1
?
this
.
tabs
.
at
(
aIndex
)
?
.
group
:
null
createLazyBrowser
}
;
let
numPinned
=
this
.
pinnedTabCount
;
if
(
aIndex
<
numPinned
|
|
(
aTab
.
pinned
&
&
aIndex
=
=
numPinned
)
)
{
params
.
pinned
=
true
;
}
if
(
aTab
.
hasAttribute
(
"
usercontextid
"
)
)
{
params
.
userContextId
=
aTab
.
getAttribute
(
"
usercontextid
"
)
;
}
let
newTab
=
this
.
addWebTab
(
"
about
:
blank
"
params
)
;
let
newBrowser
=
this
.
getBrowserForTab
(
newTab
)
;
aTab
.
container
.
_finishAnimateTabMove
(
)
;
if
(
!
createLazyBrowser
)
{
newBrowser
.
stop
(
)
;
}
if
(
!
this
.
swapBrowsersAndCloseOther
(
newTab
aTab
)
)
{
this
.
removeTab
(
newTab
)
;
return
null
;
}
if
(
aSelectTab
)
{
this
.
selectedTab
=
newTab
;
}
return
newTab
;
}
moveTabForward
(
)
{
let
{
selectedTab
}
=
this
;
let
nextTab
=
this
.
tabContainer
.
findNextTab
(
selectedTab
{
direction
:
DIRECTION_FORWARD
filter
:
tab
=
>
!
tab
.
hidden
&
&
selectedTab
.
pinned
=
=
tab
.
pinned
}
)
;
if
(
nextTab
)
{
this
.
_handleTabMove
(
selectedTab
(
)
=
>
{
if
(
!
selectedTab
.
group
&
&
nextTab
.
group
)
{
if
(
nextTab
.
group
.
collapsed
)
{
nextTab
.
group
.
after
(
selectedTab
)
;
}
else
{
nextTab
.
group
.
prepend
(
selectedTab
)
;
}
}
else
if
(
selectedTab
.
group
!
=
nextTab
.
group
)
{
selectedTab
.
group
.
after
(
selectedTab
)
;
}
else
{
nextTab
.
after
(
selectedTab
)
;
}
}
)
;
}
}
moveTabBackward
(
)
{
let
{
selectedTab
}
=
this
;
let
previousTab
=
this
.
tabContainer
.
findNextTab
(
selectedTab
{
direction
:
DIRECTION_BACKWARD
filter
:
tab
=
>
!
tab
.
hidden
&
&
selectedTab
.
pinned
=
=
tab
.
pinned
}
)
;
if
(
previousTab
)
{
this
.
_handleTabMove
(
selectedTab
(
)
=
>
{
if
(
!
selectedTab
.
group
&
&
previousTab
.
group
)
{
if
(
previousTab
.
group
.
collapsed
)
{
previousTab
.
group
.
before
(
selectedTab
)
;
}
else
{
previousTab
.
group
.
append
(
selectedTab
)
;
}
}
else
if
(
selectedTab
.
group
!
=
previousTab
.
group
)
{
selectedTab
.
group
.
before
(
selectedTab
)
;
}
else
{
previousTab
.
before
(
selectedTab
)
;
}
}
)
;
}
}
moveTabToStart
(
aTab
=
this
.
selectedTab
)
{
this
.
moveTabTo
(
aTab
0
{
forceStandaloneTab
:
true
}
)
;
}
moveTabToEnd
(
aTab
=
this
.
selectedTab
)
{
this
.
moveTabTo
(
aTab
this
.
tabs
.
length
-
1
{
forceStandaloneTab
:
true
}
)
;
}
duplicateTab
(
aTab
aRestoreTabImmediately
aOptions
)
{
return
SessionStore
.
duplicateTab
(
window
aTab
0
aRestoreTabImmediately
aOptions
)
;
}
_updateMultiselectedTabCloseButtonTooltip
(
)
{
const
tabCount
=
gBrowser
.
selectedTabs
.
length
;
gBrowser
.
selectedTabs
.
forEach
(
selectedTab
=
>
{
document
.
l10n
.
setArgs
(
selectedTab
.
querySelector
(
"
.
tab
-
close
-
button
"
)
{
tabCount
}
)
;
}
)
;
}
addToMultiSelectedTabs
(
aTab
)
{
if
(
aTab
.
multiselected
)
{
return
;
}
aTab
.
setAttribute
(
"
multiselected
"
"
true
"
)
;
aTab
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
this
.
_multiSelectedTabsSet
.
add
(
aTab
)
;
this
.
_startMultiSelectChange
(
)
;
if
(
this
.
_multiSelectChangeRemovals
.
has
(
aTab
)
)
{
this
.
_multiSelectChangeRemovals
.
delete
(
aTab
)
;
}
else
{
this
.
_multiSelectChangeAdditions
.
add
(
aTab
)
;
}
this
.
_updateMultiselectedTabCloseButtonTooltip
(
)
;
}
addRangeToMultiSelectedTabs
(
aTab1
aTab2
)
{
if
(
aTab1
=
=
aTab2
)
{
return
;
}
const
tabs
=
this
.
visibleTabs
;
const
indexOfTab1
=
tabs
.
indexOf
(
aTab1
)
;
const
indexOfTab2
=
tabs
.
indexOf
(
aTab2
)
;
const
[
lowerIndex
higherIndex
]
=
indexOfTab1
<
indexOfTab2
?
[
Math
.
max
(
0
indexOfTab1
)
indexOfTab2
]
:
[
Math
.
max
(
0
indexOfTab2
)
indexOfTab1
]
;
for
(
let
i
=
lowerIndex
;
i
<
=
higherIndex
;
i
+
+
)
{
this
.
addToMultiSelectedTabs
(
tabs
[
i
]
)
;
}
this
.
_updateMultiselectedTabCloseButtonTooltip
(
)
;
}
removeFromMultiSelectedTabs
(
aTab
)
{
if
(
!
aTab
.
multiselected
)
{
return
;
}
aTab
.
removeAttribute
(
"
multiselected
"
)
;
aTab
.
removeAttribute
(
"
aria
-
selected
"
)
;
this
.
_multiSelectedTabsSet
.
delete
(
aTab
)
;
this
.
_startMultiSelectChange
(
)
;
if
(
this
.
_multiSelectChangeAdditions
.
has
(
aTab
)
)
{
this
.
_multiSelectChangeAdditions
.
delete
(
aTab
)
;
}
else
{
this
.
_multiSelectChangeRemovals
.
add
(
aTab
)
;
}
this
.
_updateMultiselectedTabCloseButtonTooltip
(
)
;
document
.
l10n
.
setArgs
(
aTab
.
querySelector
(
"
.
tab
-
close
-
button
"
)
{
tabCount
:
1
}
)
;
}
clearMultiSelectedTabs
(
)
{
if
(
this
.
_clearMultiSelectionLocked
)
{
if
(
this
.
_clearMultiSelectionLockedOnce
)
{
this
.
_clearMultiSelectionLockedOnce
=
false
;
this
.
_clearMultiSelectionLocked
=
false
;
}
return
;
}
if
(
this
.
multiSelectedTabsCount
<
1
)
{
return
;
}
for
(
let
tab
of
this
.
selectedTabs
)
{
this
.
removeFromMultiSelectedTabs
(
tab
)
;
}
this
.
_lastMultiSelectedTabRef
=
null
;
}
selectAllTabs
(
)
{
let
visibleTabs
=
this
.
visibleTabs
;
gBrowser
.
addRangeToMultiSelectedTabs
(
visibleTabs
[
0
]
visibleTabs
[
visibleTabs
.
length
-
1
]
)
;
}
allTabsSelected
(
)
{
return
(
this
.
visibleTabs
.
length
=
=
1
|
|
this
.
visibleTabs
.
every
(
t
=
>
t
.
multiselected
)
)
;
}
lockClearMultiSelectionOnce
(
)
{
this
.
_clearMultiSelectionLockedOnce
=
true
;
this
.
_clearMultiSelectionLocked
=
true
;
}
unlockClearMultiSelection
(
)
{
this
.
_clearMultiSelectionLockedOnce
=
false
;
this
.
_clearMultiSelectionLocked
=
false
;
}
_avoidSingleSelectedTab
(
)
{
if
(
this
.
multiSelectedTabsCount
=
=
1
)
{
this
.
clearMultiSelectedTabs
(
)
;
}
}
_switchToNextMultiSelectedTab
(
)
{
this
.
_clearMultiSelectionLocked
=
true
;
try
{
let
lastMultiSelectedTab
=
this
.
lastMultiSelectedTab
;
if
(
!
lastMultiSelectedTab
.
selected
)
{
this
.
selectedTab
=
lastMultiSelectedTab
;
}
else
{
let
selectedTabs
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
this
.
_multiSelectedTabsSet
)
.
filter
(
this
.
_mayTabBeMultiselected
)
;
this
.
selectedTab
=
selectedTabs
.
at
(
-
1
)
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
this
.
_clearMultiSelectionLocked
=
false
;
}
set
selectedTabs
(
tabs
)
{
this
.
clearMultiSelectedTabs
(
)
;
this
.
selectedTab
=
tabs
[
0
]
;
if
(
tabs
.
length
>
1
)
{
for
(
let
tab
of
tabs
)
{
this
.
addToMultiSelectedTabs
(
tab
)
;
}
}
}
get
selectedTabs
(
)
{
let
{
selectedTab
_multiSelectedTabsSet
}
=
this
;
let
tabs
=
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
_multiSelectedTabsSet
)
.
filter
(
this
.
_mayTabBeMultiselected
)
;
if
(
(
!
_multiSelectedTabsSet
.
has
(
selectedTab
)
&
&
this
.
_mayTabBeMultiselected
(
selectedTab
)
)
|
|
!
tabs
.
length
)
{
tabs
.
push
(
selectedTab
)
;
}
return
tabs
.
sort
(
(
a
b
)
=
>
a
.
_tPos
>
b
.
_tPos
)
;
}
get
multiSelectedTabsCount
(
)
{
return
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
this
.
_multiSelectedTabsSet
)
.
filter
(
this
.
_mayTabBeMultiselected
)
.
length
;
}
get
lastMultiSelectedTab
(
)
{
let
tab
=
this
.
_lastMultiSelectedTabRef
?
this
.
_lastMultiSelectedTabRef
.
get
(
)
:
null
;
if
(
tab
&
&
tab
.
isConnected
&
&
this
.
_multiSelectedTabsSet
.
has
(
tab
)
)
{
return
tab
;
}
let
selectedTab
=
this
.
selectedTab
;
this
.
lastMultiSelectedTab
=
selectedTab
;
return
selectedTab
;
}
set
lastMultiSelectedTab
(
aTab
)
{
this
.
_lastMultiSelectedTabRef
=
Cu
.
getWeakReference
(
aTab
)
;
}
_mayTabBeMultiselected
(
aTab
)
{
return
aTab
.
visible
;
}
_startMultiSelectChange
(
)
{
if
(
!
this
.
_multiSelectChangeStarted
)
{
this
.
_multiSelectChangeStarted
=
true
;
Promise
.
resolve
(
)
.
then
(
(
)
=
>
this
.
_endMultiSelectChange
(
)
)
;
}
}
_endMultiSelectChange
(
)
{
let
noticeable
=
false
;
let
{
selectedTab
}
=
this
;
if
(
this
.
_multiSelectChangeAdditions
.
size
)
{
if
(
!
selectedTab
.
multiselected
)
{
this
.
addToMultiSelectedTabs
(
selectedTab
)
;
}
noticeable
=
true
;
}
if
(
this
.
_multiSelectChangeRemovals
.
size
)
{
if
(
this
.
_multiSelectChangeRemovals
.
has
(
selectedTab
)
)
{
this
.
_switchToNextMultiSelectedTab
(
)
;
}
this
.
_avoidSingleSelectedTab
(
)
;
noticeable
=
true
;
}
this
.
_multiSelectChangeStarted
=
false
;
if
(
noticeable
|
|
this
.
_multiSelectChangeSelected
)
{
this
.
_multiSelectChangeSelected
=
false
;
this
.
_multiSelectChangeAdditions
.
clear
(
)
;
this
.
_multiSelectChangeRemovals
.
clear
(
)
;
this
.
dispatchEvent
(
new
CustomEvent
(
"
TabMultiSelect
"
{
bubbles
:
true
}
)
)
;
}
}
toggleMuteAudioOnMultiSelectedTabs
(
aTab
)
{
let
tabMuted
=
aTab
.
linkedBrowser
.
audioMuted
;
let
tabsToToggle
=
this
.
selectedTabs
.
filter
(
tab
=
>
tab
.
linkedBrowser
.
audioMuted
=
=
tabMuted
)
;
for
(
let
tab
of
tabsToToggle
)
{
tab
.
toggleMuteAudio
(
)
;
}
}
resumeDelayedMediaOnMultiSelectedTabs
(
)
{
for
(
let
tab
of
this
.
selectedTabs
)
{
tab
.
resumeDelayedMedia
(
)
;
}
}
pinMultiSelectedTabs
(
)
{
for
(
let
tab
of
this
.
selectedTabs
)
{
this
.
pinTab
(
tab
)
;
}
}
unpinMultiSelectedTabs
(
)
{
let
selectedTabs
=
this
.
selectedTabs
;
for
(
let
i
=
selectedTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
tab
=
selectedTabs
[
i
]
;
this
.
unpinTab
(
tab
)
;
}
}
activateBrowserForPrintPreview
(
aBrowser
)
{
this
.
_printPreviewBrowsers
.
add
(
aBrowser
)
;
if
(
this
.
_switcher
)
{
this
.
_switcher
.
activateBrowserForPrintPreview
(
aBrowser
)
;
}
aBrowser
.
docShellIsActive
=
true
;
}
deactivatePrintPreviewBrowsers
(
)
{
let
browsers
=
this
.
_printPreviewBrowsers
;
this
.
_printPreviewBrowsers
=
new
Set
(
)
;
for
(
let
browser
of
browsers
)
{
browser
.
docShellIsActive
=
this
.
shouldActivateDocShell
(
browser
)
;
}
}
shouldActivateDocShell
(
aBrowser
)
{
if
(
this
.
_switcher
)
{
return
this
.
_switcher
.
shouldActivateDocShell
(
aBrowser
)
;
}
return
(
(
aBrowser
=
=
this
.
selectedBrowser
&
&
!
document
.
hidden
)
|
|
this
.
_printPreviewBrowsers
.
has
(
aBrowser
)
|
|
this
.
PictureInPicture
.
isOriginatingBrowser
(
aBrowser
)
)
;
}
_getSwitcher
(
)
{
if
(
!
this
.
_switcher
)
{
this
.
_switcher
=
new
this
.
AsyncTabSwitcher
(
this
)
;
}
return
this
.
_switcher
;
}
warmupTab
(
aTab
)
{
if
(
gMultiProcessBrowser
)
{
this
.
_getSwitcher
(
)
.
warmupTab
(
aTab
)
;
}
}
_maybeRequestReplyFromRemoteContent
(
aEvent
)
{
if
(
aEvent
.
defaultPrevented
)
{
return
false
;
}
if
(
aEvent
.
isWaitingReplyFromRemoteContent
)
{
return
true
;
}
if
(
!
aEvent
.
isReplyEventFromRemoteContent
&
&
aEvent
.
target
?
.
isRemoteBrowser
=
=
=
true
)
{
aEvent
.
requestReplyFromRemoteContent
(
)
;
return
true
;
}
return
false
;
}
_handleKeyDownEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
;
}
if
(
aEvent
.
defaultCancelled
)
{
return
;
}
if
(
aEvent
.
defaultPreventedByChrome
)
{
return
;
}
switch
(
ShortcutUtils
.
getSystemActionForEvent
(
aEvent
)
)
{
case
ShortcutUtils
.
TOGGLE_CARET_BROWSING
:
this
.
_maybeRequestReplyFromRemoteContent
(
aEvent
)
;
return
;
case
ShortcutUtils
.
MOVE_TAB_BACKWARD
:
this
.
moveTabBackward
(
)
;
aEvent
.
preventDefault
(
)
;
return
;
case
ShortcutUtils
.
MOVE_TAB_FORWARD
:
this
.
moveTabForward
(
)
;
aEvent
.
preventDefault
(
)
;
return
;
case
ShortcutUtils
.
CLOSE_TAB
:
if
(
gBrowser
.
multiSelectedTabsCount
)
{
gBrowser
.
removeMultiSelectedTabs
(
)
;
}
else
if
(
!
this
.
selectedTab
.
pinned
)
{
this
.
removeCurrentTab
(
{
animate
:
true
}
)
;
}
aEvent
.
preventDefault
(
)
;
}
}
toggleCaretBrowsing
(
)
{
const
kPrefShortcutEnabled
=
"
accessibility
.
browsewithcaret_shortcut
.
enabled
"
;
const
kPrefWarnOnEnable
=
"
accessibility
.
warn_on_browsewithcaret
"
;
const
kPrefCaretBrowsingOn
=
"
accessibility
.
browsewithcaret
"
;
var
isEnabled
=
Services
.
prefs
.
getBoolPref
(
kPrefShortcutEnabled
)
;
if
(
!
isEnabled
|
|
this
.
_awaitingToggleCaretBrowsingPrompt
)
{
return
;
}
var
browseWithCaretOn
=
Services
.
prefs
.
getBoolPref
(
kPrefCaretBrowsingOn
false
)
;
var
warn
=
Services
.
prefs
.
getBoolPref
(
kPrefWarnOnEnable
true
)
;
if
(
warn
&
&
!
browseWithCaretOn
)
{
var
checkValue
=
{
value
:
false
}
;
var
promptService
=
Services
.
prompt
;
try
{
this
.
_awaitingToggleCaretBrowsingPrompt
=
true
;
const
[
title
message
checkbox
]
=
this
.
tabLocalization
.
formatValuesSync
(
[
"
tabbrowser
-
confirm
-
caretbrowsing
-
title
"
"
tabbrowser
-
confirm
-
caretbrowsing
-
message
"
"
tabbrowser
-
confirm
-
caretbrowsing
-
checkbox
"
]
)
;
var
buttonPressed
=
promptService
.
confirmEx
(
window
title
message
promptService
.
STD_YES_NO_BUTTONS
|
promptService
.
BUTTON_POS_1_DEFAULT
null
null
null
checkbox
checkValue
)
;
}
catch
(
ex
)
{
return
;
}
finally
{
this
.
_awaitingToggleCaretBrowsingPrompt
=
false
;
}
if
(
buttonPressed
!
=
0
)
{
if
(
checkValue
.
value
)
{
try
{
Services
.
prefs
.
setBoolPref
(
kPrefShortcutEnabled
false
)
;
}
catch
(
ex
)
{
}
}
return
;
}
if
(
checkValue
.
value
)
{
try
{
Services
.
prefs
.
setBoolPref
(
kPrefWarnOnEnable
false
)
;
}
catch
(
ex
)
{
}
}
}
try
{
Services
.
prefs
.
setBoolPref
(
kPrefCaretBrowsingOn
!
browseWithCaretOn
)
;
}
catch
(
ex
)
{
}
}
_handleKeyPressEvent
(
aEvent
)
{
if
(
!
aEvent
.
isTrusted
)
{
return
;
}
if
(
aEvent
.
defaultCancelled
)
{
return
;
}
if
(
aEvent
.
defaultPreventedByChrome
)
{
return
;
}
switch
(
ShortcutUtils
.
getSystemActionForEvent
(
aEvent
{
rtl
:
RTL_UI
}
)
)
{
case
ShortcutUtils
.
TOGGLE_CARET_BROWSING
:
if
(
aEvent
.
defaultPrevented
|
|
this
.
_maybeRequestReplyFromRemoteContent
(
aEvent
)
)
{
break
;
}
this
.
toggleCaretBrowsing
(
)
;
break
;
case
ShortcutUtils
.
NEXT_TAB
:
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
tabContainer
.
advanceSelectedTab
(
DIRECTION_FORWARD
true
)
;
aEvent
.
preventDefault
(
)
;
}
break
;
case
ShortcutUtils
.
PREVIOUS_TAB
:
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
tabContainer
.
advanceSelectedTab
(
DIRECTION_BACKWARD
true
)
;
aEvent
.
preventDefault
(
)
;
}
break
;
}
}
getTabPids
(
tab
)
{
if
(
!
tab
.
linkedBrowser
)
{
return
[
]
;
}
let
[
contentPid
.
.
.
framePids
]
=
E10SUtils
.
getBrowserPids
(
tab
.
linkedBrowser
gFissionBrowser
)
;
let
pids
=
contentPid
?
[
contentPid
]
:
[
]
;
return
pids
.
concat
(
framePids
.
sort
(
)
)
;
}
getTabTooltip
(
tab
includeLabel
=
true
)
{
let
labelArray
=
[
]
;
if
(
includeLabel
)
{
labelArray
.
push
(
tab
.
_fullLabel
|
|
tab
.
getAttribute
(
"
label
"
)
)
;
}
if
(
this
.
showPidAndActiveness
)
{
const
pids
=
this
.
getTabPids
(
tab
)
;
if
(
pids
.
length
)
{
let
pidLabel
=
pids
.
length
>
1
?
"
pids
"
:
"
pid
"
;
labelArray
.
push
(
(
{
pidLabel
}
{
pids
.
join
(
"
"
)
}
)
)
;
}
if
(
tab
.
linkedBrowser
.
docShellIsActive
)
{
labelArray
.
push
(
"
[
A
]
"
)
;
}
}
let
label
=
labelArray
.
join
(
"
"
)
;
if
(
tab
.
userContextId
)
{
const
containerName
=
ContextualIdentityService
.
getUserContextLabel
(
tab
.
userContextId
)
;
label
=
this
.
tabLocalization
.
formatValueSync
(
"
tabbrowser
-
container
-
tab
-
title
"
{
title
:
label
containerName
}
)
;
}
labelArray
=
[
label
]
;
if
(
tab
.
soundPlaying
)
{
let
audioPlayingString
=
this
.
tabLocalization
.
formatValueSync
(
"
tabbrowser
-
tab
-
audio
-
playing
-
description
"
)
;
labelArray
.
push
(
audioPlayingString
)
;
}
return
labelArray
.
join
(
"
\
n
"
)
;
}
createTooltip
(
event
)
{
event
.
stopPropagation
(
)
;
let
tab
=
event
.
target
.
triggerNode
?
.
closest
(
"
tab
"
)
;
if
(
!
tab
)
{
if
(
event
.
target
.
triggerNode
?
.
getRootNode
(
)
?
.
host
?
.
closest
(
"
tab
"
)
)
{
tab
=
event
.
target
.
triggerNode
?
.
getRootNode
(
)
.
host
.
closest
(
"
tab
"
)
;
}
else
{
event
.
preventDefault
(
)
;
return
;
}
}
const
tooltip
=
event
.
target
;
tooltip
.
removeAttribute
(
"
data
-
l10n
-
id
"
)
;
const
tabCount
=
this
.
selectedTabs
.
includes
(
tab
)
?
this
.
selectedTabs
.
length
:
1
;
if
(
tab
.
_overPlayingIcon
|
|
tab
.
_overAudioButton
)
{
let
l10nId
;
const
l10nArgs
=
{
tabCount
}
;
if
(
tab
.
selected
)
{
l10nId
=
tab
.
linkedBrowser
.
audioMuted
?
"
tabbrowser
-
unmute
-
tab
-
audio
-
tooltip
"
:
"
tabbrowser
-
mute
-
tab
-
audio
-
tooltip
"
;
const
keyElem
=
document
.
getElementById
(
"
key_toggleMute
"
)
;
l10nArgs
.
shortcut
=
ShortcutUtils
.
prettifyShortcut
(
keyElem
)
;
}
else
if
(
tab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
l10nId
=
"
tabbrowser
-
unblock
-
tab
-
audio
-
tooltip
"
;
}
else
{
l10nId
=
tab
.
linkedBrowser
.
audioMuted
?
"
tabbrowser
-
unmute
-
tab
-
audio
-
background
-
tooltip
"
:
"
tabbrowser
-
mute
-
tab
-
audio
-
background
-
tooltip
"
;
}
tooltip
.
label
=
"
"
;
document
.
l10n
.
setAttributes
(
tooltip
l10nId
l10nArgs
)
;
}
else
{
if
(
this
.
_showTabCardPreview
)
{
event
.
preventDefault
(
)
;
return
;
}
tooltip
.
label
=
this
.
getTabTooltip
(
tab
true
)
;
}
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
keydown
"
:
this
.
_handleKeyDownEvent
(
aEvent
)
;
break
;
case
"
keypress
"
:
this
.
_handleKeyPressEvent
(
aEvent
)
;
break
;
case
"
framefocusrequested
"
:
{
let
tab
=
this
.
getTabForBrowser
(
aEvent
.
target
)
;
if
(
!
tab
|
|
tab
=
=
this
.
selectedTab
)
{
break
;
}
this
.
selectedTab
=
tab
;
window
.
focus
(
)
;
aEvent
.
preventDefault
(
)
;
break
;
}
case
"
visibilitychange
"
:
{
const
inactive
=
document
.
hidden
;
if
(
!
this
.
_switcher
)
{
this
.
selectedBrowser
.
preserveLayers
(
inactive
)
;
this
.
selectedBrowser
.
docShellIsActive
=
!
inactive
;
}
break
;
}
case
"
TabGroupCreate
"
:
if
(
aEvent
.
detail
.
showCreateUI
)
{
this
.
tabGroupMenu
.
openCreateModal
(
aEvent
.
target
)
;
}
break
;
case
"
activate
"
:
case
"
deactivate
"
:
this
.
selectedTab
.
updateLastSeenActive
(
)
;
break
;
}
}
observe
(
aSubject
aTopic
)
{
switch
(
aTopic
)
{
case
"
contextual
-
identity
-
updated
"
:
{
let
identity
=
aSubject
.
wrappedJSObject
;
for
(
let
tab
of
this
.
tabs
)
{
if
(
tab
.
getAttribute
(
"
usercontextid
"
)
=
=
identity
.
userContextId
)
{
ContextualIdentityService
.
setTabStyle
(
tab
)
;
}
}
break
;
}
}
}
refreshBlocked
(
actor
browser
data
)
{
let
notificationBox
=
this
.
getNotificationBox
(
browser
)
;
let
notification
=
notificationBox
.
getNotificationWithValue
(
"
refresh
-
blocked
"
)
;
let
l10nId
=
data
.
sameURI
?
"
refresh
-
blocked
-
refresh
-
label
"
:
"
refresh
-
blocked
-
redirect
-
label
"
;
if
(
notification
)
{
notification
.
label
=
{
"
l10n
-
id
"
:
l10nId
}
;
}
else
{
const
buttons
=
[
{
"
l10n
-
id
"
:
"
refresh
-
blocked
-
allow
"
callback
(
)
{
actor
.
sendAsyncMessage
(
"
RefreshBlocker
:
Refresh
"
data
)
;
}
}
]
;
notificationBox
.
appendNotification
(
"
refresh
-
blocked
"
{
label
:
{
"
l10n
-
id
"
:
l10nId
}
image
:
"
chrome
:
/
/
browser
/
skin
/
notification
-
icons
/
popup
.
svg
"
priority
:
notificationBox
.
PRIORITY_INFO_MEDIUM
}
buttons
)
;
}
}
_generateUniquePanelID
(
)
{
if
(
!
this
.
_uniquePanelIDCounter
)
{
this
.
_uniquePanelIDCounter
=
0
;
}
let
outerID
=
window
.
docShell
.
outerWindowID
;
return
"
panel
-
"
+
outerID
+
"
-
"
+
+
+
this
.
_uniquePanelIDCounter
;
}
destroy
(
)
{
this
.
tabContainer
.
destroy
(
)
;
Services
.
obs
.
removeObserver
(
this
"
contextual
-
identity
-
updated
"
)
;
for
(
let
tab
of
this
.
tabs
)
{
let
browser
=
tab
.
linkedBrowser
;
if
(
browser
.
registeredOpenURI
)
{
let
userContextId
=
browser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
this
.
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
browser
.
registeredOpenURI
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
delete
browser
.
registeredOpenURI
;
}
let
filter
=
this
.
_tabFilters
.
get
(
tab
)
;
if
(
filter
)
{
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
let
listener
=
this
.
_tabListeners
.
get
(
tab
)
;
if
(
listener
)
{
filter
.
removeProgressListener
(
listener
)
;
listener
.
destroy
(
)
;
}
this
.
_tabFilters
.
delete
(
tab
)
;
this
.
_tabListeners
.
delete
(
tab
)
;
}
}
document
.
removeEventListener
(
"
keydown
"
this
{
mozSystemGroup
:
true
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
document
.
removeEventListener
(
"
keypress
"
this
{
mozSystemGroup
:
true
}
)
;
}
document
.
removeEventListener
(
"
visibilitychange
"
this
)
;
window
.
removeEventListener
(
"
framefocusrequested
"
this
)
;
window
.
removeEventListener
(
"
activate
"
this
)
;
window
.
removeEventListener
(
"
deactivate
"
this
)
;
if
(
gMultiProcessBrowser
)
{
if
(
this
.
_switcher
)
{
this
.
_switcher
.
destroy
(
)
;
}
}
}
_setupEventListeners
(
)
{
this
.
tabpanels
.
addEventListener
(
"
select
"
event
=
>
{
if
(
event
.
target
=
=
this
.
tabpanels
)
{
this
.
updateCurrentBrowser
(
)
;
}
}
)
;
this
.
addEventListener
(
"
DOMWindowClose
"
event
=
>
{
let
browser
=
event
.
target
;
if
(
!
browser
.
isRemoteBrowser
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
browser
=
event
.
target
.
docShell
.
chromeEventHandler
;
}
if
(
this
.
tabs
.
length
=
=
1
)
{
window
.
skipNextCanClose
=
true
;
window
.
close
(
)
;
return
;
}
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
tab
)
{
this
.
removeTab
(
tab
{
skipPermitUnload
:
true
}
)
;
event
.
preventDefault
(
)
;
}
}
)
;
this
.
addEventListener
(
"
pagetitlechanged
"
event
=
>
{
let
browser
=
event
.
target
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
|
|
tab
.
hasAttribute
(
"
pending
"
)
)
{
return
;
}
if
(
!
browser
.
contentTitle
&
&
browser
.
contentPrincipal
.
isSystemPrincipal
)
{
return
;
}
let
titleChanged
=
this
.
setTabTitle
(
tab
)
;
if
(
titleChanged
&
&
!
tab
.
selected
&
&
!
tab
.
hasAttribute
(
"
busy
"
)
)
{
tab
.
setAttribute
(
"
titlechanged
"
"
true
"
)
;
}
}
)
;
this
.
addEventListener
(
"
DOMWillOpenModalDialog
"
event
=
>
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
targetIsWindow
=
Window
.
isInstance
(
event
.
target
)
;
let
tabForEvent
=
targetIsWindow
?
this
.
getTabForBrowser
(
event
.
target
.
docShell
.
chromeEventHandler
)
:
this
.
getTabForBrowser
(
event
.
originalTarget
)
;
if
(
event
.
detail
&
&
event
.
detail
.
tabPrompt
&
&
event
.
detail
.
inPermitUnload
&
&
Services
.
focus
.
activeWindow
)
{
window
.
focus
(
)
;
}
if
(
!
tabForEvent
|
|
tabForEvent
.
selected
)
{
return
;
}
if
(
event
.
detail
&
&
event
.
detail
.
tabPrompt
&
&
!
event
.
detail
.
inPermitUnload
)
{
let
docPrincipal
=
targetIsWindow
?
event
.
target
.
document
.
nodePrincipal
:
null
;
let
promptPrincipal
=
event
.
detail
.
promptPrincipal
|
|
docPrincipal
|
|
tabForEvent
.
linkedBrowser
.
contentPrincipal
;
if
(
!
promptPrincipal
|
|
promptPrincipal
.
isNullPrincipal
)
{
tabForEvent
.
attention
=
true
;
return
;
}
if
(
promptPrincipal
.
URI
&
&
!
promptPrincipal
.
isSystemPrincipal
)
{
let
permission
=
Services
.
perms
.
testPermissionFromPrincipal
(
promptPrincipal
"
focus
-
tab
-
by
-
prompt
"
)
;
if
(
permission
!
=
Services
.
perms
.
ALLOW_ACTION
)
{
let
tabPrompt
=
this
.
getTabDialogBox
(
tabForEvent
.
linkedBrowser
)
;
tabPrompt
.
onNextPromptShowAllowFocusCheckboxFor
(
promptPrincipal
)
;
tabForEvent
.
attention
=
true
;
return
;
}
}
}
this
.
selectedTab
=
tabForEvent
;
}
true
)
;
this
.
addEventListener
(
"
DOMModalDialogClosed
"
event
=
>
{
if
(
event
.
detail
?
.
promptType
!
=
"
beforeunload
"
|
|
event
.
detail
.
areLeaving
|
|
event
.
target
.
nodeName
!
=
"
browser
"
)
{
return
;
}
event
.
target
.
userTypedValue
=
null
;
if
(
event
.
target
=
=
this
.
selectedBrowser
)
{
gURLBar
.
setURI
(
)
;
}
}
true
)
;
let
onTabCrashed
=
event
=
>
{
if
(
!
event
.
isTrusted
)
{
return
;
}
let
browser
=
event
.
originalTarget
;
if
(
!
event
.
isTopFrame
)
{
TabCrashHandler
.
onSubFrameCrash
(
browser
event
.
childID
)
;
return
;
}
if
(
browser
=
=
=
this
.
preloadedBrowser
)
{
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
return
;
}
let
isRestartRequiredCrash
=
event
.
type
=
=
"
oop
-
browser
-
buildid
-
mismatch
"
;
let
icon
=
browser
.
mIconURL
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
this
.
selectedBrowser
=
=
browser
)
{
TabCrashHandler
.
onSelectedBrowserCrash
(
browser
isRestartRequiredCrash
)
;
}
else
{
TabCrashHandler
.
onBackgroundBrowserCrash
(
browser
isRestartRequiredCrash
)
;
}
tab
.
removeAttribute
(
"
soundplaying
"
)
;
this
.
setIcon
(
tab
icon
)
;
}
;
this
.
addEventListener
(
"
oop
-
browser
-
crashed
"
onTabCrashed
)
;
this
.
addEventListener
(
"
oop
-
browser
-
buildid
-
mismatch
"
onTabCrashed
)
;
this
.
addEventListener
(
"
DOMAudioPlaybackStarted
"
event
=
>
{
var
tab
=
this
.
getTabFromAudioEvent
(
event
)
;
if
(
!
tab
)
{
return
;
}
clearTimeout
(
tab
.
_soundPlayingAttrRemovalTimer
)
;
tab
.
_soundPlayingAttrRemovalTimer
=
0
;
let
modifiedAttrs
=
[
]
;
if
(
tab
.
hasAttribute
(
"
soundplaying
-
scheduledremoval
"
)
)
{
tab
.
removeAttribute
(
"
soundplaying
-
scheduledremoval
"
)
;
modifiedAttrs
.
push
(
"
soundplaying
-
scheduledremoval
"
)
;
}
if
(
!
tab
.
hasAttribute
(
"
soundplaying
"
)
)
{
tab
.
toggleAttribute
(
"
soundplaying
"
true
)
;
modifiedAttrs
.
push
(
"
soundplaying
"
)
;
}
if
(
modifiedAttrs
.
length
)
{
getComputedStyle
(
tab
)
.
opacity
;
}
this
.
_tabAttrModified
(
tab
modifiedAttrs
)
;
}
)
;
this
.
addEventListener
(
"
DOMAudioPlaybackStopped
"
event
=
>
{
var
tab
=
this
.
getTabFromAudioEvent
(
event
)
;
if
(
!
tab
)
{
return
;
}
if
(
tab
.
hasAttribute
(
"
soundplaying
"
)
)
{
let
removalDelay
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
delayHidingAudioPlayingIconMS
"
)
;
tab
.
style
.
setProperty
(
"
-
-
soundplaying
-
removal
-
delay
"
{
removalDelay
-
300
}
ms
)
;
tab
.
toggleAttribute
(
"
soundplaying
-
scheduledremoval
"
true
)
;
this
.
_tabAttrModified
(
tab
[
"
soundplaying
-
scheduledremoval
"
]
)
;
tab
.
_soundPlayingAttrRemovalTimer
=
setTimeout
(
(
)
=
>
{
tab
.
removeAttribute
(
"
soundplaying
-
scheduledremoval
"
)
;
tab
.
removeAttribute
(
"
soundplaying
"
)
;
this
.
_tabAttrModified
(
tab
[
"
soundplaying
"
"
soundplaying
-
scheduledremoval
"
]
)
;
}
removalDelay
)
;
}
}
)
;
this
.
addEventListener
(
"
DOMAudioPlaybackBlockStarted
"
event
=
>
{
var
tab
=
this
.
getTabFromAudioEvent
(
event
)
;
if
(
!
tab
)
{
return
;
}
if
(
!
tab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
tab
.
setAttribute
(
"
activemedia
-
blocked
"
true
)
;
this
.
_tabAttrModified
(
tab
[
"
activemedia
-
blocked
"
]
)
;
}
}
)
;
this
.
addEventListener
(
"
DOMAudioPlaybackBlockStopped
"
event
=
>
{
var
tab
=
this
.
getTabFromAudioEvent
(
event
)
;
if
(
!
tab
)
{
return
;
}
if
(
tab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
tab
.
removeAttribute
(
"
activemedia
-
blocked
"
)
;
this
.
_tabAttrModified
(
tab
[
"
activemedia
-
blocked
"
]
)
;
}
}
)
;
this
.
addEventListener
(
"
GloballyAutoplayBlocked
"
event
=
>
{
let
browser
=
event
.
originalTarget
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
SitePermissions
.
setForPrincipal
(
browser
.
contentPrincipal
"
autoplay
-
media
"
SitePermissions
.
BLOCK
SitePermissions
.
SCOPE_GLOBAL
browser
)
;
}
)
;
let
tabContextFTLInserter
=
(
)
=
>
{
this
.
translateTabContextMenu
(
)
;
this
.
tabContainer
.
removeEventListener
(
"
contextmenu
"
tabContextFTLInserter
true
)
;
this
.
tabContainer
.
removeEventListener
(
"
mouseover
"
tabContextFTLInserter
)
;
this
.
tabContainer
.
removeEventListener
(
"
focus
"
tabContextFTLInserter
true
)
;
}
;
this
.
tabContainer
.
addEventListener
(
"
contextmenu
"
tabContextFTLInserter
true
)
;
this
.
tabContainer
.
addEventListener
(
"
mouseover
"
tabContextFTLInserter
)
;
this
.
tabContainer
.
addEventListener
(
"
focus
"
tabContextFTLInserter
true
)
;
this
.
addEventListener
(
"
WillChangeBrowserRemoteness
"
event
=
>
{
let
browser
=
event
.
originalTarget
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
let
evt
=
document
.
createEvent
(
"
Events
"
)
;
evt
.
initEvent
(
"
BeforeTabRemotenessChange
"
true
false
)
;
tab
.
dispatchEvent
(
evt
)
;
let
filter
=
this
.
_tabFilters
.
get
(
tab
)
;
let
oldListener
=
this
.
_tabListeners
.
get
(
tab
)
;
browser
.
webProgress
.
removeProgressListener
(
filter
)
;
filter
.
removeProgressListener
(
oldListener
)
;
let
stateFlags
=
oldListener
.
mStateFlags
;
let
requestCount
=
oldListener
.
mRequestCount
;
oldListener
.
destroy
(
)
;
let
oldDroppedLinkHandler
=
browser
.
droppedLinkHandler
;
let
oldUserTypedValue
=
browser
.
userTypedValue
;
let
hadStartedLoad
=
browser
.
didStartLoadSinceLastUserTyping
(
)
;
let
didChange
=
(
)
=
>
{
browser
.
userTypedValue
=
oldUserTypedValue
;
if
(
hadStartedLoad
)
{
browser
.
urlbarChangeTracker
.
startedLoad
(
)
;
}
browser
.
droppedLinkHandler
=
oldDroppedLinkHandler
;
browser
.
docShellIsActive
=
browser
.
docShellIsActive
;
let
listener
=
new
TabProgressListener
(
tab
browser
false
false
stateFlags
requestCount
)
;
this
.
_tabListeners
.
set
(
tab
listener
)
;
filter
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
browser
.
webProgress
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
let
cbEvent
=
browser
.
getContentBlockingEvents
(
)
;
this
.
_callProgressListeners
(
browser
"
onContentBlockingEvent
"
[
browser
.
webProgress
null
cbEvent
true
]
true
false
)
;
if
(
browser
.
isRemoteBrowser
)
{
tab
.
removeAttribute
(
"
crashed
"
)
;
}
if
(
this
.
isFindBarInitialized
(
tab
)
)
{
this
.
getCachedFindBar
(
tab
)
.
browser
=
browser
;
}
evt
=
document
.
createEvent
(
"
Events
"
)
;
evt
.
initEvent
(
"
TabRemotenessChange
"
true
false
)
;
tab
.
dispatchEvent
(
evt
)
;
}
;
browser
.
addEventListener
(
"
DidChangeBrowserRemoteness
"
didChange
{
once
:
true
}
)
;
}
)
;
this
.
addEventListener
(
"
pageinfo
"
event
=
>
{
let
browser
=
event
.
originalTarget
;
let
tab
=
this
.
getTabForBrowser
(
browser
)
;
if
(
!
tab
)
{
return
;
}
const
{
url
description
previewImageURL
}
=
event
.
detail
;
this
.
setPageInfo
(
url
description
previewImageURL
)
;
}
)
;
}
translateTabContextMenu
(
)
{
if
(
this
.
_tabContextMenuTranslated
)
{
return
;
}
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
tabContextMenu
.
ftl
"
)
;
document
.
getElementById
(
"
tabContextMenu
"
)
.
querySelectorAll
(
"
[
data
-
lazy
-
l10n
-
id
]
"
)
.
forEach
(
el
=
>
{
el
.
setAttribute
(
"
data
-
l10n
-
id
"
el
.
getAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
)
;
el
.
removeAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
;
}
)
;
this
.
_tabContextMenuTranslated
=
true
;
}
setSuccessor
(
aTab
successorTab
)
{
if
(
aTab
.
ownerGlobal
!
=
window
)
{
throw
new
Error
(
"
Cannot
set
the
successor
of
another
window
'
s
tab
"
)
;
}
if
(
successorTab
=
=
aTab
)
{
successorTab
=
null
;
}
if
(
successorTab
&
&
successorTab
.
ownerGlobal
!
=
window
)
{
throw
new
Error
(
"
Cannot
set
the
successor
to
another
window
'
s
tab
"
)
;
}
if
(
aTab
.
successor
)
{
aTab
.
successor
.
predecessors
.
delete
(
aTab
)
;
}
aTab
.
successor
=
successorTab
;
if
(
successorTab
)
{
if
(
!
successorTab
.
predecessors
)
{
successorTab
.
predecessors
=
new
Set
(
)
;
}
successorTab
.
predecessors
.
add
(
aTab
)
;
}
}
replaceInSuccession
(
aTab
aOtherTab
)
{
if
(
aTab
.
predecessors
)
{
for
(
const
predecessor
of
Array
.
from
(
aTab
.
predecessors
)
)
{
this
.
setSuccessor
(
predecessor
aOtherTab
)
;
}
}
}
_getTriggeringPrincipalFromHistory
(
aBrowser
)
{
let
sessionHistory
=
aBrowser
?
.
browsingContext
?
.
sessionHistory
;
if
(
!
sessionHistory
|
|
!
sessionHistory
.
index
|
|
sessionHistory
.
count
=
=
0
)
{
return
undefined
;
}
let
currentEntry
=
sessionHistory
.
getEntryAtIndex
(
sessionHistory
.
index
)
;
let
triggeringPrincipal
=
currentEntry
?
.
triggeringPrincipal
;
return
triggeringPrincipal
;
}
clearRelatedTabs
(
)
{
this
.
_lastRelatedTabMap
=
new
WeakMap
(
)
;
}
}
;
class
TabProgressListener
{
constructor
(
aTab
aBrowser
aStartsBlank
aWasPreloadedBrowser
aOrigStateFlags
aOrigRequestCount
)
{
let
stateFlags
=
aOrigStateFlags
|
|
0
;
if
(
aWasPreloadedBrowser
)
{
stateFlags
=
Ci
.
nsIWebProgressListener
.
STATE_STOP
|
Ci
.
nsIWebProgressListener
.
STATE_IS_REQUEST
;
}
this
.
mTab
=
aTab
;
this
.
mBrowser
=
aBrowser
;
this
.
mBlank
=
aStartsBlank
;
this
.
mStateFlags
=
stateFlags
;
this
.
mStatus
=
0
;
this
.
mMessage
=
"
"
;
this
.
mTotalProgress
=
0
;
this
.
mRequestCount
=
aOrigRequestCount
|
|
0
;
}
destroy
(
)
{
delete
this
.
mTab
;
delete
this
.
mBrowser
;
}
_callProgressListeners
(
.
.
.
args
)
{
args
.
unshift
(
this
.
mBrowser
)
;
return
gBrowser
.
_callProgressListeners
.
apply
(
gBrowser
args
)
;
}
_shouldShowProgress
(
aRequest
)
{
if
(
this
.
mBlank
)
{
return
false
;
}
if
(
aRequest
instanceof
Ci
.
nsIChannel
&
&
aRequest
.
originalURI
.
schemeIs
(
"
about
"
)
)
{
return
false
;
}
return
true
;
}
_isForInitialAboutBlank
(
aWebProgress
aStateFlags
aLocation
)
{
if
(
!
this
.
mBlank
|
|
!
aWebProgress
.
isTopLevel
)
{
return
false
;
}
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
this
.
mRequestCount
=
=
0
&
&
!
aLocation
)
{
return
true
;
}
let
location
=
aLocation
?
aLocation
.
spec
:
"
"
;
return
location
=
=
"
about
:
blank
"
;
}
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
this
.
mTotalProgress
=
aMaxTotalProgress
?
aCurTotalProgress
/
aMaxTotalProgress
:
0
;
if
(
!
this
.
_shouldShowProgress
(
aRequest
)
)
{
return
;
}
if
(
this
.
mTotalProgress
&
&
this
.
mTab
.
hasAttribute
(
"
busy
"
)
)
{
this
.
mTab
.
setAttribute
(
"
progress
"
"
true
"
)
;
gBrowser
.
_tabAttrModified
(
this
.
mTab
[
"
progress
"
]
)
;
}
this
.
_callProgressListeners
(
"
onProgressChange
"
[
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
]
)
;
}
onProgressChange64
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
return
this
.
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
;
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
!
aRequest
)
{
return
;
}
let
location
originalLocation
;
try
{
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
location
=
aRequest
.
URI
;
originalLocation
=
aRequest
.
originalURI
;
}
catch
(
ex
)
{
}
let
ignoreBlank
=
this
.
_isForInitialAboutBlank
(
aWebProgress
aStateFlags
location
)
;
const
{
STATE_START
STATE_STOP
STATE_IS_NETWORK
}
=
Ci
.
nsIWebProgressListener
;
if
(
(
ignoreBlank
&
&
aStateFlags
&
STATE_STOP
&
&
aStateFlags
&
STATE_IS_NETWORK
)
|
|
(
!
ignoreBlank
&
&
this
.
mBlank
)
)
{
this
.
mBlank
=
false
;
}
if
(
aStateFlags
&
STATE_START
&
&
aStateFlags
&
STATE_IS_NETWORK
)
{
this
.
mRequestCount
+
+
;
if
(
aWebProgress
.
isTopLevel
)
{
if
(
!
(
originalLocation
&
&
gInitialPages
.
includes
(
originalLocation
.
spec
)
&
&
originalLocation
!
=
"
about
:
blank
"
&
&
this
.
mBrowser
.
initialPageLoadedFromUserAction
!
=
originalLocation
.
spec
&
&
this
.
mBrowser
.
currentURI
&
&
this
.
mBrowser
.
currentURI
.
spec
=
=
"
about
:
blank
"
)
)
{
this
.
mBrowser
.
urlbarChangeTracker
.
startedLoad
(
)
;
if
(
this
.
mBrowser
.
browsingContext
.
sessionHistory
?
.
count
=
=
=
0
&
&
BrowserUIUtils
.
checkEmptyPageOrigin
(
this
.
mBrowser
originalLocation
)
)
{
gBrowser
.
setInitialTabTitle
(
this
.
mTab
originalLocation
.
spec
{
isURL
:
true
}
)
;
this
.
mBrowser
.
browsingContext
.
nonWebControlledBlankURI
=
originalLocation
;
if
(
this
.
mTab
.
selected
&
&
!
gBrowser
.
userTypedValue
)
{
gURLBar
.
setURI
(
)
;
}
}
}
delete
this
.
mBrowser
.
initialPageLoadedFromUserAction
;
this
.
mTab
.
removeAttribute
(
"
crashed
"
)
;
}
if
(
this
.
_shouldShowProgress
(
aRequest
)
)
{
if
(
!
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_RESTORING
)
&
&
aWebProgress
&
&
aWebProgress
.
isTopLevel
)
{
this
.
mTab
.
setAttribute
(
"
busy
"
"
true
"
)
;
gBrowser
.
_tabAttrModified
(
this
.
mTab
[
"
busy
"
]
)
;
this
.
mTab
.
_notselectedsinceload
=
!
this
.
mTab
.
selected
;
}
if
(
this
.
mTab
.
selected
)
{
gBrowser
.
_isBusy
=
true
;
}
}
}
else
if
(
aStateFlags
&
STATE_STOP
&
&
aStateFlags
&
STATE_IS_NETWORK
)
{
this
.
mRequestCount
=
0
;
let
modifiedAttrs
=
[
]
;
if
(
this
.
mTab
.
hasAttribute
(
"
busy
"
)
)
{
this
.
mTab
.
removeAttribute
(
"
busy
"
)
;
modifiedAttrs
.
push
(
"
busy
"
)
;
if
(
aWebProgress
.
isTopLevel
&
&
!
aWebProgress
.
isLoadingDocument
&
&
Components
.
isSuccessCode
(
aStatus
)
&
&
!
gBrowser
.
tabAnimationsInProgress
&
&
!
gReduceMotion
)
{
if
(
this
.
mTab
.
_notselectedsinceload
)
{
this
.
mTab
.
setAttribute
(
"
notselectedsinceload
"
"
true
"
)
;
}
else
{
this
.
mTab
.
removeAttribute
(
"
notselectedsinceload
"
)
;
}
this
.
mTab
.
setAttribute
(
"
bursting
"
"
true
"
)
;
}
}
if
(
this
.
mTab
.
hasAttribute
(
"
progress
"
)
)
{
this
.
mTab
.
removeAttribute
(
"
progress
"
)
;
modifiedAttrs
.
push
(
"
progress
"
)
;
}
if
(
modifiedAttrs
.
length
)
{
gBrowser
.
_tabAttrModified
(
this
.
mTab
modifiedAttrs
)
;
}
if
(
aWebProgress
.
isTopLevel
)
{
let
isSuccessful
=
Components
.
isSuccessCode
(
aStatus
)
;
if
(
!
isSuccessful
&
&
!
this
.
mTab
.
isEmpty
)
{
this
.
mBrowser
.
userTypedValue
=
null
;
let
isNavigating
=
this
.
mBrowser
.
isNavigating
;
if
(
this
.
mTab
.
selected
&
&
aStatus
!
=
Cr
.
NS_BINDING_CANCELLED_OLD_LOAD
&
&
!
isNavigating
)
{
gURLBar
.
setURI
(
)
;
}
}
else
if
(
isSuccessful
)
{
this
.
mBrowser
.
urlbarChangeTracker
.
finishedLoad
(
)
;
}
}
if
(
!
this
.
mBrowser
.
mIconURL
&
&
!
ignoreBlank
&
&
!
(
originalLocation
.
spec
in
FAVICON_DEFAULTS
)
)
{
this
.
mTab
.
removeAttribute
(
"
image
"
)
;
}
else
{
gBrowser
.
setDefaultIcon
(
this
.
mTab
this
.
mBrowser
.
_documentURI
)
;
}
if
(
location
.
scheme
=
=
"
keyword
"
)
{
this
.
mBrowser
.
userTypedValue
=
null
;
}
if
(
this
.
mTab
.
selected
)
{
gBrowser
.
_isBusy
=
false
;
}
}
if
(
ignoreBlank
)
{
this
.
_callProgressListeners
(
"
onUpdateCurrentBrowser
"
[
aStateFlags
aStatus
"
"
0
]
true
false
)
;
}
else
{
this
.
_callProgressListeners
(
"
onStateChange
"
[
aWebProgress
aRequest
aStateFlags
aStatus
]
true
false
)
;
}
this
.
_callProgressListeners
(
"
onStateChange
"
[
aWebProgress
aRequest
aStateFlags
aStatus
]
false
)
;
if
(
aStateFlags
&
(
STATE_START
|
STATE_STOP
)
)
{
this
.
mMessage
=
"
"
;
this
.
mTotalProgress
=
0
;
}
this
.
mStateFlags
=
aStateFlags
;
this
.
mStatus
=
aStatus
;
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
let
topLevel
=
aWebProgress
.
isTopLevel
;
let
isSameDocument
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
;
if
(
topLevel
)
{
let
isReload
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_RELOAD
)
;
let
isErrorPage
=
!
!
(
aFlags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
;
if
(
this
.
mBrowser
.
didStartLoadSinceLastUserTyping
(
)
|
|
(
isErrorPage
&
&
aLocation
.
spec
!
=
"
about
:
blank
"
)
|
|
(
isSameDocument
&
&
this
.
mBrowser
.
isNavigating
)
|
|
(
isSameDocument
&
&
!
this
.
mBrowser
.
userTypedValue
)
)
{
this
.
mBrowser
.
userTypedValue
=
null
;
}
if
(
isErrorPage
&
&
this
.
mTab
.
hasAttribute
(
"
busy
"
)
)
{
this
.
mTab
.
removeAttribute
(
"
busy
"
)
;
gBrowser
.
_tabAttrModified
(
this
.
mTab
[
"
busy
"
]
)
;
}
if
(
!
isSameDocument
)
{
if
(
this
.
mTab
.
hasAttribute
(
"
soundplaying
"
)
)
{
clearTimeout
(
this
.
mTab
.
_soundPlayingAttrRemovalTimer
)
;
this
.
mTab
.
_soundPlayingAttrRemovalTimer
=
0
;
this
.
mTab
.
removeAttribute
(
"
soundplaying
"
)
;
gBrowser
.
_tabAttrModified
(
this
.
mTab
[
"
soundplaying
"
]
)
;
}
if
(
this
.
mTab
.
hasAttribute
(
"
muted
"
)
)
{
this
.
mTab
.
linkedBrowser
.
mute
(
)
;
}
if
(
gBrowser
.
isFindBarInitialized
(
this
.
mTab
)
)
{
let
findBar
=
gBrowser
.
getCachedFindBar
(
this
.
mTab
)
;
if
(
findBar
.
findMode
!
=
findBar
.
FIND_NORMAL
)
{
findBar
.
close
(
)
;
}
}
if
(
!
isReload
)
{
gBrowser
.
setTabTitle
(
this
.
mTab
)
;
}
if
(
!
this
.
mTab
.
hasAttribute
(
"
pending
"
)
&
&
!
this
.
mTab
.
hasAttribute
(
"
customizemode
"
)
&
&
aWebProgress
.
isLoadingDocument
)
{
this
.
mBrowser
.
mIconURL
=
null
;
}
if
(
!
isReload
&
&
aWebProgress
.
isLoadingDocument
)
{
let
triggerer
=
gBrowser
.
_getTriggeringPrincipalFromHistory
(
this
.
mBrowser
)
;
if
(
triggerer
&
&
triggerer
.
isSystemPrincipal
)
{
gBrowser
.
clearRelatedTabs
(
)
;
}
}
if
(
aRequest
instanceof
Ci
.
nsIChannel
&
&
!
isBlankPageURL
(
aRequest
.
originalURI
.
spec
)
)
{
this
.
mBrowser
.
originalURI
=
aRequest
.
originalURI
;
}
}
let
userContextId
=
this
.
mBrowser
.
getAttribute
(
"
usercontextid
"
)
|
|
0
;
if
(
this
.
mBrowser
.
registeredOpenURI
)
{
let
uri
=
this
.
mBrowser
.
registeredOpenURI
;
gBrowser
.
UrlbarProviderOpenTabs
.
unregisterOpenTab
(
uri
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
delete
this
.
mBrowser
.
registeredOpenURI
;
}
if
(
!
isBlankPageURL
(
aLocation
.
spec
)
)
{
gBrowser
.
UrlbarProviderOpenTabs
.
registerOpenTab
(
aLocation
.
spec
userContextId
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
;
this
.
mBrowser
.
registeredOpenURI
=
aLocation
;
}
if
(
this
.
mTab
!
=
gBrowser
.
selectedTab
)
{
let
tabCacheIndex
=
gBrowser
.
_tabLayerCache
.
indexOf
(
this
.
mTab
)
;
if
(
tabCacheIndex
!
=
-
1
)
{
gBrowser
.
_tabLayerCache
.
splice
(
tabCacheIndex
1
)
;
gBrowser
.
_getSwitcher
(
)
.
cleanUpTabAfterEviction
(
this
.
mTab
)
;
}
}
}
if
(
!
this
.
mBlank
|
|
this
.
mBrowser
.
hasContentOpener
)
{
this
.
_callProgressListeners
(
"
onLocationChange
"
[
aWebProgress
aRequest
aLocation
aFlags
]
)
;
if
(
topLevel
&
&
!
isSameDocument
)
{
this
.
_callProgressListeners
(
"
onContentBlockingEvent
"
[
aWebProgress
null
0
true
]
)
;
}
}
if
(
topLevel
)
{
this
.
mBrowser
.
lastURI
=
aLocation
;
this
.
mBrowser
.
lastLocationChange
=
Date
.
now
(
)
;
}
}
onStatusChange
(
aWebProgress
aRequest
aStatus
aMessage
)
{
if
(
this
.
mBlank
)
{
return
;
}
this
.
_callProgressListeners
(
"
onStatusChange
"
[
aWebProgress
aRequest
aStatus
aMessage
]
)
;
this
.
mMessage
=
aMessage
;
}
onSecurityChange
(
aWebProgress
aRequest
aState
)
{
this
.
_callProgressListeners
(
"
onSecurityChange
"
[
aWebProgress
aRequest
aState
]
)
;
}
onContentBlockingEvent
(
aWebProgress
aRequest
aEvent
)
{
this
.
_callProgressListeners
(
"
onContentBlockingEvent
"
[
aWebProgress
aRequest
aEvent
]
)
;
}
onRefreshAttempted
(
aWebProgress
aURI
aDelay
aSameURI
)
{
return
this
.
_callProgressListeners
(
"
onRefreshAttempted
"
[
aWebProgress
aURI
aDelay
aSameURI
]
)
;
}
}
TabProgressListener
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsIWebProgressListener2
"
"
nsISupportsWeakReference
"
]
)
;
let
URILoadingWrapper
=
{
_normalizeLoadURIOptions
(
browser
loadURIOptions
)
{
if
(
!
loadURIOptions
.
triggeringPrincipal
)
{
throw
new
Error
(
"
Must
load
with
a
triggering
Principal
"
)
;
}
if
(
loadURIOptions
.
userContextId
&
&
loadURIOptions
.
userContextId
!
=
browser
.
getAttribute
(
"
usercontextid
"
)
)
{
throw
new
Error
(
"
Cannot
load
with
mismatched
userContextId
"
)
;
}
loadURIOptions
.
loadFlags
|
=
loadURIOptions
.
flags
|
LOAD_FLAGS_NONE
;
delete
loadURIOptions
.
flags
;
loadURIOptions
.
hasValidUserGestureActivation
?
?
=
document
.
hasValidTransientUserGestureActivation
;
}
_loadFlagsToFixupFlags
(
browser
loadFlags
)
{
let
fixupFlags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_NONE
;
if
(
loadFlags
&
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
}
if
(
loadFlags
&
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
;
}
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
)
{
fixupFlags
|
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
return
fixupFlags
;
}
_fixupURIString
(
browser
uriString
loadURIOptions
)
{
let
fixupFlags
=
this
.
_loadFlagsToFixupFlags
(
browser
loadURIOptions
.
loadFlags
)
;
try
{
let
fixupInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
uriString
fixupFlags
)
;
return
fixupInfo
.
preferredURI
;
}
catch
(
e
)
{
}
return
null
;
}
_handleUriInChrome
(
aBrowser
aUri
)
{
if
(
aUri
.
scheme
=
=
"
file
"
)
{
try
{
let
mimeType
=
Cc
[
"
mozilla
.
org
/
mime
;
1
"
]
.
getService
(
Ci
.
nsIMIMEService
)
.
getTypeFromURI
(
aUri
)
;
if
(
mimeType
=
=
"
application
/
x
-
xpinstall
"
)
{
let
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
AddonManager
.
getInstallForURL
(
aUri
.
spec
{
telemetryInfo
:
{
source
:
"
file
-
url
"
}
}
)
.
then
(
install
=
>
{
AddonManager
.
installAddonFromWebpage
(
mimeType
aBrowser
systemPrincipal
install
)
;
}
)
;
return
true
;
}
}
catch
(
e
)
{
return
false
;
}
}
return
false
;
}
_updateTriggerMetadataForLoad
(
browser
uriString
{
loadFlags
globalHistoryOptions
}
)
{
if
(
globalHistoryOptions
?
.
triggeringSponsoredURL
)
{
try
{
const
triggeringSponsoredURL
=
Services
.
uriFixup
.
getFixupURIInfo
(
globalHistoryOptions
.
triggeringSponsoredURL
this
.
_loadFlagsToFixupFlags
(
browser
loadFlags
)
)
.
fixedURI
.
spec
;
browser
.
setAttribute
(
"
triggeringSponsoredURL
"
triggeringSponsoredURL
)
;
const
time
=
globalHistoryOptions
.
triggeringSponsoredURLVisitTimeMS
|
|
Date
.
now
(
)
;
browser
.
setAttribute
(
"
triggeringSponsoredURLVisitTimeMS
"
time
)
;
}
catch
(
e
)
{
}
}
if
(
globalHistoryOptions
?
.
triggeringSearchEngine
)
{
browser
.
setAttribute
(
"
triggeringSearchEngine
"
globalHistoryOptions
.
triggeringSearchEngine
)
;
browser
.
setAttribute
(
"
triggeringSearchEngineURL
"
uriString
)
;
}
else
{
browser
.
removeAttribute
(
"
triggeringSearchEngine
"
)
;
browser
.
removeAttribute
(
"
triggeringSearchEngineURL
"
)
;
}
}
fixupAndLoadURIString
(
browser
uriString
loadURIOptions
=
{
}
)
{
this
.
_internalMaybeFixupLoadURI
(
browser
uriString
null
loadURIOptions
)
;
}
loadURI
(
browser
uri
loadURIOptions
=
{
}
)
{
this
.
_internalMaybeFixupLoadURI
(
browser
"
"
uri
loadURIOptions
)
;
}
_internalMaybeFixupLoadURI
(
browser
uriString
uri
loadURIOptions
)
{
this
.
_normalizeLoadURIOptions
(
browser
loadURIOptions
)
;
if
(
!
uriString
&
&
!
uri
)
{
uri
=
Services
.
io
.
newURI
(
"
about
:
blank
"
)
;
}
let
startedWithURI
=
!
!
uri
;
if
(
!
uri
)
{
uri
=
this
.
_fixupURIString
(
browser
uriString
loadURIOptions
)
;
}
if
(
uri
&
&
this
.
_handleUriInChrome
(
browser
uri
)
)
{
return
;
}
this
.
_updateTriggerMetadataForLoad
(
browser
uriString
|
|
uri
.
spec
loadURIOptions
)
;
browser
.
isNavigating
=
true
;
try
{
if
(
startedWithURI
)
{
browser
.
webNavigation
.
loadURI
(
uri
loadURIOptions
)
;
}
else
{
browser
.
webNavigation
.
fixupAndLoadURIString
(
uriString
loadURIOptions
)
;
}
}
finally
{
browser
.
isNavigating
=
false
;
}
}
}
;
}
var
StatusPanel
=
{
_frozen
:
false
get
panel
(
)
{
delete
this
.
panel
;
this
.
panel
=
document
.
getElementById
(
"
statuspanel
"
)
;
this
.
panel
.
addEventListener
(
"
transitionend
"
this
.
_onTransitionEnd
.
bind
(
this
)
)
;
this
.
panel
.
addEventListener
(
"
transitioncancel
"
this
.
_onTransitionEnd
.
bind
(
this
)
)
;
return
this
.
panel
;
}
get
isVisible
(
)
{
return
!
this
.
panel
.
hasAttribute
(
"
inactive
"
)
;
}
update
(
)
{
if
(
BrowserHandler
.
kiosk
|
|
this
.
_frozen
)
{
return
;
}
let
text
;
let
type
;
let
types
=
[
"
overLink
"
]
;
if
(
XULBrowserWindow
.
busyUI
)
{
types
.
push
(
"
status
"
)
;
}
types
.
push
(
"
defaultStatus
"
)
;
for
(
type
of
types
)
{
if
(
(
text
=
XULBrowserWindow
[
type
]
)
)
{
break
;
}
}
let
textCropped
=
false
;
if
(
text
.
length
>
500
&
&
text
.
match
(
/
^
data
:
[
^
]
+
;
base64
/
)
)
{
text
=
text
.
substring
(
0
500
)
+
"
\
u2026
"
;
textCropped
=
true
;
}
if
(
this
.
_labelElement
.
value
!
=
text
|
|
(
text
&
&
!
this
.
isVisible
)
)
{
this
.
panel
.
setAttribute
(
"
previoustype
"
this
.
panel
.
getAttribute
(
"
type
"
)
)
;
this
.
panel
.
setAttribute
(
"
type
"
type
)
;
this
.
_label
=
text
;
this
.
_labelElement
.
setAttribute
(
"
crop
"
type
=
=
"
overLink
"
&
&
!
textCropped
?
"
center
"
:
"
end
"
)
;
}
}
get
_labelElement
(
)
{
delete
this
.
_labelElement
;
return
(
this
.
_labelElement
=
document
.
getElementById
(
"
statuspanel
-
label
"
)
)
;
}
set
_label
(
val
)
{
if
(
!
this
.
isVisible
)
{
this
.
panel
.
removeAttribute
(
"
mirror
"
)
;
this
.
panel
.
removeAttribute
(
"
sizelimit
"
)
;
}
if
(
this
.
panel
.
getAttribute
(
"
type
"
)
=
=
"
status
"
&
&
this
.
panel
.
getAttribute
(
"
previoustype
"
)
=
=
"
status
"
)
{
this
.
panel
.
style
.
minWidth
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
panel
)
.
width
+
"
px
"
;
}
else
{
this
.
panel
.
style
.
minWidth
=
"
"
;
}
if
(
val
)
{
this
.
_labelElement
.
value
=
val
;
if
(
this
.
panel
.
hidden
)
{
this
.
panel
.
hidden
=
false
;
getComputedStyle
(
this
.
panel
)
.
display
;
}
this
.
panel
.
removeAttribute
(
"
inactive
"
)
;
MousePosTracker
.
addListener
(
this
)
;
}
else
{
this
.
panel
.
setAttribute
(
"
inactive
"
"
true
"
)
;
MousePosTracker
.
removeListener
(
this
)
;
}
}
_onTransitionEnd
(
)
{
if
(
!
this
.
isVisible
)
{
this
.
panel
.
hidden
=
true
;
}
}
getMouseTargetRect
(
)
{
let
container
=
this
.
panel
.
parentNode
;
let
panelRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
panel
)
;
let
containerRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
container
)
;
return
{
top
:
panelRect
.
top
bottom
:
panelRect
.
bottom
left
:
RTL_UI
?
containerRect
.
right
-
panelRect
.
width
:
containerRect
.
left
right
:
RTL_UI
?
containerRect
.
right
:
containerRect
.
left
+
panelRect
.
width
}
;
}
onMouseEnter
(
)
{
this
.
_mirror
(
)
;
}
onMouseLeave
(
)
{
this
.
_mirror
(
)
;
}
_mirror
(
)
{
if
(
this
.
_frozen
)
{
return
;
}
if
(
this
.
panel
.
hasAttribute
(
"
mirror
"
)
)
{
this
.
panel
.
removeAttribute
(
"
mirror
"
)
;
}
else
{
this
.
panel
.
setAttribute
(
"
mirror
"
"
true
"
)
;
}
if
(
!
this
.
panel
.
hasAttribute
(
"
sizelimit
"
)
)
{
this
.
panel
.
setAttribute
(
"
sizelimit
"
"
true
"
)
;
}
}
}
;
var
TabBarVisibility
=
{
_initialUpdateDone
:
false
update
(
force
=
false
)
{
let
toolbar
=
document
.
getElementById
(
"
TabsToolbar
"
)
;
let
navbar
=
document
.
getElementById
(
"
nav
-
bar
"
)
;
let
hideTabstrip
=
false
;
let
isPopup
=
!
window
.
toolbar
.
visible
;
let
isVerticalTabs
=
Services
.
prefs
.
getBoolPref
(
"
sidebar
.
verticalTabs
"
false
)
;
let
nonPopupWithVerticalTabs
=
!
isPopup
&
&
isVerticalTabs
;
if
(
!
gBrowser
|
|
gBrowser
.
visibleTabs
.
length
=
=
1
)
{
hideTabstrip
=
isPopup
;
}
if
(
nonPopupWithVerticalTabs
)
{
hideTabstrip
=
true
;
CustomTitlebar
.
allowedBy
(
"
tabs
-
visible
"
true
)
;
}
else
{
CustomTitlebar
.
allowedBy
(
"
tabs
-
visible
"
!
hideTabstrip
)
;
}
gNavToolbox
.
toggleAttribute
(
"
tabs
-
hidden
"
hideTabstrip
)
;
navbar
.
classList
.
toggle
(
"
browser
-
titlebar
"
CustomTitlebar
.
enabled
&
&
hideTabstrip
)
;
document
.
getElementById
(
"
browser
"
)
.
classList
.
toggle
(
"
browser
-
toolbox
-
background
"
CustomTitlebar
.
enabled
&
&
nonPopupWithVerticalTabs
)
;
if
(
hideTabstrip
=
=
toolbar
.
collapsed
&
&
!
force
&
&
this
.
_initialUpdateDone
)
{
return
;
}
this
.
_initialUpdateDone
=
true
;
toolbar
.
collapsed
=
hideTabstrip
;
document
.
getElementById
(
"
menu_closeWindow
"
)
.
hidden
=
hideTabstrip
;
document
.
l10n
.
setAttributes
(
document
.
getElementById
(
"
menu_close
"
)
hideTabstrip
?
"
tabbrowser
-
menuitem
-
close
"
:
"
tabbrowser
-
menuitem
-
close
-
tab
"
)
;
}
}
;
var
TabContextMenu
=
{
contextTab
:
null
_updateToggleMuteMenuItems
(
aTab
aConditionFn
)
{
[
"
muted
"
"
soundplaying
"
]
.
forEach
(
attr
=
>
{
if
(
!
aConditionFn
|
|
aConditionFn
(
attr
)
)
{
if
(
aTab
.
hasAttribute
(
attr
)
)
{
aTab
.
toggleMuteMenuItem
.
setAttribute
(
attr
"
true
"
)
;
aTab
.
toggleMultiSelectMuteMenuItem
.
setAttribute
(
attr
"
true
"
)
;
}
else
{
aTab
.
toggleMuteMenuItem
.
removeAttribute
(
attr
)
;
aTab
.
toggleMultiSelectMuteMenuItem
.
removeAttribute
(
attr
)
;
}
}
}
)
;
}
updateContextMenu
(
aPopupMenu
)
{
let
triggerTab
=
aPopupMenu
.
triggerNode
&
&
(
aPopupMenu
.
triggerNode
.
tab
|
|
aPopupMenu
.
triggerNode
.
closest
(
"
tab
"
)
)
;
this
.
contextTab
=
triggerTab
|
|
gBrowser
.
selectedTab
;
this
.
contextTab
.
addEventListener
(
"
TabAttrModified
"
this
)
;
aPopupMenu
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
multiselected
=
this
.
contextTab
.
multiselected
;
this
.
contextTabs
=
this
.
multiselected
?
gBrowser
.
selectedTabs
:
[
this
.
contextTab
]
;
let
disabled
=
gBrowser
.
tabs
.
length
=
=
1
;
let
tabCountInfo
=
JSON
.
stringify
(
{
tabCount
:
this
.
contextTabs
.
length
}
)
;
var
menuItems
=
aPopupMenu
.
getElementsByAttribute
(
"
tbattr
"
"
tabbrowser
-
multiple
"
)
;
for
(
let
menuItem
of
menuItems
)
{
menuItem
.
disabled
=
disabled
;
}
disabled
=
gBrowser
.
visibleTabs
.
length
=
=
1
;
menuItems
=
aPopupMenu
.
getElementsByAttribute
(
"
tbattr
"
"
tabbrowser
-
multiple
-
visible
"
)
;
for
(
let
menuItem
of
menuItems
)
{
menuItem
.
disabled
=
disabled
;
}
let
contextNewTabButton
=
document
.
getElementById
(
"
context_openANewTab
"
)
;
document
.
l10n
.
setAttributes
(
contextNewTabButton
gBrowser
.
tabContainer
?
.
verticalMode
?
"
tab
-
context
-
new
-
tab
-
open
-
vertical
"
:
"
tab
-
context
-
new
-
tab
-
open
"
)
;
let
closedCount
=
SessionStore
.
getLastClosedTabCount
(
window
)
;
document
.
getElementById
(
"
History
:
UndoCloseTab
"
)
.
setAttribute
(
"
disabled
"
closedCount
=
=
0
)
;
document
.
l10n
.
setArgs
(
document
.
getElementById
(
"
context_undoCloseTab
"
)
{
tabCount
:
closedCount
}
)
;
showFullScreenViewContextMenuItems
(
aPopupMenu
)
;
let
contextMoveTabToNewGroup
=
document
.
getElementById
(
"
context_moveTabToNewGroup
"
)
;
let
contextMoveTabToGroup
=
document
.
getElementById
(
"
context_moveTabToGroup
"
)
;
let
contextUngroupTab
=
document
.
getElementById
(
"
context_ungroupTab
"
)
;
if
(
gBrowser
.
_tabGroupsEnabled
)
{
let
groupableTabs
=
this
.
contextTabs
.
filter
(
t
=
>
!
t
.
pinned
)
;
let
selectedGroupCount
=
new
Set
(
groupableTabs
.
map
(
t
=
>
t
.
group
)
.
filter
(
g
=
>
g
)
)
.
size
;
let
availableGroupsToMoveTo
=
gBrowser
.
getAllTabGroups
(
)
.
sort
(
(
a
b
)
=
>
a
.
createdDate
-
b
.
createdDate
)
;
let
groupToFilter
;
if
(
selectedGroupCount
=
=
1
)
{
groupToFilter
=
groupableTabs
[
0
]
.
group
;
}
if
(
groupToFilter
)
{
availableGroupsToMoveTo
=
availableGroupsToMoveTo
.
filter
(
group
=
>
group
!
=
=
groupToFilter
)
;
}
contextMoveTabToGroup
.
disabled
=
!
groupableTabs
.
length
;
contextMoveTabToNewGroup
.
disabled
=
!
groupableTabs
.
length
;
if
(
!
availableGroupsToMoveTo
.
length
)
{
contextMoveTabToGroup
.
hidden
=
true
;
contextMoveTabToNewGroup
.
hidden
=
false
;
contextMoveTabToNewGroup
.
setAttribute
(
"
data
-
l10n
-
args
"
tabCountInfo
)
;
}
else
{
contextMoveTabToNewGroup
.
hidden
=
true
;
contextMoveTabToGroup
.
hidden
=
false
;
contextMoveTabToGroup
.
setAttribute
(
"
data
-
l10n
-
args
"
tabCountInfo
)
;
const
submenu
=
contextMoveTabToGroup
.
querySelector
(
"
menupopup
"
)
;
submenu
.
querySelectorAll
(
"
[
tab
-
group
-
id
]
"
)
.
forEach
(
el
=
>
el
.
remove
(
)
)
;
availableGroupsToMoveTo
.
forEach
(
group
=
>
{
let
item
=
document
.
createXULElement
(
"
menuitem
"
)
;
item
.
setAttribute
(
"
tab
-
group
-
id
"
group
.
id
)
;
if
(
group
.
label
)
{
item
.
setAttribute
(
"
label
"
group
.
label
)
;
}
else
{
document
.
l10n
.
setAttributes
(
item
"
tab
-
context
-
unnamed
-
group
"
)
;
}
item
.
classList
.
add
(
"
menuitem
-
iconic
"
)
;
if
(
group
.
collapsed
)
{
item
.
classList
.
add
(
"
tab
-
group
-
icon
-
collapsed
"
)
;
}
else
{
item
.
classList
.
add
(
"
tab
-
group
-
icon
"
)
;
}
item
.
style
.
setProperty
(
"
-
-
tab
-
group
-
color
"
group
.
style
.
getPropertyValue
(
"
-
-
tab
-
group
-
color
"
)
)
;
item
.
style
.
setProperty
(
"
-
-
tab
-
group
-
color
-
invert
"
group
.
style
.
getPropertyValue
(
"
-
-
tab
-
group
-
color
-
invert
"
)
)
;
item
.
style
.
setProperty
(
"
-
-
tab
-
group
-
color
-
pale
"
group
.
style
.
getPropertyValue
(
"
-
-
tab
-
group
-
color
-
pale
"
)
)
;
submenu
.
appendChild
(
item
)
;
}
)
;
}
contextUngroupTab
.
hidden
=
!
selectedGroupCount
;
let
groupInfo
=
JSON
.
stringify
(
{
groupCount
:
selectedGroupCount
}
)
;
contextUngroupTab
.
setAttribute
(
"
data
-
l10n
-
args
"
groupInfo
)
;
}
else
{
contextMoveTabToNewGroup
.
hidden
=
true
;
contextMoveTabToGroup
.
hidden
=
true
;
contextUngroupTab
.
hidden
=
true
;
}
document
.
getElementById
(
"
context_reloadTab
"
)
.
hidden
=
this
.
multiselected
;
document
.
getElementById
(
"
context_reloadSelectedTabs
"
)
.
hidden
=
!
this
.
multiselected
;
let
unloadTabItem
=
document
.
getElementById
(
"
context_unloadTab
"
)
;
if
(
gBrowser
.
_unloadTabInContextMenu
)
{
let
unloadableTabs
=
this
.
contextTabs
.
filter
(
t
=
>
t
.
linkedPanel
&
&
t
.
linkedBrowser
?
.
isRemoteBrowser
)
;
unloadTabItem
.
hidden
=
unloadableTabs
.
length
=
=
=
0
;
unloadTabItem
.
setAttribute
(
"
data
-
l10n
-
args
"
JSON
.
stringify
(
{
tabCount
:
unloadableTabs
.
length
}
)
)
;
}
else
{
unloadTabItem
.
hidden
=
true
;
}
document
.
getElementById
(
"
context_playTab
"
)
.
hidden
=
!
(
this
.
contextTab
.
activeMediaBlocked
&
&
!
this
.
multiselected
)
;
document
.
getElementById
(
"
context_playSelectedTabs
"
)
.
hidden
=
!
(
this
.
contextTab
.
activeMediaBlocked
&
&
this
.
multiselected
)
;
let
contextPinTab
=
document
.
getElementById
(
"
context_pinTab
"
)
;
contextPinTab
.
hidden
=
this
.
contextTab
.
pinned
|
|
this
.
multiselected
;
let
contextUnpinTab
=
document
.
getElementById
(
"
context_unpinTab
"
)
;
contextUnpinTab
.
hidden
=
!
this
.
contextTab
.
pinned
|
|
this
.
multiselected
;
let
contextPinSelectedTabs
=
document
.
getElementById
(
"
context_pinSelectedTabs
"
)
;
contextPinSelectedTabs
.
hidden
=
this
.
contextTab
.
pinned
|
|
!
this
.
multiselected
;
let
contextUnpinSelectedTabs
=
document
.
getElementById
(
"
context_unpinSelectedTabs
"
)
;
contextUnpinSelectedTabs
.
hidden
=
!
this
.
contextTab
.
pinned
|
|
!
this
.
multiselected
;
let
contextMoveTabOptions
=
document
.
getElementById
(
"
context_moveTabOptions
"
)
;
contextMoveTabOptions
.
setAttribute
(
"
data
-
l10n
-
args
"
tabCountInfo
)
;
contextMoveTabOptions
.
disabled
=
this
.
contextTab
.
hidden
|
|
gBrowser
.
allTabsSelected
(
)
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
contextMoveTabToEnd
=
document
.
getElementById
(
"
context_moveToEnd
"
)
;
let
allSelectedTabsAdjacent
=
selectedTabs
.
every
(
(
element
index
array
)
=
>
{
return
array
.
length
>
index
+
1
?
element
.
_tPos
+
1
=
=
array
[
index
+
1
]
.
_tPos
:
true
;
}
)
;
let
visibleTabs
=
gBrowser
.
visibleTabs
;
let
lastVisibleTab
=
visibleTabs
.
at
(
-
1
)
;
let
lastTabToMove
=
this
.
contextTabs
.
at
(
-
1
)
;
let
isLastPinnedTab
=
false
;
if
(
lastTabToMove
.
pinned
)
{
let
sibling
=
gBrowser
.
tabContainer
.
findNextTab
(
lastTabToMove
)
;
isLastPinnedTab
=
!
sibling
|
|
!
sibling
.
pinned
;
}
contextMoveTabToEnd
.
disabled
=
(
lastTabToMove
=
=
lastVisibleTab
|
|
isLastPinnedTab
)
&
&
!
lastTabToMove
.
group
&
&
allSelectedTabsAdjacent
;
let
contextMoveTabToStart
=
document
.
getElementById
(
"
context_moveToStart
"
)
;
let
isFirstTab
=
!
this
.
contextTabs
[
0
]
.
group
&
&
(
this
.
contextTabs
[
0
]
=
=
visibleTabs
[
0
]
|
|
this
.
contextTabs
[
0
]
=
=
visibleTabs
[
gBrowser
.
pinnedTabCount
]
)
;
contextMoveTabToStart
.
disabled
=
isFirstTab
&
&
allSelectedTabsAdjacent
;
document
.
getElementById
(
"
context_openTabInWindow
"
)
.
disabled
=
this
.
contextTab
.
hasAttribute
(
"
customizemode
"
)
;
document
.
getElementById
(
"
context_duplicateTab
"
)
.
hidden
=
this
.
multiselected
;
document
.
getElementById
(
"
context_duplicateTabs
"
)
.
hidden
=
!
this
.
multiselected
;
let
closeTabsToTheStartItem
=
document
.
getElementById
(
"
context_closeTabsToTheStart
"
)
;
document
.
l10n
.
setAttributes
(
closeTabsToTheStartItem
gBrowser
.
tabContainer
?
.
verticalMode
?
"
close
-
tabs
-
to
-
the
-
start
-
vertical
"
:
"
close
-
tabs
-
to
-
the
-
start
"
)
;
let
closeTabsToTheEndItem
=
document
.
getElementById
(
"
context_closeTabsToTheEnd
"
)
;
document
.
l10n
.
setAttributes
(
closeTabsToTheEndItem
gBrowser
.
tabContainer
?
.
verticalMode
?
"
close
-
tabs
-
to
-
the
-
end
-
vertical
"
:
"
close
-
tabs
-
to
-
the
-
end
"
)
;
const
toggleVerticalTabsItem
=
document
.
getElementById
(
"
context_toggleVerticalTabs
"
)
;
document
.
l10n
.
setAttributes
(
toggleVerticalTabsItem
gBrowser
.
tabContainer
?
.
verticalMode
?
"
tab
-
context
-
disable
-
vertical
-
tabs
"
:
"
tab
-
context
-
enable
-
vertical
-
tabs
"
)
;
let
noTabsToStart
=
!
gBrowser
.
_getTabsToTheStartFrom
(
this
.
contextTab
)
.
length
;
closeTabsToTheStartItem
.
disabled
=
noTabsToStart
;
let
noTabsToEnd
=
!
gBrowser
.
_getTabsToTheEndFrom
(
this
.
contextTab
)
.
length
;
closeTabsToTheEndItem
.
disabled
=
noTabsToEnd
;
let
unpinnedTabsToClose
=
this
.
multiselected
?
gBrowser
.
openTabs
.
filter
(
t
=
>
!
t
.
multiselected
&
&
!
t
.
pinned
&
&
!
t
.
hidden
)
.
length
:
gBrowser
.
openTabs
.
filter
(
t
=
>
t
!
=
this
.
contextTab
&
&
!
t
.
pinned
&
&
!
t
.
hidden
)
.
length
;
let
closeOtherTabsItem
=
document
.
getElementById
(
"
context_closeOtherTabs
"
)
;
closeOtherTabsItem
.
disabled
=
unpinnedTabsToClose
<
1
;
document
.
getElementById
(
"
context_closeTab
"
)
.
setAttribute
(
"
data
-
l10n
-
args
"
tabCountInfo
)
;
let
closeDuplicateEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
context
.
close
-
duplicate
.
enabled
"
)
;
let
closeDuplicateTabsItem
=
document
.
getElementById
(
"
context_closeDuplicateTabs
"
)
;
closeDuplicateTabsItem
.
hidden
=
!
closeDuplicateEnabled
;
closeDuplicateTabsItem
.
disabled
=
!
closeDuplicateEnabled
|
|
!
gBrowser
.
getDuplicateTabsToClose
(
this
.
contextTab
)
.
length
;
document
.
getElementById
(
"
context_closeTabOptions
"
)
.
disabled
=
closeTabsToTheStartItem
.
disabled
&
&
closeTabsToTheEndItem
.
disabled
&
&
closeOtherTabsItem
.
disabled
;
let
bookmarkTab
=
document
.
getElementById
(
"
context_bookmarkTab
"
)
;
bookmarkTab
.
hidden
=
this
.
multiselected
;
let
bookmarkMultiSelectedTabs
=
document
.
getElementById
(
"
context_bookmarkSelectedTabs
"
)
;
bookmarkMultiSelectedTabs
.
hidden
=
!
this
.
multiselected
;
let
toggleMute
=
document
.
getElementById
(
"
context_toggleMuteTab
"
)
;
let
toggleMultiSelectMute
=
document
.
getElementById
(
"
context_toggleMuteSelectedTabs
"
)
;
toggleMute
.
hidden
=
this
.
multiselected
;
toggleMultiSelectMute
.
hidden
=
!
this
.
multiselected
;
const
isMuted
=
this
.
contextTab
.
hasAttribute
(
"
muted
"
)
;
document
.
l10n
.
setAttributes
(
toggleMute
isMuted
?
"
tabbrowser
-
context
-
unmute
-
tab
"
:
"
tabbrowser
-
context
-
mute
-
tab
"
)
;
document
.
l10n
.
setAttributes
(
toggleMultiSelectMute
isMuted
?
"
tabbrowser
-
context
-
unmute
-
selected
-
tabs
"
:
"
tabbrowser
-
context
-
mute
-
selected
-
tabs
"
)
;
this
.
contextTab
.
toggleMuteMenuItem
=
toggleMute
;
this
.
contextTab
.
toggleMultiSelectMuteMenuItem
=
toggleMultiSelectMute
;
this
.
_updateToggleMuteMenuItems
(
this
.
contextTab
)
;
let
selectAllTabs
=
document
.
getElementById
(
"
context_selectAllTabs
"
)
;
selectAllTabs
.
disabled
=
gBrowser
.
allTabsSelected
(
)
;
gSync
.
updateTabContextMenu
(
aPopupMenu
this
.
contextTab
)
;
let
reopenInContainer
=
document
.
getElementById
(
"
context_reopenInContainer
"
)
;
reopenInContainer
.
hidden
=
!
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
false
)
|
|
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
reopenInContainer
.
disabled
=
this
.
contextTab
.
hidden
;
gShareUtils
.
updateShareURLMenuItem
(
this
.
contextTab
.
linkedBrowser
document
.
getElementById
(
"
context_sendTabToDevice
"
)
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
popuphidden
"
:
if
(
aEvent
.
target
.
id
=
=
"
tabContextMenu
"
)
{
this
.
contextTab
.
removeEventListener
(
"
TabAttrModified
"
this
)
;
this
.
contextTab
=
null
;
this
.
contextTabs
=
null
;
}
break
;
case
"
TabAttrModified
"
:
{
let
tab
=
aEvent
.
target
;
this
.
_updateToggleMuteMenuItems
(
tab
attr
=
>
aEvent
.
detail
.
changed
.
includes
(
attr
)
)
;
break
;
}
}
}
createReopenInContainerMenu
(
event
)
{
createUserContextMenu
(
event
{
isContextMenu
:
true
excludeUserContextId
:
this
.
contextTab
.
getAttribute
(
"
usercontextid
"
)
}
)
;
}
duplicateSelectedTabs
(
)
{
let
newIndex
=
this
.
contextTabs
.
at
(
-
1
)
.
_tPos
+
1
;
for
(
let
tab
of
this
.
contextTabs
)
{
let
newTab
=
SessionStore
.
duplicateTab
(
window
tab
)
;
gBrowser
.
moveTabTo
(
newTab
newIndex
+
+
)
;
}
}
reopenInContainer
(
event
)
{
let
userContextId
=
parseInt
(
event
.
target
.
getAttribute
(
"
data
-
usercontextid
"
)
)
;
for
(
let
tab
of
this
.
contextTabs
)
{
if
(
tab
.
getAttribute
(
"
usercontextid
"
)
=
=
userContextId
)
{
continue
;
}
let
triggeringPrincipal
;
if
(
tab
.
linkedPanel
)
{
triggeringPrincipal
=
tab
.
linkedBrowser
.
contentPrincipal
;
}
else
{
let
tabState
=
JSON
.
parse
(
SessionStore
.
getTabState
(
tab
)
)
;
try
{
triggeringPrincipal
=
E10SUtils
.
deserializePrincipal
(
tabState
.
triggeringPrincipal_base64
)
;
}
catch
(
ex
)
{
continue
;
}
}
if
(
!
triggeringPrincipal
|
|
triggeringPrincipal
.
isNullPrincipal
)
{
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
userContextId
}
)
;
}
else
if
(
triggeringPrincipal
.
isContentPrincipal
)
{
triggeringPrincipal
=
Services
.
scriptSecurityManager
.
principalWithOA
(
triggeringPrincipal
{
userContextId
}
)
;
}
let
newTab
=
gBrowser
.
addTab
(
tab
.
linkedBrowser
.
currentURI
.
spec
{
userContextId
pinned
:
tab
.
pinned
index
:
tab
.
_tPos
+
1
triggeringPrincipal
}
)
;
if
(
gBrowser
.
selectedTab
=
=
tab
)
{
gBrowser
.
selectedTab
=
newTab
;
}
if
(
tab
.
muted
&
&
!
newTab
.
muted
)
{
newTab
.
toggleMuteAudio
(
tab
.
muteReason
)
;
}
}
}
closeContextTabs
(
)
{
if
(
this
.
contextTab
.
multiselected
)
{
gBrowser
.
removeMultiSelectedTabs
(
)
;
}
else
{
gBrowser
.
removeTab
(
this
.
contextTab
{
animate
:
true
}
)
;
}
}
explicitUnloadTabs
(
)
{
gBrowser
.
explicitUnloadTabs
(
this
.
contextTabs
)
;
}
moveTabsToNewGroup
(
)
{
gBrowser
.
addTabGroup
(
this
.
contextTabs
{
insertBefore
:
this
.
contextTab
showCreateUI
:
true
}
)
;
gTabsPanel
.
hideAllTabsPanel
(
)
;
}
moveTabsToGroup
(
group
)
{
group
.
addTabs
(
this
.
contextTabs
)
;
group
.
ownerGlobal
.
focus
(
)
;
}
ungroupTabs
(
)
{
for
(
let
i
=
this
.
contextTabs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
gBrowser
.
ungroupTab
(
this
.
contextTabs
[
i
]
)
;
}
}
}
;
