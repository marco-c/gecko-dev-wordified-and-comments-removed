"
use
strict
"
;
{
const
isTab
=
element
=
>
gBrowser
.
isTab
(
element
)
;
const
isTabGroupLabel
=
element
=
>
gBrowser
.
isTabGroupLabel
(
element
)
;
const
elementToMove
=
element
=
>
{
if
(
isTab
(
element
)
)
{
return
element
;
}
if
(
isTabGroupLabel
(
element
)
)
{
return
element
.
closest
(
"
.
tab
-
group
-
label
-
container
"
)
;
}
throw
new
Error
(
Element
"
{
element
.
tagName
}
"
is
not
expected
to
move
)
;
}
;
window
.
TabDragAndDrop
=
class
{
#
tabbrowserTabs
;
#
dragTime
=
0
;
#
maxTabsPerRow
;
#
dragOverGroupingTimer
;
#
pinnedDropIndicatorTimeout
=
null
;
#
pinnedDropIndicator
;
#
dragToPinPromoCard
;
#
tabDropIndicator
;
constructor
(
tabbrowserTabs
)
{
this
.
#
tabbrowserTabs
=
tabbrowserTabs
;
}
init
(
)
{
this
.
#
pinnedDropIndicator
=
document
.
getElementById
(
"
pinned
-
drop
-
indicator
"
)
;
this
.
#
dragToPinPromoCard
=
document
.
getElementById
(
"
drag
-
to
-
pin
-
promo
-
card
"
)
;
this
.
#
tabDropIndicator
=
this
.
#
tabbrowserTabs
.
querySelector
(
"
.
tab
-
drop
-
indicator
"
)
;
}
handle_dragstart
(
event
)
{
if
(
this
.
#
tabbrowserTabs
.
_isCustomizing
)
{
return
;
}
let
tab
=
this
.
#
getDragTarget
(
event
)
;
if
(
!
tab
)
{
return
;
}
this
.
#
tabbrowserTabs
.
previewPanel
?
.
deactivate
(
null
{
force
:
true
}
)
;
this
.
startTabDrag
(
event
tab
)
;
}
handle_dragover
(
event
)
{
var
dropEffect
=
this
.
getDropEffectForTabDrag
(
event
)
;
var
ind
=
this
.
#
tabDropIndicator
;
if
(
dropEffect
=
=
"
"
|
|
dropEffect
=
=
"
none
"
)
{
ind
.
hidden
=
true
;
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
var
arrowScrollbox
=
this
.
#
tabbrowserTabs
.
arrowScrollbox
;
var
pixelsToScroll
=
0
;
if
(
this
.
#
tabbrowserTabs
.
overflowing
)
{
switch
(
event
.
originalTarget
)
{
case
arrowScrollbox
.
_scrollButtonUp
:
pixelsToScroll
=
arrowScrollbox
.
scrollIncrement
*
-
1
;
break
;
case
arrowScrollbox
.
_scrollButtonDown
:
pixelsToScroll
=
arrowScrollbox
.
scrollIncrement
;
break
;
}
if
(
pixelsToScroll
)
{
arrowScrollbox
.
scrollByPixels
(
(
this
.
#
rtlMode
?
-
1
:
1
)
*
pixelsToScroll
true
)
;
}
}
let
draggedTab
=
event
.
dataTransfer
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
(
dropEffect
=
=
"
move
"
|
|
dropEffect
=
=
"
copy
"
)
&
&
document
=
=
draggedTab
.
ownerDocument
&
&
!
draggedTab
.
_dragData
.
fromTabList
)
{
ind
.
hidden
=
true
;
if
(
this
.
#
isAnimatingMoveTogetherSelectedTabs
(
)
)
{
return
;
}
this
.
finishMoveTogetherSelectedTabs
(
draggedTab
)
;
if
(
dropEffect
=
=
"
move
"
)
{
this
.
#
setMovingTabMode
(
true
)
;
if
(
this
.
#
isContainerVerticalPinnedGrid
(
draggedTab
)
)
{
this
.
#
animateExpandedPinnedTabMove
(
event
)
;
return
;
}
this
.
#
animateTabMove
(
event
)
;
return
;
}
}
this
.
finishAnimateTabMove
(
)
;
if
(
dropEffect
=
=
"
link
"
)
{
let
target
=
this
.
#
getDragTarget
(
event
{
ignoreSides
:
true
}
)
;
if
(
target
)
{
if
(
!
this
.
#
dragTime
)
{
this
.
#
dragTime
=
Date
.
now
(
)
;
}
let
overGroupLabel
=
isTabGroupLabel
(
target
)
;
if
(
Date
.
now
(
)
>
=
this
.
#
dragTime
+
Services
.
prefs
.
getIntPref
(
overGroupLabel
?
"
browser
.
tabs
.
dragDrop
.
expandGroup
.
delayMS
"
:
"
browser
.
tabs
.
dragDrop
.
selectTab
.
delayMS
"
)
)
{
if
(
overGroupLabel
)
{
target
.
group
.
collapsed
=
false
;
}
else
{
this
.
#
tabbrowserTabs
.
selectedItem
=
target
;
}
}
if
(
isTab
(
target
)
)
{
ind
.
hidden
=
true
;
return
;
}
}
}
var
rect
=
arrowScrollbox
.
getBoundingClientRect
(
)
;
var
newMargin
;
if
(
pixelsToScroll
)
{
let
scrollRect
=
arrowScrollbox
.
scrollClientRect
;
let
minMargin
=
this
.
#
tabbrowserTabs
.
verticalMode
?
scrollRect
.
top
-
rect
.
top
:
scrollRect
.
left
-
rect
.
left
;
let
maxMargin
=
this
.
#
tabbrowserTabs
.
verticalMode
?
Math
.
min
(
minMargin
+
scrollRect
.
height
scrollRect
.
bottom
)
:
Math
.
min
(
minMargin
+
scrollRect
.
width
scrollRect
.
right
)
;
if
(
this
.
#
rtlMode
)
{
[
minMargin
maxMargin
]
=
[
this
.
#
tabbrowserTabs
.
clientWidth
-
maxMargin
this
.
#
tabbrowserTabs
.
clientWidth
-
minMargin
]
;
}
newMargin
=
pixelsToScroll
>
0
?
maxMargin
:
minMargin
;
}
else
{
let
newIndex
=
this
.
#
getDropIndex
(
event
)
;
let
children
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
;
if
(
newIndex
=
=
children
.
length
)
{
let
itemRect
=
children
.
at
(
-
1
)
.
getBoundingClientRect
(
)
;
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
newMargin
=
itemRect
.
bottom
-
rect
.
top
;
}
else
if
(
this
.
#
rtlMode
)
{
newMargin
=
rect
.
right
-
itemRect
.
left
;
}
else
{
newMargin
=
itemRect
.
right
-
rect
.
left
;
}
}
else
{
let
itemRect
=
children
[
newIndex
]
.
getBoundingClientRect
(
)
;
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
newMargin
=
rect
.
top
-
itemRect
.
bottom
;
}
else
if
(
this
.
#
rtlMode
)
{
newMargin
=
rect
.
right
-
itemRect
.
right
;
}
else
{
newMargin
=
itemRect
.
left
-
rect
.
left
;
}
}
}
ind
.
hidden
=
false
;
newMargin
+
=
this
.
#
tabbrowserTabs
.
verticalMode
?
ind
.
clientHeight
:
ind
.
clientWidth
/
2
;
if
(
this
.
#
rtlMode
)
{
newMargin
*
=
-
1
;
}
ind
.
style
.
transform
=
this
.
#
tabbrowserTabs
.
verticalMode
?
"
translateY
(
"
+
Math
.
round
(
newMargin
)
+
"
px
)
"
:
"
translateX
(
"
+
Math
.
round
(
newMargin
)
+
"
px
)
"
;
}
handle_drop
(
event
)
{
var
dt
=
event
.
dataTransfer
;
var
dropEffect
=
dt
.
dropEffect
;
var
draggedTab
;
let
movingTabs
;
const
dropMetricsContext
=
gBrowser
.
TabMetrics
.
userTriggeredContext
(
gBrowser
.
TabMetrics
.
METRIC_SOURCE
.
DRAG_AND_DROP
)
;
if
(
dt
.
mozTypesAt
(
0
)
[
0
]
=
=
TAB_DROP_TYPE
)
{
draggedTab
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
!
draggedTab
)
{
return
;
}
movingTabs
=
draggedTab
.
_dragData
.
movingTabs
;
draggedTab
.
container
.
tabDragAndDrop
.
finishMoveTogetherSelectedTabs
(
draggedTab
)
;
}
if
(
this
.
#
rtlMode
)
{
movingTabs
?
.
reverse
(
)
;
}
let
overPinnedDropIndicator
=
this
.
#
pinnedDropIndicator
.
hasAttribute
(
"
visible
"
)
&
&
this
.
#
pinnedDropIndicator
.
hasAttribute
(
"
interactive
"
)
;
this
.
#
resetTabsAfterDrop
(
draggedTab
?
.
ownerDocument
)
;
this
.
#
tabDropIndicator
.
hidden
=
true
;
event
.
stopPropagation
(
)
;
if
(
draggedTab
&
&
dropEffect
=
=
"
copy
"
)
{
let
duplicatedDraggedTab
;
let
duplicatedTabs
=
[
]
;
let
dropTarget
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
[
this
.
#
getDropIndex
(
event
)
]
;
for
(
let
tab
of
movingTabs
)
{
let
duplicatedTab
=
gBrowser
.
duplicateTab
(
tab
)
;
duplicatedTabs
.
push
(
duplicatedTab
)
;
if
(
tab
=
=
draggedTab
)
{
duplicatedDraggedTab
=
duplicatedTab
;
}
}
gBrowser
.
moveTabsBefore
(
duplicatedTabs
dropTarget
dropMetricsContext
)
;
if
(
draggedTab
.
container
!
=
this
.
#
tabbrowserTabs
|
|
event
.
shiftKey
)
{
this
.
#
tabbrowserTabs
.
selectedItem
=
duplicatedDraggedTab
;
}
}
else
if
(
draggedTab
&
&
draggedTab
.
container
=
=
this
.
#
tabbrowserTabs
)
{
let
oldTranslateX
=
Math
.
round
(
draggedTab
.
_dragData
.
translateX
)
;
let
oldTranslateY
=
Math
.
round
(
draggedTab
.
_dragData
.
translateY
)
;
let
tabWidth
=
Math
.
round
(
draggedTab
.
_dragData
.
tabWidth
)
;
let
tabHeight
=
Math
.
round
(
draggedTab
.
_dragData
.
tabHeight
)
;
let
translateOffsetX
=
oldTranslateX
%
tabWidth
;
let
translateOffsetY
=
oldTranslateY
%
tabHeight
;
let
newTranslateX
=
oldTranslateX
-
translateOffsetX
;
let
newTranslateY
=
oldTranslateY
-
translateOffsetY
;
let
isPinned
=
draggedTab
.
pinned
;
let
numPinned
=
gBrowser
.
pinnedTabCount
;
if
(
this
.
#
isContainerVerticalPinnedGrid
(
draggedTab
)
)
{
if
(
oldTranslateX
>
0
&
&
translateOffsetX
>
tabWidth
/
2
)
{
newTranslateX
+
=
tabWidth
;
}
else
if
(
oldTranslateX
<
0
&
&
-
translateOffsetX
>
tabWidth
/
2
)
{
newTranslateX
-
=
tabWidth
;
}
if
(
oldTranslateY
>
0
&
&
translateOffsetY
>
tabHeight
/
2
)
{
newTranslateY
+
=
tabHeight
;
}
else
if
(
oldTranslateY
<
0
&
&
-
translateOffsetY
>
tabHeight
/
2
)
{
newTranslateY
-
=
tabHeight
;
}
}
else
{
let
tabs
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
.
slice
(
isPinned
?
0
:
numPinned
isPinned
?
numPinned
:
undefined
)
;
let
size
=
this
.
#
tabbrowserTabs
.
verticalMode
?
"
height
"
:
"
width
"
;
let
screenAxis
=
this
.
#
tabbrowserTabs
.
verticalMode
?
"
screenY
"
:
"
screenX
"
;
let
tabSize
=
this
.
#
tabbrowserTabs
.
verticalMode
?
tabHeight
:
tabWidth
;
let
firstTab
=
tabs
[
0
]
;
let
lastTab
=
tabs
.
at
(
-
1
)
;
let
lastMovingTabScreen
=
movingTabs
.
at
(
-
1
)
[
screenAxis
]
;
let
firstMovingTabScreen
=
movingTabs
[
0
]
[
screenAxis
]
;
let
startBound
=
firstTab
[
screenAxis
]
-
firstMovingTabScreen
;
let
endBound
=
lastTab
[
screenAxis
]
+
window
.
windowUtils
.
getBoundsWithoutFlushing
(
lastTab
)
[
size
]
-
(
lastMovingTabScreen
+
tabSize
)
;
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
newTranslateY
=
Math
.
min
(
Math
.
max
(
oldTranslateY
startBound
)
endBound
)
;
}
else
{
newTranslateX
=
RTL_UI
?
Math
.
min
(
Math
.
max
(
oldTranslateX
endBound
)
startBound
)
:
Math
.
min
(
Math
.
max
(
oldTranslateX
startBound
)
endBound
)
;
}
}
let
{
dropElement
dropBefore
shouldCreateGroupOnDrop
shouldDropIntoCollapsedTabGroup
fromTabList
}
=
draggedTab
.
_dragData
;
let
dropIndex
;
let
directionForward
=
false
;
if
(
fromTabList
)
{
dropIndex
=
this
.
#
getDropIndex
(
event
)
;
if
(
dropIndex
&
&
dropIndex
>
movingTabs
[
0
]
.
elementIndex
)
{
dropIndex
-
-
;
directionForward
=
true
;
}
}
const
dragToPinTargets
=
[
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
this
.
#
dragToPinPromoCard
]
;
let
shouldPin
=
isTab
(
draggedTab
)
&
&
!
draggedTab
.
pinned
&
&
(
overPinnedDropIndicator
|
|
dragToPinTargets
.
some
(
el
=
>
el
.
contains
(
event
.
target
)
)
)
;
let
shouldUnpin
=
isTab
(
draggedTab
)
&
&
draggedTab
.
pinned
&
&
this
.
#
tabbrowserTabs
.
arrowScrollbox
.
contains
(
event
.
target
)
;
let
shouldTranslate
=
!
gReduceMotion
&
&
!
shouldCreateGroupOnDrop
&
&
!
shouldDropIntoCollapsedTabGroup
&
&
!
isTabGroupLabel
(
draggedTab
)
&
&
!
shouldPin
&
&
!
shouldUnpin
;
if
(
this
.
#
isContainerVerticalPinnedGrid
(
draggedTab
)
)
{
shouldTranslate
&
&
=
(
oldTranslateX
&
&
oldTranslateX
!
=
newTranslateX
)
|
|
(
oldTranslateY
&
&
oldTranslateY
!
=
newTranslateY
)
;
}
else
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
shouldTranslate
&
&
=
oldTranslateY
&
&
oldTranslateY
!
=
newTranslateY
;
}
else
{
shouldTranslate
&
&
=
oldTranslateX
&
&
oldTranslateX
!
=
newTranslateX
;
}
let
moveTabs
=
(
)
=
>
{
if
(
dropIndex
!
=
=
undefined
)
{
for
(
let
tab
of
movingTabs
)
{
gBrowser
.
moveTabTo
(
tab
{
elementIndex
:
dropIndex
}
dropMetricsContext
)
;
if
(
!
directionForward
)
{
dropIndex
+
+
;
}
}
}
else
if
(
dropElement
&
&
dropBefore
)
{
gBrowser
.
moveTabsBefore
(
movingTabs
dropElement
dropMetricsContext
)
;
}
else
if
(
dropElement
&
&
dropBefore
!
=
undefined
)
{
gBrowser
.
moveTabsAfter
(
movingTabs
dropElement
dropMetricsContext
)
;
}
if
(
isTabGroupLabel
(
draggedTab
)
)
{
this
.
#
setIsDraggingTabGroup
(
draggedTab
.
group
false
)
;
this
.
#
expandGroupOnDrop
(
draggedTab
)
;
}
}
;
if
(
shouldPin
|
|
shouldUnpin
)
{
for
(
let
item
of
movingTabs
)
{
if
(
shouldPin
)
{
gBrowser
.
pinTab
(
item
{
telemetrySource
:
gBrowser
.
TabMetrics
.
METRIC_SOURCE
.
DRAG_AND_DROP
}
)
;
}
else
if
(
shouldUnpin
)
{
gBrowser
.
unpinTab
(
item
)
;
}
}
}
if
(
shouldTranslate
)
{
let
translationPromises
=
[
]
;
for
(
let
item
of
movingTabs
)
{
item
=
elementToMove
(
item
)
;
let
translationPromise
=
new
Promise
(
resolve
=
>
{
item
.
toggleAttribute
(
"
tabdrop
-
samewindow
"
true
)
;
item
.
style
.
transform
=
translate
(
{
newTranslateX
}
px
{
newTranslateY
}
px
)
;
let
postTransitionCleanup
=
(
)
=
>
{
item
.
removeAttribute
(
"
tabdrop
-
samewindow
"
)
;
resolve
(
)
;
}
;
if
(
gReduceMotion
)
{
postTransitionCleanup
(
)
;
}
else
{
let
onTransitionEnd
=
transitionendEvent
=
>
{
if
(
transitionendEvent
.
propertyName
!
=
"
transform
"
|
|
transitionendEvent
.
originalTarget
!
=
item
)
{
return
;
}
item
.
removeEventListener
(
"
transitionend
"
onTransitionEnd
)
;
postTransitionCleanup
(
)
;
}
;
item
.
addEventListener
(
"
transitionend
"
onTransitionEnd
)
;
}
}
)
;
translationPromises
.
push
(
translationPromise
)
;
}
Promise
.
all
(
translationPromises
)
.
then
(
(
)
=
>
{
this
.
finishAnimateTabMove
(
)
;
moveTabs
(
)
;
}
)
;
}
else
{
this
.
finishAnimateTabMove
(
)
;
if
(
shouldCreateGroupOnDrop
)
{
let
tabsInGroup
=
dropBefore
?
[
.
.
.
movingTabs
dropElement
]
:
[
dropElement
.
.
.
movingTabs
]
;
gBrowser
.
addTabGroup
(
tabsInGroup
{
insertBefore
:
dropElement
isUserTriggered
:
true
color
:
draggedTab
.
_dragData
.
tabGroupCreationColor
telemetryUserCreateSource
:
"
drag
"
}
)
;
}
else
if
(
shouldDropIntoCollapsedTabGroup
&
&
isTabGroupLabel
(
dropElement
)
&
&
isTab
(
draggedTab
)
)
{
if
(
dropElement
.
group
!
=
draggedTab
.
group
)
{
dropElement
.
group
.
addTabs
(
movingTabs
dropMetricsContext
)
;
}
}
else
{
moveTabs
(
)
;
}
}
}
else
if
(
isTabGroupLabel
(
draggedTab
)
)
{
gBrowser
.
adoptTabGroup
(
draggedTab
.
group
{
elementIndex
:
this
.
#
getDropIndex
(
event
)
}
)
;
}
else
if
(
draggedTab
)
{
const
dropIndex
=
this
.
#
getDropIndex
(
event
)
;
let
newIndex
=
dropIndex
;
let
selectedTab
;
let
indexForSelectedTab
;
for
(
let
i
=
0
;
i
<
movingTabs
.
length
;
+
+
i
)
{
const
tab
=
movingTabs
[
i
]
;
if
(
tab
.
selected
)
{
selectedTab
=
tab
;
indexForSelectedTab
=
newIndex
;
}
else
{
const
newTab
=
gBrowser
.
adoptTab
(
tab
{
elementIndex
:
newIndex
selectTab
:
tab
=
=
draggedTab
}
)
;
if
(
newTab
)
{
+
+
newIndex
;
}
}
}
if
(
selectedTab
)
{
const
newTab
=
gBrowser
.
adoptTab
(
selectedTab
{
elementIndex
:
indexForSelectedTab
selectTab
:
selectedTab
=
=
draggedTab
}
)
;
if
(
newTab
)
{
+
+
newIndex
;
}
}
gBrowser
.
addRangeToMultiSelectedTabs
(
this
.
#
tabbrowserTabs
.
ariaFocusableItems
[
dropIndex
]
this
.
#
tabbrowserTabs
.
ariaFocusableItems
[
newIndex
-
1
]
)
;
}
else
{
let
links
;
try
{
links
=
Services
.
droppedLinkHandler
.
dropLinks
(
event
true
)
;
}
catch
(
ex
)
{
}
if
(
!
links
|
|
links
.
length
=
=
=
0
)
{
return
;
}
let
inBackground
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
if
(
event
.
shiftKey
)
{
inBackground
=
!
inBackground
;
}
let
targetTab
=
this
.
#
getDragTarget
(
event
{
ignoreSides
:
true
}
)
;
let
userContextId
=
this
.
#
tabbrowserTabs
.
selectedItem
.
getAttribute
(
"
usercontextid
"
)
;
let
replace
=
isTab
(
targetTab
)
;
let
newIndex
=
this
.
#
getDropIndex
(
event
)
;
let
urls
=
links
.
map
(
link
=
>
link
.
url
)
;
let
policyContainer
=
Services
.
droppedLinkHandler
.
getPolicyContainer
(
event
)
;
let
triggeringPrincipal
=
Services
.
droppedLinkHandler
.
getTriggeringPrincipal
(
event
)
;
(
async
(
)
=
>
{
if
(
urls
.
length
>
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
maxOpenBeforeWarn
"
)
)
{
let
answer
=
await
OpenInTabsUtils
.
promiseConfirmOpenInTabs
(
urls
.
length
window
)
;
if
(
!
answer
)
{
return
;
}
}
let
nextItem
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
[
newIndex
]
;
let
tabGroup
=
isTab
(
nextItem
)
&
&
nextItem
.
group
;
gBrowser
.
loadTabs
(
urls
{
inBackground
replace
allowThirdPartyFixup
:
true
targetTab
elementIndex
:
newIndex
tabGroup
userContextId
triggeringPrincipal
policyContainer
}
)
;
}
)
(
)
;
}
if
(
draggedTab
)
{
delete
draggedTab
.
_dragData
;
}
}
handle_dragend
(
event
)
{
var
dt
=
event
.
dataTransfer
;
var
draggedTab
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
draggedTab
.
hasAttribute
(
"
tabdrop
-
samewindow
"
)
)
{
return
;
}
this
.
finishMoveTogetherSelectedTabs
(
draggedTab
)
;
this
.
finishAnimateTabMove
(
)
;
if
(
isTabGroupLabel
(
draggedTab
)
)
{
this
.
#
setIsDraggingTabGroup
(
draggedTab
.
group
false
)
;
this
.
#
expandGroupOnDrop
(
draggedTab
)
;
}
this
.
#
resetTabsAfterDrop
(
draggedTab
.
ownerDocument
)
;
if
(
dt
.
mozUserCancelled
|
|
dt
.
dropEffect
!
=
"
none
"
|
|
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
allowTabDetach
"
)
|
|
this
.
#
tabbrowserTabs
.
_isCustomizing
)
{
delete
draggedTab
.
_dragData
;
return
;
}
let
[
tabAxisPos
tabAxisStart
tabAxisEnd
]
=
this
.
#
tabbrowserTabs
.
verticalMode
?
[
event
.
screenY
window
.
screenY
window
.
screenY
+
window
.
outerHeight
]
:
[
event
.
screenX
window
.
screenX
window
.
screenX
+
window
.
outerWidth
]
;
if
(
tabAxisPos
>
tabAxisStart
&
&
tabAxisPos
<
tabAxisEnd
)
{
let
rect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
#
tabbrowserTabs
.
arrowScrollbox
)
;
let
crossAxisPos
=
this
.
#
tabbrowserTabs
.
verticalMode
?
event
.
screenX
:
event
.
screenY
;
let
crossAxisStart
crossAxisEnd
;
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
if
(
(
RTL_UI
&
&
this
.
#
tabbrowserTabs
.
_sidebarPositionStart
)
|
|
(
!
RTL_UI
&
&
!
this
.
#
tabbrowserTabs
.
_sidebarPositionStart
)
)
{
crossAxisStart
=
window
.
mozInnerScreenX
+
rect
.
right
-
1
.
5
*
rect
.
width
;
crossAxisEnd
=
window
.
screenX
+
window
.
outerWidth
;
}
else
{
crossAxisStart
=
window
.
screenX
;
crossAxisEnd
=
window
.
mozInnerScreenX
+
rect
.
left
+
1
.
5
*
rect
.
width
;
}
}
else
{
crossAxisStart
=
window
.
screenY
;
crossAxisEnd
=
window
.
mozInnerScreenY
+
rect
.
top
+
1
.
5
*
rect
.
height
;
}
if
(
crossAxisPos
>
crossAxisStart
&
&
crossAxisPos
<
crossAxisEnd
)
{
return
;
}
}
var
screen
=
event
.
screen
;
var
availX
=
{
}
availY
=
{
}
availWidth
=
{
}
availHeight
=
{
}
;
screen
.
GetAvailRectDisplayPix
(
availX
availY
availWidth
availHeight
)
;
availX
=
availX
.
value
;
availY
=
availY
.
value
;
availWidth
=
availWidth
.
value
;
availHeight
=
availHeight
.
value
;
let
ourCssToDesktopScale
=
window
.
devicePixelRatio
/
window
.
desktopToDeviceScale
;
let
screenCssToDesktopScale
=
screen
.
defaultCSSScaleFactor
/
screen
.
contentsScaleFactor
;
var
winWidth
=
Math
.
min
(
window
.
outerWidth
*
screenCssToDesktopScale
availWidth
)
;
var
winHeight
=
Math
.
min
(
window
.
outerHeight
*
screenCssToDesktopScale
availHeight
)
;
var
left
=
Math
.
min
(
Math
.
max
(
event
.
screenX
*
ourCssToDesktopScale
-
draggedTab
.
_dragData
.
offsetX
*
screenCssToDesktopScale
availX
)
availX
+
availWidth
-
winWidth
)
;
var
top
=
Math
.
min
(
Math
.
max
(
event
.
screenY
*
ourCssToDesktopScale
-
draggedTab
.
_dragData
.
offsetY
*
screenCssToDesktopScale
availY
)
availY
+
availHeight
-
winHeight
)
;
left
/
=
ourCssToDesktopScale
;
top
/
=
ourCssToDesktopScale
;
delete
draggedTab
.
_dragData
;
if
(
gBrowser
.
tabs
.
length
=
=
1
)
{
winWidth
/
=
ourCssToDesktopScale
;
winHeight
/
=
ourCssToDesktopScale
;
window
.
resizeTo
(
winWidth
winHeight
)
;
window
.
moveTo
(
left
top
)
;
window
.
focus
(
)
;
}
else
{
winWidth
/
=
screenCssToDesktopScale
;
winHeight
/
=
screenCssToDesktopScale
;
let
props
=
{
screenX
:
left
screenY
:
top
suppressanimation
:
1
}
;
gBrowser
.
replaceTabsWithWindow
(
draggedTab
props
)
;
}
event
.
stopPropagation
(
)
;
}
handle_dragleave
(
event
)
{
this
.
#
dragTime
=
0
;
var
target
=
event
.
relatedTarget
;
while
(
target
&
&
target
!
=
this
.
#
tabbrowserTabs
)
{
target
=
target
.
parentNode
;
}
if
(
target
)
{
return
;
}
this
.
#
tabDropIndicator
.
hidden
=
true
;
event
.
stopPropagation
(
)
;
}
get
#
rtlMode
(
)
{
return
!
this
.
#
tabbrowserTabs
.
verticalMode
&
&
RTL_UI
;
}
#
setMovingTabMode
(
movingTab
)
{
this
.
#
tabbrowserTabs
.
toggleAttribute
(
"
movingtab
"
movingTab
)
;
gNavToolbox
.
toggleAttribute
(
"
movingtab
"
movingTab
)
;
}
#
getDropIndex
(
event
)
{
let
item
=
this
.
#
getDragTarget
(
event
)
;
if
(
!
item
)
{
return
this
.
#
tabbrowserTabs
.
ariaFocusableItems
.
length
;
}
let
isBeforeMiddle
;
let
elementForSize
=
elementToMove
(
item
)
;
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
let
middle
=
elementForSize
.
screenY
+
elementForSize
.
getBoundingClientRect
(
)
.
height
/
2
;
isBeforeMiddle
=
event
.
screenY
<
middle
;
}
else
{
let
middle
=
elementForSize
.
screenX
+
elementForSize
.
getBoundingClientRect
(
)
.
width
/
2
;
isBeforeMiddle
=
this
.
#
rtlMode
?
event
.
screenX
>
middle
:
event
.
screenX
<
middle
;
}
return
item
.
elementIndex
+
(
isBeforeMiddle
?
0
:
1
)
;
}
#
getDragTarget
(
event
{
ignoreSides
=
false
}
=
{
}
)
{
let
{
target
}
=
event
;
while
(
target
)
{
if
(
isTab
(
target
)
|
|
isTabGroupLabel
(
target
)
)
{
break
;
}
target
=
target
.
parentNode
;
}
if
(
target
&
&
ignoreSides
)
{
let
{
width
height
}
=
target
.
getBoundingClientRect
(
)
;
if
(
event
.
screenX
<
target
.
screenX
+
width
*
0
.
25
|
|
event
.
screenX
>
target
.
screenX
+
width
*
0
.
75
|
|
(
(
event
.
screenY
<
target
.
screenY
+
height
*
0
.
25
|
|
event
.
screenY
>
target
.
screenY
+
height
*
0
.
75
)
&
&
this
.
#
tabbrowserTabs
.
verticalMode
)
)
{
return
null
;
}
}
return
target
;
}
#
isContainerVerticalPinnedGrid
(
tab
)
{
return
(
this
.
#
tabbrowserTabs
.
verticalMode
&
&
tab
.
pinned
&
&
this
.
#
tabbrowserTabs
.
hasAttribute
(
"
expanded
"
)
&
&
!
this
.
#
tabbrowserTabs
.
expandOnHover
)
;
}
#
isMovingTab
(
)
{
return
this
.
#
tabbrowserTabs
.
hasAttribute
(
"
movingtab
"
)
;
}
#
setIsDraggingTabGroup
(
tabGroup
isDragging
)
{
tabGroup
.
isBeingDragged
=
isDragging
;
this
.
#
tabbrowserTabs
.
_invalidateCachedVisibleTabs
(
)
;
}
#
expandGroupOnDrop
(
draggedTab
)
{
if
(
isTabGroupLabel
(
draggedTab
)
&
&
draggedTab
.
_dragData
?
.
expandGroupOnDrop
)
{
draggedTab
.
group
.
collapsed
=
false
;
}
}
#
triggerDragOverGrouping
(
dropElement
)
{
this
.
#
clearDragOverGroupingTimer
(
)
;
this
.
#
tabbrowserTabs
.
toggleAttribute
(
"
movingtab
-
group
"
true
)
;
this
.
#
tabbrowserTabs
.
removeAttribute
(
"
movingtab
-
ungroup
"
)
;
dropElement
.
toggleAttribute
(
"
dragover
-
groupTarget
"
true
)
;
}
#
clearDragOverGroupingTimer
(
)
{
if
(
this
.
#
dragOverGroupingTimer
)
{
clearTimeout
(
this
.
#
dragOverGroupingTimer
)
;
this
.
#
dragOverGroupingTimer
=
0
;
}
}
#
setDragOverGroupColor
(
groupColorCode
)
{
if
(
!
groupColorCode
)
{
this
.
#
tabbrowserTabs
.
style
.
removeProperty
(
"
-
-
dragover
-
tab
-
group
-
color
"
)
;
this
.
#
tabbrowserTabs
.
style
.
removeProperty
(
"
-
-
dragover
-
tab
-
group
-
color
-
invert
"
)
;
this
.
#
tabbrowserTabs
.
style
.
removeProperty
(
"
-
-
dragover
-
tab
-
group
-
color
-
pale
"
)
;
return
;
}
this
.
#
tabbrowserTabs
.
style
.
setProperty
(
"
-
-
dragover
-
tab
-
group
-
color
"
var
(
-
-
tab
-
group
-
color
-
{
groupColorCode
}
)
)
;
this
.
#
tabbrowserTabs
.
style
.
setProperty
(
"
-
-
dragover
-
tab
-
group
-
color
-
invert
"
var
(
-
-
tab
-
group
-
color
-
{
groupColorCode
}
-
invert
)
)
;
this
.
#
tabbrowserTabs
.
style
.
setProperty
(
"
-
-
dragover
-
tab
-
group
-
color
-
pale
"
var
(
-
-
tab
-
group
-
color
-
{
groupColorCode
}
-
pale
)
)
;
}
#
resetGroupTarget
(
element
)
{
element
?
.
removeAttribute
(
"
dragover
-
groupTarget
"
)
;
}
startTabDrag
(
event
tab
{
fromTabList
=
false
}
=
{
}
)
{
if
(
this
.
expandOnHover
)
{
MousePosTracker
.
removeListener
(
document
.
defaultView
.
SidebarController
)
;
}
if
(
this
.
#
isContainerVerticalPinnedGrid
(
tab
)
)
{
let
pinnedTabs
=
this
.
#
tabbrowserTabs
.
visibleTabs
.
slice
(
0
gBrowser
.
pinnedTabCount
)
;
let
tabsPerRow
=
0
;
let
position
=
RTL_UI
?
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
)
.
right
:
0
;
for
(
let
pinnedTab
of
pinnedTabs
)
{
let
tabPosition
;
let
rect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
pinnedTab
)
;
if
(
RTL_UI
)
{
tabPosition
=
rect
.
right
;
if
(
tabPosition
>
position
)
{
break
;
}
}
else
{
tabPosition
=
rect
.
left
;
if
(
tabPosition
<
position
)
{
break
;
}
}
tabsPerRow
+
+
;
position
=
tabPosition
;
}
this
.
#
maxTabsPerRow
=
tabsPerRow
;
}
if
(
tab
.
multiselected
)
{
for
(
let
multiselectedTab
of
gBrowser
.
selectedTabs
.
filter
(
t
=
>
t
.
pinned
!
=
tab
.
pinned
)
)
{
gBrowser
.
removeFromMultiSelectedTabs
(
multiselectedTab
)
;
}
}
let
dataTransferOrderedTabs
;
if
(
fromTabList
|
|
isTabGroupLabel
(
tab
)
)
{
dataTransferOrderedTabs
=
[
tab
]
;
}
else
{
this
.
#
tabbrowserTabs
.
selectedItem
=
tab
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
otherSelectedTabs
=
selectedTabs
.
filter
(
selectedTab
=
>
selectedTab
!
=
tab
)
;
dataTransferOrderedTabs
=
[
tab
]
.
concat
(
otherSelectedTabs
)
;
}
let
dt
=
event
.
dataTransfer
;
for
(
let
i
=
0
;
i
<
dataTransferOrderedTabs
.
length
;
i
+
+
)
{
let
dtTab
=
dataTransferOrderedTabs
[
i
]
;
dt
.
mozSetDataAt
(
TAB_DROP_TYPE
dtTab
i
)
;
if
(
isTab
(
dtTab
)
)
{
let
dtBrowser
=
dtTab
.
linkedBrowser
;
dt
.
mozSetDataAt
(
"
text
/
x
-
moz
-
text
-
internal
"
dtBrowser
.
currentURI
.
spec
i
)
;
}
}
dt
.
mozCursor
=
"
default
"
;
dt
.
addElement
(
tab
)
;
let
scale
=
window
.
devicePixelRatio
;
let
canvas
=
this
.
#
tabbrowserTabs
.
_dndCanvas
;
if
(
!
canvas
)
{
this
.
#
tabbrowserTabs
.
_dndCanvas
=
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
style
.
width
=
"
100
%
"
;
canvas
.
style
.
height
=
"
100
%
"
;
canvas
.
mozOpaque
=
true
;
}
canvas
.
width
=
160
*
scale
;
canvas
.
height
=
90
*
scale
;
let
toDrag
=
canvas
;
let
dragImageOffset
=
-
16
;
let
browser
=
isTab
(
tab
)
&
&
tab
.
linkedBrowser
;
if
(
isTabGroupLabel
(
tab
)
)
{
toDrag
=
tab
;
}
else
if
(
gMultiProcessBrowser
)
{
var
context
=
canvas
.
getContext
(
"
2d
"
)
;
context
.
fillStyle
=
"
white
"
;
context
.
fillRect
(
0
0
canvas
.
width
canvas
.
height
)
;
let
captureListener
;
let
platform
=
AppConstants
.
platform
;
if
(
platform
=
=
"
win
"
|
|
platform
=
=
"
macosx
"
)
{
captureListener
=
function
(
)
{
dt
.
updateDragImage
(
canvas
dragImageOffset
dragImageOffset
)
;
}
;
}
else
{
if
(
!
this
.
#
tabbrowserTabs
.
_dndPanel
)
{
this
.
#
tabbrowserTabs
.
_dndCanvas
=
canvas
;
this
.
#
tabbrowserTabs
.
_dndPanel
=
document
.
createXULElement
(
"
panel
"
)
;
this
.
#
tabbrowserTabs
.
_dndPanel
.
className
=
"
dragfeedback
-
tab
"
;
this
.
#
tabbrowserTabs
.
_dndPanel
.
setAttribute
(
"
type
"
"
drag
"
)
;
let
wrapper
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
div
"
)
;
wrapper
.
style
.
width
=
"
160px
"
;
wrapper
.
style
.
height
=
"
90px
"
;
wrapper
.
appendChild
(
canvas
)
;
this
.
#
tabbrowserTabs
.
_dndPanel
.
appendChild
(
wrapper
)
;
document
.
documentElement
.
appendChild
(
this
.
#
tabbrowserTabs
.
_dndPanel
)
;
}
toDrag
=
this
.
#
tabbrowserTabs
.
_dndPanel
;
}
PageThumbs
.
captureToCanvas
(
browser
canvas
)
.
then
(
captureListener
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
else
{
PageThumbs
.
captureToCanvas
(
browser
canvas
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
dragImageOffset
=
dragImageOffset
*
scale
;
}
dt
.
setDragImage
(
toDrag
dragImageOffset
dragImageOffset
)
;
let
clientPos
=
ele
=
>
{
const
rect
=
ele
.
getBoundingClientRect
(
)
;
return
this
.
#
tabbrowserTabs
.
verticalMode
?
rect
.
top
:
rect
.
left
;
}
;
let
tabOffset
=
clientPos
(
tab
)
-
clientPos
(
this
.
#
tabbrowserTabs
)
;
let
movingTabs
=
tab
.
multiselected
?
gBrowser
.
selectedTabs
:
[
tab
]
;
let
movingTabsSet
=
new
Set
(
movingTabs
)
;
let
dropEffect
=
this
.
getDropEffectForTabDrag
(
event
)
;
let
isMovingInTabStrip
=
!
fromTabList
&
&
dropEffect
=
=
"
move
"
;
let
collapseTabGroupDuringDrag
=
isMovingInTabStrip
&
&
isTabGroupLabel
(
tab
)
&
&
!
tab
.
group
.
collapsed
;
tab
.
_dragData
=
{
offsetX
:
this
.
#
tabbrowserTabs
.
verticalMode
?
event
.
screenX
-
window
.
screenX
:
event
.
screenX
-
window
.
screenX
-
tabOffset
offsetY
:
this
.
#
tabbrowserTabs
.
verticalMode
?
event
.
screenY
-
window
.
screenY
-
tabOffset
:
event
.
screenY
-
window
.
screenY
scrollPos
:
this
.
#
tabbrowserTabs
.
verticalMode
&
&
tab
.
pinned
?
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
scrollPosition
:
this
.
#
tabbrowserTabs
.
arrowScrollbox
.
scrollPosition
screenX
:
event
.
screenX
screenY
:
event
.
screenY
movingTabs
movingTabsSet
fromTabList
tabGroupCreationColor
:
gBrowser
.
tabGroupMenu
.
nextUnusedColor
expandGroupOnDrop
:
collapseTabGroupDuringDrag
}
;
if
(
this
.
#
rtlMode
)
{
tab
.
_dragData
.
movingTabs
.
reverse
(
)
;
}
this
.
#
updateTabStylesOnDrag
(
tab
event
)
;
if
(
isMovingInTabStrip
)
{
this
.
#
setMovingTabMode
(
true
)
;
if
(
tab
.
multiselected
)
{
this
.
#
moveTogetherSelectedTabs
(
tab
)
;
}
else
if
(
isTabGroupLabel
(
tab
)
)
{
this
.
#
setIsDraggingTabGroup
(
tab
.
group
true
)
;
if
(
collapseTabGroupDuringDrag
)
{
tab
.
group
.
collapsed
=
true
;
}
}
}
event
.
stopPropagation
(
)
;
if
(
fromTabList
)
{
Glean
.
browserUiInteraction
.
allTabsPanelDragstartTabEventCount
.
add
(
1
)
;
}
}
#
updateTabStylesOnDrag
(
tab
)
{
let
isPinned
=
tab
.
pinned
;
let
numPinned
=
gBrowser
.
pinnedTabCount
;
let
allTabs
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
;
let
isGrid
=
this
.
#
isContainerVerticalPinnedGrid
(
tab
)
;
let
periphery
=
document
.
getElementById
(
"
tabbrowser
-
arrowscrollbox
-
periphery
"
)
;
if
(
isPinned
&
&
this
.
#
tabbrowserTabs
.
verticalMode
)
{
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
setAttribute
(
"
dragActive
"
"
"
)
;
}
let
pinnedRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
scrollbox
)
;
let
pinnedContainerRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
)
;
let
unpinnedRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
#
tabbrowserTabs
.
arrowScrollbox
.
scrollbox
)
;
let
tabContainerRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
#
tabbrowserTabs
)
;
if
(
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
firstChild
)
{
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
scrollbox
.
style
.
height
=
pinnedRect
.
height
+
"
px
"
;
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
style
.
minHeight
=
pinnedContainerRect
.
height
+
"
px
"
;
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
scrollbox
.
style
.
width
=
pinnedRect
.
width
+
"
px
"
;
}
this
.
#
tabbrowserTabs
.
arrowScrollbox
.
scrollbox
.
style
.
height
=
unpinnedRect
.
height
+
"
px
"
;
this
.
#
tabbrowserTabs
.
arrowScrollbox
.
scrollbox
.
style
.
width
=
unpinnedRect
.
width
+
"
px
"
;
let
{
movingTabs
movingTabsSet
expandGroupOnDrop
}
=
tab
.
_dragData
;
let
suppressTransitionsFor
=
[
]
;
const
pinnedTabsOrigBounds
=
new
Map
(
)
;
for
(
let
t
of
allTabs
)
{
t
=
elementToMove
(
t
)
;
let
tabRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
t
)
;
if
(
isGrid
&
&
t
.
pinned
)
{
pinnedTabsOrigBounds
.
set
(
t
tabRect
)
;
}
t
.
style
.
maxWidth
=
tabRect
.
width
+
"
px
"
;
let
isTabInCollapsingGroup
=
expandGroupOnDrop
&
&
t
.
group
=
=
tab
.
group
;
if
(
!
movingTabsSet
.
has
(
t
)
&
&
!
isTabInCollapsingGroup
)
{
t
.
style
.
transition
=
"
none
"
;
suppressTransitionsFor
.
push
(
t
)
;
}
}
if
(
suppressTransitionsFor
.
length
)
{
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
for
(
let
t
of
suppressTransitionsFor
)
{
t
.
style
.
transition
=
"
"
;
}
}
)
;
}
)
;
}
let
tabStripItemElement
=
elementToMove
(
tab
)
;
let
rect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
tabStripItemElement
)
;
let
movingTabsOffsetX
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
tabStripItemElement
.
offsetParent
)
.
x
;
let
movingTabsIndex
=
movingTabs
.
findIndex
(
t
=
>
t
.
_tPos
=
=
tab
.
_tPos
)
;
let
position
=
0
;
for
(
let
movingTab
of
movingTabs
.
slice
(
movingTabsIndex
)
)
{
movingTab
=
elementToMove
(
movingTab
)
;
movingTab
.
style
.
width
=
rect
.
width
+
"
px
"
;
movingTab
.
setAttribute
(
"
dragtarget
"
"
"
)
;
if
(
isTabGroupLabel
(
tab
)
)
{
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
movingTab
.
style
.
top
=
rect
.
top
-
unpinnedRect
.
top
+
"
px
"
;
}
else
{
movingTab
.
style
.
left
=
rect
.
left
-
movingTabsOffsetX
+
"
px
"
;
movingTab
.
style
.
height
=
rect
.
height
+
"
px
"
;
}
}
else
if
(
isGrid
)
{
movingTab
.
style
.
top
=
rect
.
top
-
pinnedRect
.
top
+
"
px
"
;
movingTab
.
style
.
left
=
rect
.
left
-
movingTabsOffsetX
+
position
+
"
px
"
;
position
+
=
rect
.
width
;
}
else
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
movingTab
.
style
.
top
=
rect
.
top
-
tabContainerRect
.
top
+
position
+
"
px
"
;
position
+
=
rect
.
height
;
}
else
if
(
this
.
#
rtlMode
)
{
movingTab
.
style
.
left
=
rect
.
left
-
movingTabsOffsetX
-
position
+
"
px
"
;
position
-
=
rect
.
width
;
}
else
{
movingTab
.
style
.
left
=
rect
.
left
-
movingTabsOffsetX
+
position
+
"
px
"
;
position
+
=
rect
.
width
;
}
}
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
position
=
-
rect
.
height
;
}
else
if
(
this
.
#
rtlMode
)
{
position
=
rect
.
width
;
}
else
{
position
=
-
rect
.
width
;
}
for
(
let
movingTab
of
movingTabs
.
slice
(
0
movingTabsIndex
)
.
reverse
(
)
)
{
movingTab
.
style
.
width
=
rect
.
width
+
"
px
"
;
movingTab
.
setAttribute
(
"
dragtarget
"
"
"
)
;
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
movingTab
.
style
.
top
=
rect
.
top
-
tabContainerRect
.
top
+
position
+
"
px
"
;
position
-
=
rect
.
height
;
}
else
if
(
this
.
#
rtlMode
)
{
movingTab
.
style
.
left
=
rect
.
left
-
movingTabsOffsetX
-
position
+
"
px
"
;
position
+
=
rect
.
width
;
}
else
{
movingTab
.
style
.
left
=
rect
.
left
-
movingTabsOffsetX
+
position
+
"
px
"
;
position
-
=
rect
.
width
;
}
}
if
(
!
isPinned
&
&
this
.
#
tabbrowserTabs
.
arrowScrollbox
.
hasAttribute
(
"
overflowing
"
)
)
{
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
periphery
.
style
.
marginBlockStart
=
rect
.
height
*
movingTabs
.
length
+
"
px
"
;
}
else
{
periphery
.
style
.
marginInlineStart
=
rect
.
width
*
movingTabs
.
length
+
"
px
"
;
}
}
else
if
(
isPinned
&
&
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
hasAttribute
(
"
overflowing
"
)
)
{
let
pinnedPeriphery
=
document
.
createXULElement
(
"
hbox
"
)
;
pinnedPeriphery
.
id
=
"
pinned
-
tabs
-
container
-
periphery
"
;
pinnedPeriphery
.
style
.
width
=
"
100
%
"
;
pinnedPeriphery
.
style
.
marginBlockStart
=
(
isGrid
&
&
numPinned
%
this
.
#
maxTabsPerRow
=
=
1
?
rect
.
height
:
rect
.
height
*
movingTabs
.
length
)
+
"
px
"
;
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
appendChild
(
pinnedPeriphery
)
;
}
let
setElPosition
=
el
=
>
{
let
elRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
el
)
;
if
(
this
.
#
tabbrowserTabs
.
verticalMode
&
&
elRect
.
top
>
rect
.
top
)
{
el
.
style
.
top
=
movingTabs
.
length
*
rect
.
height
+
"
px
"
;
}
else
if
(
!
this
.
#
tabbrowserTabs
.
verticalMode
)
{
if
(
!
this
.
#
rtlMode
&
&
elRect
.
left
>
rect
.
left
)
{
el
.
style
.
left
=
movingTabs
.
length
*
rect
.
width
+
"
px
"
;
}
else
if
(
this
.
#
rtlMode
&
&
elRect
.
left
<
rect
.
left
)
{
el
.
style
.
left
=
movingTabs
.
length
*
-
rect
.
width
+
"
px
"
;
}
}
}
;
let
setGridElPosition
=
el
=
>
{
let
origBounds
=
pinnedTabsOrigBounds
.
get
(
el
)
;
if
(
!
origBounds
)
{
return
;
}
let
newBounds
=
el
.
getBoundingClientRect
(
)
;
let
shiftX
=
origBounds
.
x
-
newBounds
.
x
;
let
shiftY
=
origBounds
.
y
-
newBounds
.
y
;
el
.
style
.
left
=
shiftX
+
"
px
"
;
el
.
style
.
top
=
shiftY
+
"
px
"
;
}
;
for
(
let
t
of
allTabs
)
{
let
tabIsPinned
=
t
.
pinned
;
t
=
elementToMove
(
t
)
;
if
(
!
t
.
hasAttribute
(
"
dragtarget
"
)
)
{
if
(
(
!
isPinned
&
&
!
tabIsPinned
)
|
|
(
tabIsPinned
&
&
isPinned
&
&
!
isGrid
)
)
{
setElPosition
(
t
)
;
}
else
if
(
isGrid
&
&
tabIsPinned
&
&
isPinned
)
{
setGridElPosition
(
t
)
;
}
}
}
if
(
this
.
#
tabbrowserTabs
.
expandOnHover
)
{
const
{
SidebarController
}
=
tab
.
ownerGlobal
;
SidebarController
.
expandOnHoverComplete
.
then
(
async
(
)
=
>
{
const
width
=
await
window
.
promiseDocumentFlushed
(
(
)
=
>
SidebarController
.
sidebarMain
.
clientWidth
)
;
requestAnimationFrame
(
(
)
=
>
{
for
(
const
t
of
movingTabs
)
{
t
.
style
.
width
=
width
+
"
px
"
;
}
this
.
#
tabbrowserTabs
.
arrowScrollbox
.
scrollbox
.
style
.
width
=
"
"
;
this
.
#
tabbrowserTabs
.
pinnedTabsContainer
.
scrollbox
.
style
.
width
=
"
"
;
}
)
;
}
)
;
}
if
(
!
this
.
#
tabbrowserTabs
.
overflowing
&
&
!
isPinned
)
{
if
(
this
.
#
tabbrowserTabs
.
verticalMode
)
{
periphery
.
style
.
top
=
{
Math
.
round
(
movingTabs
.
length
*
rect
.
height
)
}
px
;
}
else
if
(
this
.
#
rtlMode
)
{
periphery
.
style
.
left
=
{
Math
.
round
(
movingTabs
.
length
*
-
rect
.
width
)
}
px
;
}
else
{
periphery
.
style
.
left
=
{
Math
.
round
(
movingTabs
.
length
*
rect
.
width
)
}
px
;
}
}
}
#
moveTogetherSelectedTabs
(
tab
)
{
let
draggedTabIndex
=
tab
.
elementIndex
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
if
(
selectedTabs
.
some
(
t
=
>
t
.
pinned
!
=
tab
.
pinned
)
)
{
throw
new
Error
(
"
Cannot
move
together
a
mix
of
pinned
and
unpinned
tabs
.
"
)
;
}
let
animate
=
!
gReduceMotion
;
tab
.
_moveTogetherSelectedTabsData
=
{
finished
:
!
animate
}
;
let
addAnimationData
=
(
movingTab
isBeforeSelectedTab
)
=
>
{
let
lowerIndex
=
Math
.
min
(
movingTab
.
elementIndex
draggedTabIndex
)
+
1
;
let
higherIndex
=
Math
.
max
(
movingTab
.
elementIndex
draggedTabIndex
)
;
let
middleItems
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
.
slice
(
lowerIndex
higherIndex
)
.
filter
(
item
=
>
!
item
.
multiselected
)
;
if
(
!
middleItems
.
length
)
{
return
;
}
movingTab
.
_moveTogetherSelectedTabsData
=
{
translatePos
:
0
animate
:
true
}
;
movingTab
.
toggleAttribute
(
"
multiselected
-
move
-
together
"
true
)
;
let
postTransitionCleanup
=
(
)
=
>
{
movingTab
.
_moveTogetherSelectedTabsData
.
animate
=
false
;
}
;
if
(
gReduceMotion
)
{
postTransitionCleanup
(
)
;
}
else
{
let
onTransitionEnd
=
transitionendEvent
=
>
{
if
(
transitionendEvent
.
propertyName
!
=
"
transform
"
|
|
transitionendEvent
.
originalTarget
!
=
movingTab
)
{
return
;
}
movingTab
.
removeEventListener
(
"
transitionend
"
onTransitionEnd
)
;
postTransitionCleanup
(
)
;
}
;
movingTab
.
addEventListener
(
"
transitionend
"
onTransitionEnd
)
;
}
let
movingTabSize
=
movingTab
.
getBoundingClientRect
(
)
[
this
.
#
tabbrowserTabs
.
verticalMode
?
"
height
"
:
"
width
"
]
;
for
(
let
middleItem
of
middleItems
)
{
if
(
isTab
(
middleItem
)
)
{
if
(
middleItem
.
pinned
!
=
movingTab
.
pinned
)
{
break
;
}
if
(
middleItem
.
multiselected
)
{
continue
;
}
}
middleItem
=
elementToMove
(
middleItem
)
;
let
middleItemSize
=
middleItem
.
getBoundingClientRect
(
)
[
this
.
#
tabbrowserTabs
.
verticalMode
?
"
height
"
:
"
width
"
]
;
if
(
!
middleItem
.
_moveTogetherSelectedTabsData
?
.
translatePos
)
{
middleItem
.
_moveTogetherSelectedTabsData
=
{
translatePos
:
0
}
;
}
movingTab
.
_moveTogetherSelectedTabsData
.
translatePos
+
=
isBeforeSelectedTab
?
middleItemSize
:
-
middleItemSize
;
middleItem
.
_moveTogetherSelectedTabsData
.
translatePos
=
isBeforeSelectedTab
?
-
movingTabSize
:
movingTabSize
;
middleItem
.
toggleAttribute
(
"
multiselected
-
move
-
together
"
true
)
;
}
}
;
let
tabIndex
=
selectedTabs
.
indexOf
(
tab
)
;
for
(
let
i
=
0
;
i
<
tabIndex
;
i
+
+
)
{
let
movingTab
=
selectedTabs
[
i
]
;
if
(
animate
)
{
addAnimationData
(
movingTab
true
)
;
}
else
{
gBrowser
.
moveTabBefore
(
movingTab
tab
)
;
}
}
for
(
let
i
=
selectedTabs
.
length
-
1
;
i
>
tabIndex
;
i
-
-
)
{
let
movingTab
=
selectedTabs
[
i
]
;
if
(
animate
)
{
addAnimationData
(
movingTab
false
)
;
}
else
{
gBrowser
.
moveTabAfter
(
movingTab
tab
)
;
}
}
for
(
let
item
of
this
.
#
tabbrowserTabs
.
ariaFocusableItems
)
{
item
=
elementToMove
(
item
)
;
if
(
item
.
_moveTogetherSelectedTabsData
?
.
translatePos
)
{
let
translatePos
=
(
this
.
#
rtlMode
?
-
1
:
1
)
*
item
.
_moveTogetherSelectedTabsData
.
translatePos
;
item
.
style
.
transform
=
translate
{
this
.
#
tabbrowserTabs
.
verticalMode
?
"
Y
"
:
"
X
"
}
(
{
translatePos
}
px
)
;
}
}
}
#
isAnimatingMoveTogetherSelectedTabs
(
)
{
for
(
let
tab
of
gBrowser
.
selectedTabs
)
{
if
(
tab
.
_moveTogetherSelectedTabsData
?
.
animate
)
{
return
true
;
}
}
return
false
;
}
finishMoveTogetherSelectedTabs
(
tab
)
{
if
(
!
tab
.
_moveTogetherSelectedTabsData
|
|
tab
.
_moveTogetherSelectedTabsData
.
finished
)
{
return
;
}
tab
.
_moveTogetherSelectedTabsData
.
finished
=
true
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
tabIndex
=
selectedTabs
.
indexOf
(
tab
)
;
for
(
let
i
=
0
;
i
<
tabIndex
;
i
+
+
)
{
gBrowser
.
moveTabBefore
(
selectedTabs
[
i
]
tab
)
;
}
for
(
let
i
=
selectedTabs
.
length
-
1
;
i
>
tabIndex
;
i
-
-
)
{
gBrowser
.
moveTabAfter
(
selectedTabs
[
i
]
tab
)
;
}
for
(
let
item
of
this
.
#
tabbrowserTabs
.
ariaFocusableItems
)
{
item
=
elementToMove
(
item
)
;
item
.
style
.
transform
=
"
"
;
item
.
removeAttribute
(
"
multiselected
-
move
-
together
"
)
;
delete
item
.
_moveTogetherSelectedTabsData
;
}
}
#
animateExpandedPinnedTabMove
(
event
)
{
let
draggedTab
=
event
.
dataTransfer
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
let
dragData
=
draggedTab
.
_dragData
;
let
movingTabs
=
dragData
.
movingTabs
;
dragData
.
animLastScreenX
?
?
=
dragData
.
screenX
;
dragData
.
animLastScreenY
?
?
=
dragData
.
screenY
;
let
screenX
=
event
.
screenX
;
let
screenY
=
event
.
screenY
;
if
(
screenY
=
=
dragData
.
animLastScreenY
&
&
screenX
=
=
dragData
.
animLastScreenX
)
{
return
;
}
let
tabs
=
this
.
#
tabbrowserTabs
.
visibleTabs
.
slice
(
0
gBrowser
.
pinnedTabCount
)
;
let
directionX
=
screenX
>
dragData
.
animLastScreenX
;
let
directionY
=
screenY
>
dragData
.
animLastScreenY
;
dragData
.
animLastScreenY
=
screenY
;
dragData
.
animLastScreenX
=
screenX
;
let
{
width
:
tabWidth
height
:
tabHeight
}
=
draggedTab
.
getBoundingClientRect
(
)
;
let
shiftSizeX
=
tabWidth
*
movingTabs
.
length
;
let
shiftSizeY
=
tabHeight
;
dragData
.
tabWidth
=
tabWidth
;
dragData
.
tabHeight
=
tabHeight
;
let
firstTabInRow
;
let
lastTabInRow
;
let
lastTab
=
tabs
.
at
(
-
1
)
;
let
periphery
=
document
.
getElementById
(
"
tabbrowser
-
arrowscrollbox
-
periphery
"
)
;
if
(
RTL_UI
)
{
firstTabInRow
=
tabs
.
length
>
=
this
.
#
maxTabsPerRow
?
tabs
[
this
.
#
maxTabsPerRow
-
1
]
:
lastTab
;
lastTabInRow
=
tabs
[
0
]
;
}
else
{
firstTabInRow
=
tabs
[
0
]
;
lastTabInRow
=
tabs
.
length
>
=
this
.
#
maxTabsPerRow
?
tabs
[
this
.
#
maxTabsPerRow
-
1
]
:
lastTab
;
}
let
lastMovingTabScreenX
=
movingTabs
.
at
(
-
1
)
.
screenX
;
let
lastMovingTabScreenY
=
movingTabs
.
at
(
-
1
)
.
screenY
;
let
firstMovingTabScreenX
=
movingTabs
[
0
]
.
screenX
;
let
firstMovingTabScreenY
=
movingTabs
[
0
]
.
screenY
;
let
translateX
=
screenX
-
dragData
.
screenX
;
let
translateY
=
screenY
-
dragData
.
screenY
;
let
firstBoundX
=
firstTabInRow
.
screenX
-
firstMovingTabScreenX
;
let
firstBoundY
=
this
.
#
tabbrowserTabs
.
screenY
-
firstMovingTabScreenY
;
let
lastBoundX
=
lastTabInRow
.
screenX
+
lastTabInRow
.
getBoundingClientRect
(
)
.
width
-
(
lastMovingTabScreenX
+
tabWidth
)
;
let
lastBoundY
=
periphery
.
screenY
-
(
lastMovingTabScreenY
+
tabHeight
)
;
translateX
=
Math
.
min
(
Math
.
max
(
translateX
firstBoundX
)
lastBoundX
)
;
translateY
=
Math
.
min
(
Math
.
max
(
translateY
firstBoundY
)
lastBoundY
)
;
if
(
screen
<
draggedTab
.
screenY
+
translateY
|
|
screen
>
draggedTab
.
screenY
+
tabHeight
+
translateY
)
{
translateY
=
screen
-
draggedTab
.
screenY
-
tabHeight
/
2
;
}
for
(
let
tab
of
movingTabs
)
{
tab
.
style
.
transform
=
translate
(
{
translateX
}
px
{
translateY
}
px
)
;
}
dragData
.
translateX
=
translateX
;
dragData
.
translateY
=
translateY
;
tabs
=
tabs
.
filter
(
t
=
>
!
movingTabs
.
includes
(
t
)
|
|
t
=
=
draggedTab
)
;
let
firstTabCenterX
=
firstMovingTabScreenX
+
translateX
+
tabWidth
/
2
;
let
lastTabCenterX
=
lastMovingTabScreenX
+
translateX
+
tabWidth
/
2
;
let
tabCenterX
=
directionX
?
lastTabCenterX
:
firstTabCenterX
;
let
firstTabCenterY
=
firstMovingTabScreenY
+
translateY
+
tabHeight
/
2
;
let
lastTabCenterY
=
lastMovingTabScreenY
+
translateY
+
tabHeight
/
2
;
let
tabCenterY
=
directionY
?
lastTabCenterY
:
firstTabCenterY
;
let
shiftNumber
=
this
.
#
maxTabsPerRow
-
movingTabs
.
length
;
let
getTabShift
=
(
tab
dropIndex
)
=
>
{
if
(
tab
.
elementIndex
<
draggedTab
.
elementIndex
&
&
tab
.
elementIndex
>
=
dropIndex
)
{
let
tabRow
=
Math
.
ceil
(
(
tab
.
elementIndex
+
1
)
/
this
.
#
maxTabsPerRow
)
;
let
shiftedTabRow
=
Math
.
ceil
(
(
tab
.
elementIndex
+
1
+
movingTabs
.
length
)
/
this
.
#
maxTabsPerRow
)
;
if
(
tab
.
elementIndex
&
&
tabRow
!
=
shiftedTabRow
)
{
return
[
RTL_UI
?
tabWidth
*
shiftNumber
:
-
tabWidth
*
shiftNumber
shiftSizeY
]
;
}
return
[
RTL_UI
?
-
shiftSizeX
:
shiftSizeX
0
]
;
}
if
(
tab
.
elementIndex
>
draggedTab
.
elementIndex
&
&
tab
.
elementIndex
<
dropIndex
)
{
let
tabRow
=
Math
.
floor
(
tab
.
elementIndex
/
this
.
#
maxTabsPerRow
)
;
let
shiftedTabRow
=
Math
.
floor
(
(
tab
.
elementIndex
-
movingTabs
.
length
)
/
this
.
#
maxTabsPerRow
)
;
if
(
tab
.
elementIndex
&
&
tabRow
!
=
shiftedTabRow
)
{
return
[
RTL_UI
?
-
tabWidth
*
shiftNumber
:
tabWidth
*
shiftNumber
-
shiftSizeY
]
;
}
return
[
RTL_UI
?
shiftSizeX
:
-
shiftSizeX
0
]
;
}
return
[
0
0
]
;
}
;
let
low
=
0
;
let
high
=
tabs
.
length
-
1
;
let
newIndex
=
-
1
;
let
oldIndex
=
dragData
.
animDropElementIndex
?
?
movingTabs
[
0
]
.
elementIndex
;
while
(
low
<
=
high
)
{
let
mid
=
Math
.
floor
(
(
low
+
high
)
/
2
)
;
if
(
tabs
[
mid
]
=
=
draggedTab
&
&
+
+
mid
>
high
)
{
break
;
}
let
[
shiftX
shiftY
]
=
getTabShift
(
tabs
[
mid
]
oldIndex
)
;
screenX
=
tabs
[
mid
]
.
screenX
+
shiftX
;
screenY
=
tabs
[
mid
]
.
screenY
+
shiftY
;
if
(
screenY
+
tabHeight
<
tabCenterY
)
{
low
=
mid
+
1
;
}
else
if
(
screenY
>
tabCenterY
)
{
high
=
mid
-
1
;
}
else
if
(
RTL_UI
?
screenX
+
tabWidth
<
tabCenterX
:
screenX
>
tabCenterX
)
{
high
=
mid
-
1
;
}
else
if
(
RTL_UI
?
screenX
>
tabCenterX
:
screenX
+
tabWidth
<
tabCenterX
)
{
low
=
mid
+
1
;
}
else
{
newIndex
=
tabs
[
mid
]
.
elementIndex
;
break
;
}
}
if
(
newIndex
>
=
oldIndex
&
&
newIndex
<
tabs
.
length
)
{
newIndex
+
+
;
}
if
(
newIndex
<
0
)
{
newIndex
=
oldIndex
;
}
if
(
newIndex
=
=
dragData
.
animDropElementIndex
)
{
return
;
}
dragData
.
animDropElementIndex
=
newIndex
;
dragData
.
dropElement
=
tabs
[
Math
.
min
(
newIndex
tabs
.
length
-
1
)
]
;
dragData
.
dropBefore
=
newIndex
<
tabs
.
length
;
for
(
let
tab
of
tabs
)
{
if
(
tab
!
=
draggedTab
)
{
let
[
shiftX
shiftY
]
=
getTabShift
(
tab
newIndex
)
;
tab
.
style
.
transform
=
shiftX
|
|
shiftY
?
translate
(
{
shiftX
}
px
{
shiftY
}
px
)
:
"
"
;
}
}
}
#
animateTabMove
(
event
)
{
let
draggedTab
=
event
.
dataTransfer
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
let
dragData
=
draggedTab
.
_dragData
;
let
movingTabs
=
dragData
.
movingTabs
;
let
movingTabsSet
=
dragData
.
movingTabsSet
;
dragData
.
animLastScreenPos
?
?
=
this
.
#
tabbrowserTabs
.
verticalMode
?
dragData
.
screenY
:
dragData
.
screenX
;
let
screen
=
this
.
#
tabbrowserTabs
.
verticalMode
?
event
.
screenY
:
event
.
screenX
;
if
(
screen
=
=
dragData
.
animLastScreenPos
)
{
return
;
}
let
screenForward
=
screen
>
dragData
.
animLastScreenPos
;
dragData
.
animLastScreenPos
=
screen
;
this
.
#
clearDragOverGroupingTimer
(
)
;
this
.
#
clearPinnedDropIndicatorTimer
(
)
;
let
isPinned
=
draggedTab
.
pinned
;
let
numPinned
=
gBrowser
.
pinnedTabCount
;
let
allTabs
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
;
let
tabs
=
allTabs
.
slice
(
isPinned
?
0
:
numPinned
isPinned
?
numPinned
:
undefined
)
;
if
(
this
.
#
rtlMode
)
{
tabs
.
reverse
(
)
;
}
let
bounds
=
ele
=
>
window
.
windowUtils
.
getBoundsWithoutFlushing
(
ele
)
;
let
logicalForward
=
screenForward
!
=
this
.
#
rtlMode
;
let
screenAxis
=
this
.
#
tabbrowserTabs
.
verticalMode
?
"
screenY
"
:
"
screenX
"
;
let
size
=
this
.
#
tabbrowserTabs
.
verticalMode
?
"
height
"
:
"
width
"
;
let
translateAxis
=
this
.
#
tabbrowserTabs
.
verticalMode
?
"
translateY
"
:
"
translateX
"
;
let
{
width
:
tabWidth
height
:
tabHeight
}
=
bounds
(
draggedTab
)
;
let
tabSize
=
this
.
#
tabbrowserTabs
.
verticalMode
?
tabHeight
:
tabWidth
;
let
translateX
=
event
.
screenX
-
dragData
.
screenX
;
let
translateY
=
event
.
screenY
-
dragData
.
screenY
;
dragData
.
tabWidth
=
tabWidth
;
dragData
.
tabHeight
=
tabHeight
;
dragData
.
translateX
=
translateX
;
dragData
.
translateY
=
translateY
;
let
periphery
=
document
.
getElementById
(
"
tabbrowser
-
arrowscrollbox
-
periphery
"
)
;
let
lastMovingTab
=
movingTabs
.
at
(
-
1
)
;
let
firstMovingTab
=
movingTabs
[
0
]
;
let
endEdge
=
ele
=
>
ele
[
screenAxis
]
+
bounds
(
ele
)
[
size
]
;
let
lastMovingTabScreen
=
endEdge
(
lastMovingTab
)
;
let
firstMovingTabScreen
=
firstMovingTab
[
screenAxis
]
;
let
shiftSize
=
lastMovingTabScreen
-
firstMovingTabScreen
;
let
translate
=
screen
-
dragData
[
screenAxis
]
;
let
startBound
=
this
.
#
rtlMode
?
endEdge
(
periphery
)
+
1
-
firstMovingTabScreen
:
this
.
#
tabbrowserTabs
[
screenAxis
]
-
firstMovingTabScreen
;
let
endBound
=
this
.
#
rtlMode
?
endEdge
(
this
.
#
tabbrowserTabs
)
-
lastMovingTabScreen
:
periphery
[
screenAxis
]
-
1
-
lastMovingTabScreen
;
translate
=
Math
.
min
(
Math
.
max
(
translate
startBound
)
endBound
)
;
let
draggedTabScreenAxis
=
draggedTab
[
screenAxis
]
+
translate
;
if
(
(
screen
<
draggedTabScreenAxis
|
|
screen
>
draggedTabScreenAxis
+
tabSize
)
&
&
draggedTabScreenAxis
+
tabSize
<
endBound
&
&
draggedTabScreenAxis
>
startBound
)
{
translate
=
screen
-
draggedTab
[
screenAxis
]
-
tabSize
/
2
;
translate
=
Math
.
min
(
Math
.
max
(
translate
startBound
)
endBound
)
;
}
if
(
!
gBrowser
.
pinnedTabCount
&
&
!
this
.
#
dragToPinPromoCard
.
shouldRender
)
{
let
pinnedDropIndicatorMargin
=
parseFloat
(
window
.
getComputedStyle
(
this
.
#
pinnedDropIndicator
)
.
marginInline
)
;
this
.
#
checkWithinPinnedContainerBounds
(
{
firstMovingTabScreen
lastMovingTabScreen
pinnedTabsStartEdge
:
this
.
#
rtlMode
?
endEdge
(
this
.
#
tabbrowserTabs
.
arrowScrollbox
)
+
pinnedDropIndicatorMargin
:
this
[
screenAxis
]
pinnedTabsEndEdge
:
this
.
#
rtlMode
?
endEdge
(
this
.
#
tabbrowserTabs
)
:
this
.
#
tabbrowserTabs
.
arrowScrollbox
[
screenAxis
]
-
pinnedDropIndicatorMargin
translate
draggedTab
}
)
;
}
for
(
let
item
of
movingTabs
)
{
item
=
elementToMove
(
item
)
;
item
.
style
.
transform
=
{
translateAxis
}
(
{
translate
}
px
)
;
}
dragData
.
translatePos
=
translate
;
tabs
=
tabs
.
filter
(
t
=
>
!
movingTabsSet
.
has
(
t
)
|
|
t
=
=
draggedTab
)
;
let
getTabShift
=
(
item
dropElementIndex
)
=
>
{
if
(
item
.
elementIndex
<
draggedTab
.
elementIndex
&
&
item
.
elementIndex
>
=
dropElementIndex
)
{
return
this
.
#
rtlMode
?
-
shiftSize
:
shiftSize
;
}
if
(
item
.
elementIndex
>
draggedTab
.
elementIndex
&
&
item
.
elementIndex
<
dropElementIndex
)
{
return
this
.
#
rtlMode
?
shiftSize
:
-
shiftSize
;
}
return
0
;
}
;
let
oldDropElementIndex
=
dragData
.
animDropElementIndex
?
?
movingTabs
[
0
]
.
elementIndex
;
function
greatestOverlap
(
p1
s1
p2
s2
)
{
let
overlapSize
;
if
(
p1
<
p2
)
{
overlapSize
=
p1
+
s1
-
p2
;
}
else
{
overlapSize
=
p2
+
s2
-
p1
;
}
if
(
overlapSize
<
=
0
)
{
return
0
;
}
let
overlapPercent
=
Math
.
max
(
overlapSize
/
s1
overlapSize
/
s2
)
;
return
Math
.
min
(
overlapPercent
1
)
;
}
let
getOverlappedElement
=
(
)
=
>
{
let
point
=
(
screenForward
?
lastMovingTabScreen
:
firstMovingTabScreen
)
+
translate
;
let
low
=
0
;
let
high
=
tabs
.
length
-
1
;
while
(
low
<
=
high
)
{
let
mid
=
Math
.
floor
(
(
low
+
high
)
/
2
)
;
if
(
tabs
[
mid
]
=
=
draggedTab
&
&
+
+
mid
>
high
)
{
break
;
}
let
element
=
tabs
[
mid
]
;
let
elementForSize
=
elementToMove
(
element
)
;
screen
=
elementForSize
[
screenAxis
]
+
getTabShift
(
element
oldDropElementIndex
)
;
if
(
screen
>
point
)
{
high
=
mid
-
1
;
}
else
if
(
screen
+
bounds
(
elementForSize
)
[
size
]
<
point
)
{
low
=
mid
+
1
;
}
else
{
return
element
;
}
}
return
null
;
}
;
let
dropElement
=
getOverlappedElement
(
)
;
let
newDropElementIndex
;
if
(
dropElement
)
{
newDropElementIndex
=
dropElement
.
elementIndex
;
}
else
{
newDropElementIndex
=
oldDropElementIndex
;
let
lastPossibleDropElement
=
this
.
#
rtlMode
?
tabs
.
find
(
t
=
>
t
!
=
draggedTab
)
:
tabs
.
findLast
(
t
=
>
t
!
=
draggedTab
)
;
let
maxElementIndexForDropElement
=
lastPossibleDropElement
?
.
elementIndex
;
if
(
Number
.
isInteger
(
maxElementIndexForDropElement
)
)
{
let
index
=
Math
.
min
(
oldDropElementIndex
maxElementIndexForDropElement
)
;
let
oldDropElementCandidate
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
.
at
(
index
)
;
if
(
!
movingTabsSet
.
has
(
oldDropElementCandidate
)
)
{
dropElement
=
oldDropElementCandidate
;
}
}
}
let
moveOverThreshold
;
let
overlapPercent
;
let
dropBefore
;
if
(
dropElement
)
{
let
dropElementForOverlap
=
elementToMove
(
dropElement
)
;
let
dropElementScreen
=
dropElementForOverlap
[
screenAxis
]
;
let
dropElementPos
=
dropElementScreen
+
getTabShift
(
dropElement
oldDropElementIndex
)
;
let
dropElementSize
=
bounds
(
dropElementForOverlap
)
[
size
]
;
let
firstMovingTabPos
=
firstMovingTabScreen
+
translate
;
overlapPercent
=
greatestOverlap
(
firstMovingTabPos
shiftSize
dropElementPos
dropElementSize
)
;
moveOverThreshold
=
gBrowser
.
_tabGroupsEnabled
?
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
dragDrop
.
moveOverThresholdPercent
"
)
/
100
:
0
.
5
;
moveOverThreshold
=
Math
.
min
(
1
Math
.
max
(
0
moveOverThreshold
)
)
;
let
shouldMoveOver
=
overlapPercent
>
moveOverThreshold
;
if
(
logicalForward
&
&
shouldMoveOver
)
{
newDropElementIndex
+
+
;
}
else
if
(
!
logicalForward
&
&
!
shouldMoveOver
)
{
newDropElementIndex
+
+
;
if
(
newDropElementIndex
>
oldDropElementIndex
)
{
newDropElementIndex
=
oldDropElementIndex
;
}
}
dropElementPos
=
dropElementScreen
+
getTabShift
(
dropElement
newDropElementIndex
)
;
overlapPercent
=
greatestOverlap
(
firstMovingTabPos
shiftSize
dropElementPos
dropElementSize
)
;
dropBefore
=
firstMovingTabPos
<
dropElementPos
;
if
(
this
.
#
rtlMode
)
{
dropBefore
=
!
dropBefore
;
}
if
(
isTabGroupLabel
(
draggedTab
)
&
&
dropElement
?
.
group
&
&
(
!
dropElement
.
group
.
collapsed
|
|
(
dropElement
.
group
.
collapsed
&
&
dropElement
.
group
.
hasActiveTab
)
)
)
{
let
overlappedGroup
=
dropElement
.
group
;
if
(
isTabGroupLabel
(
dropElement
)
)
{
dropBefore
=
true
;
newDropElementIndex
=
dropElement
.
elementIndex
;
}
else
{
dropBefore
=
false
;
let
lastVisibleTabInGroup
=
overlappedGroup
.
tabs
.
findLast
(
tab
=
>
tab
.
visible
)
;
newDropElementIndex
=
lastVisibleTabInGroup
.
elementIndex
+
1
;
}
dropElement
=
overlappedGroup
;
}
let
isOutOfBounds
=
isPinned
?
dropElement
.
elementIndex
>
=
numPinned
:
dropElement
.
elementIndex
<
numPinned
;
if
(
isOutOfBounds
)
{
dropElement
=
this
.
#
tabbrowserTabs
.
ariaFocusableItems
[
numPinned
-
1
]
;
dropBefore
=
false
;
}
}
if
(
gBrowser
.
_tabGroupsEnabled
&
&
isTab
(
draggedTab
)
&
&
!
isPinned
&
&
(
!
numPinned
|
|
newDropElementIndex
>
numPinned
)
)
{
let
dragOverGroupingThreshold
=
1
-
moveOverThreshold
;
let
groupingDelay
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
dragDrop
.
createGroup
.
delayMS
"
)
;
let
shouldCreateGroupOnDrop
=
!
movingTabsSet
.
has
(
dropElement
)
&
&
isTab
(
dropElement
)
&
&
!
dropElement
?
.
group
&
&
overlapPercent
>
dragOverGroupingThreshold
;
let
shouldDropIntoCollapsedTabGroup
=
isTabGroupLabel
(
dropElement
)
&
&
dropElement
.
group
.
collapsed
&
&
overlapPercent
>
dragOverGroupingThreshold
;
if
(
shouldCreateGroupOnDrop
)
{
this
.
#
dragOverGroupingTimer
=
setTimeout
(
(
)
=
>
{
this
.
#
triggerDragOverGrouping
(
dropElement
)
;
dragData
.
shouldCreateGroupOnDrop
=
true
;
this
.
#
setDragOverGroupColor
(
dragData
.
tabGroupCreationColor
)
;
}
groupingDelay
)
;
}
else
if
(
shouldDropIntoCollapsedTabGroup
)
{
this
.
#
dragOverGroupingTimer
=
setTimeout
(
(
)
=
>
{
this
.
#
triggerDragOverGrouping
(
dropElement
)
;
dragData
.
shouldDropIntoCollapsedTabGroup
=
true
;
this
.
#
setDragOverGroupColor
(
dropElement
.
group
.
color
)
;
}
groupingDelay
)
;
}
else
{
this
.
#
tabbrowserTabs
.
removeAttribute
(
"
movingtab
-
group
"
)
;
this
.
#
resetGroupTarget
(
document
.
querySelector
(
"
[
dragover
-
groupTarget
]
"
)
)
;
delete
dragData
.
shouldCreateGroupOnDrop
;
delete
dragData
.
shouldDropIntoCollapsedTabGroup
;
let
dropElementGroup
=
dropElement
?
.
group
;
let
colorCode
=
dropElementGroup
?
.
color
;
let
lastUnmovingTabInGroup
=
dropElementGroup
?
.
tabs
.
findLast
(
t
=
>
!
movingTabsSet
.
has
(
t
)
)
;
if
(
isTab
(
dropElement
)
&
&
dropElementGroup
&
&
dropElement
=
=
lastUnmovingTabInGroup
&
&
!
dropBefore
&
&
overlapPercent
<
dragOverGroupingThreshold
)
{
dropElement
=
dropElementGroup
;
colorCode
=
undefined
;
}
else
if
(
isTabGroupLabel
(
dropElement
)
)
{
if
(
dropBefore
)
{
dropElement
=
dropElementGroup
;
colorCode
=
undefined
;
}
else
if
(
dropElementGroup
.
collapsed
)
{
dropElement
=
dropElementGroup
;
colorCode
=
undefined
;
}
else
{
dropElement
=
dropElementGroup
.
tabs
[
0
]
;
dropBefore
=
true
;
}
}
this
.
#
setDragOverGroupColor
(
colorCode
)
;
this
.
#
tabbrowserTabs
.
toggleAttribute
(
"
movingtab
-
addToGroup
"
colorCode
)
;
this
.
#
tabbrowserTabs
.
toggleAttribute
(
"
movingtab
-
ungroup
"
!
colorCode
)
;
}
}
if
(
newDropElementIndex
=
=
oldDropElementIndex
&
&
dropBefore
=
=
dragData
.
dropBefore
&
&
dropElement
=
=
dragData
.
dropElement
)
{
return
;
}
dragData
.
dropElement
=
dropElement
;
dragData
.
dropBefore
=
dropBefore
;
dragData
.
animDropElementIndex
=
newDropElementIndex
;
for
(
let
item
of
tabs
)
{
if
(
item
=
=
draggedTab
)
{
continue
;
}
let
shift
=
getTabShift
(
item
newDropElementIndex
)
;
let
transform
=
shift
?
{
translateAxis
}
(
{
shift
}
px
)
:
"
"
;
item
=
elementToMove
(
item
)
;
item
.
style
.
transform
=
transform
;
}
}
#
checkWithinPinnedContainerBounds
(
{
firstMovingTabScreen
lastMovingTabScreen
pinnedTabsStartEdge
pinnedTabsEndEdge
translate
draggedTab
}
)
{
let
firstMovingTabPosition
=
firstMovingTabScreen
+
translate
;
let
lastMovingTabPosition
=
lastMovingTabScreen
+
translate
;
let
buffer
=
20
;
let
inPinnedRange
=
this
.
#
rtlMode
?
lastMovingTabPosition
>
=
pinnedTabsStartEdge
:
firstMovingTabPosition
<
=
pinnedTabsEndEdge
;
let
inVisibleRange
=
this
.
#
rtlMode
?
lastMovingTabPosition
>
=
pinnedTabsStartEdge
-
buffer
:
firstMovingTabPosition
<
=
pinnedTabsEndEdge
+
buffer
;
let
isVisible
=
this
.
#
pinnedDropIndicator
.
hasAttribute
(
"
visible
"
)
;
let
isInteractive
=
this
.
#
pinnedDropIndicator
.
hasAttribute
(
"
interactive
"
)
;
if
(
this
.
#
pinnedDropIndicatorTimeout
&
&
!
inPinnedRange
&
&
!
inVisibleRange
&
&
!
isVisible
&
&
!
isInteractive
)
{
this
.
#
resetPinnedDropIndicator
(
)
;
}
else
if
(
isTab
(
draggedTab
)
&
&
(
(
inVisibleRange
&
&
!
isVisible
)
|
|
(
inPinnedRange
&
&
!
isInteractive
)
)
)
{
let
tabbrowserTabsRect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
#
tabbrowserTabs
)
;
if
(
!
this
.
#
tabbrowserTabs
.
verticalMode
)
{
this
.
#
tabbrowserTabs
.
style
.
maxWidth
=
tabbrowserTabsRect
.
width
+
"
px
"
;
}
if
(
isVisible
)
{
this
.
#
pinnedDropIndicator
.
setAttribute
(
"
interactive
"
"
"
)
;
}
else
if
(
!
this
.
#
pinnedDropIndicatorTimeout
)
{
let
interactionDelay
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
dragDrop
.
pinInteractionCue
.
delayMS
"
)
;
this
.
#
pinnedDropIndicatorTimeout
=
setTimeout
(
(
)
=
>
{
if
(
this
.
#
isMovingTab
(
)
)
{
this
.
#
pinnedDropIndicator
.
setAttribute
(
"
visible
"
"
"
)
;
this
.
#
pinnedDropIndicator
.
setAttribute
(
"
interactive
"
"
"
)
;
}
}
interactionDelay
)
;
}
}
else
if
(
!
inPinnedRange
)
{
this
.
#
pinnedDropIndicator
.
removeAttribute
(
"
interactive
"
)
;
}
}
#
clearPinnedDropIndicatorTimer
(
)
{
if
(
this
.
#
pinnedDropIndicatorTimeout
)
{
clearTimeout
(
this
.
#
pinnedDropIndicatorTimeout
)
;
this
.
#
pinnedDropIndicatorTimeout
=
null
;
}
}
#
resetPinnedDropIndicator
(
)
{
this
.
#
clearPinnedDropIndicatorTimer
(
)
;
this
.
#
pinnedDropIndicator
.
removeAttribute
(
"
visible
"
)
;
this
.
#
pinnedDropIndicator
.
removeAttribute
(
"
interactive
"
)
;
}
finishAnimateTabMove
(
)
{
if
(
!
this
.
#
isMovingTab
(
)
)
{
return
;
}
this
.
#
setMovingTabMode
(
false
)
;
for
(
let
item
of
this
.
#
tabbrowserTabs
.
ariaFocusableItems
)
{
this
.
#
resetGroupTarget
(
item
)
;
item
=
elementToMove
(
item
)
;
item
.
style
.
transform
=
"
"
;
}
this
.
#
tabbrowserTabs
.
removeAttribute
(
"
movingtab
-
group
"
)
;
this
.
#
tabbrowserTabs
.
removeAttribute
(
"
movingtab
-
ungroup
"
)
;
this
.
#
tabbrowserTabs
.
removeAttribute
(
"
movingtab
-
addToGroup
"
)
;
this
.
#
setDragOverGroupColor
(
null
)
;
this
.
#
clearDragOverGroupingTimer
(
)
;
this
.
#
resetPinnedDropIndicator
(
)
;
}
#
resetTabsAfterDrop
(
draggedTabDocument
=
document
)
{
if
(
this
.
#
tabbrowserTabs
.
expandOnHover
)
{
MousePosTracker
.
addListener
(
document
.
defaultView
.
SidebarController
)
;
}
let
pinnedDropIndicator
=
draggedTabDocument
.
getElementById
(
"
pinned
-
drop
-
indicator
"
)
;
pinnedDropIndicator
.
removeAttribute
(
"
visible
"
)
;
pinnedDropIndicator
.
removeAttribute
(
"
interactive
"
)
;
draggedTabDocument
.
ownerGlobal
.
gBrowser
.
tabContainer
.
style
.
maxWidth
=
"
"
;
let
allTabs
=
draggedTabDocument
.
getElementsByClassName
(
"
tabbrowser
-
tab
"
)
;
for
(
let
tab
of
allTabs
)
{
tab
.
style
.
width
=
"
"
;
tab
.
style
.
left
=
"
"
;
tab
.
style
.
top
=
"
"
;
tab
.
style
.
maxWidth
=
"
"
;
tab
.
removeAttribute
(
"
dragtarget
"
)
;
}
for
(
let
label
of
draggedTabDocument
.
getElementsByClassName
(
"
tab
-
group
-
label
-
container
"
)
)
{
label
.
style
.
width
=
"
"
;
label
.
style
.
height
=
"
"
;
label
.
style
.
left
=
"
"
;
label
.
style
.
top
=
"
"
;
label
.
style
.
maxWidth
=
"
"
;
label
.
removeAttribute
(
"
dragtarget
"
)
;
}
let
periphery
=
draggedTabDocument
.
getElementById
(
"
tabbrowser
-
arrowscrollbox
-
periphery
"
)
;
periphery
.
style
.
marginBlockStart
=
"
"
;
periphery
.
style
.
marginInlineStart
=
"
"
;
periphery
.
style
.
left
=
"
"
;
periphery
.
style
.
top
=
"
"
;
let
pinnedTabsContainer
=
draggedTabDocument
.
getElementById
(
"
pinned
-
tabs
-
container
"
)
;
let
pinnedPeriphery
=
draggedTabDocument
.
getElementById
(
"
pinned
-
tabs
-
container
-
periphery
"
)
;
pinnedPeriphery
&
&
pinnedTabsContainer
.
removeChild
(
pinnedPeriphery
)
;
pinnedTabsContainer
.
removeAttribute
(
"
dragActive
"
)
;
pinnedTabsContainer
.
style
.
minHeight
=
"
"
;
draggedTabDocument
.
defaultView
.
SidebarController
.
updatePinnedTabsHeightOnResize
(
)
;
pinnedTabsContainer
.
scrollbox
.
style
.
height
=
"
"
;
pinnedTabsContainer
.
scrollbox
.
style
.
width
=
"
"
;
let
arrowScrollbox
=
draggedTabDocument
.
getElementById
(
"
tabbrowser
-
arrowscrollbox
"
)
;
arrowScrollbox
.
scrollbox
.
style
.
height
=
"
"
;
arrowScrollbox
.
scrollbox
.
style
.
width
=
"
"
;
for
(
let
groupLabel
of
draggedTabDocument
.
getElementsByClassName
(
"
tab
-
group
-
label
-
container
"
)
)
{
groupLabel
.
style
.
left
=
"
"
;
groupLabel
.
style
.
top
=
"
"
;
}
}
getDropEffectForTabDrag
(
event
)
{
var
dt
=
event
.
dataTransfer
;
let
isMovingTab
=
dt
.
mozItemCount
>
0
;
for
(
let
i
=
0
;
i
<
dt
.
mozItemCount
;
i
+
+
)
{
let
types
=
dt
.
mozTypesAt
(
0
)
;
if
(
types
[
0
]
!
=
TAB_DROP_TYPE
)
{
isMovingTab
=
false
;
break
;
}
}
if
(
isMovingTab
)
{
let
sourceNode
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
(
isTab
(
sourceNode
)
|
|
isTabGroupLabel
(
sourceNode
)
)
&
&
sourceNode
.
ownerGlobal
.
isChromeWindow
&
&
sourceNode
.
ownerDocument
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
!
=
PrivateBrowsingUtils
.
isWindowPrivate
(
sourceNode
.
ownerGlobal
)
)
{
return
"
none
"
;
}
if
(
window
.
gMultiProcessBrowser
!
=
sourceNode
.
ownerGlobal
.
gMultiProcessBrowser
)
{
return
"
none
"
;
}
if
(
window
.
gFissionBrowser
!
=
sourceNode
.
ownerGlobal
.
gFissionBrowser
)
{
return
"
none
"
;
}
return
dt
.
dropEffect
=
=
"
copy
"
?
"
copy
"
:
"
move
"
;
}
}
if
(
Services
.
droppedLinkHandler
.
canDropLink
(
event
true
)
)
{
return
"
link
"
;
}
return
"
none
"
;
}
}
;
}
