"
use
strict
"
;
{
const
TAB_PREVIEW_PREF
=
"
browser
.
tabs
.
hoverPreview
.
enabled
"
;
const
DIRECTION_BACKWARD
=
-
1
;
const
DIRECTION_FORWARD
=
1
;
const
isTab
=
element
=
>
!
!
(
element
?
.
tagName
=
=
"
tab
"
)
;
const
isTabGroup
=
element
=
>
!
!
(
element
?
.
tagName
=
=
"
tab
-
group
"
)
;
const
isTabGroupLabel
=
element
=
>
!
!
element
?
.
classList
?
.
contains
(
"
tab
-
group
-
label
"
)
;
class
MozTabbrowserTabs
extends
MozElements
.
TabsBase
{
static
observedAttributes
=
[
"
orient
"
]
;
#
maxTabsPerRow
;
#
dragOverCreateGroupTimer
;
#
mustUpdateTabMinHeight
=
false
;
#
tabMinHeight
=
36
;
constructor
(
)
{
super
(
)
;
this
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
addEventListener
(
"
TabAttrModified
"
this
)
;
this
.
addEventListener
(
"
TabHide
"
this
)
;
this
.
addEventListener
(
"
TabShow
"
this
)
;
this
.
addEventListener
(
"
TabHoverStart
"
this
)
;
this
.
addEventListener
(
"
TabHoverEnd
"
this
)
;
this
.
addEventListener
(
"
TabGroupExpand
"
this
)
;
this
.
addEventListener
(
"
TabGroupCollapse
"
this
)
;
this
.
addEventListener
(
"
TabGroupCreate
"
this
)
;
this
.
addEventListener
(
"
TabGroupRemoved
"
this
)
;
this
.
addEventListener
(
"
transitionend
"
this
)
;
this
.
addEventListener
(
"
dblclick
"
this
)
;
this
.
addEventListener
(
"
click
"
this
)
;
this
.
addEventListener
(
"
click
"
this
true
)
;
this
.
addEventListener
(
"
keydown
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
addEventListener
(
"
dragstart
"
this
)
;
this
.
addEventListener
(
"
dragover
"
this
)
;
this
.
addEventListener
(
"
drop
"
this
)
;
this
.
addEventListener
(
"
dragend
"
this
)
;
this
.
addEventListener
(
"
dragleave
"
this
)
;
this
.
addEventListener
(
"
mouseleave
"
this
)
;
this
.
addEventListener
(
"
focusin
"
this
)
;
this
.
addEventListener
(
"
focusout
"
this
)
;
this
.
addEventListener
(
"
contextmenu
"
this
)
;
}
init
(
)
{
this
.
startupTime
=
Services
.
startup
.
getStartupInfo
(
)
.
start
.
getTime
(
)
;
this
.
arrowScrollbox
=
this
.
querySelector
(
"
arrowscrollbox
"
)
;
this
.
arrowScrollbox
.
addEventListener
(
"
wheel
"
this
true
)
;
this
.
arrowScrollbox
.
addEventListener
(
"
underflow
"
this
)
;
this
.
arrowScrollbox
.
addEventListener
(
"
overflow
"
this
)
;
this
.
verticalPinnedTabsContainer
=
document
.
getElementById
(
"
vertical
-
pinned
-
tabs
-
container
"
)
;
this
.
arrowScrollbox
.
_getScrollableElements
=
(
)
=
>
{
return
this
.
ariaFocusableItems
.
filter
(
this
.
arrowScrollbox
.
_canScrollToElement
)
;
}
;
this
.
arrowScrollbox
.
_canScrollToElement
=
element
=
>
{
if
(
isTab
(
element
)
)
{
return
!
element
.
pinned
|
|
!
this
.
hasAttribute
(
"
positionpinnedtabs
"
)
;
}
return
true
;
}
;
Object
.
defineProperty
(
this
.
arrowScrollbox
"
lineScrollAmount
"
{
get
:
(
)
=
>
this
.
verticalMode
?
this
.
#
tabMinHeight
:
this
.
_tabMinWidthPref
}
)
;
this
.
baseConnect
(
)
;
this
.
_blockDblClick
=
false
;
this
.
_tabDropIndicator
=
this
.
querySelector
(
"
.
tab
-
drop
-
indicator
"
)
;
this
.
_dragOverDelay
=
350
;
this
.
_dragTime
=
0
;
this
.
_closeButtonsUpdatePending
=
false
;
this
.
_closingTabsSpacer
=
this
.
querySelector
(
"
.
closing
-
tabs
-
spacer
"
)
;
this
.
_tabDefaultMaxWidth
=
NaN
;
this
.
_lastTabClosedByMouse
=
false
;
this
.
_hasTabTempMaxWidth
=
false
;
this
.
_scrollButtonWidth
=
0
;
this
.
_lastNumPinned
=
0
;
this
.
_pinnedTabsLayoutCache
=
null
;
this
.
_animateElement
=
this
.
arrowScrollbox
;
this
.
_tabClipWidth
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
tabClipWidth
"
)
;
this
.
_hiddenSoundPlayingTabs
=
new
Set
(
)
;
this
.
previewPanel
=
null
;
this
.
allTabs
[
0
]
.
label
=
this
.
emptyTabTitle
;
const
language
=
Services
.
locale
.
appLocaleAsBCP47
;
const
unsupportedLocales
=
Services
.
prefs
.
getCharPref
(
"
browser
.
tabs
.
secondaryTextUnsupportedLocales
"
)
;
this
.
toggleAttribute
(
"
secondarytext
-
unsupported
"
unsupportedLocales
.
split
(
"
"
)
.
includes
(
language
.
split
(
"
-
"
)
[
0
]
)
)
;
this
.
newTabButton
.
setAttribute
(
"
aria
-
label
"
GetDynamicShortcutTooltipText
(
"
tabs
-
newtab
-
button
"
)
)
;
let
handleResize
=
(
)
=
>
{
this
.
_updateCloseButtons
(
)
;
this
.
_handleTabSelect
(
true
)
;
}
;
window
.
addEventListener
(
"
resize
"
handleResize
)
;
this
.
_fullscreenMutationObserver
=
new
MutationObserver
(
handleResize
)
;
this
.
_fullscreenMutationObserver
.
observe
(
document
.
documentElement
{
attributeFilter
:
[
"
inFullscreen
"
"
inDOMFullscreen
"
]
}
)
;
this
.
boundObserve
=
(
.
.
.
args
)
=
>
this
.
observe
(
.
.
.
args
)
;
Services
.
prefs
.
addObserver
(
"
privacy
.
userContext
"
this
.
boundObserve
)
;
this
.
observe
(
null
"
nsPref
:
changed
"
"
privacy
.
userContext
.
enabled
"
)
;
document
.
getElementById
(
"
vertical
-
tabs
-
newtab
-
button
"
)
.
addEventListener
(
"
keypress
"
this
)
;
document
.
getElementById
(
"
tabs
-
newtab
-
button
"
)
.
addEventListener
(
"
keypress
"
this
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_tabMinWidthPref
"
"
browser
.
tabs
.
tabMinWidth
"
null
(
pref
prevValue
newValue
)
=
>
this
.
#
updateTabMinWidth
(
newValue
)
newValue
=
>
{
const
LIMIT
=
50
;
return
Math
.
max
(
newValue
LIMIT
)
;
}
)
;
this
.
#
updateTabMinWidth
(
this
.
_tabMinWidthPref
)
;
this
.
#
updateTabMinHeight
(
)
;
CustomizableUI
.
addListener
(
this
)
;
this
.
_updateNewTabVisibility
(
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_closeTabByDblclick
"
"
browser
.
tabs
.
closeTabByDblclick
"
false
)
;
if
(
gMultiProcessBrowser
)
{
this
.
tabbox
.
tabpanels
.
setAttribute
(
"
async
"
"
true
"
)
;
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_showCardPreviews
"
TAB_PREVIEW_PREF
false
)
;
this
.
tooltip
=
"
tabbrowser
-
tab
-
tooltip
"
;
}
attributeChangedCallback
(
name
oldValue
newValue
)
{
if
(
name
!
=
"
orient
"
)
{
return
;
}
if
(
oldValue
=
=
"
vertical
"
&
&
newValue
=
=
"
horizontal
"
)
{
this
.
_resetVerticalPinnedTabs
(
)
;
}
if
(
this
.
overflowing
)
{
this
.
removeAttribute
(
"
overflow
"
)
;
}
this
.
_positionPinnedTabs
(
)
;
this
.
#
updateTabMinWidth
(
)
;
this
.
#
updateTabMinHeight
(
)
;
super
.
attributeChangedCallback
(
name
oldValue
newValue
)
;
}
on_TabSelect
(
)
{
this
.
_handleTabSelect
(
)
;
}
on_TabClose
(
event
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
{
closed
:
true
}
)
;
}
on_TabAttrModified
(
event
)
{
if
(
event
.
detail
.
changed
.
includes
(
"
soundplaying
"
)
&
&
!
event
.
target
.
visible
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
if
(
event
.
detail
.
changed
.
includes
(
"
soundplaying
"
)
|
|
event
.
detail
.
changed
.
includes
(
"
muted
"
)
|
|
event
.
detail
.
changed
.
includes
(
"
activemedia
-
blocked
"
)
)
{
this
.
updateTabSoundLabel
(
event
.
target
)
;
}
}
on_TabHide
(
event
)
{
if
(
event
.
target
.
soundPlaying
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
}
on_TabShow
(
event
)
{
if
(
event
.
target
.
soundPlaying
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
}
on_TabHoverStart
(
event
)
{
if
(
!
this
.
_showCardPreviews
)
{
return
;
}
if
(
!
this
.
previewPanel
)
{
const
TabHoverPreviewPanel
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tab
-
hover
-
preview
.
mjs
"
)
.
default
;
this
.
previewPanel
=
new
TabHoverPreviewPanel
(
document
.
getElementById
(
"
tab
-
preview
-
panel
"
)
)
;
}
this
.
previewPanel
.
activate
(
event
.
target
)
;
}
on_TabHoverEnd
(
event
)
{
this
.
previewPanel
?
.
deactivate
(
event
.
target
)
;
}
on_TabGroupExpand
(
)
{
this
.
_invalidateCachedVisibleTabs
(
)
;
}
on_TabGroupCollapse
(
event
)
{
this
.
_invalidateCachedVisibleTabs
(
)
;
this
.
_unlockTabSizing
(
)
;
const
group
=
event
.
target
;
if
(
gBrowser
.
selectedTab
.
group
=
=
=
group
)
{
gBrowser
.
selectedTab
=
gBrowser
.
_findTabToBlurTo
(
gBrowser
.
selectedTab
gBrowser
.
tabsInCollapsedTabGroups
)
|
|
gBrowser
.
addTrustedTab
(
BROWSER_NEW_TAB_URL
{
skipAnimation
:
true
}
)
;
}
}
on_TabGroupCreate
(
)
{
this
.
_invalidateCachedTabs
(
)
;
}
on_TabGroupRemoved
(
)
{
this
.
_invalidateCachedTabs
(
)
;
}
on_transitionend
(
event
)
{
if
(
event
.
propertyName
!
=
"
max
-
width
"
)
{
return
;
}
let
tab
=
event
.
target
?
event
.
target
.
closest
(
"
tab
"
)
:
null
;
if
(
tab
.
hasAttribute
(
"
fadein
"
)
)
{
if
(
tab
.
_fullyOpen
)
{
this
.
_updateCloseButtons
(
)
;
}
else
{
this
.
_handleNewTab
(
tab
)
;
}
}
else
if
(
tab
.
closing
)
{
gBrowser
.
_endRemoveTab
(
tab
)
;
}
let
evt
=
new
CustomEvent
(
"
TabAnimationEnd
"
{
bubbles
:
true
}
)
;
tab
.
dispatchEvent
(
evt
)
;
}
on_dblclick
(
event
)
{
if
(
CustomTitlebar
.
enabled
&
&
!
this
.
verticalMode
)
{
return
;
}
if
(
event
.
button
!
=
0
|
|
event
.
target
!
=
this
.
arrowScrollbox
|
|
event
.
composedTarget
.
localName
=
=
"
toolbarbutton
"
)
{
return
;
}
if
(
!
this
.
_blockDblClick
)
{
BrowserCommands
.
openTab
(
)
;
}
event
.
preventDefault
(
)
;
}
on_click
(
event
)
{
if
(
event
.
eventPhase
=
=
Event
.
CAPTURING_PHASE
&
&
event
.
button
=
=
0
)
{
let
target
=
event
.
originalTarget
;
if
(
target
.
classList
.
contains
(
"
tab
-
close
-
button
"
)
)
{
if
(
this
.
_blockDblClick
)
{
target
.
_ignoredCloseButtonClicks
=
true
;
}
else
if
(
event
.
detail
>
1
&
&
!
target
.
_ignoredCloseButtonClicks
)
{
target
.
_ignoredCloseButtonClicks
=
true
;
event
.
stopPropagation
(
)
;
return
;
}
else
{
target
.
_ignoredCloseButtonClicks
=
false
;
}
}
if
(
this
.
_blockDblClick
)
{
if
(
!
(
"
_clickedTabBarOnce
"
in
this
)
)
{
this
.
_clickedTabBarOnce
=
true
;
return
;
}
delete
this
.
_clickedTabBarOnce
;
this
.
_blockDblClick
=
false
;
}
}
else
if
(
event
.
eventPhase
=
=
Event
.
BUBBLING_PHASE
&
&
event
.
button
=
=
1
)
{
let
tab
=
event
.
target
?
event
.
target
.
closest
(
"
tab
"
)
:
null
;
if
(
tab
)
{
if
(
tab
.
multiselected
)
{
gBrowser
.
removeMultiSelectedTabs
(
)
;
}
else
{
gBrowser
.
removeTab
(
tab
{
animate
:
true
triggeringEvent
:
event
}
)
;
}
}
else
if
(
event
.
originalTarget
.
closest
(
"
scrollbox
"
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
widget
.
gtk
.
titlebar
-
action
-
middle
-
click
-
enabled
"
)
)
{
let
visibleTabs
=
this
.
visibleTabs
;
let
lastTab
=
visibleTabs
.
at
(
-
1
)
;
let
winUtils
=
window
.
windowUtils
;
let
endOfTab
=
winUtils
.
getBoundsWithoutFlushing
(
lastTab
)
[
(
this
.
verticalMode
&
&
"
bottom
"
)
|
|
(
this
.
#
rtlMode
?
"
left
"
:
"
right
"
)
]
;
if
(
(
this
.
verticalMode
&
&
event
.
clientY
>
endOfTab
)
|
|
(
!
this
.
verticalMode
&
&
(
this
.
#
rtlMode
?
event
.
clientX
<
endOfTab
:
event
.
clientX
>
endOfTab
)
)
)
{
BrowserCommands
.
openTab
(
)
;
}
}
else
{
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
on_keydown
(
event
)
{
let
{
altKey
shiftKey
}
=
event
;
let
[
accel
nonAccel
]
=
AppConstants
.
platform
=
=
"
macosx
"
?
[
event
.
metaKey
event
.
ctrlKey
]
:
[
event
.
ctrlKey
event
.
metaKey
]
;
let
keyComboForFocusedElement
=
!
accel
&
&
!
shiftKey
&
&
!
altKey
&
&
!
nonAccel
;
let
keyComboForMove
=
accel
&
&
shiftKey
&
&
!
altKey
&
&
!
nonAccel
;
let
keyComboForFocus
=
accel
&
&
!
shiftKey
&
&
!
altKey
&
&
!
nonAccel
;
if
(
!
keyComboForFocusedElement
&
&
!
keyComboForMove
&
&
!
keyComboForFocus
)
{
return
;
}
if
(
keyComboForFocusedElement
)
{
let
ariaFocusedItem
=
this
.
ariaFocusedItem
;
if
(
isTabGroupLabel
(
ariaFocusedItem
)
)
{
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_SPACE
:
case
KeyEvent
.
DOM_VK_RETURN
:
{
ariaFocusedItem
.
click
(
)
;
event
.
preventDefault
(
)
;
}
}
}
}
else
if
(
keyComboForMove
)
{
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_UP
:
gBrowser
.
moveTabBackward
(
)
;
break
;
case
KeyEvent
.
DOM_VK_DOWN
:
gBrowser
.
moveTabForward
(
)
;
break
;
case
KeyEvent
.
DOM_VK_RIGHT
:
if
(
RTL_UI
)
{
gBrowser
.
moveTabBackward
(
)
;
}
else
{
gBrowser
.
moveTabForward
(
)
;
}
break
;
case
KeyEvent
.
DOM_VK_LEFT
:
if
(
RTL_UI
)
{
gBrowser
.
moveTabForward
(
)
;
}
else
{
gBrowser
.
moveTabBackward
(
)
;
}
break
;
case
KeyEvent
.
DOM_VK_HOME
:
gBrowser
.
moveTabToStart
(
)
;
break
;
case
KeyEvent
.
DOM_VK_END
:
gBrowser
.
moveTabToEnd
(
)
;
break
;
default
:
return
;
}
event
.
preventDefault
(
)
;
}
else
if
(
keyComboForFocus
)
{
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_UP
:
this
.
#
advanceFocus
(
DIRECTION_BACKWARD
)
;
break
;
case
KeyEvent
.
DOM_VK_DOWN
:
this
.
#
advanceFocus
(
DIRECTION_FORWARD
)
;
break
;
case
KeyEvent
.
DOM_VK_RIGHT
:
if
(
RTL_UI
)
{
this
.
#
advanceFocus
(
DIRECTION_BACKWARD
)
;
}
else
{
this
.
#
advanceFocus
(
DIRECTION_FORWARD
)
;
}
break
;
case
KeyEvent
.
DOM_VK_LEFT
:
if
(
RTL_UI
)
{
this
.
#
advanceFocus
(
DIRECTION_FORWARD
)
;
}
else
{
this
.
#
advanceFocus
(
DIRECTION_BACKWARD
)
;
}
break
;
case
KeyEvent
.
DOM_VK_HOME
:
this
.
ariaFocusedItem
=
this
.
ariaFocusableItems
.
at
(
0
)
;
break
;
case
KeyEvent
.
DOM_VK_END
:
this
.
ariaFocusedItem
=
this
.
ariaFocusableItems
.
at
(
-
1
)
;
break
;
case
KeyEvent
.
DOM_VK_SPACE
:
{
let
ariaFocusedItem
=
this
.
ariaFocusedItem
;
if
(
isTab
(
ariaFocusedItem
)
)
{
if
(
ariaFocusedItem
.
multiselected
)
{
gBrowser
.
removeFromMultiSelectedTabs
(
ariaFocusedItem
)
;
}
else
{
gBrowser
.
addToMultiSelectedTabs
(
ariaFocusedItem
)
;
}
}
break
;
}
default
:
return
;
}
event
.
preventDefault
(
)
;
}
}
on_focusin
(
event
)
{
if
(
event
.
target
=
=
this
.
selectedItem
)
{
this
.
tablistHasFocus
=
true
;
if
(
!
this
.
ariaFocusedItem
)
{
this
.
ariaFocusedItem
=
this
.
selectedItem
;
}
}
}
on_focusout
(
event
)
{
if
(
event
.
target
=
=
this
.
selectedItem
)
{
this
.
tablistHasFocus
=
false
;
}
}
#
advanceFocus
(
direction
)
{
let
currentIndex
=
this
.
ariaFocusableItems
.
indexOf
(
this
.
ariaFocusedItem
)
;
let
newIndex
=
currentIndex
+
direction
;
newIndex
=
Math
.
min
(
this
.
ariaFocusableItems
.
length
-
1
Math
.
max
(
0
newIndex
)
)
;
let
itemToFocus
=
this
.
ariaFocusableItems
[
newIndex
]
;
this
.
ariaFocusedItem
=
itemToFocus
;
}
advanceSelectedItem
(
aDir
aWrap
)
{
let
{
ariaFocusableItems
ariaFocusedIndex
}
=
this
;
let
currentItemIndex
=
ariaFocusedIndex
>
=
0
?
ariaFocusedIndex
:
ariaFocusableItems
.
indexOf
(
this
.
selectedItem
)
;
let
newItemIndex
=
currentItemIndex
+
aDir
;
if
(
aWrap
)
{
if
(
newItemIndex
>
=
ariaFocusableItems
.
length
)
{
newItemIndex
=
0
;
}
else
if
(
newItemIndex
<
0
)
{
newItemIndex
=
ariaFocusableItems
.
length
-
1
;
}
}
else
{
newItemIndex
=
Math
.
min
(
ariaFocusableItems
.
length
-
1
Math
.
max
(
0
newItemIndex
)
)
;
}
if
(
currentItemIndex
=
=
newItemIndex
)
{
return
;
}
let
newItem
=
ariaFocusableItems
[
newItemIndex
]
;
if
(
isTab
(
newItem
)
)
{
this
.
_selectNewTab
(
newItem
aDir
aWrap
)
;
}
this
.
ariaFocusedItem
=
newItem
;
}
on_keypress
(
event
)
{
if
(
event
.
defaultPrevented
)
{
return
;
}
if
(
event
.
key
=
=
"
"
|
|
event
.
key
=
=
"
Enter
"
)
{
event
.
preventDefault
(
)
;
event
.
target
.
click
(
)
;
}
}
on_dragstart
(
event
)
{
var
tab
=
this
.
_getDragTargetTab
(
event
)
;
if
(
!
tab
|
|
this
.
_isCustomizing
)
{
return
;
}
this
.
previewPanel
?
.
deactivate
(
)
;
this
.
startTabDrag
(
event
tab
)
;
}
startTabDrag
(
event
tab
{
fromTabList
=
false
}
=
{
}
)
{
if
(
this
.
#
isContainerVerticalPinnedExpanded
(
tab
)
)
{
let
pinnedTabs
=
this
.
visibleTabs
.
slice
(
0
gBrowser
.
pinnedTabCount
)
;
let
tabsPerRow
=
0
;
let
position
=
0
;
for
(
let
pinnedTab
of
pinnedTabs
)
{
let
tabPosition
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
pinnedTab
)
.
left
;
if
(
tabPosition
<
position
)
{
break
;
}
tabsPerRow
+
+
;
position
=
tabPosition
;
}
this
.
#
maxTabsPerRow
=
tabsPerRow
;
}
let
dataTransferOrderedTabs
;
if
(
!
fromTabList
)
{
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
otherSelectedTabs
=
selectedTabs
.
filter
(
selectedTab
=
>
selectedTab
!
=
tab
)
;
dataTransferOrderedTabs
=
[
tab
]
.
concat
(
otherSelectedTabs
)
;
}
else
{
dataTransferOrderedTabs
=
[
tab
]
;
}
let
dt
=
event
.
dataTransfer
;
for
(
let
i
=
0
;
i
<
dataTransferOrderedTabs
.
length
;
i
+
+
)
{
let
dtTab
=
dataTransferOrderedTabs
[
i
]
;
dt
.
mozSetDataAt
(
TAB_DROP_TYPE
dtTab
i
)
;
let
dtBrowser
=
dtTab
.
linkedBrowser
;
dt
.
mozSetDataAt
(
"
text
/
x
-
moz
-
text
-
internal
"
dtBrowser
.
currentURI
.
spec
i
)
;
}
dt
.
mozCursor
=
"
default
"
;
dt
.
addElement
(
tab
)
;
if
(
tab
.
multiselected
)
{
this
.
#
moveTogetherSelectedTabs
(
tab
)
;
}
let
scale
=
window
.
devicePixelRatio
;
let
canvas
=
this
.
_dndCanvas
;
if
(
!
canvas
)
{
this
.
_dndCanvas
=
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
style
.
width
=
"
100
%
"
;
canvas
.
style
.
height
=
"
100
%
"
;
canvas
.
mozOpaque
=
true
;
}
canvas
.
width
=
160
*
scale
;
canvas
.
height
=
90
*
scale
;
let
toDrag
=
canvas
;
let
dragImageOffset
=
-
16
;
let
browser
=
tab
.
linkedBrowser
;
if
(
gMultiProcessBrowser
)
{
var
context
=
canvas
.
getContext
(
"
2d
"
)
;
context
.
fillStyle
=
"
white
"
;
context
.
fillRect
(
0
0
canvas
.
width
canvas
.
height
)
;
let
captureListener
;
let
platform
=
AppConstants
.
platform
;
if
(
platform
=
=
"
win
"
|
|
platform
=
=
"
macosx
"
)
{
captureListener
=
function
(
)
{
dt
.
updateDragImage
(
canvas
dragImageOffset
dragImageOffset
)
;
}
;
}
else
{
if
(
!
this
.
_dndPanel
)
{
this
.
_dndCanvas
=
canvas
;
this
.
_dndPanel
=
document
.
createXULElement
(
"
panel
"
)
;
this
.
_dndPanel
.
className
=
"
dragfeedback
-
tab
"
;
this
.
_dndPanel
.
setAttribute
(
"
type
"
"
drag
"
)
;
let
wrapper
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
div
"
)
;
wrapper
.
style
.
width
=
"
160px
"
;
wrapper
.
style
.
height
=
"
90px
"
;
wrapper
.
appendChild
(
canvas
)
;
this
.
_dndPanel
.
appendChild
(
wrapper
)
;
document
.
documentElement
.
appendChild
(
this
.
_dndPanel
)
;
}
toDrag
=
this
.
_dndPanel
;
}
PageThumbs
.
captureToCanvas
(
browser
canvas
)
.
then
(
captureListener
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
else
{
PageThumbs
.
captureToCanvas
(
browser
canvas
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
dragImageOffset
=
dragImageOffset
*
scale
;
}
dt
.
setDragImage
(
toDrag
dragImageOffset
dragImageOffset
)
;
let
clientPos
=
ele
=
>
{
const
rect
=
ele
.
getBoundingClientRect
(
)
;
return
this
.
verticalMode
?
rect
.
top
:
rect
.
left
;
}
;
let
tabOffset
=
clientPos
(
tab
)
-
clientPos
(
this
)
;
tab
.
_dragData
=
{
offsetX
:
this
.
verticalMode
?
event
.
screenX
-
window
.
screenX
:
event
.
screenX
-
window
.
screenX
-
tabOffset
offsetY
:
this
.
verticalMode
?
event
.
screenY
-
window
.
screenY
-
tabOffset
:
event
.
screenY
-
window
.
screenY
scrollPos
:
this
.
verticalMode
&
&
tab
.
pinned
?
this
.
verticalPinnedTabsContainer
.
scrollTop
:
this
.
arrowScrollbox
.
scrollPosition
screenX
:
event
.
screenX
screenY
:
event
.
screenY
movingTabs
:
(
tab
.
multiselected
?
gBrowser
.
selectedTabs
:
[
tab
]
)
.
filter
(
t
=
>
t
.
pinned
=
=
tab
.
pinned
)
fromTabList
tabGroupCreationColor
:
gBrowser
.
tabGroupMenu
.
nextUnusedColor
}
;
event
.
stopPropagation
(
)
;
if
(
fromTabList
)
{
Glean
.
browserUiInteraction
.
allTabsPanelDragstartTabEventCount
.
add
(
1
)
;
}
}
on_dragover
(
event
)
{
var
effects
=
this
.
getDropEffectForTabDrag
(
event
)
;
var
ind
=
this
.
_tabDropIndicator
;
if
(
effects
=
=
"
"
|
|
effects
=
=
"
none
"
)
{
ind
.
hidden
=
true
;
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
var
arrowScrollbox
=
this
.
arrowScrollbox
;
var
pixelsToScroll
=
0
;
if
(
this
.
overflowing
)
{
switch
(
event
.
originalTarget
)
{
case
arrowScrollbox
.
_scrollButtonUp
:
pixelsToScroll
=
arrowScrollbox
.
scrollIncrement
*
-
1
;
break
;
case
arrowScrollbox
.
_scrollButtonDown
:
pixelsToScroll
=
arrowScrollbox
.
scrollIncrement
;
break
;
}
if
(
pixelsToScroll
)
{
arrowScrollbox
.
scrollByPixels
(
(
this
.
#
rtlMode
?
-
1
:
1
)
*
pixelsToScroll
true
)
;
}
}
let
draggedTab
=
event
.
dataTransfer
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
(
effects
=
=
"
move
"
|
|
effects
=
=
"
copy
"
)
&
&
this
=
=
draggedTab
.
container
&
&
!
draggedTab
.
_dragData
.
fromTabList
)
{
ind
.
hidden
=
true
;
if
(
this
.
#
isAnimatingMoveTogetherSelectedTabs
(
)
)
{
return
;
}
this
.
_finishMoveTogetherSelectedTabs
(
draggedTab
)
;
if
(
effects
=
=
"
move
"
)
{
if
(
this
.
#
isContainerVerticalPinnedExpanded
(
draggedTab
)
)
{
this
.
#
animateExpandedPinnedTabMove
(
event
)
;
return
;
}
this
.
_animateTabMove
(
event
)
;
return
;
}
}
this
.
_finishAnimateTabMove
(
)
;
if
(
effects
=
=
"
link
"
)
{
let
tab
=
this
.
_getDragTargetTab
(
event
{
ignoreTabSides
:
true
}
)
;
if
(
tab
)
{
if
(
!
this
.
_dragTime
)
{
this
.
_dragTime
=
Date
.
now
(
)
;
}
if
(
Date
.
now
(
)
>
=
this
.
_dragTime
+
this
.
_dragOverDelay
)
{
this
.
selectedItem
=
tab
;
}
ind
.
hidden
=
true
;
return
;
}
}
var
rect
=
arrowScrollbox
.
getBoundingClientRect
(
)
;
var
newMargin
;
if
(
pixelsToScroll
)
{
let
scrollRect
=
arrowScrollbox
.
scrollClientRect
;
let
minMargin
=
this
.
verticalMode
?
scrollRect
.
top
-
rect
.
top
:
scrollRect
.
left
-
rect
.
left
;
let
maxMargin
=
this
.
verticalMode
?
Math
.
min
(
minMargin
+
scrollRect
.
height
scrollRect
.
bottom
)
:
Math
.
min
(
minMargin
+
scrollRect
.
width
scrollRect
.
right
)
;
if
(
this
.
#
rtlMode
)
{
[
minMargin
maxMargin
]
=
[
this
.
clientWidth
-
maxMargin
this
.
clientWidth
-
minMargin
]
;
}
newMargin
=
pixelsToScroll
>
0
?
maxMargin
:
minMargin
;
}
else
{
let
newIndex
=
this
.
_getDropIndex
(
event
)
;
let
children
=
this
.
allTabs
;
if
(
newIndex
=
=
children
.
length
)
{
let
tabRect
=
this
.
visibleTabs
.
at
(
-
1
)
.
getBoundingClientRect
(
)
;
if
(
this
.
verticalMode
)
{
newMargin
=
tabRect
.
bottom
-
rect
.
top
;
}
else
if
(
this
.
#
rtlMode
)
{
newMargin
=
rect
.
right
-
tabRect
.
left
;
}
else
{
newMargin
=
tabRect
.
right
-
rect
.
left
;
}
}
else
{
let
tabRect
=
children
[
newIndex
]
.
getBoundingClientRect
(
)
;
if
(
this
.
verticalMode
)
{
newMargin
=
rect
.
top
-
tabRect
.
bottom
;
}
else
if
(
this
.
#
rtlMode
)
{
newMargin
=
rect
.
right
-
tabRect
.
right
;
}
else
{
newMargin
=
tabRect
.
left
-
rect
.
left
;
}
}
}
ind
.
hidden
=
false
;
newMargin
+
=
this
.
verticalMode
?
ind
.
clientHeight
:
ind
.
clientWidth
/
2
;
if
(
this
.
#
rtlMode
)
{
newMargin
*
=
-
1
;
}
ind
.
style
.
transform
=
this
.
verticalMode
?
"
translateY
(
"
+
Math
.
round
(
newMargin
)
+
"
px
)
"
:
"
translateX
(
"
+
Math
.
round
(
newMargin
)
+
"
px
)
"
;
}
on_drop
(
event
)
{
var
dt
=
event
.
dataTransfer
;
var
dropEffect
=
dt
.
dropEffect
;
var
draggedTab
;
let
movingTabs
;
if
(
dt
.
mozTypesAt
(
0
)
[
0
]
=
=
TAB_DROP_TYPE
)
{
draggedTab
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
!
draggedTab
)
{
return
;
}
movingTabs
=
draggedTab
.
_dragData
.
movingTabs
;
draggedTab
.
container
.
_finishMoveTogetherSelectedTabs
(
draggedTab
)
;
}
this
.
_tabDropIndicator
.
hidden
=
true
;
event
.
stopPropagation
(
)
;
if
(
draggedTab
&
&
dropEffect
=
=
"
copy
"
)
{
let
newIndex
=
this
.
_getDropIndex
(
event
)
;
let
draggedTabCopy
;
for
(
let
tab
of
movingTabs
)
{
let
newTab
=
gBrowser
.
duplicateTab
(
tab
)
;
gBrowser
.
moveTabTo
(
newTab
newIndex
+
+
)
;
if
(
tab
=
=
draggedTab
)
{
draggedTabCopy
=
newTab
;
}
}
if
(
draggedTab
.
container
!
=
this
|
|
event
.
shiftKey
)
{
this
.
selectedItem
=
draggedTabCopy
;
}
}
else
if
(
draggedTab
&
&
draggedTab
.
container
=
=
this
)
{
let
oldTranslateX
=
Math
.
round
(
draggedTab
.
_dragData
.
translateX
)
;
let
oldTranslateY
=
Math
.
round
(
draggedTab
.
_dragData
.
translateY
)
;
let
tabWidth
=
Math
.
round
(
draggedTab
.
_dragData
.
tabWidth
)
;
let
tabHeight
=
Math
.
round
(
draggedTab
.
_dragData
.
tabHeight
)
;
let
translateOffsetX
=
oldTranslateX
%
tabWidth
;
let
translateOffsetY
=
oldTranslateY
%
tabHeight
;
let
newTranslateX
=
oldTranslateX
-
translateOffsetX
;
let
newTranslateY
=
oldTranslateY
-
translateOffsetY
;
if
(
this
.
#
isContainerVerticalPinnedExpanded
(
draggedTab
)
)
{
if
(
oldTranslateX
>
0
&
&
translateOffsetX
>
tabWidth
/
2
)
{
newTranslateX
+
=
tabWidth
;
}
else
if
(
oldTranslateX
<
0
&
&
-
translateOffsetX
>
tabWidth
/
2
)
{
newTranslateX
-
=
tabWidth
;
}
if
(
oldTranslateY
>
0
&
&
translateOffsetY
>
tabHeight
/
2
)
{
newTranslateY
+
=
tabHeight
;
}
else
if
(
oldTranslateY
<
0
&
&
-
translateOffsetY
>
tabHeight
/
2
)
{
newTranslateY
-
=
tabHeight
;
}
}
else
{
let
isPinned
=
draggedTab
.
pinned
;
let
numPinned
=
gBrowser
.
pinnedTabCount
;
let
tabs
=
this
.
ariaFocusableItems
.
slice
(
isPinned
?
0
:
numPinned
isPinned
?
numPinned
:
undefined
)
;
let
size
=
this
.
verticalMode
?
"
height
"
:
"
width
"
;
let
screenAxis
=
this
.
verticalMode
?
"
screenY
"
:
"
screenX
"
;
let
tabSize
=
this
.
verticalMode
?
tabHeight
:
tabWidth
;
let
firstTab
=
tabs
[
0
]
;
let
lastTab
=
tabs
.
at
(
-
1
)
;
let
lastMovingTabScreen
=
movingTabs
.
at
(
-
1
)
[
screenAxis
]
;
let
firstMovingTabScreen
=
movingTabs
[
0
]
[
screenAxis
]
;
let
firstBound
=
firstTab
[
screenAxis
]
-
firstMovingTabScreen
;
let
lastBound
=
lastTab
[
screenAxis
]
+
window
.
windowUtils
.
getBoundsWithoutFlushing
(
lastTab
)
[
size
]
-
(
lastMovingTabScreen
+
tabSize
)
;
if
(
this
.
verticalMode
)
{
newTranslateY
=
Math
.
min
(
Math
.
max
(
oldTranslateY
firstBound
)
lastBound
)
;
}
else
{
newTranslateX
=
RTL_UI
?
Math
.
min
(
Math
.
max
(
oldTranslateX
lastBound
)
firstBound
)
:
Math
.
min
(
Math
.
max
(
oldTranslateX
firstBound
)
lastBound
)
;
}
}
let
{
dropElement
dropBefore
shouldCreateGroupOnDrop
fromTabList
}
=
draggedTab
.
_dragData
;
let
dropIndex
;
let
directionForward
=
false
;
if
(
fromTabList
)
{
dropIndex
=
this
.
_getDropIndex
(
event
)
;
if
(
dropIndex
&
&
dropIndex
>
movingTabs
[
0
]
.
_tPos
)
{
dropIndex
-
-
;
directionForward
=
true
;
}
}
let
shouldTranslate
=
!
gReduceMotion
&
&
!
shouldCreateGroupOnDrop
;
if
(
this
.
#
isContainerVerticalPinnedExpanded
(
draggedTab
)
)
{
shouldTranslate
&
&
=
(
oldTranslateX
&
&
oldTranslateX
!
=
newTranslateX
)
|
|
(
oldTranslateY
&
&
oldTranslateY
!
=
newTranslateY
)
;
}
else
if
(
this
.
verticalMode
)
{
shouldTranslate
&
&
=
oldTranslateY
&
&
oldTranslateY
!
=
newTranslateY
;
}
else
{
shouldTranslate
&
&
=
oldTranslateX
&
&
oldTranslateX
!
=
newTranslateX
;
}
let
moveTabs
=
(
)
=
>
{
if
(
dropIndex
!
=
=
undefined
)
{
for
(
let
tab
of
movingTabs
)
{
gBrowser
.
moveTabTo
(
tab
dropIndex
)
;
if
(
!
directionForward
)
{
dropIndex
+
+
;
}
}
}
else
if
(
dropBefore
)
{
gBrowser
.
moveTabsBefore
(
movingTabs
dropElement
)
;
}
else
{
gBrowser
.
moveTabsAfter
(
movingTabs
dropElement
)
;
}
}
;
if
(
shouldTranslate
)
{
let
translationPromises
=
[
]
;
for
(
let
tab
of
movingTabs
)
{
let
translationPromise
=
new
Promise
(
resolve
=
>
{
tab
.
toggleAttribute
(
"
tabdrop
-
samewindow
"
true
)
;
tab
.
style
.
transform
=
translate
(
{
newTranslateX
}
px
{
newTranslateY
}
px
)
;
let
postTransitionCleanup
=
(
)
=
>
{
tab
.
removeAttribute
(
"
tabdrop
-
samewindow
"
)
;
resolve
(
)
;
}
;
if
(
gReduceMotion
)
{
postTransitionCleanup
(
)
;
}
else
{
let
onTransitionEnd
=
transitionendEvent
=
>
{
if
(
transitionendEvent
.
propertyName
!
=
"
transform
"
|
|
transitionendEvent
.
originalTarget
!
=
tab
)
{
return
;
}
tab
.
removeEventListener
(
"
transitionend
"
onTransitionEnd
)
;
postTransitionCleanup
(
)
;
}
;
tab
.
addEventListener
(
"
transitionend
"
onTransitionEnd
)
;
}
}
)
;
translationPromises
.
push
(
translationPromise
)
;
}
Promise
.
all
(
translationPromises
)
.
then
(
(
)
=
>
{
this
.
_finishAnimateTabMove
(
)
;
moveTabs
(
)
;
}
)
;
}
else
{
this
.
_finishAnimateTabMove
(
)
;
if
(
shouldCreateGroupOnDrop
)
{
let
tabsInGroup
=
dropBefore
?
[
.
.
.
movingTabs
dropElement
]
:
[
dropElement
.
.
.
movingTabs
]
;
gBrowser
.
addTabGroup
(
tabsInGroup
{
insertBefore
:
dropElement
showCreateUI
:
true
color
:
draggedTab
.
_dragData
.
tabGroupCreationColor
}
)
;
}
else
{
moveTabs
(
)
;
}
}
}
else
if
(
draggedTab
)
{
const
dropIndex
=
this
.
_getDropIndex
(
event
)
;
let
newIndex
=
dropIndex
;
let
selectedTab
;
let
indexForSelectedTab
;
for
(
let
i
=
0
;
i
<
movingTabs
.
length
;
+
+
i
)
{
const
tab
=
movingTabs
[
i
]
;
if
(
tab
.
selected
)
{
selectedTab
=
tab
;
indexForSelectedTab
=
newIndex
;
}
else
{
const
newTab
=
gBrowser
.
adoptTab
(
tab
newIndex
tab
=
=
draggedTab
)
;
if
(
newTab
)
{
+
+
newIndex
;
}
}
}
if
(
selectedTab
)
{
const
newTab
=
gBrowser
.
adoptTab
(
selectedTab
indexForSelectedTab
selectedTab
=
=
draggedTab
)
;
if
(
newTab
)
{
+
+
newIndex
;
}
}
gBrowser
.
addRangeToMultiSelectedTabs
(
gBrowser
.
tabs
[
dropIndex
]
gBrowser
.
tabs
[
newIndex
-
1
]
)
;
}
else
{
let
links
;
try
{
links
=
browserDragAndDrop
.
dropLinks
(
event
true
)
;
}
catch
(
ex
)
{
}
if
(
!
links
|
|
links
.
length
=
=
=
0
)
{
return
;
}
let
inBackground
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
loadInBackground
"
)
;
if
(
event
.
shiftKey
)
{
inBackground
=
!
inBackground
;
}
let
targetTab
=
this
.
_getDragTargetTab
(
event
{
ignoreTabSides
:
true
}
)
;
let
userContextId
=
this
.
selectedItem
.
getAttribute
(
"
usercontextid
"
)
;
let
replace
=
!
!
targetTab
;
let
newIndex
=
this
.
_getDropIndex
(
event
)
;
let
urls
=
links
.
map
(
link
=
>
link
.
url
)
;
let
csp
=
browserDragAndDrop
.
getCsp
(
event
)
;
let
triggeringPrincipal
=
browserDragAndDrop
.
getTriggeringPrincipal
(
event
)
;
(
async
(
)
=
>
{
if
(
urls
.
length
>
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
maxOpenBeforeWarn
"
)
)
{
let
answer
=
await
OpenInTabsUtils
.
promiseConfirmOpenInTabs
(
urls
.
length
window
)
;
if
(
!
answer
)
{
return
;
}
}
gBrowser
.
loadTabs
(
urls
{
inBackground
replace
allowThirdPartyFixup
:
true
targetTab
newIndex
userContextId
triggeringPrincipal
csp
}
)
;
}
)
(
)
;
}
if
(
draggedTab
)
{
delete
draggedTab
.
_dragData
;
}
}
on_dragend
(
event
)
{
var
dt
=
event
.
dataTransfer
;
var
draggedTab
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
draggedTab
.
hasAttribute
(
"
tabdrop
-
samewindow
"
)
)
{
return
;
}
this
.
_finishMoveTogetherSelectedTabs
(
draggedTab
)
;
this
.
_finishAnimateTabMove
(
)
;
if
(
dt
.
mozUserCancelled
|
|
dt
.
dropEffect
!
=
"
none
"
|
|
this
.
_isCustomizing
)
{
delete
draggedTab
.
_dragData
;
return
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
allowTabDetach
"
)
)
{
return
;
}
let
[
tabAxisPos
tabAxisStart
tabAxisEnd
]
=
this
.
verticalMode
?
[
event
.
screenY
window
.
screenY
window
.
screenY
+
window
.
outerHeight
]
:
[
event
.
screenX
window
.
screenX
window
.
screenX
+
window
.
outerWidth
]
;
if
(
tabAxisPos
>
tabAxisStart
&
&
tabAxisPos
<
tabAxisEnd
)
{
let
rect
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
arrowScrollbox
)
;
let
crossAxisPos
=
this
.
verticalMode
?
event
.
screenX
:
event
.
screenY
;
let
crossAxisStart
crossAxisEnd
;
if
(
this
.
verticalMode
)
{
if
(
RTL_UI
)
{
crossAxisStart
=
window
.
screenX
+
rect
.
right
-
1
.
5
*
rect
.
width
;
crossAxisEnd
=
window
.
screenX
;
}
else
{
crossAxisStart
=
window
.
screenX
;
crossAxisEnd
=
window
.
screenX
+
rect
.
left
+
1
.
5
*
rect
.
width
;
}
}
else
{
crossAxisStart
=
window
.
screenY
;
crossAxisEnd
=
window
.
screenY
+
rect
.
top
+
1
.
5
*
rect
.
height
;
}
if
(
crossAxisPos
>
crossAxisStart
&
&
crossAxisPos
<
crossAxisEnd
)
{
return
;
}
}
var
screen
=
event
.
screen
;
var
availX
=
{
}
availY
=
{
}
availWidth
=
{
}
availHeight
=
{
}
;
screen
.
GetAvailRectDisplayPix
(
availX
availY
availWidth
availHeight
)
;
availX
=
availX
.
value
;
availY
=
availY
.
value
;
availWidth
=
availWidth
.
value
;
availHeight
=
availHeight
.
value
;
let
ourCssToDesktopScale
=
window
.
devicePixelRatio
/
window
.
desktopToDeviceScale
;
let
screenCssToDesktopScale
=
screen
.
defaultCSSScaleFactor
/
screen
.
contentsScaleFactor
;
var
winWidth
=
Math
.
min
(
window
.
outerWidth
*
screenCssToDesktopScale
availWidth
)
;
var
winHeight
=
Math
.
min
(
window
.
outerHeight
*
screenCssToDesktopScale
availHeight
)
;
var
left
=
Math
.
min
(
Math
.
max
(
event
.
screenX
*
ourCssToDesktopScale
-
draggedTab
.
_dragData
.
offsetX
*
screenCssToDesktopScale
availX
)
availX
+
availWidth
-
winWidth
)
;
var
top
=
Math
.
min
(
Math
.
max
(
event
.
screenY
*
ourCssToDesktopScale
-
draggedTab
.
_dragData
.
offsetY
*
screenCssToDesktopScale
availY
)
availY
+
availHeight
-
winHeight
)
;
left
/
=
ourCssToDesktopScale
;
top
/
=
ourCssToDesktopScale
;
delete
draggedTab
.
_dragData
;
if
(
gBrowser
.
tabs
.
length
=
=
1
)
{
winWidth
/
=
ourCssToDesktopScale
;
winHeight
/
=
ourCssToDesktopScale
;
window
.
resizeTo
(
winWidth
winHeight
)
;
window
.
moveTo
(
left
top
)
;
window
.
focus
(
)
;
}
else
{
winWidth
/
=
screenCssToDesktopScale
;
winHeight
/
=
screenCssToDesktopScale
;
let
props
=
{
screenX
:
left
screenY
:
top
suppressanimation
:
1
}
;
gBrowser
.
replaceTabsWithWindow
(
draggedTab
props
)
;
}
event
.
stopPropagation
(
)
;
}
on_dragleave
(
event
)
{
this
.
_dragTime
=
0
;
var
target
=
event
.
relatedTarget
;
while
(
target
&
&
target
!
=
this
)
{
target
=
target
.
parentNode
;
}
if
(
target
)
{
return
;
}
this
.
_tabDropIndicator
.
hidden
=
true
;
event
.
stopPropagation
(
)
;
}
on_wheel
(
event
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
tabbox
.
switchByScrolling
"
false
)
)
{
event
.
stopImmediatePropagation
(
)
;
}
}
on_overflow
(
event
)
{
if
(
event
.
target
!
=
this
.
arrowScrollbox
)
{
return
;
}
this
.
toggleAttribute
(
"
overflow
"
true
)
;
this
.
_positionPinnedTabs
(
)
;
this
.
_updateCloseButtons
(
)
;
this
.
_handleTabSelect
(
true
)
;
document
.
getElementById
(
"
tab
-
preview
-
panel
"
)
?
.
setAttribute
(
"
rolluponmousewheel
"
true
)
;
}
on_underflow
(
event
)
{
if
(
event
.
target
!
=
this
.
arrowScrollbox
|
|
!
this
.
overflowing
)
{
return
;
}
this
.
removeAttribute
(
"
overflow
"
)
;
if
(
this
.
_lastTabClosedByMouse
)
{
this
.
_expandSpacerBy
(
this
.
_scrollButtonWidth
)
;
}
for
(
let
tab
of
gBrowser
.
_removingTabs
)
{
gBrowser
.
removeTab
(
tab
)
;
}
this
.
_positionPinnedTabs
(
)
;
this
.
_updateCloseButtons
(
)
;
document
.
getElementById
(
"
tab
-
preview
-
panel
"
)
?
.
removeAttribute
(
"
rolluponmousewheel
"
)
;
}
on_contextmenu
(
event
)
{
if
(
event
.
button
=
=
0
&
&
isTabGroupLabel
(
this
.
ariaFocusedItem
)
)
{
gBrowser
.
tabGroupMenu
.
openEditModal
(
this
.
ariaFocusedItem
.
closest
(
"
tab
-
group
"
)
)
;
event
.
preventDefault
(
)
;
}
}
get
emptyTabTitle
(
)
{
const
l10nId
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
privatebrowsing
.
autostart
"
)
?
"
tabbrowser
-
empty
-
private
-
tab
-
title
"
:
"
tabbrowser
-
empty
-
tab
-
title
"
;
return
gBrowser
.
tabLocalization
.
formatValueSync
(
l10nId
)
;
}
get
tabbox
(
)
{
return
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
}
get
newTabButton
(
)
{
return
this
.
querySelector
(
"
#
tabs
-
newtab
-
button
"
)
;
}
get
verticalMode
(
)
{
return
this
.
getAttribute
(
"
orient
"
)
=
=
"
vertical
"
;
}
get
#
rtlMode
(
)
{
return
!
this
.
verticalMode
&
&
RTL_UI
;
}
get
overflowing
(
)
{
return
this
.
hasAttribute
(
"
overflow
"
)
;
}
#
allTabs
;
get
allTabs
(
)
{
if
(
this
.
#
allTabs
)
{
return
this
.
#
allTabs
;
}
let
children
=
Array
.
from
(
this
.
arrowScrollbox
.
children
)
;
children
.
pop
(
)
;
for
(
let
i
=
children
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
children
[
i
]
.
tagName
=
=
"
tab
-
group
"
)
{
children
.
splice
(
i
1
.
.
.
children
[
i
]
.
tabs
)
;
}
}
this
.
#
allTabs
=
[
.
.
.
this
.
verticalPinnedTabsContainer
.
children
.
.
.
children
]
;
return
this
.
#
allTabs
;
}
get
allGroups
(
)
{
let
children
=
Array
.
from
(
this
.
arrowScrollbox
.
children
)
;
return
children
.
filter
(
node
=
>
node
.
tagName
=
=
"
tab
-
group
"
)
;
}
get
openTabs
(
)
{
if
(
!
this
.
#
openTabs
)
{
this
.
#
openTabs
=
this
.
allTabs
.
filter
(
tab
=
>
tab
.
isOpen
)
;
}
return
this
.
#
openTabs
;
}
#
openTabs
;
get
visibleTabs
(
)
{
if
(
!
this
.
#
visibleTabs
)
{
this
.
#
visibleTabs
=
this
.
openTabs
.
filter
(
tab
=
>
tab
.
visible
)
;
}
return
this
.
#
visibleTabs
;
}
#
visibleTabs
;
get
tablistHasFocus
(
)
{
return
this
.
hasAttribute
(
"
tablist
-
has
-
focus
"
)
;
}
set
tablistHasFocus
(
hasFocus
)
{
this
.
toggleAttribute
(
"
tablist
-
has
-
focus
"
hasFocus
)
;
}
#
focusableItems
;
get
ariaFocusableItems
(
)
{
if
(
this
.
#
focusableItems
)
{
return
this
.
#
focusableItems
;
}
let
elementIndex
=
0
;
let
verticalPinnedTabsContainer
=
document
.
getElementById
(
"
vertical
-
pinned
-
tabs
-
container
"
)
;
for
(
let
i
=
0
;
i
<
verticalPinnedTabsContainer
.
childElementCount
;
i
+
+
)
{
verticalPinnedTabsContainer
.
children
[
i
]
.
elementIndex
=
elementIndex
+
+
;
}
let
children
=
Array
.
from
(
this
.
arrowScrollbox
.
children
)
;
let
focusableItems
=
[
]
;
for
(
let
child
of
children
)
{
if
(
isTab
(
child
)
&
&
child
.
visible
)
{
child
.
elementIndex
=
elementIndex
+
+
;
focusableItems
.
push
(
child
)
;
}
else
if
(
isTabGroup
(
child
)
)
{
child
.
labelElement
.
elementIndex
=
elementIndex
+
+
;
focusableItems
.
push
(
child
.
labelElement
)
;
if
(
!
child
.
collapsed
)
{
let
visibleTabsInGroup
=
child
.
tabs
.
filter
(
tab
=
>
tab
.
visible
)
;
visibleTabsInGroup
.
forEach
(
tab
=
>
{
tab
.
elementIndex
=
elementIndex
+
+
;
}
)
;
focusableItems
.
push
(
.
.
.
visibleTabsInGroup
)
;
}
}
}
this
.
#
focusableItems
=
[
.
.
.
verticalPinnedTabsContainer
.
children
.
.
.
focusableItems
]
;
return
this
.
#
focusableItems
;
}
_invalidateCachedTabs
(
)
{
this
.
#
allTabs
=
null
;
this
.
_invalidateCachedVisibleTabs
(
)
;
}
_invalidateCachedVisibleTabs
(
)
{
this
.
#
openTabs
=
null
;
this
.
#
visibleTabs
=
null
;
this
.
#
focusableItems
=
null
;
}
#
isContainerVerticalPinnedExpanded
(
tab
)
{
return
(
this
.
verticalMode
&
&
tab
.
hasAttribute
(
"
pinned
"
)
&
&
this
.
hasAttribute
(
"
expanded
"
)
)
;
}
appendChild
(
tab
)
{
return
this
.
insertBefore
(
tab
null
)
;
}
insertBefore
(
tab
node
)
{
if
(
!
this
.
arrowScrollbox
)
{
throw
new
Error
(
"
Shouldn
'
t
call
this
without
arrowscrollbox
"
)
;
}
if
(
node
=
=
null
)
{
node
=
this
.
arrowScrollbox
.
lastChild
;
}
node
.
before
(
tab
)
;
if
(
this
.
#
mustUpdateTabMinHeight
)
{
this
.
#
updateTabMinHeight
(
)
;
}
}
#
updateTabMinWidth
(
val
)
{
this
.
style
.
setProperty
(
"
-
-
tab
-
min
-
width
-
pref
"
(
val
?
?
this
.
_tabMinWidthPref
)
+
"
px
"
)
;
}
#
updateTabMinHeight
(
)
{
if
(
!
this
.
verticalMode
|
|
!
window
.
toolbar
.
visible
)
{
this
.
#
mustUpdateTabMinHeight
=
false
;
return
;
}
let
firstScrollableTab
=
this
.
visibleTabs
.
find
(
this
.
arrowScrollbox
.
_canScrollToElement
)
;
if
(
!
firstScrollableTab
)
{
this
.
#
mustUpdateTabMinHeight
=
true
;
return
;
}
let
{
height
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
firstScrollableTab
)
;
this
.
#
tabMinHeight
=
height
|
|
36
;
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
height
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
firstScrollableTab
)
.
height
;
if
(
height
)
{
this
.
#
tabMinHeight
=
height
;
}
}
(
)
=
>
{
}
)
;
}
get
_isCustomizing
(
)
{
return
document
.
documentElement
.
hasAttribute
(
"
customizing
"
)
;
}
_selectNewTab
(
aNewTab
aFallbackDir
aWrap
)
{
if
(
!
gSharedTabWarning
.
willShowSharedTabWarning
(
aNewTab
)
)
{
super
.
_selectNewTab
(
aNewTab
aFallbackDir
aWrap
)
;
}
}
observe
(
aSubject
aTopic
)
{
switch
(
aTopic
)
{
case
"
nsPref
:
changed
"
:
let
containersEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
const
newTabLeftClickOpensContainersMenu
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
newTabContainerOnLeftClick
.
enabled
"
)
;
const
newTab
=
document
.
getElementById
(
"
new
-
tab
-
button
"
)
;
const
newTab2
=
this
.
newTabButton
;
const
newTabVertical
=
document
.
getElementById
(
"
vertical
-
tabs
-
newtab
-
button
"
)
;
for
(
let
parent
of
[
newTab
newTab2
newTabVertical
]
)
{
if
(
!
parent
)
{
continue
;
}
parent
.
removeAttribute
(
"
type
"
)
;
if
(
parent
.
menupopup
)
{
parent
.
menupopup
.
remove
(
)
;
}
if
(
containersEnabled
)
{
parent
.
setAttribute
(
"
context
"
"
new
-
tab
-
button
-
popup
"
)
;
let
popup
=
document
.
getElementById
(
"
new
-
tab
-
button
-
popup
"
)
.
cloneNode
(
true
)
;
popup
.
removeAttribute
(
"
id
"
)
;
popup
.
className
=
"
new
-
tab
-
popup
"
;
popup
.
setAttribute
(
"
position
"
"
after_end
"
)
;
popup
.
addEventListener
(
"
popupshowing
"
CreateContainerTabMenu
)
;
parent
.
prepend
(
popup
)
;
parent
.
setAttribute
(
"
type
"
"
menu
"
)
;
nodeToTooltipMap
[
parent
.
id
]
=
newTabLeftClickOpensContainersMenu
?
"
newTabAlwaysContainer
.
tooltip
"
:
"
newTabContainer
.
tooltip
"
;
}
else
{
nodeToTooltipMap
[
parent
.
id
]
=
"
newTabButton
.
tooltip
"
;
parent
.
removeAttribute
(
"
context
"
"
new
-
tab
-
button
-
popup
"
)
;
}
gDynamicTooltipCache
.
delete
(
parent
.
id
)
;
if
(
containersEnabled
&
&
!
newTabLeftClickOpensContainersMenu
)
{
gClickAndHoldListenersOnElement
.
add
(
parent
)
;
}
else
{
gClickAndHoldListenersOnElement
.
remove
(
parent
)
;
}
}
break
;
}
}
_updateCloseButtons
(
)
{
if
(
this
.
overflowing
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
return
;
}
if
(
this
.
_closeButtonsUpdatePending
)
{
return
;
}
this
.
_closeButtonsUpdatePending
=
true
;
window
.
requestAnimationFrame
(
(
)
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
this
.
_closeButtonsUpdatePending
=
false
;
if
(
this
.
overflowing
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
return
;
}
let
rect
=
ele
=
>
{
return
window
.
windowUtils
.
getBoundsWithoutFlushing
(
ele
)
;
}
;
let
tab
=
this
.
visibleTabs
[
gBrowser
.
pinnedTabCount
]
;
if
(
tab
&
&
rect
(
tab
)
.
width
<
=
this
.
_tabClipWidth
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
}
else
{
this
.
removeAttribute
(
"
closebuttons
"
)
;
}
}
)
;
}
)
;
}
_handleTabSelect
(
aInstant
)
{
let
selectedTab
=
this
.
selectedItem
;
if
(
this
.
overflowing
)
{
this
.
arrowScrollbox
.
ensureElementIsVisible
(
selectedTab
aInstant
)
;
}
selectedTab
.
_notselectedsinceload
=
false
;
}
_lockTabSizing
(
aTab
aTabWidth
)
{
if
(
this
.
verticalMode
)
{
return
;
}
let
tabs
=
this
.
visibleTabs
;
if
(
!
tabs
.
length
)
{
return
;
}
var
isEndTab
=
aTab
.
_tPos
>
tabs
.
at
(
-
1
)
.
_tPos
;
if
(
!
this
.
_tabDefaultMaxWidth
)
{
this
.
_tabDefaultMaxWidth
=
parseFloat
(
window
.
getComputedStyle
(
aTab
)
.
maxWidth
)
;
}
this
.
_lastTabClosedByMouse
=
true
;
this
.
_scrollButtonWidth
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
arrowScrollbox
.
_scrollButtonDown
)
.
width
;
if
(
this
.
overflowing
)
{
if
(
isEndTab
|
|
!
this
.
arrowScrollbox
.
hasAttribute
(
"
scrolledtoend
"
)
)
{
return
;
}
if
(
aTab
.
owner
)
{
return
;
}
this
.
_expandSpacerBy
(
aTabWidth
)
;
}
else
{
if
(
isEndTab
&
&
!
this
.
_hasTabTempMaxWidth
)
{
return
;
}
let
numPinned
=
gBrowser
.
pinnedTabCount
;
if
(
isEndTab
)
{
let
numNormalTabs
=
tabs
.
length
-
numPinned
;
aTabWidth
=
(
aTabWidth
*
(
numNormalTabs
+
1
)
)
/
numNormalTabs
;
if
(
aTabWidth
>
this
.
_tabDefaultMaxWidth
)
{
aTabWidth
=
this
.
_tabDefaultMaxWidth
;
}
}
aTabWidth
+
=
"
px
"
;
let
tabsToReset
=
[
]
;
for
(
let
i
=
numPinned
;
i
<
tabs
.
length
;
i
+
+
)
{
let
tab
=
tabs
[
i
]
;
tab
.
style
.
setProperty
(
"
max
-
width
"
aTabWidth
"
important
"
)
;
if
(
!
isEndTab
)
{
tab
.
style
.
transition
=
"
none
"
;
tabsToReset
.
push
(
tab
)
;
}
}
if
(
tabsToReset
.
length
)
{
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
for
(
let
tab
of
tabsToReset
)
{
tab
.
style
.
transition
=
"
"
;
}
}
)
;
}
)
;
}
this
.
_hasTabTempMaxWidth
=
true
;
gBrowser
.
addEventListener
(
"
mousemove
"
this
)
;
window
.
addEventListener
(
"
mouseout
"
this
)
;
}
}
_expandSpacerBy
(
pixels
)
{
let
spacer
=
this
.
_closingTabsSpacer
;
spacer
.
style
.
width
=
parseFloat
(
spacer
.
style
.
width
)
+
pixels
+
"
px
"
;
this
.
toggleAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
true
)
;
gBrowser
.
addEventListener
(
"
mousemove
"
this
)
;
window
.
addEventListener
(
"
mouseout
"
this
)
;
}
_unlockTabSizing
(
)
{
gBrowser
.
removeEventListener
(
"
mousemove
"
this
)
;
window
.
removeEventListener
(
"
mouseout
"
this
)
;
if
(
this
.
_hasTabTempMaxWidth
)
{
this
.
_hasTabTempMaxWidth
=
false
;
let
tabs
=
this
.
allTabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
tabs
[
i
]
.
style
.
maxWidth
=
"
"
;
}
}
if
(
this
.
hasAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
)
)
{
this
.
removeAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
)
;
this
.
_closingTabsSpacer
.
style
.
width
=
0
;
}
}
uiDensityChanged
(
)
{
this
.
_positionPinnedTabs
(
)
;
this
.
_updateCloseButtons
(
)
;
this
.
#
updateTabMinHeight
(
)
;
this
.
_handleTabSelect
(
true
)
;
}
_updateVerticalPinnedTabs
(
)
{
let
verticalTabsContainer
=
document
.
getElementById
(
"
vertical
-
pinned
-
tabs
-
container
"
)
;
let
numPinned
=
gBrowser
.
pinnedTabCount
;
if
(
gBrowser
.
pinnedTabCount
!
=
=
verticalTabsContainer
.
children
.
length
)
{
let
tabs
=
this
.
visibleTabs
;
for
(
let
i
=
0
;
i
<
numPinned
;
i
+
+
)
{
tabs
[
i
]
.
style
.
marginInlineStart
=
"
"
;
verticalTabsContainer
.
appendChild
(
tabs
[
i
]
)
;
}
}
this
.
style
.
removeProperty
(
"
-
-
tab
-
overflow
-
pinned
-
tabs
-
width
"
)
;
}
_resetVerticalPinnedTabs
(
)
{
let
verticalTabsContainer
=
document
.
getElementById
(
"
vertical
-
pinned
-
tabs
-
container
"
)
;
if
(
!
verticalTabsContainer
.
children
.
length
)
{
return
;
}
for
(
const
child
of
Array
.
from
(
verticalTabsContainer
.
children
)
.
reverse
(
)
)
{
this
.
arrowScrollbox
.
prepend
(
child
)
;
}
}
_positionPinnedTabs
(
)
{
let
tabs
=
this
.
visibleTabs
;
let
numPinned
=
gBrowser
.
pinnedTabCount
;
let
absPositionHorizontalTabs
=
this
.
overflowing
&
&
tabs
.
length
>
numPinned
&
&
numPinned
>
0
;
this
.
toggleAttribute
(
"
haspinnedtabs
"
!
!
numPinned
)
;
this
.
toggleAttribute
(
"
positionpinnedtabs
"
absPositionHorizontalTabs
)
;
if
(
this
.
verticalMode
)
{
this
.
_updateVerticalPinnedTabs
(
)
;
}
else
if
(
absPositionHorizontalTabs
)
{
let
layoutData
=
this
.
_pinnedTabsLayoutCache
;
let
uiDensity
=
document
.
documentElement
.
getAttribute
(
"
uidensity
"
)
;
if
(
!
layoutData
|
|
layoutData
.
uiDensity
!
=
uiDensity
)
{
let
arrowScrollbox
=
this
.
arrowScrollbox
;
layoutData
=
this
.
_pinnedTabsLayoutCache
=
{
uiDensity
pinnedTabWidth
:
tabs
[
0
]
.
getBoundingClientRect
(
)
.
width
scrollStartOffset
:
arrowScrollbox
.
scrollbox
.
getBoundingClientRect
(
)
.
left
-
arrowScrollbox
.
getBoundingClientRect
(
)
.
left
+
parseFloat
(
getComputedStyle
(
arrowScrollbox
.
scrollbox
)
.
paddingInlineStart
)
}
;
}
let
width
=
0
;
for
(
let
i
=
numPinned
-
1
;
i
>
=
0
;
i
-
-
)
{
let
tab
=
tabs
[
i
]
;
width
+
=
layoutData
.
pinnedTabWidth
;
tab
.
style
.
setProperty
(
"
margin
-
inline
-
start
"
-
(
width
+
layoutData
.
scrollStartOffset
)
+
"
px
"
"
important
"
)
;
}
this
.
style
.
setProperty
(
"
-
-
tab
-
overflow
-
pinned
-
tabs
-
width
"
width
+
"
px
"
)
;
}
else
{
for
(
let
i
=
0
;
i
<
numPinned
;
i
+
+
)
{
let
tab
=
tabs
[
i
]
;
tab
.
style
.
marginInlineStart
=
"
"
;
}
this
.
style
.
removeProperty
(
"
-
-
tab
-
overflow
-
pinned
-
tabs
-
width
"
)
;
}
if
(
this
.
_lastNumPinned
!
=
numPinned
)
{
this
.
_lastNumPinned
=
numPinned
;
this
.
_handleTabSelect
(
true
)
;
}
}
#
animateExpandedPinnedTabMove
(
event
)
{
let
draggedTab
=
event
.
dataTransfer
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
let
dragData
=
draggedTab
.
_dragData
;
let
movingTabs
=
dragData
.
movingTabs
;
if
(
!
this
.
hasAttribute
(
"
movingtab
"
)
)
{
this
.
toggleAttribute
(
"
movingtab
"
true
)
;
gNavToolbox
.
toggleAttribute
(
"
movingtab
"
true
)
;
if
(
!
draggedTab
.
multiselected
)
{
this
.
selectedItem
=
draggedTab
;
}
}
dragData
.
animLastScreenX
?
?
=
dragData
.
screenX
;
dragData
.
animLastScreenY
?
?
=
dragData
.
screenY
;
let
screenX
=
event
.
screenX
;
let
screenY
=
event
.
screenY
;
if
(
screenY
=
=
dragData
.
animLastScreenY
&
&
screenX
=
=
dragData
.
animLastScreenX
)
{
return
;
}
let
tabs
=
this
.
visibleTabs
.
slice
(
0
gBrowser
.
pinnedTabCount
)
;
let
directionX
=
screenX
>
dragData
.
animLastScreenX
;
let
directionY
=
screenY
>
dragData
.
animLastScreenY
;
dragData
.
animLastScreenY
=
screenY
;
dragData
.
animLastScreenX
=
screenX
;
let
{
width
:
tabWidth
height
:
tabHeight
}
=
draggedTab
.
getBoundingClientRect
(
)
;
let
shiftSizeX
=
tabWidth
*
movingTabs
.
length
;
let
shiftSizeY
=
tabHeight
;
dragData
.
tabWidth
=
tabWidth
;
dragData
.
tabHeight
=
tabHeight
;
let
firstTabInRow
;
let
lastTabInRow
;
let
lastTab
=
tabs
.
at
(
-
1
)
;
if
(
RTL_UI
)
{
firstTabInRow
=
tabs
.
length
>
=
this
.
#
maxTabsPerRow
?
tabs
[
this
.
#
maxTabsPerRow
-
1
]
:
lastTab
;
lastTabInRow
=
tabs
[
0
]
;
}
else
{
firstTabInRow
=
tabs
[
0
]
;
lastTabInRow
=
tabs
.
length
>
=
this
.
#
maxTabsPerRow
?
tabs
[
this
.
#
maxTabsPerRow
-
1
]
:
lastTab
;
}
let
lastMovingTabScreenX
=
movingTabs
.
at
(
-
1
)
.
screenX
;
let
lastMovingTabScreenY
=
movingTabs
.
at
(
-
1
)
.
screenY
;
let
firstMovingTabScreenX
=
movingTabs
[
0
]
.
screenX
;
let
firstMovingTabScreenY
=
movingTabs
[
0
]
.
screenY
;
let
translateX
=
screenX
-
dragData
.
screenX
;
let
translateY
=
screenY
-
dragData
.
screenY
;
translateY
+
=
this
.
verticalPinnedTabsContainer
.
scrollTop
-
dragData
.
scrollPos
;
let
firstBoundX
=
firstTabInRow
.
screenX
-
firstMovingTabScreenX
;
let
firstBoundY
=
firstTabInRow
.
screenY
-
firstMovingTabScreenY
;
let
lastBoundX
=
lastTabInRow
.
screenX
+
lastTabInRow
.
getBoundingClientRect
(
)
.
width
-
(
lastMovingTabScreenX
+
tabWidth
)
;
let
lastBoundY
=
lastTab
.
screenY
+
lastTab
.
getBoundingClientRect
(
)
.
height
-
(
lastMovingTabScreenY
+
tabHeight
)
;
translateX
=
Math
.
min
(
Math
.
max
(
translateX
firstBoundX
)
lastBoundX
)
;
translateY
=
Math
.
min
(
Math
.
max
(
translateY
firstBoundY
)
lastBoundY
)
;
for
(
let
tab
of
movingTabs
)
{
tab
.
style
.
transform
=
translate
(
{
translateX
}
px
{
translateY
}
px
)
;
}
dragData
.
translateX
=
translateX
;
dragData
.
translateY
=
translateY
;
tabs
=
tabs
.
filter
(
t
=
>
!
movingTabs
.
includes
(
t
)
|
|
t
=
=
draggedTab
)
;
let
firstTabCenterX
=
firstMovingTabScreenX
+
translateX
+
tabWidth
/
2
;
let
lastTabCenterX
=
lastMovingTabScreenX
+
translateX
+
tabWidth
/
2
;
let
tabCenterX
=
directionX
?
lastTabCenterX
:
firstTabCenterX
;
let
firstTabCenterY
=
firstMovingTabScreenY
+
translateY
+
tabHeight
/
2
;
let
lastTabCenterY
=
lastMovingTabScreenY
+
translateY
+
tabHeight
/
2
;
let
tabCenterY
=
directionY
?
lastTabCenterY
:
firstTabCenterY
;
let
shiftNumber
=
this
.
#
maxTabsPerRow
-
movingTabs
.
length
;
let
getTabShift
=
(
tab
dropIndex
)
=
>
{
if
(
tab
.
_tPos
<
draggedTab
.
_tPos
&
&
tab
.
_tPos
>
=
dropIndex
)
{
let
tabRow
=
Math
.
ceil
(
(
tab
.
_tPos
+
1
)
/
this
.
#
maxTabsPerRow
)
;
let
shiftedTabRow
=
Math
.
ceil
(
(
tab
.
_tPos
+
1
+
movingTabs
.
length
)
/
this
.
#
maxTabsPerRow
)
;
if
(
tab
.
_tPos
&
&
tabRow
!
=
shiftedTabRow
)
{
return
[
RTL_UI
?
tabWidth
*
shiftNumber
:
-
tabWidth
*
shiftNumber
shiftSizeY
]
;
}
return
[
RTL_UI
?
-
shiftSizeX
:
shiftSizeX
0
]
;
}
if
(
tab
.
_tPos
>
draggedTab
.
_tPos
&
&
tab
.
_tPos
<
dropIndex
)
{
let
tabRow
=
Math
.
floor
(
tab
.
_tPos
/
this
.
#
maxTabsPerRow
)
;
let
shiftedTabRow
=
Math
.
floor
(
(
tab
.
_tPos
-
movingTabs
.
length
)
/
this
.
#
maxTabsPerRow
)
;
if
(
tab
.
_tPos
&
&
tabRow
!
=
shiftedTabRow
)
{
return
[
RTL_UI
?
-
tabWidth
*
shiftNumber
:
tabWidth
*
shiftNumber
-
shiftSizeY
]
;
}
return
[
RTL_UI
?
shiftSizeX
:
-
shiftSizeX
0
]
;
}
return
[
0
0
]
;
}
;
let
low
=
0
;
let
high
=
tabs
.
length
-
1
;
let
newIndex
=
-
1
;
let
oldIndex
=
dragData
.
animDropIndex
?
?
movingTabs
[
0
]
.
_tPos
;
while
(
low
<
=
high
)
{
let
mid
=
Math
.
floor
(
(
low
+
high
)
/
2
)
;
if
(
tabs
[
mid
]
=
=
draggedTab
&
&
+
+
mid
>
high
)
{
break
;
}
let
[
shiftX
shiftY
]
=
getTabShift
(
tabs
[
mid
]
oldIndex
)
;
screenX
=
tabs
[
mid
]
.
screenX
+
shiftX
;
screenY
=
tabs
[
mid
]
.
screenY
+
shiftY
;
if
(
screenY
+
tabHeight
<
tabCenterY
)
{
low
=
mid
+
1
;
}
else
if
(
screenY
>
tabCenterY
)
{
high
=
mid
-
1
;
}
else
if
(
screenX
>
tabCenterX
)
{
high
=
mid
-
1
;
}
else
if
(
screenX
+
tabWidth
<
tabCenterX
)
{
low
=
mid
+
1
;
}
else
{
newIndex
=
tabs
[
mid
]
.
_tPos
;
break
;
}
}
if
(
newIndex
>
=
oldIndex
&
&
newIndex
<
tabs
.
length
)
{
newIndex
+
+
;
}
if
(
newIndex
<
0
)
{
newIndex
=
oldIndex
;
}
if
(
newIndex
=
=
dragData
.
animDropIndex
)
{
return
;
}
dragData
.
animDropIndex
=
newIndex
;
dragData
.
dropElement
=
tabs
[
newIndex
]
;
dragData
.
dropBefore
=
newIndex
<
tabs
.
length
;
for
(
let
tab
of
tabs
)
{
if
(
tab
!
=
draggedTab
)
{
let
[
shiftX
shiftY
]
=
getTabShift
(
tab
newIndex
)
;
tab
.
style
.
transform
=
shiftX
|
|
shiftY
?
translate
(
{
shiftX
}
px
{
shiftY
}
px
)
:
"
"
;
}
}
}
_animateTabMove
(
event
)
{
let
draggedTab
=
event
.
dataTransfer
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
let
dragData
=
draggedTab
.
_dragData
;
let
movingTabs
=
dragData
.
movingTabs
;
if
(
!
this
.
hasAttribute
(
"
movingtab
"
)
)
{
this
.
toggleAttribute
(
"
movingtab
"
true
)
;
gNavToolbox
.
toggleAttribute
(
"
movingtab
"
true
)
;
if
(
!
draggedTab
.
multiselected
)
{
this
.
selectedItem
=
draggedTab
;
}
}
dragData
.
animLastScreenPos
?
?
=
this
.
verticalMode
?
dragData
.
screenY
:
dragData
.
screenX
;
let
screen
=
this
.
verticalMode
?
event
.
screenY
:
event
.
screenX
;
if
(
screen
=
=
dragData
.
animLastScreenPos
)
{
return
;
}
let
screenForward
=
screen
>
dragData
.
animLastScreenPos
;
dragData
.
animLastScreenPos
=
screen
;
this
.
#
clearDragOverCreateGroupTimer
(
)
;
let
isPinned
=
draggedTab
.
pinned
;
let
numPinned
=
gBrowser
.
pinnedTabCount
;
let
tabs
=
this
.
ariaFocusableItems
.
slice
(
isPinned
?
0
:
numPinned
isPinned
?
numPinned
:
undefined
)
;
if
(
this
.
#
rtlMode
)
{
tabs
.
reverse
(
)
;
movingTabs
=
[
.
.
.
movingTabs
]
.
reverse
(
)
;
}
let
bounds
=
ele
=
>
window
.
windowUtils
.
getBoundsWithoutFlushing
(
ele
)
;
let
logicalForward
=
screenForward
!
=
this
.
#
rtlMode
;
let
screenAxis
=
this
.
verticalMode
?
"
screenY
"
:
"
screenX
"
;
let
size
=
this
.
verticalMode
?
"
height
"
:
"
width
"
;
let
translateAxis
=
this
.
verticalMode
?
"
translateY
"
:
"
translateX
"
;
let
scrollDirection
=
this
.
verticalMode
?
"
scrollTop
"
:
"
scrollLeft
"
;
let
{
width
:
tabWidth
height
:
tabHeight
}
=
bounds
(
draggedTab
)
;
let
translateX
=
event
.
screenX
-
dragData
.
screenX
;
let
translateY
=
event
.
screenY
-
dragData
.
screenY
;
dragData
.
tabWidth
=
tabWidth
;
dragData
.
tabHeight
=
tabHeight
;
dragData
.
translateX
=
translateX
;
dragData
.
translateY
=
translateY
;
let
firstTab
=
tabs
[
0
]
;
let
lastTab
=
tabs
.
at
(
-
1
)
;
let
lastMovingTab
=
movingTabs
.
at
(
-
1
)
;
let
firstMovingTab
=
movingTabs
[
0
]
;
let
endEdge
=
ele
=
>
ele
[
screenAxis
]
+
bounds
(
ele
)
[
size
]
;
let
lastMovingTabScreen
=
endEdge
(
lastMovingTab
)
;
let
firstMovingTabScreen
=
firstMovingTab
[
screenAxis
]
;
let
shiftSize
=
lastMovingTabScreen
-
firstMovingTabScreen
;
let
translate
=
screen
-
dragData
[
screenAxis
]
;
if
(
!
isPinned
)
{
translate
+
=
this
.
arrowScrollbox
.
scrollbox
[
scrollDirection
]
-
dragData
.
scrollPos
;
}
else
if
(
isPinned
&
&
this
.
verticalMode
)
{
translate
+
=
this
.
verticalPinnedTabsContainer
.
scrollTop
-
dragData
.
scrollPos
;
}
let
firstBound
=
firstTab
[
screenAxis
]
-
firstMovingTabScreen
;
let
lastBound
=
endEdge
(
lastTab
)
-
lastMovingTabScreen
;
translate
=
Math
.
min
(
Math
.
max
(
translate
firstBound
)
lastBound
)
;
for
(
let
tab
of
movingTabs
)
{
tab
.
style
.
transform
=
{
translateAxis
}
(
{
translate
}
px
)
;
}
dragData
.
translatePos
=
translate
;
tabs
=
tabs
.
filter
(
t
=
>
!
movingTabs
.
includes
(
t
)
|
|
t
=
=
draggedTab
)
;
let
getTabShift
=
(
item
dropElementIndex
)
=
>
{
if
(
item
.
elementIndex
<
draggedTab
.
elementIndex
&
&
item
.
elementIndex
>
=
dropElementIndex
)
{
return
this
.
#
rtlMode
?
-
shiftSize
:
shiftSize
;
}
if
(
item
.
elementIndex
>
draggedTab
.
elementIndex
&
&
item
.
elementIndex
<
dropElementIndex
)
{
return
this
.
#
rtlMode
?
shiftSize
:
-
shiftSize
;
}
return
0
;
}
;
let
oldDropElementIndex
=
dragData
.
animDropElementIndex
?
?
movingTabs
[
0
]
.
elementIndex
;
function
greatestOverlap
(
p1
s1
p2
s2
)
{
let
overlapSize
;
if
(
p1
<
p2
)
{
overlapSize
=
p1
+
s1
-
p2
;
}
else
{
overlapSize
=
p2
+
s2
-
p1
;
}
if
(
overlapSize
<
=
0
)
{
return
0
;
}
let
overlapPercent
=
Math
.
max
(
overlapSize
/
s1
overlapSize
/
s2
)
;
return
Math
.
min
(
overlapPercent
1
)
;
}
let
getOverlappedElement
=
(
)
=
>
{
let
point
=
(
screenForward
?
lastMovingTabScreen
:
firstMovingTabScreen
)
+
translate
;
let
low
=
0
;
let
high
=
tabs
.
length
-
1
;
while
(
low
<
=
high
)
{
let
mid
=
Math
.
floor
(
(
low
+
high
)
/
2
)
;
if
(
tabs
[
mid
]
=
=
draggedTab
&
&
+
+
mid
>
high
)
{
break
;
}
let
element
=
tabs
[
mid
]
;
let
elementForSize
=
isTabGroupLabel
(
element
)
?
element
.
parentElement
:
element
;
screen
=
elementForSize
[
screenAxis
]
+
getTabShift
(
element
oldDropElementIndex
)
;
if
(
screen
>
point
)
{
high
=
mid
-
1
;
}
else
if
(
screen
+
bounds
(
elementForSize
)
[
size
]
<
point
)
{
low
=
mid
+
1
;
}
else
{
return
element
;
}
}
return
null
;
}
;
let
dropElement
=
getOverlappedElement
(
)
;
if
(
!
dropElement
)
{
dropElement
=
this
.
ariaFocusableItems
[
oldDropElementIndex
]
;
}
let
newDropElementIndex
=
dropElement
?
dropElement
.
elementIndex
:
oldDropElementIndex
;
let
moveOverThreshold
;
let
overlapPercent
;
let
shouldCreateGroupOnDrop
;
let
dropBefore
;
if
(
dropElement
)
{
let
dropElementForOverlap
=
isTabGroupLabel
(
dropElement
)
?
dropElement
.
parentElement
:
dropElement
;
let
dropElementScreen
=
dropElementForOverlap
[
screenAxis
]
;
let
dropElementPos
=
dropElementScreen
+
getTabShift
(
dropElement
oldDropElementIndex
)
;
let
dropElementSize
=
bounds
(
dropElementForOverlap
)
[
size
]
;
let
firstMovingTabPos
=
firstMovingTabScreen
+
translate
;
overlapPercent
=
greatestOverlap
(
firstMovingTabPos
shiftSize
dropElementPos
dropElementSize
)
;
moveOverThreshold
=
gBrowser
.
_tabGroupsEnabled
?
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
dragdrop
.
moveOverThresholdPercent
"
)
/
100
:
0
.
5
;
moveOverThreshold
=
Math
.
min
(
1
Math
.
max
(
0
moveOverThreshold
)
)
;
let
shouldMoveOver
=
overlapPercent
>
moveOverThreshold
;
if
(
logicalForward
&
&
shouldMoveOver
)
{
newDropElementIndex
+
+
;
}
else
if
(
!
logicalForward
&
&
!
shouldMoveOver
)
{
newDropElementIndex
+
+
;
if
(
newDropElementIndex
>
oldDropElementIndex
)
{
newDropElementIndex
=
oldDropElementIndex
;
}
}
dropElementPos
=
dropElementScreen
+
getTabShift
(
dropElement
newDropElementIndex
)
;
overlapPercent
=
greatestOverlap
(
firstMovingTabPos
shiftSize
dropElementPos
dropElementSize
)
;
dropBefore
=
firstMovingTabPos
<
dropElementPos
;
if
(
this
.
#
rtlMode
)
{
dropBefore
=
!
dropBefore
;
}
}
if
(
gBrowser
.
_tabGroupsEnabled
&
&
!
isPinned
)
{
let
dragOverGroupingThreshold
=
1
-
moveOverThreshold
;
shouldCreateGroupOnDrop
=
dropElement
!
=
draggedTab
&
&
isTab
(
dropElement
)
&
&
!
dropElement
?
.
group
&
&
overlapPercent
>
dragOverGroupingThreshold
;
if
(
shouldCreateGroupOnDrop
)
{
this
.
#
dragOverCreateGroupTimer
=
setTimeout
(
(
)
=
>
this
.
#
triggerDragOverCreateGroup
(
dragData
dropElement
)
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
groups
.
dragOverDelayMS
"
)
)
;
}
else
{
this
.
removeAttribute
(
"
movingtab
-
createGroup
"
)
;
document
.
querySelector
(
"
[
dragover
-
createGroup
]
"
)
?
.
removeAttribute
(
"
dragover
-
createGroup
"
)
;
delete
dragData
.
shouldCreateGroupOnDrop
;
let
dropElementGroup
=
isTabGroupLabel
(
dropElement
)
?
dropElement
.
closest
(
"
tab
-
group
"
)
:
dropElement
?
.
group
;
let
colorCode
=
dropElementGroup
?
.
color
;
if
(
isTab
(
dropElement
)
&
&
dropElementGroup
&
&
dropElement
=
=
dropElementGroup
.
tabs
.
at
(
-
1
)
&
&
!
dropBefore
&
&
overlapPercent
<
dragOverGroupingThreshold
)
{
dropElement
=
dropElementGroup
;
colorCode
=
undefined
;
}
else
if
(
isTabGroupLabel
(
dropElement
)
)
{
if
(
dropBefore
)
{
dropElement
=
dropElementGroup
;
colorCode
=
undefined
;
}
else
if
(
dropElementGroup
.
collapsed
)
{
dropElement
=
dropElementGroup
;
colorCode
=
undefined
;
}
else
{
dropElement
=
dropElementGroup
.
tabs
[
0
]
;
dropBefore
=
true
;
}
}
this
.
#
setDragOverGroupColor
(
colorCode
)
;
this
.
toggleAttribute
(
"
movingtab
-
ungroup
"
!
colorCode
)
;
}
}
if
(
newDropElementIndex
=
=
oldDropElementIndex
&
&
dropBefore
=
=
dragData
.
dropBefore
&
&
dropElement
=
=
dragData
.
dropElement
)
{
return
;
}
dragData
.
dropElement
=
dropElement
;
dragData
.
dropBefore
=
dropBefore
;
dragData
.
animDropElementIndex
=
newDropElementIndex
;
for
(
let
item
of
tabs
)
{
if
(
item
=
=
draggedTab
)
{
continue
;
}
let
shift
=
getTabShift
(
item
newDropElementIndex
)
;
let
transform
=
shift
?
{
translateAxis
}
(
{
shift
}
px
)
:
"
"
;
if
(
isTabGroupLabel
(
item
)
)
{
item
=
item
.
parentElement
;
}
item
.
style
.
transform
=
transform
;
}
}
#
triggerDragOverCreateGroup
(
dragData
dropElement
)
{
this
.
#
clearDragOverCreateGroupTimer
(
)
;
dragData
.
shouldCreateGroupOnDrop
=
true
;
this
.
toggleAttribute
(
"
movingtab
-
createGroup
"
true
)
;
this
.
removeAttribute
(
"
movingtab
-
ungroup
"
)
;
dropElement
.
toggleAttribute
(
"
dragover
-
createGroup
"
true
)
;
this
.
#
setDragOverGroupColor
(
dragData
.
tabGroupCreationColor
)
;
}
#
clearDragOverCreateGroupTimer
(
)
{
if
(
this
.
#
dragOverCreateGroupTimer
)
{
clearTimeout
(
this
.
#
dragOverCreateGroupTimer
)
;
this
.
#
dragOverCreateGroupTimer
=
0
;
}
}
#
setDragOverGroupColor
(
groupColorCode
)
{
if
(
!
groupColorCode
)
{
this
.
style
.
removeProperty
(
"
-
-
dragover
-
tab
-
group
-
color
"
)
;
this
.
style
.
removeProperty
(
"
-
-
dragover
-
tab
-
group
-
color
-
invert
"
)
;
this
.
style
.
removeProperty
(
"
-
-
dragover
-
tab
-
group
-
color
-
pale
"
)
;
return
;
}
this
.
style
.
setProperty
(
"
-
-
dragover
-
tab
-
group
-
color
"
var
(
-
-
tab
-
group
-
color
-
{
groupColorCode
}
)
)
;
this
.
style
.
setProperty
(
"
-
-
dragover
-
tab
-
group
-
color
-
invert
"
var
(
-
-
tab
-
group
-
color
-
{
groupColorCode
}
-
invert
)
)
;
this
.
style
.
setProperty
(
"
-
-
dragover
-
tab
-
group
-
color
-
pale
"
var
(
-
-
tab
-
group
-
color
-
{
groupColorCode
}
-
pale
)
)
;
}
_finishAnimateTabMove
(
)
{
if
(
!
this
.
hasAttribute
(
"
movingtab
"
)
)
{
return
;
}
this
.
removeAttribute
(
"
movingtab
"
)
;
gNavToolbox
.
removeAttribute
(
"
movingtab
"
)
;
for
(
let
item
of
this
.
ariaFocusableItems
)
{
if
(
isTabGroupLabel
(
item
)
)
{
item
=
item
.
parentElement
;
}
item
.
style
.
transform
=
"
"
;
item
.
removeAttribute
(
"
dragover
-
createGroup
"
)
;
}
this
.
removeAttribute
(
"
movingtab
-
createGroup
"
)
;
this
.
removeAttribute
(
"
movingtab
-
ungroup
"
)
;
this
.
#
setDragOverGroupColor
(
null
)
;
this
.
#
clearDragOverCreateGroupTimer
(
)
;
this
.
_handleTabSelect
(
)
;
}
#
moveTogetherSelectedTabs
(
tab
)
{
let
draggedTabIndex
=
tab
.
elementIndex
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
animate
=
!
gReduceMotion
;
tab
.
_moveTogetherSelectedTabsData
=
{
finished
:
!
animate
}
;
let
addAnimationData
=
(
movingTab
isBeforeSelectedTab
)
=
>
{
let
lowerIndex
=
Math
.
min
(
movingTab
.
elementIndex
draggedTabIndex
)
+
1
;
let
higherIndex
=
Math
.
max
(
movingTab
.
elementIndex
draggedTabIndex
)
;
let
middleItems
=
this
.
ariaFocusableItems
.
slice
(
lowerIndex
higherIndex
)
.
filter
(
item
=
>
!
item
.
multiselected
)
;
if
(
!
middleItems
.
length
)
{
return
;
}
movingTab
.
_moveTogetherSelectedTabsData
=
{
translatePos
:
0
animate
:
true
}
;
movingTab
.
toggleAttribute
(
"
multiselected
-
move
-
together
"
true
)
;
let
postTransitionCleanup
=
(
)
=
>
{
movingTab
.
_moveTogetherSelectedTabsData
.
animate
=
false
;
}
;
if
(
gReduceMotion
)
{
postTransitionCleanup
(
)
;
}
else
{
let
onTransitionEnd
=
transitionendEvent
=
>
{
if
(
transitionendEvent
.
propertyName
!
=
"
transform
"
|
|
transitionendEvent
.
originalTarget
!
=
movingTab
)
{
return
;
}
movingTab
.
removeEventListener
(
"
transitionend
"
onTransitionEnd
)
;
postTransitionCleanup
(
)
;
}
;
movingTab
.
addEventListener
(
"
transitionend
"
onTransitionEnd
)
;
}
let
movingTabSize
=
movingTab
.
getBoundingClientRect
(
)
[
this
.
verticalMode
?
"
height
"
:
"
width
"
]
;
for
(
let
middleItem
of
middleItems
)
{
if
(
isTab
(
middleItem
)
)
{
if
(
middleItem
.
pinned
!
=
movingTab
.
pinned
)
{
break
;
}
if
(
middleItem
.
multiselected
)
{
continue
;
}
}
if
(
isTabGroupLabel
(
middleItem
)
)
{
middleItem
=
middleItem
.
parentElement
;
}
let
middleItemSize
=
middleItem
.
getBoundingClientRect
(
)
[
this
.
verticalMode
?
"
height
"
:
"
width
"
]
;
if
(
!
middleItem
.
_moveTogetherSelectedTabsData
?
.
translatePos
)
{
middleItem
.
_moveTogetherSelectedTabsData
=
{
translatePos
:
0
}
;
}
movingTab
.
_moveTogetherSelectedTabsData
.
translatePos
+
=
isBeforeSelectedTab
?
middleItemSize
:
-
middleItemSize
;
middleItem
.
_moveTogetherSelectedTabsData
.
translatePos
=
isBeforeSelectedTab
?
-
movingTabSize
:
movingTabSize
;
middleItem
.
toggleAttribute
(
"
multiselected
-
move
-
together
"
true
)
;
}
}
;
let
tabIndex
=
selectedTabs
.
indexOf
(
tab
)
;
for
(
let
i
=
0
;
i
<
tabIndex
;
i
+
+
)
{
let
movingTab
=
selectedTabs
[
i
]
;
if
(
animate
)
{
addAnimationData
(
movingTab
true
)
;
}
else
{
gBrowser
.
moveTabBefore
(
movingTab
tab
)
;
}
}
for
(
let
i
=
selectedTabs
.
length
-
1
;
i
>
tabIndex
;
i
-
-
)
{
let
movingTab
=
selectedTabs
[
i
]
;
if
(
animate
)
{
addAnimationData
(
movingTab
false
)
;
}
else
{
gBrowser
.
moveTabAfter
(
movingTab
tab
)
;
}
}
for
(
let
item
of
this
.
ariaFocusableItems
)
{
if
(
isTabGroupLabel
(
item
)
)
{
item
=
item
.
parentElement
;
}
if
(
item
.
_moveTogetherSelectedTabsData
?
.
translatePos
)
{
let
translatePos
=
(
this
.
#
rtlMode
?
-
1
:
1
)
*
item
.
_moveTogetherSelectedTabsData
.
translatePos
;
item
.
style
.
transform
=
translate
{
this
.
verticalMode
?
"
Y
"
:
"
X
"
}
(
{
translatePos
}
px
)
;
}
}
}
_finishMoveTogetherSelectedTabs
(
tab
)
{
if
(
!
tab
.
_moveTogetherSelectedTabsData
|
|
tab
.
_moveTogetherSelectedTabsData
.
finished
)
{
return
;
}
tab
.
_moveTogetherSelectedTabsData
.
finished
=
true
;
let
selectedTabs
=
gBrowser
.
selectedTabs
;
let
tabIndex
=
selectedTabs
.
indexOf
(
tab
)
;
for
(
let
i
=
0
;
i
<
tabIndex
;
i
+
+
)
{
gBrowser
.
moveTabBefore
(
selectedTabs
[
i
]
tab
)
;
}
for
(
let
i
=
selectedTabs
.
length
-
1
;
i
>
tabIndex
;
i
-
-
)
{
gBrowser
.
moveTabAfter
(
selectedTabs
[
i
]
tab
)
;
}
for
(
let
item
of
this
.
ariaFocusableItems
)
{
if
(
isTabGroupLabel
(
item
)
)
{
item
=
item
.
parentElement
;
}
item
.
style
.
transform
=
"
"
;
item
.
removeAttribute
(
"
multiselected
-
move
-
together
"
)
;
delete
item
.
_moveTogetherSelectedTabsData
;
}
}
#
isAnimatingMoveTogetherSelectedTabs
(
)
{
for
(
let
tab
of
gBrowser
.
selectedTabs
)
{
if
(
tab
.
_moveTogetherSelectedTabsData
?
.
animate
)
{
return
true
;
}
}
return
false
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
mouseout
"
:
let
relatedTarget
=
aEvent
.
relatedTarget
;
if
(
relatedTarget
&
&
relatedTarget
.
ownerDocument
=
=
document
)
{
break
;
}
case
"
mousemove
"
:
if
(
document
.
getElementById
(
"
tabContextMenu
"
)
.
state
!
=
"
open
"
)
{
this
.
_unlockTabSizing
(
)
;
}
break
;
case
"
mouseleave
"
:
this
.
previewPanel
?
.
deactivate
(
)
;
break
;
default
:
let
methodName
=
on_
{
aEvent
.
type
}
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
aEvent
)
;
}
else
{
throw
new
Error
(
Unexpected
event
{
aEvent
.
type
}
)
;
}
}
}
_notifyBackgroundTab
(
aTab
)
{
if
(
aTab
.
pinned
|
|
!
aTab
.
visible
|
|
!
this
.
overflowing
)
{
return
;
}
this
.
_lastTabToScrollIntoView
=
aTab
;
if
(
!
this
.
_backgroundTabScrollPromise
)
{
this
.
_backgroundTabScrollPromise
=
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
lastTabRect
=
this
.
_lastTabToScrollIntoView
.
getBoundingClientRect
(
)
;
let
selectedTab
=
this
.
selectedItem
;
if
(
selectedTab
.
pinned
)
{
selectedTab
=
null
;
}
else
{
selectedTab
=
selectedTab
.
getBoundingClientRect
(
)
;
selectedTab
=
{
left
:
selectedTab
.
left
right
:
selectedTab
.
right
top
:
selectedTab
.
top
bottom
:
selectedTab
.
bottom
}
;
}
return
[
this
.
_lastTabToScrollIntoView
this
.
arrowScrollbox
.
scrollClientRect
lastTabRect
selectedTab
]
;
}
)
.
then
(
(
[
tabToScrollIntoView
scrollRect
tabRect
selectedRect
]
)
=
>
{
delete
this
.
_backgroundTabScrollPromise
;
if
(
this
.
_lastTabToScrollIntoView
!
=
tabToScrollIntoView
)
{
this
.
_notifyBackgroundTab
(
this
.
_lastTabToScrollIntoView
)
;
return
;
}
delete
this
.
_lastTabToScrollIntoView
;
if
(
this
.
verticalMode
?
scrollRect
.
top
<
=
tabRect
.
top
&
&
tabRect
.
bottom
<
=
scrollRect
.
bottom
:
scrollRect
.
left
<
=
tabRect
.
left
&
&
tabRect
.
right
<
=
scrollRect
.
right
)
{
return
;
}
if
(
this
.
arrowScrollbox
.
smoothScroll
)
{
if
(
!
selectedRect
|
|
(
this
.
verticalMode
?
Math
.
max
(
tabRect
.
bottom
-
selectedRect
.
top
selectedRect
.
bottom
-
tabRect
.
top
)
<
=
scrollRect
.
height
:
Math
.
max
(
tabRect
.
right
-
selectedRect
.
left
selectedRect
.
right
-
tabRect
.
left
)
<
=
scrollRect
.
width
)
)
{
this
.
arrowScrollbox
.
ensureElementIsVisible
(
tabToScrollIntoView
)
;
return
;
}
let
scrollPixels
;
if
(
this
.
verticalMode
)
{
scrollPixels
=
tabRect
.
top
-
selectedRect
.
top
;
}
else
if
(
this
.
#
rtlMode
)
{
scrollPixels
=
selectedRect
.
right
-
scrollRect
.
right
;
}
else
{
scrollPixels
=
selectedRect
.
left
-
scrollRect
.
left
;
}
this
.
arrowScrollbox
.
scrollByPixels
(
scrollPixels
)
;
}
if
(
!
this
.
_animateElement
.
hasAttribute
(
"
highlight
"
)
)
{
this
.
_animateElement
.
toggleAttribute
(
"
highlight
"
true
)
;
setTimeout
(
function
(
ele
)
{
ele
.
removeAttribute
(
"
highlight
"
)
;
}
150
this
.
_animateElement
)
;
}
}
)
;
}
}
_getDragTargetTab
(
event
{
ignoreTabSides
=
false
}
=
{
}
)
{
let
{
target
}
=
event
;
if
(
target
.
nodeType
!
=
Node
.
ELEMENT_NODE
)
{
target
=
target
.
parentElement
;
}
let
tab
=
target
?
.
closest
(
"
tab
"
)
;
if
(
tab
&
&
ignoreTabSides
)
{
let
{
width
height
}
=
tab
.
getBoundingClientRect
(
)
;
if
(
event
.
screenX
<
tab
.
screenX
+
width
*
0
.
25
|
|
event
.
screenX
>
tab
.
screenX
+
width
*
0
.
75
|
|
(
(
event
.
screenY
<
tab
.
screenY
+
height
*
0
.
25
|
|
event
.
screenY
>
tab
.
screenY
+
height
*
0
.
75
)
&
&
this
.
verticalMode
)
)
{
return
null
;
}
}
return
tab
;
}
_getDropIndex
(
event
)
{
let
tab
=
this
.
_getDragTargetTab
(
event
)
;
if
(
!
tab
)
{
return
this
.
allTabs
.
length
;
}
let
isBeforeMiddle
;
if
(
this
.
verticalMode
)
{
let
middle
=
tab
.
screenY
+
tab
.
getBoundingClientRect
(
)
.
height
/
2
;
isBeforeMiddle
=
event
.
screenY
<
middle
;
}
else
{
let
middle
=
tab
.
screenX
+
tab
.
getBoundingClientRect
(
)
.
width
/
2
;
isBeforeMiddle
=
this
.
#
rtlMode
?
event
.
screenX
>
middle
:
event
.
screenX
<
middle
;
}
return
tab
.
_tPos
+
(
isBeforeMiddle
?
0
:
1
)
;
}
getDropEffectForTabDrag
(
event
)
{
var
dt
=
event
.
dataTransfer
;
let
isMovingTabs
=
dt
.
mozItemCount
>
0
;
for
(
let
i
=
0
;
i
<
dt
.
mozItemCount
;
i
+
+
)
{
let
types
=
dt
.
mozTypesAt
(
0
)
;
if
(
types
[
0
]
!
=
TAB_DROP_TYPE
)
{
isMovingTabs
=
false
;
break
;
}
}
if
(
isMovingTabs
)
{
let
sourceNode
=
dt
.
mozGetDataAt
(
TAB_DROP_TYPE
0
)
;
if
(
XULElement
.
isInstance
(
sourceNode
)
&
&
sourceNode
.
localName
=
=
"
tab
"
&
&
sourceNode
.
ownerGlobal
.
isChromeWindow
&
&
sourceNode
.
ownerDocument
.
documentElement
.
getAttribute
(
"
windowtype
"
)
=
=
"
navigator
:
browser
"
&
&
sourceNode
.
ownerGlobal
.
gBrowser
.
tabContainer
=
=
sourceNode
.
container
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
!
=
PrivateBrowsingUtils
.
isWindowPrivate
(
sourceNode
.
ownerGlobal
)
)
{
return
"
none
"
;
}
if
(
window
.
gMultiProcessBrowser
!
=
sourceNode
.
ownerGlobal
.
gMultiProcessBrowser
)
{
return
"
none
"
;
}
if
(
window
.
gFissionBrowser
!
=
sourceNode
.
ownerGlobal
.
gFissionBrowser
)
{
return
"
none
"
;
}
return
dt
.
dropEffect
=
=
"
copy
"
?
"
copy
"
:
"
move
"
;
}
}
if
(
browserDragAndDrop
.
canDropLink
(
event
)
)
{
return
"
link
"
;
}
return
"
none
"
;
}
_handleNewTab
(
tab
)
{
if
(
tab
.
container
!
=
this
)
{
return
;
}
tab
.
_fullyOpen
=
true
;
gBrowser
.
tabAnimationsInProgress
-
-
;
this
.
_updateCloseButtons
(
)
;
if
(
tab
.
hasAttribute
(
"
selected
"
)
)
{
this
.
_handleTabSelect
(
)
;
}
else
if
(
!
tab
.
hasAttribute
(
"
skipbackgroundnotify
"
)
)
{
this
.
_notifyBackgroundTab
(
tab
)
;
}
if
(
tab
.
linkedPanel
)
{
NewTabPagePreloading
.
maybeCreatePreloadedBrowser
(
window
)
;
}
if
(
UserInteraction
.
running
(
"
browser
.
tabs
.
opening
"
window
)
)
{
UserInteraction
.
finish
(
"
browser
.
tabs
.
opening
"
window
)
;
}
}
_canAdvanceToTab
(
aTab
)
{
return
!
aTab
.
closing
;
}
getRelatedElement
(
aTab
)
{
if
(
!
aTab
)
{
return
null
;
}
if
(
!
gBrowser
.
_initialized
)
{
return
this
.
tabbox
.
tabpanels
.
firstElementChild
;
}
if
(
!
aTab
.
linkedPanel
)
{
if
(
!
aTab
.
selected
)
{
return
null
;
}
gBrowser
.
_insertBrowser
(
aTab
)
;
}
return
document
.
getElementById
(
aTab
.
linkedPanel
)
;
}
_updateNewTabVisibility
(
)
{
let
wrap
=
n
=
>
n
.
parentNode
.
localName
=
=
"
toolbarpaletteitem
"
?
n
.
parentNode
:
n
;
let
unwrap
=
n
=
>
n
&
&
n
.
localName
=
=
"
toolbarpaletteitem
"
?
n
.
firstElementChild
:
n
;
let
sib
=
this
;
do
{
sib
=
unwrap
(
wrap
(
sib
)
.
nextElementSibling
)
;
}
while
(
sib
&
&
(
sib
.
hidden
|
|
sib
.
id
=
=
"
alltabs
-
button
"
)
)
;
this
.
toggleAttribute
(
"
hasadjacentnewtabbutton
"
sib
&
&
sib
.
id
=
=
"
new
-
tab
-
button
"
)
;
}
onWidgetAfterDOMChange
(
aNode
aNextNode
aContainer
)
{
if
(
aContainer
.
ownerDocument
=
=
document
&
&
aContainer
.
id
=
=
"
TabsToolbar
-
customization
-
target
"
)
{
this
.
_updateNewTabVisibility
(
)
;
}
}
onAreaNodeRegistered
(
aArea
aContainer
)
{
if
(
aContainer
.
ownerDocument
=
=
document
&
&
aArea
=
=
"
TabsToolbar
"
)
{
this
.
_updateNewTabVisibility
(
)
;
}
}
onAreaReset
(
aArea
aContainer
)
{
this
.
onAreaNodeRegistered
(
aArea
aContainer
)
;
}
_hiddenSoundPlayingStatusChanged
(
tab
opts
)
{
let
closed
=
opts
&
&
opts
.
closed
;
if
(
!
closed
&
&
tab
.
soundPlaying
&
&
!
tab
.
visible
)
{
this
.
_hiddenSoundPlayingTabs
.
add
(
tab
)
;
this
.
toggleAttribute
(
"
hiddensoundplaying
"
true
)
;
}
else
{
this
.
_hiddenSoundPlayingTabs
.
delete
(
tab
)
;
if
(
this
.
_hiddenSoundPlayingTabs
.
size
=
=
0
)
{
this
.
removeAttribute
(
"
hiddensoundplaying
"
)
;
}
}
}
destroy
(
)
{
if
(
this
.
boundObserve
)
{
Services
.
prefs
.
removeObserver
(
"
privacy
.
userContext
"
this
.
boundObserve
)
;
}
CustomizableUI
.
removeListener
(
this
)
;
}
updateTabSoundLabel
(
tab
)
{
/
/
Add
aria
-
label
for
inline
audio
button
const
[
unmute
mute
unblock
]
=
gBrowser
.
tabLocalization
.
formatMessagesSync
(
[
"
tabbrowser
-
unmute
-
tab
-
audio
-
aria
-
label
"
"
tabbrowser
-
mute
-
tab
-
audio
-
aria
-
label
"
"
tabbrowser
-
unblock
-
tab
-
audio
-
aria
-
label
"
]
)
;
if
(
tab
.
audioButton
)
{
if
(
tab
.
hasAttribute
(
"
muted
"
)
|
|
tab
.
hasAttribute
(
"
soundplaying
"
)
)
{
let
ariaLabel
;
tab
.
linkedBrowser
.
audioMuted
?
(
ariaLabel
=
unmute
.
attributes
[
0
]
.
value
)
:
(
ariaLabel
=
mute
.
attributes
[
0
]
.
value
)
;
tab
.
audioButton
.
setAttribute
(
"
aria
-
label
"
ariaLabel
)
;
}
else
if
(
tab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
tab
.
audioButton
.
setAttribute
(
"
aria
-
label
"
unblock
.
attributes
[
0
]
.
value
)
;
}
}
}
}
customElements
.
define
(
"
tabbrowser
-
tabs
"
MozTabbrowserTabs
{
extends
:
"
tabs
"
}
)
;
}
