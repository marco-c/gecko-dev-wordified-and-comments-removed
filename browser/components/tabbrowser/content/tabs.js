"
use
strict
"
;
{
const
DIRECTION_BACKWARD
=
-
1
;
const
DIRECTION_FORWARD
=
1
;
const
isTab
=
element
=
>
gBrowser
.
isTab
(
element
)
;
const
isTabGroup
=
element
=
>
gBrowser
.
isTabGroup
(
element
)
;
const
isTabGroupLabel
=
element
=
>
gBrowser
.
isTabGroupLabel
(
element
)
;
class
MozTabbrowserTabs
extends
MozElements
.
TabsBase
{
static
observedAttributes
=
[
"
orient
"
]
;
#
mustUpdateTabMinHeight
=
false
;
#
tabMinHeight
=
36
;
constructor
(
)
{
super
(
)
;
this
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
addEventListener
(
"
TabAttrModified
"
this
)
;
this
.
addEventListener
(
"
TabHide
"
this
)
;
this
.
addEventListener
(
"
TabShow
"
this
)
;
this
.
addEventListener
(
"
TabHoverStart
"
this
)
;
this
.
addEventListener
(
"
TabHoverEnd
"
this
)
;
this
.
addEventListener
(
"
TabGroupLabelHoverStart
"
this
)
;
this
.
addEventListener
(
"
TabGroupLabelHoverEnd
"
this
)
;
this
.
addEventListener
(
"
TabGroupExpand
"
this
)
;
this
.
addEventListener
(
"
TabGroupCollapse
"
this
)
;
this
.
addEventListener
(
"
TabGroupCreate
"
this
)
;
this
.
addEventListener
(
"
TabGroupRemoved
"
this
)
;
this
.
addEventListener
(
"
transitionend
"
this
)
;
this
.
addEventListener
(
"
dblclick
"
this
)
;
this
.
addEventListener
(
"
click
"
this
)
;
this
.
addEventListener
(
"
click
"
this
true
)
;
this
.
addEventListener
(
"
keydown
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
addEventListener
(
"
mouseleave
"
this
)
;
this
.
addEventListener
(
"
focusin
"
this
)
;
this
.
addEventListener
(
"
focusout
"
this
)
;
this
.
addEventListener
(
"
contextmenu
"
this
)
;
this
.
addEventListener
(
"
dragstart
"
this
)
;
this
.
addEventListener
(
"
dragover
"
this
)
;
this
.
addEventListener
(
"
drop
"
this
)
;
this
.
addEventListener
(
"
dragend
"
this
)
;
this
.
addEventListener
(
"
dragleave
"
this
)
;
}
init
(
)
{
this
.
startupTime
=
Services
.
startup
.
getStartupInfo
(
)
.
start
.
getTime
(
)
;
this
.
arrowScrollbox
=
document
.
getElementById
(
"
tabbrowser
-
arrowscrollbox
"
)
;
this
.
arrowScrollbox
.
addEventListener
(
"
wheel
"
this
true
)
;
this
.
arrowScrollbox
.
addEventListener
(
"
underflow
"
this
)
;
this
.
arrowScrollbox
.
addEventListener
(
"
overflow
"
this
)
;
this
.
pinnedTabsContainer
=
document
.
getElementById
(
"
pinned
-
tabs
-
container
"
)
;
this
.
arrowScrollbox
.
_getScrollableElements
=
(
)
=
>
{
return
this
.
ariaFocusableItems
.
reduce
(
(
elements
item
)
=
>
{
if
(
this
.
arrowScrollbox
.
_canScrollToElement
(
item
)
)
{
elements
.
push
(
item
)
;
if
(
isTab
(
item
)
&
&
item
.
group
&
&
item
.
group
.
collapsed
&
&
item
.
selected
)
{
elements
.
push
(
item
.
group
.
overflowContainer
)
;
}
}
return
elements
;
}
[
]
)
;
}
;
this
.
arrowScrollbox
.
_canScrollToElement
=
element
=
>
{
if
(
isTab
(
element
)
)
{
return
!
element
.
pinned
;
}
return
true
;
}
;
Object
.
defineProperty
(
this
.
arrowScrollbox
"
lineScrollAmount
"
{
get
:
(
)
=
>
this
.
verticalMode
?
this
.
#
tabMinHeight
:
this
.
_tabMinWidthPref
}
)
;
this
.
baseConnect
(
)
;
this
.
_blockDblClick
=
false
;
this
.
_closeButtonsUpdatePending
=
false
;
this
.
_closingTabsSpacer
=
this
.
querySelector
(
"
.
closing
-
tabs
-
spacer
"
)
;
this
.
_tabDefaultMaxWidth
=
NaN
;
this
.
_lastTabClosedByMouse
=
false
;
this
.
_hasTabTempMaxWidth
=
false
;
this
.
_scrollButtonWidth
=
0
;
this
.
_animateElement
=
this
.
arrowScrollbox
;
this
.
_tabClipWidth
=
Services
.
prefs
.
getIntPref
(
"
browser
.
tabs
.
tabClipWidth
"
)
;
this
.
_hiddenSoundPlayingTabs
=
new
Set
(
)
;
this
.
previewPanel
=
null
;
this
.
allTabs
[
0
]
.
label
=
this
.
emptyTabTitle
;
const
language
=
Services
.
locale
.
appLocaleAsBCP47
;
const
unsupportedLocales
=
Services
.
prefs
.
getCharPref
(
"
browser
.
tabs
.
secondaryTextUnsupportedLocales
"
)
;
this
.
toggleAttribute
(
"
secondarytext
-
unsupported
"
unsupportedLocales
.
split
(
"
"
)
.
includes
(
language
.
split
(
"
-
"
)
[
0
]
)
)
;
this
.
newTabButton
.
setAttribute
(
"
aria
-
label
"
DynamicShortcutTooltip
.
getText
(
"
tabs
-
newtab
-
button
"
)
)
;
let
handleResize
=
(
)
=
>
{
this
.
_updateCloseButtons
(
)
;
this
.
_handleTabSelect
(
true
)
;
}
;
window
.
addEventListener
(
"
resize
"
handleResize
)
;
this
.
_fullscreenMutationObserver
=
new
MutationObserver
(
handleResize
)
;
this
.
_fullscreenMutationObserver
.
observe
(
document
.
documentElement
{
attributeFilter
:
[
"
inFullscreen
"
"
inDOMFullscreen
"
]
}
)
;
this
.
boundObserve
=
(
.
.
.
args
)
=
>
this
.
observe
(
.
.
.
args
)
;
Services
.
prefs
.
addObserver
(
"
privacy
.
userContext
"
this
.
boundObserve
)
;
this
.
observe
(
null
"
nsPref
:
changed
"
"
privacy
.
userContext
.
enabled
"
)
;
document
.
getElementById
(
"
vertical
-
tabs
-
newtab
-
button
"
)
.
addEventListener
(
"
keypress
"
this
)
;
document
.
getElementById
(
"
tabs
-
newtab
-
button
"
)
.
addEventListener
(
"
keypress
"
this
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_tabMinWidthPref
"
"
browser
.
tabs
.
tabMinWidth
"
null
(
pref
prevValue
newValue
)
=
>
this
.
#
updateTabMinWidth
(
newValue
)
newValue
=
>
{
const
LIMIT
=
50
;
return
Math
.
max
(
newValue
LIMIT
)
;
}
)
;
this
.
#
updateTabMinWidth
(
this
.
_tabMinWidthPref
)
;
this
.
#
updateTabMinHeight
(
)
;
CustomizableUI
.
addListener
(
this
)
;
this
.
_updateNewTabVisibility
(
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_closeTabByDblclick
"
"
browser
.
tabs
.
closeTabByDblclick
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_sidebarVisibility
"
"
sidebar
.
visibility
"
"
always
-
show
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_sidebarPositionStart
"
"
sidebar
.
position_start
"
true
)
;
if
(
gMultiProcessBrowser
)
{
this
.
tabbox
.
tabpanels
.
setAttribute
(
"
async
"
"
true
"
)
;
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_showTabHoverPreview
"
"
browser
.
tabs
.
hoverPreview
.
enabled
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_showTabGroupHoverPreview
"
"
browser
.
tabs
.
groups
.
hoverPreview
.
enabled
"
false
)
;
this
.
tooltip
=
"
tabbrowser
-
tab
-
tooltip
"
;
this
.
tabDragAndDrop
=
new
window
.
TabDragAndDrop
(
this
)
;
this
.
tabDragAndDrop
.
init
(
)
;
}
attributeChangedCallback
(
name
oldValue
newValue
)
{
if
(
name
!
=
"
orient
"
)
{
return
;
}
if
(
this
.
overflowing
)
{
this
.
removeAttribute
(
"
overflow
"
)
;
}
this
.
#
updateTabMinWidth
(
)
;
this
.
#
updateTabMinHeight
(
)
;
this
.
pinnedTabsContainer
.
setAttribute
(
"
orient
"
newValue
)
;
super
.
attributeChangedCallback
(
name
oldValue
newValue
)
;
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
mouseout
"
:
{
let
relatedTarget
=
aEvent
.
relatedTarget
;
if
(
relatedTarget
&
&
relatedTarget
.
ownerDocument
=
=
document
)
{
break
;
}
}
case
"
mousemove
"
:
if
(
document
.
getElementById
(
"
tabContextMenu
"
)
.
state
!
=
"
open
"
&
&
!
this
.
#
isMovingTab
(
)
)
{
this
.
_unlockTabSizing
(
)
;
}
break
;
case
"
mouseleave
"
:
this
.
previewPanel
?
.
deactivate
(
)
;
break
;
default
:
{
let
methodName
=
on_
{
aEvent
.
type
}
;
if
(
methodName
in
this
)
{
this
[
methodName
]
(
aEvent
)
;
}
else
{
throw
new
Error
(
Unexpected
event
{
aEvent
.
type
}
)
;
}
}
}
}
on_TabSelect
(
event
)
{
const
{
target
:
newTab
detail
:
{
previousTab
}
}
=
event
;
if
(
previousTab
.
group
?
.
collapsed
|
|
newTab
.
group
?
.
collapsed
)
{
this
.
_invalidateCachedVisibleTabs
(
)
;
}
this
.
_handleTabSelect
(
)
;
}
on_TabClose
(
event
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
{
closed
:
true
}
)
;
}
on_TabAttrModified
(
event
)
{
if
(
event
.
detail
.
changed
.
includes
(
"
soundplaying
"
)
&
&
!
event
.
target
.
visible
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
if
(
event
.
detail
.
changed
.
includes
(
"
soundplaying
"
)
|
|
event
.
detail
.
changed
.
includes
(
"
muted
"
)
|
|
event
.
detail
.
changed
.
includes
(
"
activemedia
-
blocked
"
)
)
{
this
.
updateTabSoundLabel
(
event
.
target
)
;
}
}
on_TabHide
(
event
)
{
if
(
event
.
target
.
soundPlaying
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
}
on_TabShow
(
event
)
{
if
(
event
.
target
.
soundPlaying
)
{
this
.
_hiddenSoundPlayingStatusChanged
(
event
.
target
)
;
}
}
on_TabHoverStart
(
event
)
{
if
(
!
this
.
_showTabHoverPreview
)
{
return
;
}
this
.
ensureTabPreviewPanelLoaded
(
)
;
this
.
previewPanel
.
activate
(
event
.
target
)
;
}
on_TabHoverEnd
(
event
)
{
this
.
previewPanel
?
.
deactivate
(
event
.
target
)
;
}
on_TabGroupLabelHoverStart
(
event
)
{
if
(
!
this
.
_showTabGroupHoverPreview
)
{
return
;
}
this
.
ensureTabPreviewPanelLoaded
(
)
;
this
.
previewPanel
.
activate
(
event
.
target
.
group
)
;
}
on_TabGroupLabelHoverEnd
(
event
)
{
this
.
previewPanel
?
.
deactivate
(
event
.
target
.
group
)
;
}
on_TabGroupExpand
(
)
{
this
.
_invalidateCachedVisibleTabs
(
)
;
}
on_TabGroupCollapse
(
)
{
this
.
_invalidateCachedVisibleTabs
(
)
;
this
.
_unlockTabSizing
(
)
;
}
on_TabGroupCreate
(
)
{
this
.
_invalidateCachedTabs
(
)
;
}
on_TabGroupRemoved
(
)
{
this
.
_invalidateCachedTabs
(
)
;
}
on_transitionend
(
event
)
{
if
(
event
.
propertyName
!
=
"
max
-
width
"
)
{
return
;
}
let
tab
=
event
.
target
?
.
closest
(
"
tab
"
)
;
if
(
!
tab
)
{
return
;
}
if
(
tab
.
hasAttribute
(
"
fadein
"
)
)
{
if
(
tab
.
_fullyOpen
)
{
this
.
_updateCloseButtons
(
)
;
}
else
{
this
.
_handleNewTab
(
tab
)
;
}
}
else
if
(
tab
.
closing
)
{
gBrowser
.
_endRemoveTab
(
tab
)
;
}
let
evt
=
new
CustomEvent
(
"
TabAnimationEnd
"
{
bubbles
:
true
}
)
;
tab
.
dispatchEvent
(
evt
)
;
}
on_dblclick
(
event
)
{
if
(
CustomTitlebar
.
enabled
&
&
!
this
.
verticalMode
)
{
return
;
}
if
(
event
.
button
!
=
0
|
|
event
.
target
!
=
this
.
arrowScrollbox
|
|
event
.
composedTarget
.
localName
=
=
"
toolbarbutton
"
)
{
return
;
}
if
(
!
this
.
_blockDblClick
)
{
BrowserCommands
.
openTab
(
)
;
}
event
.
preventDefault
(
)
;
}
on_click
(
event
)
{
if
(
event
.
eventPhase
=
=
Event
.
CAPTURING_PHASE
&
&
event
.
button
=
=
0
)
{
let
target
=
event
.
originalTarget
;
if
(
target
.
classList
.
contains
(
"
tab
-
close
-
button
"
)
)
{
if
(
this
.
_blockDblClick
)
{
target
.
_ignoredCloseButtonClicks
=
true
;
}
else
if
(
event
.
detail
>
1
&
&
!
target
.
_ignoredCloseButtonClicks
)
{
target
.
_ignoredCloseButtonClicks
=
true
;
event
.
stopPropagation
(
)
;
return
;
}
else
{
target
.
_ignoredCloseButtonClicks
=
false
;
}
}
if
(
this
.
_blockDblClick
)
{
if
(
!
(
"
_clickedTabBarOnce
"
in
this
)
)
{
this
.
_clickedTabBarOnce
=
true
;
return
;
}
delete
this
.
_clickedTabBarOnce
;
this
.
_blockDblClick
=
false
;
}
}
else
if
(
event
.
eventPhase
=
=
Event
.
BUBBLING_PHASE
&
&
event
.
button
=
=
1
)
{
let
tab
=
event
.
target
?
.
closest
(
"
tab
"
)
;
if
(
tab
)
{
if
(
tab
.
multiselected
)
{
gBrowser
.
removeMultiSelectedTabs
(
)
;
}
else
{
gBrowser
.
removeTab
(
tab
{
animate
:
true
triggeringEvent
:
event
}
)
;
}
}
else
if
(
isTabGroupLabel
(
event
.
target
)
)
{
event
.
target
.
group
.
saveAndClose
(
)
;
}
else
if
(
event
.
originalTarget
.
closest
(
"
scrollbox
"
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
widget
.
gtk
.
titlebar
-
action
-
middle
-
click
-
enabled
"
)
)
{
let
visibleTabs
=
this
.
visibleTabs
;
let
lastTab
=
visibleTabs
.
at
(
-
1
)
;
let
winUtils
=
window
.
windowUtils
;
let
endOfTab
=
winUtils
.
getBoundsWithoutFlushing
(
lastTab
)
[
(
this
.
verticalMode
&
&
"
bottom
"
)
|
|
(
this
.
#
rtlMode
?
"
left
"
:
"
right
"
)
]
;
if
(
(
this
.
verticalMode
&
&
event
.
clientY
>
endOfTab
)
|
|
(
!
this
.
verticalMode
&
&
(
this
.
#
rtlMode
?
event
.
clientX
<
endOfTab
:
event
.
clientX
>
endOfTab
)
)
)
{
BrowserCommands
.
openTab
(
)
;
}
}
else
{
return
;
}
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
on_keydown
(
event
)
{
let
{
altKey
shiftKey
}
=
event
;
let
[
accel
nonAccel
]
=
AppConstants
.
platform
=
=
"
macosx
"
?
[
event
.
metaKey
event
.
ctrlKey
]
:
[
event
.
ctrlKey
event
.
metaKey
]
;
let
keyComboForFocusedElement
=
!
accel
&
&
!
shiftKey
&
&
!
altKey
&
&
!
nonAccel
;
let
keyComboForMove
=
accel
&
&
shiftKey
&
&
!
altKey
&
&
!
nonAccel
;
let
keyComboForFocus
=
accel
&
&
!
shiftKey
&
&
!
altKey
&
&
!
nonAccel
;
if
(
!
keyComboForFocusedElement
&
&
!
keyComboForMove
&
&
!
keyComboForFocus
)
{
return
;
}
if
(
keyComboForFocusedElement
)
{
let
ariaFocusedItem
=
this
.
ariaFocusedItem
;
if
(
isTabGroupLabel
(
ariaFocusedItem
)
)
{
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_SPACE
:
case
KeyEvent
.
DOM_VK_RETURN
:
{
ariaFocusedItem
.
click
(
)
;
event
.
preventDefault
(
)
;
}
}
}
}
else
if
(
keyComboForMove
)
{
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_UP
:
gBrowser
.
moveTabBackward
(
)
;
break
;
case
KeyEvent
.
DOM_VK_DOWN
:
gBrowser
.
moveTabForward
(
)
;
break
;
case
KeyEvent
.
DOM_VK_RIGHT
:
if
(
RTL_UI
)
{
gBrowser
.
moveTabBackward
(
)
;
}
else
{
gBrowser
.
moveTabForward
(
)
;
}
break
;
case
KeyEvent
.
DOM_VK_LEFT
:
if
(
RTL_UI
)
{
gBrowser
.
moveTabForward
(
)
;
}
else
{
gBrowser
.
moveTabBackward
(
)
;
}
break
;
case
KeyEvent
.
DOM_VK_HOME
:
gBrowser
.
moveTabToStart
(
)
;
break
;
case
KeyEvent
.
DOM_VK_END
:
gBrowser
.
moveTabToEnd
(
)
;
break
;
default
:
return
;
}
event
.
preventDefault
(
)
;
}
else
if
(
keyComboForFocus
)
{
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_UP
:
this
.
#
advanceFocus
(
DIRECTION_BACKWARD
)
;
break
;
case
KeyEvent
.
DOM_VK_DOWN
:
this
.
#
advanceFocus
(
DIRECTION_FORWARD
)
;
break
;
case
KeyEvent
.
DOM_VK_RIGHT
:
if
(
RTL_UI
)
{
this
.
#
advanceFocus
(
DIRECTION_BACKWARD
)
;
}
else
{
this
.
#
advanceFocus
(
DIRECTION_FORWARD
)
;
}
break
;
case
KeyEvent
.
DOM_VK_LEFT
:
if
(
RTL_UI
)
{
this
.
#
advanceFocus
(
DIRECTION_FORWARD
)
;
}
else
{
this
.
#
advanceFocus
(
DIRECTION_BACKWARD
)
;
}
break
;
case
KeyEvent
.
DOM_VK_HOME
:
this
.
ariaFocusedItem
=
this
.
ariaFocusableItems
.
at
(
0
)
;
break
;
case
KeyEvent
.
DOM_VK_END
:
this
.
ariaFocusedItem
=
this
.
ariaFocusableItems
.
at
(
-
1
)
;
break
;
case
KeyEvent
.
DOM_VK_SPACE
:
{
let
ariaFocusedItem
=
this
.
ariaFocusedItem
;
if
(
isTab
(
ariaFocusedItem
)
)
{
if
(
ariaFocusedItem
.
multiselected
)
{
gBrowser
.
removeFromMultiSelectedTabs
(
ariaFocusedItem
)
;
}
else
{
gBrowser
.
addToMultiSelectedTabs
(
ariaFocusedItem
)
;
}
}
break
;
}
default
:
return
;
}
event
.
preventDefault
(
)
;
}
}
on_focusin
(
event
)
{
if
(
event
.
target
=
=
this
.
selectedItem
)
{
this
.
tablistHasFocus
=
true
;
if
(
!
this
.
ariaFocusedItem
)
{
this
.
ariaFocusedItem
=
this
.
selectedItem
;
}
}
}
on_focusout
(
event
)
{
if
(
event
.
target
=
=
this
.
selectedItem
)
{
this
.
tablistHasFocus
=
false
;
}
}
on_keypress
(
event
)
{
if
(
event
.
defaultPrevented
)
{
return
;
}
if
(
event
.
key
=
=
"
"
|
|
event
.
key
=
=
"
Enter
"
)
{
event
.
preventDefault
(
)
;
event
.
target
.
click
(
)
;
}
}
on_dragstart
(
event
)
{
this
.
tabDragAndDrop
.
handle_dragstart
(
event
)
;
}
on_dragover
(
event
)
{
this
.
tabDragAndDrop
.
handle_dragover
(
event
)
;
}
on_drop
(
event
)
{
this
.
tabDragAndDrop
.
handle_drop
(
event
)
;
}
on_dragend
(
event
)
{
this
.
tabDragAndDrop
.
handle_dragend
(
event
)
;
}
on_dragleave
(
event
)
{
this
.
tabDragAndDrop
.
handle_dragleave
(
event
)
;
}
on_wheel
(
event
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
tabbox
.
switchByScrolling
"
false
)
)
{
event
.
stopImmediatePropagation
(
)
;
}
}
on_overflow
(
event
)
{
if
(
event
.
target
!
=
this
.
arrowScrollbox
)
{
return
;
}
this
.
toggleAttribute
(
"
overflow
"
true
)
;
this
.
_updateCloseButtons
(
)
;
this
.
_handleTabSelect
(
true
)
;
document
.
getElementById
(
"
tab
-
preview
-
panel
"
)
?
.
setAttribute
(
"
rolluponmousewheel
"
true
)
;
}
on_underflow
(
event
)
{
if
(
event
.
target
!
=
this
.
arrowScrollbox
|
|
!
this
.
overflowing
)
{
return
;
}
this
.
removeAttribute
(
"
overflow
"
)
;
if
(
this
.
_lastTabClosedByMouse
)
{
this
.
_expandSpacerBy
(
this
.
_scrollButtonWidth
)
;
}
for
(
let
tab
of
gBrowser
.
_removingTabs
)
{
gBrowser
.
removeTab
(
tab
)
;
}
this
.
_updateCloseButtons
(
)
;
document
.
getElementById
(
"
tab
-
preview
-
panel
"
)
?
.
removeAttribute
(
"
rolluponmousewheel
"
)
;
}
on_contextmenu
(
event
)
{
if
(
event
.
button
=
=
0
&
&
isTabGroupLabel
(
this
.
ariaFocusedItem
)
)
{
gBrowser
.
tabGroupMenu
.
openEditModal
(
this
.
ariaFocusedItem
.
group
)
;
event
.
preventDefault
(
)
;
}
}
get
emptyTabTitle
(
)
{
const
l10nId
=
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
privatebrowsing
.
autostart
"
)
?
"
tabbrowser
-
empty
-
private
-
tab
-
title
"
:
"
tabbrowser
-
empty
-
tab
-
title
"
;
return
gBrowser
.
tabLocalization
.
formatValueSync
(
l10nId
)
;
}
get
tabbox
(
)
{
return
document
.
getElementById
(
"
tabbrowser
-
tabbox
"
)
;
}
get
newTabButton
(
)
{
return
this
.
querySelector
(
"
#
tabs
-
newtab
-
button
"
)
;
}
get
verticalMode
(
)
{
return
this
.
getAttribute
(
"
orient
"
)
=
=
"
vertical
"
;
}
get
expandOnHover
(
)
{
return
this
.
_sidebarVisibility
=
=
"
expand
-
on
-
hover
"
;
}
get
#
rtlMode
(
)
{
return
!
this
.
verticalMode
&
&
RTL_UI
;
}
get
overflowing
(
)
{
return
this
.
hasAttribute
(
"
overflow
"
)
;
}
#
allTabs
;
get
allTabs
(
)
{
if
(
this
.
#
allTabs
)
{
return
this
.
#
allTabs
;
}
let
pinnedChildren
=
Array
.
from
(
this
.
pinnedTabsContainer
.
children
)
;
if
(
pinnedChildren
?
.
at
(
-
1
)
?
.
id
=
=
"
pinned
-
tabs
-
container
-
periphery
"
)
{
pinnedChildren
.
pop
(
)
;
}
let
unpinnedChildren
=
Array
.
from
(
this
.
arrowScrollbox
.
children
)
;
unpinnedChildren
.
pop
(
)
;
for
(
let
i
=
unpinnedChildren
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
unpinnedChildren
[
i
]
.
tagName
=
=
"
tab
-
group
"
|
|
unpinnedChildren
[
i
]
.
tagName
=
=
"
tab
-
split
-
view
-
wrapper
"
)
{
unpinnedChildren
.
splice
(
i
1
.
.
.
unpinnedChildren
[
i
]
.
tabs
)
;
}
}
this
.
#
allTabs
=
[
.
.
.
pinnedChildren
.
.
.
unpinnedChildren
]
;
return
this
.
#
allTabs
;
}
get
allGroups
(
)
{
let
children
=
Array
.
from
(
this
.
arrowScrollbox
.
children
)
;
return
children
.
filter
(
node
=
>
node
.
tagName
=
=
"
tab
-
group
"
)
;
}
get
openTabs
(
)
{
if
(
!
this
.
#
openTabs
)
{
this
.
#
openTabs
=
this
.
allTabs
.
filter
(
tab
=
>
tab
.
isOpen
)
;
}
return
this
.
#
openTabs
;
}
#
openTabs
;
get
nonHiddenTabs
(
)
{
if
(
!
this
.
#
nonHiddenTabs
)
{
this
.
#
nonHiddenTabs
=
this
.
openTabs
.
filter
(
tab
=
>
!
tab
.
hidden
)
;
}
return
this
.
#
nonHiddenTabs
;
}
#
nonHiddenTabs
;
get
visibleTabs
(
)
{
if
(
!
this
.
#
visibleTabs
)
{
this
.
#
visibleTabs
=
this
.
openTabs
.
filter
(
tab
=
>
tab
.
visible
)
;
}
return
this
.
#
visibleTabs
;
}
#
visibleTabs
;
get
tablistHasFocus
(
)
{
return
this
.
hasAttribute
(
"
tablist
-
has
-
focus
"
)
;
}
set
tablistHasFocus
(
hasFocus
)
{
this
.
toggleAttribute
(
"
tablist
-
has
-
focus
"
hasFocus
)
;
}
#
focusableItems
;
get
ariaFocusableItems
(
)
{
if
(
this
.
#
focusableItems
)
{
return
this
.
#
focusableItems
;
}
let
elementIndex
=
0
;
let
unpinnedChildren
=
Array
.
from
(
this
.
arrowScrollbox
.
children
)
;
let
pinnedChildren
=
Array
.
from
(
this
.
pinnedTabsContainer
.
children
)
;
let
focusableItems
=
[
]
;
for
(
let
child
of
pinnedChildren
)
{
if
(
isTab
(
child
)
)
{
child
.
elementIndex
=
elementIndex
+
+
;
focusableItems
.
push
(
child
)
;
}
}
for
(
let
child
of
unpinnedChildren
)
{
if
(
isTab
(
child
)
&
&
child
.
visible
)
{
child
.
elementIndex
=
elementIndex
+
+
;
focusableItems
.
push
(
child
)
;
}
else
if
(
isTabGroup
(
child
)
)
{
child
.
labelElement
.
elementIndex
=
elementIndex
+
+
;
focusableItems
.
push
(
child
.
labelElement
)
;
let
visibleTabsInGroup
=
child
.
tabs
.
filter
(
tab
=
>
tab
.
visible
)
;
visibleTabsInGroup
.
forEach
(
tab
=
>
{
tab
.
elementIndex
=
elementIndex
+
+
;
}
)
;
focusableItems
.
push
(
.
.
.
visibleTabsInGroup
)
;
}
}
this
.
#
focusableItems
=
focusableItems
;
return
this
.
#
focusableItems
;
}
#
advanceFocus
(
direction
)
{
let
currentIndex
=
this
.
ariaFocusableItems
.
indexOf
(
this
.
ariaFocusedItem
)
;
let
newIndex
=
currentIndex
+
direction
;
newIndex
=
Math
.
min
(
this
.
ariaFocusableItems
.
length
-
1
Math
.
max
(
0
newIndex
)
)
;
let
itemToFocus
=
this
.
ariaFocusableItems
[
newIndex
]
;
this
.
ariaFocusedItem
=
itemToFocus
;
}
_invalidateCachedTabs
(
)
{
this
.
#
allTabs
=
null
;
this
.
_invalidateCachedVisibleTabs
(
)
;
}
_invalidateCachedVisibleTabs
(
)
{
this
.
#
openTabs
=
null
;
this
.
#
nonHiddenTabs
=
null
;
this
.
#
visibleTabs
=
null
;
this
.
#
focusableItems
=
null
;
}
#
isMovingTab
(
)
{
return
this
.
hasAttribute
(
"
movingtab
"
)
;
}
advanceSelectedItem
(
aDir
aWrap
)
{
let
{
ariaFocusableItems
ariaFocusedIndex
}
=
this
;
let
currentItemIndex
=
ariaFocusedIndex
>
=
0
?
ariaFocusedIndex
:
ariaFocusableItems
.
indexOf
(
this
.
selectedItem
)
;
let
newItemIndex
=
currentItemIndex
+
aDir
;
if
(
aWrap
)
{
if
(
newItemIndex
>
=
ariaFocusableItems
.
length
)
{
newItemIndex
=
0
;
}
else
if
(
newItemIndex
<
0
)
{
newItemIndex
=
ariaFocusableItems
.
length
-
1
;
}
}
else
{
newItemIndex
=
Math
.
min
(
ariaFocusableItems
.
length
-
1
Math
.
max
(
0
newItemIndex
)
)
;
}
if
(
currentItemIndex
=
=
newItemIndex
)
{
return
;
}
let
newItem
=
ariaFocusableItems
[
newItemIndex
]
;
if
(
isTab
(
newItem
)
)
{
this
.
_selectNewTab
(
newItem
aDir
aWrap
)
;
}
this
.
ariaFocusedItem
=
newItem
;
}
ensureTabPreviewPanelLoaded
(
)
{
if
(
!
this
.
previewPanel
)
{
const
TabHoverPanelSet
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
browser
/
content
/
tabbrowser
/
tab
-
hover
-
preview
.
mjs
"
)
.
default
;
this
.
previewPanel
=
new
TabHoverPanelSet
(
window
)
;
}
}
appendChild
(
tab
)
{
return
this
.
insertBefore
(
tab
null
)
;
}
insertBefore
(
tab
node
)
{
if
(
!
this
.
arrowScrollbox
)
{
throw
new
Error
(
"
Shouldn
'
t
call
this
without
arrowscrollbox
"
)
;
}
if
(
node
=
=
null
)
{
node
=
this
.
arrowScrollbox
.
lastChild
;
}
node
.
before
(
tab
)
;
if
(
this
.
#
mustUpdateTabMinHeight
)
{
this
.
#
updateTabMinHeight
(
)
;
}
}
#
updateTabMinWidth
(
val
)
{
this
.
style
.
setProperty
(
"
-
-
tab
-
min
-
width
-
pref
"
(
val
?
?
this
.
_tabMinWidthPref
)
+
"
px
"
)
;
}
#
updateTabMinHeight
(
)
{
if
(
!
this
.
verticalMode
|
|
!
window
.
toolbar
.
visible
)
{
this
.
#
mustUpdateTabMinHeight
=
false
;
return
;
}
let
firstScrollableTab
=
this
.
visibleTabs
.
find
(
this
.
arrowScrollbox
.
_canScrollToElement
)
;
if
(
!
firstScrollableTab
)
{
this
.
#
mustUpdateTabMinHeight
=
true
;
return
;
}
let
{
height
}
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
firstScrollableTab
)
;
this
.
#
tabMinHeight
=
height
|
|
36
;
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
height
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
firstScrollableTab
)
.
height
;
if
(
height
)
{
this
.
#
tabMinHeight
=
height
;
}
}
(
)
=
>
{
}
)
;
}
get
_isCustomizing
(
)
{
return
document
.
documentElement
.
hasAttribute
(
"
customizing
"
)
;
}
_selectNewTab
(
aNewTab
aFallbackDir
aWrap
)
{
if
(
!
gSharedTabWarning
.
willShowSharedTabWarning
(
aNewTab
)
)
{
super
.
_selectNewTab
(
aNewTab
aFallbackDir
aWrap
)
;
}
}
observe
(
aSubject
aTopic
)
{
switch
(
aTopic
)
{
case
"
nsPref
:
changed
"
:
{
let
containersEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
enabled
"
)
&
&
!
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
;
const
newTabLeftClickOpensContainersMenu
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
userContext
.
newTabContainerOnLeftClick
.
enabled
"
)
;
const
newTab
=
document
.
getElementById
(
"
new
-
tab
-
button
"
)
;
const
newTab2
=
this
.
newTabButton
;
const
newTabVertical
=
document
.
getElementById
(
"
vertical
-
tabs
-
newtab
-
button
"
)
;
for
(
let
parent
of
[
newTab
newTab2
newTabVertical
]
)
{
if
(
!
parent
)
{
continue
;
}
parent
.
removeAttribute
(
"
type
"
)
;
if
(
parent
.
menupopup
)
{
parent
.
menupopup
.
remove
(
)
;
}
if
(
containersEnabled
)
{
parent
.
setAttribute
(
"
context
"
"
new
-
tab
-
button
-
popup
"
)
;
let
popup
=
document
.
getElementById
(
"
new
-
tab
-
button
-
popup
"
)
.
cloneNode
(
true
)
;
popup
.
removeAttribute
(
"
id
"
)
;
popup
.
className
=
"
new
-
tab
-
popup
"
;
popup
.
setAttribute
(
"
position
"
"
after_end
"
)
;
popup
.
addEventListener
(
"
popupshowing
"
CreateContainerTabMenu
)
;
parent
.
prepend
(
popup
)
;
parent
.
setAttribute
(
"
type
"
"
menu
"
)
;
DynamicShortcutTooltip
.
nodeToTooltipMap
[
parent
.
id
]
=
newTabLeftClickOpensContainersMenu
?
"
newTabAlwaysContainer
.
tooltip
"
:
"
newTabContainer
.
tooltip
"
;
}
else
{
DynamicShortcutTooltip
.
nodeToTooltipMap
[
parent
.
id
]
=
"
newTabButton
.
tooltip
"
;
parent
.
removeAttribute
(
"
context
"
"
new
-
tab
-
button
-
popup
"
)
;
}
DynamicShortcutTooltip
.
cache
.
delete
(
parent
.
id
)
;
if
(
containersEnabled
&
&
!
newTabLeftClickOpensContainersMenu
)
{
gClickAndHoldListenersOnElement
.
add
(
parent
)
;
}
else
{
gClickAndHoldListenersOnElement
.
remove
(
parent
)
;
}
}
break
;
}
}
}
_updateCloseButtons
(
)
{
if
(
this
.
overflowing
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
return
;
}
if
(
this
.
_closeButtonsUpdatePending
)
{
return
;
}
this
.
_closeButtonsUpdatePending
=
true
;
window
.
requestAnimationFrame
(
(
)
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
this
.
_closeButtonsUpdatePending
=
false
;
if
(
this
.
overflowing
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
return
;
}
let
rect
=
ele
=
>
{
return
window
.
windowUtils
.
getBoundsWithoutFlushing
(
ele
)
;
}
;
let
tab
=
this
.
visibleTabs
[
gBrowser
.
pinnedTabCount
]
;
if
(
tab
&
&
rect
(
tab
)
.
width
<
=
this
.
_tabClipWidth
)
{
this
.
setAttribute
(
"
closebuttons
"
"
activetab
"
)
;
}
else
{
this
.
removeAttribute
(
"
closebuttons
"
)
;
}
}
)
;
}
)
;
}
_handleTabSelect
(
aInstant
)
{
let
selectedTab
=
this
.
selectedItem
;
this
.
#
ensureTabIsVisible
(
selectedTab
aInstant
)
;
selectedTab
.
_notselectedsinceload
=
false
;
}
#
ensureTabIsVisible
(
tab
shouldScrollInstantly
=
false
)
{
let
arrowScrollbox
=
tab
.
closest
(
"
arrowscrollbox
"
)
;
if
(
arrowScrollbox
?
.
overflowing
)
{
arrowScrollbox
.
ensureElementIsVisible
(
tab
shouldScrollInstantly
)
;
}
}
_lockTabSizing
(
aClosingTab
aTabWidth
)
{
if
(
this
.
verticalMode
)
{
return
;
}
let
tabs
=
this
.
visibleTabs
;
let
numPinned
=
gBrowser
.
pinnedTabCount
;
if
(
tabs
.
length
<
=
numPinned
)
{
return
;
}
let
isEndTab
=
aClosingTab
&
&
aClosingTab
.
_tPos
>
tabs
.
at
(
-
1
)
.
_tPos
;
if
(
!
this
.
_tabDefaultMaxWidth
)
{
this
.
_tabDefaultMaxWidth
=
parseFloat
(
window
.
getComputedStyle
(
tabs
[
numPinned
]
)
.
maxWidth
)
;
}
this
.
_lastTabClosedByMouse
=
true
;
this
.
_scrollButtonWidth
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
this
.
arrowScrollbox
.
_scrollButtonDown
)
.
width
;
if
(
aTabWidth
=
=
=
undefined
)
{
aTabWidth
=
window
.
windowUtils
.
getBoundsWithoutFlushing
(
tabs
[
numPinned
]
)
.
width
;
}
if
(
this
.
overflowing
)
{
if
(
isEndTab
|
|
!
this
.
arrowScrollbox
.
hasAttribute
(
"
scrolledtoend
"
)
)
{
return
;
}
if
(
aClosingTab
?
.
owner
)
{
return
;
}
this
.
_expandSpacerBy
(
aTabWidth
)
;
}
else
{
if
(
isEndTab
&
&
!
this
.
_hasTabTempMaxWidth
)
{
return
;
}
if
(
isEndTab
)
{
let
numNormalTabs
=
tabs
.
length
-
numPinned
;
aTabWidth
=
(
aTabWidth
*
(
numNormalTabs
+
1
)
)
/
numNormalTabs
;
if
(
aTabWidth
>
this
.
_tabDefaultMaxWidth
)
{
aTabWidth
=
this
.
_tabDefaultMaxWidth
;
}
}
aTabWidth
+
=
"
px
"
;
let
tabsToReset
=
[
]
;
for
(
let
i
=
numPinned
;
i
<
tabs
.
length
;
i
+
+
)
{
let
tab
=
tabs
[
i
]
;
tab
.
style
.
setProperty
(
"
max
-
width
"
aTabWidth
"
important
"
)
;
if
(
!
isEndTab
)
{
tab
.
style
.
transition
=
"
none
"
;
tabsToReset
.
push
(
tab
)
;
}
}
if
(
tabsToReset
.
length
)
{
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
for
(
let
tab
of
tabsToReset
)
{
tab
.
style
.
transition
=
"
"
;
}
}
)
;
}
)
;
}
this
.
_hasTabTempMaxWidth
=
true
;
gBrowser
.
addEventListener
(
"
mousemove
"
this
)
;
window
.
addEventListener
(
"
mouseout
"
this
)
;
}
}
_expandSpacerBy
(
pixels
)
{
let
spacer
=
this
.
_closingTabsSpacer
;
spacer
.
style
.
width
=
parseFloat
(
spacer
.
style
.
width
)
+
pixels
+
"
px
"
;
this
.
toggleAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
true
)
;
gBrowser
.
addEventListener
(
"
mousemove
"
this
)
;
window
.
addEventListener
(
"
mouseout
"
this
)
;
}
_unlockTabSizing
(
)
{
gBrowser
.
removeEventListener
(
"
mousemove
"
this
)
;
window
.
removeEventListener
(
"
mouseout
"
this
)
;
if
(
this
.
_hasTabTempMaxWidth
)
{
this
.
_hasTabTempMaxWidth
=
false
;
let
tabs
=
this
.
allTabs
;
for
(
let
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
tabs
[
i
]
.
style
.
maxWidth
=
"
"
;
}
}
if
(
this
.
hasAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
)
)
{
this
.
removeAttribute
(
"
using
-
closing
-
tabs
-
spacer
"
)
;
this
.
_closingTabsSpacer
.
style
.
width
=
0
;
}
}
uiDensityChanged
(
)
{
this
.
_updateCloseButtons
(
)
;
this
.
#
updateTabMinHeight
(
)
;
this
.
_handleTabSelect
(
true
)
;
}
_notifyBackgroundTab
(
aTab
)
{
if
(
aTab
.
pinned
|
|
!
aTab
.
visible
|
|
!
this
.
overflowing
)
{
return
;
}
this
.
_lastTabToScrollIntoView
=
aTab
;
if
(
!
this
.
_backgroundTabScrollPromise
)
{
this
.
_backgroundTabScrollPromise
=
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
lastTabRect
=
this
.
_lastTabToScrollIntoView
.
getBoundingClientRect
(
)
;
let
selectedTab
=
this
.
selectedItem
;
if
(
selectedTab
.
pinned
)
{
selectedTab
=
null
;
}
else
{
selectedTab
=
selectedTab
.
getBoundingClientRect
(
)
;
selectedTab
=
{
left
:
selectedTab
.
left
right
:
selectedTab
.
right
top
:
selectedTab
.
top
bottom
:
selectedTab
.
bottom
}
;
}
return
[
this
.
_lastTabToScrollIntoView
this
.
arrowScrollbox
.
scrollClientRect
lastTabRect
selectedTab
]
;
}
)
.
then
(
(
[
tabToScrollIntoView
scrollRect
tabRect
selectedRect
]
)
=
>
{
delete
this
.
_backgroundTabScrollPromise
;
if
(
this
.
_lastTabToScrollIntoView
!
=
tabToScrollIntoView
)
{
this
.
_notifyBackgroundTab
(
this
.
_lastTabToScrollIntoView
)
;
return
;
}
delete
this
.
_lastTabToScrollIntoView
;
if
(
this
.
verticalMode
?
scrollRect
.
top
<
=
tabRect
.
top
&
&
tabRect
.
bottom
<
=
scrollRect
.
bottom
:
scrollRect
.
left
<
=
tabRect
.
left
&
&
tabRect
.
right
<
=
scrollRect
.
right
)
{
return
;
}
if
(
this
.
arrowScrollbox
.
smoothScroll
)
{
if
(
!
selectedRect
|
|
(
this
.
verticalMode
?
Math
.
max
(
tabRect
.
bottom
-
selectedRect
.
top
selectedRect
.
bottom
-
tabRect
.
top
)
<
=
scrollRect
.
height
:
Math
.
max
(
tabRect
.
right
-
selectedRect
.
left
selectedRect
.
right
-
tabRect
.
left
)
<
=
scrollRect
.
width
)
)
{
this
.
#
ensureTabIsVisible
(
tabToScrollIntoView
)
;
return
;
}
let
scrollPixels
;
if
(
this
.
verticalMode
)
{
scrollPixels
=
tabRect
.
top
-
selectedRect
.
top
;
}
else
if
(
this
.
#
rtlMode
)
{
scrollPixels
=
selectedRect
.
right
-
scrollRect
.
right
;
}
else
{
scrollPixels
=
selectedRect
.
left
-
scrollRect
.
left
;
}
this
.
arrowScrollbox
.
scrollByPixels
(
scrollPixels
)
;
}
if
(
!
this
.
_animateElement
.
hasAttribute
(
"
highlight
"
)
)
{
this
.
_animateElement
.
toggleAttribute
(
"
highlight
"
true
)
;
setTimeout
(
function
(
ele
)
{
ele
.
removeAttribute
(
"
highlight
"
)
;
}
150
this
.
_animateElement
)
;
}
}
)
;
}
}
_handleNewTab
(
tab
)
{
if
(
tab
.
container
!
=
this
)
{
return
;
}
tab
.
_fullyOpen
=
true
;
gBrowser
.
tabAnimationsInProgress
-
-
;
this
.
_updateCloseButtons
(
)
;
if
(
tab
.
hasAttribute
(
"
selected
"
)
)
{
this
.
_handleTabSelect
(
)
;
}
else
if
(
!
tab
.
hasAttribute
(
"
skipbackgroundnotify
"
)
)
{
this
.
_notifyBackgroundTab
(
tab
)
;
}
if
(
tab
.
linkedPanel
)
{
NewTabPagePreloading
.
maybeCreatePreloadedBrowser
(
window
)
;
}
if
(
UserInteraction
.
running
(
"
browser
.
tabs
.
opening
"
window
)
)
{
UserInteraction
.
finish
(
"
browser
.
tabs
.
opening
"
window
)
;
}
}
_canAdvanceToTab
(
aTab
)
{
return
!
aTab
.
closing
;
}
getRelatedElement
(
aTab
)
{
if
(
!
aTab
)
{
return
null
;
}
if
(
!
gBrowser
.
_initialized
)
{
return
this
.
tabbox
.
tabpanels
.
firstElementChild
;
}
if
(
!
aTab
.
linkedPanel
)
{
if
(
!
aTab
.
selected
)
{
return
null
;
}
gBrowser
.
_insertBrowser
(
aTab
)
;
}
return
document
.
getElementById
(
aTab
.
linkedPanel
)
;
}
_updateNewTabVisibility
(
)
{
let
wrap
=
n
=
>
n
.
parentNode
.
localName
=
=
"
toolbarpaletteitem
"
?
n
.
parentNode
:
n
;
let
unwrap
=
n
=
>
n
&
&
n
.
localName
=
=
"
toolbarpaletteitem
"
?
n
.
firstElementChild
:
n
;
let
sib
=
this
;
do
{
sib
=
unwrap
(
wrap
(
sib
)
.
nextElementSibling
)
;
}
while
(
sib
&
&
(
sib
.
hidden
|
|
sib
.
id
=
=
"
alltabs
-
button
"
)
)
;
this
.
toggleAttribute
(
"
hasadjacentnewtabbutton
"
sib
&
&
sib
.
id
=
=
"
new
-
tab
-
button
"
)
;
}
onWidgetAfterDOMChange
(
aNode
aNextNode
aContainer
)
{
if
(
aContainer
.
ownerDocument
=
=
document
&
&
aContainer
.
id
=
=
"
TabsToolbar
-
customization
-
target
"
)
{
this
.
_updateNewTabVisibility
(
)
;
}
}
onAreaNodeRegistered
(
aArea
aContainer
)
{
if
(
aContainer
.
ownerDocument
=
=
document
&
&
aArea
=
=
"
TabsToolbar
"
)
{
this
.
_updateNewTabVisibility
(
)
;
}
}
onAreaReset
(
aArea
aContainer
)
{
this
.
onAreaNodeRegistered
(
aArea
aContainer
)
;
}
_hiddenSoundPlayingStatusChanged
(
tab
opts
)
{
let
closed
=
opts
&
&
opts
.
closed
;
if
(
!
closed
&
&
tab
.
soundPlaying
&
&
!
tab
.
visible
)
{
this
.
_hiddenSoundPlayingTabs
.
add
(
tab
)
;
this
.
toggleAttribute
(
"
hiddensoundplaying
"
true
)
;
}
else
{
this
.
_hiddenSoundPlayingTabs
.
delete
(
tab
)
;
if
(
this
.
_hiddenSoundPlayingTabs
.
size
=
=
0
)
{
this
.
removeAttribute
(
"
hiddensoundplaying
"
)
;
}
}
}
destroy
(
)
{
if
(
this
.
boundObserve
)
{
Services
.
prefs
.
removeObserver
(
"
privacy
.
userContext
"
this
.
boundObserve
)
;
}
CustomizableUI
.
removeListener
(
this
)
;
}
updateTabSoundLabel
(
tab
)
{
const
[
unmute
mute
unblock
]
=
gBrowser
.
tabLocalization
.
formatMessagesSync
(
[
"
tabbrowser
-
unmute
-
tab
-
audio
-
aria
-
label
"
"
tabbrowser
-
mute
-
tab
-
audio
-
aria
-
label
"
"
tabbrowser
-
unblock
-
tab
-
audio
-
aria
-
label
"
]
)
;
if
(
tab
.
audioButton
)
{
if
(
tab
.
hasAttribute
(
"
muted
"
)
|
|
tab
.
hasAttribute
(
"
soundplaying
"
)
)
{
let
ariaLabel
;
tab
.
linkedBrowser
.
audioMuted
?
(
ariaLabel
=
unmute
.
attributes
[
0
]
.
value
)
:
(
ariaLabel
=
mute
.
attributes
[
0
]
.
value
)
;
tab
.
audioButton
.
setAttribute
(
"
aria
-
label
"
ariaLabel
)
;
}
else
if
(
tab
.
hasAttribute
(
"
activemedia
-
blocked
"
)
)
{
tab
.
audioButton
.
setAttribute
(
"
aria
-
label
"
unblock
.
attributes
[
0
]
.
value
)
;
}
}
}
}
customElements
.
define
(
"
tabbrowser
-
tabs
"
MozTabbrowserTabs
{
extends
:
"
tabs
"
}
)
;
}
