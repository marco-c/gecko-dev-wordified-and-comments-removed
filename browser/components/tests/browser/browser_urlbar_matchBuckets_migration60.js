const
PREF_NAME
=
"
browser
.
urlbar
.
matchBuckets
"
;
const
PREF_VALUE_SUGGESTIONS_FIRST
=
"
suggestion
:
4
general
:
5
"
;
const
PREF_VALUE_GENERAL_FIRST
=
"
general
:
5
suggestion
:
Infinity
"
;
const
STUDY_NAME
=
"
pref
-
flip
-
search
-
composition
-
57
-
release
-
1413565
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
PreferenceExperiments
.
jsm
"
this
)
;
add_task
(
async
function
migrate
(
)
{
await
sanityCheckInitialState
(
)
;
await
promiseMigration
(
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
PREF_VALUE_GENERAL_FIRST
"
Pref
should
be
set
general
first
"
)
;
Assert
.
ok
(
Services
.
prefs
.
prefHasUserValue
(
PREF_NAME
)
"
Pref
should
be
set
on
user
branch
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_NAME
)
;
}
)
;
add_task
(
async
function
setUserPrefAndMigrate
(
)
{
await
sanityCheckInitialState
(
)
;
let
userValue
=
"
userTest
:
10
"
;
Services
.
prefs
.
setCharPref
(
PREF_NAME
userValue
)
;
await
promiseMigration
(
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
userValue
"
Pref
should
remain
same
"
)
;
Assert
.
ok
(
Services
.
prefs
.
prefHasUserValue
(
PREF_NAME
)
"
Pref
should
remain
on
user
branch
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_NAME
)
;
}
)
;
add_task
(
async
function
setDefaultPrefAndMigrate
(
)
{
await
sanityCheckInitialState
(
)
;
let
defaultValue
=
"
defaultTest
:
10
"
;
Services
.
prefs
.
getDefaultBranch
(
PREF_NAME
)
.
setCharPref
(
"
"
defaultValue
)
;
await
promiseMigration
(
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
defaultValue
"
Pref
should
remain
same
"
)
;
Assert
.
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
PREF_NAME
)
"
Pref
should
remain
on
default
branch
"
)
;
Services
.
prefs
.
deleteBranch
(
PREF_NAME
)
;
}
)
;
add_task
(
async
function
installStudyAndMigrate
(
)
{
await
sanityCheckInitialState
(
)
;
Services
.
prefs
.
getDefaultBranch
(
PREF_NAME
)
.
setCharPref
(
"
"
"
"
)
;
await
PreferenceExperiments
.
start
(
newExperimentOpts
(
)
)
;
Assert
.
ok
(
await
PreferenceExperiments
.
has
(
STUDY_NAME
)
"
Study
installed
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
PREF_VALUE_SUGGESTIONS_FIRST
"
Pref
should
be
set
by
study
"
)
;
await
promiseMigration
(
)
;
Assert
.
ok
(
!
(
await
getNonExpiredExperiment
(
)
)
"
Study
stopped
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
"
"
"
Pref
should
be
cleared
"
)
;
await
PreferenceExperiments
.
clearAllExperimentStorage
(
)
;
}
)
;
add_task
(
async
function
installStudyPrefWithSpacesAndMigrate
(
)
{
await
sanityCheckInitialState
(
)
;
const
preferenceValue
=
"
suggestion
:
4
general
:
5
"
;
const
experiment
=
newExperimentOpts
(
{
preferences
:
{
[
PREF_NAME
]
:
{
preferenceValue
}
}
}
)
;
await
PreferenceExperiments
.
start
(
experiment
)
;
Assert
.
ok
(
await
PreferenceExperiments
.
has
(
STUDY_NAME
)
"
Study
installed
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
preferenceValue
"
Pref
should
be
set
by
study
"
)
;
await
promiseMigration
(
)
;
Assert
.
ok
(
!
(
await
getNonExpiredExperiment
(
)
)
"
Study
stopped
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
"
"
"
Pref
should
be
cleared
"
)
;
await
PreferenceExperiments
.
clearAllExperimentStorage
(
)
;
}
)
;
add_task
(
async
function
installStudyMinorityPrefAndMigrate
(
)
{
await
sanityCheckInitialState
(
)
;
let
preferenceValue
=
"
general
:
3
suggestion
:
6
"
;
const
experiment
=
newExperimentOpts
(
{
preferences
:
{
[
PREF_NAME
]
:
{
preferenceValue
}
}
}
)
;
await
PreferenceExperiments
.
start
(
experiment
)
;
Assert
.
ok
(
await
PreferenceExperiments
.
has
(
STUDY_NAME
)
"
Study
installed
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
preferenceValue
"
Pref
should
be
set
by
study
"
)
;
await
promiseMigration
(
)
;
Assert
.
ok
(
!
(
await
getNonExpiredExperiment
(
)
)
"
Study
stopped
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
preferenceValue
"
Pref
should
remain
the
same
"
)
;
Assert
.
ok
(
Services
.
prefs
.
prefHasUserValue
(
PREF_NAME
)
"
Pref
should
be
set
on
user
branch
"
)
;
await
PreferenceExperiments
.
clearAllExperimentStorage
(
)
;
Services
.
prefs
.
clearUserPref
(
PREF_NAME
)
;
}
)
;
add_task
(
async
function
setDefaultPrefInstallStudyAndMigrate
(
)
{
await
sanityCheckInitialState
(
)
;
let
defaultValue
=
"
test
:
10
"
;
Services
.
prefs
.
getDefaultBranch
(
PREF_NAME
)
.
setCharPref
(
"
"
defaultValue
)
;
await
PreferenceExperiments
.
start
(
newExperimentOpts
(
)
)
;
Assert
.
ok
(
await
PreferenceExperiments
.
has
(
STUDY_NAME
)
"
Study
installed
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
PREF_VALUE_SUGGESTIONS_FIRST
"
Pref
should
be
set
by
study
"
)
;
await
promiseMigration
(
)
;
Assert
.
ok
(
!
(
await
getNonExpiredExperiment
(
)
)
"
Study
stopped
"
)
;
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
defaultValue
"
Pref
should
be
restored
to
user
value
"
)
;
await
PreferenceExperiments
.
clearAllExperimentStorage
(
)
;
Services
.
prefs
.
deleteBranch
(
PREF_NAME
)
;
}
)
;
async
function
sanityCheckInitialState
(
)
{
Assert
.
equal
(
Services
.
prefs
.
getCharPref
(
PREF_NAME
"
"
)
"
"
"
Pref
should
be
cleared
initially
"
)
;
Assert
.
ok
(
!
(
await
PreferenceExperiments
.
has
(
STUDY_NAME
)
)
"
Study
should
not
be
installed
initially
"
)
;
}
function
promiseMigration
(
)
{
let
topic
=
"
browser
-
glue
-
test
"
;
let
donePromise
=
TestUtils
.
topicObserved
(
topic
(
subj
data
)
=
>
{
return
"
migrateMatchBucketsPrefForUI66
-
done
"
=
=
data
;
}
)
;
Cc
[
"
mozilla
.
org
/
browser
/
browserglue
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
observe
(
null
topic
"
migrateMatchBucketsPrefForUI66
"
)
;
return
donePromise
;
}
function
newExperimentOpts
(
opts
=
{
}
)
{
const
defaultPref
=
{
[
PREF_NAME
]
:
{
}
}
;
const
defaultPrefInfo
=
{
preferenceValue
:
PREF_VALUE_SUGGESTIONS_FIRST
preferenceBranchType
:
"
default
"
preferenceType
:
"
string
"
}
;
const
preferences
=
{
}
;
for
(
const
[
prefName
prefInfo
]
of
Object
.
entries
(
opts
.
preferences
|
|
defaultPref
)
)
{
preferences
[
prefName
]
=
{
.
.
.
defaultPrefInfo
.
.
.
prefInfo
}
;
}
return
Object
.
assign
(
{
name
:
STUDY_NAME
actionName
:
"
SomeAction
"
branch
:
"
branch
"
}
opts
{
preferences
}
)
;
}
async
function
getNonExpiredExperiment
(
)
{
try
{
let
exp
=
await
PreferenceExperiments
.
get
(
STUDY_NAME
)
;
if
(
exp
.
expired
)
{
return
null
;
}
}
catch
(
ex
)
{
}
return
null
;
}
