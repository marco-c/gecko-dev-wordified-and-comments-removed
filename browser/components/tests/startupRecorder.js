const
Cm
=
Components
.
manager
;
Cm
.
QueryInterface
(
Ci
.
nsIServiceManager
)
;
const
{
ComponentUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ComponentUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
let
firstPaintNotification
=
"
widget
-
first
-
paint
"
;
if
(
AppConstants
.
platform
=
=
"
linux
"
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
preXulSkeletonUI
"
)
)
{
firstPaintNotification
=
"
xul
-
window
-
visible
"
;
}
let
win
canvas
;
let
paints
=
[
]
;
let
afterPaintListener
=
(
)
=
>
{
let
width
height
;
canvas
.
width
=
width
=
win
.
innerWidth
;
canvas
.
height
=
height
=
win
.
innerHeight
;
if
(
width
<
1
|
|
height
<
1
)
{
return
;
}
let
ctx
=
canvas
.
getContext
(
"
2d
"
{
alpha
:
false
willReadFrequently
:
true
}
)
;
ctx
.
drawWindow
(
win
0
0
width
height
"
white
"
ctx
.
DRAWWINDOW_DO_NOT_FLUSH
|
ctx
.
DRAWWINDOW_DRAW_VIEW
|
ctx
.
DRAWWINDOW_ASYNC_DECODE_IMAGES
|
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
)
;
paints
.
push
(
{
data
:
ctx
.
getImageData
(
0
0
width
height
)
.
data
width
height
}
)
;
}
;
function
startupRecorder
(
)
{
this
.
wrappedJSObject
=
this
;
this
.
data
=
{
images
:
{
"
image
-
drawing
"
:
new
Set
(
)
"
image
-
loading
"
:
new
Set
(
)
}
code
:
{
}
extras
:
{
}
prefStats
:
{
}
}
;
this
.
done
=
new
Promise
(
resolve
=
>
{
this
.
_resolve
=
resolve
;
}
)
;
}
startupRecorder
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
11c095b2
-
e42e
-
4bdf
-
9dd0
-
aed87595f6a4
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
record
(
name
)
{
ChromeUtils
.
addProfilerMarker
(
"
startupRecorder
:
"
+
name
)
;
this
.
data
.
code
[
name
]
=
{
components
:
Cu
.
loadedComponents
modules
:
Cu
.
loadedModules
services
:
Object
.
keys
(
Cc
)
.
filter
(
c
=
>
{
try
{
return
Cm
.
isServiceInstantiatedByContractID
(
c
Ci
.
nsISupports
)
;
}
catch
(
e
)
{
return
false
;
}
}
)
}
;
this
.
data
.
extras
[
name
]
=
{
hiddenWindowLoaded
:
Services
.
appShell
.
hasHiddenWindow
}
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
app
-
startup
"
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
record
"
false
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
recordImages
"
false
)
)
{
this
.
_resolve
(
)
;
this
.
_resolve
=
null
;
return
;
}
let
topics
=
[
"
profile
-
do
-
change
"
"
toplevel
-
window
-
ready
"
firstPaintNotification
"
sessionstore
-
windows
-
restored
"
"
browser
-
startup
-
idle
-
tasks
-
finished
"
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
recordImages
"
false
)
)
{
topics
=
[
"
image
-
loading
"
"
image
-
drawing
"
"
browser
-
startup
-
idle
-
tasks
-
finished
"
]
;
}
for
(
let
t
of
topics
)
{
Services
.
obs
.
addObserver
(
this
t
)
;
}
return
;
}
if
(
topic
=
=
firstPaintNotification
)
{
if
(
subject
instanceof
Ci
.
nsIAppWindow
)
{
subject
=
subject
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
if
(
subject
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
"
navigator
:
browser
"
)
{
return
;
}
}
if
(
topic
=
=
"
image
-
drawing
"
|
|
topic
=
=
"
image
-
loading
"
)
{
this
.
data
.
images
[
topic
]
.
add
(
data
)
;
return
;
}
Services
.
obs
.
removeObserver
(
this
topic
)
;
if
(
topic
=
=
firstPaintNotification
)
{
win
=
subject
;
canvas
=
win
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
mozOpaque
=
true
;
afterPaintListener
(
)
;
win
.
addEventListener
(
"
MozAfterPaint
"
afterPaintListener
)
;
}
if
(
topic
=
=
"
sessionstore
-
windows
-
restored
"
)
{
Services
.
tm
.
dispatchToMainThread
(
this
.
record
.
bind
(
this
"
before
handling
user
events
"
)
)
;
}
else
if
(
topic
=
=
"
browser
-
startup
-
idle
-
tasks
-
finished
"
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
recordImages
"
false
)
)
{
Services
.
obs
.
removeObserver
(
this
"
image
-
drawing
"
)
;
Services
.
obs
.
removeObserver
(
this
"
image
-
loading
"
)
;
this
.
_resolve
(
)
;
this
.
_resolve
=
null
;
return
;
}
this
.
record
(
"
before
becoming
idle
"
)
;
win
.
removeEventListener
(
"
MozAfterPaint
"
afterPaintListener
)
;
win
=
null
;
this
.
data
.
frames
=
paints
;
this
.
data
.
prefStats
=
{
}
;
if
(
AppConstants
.
DEBUG
)
{
Services
.
prefs
.
readStats
(
(
key
value
)
=
>
(
this
.
data
.
prefStats
[
key
]
=
value
)
)
;
}
paints
=
null
;
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
!
env
.
exists
(
"
MOZ_PROFILER_STARTUP_PERFORMANCE_TEST
"
)
)
{
this
.
_resolve
(
)
;
this
.
_resolve
=
null
;
return
;
}
Services
.
profiler
.
getProfileDataAsync
(
)
.
then
(
profileData
=
>
{
this
.
data
.
profile
=
profileData
;
Services
.
profiler
.
StopProfiler
(
)
;
this
.
_resolve
(
)
;
this
.
_resolve
=
null
;
}
)
;
}
else
{
const
topicsToNames
=
{
"
profile
-
do
-
change
"
:
"
before
profile
selection
"
"
toplevel
-
window
-
ready
"
:
"
before
opening
first
browser
window
"
}
;
topicsToNames
[
firstPaintNotification
]
=
"
before
first
paint
"
;
this
.
record
(
topicsToNames
[
topic
]
)
;
}
}
}
;
this
.
NSGetFactory
=
ComponentUtils
.
generateNSGetFactory
(
[
startupRecorder
]
)
;
