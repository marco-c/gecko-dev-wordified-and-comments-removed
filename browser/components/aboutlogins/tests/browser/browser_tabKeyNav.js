add_task
(
async
function
setup
(
)
{
TEST_LOGIN1
=
await
addLogin
(
TEST_LOGIN1
)
;
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
url
:
"
about
:
logins
"
}
)
;
registerCleanupFunction
(
(
)
=
>
{
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
Services
.
logins
.
removeAllLogins
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_tab_key_nav
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
const
EventUtils
=
ContentTaskUtils
.
getEventUtils
(
content
)
;
async
function
tab
(
)
{
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
{
}
content
)
;
await
new
Promise
(
resolve
=
>
content
.
requestAnimationFrame
(
resolve
)
)
;
}
function
getFocusedEl
(
)
{
let
el
=
content
.
document
.
activeElement
;
const
getShadowRootFocus
=
e
=
>
{
if
(
e
.
shadowRoot
)
{
return
getShadowRootFocus
(
e
.
shadowRoot
.
activeElement
)
;
}
return
e
;
}
;
return
getShadowRootFocus
(
el
)
;
}
const
focused
=
new
Set
(
)
;
const
focusedAgain
=
new
Set
(
)
;
const
firstEl
=
getFocusedEl
(
)
;
focused
.
add
(
firstEl
)
;
const
maxKeypresses
=
content
.
document
.
getElementsByTagName
(
"
*
"
)
.
length
*
2
;
let
keypresses
=
1
;
while
(
focusedAgain
.
size
<
focused
.
size
&
&
keypresses
<
=
maxKeypresses
)
{
await
tab
(
)
;
keypresses
+
+
;
let
el
=
getFocusedEl
(
)
;
if
(
el
.
tagName
=
=
=
"
BODY
"
&
&
el
!
=
=
firstEl
)
{
firstEl
.
focus
(
)
;
await
new
Promise
(
resolve
=
>
content
.
requestAnimationFrame
(
resolve
)
)
;
el
=
getFocusedEl
(
)
;
}
if
(
focused
.
has
(
el
)
)
{
focusedAgain
.
add
(
el
)
;
}
else
{
focused
.
add
(
el
)
;
}
}
is
(
focusedAgain
.
size
focused
.
size
"
All
focusable
elements
should
be
kept
accessible
with
TAB
key
(
no
focus
trap
)
.
"
)
;
}
)
;
}
)
;
