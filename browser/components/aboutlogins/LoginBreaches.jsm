"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
LoginBreaches
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
LoginHelper
:
"
resource
:
/
/
gre
/
modules
/
LoginHelper
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
RemoteSettingsClient
:
"
resource
:
/
/
services
-
settings
/
RemoteSettingsClient
.
jsm
"
}
)
;
this
.
LoginBreaches
=
{
REMOTE_SETTINGS_COLLECTION
:
"
fxmonitor
-
breaches
"
async
update
(
breaches
=
null
)
{
const
logins
=
await
LoginHelper
.
getAllUserFacingLogins
(
)
;
await
this
.
getPotentialBreachesByLoginGUID
(
logins
breaches
)
;
}
async
getPotentialBreachesByLoginGUID
(
logins
breaches
=
null
)
{
const
breachesByLoginGUID
=
new
Map
(
)
;
if
(
!
breaches
)
{
try
{
breaches
=
await
RemoteSettings
(
this
.
REMOTE_SETTINGS_COLLECTION
)
.
get
(
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
RemoteSettingsClient
.
UnknownCollectionError
)
{
log
.
warn
(
"
Could
not
get
Remote
Settings
collection
.
"
this
.
REMOTE_SETTINGS_COLLECTION
ex
)
;
return
breachesByLoginGUID
;
}
throw
ex
;
}
}
const
BREACH_ALERT_URL
=
Services
.
prefs
.
getStringPref
(
"
signon
.
management
.
page
.
breachAlertUrl
"
)
;
const
baseBreachAlertURL
=
new
URL
(
BREACH_ALERT_URL
)
;
await
Services
.
logins
.
initializationPromise
;
const
storageJSON
=
Services
.
logins
.
wrappedJSObject
.
_storage
.
wrappedJSObject
;
const
dismissedBreachAlertsByLoginGUID
=
storageJSON
.
getBreachAlertDismissalsByLoginGUID
(
)
;
for
(
const
login
of
logins
)
{
let
loginHost
;
try
{
loginHost
=
Services
.
io
.
newURI
(
login
.
origin
)
.
host
;
}
catch
{
continue
;
}
for
(
const
breach
of
breaches
)
{
if
(
!
breach
.
Domain
|
|
!
Services
.
eTLD
.
hasRootDomain
(
loginHost
breach
.
Domain
)
|
|
!
this
.
_breachInvolvedPasswords
(
breach
)
|
|
!
this
.
_breachWasAfterPasswordLastChanged
(
breach
login
)
)
{
continue
;
}
if
(
!
storageJSON
.
isPotentiallyVulnerablePassword
(
login
)
)
{
storageJSON
.
addPotentiallyVulnerablePassword
(
login
)
;
}
if
(
this
.
_breachAlertIsDismissed
(
login
breach
dismissedBreachAlertsByLoginGUID
)
)
{
continue
;
}
let
breachAlertURL
=
new
URL
(
breach
.
Name
baseBreachAlertURL
)
;
breachAlertURL
.
searchParams
.
set
(
"
utm_source
"
"
firefox
-
desktop
"
)
;
breachAlertURL
.
searchParams
.
set
(
"
utm_medium
"
"
referral
"
)
;
breachAlertURL
.
searchParams
.
set
(
"
utm_campaign
"
"
about
-
logins
"
)
;
breachAlertURL
.
searchParams
.
set
(
"
utm_content
"
"
about
-
logins
"
)
;
breach
.
breachAlertURL
=
breachAlertURL
.
href
;
breachesByLoginGUID
.
set
(
login
.
guid
breach
)
;
}
}
Services
.
telemetry
.
scalarSet
(
"
pwmgr
.
potentially_breached_passwords
"
breachesByLoginGUID
.
size
)
;
return
breachesByLoginGUID
;
}
getPotentiallyVulnerablePasswordsByLoginGUID
(
logins
)
{
const
vulnerablePasswordsByLoginGUID
=
new
Map
(
)
;
const
storageJSON
=
Services
.
logins
.
wrappedJSObject
.
_storage
.
wrappedJSObject
;
for
(
const
login
of
logins
)
{
if
(
storageJSON
.
isPotentiallyVulnerablePassword
(
login
)
)
{
vulnerablePasswordsByLoginGUID
.
set
(
login
.
guid
true
)
;
}
}
return
vulnerablePasswordsByLoginGUID
;
}
async
clearAllPotentiallyVulnerablePasswords
(
)
{
await
Services
.
logins
.
initializationPromise
;
const
storageJSON
=
Services
.
logins
.
wrappedJSObject
.
_storage
.
wrappedJSObject
;
storageJSON
.
clearAllPotentiallyVulnerablePasswords
(
)
;
}
_breachAlertIsDismissed
(
login
breach
dismissedBreachAlerts
)
{
const
breachAddedDate
=
new
Date
(
breach
.
AddedDate
)
.
getTime
(
)
;
const
breachAlertIsDismissed
=
dismissedBreachAlerts
[
login
.
guid
]
&
&
dismissedBreachAlerts
[
login
.
guid
]
.
timeBreachAlertDismissed
>
breachAddedDate
;
return
breachAlertIsDismissed
;
}
_breachInvolvedPasswords
(
breach
)
{
return
(
breach
.
hasOwnProperty
(
"
DataClasses
"
)
&
&
breach
.
DataClasses
.
includes
(
"
Passwords
"
)
)
;
}
_breachWasAfterPasswordLastChanged
(
breach
login
)
{
const
breachDate
=
new
Date
(
breach
.
BreachDate
)
.
getTime
(
)
;
return
login
.
timePasswordChanged
<
breachDate
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
return
LoginHelper
.
createLogger
(
"
LoginBreaches
"
)
;
}
)
;
