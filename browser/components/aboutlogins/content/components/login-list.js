import
LoginListItemFactory
from
"
.
/
login
-
list
-
item
.
js
"
;
import
{
recordTelemetryEvent
}
from
"
.
.
/
aboutLoginsUtils
.
js
"
;
const
collator
=
new
Intl
.
Collator
(
)
;
const
sortFnOptions
=
{
name
:
(
a
b
)
=
>
collator
.
compare
(
a
.
title
b
.
title
)
"
last
-
used
"
:
(
a
b
)
=
>
a
.
timeLastUsed
<
b
.
timeLastUsed
"
last
-
changed
"
:
(
a
b
)
=
>
a
.
timePasswordChanged
<
b
.
timePasswordChanged
}
;
export
default
class
LoginList
extends
HTMLElement
{
constructor
(
)
{
super
(
)
;
this
.
_loginGuidsSortedOrder
=
[
]
;
this
.
_logins
=
{
}
;
this
.
_filter
=
"
"
;
this
.
_selectedGuid
=
null
;
this
.
_blankLoginListItem
=
LoginListItemFactory
.
create
(
{
}
)
;
}
connectedCallback
(
)
{
if
(
this
.
shadowRoot
)
{
return
;
}
let
loginListTemplate
=
document
.
querySelector
(
"
#
login
-
list
-
template
"
)
;
let
shadowRoot
=
this
.
attachShadow
(
{
mode
:
"
open
"
}
)
;
document
.
l10n
.
connectRoot
(
shadowRoot
)
;
shadowRoot
.
appendChild
(
loginListTemplate
.
content
.
cloneNode
(
true
)
)
;
this
.
_count
=
shadowRoot
.
querySelector
(
"
.
count
"
)
;
this
.
_createLoginButton
=
shadowRoot
.
querySelector
(
"
.
create
-
login
-
button
"
)
;
this
.
_list
=
shadowRoot
.
querySelector
(
"
ol
"
)
;
this
.
_list
.
appendChild
(
this
.
_blankLoginListItem
)
;
this
.
_sortSelect
=
shadowRoot
.
querySelector
(
"
#
login
-
sort
"
)
;
this
.
render
(
)
;
this
.
shadowRoot
.
getElementById
(
"
login
-
sort
"
)
.
addEventListener
(
"
change
"
this
)
;
window
.
addEventListener
(
"
AboutLoginsClearSelection
"
this
)
;
window
.
addEventListener
(
"
AboutLoginsCreateLogin
"
this
)
;
window
.
addEventListener
(
"
AboutLoginsLoginSelected
"
this
)
;
window
.
addEventListener
(
"
AboutLoginsFilterLogins
"
this
)
;
this
.
_list
.
addEventListener
(
"
click
"
this
)
;
this
.
addEventListener
(
"
keydown
"
this
)
;
this
.
_createLoginButton
.
addEventListener
(
"
click
"
this
)
;
}
async
render
(
)
{
let
visibleLoginGuids
=
this
.
_applyFilter
(
)
;
this
.
_updateVisibleLoginCount
(
visibleLoginGuids
.
size
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
guid
of
this
.
_loginGuidsSortedOrder
)
{
if
(
this
.
_logins
[
guid
]
.
listItem
)
{
continue
;
}
let
login
=
this
.
_logins
[
guid
]
.
login
;
let
listItem
=
LoginListItemFactory
.
create
(
login
)
;
this
.
_logins
[
login
.
guid
]
=
Object
.
assign
(
this
.
_logins
[
login
.
guid
]
{
listItem
}
)
;
fragment
.
appendChild
(
listItem
)
;
}
this
.
_list
.
appendChild
(
fragment
)
;
for
(
let
guid
of
this
.
_loginGuidsSortedOrder
)
{
let
{
listItem
}
=
this
.
_logins
[
guid
]
;
if
(
guid
=
=
this
.
_selectedGuid
)
{
this
.
_setListItemAsSelected
(
listItem
)
;
}
if
(
this
.
_breachesByLoginGUID
&
&
this
.
_breachesByLoginGUID
.
has
(
listItem
.
dataset
.
guid
)
)
{
listItem
.
classList
.
add
(
"
breached
"
)
;
}
listItem
.
hidden
=
!
visibleLoginGuids
.
has
(
listItem
.
dataset
.
guid
)
;
}
this
.
_blankLoginListItem
.
hidden
=
this
.
_selectedGuid
!
=
null
;
for
(
let
i
=
this
.
_loginGuidsSortedOrder
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
guid
=
this
.
_loginGuidsSortedOrder
[
i
]
;
let
{
listItem
}
=
this
.
_logins
[
guid
]
;
this
.
_list
.
insertBefore
(
listItem
this
.
_blankLoginListItem
.
nextElementSibling
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
click
"
:
{
if
(
event
.
originalTarget
=
=
this
.
_createLoginButton
)
{
window
.
dispatchEvent
(
new
CustomEvent
(
"
AboutLoginsCreateLogin
"
)
)
;
recordTelemetryEvent
(
{
object
:
"
new_login
"
method
:
"
new
"
}
)
;
return
;
}
let
listItem
=
event
.
originalTarget
.
closest
(
"
.
login
-
list
-
item
"
)
;
if
(
!
listItem
|
|
!
listItem
.
dataset
.
guid
)
{
return
;
}
this
.
dispatchEvent
(
new
CustomEvent
(
"
AboutLoginsLoginSelected
"
{
bubbles
:
true
composed
:
true
cancelable
:
true
detail
:
listItem
.
_login
}
)
)
;
recordTelemetryEvent
(
{
object
:
"
existing_login
"
method
:
"
select
"
}
)
;
break
;
}
case
"
change
"
:
{
this
.
_applySort
(
)
;
this
.
render
(
)
;
break
;
}
case
"
AboutLoginsClearSelection
"
:
{
if
(
!
this
.
_loginGuidsSortedOrder
.
length
)
{
return
;
}
let
firstLogin
=
this
.
_logins
[
this
.
_loginGuidsSortedOrder
[
0
]
]
.
login
;
window
.
dispatchEvent
(
new
CustomEvent
(
"
AboutLoginsLoginSelected
"
{
detail
:
firstLogin
cancelable
:
true
}
)
)
;
break
;
}
case
"
AboutLoginsCreateLogin
"
:
{
this
.
_selectedGuid
=
null
;
this
.
_setListItemAsSelected
(
this
.
_blankLoginListItem
)
;
break
;
}
case
"
AboutLoginsFilterLogins
"
:
{
this
.
_filter
=
event
.
detail
.
toLocaleLowerCase
(
)
;
this
.
render
(
)
;
break
;
}
case
"
AboutLoginsLoginSelected
"
:
{
if
(
event
.
defaultPrevented
|
|
this
.
_selectedGuid
=
=
event
.
detail
.
guid
)
{
return
;
}
let
listItem
=
this
.
_list
.
querySelector
(
.
login
-
list
-
item
[
data
-
guid
=
"
{
event
.
detail
.
guid
}
"
]
)
;
if
(
listItem
)
{
this
.
_setListItemAsSelected
(
listItem
)
;
}
else
{
this
.
render
(
)
;
}
break
;
}
case
"
keydown
"
:
{
this
.
_handleKeyboardNav
(
event
)
;
break
;
}
}
}
setLogins
(
logins
)
{
this
.
_loginGuidsSortedOrder
=
[
]
;
this
.
_logins
=
logins
.
reduce
(
(
map
login
)
=
>
{
this
.
_loginGuidsSortedOrder
.
push
(
login
.
guid
)
;
map
[
login
.
guid
]
=
{
login
}
;
return
map
;
}
{
}
)
;
this
.
_applySort
(
)
;
this
.
_list
.
textContent
=
"
"
;
this
.
_list
.
appendChild
(
this
.
_blankLoginListItem
)
;
this
.
render
(
)
;
if
(
!
this
.
_selectedGuid
|
|
!
this
.
_logins
[
this
.
_selectedGuid
]
)
{
let
firstVisibleListItem
=
this
.
_list
.
querySelector
(
"
.
login
-
list
-
item
[
data
-
guid
]
:
not
(
[
hidden
]
)
"
)
;
if
(
firstVisibleListItem
)
{
this
.
_selectedGuid
=
firstVisibleListItem
.
dataset
.
guid
;
this
.
_setListItemAsSelected
(
firstVisibleListItem
)
;
window
.
dispatchEvent
(
new
CustomEvent
(
"
AboutLoginsInitialLoginSelected
"
{
detail
:
firstVisibleListItem
.
_login
}
)
)
;
}
}
}
updateBreaches
(
breachesByLoginGUID
)
{
this
.
_breachesByLoginGUID
=
breachesByLoginGUID
;
this
.
render
(
)
;
}
loginAdded
(
login
)
{
this
.
_logins
[
login
.
guid
]
=
{
login
}
;
this
.
_loginGuidsSortedOrder
.
push
(
login
.
guid
)
;
this
.
_applySort
(
)
;
this
.
render
(
)
;
}
loginModified
(
login
)
{
this
.
_logins
[
login
.
guid
]
=
Object
.
assign
(
this
.
_logins
[
login
.
guid
]
{
login
}
)
;
this
.
_applySort
(
)
;
let
{
listItem
}
=
this
.
_logins
[
login
.
guid
]
;
LoginListItemFactory
.
update
(
listItem
login
)
;
this
.
render
(
)
;
}
loginRemoved
(
login
)
{
this
.
_logins
[
login
.
guid
]
.
listItem
.
remove
(
)
;
if
(
this
.
_selectedGuid
=
=
login
.
guid
)
{
let
index
=
this
.
_loginGuidsSortedOrder
.
indexOf
(
login
.
guid
)
;
if
(
this
.
_loginGuidsSortedOrder
.
length
>
1
)
{
let
newlySelectedIndex
=
index
>
0
?
index
-
1
:
index
+
1
;
let
newlySelectedListItem
=
this
.
_logins
[
this
.
_loginGuidsSortedOrder
[
newlySelectedIndex
]
]
.
listItem
;
this
.
_setListItemAsSelected
(
newlySelectedListItem
)
;
}
}
delete
this
.
_logins
[
login
.
guid
]
;
this
.
_loginGuidsSortedOrder
=
this
.
_loginGuidsSortedOrder
.
filter
(
guid
=
>
{
return
guid
!
=
login
.
guid
;
}
)
;
let
visibleLoginGuids
=
this
.
_applyFilter
(
)
;
this
.
_updateVisibleLoginCount
(
visibleLoginGuids
.
size
)
;
}
_applyFilter
(
)
{
let
matchingLoginGuids
;
if
(
this
.
_filter
)
{
matchingLoginGuids
=
new
Set
(
this
.
_loginGuidsSortedOrder
.
filter
(
guid
=
>
{
let
{
login
}
=
this
.
_logins
[
guid
]
;
return
(
login
.
origin
.
toLocaleLowerCase
(
)
.
includes
(
this
.
_filter
)
|
|
login
.
username
.
toLocaleLowerCase
(
)
.
includes
(
this
.
_filter
)
)
;
}
)
)
;
}
else
{
matchingLoginGuids
=
new
Set
(
[
.
.
.
this
.
_loginGuidsSortedOrder
]
)
;
}
return
matchingLoginGuids
;
}
_applySort
(
)
{
const
sort
=
this
.
_sortSelect
.
value
;
this
.
_loginGuidsSortedOrder
=
this
.
_loginGuidsSortedOrder
.
sort
(
(
a
b
)
=
>
{
let
loginA
=
this
.
_logins
[
a
]
.
login
;
let
loginB
=
this
.
_logins
[
b
]
.
login
;
return
sortFnOptions
[
sort
]
(
loginA
loginB
)
;
}
)
;
}
_updateVisibleLoginCount
(
count
)
{
if
(
count
!
=
document
.
l10n
.
getAttributes
(
this
.
_count
)
.
args
.
count
)
{
document
.
l10n
.
setAttributes
(
this
.
_count
"
login
-
list
-
count
"
{
count
}
)
;
}
}
_handleKeyboardNav
(
event
)
{
if
(
this
.
_createLoginButton
=
=
this
.
shadowRoot
.
activeElement
&
&
event
.
key
=
=
"
Tab
"
)
{
if
(
event
.
shiftKey
)
{
return
;
}
let
loginItem
=
document
.
querySelector
(
"
login
-
item
"
)
;
if
(
loginItem
)
{
event
.
preventDefault
(
)
;
loginItem
.
shadowRoot
.
querySelector
(
"
.
edit
-
button
"
)
.
focus
(
)
;
}
return
;
}
else
if
(
this
.
_list
!
=
this
.
shadowRoot
.
activeElement
)
{
return
;
}
let
isLTR
=
document
.
dir
=
=
"
ltr
"
;
let
activeDescendantId
=
this
.
_list
.
getAttribute
(
"
aria
-
activedescendant
"
)
;
let
activeDescendant
=
activeDescendantId
?
this
.
shadowRoot
.
getElementById
(
activeDescendantId
)
:
this
.
_list
.
firstElementChild
;
let
newlyFocusedItem
=
null
;
switch
(
event
.
key
)
{
case
"
ArrowDown
"
:
{
let
nextItem
=
activeDescendant
.
nextElementSibling
;
if
(
!
nextItem
)
{
return
;
}
newlyFocusedItem
=
nextItem
;
break
;
}
case
"
ArrowLeft
"
:
{
let
item
=
isLTR
?
activeDescendant
.
previousElementSibling
:
activeDescendant
.
nextElementSibling
;
if
(
!
item
)
{
return
;
}
newlyFocusedItem
=
item
;
break
;
}
case
"
ArrowRight
"
:
{
let
item
=
isLTR
?
activeDescendant
.
nextElementSibling
:
activeDescendant
.
previousElementSibling
;
if
(
!
item
)
{
return
;
}
newlyFocusedItem
=
item
;
break
;
}
case
"
ArrowUp
"
:
{
let
previousItem
=
activeDescendant
.
previousElementSibling
;
if
(
!
previousItem
)
{
return
;
}
newlyFocusedItem
=
previousItem
;
break
;
}
case
"
"
:
case
"
Enter
"
:
{
event
.
preventDefault
(
)
;
activeDescendant
.
click
(
)
;
return
;
}
default
:
return
;
}
event
.
preventDefault
(
)
;
this
.
_list
.
setAttribute
(
"
aria
-
activedescendant
"
newlyFocusedItem
.
id
)
;
activeDescendant
.
classList
.
remove
(
"
keyboard
-
selected
"
)
;
newlyFocusedItem
.
classList
.
add
(
"
keyboard
-
selected
"
)
;
newlyFocusedItem
.
scrollIntoView
(
false
)
;
}
_setListItemAsSelected
(
listItem
)
{
let
oldSelectedItem
=
this
.
_list
.
querySelector
(
"
.
selected
"
)
;
if
(
oldSelectedItem
)
{
oldSelectedItem
.
classList
.
remove
(
"
selected
"
)
;
oldSelectedItem
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
this
.
_blankLoginListItem
.
hidden
=
!
!
listItem
.
dataset
.
guid
;
listItem
.
classList
.
add
(
"
selected
"
)
;
listItem
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
this
.
_list
.
setAttribute
(
"
aria
-
activedescendant
"
listItem
.
id
)
;
this
.
_selectedGuid
=
listItem
.
dataset
.
guid
;
}
}
customElements
.
define
(
"
login
-
list
"
LoginList
)
;
