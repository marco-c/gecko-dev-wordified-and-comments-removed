"
use
strict
"
;
var
gNavBar
=
document
.
getElementById
(
CustomizableUI
.
AREA_NAVBAR
)
;
var
gOverflowList
=
document
.
getElementById
(
gNavBar
.
getAttribute
(
"
default
-
overflowtarget
"
)
)
;
const
kBookmarksButton
=
"
bookmarks
-
menu
-
button
"
;
const
kBookmarksItems
=
"
personal
-
bookmarks
"
;
const
kOriginalWindowWidth
=
window
.
outerWidth
;
function
bookmarksMenuPanelShown
(
)
{
return
new
Promise
(
resolve
=
>
{
let
bookmarksMenuPopup
=
document
.
getElementById
(
"
BMB_bookmarksPopup
"
)
;
let
onPopupShown
=
e
=
>
{
if
(
e
.
target
=
=
bookmarksMenuPopup
)
{
bookmarksMenuPopup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
resolve
(
)
;
}
}
;
bookmarksMenuPopup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
}
)
;
}
function
checkPlacesContextMenu
(
aItemWithContextMenu
)
{
return
(
async
function
(
)
{
let
contextMenu
=
document
.
getElementById
(
"
placesContext
"
)
;
let
newBookmarkItem
=
document
.
getElementById
(
"
placesContext_new
:
bookmark
"
)
;
info
(
"
Waiting
for
context
menu
on
"
+
aItemWithContextMenu
.
id
)
;
let
shownPromise
=
popupShown
(
contextMenu
)
;
EventUtils
.
synthesizeMouseAtCenter
(
aItemWithContextMenu
{
type
:
"
contextmenu
"
button
:
2
}
)
;
await
shownPromise
;
ok
(
!
newBookmarkItem
.
hasAttribute
(
"
disabled
"
)
"
New
bookmark
item
shouldn
'
t
be
disabled
"
)
;
info
(
"
Closing
context
menu
"
)
;
let
hiddenPromise
=
popupHidden
(
contextMenu
)
;
contextMenu
.
hidePopup
(
)
;
await
hiddenPromise
;
}
)
(
)
;
}
function
checkSpecialContextMenus
(
)
{
return
(
async
function
(
)
{
let
bookmarksMenuButton
=
document
.
getElementById
(
kBookmarksButton
)
;
let
bookmarksMenuPopup
=
document
.
getElementById
(
"
BMB_bookmarksPopup
"
)
;
const
kSpecialItemIDs
=
{
BMB_bookmarksToolbar
:
"
BMB_bookmarksToolbarPopup
"
BMB_unsortedBookmarks
:
"
BMB_unsortedBookmarksPopup
"
}
;
let
shownPromise
=
bookmarksMenuPanelShown
(
)
;
EventUtils
.
synthesizeMouseAtCenter
(
bookmarksMenuButton
{
}
)
;
info
(
"
Waiting
for
bookmarks
menu
popup
to
show
after
clicking
dropmarker
.
"
)
;
await
shownPromise
;
for
(
let
menuID
in
kSpecialItemIDs
)
{
let
menuItem
=
document
.
getElementById
(
menuID
)
;
let
menuPopup
=
document
.
getElementById
(
kSpecialItemIDs
[
menuID
]
)
;
info
(
"
Waiting
to
open
menu
for
"
+
menuID
)
;
shownPromise
=
popupShown
(
menuPopup
)
;
menuPopup
.
openPopup
(
menuItem
null
0
0
false
false
null
)
;
await
shownPromise
;
await
checkPlacesContextMenu
(
menuPopup
)
;
info
(
"
Closing
menu
for
"
+
menuID
)
;
await
closePopup
(
menuPopup
)
;
}
info
(
"
Closing
bookmarks
menu
"
)
;
await
closePopup
(
bookmarksMenuPopup
)
;
}
)
(
)
;
}
function
closePopup
(
aPopup
)
{
let
hiddenPromise
=
popupHidden
(
aPopup
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
return
hiddenPromise
;
}
function
checkBookmarksItemsChevronContextMenu
(
)
{
return
(
async
function
(
)
{
let
chevronPopup
=
document
.
getElementById
(
"
PlacesChevronPopup
"
)
;
let
shownPromise
=
popupShown
(
chevronPopup
)
;
let
chevron
=
document
.
getElementById
(
"
PlacesChevron
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
chevron
{
}
)
;
info
(
"
Waiting
for
bookmark
toolbar
item
chevron
popup
to
show
"
)
;
await
shownPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
for
(
let
child
of
chevronPopup
.
children
)
{
if
(
child
.
style
.
visibility
!
=
"
hidden
"
)
{
return
true
;
}
}
return
false
;
}
)
;
await
checkPlacesContextMenu
(
chevronPopup
)
;
info
(
"
Waiting
for
bookmark
toolbar
item
chevron
popup
to
close
"
)
;
await
closePopup
(
chevronPopup
)
;
}
)
(
)
;
}
function
overflowEverything
(
win
)
{
info
(
"
Waiting
for
overflow
"
)
;
let
waitOverflowing
=
BrowserTestUtils
.
waitForMutationCondition
(
gNavBar
{
attributes
:
true
attributeFilter
:
[
"
overflowing
"
]
}
(
)
=
>
gNavBar
.
hasAttribute
(
"
overflowing
"
)
)
;
ensureToolbarOverflow
(
win
false
)
;
return
waitOverflowing
;
}
function
stopOverflowing
(
win
originalWindowWidth
)
{
info
(
"
Waiting
until
we
stop
overflowing
"
)
;
let
waitOverflowing
=
BrowserTestUtils
.
waitForMutationCondition
(
gNavBar
{
attributes
:
true
attributeFilter
:
[
"
overflowing
"
]
}
(
)
=
>
!
gNavBar
.
hasAttribute
(
"
overflowing
"
)
)
;
unensureToolbarOverflow
(
win
originalWindowWidth
)
;
return
waitOverflowing
;
}
async
function
waitBookmarksToolbarIsUpdated
(
win
=
window
)
{
await
TestUtils
.
waitForCondition
(
async
(
)
=
>
(
await
win
.
PlacesToolbarHelper
.
getIsEmpty
(
)
)
=
=
=
false
"
Waiting
for
the
Bookmarks
toolbar
to
have
been
rebuilt
and
not
be
empty
"
)
;
if
(
win
.
PlacesToolbarHelper
.
_viewElt
.
_placesView
.
_updateNodesVisibilityTimer
)
{
await
BrowserTestUtils
.
waitForEvent
(
win
"
BookmarksToolbarVisibilityUpdated
"
)
;
}
}
function
checkOverflowing
(
aID
)
{
ok
(
!
gNavBar
.
querySelector
(
"
#
"
+
aID
)
"
Item
with
ID
"
+
aID
+
"
should
no
longer
be
in
the
gNavBar
"
)
;
let
item
=
gOverflowList
.
querySelector
(
"
#
"
+
aID
)
;
ok
(
item
"
Item
with
ID
"
+
aID
+
"
should
be
overflowing
"
)
;
is
(
item
.
getAttribute
(
"
overflowedItem
"
)
"
true
"
"
Item
with
ID
"
+
aID
+
"
should
have
overflowedItem
attribute
"
)
;
}
function
checkNotOverflowing
(
aID
)
{
ok
(
!
gOverflowList
.
querySelector
(
"
#
"
+
aID
)
"
Item
with
ID
"
+
aID
+
"
should
no
longer
be
overflowing
"
)
;
let
item
=
gNavBar
.
querySelector
(
"
#
"
+
aID
)
;
ok
(
item
"
Item
with
ID
"
+
aID
+
"
should
be
in
the
nav
bar
"
)
;
ok
(
!
item
.
hasAttribute
(
"
overflowedItem
"
)
"
Item
with
ID
"
+
aID
+
"
should
not
have
overflowedItem
attribute
"
)
;
}
add_task
(
async
function
testOverflowingBookmarksButtonContextMenu
(
)
{
ok
(
CustomizableUI
.
inDefaultState
"
Should
start
in
default
state
.
"
)
;
CustomizableUI
.
removeWidgetFromArea
(
"
developer
-
button
"
)
;
CustomizableUI
.
removeWidgetFromArea
(
"
library
-
button
"
CustomizableUI
.
AREA_NAVBAR
)
;
CustomizableUI
.
addWidgetToArea
(
kBookmarksButton
CustomizableUI
.
AREA_NAVBAR
)
;
ok
(
!
gNavBar
.
hasAttribute
(
"
overflowing
"
)
"
Should
start
with
a
non
-
overflowing
toolbar
.
"
)
;
await
checkSpecialContextMenus
(
)
;
const
originalWindowWidth
=
window
.
outerWidth
;
await
overflowEverything
(
window
)
;
checkOverflowing
(
kBookmarksButton
)
;
await
stopOverflowing
(
window
originalWindowWidth
)
;
checkNotOverflowing
(
kBookmarksButton
)
;
await
checkSpecialContextMenus
(
)
;
}
)
;
add_task
(
async
function
testOverflowingBookmarksItemsContextMenu
(
)
{
info
(
"
Adding
a
bookmark
to
the
bookmarks
toolbar
.
"
)
;
let
addedBookmark
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
title
:
"
Test
"
url
:
"
https
:
/
/
example
.
com
"
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
PlacesUtils
.
bookmarks
.
remove
(
addedBookmark
)
;
}
)
;
info
(
"
Ensuring
panel
is
ready
.
"
)
;
await
PanelUI
.
ensureReady
(
)
;
let
bookmarksToolbarItems
=
document
.
getElementById
(
kBookmarksItems
)
;
await
gCustomizeMode
.
addToToolbar
(
bookmarksToolbarItems
)
;
await
waitBookmarksToolbarIsUpdated
(
)
;
await
checkPlacesContextMenu
(
bookmarksToolbarItems
)
;
let
originalWindowWidth
=
window
.
outerWidth
;
await
overflowEverything
(
window
)
;
checkOverflowing
(
kBookmarksItems
)
;
await
gCustomizeMode
.
addToPanel
(
bookmarksToolbarItems
)
;
await
stopOverflowing
(
window
originalWindowWidth
)
;
await
gCustomizeMode
.
addToToolbar
(
bookmarksToolbarItems
)
;
await
waitBookmarksToolbarIsUpdated
(
)
;
await
checkPlacesContextMenu
(
bookmarksToolbarItems
)
;
}
)
;
add_task
(
async
function
testOverflowingBookmarksItemsChevronContextMenu
(
)
{
let
bookmarksToolbarItems
=
document
.
getElementById
(
kBookmarksItems
)
;
await
gCustomizeMode
.
addToToolbar
(
bookmarksToolbarItems
)
;
let
placesToolbarItems
=
document
.
getElementById
(
"
PlacesToolbarItems
"
)
;
let
placesChevron
=
document
.
getElementById
(
"
PlacesChevron
"
)
;
placesToolbarItems
.
style
.
maxWidth
=
"
10px
"
;
info
(
"
Waiting
for
chevron
to
no
longer
be
collapsed
"
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
placesChevron
.
collapsed
)
;
await
checkBookmarksItemsChevronContextMenu
(
)
;
let
originalWindowWidth
=
window
.
outerWidth
;
await
overflowEverything
(
window
)
;
checkOverflowing
(
kBookmarksItems
)
;
await
stopOverflowing
(
window
originalWindowWidth
)
;
checkNotOverflowing
(
kBookmarksItems
)
;
await
waitBookmarksToolbarIsUpdated
(
)
;
await
checkBookmarksItemsChevronContextMenu
(
)
;
placesToolbarItems
.
style
.
removeProperty
(
"
max
-
width
"
)
;
}
)
;
add_task
(
async
function
asyncCleanup
(
)
{
window
.
resizeTo
(
kOriginalWindowWidth
window
.
outerHeight
)
;
await
resetCustomization
(
)
;
}
)
;
