"
use
strict
"
;
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
search
.
widget
.
new
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
test_all_buttons_have_labels
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
endCustomizing
(
win
)
;
return
BrowserTestUtils
.
closeWindow
(
win
)
;
}
)
;
await
startCustomizing
(
win
)
;
let
{
palette
}
=
win
.
gNavToolbox
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
!
!
Array
.
from
(
palette
.
querySelectorAll
(
"
.
toolbarbutton
-
icon
"
)
)
.
filter
(
n
=
>
{
let
rect
=
n
.
getBoundingClientRect
(
)
;
return
rect
.
height
>
0
&
&
rect
.
width
>
0
;
}
)
.
length
;
}
"
Must
start
rendering
icons
.
"
)
;
for
(
let
wrapper
of
palette
.
children
)
{
if
(
wrapper
.
hasAttribute
(
"
title
"
)
)
{
ok
(
true
wrapper
.
firstElementChild
.
id
+
"
has
a
label
.
"
)
;
}
else
{
info
(
{
wrapper
.
firstElementChild
.
id
}
doesn
'
t
seem
to
have
a
label
waiting
.
)
;
await
BrowserTestUtils
.
waitForAttribute
(
"
title
"
wrapper
)
;
ok
(
wrapper
.
hasAttribute
(
"
title
"
)
wrapper
.
firstElementChild
.
id
+
"
has
a
label
.
"
)
;
}
let
icons
=
Array
.
from
(
wrapper
.
querySelectorAll
(
"
.
toolbarbutton
-
icon
"
)
)
;
if
(
icons
.
length
)
{
let
visibleIcons
=
icons
.
filter
(
n
=
>
{
let
rect
=
n
.
getBoundingClientRect
(
)
;
return
rect
.
height
>
0
&
&
rect
.
width
>
0
;
}
)
;
Assert
.
greater
(
visibleIcons
.
length
0
{
wrapper
.
firstElementChild
.
id
}
should
have
at
least
one
visible
icon
.
)
;
}
}
}
)
;
