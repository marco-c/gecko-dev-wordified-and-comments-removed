"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PanelMultiView
"
"
PanelView
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
const
BLOCKERS_TIMEOUT_MS
=
10000
;
const
TRANSITION_PHASES
=
Object
.
freeze
(
{
START
:
1
PREPARE
:
2
TRANSITION
:
3
}
)
;
let
gNodeToObjectMap
=
new
WeakMap
(
)
;
let
gWindowsWithUnloadHandler
=
new
WeakSet
(
)
;
let
gMultiLineElementsMap
=
new
WeakMap
(
)
;
var
AssociatedToNode
=
class
{
constructor
(
node
)
{
this
.
node
=
node
;
this
.
_blockersPromise
=
Promise
.
resolve
(
)
;
}
static
forNode
(
node
)
{
let
associatedToNode
=
gNodeToObjectMap
.
get
(
node
)
;
if
(
!
associatedToNode
)
{
associatedToNode
=
new
this
(
node
)
;
gNodeToObjectMap
.
set
(
node
associatedToNode
)
;
}
return
associatedToNode
;
}
get
document
(
)
{
return
this
.
node
.
ownerDocument
;
}
get
window
(
)
{
return
this
.
node
.
ownerGlobal
;
}
_getBoundsWithoutFlushing
(
element
)
{
return
this
.
window
.
windowUtils
.
getBoundsWithoutFlushing
(
element
)
;
}
dispatchCustomEvent
(
eventName
detail
cancelable
=
false
)
{
let
event
=
new
this
.
window
.
CustomEvent
(
eventName
{
detail
bubbles
:
true
cancelable
}
)
;
this
.
node
.
dispatchEvent
(
event
)
;
return
event
.
defaultPrevented
;
}
async
dispatchAsyncEvent
(
eventName
)
{
let
blockersPromise
=
this
.
_blockersPromise
.
catch
(
(
)
=
>
{
}
)
;
return
(
this
.
_blockersPromise
=
blockersPromise
.
then
(
async
(
)
=
>
{
let
blockers
=
new
Set
(
)
;
let
cancel
=
this
.
dispatchCustomEvent
(
eventName
{
addBlocker
(
promise
)
{
blockers
.
add
(
promise
.
catch
(
ex
=
>
{
Cu
.
reportError
(
ex
)
;
return
true
;
}
)
)
;
}
}
true
)
;
if
(
blockers
.
size
)
{
let
timeoutPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
window
.
setTimeout
(
reject
BLOCKERS_TIMEOUT_MS
)
;
}
)
;
try
{
let
results
=
await
Promise
.
race
(
[
Promise
.
all
(
blockers
)
timeoutPromise
]
)
;
cancel
=
cancel
|
|
results
.
some
(
result
=
>
result
=
=
=
false
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
new
Error
(
One
of
the
blockers
for
{
eventName
}
timed
out
.
)
)
;
return
true
;
}
}
return
cancel
;
}
)
)
;
}
}
;
var
PanelMultiView
=
class
extends
AssociatedToNode
{
static
async
openPopup
(
panelNode
.
.
.
args
)
{
let
panelMultiViewNode
=
panelNode
.
querySelector
(
"
panelmultiview
"
)
;
if
(
panelMultiViewNode
)
{
return
this
.
forNode
(
panelMultiViewNode
)
.
openPopup
(
.
.
.
args
)
;
}
panelNode
.
openPopup
(
.
.
.
args
)
;
return
true
;
}
static
hidePopup
(
panelNode
)
{
let
panelMultiViewNode
=
panelNode
.
querySelector
(
"
panelmultiview
"
)
;
if
(
panelMultiViewNode
)
{
this
.
forNode
(
panelMultiViewNode
)
.
hidePopup
(
)
;
}
else
{
panelNode
.
hidePopup
(
)
;
}
}
static
removePopup
(
panelNode
)
{
try
{
let
panelMultiViewNode
=
panelNode
.
querySelector
(
"
panelmultiview
"
)
;
if
(
panelMultiViewNode
)
{
let
panelMultiView
=
this
.
forNode
(
panelMultiViewNode
)
;
panelMultiView
.
_moveOutKids
(
)
;
panelMultiView
.
disconnect
(
)
;
}
}
finally
{
panelNode
.
remove
(
)
;
}
}
static
getViewNode
(
doc
id
)
{
let
viewCacheTemplate
=
doc
.
getElementById
(
"
appMenu
-
viewCache
"
)
;
return
(
doc
.
getElementById
(
id
)
|
|
viewCacheTemplate
?
.
content
.
querySelector
(
"
#
"
+
id
)
)
;
}
static
ensureUnloadHandlerRegistered
(
window
)
{
if
(
gWindowsWithUnloadHandler
.
has
(
window
)
)
{
return
;
}
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
for
(
let
panelMultiViewNode
of
window
.
document
.
querySelectorAll
(
"
panelmultiview
"
)
)
{
this
.
forNode
(
panelMultiViewNode
)
.
disconnect
(
)
;
}
}
{
once
:
true
}
)
;
gWindowsWithUnloadHandler
.
add
(
window
)
;
}
get
_panel
(
)
{
return
this
.
node
.
parentNode
;
}
set
_transitioning
(
val
)
{
if
(
val
)
{
this
.
node
.
setAttribute
(
"
transitioning
"
"
true
"
)
;
}
else
{
this
.
node
.
removeAttribute
(
"
transitioning
"
)
;
}
}
get
_screenManager
(
)
{
if
(
this
.
__screenManager
)
{
return
this
.
__screenManager
;
}
return
(
this
.
__screenManager
=
Cc
[
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
]
.
getService
(
Ci
.
nsIScreenManager
)
)
;
}
constructor
(
node
)
{
super
(
node
)
;
this
.
_openPopupPromise
=
Promise
.
resolve
(
false
)
;
this
.
_openPopupCancelCallback
=
(
)
=
>
{
}
;
}
connect
(
)
{
this
.
connected
=
true
;
PanelMultiView
.
ensureUnloadHandlerRegistered
(
this
.
window
)
;
let
viewContainer
=
(
this
.
_viewContainer
=
this
.
document
.
createXULElement
(
"
box
"
)
)
;
viewContainer
.
classList
.
add
(
"
panel
-
viewcontainer
"
)
;
let
viewStack
=
(
this
.
_viewStack
=
this
.
document
.
createXULElement
(
"
box
"
)
)
;
viewStack
.
classList
.
add
(
"
panel
-
viewstack
"
)
;
viewContainer
.
append
(
viewStack
)
;
let
offscreenViewContainer
=
this
.
document
.
createXULElement
(
"
box
"
)
;
offscreenViewContainer
.
classList
.
add
(
"
panel
-
viewcontainer
"
"
offscreen
"
)
;
let
offscreenViewStack
=
(
this
.
_offscreenViewStack
=
this
.
document
.
createXULElement
(
"
box
"
)
)
;
offscreenViewStack
.
classList
.
add
(
"
panel
-
viewstack
"
)
;
offscreenViewContainer
.
append
(
offscreenViewStack
)
;
this
.
node
.
prepend
(
offscreenViewContainer
)
;
this
.
node
.
prepend
(
viewContainer
)
;
this
.
openViews
=
[
]
;
this
.
_panel
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popuppositioned
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popupshown
"
this
)
;
[
"
goBack
"
"
showSubView
"
]
.
forEach
(
method
=
>
{
Object
.
defineProperty
(
this
.
node
method
{
enumerable
:
true
value
:
(
.
.
.
args
)
=
>
this
[
method
]
(
.
.
.
args
)
}
)
;
}
)
;
}
disconnect
(
)
{
if
(
!
this
.
node
|
|
!
this
.
connected
)
{
return
;
}
this
.
_panel
.
removeEventListener
(
"
mousemove
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popupshowing
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popuppositioned
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popupshown
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popuphidden
"
this
)
;
this
.
document
.
documentElement
.
removeEventListener
(
"
keydown
"
this
true
)
;
this
.
node
=
this
.
_openPopupPromise
=
this
.
_openPopupCancelCallback
=
this
.
_viewContainer
=
this
.
_viewStack
=
this
.
_transitionDetails
=
null
;
}
async
openPopup
(
anchor
options
.
.
.
args
)
{
let
canCancel
=
true
;
let
cancelCallback
=
(
this
.
_openPopupCancelCallback
=
(
)
=
>
{
if
(
canCancel
&
&
this
.
node
)
{
canCancel
=
false
;
this
.
dispatchCustomEvent
(
"
popuphidden
"
)
;
}
}
)
;
let
openPopupPromise
=
this
.
_openPopupPromise
.
catch
(
(
)
=
>
{
return
false
;
}
)
;
return
(
this
.
_openPopupPromise
=
openPopupPromise
.
then
(
async
wasShown
=
>
{
if
(
!
this
.
node
)
{
return
false
;
}
if
(
wasShown
&
&
[
"
open
"
"
showing
"
]
.
includes
(
this
.
_panel
.
state
)
)
{
return
true
;
}
try
{
if
(
!
this
.
connected
)
{
this
.
connect
(
)
;
}
if
(
!
(
await
this
.
_showMainView
(
)
)
)
{
cancelCallback
(
)
;
}
}
catch
(
ex
)
{
cancelCallback
(
)
;
throw
ex
;
}
if
(
!
canCancel
|
|
!
this
.
node
)
{
return
false
;
}
try
{
canCancel
=
false
;
this
.
_panel
.
openPopup
(
anchor
options
.
.
.
args
)
;
this
.
_panel
.
setAttribute
(
"
mainviewshowing
"
true
)
;
if
(
this
.
_panel
.
state
=
=
"
closed
"
&
&
this
.
openViews
.
length
)
{
this
.
dispatchCustomEvent
(
"
popuphidden
"
)
;
return
false
;
}
if
(
options
&
&
typeof
options
=
=
"
object
"
&
&
options
.
triggerEvent
&
&
options
.
triggerEvent
.
type
=
=
"
keypress
"
&
&
this
.
openViews
.
length
)
{
this
.
openViews
[
0
]
.
focusWhenActive
=
true
;
}
return
true
;
}
catch
(
ex
)
{
this
.
dispatchCustomEvent
(
"
popuphidden
"
)
;
throw
ex
;
}
}
)
)
;
}
hidePopup
(
)
{
if
(
!
this
.
node
|
|
!
this
.
connected
)
{
return
;
}
if
(
[
"
open
"
"
showing
"
]
.
includes
(
this
.
_panel
.
state
)
)
{
this
.
_panel
.
hidePopup
(
)
;
}
else
{
this
.
_openPopupCancelCallback
(
)
;
}
this
.
closeAllViews
(
)
;
}
_moveOutKids
(
)
{
let
viewCacheId
=
this
.
node
.
getAttribute
(
"
viewCacheId
"
)
;
if
(
!
viewCacheId
)
{
return
;
}
let
subviews
=
Array
.
from
(
this
.
_viewStack
.
children
)
;
let
viewCache
=
this
.
document
.
getElementById
(
"
appMenu
-
viewCache
"
)
;
for
(
let
subview
of
subviews
)
{
viewCache
.
appendChild
(
subview
)
;
}
}
showSubView
(
viewIdOrNode
anchor
)
{
this
.
_panel
.
autoPosition
=
false
;
this
.
_showSubView
(
viewIdOrNode
anchor
)
.
catch
(
Cu
.
reportError
)
;
}
async
_showSubView
(
viewIdOrNode
anchor
)
{
let
viewNode
=
typeof
viewIdOrNode
=
=
"
string
"
?
PanelMultiView
.
getViewNode
(
this
.
document
viewIdOrNode
)
:
viewIdOrNode
;
if
(
!
viewNode
)
{
Cu
.
reportError
(
new
Error
(
Subview
{
viewIdOrNode
}
doesn
'
t
exist
.
)
)
;
return
;
}
if
(
!
this
.
openViews
.
length
)
{
Cu
.
reportError
(
new
Error
(
Cannot
show
a
subview
in
a
closed
panel
.
)
)
;
return
;
}
let
prevPanelView
=
this
.
openViews
[
this
.
openViews
.
length
-
1
]
;
let
nextPanelView
=
PanelView
.
forNode
(
viewNode
)
;
if
(
this
.
openViews
.
includes
(
nextPanelView
)
)
{
Cu
.
reportError
(
new
Error
(
Subview
{
viewNode
.
id
}
is
already
open
.
)
)
;
return
;
}
if
(
!
prevPanelView
.
active
)
{
return
;
}
let
doingKeyboardActivation
=
prevPanelView
.
_doingKeyboardActivation
;
prevPanelView
.
active
=
false
;
if
(
anchor
)
{
anchor
.
setAttribute
(
"
open
"
"
true
"
)
;
}
try
{
if
(
!
(
await
this
.
_openView
(
nextPanelView
)
)
)
{
if
(
prevPanelView
.
isOpenIn
(
this
)
)
{
prevPanelView
.
active
=
true
;
}
return
;
}
prevPanelView
.
captureKnownSize
(
)
;
nextPanelView
.
mainview
=
false
;
nextPanelView
.
headerText
=
viewNode
.
getAttribute
(
"
title
"
)
|
|
(
anchor
&
&
anchor
.
getAttribute
(
"
label
"
)
)
;
nextPanelView
.
minMaxWidth
=
prevPanelView
.
knownWidth
;
let
lockPanelVertical
=
this
.
openViews
[
0
]
.
node
.
getAttribute
(
"
lockpanelvertical
"
)
=
=
"
true
"
;
nextPanelView
.
minMaxHeight
=
lockPanelVertical
?
prevPanelView
.
knownHeight
:
0
;
if
(
anchor
)
{
viewNode
.
classList
.
add
(
"
PanelUI
-
subView
"
)
;
}
await
this
.
_transitionViews
(
prevPanelView
.
node
viewNode
false
anchor
)
;
}
finally
{
if
(
anchor
)
{
anchor
.
removeAttribute
(
"
open
"
)
;
}
}
nextPanelView
.
focusWhenActive
=
doingKeyboardActivation
;
this
.
_activateView
(
nextPanelView
)
;
}
goBack
(
)
{
this
.
_goBack
(
)
.
catch
(
Cu
.
reportError
)
;
}
async
_goBack
(
)
{
if
(
this
.
openViews
.
length
<
2
)
{
return
;
}
let
prevPanelView
=
this
.
openViews
[
this
.
openViews
.
length
-
1
]
;
let
nextPanelView
=
this
.
openViews
[
this
.
openViews
.
length
-
2
]
;
if
(
!
prevPanelView
.
active
)
{
return
;
}
prevPanelView
.
active
=
false
;
prevPanelView
.
captureKnownSize
(
)
;
await
this
.
_transitionViews
(
prevPanelView
.
node
nextPanelView
.
node
true
)
;
this
.
_closeLatestView
(
)
;
this
.
_activateView
(
nextPanelView
)
;
}
async
_showMainView
(
)
{
let
nextPanelView
=
PanelView
.
forNode
(
PanelMultiView
.
getViewNode
(
this
.
document
this
.
node
.
getAttribute
(
"
mainViewId
"
)
)
)
;
let
oldPanelMultiViewNode
=
nextPanelView
.
node
.
panelMultiView
;
if
(
oldPanelMultiViewNode
)
{
PanelMultiView
.
forNode
(
oldPanelMultiViewNode
)
.
hidePopup
(
)
;
await
this
.
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
}
if
(
!
(
await
this
.
_openView
(
nextPanelView
)
)
)
{
return
false
;
}
nextPanelView
.
mainview
=
true
;
nextPanelView
.
headerText
=
"
"
;
nextPanelView
.
minMaxWidth
=
0
;
nextPanelView
.
minMaxHeight
=
0
;
nextPanelView
.
visible
=
true
;
nextPanelView
.
descriptionHeightWorkaround
(
)
;
return
true
;
}
async
_openView
(
panelView
)
{
if
(
panelView
.
node
.
parentNode
!
=
this
.
_viewStack
)
{
this
.
_viewStack
.
appendChild
(
panelView
.
node
)
;
}
panelView
.
node
.
panelMultiView
=
this
.
node
;
this
.
openViews
.
push
(
panelView
)
;
if
(
panelView
.
node
.
getAttribute
(
"
remote
"
)
=
=
"
true
"
)
{
this
.
_panel
.
setAttribute
(
"
remote
"
"
true
"
)
;
}
let
canceled
=
await
panelView
.
dispatchAsyncEvent
(
"
ViewShowing
"
)
;
if
(
!
this
.
openViews
.
length
)
{
return
false
;
}
if
(
canceled
)
{
this
.
_closeLatestView
(
)
;
return
false
;
}
let
{
style
}
=
panelView
.
node
;
style
.
removeProperty
(
"
outline
"
)
;
style
.
removeProperty
(
"
width
"
)
;
return
true
;
}
_activateView
(
panelView
)
{
if
(
panelView
.
isOpenIn
(
this
)
)
{
panelView
.
active
=
true
;
if
(
panelView
.
focusWhenActive
)
{
panelView
.
focusFirstNavigableElement
(
false
true
)
;
panelView
.
focusWhenActive
=
false
;
}
panelView
.
dispatchCustomEvent
(
"
ViewShown
"
)
;
this
.
_panel
.
autoPosition
=
true
;
}
}
_closeLatestView
(
)
{
let
panelView
=
this
.
openViews
.
pop
(
)
;
panelView
.
clearNavigation
(
)
;
panelView
.
dispatchCustomEvent
(
"
ViewHiding
"
)
;
panelView
.
node
.
panelMultiView
=
null
;
panelView
.
visible
=
false
;
}
closeAllViews
(
)
{
while
(
this
.
openViews
.
length
)
{
this
.
_closeLatestView
(
)
;
}
}
async
_transitionViews
(
previousViewNode
viewNode
reverse
)
{
const
{
window
}
=
this
;
let
nextPanelView
=
PanelView
.
forNode
(
viewNode
)
;
let
prevPanelView
=
PanelView
.
forNode
(
previousViewNode
)
;
let
details
=
(
this
.
_transitionDetails
=
{
phase
:
TRANSITION_PHASES
.
START
}
)
;
let
olderView
=
reverse
?
nextPanelView
:
prevPanelView
;
this
.
_viewContainer
.
style
.
minHeight
=
olderView
.
knownHeight
+
"
px
"
;
this
.
_viewContainer
.
style
.
height
=
prevPanelView
.
knownHeight
+
"
px
"
;
this
.
_viewContainer
.
style
.
width
=
prevPanelView
.
knownWidth
+
"
px
"
;
let
rect
=
this
.
_panel
.
getOuterScreenRect
(
)
;
this
.
_panel
.
setAttribute
(
"
width
"
rect
.
width
)
;
this
.
_panel
.
setAttribute
(
"
height
"
rect
.
height
)
;
let
viewRect
;
if
(
reverse
)
{
viewRect
=
{
width
:
nextPanelView
.
knownWidth
height
:
nextPanelView
.
knownHeight
}
;
nextPanelView
.
visible
=
true
;
}
else
if
(
viewNode
.
customRectGetter
)
{
let
width
=
prevPanelView
.
knownWidth
;
let
height
=
prevPanelView
.
knownHeight
;
viewRect
=
Object
.
assign
(
{
height
width
}
viewNode
.
customRectGetter
(
)
)
;
nextPanelView
.
visible
=
true
;
let
header
=
viewNode
.
firstElementChild
;
if
(
header
&
&
header
.
classList
.
contains
(
"
panel
-
header
"
)
)
{
viewRect
.
height
+
=
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
return
this
.
_getBoundsWithoutFlushing
(
header
)
.
height
;
}
)
;
}
await
nextPanelView
.
descriptionHeightWorkaround
(
)
;
if
(
!
nextPanelView
.
isOpenIn
(
this
)
)
{
return
;
}
}
else
{
this
.
_offscreenViewStack
.
style
.
minHeight
=
olderView
.
knownHeight
+
"
px
"
;
this
.
_offscreenViewStack
.
appendChild
(
viewNode
)
;
nextPanelView
.
visible
=
true
;
await
nextPanelView
.
descriptionHeightWorkaround
(
)
;
viewRect
=
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
return
this
.
_getBoundsWithoutFlushing
(
viewNode
)
;
}
)
;
if
(
!
nextPanelView
.
isOpenIn
(
this
)
)
{
return
;
}
this
.
_viewStack
.
appendChild
(
viewNode
)
;
this
.
_offscreenViewStack
.
style
.
removeProperty
(
"
min
-
height
"
)
;
}
this
.
_transitioning
=
true
;
details
.
phase
=
TRANSITION_PHASES
.
PREPARE
;
let
moveToLeft
=
(
this
.
window
.
RTL_UI
&
&
!
reverse
)
|
|
(
!
this
.
window
.
RTL_UI
&
&
reverse
)
;
let
deltaX
=
prevPanelView
.
knownWidth
;
let
deepestNode
=
reverse
?
previousViewNode
:
viewNode
;
if
(
reverse
)
{
this
.
_viewStack
.
style
.
marginInlineStart
=
"
-
"
+
deltaX
+
"
px
"
;
}
this
.
_viewStack
.
style
.
transition
=
"
transform
var
(
-
-
animation
-
easing
-
function
)
"
+
"
var
(
-
-
panelui
-
subview
-
transition
-
duration
)
"
;
this
.
_viewStack
.
style
.
willChange
=
"
transform
"
;
deepestNode
.
style
.
outline
=
"
1px
solid
var
(
-
-
panel
-
separator
-
color
)
"
;
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
if
(
!
nextPanelView
.
isOpenIn
(
this
)
)
{
return
;
}
this
.
_viewContainer
.
style
.
height
=
viewRect
.
height
+
"
px
"
;
this
.
_viewContainer
.
style
.
width
=
viewRect
.
width
+
"
px
"
;
this
.
_panel
.
removeAttribute
(
"
width
"
)
;
this
.
_panel
.
removeAttribute
(
"
height
"
)
;
viewNode
.
style
.
width
=
viewRect
.
width
+
"
px
"
;
details
.
phase
=
TRANSITION_PHASES
.
TRANSITION
;
if
(
viewNode
.
getAttribute
(
"
mainview
"
)
)
{
this
.
_viewContainer
.
style
.
removeProperty
(
"
min
-
height
"
)
;
this
.
_panel
.
setAttribute
(
"
mainviewshowing
"
true
)
;
}
else
{
this
.
_panel
.
removeAttribute
(
"
mainviewshowing
"
)
;
}
this
.
_viewStack
.
style
.
transform
=
"
translateX
(
"
+
(
moveToLeft
?
"
"
:
"
-
"
)
+
deltaX
+
"
px
)
"
;
await
new
Promise
(
resolve
=
>
{
details
.
resolve
=
resolve
;
this
.
_viewContainer
.
addEventListener
(
"
transitionend
"
(
details
.
listener
=
ev
=
>
{
if
(
ev
.
target
!
=
this
.
_viewStack
|
|
ev
.
propertyName
!
=
"
transform
"
)
{
return
;
}
this
.
_viewContainer
.
removeEventListener
(
"
transitionend
"
details
.
listener
)
;
delete
details
.
listener
;
resolve
(
)
;
}
)
)
;
this
.
_viewContainer
.
addEventListener
(
"
transitioncancel
"
(
details
.
cancelListener
=
ev
=
>
{
if
(
ev
.
target
!
=
this
.
_viewStack
)
{
return
;
}
this
.
_viewContainer
.
removeEventListener
(
"
transitioncancel
"
details
.
cancelListener
)
;
delete
details
.
cancelListener
;
resolve
(
)
;
}
)
)
;
}
)
;
if
(
!
nextPanelView
.
isOpenIn
(
this
)
)
{
return
;
}
prevPanelView
.
visible
=
false
;
nextPanelView
.
node
.
style
.
removeProperty
(
"
width
"
)
;
deepestNode
.
style
.
removeProperty
(
"
outline
"
)
;
this
.
_cleanupTransitionPhase
(
)
;
nextPanelView
.
focusSelectedElement
(
)
;
}
_cleanupTransitionPhase
(
)
{
if
(
!
this
.
_transitionDetails
)
{
return
;
}
let
{
phase
resolve
listener
cancelListener
}
=
this
.
_transitionDetails
;
this
.
_transitionDetails
=
null
;
if
(
phase
>
=
TRANSITION_PHASES
.
START
)
{
this
.
_panel
.
removeAttribute
(
"
width
"
)
;
this
.
_panel
.
removeAttribute
(
"
height
"
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
height
"
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
width
"
)
;
}
if
(
phase
>
=
TRANSITION_PHASES
.
PREPARE
)
{
this
.
_transitioning
=
false
;
this
.
_viewStack
.
style
.
removeProperty
(
"
margin
-
inline
-
start
"
)
;
this
.
_viewStack
.
style
.
removeProperty
(
"
transition
"
)
;
}
if
(
phase
>
=
TRANSITION_PHASES
.
TRANSITION
)
{
this
.
_viewStack
.
style
.
removeProperty
(
"
transform
"
)
;
if
(
listener
)
{
this
.
_viewContainer
.
removeEventListener
(
"
transitionend
"
listener
)
;
}
if
(
cancelListener
)
{
this
.
_viewContainer
.
removeEventListener
(
"
transitioncancel
"
cancelListener
)
;
}
if
(
resolve
)
{
resolve
(
)
;
}
}
}
_calculateMaxHeight
(
aEvent
)
{
let
anchor
=
this
.
_panel
.
anchorNode
;
let
anchorRect
=
anchor
.
getBoundingClientRect
(
)
;
let
screen
=
this
.
_screenManager
.
screenForRect
(
anchor
.
screenX
anchor
.
screenY
anchorRect
.
width
anchorRect
.
height
)
;
let
availTop
=
{
}
availHeight
=
{
}
;
screen
.
GetAvailRect
(
{
}
availTop
{
}
availHeight
)
;
let
cssAvailTop
=
availTop
.
value
/
screen
.
defaultCSSScaleFactor
;
let
maxHeight
;
if
(
aEvent
.
alignmentPosition
.
startsWith
(
"
before_
"
)
)
{
maxHeight
=
anchor
.
screenY
-
cssAvailTop
;
}
else
{
let
anchorScreenBottom
=
anchor
.
screenY
+
anchorRect
.
height
;
let
cssAvailHeight
=
availHeight
.
value
/
screen
.
defaultCSSScaleFactor
;
maxHeight
=
cssAvailTop
+
cssAvailHeight
-
anchorScreenBottom
;
}
const
EXTRA_MARGIN_PX
=
20
;
maxHeight
-
=
EXTRA_MARGIN_PX
;
return
maxHeight
;
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
.
startsWith
(
"
popup
"
)
&
&
aEvent
.
target
!
=
this
.
_panel
&
&
aEvent
.
target
!
=
this
.
node
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
keydown
"
:
let
currentView
=
this
.
openViews
[
this
.
openViews
.
length
-
1
]
;
currentView
.
keyNavigation
(
aEvent
)
;
break
;
case
"
mousemove
"
:
this
.
openViews
.
forEach
(
panelView
=
>
{
if
(
!
panelView
.
ignoreMouseMove
)
{
panelView
.
clearNavigation
(
)
;
}
}
)
;
break
;
case
"
popupshowing
"
:
{
this
.
_viewContainer
.
setAttribute
(
"
panelopen
"
"
true
"
)
;
if
(
!
this
.
node
.
hasAttribute
(
"
disablekeynav
"
)
)
{
this
.
document
.
documentElement
.
addEventListener
(
"
keydown
"
this
true
)
;
this
.
_panel
.
addEventListener
(
"
mousemove
"
this
)
;
}
break
;
}
case
"
popuppositioned
"
:
{
if
(
this
.
_panel
.
state
=
=
"
showing
"
)
{
let
maxHeight
=
this
.
_calculateMaxHeight
(
aEvent
)
;
this
.
_viewStack
.
style
.
maxHeight
=
maxHeight
+
"
px
"
;
this
.
_offscreenViewStack
.
style
.
maxHeight
=
maxHeight
+
"
px
"
;
}
break
;
}
case
"
popupshown
"
:
let
mainPanelView
=
this
.
openViews
[
0
]
;
mainPanelView
.
descriptionHeightWorkaround
(
true
)
.
catch
(
Cu
.
reportError
)
;
this
.
_activateView
(
mainPanelView
)
;
break
;
case
"
popuphidden
"
:
{
this
.
_transitioning
=
false
;
this
.
_viewContainer
.
removeAttribute
(
"
panelopen
"
)
;
this
.
_cleanupTransitionPhase
(
)
;
this
.
document
.
documentElement
.
removeEventListener
(
"
keydown
"
this
true
)
;
this
.
_panel
.
removeEventListener
(
"
mousemove
"
this
)
;
this
.
closeAllViews
(
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
min
-
height
"
)
;
this
.
_viewStack
.
style
.
removeProperty
(
"
max
-
height
"
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
width
"
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
height
"
)
;
this
.
dispatchCustomEvent
(
"
PanelMultiViewHidden
"
)
;
break
;
}
}
}
}
;
var
PanelView
=
class
extends
AssociatedToNode
{
constructor
(
node
)
{
super
(
node
)
;
this
.
active
=
false
;
this
.
focusWhenActive
=
false
;
}
isOpenIn
(
panelMultiView
)
{
return
this
.
node
.
panelMultiView
=
=
panelMultiView
.
node
;
}
set
mainview
(
value
)
{
if
(
value
)
{
this
.
node
.
setAttribute
(
"
mainview
"
true
)
;
}
else
{
this
.
node
.
removeAttribute
(
"
mainview
"
)
;
}
}
set
visible
(
value
)
{
if
(
value
)
{
this
.
node
.
setAttribute
(
"
visible
"
true
)
;
}
else
{
this
.
node
.
removeAttribute
(
"
visible
"
)
;
this
.
active
=
false
;
this
.
focusWhenActive
=
false
;
}
}
set
minMaxWidth
(
value
)
{
let
style
=
this
.
node
.
style
;
if
(
value
)
{
style
.
minWidth
=
style
.
maxWidth
=
value
+
"
px
"
;
}
else
{
style
.
removeProperty
(
"
min
-
width
"
)
;
style
.
removeProperty
(
"
max
-
width
"
)
;
}
}
set
minMaxHeight
(
value
)
{
let
style
=
this
.
node
.
style
;
if
(
value
)
{
style
.
minHeight
=
style
.
maxHeight
=
value
+
"
px
"
;
}
else
{
style
.
removeProperty
(
"
min
-
height
"
)
;
style
.
removeProperty
(
"
max
-
height
"
)
;
}
}
set
headerText
(
value
)
{
let
ensureHeaderSeparator
=
headerNode
=
>
{
if
(
headerNode
.
nextSibling
.
tagName
!
=
"
toolbarseparator
"
)
{
let
separator
=
this
.
document
.
createXULElement
(
"
toolbarseparator
"
)
;
this
.
node
.
insertBefore
(
separator
headerNode
.
nextSibling
)
;
}
}
;
let
header
=
this
.
node
.
firstElementChild
;
if
(
header
&
&
header
.
classList
.
contains
(
"
panel
-
header
"
)
)
{
if
(
value
)
{
header
.
querySelector
(
"
.
panel
-
header
>
h1
>
span
"
)
.
textContent
=
value
;
ensureHeaderSeparator
(
header
)
;
}
else
{
if
(
header
.
nextSibling
.
tagName
=
=
"
toolbarseparator
"
)
{
header
.
nextSibling
.
remove
(
)
;
}
header
.
remove
(
)
;
}
return
;
}
if
(
!
value
)
{
return
;
}
header
=
this
.
document
.
createXULElement
(
"
box
"
)
;
header
.
classList
.
add
(
"
panel
-
header
"
)
;
let
backButton
=
this
.
document
.
createXULElement
(
"
toolbarbutton
"
)
;
backButton
.
className
=
"
subviewbutton
subviewbutton
-
iconic
subviewbutton
-
back
"
;
backButton
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
backButton
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
backButton
.
setAttribute
(
"
aria
-
label
"
gBundle
.
GetStringFromName
(
"
panel
.
back
"
)
)
;
backButton
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
node
.
panelMultiView
.
goBack
(
)
;
backButton
.
blur
(
)
;
}
)
;
let
h1
=
this
.
document
.
createElement
(
"
h1
"
)
;
let
span
=
this
.
document
.
createElement
(
"
span
"
)
;
span
.
textContent
=
value
;
h1
.
appendChild
(
span
)
;
header
.
append
(
backButton
h1
)
;
this
.
node
.
prepend
(
header
)
;
ensureHeaderSeparator
(
header
)
;
}
dispatchCustomEvent
(
.
.
.
args
)
{
CustomizableUI
.
ensureSubviewListeners
(
this
.
node
)
;
return
super
.
dispatchCustomEvent
(
.
.
.
args
)
;
}
captureKnownSize
(
)
{
let
rect
=
this
.
_getBoundsWithoutFlushing
(
this
.
node
)
;
this
.
knownWidth
=
rect
.
width
;
this
.
knownHeight
=
rect
.
height
;
}
async
descriptionHeightWorkaround
(
allowSyncReflows
=
false
)
{
if
(
!
this
.
node
.
hasAttribute
(
"
descriptionheightworkaround
"
)
)
{
return
;
}
const
profilerMarkerStartTime
=
Cu
.
now
(
)
;
let
items
=
[
]
;
let
collectItems
=
(
)
=
>
{
let
isMultiline
=
"
:
not
(
[
hidden
]
[
value
]
:
empty
)
"
;
let
selector
=
[
"
description
"
+
isMultiline
"
label
"
+
isMultiline
"
toolbarbutton
[
wrap
]
:
not
(
[
hidden
]
)
"
]
.
join
(
"
"
)
;
for
(
let
element
of
this
.
node
.
querySelectorAll
(
selector
)
)
{
if
(
element
.
closest
(
"
[
hidden
]
"
)
)
{
continue
;
}
if
(
element
.
tagName
!
=
"
toolbarbutton
"
&
&
element
.
closest
(
"
toolbarbutton
"
)
)
{
continue
;
}
element
=
element
.
multilineLabel
|
|
element
;
let
bounds
=
element
.
getBoundingClientRect
(
)
;
let
previous
=
gMultiLineElementsMap
.
get
(
element
)
;
if
(
!
bounds
.
width
|
|
!
bounds
.
height
|
|
(
previous
&
&
element
.
textContent
=
=
previous
.
textContent
&
&
bounds
.
width
=
=
previous
.
bounds
.
width
)
)
{
continue
;
}
items
.
push
(
{
element
}
)
;
}
}
;
if
(
allowSyncReflows
)
{
collectItems
(
)
;
}
else
{
await
this
.
window
.
promiseDocumentFlushed
(
collectItems
)
;
if
(
!
this
.
node
.
panelMultiView
)
{
return
;
}
}
for
(
let
item
of
items
)
{
item
.
element
.
style
.
removeProperty
(
"
height
"
)
;
}
let
measureItems
=
(
)
=
>
{
for
(
let
item
of
items
)
{
item
.
bounds
=
item
.
element
.
getBoundingClientRect
(
)
;
}
}
;
if
(
allowSyncReflows
)
{
measureItems
(
)
;
}
else
{
await
this
.
window
.
promiseDocumentFlushed
(
measureItems
)
;
if
(
!
this
.
node
.
panelMultiView
)
{
return
;
}
}
for
(
let
{
element
bounds
}
of
items
)
{
gMultiLineElementsMap
.
set
(
element
{
bounds
textContent
:
element
.
textContent
}
)
;
element
.
style
.
height
=
bounds
.
height
+
"
px
"
;
}
ChromeUtils
.
addProfilerMarker
(
"
PMV
.
descriptionHeightWorkaround
(
)
"
profilerMarkerStartTime
<
{
this
.
node
.
tagName
}
id
=
"
{
this
.
node
.
id
}
"
>
)
;
}
_isNavigableWithTabOnly
(
element
)
{
let
tag
=
element
.
localName
;
return
(
tag
=
=
"
menulist
"
|
|
tag
=
=
"
radiogroup
"
|
|
tag
=
=
"
input
"
|
|
tag
=
=
"
textarea
"
|
|
tag
=
=
"
browser
"
|
|
tag
=
=
"
iframe
"
)
;
}
_makeNavigableTreeWalker
(
arrowKey
)
{
let
filter
=
node
=
>
{
if
(
node
.
disabled
)
{
return
NodeFilter
.
FILTER_REJECT
;
}
let
bounds
=
this
.
_getBoundsWithoutFlushing
(
node
)
;
if
(
bounds
.
width
=
=
0
|
|
bounds
.
height
=
=
0
)
{
return
NodeFilter
.
FILTER_REJECT
;
}
if
(
node
.
tagName
=
=
"
button
"
|
|
node
.
tagName
=
=
"
toolbarbutton
"
|
|
node
.
tagName
=
=
"
checkbox
"
|
|
node
.
classList
.
contains
(
"
text
-
link
"
)
|
|
(
!
arrowKey
&
&
this
.
_isNavigableWithTabOnly
(
node
)
)
)
{
if
(
node
.
tagName
!
=
"
browser
"
&
&
node
.
tagName
!
=
"
iframe
"
&
&
!
node
.
hasAttribute
(
"
tabindex
"
)
)
{
node
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
}
return
NodeFilter
.
FILTER_ACCEPT
;
}
return
NodeFilter
.
FILTER_SKIP
;
}
;
return
this
.
document
.
createTreeWalker
(
this
.
node
NodeFilter
.
SHOW_ELEMENT
filter
)
;
}
get
_tabNavigableWalker
(
)
{
if
(
!
this
.
__tabNavigableWalker
)
{
this
.
__tabNavigableWalker
=
this
.
_makeNavigableTreeWalker
(
false
)
;
}
return
this
.
__tabNavigableWalker
;
}
get
_arrowNavigableWalker
(
)
{
if
(
!
this
.
__arrowNavigableWalker
)
{
this
.
__arrowNavigableWalker
=
this
.
_makeNavigableTreeWalker
(
true
)
;
}
return
this
.
__arrowNavigableWalker
;
}
get
selectedElement
(
)
{
return
this
.
_selectedElement
&
&
this
.
_selectedElement
.
get
(
)
;
}
set
selectedElement
(
value
)
{
if
(
!
value
)
{
delete
this
.
_selectedElement
;
}
else
{
this
.
_selectedElement
=
Cu
.
getWeakReference
(
value
)
;
}
}
focusFirstNavigableElement
(
homeKey
=
false
skipBack
=
false
)
{
let
walker
=
homeKey
?
this
.
_arrowNavigableWalker
:
this
.
_tabNavigableWalker
;
walker
.
currentNode
=
walker
.
root
;
this
.
selectedElement
=
walker
.
firstChild
(
)
;
if
(
skipBack
&
&
walker
.
currentNode
&
&
walker
.
currentNode
.
classList
.
contains
(
"
subviewbutton
-
back
"
)
&
&
walker
.
nextNode
(
)
)
{
this
.
selectedElement
=
walker
.
currentNode
;
}
this
.
focusSelectedElement
(
true
)
;
}
focusLastNavigableElement
(
endKey
=
false
)
{
let
walker
=
endKey
?
this
.
_arrowNavigableWalker
:
this
.
_tabNavigableWalker
;
walker
.
currentNode
=
walker
.
root
;
this
.
selectedElement
=
walker
.
lastChild
(
)
;
this
.
focusSelectedElement
(
true
)
;
}
moveSelection
(
isDown
arrowKey
=
false
)
{
let
walker
=
arrowKey
?
this
.
_arrowNavigableWalker
:
this
.
_tabNavigableWalker
;
let
oldSel
=
this
.
selectedElement
;
let
newSel
;
if
(
oldSel
)
{
walker
.
currentNode
=
oldSel
;
newSel
=
isDown
?
walker
.
nextNode
(
)
:
walker
.
previousNode
(
)
;
}
if
(
!
newSel
)
{
walker
.
currentNode
=
walker
.
root
;
newSel
=
isDown
?
walker
.
firstChild
(
)
:
walker
.
lastChild
(
)
;
}
this
.
selectedElement
=
newSel
;
return
newSel
;
}
keyNavigation
(
event
)
{
if
(
!
this
.
active
)
{
return
;
}
let
focus
=
this
.
document
.
activeElement
;
if
(
focus
&
&
!
(
this
.
node
.
compareDocumentPosition
(
focus
)
&
Node
.
DOCUMENT_POSITION_CONTAINED_BY
)
)
{
focus
=
null
;
}
if
(
focus
&
&
(
focus
.
tagName
=
=
"
browser
"
|
|
focus
.
tagName
=
=
"
iframe
"
)
)
{
return
;
}
let
stop
=
(
)
=
>
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
;
let
tabOnly
=
(
)
=
>
{
return
focus
&
&
this
.
_isNavigableWithTabOnly
(
focus
)
;
}
;
let
isContextMenuOpen
=
(
)
=
>
{
if
(
!
focus
)
{
return
false
;
}
let
contextNode
=
focus
.
closest
(
"
[
context
]
"
)
;
if
(
!
contextNode
)
{
return
false
;
}
let
context
=
contextNode
.
getAttribute
(
"
context
"
)
;
let
popup
=
this
.
document
.
getElementById
(
context
)
;
return
popup
&
&
popup
.
state
=
=
"
open
"
;
}
;
this
.
ignoreMouseMove
=
false
;
let
keyCode
=
event
.
code
;
switch
(
keyCode
)
{
case
"
ArrowDown
"
:
case
"
ArrowUp
"
:
if
(
tabOnly
(
)
)
{
break
;
}
case
"
Tab
"
:
{
if
(
isContextMenuOpen
(
)
|
|
(
focus
&
&
focus
.
localName
=
=
"
menulist
"
&
&
focus
.
open
)
)
{
break
;
}
stop
(
)
;
let
isDown
=
keyCode
=
=
"
ArrowDown
"
|
|
(
keyCode
=
=
"
Tab
"
&
&
!
event
.
shiftKey
)
;
let
button
=
this
.
moveSelection
(
isDown
keyCode
!
=
"
Tab
"
)
;
Services
.
focus
.
setFocus
(
button
Services
.
focus
.
FLAG_BYKEY
)
;
break
;
}
case
"
Home
"
:
if
(
tabOnly
(
)
|
|
isContextMenuOpen
(
)
)
{
break
;
}
stop
(
)
;
this
.
focusFirstNavigableElement
(
true
)
;
break
;
case
"
End
"
:
if
(
tabOnly
(
)
|
|
isContextMenuOpen
(
)
)
{
break
;
}
stop
(
)
;
this
.
focusLastNavigableElement
(
true
)
;
break
;
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
{
if
(
tabOnly
(
)
|
|
isContextMenuOpen
(
)
)
{
break
;
}
stop
(
)
;
if
(
(
!
this
.
window
.
RTL_UI
&
&
keyCode
=
=
"
ArrowLeft
"
)
|
|
(
this
.
window
.
RTL_UI
&
&
keyCode
=
=
"
ArrowRight
"
)
)
{
this
.
node
.
panelMultiView
.
goBack
(
)
;
break
;
}
let
button
=
this
.
selectedElement
;
if
(
!
button
|
|
!
button
.
classList
.
contains
(
"
subviewbutton
-
nav
"
)
)
{
break
;
}
}
case
"
Space
"
:
case
"
NumpadEnter
"
:
case
"
Enter
"
:
{
if
(
tabOnly
(
)
|
|
isContextMenuOpen
(
)
)
{
break
;
}
let
button
=
this
.
selectedElement
;
if
(
!
button
)
{
break
;
}
stop
(
)
;
this
.
_doingKeyboardActivation
=
true
;
let
commandEvent
=
event
.
target
.
ownerDocument
.
createEvent
(
"
xulcommandevent
"
)
;
commandEvent
.
initCommandEvent
(
"
command
"
true
true
event
.
target
.
ownerGlobal
0
event
.
ctrlKey
event
.
altKey
event
.
shiftKey
event
.
metaKey
0
null
0
)
;
button
.
dispatchEvent
(
commandEvent
)
;
let
dispEvent
=
new
event
.
target
.
ownerGlobal
.
MouseEvent
(
"
mousedown
"
{
bubbles
:
true
}
)
;
button
.
dispatchEvent
(
dispEvent
)
;
dispEvent
=
new
event
.
target
.
ownerGlobal
.
MouseEvent
(
"
click
"
{
bubbles
:
true
}
)
;
button
.
dispatchEvent
(
dispEvent
)
;
this
.
_doingKeyboardActivation
=
false
;
break
;
}
}
}
focusSelectedElement
(
byKey
=
false
)
{
let
selected
=
this
.
selectedElement
;
if
(
selected
)
{
let
flag
=
byKey
?
Services
.
focus
.
FLAG_BYKEY
:
0
;
Services
.
focus
.
setFocus
(
selected
flag
)
;
}
}
clearNavigation
(
)
{
let
selected
=
this
.
selectedElement
;
if
(
selected
)
{
selected
.
blur
(
)
;
this
.
selectedElement
=
null
;
}
}
}
;
