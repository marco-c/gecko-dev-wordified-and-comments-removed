"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PanelMultiView
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableWidgets
"
"
resource
:
/
/
/
modules
/
CustomizableWidgets
.
jsm
"
)
;
class
SlidingPanelViews
extends
Array
{
constructor
(
)
{
super
(
)
;
this
.
_marker
=
0
;
}
get
current
(
)
{
return
this
.
_marker
;
}
set
current
(
index
)
{
if
(
index
=
=
this
.
_marker
)
{
return
index
;
}
if
(
index
=
=
-
1
|
|
index
>
(
this
.
length
-
1
)
)
{
throw
new
Error
(
SlidingPanelViews
:
:
index
{
index
}
out
of
bounds
)
;
}
let
view
=
this
.
splice
(
index
1
)
[
0
]
;
if
(
this
.
_marker
>
index
)
{
-
-
this
.
_marker
;
}
this
.
splice
(
+
+
this
.
_marker
0
view
)
;
return
this
.
_marker
;
}
get
currentView
(
)
{
return
this
[
this
.
_marker
]
;
}
set
currentView
(
view
)
{
if
(
!
view
)
return
this
.
current
;
return
this
.
current
=
this
.
indexOf
(
view
)
;
}
get
previousView
(
)
{
return
this
[
this
.
_marker
+
1
]
;
}
back
(
)
{
if
(
this
.
_marker
>
0
)
-
-
this
.
_marker
;
return
[
this
.
currentView
this
.
previousView
]
;
}
clear
(
)
{
this
.
_marker
=
0
;
this
.
splice
(
0
this
.
length
)
;
}
}
this
.
PanelMultiView
=
class
{
get
document
(
)
{
return
this
.
node
.
ownerDocument
;
}
get
window
(
)
{
return
this
.
node
.
ownerGlobal
;
}
get
_panel
(
)
{
return
this
.
node
.
parentNode
;
}
get
showingSubView
(
)
{
return
this
.
node
.
getAttribute
(
"
viewtype
"
)
=
=
"
subview
"
;
}
get
_mainViewId
(
)
{
return
this
.
node
.
getAttribute
(
"
mainViewId
"
)
;
}
set
_mainViewId
(
val
)
{
this
.
node
.
setAttribute
(
"
mainViewId
"
val
)
;
return
val
;
}
get
_mainView
(
)
{
return
this
.
_mainViewId
?
this
.
document
.
getElementById
(
this
.
_mainViewId
)
:
null
;
}
get
showingSubViewAsMainView
(
)
{
return
this
.
node
.
getAttribute
(
"
mainViewIsSubView
"
)
=
=
"
true
"
;
}
get
ignoreMutations
(
)
{
return
this
.
_ignoreMutations
;
}
set
ignoreMutations
(
val
)
{
this
.
_ignoreMutations
=
val
;
if
(
!
val
&
&
this
.
_panel
.
state
=
=
"
open
"
)
{
if
(
this
.
showingSubView
)
{
this
.
_syncContainerWithSubView
(
)
;
}
else
{
this
.
_syncContainerWithMainView
(
)
;
}
}
}
get
_transitioning
(
)
{
return
this
.
__transitioning
;
}
set
_transitioning
(
val
)
{
this
.
__transitioning
=
val
;
if
(
val
)
{
this
.
node
.
setAttribute
(
"
transitioning
"
"
true
"
)
;
}
else
{
this
.
node
.
removeAttribute
(
"
transitioning
"
)
;
}
}
get
panelViews
(
)
{
if
(
this
.
_subViews
)
return
null
;
if
(
this
.
_panelViews
)
return
this
.
_panelViews
;
this
.
_panelViews
=
new
SlidingPanelViews
(
)
;
this
.
_panelViews
.
push
(
.
.
.
this
.
node
.
getElementsByTagName
(
"
panelview
"
)
)
;
return
this
.
_panelViews
;
}
get
_dwu
(
)
{
return
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
get
_currentSubView
(
)
{
return
this
.
panelViews
?
this
.
panelViews
.
currentView
:
this
.
__currentSubView
;
}
set
_currentSubView
(
panel
)
{
if
(
this
.
panelViews
)
this
.
panelViews
.
currentView
=
panel
;
else
this
.
__currentSubView
=
panel
;
return
panel
;
}
constructor
(
xulNode
)
{
this
.
node
=
xulNode
;
this
.
_currentSubView
=
this
.
_anchorElement
=
this
.
_subViewObserver
=
null
;
this
.
_mainViewHeight
=
0
;
this
.
__transitioning
=
this
.
_ignoreMutations
=
false
;
const
{
document
window
}
=
this
;
this
.
_clickCapturer
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
clickCapturer
"
)
;
this
.
_viewContainer
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
viewContainer
"
)
;
this
.
_mainViewContainer
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
mainViewContainer
"
)
;
this
.
_subViews
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
subViews
"
)
;
this
.
_viewStack
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
viewStack
"
)
;
this
.
_panel
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popuphidden
"
this
)
;
if
(
this
.
panelViews
)
{
let
cs
=
window
.
getComputedStyle
(
document
.
documentElement
)
;
this
.
_dir
=
cs
.
direction
;
this
.
setMainView
(
this
.
panelViews
.
currentView
)
;
this
.
showMainView
(
)
;
}
else
{
this
.
_panel
.
addEventListener
(
"
popupshown
"
this
)
;
this
.
_clickCapturer
.
addEventListener
(
"
click
"
this
)
;
this
.
_subViews
.
addEventListener
(
"
overflow
"
this
)
;
this
.
_mainViewContainer
.
addEventListener
(
"
overflow
"
this
)
;
this
.
_subViewObserver
=
new
window
.
MutationObserver
(
this
.
_syncContainerWithSubView
.
bind
(
this
)
)
;
this
.
_mainViewObserver
=
new
window
.
MutationObserver
(
this
.
_syncContainerWithMainView
.
bind
(
this
)
)
;
this
.
_mainViewContainer
.
setAttribute
(
"
panelid
"
this
.
_panel
.
id
)
;
if
(
this
.
_mainView
)
{
this
.
setMainView
(
this
.
_mainView
)
;
}
}
this
.
node
.
setAttribute
(
"
viewtype
"
"
main
"
)
;
[
"
_mainView
"
"
ignoreMutations
"
"
showingSubView
"
]
.
forEach
(
property
=
>
{
Object
.
defineProperty
(
this
.
node
property
{
enumerable
:
true
get
:
(
)
=
>
this
[
property
]
set
:
(
val
)
=
>
this
[
property
]
=
val
}
)
;
}
)
;
[
"
goBack
"
"
setHeightToFit
"
"
setMainView
"
"
showMainView
"
"
showSubView
"
]
.
forEach
(
method
=
>
{
Object
.
defineProperty
(
this
.
node
method
{
enumerable
:
true
value
:
(
.
.
.
args
)
=
>
this
[
method
]
(
.
.
.
args
)
}
)
;
}
)
;
}
destructor
(
)
{
if
(
this
.
_mainView
)
{
this
.
_mainView
.
removeAttribute
(
"
mainview
"
)
;
}
if
(
this
.
panelViews
)
{
this
.
panelViews
.
clear
(
)
;
}
else
{
this
.
_mainViewObserver
.
disconnect
(
)
;
this
.
_subViewObserver
.
disconnect
(
)
;
this
.
_subViews
.
removeEventListener
(
"
overflow
"
this
)
;
this
.
_mainViewContainer
.
removeEventListener
(
"
overflow
"
this
)
;
this
.
_clickCapturer
.
removeEventListener
(
"
click
"
this
)
;
}
this
.
_panel
.
removeEventListener
(
"
popupshowing
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popupshown
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popuphidden
"
this
)
;
this
.
node
=
this
.
_clickCapturer
=
this
.
_viewContainer
=
this
.
_mainViewContainer
=
this
.
_subViews
=
this
.
_viewStack
=
null
;
}
goBack
(
target
)
{
let
[
current
previous
]
=
this
.
panelViews
.
back
(
)
;
return
this
.
showSubView
(
current
target
previous
)
;
}
setMainView
(
aNewMainView
)
{
if
(
this
.
panelViews
)
{
if
(
aNewMainView
.
parentNode
!
=
this
.
_viewStack
&
&
this
.
_viewStack
.
firstChild
!
=
aNewMainView
)
{
this
.
_viewStack
.
insertBefore
(
aNewMainView
this
.
_viewStack
.
firstChild
)
;
}
}
else
{
if
(
this
.
_mainView
)
{
this
.
_mainViewObserver
.
disconnect
(
)
;
this
.
_subViews
.
appendChild
(
this
.
_mainView
)
;
this
.
_mainView
.
removeAttribute
(
"
mainview
"
)
;
}
this
.
_mainViewId
=
aNewMainView
.
id
;
aNewMainView
.
setAttribute
(
"
mainview
"
"
true
"
)
;
this
.
_mainViewContainer
.
appendChild
(
aNewMainView
)
;
}
}
showMainView
(
)
{
if
(
this
.
panelViews
)
{
this
.
showSubView
(
this
.
_mainViewId
)
;
}
else
{
if
(
this
.
showingSubView
)
{
let
viewNode
=
this
.
_currentSubView
;
let
evt
=
new
this
.
window
.
CustomEvent
(
"
ViewHiding
"
{
bubbles
:
true
cancelable
:
true
}
)
;
viewNode
.
dispatchEvent
(
evt
)
;
viewNode
.
removeAttribute
(
"
current
"
)
;
this
.
_currentSubView
=
null
;
this
.
_subViewObserver
.
disconnect
(
)
;
this
.
_setViewContainerHeight
(
this
.
_mainViewHeight
)
;
this
.
node
.
setAttribute
(
"
viewtype
"
"
main
"
)
;
}
this
.
_shiftMainView
(
)
;
}
}
showSubView
(
aViewId
aAnchor
aPreviousView
aAdopted
=
false
)
{
const
{
document
window
}
=
this
;
return
window
.
Task
.
spawn
(
function
*
(
)
{
let
viewNode
=
typeof
aViewId
=
=
"
string
"
?
this
.
node
.
querySelector
(
"
#
"
+
aViewId
)
:
aViewId
;
if
(
!
viewNode
)
{
viewNode
=
document
.
getElementById
(
aViewId
)
;
if
(
viewNode
)
{
if
(
this
.
panelViews
)
{
this
.
_viewStack
.
appendChild
(
viewNode
)
;
this
.
panelViews
.
push
(
viewNode
)
;
}
else
{
this
.
_subViews
.
appendChild
(
viewNode
)
;
}
}
else
{
throw
new
Error
(
Subview
{
aViewId
}
doesn
'
t
exist
!
)
;
}
}
let
reverse
=
!
!
aPreviousView
;
let
previousViewNode
=
aPreviousView
|
|
this
.
_currentSubView
;
let
playTransition
=
(
!
!
previousViewNode
&
&
previousViewNode
!
=
viewNode
)
;
let
dwu
previousRect
;
if
(
playTransition
)
{
dwu
=
this
.
_dwu
;
previousRect
=
previousViewNode
.
__lastKnownBoundingRect
=
dwu
.
getBoundsWithoutFlushing
(
previousViewNode
)
;
}
let
detail
=
{
blockers
:
new
Set
(
)
addBlocker
(
aPromise
)
{
this
.
blockers
.
add
(
aPromise
)
;
}
}
;
if
(
this
.
panelViews
&
&
aAdopted
&
&
aAnchor
)
{
if
(
aAnchor
&
&
!
viewNode
.
hasAttribute
(
"
title
"
)
)
viewNode
.
setAttribute
(
"
title
"
aAnchor
.
getAttribute
(
"
label
"
)
)
;
viewNode
.
classList
.
add
(
"
PanelUI
-
subView
"
)
;
let
custWidget
=
CustomizableWidgets
.
find
(
widget
=
>
widget
.
viewId
=
=
viewNode
.
id
)
;
if
(
custWidget
)
{
if
(
custWidget
.
onInit
)
custWidget
.
onInit
(
aAnchor
)
;
custWidget
.
onViewShowing
(
{
target
:
aAnchor
detail
}
)
;
}
}
viewNode
.
setAttribute
(
"
current
"
true
)
;
let
evt
=
new
window
.
CustomEvent
(
"
ViewShowing
"
{
bubbles
:
true
cancelable
:
true
detail
}
)
;
viewNode
.
dispatchEvent
(
evt
)
;
let
cancel
=
evt
.
defaultPrevented
;
if
(
detail
.
blockers
.
size
)
{
try
{
let
results
=
yield
window
.
Promise
.
all
(
detail
.
blockers
)
;
cancel
=
cancel
|
|
results
.
some
(
val
=
>
val
=
=
=
false
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
cancel
=
true
;
}
}
if
(
cancel
)
{
return
;
}
this
.
_currentSubView
=
viewNode
;
this
.
node
.
setAttribute
(
"
viewtype
"
"
subview
"
)
;
if
(
this
.
panelViews
&
&
playTransition
)
{
let
onTransitionEnd
=
(
)
=
>
{
evt
=
new
window
.
CustomEvent
(
"
ViewHiding
"
{
bubbles
:
true
cancelable
:
true
}
)
;
previousViewNode
.
dispatchEvent
(
evt
)
;
previousViewNode
.
removeAttribute
(
"
current
"
)
;
}
;
if
(
this
.
_panel
.
state
!
=
"
open
"
)
{
onTransitionEnd
(
)
;
return
;
}
if
(
aAnchor
)
aAnchor
.
setAttribute
(
"
open
"
true
)
;
this
.
_viewContainer
.
style
.
height
=
previousRect
.
height
+
"
px
"
;
this
.
_viewContainer
.
style
.
width
=
previousRect
.
width
+
"
px
"
;
this
.
_transitioning
=
true
;
this
.
_viewContainer
.
setAttribute
(
"
transition
-
reverse
"
reverse
)
;
let
nodeToAnimate
=
reverse
?
previousViewNode
:
viewNode
;
if
(
!
reverse
)
{
nodeToAnimate
.
style
.
marginInlineStart
=
previousRect
.
width
+
"
px
"
;
}
nodeToAnimate
.
style
.
transition
=
"
transform
ease
-
"
+
(
reverse
?
"
in
"
:
"
out
"
)
+
"
var
(
-
-
panelui
-
subview
-
transition
-
duration
)
"
;
nodeToAnimate
.
style
.
willChange
=
"
transform
"
;
nodeToAnimate
.
style
.
borderInlineStart
=
"
1px
solid
var
(
-
-
panel
-
separator
-
color
)
"
;
window
.
addEventListener
(
"
MozAfterPaint
"
(
)
=
>
{
let
viewRect
=
viewNode
.
__lastKnownBoundingRect
;
if
(
!
viewRect
)
{
viewRect
=
dwu
.
getBoundsWithoutFlushing
(
viewNode
)
;
if
(
!
reverse
)
{
viewRect
.
height
=
[
viewNode
.
header
.
.
.
viewNode
.
children
]
.
reduce
(
(
acc
node
)
=
>
{
return
acc
+
dwu
.
getBoundsWithoutFlushing
(
node
)
.
height
;
}
0
)
;
}
}
this
.
_viewContainer
.
style
.
height
=
viewRect
.
height
+
"
px
"
;
this
.
_viewContainer
.
style
.
width
=
viewRect
.
width
+
"
px
"
;
let
moveToLeft
=
(
this
.
_dir
=
=
"
rtl
"
&
&
!
reverse
)
|
|
(
this
.
_dir
=
=
"
ltr
"
&
&
reverse
)
;
let
movementX
=
reverse
?
viewRect
.
width
:
previousRect
.
width
;
let
moveX
=
(
moveToLeft
?
"
"
:
"
-
"
)
+
movementX
;
nodeToAnimate
.
style
.
transform
=
"
translateX
(
"
+
moveX
+
"
px
)
"
;
nodeToAnimate
.
style
.
width
=
viewRect
.
width
+
"
px
"
;
let
listener
;
let
seen
=
0
;
this
.
_viewContainer
.
addEventListener
(
"
transitionend
"
listener
=
ev
=
>
{
if
(
ev
.
target
=
=
this
.
_viewContainer
&
&
ev
.
propertyName
=
=
"
height
"
)
{
window
.
setTimeout
(
(
)
=
>
{
this
.
_viewContainer
.
style
.
removeProperty
(
"
height
"
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
width
"
)
;
}
500
)
;
+
+
seen
;
}
else
if
(
ev
.
target
=
=
nodeToAnimate
&
&
ev
.
propertyName
=
=
"
transform
"
)
{
onTransitionEnd
(
)
;
this
.
_transitioning
=
false
;
window
.
addEventListener
(
"
MozAfterPaint
"
(
)
=
>
{
nodeToAnimate
.
style
.
removeProperty
(
"
border
-
inline
-
start
"
)
;
nodeToAnimate
.
style
.
removeProperty
(
"
transition
"
)
;
nodeToAnimate
.
style
.
removeProperty
(
"
transform
"
)
;
nodeToAnimate
.
style
.
removeProperty
(
"
width
"
)
;
if
(
!
reverse
)
viewNode
.
style
.
removeProperty
(
"
margin
-
inline
-
start
"
)
;
if
(
aAnchor
)
aAnchor
.
removeAttribute
(
"
open
"
)
;
this
.
_viewContainer
.
removeAttribute
(
"
transition
-
reverse
"
)
;
}
{
once
:
true
}
)
;
+
+
seen
;
}
if
(
seen
=
=
2
)
this
.
_viewContainer
.
removeEventListener
(
"
transitionend
"
listener
)
;
}
)
;
}
{
once
:
true
}
)
;
}
else
if
(
!
this
.
panelViews
)
{
this
.
_shiftMainView
(
aAnchor
)
;
this
.
_mainViewHeight
=
this
.
_viewStack
.
clientHeight
;
let
newHeight
=
this
.
_heightOfSubview
(
viewNode
this
.
_subViews
)
;
this
.
_setViewContainerHeight
(
newHeight
)
;
this
.
_subViewObserver
.
observe
(
viewNode
{
attributes
:
true
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
}
}
.
bind
(
this
)
)
;
}
_setViewContainerHeight
(
aHeight
)
{
let
container
=
this
.
_viewContainer
;
this
.
_transitioning
=
true
;
let
onTransitionEnd
=
(
)
=
>
{
container
.
removeEventListener
(
"
transitionend
"
onTransitionEnd
)
;
this
.
_transitioning
=
false
;
}
;
container
.
addEventListener
(
"
transitionend
"
onTransitionEnd
)
;
container
.
style
.
height
=
{
aHeight
}
px
;
}
_shiftMainView
(
aAnchor
)
{
if
(
aAnchor
)
{
let
anchorRect
=
aAnchor
.
getBoundingClientRect
(
)
;
let
mainViewRect
=
this
.
_mainViewContainer
.
getBoundingClientRect
(
)
;
let
center
=
aAnchor
.
clientWidth
/
2
;
let
direction
=
aAnchor
.
ownerGlobal
.
getComputedStyle
(
aAnchor
)
.
direction
;
let
edge
;
if
(
direction
=
=
"
ltr
"
)
{
edge
=
anchorRect
.
left
-
mainViewRect
.
left
;
}
else
{
edge
=
mainViewRect
.
right
-
anchorRect
.
right
;
}
let
cstyle
=
this
.
window
.
getComputedStyle
(
this
.
document
.
documentElement
)
;
let
exitSubViewGutterWidth
=
cstyle
.
getPropertyValue
(
"
-
-
panel
-
ui
-
exit
-
subview
-
gutter
-
width
"
)
;
let
maxShift
=
mainViewRect
.
width
-
parseInt
(
exitSubViewGutterWidth
)
;
let
target
=
Math
.
min
(
maxShift
edge
+
center
)
;
let
neg
=
direction
=
=
"
ltr
"
?
"
-
"
:
"
"
;
this
.
_mainViewContainer
.
style
.
transform
=
translateX
(
{
neg
}
{
target
}
px
)
;
aAnchor
.
setAttribute
(
"
panel
-
multiview
-
anchor
"
true
)
;
}
else
{
this
.
_mainViewContainer
.
style
.
transform
=
"
"
;
if
(
this
.
anchorElement
)
this
.
anchorElement
.
removeAttribute
(
"
panel
-
multiview
-
anchor
"
)
;
}
this
.
anchorElement
=
aAnchor
;
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
.
startsWith
(
"
popup
"
)
&
&
aEvent
.
target
!
=
this
.
_panel
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
click
"
:
if
(
aEvent
.
originalTarget
=
=
this
.
_clickCapturer
)
{
this
.
showMainView
(
)
;
}
break
;
case
"
overflow
"
:
if
(
!
this
.
panelViews
&
&
aEvent
.
target
.
localName
=
=
"
vbox
"
)
{
if
(
this
.
showingSubView
)
{
this
.
window
.
setTimeout
(
this
.
_syncContainerWithSubView
.
bind
(
this
)
0
)
;
}
else
if
(
!
this
.
transitioning
)
{
this
.
window
.
setTimeout
(
this
.
_syncContainerWithMainView
.
bind
(
this
)
0
)
;
}
}
break
;
case
"
popupshowing
"
:
this
.
node
.
setAttribute
(
"
panelopen
"
"
true
"
)
;
this
.
_panel
.
autoPosition
=
false
;
if
(
!
this
.
panelViews
)
{
this
.
_syncContainerWithMainView
(
)
;
this
.
_mainViewObserver
.
observe
(
this
.
_mainView
{
attributes
:
true
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
}
break
;
case
"
popupshown
"
:
this
.
_setMaxHeight
(
)
;
break
;
case
"
popuphidden
"
:
this
.
node
.
removeAttribute
(
"
panelopen
"
)
;
this
.
_mainView
.
style
.
removeProperty
(
"
height
"
)
;
this
.
showMainView
(
)
;
if
(
!
this
.
panelViews
)
this
.
_mainViewObserver
.
disconnect
(
)
;
break
;
}
}
_shouldSetPosition
(
)
{
return
this
.
node
.
getAttribute
(
"
nosubviews
"
)
=
=
"
true
"
;
}
_shouldSetHeight
(
)
{
return
this
.
node
.
getAttribute
(
"
nosubviews
"
)
!
=
"
true
"
;
}
_setMaxHeight
(
)
{
if
(
!
this
.
_shouldSetHeight
(
)
)
return
;
this
.
ignoreMutations
=
true
;
this
.
_mainView
.
style
.
height
=
this
.
node
.
getBoundingClientRect
(
)
.
height
+
"
px
"
;
this
.
ignoreMutations
=
false
;
}
_adjustContainerHeight
(
)
{
if
(
!
this
.
ignoreMutations
&
&
!
this
.
showingSubView
&
&
!
this
.
_transitioning
)
{
let
height
;
if
(
this
.
showingSubViewAsMainView
)
{
height
=
this
.
_heightOfSubview
(
this
.
_mainView
)
;
}
else
{
height
=
this
.
_mainView
.
scrollHeight
;
}
this
.
_viewContainer
.
style
.
height
=
height
+
"
px
"
;
}
}
_syncContainerWithSubView
(
)
{
if
(
!
this
.
_panel
|
|
!
this
.
_panel
.
parentNode
)
{
return
;
}
if
(
!
this
.
ignoreMutations
&
&
this
.
showingSubView
)
{
let
newHeight
=
this
.
_heightOfSubview
(
this
.
_currentSubView
this
.
_subViews
)
;
this
.
_viewContainer
.
style
.
height
=
newHeight
+
"
px
"
;
}
}
_syncContainerWithMainView
(
)
{
if
(
!
this
.
_panel
|
|
!
this
.
_panel
.
parentNode
)
{
return
;
}
if
(
this
.
_shouldSetPosition
(
)
)
{
this
.
_panel
.
adjustArrowPosition
(
)
;
}
if
(
this
.
_shouldSetHeight
(
)
)
{
this
.
_adjustContainerHeight
(
)
;
}
}
setHeightToFit
(
aExpectedChange
)
{
const
{
window
}
=
this
;
let
count
=
5
;
let
height
=
window
.
getComputedStyle
(
this
.
node
)
.
height
;
if
(
aExpectedChange
)
this
.
node
.
style
.
maxHeight
=
(
parseInt
(
height
10
)
+
aExpectedChange
)
+
"
px
"
;
else
this
.
node
.
style
.
maxHeight
=
"
0
"
;
let
interval
=
window
.
setInterval
(
(
)
=
>
{
if
(
height
!
=
window
.
getComputedStyle
(
this
.
node
)
.
height
|
|
-
-
count
=
=
0
)
{
window
.
clearInterval
(
interval
)
;
this
.
node
.
style
.
removeProperty
(
"
max
-
height
"
)
;
}
}
0
)
;
}
_heightOfSubview
(
aSubview
aContainerToCheck
)
{
function
getFullHeight
(
element
)
{
let
height
;
let
elementCS
;
if
(
element
.
scrollTopMax
)
{
height
=
element
.
scrollHeight
;
elementCS
=
win
.
getComputedStyle
(
element
)
;
height
+
=
parseFloat
(
elementCS
.
borderTopWidth
)
+
parseFloat
(
elementCS
.
borderBottomWidth
)
;
}
else
{
height
=
element
.
getBoundingClientRect
(
)
.
height
;
if
(
height
>
0
)
{
elementCS
=
win
.
getComputedStyle
(
element
)
;
}
}
if
(
elementCS
)
{
height
+
=
parseFloat
(
elementCS
.
marginTop
)
+
parseFloat
(
elementCS
.
marginBottom
)
;
}
return
height
;
}
let
win
=
aSubview
.
ownerGlobal
;
let
body
=
aSubview
.
querySelector
(
"
.
panel
-
subview
-
body
"
)
;
let
height
=
getFullHeight
(
body
|
|
aSubview
)
;
if
(
body
)
{
let
header
=
aSubview
.
querySelector
(
"
.
panel
-
subview
-
header
"
)
;
let
footer
=
aSubview
.
querySelector
(
"
.
panel
-
subview
-
footer
"
)
;
height
+
=
(
header
?
getFullHeight
(
header
)
:
0
)
+
(
footer
?
getFullHeight
(
footer
)
:
0
)
;
}
if
(
aContainerToCheck
)
{
let
containerCS
=
win
.
getComputedStyle
(
aContainerToCheck
)
;
height
+
=
parseFloat
(
containerCS
.
paddingTop
)
+
parseFloat
(
containerCS
.
paddingBottom
)
;
}
return
Math
.
ceil
(
height
)
;
}
}
