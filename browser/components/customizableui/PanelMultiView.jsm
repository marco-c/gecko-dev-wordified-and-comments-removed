"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PanelMultiView
"
]
;
this
.
PanelMultiView
=
class
{
get
document
(
)
{
return
this
.
node
.
ownerDocument
;
}
get
window
(
)
{
return
this
.
node
.
ownerGlobal
;
}
get
_panel
(
)
{
return
this
.
node
.
parentNode
;
}
get
showingSubView
(
)
{
return
this
.
_viewStack
.
getAttribute
(
"
viewtype
"
)
=
=
"
subview
"
;
}
get
_mainViewId
(
)
{
return
this
.
node
.
getAttribute
(
"
mainViewId
"
)
;
}
set
_mainViewId
(
val
)
{
this
.
node
.
setAttribute
(
"
mainViewId
"
val
)
;
return
val
;
}
get
_mainView
(
)
{
return
this
.
_mainViewId
?
this
.
document
.
getElementById
(
this
.
_mainViewId
)
:
null
;
}
get
showingSubViewAsMainView
(
)
{
return
this
.
node
.
getAttribute
(
"
mainViewIsSubView
"
)
=
=
"
true
"
;
}
get
ignoreMutations
(
)
{
return
this
.
_ignoreMutations
;
}
set
ignoreMutations
(
val
)
{
this
.
_ignoreMutations
=
val
;
if
(
!
val
&
&
this
.
_panel
.
state
=
=
"
open
"
)
{
if
(
this
.
showingSubView
)
{
this
.
_syncContainerWithSubView
(
)
;
}
else
{
this
.
_syncContainerWithMainView
(
)
;
}
}
}
get
_transitioning
(
)
{
return
this
.
__transitioning
;
}
set
_transitioning
(
val
)
{
this
.
__transitioning
=
val
;
if
(
val
)
{
this
.
node
.
setAttribute
(
"
transitioning
"
"
true
"
)
;
}
else
{
this
.
node
.
removeAttribute
(
"
transitioning
"
)
;
}
}
constructor
(
xulNode
)
{
this
.
node
=
xulNode
;
this
.
_currentSubView
=
this
.
_anchorElement
=
this
.
_subViewObserver
=
null
;
this
.
_mainViewHeight
=
0
;
this
.
__transitioning
=
this
.
_ignoreMutations
=
false
;
const
{
document
window
}
=
this
;
this
.
_clickCapturer
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
clickCapturer
"
)
;
this
.
_viewContainer
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
viewContainer
"
)
;
this
.
_mainViewContainer
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
mainViewContainer
"
)
;
this
.
_subViews
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
subViews
"
)
;
this
.
_viewStack
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
viewStack
"
)
;
this
.
_clickCapturer
.
addEventListener
(
"
click
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popupshown
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
_subViews
.
addEventListener
(
"
overflow
"
this
)
;
this
.
_mainViewContainer
.
addEventListener
(
"
overflow
"
this
)
;
this
.
_subViewObserver
=
new
window
.
MutationObserver
(
this
.
_syncContainerWithSubView
.
bind
(
this
)
)
;
this
.
_mainViewObserver
=
new
window
.
MutationObserver
(
this
.
_syncContainerWithMainView
.
bind
(
this
)
)
;
this
.
_mainViewContainer
.
setAttribute
(
"
panelid
"
this
.
_panel
.
id
)
;
if
(
this
.
_mainView
)
{
this
.
setMainView
(
this
.
_mainView
)
;
}
this
.
node
.
setAttribute
(
"
viewtype
"
"
main
"
)
;
[
"
_mainView
"
"
ignoreMutations
"
"
showingSubView
"
]
.
forEach
(
property
=
>
{
Object
.
defineProperty
(
this
.
node
property
{
enumerable
:
true
get
:
(
)
=
>
this
[
property
]
set
:
(
val
)
=
>
this
[
property
]
=
val
}
)
;
}
)
;
[
"
setHeightToFit
"
"
setMainView
"
"
showMainView
"
"
showSubView
"
]
.
forEach
(
method
=
>
{
Object
.
defineProperty
(
this
.
node
method
{
enumerable
:
true
value
:
(
.
.
.
args
)
=
>
this
[
method
]
(
.
.
.
args
)
}
)
;
}
)
;
}
destructor
(
)
{
if
(
this
.
_mainView
)
{
this
.
_mainView
.
removeAttribute
(
"
mainview
"
)
;
}
this
.
_mainViewObserver
.
disconnect
(
)
;
this
.
_subViewObserver
.
disconnect
(
)
;
this
.
_panel
.
removeEventListener
(
"
popupshowing
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popupshown
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popuphidden
"
this
)
;
this
.
_subViews
.
removeEventListener
(
"
overflow
"
this
)
;
this
.
_mainViewContainer
.
removeEventListener
(
"
overflow
"
this
)
;
this
.
_clickCapturer
.
removeEventListener
(
"
click
"
this
)
;
this
.
node
=
this
.
__clickCapturer
=
this
.
__viewContainer
=
this
.
__mainViewContainer
=
this
.
__subViews
=
this
.
__viewStack
=
null
;
}
setMainView
(
aNewMainView
)
{
if
(
this
.
_mainView
)
{
this
.
_mainViewObserver
.
disconnect
(
)
;
this
.
_subViews
.
appendChild
(
this
.
_mainView
)
;
this
.
_mainView
.
removeAttribute
(
"
mainview
"
)
;
}
this
.
_mainViewId
=
aNewMainView
.
id
;
aNewMainView
.
setAttribute
(
"
mainview
"
"
true
"
)
;
this
.
_mainViewContainer
.
appendChild
(
aNewMainView
)
;
}
showMainView
(
)
{
if
(
this
.
showingSubView
)
{
let
viewNode
=
this
.
_currentSubView
;
let
evt
=
new
this
.
window
.
CustomEvent
(
"
ViewHiding
"
{
bubbles
:
true
cancelable
:
true
}
)
;
viewNode
.
dispatchEvent
(
evt
)
;
viewNode
.
removeAttribute
(
"
current
"
)
;
this
.
_currentSubView
=
null
;
this
.
_subViewObserver
.
disconnect
(
)
;
this
.
_setViewContainerHeight
(
this
.
_mainViewHeight
)
;
this
.
node
.
setAttribute
(
"
viewtype
"
"
main
"
)
;
}
this
.
_shiftMainView
(
)
;
}
showSubView
(
aViewId
aAnchor
)
{
const
{
document
window
}
=
this
;
window
.
Task
.
spawn
(
function
*
(
)
{
let
viewNode
=
this
.
node
.
querySelector
(
"
#
"
+
aViewId
)
;
if
(
!
viewNode
)
{
viewNode
=
document
.
getElementById
(
aViewId
)
;
if
(
viewNode
)
{
this
.
_subViews
.
appendChild
(
viewNode
)
;
}
else
{
throw
new
Error
(
Subview
{
aViewId
}
doesn
'
t
exist
!
)
;
}
}
viewNode
.
setAttribute
(
"
current
"
true
)
;
let
detail
=
{
blockers
:
new
Set
(
)
addBlocker
(
aPromise
)
{
this
.
blockers
.
add
(
aPromise
)
;
}
}
;
let
evt
=
new
window
.
CustomEvent
(
"
ViewShowing
"
{
bubbles
:
true
cancelable
:
true
detail
}
)
;
viewNode
.
dispatchEvent
(
evt
)
;
let
cancel
=
evt
.
defaultPrevented
;
if
(
detail
.
blockers
.
size
)
{
try
{
let
results
=
yield
window
.
Promise
.
all
(
detail
.
blockers
)
;
cancel
=
cancel
|
|
results
.
some
(
val
=
>
val
=
=
=
false
)
;
}
catch
(
e
)
{
Components
.
utils
.
reportError
(
e
)
;
cancel
=
true
;
}
}
if
(
cancel
)
{
return
;
}
this
.
_currentSubView
=
viewNode
;
this
.
node
.
setAttribute
(
"
viewtype
"
"
subview
"
)
;
this
.
_shiftMainView
(
aAnchor
)
;
this
.
_mainViewHeight
=
this
.
_viewStack
.
clientHeight
;
let
newHeight
=
this
.
_heightOfSubview
(
viewNode
this
.
_subViews
)
;
this
.
_setViewContainerHeight
(
newHeight
)
;
this
.
_subViewObserver
.
observe
(
viewNode
{
attributes
:
true
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
}
.
bind
(
this
)
)
;
}
_setViewContainerHeight
(
aHeight
)
{
let
container
=
this
.
_viewContainer
;
this
.
_transitioning
=
true
;
let
onTransitionEnd
=
(
)
=
>
{
container
.
removeEventListener
(
"
transitionend
"
onTransitionEnd
)
;
this
.
_transitioning
=
false
;
}
;
container
.
addEventListener
(
"
transitionend
"
onTransitionEnd
)
;
container
.
style
.
height
=
{
aHeight
}
px
;
}
_shiftMainView
(
aAnchor
)
{
if
(
aAnchor
)
{
let
anchorRect
=
aAnchor
.
getBoundingClientRect
(
)
;
let
mainViewRect
=
this
.
_mainViewContainer
.
getBoundingClientRect
(
)
;
let
center
=
aAnchor
.
clientWidth
/
2
;
let
direction
=
aAnchor
.
ownerGlobal
.
getComputedStyle
(
aAnchor
)
.
direction
;
let
edge
;
if
(
direction
=
=
"
ltr
"
)
{
edge
=
anchorRect
.
left
-
mainViewRect
.
left
;
}
else
{
edge
=
mainViewRect
.
right
-
anchorRect
.
right
;
}
let
cstyle
=
this
.
window
.
getComputedStyle
(
this
.
document
.
documentElement
)
;
let
exitSubViewGutterWidth
=
cstyle
.
getPropertyValue
(
"
-
-
panel
-
ui
-
exit
-
subview
-
gutter
-
width
"
)
;
let
maxShift
=
mainViewRect
.
width
-
parseInt
(
exitSubViewGutterWidth
)
;
let
target
=
Math
.
min
(
maxShift
edge
+
center
)
;
let
neg
=
direction
=
=
"
ltr
"
?
"
-
"
:
"
"
;
this
.
_mainViewContainer
.
style
.
transform
=
translateX
(
{
neg
}
{
target
}
px
)
;
aAnchor
.
setAttribute
(
"
panel
-
multiview
-
anchor
"
true
)
;
}
else
{
this
.
_mainViewContainer
.
style
.
transform
=
"
"
;
if
(
this
.
anchorElement
)
this
.
anchorElement
.
removeAttribute
(
"
panel
-
multiview
-
anchor
"
)
;
}
this
.
anchorElement
=
aAnchor
;
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
.
startsWith
(
"
popup
"
)
&
&
aEvent
.
target
!
=
this
.
_panel
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
click
"
:
if
(
aEvent
.
originalTarget
=
=
this
.
_clickCapturer
)
{
this
.
showMainView
(
)
;
}
break
;
case
"
overflow
"
:
if
(
aEvent
.
target
.
localName
=
=
"
vbox
"
)
{
if
(
this
.
showingSubView
)
{
this
.
window
.
setTimeout
(
this
.
_syncContainerWithSubView
.
bind
(
this
)
0
)
;
}
else
if
(
!
this
.
transitioning
)
{
this
.
window
.
setTimeout
(
this
.
_syncContainerWithMainView
.
bind
(
this
)
0
)
;
}
}
break
;
case
"
popupshowing
"
:
this
.
node
.
setAttribute
(
"
panelopen
"
"
true
"
)
;
this
.
_panel
.
autoPosition
=
false
;
this
.
_syncContainerWithMainView
(
)
;
this
.
_mainViewObserver
.
observe
(
this
.
_mainView
{
attributes
:
true
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
break
;
case
"
popupshown
"
:
this
.
_setMaxHeight
(
)
;
break
;
case
"
popuphidden
"
:
this
.
node
.
removeAttribute
(
"
panelopen
"
)
;
this
.
_mainView
.
style
.
removeProperty
(
"
height
"
)
;
this
.
showMainView
(
)
;
this
.
_mainViewObserver
.
disconnect
(
)
;
break
;
}
}
_shouldSetPosition
(
)
{
return
this
.
node
.
getAttribute
(
"
nosubviews
"
)
=
=
"
true
"
;
}
_shouldSetHeight
(
)
{
return
this
.
node
.
getAttribute
(
"
nosubviews
"
)
!
=
"
true
"
;
}
_setMaxHeight
(
)
{
if
(
!
this
.
_shouldSetHeight
(
)
)
return
;
this
.
ignoreMutations
=
true
;
this
.
_mainView
.
style
.
height
=
this
.
node
.
getBoundingClientRect
(
)
.
height
+
"
px
"
;
this
.
ignoreMutations
=
false
;
}
_adjustContainerHeight
(
)
{
if
(
!
this
.
ignoreMutations
&
&
!
this
.
showingSubView
&
&
!
this
.
_transitioning
)
{
let
height
;
if
(
this
.
showingSubViewAsMainView
)
{
height
=
this
.
_heightOfSubview
(
this
.
_mainView
)
;
}
else
{
height
=
this
.
_mainView
.
scrollHeight
;
}
this
.
_viewContainer
.
style
.
height
=
height
+
"
px
"
;
}
}
_syncContainerWithSubView
(
)
{
if
(
!
this
.
_panel
|
|
!
this
.
_panel
.
parentNode
)
{
return
;
}
if
(
!
this
.
ignoreMutations
&
&
this
.
showingSubView
)
{
let
newHeight
=
this
.
_heightOfSubview
(
this
.
_currentSubView
this
.
_subViews
)
;
this
.
_viewContainer
.
style
.
height
=
newHeight
+
"
px
"
;
}
}
_syncContainerWithMainView
(
)
{
if
(
!
this
.
_panel
|
|
!
this
.
_panel
.
parentNode
)
{
return
;
}
if
(
this
.
_shouldSetPosition
(
)
)
{
this
.
_panel
.
adjustArrowPosition
(
)
;
}
if
(
this
.
_shouldSetHeight
(
)
)
{
this
.
_adjustContainerHeight
(
)
;
}
}
setHeightToFit
(
aExpectedChange
)
{
const
{
window
}
=
this
;
let
count
=
5
;
let
height
=
window
.
getComputedStyle
(
this
.
node
)
.
height
;
if
(
aExpectedChange
)
this
.
node
.
style
.
maxHeight
=
(
parseInt
(
height
10
)
+
aExpectedChange
)
+
"
px
"
;
else
this
.
node
.
style
.
maxHeight
=
"
0
"
;
let
interval
=
window
.
setInterval
(
(
)
=
>
{
if
(
height
!
=
window
.
getComputedStyle
(
this
.
node
)
.
height
|
|
-
-
count
=
=
0
)
{
window
.
clearInterval
(
interval
)
;
this
.
node
.
style
.
removeProperty
(
"
max
-
height
"
)
;
}
}
0
)
;
}
_heightOfSubview
(
aSubview
aContainerToCheck
)
{
function
getFullHeight
(
element
)
{
let
height
;
let
elementCS
;
if
(
element
.
scrollTopMax
)
{
height
=
element
.
scrollHeight
;
elementCS
=
win
.
getComputedStyle
(
element
)
;
height
+
=
parseFloat
(
elementCS
.
borderTopWidth
)
+
parseFloat
(
elementCS
.
borderBottomWidth
)
;
}
else
{
height
=
element
.
getBoundingClientRect
(
)
.
height
;
if
(
height
>
0
)
{
elementCS
=
win
.
getComputedStyle
(
element
)
;
}
}
if
(
elementCS
)
{
height
+
=
parseFloat
(
elementCS
.
marginTop
)
+
parseFloat
(
elementCS
.
marginBottom
)
;
}
return
height
;
}
let
win
=
aSubview
.
ownerGlobal
;
let
body
=
aSubview
.
querySelector
(
"
.
panel
-
subview
-
body
"
)
;
let
height
=
getFullHeight
(
body
|
|
aSubview
)
;
if
(
body
)
{
let
header
=
aSubview
.
querySelector
(
"
.
panel
-
subview
-
header
"
)
;
let
footer
=
aSubview
.
querySelector
(
"
.
panel
-
subview
-
footer
"
)
;
height
+
=
(
header
?
getFullHeight
(
header
)
:
0
)
+
(
footer
?
getFullHeight
(
footer
)
:
0
)
;
}
if
(
aContainerToCheck
)
{
let
containerCS
=
win
.
getComputedStyle
(
aContainerToCheck
)
;
height
+
=
parseFloat
(
containerCS
.
paddingTop
)
+
parseFloat
(
containerCS
.
paddingBottom
)
;
}
return
Math
.
ceil
(
height
)
;
}
}
