"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
PanelMultiView
"
"
PanelView
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
const
TRANSITION_PHASES
=
Object
.
freeze
(
{
START
:
1
PREPARE
:
2
TRANSITION
:
3
END
:
4
}
)
;
let
gNodeToObjectMap
=
new
WeakMap
(
)
;
let
gMultiLineElementsMap
=
new
WeakMap
(
)
;
this
.
AssociatedToNode
=
class
{
constructor
(
node
)
{
this
.
node
=
node
;
}
static
forNode
(
node
)
{
let
associatedToNode
=
gNodeToObjectMap
.
get
(
node
)
;
if
(
!
associatedToNode
)
{
associatedToNode
=
new
this
(
node
)
;
gNodeToObjectMap
.
set
(
node
associatedToNode
)
;
}
return
associatedToNode
;
}
get
document
(
)
{
return
this
.
node
.
ownerDocument
;
}
get
window
(
)
{
return
this
.
node
.
ownerGlobal
;
}
get
_dwu
(
)
{
if
(
this
.
__dwu
)
return
this
.
__dwu
;
return
this
.
__dwu
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
dispatchCustomEvent
(
eventName
detail
cancelable
=
false
)
{
let
event
=
new
this
.
window
.
CustomEvent
(
eventName
{
detail
bubbles
:
true
cancelable
}
)
;
this
.
node
.
dispatchEvent
(
event
)
;
return
event
.
defaultPrevented
;
}
}
;
this
.
PanelMultiView
=
class
extends
this
.
AssociatedToNode
{
get
_panel
(
)
{
return
this
.
node
.
parentNode
;
}
get
_mainViewId
(
)
{
return
this
.
node
.
getAttribute
(
"
mainViewId
"
)
;
}
get
_mainView
(
)
{
return
this
.
document
.
getElementById
(
this
.
_mainViewId
)
;
}
get
_transitioning
(
)
{
return
this
.
__transitioning
;
}
set
_transitioning
(
val
)
{
this
.
__transitioning
=
val
;
if
(
val
)
{
this
.
node
.
setAttribute
(
"
transitioning
"
"
true
"
)
;
}
else
{
this
.
node
.
removeAttribute
(
"
transitioning
"
)
;
}
}
get
_ephemeral
(
)
{
return
this
.
node
.
hasAttribute
(
"
ephemeral
"
)
;
}
get
_screenManager
(
)
{
if
(
this
.
__screenManager
)
return
this
.
__screenManager
;
return
this
.
__screenManager
=
Cc
[
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
]
.
getService
(
Ci
.
nsIScreenManager
)
;
}
get
current
(
)
{
return
this
.
node
&
&
(
this
.
_viewShowing
|
|
this
.
_currentSubView
)
;
}
get
_currentSubView
(
)
{
let
panelView
=
this
.
openViews
[
this
.
openViews
.
length
-
1
]
;
return
(
panelView
&
&
panelView
.
node
)
|
|
this
.
_mainView
;
}
get
currentShowPromise
(
)
{
return
this
.
_currentShowPromise
|
|
Promise
.
resolve
(
)
;
}
get
_keyNavigationMap
(
)
{
if
(
!
this
.
__keyNavigationMap
)
this
.
__keyNavigationMap
=
new
Map
(
)
;
return
this
.
__keyNavigationMap
;
}
connect
(
)
{
this
.
knownViews
=
new
Set
(
Array
.
from
(
this
.
node
.
getElementsByTagName
(
"
panelview
"
)
node
=
>
PanelView
.
forNode
(
node
)
)
)
;
this
.
openViews
=
[
]
;
this
.
_mainViewHeight
=
0
;
this
.
__transitioning
=
false
;
this
.
showingSubView
=
false
;
const
{
document
window
}
=
this
;
this
.
_viewContainer
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
viewContainer
"
)
;
this
.
_viewStack
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
viewStack
"
)
;
this
.
_offscreenViewStack
=
document
.
getAnonymousElementByAttribute
(
this
.
node
"
anonid
"
"
offscreenViewStack
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_panelViewCache
"
(
)
=
>
{
let
viewCacheId
=
this
.
node
.
getAttribute
(
"
viewCacheId
"
)
;
return
viewCacheId
?
document
.
getElementById
(
viewCacheId
)
:
null
;
}
)
;
this
.
_panel
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popuppositioned
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
_panel
.
addEventListener
(
"
popupshown
"
this
)
;
let
cs
=
window
.
getComputedStyle
(
document
.
documentElement
)
;
this
.
_dir
=
cs
.
direction
;
this
.
showMainView
(
)
;
[
"
goBack
"
"
showMainView
"
"
showSubView
"
]
.
forEach
(
method
=
>
{
Object
.
defineProperty
(
this
.
node
method
{
enumerable
:
true
value
:
(
.
.
.
args
)
=
>
this
[
method
]
(
.
.
.
args
)
}
)
;
}
)
;
[
"
current
"
"
currentShowPromise
"
"
showingSubView
"
]
.
forEach
(
property
=
>
{
Object
.
defineProperty
(
this
.
node
property
{
enumerable
:
true
get
:
(
)
=
>
this
[
property
]
}
)
;
}
)
;
}
destructor
(
)
{
if
(
!
this
.
node
)
return
;
this
.
_cleanupTransitionPhase
(
)
;
if
(
this
.
_ephemeral
)
this
.
hideAllViewsExcept
(
null
)
;
let
mainView
=
this
.
_mainView
;
if
(
mainView
)
{
if
(
this
.
_panelViewCache
)
this
.
_panelViewCache
.
appendChild
(
mainView
)
;
mainView
.
removeAttribute
(
"
mainview
"
)
;
}
this
.
_moveOutKids
(
this
.
_viewStack
)
;
this
.
_panel
.
removeEventListener
(
"
mousemove
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popupshowing
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popuppositioned
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popupshown
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
popuphidden
"
this
)
;
this
.
window
.
removeEventListener
(
"
keydown
"
this
)
;
this
.
node
=
this
.
_viewContainer
=
this
.
_viewStack
=
this
.
__dwu
=
this
.
_panelViewCache
=
this
.
_transitionDetails
=
null
;
}
_moveOutKids
(
viewNodeContainer
)
{
if
(
!
this
.
_panelViewCache
)
return
;
let
subviews
=
Array
.
from
(
viewNodeContainer
.
childNodes
)
;
for
(
let
subview
of
subviews
)
{
if
(
subview
.
nodeName
!
=
"
children
"
)
this
.
_panelViewCache
.
appendChild
(
subview
)
;
}
}
goBack
(
)
{
let
previous
=
this
.
openViews
.
pop
(
)
.
node
;
let
current
=
this
.
_currentSubView
;
return
this
.
showSubView
(
current
null
previous
)
;
}
_canGoBack
(
view
=
this
.
_currentSubView
)
{
return
view
.
id
!
=
this
.
_mainViewId
;
}
showMainView
(
)
{
if
(
!
this
.
node
|
|
!
this
.
_mainViewId
)
return
Promise
.
resolve
(
)
;
return
this
.
showSubView
(
this
.
_mainView
)
;
}
hideAllViewsExcept
(
nextPanelView
=
null
)
{
for
(
let
panelView
of
this
.
knownViews
)
{
if
(
panelView
=
=
nextPanelView
|
|
!
this
.
node
|
|
panelView
.
node
.
panelMultiView
!
=
this
.
node
)
continue
;
panelView
.
current
=
false
;
}
this
.
_viewShowing
=
null
;
if
(
!
this
.
node
|
|
!
nextPanelView
)
return
;
if
(
!
this
.
openViews
.
includes
(
nextPanelView
)
)
this
.
openViews
.
push
(
nextPanelView
)
;
nextPanelView
.
current
=
true
;
this
.
showingSubView
=
nextPanelView
.
node
.
id
!
=
this
.
_mainViewId
;
}
showSubView
(
aViewId
aAnchor
aPreviousView
)
{
this
.
_currentShowPromise
=
(
async
(
)
=
>
{
let
viewNode
=
typeof
aViewId
=
=
"
string
"
?
this
.
node
.
querySelector
(
"
#
"
+
aViewId
)
:
aViewId
;
if
(
!
viewNode
)
{
viewNode
=
this
.
document
.
getElementById
(
aViewId
)
;
if
(
viewNode
)
{
this
.
_viewStack
.
appendChild
(
viewNode
)
;
}
else
{
throw
new
Error
(
Subview
{
aViewId
}
doesn
'
t
exist
!
)
;
}
}
else
if
(
viewNode
.
parentNode
=
=
this
.
_panelViewCache
)
{
this
.
_viewStack
.
appendChild
(
viewNode
)
;
}
let
nextPanelView
=
PanelView
.
forNode
(
viewNode
)
;
this
.
knownViews
.
add
(
nextPanelView
)
;
viewNode
.
panelMultiView
=
this
.
node
;
let
reverse
=
!
!
aPreviousView
;
if
(
!
reverse
)
{
nextPanelView
.
headerText
=
viewNode
.
getAttribute
(
"
title
"
)
|
|
(
aAnchor
&
&
aAnchor
.
getAttribute
(
"
label
"
)
)
;
}
let
previousViewNode
=
aPreviousView
|
|
this
.
_currentSubView
;
let
showingSameView
=
viewNode
=
=
previousViewNode
;
let
playTransition
=
(
!
!
previousViewNode
&
&
!
showingSameView
&
&
this
.
_panel
.
state
=
=
"
open
"
)
;
let
isMainView
=
viewNode
.
id
=
=
this
.
_mainViewId
;
let
previousRect
=
previousViewNode
.
__lastKnownBoundingRect
=
this
.
_dwu
.
getBoundsWithoutFlushing
(
previousViewNode
)
;
if
(
!
this
.
_mainViewWidth
)
{
this
.
_mainViewWidth
=
previousRect
.
width
;
}
if
(
!
this
.
_mainViewHeight
)
{
this
.
_mainViewHeight
=
previousRect
.
height
;
this
.
_viewContainer
.
style
.
minHeight
=
this
.
_mainViewHeight
+
"
px
"
;
}
this
.
_viewShowing
=
viewNode
;
nextPanelView
.
mainview
=
isMainView
;
if
(
aAnchor
)
{
viewNode
.
classList
.
add
(
"
PanelUI
-
subView
"
)
;
}
if
(
!
isMainView
&
&
this
.
_mainViewWidth
)
viewNode
.
style
.
maxWidth
=
viewNode
.
style
.
minWidth
=
this
.
_mainViewWidth
+
"
px
"
;
if
(
!
showingSameView
|
|
!
viewNode
.
hasAttribute
(
"
current
"
)
)
{
let
detail
=
{
blockers
:
new
Set
(
)
addBlocker
(
promise
)
{
this
.
blockers
.
add
(
promise
)
;
}
}
;
let
cancel
=
nextPanelView
.
dispatchCustomEvent
(
"
ViewShowing
"
detail
true
)
;
if
(
detail
.
blockers
.
size
)
{
try
{
let
results
=
await
Promise
.
all
(
detail
.
blockers
)
;
cancel
=
cancel
|
|
results
.
some
(
val
=
>
val
=
=
=
false
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
cancel
=
true
;
}
}
if
(
cancel
)
{
this
.
_viewShowing
=
null
;
return
;
}
}
await
this
.
_cleanupTransitionPhase
(
)
;
if
(
playTransition
)
{
await
this
.
_transitionViews
(
previousViewNode
viewNode
reverse
previousRect
aAnchor
)
;
this
.
_updateKeyboardFocus
(
viewNode
)
;
}
else
{
this
.
hideAllViewsExcept
(
nextPanelView
)
;
}
}
)
(
)
.
catch
(
e
=
>
Cu
.
reportError
(
e
)
)
;
return
this
.
_currentShowPromise
;
}
async
_transitionViews
(
previousViewNode
viewNode
reverse
previousRect
anchor
)
{
if
(
this
.
_panel
.
state
!
=
"
open
"
)
{
return
;
}
const
{
window
document
}
=
this
;
let
nextPanelView
=
PanelView
.
forNode
(
viewNode
)
;
if
(
this
.
_autoResizeWorkaroundTimer
)
window
.
clearTimeout
(
this
.
_autoResizeWorkaroundTimer
)
;
let
details
=
this
.
_transitionDetails
=
{
phase
:
TRANSITION_PHASES
.
START
previousViewNode
viewNode
reverse
anchor
}
;
if
(
anchor
)
anchor
.
setAttribute
(
"
open
"
"
true
"
)
;
previousViewNode
.
setAttribute
(
"
in
-
transition
"
true
)
;
this
.
_viewContainer
.
style
.
height
=
Math
.
max
(
previousRect
.
height
this
.
_mainViewHeight
)
+
"
px
"
;
this
.
_viewContainer
.
style
.
width
=
previousRect
.
width
+
"
px
"
;
let
rect
=
this
.
_panel
.
popupBoxObject
.
getOuterScreenRect
(
)
;
this
.
_panel
.
setAttribute
(
"
width
"
rect
.
width
)
;
this
.
_panel
.
setAttribute
(
"
height
"
rect
.
height
)
;
let
viewRect
;
if
(
reverse
&
&
viewNode
.
__lastKnownBoundingRect
)
{
viewRect
=
viewNode
.
__lastKnownBoundingRect
;
viewNode
.
setAttribute
(
"
in
-
transition
"
true
)
;
}
else
if
(
viewNode
.
customRectGetter
)
{
let
{
height
width
}
=
previousRect
;
viewRect
=
Object
.
assign
(
{
height
width
}
viewNode
.
customRectGetter
(
)
)
;
let
header
=
viewNode
.
firstChild
;
if
(
header
&
&
header
.
classList
.
contains
(
"
panel
-
header
"
)
)
{
viewRect
.
height
+
=
this
.
_dwu
.
getBoundsWithoutFlushing
(
header
)
.
height
;
}
viewNode
.
setAttribute
(
"
in
-
transition
"
true
)
;
}
else
{
let
oldSibling
=
viewNode
.
nextSibling
|
|
null
;
this
.
_offscreenViewStack
.
style
.
minHeight
=
this
.
_viewContainer
.
style
.
height
;
this
.
_offscreenViewStack
.
appendChild
(
viewNode
)
;
viewNode
.
setAttribute
(
"
in
-
transition
"
true
)
;
nextPanelView
.
descriptionHeightWorkaround
(
)
;
viewRect
=
await
BrowserUtils
.
promiseLayoutFlushed
(
this
.
document
"
layout
"
(
)
=
>
{
return
this
.
_dwu
.
getBoundsWithoutFlushing
(
viewNode
)
;
}
)
;
try
{
this
.
_viewStack
.
insertBefore
(
viewNode
oldSibling
)
;
}
catch
(
ex
)
{
this
.
_viewStack
.
appendChild
(
viewNode
)
;
}
this
.
_offscreenViewStack
.
style
.
removeProperty
(
"
min
-
height
"
)
;
}
this
.
_transitioning
=
true
;
details
.
phase
=
TRANSITION_PHASES
.
PREPARE
;
let
moveToLeft
=
(
this
.
_dir
=
=
"
rtl
"
&
&
!
reverse
)
|
|
(
this
.
_dir
=
=
"
ltr
"
&
&
reverse
)
;
let
deltaX
=
previousRect
.
width
;
let
deepestNode
=
reverse
?
previousViewNode
:
viewNode
;
if
(
reverse
)
this
.
_viewStack
.
style
.
marginInlineStart
=
"
-
"
+
deltaX
+
"
px
"
;
this
.
_viewStack
.
style
.
transition
=
"
transform
var
(
-
-
animation
-
easing
-
function
)
"
+
"
var
(
-
-
panelui
-
subview
-
transition
-
duration
)
"
;
this
.
_viewStack
.
style
.
willChange
=
"
transform
"
;
deepestNode
.
style
.
outline
=
"
1px
solid
var
(
-
-
panel
-
separator
-
color
)
"
;
this
.
_viewContainer
.
style
.
height
=
Math
.
max
(
viewRect
.
height
this
.
_mainViewHeight
)
+
"
px
"
;
this
.
_viewContainer
.
style
.
width
=
viewRect
.
width
+
"
px
"
;
this
.
_panel
.
removeAttribute
(
"
width
"
)
;
this
.
_panel
.
removeAttribute
(
"
height
"
)
;
viewNode
.
style
.
width
=
viewRect
.
width
+
"
px
"
;
await
BrowserUtils
.
promiseLayoutFlushed
(
document
"
layout
"
(
)
=
>
{
}
)
;
details
.
phase
=
TRANSITION_PHASES
.
TRANSITION
;
this
.
_viewStack
.
style
.
transform
=
"
translateX
(
"
+
(
moveToLeft
?
"
"
:
"
-
"
)
+
deltaX
+
"
px
)
"
;
await
new
Promise
(
resolve
=
>
{
details
.
resolve
=
resolve
;
this
.
_viewContainer
.
addEventListener
(
"
transitionend
"
details
.
listener
=
ev
=
>
{
if
(
ev
.
target
!
=
this
.
_viewStack
|
|
ev
.
propertyName
!
=
"
transform
"
)
return
;
this
.
_viewContainer
.
removeEventListener
(
"
transitionend
"
details
.
listener
)
;
delete
details
.
listener
;
resolve
(
)
;
}
)
;
this
.
_viewContainer
.
addEventListener
(
"
transitioncancel
"
details
.
cancelListener
=
ev
=
>
{
if
(
ev
.
target
!
=
this
.
_viewStack
)
return
;
this
.
_viewContainer
.
removeEventListener
(
"
transitioncancel
"
details
.
cancelListener
)
;
delete
details
.
cancelListener
;
resolve
(
)
;
}
)
;
}
)
;
details
.
phase
=
TRANSITION_PHASES
.
END
;
await
this
.
_cleanupTransitionPhase
(
details
)
;
}
async
_cleanupTransitionPhase
(
details
=
this
.
_transitionDetails
)
{
if
(
!
details
|
|
!
this
.
node
)
return
;
let
{
phase
previousViewNode
viewNode
reverse
resolve
listener
cancelListener
anchor
}
=
details
;
if
(
details
=
=
this
.
_transitionDetails
)
this
.
_transitionDetails
=
null
;
let
nextPanelView
=
PanelView
.
forNode
(
viewNode
)
;
this
.
hideAllViewsExcept
(
nextPanelView
)
;
previousViewNode
.
removeAttribute
(
"
in
-
transition
"
)
;
viewNode
.
removeAttribute
(
"
in
-
transition
"
)
;
if
(
reverse
)
this
.
_resetKeyNavigation
(
previousViewNode
)
;
if
(
anchor
)
anchor
.
removeAttribute
(
"
open
"
)
;
if
(
phase
>
=
TRANSITION_PHASES
.
START
)
{
this
.
_panel
.
removeAttribute
(
"
width
"
)
;
this
.
_panel
.
removeAttribute
(
"
height
"
)
;
this
.
_autoResizeWorkaroundTimer
=
this
.
window
.
setTimeout
(
(
)
=
>
{
if
(
!
this
.
_viewContainer
)
return
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
height
"
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
width
"
)
;
}
500
)
;
}
if
(
phase
>
=
TRANSITION_PHASES
.
PREPARE
)
{
this
.
_transitioning
=
false
;
if
(
reverse
)
this
.
_viewStack
.
style
.
removeProperty
(
"
margin
-
inline
-
start
"
)
;
let
deepestNode
=
reverse
?
previousViewNode
:
viewNode
;
deepestNode
.
style
.
removeProperty
(
"
outline
"
)
;
this
.
_viewStack
.
style
.
removeProperty
(
"
transition
"
)
;
}
if
(
phase
>
=
TRANSITION_PHASES
.
TRANSITION
)
{
this
.
_viewStack
.
style
.
removeProperty
(
"
transform
"
)
;
viewNode
.
style
.
removeProperty
(
"
width
"
)
;
if
(
listener
)
this
.
_viewContainer
.
removeEventListener
(
"
transitionend
"
listener
)
;
if
(
cancelListener
)
this
.
_viewContainer
.
removeEventListener
(
"
transitioncancel
"
cancelListener
)
;
if
(
resolve
)
resolve
(
)
;
}
if
(
phase
>
=
TRANSITION_PHASES
.
END
)
{
previousViewNode
.
style
.
display
=
"
none
"
;
await
BrowserUtils
.
promiseLayoutFlushed
(
this
.
document
"
layout
"
(
)
=
>
{
}
)
;
previousViewNode
.
style
.
removeProperty
(
"
display
"
)
;
}
}
_calculateMaxHeight
(
)
{
let
anchorBox
=
this
.
_panel
.
anchorNode
.
boxObject
;
let
screen
=
this
.
_screenManager
.
screenForRect
(
anchorBox
.
screenX
anchorBox
.
screenY
anchorBox
.
width
anchorBox
.
height
)
;
let
availTop
=
{
}
availHeight
=
{
}
;
screen
.
GetAvailRect
(
{
}
availTop
{
}
availHeight
)
;
let
cssAvailTop
=
availTop
.
value
/
screen
.
defaultCSSScaleFactor
;
let
maxHeight
;
if
(
this
.
_panel
.
alignmentPosition
.
startsWith
(
"
before_
"
)
)
{
maxHeight
=
anchorBox
.
screenY
-
cssAvailTop
;
}
else
{
let
anchorScreenBottom
=
anchorBox
.
screenY
+
anchorBox
.
height
;
let
cssAvailHeight
=
availHeight
.
value
/
screen
.
defaultCSSScaleFactor
;
maxHeight
=
cssAvailTop
+
cssAvailHeight
-
anchorScreenBottom
;
}
const
EXTRA_MARGIN_PX
=
20
;
maxHeight
-
=
EXTRA_MARGIN_PX
;
return
maxHeight
;
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
.
startsWith
(
"
popup
"
)
&
&
aEvent
.
target
!
=
this
.
_panel
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
keydown
"
:
this
.
_keyNavigation
(
aEvent
)
;
break
;
case
"
mousemove
"
:
this
.
_resetKeyNavigation
(
)
;
break
;
case
"
popupshowing
"
:
{
this
.
node
.
setAttribute
(
"
panelopen
"
"
true
"
)
;
if
(
!
this
.
node
.
hasAttribute
(
"
disablekeynav
"
)
)
{
this
.
window
.
addEventListener
(
"
keydown
"
this
)
;
this
.
_panel
.
addEventListener
(
"
mousemove
"
this
)
;
}
break
;
}
case
"
popuppositioned
"
:
{
this
.
_panel
.
autoPosition
=
false
;
if
(
this
.
_panel
.
state
=
=
"
showing
"
)
{
let
maxHeight
=
this
.
_calculateMaxHeight
(
)
;
this
.
_viewStack
.
style
.
maxHeight
=
maxHeight
+
"
px
"
;
this
.
_offscreenViewStack
.
style
.
maxHeight
=
maxHeight
+
"
px
"
;
}
break
;
}
case
"
popupshown
"
:
PanelView
.
forNode
(
this
.
_mainView
)
.
descriptionHeightWorkaround
(
)
;
break
;
case
"
popuphidden
"
:
{
this
.
_viewShowing
=
null
;
this
.
_transitioning
=
false
;
this
.
node
.
removeAttribute
(
"
panelopen
"
)
;
this
.
showMainView
(
)
;
for
(
let
panelView
of
this
.
_viewStack
.
children
)
{
if
(
panelView
.
nodeName
!
=
"
children
"
)
{
panelView
.
__lastKnownBoundingRect
=
null
;
panelView
.
style
.
removeProperty
(
"
min
-
width
"
)
;
panelView
.
style
.
removeProperty
(
"
max
-
width
"
)
;
}
}
this
.
window
.
removeEventListener
(
"
keydown
"
this
)
;
this
.
_panel
.
removeEventListener
(
"
mousemove
"
this
)
;
this
.
_resetKeyNavigation
(
)
;
this
.
openViews
=
[
]
;
this
.
_mainViewHeight
=
0
;
this
.
_mainViewWidth
=
0
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
min
-
height
"
)
;
this
.
_viewStack
.
style
.
removeProperty
(
"
max
-
height
"
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
min
-
width
"
)
;
this
.
_viewContainer
.
style
.
removeProperty
(
"
max
-
width
"
)
;
this
.
dispatchCustomEvent
(
"
PanelMultiViewHidden
"
)
;
break
;
}
}
}
_updateSelectedKeyNav
(
navMap
buttons
isDown
)
{
let
lastSelected
=
navMap
.
selected
&
&
navMap
.
selected
.
get
(
)
;
let
newButton
=
null
;
let
maxIdx
=
buttons
.
length
-
1
;
if
(
lastSelected
)
{
let
buttonIndex
=
buttons
.
indexOf
(
lastSelected
)
;
if
(
buttonIndex
!
=
-
1
)
{
do
{
buttonIndex
=
buttonIndex
+
(
isDown
?
1
:
-
1
)
;
}
while
(
buttons
[
buttonIndex
]
&
&
buttons
[
buttonIndex
]
.
disabled
)
;
if
(
isDown
&
&
buttonIndex
>
maxIdx
)
buttonIndex
=
0
;
else
if
(
!
isDown
&
&
buttonIndex
<
0
)
buttonIndex
=
maxIdx
;
newButton
=
buttons
[
buttonIndex
]
;
}
else
{
let
allButtons
=
lastSelected
.
closest
(
"
panelview
"
)
.
getElementsByTagName
(
"
toolbarbutton
"
)
;
let
maxAllButtonIdx
=
allButtons
.
length
-
1
;
let
allButtonIndex
=
allButtons
.
indexOf
(
lastSelected
)
;
while
(
allButtonIndex
>
=
0
&
&
allButtonIndex
<
=
maxAllButtonIdx
)
{
allButtonIndex
+
+
;
buttonIndex
=
buttons
.
indexOf
(
allButtons
[
allButtonIndex
]
)
;
if
(
buttonIndex
!
=
-
1
)
{
newButton
=
buttons
[
isDown
?
buttonIndex
:
buttonIndex
-
1
]
;
break
;
}
}
}
}
if
(
!
newButton
)
{
newButton
=
buttons
[
isDown
?
0
:
maxIdx
]
;
}
navMap
.
selected
=
Cu
.
getWeakReference
(
newButton
)
;
return
newButton
;
}
_keyNavigation
(
event
)
{
if
(
this
.
_transitioning
)
return
;
let
view
=
this
.
_currentSubView
;
let
navMap
=
this
.
_keyNavigationMap
.
get
(
view
)
;
if
(
!
navMap
)
{
navMap
=
{
}
;
this
.
_keyNavigationMap
.
set
(
view
navMap
)
;
}
let
buttons
=
navMap
.
buttons
;
if
(
!
buttons
|
|
!
buttons
.
length
)
{
buttons
=
navMap
.
buttons
=
PanelView
.
forNode
(
view
)
.
getNavigableElements
(
)
;
for
(
let
button
of
buttons
)
{
if
(
!
button
.
classList
.
contains
(
"
subviewbutton
-
back
"
)
&
&
!
button
.
hasAttribute
(
"
tabindex
"
)
)
{
button
.
setAttribute
(
"
tabindex
"
0
)
;
}
}
}
if
(
!
buttons
.
length
)
return
;
let
stop
=
(
)
=
>
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
;
let
keyCode
=
event
.
code
;
switch
(
keyCode
)
{
case
"
ArrowDown
"
:
case
"
ArrowUp
"
:
case
"
Tab
"
:
{
stop
(
)
;
let
isDown
=
(
keyCode
=
=
"
ArrowDown
"
)
|
|
(
keyCode
=
=
"
Tab
"
&
&
!
event
.
shiftKey
)
;
let
button
=
this
.
_updateSelectedKeyNav
(
navMap
buttons
isDown
)
;
button
.
focus
(
)
;
break
;
}
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
{
stop
(
)
;
let
dir
=
this
.
_dir
;
if
(
(
dir
=
=
"
ltr
"
&
&
keyCode
=
=
"
ArrowLeft
"
)
|
|
(
dir
=
=
"
rtl
"
&
&
keyCode
=
=
"
ArrowRight
"
)
)
{
if
(
this
.
_canGoBack
(
view
)
)
this
.
goBack
(
)
;
break
;
}
if
(
!
navMap
.
selected
|
|
!
navMap
.
selected
.
get
(
)
|
|
!
navMap
.
selected
.
get
(
)
.
classList
.
contains
(
"
subviewbutton
-
nav
"
)
)
{
break
;
}
}
case
"
Space
"
:
case
"
Enter
"
:
{
let
button
=
navMap
.
selected
&
&
navMap
.
selected
.
get
(
)
;
if
(
!
button
)
break
;
stop
(
)
;
button
.
doCommand
(
)
;
let
clickEvent
=
new
event
.
target
.
ownerGlobal
.
MouseEvent
(
"
click
"
{
"
bubbles
"
:
true
}
)
;
button
.
dispatchEvent
(
clickEvent
)
;
break
;
}
}
}
_resetKeyNavigation
(
view
)
{
let
viewToBlur
=
view
|
|
this
.
_currentSubView
;
let
navMap
=
this
.
_keyNavigationMap
.
get
(
viewToBlur
)
;
if
(
navMap
&
&
navMap
.
selected
&
&
navMap
.
selected
.
get
(
)
)
{
navMap
.
selected
.
get
(
)
.
blur
(
)
;
}
if
(
view
)
{
this
.
_keyNavigationMap
.
delete
(
view
)
;
}
else
{
this
.
_keyNavigationMap
.
clear
(
)
;
}
}
_updateKeyboardFocus
(
view
)
{
let
navMap
=
this
.
_keyNavigationMap
.
get
(
view
)
;
if
(
navMap
&
&
navMap
.
selected
&
&
navMap
.
selected
.
get
(
)
)
{
navMap
.
selected
.
get
(
)
.
focus
(
)
;
}
}
}
;
this
.
PanelView
=
class
extends
this
.
AssociatedToNode
{
set
mainview
(
value
)
{
if
(
value
)
{
this
.
node
.
setAttribute
(
"
mainview
"
true
)
;
}
else
{
this
.
node
.
removeAttribute
(
"
mainview
"
)
;
}
}
set
current
(
value
)
{
if
(
value
)
{
if
(
!
this
.
node
.
hasAttribute
(
"
current
"
)
)
{
this
.
node
.
setAttribute
(
"
current
"
true
)
;
this
.
descriptionHeightWorkaround
(
)
;
this
.
dispatchCustomEvent
(
"
ViewShown
"
)
;
}
}
else
if
(
this
.
node
.
hasAttribute
(
"
current
"
)
)
{
this
.
dispatchCustomEvent
(
"
ViewHiding
"
)
;
this
.
node
.
removeAttribute
(
"
current
"
)
;
}
}
set
headerText
(
value
)
{
let
header
=
this
.
node
.
firstChild
;
if
(
header
&
&
header
.
classList
.
contains
(
"
panel
-
header
"
)
)
{
if
(
value
)
{
header
.
querySelector
(
"
label
"
)
.
setAttribute
(
"
value
"
value
)
;
}
else
{
header
.
remove
(
)
;
}
return
;
}
if
(
!
value
)
{
return
;
}
header
=
this
.
document
.
createElement
(
"
box
"
)
;
header
.
classList
.
add
(
"
panel
-
header
"
)
;
let
backButton
=
this
.
document
.
createElement
(
"
toolbarbutton
"
)
;
backButton
.
className
=
"
subviewbutton
subviewbutton
-
iconic
subviewbutton
-
back
"
;
backButton
.
setAttribute
(
"
closemenu
"
"
none
"
)
;
backButton
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
backButton
.
setAttribute
(
"
tooltip
"
this
.
node
.
getAttribute
(
"
data
-
subviewbutton
-
tooltip
"
)
)
;
backButton
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
node
.
panelMultiView
.
goBack
(
)
;
backButton
.
blur
(
)
;
}
)
;
let
label
=
this
.
document
.
createElement
(
"
label
"
)
;
label
.
setAttribute
(
"
value
"
value
)
;
header
.
append
(
backButton
label
)
;
this
.
node
.
prepend
(
header
)
;
}
dispatchCustomEvent
(
.
.
.
args
)
{
CustomizableUI
.
ensureSubviewListeners
(
this
.
node
)
;
return
super
.
dispatchCustomEvent
(
.
.
.
args
)
;
}
descriptionHeightWorkaround
(
)
{
if
(
!
this
.
node
.
hasAttribute
(
"
descriptionheightworkaround
"
)
)
{
return
;
}
let
items
=
[
]
;
let
isMultiline
=
"
:
not
(
:
-
moz
-
any
(
[
hidden
]
[
value
]
:
empty
)
)
"
;
let
selector
=
[
"
description
"
+
isMultiline
"
label
"
+
isMultiline
"
toolbarbutton
[
wrap
]
:
not
(
[
hidden
]
)
"
]
.
join
(
"
"
)
;
for
(
let
element
of
this
.
node
.
querySelectorAll
(
selector
)
)
{
if
(
element
.
closest
(
"
[
hidden
]
"
)
)
{
continue
;
}
element
=
element
.
labelElement
|
|
element
;
let
bounds
=
element
.
getBoundingClientRect
(
)
;
let
previous
=
gMultiLineElementsMap
.
get
(
element
)
;
if
(
!
bounds
.
width
|
|
!
bounds
.
height
|
|
(
previous
&
&
element
.
textContent
=
=
previous
.
textContent
&
&
bounds
.
width
=
=
previous
.
bounds
.
width
)
)
{
continue
;
}
items
.
push
(
{
element
}
)
;
}
for
(
let
item
of
items
)
{
item
.
element
.
style
.
removeProperty
(
"
height
"
)
;
}
for
(
let
item
of
items
)
{
item
.
bounds
=
item
.
element
.
getBoundingClientRect
(
)
;
}
for
(
let
{
element
bounds
}
of
items
)
{
gMultiLineElementsMap
.
set
(
element
{
bounds
textContent
:
element
.
textContent
}
)
;
element
.
style
.
height
=
bounds
.
height
+
"
px
"
;
}
}
getNavigableElements
(
)
{
let
buttons
=
Array
.
from
(
this
.
node
.
querySelectorAll
(
"
.
subviewbutton
:
not
(
[
disabled
]
)
"
)
)
;
let
dwu
=
this
.
_dwu
;
return
buttons
.
filter
(
button
=
>
{
let
bounds
=
dwu
.
getBoundsWithoutFlushing
(
button
)
;
return
bounds
.
width
>
0
&
&
bounds
.
height
>
0
;
}
)
;
}
}
;
