"
use
strict
"
;
Components
.
utils
.
import
(
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
gManagers
=
new
WeakMap
(
)
;
const
kPaletteId
=
"
customization
-
palette
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
DragPositionManager
"
]
;
function
AreaPositionManager
(
aContainer
)
{
let
window
=
aContainer
.
ownerGlobal
;
this
.
_dir
=
window
.
getComputedStyle
(
aContainer
)
.
direction
;
let
containerRect
=
aContainer
.
getBoundingClientRect
(
)
;
this
.
_containerInfo
=
{
left
:
containerRect
.
left
right
:
containerRect
.
right
top
:
containerRect
.
top
width
:
containerRect
.
width
}
;
this
.
_horizontalDistance
=
null
;
this
.
update
(
aContainer
)
;
}
AreaPositionManager
.
prototype
=
{
_nodePositionStore
:
null
update
(
aContainer
)
{
this
.
_nodePositionStore
=
new
WeakMap
(
)
;
let
last
=
null
;
let
singleItemHeight
;
for
(
let
child
of
aContainer
.
children
)
{
if
(
child
.
hidden
)
{
continue
;
}
let
coordinates
=
this
.
_lazyStoreGet
(
child
)
;
if
(
!
this
.
_horizontalDistance
&
&
last
)
{
this
.
_horizontalDistance
=
coordinates
.
left
-
last
.
left
;
}
if
(
!
singleItemHeight
)
{
singleItemHeight
=
coordinates
.
height
;
}
last
=
coordinates
;
}
this
.
_heightToWidthFactor
=
this
.
_containerInfo
.
width
/
singleItemHeight
;
}
find
(
aContainer
aX
aY
)
{
let
closest
=
null
;
let
minCartesian
=
Number
.
MAX_VALUE
;
let
containerX
=
this
.
_containerInfo
.
left
;
let
containerY
=
this
.
_containerInfo
.
top
;
for
(
let
node
of
aContainer
.
children
)
{
let
coordinates
=
this
.
_lazyStoreGet
(
node
)
;
let
offsetX
=
coordinates
.
x
-
containerX
;
let
offsetY
=
coordinates
.
y
-
containerY
;
let
hDiff
=
offsetX
-
aX
;
let
vDiff
=
offsetY
-
aY
;
hDiff
/
=
this
.
_heightToWidthFactor
;
let
cartesianDiff
=
hDiff
*
hDiff
+
vDiff
*
vDiff
;
if
(
cartesianDiff
<
minCartesian
)
{
minCartesian
=
cartesianDiff
;
closest
=
node
;
}
}
if
(
closest
)
{
let
targetBounds
=
this
.
_lazyStoreGet
(
closest
)
;
let
farSide
=
this
.
_dir
=
=
"
ltr
"
?
"
right
"
:
"
left
"
;
let
outsideX
=
targetBounds
[
farSide
]
;
if
(
aY
>
targetBounds
.
top
&
&
aY
<
targetBounds
.
bottom
)
{
if
(
(
this
.
_dir
=
=
"
ltr
"
&
&
aX
>
outsideX
)
|
|
(
this
.
_dir
=
=
"
rtl
"
&
&
aX
<
outsideX
)
)
{
return
closest
.
nextSibling
|
|
aContainer
;
}
}
}
return
closest
;
}
insertPlaceholder
(
aContainer
aBefore
aSize
aIsFromThisArea
)
{
let
isShifted
=
false
;
for
(
let
child
of
aContainer
.
children
)
{
if
(
child
.
getAttribute
(
"
hidden
"
)
=
=
"
true
"
)
{
continue
;
}
if
(
child
=
=
aBefore
)
{
isShifted
=
true
;
}
if
(
isShifted
)
{
if
(
aIsFromThisArea
&
&
!
this
.
_lastPlaceholderInsertion
)
{
child
.
setAttribute
(
"
notransition
"
"
true
"
)
;
}
child
.
style
.
transform
=
this
.
_diffWithNext
(
child
aSize
)
;
}
else
{
child
.
style
.
transform
=
"
"
;
}
}
if
(
aContainer
.
lastChild
&
&
aIsFromThisArea
&
&
!
this
.
_lastPlaceholderInsertion
)
{
aContainer
.
lastChild
.
getBoundingClientRect
(
)
;
for
(
let
child
of
aContainer
.
children
)
{
child
.
removeAttribute
(
"
notransition
"
)
;
}
}
this
.
_lastPlaceholderInsertion
=
aBefore
;
}
clearPlaceholders
(
aContainer
aNoTransition
)
{
for
(
let
child
of
aContainer
.
children
)
{
if
(
aNoTransition
)
{
child
.
setAttribute
(
"
notransition
"
true
)
;
}
child
.
style
.
transform
=
"
"
;
if
(
aNoTransition
)
{
child
.
getBoundingClientRect
(
)
;
child
.
removeAttribute
(
"
notransition
"
)
;
}
}
if
(
aNoTransition
)
{
this
.
_lastPlaceholderInsertion
=
null
;
}
}
_diffWithNext
(
aNode
aSize
)
{
let
xDiff
;
let
yDiff
=
null
;
let
nodeBounds
=
this
.
_lazyStoreGet
(
aNode
)
;
let
side
=
this
.
_dir
=
=
"
ltr
"
?
"
left
"
:
"
right
"
;
let
next
=
this
.
_getVisibleSiblingForDirection
(
aNode
"
next
"
)
;
if
(
next
)
{
let
otherBounds
=
this
.
_lazyStoreGet
(
next
)
;
xDiff
=
otherBounds
[
side
]
-
nodeBounds
[
side
]
;
yDiff
=
otherBounds
.
top
-
nodeBounds
.
top
;
}
else
{
let
firstNode
=
this
.
_firstInRow
(
aNode
)
;
if
(
aNode
=
=
firstNode
)
{
xDiff
=
this
.
_horizontalDistance
|
|
aSize
.
width
;
}
else
{
xDiff
=
this
.
_moveNextBasedOnPrevious
(
aNode
nodeBounds
firstNode
)
;
}
}
if
(
yDiff
=
=
=
null
)
{
if
(
(
xDiff
>
0
&
&
this
.
_dir
=
=
"
rtl
"
)
|
|
(
xDiff
<
0
&
&
this
.
_dir
=
=
"
ltr
"
)
)
{
yDiff
=
aSize
.
height
;
}
else
{
yDiff
=
0
;
}
}
return
"
translate
(
"
+
xDiff
+
"
px
"
+
yDiff
+
"
px
)
"
;
}
_moveNextBasedOnPrevious
(
aNode
aNodeBounds
aFirstNodeInRow
)
{
let
next
=
this
.
_getVisibleSiblingForDirection
(
aNode
"
previous
"
)
;
let
otherBounds
=
this
.
_lazyStoreGet
(
next
)
;
let
side
=
this
.
_dir
=
=
"
ltr
"
?
"
left
"
:
"
right
"
;
let
xDiff
=
aNodeBounds
[
side
]
-
otherBounds
[
side
]
;
let
bound
=
this
.
_containerInfo
[
this
.
_dir
=
=
"
ltr
"
?
"
right
"
:
"
left
"
]
;
if
(
(
this
.
_dir
=
=
"
ltr
"
&
&
xDiff
+
aNodeBounds
.
right
>
bound
)
|
|
(
this
.
_dir
=
=
"
rtl
"
&
&
xDiff
+
aNodeBounds
.
left
<
bound
)
)
{
xDiff
=
this
.
_lazyStoreGet
(
aFirstNodeInRow
)
[
side
]
-
aNodeBounds
[
side
]
;
}
return
xDiff
;
}
_lazyStoreGet
(
aNode
)
{
let
rect
=
this
.
_nodePositionStore
.
get
(
aNode
)
;
if
(
!
rect
)
{
let
clientRect
=
aNode
.
getBoundingClientRect
(
)
;
rect
=
{
left
:
clientRect
.
left
right
:
clientRect
.
right
width
:
clientRect
.
width
height
:
clientRect
.
height
top
:
clientRect
.
top
bottom
:
clientRect
.
bottom
}
;
rect
.
x
=
rect
.
left
+
rect
.
width
/
2
;
rect
.
y
=
rect
.
top
+
rect
.
height
/
2
;
Object
.
freeze
(
rect
)
;
this
.
_nodePositionStore
.
set
(
aNode
rect
)
;
}
return
rect
;
}
_firstInRow
(
aNode
)
{
let
bound
=
Math
.
floor
(
this
.
_lazyStoreGet
(
aNode
)
.
top
)
;
let
rv
=
aNode
;
let
prev
;
while
(
rv
&
&
(
prev
=
this
.
_getVisibleSiblingForDirection
(
rv
"
previous
"
)
)
)
{
if
(
Math
.
floor
(
this
.
_lazyStoreGet
(
prev
)
.
bottom
)
<
=
bound
)
{
return
rv
;
}
rv
=
prev
;
}
return
rv
;
}
_getVisibleSiblingForDirection
(
aNode
aDirection
)
{
let
rv
=
aNode
;
do
{
rv
=
rv
[
aDirection
+
"
Sibling
"
]
;
}
while
(
rv
&
&
rv
.
getAttribute
(
"
hidden
"
)
=
=
"
true
"
)
;
return
rv
;
}
}
;
var
DragPositionManager
=
{
start
(
aWindow
)
{
let
areas
=
[
aWindow
.
document
.
getElementById
(
kPaletteId
)
]
;
for
(
let
areaNode
of
areas
)
{
let
positionManager
=
gManagers
.
get
(
areaNode
)
;
if
(
positionManager
)
{
positionManager
.
update
(
areaNode
)
;
}
else
{
gManagers
.
set
(
areaNode
new
AreaPositionManager
(
areaNode
)
)
;
}
}
}
stop
(
)
{
gManagers
=
new
WeakMap
(
)
;
}
getManagerForArea
(
aArea
)
{
return
gManagers
.
get
(
aArea
)
;
}
}
;
Object
.
freeze
(
DragPositionManager
)
;
