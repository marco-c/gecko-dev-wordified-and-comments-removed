ChromeUtils
.
defineModuleGetter
(
this
"
AppMenuNotifications
"
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NewTabUtils
"
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PanelMultiView
"
"
resource
:
/
/
/
modules
/
PanelMultiView
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ToolbarPanelHub
"
"
resource
:
/
/
activity
-
stream
/
lib
/
ToolbarPanelHub
.
jsm
"
)
;
const
PanelUI
=
{
get
kEvents
(
)
{
return
[
"
popupshowing
"
"
popupshown
"
"
popuphiding
"
"
popuphidden
"
]
;
}
get
kElements
(
)
{
return
{
multiView
:
"
appMenu
-
multiView
"
menuButton
:
"
PanelUI
-
menu
-
button
"
panel
:
"
appMenu
-
popup
"
overflowFixedList
:
"
widget
-
overflow
-
fixed
-
list
"
overflowPanel
:
"
widget
-
overflow
"
navbar
:
"
nav
-
bar
"
}
;
}
_initialized
:
false
_notifications
:
null
_notificationPanel
:
null
init
(
shouldSuppress
)
{
this
.
_shouldSuppress
=
shouldSuppress
;
this
.
_initElements
(
)
;
this
.
menuButton
.
addEventListener
(
"
mousedown
"
this
)
;
this
.
menuButton
.
addEventListener
(
"
keypress
"
this
)
;
Services
.
obs
.
addObserver
(
this
"
fullscreen
-
nav
-
toolbox
"
)
;
Services
.
obs
.
addObserver
(
this
"
appMenu
-
notifications
"
)
;
Services
.
obs
.
addObserver
(
this
"
show
-
update
-
progress
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
autoHideToolbarInFullScreen
"
"
browser
.
fullscreen
.
autohide
"
false
(
pref
previousValue
newValue
)
=
>
{
if
(
newValue
)
{
window
.
removeEventListener
(
"
MozDOMFullscreen
:
Entered
"
this
)
;
window
.
removeEventListener
(
"
MozDOMFullscreen
:
Exited
"
this
)
;
window
.
addEventListener
(
"
fullscreen
"
this
)
;
}
else
{
window
.
addEventListener
(
"
MozDOMFullscreen
:
Entered
"
this
)
;
window
.
addEventListener
(
"
MozDOMFullscreen
:
Exited
"
this
)
;
window
.
removeEventListener
(
"
fullscreen
"
this
)
;
}
this
.
updateNotifications
(
false
)
;
}
autoHidePref
=
>
autoHidePref
&
&
Services
.
appinfo
.
OS
!
=
=
"
Darwin
"
)
;
if
(
this
.
autoHideToolbarInFullScreen
)
{
window
.
addEventListener
(
"
fullscreen
"
this
)
;
}
else
{
window
.
addEventListener
(
"
MozDOMFullscreen
:
Entered
"
this
)
;
window
.
addEventListener
(
"
MozDOMFullscreen
:
Exited
"
this
)
;
}
window
.
addEventListener
(
"
activate
"
this
)
;
CustomizableUI
.
addListener
(
this
)
;
this
.
overflowFixedList
.
hidden
=
false
;
this
.
overflowFixedList
.
previousElementSibling
.
hidden
=
false
;
CustomizableUI
.
registerMenuPanel
(
this
.
overflowFixedList
CustomizableUI
.
AREA_FIXED_OVERFLOW_PANEL
)
;
this
.
updateOverflowStatus
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
appMenu
-
notifications
-
request
"
"
refresh
"
)
;
this
.
_initialized
=
true
;
}
_initElements
(
)
{
for
(
let
[
k
v
]
of
Object
.
entries
(
this
.
kElements
)
)
{
let
getKey
=
k
;
let
id
=
v
;
this
.
__defineGetter__
(
getKey
function
(
)
{
delete
this
[
getKey
]
;
return
(
this
[
getKey
]
=
document
.
getElementById
(
id
)
)
;
}
)
;
}
}
_eventListenersAdded
:
false
_ensureEventListenersAdded
(
)
{
if
(
this
.
_eventListenersAdded
)
{
return
;
}
this
.
_addEventListeners
(
)
;
}
_addEventListeners
(
)
{
for
(
let
event
of
this
.
kEvents
)
{
this
.
panel
.
addEventListener
(
event
this
)
;
}
PanelMultiView
.
getViewNode
(
document
"
PanelUI
-
helpView
"
)
.
addEventListener
(
"
ViewShowing
"
this
.
_onHelpViewShow
)
;
this
.
_eventListenersAdded
=
true
;
}
_removeEventListeners
(
)
{
for
(
let
event
of
this
.
kEvents
)
{
this
.
panel
.
removeEventListener
(
event
this
)
;
}
PanelMultiView
.
getViewNode
(
document
"
PanelUI
-
helpView
"
)
.
removeEventListener
(
"
ViewShowing
"
this
.
_onHelpViewShow
)
;
this
.
_eventListenersAdded
=
false
;
}
uninit
(
)
{
this
.
_removeEventListeners
(
)
;
if
(
this
.
_notificationPanel
)
{
for
(
let
event
of
this
.
kEvents
)
{
this
.
notificationPanel
.
removeEventListener
(
event
this
)
;
}
}
Services
.
obs
.
removeObserver
(
this
"
fullscreen
-
nav
-
toolbox
"
)
;
Services
.
obs
.
removeObserver
(
this
"
appMenu
-
notifications
"
)
;
Services
.
obs
.
removeObserver
(
this
"
show
-
update
-
progress
"
)
;
window
.
removeEventListener
(
"
MozDOMFullscreen
:
Entered
"
this
)
;
window
.
removeEventListener
(
"
MozDOMFullscreen
:
Exited
"
this
)
;
window
.
removeEventListener
(
"
fullscreen
"
this
)
;
window
.
removeEventListener
(
"
activate
"
this
)
;
this
.
menuButton
.
removeEventListener
(
"
mousedown
"
this
)
;
this
.
menuButton
.
removeEventListener
(
"
keypress
"
this
)
;
CustomizableUI
.
removeListener
(
this
)
;
if
(
this
.
whatsNewPanel
)
{
this
.
whatsNewPanel
.
removeEventListener
(
"
ViewShowing
"
this
)
;
}
}
toggle
(
aEvent
)
{
if
(
document
.
documentElement
.
hasAttribute
(
"
customizing
"
)
)
{
return
;
}
this
.
_ensureEventListenersAdded
(
)
;
if
(
this
.
panel
.
state
=
=
"
open
"
)
{
this
.
hide
(
)
;
}
else
if
(
this
.
panel
.
state
=
=
"
closed
"
)
{
this
.
show
(
aEvent
)
;
}
}
show
(
aEvent
)
{
this
.
_ensureShortcutsShown
(
)
;
(
async
(
)
=
>
{
await
this
.
ensureReady
(
)
;
if
(
this
.
panel
.
state
=
=
"
open
"
|
|
document
.
documentElement
.
hasAttribute
(
"
customizing
"
)
)
{
return
;
}
let
domEvent
=
null
;
if
(
aEvent
&
&
aEvent
.
type
!
=
"
command
"
)
{
domEvent
=
aEvent
;
}
let
anchor
=
this
.
_getPanelAnchor
(
this
.
menuButton
)
;
await
PanelMultiView
.
openPopup
(
this
.
panel
anchor
{
triggerEvent
:
domEvent
}
)
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
hide
(
)
{
if
(
document
.
documentElement
.
hasAttribute
(
"
customizing
"
)
)
{
return
;
}
PanelMultiView
.
hidePopup
(
this
.
panel
)
;
}
observe
(
subject
topic
status
)
{
switch
(
topic
)
{
case
"
fullscreen
-
nav
-
toolbox
"
:
if
(
this
.
_notifications
)
{
this
.
updateNotifications
(
false
)
;
}
break
;
case
"
appMenu
-
notifications
"
:
if
(
status
=
=
"
init
"
&
&
this
.
_notifications
)
{
break
;
}
this
.
_notifications
=
AppMenuNotifications
.
notifications
;
this
.
updateNotifications
(
true
)
;
break
;
case
"
show
-
update
-
progress
"
:
openAboutDialog
(
)
;
break
;
}
}
handleEvent
(
aEvent
)
{
if
(
aEvent
.
type
.
startsWith
(
"
popup
"
)
&
&
aEvent
.
target
!
=
this
.
panel
)
{
return
;
}
switch
(
aEvent
.
type
)
{
case
"
popupshowing
"
:
updateEditUIVisibility
(
)
;
case
"
popupshown
"
:
if
(
aEvent
.
type
=
=
"
popupshown
"
)
{
CustomizableUI
.
addPanelCloseListeners
(
this
.
panel
)
;
}
case
"
popuphiding
"
:
if
(
aEvent
.
type
=
=
"
popuphiding
"
)
{
updateEditUIVisibility
(
)
;
}
case
"
popuphidden
"
:
this
.
updateNotifications
(
)
;
this
.
_updatePanelButton
(
aEvent
.
target
)
;
if
(
aEvent
.
type
=
=
"
popuphidden
"
)
{
CustomizableUI
.
removePanelCloseListeners
(
this
.
panel
)
;
}
break
;
case
"
mousedown
"
:
if
(
aEvent
.
button
=
=
0
&
&
(
AppConstants
.
platform
!
=
"
macosx
"
|
|
!
aEvent
.
ctrlKey
)
)
{
this
.
toggle
(
aEvent
)
;
}
break
;
case
"
keypress
"
:
if
(
aEvent
.
key
=
=
"
"
|
|
aEvent
.
key
=
=
"
Enter
"
)
{
this
.
toggle
(
aEvent
)
;
aEvent
.
stopPropagation
(
)
;
}
break
;
case
"
MozDOMFullscreen
:
Entered
"
:
case
"
MozDOMFullscreen
:
Exited
"
:
case
"
fullscreen
"
:
case
"
activate
"
:
this
.
updateNotifications
(
)
;
break
;
case
"
ViewShowing
"
:
if
(
aEvent
.
target
=
=
this
.
whatsNewPanel
)
{
this
.
onWhatsNewPanelShowing
(
)
;
}
break
;
}
}
get
isReady
(
)
{
return
!
!
this
.
_isReady
;
}
get
isNotificationPanelOpen
(
)
{
let
panelState
=
this
.
notificationPanel
.
state
;
return
panelState
=
=
"
showing
"
|
|
panelState
=
=
"
open
"
;
}
async
ensureReady
(
)
{
if
(
this
.
_isReady
)
{
return
;
}
await
window
.
delayedStartupPromise
;
this
.
_ensureEventListenersAdded
(
)
;
this
.
panel
.
hidden
=
false
;
this
.
_isReady
=
true
;
}
showHelpView
(
aAnchor
)
{
this
.
_ensureEventListenersAdded
(
)
;
this
.
multiView
.
showSubView
(
"
PanelUI
-
helpView
"
aAnchor
)
;
}
showMoreToolsPanel
(
moreTools
)
{
this
.
showSubView
(
"
appmenu
-
moreTools
"
moreTools
)
;
let
view
=
document
.
getElementById
(
"
appmenu
-
developer
-
tools
-
view
"
)
;
Services
.
obs
.
notifyObservers
(
view
"
web
-
developer
-
tools
-
view
-
showing
"
)
;
}
async
showSubView
(
aViewId
aAnchor
aEvent
)
{
if
(
aEvent
)
{
if
(
aEvent
.
type
=
=
"
mousedown
"
&
&
(
aEvent
.
button
!
=
0
|
|
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
aEvent
.
ctrlKey
)
)
)
{
return
;
}
if
(
aEvent
.
type
=
=
"
keypress
"
&
&
aEvent
.
key
!
=
"
"
&
&
aEvent
.
key
!
=
"
Enter
"
)
{
return
;
}
}
this
.
_ensureEventListenersAdded
(
)
;
let
viewNode
=
PanelMultiView
.
getViewNode
(
document
aViewId
)
;
if
(
!
viewNode
)
{
Cu
.
reportError
(
"
Could
not
show
panel
subview
with
id
:
"
+
aViewId
)
;
return
;
}
if
(
!
aAnchor
)
{
Cu
.
reportError
(
"
Expected
an
anchor
when
opening
subview
with
id
:
"
+
aViewId
)
;
return
;
}
this
.
ensureWhatsNewInitialized
(
viewNode
)
;
this
.
ensurePanicViewInitialized
(
viewNode
)
;
let
container
=
aAnchor
.
closest
(
"
panelmultiview
"
)
;
if
(
container
&
&
!
viewNode
.
hasAttribute
(
"
disallowSubView
"
)
)
{
container
.
showSubView
(
aViewId
aAnchor
)
;
}
else
if
(
!
aAnchor
.
open
)
{
aAnchor
.
open
=
true
;
let
tempPanel
=
document
.
createXULElement
(
"
panel
"
)
;
tempPanel
.
setAttribute
(
"
type
"
"
arrow
"
)
;
tempPanel
.
setAttribute
(
"
id
"
"
customizationui
-
widget
-
panel
"
)
;
if
(
viewNode
.
hasAttribute
(
"
neverhidden
"
)
)
{
tempPanel
.
setAttribute
(
"
neverhidden
"
"
true
"
)
;
}
tempPanel
.
setAttribute
(
"
class
"
"
cui
-
widget
-
panel
panel
-
no
-
padding
"
)
;
tempPanel
.
setAttribute
(
"
viewId
"
aViewId
)
;
if
(
aAnchor
.
getAttribute
(
"
tabspecific
"
)
)
{
tempPanel
.
setAttribute
(
"
tabspecific
"
true
)
;
}
if
(
aAnchor
.
getAttribute
(
"
locationspecific
"
)
)
{
tempPanel
.
setAttribute
(
"
locationspecific
"
true
)
;
}
if
(
this
.
_disableAnimations
)
{
tempPanel
.
setAttribute
(
"
animate
"
"
false
"
)
;
}
tempPanel
.
setAttribute
(
"
context
"
"
"
)
;
document
.
getElementById
(
CustomizableUI
.
AREA_NAVBAR
)
.
appendChild
(
tempPanel
)
;
let
multiView
=
document
.
createXULElement
(
"
panelmultiview
"
)
;
multiView
.
setAttribute
(
"
id
"
"
customizationui
-
widget
-
multiview
"
)
;
multiView
.
setAttribute
(
"
viewCacheId
"
"
appMenu
-
viewCache
"
)
;
multiView
.
setAttribute
(
"
mainViewId
"
viewNode
.
id
)
;
multiView
.
appendChild
(
viewNode
)
;
tempPanel
.
appendChild
(
multiView
)
;
viewNode
.
classList
.
add
(
"
cui
-
widget
-
panelview
"
"
PanelUI
-
subView
"
)
;
let
viewShown
=
false
;
let
panelRemover
=
(
)
=
>
{
viewNode
.
classList
.
remove
(
"
cui
-
widget
-
panelview
"
)
;
if
(
viewShown
)
{
CustomizableUI
.
removePanelCloseListeners
(
tempPanel
)
;
tempPanel
.
removeEventListener
(
"
popuphidden
"
panelRemover
)
;
}
aAnchor
.
open
=
false
;
PanelMultiView
.
removePopup
(
tempPanel
)
;
}
;
if
(
aAnchor
.
parentNode
.
id
=
=
"
PersonalToolbar
"
)
{
tempPanel
.
classList
.
add
(
"
bookmarks
-
toolbar
"
)
;
}
let
anchor
=
this
.
_getPanelAnchor
(
aAnchor
)
;
if
(
aAnchor
!
=
anchor
&
&
aAnchor
.
id
)
{
anchor
.
setAttribute
(
"
consumeanchor
"
aAnchor
.
id
)
;
}
try
{
viewShown
=
await
PanelMultiView
.
openPopup
(
tempPanel
anchor
{
position
:
"
bottomcenter
topright
"
triggerEvent
:
aEvent
}
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
if
(
viewShown
)
{
CustomizableUI
.
addPanelCloseListeners
(
tempPanel
)
;
tempPanel
.
addEventListener
(
"
popuphidden
"
panelRemover
)
;
}
else
{
panelRemover
(
)
;
}
}
}
ensureWhatsNewInitialized
(
panelView
)
{
if
(
panelView
.
id
!
=
"
PanelUI
-
whatsNew
"
|
|
panelView
.
_initialized
)
{
return
;
}
if
(
!
this
.
whatsNewPanel
)
{
this
.
whatsNewPanel
=
panelView
;
}
panelView
.
_initialized
=
true
;
panelView
.
addEventListener
(
"
ViewShowing
"
this
)
;
}
ensurePanicViewInitialized
(
panelView
)
{
if
(
panelView
.
id
!
=
"
PanelUI
-
panicView
"
|
|
panelView
.
_initialized
)
{
return
;
}
if
(
!
this
.
panic
)
{
this
.
panic
=
panelView
;
}
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
panicButton
.
ftl
"
)
;
panelView
.
_initialized
=
true
;
}
onWhatsNewPanelShowing
(
)
{
ToolbarPanelHub
.
renderMessages
(
window
document
"
PanelUI
-
whatsNew
-
message
-
container
"
)
;
}
disableSingleSubviewPanelAnimations
(
)
{
this
.
_disableAnimations
=
true
;
}
enableSingleSubviewPanelAnimations
(
)
{
this
.
_disableAnimations
=
false
;
}
updateOverflowStatus
(
)
{
let
hasKids
=
this
.
overflowFixedList
.
hasChildNodes
(
)
;
if
(
hasKids
&
&
!
this
.
navbar
.
hasAttribute
(
"
nonemptyoverflow
"
)
)
{
this
.
navbar
.
setAttribute
(
"
nonemptyoverflow
"
"
true
"
)
;
this
.
overflowPanel
.
setAttribute
(
"
hasfixeditems
"
"
true
"
)
;
}
else
if
(
!
hasKids
&
&
this
.
navbar
.
hasAttribute
(
"
nonemptyoverflow
"
)
)
{
PanelMultiView
.
hidePopup
(
this
.
overflowPanel
)
;
this
.
overflowPanel
.
removeAttribute
(
"
hasfixeditems
"
)
;
this
.
navbar
.
removeAttribute
(
"
nonemptyoverflow
"
)
;
}
}
onWidgetAfterDOMChange
(
aNode
aNextNode
aContainer
aWasRemoval
)
{
if
(
aContainer
=
=
this
.
overflowFixedList
)
{
this
.
updateOverflowStatus
(
)
;
}
}
onAreaReset
(
aArea
aContainer
)
{
if
(
aContainer
=
=
this
.
overflowFixedList
)
{
this
.
updateOverflowStatus
(
)
;
}
}
_updatePanelButton
(
)
{
let
{
state
}
=
this
.
panel
;
if
(
state
=
=
"
open
"
|
|
state
=
=
"
showing
"
)
{
this
.
menuButton
.
open
=
true
;
document
.
l10n
.
setAttributes
(
this
.
menuButton
"
appmenu
-
menu
-
button
-
opened2
"
)
;
}
else
{
this
.
menuButton
.
open
=
false
;
document
.
l10n
.
setAttributes
(
this
.
menuButton
"
appmenu
-
menu
-
button
-
closed2
"
)
;
}
}
_onHelpViewShow
(
aEvent
)
{
buildHelpMenu
(
)
;
let
helpMenu
=
document
.
getElementById
(
"
menu_HelpPopup
"
)
;
let
items
=
this
.
getElementsByTagName
(
"
vbox
"
)
[
0
]
;
let
attrs
=
[
"
command
"
"
oncommand
"
"
onclick
"
"
key
"
"
disabled
"
"
accesskey
"
"
label
"
]
;
while
(
items
.
firstChild
)
{
items
.
firstChild
.
remove
(
)
;
}
let
menuItems
=
Array
.
prototype
.
slice
.
call
(
helpMenu
.
getElementsByTagName
(
"
menuitem
"
)
)
;
let
fragment
=
document
.
createDocumentFragment
(
)
;
for
(
let
node
of
menuItems
)
{
if
(
node
.
hidden
)
{
continue
;
}
let
button
=
document
.
createXULElement
(
"
toolbarbutton
"
)
;
for
(
let
attrName
of
attrs
)
{
if
(
!
node
.
hasAttribute
(
attrName
)
)
{
continue
;
}
button
.
setAttribute
(
attrName
node
.
getAttribute
(
attrName
)
)
;
}
let
l10nId
=
node
.
getAttribute
(
"
appmenu
-
data
-
l10n
-
id
"
)
;
if
(
l10nId
)
{
button
.
setAttribute
(
"
data
-
l10n
-
id
"
l10nId
)
;
}
if
(
node
.
id
)
{
button
.
id
=
"
appMenu_
"
+
node
.
id
;
}
button
.
classList
.
add
(
"
subviewbutton
"
)
;
fragment
.
appendChild
(
button
)
;
}
let
helpPolicySupport
=
fragment
.
querySelector
(
"
#
appMenu_helpPolicySupport
"
)
;
if
(
helpPolicySupport
)
{
fragment
.
insertBefore
(
helpPolicySupport
fragment
.
querySelector
(
"
#
appMenu_menu_HelpPopup_reportPhishingtoolmenu
"
)
.
nextSibling
)
;
}
items
.
appendChild
(
fragment
)
;
}
_hidePopup
(
)
{
if
(
!
this
.
_notificationPanel
)
{
return
;
}
if
(
this
.
isNotificationPanelOpen
)
{
this
.
notificationPanel
.
hidePopup
(
)
;
}
}
async
selectAndMarkItem
(
itemIds
)
{
if
(
document
.
documentElement
.
hasAttribute
(
"
customizing
"
)
)
{
return
;
}
if
(
this
.
panel
.
state
=
=
"
hiding
"
)
{
await
new
Promise
(
resolve
=
>
{
this
.
panel
.
addEventListener
(
"
popuphidden
"
resolve
{
once
:
true
}
)
;
}
)
;
}
if
(
this
.
panel
.
state
!
=
"
open
"
)
{
await
new
Promise
(
resolve
=
>
{
this
.
panel
.
addEventListener
(
"
ViewShown
"
resolve
{
once
:
true
}
)
;
this
.
show
(
)
;
}
)
;
}
let
currentView
;
let
viewShownCB
=
event
=
>
{
viewHidingCB
(
)
;
if
(
itemIds
.
length
)
{
let
subItem
=
window
.
document
.
getElementById
(
itemIds
[
0
]
)
;
if
(
event
.
target
.
id
=
=
subItem
?
.
closest
(
"
panelview
"
)
?
.
id
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
markItem
(
event
.
target
)
;
}
)
;
}
else
{
itemIds
=
[
]
;
}
}
}
;
let
viewHidingCB
=
(
)
=
>
{
if
(
currentView
)
{
currentView
.
ignoreMouseMove
=
false
;
}
currentView
=
null
;
}
;
let
popupHiddenCB
=
(
)
=
>
{
viewHidingCB
(
)
;
this
.
panel
.
removeEventListener
(
"
ViewShown
"
viewShownCB
)
;
}
;
let
markItem
=
viewNode
=
>
{
let
id
=
itemIds
.
shift
(
)
;
let
item
=
window
.
document
.
getElementById
(
id
)
;
item
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
;
currentView
=
PanelView
.
forNode
(
viewNode
)
;
currentView
.
selectedElement
=
item
;
currentView
.
focusSelectedElement
(
true
)
;
currentView
.
ignoreMouseMove
=
true
;
if
(
itemIds
.
length
)
{
this
.
panel
.
addEventListener
(
"
ViewShown
"
viewShownCB
{
once
:
true
}
)
;
}
this
.
panel
.
addEventListener
(
"
ViewHiding
"
viewHidingCB
{
once
:
true
}
)
;
}
;
this
.
panel
.
addEventListener
(
"
popuphidden
"
popupHiddenCB
{
once
:
true
}
)
;
markItem
(
this
.
mainView
)
;
}
updateNotifications
(
notificationsChanged
)
{
let
notifications
=
this
.
_notifications
;
if
(
!
notifications
|
|
!
notifications
.
length
)
{
if
(
notificationsChanged
)
{
this
.
_clearAllNotifications
(
)
;
this
.
_hidePopup
(
)
;
}
return
;
}
if
(
(
window
.
fullScreen
&
&
FullScreen
.
navToolboxHidden
)
|
|
document
.
fullscreenElement
|
|
this
.
_shouldSuppress
(
)
)
{
this
.
_hidePopup
(
)
;
return
;
}
let
doorhangers
=
notifications
.
filter
(
n
=
>
!
n
.
dismissed
&
&
!
n
.
options
.
badgeOnly
)
;
if
(
this
.
panel
.
state
=
=
"
showing
"
|
|
this
.
panel
.
state
=
=
"
open
"
)
{
doorhangers
.
forEach
(
n
=
>
{
n
.
dismissed
=
true
;
if
(
n
.
options
.
onDismissed
)
{
n
.
options
.
onDismissed
(
window
)
;
}
}
)
;
this
.
_hidePopup
(
)
;
if
(
!
notifications
[
0
]
.
options
.
badgeOnly
)
{
this
.
_showBannerItem
(
notifications
[
0
]
)
;
}
}
else
if
(
doorhangers
.
length
)
{
if
(
(
window
.
fullScreen
&
&
this
.
autoHideToolbarInFullScreen
)
|
|
Services
.
focus
.
activeWindow
!
=
=
window
)
{
this
.
_hidePopup
(
)
;
this
.
_showBadge
(
doorhangers
[
0
]
)
;
this
.
_showBannerItem
(
doorhangers
[
0
]
)
;
}
else
{
this
.
_clearBadge
(
)
;
this
.
_showNotificationPanel
(
doorhangers
[
0
]
)
;
}
}
else
{
this
.
_hidePopup
(
)
;
this
.
_showBadge
(
notifications
[
0
]
)
;
this
.
_showBannerItem
(
notifications
[
0
]
)
;
}
}
_showNotificationPanel
(
notification
)
{
this
.
_refreshNotificationPanel
(
notification
)
;
if
(
this
.
isNotificationPanelOpen
)
{
return
;
}
if
(
notification
.
options
.
beforeShowDoorhanger
)
{
notification
.
options
.
beforeShowDoorhanger
(
document
)
;
}
let
anchor
=
this
.
_getPanelAnchor
(
this
.
menuButton
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
branding
/
brand
.
ftl
"
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
browser
/
appMenuNotifications
.
ftl
"
)
;
document
.
getElementById
(
"
appMenu
-
notification
-
popup
"
)
.
querySelectorAll
(
"
[
data
-
lazy
-
l10n
-
id
]
"
)
.
forEach
(
el
=
>
{
el
.
setAttribute
(
"
data
-
l10n
-
id
"
el
.
getAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
)
;
el
.
removeAttribute
(
"
data
-
lazy
-
l10n
-
id
"
)
;
}
)
;
this
.
notificationPanel
.
openPopup
(
anchor
"
bottomcenter
topright
"
)
;
}
_clearNotificationPanel
(
)
{
for
(
let
popupnotification
of
this
.
notificationPanel
.
children
)
{
popupnotification
.
hidden
=
true
;
popupnotification
.
notification
=
null
;
}
}
_clearAllNotifications
(
)
{
this
.
_clearNotificationPanel
(
)
;
this
.
_clearBadge
(
)
;
this
.
_clearBannerItem
(
)
;
}
get
notificationPanel
(
)
{
if
(
!
this
.
_notificationPanel
)
{
let
template
=
document
.
getElementById
(
"
appMenuNotificationTemplate
"
)
;
template
.
replaceWith
(
template
.
content
)
;
this
.
_notificationPanel
=
document
.
getElementById
(
"
appMenu
-
notification
-
popup
"
)
;
for
(
let
event
of
this
.
kEvents
)
{
this
.
_notificationPanel
.
addEventListener
(
event
this
)
;
}
}
return
this
.
_notificationPanel
;
}
get
mainView
(
)
{
if
(
!
this
.
_mainView
)
{
this
.
_mainView
=
PanelMultiView
.
getViewNode
(
document
"
appMenu
-
protonMainView
"
)
;
}
return
this
.
_mainView
;
}
get
addonNotificationContainer
(
)
{
if
(
!
this
.
_addonNotificationContainer
)
{
this
.
_addonNotificationContainer
=
PanelMultiView
.
getViewNode
(
document
"
appMenu
-
proton
-
addon
-
banners
"
)
;
}
return
this
.
_addonNotificationContainer
;
}
_formatDescriptionMessage
(
n
)
{
let
text
=
{
}
;
let
array
=
n
.
options
.
message
.
split
(
"
<
>
"
)
;
text
.
start
=
array
[
0
]
|
|
"
"
;
text
.
name
=
n
.
options
.
name
|
|
"
"
;
text
.
end
=
array
[
1
]
|
|
"
"
;
return
text
;
}
_refreshNotificationPanel
(
notification
)
{
this
.
_clearNotificationPanel
(
)
;
let
popupnotificationID
=
this
.
_getPopupId
(
notification
)
;
let
popupnotification
=
document
.
getElementById
(
popupnotificationID
)
;
popupnotification
.
setAttribute
(
"
id
"
popupnotificationID
)
;
popupnotification
.
setAttribute
(
"
buttoncommand
"
"
PanelUI
.
_onNotificationButtonEvent
(
event
'
buttoncommand
'
)
;
"
)
;
popupnotification
.
setAttribute
(
"
secondarybuttoncommand
"
"
PanelUI
.
_onNotificationButtonEvent
(
event
'
secondarybuttoncommand
'
)
;
"
)
;
if
(
notification
.
options
.
message
)
{
let
desc
=
this
.
_formatDescriptionMessage
(
notification
)
;
popupnotification
.
setAttribute
(
"
label
"
desc
.
start
)
;
popupnotification
.
setAttribute
(
"
name
"
desc
.
name
)
;
popupnotification
.
setAttribute
(
"
endlabel
"
desc
.
end
)
;
}
if
(
notification
.
options
.
onRefresh
)
{
notification
.
options
.
onRefresh
(
window
)
;
}
if
(
notification
.
options
.
popupIconURL
)
{
popupnotification
.
setAttribute
(
"
icon
"
notification
.
options
.
popupIconURL
)
;
popupnotification
.
setAttribute
(
"
hasicon
"
true
)
;
}
popupnotification
.
notification
=
notification
;
popupnotification
.
show
(
)
;
}
_showBadge
(
notification
)
{
let
badgeStatus
=
this
.
_getBadgeStatus
(
notification
)
;
this
.
menuButton
.
setAttribute
(
"
badge
-
status
"
badgeStatus
)
;
}
_showBannerItem
(
notification
)
{
const
supportedIds
=
[
"
update
-
downloading
"
"
update
-
available
"
"
update
-
manual
"
"
update
-
unsupported
"
"
update
-
restart
"
]
;
if
(
!
supportedIds
.
includes
(
notification
.
id
)
)
{
return
;
}
if
(
!
this
.
_panelBannerItem
)
{
this
.
_panelBannerItem
=
this
.
mainView
.
querySelector
(
"
.
panel
-
banner
-
item
"
)
;
}
let
l10nId
=
"
appmenuitem
-
banner
-
"
+
notification
.
id
;
document
.
l10n
.
setAttributes
(
this
.
_panelBannerItem
l10nId
)
;
this
.
_panelBannerItem
.
setAttribute
(
"
notificationid
"
notification
.
id
)
;
this
.
_panelBannerItem
.
hidden
=
false
;
this
.
_panelBannerItem
.
notification
=
notification
;
}
_clearBadge
(
)
{
this
.
menuButton
.
removeAttribute
(
"
badge
-
status
"
)
;
}
_clearBannerItem
(
)
{
if
(
this
.
_panelBannerItem
)
{
this
.
_panelBannerItem
.
notification
=
null
;
this
.
_panelBannerItem
.
hidden
=
true
;
}
}
_onNotificationButtonEvent
(
event
type
)
{
let
notificationEl
=
getNotificationFromElement
(
event
.
originalTarget
)
;
if
(
!
notificationEl
)
{
throw
new
Error
(
"
PanelUI
.
_onNotificationButtonEvent
:
couldn
'
t
find
notification
element
"
)
;
}
if
(
!
notificationEl
.
notification
)
{
throw
new
Error
(
"
PanelUI
.
_onNotificationButtonEvent
:
couldn
'
t
find
notification
"
)
;
}
let
notification
=
notificationEl
.
notification
;
if
(
type
=
=
"
secondarybuttoncommand
"
)
{
AppMenuNotifications
.
callSecondaryAction
(
window
notification
)
;
}
else
{
AppMenuNotifications
.
callMainAction
(
window
notification
true
)
;
}
}
_onBannerItemSelected
(
event
)
{
let
target
=
event
.
originalTarget
;
if
(
!
target
.
notification
)
{
throw
new
Error
(
"
menucommand
target
has
no
associated
action
/
notification
"
)
;
}
event
.
stopPropagation
(
)
;
AppMenuNotifications
.
callMainAction
(
window
target
.
notification
false
)
;
}
_getPopupId
(
notification
)
{
return
"
appMenu
-
"
+
notification
.
id
+
"
-
notification
"
;
}
_getBadgeStatus
(
notification
)
{
return
notification
.
id
;
}
_getPanelAnchor
(
candidate
)
{
let
iconAnchor
=
candidate
.
badgeStack
|
|
candidate
.
icon
;
return
iconAnchor
|
|
candidate
;
}
_ensureShortcutsShown
(
view
=
this
.
mainView
)
{
if
(
view
.
hasAttribute
(
"
added
-
shortcuts
"
)
)
{
return
;
}
view
.
setAttribute
(
"
added
-
shortcuts
"
"
true
"
)
;
for
(
let
button
of
view
.
querySelectorAll
(
"
toolbarbutton
[
key
]
"
)
)
{
let
keyId
=
button
.
getAttribute
(
"
key
"
)
;
let
key
=
document
.
getElementById
(
keyId
)
;
if
(
!
key
)
{
continue
;
}
button
.
setAttribute
(
"
shortcut
"
ShortcutUtils
.
prettifyShortcut
(
key
)
)
;
}
}
}
;
XPCOMUtils
.
defineConstant
(
this
"
PanelUI
"
PanelUI
)
;
function
getLocale
(
)
{
return
Services
.
locale
.
appLocaleAsBCP47
;
}
function
getNotificationFromElement
(
aElement
)
{
return
aElement
.
closest
(
"
popupnotification
"
)
;
}
