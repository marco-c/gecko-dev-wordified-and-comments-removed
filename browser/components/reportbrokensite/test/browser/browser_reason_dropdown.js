"
use
strict
"
;
add_common_setup
(
)
;
requestLongerTimeout
(
2
)
;
async
function
clickSendAndCheckPing
(
rbs
expectedReason
=
null
)
{
const
pingCheck
=
new
Promise
(
resolve
=
>
{
GleanPings
.
brokenSiteReport
.
testBeforeNextSubmit
(
(
)
=
>
{
Assert
.
equal
(
Glean
.
brokenSiteReport
.
breakageCategory
.
testGetValue
(
)
expectedReason
)
;
resolve
(
)
;
}
)
;
}
)
;
await
rbs
.
clickSend
(
)
;
return
pingCheck
;
}
add_task
(
async
function
testReasonDropdown
(
)
{
ensureReportBrokenSitePreffedOn
(
)
;
await
BrowserTestUtils
.
withNewTab
(
REPORTABLE_PAGE_URL
async
function
(
)
{
ensureReasonDisabled
(
)
;
let
rbs
=
await
AppMenu
(
)
.
openReportBrokenSite
(
)
;
await
rbs
.
isReasonHidden
(
)
;
await
rbs
.
isSendButtonEnabled
(
)
;
await
clickSendAndCheckPing
(
rbs
)
;
await
rbs
.
clickOkay
(
)
;
ensureReasonOptional
(
)
;
rbs
=
await
AppMenu
(
)
.
openReportBrokenSite
(
)
;
await
rbs
.
isReasonOptional
(
)
;
await
rbs
.
isSendButtonEnabled
(
)
;
await
clickSendAndCheckPing
(
rbs
)
;
await
rbs
.
clickOkay
(
)
;
rbs
=
await
AppMenu
(
)
.
openReportBrokenSite
(
)
;
await
rbs
.
isReasonOptional
(
)
;
rbs
.
chooseReason
(
"
slow
"
)
;
await
rbs
.
isSendButtonEnabled
(
)
;
await
clickSendAndCheckPing
(
rbs
"
slow
"
)
;
await
rbs
.
clickOkay
(
)
;
ensureReasonRequired
(
)
;
rbs
=
await
AppMenu
(
)
.
openReportBrokenSite
(
)
;
await
rbs
.
isReasonRequired
(
)
;
await
rbs
.
isSendButtonEnabled
(
)
;
const
selectPromise
=
BrowserTestUtils
.
waitForSelectPopupShown
(
window
)
;
EventUtils
.
synthesizeMouseAtCenter
(
rbs
.
sendButton
{
}
window
)
;
await
selectPromise
;
rbs
.
chooseReason
(
"
media
"
)
;
await
rbs
.
dismissDropdownPopup
(
)
;
await
rbs
.
isSendButtonEnabled
(
)
;
await
clickSendAndCheckPing
(
rbs
"
media
"
)
;
await
rbs
.
clickOkay
(
)
;
}
)
;
}
)
;
async
function
getListItems
(
rbs
)
{
const
items
=
Array
.
from
(
rbs
.
reasonInput
.
querySelectorAll
(
"
option
"
)
)
.
map
(
i
=
>
i
.
id
.
replace
(
"
report
-
broken
-
site
-
popup
-
reason
-
"
"
"
)
)
;
Assert
.
equal
(
items
[
0
]
"
choose
"
"
First
option
is
always
'
choose
'
"
)
;
return
items
.
join
(
"
"
)
;
}
add_task
(
async
function
testReasonDropdownRandomized
(
)
{
ensureReportBrokenSitePreffedOn
(
)
;
ensureReasonOptional
(
)
;
const
USER_ID_PREF
=
"
app
.
normandy
.
user_id
"
;
const
RANDOMIZE_PREF
=
"
ui
.
new
-
webcompat
-
reporter
.
reason
-
dropdown
.
randomized
"
;
const
origNormandyUserID
=
Services
.
prefs
.
getCharPref
(
USER_ID_PREF
undefined
)
;
await
BrowserTestUtils
.
withNewTab
(
REPORTABLE_PAGE_URL
async
function
(
)
{
Services
.
prefs
.
setBoolPref
(
RANDOMIZE_PREF
false
)
;
const
rbs
=
await
AppMenu
(
)
.
openReportBrokenSite
(
)
;
const
defaultOrder
=
[
"
choose
"
"
slow
"
"
media
"
"
content
"
"
account
"
"
adblockers
"
"
other
"
]
;
Assert
.
deepEqual
(
await
getListItems
(
rbs
)
defaultOrder
"
non
-
random
order
is
correct
"
)
;
let
randomOrder
;
let
isRandomized
=
false
;
Services
.
prefs
.
setBoolPref
(
RANDOMIZE_PREF
true
)
;
Services
.
prefs
.
setCharPref
(
"
app
.
normandy
.
user_id
"
"
dummy
"
)
;
rbs
.
clickCancel
(
)
;
await
AppMenu
(
)
.
openReportBrokenSite
(
)
;
randomOrder
=
await
getListItems
(
rbs
)
;
Assert
.
ok
(
randomOrder
!
=
defaultOrder
"
options
are
randomized
with
pref
on
"
)
;
isRandomized
=
false
;
for
(
let
attempt
=
0
;
attempt
<
5
;
+
+
attempt
)
{
rbs
.
clickCancel
(
)
;
await
AppMenu
(
)
.
openReportBrokenSite
(
)
;
const
order
=
await
getListItems
(
rbs
)
;
if
(
order
!
=
randomOrder
)
{
isRandomized
=
true
;
break
;
}
}
Assert
.
ok
(
!
isRandomized
"
options
keep
the
same
order
per
user
"
)
;
Services
.
prefs
.
setBoolPref
(
RANDOMIZE_PREF
false
)
;
rbs
.
clickCancel
(
)
;
await
AppMenu
(
)
.
openReportBrokenSite
(
)
;
Assert
.
deepEqual
(
defaultOrder
await
getListItems
(
rbs
)
"
reverts
to
non
-
random
order
correctly
"
)
;
rbs
.
clickCancel
(
)
;
}
)
;
Services
.
prefs
.
setCharPref
(
USER_ID_PREF
origNormandyUserID
)
;
}
)
;
