const
BASE_ORIGIN
=
"
http
:
/
/
example
.
com
"
;
const
URI
=
BASE_ORIGIN
+
"
/
browser
/
browser
/
components
/
contextualidentity
/
test
/
browser
/
empty_file
.
html
"
;
async
function
openTabInUserContext
(
uri
userContextId
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
uri
{
userContextId
}
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
return
{
tab
browser
}
;
}
async
function
addBrowserFrameInUserContext
(
uri
userContextId
)
{
const
browser
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
iframe
"
)
;
browser
.
setAttribute
(
"
remote
"
"
true
"
)
;
browser
.
setAttribute
(
"
usercontextid
"
userContextId
)
;
browser
.
setAttribute
(
"
mozbrowser
"
"
true
"
)
;
browser
.
setAttribute
(
"
noisolation
"
"
true
"
)
;
browser
.
setAttribute
(
"
src
"
uri
)
;
gBrowser
.
tabpanels
.
appendChild
(
browser
)
;
Object
.
defineProperty
(
browser
"
messageManager
"
{
get
(
)
{
return
browser
.
frameLoader
.
messageManager
;
}
configurable
:
true
enumerable
:
true
}
)
;
await
browserFrameLoaded
(
browser
)
;
return
{
browser
}
;
}
function
browserFrameLoaded
(
browser
)
{
const
mm
=
browser
.
messageManager
;
return
new
Promise
(
resolve
=
>
{
const
eventName
=
"
browser
-
test
-
utils
:
loadEvent
"
;
mm
.
addMessageListener
(
eventName
function
onLoad
(
msg
)
{
if
(
msg
.
target
!
=
browser
)
{
return
;
}
mm
.
removeMessageListener
(
eventName
onLoad
)
;
resolve
(
msg
.
data
.
internalURL
)
;
}
)
;
}
)
;
}
function
removeBrowserFrame
(
{
browser
}
)
{
browser
.
remove
(
)
;
delete
window
.
_browserElementParents
;
}
async
function
runTestForReceiver
(
receiver
)
{
let
channelName
=
"
contextualidentity
-
broadcastchannel
"
;
await
ContentTask
.
spawn
(
receiver
.
browser
channelName
function
(
name
)
{
content
.
window
.
testPromise
=
new
content
.
window
.
Promise
(
resolve
=
>
{
content
.
window
.
bc
=
new
content
.
window
.
BroadcastChannel
(
name
)
;
content
.
window
.
bc
.
onmessage
=
function
(
e
)
{
content
.
document
.
title
+
=
e
.
data
;
resolve
(
)
;
}
;
}
)
;
}
)
;
let
sender1
=
await
openTabInUserContext
(
URI
1
)
;
let
sender2
=
await
openTabInUserContext
(
URI
2
)
;
sender1
.
message
=
"
Message
from
user
context
#
1
"
;
sender2
.
message
=
"
Message
from
user
context
#
2
"
;
for
(
let
sender
of
[
sender1
sender2
]
)
{
await
ContentTask
.
spawn
(
sender
.
browser
{
name
:
channelName
message
:
sender
.
message
}
function
(
opts
)
{
let
bc
=
new
content
.
window
.
BroadcastChannel
(
opts
.
name
)
;
bc
.
postMessage
(
opts
.
message
)
;
}
)
;
}
await
ContentTask
.
spawn
(
receiver
.
browser
sender2
.
message
async
function
(
message
)
{
await
content
.
window
.
testPromise
.
then
(
function
(
)
{
is
(
content
.
document
.
title
message
"
should
only
receive
messages
from
the
same
user
context
"
)
;
}
)
;
}
)
;
gBrowser
.
removeTab
(
sender1
.
tab
)
;
gBrowser
.
removeTab
(
sender2
.
tab
)
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
userContext
.
enabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
test
(
)
{
info
(
"
Checking
broadcast
channel
with
browser
tab
receiver
"
)
;
let
receiver
=
await
openTabInUserContext
(
URI
2
)
;
await
runTestForReceiver
(
receiver
)
;
gBrowser
.
removeTab
(
receiver
.
tab
)
;
}
)
;
add_task
(
async
function
test
(
)
{
info
(
"
Checking
broadcast
channel
with
<
iframe
mozbrowser
>
receiver
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
mozBrowserFramesEnabled
"
true
]
]
}
)
;
let
receiver
=
await
addBrowserFrameInUserContext
(
URI
2
)
;
await
runTestForReceiver
(
receiver
)
;
removeBrowserFrame
(
receiver
)
;
}
)
;
