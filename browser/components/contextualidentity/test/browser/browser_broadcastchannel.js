let
{
classes
:
Cc
interfaces
:
Ci
}
=
Components
;
const
BASE_ORIGIN
=
"
http
:
/
/
example
.
com
"
;
const
URI
=
BASE_ORIGIN
+
"
/
browser
/
browser
/
components
/
contextualidentity
/
test
/
browser
/
empty_file
.
html
"
;
function
*
openTabInUserContext
(
uri
userContextId
)
{
let
tab
=
gBrowser
.
addTab
(
uri
{
userContextId
}
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerDocument
.
defaultView
.
focus
(
)
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
yield
BrowserTestUtils
.
browserLoaded
(
browser
)
;
return
{
tab
browser
}
;
}
add_task
(
function
*
setup
(
)
{
yield
new
Promise
(
resolve
=
>
{
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
privacy
.
userContext
.
enabled
"
true
]
]
}
resolve
)
;
}
)
;
}
)
;
add_task
(
function
*
test
(
)
{
let
receiver
=
yield
*
openTabInUserContext
(
URI
2
)
;
let
channelName
=
"
contextualidentity
-
broadcastchannel
"
;
let
receiveMsg
=
ContentTask
.
spawn
(
receiver
.
browser
channelName
function
(
name
)
{
return
new
Promise
(
resolve
=
>
{
content
.
window
.
bc
=
new
content
.
window
.
BroadcastChannel
(
name
)
;
content
.
window
.
bc
.
onmessage
=
function
(
e
)
{
content
.
document
.
title
+
=
e
.
data
;
resolve
(
)
;
}
}
)
;
}
)
;
let
sender1
=
yield
*
openTabInUserContext
(
URI
1
)
;
let
sender2
=
yield
*
openTabInUserContext
(
URI
2
)
;
sender1
.
message
=
"
Message
from
user
context
#
1
"
;
sender2
.
message
=
"
Message
from
user
context
#
2
"
;
for
(
let
sender
of
[
sender1
sender2
]
)
{
yield
ContentTask
.
spawn
(
sender
.
browser
{
name
:
channelName
message
:
sender
.
message
}
function
(
opts
)
{
let
bc
=
new
content
.
window
.
BroadcastChannel
(
opts
.
name
)
;
bc
.
postMessage
(
opts
.
message
)
;
}
)
;
}
yield
receiveMsg
;
is
(
receiver
.
browser
.
contentDocument
.
title
sender2
.
message
"
should
only
receive
messages
from
the
same
user
context
"
)
;
gBrowser
.
removeTab
(
sender1
.
tab
)
;
gBrowser
.
removeTab
(
sender2
.
tab
)
;
gBrowser
.
removeTab
(
receiver
.
tab
)
;
}
)
;
