"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ASRouter
:
"
resource
:
/
/
/
modules
/
asrouter
/
ASRouter
.
sys
.
mjs
"
FeatureCallout
:
"
resource
:
/
/
/
modules
/
asrouter
/
FeatureCallout
.
sys
.
mjs
"
FeatureCalloutBroker
:
"
resource
:
/
/
/
modules
/
asrouter
/
FeatureCalloutBroker
.
sys
.
mjs
"
FeatureCalloutMessages
:
"
resource
:
/
/
/
modules
/
asrouter
/
FeatureCalloutMessages
.
sys
.
mjs
"
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
QueryCache
:
"
resource
:
/
/
/
modules
/
asrouter
/
ASRouterTargeting
.
sys
.
mjs
"
AboutWelcomeParent
:
"
resource
:
/
/
/
actors
/
AboutWelcomeParent
.
sys
.
mjs
"
}
)
;
const
{
FxAccounts
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
sys
.
mjs
"
)
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
const
BROWSER_GLUE
=
Cc
[
"
mozilla
.
org
/
browser
/
browserglue
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
const
calloutId
=
"
feature
-
callout
"
;
const
calloutSelector
=
#
{
calloutId
}
.
featureCallout
;
const
calloutCTASelector
=
#
{
calloutId
}
:
is
(
.
primary
.
secondary
)
;
const
calloutDismissSelector
=
#
{
calloutId
}
.
dismiss
-
button
;
const
CTASelector
=
#
{
calloutId
}
:
is
(
.
primary
.
secondary
)
;
function
pushPrefs
(
.
.
.
prefs
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
prefs
}
)
;
}
async
function
clearHistoryAndBookmarks
(
)
{
await
PlacesUtils
.
bookmarks
.
eraseEverything
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
QueryCache
.
expireAll
(
)
;
}
async
function
waitForUrlLoad
(
url
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
BrowserTestUtils
.
startLoadingURIString
(
browser
url
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
url
)
;
}
async
function
waitForCalloutScreen
(
target
screenId
)
{
await
BrowserTestUtils
.
waitForMutationCondition
(
target
{
childList
:
true
subtree
:
true
attributeFilter
:
[
"
class
"
]
}
(
)
=
>
target
.
querySelector
(
{
calloutSelector
}
:
not
(
.
hidden
)
.
{
screenId
}
)
)
;
}
async
function
waitForCalloutRemoved
(
target
)
{
await
BrowserTestUtils
.
waitForMutationCondition
(
target
{
childList
:
true
subtree
:
true
}
(
)
=
>
!
target
.
querySelector
(
calloutSelector
)
)
;
}
class
TelemetrySpy
{
constructor
(
sandbox
=
sinon
.
createSandbox
(
)
)
{
this
.
sandbox
=
sandbox
;
this
.
spy
=
this
.
sandbox
.
spy
(
AboutWelcomeParent
.
prototype
"
onContentMessage
"
)
.
withArgs
(
"
AWPage
:
TELEMETRY_EVENT
"
)
;
registerCleanupFunction
(
(
)
=
>
this
.
restore
(
)
)
;
}
assertCalledWith
(
expectedData
)
{
let
match
=
this
.
spy
.
calledWith
(
"
AWPage
:
TELEMETRY_EVENT
"
expectedData
)
;
if
(
match
)
{
ok
(
true
"
Expected
telemetry
sent
"
)
;
}
else
if
(
this
.
spy
.
called
)
{
ok
(
false
Wrong
telemetry
sent
:
{
JSON
.
stringify
(
this
.
spy
.
lastCall
.
args
)
}
)
;
}
else
{
ok
(
false
"
No
telemetry
sent
"
)
;
}
}
reset
(
)
{
this
.
spy
.
resetHistory
(
)
;
}
restore
(
)
{
this
.
sandbox
.
restore
(
)
;
}
}
const
clickCTA
=
async
doc
=
>
{
doc
.
querySelector
(
CTASelector
)
.
click
(
)
;
}
;
