"
use
strict
"
;
const
{
MenuMessage
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
asrouter
/
MenuMessage
.
sys
.
mjs
"
)
;
const
{
PanelTestProvider
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
asrouter
/
PanelTestProvider
.
sys
.
mjs
"
)
;
const
{
AboutWelcomeTelemetry
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
aboutwelcome
/
AboutWelcomeTelemetry
.
sys
.
mjs
"
)
;
const
{
SpecialMessageActions
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
messaging
-
system
/
lib
/
SpecialMessageActions
.
sys
.
mjs
"
)
;
const
{
AppMenuNotifications
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
sys
.
mjs
"
)
;
async
function
hideAllPopups
(
win
=
window
)
{
if
(
win
.
PanelUI
.
panel
.
state
=
=
=
"
open
"
)
{
let
panelHidden
=
BrowserTestUtils
.
waitForEvent
(
win
.
PanelUI
.
panel
"
popuphidden
"
)
;
win
.
PanelUI
.
hide
(
)
;
await
panelHidden
;
}
let
widgetPanel
=
win
.
document
.
getElementById
(
"
customizationui
-
widget
-
panel
"
)
;
if
(
widgetPanel
)
{
let
panelHidden
=
BrowserTestUtils
.
waitForEvent
(
widgetPanel
"
popuphidden
"
)
;
widgetPanel
.
hidePopup
(
)
;
await
panelHidden
;
}
}
async
function
assertMessageInMenuSource
(
source
message
win
=
window
)
{
let
messageEl
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
messageEl
=
win
.
PanelUI
.
mainView
.
querySelector
(
"
fxa
-
menu
-
message
"
)
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
messageEl
=
win
.
document
.
querySelector
(
"
#
PanelUI
-
fxa
fxa
-
menu
-
message
"
)
;
}
await
messageEl
.
updateComplete
;
Assert
.
ok
(
messageEl
"
Found
the
fxa
-
menu
-
message
element
.
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
messageEl
"
fxa
-
menu
-
message
is
visible
.
"
)
)
;
Assert
.
equal
(
messageEl
.
primaryText
message
.
content
.
primaryText
"
The
primary
text
was
set
.
"
)
;
Assert
.
equal
(
messageEl
.
secondaryText
message
.
content
.
secondaryText
"
The
secondary
text
was
set
.
"
)
;
Assert
.
equal
(
messageEl
.
imageURL
message
.
content
.
imageURL
"
The
imageURL
property
was
set
.
"
)
;
Assert
.
equal
(
messageEl
.
buttonText
message
.
content
.
primaryActionText
"
The
buttonText
property
was
set
.
"
)
;
Assert
.
equal
(
messageEl
.
dataset
.
navigableWithTabOnly
"
true
"
"
The
element
should
be
configured
for
tab
navigation
.
"
)
;
Assert
.
equal
(
messageEl
.
layout
"
column
"
"
The
default
layout
should
be
'
column
'
.
"
)
;
let
messageElStyles
=
window
.
getComputedStyle
(
messageEl
)
;
Assert
.
equal
(
messageElStyles
.
getPropertyValue
(
"
-
-
illustration
-
margin
-
block
-
start
-
offset
"
)
{
message
.
content
.
imageVerticalTopOffset
}
px
)
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
separator
"
)
)
"
Zap
gradient
separator
is
hidden
in
the
AppMenu
.
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
status2
"
)
)
"
Default
FxA
sign
-
in
button
is
hidden
in
the
AppMenu
.
"
)
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
win
.
document
.
querySelector
(
"
#
fxa
-
manage
-
account
-
button
"
)
)
"
Default
FxA
sign
-
in
button
in
the
PXI
panel
is
hidden
.
"
)
;
}
return
messageEl
;
}
function
assertNoMessageInMenuSource
(
source
win
=
window
)
{
let
messageEl
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
messageEl
=
win
.
PanelUI
.
mainView
.
querySelector
(
"
fxa
-
menu
-
message
"
)
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
messageEl
=
win
.
document
.
querySelector
(
"
#
PanelUI
-
fxa
fxa
-
menu
-
message
"
)
;
}
Assert
.
ok
(
!
messageEl
"
Should
not
have
found
an
fxa
-
menu
-
message
"
)
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
separator
"
)
)
"
Zap
gradient
separator
is
visible
.
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
status2
"
)
)
"
Default
FxA
sign
-
in
button
is
visible
.
"
)
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
win
.
document
.
querySelector
(
"
#
fxa
-
manage
-
account
-
button
"
)
)
"
Default
FxA
sign
-
in
button
in
the
PXI
panel
is
visible
.
"
)
;
}
}
async
function
reopenMenuSource
(
source
expectedMessage
win
=
window
taskFn
)
{
await
hideAllPopups
(
win
)
;
let
promiseViewShown
;
let
panel
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
promiseViewShown
=
BrowserTestUtils
.
waitForEvent
(
win
.
PanelUI
.
panel
"
ViewShown
"
)
;
win
.
PanelUI
.
show
(
)
;
panel
=
win
.
PanelUI
.
panel
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
promiseViewShown
=
BrowserTestUtils
.
waitForEvent
(
PanelMultiView
.
getViewNode
(
win
.
document
"
PanelUI
-
fxa
"
)
"
ViewShown
"
)
;
await
win
.
gSync
.
toggleAccountPanel
(
win
.
document
.
getElementById
(
"
fxa
-
toolbar
-
menu
-
button
"
)
new
MouseEvent
(
"
mousedown
"
)
)
;
panel
=
win
.
document
.
getElementById
(
"
customizationui
-
widget
-
panel
"
)
;
}
info
(
Waiting
for
menu
source
{
source
}
to
open
)
;
await
promiseViewShown
;
info
(
Menu
source
{
source
}
opened
)
;
let
messageEl
=
null
;
if
(
expectedMessage
)
{
messageEl
=
await
assertMessageInMenuSource
(
source
expectedMessage
win
)
;
}
else
{
assertNoMessageInMenuSource
(
source
win
)
;
}
if
(
taskFn
)
{
await
taskFn
(
messageEl
panel
)
;
}
await
hideAllPopups
(
win
)
;
Assert
.
ok
(
!
win
.
document
.
querySelector
(
"
fxa
-
menu
-
message
"
)
"
Should
not
find
any
fxa
-
menu
-
message
elements
"
)
;
}
async
function
withTestMessage
(
sandbox
message
taskFn
)
{
let
handleMessageRequestStub
=
sandbox
.
stub
(
ASRouter
"
handleMessageRequest
"
)
;
handleMessageRequestStub
.
resolves
(
[
message
]
)
;
let
messagesEnabledInAutomationStub
=
sandbox
.
stub
(
ASRouter
"
messagesEnabledInAutomation
"
)
;
messagesEnabledInAutomationStub
.
value
(
[
message
.
id
]
)
;
let
getMessageByIdStub
=
sandbox
.
stub
(
ASRouter
"
getMessageById
"
)
;
getMessageByIdStub
.
withArgs
(
message
.
id
)
.
returns
(
message
)
;
await
taskFn
(
handleMessageRequestStub
)
;
handleMessageRequestStub
.
restore
(
)
;
messagesEnabledInAutomationStub
.
restore
(
)
;
getMessageByIdStub
.
restore
(
)
;
}
async
function
withEachSource
(
taskFn
)
{
for
(
let
source
of
[
MenuMessage
.
SOURCES
.
APP_MENU
MenuMessage
.
SOURCES
.
PXI_MENU
]
)
{
info
(
Trying
source
{
source
}
)
;
await
taskFn
(
source
)
;
}
}
let
gTestFxAMessage
;
add_setup
(
async
function
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
gTestFxAMessage
=
await
PanelTestProvider
.
getMessages
(
)
.
then
(
msgs
=
>
msgs
.
find
(
msg
=
>
msg
.
id
=
=
=
"
FXA_ACCOUNTS_APPMENU_PROTECT_BROWSING_DATA
"
)
)
;
Assert
.
ok
(
gTestFxAMessage
"
Found
a
test
AppMenu
message
to
use
.
"
)
;
delete
gTestFxAMessage
.
testingTriggerContext
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
newtabpage
.
activity
-
stream
.
telemetry
"
true
]
]
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
fog
.
testResetFOG
(
)
;
}
)
;
gSync
.
init
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
hideAllPopups
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_trigger
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
spy
(
ASRouter
"
sendTriggerMessage
"
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
)
;
Assert
.
ok
(
ASRouter
.
sendTriggerMessage
.
calledWith
(
{
browser
:
gBrowser
.
selectedBrowser
id
:
"
menuOpened
"
context
:
{
source
:
MenuMessage
.
SOURCES
.
APP_MENU
browserIsSelected
:
true
}
}
)
"
sendTriggerMessage
was
called
when
opening
the
AppMenu
panel
.
"
)
;
ASRouter
.
sendTriggerMessage
.
resetHistory
(
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
PXI_MENU
)
;
Assert
.
ok
(
ASRouter
.
sendTriggerMessage
.
calledWith
(
{
browser
:
gBrowser
.
selectedBrowser
id
:
"
menuOpened
"
context
:
{
source
:
MenuMessage
.
SOURCES
.
PXI_MENU
browserIsSelected
:
true
}
}
)
"
sendTriggerMessage
was
called
when
opening
the
PXI
panel
.
"
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_show_fxa_cta_message
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
spy
(
ASRouter
"
addImpression
"
)
;
sandbox
.
spy
(
AboutWelcomeTelemetry
.
prototype
"
submitGleanPingForPing
"
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
(
)
=
>
{
await
withEachSource
(
async
source
=
>
{
info
(
Testing
source
{
source
}
)
;
await
reopenMenuSource
(
source
gTestFxAMessage
window
async
(
msgElement
panel
)
=
>
{
AccessibilityUtils
.
setEnv
(
{
mustHaveAccessibleRule
:
false
}
)
;
msgElement
.
click
(
)
;
AccessibilityUtils
.
resetEnv
(
)
;
Assert
.
equal
(
panel
.
state
"
open
"
"
Panel
should
still
be
in
the
open
state
.
"
)
;
}
)
;
Assert
.
ok
(
ASRouter
.
addImpression
.
calledWith
(
gTestFxAMessage
)
"
The
test
message
had
an
impression
recorded
for
it
.
"
)
;
Assert
.
ok
(
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
calledWithMatch
(
sinon
.
match
(
{
message_id
:
gTestFxAMessage
.
id
event
:
"
IMPRESSION
"
pingType
:
"
menu
"
source
}
)
)
"
The
test
message
had
an
impression
recorded
for
it
.
"
)
;
ASRouter
.
addImpression
.
resetHistory
(
)
;
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
resetHistory
(
)
;
}
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_show_fxa_cta_message_multiple_windows
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
win1
=
window
;
let
win2
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
win3
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
win2
.
gSync
.
init
(
)
;
win3
.
gSync
.
init
(
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
handleMessageRequestStub
=
>
{
let
message
=
gTestFxAMessage
;
for
(
let
win
of
[
win1
win2
win3
]
)
{
await
SimpleTest
.
promiseFocus
(
win
)
;
await
withEachSource
(
async
source
=
>
{
await
reopenMenuSource
(
source
message
win
)
;
}
)
;
}
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
gTestFxAMessage
win3
async
(
)
=
>
{
let
win3Message
=
win3
.
PanelUI
.
mainView
.
querySelector
(
"
fxa
-
menu
-
message
"
)
;
await
win3Message
.
updateComplete
;
win3Message
.
closeButton
.
click
(
)
;
Assert
.
ok
(
!
win3Message
.
isConnected
"
Closed
message
should
have
been
immediately
removed
from
the
DOM
.
"
)
;
}
)
;
handleMessageRequestStub
.
resolves
(
[
]
)
;
for
(
let
win
of
[
win1
win2
win3
]
)
{
await
SimpleTest
.
promiseFocus
(
win
)
;
await
withEachSource
(
async
source
=
>
{
await
reopenMenuSource
(
source
null
win
)
;
}
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win2
)
;
await
BrowserTestUtils
.
closeWindow
(
win3
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_fxa_cta_actions
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
spy
(
AboutWelcomeTelemetry
.
prototype
"
submitGleanPingForPing
"
)
;
sandbox
.
stub
(
SpecialMessageActions
"
handleAction
"
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
(
)
=
>
{
await
withEachSource
(
async
source
=
>
{
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
resetHistory
(
)
;
SpecialMessageActions
.
handleAction
.
resetHistory
(
)
;
await
reopenMenuSource
(
source
gTestFxAMessage
window
async
(
messageEl
panel
)
=
>
{
messageEl
.
signUpButton
.
click
(
)
;
Assert
.
notEqual
(
panel
.
state
"
open
"
"
Panel
should
have
started
to
close
.
"
)
;
}
)
;
let
clonedPrimaryAction
=
structuredClone
(
gTestFxAMessage
.
content
.
primaryAction
)
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
clonedPrimaryAction
.
data
.
entrypoint
=
"
fxa_app_menu
"
;
clonedPrimaryAction
.
data
.
extraParams
.
utm_content
+
=
"
-
app_menu
"
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
clonedPrimaryAction
.
data
.
entrypoint
=
"
fxa_avatar_menu
"
;
clonedPrimaryAction
.
data
.
extraParams
.
utm_content
+
=
"
-
avatar
"
;
}
Assert
.
ok
(
SpecialMessageActions
.
handleAction
.
calledWith
(
clonedPrimaryAction
gBrowser
.
selectedBrowser
)
"
The
message
action
for
signing
up
for
an
account
was
passed
.
"
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
ok
(
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
calledWithMatch
(
sinon
.
match
(
{
message_id
:
gTestFxAMessage
.
id
event
:
"
CLICK
"
pingType
:
"
menu
"
source
}
)
)
"
A
ping
for
clicking
the
message
should
have
been
passed
.
"
)
;
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
resetHistory
(
)
;
SpecialMessageActions
.
handleAction
.
resetHistory
(
)
;
await
reopenMenuSource
(
source
gTestFxAMessage
window
async
messageEl
=
>
{
messageEl
.
closeButton
.
click
(
)
;
}
)
;
Assert
.
ok
(
SpecialMessageActions
.
handleAction
.
calledWith
(
gTestFxAMessage
.
content
.
closeAction
gBrowser
.
selectedBrowser
)
"
The
message
action
for
closing
the
message
should
have
been
passed
.
"
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
ok
(
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
calledWithMatch
(
sinon
.
match
(
{
message_id
:
gTestFxAMessage
.
id
event
:
"
DISMISS
"
pingType
:
"
menu
"
source
}
)
)
"
A
ping
for
dismissing
the
message
should
have
been
passed
.
"
)
;
}
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_fxa_cta_notification_precedence
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
spy
(
AboutWelcomeTelemetry
.
prototype
"
submitGleanPingForPing
"
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
(
)
=
>
{
const
NOTIFICATION_ID
=
"
update
-
restart
"
;
AppMenuNotifications
.
showNotification
(
NOTIFICATION_ID
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
null
)
;
AppMenuNotifications
.
removeNotification
(
NOTIFICATION_ID
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
gTestFxAMessage
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
