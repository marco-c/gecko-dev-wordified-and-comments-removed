"
use
strict
"
;
const
{
MenuMessage
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
asrouter
/
MenuMessage
.
sys
.
mjs
"
)
;
const
{
PanelTestProvider
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
asrouter
/
PanelTestProvider
.
sys
.
mjs
"
)
;
const
{
AboutWelcomeTelemetry
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
aboutwelcome
/
AboutWelcomeTelemetry
.
sys
.
mjs
"
)
;
const
{
SpecialMessageActions
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
messaging
-
system
/
lib
/
SpecialMessageActions
.
sys
.
mjs
"
)
;
const
{
AppMenuNotifications
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
sys
.
mjs
"
)
;
async
function
hideAllPopups
(
win
=
window
)
{
if
(
win
.
PanelUI
.
panel
.
state
=
=
=
"
open
"
)
{
let
panelHidden
=
BrowserTestUtils
.
waitForEvent
(
win
.
PanelUI
.
panel
"
popuphidden
"
)
;
win
.
PanelUI
.
hide
(
)
;
await
panelHidden
;
}
let
widgetPanel
=
win
.
document
.
getElementById
(
"
customizationui
-
widget
-
panel
"
)
;
if
(
widgetPanel
)
{
let
panelHidden
=
BrowserTestUtils
.
waitForEvent
(
widgetPanel
"
popuphidden
"
)
;
widgetPanel
.
hidePopup
(
)
;
await
panelHidden
;
}
}
async
function
assertMessageInMenuSource
(
source
message
win
=
window
)
{
let
messageEl
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
messageEl
=
win
.
PanelUI
.
mainView
.
querySelector
(
"
menu
-
message
"
)
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
messageEl
=
win
.
document
.
querySelector
(
"
#
PanelUI
-
fxa
menu
-
message
"
)
;
}
await
messageEl
.
updateComplete
;
Assert
.
ok
(
messageEl
"
Found
the
menu
-
message
element
.
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
messageEl
"
menu
-
message
is
visible
.
"
)
)
;
Assert
.
equal
(
messageEl
.
primaryText
message
.
content
.
primaryText
"
The
primary
text
was
set
.
"
)
;
if
(
message
.
content
.
layout
=
=
=
"
simple
"
)
{
Assert
.
equal
(
win
.
getComputedStyle
(
messageEl
.
shadowRoot
.
querySelector
(
"
#
secondary
"
)
)
.
display
"
none
"
"
Secondary
text
is
not
visible
even
if
provided
.
"
)
;
}
else
{
Assert
.
equal
(
messageEl
.
secondaryText
message
.
content
.
secondaryText
"
The
secondary
text
was
set
.
"
)
;
}
Assert
.
equal
(
messageEl
.
imageURL
message
.
content
.
imageURL
"
The
imageURL
property
was
set
.
"
)
;
Assert
.
equal
(
messageEl
.
buttonText
message
.
content
.
primaryActionText
"
The
buttonText
property
was
set
.
"
)
;
Assert
.
equal
(
messageEl
.
dataset
.
navigableWithTabOnly
"
true
"
"
The
element
should
be
configured
for
tab
navigation
.
"
)
;
const
expectedLayout
=
message
.
content
.
layout
?
?
"
column
"
;
Assert
.
equal
(
messageEl
.
layout
expectedLayout
The
layout
should
be
'
{
expectedLayout
}
'
.
)
;
const
cs
=
win
.
getComputedStyle
(
messageEl
)
;
if
(
expectedLayout
=
=
=
"
row
"
)
{
if
(
message
.
content
.
imageVerticalBottomOffset
!
=
=
undefined
)
{
Assert
.
equal
(
cs
.
getPropertyValue
(
"
-
-
illustration
-
margin
-
block
-
end
-
offset
"
)
{
message
.
content
.
imageVerticalBottomOffset
}
px
"
Row
layout
:
bottom
illustration
offset
matches
.
"
)
;
}
if
(
message
.
content
.
imageVerticalTopOffset
!
=
=
undefined
)
{
Assert
.
equal
(
cs
.
getPropertyValue
(
"
-
-
illustration
-
margin
-
block
-
start
-
offset
"
)
{
message
.
content
.
imageVerticalTopOffset
}
px
"
Row
layout
:
top
illustration
offset
matches
.
"
)
;
}
}
else
if
(
expectedLayout
=
=
=
"
column
"
)
{
if
(
message
.
content
.
imageVerticalTopOffset
!
=
=
undefined
)
{
Assert
.
equal
(
cs
.
getPropertyValue
(
"
-
-
illustration
-
margin
-
block
-
start
-
offset
"
)
{
message
.
content
.
imageVerticalTopOffset
}
px
"
Column
layout
:
top
illustration
offset
matches
.
"
)
;
}
}
else
if
(
expectedLayout
=
=
=
"
simple
"
)
{
const
shadow
=
messageEl
.
shadowRoot
;
const
closeBtn
=
shadow
.
querySelector
(
"
#
close
-
button
"
)
;
const
secondary
=
shadow
.
querySelector
(
"
#
secondary
"
)
;
Assert
.
equal
(
getComputedStyle
(
closeBtn
)
.
display
"
none
"
"
Close
button
hidden
in
simple
layout
.
"
)
;
Assert
.
equal
(
getComputedStyle
(
secondary
)
.
display
"
none
"
"
Secondary
text
hidden
in
simple
layout
.
"
)
;
for
(
const
img
of
shadow
.
querySelectorAll
(
"
img
"
)
)
{
Assert
.
equal
(
getComputedStyle
(
img
)
.
display
"
none
"
"
Images
hidden
in
simple
layout
.
"
)
;
}
}
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
const
isFxAMessage
=
message
.
content
.
messageType
=
=
=
MenuMessage
.
MESSAGE_TYPES
.
FXA_CTA
;
if
(
isFxAMessage
)
{
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
separator
"
)
)
"
Zap
gradient
separator
is
hidden
in
the
AppMenu
for
fxa_cta
.
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
status2
"
)
)
"
Default
FxA
sign
-
in
button
is
hidden
in
the
AppMenu
for
fxa_cta
.
"
)
;
}
else
{
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
separator
"
)
)
"
Zap
gradient
separator
is
visible
in
the
AppMenu
for
default_cta
.
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
status2
"
)
)
"
Default
FxA
sign
-
in
button
is
visible
in
the
AppMenu
for
default_cta
.
"
)
;
}
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
Assert
.
ok
(
BrowserTestUtils
.
isHidden
(
win
.
document
.
querySelector
(
"
#
fxa
-
manage
-
account
-
button
"
)
)
"
Default
FxA
sign
-
in
button
in
the
PXI
panel
is
hidden
.
"
)
;
}
return
messageEl
;
}
function
assertNoMessageInMenuSource
(
source
win
=
window
)
{
let
messageEl
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
messageEl
=
win
.
PanelUI
.
mainView
.
querySelector
(
"
menu
-
message
"
)
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
messageEl
=
win
.
document
.
querySelector
(
"
#
PanelUI
-
fxa
menu
-
message
"
)
;
}
Assert
.
ok
(
!
messageEl
"
Should
not
have
found
an
menu
-
message
"
)
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
separator
"
)
)
"
Zap
gradient
separator
is
visible
.
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
win
.
PanelUI
.
mainView
.
querySelector
(
"
#
appMenu
-
fxa
-
status2
"
)
)
"
Default
FxA
sign
-
in
button
is
visible
.
"
)
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
win
.
document
.
querySelector
(
"
#
fxa
-
manage
-
account
-
button
"
)
)
"
Default
FxA
sign
-
in
button
in
the
PXI
panel
is
visible
.
"
)
;
}
}
async
function
reopenMenuSource
(
source
expectedMessage
win
=
window
taskFn
)
{
await
hideAllPopups
(
win
)
;
let
promiseViewShown
;
let
panel
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
promiseViewShown
=
BrowserTestUtils
.
waitForEvent
(
win
.
PanelUI
.
panel
"
ViewShown
"
)
;
win
.
PanelUI
.
show
(
)
;
panel
=
win
.
PanelUI
.
panel
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
promiseViewShown
=
BrowserTestUtils
.
waitForEvent
(
PanelMultiView
.
getViewNode
(
win
.
document
"
PanelUI
-
fxa
"
)
"
ViewShown
"
)
;
await
win
.
gSync
.
toggleAccountPanel
(
win
.
document
.
getElementById
(
"
fxa
-
toolbar
-
menu
-
button
"
)
new
MouseEvent
(
"
mousedown
"
)
)
;
panel
=
win
.
document
.
getElementById
(
"
customizationui
-
widget
-
panel
"
)
;
}
info
(
Waiting
for
menu
source
{
source
}
to
open
)
;
await
promiseViewShown
;
info
(
Menu
source
{
source
}
opened
)
;
let
messageEl
=
null
;
if
(
expectedMessage
)
{
messageEl
=
await
assertMessageInMenuSource
(
source
expectedMessage
win
)
;
}
else
{
assertNoMessageInMenuSource
(
source
win
)
;
}
if
(
taskFn
)
{
await
taskFn
(
messageEl
panel
)
;
}
await
hideAllPopups
(
win
)
;
Assert
.
ok
(
!
win
.
document
.
querySelector
(
"
menu
-
message
"
)
"
Should
not
find
any
menu
-
message
elements
"
)
;
}
async
function
withTestMessage
(
sandbox
message
taskFn
)
{
let
handleMessageRequestStub
=
sandbox
.
stub
(
ASRouter
"
handleMessageRequest
"
)
;
handleMessageRequestStub
.
resolves
(
[
message
]
)
;
let
messagesEnabledInAutomationStub
=
sandbox
.
stub
(
ASRouter
"
messagesEnabledInAutomation
"
)
;
messagesEnabledInAutomationStub
.
value
(
[
message
.
id
]
)
;
let
getMessageByIdStub
=
sandbox
.
stub
(
ASRouter
"
getMessageById
"
)
;
getMessageByIdStub
.
withArgs
(
message
.
id
)
.
returns
(
message
)
;
await
taskFn
(
handleMessageRequestStub
)
;
handleMessageRequestStub
.
restore
(
)
;
messagesEnabledInAutomationStub
.
restore
(
)
;
getMessageByIdStub
.
restore
(
)
;
}
async
function
withEachSource
(
taskFn
)
{
for
(
let
source
of
[
MenuMessage
.
SOURCES
.
APP_MENU
MenuMessage
.
SOURCES
.
PXI_MENU
]
)
{
info
(
Trying
source
{
source
}
)
;
await
taskFn
(
source
)
;
}
}
let
gTestFxAMessage
;
const
PREF_PXI_PANEL_ACCESSED
=
"
identity
.
fxaccounts
.
toolbar
.
syncSetup
.
panelAccessed
"
;
add_setup
(
async
function
(
)
{
Services
.
fog
.
testResetFOG
(
)
;
gTestFxAMessage
=
await
PanelTestProvider
.
getMessages
(
)
.
then
(
msgs
=
>
msgs
.
find
(
msg
=
>
msg
.
id
=
=
=
"
FXA_ACCOUNTS_PXIMENU_ROW_LAYOUT
"
)
)
;
Assert
.
ok
(
gTestFxAMessage
"
Found
a
test
fxa_cta
message
to
use
.
"
)
;
delete
gTestFxAMessage
.
testingTriggerContext
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
newtabpage
.
activity
-
stream
.
telemetry
"
true
]
]
}
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
fog
.
testResetFOG
(
)
;
}
)
;
gSync
.
init
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
identity
.
fxaccounts
.
toolbar
.
syncSetup
.
panelAccessed
"
)
;
await
hideAllPopups
(
)
;
}
)
;
}
)
;
function
buildDefaultCtaMessage
(
{
id
=
"
TEST_DEFAULT_CTA
"
layout
=
"
column
"
}
=
{
}
)
{
return
{
id
template
:
"
menu_message
"
content
:
{
layout
messageType
:
"
default_cta
"
primaryText
:
"
Firefox
is
not
your
default
browser
"
primaryActionText
:
"
Set
as
default
"
primaryButtonSize
:
"
small
"
logoURL
:
"
chrome
:
/
/
branding
/
content
/
about
-
logo
.
svg
"
secondaryText
:
"
Make
Firefox
your
default
browser
to
open
links
from
other
apps
.
"
primaryAction
:
{
}
closeAction
:
{
}
}
targeting
:
"
true
"
trigger
:
{
id
:
"
menuOpened
"
}
groups
:
[
]
}
;
}
add_task
(
async
function
test_trigger
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
spy
(
ASRouter
"
sendTriggerMessage
"
)
;
const
handleMessageRequestStub
=
sandbox
.
stub
(
ASRouter
"
handleMessageRequest
"
)
.
resolves
(
[
]
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
)
;
Assert
.
ok
(
ASRouter
.
sendTriggerMessage
.
calledWith
(
{
browser
:
gBrowser
.
selectedBrowser
id
:
"
menuOpened
"
context
:
{
source
:
MenuMessage
.
SOURCES
.
APP_MENU
browserIsSelected
:
true
isAIWindow
:
false
}
}
)
"
sendTriggerMessage
was
called
when
opening
the
AppMenu
panel
.
"
)
;
ASRouter
.
sendTriggerMessage
.
resetHistory
(
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
PXI_MENU
)
;
Assert
.
ok
(
ASRouter
.
sendTriggerMessage
.
calledWith
(
{
browser
:
gBrowser
.
selectedBrowser
id
:
"
menuOpened
"
context
:
{
source
:
MenuMessage
.
SOURCES
.
PXI_MENU
browserIsSelected
:
true
isAIWindow
:
false
}
}
)
"
sendTriggerMessage
was
called
when
opening
the
PXI
panel
.
"
)
;
handleMessageRequestStub
.
restore
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_show_fxa_cta_message
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
spy
(
ASRouter
"
addImpression
"
)
;
sandbox
.
spy
(
AboutWelcomeTelemetry
.
prototype
"
submitGleanPingForPing
"
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
(
)
=
>
{
await
withEachSource
(
async
source
=
>
{
info
(
Testing
source
{
source
}
)
;
await
reopenMenuSource
(
source
gTestFxAMessage
window
async
(
msgElement
panel
)
=
>
{
AccessibilityUtils
.
setEnv
(
{
mustHaveAccessibleRule
:
false
}
)
;
msgElement
.
click
(
)
;
AccessibilityUtils
.
resetEnv
(
)
;
Assert
.
equal
(
panel
.
state
"
open
"
"
Panel
should
still
be
in
the
open
state
.
"
)
;
}
)
;
Assert
.
ok
(
ASRouter
.
addImpression
.
calledWith
(
gTestFxAMessage
)
"
The
test
message
had
an
impression
recorded
for
it
.
"
)
;
Assert
.
ok
(
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
calledWithMatch
(
sinon
.
match
(
{
message_id
:
gTestFxAMessage
.
id
event
:
"
IMPRESSION
"
pingType
:
"
menu
"
source
}
)
)
"
The
test
message
had
an
impression
recorded
for
it
.
"
)
;
ASRouter
.
addImpression
.
resetHistory
(
)
;
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
resetHistory
(
)
;
}
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_show_fxa_cta_message_multiple_windows
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
win1
=
window
;
let
win2
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
let
win3
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
win2
.
gSync
.
init
(
)
;
win3
.
gSync
.
init
(
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
handleMessageRequestStub
=
>
{
let
message
=
gTestFxAMessage
;
for
(
let
win
of
[
win1
win2
win3
]
)
{
await
SimpleTest
.
promiseFocus
(
win
)
;
await
withEachSource
(
async
source
=
>
{
await
reopenMenuSource
(
source
message
win
)
;
}
)
;
}
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
gTestFxAMessage
win3
async
(
)
=
>
{
let
win3Message
=
win3
.
PanelUI
.
mainView
.
querySelector
(
"
menu
-
message
"
)
;
await
win3Message
.
updateComplete
;
win3Message
.
closeButton
.
click
(
)
;
Assert
.
ok
(
!
win3Message
.
isConnected
"
Closed
message
should
have
been
immediately
removed
from
the
DOM
.
"
)
;
}
)
;
handleMessageRequestStub
.
resolves
(
[
]
)
;
for
(
let
win
of
[
win1
win2
win3
]
)
{
await
SimpleTest
.
promiseFocus
(
win
)
;
await
withEachSource
(
async
source
=
>
{
await
reopenMenuSource
(
source
null
win
)
;
}
)
;
}
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win2
)
;
await
BrowserTestUtils
.
closeWindow
(
win3
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_fxa_cta_actions
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
spy
(
AboutWelcomeTelemetry
.
prototype
"
submitGleanPingForPing
"
)
;
sandbox
.
stub
(
SpecialMessageActions
"
handleAction
"
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
(
)
=
>
{
await
withEachSource
(
async
source
=
>
{
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
resetHistory
(
)
;
SpecialMessageActions
.
handleAction
.
resetHistory
(
)
;
await
reopenMenuSource
(
source
gTestFxAMessage
window
async
(
messageEl
panel
)
=
>
{
messageEl
.
primaryButton
.
click
(
)
;
Assert
.
notEqual
(
panel
.
state
"
open
"
"
Panel
should
have
started
to
close
.
"
)
;
}
)
;
let
clonedPrimaryAction
=
structuredClone
(
gTestFxAMessage
.
content
.
primaryAction
)
;
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
APP_MENU
)
{
clonedPrimaryAction
.
data
.
entrypoint
=
"
fxa_app_menu
"
;
clonedPrimaryAction
.
data
.
extraParams
.
utm_content
+
=
"
-
app_menu
"
;
}
else
if
(
source
=
=
=
MenuMessage
.
SOURCES
.
PXI_MENU
)
{
clonedPrimaryAction
.
data
.
entrypoint
=
"
fxa_avatar_menu
"
;
clonedPrimaryAction
.
data
.
extraParams
.
utm_content
+
=
"
-
avatar
"
;
}
Assert
.
ok
(
SpecialMessageActions
.
handleAction
.
calledWith
(
clonedPrimaryAction
gBrowser
.
selectedBrowser
)
"
The
message
action
for
signing
up
for
an
account
was
passed
.
"
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
ok
(
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
calledWithMatch
(
sinon
.
match
(
{
message_id
:
gTestFxAMessage
.
id
event
:
"
CLICK
"
pingType
:
"
menu
"
source
}
)
)
"
A
ping
for
clicking
the
message
should
have
been
passed
.
"
)
;
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
resetHistory
(
)
;
SpecialMessageActions
.
handleAction
.
resetHistory
(
)
;
await
reopenMenuSource
(
source
gTestFxAMessage
window
async
messageEl
=
>
{
messageEl
.
closeButton
.
click
(
)
;
}
)
;
Assert
.
ok
(
SpecialMessageActions
.
handleAction
.
calledWith
(
gTestFxAMessage
.
content
.
closeAction
gBrowser
.
selectedBrowser
)
"
The
message
action
for
closing
the
message
should
have
been
passed
.
"
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
ok
(
AboutWelcomeTelemetry
.
prototype
.
submitGleanPingForPing
.
calledWithMatch
(
sinon
.
match
(
{
message_id
:
gTestFxAMessage
.
id
event
:
"
DISMISS
"
pingType
:
"
menu
"
source
}
)
)
"
A
ping
for
dismissing
the
message
should
have
been
passed
.
"
)
;
}
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_fxa_cta_notification_precedence
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
spy
(
AboutWelcomeTelemetry
.
prototype
"
submitGleanPingForPing
"
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
(
)
=
>
{
const
NOTIFICATION_ID
=
"
update
-
restart
"
;
AppMenuNotifications
.
showNotification
(
NOTIFICATION_ID
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
null
)
;
AppMenuNotifications
.
removeNotification
(
NOTIFICATION_ID
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
gTestFxAMessage
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_default_cta_allowed_sources
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
let
defaultMsg
=
buildDefaultCtaMessage
(
)
;
Assert
.
ok
(
defaultMsg
"
Found
a
test
default_cta
message
to
use
.
"
)
;
await
withTestMessage
(
sandbox
defaultMsg
async
(
)
=
>
{
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
defaultMsg
)
;
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
PXI_MENU
null
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
function
stubSignedIn
(
sandbox
signedIn
)
{
const
{
UIState
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
services
-
sync
/
UIState
.
sys
.
mjs
"
)
;
return
sandbox
.
stub
(
UIState
"
get
"
)
.
returns
(
{
status
:
signedIn
?
UIState
.
STATUS_SIGNED_IN
:
UIState
.
STATUS_NOT_CONFIGURED
}
)
;
}
add_task
(
async
function
test_message_type_suppression_rules
(
)
{
let
defaultMsg
=
buildDefaultCtaMessage
(
{
id
:
"
TEST_DEFAULT_CTA_SIMPLE_LAYOUT
"
layout
:
"
simple
"
}
)
;
Assert
.
ok
(
defaultMsg
"
Found
a
test
default_cta
message
to
use
.
"
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
const
signedInStub
=
stubSignedIn
(
sandbox
true
)
;
await
withTestMessage
(
sandbox
gTestFxAMessage
async
(
)
=
>
{
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
null
)
;
}
)
;
const
allowedFXA
=
structuredClone
(
gTestFxAMessage
)
;
allowedFXA
.
content
=
{
.
.
.
allowedFXA
.
content
allowWhenSignedIn
:
true
}
;
await
withTestMessage
(
sandbox
allowedFXA
async
(
)
=
>
{
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
allowedFXA
)
;
}
)
;
await
withTestMessage
(
sandbox
defaultMsg
async
(
)
=
>
{
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
defaultMsg
)
;
}
)
;
signedInStub
.
restore
?
.
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_default_cta_does_not_replace_fxa_row
(
)
{
let
sandbox
=
sinon
.
createSandbox
(
)
;
const
defaultMsg
=
buildDefaultCtaMessage
(
{
id
:
"
TEST_DEFAULT_CTA_SIMPLE_LAYOUT
"
layout
:
"
simple
"
}
)
;
await
withTestMessage
(
sandbox
defaultMsg
async
(
)
=
>
{
await
reopenMenuSource
(
MenuMessage
.
SOURCES
.
APP_MENU
defaultMsg
window
async
(
_msgEl
panel
)
=
>
{
const
view
=
panel
.
ownerGlobal
.
PanelUI
.
mainView
;
const
separator
=
view
.
querySelector
(
"
#
appMenu
-
fxa
-
separator
"
)
;
const
fxaRow
=
view
.
querySelector
(
"
#
appMenu
-
fxa
-
status2
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
separator
)
"
FxA
separator
remains
visible
for
default_cta
.
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
isVisible
(
fxaRow
)
"
FxA
sign
-
in
row
remains
visible
for
default_cta
.
"
)
;
}
)
;
}
)
;
sandbox
.
restore
(
)
;
}
)
;
