"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AttributionCode
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
MacAttribution
"
"
resource
:
/
/
/
modules
/
MacAttribution
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
ConsoleAPI
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
browser
.
attribution
.
loglevel
"
prefix
:
"
AttributionCode
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
const
ATTR_CODE_MAX_LENGTH
=
1010
;
const
ATTR_CODE_VALUE_REGEX
=
/
[
a
-
zA
-
Z0
-
9_
%
\
\
-
\
\
.
\
\
(
\
\
)
]
*
/
;
const
ATTR_CODE_FIELD_SEPARATOR
=
"
%
26
"
;
const
ATTR_CODE_KEY_VALUE_SEPARATOR
=
"
%
3D
"
;
const
ATTR_CODE_KEYS
=
[
"
source
"
"
medium
"
"
campaign
"
"
content
"
"
experiment
"
"
variation
"
"
ua
"
]
;
let
gCachedAttrData
=
null
;
var
AttributionCode
=
{
get
attributionFile
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
file
=
Services
.
dirsvc
.
get
(
"
LocalAppData
"
Ci
.
nsIFile
)
;
file
.
append
(
Services
.
appinfo
.
vendor
|
|
"
mozilla
"
)
;
file
.
append
(
AppConstants
.
MOZ_APP_NAME
)
;
file
.
append
(
"
postSigningData
"
)
;
return
file
;
}
else
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
file
;
try
{
file
=
Services
.
dirsvc
.
get
(
"
UpdRootD
"
Ci
.
nsIFile
)
;
}
catch
(
ex
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
ex
instanceof
Ci
.
nsIException
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_FAILURE
&
&
env
.
exists
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
)
{
let
path
=
env
.
get
(
"
XPCSHELL_TEST_TEMP_DIR
"
)
;
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
path
)
;
file
.
append
(
"
nested_UpdRootD_1
"
)
;
file
.
append
(
"
nested_UpdRootD_2
"
)
;
}
else
{
throw
ex
;
}
}
file
.
append
(
"
macAttributionData
"
)
;
return
file
;
}
return
null
;
}
async
writeAttributionFile
(
code
)
{
let
file
=
AttributionCode
.
attributionFile
;
let
dir
=
file
.
parent
;
try
{
dir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
{
throw
ex
;
}
}
let
bytes
=
new
TextEncoder
(
)
.
encode
(
code
)
;
await
OS
.
File
.
writeAtomic
(
file
.
path
bytes
)
;
}
get
allowedCodeKeys
(
)
{
return
[
.
.
.
ATTR_CODE_KEYS
]
;
}
parseAttributionCode
(
code
)
{
if
(
code
.
length
>
ATTR_CODE_MAX_LENGTH
)
{
return
{
}
;
}
let
isValid
=
true
;
let
parsed
=
{
}
;
for
(
let
param
of
code
.
split
(
ATTR_CODE_FIELD_SEPARATOR
)
)
{
let
[
key
value
]
=
param
.
split
(
ATTR_CODE_KEY_VALUE_SEPARATOR
2
)
;
if
(
key
&
&
ATTR_CODE_KEYS
.
includes
(
key
)
)
{
if
(
value
&
&
ATTR_CODE_VALUE_REGEX
.
test
(
value
)
)
{
parsed
[
key
]
=
value
;
}
}
else
{
log
.
debug
(
parseAttributionCode
:
"
{
code
}
"
=
>
isValid
=
false
:
"
{
key
}
"
"
{
value
}
"
)
;
isValid
=
false
;
break
;
}
}
if
(
isValid
)
{
return
parsed
;
}
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_ATTRIBUTION_ERRORS
"
)
.
add
(
"
decode_error
"
)
;
return
{
}
;
}
parseAttributionCodeFromUrl
(
url
)
{
if
(
!
url
)
{
return
{
}
;
}
let
parsed
=
{
}
;
let
params
=
new
URL
(
url
)
.
searchParams
;
for
(
let
key
of
ATTR_CODE_KEYS
)
{
for
(
let
paramKey
of
[
utm_
{
key
}
funnel_
{
key
}
key
]
)
{
if
(
params
.
has
(
paramKey
)
)
{
let
value
=
encodeURIComponent
(
params
.
get
(
paramKey
)
)
;
if
(
value
&
&
ATTR_CODE_VALUE_REGEX
.
test
(
value
)
)
{
parsed
[
key
]
=
value
;
}
}
}
}
return
parsed
;
}
serializeAttributionData
(
data
)
{
let
s
=
"
"
;
for
(
let
key
of
ATTR_CODE_KEYS
)
{
if
(
key
in
data
)
{
let
value
=
data
[
key
]
;
if
(
s
)
{
s
+
=
ATTR_CODE_FIELD_SEPARATOR
;
}
s
+
=
{
key
}
{
ATTR_CODE_KEY_VALUE_SEPARATOR
}
{
value
}
;
}
}
return
s
;
}
async
getAttrDataAsync
(
)
{
if
(
gCachedAttrData
!
=
null
)
{
log
.
debug
(
getAttrDataAsync
:
attribution
is
cached
:
{
JSON
.
stringify
(
gCachedAttrData
)
}
)
;
return
gCachedAttrData
;
}
gCachedAttrData
=
{
}
;
let
attributionFile
=
this
.
attributionFile
;
if
(
!
attributionFile
)
{
log
.
debug
(
getAttrDataAsync
:
no
attribution
(
attributionFile
is
null
)
)
;
return
gCachedAttrData
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
!
(
await
OS
.
File
.
exists
(
attributionFile
.
path
)
)
)
{
log
.
debug
(
getAttrDataAsync
:
macOS
&
&
!
exists
(
"
{
attributionFile
.
path
}
"
)
)
;
try
{
let
referrer
=
await
MacAttribution
.
getReferrerUrl
(
)
;
log
.
debug
(
getAttrDataAsync
:
macOS
attribution
getReferrerUrl
:
"
{
referrer
}
"
)
;
gCachedAttrData
=
this
.
parseAttributionCodeFromUrl
(
referrer
)
;
}
catch
(
ex
)
{
gCachedAttrData
=
{
}
;
log
.
warn
(
"
Caught
exception
fetching
macOS
attribution
codes
!
"
ex
)
;
if
(
ex
instanceof
Ci
.
nsIException
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_UNEXPECTED
)
{
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_ATTRIBUTION_ERRORS
"
)
.
add
(
"
quarantine_error
"
)
;
}
}
log
.
debug
(
macOS
attribution
data
is
{
JSON
.
stringify
(
gCachedAttrData
)
}
)
;
try
{
let
code
=
this
.
serializeAttributionData
(
gCachedAttrData
)
;
log
.
debug
(
macOS
attribution
data
serializes
as
"
{
code
}
"
)
;
await
this
.
writeAttributionFile
(
code
)
;
}
catch
(
ex
)
{
log
.
debug
(
Caught
exception
writing
"
{
attributionFile
.
path
}
"
ex
)
;
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_ATTRIBUTION_ERRORS
"
)
.
add
(
"
write_error
"
)
;
return
gCachedAttrData
;
}
log
.
debug
(
Returning
after
successfully
writing
"
{
attributionFile
.
path
}
"
)
;
return
gCachedAttrData
;
}
log
.
debug
(
getAttrDataAsync
:
!
macOS
|
|
!
exists
(
"
{
attributionFile
.
path
}
"
)
)
;
let
bytes
;
try
{
bytes
=
await
OS
.
File
.
read
(
attributionFile
.
path
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
OS
.
File
.
Error
&
&
ex
.
becauseNoSuchFile
)
{
log
.
debug
(
getAttrDataAsync
:
!
exists
(
"
{
attributionFile
.
path
}
"
)
returning
{
JSON
.
stringify
(
gCachedAttrData
)
}
)
;
return
gCachedAttrData
;
}
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_ATTRIBUTION_ERRORS
"
)
.
add
(
"
read_error
"
)
;
}
if
(
bytes
)
{
try
{
let
decoder
=
new
TextDecoder
(
)
;
let
code
=
decoder
.
decode
(
bytes
)
;
log
.
debug
(
getAttrDataAsync
:
{
attributionFile
.
path
}
deserializes
to
{
code
}
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
!
code
)
{
return
gCachedAttrData
;
}
gCachedAttrData
=
this
.
parseAttributionCode
(
code
)
;
log
.
debug
(
getAttrDataAsync
:
{
code
}
parses
to
{
JSON
.
stringify
(
gCachedAttrData
)
}
)
;
}
catch
(
ex
)
{
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_ATTRIBUTION_ERRORS
"
)
.
add
(
"
decode_error
"
)
;
}
}
return
gCachedAttrData
;
}
getCachedAttributionData
(
)
{
return
gCachedAttrData
;
}
async
deleteFileAsync
(
)
{
try
{
await
OS
.
File
.
remove
(
this
.
attributionFile
.
path
)
;
}
catch
(
ex
)
{
}
}
_clearCache
(
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
exists
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
)
{
gCachedAttrData
=
null
;
}
}
}
;
