"
use
strict
"
;
const
{
PlacesUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
FAVICON_DATA
=
"
data
:
image
/
png
;
base64
iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8
/
9hAAAABmJLR0QA
/
wD
/
AP
+
gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gwMDAsTBZbkNwAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABNElEQVQ4y8WSsU0DURBE3yyWIaAJaqAAN4DPSL6AlIACKIEOyJEgRsIgOOkiInJqgAKowNg7BHdn7MOksNl
+
zZ
/
/
dvbDf5cAiklp22BdVtXdeTEpDYDB9m1VzU6OJuVp2NdEQCaI96fH2YHG4
+
mDduKYNMYINTcjcGbXzQVDEAphG0k48zUsajIbnAiMIXThpW8EICE0RAK4dvoKg9NIcTiQ589otyHOZLnwqK5nLwBFUZ4igc3iM0d1ff8CMC6mZ6Ihiaqq3gi1aUAnArD00SW1fq5OLBg0ymYmSZsR2
/
t4e
/
rGyCLW0sbp3oq
+
yTYqVgytQWui2FS7XYF7GFprY921T4CNQt8zr47dNzCkIX7y
/
jBtH
+
v
+
RGMQrc828W8pApnZbmEVQp
/
Ae7BlOy2ttib81
/
UFc
+
WRWEbjckIAAAAASUVORK5CYII
=
"
;
const
{
BookmarksPolicies
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
policies
/
BookmarksPolicies
.
jsm
"
)
;
let
CURRENT_POLICY
;
const
basePath
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
mochi
.
test
:
8888
"
)
;
const
BASE_POLICY
=
{
policies
:
{
DisplayBookmarksToolbar
:
true
Bookmarks
:
[
{
Title
:
"
Bookmark
1
"
URL
:
"
https
:
/
/
bookmark1
.
example
.
com
/
"
Favicon
:
FAVICON_DATA
}
{
Title
:
"
Bookmark
2
"
URL
:
"
https
:
/
/
bookmark2
.
example
.
com
/
"
Favicon
:
{
basePath
}
/
404
.
sjs
}
{
Title
:
"
Bookmark
3
"
URL
:
"
https
:
/
/
bookmark3
.
example
.
com
/
"
Folder
:
"
Folder
1
"
}
{
Title
:
"
Bookmark
4
"
URL
:
"
https
:
/
/
bookmark4
.
example
.
com
/
"
Placement
:
"
menu
"
}
{
Title
:
"
Bookmark
5
"
URL
:
"
https
:
/
/
bookmark5
.
example
.
com
/
"
Folder
:
"
Folder
1
"
}
{
Title
:
"
Bookmark
6
"
URL
:
"
https
:
/
/
bookmark6
.
example
.
com
/
"
Placement
:
"
menu
"
Folder
:
"
Folder
2
"
}
]
}
}
;
function
deepClone
(
obj
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
obj
)
)
;
}
function
findBookmarkInPolicy
(
bookmark
)
{
for
(
let
entry
of
CURRENT_POLICY
.
policies
.
Bookmarks
)
{
if
(
entry
.
Title
=
=
bookmark
.
title
)
{
return
entry
;
}
}
return
null
;
}
async
function
promiseAllChangesMade
(
{
itemsToAdd
itemsToRemove
}
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
events
=
>
{
is
(
events
.
length
1
"
Should
only
have
1
event
.
"
)
;
switch
(
events
[
0
]
.
type
)
{
case
"
bookmark
-
added
"
:
itemsToAdd
-
-
;
if
(
itemsToAdd
=
=
0
&
&
itemsToRemove
=
=
0
)
{
PlacesUtils
.
bookmarks
.
removeObserver
(
bmObserver
)
;
PlacesUtils
.
observers
.
removeListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
]
listener
)
;
resolve
(
)
;
}
break
;
case
"
bookmark
-
removed
"
:
itemsToRemove
-
-
;
if
(
itemsToAdd
=
=
0
&
&
itemsToRemove
=
=
0
)
{
PlacesUtils
.
bookmarks
.
removeObserver
(
bmObserver
)
;
PlacesUtils
.
observers
.
removeListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
]
listener
)
;
resolve
(
)
;
}
break
;
}
}
;
let
bmObserver
=
{
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onItemChanged
(
)
{
}
onItemMoved
(
)
{
}
}
;
PlacesUtils
.
bookmarks
.
addObserver
(
bmObserver
)
;
PlacesUtils
.
observers
.
addListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
]
listener
)
;
}
)
;
}
async
function
check
(
{
expectedNumberOfFolders
}
)
{
let
bookmarks
=
[
]
folders
=
[
]
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
guidPrefix
:
BookmarksPolicies
.
BOOKMARK_GUID_PREFIX
}
r
=
>
{
bookmarks
.
push
(
r
)
;
}
)
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
guidPrefix
:
BookmarksPolicies
.
FOLDER_GUID_PREFIX
}
r
=
>
{
folders
.
push
(
r
)
;
}
)
;
let
foldersToGuids
=
new
Map
(
)
;
for
(
let
folder
of
folders
)
{
is
(
folder
.
type
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
"
Correct
type
for
folder
"
)
;
foldersToGuids
.
set
(
folder
.
title
folder
.
guid
)
;
}
is
(
folders
.
length
expectedNumberOfFolders
"
Correct
number
of
folders
expected
"
)
;
is
(
foldersToGuids
.
size
expectedNumberOfFolders
"
There
aren
'
t
two
different
folders
with
the
same
name
"
)
;
is
(
CURRENT_POLICY
.
policies
.
Bookmarks
.
length
bookmarks
.
length
"
The
correct
number
of
bookmarks
exist
"
)
;
for
(
let
bookmark
of
bookmarks
)
{
is
(
bookmark
.
type
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
"
Correct
type
for
bookmark
"
)
;
let
entry
=
findBookmarkInPolicy
(
bookmark
)
;
is
(
bookmark
.
title
entry
.
Title
"
Title
matches
"
)
;
is
(
bookmark
.
url
.
href
entry
.
URL
"
URL
matches
"
)
;
let
expectedPlacementGuid
;
if
(
entry
.
Folder
)
{
expectedPlacementGuid
=
foldersToGuids
.
get
(
entry
.
Folder
)
;
}
else
{
expectedPlacementGuid
=
entry
.
Placement
=
=
"
menu
"
?
PlacesUtils
.
bookmarks
.
menuGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
;
}
is
(
bookmark
.
parentGuid
expectedPlacementGuid
"
Correctly
placed
"
)
;
}
}
add_task
(
async
function
test_initial_bookmarks
(
)
{
CURRENT_POLICY
=
deepClone
(
BASE_POLICY
)
;
await
Promise
.
all
(
[
promiseAllChangesMade
(
{
itemsToAdd
:
8
itemsToRemove
:
0
}
)
setupPolicyEngineWithJson
(
CURRENT_POLICY
)
]
)
;
await
check
(
{
expectedNumberOfFolders
:
2
}
)
;
}
)
;
add_task
(
async
function
checkFavicon
(
)
{
let
bookmark1url
=
CURRENT_POLICY
.
policies
.
Bookmarks
[
0
]
.
URL
;
let
result
=
await
new
Promise
(
resolve
=
>
{
PlacesUtils
.
favicons
.
getFaviconDataForPage
(
Services
.
io
.
newURI
(
bookmark1url
)
(
uri
_
data
)
=
>
resolve
(
{
uri
data
}
)
)
;
}
)
;
is
(
result
.
uri
.
spec
"
fake
-
favicon
-
uri
:
"
+
bookmark1url
"
Favicon
URI
is
correct
"
)
;
is
(
result
.
data
.
length
464
"
Favicon
data
has
the
correct
length
"
)
;
let
faviconsExpiredNotification
=
TestUtils
.
topicObserved
(
"
places
-
favicons
-
expired
"
)
;
PlacesUtils
.
favicons
.
expireAllFavicons
(
)
;
await
faviconsExpiredNotification
;
}
)
;
add_task
(
async
function
test_remove_Bookmark_2
(
)
{
CURRENT_POLICY
.
policies
.
Bookmarks
.
splice
(
3
1
)
;
await
Promise
.
all
(
[
promiseAllChangesMade
(
{
itemsToAdd
:
0
itemsToRemove
:
1
}
)
setupPolicyEngineWithJson
(
CURRENT_POLICY
)
]
)
;
await
check
(
{
expectedNumberOfFolders
:
2
}
)
;
}
)
;
add_task
(
async
function
test_remove_Bookmark_5
(
)
{
CURRENT_POLICY
.
policies
.
Bookmarks
.
splice
(
-
1
1
)
;
await
Promise
.
all
(
[
promiseAllChangesMade
(
{
itemsToAdd
:
0
itemsToRemove
:
2
}
)
setupPolicyEngineWithJson
(
CURRENT_POLICY
)
]
)
;
await
check
(
{
expectedNumberOfFolders
:
1
}
)
;
}
)
;
add_task
(
async
function
test_revert_to_original_policy
(
)
{
CURRENT_POLICY
=
deepClone
(
BASE_POLICY
)
;
await
Promise
.
all
(
[
promiseAllChangesMade
(
{
itemsToAdd
:
3
itemsToRemove
:
0
}
)
setupPolicyEngineWithJson
(
CURRENT_POLICY
)
]
)
;
await
check
(
{
expectedNumberOfFolders
:
2
}
)
;
}
)
;
add_task
(
async
function
test_empty_all_bookmarks
(
)
{
CURRENT_POLICY
=
{
policies
:
{
Bookmarks
:
[
]
}
}
;
await
Promise
.
all
(
[
promiseAllChangesMade
(
{
itemsToAdd
:
0
itemsToRemove
:
8
}
)
setupPolicyEngineWithJson
(
CURRENT_POLICY
)
]
)
;
check
(
{
expectedNumberOfFolders
:
0
}
)
;
}
)
;
