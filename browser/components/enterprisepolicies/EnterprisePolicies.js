ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
WindowsGPOParser
:
"
resource
:
/
/
/
modules
/
policies
/
WindowsGPOParser
.
jsm
"
Policies
:
"
resource
:
/
/
/
modules
/
policies
/
Policies
.
jsm
"
JsonSchemaValidator
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
JsonSchemaValidator
.
jsm
"
}
)
;
const
POLICIES_FILENAME
=
"
policies
.
json
"
;
const
PREF_ALTERNATE_PATH
=
"
browser
.
policies
.
alternatePath
"
;
const
MAGIC_TEST_ROOT_PREFIX
=
"
<
test
-
root
>
"
;
const
PREF_TEST_ROOT
=
"
mochitest
.
testRoot
"
;
const
PREF_LOGLEVEL
=
"
browser
.
policies
.
loglevel
"
;
const
PREF_DISALLOW_ENTERPRISE
=
"
browser
.
policies
.
testing
.
disallowEnterprise
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
return
new
ConsoleAPI
(
{
prefix
:
"
Enterprise
Policies
"
maxLogLevel
:
"
error
"
maxLogLevelPref
:
PREF_LOGLEVEL
}
)
;
}
)
;
const
EnterprisePoliciesFactory
=
{
_instance
:
null
createInstance
:
function
BGSF_createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
return
this
.
_instance
=
=
null
?
this
.
_instance
=
new
EnterprisePoliciesManager
(
)
:
this
.
_instance
;
}
}
;
function
EnterprisePoliciesManager
(
)
{
Services
.
obs
.
addObserver
(
this
"
profile
-
after
-
change
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
final
-
ui
-
startup
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
EnterprisePolicies
:
Restart
"
true
)
;
}
EnterprisePoliciesManager
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
ea4e1414
-
779b
-
458b
-
9d1f
-
d18e8efbc145
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
Ci
.
nsIEnterprisePolicies
]
)
_xpcom_factory
:
EnterprisePoliciesFactory
_initialize
(
)
{
let
provider
=
this
.
_chooseProvider
(
)
;
if
(
!
provider
)
{
this
.
status
=
Ci
.
nsIEnterprisePolicies
.
INACTIVE
;
return
;
}
if
(
provider
.
failed
)
{
this
.
status
=
Ci
.
nsIEnterprisePolicies
.
FAILED
;
return
;
}
this
.
status
=
Ci
.
nsIEnterprisePolicies
.
ACTIVE
;
this
.
_activatePolicies
(
provider
.
policies
)
;
}
_chooseProvider
(
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
gpoProvider
=
new
GPOPoliciesProvider
(
)
;
if
(
gpoProvider
.
hasPolicies
)
{
return
gpoProvider
;
}
}
let
jsonProvider
=
new
JSONPoliciesProvider
(
)
;
if
(
jsonProvider
.
hasPolicies
)
{
return
jsonProvider
;
}
return
null
;
}
_activatePolicies
(
unparsedPolicies
)
{
let
{
schema
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
policies
/
schema
.
jsm
"
{
}
)
;
for
(
let
policyName
of
Object
.
keys
(
unparsedPolicies
)
)
{
let
policySchema
=
schema
.
properties
[
policyName
]
;
let
policyParameters
=
unparsedPolicies
[
policyName
]
;
if
(
!
policySchema
)
{
log
.
error
(
Unknown
policy
:
{
policyName
}
)
;
continue
;
}
if
(
policySchema
.
enterprise_only
&
&
!
areEnterpriseOnlyPoliciesAllowed
(
)
)
{
log
.
error
(
Policy
{
policyName
}
is
only
allowed
on
ESR
)
;
continue
;
}
let
[
parametersAreValid
parsedParameters
]
=
JsonSchemaValidator
.
validateAndParseParameters
(
policyParameters
policySchema
)
;
if
(
!
parametersAreValid
)
{
log
.
error
(
Invalid
parameters
specified
for
{
policyName
}
.
)
;
continue
;
}
let
policyImpl
=
Policies
[
policyName
]
;
for
(
let
timing
of
Object
.
keys
(
this
.
_callbacks
)
)
{
let
policyCallback
=
policyImpl
[
timing
]
;
if
(
policyCallback
)
{
this
.
_schedulePolicyCallback
(
timing
policyCallback
.
bind
(
policyImpl
this
parsedParameters
)
)
;
}
}
}
}
_callbacks
:
{
onBeforeAddons
:
[
]
onProfileAfterChange
:
[
]
onBeforeUIStartup
:
[
]
onAllWindowsRestored
:
[
]
}
_schedulePolicyCallback
(
timing
callback
)
{
this
.
_callbacks
[
timing
]
.
push
(
callback
)
;
}
_runPoliciesCallbacks
(
timing
)
{
let
callbacks
=
this
.
_callbacks
[
timing
]
;
while
(
callbacks
.
length
>
0
)
{
let
callback
=
callbacks
.
shift
(
)
;
try
{
callback
(
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Error
running
"
callback
for
{
timing
}
:
ex
)
;
}
}
}
async
_restart
(
)
{
if
(
!
Cu
.
isInAutomation
)
{
return
;
}
DisallowedFeatures
=
{
}
;
this
.
_status
=
Ci
.
nsIEnterprisePolicies
.
UNINITIALIZED
;
for
(
let
timing
of
Object
.
keys
(
this
.
_callbacks
)
)
{
this
.
_callbacks
[
timing
]
=
[
]
;
}
delete
Services
.
ppmm
.
initialProcessData
.
policies
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
EnterprisePolicies
:
Restart
"
null
)
;
let
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
{
}
)
;
await
PromiseUtils
.
idleDispatch
(
(
)
=
>
{
this
.
observe
(
null
"
policies
-
startup
"
null
)
;
}
)
;
await
PromiseUtils
.
idleDispatch
(
(
)
=
>
{
this
.
observe
(
null
"
profile
-
after
-
change
"
null
)
;
}
)
;
await
PromiseUtils
.
idleDispatch
(
(
)
=
>
{
this
.
observe
(
null
"
final
-
ui
-
startup
"
null
)
;
}
)
;
await
PromiseUtils
.
idleDispatch
(
(
)
=
>
{
this
.
observe
(
null
"
sessionstore
-
windows
-
restored
"
null
)
;
}
)
;
}
observe
:
function
BG_observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
policies
-
startup
"
:
this
.
_initialize
(
)
;
this
.
_runPoliciesCallbacks
(
"
onBeforeAddons
"
)
;
break
;
case
"
profile
-
after
-
change
"
:
this
.
_runPoliciesCallbacks
(
"
onProfileAfterChange
"
)
;
break
;
case
"
final
-
ui
-
startup
"
:
this
.
_runPoliciesCallbacks
(
"
onBeforeUIStartup
"
)
;
break
;
case
"
sessionstore
-
windows
-
restored
"
:
this
.
_runPoliciesCallbacks
(
"
onAllWindowsRestored
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
EnterprisePolicies
:
AllPoliciesApplied
"
)
;
break
;
case
"
EnterprisePolicies
:
Restart
"
:
this
.
_restart
(
)
.
then
(
null
Cu
.
reportError
)
;
break
;
}
}
disallowFeature
(
feature
neededOnContentProcess
=
false
)
{
DisallowedFeatures
[
feature
]
=
true
;
if
(
neededOnContentProcess
)
{
Services
.
ppmm
.
initialProcessData
.
policies
.
disallowedFeatures
.
push
(
feature
)
;
if
(
Services
.
ppmm
.
childCount
>
1
)
{
Services
.
ppmm
.
broadcastAsyncMessage
(
"
EnterprisePolicies
:
DisallowFeature
"
{
feature
}
)
;
}
}
}
_status
:
Ci
.
nsIEnterprisePolicies
.
UNINITIALIZED
set
status
(
val
)
{
this
.
_status
=
val
;
if
(
val
!
=
Ci
.
nsIEnterprisePolicies
.
INACTIVE
)
{
Services
.
ppmm
.
initialProcessData
.
policies
=
{
status
:
val
disallowedFeatures
:
[
]
}
;
}
return
val
;
}
get
status
(
)
{
return
this
.
_status
;
}
isAllowed
:
function
BG_sanitize
(
feature
)
{
return
!
(
feature
in
DisallowedFeatures
)
;
}
}
;
let
DisallowedFeatures
=
{
}
;
function
areEnterpriseOnlyPoliciesAllowed
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_DISALLOW_ENTERPRISE
false
)
)
{
return
false
;
}
if
(
AppConstants
.
MOZ_UPDATE_CHANNEL
!
=
"
release
"
|
|
Cu
.
isInAutomation
)
{
return
true
;
}
return
false
;
}
class
JSONPoliciesProvider
{
constructor
(
)
{
this
.
_policies
=
null
;
this
.
_failed
=
false
;
this
.
_readData
(
)
;
}
get
hasPolicies
(
)
{
return
this
.
_policies
!
=
=
null
|
|
this
.
_failed
;
}
get
policies
(
)
{
return
this
.
_policies
;
}
get
failed
(
)
{
return
this
.
_failed
;
}
_getConfigurationFile
(
)
{
let
configFile
=
null
;
try
{
configFile
=
Services
.
dirsvc
.
get
(
"
XREAppDist
"
Ci
.
nsIFile
)
;
configFile
.
append
(
POLICIES_FILENAME
)
;
}
catch
(
ex
)
{
}
let
alternatePath
=
Services
.
prefs
.
getStringPref
(
PREF_ALTERNATE_PATH
"
"
)
;
if
(
alternatePath
&
&
(
!
configFile
|
|
!
configFile
.
exists
(
)
)
)
{
if
(
alternatePath
.
startsWith
(
MAGIC_TEST_ROOT_PREFIX
)
)
{
let
testRoot
=
Services
.
prefs
.
getStringPref
(
PREF_TEST_ROOT
)
;
let
relativePath
=
alternatePath
.
substring
(
MAGIC_TEST_ROOT_PREFIX
.
length
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
relativePath
=
relativePath
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
alternatePath
=
testRoot
+
relativePath
;
}
configFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
configFile
.
initWithPath
(
alternatePath
)
;
}
return
configFile
;
}
_readData
(
)
{
try
{
let
data
=
Cu
.
readUTF8File
(
this
.
_getConfigurationFile
(
)
)
;
if
(
data
)
{
this
.
_policies
=
JSON
.
parse
(
data
)
.
policies
;
}
}
catch
(
ex
)
{
if
(
ex
instanceof
Components
.
Exception
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
}
else
if
(
ex
instanceof
SyntaxError
)
{
log
.
error
(
"
Error
parsing
JSON
file
"
)
;
this
.
_failed
=
true
;
}
else
{
log
.
error
(
"
Error
reading
file
"
)
;
this
.
_failed
=
true
;
}
}
}
}
class
GPOPoliciesProvider
{
constructor
(
)
{
this
.
_policies
=
null
;
let
wrk
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
wrk
.
open
(
wrk
.
ROOT_KEY_CURRENT_USER
"
SOFTWARE
\
\
Policies
"
wrk
.
ACCESS_READ
)
;
if
(
wrk
.
hasChild
(
"
Mozilla
\
\
Firefox
"
)
)
{
this
.
_readData
(
wrk
)
;
}
wrk
.
close
(
)
;
wrk
.
open
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
"
SOFTWARE
\
\
Policies
"
wrk
.
ACCESS_READ
)
;
if
(
wrk
.
hasChild
(
"
Mozilla
\
\
Firefox
"
)
)
{
this
.
_readData
(
wrk
)
;
}
wrk
.
close
(
)
;
}
get
hasPolicies
(
)
{
return
this
.
_policies
!
=
=
null
;
}
get
policies
(
)
{
return
this
.
_policies
;
}
get
failed
(
)
{
return
this
.
_failed
;
}
_readData
(
wrk
)
{
this
.
_policies
=
WindowsGPOParser
.
readPolicies
(
wrk
this
.
_policies
)
;
}
}
var
components
=
[
EnterprisePoliciesManager
]
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
components
)
;
