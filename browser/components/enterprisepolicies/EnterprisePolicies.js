ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
Policies
:
"
resource
:
/
/
/
modules
/
policies
/
Policies
.
jsm
"
PoliciesValidator
:
"
resource
:
/
/
/
modules
/
policies
/
PoliciesValidator
.
jsm
"
}
)
;
const
POLICIES_FILENAME
=
"
policies
.
json
"
;
const
PREF_ALTERNATE_PATH
=
"
browser
.
policies
.
alternatePath
"
;
const
PREF_ENABLED
=
"
browser
.
policies
.
enabled
"
;
const
PREF_LOGLEVEL
=
"
browser
.
policies
.
loglevel
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
return
new
ConsoleAPI
(
{
prefix
:
"
Enterprise
Policies
"
maxLogLevel
:
"
error
"
maxLogLevelPref
:
PREF_LOGLEVEL
}
)
;
}
)
;
const
EnterprisePoliciesFactory
=
{
_instance
:
null
createInstance
:
function
BGSF_createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
throw
Components
.
results
.
NS_ERROR_NO_AGGREGATION
;
return
this
.
_instance
=
=
null
?
this
.
_instance
=
new
EnterprisePoliciesManager
(
)
:
this
.
_instance
;
}
}
;
function
EnterprisePoliciesManager
(
)
{
Services
.
obs
.
addObserver
(
this
"
profile
-
after
-
change
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
final
-
ui
-
startup
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
EnterprisePolicies
:
Restart
"
true
)
;
}
EnterprisePoliciesManager
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
ea4e1414
-
779b
-
458b
-
9d1f
-
d18e8efbc145
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
Ci
.
nsIEnterprisePolicies
]
)
_xpcom_factory
:
EnterprisePoliciesFactory
_initialize
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_ENABLED
false
)
)
{
this
.
status
=
Ci
.
nsIEnterprisePolicies
.
INACTIVE
;
return
;
}
let
provider
=
this
.
_chooseProvider
(
)
;
if
(
!
provider
)
{
this
.
status
=
Ci
.
nsIEnterprisePolicies
.
INACTIVE
;
return
;
}
if
(
provider
.
failed
)
{
this
.
status
=
Ci
.
nsIEnterprisePolicies
.
FAILED
;
return
;
}
this
.
status
=
Ci
.
nsIEnterprisePolicies
.
ACTIVE
;
this
.
_activatePolicies
(
provider
.
policies
)
;
}
_chooseProvider
(
)
{
let
jsonProvider
=
new
JSONPoliciesProvider
(
)
;
if
(
jsonProvider
.
hasPolicies
)
{
return
jsonProvider
;
}
return
null
;
}
_activatePolicies
(
unparsedPolicies
)
{
let
{
schema
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
policies
/
schema
.
jsm
"
{
}
)
;
for
(
let
policyName
of
Object
.
keys
(
unparsedPolicies
)
)
{
let
policySchema
=
schema
.
properties
[
policyName
]
;
let
policyParameters
=
unparsedPolicies
[
policyName
]
;
if
(
!
policySchema
)
{
log
.
error
(
Unknown
policy
:
{
policyName
}
)
;
continue
;
}
let
[
parametersAreValid
parsedParameters
]
=
PoliciesValidator
.
validateAndParseParameters
(
policyParameters
policySchema
)
;
if
(
!
parametersAreValid
)
{
log
.
error
(
Invalid
parameters
specified
for
{
policyName
}
.
)
;
continue
;
}
let
policyImpl
=
Policies
[
policyName
]
;
for
(
let
timing
of
Object
.
keys
(
this
.
_callbacks
)
)
{
let
policyCallback
=
policyImpl
[
"
on
"
+
timing
]
;
if
(
policyCallback
)
{
this
.
_schedulePolicyCallback
(
timing
policyCallback
.
bind
(
null
this
parsedParameters
)
)
;
}
}
}
}
_callbacks
:
{
BeforeAddons
:
[
]
ProfileAfterChange
:
[
]
BeforeUIStartup
:
[
]
AllWindowsRestored
:
[
]
}
_schedulePolicyCallback
(
timing
callback
)
{
this
.
_callbacks
[
timing
]
.
push
(
callback
)
;
}
_runPoliciesCallbacks
(
timing
)
{
let
callbacks
=
this
.
_callbacks
[
timing
]
;
while
(
callbacks
.
length
>
0
)
{
let
callback
=
callbacks
.
shift
(
)
;
try
{
callback
(
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Error
running
"
callback
for
{
timing
}
:
ex
)
;
}
}
}
async
_restart
(
)
{
if
(
!
Cu
.
isInAutomation
)
{
return
;
}
DisallowedFeatures
=
{
}
;
this
.
_status
=
Ci
.
nsIEnterprisePolicies
.
UNINITIALIZED
;
for
(
let
timing
of
Object
.
keys
(
this
.
_callbacks
)
)
{
this
.
_callbacks
[
timing
]
=
[
]
;
}
delete
Services
.
ppmm
.
initialProcessData
.
policies
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
EnterprisePolicies
:
Restart
"
null
)
;
let
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
{
}
)
;
await
PromiseUtils
.
idleDispatch
(
(
)
=
>
{
this
.
observe
(
null
"
policies
-
startup
"
null
)
;
}
)
;
await
PromiseUtils
.
idleDispatch
(
(
)
=
>
{
this
.
observe
(
null
"
profile
-
after
-
change
"
null
)
;
}
)
;
await
PromiseUtils
.
idleDispatch
(
(
)
=
>
{
this
.
observe
(
null
"
final
-
ui
-
startup
"
null
)
;
}
)
;
await
PromiseUtils
.
idleDispatch
(
(
)
=
>
{
this
.
observe
(
null
"
sessionstore
-
windows
-
restored
"
null
)
;
}
)
;
}
observe
:
function
BG_observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
policies
-
startup
"
:
this
.
_initialize
(
)
;
this
.
_runPoliciesCallbacks
(
"
BeforeAddons
"
)
;
break
;
case
"
profile
-
after
-
change
"
:
this
.
_runPoliciesCallbacks
(
"
ProfileAfterChange
"
)
;
break
;
case
"
final
-
ui
-
startup
"
:
this
.
_runPoliciesCallbacks
(
"
BeforeUIStartup
"
)
;
break
;
case
"
sessionstore
-
windows
-
restored
"
:
this
.
_runPoliciesCallbacks
(
"
AllWindowsRestored
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
EnterprisePolicies
:
AllPoliciesApplied
"
)
;
break
;
case
"
EnterprisePolicies
:
Restart
"
:
this
.
_restart
(
)
.
then
(
null
Cu
.
reportError
)
;
break
;
}
}
disallowFeature
(
feature
neededOnContentProcess
=
false
)
{
DisallowedFeatures
[
feature
]
=
true
;
if
(
neededOnContentProcess
)
{
Services
.
ppmm
.
initialProcessData
.
policies
.
disallowedFeatures
.
push
(
feature
)
;
if
(
Services
.
ppmm
.
childCount
>
1
)
{
Services
.
ppmm
.
broadcastAsyncMessage
(
"
EnterprisePolicies
:
DisallowFeature
"
{
feature
}
)
;
}
}
}
_status
:
Ci
.
nsIEnterprisePolicies
.
UNINITIALIZED
set
status
(
val
)
{
this
.
_status
=
val
;
if
(
val
!
=
Ci
.
nsIEnterprisePolicies
.
INACTIVE
)
{
Services
.
ppmm
.
initialProcessData
.
policies
=
{
status
:
val
disallowedFeatures
:
[
]
}
;
}
return
val
;
}
get
status
(
)
{
return
this
.
_status
;
}
isAllowed
:
function
BG_sanitize
(
feature
)
{
return
!
(
feature
in
DisallowedFeatures
)
;
}
}
;
let
DisallowedFeatures
=
{
}
;
class
JSONPoliciesProvider
{
constructor
(
)
{
this
.
_policies
=
null
;
this
.
_failed
=
false
;
this
.
_readData
(
)
;
}
get
hasPolicies
(
)
{
return
this
.
_policies
!
=
=
null
|
|
this
.
_failed
;
}
get
policies
(
)
{
return
this
.
_policies
;
}
get
failed
(
)
{
return
this
.
_failed
;
}
_getConfigurationFile
(
)
{
let
configFile
=
Services
.
dirsvc
.
get
(
"
XREAppDist
"
Ci
.
nsIFile
)
;
configFile
.
append
(
POLICIES_FILENAME
)
;
let
alternatePath
=
Services
.
prefs
.
getStringPref
(
PREF_ALTERNATE_PATH
"
"
)
;
if
(
alternatePath
&
&
!
configFile
.
exists
(
)
)
{
configFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
configFile
.
initWithPath
(
alternatePath
)
;
}
return
configFile
;
}
_readData
(
)
{
try
{
let
data
=
Cu
.
readUTF8File
(
this
.
_getConfigurationFile
(
)
)
;
if
(
data
)
{
this
.
_policies
=
JSON
.
parse
(
data
)
.
policies
;
}
}
catch
(
ex
)
{
if
(
ex
instanceof
Components
.
Exception
&
&
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
}
else
if
(
ex
instanceof
SyntaxError
)
{
log
.
error
(
"
Error
parsing
JSON
file
"
)
;
this
.
_failed
=
true
;
}
else
{
log
.
error
(
"
Error
reading
file
"
)
;
this
.
_failed
=
true
;
}
}
}
}
var
components
=
[
EnterprisePoliciesManager
]
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
components
)
;
