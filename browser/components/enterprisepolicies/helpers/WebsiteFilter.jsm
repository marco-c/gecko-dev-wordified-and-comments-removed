"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
LIST_LENGTH_LIMIT
=
1000
;
const
PREF_LOGLEVEL
=
"
browser
.
policies
.
loglevel
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
return
new
ConsoleAPI
(
{
prefix
:
"
WebsiteFilter
Policy
"
maxLogLevel
:
"
error
"
maxLogLevelPref
:
PREF_LOGLEVEL
}
)
;
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
WebsiteFilter
"
]
;
function
WebsiteFilter
(
blocklist
exceptionlist
)
{
let
blockArray
=
[
]
exceptionArray
=
[
]
;
for
(
let
i
=
0
;
i
<
blocklist
.
length
&
&
i
<
LIST_LENGTH_LIMIT
;
i
+
+
)
{
try
{
let
pattern
=
new
MatchPattern
(
blocklist
[
i
]
)
;
blockArray
.
push
(
pattern
)
;
log
.
debug
(
Pattern
added
to
WebsiteFilter
.
Block
:
{
blocklist
[
i
]
}
)
;
}
catch
(
e
)
{
log
.
error
(
Invalid
pattern
on
WebsiteFilter
.
Block
:
{
blocklist
[
i
]
}
)
;
}
}
this
.
_blockPatterns
=
new
MatchPatternSet
(
blockArray
)
;
for
(
let
i
=
0
;
i
<
exceptionlist
.
length
&
&
i
<
LIST_LENGTH_LIMIT
;
i
+
+
)
{
try
{
let
pattern
=
new
MatchPattern
(
exceptionlist
[
i
]
)
;
exceptionArray
.
push
(
pattern
)
;
log
.
debug
(
Pattern
added
to
WebsiteFilter
.
Exception
:
{
exceptionlist
[
i
]
}
)
;
}
catch
(
e
)
{
log
.
error
(
Invalid
pattern
on
WebsiteFilter
.
Exception
:
{
exceptionlist
[
i
]
}
)
;
}
}
if
(
exceptionArray
.
length
)
{
this
.
_exceptionsPatterns
=
new
MatchPatternSet
(
exceptionArray
)
;
}
Services
.
obs
.
addObserver
(
this
"
http
-
on
-
modify
-
request
"
true
)
;
}
WebsiteFilter
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
observe
(
subject
topic
data
)
{
let
channel
isDocument
=
false
;
try
{
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
isDocument
=
channel
.
isDocument
;
}
catch
(
e
)
{
return
;
}
if
(
!
isDocument
)
{
return
;
}
if
(
this
.
_blockPatterns
.
matches
(
channel
.
URI
)
)
{
if
(
!
this
.
_exceptionsPatterns
|
|
!
this
.
_exceptionsPatterns
.
matches
(
channel
.
URI
)
)
{
channel
.
cancel
(
Cr
.
NS_ERROR_BLOCKED_BY_POLICY
)
;
}
}
}
}
;
