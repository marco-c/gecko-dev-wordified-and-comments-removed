"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
PREF_LOGLEVEL
=
"
browser
.
policies
.
loglevel
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
return
new
ConsoleAPI
(
{
prefix
:
"
BookmarksPolicies
.
jsm
"
maxLogLevel
:
"
error
"
maxLogLevelPref
:
PREF_LOGLEVEL
}
)
;
}
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
BookmarksPolicies
"
]
;
this
.
BookmarksPolicies
=
{
BOOKMARK_GUID_PREFIX
:
"
PolB
-
"
FOLDER_GUID_PREFIX
:
"
PolF
-
"
processBookmarks
(
param
)
{
calculateLists
(
param
)
.
then
(
async
function
addRemoveBookmarks
(
results
)
{
for
(
let
bookmark
of
results
.
add
.
values
(
)
)
{
await
insertBookmark
(
bookmark
)
.
catch
(
log
.
error
)
;
}
for
(
let
bookmark
of
results
.
remove
.
values
(
)
)
{
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
)
.
catch
(
log
.
error
)
;
}
for
(
let
bookmark
of
results
.
emptyFolders
.
values
(
)
)
{
await
PlacesUtils
.
bookmarks
.
remove
(
bookmark
)
.
catch
(
log
.
error
)
;
}
gFoldersMapPromise
.
then
(
map
=
>
map
.
clear
(
)
)
;
}
)
;
}
}
;
async
function
calculateLists
(
specifiedBookmarks
)
{
let
specifiedBookmarksMap
=
new
Map
(
)
;
for
(
let
bookmark
of
specifiedBookmarks
)
{
specifiedBookmarksMap
.
set
(
bookmark
.
URL
.
href
bookmark
)
;
}
let
existingBookmarksMap
=
new
Map
(
)
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
guidPrefix
:
BookmarksPolicies
.
BOOKMARK_GUID_PREFIX
}
(
bookmark
)
=
>
existingBookmarksMap
.
set
(
bookmark
.
url
.
href
bookmark
)
)
;
let
foldersSeen
=
new
Set
(
)
;
for
(
let
[
url
item
]
of
specifiedBookmarksMap
)
{
foldersSeen
.
add
(
item
.
Folder
)
;
if
(
existingBookmarksMap
.
has
(
url
)
)
{
log
.
debug
(
Bookmark
intersection
:
{
url
}
)
;
specifiedBookmarksMap
.
delete
(
url
)
;
existingBookmarksMap
.
delete
(
url
)
;
}
}
for
(
let
url
of
specifiedBookmarksMap
.
keys
(
)
)
{
log
.
debug
(
Bookmark
to
add
:
{
url
}
)
;
}
for
(
let
url
of
existingBookmarksMap
.
keys
(
)
)
{
log
.
debug
(
Bookmark
to
remove
:
{
url
}
)
;
}
let
foldersToRemove
=
new
Set
(
)
;
if
(
existingBookmarksMap
.
size
>
0
)
{
await
PlacesUtils
.
bookmarks
.
fetch
(
{
guidPrefix
:
BookmarksPolicies
.
FOLDER_GUID_PREFIX
}
(
folder
)
=
>
{
if
(
!
foldersSeen
.
has
(
folder
.
title
)
)
{
log
.
debug
(
Folder
to
remove
:
{
folder
.
title
}
)
;
foldersToRemove
.
add
(
folder
)
;
}
}
)
;
}
return
{
add
:
specifiedBookmarksMap
remove
:
existingBookmarksMap
emptyFolders
:
foldersToRemove
}
;
}
async
function
insertBookmark
(
bookmark
)
{
let
parentGuid
=
await
getParentGuid
(
bookmark
.
Placement
bookmark
.
Folder
)
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
url
:
Services
.
io
.
newURI
(
bookmark
.
URL
.
href
)
title
:
bookmark
.
Title
guid
:
PlacesUtils
.
generateGuidWithPrefix
(
BookmarksPolicies
.
BOOKMARK_GUID_PREFIX
)
parentGuid
}
)
;
if
(
bookmark
.
Favicon
)
{
await
setFaviconForBookmark
(
bookmark
)
.
catch
(
(
)
=
>
log
.
error
(
Error
setting
favicon
for
{
bookmark
.
Title
}
)
)
;
}
}
async
function
setFaviconForBookmark
(
bookmark
)
{
let
faviconURI
;
let
nullPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
;
switch
(
bookmark
.
Favicon
.
protocol
)
{
case
"
data
:
"
:
faviconURI
=
Services
.
io
.
newURI
(
"
fake
-
favicon
-
uri
:
"
+
bookmark
.
URL
.
href
)
;
PlacesUtils
.
favicons
.
replaceFaviconDataFromDataURL
(
faviconURI
bookmark
.
Favicon
.
href
0
nullPrincipal
)
;
break
;
case
"
http
:
"
:
case
"
https
:
"
:
faviconURI
=
Services
.
io
.
newURI
(
bookmark
.
Favicon
.
href
)
;
break
;
default
:
log
.
error
(
Bad
URL
given
for
favicon
on
bookmark
"
{
bookmark
.
Title
}
"
)
;
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
PlacesUtils
.
favicons
.
setAndFetchFaviconForPage
(
Services
.
io
.
newURI
(
bookmark
.
URL
.
href
)
faviconURI
false
PlacesUtils
.
favicons
.
FAVICON_LOAD_NON_PRIVATE
resolve
nullPrincipal
)
;
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gFoldersMapPromise
"
(
)
=
>
{
return
new
Promise
(
resolve
=
>
{
let
foldersMap
=
new
Map
(
)
;
return
PlacesUtils
.
bookmarks
.
fetch
(
{
guidPrefix
:
BookmarksPolicies
.
FOLDER_GUID_PREFIX
}
(
result
)
=
>
{
foldersMap
.
set
(
{
result
.
parentGuid
}
|
{
result
.
title
}
result
.
guid
)
;
}
)
.
then
(
(
)
=
>
resolve
(
foldersMap
)
)
;
}
)
;
}
)
;
async
function
getParentGuid
(
placement
folderTitle
)
{
let
parentGuid
=
(
placement
=
=
"
menu
"
)
?
PlacesUtils
.
bookmarks
.
menuGuid
:
PlacesUtils
.
bookmarks
.
toolbarGuid
;
if
(
!
folderTitle
)
{
return
parentGuid
;
}
let
foldersMap
=
await
gFoldersMapPromise
;
let
folderName
=
{
parentGuid
}
|
{
folderTitle
}
;
if
(
foldersMap
.
has
(
folderName
)
)
{
return
foldersMap
.
get
(
folderName
)
;
}
let
guid
=
PlacesUtils
.
generateGuidWithPrefix
(
BookmarksPolicies
.
FOLDER_GUID_PREFIX
)
;
await
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
title
:
folderTitle
guid
parentGuid
}
)
;
foldersMap
.
set
(
folderName
guid
)
;
return
guid
;
}
