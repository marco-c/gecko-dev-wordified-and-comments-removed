"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
const
PREF_LOGLEVEL
=
"
browser
.
policies
.
loglevel
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
return
new
ConsoleAPI
(
{
prefix
:
"
ProxyPolicies
.
jsm
"
maxLogLevel
:
"
error
"
maxLogLevelPref
:
PREF_LOGLEVEL
}
)
;
}
)
;
var
PROXY_TYPES_MAP
=
new
Map
(
[
[
"
none
"
Ci
.
nsIProtocolProxyService
.
PROXYCONFIG_DIRECT
]
[
"
system
"
Ci
.
nsIProtocolProxyService
.
PROXYCONFIG_SYSTEM
]
[
"
manual
"
Ci
.
nsIProtocolProxyService
.
PROXYCONFIG_MANUAL
]
[
"
autoDetect
"
Ci
.
nsIProtocolProxyService
.
PROXYCONFIG_WPAD
]
[
"
autoConfig
"
Ci
.
nsIProtocolProxyService
.
PROXYCONFIG_PAC
]
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
ProxyPolicies
"
]
;
var
ProxyPolicies
=
{
configureProxySettings
(
param
setPref
)
{
if
(
param
.
Mode
)
{
setPref
(
"
network
.
proxy
.
type
"
PROXY_TYPES_MAP
.
get
(
param
.
Mode
)
)
;
}
if
(
param
.
AutoConfigURL
)
{
setPref
(
"
network
.
proxy
.
autoconfig_url
"
param
.
AutoConfigURL
.
href
)
;
}
if
(
param
.
UseProxyForDNS
!
=
=
undefined
)
{
setPref
(
"
network
.
proxy
.
socks_remote_dns
"
param
.
UseProxyForDNS
)
;
}
if
(
param
.
AutoLogin
!
=
=
undefined
)
{
setPref
(
"
signon
.
autologin
.
proxy
"
param
.
AutoLogin
)
;
}
if
(
param
.
SOCKSVersion
!
=
=
undefined
)
{
if
(
param
.
SOCKSVersion
!
=
4
&
&
param
.
SOCKSVersion
!
=
5
)
{
log
.
error
(
"
Invalid
SOCKS
version
"
)
;
}
else
{
setPref
(
"
network
.
proxy
.
socks_version
"
param
.
SOCKSVersion
)
;
}
}
if
(
param
.
Passthrough
!
=
=
undefined
)
{
setPref
(
"
network
.
proxy
.
no_proxies_on
"
param
.
Passthrough
)
;
}
if
(
param
.
UseHTTPProxyForAllProtocols
!
=
=
undefined
)
{
setPref
(
"
network
.
proxy
.
share_proxy_settings
"
param
.
UseHTTPProxyForAllProtocols
)
;
}
function
setProxyHostAndPort
(
type
address
)
{
let
url
;
try
{
url
=
new
URL
(
https
:
/
/
{
address
}
)
;
}
catch
(
e
)
{
log
.
error
(
Invalid
address
for
{
type
}
proxy
:
{
address
}
)
;
return
;
}
setPref
(
network
.
proxy
.
{
type
}
url
.
hostname
)
;
if
(
url
.
port
)
{
setPref
(
network
.
proxy
.
{
type
}
_port
Number
(
url
.
port
)
)
;
}
}
if
(
param
.
HTTPProxy
)
{
setProxyHostAndPort
(
"
http
"
param
.
HTTPProxy
)
;
if
(
param
.
UseHTTPProxyForAllProtocols
)
{
param
.
FTPProxy
=
param
.
SSLProxy
=
param
.
SOCKSProxy
=
param
.
HTTPProxy
;
}
}
if
(
param
.
FTPProxy
)
{
setProxyHostAndPort
(
"
ftp
"
param
.
FTPProxy
)
;
}
if
(
param
.
SSLProxy
)
{
setProxyHostAndPort
(
"
ssl
"
param
.
SSLProxy
)
;
}
if
(
param
.
SOCKSProxy
)
{
setProxyHostAndPort
(
"
socks
"
param
.
SOCKSProxy
)
;
}
}
}
;
