var
EXPORTED_SYMBOLS
=
[
"
AboutHomeStartupCache
"
"
BrowserGlue
"
"
ContentPermissionPrompt
"
"
DefaultBrowserCheck
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ActorManagerParent
"
"
resource
:
/
/
gre
/
modules
/
ActorManagerParent
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AboutNewTab
"
"
resource
:
/
/
/
modules
/
AboutNewTab
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
E10SUtils
"
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
PushService
"
"
mozilla
.
org
/
push
/
Service
;
1
"
"
nsIPushService
"
)
;
const
PREF_PDFJS_ENABLED_CACHE_STATE
=
"
pdfjs
.
enabledCache
.
state
"
;
let
ACTORS
=
{
AboutLogins
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutLoginsParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutLoginsChild
.
jsm
"
events
:
{
AboutLoginsCopyLoginDetail
:
{
wantUntrusted
:
true
}
AboutLoginsCreateLogin
:
{
wantUntrusted
:
true
}
AboutLoginsDeleteLogin
:
{
wantUntrusted
:
true
}
AboutLoginsDismissBreachAlert
:
{
wantUntrusted
:
true
}
AboutLoginsHideFooter
:
{
wantUntrusted
:
true
}
AboutLoginsImport
:
{
wantUntrusted
:
true
}
AboutLoginsInit
:
{
wantUntrusted
:
true
}
AboutLoginsGetHelp
:
{
wantUntrusted
:
true
}
AboutLoginsOpenMobileAndroid
:
{
wantUntrusted
:
true
}
AboutLoginsOpenMobileIos
:
{
wantUntrusted
:
true
}
AboutLoginsOpenPreferences
:
{
wantUntrusted
:
true
}
AboutLoginsOpenSite
:
{
wantUntrusted
:
true
}
AboutLoginsRecordTelemetryEvent
:
{
wantUntrusted
:
true
}
AboutLoginsSortChanged
:
{
wantUntrusted
:
true
}
AboutLoginsSyncEnable
:
{
wantUntrusted
:
true
}
AboutLoginsSyncOptions
:
{
wantUntrusted
:
true
}
AboutLoginsUpdateLogin
:
{
wantUntrusted
:
true
}
}
}
matches
:
[
"
about
:
logins
"
"
about
:
logins
?
*
"
]
}
AboutNewTab
:
{
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutNewTabChild
.
jsm
"
events
:
{
DOMContentLoaded
:
{
}
}
}
matches
:
[
"
about
:
home
"
"
about
:
welcome
"
"
about
:
newtab
*
"
]
remoteTypes
:
[
"
privilegedabout
"
]
}
AboutPlugins
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutPluginsParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutPluginsChild
.
jsm
"
events
:
{
DOMWindowCreated
:
{
capture
:
true
}
}
}
matches
:
[
"
about
:
plugins
"
]
}
AboutPrivateBrowsing
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutPrivateBrowsingParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutPrivateBrowsingChild
.
jsm
"
events
:
{
DOMWindowCreated
:
{
capture
:
true
}
}
}
matches
:
[
"
about
:
privatebrowsing
"
]
}
AboutProtections
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutProtectionsParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutProtectionsChild
.
jsm
"
events
:
{
DOMWindowCreated
:
{
capture
:
true
}
}
}
matches
:
[
"
about
:
protections
"
]
}
AboutTabCrashed
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutTabCrashedParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutTabCrashedChild
.
jsm
"
events
:
{
DOMWindowCreated
:
{
capture
:
true
}
}
}
matches
:
[
"
about
:
tabcrashed
*
"
]
}
AboutWelcome
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutWelcomeParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
AboutWelcomeChild
.
jsm
"
events
:
{
DOMWindowCreated
:
{
}
}
}
matches
:
[
"
about
:
welcome
"
]
enablePreference
:
"
browser
.
aboutwelcome
.
enabled
"
}
BlockedSite
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
BlockedSiteParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
BlockedSiteChild
.
jsm
"
events
:
{
AboutBlockedLoaded
:
{
wantUntrusted
:
true
}
click
:
{
}
}
}
matches
:
[
"
about
:
blocked
?
*
"
]
allFrames
:
true
}
BrowserTab
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
BrowserTabParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
BrowserTabChild
.
jsm
"
events
:
{
DOMWindowCreated
:
{
}
MozAfterPaint
:
{
}
"
MozDOMPointerLock
:
Entered
"
:
{
}
"
MozDOMPointerLock
:
Exited
"
:
{
}
}
}
}
ClickHandler
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
ClickHandlerParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
ClickHandlerChild
.
jsm
"
events
:
{
click
:
{
capture
:
true
mozSystemGroup
:
true
}
auxclick
:
{
capture
:
true
mozSystemGroup
:
true
}
}
}
allFrames
:
true
}
ContentMeta
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
ContentMetaParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
ContentMetaChild
.
jsm
"
events
:
{
DOMMetaAdded
:
{
}
}
}
}
ContentSearch
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
ContentSearchParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
ContentSearchChild
.
jsm
"
matches
:
[
"
about
:
home
"
"
about
:
newtab
"
"
about
:
welcome
"
"
about
:
privatebrowsing
"
"
chrome
:
/
/
mochitests
/
content
/
*
"
]
events
:
{
ContentSearchClient
:
{
capture
:
true
wantUntrusted
:
true
}
}
}
}
ContextMenu
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
ContextMenuParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
ContextMenuChild
.
jsm
"
events
:
{
contextmenu
:
{
mozSystemGroup
:
true
}
}
}
allFrames
:
true
}
DOMFullscreen
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
DOMFullscreenParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
DOMFullscreenChild
.
jsm
"
group
:
"
browsers
"
events
:
{
"
MozDOMFullscreen
:
Request
"
:
{
}
"
MozDOMFullscreen
:
Entered
"
:
{
}
"
MozDOMFullscreen
:
NewOrigin
"
:
{
}
"
MozDOMFullscreen
:
Exit
"
:
{
}
"
MozDOMFullscreen
:
Exited
"
:
{
}
}
}
allFrames
:
true
}
FormValidation
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
FormValidationParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
FormValidationChild
.
jsm
"
events
:
{
MozInvalidForm
:
{
}
}
}
allFrames
:
true
}
LightweightTheme
:
{
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
LightweightThemeChild
.
jsm
"
events
:
{
pageshow
:
{
mozSystemGroup
:
true
}
}
}
includeChrome
:
true
allFrames
:
true
matches
:
[
"
about
:
home
"
"
about
:
newtab
"
"
about
:
welcome
"
"
chrome
:
/
/
browser
/
content
/
syncedtabs
/
sidebar
.
xhtml
"
"
chrome
:
/
/
browser
/
content
/
places
/
historySidebar
.
xhtml
"
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarksSidebar
.
xhtml
"
]
}
LinkHandler
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
LinkHandlerParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
LinkHandlerChild
.
jsm
"
events
:
{
DOMHeadElementParsed
:
{
}
DOMLinkAdded
:
{
}
DOMLinkChanged
:
{
}
pageshow
:
{
}
pagehide
:
{
}
}
}
}
NetError
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
NetErrorParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
NetErrorChild
.
jsm
"
events
:
{
DOMWindowCreated
:
{
}
click
:
{
}
}
}
matches
:
[
"
about
:
certerror
?
*
"
"
about
:
neterror
?
*
"
]
allFrames
:
true
}
PageInfo
:
{
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PageInfoChild
.
jsm
"
}
allFrames
:
true
}
PageStyle
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PageStyleParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PageStyleChild
.
jsm
"
events
:
{
pageshow
:
{
}
}
}
matches
:
[
"
*
:
/
/
*
/
*
"
]
allFrames
:
true
}
Plugin
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PluginParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PluginChild
.
jsm
"
events
:
{
PluginBindingAttached
:
{
capture
:
true
wantUntrusted
:
true
}
PluginCrashed
:
{
capture
:
true
}
PluginOutdated
:
{
capture
:
true
}
PluginInstantiated
:
{
capture
:
true
}
PluginRemoved
:
{
capture
:
true
}
HiddenPlugin
:
{
capture
:
true
}
}
observers
:
[
"
decoder
-
doctor
-
notification
"
]
}
allFrames
:
true
}
Prompt
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PromptParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
PromptChild
.
jsm
"
events
:
{
pagehide
:
{
capture
:
true
}
}
}
includeChrome
:
true
allFrames
:
true
}
SearchTelemetry
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
SearchTelemetryParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
SearchTelemetryChild
.
jsm
"
events
:
{
DOMContentLoaded
:
{
}
pageshow
:
{
mozSystemGroup
:
true
}
unload
:
{
}
}
}
}
ShieldFrame
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
normandy
-
content
/
ShieldFrameParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
normandy
-
content
/
ShieldFrameChild
.
jsm
"
events
:
{
pageshow
:
{
}
pagehide
:
{
}
ShieldPageEvent
:
{
wantUntrusted
:
true
}
}
}
matches
:
[
"
about
:
studies
"
]
}
SwitchDocumentDirection
:
{
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
SwitchDocumentDirectionChild
.
jsm
"
}
allFrames
:
true
}
SiteSpecificBrowser
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
SiteSpecificBrowserParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
SiteSpecificBrowserChild
.
jsm
"
}
allFrames
:
true
}
Translation
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
modules
/
translation
/
TranslationParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
modules
/
translation
/
TranslationChild
.
jsm
"
events
:
{
pageshow
:
{
}
load
:
{
mozSystemGroup
:
true
capture
:
true
}
}
}
enablePreference
:
"
browser
.
translation
.
detectLanguage
"
}
UITour
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
modules
/
UITourParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
modules
/
UITourChild
.
jsm
"
events
:
{
mozUITour
:
{
wantUntrusted
:
true
}
}
}
}
WebRTC
:
{
parent
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
WebRTCParent
.
jsm
"
}
child
:
{
moduleURI
:
"
resource
:
/
/
/
actors
/
WebRTCChild
.
jsm
"
}
allFrames
:
true
}
}
;
let
LEGACY_ACTORS
=
{
AboutReader
:
{
child
:
{
module
:
"
resource
:
/
/
/
actors
/
AboutReaderChild
.
jsm
"
group
:
"
browsers
"
events
:
{
AboutReaderContentLoaded
:
{
wantUntrusted
:
true
}
DOMContentLoaded
:
{
}
pageshow
:
{
mozSystemGroup
:
true
}
pagehide
:
{
mozSystemGroup
:
true
}
}
messages
:
[
"
Reader
:
ToggleReaderMode
"
"
Reader
:
PushState
"
]
}
}
URIFixup
:
{
child
:
{
module
:
"
resource
:
/
/
/
actors
/
URIFixupChild
.
jsm
"
group
:
"
browsers
"
observers
:
[
"
keyword
-
uri
-
fixup
"
]
}
}
}
;
(
function
earlyBlankFirstPaint
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
|
|
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
startup
.
blankWindow
"
false
)
)
{
return
;
}
if
(
Services
.
prefs
.
getCharPref
(
"
extensions
.
activeThemeID
"
"
default
-
theme
mozilla
.
org
"
)
!
=
"
default
-
theme
mozilla
.
org
"
)
{
return
;
}
let
store
=
Services
.
xulStore
;
let
getValue
=
attr
=
>
store
.
getValue
(
AppConstants
.
BROWSER_CHROME_URL
"
main
-
window
"
attr
)
;
let
width
=
getValue
(
"
width
"
)
;
let
height
=
getValue
(
"
height
"
)
;
if
(
!
width
|
|
!
height
)
{
return
;
}
let
browserWindowFeatures
=
"
chrome
all
dialog
=
no
extrachrome
menubar
resizable
scrollbars
status
"
+
"
location
toolbar
personalbar
"
;
let
win
=
Services
.
ww
.
openWindow
(
null
"
about
:
blank
"
null
browserWindowFeatures
null
)
;
let
hiddenTitlebar
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
drawInTitlebar
"
win
.
matchMedia
(
"
(
-
moz
-
gtk
-
csd
-
hide
-
titlebar
-
by
-
default
)
"
)
.
matches
)
;
if
(
hiddenTitlebar
)
{
win
.
windowUtils
.
setChromeMargin
(
0
2
2
2
)
;
}
let
docElt
=
win
.
document
.
documentElement
;
docElt
.
setAttribute
(
"
screenX
"
getValue
(
"
screenX
"
)
)
;
docElt
.
setAttribute
(
"
screenY
"
getValue
(
"
screenY
"
)
)
;
let
sizemode
=
getValue
(
"
sizemode
"
)
;
if
(
sizemode
=
=
"
maximized
"
)
{
docElt
.
setAttribute
(
"
sizemode
"
sizemode
)
;
let
appWin
=
win
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
;
height
-
=
appWin
.
outerToInnerHeightDifferenceInCSSPixels
;
width
-
=
appWin
.
outerToInnerWidthDifferenceInCSSPixels
;
docElt
.
setAttribute
(
"
height
"
height
)
;
docElt
.
setAttribute
(
"
width
"
width
)
;
}
else
{
win
.
resizeTo
(
width
height
)
;
}
docElt
.
setAttribute
(
"
windowtype
"
"
navigator
:
blank
"
)
;
win
.
stop
(
)
;
let
{
TelemetryTimestamps
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
)
;
TelemetryTimestamps
.
add
(
"
blankWindowShown
"
)
;
}
)
(
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
WeaveService
"
(
)
=
>
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
)
.
wrappedJSObject
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutCertViewerHandler
:
"
resource
:
/
/
gre
/
modules
/
AboutCertViewerHandler
.
jsm
"
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AppMenuNotifications
:
"
resource
:
/
/
gre
/
modules
/
AppMenuNotifications
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
Blocklist
:
"
resource
:
/
/
gre
/
modules
/
Blocklist
.
jsm
"
BookmarkHTMLUtils
:
"
resource
:
/
/
gre
/
modules
/
BookmarkHTMLUtils
.
jsm
"
BookmarkJSONUtils
:
"
resource
:
/
/
gre
/
modules
/
BookmarkJSONUtils
.
jsm
"
BrowserUsageTelemetry
:
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
Corroborate
:
"
resource
:
/
/
gre
/
modules
/
Corroborate
.
jsm
"
Discovery
:
"
resource
:
/
/
/
modules
/
Discovery
.
jsm
"
ExtensionsUI
:
"
resource
:
/
/
/
modules
/
ExtensionsUI
.
jsm
"
FirefoxMonitor
:
"
resource
:
/
/
/
modules
/
FirefoxMonitor
.
jsm
"
FxAccounts
:
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
HomePage
:
"
resource
:
/
/
/
modules
/
HomePage
.
jsm
"
Integration
:
"
resource
:
/
/
gre
/
modules
/
Integration
.
jsm
"
LoginBreaches
:
"
resource
:
/
/
/
modules
/
LoginBreaches
.
jsm
"
LiveBookmarkMigrator
:
"
resource
:
/
/
/
modules
/
LiveBookmarkMigrator
.
jsm
"
NewTabUtils
:
"
resource
:
/
/
gre
/
modules
/
NewTabUtils
.
jsm
"
Normandy
:
"
resource
:
/
/
normandy
/
Normandy
.
jsm
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PageActions
:
"
resource
:
/
/
/
modules
/
PageActions
.
jsm
"
PageThumbs
:
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
PdfJs
:
"
resource
:
/
/
pdf
.
js
/
PdfJs
.
jsm
"
PermissionUI
:
"
resource
:
/
/
/
modules
/
PermissionUI
.
jsm
"
PlacesBackups
:
"
resource
:
/
/
gre
/
modules
/
PlacesBackups
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PluralForm
:
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
ProcessHangMonitor
:
"
resource
:
/
/
/
modules
/
ProcessHangMonitor
.
jsm
"
PublicSuffixList
:
"
resource
:
/
/
gre
/
modules
/
netwerk
-
dns
/
PublicSuffixList
.
jsm
"
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
RemoteSecuritySettings
:
"
resource
:
/
/
gre
/
modules
/
psm
/
RemoteSecuritySettings
.
jsm
"
RFPHelper
:
"
resource
:
/
/
gre
/
modules
/
RFPHelper
.
jsm
"
SafeBrowsing
:
"
resource
:
/
/
gre
/
modules
/
SafeBrowsing
.
jsm
"
Sanitizer
:
"
resource
:
/
/
/
modules
/
Sanitizer
.
jsm
"
SaveToPocket
:
"
chrome
:
/
/
pocket
/
content
/
SaveToPocket
.
jsm
"
SearchTelemetry
:
"
resource
:
/
/
/
modules
/
SearchTelemetry
.
jsm
"
SessionStartup
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStartup
.
jsm
"
SessionStore
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
ShellService
:
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
TabCrashHandler
:
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
TabUnloader
:
"
resource
:
/
/
/
modules
/
TabUnloader
.
jsm
"
TRRRacer
:
"
resource
:
/
/
/
modules
/
TRRPerformance
.
jsm
"
UIState
:
"
resource
:
/
/
services
-
sync
/
UIState
.
jsm
"
WebChannel
:
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
jsm
"
WindowsRegistry
:
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutLoginsParent
:
"
resource
:
/
/
/
modules
/
AboutLoginsParent
.
jsm
"
AsyncPrefs
:
"
resource
:
/
/
gre
/
modules
/
AsyncPrefs
.
jsm
"
PluginManager
:
"
resource
:
/
/
/
actors
/
PluginParent
.
jsm
"
ReaderParent
:
"
resource
:
/
/
/
modules
/
ReaderParent
.
jsm
"
}
)
;
let
initializedModules
=
{
}
;
[
[
"
ContentPrefServiceParent
"
"
resource
:
/
/
gre
/
modules
/
ContentPrefServiceParent
.
jsm
"
"
alwaysInit
"
]
[
"
UpdateListener
"
"
resource
:
/
/
gre
/
modules
/
UpdateListener
.
jsm
"
"
init
"
]
]
.
forEach
(
(
[
name
resource
init
]
)
=
>
{
XPCOMUtils
.
defineLazyGetter
(
this
name
(
)
=
>
{
ChromeUtils
.
import
(
resource
initializedModules
)
;
initializedModules
[
name
]
[
init
]
(
)
;
return
initializedModules
[
name
]
;
}
)
;
}
)
;
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UnsubmittedCrashHandler
:
"
resource
:
/
/
/
modules
/
ContentCrashHandlers
.
jsm
"
}
)
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrandBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gBrowserBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTabbrowserBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
tabbrowser
.
properties
"
)
;
}
)
;
const
global
=
this
;
const
listeners
=
{
observers
:
{
"
update
-
staged
"
:
[
"
UpdateListener
"
]
"
update
-
downloaded
"
:
[
"
UpdateListener
"
]
"
update
-
available
"
:
[
"
UpdateListener
"
]
"
update
-
error
"
:
[
"
UpdateListener
"
]
"
gmp
-
plugin
-
crash
"
:
[
"
PluginManager
"
]
"
plugin
-
crashed
"
:
[
"
PluginManager
"
]
}
ppmm
:
{
"
ContentPrefs
:
FunctionCall
"
:
[
"
ContentPrefServiceParent
"
]
"
ContentPrefs
:
AddObserverForName
"
:
[
"
ContentPrefServiceParent
"
]
"
ContentPrefs
:
RemoveObserverForName
"
:
[
"
ContentPrefServiceParent
"
]
"
AsyncPrefs
:
SetPref
"
:
[
"
AsyncPrefs
"
]
"
AsyncPrefs
:
ResetPref
"
:
[
"
AsyncPrefs
"
]
}
mm
:
{
"
AboutLogins
:
CreateLogin
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
DeleteLogin
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
DismissBreachAlert
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
HideFooter
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
Import
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
MasterPasswordRequest
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
OpenFAQ
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
GetHelp
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
OpenPreferences
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
OpenMobileAndroid
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
OpenMobileIos
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
OpenSite
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
SortChanged
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
Subscribe
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
SyncEnable
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
SyncOptions
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
TestOnlyResetOSAuth
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
UpdateLogin
"
:
[
"
AboutLoginsParent
"
]
"
AboutLogins
:
VulnerableLogins
"
:
[
"
AboutLoginsParent
"
]
"
Reader
:
FaviconRequest
"
:
[
"
ReaderParent
"
]
"
Reader
:
UpdateReaderButton
"
:
[
"
ReaderParent
"
]
}
observe
(
subject
topic
data
)
{
for
(
let
module
of
this
.
observers
[
topic
]
)
{
try
{
global
[
module
]
.
observe
(
subject
topic
data
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
receiveMessage
(
modules
data
)
{
let
val
;
for
(
let
module
of
modules
[
data
.
name
]
)
{
try
{
val
=
global
[
module
]
.
receiveMessage
(
data
)
|
|
val
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
return
val
;
}
init
(
)
{
for
(
let
observer
of
Object
.
keys
(
this
.
observers
)
)
{
Services
.
obs
.
addObserver
(
this
observer
)
;
}
let
receiveMessageMM
=
this
.
receiveMessage
.
bind
(
this
this
.
mm
)
;
for
(
let
message
of
Object
.
keys
(
this
.
mm
)
)
{
Services
.
mm
.
addMessageListener
(
message
receiveMessageMM
)
;
}
let
receiveMessagePPMM
=
this
.
receiveMessage
.
bind
(
this
this
.
ppmm
)
;
for
(
let
message
of
Object
.
keys
(
this
.
ppmm
)
)
{
Services
.
ppmm
.
addMessageListener
(
message
receiveMessagePPMM
)
;
}
}
}
;
const
BOOKMARKS_BACKUP_IDLE_TIME_SEC
=
8
*
60
;
const
BOOKMARKS_BACKUP_MIN_INTERVAL_DAYS
=
1
;
const
BOOKMARKS_BACKUP_MAX_INTERVAL_DAYS
=
3
;
const
LATE_TASKS_IDLE_TIME_SEC
=
20
;
const
STARTUP_CRASHES_END_DELAY_MS
=
30
*
1000
;
const
OBSERVE_LASTWINDOW_CLOSE_TOPICS
=
AppConstants
.
platform
!
=
"
macosx
"
;
function
BrowserGlue
(
)
{
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
_idleService
"
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
"
nsIIdleService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_distributionCustomizer
"
function
(
)
{
const
{
DistributionCustomizer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
distribution
.
js
"
)
;
return
new
DistributionCustomizer
(
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
AlertsService
"
"
mozilla
.
org
/
alerts
-
service
;
1
"
"
nsIAlertsService
"
)
;
this
.
_init
(
)
;
}
BrowserGlue
.
prototype
=
{
_saveSession
:
false
_migrationImportsDefaultBookmarks
:
false
_placesBrowserInitComplete
:
false
_isNewProfile
:
undefined
_setPrefToSaveSession
:
function
BG__setPrefToSaveSession
(
aForce
)
{
if
(
!
this
.
_saveSession
&
&
!
aForce
)
{
return
;
}
if
(
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
sessionstore
.
resume_session_once
"
true
)
;
}
Services
.
prefs
.
savePrefFile
(
null
)
;
}
_setSyncAutoconnectDelay
:
function
BG__setSyncAutoconnectDelay
(
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
"
services
.
sync
.
autoconnectDelay
"
)
)
{
let
prefDelay
=
Services
.
prefs
.
getIntPref
(
"
services
.
sync
.
autoconnectDelay
"
)
;
if
(
prefDelay
>
0
)
{
return
;
}
}
const
MAX_DELAY
=
300
;
let
delay
=
3
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
win
.
closed
|
|
!
win
.
gBrowser
)
{
return
;
}
delay
+
=
win
.
gBrowser
.
tabs
.
length
;
}
delay
=
delay
<
=
MAX_DELAY
?
delay
:
MAX_DELAY
;
const
{
Weave
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
Weave
.
Service
.
scheduler
.
delayedAutoConnect
(
delay
)
;
}
observe
:
async
function
BG_observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
notifications
-
open
-
settings
"
:
this
.
_openPreferences
(
"
privacy
-
permissions
"
)
;
break
;
case
"
final
-
ui
-
startup
"
:
this
.
_beforeUIStartup
(
)
;
break
;
case
"
browser
-
delayed
-
startup
-
finished
"
:
this
.
_onFirstWindowLoaded
(
subject
)
;
Services
.
obs
.
removeObserver
(
this
"
browser
-
delayed
-
startup
-
finished
"
)
;
break
;
case
"
sessionstore
-
windows
-
restored
"
:
this
.
_onWindowsRestored
(
)
;
break
;
case
"
browser
:
purge
-
session
-
history
"
:
Services
.
console
.
logStringMessage
(
null
)
;
Services
.
console
.
reset
(
)
;
break
;
case
"
restart
-
in
-
safe
-
mode
"
:
this
.
_onSafeModeRestart
(
)
;
break
;
case
"
quit
-
application
-
requested
"
:
this
.
_onQuitRequest
(
subject
data
)
;
break
;
case
"
quit
-
application
-
granted
"
:
this
.
_onQuitApplicationGranted
(
)
;
break
;
case
"
browser
-
lastwindow
-
close
-
requested
"
:
if
(
OBSERVE_LASTWINDOW_CLOSE_TOPICS
)
{
this
.
_onQuitRequest
(
subject
"
lastwindow
"
)
;
}
break
;
case
"
browser
-
lastwindow
-
close
-
granted
"
:
if
(
OBSERVE_LASTWINDOW_CLOSE_TOPICS
)
{
this
.
_setPrefToSaveSession
(
)
;
}
break
;
case
"
weave
:
service
:
ready
"
:
this
.
_setSyncAutoconnectDelay
(
)
;
break
;
case
"
fxaccounts
:
onverified
"
:
this
.
_onThisDeviceConnected
(
)
;
break
;
case
"
fxaccounts
:
device_connected
"
:
this
.
_onDeviceConnected
(
data
)
;
break
;
case
"
fxaccounts
:
verify_login
"
:
this
.
_onVerifyLoginNotification
(
JSON
.
parse
(
data
)
)
;
break
;
case
"
fxaccounts
:
device_disconnected
"
:
data
=
JSON
.
parse
(
data
)
;
if
(
data
.
isLocalDevice
)
{
this
.
_onDeviceDisconnected
(
)
;
}
break
;
case
"
fxaccounts
:
commands
:
open
-
uri
"
:
case
"
weave
:
engine
:
clients
:
display
-
uris
"
:
this
.
_onDisplaySyncURIs
(
subject
)
;
break
;
case
"
session
-
save
"
:
this
.
_setPrefToSaveSession
(
true
)
;
subject
.
QueryInterface
(
Ci
.
nsISupportsPRBool
)
;
subject
.
data
=
true
;
break
;
case
"
places
-
init
-
complete
"
:
Services
.
obs
.
removeObserver
(
this
"
places
-
init
-
complete
"
)
;
if
(
!
this
.
_migrationImportsDefaultBookmarks
)
{
this
.
_initPlaces
(
false
)
;
}
break
;
case
"
idle
"
:
this
.
_backupBookmarks
(
)
;
break
;
case
"
distribution
-
customization
-
complete
"
:
Services
.
obs
.
removeObserver
(
this
"
distribution
-
customization
-
complete
"
)
;
delete
this
.
_distributionCustomizer
;
break
;
case
"
browser
-
glue
-
test
"
:
if
(
data
=
=
"
force
-
ui
-
migration
"
)
{
this
.
_migrateUI
(
)
;
}
else
if
(
data
=
=
"
force
-
distribution
-
customization
"
)
{
this
.
_distributionCustomizer
.
applyCustomizations
(
)
;
}
else
if
(
data
=
=
"
force
-
places
-
init
"
)
{
this
.
_initPlaces
(
false
)
;
}
else
if
(
data
=
=
"
mock
-
alerts
-
service
"
)
{
Object
.
defineProperty
(
this
"
AlertsService
"
{
value
:
subject
.
wrappedJSObject
}
)
;
}
else
if
(
data
=
=
"
places
-
browser
-
init
-
complete
"
)
{
if
(
this
.
_placesBrowserInitComplete
)
{
Services
.
obs
.
notifyObservers
(
null
"
places
-
browser
-
init
-
complete
"
)
;
}
}
else
if
(
data
=
=
"
migrateMatchBucketsPrefForUI66
"
)
{
this
.
_migrateMatchBucketsPrefForUI66
(
)
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
browser
-
glue
-
test
"
"
migrateMatchBucketsPrefForUI66
-
done
"
)
;
}
)
;
}
else
if
(
data
=
=
"
add
-
breaches
-
sync
-
handler
"
)
{
this
.
_addBreachesSyncHandler
(
)
;
}
break
;
case
"
initial
-
migration
-
will
-
import
-
default
-
bookmarks
"
:
this
.
_migrationImportsDefaultBookmarks
=
true
;
break
;
case
"
initial
-
migration
-
did
-
import
-
default
-
bookmarks
"
:
this
.
_initPlaces
(
true
)
;
break
;
case
"
handle
-
xul
-
text
-
link
"
:
let
linkHandled
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRBool
)
;
if
(
!
linkHandled
.
data
)
{
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
win
)
{
data
=
JSON
.
parse
(
data
)
;
let
where
=
win
.
whereToOpenLink
(
data
)
;
if
(
where
=
=
"
current
"
)
{
where
=
"
tab
"
;
}
win
.
openTrustedLinkIn
(
data
.
href
where
)
;
linkHandled
.
data
=
true
;
}
}
break
;
case
"
profile
-
before
-
change
"
:
this
.
_dispose
(
)
;
break
;
case
"
keyword
-
search
"
:
let
engine
=
null
;
try
{
engine
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
win
.
BrowserSearch
.
recordSearchInTelemetry
(
engine
"
urlbar
"
)
;
break
;
case
"
browser
-
search
-
engine
-
modified
"
:
if
(
data
=
=
"
engine
-
added
"
|
|
data
=
=
"
engine
-
removed
"
)
{
let
engineName
=
subject
.
QueryInterface
(
Ci
.
nsISearchEngine
)
.
name
;
let
pref
=
Services
.
prefs
.
getStringPref
(
"
browser
.
search
.
hiddenOneOffs
"
)
;
let
hiddenList
=
pref
?
pref
.
split
(
"
"
)
:
[
]
;
hiddenList
=
hiddenList
.
filter
(
x
=
>
x
!
=
=
engineName
)
;
Services
.
prefs
.
setStringPref
(
"
browser
.
search
.
hiddenOneOffs
"
hiddenList
.
join
(
"
"
)
)
;
}
break
;
case
"
flash
-
plugin
-
hang
"
:
this
.
_handleFlashHang
(
)
;
break
;
case
"
xpi
-
signature
-
changed
"
:
let
disabledAddons
=
JSON
.
parse
(
data
)
.
disabled
;
let
addons
=
await
AddonManager
.
getAddonsByIDs
(
disabledAddons
)
;
if
(
addons
.
some
(
addon
=
>
addon
)
)
{
this
.
_notifyUnsignedAddonsDisabled
(
)
;
}
break
;
case
"
sync
-
ui
-
state
:
update
"
:
this
.
_updateFxaBadges
(
)
;
break
;
case
"
handlersvc
-
store
-
initialized
"
:
PdfJs
.
init
(
this
.
_isNewProfile
)
;
break
;
case
"
shield
-
init
-
complete
"
:
this
.
_shieldInitComplete
=
true
;
break
;
}
}
_init
:
function
BG__init
(
)
{
let
os
=
Services
.
obs
;
os
.
addObserver
(
this
"
notifications
-
open
-
settings
"
)
;
os
.
addObserver
(
this
"
final
-
ui
-
startup
"
)
;
os
.
addObserver
(
this
"
browser
-
delayed
-
startup
-
finished
"
)
;
os
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
os
.
addObserver
(
this
"
browser
:
purge
-
session
-
history
"
)
;
os
.
addObserver
(
this
"
quit
-
application
-
requested
"
)
;
os
.
addObserver
(
this
"
quit
-
application
-
granted
"
)
;
if
(
OBSERVE_LASTWINDOW_CLOSE_TOPICS
)
{
os
.
addObserver
(
this
"
browser
-
lastwindow
-
close
-
requested
"
)
;
os
.
addObserver
(
this
"
browser
-
lastwindow
-
close
-
granted
"
)
;
}
os
.
addObserver
(
this
"
weave
:
service
:
ready
"
)
;
os
.
addObserver
(
this
"
fxaccounts
:
onverified
"
)
;
os
.
addObserver
(
this
"
fxaccounts
:
device_connected
"
)
;
os
.
addObserver
(
this
"
fxaccounts
:
verify_login
"
)
;
os
.
addObserver
(
this
"
fxaccounts
:
device_disconnected
"
)
;
os
.
addObserver
(
this
"
fxaccounts
:
commands
:
open
-
uri
"
)
;
os
.
addObserver
(
this
"
weave
:
engine
:
clients
:
display
-
uris
"
)
;
os
.
addObserver
(
this
"
session
-
save
"
)
;
os
.
addObserver
(
this
"
places
-
init
-
complete
"
)
;
os
.
addObserver
(
this
"
distribution
-
customization
-
complete
"
)
;
os
.
addObserver
(
this
"
handle
-
xul
-
text
-
link
"
)
;
os
.
addObserver
(
this
"
profile
-
before
-
change
"
)
;
os
.
addObserver
(
this
"
keyword
-
search
"
)
;
os
.
addObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
os
.
addObserver
(
this
"
restart
-
in
-
safe
-
mode
"
)
;
os
.
addObserver
(
this
"
flash
-
plugin
-
hang
"
)
;
os
.
addObserver
(
this
"
xpi
-
signature
-
changed
"
)
;
os
.
addObserver
(
this
"
sync
-
ui
-
state
:
update
"
)
;
os
.
addObserver
(
this
"
handlersvc
-
store
-
initialized
"
)
;
os
.
addObserver
(
this
"
shield
-
init
-
complete
"
)
;
ActorManagerParent
.
addActors
(
ACTORS
)
;
ActorManagerParent
.
addLegacyActors
(
LEGACY_ACTORS
)
;
ActorManagerParent
.
flush
(
)
;
this
.
_flashHangCount
=
0
;
this
.
_firstWindowReady
=
new
Promise
(
resolve
=
>
(
this
.
_firstWindowLoaded
=
resolve
)
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
JawsScreenReaderVersionCheck
.
init
(
)
;
}
}
_dispose
:
function
BG__dispose
(
)
{
AboutHomeStartupCache
.
uninit
(
)
;
let
os
=
Services
.
obs
;
os
.
removeObserver
(
this
"
notifications
-
open
-
settings
"
)
;
os
.
removeObserver
(
this
"
final
-
ui
-
startup
"
)
;
os
.
removeObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
os
.
removeObserver
(
this
"
browser
:
purge
-
session
-
history
"
)
;
os
.
removeObserver
(
this
"
quit
-
application
-
requested
"
)
;
os
.
removeObserver
(
this
"
quit
-
application
-
granted
"
)
;
os
.
removeObserver
(
this
"
restart
-
in
-
safe
-
mode
"
)
;
if
(
OBSERVE_LASTWINDOW_CLOSE_TOPICS
)
{
os
.
removeObserver
(
this
"
browser
-
lastwindow
-
close
-
requested
"
)
;
os
.
removeObserver
(
this
"
browser
-
lastwindow
-
close
-
granted
"
)
;
}
os
.
removeObserver
(
this
"
weave
:
service
:
ready
"
)
;
os
.
removeObserver
(
this
"
fxaccounts
:
onverified
"
)
;
os
.
removeObserver
(
this
"
fxaccounts
:
device_connected
"
)
;
os
.
removeObserver
(
this
"
fxaccounts
:
verify_login
"
)
;
os
.
removeObserver
(
this
"
fxaccounts
:
device_disconnected
"
)
;
os
.
removeObserver
(
this
"
fxaccounts
:
commands
:
open
-
uri
"
)
;
os
.
removeObserver
(
this
"
weave
:
engine
:
clients
:
display
-
uris
"
)
;
os
.
removeObserver
(
this
"
session
-
save
"
)
;
if
(
this
.
_bookmarksBackupIdleTime
)
{
this
.
_idleService
.
removeIdleObserver
(
this
this
.
_bookmarksBackupIdleTime
)
;
delete
this
.
_bookmarksBackupIdleTime
;
}
if
(
this
.
_lateTasksIdleObserver
)
{
this
.
_idleService
.
removeIdleObserver
(
this
.
_lateTasksIdleObserver
LATE_TASKS_IDLE_TIME_SEC
)
;
delete
this
.
_lateTasksIdleObserver
;
}
if
(
this
.
_gmpInstallManager
)
{
this
.
_gmpInstallManager
.
uninit
(
)
;
delete
this
.
_gmpInstallManager
;
}
try
{
os
.
removeObserver
(
this
"
places
-
init
-
complete
"
)
;
}
catch
(
ex
)
{
}
os
.
removeObserver
(
this
"
handle
-
xul
-
text
-
link
"
)
;
os
.
removeObserver
(
this
"
profile
-
before
-
change
"
)
;
os
.
removeObserver
(
this
"
keyword
-
search
"
)
;
os
.
removeObserver
(
this
"
browser
-
search
-
engine
-
modified
"
)
;
os
.
removeObserver
(
this
"
flash
-
plugin
-
hang
"
)
;
os
.
removeObserver
(
this
"
xpi
-
signature
-
changed
"
)
;
os
.
removeObserver
(
this
"
sync
-
ui
-
state
:
update
"
)
;
os
.
removeObserver
(
this
"
shield
-
init
-
complete
"
)
;
Services
.
prefs
.
removeObserver
(
"
privacy
.
trackingprotection
"
this
.
_matchCBCategory
)
;
Services
.
prefs
.
removeObserver
(
"
network
.
cookie
.
cookieBehavior
"
this
.
_matchCBCategory
)
;
Services
.
prefs
.
removeObserver
(
ContentBlockingCategoriesPrefs
.
PREF_CB_CATEGORY
this
.
_updateCBCategory
)
;
Services
.
prefs
.
removeObserver
(
"
privacy
.
trackingprotection
"
this
.
_setPrefExpectations
)
;
Services
.
prefs
.
removeObserver
(
"
browser
.
contentblocking
.
features
.
strict
"
this
.
_setPrefExpectationsAndUpdate
)
;
}
_beforeUIStartup
:
function
BG__beforeUIStartup
(
)
{
SessionStartup
.
init
(
)
;
if
(
Services
.
appinfo
.
inSafeMode
)
{
Services
.
ww
.
openWindow
(
null
"
chrome
:
/
/
browser
/
content
/
safeMode
.
xhtml
"
"
_blank
"
"
chrome
centerscreen
modal
resizable
=
no
"
null
)
;
}
this
.
_distributionCustomizer
.
applyCustomizations
(
)
;
this
.
_migrateUI
(
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_PDFJS_ENABLED_CACHE_STATE
)
)
{
Services
.
ppmm
.
sharedData
.
set
(
"
pdfjs
.
enabled
"
Services
.
prefs
.
getBoolPref
(
PREF_PDFJS_ENABLED_CACHE_STATE
)
)
;
}
else
{
PdfJs
.
earlyInit
(
this
.
_isNewProfile
)
;
}
listeners
.
init
(
)
;
SessionStore
.
init
(
)
;
AddonManager
.
maybeInstallBuiltinAddon
(
"
firefox
-
compact
-
light
mozilla
.
org
"
"
1
.
0
"
"
resource
:
/
/
/
modules
/
themes
/
light
/
"
)
;
AddonManager
.
maybeInstallBuiltinAddon
(
"
firefox
-
compact
-
dark
mozilla
.
org
"
"
1
.
0
"
"
resource
:
/
/
/
modules
/
themes
/
dark
/
"
)
;
if
(
AppConstants
.
MOZ_NORMANDY
)
{
Normandy
.
init
(
)
;
}
SaveToPocket
.
init
(
)
;
AboutHomeStartupCache
.
init
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
browser
-
ui
-
startup
-
complete
"
)
;
}
_checkForOldBuildUpdates
(
)
{
if
(
AppConstants
.
MOZ_UPDATER
&
&
Services
.
prefs
.
getBoolPref
(
"
app
.
update
.
checkInstallTime
"
)
)
{
let
buildID
=
Services
.
appinfo
.
appBuildID
;
let
today
=
new
Date
(
)
.
getTime
(
)
;
let
buildDate
=
new
Date
(
buildID
.
slice
(
0
4
)
buildID
.
slice
(
4
6
)
-
1
buildID
.
slice
(
6
8
)
buildID
.
slice
(
8
10
)
buildID
.
slice
(
10
12
)
buildID
.
slice
(
12
14
)
)
.
getTime
(
)
;
const
millisecondsIn24Hours
=
86400000
;
let
acceptableAge
=
Services
.
prefs
.
getIntPref
(
"
app
.
update
.
checkInstallTime
.
days
"
)
*
millisecondsIn24Hours
;
if
(
buildDate
+
acceptableAge
<
today
)
{
Cc
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationUpdateService
)
.
checkForBackgroundUpdates
(
)
;
}
}
}
_onSafeModeRestart
:
function
BG_onSafeModeRestart
(
)
{
let
strings
=
gBrowserBundle
;
let
promptTitle
=
strings
.
GetStringFromName
(
"
safeModeRestartPromptTitle
"
)
;
let
promptMessage
=
strings
.
GetStringFromName
(
"
safeModeRestartPromptMessage
"
)
;
let
restartText
=
strings
.
GetStringFromName
(
"
safeModeRestartButton
"
)
;
let
buttonFlags
=
Services
.
prompt
.
BUTTON_POS_0
*
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
+
Services
.
prompt
.
BUTTON_POS_1
*
Services
.
prompt
.
BUTTON_TITLE_CANCEL
+
Services
.
prompt
.
BUTTON_POS_0_DEFAULT
;
let
rv
=
Services
.
prompt
.
confirmEx
(
null
promptTitle
promptMessage
buttonFlags
restartText
null
null
null
{
}
)
;
if
(
rv
!
=
0
)
{
return
;
}
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
"
restart
"
)
;
if
(
!
cancelQuit
.
data
)
{
Services
.
startup
.
restartInSafeMode
(
Ci
.
nsIAppStartup
.
eAttemptQuit
)
;
}
}
_trackSlowStartup
(
)
{
let
disabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
slowStartup
.
notificationDisabled
"
)
;
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
slow_startup_notification_disabled
"
disabled
)
;
if
(
Services
.
startup
.
interrupted
|
|
disabled
)
{
return
;
}
let
currentTime
=
Math
.
round
(
Cu
.
now
(
)
)
;
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
recorded_time
"
currentTime
)
;
let
averageTime
=
0
;
let
samples
=
0
;
try
{
averageTime
=
Services
.
prefs
.
getIntPref
(
"
browser
.
slowStartup
.
averageTime
"
)
;
samples
=
Services
.
prefs
.
getIntPref
(
"
browser
.
slowStartup
.
samples
"
)
;
}
catch
(
e
)
{
}
let
totalTime
=
averageTime
*
samples
+
currentTime
;
samples
+
+
;
averageTime
=
totalTime
/
samples
;
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
average_time
"
averageTime
)
;
if
(
samples
>
=
Services
.
prefs
.
getIntPref
(
"
browser
.
slowStartup
.
maxSamples
"
)
)
{
if
(
averageTime
>
Services
.
prefs
.
getIntPref
(
"
browser
.
slowStartup
.
timeThreshold
"
)
)
{
this
.
_calculateProfileAgeInDays
(
)
.
then
(
this
.
_showSlowStartupNotification
null
)
;
}
averageTime
=
0
;
samples
=
0
;
}
Services
.
prefs
.
setIntPref
(
"
browser
.
slowStartup
.
averageTime
"
averageTime
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
slowStartup
.
samples
"
samples
)
;
}
async
_calculateProfileAgeInDays
(
)
{
let
ProfileAge
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
{
}
)
.
ProfileAge
;
let
profileAge
=
await
ProfileAge
(
)
;
let
creationDate
=
await
profileAge
.
created
;
let
resetDate
=
await
profileAge
.
reset
;
let
profileDate
=
resetDate
|
|
creationDate
;
const
ONE_DAY
=
24
*
60
*
60
*
1000
;
return
(
Date
.
now
(
)
-
profileDate
)
/
ONE_DAY
;
}
_showSlowStartupNotification
(
profileAge
)
{
if
(
profileAge
<
90
)
{
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
too_new_for_notification
"
true
)
;
return
;
}
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
win
)
{
return
;
}
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
slow_startup_notified
"
true
)
;
const
NO_ACTION
=
0
;
const
OPENED_SUMO
=
1
;
const
NEVER_SHOW_AGAIN
=
2
;
const
DISMISS_NOTIFICATION
=
3
;
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
action
"
NO_ACTION
)
;
let
productName
=
gBrandBundle
.
GetStringFromName
(
"
brandFullName
"
)
;
let
message
=
win
.
gNavigatorBundle
.
getFormattedString
(
"
slowStartup
.
message
"
[
productName
]
)
;
let
buttons
=
[
{
label
:
win
.
gNavigatorBundle
.
getString
(
"
slowStartup
.
helpButton
.
label
"
)
accessKey
:
win
.
gNavigatorBundle
.
getString
(
"
slowStartup
.
helpButton
.
accesskey
"
)
callback
(
)
{
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
action
"
OPENED_SUMO
)
;
win
.
openTrustedLinkIn
(
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
reset
-
firefox
-
easily
-
fix
-
most
-
problems
"
"
tab
"
)
;
}
}
{
label
:
win
.
gNavigatorBundle
.
getString
(
"
slowStartup
.
disableNotificationButton
.
label
"
)
accessKey
:
win
.
gNavigatorBundle
.
getString
(
"
slowStartup
.
disableNotificationButton
.
accesskey
"
)
callback
(
)
{
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
action
"
NEVER_SHOW_AGAIN
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
slowStartup
.
notificationDisabled
"
true
)
;
}
}
]
;
let
closeCallback
=
closeType
=
>
{
if
(
closeType
=
=
"
dismissed
"
)
{
Services
.
telemetry
.
scalarSet
(
"
browser
.
startup
.
action
"
DISMISS_NOTIFICATION
)
;
}
}
;
win
.
gNotificationBox
.
appendNotification
(
message
"
slow
-
startup
"
"
chrome
:
/
/
browser
/
skin
/
slowStartup
-
16
.
png
"
win
.
gNotificationBox
.
PRIORITY_INFO_LOW
buttons
closeCallback
)
;
}
_resetProfileNotification
(
reason
)
{
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
win
)
{
return
;
}
const
{
ResetProfile
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ResetProfile
.
jsm
"
)
;
if
(
!
ResetProfile
.
resetSupported
(
)
)
{
return
;
}
let
productName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
resetBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
resetProfile
.
properties
"
)
;
let
message
;
if
(
reason
=
=
"
unused
"
)
{
message
=
resetBundle
.
formatStringFromName
(
"
resetUnusedProfile
.
message
"
[
productName
]
)
;
}
else
if
(
reason
=
=
"
uninstall
"
)
{
message
=
resetBundle
.
formatStringFromName
(
"
resetUninstalled
.
message
"
[
productName
]
)
;
}
else
{
throw
new
Error
(
Unknown
reason
(
{
reason
}
)
given
to
_resetProfileNotification
.
)
;
}
let
buttons
=
[
{
label
:
resetBundle
.
formatStringFromName
(
"
refreshProfile
.
resetButton
.
label
"
[
productName
]
)
accessKey
:
resetBundle
.
GetStringFromName
(
"
refreshProfile
.
resetButton
.
accesskey
"
)
callback
(
)
{
ResetProfile
.
openConfirmationDialog
(
win
)
;
}
}
]
;
win
.
gNotificationBox
.
appendNotification
(
message
"
reset
-
profile
-
notification
"
"
chrome
:
/
/
global
/
skin
/
icons
/
question
-
16
.
png
"
win
.
gNotificationBox
.
PRIORITY_INFO_LOW
buttons
)
;
}
_notifyUnsignedAddonsDisabled
(
)
{
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
win
)
{
return
;
}
let
message
=
win
.
gNavigatorBundle
.
getString
(
"
unsignedAddonsDisabled
.
message
"
)
;
let
buttons
=
[
{
label
:
win
.
gNavigatorBundle
.
getString
(
"
unsignedAddonsDisabled
.
learnMore
.
label
"
)
accessKey
:
win
.
gNavigatorBundle
.
getString
(
"
unsignedAddonsDisabled
.
learnMore
.
accesskey
"
)
callback
(
)
{
win
.
BrowserOpenAddonsMgr
(
"
addons
:
/
/
list
/
extension
?
unsigned
=
true
"
)
;
}
}
]
;
win
.
gHighPriorityNotificationBox
.
appendNotification
(
message
"
unsigned
-
addons
-
disabled
"
"
"
win
.
gHighPriorityNotificationBox
.
PRIORITY_WARNING_MEDIUM
buttons
)
;
}
_firstWindowTelemetry
(
aWindow
)
{
let
scaling
=
aWindow
.
devicePixelRatio
*
100
;
try
{
Services
.
telemetry
.
getHistogramById
(
"
DISPLAY_SCALING
"
)
.
add
(
scaling
)
;
}
catch
(
ex
)
{
}
}
_collectStartupConditionsTelemetry
(
)
{
let
nowSeconds
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
let
lastCheckSeconds
=
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
lastColdStartupCheck
"
nowSeconds
)
;
Services
.
prefs
.
setIntPref
(
"
browser
.
startup
.
lastColdStartupCheck
"
nowSeconds
)
;
try
{
let
secondsSinceLastOSRestart
=
Services
.
startup
.
secondsSinceLastOSRestart
;
let
isColdStartup
=
nowSeconds
-
secondsSinceLastOSRestart
>
lastCheckSeconds
;
Services
.
telemetry
.
scalarSet
(
"
startup
.
is_cold
"
isColdStartup
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
_onFirstWindowLoaded
:
function
BG__onFirstWindowLoaded
(
aWindow
)
{
AboutNewTab
.
init
(
)
;
TabCrashHandler
.
init
(
)
;
ProcessHangMonitor
.
init
(
)
;
let
channel
=
new
WebChannel
(
"
remote
-
troubleshooting
"
"
remote
-
troubleshooting
"
)
;
channel
.
listen
(
(
id
data
target
)
=
>
{
if
(
data
.
command
=
=
"
request
"
)
{
let
{
Troubleshoot
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Troubleshoot
.
jsm
"
)
;
Troubleshoot
.
snapshot
(
snapshotData
=
>
{
delete
snapshotData
.
crashes
;
delete
snapshotData
.
modifiedPreferences
;
channel
.
send
(
snapshotData
target
)
;
}
)
;
}
}
)
;
this
.
_trackSlowStartup
(
)
;
const
OFFER_PROFILE_RESET_INTERVAL_MS
=
60
*
24
*
60
*
60
*
1000
;
let
lastUse
=
Services
.
appinfo
.
replacedLockTime
;
let
disableResetPrompt
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
disableResetPrompt
"
false
)
;
if
(
!
disableResetPrompt
&
&
lastUse
&
&
Date
.
now
(
)
-
lastUse
>
=
OFFER_PROFILE_RESET_INTERVAL_MS
)
{
this
.
_resetProfileNotification
(
"
unused
"
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
!
disableResetPrompt
)
{
let
updateChannel
;
try
{
updateChannel
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
{
}
)
.
UpdateUtils
.
UpdateChannel
;
}
catch
(
ex
)
{
}
if
(
updateChannel
)
{
let
uninstalledValue
=
WindowsRegistry
.
readRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
"
Software
\
\
Mozilla
\
\
Firefox
"
Uninstalled
-
{
updateChannel
}
)
;
let
removalSuccessful
=
WindowsRegistry
.
removeRegKey
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
"
Software
\
\
Mozilla
\
\
Firefox
"
Uninstalled
-
{
updateChannel
}
)
;
if
(
removalSuccessful
&
&
uninstalledValue
=
=
"
True
"
)
{
this
.
_resetProfileNotification
(
"
uninstall
"
)
;
}
}
}
this
.
_checkForOldBuildUpdates
(
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
"
services
.
sync
.
username
"
)
)
{
WeaveService
.
init
(
)
;
}
PageThumbs
.
init
(
)
;
NewTabUtils
.
init
(
)
;
AboutCertViewerHandler
.
init
(
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
security
.
ui
.
protections
"
true
)
;
PageActions
.
init
(
)
;
this
.
_firstWindowTelemetry
(
aWindow
)
;
this
.
_firstWindowLoaded
(
)
;
this
.
_collectStartupConditionsTelemetry
(
)
;
PlacesUtils
.
favicons
.
setDefaultIconURIPreferredSize
(
16
*
aWindow
.
devicePixelRatio
)
;
this
.
_setPrefExpectationsAndUpdate
(
)
;
this
.
_matchCBCategory
(
)
;
Services
.
prefs
.
addObserver
(
"
privacy
.
trackingprotection
"
this
.
_matchCBCategory
)
;
Services
.
prefs
.
addObserver
(
"
network
.
cookie
.
cookieBehavior
"
this
.
_matchCBCategory
)
;
Services
.
prefs
.
addObserver
(
ContentBlockingCategoriesPrefs
.
PREF_CB_CATEGORY
this
.
_updateCBCategory
)
;
Services
.
prefs
.
addObserver
(
"
media
.
autoplay
.
default
"
this
.
_updateAutoplayPref
)
;
Services
.
prefs
.
addObserver
(
"
privacy
.
trackingprotection
"
this
.
_setPrefExpectations
)
;
Services
.
prefs
.
addObserver
(
"
browser
.
contentblocking
.
features
.
strict
"
this
.
_setPrefExpectationsAndUpdate
)
;
}
_updateAutoplayPref
(
)
{
const
blocked
=
Services
.
prefs
.
getIntPref
(
"
media
.
autoplay
.
default
"
1
)
;
const
telemetry
=
Services
.
telemetry
.
getHistogramById
(
"
AUTOPLAY_DEFAULT_SETTING_CHANGE
"
)
;
const
labels
=
{
0
:
"
allow
"
1
:
"
blockAudible
"
5
:
"
blockAll
"
}
;
if
(
blocked
in
labels
)
{
telemetry
.
add
(
labels
[
blocked
]
)
;
}
}
_setPrefExpectations
(
)
{
ContentBlockingCategoriesPrefs
.
setPrefExpectations
(
)
;
}
_setPrefExpectationsAndUpdate
(
)
{
ContentBlockingCategoriesPrefs
.
setPrefExpectations
(
)
;
ContentBlockingCategoriesPrefs
.
updateCBCategory
(
)
;
}
_matchCBCategory
(
)
{
ContentBlockingCategoriesPrefs
.
matchCBCategory
(
)
;
}
_updateCBCategory
(
)
{
ContentBlockingCategoriesPrefs
.
updateCBCategory
(
)
;
}
_recordContentBlockingTelemetry
(
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
"
security
.
ui
.
protectionspopup
"
Services
.
prefs
.
getBoolPref
(
"
security
.
protectionspopup
.
recordEventTelemetry
"
)
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
security
.
ui
.
app_menu
"
Services
.
prefs
.
getBoolPref
(
"
security
.
app_menu
.
recordEventTelemetry
"
)
)
;
let
tpEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
trackingprotection
.
enabled
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
TRACKING_PROTECTION_ENABLED
"
)
.
add
(
tpEnabled
)
;
let
tpPBDisabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
TRACKING_PROTECTION_PBM_DISABLED
"
)
.
add
(
!
tpPBDisabled
)
;
let
cookieBehavior
=
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
cookieBehavior
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_BEHAVIOR
"
)
.
add
(
cookieBehavior
)
;
let
fpEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
)
;
let
cmEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
)
;
let
categoryPref
;
switch
(
Services
.
prefs
.
getStringPref
(
"
browser
.
contentblocking
.
category
"
null
)
)
{
case
"
standard
"
:
categoryPref
=
0
;
break
;
case
"
strict
"
:
categoryPref
=
1
;
break
;
case
"
custom
"
:
categoryPref
=
2
;
break
;
default
:
categoryPref
=
3
;
break
;
}
Services
.
telemetry
.
scalarSet
(
"
contentblocking
.
fingerprinting_blocking_enabled
"
fpEnabled
)
;
Services
.
telemetry
.
scalarSet
(
"
contentblocking
.
cryptomining_blocking_enabled
"
cmEnabled
)
;
Services
.
telemetry
.
scalarSet
(
"
contentblocking
.
category
"
categoryPref
)
;
}
_recordDataSanitizationPrefs
(
)
{
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
network_cookie_lifetimePolicy
"
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
lifetimePolicy
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_sanitize_sanitizeOnShutdown
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_cookies
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
cookies
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_history
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
history
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_formdata
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
formdata
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_downloads
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
downloads
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_cache
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
cache
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_sessions
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
sessions
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_offlineApps
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
offlineApps
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_siteSettings
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
siteSettings
"
)
)
;
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
privacy_clearOnShutdown_openWindows
"
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
openWindows
"
)
)
;
let
exceptions
=
0
;
for
(
let
permission
of
Services
.
perms
.
all
)
{
let
uri
=
permission
.
principal
.
URI
;
if
(
permission
.
type
=
=
"
cookie
"
&
&
permission
.
capability
=
=
Ci
.
nsICookiePermission
.
ACCESS_SESSION
&
&
(
uri
.
scheme
=
=
"
http
"
|
|
uri
.
scheme
=
=
"
https
"
|
|
uri
.
scheme
=
=
"
file
"
)
)
{
exceptions
+
+
;
}
}
Services
.
telemetry
.
scalarSet
(
"
datasanitization
.
session_permission_exceptions
"
exceptions
)
;
}
_sendMediaTelemetry
(
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
win
)
{
let
v
=
win
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
video
"
)
;
v
.
reportCanPlayTelemetry
(
)
;
}
}
_onQuitApplicationGranted
(
)
{
this
.
_setPrefToSaveSession
(
)
;
try
{
Services
.
startup
.
trackStartupCrashEnd
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Could
not
end
startup
crash
tracking
in
quit
-
application
-
granted
:
"
+
e
)
;
}
if
(
this
.
_bookmarksBackupIdleTime
)
{
this
.
_idleService
.
removeIdleObserver
(
this
this
.
_bookmarksBackupIdleTime
)
;
delete
this
.
_bookmarksBackupIdleTime
;
}
for
(
let
mod
of
Object
.
values
(
initializedModules
)
)
{
if
(
mod
.
uninit
)
{
mod
.
uninit
(
)
;
}
}
BrowserUsageTelemetry
.
uninit
(
)
;
SearchTelemetry
.
uninit
(
)
;
PageThumbs
.
uninit
(
)
;
NewTabUtils
.
uninit
(
)
;
AboutCertViewerHandler
.
uninit
(
)
;
Normandy
.
uninit
(
)
;
RFPHelper
.
uninit
(
)
;
}
_monitorScreenshotsPref
(
)
{
const
PREF
=
"
extensions
.
screenshots
.
disabled
"
;
const
ID
=
"
screenshots
mozilla
.
org
"
;
const
_checkScreenshotsPref
=
async
(
)
=
>
{
let
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
let
disabled
=
Services
.
prefs
.
getBoolPref
(
PREF
false
)
;
if
(
disabled
)
{
await
addon
.
disable
(
{
allowSystemAddons
:
true
}
)
;
}
else
{
await
addon
.
enable
(
{
allowSystemAddons
:
true
}
)
;
}
}
;
Services
.
prefs
.
addObserver
(
PREF
_checkScreenshotsPref
)
;
_checkScreenshotsPref
(
)
;
}
_monitorWebcompatReporterPref
(
)
{
const
PREF
=
"
extensions
.
webcompat
-
reporter
.
enabled
"
;
const
ID
=
"
webcompat
-
reporter
mozilla
.
org
"
;
Services
.
prefs
.
addObserver
(
PREF
async
(
)
=
>
{
let
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
let
enabled
=
Services
.
prefs
.
getBoolPref
(
PREF
false
)
;
if
(
enabled
&
&
!
addon
.
isActive
)
{
await
addon
.
enable
(
{
allowSystemAddons
:
true
}
)
;
}
else
if
(
!
enabled
&
&
addon
.
isActive
)
{
await
addon
.
disable
(
{
allowSystemAddons
:
true
}
)
;
}
}
)
;
}
_monitorHTTPSOnlyPref
(
)
{
const
PREF_ENABLED
=
"
dom
.
security
.
https_only_mode
"
;
const
PREF_WAS_ENABLED
=
"
dom
.
security
.
https_only_mode_ever_enabled
"
;
const
_checkHTTPSOnlyPref
=
async
(
)
=
>
{
const
enabled
=
Services
.
prefs
.
getBoolPref
(
PREF_ENABLED
false
)
;
const
was_enabled
=
Services
.
prefs
.
getBoolPref
(
PREF_WAS_ENABLED
false
)
;
let
value
=
0
;
if
(
enabled
)
{
value
=
1
;
Services
.
prefs
.
setBoolPref
(
PREF_WAS_ENABLED
true
)
;
}
else
if
(
was_enabled
)
{
value
=
2
;
}
Services
.
telemetry
.
scalarSet
(
"
security
.
https_only_mode_enabled
"
value
)
;
}
;
Services
.
prefs
.
addObserver
(
PREF_ENABLED
_checkHTTPSOnlyPref
)
;
_checkHTTPSOnlyPref
(
)
;
}
_showNewInstallModal
(
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
let
stack
=
win
.
gBrowser
.
getPanel
(
)
.
querySelector
(
"
.
browserStack
"
)
;
let
mask
=
win
.
document
.
createXULElement
(
"
box
"
)
;
mask
.
setAttribute
(
"
id
"
"
content
-
mask
"
)
;
stack
.
appendChild
(
mask
)
;
Services
.
ww
.
openWindow
(
win
"
chrome
:
/
/
browser
/
content
/
newInstall
.
xhtml
"
"
_blank
"
"
chrome
modal
resizable
=
no
centerscreen
"
null
)
;
mask
.
remove
(
)
;
}
)
;
}
_onWindowsRestored
:
function
BG__onWindowsRestored
(
)
{
if
(
this
.
_windowsWereRestored
)
{
return
;
}
this
.
_windowsWereRestored
=
true
;
BrowserUsageTelemetry
.
init
(
)
;
SearchTelemetry
.
init
(
)
;
ExtensionsUI
.
init
(
)
;
let
signingRequired
;
if
(
AppConstants
.
MOZ_REQUIRE_SIGNING
)
{
signingRequired
=
true
;
}
else
{
signingRequired
=
Services
.
prefs
.
getBoolPref
(
"
xpinstall
.
signatures
.
required
"
)
;
}
if
(
signingRequired
)
{
let
disabledAddons
=
AddonManager
.
getStartupChanges
(
AddonManager
.
STARTUP_CHANGE_DISABLED
)
;
AddonManager
.
getAddonsByIDs
(
disabledAddons
)
.
then
(
addons
=
>
{
for
(
let
addon
of
addons
)
{
if
(
addon
.
signedState
<
=
AddonManager
.
SIGNEDSTATE_MISSING
)
{
this
.
_notifyUnsignedAddonsDisabled
(
)
;
break
;
}
}
}
)
;
}
if
(
AppConstants
.
MOZ_CRASHREPORTER
)
{
UnsubmittedCrashHandler
.
init
(
)
;
UnsubmittedCrashHandler
.
scheduleCheckForUnsubmittedCrashReports
(
)
;
}
if
(
AppConstants
.
ASAN_REPORTER
)
{
var
{
AsanReporter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
AsanReporter
.
jsm
"
)
;
AsanReporter
.
init
(
)
;
}
Sanitizer
.
onStartup
(
)
;
this
.
_scheduleStartupIdleTasks
(
)
;
this
.
_lateTasksIdleObserver
=
(
idleService
topic
data
)
=
>
{
if
(
topic
=
=
"
idle
"
)
{
idleService
.
removeIdleObserver
(
this
.
_lateTasksIdleObserver
LATE_TASKS_IDLE_TIME_SEC
)
;
delete
this
.
_lateTasksIdleObserver
;
this
.
_scheduleArbitrarilyLateIdleTasks
(
)
;
}
}
;
this
.
_idleService
.
addIdleObserver
(
this
.
_lateTasksIdleObserver
LATE_TASKS_IDLE_TIME_SEC
)
;
this
.
_monitorScreenshotsPref
(
)
;
this
.
_monitorWebcompatReporterPref
(
)
;
this
.
_monitorHTTPSOnlyPref
(
)
;
let
pService
=
Cc
[
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
]
.
getService
(
Ci
.
nsIToolkitProfileService
)
;
if
(
pService
.
createdAlternateProfile
)
{
this
.
_showNewInstallModal
(
)
;
}
FirefoxMonitor
.
init
(
)
;
}
_scheduleStartupIdleTasks
(
)
{
const
idleTasks
=
[
{
task
:
(
)
=
>
{
SafeBrowsing
.
init
(
)
;
}
timeout
:
5000
}
{
task
:
async
(
)
=
>
{
await
ContextualIdentityService
.
load
(
)
;
Discovery
.
update
(
)
;
}
}
{
task
:
(
)
=
>
{
try
{
PushService
.
wrappedJSObject
.
ensureReady
(
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
throw
ex
;
}
}
}
}
{
task
:
(
)
=
>
{
this
.
_recordContentBlockingTelemetry
(
)
;
}
}
{
task
:
(
)
=
>
{
this
.
_recordDataSanitizationPrefs
(
)
;
}
}
{
task
:
(
)
=
>
{
let
enableCertErrorUITelemetry
=
Services
.
prefs
.
getBoolPref
(
"
security
.
certerrors
.
recordEventTelemetry
"
true
)
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
security
.
ui
.
certerror
"
enableCertErrorUITelemetry
)
;
}
}
{
task
:
(
)
=
>
{
let
siteSpecific
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
zoom
.
siteSpecific
"
false
)
;
Services
.
telemetry
.
scalarSet
(
"
a11y
.
sitezoom
"
siteSpecific
)
;
}
}
{
task
:
(
)
=
>
{
try
{
Services
.
logins
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
timeout
:
3000
}
{
task
:
(
)
=
>
{
this
.
_addBreachAlertsPrefObserver
(
)
;
}
}
{
condition
:
AppConstants
.
platform
=
=
"
win
"
task
:
(
)
=
>
{
const
WINTASKBAR_CONTRACTID
=
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
;
if
(
WINTASKBAR_CONTRACTID
in
Cc
&
&
Cc
[
WINTASKBAR_CONTRACTID
]
.
getService
(
Ci
.
nsIWinTaskbar
)
.
available
)
{
let
temp
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
WindowsJumpLists
.
jsm
"
temp
)
;
temp
.
WinTaskbarJumpList
.
startup
(
)
;
}
}
}
{
task
:
(
)
=
>
{
this
.
_maybeShowDefaultBrowserPrompt
(
)
;
}
}
{
task
:
(
)
=
>
{
let
{
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
setTimeout
(
function
(
)
{
Services
.
tm
.
idleDispatchToMainThread
(
Services
.
startup
.
trackStartupCrashEnd
)
;
}
STARTUP_CRASHES_END_DELAY_MS
)
;
}
}
{
task
:
(
)
=
>
{
let
handlerService
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
handlerService
.
asyncInit
(
)
;
}
}
{
condition
:
AppConstants
.
platform
=
=
"
win
"
task
:
(
)
=
>
{
JawsScreenReaderVersionCheck
.
onWindowsRestored
(
)
;
}
}
{
task
:
(
)
=
>
{
RFPHelper
.
init
(
)
;
}
}
{
task
:
(
)
=
>
{
Blocklist
.
loadBlocklistAsync
(
)
;
}
}
{
condition
:
Services
.
prefs
.
getIntPref
(
"
browser
.
livebookmarks
.
migrationAttemptsLeft
"
0
)
>
0
task
:
(
)
=
>
{
LiveBookmarkMigrator
.
migrate
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
{
task
:
(
)
=
>
{
TabUnloader
.
init
(
)
;
}
}
{
condition
:
AppConstants
.
ENABLE_REMOTE_AGENT
task
:
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
remote
-
startup
-
requested
"
)
;
}
}
{
task
:
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
marionette
-
startup
-
requested
"
)
;
}
}
{
task
:
(
)
=
>
{
if
(
Services
.
prefs
.
getBoolPref
(
"
doh
-
rollout
.
trrRace
.
enabled
"
false
)
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
doh
-
rollout
.
trrRace
.
complete
"
false
)
)
{
new
TRRRacer
(
)
.
run
(
)
;
}
}
else
{
Services
.
prefs
.
addObserver
(
"
doh
-
rollout
.
trrRace
.
enabled
"
function
observer
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
doh
-
rollout
.
trrRace
.
enabled
"
false
)
)
{
Services
.
prefs
.
removeObserver
(
"
doh
-
rollout
.
trrRace
.
enabled
"
observer
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
doh
-
rollout
.
trrRace
.
complete
"
false
)
)
{
new
TRRRacer
(
)
.
run
(
)
;
}
}
}
)
;
}
}
}
]
;
for
(
let
task
of
idleTasks
)
{
if
(
"
condition
"
in
task
&
&
!
task
.
condition
)
{
continue
;
}
ChromeUtils
.
idleDispatch
(
(
)
=
>
{
if
(
!
Services
.
startup
.
shuttingDown
)
{
let
startTime
=
Cu
.
now
(
)
;
try
{
task
.
task
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
finally
{
ChromeUtils
.
addProfilerMarker
(
"
startupIdleTask
"
startTime
)
;
}
}
}
task
.
timeout
?
{
timeout
:
task
.
timeout
}
:
undefined
)
;
}
}
_scheduleArbitrarilyLateIdleTasks
(
)
{
const
idleTasks
=
[
(
)
=
>
{
this
.
_sendMediaTelemetry
(
)
;
}
(
)
=
>
{
let
tokenDB
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
getService
(
Ci
.
nsIPK11TokenDB
)
;
let
token
=
tokenDB
.
getInternalKeyToken
(
)
;
let
mpEnabled
=
token
.
hasPassword
;
if
(
mpEnabled
)
{
Services
.
telemetry
.
getHistogramById
(
"
MASTER_PASSWORD_ENABLED
"
)
.
add
(
mpEnabled
)
;
}
}
(
)
=
>
{
let
obj
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
GMPInstallManager
.
jsm
"
obj
)
;
this
.
_gmpInstallManager
=
new
obj
.
GMPInstallManager
(
)
;
this
.
_gmpInstallManager
.
simpleCheckAndInstall
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
(
)
=
>
{
RemoteSettings
.
init
(
)
;
this
.
_addBreachesSyncHandler
(
)
;
}
(
)
=
>
{
PublicSuffixList
.
init
(
)
;
}
(
)
=
>
{
RemoteSecuritySettings
.
init
(
)
;
}
(
)
=
>
{
if
(
Services
.
prefs
.
getBoolPref
(
"
corroborator
.
enabled
"
false
)
)
{
Corroborate
.
init
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
]
;
for
(
let
task
of
idleTasks
)
{
ChromeUtils
.
idleDispatch
(
(
)
=
>
{
if
(
!
Services
.
startup
.
shuttingDown
)
{
let
startTime
=
Cu
.
now
(
)
;
try
{
task
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
finally
{
ChromeUtils
.
addProfilerMarker
(
"
startupLateIdleTask
"
startTime
)
;
}
}
}
)
;
}
}
_addBreachesSyncHandler
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
signon
.
management
.
page
.
breach
-
alerts
.
enabled
"
false
)
)
{
RemoteSettings
(
LoginBreaches
.
REMOTE_SETTINGS_COLLECTION
)
.
on
(
"
sync
"
async
event
=
>
{
await
LoginBreaches
.
update
(
event
.
data
.
current
)
;
}
)
;
}
}
_addBreachAlertsPrefObserver
(
)
{
const
BREACH_ALERTS_PREF
=
"
signon
.
management
.
page
.
breach
-
alerts
.
enabled
"
;
const
clearVulnerablePasswordsIfBreachAlertsDisabled
=
async
function
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
BREACH_ALERTS_PREF
)
)
{
await
LoginBreaches
.
clearAllPotentiallyVulnerablePasswords
(
)
;
}
}
;
clearVulnerablePasswordsIfBreachAlertsDisabled
(
)
;
Services
.
prefs
.
addObserver
(
BREACH_ALERTS_PREF
clearVulnerablePasswordsIfBreachAlertsDisabled
)
;
}
_onQuitRequest
:
function
BG__onQuitRequest
(
aCancelQuit
aQuitType
)
{
if
(
aCancelQuit
instanceof
Ci
.
nsISupportsPRBool
&
&
aCancelQuit
.
data
)
{
return
;
}
if
(
aQuitType
=
=
"
restart
"
|
|
aQuitType
=
=
"
os
-
restart
"
)
{
return
;
}
var
windowcount
=
0
;
var
pagecount
=
0
;
for
(
let
win
of
BrowserWindowTracker
.
orderedWindows
)
{
if
(
win
.
closed
)
{
continue
;
}
windowcount
+
+
;
let
tabbrowser
=
win
.
gBrowser
;
if
(
tabbrowser
)
{
pagecount
+
=
tabbrowser
.
browsers
.
length
-
tabbrowser
.
_numPinnedTabs
-
tabbrowser
.
_removingTabs
.
length
;
}
}
if
(
pagecount
<
2
)
{
return
;
}
if
(
!
aQuitType
)
{
aQuitType
=
"
quit
"
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
warnOnQuit
"
)
)
{
return
;
}
let
sessionWillBeRestored
=
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
page
"
)
=
=
3
|
|
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
resume_session_once
"
)
;
if
(
sessionWillBeRestored
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
sessionstore
.
warnOnQuit
"
false
)
)
{
return
;
}
}
else
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
warnOnClose
"
)
)
{
return
;
}
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
let
warningMessage
;
if
(
windowcount
>
1
)
{
let
tabSubstring
=
gTabbrowserBundle
.
GetStringFromName
(
"
tabs
.
closeWarningMultipleWindowsTabSnippet
"
)
;
tabSubstring
=
PluralForm
.
get
(
pagecount
tabSubstring
)
.
replace
(
/
#
1
/
pagecount
)
;
let
stringID
=
sessionWillBeRestored
?
"
tabs
.
closeWarningMultipleWindowsSessionRestore2
"
:
"
tabs
.
closeWarningMultipleWindows
"
;
let
windowString
=
gTabbrowserBundle
.
GetStringFromName
(
stringID
)
;
windowString
=
PluralForm
.
get
(
windowcount
windowString
)
.
replace
(
/
#
1
/
windowcount
)
;
warningMessage
=
windowString
.
replace
(
/
%
(
?
:
1
\
)
?
S
/
i
tabSubstring
)
;
}
else
{
let
stringID
=
sessionWillBeRestored
?
"
tabs
.
closeWarningMultipleSessionRestore2
"
:
"
tabs
.
closeWarningMultiple
"
;
warningMessage
=
gTabbrowserBundle
.
GetStringFromName
(
stringID
)
;
warningMessage
=
PluralForm
.
get
(
pagecount
warningMessage
)
.
replace
(
"
#
1
"
pagecount
)
;
}
let
warnOnClose
=
{
value
:
true
}
;
let
titleId
=
AppConstants
.
platform
=
=
"
win
"
?
"
tabs
.
closeAndQuitTitleTabsWin
"
:
"
tabs
.
closeAndQuitTitleTabs
"
;
let
flags
=
Services
.
prompt
.
BUTTON_TITLE_IS_STRING
*
Services
.
prompt
.
BUTTON_POS_0
+
Services
.
prompt
.
BUTTON_TITLE_CANCEL
*
Services
.
prompt
.
BUTTON_POS_1
;
let
checkboxLabel
=
!
sessionWillBeRestored
?
gTabbrowserBundle
.
GetStringFromName
(
"
tabs
.
closeWarningPromptMe
"
)
:
null
;
let
buttonPressed
=
Services
.
prompt
.
confirmEx
(
win
gTabbrowserBundle
.
GetStringFromName
(
titleId
)
warningMessage
flags
gTabbrowserBundle
.
GetStringFromName
(
"
tabs
.
closeButtonMultiple
"
)
null
null
checkboxLabel
warnOnClose
)
;
if
(
!
sessionWillBeRestored
&
&
buttonPressed
=
=
0
&
&
!
warnOnClose
.
value
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
tabs
.
warnOnClose
"
false
)
;
}
aCancelQuit
.
data
=
buttonPressed
!
=
0
;
}
_initPlaces
:
function
BG__initPlaces
(
aInitialMigrationPerformed
)
{
let
dbStatus
=
PlacesUtils
.
history
.
databaseStatus
;
if
(
dbStatus
=
=
PlacesUtils
.
history
.
DATABASE_STATUS_LOCKED
)
{
this
.
_firstWindowReady
.
then
(
(
)
=
>
{
this
.
_showPlacesLockedNotificationBox
(
)
;
this
.
_placesBrowserInitComplete
=
true
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
browser
-
init
-
complete
"
)
;
}
)
;
return
;
}
let
importBookmarks
=
!
aInitialMigrationPerformed
&
&
(
dbStatus
=
=
PlacesUtils
.
history
.
DATABASE_STATUS_CREATE
|
|
dbStatus
=
=
PlacesUtils
.
history
.
DATABASE_STATUS_CORRUPT
)
;
let
importBookmarksHTML
=
false
;
try
{
importBookmarksHTML
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
places
.
importBookmarksHTML
"
)
;
if
(
importBookmarksHTML
)
{
importBookmarks
=
true
;
}
}
catch
(
ex
)
{
}
let
autoExportHTML
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
bookmarks
.
autoExportHTML
"
false
)
;
if
(
autoExportHTML
)
{
AsyncShutdown
.
profileChangeTeardown
.
addBlocker
(
"
Places
:
export
bookmarks
.
html
"
(
)
=
>
BookmarkHTMLUtils
.
exportToFile
(
BookmarkHTMLUtils
.
defaultPath
)
)
;
}
(
async
(
)
=
>
{
let
restoreDefaultBookmarks
=
false
;
try
{
restoreDefaultBookmarks
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
bookmarks
.
restore_default_bookmarks
"
)
;
if
(
restoreDefaultBookmarks
)
{
await
this
.
_backupBookmarks
(
)
;
importBookmarks
=
true
;
}
}
catch
(
ex
)
{
}
let
lastBackupFile
;
if
(
importBookmarks
&
&
!
restoreDefaultBookmarks
&
&
!
importBookmarksHTML
)
{
lastBackupFile
=
await
PlacesBackups
.
getMostRecentBackup
(
)
;
if
(
lastBackupFile
)
{
await
BookmarkJSONUtils
.
importFromFile
(
lastBackupFile
{
replace
:
true
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
}
)
;
importBookmarks
=
false
;
}
else
{
importBookmarks
=
true
;
if
(
await
OS
.
File
.
exists
(
BookmarkHTMLUtils
.
defaultPath
)
)
{
importBookmarksHTML
=
true
;
}
else
{
restoreDefaultBookmarks
=
true
;
}
}
}
if
(
!
importBookmarks
)
{
try
{
await
this
.
_distributionCustomizer
.
applyBookmarks
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
else
{
let
bookmarksUrl
=
null
;
if
(
restoreDefaultBookmarks
)
{
bookmarksUrl
=
"
chrome
:
/
/
browser
/
locale
/
bookmarks
.
html
"
;
}
else
if
(
await
OS
.
File
.
exists
(
BookmarkHTMLUtils
.
defaultPath
)
)
{
bookmarksUrl
=
OS
.
Path
.
toFileURI
(
BookmarkHTMLUtils
.
defaultPath
)
;
}
if
(
bookmarksUrl
)
{
try
{
if
(
Services
.
policies
.
isAllowed
(
"
defaultBookmarks
"
)
)
{
await
BookmarkHTMLUtils
.
importFromURL
(
bookmarksUrl
{
replace
:
true
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
}
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
"
Bookmarks
.
html
file
could
be
corrupt
.
"
+
e
)
;
}
try
{
await
this
.
_distributionCustomizer
.
applyBookmarks
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
else
{
Cu
.
reportError
(
new
Error
(
"
Unable
to
find
bookmarks
.
html
file
.
"
)
)
;
}
if
(
importBookmarksHTML
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
places
.
importBookmarksHTML
"
false
)
;
}
if
(
restoreDefaultBookmarks
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
bookmarks
.
restore_default_bookmarks
"
false
)
;
}
}
if
(
!
this
.
_bookmarksBackupIdleTime
)
{
this
.
_bookmarksBackupIdleTime
=
BOOKMARKS_BACKUP_IDLE_TIME_SEC
;
if
(
lastBackupFile
=
=
=
undefined
)
{
lastBackupFile
=
await
PlacesBackups
.
getMostRecentBackup
(
)
;
}
if
(
!
lastBackupFile
)
{
this
.
_bookmarksBackupIdleTime
/
=
2
;
}
else
{
let
lastBackupTime
=
PlacesBackups
.
getDateForFile
(
lastBackupFile
)
;
let
profileLastUse
=
Services
.
appinfo
.
replacedLockTime
|
|
Date
.
now
(
)
;
if
(
profileLastUse
>
lastBackupTime
)
{
let
backupAge
=
Math
.
round
(
(
profileLastUse
-
lastBackupTime
)
/
86400000
)
;
try
{
Services
.
telemetry
.
getHistogramById
(
"
PLACES_BACKUPS_DAYSFROMLAST
"
)
.
add
(
backupAge
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
new
Error
(
"
Unable
to
report
telemetry
.
"
)
)
;
}
if
(
backupAge
>
BOOKMARKS_BACKUP_MAX_INTERVAL_DAYS
)
{
this
.
_bookmarksBackupIdleTime
/
=
2
;
}
}
}
this
.
_idleService
.
addIdleObserver
(
this
this
.
_bookmarksBackupIdleTime
)
;
}
if
(
this
.
_isNewProfile
)
{
try
{
this
.
_maybeToggleBookmarkToolbarVisibility
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
)
(
)
.
catch
(
ex
=
>
{
Cu
.
reportError
(
ex
)
;
}
)
.
then
(
(
)
=
>
{
this
.
_placesBrowserInitComplete
=
true
;
Services
.
obs
.
notifyObservers
(
null
"
places
-
browser
-
init
-
complete
"
)
;
}
)
;
}
_backupBookmarks
:
function
BG__backupBookmarks
(
)
{
return
(
async
function
(
)
{
let
lastBackupFile
=
await
PlacesBackups
.
getMostRecentBackup
(
)
;
if
(
!
lastBackupFile
|
|
new
Date
(
)
-
PlacesBackups
.
getDateForFile
(
lastBackupFile
)
>
BOOKMARKS_BACKUP_MIN_INTERVAL_DAYS
*
86400000
)
{
let
maxBackups
=
Services
.
prefs
.
getIntPref
(
"
browser
.
bookmarks
.
max_backups
"
)
;
await
PlacesBackups
.
create
(
maxBackups
)
;
}
}
)
(
)
;
}
_showPlacesLockedNotificationBox
:
function
BG__showPlacesLockedNotificationBox
(
)
{
var
applicationName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
var
placesBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
places
/
places
.
properties
"
)
;
var
title
=
placesBundle
.
GetStringFromName
(
"
lockPrompt
.
title
"
)
;
var
text
=
placesBundle
.
formatStringFromName
(
"
lockPrompt
.
text
"
[
applicationName
]
)
;
var
buttonText
=
placesBundle
.
GetStringFromName
(
"
lockPromptInfoButton
.
label
"
)
;
var
accessKey
=
placesBundle
.
GetStringFromName
(
"
lockPromptInfoButton
.
accessKey
"
)
;
var
helpTopic
=
"
places
-
locked
"
;
var
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
;
url
+
=
helpTopic
;
var
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
var
buttons
=
[
{
label
:
buttonText
accessKey
popup
:
null
callback
(
aNotificationBar
aButton
)
{
win
.
openTrustedLinkIn
(
url
"
tab
"
)
;
}
}
]
;
var
notifyBox
=
win
.
gBrowser
.
getNotificationBox
(
)
;
var
notification
=
notifyBox
.
appendNotification
(
text
title
null
notifyBox
.
PRIORITY_CRITICAL_MEDIUM
buttons
)
;
notification
.
persistence
=
-
1
;
}
_onThisDeviceConnected
(
)
{
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
accounts
.
properties
"
)
;
let
title
=
bundle
.
GetStringFromName
(
"
deviceConnDisconnTitle
"
)
;
let
body
=
bundle
.
GetStringFromName
(
"
thisDeviceConnectedBody
"
)
;
let
clickCallback
=
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
"
alertclickcallback
"
)
{
return
;
}
this
.
_openPreferences
(
"
sync
"
)
;
}
;
this
.
AlertsService
.
showAlertNotification
(
null
title
body
true
null
clickCallback
)
;
}
_maybeToggleBookmarkToolbarVisibility
(
)
{
const
BROWSER_DOCURL
=
AppConstants
.
BROWSER_CHROME_URL
;
const
NUM_TOOLBAR_BOOKMARKS_TO_UNHIDE
=
3
;
let
xulStore
=
Services
.
xulStore
;
if
(
!
xulStore
.
hasValue
(
BROWSER_DOCURL
"
PersonalToolbar
"
"
collapsed
"
)
)
{
let
toolbarIsCustomized
=
xulStore
.
hasValue
(
BROWSER_DOCURL
"
PersonalToolbar
"
"
currentset
"
)
;
let
getToolbarFolderCount
=
(
)
=
>
{
let
toolbarFolder
=
PlacesUtils
.
getFolderContents
(
PlacesUtils
.
bookmarks
.
toolbarGuid
)
.
root
;
let
toolbarChildCount
=
toolbarFolder
.
childCount
;
toolbarFolder
.
containerOpen
=
false
;
return
toolbarChildCount
;
}
;
if
(
toolbarIsCustomized
|
|
getToolbarFolderCount
(
)
>
NUM_TOOLBAR_BOOKMARKS_TO_UNHIDE
)
{
CustomizableUI
.
setToolbarVisibility
(
CustomizableUI
.
AREA_BOOKMARKS
true
)
;
}
}
}
_migrateXULStoreForDocument
(
fromURL
toURL
)
{
Array
.
from
(
Services
.
xulStore
.
getIDsEnumerator
(
fromURL
)
)
.
forEach
(
id
=
>
{
Array
.
from
(
Services
.
xulStore
.
getAttributeEnumerator
(
fromURL
id
)
)
.
forEach
(
attr
=
>
{
let
value
=
Services
.
xulStore
.
getValue
(
fromURL
id
attr
)
;
Services
.
xulStore
.
setValue
(
toURL
id
attr
value
)
;
}
)
;
}
)
;
}
_migrateUI
:
function
BG__migrateUI
(
)
{
const
UI_VERSION
=
94
;
const
BROWSER_DOCURL
=
AppConstants
.
BROWSER_CHROME_URL
;
if
(
!
Services
.
prefs
.
prefHasUserValue
(
"
browser
.
migration
.
version
"
)
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
migration
.
version
"
UI_VERSION
)
;
this
.
_isNewProfile
=
true
;
return
;
}
this
.
_isNewProfile
=
false
;
let
currentUIVersion
=
Services
.
prefs
.
getIntPref
(
"
browser
.
migration
.
version
"
)
;
if
(
currentUIVersion
>
=
UI_VERSION
)
{
return
;
}
let
xulStore
=
Services
.
xulStore
;
if
(
currentUIVersion
<
52
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
webconsole
.
persistlog
"
false
)
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
netmonitor
.
persistlog
"
true
)
;
}
}
if
(
currentUIVersion
<
53
)
{
const
MALWARE_PREF
=
"
urlclassifier
.
malwareTable
"
;
if
(
Services
.
prefs
.
prefHasUserValue
(
MALWARE_PREF
)
)
{
let
malwareList
=
Services
.
prefs
.
getCharPref
(
MALWARE_PREF
)
;
if
(
malwareList
.
includes
(
"
goog
-
malware
-
shavar
"
)
)
{
malwareList
.
replace
(
"
goog
-
malware
-
shavar
"
"
goog
-
malware
-
proto
"
)
;
Services
.
prefs
.
setCharPref
(
MALWARE_PREF
malwareList
)
;
}
}
}
if
(
currentUIVersion
<
55
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
customizemode
.
tip0
.
shown
"
)
;
}
if
(
currentUIVersion
<
56
)
{
if
(
xulStore
.
getValue
(
BROWSER_DOCURL
"
sidebar
-
box
"
"
sidebarcommand
"
)
)
{
xulStore
.
setValue
(
BROWSER_DOCURL
"
sidebar
-
box
"
"
checked
"
"
true
"
)
;
}
}
if
(
currentUIVersion
<
58
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
countryCode
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
region
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
isUS
"
)
;
}
if
(
currentUIVersion
<
59
)
{
let
searchInitializedPromise
=
new
Promise
(
resolve
=
>
{
if
(
Services
.
search
.
isInitialized
)
{
resolve
(
)
;
}
const
SEARCH_SERVICE_TOPIC
=
"
browser
-
search
-
service
"
;
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
if
(
data
!
=
"
init
-
complete
"
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observer
SEARCH_SERVICE_TOPIC
)
;
resolve
(
)
;
}
SEARCH_SERVICE_TOPIC
)
;
}
)
;
searchInitializedPromise
.
then
(
(
)
=
>
{
let
currentEngine
=
Services
.
search
.
defaultEngine
.
wrappedJSObject
;
if
(
currentEngine
.
_extensionID
|
|
currentEngine
.
isAppProvided
|
|
!
Services
.
search
.
originalDefaultEngine
.
isAppProvided
)
{
return
;
}
if
(
!
currentEngine
.
_loadPath
.
startsWith
(
"
[
https
]
"
)
)
{
Services
.
search
.
resetToOriginalDefaultEngine
(
)
;
}
}
)
;
const
SELECTED_LOCALE_PREF
=
"
general
.
useragent
.
locale
"
;
const
MATCHOS_LOCALE_PREF
=
"
intl
.
locale
.
matchOS
"
;
if
(
Services
.
prefs
.
prefHasUserValue
(
MATCHOS_LOCALE_PREF
)
|
|
Services
.
prefs
.
prefHasUserValue
(
SELECTED_LOCALE_PREF
)
)
{
if
(
Services
.
prefs
.
getBoolPref
(
MATCHOS_LOCALE_PREF
false
)
)
{
Services
.
locale
.
requestedLocales
=
[
]
;
}
else
{
let
locale
=
Services
.
prefs
.
getComplexValue
(
SELECTED_LOCALE_PREF
Ci
.
nsIPrefLocalizedString
)
;
if
(
locale
)
{
try
{
Services
.
locale
.
requestedLocales
=
[
locale
.
data
]
;
}
catch
(
e
)
{
}
}
}
Services
.
prefs
.
clearUserPref
(
SELECTED_LOCALE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
MATCHOS_LOCALE_PREF
)
;
}
}
if
(
currentUIVersion
<
61
)
{
xulStore
.
removeValue
(
BROWSER_DOCURL
"
navigator
-
toolbox
"
"
toolbarset
"
)
;
}
if
(
currentUIVersion
<
62
)
{
let
toolbars
=
[
"
navigator
-
toolbox
"
"
nav
-
bar
"
"
PersonalToolbar
"
"
TabsToolbar
"
"
toolbar
-
menubar
"
]
;
for
(
let
resourceName
of
[
"
mode
"
"
iconsize
"
]
)
{
for
(
let
toolbarId
of
toolbars
)
{
xulStore
.
removeValue
(
BROWSER_DOCURL
toolbarId
resourceName
)
;
}
}
}
if
(
currentUIVersion
<
64
)
{
OS
.
File
.
remove
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
directoryLinks
.
json
"
)
{
ignoreAbsent
:
true
}
)
;
}
if
(
currentUIVersion
<
65
&
&
Services
.
prefs
.
getCharPref
(
"
general
.
config
.
filename
"
"
"
)
=
=
"
dsengine
.
cfg
"
)
{
let
searchInitializedPromise
=
new
Promise
(
resolve
=
>
{
if
(
Services
.
search
.
isInitialized
)
{
resolve
(
)
;
}
const
SEARCH_SERVICE_TOPIC
=
"
browser
-
search
-
service
"
;
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
if
(
data
!
=
"
init
-
complete
"
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observer
SEARCH_SERVICE_TOPIC
)
;
resolve
(
)
;
}
SEARCH_SERVICE_TOPIC
)
;
}
)
;
searchInitializedPromise
.
then
(
(
)
=
>
{
let
engineNames
=
[
"
Bing
Search
Engine
"
"
Yahoo
!
Search
Engine
"
"
Yandex
Search
Engine
"
]
;
for
(
let
engineName
of
engineNames
)
{
let
engine
=
Services
.
search
.
getEngineByName
(
engineName
)
;
if
(
engine
)
{
Services
.
search
.
removeEngine
(
engine
)
;
}
}
}
)
;
}
if
(
currentUIVersion
<
66
)
{
this
.
_migrateMatchBucketsPrefForUI66
(
)
;
}
if
(
currentUIVersion
<
67
)
{
if
(
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
=
=
"
firebug
"
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
theme
"
"
light
"
)
;
}
}
if
(
currentUIVersion
<
68
)
{
OS
.
File
.
remove
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
kinto
.
sqlite
"
)
{
ignoreAbsent
:
true
}
)
;
}
if
(
currentUIVersion
<
69
)
{
let
socialPrefs
=
Services
.
prefs
.
getBranch
(
"
social
.
"
)
;
if
(
socialPrefs
)
{
let
socialPrefsArray
=
socialPrefs
.
getChildList
(
"
"
)
;
for
(
let
item
of
socialPrefsArray
)
{
Services
.
prefs
.
clearUserPref
(
"
social
.
"
+
item
)
;
}
}
}
if
(
currentUIVersion
<
70
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
ctrlTab
.
recentlyUsedOrder
"
Services
.
prefs
.
getBoolPref
(
"
browser
.
ctrlTab
.
previews
"
false
)
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
ctrlTab
.
previews
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
ctrlTab
.
migrated
"
true
)
;
}
if
(
currentUIVersion
<
71
)
{
let
savedContentHandlers
=
Services
.
prefs
.
getChildList
(
"
browser
.
contentHandlers
.
types
"
)
;
for
(
let
savedHandlerPref
of
savedContentHandlers
)
{
Services
.
prefs
.
clearUserPref
(
savedHandlerPref
)
;
}
}
if
(
currentUIVersion
<
72
)
{
let
pref
=
"
devtools
.
performance
.
recording
.
interval
"
;
Services
.
prefs
.
setIntPref
(
pref
Services
.
prefs
.
getIntPref
(
pref
1
)
*
1000
)
;
}
if
(
currentUIVersion
<
73
)
{
OS
.
File
.
removeDir
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
blocklists
"
)
{
ignoreAbsent
:
true
}
)
;
OS
.
File
.
removeDir
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
blocklists
-
preview
"
)
{
ignoreAbsent
:
true
}
)
;
for
(
const
filename
of
[
"
addons
.
json
"
"
plugins
.
json
"
"
gfx
.
json
"
]
)
{
const
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
blocklists
-
{
filename
}
)
;
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
}
}
if
(
currentUIVersion
<
75
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
livebookmarks
.
migrationAttemptsLeft
"
5
)
;
}
if
(
currentUIVersion
<
76
)
{
let
onboardingPrefs
=
Services
.
prefs
.
getBranch
(
"
browser
.
onboarding
.
"
)
;
if
(
onboardingPrefs
)
{
let
onboardingPrefsArray
=
onboardingPrefs
.
getChildList
(
"
"
)
;
for
(
let
item
of
onboardingPrefsArray
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
onboarding
.
"
+
item
)
;
}
}
}
if
(
currentUIVersion
<
77
)
{
let
toolbars
=
[
"
nav
-
bar
"
"
PersonalToolbar
"
"
TabsToolbar
"
"
toolbar
-
menubar
"
]
;
for
(
let
toolbarId
of
toolbars
)
{
xulStore
.
removeValue
(
BROWSER_DOCURL
toolbarId
"
currentset
"
)
;
}
}
if
(
currentUIVersion
<
78
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
region
"
)
;
}
if
(
currentUIVersion
<
79
)
{
Services
.
prefs
.
setCharPref
(
"
browser
.
handlers
.
migrations
"
"
30boxes
"
)
;
}
if
(
currentUIVersion
<
80
)
{
let
hosts
=
Services
.
prefs
.
getCharPref
(
"
network
.
proxy
.
no_proxies_on
"
)
;
const
kLocalHosts
=
new
Set
(
[
"
localhost
"
"
127
.
0
.
0
.
1
"
]
)
;
hosts
=
hosts
.
split
(
/
[
]
+
/
)
.
filter
(
host
=
>
!
kLocalHosts
.
has
(
host
)
)
.
join
(
"
"
)
;
Services
.
prefs
.
setCharPref
(
"
network
.
proxy
.
no_proxies_on
"
hosts
)
;
}
if
(
currentUIVersion
<
81
)
{
if
(
HomePage
.
overridden
)
{
const
DEFAULT
=
HomePage
.
getDefault
(
)
;
let
value
=
HomePage
.
get
(
)
;
let
updated
=
value
.
replace
(
/
https
?
:
\
/
\
/
(
[
\
w
\
-
]
+
\
.
)
?
start
\
d
*
\
.
mozilla
\
.
(
org
|
com
)
[
^
|
]
*
/
gi
DEFAULT
)
;
if
(
updated
!
=
value
)
{
if
(
updated
=
=
DEFAULT
)
{
HomePage
.
reset
(
)
;
}
else
{
value
=
updated
;
HomePage
.
safeSet
(
value
)
;
}
}
}
}
if
(
currentUIVersion
<
82
)
{
this
.
_migrateXULStoreForDocument
(
"
chrome
:
/
/
browser
/
content
/
browser
.
xul
"
"
chrome
:
/
/
browser
/
content
/
browser
.
xhtml
"
)
;
}
if
(
currentUIVersion
<
83
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
search
.
reset
.
status
"
)
;
}
if
(
currentUIVersion
<
84
)
{
const
{
EXPIRE_NEVER
EXPIRE_TIME
}
=
Services
.
perms
;
let
flashPermissions
=
Services
.
perms
.
getAllWithTypePrefix
(
"
plugin
:
flash
"
)
.
filter
(
p
=
>
p
.
type
=
=
"
plugin
:
flash
"
&
&
(
p
.
expireType
=
=
EXPIRE_NEVER
|
|
p
.
expireType
=
=
EXPIRE_TIME
)
)
;
flashPermissions
.
forEach
(
p
=
>
Services
.
perms
.
removePermission
(
p
)
)
;
}
if
(
currentUIVersion
<
86
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
"
media
.
autoplay
.
allow
-
muted
"
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
media
.
autoplay
.
allow
-
muted
"
)
&
&
!
Services
.
prefs
.
prefHasUserValue
(
"
media
.
autoplay
.
default
"
)
&
&
Services
.
prefs
.
getIntPref
(
"
media
.
autoplay
.
default
"
)
=
=
Ci
.
nsIAutoplay
.
BLOCKED
)
{
Services
.
prefs
.
setIntPref
(
"
media
.
autoplay
.
default
"
Ci
.
nsIAutoplay
.
BLOCKED_ALL
)
;
}
Services
.
prefs
.
clearUserPref
(
"
media
.
autoplay
.
allow
-
muted
"
)
;
}
if
(
currentUIVersion
<
87
)
{
const
TRACKING_TABLE_PREF
=
"
urlclassifier
.
trackingTable
"
;
const
CUSTOM_BLOCKING_PREF
=
"
browser
.
contentblocking
.
customBlockList
.
preferences
.
ui
.
enabled
"
;
if
(
Services
.
prefs
.
prefHasUserValue
(
TRACKING_TABLE_PREF
)
)
{
Services
.
prefs
.
setBoolPref
(
CUSTOM_BLOCKING_PREF
true
)
;
}
}
if
(
currentUIVersion
<
88
)
{
let
category_prefs
=
[
"
network
.
cookie
.
cookieBehavior
"
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
"
privacy
.
trackingprotection
.
enabled
"
"
privacy
.
trackingprotection
.
socialtracking
.
enabled
"
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
]
;
if
(
Services
.
prefs
.
getStringPref
(
"
browser
.
contentblocking
.
category
"
"
standard
"
)
=
=
"
custom
"
)
{
let
shouldMigrate
=
true
;
for
(
let
pref
of
category_prefs
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
pref
)
)
{
shouldMigrate
=
false
;
}
}
if
(
shouldMigrate
)
{
Services
.
prefs
.
setStringPref
(
"
browser
.
contentblocking
.
category
"
"
standard
"
)
;
}
}
}
if
(
currentUIVersion
<
89
)
{
this
.
_migrateXULStoreForDocument
(
"
chrome
:
/
/
devtools
/
content
/
framework
/
toolbox
-
window
.
xul
"
"
chrome
:
/
/
devtools
/
content
/
framework
/
toolbox
-
window
.
xhtml
"
)
;
}
if
(
currentUIVersion
<
90
)
{
this
.
_migrateXULStoreForDocument
(
"
chrome
:
/
/
browser
/
content
/
places
/
historySidebar
.
xul
"
"
chrome
:
/
/
browser
/
content
/
places
/
historySidebar
.
xhtml
"
)
;
this
.
_migrateXULStoreForDocument
(
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xul
"
"
chrome
:
/
/
browser
/
content
/
places
/
places
.
xhtml
"
)
;
this
.
_migrateXULStoreForDocument
(
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarksSidebar
.
xul
"
"
chrome
:
/
/
browser
/
content
/
places
/
bookmarksSidebar
.
xhtml
"
)
;
}
if
(
currentUIVersion
<
91
&
&
Services
.
prefs
.
getBoolPref
(
"
network
.
proxy
.
share_proxy_settings
"
false
)
&
&
Services
.
prefs
.
getIntPref
(
"
network
.
proxy
.
type
"
0
)
=
=
1
)
{
let
httpProxy
=
Services
.
prefs
.
getCharPref
(
"
network
.
proxy
.
http
"
"
"
)
;
let
httpPort
=
Services
.
prefs
.
getIntPref
(
"
network
.
proxy
.
http_port
"
0
)
;
let
socksProxy
=
Services
.
prefs
.
getCharPref
(
"
network
.
proxy
.
socks
"
"
"
)
;
let
socksPort
=
Services
.
prefs
.
getIntPref
(
"
network
.
proxy
.
socks_port
"
0
)
;
if
(
httpProxy
&
&
httpProxy
=
=
socksProxy
&
&
httpPort
=
=
socksPort
)
{
Services
.
prefs
.
setCharPref
(
"
network
.
proxy
.
socks
"
Services
.
prefs
.
getCharPref
(
"
network
.
proxy
.
backup
.
socks
"
"
"
)
)
;
Services
.
prefs
.
setIntPref
(
"
network
.
proxy
.
socks_port
"
Services
.
prefs
.
getIntPref
(
"
network
.
proxy
.
backup
.
socks_port
"
0
)
)
;
}
}
if
(
currentUIVersion
<
92
)
{
let
longpress
=
Services
.
prefs
.
getIntPref
(
"
privacy
.
userContext
.
longPressBehavior
"
0
)
;
if
(
longpress
=
=
1
)
{
Services
.
prefs
.
setBoolPref
(
"
privacy
.
userContext
.
newTabContainerOnLeftClick
.
enabled
"
true
)
;
}
}
if
(
currentUIVersion
<
93
)
{
function
enableProfilerButton
(
wasAddonActive
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
performance
.
popup
.
feature
-
flag
"
true
)
;
if
(
wasAddonActive
)
{
const
{
ProfilerMenuButton
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
menu
-
button
.
jsm
.
js
"
)
;
if
(
!
ProfilerMenuButton
.
isInNavbar
(
)
)
{
const
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
win
&
&
win
.
document
)
{
ProfilerMenuButton
.
addToNavbar
(
win
.
document
)
;
}
}
}
}
let
addonPromise
;
try
{
addonPromise
=
AddonManager
.
getAddonByID
(
"
geckoprofiler
mozilla
.
com
"
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
"
Could
not
access
the
AddonManager
to
upgrade
the
profile
.
This
is
most
"
+
"
likely
because
the
upgrader
is
being
run
from
an
xpcshell
test
where
"
+
"
the
AddonManager
is
not
initialized
.
"
)
;
}
Promise
.
resolve
(
addonPromise
)
.
then
(
addon
=
>
{
if
(
!
addon
)
{
return
;
}
const
wasAddonActive
=
addon
.
isActive
;
addon
.
uninstall
(
)
.
catch
(
Cu
.
reportError
)
.
then
(
(
)
=
>
enableProfilerButton
(
wasAddonActive
)
)
.
catch
(
Cu
.
reportError
)
;
}
Cu
.
reportError
)
;
}
if
(
currentUIVersion
<
94
)
{
let
backup
=
Services
.
prefs
.
getCharPref
(
"
network
.
proxy
.
backup
.
socks
"
"
"
)
;
let
backupPort
=
Services
.
prefs
.
getIntPref
(
"
network
.
proxy
.
backup
.
socks_port
"
0
)
;
let
socksProxy
=
Services
.
prefs
.
getCharPref
(
"
network
.
proxy
.
socks
"
"
"
)
;
let
socksPort
=
Services
.
prefs
.
getIntPref
(
"
network
.
proxy
.
socks_port
"
0
)
;
if
(
backup
=
=
socksProxy
)
{
Services
.
prefs
.
clearUserPref
(
"
network
.
proxy
.
backup
.
socks
"
)
;
}
if
(
backupPort
=
=
socksPort
)
{
Services
.
prefs
.
clearUserPref
(
"
network
.
proxy
.
backup
.
socks_port
"
)
;
}
}
Services
.
prefs
.
setIntPref
(
"
browser
.
migration
.
version
"
UI_VERSION
)
;
}
_maybeShowDefaultBrowserPrompt
(
)
{
DefaultBrowserCheck
.
willCheckDefaultBrowser
(
true
)
.
then
(
willPrompt
=
>
{
if
(
!
willPrompt
)
{
return
;
}
DefaultBrowserCheck
.
prompt
(
BrowserWindowTracker
.
getTopWindow
(
)
)
;
}
)
;
}
async
_migrateMatchBucketsPrefForUI66
(
)
{
await
new
Promise
(
resolve
=
>
{
if
(
this
.
_shieldInitComplete
)
{
resolve
(
)
;
return
;
}
let
topic
=
"
shield
-
init
-
complete
"
;
Services
.
obs
.
addObserver
(
function
obs
(
)
{
Services
.
obs
.
removeObserver
(
obs
topic
)
;
resolve
(
)
;
}
topic
)
;
}
)
;
let
prefName
=
"
browser
.
urlbar
.
matchBuckets
"
;
let
prefValue
=
Services
.
prefs
.
getCharPref
(
prefName
"
"
)
;
let
experiment
=
null
;
let
experimentName
=
"
pref
-
flip
-
search
-
composition
-
57
-
release
-
1413565
"
;
let
{
PreferenceExperiments
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
PreferenceExperiments
.
jsm
"
)
;
try
{
experiment
=
await
PreferenceExperiments
.
get
(
experimentName
)
;
}
catch
(
e
)
{
}
if
(
experiment
&
&
!
experiment
.
expired
)
{
await
PreferenceExperiments
.
stop
(
experimentName
{
resetValue
:
true
reason
:
"
external
:
search
-
ui
-
migration
"
}
)
;
}
if
(
Services
.
prefs
.
getCharPref
(
prefName
"
"
)
)
{
return
;
}
if
(
prefValue
)
{
let
buckets
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
prefValue
)
;
if
(
ObjectUtils
.
deepEqual
(
buckets
[
[
"
suggestion
"
4
]
[
"
general
"
5
]
]
)
)
{
return
;
}
}
prefValue
=
prefValue
|
|
"
general
:
5
suggestion
:
Infinity
"
;
Services
.
prefs
.
setCharPref
(
prefName
prefValue
)
;
}
_openPreferences
(
.
.
.
args
)
{
let
chromeWindow
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
chromeWindow
)
{
chromeWindow
.
openPreferences
(
.
.
.
args
)
;
return
;
}
if
(
Services
.
appShell
.
hiddenDOMWindow
.
openPreferences
)
{
Services
.
appShell
.
hiddenDOMWindow
.
openPreferences
(
.
.
.
args
)
;
}
}
_openURLInNewWindow
(
url
)
{
let
urlString
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
urlString
.
data
=
url
;
return
new
Promise
(
resolve
=
>
{
let
win
=
Services
.
ww
.
openWindow
(
null
AppConstants
.
BROWSER_CHROME_URL
"
_blank
"
"
chrome
all
dialog
=
no
"
urlString
)
;
win
.
addEventListener
(
"
load
"
(
)
=
>
{
resolve
(
win
)
;
}
{
once
:
true
}
)
;
}
)
;
}
async
_onDisplaySyncURIs
(
data
)
{
try
{
const
URIs
=
data
.
wrappedJSObject
.
object
;
let
win
=
BrowserWindowTracker
.
getTopWindow
(
{
private
:
false
}
)
;
const
openTab
=
async
URI
=
>
{
let
tab
;
if
(
!
win
)
{
win
=
await
this
.
_openURLInNewWindow
(
URI
.
uri
)
;
let
tabs
=
win
.
gBrowser
.
tabs
;
tab
=
tabs
[
tabs
.
length
-
1
]
;
}
else
{
tab
=
win
.
gBrowser
.
addWebTab
(
URI
.
uri
)
;
}
tab
.
setAttribute
(
"
attention
"
true
)
;
return
tab
;
}
;
const
firstTab
=
await
openTab
(
URIs
[
0
]
)
;
await
Promise
.
all
(
URIs
.
slice
(
1
)
.
map
(
URI
=
>
openTab
(
URI
)
)
)
;
const
deviceName
=
URIs
[
0
]
.
sender
&
&
URIs
[
0
]
.
sender
.
name
;
let
title
body
;
const
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
accounts
.
properties
"
)
;
if
(
URIs
.
length
=
=
1
)
{
if
(
deviceName
)
{
title
=
bundle
.
formatStringFromName
(
"
tabArrivingNotificationWithDevice
.
title
"
[
deviceName
]
)
;
}
else
{
title
=
bundle
.
GetStringFromName
(
"
tabArrivingNotification
.
title
"
)
;
}
body
=
URIs
[
0
]
.
uri
.
replace
(
/
(
[
?
#
]
)
.
*
/
"
1
"
)
;
let
wasTruncated
=
body
.
length
<
URIs
[
0
]
.
uri
.
length
;
body
=
BrowserUtils
.
trimURL
(
body
)
;
if
(
wasTruncated
)
{
body
=
bundle
.
formatStringFromName
(
"
singleTabArrivingWithTruncatedURL
.
body
"
[
body
]
)
;
}
}
else
{
title
=
bundle
.
GetStringFromName
(
"
multipleTabsArrivingNotification
.
title
"
)
;
const
allKnownSender
=
URIs
.
every
(
URI
=
>
URI
.
sender
!
=
null
)
;
const
allSameDevice
=
allKnownSender
&
&
URIs
.
every
(
URI
=
>
URI
.
sender
.
id
=
=
URIs
[
0
]
.
sender
.
id
)
;
let
tabArrivingBody
;
if
(
allSameDevice
)
{
if
(
deviceName
)
{
tabArrivingBody
=
"
unnamedTabsArrivingNotification2
.
body
"
;
}
else
{
tabArrivingBody
=
"
unnamedTabsArrivingNotificationNoDevice
.
body
"
;
}
}
else
{
tabArrivingBody
=
"
unnamedTabsArrivingNotificationMultiple2
.
body
"
;
}
body
=
bundle
.
GetStringFromName
(
tabArrivingBody
)
;
body
=
PluralForm
.
get
(
URIs
.
length
body
)
;
body
=
body
.
replace
(
"
#
1
"
URIs
.
length
)
;
body
=
body
.
replace
(
"
#
2
"
deviceName
)
;
}
const
clickCallback
=
(
obsSubject
obsTopic
obsData
)
=
>
{
if
(
obsTopic
=
=
"
alertclickcallback
"
)
{
win
.
gBrowser
.
selectedTab
=
firstTab
;
}
}
;
let
imageURL
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
imageURL
=
"
chrome
:
/
/
branding
/
content
/
icon64
.
png
"
;
}
this
.
AlertsService
.
showAlertNotification
(
imageURL
title
body
true
null
clickCallback
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Error
displaying
tab
(
s
)
received
by
Sync
:
"
+
ex
)
;
}
}
async
_onVerifyLoginNotification
(
{
body
title
url
}
)
{
let
tab
;
let
imageURL
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
imageURL
=
"
chrome
:
/
/
branding
/
content
/
icon64
.
png
"
;
}
let
win
=
BrowserWindowTracker
.
getTopWindow
(
{
private
:
false
}
)
;
if
(
!
win
)
{
win
=
await
this
.
_openURLInNewWindow
(
url
)
;
let
tabs
=
win
.
gBrowser
.
tabs
;
tab
=
tabs
[
tabs
.
length
-
1
]
;
}
else
{
tab
=
win
.
gBrowser
.
addWebTab
(
url
)
;
}
tab
.
setAttribute
(
"
attention
"
true
)
;
let
clickCallback
=
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
"
alertclickcallback
"
)
{
return
;
}
win
.
gBrowser
.
selectedTab
=
tab
;
}
;
try
{
this
.
AlertsService
.
showAlertNotification
(
imageURL
title
body
true
null
clickCallback
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Error
notifying
of
a
verify
login
event
:
"
+
ex
)
;
}
}
_onDeviceConnected
(
deviceName
)
{
let
accountsBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
accounts
.
properties
"
)
;
let
title
=
accountsBundle
.
GetStringFromName
(
"
deviceConnDisconnTitle
"
)
;
let
body
=
accountsBundle
.
formatStringFromName
(
"
otherDeviceConnectedBody
"
+
(
deviceName
?
"
"
:
"
.
noDeviceName
"
)
[
deviceName
]
)
;
let
clickCallback
=
async
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
"
alertclickcallback
"
)
{
return
;
}
let
url
=
await
FxAccounts
.
config
.
promiseManageDevicesURI
(
"
device
-
connected
-
notification
"
)
;
let
win
=
BrowserWindowTracker
.
getTopWindow
(
{
private
:
false
}
)
;
if
(
!
win
)
{
this
.
_openURLInNewWindow
(
url
)
;
}
else
{
win
.
gBrowser
.
addWebTab
(
url
)
;
}
}
;
try
{
this
.
AlertsService
.
showAlertNotification
(
null
title
body
true
null
clickCallback
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Error
notifying
of
a
new
Sync
device
:
"
+
ex
)
;
}
}
_onDeviceDisconnected
(
)
{
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
accounts
.
properties
"
)
;
let
title
=
bundle
.
GetStringFromName
(
"
deviceConnDisconnTitle
"
)
;
let
body
=
bundle
.
GetStringFromName
(
"
thisDeviceDisconnectedBody
"
)
;
let
clickCallback
=
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
"
alertclickcallback
"
)
{
return
;
}
this
.
_openPreferences
(
"
sync
"
)
;
}
;
this
.
AlertsService
.
showAlertNotification
(
null
title
body
true
null
clickCallback
)
;
}
_handleFlashHang
(
)
{
+
+
this
.
_flashHangCount
;
if
(
this
.
_flashHangCount
<
2
)
{
return
;
}
if
(
Services
.
appinfo
.
XPCOMABI
!
=
"
x86
-
msvc
"
)
{
return
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
dom
.
ipc
.
plugins
.
flash
.
disable
-
protected
-
mode
"
)
)
{
return
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
flash
-
protected
-
mode
-
flip
.
enable
"
)
)
{
return
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
flash
-
protected
-
mode
-
flip
.
done
"
)
)
{
return
;
}
Services
.
prefs
.
setBoolPref
(
"
dom
.
ipc
.
plugins
.
flash
.
disable
-
protected
-
mode
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
flash
-
protected
-
mode
-
flip
.
done
"
true
)
;
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
win
)
{
return
;
}
let
productName
=
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
message
=
win
.
gNavigatorBundle
.
getFormattedString
(
"
flashHang
.
message
"
[
productName
]
)
;
let
buttons
=
[
{
label
:
win
.
gNavigatorBundle
.
getString
(
"
flashHang
.
helpButton
.
label
"
)
accessKey
:
win
.
gNavigatorBundle
.
getString
(
"
flashHang
.
helpButton
.
accesskey
"
)
callback
(
)
{
win
.
openTrustedLinkIn
(
"
https
:
/
/
support
.
mozilla
.
org
/
kb
/
flash
-
protected
-
mode
-
autodisabled
"
"
tab
"
)
;
}
}
]
;
win
.
gNotificationBox
.
appendNotification
(
message
"
flash
-
hang
"
null
win
.
gNotificationBox
.
PRIORITY_INFO_MEDIUM
buttons
)
;
}
_updateFxaBadges
(
)
{
let
state
=
UIState
.
get
(
)
;
if
(
state
.
status
=
=
UIState
.
STATUS_LOGIN_FAILED
|
|
state
.
status
=
=
UIState
.
STATUS_NOT_VERIFIED
)
{
AppMenuNotifications
.
showBadgeOnlyNotification
(
"
fxa
-
needs
-
authentication
"
)
;
}
else
{
AppMenuNotifications
.
removeNotification
(
"
fxa
-
needs
-
authentication
"
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
var
ContentBlockingCategoriesPrefs
=
{
PREF_CB_CATEGORY
:
"
browser
.
contentblocking
.
category
"
PREF_STRICT_DEF
:
"
browser
.
contentblocking
.
features
.
strict
"
switchingCategory
:
false
setPrefExpectations
(
)
{
this
.
CATEGORY_PREFS
=
{
strict
:
{
"
network
.
cookie
.
cookieBehavior
"
:
null
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
:
null
"
privacy
.
trackingprotection
.
enabled
"
:
null
"
privacy
.
trackingprotection
.
socialtracking
.
enabled
"
:
null
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
:
null
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
:
null
}
standard
:
{
"
network
.
cookie
.
cookieBehavior
"
:
null
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
:
null
"
privacy
.
trackingprotection
.
enabled
"
:
null
"
privacy
.
trackingprotection
.
socialtracking
.
enabled
"
:
null
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
:
null
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
:
null
}
}
;
let
type
=
"
strict
"
;
let
rulesArray
=
Services
.
prefs
.
getStringPref
(
this
.
PREF_STRICT_DEF
)
.
split
(
"
"
)
;
for
(
let
item
of
rulesArray
)
{
switch
(
item
)
{
case
"
tp
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
enabled
"
]
=
true
;
break
;
case
"
-
tp
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
enabled
"
]
=
false
;
break
;
case
"
tpPrivate
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
]
=
true
;
break
;
case
"
-
tpPrivate
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
]
=
false
;
break
;
case
"
fp
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
]
=
true
;
break
;
case
"
-
fp
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
fingerprinting
.
enabled
"
]
=
false
;
break
;
case
"
cm
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
]
=
true
;
break
;
case
"
-
cm
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
cryptomining
.
enabled
"
]
=
false
;
break
;
case
"
stp
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
socialtracking
.
enabled
"
]
=
true
;
break
;
case
"
-
stp
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
privacy
.
trackingprotection
.
socialtracking
.
enabled
"
]
=
false
;
break
;
case
"
cookieBehavior0
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
network
.
cookie
.
cookieBehavior
"
]
=
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
;
break
;
case
"
cookieBehavior1
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
network
.
cookie
.
cookieBehavior
"
]
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
;
break
;
case
"
cookieBehavior2
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
network
.
cookie
.
cookieBehavior
"
]
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT
;
break
;
case
"
cookieBehavior3
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
network
.
cookie
.
cookieBehavior
"
]
=
Ci
.
nsICookieService
.
BEHAVIOR_LIMIT_FOREIGN
;
break
;
case
"
cookieBehavior4
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
network
.
cookie
.
cookieBehavior
"
]
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
;
break
;
case
"
cookieBehavior5
"
:
this
.
CATEGORY_PREFS
[
type
]
[
"
network
.
cookie
.
cookieBehavior
"
]
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
;
break
;
default
:
Cu
.
reportError
(
Error
:
Unknown
rule
observed
{
item
}
)
;
}
}
}
prefsMatch
(
category
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
this
.
PREF_CB_CATEGORY
)
&
&
Services
.
prefs
.
getStringPref
(
this
.
PREF_CB_CATEGORY
)
!
=
category
)
{
return
false
;
}
for
(
let
pref
in
this
.
CATEGORY_PREFS
[
category
]
)
{
let
value
=
this
.
CATEGORY_PREFS
[
category
]
[
pref
]
;
if
(
value
=
=
null
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
pref
)
)
{
return
false
;
}
}
else
{
let
prefType
=
Services
.
prefs
.
getPrefType
(
pref
)
;
if
(
(
prefType
=
=
Services
.
prefs
.
PREF_BOOL
&
&
Services
.
prefs
.
getBoolPref
(
pref
)
!
=
value
)
|
|
(
prefType
=
=
Services
.
prefs
.
PREF_INT
&
&
Services
.
prefs
.
getIntPref
(
pref
)
!
=
value
)
|
|
(
prefType
=
=
Services
.
prefs
.
PREF_STRING
&
&
Services
.
prefs
.
getStringPref
(
pref
)
!
=
value
)
)
{
return
false
;
}
}
}
return
true
;
}
matchCBCategory
(
)
{
if
(
this
.
switchingCategory
)
{
return
;
}
if
(
this
.
prefsMatch
(
"
standard
"
)
)
{
Services
.
prefs
.
setStringPref
(
this
.
PREF_CB_CATEGORY
"
standard
"
)
;
}
else
if
(
this
.
prefsMatch
(
"
strict
"
)
)
{
Services
.
prefs
.
setStringPref
(
this
.
PREF_CB_CATEGORY
"
strict
"
)
;
}
else
{
Services
.
prefs
.
setStringPref
(
this
.
PREF_CB_CATEGORY
"
custom
"
)
;
}
let
policy
=
Services
.
policies
.
getActivePolicies
(
)
;
if
(
policy
&
&
(
policy
.
EnableTrackingProtection
|
|
policy
.
Cookies
)
)
{
Services
.
prefs
.
setStringPref
(
this
.
PREF_CB_CATEGORY
"
custom
"
)
;
}
}
updateCBCategory
(
)
{
if
(
this
.
switchingCategory
|
|
!
Services
.
prefs
.
prefHasUserValue
(
this
.
PREF_CB_CATEGORY
)
)
{
return
;
}
this
.
switchingCategory
=
true
;
let
value
=
Services
.
prefs
.
getStringPref
(
this
.
PREF_CB_CATEGORY
)
;
this
.
setPrefsToCategory
(
value
)
;
this
.
switchingCategory
=
false
;
}
setPrefsToCategory
(
category
)
{
if
(
category
=
=
"
custom
"
)
{
return
;
}
for
(
let
pref
in
this
.
CATEGORY_PREFS
[
category
]
)
{
let
value
=
this
.
CATEGORY_PREFS
[
category
]
[
pref
]
;
if
(
!
Services
.
prefs
.
prefIsLocked
(
pref
)
)
{
if
(
value
=
=
null
)
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
else
{
switch
(
Services
.
prefs
.
getPrefType
(
pref
)
)
{
case
Services
.
prefs
.
PREF_BOOL
:
Services
.
prefs
.
setBoolPref
(
pref
value
)
;
break
;
case
Services
.
prefs
.
PREF_INT
:
Services
.
prefs
.
setIntPref
(
pref
value
)
;
break
;
case
Services
.
prefs
.
PREF_STRING
:
Services
.
prefs
.
setStringPref
(
pref
value
)
;
break
;
}
}
}
}
}
}
;
const
ContentPermissionIntegration
=
{
createPermissionPrompt
(
type
request
)
{
switch
(
type
)
{
case
"
geolocation
"
:
{
return
new
PermissionUI
.
GeolocationPermissionPrompt
(
request
)
;
}
case
"
xr
"
:
{
return
new
PermissionUI
.
XRPermissionPrompt
(
request
)
;
}
case
"
desktop
-
notification
"
:
{
return
new
PermissionUI
.
DesktopNotificationPermissionPrompt
(
request
)
;
}
case
"
persistent
-
storage
"
:
{
return
new
PermissionUI
.
PersistentStoragePermissionPrompt
(
request
)
;
}
case
"
midi
"
:
{
return
new
PermissionUI
.
MIDIPermissionPrompt
(
request
)
;
}
case
"
storage
-
access
"
:
{
return
new
PermissionUI
.
StorageAccessPermissionPrompt
(
request
)
;
}
}
return
undefined
;
}
}
;
function
ContentPermissionPrompt
(
)
{
}
ContentPermissionPrompt
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
d8903bf6
-
68d5
-
4e97
-
bcd1
-
e4d3012f721a
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIContentPermissionPrompt
]
)
prompt
(
request
)
{
if
(
request
.
element
&
&
request
.
element
.
fxrPermissionPrompt
)
{
request
.
element
.
fxrPermissionPrompt
(
request
)
;
return
;
}
let
type
;
try
{
let
types
=
request
.
types
.
QueryInterface
(
Ci
.
nsIArray
)
;
if
(
types
.
length
!
=
1
)
{
throw
Components
.
Exception
(
"
Expected
an
nsIContentPermissionRequest
with
only
1
type
.
"
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
type
=
types
.
queryElementAt
(
0
Ci
.
nsIContentPermissionType
)
.
type
;
let
combinedIntegration
=
Integration
.
contentPermission
.
getCombined
(
ContentPermissionIntegration
)
;
let
permissionPrompt
=
combinedIntegration
.
createPermissionPrompt
(
type
request
)
;
if
(
!
permissionPrompt
)
{
throw
Components
.
Exception
(
Failed
to
handle
permission
of
type
{
type
}
Cr
.
NS_ERROR_FAILURE
)
;
}
permissionPrompt
.
prompt
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
request
.
cancel
(
)
;
throw
ex
;
}
let
schemeHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
PERMISSION_REQUEST_ORIGIN_SCHEME
"
)
;
let
scheme
=
0
;
try
{
if
(
request
.
principal
.
schemeIs
(
"
http
"
)
)
{
scheme
=
1
;
}
else
if
(
request
.
principal
.
schemeIs
(
"
https
"
)
)
{
scheme
=
2
;
}
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_FAILURE
)
{
Cu
.
reportError
(
ex
)
;
}
return
;
}
schemeHistogram
.
add
(
type
scheme
)
;
let
userInputHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
"
PERMISSION_REQUEST_HANDLING_USER_INPUT
"
)
;
userInputHistogram
.
add
(
type
request
.
isHandlingUserInput
)
;
}
}
;
var
DefaultBrowserCheck
=
{
get
OPTIONPOPUP
(
)
{
return
"
defaultBrowserNotificationPopup
"
;
}
closePrompt
(
aNode
)
{
if
(
this
.
_notification
)
{
this
.
_notification
.
close
(
)
;
}
}
setAsDefault
(
)
{
let
claimAllTypes
=
true
;
let
setAsDefaultError
=
false
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
try
{
let
version
=
Services
.
sysinfo
.
getProperty
(
"
version
"
)
;
claimAllTypes
=
parseFloat
(
version
)
<
6
.
2
;
}
catch
(
ex
)
{
}
}
try
{
ShellService
.
setDefaultBrowser
(
claimAllTypes
false
)
;
}
catch
(
ex
)
{
setAsDefaultError
=
true
;
Cu
.
reportError
(
ex
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_IS_USER_DEFAULT
"
)
.
add
(
!
setAsDefaultError
)
;
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_SET_DEFAULT_ERROR
"
)
.
add
(
setAsDefaultError
)
;
}
_createPopup
(
win
notNowStrings
neverStrings
)
{
let
doc
=
win
.
document
;
let
popup
=
doc
.
createXULElement
(
"
menupopup
"
)
;
popup
.
id
=
this
.
OPTIONPOPUP
;
let
notNowItem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
notNowItem
.
id
=
"
defaultBrowserNotNow
"
;
notNowItem
.
setAttribute
(
"
label
"
notNowStrings
.
label
)
;
notNowItem
.
setAttribute
(
"
accesskey
"
notNowStrings
.
accesskey
)
;
popup
.
appendChild
(
notNowItem
)
;
let
neverItem
=
doc
.
createXULElement
(
"
menuitem
"
)
;
neverItem
.
id
=
"
defaultBrowserNever
"
;
neverItem
.
setAttribute
(
"
label
"
neverStrings
.
label
)
;
neverItem
.
setAttribute
(
"
accesskey
"
neverStrings
.
accesskey
)
;
popup
.
appendChild
(
neverItem
)
;
popup
.
addEventListener
(
"
command
"
this
)
;
let
popupset
=
doc
.
getElementById
(
"
mainPopupSet
"
)
;
popupset
.
appendChild
(
popup
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
command
"
)
{
if
(
event
.
target
.
id
=
=
"
defaultBrowserNever
"
)
{
ShellService
.
shouldCheckDefaultBrowser
=
false
;
}
this
.
closePrompt
(
)
;
}
}
prompt
(
win
)
{
let
useNotificationBar
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
defaultbrowser
.
notificationbar
"
)
;
let
brandBundle
=
win
.
document
.
getElementById
(
"
bundle_brand
"
)
;
let
brandShortName
=
brandBundle
.
getString
(
"
brandShortName
"
)
;
let
shellBundle
=
win
.
document
.
getElementById
(
"
bundle_shell
"
)
;
let
buttonPrefix
=
"
setDefaultBrowser
"
+
(
useNotificationBar
?
"
"
:
"
Alert
"
)
;
let
yesButton
=
shellBundle
.
getFormattedString
(
buttonPrefix
+
"
Confirm
.
label
"
[
brandShortName
]
)
;
let
notNowButton
=
shellBundle
.
getString
(
buttonPrefix
+
"
NotNow
.
label
"
)
;
if
(
useNotificationBar
)
{
let
promptMessage
=
shellBundle
.
getFormattedString
(
"
setDefaultBrowserMessage2
"
[
brandShortName
]
)
;
let
optionsMessage
=
shellBundle
.
getString
(
"
setDefaultBrowserOptions
.
label
"
)
;
let
optionsKey
=
shellBundle
.
getString
(
"
setDefaultBrowserOptions
.
accesskey
"
)
;
let
neverLabel
=
shellBundle
.
getString
(
"
setDefaultBrowserNever
.
label
"
)
;
let
neverKey
=
shellBundle
.
getString
(
"
setDefaultBrowserNever
.
accesskey
"
)
;
let
yesButtonKey
=
shellBundle
.
getString
(
"
setDefaultBrowserConfirm
.
accesskey
"
)
;
let
notNowButtonKey
=
shellBundle
.
getString
(
"
setDefaultBrowserNotNow
.
accesskey
"
)
;
this
.
_createPopup
(
win
{
label
:
notNowButton
accesskey
:
notNowButtonKey
}
{
label
:
neverLabel
accesskey
:
neverKey
}
)
;
let
buttons
=
[
{
label
:
yesButton
accessKey
:
yesButtonKey
callback
:
(
)
=
>
{
this
.
setAsDefault
(
)
;
this
.
closePrompt
(
)
;
}
}
{
label
:
optionsMessage
accessKey
:
optionsKey
popup
:
this
.
OPTIONPOPUP
}
]
;
let
iconPixels
=
win
.
devicePixelRatio
>
1
?
"
32
"
:
"
16
"
;
let
iconURL
=
"
chrome
:
/
/
branding
/
content
/
icon
"
+
iconPixels
+
"
.
png
"
;
const
priority
=
win
.
gHighPriorityNotificationBox
.
PRIORITY_WARNING_HIGH
;
let
callback
=
this
.
_onNotificationEvent
.
bind
(
this
)
;
this
.
_notification
=
win
.
gHighPriorityNotificationBox
.
appendNotification
(
promptMessage
"
default
-
browser
"
iconURL
priority
buttons
callback
)
;
}
else
{
let
promptTitle
=
shellBundle
.
getString
(
"
setDefaultBrowserTitle
"
)
;
let
promptMessage
=
shellBundle
.
getFormattedString
(
"
setDefaultBrowserMessage
"
[
brandShortName
]
)
;
let
askLabel
=
shellBundle
.
getFormattedString
(
"
setDefaultBrowserDontAsk
"
[
brandShortName
]
)
;
let
ps
=
Services
.
prompt
;
let
shouldAsk
=
{
value
:
true
}
;
let
buttonFlags
=
ps
.
BUTTON_TITLE_IS_STRING
*
ps
.
BUTTON_POS_0
+
ps
.
BUTTON_TITLE_IS_STRING
*
ps
.
BUTTON_POS_1
+
ps
.
BUTTON_POS_0_DEFAULT
;
let
rv
=
ps
.
confirmEx
(
win
promptTitle
promptMessage
buttonFlags
yesButton
notNowButton
null
askLabel
shouldAsk
)
;
if
(
rv
=
=
0
)
{
this
.
setAsDefault
(
)
;
}
else
if
(
!
shouldAsk
.
value
)
{
ShellService
.
shouldCheckDefaultBrowser
=
false
;
}
try
{
let
resultEnum
=
rv
*
2
+
shouldAsk
.
value
;
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_SET_DEFAULT_RESULT
"
)
.
add
(
resultEnum
)
;
}
catch
(
ex
)
{
}
}
}
_onNotificationEvent
(
eventType
)
{
if
(
eventType
=
=
"
removed
"
)
{
let
doc
=
this
.
_notification
.
ownerDocument
;
let
popup
=
doc
.
getElementById
(
this
.
OPTIONPOPUP
)
;
popup
.
removeEventListener
(
"
command
"
this
)
;
popup
.
remove
(
)
;
delete
this
.
_notification
;
}
}
async
willCheckDefaultBrowser
(
isStartupCheck
)
{
if
(
!
ShellService
)
{
return
false
;
}
let
shouldCheck
=
!
AppConstants
.
DEBUG
&
&
ShellService
.
shouldCheckDefaultBrowser
;
if
(
!
shouldCheck
&
&
!
isStartupCheck
)
{
return
false
;
}
const
skipDefaultBrowserCheck
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
shell
.
skipDefaultBrowserCheckOnFirstRun
"
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
shell
.
didSkipDefaultBrowserCheckOnFirstRun
"
)
;
const
usePromptLimit
=
!
AppConstants
.
RELEASE_OR_BETA
;
let
promptCount
=
usePromptLimit
?
Services
.
prefs
.
getIntPref
(
"
browser
.
shell
.
defaultBrowserCheckCount
"
)
:
0
;
await
SessionStartup
.
onceInitialized
;
let
willRecoverSession
=
SessionStartup
.
sessionType
=
=
SessionStartup
.
RECOVER_SESSION
;
let
isDefault
=
false
;
let
isDefaultError
=
false
;
try
{
isDefault
=
ShellService
.
isDefaultBrowser
(
isStartupCheck
false
)
;
}
catch
(
ex
)
{
isDefaultError
=
true
;
}
if
(
isDefault
&
&
isStartupCheck
)
{
let
now
=
Math
.
floor
(
Date
.
now
(
)
/
1000
)
.
toString
(
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
shell
.
mostRecentDateSetAsDefault
"
now
)
;
}
let
willPrompt
=
shouldCheck
&
&
!
isDefault
&
&
!
willRecoverSession
;
if
(
willPrompt
)
{
if
(
skipDefaultBrowserCheck
)
{
if
(
isStartupCheck
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
shell
.
didSkipDefaultBrowserCheckOnFirstRun
"
true
)
;
}
willPrompt
=
false
;
}
if
(
usePromptLimit
)
{
promptCount
+
+
;
if
(
isStartupCheck
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
shell
.
defaultBrowserCheckCount
"
promptCount
)
;
}
if
(
promptCount
>
3
)
{
willPrompt
=
false
;
}
}
}
if
(
isStartupCheck
)
{
try
{
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_IS_USER_DEFAULT
"
)
.
add
(
isDefault
)
;
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_IS_USER_DEFAULT_ERROR
"
)
.
add
(
isDefaultError
)
;
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_SET_DEFAULT_ALWAYS_CHECK
"
)
.
add
(
shouldCheck
)
;
Services
.
telemetry
.
getHistogramById
(
"
BROWSER_SET_DEFAULT_DIALOG_PROMPT_RAWCOUNT
"
)
.
add
(
promptCount
)
;
}
catch
(
ex
)
{
}
}
return
willPrompt
;
}
}
;
var
JawsScreenReaderVersionCheck
=
{
_prompted
:
false
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
a11y
-
init
-
or
-
shutdown
"
true
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
a11y
-
init
-
or
-
shutdown
"
&
&
data
=
=
"
1
"
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
this
.
_checkVersionAndPrompt
(
)
)
;
}
}
onWindowsRestored
(
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
this
.
_checkVersionAndPrompt
(
)
)
;
}
_checkVersionAndPrompt
(
)
{
if
(
!
Services
.
appinfo
.
shouldBlockIncompatJaws
|
|
!
Services
.
appinfo
.
browserTabsRemoteAutostart
|
|
AppConstants
.
NIGHTLY_BUILD
)
{
return
;
}
let
win
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
win
|
|
!
win
.
gBrowser
|
|
!
win
.
gBrowser
.
selectedBrowser
)
{
Services
.
console
.
logStringMessage
(
"
Content
access
support
for
older
versions
of
JAWS
is
disabled
"
+
"
due
to
compatibility
issues
with
this
version
of
Firefox
.
"
)
;
this
.
_prompted
=
false
;
return
;
}
if
(
this
.
_prompted
)
{
return
;
}
this
.
_prompted
=
true
;
let
browser
=
win
.
gBrowser
.
selectedBrowser
;
let
promptMessage
=
win
.
gNavigatorBundle
.
getFormattedString
(
"
e10s
.
accessibilityNotice
.
jawsMessage
"
[
gBrandBundle
.
GetStringFromName
(
"
brandShortName
"
)
]
)
;
let
notification
;
let
mainAction
=
{
label
:
win
.
gNavigatorBundle
.
getString
(
"
e10s
.
accessibilityNotice
.
acceptButton
.
label
"
)
accessKey
:
win
.
gNavigatorBundle
.
getString
(
"
e10s
.
accessibilityNotice
.
acceptButton
.
accesskey
"
)
callback
(
)
{
notification
.
remove
(
)
;
}
}
;
let
options
=
{
popupIconURL
:
"
chrome
:
/
/
browser
/
skin
/
e10s
-
64
2x
.
png
"
persistWhileVisible
:
true
persistent
:
true
persistence
:
100
}
;
notification
=
win
.
PopupNotifications
.
show
(
browser
"
e10s_enabled_with_incompat_jaws
"
promptMessage
null
mainAction
null
options
)
;
}
}
;
var
AboutHomeStartupCache
=
{
ABOUT_HOME_URI_STRING
:
"
about
:
home
"
SCRIPT_EXTENSION
:
"
script
"
ENABLED_PREF
:
"
browser
.
startup
.
homepage
.
abouthome_cache
.
enabled
"
PRELOADED_NEWTAB_PREF
:
"
browser
.
newtab
.
preload
"
LOG_LEVEL_PREF
:
"
browser
.
startup
.
homepage
.
abouthome_cache
.
loglevel
"
CACHE_VERSION_META_KEY
:
"
version
"
CACHE_VERSION
:
1
LOG_NAME
:
"
AboutHomeStartupCache
"
CACHE_REQUEST_MESSAGE
:
"
AboutHomeStartupCache
:
CacheRequest
"
CACHE_RESPONSE_MESSAGE
:
"
AboutHomeStartupCache
:
CacheResponse
"
SEND_STREAMS_MESSAGE
:
"
AboutHomeStartupCache
:
InputStreams
"
CACHE_DEBOUNCE_RATE_MS
:
5000
_cacheEntry
:
null
_pagePipe
:
null
_scriptPipe
:
null
_cacheDeferred
:
null
_enabled
:
false
_initted
:
false
_hasWrittenThisSession
:
false
init
(
)
{
if
(
this
.
_initted
)
{
throw
new
Error
(
"
AboutHomeStartupCache
already
initted
.
"
)
;
}
this
.
_enabled
=
Services
.
prefs
.
getBoolPref
(
this
.
ENABLED_PREF
false
)
;
if
(
!
this
.
_enabled
)
{
return
;
}
this
.
log
=
Log
.
repository
.
getLogger
(
this
.
LOG_NAME
)
;
this
.
log
.
manageLevelFromPref
(
this
.
LOG_LEVEL_PREF
)
;
this
.
_appender
=
new
Log
.
ConsoleAppender
(
new
Log
.
BasicFormatter
(
)
)
;
this
.
log
.
addAppender
(
this
.
_appender
)
;
this
.
log
.
trace
(
"
Initting
.
"
)
;
let
willLoadAboutHome
=
!
HomePage
.
overridden
&
&
Services
.
prefs
.
getIntPref
(
"
browser
.
startup
.
page
"
)
=
=
=
1
;
if
(
!
willLoadAboutHome
)
{
this
.
log
.
trace
(
"
Not
configured
to
load
about
:
home
by
default
.
"
)
;
return
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
this
.
PRELOADED_NEWTAB_PREF
false
)
)
{
this
.
log
.
trace
(
"
Preloaded
about
:
newtab
disabled
.
"
)
;
return
;
}
Services
.
obs
.
addObserver
(
this
"
ipc
:
content
-
created
"
)
;
Services
.
obs
.
addObserver
(
this
"
ipc
:
content
-
shutdown
"
)
;
let
lci
=
Services
.
loadContextInfo
.
default
;
let
storage
=
Services
.
cache2
.
diskCacheStorage
(
lci
false
)
;
try
{
storage
.
asyncOpenURI
(
this
.
aboutHomeURI
"
"
Ci
.
nsICacheStorage
.
OPEN_PRIORITY
this
)
;
}
catch
(
e
)
{
this
.
log
.
error
(
"
Failed
to
open
about
:
home
cache
entry
"
e
)
;
}
this
.
_cacheTask
=
new
DeferredTask
(
async
(
)
=
>
{
await
this
.
cacheNow
(
)
;
}
this
.
CACHE_DEBOUNCE_RATE_MS
)
;
AsyncShutdown
.
quitApplicationGranted
.
addBlocker
(
"
AboutHomeStartupCache
:
Writing
cache
"
async
(
)
=
>
{
await
this
.
onShutdown
(
)
;
}
(
)
=
>
this
.
_cacheProgress
)
;
this
.
_cacheDeferred
=
null
;
this
.
_initted
=
true
;
this
.
log
.
trace
(
"
Initialized
.
"
)
;
}
uninit
(
)
{
if
(
!
this
.
_enabled
|
|
!
this
.
_initted
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
"
ipc
:
content
-
created
"
)
;
Services
.
obs
.
removeObserver
(
this
"
ipc
:
content
-
shutdown
"
)
;
if
(
this
.
_cacheTask
)
{
this
.
_cacheTask
.
disarm
(
)
;
this
.
_cacheTask
=
null
;
}
this
.
_pagePipe
=
null
;
this
.
_scriptPipe
=
null
;
this
.
_initted
=
false
;
this
.
_cacheEntry
=
null
;
this
.
_hasWrittenThisSession
=
false
;
this
.
log
.
trace
(
"
Uninitialized
.
"
)
;
this
.
log
.
removeAppender
(
this
.
_appender
)
;
this
.
log
=
null
;
this
.
_appender
=
null
;
this
.
_cacheDeferred
=
null
;
}
_aboutHomeURI
:
null
get
aboutHomeURI
(
)
{
if
(
this
.
_aboutHomeURI
)
{
return
this
.
_aboutHomeURI
;
}
this
.
_aboutHomeURI
=
Services
.
io
.
newURI
(
this
.
ABOUT_HOME_URI_STRING
)
;
return
this
.
_aboutHomeURI
;
}
_cacheProgress
:
"
Not
yet
begun
"
async
onShutdown
(
)
{
if
(
!
this
.
_hasWrittenThisSession
)
{
this
.
log
.
trace
(
"
Never
wrote
a
cache
this
session
.
Arming
cache
task
.
"
)
;
this
.
_cacheTask
.
arm
(
)
;
}
if
(
this
.
_cacheTask
.
isArmed
)
{
this
.
log
.
trace
(
"
Finalizing
cache
task
on
shutdown
"
)
;
await
this
.
_cacheTask
.
finalize
(
)
;
}
}
async
cacheNow
(
)
{
this
.
_hasWrittenThisSession
=
true
;
this
.
_cacheProgress
=
"
Getting
cache
streams
"
;
let
{
pageInputStream
scriptInputStream
}
=
await
this
.
requestCache
(
)
;
if
(
!
pageInputStream
|
|
!
scriptInputStream
)
{
this
.
_cacheProgress
=
"
Failed
to
get
streams
"
;
return
;
}
this
.
_cacheProgress
=
"
Writing
to
cache
"
;
await
this
.
populateCache
(
pageInputStream
scriptInputStream
)
;
this
.
_cacheProgress
=
"
Done
"
;
}
requestCache
(
)
{
this
.
log
.
trace
(
"
Parent
is
requesting
Activity
Stream
state
object
.
"
)
;
if
(
!
this
.
_procManager
)
{
this
.
log
.
error
(
"
requestCache
called
with
no
_procManager
!
"
)
;
return
{
pageInputStream
:
null
scriptInputStream
:
null
}
;
}
if
(
this
.
_procManager
.
remoteType
!
=
E10SUtils
.
PRIVILEGEDABOUT_REMOTE_TYPE
)
{
this
.
log
.
error
(
"
Somehow
got
the
wrong
process
type
.
"
)
;
return
{
pageInputStream
:
null
scriptInputStream
:
null
}
;
}
let
state
=
AboutNewTab
.
activityStream
.
store
.
getState
(
)
;
return
new
Promise
(
resolve
=
>
{
this
.
_cacheDeferred
=
resolve
;
this
.
log
.
trace
(
"
Parent
received
cache
streams
.
"
)
;
this
.
_procManager
.
sendAsyncMessage
(
this
.
CACHE_REQUEST_MESSAGE
{
state
}
)
;
}
)
;
}
makePipe
(
)
{
let
pipe
=
Cc
[
"
mozilla
.
org
/
pipe
;
1
"
]
.
createInstance
(
Ci
.
nsIPipe
)
;
pipe
.
init
(
true
true
0
0
)
;
return
pipe
;
}
makePipes
(
)
{
if
(
this
.
_pagePipe
&
&
this
.
_scriptPipe
)
{
return
;
}
this
.
log
.
trace
(
"
Constructing
pipes
.
"
)
;
this
.
_pagePipe
=
this
.
makePipe
(
)
;
this
.
_scriptPipe
=
this
.
makePipe
(
)
;
}
get
pagePipe
(
)
{
return
this
.
_pagePipe
;
}
get
scriptPipe
(
)
{
return
this
.
_scriptPipe
;
}
maybeConnectToPipes
(
)
{
if
(
!
this
.
_cacheEntry
)
{
this
.
log
.
trace
(
"
Not
connecting
to
pipes
yet
-
the
cache
entry
isn
'
t
available
yet
"
)
;
return
;
}
let
version
;
try
{
this
.
log
.
trace
(
"
"
)
;
version
=
this
.
_cacheEntry
.
getMetaDataElement
(
this
.
CACHE_VERSION_META_KEY
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
this
.
log
.
debug
(
"
Cache
meta
data
does
not
exist
.
Closing
streams
.
"
)
;
this
.
pagePipe
.
outputStream
.
close
(
)
;
this
.
scriptPipe
.
outputStream
.
close
(
)
;
return
;
}
throw
e
;
}
this
.
log
.
info
(
"
Version
retrieved
is
"
version
)
;
if
(
parseInt
(
version
10
)
!
=
this
.
CACHE_VERSION
)
{
this
.
log
.
info
(
"
Version
does
not
match
!
Dooming
and
closing
streams
.
\
n
"
)
;
this
.
_cacheEntry
=
this
.
_cacheEntry
.
recreate
(
)
;
this
.
pagePipe
.
outputStream
.
close
(
)
;
this
.
scriptPipe
.
outputStream
.
close
(
)
;
return
;
}
let
cachePageInputStream
;
try
{
cachePageInputStream
=
this
.
_cacheEntry
.
openInputStream
(
0
)
;
}
catch
(
e
)
{
this
.
log
.
error
(
"
Failed
to
open
main
input
stream
for
cache
entry
"
e
)
;
this
.
pagePipe
.
outputStream
.
close
(
)
;
this
.
scriptPipe
.
outputStream
.
close
(
)
;
return
;
}
this
.
log
.
trace
(
"
Connecting
page
stream
to
pipe
.
"
)
;
NetUtil
.
asyncCopy
(
cachePageInputStream
this
.
pagePipe
.
outputStream
(
)
=
>
{
this
.
log
.
info
(
"
Page
stream
connected
to
pipe
.
"
)
;
}
)
;
let
cacheScriptInputStream
;
try
{
this
.
log
.
trace
(
"
Connecting
script
stream
to
pipe
.
"
)
;
cacheScriptInputStream
=
this
.
_cacheEntry
.
openAlternativeInputStream
(
"
script
"
)
;
NetUtil
.
asyncCopy
(
cacheScriptInputStream
this
.
scriptPipe
.
outputStream
(
)
=
>
{
this
.
log
.
info
(
"
Script
stream
connected
to
pipe
.
"
)
;
}
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_AVAILABLE
)
{
this
.
log
.
error
(
"
Script
stream
not
available
!
Closing
pipe
.
"
)
;
this
.
scriptPipe
.
outputStream
.
close
(
)
;
}
else
{
throw
e
;
}
}
this
.
log
.
trace
(
"
Streams
connected
to
pipes
.
Dropping
references
to
pipes
.
"
)
;
this
.
_pagePipe
=
null
;
this
.
_scriptPipe
=
null
;
}
sendCacheInputStreams
(
aProcManager
)
{
if
(
aProcManager
.
remoteType
!
=
E10SUtils
.
PRIVILEGEDABOUT_REMOTE_TYPE
)
{
throw
new
Error
(
"
Cannot
send
about
:
home
cache
to
a
non
-
privileged
content
process
.
"
)
;
}
this
.
makePipes
(
)
;
this
.
log
.
info
(
"
Sending
input
streams
down
to
content
process
.
"
)
;
aProcManager
.
sendAsyncMessage
(
this
.
SEND_STREAMS_MESSAGE
{
pageInputStream
:
this
.
pagePipe
.
inputStream
scriptInputStream
:
this
.
scriptPipe
.
inputStream
}
)
;
if
(
this
.
_cacheEntry
)
{
this
.
log
.
trace
(
"
The
cache
entry
is
already
available
.
Connecting
to
pipes
"
+
"
immediately
.
"
)
;
this
.
maybeConnectToPipes
(
)
;
}
}
populateCache
(
pageInputStream
scriptInputStream
)
{
this
.
log
.
trace
(
"
Populating
the
cache
.
Dooming
old
entry
.
"
)
;
this
.
_cacheEntry
=
this
.
_cacheEntry
.
recreate
(
)
;
this
.
log
.
trace
(
"
Opening
the
page
output
stream
.
"
)
;
let
pageOutputStream
=
this
.
_cacheEntry
.
openOutputStream
(
0
-
1
)
;
this
.
log
.
info
(
"
Writing
the
page
cache
.
"
)
;
NetUtil
.
asyncCopy
(
pageInputStream
pageOutputStream
(
)
=
>
{
this
.
log
.
trace
(
"
Writing
the
page
data
is
complete
.
Now
opening
the
"
+
"
script
output
stream
.
"
)
;
let
scriptOutputStream
=
this
.
_cacheEntry
.
openAlternativeOutputStream
(
"
script
"
-
1
)
;
this
.
log
.
info
(
"
Writing
the
script
cache
.
"
)
;
NetUtil
.
asyncCopy
(
scriptInputStream
scriptOutputStream
(
)
=
>
{
this
.
log
.
trace
(
"
Writing
the
script
cache
is
done
.
Setting
version
.
"
)
;
this
.
_cacheEntry
.
setMetaDataElement
(
"
version
"
String
(
this
.
CACHE_VERSION
)
)
;
this
.
log
.
trace
(
Version
is
set
to
{
this
.
CACHE_VERSION
}
.
)
;
this
.
log
.
info
(
"
Caching
of
page
and
script
is
done
.
"
)
;
}
)
;
}
)
;
}
onContentProcessCreated
(
childID
procManager
)
{
if
(
procManager
.
remoteType
=
=
E10SUtils
.
PRIVILEGEDABOUT_REMOTE_TYPE
)
{
this
.
log
.
trace
(
A
privileged
about
content
process
is
launching
with
ID
{
childID
}
.
+
"
Sending
it
the
cache
input
streams
.
"
)
;
this
.
sendCacheInputStreams
(
procManager
)
;
procManager
.
addMessageListener
(
this
.
CACHE_RESPONSE_MESSAGE
this
)
;
this
.
_procManager
=
procManager
;
this
.
_procManagerID
=
childID
;
}
}
onContentProcessShutdown
(
childID
)
{
if
(
this
.
_procManagerID
=
=
childID
)
{
this
.
_procManager
.
removeMessageListener
(
this
.
CACHE_RESPONSE_MESSAGE
this
)
;
this
.
_procManager
=
null
;
this
.
_procManagerID
=
null
;
}
}
onPreloadedNewTabMessage
(
)
{
if
(
!
this
.
_initted
|
|
!
this
.
_enabled
)
{
return
;
}
this
.
log
.
trace
(
"
Preloaded
about
:
newtab
was
updated
.
"
)
;
this
.
_cacheTask
.
disarm
(
)
;
this
.
_cacheTask
.
arm
(
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsICacheEntryOpenallback
Ci
.
nsIObserver
]
)
receiveMessage
(
message
)
{
if
(
message
.
target
.
remoteType
!
=
E10SUtils
.
PRIVILEGEDABOUT_REMOTE_TYPE
)
{
this
.
log
.
error
(
"
Received
a
message
from
a
non
-
privileged
content
process
!
"
)
;
return
;
}
if
(
message
.
name
=
=
this
.
CACHE_RESPONSE_MESSAGE
)
{
this
.
log
.
trace
(
"
Parent
received
cache
streams
.
"
)
;
if
(
!
this
.
_cacheDeferred
)
{
this
.
log
.
error
(
"
Parent
doesn
'
t
have
_cacheDeferred
set
up
!
"
)
;
return
;
}
this
.
_cacheDeferred
(
message
.
data
)
;
this
.
_cacheDeferred
=
null
;
}
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
ipc
:
content
-
created
"
:
{
let
childID
=
aData
;
let
procManager
=
aSubject
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIMessageSender
)
;
this
.
onContentProcessCreated
(
childID
procManager
)
;
break
;
}
case
"
ipc
:
content
-
shutdown
"
:
{
let
childID
=
aData
;
this
.
onContentProcessShutdown
(
childID
)
;
break
;
}
}
}
onCacheEntryCheck
(
aEntry
aApplicationCache
)
{
return
Ci
.
nsICacheEntryOpenCallback
.
ENTRY_WANTED
;
}
onCacheEntryAvailable
(
aEntry
aNew
aApplicationCache
aResult
)
{
this
.
log
.
trace
(
"
Cache
entry
is
available
.
"
)
;
this
.
_cacheEntry
=
aEntry
;
this
.
makePipes
(
)
;
this
.
maybeConnectToPipes
(
)
;
}
}
;
