"
use
strict
"
;
ChromeUtils
.
defineESModuleGetters
(
this
{
ReviewCheckerParent
:
"
resource
:
/
/
/
actors
/
ReviewCheckerParent
.
sys
.
mjs
"
ShoppingUtils
:
"
resource
:
/
/
/
modules
/
ShoppingUtils
.
sys
.
mjs
"
}
)
;
const
{
SpecialMessageActions
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
messaging
-
system
/
lib
/
SpecialMessageActions
.
sys
.
mjs
"
)
;
const
PRODUCT_URI
=
Services
.
io
.
newURI
(
"
https
:
/
/
example
.
com
/
product
/
B09TJGHL5F
"
)
;
const
CONTENT_PAGE_URI
=
Services
.
io
.
newURI
(
"
https
:
/
/
example
.
com
"
)
;
const
UNSUPPORTED_NON_PDP_URL
=
"
about
:
about
"
;
const
UNSUPPORTED_NON_PDP_URI
=
Services
.
io
.
newURI
(
UNSUPPORTED_NON_PDP_URL
)
;
const
REVIEW_CHECKER_ACTOR
=
"
ReviewChecker
"
;
const
EMPTY_STATE_CLASS_NAME
=
"
.
FS_OPT_IN_SIDEBAR_VARIANT
"
;
const
EMPTY_STATE_UNSUPPORTED_PDP_CLASS_NAME
=
"
.
FS_OPT_IN_SIDEBAR_VARIANT_UNSUPPORTED_NON_PDP
"
;
function
setOnboardingPrefs
(
states
=
{
}
)
{
if
(
Object
.
hasOwn
(
states
"
handledAutoActivate
"
)
)
{
ShoppingUtils
.
handledAutoActivate
=
!
!
states
.
handledAutoActivate
;
}
if
(
Object
.
hasOwn
(
states
"
lastAutoActivate
"
)
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
shopping
.
experience2023
.
lastAutoActivate
"
states
.
lastAutoActivate
)
;
}
if
(
Object
.
hasOwn
(
states
"
autoActivateCount
"
)
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
shopping
.
experience2023
.
autoActivateCount
"
states
.
autoActivateCount
)
;
}
if
(
Object
.
hasOwn
(
states
"
optedIn
"
)
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
shopping
.
experience2023
.
optedIn
"
states
.
optedIn
)
;
}
if
(
Object
.
hasOwn
(
states
"
active
"
)
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
shopping
.
experience2023
.
active
"
states
.
active
)
;
}
if
(
Object
.
hasOwn
(
states
"
telemetryEnabled
"
)
)
{
Services
.
prefs
.
setBoolPref
(
"
browser
.
newtabpage
.
activity
-
stream
.
telemetry
"
states
.
telemetryEnabled
)
;
}
}
async
function
assertEmptyStateType
(
browser
messageName
)
{
await
SpecialPowers
.
spawn
(
browser
[
messageName
]
async
className
=
>
{
let
shoppingContainer
=
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
content
.
document
.
querySelector
(
"
shopping
-
container
"
)
"
shopping
-
container
"
)
;
let
containerElem
=
shoppingContainer
.
shadowRoot
.
getElementById
(
"
shopping
-
container
"
)
;
let
messageSlot
=
containerElem
.
getElementsByTagName
(
"
slot
"
)
;
ok
(
messageSlot
.
length
message
slot
element
exists
)
;
is
(
messageSlot
[
0
]
.
name
"
multi
-
stage
-
message
-
slot
"
"
multi
-
stage
-
message
-
slot
showing
opt
-
in
message
rendered
"
)
;
ok
(
!
content
.
document
.
getElementById
(
"
multi
-
stage
-
message
-
root
"
)
.
hidden
"
message
is
shown
"
)
;
ok
(
content
.
document
.
querySelector
(
className
)
Rendered
correct
message
{
className
}
)
;
}
)
;
}
async
function
assertEmptyStateTypeWithRC
(
emptyStateClassName
)
{
await
withReviewCheckerSidebar
(
async
className
=
>
{
let
shoppingContainer
=
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
content
.
document
.
querySelector
(
"
shopping
-
container
"
)
?
.
wrappedJSObject
"
Review
Checker
is
loaded
.
"
)
;
await
shoppingContainer
.
updateComplete
;
let
containerElem
=
shoppingContainer
.
shadowRoot
.
getElementById
(
"
shopping
-
container
"
)
;
let
messageSlot
=
containerElem
.
getElementsByTagName
(
"
slot
"
)
;
ok
(
messageSlot
.
length
message
slot
element
exists
)
;
is
(
messageSlot
[
0
]
.
name
"
multi
-
stage
-
message
-
slot
"
"
multi
-
stage
-
message
-
slot
showing
opt
-
in
message
rendered
"
)
;
ok
(
!
content
.
document
.
getElementById
(
"
multi
-
stage
-
message
-
root
"
)
.
hidden
"
message
is
shown
"
)
;
ok
(
content
.
document
.
querySelector
(
{
className
}
)
Rendered
correct
message
{
className
}
)
;
}
[
emptyStateClassName
]
)
;
}
add_setup
(
async
function
setup
(
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
registerCleanupFunction
(
(
)
=
>
setOnboardingPrefs
(
{
active
:
true
optedIn
:
1
lastAutoActivate
:
0
autoActivateCount
:
0
handledAutoActivate
:
false
telementryEnabled
:
false
}
)
)
;
}
)
;
add_task
(
async
function
test_showOnboarding_notOptedIn
(
)
{
setOnboardingPrefs
(
{
active
:
false
optedIn
:
0
telemetryEnabled
:
true
}
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
Services
.
fog
.
testFlushAllChildren
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
ReviewCheckerParent
"
isIgnoredURL
"
)
.
returns
(
false
)
;
await
BrowserTestUtils
.
withNewTab
(
{
url
:
"
about
:
shoppingsidebar
"
gBrowser
}
async
browser
=
>
{
let
actor
=
gBrowser
.
selectedBrowser
.
browsingContext
.
currentWindowGlobal
.
getExistingActor
(
REVIEW_CHECKER_ACTOR
)
;
actor
.
updateCurrentURL
(
PRODUCT_URI
)
;
await
assertEmptyStateType
(
browser
EMPTY_STATE_CLASS_NAME
)
;
}
)
;
if
(
!
AppConstants
.
platform
!
=
"
linux
"
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
events
=
Glean
.
shopping
.
surfaceOnboardingDisplayed
.
testGetValue
(
)
;
if
(
events
)
{
Assert
.
greater
(
events
.
length
0
)
;
Assert
.
equal
(
events
[
0
]
.
category
"
shopping
"
)
;
Assert
.
equal
(
events
[
0
]
.
name
"
surface_onboarding_displayed
"
)
;
}
else
{
info
(
"
Failed
to
get
Glean
value
due
to
unknown
bug
.
See
bug
1862389
.
"
)
;
}
}
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_showOnboarding_notOptedIn_supported
(
)
{
setOnboardingPrefs
(
{
active
:
false
optedIn
:
0
telemetryEnabled
:
true
}
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
Services
.
fog
.
testFlushAllChildren
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
ReviewCheckerParent
"
isIgnoredURL
"
)
.
returns
(
false
)
;
await
BrowserTestUtils
.
withNewTab
(
{
url
:
"
about
:
shoppingsidebar
"
gBrowser
}
async
browser
=
>
{
let
actor
=
gBrowser
.
selectedBrowser
.
browsingContext
.
currentWindowGlobal
.
getExistingActor
(
REVIEW_CHECKER_ACTOR
)
;
actor
.
updateCurrentURL
(
CONTENT_PAGE_URI
)
;
await
assertEmptyStateType
(
browser
EMPTY_STATE_CLASS_NAME
)
;
}
)
;
if
(
!
AppConstants
.
platform
!
=
"
linux
"
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
events
=
Glean
.
shopping
.
surfaceOnboardingDisplayed
.
testGetValue
(
)
;
if
(
events
)
{
Assert
.
greater
(
events
.
length
0
)
;
Assert
.
equal
(
events
[
0
]
.
category
"
shopping
"
)
;
Assert
.
equal
(
events
[
0
]
.
name
"
surface_onboarding_displayed
"
)
;
}
else
{
info
(
"
Failed
to
get
Glean
value
due
to
unknown
bug
.
See
bug
1862389
.
"
)
;
}
}
await
SpecialPowers
.
popPrefEnv
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_showOnboarding_notOptedIn_integrated_sidebar_unsupported
(
)
{
setOnboardingPrefs
(
{
active
:
false
optedIn
:
0
telemetryEnabled
:
true
}
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
Services
.
fog
.
testFlushAllChildren
(
)
;
let
sandbox
=
sinon
.
createSandbox
(
)
;
sandbox
.
stub
(
ReviewCheckerParent
"
isIgnoredURL
"
)
.
returns
(
false
)
;
await
BrowserTestUtils
.
withNewTab
(
{
url
:
"
about
:
shoppingsidebar
"
gBrowser
}
async
browser
=
>
{
let
actor
=
gBrowser
.
selectedBrowser
.
browsingContext
.
currentWindowGlobal
.
getExistingActor
(
REVIEW_CHECKER_ACTOR
)
;
actor
.
updateCurrentURL
(
UNSUPPORTED_NON_PDP_URI
)
;
await
assertEmptyStateType
(
browser
EMPTY_STATE_UNSUPPORTED_PDP_CLASS_NAME
)
;
}
)
;
if
(
!
AppConstants
.
platform
!
=
"
linux
"
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
events
=
Glean
.
shopping
.
surfaceOnboardingDisplayed
.
testGetValue
(
)
;
if
(
events
)
{
Assert
.
greater
(
events
.
length
0
)
;
Assert
.
equal
(
events
[
0
]
.
category
"
shopping
"
)
;
Assert
.
equal
(
events
[
0
]
.
name
"
surface_onboarding_displayed
"
)
;
}
else
{
info
(
"
Failed
to
get
Glean
value
due
to
unknown
bug
.
See
bug
1862389
.
"
)
;
}
}
await
SpecialPowers
.
popPrefEnv
(
)
;
sandbox
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_hideOnboarding_optedIn
(
)
{
setOnboardingPrefs
(
{
active
:
false
optedIn
:
1
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
url
:
"
about
:
shoppingsidebar
"
gBrowser
}
async
browser
=
>
{
let
actor
=
gBrowser
.
selectedBrowser
.
browsingContext
.
currentWindowGlobal
.
getExistingActor
(
REVIEW_CHECKER_ACTOR
)
;
actor
.
updateCurrentURL
(
PRODUCT_URI
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
content
.
document
.
querySelector
(
"
shopping
-
container
"
)
"
shopping
-
container
"
)
;
ok
(
content
.
document
.
getElementById
(
"
multi
-
stage
-
message
-
root
"
)
.
hidden
"
message
is
hidden
"
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_hideOnboarding_OptIn_AfterSurveySeen
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
shopping
.
experience2023
.
optedIn
"
0
]
[
"
browser
.
shopping
.
experience2023
.
survey
.
enabled
"
true
]
[
"
browser
.
shopping
.
experience2023
.
survey
.
hasSeen
"
true
]
[
"
browser
.
shopping
.
experience2023
.
survey
.
pdpVisits
"
5
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
{
url
:
"
about
:
shoppingsidebar
"
gBrowser
}
async
browser
=
>
{
let
actor
=
gBrowser
.
selectedBrowser
.
browsingContext
.
currentWindowGlobal
.
getExistingActor
(
REVIEW_CHECKER_ACTOR
)
;
actor
.
updateCurrentURL
(
PRODUCT_URI
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
shoppingContainer
=
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
content
.
document
.
querySelector
(
"
shopping
-
container
"
)
"
shopping
-
container
"
)
;
ok
(
!
content
.
document
.
getElementById
(
"
multi
-
stage
-
message
-
root
"
)
.
hidden
"
opt
-
in
message
is
shown
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
sys
.
mjs
"
)
;
let
optedInPrefChanged
=
TestUtils
.
waitForPrefChange
(
"
browser
.
shopping
.
experience2023
.
optedIn
"
value
=
>
value
=
=
=
1
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
shopping
.
experience2023
.
optedIn
"
1
]
]
}
)
;
await
optedInPrefChanged
;
await
shoppingContainer
.
wrappedJSObject
.
updateComplete
;
ok
(
content
.
document
.
getElementById
(
"
multi
-
stage
-
message
-
root
"
)
.
hidden
"
opt
-
in
message
is
hidden
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_showOnboarding_integrated_sidebar_correct_ui_on_rerender
(
)
{
setOnboardingPrefs
(
{
optedIn
:
0
telemetryEnabled
:
true
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
shopping
.
experience2023
.
autoClose
.
userEnabled
"
false
]
[
"
browser
.
shopping
.
experience2023
.
autoOpen
.
userEnabled
"
true
]
[
"
toolkit
.
shopping
.
ohttpRelayURL
"
"
"
]
[
"
toolkit
.
shopping
.
ohttpConfigURL
"
"
"
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
PRODUCT_TEST_URL
async
browser
=
>
{
await
SidebarController
.
show
(
"
viewReviewCheckerSidebar
"
)
;
await
assertEmptyStateTypeWithRC
(
EMPTY_STATE_CLASS_NAME
)
;
let
loadedPromise
=
BrowserTestUtils
.
browserLoaded
(
browser
)
;
await
BrowserTestUtils
.
reloadTab
(
gBrowser
.
selectedTab
)
;
await
loadedPromise
;
Assert
.
ok
(
true
"
Promise
resolved
after
reloading
tab
"
)
;
info
(
"
Verifying
UI
for
PDP
after
reload
"
)
;
await
assertEmptyStateTypeWithRC
(
EMPTY_STATE_CLASS_NAME
)
;
SidebarController
.
hide
(
)
;
await
SidebarController
.
show
(
"
viewReviewCheckerSidebar
"
)
;
info
(
"
Verifying
UI
for
PDP
after
closing
then
reopening
the
RC
panel
"
)
;
await
assertEmptyStateTypeWithRC
(
EMPTY_STATE_CLASS_NAME
)
;
let
unsupportedSiteTab
=
BrowserTestUtils
.
addTab
(
gBrowser
UNSUPPORTED_NON_PDP_URL
)
;
let
nonPDPBrowser
=
unsupportedSiteTab
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
nonPDPBrowser
false
UNSUPPORTED_NON_PDP_URL
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
unsupportedSiteTab
)
;
Assert
.
ok
(
true
"
Browser
is
loaded
after
switching
tabs
"
)
;
Assert
.
ok
(
SidebarController
.
isOpen
"
Sidebar
is
open
now
"
)
;
info
(
"
Verifying
UI
for
unsupported
sites
after
switching
to
an
unsupported
site
tab
"
)
;
await
assertEmptyStateTypeWithRC
(
EMPTY_STATE_UNSUPPORTED_PDP_CLASS_NAME
)
;
SidebarController
.
hide
(
)
;
await
SidebarController
.
show
(
"
viewReviewCheckerSidebar
"
)
;
info
(
"
Verifying
UI
for
unsupported
sites
after
closing
then
reopening
the
RC
panel
"
)
;
await
assertEmptyStateTypeWithRC
(
EMPTY_STATE_UNSUPPORTED_PDP_CLASS_NAME
)
;
await
BrowserTestUtils
.
removeTab
(
unsupportedSiteTab
)
;
}
)
;
SidebarController
.
hide
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
function
test_onboarding_auto_activate
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
shopping
.
experience2023
.
autoActivateCount
"
0
]
[
"
browser
.
shopping
.
experience2023
.
optedIn
"
0
]
]
}
)
;
let
shownPromise
=
BrowserTestUtils
.
waitForEvent
(
window
"
SidebarShown
"
)
;
await
BrowserTestUtils
.
withNewTab
(
PRODUCT_TEST_URL
async
(
)
=
>
{
await
shownPromise
;
let
reviewCheckerOpen
=
SidebarController
.
isOpen
&
&
SidebarController
.
currentID
=
=
"
viewReviewCheckerSidebar
"
;
Assert
.
equal
(
reviewCheckerOpen
true
"
Review
Checker
should
auto
-
activate
"
)
;
let
autoActivateCount
=
Services
.
prefs
.
getIntPref
(
"
browser
.
shopping
.
experience2023
.
autoActivateCount
"
0
)
;
Assert
.
equal
(
autoActivateCount
1
)
;
SidebarController
.
hide
(
)
;
let
newProductTab
=
BrowserTestUtils
.
addTab
(
gBrowser
OTHER_PRODUCT_TEST_URL
)
;
let
newProductBrowser
=
newProductTab
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
newProductBrowser
false
OTHER_PRODUCT_TEST_URL
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
newProductTab
)
;
await
TestUtils
.
waitForTick
(
)
;
Assert
.
equal
(
SidebarController
.
isOpen
false
"
Review
checker
should
not
auto
-
activate
a
second
time
"
)
;
await
BrowserTestUtils
.
removeTab
(
newProductTab
)
;
}
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
