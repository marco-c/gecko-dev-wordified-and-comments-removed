let
homeURL
=
"
https
:
/
/
webxr
.
today
/
"
;
let
privacyPolicyURL
=
"
https
:
/
/
www
.
mozilla
.
org
/
en
-
US
/
privacy
/
firefox
/
"
;
let
reportIssueURL
=
"
https
:
/
/
mzl
.
la
/
fxr
"
;
let
licenseURL
=
"
https
:
/
/
mixedreality
.
mozilla
.
org
/
FirefoxRealityPC
/
license
.
html
"
;
let
browser
=
null
;
let
currentPermissionRequest
=
null
;
let
pendingPermissionRequests
=
[
]
;
let
urlInput
=
null
;
let
secureIcon
=
null
;
let
backButton
=
null
;
let
forwardButton
=
null
;
let
refreshButton
=
null
;
let
stopButton
=
null
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
XPCOMUtils
.
defineLazyScriptGetter
(
this
"
FullScreen
"
"
chrome
:
/
/
fxr
/
content
/
fxr
-
fullScreen
.
js
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gSystemPrincipal
"
(
)
=
>
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
window
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
urlInput
=
document
.
getElementById
(
"
eUrlInput
"
)
;
secureIcon
=
document
.
getElementById
(
"
eUrlSecure
"
)
;
backButton
=
document
.
getElementById
(
"
eBack
"
)
;
forwardButton
=
document
.
getElementById
(
"
eForward
"
)
;
refreshButton
=
document
.
getElementById
(
"
eRefresh
"
)
;
stopButton
=
document
.
getElementById
(
"
eStop
"
)
;
setupBrowser
(
)
;
setupNavButtons
(
)
;
setupUrlBar
(
)
;
}
{
once
:
true
}
)
;
function
setupBrowser
(
)
{
if
(
document
.
createXULElement
)
{
browser
=
document
.
createXULElement
(
"
browser
"
)
;
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
browser
.
setAttribute
(
"
remote
"
"
true
"
)
;
browser
.
classList
.
add
(
"
browser_instance
"
)
;
document
.
getElementById
(
"
eBrowserContainer
"
)
.
appendChild
(
browser
)
;
browser
.
loadUrlWithSystemPrincipal
=
function
(
url
)
{
this
.
loadURI
(
url
{
triggeringPrincipal
:
gSystemPrincipal
}
)
;
}
;
browser
.
fxrPermissionPrompt
=
permissionPrompt
;
urlInput
.
value
=
homeURL
;
browser
.
loadUrlWithSystemPrincipal
(
homeURL
)
;
browser
.
addProgressListener
(
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
urlInput
.
value
=
browser
.
currentURI
.
spec
;
backButton
.
disabled
=
!
browser
.
canGoBack
;
forwardButton
.
disabled
=
!
browser
.
canGoForward
;
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
if
(
aStateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
refreshButton
.
disabled
=
false
;
stopButton
.
disabled
=
true
;
}
else
{
refreshButton
.
disabled
=
true
;
stopButton
.
disabled
=
false
;
}
}
onSecurityChange
(
aWebProgress
aRequest
aState
)
{
if
(
aState
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
)
{
secureIcon
.
style
.
visibility
=
"
visible
"
;
}
else
{
secureIcon
.
style
.
visibility
=
"
hidden
"
;
}
}
}
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
|
Ci
.
nsIWebProgress
.
NOTIFY_SECURITY
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_REQUEST
)
;
FullScreen
.
init
(
)
;
Services
.
obs
.
notifyObservers
(
window
"
extensions
-
late
-
startup
"
)
;
}
}
function
setupNavButtons
(
)
{
let
aryNavButtons
=
[
"
eBack
"
"
eForward
"
"
eRefresh
"
"
eStop
"
"
eHome
"
"
ePrefs
"
]
;
function
navButtonHandler
(
e
)
{
if
(
!
this
.
disabled
)
{
switch
(
this
.
id
)
{
case
"
eBack
"
:
browser
.
goBack
(
)
;
break
;
case
"
eForward
"
:
browser
.
goForward
(
)
;
break
;
case
"
eRefresh
"
:
browser
.
reload
(
)
;
break
;
case
"
eStop
"
:
browser
.
stop
(
)
;
break
;
case
"
eHome
"
:
browser
.
loadUrlWithSystemPrincipal
(
homeURL
)
;
break
;
case
"
ePrefs
"
:
openSettings
(
)
;
break
;
}
}
}
for
(
let
btnName
of
aryNavButtons
)
{
let
elem
=
document
.
getElementById
(
btnName
)
;
elem
.
addEventListener
(
"
click
"
navButtonHandler
)
;
}
}
function
setupUrlBar
(
)
{
urlInput
.
addEventListener
(
"
keypress
"
async
function
(
e
)
{
if
(
e
.
key
=
=
"
Enter
"
)
{
await
Services
.
search
.
init
(
)
;
let
valueToFixUp
=
urlInput
.
value
;
let
flags
=
Services
.
uriFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
|
Services
.
uriFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
)
{
flags
|
=
Services
.
uriFixup
.
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
let
{
preferredURI
}
=
Services
.
uriFixup
.
getFixupURIInfo
(
valueToFixUp
flags
)
;
browser
.
loadUrlWithSystemPrincipal
(
preferredURI
.
spec
)
;
browser
.
focus
(
)
;
}
}
)
;
urlInput
.
addEventListener
(
"
focus
"
function
(
)
{
urlInput
.
select
(
)
;
}
)
;
}
function
openSettings
(
)
{
let
browserSettingsUI
=
document
.
createXULElement
(
"
browser
"
)
;
browserSettingsUI
.
setAttribute
(
"
type
"
"
chrome
"
)
;
browserSettingsUI
.
classList
.
add
(
"
browser_settings
"
)
;
showModalContainer
(
browserSettingsUI
)
;
browserSettingsUI
.
loadURI
(
"
chrome
:
/
/
fxr
/
content
/
prefs
.
html
"
{
triggeringPrincipal
:
gSystemPrincipal
}
)
;
}
function
closeSettings
(
)
{
clearModalContainer
(
)
;
}
function
showPrivacyPolicy
(
)
{
closeSettings
(
)
;
browser
.
loadUrlWithSystemPrincipal
(
privacyPolicyURL
)
;
}
function
showLicenseInfo
(
)
{
closeSettings
(
)
;
browser
.
loadUrlWithSystemPrincipal
(
licenseURL
)
;
}
function
showReportIssue
(
)
{
closeSettings
(
)
;
browser
.
loadUrlWithSystemPrincipal
(
reportIssueURL
)
;
}
function
permissionPrompt
(
aRequest
)
{
let
newPrompt
;
if
(
aRequest
instanceof
Ci
.
nsIContentPermissionRequest
)
{
newPrompt
=
new
FxrContentPrompt
(
aRequest
this
finishPrompt
)
;
}
else
{
newPrompt
=
new
FxrWebRTCPrompt
(
aRequest
this
finishPrompt
)
;
}
if
(
currentPermissionRequest
)
{
pendingPermissionRequests
.
push
(
newPrompt
)
;
}
else
{
currentPermissionRequest
=
newPrompt
;
currentPermissionRequest
.
showPrompt
(
)
;
}
}
function
finishPrompt
(
)
{
if
(
pendingPermissionRequests
.
length
)
{
currentPermissionRequest
=
pendingPermissionRequests
.
shift
(
)
;
currentPermissionRequest
.
showPrompt
(
)
;
}
else
{
currentPermissionRequest
=
null
;
}
}
