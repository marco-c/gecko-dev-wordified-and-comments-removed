#
include
"
OCSPCache
.
h
"
#
include
<
limits
>
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
pkix
/
pkixnss
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
secerr
.
h
"
extern
mozilla
:
:
LazyLogModule
gCertVerifierLog
;
using
namespace
mozilla
:
:
pkix
;
namespace
mozilla
{
namespace
psm
{
typedef
mozilla
:
:
pkix
:
:
Result
Result
;
static
SECStatus
DigestLength
(
UniquePK11Context
&
context
uint32_t
length
)
{
if
(
length
>
=
65536
)
{
return
SECFailure
;
}
unsigned
char
array
[
2
]
;
array
[
0
]
=
length
&
255
;
array
[
1
]
=
(
length
>
>
8
)
&
255
;
return
PK11_DigestOp
(
context
.
get
(
)
array
MOZ_ARRAY_LENGTH
(
array
)
)
;
}
static
SECStatus
CertIDHash
(
SHA384Buffer
&
buf
const
CertID
&
certID
const
char
*
firstPartyDomain
)
{
UniquePK11Context
context
(
PK11_CreateDigestContext
(
SEC_OID_SHA384
)
)
;
if
(
!
context
)
{
return
SECFailure
;
}
SECStatus
rv
=
PK11_DigestBegin
(
context
.
get
(
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
SECItem
certIDIssuer
=
UnsafeMapInputToSECItem
(
certID
.
issuer
)
;
rv
=
PK11_DigestOp
(
context
.
get
(
)
certIDIssuer
.
data
certIDIssuer
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
SECItem
certIDIssuerSubjectPublicKeyInfo
=
UnsafeMapInputToSECItem
(
certID
.
issuerSubjectPublicKeyInfo
)
;
rv
=
PK11_DigestOp
(
context
.
get
(
)
certIDIssuerSubjectPublicKeyInfo
.
data
certIDIssuerSubjectPublicKeyInfo
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
SECItem
certIDSerialNumber
=
UnsafeMapInputToSECItem
(
certID
.
serialNumber
)
;
rv
=
DigestLength
(
context
certIDSerialNumber
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
rv
=
PK11_DigestOp
(
context
.
get
(
)
certIDSerialNumber
.
data
certIDSerialNumber
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
if
(
firstPartyDomain
)
{
uint32_t
firstPartyDomainLen
=
strlen
(
firstPartyDomain
)
;
rv
=
DigestLength
(
context
firstPartyDomainLen
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
rv
=
PK11_DigestOp
(
context
.
get
(
)
BitwiseCast
<
const
unsigned
char
*
>
(
firstPartyDomain
)
firstPartyDomainLen
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
}
uint32_t
outLen
=
0
;
rv
=
PK11_DigestFinal
(
context
.
get
(
)
buf
&
outLen
SHA384_LENGTH
)
;
if
(
outLen
!
=
SHA384_LENGTH
)
{
return
SECFailure
;
}
return
rv
;
}
Result
OCSPCache
:
:
Entry
:
:
Init
(
const
CertID
&
aCertID
const
char
*
aFirstPartyDomain
)
{
SECStatus
srv
=
CertIDHash
(
mIDHash
aCertID
aFirstPartyDomain
)
;
if
(
srv
!
=
SECSuccess
)
{
return
MapPRErrorCodeToResult
(
PR_GetError
(
)
)
;
}
return
Success
;
}
OCSPCache
:
:
OCSPCache
(
)
:
mMutex
(
"
OCSPCache
-
mutex
"
)
{
}
OCSPCache
:
:
~
OCSPCache
(
)
{
Clear
(
)
;
}
bool
OCSPCache
:
:
FindInternal
(
const
CertID
&
aCertID
const
char
*
aFirstPartyDomain
size_t
&
index
const
MutexAutoLock
&
)
{
if
(
mEntries
.
length
(
)
=
=
0
)
{
return
false
;
}
SHA384Buffer
idHash
;
SECStatus
rv
=
CertIDHash
(
idHash
aCertID
aFirstPartyDomain
)
;
if
(
rv
!
=
SECSuccess
)
{
return
false
;
}
index
=
mEntries
.
length
(
)
;
while
(
index
>
0
)
{
-
-
index
;
if
(
memcmp
(
mEntries
[
index
]
-
>
mIDHash
idHash
SHA384_LENGTH
)
=
=
0
)
{
return
true
;
}
}
return
false
;
}
static
inline
void
LogWithCertID
(
const
char
*
aMessage
const
CertID
&
aCertID
const
char
*
aFirstPartyDomain
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
aMessage
&
aCertID
aFirstPartyDomain
)
)
;
}
void
OCSPCache
:
:
MakeMostRecentlyUsed
(
size_t
aIndex
const
MutexAutoLock
&
)
{
Entry
*
entry
=
mEntries
[
aIndex
]
;
mEntries
.
erase
(
mEntries
.
begin
(
)
+
aIndex
)
;
MOZ_RELEASE_ASSERT
(
mEntries
.
append
(
entry
)
)
;
}
bool
OCSPCache
:
:
Get
(
const
CertID
&
aCertID
const
char
*
aFirstPartyDomain
Result
&
aResult
Time
&
aValidThrough
)
{
MutexAutoLock
lock
(
mMutex
)
;
size_t
index
;
if
(
!
FindInternal
(
aCertID
aFirstPartyDomain
index
lock
)
)
{
LogWithCertID
(
"
OCSPCache
:
:
Get
(
%
p
\
"
%
s
\
"
)
not
in
cache
"
aCertID
aFirstPartyDomain
)
;
return
false
;
}
LogWithCertID
(
"
OCSPCache
:
:
Get
(
%
p
\
"
%
s
\
"
)
in
cache
"
aCertID
aFirstPartyDomain
)
;
aResult
=
mEntries
[
index
]
-
>
mResult
;
aValidThrough
=
mEntries
[
index
]
-
>
mValidThrough
;
MakeMostRecentlyUsed
(
index
lock
)
;
return
true
;
}
Result
OCSPCache
:
:
Put
(
const
CertID
&
aCertID
const
char
*
aFirstPartyDomain
Result
aResult
Time
aThisUpdate
Time
aValidThrough
)
{
MutexAutoLock
lock
(
mMutex
)
;
size_t
index
;
if
(
FindInternal
(
aCertID
aFirstPartyDomain
index
lock
)
)
{
if
(
mEntries
[
index
]
-
>
mResult
=
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
)
{
LogWithCertID
(
"
OCSPCache
:
:
Put
(
%
p
\
"
%
s
\
"
)
already
in
cache
as
revoked
-
"
"
not
replacing
"
aCertID
aFirstPartyDomain
)
;
MakeMostRecentlyUsed
(
index
lock
)
;
return
Success
;
}
if
(
mEntries
[
index
]
-
>
mThisUpdate
>
aThisUpdate
&
&
aResult
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
)
{
LogWithCertID
(
"
OCSPCache
:
:
Put
(
%
p
\
"
%
s
\
"
)
already
in
cache
with
more
"
"
recent
validity
-
not
replacing
"
aCertID
aFirstPartyDomain
)
;
MakeMostRecentlyUsed
(
index
lock
)
;
return
Success
;
}
if
(
aResult
!
=
Success
&
&
aResult
!
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
&
&
aResult
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
)
{
LogWithCertID
(
"
OCSPCache
:
:
Put
(
%
p
\
"
%
s
\
"
)
already
in
cache
-
not
"
"
replacing
with
less
important
status
"
aCertID
aFirstPartyDomain
)
;
MakeMostRecentlyUsed
(
index
lock
)
;
return
Success
;
}
LogWithCertID
(
"
OCSPCache
:
:
Put
(
%
p
\
"
%
s
\
"
)
already
in
cache
-
replacing
"
aCertID
aFirstPartyDomain
)
;
mEntries
[
index
]
-
>
mResult
=
aResult
;
mEntries
[
index
]
-
>
mThisUpdate
=
aThisUpdate
;
mEntries
[
index
]
-
>
mValidThrough
=
aValidThrough
;
MakeMostRecentlyUsed
(
index
lock
)
;
return
Success
;
}
if
(
mEntries
.
length
(
)
=
=
MaxEntries
)
{
LogWithCertID
(
"
OCSPCache
:
:
Put
(
%
p
\
"
%
s
\
"
)
too
full
-
evicting
an
entry
"
aCertID
aFirstPartyDomain
)
;
for
(
Entry
*
*
toEvict
=
mEntries
.
begin
(
)
;
toEvict
!
=
mEntries
.
end
(
)
;
toEvict
+
+
)
{
if
(
(
*
toEvict
)
-
>
mResult
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
&
&
(
*
toEvict
)
-
>
mResult
!
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
delete
*
toEvict
;
mEntries
.
erase
(
toEvict
)
;
break
;
}
}
if
(
mEntries
.
length
(
)
=
=
MaxEntries
)
{
return
aResult
;
}
}
Entry
*
newEntry
=
new
(
std
:
:
nothrow
)
Entry
(
aResult
aThisUpdate
aValidThrough
)
;
if
(
!
newEntry
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
Result
rv
=
newEntry
-
>
Init
(
aCertID
aFirstPartyDomain
)
;
if
(
rv
!
=
Success
)
{
delete
newEntry
;
return
rv
;
}
if
(
!
mEntries
.
append
(
newEntry
)
)
{
delete
newEntry
;
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
LogWithCertID
(
"
OCSPCache
:
:
Put
(
%
p
\
"
%
s
\
"
)
added
to
cache
"
aCertID
aFirstPartyDomain
)
;
return
Success
;
}
void
OCSPCache
:
:
Clear
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
OCSPCache
:
:
Clear
:
clearing
cache
"
)
)
;
for
(
Entry
*
*
entry
=
mEntries
.
begin
(
)
;
entry
<
mEntries
.
end
(
)
;
entry
+
+
)
{
delete
*
entry
;
}
mEntries
.
clearAndFree
(
)
;
}
}
}
