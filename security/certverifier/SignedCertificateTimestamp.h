#
ifndef
SignedCertificateTimestamp_h
#
define
SignedCertificateTimestamp_h
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
pkix
/
Input
.
h
"
#
include
"
pkix
/
Result
.
h
"
namespace
mozilla
{
namespace
ct
{
typedef
Vector
<
uint8_t
>
Buffer
;
struct
LogEntry
{
enum
class
Type
{
X509
=
0
Precert
=
1
}
;
void
Reset
(
)
;
Type
type
;
Buffer
leafCertificate
;
Buffer
issuerKeyHash
;
Buffer
tbsCertificate
;
}
;
struct
DigitallySigned
{
enum
class
HashAlgorithm
{
None
=
0
MD5
=
1
SHA1
=
2
SHA224
=
3
SHA256
=
4
SHA384
=
5
SHA512
=
6
}
;
enum
class
SignatureAlgorithm
{
Anonymous
=
0
RSA
=
1
DSA
=
2
ECDSA
=
3
}
;
bool
SignatureParametersMatch
(
HashAlgorithm
aHashAlgorithm
SignatureAlgorithm
aSignatureAlgorithm
)
const
;
HashAlgorithm
hashAlgorithm
;
SignatureAlgorithm
signatureAlgorithm
;
Buffer
signatureData
;
}
;
struct
SignedCertificateTimestamp
{
enum
class
Version
{
V1
=
0
}
;
Version
version
;
Buffer
logId
;
uint64_t
timestamp
;
Buffer
extensions
;
DigitallySigned
signature
;
enum
class
Origin
{
Unknown
Embedded
TLSExtension
OCSPResponse
}
;
enum
class
VerificationStatus
{
None
OK
UnknownLog
InvalidSignature
InvalidTimestamp
}
;
Origin
origin
;
VerificationStatus
verificationStatus
;
}
;
inline
pkix
:
:
Result
BufferToInput
(
const
Buffer
&
buffer
pkix
:
:
Input
&
input
)
{
return
input
.
Init
(
buffer
.
begin
(
)
buffer
.
length
(
)
)
;
}
inline
pkix
:
:
Result
InputToBuffer
(
pkix
:
:
Input
input
Buffer
&
buffer
)
{
buffer
.
clear
(
)
;
if
(
!
buffer
.
append
(
input
.
UnsafeGetData
(
)
input
.
GetLength
(
)
)
)
{
return
pkix
:
:
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
return
pkix
:
:
Success
;
}
}
}
namespace
mozilla
{
bool
operator
=
=
(
const
ct
:
:
Buffer
&
a
const
ct
:
:
Buffer
&
b
)
;
bool
operator
!
=
(
const
ct
:
:
Buffer
&
a
const
ct
:
:
Buffer
&
b
)
;
}
#
endif
