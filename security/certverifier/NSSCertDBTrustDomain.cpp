#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
<
stdint
.
h
>
#
include
"
ExtendedValidation
.
h
"
#
include
"
NSSErrorsService
.
h
"
#
include
"
OCSPVerificationTrustDomain
.
h
"
#
include
"
PublicKeyPinningService
.
h
"
#
include
"
cert
.
h
"
#
include
"
certdb
.
h
"
#
ifdef
MOZ_NEW_CERT_STORAGE
#
include
"
cert_storage
/
src
/
cert_storage
.
h
"
#
endif
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsNSSCertHelper
.
h
"
#
include
"
nsNSSCertValidity
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNSSCertificateDB
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
mozpkix
/
Result
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
prerror
.
h
"
#
include
"
secerr
.
h
"
#
include
"
TrustOverrideUtils
.
h
"
#
include
"
TrustOverride
-
StartComAndWoSignData
.
inc
"
#
include
"
TrustOverride
-
SymantecData
.
inc
"
#
include
"
TrustOverride
-
AppleGoogleDigiCertData
.
inc
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
pkix
;
extern
LazyLogModule
gCertVerifierLog
;
static
const
uint64_t
ServerFailureDelaySeconds
=
5
*
60
;
namespace
mozilla
{
namespace
psm
{
NSSCertDBTrustDomain
:
:
NSSCertDBTrustDomain
(
SECTrustType
certDBTrustType
OCSPFetching
ocspFetching
OCSPCache
&
ocspCache
void
*
pinArg
TimeDuration
ocspTimeoutSoft
TimeDuration
ocspTimeoutHard
uint32_t
certShortLifetimeInDays
CertVerifier
:
:
PinningMode
pinningMode
unsigned
int
minRSABits
ValidityCheckingMode
validityCheckingMode
CertVerifier
:
:
SHA1Mode
sha1Mode
NetscapeStepUpPolicy
netscapeStepUpPolicy
DistrustedCAPolicy
distrustedCAPolicy
const
OriginAttributes
&
originAttributes
const
Vector
<
Input
>
&
thirdPartyRootInputs
const
Vector
<
Input
>
&
thirdPartyIntermediateInputs
const
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
extraCertificates
UniqueCERTCertList
&
builtChain
PinningTelemetryInfo
*
pinningTelemetryInfo
const
char
*
hostname
)
:
mCertDBTrustType
(
certDBTrustType
)
mOCSPFetching
(
ocspFetching
)
mOCSPCache
(
ocspCache
)
mPinArg
(
pinArg
)
mOCSPTimeoutSoft
(
ocspTimeoutSoft
)
mOCSPTimeoutHard
(
ocspTimeoutHard
)
mCertShortLifetimeInDays
(
certShortLifetimeInDays
)
mPinningMode
(
pinningMode
)
mMinRSABits
(
minRSABits
)
mValidityCheckingMode
(
validityCheckingMode
)
mSHA1Mode
(
sha1Mode
)
mNetscapeStepUpPolicy
(
netscapeStepUpPolicy
)
mDistrustedCAPolicy
(
distrustedCAPolicy
)
mSawDistrustedCAByPolicyError
(
false
)
mOriginAttributes
(
originAttributes
)
mThirdPartyRootInputs
(
thirdPartyRootInputs
)
mThirdPartyIntermediateInputs
(
thirdPartyIntermediateInputs
)
mExtraCertificates
(
extraCertificates
)
mBuiltChain
(
builtChain
)
mPinningTelemetryInfo
(
pinningTelemetryInfo
)
mHostname
(
hostname
)
#
ifdef
MOZ_NEW_CERT_STORAGE
mCertStorage
(
do_GetService
(
NS_CERT_STORAGE_CID
)
)
#
else
mCertBlocklist
(
do_GetService
(
NS_CERTBLOCKLIST_CONTRACTID
)
)
#
endif
mOCSPStaplingStatus
(
CertVerifier
:
:
OCSP_STAPLING_NEVER_CHECKED
)
mSCTListFromCertificate
(
)
mSCTListFromOCSPStapling
(
)
mBuiltInRootsModule
(
SECMOD_FindModule
(
kRootModuleName
)
)
{
}
static
Result
FindRootsWithSubject
(
UniqueSECMODModule
&
rootsModule
SECItem
subject
Vector
<
Vector
<
uint8_t
>
>
&
roots
)
{
MOZ_ASSERT
(
rootsModule
)
;
for
(
int
slotIndex
=
0
;
slotIndex
<
rootsModule
-
>
slotCount
;
slotIndex
+
+
)
{
CERTCertificateList
*
rawResults
=
nullptr
;
if
(
PK11_FindRawCertsWithSubject
(
rootsModule
-
>
slots
[
slotIndex
]
&
subject
&
rawResults
)
!
=
SECSuccess
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
!
rawResults
)
{
continue
;
}
UniqueCERTCertificateList
results
(
rawResults
)
;
for
(
int
certIndex
=
0
;
certIndex
<
results
-
>
len
;
certIndex
+
+
)
{
Vector
<
uint8_t
>
root
;
if
(
!
root
.
append
(
results
-
>
certs
[
certIndex
]
.
data
results
-
>
certs
[
certIndex
]
.
len
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
if
(
!
roots
.
append
(
std
:
:
move
(
root
)
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
}
return
Success
;
}
static
bool
ShouldSkipSelfSignedNonTrustAnchor
(
TrustDomain
&
trustDomain
Input
certDER
)
{
BackCert
cert
(
certDER
EndEntityOrCA
:
:
MustBeCA
nullptr
)
;
if
(
cert
.
Init
(
)
!
=
Success
)
{
return
false
;
}
if
(
!
InputsAreEqual
(
cert
.
GetSubject
(
)
cert
.
GetIssuer
(
)
)
)
{
return
false
;
}
TrustLevel
trust
;
if
(
trustDomain
.
GetCertTrust
(
EndEntityOrCA
:
:
MustBeCA
CertPolicyId
:
:
anyPolicy
certDER
trust
)
!
=
Success
)
{
return
false
;
}
if
(
trust
!
=
TrustLevel
:
:
InheritsTrust
)
{
return
false
;
}
uint8_t
digestBuf
[
MAX_DIGEST_SIZE_IN_BYTES
]
;
pkix
:
:
der
:
:
PublicKeyAlgorithm
publicKeyAlg
;
SignedDigest
signature
;
if
(
DigestSignedData
(
trustDomain
cert
.
GetSignedData
(
)
digestBuf
publicKeyAlg
signature
)
!
=
Success
)
{
return
false
;
}
if
(
VerifySignedDigest
(
trustDomain
publicKeyAlg
signature
cert
.
GetSubjectPublicKeyInfo
(
)
)
!
=
Success
)
{
return
false
;
}
return
true
;
}
static
Result
CheckCandidates
(
TrustDomain
&
trustDomain
TrustDomain
:
:
IssuerChecker
&
checker
Vector
<
Input
>
&
candidates
Input
*
nameConstraintsInputPtr
bool
&
keepGoing
)
{
for
(
Input
candidate
:
candidates
)
{
if
(
ShouldSkipSelfSignedNonTrustAnchor
(
trustDomain
candidate
)
)
{
continue
;
}
Result
rv
=
checker
.
Check
(
candidate
nameConstraintsInputPtr
keepGoing
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
!
keepGoing
)
{
return
Success
;
}
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
FindIssuer
(
Input
encodedIssuerName
IssuerChecker
&
checker
Time
)
{
SECItem
encodedIssuerNameItem
=
UnsafeMapInputToSECItem
(
encodedIssuerName
)
;
ScopedAutoSECItem
nameConstraints
;
Input
nameConstraintsInput
;
Input
*
nameConstraintsInputPtr
=
nullptr
;
SECStatus
srv
=
CERT_GetImposedNameConstraints
(
&
encodedIssuerNameItem
&
nameConstraints
)
;
if
(
srv
=
=
SECSuccess
)
{
if
(
nameConstraintsInput
.
Init
(
nameConstraints
.
data
nameConstraints
.
len
)
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nameConstraintsInputPtr
=
&
nameConstraintsInput
;
}
else
if
(
PR_GetError
(
)
!
=
SEC_ERROR_EXTENSION_NOT_FOUND
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Vector
<
Input
>
geckoRootCandidates
;
Vector
<
Input
>
geckoIntermediateCandidates
;
#
ifdef
MOZ_NEW_CERT_STORAGE
if
(
!
mCertStorage
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsTArray
<
uint8_t
>
subject
;
if
(
!
subject
.
AppendElements
(
encodedIssuerName
.
UnsafeGetData
(
)
encodedIssuerName
.
GetLength
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
nsTArray
<
nsTArray
<
uint8_t
>
>
certs
;
nsresult
rv
=
mCertStorage
-
>
FindCertsBySubject
(
subject
certs
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
for
(
auto
&
cert
:
certs
)
{
Input
certDER
;
Result
rv
=
certDER
.
Init
(
cert
.
Elements
(
)
cert
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
if
(
!
geckoIntermediateCandidates
.
append
(
certDER
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
#
endif
Vector
<
Vector
<
uint8_t
>
>
builtInRoots
;
if
(
mBuiltInRootsModule
)
{
Result
rv
=
FindRootsWithSubject
(
mBuiltInRootsModule
encodedIssuerNameItem
builtInRoots
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
for
(
const
auto
&
root
:
builtInRoots
)
{
Input
rootInput
;
rv
=
rootInput
.
Init
(
root
.
begin
(
)
root
.
length
(
)
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
if
(
!
geckoRootCandidates
.
append
(
rootInput
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
}
else
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
:
FindIssuer
:
no
built
-
in
roots
module
"
)
)
;
}
for
(
const
auto
&
thirdPartyRootInput
:
mThirdPartyRootInputs
)
{
BackCert
root
(
thirdPartyRootInput
EndEntityOrCA
:
:
MustBeCA
nullptr
)
;
Result
rv
=
root
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
if
(
!
InputsAreEqual
(
encodedIssuerName
root
.
GetSubject
(
)
)
)
{
continue
;
}
if
(
!
geckoRootCandidates
.
append
(
thirdPartyRootInput
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
for
(
const
auto
&
thirdPartyIntermediateInput
:
mThirdPartyIntermediateInputs
)
{
BackCert
intermediate
(
thirdPartyIntermediateInput
EndEntityOrCA
:
:
MustBeCA
nullptr
)
;
Result
rv
=
intermediate
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
if
(
!
InputsAreEqual
(
encodedIssuerName
intermediate
.
GetSubject
(
)
)
)
{
continue
;
}
if
(
!
geckoIntermediateCandidates
.
append
(
thirdPartyIntermediateInput
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
if
(
mExtraCertificates
.
isSome
(
)
)
{
for
(
const
auto
&
extraCert
:
*
mExtraCertificates
)
{
Input
certInput
;
Result
rv
=
certInput
.
Init
(
extraCert
.
Elements
(
)
extraCert
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
BackCert
cert
(
certInput
EndEntityOrCA
:
:
MustBeCA
nullptr
)
;
rv
=
cert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
if
(
!
InputsAreEqual
(
encodedIssuerName
cert
.
GetSubject
(
)
)
)
{
continue
;
}
if
(
!
geckoIntermediateCandidates
.
append
(
certInput
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
}
if
(
!
geckoRootCandidates
.
appendAll
(
geckoIntermediateCandidates
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
bool
keepGoing
=
true
;
Result
result
=
CheckCandidates
(
*
this
checker
geckoRootCandidates
nameConstraintsInputPtr
keepGoing
)
;
if
(
result
!
=
Success
)
{
return
result
;
}
if
(
!
keepGoing
)
{
return
Success
;
}
UniqueCERTCertList
candidates
(
CERT_CreateSubjectCertList
(
nullptr
CERT_GetDefaultCertDB
(
)
&
encodedIssuerNameItem
0
false
)
)
;
Vector
<
Input
>
nssRootCandidates
;
Vector
<
Input
>
nssIntermediateCandidates
;
if
(
candidates
)
{
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
candidates
)
;
!
CERT_LIST_END
(
n
candidates
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
Input
certDER
;
Result
rv
=
certDER
.
Init
(
n
-
>
cert
-
>
derCert
.
data
n
-
>
cert
-
>
derCert
.
len
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
if
(
n
-
>
cert
-
>
isRoot
)
{
if
(
!
nssRootCandidates
.
append
(
certDER
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
else
{
if
(
!
nssIntermediateCandidates
.
append
(
certDER
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
}
}
if
(
!
nssRootCandidates
.
appendAll
(
nssIntermediateCandidates
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
return
CheckCandidates
(
*
this
checker
nssRootCandidates
nameConstraintsInputPtr
keepGoing
)
;
}
Result
NSSCertDBTrustDomain
:
:
GetCertTrust
(
EndEntityOrCA
endEntityOrCA
const
CertPolicyId
&
policy
Input
candidateCertDER
TrustLevel
&
trustLevel
)
{
#
ifdef
MOZ_NEW_CERT_STORAGE
if
(
!
mCertStorage
)
{
#
else
if
(
!
mCertBlocklist
)
{
#
endif
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
mCertDBTrustType
=
=
trustSSL
)
{
#
ifdef
MOZ_NEW_CERT_STORAGE
int16_t
revocationState
;
nsTArray
<
uint8_t
>
issuerBytes
;
nsTArray
<
uint8_t
>
serialBytes
;
nsTArray
<
uint8_t
>
subjectBytes
;
nsTArray
<
uint8_t
>
pubKeyBytes
;
Result
result
=
BuildRevocationCheckArrays
(
candidateCertDER
endEntityOrCA
issuerBytes
serialBytes
subjectBytes
pubKeyBytes
)
;
#
else
bool
isCertRevoked
;
nsAutoCString
encIssuer
;
nsAutoCString
encSerial
;
nsAutoCString
encSubject
;
nsAutoCString
encPubKey
;
Result
result
=
BuildRevocationCheckStrings
(
candidateCertDER
endEntityOrCA
encIssuer
encSerial
encSubject
encPubKey
)
;
#
endif
if
(
result
!
=
Success
)
{
return
result
;
}
#
ifdef
MOZ_NEW_CERT_STORAGE
nsresult
nsrv
=
mCertStorage
-
>
GetRevocationState
(
issuerBytes
serialBytes
subjectBytes
pubKeyBytes
&
revocationState
)
;
#
else
nsresult
nsrv
=
mCertBlocklist
-
>
IsCertRevoked
(
encIssuer
encSerial
encSubject
encPubKey
&
isCertRevoked
)
;
#
endif
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
#
ifdef
MOZ_NEW_CERT_STORAGE
if
(
revocationState
=
=
nsICertStorage
:
:
STATE_ENFORCE
)
{
#
else
if
(
isCertRevoked
)
{
#
endif
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
certificate
is
in
blocklist
"
)
)
;
return
Result
:
:
ERROR_REVOKED_CERTIFICATE
;
}
}
for
(
const
auto
&
thirdPartyRootInput
:
mThirdPartyRootInputs
)
{
if
(
InputsAreEqual
(
candidateCertDER
thirdPartyRootInput
)
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
}
for
(
const
auto
&
thirdPartyIntermediateInput
:
mThirdPartyIntermediateInputs
)
{
if
(
InputsAreEqual
(
candidateCertDER
thirdPartyIntermediateInput
)
)
{
trustLevel
=
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
}
SECItem
candidateCertDERSECItem
=
UnsafeMapInputToSECItem
(
candidateCertDER
)
;
UniqueCERTCertificate
candidateCert
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
candidateCertDERSECItem
nullptr
false
true
)
)
;
if
(
!
candidateCert
)
{
return
MapPRErrorCodeToResult
(
PR_GetError
(
)
)
;
}
CERTCertTrust
trust
;
if
(
CERT_GetCertTrust
(
candidateCert
.
get
(
)
&
trust
)
=
=
SECSuccess
)
{
uint32_t
flags
=
SEC_GET_TRUST_FLAGS
(
&
trust
mCertDBTrustType
)
;
uint32_t
relevantTrustBit
=
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
?
CERTDB_TRUSTED_CA
:
CERTDB_TRUSTED
;
if
(
(
(
flags
&
(
relevantTrustBit
|
CERTDB_TERMINAL_RECORD
)
)
)
=
=
CERTDB_TERMINAL_RECORD
)
{
trustLevel
=
TrustLevel
:
:
ActivelyDistrusted
;
return
Success
;
}
if
(
flags
&
CERTDB_TRUSTED_CA
)
{
if
(
policy
.
IsAnyPolicy
(
)
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
if
(
CertIsAuthoritativeForEVPolicy
(
candidateCert
policy
)
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
}
}
trustLevel
=
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
DigestBuf
(
Input
item
DigestAlgorithm
digestAlg
uint8_t
*
digestBuf
size_t
digestBufLen
)
{
return
DigestBufNSS
(
item
digestAlg
digestBuf
digestBufLen
)
;
}
TimeDuration
NSSCertDBTrustDomain
:
:
GetOCSPTimeout
(
)
const
{
switch
(
mOCSPFetching
)
{
case
NSSCertDBTrustDomain
:
:
FetchOCSPForDVSoftFail
:
return
mOCSPTimeoutSoft
;
case
NSSCertDBTrustDomain
:
:
FetchOCSPForEV
:
case
NSSCertDBTrustDomain
:
:
FetchOCSPForDVHardFail
:
return
mOCSPTimeoutHard
;
case
NSSCertDBTrustDomain
:
:
NeverFetchOCSP
:
case
NSSCertDBTrustDomain
:
:
LocalOnlyOCSPForEV
:
MOZ_ASSERT_UNREACHABLE
(
"
we
should
never
see
this
OCSPFetching
type
here
"
)
;
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
we
'
re
not
handling
every
OCSPFetching
type
"
)
;
return
mOCSPTimeoutSoft
;
}
static
Result
GetOCSPAuthorityInfoAccessLocation
(
const
UniquePLArenaPool
&
arena
Input
aiaExtension
nsCString
&
result
)
{
MOZ_ASSERT
(
arena
.
get
(
)
)
;
if
(
!
arena
.
get
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
result
.
Assign
(
VoidCString
(
)
)
;
SECItem
aiaExtensionSECItem
=
UnsafeMapInputToSECItem
(
aiaExtension
)
;
CERTAuthInfoAccess
*
*
aia
=
CERT_DecodeAuthInfoAccessExtension
(
arena
.
get
(
)
&
aiaExtensionSECItem
)
;
if
(
!
aia
)
{
return
Result
:
:
ERROR_CERT_BAD_ACCESS_LOCATION
;
}
for
(
size_t
i
=
0
;
aia
[
i
]
;
+
+
i
)
{
if
(
SECOID_FindOIDTag
(
&
aia
[
i
]
-
>
method
)
=
=
SEC_OID_PKIX_OCSP
)
{
CERTGeneralName
*
current
=
aia
[
i
]
-
>
location
;
if
(
!
current
)
{
continue
;
}
do
{
if
(
current
-
>
type
=
=
certURI
)
{
const
SECItem
&
location
=
current
-
>
name
.
other
;
if
(
location
.
len
>
1024
|
|
memchr
(
location
.
data
0
location
.
len
)
)
{
return
Result
:
:
ERROR_CERT_BAD_ACCESS_LOCATION
;
}
result
.
Assign
(
nsDependentCSubstring
(
reinterpret_cast
<
const
char
*
>
(
location
.
data
)
location
.
len
)
)
;
return
Success
;
}
current
=
CERT_GetNextGeneralName
(
current
)
;
}
while
(
current
!
=
aia
[
i
]
-
>
location
)
;
}
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
CheckRevocation
(
EndEntityOrCA
endEntityOrCA
const
CertID
&
certID
Time
time
Duration
validityDuration
const
Input
*
stapledOCSPResponse
const
Input
*
aiaExtension
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
Top
of
CheckRevocation
\
n
"
)
)
;
uint16_t
maxOCSPLifetimeInDays
=
10
;
if
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
)
{
maxOCSPLifetimeInDays
=
365
;
}
Result
stapledOCSPResponseResult
=
Success
;
if
(
stapledOCSPResponse
)
{
MOZ_ASSERT
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeEndEntity
)
;
bool
expired
;
stapledOCSPResponseResult
=
VerifyAndMaybeCacheEncodedOCSPResponse
(
certID
time
maxOCSPLifetimeInDays
*
stapledOCSPResponse
ResponseWasStapled
expired
)
;
if
(
stapledOCSPResponseResult
=
=
Success
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_GOOD
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
stapled
OCSP
response
:
good
"
)
)
;
return
Success
;
}
if
(
stapledOCSPResponseResult
=
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
|
|
expired
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_EXPIRED
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
expired
stapled
OCSP
response
"
)
)
;
}
else
if
(
stapledOCSPResponseResult
=
=
Result
:
:
ERROR_OCSP_TRY_SERVER_LATER
|
|
stapledOCSPResponseResult
=
=
Result
:
:
ERROR_OCSP_INVALID_SIGNING_CERT
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_INVALID
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
stapled
OCSP
response
:
"
"
failure
(
whitelisted
for
compatibility
)
"
)
)
;
}
else
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_INVALID
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
stapled
OCSP
response
:
failure
"
)
)
;
return
stapledOCSPResponseResult
;
}
}
else
if
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeEndEntity
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_NONE
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
no
stapled
OCSP
response
"
)
)
;
}
Result
cachedResponseResult
=
Success
;
Time
cachedResponseValidThrough
(
Time
:
:
uninitialized
)
;
bool
cachedResponsePresent
=
mOCSPCache
.
Get
(
certID
mOriginAttributes
cachedResponseResult
cachedResponseValidThrough
)
;
if
(
cachedResponsePresent
)
{
if
(
cachedResponseResult
=
=
Success
&
&
cachedResponseValidThrough
>
=
time
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
cached
OCSP
response
:
good
"
)
)
;
return
Success
;
}
if
(
cachedResponseResult
=
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
cached
OCSP
response
:
revoked
"
)
)
;
return
Result
:
:
ERROR_REVOKED_CERTIFICATE
;
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
cached
OCSP
response
:
error
%
d
"
static_cast
<
int
>
(
cachedResponseResult
)
)
)
;
if
(
cachedResponseResult
=
=
Success
&
&
cachedResponseValidThrough
<
time
)
{
cachedResponseResult
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
;
}
if
(
cachedResponseResult
!
=
Success
&
&
cachedResponseResult
!
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
&
&
cachedResponseResult
!
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
&
&
cachedResponseValidThrough
<
time
)
{
cachedResponseResult
=
Success
;
cachedResponsePresent
=
false
;
}
}
else
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
no
cached
OCSP
response
"
)
)
;
}
MOZ_ASSERT
(
(
!
cachedResponsePresent
&
&
cachedResponseResult
=
=
Success
)
|
|
(
cachedResponsePresent
&
&
cachedResponseResult
!
=
Success
)
)
;
bool
blocklistIsFresh
;
#
ifdef
MOZ_NEW_CERT_STORAGE
nsresult
nsrv
=
mCertStorage
-
>
IsBlocklistFresh
(
&
blocklistIsFresh
)
;
#
else
nsresult
nsrv
=
mCertBlocklist
-
>
IsBlocklistFresh
(
&
blocklistIsFresh
)
;
#
endif
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Duration
shortLifetime
(
mCertShortLifetimeInDays
*
Time
:
:
ONE_DAY_IN_SECONDS
)
;
if
(
(
mOCSPFetching
=
=
NeverFetchOCSP
)
|
|
(
validityDuration
<
shortLifetime
)
|
|
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
&
&
(
mOCSPFetching
=
=
FetchOCSPForDVHardFail
|
|
mOCSPFetching
=
=
FetchOCSPForDVSoftFail
|
|
blocklistIsFresh
)
)
)
{
if
(
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
return
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
;
}
if
(
mOCSPFetching
=
=
FetchOCSPForDVHardFail
&
&
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
)
{
return
Result
:
:
ERROR_OCSP_OLD_RESPONSE
;
}
return
Success
;
}
if
(
mOCSPFetching
=
=
LocalOnlyOCSPForEV
)
{
if
(
cachedResponseResult
!
=
Success
)
{
return
cachedResponseResult
;
}
return
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
;
}
UniquePLArenaPool
arena
(
PORT_NewArena
(
DER_DEFAULT_CHUNKSIZE
)
)
;
if
(
!
arena
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
Result
rv
;
nsCString
aiaLocation
(
VoidCString
(
)
)
;
if
(
aiaExtension
)
{
rv
=
GetOCSPAuthorityInfoAccessLocation
(
arena
*
aiaExtension
aiaLocation
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
if
(
aiaLocation
.
IsVoid
(
)
)
{
if
(
mOCSPFetching
=
=
FetchOCSPForEV
|
|
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
return
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
;
}
if
(
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
)
{
return
Result
:
:
ERROR_OCSP_OLD_RESPONSE
;
}
if
(
stapledOCSPResponseResult
!
=
Success
)
{
return
stapledOCSPResponseResult
;
}
return
Success
;
}
if
(
cachedResponseResult
=
=
Success
|
|
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
|
|
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
)
{
return
SynchronousCheckRevocationWithServer
(
certID
aiaLocation
time
maxOCSPLifetimeInDays
cachedResponseResult
stapledOCSPResponseResult
)
;
}
return
HandleOCSPFailure
(
cachedResponseResult
stapledOCSPResponseResult
cachedResponseResult
)
;
}
Result
NSSCertDBTrustDomain
:
:
SynchronousCheckRevocationWithServer
(
const
CertID
&
certID
const
nsCString
&
aiaLocation
Time
time
uint16_t
maxOCSPLifetimeInDays
const
Result
cachedResponseResult
const
Result
stapledOCSPResponseResult
)
{
uint8_t
ocspRequestBytes
[
OCSP_REQUEST_MAX_LENGTH
]
;
size_t
ocspRequestLength
;
Result
rv
=
CreateEncodedOCSPRequest
(
*
this
certID
ocspRequestBytes
ocspRequestLength
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Vector
<
uint8_t
>
ocspResponse
;
Input
response
;
rv
=
DoOCSPRequest
(
aiaLocation
mOriginAttributes
ocspRequestBytes
ocspRequestLength
GetOCSPTimeout
(
)
ocspResponse
)
;
if
(
rv
=
=
Success
&
&
response
.
Init
(
ocspResponse
.
begin
(
)
ocspResponse
.
length
(
)
)
!
=
Success
)
{
rv
=
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
if
(
rv
!
=
Success
)
{
Time
timeout
(
time
)
;
if
(
timeout
.
AddSeconds
(
ServerFailureDelaySeconds
)
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Result
cacheRV
=
mOCSPCache
.
Put
(
certID
mOriginAttributes
rv
time
timeout
)
;
if
(
cacheRV
!
=
Success
)
{
return
cacheRV
;
}
return
HandleOCSPFailure
(
cachedResponseResult
stapledOCSPResponseResult
rv
)
;
}
bool
expired
;
rv
=
VerifyAndMaybeCacheEncodedOCSPResponse
(
certID
time
maxOCSPLifetimeInDays
response
ResponseIsFromNetwork
expired
)
;
if
(
rv
=
=
Success
|
|
mOCSPFetching
!
=
FetchOCSPForDVSoftFail
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
after
"
"
VerifyEncodedOCSPResponse
"
)
)
;
return
rv
;
}
if
(
rv
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
|
|
rv
=
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
)
{
return
rv
;
}
if
(
stapledOCSPResponseResult
!
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECFailure
from
expired
/
invalid
"
"
stapled
response
after
OCSP
request
verification
failure
"
)
)
;
return
stapledOCSPResponseResult
;
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
end
of
CheckRevocation
"
)
)
;
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
HandleOCSPFailure
(
const
Result
cachedResponseResult
const
Result
stapledOCSPResponseResult
const
Result
error
)
{
if
(
mOCSPFetching
!
=
FetchOCSPForDVSoftFail
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECFailure
after
OCSP
request
"
"
failure
"
)
)
;
return
error
;
}
if
(
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECFailure
from
cached
response
"
"
after
OCSP
request
failure
"
)
)
;
return
cachedResponseResult
;
}
if
(
stapledOCSPResponseResult
!
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECFailure
from
expired
/
invalid
"
"
stapled
response
after
OCSP
request
failure
"
)
)
;
return
stapledOCSPResponseResult
;
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECSuccess
after
OCSP
request
"
"
failure
"
)
)
;
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
VerifyAndMaybeCacheEncodedOCSPResponse
(
const
CertID
&
certID
Time
time
uint16_t
maxLifetimeInDays
Input
encodedResponse
EncodedResponseSource
responseSource
bool
&
expired
)
{
Time
thisUpdate
(
Time
:
:
uninitialized
)
;
Time
validThrough
(
Time
:
:
uninitialized
)
;
OCSPVerificationTrustDomain
trustDomain
(
*
this
)
;
Result
rv
=
VerifyEncodedOCSPResponse
(
trustDomain
certID
time
maxLifetimeInDays
encodedResponse
expired
&
thisUpdate
&
validThrough
)
;
if
(
responseSource
=
=
ResponseWasStapled
&
&
expired
)
{
MOZ_ASSERT
(
rv
!
=
Success
)
;
return
rv
;
}
if
(
rv
!
=
Success
&
&
rv
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
&
&
rv
!
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
validThrough
=
time
;
if
(
validThrough
.
AddSeconds
(
ServerFailureDelaySeconds
)
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
}
if
(
responseSource
=
=
ResponseIsFromNetwork
|
|
rv
=
=
Success
|
|
rv
=
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
|
|
rv
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
caching
OCSP
response
"
)
)
;
Result
putRV
=
mOCSPCache
.
Put
(
certID
mOriginAttributes
rv
thisUpdate
validThrough
)
;
if
(
putRV
!
=
Success
)
{
return
putRV
;
}
}
return
rv
;
}
static
Result
CheckForStartComOrWoSign
(
const
UniqueCERTCertList
&
certChain
)
{
if
(
CERT_LIST_EMPTY
(
certChain
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
const
CERTCertListNode
*
endEntityNode
=
CERT_LIST_HEAD
(
certChain
)
;
if
(
!
endEntityNode
|
|
!
endEntityNode
-
>
cert
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
PRTime
notBefore
;
PRTime
notAfter
;
if
(
CERT_GetCertTimes
(
endEntityNode
-
>
cert
&
notBefore
&
notAfter
)
!
=
SECSuccess
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
static
const
PRTime
OCTOBER_21_2016
=
1477008000000000
;
if
(
notBefore
<
=
OCTOBER_21_2016
)
{
return
Success
;
}
for
(
const
CERTCertListNode
*
node
=
CERT_LIST_HEAD
(
certChain
)
;
!
CERT_LIST_END
(
node
certChain
)
;
node
=
CERT_LIST_NEXT
(
node
)
)
{
if
(
!
node
|
|
!
node
-
>
cert
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
CertDNIsInList
(
node
-
>
cert
StartComAndWoSignDNs
)
)
{
return
Result
:
:
ERROR_REVOKED_CERTIFICATE
;
}
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
IsChainValid
(
const
DERArray
&
certArray
Time
time
const
CertPolicyId
&
requiredPolicy
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
IsChainValid
"
)
)
;
UniqueCERTCertList
certList
;
SECStatus
srv
=
ConstructCERTCertListFromReversedDERArray
(
certArray
certList
)
;
if
(
srv
!
=
SECSuccess
)
{
return
MapPRErrorCodeToResult
(
PR_GetError
(
)
)
;
}
if
(
CERT_LIST_EMPTY
(
certList
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Result
rv
=
CheckForStartComOrWoSign
(
certList
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
nssCertList
;
nsresult
nsrv
=
nsNSSCertificateDB
:
:
ConstructCertArrayFromUniqueCertList
(
certList
nssCertList
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsCOMPtr
<
nsIX509Cert
>
rootCert
;
nsrv
=
nsNSSCertificate
:
:
GetRootCertificate
(
nssCertList
rootCert
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
UniqueCERTCertificate
root
(
rootCert
-
>
GetCert
(
)
)
;
if
(
!
root
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
bool
isBuiltInRoot
=
false
;
nsrv
=
rootCert
-
>
GetIsBuiltInRoot
(
&
isBuiltInRoot
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
bool
skipPinningChecksBecauseOfMITMMode
=
(
!
isBuiltInRoot
&
&
mPinningMode
=
=
CertVerifier
:
:
pinningAllowUserCAMITM
)
;
if
(
mHostname
&
&
(
mPinningMode
!
=
CertVerifier
:
:
pinningDisabled
)
&
&
!
skipPinningChecksBecauseOfMITMMode
)
{
bool
enforceTestMode
=
(
mPinningMode
=
=
CertVerifier
:
:
pinningEnforceTestMode
)
;
bool
chainHasValidPins
;
nsrv
=
PublicKeyPinningService
:
:
ChainHasValidPins
(
nssCertList
mHostname
time
enforceTestMode
mOriginAttributes
chainHasValidPins
mPinningTelemetryInfo
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
!
chainHasValidPins
)
{
return
Result
:
:
ERROR_KEY_PINNING_FAILURE
;
}
}
if
(
mHostname
&
&
CertDNIsInList
(
root
.
get
(
)
RootSymantecDNs
)
&
&
(
(
mDistrustedCAPolicy
&
DistrustedCAPolicy
:
:
DistrustSymantecRoots
)
|
|
(
mDistrustedCAPolicy
&
DistrustedCAPolicy
:
:
DistrustSymantecRootsRegardlessOfDate
)
)
)
{
rootCert
=
nullptr
;
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
intCerts
;
nsCOMPtr
<
nsIX509Cert
>
eeCert
;
nsrv
=
nsNSSCertificate
:
:
SegmentCertificateChain
(
nssCertList
rootCert
intCerts
eeCert
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
static
const
PRTime
JUNE_1_2016
=
1464739200000000
;
PRTime
permitAfterDate
=
JUNE_1_2016
;
if
(
mDistrustedCAPolicy
&
DistrustedCAPolicy
:
:
DistrustSymantecRootsRegardlessOfDate
)
{
permitAfterDate
=
0
;
}
bool
isDistrusted
=
false
;
nsrv
=
CheckForSymantecDistrust
(
intCerts
eeCert
permitAfterDate
RootAppleAndGoogleSPKIs
isDistrusted
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
isDistrusted
)
{
mSawDistrustedCAByPolicyError
=
true
;
return
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
}
mBuiltChain
=
std
:
:
move
(
certList
)
;
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
CheckSignatureDigestAlgorithm
(
DigestAlgorithm
aAlg
EndEntityOrCA
endEntityOrCA
Time
notBefore
)
{
static
const
Time
JANUARY_FIRST_2016
=
TimeFromEpochInSeconds
(
1451606400
)
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
CheckSignatureDigestAlgorithm
"
)
)
;
if
(
aAlg
=
=
DigestAlgorithm
:
:
sha1
)
{
switch
(
mSHA1Mode
)
{
case
CertVerifier
:
:
SHA1Mode
:
:
Forbidden
:
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SHA
-
1
certificate
rejected
"
)
)
;
return
Result
:
:
ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
;
case
CertVerifier
:
:
SHA1Mode
:
:
ImportedRootOrBefore2016
:
if
(
JANUARY_FIRST_2016
<
=
notBefore
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Post
-
2015
SHA
-
1
certificate
rejected
"
)
)
;
return
Result
:
:
ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
;
}
break
;
case
CertVerifier
:
:
SHA1Mode
:
:
Allowed
:
case
CertVerifier
:
:
SHA1Mode
:
:
ImportedRoot
:
default
:
break
;
case
CertVerifier
:
:
SHA1Mode
:
:
UsedToBeBefore2016ButNowIsForbidden
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
SHA1Mode
type
"
)
;
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
CheckRSAPublicKeyModulusSizeInBits
(
EndEntityOrCA
unsigned
int
modulusSizeInBits
)
{
if
(
modulusSizeInBits
<
mMinRSABits
)
{
return
Result
:
:
ERROR_INADEQUATE_KEY_SIZE
;
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
VerifyRSAPKCS1SignedDigest
(
const
SignedDigest
&
signedDigest
Input
subjectPublicKeyInfo
)
{
return
VerifyRSAPKCS1SignedDigestNSS
(
signedDigest
subjectPublicKeyInfo
mPinArg
)
;
}
Result
NSSCertDBTrustDomain
:
:
CheckECDSACurveIsAcceptable
(
EndEntityOrCA
NamedCurve
curve
)
{
switch
(
curve
)
{
case
NamedCurve
:
:
secp256r1
:
case
NamedCurve
:
:
secp384r1
:
case
NamedCurve
:
:
secp521r1
:
return
Success
;
}
return
Result
:
:
ERROR_UNSUPPORTED_ELLIPTIC_CURVE
;
}
Result
NSSCertDBTrustDomain
:
:
VerifyECDSASignedDigest
(
const
SignedDigest
&
signedDigest
Input
subjectPublicKeyInfo
)
{
return
VerifyECDSASignedDigestNSS
(
signedDigest
subjectPublicKeyInfo
mPinArg
)
;
}
Result
NSSCertDBTrustDomain
:
:
CheckValidityIsAcceptable
(
Time
notBefore
Time
notAfter
EndEntityOrCA
endEntityOrCA
KeyPurposeId
keyPurpose
)
{
if
(
endEntityOrCA
!
=
EndEntityOrCA
:
:
MustBeEndEntity
)
{
return
Success
;
}
if
(
keyPurpose
=
=
KeyPurposeId
:
:
id_kp_OCSPSigning
)
{
return
Success
;
}
Duration
DURATION_27_MONTHS_PLUS_SLOP
(
(
2
*
365
+
3
*
31
+
7
)
*
Time
:
:
ONE_DAY_IN_SECONDS
)
;
Duration
maxValidityDuration
(
UINT64_MAX
)
;
Duration
validityDuration
(
notBefore
notAfter
)
;
switch
(
mValidityCheckingMode
)
{
case
ValidityCheckingMode
:
:
CheckingOff
:
return
Success
;
case
ValidityCheckingMode
:
:
CheckForEV
:
maxValidityDuration
=
DURATION_27_MONTHS_PLUS_SLOP
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
We
'
re
not
handling
every
ValidityCheckingMode
type
"
)
;
}
if
(
validityDuration
>
maxValidityDuration
)
{
return
Result
:
:
ERROR_VALIDITY_TOO_LONG
;
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
NetscapeStepUpMatchesServerAuth
(
Time
notBefore
bool
&
matches
)
{
static
const
Time
AUGUST_23_2015
=
TimeFromEpochInSeconds
(
1440288000
)
;
static
const
Time
AUGUST_23_2016
=
TimeFromEpochInSeconds
(
1471910400
)
;
switch
(
mNetscapeStepUpPolicy
)
{
case
NetscapeStepUpPolicy
:
:
AlwaysMatch
:
matches
=
true
;
return
Success
;
case
NetscapeStepUpPolicy
:
:
MatchBefore23August2016
:
matches
=
notBefore
<
AUGUST_23_2016
;
return
Success
;
case
NetscapeStepUpPolicy
:
:
MatchBefore23August2015
:
matches
=
notBefore
<
AUGUST_23_2015
;
return
Success
;
case
NetscapeStepUpPolicy
:
:
NeverMatch
:
matches
=
false
;
return
Success
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unhandled
NetscapeStepUpPolicy
type
"
)
;
}
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
void
NSSCertDBTrustDomain
:
:
ResetAccumulatedState
(
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_NEVER_CHECKED
;
mSCTListFromOCSPStapling
=
nullptr
;
mSCTListFromCertificate
=
nullptr
;
mSawDistrustedCAByPolicyError
=
false
;
}
static
Input
SECItemToInput
(
const
UniqueSECItem
&
item
)
{
Input
result
;
if
(
item
)
{
MOZ_ASSERT
(
item
-
>
type
=
=
siBuffer
)
;
Result
rv
=
result
.
Init
(
item
-
>
data
item
-
>
len
)
;
MOZ_ASSERT
(
rv
=
=
Success
)
;
Unused
<
<
rv
;
}
return
result
;
}
Input
NSSCertDBTrustDomain
:
:
GetSCTListFromCertificate
(
)
const
{
return
SECItemToInput
(
mSCTListFromCertificate
)
;
}
Input
NSSCertDBTrustDomain
:
:
GetSCTListFromOCSPStapling
(
)
const
{
return
SECItemToInput
(
mSCTListFromOCSPStapling
)
;
}
bool
NSSCertDBTrustDomain
:
:
GetIsErrorDueToDistrustedCAPolicy
(
)
const
{
return
mSawDistrustedCAByPolicyError
;
}
void
NSSCertDBTrustDomain
:
:
NoteAuxiliaryExtension
(
AuxiliaryExtension
extension
Input
extensionData
)
{
UniqueSECItem
*
out
=
nullptr
;
switch
(
extension
)
{
case
AuxiliaryExtension
:
:
EmbeddedSCTList
:
out
=
&
mSCTListFromCertificate
;
break
;
case
AuxiliaryExtension
:
:
SCTListFromOCSPResponse
:
out
=
&
mSCTListFromOCSPStapling
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unhandled
AuxiliaryExtension
"
)
;
}
if
(
out
)
{
SECItem
extensionDataItem
=
UnsafeMapInputToSECItem
(
extensionData
)
;
out
-
>
reset
(
SECITEM_DupItem
(
&
extensionDataItem
)
)
;
}
}
SECStatus
InitializeNSS
(
const
nsACString
&
dir
NSSDBConfig
nssDbConfig
PKCS11DBConfig
pkcs11DbConfig
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
uint32_t
flags
=
NSS_INIT_NOROOTINIT
|
NSS_INIT_OPTIMIZESPACE
;
if
(
nssDbConfig
=
=
NSSDBConfig
:
:
ReadOnly
)
{
flags
|
=
NSS_INIT_READONLY
;
}
if
(
pkcs11DbConfig
=
=
PKCS11DBConfig
:
:
DoNotLoadModules
)
{
flags
|
=
NSS_INIT_NOMODDB
;
}
nsAutoCString
dbTypeAndDirectory
(
"
sql
:
"
)
;
dbTypeAndDirectory
.
Append
(
dir
)
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
InitializeNSS
(
%
s
%
d
%
d
)
"
dbTypeAndDirectory
.
get
(
)
(
int
)
nssDbConfig
(
int
)
pkcs11DbConfig
)
)
;
SECStatus
srv
=
NSS_Initialize
(
dbTypeAndDirectory
.
get
(
)
"
"
"
"
SECMOD_DB
flags
)
;
if
(
srv
!
=
SECSuccess
)
{
return
srv
;
}
if
(
nssDbConfig
=
=
NSSDBConfig
:
:
ReadWrite
)
{
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
SECFailure
;
}
if
(
PK11_NeedUserInit
(
slot
.
get
(
)
)
)
{
srv
=
PK11_InitPin
(
slot
.
get
(
)
nullptr
nullptr
)
;
MOZ_ASSERT
(
srv
=
=
SECSuccess
)
;
Unused
<
<
srv
;
}
}
return
SECSuccess
;
}
void
DisableMD5
(
)
{
NSS_SetAlgorithmPolicy
(
SEC_OID_MD5
0
NSS_USE_ALG_IN_CERT_SIGNATURE
|
NSS_USE_ALG_IN_CMS_SIGNATURE
)
;
NSS_SetAlgorithmPolicy
(
SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION
0
NSS_USE_ALG_IN_CERT_SIGNATURE
|
NSS_USE_ALG_IN_CMS_SIGNATURE
)
;
NSS_SetAlgorithmPolicy
(
SEC_OID_PKCS5_PBE_WITH_MD5_AND_DES_CBC
0
NSS_USE_ALG_IN_CERT_SIGNATURE
|
NSS_USE_ALG_IN_CMS_SIGNATURE
)
;
}
bool
LoadLoadableRoots
(
const
nsCString
&
dir
)
{
int
unusedModType
;
Unused
<
<
SECMOD_DeleteModule
(
kRootModuleName
&
unusedModType
)
;
Unused
<
<
SECMOD_DeleteModule
(
"
Root
Certs
"
&
unusedModType
)
;
nsAutoCString
fullLibraryPath
;
if
(
!
dir
.
IsEmpty
(
)
)
{
fullLibraryPath
.
Assign
(
dir
)
;
fullLibraryPath
.
AppendLiteral
(
FILE_PATH_SEPARATOR
)
;
}
fullLibraryPath
.
Append
(
MOZ_DLL_PREFIX
"
nssckbi
"
MOZ_DLL_SUFFIX
)
;
fullLibraryPath
.
ReplaceSubstring
(
"
\
\
"
"
\
\
\
\
"
)
;
fullLibraryPath
.
ReplaceSubstring
(
"
\
"
"
"
\
\
\
"
"
)
;
nsAutoCString
pkcs11ModuleSpec
(
"
name
=
\
"
"
)
;
pkcs11ModuleSpec
.
Append
(
kRootModuleName
)
;
pkcs11ModuleSpec
.
AppendLiteral
(
"
\
"
library
=
\
"
"
)
;
pkcs11ModuleSpec
.
Append
(
fullLibraryPath
)
;
pkcs11ModuleSpec
.
AppendLiteral
(
"
\
"
"
)
;
UniqueSECMODModule
rootsModule
(
SECMOD_LoadUserModule
(
const_cast
<
char
*
>
(
pkcs11ModuleSpec
.
get
(
)
)
nullptr
false
)
)
;
if
(
!
rootsModule
)
{
return
false
;
}
if
(
!
rootsModule
-
>
loaded
)
{
return
false
;
}
return
true
;
}
void
UnloadLoadableRoots
(
)
{
UniqueSECMODModule
rootsModule
(
SECMOD_FindModule
(
kRootModuleName
)
)
;
if
(
rootsModule
)
{
SECMOD_UnloadUserModule
(
rootsModule
.
get
(
)
)
;
}
}
nsresult
DefaultServerNicknameForCert
(
const
CERTCertificate
*
cert
nsCString
&
nickname
)
{
MOZ_ASSERT
(
cert
)
;
NS_ENSURE_ARG_POINTER
(
cert
)
;
UniquePORTString
baseName
(
CERT_GetCommonName
(
&
cert
-
>
subject
)
)
;
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetOrgUnitName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetOrgName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetLocalityName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetStateName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetCountryName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
return
NS_ERROR_FAILURE
;
}
static
const
uint32_t
ARBITRARY_LIMIT
=
500
;
for
(
uint32_t
count
=
1
;
count
<
ARBITRARY_LIMIT
;
count
+
+
)
{
nickname
=
baseName
.
get
(
)
;
if
(
count
!
=
1
)
{
nickname
.
AppendPrintf
(
"
#
%
u
"
count
)
;
}
if
(
nickname
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
conflict
=
SEC_CertNicknameConflict
(
nickname
.
get
(
)
&
cert
-
>
derSubject
cert
-
>
dbhandle
)
;
if
(
!
conflict
)
{
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
#
ifdef
MOZ_NEW_CERT_STORAGE
Result
BuildRevocationCheckArrays
(
Input
certDER
EndEntityOrCA
endEntityOrCA
nsTArray
<
uint8_t
>
&
issuerBytes
nsTArray
<
uint8_t
>
&
serialBytes
nsTArray
<
uint8_t
>
&
subjectBytes
nsTArray
<
uint8_t
>
&
pubKeyBytes
)
{
BackCert
cert
(
certDER
endEntityOrCA
nullptr
)
;
Result
rv
=
cert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
issuerBytes
.
Clear
(
)
;
Input
issuer
(
cert
.
GetIssuer
(
)
)
;
issuerBytes
.
AppendElements
(
issuer
.
UnsafeGetData
(
)
issuer
.
GetLength
(
)
)
;
serialBytes
.
Clear
(
)
;
Input
serial
(
cert
.
GetSerialNumber
(
)
)
;
serialBytes
.
AppendElements
(
serial
.
UnsafeGetData
(
)
serial
.
GetLength
(
)
)
;
subjectBytes
.
Clear
(
)
;
Input
subject
(
cert
.
GetSubject
(
)
)
;
subjectBytes
.
AppendElements
(
subject
.
UnsafeGetData
(
)
subject
.
GetLength
(
)
)
;
pubKeyBytes
.
Clear
(
)
;
Input
pubKey
(
cert
.
GetSubjectPublicKeyInfo
(
)
)
;
pubKeyBytes
.
AppendElements
(
pubKey
.
UnsafeGetData
(
)
pubKey
.
GetLength
(
)
)
;
return
Success
;
}
#
else
Result
BuildRevocationCheckStrings
(
Input
certDER
EndEntityOrCA
endEntityOrCA
nsCString
&
encIssuer
nsCString
&
encSerial
nsCString
&
encSubject
nsCString
&
encPubKey
)
{
BackCert
cert
(
certDER
endEntityOrCA
nullptr
)
;
Result
result
=
cert
.
Init
(
)
;
if
(
result
!
=
Success
)
{
return
result
;
}
Input
issuer
(
cert
.
GetIssuer
(
)
)
;
nsDependentCSubstring
issuerString
(
reinterpret_cast
<
const
char
*
>
(
issuer
.
UnsafeGetData
(
)
)
issuer
.
GetLength
(
)
)
;
Input
serial
(
cert
.
GetSerialNumber
(
)
)
;
nsDependentCSubstring
serialString
(
reinterpret_cast
<
const
char
*
>
(
serial
.
UnsafeGetData
(
)
)
serial
.
GetLength
(
)
)
;
Input
subject
(
cert
.
GetSubject
(
)
)
;
nsDependentCSubstring
subjectString
(
reinterpret_cast
<
const
char
*
>
(
subject
.
UnsafeGetData
(
)
)
subject
.
GetLength
(
)
)
;
Input
pubKey
(
cert
.
GetSubjectPublicKeyInfo
(
)
)
;
nsDependentCSubstring
pubKeyString
(
reinterpret_cast
<
const
char
*
>
(
pubKey
.
UnsafeGetData
(
)
)
pubKey
.
GetLength
(
)
)
;
nsresult
rv
=
Base64Encode
(
issuerString
encIssuer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
rv
=
Base64Encode
(
serialString
encSerial
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
rv
=
Base64Encode
(
subjectString
encSubject
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
rv
=
Base64Encode
(
pubKeyString
encPubKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
return
Success
;
}
#
endif
void
SaveIntermediateCerts
(
const
UniqueCERTCertList
&
certList
)
{
if
(
!
certList
)
{
return
;
}
UniqueCERTCertList
intermediates
(
CERT_NewCertList
(
)
)
;
if
(
!
intermediates
)
{
return
;
}
bool
isEndEntity
=
true
;
size_t
numIntermediates
=
0
;
for
(
CERTCertListNode
*
node
=
CERT_LIST_HEAD
(
certList
)
;
!
CERT_LIST_END
(
node
certList
)
;
node
=
CERT_LIST_NEXT
(
node
)
)
{
if
(
isEndEntity
)
{
isEndEntity
=
false
;
continue
;
}
if
(
node
-
>
cert
-
>
slot
)
{
continue
;
}
if
(
node
-
>
cert
-
>
isperm
)
{
continue
;
}
if
(
node
=
=
CERT_LIST_TAIL
(
certList
)
)
{
continue
;
}
UniqueCERTCertificate
certHandle
(
CERT_DupCertificate
(
node
-
>
cert
)
)
;
if
(
CERT_AddCertToListTail
(
intermediates
.
get
(
)
certHandle
.
get
(
)
)
!
=
SECSuccess
)
{
return
;
}
certHandle
.
release
(
)
;
numIntermediates
+
+
;
}
if
(
numIntermediates
>
0
)
{
nsCOMPtr
<
nsIRunnable
>
importCertsRunnable
(
NS_NewRunnableFunction
(
"
IdleSaveIntermediateCerts
"
[
intermediates
=
std
:
:
move
(
intermediates
)
]
(
)
-
>
void
{
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
;
}
for
(
CERTCertListNode
*
node
=
CERT_LIST_HEAD
(
intermediates
)
;
!
CERT_LIST_END
(
node
intermediates
)
;
node
=
CERT_LIST_NEXT
(
node
)
)
{
nsAutoCString
nickname
;
if
(
NS_FAILED
(
DefaultServerNicknameForCert
(
node
-
>
cert
nickname
)
)
)
{
continue
;
}
Unused
<
<
PK11_ImportCert
(
slot
.
get
(
)
node
-
>
cert
CK_INVALID_HANDLE
nickname
.
get
(
)
false
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
IdleSaveIntermediateCertsDone
"
[
]
(
)
-
>
void
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
nullptr
"
psm
:
intermediate
-
certs
-
cached
"
nullptr
)
;
}
}
)
)
;
Unused
<
<
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
)
)
;
Unused
<
<
NS_DispatchToCurrentThreadQueue
(
importCertsRunnable
.
forget
(
)
EventQueuePriority
:
:
Idle
)
;
}
}
}
}
