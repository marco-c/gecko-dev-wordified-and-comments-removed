#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
<
stdint
.
h
>
#
include
"
ExtendedValidation
.
h
"
#
include
"
NSSErrorsService
.
h
"
#
include
"
OCSPVerificationTrustDomain
.
h
"
#
include
"
PublicKeyPinningService
.
h
"
#
include
"
cert
.
h
"
#
include
"
certdb
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsNSSCertHelper
.
h
"
#
include
"
nsNSSCertValidity
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
mozpkix
/
Result
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
prerror
.
h
"
#
include
"
secerr
.
h
"
#
include
"
TrustOverrideUtils
.
h
"
#
include
"
TrustOverride
-
StartComAndWoSignData
.
inc
"
#
include
"
TrustOverride
-
GlobalSignData
.
inc
"
#
include
"
TrustOverride
-
SymantecData
.
inc
"
#
include
"
TrustOverride
-
AppleGoogleDigiCertData
.
inc
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
pkix
;
extern
LazyLogModule
gCertVerifierLog
;
static
const
uint64_t
ServerFailureDelaySeconds
=
5
*
60
;
namespace
mozilla
{
namespace
psm
{
NSSCertDBTrustDomain
:
:
NSSCertDBTrustDomain
(
SECTrustType
certDBTrustType
OCSPFetching
ocspFetching
OCSPCache
&
ocspCache
void
*
pinArg
TimeDuration
ocspTimeoutSoft
TimeDuration
ocspTimeoutHard
uint32_t
certShortLifetimeInDays
CertVerifier
:
:
PinningMode
pinningMode
unsigned
int
minRSABits
ValidityCheckingMode
validityCheckingMode
CertVerifier
:
:
SHA1Mode
sha1Mode
NetscapeStepUpPolicy
netscapeStepUpPolicy
DistrustedCAPolicy
distrustedCAPolicy
const
OriginAttributes
&
originAttributes
const
Vector
<
Input
>
&
thirdPartyRootInputs
UniqueCERTCertList
&
builtChain
PinningTelemetryInfo
*
pinningTelemetryInfo
const
char
*
hostname
)
:
mCertDBTrustType
(
certDBTrustType
)
mOCSPFetching
(
ocspFetching
)
mOCSPCache
(
ocspCache
)
mPinArg
(
pinArg
)
mOCSPTimeoutSoft
(
ocspTimeoutSoft
)
mOCSPTimeoutHard
(
ocspTimeoutHard
)
mCertShortLifetimeInDays
(
certShortLifetimeInDays
)
mPinningMode
(
pinningMode
)
mMinRSABits
(
minRSABits
)
mValidityCheckingMode
(
validityCheckingMode
)
mSHA1Mode
(
sha1Mode
)
mNetscapeStepUpPolicy
(
netscapeStepUpPolicy
)
mDistrustedCAPolicy
(
distrustedCAPolicy
)
mSawDistrustedCAByPolicyError
(
false
)
mOriginAttributes
(
originAttributes
)
mThirdPartyRootInputs
(
thirdPartyRootInputs
)
mBuiltChain
(
builtChain
)
mPinningTelemetryInfo
(
pinningTelemetryInfo
)
mHostname
(
hostname
)
mCertBlocklist
(
do_GetService
(
NS_CERTBLOCKLIST_CONTRACTID
)
)
mOCSPStaplingStatus
(
CertVerifier
:
:
OCSP_STAPLING_NEVER_CHECKED
)
mSCTListFromCertificate
(
)
mSCTListFromOCSPStapling
(
)
{
}
Result
NSSCertDBTrustDomain
:
:
FindIssuer
(
Input
encodedIssuerName
IssuerChecker
&
checker
Time
)
{
Vector
<
Input
>
rootCandidates
;
Vector
<
Input
>
intermediateCandidates
;
SECItem
encodedIssuerNameItem
=
UnsafeMapInputToSECItem
(
encodedIssuerName
)
;
UniqueCERTCertList
candidates
(
CERT_CreateSubjectCertList
(
nullptr
CERT_GetDefaultCertDB
(
)
&
encodedIssuerNameItem
0
false
)
)
;
if
(
candidates
)
{
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
candidates
)
;
!
CERT_LIST_END
(
n
candidates
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
Input
certDER
;
Result
rv
=
certDER
.
Init
(
n
-
>
cert
-
>
derCert
.
data
n
-
>
cert
-
>
derCert
.
len
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
if
(
n
-
>
cert
-
>
isRoot
)
{
if
(
!
rootCandidates
.
append
(
certDER
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
else
{
if
(
!
intermediateCandidates
.
append
(
certDER
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
}
}
for
(
const
auto
&
thirdPartyRootInput
:
mThirdPartyRootInputs
)
{
if
(
!
rootCandidates
.
append
(
thirdPartyRootInput
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
ScopedAutoSECItem
nameConstraints
;
Input
nameConstraintsInput
;
Input
*
nameConstraintsInputPtr
=
nullptr
;
SECStatus
srv
=
CERT_GetImposedNameConstraints
(
&
encodedIssuerNameItem
&
nameConstraints
)
;
if
(
srv
=
=
SECSuccess
)
{
if
(
nameConstraintsInput
.
Init
(
nameConstraints
.
data
nameConstraints
.
len
)
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nameConstraintsInputPtr
=
&
nameConstraintsInput
;
}
else
if
(
PR_GetError
(
)
!
=
SEC_ERROR_EXTENSION_NOT_FOUND
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
!
rootCandidates
.
appendAll
(
intermediateCandidates
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
for
(
Input
candidate
:
rootCandidates
)
{
bool
keepGoing
;
Result
rv
=
checker
.
Check
(
candidate
nameConstraintsInputPtr
keepGoing
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
!
keepGoing
)
{
return
Success
;
}
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
GetCertTrust
(
EndEntityOrCA
endEntityOrCA
const
CertPolicyId
&
policy
Input
candidateCertDER
TrustLevel
&
trustLevel
)
{
SECItem
candidateCertDERSECItem
=
UnsafeMapInputToSECItem
(
candidateCertDER
)
;
UniqueCERTCertificate
candidateCert
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
candidateCertDERSECItem
nullptr
false
true
)
)
;
if
(
!
candidateCert
)
{
return
MapPRErrorCodeToResult
(
PR_GetError
(
)
)
;
}
if
(
!
mCertBlocklist
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
mCertDBTrustType
=
=
trustSSL
)
{
bool
isCertRevoked
;
nsAutoCString
encIssuer
;
nsAutoCString
encSerial
;
nsAutoCString
encSubject
;
nsAutoCString
encPubKey
;
nsresult
nsrv
=
BuildRevocationCheckStrings
(
candidateCert
.
get
(
)
encIssuer
encSerial
encSubject
encPubKey
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsrv
=
mCertBlocklist
-
>
IsCertRevoked
(
encIssuer
encSerial
encSubject
encPubKey
&
isCertRevoked
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
isCertRevoked
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
certificate
is
in
blocklist
"
)
)
;
return
Result
:
:
ERROR_REVOKED_CERTIFICATE
;
}
}
for
(
const
auto
&
thirdPartyRootInput
:
mThirdPartyRootInputs
)
{
if
(
InputsAreEqual
(
candidateCertDER
thirdPartyRootInput
)
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
}
CERTCertTrust
trust
;
if
(
CERT_GetCertTrust
(
candidateCert
.
get
(
)
&
trust
)
=
=
SECSuccess
)
{
uint32_t
flags
=
SEC_GET_TRUST_FLAGS
(
&
trust
mCertDBTrustType
)
;
uint32_t
relevantTrustBit
=
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
?
CERTDB_TRUSTED_CA
:
CERTDB_TRUSTED
;
if
(
(
(
flags
&
(
relevantTrustBit
|
CERTDB_TERMINAL_RECORD
)
)
)
=
=
CERTDB_TERMINAL_RECORD
)
{
trustLevel
=
TrustLevel
:
:
ActivelyDistrusted
;
return
Success
;
}
if
(
flags
&
CERTDB_TRUSTED_CA
&
&
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
)
{
if
(
policy
.
IsAnyPolicy
(
)
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
if
(
CertIsAuthoritativeForEVPolicy
(
candidateCert
policy
)
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
}
}
trustLevel
=
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
DigestBuf
(
Input
item
DigestAlgorithm
digestAlg
uint8_t
*
digestBuf
size_t
digestBufLen
)
{
return
DigestBufNSS
(
item
digestAlg
digestBuf
digestBufLen
)
;
}
TimeDuration
NSSCertDBTrustDomain
:
:
GetOCSPTimeout
(
)
const
{
switch
(
mOCSPFetching
)
{
case
NSSCertDBTrustDomain
:
:
FetchOCSPForDVSoftFail
:
return
mOCSPTimeoutSoft
;
case
NSSCertDBTrustDomain
:
:
FetchOCSPForEV
:
case
NSSCertDBTrustDomain
:
:
FetchOCSPForDVHardFail
:
return
mOCSPTimeoutHard
;
case
NSSCertDBTrustDomain
:
:
NeverFetchOCSP
:
case
NSSCertDBTrustDomain
:
:
LocalOnlyOCSPForEV
:
MOZ_ASSERT_UNREACHABLE
(
"
we
should
never
see
this
OCSPFetching
type
here
"
)
;
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
we
'
re
not
handling
every
OCSPFetching
type
"
)
;
return
mOCSPTimeoutSoft
;
}
static
Result
GetOCSPAuthorityInfoAccessLocation
(
const
UniquePLArenaPool
&
arena
Input
aiaExtension
nsCString
&
result
)
{
MOZ_ASSERT
(
arena
.
get
(
)
)
;
if
(
!
arena
.
get
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
result
.
Assign
(
VoidCString
(
)
)
;
SECItem
aiaExtensionSECItem
=
UnsafeMapInputToSECItem
(
aiaExtension
)
;
CERTAuthInfoAccess
*
*
aia
=
CERT_DecodeAuthInfoAccessExtension
(
arena
.
get
(
)
&
aiaExtensionSECItem
)
;
if
(
!
aia
)
{
return
Result
:
:
ERROR_CERT_BAD_ACCESS_LOCATION
;
}
for
(
size_t
i
=
0
;
aia
[
i
]
;
+
+
i
)
{
if
(
SECOID_FindOIDTag
(
&
aia
[
i
]
-
>
method
)
=
=
SEC_OID_PKIX_OCSP
)
{
CERTGeneralName
*
current
=
aia
[
i
]
-
>
location
;
if
(
!
current
)
{
continue
;
}
do
{
if
(
current
-
>
type
=
=
certURI
)
{
const
SECItem
&
location
=
current
-
>
name
.
other
;
if
(
location
.
len
>
1024
|
|
memchr
(
location
.
data
0
location
.
len
)
)
{
return
Result
:
:
ERROR_CERT_BAD_ACCESS_LOCATION
;
}
result
.
Assign
(
nsDependentCSubstring
(
reinterpret_cast
<
const
char
*
>
(
location
.
data
)
location
.
len
)
)
;
return
Success
;
}
current
=
CERT_GetNextGeneralName
(
current
)
;
}
while
(
current
!
=
aia
[
i
]
-
>
location
)
;
}
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
CheckRevocation
(
EndEntityOrCA
endEntityOrCA
const
CertID
&
certID
Time
time
Duration
validityDuration
const
Input
*
stapledOCSPResponse
const
Input
*
aiaExtension
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
Top
of
CheckRevocation
\
n
"
)
)
;
uint16_t
maxOCSPLifetimeInDays
=
10
;
if
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
)
{
maxOCSPLifetimeInDays
=
365
;
}
Result
stapledOCSPResponseResult
=
Success
;
if
(
stapledOCSPResponse
)
{
MOZ_ASSERT
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeEndEntity
)
;
bool
expired
;
stapledOCSPResponseResult
=
VerifyAndMaybeCacheEncodedOCSPResponse
(
certID
time
maxOCSPLifetimeInDays
*
stapledOCSPResponse
ResponseWasStapled
expired
)
;
if
(
stapledOCSPResponseResult
=
=
Success
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_GOOD
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
stapled
OCSP
response
:
good
"
)
)
;
return
Success
;
}
if
(
stapledOCSPResponseResult
=
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
|
|
expired
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_EXPIRED
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
expired
stapled
OCSP
response
"
)
)
;
}
else
if
(
stapledOCSPResponseResult
=
=
Result
:
:
ERROR_OCSP_TRY_SERVER_LATER
|
|
stapledOCSPResponseResult
=
=
Result
:
:
ERROR_OCSP_INVALID_SIGNING_CERT
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_INVALID
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
stapled
OCSP
response
:
"
"
failure
(
whitelisted
for
compatibility
)
"
)
)
;
}
else
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_INVALID
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
stapled
OCSP
response
:
failure
"
)
)
;
return
stapledOCSPResponseResult
;
}
}
else
if
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeEndEntity
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_NONE
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
no
stapled
OCSP
response
"
)
)
;
}
Result
cachedResponseResult
=
Success
;
Time
cachedResponseValidThrough
(
Time
:
:
uninitialized
)
;
bool
cachedResponsePresent
=
mOCSPCache
.
Get
(
certID
mOriginAttributes
cachedResponseResult
cachedResponseValidThrough
)
;
if
(
cachedResponsePresent
)
{
if
(
cachedResponseResult
=
=
Success
&
&
cachedResponseValidThrough
>
=
time
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
cached
OCSP
response
:
good
"
)
)
;
return
Success
;
}
if
(
cachedResponseResult
=
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
cached
OCSP
response
:
revoked
"
)
)
;
return
Result
:
:
ERROR_REVOKED_CERTIFICATE
;
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
cached
OCSP
response
:
error
%
d
"
static_cast
<
int
>
(
cachedResponseResult
)
)
)
;
if
(
cachedResponseResult
=
=
Success
&
&
cachedResponseValidThrough
<
time
)
{
cachedResponseResult
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
;
}
if
(
cachedResponseResult
!
=
Success
&
&
cachedResponseResult
!
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
&
&
cachedResponseResult
!
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
&
&
cachedResponseValidThrough
<
time
)
{
cachedResponseResult
=
Success
;
cachedResponsePresent
=
false
;
}
}
else
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
no
cached
OCSP
response
"
)
)
;
}
MOZ_ASSERT
(
(
!
cachedResponsePresent
&
&
cachedResponseResult
=
=
Success
)
|
|
(
cachedResponsePresent
&
&
cachedResponseResult
!
=
Success
)
)
;
bool
blocklistIsFresh
;
nsresult
nsrv
=
mCertBlocklist
-
>
IsBlocklistFresh
(
&
blocklistIsFresh
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Duration
shortLifetime
(
mCertShortLifetimeInDays
*
Time
:
:
ONE_DAY_IN_SECONDS
)
;
if
(
(
mOCSPFetching
=
=
NeverFetchOCSP
)
|
|
(
validityDuration
<
shortLifetime
)
|
|
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
&
&
(
mOCSPFetching
=
=
FetchOCSPForDVHardFail
|
|
mOCSPFetching
=
=
FetchOCSPForDVSoftFail
|
|
blocklistIsFresh
)
)
)
{
if
(
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
return
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
;
}
if
(
mOCSPFetching
=
=
FetchOCSPForDVHardFail
&
&
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
)
{
return
Result
:
:
ERROR_OCSP_OLD_RESPONSE
;
}
return
Success
;
}
if
(
mOCSPFetching
=
=
LocalOnlyOCSPForEV
)
{
if
(
cachedResponseResult
!
=
Success
)
{
return
cachedResponseResult
;
}
return
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
;
}
UniquePLArenaPool
arena
(
PORT_NewArena
(
DER_DEFAULT_CHUNKSIZE
)
)
;
if
(
!
arena
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
Result
rv
;
nsCString
aiaLocation
(
VoidCString
(
)
)
;
if
(
aiaExtension
)
{
rv
=
GetOCSPAuthorityInfoAccessLocation
(
arena
*
aiaExtension
aiaLocation
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
if
(
aiaLocation
.
IsVoid
(
)
)
{
if
(
mOCSPFetching
=
=
FetchOCSPForEV
|
|
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
return
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
;
}
if
(
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
)
{
return
Result
:
:
ERROR_OCSP_OLD_RESPONSE
;
}
if
(
stapledOCSPResponseResult
!
=
Success
)
{
return
stapledOCSPResponseResult
;
}
return
Success
;
}
bool
attemptedRequest
;
Vector
<
uint8_t
>
ocspResponse
;
Input
response
;
if
(
cachedResponseResult
=
=
Success
|
|
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
|
|
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_OLD_RESPONSE
)
{
uint8_t
ocspRequestBytes
[
OCSP_REQUEST_MAX_LENGTH
]
;
size_t
ocspRequestLength
;
rv
=
CreateEncodedOCSPRequest
(
*
this
certID
ocspRequestBytes
ocspRequestLength
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Vector
<
uint8_t
>
ocspRequest
;
if
(
!
ocspRequest
.
append
(
ocspRequestBytes
ocspRequestLength
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
Result
tempRV
=
DoOCSPRequest
(
aiaLocation
mOriginAttributes
std
:
:
move
(
ocspRequest
)
GetOCSPTimeout
(
)
ocspResponse
)
;
if
(
tempRV
!
=
Success
)
{
rv
=
tempRV
;
}
else
if
(
response
.
Init
(
ocspResponse
.
begin
(
)
ocspResponse
.
length
(
)
)
!
=
Success
)
{
rv
=
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
attemptedRequest
=
true
;
}
else
{
rv
=
cachedResponseResult
;
attemptedRequest
=
false
;
}
if
(
response
.
GetLength
(
)
=
=
0
)
{
Result
error
=
rv
;
if
(
attemptedRequest
)
{
Time
timeout
(
time
)
;
if
(
timeout
.
AddSeconds
(
ServerFailureDelaySeconds
)
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
rv
=
mOCSPCache
.
Put
(
certID
mOriginAttributes
error
time
timeout
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
if
(
mOCSPFetching
!
=
FetchOCSPForDVSoftFail
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECFailure
after
"
"
OCSP
request
failure
"
)
)
;
return
error
;
}
if
(
cachedResponseResult
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECFailure
from
cached
"
"
response
after
OCSP
request
failure
"
)
)
;
return
cachedResponseResult
;
}
if
(
stapledOCSPResponseResult
!
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECFailure
from
expired
/
invalid
"
"
stapled
response
after
OCSP
request
failure
"
)
)
;
return
stapledOCSPResponseResult
;
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECSuccess
after
"
"
OCSP
request
failure
"
)
)
;
return
Success
;
}
bool
expired
;
rv
=
VerifyAndMaybeCacheEncodedOCSPResponse
(
certID
time
maxOCSPLifetimeInDays
response
ResponseIsFromNetwork
expired
)
;
if
(
rv
=
=
Success
|
|
mOCSPFetching
!
=
FetchOCSPForDVSoftFail
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
after
VerifyEncodedOCSPResponse
"
)
)
;
return
rv
;
}
if
(
rv
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
|
|
rv
=
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
)
{
return
rv
;
}
if
(
stapledOCSPResponseResult
!
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
returning
SECFailure
from
expired
/
invalid
"
"
stapled
response
after
OCSP
request
verification
failure
"
)
)
;
return
stapledOCSPResponseResult
;
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
end
of
CheckRevocation
"
)
)
;
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
VerifyAndMaybeCacheEncodedOCSPResponse
(
const
CertID
&
certID
Time
time
uint16_t
maxLifetimeInDays
Input
encodedResponse
EncodedResponseSource
responseSource
bool
&
expired
)
{
Time
thisUpdate
(
Time
:
:
uninitialized
)
;
Time
validThrough
(
Time
:
:
uninitialized
)
;
OCSPVerificationTrustDomain
trustDomain
(
*
this
)
;
Result
rv
=
VerifyEncodedOCSPResponse
(
trustDomain
certID
time
maxLifetimeInDays
encodedResponse
expired
&
thisUpdate
&
validThrough
)
;
if
(
responseSource
=
=
ResponseWasStapled
&
&
expired
)
{
MOZ_ASSERT
(
rv
!
=
Success
)
;
return
rv
;
}
if
(
rv
!
=
Success
&
&
rv
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
&
&
rv
!
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
validThrough
=
time
;
if
(
validThrough
.
AddSeconds
(
ServerFailureDelaySeconds
)
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
}
if
(
responseSource
=
=
ResponseIsFromNetwork
|
|
rv
=
=
Success
|
|
rv
=
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
|
|
rv
=
=
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
caching
OCSP
response
"
)
)
;
Result
putRV
=
mOCSPCache
.
Put
(
certID
mOriginAttributes
rv
thisUpdate
validThrough
)
;
if
(
putRV
!
=
Success
)
{
return
putRV
;
}
}
return
rv
;
}
static
Result
CheckForStartComOrWoSign
(
const
UniqueCERTCertList
&
certChain
)
{
if
(
CERT_LIST_EMPTY
(
certChain
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
const
CERTCertListNode
*
endEntityNode
=
CERT_LIST_HEAD
(
certChain
)
;
if
(
!
endEntityNode
|
|
!
endEntityNode
-
>
cert
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
PRTime
notBefore
;
PRTime
notAfter
;
if
(
CERT_GetCertTimes
(
endEntityNode
-
>
cert
&
notBefore
&
notAfter
)
!
=
SECSuccess
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
static
const
PRTime
OCTOBER_21_2016
=
1477008000000000
;
if
(
notBefore
<
=
OCTOBER_21_2016
)
{
return
Success
;
}
for
(
const
CERTCertListNode
*
node
=
CERT_LIST_HEAD
(
certChain
)
;
!
CERT_LIST_END
(
node
certChain
)
;
node
=
CERT_LIST_NEXT
(
node
)
)
{
if
(
!
node
|
|
!
node
-
>
cert
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
CertDNIsInList
(
node
-
>
cert
StartComAndWoSignDNs
)
)
{
return
Result
:
:
ERROR_REVOKED_CERTIFICATE
;
}
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
IsChainValid
(
const
DERArray
&
certArray
Time
time
const
CertPolicyId
&
requiredPolicy
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
IsChainValid
"
)
)
;
UniqueCERTCertList
certList
;
SECStatus
srv
=
ConstructCERTCertListFromReversedDERArray
(
certArray
certList
)
;
if
(
srv
!
=
SECSuccess
)
{
return
MapPRErrorCodeToResult
(
PR_GetError
(
)
)
;
}
if
(
CERT_LIST_EMPTY
(
certList
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Result
rv
=
CheckForStartComOrWoSign
(
certList
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
UniqueCERTCertList
certListCopy
=
nsNSSCertList
:
:
DupCertList
(
certList
)
;
RefPtr
<
nsNSSCertList
>
nssCertList
=
new
nsNSSCertList
(
std
:
:
move
(
certListCopy
)
)
;
if
(
!
nssCertList
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsCOMPtr
<
nsIX509Cert
>
rootCert
;
nsresult
nsrv
=
nssCertList
-
>
GetRootCertificate
(
rootCert
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
UniqueCERTCertificate
root
(
rootCert
-
>
GetCert
(
)
)
;
if
(
!
root
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
bool
isBuiltInRoot
=
false
;
nsrv
=
rootCert
-
>
GetIsBuiltInRoot
(
&
isBuiltInRoot
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
bool
skipPinningChecksBecauseOfMITMMode
=
(
!
isBuiltInRoot
&
&
mPinningMode
=
=
CertVerifier
:
:
pinningAllowUserCAMITM
)
;
if
(
mHostname
&
&
(
mPinningMode
!
=
CertVerifier
:
:
pinningDisabled
)
&
&
!
skipPinningChecksBecauseOfMITMMode
)
{
bool
enforceTestMode
=
(
mPinningMode
=
=
CertVerifier
:
:
pinningEnforceTestMode
)
;
bool
chainHasValidPins
;
nsrv
=
PublicKeyPinningService
:
:
ChainHasValidPins
(
nssCertList
mHostname
time
enforceTestMode
mOriginAttributes
chainHasValidPins
mPinningTelemetryInfo
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
!
chainHasValidPins
)
{
return
Result
:
:
ERROR_KEY_PINNING_FAILURE
;
}
}
if
(
requiredPolicy
=
=
sGlobalSignEVPolicy
&
&
CertMatchesStaticData
(
root
.
get
(
)
sGlobalSignRootCAR2SubjectBytes
sGlobalSignRootCAR2SPKIBytes
)
)
{
rootCert
=
nullptr
;
nsCOMPtr
<
nsIX509CertList
>
intCerts
;
nsCOMPtr
<
nsIX509Cert
>
eeCert
;
nsrv
=
nssCertList
-
>
SegmentCertificateChain
(
rootCert
intCerts
eeCert
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
bool
foundRequiredIntermediate
=
false
;
RefPtr
<
nsNSSCertList
>
intCertList
=
intCerts
-
>
GetCertList
(
)
;
nsrv
=
intCertList
-
>
ForEachCertificateInChain
(
[
&
foundRequiredIntermediate
]
(
nsCOMPtr
<
nsIX509Cert
>
aCert
bool
aHasMore
bool
&
aContinue
)
{
UniqueCERTCertificate
nssCert
(
aCert
-
>
GetCert
(
)
)
;
if
(
CertMatchesStaticData
(
nssCert
.
get
(
)
sGlobalSignExtendedValidationCASHA256G2SubjectBytes
sGlobalSignExtendedValidationCASHA256G2SPKIBytes
)
)
{
foundRequiredIntermediate
=
true
;
aContinue
=
false
;
}
return
NS_OK
;
}
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
!
foundRequiredIntermediate
)
{
return
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
}
if
(
mHostname
&
&
CertDNIsInList
(
root
.
get
(
)
RootSymantecDNs
)
&
&
(
(
mDistrustedCAPolicy
&
DistrustedCAPolicy
:
:
DistrustSymantecRoots
)
|
|
(
mDistrustedCAPolicy
&
DistrustedCAPolicy
:
:
DistrustSymantecRootsRegardlessOfDate
)
)
)
{
rootCert
=
nullptr
;
nsCOMPtr
<
nsIX509CertList
>
intCerts
;
nsCOMPtr
<
nsIX509Cert
>
eeCert
;
nsrv
=
nssCertList
-
>
SegmentCertificateChain
(
rootCert
intCerts
eeCert
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
static
const
PRTime
JUNE_1_2016
=
1464739200000000
;
PRTime
permitAfterDate
=
JUNE_1_2016
;
if
(
mDistrustedCAPolicy
&
DistrustedCAPolicy
:
:
DistrustSymantecRootsRegardlessOfDate
)
{
permitAfterDate
=
0
;
}
bool
isDistrusted
=
false
;
nsrv
=
CheckForSymantecDistrust
(
intCerts
eeCert
permitAfterDate
RootAppleAndGoogleSPKIs
isDistrusted
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
isDistrusted
)
{
mSawDistrustedCAByPolicyError
=
true
;
return
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
}
mBuiltChain
=
std
:
:
move
(
certList
)
;
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
CheckSignatureDigestAlgorithm
(
DigestAlgorithm
aAlg
EndEntityOrCA
endEntityOrCA
Time
notBefore
)
{
static
const
Time
JANUARY_FIRST_2016
=
TimeFromEpochInSeconds
(
1451606400
)
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
NSSCertDBTrustDomain
:
CheckSignatureDigestAlgorithm
"
)
)
;
if
(
aAlg
=
=
DigestAlgorithm
:
:
sha1
)
{
switch
(
mSHA1Mode
)
{
case
CertVerifier
:
:
SHA1Mode
:
:
Forbidden
:
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SHA
-
1
certificate
rejected
"
)
)
;
return
Result
:
:
ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
;
case
CertVerifier
:
:
SHA1Mode
:
:
ImportedRootOrBefore2016
:
if
(
JANUARY_FIRST_2016
<
=
notBefore
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Post
-
2015
SHA
-
1
certificate
rejected
"
)
)
;
return
Result
:
:
ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
;
}
break
;
case
CertVerifier
:
:
SHA1Mode
:
:
Allowed
:
case
CertVerifier
:
:
SHA1Mode
:
:
ImportedRoot
:
default
:
break
;
case
CertVerifier
:
:
SHA1Mode
:
:
UsedToBeBefore2016ButNowIsForbidden
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
SHA1Mode
type
"
)
;
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
CheckRSAPublicKeyModulusSizeInBits
(
EndEntityOrCA
unsigned
int
modulusSizeInBits
)
{
if
(
modulusSizeInBits
<
mMinRSABits
)
{
return
Result
:
:
ERROR_INADEQUATE_KEY_SIZE
;
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
VerifyRSAPKCS1SignedDigest
(
const
SignedDigest
&
signedDigest
Input
subjectPublicKeyInfo
)
{
return
VerifyRSAPKCS1SignedDigestNSS
(
signedDigest
subjectPublicKeyInfo
mPinArg
)
;
}
Result
NSSCertDBTrustDomain
:
:
CheckECDSACurveIsAcceptable
(
EndEntityOrCA
NamedCurve
curve
)
{
switch
(
curve
)
{
case
NamedCurve
:
:
secp256r1
:
case
NamedCurve
:
:
secp384r1
:
case
NamedCurve
:
:
secp521r1
:
return
Success
;
}
return
Result
:
:
ERROR_UNSUPPORTED_ELLIPTIC_CURVE
;
}
Result
NSSCertDBTrustDomain
:
:
VerifyECDSASignedDigest
(
const
SignedDigest
&
signedDigest
Input
subjectPublicKeyInfo
)
{
return
VerifyECDSASignedDigestNSS
(
signedDigest
subjectPublicKeyInfo
mPinArg
)
;
}
Result
NSSCertDBTrustDomain
:
:
CheckValidityIsAcceptable
(
Time
notBefore
Time
notAfter
EndEntityOrCA
endEntityOrCA
KeyPurposeId
keyPurpose
)
{
if
(
endEntityOrCA
!
=
EndEntityOrCA
:
:
MustBeEndEntity
)
{
return
Success
;
}
if
(
keyPurpose
=
=
KeyPurposeId
:
:
id_kp_OCSPSigning
)
{
return
Success
;
}
Duration
DURATION_27_MONTHS_PLUS_SLOP
(
(
2
*
365
+
3
*
31
+
7
)
*
Time
:
:
ONE_DAY_IN_SECONDS
)
;
Duration
maxValidityDuration
(
UINT64_MAX
)
;
Duration
validityDuration
(
notBefore
notAfter
)
;
switch
(
mValidityCheckingMode
)
{
case
ValidityCheckingMode
:
:
CheckingOff
:
return
Success
;
case
ValidityCheckingMode
:
:
CheckForEV
:
maxValidityDuration
=
DURATION_27_MONTHS_PLUS_SLOP
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
We
'
re
not
handling
every
ValidityCheckingMode
type
"
)
;
}
if
(
validityDuration
>
maxValidityDuration
)
{
return
Result
:
:
ERROR_VALIDITY_TOO_LONG
;
}
return
Success
;
}
Result
NSSCertDBTrustDomain
:
:
NetscapeStepUpMatchesServerAuth
(
Time
notBefore
bool
&
matches
)
{
static
const
Time
AUGUST_23_2015
=
TimeFromEpochInSeconds
(
1440288000
)
;
static
const
Time
AUGUST_23_2016
=
TimeFromEpochInSeconds
(
1471910400
)
;
switch
(
mNetscapeStepUpPolicy
)
{
case
NetscapeStepUpPolicy
:
:
AlwaysMatch
:
matches
=
true
;
return
Success
;
case
NetscapeStepUpPolicy
:
:
MatchBefore23August2016
:
matches
=
notBefore
<
AUGUST_23_2016
;
return
Success
;
case
NetscapeStepUpPolicy
:
:
MatchBefore23August2015
:
matches
=
notBefore
<
AUGUST_23_2015
;
return
Success
;
case
NetscapeStepUpPolicy
:
:
NeverMatch
:
matches
=
false
;
return
Success
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unhandled
NetscapeStepUpPolicy
type
"
)
;
}
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
void
NSSCertDBTrustDomain
:
:
ResetAccumulatedState
(
)
{
mOCSPStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_NEVER_CHECKED
;
mSCTListFromOCSPStapling
=
nullptr
;
mSCTListFromCertificate
=
nullptr
;
mSawDistrustedCAByPolicyError
=
false
;
}
static
Input
SECItemToInput
(
const
UniqueSECItem
&
item
)
{
Input
result
;
if
(
item
)
{
MOZ_ASSERT
(
item
-
>
type
=
=
siBuffer
)
;
Result
rv
=
result
.
Init
(
item
-
>
data
item
-
>
len
)
;
MOZ_ASSERT
(
rv
=
=
Success
)
;
Unused
<
<
rv
;
}
return
result
;
}
Input
NSSCertDBTrustDomain
:
:
GetSCTListFromCertificate
(
)
const
{
return
SECItemToInput
(
mSCTListFromCertificate
)
;
}
Input
NSSCertDBTrustDomain
:
:
GetSCTListFromOCSPStapling
(
)
const
{
return
SECItemToInput
(
mSCTListFromOCSPStapling
)
;
}
bool
NSSCertDBTrustDomain
:
:
GetIsErrorDueToDistrustedCAPolicy
(
)
const
{
return
mSawDistrustedCAByPolicyError
;
}
void
NSSCertDBTrustDomain
:
:
NoteAuxiliaryExtension
(
AuxiliaryExtension
extension
Input
extensionData
)
{
UniqueSECItem
*
out
=
nullptr
;
switch
(
extension
)
{
case
AuxiliaryExtension
:
:
EmbeddedSCTList
:
out
=
&
mSCTListFromCertificate
;
break
;
case
AuxiliaryExtension
:
:
SCTListFromOCSPResponse
:
out
=
&
mSCTListFromOCSPStapling
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unhandled
AuxiliaryExtension
"
)
;
}
if
(
out
)
{
SECItem
extensionDataItem
=
UnsafeMapInputToSECItem
(
extensionData
)
;
out
-
>
reset
(
SECITEM_DupItem
(
&
extensionDataItem
)
)
;
}
}
SECStatus
InitializeNSS
(
const
nsACString
&
dir
bool
readOnly
bool
loadPKCS11Modules
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
uint32_t
flags
=
NSS_INIT_NOROOTINIT
|
NSS_INIT_OPTIMIZESPACE
;
if
(
readOnly
)
{
flags
|
=
NSS_INIT_READONLY
;
}
if
(
!
loadPKCS11Modules
)
{
flags
|
=
NSS_INIT_NOMODDB
;
}
nsAutoCString
dbTypeAndDirectory
(
"
sql
:
"
)
;
dbTypeAndDirectory
.
Append
(
dir
)
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
InitializeNSS
(
%
s
%
d
%
d
)
"
dbTypeAndDirectory
.
get
(
)
readOnly
loadPKCS11Modules
)
)
;
SECStatus
srv
=
NSS_Initialize
(
dbTypeAndDirectory
.
get
(
)
"
"
"
"
SECMOD_DB
flags
)
;
if
(
srv
!
=
SECSuccess
)
{
return
srv
;
}
if
(
!
readOnly
)
{
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
SECFailure
;
}
if
(
PK11_NeedUserInit
(
slot
.
get
(
)
)
)
{
srv
=
PK11_InitPin
(
slot
.
get
(
)
nullptr
nullptr
)
;
MOZ_ASSERT
(
srv
=
=
SECSuccess
)
;
Unused
<
<
srv
;
}
}
return
SECSuccess
;
}
void
DisableMD5
(
)
{
NSS_SetAlgorithmPolicy
(
SEC_OID_MD5
0
NSS_USE_ALG_IN_CERT_SIGNATURE
|
NSS_USE_ALG_IN_CMS_SIGNATURE
)
;
NSS_SetAlgorithmPolicy
(
SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION
0
NSS_USE_ALG_IN_CERT_SIGNATURE
|
NSS_USE_ALG_IN_CMS_SIGNATURE
)
;
NSS_SetAlgorithmPolicy
(
SEC_OID_PKCS5_PBE_WITH_MD5_AND_DES_CBC
0
NSS_USE_ALG_IN_CERT_SIGNATURE
|
NSS_USE_ALG_IN_CMS_SIGNATURE
)
;
}
bool
LoadLoadableRoots
(
const
nsCString
&
dir
)
{
int
unusedModType
;
Unused
<
<
SECMOD_DeleteModule
(
kRootModuleName
&
unusedModType
)
;
Unused
<
<
SECMOD_DeleteModule
(
"
Root
Certs
"
&
unusedModType
)
;
nsAutoCString
fullLibraryPath
;
if
(
!
dir
.
IsEmpty
(
)
)
{
fullLibraryPath
.
Assign
(
dir
)
;
fullLibraryPath
.
AppendLiteral
(
FILE_PATH_SEPARATOR
)
;
}
fullLibraryPath
.
Append
(
MOZ_DLL_PREFIX
"
nssckbi
"
MOZ_DLL_SUFFIX
)
;
fullLibraryPath
.
ReplaceSubstring
(
"
\
\
"
"
\
\
\
\
"
)
;
fullLibraryPath
.
ReplaceSubstring
(
"
\
"
"
"
\
\
\
"
"
)
;
nsAutoCString
pkcs11ModuleSpec
(
"
name
=
\
"
"
)
;
pkcs11ModuleSpec
.
Append
(
kRootModuleName
)
;
pkcs11ModuleSpec
.
AppendLiteral
(
"
\
"
library
=
\
"
"
)
;
pkcs11ModuleSpec
.
Append
(
fullLibraryPath
)
;
pkcs11ModuleSpec
.
AppendLiteral
(
"
\
"
"
)
;
UniqueSECMODModule
rootsModule
(
SECMOD_LoadUserModule
(
const_cast
<
char
*
>
(
pkcs11ModuleSpec
.
get
(
)
)
nullptr
false
)
)
;
if
(
!
rootsModule
)
{
return
false
;
}
if
(
!
rootsModule
-
>
loaded
)
{
return
false
;
}
return
true
;
}
void
UnloadLoadableRoots
(
)
{
UniqueSECMODModule
rootsModule
(
SECMOD_FindModule
(
kRootModuleName
)
)
;
if
(
rootsModule
)
{
SECMOD_UnloadUserModule
(
rootsModule
.
get
(
)
)
;
}
}
nsresult
DefaultServerNicknameForCert
(
const
CERTCertificate
*
cert
nsCString
&
nickname
)
{
MOZ_ASSERT
(
cert
)
;
NS_ENSURE_ARG_POINTER
(
cert
)
;
UniquePORTString
baseName
(
CERT_GetCommonName
(
&
cert
-
>
subject
)
)
;
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetOrgUnitName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetOrgName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetLocalityName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetStateName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
baseName
=
UniquePORTString
(
CERT_GetCountryName
(
&
cert
-
>
subject
)
)
;
}
if
(
!
baseName
)
{
return
NS_ERROR_FAILURE
;
}
static
const
uint32_t
ARBITRARY_LIMIT
=
500
;
for
(
uint32_t
count
=
1
;
count
<
ARBITRARY_LIMIT
;
count
+
+
)
{
nickname
=
baseName
.
get
(
)
;
if
(
count
!
=
1
)
{
nickname
.
AppendPrintf
(
"
#
%
u
"
count
)
;
}
if
(
nickname
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
conflict
=
SEC_CertNicknameConflict
(
nickname
.
get
(
)
&
cert
-
>
derSubject
cert
-
>
dbhandle
)
;
if
(
!
conflict
)
{
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
nsresult
BuildRevocationCheckStrings
(
const
CERTCertificate
*
cert
nsCString
&
encIssuer
nsCString
&
encSerial
nsCString
&
encSubject
nsCString
&
encPubKey
)
{
nsDependentCSubstring
issuerString
(
BitwiseCast
<
char
*
uint8_t
*
>
(
cert
-
>
derIssuer
.
data
)
cert
-
>
derIssuer
.
len
)
;
nsDependentCSubstring
serialString
(
BitwiseCast
<
char
*
uint8_t
*
>
(
cert
-
>
serialNumber
.
data
)
cert
-
>
serialNumber
.
len
)
;
nsDependentCSubstring
subjectString
(
BitwiseCast
<
char
*
uint8_t
*
>
(
cert
-
>
derSubject
.
data
)
cert
-
>
derSubject
.
len
)
;
nsDependentCSubstring
pubKeyString
(
BitwiseCast
<
char
*
uint8_t
*
>
(
cert
-
>
derPublicKey
.
data
)
cert
-
>
derPublicKey
.
len
)
;
nsresult
rv
=
Base64Encode
(
issuerString
encIssuer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
Base64Encode
(
serialString
encSerial
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
Base64Encode
(
subjectString
encSubject
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
Base64Encode
(
pubKeyString
encPubKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
SaveIntermediateCerts
(
const
UniqueCERTCertList
&
certList
)
{
if
(
!
certList
)
{
return
;
}
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
;
}
bool
isEndEntity
=
true
;
for
(
CERTCertListNode
*
node
=
CERT_LIST_HEAD
(
certList
)
;
!
CERT_LIST_END
(
node
certList
)
;
node
=
CERT_LIST_NEXT
(
node
)
)
{
if
(
isEndEntity
)
{
isEndEntity
=
false
;
continue
;
}
if
(
node
-
>
cert
-
>
slot
)
{
continue
;
}
if
(
node
-
>
cert
-
>
isperm
)
{
continue
;
}
if
(
node
=
=
CERT_LIST_TAIL
(
certList
)
)
{
continue
;
}
nsAutoCString
nickname
;
nsresult
rv
=
DefaultServerNicknameForCert
(
node
-
>
cert
nickname
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
Unused
<
<
PK11_ImportCert
(
slot
.
get
(
)
node
-
>
cert
CK_INVALID_HANDLE
nickname
.
get
(
)
false
)
;
}
}
}
}
