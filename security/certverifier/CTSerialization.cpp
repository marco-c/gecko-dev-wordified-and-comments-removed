#
include
"
CTSerialization
.
h
"
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
namespace
mozilla
{
namespace
ct
{
using
namespace
mozilla
:
:
pkix
;
static
const
size_t
kVersionLength
=
1
;
static
const
size_t
kLogIdLength
=
32
;
static
const
size_t
kTimestampLength
=
8
;
static
const
size_t
kExtensionsLengthBytes
=
2
;
static
const
size_t
kHashAlgorithmLength
=
1
;
static
const
size_t
kSigAlgorithmLength
=
1
;
static
const
size_t
kSignatureLengthBytes
=
2
;
static
const
size_t
kSignatureTypeLength
=
1
;
static
const
size_t
kLogEntryTypeLength
=
2
;
static
const
size_t
kAsn1CertificateLengthBytes
=
3
;
static
const
size_t
kTbsCertificateLengthBytes
=
3
;
static
const
size_t
kSCTListLengthBytes
=
2
;
static
const
size_t
kSerializedSCTLengthBytes
=
2
;
static
const
size_t
kTreeSizeLength
=
8
;
static
const
size_t
kSthRootHashLength
=
32
;
enum
class
SignatureType
{
CertificateTimestamp
=
0
TreeHash
=
1
}
;
static
Result
UncheckedReadUint
(
size_t
length
Reader
&
in
uint64_t
&
out
)
{
uint64_t
result
=
0
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
uint8_t
value
;
Result
rv
=
in
.
Read
(
value
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
result
=
(
result
<
<
8
)
|
value
;
}
out
=
result
;
return
Success
;
}
template
<
size_t
length
typename
T
>
static
inline
Result
ReadUint
(
Reader
&
in
T
&
out
)
{
uint64_t
value
;
static_assert
(
mozilla
:
:
IsUnsigned
<
T
>
:
:
value
"
T
must
be
unsigned
"
)
;
static_assert
(
length
<
=
8
"
At
most
8
byte
integers
can
be
read
"
)
;
static_assert
(
sizeof
(
T
)
>
=
length
"
T
must
be
able
to
hold
<
length
>
bytes
"
)
;
Result
rv
=
UncheckedReadUint
(
length
in
value
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
out
=
static_cast
<
T
>
(
value
)
;
return
Success
;
}
static
Result
ReadFixedBytes
(
size_t
length
Reader
&
in
Input
&
out
)
{
return
in
.
Skip
(
length
out
)
;
}
template
<
size_t
prefixLength
>
static
inline
Result
ReadVariableBytes
(
Reader
&
in
Input
&
out
)
{
size_t
length
;
Result
rv
=
ReadUint
<
prefixLength
>
(
in
length
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
ReadFixedBytes
(
length
in
out
)
;
}
static
Result
ReadHashAlgorithm
(
Reader
&
in
DigitallySigned
:
:
HashAlgorithm
&
out
)
{
unsigned
int
value
;
Result
rv
=
ReadUint
<
kHashAlgorithmLength
>
(
in
value
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
DigitallySigned
:
:
HashAlgorithm
algo
=
static_cast
<
DigitallySigned
:
:
HashAlgorithm
>
(
value
)
;
switch
(
algo
)
{
case
DigitallySigned
:
:
HashAlgorithm
:
:
None
:
case
DigitallySigned
:
:
HashAlgorithm
:
:
MD5
:
case
DigitallySigned
:
:
HashAlgorithm
:
:
SHA1
:
case
DigitallySigned
:
:
HashAlgorithm
:
:
SHA224
:
case
DigitallySigned
:
:
HashAlgorithm
:
:
SHA256
:
case
DigitallySigned
:
:
HashAlgorithm
:
:
SHA384
:
case
DigitallySigned
:
:
HashAlgorithm
:
:
SHA512
:
out
=
algo
;
return
Success
;
}
return
Result
:
:
ERROR_BAD_DER
;
}
static
Result
ReadSignatureAlgorithm
(
Reader
&
in
DigitallySigned
:
:
SignatureAlgorithm
&
out
)
{
unsigned
int
value
;
Result
rv
=
ReadUint
<
kSigAlgorithmLength
>
(
in
value
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
DigitallySigned
:
:
SignatureAlgorithm
algo
=
static_cast
<
DigitallySigned
:
:
SignatureAlgorithm
>
(
value
)
;
switch
(
algo
)
{
case
DigitallySigned
:
:
SignatureAlgorithm
:
:
Anonymous
:
case
DigitallySigned
:
:
SignatureAlgorithm
:
:
RSA
:
case
DigitallySigned
:
:
SignatureAlgorithm
:
:
DSA
:
case
DigitallySigned
:
:
SignatureAlgorithm
:
:
ECDSA
:
out
=
algo
;
return
Success
;
}
return
Result
:
:
ERROR_BAD_DER
;
}
static
Result
ReadVersion
(
Reader
&
in
SignedCertificateTimestamp
:
:
Version
&
out
)
{
unsigned
int
value
;
Result
rv
=
ReadUint
<
kVersionLength
>
(
in
value
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
SignedCertificateTimestamp
:
:
Version
version
=
static_cast
<
SignedCertificateTimestamp
:
:
Version
>
(
value
)
;
switch
(
version
)
{
case
SignedCertificateTimestamp
:
:
Version
:
:
V1
:
out
=
version
;
return
Success
;
}
return
Result
:
:
ERROR_BAD_DER
;
}
static
Result
UncheckedWriteUint
(
size_t
length
uint64_t
value
Buffer
&
output
)
{
if
(
!
output
.
reserve
(
length
+
output
.
length
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
for
(
;
length
>
0
;
-
-
length
)
{
uint8_t
nextByte
=
(
value
>
>
(
(
length
-
1
)
*
8
)
)
&
0xFF
;
output
.
infallibleAppend
(
nextByte
)
;
}
return
Success
;
}
template
<
size_t
length
typename
T
>
static
inline
Result
WriteUint
(
T
value
Buffer
&
output
)
{
static_assert
(
length
<
=
8
"
At
most
8
byte
integers
can
be
written
"
)
;
static_assert
(
sizeof
(
T
)
>
=
length
"
T
must
be
able
to
hold
<
length
>
bytes
"
)
;
if
(
mozilla
:
:
IsSigned
<
T
>
:
:
value
)
{
if
(
value
<
0
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
}
if
(
sizeof
(
T
)
>
length
)
{
if
(
value
>
>
(
length
*
8
-
1
)
>
1
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
}
return
UncheckedWriteUint
(
length
static_cast
<
uint64_t
>
(
value
)
output
)
;
}
static
Result
WriteEncodedBytes
(
Input
input
Buffer
&
output
)
{
if
(
!
output
.
append
(
input
.
UnsafeGetData
(
)
input
.
GetLength
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
return
Success
;
}
static
Result
WriteEncodedBytes
(
const
Buffer
&
source
Buffer
&
output
)
{
if
(
!
output
.
appendAll
(
source
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
return
Success
;
}
template
<
size_t
prefixLength
>
static
Result
WriteVariableBytesPrefix
(
size_t
dataLength
Buffer
&
output
)
{
const
size_t
maxAllowedInputSize
=
static_cast
<
size_t
>
(
(
(
1
<
<
(
prefixLength
*
8
)
)
-
1
)
)
;
if
(
dataLength
>
maxAllowedInputSize
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
return
WriteUint
<
prefixLength
>
(
dataLength
output
)
;
}
template
<
size_t
prefixLength
>
static
Result
WriteVariableBytes
(
Input
input
Buffer
&
output
)
{
Result
rv
=
WriteVariableBytesPrefix
<
prefixLength
>
(
input
.
GetLength
(
)
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
WriteEncodedBytes
(
input
output
)
;
}
template
<
size_t
prefixLength
>
static
Result
WriteVariableBytes
(
const
Buffer
&
source
Buffer
&
output
)
{
Input
input
;
Result
rv
=
BufferToInput
(
source
input
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
WriteVariableBytes
<
prefixLength
>
(
input
output
)
;
}
static
Result
EncodeAsn1CertLogEntry
(
const
LogEntry
&
entry
Buffer
&
output
)
{
return
WriteVariableBytes
<
kAsn1CertificateLengthBytes
>
(
entry
.
leafCertificate
output
)
;
}
static
Result
EncodePrecertLogEntry
(
const
LogEntry
&
entry
Buffer
&
output
)
{
if
(
entry
.
issuerKeyHash
.
length
(
)
!
=
kLogIdLength
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Result
rv
=
WriteEncodedBytes
(
entry
.
issuerKeyHash
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
WriteVariableBytes
<
kTbsCertificateLengthBytes
>
(
entry
.
tbsCertificate
output
)
;
}
Result
EncodeDigitallySigned
(
const
DigitallySigned
&
data
Buffer
&
output
)
{
Result
rv
=
WriteUint
<
kHashAlgorithmLength
>
(
static_cast
<
unsigned
int
>
(
data
.
hashAlgorithm
)
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
WriteUint
<
kSigAlgorithmLength
>
(
static_cast
<
unsigned
int
>
(
data
.
signatureAlgorithm
)
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
WriteVariableBytes
<
kSignatureLengthBytes
>
(
data
.
signatureData
output
)
;
}
Result
DecodeDigitallySigned
(
Reader
&
reader
DigitallySigned
&
output
)
{
DigitallySigned
result
;
Result
rv
=
ReadHashAlgorithm
(
reader
result
.
hashAlgorithm
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
ReadSignatureAlgorithm
(
reader
result
.
signatureAlgorithm
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Input
signatureData
;
rv
=
ReadVariableBytes
<
kSignatureLengthBytes
>
(
reader
signatureData
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
InputToBuffer
(
signatureData
result
.
signatureData
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
output
=
Move
(
result
)
;
return
Success
;
}
Result
EncodeLogEntry
(
const
LogEntry
&
entry
Buffer
&
output
)
{
Result
rv
=
WriteUint
<
kLogEntryTypeLength
>
(
static_cast
<
unsigned
int
>
(
entry
.
type
)
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
switch
(
entry
.
type
)
{
case
LogEntry
:
:
Type
:
:
X509
:
return
EncodeAsn1CertLogEntry
(
entry
output
)
;
case
LogEntry
:
:
Type
:
:
Precert
:
return
EncodePrecertLogEntry
(
entry
output
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
LogEntry
type
"
)
;
}
return
Result
:
:
ERROR_BAD_DER
;
}
static
Result
WriteTimeSinceEpoch
(
uint64_t
timestamp
Buffer
&
output
)
{
return
WriteUint
<
kTimestampLength
>
(
timestamp
output
)
;
}
Result
EncodeV1SCTSignedData
(
uint64_t
timestamp
Input
serializedLogEntry
Input
extensions
Buffer
&
output
)
{
Result
rv
=
WriteUint
<
kVersionLength
>
(
static_cast
<
unsigned
int
>
(
SignedCertificateTimestamp
:
:
Version
:
:
V1
)
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
WriteUint
<
kSignatureTypeLength
>
(
static_cast
<
unsigned
int
>
(
SignatureType
:
:
CertificateTimestamp
)
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
WriteTimeSinceEpoch
(
timestamp
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
WriteEncodedBytes
(
serializedLogEntry
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
WriteVariableBytes
<
kExtensionsLengthBytes
>
(
extensions
output
)
;
}
Result
EncodeTreeHeadSignature
(
const
SignedTreeHead
&
signedTreeHead
Buffer
&
output
)
{
Result
rv
=
WriteUint
<
kVersionLength
>
(
static_cast
<
unsigned
int
>
(
signedTreeHead
.
version
)
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
WriteUint
<
kSignatureTypeLength
>
(
static_cast
<
unsigned
int
>
(
SignatureType
:
:
TreeHash
)
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
WriteTimeSinceEpoch
(
signedTreeHead
.
timestamp
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
WriteUint
<
kTreeSizeLength
>
(
signedTreeHead
.
treeSize
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
signedTreeHead
.
sha256RootHash
.
length
(
)
!
=
kSthRootHashLength
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
return
WriteEncodedBytes
(
signedTreeHead
.
sha256RootHash
output
)
;
}
Result
DecodeSCTList
(
Input
input
Reader
&
listReader
)
{
Reader
inputReader
(
input
)
;
Input
listData
;
Result
rv
=
ReadVariableBytes
<
kSCTListLengthBytes
>
(
inputReader
listData
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
listReader
.
Init
(
listData
)
;
}
Result
ReadSCTListItem
(
Reader
&
listReader
Input
&
output
)
{
if
(
listReader
.
AtEnd
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Result
rv
=
ReadVariableBytes
<
kSerializedSCTLengthBytes
>
(
listReader
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
output
.
GetLength
(
)
=
=
0
)
{
return
Result
:
:
ERROR_BAD_DER
;
}
return
Success
;
}
Result
DecodeSignedCertificateTimestamp
(
Reader
&
reader
SignedCertificateTimestamp
&
output
)
{
SignedCertificateTimestamp
result
;
Result
rv
=
ReadVersion
(
reader
result
.
version
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
uint64_t
timestamp
;
Input
logId
;
Input
extensions
;
rv
=
ReadFixedBytes
(
kLogIdLength
reader
logId
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
ReadUint
<
kTimestampLength
>
(
reader
timestamp
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
ReadVariableBytes
<
kExtensionsLengthBytes
>
(
reader
extensions
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
DecodeDigitallySigned
(
reader
result
.
signature
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
InputToBuffer
(
logId
result
.
logId
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
InputToBuffer
(
extensions
result
.
extensions
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
result
.
timestamp
=
timestamp
;
result
.
origin
=
SignedCertificateTimestamp
:
:
Origin
:
:
Unknown
;
result
.
verificationStatus
=
SignedCertificateTimestamp
:
:
VerificationStatus
:
:
None
;
output
=
Move
(
result
)
;
return
Success
;
}
Result
EncodeSCTList
(
const
Vector
<
pkix
:
:
Input
>
&
scts
Buffer
&
output
)
{
size_t
sctListLength
=
0
;
for
(
auto
&
sct
:
scts
)
{
sctListLength
+
=
sct
.
GetLength
(
)
+
kSerializedSCTLengthBytes
;
}
if
(
!
output
.
reserve
(
kSCTListLengthBytes
+
sctListLength
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
Result
rv
=
WriteVariableBytesPrefix
<
kSCTListLengthBytes
>
(
sctListLength
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
for
(
auto
&
sct
:
scts
)
{
rv
=
WriteVariableBytes
<
kSerializedSCTLengthBytes
>
(
sct
output
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
return
Success
;
}
}
}
