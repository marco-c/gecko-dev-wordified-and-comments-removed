#
include
"
CertVerifier
.
h
"
#
include
<
stdint
.
h
>
#
include
"
AppTrustDomain
.
h
"
#
include
"
CTKnownLogs
.
h
"
#
include
"
CTLogVerifier
.
h
"
#
include
"
ExtendedValidation
.
h
"
#
include
"
MultiLogCTVerifier
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
NSSErrorsService
.
h
"
#
include
"
cert
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixcheck
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsPromiseFlatString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
secmod
.
h
"
using
namespace
mozilla
:
:
ct
;
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
mozilla
:
:
LazyLogModule
gCertVerifierLog
(
"
certverifier
"
)
;
namespace
mozilla
{
namespace
psm
{
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_LOCAL_ONLY
=
1
;
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_MUST_BE_EV
=
2
;
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
=
4
;
static
const
unsigned
int
MIN_RSA_BITS
=
2048
;
static
const
unsigned
int
MIN_RSA_BITS_WEAK
=
1024
;
void
CertificateTransparencyInfo
:
:
Reset
(
)
{
enabled
=
false
;
verifyResult
.
Reset
(
)
;
policyCompliance
.
reset
(
)
;
}
CertVerifier
:
:
CertVerifier
(
OcspDownloadConfig
odc
OcspStrictConfig
osc
mozilla
:
:
TimeDuration
ocspTimeoutSoft
mozilla
:
:
TimeDuration
ocspTimeoutHard
uint32_t
certShortLifetimeInDays
NetscapeStepUpPolicy
netscapeStepUpPolicy
CertificateTransparencyMode
ctMode
CRLiteMode
crliteMode
const
nsTArray
<
EnterpriseCert
>
&
thirdPartyCerts
)
:
mOCSPDownloadConfig
(
odc
)
mOCSPStrict
(
osc
=
=
ocspStrict
)
mOCSPTimeoutSoft
(
ocspTimeoutSoft
)
mOCSPTimeoutHard
(
ocspTimeoutHard
)
mCertShortLifetimeInDays
(
certShortLifetimeInDays
)
mNetscapeStepUpPolicy
(
netscapeStepUpPolicy
)
mCTMode
(
ctMode
)
mCRLiteMode
(
crliteMode
)
mSignatureCache
(
signature_cache_new
(
StaticPrefs
:
:
security_pki_cert_signature_cache_size
(
)
)
signature_cache_free
)
{
LoadKnownCTLogs
(
)
;
mThirdPartyCerts
=
thirdPartyCerts
.
Clone
(
)
;
for
(
const
auto
&
root
:
mThirdPartyCerts
)
{
Input
input
;
if
(
root
.
GetInput
(
input
)
=
=
Success
)
{
if
(
root
.
GetIsRoot
(
)
)
{
mThirdPartyRootInputs
.
AppendElement
(
input
)
;
}
else
{
mThirdPartyIntermediateInputs
.
AppendElement
(
input
)
;
}
}
}
}
CertVerifier
:
:
~
CertVerifier
(
)
=
default
;
Result
IsDelegatedCredentialAcceptable
(
const
DelegatedCredentialInfo
&
dcInfo
)
{
bool
isEcdsa
=
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp256r1_sha256
|
|
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp384r1_sha384
|
|
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp521r1_sha512
;
if
(
!
isEcdsa
)
{
return
Result
:
:
ERROR_INVALID_KEY
;
}
return
Result
:
:
Success
;
}
Result
IsCertBuiltInRoot
(
Input
certInput
bool
&
result
)
{
result
=
false
;
if
(
NS_FAILED
(
BlockUntilLoadableCertsLoaded
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
#
ifdef
DEBUG
nsCOMPtr
<
nsINSSComponent
>
component
(
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
)
;
if
(
!
component
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsTArray
<
uint8_t
>
certBytes
;
certBytes
.
AppendElements
(
certInput
.
UnsafeGetData
(
)
certInput
.
GetLength
(
)
)
;
if
(
NS_FAILED
(
component
-
>
IsCertTestBuiltInRoot
(
certBytes
&
result
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
result
)
{
return
Success
;
}
#
endif
SECItem
certItem
(
UnsafeMapInputToSECItem
(
certInput
)
)
;
AutoSECMODListReadLock
lock
;
for
(
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
for
(
int
i
=
0
;
i
<
list
-
>
module
-
>
slotCount
;
i
+
+
)
{
PK11SlotInfo
*
slot
=
list
-
>
module
-
>
slots
[
i
]
;
if
(
!
PK11_IsPresent
(
slot
)
|
|
!
PK11_HasRootCerts
(
slot
)
)
{
continue
;
}
CK_OBJECT_HANDLE
handle
=
PK11_FindEncodedCertInSlot
(
slot
&
certItem
nullptr
)
;
if
(
handle
=
=
CK_INVALID_HANDLE
)
{
continue
;
}
if
(
PK11_HasAttributeSet
(
slot
handle
CKA_NSS_MOZILLA_CA_POLICY
false
)
)
{
result
=
true
;
break
;
}
}
}
return
Success
;
}
static
Result
BuildCertChainForOneKeyUsage
(
NSSCertDBTrustDomain
&
trustDomain
Input
certDER
Time
time
KeyUsage
ku1
KeyUsage
ku2
KeyUsage
ku3
KeyPurposeId
eku
const
CertPolicyId
&
requiredPolicy
const
Input
*
stapledOCSPResponse
CertVerifier
:
:
OCSPStaplingStatus
*
ocspStaplingStatus
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
Result
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku1
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku2
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku3
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
!
=
Success
)
{
rv
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
;
}
}
}
if
(
ocspStaplingStatus
)
{
*
ocspStaplingStatus
=
trustDomain
.
GetOCSPStaplingStatus
(
)
;
}
return
rv
;
}
void
CertVerifier
:
:
LoadKnownCTLogs
(
)
{
if
(
mCTMode
=
=
CertificateTransparencyMode
:
:
Disabled
)
{
return
;
}
mCTVerifier
=
MakeUnique
<
MultiLogCTVerifier
>
(
)
;
for
(
const
CTLogInfo
&
log
:
kCTLogList
)
{
Input
publicKey
;
Result
rv
=
publicKey
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
log
.
key
)
log
.
keyLength
)
;
if
(
rv
!
=
Success
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
reading
a
log
key
for
a
known
CT
Log
"
)
;
continue
;
}
const
CTLogOperatorInfo
&
logOperator
=
kCTLogOperatorList
[
log
.
operatorIndex
]
;
CTLogVerifier
logVerifier
(
logOperator
.
id
log
.
state
log
.
timestamp
)
;
rv
=
logVerifier
.
Init
(
publicKey
)
;
if
(
rv
!
=
Success
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
initializing
a
known
CT
Log
"
)
;
continue
;
}
mCTVerifier
-
>
AddLog
(
std
:
:
move
(
logVerifier
)
)
;
}
}
Result
CertVerifier
:
:
VerifyCertificateTransparencyPolicy
(
NSSCertDBTrustDomain
&
trustDomain
const
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
Input
sctsFromTLS
Time
time
CertificateTransparencyInfo
*
ctInfo
)
{
if
(
ctInfo
)
{
ctInfo
-
>
Reset
(
)
;
}
if
(
mCTMode
=
=
CertificateTransparencyMode
:
:
Disabled
)
{
return
Success
;
}
if
(
time
>
TimeFromEpochInSeconds
(
kCTExpirationTime
/
PR_USEC_PER_SEC
)
)
{
return
Success
;
}
if
(
ctInfo
)
{
ctInfo
-
>
enabled
=
true
;
}
if
(
builtChain
.
IsEmpty
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Input
embeddedSCTs
=
trustDomain
.
GetSCTListFromCertificate
(
)
;
if
(
embeddedSCTs
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
embedded
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
embeddedSCTs
.
GetLength
(
)
)
)
)
;
}
Input
sctsFromOCSP
=
trustDomain
.
GetSCTListFromOCSPStapling
(
)
;
if
(
sctsFromOCSP
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
OCSP
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
sctsFromOCSP
.
GetLength
(
)
)
)
)
;
}
if
(
sctsFromTLS
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
TLS
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
sctsFromTLS
.
GetLength
(
)
)
)
)
;
}
if
(
builtChain
.
Length
(
)
=
=
1
)
{
if
(
ctInfo
)
{
CTVerifyResult
emptyResult
;
ctInfo
-
>
verifyResult
=
std
:
:
move
(
emptyResult
)
;
ctInfo
-
>
policyCompliance
.
emplace
(
CTPolicyCompliance
:
:
NotEnoughScts
)
;
}
return
Success
;
}
const
nsTArray
<
uint8_t
>
&
endEntityBytes
=
builtChain
.
ElementAt
(
0
)
;
Input
endEntityInput
;
Result
rv
=
endEntityInput
.
Init
(
endEntityBytes
.
Elements
(
)
endEntityBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
const
nsTArray
<
uint8_t
>
&
issuerBytes
=
builtChain
.
ElementAt
(
1
)
;
Input
issuerInput
;
rv
=
issuerInput
.
Init
(
issuerBytes
.
Elements
(
)
issuerBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
BackCert
issuerBackCert
(
issuerInput
EndEntityOrCA
:
:
MustBeCA
nullptr
)
;
rv
=
issuerBackCert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Input
issuerPublicKeyInput
=
issuerBackCert
.
GetSubjectPublicKeyInfo
(
)
;
CTVerifyResult
result
;
rv
=
mCTVerifier
-
>
Verify
(
endEntityInput
issuerPublicKeyInput
embeddedSCTs
sctsFromOCSP
sctsFromTLS
time
result
)
;
if
(
rv
!
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SCT
verification
failed
with
fatal
error
%
"
PRId32
"
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
if
(
MOZ_LOG_TEST
(
gCertVerifierLog
LogLevel
:
:
Debug
)
)
{
size_t
validCount
=
0
;
size_t
retiredLogCount
=
0
;
for
(
const
VerifiedSCT
&
verifiedSct
:
result
.
verifiedScts
)
{
switch
(
verifiedSct
.
logState
)
{
case
CTLogState
:
:
Admissible
:
validCount
+
+
;
break
;
case
CTLogState
:
:
Retired
:
retiredLogCount
+
+
;
break
;
}
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SCT
verification
result
:
"
"
valid
=
%
zu
unknownLog
=
%
zu
retiredLog
=
%
zu
"
"
invalidSignature
=
%
zu
invalidTimestamp
=
%
zu
"
"
decodingErrors
=
%
zu
\
n
"
validCount
result
.
sctsFromUnknownLogs
retiredLogCount
result
.
sctsWithInvalidSignatures
result
.
sctsWithInvalidTimestamps
result
.
decodingErrors
)
)
;
}
BackCert
endEntityBackCert
(
endEntityInput
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
;
rv
=
endEntityBackCert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Time
notBefore
(
Time
:
:
uninitialized
)
;
Time
notAfter
(
Time
:
:
uninitialized
)
;
rv
=
ParseValidity
(
endEntityBackCert
.
GetValidity
(
)
&
notBefore
&
notAfter
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Duration
certLifetime
(
notBefore
notAfter
)
;
CTPolicyCompliance
ctPolicyCompliance
=
CheckCTPolicyCompliance
(
result
.
verifiedScts
certLifetime
)
;
if
(
ctInfo
)
{
ctInfo
-
>
verifyResult
=
std
:
:
move
(
result
)
;
ctInfo
-
>
policyCompliance
.
emplace
(
ctPolicyCompliance
)
;
}
return
Success
;
}
Result
CertVerifier
:
:
VerifyCert
(
const
nsTArray
<
uint8_t
>
&
certBytes
SECCertificateUsage
usage
Time
time
void
*
pinArg
const
char
*
hostname
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
const
Flags
flags
const
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
extraCertificates
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponseArg
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLS
const
OriginAttributes
&
originAttributes
EVStatus
*
evStatus
OCSPStaplingStatus
*
ocspStaplingStatus
KeySizeStatus
*
keySizeStatus
PinningTelemetryInfo
*
pinningTelemetryInfo
CertificateTransparencyInfo
*
ctInfo
bool
*
isBuiltChainRootBuiltInRoot
bool
*
madeOCSPRequests
IssuerSources
*
issuerSources
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Top
of
VerifyCert
\
n
"
)
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
(
flags
&
FLAG_MUST_BE_EV
)
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
keySizeStatus
)
;
if
(
NS_FAILED
(
BlockUntilLoadableCertsLoaded
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
NS_FAILED
(
CheckForSmartCardChanges
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
evStatus
)
{
*
evStatus
=
EVStatus
:
:
NotEV
;
}
if
(
ocspStaplingStatus
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
ocspStaplingStatus
=
OCSP_STAPLING_NEVER_CHECKED
;
}
if
(
keySizeStatus
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
keySizeStatus
=
KeySizeStatus
:
:
NeverChecked
;
}
if
(
usage
!
=
certificateUsageSSLServer
&
&
(
flags
&
FLAG_MUST_BE_EV
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
false
;
}
if
(
madeOCSPRequests
)
{
*
madeOCSPRequests
=
false
;
}
if
(
issuerSources
)
{
issuerSources
-
>
clear
(
)
;
}
Input
certDER
;
Result
rv
=
certDER
.
Init
(
certBytes
.
Elements
(
)
certBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
NSSCertDBTrustDomain
:
:
OCSPFetching
defaultOCSPFetching
=
(
mOCSPDownloadConfig
=
=
ocspOff
)
|
|
(
mOCSPDownloadConfig
=
=
ocspEVOnly
)
|
|
(
flags
&
FLAG_LOCAL_ONLY
)
?
NSSCertDBTrustDomain
:
:
NeverFetchOCSP
:
!
mOCSPStrict
?
NSSCertDBTrustDomain
:
:
FetchOCSPForDVSoftFail
:
NSSCertDBTrustDomain
:
:
FetchOCSPForDVHardFail
;
Input
stapledOCSPResponseInput
;
const
Input
*
stapledOCSPResponse
=
nullptr
;
if
(
stapledOCSPResponseArg
)
{
rv
=
stapledOCSPResponseInput
.
Init
(
stapledOCSPResponseArg
-
>
Elements
(
)
stapledOCSPResponseArg
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
stapledOCSPResponse
=
&
stapledOCSPResponseInput
;
}
Input
sctsFromTLSInput
;
if
(
sctsFromTLS
)
{
rv
=
sctsFromTLSInput
.
Init
(
sctsFromTLS
-
>
Elements
(
)
sctsFromTLS
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
&
&
sctsFromTLSInput
.
GetLength
(
)
!
=
0
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
}
switch
(
usage
)
{
case
certificateUsageSSLClient
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
mSignatureCache
.
get
(
)
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_clientAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
madeOCSPRequests
)
{
*
madeOCSPRequests
|
=
trustDomain
.
GetOCSPFetchStatus
(
)
=
=
OCSPFetchStatus
:
:
Fetched
;
}
break
;
}
case
certificateUsageSSLServer
:
{
NSSCertDBTrustDomain
:
:
OCSPFetching
evOCSPFetching
=
(
mOCSPDownloadConfig
=
=
ocspOff
)
|
|
(
flags
&
FLAG_LOCAL_ONLY
)
?
NSSCertDBTrustDomain
:
:
LocalOnlyOCSPForEV
:
NSSCertDBTrustDomain
:
:
FetchOCSPForEV
;
nsTArray
<
CertPolicyId
>
evPolicies
;
GetKnownEVPolicies
(
certBytes
evPolicies
)
;
rv
=
Result
:
:
ERROR_UNKNOWN_ERROR
;
for
(
const
auto
&
evPolicy
:
evPolicies
)
{
NSSCertDBTrustDomain
trustDomain
(
trustSSL
evOCSPFetching
mOCSPCache
mSignatureCache
.
get
(
)
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS
ValidityCheckingMode
:
:
CheckForEV
mNetscapeStepUpPolicy
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
pinningTelemetryInfo
hostname
)
;
rv
=
BuildCertChainForOneKeyUsage
(
trustDomain
certDER
time
KeyUsage
:
:
digitalSignature
KeyUsage
:
:
keyEncipherment
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_serverAuth
evPolicy
stapledOCSPResponse
ocspStaplingStatus
)
;
if
(
madeOCSPRequests
)
{
*
madeOCSPRequests
|
=
trustDomain
.
GetOCSPFetchStatus
(
)
=
=
OCSPFetchStatus
:
:
Fetched
;
}
if
(
issuerSources
)
{
*
issuerSources
=
trustDomain
.
GetIssuerSources
(
)
;
}
if
(
rv
=
=
Success
)
{
rv
=
VerifyCertificateTransparencyPolicy
(
trustDomain
builtChain
sctsFromTLSInput
time
ctInfo
)
;
}
if
(
rv
=
=
Success
)
{
if
(
evStatus
)
{
*
evStatus
=
EVStatus
:
:
EV
;
}
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
trustDomain
.
GetIsBuiltChainRootBuiltInRoot
(
)
;
}
break
;
}
}
if
(
rv
=
=
Success
)
{
break
;
}
if
(
flags
&
FLAG_MUST_BE_EV
)
{
rv
=
Result
:
:
ERROR_POLICY_VALIDATION_FAILED
;
break
;
}
unsigned
int
keySizeOptions
[
]
=
{
MIN_RSA_BITS
MIN_RSA_BITS_WEAK
}
;
KeySizeStatus
keySizeStatuses
[
]
=
{
KeySizeStatus
:
:
LargeMinimumSucceeded
KeySizeStatus
:
:
CompatibilityRisk
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
keySizeOptions
)
=
=
MOZ_ARRAY_LENGTH
(
keySizeStatuses
)
"
keySize
array
lengths
differ
"
)
;
size_t
keySizeOptionsCount
=
MOZ_ARRAY_LENGTH
(
keySizeStatuses
)
;
for
(
size_t
i
=
0
;
i
<
keySizeOptionsCount
&
&
rv
!
=
Success
;
i
+
+
)
{
if
(
pinningTelemetryInfo
)
{
pinningTelemetryInfo
-
>
Reset
(
)
;
}
NSSCertDBTrustDomain
trustDomain
(
trustSSL
defaultOCSPFetching
mOCSPCache
mSignatureCache
.
get
(
)
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
keySizeOptions
[
i
]
ValidityCheckingMode
:
:
CheckingOff
mNetscapeStepUpPolicy
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
pinningTelemetryInfo
hostname
)
;
rv
=
BuildCertChainForOneKeyUsage
(
trustDomain
certDER
time
KeyUsage
:
:
digitalSignature
KeyUsage
:
:
keyEncipherment
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
ocspStaplingStatus
)
;
if
(
madeOCSPRequests
)
{
*
madeOCSPRequests
|
=
trustDomain
.
GetOCSPFetchStatus
(
)
=
=
OCSPFetchStatus
:
:
Fetched
;
}
if
(
issuerSources
)
{
*
issuerSources
=
trustDomain
.
GetIssuerSources
(
)
;
}
if
(
rv
!
=
Success
&
&
!
IsFatalError
(
rv
)
&
&
rv
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
&
&
trustDomain
.
GetIsErrorDueToDistrustedCAPolicy
(
)
)
{
rv
=
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
if
(
rv
=
=
Success
)
{
rv
=
VerifyCertificateTransparencyPolicy
(
trustDomain
builtChain
sctsFromTLSInput
time
ctInfo
)
;
}
if
(
rv
=
=
Success
)
{
if
(
keySizeStatus
)
{
*
keySizeStatus
=
keySizeStatuses
[
i
]
;
}
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
trustDomain
.
GetIsBuiltChainRootBuiltInRoot
(
)
;
}
break
;
}
}
if
(
rv
!
=
Success
&
&
keySizeStatus
)
{
*
keySizeStatus
=
KeySizeStatus
:
:
AlreadyBad
;
}
break
;
}
case
certificateUsageSSLCA
:
{
NSSCertDBTrustDomain
trustDomain
(
trustSSL
defaultOCSPFetching
mOCSPCache
mSignatureCache
.
get
(
)
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
mNetscapeStepUpPolicy
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeCA
KeyUsage
:
:
keyCertSign
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
madeOCSPRequests
)
{
*
madeOCSPRequests
|
=
trustDomain
.
GetOCSPFetchStatus
(
)
=
=
OCSPFetchStatus
:
:
Fetched
;
}
break
;
}
case
certificateUsageEmailSigner
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
mSignatureCache
.
get
(
)
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
nonRepudiation
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
}
if
(
madeOCSPRequests
)
{
*
madeOCSPRequests
|
=
trustDomain
.
GetOCSPFetchStatus
(
)
=
=
OCSPFetchStatus
:
:
Fetched
;
}
break
;
}
case
certificateUsageEmailRecipient
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
mSignatureCache
.
get
(
)
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
keyEncipherment
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
}
if
(
madeOCSPRequests
)
{
*
madeOCSPRequests
|
=
trustDomain
.
GetOCSPFetchStatus
(
)
=
=
OCSPFetchStatus
:
:
Fetched
;
}
break
;
}
default
:
rv
=
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
Success
;
}
static
bool
CertIsSelfSigned
(
const
BackCert
&
backCert
void
*
pinarg
)
{
if
(
!
InputsAreEqual
(
backCert
.
GetIssuer
(
)
backCert
.
GetSubject
(
)
)
)
{
return
false
;
}
nsTArray
<
Span
<
const
uint8_t
>
>
emptyCertList
;
mozilla
:
:
psm
:
:
AppTrustDomain
trustDomain
(
std
:
:
move
(
emptyCertList
)
)
;
Result
rv
=
VerifySignedData
(
trustDomain
backCert
.
GetSignedData
(
)
backCert
.
GetSubjectPublicKeyInfo
(
)
)
;
return
rv
=
=
Success
;
}
static
Result
CheckCertHostnameHelper
(
Input
peerCertInput
const
nsACString
&
hostname
bool
rootIsBuiltIn
)
{
Input
hostnameInput
;
Result
rv
=
hostnameInput
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
hostname
.
BeginReading
(
)
)
hostname
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
SkipInvalidSANsForNonBuiltInRootsPolicy
nameMatchingPolicy
(
rootIsBuiltIn
)
;
rv
=
CheckCertHostname
(
peerCertInput
hostnameInput
nameMatchingPolicy
)
;
if
(
rv
=
=
Result
:
:
ERROR_BAD_DER
)
{
return
Result
:
:
ERROR_BAD_CERT_DOMAIN
;
}
return
rv
;
}
Result
CertVerifier
:
:
VerifySSLServerCert
(
const
nsTArray
<
uint8_t
>
&
peerCertBytes
Time
time
void
*
pinarg
const
nsACString
&
hostname
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
Flags
flags
const
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
extraCertificates
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLS
const
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
const
OriginAttributes
&
originAttributes
EVStatus
*
evStatus
OCSPStaplingStatus
*
ocspStaplingStatus
KeySizeStatus
*
keySizeStatus
PinningTelemetryInfo
*
pinningTelemetryInfo
CertificateTransparencyInfo
*
ctInfo
bool
*
isBuiltChainRootBuiltInRoot
bool
*
madeOCSPRequests
IssuerSources
*
issuerSources
)
{
MOZ_ASSERT
(
!
hostname
.
IsEmpty
(
)
)
;
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
false
;
}
if
(
evStatus
)
{
*
evStatus
=
EVStatus
:
:
NotEV
;
}
if
(
hostname
.
IsEmpty
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Input
peerCertInput
;
Result
rv
=
peerCertInput
.
Init
(
peerCertBytes
.
Elements
(
)
peerCertBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
bool
isBuiltChainRootBuiltInRootLocal
;
rv
=
VerifyCert
(
peerCertBytes
certificateUsageSSLServer
time
pinarg
PromiseFlatCString
(
hostname
)
.
get
(
)
builtChain
flags
extraCertificates
stapledOCSPResponse
sctsFromTLS
originAttributes
evStatus
ocspStaplingStatus
keySizeStatus
pinningTelemetryInfo
ctInfo
&
isBuiltChainRootBuiltInRootLocal
madeOCSPRequests
issuerSources
)
;
if
(
rv
!
=
Success
)
{
EndEntityOrCA
notUsedForPaths
=
EndEntityOrCA
:
:
MustBeEndEntity
;
BackCert
peerBackCert
(
peerCertInput
notUsedForPaths
nullptr
)
;
if
(
peerBackCert
.
Init
(
)
!
=
Success
)
{
return
rv
;
}
if
(
(
rv
=
=
Result
:
:
ERROR_UNKNOWN_ISSUER
|
|
rv
=
=
Result
:
:
ERROR_BAD_SIGNATURE
|
|
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
&
&
CertIsSelfSigned
(
peerBackCert
pinarg
)
)
{
return
Result
:
:
ERROR_SELF_SIGNED_CERT
;
}
if
(
rv
=
=
Result
:
:
ERROR_UNKNOWN_ISSUER
)
{
nsCOMPtr
<
nsINSSComponent
>
component
(
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
)
;
if
(
!
component
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Input
issuerNameInput
=
peerBackCert
.
GetIssuer
(
)
;
SECItem
issuerNameItem
=
UnsafeMapInputToSECItem
(
issuerNameInput
)
;
UniquePORTString
issuerName
(
CERT_DerNameToAscii
(
&
issuerNameItem
)
)
;
if
(
!
issuerName
)
{
return
Result
:
:
ERROR_BAD_DER
;
}
nsresult
rv
=
component
-
>
IssuerMatchesMitmCanary
(
issuerName
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
Result
:
:
ERROR_MITM_DETECTED
;
}
}
if
(
rv
=
=
Result
:
:
ERROR_EXPIRED_CERTIFICATE
|
|
rv
=
=
Result
:
:
ERROR_NOT_YET_VALID_CERTIFICATE
|
|
rv
=
=
Result
:
:
ERROR_INVALID_DER_TIME
)
{
Result
hostnameResult
=
CheckCertHostnameHelper
(
peerCertInput
hostname
false
)
;
if
(
hostnameResult
!
=
Success
)
{
return
hostnameResult
;
}
}
return
rv
;
}
if
(
dcInfo
)
{
rv
=
IsDelegatedCredentialAcceptable
(
*
dcInfo
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
Input
stapledOCSPResponseInput
;
Input
*
responseInputPtr
=
nullptr
;
if
(
stapledOCSPResponse
)
{
rv
=
stapledOCSPResponseInput
.
Init
(
stapledOCSPResponse
-
>
Elements
(
)
stapledOCSPResponse
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
responseInputPtr
=
&
stapledOCSPResponseInput
;
}
if
(
!
(
flags
&
FLAG_TLS_IGNORE_STATUS_REQUEST
)
)
{
rv
=
CheckTLSFeaturesAreSatisfied
(
peerCertInput
responseInputPtr
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
rv
=
CheckCertHostnameHelper
(
peerCertInput
hostname
isBuiltChainRootBuiltInRootLocal
)
;
if
(
(
rv
=
=
Success
|
|
rv
=
=
Result
:
:
ERROR_BAD_CERT_DOMAIN
)
&
&
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
isBuiltChainRootBuiltInRootLocal
;
}
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
Success
;
}
void
HashSignatureParams
(
pkix
:
:
Input
data
pkix
:
:
Input
signature
pkix
:
:
Input
subjectPublicKeyInfo
pkix
:
:
der
:
:
PublicKeyAlgorithm
publicKeyAlgorithm
pkix
:
:
DigestAlgorithm
digestAlgorithm
Maybe
<
nsTArray
<
uint8_t
>
>
&
sha512Hash
)
{
sha512Hash
.
reset
(
)
;
Digest
digest
;
if
(
NS_FAILED
(
digest
.
Begin
(
SEC_OID_SHA512
)
)
)
{
return
;
}
pkix
:
:
Input
:
:
size_type
dataLength
=
data
.
GetLength
(
)
;
if
(
NS_FAILED
(
digest
.
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
dataLength
)
sizeof
(
dataLength
)
)
)
)
{
return
;
}
if
(
NS_FAILED
(
digest
.
Update
(
data
.
UnsafeGetData
(
)
dataLength
)
)
)
{
return
;
}
pkix
:
:
Input
:
:
size_type
signatureLength
=
signature
.
GetLength
(
)
;
if
(
NS_FAILED
(
digest
.
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
signatureLength
)
sizeof
(
signatureLength
)
)
)
)
{
return
;
}
if
(
NS_FAILED
(
digest
.
Update
(
signature
.
UnsafeGetData
(
)
signatureLength
)
)
)
{
return
;
}
pkix
:
:
Input
:
:
size_type
spkiLength
=
subjectPublicKeyInfo
.
GetLength
(
)
;
if
(
NS_FAILED
(
digest
.
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
spkiLength
)
sizeof
(
spkiLength
)
)
)
)
{
return
;
}
if
(
NS_FAILED
(
digest
.
Update
(
subjectPublicKeyInfo
.
UnsafeGetData
(
)
spkiLength
)
)
)
{
return
;
}
if
(
NS_FAILED
(
digest
.
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
publicKeyAlgorithm
)
sizeof
(
publicKeyAlgorithm
)
)
)
)
{
return
;
}
if
(
NS_FAILED
(
digest
.
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
digestAlgorithm
)
sizeof
(
digestAlgorithm
)
)
)
)
{
return
;
}
nsTArray
<
uint8_t
>
result
;
if
(
NS_FAILED
(
digest
.
End
(
result
)
)
)
{
return
;
}
sha512Hash
.
emplace
(
std
:
:
move
(
result
)
)
;
}
Result
VerifySignedDataWithCache
(
der
:
:
PublicKeyAlgorithm
publicKeyAlg
mozilla
:
:
glean
:
:
impl
:
:
DenominatorMetric
telemetryDenominator
mozilla
:
:
glean
:
:
impl
:
:
NumeratorMetric
telemetryNumerator
Input
data
DigestAlgorithm
digestAlgorithm
Input
signature
Input
subjectPublicKeyInfo
SignatureCache
*
signatureCache
void
*
pinArg
)
{
telemetryDenominator
.
Add
(
1
)
;
Maybe
<
nsTArray
<
uint8_t
>
>
sha512Hash
;
HashSignatureParams
(
data
signature
subjectPublicKeyInfo
publicKeyAlg
digestAlgorithm
sha512Hash
)
;
if
(
sha512Hash
.
isSome
(
)
&
&
signature_cache_get
(
signatureCache
sha512Hash
.
ref
(
)
.
Elements
(
)
)
)
{
telemetryNumerator
.
AddToNumerator
(
1
)
;
return
Success
;
}
Result
result
;
switch
(
publicKeyAlg
)
{
case
der
:
:
PublicKeyAlgorithm
:
:
ECDSA
:
result
=
VerifyECDSASignedDataNSS
(
data
digestAlgorithm
signature
subjectPublicKeyInfo
pinArg
)
;
break
;
case
der
:
:
PublicKeyAlgorithm
:
:
RSA_PKCS1
:
result
=
VerifyRSAPKCS1SignedDataNSS
(
data
digestAlgorithm
signature
subjectPublicKeyInfo
pinArg
)
;
break
;
case
der
:
:
PublicKeyAlgorithm
:
:
RSA_PSS
:
result
=
VerifyRSAPSSSignedDataNSS
(
data
digestAlgorithm
signature
subjectPublicKeyInfo
pinArg
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unhandled
public
key
algorithm
"
)
;
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
sha512Hash
.
isSome
(
)
&
&
result
=
=
Success
)
{
signature_cache_insert
(
signatureCache
sha512Hash
.
ref
(
)
.
Elements
(
)
)
;
}
return
result
;
}
}
}
