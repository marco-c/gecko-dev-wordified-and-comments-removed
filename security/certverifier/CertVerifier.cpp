#
include
"
CertVerifier
.
h
"
#
include
<
stdint
.
h
>
#
include
"
CTDiversityPolicy
.
h
"
#
include
"
CTKnownLogs
.
h
"
#
include
"
CTLogVerifier
.
h
"
#
include
"
CSTrustDomain
.
h
"
#
include
"
ExtendedValidation
.
h
"
#
include
"
MultiLogCTVerifier
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
NSSErrorsService
.
h
"
#
include
"
cert
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsPromiseFlatString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixcheck
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
secmod
.
h
"
using
namespace
mozilla
:
:
ct
;
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
mozilla
:
:
LazyLogModule
gCertVerifierLog
(
"
certverifier
"
)
;
extern
mozilla
:
:
pkix
:
:
Result
GetCertLifetimeInFullMonths
(
Time
certNotBefore
Time
certNotAfter
size_t
&
months
)
{
if
(
certNotBefore
>
=
certNotAfter
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
notBefore
<
notAfter
"
)
;
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
uint64_t
notBeforeSeconds
;
Result
rv
=
SecondsSinceEpochFromTime
(
certNotBefore
&
notBeforeSeconds
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
uint64_t
notAfterSeconds
;
rv
=
SecondsSinceEpochFromTime
(
certNotAfter
&
notAfterSeconds
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
PRTime
notBeforePR
=
static_cast
<
PRTime
>
(
notBeforeSeconds
)
*
1000000
;
PRTime
notAfterPR
=
static_cast
<
PRTime
>
(
notAfterSeconds
)
*
1000000
;
PRExplodedTime
explodedNotBefore
;
PRExplodedTime
explodedNotAfter
;
PR_ExplodeTime
(
notBeforePR
PR_LocalTimeParameters
&
explodedNotBefore
)
;
PR_ExplodeTime
(
notAfterPR
PR_LocalTimeParameters
&
explodedNotAfter
)
;
PRInt32
signedMonths
=
(
explodedNotAfter
.
tm_year
-
explodedNotBefore
.
tm_year
)
*
12
+
(
explodedNotAfter
.
tm_month
-
explodedNotBefore
.
tm_month
)
;
if
(
explodedNotAfter
.
tm_mday
<
explodedNotBefore
.
tm_mday
)
{
-
-
signedMonths
;
}
if
(
signedMonths
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
explodedNotBefore
<
explodedNotAfter
"
)
;
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
months
=
static_cast
<
size_t
>
(
signedMonths
)
;
return
Success
;
}
namespace
mozilla
{
namespace
psm
{
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_LOCAL_ONLY
=
1
;
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_MUST_BE_EV
=
2
;
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
=
4
;
static
const
unsigned
int
MIN_RSA_BITS
=
2048
;
static
const
unsigned
int
MIN_RSA_BITS_WEAK
=
1024
;
void
CertificateTransparencyInfo
:
:
Reset
(
)
{
enabled
=
false
;
verifyResult
.
Reset
(
)
;
policyCompliance
=
CTPolicyCompliance
:
:
Unknown
;
}
CertVerifier
:
:
CertVerifier
(
OcspDownloadConfig
odc
OcspStrictConfig
osc
mozilla
:
:
TimeDuration
ocspTimeoutSoft
mozilla
:
:
TimeDuration
ocspTimeoutHard
uint32_t
certShortLifetimeInDays
SHA1Mode
sha1Mode
BRNameMatchingPolicy
:
:
Mode
nameMatchingMode
NetscapeStepUpPolicy
netscapeStepUpPolicy
CertificateTransparencyMode
ctMode
CRLiteMode
crliteMode
uint64_t
crliteCTMergeDelaySeconds
const
Vector
<
EnterpriseCert
>
&
thirdPartyCerts
)
:
mOCSPDownloadConfig
(
odc
)
mOCSPStrict
(
osc
=
=
ocspStrict
)
mOCSPTimeoutSoft
(
ocspTimeoutSoft
)
mOCSPTimeoutHard
(
ocspTimeoutHard
)
mCertShortLifetimeInDays
(
certShortLifetimeInDays
)
mSHA1Mode
(
sha1Mode
)
mNameMatchingMode
(
nameMatchingMode
)
mNetscapeStepUpPolicy
(
netscapeStepUpPolicy
)
mCTMode
(
ctMode
)
mCRLiteMode
(
crliteMode
)
mCRLiteCTMergeDelaySeconds
(
crliteCTMergeDelaySeconds
)
{
LoadKnownCTLogs
(
)
;
for
(
const
auto
&
root
:
thirdPartyCerts
)
{
EnterpriseCert
rootCopy
;
if
(
NS_SUCCEEDED
(
rootCopy
.
Init
(
root
)
)
)
{
Unused
<
<
mThirdPartyCerts
.
append
(
std
:
:
move
(
rootCopy
)
)
;
}
}
for
(
const
auto
&
root
:
mThirdPartyCerts
)
{
Input
input
;
if
(
root
.
GetInput
(
input
)
=
=
Success
)
{
if
(
root
.
GetIsRoot
(
)
)
{
Unused
<
<
mThirdPartyRootInputs
.
append
(
input
)
;
}
else
{
Unused
<
<
mThirdPartyIntermediateInputs
.
append
(
input
)
;
}
}
}
}
CertVerifier
:
:
~
CertVerifier
(
)
=
default
;
Result
IsCertChainRootBuiltInRoot
(
const
nsTArray
<
nsTArray
<
uint8_t
>
>
&
chain
bool
&
result
)
{
if
(
chain
.
IsEmpty
(
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
const
nsTArray
<
uint8_t
>
&
rootBytes
=
chain
.
LastElement
(
)
;
Input
rootInput
;
Result
rv
=
rootInput
.
Init
(
rootBytes
.
Elements
(
)
rootBytes
.
Length
(
)
)
;
if
(
rv
!
=
Result
:
:
Success
)
{
return
rv
;
}
return
IsCertBuiltInRoot
(
rootInput
result
)
;
}
Result
IsDelegatedCredentialAcceptable
(
const
DelegatedCredentialInfo
&
dcInfo
)
{
bool
isEcdsa
=
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp256r1_sha256
|
|
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp384r1_sha384
|
|
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp521r1_sha512
;
if
(
!
isEcdsa
)
{
return
Result
:
:
ERROR_INVALID_KEY
;
}
return
Result
:
:
Success
;
}
Result
IsCertBuiltInRoot
(
Input
certInput
bool
&
result
)
{
if
(
NS_FAILED
(
BlockUntilLoadableCertsLoaded
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
CERTCertDBHandle
*
certDB
(
CERT_GetDefaultCertDB
(
)
)
;
SECItem
certDER
(
UnsafeMapInputToSECItem
(
certInput
)
)
;
UniqueCERTCertificate
cert
(
CERT_NewTempCertificate
(
certDB
&
certDER
nullptr
false
true
)
)
;
if
(
!
cert
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
result
=
false
;
#
ifdef
DEBUG
nsCOMPtr
<
nsINSSComponent
>
component
(
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
)
;
if
(
!
component
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsresult
rv
=
component
-
>
IsCertTestBuiltInRoot
(
cert
.
get
(
)
&
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
result
)
{
return
Success
;
}
#
endif
AutoSECMODListReadLock
lock
;
for
(
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
for
(
int
i
=
0
;
i
<
list
-
>
module
-
>
slotCount
;
i
+
+
)
{
PK11SlotInfo
*
slot
=
list
-
>
module
-
>
slots
[
i
]
;
if
(
PK11_IsPresent
(
slot
)
&
&
PK11_HasRootCerts
(
slot
)
)
{
CK_OBJECT_HANDLE
handle
=
PK11_FindCertInSlot
(
slot
cert
.
get
(
)
nullptr
)
;
if
(
handle
!
=
CK_INVALID_HANDLE
&
&
PK11_HasAttributeSet
(
slot
handle
CKA_NSS_MOZILLA_CA_POLICY
false
)
)
{
result
=
true
;
break
;
}
}
}
}
return
Success
;
}
static
Result
BuildCertChainForOneKeyUsage
(
NSSCertDBTrustDomain
&
trustDomain
Input
certDER
Time
time
KeyUsage
ku1
KeyUsage
ku2
KeyUsage
ku3
KeyPurposeId
eku
const
CertPolicyId
&
requiredPolicy
const
Input
*
stapledOCSPResponse
CertVerifier
:
:
OCSPStaplingStatus
*
ocspStaplingStatus
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
Result
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku1
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku2
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku3
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
!
=
Success
)
{
rv
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
;
}
}
}
if
(
ocspStaplingStatus
)
{
*
ocspStaplingStatus
=
trustDomain
.
GetOCSPStaplingStatus
(
)
;
}
return
rv
;
}
void
CertVerifier
:
:
LoadKnownCTLogs
(
)
{
if
(
mCTMode
=
=
CertificateTransparencyMode
:
:
Disabled
)
{
return
;
}
mCTVerifier
=
MakeUnique
<
MultiLogCTVerifier
>
(
)
;
for
(
const
CTLogInfo
&
log
:
kCTLogList
)
{
Input
publicKey
;
Result
rv
=
publicKey
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
log
.
key
)
log
.
keyLength
)
;
if
(
rv
!
=
Success
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
reading
a
log
key
for
a
known
CT
Log
"
)
;
continue
;
}
CTLogVerifier
logVerifier
;
const
CTLogOperatorInfo
&
logOperator
=
kCTLogOperatorList
[
log
.
operatorIndex
]
;
rv
=
logVerifier
.
Init
(
publicKey
logOperator
.
id
log
.
status
log
.
disqualificationTime
)
;
if
(
rv
!
=
Success
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
initializing
a
known
CT
Log
"
)
;
continue
;
}
mCTVerifier
-
>
AddLog
(
std
:
:
move
(
logVerifier
)
)
;
}
mCTDiversityPolicy
=
MakeUnique
<
CTDiversityPolicy
>
(
)
;
}
Result
CertVerifier
:
:
VerifyCertificateTransparencyPolicy
(
NSSCertDBTrustDomain
&
trustDomain
const
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
Input
sctsFromTLS
Time
time
CertificateTransparencyInfo
*
ctInfo
)
{
if
(
ctInfo
)
{
ctInfo
-
>
Reset
(
)
;
}
if
(
mCTMode
=
=
CertificateTransparencyMode
:
:
Disabled
)
{
return
Success
;
}
if
(
ctInfo
)
{
ctInfo
-
>
enabled
=
true
;
}
if
(
builtChain
.
IsEmpty
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Input
embeddedSCTs
=
trustDomain
.
GetSCTListFromCertificate
(
)
;
if
(
embeddedSCTs
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
embedded
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
embeddedSCTs
.
GetLength
(
)
)
)
)
;
}
Input
sctsFromOCSP
=
trustDomain
.
GetSCTListFromOCSPStapling
(
)
;
if
(
sctsFromOCSP
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
OCSP
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
sctsFromOCSP
.
GetLength
(
)
)
)
)
;
}
if
(
sctsFromTLS
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
TLS
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
sctsFromTLS
.
GetLength
(
)
)
)
)
;
}
if
(
builtChain
.
Length
(
)
=
=
1
)
{
if
(
ctInfo
)
{
CTVerifyResult
emptyResult
;
ctInfo
-
>
verifyResult
=
std
:
:
move
(
emptyResult
)
;
ctInfo
-
>
policyCompliance
=
CTPolicyCompliance
:
:
NotEnoughScts
;
}
return
Success
;
}
const
nsTArray
<
uint8_t
>
&
endEntityBytes
=
builtChain
.
ElementAt
(
0
)
;
Input
endEntityInput
;
Result
rv
=
endEntityInput
.
Init
(
endEntityBytes
.
Elements
(
)
endEntityBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
const
nsTArray
<
uint8_t
>
&
issuerBytes
=
builtChain
.
ElementAt
(
1
)
;
Input
issuerInput
;
rv
=
issuerInput
.
Init
(
issuerBytes
.
Elements
(
)
issuerBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
BackCert
issuerBackCert
(
issuerInput
EndEntityOrCA
:
:
MustBeCA
nullptr
)
;
rv
=
issuerBackCert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Input
issuerPublicKeyInput
=
issuerBackCert
.
GetSubjectPublicKeyInfo
(
)
;
CTVerifyResult
result
;
rv
=
mCTVerifier
-
>
Verify
(
endEntityInput
issuerPublicKeyInput
embeddedSCTs
sctsFromOCSP
sctsFromTLS
time
result
)
;
if
(
rv
!
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SCT
verification
failed
with
fatal
error
%
"
PRId32
"
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
if
(
MOZ_LOG_TEST
(
gCertVerifierLog
LogLevel
:
:
Debug
)
)
{
size_t
validCount
=
0
;
size_t
unknownLogCount
=
0
;
size_t
disqualifiedLogCount
=
0
;
size_t
invalidSignatureCount
=
0
;
size_t
invalidTimestampCount
=
0
;
for
(
const
VerifiedSCT
&
verifiedSct
:
result
.
verifiedScts
)
{
switch
(
verifiedSct
.
status
)
{
case
VerifiedSCT
:
:
Status
:
:
Valid
:
validCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
ValidFromDisqualifiedLog
:
disqualifiedLogCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
UnknownLog
:
unknownLogCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
InvalidSignature
:
invalidSignatureCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
InvalidTimestamp
:
invalidTimestampCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
None
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
SCT
verification
status
"
)
;
}
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SCT
verification
result
:
"
"
valid
=
%
zu
unknownLog
=
%
zu
disqualifiedLog
=
%
zu
"
"
invalidSignature
=
%
zu
invalidTimestamp
=
%
zu
"
"
decodingErrors
=
%
zu
\
n
"
validCount
unknownLogCount
disqualifiedLogCount
invalidSignatureCount
invalidTimestampCount
result
.
decodingErrors
)
)
;
}
BackCert
endEntityBackCert
(
endEntityInput
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
;
rv
=
endEntityBackCert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Time
notBefore
(
Time
:
:
uninitialized
)
;
Time
notAfter
(
Time
:
:
uninitialized
)
;
rv
=
ParseValidity
(
endEntityBackCert
.
GetValidity
(
)
&
notBefore
&
notAfter
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
size_t
lifetimeInMonths
;
rv
=
GetCertLifetimeInFullMonths
(
notBefore
notAfter
lifetimeInMonths
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
CTLogOperatorList
allOperators
;
GetCTLogOperatorsFromVerifiedSCTList
(
result
.
verifiedScts
allOperators
)
;
CTLogOperatorList
dependentOperators
;
rv
=
mCTDiversityPolicy
-
>
GetDependentOperators
(
builtChain
allOperators
dependentOperators
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
CTPolicyEnforcer
ctPolicyEnforcer
;
CTPolicyCompliance
ctPolicyCompliance
;
ctPolicyEnforcer
.
CheckCompliance
(
result
.
verifiedScts
lifetimeInMonths
dependentOperators
ctPolicyCompliance
)
;
if
(
ctInfo
)
{
ctInfo
-
>
verifyResult
=
std
:
:
move
(
result
)
;
ctInfo
-
>
policyCompliance
=
ctPolicyCompliance
;
}
return
Success
;
}
bool
CertVerifier
:
:
SHA1ModeMoreRestrictiveThanGivenMode
(
SHA1Mode
mode
)
{
switch
(
mSHA1Mode
)
{
case
SHA1Mode
:
:
Forbidden
:
return
mode
!
=
SHA1Mode
:
:
Forbidden
;
case
SHA1Mode
:
:
ImportedRoot
:
return
mode
!
=
SHA1Mode
:
:
Forbidden
&
&
mode
!
=
SHA1Mode
:
:
ImportedRoot
;
case
SHA1Mode
:
:
ImportedRootOrBefore2016
:
return
mode
=
=
SHA1Mode
:
:
Allowed
;
case
SHA1Mode
:
:
Allowed
:
return
false
;
case
SHA1Mode
:
:
UsedToBeBefore2016ButNowIsForbidden
:
default
:
MOZ_ASSERT
(
false
"
unexpected
SHA1Mode
type
"
)
;
return
true
;
}
}
Result
CertVerifier
:
:
VerifyCert
(
const
nsTArray
<
uint8_t
>
&
certBytes
SECCertificateUsage
usage
Time
time
void
*
pinArg
const
char
*
hostname
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
const
Flags
flags
const
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
extraCertificates
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponseArg
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLS
const
OriginAttributes
&
originAttributes
EVStatus
*
evStatus
OCSPStaplingStatus
*
ocspStaplingStatus
KeySizeStatus
*
keySizeStatus
SHA1ModeResult
*
sha1ModeResult
PinningTelemetryInfo
*
pinningTelemetryInfo
CertificateTransparencyInfo
*
ctInfo
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Top
of
VerifyCert
\
n
"
)
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
(
flags
&
FLAG_MUST_BE_EV
)
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
keySizeStatus
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
sha1ModeResult
)
;
if
(
NS_FAILED
(
BlockUntilLoadableCertsLoaded
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
NS_FAILED
(
CheckForSmartCardChanges
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
evStatus
)
{
*
evStatus
=
EVStatus
:
:
NotEV
;
}
if
(
ocspStaplingStatus
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
ocspStaplingStatus
=
OCSP_STAPLING_NEVER_CHECKED
;
}
if
(
keySizeStatus
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
keySizeStatus
=
KeySizeStatus
:
:
NeverChecked
;
}
if
(
sha1ModeResult
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
sha1ModeResult
=
SHA1ModeResult
:
:
NeverChecked
;
}
if
(
usage
!
=
certificateUsageSSLServer
&
&
(
flags
&
FLAG_MUST_BE_EV
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Input
certDER
;
Result
rv
=
certDER
.
Init
(
certBytes
.
Elements
(
)
certBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
NSSCertDBTrustDomain
:
:
OCSPFetching
defaultOCSPFetching
=
(
mOCSPDownloadConfig
=
=
ocspOff
)
|
|
(
mOCSPDownloadConfig
=
=
ocspEVOnly
)
|
|
(
flags
&
FLAG_LOCAL_ONLY
)
?
NSSCertDBTrustDomain
:
:
NeverFetchOCSP
:
!
mOCSPStrict
?
NSSCertDBTrustDomain
:
:
FetchOCSPForDVSoftFail
:
NSSCertDBTrustDomain
:
:
FetchOCSPForDVHardFail
;
Input
stapledOCSPResponseInput
;
const
Input
*
stapledOCSPResponse
=
nullptr
;
if
(
stapledOCSPResponseArg
)
{
rv
=
stapledOCSPResponseInput
.
Init
(
stapledOCSPResponseArg
-
>
Elements
(
)
stapledOCSPResponseArg
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
stapledOCSPResponse
=
&
stapledOCSPResponseInput
;
}
Input
sctsFromTLSInput
;
if
(
sctsFromTLS
)
{
rv
=
sctsFromTLSInput
.
Init
(
sctsFromTLS
-
>
Elements
(
)
sctsFromTLS
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
&
&
sctsFromTLSInput
.
GetLength
(
)
!
=
0
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
}
switch
(
usage
)
{
case
certificateUsageSSLClient
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
SHA1Mode
:
:
Allowed
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
mCRLiteCTMergeDelaySeconds
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_clientAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
break
;
}
case
certificateUsageSSLServer
:
{
SHA1Mode
sha1ModeConfigurations
[
]
=
{
SHA1Mode
:
:
Forbidden
SHA1Mode
:
:
ImportedRoot
SHA1Mode
:
:
ImportedRootOrBefore2016
SHA1Mode
:
:
Allowed
}
;
SHA1ModeResult
sha1ModeResults
[
]
=
{
SHA1ModeResult
:
:
SucceededWithoutSHA1
SHA1ModeResult
:
:
SucceededWithImportedRoot
SHA1ModeResult
:
:
SucceededWithImportedRootOrSHA1Before2016
SHA1ModeResult
:
:
SucceededWithSHA1
}
;
size_t
sha1ModeConfigurationsCount
=
MOZ_ARRAY_LENGTH
(
sha1ModeConfigurations
)
;
static_assert
(
MOZ_ARRAY_LENGTH
(
sha1ModeConfigurations
)
=
=
MOZ_ARRAY_LENGTH
(
sha1ModeResults
)
"
digestAlgorithm
array
lengths
differ
"
)
;
NSSCertDBTrustDomain
:
:
OCSPFetching
evOCSPFetching
=
(
mOCSPDownloadConfig
=
=
ocspOff
)
|
|
(
flags
&
FLAG_LOCAL_ONLY
)
?
NSSCertDBTrustDomain
:
:
LocalOnlyOCSPForEV
:
NSSCertDBTrustDomain
:
:
FetchOCSPForEV
;
CertPolicyId
evPolicy
;
bool
foundEVPolicy
=
GetFirstEVPolicy
(
certBytes
evPolicy
)
;
rv
=
Result
:
:
ERROR_UNKNOWN_ERROR
;
for
(
size_t
i
=
0
;
i
<
sha1ModeConfigurationsCount
&
&
rv
!
=
Success
&
&
foundEVPolicy
;
i
+
+
)
{
if
(
SHA1ModeMoreRestrictiveThanGivenMode
(
sha1ModeConfigurations
[
i
]
)
)
{
continue
;
}
if
(
pinningTelemetryInfo
)
{
pinningTelemetryInfo
-
>
Reset
(
)
;
}
NSSCertDBTrustDomain
trustDomain
(
trustSSL
evOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS
ValidityCheckingMode
:
:
CheckForEV
sha1ModeConfigurations
[
i
]
mNetscapeStepUpPolicy
mCRLiteMode
mCRLiteCTMergeDelaySeconds
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
pinningTelemetryInfo
hostname
)
;
rv
=
BuildCertChainForOneKeyUsage
(
trustDomain
certDER
time
KeyUsage
:
:
digitalSignature
KeyUsage
:
:
keyEncipherment
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_serverAuth
evPolicy
stapledOCSPResponse
ocspStaplingStatus
)
;
if
(
rv
=
=
Success
&
&
sha1ModeConfigurations
[
i
]
=
=
SHA1Mode
:
:
ImportedRoot
)
{
bool
isBuiltInRoot
=
false
;
rv
=
IsCertChainRootBuiltInRoot
(
builtChain
isBuiltInRoot
)
;
if
(
rv
!
=
Success
)
{
break
;
}
if
(
isBuiltInRoot
)
{
rv
=
Result
:
:
ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
;
}
}
if
(
rv
=
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
cert
is
EV
with
status
%
i
\
n
"
static_cast
<
int
>
(
sha1ModeResults
[
i
]
)
)
)
;
if
(
evStatus
)
{
*
evStatus
=
foundEVPolicy
?
EVStatus
:
:
EV
:
EVStatus
:
:
NotEV
;
}
if
(
sha1ModeResult
)
{
*
sha1ModeResult
=
sha1ModeResults
[
i
]
;
}
rv
=
VerifyCertificateTransparencyPolicy
(
trustDomain
builtChain
sctsFromTLSInput
time
ctInfo
)
;
if
(
rv
!
=
Success
)
{
break
;
}
}
}
if
(
rv
=
=
Success
)
{
break
;
}
if
(
flags
&
FLAG_MUST_BE_EV
)
{
rv
=
Result
:
:
ERROR_POLICY_VALIDATION_FAILED
;
break
;
}
unsigned
int
keySizeOptions
[
]
=
{
MIN_RSA_BITS
MIN_RSA_BITS_WEAK
}
;
KeySizeStatus
keySizeStatuses
[
]
=
{
KeySizeStatus
:
:
LargeMinimumSucceeded
KeySizeStatus
:
:
CompatibilityRisk
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
keySizeOptions
)
=
=
MOZ_ARRAY_LENGTH
(
keySizeStatuses
)
"
keySize
array
lengths
differ
"
)
;
size_t
keySizeOptionsCount
=
MOZ_ARRAY_LENGTH
(
keySizeStatuses
)
;
for
(
size_t
i
=
0
;
i
<
keySizeOptionsCount
&
&
rv
!
=
Success
;
i
+
+
)
{
for
(
size_t
j
=
0
;
j
<
sha1ModeConfigurationsCount
&
&
rv
!
=
Success
;
j
+
+
)
{
if
(
SHA1ModeMoreRestrictiveThanGivenMode
(
sha1ModeConfigurations
[
j
]
)
)
{
continue
;
}
if
(
pinningTelemetryInfo
)
{
pinningTelemetryInfo
-
>
Reset
(
)
;
}
NSSCertDBTrustDomain
trustDomain
(
trustSSL
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
keySizeOptions
[
i
]
ValidityCheckingMode
:
:
CheckingOff
sha1ModeConfigurations
[
j
]
mNetscapeStepUpPolicy
mCRLiteMode
mCRLiteCTMergeDelaySeconds
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
pinningTelemetryInfo
hostname
)
;
rv
=
BuildCertChainForOneKeyUsage
(
trustDomain
certDER
time
KeyUsage
:
:
digitalSignature
KeyUsage
:
:
keyEncipherment
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
ocspStaplingStatus
)
;
if
(
rv
!
=
Success
&
&
!
IsFatalError
(
rv
)
&
&
rv
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
&
&
trustDomain
.
GetIsErrorDueToDistrustedCAPolicy
(
)
)
{
rv
=
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
if
(
rv
=
=
Success
&
&
sha1ModeConfigurations
[
j
]
=
=
SHA1Mode
:
:
ImportedRoot
)
{
bool
isBuiltInRoot
=
false
;
rv
=
IsCertChainRootBuiltInRoot
(
builtChain
isBuiltInRoot
)
;
if
(
rv
!
=
Success
)
{
break
;
}
if
(
isBuiltInRoot
)
{
rv
=
Result
:
:
ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
;
}
}
if
(
rv
=
=
Success
)
{
if
(
keySizeStatus
)
{
*
keySizeStatus
=
keySizeStatuses
[
i
]
;
}
if
(
sha1ModeResult
)
{
*
sha1ModeResult
=
sha1ModeResults
[
j
]
;
}
rv
=
VerifyCertificateTransparencyPolicy
(
trustDomain
builtChain
sctsFromTLSInput
time
ctInfo
)
;
if
(
rv
!
=
Success
)
{
break
;
}
}
}
}
if
(
rv
=
=
Success
)
{
break
;
}
if
(
keySizeStatus
)
{
*
keySizeStatus
=
KeySizeStatus
:
:
AlreadyBad
;
}
if
(
sha1ModeResult
&
&
mSHA1Mode
=
=
SHA1Mode
:
:
ImportedRoot
)
{
*
sha1ModeResult
=
SHA1ModeResult
:
:
Failed
;
}
break
;
}
case
certificateUsageSSLCA
:
{
NSSCertDBTrustDomain
trustDomain
(
trustSSL
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
SHA1Mode
:
:
Allowed
mNetscapeStepUpPolicy
mCRLiteMode
mCRLiteCTMergeDelaySeconds
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeCA
KeyUsage
:
:
keyCertSign
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
break
;
}
case
certificateUsageEmailSigner
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
SHA1Mode
:
:
Allowed
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
mCRLiteCTMergeDelaySeconds
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
nonRepudiation
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
}
break
;
}
case
certificateUsageEmailRecipient
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
SHA1Mode
:
:
Allowed
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
mCRLiteCTMergeDelaySeconds
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
keyEncipherment
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
}
break
;
}
default
:
rv
=
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
Success
;
}
static
bool
CertIsSelfSigned
(
const
BackCert
&
backCert
void
*
pinarg
)
{
if
(
!
InputsAreEqual
(
backCert
.
GetIssuer
(
)
backCert
.
GetSubject
(
)
)
)
{
return
false
;
}
nsTArray
<
nsTArray
<
uint8_t
>
>
emptyCertList
;
mozilla
:
:
psm
:
:
CSTrustDomain
trustDomain
(
emptyCertList
)
;
Result
rv
=
VerifySignedData
(
trustDomain
backCert
.
GetSignedData
(
)
backCert
.
GetSubjectPublicKeyInfo
(
)
)
;
return
rv
=
=
Success
;
}
Result
CertVerifier
:
:
VerifySSLServerCert
(
const
nsTArray
<
uint8_t
>
&
peerCertBytes
Time
time
void
*
pinarg
const
nsACString
&
hostname
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
Flags
flags
const
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
extraCertificates
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLS
const
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
const
OriginAttributes
&
originAttributes
EVStatus
*
evStatus
OCSPStaplingStatus
*
ocspStaplingStatus
KeySizeStatus
*
keySizeStatus
SHA1ModeResult
*
sha1ModeResult
PinningTelemetryInfo
*
pinningTelemetryInfo
CertificateTransparencyInfo
*
ctInfo
bool
*
isBuiltCertChainRootBuiltInRoot
)
{
MOZ_ASSERT
(
!
hostname
.
IsEmpty
(
)
)
;
if
(
isBuiltCertChainRootBuiltInRoot
)
{
*
isBuiltCertChainRootBuiltInRoot
=
false
;
}
if
(
evStatus
)
{
*
evStatus
=
EVStatus
:
:
NotEV
;
}
if
(
hostname
.
IsEmpty
(
)
)
{
return
Result
:
:
ERROR_BAD_CERT_DOMAIN
;
}
Input
peerCertInput
;
Result
rv
=
peerCertInput
.
Init
(
peerCertBytes
.
Elements
(
)
peerCertBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
VerifyCert
(
peerCertBytes
certificateUsageSSLServer
time
pinarg
PromiseFlatCString
(
hostname
)
.
get
(
)
builtChain
flags
extraCertificates
stapledOCSPResponse
sctsFromTLS
originAttributes
evStatus
ocspStaplingStatus
keySizeStatus
sha1ModeResult
pinningTelemetryInfo
ctInfo
)
;
if
(
rv
!
=
Success
)
{
EndEntityOrCA
notUsedForPaths
=
EndEntityOrCA
:
:
MustBeEndEntity
;
BackCert
peerBackCert
(
peerCertInput
notUsedForPaths
nullptr
)
;
if
(
peerBackCert
.
Init
(
)
!
=
Success
)
{
return
rv
;
}
if
(
rv
=
=
Result
:
:
ERROR_UNKNOWN_ISSUER
&
&
CertIsSelfSigned
(
peerBackCert
pinarg
)
)
{
return
Result
:
:
ERROR_SELF_SIGNED_CERT
;
}
if
(
rv
=
=
Result
:
:
ERROR_UNKNOWN_ISSUER
)
{
nsCOMPtr
<
nsINSSComponent
>
component
(
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
)
;
if
(
!
component
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Input
issuerNameInput
=
peerBackCert
.
GetIssuer
(
)
;
SECItem
issuerNameItem
=
UnsafeMapInputToSECItem
(
issuerNameInput
)
;
UniquePORTString
issuerName
(
CERT_DerNameToAscii
(
&
issuerNameItem
)
)
;
if
(
!
issuerName
)
{
return
Result
:
:
ERROR_BAD_DER
;
}
nsresult
rv
=
component
-
>
IssuerMatchesMitmCanary
(
issuerName
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
Result
:
:
ERROR_MITM_DETECTED
;
}
}
return
rv
;
}
if
(
dcInfo
)
{
rv
=
IsDelegatedCredentialAcceptable
(
*
dcInfo
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
Input
stapledOCSPResponseInput
;
Input
*
responseInputPtr
=
nullptr
;
if
(
stapledOCSPResponse
)
{
rv
=
stapledOCSPResponseInput
.
Init
(
stapledOCSPResponse
-
>
Elements
(
)
stapledOCSPResponse
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
responseInputPtr
=
&
stapledOCSPResponseInput
;
}
if
(
!
(
flags
&
FLAG_TLS_IGNORE_STATUS_REQUEST
)
)
{
rv
=
CheckTLSFeaturesAreSatisfied
(
peerCertInput
responseInputPtr
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
Input
hostnameInput
;
rv
=
hostnameInput
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
hostname
.
BeginReading
(
)
)
hostname
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
bool
isBuiltInRoot
;
rv
=
IsCertChainRootBuiltInRoot
(
builtChain
isBuiltInRoot
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
isBuiltCertChainRootBuiltInRoot
)
{
*
isBuiltCertChainRootBuiltInRoot
=
isBuiltInRoot
;
}
BRNameMatchingPolicy
nameMatchingPolicy
(
isBuiltInRoot
?
mNameMatchingMode
:
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
)
;
rv
=
CheckCertHostname
(
peerCertInput
hostnameInput
nameMatchingPolicy
)
;
if
(
rv
!
=
Success
)
{
if
(
rv
=
=
Result
:
:
ERROR_BAD_DER
)
{
return
Result
:
:
ERROR_BAD_CERT_DOMAIN
;
}
return
rv
;
}
return
Success
;
}
}
}
