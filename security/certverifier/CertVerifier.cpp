#
include
"
CertVerifier
.
h
"
#
include
<
stdint
.
h
>
#
include
"
CTDiversityPolicy
.
h
"
#
include
"
CTKnownLogs
.
h
"
#
include
"
CTLogVerifier
.
h
"
#
include
"
ExtendedValidation
.
h
"
#
include
"
MultiLogCTVerifier
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
NSSErrorsService
.
h
"
#
include
"
cert
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsPromiseFlatString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
secmod
.
h
"
using
namespace
mozilla
:
:
ct
;
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
mozilla
:
:
LazyLogModule
gCertVerifierLog
(
"
certverifier
"
)
;
extern
mozilla
:
:
pkix
:
:
Result
GetCertLifetimeInFullMonths
(
PRTime
certNotBefore
PRTime
certNotAfter
size_t
&
months
)
{
if
(
certNotBefore
>
=
certNotAfter
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
notBefore
<
notAfter
"
)
;
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
PRExplodedTime
explodedNotBefore
;
PRExplodedTime
explodedNotAfter
;
PR_ExplodeTime
(
certNotBefore
PR_LocalTimeParameters
&
explodedNotBefore
)
;
PR_ExplodeTime
(
certNotAfter
PR_LocalTimeParameters
&
explodedNotAfter
)
;
PRInt32
signedMonths
=
(
explodedNotAfter
.
tm_year
-
explodedNotBefore
.
tm_year
)
*
12
+
(
explodedNotAfter
.
tm_month
-
explodedNotBefore
.
tm_month
)
;
if
(
explodedNotAfter
.
tm_mday
<
explodedNotBefore
.
tm_mday
)
{
-
-
signedMonths
;
}
if
(
signedMonths
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
explodedNotBefore
<
explodedNotAfter
"
)
;
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
months
=
static_cast
<
size_t
>
(
signedMonths
)
;
return
Success
;
}
namespace
mozilla
{
namespace
psm
{
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_LOCAL_ONLY
=
1
;
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_MUST_BE_EV
=
2
;
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
=
4
;
void
CertificateTransparencyInfo
:
:
Reset
(
)
{
enabled
=
false
;
verifyResult
.
Reset
(
)
;
policyCompliance
=
CTPolicyCompliance
:
:
Unknown
;
}
CertVerifier
:
:
CertVerifier
(
OcspDownloadConfig
odc
OcspStrictConfig
osc
mozilla
:
:
TimeDuration
ocspTimeoutSoft
mozilla
:
:
TimeDuration
ocspTimeoutHard
uint32_t
certShortLifetimeInDays
PinningMode
pinningMode
SHA1Mode
sha1Mode
BRNameMatchingPolicy
:
:
Mode
nameMatchingMode
NetscapeStepUpPolicy
netscapeStepUpPolicy
CertificateTransparencyMode
ctMode
DistrustedCAPolicy
distrustedCAPolicy
const
Vector
<
EnterpriseCert
>
&
thirdPartyCerts
)
:
mOCSPDownloadConfig
(
odc
)
mOCSPStrict
(
osc
=
=
ocspStrict
)
mOCSPTimeoutSoft
(
ocspTimeoutSoft
)
mOCSPTimeoutHard
(
ocspTimeoutHard
)
mCertShortLifetimeInDays
(
certShortLifetimeInDays
)
mPinningMode
(
pinningMode
)
mSHA1Mode
(
sha1Mode
)
mNameMatchingMode
(
nameMatchingMode
)
mNetscapeStepUpPolicy
(
netscapeStepUpPolicy
)
mCTMode
(
ctMode
)
mDistrustedCAPolicy
(
distrustedCAPolicy
)
{
LoadKnownCTLogs
(
)
;
for
(
const
auto
&
root
:
thirdPartyCerts
)
{
EnterpriseCert
rootCopy
;
if
(
NS_SUCCEEDED
(
rootCopy
.
Init
(
root
)
)
)
{
Unused
<
<
mThirdPartyCerts
.
append
(
std
:
:
move
(
rootCopy
)
)
;
}
}
for
(
const
auto
&
root
:
mThirdPartyCerts
)
{
Input
input
;
if
(
root
.
GetInput
(
input
)
=
=
Success
)
{
if
(
root
.
GetIsRoot
(
)
)
{
Unused
<
<
mThirdPartyRootInputs
.
append
(
input
)
;
}
else
{
Unused
<
<
mThirdPartyIntermediateInputs
.
append
(
input
)
;
}
}
}
}
CertVerifier
:
:
~
CertVerifier
(
)
{
}
Result
IsCertChainRootBuiltInRoot
(
const
UniqueCERTCertList
&
chain
bool
&
result
)
{
if
(
!
chain
|
|
CERT_LIST_EMPTY
(
chain
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
CERTCertListNode
*
rootNode
=
CERT_LIST_TAIL
(
chain
)
;
if
(
!
rootNode
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
CERTCertificate
*
root
=
rootNode
-
>
cert
;
if
(
!
root
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
return
IsCertBuiltInRoot
(
root
result
)
;
}
Result
IsCertBuiltInRoot
(
CERTCertificate
*
cert
bool
&
result
)
{
if
(
NS_FAILED
(
BlockUntilLoadableRootsLoaded
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
result
=
false
;
#
ifdef
DEBUG
nsCOMPtr
<
nsINSSComponent
>
component
(
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
)
;
if
(
!
component
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsresult
rv
=
component
-
>
IsCertTestBuiltInRoot
(
cert
&
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
result
)
{
return
Success
;
}
#
endif
AutoSECMODListReadLock
lock
;
for
(
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
for
(
int
i
=
0
;
i
<
list
-
>
module
-
>
slotCount
;
i
+
+
)
{
PK11SlotInfo
*
slot
=
list
-
>
module
-
>
slots
[
i
]
;
if
(
PK11_IsPresent
(
slot
)
&
&
PK11_HasRootCerts
(
slot
)
)
{
CK_OBJECT_HANDLE
handle
=
PK11_FindCertInSlot
(
slot
cert
nullptr
)
;
if
(
handle
!
=
CK_INVALID_HANDLE
&
&
PK11_HasAttributeSet
(
slot
handle
CKA_NSS_MOZILLA_CA_POLICY
false
)
)
{
result
=
true
;
break
;
}
}
}
}
return
Success
;
}
static
Result
BuildCertChainForOneKeyUsage
(
NSSCertDBTrustDomain
&
trustDomain
Input
certDER
Time
time
KeyUsage
ku1
KeyUsage
ku2
KeyUsage
ku3
KeyPurposeId
eku
const
CertPolicyId
&
requiredPolicy
const
Input
*
stapledOCSPResponse
CertVerifier
:
:
OCSPStaplingStatus
*
ocspStaplingStatus
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
Result
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku1
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku2
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku3
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
!
=
Success
)
{
rv
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
;
}
}
}
if
(
ocspStaplingStatus
)
{
*
ocspStaplingStatus
=
trustDomain
.
GetOCSPStaplingStatus
(
)
;
}
return
rv
;
}
void
CertVerifier
:
:
LoadKnownCTLogs
(
)
{
mCTVerifier
=
MakeUnique
<
MultiLogCTVerifier
>
(
)
;
for
(
const
CTLogInfo
&
log
:
kCTLogList
)
{
Input
publicKey
;
Result
rv
=
publicKey
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
log
.
key
)
log
.
keyLength
)
;
if
(
rv
!
=
Success
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
reading
a
log
key
for
a
known
CT
Log
"
)
;
continue
;
}
CTLogVerifier
logVerifier
;
const
CTLogOperatorInfo
&
logOperator
=
kCTLogOperatorList
[
log
.
operatorIndex
]
;
rv
=
logVerifier
.
Init
(
publicKey
logOperator
.
id
log
.
status
log
.
disqualificationTime
)
;
if
(
rv
!
=
Success
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
initializing
a
known
CT
Log
"
)
;
continue
;
}
mCTVerifier
-
>
AddLog
(
std
:
:
move
(
logVerifier
)
)
;
}
mCTDiversityPolicy
=
MakeUnique
<
CTDiversityPolicy
>
(
)
;
}
Result
CertVerifier
:
:
VerifyCertificateTransparencyPolicy
(
NSSCertDBTrustDomain
&
trustDomain
const
UniqueCERTCertList
&
builtChain
Input
sctsFromTLS
Time
time
CertificateTransparencyInfo
*
ctInfo
)
{
if
(
ctInfo
)
{
ctInfo
-
>
Reset
(
)
;
}
if
(
mCTMode
=
=
CertificateTransparencyMode
:
:
Disabled
)
{
return
Success
;
}
if
(
ctInfo
)
{
ctInfo
-
>
enabled
=
true
;
}
if
(
!
builtChain
|
|
CERT_LIST_EMPTY
(
builtChain
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Input
embeddedSCTs
=
trustDomain
.
GetSCTListFromCertificate
(
)
;
if
(
embeddedSCTs
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
embedded
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
embeddedSCTs
.
GetLength
(
)
)
)
)
;
}
Input
sctsFromOCSP
=
trustDomain
.
GetSCTListFromOCSPStapling
(
)
;
if
(
sctsFromOCSP
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
OCSP
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
sctsFromOCSP
.
GetLength
(
)
)
)
)
;
}
if
(
sctsFromTLS
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
TLS
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
sctsFromTLS
.
GetLength
(
)
)
)
)
;
}
CERTCertListNode
*
endEntityNode
=
CERT_LIST_HEAD
(
builtChain
)
;
if
(
!
endEntityNode
|
|
CERT_LIST_END
(
endEntityNode
builtChain
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
CERTCertListNode
*
issuerNode
=
CERT_LIST_NEXT
(
endEntityNode
)
;
if
(
!
issuerNode
|
|
CERT_LIST_END
(
issuerNode
builtChain
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
CERTCertificate
*
endEntity
=
endEntityNode
-
>
cert
;
CERTCertificate
*
issuer
=
issuerNode
-
>
cert
;
if
(
!
endEntity
|
|
!
issuer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
endEntity
-
>
subjectName
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Verifying
CT
Policy
compliance
of
subject
%
s
\
n
"
endEntity
-
>
subjectName
)
)
;
}
Input
endEntityDER
;
Result
rv
=
endEntityDER
.
Init
(
endEntity
-
>
derCert
.
data
endEntity
-
>
derCert
.
len
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Input
issuerPublicKeyDER
;
rv
=
issuerPublicKeyDER
.
Init
(
issuer
-
>
derPublicKey
.
data
issuer
-
>
derPublicKey
.
len
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
CTVerifyResult
result
;
rv
=
mCTVerifier
-
>
Verify
(
endEntityDER
issuerPublicKeyDER
embeddedSCTs
sctsFromOCSP
sctsFromTLS
time
result
)
;
if
(
rv
!
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SCT
verification
failed
with
fatal
error
%
"
PRId32
"
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
if
(
MOZ_LOG_TEST
(
gCertVerifierLog
LogLevel
:
:
Debug
)
)
{
size_t
validCount
=
0
;
size_t
unknownLogCount
=
0
;
size_t
disqualifiedLogCount
=
0
;
size_t
invalidSignatureCount
=
0
;
size_t
invalidTimestampCount
=
0
;
for
(
const
VerifiedSCT
&
verifiedSct
:
result
.
verifiedScts
)
{
switch
(
verifiedSct
.
status
)
{
case
VerifiedSCT
:
:
Status
:
:
Valid
:
validCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
ValidFromDisqualifiedLog
:
disqualifiedLogCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
UnknownLog
:
unknownLogCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
InvalidSignature
:
invalidSignatureCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
InvalidTimestamp
:
invalidTimestampCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
None
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
SCT
verification
status
"
)
;
}
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SCT
verification
result
:
"
"
valid
=
%
zu
unknownLog
=
%
zu
disqualifiedLog
=
%
zu
"
"
invalidSignature
=
%
zu
invalidTimestamp
=
%
zu
"
"
decodingErrors
=
%
zu
\
n
"
validCount
unknownLogCount
disqualifiedLogCount
invalidSignatureCount
invalidTimestampCount
result
.
decodingErrors
)
)
;
}
PRTime
notBefore
;
PRTime
notAfter
;
if
(
CERT_GetCertTimes
(
endEntity
&
notBefore
&
notAfter
)
!
=
SECSuccess
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
size_t
lifetimeInMonths
;
rv
=
GetCertLifetimeInFullMonths
(
notBefore
notAfter
lifetimeInMonths
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
CTLogOperatorList
allOperators
;
GetCTLogOperatorsFromVerifiedSCTList
(
result
.
verifiedScts
allOperators
)
;
CTLogOperatorList
dependentOperators
;
rv
=
mCTDiversityPolicy
-
>
GetDependentOperators
(
builtChain
.
get
(
)
allOperators
dependentOperators
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
CTPolicyEnforcer
ctPolicyEnforcer
;
CTPolicyCompliance
ctPolicyCompliance
;
ctPolicyEnforcer
.
CheckCompliance
(
result
.
verifiedScts
lifetimeInMonths
dependentOperators
ctPolicyCompliance
)
;
if
(
ctInfo
)
{
ctInfo
-
>
verifyResult
=
std
:
:
move
(
result
)
;
ctInfo
-
>
policyCompliance
=
ctPolicyCompliance
;
}
return
Success
;
}
bool
CertVerifier
:
:
SHA1ModeMoreRestrictiveThanGivenMode
(
SHA1Mode
mode
)
{
switch
(
mSHA1Mode
)
{
case
SHA1Mode
:
:
Forbidden
:
return
mode
!
=
SHA1Mode
:
:
Forbidden
;
case
SHA1Mode
:
:
ImportedRoot
:
return
mode
!
=
SHA1Mode
:
:
Forbidden
&
&
mode
!
=
SHA1Mode
:
:
ImportedRoot
;
case
SHA1Mode
:
:
ImportedRootOrBefore2016
:
return
mode
=
=
SHA1Mode
:
:
Allowed
;
case
SHA1Mode
:
:
Allowed
:
return
false
;
case
SHA1Mode
:
:
UsedToBeBefore2016ButNowIsForbidden
:
default
:
MOZ_ASSERT
(
false
"
unexpected
SHA1Mode
type
"
)
;
return
true
;
}
}
static
const
unsigned
int
MIN_RSA_BITS
=
2048
;
static
const
unsigned
int
MIN_RSA_BITS_WEAK
=
1024
;
Result
CertVerifier
:
:
VerifyCert
(
CERTCertificate
*
cert
SECCertificateUsage
usage
Time
time
void
*
pinArg
const
char
*
hostname
UniqueCERTCertList
&
builtChain
const
Flags
flags
const
SECItem
*
stapledOCSPResponseSECItem
const
SECItem
*
sctsFromTLSSECItem
const
OriginAttributes
&
originAttributes
SECOidTag
*
evOidPolicy
OCSPStaplingStatus
*
ocspStaplingStatus
KeySizeStatus
*
keySizeStatus
SHA1ModeResult
*
sha1ModeResult
PinningTelemetryInfo
*
pinningTelemetryInfo
CertificateTransparencyInfo
*
ctInfo
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Top
of
VerifyCert
\
n
"
)
)
;
MOZ_ASSERT
(
cert
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
(
flags
&
FLAG_MUST_BE_EV
)
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
keySizeStatus
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
sha1ModeResult
)
;
if
(
NS_FAILED
(
BlockUntilLoadableRootsLoaded
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
NS_FAILED
(
CheckForSmartCardChanges
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
evOidPolicy
)
{
*
evOidPolicy
=
SEC_OID_UNKNOWN
;
}
if
(
ocspStaplingStatus
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
ocspStaplingStatus
=
OCSP_STAPLING_NEVER_CHECKED
;
}
if
(
keySizeStatus
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
keySizeStatus
=
KeySizeStatus
:
:
NeverChecked
;
}
if
(
sha1ModeResult
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
sha1ModeResult
=
SHA1ModeResult
:
:
NeverChecked
;
}
if
(
!
cert
|
|
(
usage
!
=
certificateUsageSSLServer
&
&
(
flags
&
FLAG_MUST_BE_EV
)
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Input
certDER
;
Result
rv
=
certDER
.
Init
(
cert
-
>
derCert
.
data
cert
-
>
derCert
.
len
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
NSSCertDBTrustDomain
:
:
OCSPFetching
defaultOCSPFetching
=
(
mOCSPDownloadConfig
=
=
ocspOff
)
|
|
(
mOCSPDownloadConfig
=
=
ocspEVOnly
)
|
|
(
flags
&
FLAG_LOCAL_ONLY
)
?
NSSCertDBTrustDomain
:
:
NeverFetchOCSP
:
!
mOCSPStrict
?
NSSCertDBTrustDomain
:
:
FetchOCSPForDVSoftFail
:
NSSCertDBTrustDomain
:
:
FetchOCSPForDVHardFail
;
Input
stapledOCSPResponseInput
;
const
Input
*
stapledOCSPResponse
=
nullptr
;
if
(
stapledOCSPResponseSECItem
)
{
rv
=
stapledOCSPResponseInput
.
Init
(
stapledOCSPResponseSECItem
-
>
data
stapledOCSPResponseSECItem
-
>
len
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
stapledOCSPResponse
=
&
stapledOCSPResponseInput
;
}
Input
sctsFromTLSInput
;
if
(
sctsFromTLSSECItem
)
{
rv
=
sctsFromTLSInput
.
Init
(
sctsFromTLSSECItem
-
>
data
sctsFromTLSSECItem
-
>
len
)
;
MOZ_ASSERT
(
rv
=
=
Success
)
;
}
switch
(
usage
)
{
case
certificateUsageSSLClient
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
pinningDisabled
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
SHA1Mode
:
:
Allowed
NetscapeStepUpPolicy
:
:
NeverMatch
mDistrustedCAPolicy
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_clientAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
break
;
}
case
certificateUsageSSLServer
:
{
SHA1Mode
sha1ModeConfigurations
[
]
=
{
SHA1Mode
:
:
Forbidden
SHA1Mode
:
:
ImportedRoot
SHA1Mode
:
:
ImportedRootOrBefore2016
SHA1Mode
:
:
Allowed
}
;
SHA1ModeResult
sha1ModeResults
[
]
=
{
SHA1ModeResult
:
:
SucceededWithoutSHA1
SHA1ModeResult
:
:
SucceededWithImportedRoot
SHA1ModeResult
:
:
SucceededWithImportedRootOrSHA1Before2016
SHA1ModeResult
:
:
SucceededWithSHA1
}
;
size_t
sha1ModeConfigurationsCount
=
MOZ_ARRAY_LENGTH
(
sha1ModeConfigurations
)
;
static_assert
(
MOZ_ARRAY_LENGTH
(
sha1ModeConfigurations
)
=
=
MOZ_ARRAY_LENGTH
(
sha1ModeResults
)
"
digestAlgorithm
array
lengths
differ
"
)
;
rv
=
Result
:
:
ERROR_UNKNOWN_ERROR
;
NSSCertDBTrustDomain
:
:
OCSPFetching
evOCSPFetching
=
(
mOCSPDownloadConfig
=
=
ocspOff
)
|
|
(
flags
&
FLAG_LOCAL_ONLY
)
?
NSSCertDBTrustDomain
:
:
LocalOnlyOCSPForEV
:
NSSCertDBTrustDomain
:
:
FetchOCSPForEV
;
CertPolicyId
evPolicy
;
SECOidTag
evPolicyOidTag
;
bool
foundEVPolicy
=
GetFirstEVPolicy
(
*
cert
evPolicy
evPolicyOidTag
)
;
for
(
size_t
i
=
0
;
i
<
sha1ModeConfigurationsCount
&
&
rv
!
=
Success
&
&
foundEVPolicy
;
i
+
+
)
{
if
(
SHA1ModeMoreRestrictiveThanGivenMode
(
sha1ModeConfigurations
[
i
]
)
)
{
continue
;
}
if
(
pinningTelemetryInfo
)
{
pinningTelemetryInfo
-
>
Reset
(
)
;
}
NSSCertDBTrustDomain
trustDomain
(
trustSSL
evOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
mPinningMode
MIN_RSA_BITS
ValidityCheckingMode
:
:
CheckForEV
sha1ModeConfigurations
[
i
]
mNetscapeStepUpPolicy
mDistrustedCAPolicy
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
builtChain
pinningTelemetryInfo
hostname
)
;
rv
=
BuildCertChainForOneKeyUsage
(
trustDomain
certDER
time
KeyUsage
:
:
digitalSignature
KeyUsage
:
:
keyEncipherment
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_serverAuth
evPolicy
stapledOCSPResponse
ocspStaplingStatus
)
;
if
(
rv
=
=
Success
&
&
sha1ModeConfigurations
[
i
]
=
=
SHA1Mode
:
:
ImportedRoot
)
{
bool
isBuiltInRoot
=
false
;
rv
=
IsCertChainRootBuiltInRoot
(
builtChain
isBuiltInRoot
)
;
if
(
rv
!
=
Success
)
{
break
;
}
if
(
isBuiltInRoot
)
{
rv
=
Result
:
:
ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
;
}
}
if
(
rv
=
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
cert
is
EV
with
status
%
i
\
n
"
static_cast
<
int
>
(
sha1ModeResults
[
i
]
)
)
)
;
if
(
evOidPolicy
)
{
*
evOidPolicy
=
evPolicyOidTag
;
}
if
(
sha1ModeResult
)
{
*
sha1ModeResult
=
sha1ModeResults
[
i
]
;
}
rv
=
VerifyCertificateTransparencyPolicy
(
trustDomain
builtChain
sctsFromTLSInput
time
ctInfo
)
;
if
(
rv
!
=
Success
)
{
break
;
}
}
}
if
(
rv
=
=
Success
)
{
break
;
}
if
(
flags
&
FLAG_MUST_BE_EV
)
{
rv
=
Result
:
:
ERROR_POLICY_VALIDATION_FAILED
;
break
;
}
unsigned
int
keySizeOptions
[
]
=
{
MIN_RSA_BITS
MIN_RSA_BITS_WEAK
}
;
KeySizeStatus
keySizeStatuses
[
]
=
{
KeySizeStatus
:
:
LargeMinimumSucceeded
KeySizeStatus
:
:
CompatibilityRisk
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
keySizeOptions
)
=
=
MOZ_ARRAY_LENGTH
(
keySizeStatuses
)
"
keySize
array
lengths
differ
"
)
;
size_t
keySizeOptionsCount
=
MOZ_ARRAY_LENGTH
(
keySizeStatuses
)
;
for
(
size_t
i
=
0
;
i
<
keySizeOptionsCount
&
&
rv
!
=
Success
;
i
+
+
)
{
for
(
size_t
j
=
0
;
j
<
sha1ModeConfigurationsCount
&
&
rv
!
=
Success
;
j
+
+
)
{
if
(
SHA1ModeMoreRestrictiveThanGivenMode
(
sha1ModeConfigurations
[
j
]
)
)
{
continue
;
}
if
(
pinningTelemetryInfo
)
{
pinningTelemetryInfo
-
>
Reset
(
)
;
}
NSSCertDBTrustDomain
trustDomain
(
trustSSL
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
mPinningMode
keySizeOptions
[
i
]
ValidityCheckingMode
:
:
CheckingOff
sha1ModeConfigurations
[
j
]
mNetscapeStepUpPolicy
mDistrustedCAPolicy
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
builtChain
pinningTelemetryInfo
hostname
)
;
rv
=
BuildCertChainForOneKeyUsage
(
trustDomain
certDER
time
KeyUsage
:
:
digitalSignature
KeyUsage
:
:
keyEncipherment
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
ocspStaplingStatus
)
;
if
(
rv
!
=
Success
&
&
!
IsFatalError
(
rv
)
&
&
rv
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
&
&
trustDomain
.
GetIsErrorDueToDistrustedCAPolicy
(
)
)
{
rv
=
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
if
(
rv
=
=
Success
&
&
sha1ModeConfigurations
[
j
]
=
=
SHA1Mode
:
:
ImportedRoot
)
{
bool
isBuiltInRoot
=
false
;
rv
=
IsCertChainRootBuiltInRoot
(
builtChain
isBuiltInRoot
)
;
if
(
rv
!
=
Success
)
{
break
;
}
if
(
isBuiltInRoot
)
{
rv
=
Result
:
:
ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
;
}
}
if
(
rv
=
=
Success
)
{
if
(
keySizeStatus
)
{
*
keySizeStatus
=
keySizeStatuses
[
i
]
;
}
if
(
sha1ModeResult
)
{
*
sha1ModeResult
=
sha1ModeResults
[
j
]
;
}
rv
=
VerifyCertificateTransparencyPolicy
(
trustDomain
builtChain
sctsFromTLSInput
time
ctInfo
)
;
if
(
rv
!
=
Success
)
{
break
;
}
}
}
}
if
(
rv
=
=
Success
)
{
break
;
}
if
(
keySizeStatus
)
{
*
keySizeStatus
=
KeySizeStatus
:
:
AlreadyBad
;
}
if
(
sha1ModeResult
&
&
mSHA1Mode
=
=
SHA1Mode
:
:
ImportedRoot
)
{
*
sha1ModeResult
=
SHA1ModeResult
:
:
Failed
;
}
break
;
}
case
certificateUsageSSLCA
:
{
NSSCertDBTrustDomain
trustDomain
(
trustSSL
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
pinningDisabled
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
SHA1Mode
:
:
Allowed
mNetscapeStepUpPolicy
mDistrustedCAPolicy
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeCA
KeyUsage
:
:
keyCertSign
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
break
;
}
case
certificateUsageEmailSigner
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
pinningDisabled
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
SHA1Mode
:
:
Allowed
NetscapeStepUpPolicy
:
:
NeverMatch
mDistrustedCAPolicy
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
nonRepudiation
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
}
break
;
}
case
certificateUsageEmailRecipient
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
pinningDisabled
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
SHA1Mode
:
:
Allowed
NetscapeStepUpPolicy
:
:
NeverMatch
mDistrustedCAPolicy
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
keyEncipherment
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
}
break
;
}
default
:
rv
=
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
Success
;
}
static
bool
CertIsSelfSigned
(
const
UniqueCERTCertificate
&
cert
void
*
pinarg
)
{
if
(
!
SECITEM_ItemsAreEqual
(
&
cert
-
>
derIssuer
&
cert
-
>
derSubject
)
)
{
return
false
;
}
SECStatus
rv
=
CERT_VerifySignedDataWithPublicKeyInfo
(
const_cast
<
CERTSignedData
*
>
(
&
cert
-
>
signatureWrap
)
const_cast
<
CERTSubjectPublicKeyInfo
*
>
(
&
cert
-
>
subjectPublicKeyInfo
)
pinarg
)
;
if
(
rv
!
=
SECSuccess
)
{
return
false
;
}
return
true
;
}
Result
CertVerifier
:
:
VerifySSLServerCert
(
const
UniqueCERTCertificate
&
peerCert
const
SECItem
*
stapledOCSPResponse
const
SECItem
*
sctsFromTLS
Time
time
void
*
pinarg
const
nsACString
&
hostname
UniqueCERTCertList
&
builtChain
bool
saveIntermediatesInPermanentDatabase
Flags
flags
const
OriginAttributes
&
originAttributes
SECOidTag
*
evOidPolicy
OCSPStaplingStatus
*
ocspStaplingStatus
KeySizeStatus
*
keySizeStatus
SHA1ModeResult
*
sha1ModeResult
PinningTelemetryInfo
*
pinningTelemetryInfo
CertificateTransparencyInfo
*
ctInfo
)
{
MOZ_ASSERT
(
peerCert
)
;
MOZ_ASSERT
(
!
hostname
.
IsEmpty
(
)
)
;
if
(
evOidPolicy
)
{
*
evOidPolicy
=
SEC_OID_UNKNOWN
;
}
if
(
hostname
.
IsEmpty
(
)
)
{
return
Result
:
:
ERROR_BAD_CERT_DOMAIN
;
}
Result
rv
=
VerifyCert
(
peerCert
.
get
(
)
certificateUsageSSLServer
time
pinarg
PromiseFlatCString
(
hostname
)
.
get
(
)
builtChain
flags
stapledOCSPResponse
sctsFromTLS
originAttributes
evOidPolicy
ocspStaplingStatus
keySizeStatus
sha1ModeResult
pinningTelemetryInfo
ctInfo
)
;
if
(
rv
!
=
Success
)
{
if
(
rv
=
=
Result
:
:
ERROR_UNKNOWN_ISSUER
&
&
CertIsSelfSigned
(
peerCert
pinarg
)
)
{
return
Result
:
:
ERROR_SELF_SIGNED_CERT
;
}
if
(
rv
=
=
Result
:
:
ERROR_UNKNOWN_ISSUER
)
{
nsCOMPtr
<
nsINSSComponent
>
component
(
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
)
;
if
(
!
component
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsresult
rv
=
component
-
>
IssuerMatchesMitmCanary
(
peerCert
-
>
issuerName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
Result
:
:
ERROR_MITM_DETECTED
;
}
}
return
rv
;
}
Input
peerCertInput
;
rv
=
peerCertInput
.
Init
(
peerCert
-
>
derCert
.
data
peerCert
-
>
derCert
.
len
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Input
stapledOCSPResponseInput
;
Input
*
responseInputPtr
=
nullptr
;
if
(
stapledOCSPResponse
)
{
rv
=
stapledOCSPResponseInput
.
Init
(
stapledOCSPResponse
-
>
data
stapledOCSPResponse
-
>
len
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
responseInputPtr
=
&
stapledOCSPResponseInput
;
}
if
(
!
(
flags
&
FLAG_TLS_IGNORE_STATUS_REQUEST
)
)
{
rv
=
CheckTLSFeaturesAreSatisfied
(
peerCertInput
responseInputPtr
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
Input
hostnameInput
;
rv
=
hostnameInput
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
hostname
.
BeginReading
(
)
)
hostname
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
bool
isBuiltInRoot
;
rv
=
IsCertChainRootBuiltInRoot
(
builtChain
isBuiltInRoot
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
BRNameMatchingPolicy
nameMatchingPolicy
(
isBuiltInRoot
?
mNameMatchingMode
:
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
)
;
rv
=
CheckCertHostname
(
peerCertInput
hostnameInput
nameMatchingPolicy
)
;
if
(
rv
!
=
Success
)
{
if
(
rv
=
=
Result
:
:
ERROR_BAD_DER
)
{
return
Result
:
:
ERROR_BAD_CERT_DOMAIN
;
}
return
rv
;
}
if
(
saveIntermediatesInPermanentDatabase
)
{
SaveIntermediateCerts
(
builtChain
)
;
}
return
Success
;
}
}
}
