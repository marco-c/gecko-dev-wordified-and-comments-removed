#
include
"
CertVerifier
.
h
"
#
include
<
stdint
.
h
>
#
include
"
AppTrustDomain
.
h
"
#
include
"
CTDiversityPolicy
.
h
"
#
include
"
CTKnownLogs
.
h
"
#
include
"
CTLogVerifier
.
h
"
#
include
"
ExtendedValidation
.
h
"
#
include
"
MultiLogCTVerifier
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
NSSErrorsService
.
h
"
#
include
"
cert
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
nsPromiseFlatString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixcheck
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
secmod
.
h
"
#
include
"
nsNetCID
.
h
"
using
namespace
mozilla
:
:
ct
;
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
mozilla
:
:
LazyLogModule
gCertVerifierLog
(
"
certverifier
"
)
;
extern
mozilla
:
:
pkix
:
:
Result
GetCertLifetimeInFullMonths
(
Time
certNotBefore
Time
certNotAfter
size_t
&
months
)
{
if
(
certNotBefore
>
=
certNotAfter
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
notBefore
<
notAfter
"
)
;
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
uint64_t
notBeforeSeconds
;
Result
rv
=
SecondsSinceEpochFromTime
(
certNotBefore
&
notBeforeSeconds
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
uint64_t
notAfterSeconds
;
rv
=
SecondsSinceEpochFromTime
(
certNotAfter
&
notAfterSeconds
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
PRTime
notBeforePR
=
static_cast
<
PRTime
>
(
notBeforeSeconds
)
*
1000000
;
PRTime
notAfterPR
=
static_cast
<
PRTime
>
(
notAfterSeconds
)
*
1000000
;
PRExplodedTime
explodedNotBefore
;
PRExplodedTime
explodedNotAfter
;
PR_ExplodeTime
(
notBeforePR
PR_LocalTimeParameters
&
explodedNotBefore
)
;
PR_ExplodeTime
(
notAfterPR
PR_LocalTimeParameters
&
explodedNotAfter
)
;
PRInt32
signedMonths
=
(
explodedNotAfter
.
tm_year
-
explodedNotBefore
.
tm_year
)
*
12
+
(
explodedNotAfter
.
tm_month
-
explodedNotBefore
.
tm_month
)
;
if
(
explodedNotAfter
.
tm_mday
<
explodedNotBefore
.
tm_mday
)
{
-
-
signedMonths
;
}
if
(
signedMonths
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
explodedNotBefore
<
explodedNotAfter
"
)
;
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
months
=
static_cast
<
size_t
>
(
signedMonths
)
;
return
Success
;
}
namespace
mozilla
{
namespace
psm
{
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_LOCAL_ONLY
=
1
;
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_MUST_BE_EV
=
2
;
const
CertVerifier
:
:
Flags
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
=
4
;
static
const
unsigned
int
MIN_RSA_BITS
=
2048
;
static
const
unsigned
int
MIN_RSA_BITS_WEAK
=
1024
;
void
CertificateTransparencyInfo
:
:
Reset
(
)
{
enabled
=
false
;
verifyResult
.
Reset
(
)
;
policyCompliance
=
CTPolicyCompliance
:
:
Unknown
;
}
CertVerifier
:
:
CertVerifier
(
OcspDownloadConfig
odc
OcspStrictConfig
osc
mozilla
:
:
TimeDuration
ocspTimeoutSoft
mozilla
:
:
TimeDuration
ocspTimeoutHard
uint32_t
certShortLifetimeInDays
NetscapeStepUpPolicy
netscapeStepUpPolicy
CertificateTransparencyMode
ctMode
CRLiteMode
crliteMode
const
Vector
<
EnterpriseCert
>
&
thirdPartyCerts
)
:
mOCSPDownloadConfig
(
odc
)
mOCSPStrict
(
osc
=
=
ocspStrict
)
mOCSPTimeoutSoft
(
ocspTimeoutSoft
)
mOCSPTimeoutHard
(
ocspTimeoutHard
)
mCertShortLifetimeInDays
(
certShortLifetimeInDays
)
mNetscapeStepUpPolicy
(
netscapeStepUpPolicy
)
mCTMode
(
ctMode
)
mCRLiteMode
(
crliteMode
)
{
LoadKnownCTLogs
(
)
;
for
(
const
auto
&
root
:
thirdPartyCerts
)
{
EnterpriseCert
rootCopy
;
if
(
NS_SUCCEEDED
(
rootCopy
.
Init
(
root
)
)
)
{
Unused
<
<
mThirdPartyCerts
.
append
(
std
:
:
move
(
rootCopy
)
)
;
}
}
for
(
const
auto
&
root
:
mThirdPartyCerts
)
{
Input
input
;
if
(
root
.
GetInput
(
input
)
=
=
Success
)
{
if
(
root
.
GetIsRoot
(
)
)
{
Unused
<
<
mThirdPartyRootInputs
.
append
(
input
)
;
}
else
{
Unused
<
<
mThirdPartyIntermediateInputs
.
append
(
input
)
;
}
}
}
}
CertVerifier
:
:
~
CertVerifier
(
)
=
default
;
Result
IsDelegatedCredentialAcceptable
(
const
DelegatedCredentialInfo
&
dcInfo
)
{
bool
isEcdsa
=
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp256r1_sha256
|
|
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp384r1_sha384
|
|
dcInfo
.
scheme
=
=
ssl_sig_ecdsa_secp521r1_sha512
;
if
(
!
isEcdsa
)
{
return
Result
:
:
ERROR_INVALID_KEY
;
}
return
Result
:
:
Success
;
}
Result
IsCertBuiltInRoot
(
Input
certInput
bool
&
result
)
{
result
=
false
;
if
(
NS_FAILED
(
BlockUntilLoadableCertsLoaded
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
#
ifdef
DEBUG
nsCOMPtr
<
nsINSSComponent
>
component
(
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
)
;
if
(
!
component
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
nsTArray
<
uint8_t
>
certBytes
;
certBytes
.
AppendElements
(
certInput
.
UnsafeGetData
(
)
certInput
.
GetLength
(
)
)
;
if
(
NS_FAILED
(
component
-
>
IsCertTestBuiltInRoot
(
certBytes
&
result
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
result
)
{
return
Success
;
}
#
endif
SECItem
certItem
(
UnsafeMapInputToSECItem
(
certInput
)
)
;
AutoSECMODListReadLock
lock
;
for
(
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
for
(
int
i
=
0
;
i
<
list
-
>
module
-
>
slotCount
;
i
+
+
)
{
PK11SlotInfo
*
slot
=
list
-
>
module
-
>
slots
[
i
]
;
if
(
!
PK11_IsPresent
(
slot
)
|
|
!
PK11_HasRootCerts
(
slot
)
)
{
continue
;
}
CK_OBJECT_HANDLE
handle
=
PK11_FindEncodedCertInSlot
(
slot
&
certItem
nullptr
)
;
if
(
handle
=
=
CK_INVALID_HANDLE
)
{
continue
;
}
if
(
PK11_HasAttributeSet
(
slot
handle
CKA_NSS_MOZILLA_CA_POLICY
false
)
)
{
result
=
true
;
break
;
}
}
}
return
Success
;
}
static
Result
BuildCertChainForOneKeyUsage
(
NSSCertDBTrustDomain
&
trustDomain
Input
certDER
Time
time
KeyUsage
ku1
KeyUsage
ku2
KeyUsage
ku3
KeyPurposeId
eku
const
CertPolicyId
&
requiredPolicy
const
Input
*
stapledOCSPResponse
CertVerifier
:
:
OCSPStaplingStatus
*
ocspStaplingStatus
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
Result
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku1
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku2
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
trustDomain
.
ResetAccumulatedState
(
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
ku3
eku
requiredPolicy
stapledOCSPResponse
)
;
if
(
rv
!
=
Success
)
{
rv
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
;
}
}
}
if
(
ocspStaplingStatus
)
{
*
ocspStaplingStatus
=
trustDomain
.
GetOCSPStaplingStatus
(
)
;
}
return
rv
;
}
void
CertVerifier
:
:
LoadKnownCTLogs
(
)
{
if
(
mCTMode
=
=
CertificateTransparencyMode
:
:
Disabled
)
{
return
;
}
mCTVerifier
=
MakeUnique
<
MultiLogCTVerifier
>
(
)
;
for
(
const
CTLogInfo
&
log
:
kCTLogList
)
{
Input
publicKey
;
Result
rv
=
publicKey
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
log
.
key
)
log
.
keyLength
)
;
if
(
rv
!
=
Success
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
reading
a
log
key
for
a
known
CT
Log
"
)
;
continue
;
}
CTLogVerifier
logVerifier
;
const
CTLogOperatorInfo
&
logOperator
=
kCTLogOperatorList
[
log
.
operatorIndex
]
;
rv
=
logVerifier
.
Init
(
publicKey
logOperator
.
id
log
.
status
log
.
disqualificationTime
)
;
if
(
rv
!
=
Success
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
initializing
a
known
CT
Log
"
)
;
continue
;
}
mCTVerifier
-
>
AddLog
(
std
:
:
move
(
logVerifier
)
)
;
}
mCTDiversityPolicy
=
MakeUnique
<
CTDiversityPolicy
>
(
)
;
}
Result
CertVerifier
:
:
VerifyCertificateTransparencyPolicy
(
NSSCertDBTrustDomain
&
trustDomain
const
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
Input
sctsFromTLS
Time
time
CertificateTransparencyInfo
*
ctInfo
)
{
if
(
ctInfo
)
{
ctInfo
-
>
Reset
(
)
;
}
if
(
mCTMode
=
=
CertificateTransparencyMode
:
:
Disabled
)
{
return
Success
;
}
if
(
ctInfo
)
{
ctInfo
-
>
enabled
=
true
;
}
if
(
builtChain
.
IsEmpty
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Input
embeddedSCTs
=
trustDomain
.
GetSCTListFromCertificate
(
)
;
if
(
embeddedSCTs
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
embedded
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
embeddedSCTs
.
GetLength
(
)
)
)
)
;
}
Input
sctsFromOCSP
=
trustDomain
.
GetSCTListFromOCSPStapling
(
)
;
if
(
sctsFromOCSP
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
OCSP
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
sctsFromOCSP
.
GetLength
(
)
)
)
)
;
}
if
(
sctsFromTLS
.
GetLength
(
)
>
0
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Got
TLS
SCT
data
of
length
%
zu
\
n
"
static_cast
<
size_t
>
(
sctsFromTLS
.
GetLength
(
)
)
)
)
;
}
if
(
builtChain
.
Length
(
)
=
=
1
)
{
if
(
ctInfo
)
{
CTVerifyResult
emptyResult
;
ctInfo
-
>
verifyResult
=
std
:
:
move
(
emptyResult
)
;
ctInfo
-
>
policyCompliance
=
CTPolicyCompliance
:
:
NotEnoughScts
;
}
return
Success
;
}
const
nsTArray
<
uint8_t
>
&
endEntityBytes
=
builtChain
.
ElementAt
(
0
)
;
Input
endEntityInput
;
Result
rv
=
endEntityInput
.
Init
(
endEntityBytes
.
Elements
(
)
endEntityBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
const
nsTArray
<
uint8_t
>
&
issuerBytes
=
builtChain
.
ElementAt
(
1
)
;
Input
issuerInput
;
rv
=
issuerInput
.
Init
(
issuerBytes
.
Elements
(
)
issuerBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
BackCert
issuerBackCert
(
issuerInput
EndEntityOrCA
:
:
MustBeCA
nullptr
)
;
rv
=
issuerBackCert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Input
issuerPublicKeyInput
=
issuerBackCert
.
GetSubjectPublicKeyInfo
(
)
;
CTVerifyResult
result
;
rv
=
mCTVerifier
-
>
Verify
(
endEntityInput
issuerPublicKeyInput
embeddedSCTs
sctsFromOCSP
sctsFromTLS
time
result
)
;
if
(
rv
!
=
Success
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SCT
verification
failed
with
fatal
error
%
"
PRId32
"
\
n
"
static_cast
<
uint32_t
>
(
rv
)
)
)
;
return
rv
;
}
if
(
MOZ_LOG_TEST
(
gCertVerifierLog
LogLevel
:
:
Debug
)
)
{
size_t
validCount
=
0
;
size_t
unknownLogCount
=
0
;
size_t
disqualifiedLogCount
=
0
;
size_t
invalidSignatureCount
=
0
;
size_t
invalidTimestampCount
=
0
;
for
(
const
VerifiedSCT
&
verifiedSct
:
result
.
verifiedScts
)
{
switch
(
verifiedSct
.
status
)
{
case
VerifiedSCT
:
:
Status
:
:
Valid
:
validCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
ValidFromDisqualifiedLog
:
disqualifiedLogCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
UnknownLog
:
unknownLogCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
InvalidSignature
:
invalidSignatureCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
InvalidTimestamp
:
invalidTimestampCount
+
+
;
break
;
case
VerifiedSCT
:
:
Status
:
:
None
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
SCT
verification
status
"
)
;
}
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
SCT
verification
result
:
"
"
valid
=
%
zu
unknownLog
=
%
zu
disqualifiedLog
=
%
zu
"
"
invalidSignature
=
%
zu
invalidTimestamp
=
%
zu
"
"
decodingErrors
=
%
zu
\
n
"
validCount
unknownLogCount
disqualifiedLogCount
invalidSignatureCount
invalidTimestampCount
result
.
decodingErrors
)
)
;
}
BackCert
endEntityBackCert
(
endEntityInput
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
;
rv
=
endEntityBackCert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Time
notBefore
(
Time
:
:
uninitialized
)
;
Time
notAfter
(
Time
:
:
uninitialized
)
;
rv
=
ParseValidity
(
endEntityBackCert
.
GetValidity
(
)
&
notBefore
&
notAfter
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
size_t
lifetimeInMonths
;
rv
=
GetCertLifetimeInFullMonths
(
notBefore
notAfter
lifetimeInMonths
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
CTLogOperatorList
allOperators
;
GetCTLogOperatorsFromVerifiedSCTList
(
result
.
verifiedScts
allOperators
)
;
CTLogOperatorList
dependentOperators
;
rv
=
mCTDiversityPolicy
-
>
GetDependentOperators
(
builtChain
allOperators
dependentOperators
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
CTPolicyEnforcer
ctPolicyEnforcer
;
CTPolicyCompliance
ctPolicyCompliance
;
ctPolicyEnforcer
.
CheckCompliance
(
result
.
verifiedScts
lifetimeInMonths
dependentOperators
ctPolicyCompliance
)
;
if
(
ctInfo
)
{
ctInfo
-
>
verifyResult
=
std
:
:
move
(
result
)
;
ctInfo
-
>
policyCompliance
=
ctPolicyCompliance
;
}
return
Success
;
}
Result
CertVerifier
:
:
VerifyCert
(
const
nsTArray
<
uint8_t
>
&
certBytes
SECCertificateUsage
usage
Time
time
void
*
pinArg
const
char
*
hostname
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
const
Flags
flags
const
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
extraCertificates
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponseArg
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLS
const
OriginAttributes
&
originAttributes
EVStatus
*
evStatus
OCSPStaplingStatus
*
ocspStaplingStatus
KeySizeStatus
*
keySizeStatus
PinningTelemetryInfo
*
pinningTelemetryInfo
CertificateTransparencyInfo
*
ctInfo
bool
*
isBuiltChainRootBuiltInRoot
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
Top
of
VerifyCert
\
n
"
)
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
(
flags
&
FLAG_MUST_BE_EV
)
)
;
MOZ_ASSERT
(
usage
=
=
certificateUsageSSLServer
|
|
!
keySizeStatus
)
;
if
(
NS_FAILED
(
BlockUntilLoadableCertsLoaded
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
NS_FAILED
(
CheckForSmartCardChanges
(
)
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
evStatus
)
{
*
evStatus
=
EVStatus
:
:
NotEV
;
}
if
(
ocspStaplingStatus
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
ocspStaplingStatus
=
OCSP_STAPLING_NEVER_CHECKED
;
}
if
(
keySizeStatus
)
{
if
(
usage
!
=
certificateUsageSSLServer
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
keySizeStatus
=
KeySizeStatus
:
:
NeverChecked
;
}
if
(
usage
!
=
certificateUsageSSLServer
&
&
(
flags
&
FLAG_MUST_BE_EV
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
false
;
}
Input
certDER
;
Result
rv
=
certDER
.
Init
(
certBytes
.
Elements
(
)
certBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
NSSCertDBTrustDomain
:
:
OCSPFetching
defaultOCSPFetching
=
(
mOCSPDownloadConfig
=
=
ocspOff
)
|
|
(
mOCSPDownloadConfig
=
=
ocspEVOnly
)
|
|
(
flags
&
FLAG_LOCAL_ONLY
)
?
NSSCertDBTrustDomain
:
:
NeverFetchOCSP
:
!
mOCSPStrict
?
NSSCertDBTrustDomain
:
:
FetchOCSPForDVSoftFail
:
NSSCertDBTrustDomain
:
:
FetchOCSPForDVHardFail
;
Input
stapledOCSPResponseInput
;
const
Input
*
stapledOCSPResponse
=
nullptr
;
if
(
stapledOCSPResponseArg
)
{
rv
=
stapledOCSPResponseInput
.
Init
(
stapledOCSPResponseArg
-
>
Elements
(
)
stapledOCSPResponseArg
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
stapledOCSPResponse
=
&
stapledOCSPResponseInput
;
}
Input
sctsFromTLSInput
;
if
(
sctsFromTLS
)
{
rv
=
sctsFromTLSInput
.
Init
(
sctsFromTLS
-
>
Elements
(
)
sctsFromTLS
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
&
&
sctsFromTLSInput
.
GetLength
(
)
!
=
0
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
}
switch
(
usage
)
{
case
certificateUsageSSLClient
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_clientAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
break
;
}
case
certificateUsageSSLServer
:
{
NSSCertDBTrustDomain
:
:
OCSPFetching
evOCSPFetching
=
(
mOCSPDownloadConfig
=
=
ocspOff
)
|
|
(
flags
&
FLAG_LOCAL_ONLY
)
?
NSSCertDBTrustDomain
:
:
LocalOnlyOCSPForEV
:
NSSCertDBTrustDomain
:
:
FetchOCSPForEV
;
nsTArray
<
CertPolicyId
>
evPolicies
;
GetKnownEVPolicies
(
certBytes
evPolicies
)
;
rv
=
Result
:
:
ERROR_UNKNOWN_ERROR
;
for
(
const
auto
&
evPolicy
:
evPolicies
)
{
NSSCertDBTrustDomain
trustDomain
(
trustSSL
evOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS
ValidityCheckingMode
:
:
CheckForEV
mNetscapeStepUpPolicy
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
pinningTelemetryInfo
hostname
)
;
rv
=
BuildCertChainForOneKeyUsage
(
trustDomain
certDER
time
KeyUsage
:
:
digitalSignature
KeyUsage
:
:
keyEncipherment
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_serverAuth
evPolicy
stapledOCSPResponse
ocspStaplingStatus
)
;
if
(
rv
=
=
Success
)
{
rv
=
VerifyCertificateTransparencyPolicy
(
trustDomain
builtChain
sctsFromTLSInput
time
ctInfo
)
;
}
if
(
rv
=
=
Success
)
{
if
(
evStatus
)
{
*
evStatus
=
EVStatus
:
:
EV
;
}
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
trustDomain
.
GetIsBuiltChainRootBuiltInRoot
(
)
;
}
break
;
}
}
if
(
rv
=
=
Success
)
{
break
;
}
if
(
flags
&
FLAG_MUST_BE_EV
)
{
rv
=
Result
:
:
ERROR_POLICY_VALIDATION_FAILED
;
break
;
}
unsigned
int
keySizeOptions
[
]
=
{
MIN_RSA_BITS
MIN_RSA_BITS_WEAK
}
;
KeySizeStatus
keySizeStatuses
[
]
=
{
KeySizeStatus
:
:
LargeMinimumSucceeded
KeySizeStatus
:
:
CompatibilityRisk
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
keySizeOptions
)
=
=
MOZ_ARRAY_LENGTH
(
keySizeStatuses
)
"
keySize
array
lengths
differ
"
)
;
size_t
keySizeOptionsCount
=
MOZ_ARRAY_LENGTH
(
keySizeStatuses
)
;
for
(
size_t
i
=
0
;
i
<
keySizeOptionsCount
&
&
rv
!
=
Success
;
i
+
+
)
{
if
(
pinningTelemetryInfo
)
{
pinningTelemetryInfo
-
>
Reset
(
)
;
}
NSSCertDBTrustDomain
trustDomain
(
trustSSL
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
keySizeOptions
[
i
]
ValidityCheckingMode
:
:
CheckingOff
mNetscapeStepUpPolicy
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
pinningTelemetryInfo
hostname
)
;
rv
=
BuildCertChainForOneKeyUsage
(
trustDomain
certDER
time
KeyUsage
:
:
digitalSignature
KeyUsage
:
:
keyEncipherment
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
ocspStaplingStatus
)
;
if
(
rv
!
=
Success
&
&
!
IsFatalError
(
rv
)
&
&
rv
!
=
Result
:
:
ERROR_REVOKED_CERTIFICATE
&
&
trustDomain
.
GetIsErrorDueToDistrustedCAPolicy
(
)
)
{
rv
=
Result
:
:
ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
;
}
if
(
rv
=
=
Success
)
{
rv
=
VerifyCertificateTransparencyPolicy
(
trustDomain
builtChain
sctsFromTLSInput
time
ctInfo
)
;
}
if
(
rv
=
=
Success
)
{
if
(
keySizeStatus
)
{
*
keySizeStatus
=
keySizeStatuses
[
i
]
;
}
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
trustDomain
.
GetIsBuiltChainRootBuiltInRoot
(
)
;
}
break
;
}
}
if
(
rv
!
=
Success
&
&
keySizeStatus
)
{
*
keySizeStatus
=
KeySizeStatus
:
:
AlreadyBad
;
}
break
;
}
case
certificateUsageSSLCA
:
{
NSSCertDBTrustDomain
trustDomain
(
trustSSL
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
mNetscapeStepUpPolicy
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeCA
KeyUsage
:
:
keyCertSign
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
break
;
}
case
certificateUsageEmailSigner
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
nonRepudiation
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
}
break
;
}
case
certificateUsageEmailRecipient
:
{
NSSCertDBTrustDomain
trustDomain
(
trustEmail
defaultOCSPFetching
mOCSPCache
pinArg
mOCSPTimeoutSoft
mOCSPTimeoutHard
mCertShortLifetimeInDays
MIN_RSA_BITS_WEAK
ValidityCheckingMode
:
:
CheckingOff
NetscapeStepUpPolicy
:
:
NeverMatch
mCRLiteMode
originAttributes
mThirdPartyRootInputs
mThirdPartyIntermediateInputs
extraCertificates
builtChain
nullptr
nullptr
)
;
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
keyEncipherment
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
if
(
rv
=
=
Result
:
:
ERROR_INADEQUATE_KEY_USAGE
)
{
rv
=
BuildCertChain
(
trustDomain
certDER
time
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
keyAgreement
KeyPurposeId
:
:
id_kp_emailProtection
CertPolicyId
:
:
anyPolicy
stapledOCSPResponse
)
;
}
break
;
}
default
:
rv
=
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
Success
;
}
static
bool
CertIsSelfSigned
(
const
BackCert
&
backCert
void
*
pinarg
)
{
if
(
!
InputsAreEqual
(
backCert
.
GetIssuer
(
)
backCert
.
GetSubject
(
)
)
)
{
return
false
;
}
nsTArray
<
Span
<
const
uint8_t
>
>
emptyCertList
;
mozilla
:
:
psm
:
:
AppTrustDomain
trustDomain
(
std
:
:
move
(
emptyCertList
)
)
;
Result
rv
=
VerifySignedData
(
trustDomain
backCert
.
GetSignedData
(
)
backCert
.
GetSubjectPublicKeyInfo
(
)
)
;
return
rv
=
=
Success
;
}
static
Result
CheckCertHostnameHelper
(
Input
peerCertInput
const
nsACString
&
hostname
)
{
Input
hostnameInput
;
Result
rv
=
hostnameInput
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
hostname
.
BeginReading
(
)
)
hostname
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
rv
=
CheckCertHostname
(
peerCertInput
hostnameInput
)
;
if
(
rv
=
=
Result
:
:
ERROR_BAD_DER
)
{
return
Result
:
:
ERROR_BAD_CERT_DOMAIN
;
}
return
rv
;
}
Result
CertVerifier
:
:
VerifySSLServerCert
(
const
nsTArray
<
uint8_t
>
&
peerCertBytes
Time
time
void
*
pinarg
const
nsACString
&
hostname
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtChain
Flags
flags
const
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
extraCertificates
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLS
const
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
const
OriginAttributes
&
originAttributes
EVStatus
*
evStatus
OCSPStaplingStatus
*
ocspStaplingStatus
KeySizeStatus
*
keySizeStatus
PinningTelemetryInfo
*
pinningTelemetryInfo
CertificateTransparencyInfo
*
ctInfo
bool
*
isBuiltChainRootBuiltInRoot
)
{
MOZ_ASSERT
(
!
hostname
.
IsEmpty
(
)
)
;
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
false
;
}
if
(
evStatus
)
{
*
evStatus
=
EVStatus
:
:
NotEV
;
}
if
(
hostname
.
IsEmpty
(
)
)
{
return
Result
:
:
ERROR_BAD_CERT_DOMAIN
;
}
Input
peerCertInput
;
Result
rv
=
peerCertInput
.
Init
(
peerCertBytes
.
Elements
(
)
peerCertBytes
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
bool
isBuiltChainRootBuiltInRootLocal
;
rv
=
VerifyCert
(
peerCertBytes
certificateUsageSSLServer
time
pinarg
PromiseFlatCString
(
hostname
)
.
get
(
)
builtChain
flags
extraCertificates
stapledOCSPResponse
sctsFromTLS
originAttributes
evStatus
ocspStaplingStatus
keySizeStatus
pinningTelemetryInfo
ctInfo
&
isBuiltChainRootBuiltInRootLocal
)
;
if
(
rv
!
=
Success
)
{
EndEntityOrCA
notUsedForPaths
=
EndEntityOrCA
:
:
MustBeEndEntity
;
BackCert
peerBackCert
(
peerCertInput
notUsedForPaths
nullptr
)
;
if
(
peerBackCert
.
Init
(
)
!
=
Success
)
{
return
rv
;
}
if
(
rv
=
=
Result
:
:
ERROR_UNKNOWN_ISSUER
&
&
CertIsSelfSigned
(
peerBackCert
pinarg
)
)
{
return
Result
:
:
ERROR_SELF_SIGNED_CERT
;
}
if
(
rv
=
=
Result
:
:
ERROR_UNKNOWN_ISSUER
)
{
nsCOMPtr
<
nsINSSComponent
>
component
(
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
)
;
if
(
!
component
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
Input
issuerNameInput
=
peerBackCert
.
GetIssuer
(
)
;
SECItem
issuerNameItem
=
UnsafeMapInputToSECItem
(
issuerNameInput
)
;
UniquePORTString
issuerName
(
CERT_DerNameToAscii
(
&
issuerNameItem
)
)
;
if
(
!
issuerName
)
{
return
Result
:
:
ERROR_BAD_DER
;
}
nsresult
rv
=
component
-
>
IssuerMatchesMitmCanary
(
issuerName
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
Result
:
:
ERROR_MITM_DETECTED
;
}
}
if
(
rv
=
=
Result
:
:
ERROR_EXPIRED_CERTIFICATE
|
|
rv
=
=
Result
:
:
ERROR_NOT_YET_VALID_CERTIFICATE
|
|
rv
=
=
Result
:
:
ERROR_INVALID_DER_TIME
)
{
Result
hostnameResult
=
CheckCertHostnameHelper
(
peerCertInput
hostname
)
;
if
(
hostnameResult
!
=
Success
)
{
return
hostnameResult
;
}
}
return
rv
;
}
if
(
dcInfo
)
{
rv
=
IsDelegatedCredentialAcceptable
(
*
dcInfo
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
Input
stapledOCSPResponseInput
;
Input
*
responseInputPtr
=
nullptr
;
if
(
stapledOCSPResponse
)
{
rv
=
stapledOCSPResponseInput
.
Init
(
stapledOCSPResponse
-
>
Elements
(
)
stapledOCSPResponse
-
>
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
Result
:
:
ERROR_OCSP_MALFORMED_RESPONSE
;
}
responseInputPtr
=
&
stapledOCSPResponseInput
;
}
if
(
!
(
flags
&
FLAG_TLS_IGNORE_STATUS_REQUEST
)
)
{
rv
=
CheckTLSFeaturesAreSatisfied
(
peerCertInput
responseInputPtr
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
rv
=
CheckCertHostnameHelper
(
peerCertInput
hostname
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
isBuiltChainRootBuiltInRoot
)
{
*
isBuiltChainRootBuiltInRoot
=
isBuiltChainRootBuiltInRootLocal
;
}
return
Success
;
}
}
}
