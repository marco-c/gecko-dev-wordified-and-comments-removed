#
ifndef
TrustOverrides_h
#
define
TrustOverrides_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
pkix
;
struct
DataAndLength
{
const
uint8_t
*
data
;
uint32_t
len
;
}
;
template
<
size_t
T
>
static
bool
CertDNIsInList
(
const
nsTArray
<
uint8_t
>
&
aCert
const
DataAndLength
(
&
aDnList
)
[
T
]
)
{
Input
certInput
;
mozilla
:
:
pkix
:
:
Result
rv
=
certInput
.
Init
(
aCert
.
Elements
(
)
aCert
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
EndEntityOrCA
notUsedForPaths
=
EndEntityOrCA
:
:
MustBeEndEntity
;
BackCert
cert
(
certInput
notUsedForPaths
nullptr
)
;
rv
=
cert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
Input
subject
(
cert
.
GetSubject
(
)
)
;
for
(
auto
&
dn
:
aDnList
)
{
Input
dnInput
;
rv
=
dnInput
.
Init
(
dn
.
data
dn
.
len
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
if
(
InputsAreEqual
(
subject
dnInput
)
)
{
return
true
;
}
}
return
false
;
}
template
<
size_t
T
>
static
bool
CertSPKIIsInList
(
const
nsTArray
<
uint8_t
>
&
aCert
const
DataAndLength
(
&
aSpkiList
)
[
T
]
)
{
Input
certInput
;
mozilla
:
:
pkix
:
:
Result
rv
=
certInput
.
Init
(
aCert
.
Elements
(
)
aCert
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
EndEntityOrCA
notUsedForPaths
=
EndEntityOrCA
:
:
MustBeEndEntity
;
BackCert
cert
(
certInput
notUsedForPaths
nullptr
)
;
rv
=
cert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
Input
publicKey
(
cert
.
GetSubjectPublicKeyInfo
(
)
)
;
for
(
auto
&
spki
:
aSpkiList
)
{
Input
spkiInput
;
rv
=
spkiInput
.
Init
(
spki
.
data
spki
.
len
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
if
(
InputsAreEqual
(
publicKey
spkiInput
)
)
{
return
true
;
}
}
return
false
;
}
template
<
size_t
T
size_t
R
>
static
bool
CertMatchesStaticData
(
const
nsTArray
<
uint8_t
>
&
aCert
const
unsigned
char
(
&
subject
)
[
T
]
const
unsigned
char
(
&
spki
)
[
R
]
)
{
Input
certInput
;
mozilla
:
:
pkix
:
:
Result
rv
=
certInput
.
Init
(
aCert
.
Elements
(
)
aCert
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
EndEntityOrCA
notUsedForPaths
=
EndEntityOrCA
:
:
MustBeEndEntity
;
BackCert
cert
(
certInput
notUsedForPaths
nullptr
)
;
rv
=
cert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
Input
certSubject
(
cert
.
GetSubject
(
)
)
;
Input
certSPKI
(
cert
.
GetSubjectPublicKeyInfo
(
)
)
;
Input
subjectInput
;
rv
=
subjectInput
.
Init
(
subject
T
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
Input
spkiInput
;
rv
=
spkiInput
.
Init
(
spki
R
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
return
InputsAreEqual
(
certSubject
subjectInput
)
&
&
InputsAreEqual
(
certSPKI
spkiInput
)
;
}
template
<
size_t
T
>
static
nsresult
CheckForSymantecDistrust
(
const
nsTArray
<
nsTArray
<
uint8_t
>
>
&
intCerts
const
DataAndLength
(
&
allowlist
)
[
T
]
bool
&
isDistrusted
)
{
isDistrusted
=
true
;
for
(
const
auto
&
cert
:
intCerts
)
{
if
(
CertSPKIIsInList
(
cert
allowlist
)
)
{
isDistrusted
=
false
;
break
;
}
}
return
NS_OK
;
}
#
endif
