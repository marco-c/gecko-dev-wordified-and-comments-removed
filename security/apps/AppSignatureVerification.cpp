#
include
"
nsNSSCertificateDB
.
h
"
#
include
"
AppTrustDomain
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
SharedCertVerifier
.
h
"
#
include
"
certdb
.
h
"
#
include
"
cms
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDependentString
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIDirectoryEnumerator
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIStringEnumerator
.
h
"
#
include
"
nsIZipReader
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
pkix
/
pkix
.
h
"
#
include
"
pkix
/
pkixnss
.
h
"
#
include
"
plstr
.
h
"
#
include
"
secmime
.
h
"
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
psm
;
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
namespace
{
struct
DigestWithAlgorithm
{
nsresult
ValidateLength
(
)
const
{
size_t
hashLen
;
switch
(
mAlgorithm
)
{
case
SEC_OID_SHA256
:
hashLen
=
SHA256_LENGTH
;
break
;
case
SEC_OID_SHA1
:
hashLen
=
SHA1_LENGTH
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unsupported
hash
type
in
DigestWithAlgorithm
:
:
ValidateLength
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mDigest
.
Length
(
)
!
=
hashLen
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
return
NS_OK
;
}
nsAutoCString
mDigest
;
SECOidTag
mAlgorithm
;
}
;
inline
nsDependentCSubstring
DigestToDependentString
(
const
Digest
&
digest
)
{
return
nsDependentCSubstring
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
digest
.
get
(
)
.
data
)
digest
.
get
(
)
.
len
)
;
}
nsresult
ReadStream
(
const
nsCOMPtr
<
nsIInputStream
>
&
stream
SECItem
&
buf
)
{
uint64_t
length
;
nsresult
rv
=
stream
-
>
Available
(
&
length
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
static
const
uint32_t
MAX_LENGTH
=
1024
*
1024
;
if
(
length
>
MAX_LENGTH
)
{
return
NS_ERROR_FILE_TOO_BIG
;
}
SECITEM_AllocItem
(
buf
static_cast
<
uint32_t
>
(
length
+
1
)
)
;
uint32_t
bytesRead
;
rv
=
stream
-
>
Read
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
buf
.
data
)
buf
.
len
&
bytesRead
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bytesRead
!
=
length
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
buf
.
data
[
buf
.
len
-
1
]
=
0
;
return
NS_OK
;
}
nsresult
FindAndLoadOneEntry
(
nsIZipReader
*
zip
const
nsACString
&
searchPattern
nsACString
&
filename
SECItem
&
buf
SECOidTag
digestAlgorithm
=
SEC_OID_SHA1
Digest
*
bufDigest
=
nullptr
)
{
nsCOMPtr
<
nsIUTF8StringEnumerator
>
files
;
nsresult
rv
=
zip
-
>
FindEntries
(
searchPattern
getter_AddRefs
(
files
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
files
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
bool
more
;
rv
=
files
-
>
HasMore
(
&
more
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
more
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
rv
=
files
-
>
GetNext
(
filename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
files
-
>
HasMore
(
&
more
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
more
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
zip
-
>
GetInputStream
(
filename
getter_AddRefs
(
stream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadStream
(
stream
buf
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
if
(
bufDigest
)
{
rv
=
bufDigest
-
>
DigestBuf
(
digestAlgorithm
buf
.
data
buf
.
len
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
VerifyStreamContentDigest
(
nsIInputStream
*
stream
const
DigestWithAlgorithm
&
digestFromManifest
SECItem
&
buf
)
{
MOZ_ASSERT
(
buf
.
len
>
0
)
;
nsresult
rv
=
digestFromManifest
.
ValidateLength
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint64_t
len64
;
rv
=
stream
-
>
Available
(
&
len64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
len64
>
UINT32_MAX
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE
;
}
UniquePK11Context
digestContext
(
PK11_CreateDigestContext
(
digestFromManifest
.
mAlgorithm
)
)
;
if
(
!
digestContext
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
rv
=
MapSECStatus
(
PK11_DigestBegin
(
digestContext
.
get
(
)
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint64_t
totalBytesRead
=
0
;
for
(
;
;
)
{
uint32_t
bytesRead
;
rv
=
stream
-
>
Read
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
buf
.
data
)
buf
.
len
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
bytesRead
=
=
0
)
{
break
;
}
totalBytesRead
+
=
bytesRead
;
if
(
totalBytesRead
>
=
UINT32_MAX
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE
;
}
rv
=
MapSECStatus
(
PK11_DigestOp
(
digestContext
.
get
(
)
buf
.
data
bytesRead
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
totalBytesRead
!
=
len64
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
Digest
digest
;
rv
=
digest
.
End
(
digestFromManifest
.
mAlgorithm
digestContext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsDependentCSubstring
digestStr
(
DigestToDependentString
(
digest
)
)
;
if
(
!
digestStr
.
Equals
(
digestFromManifest
.
mDigest
)
)
{
return
NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY
;
}
return
NS_OK
;
}
nsresult
VerifyEntryContentDigest
(
nsIZipReader
*
zip
const
nsACString
&
aFilename
const
DigestWithAlgorithm
&
digestFromManifest
SECItem
&
buf
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
zip
-
>
GetInputStream
(
aFilename
getter_AddRefs
(
stream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
;
}
return
VerifyStreamContentDigest
(
stream
digestFromManifest
buf
)
;
}
nsresult
ReadLine
(
const
char
*
&
nextLineStart
nsCString
&
line
bool
allowContinuations
=
true
)
{
line
.
Truncate
(
)
;
size_t
previousLength
=
0
;
size_t
currentLength
=
0
;
for
(
;
;
)
{
const
char
*
eol
=
PL_strpbrk
(
nextLineStart
"
\
r
\
n
"
)
;
if
(
!
eol
)
{
eol
=
nextLineStart
+
strlen
(
nextLineStart
)
;
}
previousLength
=
currentLength
;
line
.
Append
(
nextLineStart
eol
-
nextLineStart
)
;
currentLength
=
line
.
Length
(
)
;
static
const
size_t
lineLimit
=
72
;
if
(
currentLength
-
previousLength
>
lineLimit
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
currentLength
>
65535
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
*
eol
=
=
'
\
r
'
)
{
+
+
eol
;
}
if
(
*
eol
=
=
'
\
n
'
)
{
+
+
eol
;
}
nextLineStart
=
eol
;
if
(
*
eol
!
=
'
'
)
{
return
NS_OK
;
}
if
(
!
allowContinuations
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
+
+
nextLineStart
;
}
}
#
define
JAR_MF_SEARCH_STRING
"
(
M
|
/
M
)
ETA
-
INF
/
(
M
|
m
)
(
ANIFEST
|
anifest
)
.
(
MF
|
mf
)
"
#
define
JAR_SF_SEARCH_STRING
"
(
M
|
/
M
)
ETA
-
INF
/
*
.
(
SF
|
sf
)
"
#
define
JAR_RSA_SEARCH_STRING
"
(
M
|
/
M
)
ETA
-
INF
/
*
.
(
RSA
|
rsa
)
"
#
define
JAR_META_DIR
"
META
-
INF
"
#
define
JAR_MF_HEADER
"
Manifest
-
Version
:
1
.
0
"
#
define
JAR_SF_HEADER
"
Signature
-
Version
:
1
.
0
"
nsresult
ParseAttribute
(
const
nsAutoCString
&
curLine
nsAutoCString
&
attrName
nsAutoCString
&
attrValue
)
{
int32_t
colonPos
=
curLine
.
FindChar
(
'
:
'
)
;
if
(
colonPos
=
=
kNotFound
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
int32_t
nameEnd
=
colonPos
;
for
(
;
;
)
{
if
(
nameEnd
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
curLine
[
nameEnd
-
1
]
!
=
'
'
)
break
;
-
-
nameEnd
;
}
curLine
.
Left
(
attrName
nameEnd
)
;
int32_t
valueStart
=
colonPos
+
1
;
int32_t
curLineLength
=
curLine
.
Length
(
)
;
while
(
valueStart
!
=
curLineLength
&
&
curLine
[
valueStart
]
=
=
'
'
)
{
+
+
valueStart
;
}
curLine
.
Right
(
attrValue
curLineLength
-
valueStart
)
;
return
NS_OK
;
}
nsresult
CheckManifestVersion
(
const
char
*
&
nextLineStart
const
nsACString
&
expectedHeader
)
{
nsAutoCString
curLine
;
nsresult
rv
=
ReadLine
(
nextLineStart
curLine
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
curLine
.
Equals
(
expectedHeader
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
return
NS_OK
;
}
nsresult
ParseSF
(
const
char
*
filebuf
SECOidTag
digestAlgorithm
nsAutoCString
&
mfDigest
)
{
const
char
*
digestNameToFind
=
nullptr
;
switch
(
digestAlgorithm
)
{
case
SEC_OID_SHA256
:
digestNameToFind
=
"
sha256
-
digest
-
manifest
"
;
break
;
case
SEC_OID_SHA1
:
digestNameToFind
=
"
sha1
-
digest
-
manifest
"
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
bad
argument
to
ParseSF
"
)
;
return
NS_ERROR_FAILURE
;
}
const
char
*
nextLineStart
=
filebuf
;
nsresult
rv
=
CheckManifestVersion
(
nextLineStart
NS_LITERAL_CSTRING
(
JAR_SF_HEADER
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
for
(
;
;
)
{
nsAutoCString
curLine
;
rv
=
ReadLine
(
nextLineStart
curLine
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
curLine
.
Length
(
)
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsAutoCString
attrName
;
nsAutoCString
attrValue
;
rv
=
ParseAttribute
(
curLine
attrName
attrValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
attrName
.
EqualsIgnoreCase
(
digestNameToFind
)
)
{
rv
=
Base64Decode
(
attrValue
mfDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
somehow
exited
loop
in
ParseSF
without
returning
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
ParseMF
(
const
char
*
filebuf
nsIZipReader
*
zip
SECOidTag
digestAlgorithm
nsTHashtable
<
nsCStringHashKey
>
&
mfItems
ScopedAutoSECItem
&
buf
)
{
const
char
*
digestNameToFind
=
nullptr
;
switch
(
digestAlgorithm
)
{
case
SEC_OID_SHA256
:
digestNameToFind
=
"
sha256
-
digest
"
;
break
;
case
SEC_OID_SHA1
:
digestNameToFind
=
"
sha1
-
digest
"
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
bad
argument
to
ParseMF
"
)
;
return
NS_ERROR_FAILURE
;
}
const
char
*
nextLineStart
=
filebuf
;
nsresult
rv
=
CheckManifestVersion
(
nextLineStart
NS_LITERAL_CSTRING
(
JAR_MF_HEADER
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
{
nsAutoCString
line
;
do
{
rv
=
ReadLine
(
nextLineStart
line
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
while
(
line
.
Length
(
)
>
0
)
;
if
(
*
nextLineStart
=
=
'
\
0
'
)
{
return
NS_OK
;
}
}
nsAutoCString
curItemName
;
nsAutoCString
digest
;
for
(
;
;
)
{
nsAutoCString
curLine
;
rv
=
ReadLine
(
nextLineStart
curLine
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
curLine
.
Length
(
)
=
=
0
)
{
if
(
curItemName
.
Length
(
)
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
digest
.
IsEmpty
(
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
mfItems
.
Contains
(
curItemName
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
DigestWithAlgorithm
digestWithAlgorithm
=
{
digest
digestAlgorithm
}
;
rv
=
VerifyEntryContentDigest
(
zip
curItemName
digestWithAlgorithm
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mfItems
.
PutEntry
(
curItemName
)
;
if
(
*
nextLineStart
=
=
'
\
0
'
)
{
break
;
}
curItemName
.
Truncate
(
)
;
digest
.
Truncate
(
)
;
continue
;
}
nsAutoCString
attrName
;
nsAutoCString
attrValue
;
rv
=
ParseAttribute
(
curLine
attrName
attrValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
attrName
.
EqualsIgnoreCase
(
digestNameToFind
)
)
{
if
(
!
digest
.
IsEmpty
(
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
rv
=
Base64Decode
(
attrValue
digest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
continue
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
name
"
)
)
{
if
(
MOZ_UNLIKELY
(
curItemName
.
Length
(
)
>
0
)
)
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
if
(
MOZ_UNLIKELY
(
attrValue
.
Length
(
)
=
=
0
)
)
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
curItemName
=
attrValue
;
continue
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
magic
"
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
}
return
NS_OK
;
}
nsresult
VerifyCertificate
(
CERTCertificate
*
signerCert
AppTrustedRoot
trustedRoot
UniqueCERTCertList
&
builtChain
)
{
if
(
NS_WARN_IF
(
!
signerCert
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AppTrustDomain
trustDomain
(
builtChain
nullptr
)
;
nsresult
rv
=
trustDomain
.
SetTrustedRoot
(
trustedRoot
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Input
certDER
;
mozilla
:
:
pkix
:
:
Result
result
=
certDER
.
Init
(
signerCert
-
>
derCert
.
data
signerCert
-
>
derCert
.
len
)
;
if
(
result
!
=
Success
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
MapResultToPRErrorCode
(
result
)
)
;
}
result
=
BuildCertChain
(
trustDomain
certDER
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_codeSigning
CertPolicyId
:
:
anyPolicy
nullptr
)
;
if
(
result
=
=
mozilla
:
:
pkix
:
:
Result
:
:
ERROR_EXPIRED_CERTIFICATE
)
{
result
=
Success
;
}
if
(
result
!
=
Success
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
MapResultToPRErrorCode
(
result
)
)
;
}
return
NS_OK
;
}
NSSCMSSignerInfo
*
GetSignerInfoForDigestAlgorithm
(
NSSCMSSignedData
*
signedData
SECOidTag
digestAlgorithm
)
{
MOZ_ASSERT
(
digestAlgorithm
=
=
SEC_OID_SHA1
|
|
digestAlgorithm
=
=
SEC_OID_SHA256
)
;
if
(
digestAlgorithm
!
=
SEC_OID_SHA1
&
&
digestAlgorithm
!
=
SEC_OID_SHA256
)
{
return
nullptr
;
}
int
numSigners
=
NSS_CMSSignedData_SignerInfoCount
(
signedData
)
;
if
(
numSigners
<
1
)
{
return
nullptr
;
}
for
(
int
i
=
0
;
i
<
numSigners
;
i
+
+
)
{
NSSCMSSignerInfo
*
signerInfo
=
NSS_CMSSignedData_GetSignerInfo
(
signedData
i
)
;
SECOidData
*
digestAlgOID
=
SECOID_FindOID
(
&
signerInfo
-
>
digestAlg
.
algorithm
)
;
if
(
!
digestAlgOID
)
{
continue
;
}
if
(
digestAlgorithm
=
=
digestAlgOID
-
>
offset
)
{
return
signerInfo
;
}
}
return
nullptr
;
}
nsresult
VerifySignature
(
AppTrustedRoot
trustedRoot
const
SECItem
&
buffer
const
SECItem
&
detachedSHA1Digest
const
SECItem
&
detachedSHA256Digest
SECOidTag
&
digestAlgorithm
UniqueCERTCertList
&
builtChain
)
{
if
(
NS_WARN_IF
(
!
buffer
.
data
|
|
buffer
.
len
=
=
0
|
|
!
detachedSHA1Digest
.
data
|
|
detachedSHA1Digest
.
len
=
=
0
|
|
!
detachedSHA256Digest
.
data
|
|
detachedSHA256Digest
.
len
=
=
0
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
UniqueNSSCMSMessage
cmsMsg
(
NSS_CMSMessage_CreateFromDER
(
const_cast
<
SECItem
*
>
(
&
buffer
)
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
)
)
;
if
(
!
cmsMsg
)
{
return
NS_ERROR_CMS_VERIFY_NOT_SIGNED
;
}
if
(
!
NSS_CMSMessage_IsSigned
(
cmsMsg
.
get
(
)
)
)
{
return
NS_ERROR_CMS_VERIFY_NOT_SIGNED
;
}
NSSCMSContentInfo
*
cinfo
=
NSS_CMSMessage_ContentLevel
(
cmsMsg
.
get
(
)
0
)
;
if
(
!
cinfo
)
{
return
NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO
;
}
if
(
NSS_CMSContentInfo_GetContentTypeTag
(
cinfo
)
!
=
SEC_OID_PKCS7_SIGNED_DATA
)
{
return
NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO
;
}
NSSCMSSignedData
*
signedData
=
static_cast
<
NSSCMSSignedData
*
>
(
NSS_CMSContentInfo_GetContent
(
cinfo
)
)
;
if
(
!
signedData
)
{
return
NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO
;
}
UniqueCERTCertList
certs
(
CERT_NewCertList
(
)
)
;
if
(
!
certs
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
signedData
-
>
rawCerts
)
{
for
(
size_t
i
=
0
;
signedData
-
>
rawCerts
[
i
]
;
+
+
i
)
{
UniqueCERTCertificate
cert
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
signedData
-
>
rawCerts
[
i
]
nullptr
false
true
)
)
;
if
(
!
cert
)
{
continue
;
}
if
(
CERT_AddCertToListTail
(
certs
.
get
(
)
cert
.
get
(
)
)
!
=
SECSuccess
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
Unused
<
<
cert
.
release
(
)
;
}
}
NSSCMSSignerInfo
*
signerInfo
=
GetSignerInfoForDigestAlgorithm
(
signedData
SEC_OID_SHA256
)
;
const
SECItem
*
detachedDigest
=
&
detachedSHA256Digest
;
digestAlgorithm
=
SEC_OID_SHA256
;
if
(
!
signerInfo
)
{
signerInfo
=
GetSignerInfoForDigestAlgorithm
(
signedData
SEC_OID_SHA1
)
;
if
(
!
signerInfo
)
{
return
NS_ERROR_CMS_VERIFY_NOT_SIGNED
;
}
detachedDigest
=
&
detachedSHA1Digest
;
digestAlgorithm
=
SEC_OID_SHA1
;
}
CERTCertificate
*
signerCert
=
NSS_CMSSignerInfo_GetSigningCertificate
(
signerInfo
CERT_GetDefaultCertDB
(
)
)
;
if
(
!
signerCert
)
{
return
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
;
}
nsresult
rv
=
VerifyCertificate
(
signerCert
trustedRoot
builtChain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
char
*
pkcs7DataOidString
=
"
1
.
2
.
840
.
113549
.
1
.
7
.
1
"
;
ScopedAutoSECItem
pkcs7DataOid
;
if
(
SEC_StringToOID
(
nullptr
&
pkcs7DataOid
pkcs7DataOidString
0
)
!
=
SECSuccess
)
{
return
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
;
}
return
MapSECStatus
(
NSS_CMSSignerInfo_Verify
(
signerInfo
const_cast
<
SECItem
*
>
(
detachedDigest
)
&
pkcs7DataOid
)
)
;
}
enum
class
SignaturePolicy
{
PKCS7WithSHA1OrSHA256
=
0
PKCS7WithSHA256
=
1
}
;
nsresult
OpenSignedAppFile
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aJarFile
SignaturePolicy
aPolicy
nsIZipReader
*
*
aZipReader
nsIX509Cert
*
*
aSignerCert
)
{
NS_ENSURE_ARG_POINTER
(
aJarFile
)
;
if
(
aZipReader
)
{
*
aZipReader
=
nullptr
;
}
if
(
aSignerCert
)
{
*
aSignerCert
=
nullptr
;
}
nsresult
rv
;
static
NS_DEFINE_CID
(
kZipReaderCID
NS_ZIPREADER_CID
)
;
nsCOMPtr
<
nsIZipReader
>
zip
=
do_CreateInstance
(
kZipReaderCID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
zip
-
>
Open
(
aJarFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
sigFilename
;
ScopedAutoSECItem
sigBuffer
;
rv
=
FindAndLoadOneEntry
(
zip
nsLiteralCString
(
JAR_RSA_SEARCH_STRING
)
sigFilename
sigBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_NOT_SIGNED
;
}
nsAutoCString
sfFilename
;
ScopedAutoSECItem
sfBuffer
;
rv
=
FindAndLoadOneEntry
(
zip
NS_LITERAL_CSTRING
(
JAR_SF_SEARCH_STRING
)
sfFilename
sfBuffer
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
Digest
sfCalculatedSHA1Digest
;
rv
=
sfCalculatedSHA1Digest
.
DigestBuf
(
SEC_OID_SHA1
sfBuffer
.
data
sfBuffer
.
len
-
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Digest
sfCalculatedSHA256Digest
;
rv
=
sfCalculatedSHA256Digest
.
DigestBuf
(
SEC_OID_SHA256
sfBuffer
.
data
sfBuffer
.
len
-
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
sigBuffer
.
type
=
siBuffer
;
UniqueCERTCertList
builtChain
;
SECOidTag
digestToUse
;
rv
=
VerifySignature
(
aTrustedRoot
sigBuffer
sfCalculatedSHA1Digest
.
get
(
)
sfCalculatedSHA256Digest
.
get
(
)
digestToUse
builtChain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
switch
(
aPolicy
)
{
case
SignaturePolicy
:
:
PKCS7WithSHA256
:
if
(
digestToUse
!
=
SEC_OID_SHA256
)
{
return
NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE
;
}
break
;
case
SignaturePolicy
:
:
PKCS7WithSHA1OrSHA256
:
break
;
}
nsAutoCString
mfDigest
;
rv
=
ParseSF
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
sfBuffer
.
data
)
digestToUse
mfDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
mfFilename
;
ScopedAutoSECItem
manifestBuffer
;
Digest
mfCalculatedDigest
;
rv
=
FindAndLoadOneEntry
(
zip
NS_LITERAL_CSTRING
(
JAR_MF_SEARCH_STRING
)
mfFilename
manifestBuffer
digestToUse
&
mfCalculatedDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsDependentCSubstring
calculatedDigest
(
DigestToDependentString
(
mfCalculatedDigest
)
)
;
if
(
!
mfDigest
.
Equals
(
calculatedDigest
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
ScopedAutoSECItem
buf
(
128
*
1024
)
;
nsTHashtable
<
nsCStringHashKey
>
items
;
rv
=
ParseMF
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
manifestBuffer
.
data
)
zip
digestToUse
items
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIUTF8StringEnumerator
>
entries
;
rv
=
zip
-
>
FindEntries
(
EmptyCString
(
)
getter_AddRefs
(
entries
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
entries
)
{
rv
=
NS_ERROR_UNEXPECTED
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
for
(
;
;
)
{
bool
hasMore
;
rv
=
entries
-
>
HasMore
(
&
hasMore
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
hasMore
)
{
break
;
}
nsAutoCString
entryFilename
;
rv
=
entries
-
>
GetNext
(
entryFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Verifying
digests
for
%
s
"
entryFilename
.
get
(
)
)
)
;
if
(
entryFilename
=
=
mfFilename
|
|
entryFilename
=
=
sfFilename
|
|
entryFilename
=
=
sigFilename
)
{
continue
;
}
if
(
entryFilename
.
Length
(
)
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
if
(
entryFilename
[
entryFilename
.
Length
(
)
-
1
]
=
=
'
/
'
)
{
continue
;
}
nsCStringHashKey
*
item
=
items
.
GetEntry
(
entryFilename
)
;
if
(
!
item
)
{
return
NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY
;
}
items
.
RemoveEntry
(
item
)
;
}
if
(
items
.
Count
(
)
!
=
0
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
;
}
if
(
aZipReader
)
{
zip
.
forget
(
aZipReader
)
;
}
if
(
aSignerCert
)
{
CERTCertListNode
*
signerCertNode
=
CERT_LIST_HEAD
(
builtChain
)
;
if
(
!
signerCertNode
|
|
CERT_LIST_END
(
signerCertNode
builtChain
)
|
|
!
signerCertNode
-
>
cert
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIX509Cert
>
signerCert
=
nsNSSCertificate
:
:
Create
(
signerCertNode
-
>
cert
)
;
NS_ENSURE_TRUE
(
signerCert
NS_ERROR_OUT_OF_MEMORY
)
;
signerCert
.
forget
(
aSignerCert
)
;
}
return
NS_OK
;
}
class
OpenSignedAppFileTask
final
:
public
CryptoTask
{
public
:
OpenSignedAppFileTask
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aJarFile
SignaturePolicy
aPolicy
nsIOpenSignedAppFileCallback
*
aCallback
)
:
mTrustedRoot
(
aTrustedRoot
)
mJarFile
(
aJarFile
)
mPolicy
(
aPolicy
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIOpenSignedAppFileCallback
>
(
"
OpenSignedAppFileTask
:
:
mCallback
"
aCallback
)
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
{
return
OpenSignedAppFile
(
mTrustedRoot
mJarFile
mPolicy
getter_AddRefs
(
mZipReader
)
getter_AddRefs
(
mSignerCert
)
)
;
}
virtual
void
ReleaseNSSResources
(
)
override
{
}
virtual
void
CallCallback
(
nsresult
rv
)
override
{
(
void
)
mCallback
-
>
OpenSignedAppFileFinished
(
rv
mZipReader
mSignerCert
)
;
}
const
AppTrustedRoot
mTrustedRoot
;
const
nsCOMPtr
<
nsIFile
>
mJarFile
;
const
SignaturePolicy
mPolicy
;
nsMainThreadPtrHandle
<
nsIOpenSignedAppFileCallback
>
mCallback
;
nsCOMPtr
<
nsIZipReader
>
mZipReader
;
nsCOMPtr
<
nsIX509Cert
>
mSignerCert
;
}
;
static
const
SignaturePolicy
sDefaultSignaturePolicy
=
SignaturePolicy
:
:
PKCS7WithSHA1OrSHA256
;
}
NS_IMETHODIMP
nsNSSCertificateDB
:
:
OpenSignedAppFileAsync
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aJarFile
nsIOpenSignedAppFileCallback
*
aCallback
)
{
NS_ENSURE_ARG_POINTER
(
aJarFile
)
;
NS_ENSURE_ARG_POINTER
(
aCallback
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
SignaturePolicy
policy
=
static_cast
<
SignaturePolicy
>
(
Preferences
:
:
GetInt
(
"
security
.
signed_app_signatures
.
policy
"
static_cast
<
int32_t
>
(
sDefaultSignaturePolicy
)
)
)
;
switch
(
policy
)
{
case
SignaturePolicy
:
:
PKCS7WithSHA1OrSHA256
:
break
;
case
SignaturePolicy
:
:
PKCS7WithSHA256
:
break
;
default
:
policy
=
sDefaultSignaturePolicy
;
break
;
}
RefPtr
<
OpenSignedAppFileTask
>
task
(
new
OpenSignedAppFileTask
(
aTrustedRoot
aJarFile
policy
aCallback
)
)
;
return
task
-
>
Dispatch
(
"
SignedJAR
"
)
;
}
NS_IMETHODIMP
nsNSSCertificateDB
:
:
VerifySignedDirectoryAsync
(
AppTrustedRoot
nsIFile
*
nsIVerifySignedDirectoryCallback
*
aCallback
)
{
NS_ENSURE_ARG_POINTER
(
aCallback
)
;
return
aCallback
-
>
VerifySignedDirectoryFinished
(
NS_ERROR_SIGNED_JAR_NOT_SIGNED
nullptr
)
;
}
