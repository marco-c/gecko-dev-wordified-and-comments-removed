#
include
"
nsNSSCertificateDB
.
h
"
#
include
"
AppTrustDomain
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
certdb
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDataSignatureVerifier
.
h
"
#
include
"
nsDependentString
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIDirectoryEnumerator
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIStringEnumerator
.
h
"
#
include
"
nsIZipReader
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
pkix
/
pkix
.
h
"
#
include
"
pkix
/
pkixnss
.
h
"
#
include
"
plstr
.
h
"
#
include
"
secmime
.
h
"
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
psm
;
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
namespace
{
inline
nsDependentCSubstring
DigestToDependentString
(
const
Digest
&
digest
)
{
return
nsDependentCSubstring
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
digest
.
get
(
)
.
data
)
digest
.
get
(
)
.
len
)
;
}
nsresult
ReadStream
(
const
nsCOMPtr
<
nsIInputStream
>
&
stream
SECItem
&
buf
)
{
uint64_t
length
;
nsresult
rv
=
stream
-
>
Available
(
&
length
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
static
const
uint32_t
MAX_LENGTH
=
1024
*
1024
;
if
(
length
>
MAX_LENGTH
)
{
return
NS_ERROR_FILE_TOO_BIG
;
}
SECITEM_AllocItem
(
buf
static_cast
<
uint32_t
>
(
length
+
1
)
)
;
uint32_t
bytesRead
;
rv
=
stream
-
>
Read
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
buf
.
data
)
buf
.
len
&
bytesRead
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bytesRead
!
=
length
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
buf
.
data
[
buf
.
len
-
1
]
=
0
;
return
NS_OK
;
}
nsresult
FindAndLoadOneEntry
(
nsIZipReader
*
zip
const
nsACString
&
searchPattern
nsACString
&
filename
SECItem
&
buf
Digest
*
bufDigest
)
{
nsCOMPtr
<
nsIUTF8StringEnumerator
>
files
;
nsresult
rv
=
zip
-
>
FindEntries
(
searchPattern
getter_AddRefs
(
files
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
files
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
bool
more
;
rv
=
files
-
>
HasMore
(
&
more
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
more
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
rv
=
files
-
>
GetNext
(
filename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
files
-
>
HasMore
(
&
more
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
more
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
zip
-
>
GetInputStream
(
filename
getter_AddRefs
(
stream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadStream
(
stream
buf
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
if
(
bufDigest
)
{
rv
=
bufDigest
-
>
DigestBuf
(
SEC_OID_SHA1
buf
.
data
buf
.
len
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
VerifyStreamContentDigest
(
nsIInputStream
*
stream
const
nsCString
&
digestFromManifest
SECItem
&
buf
)
{
MOZ_ASSERT
(
buf
.
len
>
0
)
;
if
(
digestFromManifest
.
Length
(
)
!
=
SHA1_LENGTH
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsresult
rv
;
uint64_t
len64
;
rv
=
stream
-
>
Available
(
&
len64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
len64
>
UINT32_MAX
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE
;
}
UniquePK11Context
digestContext
(
PK11_CreateDigestContext
(
SEC_OID_SHA1
)
)
;
if
(
!
digestContext
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
rv
=
MapSECStatus
(
PK11_DigestBegin
(
digestContext
.
get
(
)
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint64_t
totalBytesRead
=
0
;
for
(
;
;
)
{
uint32_t
bytesRead
;
rv
=
stream
-
>
Read
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
buf
.
data
)
buf
.
len
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
bytesRead
=
=
0
)
{
break
;
}
totalBytesRead
+
=
bytesRead
;
if
(
totalBytesRead
>
=
UINT32_MAX
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE
;
}
rv
=
MapSECStatus
(
PK11_DigestOp
(
digestContext
.
get
(
)
buf
.
data
bytesRead
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
totalBytesRead
!
=
len64
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
Digest
digest
;
rv
=
digest
.
End
(
SEC_OID_SHA1
digestContext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsDependentCSubstring
digestStr
(
DigestToDependentString
(
digest
)
)
;
if
(
!
digestStr
.
Equals
(
digestFromManifest
)
)
{
return
NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY
;
}
return
NS_OK
;
}
nsresult
VerifyEntryContentDigest
(
nsIZipReader
*
zip
const
nsACString
&
aFilename
const
nsCString
&
digestFromManifest
SECItem
&
buf
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
zip
-
>
GetInputStream
(
aFilename
getter_AddRefs
(
stream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
;
}
return
VerifyStreamContentDigest
(
stream
digestFromManifest
buf
)
;
}
nsresult
VerifyFileContentDigest
(
nsIFile
*
aDir
const
nsAString
&
aFilename
const
nsCString
&
digestFromManifest
SECItem
&
buf
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
aDir
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
pos
=
0
;
int32_t
slash
;
int32_t
namelen
=
aFilename
.
Length
(
)
;
if
(
namelen
=
=
0
|
|
aFilename
[
namelen
-
1
]
=
=
'
/
'
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
do
{
slash
=
aFilename
.
FindChar
(
'
/
'
pos
)
;
int32_t
segend
=
(
slash
=
=
kNotFound
)
?
namelen
:
slash
;
rv
=
file
-
>
Append
(
Substring
(
aFilename
pos
(
segend
-
pos
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
pos
=
slash
+
1
;
}
while
(
pos
<
namelen
&
&
slash
!
=
kNotFound
)
;
bool
exists
;
rv
=
file
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
exists
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
;
}
bool
isDir
;
rv
=
file
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
|
|
isDir
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
stream
)
file
-
1
-
1
nsIFileInputStream
:
:
CLOSE_ON_EOF
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
stream
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
;
}
return
VerifyStreamContentDigest
(
stream
digestFromManifest
buf
)
;
}
nsresult
ReadLine
(
const
char
*
&
nextLineStart
nsCString
&
line
bool
allowContinuations
=
true
)
{
line
.
Truncate
(
)
;
size_t
previousLength
=
0
;
size_t
currentLength
=
0
;
for
(
;
;
)
{
const
char
*
eol
=
PL_strpbrk
(
nextLineStart
"
\
r
\
n
"
)
;
if
(
!
eol
)
{
eol
=
nextLineStart
+
strlen
(
nextLineStart
)
;
}
previousLength
=
currentLength
;
line
.
Append
(
nextLineStart
eol
-
nextLineStart
)
;
currentLength
=
line
.
Length
(
)
;
static
const
size_t
lineLimit
=
72
;
if
(
currentLength
-
previousLength
>
lineLimit
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
currentLength
>
65535
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
*
eol
=
=
'
\
r
'
)
{
+
+
eol
;
}
if
(
*
eol
=
=
'
\
n
'
)
{
+
+
eol
;
}
nextLineStart
=
eol
;
if
(
*
eol
!
=
'
'
)
{
return
NS_OK
;
}
if
(
!
allowContinuations
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
+
+
nextLineStart
;
}
}
#
define
JAR_MF_SEARCH_STRING
"
(
M
|
/
M
)
ETA
-
INF
/
(
M
|
m
)
(
ANIFEST
|
anifest
)
.
(
MF
|
mf
)
"
#
define
JAR_SF_SEARCH_STRING
"
(
M
|
/
M
)
ETA
-
INF
/
*
.
(
SF
|
sf
)
"
#
define
JAR_RSA_SEARCH_STRING
"
(
M
|
/
M
)
ETA
-
INF
/
*
.
(
RSA
|
rsa
)
"
#
define
JAR_META_DIR
"
META
-
INF
"
#
define
JAR_MF_HEADER
"
Manifest
-
Version
:
1
.
0
"
#
define
JAR_SF_HEADER
"
Signature
-
Version
:
1
.
0
"
nsresult
ParseAttribute
(
const
nsAutoCString
&
curLine
nsAutoCString
&
attrName
nsAutoCString
&
attrValue
)
{
int32_t
colonPos
=
curLine
.
FindChar
(
'
:
'
)
;
if
(
colonPos
=
=
kNotFound
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
int32_t
nameEnd
=
colonPos
;
for
(
;
;
)
{
if
(
nameEnd
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
curLine
[
nameEnd
-
1
]
!
=
'
'
)
break
;
-
-
nameEnd
;
}
curLine
.
Left
(
attrName
nameEnd
)
;
int32_t
valueStart
=
colonPos
+
1
;
int32_t
curLineLength
=
curLine
.
Length
(
)
;
while
(
valueStart
!
=
curLineLength
&
&
curLine
[
valueStart
]
=
=
'
'
)
{
+
+
valueStart
;
}
curLine
.
Right
(
attrValue
curLineLength
-
valueStart
)
;
return
NS_OK
;
}
nsresult
CheckManifestVersion
(
const
char
*
&
nextLineStart
const
nsACString
&
expectedHeader
)
{
nsAutoCString
curLine
;
nsresult
rv
=
ReadLine
(
nextLineStart
curLine
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
curLine
.
Equals
(
expectedHeader
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
return
NS_OK
;
}
nsresult
ParseSF
(
const
char
*
filebuf
nsCString
&
mfDigest
)
{
const
char
*
nextLineStart
=
filebuf
;
nsresult
rv
=
CheckManifestVersion
(
nextLineStart
NS_LITERAL_CSTRING
(
JAR_SF_HEADER
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
for
(
;
;
)
{
nsAutoCString
curLine
;
rv
=
ReadLine
(
nextLineStart
curLine
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
curLine
.
Length
(
)
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsAutoCString
attrName
;
nsAutoCString
attrValue
;
rv
=
ParseAttribute
(
curLine
attrName
attrValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
sha1
-
digest
-
manifest
"
)
)
{
rv
=
Base64Decode
(
attrValue
mfDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
break
;
}
}
return
NS_OK
;
}
nsresult
ParseMF
(
const
char
*
filebuf
nsIZipReader
*
zip
nsTHashtable
<
nsCStringHashKey
>
&
mfItems
ScopedAutoSECItem
&
buf
)
{
nsresult
rv
;
const
char
*
nextLineStart
=
filebuf
;
rv
=
CheckManifestVersion
(
nextLineStart
NS_LITERAL_CSTRING
(
JAR_MF_HEADER
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
{
nsAutoCString
line
;
do
{
rv
=
ReadLine
(
nextLineStart
line
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
while
(
line
.
Length
(
)
>
0
)
;
if
(
*
nextLineStart
=
=
'
\
0
'
)
{
return
NS_OK
;
}
}
nsAutoCString
curItemName
;
nsAutoCString
digest
;
for
(
;
;
)
{
nsAutoCString
curLine
;
rv
=
ReadLine
(
nextLineStart
curLine
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
curLine
.
Length
(
)
=
=
0
)
{
if
(
curItemName
.
Length
(
)
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
digest
.
IsEmpty
(
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
mfItems
.
Contains
(
curItemName
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
rv
=
VerifyEntryContentDigest
(
zip
curItemName
digest
buf
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mfItems
.
PutEntry
(
curItemName
)
;
if
(
*
nextLineStart
=
=
'
\
0
'
)
break
;
curItemName
.
Truncate
(
)
;
digest
.
Truncate
(
)
;
continue
;
}
nsAutoCString
attrName
;
nsAutoCString
attrValue
;
rv
=
ParseAttribute
(
curLine
attrName
attrValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
sha1
-
digest
"
)
)
{
if
(
!
digest
.
IsEmpty
(
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
rv
=
Base64Decode
(
attrValue
digest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
continue
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
name
"
)
)
{
if
(
MOZ_UNLIKELY
(
curItemName
.
Length
(
)
>
0
)
)
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
if
(
MOZ_UNLIKELY
(
attrValue
.
Length
(
)
=
=
0
)
)
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
curItemName
=
attrValue
;
continue
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
magic
"
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
}
return
NS_OK
;
}
struct
VerifyCertificateContext
{
AppTrustedRoot
trustedRoot
;
UniqueCERTCertList
&
builtChain
;
}
;
nsresult
VerifyCertificate
(
CERTCertificate
*
signerCert
void
*
voidContext
void
*
pinArg
)
{
if
(
NS_WARN_IF
(
!
signerCert
)
|
|
NS_WARN_IF
(
!
voidContext
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
VerifyCertificateContext
&
context
=
*
static_cast
<
const
VerifyCertificateContext
*
>
(
voidContext
)
;
AppTrustDomain
trustDomain
(
context
.
builtChain
pinArg
)
;
nsresult
rv
=
trustDomain
.
SetTrustedRoot
(
context
.
trustedRoot
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Input
certDER
;
mozilla
:
:
pkix
:
:
Result
result
=
certDER
.
Init
(
signerCert
-
>
derCert
.
data
signerCert
-
>
derCert
.
len
)
;
if
(
result
!
=
Success
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
MapResultToPRErrorCode
(
result
)
)
;
}
result
=
BuildCertChain
(
trustDomain
certDER
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
digitalSignature
KeyPurposeId
:
:
id_kp_codeSigning
CertPolicyId
:
:
anyPolicy
nullptr
)
;
if
(
result
=
=
mozilla
:
:
pkix
:
:
Result
:
:
ERROR_EXPIRED_CERTIFICATE
)
{
result
=
Success
;
}
if
(
result
!
=
Success
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
MapResultToPRErrorCode
(
result
)
)
;
}
return
NS_OK
;
}
nsresult
VerifySignature
(
AppTrustedRoot
trustedRoot
const
SECItem
&
buffer
const
SECItem
&
detachedDigest
UniqueCERTCertList
&
builtChain
)
{
nsNSSShutDownPreventionLock
locker
;
VerifyCertificateContext
context
=
{
trustedRoot
builtChain
}
;
return
VerifyCMSDetachedSignatureIncludingCertificate
(
buffer
detachedDigest
VerifyCertificate
&
context
nullptr
locker
)
;
}
NS_IMETHODIMP
OpenSignedAppFile
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aJarFile
nsIZipReader
*
*
aZipReader
nsIX509Cert
*
*
aSignerCert
)
{
NS_ENSURE_ARG_POINTER
(
aJarFile
)
;
if
(
aZipReader
)
{
*
aZipReader
=
nullptr
;
}
if
(
aSignerCert
)
{
*
aSignerCert
=
nullptr
;
}
nsresult
rv
;
static
NS_DEFINE_CID
(
kZipReaderCID
NS_ZIPREADER_CID
)
;
nsCOMPtr
<
nsIZipReader
>
zip
=
do_CreateInstance
(
kZipReaderCID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
zip
-
>
Open
(
aJarFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
sigFilename
;
ScopedAutoSECItem
sigBuffer
;
rv
=
FindAndLoadOneEntry
(
zip
nsLiteralCString
(
JAR_RSA_SEARCH_STRING
)
sigFilename
sigBuffer
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_NOT_SIGNED
;
}
nsAutoCString
sfFilename
;
ScopedAutoSECItem
sfBuffer
;
Digest
sfCalculatedDigest
;
rv
=
FindAndLoadOneEntry
(
zip
NS_LITERAL_CSTRING
(
JAR_SF_SEARCH_STRING
)
sfFilename
sfBuffer
&
sfCalculatedDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
sigBuffer
.
type
=
siBuffer
;
UniqueCERTCertList
builtChain
;
rv
=
VerifySignature
(
aTrustedRoot
sigBuffer
sfCalculatedDigest
.
get
(
)
builtChain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
mfDigest
;
rv
=
ParseSF
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
sfBuffer
.
data
)
mfDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
mfFilename
;
ScopedAutoSECItem
manifestBuffer
;
Digest
mfCalculatedDigest
;
rv
=
FindAndLoadOneEntry
(
zip
NS_LITERAL_CSTRING
(
JAR_MF_SEARCH_STRING
)
mfFilename
manifestBuffer
&
mfCalculatedDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsDependentCSubstring
calculatedDigest
(
DigestToDependentString
(
mfCalculatedDigest
)
)
;
if
(
!
mfDigest
.
Equals
(
calculatedDigest
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
ScopedAutoSECItem
buf
(
128
*
1024
)
;
nsTHashtable
<
nsCStringHashKey
>
items
;
rv
=
ParseMF
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
manifestBuffer
.
data
)
zip
items
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIUTF8StringEnumerator
>
entries
;
rv
=
zip
-
>
FindEntries
(
EmptyCString
(
)
getter_AddRefs
(
entries
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
entries
)
{
rv
=
NS_ERROR_UNEXPECTED
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
for
(
;
;
)
{
bool
hasMore
;
rv
=
entries
-
>
HasMore
(
&
hasMore
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
hasMore
)
{
break
;
}
nsAutoCString
entryFilename
;
rv
=
entries
-
>
GetNext
(
entryFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Verifying
digests
for
%
s
"
entryFilename
.
get
(
)
)
)
;
if
(
entryFilename
=
=
mfFilename
|
|
entryFilename
=
=
sfFilename
|
|
entryFilename
=
=
sigFilename
)
{
continue
;
}
if
(
entryFilename
.
Length
(
)
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_INVALID
;
}
if
(
entryFilename
[
entryFilename
.
Length
(
)
-
1
]
=
=
'
/
'
)
{
continue
;
}
nsCStringHashKey
*
item
=
items
.
GetEntry
(
entryFilename
)
;
if
(
!
item
)
{
return
NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY
;
}
items
.
RemoveEntry
(
item
)
;
}
if
(
items
.
Count
(
)
!
=
0
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
;
}
if
(
aZipReader
)
{
zip
.
forget
(
aZipReader
)
;
}
if
(
aSignerCert
)
{
CERTCertListNode
*
signerCertNode
=
CERT_LIST_HEAD
(
builtChain
)
;
if
(
!
signerCertNode
|
|
CERT_LIST_END
(
signerCertNode
builtChain
)
|
|
!
signerCertNode
-
>
cert
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIX509Cert
>
signerCert
=
nsNSSCertificate
:
:
Create
(
signerCertNode
-
>
cert
)
;
NS_ENSURE_TRUE
(
signerCert
NS_ERROR_OUT_OF_MEMORY
)
;
signerCert
.
forget
(
aSignerCert
)
;
}
return
NS_OK
;
}
class
OpenSignedAppFileTask
final
:
public
CryptoTask
{
public
:
OpenSignedAppFileTask
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aJarFile
nsIOpenSignedAppFileCallback
*
aCallback
)
:
mTrustedRoot
(
aTrustedRoot
)
mJarFile
(
aJarFile
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIOpenSignedAppFileCallback
>
(
"
OpenSignedAppFileTask
:
:
mCallback
"
aCallback
)
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
{
return
OpenSignedAppFile
(
mTrustedRoot
mJarFile
getter_AddRefs
(
mZipReader
)
getter_AddRefs
(
mSignerCert
)
)
;
}
virtual
void
ReleaseNSSResources
(
)
override
{
}
virtual
void
CallCallback
(
nsresult
rv
)
override
{
(
void
)
mCallback
-
>
OpenSignedAppFileFinished
(
rv
mZipReader
mSignerCert
)
;
}
const
AppTrustedRoot
mTrustedRoot
;
const
nsCOMPtr
<
nsIFile
>
mJarFile
;
nsMainThreadPtrHandle
<
nsIOpenSignedAppFileCallback
>
mCallback
;
nsCOMPtr
<
nsIZipReader
>
mZipReader
;
nsCOMPtr
<
nsIX509Cert
>
mSignerCert
;
}
;
}
NS_IMETHODIMP
nsNSSCertificateDB
:
:
OpenSignedAppFileAsync
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aJarFile
nsIOpenSignedAppFileCallback
*
aCallback
)
{
NS_ENSURE_ARG_POINTER
(
aJarFile
)
;
NS_ENSURE_ARG_POINTER
(
aCallback
)
;
RefPtr
<
OpenSignedAppFileTask
>
task
(
new
OpenSignedAppFileTask
(
aTrustedRoot
aJarFile
aCallback
)
)
;
return
task
-
>
Dispatch
(
"
SignedJAR
"
)
;
}
nsresult
FindSignatureFilename
(
nsIFile
*
aMetaDir
nsAString
&
aFilename
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
entries
;
nsresult
rv
=
aMetaDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
files
=
do_QueryInterface
(
entries
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
files
)
{
return
NS_ERROR_SIGNED_JAR_NOT_SIGNED
;
}
bool
found
=
false
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
files
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
;
while
(
NS_SUCCEEDED
(
rv
)
&
&
file
)
{
nsAutoString
leafname
;
rv
=
file
-
>
GetLeafName
(
leafname
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
StringEndsWith
(
leafname
NS_LITERAL_STRING
(
"
.
rsa
"
)
)
)
{
if
(
!
found
)
{
found
=
true
;
aFilename
=
leafname
;
}
else
{
rv
=
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
break
;
}
}
rv
=
files
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
;
}
}
if
(
!
found
)
{
rv
=
NS_ERROR_SIGNED_JAR_NOT_SIGNED
;
}
files
-
>
Close
(
)
;
return
rv
;
}
nsresult
LoadOneMetafile
(
nsIFile
*
aMetaDir
const
nsAString
&
aFilename
SECItem
&
aBuf
Digest
*
aBufDigest
)
{
nsCOMPtr
<
nsIFile
>
metafile
;
nsresult
rv
=
aMetaDir
-
>
Clone
(
getter_AddRefs
(
metafile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
metafile
-
>
Append
(
aFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
exists
;
rv
=
metafile
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
exists
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
stream
)
metafile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadStream
(
stream
aBuf
)
;
stream
-
>
Close
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aBufDigest
)
{
rv
=
aBufDigest
-
>
DigestBuf
(
SEC_OID_SHA1
aBuf
.
data
aBuf
.
len
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
ParseMFUnpacked
(
const
char
*
aFilebuf
nsIFile
*
aDir
nsTHashtable
<
nsStringHashKey
>
&
aMfItems
ScopedAutoSECItem
&
aBuf
)
{
nsresult
rv
;
const
char
*
nextLineStart
=
aFilebuf
;
rv
=
CheckManifestVersion
(
nextLineStart
NS_LITERAL_CSTRING
(
JAR_MF_HEADER
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
{
nsAutoCString
line
;
do
{
rv
=
ReadLine
(
nextLineStart
line
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
while
(
line
.
Length
(
)
>
0
)
;
if
(
*
nextLineStart
=
=
'
\
0
'
)
{
return
NS_OK
;
}
}
nsAutoString
curItemName
;
nsAutoCString
digest
;
for
(
;
;
)
{
nsAutoCString
curLine
;
rv
=
ReadLine
(
nextLineStart
curLine
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
curLine
.
Length
(
)
=
=
0
)
{
if
(
curItemName
.
Length
(
)
=
=
0
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
digest
.
IsEmpty
(
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
aMfItems
.
Contains
(
curItemName
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
rv
=
VerifyFileContentDigest
(
aDir
curItemName
digest
aBuf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aMfItems
.
PutEntry
(
curItemName
)
;
if
(
*
nextLineStart
=
=
'
\
0
'
)
{
break
;
}
curItemName
.
Truncate
(
)
;
digest
.
Truncate
(
)
;
continue
;
}
nsAutoCString
attrName
;
nsAutoCString
attrValue
;
rv
=
ParseAttribute
(
curLine
attrName
attrValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
sha1
-
digest
"
)
)
{
if
(
!
digest
.
IsEmpty
(
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
rv
=
Base64Decode
(
attrValue
digest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
continue
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
name
"
)
)
{
if
(
MOZ_UNLIKELY
(
curItemName
.
Length
(
)
>
0
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
if
(
MOZ_UNLIKELY
(
attrValue
.
Length
(
)
=
=
0
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
curItemName
=
NS_ConvertUTF8toUTF16
(
attrValue
)
;
continue
;
}
if
(
attrName
.
LowerCaseEqualsLiteral
(
"
magic
"
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
}
return
NS_OK
;
}
nsresult
CheckDirForUnsignedFiles
(
nsIFile
*
aDir
const
nsString
&
aPath
nsTHashtable
<
nsStringHashKey
>
&
aItems
const
nsAString
&
sigFilename
const
nsAString
&
sfFilename
const
nsAString
&
mfFilename
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
entries
;
nsresult
rv
=
aDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
files
=
do_QueryInterface
(
entries
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
files
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
;
}
bool
inMeta
=
StringBeginsWith
(
aPath
NS_LITERAL_STRING
(
JAR_META_DIR
)
)
;
while
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
file
;
rv
=
files
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
file
)
{
break
;
}
nsAutoString
leafname
;
rv
=
file
-
>
GetLeafName
(
leafname
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoString
curName
(
aPath
+
leafname
)
;
bool
isDir
;
rv
=
file
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
isDir
)
{
curName
.
AppendLiteral
(
u
"
/
"
)
;
rv
=
CheckDirForUnsignedFiles
(
file
curName
aItems
sigFilename
sfFilename
mfFilename
)
;
}
else
{
if
(
inMeta
&
&
(
leafname
=
=
sigFilename
|
|
leafname
=
=
sfFilename
|
|
leafname
=
=
mfFilename
)
)
{
continue
;
}
nsStringHashKey
*
item
=
aItems
.
GetEntry
(
curName
)
;
if
(
!
item
)
{
return
NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY
;
}
aItems
.
RemoveEntry
(
item
)
;
}
}
files
-
>
Close
(
)
;
return
rv
;
}
nsresult
VerifySignedDirectory
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aDirectory
nsIX509Cert
*
*
aSignerCert
)
{
NS_ENSURE_ARG_POINTER
(
aDirectory
)
;
if
(
aSignerCert
)
{
*
aSignerCert
=
nullptr
;
}
nsCOMPtr
<
nsIFile
>
metaDir
;
nsresult
rv
=
aDirectory
-
>
Clone
(
getter_AddRefs
(
metaDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
metaDir
-
>
Append
(
NS_LITERAL_STRING
(
JAR_META_DIR
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
exists
;
rv
=
metaDir
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
exists
)
{
return
NS_ERROR_SIGNED_JAR_NOT_SIGNED
;
}
bool
isDirectory
;
rv
=
metaDir
-
>
IsDirectory
(
&
isDirectory
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
isDirectory
)
{
return
NS_ERROR_SIGNED_JAR_NOT_SIGNED
;
}
nsAutoString
sigFilename
;
rv
=
FindSignatureFilename
(
metaDir
sigFilename
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ScopedAutoSECItem
sigBuffer
;
rv
=
LoadOneMetafile
(
metaDir
sigFilename
sigBuffer
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_NOT_SIGNED
;
}
nsAutoString
sfFilename
(
Substring
(
sigFilename
0
sigFilename
.
Length
(
)
-
3
)
+
NS_LITERAL_STRING
(
"
sf
"
)
)
;
ScopedAutoSECItem
sfBuffer
;
Digest
sfCalculatedDigest
;
rv
=
LoadOneMetafile
(
metaDir
sfFilename
sfBuffer
&
sfCalculatedDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
sigBuffer
.
type
=
siBuffer
;
UniqueCERTCertList
builtChain
;
rv
=
VerifySignature
(
aTrustedRoot
sigBuffer
sfCalculatedDigest
.
get
(
)
builtChain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsAutoCString
mfDigest
;
rv
=
ParseSF
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
sfBuffer
.
data
)
mfDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsAutoString
mfFilename
(
NS_LITERAL_STRING
(
"
manifest
.
mf
"
)
)
;
ScopedAutoSECItem
manifestBuffer
;
Digest
mfCalculatedDigest
;
rv
=
LoadOneMetafile
(
metaDir
mfFilename
manifestBuffer
&
mfCalculatedDigest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
nsDependentCSubstring
calculatedDigest
(
DigestToDependentString
(
mfCalculatedDigest
)
)
;
if
(
!
mfDigest
.
Equals
(
calculatedDigest
)
)
{
return
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
;
}
ScopedAutoSECItem
buf
(
128
*
1024
)
;
nsTHashtable
<
nsStringHashKey
>
items
;
rv
=
ParseMFUnpacked
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
manifestBuffer
.
data
)
aDirectory
items
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CheckDirForUnsignedFiles
(
aDirectory
EmptyString
(
)
items
sigFilename
sfFilename
mfFilename
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
items
.
Count
(
)
!
=
0
)
{
return
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
;
}
if
(
aSignerCert
)
{
CERTCertListNode
*
signerCertNode
=
CERT_LIST_HEAD
(
builtChain
)
;
if
(
!
signerCertNode
|
|
CERT_LIST_END
(
signerCertNode
builtChain
)
|
|
!
signerCertNode
-
>
cert
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIX509Cert
>
signerCert
=
nsNSSCertificate
:
:
Create
(
signerCertNode
-
>
cert
)
;
NS_ENSURE_TRUE
(
signerCert
NS_ERROR_OUT_OF_MEMORY
)
;
signerCert
.
forget
(
aSignerCert
)
;
}
return
NS_OK
;
}
class
VerifySignedDirectoryTask
final
:
public
CryptoTask
{
public
:
VerifySignedDirectoryTask
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aUnpackedJar
nsIVerifySignedDirectoryCallback
*
aCallback
)
:
mTrustedRoot
(
aTrustedRoot
)
mDirectory
(
aUnpackedJar
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsIVerifySignedDirectoryCallback
>
(
"
VerifySignedDirectoryTask
:
:
mCallback
"
aCallback
)
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
{
return
VerifySignedDirectory
(
mTrustedRoot
mDirectory
getter_AddRefs
(
mSignerCert
)
)
;
}
virtual
void
ReleaseNSSResources
(
)
override
{
}
virtual
void
CallCallback
(
nsresult
rv
)
override
{
(
void
)
mCallback
-
>
VerifySignedDirectoryFinished
(
rv
mSignerCert
)
;
}
const
AppTrustedRoot
mTrustedRoot
;
const
nsCOMPtr
<
nsIFile
>
mDirectory
;
nsMainThreadPtrHandle
<
nsIVerifySignedDirectoryCallback
>
mCallback
;
nsCOMPtr
<
nsIX509Cert
>
mSignerCert
;
}
;
NS_IMETHODIMP
nsNSSCertificateDB
:
:
VerifySignedDirectoryAsync
(
AppTrustedRoot
aTrustedRoot
nsIFile
*
aUnpackedJar
nsIVerifySignedDirectoryCallback
*
aCallback
)
{
NS_ENSURE_ARG_POINTER
(
aUnpackedJar
)
;
NS_ENSURE_ARG_POINTER
(
aCallback
)
;
RefPtr
<
VerifySignedDirectoryTask
>
task
(
new
VerifySignedDirectoryTask
(
aTrustedRoot
aUnpackedJar
aCallback
)
)
;
return
task
-
>
Dispatch
(
"
UnpackedJar
"
)
;
}
