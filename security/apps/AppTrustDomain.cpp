#
include
"
AppTrustDomain
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
certdb
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIX509CertDB
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
prerror
.
h
"
#
include
"
xpcshell
.
inc
"
#
include
"
addons
-
public
.
inc
"
#
include
"
addons
-
public
-
intermediate
.
inc
"
#
include
"
addons
-
stage
.
inc
"
using
namespace
mozilla
:
:
pkix
;
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
namespace
mozilla
{
namespace
psm
{
AppTrustDomain
:
:
AppTrustDomain
(
UniqueCERTCertList
&
certChain
void
*
pinArg
)
:
mCertChain
(
certChain
)
mPinArg
(
pinArg
)
{
}
nsresult
AppTrustDomain
:
:
SetTrustedRoot
(
AppTrustedRoot
trustedRoot
)
{
SECItem
trustedDER
;
switch
(
trustedRoot
)
{
case
nsIX509CertDB
:
:
AppXPCShellRoot
:
trustedDER
.
data
=
const_cast
<
uint8_t
*
>
(
xpcshellRoot
)
;
trustedDER
.
len
=
mozilla
:
:
ArrayLength
(
xpcshellRoot
)
;
break
;
case
nsIX509CertDB
:
:
AddonsPublicRoot
:
trustedDER
.
data
=
const_cast
<
uint8_t
*
>
(
addonsPublicRoot
)
;
trustedDER
.
len
=
mozilla
:
:
ArrayLength
(
addonsPublicRoot
)
;
break
;
case
nsIX509CertDB
:
:
AddonsStageRoot
:
trustedDER
.
data
=
const_cast
<
uint8_t
*
>
(
addonsStageRoot
)
;
trustedDER
.
len
=
mozilla
:
:
ArrayLength
(
addonsStageRoot
)
;
break
;
default
:
return
NS_ERROR_INVALID_ARG
;
}
mTrustedRoot
.
reset
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
trustedDER
nullptr
false
true
)
)
;
if
(
!
mTrustedRoot
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
if
(
trustedRoot
=
=
nsIX509CertDB
:
:
AddonsPublicRoot
)
{
SECItem
intermediateDER
=
{
siBuffer
const_cast
<
uint8_t
*
>
(
addonsPublicIntermediate
)
static_cast
<
unsigned
int
>
(
mozilla
:
:
ArrayLength
(
addonsPublicIntermediate
)
)
}
;
mAddonsIntermediate
.
reset
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
intermediateDER
nullptr
false
true
)
)
;
if
(
!
mAddonsIntermediate
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
}
return
NS_OK
;
}
Result
AppTrustDomain
:
:
FindIssuer
(
Input
encodedIssuerName
IssuerChecker
&
checker
Time
)
{
MOZ_ASSERT
(
mTrustedRoot
)
;
if
(
!
mTrustedRoot
)
{
return
Result
:
:
FATAL_ERROR_INVALID_STATE
;
}
SECItem
encodedIssuerNameSECItem
=
UnsafeMapInputToSECItem
(
encodedIssuerName
)
;
UniqueCERTCertList
candidates
(
CERT_CreateSubjectCertList
(
nullptr
CERT_GetDefaultCertDB
(
)
&
encodedIssuerNameSECItem
0
false
)
)
;
if
(
candidates
)
{
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
candidates
)
;
!
CERT_LIST_END
(
n
candidates
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
Input
certDER
;
Result
rv
=
certDER
.
Init
(
n
-
>
cert
-
>
derCert
.
data
n
-
>
cert
-
>
derCert
.
len
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
bool
keepGoing
;
rv
=
checker
.
Check
(
certDER
nullptr
keepGoing
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
!
keepGoing
)
{
break
;
}
}
}
return
Success
;
}
Result
AppTrustDomain
:
:
GetCertTrust
(
EndEntityOrCA
endEntityOrCA
const
CertPolicyId
&
policy
Input
candidateCertDER
TrustLevel
&
trustLevel
)
{
MOZ_ASSERT
(
policy
.
IsAnyPolicy
(
)
)
;
MOZ_ASSERT
(
mTrustedRoot
)
;
if
(
!
policy
.
IsAnyPolicy
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
!
mTrustedRoot
)
{
return
Result
:
:
FATAL_ERROR_INVALID_STATE
;
}
SECItem
candidateCertDERSECItem
=
UnsafeMapInputToSECItem
(
candidateCertDER
)
;
UniqueCERTCertificate
candidateCert
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
candidateCertDERSECItem
nullptr
false
true
)
)
;
if
(
!
candidateCert
)
{
return
MapPRErrorCodeToResult
(
PR_GetError
(
)
)
;
}
CERTCertTrust
trust
;
if
(
CERT_GetCertTrust
(
candidateCert
.
get
(
)
&
trust
)
=
=
SECSuccess
)
{
uint32_t
flags
=
SEC_GET_TRUST_FLAGS
(
&
trust
trustObjectSigning
)
;
uint32_t
relevantTrustBit
=
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
?
CERTDB_TRUSTED_CA
:
CERTDB_TRUSTED
;
if
(
(
(
flags
&
(
relevantTrustBit
|
CERTDB_TERMINAL_RECORD
)
)
)
=
=
CERTDB_TERMINAL_RECORD
)
{
trustLevel
=
TrustLevel
:
:
ActivelyDistrusted
;
return
Success
;
}
}
if
(
CERT_CompareCerts
(
mTrustedRoot
.
get
(
)
candidateCert
.
get
(
)
)
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
trustLevel
=
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
Result
AppTrustDomain
:
:
DigestBuf
(
Input
item
DigestAlgorithm
digestAlg
uint8_t
*
digestBuf
size_t
digestBufLen
)
{
return
DigestBufNSS
(
item
digestAlg
digestBuf
digestBufLen
)
;
}
Result
AppTrustDomain
:
:
CheckRevocation
(
EndEntityOrCA
const
CertID
&
Time
Time
Duration
const
Input
*
const
Input
*
)
{
return
Success
;
}
Result
AppTrustDomain
:
:
IsChainValid
(
const
DERArray
&
certChain
Time
time
const
CertPolicyId
&
requiredPolicy
)
{
MOZ_ASSERT
(
requiredPolicy
.
IsAnyPolicy
(
)
)
;
SECStatus
srv
=
ConstructCERTCertListFromReversedDERArray
(
certChain
mCertChain
)
;
if
(
srv
!
=
SECSuccess
)
{
return
MapPRErrorCodeToResult
(
PR_GetError
(
)
)
;
}
return
Success
;
}
Result
AppTrustDomain
:
:
CheckSignatureDigestAlgorithm
(
DigestAlgorithm
EndEntityOrCA
Time
)
{
return
Success
;
}
Result
AppTrustDomain
:
:
CheckRSAPublicKeyModulusSizeInBits
(
EndEntityOrCA
unsigned
int
modulusSizeInBits
)
{
if
(
modulusSizeInBits
<
2048u
)
{
return
Result
:
:
ERROR_INADEQUATE_KEY_SIZE
;
}
return
Success
;
}
Result
AppTrustDomain
:
:
VerifyRSAPKCS1SignedDigest
(
const
SignedDigest
&
signedDigest
Input
subjectPublicKeyInfo
)
{
return
VerifyRSAPKCS1SignedDigestNSS
(
signedDigest
subjectPublicKeyInfo
mPinArg
)
;
}
Result
AppTrustDomain
:
:
CheckECDSACurveIsAcceptable
(
EndEntityOrCA
NamedCurve
curve
)
{
switch
(
curve
)
{
case
NamedCurve
:
:
secp256r1
:
case
NamedCurve
:
:
secp384r1
:
case
NamedCurve
:
:
secp521r1
:
return
Success
;
}
return
Result
:
:
ERROR_UNSUPPORTED_ELLIPTIC_CURVE
;
}
Result
AppTrustDomain
:
:
VerifyECDSASignedDigest
(
const
SignedDigest
&
signedDigest
Input
subjectPublicKeyInfo
)
{
return
VerifyECDSASignedDigestNSS
(
signedDigest
subjectPublicKeyInfo
mPinArg
)
;
}
Result
AppTrustDomain
:
:
CheckValidityIsAcceptable
(
Time
Time
EndEntityOrCA
KeyPurposeId
)
{
return
Success
;
}
Result
AppTrustDomain
:
:
NetscapeStepUpMatchesServerAuth
(
Time
bool
&
matches
)
{
matches
=
false
;
return
Success
;
}
void
AppTrustDomain
:
:
NoteAuxiliaryExtension
(
AuxiliaryExtension
Input
)
{
}
}
}
