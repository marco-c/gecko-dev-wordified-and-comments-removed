#
include
"
AppTrustDomain
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
cert_storage
/
src
/
cert_storage
.
h
"
#
include
"
certdb
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIX509CertDB
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
prerror
.
h
"
#
include
"
xpcshell
.
inc
"
#
include
"
addons
-
public
.
inc
"
#
include
"
addons
-
public
-
intermediate
.
inc
"
#
include
"
addons
-
stage
.
inc
"
using
namespace
mozilla
:
:
pkix
;
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
namespace
mozilla
{
namespace
psm
{
AppTrustDomain
:
:
AppTrustDomain
(
nsTArray
<
Span
<
const
uint8_t
>
>
&
&
collectedCerts
)
:
mIntermediates
(
std
:
:
move
(
collectedCerts
)
)
mCertBlocklist
(
do_GetService
(
NS_CERT_STORAGE_CID
)
)
{
}
nsresult
AppTrustDomain
:
:
SetTrustedRoot
(
AppTrustedRoot
trustedRoot
)
{
switch
(
trustedRoot
)
{
case
nsIX509CertDB
:
:
AppXPCShellRoot
:
mTrustedRoot
=
{
xpcshellRoot
}
;
break
;
case
nsIX509CertDB
:
:
AddonsPublicRoot
:
mTrustedRoot
=
{
addonsPublicRoot
}
;
break
;
case
nsIX509CertDB
:
:
AddonsStageRoot
:
mTrustedRoot
=
{
addonsStageRoot
}
;
break
;
default
:
return
NS_ERROR_INVALID_ARG
;
}
if
(
trustedRoot
=
=
nsIX509CertDB
:
:
AddonsPublicRoot
)
{
mAddonsIntermediate
=
{
addonsPublicIntermediate
}
;
}
return
NS_OK
;
}
Result
AppTrustDomain
:
:
FindIssuer
(
Input
encodedIssuerName
IssuerChecker
&
checker
Time
)
{
MOZ_ASSERT
(
!
mTrustedRoot
.
IsEmpty
(
)
)
;
if
(
mTrustedRoot
.
IsEmpty
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_STATE
;
}
nsTArray
<
Input
>
candidates
;
Input
rootInput
;
Result
rv
=
rootInput
.
Init
(
mTrustedRoot
.
Elements
(
)
mTrustedRoot
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
candidates
.
AppendElement
(
std
:
:
move
(
rootInput
)
)
;
if
(
!
mAddonsIntermediate
.
IsEmpty
(
)
)
{
Input
intermediateInput
;
rv
=
intermediateInput
.
Init
(
mAddonsIntermediate
.
Elements
(
)
mAddonsIntermediate
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
candidates
.
AppendElement
(
std
:
:
move
(
intermediateInput
)
)
;
}
for
(
const
auto
&
intermediate
:
mIntermediates
)
{
Input
intermediateInput
;
rv
=
intermediateInput
.
Init
(
intermediate
.
Elements
(
)
intermediate
.
Length
(
)
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
candidates
.
AppendElement
(
std
:
:
move
(
intermediateInput
)
)
;
}
for
(
const
auto
&
candidate
:
candidates
)
{
bool
keepGoing
;
rv
=
checker
.
Check
(
candidate
nullptr
keepGoing
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
!
keepGoing
)
{
return
Success
;
}
}
SECItem
encodedIssuerNameSECItem
=
UnsafeMapInputToSECItem
(
encodedIssuerName
)
;
UniqueCERTCertList
nssCandidates
(
CERT_CreateSubjectCertList
(
nullptr
CERT_GetDefaultCertDB
(
)
&
encodedIssuerNameSECItem
0
false
)
)
;
if
(
nssCandidates
)
{
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
nssCandidates
)
;
!
CERT_LIST_END
(
n
nssCandidates
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
Input
certDER
;
Result
rv
=
certDER
.
Init
(
n
-
>
cert
-
>
derCert
.
data
n
-
>
cert
-
>
derCert
.
len
)
;
if
(
rv
!
=
Success
)
{
continue
;
}
bool
keepGoing
;
rv
=
checker
.
Check
(
certDER
nullptr
keepGoing
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
!
keepGoing
)
{
break
;
}
}
}
return
Success
;
}
Result
AppTrustDomain
:
:
GetCertTrust
(
EndEntityOrCA
endEntityOrCA
const
CertPolicyId
&
policy
Input
candidateCertDER
TrustLevel
&
trustLevel
)
{
MOZ_ASSERT
(
policy
.
IsAnyPolicy
(
)
)
;
MOZ_ASSERT
(
!
mTrustedRoot
.
IsEmpty
(
)
)
;
if
(
!
policy
.
IsAnyPolicy
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
if
(
mTrustedRoot
.
IsEmpty
(
)
)
{
return
Result
:
:
FATAL_ERROR_INVALID_STATE
;
}
nsTArray
<
uint8_t
>
issuerBytes
;
nsTArray
<
uint8_t
>
serialBytes
;
nsTArray
<
uint8_t
>
subjectBytes
;
nsTArray
<
uint8_t
>
pubKeyBytes
;
Result
result
=
BuildRevocationCheckArrays
(
candidateCertDER
endEntityOrCA
issuerBytes
serialBytes
subjectBytes
pubKeyBytes
)
;
if
(
result
!
=
Success
)
{
return
result
;
}
int16_t
revocationState
;
nsresult
nsrv
=
mCertBlocklist
-
>
GetRevocationState
(
issuerBytes
serialBytes
subjectBytes
pubKeyBytes
&
revocationState
)
;
if
(
NS_FAILED
(
nsrv
)
)
{
return
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
if
(
revocationState
=
=
nsICertStorage
:
:
STATE_ENFORCE
)
{
return
Result
:
:
ERROR_REVOKED_CERTIFICATE
;
}
Span
<
const
uint8_t
>
candidateCertDERSpan
=
{
candidateCertDER
.
UnsafeGetData
(
)
candidateCertDER
.
GetLength
(
)
}
;
if
(
mTrustedRoot
=
=
candidateCertDERSpan
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
trustLevel
=
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
Result
AppTrustDomain
:
:
DigestBuf
(
Input
item
DigestAlgorithm
digestAlg
uint8_t
*
digestBuf
size_t
digestBufLen
)
{
return
DigestBufNSS
(
item
digestAlg
digestBuf
digestBufLen
)
;
}
Result
AppTrustDomain
:
:
CheckRevocation
(
EndEntityOrCA
const
CertID
&
Time
Duration
const
Input
*
const
Input
*
const
Input
*
)
{
return
Success
;
}
Result
AppTrustDomain
:
:
IsChainValid
(
const
DERArray
&
certChain
Time
time
const
CertPolicyId
&
requiredPolicy
)
{
MOZ_ASSERT
(
requiredPolicy
.
IsAnyPolicy
(
)
)
;
return
Success
;
}
Result
AppTrustDomain
:
:
CheckSignatureDigestAlgorithm
(
DigestAlgorithm
EndEntityOrCA
Time
)
{
return
Success
;
}
Result
AppTrustDomain
:
:
CheckRSAPublicKeyModulusSizeInBits
(
EndEntityOrCA
unsigned
int
modulusSizeInBits
)
{
if
(
modulusSizeInBits
<
2048u
)
{
return
Result
:
:
ERROR_INADEQUATE_KEY_SIZE
;
}
return
Success
;
}
Result
AppTrustDomain
:
:
VerifyRSAPKCS1SignedData
(
Input
data
DigestAlgorithm
digestAlgorithm
Input
signature
Input
subjectPublicKeyInfo
)
{
return
VerifyRSAPKCS1SignedDataNSS
(
data
digestAlgorithm
signature
subjectPublicKeyInfo
nullptr
)
;
}
Result
AppTrustDomain
:
:
VerifyRSAPSSSignedData
(
Input
data
DigestAlgorithm
digestAlgorithm
Input
signature
Input
subjectPublicKeyInfo
)
{
return
VerifyRSAPSSSignedDataNSS
(
data
digestAlgorithm
signature
subjectPublicKeyInfo
nullptr
)
;
}
Result
AppTrustDomain
:
:
CheckECDSACurveIsAcceptable
(
EndEntityOrCA
NamedCurve
curve
)
{
switch
(
curve
)
{
case
NamedCurve
:
:
secp256r1
:
case
NamedCurve
:
:
secp384r1
:
case
NamedCurve
:
:
secp521r1
:
return
Success
;
}
return
Result
:
:
ERROR_UNSUPPORTED_ELLIPTIC_CURVE
;
}
Result
AppTrustDomain
:
:
VerifyECDSASignedData
(
Input
data
DigestAlgorithm
digestAlgorithm
Input
signature
Input
subjectPublicKeyInfo
)
{
return
VerifyECDSASignedDataNSS
(
data
digestAlgorithm
signature
subjectPublicKeyInfo
nullptr
)
;
}
Result
AppTrustDomain
:
:
CheckValidityIsAcceptable
(
Time
Time
EndEntityOrCA
KeyPurposeId
)
{
return
Success
;
}
Result
AppTrustDomain
:
:
NetscapeStepUpMatchesServerAuth
(
Time
bool
&
matches
)
{
matches
=
false
;
return
Success
;
}
void
AppTrustDomain
:
:
NoteAuxiliaryExtension
(
AuxiliaryExtension
Input
)
{
}
}
}
