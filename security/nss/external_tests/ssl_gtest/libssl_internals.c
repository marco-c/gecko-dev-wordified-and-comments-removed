#
include
"
libssl_internals
.
h
"
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
seccomon
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslimpl
.
h
"
SECStatus
SSLInt_IncrementClientHandshakeVersion
(
PRFileDesc
*
fd
)
{
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
if
(
!
ss
)
{
return
SECFailure
;
}
+
+
ss
-
>
clientHelloVersion
;
return
SECSuccess
;
}
PRUint32
SSLInt_DetermineKEABits
(
PRUint16
serverKeyBits
SSLAuthType
authAlgorithm
)
{
if
(
authAlgorithm
=
=
ssl_auth_ecdsa
|
|
authAlgorithm
=
=
ssl_auth_ecdh_rsa
|
|
authAlgorithm
=
=
ssl_auth_ecdh_ecdsa
)
{
return
serverKeyBits
;
}
PORT_Assert
(
authAlgorithm
=
=
ssl_auth_rsa_decrypt
|
|
authAlgorithm
=
=
ssl_auth_rsa_sign
)
;
PRUint32
minKeaBits
;
#
ifdef
NSS_ECC_MORE_THAN_SUITE_B
minKeaBits
=
192U
;
#
else
minKeaBits
=
256U
;
#
endif
return
PR_MAX
(
SSL_RSASTRENGTH_TO_ECSTRENGTH
(
serverKeyBits
)
minKeaBits
)
;
}
SECStatus
SSLInt_UpdateSSLv2ClientRandom
(
PRFileDesc
*
fd
uint8_t
*
rnd
size_t
rnd_len
uint8_t
*
msg
size_t
msg_len
)
{
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
if
(
!
ss
)
{
return
SECFailure
;
}
SECStatus
rv
=
ssl3_InitState
(
ss
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
rv
=
ssl3_RestartHandshakeHashes
(
ss
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
PORT_Memset
(
&
ss
-
>
ssl3
.
hs
.
client_random
0
SSL3_RANDOM_LENGTH
)
;
size_t
offset
=
SSL3_RANDOM_LENGTH
-
rnd_len
;
PORT_Memcpy
(
&
ss
-
>
ssl3
.
hs
.
client_random
.
rand
[
offset
]
rnd
rnd_len
)
;
return
ssl3_UpdateHandshakeHashes
(
ss
msg
msg_len
)
;
}
PRBool
SSLInt_ExtensionNegotiated
(
PRFileDesc
*
fd
PRUint16
ext
)
{
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
return
(
PRBool
)
(
ss
&
&
ssl3_ExtensionNegotiated
(
ss
ext
)
)
;
}
void
SSLInt_ClearSessionTicketKey
(
)
{
ssl3_SessionTicketShutdown
(
NULL
NULL
)
;
NSS_UnregisterShutdown
(
ssl3_SessionTicketShutdown
NULL
)
;
}
SECStatus
SSLInt_SetMTU
(
PRFileDesc
*
fd
PRUint16
mtu
)
{
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
if
(
ss
)
{
ss
-
>
ssl3
.
mtu
=
mtu
;
return
SECSuccess
;
}
return
SECFailure
;
}
PRInt32
SSLInt_CountTls13CipherSpecs
(
PRFileDesc
*
fd
)
{
PRCList
*
cur_p
;
PRInt32
ct
=
0
;
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
if
(
!
ss
)
{
return
-
1
;
}
for
(
cur_p
=
PR_NEXT_LINK
(
&
ss
-
>
ssl3
.
hs
.
cipherSpecs
)
;
cur_p
!
=
&
ss
-
>
ssl3
.
hs
.
cipherSpecs
;
cur_p
=
PR_NEXT_LINK
(
cur_p
)
)
{
+
+
ct
;
}
return
ct
;
}
void
SSLInt_ForceTimerExpiry
(
PRFileDesc
*
fd
)
{
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
if
(
!
ss
)
{
return
;
}
if
(
!
ss
-
>
ssl3
.
hs
.
rtTimerCb
)
return
;
ss
-
>
ssl3
.
hs
.
rtTimerStarted
=
PR_IntervalNow
(
)
-
PR_MillisecondsToInterval
(
ss
-
>
ssl3
.
hs
.
rtTimeoutMs
+
1
)
;
}
#
define
CHECK_SECRET
(
secret
)
\
if
(
ss
-
>
ssl3
.
hs
.
secret
)
{
\
fprintf
(
stderr
"
%
s
!
=
NULL
\
n
"
#
secret
)
;
\
return
PR_FALSE
;
\
}
PRBool
SSLInt_CheckSecretsDestroyed
(
PRFileDesc
*
fd
)
{
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
if
(
!
ss
)
{
return
PR_FALSE
;
}
CHECK_SECRET
(
currentSecret
)
;
CHECK_SECRET
(
resumptionPsk
)
;
CHECK_SECRET
(
dheSecret
)
;
CHECK_SECRET
(
earlyTrafficSecret
)
;
CHECK_SECRET
(
hsTrafficSecret
)
;
return
PR_TRUE
;
}
PRBool
sslint_DamageTrafficSecret
(
PRFileDesc
*
fd
size_t
offset
)
{
unsigned
char
data
[
32
]
=
{
0
}
;
PK11SymKey
*
*
keyPtr
;
PK11SlotInfo
*
slot
=
PK11_GetInternalSlot
(
)
;
SECItem
key_item
=
{
siBuffer
data
sizeof
(
data
)
}
;
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
if
(
!
ss
)
{
return
PR_FALSE
;
}
if
(
!
slot
)
{
return
PR_FALSE
;
}
keyPtr
=
(
PK11SymKey
*
*
)
(
(
char
*
)
&
ss
-
>
ssl3
.
hs
+
offset
)
;
if
(
!
keyPtr
)
return
PR_FALSE
;
PK11_FreeSymKey
(
*
keyPtr
)
;
*
keyPtr
=
PK11_ImportSymKey
(
slot
CKM_NSS_HKDF_SHA256
PK11_OriginUnwrap
CKA_DERIVE
&
key_item
NULL
)
;
PK11_FreeSlot
(
slot
)
;
if
(
!
*
keyPtr
)
return
PR_FALSE
;
return
PR_TRUE
;
}
PRBool
SSLInt_DamageHsTrafficSecret
(
PRFileDesc
*
fd
)
{
return
sslint_DamageTrafficSecret
(
fd
offsetof
(
SSL3HandshakeState
hsTrafficSecret
)
)
;
}
PRBool
SSLInt_DamageEarlyTrafficSecret
(
PRFileDesc
*
fd
)
{
return
sslint_DamageTrafficSecret
(
fd
offsetof
(
SSL3HandshakeState
earlyTrafficSecret
)
)
;
}
SECStatus
SSLInt_Set0RttAlpn
(
PRFileDesc
*
fd
PRUint8
*
data
unsigned
int
len
)
{
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
if
(
!
ss
)
{
return
SECFailure
;
}
ss
-
>
ssl3
.
nextProtoState
=
SSL_NEXT_PROTO_EARLY_VALUE
;
if
(
ss
-
>
ssl3
.
nextProto
.
data
)
{
SECITEM_FreeItem
(
&
ss
-
>
ssl3
.
nextProto
PR_FALSE
)
;
}
if
(
!
SECITEM_AllocItem
(
NULL
&
ss
-
>
ssl3
.
nextProto
len
)
)
return
SECFailure
;
PORT_Memcpy
(
ss
-
>
ssl3
.
nextProto
.
data
data
len
)
;
return
SECSuccess
;
}
