#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
random
>
#
include
<
vector
>
#
include
"
tls_parser
.
h
"
using
namespace
nss_test
;
static
size_t
gExtraHeaderBytes
=
0
;
class
Record
{
public
:
static
std
:
:
unique_ptr
<
Record
>
Create
(
const
uint8_t
*
data
size_t
size
size_t
remaining
)
{
return
std
:
:
unique_ptr
<
Record
>
(
new
Record
(
data
size
remaining
)
)
;
}
void
insert_before
(
const
std
:
:
unique_ptr
<
Record
>
&
other
)
{
assert
(
data_
&
&
size_
>
0
)
;
std
:
:
vector
<
uint8_t
>
buf
(
size_
)
;
memcpy
(
buf
.
data
(
)
data_
size_
)
;
uint8_t
*
dest
=
const_cast
<
uint8_t
*
>
(
other
-
>
data
(
)
)
;
memmove
(
dest
+
size_
other
-
>
data
(
)
other
-
>
size
(
)
+
other
-
>
remaining
(
)
)
;
memcpy
(
dest
buf
.
data
(
)
size_
)
;
}
void
truncate
(
size_t
length
)
{
assert
(
length
>
=
5
+
gExtraHeaderBytes
)
;
uint8_t
*
dest
=
const_cast
<
uint8_t
*
>
(
data_
)
;
size_t
l
=
length
-
(
5
+
gExtraHeaderBytes
)
;
dest
[
3
]
=
(
l
>
>
8
)
&
0xff
;
dest
[
4
]
=
l
&
0xff
;
memmove
(
dest
+
length
data_
+
size_
remaining_
)
;
}
void
drop
(
)
{
uint8_t
*
dest
=
const_cast
<
uint8_t
*
>
(
data_
)
;
memmove
(
dest
data_
+
size_
remaining_
)
;
}
const
uint8_t
*
data
(
)
{
return
data_
;
}
size_t
remaining
(
)
{
return
remaining_
;
}
size_t
size
(
)
{
return
size_
;
}
private
:
Record
(
const
uint8_t
*
data
size_t
size
size_t
remaining
)
:
data_
(
data
)
remaining_
(
remaining
)
size_
(
size
)
{
}
const
uint8_t
*
data_
;
size_t
remaining_
;
size_t
size_
;
}
;
std
:
:
vector
<
std
:
:
unique_ptr
<
Record
>
>
ParseRecords
(
const
uint8_t
*
data
size_t
size
)
{
std
:
:
vector
<
std
:
:
unique_ptr
<
Record
>
>
records
;
TlsParser
parser
(
data
size
)
;
while
(
parser
.
remaining
(
)
)
{
size_t
offset
=
parser
.
consumed
(
)
;
if
(
!
parser
.
Skip
(
3
+
gExtraHeaderBytes
)
)
{
break
;
}
DataBuffer
fragment
;
if
(
!
parser
.
ReadVariable
(
&
fragment
2
)
)
{
break
;
}
records
.
push_back
(
Record
:
:
Create
(
data
+
offset
fragment
.
len
(
)
+
5
+
gExtraHeaderBytes
parser
.
remaining
(
)
)
)
;
}
return
records
;
}
namespace
TlsMutators
{
void
SetIsDTLS
(
)
{
gExtraHeaderBytes
=
8
;
}
size_t
DropRecord
(
uint8_t
*
data
size_t
size
size_t
max_size
unsigned
int
seed
)
{
std
:
:
mt19937
rng
(
seed
)
;
auto
records
=
ParseRecords
(
data
size
)
;
if
(
records
.
empty
(
)
)
{
return
0
;
}
std
:
:
uniform_int_distribution
<
size_t
>
dist
(
0
records
.
size
(
)
-
1
)
;
auto
&
rec
=
records
.
at
(
dist
(
rng
)
)
;
rec
-
>
drop
(
)
;
return
size
-
rec
-
>
size
(
)
;
}
size_t
ShuffleRecords
(
uint8_t
*
data
size_t
size
size_t
max_size
unsigned
int
seed
)
{
std
:
:
mt19937
rng
(
seed
)
;
auto
records
=
ParseRecords
(
data
size
)
;
if
(
records
.
empty
(
)
)
{
return
0
;
}
std
:
:
vector
<
uint8_t
>
buf
(
size
)
;
memcpy
(
buf
.
data
(
)
data
size
)
;
uint8_t
*
dest
=
const_cast
<
uint8_t
*
>
(
records
.
at
(
0
)
-
>
data
(
)
)
;
std
:
:
shuffle
(
records
.
begin
(
)
records
.
end
(
)
rng
)
;
for
(
auto
&
rec
:
records
)
{
memcpy
(
dest
buf
.
data
(
)
+
(
rec
-
>
data
(
)
-
data
)
rec
-
>
size
(
)
)
;
dest
+
=
rec
-
>
size
(
)
;
}
return
size
;
}
size_t
DuplicateRecord
(
uint8_t
*
data
size_t
size
size_t
max_size
unsigned
int
seed
)
{
std
:
:
mt19937
rng
(
seed
)
;
const
auto
records
=
ParseRecords
(
data
size
)
;
if
(
records
.
empty
(
)
)
{
return
0
;
}
std
:
:
uniform_int_distribution
<
size_t
>
dist
(
0
records
.
size
(
)
-
1
)
;
auto
&
rec
=
records
.
at
(
dist
(
rng
)
)
;
if
(
size
+
rec
-
>
size
(
)
>
max_size
)
{
return
0
;
}
rec
-
>
insert_before
(
records
.
at
(
dist
(
rng
)
)
)
;
return
size
+
rec
-
>
size
(
)
;
}
size_t
TruncateRecord
(
uint8_t
*
data
size_t
size
size_t
max_size
unsigned
int
seed
)
{
std
:
:
mt19937
rng
(
seed
)
;
const
auto
records
=
ParseRecords
(
data
size
)
;
if
(
records
.
empty
(
)
)
{
return
0
;
}
std
:
:
uniform_int_distribution
<
size_t
>
dist
(
0
records
.
size
(
)
-
1
)
;
auto
&
rec
=
records
.
at
(
dist
(
rng
)
)
;
if
(
rec
-
>
size
(
)
<
=
5
+
gExtraHeaderBytes
)
{
return
0
;
}
std
:
:
uniform_int_distribution
<
size_t
>
dist2
(
5
+
gExtraHeaderBytes
rec
-
>
size
(
)
-
1
)
;
size_t
new_length
=
dist2
(
rng
)
;
rec
-
>
truncate
(
new_length
)
;
return
size
+
new_length
-
rec
-
>
size
(
)
;
}
size_t
FragmentRecord
(
uint8_t
*
data
size_t
size
size_t
max_size
unsigned
int
seed
)
{
std
:
:
mt19937
rng
(
seed
)
;
if
(
gExtraHeaderBytes
>
0
)
{
return
0
;
}
if
(
size
+
5
>
max_size
)
{
return
0
;
}
const
auto
records
=
ParseRecords
(
data
size
)
;
if
(
records
.
empty
(
)
)
{
return
0
;
}
std
:
:
uniform_int_distribution
<
size_t
>
rand_record
(
0
records
.
size
(
)
-
1
)
;
auto
&
rec
=
records
.
at
(
rand_record
(
rng
)
)
;
uint8_t
*
rdata
=
const_cast
<
uint8_t
*
>
(
rec
-
>
data
(
)
)
;
size_t
length
=
rec
-
>
size
(
)
;
size_t
content_length
=
length
-
5
;
if
(
content_length
<
2
)
{
return
0
;
}
std
:
:
uniform_int_distribution
<
size_t
>
rand_size
(
1
content_length
-
1
)
;
size_t
first_length
=
rand_size
(
rng
)
;
size_t
second_length
=
content_length
-
first_length
;
rdata
[
3
]
=
(
first_length
>
>
8
)
&
0xff
;
rdata
[
4
]
=
first_length
&
0xff
;
uint8_t
*
second_record
=
rdata
+
5
+
first_length
;
memmove
(
second_record
+
5
second_record
rec
-
>
remaining
(
)
+
content_length
-
first_length
)
;
memcpy
(
second_record
rdata
3
)
;
second_record
[
3
]
=
(
second_length
>
>
8
)
&
0xff
;
second_record
[
4
]
=
second_length
&
0xff
;
return
size
+
5
;
}
size_t
CrossOver
(
const
uint8_t
*
data1
size_t
size1
const
uint8_t
*
data2
size_t
size2
uint8_t
*
out
size_t
max_out_size
unsigned
int
seed
)
{
std
:
:
mt19937
rng
(
seed
)
;
auto
records1
=
ParseRecords
(
data1
size1
)
;
if
(
records1
.
empty
(
)
)
{
return
0
;
}
{
auto
records2
=
ParseRecords
(
data2
size2
)
;
if
(
records2
.
empty
(
)
)
{
return
0
;
}
std
:
:
move
(
records2
.
begin
(
)
records2
.
end
(
)
std
:
:
back_inserter
(
records1
)
)
;
}
std
:
:
shuffle
(
records1
.
begin
(
)
records1
.
end
(
)
rng
)
;
size_t
total
=
0
;
for
(
auto
&
rec
:
records1
)
{
size_t
length
=
rec
-
>
size
(
)
;
if
(
total
+
length
>
max_out_size
)
{
break
;
}
memcpy
(
out
+
total
rec
-
>
data
(
)
length
)
;
total
+
=
length
;
}
return
total
;
}
}
