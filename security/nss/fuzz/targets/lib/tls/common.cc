#
include
"
common
.
h
"
#
include
<
cassert
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
"
prio
.
h
"
#
include
"
secport
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslexp
.
h
"
static
PRTime
FixedTime
(
void
*
)
{
return
1234
;
}
namespace
TlsCommon
{
void
FixTime
(
PRFileDesc
*
fd
)
{
SECStatus
rv
=
SSL_SetTimeFunc
(
fd
FixedTime
nullptr
)
;
assert
(
rv
=
=
SECSuccess
)
;
}
void
EnableAllProtocolVersions
(
)
{
SSLVersionRange
supported
;
SECStatus
rv
;
rv
=
SSL_VersionRangeGetSupported
(
ssl_variant_stream
&
supported
)
;
assert
(
rv
=
=
SECSuccess
)
;
rv
=
SSL_VersionRangeSetDefault
(
ssl_variant_stream
&
supported
)
;
assert
(
rv
=
=
SECSuccess
)
;
rv
=
SSL_VersionRangeGetSupported
(
ssl_variant_datagram
&
supported
)
;
assert
(
rv
=
=
SECSuccess
)
;
rv
=
SSL_VersionRangeSetDefault
(
ssl_variant_datagram
&
supported
)
;
assert
(
rv
=
=
SECSuccess
)
;
}
void
EnableAllCipherSuites
(
PRFileDesc
*
fd
)
{
for
(
uint16_t
i
=
0
;
i
<
SSL_NumImplementedCiphers
;
+
+
i
)
{
SECStatus
rv
=
SSL_CipherPrefSet
(
fd
SSL_ImplementedCiphers
[
i
]
true
)
;
assert
(
rv
=
=
SECSuccess
)
;
}
}
void
DoHandshake
(
PRFileDesc
*
fd
bool
isServer
)
{
SECStatus
rv
=
SSL_ResetHandshake
(
fd
isServer
)
;
assert
(
rv
=
=
SECSuccess
)
;
do
{
rv
=
SSL_ForceHandshake
(
fd
)
;
}
while
(
rv
!
=
SECSuccess
&
&
PR_GetError
(
)
=
=
PR_WOULD_BLOCK_ERROR
)
;
if
(
rv
=
=
SECSuccess
)
{
uint8_t
block
[
1024
]
;
int32_t
nb
;
while
(
(
nb
=
PR_Read
(
fd
block
sizeof
(
block
)
)
)
>
0
)
{
PR_Write
(
fd
block
nb
)
;
}
}
}
SECStatus
DummyCompressionEncode
(
const
SECItem
*
input
SECItem
*
output
)
{
if
(
!
input
|
|
!
input
-
>
data
|
|
input
-
>
len
=
=
0
|
|
!
output
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
SECITEM_CopyItem
(
nullptr
output
input
)
;
return
SECSuccess
;
}
SECStatus
DummyCompressionDecode
(
const
SECItem
*
input
unsigned
char
*
output
size_t
outputLen
size_t
*
usedLen
)
{
if
(
!
input
|
|
!
input
-
>
data
|
|
input
-
>
len
=
=
0
|
|
!
output
|
|
outputLen
=
=
0
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
input
-
>
len
>
outputLen
)
{
PORT_SetError
(
SEC_ERROR_BAD_DATA
)
;
return
SECFailure
;
}
PORT_Memcpy
(
output
input
-
>
data
input
-
>
len
)
;
*
usedLen
=
input
-
>
len
;
return
SECSuccess
;
}
}
