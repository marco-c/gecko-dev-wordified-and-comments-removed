#
include
"
pkcs11i
.
h
"
#
include
"
blapi
.
h
"
#
include
"
secerr
.
h
"
#
include
"
softoken
.
h
"
#
define
VALID_CK_BOOL
(
x
)
(
(
x
)
=
=
CK_TRUE
|
|
(
x
)
=
=
CK_FALSE
)
#
define
IS_COUNTER
(
_mech
)
(
(
_mech
)
=
=
CKM_SP800_108_COUNTER_KDF
|
|
(
_mech
)
=
=
CKM_NSS_SP800_108_COUNTER_KDF_DERIVE_DATA
)
#
define
DOES_DERIVE_DATA
(
_mech
)
(
(
_mech
)
=
=
CKM_NSS_SP800_108_COUNTER_KDF_DERIVE_DATA
|
|
(
_mech
)
=
=
CKM_NSS_SP800_108_FEEDBACK_KDF_DERIVE_DATA
|
|
(
_mech
)
=
=
CKM_NSS_SP800_108_DOUBLE_PIPELINE_KDF_DERIVE_DATA
)
static
CK_RV
kbkdf_LoadParameters
(
CK_MECHANISM_TYPE
mech
CK_MECHANISM_PTR
pMechanism
CK_SP800_108_KDF_PARAMS_PTR
kdf_params
CK_BYTE_PTR
*
initial_value
CK_ULONG_PTR
initial_value_length
)
{
PR_ASSERT
(
pMechanism
!
=
NULL
&
&
kdf_params
!
=
NULL
&
&
initial_value
!
=
NULL
&
&
initial_value_length
!
=
NULL
)
;
CK_SP800_108_KDF_PARAMS_PTR
in_params
;
CK_SP800_108_FEEDBACK_KDF_PARAMS_PTR
feedback_params
;
if
(
mech
=
=
CKM_SP800_108_FEEDBACK_KDF
|
|
mech
=
=
CKM_NSS_SP800_108_FEEDBACK_KDF_DERIVE_DATA
)
{
if
(
pMechanism
-
>
ulParameterLen
!
=
sizeof
(
CK_SP800_108_FEEDBACK_KDF_PARAMS
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
feedback_params
=
(
CK_SP800_108_FEEDBACK_KDF_PARAMS
*
)
pMechanism
-
>
pParameter
;
if
(
feedback_params
-
>
pIV
=
=
NULL
&
&
feedback_params
-
>
ulIVLen
>
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
kdf_params
-
>
prfType
=
feedback_params
-
>
prfType
;
kdf_params
-
>
ulNumberOfDataParams
=
feedback_params
-
>
ulNumberOfDataParams
;
kdf_params
-
>
pDataParams
=
feedback_params
-
>
pDataParams
;
kdf_params
-
>
ulAdditionalDerivedKeys
=
feedback_params
-
>
ulAdditionalDerivedKeys
;
kdf_params
-
>
pAdditionalDerivedKeys
=
feedback_params
-
>
pAdditionalDerivedKeys
;
*
initial_value
=
feedback_params
-
>
pIV
;
*
initial_value_length
=
feedback_params
-
>
ulIVLen
;
}
else
{
if
(
pMechanism
-
>
ulParameterLen
!
=
sizeof
(
CK_SP800_108_KDF_PARAMS
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
in_params
=
(
CK_SP800_108_KDF_PARAMS
*
)
pMechanism
-
>
pParameter
;
(
*
kdf_params
)
=
*
in_params
;
}
return
CKR_OK
;
}
static
CK_RV
kbkdf_ValidateParameter
(
CK_MECHANISM_TYPE
mech
const
CK_PRF_DATA_PARAM
*
data
)
{
if
(
(
data
-
>
pValue
=
=
NULL
)
!
=
(
data
-
>
ulValueLen
=
=
0
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
switch
(
data
-
>
type
)
{
case
CK_SP800_108_ITERATION_VARIABLE
:
case
CK_SP800_108_OPTIONAL_COUNTER
:
{
if
(
data
-
>
type
=
=
CK_SP800_108_ITERATION_VARIABLE
&
&
!
IS_COUNTER
(
mech
)
)
{
if
(
data
-
>
pValue
!
=
NULL
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
return
CKR_OK
;
}
if
(
data
-
>
ulValueLen
!
=
sizeof
(
CK_SP800_108_COUNTER_FORMAT
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
CK_SP800_108_COUNTER_FORMAT_PTR
param
=
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
data
-
>
pValue
;
if
(
!
VALID_CK_BOOL
(
param
-
>
bLittleEndian
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
(
param
-
>
ulWidthInBits
%
8
)
!
=
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
param
-
>
ulWidthInBits
>
32
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
break
;
}
case
CK_SP800_108_DKM_LENGTH
:
{
if
(
data
-
>
ulValueLen
!
=
sizeof
(
CK_SP800_108_DKM_LENGTH_FORMAT
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
param
=
(
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
)
data
-
>
pValue
;
if
(
param
-
>
dkmLengthMethod
!
=
CK_SP800_108_DKM_LENGTH_SUM_OF_KEYS
&
&
param
-
>
dkmLengthMethod
!
=
CK_SP800_108_DKM_LENGTH_SUM_OF_SEGMENTS
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
!
VALID_CK_BOOL
(
param
-
>
bLittleEndian
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
(
param
-
>
ulWidthInBits
%
8
)
!
=
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
param
-
>
ulWidthInBits
>
64
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
break
;
}
case
CK_SP800_108_BYTE_ARRAY
:
break
;
default
:
return
CKR_MECHANISM_PARAM_INVALID
;
}
return
CKR_OK
;
}
static
CK_RV
kbkdf_ValidateDerived
(
CK_DERIVED_KEY_PTR
key
)
{
CK_KEY_TYPE
keyType
=
CKK_GENERIC_SECRET
;
PRUint64
keySize
=
0
;
if
(
key
-
>
phKey
=
=
NULL
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
(
key
-
>
ulAttributeCount
=
=
0
)
!
=
(
key
-
>
pTemplate
=
=
NULL
)
)
{
goto
failure
;
}
for
(
size_t
offset
=
0
;
offset
<
key
-
>
ulAttributeCount
;
offset
+
+
)
{
CK_ATTRIBUTE_PTR
template
=
key
-
>
pTemplate
+
offset
;
if
(
template
-
>
type
=
=
CKA_KEY_TYPE
)
{
if
(
template
-
>
ulValueLen
!
=
sizeof
(
CK_KEY_TYPE
)
)
{
goto
failure
;
}
keyType
=
*
(
CK_KEY_TYPE
*
)
template
-
>
pValue
;
}
else
if
(
template
-
>
type
=
=
CKA_VALUE_LEN
)
{
if
(
template
-
>
ulValueLen
!
=
sizeof
(
CK_ULONG
)
)
{
goto
failure
;
}
keySize
=
*
(
CK_ULONG
*
)
template
-
>
pValue
;
}
}
if
(
keySize
=
=
0
)
{
keySize
=
sftk_MapKeySize
(
keyType
)
;
}
if
(
keySize
=
=
0
|
|
keySize
>
=
(
1ull
<
<
32ull
)
)
{
goto
failure
;
}
return
CKR_OK
;
failure
:
*
(
key
-
>
phKey
)
=
CK_INVALID_HANDLE
;
return
CKR_MECHANISM_PARAM_INVALID
;
}
static
PRBool
kbkdf_ValidPRF
(
CK_SP800_108_PRF_TYPE
prf
)
{
switch
(
prf
)
{
case
CKM_AES_CMAC
:
return
PR_TRUE
;
case
CKM_SHA_1_HMAC
:
case
CKM_SHA224_HMAC
:
case
CKM_SHA256_HMAC
:
case
CKM_SHA384_HMAC
:
case
CKM_SHA512_HMAC
:
case
CKM_SHA3_224_HMAC
:
case
CKM_SHA3_256_HMAC
:
case
CKM_SHA3_384_HMAC
:
case
CKM_SHA3_512_HMAC
:
return
sftk_HMACMechanismToHash
(
prf
)
!
=
HASH_AlgNULL
;
}
return
PR_FALSE
;
}
static
CK_RV
kbkdf_ValidateParameters
(
CK_MECHANISM_TYPE
mech
const
CK_SP800_108_KDF_PARAMS
*
params
CK_ULONG
keySize
)
{
CK_RV
ret
=
CKR_MECHANISM_PARAM_INVALID
;
int
param_type_count
[
5
]
=
{
0
0
0
0
0
}
;
size_t
offset
=
0
;
if
(
!
kbkdf_ValidPRF
(
params
-
>
prfType
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
params
-
>
pDataParams
=
=
NULL
)
{
return
CKR_HOST_MEMORY
;
}
for
(
offset
=
0
;
offset
<
params
-
>
ulNumberOfDataParams
;
offset
+
+
)
{
ret
=
kbkdf_ValidateParameter
(
mech
params
-
>
pDataParams
+
offset
)
;
if
(
ret
!
=
CKR_OK
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
PR_ASSERT
(
params
-
>
pDataParams
[
offset
]
.
type
<
sizeof
(
param_type_count
)
/
sizeof
(
param_type_count
[
0
]
)
)
;
param_type_count
[
params
-
>
pDataParams
[
offset
]
.
type
]
+
=
1
;
}
if
(
IS_COUNTER
(
mech
)
)
{
if
(
param_type_count
[
CK_SP800_108_ITERATION_VARIABLE
]
=
=
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
param_type_count
[
CK_SP800_108_OPTIONAL_COUNTER
]
!
=
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
}
if
(
(
params
-
>
ulAdditionalDerivedKeys
=
=
0
)
!
=
(
params
-
>
pAdditionalDerivedKeys
=
=
NULL
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
for
(
offset
=
0
;
offset
<
params
-
>
ulAdditionalDerivedKeys
;
offset
+
+
)
{
ret
=
kbkdf_ValidateDerived
(
params
-
>
pAdditionalDerivedKeys
+
offset
)
;
if
(
ret
!
=
CKR_OK
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
}
if
(
keySize
=
=
0
|
|
(
(
PRUint64
)
keySize
)
>
=
(
1ull
<
<
32ull
)
)
{
return
CKR_KEY_SIZE_RANGE
;
}
return
CKR_OK
;
}
static
CK_VOID_PTR
kbkdf_FindParameter
(
const
CK_SP800_108_KDF_PARAMS
*
params
CK_PRF_DATA_TYPE
type
)
{
for
(
size_t
offset
=
0
;
offset
<
params
-
>
ulNumberOfDataParams
;
offset
+
+
)
{
if
(
params
-
>
pDataParams
[
offset
]
.
type
=
=
type
)
{
return
params
-
>
pDataParams
[
offset
]
.
pValue
;
}
}
return
NULL
;
}
size_t
kbkdf_IncrementBuffer
(
size_t
cur_offset
size_t
consumed
size_t
prf_length
)
{
return
cur_offset
+
PR_ROUNDUP
(
consumed
prf_length
)
;
}
CK_ULONG
kbkdf_GetDerivedKeySize
(
CK_DERIVED_KEY_PTR
derived_key
)
{
CK_KEY_TYPE
keyType
=
CKK_GENERIC_SECRET
;
CK_ULONG
keySize
=
0
;
for
(
size_t
offset
=
0
;
offset
<
derived_key
-
>
ulAttributeCount
;
offset
+
+
)
{
CK_ATTRIBUTE_PTR
template
=
derived_key
-
>
pTemplate
+
offset
;
if
(
template
-
>
type
=
=
CKA_KEY_TYPE
)
{
keyType
=
*
(
CK_KEY_TYPE
*
)
template
-
>
pValue
;
}
else
if
(
template
-
>
type
=
=
CKA_VALUE_LEN
)
{
keySize
=
*
(
CK_ULONG
*
)
template
-
>
pValue
;
}
}
if
(
keySize
>
0
)
{
return
keySize
;
}
return
sftk_MapKeySize
(
keyType
)
;
}
static
CK_RV
kbkdf_CalculateLength
(
const
CK_SP800_108_KDF_PARAMS
*
params
sftk_MACCtx
*
ctx
CK_ULONG
ret_key_size
PRUint64
*
output_bitlen
size_t
*
buffer_length
)
{
if
(
params
-
>
ulAdditionalDerivedKeys
=
=
0
)
{
*
output_bitlen
=
ret_key_size
;
*
buffer_length
=
ret_key_size
;
}
else
{
size_t
offset
=
0
;
CK_ULONG
derived_size
=
0
;
*
output_bitlen
=
ret_key_size
;
*
buffer_length
=
kbkdf_IncrementBuffer
(
0
ret_key_size
ctx
-
>
mac_size
)
;
for
(
;
offset
<
params
-
>
ulAdditionalDerivedKeys
-
1
;
offset
+
+
)
{
derived_size
=
kbkdf_GetDerivedKeySize
(
params
-
>
pAdditionalDerivedKeys
+
offset
)
;
*
output_bitlen
+
=
derived_size
;
*
buffer_length
=
kbkdf_IncrementBuffer
(
*
buffer_length
derived_size
ctx
-
>
mac_size
)
;
}
derived_size
=
kbkdf_GetDerivedKeySize
(
params
-
>
pAdditionalDerivedKeys
+
offset
)
;
*
output_bitlen
+
=
derived_size
;
*
buffer_length
=
kbkdf_IncrementBuffer
(
*
buffer_length
derived_size
ctx
-
>
mac_size
)
;
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
dkm_param
=
kbkdf_FindParameter
(
params
CK_SP800_108_DKM_LENGTH
)
;
if
(
dkm_param
!
=
NULL
)
{
if
(
dkm_param
-
>
dkmLengthMethod
=
=
CK_SP800_108_DKM_LENGTH_SUM_OF_SEGMENTS
)
{
*
output_bitlen
=
*
buffer_length
;
}
}
}
*
output_bitlen
*
=
8
;
return
CKR_OK
;
}
static
CK_RV
kbkdf_CalculateIterations
(
CK_MECHANISM_TYPE
mech
const
CK_SP800_108_KDF_PARAMS
*
params
sftk_MACCtx
*
ctx
size_t
buffer_length
PRUint32
*
num_iterations
)
{
CK_SP800_108_COUNTER_FORMAT_PTR
param_ptr
=
NULL
;
PRUint64
iteration_count
;
PRUint64
r
=
32
;
iteration_count
=
buffer_length
+
(
ctx
-
>
mac_size
-
1
)
;
iteration_count
=
iteration_count
/
ctx
-
>
mac_size
;
if
(
IS_COUNTER
(
mech
)
)
{
param_ptr
=
kbkdf_FindParameter
(
params
CK_SP800_108_ITERATION_VARIABLE
)
;
PR_ASSERT
(
param_ptr
!
=
NULL
)
;
r
=
(
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
param_ptr
)
-
>
ulWidthInBits
;
}
else
{
param_ptr
=
kbkdf_FindParameter
(
params
CK_SP800_108_COUNTER
)
;
if
(
param_ptr
!
=
NULL
)
{
r
=
(
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
param_ptr
)
-
>
ulWidthInBits
;
}
}
if
(
iteration_count
>
=
(
1ull
<
<
r
)
|
|
r
>
32
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
*
num_iterations
=
(
PRUint32
)
iteration_count
;
return
CKR_OK
;
}
static
CK_RV
kbkdf_AddParameters
(
CK_MECHANISM_TYPE
mech
sftk_MACCtx
*
ctx
const
CK_SP800_108_KDF_PARAMS
*
params
PRUint32
counter
PRUint64
length
const
unsigned
char
*
chaining_prf
size_t
chaining_prf_len
CK_PRF_DATA_TYPE
exclude
)
{
size_t
offset
=
0
;
CK_RV
ret
=
CKR_OK
;
for
(
offset
=
0
;
offset
<
params
-
>
ulNumberOfDataParams
;
offset
+
+
)
{
CK_PRF_DATA_PARAM_PTR
param
=
params
-
>
pDataParams
+
offset
;
if
(
param
-
>
type
=
=
exclude
)
{
continue
;
}
switch
(
param
-
>
type
)
{
case
CK_SP800_108_ITERATION_VARIABLE
:
{
if
(
IS_COUNTER
(
mech
)
)
{
CK_SP800_108_COUNTER_FORMAT_PTR
counter_format
=
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
param
-
>
pValue
;
CK_BYTE
buffer
[
sizeof
(
PRUint64
)
]
;
CK_ULONG
num_bytes
;
sftk_EncodeInteger
(
counter
counter_format
-
>
ulWidthInBits
counter_format
-
>
bLittleEndian
buffer
&
num_bytes
)
;
ret
=
sftk_MAC_Update
(
ctx
buffer
num_bytes
)
;
}
else
{
ret
=
sftk_MAC_Update
(
ctx
chaining_prf
chaining_prf_len
)
;
}
break
;
}
case
CK_SP800_108_COUNTER
:
{
PR_ASSERT
(
!
IS_COUNTER
(
mech
)
)
;
CK_SP800_108_COUNTER_FORMAT_PTR
counter_format
=
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
param
-
>
pValue
;
CK_BYTE
buffer
[
sizeof
(
PRUint64
)
]
;
CK_ULONG
num_bytes
;
sftk_EncodeInteger
(
counter
counter_format
-
>
ulWidthInBits
counter_format
-
>
bLittleEndian
buffer
&
num_bytes
)
;
ret
=
sftk_MAC_Update
(
ctx
buffer
num_bytes
)
;
break
;
}
case
CK_SP800_108_BYTE_ARRAY
:
ret
=
sftk_MAC_Update
(
ctx
(
CK_BYTE_PTR
)
param
-
>
pValue
param
-
>
ulValueLen
)
;
break
;
case
CK_SP800_108_DKM_LENGTH
:
{
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
length_format
=
(
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
)
param
-
>
pValue
;
CK_BYTE
buffer
[
sizeof
(
PRUint64
)
]
;
CK_ULONG
num_bytes
;
sftk_EncodeInteger
(
length
length_format
-
>
ulWidthInBits
length_format
-
>
bLittleEndian
buffer
&
num_bytes
)
;
ret
=
sftk_MAC_Update
(
ctx
buffer
num_bytes
)
;
break
;
}
default
:
PR_ASSERT
(
PR_FALSE
)
;
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
}
return
CKR_OK
;
}
CK_RV
kbkdf_SaveKey
(
SFTKObject
*
key
unsigned
char
*
key_buffer
unsigned
int
key_len
)
{
return
sftk_forceAttribute
(
key
CKA_VALUE
key_buffer
key_len
)
;
}
CK_RV
kbkdf_CreateKey
(
CK_MECHANISM_TYPE
kdf_mech
CK_SESSION_HANDLE
hSession
CK_DERIVED_KEY_PTR
derived_key
SFTKObject
*
*
ret_key
)
{
CK_RV
ret
=
CKR_HOST_MEMORY
;
SFTKObject
*
key
=
NULL
;
SFTKSlot
*
slot
=
sftk_SlotFromSessionHandle
(
hSession
)
;
size_t
offset
=
0
;
PR_ASSERT
(
slot
!
=
NULL
)
;
PR_ASSERT
(
ret_key
!
=
NULL
)
;
PR_ASSERT
(
derived_key
!
=
NULL
)
;
PR_ASSERT
(
derived_key
-
>
phKey
!
=
NULL
)
;
if
(
slot
=
=
NULL
)
{
return
CKR_SESSION_HANDLE_INVALID
;
}
key
=
sftk_NewObject
(
slot
)
;
if
(
key
=
=
NULL
)
{
return
CKR_HOST_MEMORY
;
}
for
(
offset
=
0
;
offset
<
derived_key
-
>
ulAttributeCount
;
offset
+
+
)
{
ret
=
sftk_AddAttributeType
(
key
sftk_attr_expand
(
derived_key
-
>
pTemplate
+
offset
)
)
;
if
(
ret
!
=
CKR_OK
)
{
sftk_FreeObject
(
key
)
;
return
ret
;
}
}
CK_OBJECT_CLASS
classType
=
CKO_SECRET_KEY
;
if
(
DOES_DERIVE_DATA
(
kdf_mech
)
)
{
classType
=
CKO_DATA
;
}
ret
=
sftk_forceAttribute
(
key
CKA_CLASS
&
classType
sizeof
(
classType
)
)
;
if
(
ret
!
=
CKR_OK
)
{
sftk_FreeObject
(
key
)
;
return
ret
;
}
*
ret_key
=
key
;
return
CKR_OK
;
}
CK_RV
kbkdf_FinalizeKey
(
CK_SESSION_HANDLE
hSession
CK_DERIVED_KEY_PTR
derived_key
SFTKObject
*
key
)
{
CK_RV
ret
=
CKR_HOST_MEMORY
;
SFTKSession
*
session
=
NULL
;
PR_ASSERT
(
derived_key
!
=
NULL
&
&
key
!
=
NULL
)
;
SFTKSessionObject
*
sessionForKey
=
sftk_narrowToSessionObject
(
key
)
;
PR_ASSERT
(
sessionForKey
!
=
NULL
)
;
sessionForKey
-
>
wasDerived
=
PR_TRUE
;
session
=
sftk_SessionFromHandle
(
hSession
)
;
PR_ASSERT
(
session
!
=
NULL
)
;
ret
=
sftk_handleObject
(
key
session
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
done
;
}
*
(
derived_key
-
>
phKey
)
=
key
-
>
handle
;
done
:
sftk_FreeObject
(
key
)
;
if
(
session
)
{
sftk_FreeSession
(
session
)
;
}
return
ret
;
}
CK_RV
kbkdf_SaveKeys
(
CK_MECHANISM_TYPE
mech
CK_SESSION_HANDLE
hSession
CK_SP800_108_KDF_PARAMS_PTR
params
unsigned
char
*
output_buffer
size_t
buffer_len
size_t
prf_length
SFTKObject
*
ret_key
CK_ULONG
ret_key_size
)
{
CK_RV
ret
;
size_t
key_offset
=
0
;
size_t
buffer_offset
=
0
;
PR_ASSERT
(
output_buffer
!
=
NULL
&
&
buffer_len
>
0
&
&
ret_key
!
=
NULL
)
;
ret
=
kbkdf_SaveKey
(
ret_key
output_buffer
+
buffer_offset
ret_key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
buffer_offset
=
kbkdf_IncrementBuffer
(
buffer_offset
ret_key_size
prf_length
)
;
if
(
params
-
>
ulAdditionalDerivedKeys
>
0
)
{
for
(
key_offset
=
0
;
key_offset
<
params
-
>
ulAdditionalDerivedKeys
;
key_offset
+
+
)
{
CK_DERIVED_KEY_PTR
derived_key
=
params
-
>
pAdditionalDerivedKeys
+
key_offset
;
SFTKObject
*
key_obj
=
NULL
;
size_t
key_size
=
kbkdf_GetDerivedKeySize
(
derived_key
)
;
ret
=
kbkdf_CreateKey
(
mech
hSession
derived_key
&
key_obj
)
;
if
(
ret
!
=
CKR_OK
)
{
*
(
derived_key
-
>
phKey
)
=
CK_INVALID_HANDLE
;
return
ret
;
}
ret
=
kbkdf_SaveKey
(
key_obj
output_buffer
+
buffer_offset
key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
sftk_FreeObject
(
key_obj
)
;
*
(
derived_key
-
>
phKey
)
=
CK_INVALID_HANDLE
;
return
ret
;
}
buffer_offset
=
kbkdf_IncrementBuffer
(
buffer_offset
key_size
prf_length
)
;
ret
=
kbkdf_FinalizeKey
(
hSession
derived_key
key_obj
)
;
if
(
ret
!
=
CKR_OK
)
{
*
(
derived_key
-
>
phKey
)
=
CK_INVALID_HANDLE
;
return
ret
;
}
}
}
return
CKR_OK
;
}
static
CK_RV
kbkdf_CounterRaw
(
const
CK_SP800_108_KDF_PARAMS
*
params
sftk_MACCtx
*
ctx
unsigned
char
*
ret_buffer
size_t
buffer_length
PRUint64
output_bitlen
)
{
CK_RV
ret
=
CKR_OK
;
PRUint32
counter
;
PRUint32
num_iterations
;
size_t
buffer_offset
=
0
;
size_t
block_size
=
ctx
-
>
mac_size
;
ret
=
kbkdf_CalculateIterations
(
CKM_SP800_108_COUNTER_KDF
params
ctx
buffer_length
&
num_iterations
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
for
(
counter
=
1
;
counter
<
=
num_iterations
;
counter
+
+
)
{
if
(
counter
=
=
num_iterations
)
{
block_size
=
buffer_length
-
buffer_offset
;
PR_ASSERT
(
block_size
<
=
ctx
-
>
mac_size
)
;
}
ret
=
kbkdf_AddParameters
(
CKM_SP800_108_COUNTER_KDF
ctx
params
counter
output_bitlen
NULL
0
0
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
ret
=
sftk_MAC_End
(
ctx
ret_buffer
+
buffer_offset
NULL
block_size
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
buffer_offset
+
=
block_size
;
if
(
counter
<
num_iterations
)
{
ret
=
sftk_MAC_Reset
(
ctx
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
}
}
return
CKR_OK
;
}
static
CK_RV
kbkdf_FeedbackRaw
(
const
CK_SP800_108_KDF_PARAMS
*
params
const
unsigned
char
*
initial_value
CK_ULONG
initial_value_length
sftk_MACCtx
*
ctx
unsigned
char
*
ret_buffer
size_t
buffer_length
PRUint64
output_bitlen
)
{
CK_RV
ret
=
CKR_OK
;
PRUint32
counter
;
PRUint32
num_iterations
;
size_t
buffer_offset
=
0
;
size_t
block_size
=
ctx
-
>
mac_size
;
unsigned
char
*
chaining_value
=
(
unsigned
char
*
)
initial_value
;
size_t
chaining_length
=
initial_value_length
;
ret
=
kbkdf_CalculateIterations
(
CKM_SP800_108_FEEDBACK_KDF
params
ctx
buffer_length
&
num_iterations
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
for
(
counter
=
1
;
counter
<
=
num_iterations
;
counter
+
+
)
{
if
(
counter
=
=
num_iterations
)
{
block_size
=
buffer_length
-
buffer_offset
;
PR_ASSERT
(
block_size
<
=
ctx
-
>
mac_size
)
;
}
ret
=
kbkdf_AddParameters
(
CKM_SP800_108_FEEDBACK_KDF
ctx
params
counter
output_bitlen
chaining_value
chaining_length
0
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
if
(
counter
=
=
1
)
{
chaining_value
=
PORT_ZNewArray
(
unsigned
char
ctx
-
>
mac_size
)
;
chaining_length
=
ctx
-
>
mac_size
;
if
(
chaining_value
=
=
NULL
)
{
ret
=
CKR_HOST_MEMORY
;
goto
finish
;
}
}
ret
=
sftk_MAC_End
(
ctx
chaining_value
NULL
chaining_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
PORT_Memcpy
(
ret_buffer
+
buffer_offset
chaining_value
block_size
)
;
buffer_offset
+
=
block_size
;
if
(
counter
<
num_iterations
)
{
ret
=
sftk_MAC_Reset
(
ctx
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
}
}
finish
:
if
(
chaining_value
!
=
initial_value
&
&
chaining_value
!
=
NULL
)
{
PORT_ZFree
(
chaining_value
chaining_length
)
;
}
return
ret
;
}
static
CK_RV
kbkdf_PipelineRaw
(
const
CK_SP800_108_KDF_PARAMS
*
params
sftk_MACCtx
*
ctx
unsigned
char
*
ret_buffer
size_t
buffer_length
PRUint64
output_bitlen
)
{
CK_RV
ret
=
CKR_OK
;
PRUint32
counter
;
PRUint32
num_iterations
;
size_t
buffer_offset
=
0
;
size_t
block_size
=
ctx
-
>
mac_size
;
unsigned
char
*
chaining_value
=
NULL
;
size_t
chaining_length
=
0
;
ret
=
kbkdf_CalculateIterations
(
CKM_SP800_108_DOUBLE_PIPELINE_KDF
params
ctx
buffer_length
&
num_iterations
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
for
(
counter
=
1
;
counter
<
=
num_iterations
;
counter
+
+
)
{
if
(
counter
=
=
num_iterations
)
{
block_size
=
buffer_length
-
buffer_offset
;
PR_ASSERT
(
block_size
<
=
ctx
-
>
mac_size
)
;
}
if
(
counter
=
=
1
)
{
ret
=
kbkdf_AddParameters
(
CKM_SP800_108_DOUBLE_PIPELINE_KDF
ctx
params
counter
output_bitlen
NULL
0
CK_SP800_108_OPTIONAL_COUNTER
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
chaining_value
=
PORT_ZNewArray
(
unsigned
char
ctx
-
>
mac_size
)
;
chaining_length
=
ctx
-
>
mac_size
;
if
(
chaining_value
=
=
NULL
)
{
ret
=
CKR_HOST_MEMORY
;
goto
finish
;
}
}
else
{
ret
=
sftk_MAC_Update
(
ctx
chaining_value
chaining_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
}
ret
=
sftk_MAC_End
(
ctx
chaining_value
NULL
chaining_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
sftk_MAC_Reset
(
ctx
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
kbkdf_AddParameters
(
CKM_SP800_108_FEEDBACK_KDF
ctx
params
counter
output_bitlen
chaining_value
chaining_length
0
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
sftk_MAC_End
(
ctx
ret_buffer
+
buffer_offset
NULL
block_size
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
buffer_offset
+
=
block_size
;
if
(
counter
<
num_iterations
)
{
ret
=
sftk_MAC_Reset
(
ctx
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
}
}
finish
:
PORT_ZFree
(
chaining_value
chaining_length
)
;
return
ret
;
}
static
CK_RV
kbkdf_RawDispatch
(
CK_MECHANISM_TYPE
mech
const
CK_SP800_108_KDF_PARAMS
*
kdf_params
const
CK_BYTE
*
initial_value
CK_ULONG
initial_value_length
SFTKObject
*
prf_key
const
unsigned
char
*
prf_key_bytes
unsigned
int
prf_key_length
unsigned
char
*
*
out_key_bytes
size_t
*
out_key_length
unsigned
int
*
mac_size
CK_ULONG
ret_key_size
)
{
CK_RV
ret
;
sftk_MACCtx
ctx
=
{
0
}
;
unsigned
char
*
output_buffer
=
NULL
;
size_t
buffer_length
=
0
;
PRUint64
output_bitlen
=
0
;
ret
=
kbkdf_ValidateParameters
(
mech
kdf_params
ret_key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
if
(
prf_key
)
{
ret
=
sftk_MAC_Init
(
&
ctx
kdf_params
-
>
prfType
prf_key
)
;
}
else
{
ret
=
sftk_MAC_InitRaw
(
&
ctx
kdf_params
-
>
prfType
prf_key_bytes
prf_key_length
PR_TRUE
)
;
}
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
kbkdf_CalculateLength
(
kdf_params
&
ctx
ret_key_size
&
output_bitlen
&
buffer_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
output_buffer
=
PORT_ZNewArray
(
unsigned
char
buffer_length
)
;
if
(
output_buffer
=
=
NULL
)
{
ret
=
CKR_HOST_MEMORY
;
goto
finish
;
}
switch
(
mech
)
{
case
CKM_NSS_SP800_108_COUNTER_KDF_DERIVE_DATA
:
case
CKM_SP800_108_COUNTER_KDF
:
ret
=
kbkdf_CounterRaw
(
kdf_params
&
ctx
output_buffer
buffer_length
output_bitlen
)
;
break
;
case
CKM_NSS_SP800_108_FEEDBACK_KDF_DERIVE_DATA
:
case
CKM_SP800_108_FEEDBACK_KDF
:
ret
=
kbkdf_FeedbackRaw
(
kdf_params
initial_value
initial_value_length
&
ctx
output_buffer
buffer_length
output_bitlen
)
;
break
;
case
CKM_NSS_SP800_108_DOUBLE_PIPELINE_KDF_DERIVE_DATA
:
case
CKM_SP800_108_DOUBLE_PIPELINE_KDF
:
ret
=
kbkdf_PipelineRaw
(
kdf_params
&
ctx
output_buffer
buffer_length
output_bitlen
)
;
break
;
default
:
PR_ASSERT
(
PR_FALSE
)
;
ret
=
CKR_FUNCTION_FAILED
;
}
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
*
out_key_bytes
=
output_buffer
;
*
out_key_length
=
buffer_length
;
*
mac_size
=
ctx
.
mac_size
;
output_buffer
=
NULL
;
finish
:
PORT_ZFree
(
output_buffer
buffer_length
)
;
sftk_MAC_DestroyContext
(
&
ctx
PR_FALSE
)
;
return
ret
;
}
CK_RV
kbkdf_Dispatch
(
CK_MECHANISM_TYPE
mech
CK_SESSION_HANDLE
hSession
CK_MECHANISM_PTR
pMechanism
SFTKObject
*
prf_key
SFTKObject
*
ret_key
CK_ULONG
ret_key_size
)
{
CK_RV
ret
;
PR_ASSERT
(
pMechanism
!
=
NULL
&
&
prf_key
!
=
NULL
&
&
ret_key
!
=
NULL
)
;
if
(
pMechanism
-
>
pParameter
=
=
NULL
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
CK_SP800_108_KDF_PARAMS
kdf_params
=
{
0
}
;
CK_BYTE_PTR
initial_value
=
NULL
;
CK_ULONG
initial_value_length
=
0
;
unsigned
char
*
output_buffer
=
NULL
;
size_t
buffer_length
=
0
;
unsigned
int
mac_size
=
0
;
ret
=
kbkdf_LoadParameters
(
mech
pMechanism
&
kdf_params
&
initial_value
&
initial_value_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
kbkdf_RawDispatch
(
mech
&
kdf_params
initial_value
initial_value_length
prf_key
NULL
0
&
output_buffer
&
buffer_length
&
mac_size
ret_key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
kbkdf_SaveKeys
(
mech
hSession
&
kdf_params
output_buffer
buffer_length
mac_size
ret_key
ret_key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
finish
:
PORT_ZFree
(
output_buffer
buffer_length
)
;
return
ret
;
}
struct
sftk_SP800_Test_struct
{
CK_MECHANISM_TYPE
mech
;
CK_SP800_108_KDF_PARAMS
kdf_params
;
unsigned
int
expected_mac_size
;
unsigned
int
ret_key_length
;
const
unsigned
char
expected_key_bytes
[
64
]
;
}
;
static
const
CK_SP800_108_COUNTER_FORMAT
counter_32
=
{
0
32
}
;
static
const
CK_PRF_DATA_PARAM
counter_32_data
=
{
CK_SP800_108_ITERATION_VARIABLE
(
CK_VOID_PTR
)
&
counter_32
sizeof
(
counter_32
)
}
;
#
ifdef
NSS_FULL_POST
static
const
CK_SP800_108_COUNTER_FORMAT
counter_16
=
{
0
16
}
;
static
const
CK_PRF_DATA_PARAM
counter_16_data
=
{
CK_SP800_108_ITERATION_VARIABLE
(
CK_VOID_PTR
)
&
counter_16
sizeof
(
counter_16
)
}
;
static
const
CK_PRF_DATA_PARAM
counter_null_data
=
{
CK_SP800_108_ITERATION_VARIABLE
NULL
0
}
;
#
endif
static
const
struct
sftk_SP800_Test_struct
sftk_SP800_Tests
[
]
=
{
#
ifdef
NSS_FULL_POST
{
CKM_SP800_108_COUNTER_KDF
{
CKM_AES_CMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_16_data
0
NULL
}
16
64
{
0x7b
0x1c
0xe7
0xf3
0x14
0x67
0x15
0xdd
0xde
0x0c
0x09
0x46
0x3f
0x47
0x7b
0xa6
0xb8
0xba
0x40
0x07
0x7c
0xe3
0x19
0x53
0x26
0xac
0x4c
0x2e
0x2b
0x37
0x41
0xe4
0x1b
0x01
0x3f
0x2f
0x2d
0x16
0x95
0xee
0xeb
0x7e
0x72
0x7d
0xa4
0xab
0x2e
0x67
0x1d
0xef
0x6f
0xa2
0xc6
0xee
0x3c
0xcf
0xef
0x88
0xfd
0x5c
0x1d
0x7b
0xa0
0x5a
}
}
{
CKM_SP800_108_COUNTER_KDF
{
CKM_SHA384_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_32_data
0
NULL
}
48
64
{
0xe6
0x62
0xa4
0x32
0x5c
0xe4
0xc2
0x28
0x73
0x8a
0x5d
0x94
0xe7
0x05
0xe0
0x5a
0x71
0x61
0xb2
0x3c
0x51
0x28
0x03
0x1d
0xa7
0xf5
0x10
0x83
0x34
0xdb
0x11
0x73
0x92
0xa6
0x79
0x74
0x81
0x5d
0x22
0x7e
0x8d
0xf2
0x59
0x14
0x56
0x60
0xcf
0xb2
0xb3
0xfd
0x46
0xfd
0x9b
0x74
0xfe
0x4a
0x09
0x30
0x4a
0xdf
0x07
0x43
0xfe
0x85
}
}
{
CKM_SP800_108_COUNTER_KDF
{
CKM_SHA512_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_32_data
0
NULL
}
64
64
{
0xb0
0x78
0x36
0xe1
0x15
0xd6
0xf0
0xac
0x68
0x7b
0x42
0xd3
0xb6
0x82
0x51
0xad
0x95
0x0a
0x69
0x88
0x84
0xc2
0x2e
0x07
0x34
0x62
0x8d
0x42
0x72
0x0f
0x22
0xe6
0xd5
0x7f
0x80
0x15
0xe6
0x84
0x00
0x65
0xef
0x64
0x77
0x29
0xd6
0x3b
0xc7
0x9a
0x15
0x6d
0x36
0xf3
0x96
0xc9
0x14
0x3f
0x2d
0x4a
0x7c
0xdb
0xc3
0x6c
0x3d
0x6a
}
}
{
CKM_SP800_108_FEEDBACK_KDF
{
CKM_AES_CMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_null_data
0
NULL
}
16
64
{
0xc0
0xa0
0x23
0x96
0x16
0x4d
0xd6
0xbd
0x2a
0x75
0x8e
0x72
0xf5
0xc3
0xa0
0xb8
0x78
0x83
0x15
0x21
0x34
0xd3
0xd8
0x71
0xc9
0xe7
0x4b
0x20
0xb7
0x65
0x5b
0x13
0xbc
0x85
0x54
0xe3
0xb6
0xee
0x73
0xd5
0xf2
0xa0
0x94
0x1a
0x79
0x66
0x3b
0x1e
0x67
0x3e
0x69
0xa4
0x12
0x40
0xa9
0xda
0x8d
0x14
0xb1
0xce
0xf1
0x4b
0x79
0x4e
}
}
{
CKM_SP800_108_FEEDBACK_KDF
{
CKM_SHA256_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_null_data
0
NULL
}
32
64
{
0x99
0x9b
0x08
0x79
0x14
0x2e
0x58
0x34
0xd7
0x92
0xa7
0x7e
0x7f
0xc2
0xf0
0x34
0xa3
0x4e
0x33
0xf0
0x63
0x95
0x2d
0xad
0xbf
0x3b
0xcb
0x6d
0x4e
0x07
0xd9
0xe9
0xbd
0xbd
0x77
0x54
0xe1
0xa3
0x36
0x26
0xcd
0xb1
0xf9
0x2d
0x80
0x68
0xa2
0x01
0x4e
0xbf
0x35
0xec
0x65
0xae
0xfd
0x71
0xa6
0xd7
0x62
0x26
0x2c
0x3f
0x73
0x63
}
}
{
CKM_SP800_108_FEEDBACK_KDF
{
CKM_SHA384_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_null_data
0
NULL
}
48
64
{
0xc8
0x7a
0xf8
0xd9
0x6b
0x90
0x82
0x35
0xea
0xf5
0x2c
0x8f
0xce
0xaa
0x3b
0xa5
0x68
0xd3
0x7f
0xae
0x31
0x93
0xe6
0x69
0x0c
0xd1
0x74
0x7f
0x8f
0xc2
0xe2
0x33
0x93
0x45
0x23
0xba
0xb3
0x73
0xc9
0x2c
0xd6
0xd2
0x10
0x16
0xe9
0x9f
0x9e
0xe8
0xc1
0x0e
0x29
0x95
0x3d
0x16
0x68
0x24
0x40
0x4d
0x40
0x21
0x41
0xa6
0xc8
0xdb
}
}
{
CKM_SP800_108_FEEDBACK_KDF
{
CKM_SHA512_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_null_data
0
NULL
}
64
64
{
0x81
0x39
0x12
0xc2
0xf9
0x31
0x24
0x7c
0x71
0x12
0x97
0x08
0x82
0x76
0x83
0x55
0x8c
0x82
0xf3
0x09
0xd6
0x1b
0x7a
0xa2
0x6e
0x71
0x6b
0xad
0x46
0x57
0x60
0x89
0x38
0xcf
0x63
0xfa
0xf4
0x38
0x27
0xef
0xf0
0xaf
0x75
0x4e
0xc2
0xe0
0x31
0xdb
0x59
0x7d
0x19
0xc9
0x6d
0xbb
0xed
0x95
0xaf
0x3e
0xd8
0x33
0x76
0xab
0xec
0xfa
}
}
{
CKM_SP800_108_DOUBLE_PIPELINE_KDF
{
CKM_AES_CMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_null_data
0
NULL
}
16
64
{
0x3e
0xa8
0xbf
0x77
0x84
0x90
0xb0
0x3a
0x89
0x16
0x32
0x01
0x92
0xd3
0x1f
0x1b
0xc1
0x06
0xc5
0x32
0x62
0x03
0x50
0x16
0x3b
0xb9
0xa7
0xdc
0xb5
0x68
0x6a
0xbb
0xbb
0x7d
0x63
0x69
0x24
0x6e
0x09
0xd6
0x6f
0x80
0x57
0x65
0xc5
0x62
0x33
0x96
0x69
0xe6
0xab
0x65
0x36
0xd0
0xe2
0x5c
0xd7
0xbd
0xe4
0x68
0x13
0xd6
0xb1
0x46
}
}
{
CKM_SP800_108_DOUBLE_PIPELINE_KDF
{
CKM_SHA256_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_null_data
0
NULL
}
32
64
{
0xeb
0x28
0xd9
0x2c
0x19
0x33
0xb9
0x2a
0xf9
0xac
0x85
0xbd
0xf4
0xdb
0xfa
0x88
0x73
0xf4
0x36
0x08
0xdb
0xfe
0x13
0xd1
0x5a
0xec
0x7b
0x68
0x13
0x53
0xb3
0xd1
0x31
0xf2
0x83
0xae
0x9f
0x75
0x47
0xb6
0x6d
0x3c
0x20
0x16
0x47
0x9c
0x27
0x66
0xec
0xa9
0xdf
0x0c
0xda
0x2a
0xf9
0xf4
0x55
0x74
0xde
0x9d
0x3f
0xe3
0x5e
0x14
}
}
{
CKM_SP800_108_DOUBLE_PIPELINE_KDF
{
CKM_SHA384_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_null_data
0
NULL
}
48
64
{
0xa5
0xca
0x32
0x40
0x00
0x93
0xb2
0xcc
0x78
0x3c
0xa6
0xc4
0xaf
0xa8
0xb3
0xd0
0xa4
0x6b
0xb5
0x31
0x35
0x87
0x33
0xa2
0x6a
0x6b
0xe1
0xff
0xea
0x1d
0x6e
0x9e
0x0b
0xde
0x8b
0x92
0x15
0xd6
0x56
0x2f
0xb6
0x1a
0xd7
0xd2
0x01
0x3e
0x28
0x2e
0xfa
0x84
0x3c
0xc0
0xe8
0xbe
0x94
0xc0
0x06
0xbd
0xbf
0x87
0x1f
0xb8
0x64
0xc2
}
}
{
CKM_SP800_108_DOUBLE_PIPELINE_KDF
{
CKM_SHA512_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_null_data
0
NULL
}
64
64
{
0x3f
0xd9
0x4e
0x80
0x58
0x21
0xc8
0xea
0x22
0x17
0xcf
0x7d
0xce
0xfd
0xec
0x03
0xb9
0xe4
0xa2
0xf7
0xc0
0xf1
0x68
0x81
0x53
0x71
0xb7
0x42
0x14
0x4e
0x5b
0x09
0x05
0x31
0xb9
0x27
0x18
0x2d
0x23
0xf8
0x9c
0x3d
0x4e
0xd0
0xdd
0xf3
0x1e
0x4b
0xf2
0xf9
0x1a
0x5d
0x00
0x66
0x22
0x83
0xae
0x3c
0x53
0xd2
0x54
0x4b
0x06
0x4c
}
}
#
endif
{
CKM_SP800_108_COUNTER_KDF
{
CKM_SHA256_HMAC
1
(
CK_PRF_DATA_PARAM_PTR
)
&
counter_32_data
0
NULL
}
32
64
{
0xfb
0x2b
0xb5
0xde
0xce
0x5a
0x2b
0xdc
0x25
0x8f
0x54
0x17
0x4b
0x5a
0xa7
0x90
0x64
0x36
0xeb
0x43
0x1f
0x1d
0xf9
0x23
0xb2
0x22
0x29
0xa0
0xfa
0x2e
0x21
0xb6
0xb7
0xfb
0x27
0x0a
0x1c
0xa6
0x58
0x43
0xa1
0x16
0x44
0x29
0x4b
0x1c
0xb3
0x72
0xd5
0x98
0x9d
0x27
0xd5
0x75
0x25
0xbf
0x23
0x61
0x40
0x48
0xbb
0x0b
0x49
0x8e
}
}
}
;
SECStatus
sftk_fips_SP800_108_PowerUpSelfTests
(
void
)
{
int
i
;
CK_RV
crv
;
const
unsigned
char
prf_key
[
]
=
{
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x20
0x21
0x22
0x23
0x24
0x25
0x26
0x27
0x28
0x30
0x31
0x32
0x33
0x34
0x35
0x36
0x37
0x38
0x40
0x41
0x42
0x43
0x44
0x45
0x46
0x47
0x48
0x50
0x51
0x52
0x53
0x54
0x55
0x56
0x57
0x58
0x60
0x61
0x62
0x63
0x64
0x65
0x66
0x67
0x68
0x70
0x71
0x72
0x73
0x74
0x75
0x76
0x77
0x78
}
;
for
(
i
=
0
;
i
<
PR_ARRAY_SIZE
(
sftk_SP800_Tests
)
;
i
+
+
)
{
const
struct
sftk_SP800_Test_struct
*
test
=
&
sftk_SP800_Tests
[
i
]
;
unsigned
char
*
output_buffer
;
size_t
buffer_length
;
unsigned
int
mac_size
;
crv
=
kbkdf_RawDispatch
(
test
-
>
mech
&
test
-
>
kdf_params
prf_key
test
-
>
expected_mac_size
NULL
prf_key
test
-
>
expected_mac_size
&
output_buffer
&
buffer_length
&
mac_size
test
-
>
ret_key_length
)
;
if
(
crv
!
=
CKR_OK
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
if
(
(
mac_size
!
=
test
-
>
expected_mac_size
)
|
|
(
buffer_length
!
=
test
-
>
ret_key_length
)
|
|
(
output_buffer
=
=
NULL
)
|
|
(
PORT_Memcmp
(
output_buffer
test
-
>
expected_key_bytes
buffer_length
)
!
=
0
)
)
{
PORT_ZFree
(
output_buffer
buffer_length
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
PORT_ZFree
(
output_buffer
buffer_length
)
;
}
return
SECSuccess
;
}
