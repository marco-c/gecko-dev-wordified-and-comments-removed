#
include
"
pkcs11i
.
h
"
#
include
"
blapi
.
h
"
#
include
"
secerr
.
h
"
#
include
"
softoken
.
h
"
#
define
VALID_CK_BOOL
(
x
)
(
(
x
)
=
=
CK_TRUE
|
|
(
x
)
=
=
CK_FALSE
)
#
define
IS_COUNTER
(
_mech
)
(
(
_mech
)
=
=
CKM_SP800_108_COUNTER_KDF
|
|
(
_mech
)
=
=
CKM_NSS_SP800_108_COUNTER_KDF_DERIVE_DATA
)
#
define
DOES_DERIVE_DATA
(
_mech
)
(
(
_mech
)
=
=
CKM_NSS_SP800_108_COUNTER_KDF_DERIVE_DATA
|
|
(
_mech
)
=
=
CKM_NSS_SP800_108_FEEDBACK_KDF_DERIVE_DATA
|
|
(
_mech
)
=
=
CKM_NSS_SP800_108_DOUBLE_PIPELINE_KDF_DERIVE_DATA
)
static
CK_RV
kbkdf_LoadParameters
(
CK_MECHANISM_TYPE
mech
CK_MECHANISM_PTR
pMechanism
CK_SP800_108_KDF_PARAMS_PTR
kdf_params
CK_BYTE_PTR
*
initial_value
CK_ULONG_PTR
initial_value_length
)
{
PR_ASSERT
(
pMechanism
!
=
NULL
&
&
kdf_params
!
=
NULL
&
&
initial_value
!
=
NULL
&
&
initial_value_length
!
=
NULL
)
;
CK_SP800_108_KDF_PARAMS_PTR
in_params
;
CK_SP800_108_FEEDBACK_KDF_PARAMS_PTR
feedback_params
;
if
(
mech
=
=
CKM_SP800_108_FEEDBACK_KDF
|
|
mech
=
=
CKM_NSS_SP800_108_FEEDBACK_KDF_DERIVE_DATA
)
{
if
(
pMechanism
-
>
ulParameterLen
!
=
sizeof
(
CK_SP800_108_FEEDBACK_KDF_PARAMS
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
feedback_params
=
(
CK_SP800_108_FEEDBACK_KDF_PARAMS
*
)
pMechanism
-
>
pParameter
;
if
(
feedback_params
-
>
pIV
=
=
NULL
&
&
feedback_params
-
>
ulIVLen
>
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
kdf_params
-
>
prfType
=
feedback_params
-
>
prfType
;
kdf_params
-
>
ulNumberOfDataParams
=
feedback_params
-
>
ulNumberOfDataParams
;
kdf_params
-
>
pDataParams
=
feedback_params
-
>
pDataParams
;
kdf_params
-
>
ulAdditionalDerivedKeys
=
feedback_params
-
>
ulAdditionalDerivedKeys
;
kdf_params
-
>
pAdditionalDerivedKeys
=
feedback_params
-
>
pAdditionalDerivedKeys
;
*
initial_value
=
feedback_params
-
>
pIV
;
*
initial_value_length
=
feedback_params
-
>
ulIVLen
;
}
else
{
if
(
pMechanism
-
>
ulParameterLen
!
=
sizeof
(
CK_SP800_108_KDF_PARAMS
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
in_params
=
(
CK_SP800_108_KDF_PARAMS
*
)
pMechanism
-
>
pParameter
;
(
*
kdf_params
)
=
*
in_params
;
}
return
CKR_OK
;
}
static
CK_RV
kbkdf_ValidateParameter
(
CK_MECHANISM_TYPE
mech
CK_PRF_DATA_PARAM_PTR
data
)
{
if
(
(
data
-
>
pValue
=
=
NULL
)
!
=
(
data
-
>
ulValueLen
=
=
0
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
switch
(
data
-
>
type
)
{
case
CK_SP800_108_ITERATION_VARIABLE
:
case
CK_SP800_108_OPTIONAL_COUNTER
:
{
if
(
data
-
>
type
=
=
CK_SP800_108_ITERATION_VARIABLE
&
&
!
IS_COUNTER
(
mech
)
)
{
if
(
data
-
>
pValue
!
=
NULL
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
return
CKR_OK
;
}
if
(
data
-
>
ulValueLen
!
=
sizeof
(
CK_SP800_108_COUNTER_FORMAT
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
CK_SP800_108_COUNTER_FORMAT_PTR
param
=
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
data
-
>
pValue
;
if
(
!
VALID_CK_BOOL
(
param
-
>
bLittleEndian
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
(
param
-
>
ulWidthInBits
%
8
)
!
=
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
param
-
>
ulWidthInBits
>
32
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
break
;
}
case
CK_SP800_108_DKM_LENGTH
:
{
if
(
data
-
>
ulValueLen
!
=
sizeof
(
CK_SP800_108_DKM_LENGTH_FORMAT
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
param
=
(
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
)
data
-
>
pValue
;
if
(
param
-
>
dkmLengthMethod
!
=
CK_SP800_108_DKM_LENGTH_SUM_OF_KEYS
&
&
param
-
>
dkmLengthMethod
!
=
CK_SP800_108_DKM_LENGTH_SUM_OF_SEGMENTS
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
!
VALID_CK_BOOL
(
param
-
>
bLittleEndian
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
(
param
-
>
ulWidthInBits
%
8
)
!
=
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
param
-
>
ulWidthInBits
>
64
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
break
;
}
case
CK_SP800_108_BYTE_ARRAY
:
break
;
default
:
return
CKR_MECHANISM_PARAM_INVALID
;
}
return
CKR_OK
;
}
static
CK_RV
kbkdf_ValidateDerived
(
CK_DERIVED_KEY_PTR
key
)
{
CK_KEY_TYPE
keyType
=
CKK_GENERIC_SECRET
;
PRUint64
keySize
=
0
;
if
(
key
-
>
phKey
=
=
NULL
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
(
key
-
>
ulAttributeCount
=
=
0
)
!
=
(
key
-
>
pTemplate
=
=
NULL
)
)
{
goto
failure
;
}
for
(
size_t
offset
=
0
;
offset
<
key
-
>
ulAttributeCount
;
offset
+
+
)
{
CK_ATTRIBUTE_PTR
template
=
key
-
>
pTemplate
+
offset
;
if
(
template
-
>
type
=
=
CKA_KEY_TYPE
)
{
if
(
template
-
>
ulValueLen
!
=
sizeof
(
CK_KEY_TYPE
)
)
{
goto
failure
;
}
keyType
=
*
(
CK_KEY_TYPE
*
)
template
-
>
pValue
;
}
else
if
(
template
-
>
type
=
=
CKA_VALUE_LEN
)
{
if
(
template
-
>
ulValueLen
!
=
sizeof
(
CK_ULONG
)
)
{
goto
failure
;
}
keySize
=
*
(
CK_ULONG
*
)
template
-
>
pValue
;
}
}
if
(
keySize
=
=
0
)
{
keySize
=
sftk_MapKeySize
(
keyType
)
;
}
if
(
keySize
=
=
0
|
|
keySize
>
=
(
1ull
<
<
32ull
)
)
{
goto
failure
;
}
return
CKR_OK
;
failure
:
*
(
key
-
>
phKey
)
=
CK_INVALID_HANDLE
;
return
CKR_MECHANISM_PARAM_INVALID
;
}
static
CK_RV
kbkdf_ValidateParameters
(
CK_MECHANISM_TYPE
mech
CK_SP800_108_KDF_PARAMS_PTR
params
CK_ULONG
keySize
)
{
CK_RV
ret
=
CKR_MECHANISM_PARAM_INVALID
;
int
param_type_count
[
5
]
=
{
0
0
0
0
0
}
;
size_t
offset
=
0
;
if
(
!
(
params
-
>
prfType
=
=
CKM_AES_CMAC
|
|
params
-
>
prfType
!
=
CKM_MD2_HMAC
|
|
params
-
>
prfType
!
=
CKM_MD5_HMAC
|
|
sftk_HMACMechanismToHash
(
params
-
>
prfType
)
!
=
HASH_AlgNULL
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
params
-
>
pDataParams
=
=
NULL
)
{
return
CKR_HOST_MEMORY
;
}
for
(
offset
=
0
;
offset
<
params
-
>
ulNumberOfDataParams
;
offset
+
+
)
{
ret
=
kbkdf_ValidateParameter
(
mech
params
-
>
pDataParams
+
offset
)
;
if
(
ret
!
=
CKR_OK
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
PR_ASSERT
(
params
-
>
pDataParams
[
offset
]
.
type
<
sizeof
(
param_type_count
)
/
sizeof
(
param_type_count
[
0
]
)
)
;
param_type_count
[
params
-
>
pDataParams
[
offset
]
.
type
]
+
=
1
;
}
if
(
IS_COUNTER
(
mech
)
)
{
if
(
param_type_count
[
CK_SP800_108_ITERATION_VARIABLE
]
=
=
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
param_type_count
[
CK_SP800_108_OPTIONAL_COUNTER
]
!
=
0
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
}
if
(
(
params
-
>
ulAdditionalDerivedKeys
=
=
0
)
!
=
(
params
-
>
pAdditionalDerivedKeys
=
=
NULL
)
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
for
(
offset
=
0
;
offset
<
params
-
>
ulAdditionalDerivedKeys
;
offset
+
+
)
{
ret
=
kbkdf_ValidateDerived
(
params
-
>
pAdditionalDerivedKeys
+
offset
)
;
if
(
ret
!
=
CKR_OK
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
}
if
(
keySize
=
=
0
|
|
(
(
PRUint64
)
keySize
)
>
=
(
1ull
<
<
32ull
)
)
{
return
CKR_KEY_SIZE_RANGE
;
}
return
CKR_OK
;
}
static
CK_VOID_PTR
kbkdf_FindParameter
(
CK_SP800_108_KDF_PARAMS_PTR
params
CK_PRF_DATA_TYPE
type
)
{
for
(
size_t
offset
=
0
;
offset
<
params
-
>
ulNumberOfDataParams
;
offset
+
+
)
{
if
(
params
-
>
pDataParams
[
offset
]
.
type
=
=
type
)
{
return
params
-
>
pDataParams
[
offset
]
.
pValue
;
}
}
return
NULL
;
}
size_t
kbkdf_IncrementBuffer
(
size_t
cur_offset
size_t
consumed
size_t
prf_length
)
{
return
cur_offset
+
PR_ROUNDUP
(
consumed
prf_length
)
;
}
CK_ULONG
kbkdf_GetDerivedKeySize
(
CK_DERIVED_KEY_PTR
derived_key
)
{
CK_KEY_TYPE
keyType
=
CKK_GENERIC_SECRET
;
CK_ULONG
keySize
=
0
;
for
(
size_t
offset
=
0
;
offset
<
derived_key
-
>
ulAttributeCount
;
offset
+
+
)
{
CK_ATTRIBUTE_PTR
template
=
derived_key
-
>
pTemplate
+
offset
;
if
(
template
-
>
type
=
=
CKA_KEY_TYPE
)
{
keyType
=
*
(
CK_KEY_TYPE
*
)
template
-
>
pValue
;
}
else
if
(
template
-
>
type
=
=
CKA_VALUE_LEN
)
{
keySize
=
*
(
CK_ULONG
*
)
template
-
>
pValue
;
}
}
if
(
keySize
>
0
)
{
return
keySize
;
}
return
sftk_MapKeySize
(
keyType
)
;
}
static
CK_RV
kbkdf_CalculateLength
(
CK_SP800_108_KDF_PARAMS_PTR
params
sftk_MACCtx
*
ctx
CK_ULONG
ret_key_size
PRUint64
*
output_bitlen
size_t
*
buffer_length
)
{
if
(
params
-
>
ulAdditionalDerivedKeys
=
=
0
)
{
*
output_bitlen
=
ret_key_size
;
*
buffer_length
=
ret_key_size
;
}
else
{
size_t
offset
=
0
;
CK_ULONG
derived_size
=
0
;
*
output_bitlen
=
ret_key_size
;
*
buffer_length
=
kbkdf_IncrementBuffer
(
0
ret_key_size
ctx
-
>
mac_size
)
;
for
(
;
offset
<
params
-
>
ulAdditionalDerivedKeys
-
1
;
offset
+
+
)
{
derived_size
=
kbkdf_GetDerivedKeySize
(
params
-
>
pAdditionalDerivedKeys
+
offset
)
;
*
output_bitlen
+
=
derived_size
;
*
buffer_length
=
kbkdf_IncrementBuffer
(
*
buffer_length
derived_size
ctx
-
>
mac_size
)
;
}
derived_size
=
kbkdf_GetDerivedKeySize
(
params
-
>
pAdditionalDerivedKeys
+
offset
)
;
*
output_bitlen
+
=
derived_size
;
*
buffer_length
=
kbkdf_IncrementBuffer
(
*
buffer_length
derived_size
ctx
-
>
mac_size
)
;
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
dkm_param
=
kbkdf_FindParameter
(
params
CK_SP800_108_DKM_LENGTH
)
;
if
(
dkm_param
!
=
NULL
)
{
if
(
dkm_param
-
>
dkmLengthMethod
=
=
CK_SP800_108_DKM_LENGTH_SUM_OF_SEGMENTS
)
{
*
output_bitlen
=
*
buffer_length
;
}
}
}
*
output_bitlen
*
=
8
;
return
CKR_OK
;
}
static
CK_RV
kbkdf_CalculateIterations
(
CK_MECHANISM_TYPE
mech
CK_SP800_108_KDF_PARAMS_PTR
params
sftk_MACCtx
*
ctx
size_t
buffer_length
PRUint32
*
num_iterations
)
{
CK_SP800_108_COUNTER_FORMAT_PTR
param_ptr
=
NULL
;
PRUint64
iteration_count
;
PRUint64
r
=
32
;
iteration_count
=
buffer_length
+
(
ctx
-
>
mac_size
-
1
)
;
iteration_count
=
iteration_count
/
ctx
-
>
mac_size
;
if
(
IS_COUNTER
(
mech
)
)
{
param_ptr
=
kbkdf_FindParameter
(
params
CK_SP800_108_ITERATION_VARIABLE
)
;
PR_ASSERT
(
param_ptr
!
=
NULL
)
;
r
=
(
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
param_ptr
)
-
>
ulWidthInBits
;
}
else
{
param_ptr
=
kbkdf_FindParameter
(
params
CK_SP800_108_COUNTER
)
;
if
(
param_ptr
!
=
NULL
)
{
r
=
(
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
param_ptr
)
-
>
ulWidthInBits
;
}
}
if
(
iteration_count
>
=
(
1ull
<
<
r
)
|
|
r
>
32
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
*
num_iterations
=
(
PRUint32
)
iteration_count
;
return
CKR_OK
;
}
static
CK_RV
kbkdf_AddParameters
(
CK_MECHANISM_TYPE
mech
sftk_MACCtx
*
ctx
CK_SP800_108_KDF_PARAMS
*
params
PRUint32
counter
PRUint64
length
unsigned
char
*
chaining_prf
size_t
chaining_prf_len
CK_PRF_DATA_TYPE
exclude
)
{
size_t
offset
=
0
;
CK_RV
ret
=
CKR_OK
;
for
(
offset
=
0
;
offset
<
params
-
>
ulNumberOfDataParams
;
offset
+
+
)
{
CK_PRF_DATA_PARAM_PTR
param
=
params
-
>
pDataParams
+
offset
;
if
(
param
-
>
type
=
=
exclude
)
{
continue
;
}
switch
(
param
-
>
type
)
{
case
CK_SP800_108_ITERATION_VARIABLE
:
{
if
(
IS_COUNTER
(
mech
)
)
{
CK_SP800_108_COUNTER_FORMAT_PTR
counter_format
=
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
param
-
>
pValue
;
CK_BYTE
buffer
[
sizeof
(
PRUint64
)
]
;
CK_ULONG
num_bytes
;
sftk_EncodeInteger
(
counter
counter_format
-
>
ulWidthInBits
counter_format
-
>
bLittleEndian
buffer
&
num_bytes
)
;
ret
=
sftk_MAC_Update
(
ctx
buffer
num_bytes
)
;
}
else
{
ret
=
sftk_MAC_Update
(
ctx
chaining_prf
chaining_prf_len
)
;
}
break
;
}
case
CK_SP800_108_COUNTER
:
{
PR_ASSERT
(
!
IS_COUNTER
(
mech
)
)
;
CK_SP800_108_COUNTER_FORMAT_PTR
counter_format
=
(
CK_SP800_108_COUNTER_FORMAT_PTR
)
param
-
>
pValue
;
CK_BYTE
buffer
[
sizeof
(
PRUint64
)
]
;
CK_ULONG
num_bytes
;
sftk_EncodeInteger
(
counter
counter_format
-
>
ulWidthInBits
counter_format
-
>
bLittleEndian
buffer
&
num_bytes
)
;
ret
=
sftk_MAC_Update
(
ctx
buffer
num_bytes
)
;
break
;
}
case
CK_SP800_108_BYTE_ARRAY
:
ret
=
sftk_MAC_Update
(
ctx
(
CK_BYTE_PTR
)
param
-
>
pValue
param
-
>
ulValueLen
)
;
break
;
case
CK_SP800_108_DKM_LENGTH
:
{
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
length_format
=
(
CK_SP800_108_DKM_LENGTH_FORMAT_PTR
)
param
-
>
pValue
;
CK_BYTE
buffer
[
sizeof
(
PRUint64
)
]
;
CK_ULONG
num_bytes
;
sftk_EncodeInteger
(
length
length_format
-
>
ulWidthInBits
length_format
-
>
bLittleEndian
buffer
&
num_bytes
)
;
ret
=
sftk_MAC_Update
(
ctx
buffer
num_bytes
)
;
break
;
}
default
:
PR_ASSERT
(
PR_FALSE
)
;
return
CKR_MECHANISM_PARAM_INVALID
;
}
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
}
return
CKR_OK
;
}
CK_RV
kbkdf_SaveKey
(
SFTKObject
*
key
unsigned
char
*
key_buffer
unsigned
int
key_len
)
{
return
sftk_forceAttribute
(
key
CKA_VALUE
key_buffer
key_len
)
;
}
CK_RV
kbkdf_CreateKey
(
CK_MECHANISM_TYPE
kdf_mech
CK_SESSION_HANDLE
hSession
CK_DERIVED_KEY_PTR
derived_key
SFTKObject
*
*
ret_key
)
{
CK_RV
ret
=
CKR_HOST_MEMORY
;
SFTKObject
*
key
=
NULL
;
SFTKSlot
*
slot
=
sftk_SlotFromSessionHandle
(
hSession
)
;
size_t
offset
=
0
;
PR_ASSERT
(
slot
!
=
NULL
)
;
PR_ASSERT
(
ret_key
!
=
NULL
)
;
PR_ASSERT
(
derived_key
!
=
NULL
)
;
PR_ASSERT
(
derived_key
-
>
phKey
!
=
NULL
)
;
key
=
sftk_NewObject
(
slot
)
;
if
(
key
=
=
NULL
)
{
return
CKR_HOST_MEMORY
;
}
for
(
offset
=
0
;
offset
<
derived_key
-
>
ulAttributeCount
;
offset
+
+
)
{
ret
=
sftk_AddAttributeType
(
key
sftk_attr_expand
(
derived_key
-
>
pTemplate
+
offset
)
)
;
if
(
ret
!
=
CKR_OK
)
{
sftk_FreeObject
(
key
)
;
return
ret
;
}
}
CK_OBJECT_CLASS
classType
=
CKO_SECRET_KEY
;
if
(
DOES_DERIVE_DATA
(
kdf_mech
)
)
{
classType
=
CKO_DATA
;
}
ret
=
sftk_forceAttribute
(
key
CKA_CLASS
&
classType
sizeof
(
classType
)
)
;
if
(
ret
!
=
CKR_OK
)
{
sftk_FreeObject
(
key
)
;
return
ret
;
}
*
ret_key
=
key
;
return
CKR_OK
;
}
CK_RV
kbkdf_FinalizeKey
(
CK_SESSION_HANDLE
hSession
CK_DERIVED_KEY_PTR
derived_key
SFTKObject
*
key
)
{
CK_RV
ret
=
CKR_HOST_MEMORY
;
SFTKSession
*
session
=
NULL
;
PR_ASSERT
(
derived_key
!
=
NULL
&
&
key
!
=
NULL
)
;
SFTKSessionObject
*
sessionForKey
=
sftk_narrowToSessionObject
(
key
)
;
PR_ASSERT
(
sessionForKey
!
=
NULL
)
;
sessionForKey
-
>
wasDerived
=
PR_TRUE
;
session
=
sftk_SessionFromHandle
(
hSession
)
;
PR_ASSERT
(
session
!
=
NULL
)
;
ret
=
sftk_handleObject
(
key
session
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
done
;
}
*
(
derived_key
-
>
phKey
)
=
key
-
>
handle
;
done
:
sftk_FreeObject
(
key
)
;
sftk_FreeSession
(
session
)
;
return
ret
;
}
CK_RV
kbkdf_SaveKeys
(
CK_MECHANISM_TYPE
mech
CK_SESSION_HANDLE
hSession
CK_SP800_108_KDF_PARAMS_PTR
params
unsigned
char
*
output_buffer
size_t
buffer_len
size_t
prf_length
SFTKObject
*
ret_key
CK_ULONG
ret_key_size
)
{
CK_RV
ret
;
size_t
key_offset
=
0
;
size_t
buffer_offset
=
0
;
PR_ASSERT
(
output_buffer
!
=
NULL
&
&
buffer_len
>
0
&
&
ret_key
!
=
NULL
)
;
ret
=
kbkdf_SaveKey
(
ret_key
output_buffer
+
buffer_offset
ret_key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
buffer_offset
=
kbkdf_IncrementBuffer
(
buffer_offset
ret_key_size
prf_length
)
;
if
(
params
-
>
ulAdditionalDerivedKeys
>
0
)
{
for
(
key_offset
=
0
;
key_offset
<
params
-
>
ulAdditionalDerivedKeys
;
key_offset
+
+
)
{
CK_DERIVED_KEY_PTR
derived_key
=
params
-
>
pAdditionalDerivedKeys
+
key_offset
;
SFTKObject
*
key_obj
=
NULL
;
size_t
key_size
=
kbkdf_GetDerivedKeySize
(
derived_key
)
;
ret
=
kbkdf_CreateKey
(
mech
hSession
derived_key
&
key_obj
)
;
if
(
ret
!
=
CKR_OK
)
{
*
(
derived_key
-
>
phKey
)
=
CK_INVALID_HANDLE
;
return
ret
;
}
ret
=
kbkdf_SaveKey
(
key_obj
output_buffer
+
buffer_offset
key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
sftk_FreeObject
(
key_obj
)
;
*
(
derived_key
-
>
phKey
)
=
CK_INVALID_HANDLE
;
return
ret
;
}
buffer_offset
=
kbkdf_IncrementBuffer
(
buffer_offset
key_size
prf_length
)
;
ret
=
kbkdf_FinalizeKey
(
hSession
derived_key
key_obj
)
;
if
(
ret
!
=
CKR_OK
)
{
*
(
derived_key
-
>
phKey
)
=
CK_INVALID_HANDLE
;
return
ret
;
}
}
}
return
CKR_OK
;
}
static
CK_RV
kbkdf_CounterRaw
(
CK_SP800_108_KDF_PARAMS_PTR
params
sftk_MACCtx
*
ctx
unsigned
char
*
ret_buffer
size_t
buffer_length
PRUint64
output_bitlen
)
{
CK_RV
ret
=
CKR_OK
;
PRUint32
counter
;
PRUint32
num_iterations
;
size_t
buffer_offset
=
0
;
size_t
block_size
=
ctx
-
>
mac_size
;
ret
=
kbkdf_CalculateIterations
(
CKM_SP800_108_COUNTER_KDF
params
ctx
buffer_length
&
num_iterations
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
for
(
counter
=
1
;
counter
<
=
num_iterations
;
counter
+
+
)
{
if
(
counter
=
=
num_iterations
)
{
block_size
=
buffer_length
-
buffer_offset
;
PR_ASSERT
(
block_size
<
=
ctx
-
>
mac_size
)
;
}
ret
=
kbkdf_AddParameters
(
CKM_SP800_108_COUNTER_KDF
ctx
params
counter
output_bitlen
NULL
0
0
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
ret
=
sftk_MAC_Finish
(
ctx
ret_buffer
+
buffer_offset
NULL
block_size
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
buffer_offset
+
=
block_size
;
if
(
counter
<
num_iterations
)
{
ret
=
sftk_MAC_Reset
(
ctx
)
;
if
(
ret
!
=
CKR_OK
)
{
return
ret
;
}
}
}
return
CKR_OK
;
}
static
CK_RV
kbkdf_FeedbackRaw
(
CK_SP800_108_KDF_PARAMS_PTR
params
unsigned
char
*
initial_value
CK_ULONG
initial_value_length
sftk_MACCtx
*
ctx
unsigned
char
*
ret_buffer
size_t
buffer_length
PRUint64
output_bitlen
)
{
CK_RV
ret
=
CKR_OK
;
PRUint32
counter
;
PRUint32
num_iterations
;
size_t
buffer_offset
=
0
;
size_t
block_size
=
ctx
-
>
mac_size
;
unsigned
char
*
chaining_value
=
initial_value
;
size_t
chaining_length
=
initial_value_length
;
ret
=
kbkdf_CalculateIterations
(
CKM_SP800_108_FEEDBACK_KDF
params
ctx
buffer_length
&
num_iterations
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
for
(
counter
=
1
;
counter
<
=
num_iterations
;
counter
+
+
)
{
if
(
counter
=
=
num_iterations
)
{
block_size
=
buffer_length
-
buffer_offset
;
PR_ASSERT
(
block_size
<
=
ctx
-
>
mac_size
)
;
}
ret
=
kbkdf_AddParameters
(
CKM_SP800_108_FEEDBACK_KDF
ctx
params
counter
output_bitlen
chaining_value
chaining_length
0
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
if
(
counter
=
=
1
)
{
chaining_value
=
PORT_ZNewArray
(
unsigned
char
ctx
-
>
mac_size
)
;
chaining_length
=
ctx
-
>
mac_size
;
if
(
chaining_value
=
=
NULL
)
{
ret
=
CKR_HOST_MEMORY
;
goto
finish
;
}
}
ret
=
sftk_MAC_Finish
(
ctx
chaining_value
NULL
chaining_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
PORT_Memcpy
(
ret_buffer
+
buffer_offset
chaining_value
block_size
)
;
buffer_offset
+
=
block_size
;
if
(
counter
<
num_iterations
)
{
ret
=
sftk_MAC_Reset
(
ctx
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
}
}
finish
:
if
(
chaining_value
!
=
initial_value
&
&
chaining_value
!
=
NULL
)
{
PORT_ZFree
(
chaining_value
chaining_length
)
;
}
return
ret
;
}
static
CK_RV
kbkdf_PipelineRaw
(
CK_SP800_108_KDF_PARAMS_PTR
params
sftk_MACCtx
*
ctx
unsigned
char
*
ret_buffer
size_t
buffer_length
PRUint64
output_bitlen
)
{
CK_RV
ret
=
CKR_OK
;
PRUint32
counter
;
PRUint32
num_iterations
;
size_t
buffer_offset
=
0
;
size_t
block_size
=
ctx
-
>
mac_size
;
unsigned
char
*
chaining_value
=
NULL
;
size_t
chaining_length
=
0
;
ret
=
kbkdf_CalculateIterations
(
CKM_SP800_108_DOUBLE_PIPELINE_KDF
params
ctx
buffer_length
&
num_iterations
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
for
(
counter
=
1
;
counter
<
=
num_iterations
;
counter
+
+
)
{
if
(
counter
=
=
num_iterations
)
{
block_size
=
buffer_length
-
buffer_offset
;
PR_ASSERT
(
block_size
<
=
ctx
-
>
mac_size
)
;
}
if
(
counter
=
=
1
)
{
ret
=
kbkdf_AddParameters
(
CKM_SP800_108_DOUBLE_PIPELINE_KDF
ctx
params
counter
output_bitlen
NULL
0
CK_SP800_108_OPTIONAL_COUNTER
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
chaining_value
=
PORT_ZNewArray
(
unsigned
char
ctx
-
>
mac_size
)
;
chaining_length
=
ctx
-
>
mac_size
;
if
(
chaining_value
=
=
NULL
)
{
ret
=
CKR_HOST_MEMORY
;
goto
finish
;
}
}
else
{
ret
=
sftk_MAC_Update
(
ctx
chaining_value
chaining_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
}
ret
=
sftk_MAC_Finish
(
ctx
chaining_value
NULL
chaining_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
sftk_MAC_Reset
(
ctx
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
kbkdf_AddParameters
(
CKM_SP800_108_FEEDBACK_KDF
ctx
params
counter
output_bitlen
chaining_value
chaining_length
0
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
sftk_MAC_Finish
(
ctx
ret_buffer
+
buffer_offset
NULL
block_size
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
buffer_offset
+
=
block_size
;
if
(
counter
<
num_iterations
)
{
ret
=
sftk_MAC_Reset
(
ctx
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
}
}
finish
:
PORT_ZFree
(
chaining_value
chaining_length
)
;
return
ret
;
}
CK_RV
kbkdf_Dispatch
(
CK_MECHANISM_TYPE
mech
CK_SESSION_HANDLE
hSession
CK_MECHANISM_PTR
pMechanism
SFTKObject
*
prf_key
SFTKObject
*
ret_key
CK_ULONG
ret_key_size
)
{
CK_RV
ret
;
PR_ASSERT
(
pMechanism
!
=
NULL
&
&
prf_key
!
=
NULL
&
&
ret_key
!
=
NULL
)
;
if
(
pMechanism
-
>
pParameter
=
=
NULL
)
{
return
CKR_MECHANISM_PARAM_INVALID
;
}
CK_SP800_108_KDF_PARAMS
kdf_params
=
{
0
}
;
CK_BYTE_PTR
initial_value
=
NULL
;
CK_ULONG
initial_value_length
=
0
;
sftk_MACCtx
ctx
=
{
0
}
;
unsigned
char
*
output_buffer
=
NULL
;
size_t
buffer_length
=
0
;
PRUint64
output_bitlen
=
0
;
ret
=
kbkdf_LoadParameters
(
mech
pMechanism
&
kdf_params
&
initial_value
&
initial_value_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
kbkdf_ValidateParameters
(
mech
&
kdf_params
ret_key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
sftk_MAC_Init
(
&
ctx
kdf_params
.
prfType
prf_key
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
kbkdf_CalculateLength
(
&
kdf_params
&
ctx
ret_key_size
&
output_bitlen
&
buffer_length
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
output_buffer
=
PORT_ZNewArray
(
unsigned
char
buffer_length
)
;
if
(
output_buffer
=
=
NULL
)
{
ret
=
CKR_HOST_MEMORY
;
goto
finish
;
}
switch
(
mech
)
{
case
CKM_NSS_SP800_108_COUNTER_KDF_DERIVE_DATA
:
case
CKM_SP800_108_COUNTER_KDF
:
ret
=
kbkdf_CounterRaw
(
&
kdf_params
&
ctx
output_buffer
buffer_length
output_bitlen
)
;
break
;
case
CKM_NSS_SP800_108_FEEDBACK_KDF_DERIVE_DATA
:
case
CKM_SP800_108_FEEDBACK_KDF
:
ret
=
kbkdf_FeedbackRaw
(
&
kdf_params
initial_value
initial_value_length
&
ctx
output_buffer
buffer_length
output_bitlen
)
;
break
;
case
CKM_NSS_SP800_108_DOUBLE_PIPELINE_KDF_DERIVE_DATA
:
case
CKM_SP800_108_DOUBLE_PIPELINE_KDF
:
ret
=
kbkdf_PipelineRaw
(
&
kdf_params
&
ctx
output_buffer
buffer_length
output_bitlen
)
;
break
;
default
:
PR_ASSERT
(
PR_FALSE
)
;
ret
=
CKR_FUNCTION_FAILED
;
}
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
ret
=
kbkdf_SaveKeys
(
mech
hSession
&
kdf_params
output_buffer
buffer_length
ctx
.
mac_size
ret_key
ret_key_size
)
;
if
(
ret
!
=
CKR_OK
)
{
goto
finish
;
}
finish
:
PORT_ZFree
(
output_buffer
buffer_length
)
;
sftk_MAC_Destroy
(
&
ctx
PR_FALSE
)
;
return
ret
;
}
