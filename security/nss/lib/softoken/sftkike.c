#
include
"
seccomon
.
h
"
#
include
"
secitem
.
h
"
#
include
"
secport
.
h
"
#
include
"
blapi
.
h
"
#
include
"
pkcs11
.
h
"
#
include
"
pkcs11i
.
h
"
#
include
"
pkcs1sig
.
h
"
#
include
"
lowkeyi
.
h
"
#
include
"
secder
.
h
"
#
include
"
secdig
.
h
"
#
include
"
lowpbe
.
h
"
#
include
"
pkcs11t
.
h
"
#
include
"
secoid
.
h
"
#
include
"
alghmac
.
h
"
#
include
"
softoken
.
h
"
#
include
"
secasn1
.
h
"
#
include
"
secerr
.
h
"
#
include
"
prprf
.
h
"
#
include
"
prenv
.
h
"
typedef
struct
prfContextStr
{
HASH_HashType
hashType
;
const
SECHashObject
*
hashObj
;
HMACContext
*
hmac
;
AESContext
*
aes
;
unsigned
int
nextChar
;
unsigned
char
padBuf
[
AES_BLOCK_SIZE
]
;
unsigned
char
macBuf
[
AES_BLOCK_SIZE
]
;
unsigned
char
k1
[
AES_BLOCK_SIZE
]
;
unsigned
char
k2
[
AES_BLOCK_SIZE
]
;
unsigned
char
k3
[
AES_BLOCK_SIZE
]
;
}
prfContext
;
static
const
unsigned
char
iv_zero
[
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
static
CK_RV
sftk_aes_xcbc_get_keys
(
const
unsigned
char
*
keyValue
unsigned
int
keyLen
unsigned
char
*
k1
unsigned
char
*
k2
unsigned
char
*
k3
)
{
SECStatus
rv
;
CK_RV
crv
;
unsigned
int
tmpLen
;
AESContext
*
aes_context
=
NULL
;
unsigned
char
newKey
[
AES_BLOCK_SIZE
]
;
static
const
unsigned
char
k1data
[
]
=
{
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
}
;
static
const
unsigned
char
k2data
[
]
=
{
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
}
;
static
const
unsigned
char
k3data
[
]
=
{
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
}
;
static
const
unsigned
char
k1_0
[
]
=
{
0xe1
0x4d
0x5d
0x0e
0xe2
0x77
0x15
0xdf
0x08
0xb4
0x15
0x2b
0xa2
0x3d
0xa8
0xe0
}
;
static
const
unsigned
char
k2_0
[
]
=
{
0x5e
0xba
0x73
0xf8
0x91
0x42
0xc5
0x48
0x80
0xf6
0x85
0x94
0x37
0x3c
0x5c
0x37
}
;
static
const
unsigned
char
k3_0
[
]
=
{
0x8d
0x34
0xef
0xcb
0x3b
0xd5
0x45
0xca
0x06
0x2a
0xec
0xdf
0xef
0x7c
0x0b
0xfa
}
;
if
(
keyLen
<
AES_BLOCK_SIZE
)
{
PORT_Memcpy
(
newKey
keyValue
keyLen
)
;
PORT_Memset
(
&
newKey
[
keyLen
]
0
AES_BLOCK_SIZE
-
keyLen
)
;
keyValue
=
newKey
;
}
else
if
(
keyLen
>
AES_BLOCK_SIZE
)
{
aes_context
=
AES_CreateContext
(
k1_0
iv_zero
NSS_AES_CBC
PR_TRUE
AES_BLOCK_SIZE
AES_BLOCK_SIZE
)
;
while
(
keyLen
>
AES_BLOCK_SIZE
)
{
rv
=
AES_Encrypt
(
aes_context
newKey
&
tmpLen
AES_BLOCK_SIZE
keyValue
AES_BLOCK_SIZE
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
fail
;
}
keyValue
+
=
AES_BLOCK_SIZE
;
keyLen
-
=
AES_BLOCK_SIZE
;
}
PORT_Memcpy
(
newKey
keyValue
keyLen
)
;
sftk_xcbc_mac_pad
(
newKey
keyLen
AES_BLOCK_SIZE
k2_0
k3_0
)
;
rv
=
AES_Encrypt
(
aes_context
newKey
&
tmpLen
AES_BLOCK_SIZE
newKey
AES_BLOCK_SIZE
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
fail
;
}
keyValue
=
newKey
;
AES_DestroyContext
(
aes_context
PR_TRUE
)
;
}
aes_context
=
AES_CreateContext
(
keyValue
iv_zero
NSS_AES
PR_TRUE
AES_BLOCK_SIZE
AES_BLOCK_SIZE
)
;
if
(
aes_context
=
=
NULL
)
{
goto
fail
;
}
rv
=
AES_Encrypt
(
aes_context
k1
&
tmpLen
AES_BLOCK_SIZE
k1data
sizeof
(
k1data
)
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
fail
;
}
rv
=
AES_Encrypt
(
aes_context
k2
&
tmpLen
AES_BLOCK_SIZE
k2data
sizeof
(
k2data
)
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
fail
;
}
rv
=
AES_Encrypt
(
aes_context
k3
&
tmpLen
AES_BLOCK_SIZE
k3data
sizeof
(
k3data
)
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
fail
;
}
AES_DestroyContext
(
aes_context
PR_TRUE
)
;
PORT_Memset
(
newKey
0
AES_BLOCK_SIZE
)
;
return
CKR_OK
;
fail
:
crv
=
sftk_MapCryptError
(
PORT_GetError
(
)
)
;
if
(
aes_context
)
{
AES_DestroyContext
(
aes_context
PR_TRUE
)
;
}
PORT_Memset
(
k1
0
AES_BLOCK_SIZE
)
;
PORT_Memset
(
k2
0
AES_BLOCK_SIZE
)
;
PORT_Memset
(
k3
0
AES_BLOCK_SIZE
)
;
PORT_Memset
(
newKey
0
AES_BLOCK_SIZE
)
;
return
crv
;
}
CK_RV
sftk_xcbc_mac_pad
(
unsigned
char
*
padBuf
unsigned
int
bufLen
unsigned
int
blockSize
const
unsigned
char
*
k2
const
unsigned
char
*
k3
)
{
unsigned
int
i
;
if
(
bufLen
=
=
blockSize
)
{
for
(
i
=
0
;
i
<
blockSize
;
i
+
+
)
{
padBuf
[
i
]
^
=
k2
[
i
]
;
}
}
else
{
padBuf
[
bufLen
+
+
]
=
0x80
;
for
(
i
=
bufLen
;
i
<
blockSize
;
i
+
+
)
{
padBuf
[
i
]
=
0x00
;
}
for
(
i
=
0
;
i
<
blockSize
;
i
+
+
)
{
padBuf
[
i
]
^
=
k3
[
i
]
;
}
}
return
CKR_OK
;
}
static
HASH_HashType
sftk_map_hmac_to_hash
(
CK_MECHANISM_TYPE
type
)
{
switch
(
type
)
{
case
CKM_SHA_1_HMAC
:
case
CKM_SHA_1
:
return
HASH_AlgSHA1
;
case
CKM_MD5_HMAC
:
case
CKM_MD5
:
return
HASH_AlgMD5
;
case
CKM_MD2_HMAC
:
case
CKM_MD2
:
return
HASH_AlgMD2
;
case
CKM_SHA224_HMAC
:
case
CKM_SHA224
:
return
HASH_AlgSHA224
;
case
CKM_SHA256_HMAC
:
case
CKM_SHA256
:
return
HASH_AlgSHA256
;
case
CKM_SHA384_HMAC
:
case
CKM_SHA384
:
return
HASH_AlgSHA384
;
case
CKM_SHA512_HMAC
:
case
CKM_SHA512
:
return
HASH_AlgSHA512
;
}
return
HASH_AlgNULL
;
}
static
CK_RV
prf_setup
(
prfContext
*
context
CK_MECHANISM_TYPE
mech
)
{
context
-
>
hashType
=
sftk_map_hmac_to_hash
(
mech
)
;
context
-
>
hashObj
=
NULL
;
context
-
>
hmac
=
NULL
;
context
-
>
aes
=
NULL
;
if
(
context
-
>
hashType
!
=
HASH_AlgNULL
)
{
context
-
>
hashObj
=
HASH_GetRawHashObject
(
context
-
>
hashType
)
;
if
(
context
-
>
hashObj
=
=
NULL
)
{
return
CKR_GENERAL_ERROR
;
}
return
CKR_OK
;
}
else
if
(
mech
=
=
CKM_AES_XCBC_MAC
)
{
return
CKR_OK
;
}
return
CKR_MECHANISM_PARAM_INVALID
;
}
static
CK_RV
prf_length
(
prfContext
*
context
)
{
if
(
context
-
>
hashObj
)
{
return
context
-
>
hashObj
-
>
length
;
}
return
AES_BLOCK_SIZE
;
}
static
CK_RV
prf_init
(
prfContext
*
context
const
unsigned
char
*
keyValue
unsigned
int
keyLen
)
{
CK_RV
crv
;
context
-
>
hmac
=
NULL
;
if
(
context
-
>
hashObj
)
{
context
-
>
hmac
=
HMAC_Create
(
context
-
>
hashObj
keyValue
keyLen
PR_FALSE
)
;
if
(
context
-
>
hmac
=
=
NULL
)
{
return
sftk_MapCryptError
(
PORT_GetError
(
)
)
;
}
HMAC_Begin
(
context
-
>
hmac
)
;
}
else
{
crv
=
sftk_aes_xcbc_get_keys
(
keyValue
keyLen
context
-
>
k1
context
-
>
k2
context
-
>
k3
)
;
if
(
crv
!
=
CKR_OK
)
return
crv
;
context
-
>
nextChar
=
0
;
context
-
>
aes
=
AES_CreateContext
(
context
-
>
k1
iv_zero
NSS_AES_CBC
PR_TRUE
sizeof
(
context
-
>
k1
)
AES_BLOCK_SIZE
)
;
if
(
context
-
>
aes
=
=
NULL
)
{
crv
=
sftk_MapCryptError
(
PORT_GetError
(
)
)
;
PORT_Memset
(
context
-
>
k1
0
sizeof
(
context
-
>
k1
)
)
;
PORT_Memset
(
context
-
>
k2
0
sizeof
(
context
-
>
k2
)
)
;
PORT_Memset
(
context
-
>
k3
0
sizeof
(
context
-
>
k2
)
)
;
return
crv
;
}
}
return
CKR_OK
;
}
static
CK_RV
prf_update
(
prfContext
*
context
const
unsigned
char
*
buf
unsigned
int
len
)
{
unsigned
int
tmpLen
;
SECStatus
rv
;
if
(
context
-
>
hmac
)
{
HMAC_Update
(
context
-
>
hmac
buf
len
)
;
}
else
{
while
(
context
-
>
nextChar
+
len
>
AES_BLOCK_SIZE
)
{
if
(
context
-
>
nextChar
!
=
0
)
{
unsigned
int
left
=
AES_BLOCK_SIZE
-
context
-
>
nextChar
;
PORT_Memcpy
(
context
-
>
padBuf
+
context
-
>
nextChar
buf
left
)
;
rv
=
AES_Encrypt
(
context
-
>
aes
context
-
>
macBuf
&
tmpLen
sizeof
(
context
-
>
macBuf
)
context
-
>
padBuf
sizeof
(
context
-
>
padBuf
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
sftk_MapCryptError
(
PORT_GetError
(
)
)
;
}
context
-
>
nextChar
=
0
;
len
-
=
left
;
buf
+
=
left
;
}
else
{
rv
=
AES_Encrypt
(
context
-
>
aes
context
-
>
macBuf
&
tmpLen
sizeof
(
context
-
>
macBuf
)
buf
AES_BLOCK_SIZE
)
;
if
(
rv
!
=
SECSuccess
)
{
return
sftk_MapCryptError
(
PORT_GetError
(
)
)
;
}
len
-
=
AES_BLOCK_SIZE
;
buf
+
=
AES_BLOCK_SIZE
;
}
}
PORT_Memcpy
(
context
-
>
padBuf
+
context
-
>
nextChar
buf
len
)
;
context
-
>
nextChar
+
=
len
;
}
return
CKR_OK
;
}
static
void
prf_free
(
prfContext
*
context
)
{
if
(
context
-
>
hmac
)
{
HMAC_Destroy
(
context
-
>
hmac
PR_TRUE
)
;
context
-
>
hmac
=
NULL
;
}
if
(
context
-
>
aes
)
{
PORT_Memset
(
context
-
>
k1
0
sizeof
(
context
-
>
k1
)
)
;
PORT_Memset
(
context
-
>
k2
0
sizeof
(
context
-
>
k2
)
)
;
PORT_Memset
(
context
-
>
k3
0
sizeof
(
context
-
>
k2
)
)
;
PORT_Memset
(
context
-
>
padBuf
0
sizeof
(
context
-
>
padBuf
)
)
;
PORT_Memset
(
context
-
>
macBuf
0
sizeof
(
context
-
>
macBuf
)
)
;
AES_DestroyContext
(
context
-
>
aes
PR_TRUE
)
;
context
-
>
aes
=
NULL
;
}
}
static
CK_RV
prf_final
(
prfContext
*
context
unsigned
char
*
buf
unsigned
int
len
)
{
unsigned
int
tmpLen
;
SECStatus
rv
;
if
(
context
-
>
hmac
)
{
unsigned
int
outLen
;
HMAC_Finish
(
context
-
>
hmac
buf
&
outLen
len
)
;
if
(
outLen
!
=
len
)
{
return
CKR_GENERAL_ERROR
;
}
}
else
{
CK_RV
crv
=
sftk_xcbc_mac_pad
(
context
-
>
padBuf
context
-
>
nextChar
AES_BLOCK_SIZE
context
-
>
k2
context
-
>
k3
)
;
if
(
crv
!
=
CKR_OK
)
{
return
crv
;
}
rv
=
AES_Encrypt
(
context
-
>
aes
context
-
>
macBuf
&
tmpLen
sizeof
(
context
-
>
macBuf
)
context
-
>
padBuf
AES_BLOCK_SIZE
)
;
if
(
rv
!
=
SECSuccess
)
{
return
sftk_MapCryptError
(
PORT_GetError
(
)
)
;
}
PORT_Memcpy
(
buf
context
-
>
macBuf
len
)
;
}
prf_free
(
context
)
;
return
CKR_OK
;
}
CK_RV
sftk_ike_prf
(
CK_SESSION_HANDLE
hSession
const
SFTKAttribute
*
inKey
const
CK_NSS_IKE_PRF_DERIVE_PARAMS
*
params
SFTKObject
*
outKey
)
{
SFTKAttribute
*
newKeyValue
=
NULL
;
SFTKObject
*
newKeyObj
=
NULL
;
unsigned
char
outKeyData
[
HASH_LENGTH_MAX
]
;
unsigned
char
*
newInKey
=
NULL
;
unsigned
int
newInKeySize
;
unsigned
int
macSize
;
CK_RV
crv
=
CKR_OK
;
prfContext
context
;
crv
=
prf_setup
(
&
context
params
-
>
prfMechanism
)
;
if
(
crv
!
=
CKR_OK
)
{
return
crv
;
}
macSize
=
prf_length
(
&
context
)
;
if
(
(
params
-
>
bDataAsKey
)
&
&
(
params
-
>
bRekey
)
)
{
return
CKR_ARGUMENTS_BAD
;
}
if
(
params
-
>
bRekey
)
{
SFTKSession
*
session
=
sftk_SessionFromHandle
(
hSession
)
;
if
(
session
=
=
NULL
)
{
return
CKR_SESSION_HANDLE_INVALID
;
}
newKeyObj
=
sftk_ObjectFromHandle
(
params
-
>
hNewKey
session
)
;
sftk_FreeSession
(
session
)
;
if
(
newKeyObj
=
=
NULL
)
{
return
CKR_KEY_HANDLE_INVALID
;
}
newKeyValue
=
sftk_FindAttribute
(
newKeyObj
CKA_VALUE
)
;
if
(
newKeyValue
=
=
NULL
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
}
if
(
params
-
>
bDataAsKey
)
{
newInKeySize
=
params
-
>
ulNiLen
+
params
-
>
ulNrLen
;
newInKey
=
PORT_Alloc
(
newInKeySize
)
;
if
(
newInKey
=
=
NULL
)
{
crv
=
CKR_HOST_MEMORY
;
goto
fail
;
}
PORT_Memcpy
(
newInKey
params
-
>
pNi
params
-
>
ulNiLen
)
;
PORT_Memcpy
(
newInKey
+
params
-
>
ulNiLen
params
-
>
pNr
params
-
>
ulNrLen
)
;
crv
=
prf_init
(
&
context
newInKey
newInKeySize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
inKey
-
>
attrib
.
pValue
inKey
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
}
else
{
crv
=
prf_init
(
&
context
inKey
-
>
attrib
.
pValue
inKey
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
if
(
newKeyValue
)
{
crv
=
prf_update
(
&
context
newKeyValue
-
>
attrib
.
pValue
newKeyValue
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
}
crv
=
prf_update
(
&
context
params
-
>
pNi
params
-
>
ulNiLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
params
-
>
pNr
params
-
>
ulNrLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
}
crv
=
prf_final
(
&
context
outKeyData
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
sftk_forceAttribute
(
outKey
CKA_VALUE
outKeyData
macSize
)
;
fail
:
if
(
newInKey
)
{
PORT_Free
(
newInKey
)
;
}
if
(
newKeyValue
)
{
sftk_FreeAttribute
(
newKeyValue
)
;
}
if
(
newKeyObj
)
{
sftk_FreeObject
(
newKeyObj
)
;
}
PORT_Memset
(
outKeyData
0
macSize
)
;
prf_free
(
&
context
)
;
return
crv
;
}
CK_RV
sftk_ike1_prf
(
CK_SESSION_HANDLE
hSession
const
SFTKAttribute
*
inKey
const
CK_NSS_IKE1_PRF_DERIVE_PARAMS
*
params
SFTKObject
*
outKey
unsigned
int
keySize
)
{
SFTKAttribute
*
gxyKeyValue
=
NULL
;
SFTKObject
*
gxyKeyObj
=
NULL
;
SFTKAttribute
*
prevKeyValue
=
NULL
;
SFTKObject
*
prevKeyObj
=
NULL
;
SFTKSession
*
session
;
unsigned
char
outKeyData
[
HASH_LENGTH_MAX
]
;
unsigned
int
macSize
;
CK_RV
crv
;
prfContext
context
;
crv
=
prf_setup
(
&
context
params
-
>
prfMechanism
)
;
if
(
crv
!
=
CKR_OK
)
{
return
crv
;
}
macSize
=
prf_length
(
&
context
)
;
if
(
keySize
>
macSize
)
{
return
CKR_KEY_SIZE_RANGE
;
}
if
(
keySize
=
=
0
)
{
keySize
=
macSize
;
}
session
=
sftk_SessionFromHandle
(
hSession
)
;
if
(
session
=
=
NULL
)
{
return
CKR_SESSION_HANDLE_INVALID
;
}
gxyKeyObj
=
sftk_ObjectFromHandle
(
params
-
>
hKeygxy
session
)
;
if
(
params
-
>
bHasPrevKey
)
{
prevKeyObj
=
sftk_ObjectFromHandle
(
params
-
>
hPrevKey
session
)
;
}
sftk_FreeSession
(
session
)
;
if
(
(
gxyKeyObj
=
=
NULL
)
|
|
(
(
params
-
>
bHasPrevKey
)
&
&
(
prevKeyObj
=
=
NULL
)
)
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
gxyKeyValue
=
sftk_FindAttribute
(
gxyKeyObj
CKA_VALUE
)
;
if
(
gxyKeyValue
=
=
NULL
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
if
(
prevKeyObj
)
{
prevKeyValue
=
sftk_FindAttribute
(
prevKeyObj
CKA_VALUE
)
;
if
(
prevKeyValue
=
=
NULL
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
}
crv
=
prf_init
(
&
context
inKey
-
>
attrib
.
pValue
inKey
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
if
(
prevKeyValue
)
{
crv
=
prf_update
(
&
context
prevKeyValue
-
>
attrib
.
pValue
prevKeyValue
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
}
crv
=
prf_update
(
&
context
gxyKeyValue
-
>
attrib
.
pValue
gxyKeyValue
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
params
-
>
pCKYi
params
-
>
ulCKYiLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
params
-
>
pCKYr
params
-
>
ulCKYrLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
&
params
-
>
keyNumber
1
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_final
(
&
context
outKeyData
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
sftk_forceAttribute
(
outKey
CKA_VALUE
outKeyData
keySize
)
;
fail
:
if
(
gxyKeyValue
)
{
sftk_FreeAttribute
(
gxyKeyValue
)
;
}
if
(
prevKeyValue
)
{
sftk_FreeAttribute
(
prevKeyValue
)
;
}
if
(
gxyKeyObj
)
{
sftk_FreeObject
(
gxyKeyObj
)
;
}
if
(
prevKeyObj
)
{
sftk_FreeObject
(
prevKeyObj
)
;
}
PORT_Memset
(
outKeyData
0
macSize
)
;
prf_free
(
&
context
)
;
return
crv
;
}
CK_RV
sftk_ike1_appendix_b_prf
(
CK_SESSION_HANDLE
hSession
const
SFTKAttribute
*
inKey
const
CK_NSS_IKE1_APP_B_PRF_DERIVE_PARAMS
*
params
SFTKObject
*
outKey
unsigned
int
keySize
)
{
SFTKAttribute
*
gxyKeyValue
=
NULL
;
SFTKObject
*
gxyKeyObj
=
NULL
;
unsigned
char
*
outKeyData
=
NULL
;
unsigned
char
*
thisKey
=
NULL
;
unsigned
char
*
lastKey
=
NULL
;
unsigned
int
macSize
;
unsigned
int
outKeySize
;
unsigned
int
genKeySize
;
PRBool
quickMode
=
PR_FALSE
;
CK_RV
crv
;
prfContext
context
;
if
(
(
params
-
>
ulExtraDataLen
!
=
0
)
&
&
(
params
-
>
pExtraData
=
=
NULL
)
)
{
return
CKR_ARGUMENTS_BAD
;
}
crv
=
prf_setup
(
&
context
params
-
>
prfMechanism
)
;
if
(
crv
!
=
CKR_OK
)
{
return
crv
;
}
if
(
params
-
>
bHasKeygxy
)
{
SFTKSession
*
session
;
session
=
sftk_SessionFromHandle
(
hSession
)
;
if
(
session
=
=
NULL
)
{
return
CKR_SESSION_HANDLE_INVALID
;
}
gxyKeyObj
=
sftk_ObjectFromHandle
(
params
-
>
hKeygxy
session
)
;
sftk_FreeSession
(
session
)
;
if
(
gxyKeyObj
=
=
NULL
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
gxyKeyValue
=
sftk_FindAttribute
(
gxyKeyObj
CKA_VALUE
)
;
if
(
gxyKeyValue
=
=
NULL
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
quickMode
=
PR_TRUE
;
}
if
(
params
-
>
ulExtraDataLen
!
=
0
)
{
quickMode
=
PR_TRUE
;
}
macSize
=
prf_length
(
&
context
)
;
if
(
keySize
=
=
0
)
{
keySize
=
macSize
;
}
if
(
(
!
quickMode
)
&
&
(
keySize
<
=
inKey
-
>
attrib
.
ulValueLen
)
)
{
return
sftk_forceAttribute
(
outKey
CKA_VALUE
inKey
-
>
attrib
.
pValue
keySize
)
;
}
outKeySize
=
PR_ROUNDUP
(
keySize
macSize
)
;
outKeyData
=
PORT_Alloc
(
outKeySize
)
;
if
(
outKeyData
=
=
NULL
)
{
crv
=
CKR_HOST_MEMORY
;
goto
fail
;
}
thisKey
=
outKeyData
;
for
(
genKeySize
=
0
;
genKeySize
<
keySize
;
genKeySize
+
=
macSize
)
{
PRBool
hashedData
=
PR_FALSE
;
crv
=
prf_init
(
&
context
inKey
-
>
attrib
.
pValue
inKey
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
if
(
lastKey
!
=
NULL
)
{
crv
=
prf_update
(
&
context
lastKey
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
hashedData
=
PR_TRUE
;
}
if
(
gxyKeyValue
!
=
NULL
)
{
crv
=
prf_update
(
&
context
gxyKeyValue
-
>
attrib
.
pValue
gxyKeyValue
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
hashedData
=
PR_TRUE
;
}
if
(
params
-
>
ulExtraDataLen
!
=
0
)
{
crv
=
prf_update
(
&
context
params
-
>
pExtraData
params
-
>
ulExtraDataLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
hashedData
=
PR_TRUE
;
}
if
(
hashedData
=
=
PR_FALSE
)
{
const
unsigned
char
zero
=
0
;
crv
=
prf_update
(
&
context
&
zero
1
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
}
crv
=
prf_final
(
&
context
thisKey
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
lastKey
=
thisKey
;
thisKey
+
=
macSize
;
}
crv
=
sftk_forceAttribute
(
outKey
CKA_VALUE
outKeyData
keySize
)
;
fail
:
if
(
gxyKeyValue
)
{
sftk_FreeAttribute
(
gxyKeyValue
)
;
}
if
(
gxyKeyObj
)
{
sftk_FreeObject
(
gxyKeyObj
)
;
}
if
(
outKeyData
)
{
PORT_ZFree
(
outKeyData
outKeySize
)
;
}
prf_free
(
&
context
)
;
return
crv
;
}
static
CK_RV
sftk_ike_prf_plus_raw
(
CK_SESSION_HANDLE
hSession
const
unsigned
char
*
inKeyData
CK_ULONG
inKeyLen
const
CK_NSS_IKE_PRF_PLUS_DERIVE_PARAMS
*
params
unsigned
char
*
*
outKeyDataPtr
unsigned
int
*
outKeySizePtr
unsigned
int
keySize
)
{
SFTKAttribute
*
seedValue
=
NULL
;
SFTKObject
*
seedKeyObj
=
NULL
;
unsigned
char
*
outKeyData
=
NULL
;
unsigned
int
outKeySize
;
unsigned
char
*
thisKey
;
unsigned
char
*
lastKey
=
NULL
;
unsigned
char
currentByte
=
0
;
unsigned
int
getKeySize
;
unsigned
int
macSize
;
CK_RV
crv
;
prfContext
context
;
if
(
keySize
=
=
0
)
{
return
CKR_KEY_SIZE_RANGE
;
}
crv
=
prf_setup
(
&
context
params
-
>
prfMechanism
)
;
if
(
crv
!
=
CKR_OK
)
{
return
crv
;
}
if
(
params
-
>
bHasSeedKey
)
{
SFTKSession
*
session
=
sftk_SessionFromHandle
(
hSession
)
;
if
(
session
=
=
NULL
)
{
return
CKR_SESSION_HANDLE_INVALID
;
}
seedKeyObj
=
sftk_ObjectFromHandle
(
params
-
>
hSeedKey
session
)
;
sftk_FreeSession
(
session
)
;
if
(
seedKeyObj
=
=
NULL
)
{
return
CKR_KEY_HANDLE_INVALID
;
}
seedValue
=
sftk_FindAttribute
(
seedKeyObj
CKA_VALUE
)
;
if
(
seedValue
=
=
NULL
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
}
else
if
(
params
-
>
ulSeedDataLen
=
=
0
)
{
crv
=
CKR_ARGUMENTS_BAD
;
goto
fail
;
}
macSize
=
prf_length
(
&
context
)
;
outKeySize
=
PR_ROUNDUP
(
keySize
macSize
)
;
outKeyData
=
PORT_Alloc
(
outKeySize
)
;
if
(
outKeyData
=
=
NULL
)
{
crv
=
CKR_HOST_MEMORY
;
goto
fail
;
}
thisKey
=
outKeyData
;
for
(
getKeySize
=
0
;
getKeySize
<
keySize
;
getKeySize
+
=
macSize
)
{
if
(
currentByte
=
=
255
)
{
crv
=
CKR_KEY_SIZE_RANGE
;
goto
fail
;
}
crv
=
prf_init
(
&
context
inKeyData
inKeyLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
if
(
lastKey
)
{
crv
=
prf_update
(
&
context
lastKey
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
}
if
(
seedValue
)
{
crv
=
prf_update
(
&
context
seedValue
-
>
attrib
.
pValue
seedValue
-
>
attrib
.
ulValueLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
}
if
(
params
-
>
ulSeedDataLen
!
=
0
)
{
crv
=
prf_update
(
&
context
params
-
>
pSeedData
params
-
>
ulSeedDataLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
}
currentByte
+
+
;
crv
=
prf_update
(
&
context
&
currentByte
1
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_final
(
&
context
thisKey
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
lastKey
=
thisKey
;
thisKey
+
=
macSize
;
}
*
outKeyDataPtr
=
outKeyData
;
*
outKeySizePtr
=
outKeySize
;
outKeyData
=
NULL
;
fail
:
if
(
outKeyData
)
{
PORT_ZFree
(
outKeyData
outKeySize
)
;
}
if
(
seedValue
)
{
sftk_FreeAttribute
(
seedValue
)
;
}
if
(
seedKeyObj
)
{
sftk_FreeObject
(
seedKeyObj
)
;
}
prf_free
(
&
context
)
;
return
crv
;
}
CK_RV
sftk_ike_prf_plus
(
CK_SESSION_HANDLE
hSession
const
SFTKAttribute
*
inKey
const
CK_NSS_IKE_PRF_PLUS_DERIVE_PARAMS
*
params
SFTKObject
*
outKey
unsigned
int
keySize
)
{
unsigned
char
*
outKeyData
=
NULL
;
unsigned
int
outKeySize
;
CK_RV
crv
;
crv
=
sftk_ike_prf_plus_raw
(
hSession
inKey
-
>
attrib
.
pValue
inKey
-
>
attrib
.
ulValueLen
params
&
outKeyData
&
outKeySize
keySize
)
;
if
(
crv
!
=
CKR_OK
)
{
return
crv
;
}
crv
=
sftk_forceAttribute
(
outKey
CKA_VALUE
outKeyData
keySize
)
;
PORT_ZFree
(
outKeyData
outKeySize
)
;
return
crv
;
}
CK_RV
sftk_aes_xcbc_new_keys
(
CK_SESSION_HANDLE
hSession
CK_OBJECT_HANDLE
hKey
CK_OBJECT_HANDLE_PTR
phKey
unsigned
char
*
k2
unsigned
char
*
k3
)
{
SFTKObject
*
key
=
NULL
;
SFTKSession
*
session
=
NULL
;
SFTKObject
*
inKeyObj
=
NULL
;
SFTKAttribute
*
inKeyValue
=
NULL
;
CK_KEY_TYPE
key_type
=
CKK_AES
;
CK_OBJECT_CLASS
objclass
=
CKO_SECRET_KEY
;
CK_BBOOL
ck_true
=
CK_TRUE
;
CK_RV
crv
=
CKR_OK
;
SFTKSlot
*
slot
=
sftk_SlotFromSessionHandle
(
hSession
)
;
unsigned
char
buf
[
AES_BLOCK_SIZE
]
;
if
(
!
slot
)
{
return
CKR_SESSION_HANDLE_INVALID
;
}
session
=
sftk_SessionFromHandle
(
hSession
)
;
if
(
session
=
=
NULL
)
{
crv
=
CKR_SESSION_HANDLE_INVALID
;
goto
fail
;
}
inKeyObj
=
sftk_ObjectFromHandle
(
hKey
session
)
;
if
(
inKeyObj
=
=
NULL
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
inKeyValue
=
sftk_FindAttribute
(
inKeyObj
CKA_VALUE
)
;
if
(
inKeyValue
=
=
NULL
)
{
crv
=
CKR_KEY_HANDLE_INVALID
;
goto
fail
;
}
crv
=
sftk_aes_xcbc_get_keys
(
inKeyValue
-
>
attrib
.
pValue
inKeyValue
-
>
attrib
.
ulValueLen
buf
k2
k3
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
key
=
sftk_NewObject
(
slot
)
;
if
(
key
=
=
NULL
)
{
crv
=
CKR_HOST_MEMORY
;
goto
fail
;
}
sftk_DeleteAttributeType
(
key
CKA_CLASS
)
;
sftk_DeleteAttributeType
(
key
CKA_KEY_TYPE
)
;
sftk_DeleteAttributeType
(
key
CKA_VALUE
)
;
sftk_DeleteAttributeType
(
key
CKA_SIGN
)
;
crv
=
sftk_AddAttributeType
(
key
CKA_CLASS
&
objclass
sizeof
(
CK_OBJECT_CLASS
)
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
sftk_AddAttributeType
(
key
CKA_KEY_TYPE
&
key_type
sizeof
(
CK_KEY_TYPE
)
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
sftk_AddAttributeType
(
key
CKA_SIGN
&
ck_true
sizeof
(
CK_BBOOL
)
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
sftk_AddAttributeType
(
key
CKA_VALUE
buf
AES_BLOCK_SIZE
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
sftk_handleObject
(
key
session
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
*
phKey
=
key
-
>
handle
;
fail
:
if
(
session
)
{
sftk_FreeSession
(
session
)
;
}
if
(
inKeyValue
)
{
sftk_FreeAttribute
(
inKeyValue
)
;
}
if
(
inKeyObj
)
{
sftk_FreeObject
(
inKeyObj
)
;
}
if
(
key
)
{
sftk_FreeObject
(
key
)
;
}
PORT_Memset
(
buf
0
sizeof
(
buf
)
)
;
if
(
crv
!
=
CKR_OK
)
{
PORT_Memset
(
k2
0
AES_BLOCK_SIZE
)
;
PORT_Memset
(
k3
0
AES_BLOCK_SIZE
)
;
}
return
crv
;
}
static
SECStatus
prf_test
(
CK_MECHANISM_TYPE
mech
const
unsigned
char
*
inKey
unsigned
int
inKeyLen
const
unsigned
char
*
plainText
unsigned
int
plainTextLen
const
unsigned
char
*
expectedResult
unsigned
int
expectedResultLen
)
{
PRUint8
ike_computed_mac
[
HASH_LENGTH_MAX
]
;
prfContext
context
;
unsigned
int
macSize
;
CK_RV
crv
;
crv
=
prf_setup
(
&
context
mech
)
;
if
(
crv
!
=
CKR_OK
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
macSize
=
prf_length
(
&
context
)
;
crv
=
prf_init
(
&
context
inKey
inKeyLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
plainText
plainTextLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_final
(
&
context
ike_computed_mac
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
if
(
macSize
!
=
expectedResultLen
)
{
goto
fail
;
}
if
(
PORT_Memcmp
(
expectedResult
ike_computed_mac
macSize
)
!
=
0
)
{
goto
fail
;
}
if
(
plainTextLen
<
=
macSize
)
{
return
SECSuccess
;
}
prf_free
(
&
context
)
;
crv
=
prf_init
(
&
context
inKey
inKeyLen
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
plainText
1
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
&
plainText
[
1
]
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_update
(
&
context
&
plainText
[
1
+
macSize
]
plainTextLen
-
(
macSize
+
1
)
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
crv
=
prf_final
(
&
context
ike_computed_mac
macSize
)
;
if
(
crv
!
=
CKR_OK
)
{
goto
fail
;
}
if
(
PORT_Memcmp
(
expectedResult
ike_computed_mac
macSize
)
!
=
0
)
{
goto
fail
;
}
prf_free
(
&
context
)
;
return
SECSuccess
;
fail
:
prf_free
(
&
context
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
SECStatus
sftk_fips_IKE_PowerUpSelfTests
(
void
)
{
static
const
PRUint8
ike_xcbc_known_key
[
]
=
{
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0a
0x0b
0x0c
0x0d
0x0e
0x0f
}
;
static
const
PRUint8
ike_xcbc_known_plain_text
[
]
=
{
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0a
0x0b
0x0c
0x0d
0x0e
0x0f
}
;
static
const
PRUint8
ike_xcbc_known_mac
[
]
=
{
0xd2
0xa2
0x46
0xfa
0x34
0x9b
0x68
0xa7
0x99
0x98
0xa4
0x39
0x4f
0xf7
0xa2
0x63
}
;
static
const
PRUint8
ike_xcbc_known_plain_text_2
[
]
=
{
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0a
0x0b
0x0c
0x0d
0x0e
0x0f
0x10
0x11
0x12
0x13
}
;
static
const
PRUint8
ike_xcbc_known_mac_2
[
]
=
{
0x47
0xf5
0x1b
0x45
0x64
0x96
0x62
0x15
0xb8
0x98
0x5c
0x63
0x05
0x5e
0xd3
0x08
}
;
static
const
PRUint8
ike_xcbc_known_key_3
[
]
=
{
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
}
;
static
const
PRUint8
ike_xcbc_known_mac_3
[
]
=
{
0x0f
0xa0
0x87
0xaf
0x7d
0x86
0x6e
0x76
0x53
0x43
0x4e
0x60
0x2f
0xdd
0xe8
0x35
}
;
static
const
PRUint8
ike_xcbc_known_key_4
[
]
=
{
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0a
0x0b
0x0c
0x0d
0x0e
0x0f
0xed
0xcb
}
;
static
const
PRUint8
ike_xcbc_known_mac_4
[
]
=
{
0x8c
0xd3
0xc9
0x3a
0xe5
0x98
0xa9
0x80
0x30
0x06
0xff
0xb6
0x7c
0x40
0xe9
0xe4
}
;
static
const
PRUint8
ike_sha1_known_key
[
]
=
{
0x59
0x98
0x2b
0x5b
0xa5
0x7e
0x62
0xc0
0x46
0x0d
0xef
0xc7
0x1e
0x18
0x64
0x63
}
;
static
const
PRUint8
ike_sha1_known_plain_text
[
]
=
{
0x1c
0x07
0x32
0x1a
0x9a
0x7e
0x41
0xcd
0x88
0x0c
0xa3
0x7a
0xdb
0x10
0xc7
0x3b
0xf0
0x0e
0x7a
0xe3
0xcf
0xc6
0xfd
0x8b
0x51
0xbc
0xe2
0xb9
0x90
0xe6
0xf2
0x01
}
;
static
const
PRUint8
ike_sha1_known_mac
[
]
=
{
0x0c
0x2a
0xf3
0x42
0x97
0x15
0x62
0x1d
0x2a
0xad
0xc9
0x94
0x5a
0x90
0x26
0xfa
0xc7
0x91
0xe2
0x4b
}
;
static
const
PRUint8
ike_sha256_known_key
[
]
=
{
0x9d
0xa2
0xd5
0x8f
0x57
0xf0
0x39
0xf9
0x20
0x4e
0x0d
0xd0
0xef
0x04
0xf3
0x72
}
;
static
const
PRUint8
ike_sha256_known_plain_text
[
]
=
{
0x33
0xf1
0x7a
0xfc
0xb6
0x13
0x4c
0xbf
0x1c
0xab
0x59
0x87
0x7d
0x42
0xdb
0x35
0x82
0x22
0x6e
0xff
0x74
0xdd
0x37
0xeb
0x8b
0x75
0xe6
0x75
0x64
0x5f
0xc1
0x69
}
;
static
const
PRUint8
ike_sha256_known_mac
[
]
=
{
0x80
0x4b
0x4a
0x1e
0x0e
0xc5
0x93
0xcf
0xb6
0xe4
0x54
0x52
0x41
0x49
0x39
0x6d
0xe2
0x34
0xd0
0xda
0xe2
0x9f
0x34
0xa8
0xfd
0xb5
0xf9
0xaf
0xe7
0x6e
0xa6
0x52
}
;
static
const
PRUint8
ike_sha384_known_key
[
]
=
{
0xce
0xc8
0x9d
0x84
0x5a
0xdd
0x83
0xef
0xce
0xbd
0x43
0xab
0x71
0xd1
0x7d
0xb9
}
;
static
const
PRUint8
ike_sha384_known_plain_text
[
]
=
{
0x17
0x24
0xdb
0xd8
0x93
0x52
0x37
0x64
0xbf
0xef
0x8c
0x6f
0xa9
0x27
0x85
0x6f
0xcc
0xfb
0x77
0xae
0x25
0x43
0x58
0xcc
0xe2
0x9c
0x27
0x69
0xa3
0x29
0x15
0xc1
}
;
static
const
PRUint8
ike_sha384_known_mac
[
]
=
{
0x6e
0x45
0x14
0x61
0x0b
0xf8
0x2d
0x0a
0xb7
0xbf
0x02
0x60
0x09
0x6f
0x61
0x46
0xa1
0x53
0xc7
0x12
0x07
0x1a
0xbb
0x63
0x3c
0xed
0x81
0x3c
0x57
0x21
0x56
0xc7
0x83
0xe3
0x68
0x74
0xa6
0x5a
0x64
0x69
0x0c
0xa7
0x01
0xd4
0x0d
0x56
0xea
0x18
}
;
static
const
PRUint8
ike_sha512_known_key
[
]
=
{
0xac
0xad
0xc6
0x31
0x4a
0x69
0xcf
0xcd
0x4e
0x4a
0xd1
0x77
0x18
0xfe
0xa7
0xce
}
;
static
const
PRUint8
ike_sha512_known_plain_text
[
]
=
{
0xb1
0x5a
0x9c
0xfc
0xe8
0xc8
0xd7
0xea
0xb8
0x79
0xd6
0x24
0x30
0x29
0xd4
0x01
0x88
0xd3
0xb7
0x40
0x87
0x5a
0x6a
0xc6
0x2f
0x56
0xca
0xc4
0x37
0x7e
0x2e
0xdd
}
;
static
const
PRUint8
ike_sha512_known_mac
[
]
=
{
0xf0
0x5a
0xa0
0x36
0xdf
0xce
0x45
0xa5
0x58
0xd4
0x04
0x18
0xde
0xa9
0x80
0x96
0xe5
0x19
0xbc
0x78
0x41
0xe3
0xdb
0x3d
0xd9
0x36
0x58
0xd1
0x18
0xc3
0xe8
0x3b
0x50
0x2f
0x39
0x8e
0xcb
0x13
0x61
0xec
0x77
0xd3
0x8a
0x88
0x55
0xef
0xff
0x40
0x7f
0x6f
0x77
0x2e
0x5d
0x65
0xb5
0x8e
0xb1
0x13
0x40
0x96
0xe8
0x47
0x8d
0x2b
}
;
static
const
PRUint8
ike_known_sha256_prf_plus
[
]
=
{
0xe6
0xf1
0x9b
0x4a
0x02
0xe9
0x73
0x72
0x93
0x9f
0xdb
0x46
0x1d
0xb1
0x49
0xcb
0x53
0x08
0x98
0x3d
0x41
0x36
0xfa
0x8b
0x47
0x04
0x49
0x11
0x0d
0x6e
0x96
0x1d
0xab
0xbe
0x94
0x28
0xa0
0xb7
0x9c
0xa3
0x29
0xe1
0x40
0xf8
0xf8
0x88
0xb9
0xb5
0x40
0xd4
0x54
0x4d
0x25
0xab
0x94
0xd4
0x98
0xd8
0x00
0xbf
0x6f
0xef
0xe8
0x39
}
;
SECStatus
rv
;
CK_RV
crv
;
unsigned
char
*
outKeyData
=
NULL
;
unsigned
int
outKeySize
;
CK_NSS_IKE_PRF_PLUS_DERIVE_PARAMS
ike_params
;
rv
=
prf_test
(
CKM_AES_XCBC_MAC
ike_xcbc_known_key
sizeof
(
ike_xcbc_known_key
)
ike_xcbc_known_plain_text
sizeof
(
ike_xcbc_known_plain_text
)
ike_xcbc_known_mac
sizeof
(
ike_xcbc_known_mac
)
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
prf_test
(
CKM_AES_XCBC_MAC
ike_xcbc_known_key
sizeof
(
ike_xcbc_known_key
)
ike_xcbc_known_plain_text_2
sizeof
(
ike_xcbc_known_plain_text_2
)
ike_xcbc_known_mac_2
sizeof
(
ike_xcbc_known_mac_2
)
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
prf_test
(
CKM_AES_XCBC_MAC
ike_xcbc_known_key_3
sizeof
(
ike_xcbc_known_key_3
)
ike_xcbc_known_plain_text_2
sizeof
(
ike_xcbc_known_plain_text_2
)
ike_xcbc_known_mac_3
sizeof
(
ike_xcbc_known_mac_3
)
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
prf_test
(
CKM_AES_XCBC_MAC
ike_xcbc_known_key_4
sizeof
(
ike_xcbc_known_key_4
)
ike_xcbc_known_plain_text_2
sizeof
(
ike_xcbc_known_plain_text_2
)
ike_xcbc_known_mac_4
sizeof
(
ike_xcbc_known_mac_4
)
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
prf_test
(
CKM_SHA_1_HMAC
ike_sha1_known_key
sizeof
(
ike_sha1_known_key
)
ike_sha1_known_plain_text
sizeof
(
ike_sha1_known_plain_text
)
ike_sha1_known_mac
sizeof
(
ike_sha1_known_mac
)
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
prf_test
(
CKM_SHA256_HMAC
ike_sha256_known_key
sizeof
(
ike_sha256_known_key
)
ike_sha256_known_plain_text
sizeof
(
ike_sha256_known_plain_text
)
ike_sha256_known_mac
sizeof
(
ike_sha256_known_mac
)
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
prf_test
(
CKM_SHA384_HMAC
ike_sha384_known_key
sizeof
(
ike_sha384_known_key
)
ike_sha384_known_plain_text
sizeof
(
ike_sha384_known_plain_text
)
ike_sha384_known_mac
sizeof
(
ike_sha384_known_mac
)
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
prf_test
(
CKM_SHA512_HMAC
ike_sha512_known_key
sizeof
(
ike_sha512_known_key
)
ike_sha512_known_plain_text
sizeof
(
ike_sha512_known_plain_text
)
ike_sha512_known_mac
sizeof
(
ike_sha512_known_mac
)
)
;
ike_params
.
prfMechanism
=
CKM_SHA256_HMAC
;
ike_params
.
bHasSeedKey
=
PR_FALSE
;
ike_params
.
hSeedKey
=
CK_INVALID_HANDLE
;
ike_params
.
pSeedData
=
(
CK_BYTE_PTR
)
ike_sha256_known_plain_text
;
ike_params
.
ulSeedDataLen
=
sizeof
(
ike_sha256_known_plain_text
)
;
crv
=
sftk_ike_prf_plus_raw
(
CK_INVALID_HANDLE
ike_sha256_known_key
sizeof
(
ike_sha256_known_key
)
&
ike_params
&
outKeyData
&
outKeySize
64
)
;
if
(
(
crv
!
=
CKR_OK
)
|
|
(
outKeySize
!
=
sizeof
(
ike_known_sha256_prf_plus
)
)
|
|
(
PORT_Memcmp
(
outKeyData
ike_known_sha256_prf_plus
sizeof
(
ike_known_sha256_prf_plus
)
)
!
=
0
)
)
{
PORT_ZFree
(
outKeyData
outKeySize
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
PORT_ZFree
(
outKeyData
outKeySize
)
;
return
rv
;
}
