#
include
"
pkcs1sig
.
h
"
#
include
"
hasht
.
h
"
#
include
"
secerr
.
h
"
#
include
"
secasn1t
.
h
"
#
include
"
secoid
.
h
"
typedef
struct
pkcs1PrefixStr
pkcs1Prefix
;
struct
pkcs1PrefixStr
{
unsigned
int
len
;
PRUint8
*
data
;
}
;
#
define
MAX_PREFIX_LEN_EXCLUDING_OID
10
static
SECStatus
encodePrefix
(
const
SECOidData
*
hashOid
unsigned
int
digestLen
pkcs1Prefix
*
prefix
PRBool
withParams
)
{
unsigned
int
innerSeqLen
=
2
+
hashOid
-
>
oid
.
len
;
unsigned
int
outerSeqLen
=
2
+
innerSeqLen
+
2
+
digestLen
;
unsigned
int
extra
=
0
;
if
(
withParams
)
{
innerSeqLen
+
=
2
;
outerSeqLen
+
=
2
;
extra
=
2
;
}
if
(
innerSeqLen
>
=
128
|
|
outerSeqLen
>
=
128
|
|
(
outerSeqLen
+
2
-
digestLen
)
>
(
MAX_PREFIX_LEN_EXCLUDING_OID
+
hashOid
-
>
oid
.
len
)
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
prefix
-
>
len
=
6
+
hashOid
-
>
oid
.
len
+
extra
+
2
;
prefix
-
>
data
=
PORT_Alloc
(
prefix
-
>
len
)
;
if
(
!
prefix
-
>
data
)
{
PORT_SetError
(
SEC_ERROR_NO_MEMORY
)
;
return
SECFailure
;
}
prefix
-
>
data
[
0
]
=
SEC_ASN1_SEQUENCE
|
SEC_ASN1_CONSTRUCTED
;
prefix
-
>
data
[
1
]
=
outerSeqLen
;
prefix
-
>
data
[
2
]
=
SEC_ASN1_SEQUENCE
|
SEC_ASN1_CONSTRUCTED
;
prefix
-
>
data
[
3
]
=
innerSeqLen
;
prefix
-
>
data
[
4
]
=
SEC_ASN1_OBJECT_ID
;
prefix
-
>
data
[
5
]
=
hashOid
-
>
oid
.
len
;
PORT_Memcpy
(
&
prefix
-
>
data
[
6
]
hashOid
-
>
oid
.
data
hashOid
-
>
oid
.
len
)
;
if
(
withParams
)
{
prefix
-
>
data
[
6
+
hashOid
-
>
oid
.
len
]
=
SEC_ASN1_NULL
;
prefix
-
>
data
[
6
+
hashOid
-
>
oid
.
len
+
1
]
=
0
;
}
prefix
-
>
data
[
6
+
hashOid
-
>
oid
.
len
+
extra
]
=
SEC_ASN1_OCTET_STRING
;
prefix
-
>
data
[
6
+
hashOid
-
>
oid
.
len
+
extra
+
1
]
=
digestLen
;
return
SECSuccess
;
}
SECStatus
_SGN_VerifyPKCS1DigestInfo
(
SECOidTag
digestAlg
const
SECItem
*
digest
const
SECItem
*
dataRecoveredFromSignature
PRBool
unsafeAllowMissingParameters
)
{
SECOidData
*
hashOid
;
pkcs1Prefix
prefix
;
SECStatus
rv
;
if
(
!
digest
|
|
!
digest
-
>
data
|
|
!
dataRecoveredFromSignature
|
|
!
dataRecoveredFromSignature
-
>
data
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
hashOid
=
SECOID_FindOIDByTag
(
digestAlg
)
;
if
(
hashOid
=
=
NULL
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
prefix
.
data
=
NULL
;
rv
=
encodePrefix
(
hashOid
digest
-
>
len
&
prefix
PR_TRUE
)
;
if
(
rv
=
=
SECSuccess
)
{
if
(
dataRecoveredFromSignature
-
>
len
!
=
prefix
.
len
+
digest
-
>
len
)
{
PRBool
lengthMismatch
=
PR_TRUE
;
#
ifdef
NSS_PKCS1_AllowMissingParameters
if
(
unsafeAllowMissingParameters
)
{
if
(
prefix
.
data
)
{
PORT_Free
(
prefix
.
data
)
;
prefix
.
data
=
NULL
;
}
rv
=
encodePrefix
(
hashOid
digest
-
>
len
&
prefix
PR_FALSE
)
;
if
(
rv
!
=
SECSuccess
|
|
dataRecoveredFromSignature
-
>
len
=
=
prefix
.
len
+
digest
-
>
len
)
{
lengthMismatch
=
PR_FALSE
;
}
}
#
endif
if
(
lengthMismatch
)
{
PORT_SetError
(
SEC_ERROR_BAD_SIGNATURE
)
;
rv
=
SECFailure
;
}
}
}
if
(
rv
=
=
SECSuccess
)
{
if
(
memcmp
(
dataRecoveredFromSignature
-
>
data
prefix
.
data
prefix
.
len
)
|
|
memcmp
(
dataRecoveredFromSignature
-
>
data
+
prefix
.
len
digest
-
>
data
digest
-
>
len
)
)
{
PORT_SetError
(
SEC_ERROR_BAD_SIGNATURE
)
;
rv
=
SECFailure
;
}
}
if
(
prefix
.
data
)
{
PORT_Free
(
prefix
.
data
)
;
}
return
rv
;
}
