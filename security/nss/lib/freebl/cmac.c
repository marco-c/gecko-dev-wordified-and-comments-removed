#
ifdef
FREEBL_NO_DEPEND
#
include
"
stubs
.
h
"
#
endif
#
include
"
rijndael
.
h
"
#
include
"
blapi
.
h
"
#
include
"
cmac
.
h
"
#
include
"
secerr
.
h
"
#
include
"
nspr
.
h
"
struct
CMACContextStr
{
CMACCipher
cipherType
;
union
{
AESContext
*
aes
;
}
cipher
;
int
blockSize
;
unsigned
char
k1
[
MAX_BLOCK_SIZE
]
;
unsigned
char
k2
[
MAX_BLOCK_SIZE
]
;
unsigned
int
partialIndex
;
unsigned
char
partialBlock
[
MAX_BLOCK_SIZE
]
;
unsigned
char
lastBlock
[
MAX_BLOCK_SIZE
]
;
}
;
static
void
cmac_ShiftLeftOne
(
unsigned
char
*
out
const
unsigned
char
*
in
int
length
)
{
int
i
=
0
;
for
(
;
i
<
length
-
1
;
i
+
+
)
{
out
[
i
]
=
in
[
i
]
<
<
1
;
out
[
i
]
|
=
in
[
i
+
1
]
>
>
7
;
}
out
[
i
]
=
in
[
i
]
<
<
1
;
}
static
SECStatus
cmac_Encrypt
(
CMACContext
*
ctx
unsigned
char
*
output
const
unsigned
char
*
input
unsigned
int
inputLen
)
{
if
(
ctx
-
>
cipherType
=
=
CMAC_AES
)
{
unsigned
int
tmpOutputLen
;
SECStatus
rv
=
AES_Encrypt
(
ctx
-
>
cipher
.
aes
output
&
tmpOutputLen
ctx
-
>
blockSize
input
inputLen
)
;
PORT_Assert
(
tmpOutputLen
=
=
ctx
-
>
blockSize
)
;
return
rv
;
}
return
SECFailure
;
}
static
SECStatus
cmac_GenerateSubkeys
(
CMACContext
*
ctx
)
{
unsigned
char
null_block
[
MAX_BLOCK_SIZE
]
=
{
0
}
;
unsigned
char
L
[
MAX_BLOCK_SIZE
]
;
unsigned
char
v
;
unsigned
char
i
;
if
(
cmac_Encrypt
(
ctx
L
null_block
ctx
-
>
blockSize
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
cmac_ShiftLeftOne
(
ctx
-
>
k1
L
ctx
-
>
blockSize
)
;
v
=
L
[
0
]
>
>
7
;
for
(
i
=
1
;
i
<
=
7
;
i
<
<
=
1
)
{
v
|
=
(
v
<
<
i
)
;
}
ctx
-
>
k1
[
ctx
-
>
blockSize
-
1
]
^
=
(
0x87
&
v
)
;
cmac_ShiftLeftOne
(
ctx
-
>
k2
ctx
-
>
k1
ctx
-
>
blockSize
)
;
v
=
ctx
-
>
k1
[
0
]
>
>
7
;
for
(
i
=
1
;
i
<
=
7
;
i
<
<
=
1
)
{
v
|
=
(
v
<
<
i
)
;
}
ctx
-
>
k2
[
ctx
-
>
blockSize
-
1
]
^
=
(
0x87
&
v
)
;
PORT_Memset
(
null_block
0
MAX_BLOCK_SIZE
)
;
PORT_Memset
(
L
0
MAX_BLOCK_SIZE
)
;
return
SECSuccess
;
}
static
SECStatus
cmac_UpdateState
(
CMACContext
*
ctx
)
{
if
(
ctx
=
=
NULL
|
|
ctx
-
>
partialIndex
!
=
ctx
-
>
blockSize
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
for
(
unsigned
int
index
=
0
;
index
<
ctx
-
>
blockSize
;
index
+
+
)
{
ctx
-
>
partialBlock
[
index
]
^
=
ctx
-
>
lastBlock
[
index
]
;
}
return
cmac_Encrypt
(
ctx
ctx
-
>
lastBlock
ctx
-
>
partialBlock
ctx
-
>
blockSize
)
;
}
SECStatus
CMAC_Init
(
CMACContext
*
ctx
CMACCipher
type
const
unsigned
char
*
key
unsigned
int
key_len
)
{
if
(
ctx
=
=
NULL
)
{
PORT_SetError
(
SEC_ERROR_NO_MEMORY
)
;
return
SECFailure
;
}
if
(
type
!
=
CMAC_AES
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
PORT_Memset
(
ctx
0
sizeof
(
*
ctx
)
)
;
ctx
-
>
blockSize
=
AES_BLOCK_SIZE
;
ctx
-
>
cipherType
=
CMAC_AES
;
ctx
-
>
cipher
.
aes
=
AES_CreateContext
(
key
NULL
NSS_AES
1
key_len
ctx
-
>
blockSize
)
;
if
(
ctx
-
>
cipher
.
aes
=
=
NULL
)
{
return
SECFailure
;
}
return
CMAC_Begin
(
ctx
)
;
}
CMACContext
*
CMAC_Create
(
CMACCipher
type
const
unsigned
char
*
key
unsigned
int
key_len
)
{
CMACContext
*
result
=
PORT_New
(
CMACContext
)
;
if
(
CMAC_Init
(
result
type
key
key_len
)
!
=
SECSuccess
)
{
CMAC_Destroy
(
result
PR_TRUE
)
;
return
NULL
;
}
return
result
;
}
SECStatus
CMAC_Begin
(
CMACContext
*
ctx
)
{
if
(
ctx
=
=
NULL
)
{
return
SECFailure
;
}
PORT_Assert
(
ctx
-
>
blockSize
<
=
MAX_BLOCK_SIZE
)
;
if
(
cmac_GenerateSubkeys
(
ctx
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
ctx
-
>
partialIndex
=
0
;
PORT_Memset
(
ctx
-
>
lastBlock
0
ctx
-
>
blockSize
)
;
return
SECSuccess
;
}
SECStatus
CMAC_Update
(
CMACContext
*
ctx
const
unsigned
char
*
data
unsigned
int
data_len
)
{
int
data_index
=
0
;
if
(
ctx
=
=
NULL
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
data
=
=
NULL
|
|
data_len
=
=
0
)
{
return
SECSuccess
;
}
while
(
data_index
<
data_len
)
{
if
(
ctx
-
>
partialIndex
=
=
ctx
-
>
blockSize
)
{
if
(
cmac_UpdateState
(
ctx
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
ctx
-
>
partialIndex
=
0
;
}
unsigned
int
copy_len
=
data_len
-
data_index
;
if
(
copy_len
>
(
ctx
-
>
blockSize
-
ctx
-
>
partialIndex
)
)
{
copy_len
=
ctx
-
>
blockSize
-
ctx
-
>
partialIndex
;
}
PORT_Memcpy
(
ctx
-
>
partialBlock
+
ctx
-
>
partialIndex
data
+
data_index
copy_len
)
;
data_index
+
=
copy_len
;
ctx
-
>
partialIndex
+
=
copy_len
;
}
return
SECSuccess
;
}
SECStatus
CMAC_Finish
(
CMACContext
*
ctx
unsigned
char
*
result
unsigned
int
*
result_len
unsigned
int
max_result_len
)
{
if
(
ctx
=
=
NULL
|
|
result
=
=
NULL
|
|
max_result_len
=
=
0
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
max_result_len
>
ctx
-
>
blockSize
)
{
max_result_len
=
ctx
-
>
blockSize
;
}
if
(
ctx
-
>
partialIndex
=
=
ctx
-
>
blockSize
)
{
for
(
unsigned
int
index
=
0
;
index
<
ctx
-
>
blockSize
;
index
+
+
)
{
ctx
-
>
partialBlock
[
index
]
^
=
ctx
-
>
k1
[
index
]
;
}
}
else
{
ctx
-
>
partialBlock
[
ctx
-
>
partialIndex
+
+
]
=
0x80
;
PORT_Memset
(
ctx
-
>
partialBlock
+
ctx
-
>
partialIndex
0
ctx
-
>
blockSize
-
ctx
-
>
partialIndex
)
;
ctx
-
>
partialIndex
=
ctx
-
>
blockSize
;
for
(
unsigned
int
index
=
0
;
index
<
ctx
-
>
blockSize
;
index
+
+
)
{
ctx
-
>
partialBlock
[
index
]
^
=
ctx
-
>
k2
[
index
]
;
}
}
if
(
cmac_UpdateState
(
ctx
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
PORT_Memcpy
(
result
ctx
-
>
lastBlock
max_result_len
)
;
if
(
result_len
!
=
NULL
)
{
*
result_len
=
max_result_len
;
}
return
SECSuccess
;
}
void
CMAC_Destroy
(
CMACContext
*
ctx
PRBool
free_it
)
{
if
(
ctx
=
=
NULL
)
{
return
;
}
if
(
ctx
-
>
cipherType
=
=
CMAC_AES
&
&
ctx
-
>
cipher
.
aes
!
=
NULL
)
{
AES_DestroyContext
(
ctx
-
>
cipher
.
aes
PR_TRUE
)
;
}
PORT_Memset
(
ctx
0
sizeof
(
*
ctx
)
)
;
if
(
free_it
=
=
PR_TRUE
)
{
PORT_Free
(
ctx
)
;
}
}
