#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
include
<
errno
.
h
>
#
include
"
secerr
.
h
"
#
include
"
secrng
.
h
"
#
include
"
prprf
.
h
"
#
define
GETENTROPY_MAX_BYTES
256
void
RNG_SystemInfoForRNG
(
void
)
{
PRUint8
bytes
[
SYSTEM_RNG_SEED_COUNT
]
;
size_t
numBytes
=
RNG_SystemRNG
(
bytes
SYSTEM_RNG_SEED_COUNT
)
;
if
(
!
numBytes
)
{
return
;
}
RNG_RandomUpdate
(
bytes
numBytes
)
;
}
size_t
RNG_SystemRNG
(
void
*
dest
size_t
maxLen
)
{
int
fd
;
int
bytes
;
size_t
fileBytes
=
0
;
unsigned
char
*
buffer
=
dest
;
#
if
defined
(
__OpenBSD__
)
|
|
(
defined
(
__FreeBSD__
)
&
&
__FreeBSD_version
>
=
1200000
)
|
|
(
defined
(
LINUX
)
&
&
defined
(
__GLIBC__
)
&
&
(
(
__GLIBC__
>
2
)
|
|
(
(
__GLIBC__
=
=
2
)
&
&
(
__GLIBC_MINOR__
>
=
25
)
)
)
)
int
result
;
while
(
fileBytes
<
maxLen
)
{
size_t
getBytes
=
maxLen
-
fileBytes
;
if
(
getBytes
>
GETENTROPY_MAX_BYTES
)
{
getBytes
=
GETENTROPY_MAX_BYTES
;
}
result
=
getentropy
(
buffer
getBytes
)
;
if
(
result
=
=
0
)
{
fileBytes
+
=
getBytes
;
buffer
+
=
getBytes
;
}
else
{
break
;
}
}
if
(
fileBytes
=
=
maxLen
)
{
return
maxLen
;
}
if
(
errno
!
=
ENOSYS
)
{
PORT_SetError
(
SEC_ERROR_NEED_RANDOM
)
;
return
0
;
}
fileBytes
=
0
;
#
endif
fd
=
open
(
"
/
dev
/
urandom
"
O_RDONLY
)
;
if
(
fd
<
0
)
{
PORT_SetError
(
SEC_ERROR_NEED_RANDOM
)
;
return
0
;
}
while
(
fileBytes
<
maxLen
)
{
bytes
=
read
(
fd
buffer
maxLen
-
fileBytes
)
;
if
(
bytes
<
=
0
)
{
break
;
}
fileBytes
+
=
bytes
;
buffer
+
=
bytes
;
}
(
void
)
close
(
fd
)
;
if
(
fileBytes
!
=
maxLen
)
{
PORT_SetError
(
SEC_ERROR_NEED_RANDOM
)
;
return
0
;
}
return
fileBytes
;
}
