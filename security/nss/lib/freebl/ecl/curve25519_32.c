#
include
"
ecl
-
priv
.
h
"
#
include
"
mpi
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
typedef
uint32_t
elem
[
32
]
;
static
void
add
(
elem
out
const
elem
a
const
elem
b
)
{
uint32_t
j
;
uint32_t
u
=
0
;
for
(
j
=
0
;
j
<
31
;
+
+
j
)
{
u
+
=
a
[
j
]
+
b
[
j
]
;
out
[
j
]
=
u
&
0xFF
;
u
>
>
=
8
;
}
u
+
=
a
[
31
]
+
b
[
31
]
;
out
[
31
]
=
u
;
}
static
void
sub
(
elem
out
const
elem
a
const
elem
b
)
{
uint32_t
j
;
uint32_t
u
;
u
=
218
;
for
(
j
=
0
;
j
<
31
;
+
+
j
)
{
u
+
=
a
[
j
]
+
0xFF00
-
b
[
j
]
;
out
[
j
]
=
u
&
0xFF
;
u
>
>
=
8
;
}
u
+
=
a
[
31
]
-
b
[
31
]
;
out
[
31
]
=
u
;
}
static
void
squeeze
(
elem
a
)
{
uint32_t
j
;
uint32_t
u
;
u
=
0
;
for
(
j
=
0
;
j
<
31
;
+
+
j
)
{
u
+
=
a
[
j
]
;
a
[
j
]
=
u
&
0xFF
;
u
>
>
=
8
;
}
u
+
=
a
[
31
]
;
a
[
31
]
=
u
&
0x7F
;
u
=
19
*
(
u
>
>
7
)
;
for
(
j
=
0
;
j
<
31
;
+
+
j
)
{
u
+
=
a
[
j
]
;
a
[
j
]
=
u
&
0xFF
;
u
>
>
=
8
;
}
a
[
31
]
+
=
u
;
}
static
const
elem
minusp
=
{
19
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
128
}
;
static
void
reduce
(
elem
a
)
{
elem
aorig
;
uint32_t
j
;
uint32_t
negative
;
for
(
j
=
0
;
j
<
32
;
+
+
j
)
{
aorig
[
j
]
=
a
[
j
]
;
}
add
(
a
a
minusp
)
;
negative
=
1
+
~
(
(
a
[
31
]
>
>
7
)
&
1
)
;
for
(
j
=
0
;
j
<
32
;
+
+
j
)
{
a
[
j
]
^
=
negative
&
(
aorig
[
j
]
^
a
[
j
]
)
;
}
}
static
void
mult
(
elem
out
const
elem
a
const
elem
b
)
{
uint32_t
i
;
uint32_t
j
;
uint32_t
u
;
for
(
i
=
0
;
i
<
32
;
+
+
i
)
{
u
=
0
;
for
(
j
=
0
;
j
<
=
i
;
+
+
j
)
{
u
+
=
a
[
j
]
*
b
[
i
-
j
]
;
}
for
(
j
=
i
+
1
;
j
<
32
;
+
+
j
)
{
u
+
=
38
*
a
[
j
]
*
b
[
i
+
32
-
j
]
;
}
out
[
i
]
=
u
;
}
squeeze
(
out
)
;
}
static
void
mult121665
(
elem
out
const
elem
a
)
{
uint32_t
j
;
uint32_t
u
;
u
=
0
;
for
(
j
=
0
;
j
<
31
;
+
+
j
)
{
u
+
=
121665
*
a
[
j
]
;
out
[
j
]
=
u
&
0xFF
;
u
>
>
=
8
;
}
u
+
=
121665
*
a
[
31
]
;
out
[
31
]
=
u
&
0x7F
;
u
=
19
*
(
u
>
>
7
)
;
for
(
j
=
0
;
j
<
31
;
+
+
j
)
{
u
+
=
out
[
j
]
;
out
[
j
]
=
u
&
0xFF
;
u
>
>
=
8
;
}
u
+
=
out
[
j
]
;
out
[
j
]
=
u
;
}
static
void
square
(
elem
out
const
elem
a
)
{
uint32_t
i
;
uint32_t
j
;
uint32_t
u
;
for
(
i
=
0
;
i
<
32
;
+
+
i
)
{
u
=
0
;
for
(
j
=
0
;
j
<
i
-
j
;
+
+
j
)
{
u
+
=
a
[
j
]
*
a
[
i
-
j
]
;
}
for
(
j
=
i
+
1
;
j
<
i
+
32
-
j
;
+
+
j
)
{
u
+
=
38
*
a
[
j
]
*
a
[
i
+
32
-
j
]
;
}
u
*
=
2
;
if
(
(
i
&
1
)
=
=
0
)
{
u
+
=
a
[
i
/
2
]
*
a
[
i
/
2
]
;
u
+
=
38
*
a
[
i
/
2
+
16
]
*
a
[
i
/
2
+
16
]
;
}
out
[
i
]
=
u
;
}
squeeze
(
out
)
;
}
static
void
cswap
(
uint32_t
p
[
64
]
uint32_t
q
[
64
]
uint32_t
b
)
{
uint32_t
j
;
uint32_t
swap
=
1
+
~
b
;
for
(
j
=
0
;
j
<
64
;
+
+
j
)
{
const
uint32_t
t
=
swap
&
(
p
[
j
]
^
q
[
j
]
)
;
p
[
j
]
^
=
t
;
q
[
j
]
^
=
t
;
}
}
static
void
monty
(
elem
x_2_out
elem
z_2_out
const
elem
point
const
elem
scalar
)
{
uint32_t
x_3
[
64
]
=
{
0
}
;
uint32_t
x_2
[
64
]
=
{
0
}
;
uint32_t
a0
[
64
]
;
uint32_t
a1
[
64
]
;
uint32_t
b0
[
64
]
;
uint32_t
b1
[
64
]
;
uint32_t
c1
[
64
]
;
uint32_t
r
[
32
]
;
uint32_t
s
[
32
]
;
uint32_t
t
[
32
]
;
uint32_t
u
[
32
]
;
uint32_t
swap
=
0
;
uint32_t
k_t
=
0
;
int
j
;
for
(
j
=
0
;
j
<
32
;
+
+
j
)
{
x_3
[
j
]
=
point
[
j
]
;
}
x_3
[
32
]
=
1
;
x_2
[
0
]
=
1
;
for
(
j
=
254
;
j
>
=
0
;
-
-
j
)
{
k_t
=
(
scalar
[
j
>
>
3
]
>
>
(
j
&
7
)
)
&
1
;
swap
^
=
k_t
;
cswap
(
x_2
x_3
swap
)
;
swap
=
k_t
;
add
(
a0
x_2
x_2
+
32
)
;
sub
(
a0
+
32
x_2
x_2
+
32
)
;
add
(
a1
x_3
x_3
+
32
)
;
sub
(
a1
+
32
x_3
x_3
+
32
)
;
square
(
b0
a0
)
;
square
(
b0
+
32
a0
+
32
)
;
mult
(
b1
a1
a0
+
32
)
;
mult
(
b1
+
32
a1
+
32
a0
)
;
add
(
c1
b1
b1
+
32
)
;
sub
(
c1
+
32
b1
b1
+
32
)
;
square
(
r
c1
+
32
)
;
sub
(
s
b0
b0
+
32
)
;
mult121665
(
t
s
)
;
add
(
u
t
b0
)
;
mult
(
x_2
b0
b0
+
32
)
;
mult
(
x_2
+
32
s
u
)
;
square
(
x_3
c1
)
;
mult
(
x_3
+
32
r
point
)
;
}
cswap
(
x_2
x_3
swap
)
;
for
(
j
=
0
;
j
<
32
;
+
+
j
)
{
x_2_out
[
j
]
=
x_2
[
j
]
;
}
for
(
j
=
0
;
j
<
32
;
+
+
j
)
{
z_2_out
[
j
]
=
x_2
[
j
+
32
]
;
}
}
static
void
recip
(
elem
out
const
elem
z
)
{
elem
z2
;
elem
z9
;
elem
z11
;
elem
z2_5_0
;
elem
z2_10_0
;
elem
z2_20_0
;
elem
z2_50_0
;
elem
z2_100_0
;
elem
t0
;
elem
t1
;
int
i
;
square
(
z2
z
)
;
square
(
t1
z2
)
;
square
(
t0
t1
)
;
mult
(
z9
t0
z
)
;
mult
(
z11
z9
z2
)
;
square
(
t0
z11
)
;
mult
(
z2_5_0
t0
z9
)
;
square
(
t0
z2_5_0
)
;
square
(
t1
t0
)
;
square
(
t0
t1
)
;
square
(
t1
t0
)
;
square
(
t0
t1
)
;
mult
(
z2_10_0
t0
z2_5_0
)
;
square
(
t0
z2_10_0
)
;
square
(
t1
t0
)
;
for
(
i
=
2
;
i
<
10
;
i
+
=
2
)
{
square
(
t0
t1
)
;
square
(
t1
t0
)
;
}
mult
(
z2_20_0
t1
z2_10_0
)
;
square
(
t0
z2_20_0
)
;
square
(
t1
t0
)
;
for
(
i
=
2
;
i
<
20
;
i
+
=
2
)
{
square
(
t0
t1
)
;
square
(
t1
t0
)
;
}
mult
(
t0
t1
z2_20_0
)
;
square
(
t1
t0
)
;
square
(
t0
t1
)
;
for
(
i
=
2
;
i
<
10
;
i
+
=
2
)
{
square
(
t1
t0
)
;
square
(
t0
t1
)
;
}
mult
(
z2_50_0
t0
z2_10_0
)
;
square
(
t0
z2_50_0
)
;
square
(
t1
t0
)
;
for
(
i
=
2
;
i
<
50
;
i
+
=
2
)
{
square
(
t0
t1
)
;
square
(
t1
t0
)
;
}
mult
(
z2_100_0
t1
z2_50_0
)
;
square
(
t1
z2_100_0
)
;
square
(
t0
t1
)
;
for
(
i
=
2
;
i
<
100
;
i
+
=
2
)
{
square
(
t1
t0
)
;
square
(
t0
t1
)
;
}
mult
(
t1
t0
z2_100_0
)
;
square
(
t0
t1
)
;
square
(
t1
t0
)
;
for
(
i
=
2
;
i
<
50
;
i
+
=
2
)
{
square
(
t0
t1
)
;
square
(
t1
t0
)
;
}
mult
(
t0
t1
z2_50_0
)
;
square
(
t1
t0
)
;
square
(
t0
t1
)
;
square
(
t1
t0
)
;
square
(
t0
t1
)
;
square
(
t1
t0
)
;
mult
(
out
t1
z11
)
;
}
SECStatus
ec_Curve25519_mul
(
PRUint8
*
q
const
PRUint8
*
s
const
PRUint8
*
p
)
{
elem
point
=
{
0
}
;
elem
x_2
=
{
0
}
;
elem
z_2
=
{
0
}
;
elem
X
=
{
0
}
;
elem
scalar
=
{
0
}
;
uint32_t
i
;
for
(
i
=
0
;
i
<
32
;
+
+
i
)
{
scalar
[
i
]
=
s
[
i
]
;
}
scalar
[
0
]
&
=
0xF8
;
scalar
[
31
]
&
=
0x7F
;
scalar
[
31
]
|
=
64
;
for
(
i
=
0
;
i
<
32
;
+
+
i
)
{
point
[
i
]
=
p
[
i
]
;
}
point
[
31
]
&
=
0x7F
;
monty
(
x_2
z_2
point
scalar
)
;
recip
(
z_2
z_2
)
;
mult
(
X
x_2
z_2
)
;
reduce
(
X
)
;
for
(
i
=
0
;
i
<
32
;
+
+
i
)
{
q
[
i
]
=
X
[
i
]
;
}
return
0
;
}
