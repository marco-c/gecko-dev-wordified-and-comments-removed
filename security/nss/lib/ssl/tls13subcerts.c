#
include
"
nss
.
h
"
#
include
"
pk11func
.
h
"
#
include
"
secder
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslproto
.
h
"
#
include
"
sslimpl
.
h
"
#
include
"
ssl3exthandle
.
h
"
#
include
"
tls13exthandle
.
h
"
#
include
"
tls13hkdf
.
h
"
#
include
"
tls13subcerts
.
h
"
SECStatus
tls13_ReadDelegatedCredential
(
PRUint8
*
b
PRUint32
length
sslDelegatedCredential
*
*
dcp
)
{
sslDelegatedCredential
*
dc
=
NULL
;
SECStatus
rv
;
PRUint64
n
;
sslReadBuffer
tmp
;
sslReader
rdr
=
SSL_READER
(
b
length
)
;
PORT_Assert
(
!
*
dcp
)
;
dc
=
PORT_ZNew
(
sslDelegatedCredential
)
;
if
(
!
dc
)
{
PORT_SetError
(
SEC_ERROR_NO_MEMORY
)
;
goto
loser
;
}
rv
=
sslRead_ReadNumber
(
&
rdr
4
&
n
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
dc
-
>
validTime
=
n
;
rv
=
sslRead_ReadNumber
(
&
rdr
2
&
n
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
dc
-
>
expectedCertVerifyAlg
=
n
;
rv
=
sslRead_ReadVariable
(
&
rdr
3
&
tmp
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
SECITEM_MakeItem
(
NULL
&
dc
-
>
derSpki
tmp
.
buf
tmp
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
dc
-
>
spki
=
SECKEY_DecodeDERSubjectPublicKeyInfo
(
&
dc
-
>
derSpki
)
;
if
(
!
dc
-
>
spki
)
{
goto
loser
;
}
rv
=
sslRead_ReadNumber
(
&
rdr
2
&
n
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
dc
-
>
alg
=
n
;
rv
=
sslRead_ReadVariable
(
&
rdr
2
&
tmp
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
SECITEM_MakeItem
(
NULL
&
dc
-
>
signature
tmp
.
buf
tmp
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
SSL_READER_REMAINING
(
&
rdr
)
>
0
)
{
goto
loser
;
}
*
dcp
=
dc
;
return
SECSuccess
;
loser
:
tls13_DestroyDelegatedCredential
(
dc
)
;
*
dcp
=
NULL
;
return
SECFailure
;
}
void
tls13_DestroyDelegatedCredential
(
sslDelegatedCredential
*
dc
)
{
if
(
!
dc
)
{
return
;
}
SECKEY_DestroySubjectPublicKeyInfo
(
dc
-
>
spki
)
;
SECITEM_FreeItem
(
&
dc
-
>
derSpki
PR_FALSE
)
;
SECITEM_FreeItem
(
&
dc
-
>
signature
PR_FALSE
)
;
PORT_ZFree
(
dc
sizeof
(
sslDelegatedCredential
)
)
;
}
static
SECStatus
tls13_GetExpectedCertVerifyAlg
(
SECItem
in
SSLSignatureScheme
*
certVerifyAlg
)
{
SECStatus
rv
;
PRUint64
n
;
sslReader
rdr
=
SSL_READER
(
in
.
data
in
.
len
)
;
if
(
in
.
len
<
6
)
{
return
SECFailure
;
}
rv
=
sslRead_ReadNumber
(
&
rdr
4
&
n
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslRead_ReadNumber
(
&
rdr
2
&
n
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
certVerifyAlg
=
n
;
return
SECSuccess
;
}
PRBool
tls13_IsVerifyingWithDelegatedCredential
(
const
sslSocket
*
ss
)
{
if
(
ss
-
>
sec
.
isServer
|
|
!
ss
-
>
opt
.
enableDelegatedCredentials
|
|
!
ss
-
>
xtnData
.
peerDelegCred
)
{
return
PR_FALSE
;
}
return
PR_TRUE
;
}
PRBool
tls13_IsSigningWithDelegatedCredential
(
const
sslSocket
*
ss
)
{
if
(
!
ss
-
>
sec
.
isServer
|
|
!
ss
-
>
xtnData
.
sendingDelegCredToPeer
|
|
!
ss
-
>
xtnData
.
peerRequestedDelegCred
)
{
return
PR_FALSE
;
}
return
PR_TRUE
;
}
SECStatus
tls13_MaybeSetDelegatedCredential
(
sslSocket
*
ss
)
{
SECStatus
rv
;
PRBool
doesRsaPss
;
SECKEYPrivateKey
*
priv
;
SSLSignatureScheme
scheme
;
PORT_Assert
(
ss
-
>
sec
.
isServer
)
;
PORT_Assert
(
ss
-
>
sec
.
serverCert
)
;
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
PORT_Assert
(
ss
-
>
xtnData
.
sigSchemes
)
;
if
(
!
ss
-
>
xtnData
.
peerRequestedDelegCred
|
|
!
ss
-
>
sec
.
serverCert
-
>
delegCred
.
len
|
|
!
ss
-
>
sec
.
serverCert
-
>
delegCredKeyPair
)
{
return
SECSuccess
;
}
rv
=
tls13_GetExpectedCertVerifyAlg
(
ss
-
>
sec
.
serverCert
-
>
delegCred
&
scheme
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
priv
=
ss
-
>
sec
.
serverCert
-
>
delegCredKeyPair
-
>
privKey
;
rv
=
ssl_PrivateKeySupportsRsaPss
(
priv
&
doesRsaPss
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
!
ssl_SignatureSchemeEnabled
(
ss
scheme
)
|
|
!
ssl_CanUseSignatureScheme
(
scheme
ss
-
>
xtnData
.
sigSchemes
ss
-
>
xtnData
.
numSigSchemes
PR_FALSE
doesRsaPss
)
)
{
return
SECSuccess
;
}
ss
-
>
xtnData
.
sendingDelegCredToPeer
=
PR_TRUE
;
ss
-
>
ssl3
.
hs
.
signatureScheme
=
scheme
;
return
SECSuccess
;
}
static
SECStatus
tls13_AppendCredentialParams
(
sslBuffer
*
buf
sslDelegatedCredential
*
dc
)
{
SECStatus
rv
;
rv
=
sslBuffer_AppendNumber
(
buf
dc
-
>
validTime
4
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslBuffer_AppendNumber
(
buf
dc
-
>
expectedCertVerifyAlg
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslBuffer_AppendVariable
(
buf
dc
-
>
derSpki
.
data
dc
-
>
derSpki
.
len
3
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslBuffer_AppendNumber
(
buf
dc
-
>
alg
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
return
SECSuccess
;
}
static
SECStatus
tls13_AppendCredentialSignature
(
sslBuffer
*
buf
sslDelegatedCredential
*
dc
)
{
SECStatus
rv
;
rv
=
sslBuffer_AppendVariable
(
buf
dc
-
>
signature
.
data
dc
-
>
signature
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
return
SECSuccess
;
}
static
SECStatus
tls13_HashCredentialSignatureMessage
(
SSL3Hashes
*
hash
SSLSignatureScheme
scheme
const
CERTCertificate
*
cert
const
sslBuffer
*
dcBuf
)
{
SECStatus
rv
;
PK11Context
*
ctx
=
NULL
;
unsigned
int
hashLen
;
hash
-
>
hashAlg
=
ssl_SignatureSchemeToHashType
(
scheme
)
;
ctx
=
PK11_CreateDigestContext
(
ssl3_HashTypeToOID
(
hash
-
>
hashAlg
)
)
;
if
(
!
ctx
)
{
PORT_SetError
(
SEC_ERROR_NO_MEMORY
)
;
goto
loser
;
}
static
const
PRUint8
kCtxStrPadding
[
64
]
=
{
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
}
;
static
const
PRUint8
kCtxStr
[
]
=
"
TLS
server
delegated
credentials
"
;
rv
=
SECSuccess
;
rv
|
=
PK11_DigestBegin
(
ctx
)
;
rv
|
=
PK11_DigestOp
(
ctx
kCtxStrPadding
sizeof
kCtxStrPadding
)
;
rv
|
=
PK11_DigestOp
(
ctx
kCtxStr
1
+
strlen
(
(
const
char
*
)
kCtxStr
)
)
;
rv
|
=
PK11_DigestOp
(
ctx
cert
-
>
derCert
.
data
cert
-
>
derCert
.
len
)
;
rv
|
=
PK11_DigestOp
(
ctx
dcBuf
-
>
buf
dcBuf
-
>
len
)
;
rv
|
=
PK11_DigestFinal
(
ctx
hash
-
>
u
.
raw
&
hashLen
sizeof
hash
-
>
u
.
raw
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SSL_ERROR_SHA_DIGEST_FAILURE
)
;
goto
loser
;
}
hash
-
>
len
=
hashLen
;
if
(
ctx
)
{
PK11_DestroyContext
(
ctx
PR_TRUE
)
;
}
return
SECSuccess
;
loser
:
if
(
ctx
)
{
PK11_DestroyContext
(
ctx
PR_TRUE
)
;
}
return
SECFailure
;
}
static
SECStatus
tls13_VerifyCredentialSignature
(
sslSocket
*
ss
sslDelegatedCredential
*
dc
)
{
SECStatus
rv
=
SECSuccess
;
SSL3Hashes
hash
;
sslBuffer
dcBuf
=
SSL_BUFFER_EMPTY
;
CERTCertificate
*
cert
=
ss
-
>
sec
.
peerCert
;
rv
=
tls13_AppendCredentialParams
(
&
dcBuf
dc
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
tls13_HashCredentialSignatureMessage
(
&
hash
dc
-
>
alg
cert
&
dcBuf
)
;
if
(
rv
!
=
SECSuccess
)
{
FATAL_ERROR
(
ss
PORT_GetError
(
)
internal_error
)
;
goto
loser
;
}
rv
=
ssl3_VerifySignedHashesWithSpki
(
ss
&
cert
-
>
subjectPublicKeyInfo
dc
-
>
alg
&
hash
&
dc
-
>
signature
)
;
if
(
rv
!
=
SECSuccess
)
{
FATAL_ERROR
(
ss
SSL_ERROR_DC_BAD_SIGNATURE
illegal_parameter
)
;
goto
loser
;
}
sslBuffer_Clear
(
&
dcBuf
)
;
return
SECSuccess
;
loser
:
sslBuffer_Clear
(
&
dcBuf
)
;
return
SECFailure
;
}
static
SECStatus
tls13_CheckCertDelegationUsage
(
sslSocket
*
ss
)
{
int
i
;
PRBool
found
;
CERTCertExtension
*
ext
;
SECItem
delegUsageOid
=
{
siBuffer
NULL
0
}
;
const
CERTCertificate
*
cert
=
ss
-
>
sec
.
peerCert
;
static
unsigned
char
kDelegationUsageOid
[
]
=
{
0x2b
0x06
0x01
0x04
0x01
0x82
0xda
0x4b
0x2c
}
;
delegUsageOid
.
data
=
kDelegationUsageOid
;
delegUsageOid
.
len
=
sizeof
kDelegationUsageOid
;
found
=
PR_FALSE
;
for
(
i
=
0
;
cert
-
>
extensions
[
i
]
!
=
NULL
;
i
+
+
)
{
ext
=
cert
-
>
extensions
[
i
]
;
if
(
SECITEM_CompareItem
(
&
ext
-
>
id
&
delegUsageOid
)
=
=
SECEqual
)
{
found
=
PR_TRUE
;
break
;
}
}
if
(
!
found
|
|
!
cert
-
>
keyUsagePresent
|
|
!
(
cert
-
>
keyUsage
&
KU_DIGITAL_SIGNATURE
)
)
{
FATAL_ERROR
(
ss
SSL_ERROR_DC_INVALID_KEY_USAGE
illegal_parameter
)
;
return
SECFailure
;
}
return
SECSuccess
;
}
static
SECStatus
tls13_CheckCredentialExpiration
(
sslSocket
*
ss
sslDelegatedCredential
*
dc
)
{
SECStatus
rv
;
PRTime
start
end
;
CERTCertificate
*
cert
=
ss
-
>
sec
.
peerCert
;
rv
=
DER_DecodeTimeChoice
(
&
start
&
cert
-
>
validity
.
notBefore
)
;
if
(
rv
!
=
SECSuccess
)
{
FATAL_ERROR
(
ss
PORT_GetError
(
)
internal_error
)
;
return
SECFailure
;
}
end
=
start
+
(
(
PRTime
)
dc
-
>
validTime
*
PR_USEC_PER_SEC
)
;
if
(
ssl_Time
(
ss
)
>
end
)
{
FATAL_ERROR
(
ss
SSL_ERROR_DC_EXPIRED
illegal_parameter
)
;
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
tls13_VerifyDelegatedCredential
(
sslSocket
*
ss
sslDelegatedCredential
*
dc
)
{
SECStatus
rv
;
PRTime
start
;
PRExplodedTime
end
;
CERTCertificate
*
cert
=
ss
-
>
sec
.
peerCert
;
char
endStr
[
256
]
;
rv
=
DER_DecodeTimeChoice
(
&
start
&
cert
-
>
validity
.
notBefore
)
;
if
(
rv
!
=
SECSuccess
)
{
FATAL_ERROR
(
ss
PORT_GetError
(
)
internal_error
)
;
return
SECFailure
;
}
PR_ExplodeTime
(
start
+
(
dc
-
>
validTime
*
PR_USEC_PER_SEC
)
PR_GMTParameters
&
end
)
;
if
(
PR_FormatTime
(
endStr
sizeof
(
endStr
)
"
%
a
%
b
%
d
%
H
:
%
M
:
%
S
%
Y
"
&
end
)
)
{
SSL_TRC
(
20
(
"
%
d
:
TLS13
[
%
d
]
:
Received
delegated
credential
(
expires
%
s
)
"
SSL_GETPID
(
)
ss
-
>
fd
endStr
)
)
;
}
else
{
SSL_TRC
(
20
(
"
%
d
:
TLS13
[
%
d
]
:
Received
delegated
credential
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
}
rv
=
SECSuccess
;
rv
|
=
tls13_VerifyCredentialSignature
(
ss
dc
)
;
rv
|
=
tls13_CheckCertDelegationUsage
(
ss
)
;
rv
|
=
tls13_CheckCredentialExpiration
(
ss
dc
)
;
return
rv
;
}
SECStatus
SSLExp_DelegateCredential
(
const
CERTCertificate
*
cert
const
SECKEYPrivateKey
*
certPriv
const
SECKEYPublicKey
*
dcPub
SSLSignatureScheme
dcCertVerifyAlg
PRUint32
dcValidFor
PRTime
now
SECItem
*
out
)
{
SECStatus
rv
;
SSL3Hashes
hash
;
SECItem
*
tmp
=
NULL
;
SECKEYPrivateKey
*
tmpPriv
=
NULL
;
sslDelegatedCredential
*
dc
=
NULL
;
sslBuffer
dcBuf
=
SSL_BUFFER_EMPTY
;
dc
=
PORT_ZNew
(
sslDelegatedCredential
)
;
if
(
!
dc
)
{
PORT_SetError
(
SEC_ERROR_NO_MEMORY
)
;
goto
loser
;
}
PRTime
start
;
rv
=
DER_DecodeTimeChoice
(
&
start
&
cert
-
>
validity
.
notBefore
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
dc
-
>
validTime
=
(
(
now
-
start
)
/
PR_USEC_PER_SEC
)
+
dcValidFor
;
dc
-
>
expectedCertVerifyAlg
=
dcCertVerifyAlg
;
tmp
=
SECKEY_EncodeDERSubjectPublicKeyInfo
(
dcPub
)
;
if
(
!
tmp
)
{
goto
loser
;
}
dc
-
>
derSpki
.
type
=
tmp
-
>
type
;
dc
-
>
derSpki
.
data
=
tmp
-
>
data
;
dc
-
>
derSpki
.
len
=
tmp
-
>
len
;
PORT_Free
(
tmp
)
;
rv
=
ssl_SignatureSchemeFromSpki
(
&
cert
-
>
subjectPublicKeyInfo
PR_TRUE
&
dc
-
>
alg
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
PORT_Assert
(
dc
-
>
alg
!
=
ssl_sig_none
)
;
rv
=
tls13_AppendCredentialParams
(
&
dcBuf
dc
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
tls13_HashCredentialSignatureMessage
(
&
hash
dc
-
>
alg
cert
&
dcBuf
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
tmpPriv
=
SECKEY_CopyPrivateKey
(
certPriv
)
;
rv
=
ssl3_SignHashesWithPrivKey
(
&
hash
tmpPriv
dc
-
>
alg
PR_TRUE
&
dc
-
>
signature
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
tls13_AppendCredentialSignature
(
&
dcBuf
dc
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
SECITEM_MakeItem
(
NULL
out
dcBuf
.
buf
dcBuf
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
SECKEY_DestroyPrivateKey
(
tmpPriv
)
;
tls13_DestroyDelegatedCredential
(
dc
)
;
sslBuffer_Clear
(
&
dcBuf
)
;
return
SECSuccess
;
loser
:
SECKEY_DestroyPrivateKey
(
tmpPriv
)
;
tls13_DestroyDelegatedCredential
(
dc
)
;
sslBuffer_Clear
(
&
dcBuf
)
;
return
SECFailure
;
}
