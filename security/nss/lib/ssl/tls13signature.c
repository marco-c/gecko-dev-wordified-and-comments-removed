#
include
"
sslimpl
.
h
"
#
include
"
cryptohi
.
h
"
#
include
"
keyhi
.
h
"
static
SECAlgorithmID
*
tls_GetSignatureAlgorithmId
(
PLArenaPool
*
arena
SSLSignatureScheme
scheme
SECKEYPrivateKey
*
privKey
SECKEYPublicKey
*
pubKey
)
{
SECAlgorithmID
*
newAlgID
=
PORT_ArenaZNew
(
arena
SECAlgorithmID
)
;
SECOidTag
algTag
=
SEC_OID_UNKNOWN
;
SECOidTag
hashAlgTag
=
SEC_OID_UNKNOWN
;
SECStatus
rv
;
switch
(
scheme
)
{
case
ssl_sig_rsa_pss_rsae_sha256
:
case
ssl_sig_rsa_pss_pss_sha256
:
algTag
=
SEC_OID_PKCS1_RSA_PSS_SIGNATURE
;
hashAlgTag
=
SEC_OID_SHA256
;
break
;
case
ssl_sig_rsa_pss_rsae_sha384
:
case
ssl_sig_rsa_pss_pss_sha384
:
algTag
=
SEC_OID_PKCS1_RSA_PSS_SIGNATURE
;
hashAlgTag
=
SEC_OID_SHA384
;
break
;
case
ssl_sig_rsa_pss_rsae_sha512
:
case
ssl_sig_rsa_pss_pss_sha512
:
algTag
=
SEC_OID_PKCS1_RSA_PSS_SIGNATURE
;
hashAlgTag
=
SEC_OID_SHA512
;
break
;
case
ssl_sig_ecdsa_secp256r1_sha256
:
algTag
=
SEC_OID_ANSIX962_ECDSA_SHA256_SIGNATURE
;
hashAlgTag
=
SEC_OID_SHA256
;
break
;
case
ssl_sig_ecdsa_secp384r1_sha384
:
algTag
=
SEC_OID_ANSIX962_ECDSA_SHA384_SIGNATURE
;
hashAlgTag
=
SEC_OID_SHA384
;
break
;
case
ssl_sig_ecdsa_secp521r1_sha512
:
algTag
=
SEC_OID_ANSIX962_ECDSA_SHA512_SIGNATURE
;
hashAlgTag
=
SEC_OID_SHA512
;
break
;
case
ssl_sig_ed25519
:
case
ssl_sig_ed448
:
case
ssl_sig_ecdsa_sha1
:
case
ssl_sig_rsa_pkcs1_sha1
:
case
ssl_sig_rsa_pkcs1_sha256
:
case
ssl_sig_rsa_pkcs1_sha384
:
case
ssl_sig_rsa_pkcs1_sha512
:
case
ssl_sig_dsa_sha1
:
case
ssl_sig_dsa_sha256
:
case
ssl_sig_dsa_sha384
:
case
ssl_sig_dsa_sha512
:
case
ssl_sig_rsa_pkcs1_sha1md5
:
case
ssl_sig_none
:
break
;
}
PORT_Assert
(
algTag
!
=
SEC_OID_UNKNOWN
)
;
if
(
algTag
=
=
SEC_OID_UNKNOWN
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ALGORITHM
)
;
return
NULL
;
}
rv
=
SEC_CreateSignatureAlgorithmID
(
arena
newAlgID
algTag
hashAlgTag
NULL
privKey
pubKey
)
;
if
(
rv
!
=
SECSuccess
)
{
return
NULL
;
}
return
newAlgID
;
}
tlsSignOrVerifyContext
tls_CreateSignOrVerifyContext
(
SECKEYPrivateKey
*
privKey
SECKEYPublicKey
*
pubKey
SSLSignatureScheme
scheme
sslSignOrVerify
type
SECItem
*
signature
void
*
pwArg
)
{
PLArenaPool
*
arena
=
PORT_NewArena
(
DER_DEFAULT_CHUNKSIZE
)
;
tlsSignOrVerifyContext
newCtx
=
{
type
{
NULL
}
}
;
SECStatus
rv
;
if
(
!
arena
)
{
goto
loser
;
}
if
(
type
=
=
sig_sign
)
{
PORT_Assert
(
privKey
)
;
}
else
{
PORT_Assert
(
pubKey
)
;
}
SECAlgorithmID
*
sigAlgID
=
tls_GetSignatureAlgorithmId
(
arena
scheme
privKey
pubKey
)
;
if
(
sigAlgID
=
=
NULL
)
{
goto
loser
;
}
if
(
type
=
=
sig_sign
)
{
newCtx
.
u
.
sig
=
SGN_NewContextWithAlgorithmID
(
sigAlgID
privKey
)
;
if
(
!
newCtx
.
u
.
sig
)
{
goto
loser
;
}
rv
=
SGN_Begin
(
newCtx
.
u
.
sig
)
;
}
else
{
newCtx
.
u
.
vfy
=
VFY_CreateContextWithAlgorithmID
(
pubKey
signature
sigAlgID
NULL
pwArg
)
;
if
(
!
newCtx
.
u
.
vfy
)
{
goto
loser
;
}
rv
=
VFY_Begin
(
newCtx
.
u
.
vfy
)
;
}
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
PORT_FreeArena
(
arena
PR_FALSE
)
;
return
newCtx
;
loser
:
tls_DestroySignOrVerifyContext
(
newCtx
)
;
if
(
arena
)
{
PORT_FreeArena
(
arena
PR_FALSE
)
;
}
return
newCtx
;
}
SECStatus
tls_SignOrVerifyUpdate
(
tlsSignOrVerifyContext
ctx
const
unsigned
char
*
buf
int
len
)
{
SECStatus
rv
;
if
(
ctx
.
type
=
=
sig_sign
)
{
rv
=
SGN_Update
(
ctx
.
u
.
sig
buf
len
)
;
}
else
{
rv
=
VFY_Update
(
ctx
.
u
.
vfy
buf
len
)
;
}
return
rv
;
}
SECStatus
tls_SignOrVerifyEnd
(
tlsSignOrVerifyContext
ctx
SECItem
*
sig
)
{
SECStatus
rv
;
if
(
ctx
.
type
=
=
sig_sign
)
{
rv
=
SGN_End
(
ctx
.
u
.
sig
sig
)
;
}
else
{
rv
=
VFY_End
(
ctx
.
u
.
vfy
)
;
}
if
(
rv
=
=
SECSuccess
)
{
tls_DestroySignOrVerifyContext
(
ctx
)
;
}
return
rv
;
}
void
tls_DestroySignOrVerifyContext
(
tlsSignOrVerifyContext
ctx
)
{
if
(
ctx
.
type
=
=
sig_sign
)
{
if
(
ctx
.
u
.
sig
)
{
SGN_DestroyContext
(
ctx
.
u
.
sig
PR_TRUE
)
;
}
}
else
{
if
(
ctx
.
u
.
vfy
)
{
VFY_DestroyContext
(
ctx
.
u
.
vfy
PR_TRUE
)
;
}
}
}
