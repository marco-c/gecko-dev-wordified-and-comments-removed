#
include
"
nss
.
h
"
#
include
"
nssilock
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
prinit
.
h
"
#
include
"
prmon
.
h
"
#
include
"
prtime
.
h
"
#
include
"
secerr
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslbloom
.
h
"
#
include
"
sslimpl
.
h
"
#
include
"
tls13hkdf
.
h
"
static
struct
{
PRCallOnceType
init
;
PZMonitor
*
lock
;
sslBloomFilter
filters
[
2
]
;
PRUint8
current
;
PRTime
nextUpdate
;
PRTime
window
;
PK11SymKey
*
key
;
}
ssl_anti_replay
;
static
SECStatus
tls13_AntiReplayReset
(
void
*
appData
void
*
nssData
)
{
if
(
ssl_anti_replay
.
key
)
{
PK11_FreeSymKey
(
ssl_anti_replay
.
key
)
;
ssl_anti_replay
.
key
=
NULL
;
}
if
(
ssl_anti_replay
.
lock
)
{
PZ_DestroyMonitor
(
ssl_anti_replay
.
lock
)
;
ssl_anti_replay
.
lock
=
NULL
;
}
sslBloom_Destroy
(
&
ssl_anti_replay
.
filters
[
0
]
)
;
sslBloom_Destroy
(
&
ssl_anti_replay
.
filters
[
1
]
)
;
return
SECSuccess
;
}
static
PRStatus
tls13_AntiReplayInit
(
void
)
{
SECStatus
rv
=
NSS_RegisterShutdown
(
tls13_AntiReplayReset
NULL
)
;
if
(
rv
!
=
SECSuccess
)
{
return
PR_FAILURE
;
}
return
PR_SUCCESS
;
}
static
SECStatus
tls13_AntiReplayKeyGen
(
)
{
PRUint8
buf
[
32
]
;
SECItem
keyItem
=
{
siBuffer
buf
sizeof
(
buf
)
}
;
PK11SlotInfo
*
slot
;
SECStatus
rv
;
slot
=
PK11_GetInternalSlot
(
)
;
if
(
!
slot
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
rv
=
PK11_GenerateRandomOnSlot
(
slot
buf
sizeof
(
buf
)
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
ssl_anti_replay
.
key
=
PK11_ImportSymKey
(
slot
CKM_NSS_HKDF_SHA256
PK11_OriginUnwrap
CKA_DERIVE
&
keyItem
NULL
)
;
if
(
!
ssl_anti_replay
.
key
)
{
goto
loser
;
}
PK11_FreeSlot
(
slot
)
;
return
SECSuccess
;
loser
:
PK11_FreeSlot
(
slot
)
;
return
SECFailure
;
}
#
define
SSL_MAX_BLOOM_FILTER_SIZE
64
SECStatus
SSLExp_InitAntiReplay
(
PRTime
now
PRTime
window
unsigned
int
k
unsigned
int
bits
)
{
SECStatus
rv
;
if
(
k
=
=
0
|
|
bits
=
=
0
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
(
k
*
(
bits
+
7
)
/
8
)
>
SSL_MAX_BLOOM_FILTER_SIZE
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
PR_SUCCESS
!
=
PR_CallOnce
(
&
ssl_anti_replay
.
init
tls13_AntiReplayInit
)
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
(
void
)
tls13_AntiReplayReset
(
NULL
NULL
)
;
ssl_anti_replay
.
lock
=
PZ_NewMonitor
(
nssILockSSL
)
;
if
(
!
ssl_anti_replay
.
lock
)
{
goto
loser
;
}
rv
=
tls13_AntiReplayKeyGen
(
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
sslBloom_Init
(
&
ssl_anti_replay
.
filters
[
0
]
k
bits
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
sslBloom_Init
(
&
ssl_anti_replay
.
filters
[
1
]
k
bits
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
sslBloom_Fill
(
&
ssl_anti_replay
.
filters
[
1
]
)
;
ssl_anti_replay
.
current
=
0
;
ssl_anti_replay
.
nextUpdate
=
now
+
window
;
ssl_anti_replay
.
window
=
window
;
return
SECSuccess
;
loser
:
(
void
)
tls13_AntiReplayReset
(
NULL
NULL
)
;
return
SECFailure
;
}
static
void
tls13_AntiReplayUpdate
(
PRTime
now
)
{
PR_ASSERT_CURRENT_THREAD_IN_MONITOR
(
ssl_anti_replay
.
lock
)
;
if
(
now
>
=
ssl_anti_replay
.
nextUpdate
)
{
ssl_anti_replay
.
current
^
=
1
;
ssl_anti_replay
.
nextUpdate
=
now
+
ssl_anti_replay
.
window
;
sslBloom_Zero
(
ssl_anti_replay
.
filters
+
ssl_anti_replay
.
current
)
;
}
}
PRBool
tls13_InWindow
(
const
sslSocket
*
ss
const
sslSessionID
*
sid
)
{
PRInt32
timeDelta
;
timeDelta
=
ss
-
>
xtnData
.
ticketAge
-
(
(
ssl_Time
(
ss
)
-
sid
-
>
creationTime
)
/
PR_USEC_PER_MSEC
)
;
return
PR_ABS
(
timeDelta
)
<
(
ssl_anti_replay
.
window
/
(
PR_USEC_PER_MSEC
*
2
)
)
;
}
PRBool
tls13_IsReplay
(
const
sslSocket
*
ss
const
sslSessionID
*
sid
)
{
PRBool
replay
;
unsigned
int
size
;
PRUint8
index
;
SECStatus
rv
;
static
const
char
*
label
=
"
tls13
anti
-
replay
"
;
PRUint8
buf
[
SSL_MAX_BLOOM_FILTER_SIZE
]
;
if
(
!
ssl_anti_replay
.
init
.
initialized
)
{
return
PR_TRUE
;
}
if
(
!
tls13_InWindow
(
ss
sid
)
)
{
return
PR_TRUE
;
}
size
=
ssl_anti_replay
.
filters
[
0
]
.
k
*
(
ssl_anti_replay
.
filters
[
0
]
.
bits
+
7
)
/
8
;
PORT_Assert
(
size
<
=
SSL_MAX_BLOOM_FILTER_SIZE
)
;
rv
=
tls13_HkdfExpandLabelRaw
(
ssl_anti_replay
.
key
ssl_hash_sha256
ss
-
>
xtnData
.
pskBinder
.
data
ss
-
>
xtnData
.
pskBinder
.
len
label
strlen
(
label
)
buf
size
)
;
if
(
rv
!
=
SECSuccess
)
{
return
PR_TRUE
;
}
PZ_EnterMonitor
(
ssl_anti_replay
.
lock
)
;
tls13_AntiReplayUpdate
(
ssl_Time
(
ss
)
)
;
index
=
ssl_anti_replay
.
current
;
replay
=
sslBloom_Add
(
&
ssl_anti_replay
.
filters
[
index
]
buf
)
;
if
(
!
replay
)
{
replay
=
sslBloom_Check
(
&
ssl_anti_replay
.
filters
[
index
^
1
]
buf
)
;
}
PZ_ExitMonitor
(
ssl_anti_replay
.
lock
)
;
return
replay
;
}
