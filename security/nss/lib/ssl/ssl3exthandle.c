#
include
"
nssrenam
.
h
"
#
include
"
nss
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslproto
.
h
"
#
include
"
sslimpl
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
blapit
.
h
"
#
include
"
prinit
.
h
"
#
include
"
selfencrypt
.
h
"
#
include
"
ssl3encode
.
h
"
#
include
"
ssl3ext
.
h
"
#
include
"
ssl3exthandle
.
h
"
#
include
"
tls13exthandle
.
h
"
PRInt32
ssl3_SendServerNameXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
SECStatus
rv
;
if
(
!
ss
)
return
0
;
if
(
!
ss
-
>
sec
.
isServer
)
{
PRUint32
len
;
PRNetAddr
netAddr
;
if
(
!
ss
-
>
url
|
|
!
ss
-
>
url
[
0
]
)
return
0
;
if
(
PR_SUCCESS
=
=
PR_StringToNetAddr
(
ss
-
>
url
&
netAddr
)
)
{
return
0
;
}
len
=
PORT_Strlen
(
ss
-
>
url
)
;
if
(
append
&
&
maxBytes
>
=
len
+
9
)
{
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_server_name_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
len
+
5
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
len
+
3
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshake
(
ss
"
\
0
"
1
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeVariable
(
ss
(
PRUint8
*
)
ss
-
>
url
len
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
if
(
!
ss
-
>
sec
.
isServer
)
{
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_server_name_xtn
;
}
}
return
len
+
9
;
}
if
(
append
&
&
maxBytes
>
=
4
)
{
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_server_name_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
0
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
}
return
4
;
}
SECStatus
ssl3_HandleServerNameXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECItem
*
names
=
NULL
;
PRUint32
listLenBytes
=
0
;
SECStatus
rv
;
if
(
!
ss
-
>
sec
.
isServer
)
{
return
SECSuccess
;
}
if
(
!
ss
-
>
sniSocketConfig
)
{
return
SECSuccess
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
listLenBytes
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
listLenBytes
=
=
0
|
|
listLenBytes
!
=
data
-
>
len
)
{
goto
alert_loser
;
}
while
(
data
-
>
len
>
0
)
{
SECItem
tmp
;
PRUint32
type
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
type
1
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
tmp
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
type
=
=
sni_nametype_hostname
)
{
if
(
names
)
{
goto
alert_loser
;
}
names
=
PORT_ZNewArray
(
SECItem
1
)
;
if
(
!
names
)
{
goto
loser
;
}
if
(
SECITEM_CopyItem
(
NULL
&
names
[
0
]
&
tmp
)
!
=
SECSuccess
)
{
goto
loser
;
}
}
}
if
(
names
)
{
ssl3_FreeSniNameArray
(
xtnData
)
;
xtnData
-
>
sniNameArr
=
names
;
xtnData
-
>
sniNameArrSize
=
1
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_server_name_xtn
;
}
return
SECSuccess
;
alert_loser
:
ssl3_ExtDecodeError
(
ss
)
;
loser
:
if
(
names
)
{
PORT_Free
(
names
)
;
}
return
SECFailure
;
}
void
ssl3_FreeSniNameArray
(
TLSExtensionData
*
xtnData
)
{
PRUint32
i
;
if
(
!
xtnData
-
>
sniNameArr
)
{
return
;
}
for
(
i
=
0
;
i
<
xtnData
-
>
sniNameArrSize
;
i
+
+
)
{
SECITEM_FreeItem
(
&
xtnData
-
>
sniNameArr
[
i
]
PR_FALSE
)
;
}
PORT_Free
(
xtnData
-
>
sniNameArr
)
;
xtnData
-
>
sniNameArr
=
NULL
;
xtnData
-
>
sniNameArrSize
=
0
;
}
PRInt32
ssl3_SendSessionTicketXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
NewSessionTicket
*
session_ticket
=
NULL
;
sslSessionID
*
sid
=
ss
-
>
sec
.
ci
.
sid
;
if
(
sid
-
>
cached
=
=
in_client_cache
&
&
sid
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
0
;
}
if
(
!
ss
-
>
opt
.
enableSessionTickets
)
return
0
;
extension_length
=
4
;
if
(
!
ss
-
>
sec
.
isServer
)
{
session_ticket
=
&
sid
-
>
u
.
ssl3
.
locked
.
sessionTicket
;
if
(
session_ticket
-
>
ticket
.
data
)
{
if
(
xtnData
-
>
ticketTimestampVerified
)
{
extension_length
+
=
session_ticket
-
>
ticket
.
len
;
}
else
if
(
!
append
&
&
ssl_TicketTimeValid
(
session_ticket
)
)
{
extension_length
+
=
session_ticket
-
>
ticket
.
len
;
xtnData
-
>
ticketTimestampVerified
=
PR_TRUE
;
}
}
}
if
(
maxBytes
<
(
PRUint32
)
extension_length
)
{
PORT_Assert
(
0
)
;
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_session_ticket_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
if
(
session_ticket
&
&
session_ticket
-
>
ticket
.
data
&
&
xtnData
-
>
ticketTimestampVerified
)
{
rv
=
ssl3_ExtAppendHandshakeVariable
(
ss
session_ticket
-
>
ticket
.
data
session_ticket
-
>
ticket
.
len
2
)
;
xtnData
-
>
ticketTimestampVerified
=
PR_FALSE
;
xtnData
-
>
sentSessionTicketInClientHello
=
PR_TRUE
;
}
else
{
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
0
2
)
;
}
if
(
rv
!
=
SECSuccess
)
goto
loser
;
if
(
!
ss
-
>
sec
.
isServer
)
{
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_session_ticket_xtn
;
}
}
return
extension_length
;
loser
:
xtnData
-
>
ticketTimestampVerified
=
PR_FALSE
;
return
-
1
;
}
PRBool
ssl_AlpnTagAllowed
(
const
sslSocket
*
ss
const
SECItem
*
tag
)
{
const
unsigned
char
*
data
=
ss
-
>
opt
.
nextProtoNego
.
data
;
unsigned
int
length
=
ss
-
>
opt
.
nextProtoNego
.
len
;
unsigned
int
offset
=
0
;
if
(
!
tag
-
>
len
)
return
PR_TRUE
;
while
(
offset
<
length
)
{
unsigned
int
taglen
=
(
unsigned
int
)
data
[
offset
]
;
if
(
(
taglen
=
=
tag
-
>
len
)
&
&
!
PORT_Memcmp
(
data
+
offset
+
1
tag
-
>
data
tag
-
>
len
)
)
return
PR_TRUE
;
offset
+
=
1
+
taglen
;
}
return
PR_FALSE
;
}
SECStatus
ssl3_ServerHandleNextProtoNegoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
if
(
ss
-
>
firstHsDone
|
|
data
-
>
len
!
=
0
)
{
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_DATA_INVALID
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
return
SECSuccess
;
}
SECStatus
ssl3_ValidateNextProtoNego
(
const
unsigned
char
*
data
unsigned
int
length
)
{
unsigned
int
offset
=
0
;
while
(
offset
<
length
)
{
unsigned
int
newOffset
=
offset
+
1
+
(
unsigned
int
)
data
[
offset
]
;
if
(
newOffset
>
length
|
|
data
[
offset
]
=
=
0
)
{
return
SECFailure
;
}
offset
=
newOffset
;
}
return
SECSuccess
;
}
static
SECStatus
ssl3_SelectAppProtocol
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECStatus
rv
;
unsigned
char
resultBuffer
[
255
]
;
SECItem
result
=
{
siBuffer
resultBuffer
0
}
;
rv
=
ssl3_ValidateNextProtoNego
(
data
-
>
data
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_DATA_INVALID
)
;
return
rv
;
}
PORT_Assert
(
ss
-
>
nextProtoCallback
)
;
PORT_Assert
(
(
ss
-
>
ssl3
.
hs
.
preliminaryInfo
&
ssl_preinfo_all
&
~
ssl_preinfo_cipher_suite
)
=
=
(
ssl_preinfo_all
&
~
ssl_preinfo_cipher_suite
)
)
;
rv
=
ss
-
>
nextProtoCallback
(
ss
-
>
nextProtoArg
ss
-
>
fd
data
-
>
data
data
-
>
len
result
.
data
&
result
.
len
sizeof
(
resultBuffer
)
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
internal_error
)
;
return
SECFailure
;
}
if
(
result
.
len
>
sizeof
(
resultBuffer
)
)
{
PORT_SetError
(
SEC_ERROR_OUTPUT_LEN
)
;
return
SECFailure
;
}
SECITEM_FreeItem
(
&
xtnData
-
>
nextProto
PR_FALSE
)
;
if
(
ex_type
=
=
ssl_app_layer_protocol_xtn
&
&
xtnData
-
>
nextProtoState
!
=
SSL_NEXT_PROTO_NEGOTIATED
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
no_application_protocol
)
;
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_NO_PROTOCOL
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
return
SECITEM_CopyItem
(
NULL
&
xtnData
-
>
nextProto
&
result
)
;
}
SECStatus
ssl3_ServerHandleAppProtoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
PRUint32
count
;
SECStatus
rv
;
if
(
ss
-
>
firstHsDone
|
|
data
-
>
len
=
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_DATA_INVALID
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
count
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
|
|
count
!
=
data
-
>
len
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
if
(
!
ss
-
>
nextProtoCallback
)
{
return
SECSuccess
;
}
rv
=
ssl3_SelectAppProtocol
(
ss
xtnData
ex_type
data
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
if
(
xtnData
-
>
nextProtoState
=
=
SSL_NEXT_PROTO_NEGOTIATED
)
{
rv
=
ssl3_RegisterExtensionSender
(
ss
xtnData
ex_type
ssl3_ServerSendAppProtoXtn
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
internal_error
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
rv
;
}
}
return
SECSuccess
;
}
SECStatus
ssl3_ClientHandleNextProtoNegoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
PORT_Assert
(
!
ss
-
>
firstHsDone
)
;
if
(
ssl3_ExtensionNegotiated
(
ss
ssl_app_layer_protocol_xtn
)
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_BAD_SERVER
)
;
return
SECFailure
;
}
if
(
!
ss
-
>
nextProtoCallback
)
{
PORT_Assert
(
0
)
;
ssl3_ExtSendAlert
(
ss
alert_fatal
internal_error
)
;
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_NO_CALLBACK
)
;
return
SECFailure
;
}
return
ssl3_SelectAppProtocol
(
ss
xtnData
ex_type
data
)
;
}
SECStatus
ssl3_ClientHandleAppProtoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECStatus
rv
;
PRUint32
list_len
;
SECItem
protocol_name
;
if
(
ssl3_ExtensionNegotiated
(
ss
ssl_next_proto_nego_xtn
)
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
if
(
data
-
>
len
<
4
|
|
data
-
>
len
>
2
+
1
+
255
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_DATA_INVALID
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
list_len
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
|
|
list_len
!
=
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_DATA_INVALID
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
protocol_name
1
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
|
|
data
-
>
len
!
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_DATA_INVALID
)
;
return
SECFailure
;
}
if
(
!
ssl_AlpnTagAllowed
(
ss
&
protocol_name
)
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_NEXT_PROTOCOL_DATA_INVALID
)
;
return
SECFailure
;
}
SECITEM_FreeItem
(
&
xtnData
-
>
nextProto
PR_FALSE
)
;
xtnData
-
>
nextProtoState
=
SSL_NEXT_PROTO_SELECTED
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
return
SECITEM_CopyItem
(
NULL
&
xtnData
-
>
nextProto
&
protocol_name
)
;
}
PRInt32
ssl3_ClientSendNextProtoNegoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
if
(
!
ss
-
>
opt
.
enableNPN
|
|
!
ss
-
>
nextProtoCallback
|
|
ss
-
>
firstHsDone
)
{
return
0
;
}
extension_length
=
4
;
if
(
maxBytes
<
(
PRUint32
)
extension_length
)
{
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_next_proto_nego_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
0
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_next_proto_nego_xtn
;
}
return
extension_length
;
loser
:
return
-
1
;
}
PRInt32
ssl3_ClientSendAppProtoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
unsigned
char
*
alpn_protos
=
NULL
;
if
(
!
ss
-
>
opt
.
enableALPN
|
|
!
ss
-
>
opt
.
nextProtoNego
.
data
|
|
ss
-
>
firstHsDone
)
{
return
0
;
}
extension_length
=
2
+
2
+
2
+
ss
-
>
opt
.
nextProtoNego
.
len
;
if
(
maxBytes
<
(
PRUint32
)
extension_length
)
{
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
const
unsigned
int
len
=
ss
-
>
opt
.
nextProtoNego
.
len
;
alpn_protos
=
PORT_Alloc
(
len
)
;
if
(
alpn_protos
=
=
NULL
)
{
return
SECFailure
;
}
if
(
len
>
0
)
{
unsigned
int
i
=
ss
-
>
opt
.
nextProtoNego
.
data
[
0
]
+
1
;
if
(
i
<
=
len
)
{
memcpy
(
alpn_protos
&
ss
-
>
opt
.
nextProtoNego
.
data
[
i
]
len
-
i
)
;
memcpy
(
alpn_protos
+
len
-
i
ss
-
>
opt
.
nextProtoNego
.
data
i
)
;
}
else
{
memcpy
(
alpn_protos
ss
-
>
opt
.
nextProtoNego
.
data
len
)
;
}
}
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_app_layer_protocol_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
extension_length
-
4
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_ExtAppendHandshakeVariable
(
ss
alpn_protos
len
2
)
;
PORT_Free
(
alpn_protos
)
;
alpn_protos
=
NULL
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_app_layer_protocol_xtn
;
}
return
extension_length
;
loser
:
if
(
alpn_protos
)
{
PORT_Free
(
alpn_protos
)
;
}
return
-
1
;
}
PRInt32
ssl3_ServerSendAppProtoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
PORT_Assert
(
ss
-
>
opt
.
enableALPN
)
;
PORT_Assert
(
xtnData
-
>
nextProto
.
data
)
;
PORT_Assert
(
xtnData
-
>
nextProto
.
len
>
0
)
;
PORT_Assert
(
xtnData
-
>
nextProtoState
=
=
SSL_NEXT_PROTO_NEGOTIATED
)
;
PORT_Assert
(
!
ss
-
>
firstHsDone
)
;
extension_length
=
2
+
2
+
2
+
1
+
xtnData
-
>
nextProto
.
len
;
if
(
maxBytes
<
(
PRUint32
)
extension_length
)
{
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_app_layer_protocol_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
extension_length
-
4
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
xtnData
-
>
nextProto
.
len
+
1
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
rv
=
ssl3_ExtAppendHandshakeVariable
(
ss
xtnData
-
>
nextProto
.
data
xtnData
-
>
nextProto
.
len
1
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
}
return
extension_length
;
}
SECStatus
ssl3_ServerHandleStatusRequestXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
ssl3HelloExtensionSenderFunc
sender
;
PORT_Assert
(
ss
-
>
sec
.
isServer
)
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
if
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
sender
=
tls13_ServerSendStatusRequestXtn
;
}
else
{
sender
=
ssl3_ServerSendStatusRequestXtn
;
}
return
ssl3_RegisterExtensionSender
(
ss
xtnData
ex_type
sender
)
;
}
PRInt32
ssl3_ServerSendStatusRequestXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
const
sslServerCert
*
serverCert
=
ss
-
>
sec
.
serverCert
;
SECStatus
rv
;
if
(
!
serverCert
-
>
certStatusArray
|
|
!
serverCert
-
>
certStatusArray
-
>
len
)
{
return
0
;
}
extension_length
=
2
+
2
;
if
(
maxBytes
<
(
PRUint32
)
extension_length
)
{
return
0
;
}
if
(
append
)
{
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_cert_status_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
0
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
}
return
extension_length
;
}
PRInt32
ssl3_ClientSendStatusRequestXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
if
(
!
ss
-
>
opt
.
enableOCSPStapling
)
return
0
;
extension_length
=
9
;
if
(
maxBytes
<
(
PRUint32
)
extension_length
)
{
PORT_Assert
(
0
)
;
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_cert_status_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
extension_length
-
4
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
1
1
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
0
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
0
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_cert_status_xtn
;
}
return
extension_length
;
}
SECStatus
ssl3_ClientHandleStatusRequestXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
if
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
SECStatus
rv
;
rv
=
ssl_ReadCertificateStatus
(
CONST_CAST
(
sslSocket
ss
)
data
-
>
data
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
else
if
(
data
-
>
len
!
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_SERVER_HELLO
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
return
SECSuccess
;
}
PRUint32
ssl_ticket_lifetime
=
2
*
24
*
60
*
60
;
#
define
TLS_EX_SESS_TICKET_VERSION
(
0x0106
)
SECStatus
ssl3_EncodeSessionTicket
(
sslSocket
*
ss
const
NewSessionTicket
*
ticket
SECItem
*
ticket_data
)
{
SECStatus
rv
;
SECItem
plaintext
;
SECItem
plaintext_item
=
{
0
NULL
0
}
;
PRUint32
plaintext_length
;
SECItem
ticket_buf
=
{
0
NULL
0
}
;
PRBool
ms_is_wrapped
;
unsigned
char
wrapped_ms
[
SSL3_MASTER_SECRET_LENGTH
]
;
SECItem
ms_item
=
{
0
NULL
0
}
;
PRUint32
cert_length
=
0
;
PRUint32
now
;
SECItem
*
srvName
=
NULL
;
CK_MECHANISM_TYPE
msWrapMech
=
0
;
ssl3CipherSpec
*
spec
;
SECItem
*
alpnSelection
=
NULL
;
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
send
session_ticket
handshake
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveXmitBufLock
(
ss
)
)
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveSSL3HandshakeLock
(
ss
)
)
;
if
(
ss
-
>
opt
.
requestCertificate
&
&
ss
-
>
sec
.
ci
.
sid
-
>
peerCert
)
{
cert_length
=
2
+
ss
-
>
sec
.
ci
.
sid
-
>
peerCert
-
>
derCert
.
len
;
}
if
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
spec
=
ss
-
>
ssl3
.
cwSpec
;
}
else
{
spec
=
ss
-
>
ssl3
.
pwSpec
;
}
if
(
spec
-
>
msItem
.
len
&
&
spec
-
>
msItem
.
data
)
{
ms_item
.
data
=
spec
-
>
msItem
.
data
;
ms_item
.
len
=
spec
-
>
msItem
.
len
;
ms_is_wrapped
=
PR_FALSE
;
}
else
{
sslSessionID
sid
;
PORT_Memset
(
&
sid
0
sizeof
(
sslSessionID
)
)
;
rv
=
ssl3_CacheWrappedMasterSecret
(
ss
&
sid
spec
)
;
if
(
rv
=
=
SECSuccess
)
{
if
(
sid
.
u
.
ssl3
.
keys
.
wrapped_master_secret_len
>
sizeof
(
wrapped_ms
)
)
goto
loser
;
memcpy
(
wrapped_ms
sid
.
u
.
ssl3
.
keys
.
wrapped_master_secret
sid
.
u
.
ssl3
.
keys
.
wrapped_master_secret_len
)
;
ms_item
.
data
=
wrapped_ms
;
ms_item
.
len
=
sid
.
u
.
ssl3
.
keys
.
wrapped_master_secret_len
;
msWrapMech
=
sid
.
u
.
ssl3
.
masterWrapMech
;
}
else
{
goto
loser
;
}
ms_is_wrapped
=
PR_TRUE
;
}
srvName
=
&
ss
-
>
sec
.
ci
.
sid
-
>
u
.
ssl3
.
srvName
;
PORT_Assert
(
ss
-
>
xtnData
.
nextProtoState
=
=
SSL_NEXT_PROTO_SELECTED
|
|
ss
-
>
xtnData
.
nextProtoState
=
=
SSL_NEXT_PROTO_NEGOTIATED
|
|
ss
-
>
xtnData
.
nextProto
.
len
=
=
0
)
;
alpnSelection
=
&
ss
-
>
xtnData
.
nextProto
;
plaintext_length
=
sizeof
(
PRUint16
)
+
sizeof
(
SSL3ProtocolVersion
)
+
sizeof
(
ssl3CipherSuite
)
+
1
+
10
+
8
+
1
+
1
+
4
+
2
+
ms_item
.
len
+
1
+
cert_length
+
2
+
srvName
-
>
len
+
1
+
sizeof
(
ticket
-
>
ticket_lifetime_hint
)
+
sizeof
(
ticket
-
>
flags
)
+
1
+
alpnSelection
-
>
len
+
4
;
if
(
SECITEM_AllocItem
(
NULL
&
plaintext_item
plaintext_length
)
=
=
NULL
)
goto
loser
;
plaintext
=
plaintext_item
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
TLS_EX_SESS_TICKET_VERSION
sizeof
(
PRUint16
)
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
version
sizeof
(
SSL3ProtocolVersion
)
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
ssl3
.
hs
.
cipher_suite
sizeof
(
ssl3CipherSuite
)
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
ssl3
.
hs
.
compression
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
sec
.
authType
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
sec
.
authKeyBits
4
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
sec
.
keaType
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
sec
.
keaKeyBits
4
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
if
(
ss
-
>
sec
.
keaGroup
)
{
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
sec
.
keaGroup
-
>
name
4
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
}
else
{
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
0
4
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
}
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
sec
.
signatureScheme
4
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
PORT_Assert
(
SSL_CERT_IS
(
ss
-
>
sec
.
serverCert
ss
-
>
sec
.
authType
)
)
;
if
(
SSL_CERT_IS_EC
(
ss
-
>
sec
.
serverCert
)
)
{
const
sslServerCert
*
cert
=
ss
-
>
sec
.
serverCert
;
PORT_Assert
(
cert
-
>
namedCurve
)
;
PORT_Assert
(
cert
-
>
namedCurve
-
>
name
<
256
)
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
cert
-
>
namedCurve
-
>
name
1
)
;
}
else
{
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
0
1
)
;
}
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ms_is_wrapped
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
msWrapMech
4
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ms_item
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendToItem
(
&
plaintext
ms_item
.
data
ms_item
.
len
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
if
(
ss
-
>
opt
.
requestCertificate
&
&
ss
-
>
sec
.
ci
.
sid
-
>
peerCert
)
{
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
CLIENT_AUTH_CERTIFICATE
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
sec
.
ci
.
sid
-
>
peerCert
-
>
derCert
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendToItem
(
&
plaintext
ss
-
>
sec
.
ci
.
sid
-
>
peerCert
-
>
derCert
.
data
ss
-
>
sec
.
ci
.
sid
-
>
peerCert
-
>
derCert
.
len
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
}
else
{
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
0
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
}
now
=
ssl_Time
(
)
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
now
sizeof
(
ticket
-
>
ticket_lifetime_hint
)
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
srvName
-
>
len
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
if
(
srvName
-
>
len
)
{
rv
=
ssl3_AppendToItem
(
&
plaintext
srvName
-
>
data
srvName
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
}
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ss
-
>
sec
.
ci
.
sid
-
>
u
.
ssl3
.
keys
.
extendedMasterSecretUsed
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ticket
-
>
flags
sizeof
(
ticket
-
>
flags
)
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
PORT_Assert
(
alpnSelection
-
>
len
<
256
)
;
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
alpnSelection
-
>
len
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
if
(
alpnSelection
-
>
len
)
{
rv
=
ssl3_AppendToItem
(
&
plaintext
alpnSelection
-
>
data
alpnSelection
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
}
rv
=
ssl3_AppendNumberToItem
(
&
plaintext
ssl_max_early_data_size
4
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
PORT_Assert
(
plaintext
.
len
=
=
0
)
;
if
(
SECITEM_AllocItem
(
NULL
&
ticket_buf
plaintext_length
+
128
)
=
=
NULL
)
{
goto
loser
;
}
rv
=
ssl_SelfEncryptProtect
(
ss
plaintext_item
.
data
plaintext_item
.
len
ticket_buf
.
data
&
ticket_buf
.
len
ticket_buf
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
*
ticket_data
=
ticket_buf
;
SECITEM_FreeItem
(
&
plaintext_item
PR_FALSE
)
;
return
SECSuccess
;
loser
:
if
(
plaintext_item
.
data
)
{
SECITEM_FreeItem
(
&
plaintext_item
PR_FALSE
)
;
}
if
(
ticket_buf
.
data
)
{
SECITEM_FreeItem
(
&
ticket_buf
PR_FALSE
)
;
}
return
SECFailure
;
}
SECStatus
ssl3_ClientHandleSessionTicketXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
if
(
data
-
>
len
!
=
0
)
{
return
SECSuccess
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
return
SECSuccess
;
}
static
SECStatus
ssl_ParseSessionTicket
(
sslSocket
*
ss
const
SECItem
*
decryptedTicket
SessionTicket
*
parsedTicket
)
{
PRUint32
temp
;
SECStatus
rv
;
PRUint8
*
buffer
=
decryptedTicket
-
>
data
;
unsigned
int
len
=
decryptedTicket
-
>
len
;
PORT_Memset
(
parsedTicket
0
sizeof
(
*
parsedTicket
)
)
;
parsedTicket
-
>
valid
=
PR_FALSE
;
if
(
decryptedTicket
-
>
len
=
=
0
)
{
return
SECSuccess
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
2
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
if
(
temp
!
=
TLS_EX_SESS_TICKET_VERSION
)
{
return
SECSuccess
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
2
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
ssl_version
=
(
SSL3ProtocolVersion
)
temp
;
if
(
!
ssl3_VersionIsSupported
(
ss
-
>
protocolVariant
parsedTicket
-
>
ssl_version
)
)
{
return
SECSuccess
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
2
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
cipher_suite
=
(
ssl3CipherSuite
)
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
1
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
compression_method
=
(
SSLCompressionMethod
)
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
1
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
authType
=
(
SSLAuthType
)
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
4
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
authKeyBits
=
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
1
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
keaType
=
(
SSLKEAType
)
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
4
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
keaKeyBits
=
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
4
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
originalKeaGroup
=
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
4
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
signatureScheme
=
(
SSLSignatureScheme
)
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
1
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
if
(
parsedTicket
-
>
authType
=
=
ssl_auth_ecdsa
|
|
parsedTicket
-
>
authType
=
=
ssl_auth_ecdh_rsa
|
|
parsedTicket
-
>
authType
=
=
ssl_auth_ecdh_ecdsa
)
{
const
sslNamedGroupDef
*
group
=
ssl_LookupNamedGroup
(
(
SSLNamedGroup
)
temp
)
;
if
(
!
group
|
|
group
-
>
keaType
!
=
ssl_kea_ecdh
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
namedCurve
=
group
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
1
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
PORT_Assert
(
temp
=
=
PR_TRUE
|
|
temp
=
=
PR_FALSE
)
;
parsedTicket
-
>
ms_is_wrapped
=
(
PRBool
)
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
4
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
msWrapMech
=
(
CK_MECHANISM_TYPE
)
temp
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
2
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
if
(
temp
=
=
0
|
|
temp
>
sizeof
(
parsedTicket
-
>
master_secret
)
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
ms_length
=
(
PRUint16
)
temp
;
rv
=
ssl3_ExtConsumeHandshake
(
ss
parsedTicket
-
>
master_secret
parsedTicket
-
>
ms_length
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
1
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
client_auth_type
=
(
ClientAuthenticationType
)
temp
;
switch
(
parsedTicket
-
>
client_auth_type
)
{
case
CLIENT_AUTH_ANONYMOUS
:
break
;
case
CLIENT_AUTH_CERTIFICATE
:
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
parsedTicket
-
>
peer_cert
2
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
break
;
default
:
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
4
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
timestamp
=
temp
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
parsedTicket
-
>
srvName
2
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
1
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
PORT_Assert
(
temp
=
=
PR_TRUE
|
|
temp
=
=
PR_FALSE
)
;
parsedTicket
-
>
extendedMasterSecretUsed
=
(
PRBool
)
temp
;
rv
=
ssl3_ExtConsumeHandshake
(
ss
&
temp
4
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
flags
=
PR_ntohl
(
temp
)
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
parsedTicket
-
>
alpnSelection
1
&
buffer
&
len
)
;
PORT_Assert
(
parsedTicket
-
>
alpnSelection
.
len
<
256
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
temp
4
&
buffer
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
parsedTicket
-
>
maxEarlyData
=
temp
;
#
ifndef
UNSAFE_FUZZER_MODE
if
(
len
!
=
0
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
#
endif
parsedTicket
-
>
valid
=
PR_TRUE
;
return
SECSuccess
;
}
static
SECStatus
ssl_CreateSIDFromTicket
(
sslSocket
*
ss
const
SECItem
*
rawTicket
SessionTicket
*
parsedTicket
sslSessionID
*
*
out
)
{
sslSessionID
*
sid
;
SECStatus
rv
;
sid
=
ssl3_NewSessionID
(
ss
PR_TRUE
)
;
if
(
sid
=
=
NULL
)
{
return
SECFailure
;
}
sid
-
>
version
=
parsedTicket
-
>
ssl_version
;
sid
-
>
u
.
ssl3
.
cipherSuite
=
parsedTicket
-
>
cipher_suite
;
sid
-
>
u
.
ssl3
.
compression
=
parsedTicket
-
>
compression_method
;
sid
-
>
authType
=
parsedTicket
-
>
authType
;
sid
-
>
authKeyBits
=
parsedTicket
-
>
authKeyBits
;
sid
-
>
keaType
=
parsedTicket
-
>
keaType
;
sid
-
>
keaKeyBits
=
parsedTicket
-
>
keaKeyBits
;
sid
-
>
keaGroup
=
parsedTicket
-
>
originalKeaGroup
;
sid
-
>
namedCurve
=
parsedTicket
-
>
namedCurve
;
sid
-
>
sigScheme
=
parsedTicket
-
>
signatureScheme
;
rv
=
SECITEM_CopyItem
(
NULL
&
sid
-
>
u
.
ssl3
.
locked
.
sessionTicket
.
ticket
rawTicket
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
sid
-
>
u
.
ssl3
.
locked
.
sessionTicket
.
flags
=
parsedTicket
-
>
flags
;
sid
-
>
u
.
ssl3
.
locked
.
sessionTicket
.
max_early_data_size
=
parsedTicket
-
>
maxEarlyData
;
if
(
parsedTicket
-
>
ms_length
>
sizeof
(
sid
-
>
u
.
ssl3
.
keys
.
wrapped_master_secret
)
)
{
goto
loser
;
}
PORT_Memcpy
(
sid
-
>
u
.
ssl3
.
keys
.
wrapped_master_secret
parsedTicket
-
>
master_secret
parsedTicket
-
>
ms_length
)
;
sid
-
>
u
.
ssl3
.
keys
.
wrapped_master_secret_len
=
parsedTicket
-
>
ms_length
;
sid
-
>
u
.
ssl3
.
masterWrapMech
=
parsedTicket
-
>
msWrapMech
;
sid
-
>
u
.
ssl3
.
keys
.
msIsWrapped
=
parsedTicket
-
>
ms_is_wrapped
;
sid
-
>
u
.
ssl3
.
masterValid
=
PR_TRUE
;
sid
-
>
u
.
ssl3
.
keys
.
resumable
=
PR_TRUE
;
sid
-
>
u
.
ssl3
.
keys
.
extendedMasterSecretUsed
=
parsedTicket
-
>
extendedMasterSecretUsed
;
if
(
parsedTicket
-
>
peer_cert
.
data
!
=
NULL
)
{
PORT_Assert
(
!
sid
-
>
peerCert
)
;
sid
-
>
peerCert
=
CERT_NewTempCertificate
(
ss
-
>
dbHandle
&
parsedTicket
-
>
peer_cert
NULL
PR_FALSE
PR_TRUE
)
;
if
(
!
sid
-
>
peerCert
)
{
goto
loser
;
}
}
if
(
parsedTicket
-
>
srvName
.
data
!
=
NULL
)
{
SECITEM_FreeItem
(
&
sid
-
>
u
.
ssl3
.
srvName
PR_FALSE
)
;
rv
=
SECITEM_CopyItem
(
NULL
&
sid
-
>
u
.
ssl3
.
srvName
&
parsedTicket
-
>
srvName
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
}
if
(
parsedTicket
-
>
alpnSelection
.
data
!
=
NULL
)
{
rv
=
SECITEM_CopyItem
(
NULL
&
sid
-
>
u
.
ssl3
.
alpnSelection
&
parsedTicket
-
>
alpnSelection
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
}
*
out
=
sid
;
return
SECSuccess
;
loser
:
ssl_FreeSID
(
sid
)
;
return
SECFailure
;
}
SECStatus
ssl3_ProcessSessionTicketCommon
(
sslSocket
*
ss
SECItem
*
data
)
{
SECItem
decryptedTicket
=
{
siBuffer
NULL
0
}
;
SessionTicket
parsedTicket
;
SECStatus
rv
;
if
(
ss
-
>
sec
.
ci
.
sid
!
=
NULL
)
{
ss
-
>
sec
.
uncache
(
ss
-
>
sec
.
ci
.
sid
)
;
ssl_FreeSID
(
ss
-
>
sec
.
ci
.
sid
)
;
ss
-
>
sec
.
ci
.
sid
=
NULL
;
}
if
(
!
SECITEM_AllocItem
(
NULL
&
decryptedTicket
data
-
>
len
)
)
{
return
SECFailure
;
}
rv
=
ssl_SelfEncryptUnprotect
(
ss
data
-
>
data
data
-
>
len
decryptedTicket
.
data
&
decryptedTicket
.
len
decryptedTicket
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
SECITEM_ZfreeItem
(
&
decryptedTicket
PR_FALSE
)
;
if
(
PORT_GetError
(
)
!
=
SEC_ERROR_NOT_A_RECIPIENT
)
{
SSL3_SendAlert
(
ss
alert_fatal
illegal_parameter
)
;
return
SECFailure
;
}
}
rv
=
ssl_ParseSessionTicket
(
ss
&
decryptedTicket
&
parsedTicket
)
;
if
(
rv
!
=
SECSuccess
)
{
SSL3Statistics
*
ssl3stats
;
SSL_DBG
(
(
"
%
d
:
SSL
[
%
d
]
:
Session
ticket
parsing
failed
.
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
ssl3stats
=
SSL_GetStatistics
(
)
;
SSL_AtomicIncrementLong
(
&
ssl3stats
-
>
hch_sid_ticket_parse_failures
)
;
goto
loser
;
}
if
(
parsedTicket
.
valid
&
&
parsedTicket
.
timestamp
+
ssl_ticket_lifetime
>
ssl_Time
(
)
)
{
sslSessionID
*
sid
;
rv
=
ssl_CreateSIDFromTicket
(
ss
data
&
parsedTicket
&
sid
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
ss
-
>
statelessResume
=
PR_TRUE
;
ss
-
>
sec
.
ci
.
sid
=
sid
;
}
SECITEM_ZfreeItem
(
&
decryptedTicket
PR_FALSE
)
;
PORT_Memset
(
&
parsedTicket
0
sizeof
(
parsedTicket
)
)
;
return
SECSuccess
;
loser
:
SECITEM_ZfreeItem
(
&
decryptedTicket
PR_FALSE
)
;
PORT_Memset
(
&
parsedTicket
0
sizeof
(
parsedTicket
)
)
;
return
SECFailure
;
}
SECStatus
ssl3_ServerHandleSessionTicketXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
if
(
!
ss
-
>
opt
.
enableSessionTickets
)
{
return
SECSuccess
;
}
if
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
if
(
data
-
>
len
=
=
0
)
{
xtnData
-
>
emptySessionTicket
=
PR_TRUE
;
return
SECSuccess
;
}
return
ssl3_ProcessSessionTicketCommon
(
CONST_CAST
(
sslSocket
ss
)
data
)
;
}
PRInt32
ssl3_SendRenegotiationInfoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
len
=
0
;
PRInt32
needed
;
if
(
ss
-
>
ssl3
.
hs
.
sendingSCSV
)
{
return
0
;
}
if
(
ss
-
>
firstHsDone
)
{
len
=
ss
-
>
sec
.
isServer
?
ss
-
>
ssl3
.
hs
.
finishedBytes
*
2
:
ss
-
>
ssl3
.
hs
.
finishedBytes
;
}
needed
=
5
+
len
;
if
(
maxBytes
<
(
PRUint32
)
needed
)
{
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_renegotiation_info_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
len
+
1
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeVariable
(
ss
ss
-
>
ssl3
.
hs
.
finishedMsgs
.
data
len
1
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
if
(
!
ss
-
>
sec
.
isServer
)
{
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_renegotiation_info_xtn
;
}
}
return
needed
;
}
SECStatus
ssl3_HandleRenegotiationInfoXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECStatus
rv
=
SECSuccess
;
PRUint32
len
=
0
;
if
(
ss
-
>
firstHsDone
)
{
len
=
ss
-
>
sec
.
isServer
?
ss
-
>
ssl3
.
hs
.
finishedBytes
:
ss
-
>
ssl3
.
hs
.
finishedBytes
*
2
;
}
if
(
data
-
>
len
!
=
1
+
len
|
|
data
-
>
data
[
0
]
!
=
len
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
if
(
len
&
&
NSS_SecureMemcmp
(
ss
-
>
ssl3
.
hs
.
finishedMsgs
.
data
data
-
>
data
+
1
len
)
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
handshake_failure
)
;
PORT_SetError
(
SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE
)
;
return
SECFailure
;
}
CONST_CAST
(
sslSocket
ss
)
-
>
peerRequestedProtection
=
1
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
if
(
ss
-
>
sec
.
isServer
)
{
rv
=
ssl3_RegisterExtensionSender
(
ss
xtnData
ex_type
ssl3_SendRenegotiationInfoXtn
)
;
}
return
rv
;
}
PRInt32
ssl3_ClientSendUseSRTPXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRUint32
ext_data_len
;
PRInt16
i
;
SECStatus
rv
;
if
(
!
ss
)
return
0
;
if
(
!
IS_DTLS
(
ss
)
|
|
!
ss
-
>
ssl3
.
dtlsSRTPCipherCount
)
return
0
;
ext_data_len
=
2
+
2
*
ss
-
>
ssl3
.
dtlsSRTPCipherCount
+
1
;
if
(
append
&
&
maxBytes
>
=
4
+
ext_data_len
)
{
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_use_srtp_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ext_data_len
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
2
*
ss
-
>
ssl3
.
dtlsSRTPCipherCount
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
for
(
i
=
0
;
i
<
ss
-
>
ssl3
.
dtlsSRTPCipherCount
;
i
+
+
)
{
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ss
-
>
ssl3
.
dtlsSRTPCiphers
[
i
]
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
}
ssl3_ExtAppendHandshakeVariable
(
ss
NULL
0
1
)
;
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_use_srtp_xtn
;
}
return
4
+
ext_data_len
;
}
PRInt32
ssl3_ServerSendUseSRTPXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
SECStatus
rv
;
if
(
!
append
|
|
maxBytes
<
9
)
{
return
9
;
}
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_use_srtp_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
5
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
2
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
xtnData
-
>
dtlsSRTPCipherSuite
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
ssl3_ExtAppendHandshakeVariable
(
ss
NULL
0
1
)
;
return
9
;
}
SECStatus
ssl3_ClientHandleUseSRTPXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECStatus
rv
;
SECItem
ciphers
=
{
siBuffer
NULL
0
}
;
PRUint16
i
;
PRUint16
cipher
=
0
;
PRBool
found
=
PR_FALSE
;
SECItem
litem
;
if
(
!
data
-
>
data
|
|
!
data
-
>
len
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
ciphers
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
ciphers
.
len
!
=
2
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
cipher
=
(
ciphers
.
data
[
0
]
<
<
8
)
|
ciphers
.
data
[
1
]
;
for
(
i
=
0
;
i
<
ss
-
>
ssl3
.
dtlsSRTPCipherCount
;
i
+
+
)
{
if
(
cipher
=
=
ss
-
>
ssl3
.
dtlsSRTPCiphers
[
i
]
)
{
found
=
PR_TRUE
;
break
;
}
}
if
(
!
found
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_SERVER_HELLO
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
litem
1
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
litem
.
len
!
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_SERVER_HELLO
)
;
return
SECFailure
;
}
if
(
data
-
>
len
!
=
0
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_use_srtp_xtn
;
xtnData
-
>
dtlsSRTPCipherSuite
=
cipher
;
return
SECSuccess
;
}
SECStatus
ssl3_ServerHandleUseSRTPXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECStatus
rv
;
SECItem
ciphers
=
{
siBuffer
NULL
0
}
;
PRUint16
i
;
unsigned
int
j
;
PRUint16
cipher
=
0
;
PRBool
found
=
PR_FALSE
;
SECItem
litem
;
if
(
!
IS_DTLS
(
ss
)
|
|
!
ss
-
>
ssl3
.
dtlsSRTPCipherCount
)
{
return
SECSuccess
;
}
if
(
!
data
-
>
data
|
|
data
-
>
len
<
5
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
ciphers
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
ciphers
.
len
%
2
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
for
(
i
=
0
;
!
found
&
&
i
<
ss
-
>
ssl3
.
dtlsSRTPCipherCount
;
i
+
+
)
{
for
(
j
=
0
;
j
+
1
<
ciphers
.
len
;
j
+
=
2
)
{
cipher
=
(
ciphers
.
data
[
j
]
<
<
8
)
|
ciphers
.
data
[
j
+
1
]
;
if
(
cipher
=
=
ss
-
>
ssl3
.
dtlsSRTPCiphers
[
i
]
)
{
found
=
PR_TRUE
;
break
;
}
}
}
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
litem
1
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
data
-
>
len
!
=
0
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
if
(
!
found
)
{
return
SECSuccess
;
}
xtnData
-
>
dtlsSRTPCipherSuite
=
cipher
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_use_srtp_xtn
;
return
ssl3_RegisterExtensionSender
(
ss
xtnData
ssl_use_srtp_xtn
ssl3_ServerSendUseSRTPXtn
)
;
}
SECStatus
ssl3_ServerHandleSigAlgsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECStatus
rv
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_2
)
{
return
SECSuccess
;
}
if
(
xtnData
-
>
clientSigSchemes
)
{
PORT_Free
(
xtnData
-
>
clientSigSchemes
)
;
xtnData
-
>
clientSigSchemes
=
NULL
;
}
rv
=
ssl_ParseSignatureSchemes
(
ss
NULL
&
xtnData
-
>
clientSigSchemes
&
xtnData
-
>
numClientSigScheme
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
|
|
xtnData
-
>
numClientSigScheme
=
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
if
(
data
-
>
len
!
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
return
SECSuccess
;
}
PRInt32
ssl3_ClientSendSigAlgsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
PRUint8
buf
[
MAX_SIGNATURE_SCHEMES
*
2
]
;
PRUint32
len
;
SECStatus
rv
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_2
)
{
return
0
;
}
rv
=
ssl3_EncodeSigAlgs
(
ss
buf
sizeof
(
buf
)
&
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
extension_length
=
2
+
2
+
2
+
len
;
if
(
maxBytes
<
extension_length
)
{
PORT_Assert
(
0
)
;
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_signature_algorithms_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
len
+
2
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
rv
=
ssl3_ExtAppendHandshakeVariable
(
ss
buf
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_signature_algorithms_xtn
;
}
return
extension_length
;
}
void
ssl3_CalculatePaddingExtLen
(
sslSocket
*
ss
unsigned
int
clientHelloLength
)
{
unsigned
int
recordLength
=
1
+
3
+
clientHelloLength
;
unsigned
int
extensionLen
;
if
(
IS_DTLS
(
ss
)
|
|
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_0
|
|
ss
-
>
firstHsDone
)
{
return
;
}
if
(
recordLength
<
256
|
|
recordLength
>
=
512
)
{
return
;
}
extensionLen
=
512
-
recordLength
;
if
(
extensionLen
<
4
+
1
)
{
extensionLen
=
4
+
1
;
}
ss
-
>
xtnData
.
paddingLen
=
extensionLen
-
4
;
}
PRInt32
ssl3_ClientSendPaddingExtension
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
static
unsigned
char
padding
[
252
]
=
{
0
}
;
unsigned
int
extensionLen
;
SECStatus
rv
;
if
(
!
append
|
|
!
xtnData
-
>
paddingLen
)
{
return
0
;
}
extensionLen
=
xtnData
-
>
paddingLen
+
4
;
if
(
extensionLen
>
maxBytes
|
|
xtnData
-
>
paddingLen
>
sizeof
(
padding
)
)
{
PORT_Assert
(
0
)
;
return
-
1
;
}
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_padding_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
rv
=
ssl3_ExtAppendHandshakeVariable
(
ss
padding
xtnData
-
>
paddingLen
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
return
extensionLen
;
}
PRInt32
ssl3_SendExtendedMasterSecretXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
if
(
!
ss
-
>
opt
.
enableExtendedMS
)
{
return
0
;
}
extension_length
=
4
;
if
(
maxBytes
<
extension_length
)
{
PORT_Assert
(
0
)
;
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_extended_master_secret_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
0
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_extended_master_secret_xtn
;
}
return
extension_length
;
loser
:
return
-
1
;
}
SECStatus
ssl3_HandleExtendedMasterSecretXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_0
)
{
return
SECSuccess
;
}
if
(
!
ss
-
>
opt
.
enableExtendedMS
)
{
return
SECSuccess
;
}
if
(
data
-
>
len
!
=
0
)
{
SSL_TRC
(
30
(
"
%
d
:
SSL3
[
%
d
]
:
Bogus
extended
master
secret
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
return
SECFailure
;
}
SSL_DBG
(
(
"
%
d
:
SSL
[
%
d
]
:
Negotiated
extended
master
secret
extension
.
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
if
(
ss
-
>
sec
.
isServer
)
{
return
ssl3_RegisterExtensionSender
(
ss
xtnData
ex_type
ssl3_SendExtendedMasterSecretXtn
)
;
}
return
SECSuccess
;
}
PRInt32
ssl3_ClientSendSignedCertTimestampXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
=
2
+
2
;
if
(
!
ss
-
>
opt
.
enableSignedCertTimestamps
)
return
0
;
if
(
append
&
&
maxBytes
>
=
extension_length
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_signed_cert_timestamp_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
0
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_signed_cert_timestamp_xtn
;
}
else
if
(
maxBytes
<
extension_length
)
{
PORT_Assert
(
0
)
;
return
0
;
}
return
extension_length
;
loser
:
return
-
1
;
}
SECStatus
ssl3_ClientHandleSignedCertTimestampXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECItem
*
scts
=
&
xtnData
-
>
signedCertTimestamps
;
PORT_Assert
(
!
scts
-
>
data
&
&
!
scts
-
>
len
)
;
if
(
!
data
-
>
len
)
{
return
SECFailure
;
}
*
scts
=
*
data
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
return
SECSuccess
;
}
PRInt32
ssl3_ServerSendSignedCertTimestampXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
const
SECItem
*
scts
=
&
ss
-
>
sec
.
serverCert
-
>
signedCertTimestamps
;
if
(
!
scts
-
>
len
)
{
return
0
;
}
extension_length
=
2
+
2
+
scts
-
>
len
;
if
(
maxBytes
<
extension_length
)
{
PORT_Assert
(
0
)
;
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_ExtAppendHandshakeNumber
(
ss
ssl_signed_cert_timestamp_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
rv
=
ssl3_ExtAppendHandshakeVariable
(
ss
scts
-
>
data
scts
-
>
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
-
1
;
}
}
return
extension_length
;
}
SECStatus
ssl3_ServerHandleSignedCertTimestampXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
if
(
data
-
>
len
!
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
PORT_Assert
(
ss
-
>
sec
.
isServer
)
;
return
ssl3_RegisterExtensionSender
(
ss
xtnData
ex_type
ssl3_ServerSendSignedCertTimestampXtn
)
;
}
SECStatus
ssl3_HandleSupportedPointFormatsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
int
i
;
if
(
data
-
>
len
<
2
|
|
data
-
>
len
>
255
|
|
!
data
-
>
data
|
|
data
-
>
len
!
=
(
unsigned
int
)
data
-
>
data
[
0
]
+
1
)
{
ssl3_ExtDecodeError
(
ss
)
;
return
SECFailure
;
}
for
(
i
=
data
-
>
len
;
-
-
i
>
0
;
)
{
if
(
data
-
>
data
[
i
]
=
=
0
)
{
SECStatus
rv
;
rv
=
ssl3_RegisterExtensionSender
(
ss
xtnData
ex_type
&
ssl3_SendSupportedPointFormatsXtn
)
;
return
rv
;
}
}
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HANDSHAKE
)
;
return
SECFailure
;
}
static
SECStatus
ssl_UpdateSupportedGroups
(
sslSocket
*
ss
SECItem
*
data
)
{
SECStatus
rv
;
PRUint32
list_len
;
unsigned
int
i
;
const
sslNamedGroupDef
*
enabled
[
SSL_NAMED_GROUP_COUNT
]
=
{
0
}
;
PORT_Assert
(
SSL_NAMED_GROUP_COUNT
=
=
PR_ARRAY_SIZE
(
enabled
)
)
;
if
(
!
data
-
>
data
|
|
data
-
>
len
<
4
)
{
(
void
)
ssl3_DecodeError
(
ss
)
;
return
SECFailure
;
}
rv
=
ssl3_ConsumeHandshakeNumber
(
ss
&
list_len
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
|
|
data
-
>
len
!
=
list_len
|
|
(
data
-
>
len
%
2
)
!
=
0
)
{
(
void
)
ssl3_DecodeError
(
ss
)
;
return
SECFailure
;
}
for
(
i
=
0
;
i
<
SSL_NAMED_GROUP_COUNT
;
+
+
i
)
{
enabled
[
i
]
=
ss
-
>
namedGroupPreferences
[
i
]
;
ss
-
>
namedGroupPreferences
[
i
]
=
NULL
;
}
while
(
data
-
>
len
)
{
const
sslNamedGroupDef
*
group
;
PRUint32
curve_name
;
rv
=
ssl3_ConsumeHandshakeNumber
(
ss
&
curve_name
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
group
=
ssl_LookupNamedGroup
(
curve_name
)
;
if
(
group
)
{
for
(
i
=
0
;
i
<
SSL_NAMED_GROUP_COUNT
;
+
+
i
)
{
if
(
enabled
[
i
]
&
&
group
=
=
enabled
[
i
]
)
{
ss
-
>
namedGroupPreferences
[
i
]
=
enabled
[
i
]
;
break
;
}
}
}
if
(
(
curve_name
&
0xff00
)
=
=
0x0100
)
{
ss
-
>
xtnData
.
peerSupportsFfdheGroups
=
PR_TRUE
;
}
}
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
&
&
!
ss
-
>
opt
.
requireDHENamedGroups
&
&
!
ss
-
>
xtnData
.
peerSupportsFfdheGroups
)
{
for
(
i
=
0
;
i
<
SSL_NAMED_GROUP_COUNT
;
+
+
i
)
{
if
(
enabled
[
i
]
&
&
enabled
[
i
]
-
>
keaType
=
=
ssl_kea_dh
)
{
ss
-
>
namedGroupPreferences
[
i
]
=
enabled
[
i
]
;
}
}
}
return
SECSuccess
;
}
SECStatus
ssl_HandleSupportedGroupsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
SECItem
*
data
)
{
SECStatus
rv
;
rv
=
ssl_UpdateSupportedGroups
(
CONST_CAST
(
sslSocket
ss
)
data
)
;
if
(
rv
!
=
SECSuccess
)
return
SECFailure
;
if
(
ss
-
>
sec
.
isServer
&
&
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
rv
=
ssl3_RegisterExtensionSender
(
ss
xtnData
ex_type
&
ssl_SendSupportedGroupsXtn
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ex_type
;
return
SECSuccess
;
}
