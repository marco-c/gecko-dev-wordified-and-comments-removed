#
include
"
nss
.
h
"
#
include
"
cert
.
h
"
#
include
"
ssl
.
h
"
#
include
"
cryptohi
.
h
"
#
include
"
keyhi
.
h
"
#
include
"
secder
.
h
"
#
include
"
secitem
.
h
"
#
include
"
sslimpl
.
h
"
#
include
"
sslproto
.
h
"
#
include
"
sslerr
.
h
"
#
include
"
prtime
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
prerror
.
h
"
#
include
"
pratom
.
h
"
#
include
"
prthread
.
h
"
#
include
"
prinit
.
h
"
#
include
"
pk11func
.
h
"
#
include
"
secmod
.
h
"
#
include
<
stdio
.
h
>
#
ifndef
PK11_SETATTRS
#
define
PK11_SETATTRS
(
x
id
v
l
)
\
(
x
)
-
>
type
=
(
id
)
;
\
(
x
)
-
>
pValue
=
(
v
)
;
\
(
x
)
-
>
ulValueLen
=
(
l
)
;
#
endif
static
SECStatus
ssl_CreateECDHEphemeralKeys
(
sslSocket
*
ss
const
namedGroupDef
*
ecGroup
)
;
typedef
struct
ECDHEKeyPairStr
{
sslEphemeralKeyPair
*
pair
;
int
error
;
PRCallOnceType
once
;
}
ECDHEKeyPair
;
static
PRCallOnceType
gECDHEInitOnce
;
static
int
gECDHEInitError
;
static
ECDHEKeyPair
gECDHEKeyPairs
[
29
]
;
SECStatus
ssl_NamedGroup2ECParams
(
PLArenaPool
*
arena
const
namedGroupDef
*
ecGroup
SECKEYECParams
*
params
)
{
SECOidData
*
oidData
=
NULL
;
PRUint32
policyFlags
=
0
;
SECStatus
rv
;
if
(
!
params
)
{
PORT_Assert
(
0
)
;
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
!
ecGroup
|
|
ecGroup
-
>
type
!
=
group_type_ec
|
|
(
oidData
=
SECOID_FindOIDByTag
(
ecGroup
-
>
oidTag
)
)
=
=
NULL
)
{
PORT_SetError
(
SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE
)
;
return
SECFailure
;
}
rv
=
NSS_GetAlgorithmPolicy
(
ecGroup
-
>
oidTag
&
policyFlags
)
;
if
(
rv
=
=
SECSuccess
&
&
!
(
policyFlags
&
NSS_USE_ALG_IN_SSL_KX
)
)
{
PORT_SetError
(
SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE
)
;
return
SECFailure
;
}
if
(
SECITEM_AllocItem
(
arena
params
(
2
+
oidData
-
>
oid
.
len
)
)
=
=
NULL
)
{
PORT_SetError
(
SEC_ERROR_NO_MEMORY
)
;
return
SECFailure
;
}
params
-
>
data
[
0
]
=
SEC_ASN1_OBJECT_ID
;
params
-
>
data
[
1
]
=
oidData
-
>
oid
.
len
;
memcpy
(
params
-
>
data
+
2
oidData
-
>
oid
.
data
oidData
-
>
oid
.
len
)
;
return
SECSuccess
;
}
const
namedGroupDef
*
ssl_ECPubKey2NamedGroup
(
const
SECKEYPublicKey
*
pubKey
)
{
SECItem
oid
=
{
siBuffer
NULL
0
}
;
SECOidData
*
oidData
=
NULL
;
PRUint32
policyFlags
=
0
;
unsigned
int
i
;
const
SECKEYECParams
*
params
;
if
(
pubKey
-
>
keyType
!
=
ecKey
)
{
PORT_Assert
(
0
)
;
return
NULL
;
}
params
=
&
pubKey
-
>
u
.
ec
.
DEREncodedParams
;
if
(
params
-
>
data
[
0
]
!
=
SEC_ASN1_OBJECT_ID
)
return
NULL
;
oid
.
len
=
params
-
>
len
-
2
;
oid
.
data
=
params
-
>
data
+
2
;
if
(
(
oidData
=
SECOID_FindOID
(
&
oid
)
)
=
=
NULL
)
return
NULL
;
if
(
(
NSS_GetAlgorithmPolicy
(
oidData
-
>
offset
&
policyFlags
)
=
=
SECSuccess
)
&
&
!
(
policyFlags
&
NSS_USE_ALG_IN_SSL_KX
)
)
{
return
NULL
;
}
for
(
i
=
0
;
i
<
ssl_named_group_count
;
+
+
i
)
{
if
(
ssl_named_groups
[
i
]
.
oidTag
=
=
oidData
-
>
offset
)
{
return
&
ssl_named_groups
[
i
]
;
}
}
return
NULL
;
}
static
SECStatus
ssl3_ComputeECDHKeyHash
(
SSLHashType
hashAlg
SECItem
ec_params
SECItem
server_ecpoint
SSL3Random
*
client_rand
SSL3Random
*
server_rand
SSL3Hashes
*
hashes
PRBool
bypassPKCS11
)
{
PRUint8
*
hashBuf
;
PRUint8
*
pBuf
;
SECStatus
rv
=
SECSuccess
;
unsigned
int
bufLen
;
PRUint8
buf
[
2
*
SSL3_RANDOM_LENGTH
+
2
+
1
+
256
]
;
bufLen
=
2
*
SSL3_RANDOM_LENGTH
+
ec_params
.
len
+
1
+
server_ecpoint
.
len
;
if
(
bufLen
<
=
sizeof
buf
)
{
hashBuf
=
buf
;
}
else
{
hashBuf
=
PORT_Alloc
(
bufLen
)
;
if
(
!
hashBuf
)
{
return
SECFailure
;
}
}
memcpy
(
hashBuf
client_rand
SSL3_RANDOM_LENGTH
)
;
pBuf
=
hashBuf
+
SSL3_RANDOM_LENGTH
;
memcpy
(
pBuf
server_rand
SSL3_RANDOM_LENGTH
)
;
pBuf
+
=
SSL3_RANDOM_LENGTH
;
memcpy
(
pBuf
ec_params
.
data
ec_params
.
len
)
;
pBuf
+
=
ec_params
.
len
;
pBuf
[
0
]
=
(
PRUint8
)
(
server_ecpoint
.
len
)
;
pBuf
+
=
1
;
memcpy
(
pBuf
server_ecpoint
.
data
server_ecpoint
.
len
)
;
pBuf
+
=
server_ecpoint
.
len
;
PORT_Assert
(
(
unsigned
int
)
(
pBuf
-
hashBuf
)
=
=
bufLen
)
;
rv
=
ssl3_ComputeCommonKeyHash
(
hashAlg
hashBuf
bufLen
hashes
bypassPKCS11
)
;
PRINT_BUF
(
95
(
NULL
"
ECDHkey
hash
:
"
hashBuf
bufLen
)
)
;
PRINT_BUF
(
95
(
NULL
"
ECDHkey
hash
:
MD5
result
"
hashes
-
>
u
.
s
.
md5
MD5_LENGTH
)
)
;
PRINT_BUF
(
95
(
NULL
"
ECDHkey
hash
:
SHA1
result
"
hashes
-
>
u
.
s
.
sha
SHA1_LENGTH
)
)
;
if
(
hashBuf
!
=
buf
)
PORT_Free
(
hashBuf
)
;
return
rv
;
}
SECStatus
ssl3_SendECDHClientKeyExchange
(
sslSocket
*
ss
SECKEYPublicKey
*
svrPubKey
)
{
PK11SymKey
*
pms
=
NULL
;
SECStatus
rv
=
SECFailure
;
PRBool
isTLS
isTLS12
;
CK_MECHANISM_TYPE
target
;
const
namedGroupDef
*
groupDef
;
sslEphemeralKeyPair
*
keyPair
=
NULL
;
SECKEYPublicKey
*
pubKey
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveSSL3HandshakeLock
(
ss
)
)
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveXmitBufLock
(
ss
)
)
;
isTLS
=
(
PRBool
)
(
ss
-
>
ssl3
.
pwSpec
-
>
version
>
SSL_LIBRARY_VERSION_3_0
)
;
isTLS12
=
(
PRBool
)
(
ss
-
>
ssl3
.
pwSpec
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_2
)
;
if
(
svrPubKey
-
>
keyType
!
=
ecKey
)
{
PORT_SetError
(
SEC_ERROR_BAD_KEY
)
;
goto
loser
;
}
groupDef
=
ssl_ECPubKey2NamedGroup
(
svrPubKey
)
;
if
(
!
groupDef
)
{
PORT_SetError
(
SEC_ERROR_BAD_KEY
)
;
goto
loser
;
}
rv
=
ssl_CreateECDHEphemeralKeyPair
(
groupDef
&
keyPair
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl_MapLowLevelError
(
SEC_ERROR_KEYGEN_FAIL
)
;
goto
loser
;
}
pubKey
=
keyPair
-
>
keys
-
>
pubKey
;
PRINT_BUF
(
50
(
ss
"
ECDH
public
value
:
"
pubKey
-
>
u
.
ec
.
publicValue
.
data
pubKey
-
>
u
.
ec
.
publicValue
.
len
)
)
;
if
(
isTLS12
)
{
target
=
CKM_TLS12_MASTER_KEY_DERIVE_DH
;
}
else
if
(
isTLS
)
{
target
=
CKM_TLS_MASTER_KEY_DERIVE_DH
;
}
else
{
target
=
CKM_SSL3_MASTER_KEY_DERIVE_DH
;
}
pms
=
PK11_PubDeriveWithKDF
(
keyPair
-
>
keys
-
>
privKey
svrPubKey
PR_FALSE
NULL
NULL
CKM_ECDH1_DERIVE
target
CKA_DERIVE
0
CKD_NULL
NULL
NULL
)
;
if
(
pms
=
=
NULL
)
{
(
void
)
SSL3_SendAlert
(
ss
alert_fatal
illegal_parameter
)
;
ssl_MapLowLevelError
(
SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE
)
;
goto
loser
;
}
rv
=
ssl3_AppendHandshakeHeader
(
ss
client_key_exchange
pubKey
-
>
u
.
ec
.
publicValue
.
len
+
1
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_AppendHandshakeVariable
(
ss
pubKey
-
>
u
.
ec
.
publicValue
.
data
pubKey
-
>
u
.
ec
.
publicValue
.
len
1
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_InitPendingCipherSpec
(
ss
pms
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl_MapLowLevelError
(
SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE
)
;
goto
loser
;
}
PK11_FreeSymKey
(
pms
)
;
ssl_FreeEphemeralKeyPair
(
keyPair
)
;
return
SECSuccess
;
loser
:
if
(
pms
)
PK11_FreeSymKey
(
pms
)
;
if
(
keyPair
)
ssl_FreeEphemeralKeyPair
(
keyPair
)
;
return
SECFailure
;
}
unsigned
int
tls13_SizeOfECDHEKeyShareKEX
(
const
SECKEYPublicKey
*
pubKey
)
{
PORT_Assert
(
pubKey
-
>
keyType
=
=
ecKey
)
;
return
pubKey
-
>
u
.
ec
.
publicValue
.
len
;
}
SECStatus
tls13_EncodeECDHEKeyShareKEX
(
sslSocket
*
ss
const
SECKEYPublicKey
*
pubKey
)
{
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveSSL3HandshakeLock
(
ss
)
)
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveXmitBufLock
(
ss
)
)
;
PORT_Assert
(
pubKey
-
>
keyType
=
=
ecKey
)
;
return
ssl3_AppendHandshake
(
ss
pubKey
-
>
u
.
ec
.
publicValue
.
data
pubKey
-
>
u
.
ec
.
publicValue
.
len
)
;
}
SECStatus
ssl3_HandleECDHClientKeyExchange
(
sslSocket
*
ss
SSL3Opaque
*
b
PRUint32
length
sslKeyPair
*
serverKeyPair
)
{
PK11SymKey
*
pms
;
SECStatus
rv
;
SECKEYPublicKey
clntPubKey
;
CK_MECHANISM_TYPE
target
;
PRBool
isTLS
isTLS12
;
int
errCode
=
SSL_ERROR_RX_MALFORMED_CLIENT_KEY_EXCH
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveRecvBufLock
(
ss
)
)
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveSSL3HandshakeLock
(
ss
)
)
;
clntPubKey
.
keyType
=
ecKey
;
clntPubKey
.
u
.
ec
.
DEREncodedParams
.
len
=
serverKeyPair
-
>
pubKey
-
>
u
.
ec
.
DEREncodedParams
.
len
;
clntPubKey
.
u
.
ec
.
DEREncodedParams
.
data
=
serverKeyPair
-
>
pubKey
-
>
u
.
ec
.
DEREncodedParams
.
data
;
rv
=
ssl3_ConsumeHandshakeVariable
(
ss
&
clntPubKey
.
u
.
ec
.
publicValue
1
&
b
&
length
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
errCode
)
;
return
SECFailure
;
}
if
(
!
clntPubKey
.
u
.
ec
.
publicValue
.
len
)
{
(
void
)
SSL3_SendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
errCode
)
;
return
SECFailure
;
}
isTLS
=
(
PRBool
)
(
ss
-
>
ssl3
.
prSpec
-
>
version
>
SSL_LIBRARY_VERSION_3_0
)
;
isTLS12
=
(
PRBool
)
(
ss
-
>
ssl3
.
prSpec
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_2
)
;
if
(
isTLS12
)
{
target
=
CKM_TLS12_MASTER_KEY_DERIVE_DH
;
}
else
if
(
isTLS
)
{
target
=
CKM_TLS_MASTER_KEY_DERIVE_DH
;
}
else
{
target
=
CKM_SSL3_MASTER_KEY_DERIVE_DH
;
}
pms
=
PK11_PubDeriveWithKDF
(
serverKeyPair
-
>
privKey
&
clntPubKey
PR_FALSE
NULL
NULL
CKM_ECDH1_DERIVE
target
CKA_DERIVE
0
CKD_NULL
NULL
NULL
)
;
if
(
pms
=
=
NULL
)
{
errCode
=
ssl_MapLowLevelError
(
SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE
)
;
PORT_SetError
(
errCode
)
;
return
SECFailure
;
}
rv
=
ssl3_InitPendingCipherSpec
(
ss
pms
)
;
PK11_FreeSymKey
(
pms
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
tls13_ImportECDHKeyShare
(
sslSocket
*
ss
SECKEYPublicKey
*
peerKey
SSL3Opaque
*
b
PRUint32
length
const
namedGroupDef
*
ecGroup
)
{
SECStatus
rv
;
SECItem
ecPoint
=
{
siBuffer
NULL
0
}
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveRecvBufLock
(
ss
)
)
;
PORT_Assert
(
ss
-
>
opt
.
noLocks
|
|
ssl_HaveSSL3HandshakeLock
(
ss
)
)
;
if
(
!
length
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_ECDHE_KEY_SHARE
)
;
return
SECFailure
;
}
if
(
b
[
0
]
!
=
EC_POINT_FORM_UNCOMPRESSED
)
{
PORT_SetError
(
SEC_ERROR_UNSUPPORTED_EC_POINT_FORM
)
;
return
SECFailure
;
}
peerKey
-
>
keyType
=
ecKey
;
rv
=
ssl_NamedGroup2ECParams
(
peerKey
-
>
arena
ecGroup
&
peerKey
-
>
u
.
ec
.
DEREncodedParams
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl_MapLowLevelError
(
SSL_ERROR_RX_MALFORMED_ECDHE_KEY_SHARE
)
;
return
SECFailure
;
}
ecPoint
.
data
=
b
;
ecPoint
.
len
=
length
;
rv
=
SECITEM_CopyItem
(
peerKey
-
>
arena
&
peerKey
-
>
u
.
ec
.
publicValue
&
ecPoint
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
return
SECSuccess
;
}
const
namedGroupDef
*
ssl_GetECGroupWithStrength
(
PRUint32
curvemsk
int
requiredECCbits
)
{
int
i
;
for
(
i
=
0
;
i
<
ssl_named_group_count
;
i
+
+
)
{
if
(
ssl_named_groups
[
i
]
.
type
!
=
group_type_ec
|
|
ssl_named_groups
[
i
]
.
bits
<
requiredECCbits
)
{
continue
;
}
if
(
(
curvemsk
&
(
1U
<
<
i
)
)
)
{
return
&
ssl_named_groups
[
i
]
;
}
}
PORT_SetError
(
SSL_ERROR_NO_CYPHER_OVERLAP
)
;
return
NULL
;
}
const
namedGroupDef
*
ssl_GetECGroupForServerSocket
(
sslSocket
*
ss
)
{
const
sslServerCert
*
cert
=
ss
-
>
sec
.
serverCert
;
int
certKeySize
;
int
requiredECCbits
=
ss
-
>
sec
.
secretKeyBits
*
2
;
PORT_Assert
(
cert
)
;
if
(
!
cert
|
|
!
cert
-
>
serverKeyPair
|
|
!
cert
-
>
serverKeyPair
-
>
pubKey
)
{
PORT_SetError
(
SSL_ERROR_NO_CYPHER_OVERLAP
)
;
return
NULL
;
}
if
(
cert
-
>
certType
.
authType
=
=
ssl_auth_rsa_sign
)
{
certKeySize
=
SECKEY_PublicKeyStrengthInBits
(
cert
-
>
serverKeyPair
-
>
pubKey
)
;
certKeySize
=
SSL_RSASTRENGTH_TO_ECSTRENGTH
(
certKeySize
)
;
}
else
if
(
cert
-
>
certType
.
authType
=
=
ssl_auth_ecdsa
|
|
cert
-
>
certType
.
authType
=
=
ssl_auth_ecdh_rsa
|
|
cert
-
>
certType
.
authType
=
=
ssl_auth_ecdh_ecdsa
)
{
const
namedGroupDef
*
groupDef
=
cert
-
>
certType
.
namedCurve
;
PORT_Assert
(
groupDef
-
>
type
=
=
group_type_ec
)
;
PORT_Assert
(
ssl_NamedGroupEnabled
(
ss
groupDef
)
)
;
if
(
!
ssl_NamedGroupEnabled
(
ss
groupDef
)
)
{
return
NULL
;
}
certKeySize
=
groupDef
-
>
bits
;
}
else
{
PORT_Assert
(
0
)
;
return
NULL
;
}
if
(
requiredECCbits
>
certKeySize
)
{
requiredECCbits
=
certKeySize
;
}
return
ssl_GetECGroupWithStrength
(
ss
-
>
namedGroups
requiredECCbits
)
;
}
static
SECStatus
ssl_ShutdownECDHECurves
(
void
*
appData
void
*
nssData
)
{
int
i
;
for
(
i
=
0
;
i
<
PR_ARRAY_SIZE
(
gECDHEKeyPairs
)
;
i
+
+
)
{
if
(
gECDHEKeyPairs
[
i
]
.
pair
)
{
ssl_FreeEphemeralKeyPair
(
gECDHEKeyPairs
[
i
]
.
pair
)
;
}
}
memset
(
gECDHEKeyPairs
0
sizeof
(
gECDHEKeyPairs
)
)
;
return
SECSuccess
;
}
static
PRStatus
ssl_ECRegister
(
void
)
{
SECStatus
rv
;
PORT_Assert
(
PR_ARRAY_SIZE
(
gECDHEKeyPairs
)
=
=
ssl_named_group_count
)
;
rv
=
NSS_RegisterShutdown
(
ssl_ShutdownECDHECurves
gECDHEKeyPairs
)
;
if
(
rv
!
=
SECSuccess
)
{
gECDHEInitError
=
PORT_GetError
(
)
;
}
return
(
PRStatus
)
rv
;
}
SECStatus
ssl_CreateECDHEphemeralKeyPair
(
const
namedGroupDef
*
ecGroup
sslEphemeralKeyPair
*
*
keyPair
)
{
SECKEYPrivateKey
*
privKey
=
NULL
;
SECKEYPublicKey
*
pubKey
=
NULL
;
SECKEYECParams
ecParams
=
{
siBuffer
NULL
0
}
;
sslEphemeralKeyPair
*
pair
;
if
(
ssl_NamedGroup2ECParams
(
NULL
ecGroup
&
ecParams
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
privKey
=
SECKEY_CreateECPrivateKey
(
&
ecParams
&
pubKey
NULL
)
;
SECITEM_FreeItem
(
&
ecParams
PR_FALSE
)
;
if
(
!
privKey
|
|
!
pubKey
|
|
!
(
pair
=
ssl_NewEphemeralKeyPair
(
ecGroup
privKey
pubKey
)
)
)
{
if
(
privKey
)
{
SECKEY_DestroyPrivateKey
(
privKey
)
;
}
if
(
pubKey
)
{
SECKEY_DestroyPublicKey
(
pubKey
)
;
}
ssl_MapLowLevelError
(
SEC_ERROR_KEYGEN_FAIL
)
;
return
SECFailure
;
}
*
keyPair
=
pair
;
return
SECSuccess
;
}
static
PRStatus
ssl_CreateECDHEphemeralKeyPairOnce
(
void
*
arg
)
{
const
namedGroupDef
*
groupDef
=
(
const
namedGroupDef
*
)
arg
;
sslEphemeralKeyPair
*
keyPair
=
NULL
;
SECStatus
rv
;
PORT_Assert
(
groupDef
-
>
type
=
=
group_type_ec
)
;
PORT_Assert
(
gECDHEKeyPairs
[
groupDef
-
>
index
]
.
pair
=
=
NULL
)
;
rv
=
ssl_CreateECDHEphemeralKeyPair
(
groupDef
&
keyPair
)
;
if
(
rv
!
=
SECSuccess
)
{
gECDHEKeyPairs
[
groupDef
-
>
index
]
.
error
=
PORT_GetError
(
)
;
return
PR_FAILURE
;
}
gECDHEKeyPairs
[
groupDef
-
>
index
]
.
pair
=
keyPair
;
return
PR_SUCCESS
;
}
static
SECStatus
ssl_CreateECDHEphemeralKeys
(
sslSocket
*
ss
const
namedGroupDef
*
ecGroup
)
{
sslEphemeralKeyPair
*
keyPair
=
NULL
;
if
(
gECDHEKeyPairs
[
ecGroup
-
>
index
]
.
pair
=
=
NULL
)
{
PRStatus
status
;
status
=
PR_CallOnce
(
&
gECDHEInitOnce
ssl_ECRegister
)
;
if
(
status
!
=
PR_SUCCESS
)
{
PORT_SetError
(
gECDHEInitError
)
;
return
SECFailure
;
}
status
=
PR_CallOnceWithArg
(
&
gECDHEKeyPairs
[
ecGroup
-
>
index
]
.
once
ssl_CreateECDHEphemeralKeyPairOnce
(
void
*
)
ecGroup
)
;
if
(
status
!
=
PR_SUCCESS
)
{
PORT_SetError
(
gECDHEKeyPairs
[
ecGroup
-
>
index
]
.
error
)
;
return
SECFailure
;
}
}
keyPair
=
ssl_CopyEphemeralKeyPair
(
gECDHEKeyPairs
[
ecGroup
-
>
index
]
.
pair
)
;
PORT_Assert
(
keyPair
!
=
NULL
)
;
if
(
!
keyPair
)
return
SECFailure
;
PORT_Assert
(
PR_CLIST_IS_EMPTY
(
&
ss
-
>
ephemeralKeyPairs
)
)
;
PR_APPEND_LINK
(
&
keyPair
-
>
link
&
ss
-
>
ephemeralKeyPairs
)
;
return
SECSuccess
;
}
SECStatus
ssl3_HandleECDHServerKeyExchange
(
sslSocket
*
ss
SSL3Opaque
*
b
PRUint32
length
)
{
PLArenaPool
*
arena
=
NULL
;
SECKEYPublicKey
*
peerKey
=
NULL
;
PRBool
isTLS
;
SECStatus
rv
;
int
errCode
=
SSL_ERROR_RX_MALFORMED_SERVER_KEY_EXCH
;
SSL3AlertDescription
desc
=
illegal_parameter
;
SSL3Hashes
hashes
;
SECItem
signature
=
{
siBuffer
NULL
0
}
;
SSLHashType
hashAlg
=
ssl_hash_none
;
SECItem
ec_params
=
{
siBuffer
NULL
0
}
;
SECItem
ec_point
=
{
siBuffer
NULL
0
}
;
unsigned
char
paramBuf
[
3
]
;
const
namedGroupDef
*
ecGroup
;
isTLS
=
(
PRBool
)
(
ss
-
>
ssl3
.
prSpec
-
>
version
>
SSL_LIBRARY_VERSION_3_0
)
;
ec_params
.
len
=
sizeof
paramBuf
;
ec_params
.
data
=
paramBuf
;
rv
=
ssl3_ConsumeHandshake
(
ss
ec_params
.
data
ec_params
.
len
&
b
&
length
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
ec_params
.
data
[
0
]
!
=
ec_type_named
)
{
errCode
=
SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE
;
desc
=
handshake_failure
;
goto
alert_loser
;
}
ecGroup
=
ssl_LookupNamedGroup
(
ec_params
.
data
[
1
]
<
<
8
|
ec_params
.
data
[
2
]
)
;
if
(
!
ecGroup
|
|
ecGroup
-
>
type
!
=
group_type_ec
)
{
errCode
=
SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE
;
desc
=
handshake_failure
;
goto
alert_loser
;
}
rv
=
ssl3_ConsumeHandshakeVariable
(
ss
&
ec_point
1
&
b
&
length
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
!
ec_point
.
len
)
{
goto
alert_loser
;
}
if
(
ec_point
.
data
[
0
]
!
=
EC_POINT_FORM_UNCOMPRESSED
)
{
errCode
=
SEC_ERROR_UNSUPPORTED_EC_POINT_FORM
;
desc
=
handshake_failure
;
goto
alert_loser
;
}
if
(
ss
-
>
ssl3
.
prSpec
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_2
)
{
SSLSignatureAndHashAlg
sigAndHash
;
rv
=
ssl3_ConsumeSignatureAndHashAlgorithm
(
ss
&
b
&
length
&
sigAndHash
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_CheckSignatureAndHashAlgorithmConsistency
(
ss
&
sigAndHash
ss
-
>
sec
.
peerCert
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
hashAlg
=
sigAndHash
.
hashAlg
;
}
rv
=
ssl3_ConsumeHandshakeVariable
(
ss
&
signature
2
&
b
&
length
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
length
!
=
0
)
{
if
(
isTLS
)
desc
=
decode_error
;
goto
alert_loser
;
}
PRINT_BUF
(
60
(
NULL
"
Server
EC
params
"
ec_params
.
data
ec_params
.
len
)
)
;
PRINT_BUF
(
60
(
NULL
"
Server
EC
point
"
ec_point
.
data
ec_point
.
len
)
)
;
desc
=
isTLS
?
decrypt_error
:
handshake_failure
;
rv
=
ssl3_ComputeECDHKeyHash
(
hashAlg
ec_params
ec_point
&
ss
-
>
ssl3
.
hs
.
client_random
&
ss
-
>
ssl3
.
hs
.
server_random
&
hashes
ss
-
>
opt
.
bypassPKCS11
)
;
if
(
rv
!
=
SECSuccess
)
{
errCode
=
ssl_MapLowLevelError
(
SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE
)
;
goto
alert_loser
;
}
rv
=
ssl3_VerifySignedHashes
(
&
hashes
ss
-
>
sec
.
peerCert
&
signature
isTLS
ss
-
>
pkcs11PinArg
)
;
if
(
rv
!
=
SECSuccess
)
{
errCode
=
ssl_MapLowLevelError
(
SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE
)
;
goto
alert_loser
;
}
arena
=
PORT_NewArena
(
DER_DEFAULT_CHUNKSIZE
)
;
if
(
arena
=
=
NULL
)
{
errCode
=
SEC_ERROR_NO_MEMORY
;
goto
loser
;
}
peerKey
=
PORT_ArenaZNew
(
arena
SECKEYPublicKey
)
;
if
(
peerKey
=
=
NULL
)
{
errCode
=
SEC_ERROR_NO_MEMORY
;
goto
loser
;
}
peerKey
-
>
arena
=
arena
;
peerKey
-
>
keyType
=
ecKey
;
rv
=
ssl_NamedGroup2ECParams
(
arena
ecGroup
&
peerKey
-
>
u
.
ec
.
DEREncodedParams
)
;
if
(
rv
!
=
SECSuccess
)
{
errCode
=
SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE
;
goto
alert_loser
;
}
if
(
SECITEM_CopyItem
(
arena
&
peerKey
-
>
u
.
ec
.
publicValue
&
ec_point
)
)
{
errCode
=
SEC_ERROR_NO_MEMORY
;
goto
loser
;
}
peerKey
-
>
pkcs11Slot
=
NULL
;
peerKey
-
>
pkcs11ID
=
CK_INVALID_HANDLE
;
ss
-
>
sec
.
peerKey
=
peerKey
;
return
SECSuccess
;
alert_loser
:
(
void
)
SSL3_SendAlert
(
ss
alert_fatal
desc
)
;
loser
:
if
(
arena
)
{
PORT_FreeArena
(
arena
PR_FALSE
)
;
}
PORT_SetError
(
errCode
)
;
return
SECFailure
;
}
SECStatus
ssl3_SendECDHServerKeyExchange
(
sslSocket
*
ss
const
SSLSignatureAndHashAlg
*
sigAndHash
)
{
SECStatus
rv
=
SECFailure
;
int
length
;
PRBool
isTLS
isTLS12
;
SECItem
signed_hash
=
{
siBuffer
NULL
0
}
;
SSL3Hashes
hashes
;
SECItem
ec_params
=
{
siBuffer
NULL
0
}
;
unsigned
char
paramBuf
[
3
]
;
const
namedGroupDef
*
ecGroup
;
sslEphemeralKeyPair
*
keyPair
;
SECKEYPublicKey
*
pubKey
;
ecGroup
=
ssl_GetECGroupForServerSocket
(
ss
)
;
if
(
!
ecGroup
)
{
goto
loser
;
}
PORT_Assert
(
PR_CLIST_IS_EMPTY
(
&
ss
-
>
ephemeralKeyPairs
)
)
;
if
(
ss
-
>
opt
.
reuseServerECDHEKey
)
{
rv
=
ssl_CreateECDHEphemeralKeys
(
ss
ecGroup
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
keyPair
=
(
sslEphemeralKeyPair
*
)
PR_NEXT_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
;
}
else
{
rv
=
ssl_CreateECDHEphemeralKeyPair
(
ecGroup
&
keyPair
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
PR_APPEND_LINK
(
&
keyPair
-
>
link
&
ss
-
>
ephemeralKeyPairs
)
;
}
PORT_Assert
(
keyPair
)
;
if
(
!
keyPair
)
{
PORT_SetError
(
SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE
)
;
return
SECFailure
;
}
ec_params
.
len
=
sizeof
(
paramBuf
)
;
ec_params
.
data
=
paramBuf
;
PORT_Assert
(
keyPair
-
>
group
)
;
PORT_Assert
(
keyPair
-
>
group
-
>
type
=
=
group_type_ec
)
;
ec_params
.
data
[
0
]
=
ec_type_named
;
ec_params
.
data
[
1
]
=
keyPair
-
>
group
-
>
name
>
>
8
;
ec_params
.
data
[
2
]
=
keyPair
-
>
group
-
>
name
&
0xff
;
pubKey
=
keyPair
-
>
keys
-
>
pubKey
;
rv
=
ssl3_ComputeECDHKeyHash
(
sigAndHash
-
>
hashAlg
ec_params
pubKey
-
>
u
.
ec
.
publicValue
&
ss
-
>
ssl3
.
hs
.
client_random
&
ss
-
>
ssl3
.
hs
.
server_random
&
hashes
ss
-
>
opt
.
bypassPKCS11
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl_MapLowLevelError
(
SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE
)
;
goto
loser
;
}
isTLS
=
(
PRBool
)
(
ss
-
>
ssl3
.
pwSpec
-
>
version
>
SSL_LIBRARY_VERSION_3_0
)
;
isTLS12
=
(
PRBool
)
(
ss
-
>
ssl3
.
pwSpec
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_2
)
;
rv
=
ssl3_SignHashes
(
&
hashes
ss
-
>
sec
.
serverCert
-
>
serverKeyPair
-
>
privKey
&
signed_hash
isTLS
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
signed_hash
.
data
=
=
NULL
)
{
PORT_SetError
(
SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE
)
;
goto
loser
;
}
length
=
ec_params
.
len
+
1
+
pubKey
-
>
u
.
ec
.
publicValue
.
len
+
(
isTLS12
?
2
:
0
)
+
2
+
signed_hash
.
len
;
rv
=
ssl3_AppendHandshakeHeader
(
ss
server_key_exchange
length
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_AppendHandshake
(
ss
ec_params
.
data
ec_params
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_AppendHandshakeVariable
(
ss
pubKey
-
>
u
.
ec
.
publicValue
.
data
pubKey
-
>
u
.
ec
.
publicValue
.
len
1
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
isTLS12
)
{
rv
=
ssl3_AppendSignatureAndHashAlgorithm
(
ss
sigAndHash
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
}
rv
=
ssl3_AppendHandshakeVariable
(
ss
signed_hash
.
data
signed_hash
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
PORT_Free
(
signed_hash
.
data
)
;
return
SECSuccess
;
loser
:
if
(
signed_hash
.
data
!
=
NULL
)
PORT_Free
(
signed_hash
.
data
)
;
return
SECFailure
;
}
static
const
ssl3CipherSuite
ssl_all_ec_suites
[
]
=
{
TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
TLS_ECDHE_ECDSA_WITH_NULL_SHA
TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
TLS_ECDHE_RSA_WITH_NULL_SHA
TLS_ECDHE_RSA_WITH_RC4_128_SHA
TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
TLS_ECDH_ECDSA_WITH_NULL_SHA
TLS_ECDH_ECDSA_WITH_RC4_128_SHA
TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
TLS_ECDH_RSA_WITH_NULL_SHA
TLS_ECDH_RSA_WITH_RC4_128_SHA
0
}
;
static
const
ssl3CipherSuite
ssl_dhe_suites
[
]
=
{
TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
TLS_DHE_DSS_WITH_AES_128_GCM_SHA256
TLS_DHE_RSA_WITH_AES_128_CBC_SHA
TLS_DHE_DSS_WITH_AES_128_CBC_SHA
TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA
TLS_DHE_RSA_WITH_AES_256_CBC_SHA
TLS_DHE_DSS_WITH_AES_256_CBC_SHA
TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA
TLS_DHE_DSS_WITH_RC4_128_SHA
TLS_DHE_RSA_WITH_DES_CBC_SHA
TLS_DHE_DSS_WITH_DES_CBC_SHA
0
}
;
static
PRBool
ssl_IsSuiteEnabled
(
sslSocket
*
ss
const
ssl3CipherSuite
*
list
)
{
const
ssl3CipherSuite
*
suite
;
for
(
suite
=
list
;
*
suite
;
+
+
suite
)
{
PRBool
enabled
=
PR_FALSE
;
SECStatus
rv
=
ssl3_CipherPrefGet
(
ss
*
suite
&
enabled
)
;
PORT_Assert
(
rv
=
=
SECSuccess
)
;
if
(
rv
=
=
SECSuccess
&
&
enabled
)
return
PR_TRUE
;
}
return
PR_FALSE
;
}
static
PRBool
ssl_IsECCEnabled
(
sslSocket
*
ss
)
{
PK11SlotInfo
*
slot
;
slot
=
PK11_GetBestSlot
(
CKM_ECDH1_DERIVE
ss
-
>
pkcs11PinArg
)
;
if
(
!
slot
)
{
return
PR_FALSE
;
}
PK11_FreeSlot
(
slot
)
;
return
ssl_IsSuiteEnabled
(
ss
ssl_all_ec_suites
)
;
}
PRBool
ssl_SuiteBOnly
(
sslSocket
*
ss
)
{
PK11SlotInfo
*
slot
=
PK11_GetBestSlotWithAttributes
(
CKM_ECDH1_DERIVE
0
163
ss
?
ss
-
>
pkcs11PinArg
:
NULL
)
;
if
(
!
slot
)
{
return
PR_TRUE
;
}
PK11_FreeSlot
(
slot
)
;
return
PR_FALSE
;
}
PRInt32
ssl_SendSupportedGroupsXtn
(
sslSocket
*
ss
PRBool
append
PRUint32
maxBytes
)
{
PRInt32
extension_length
;
unsigned
char
enabledGroups
[
64
]
;
unsigned
int
enabledGroupsLen
=
0
;
unsigned
int
i
;
PRBool
ec
;
PRBool
ff
=
PR_FALSE
;
if
(
!
ss
)
return
0
;
ec
=
ssl_IsECCEnabled
(
ss
)
;
if
(
ss
-
>
opt
.
requireDHENamedGroups
|
|
ss
-
>
vrange
.
max
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
ff
=
ssl_IsSuiteEnabled
(
ss
ssl_dhe_suites
)
;
}
if
(
!
ec
&
&
!
ff
)
{
return
0
;
}
PORT_Assert
(
sizeof
(
enabledGroups
)
>
ssl_named_group_count
*
2
)
;
for
(
i
=
0
;
i
<
ssl_named_group_count
;
+
+
i
)
{
if
(
ssl_named_groups
[
i
]
.
type
=
=
group_type_ec
&
&
!
ec
)
{
continue
;
}
if
(
ssl_named_groups
[
i
]
.
type
=
=
group_type_ff
&
&
!
ff
)
{
continue
;
}
if
(
!
ssl_NamedGroupEnabled
(
ss
&
ssl_named_groups
[
i
]
)
)
{
continue
;
}
if
(
append
)
{
enabledGroups
[
enabledGroupsLen
+
+
]
=
ssl_named_groups
[
i
]
.
name
>
>
8
;
enabledGroups
[
enabledGroupsLen
+
+
]
=
ssl_named_groups
[
i
]
.
name
&
0xff
;
}
else
{
enabledGroupsLen
+
=
2
;
}
}
extension_length
=
2
+
2
+
2
+
enabledGroupsLen
;
if
(
maxBytes
<
(
PRUint32
)
extension_length
)
{
return
0
;
}
if
(
append
)
{
SECStatus
rv
;
rv
=
ssl3_AppendHandshakeNumber
(
ss
ssl_supported_groups_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_AppendHandshakeNumber
(
ss
extension_length
-
4
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
rv
=
ssl3_AppendHandshakeVariable
(
ss
enabledGroups
enabledGroupsLen
2
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
if
(
!
ss
-
>
sec
.
isServer
)
{
TLSExtensionData
*
xtnData
=
&
ss
-
>
xtnData
;
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_supported_groups_xtn
;
}
}
return
extension_length
;
}
PRInt32
ssl3_SendSupportedPointFormatsXtn
(
sslSocket
*
ss
PRBool
append
PRUint32
maxBytes
)
{
static
const
PRUint8
ecPtFmt
[
6
]
=
{
0
11
0
2
1
0
}
;
if
(
!
ss
|
|
!
ssl_IsECCEnabled
(
ss
)
|
|
ss
-
>
vrange
.
min
>
=
SSL_LIBRARY_VERSION_TLS_1_3
|
|
(
ss
-
>
sec
.
isServer
&
&
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
)
return
0
;
if
(
append
&
&
maxBytes
>
=
(
sizeof
ecPtFmt
)
)
{
SECStatus
rv
=
ssl3_AppendHandshake
(
ss
ecPtFmt
(
sizeof
ecPtFmt
)
)
;
if
(
rv
!
=
SECSuccess
)
return
-
1
;
if
(
!
ss
-
>
sec
.
isServer
)
{
TLSExtensionData
*
xtnData
=
&
ss
-
>
xtnData
;
xtnData
-
>
advertised
[
xtnData
-
>
numAdvertised
+
+
]
=
ssl_ec_point_formats_xtn
;
}
}
return
sizeof
(
ecPtFmt
)
;
}
SECStatus
ssl3_HandleSupportedPointFormatsXtn
(
sslSocket
*
ss
PRUint16
ex_type
SECItem
*
data
)
{
int
i
;
if
(
data
-
>
len
<
2
|
|
data
-
>
len
>
255
|
|
!
data
-
>
data
|
|
data
-
>
len
!
=
(
unsigned
int
)
data
-
>
data
[
0
]
+
1
)
{
return
ssl3_DecodeError
(
ss
)
;
}
for
(
i
=
data
-
>
len
;
-
-
i
>
0
;
)
{
if
(
data
-
>
data
[
i
]
=
=
0
)
{
SECStatus
rv
;
rv
=
ssl3_RegisterServerHelloExtensionSender
(
ss
ex_type
&
ssl3_SendSupportedPointFormatsXtn
)
;
return
rv
;
}
}
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HANDSHAKE
)
;
return
SECFailure
;
}
static
SECStatus
ssl_UpdateSupportedGroups
(
sslSocket
*
ss
SECItem
*
data
)
{
PRInt32
list_len
;
PRUint32
peerGroups
=
0
;
if
(
!
data
-
>
data
|
|
data
-
>
len
<
4
)
{
(
void
)
ssl3_DecodeError
(
ss
)
;
return
SECFailure
;
}
list_len
=
ssl3_ConsumeHandshakeNumber
(
ss
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
list_len
<
0
|
|
data
-
>
len
!
=
list_len
|
|
(
data
-
>
len
%
2
)
!
=
0
)
{
(
void
)
ssl3_DecodeError
(
ss
)
;
return
SECFailure
;
}
while
(
data
-
>
len
)
{
const
namedGroupDef
*
group
;
PRInt32
curve_name
=
ssl3_ConsumeHandshakeNumber
(
ss
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
curve_name
<
0
)
{
return
SECFailure
;
}
group
=
ssl_LookupNamedGroup
(
curve_name
)
;
if
(
group
)
{
peerGroups
|
=
(
1U
<
<
group
-
>
index
)
;
}
if
(
(
curve_name
&
0xff00
)
=
=
0x0100
)
{
ss
-
>
ssl3
.
hs
.
peerSupportsFfdheGroups
=
PR_TRUE
;
}
}
if
(
!
ss
-
>
opt
.
requireDHENamedGroups
&
&
!
ss
-
>
ssl3
.
hs
.
peerSupportsFfdheGroups
)
{
unsigned
int
i
;
for
(
i
=
0
;
i
<
ssl_named_group_count
;
+
+
i
)
{
if
(
ssl_named_groups
[
i
]
.
type
=
=
group_type_ff
)
{
peerGroups
|
=
(
1U
<
<
ssl_named_groups
[
i
]
.
index
)
;
}
}
}
ss
-
>
namedGroups
&
=
peerGroups
;
return
SECSuccess
;
}
SECStatus
ssl_HandleSupportedGroupsXtn
(
sslSocket
*
ss
PRUint16
ex_type
SECItem
*
data
)
{
SECStatus
rv
;
rv
=
ssl_UpdateSupportedGroups
(
ss
data
)
;
if
(
rv
!
=
SECSuccess
)
return
SECFailure
;
if
(
ss
-
>
sec
.
isServer
&
&
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
rv
=
ssl3_RegisterServerHelloExtensionSender
(
ss
ex_type
&
ssl_SendSupportedGroupsXtn
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
return
SECSuccess
;
}
