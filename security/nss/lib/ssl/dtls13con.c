#
include
"
ssl
.
h
"
#
include
"
sslimpl
.
h
"
#
include
"
sslproto
.
h
"
#
include
"
keyhi
.
h
"
#
include
"
pk11func
.
h
"
SECStatus
dtls13_InsertCipherTextHeader
(
const
sslSocket
*
ss
const
ssl3CipherSpec
*
cwSpec
sslBuffer
*
wrBuf
PRBool
*
needsLength
)
{
if
(
ss
-
>
opt
.
enableDtlsShortHeader
&
&
cwSpec
-
>
epoch
>
TrafficKeyHandshake
)
{
*
needsLength
=
PR_FALSE
;
PRUint8
ct
=
0x20
|
(
(
uint64_t
)
cwSpec
-
>
epoch
&
0x3
)
;
if
(
sslBuffer_AppendNumber
(
wrBuf
ct
1
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
PRUint8
seq
=
cwSpec
-
>
nextSeqNum
&
0xff
;
return
sslBuffer_AppendNumber
(
wrBuf
seq
1
)
;
}
PRUint8
ct
=
0x2c
|
(
(
PRUint8
)
cwSpec
-
>
epoch
&
0x3
)
;
if
(
sslBuffer_AppendNumber
(
wrBuf
ct
1
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
sslBuffer_AppendNumber
(
wrBuf
(
cwSpec
-
>
nextSeqNum
&
0xffff
)
2
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
needsLength
=
PR_TRUE
;
return
SECSuccess
;
}
typedef
struct
DTLSHandshakeRecordEntryStr
{
PRCList
link
;
PRUint16
messageSeq
;
PRUint32
offset
;
PRUint32
length
;
sslSequenceNumber
record
;
PRBool
acked
;
}
DTLSHandshakeRecordEntry
;
static
inline
sslSequenceNumber
dtls_CombineSequenceNumber
(
DTLSEpoch
epoch
sslSequenceNumber
seqNum
)
{
PORT_Assert
(
seqNum
<
=
RECORD_SEQ_MAX
)
;
return
(
(
sslSequenceNumber
)
epoch
<
<
48
)
|
seqNum
;
}
SECStatus
dtls13_RememberFragment
(
sslSocket
*
ss
PRCList
*
list
PRUint32
sequence
PRUint32
offset
PRUint32
length
DTLSEpoch
epoch
sslSequenceNumber
record
)
{
DTLSHandshakeRecordEntry
*
entry
;
PORT_Assert
(
IS_DTLS
(
ss
)
)
;
PORT_Assert
(
length
|
|
!
offset
)
;
if
(
!
tls13_MaybeTls13
(
ss
)
)
{
return
SECSuccess
;
}
SSL_TRC
(
20
(
"
%
d
:
SSL3
[
%
d
]
:
%
s
remembering
%
s
record
=
%
llx
msg
=
%
d
offset
=
%
d
"
SSL_GETPID
(
)
ss
-
>
fd
SSL_ROLE
(
ss
)
list
=
=
&
ss
-
>
ssl3
.
hs
.
dtlsSentHandshake
?
"
sent
"
:
"
received
"
dtls_CombineSequenceNumber
(
epoch
record
)
sequence
offset
)
)
;
entry
=
PORT_ZAlloc
(
sizeof
(
DTLSHandshakeRecordEntry
)
)
;
if
(
!
entry
)
{
return
SECFailure
;
}
entry
-
>
messageSeq
=
sequence
;
entry
-
>
offset
=
offset
;
entry
-
>
length
=
length
;
entry
-
>
record
=
dtls_CombineSequenceNumber
(
epoch
record
)
;
entry
-
>
acked
=
PR_FALSE
;
PR_APPEND_LINK
(
&
entry
-
>
link
list
)
;
return
SECSuccess
;
}
SECStatus
dtls13_SendAck
(
sslSocket
*
ss
)
{
sslBuffer
buf
=
SSL_BUFFER_EMPTY
;
SECStatus
rv
=
SECSuccess
;
PRCList
*
cursor
;
PRInt32
sent
;
unsigned
int
offset
;
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
Sending
ACK
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_Skip
(
&
buf
2
&
offset
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
for
(
cursor
=
PR_LIST_HEAD
(
&
ss
-
>
ssl3
.
hs
.
dtlsRcvdHandshake
)
;
cursor
!
=
&
ss
-
>
ssl3
.
hs
.
dtlsRcvdHandshake
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
DTLSHandshakeRecordEntry
*
entry
=
(
DTLSHandshakeRecordEntry
*
)
cursor
;
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
ACK
for
record
=
%
llx
"
SSL_GETPID
(
)
ss
-
>
fd
entry
-
>
record
)
)
;
rv
=
sslBuffer_AppendNumber
(
&
buf
entry
-
>
record
8
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
}
rv
=
sslBuffer_InsertLength
(
&
buf
offset
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
ssl_GetXmitBufLock
(
ss
)
;
sent
=
ssl3_SendRecord
(
ss
NULL
ssl_ct_ack
buf
.
buf
buf
.
len
0
)
;
ssl_ReleaseXmitBufLock
(
ss
)
;
if
(
sent
!
=
buf
.
len
)
{
rv
=
SECFailure
;
if
(
sent
!
=
-
1
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
}
}
loser
:
sslBuffer_Clear
(
&
buf
)
;
return
rv
;
}
void
dtls13_SendAckCb
(
sslSocket
*
ss
)
{
if
(
!
IS_DTLS
(
ss
)
)
{
return
;
}
(
void
)
dtls13_SendAck
(
ss
)
;
}
static
PRBool
dtls_IsEmptyMessageAcknowledged
(
sslSocket
*
ss
PRUint16
msgSeq
PRUint32
offset
)
{
PRCList
*
cursor
;
for
(
cursor
=
PR_LIST_HEAD
(
&
ss
-
>
ssl3
.
hs
.
dtlsSentHandshake
)
;
cursor
!
=
&
ss
-
>
ssl3
.
hs
.
dtlsSentHandshake
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
DTLSHandshakeRecordEntry
*
entry
=
(
DTLSHandshakeRecordEntry
*
)
cursor
;
if
(
!
entry
-
>
acked
|
|
msgSeq
!
=
entry
-
>
messageSeq
)
{
continue
;
}
if
(
entry
-
>
length
=
=
0
)
{
PORT_Assert
(
!
entry
-
>
offset
)
;
return
PR_TRUE
;
}
}
return
PR_FALSE
;
}
static
PRBool
dtls_MoveUnackedStartForward
(
DTLSHandshakeRecordEntry
*
entry
PRUint32
*
start
)
{
if
(
*
start
<
entry
-
>
offset
)
{
return
PR_FALSE
;
}
if
(
*
start
>
=
entry
-
>
offset
+
entry
-
>
length
)
{
return
PR_FALSE
;
}
*
start
=
entry
-
>
offset
+
entry
-
>
length
;
return
PR_TRUE
;
}
static
PRBool
dtls_MoveUnackedEndBackward
(
DTLSHandshakeRecordEntry
*
entry
PRUint32
*
end
)
{
if
(
*
end
>
entry
-
>
offset
+
entry
-
>
length
)
{
return
PR_FALSE
;
}
if
(
*
end
<
=
entry
-
>
offset
)
{
return
PR_FALSE
;
}
*
end
=
entry
-
>
offset
;
return
PR_TRUE
;
}
PRBool
dtls_NextUnackedRange
(
sslSocket
*
ss
PRUint16
msgSeq
PRUint32
offset
PRUint32
len
PRUint32
*
startOut
PRUint32
*
endOut
)
{
PRCList
*
cur_p
;
PRBool
done
=
PR_FALSE
;
DTLSHandshakeRecordEntry
*
entry
;
PRUint32
start
;
PRUint32
end
;
PORT_Assert
(
IS_DTLS
(
ss
)
)
;
*
startOut
=
offset
;
*
endOut
=
len
;
if
(
!
tls13_MaybeTls13
(
ss
)
)
{
return
PR_TRUE
;
}
if
(
!
len
)
{
PORT_Assert
(
!
offset
)
;
return
!
dtls_IsEmptyMessageAcknowledged
(
ss
msgSeq
offset
)
;
}
start
=
offset
;
end
=
len
;
while
(
!
done
)
{
done
=
PR_TRUE
;
for
(
cur_p
=
PR_LIST_HEAD
(
&
ss
-
>
ssl3
.
hs
.
dtlsSentHandshake
)
;
cur_p
!
=
&
ss
-
>
ssl3
.
hs
.
dtlsSentHandshake
;
cur_p
=
PR_NEXT_LINK
(
cur_p
)
)
{
entry
=
(
DTLSHandshakeRecordEntry
*
)
cur_p
;
if
(
!
entry
-
>
acked
|
|
msgSeq
!
=
entry
-
>
messageSeq
)
{
continue
;
}
if
(
dtls_MoveUnackedStartForward
(
entry
&
start
)
|
|
dtls_MoveUnackedEndBackward
(
entry
&
end
)
)
{
if
(
start
>
=
end
)
{
return
PR_FALSE
;
}
done
=
PR_FALSE
;
break
;
}
}
}
PORT_Assert
(
start
<
end
)
;
*
startOut
=
start
;
*
endOut
=
end
;
return
PR_TRUE
;
}
SECStatus
dtls13_SetupAcks
(
sslSocket
*
ss
)
{
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
if
(
ss
-
>
ssl3
.
hs
.
endOfFlight
)
{
dtls_CancelTimer
(
ss
ss
-
>
ssl3
.
hs
.
ackTimer
)
;
if
(
ss
-
>
ssl3
.
hs
.
ws
=
=
idle_handshake
&
&
ss
-
>
sec
.
isServer
)
{
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
dtls_HandleHandshake
sending
ACK
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
return
dtls13_SendAck
(
ss
)
;
}
return
SECSuccess
;
}
if
(
!
ss
-
>
ssl3
.
hs
.
ackTimer
-
>
cb
)
{
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
dtls_HandleHandshake
arming
ack
timer
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
return
dtls_StartTimer
(
ss
ss
-
>
ssl3
.
hs
.
ackTimer
DTLS_RETRANSMIT_INITIAL_MS
/
4
dtls13_SendAckCb
)
;
}
return
SECSuccess
;
}
SECStatus
dtls13_HandleOutOfEpochRecord
(
sslSocket
*
ss
const
ssl3CipherSpec
*
spec
SSLContentType
rType
sslBuffer
*
databuf
)
{
SECStatus
rv
;
sslBuffer
buf
=
*
databuf
;
databuf
-
>
len
=
0
;
PORT_Assert
(
IS_DTLS
(
ss
)
)
;
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
if
(
!
IS_DTLS
(
ss
)
|
|
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
)
{
tls13_FatalError
(
ss
SEC_ERROR_LIBRARY_FAILURE
internal_error
)
;
return
SECFailure
;
}
SSL_TRC
(
10
(
"
%
d
:
DTLS13
[
%
d
]
:
handle
out
of
epoch
record
:
type
=
%
d
"
SSL_GETPID
(
)
ss
-
>
fd
rType
)
)
;
if
(
rType
=
=
ssl_ct_ack
)
{
ssl_GetSSL3HandshakeLock
(
ss
)
;
rv
=
dtls13_HandleAck
(
ss
&
buf
)
;
ssl_ReleaseSSL3HandshakeLock
(
ss
)
;
PORT_Assert
(
databuf
-
>
len
=
=
0
)
;
return
rv
;
}
switch
(
spec
-
>
epoch
)
{
case
TrafficKeyClearText
:
return
SECSuccess
;
case
TrafficKeyHandshake
:
if
(
rType
=
=
ssl_ct_handshake
)
{
if
(
(
ss
-
>
sec
.
isServer
)
&
&
(
ss
-
>
ssl3
.
hs
.
ws
=
=
idle_handshake
)
)
{
PORT_Assert
(
dtls_TimerActive
(
ss
ss
-
>
ssl3
.
hs
.
hdTimer
)
)
;
return
dtls13_SendAck
(
ss
)
;
}
return
SECSuccess
;
}
break
;
default
:
break
;
}
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
unexpected
out
of
epoch
record
type
%
d
"
SSL_GETPID
(
)
ss
-
>
fd
rType
)
)
;
(
void
)
SSL3_SendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_UNKNOWN_RECORD_TYPE
)
;
return
SECFailure
;
}
SECStatus
dtls13_HandleAck
(
sslSocket
*
ss
sslBuffer
*
databuf
)
{
PRUint8
*
b
=
databuf
-
>
buf
;
PRUint32
l
=
databuf
-
>
len
;
unsigned
int
length
;
SECStatus
rv
;
databuf
-
>
len
=
0
;
PORT_Assert
(
IS_DTLS
(
ss
)
)
;
if
(
!
tls13_MaybeTls13
(
ss
)
)
{
tls13_FatalError
(
ss
SSL_ERROR_RX_UNKNOWN_RECORD_TYPE
illegal_parameter
)
;
return
SECFailure
;
}
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
Handling
ACK
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ConsumeHandshakeNumber
(
ss
&
length
2
&
b
&
l
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
length
!
=
l
)
{
tls13_FatalError
(
ss
SSL_ERROR_RX_MALFORMED_DTLS_ACK
decode_error
)
;
return
SECFailure
;
}
while
(
l
>
0
)
{
PRUint64
seq
;
PRCList
*
cursor
;
rv
=
ssl3_ConsumeHandshakeNumber64
(
ss
&
seq
8
&
b
&
l
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
for
(
cursor
=
PR_LIST_HEAD
(
&
ss
-
>
ssl3
.
hs
.
dtlsSentHandshake
)
;
cursor
!
=
&
ss
-
>
ssl3
.
hs
.
dtlsSentHandshake
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
DTLSHandshakeRecordEntry
*
entry
=
(
DTLSHandshakeRecordEntry
*
)
cursor
;
if
(
entry
-
>
record
=
=
seq
)
{
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
Marking
record
=
%
llx
message
%
d
offset
%
d
length
=
%
d
as
ACKed
"
SSL_GETPID
(
)
ss
-
>
fd
seq
entry
-
>
messageSeq
entry
-
>
offset
entry
-
>
length
)
)
;
entry
-
>
acked
=
PR_TRUE
;
}
}
}
rv
=
dtls_TransmitMessageFlight
(
ss
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
ss
-
>
ssl3
.
hs
.
rtTimer
-
>
cb
)
{
(
void
)
dtls_RestartTimer
(
ss
ss
-
>
ssl3
.
hs
.
rtTimer
)
;
}
if
(
PR_CLIST_IS_EMPTY
(
&
ss
-
>
ssl3
.
hs
.
lastMessageFlight
)
)
{
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
No
more
unacked
handshake
messages
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
dtls_CancelTimer
(
ss
ss
-
>
ssl3
.
hs
.
rtTimer
)
;
ssl_ClearPRCList
(
&
ss
-
>
ssl3
.
hs
.
dtlsSentHandshake
NULL
)
;
if
(
!
ss
-
>
sec
.
isServer
&
&
(
ss
-
>
ssl3
.
hs
.
ws
=
=
idle_handshake
)
)
{
ssl_CipherSpecReleaseByEpoch
(
ss
ssl_secret_read
TrafficKeyHandshake
)
;
}
}
return
SECSuccess
;
}
void
dtls13_HolddownTimerCb
(
sslSocket
*
ss
)
{
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
holddown
timer
fired
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
ssl_CipherSpecReleaseByEpoch
(
ss
ssl_secret_read
TrafficKeyHandshake
)
;
ssl_ClearPRCList
(
&
ss
-
>
ssl3
.
hs
.
dtlsRcvdHandshake
NULL
)
;
}
SECStatus
dtls13_MaskSequenceNumber
(
sslSocket
*
ss
ssl3CipherSpec
*
spec
PRUint8
*
hdr
PRUint8
*
cipherText
PRUint32
cipherTextLen
)
{
PORT_Assert
(
IS_DTLS
(
ss
)
)
;
if
(
spec
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
if
(
spec
-
>
maskContext
)
{
PRUint8
mask
[
2
]
;
SECStatus
rv
=
ssl_CreateMaskInner
(
spec
-
>
maskContext
cipherText
cipherTextLen
mask
sizeof
(
mask
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
hdr
[
1
]
^
=
mask
[
0
]
;
if
(
hdr
[
0
]
&
0x08
)
{
hdr
[
2
]
^
=
mask
[
1
]
;
}
}
return
SECSuccess
;
}
CK_MECHANISM_TYPE
tls13_SequenceNumberEncryptionMechanism
(
SSLCipherAlgorithm
bulkAlgorithm
)
{
switch
(
bulkAlgorithm
)
{
case
ssl_calg_aes_gcm
:
return
CKM_AES_ECB
;
case
ssl_calg_chacha20
:
return
CKM_NSS_CHACHA20_CTR
;
default
:
PORT_Assert
(
PR_FALSE
)
;
}
return
CKM_INVALID_MECHANISM
;
}
