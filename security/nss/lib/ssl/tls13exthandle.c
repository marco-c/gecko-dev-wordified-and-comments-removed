#
include
"
nssrenam
.
h
"
#
include
"
nss
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslproto
.
h
"
#
include
"
sslimpl
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
ssl3ext
.
h
"
#
include
"
ssl3exthandle
.
h
"
#
include
"
tls13esni
.
h
"
#
include
"
tls13exthandle
.
h
"
#
include
"
tls13psk
.
h
"
#
include
"
tls13subcerts
.
h
"
SECStatus
tls13_ServerSendStatusRequestXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
const
sslServerCert
*
serverCert
=
ss
-
>
sec
.
serverCert
;
const
SECItem
*
item
;
SECStatus
rv
;
if
(
!
serverCert
-
>
certStatusArray
|
|
!
serverCert
-
>
certStatusArray
-
>
len
)
{
return
SECSuccess
;
}
item
=
&
serverCert
-
>
certStatusArray
-
>
items
[
0
]
;
rv
=
sslBuffer_AppendNumber
(
buf
1
1
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslBuffer_AppendVariable
(
buf
item
-
>
data
item
-
>
len
3
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
PRUint32
tls13_SizeOfKeyShareEntry
(
const
SECKEYPublicKey
*
pubKey
)
{
switch
(
pubKey
-
>
keyType
)
{
case
ecKey
:
return
2
+
2
+
pubKey
-
>
u
.
ec
.
publicValue
.
len
;
case
dhKey
:
return
2
+
2
+
pubKey
-
>
u
.
dh
.
prime
.
len
;
default
:
PORT_Assert
(
0
)
;
}
return
0
;
}
SECStatus
tls13_EncodeKeyShareEntry
(
sslBuffer
*
buf
SSLNamedGroup
group
SECKEYPublicKey
*
pubKey
)
{
SECStatus
rv
;
unsigned
int
size
=
tls13_SizeOfKeyShareEntry
(
pubKey
)
;
rv
=
sslBuffer_AppendNumber
(
buf
group
2
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
sslBuffer_AppendNumber
(
buf
size
-
4
2
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
switch
(
pubKey
-
>
keyType
)
{
case
ecKey
:
rv
=
sslBuffer_Append
(
buf
pubKey
-
>
u
.
ec
.
publicValue
.
data
pubKey
-
>
u
.
ec
.
publicValue
.
len
)
;
break
;
case
dhKey
:
rv
=
ssl_AppendPaddedDHKeyShare
(
buf
pubKey
PR_FALSE
)
;
break
;
default
:
PORT_Assert
(
0
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
break
;
}
return
rv
;
}
SECStatus
tls13_ClientSendKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
PRCList
*
cursor
;
unsigned
int
extStart
;
unsigned
int
lengthOffset
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
send
client
key
share
xtn
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
extStart
=
SSL_BUFFER_LEN
(
buf
)
;
rv
=
sslBuffer_Skip
(
buf
2
&
lengthOffset
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
;
cursor
!
=
&
ss
-
>
ephemeralKeyPairs
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
sslEphemeralKeyPair
*
keyPair
=
(
sslEphemeralKeyPair
*
)
cursor
;
rv
=
tls13_EncodeKeyShareEntry
(
buf
keyPair
-
>
group
-
>
name
keyPair
-
>
keys
-
>
pubKey
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
rv
=
sslBuffer_InsertLength
(
buf
lengthOffset
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
SECITEM_MakeItem
(
NULL
&
xtnData
-
>
keyShareExtension
SSL_BUFFER_BASE
(
buf
)
+
extStart
SSL_BUFFER_LEN
(
buf
)
-
extStart
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_DecodeKeyShareEntry
(
sslReader
*
rdr
TLS13KeyShareEntry
*
*
ksp
)
{
SECStatus
rv
;
PRUint64
group
;
const
sslNamedGroupDef
*
groupDef
;
TLS13KeyShareEntry
*
ks
=
NULL
;
sslReadBuffer
share
;
rv
=
sslRead_ReadNumber
(
rdr
2
&
group
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
groupDef
=
ssl_LookupNamedGroup
(
group
)
;
rv
=
sslRead_ReadVariable
(
rdr
2
&
share
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
!
groupDef
)
{
return
SECSuccess
;
}
ks
=
PORT_ZNew
(
TLS13KeyShareEntry
)
;
if
(
!
ks
)
{
goto
loser
;
}
ks
-
>
group
=
groupDef
;
rv
=
SECITEM_MakeItem
(
NULL
&
ks
-
>
key_exchange
share
.
buf
share
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
*
ksp
=
ks
;
return
SECSuccess
;
loser
:
tls13_DestroyKeyShareEntry
(
ks
)
;
return
SECFailure
;
}
SECStatus
tls13_ClientHandleKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PORT_Assert
(
PR_CLIST_IS_EMPTY
(
&
xtnData
-
>
remoteKeyShares
)
)
;
TLS13KeyShareEntry
*
ks
=
NULL
;
PORT_Assert
(
!
ss
-
>
sec
.
isServer
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
PORT_SetError
(
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
)
;
return
SECFailure
;
}
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
key_share
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
sslReader
rdr
=
SSL_READER
(
data
-
>
data
data
-
>
len
)
;
rv
=
tls13_DecodeKeyShareEntry
(
&
rdr
&
ks
)
;
if
(
(
rv
!
=
SECSuccess
)
|
|
!
ks
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_KEY_SHARE
)
;
return
SECFailure
;
}
if
(
SSL_READER_REMAINING
(
&
rdr
)
)
{
tls13_DestroyKeyShareEntry
(
ks
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_KEY_SHARE
)
;
return
SECFailure
;
}
PR_APPEND_LINK
(
&
ks
-
>
link
&
xtnData
-
>
remoteKeyShares
)
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleKeyShareXtnHrr
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PRUint32
tmp
;
const
sslNamedGroupDef
*
group
;
PORT_Assert
(
!
ss
-
>
sec
.
isServer
)
;
PORT_Assert
(
ss
-
>
vrange
.
max
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
key_share
extension
in
HRR
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
tmp
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HELLO_RETRY_REQUEST
)
;
return
SECFailure
;
}
group
=
ssl_LookupNamedGroup
(
(
SSLNamedGroup
)
tmp
)
;
if
(
!
ssl_NamedGroupEnabled
(
ss
group
)
|
|
ssl_HaveEphemeralKeyPair
(
ss
group
)
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HELLO_RETRY_REQUEST
)
;
return
SECFailure
;
}
ssl_FreeEphemeralKeyPairs
(
CONST_CAST
(
sslSocket
ss
)
)
;
rv
=
tls13_AddKeyShare
(
CONST_CAST
(
sslSocket
ss
)
group
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
internal_error
)
;
PORT_SetError
(
SEC_ERROR_KEYGEN_FAIL
)
;
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
tls13_ServerHandleKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PRUint32
length
;
PORT_Assert
(
ss
-
>
sec
.
isServer
)
;
PORT_Assert
(
PR_CLIST_IS_EMPTY
(
&
xtnData
-
>
remoteKeyShares
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
key_share
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
length
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
if
(
length
!
=
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_KEY_SHARE
)
;
goto
loser
;
}
sslReader
rdr
=
SSL_READER
(
data
-
>
data
data
-
>
len
)
;
while
(
SSL_READER_REMAINING
(
&
rdr
)
)
{
TLS13KeyShareEntry
*
ks
=
NULL
;
rv
=
tls13_DecodeKeyShareEntry
(
&
rdr
&
ks
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_KEY_SHARE
)
;
goto
loser
;
}
if
(
ks
)
{
PR_APPEND_LINK
(
&
ks
-
>
link
&
xtnData
-
>
remoteKeyShares
)
;
}
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_key_share_xtn
;
return
SECSuccess
;
loser
:
tls13_DestroyKeyShares
(
&
xtnData
-
>
remoteKeyShares
)
;
return
SECFailure
;
}
SECStatus
tls13_ServerSendKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
sslEphemeralKeyPair
*
keyPair
;
PORT_Assert
(
!
PR_CLIST_IS_EMPTY
(
&
ss
-
>
ephemeralKeyPairs
)
)
;
PORT_Assert
(
PR_PREV_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
=
=
PR_NEXT_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
)
;
keyPair
=
(
sslEphemeralKeyPair
*
)
PR_NEXT_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
;
rv
=
tls13_EncodeKeyShareEntry
(
buf
keyPair
-
>
group
-
>
name
keyPair
-
>
keys
-
>
pubKey
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendPreSharedKeyXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
const
static
PRUint8
binder
[
TLS13_MAX_FINISHED_SIZE
]
=
{
0
}
;
unsigned
int
binderLen
;
unsigned
int
identityLen
=
0
;
const
PRUint8
*
identity
=
NULL
;
PRTime
age
;
SECStatus
rv
;
if
(
PR_CLIST_IS_EMPTY
(
&
ss
-
>
ssl3
.
hs
.
psks
)
|
|
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
sslPsk
*
psk
=
(
sslPsk
*
)
PR_LIST_HEAD
(
&
ss
-
>
ssl3
.
hs
.
psks
)
;
if
(
psk
-
>
type
=
=
ssl_psk_resume
&
&
!
ss
-
>
statelessResume
)
{
return
SECSuccess
;
}
PORT_Assert
(
buf
-
>
len
>
=
4
)
;
xtnData
-
>
lastXtnOffset
=
buf
-
>
len
-
4
;
PORT_Assert
(
psk
-
>
type
=
=
ssl_psk_resume
|
|
psk
-
>
type
=
=
ssl_psk_external
)
;
binderLen
=
tls13_GetHashSizeForHash
(
psk
-
>
hash
)
;
if
(
psk
-
>
type
=
=
ssl_psk_resume
)
{
NewSessionTicket
*
session_ticket
=
&
ss
-
>
sec
.
ci
.
sid
-
>
u
.
ssl3
.
locked
.
sessionTicket
;
identityLen
=
session_ticket
-
>
ticket
.
len
;
identity
=
session_ticket
-
>
ticket
.
data
;
age
=
ssl_Time
(
ss
)
-
session_ticket
-
>
received_timestamp
;
age
/
=
PR_USEC_PER_MSEC
;
age
+
=
session_ticket
-
>
ticket_age_add
;
PRINT_BUF
(
50
(
ss
"
Sending
Resumption
PSK
with
identity
"
identity
identityLen
)
)
;
}
else
if
(
psk
-
>
type
=
=
ssl_psk_external
)
{
identityLen
=
psk
-
>
label
.
len
;
identity
=
psk
-
>
label
.
data
;
age
=
0
;
PRINT_BUF
(
50
(
ss
"
Sending
External
PSK
with
label
"
identity
identityLen
)
)
;
}
else
{
PORT_Assert
(
0
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
rv
=
sslBuffer_AppendNumber
(
buf
2
+
identityLen
+
4
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
sslBuffer_AppendVariable
(
buf
identity
identityLen
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
sslBuffer_AppendNumber
(
buf
age
4
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
sslBuffer_AppendNumber
(
buf
binderLen
+
1
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
sslBuffer_AppendVariable
(
buf
binder
binderLen
1
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
psk
-
>
type
=
=
ssl_psk_resume
)
{
xtnData
-
>
sentSessionTicketInClientHello
=
PR_TRUE
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
loser
:
xtnData
-
>
ticketTimestampVerified
=
PR_FALSE
;
return
SECFailure
;
}
SECStatus
tls13_ServerHandlePreSharedKeyXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECItem
inner
;
SECStatus
rv
;
unsigned
int
numIdentities
=
0
;
unsigned
int
numBinders
=
0
;
SECItem
*
appToken
;
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
pre_shared_key
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
if
(
!
ss
-
>
ssl3
.
hs
.
helloRetry
)
{
appToken
=
&
xtnData
-
>
applicationToken
;
}
else
{
appToken
=
NULL
;
}
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
inner
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
while
(
inner
.
len
)
{
SECItem
label
;
PRUint32
obfuscatedAge
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
label
2
&
inner
.
data
&
inner
.
len
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
if
(
!
label
.
len
)
{
goto
alert_loser
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
obfuscatedAge
4
&
inner
.
data
&
inner
.
len
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
if
(
!
numIdentities
)
{
PORT_Assert
(
!
xtnData
-
>
selectedPsk
)
;
for
(
PRCList
*
cur_p
=
PR_LIST_HEAD
(
&
ss
-
>
ssl3
.
hs
.
psks
)
;
cur_p
!
=
&
ss
-
>
ssl3
.
hs
.
psks
;
cur_p
=
PR_NEXT_LINK
(
cur_p
)
)
{
sslPsk
*
psk
=
(
sslPsk
*
)
cur_p
;
if
(
psk
-
>
type
!
=
ssl_psk_external
|
|
SECITEM_CompareItem
(
&
psk
-
>
label
&
label
)
!
=
SECEqual
)
{
continue
;
}
PRINT_BUF
(
50
(
ss
"
Using
External
PSK
with
label
"
psk
-
>
label
.
data
psk
-
>
label
.
len
)
)
;
xtnData
-
>
selectedPsk
=
psk
;
}
if
(
!
xtnData
-
>
selectedPsk
)
{
PRINT_BUF
(
50
(
ss
"
Handling
PreSharedKey
value
"
label
.
data
label
.
len
)
)
;
rv
=
ssl3_ProcessSessionTicketCommon
(
CONST_CAST
(
sslSocket
ss
)
&
label
appToken
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
ss
-
>
sec
.
ci
.
sid
)
{
xtnData
-
>
ticketAge
+
=
obfuscatedAge
;
}
}
}
+
+
numIdentities
;
}
xtnData
-
>
pskBindersLen
=
data
-
>
len
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
inner
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
return
SECFailure
;
if
(
data
-
>
len
)
{
goto
alert_loser
;
}
while
(
inner
.
len
)
{
SECItem
binder
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
binder
1
&
inner
.
data
&
inner
.
len
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
if
(
binder
.
len
<
32
)
{
goto
alert_loser
;
}
if
(
!
numBinders
)
{
xtnData
-
>
pskBinder
=
binder
;
}
+
+
numBinders
;
}
if
(
numBinders
!
=
numIdentities
)
goto
alert_loser
;
if
(
ss
-
>
statelessResume
)
{
PORT_Assert
(
!
ss
-
>
xtnData
.
selectedPsk
)
;
}
else
if
(
!
xtnData
-
>
selectedPsk
)
{
return
SECSuccess
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_pre_shared_key_xtn
;
return
SECSuccess
;
alert_loser
:
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_MALFORMED_PRE_SHARED_KEY
)
;
return
SECFailure
;
}
SECStatus
tls13_ServerSendPreSharedKeyXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
rv
=
sslBuffer_AppendNumber
(
buf
0
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandlePreSharedKeyXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
PRUint32
index
;
SECStatus
rv
;
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
pre_shared_key
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
PORT_SetError
(
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
index
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
return
SECFailure
;
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_PRE_SHARED_KEY
)
;
return
SECFailure
;
}
if
(
index
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_MALFORMED_PRE_SHARED_KEY
)
;
return
SECFailure
;
}
PORT_Assert
(
!
PR_CLIST_IS_EMPTY
(
&
ss
-
>
ssl3
.
hs
.
psks
)
)
;
sslPsk
*
candidate
=
(
sslPsk
*
)
PR_LIST_HEAD
(
&
ss
-
>
ssl3
.
hs
.
psks
)
;
if
(
candidate
-
>
hash
!
=
tls13_GetHashForCipherSuite
(
ss
-
>
ssl3
.
hs
.
cipher_suite
)
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_pre_shared_key_xtn
;
xtnData
-
>
selectedPsk
=
candidate
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendEarlyDataXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
if
(
!
tls13_ClientAllow0Rtt
(
ss
ss
-
>
sec
.
ci
.
sid
)
)
{
return
SECSuccess
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerHandleEarlyDataXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
early_data
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
if
(
ss
-
>
ssl3
.
hs
.
helloRetry
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
unsupported_extension
)
;
PORT_SetError
(
SSL_ERROR_RX_UNEXPECTED_EXTENSION
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_EARLY_DATA
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_early_data_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleEarlyDataXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
early_data
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
PORT_SetError
(
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_EARLY_DATA
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_early_data_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleTicketEarlyDataXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
PRUint32
utmp
;
SECStatus
rv
;
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
ticket
early_data
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
PORT_SetError
(
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshake
(
ss
&
utmp
sizeof
(
utmp
)
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_NEW_SESSION_TICKET
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_NEW_SESSION_TICKET
)
;
return
SECFailure
;
}
xtnData
-
>
max_early_data_size
=
PR_ntohl
(
utmp
)
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendSupportedVersionsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
PRUint16
version
;
unsigned
int
lengthOffset
;
SECStatus
rv
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
client
send
supported_versions
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_Skip
(
buf
1
&
lengthOffset
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
for
(
version
=
ss
-
>
vrange
.
max
;
version
>
=
ss
-
>
vrange
.
min
;
-
-
version
)
{
PRUint16
wire
=
tls13_EncodeVersion
(
version
ss
-
>
protocolVariant
)
;
rv
=
sslBuffer_AppendNumber
(
buf
wire
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
ss
-
>
opt
.
enableDtls13VersionCompat
&
&
ss
-
>
protocolVariant
=
=
ssl_variant_datagram
)
{
switch
(
version
)
{
case
SSL_LIBRARY_VERSION_TLS_1_2
:
case
SSL_LIBRARY_VERSION_TLS_1_1
:
rv
=
sslBuffer_AppendNumber
(
buf
(
PRUint16
)
version
2
)
;
break
;
default
:
continue
;
}
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
}
rv
=
sslBuffer_InsertLength
(
buf
lengthOffset
1
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerSendSupportedVersionsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
server
send
supported_versions
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
PRUint16
ver
=
tls13_EncodeVersion
(
SSL_LIBRARY_VERSION_TLS_1_3
ss
-
>
protocolVariant
)
;
rv
=
sslBuffer_AppendNumber
(
buf
ver
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleHrrCookie
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
cookie
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
PORT_Assert
(
ss
-
>
vrange
.
max
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
CONST_CAST
(
sslSocket
ss
)
-
>
ssl3
.
hs
.
cookie
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HELLO_RETRY_REQUEST
)
;
return
SECFailure
;
}
if
(
!
ss
-
>
ssl3
.
hs
.
cookie
.
len
|
|
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HELLO_RETRY_REQUEST
)
;
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
tls13_ClientSendHrrCookieXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
|
|
!
ss
-
>
ssl3
.
hs
.
cookie
.
len
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
send
cookie
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_AppendVariable
(
buf
ss
-
>
ssl3
.
hs
.
cookie
.
data
ss
-
>
ssl3
.
hs
.
cookie
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerHandleCookieXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
cookie
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
xtnData
-
>
cookie
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
xtnData
-
>
cookie
.
len
=
=
0
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_cookie_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendPostHandshakeAuthXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
if
(
!
IS_DTLS
(
ss
)
)
{
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
send
post_handshake_auth
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
*
added
=
ss
-
>
opt
.
enablePostHandshakeAuth
;
}
return
SECSuccess
;
}
SECStatus
tls13_ServerHandlePostHandshakeAuthXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
post_handshake_auth
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
if
(
!
IS_DTLS
(
ss
)
)
{
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_post_handshake_auth_xtn
;
}
return
SECSuccess
;
}
SECStatus
tls13_ClientSendPskModesXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
static
const
PRUint8
ke_modes
[
]
=
{
tls13_psk_dh_ke
}
;
SECStatus
rv
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
|
|
ss
-
>
opt
.
noCache
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
send
psk
key
exchange
modes
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_AppendVariable
(
buf
ke_modes
sizeof
(
ke_modes
)
1
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerHandlePskModesXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
PSK
key
exchange
modes
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
xtnData
-
>
psk_ke_modes
1
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
if
(
!
xtnData
-
>
psk_ke_modes
.
len
|
|
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_PSK_KEY_EXCHANGE_MODES
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_psk_key_exchange_modes_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_SendCertAuthoritiesXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
unsigned
int
calen
;
const
SECItem
*
name
;
unsigned
int
nnames
;
SECStatus
rv
;
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
rv
=
ssl_GetCertificateRequestCAs
(
ss
&
calen
&
name
&
nnames
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
!
calen
)
{
return
SECSuccess
;
}
rv
=
sslBuffer_AppendNumber
(
buf
calen
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
while
(
nnames
)
{
rv
=
sslBuffer_AppendVariable
(
buf
name
-
>
data
name
-
>
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
+
+
name
;
-
-
nnames
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleCertAuthoritiesXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PLArenaPool
*
arena
;
if
(
!
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CERT_REQUEST
)
;
return
SECFailure
;
}
arena
=
PORT_NewArena
(
DER_DEFAULT_CHUNKSIZE
)
;
if
(
!
arena
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
xtnData
-
>
certReqAuthorities
.
arena
=
arena
;
rv
=
ssl3_ParseCertificateRequestCAs
(
(
sslSocket
*
)
ss
&
data
-
>
data
&
data
-
>
len
&
xtnData
-
>
certReqAuthorities
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CERT_REQUEST
)
;
goto
loser
;
}
return
SECSuccess
;
loser
:
PORT_FreeArena
(
arena
PR_FALSE
)
;
xtnData
-
>
certReqAuthorities
.
arena
=
NULL
;
return
SECFailure
;
}
SECStatus
tls13_ServerSendHrrKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
if
(
!
xtnData
-
>
selectedGroup
)
{
return
SECSuccess
;
}
rv
=
sslBuffer_AppendNumber
(
buf
xtnData
-
>
selectedGroup
-
>
name
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerSendHrrCookieXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
PORT_Assert
(
xtnData
-
>
cookie
.
len
>
0
)
;
rv
=
sslBuffer_AppendVariable
(
buf
xtnData
-
>
cookie
.
data
xtnData
-
>
cookie
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendEsniXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
PRUint8
sniBuf
[
1024
]
;
PRUint8
hash
[
64
]
;
sslBuffer
sni
=
SSL_BUFFER
(
sniBuf
)
;
const
ssl3CipherSuiteDef
*
suiteDef
;
ssl3KeyMaterial
keyMat
;
PRUint8
outBuf
[
1024
]
;
unsigned
int
outLen
;
unsigned
int
sniStart
;
unsigned
int
sniLen
;
sslBuffer
aadInput
=
SSL_BUFFER_EMPTY
;
unsigned
int
keyShareBufStart
;
unsigned
int
keyShareBufLen
;
PORT_Memset
(
&
keyMat
0
sizeof
(
keyMat
)
)
;
if
(
!
ss
-
>
xtnData
.
esniPrivateKey
)
{
return
SECSuccess
;
}
rv
=
PK11_GenerateRandom
(
(
unsigned
char
*
)
xtnData
-
>
esniNonce
sizeof
(
xtnData
-
>
esniNonce
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslBuffer_Append
(
&
sni
xtnData
-
>
esniNonce
sizeof
(
xtnData
-
>
esniNonce
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
sniStart
=
SSL_BUFFER_LEN
(
&
sni
)
;
rv
=
ssl3_ClientFormatServerNameXtn
(
ss
ss
-
>
url
xtnData
&
sni
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
sniLen
=
SSL_BUFFER_LEN
(
&
sni
)
-
sniStart
;
if
(
ss
-
>
esniKeys
-
>
paddedLength
>
sniLen
)
{
unsigned
int
paddingRequired
=
ss
-
>
esniKeys
-
>
paddedLength
-
sniLen
;
while
(
paddingRequired
-
-
)
{
rv
=
sslBuffer_AppendNumber
(
&
sni
0
1
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
}
suiteDef
=
ssl_LookupCipherSuiteDef
(
xtnData
-
>
esniSuite
)
;
PORT_Assert
(
suiteDef
)
;
if
(
!
suiteDef
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
rv
=
sslBuffer_AppendNumber
(
buf
xtnData
-
>
esniSuite
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
keyShareBufStart
=
SSL_BUFFER_LEN
(
buf
)
;
rv
=
tls13_EncodeKeyShareEntry
(
buf
xtnData
-
>
esniPrivateKey
-
>
group
-
>
name
xtnData
-
>
esniPrivateKey
-
>
keys
-
>
pubKey
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
keyShareBufLen
=
SSL_BUFFER_LEN
(
buf
)
-
keyShareBufStart
;
if
(
tls13_GetHashSizeForHash
(
suiteDef
-
>
prf_hash
)
>
sizeof
(
hash
)
)
{
PORT_Assert
(
PR_FALSE
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
rv
=
PK11_HashBuf
(
ssl3_HashTypeToOID
(
suiteDef
-
>
prf_hash
)
hash
ss
-
>
esniKeys
-
>
data
.
data
ss
-
>
esniKeys
-
>
data
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_Assert
(
PR_FALSE
)
;
return
SECFailure
;
}
rv
=
sslBuffer_AppendVariable
(
buf
hash
tls13_GetHashSizeForHash
(
suiteDef
-
>
prf_hash
)
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
tls13_ComputeESNIKeys
(
ss
xtnData
-
>
peerEsniShare
xtnData
-
>
esniPrivateKey
-
>
keys
suiteDef
hash
SSL_BUFFER_BASE
(
buf
)
+
keyShareBufStart
keyShareBufLen
CONST_CAST
(
PRUint8
ss
-
>
ssl3
.
hs
.
client_random
)
&
keyMat
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
tls13_FormatEsniAADInput
(
&
aadInput
xtnData
-
>
keyShareExtension
.
data
xtnData
-
>
keyShareExtension
.
len
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl_DestroyKeyMaterial
(
&
keyMat
)
;
return
SECFailure
;
}
unsigned
char
*
aad
=
SSL_BUFFER_BASE
(
&
aadInput
)
;
int
aadLen
=
SSL_BUFFER_LEN
(
&
aadInput
)
;
const
ssl3BulkCipherDef
*
cipher_def
=
ssl_GetBulkCipherDef
(
suiteDef
)
;
int
ivLen
=
cipher_def
-
>
iv_size
+
cipher_def
-
>
explicit_nonce_size
;
unsigned
char
zero
[
sizeof
(
sslSequenceNumber
)
]
=
{
0
}
;
SSLCipherAlgorithm
calg
=
cipher_def
-
>
calg
;
SECItem
null_params
=
{
siBuffer
NULL
0
}
;
PK11Context
*
ctxt
=
PK11_CreateContextBySymKey
(
ssl3_Alg2Mech
(
calg
)
CKA_NSS_MESSAGE
|
CKA_ENCRYPT
keyMat
.
key
&
null_params
)
;
if
(
!
ctxt
)
{
ssl_DestroyKeyMaterial
(
&
keyMat
)
;
sslBuffer_Clear
(
&
aadInput
)
;
return
SECFailure
;
}
rv
=
tls13_AEAD
(
ctxt
PR_FALSE
CKG_NO_GENERATE
0
keyMat
.
iv
NULL
ivLen
zero
sizeof
(
zero
)
aad
aadLen
outBuf
&
outLen
sizeof
(
outBuf
)
cipher_def
-
>
tag_size
SSL_BUFFER_BASE
(
&
sni
)
SSL_BUFFER_LEN
(
&
sni
)
)
;
ssl_DestroyKeyMaterial
(
&
keyMat
)
;
sslBuffer_Clear
(
&
aadInput
)
;
PK11_DestroyContext
(
ctxt
PR_TRUE
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslBuffer_AppendVariable
(
buf
outBuf
outLen
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
static
SECStatus
tls13_ServerSendEsniXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
rv
=
sslBuffer_Append
(
buf
xtnData
-
>
esniNonce
sizeof
(
xtnData
-
>
esniNonce
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerHandleEsniXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
sslReadBuffer
buf
;
PRUint8
*
plainText
=
NULL
;
unsigned
int
ptLen
;
SECStatus
rv
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
if
(
!
ss
-
>
esniKeys
)
{
return
SECFailure
;
}
plainText
=
PORT_ZAlloc
(
data
-
>
len
)
;
if
(
!
plainText
)
{
return
SECFailure
;
}
rv
=
tls13_ServerDecryptEsniXtn
(
ss
data
-
>
data
data
-
>
len
plainText
&
ptLen
data
-
>
len
)
;
if
(
rv
)
{
goto
loser
;
}
sslReader
sniRdr
=
SSL_READER
(
plainText
ptLen
)
;
rv
=
sslRead_Read
(
&
sniRdr
sizeof
(
xtnData
-
>
esniNonce
)
&
buf
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
PORT_Memcpy
(
xtnData
-
>
esniNonce
buf
.
buf
sizeof
(
xtnData
-
>
esniNonce
)
)
;
SECItem
sniItem
=
{
siBuffer
(
unsigned
char
*
)
SSL_READER_CURRENT
(
&
sniRdr
)
0
}
;
rv
=
sslRead_ReadVariable
(
&
sniRdr
2
&
buf
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
sniItem
.
len
=
buf
.
len
+
2
;
PRUint64
tmp
;
while
(
SSL_READER_REMAINING
(
&
sniRdr
)
)
{
rv
=
sslRead_ReadNumber
(
&
sniRdr
1
&
tmp
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
tmp
!
=
0
)
{
goto
loser
;
}
}
rv
=
ssl3_HandleServerNameXtn
(
ss
xtnData
&
sniItem
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
ssl3_RegisterExtensionSender
(
ss
xtnData
ssl_tls13_encrypted_sni_xtn
tls13_ServerSendEsniXtn
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_encrypted_sni_xtn
;
PORT_ZFree
(
plainText
data
-
>
len
)
;
return
SECSuccess
;
loser
:
PORT_ZFree
(
plainText
data
-
>
len
)
;
return
SECFailure
;
}
SECStatus
tls13_ClientCheckEsniXtn
(
sslSocket
*
ss
)
{
TLSExtension
*
esniExtension
=
ssl3_FindExtension
(
ss
ssl_tls13_encrypted_sni_xtn
)
;
if
(
!
esniExtension
)
{
FATAL_ERROR
(
ss
SSL_ERROR_MISSING_ESNI_EXTENSION
missing_extension
)
;
return
SECFailure
;
}
if
(
esniExtension
-
>
data
.
len
!
=
sizeof
(
ss
-
>
xtnData
.
esniNonce
)
)
{
FATAL_ERROR
(
ss
SSL_ERROR_RX_MALFORMED_ESNI_EXTENSION
illegal_parameter
)
;
return
SECFailure
;
}
if
(
0
!
=
NSS_SecureMemcmp
(
esniExtension
-
>
data
.
data
ss
-
>
xtnData
.
esniNonce
sizeof
(
ss
-
>
xtnData
.
esniNonce
)
)
)
{
FATAL_ERROR
(
ss
SSL_ERROR_RX_MALFORMED_ESNI_EXTENSION
illegal_parameter
)
;
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
tls13_ClientSendDelegatedCredentialsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
|
|
!
ss
-
>
opt
.
enableDelegatedCredentials
)
{
return
SECSuccess
;
}
SSLSignatureScheme
filtered
[
MAX_SIGNATURE_SCHEMES
]
=
{
0
}
;
unsigned
int
filteredCount
=
0
;
SECStatus
rv
=
ssl3_FilterSigAlgs
(
ss
ss
-
>
vrange
.
max
PR_TRUE
MAX_SIGNATURE_SCHEMES
filtered
&
filteredCount
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
!
filteredCount
)
{
return
SECSuccess
;
}
rv
=
ssl3_EncodeFilteredSigAlgs
(
ss
filtered
filteredCount
buf
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
SSLSignatureScheme
*
dcSchemesAdvertised
=
PORT_ZNewArray
(
SSLSignatureScheme
filteredCount
)
;
if
(
!
dcSchemesAdvertised
)
{
return
SECFailure
;
}
for
(
unsigned
int
i
=
0
;
i
<
filteredCount
;
i
+
+
)
{
dcSchemesAdvertised
[
i
]
=
filtered
[
i
]
;
}
if
(
xtnData
-
>
delegCredSigSchemesAdvertised
)
{
PORT_Free
(
xtnData
-
>
delegCredSigSchemesAdvertised
)
;
}
xtnData
-
>
delegCredSigSchemesAdvertised
=
dcSchemesAdvertised
;
xtnData
-
>
numDelegCredSigSchemesAdvertised
=
filteredCount
;
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleDelegatedCredentialsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
if
(
!
ss
-
>
opt
.
enableDelegatedCredentials
|
|
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_UNEXPECTED_EXTENSION
)
;
return
SECFailure
;
}
sslDelegatedCredential
*
dc
=
NULL
;
SECStatus
rv
=
tls13_ReadDelegatedCredential
(
data
-
>
data
data
-
>
len
&
dc
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
dc
-
>
expectedCertVerifyAlg
=
=
ssl_sig_rsa_pss_rsae_sha256
|
|
dc
-
>
expectedCertVerifyAlg
=
=
ssl_sig_rsa_pss_rsae_sha384
|
|
dc
-
>
expectedCertVerifyAlg
=
=
ssl_sig_rsa_pss_rsae_sha512
)
{
goto
alert_loser
;
}
PRBool
found
=
PR_FALSE
;
for
(
unsigned
int
i
=
0
;
i
<
ss
-
>
xtnData
.
numDelegCredSigSchemesAdvertised
;
+
+
i
)
{
if
(
dc
-
>
expectedCertVerifyAlg
=
=
ss
-
>
xtnData
.
delegCredSigSchemesAdvertised
[
i
]
)
{
found
=
PR_TRUE
;
break
;
}
}
if
(
found
=
=
PR_FALSE
)
{
goto
alert_loser
;
}
if
(
dc
-
>
alg
!
=
dc
-
>
expectedCertVerifyAlg
)
{
found
=
PR_FALSE
;
for
(
unsigned
int
i
=
0
;
i
<
ss
-
>
xtnData
.
numDelegCredSigSchemesAdvertised
;
+
+
i
)
{
if
(
dc
-
>
alg
=
=
ss
-
>
xtnData
.
delegCredSigSchemesAdvertised
[
i
]
)
{
found
=
PR_TRUE
;
break
;
}
}
if
(
found
=
=
PR_FALSE
)
{
goto
alert_loser
;
}
}
xtnData
-
>
peerDelegCred
=
dc
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_delegated_credentials_xtn
;
return
SECSuccess
;
alert_loser
:
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_UNSUPPORTED_SIGNATURE_ALGORITHM
)
;
loser
:
tls13_DestroyDelegatedCredential
(
dc
)
;
return
SECFailure
;
}
static
SECStatus
tls13_ServerSendDelegatedCredentialsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
if
(
tls13_IsSigningWithDelegatedCredential
(
ss
)
)
{
const
SECItem
*
dc
=
&
ss
-
>
sec
.
serverCert
-
>
delegCred
;
SECStatus
rv
;
rv
=
sslBuffer_Append
(
buf
dc
-
>
data
dc
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
}
return
SECSuccess
;
}
SECStatus
tls13_ServerHandleDelegatedCredentialsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
if
(
xtnData
-
>
delegCredSigSchemes
)
{
PORT_Free
(
xtnData
-
>
delegCredSigSchemes
)
;
xtnData
-
>
delegCredSigSchemes
=
NULL
;
xtnData
-
>
numDelegCredSigSchemes
=
0
;
}
SECStatus
rv
=
ssl_ParseSignatureSchemes
(
ss
NULL
&
xtnData
-
>
delegCredSigSchemes
&
xtnData
-
>
numDelegCredSigSchemes
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
if
(
xtnData
-
>
numDelegCredSigSchemes
=
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
handshake_failure
)
;
PORT_SetError
(
SSL_ERROR_UNSUPPORTED_SIGNATURE_ALGORITHM
)
;
return
SECFailure
;
}
if
(
data
-
>
len
!
=
0
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
xtnData
-
>
peerRequestedDelegCred
=
PR_TRUE
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_delegated_credentials_xtn
;
return
ssl3_RegisterExtensionSender
(
ss
xtnData
ssl_delegated_credentials_xtn
tls13_ServerSendDelegatedCredentialsXtn
)
;
}
