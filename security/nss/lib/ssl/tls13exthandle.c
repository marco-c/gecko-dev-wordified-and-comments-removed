#
include
"
nssrenam
.
h
"
#
include
"
nss
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslproto
.
h
"
#
include
"
sslimpl
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
ssl3ext
.
h
"
#
include
"
ssl3exthandle
.
h
"
#
include
"
tls13exthandle
.
h
"
SECStatus
tls13_ServerSendStatusRequestXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
const
sslServerCert
*
serverCert
=
ss
-
>
sec
.
serverCert
;
const
SECItem
*
item
;
SECStatus
rv
;
if
(
!
serverCert
-
>
certStatusArray
|
|
!
serverCert
-
>
certStatusArray
-
>
len
)
{
return
SECSuccess
;
}
item
=
&
serverCert
-
>
certStatusArray
-
>
items
[
0
]
;
rv
=
sslBuffer_AppendNumber
(
buf
1
1
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslBuffer_AppendVariable
(
buf
item
-
>
data
item
-
>
len
3
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
static
PRUint32
tls13_SizeOfKeyShareEntry
(
const
SECKEYPublicKey
*
pubKey
)
{
switch
(
pubKey
-
>
keyType
)
{
case
ecKey
:
return
2
+
2
+
pubKey
-
>
u
.
ec
.
publicValue
.
len
;
case
dhKey
:
return
2
+
2
+
pubKey
-
>
u
.
dh
.
prime
.
len
;
default
:
PORT_Assert
(
0
)
;
}
return
0
;
}
static
SECStatus
tls13_EncodeKeyShareEntry
(
sslBuffer
*
buf
const
sslEphemeralKeyPair
*
keyPair
)
{
SECStatus
rv
;
SECKEYPublicKey
*
pubKey
=
keyPair
-
>
keys
-
>
pubKey
;
unsigned
int
size
=
tls13_SizeOfKeyShareEntry
(
pubKey
)
;
rv
=
sslBuffer_AppendNumber
(
buf
keyPair
-
>
group
-
>
name
2
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
sslBuffer_AppendNumber
(
buf
size
-
4
2
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
switch
(
pubKey
-
>
keyType
)
{
case
ecKey
:
rv
=
sslBuffer_Append
(
buf
pubKey
-
>
u
.
ec
.
publicValue
.
data
pubKey
-
>
u
.
ec
.
publicValue
.
len
)
;
break
;
case
dhKey
:
rv
=
ssl_AppendPaddedDHKeyShare
(
buf
pubKey
PR_FALSE
)
;
break
;
default
:
PORT_Assert
(
0
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
break
;
}
return
rv
;
}
SECStatus
tls13_ClientSendKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
PRCList
*
cursor
;
unsigned
int
lengthOffset
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
send
client
key
share
xtn
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_Skip
(
buf
2
&
lengthOffset
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
;
cursor
!
=
&
ss
-
>
ephemeralKeyPairs
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
sslEphemeralKeyPair
*
keyPair
=
(
sslEphemeralKeyPair
*
)
cursor
;
rv
=
tls13_EncodeKeyShareEntry
(
buf
keyPair
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
rv
=
sslBuffer_InsertLength
(
buf
lengthOffset
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
static
SECStatus
tls13_HandleKeyShareEntry
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PRUint32
group
;
const
sslNamedGroupDef
*
groupDef
;
TLS13KeyShareEntry
*
ks
=
NULL
;
SECItem
share
=
{
siBuffer
NULL
0
}
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
group
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_KEY_SHARE
)
;
goto
loser
;
}
groupDef
=
ssl_LookupNamedGroup
(
group
)
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
share
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
!
groupDef
)
{
return
SECSuccess
;
}
ks
=
PORT_ZNew
(
TLS13KeyShareEntry
)
;
if
(
!
ks
)
goto
loser
;
ks
-
>
group
=
groupDef
;
rv
=
SECITEM_CopyItem
(
NULL
&
ks
-
>
key_exchange
&
share
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
PR_APPEND_LINK
(
&
ks
-
>
link
&
xtnData
-
>
remoteKeyShares
)
;
return
SECSuccess
;
loser
:
if
(
ks
)
tls13_DestroyKeyShareEntry
(
ks
)
;
return
SECFailure
;
}
SECStatus
tls13_ClientHandleKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PORT_Assert
(
PR_CLIST_IS_EMPTY
(
&
xtnData
-
>
remoteKeyShares
)
)
;
PORT_Assert
(
!
ss
-
>
sec
.
isServer
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
PORT_SetError
(
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
)
;
return
SECFailure
;
}
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
key_share
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
tls13_HandleKeyShareEntry
(
ss
xtnData
data
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_KEY_SHARE
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_KEY_SHARE
)
;
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleKeyShareXtnHrr
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PRUint32
tmp
;
const
sslNamedGroupDef
*
group
;
PORT_Assert
(
!
ss
-
>
sec
.
isServer
)
;
PORT_Assert
(
ss
-
>
vrange
.
max
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
key_share
extension
in
HRR
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
tmp
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HELLO_RETRY_REQUEST
)
;
return
SECFailure
;
}
group
=
ssl_LookupNamedGroup
(
(
SSLNamedGroup
)
tmp
)
;
if
(
!
ssl_NamedGroupEnabled
(
ss
group
)
|
|
ssl_HaveEphemeralKeyPair
(
ss
group
)
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HELLO_RETRY_REQUEST
)
;
return
SECFailure
;
}
ssl_FreeEphemeralKeyPairs
(
CONST_CAST
(
sslSocket
ss
)
)
;
rv
=
tls13_CreateKeyShare
(
CONST_CAST
(
sslSocket
ss
)
group
)
;
if
(
rv
!
=
SECSuccess
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
internal_error
)
;
PORT_SetError
(
SEC_ERROR_KEYGEN_FAIL
)
;
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
tls13_ServerHandleKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PRUint32
length
;
PORT_Assert
(
ss
-
>
sec
.
isServer
)
;
PORT_Assert
(
PR_CLIST_IS_EMPTY
(
&
xtnData
-
>
remoteKeyShares
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
key_share
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
length
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
if
(
length
!
=
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_KEY_SHARE
)
;
goto
loser
;
}
while
(
data
-
>
len
)
{
rv
=
tls13_HandleKeyShareEntry
(
ss
xtnData
data
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
}
return
SECSuccess
;
loser
:
tls13_DestroyKeyShares
(
&
xtnData
-
>
remoteKeyShares
)
;
return
SECFailure
;
}
SECStatus
tls13_ServerSendKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
sslEphemeralKeyPair
*
keyPair
;
PORT_Assert
(
!
PR_CLIST_IS_EMPTY
(
&
ss
-
>
ephemeralKeyPairs
)
)
;
PORT_Assert
(
PR_PREV_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
=
=
PR_NEXT_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
)
;
keyPair
=
(
sslEphemeralKeyPair
*
)
PR_NEXT_LINK
(
&
ss
-
>
ephemeralKeyPairs
)
;
rv
=
tls13_EncodeKeyShareEntry
(
buf
keyPair
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendPreSharedKeyXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
NewSessionTicket
*
session_ticket
;
PRTime
age
;
const
static
PRUint8
binder
[
TLS13_MAX_FINISHED_SIZE
]
=
{
0
}
;
unsigned
int
binderLen
;
SECStatus
rv
;
if
(
!
ss
-
>
statelessResume
)
{
return
SECSuccess
;
}
PORT_Assert
(
buf
-
>
len
>
=
4
)
;
xtnData
-
>
lastXtnOffset
=
buf
-
>
len
-
4
;
PORT_Assert
(
ss
-
>
vrange
.
max
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
session_ticket
=
&
ss
-
>
sec
.
ci
.
sid
-
>
u
.
ssl3
.
locked
.
sessionTicket
;
rv
=
sslBuffer_AppendNumber
(
buf
2
+
session_ticket
-
>
ticket
.
len
+
4
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
sslBuffer_AppendVariable
(
buf
session_ticket
-
>
ticket
.
data
session_ticket
-
>
ticket
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
age
=
ssl_TimeUsec
(
)
-
session_ticket
-
>
received_timestamp
;
age
/
=
PR_USEC_PER_MSEC
;
age
+
=
session_ticket
-
>
ticket_age_add
;
rv
=
sslBuffer_AppendNumber
(
buf
age
4
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
binderLen
=
tls13_GetHashSize
(
ss
)
;
rv
=
sslBuffer_AppendNumber
(
buf
binderLen
+
1
2
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
rv
=
sslBuffer_AppendVariable
(
buf
binder
binderLen
1
)
;
if
(
rv
!
=
SECSuccess
)
goto
loser
;
PRINT_BUF
(
50
(
ss
"
Sending
PreSharedKey
value
"
session_ticket
-
>
ticket
.
data
session_ticket
-
>
ticket
.
len
)
)
;
xtnData
-
>
sentSessionTicketInClientHello
=
PR_TRUE
;
*
added
=
PR_TRUE
;
return
SECSuccess
;
loser
:
xtnData
-
>
ticketTimestampVerified
=
PR_FALSE
;
return
SECFailure
;
}
SECStatus
tls13_ServerHandlePreSharedKeyXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECItem
inner
;
SECStatus
rv
;
unsigned
int
numIdentities
=
0
;
unsigned
int
numBinders
=
0
;
SECItem
*
appToken
;
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
pre_shared_key
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
if
(
!
ss
-
>
ssl3
.
hs
.
helloRetry
)
{
appToken
=
&
xtnData
-
>
applicationToken
;
}
else
{
appToken
=
NULL
;
}
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
inner
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
while
(
inner
.
len
)
{
SECItem
label
;
PRUint32
obfuscatedAge
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
label
2
&
inner
.
data
&
inner
.
len
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
if
(
!
label
.
len
)
{
goto
alert_loser
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
obfuscatedAge
4
&
inner
.
data
&
inner
.
len
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
if
(
!
numIdentities
)
{
PRINT_BUF
(
50
(
ss
"
Handling
PreSharedKey
value
"
label
.
data
label
.
len
)
)
;
rv
=
ssl3_ProcessSessionTicketCommon
(
CONST_CAST
(
sslSocket
ss
)
&
label
appToken
)
;
if
(
rv
!
=
SECSuccess
)
return
SECFailure
;
if
(
ss
-
>
sec
.
ci
.
sid
)
{
xtnData
-
>
ticketAge
+
=
obfuscatedAge
;
}
}
+
+
numIdentities
;
}
xtnData
-
>
pskBindersLen
=
data
-
>
len
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
inner
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
return
SECFailure
;
if
(
data
-
>
len
)
{
goto
alert_loser
;
}
while
(
inner
.
len
)
{
SECItem
binder
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
binder
1
&
inner
.
data
&
inner
.
len
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
if
(
binder
.
len
<
32
)
{
goto
alert_loser
;
}
if
(
!
numBinders
)
{
xtnData
-
>
pskBinder
=
binder
;
}
+
+
numBinders
;
}
if
(
numBinders
!
=
numIdentities
)
goto
alert_loser
;
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_pre_shared_key_xtn
;
return
SECSuccess
;
alert_loser
:
ssl3_ExtSendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_MALFORMED_PRE_SHARED_KEY
)
;
return
SECFailure
;
}
SECStatus
tls13_ServerSendPreSharedKeyXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
rv
=
sslBuffer_AppendNumber
(
buf
0
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandlePreSharedKeyXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
PRUint32
index
;
SECStatus
rv
;
SSL_TRC
(
3
(
"
%
d
:
SSL3
[
%
d
]
:
handle
pre_shared_key
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
PORT_SetError
(
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshakeNumber
(
ss
&
index
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
return
SECFailure
;
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_PRE_SHARED_KEY
)
;
return
SECFailure
;
}
if
(
index
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_PRE_SHARED_KEY
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_pre_shared_key_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendEarlyDataXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
if
(
!
tls13_ClientAllow0Rtt
(
ss
ss
-
>
sec
.
ci
.
sid
)
)
{
return
SECSuccess
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerHandleEarlyDataXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
early_data
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
if
(
ss
-
>
ssl3
.
hs
.
helloRetry
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
unsupported_extension
)
;
PORT_SetError
(
SSL_ERROR_RX_UNEXPECTED_EXTENSION
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_EARLY_DATA
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_early_data_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleEarlyDataXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
early_data
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
PORT_SetError
(
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_EARLY_DATA
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_early_data_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleTicketEarlyDataXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
PRUint32
utmp
;
SECStatus
rv
;
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
ticket
early_data
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
PORT_SetError
(
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
)
;
return
SECFailure
;
}
rv
=
ssl3_ExtConsumeHandshake
(
ss
&
utmp
sizeof
(
utmp
)
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_NEW_SESSION_TICKET
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_NEW_SESSION_TICKET
)
;
return
SECFailure
;
}
xtnData
-
>
max_early_data_size
=
PR_ntohl
(
utmp
)
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendSupportedVersionsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
PRUint16
version
;
unsigned
int
lengthOffset
;
SECStatus
rv
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
client
send
supported_versions
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_Skip
(
buf
1
&
lengthOffset
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
for
(
version
=
ss
-
>
vrange
.
max
;
version
>
=
ss
-
>
vrange
.
min
;
-
-
version
)
{
rv
=
sslBuffer_AppendNumber
(
buf
tls13_EncodeDraftVersion
(
version
)
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
rv
=
sslBuffer_InsertLength
(
buf
lengthOffset
1
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerSendSupportedVersionsXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
server
send
supported_versions
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_AppendNumber
(
buf
tls13_EncodeDraftVersion
(
SSL_LIBRARY_VERSION_TLS_1_3
)
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleHrrCookie
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
cookie
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
PORT_Assert
(
ss
-
>
vrange
.
max
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
CONST_CAST
(
sslSocket
ss
)
-
>
ssl3
.
hs
.
cookie
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HELLO_RETRY_REQUEST
)
;
return
SECFailure
;
}
if
(
!
ss
-
>
ssl3
.
hs
.
cookie
.
len
|
|
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_HELLO_RETRY_REQUEST
)
;
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
tls13_ClientSendHrrCookieXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
|
|
!
ss
-
>
ssl3
.
hs
.
cookie
.
len
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
send
cookie
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_AppendVariable
(
buf
ss
-
>
ssl3
.
hs
.
cookie
.
data
ss
-
>
ssl3
.
hs
.
cookie
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerHandleCookieXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
cookie
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
xtnData
-
>
cookie
2
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
xtnData
-
>
cookie
.
len
=
=
0
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
if
(
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_cookie_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_ClientSendPskModesXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
static
const
PRUint8
ke_modes
[
]
=
{
tls13_psk_dh_ke
}
;
SECStatus
rv
;
if
(
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
|
|
ss
-
>
opt
.
noCache
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
send
psk
key
exchange
modes
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
sslBuffer_AppendVariable
(
buf
ke_modes
sizeof
(
ke_modes
)
1
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerHandlePskModesXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
return
SECSuccess
;
}
SSL_TRC
(
3
(
"
%
d
:
TLS13
[
%
d
]
:
handle
PSK
key
exchange
modes
extension
"
SSL_GETPID
(
)
ss
-
>
fd
)
)
;
rv
=
ssl3_ExtConsumeHandshakeVariable
(
ss
&
xtnData
-
>
psk_ke_modes
1
&
data
-
>
data
&
data
-
>
len
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
if
(
!
xtnData
-
>
psk_ke_modes
.
len
|
|
data
-
>
len
)
{
PORT_SetError
(
SSL_ERROR_MALFORMED_PSK_KEY_EXCHANGE_MODES
)
;
return
SECFailure
;
}
xtnData
-
>
negotiated
[
xtnData
-
>
numNegotiated
+
+
]
=
ssl_tls13_psk_key_exchange_modes_xtn
;
return
SECSuccess
;
}
SECStatus
tls13_SendCertAuthoritiesXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
unsigned
int
calen
;
const
SECItem
*
name
;
unsigned
int
nnames
;
SECStatus
rv
;
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
rv
=
ssl_GetCertificateRequestCAs
(
ss
&
calen
&
name
&
nnames
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
if
(
!
calen
)
{
return
SECSuccess
;
}
rv
=
sslBuffer_AppendNumber
(
buf
calen
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
while
(
nnames
)
{
rv
=
sslBuffer_AppendVariable
(
buf
name
-
>
data
name
-
>
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
+
+
name
;
-
-
nnames
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ClientHandleCertAuthoritiesXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
{
SECStatus
rv
;
PLArenaPool
*
arena
;
if
(
!
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CERT_REQUEST
)
;
return
SECFailure
;
}
arena
=
PORT_NewArena
(
DER_DEFAULT_CHUNKSIZE
)
;
if
(
!
arena
)
{
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
xtnData
-
>
certReqAuthorities
.
arena
=
arena
;
rv
=
ssl3_ParseCertificateRequestCAs
(
(
sslSocket
*
)
ss
&
data
-
>
data
&
data
-
>
len
&
xtnData
-
>
certReqAuthorities
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
if
(
data
-
>
len
)
{
ssl3_ExtSendAlert
(
ss
alert_fatal
decode_error
)
;
PORT_SetError
(
SSL_ERROR_RX_MALFORMED_CERT_REQUEST
)
;
goto
loser
;
}
return
SECSuccess
;
loser
:
PORT_FreeArena
(
arena
PR_FALSE
)
;
xtnData
-
>
certReqAuthorities
.
arena
=
NULL
;
return
SECFailure
;
}
SECStatus
tls13_ServerSendHrrKeyShareXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
if
(
!
xtnData
-
>
selectedGroup
)
{
return
SECSuccess
;
}
rv
=
sslBuffer_AppendNumber
(
buf
xtnData
-
>
selectedGroup
-
>
name
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
SECStatus
tls13_ServerSendHrrCookieXtn
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
added
)
{
SECStatus
rv
;
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
PORT_Assert
(
xtnData
-
>
cookie
.
len
>
0
)
;
rv
=
sslBuffer_AppendVariable
(
buf
xtnData
-
>
cookie
.
data
xtnData
-
>
cookie
.
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
*
added
=
PR_TRUE
;
return
SECSuccess
;
}
