#
include
"
nssrenam
.
h
"
#
include
"
nss
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslimpl
.
h
"
#
include
"
sslproto
.
h
"
#
include
"
ssl3exthandle
.
h
"
#
include
"
tls13err
.
h
"
#
include
"
tls13exthandle
.
h
"
typedef
SECStatus
(
*
ssl3ExtensionHandlerFunc
)
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
SECItem
*
data
)
;
typedef
struct
{
SSLExtensionType
ex_type
;
ssl3ExtensionHandlerFunc
ex_handler
;
}
ssl3ExtensionHandler
;
static
const
ssl3ExtensionHandler
clientHelloHandlers
[
]
=
{
{
ssl_server_name_xtn
&
ssl3_HandleServerNameXtn
}
{
ssl_supported_groups_xtn
&
ssl_HandleSupportedGroupsXtn
}
{
ssl_ec_point_formats_xtn
&
ssl3_HandleSupportedPointFormatsXtn
}
{
ssl_session_ticket_xtn
&
ssl3_ServerHandleSessionTicketXtn
}
{
ssl_renegotiation_info_xtn
&
ssl3_HandleRenegotiationInfoXtn
}
{
ssl_next_proto_nego_xtn
&
ssl3_ServerHandleNextProtoNegoXtn
}
{
ssl_app_layer_protocol_xtn
&
ssl3_ServerHandleAppProtoXtn
}
{
ssl_use_srtp_xtn
&
ssl3_ServerHandleUseSRTPXtn
}
{
ssl_cert_status_xtn
&
ssl3_ServerHandleStatusRequestXtn
}
{
ssl_signature_algorithms_xtn
&
ssl3_HandleSigAlgsXtn
}
{
ssl_extended_master_secret_xtn
&
ssl3_HandleExtendedMasterSecretXtn
}
{
ssl_signed_cert_timestamp_xtn
&
ssl3_ServerHandleSignedCertTimestampXtn
}
{
ssl_tls13_key_share_xtn
&
tls13_ServerHandleKeyShareXtn
}
{
ssl_tls13_pre_shared_key_xtn
&
tls13_ServerHandlePreSharedKeyXtn
}
{
ssl_tls13_early_data_xtn
&
tls13_ServerHandleEarlyDataXtn
}
{
ssl_tls13_psk_key_exchange_modes_xtn
&
tls13_ServerHandlePskModesXtn
}
{
ssl_tls13_cookie_xtn
&
tls13_ServerHandleCookieXtn
}
{
0
NULL
}
}
;
static
const
ssl3ExtensionHandler
serverHelloHandlersTLS
[
]
=
{
{
ssl_server_name_xtn
&
ssl3_HandleServerNameXtn
}
{
ssl_session_ticket_xtn
&
ssl3_ClientHandleSessionTicketXtn
}
{
ssl_renegotiation_info_xtn
&
ssl3_HandleRenegotiationInfoXtn
}
{
ssl_next_proto_nego_xtn
&
ssl3_ClientHandleNextProtoNegoXtn
}
{
ssl_app_layer_protocol_xtn
&
ssl3_ClientHandleAppProtoXtn
}
{
ssl_use_srtp_xtn
&
ssl3_ClientHandleUseSRTPXtn
}
{
ssl_cert_status_xtn
&
ssl3_ClientHandleStatusRequestXtn
}
{
ssl_extended_master_secret_xtn
&
ssl3_HandleExtendedMasterSecretXtn
}
{
ssl_signed_cert_timestamp_xtn
&
ssl3_ClientHandleSignedCertTimestampXtn
}
{
ssl_tls13_key_share_xtn
&
tls13_ClientHandleKeyShareXtn
}
{
ssl_tls13_pre_shared_key_xtn
&
tls13_ClientHandlePreSharedKeyXtn
}
{
ssl_tls13_early_data_xtn
&
tls13_ClientHandleEarlyDataXtn
}
{
0
NULL
}
}
;
static
const
ssl3ExtensionHandler
helloRetryRequestHandlers
[
]
=
{
{
ssl_tls13_key_share_xtn
tls13_ClientHandleKeyShareXtnHrr
}
{
ssl_tls13_cookie_xtn
tls13_ClientHandleHrrCookie
}
{
0
NULL
}
}
;
static
const
ssl3ExtensionHandler
serverHelloHandlersSSL3
[
]
=
{
{
ssl_renegotiation_info_xtn
&
ssl3_HandleRenegotiationInfoXtn
}
{
0
NULL
}
}
;
static
const
ssl3ExtensionHandler
newSessionTicketHandlers
[
]
=
{
{
ssl_tls13_early_data_xtn
&
tls13_ClientHandleTicketEarlyDataXtn
}
{
0
NULL
}
}
;
static
const
ssl3ExtensionHandler
serverCertificateHandlers
[
]
=
{
{
ssl_signed_cert_timestamp_xtn
&
ssl3_ClientHandleSignedCertTimestampXtn
}
{
ssl_cert_status_xtn
&
ssl3_ClientHandleStatusRequestXtn
}
{
0
NULL
}
}
;
static
const
ssl3ExtensionHandler
certificateRequestHandlers
[
]
=
{
{
ssl_signature_algorithms_xtn
&
ssl3_HandleSigAlgsXtn
}
{
ssl_tls13_certificate_authorities_xtn
&
tls13_ClientHandleCertAuthoritiesXtn
}
{
0
NULL
}
}
;
static
const
sslExtensionBuilder
clientHelloSendersTLS
[
]
=
{
{
ssl_server_name_xtn
&
ssl3_ClientSendServerNameXtn
}
{
ssl_extended_master_secret_xtn
&
ssl3_SendExtendedMasterSecretXtn
}
{
ssl_renegotiation_info_xtn
&
ssl3_SendRenegotiationInfoXtn
}
{
ssl_supported_groups_xtn
&
ssl_SendSupportedGroupsXtn
}
{
ssl_ec_point_formats_xtn
&
ssl3_SendSupportedPointFormatsXtn
}
{
ssl_session_ticket_xtn
&
ssl3_ClientSendSessionTicketXtn
}
{
ssl_next_proto_nego_xtn
&
ssl3_ClientSendNextProtoNegoXtn
}
{
ssl_app_layer_protocol_xtn
&
ssl3_ClientSendAppProtoXtn
}
{
ssl_use_srtp_xtn
&
ssl3_ClientSendUseSRTPXtn
}
{
ssl_cert_status_xtn
&
ssl3_ClientSendStatusRequestXtn
}
{
ssl_signed_cert_timestamp_xtn
&
ssl3_ClientSendSignedCertTimestampXtn
}
{
ssl_tls13_key_share_xtn
&
tls13_ClientSendKeyShareXtn
}
{
ssl_tls13_early_data_xtn
&
tls13_ClientSendEarlyDataXtn
}
{
ssl_tls13_supported_versions_xtn
&
tls13_ClientSendSupportedVersionsXtn
}
{
ssl_signature_algorithms_xtn
&
ssl3_SendSigAlgsXtn
}
{
ssl_tls13_cookie_xtn
&
tls13_ClientSendHrrCookieXtn
}
{
ssl_tls13_psk_key_exchange_modes_xtn
&
tls13_ClientSendPskModesXtn
}
{
ssl_tls13_pre_shared_key_xtn
&
tls13_ClientSendPreSharedKeyXtn
}
{
0
NULL
}
}
;
static
const
sslExtensionBuilder
clientHelloSendersSSL3
[
]
=
{
{
ssl_renegotiation_info_xtn
&
ssl3_SendRenegotiationInfoXtn
}
{
0
NULL
}
}
;
static
const
sslExtensionBuilder
tls13_cert_req_senders
[
]
=
{
{
ssl_signature_algorithms_xtn
&
ssl3_SendSigAlgsXtn
}
{
ssl_tls13_certificate_authorities_xtn
&
tls13_SendCertAuthoritiesXtn
}
{
0
NULL
}
}
;
static
const
sslExtensionBuilder
tls13_hrr_senders
[
]
=
{
{
ssl_tls13_key_share_xtn
&
tls13_ServerSendHrrKeyShareXtn
}
{
ssl_tls13_cookie_xtn
&
tls13_ServerSendHrrCookieXtn
}
{
ssl_tls13_supported_versions_xtn
&
tls13_ServerSendSupportedVersionsXtn
}
{
0
NULL
}
}
;
static
const
struct
{
SSLExtensionType
type
;
SSLExtensionSupport
support
;
}
ssl_supported_extensions
[
]
=
{
{
ssl_server_name_xtn
ssl_ext_native_only
}
{
ssl_cert_status_xtn
ssl_ext_native
}
{
ssl_supported_groups_xtn
ssl_ext_native_only
}
{
ssl_ec_point_formats_xtn
ssl_ext_native
}
{
ssl_signature_algorithms_xtn
ssl_ext_native_only
}
{
ssl_use_srtp_xtn
ssl_ext_native
}
{
ssl_app_layer_protocol_xtn
ssl_ext_native_only
}
{
ssl_signed_cert_timestamp_xtn
ssl_ext_native
}
{
ssl_padding_xtn
ssl_ext_native
}
{
ssl_extended_master_secret_xtn
ssl_ext_native_only
}
{
ssl_session_ticket_xtn
ssl_ext_native_only
}
{
ssl_tls13_key_share_xtn
ssl_ext_native_only
}
{
ssl_tls13_pre_shared_key_xtn
ssl_ext_native_only
}
{
ssl_tls13_early_data_xtn
ssl_ext_native_only
}
{
ssl_tls13_supported_versions_xtn
ssl_ext_native_only
}
{
ssl_tls13_cookie_xtn
ssl_ext_native_only
}
{
ssl_tls13_psk_key_exchange_modes_xtn
ssl_ext_native_only
}
{
ssl_tls13_ticket_early_data_info_xtn
ssl_ext_native_only
}
{
ssl_tls13_certificate_authorities_xtn
ssl_ext_native
}
{
ssl_next_proto_nego_xtn
ssl_ext_none
}
{
ssl_renegotiation_info_xtn
ssl_ext_native
}
}
;
static
SSLExtensionSupport
ssl_GetExtensionSupport
(
PRUint16
type
)
{
unsigned
int
i
;
for
(
i
=
0
;
i
<
PR_ARRAY_SIZE
(
ssl_supported_extensions
)
;
+
+
i
)
{
if
(
type
=
=
ssl_supported_extensions
[
i
]
.
type
)
{
return
ssl_supported_extensions
[
i
]
.
support
;
}
}
return
ssl_ext_none
;
}
SECStatus
SSLExp_GetExtensionSupport
(
PRUint16
type
SSLExtensionSupport
*
support
)
{
*
support
=
ssl_GetExtensionSupport
(
type
)
;
return
SECSuccess
;
}
SECStatus
SSLExp_InstallExtensionHooks
(
PRFileDesc
*
fd
PRUint16
extension
SSLExtensionWriter
writer
void
*
writerArg
SSLExtensionHandler
handler
void
*
handlerArg
)
{
sslSocket
*
ss
=
ssl_FindSocket
(
fd
)
;
PRCList
*
cursor
;
sslCustomExtensionHooks
*
hook
;
if
(
!
ss
)
{
return
SECFailure
;
}
if
(
(
writer
&
&
!
handler
)
|
|
(
!
writer
&
&
handler
)
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
ssl_GetExtensionSupport
(
extension
)
=
=
ssl_ext_native_only
)
{
PORT_SetError
(
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
ss
-
>
firstHsDone
|
|
(
(
ss
-
>
ssl3
.
hs
.
ws
!
=
idle_handshake
)
&
&
(
ss
-
>
ssl3
.
hs
.
ws
!
=
wait_client_hello
)
)
)
{
PORT_SetError
(
PR_INVALID_STATE_ERROR
)
;
return
SECFailure
;
}
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
extensionHooks
)
;
cursor
!
=
&
ss
-
>
extensionHooks
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
hook
=
(
sslCustomExtensionHooks
*
)
cursor
;
if
(
hook
-
>
type
=
=
extension
)
{
PR_REMOVE_LINK
(
&
hook
-
>
link
)
;
PORT_Free
(
hook
)
;
break
;
}
}
if
(
!
writer
&
&
!
handler
)
{
return
SECSuccess
;
}
hook
=
PORT_ZNew
(
sslCustomExtensionHooks
)
;
if
(
!
hook
)
{
return
SECFailure
;
}
hook
-
>
type
=
extension
;
hook
-
>
writer
=
writer
;
hook
-
>
writerArg
=
writerArg
;
hook
-
>
handler
=
handler
;
hook
-
>
handlerArg
=
handlerArg
;
PR_APPEND_LINK
(
&
hook
-
>
link
&
ss
-
>
extensionHooks
)
;
return
SECSuccess
;
}
static
sslCustomExtensionHooks
*
ssl_FindCustomExtensionHooks
(
sslSocket
*
ss
PRUint16
extension
)
{
PRCList
*
cursor
;
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
extensionHooks
)
;
cursor
!
=
&
ss
-
>
extensionHooks
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
sslCustomExtensionHooks
*
hook
=
(
sslCustomExtensionHooks
*
)
cursor
;
if
(
hook
-
>
type
=
=
extension
)
{
return
hook
;
}
}
return
NULL
;
}
static
PRBool
arrayContainsExtension
(
const
PRUint16
*
array
PRUint32
len
PRUint16
ex_type
)
{
unsigned
int
i
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
ex_type
=
=
array
[
i
]
)
return
PR_TRUE
;
}
return
PR_FALSE
;
}
PRBool
ssl3_ExtensionNegotiated
(
const
sslSocket
*
ss
PRUint16
ex_type
)
{
const
TLSExtensionData
*
xtnData
=
&
ss
-
>
xtnData
;
return
arrayContainsExtension
(
xtnData
-
>
negotiated
xtnData
-
>
numNegotiated
ex_type
)
;
}
PRBool
ssl3_ExtensionAdvertised
(
const
sslSocket
*
ss
PRUint16
ex_type
)
{
const
TLSExtensionData
*
xtnData
=
&
ss
-
>
xtnData
;
return
arrayContainsExtension
(
xtnData
-
>
advertised
xtnData
-
>
numAdvertised
ex_type
)
;
}
SECStatus
ssl3_ParseExtensions
(
sslSocket
*
ss
PRUint8
*
*
b
PRUint32
*
length
)
{
ssl3_DestroyRemoteExtensions
(
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
)
;
while
(
*
length
)
{
SECStatus
rv
;
PRUint32
extension_type
;
SECItem
extension_data
=
{
siBuffer
NULL
0
}
;
TLSExtension
*
extension
;
PRCList
*
cursor
;
rv
=
ssl3_ConsumeHandshakeNumber
(
ss
&
extension_type
2
b
length
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
SSL_TRC
(
10
(
"
%
d
:
SSL3
[
%
d
]
:
parsing
extension
%
d
"
SSL_GETPID
(
)
ss
-
>
fd
extension_type
)
)
;
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
)
;
cursor
!
=
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
if
(
(
(
TLSExtension
*
)
cursor
)
-
>
type
=
=
extension_type
)
{
(
void
)
SSL3_SendAlert
(
ss
alert_fatal
illegal_parameter
)
;
PORT_SetError
(
SSL_ERROR_RX_UNEXPECTED_EXTENSION
)
;
return
SECFailure
;
}
}
rv
=
ssl3_ConsumeHandshakeVariable
(
ss
&
extension_data
2
b
length
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
extension
=
PORT_ZNew
(
TLSExtension
)
;
if
(
!
extension
)
{
return
SECFailure
;
}
extension
-
>
type
=
(
PRUint16
)
extension_type
;
extension
-
>
data
=
extension_data
;
PR_APPEND_LINK
(
&
extension
-
>
link
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
)
;
}
return
SECSuccess
;
}
TLSExtension
*
ssl3_FindExtension
(
sslSocket
*
ss
SSLExtensionType
extension_type
)
{
PRCList
*
cursor
;
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
)
;
cursor
!
=
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
TLSExtension
*
extension
=
(
TLSExtension
*
)
cursor
;
if
(
extension
-
>
type
=
=
extension_type
)
{
return
extension
;
}
}
return
NULL
;
}
static
SECStatus
ssl_CallExtensionHandler
(
sslSocket
*
ss
SSLHandshakeType
handshakeMessage
TLSExtension
*
extension
const
ssl3ExtensionHandler
*
handler
)
{
SECStatus
rv
=
SECSuccess
;
SSLAlertDescription
alert
=
handshake_failure
;
sslCustomExtensionHooks
*
customHooks
;
customHooks
=
ssl_FindCustomExtensionHooks
(
ss
extension
-
>
type
)
;
if
(
customHooks
)
{
if
(
customHooks
-
>
handler
)
{
rv
=
customHooks
-
>
handler
(
ss
-
>
fd
handshakeMessage
extension
-
>
data
.
data
extension
-
>
data
.
len
&
alert
customHooks
-
>
handlerArg
)
;
}
}
else
{
for
(
;
handler
-
>
ex_handler
!
=
NULL
;
+
+
handler
)
{
if
(
handler
-
>
ex_type
=
=
extension
-
>
type
)
{
rv
=
(
*
handler
-
>
ex_handler
)
(
ss
&
ss
-
>
xtnData
&
extension
-
>
data
)
;
break
;
}
}
}
if
(
rv
!
=
SECSuccess
)
{
if
(
!
ss
-
>
ssl3
.
fatalAlertSent
)
{
(
void
)
SSL3_SendAlert
(
ss
alert_fatal
alert
)
;
}
return
SECFailure
;
}
return
SECSuccess
;
}
SECStatus
ssl3_HandleParsedExtensions
(
sslSocket
*
ss
SSLHandshakeType
message
)
{
const
ssl3ExtensionHandler
*
handlers
;
PRBool
isTLS13
=
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
|
|
(
message
=
=
ssl_hs_hello_retry_request
)
;
PRBool
allowNotOffered
=
(
message
=
=
ssl_hs_client_hello
)
|
|
(
message
=
=
ssl_hs_certificate_request
)
|
|
(
message
=
=
ssl_hs_new_session_ticket
)
;
PRCList
*
cursor
;
switch
(
message
)
{
case
ssl_hs_client_hello
:
handlers
=
clientHelloHandlers
;
break
;
case
ssl_hs_new_session_ticket
:
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
handlers
=
newSessionTicketHandlers
;
break
;
case
ssl_hs_hello_retry_request
:
handlers
=
helloRetryRequestHandlers
;
break
;
case
ssl_hs_encrypted_extensions
:
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
case
ssl_hs_server_hello
:
if
(
ss
-
>
version
>
SSL_LIBRARY_VERSION_3_0
)
{
handlers
=
serverHelloHandlersTLS
;
}
else
{
handlers
=
serverHelloHandlersSSL3
;
}
break
;
case
ssl_hs_certificate
:
PORT_Assert
(
!
ss
-
>
sec
.
isServer
)
;
handlers
=
serverCertificateHandlers
;
break
;
case
ssl_hs_certificate_request
:
PORT_Assert
(
!
ss
-
>
sec
.
isServer
)
;
handlers
=
certificateRequestHandlers
;
break
;
default
:
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
PORT_Assert
(
0
)
;
return
SECFailure
;
}
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
)
;
cursor
!
=
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
TLSExtension
*
extension
=
(
TLSExtension
*
)
cursor
;
SECStatus
rv
;
if
(
!
allowNotOffered
&
&
(
extension
-
>
type
!
=
ssl_tls13_cookie_xtn
)
&
&
!
ssl3_ExtensionAdvertised
(
ss
extension
-
>
type
)
)
{
(
void
)
SSL3_SendAlert
(
ss
alert_fatal
unsupported_extension
)
;
PORT_SetError
(
SSL_ERROR_RX_UNEXPECTED_EXTENSION
)
;
return
SECFailure
;
}
if
(
isTLS13
&
&
!
ssl_FindCustomExtensionHooks
(
ss
extension
-
>
type
)
)
{
switch
(
tls13_ExtensionStatus
(
extension
-
>
type
message
)
)
{
case
tls13_extension_allowed
:
break
;
case
tls13_extension_unknown
:
if
(
allowNotOffered
)
{
continue
;
}
case
tls13_extension_disallowed
:
SSL_TRC
(
3
(
"
%
d
:
TLS13
:
unexpected
extension
%
d
in
message
%
d
"
SSL_GETPID
(
)
extension
message
)
)
;
tls13_FatalError
(
ss
SSL_ERROR_EXTENSION_DISALLOWED_FOR_VERSION
unsupported_extension
)
;
return
SECFailure
;
}
}
if
(
ss
-
>
sec
.
isServer
&
&
isTLS13
&
&
(
extension
-
>
type
=
=
ssl_tls13_pre_shared_key_xtn
)
&
&
(
PR_NEXT_LINK
(
cursor
)
!
=
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
)
)
{
tls13_FatalError
(
ss
SSL_ERROR_RX_MALFORMED_CLIENT_HELLO
illegal_parameter
)
;
return
SECFailure
;
}
rv
=
ssl_CallExtensionHandler
(
ss
message
extension
handlers
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
}
return
SECSuccess
;
}
SECStatus
ssl3_HandleExtensions
(
sslSocket
*
ss
PRUint8
*
*
b
PRUint32
*
length
SSLHandshakeType
handshakeMessage
)
{
SECStatus
rv
;
rv
=
ssl3_ParseExtensions
(
ss
b
length
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
rv
=
ssl3_HandleParsedExtensions
(
ss
handshakeMessage
)
;
if
(
rv
!
=
SECSuccess
)
return
rv
;
ssl3_DestroyRemoteExtensions
(
&
ss
-
>
ssl3
.
hs
.
remoteExtensions
)
;
return
SECSuccess
;
}
SECStatus
ssl3_RegisterExtensionSender
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
PRUint16
ex_type
sslExtensionBuilderFunc
cb
)
{
int
i
;
sslExtensionBuilder
*
sender
;
if
(
ss
-
>
version
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
sender
=
&
xtnData
-
>
serverHelloSenders
[
0
]
;
}
else
{
if
(
tls13_ExtensionStatus
(
ex_type
ssl_hs_server_hello
)
=
=
tls13_extension_allowed
)
{
PORT_Assert
(
tls13_ExtensionStatus
(
ex_type
ssl_hs_encrypted_extensions
)
=
=
tls13_extension_disallowed
)
;
sender
=
&
xtnData
-
>
serverHelloSenders
[
0
]
;
}
else
if
(
tls13_ExtensionStatus
(
ex_type
ssl_hs_encrypted_extensions
)
=
=
tls13_extension_allowed
)
{
sender
=
&
xtnData
-
>
encryptedExtensionsSenders
[
0
]
;
}
else
if
(
tls13_ExtensionStatus
(
ex_type
ssl_hs_certificate
)
=
=
tls13_extension_allowed
)
{
sender
=
&
xtnData
-
>
certificateSenders
[
0
]
;
}
else
{
PORT_Assert
(
0
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
}
for
(
i
=
0
;
i
<
SSL_MAX_EXTENSIONS
;
+
+
i
+
+
sender
)
{
if
(
!
sender
-
>
ex_sender
)
{
sender
-
>
ex_type
=
ex_type
;
sender
-
>
ex_sender
=
cb
;
return
SECSuccess
;
}
PORT_Assert
(
sender
-
>
ex_type
!
=
ex_type
)
;
if
(
sender
-
>
ex_type
=
=
ex_type
)
{
break
;
}
}
PORT_Assert
(
i
<
SSL_MAX_EXTENSIONS
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
static
SECStatus
ssl_CallCustomExtensionSenders
(
sslSocket
*
ss
sslBuffer
*
buf
SSLHandshakeType
message
)
{
sslBuffer
tail
=
SSL_BUFFER_EMPTY
;
SECStatus
rv
;
PRCList
*
cursor
;
if
(
ss
-
>
xtnData
.
lastXtnOffset
)
{
rv
=
sslBuffer_Append
(
&
tail
buf
-
>
buf
+
ss
-
>
xtnData
.
lastXtnOffset
buf
-
>
len
-
ss
-
>
xtnData
.
lastXtnOffset
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
buf
-
>
len
=
ss
-
>
xtnData
.
lastXtnOffset
;
}
rv
=
sslBuffer_Grow
(
buf
65535
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
extensionHooks
)
;
cursor
!
=
&
ss
-
>
extensionHooks
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
sslCustomExtensionHooks
*
hook
=
(
sslCustomExtensionHooks
*
)
cursor
;
PRBool
append
=
PR_FALSE
;
unsigned
int
len
=
0
;
if
(
hook
-
>
writer
)
{
unsigned
int
space
=
buf
-
>
space
-
(
buf
-
>
len
+
tail
.
len
+
4
)
;
append
=
(
*
hook
-
>
writer
)
(
ss
-
>
fd
message
buf
-
>
buf
+
buf
-
>
len
+
4
&
len
space
hook
-
>
writerArg
)
;
if
(
len
>
space
)
{
PORT_SetError
(
SEC_ERROR_APPLICATION_CALLBACK_ERROR
)
;
goto
loser
;
}
}
if
(
!
append
)
{
continue
;
}
rv
=
sslBuffer_AppendNumber
(
buf
hook
-
>
type
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
sslBuffer_AppendNumber
(
buf
len
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
buf
-
>
len
+
=
len
;
if
(
message
=
=
ssl_hs_client_hello
|
|
message
=
=
ssl_hs_certificate_request
)
{
ss
-
>
xtnData
.
advertised
[
ss
-
>
xtnData
.
numAdvertised
+
+
]
=
hook
-
>
type
;
}
}
sslBuffer_Append
(
buf
tail
.
buf
tail
.
len
)
;
sslBuffer_Clear
(
&
tail
)
;
return
SECSuccess
;
loser
:
sslBuffer_Clear
(
&
tail
)
;
return
SECFailure
;
}
SECStatus
ssl_ConstructExtensions
(
sslSocket
*
ss
sslBuffer
*
buf
SSLHandshakeType
message
)
{
const
sslExtensionBuilder
*
sender
;
SECStatus
rv
;
PORT_Assert
(
buf
-
>
len
=
=
0
)
;
switch
(
message
)
{
case
ssl_hs_client_hello
:
if
(
ss
-
>
vrange
.
max
>
SSL_LIBRARY_VERSION_3_0
)
{
sender
=
clientHelloSendersTLS
;
}
else
{
sender
=
clientHelloSendersSSL3
;
}
break
;
case
ssl_hs_server_hello
:
sender
=
ss
-
>
xtnData
.
serverHelloSenders
;
break
;
case
ssl_hs_certificate_request
:
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
sender
=
tls13_cert_req_senders
;
break
;
case
ssl_hs_certificate
:
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
sender
=
ss
-
>
xtnData
.
certificateSenders
;
break
;
case
ssl_hs_encrypted_extensions
:
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
sender
=
ss
-
>
xtnData
.
encryptedExtensionsSenders
;
break
;
case
ssl_hs_hello_retry_request
:
PORT_Assert
(
ss
-
>
version
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
;
sender
=
tls13_hrr_senders
;
break
;
default
:
PORT_Assert
(
0
)
;
PORT_SetError
(
SEC_ERROR_LIBRARY_FAILURE
)
;
return
SECFailure
;
}
for
(
;
sender
-
>
ex_sender
!
=
NULL
;
+
+
sender
)
{
PRBool
append
=
PR_FALSE
;
unsigned
int
start
=
buf
-
>
len
;
unsigned
int
length
;
if
(
ssl_FindCustomExtensionHooks
(
ss
sender
-
>
ex_type
)
)
{
continue
;
}
buf
-
>
len
+
=
4
;
rv
=
(
*
sender
-
>
ex_sender
)
(
ss
&
ss
-
>
xtnData
buf
&
append
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
length
=
buf
-
>
len
-
start
-
4
;
buf
-
>
len
=
start
;
if
(
!
append
)
{
continue
;
}
buf
-
>
len
=
start
;
rv
=
sslBuffer_AppendNumber
(
buf
sender
-
>
ex_type
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
rv
=
sslBuffer_AppendNumber
(
buf
length
2
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
buf
-
>
len
+
=
length
;
if
(
message
=
=
ssl_hs_client_hello
|
|
message
=
=
ssl_hs_certificate_request
)
{
ss
-
>
xtnData
.
advertised
[
ss
-
>
xtnData
.
numAdvertised
+
+
]
=
sender
-
>
ex_type
;
}
}
if
(
!
PR_CLIST_IS_EMPTY
(
&
ss
-
>
extensionHooks
)
)
{
rv
=
ssl_CallCustomExtensionSenders
(
ss
buf
message
)
;
if
(
rv
!
=
SECSuccess
)
{
goto
loser
;
}
}
if
(
buf
-
>
len
>
0xffff
)
{
PORT_SetError
(
SSL_ERROR_TX_RECORD_TOO_LONG
)
;
goto
loser
;
}
return
SECSuccess
;
loser
:
sslBuffer_Clear
(
buf
)
;
return
SECFailure
;
}
SECStatus
ssl_SendEmptyExtension
(
const
sslSocket
*
ss
TLSExtensionData
*
xtnData
sslBuffer
*
buf
PRBool
*
append
)
{
*
append
=
PR_TRUE
;
return
SECSuccess
;
}
static
unsigned
int
ssl_CalculatePaddingExtLen
(
const
sslSocket
*
ss
unsigned
int
clientHelloLength
)
{
unsigned
int
recordLength
=
1
+
3
+
clientHelloLength
;
unsigned
int
extensionLen
;
if
(
IS_DTLS
(
ss
)
|
|
ss
-
>
vrange
.
max
<
SSL_LIBRARY_VERSION_TLS_1_0
|
|
ss
-
>
firstHsDone
)
{
return
0
;
}
if
(
recordLength
<
256
|
|
recordLength
>
=
512
)
{
return
0
;
}
extensionLen
=
512
-
recordLength
;
if
(
extensionLen
<
5
)
{
extensionLen
=
5
;
}
return
extensionLen
-
4
;
}
SECStatus
ssl_InsertPaddingExtension
(
const
sslSocket
*
ss
unsigned
int
prefixLen
sslBuffer
*
buf
)
{
static
unsigned
char
padding
[
252
]
=
{
0
}
;
unsigned
int
paddingLen
;
unsigned
int
tailLen
;
SECStatus
rv
;
paddingLen
=
ssl_CalculatePaddingExtLen
(
ss
prefixLen
+
2
+
buf
-
>
len
)
;
if
(
!
paddingLen
)
{
return
SECSuccess
;
}
if
(
ss
-
>
xtnData
.
lastXtnOffset
)
{
PORT_Assert
(
buf
-
>
len
>
ss
-
>
xtnData
.
lastXtnOffset
)
;
tailLen
=
buf
-
>
len
-
ss
-
>
xtnData
.
lastXtnOffset
;
rv
=
sslBuffer_Grow
(
buf
buf
-
>
len
+
4
+
paddingLen
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
PORT_Memmove
(
buf
-
>
buf
+
ss
-
>
xtnData
.
lastXtnOffset
+
4
+
paddingLen
buf
-
>
buf
+
ss
-
>
xtnData
.
lastXtnOffset
tailLen
)
;
buf
-
>
len
=
ss
-
>
xtnData
.
lastXtnOffset
;
}
else
{
tailLen
=
0
;
}
rv
=
sslBuffer_AppendNumber
(
buf
ssl_padding_xtn
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
rv
=
sslBuffer_AppendVariable
(
buf
padding
paddingLen
2
)
;
if
(
rv
!
=
SECSuccess
)
{
return
SECFailure
;
}
buf
-
>
len
+
=
tailLen
;
return
SECSuccess
;
}
void
ssl3_DestroyRemoteExtensions
(
PRCList
*
list
)
{
PRCList
*
cur_p
;
while
(
!
PR_CLIST_IS_EMPTY
(
list
)
)
{
cur_p
=
PR_LIST_TAIL
(
list
)
;
PR_REMOVE_LINK
(
cur_p
)
;
PORT_Free
(
cur_p
)
;
}
}
void
ssl3_InitExtensionData
(
TLSExtensionData
*
xtnData
const
sslSocket
*
ss
)
{
unsigned
int
advertisedMax
;
PRCList
*
cursor
;
PORT_Memset
(
xtnData
0
sizeof
(
*
xtnData
)
)
;
xtnData
-
>
peerSupportsFfdheGroups
=
PR_FALSE
;
PR_INIT_CLIST
(
&
xtnData
-
>
remoteKeyShares
)
;
if
(
ss
-
>
sec
.
isServer
)
{
advertisedMax
=
PR_MAX
(
PR_ARRAY_SIZE
(
certificateRequestHandlers
)
PR_ARRAY_SIZE
(
tls13_cert_req_senders
)
)
;
}
else
{
advertisedMax
=
PR_MAX
(
PR_ARRAY_SIZE
(
clientHelloHandlers
)
PR_ARRAY_SIZE
(
clientHelloSendersTLS
)
)
;
+
+
advertisedMax
;
}
for
(
cursor
=
PR_NEXT_LINK
(
&
ss
-
>
extensionHooks
)
;
cursor
!
=
&
ss
-
>
extensionHooks
;
cursor
=
PR_NEXT_LINK
(
cursor
)
)
{
+
+
advertisedMax
;
}
xtnData
-
>
advertised
=
PORT_ZNewArray
(
PRUint16
advertisedMax
)
;
}
void
ssl3_DestroyExtensionData
(
TLSExtensionData
*
xtnData
)
{
ssl3_FreeSniNameArray
(
xtnData
)
;
PORT_Free
(
xtnData
-
>
sigSchemes
)
;
SECITEM_FreeItem
(
&
xtnData
-
>
nextProto
PR_FALSE
)
;
tls13_DestroyKeyShares
(
&
xtnData
-
>
remoteKeyShares
)
;
SECITEM_FreeItem
(
&
xtnData
-
>
certReqContext
PR_FALSE
)
;
SECITEM_FreeItem
(
&
xtnData
-
>
applicationToken
PR_FALSE
)
;
if
(
xtnData
-
>
certReqAuthorities
.
arena
)
{
PORT_FreeArena
(
xtnData
-
>
certReqAuthorities
.
arena
PR_FALSE
)
;
xtnData
-
>
certReqAuthorities
.
arena
=
NULL
;
}
PORT_Free
(
xtnData
-
>
advertised
)
;
}
void
ssl3_ResetExtensionData
(
TLSExtensionData
*
xtnData
const
sslSocket
*
ss
)
{
ssl3_DestroyExtensionData
(
xtnData
)
;
ssl3_InitExtensionData
(
xtnData
ss
)
;
}
void
ssl3_ExtSendAlert
(
const
sslSocket
*
ss
SSL3AlertLevel
level
SSL3AlertDescription
desc
)
{
(
void
)
SSL3_SendAlert
(
(
sslSocket
*
)
ss
level
desc
)
;
}
void
ssl3_ExtDecodeError
(
const
sslSocket
*
ss
)
{
(
void
)
ssl3_DecodeError
(
(
sslSocket
*
)
ss
)
;
}
SECStatus
ssl3_ExtConsumeHandshake
(
const
sslSocket
*
ss
void
*
v
PRUint32
bytes
PRUint8
*
*
b
PRUint32
*
length
)
{
return
ssl3_ConsumeHandshake
(
(
sslSocket
*
)
ss
v
bytes
b
length
)
;
}
SECStatus
ssl3_ExtConsumeHandshakeNumber
(
const
sslSocket
*
ss
PRUint32
*
num
PRUint32
bytes
PRUint8
*
*
b
PRUint32
*
length
)
{
return
ssl3_ConsumeHandshakeNumber
(
(
sslSocket
*
)
ss
num
bytes
b
length
)
;
}
SECStatus
ssl3_ExtConsumeHandshakeVariable
(
const
sslSocket
*
ss
SECItem
*
i
PRUint32
bytes
PRUint8
*
*
b
PRUint32
*
length
)
{
return
ssl3_ConsumeHandshakeVariable
(
(
sslSocket
*
)
ss
i
bytes
b
length
)
;
}
