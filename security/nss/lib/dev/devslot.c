#
include
"
pkcs11
.
h
"
#
ifndef
DEVM_H
#
include
"
devm
.
h
"
#
endif
#
ifndef
CKHELPER_H
#
include
"
ckhelper
.
h
"
#
endif
#
include
"
pk11pub
.
h
"
#
define
NSSSLOT_TOKEN_DELAY_TIME
1
#
define
NSSSLOT_IS_FRIENDLY
(
slot
)
\
(
slot
-
>
base
.
flags
&
NSSSLOT_FLAGS_FRIENDLY
)
static
PRIntervalTime
s_token_delay_time
=
0
;
NSS_IMPLEMENT
PRStatus
nssSlot_Destroy
(
NSSSlot
*
slot
)
{
if
(
slot
)
{
if
(
PR_ATOMIC_DECREMENT
(
&
slot
-
>
base
.
refCount
)
=
=
0
)
{
PK11_FreeSlot
(
slot
-
>
pk11slot
)
;
PZ_DestroyLock
(
slot
-
>
base
.
lock
)
;
PZ_DestroyCondVar
(
slot
-
>
isPresentCondition
)
;
PZ_DestroyLock
(
slot
-
>
isPresentLock
)
;
return
nssArena_Destroy
(
slot
-
>
base
.
arena
)
;
}
}
return
PR_SUCCESS
;
}
void
nssSlot_EnterMonitor
(
NSSSlot
*
slot
)
{
if
(
slot
-
>
lock
)
{
PZ_Lock
(
slot
-
>
lock
)
;
}
}
void
nssSlot_ExitMonitor
(
NSSSlot
*
slot
)
{
if
(
slot
-
>
lock
)
{
PZ_Unlock
(
slot
-
>
lock
)
;
}
}
NSS_IMPLEMENT
void
NSSSlot_Destroy
(
NSSSlot
*
slot
)
{
(
void
)
nssSlot_Destroy
(
slot
)
;
}
NSS_IMPLEMENT
NSSSlot
*
nssSlot_AddRef
(
NSSSlot
*
slot
)
{
PR_ATOMIC_INCREMENT
(
&
slot
-
>
base
.
refCount
)
;
return
slot
;
}
NSS_IMPLEMENT
NSSUTF8
*
nssSlot_GetName
(
NSSSlot
*
slot
)
{
return
slot
-
>
base
.
name
;
}
NSS_IMPLEMENT
NSSUTF8
*
nssSlot_GetTokenName
(
NSSSlot
*
slot
)
{
return
nssToken_GetName
(
slot
-
>
token
)
;
}
NSS_IMPLEMENT
void
nssSlot_ResetDelay
(
NSSSlot
*
slot
)
{
PZ_Lock
(
slot
-
>
isPresentLock
)
;
slot
-
>
lastTokenPingState
=
nssSlotLastPingState_Reset
;
PZ_Unlock
(
slot
-
>
isPresentLock
)
;
}
static
PRBool
token_status_checked
(
const
NSSSlot
*
slot
)
{
PRIntervalTime
time
;
int
lastPingState
=
slot
-
>
lastTokenPingState
;
if
(
slot
-
>
isPresentThread
=
=
PR_GetCurrentThread
(
)
)
{
return
PR_TRUE
;
}
if
(
s_token_delay_time
=
=
0
)
{
s_token_delay_time
=
PR_SecondsToInterval
(
NSSSLOT_TOKEN_DELAY_TIME
)
;
}
time
=
PR_IntervalNow
(
)
;
if
(
(
lastPingState
=
=
nssSlotLastPingState_Valid
)
&
&
(
(
time
-
slot
-
>
lastTokenPingTime
)
<
s_token_delay_time
)
)
{
return
PR_TRUE
;
}
return
PR_FALSE
;
}
NSS_IMPLEMENT
PRBool
nssSlot_IsTokenPresent
(
NSSSlot
*
slot
)
{
CK_RV
ckrv
;
PRStatus
nssrv
;
nssSession
*
session
;
CK_SLOT_INFO
slotInfo
;
void
*
epv
;
PRBool
isPresent
=
PR_FALSE
;
if
(
nssSlot_IsPermanent
(
slot
)
)
{
return
!
PK11_IsDisabled
(
slot
-
>
pk11slot
)
;
}
PZ_Lock
(
slot
-
>
isPresentLock
)
;
if
(
token_status_checked
(
slot
)
)
{
CK_FLAGS
ckFlags
=
slot
-
>
ckFlags
;
PZ_Unlock
(
slot
-
>
isPresentLock
)
;
return
(
(
ckFlags
&
CKF_TOKEN_PRESENT
)
!
=
0
)
;
}
PZ_Unlock
(
slot
-
>
isPresentLock
)
;
epv
=
slot
-
>
epv
;
if
(
!
epv
)
{
return
PR_FALSE
;
}
PZ_Lock
(
slot
-
>
isPresentLock
)
;
while
(
slot
-
>
isPresentThread
)
{
PR_WaitCondVar
(
slot
-
>
isPresentCondition
PR_INTERVAL_NO_TIMEOUT
)
;
}
if
(
token_status_checked
(
slot
)
)
{
CK_FLAGS
ckFlags
=
slot
-
>
ckFlags
;
PZ_Unlock
(
slot
-
>
isPresentLock
)
;
return
(
(
ckFlags
&
CKF_TOKEN_PRESENT
)
!
=
0
)
;
}
slot
-
>
lastTokenPingState
=
nssSlotLastPingState_Update
;
slot
-
>
isPresentThread
=
PR_GetCurrentThread
(
)
;
PZ_Unlock
(
slot
-
>
isPresentLock
)
;
nssSlot_EnterMonitor
(
slot
)
;
ckrv
=
CKAPI
(
epv
)
-
>
C_GetSlotInfo
(
slot
-
>
slotID
&
slotInfo
)
;
nssSlot_ExitMonitor
(
slot
)
;
if
(
ckrv
!
=
CKR_OK
)
{
slot
-
>
token
-
>
base
.
name
[
0
]
=
0
;
isPresent
=
PR_FALSE
;
goto
done
;
}
slot
-
>
ckFlags
=
slotInfo
.
flags
;
if
(
(
slot
-
>
ckFlags
&
CKF_TOKEN_PRESENT
)
=
=
0
)
{
if
(
!
slot
-
>
token
)
{
isPresent
=
PR_FALSE
;
goto
done
;
}
session
=
nssToken_GetDefaultSession
(
slot
-
>
token
)
;
if
(
session
)
{
nssSession_EnterMonitor
(
session
)
;
if
(
session
-
>
handle
!
=
CK_INVALID_SESSION
)
{
CKAPI
(
epv
)
-
>
C_CloseSession
(
session
-
>
handle
)
;
session
-
>
handle
=
CK_INVALID_SESSION
;
}
nssSession_ExitMonitor
(
session
)
;
}
if
(
slot
-
>
token
-
>
base
.
name
[
0
]
!
=
0
)
{
slot
-
>
token
-
>
base
.
name
[
0
]
=
0
;
nssToken_NotifyCertsNotVisible
(
slot
-
>
token
)
;
}
slot
-
>
token
-
>
base
.
name
[
0
]
=
0
;
nssToken_Remove
(
slot
-
>
token
)
;
isPresent
=
PR_FALSE
;
goto
done
;
}
session
=
nssToken_GetDefaultSession
(
slot
-
>
token
)
;
if
(
session
)
{
PRBool
tokenRemoved
;
nssSession_EnterMonitor
(
session
)
;
if
(
session
-
>
handle
!
=
CK_INVALID_SESSION
)
{
CK_SESSION_INFO
sessionInfo
;
ckrv
=
CKAPI
(
epv
)
-
>
C_GetSessionInfo
(
session
-
>
handle
&
sessionInfo
)
;
if
(
ckrv
!
=
CKR_OK
)
{
CKAPI
(
epv
)
-
>
C_CloseSession
(
session
-
>
handle
)
;
session
-
>
handle
=
CK_INVALID_SESSION
;
}
}
tokenRemoved
=
(
session
-
>
handle
=
=
CK_INVALID_SESSION
)
;
nssSession_ExitMonitor
(
session
)
;
if
(
!
tokenRemoved
)
{
isPresent
=
PR_TRUE
;
goto
done
;
}
}
nssToken_NotifyCertsNotVisible
(
slot
-
>
token
)
;
nssToken_Remove
(
slot
-
>
token
)
;
nssrv
=
nssSlot_Refresh
(
slot
)
;
isPresent
=
PR_TRUE
;
if
(
nssrv
!
=
PR_SUCCESS
)
{
slot
-
>
token
-
>
base
.
name
[
0
]
=
0
;
slot
-
>
ckFlags
&
=
~
CKF_TOKEN_PRESENT
;
isPresent
=
PR_FALSE
;
}
done
:
PZ_Lock
(
slot
-
>
isPresentLock
)
;
if
(
slot
-
>
lastTokenPingState
=
=
nssSlotLastPingState_Update
)
{
slot
-
>
lastTokenPingTime
=
PR_IntervalNow
(
)
;
slot
-
>
lastTokenPingState
=
nssSlotLastPingState_Valid
;
}
slot
-
>
isPresentThread
=
NULL
;
PR_NotifyAllCondVar
(
slot
-
>
isPresentCondition
)
;
PZ_Unlock
(
slot
-
>
isPresentLock
)
;
return
isPresent
;
}
NSS_IMPLEMENT
void
*
nssSlot_GetCryptokiEPV
(
NSSSlot
*
slot
)
{
return
slot
-
>
epv
;
}
NSS_IMPLEMENT
NSSToken
*
nssSlot_GetToken
(
NSSSlot
*
slot
)
{
NSSToken
*
rvToken
=
NULL
;
if
(
nssSlot_IsTokenPresent
(
slot
)
)
{
nssSlot_EnterMonitor
(
slot
)
;
if
(
slot
-
>
token
)
rvToken
=
nssToken_AddRef
(
slot
-
>
token
)
;
nssSlot_ExitMonitor
(
slot
)
;
}
return
rvToken
;
}
NSS_IMPLEMENT
PRStatus
nssSession_EnterMonitor
(
nssSession
*
s
)
{
if
(
s
-
>
lock
)
PZ_Lock
(
s
-
>
lock
)
;
return
PR_SUCCESS
;
}
NSS_IMPLEMENT
PRStatus
nssSession_ExitMonitor
(
nssSession
*
s
)
{
return
(
s
-
>
lock
)
?
PZ_Unlock
(
s
-
>
lock
)
:
PR_SUCCESS
;
}
NSS_EXTERN
PRBool
nssSession_IsReadWrite
(
nssSession
*
s
)
{
return
s
-
>
isRW
;
}
