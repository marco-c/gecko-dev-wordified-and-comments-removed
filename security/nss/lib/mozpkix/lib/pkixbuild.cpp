#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixcheck
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
namespace
mozilla
{
namespace
pkix
{
static
Result
BuildForward
(
TrustDomain
&
trustDomain
const
BackCert
&
subject
Time
time
KeyUsage
requiredKeyUsageIfPresent
KeyPurposeId
requiredEKUIfPresent
const
CertPolicyId
&
requiredPolicy
const
Input
*
stapledOCSPResponse
unsigned
int
subCACount
unsigned
int
&
buildForwardCallBudget
)
;
TrustDomain
:
:
IssuerChecker
:
:
IssuerChecker
(
)
{
}
TrustDomain
:
:
IssuerChecker
:
:
~
IssuerChecker
(
)
{
}
class
PathBuildingStep
final
:
public
TrustDomain
:
:
IssuerChecker
{
public
:
PathBuildingStep
(
TrustDomain
&
aTrustDomain
const
BackCert
&
aSubject
Time
aTime
KeyPurposeId
aRequiredEKUIfPresent
const
CertPolicyId
&
aRequiredPolicy
const
Input
*
aStapledOCSPResponse
unsigned
int
aSubCACount
Result
aDeferredSubjectError
unsigned
int
&
aBuildForwardCallBudget
)
:
trustDomain
(
aTrustDomain
)
subject
(
aSubject
)
time
(
aTime
)
requiredEKUIfPresent
(
aRequiredEKUIfPresent
)
requiredPolicy
(
aRequiredPolicy
)
stapledOCSPResponse
(
aStapledOCSPResponse
)
subCACount
(
aSubCACount
)
deferredSubjectError
(
aDeferredSubjectError
)
result
(
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
)
resultWasSet
(
false
)
buildForwardCallBudget
(
aBuildForwardCallBudget
)
{
}
Result
Check
(
Input
potentialIssuerDER
const
Input
*
additionalNameConstraints
bool
&
keepGoing
)
override
;
Result
CheckResult
(
)
const
;
private
:
TrustDomain
&
trustDomain
;
const
BackCert
&
subject
;
const
Time
time
;
const
KeyPurposeId
requiredEKUIfPresent
;
const
CertPolicyId
&
requiredPolicy
;
Input
const
*
const
stapledOCSPResponse
;
const
unsigned
int
subCACount
;
const
Result
deferredSubjectError
;
Result
RecordResult
(
Result
currentResult
bool
&
keepGoing
)
;
Result
result
;
bool
resultWasSet
;
unsigned
int
&
buildForwardCallBudget
;
PathBuildingStep
(
const
PathBuildingStep
&
)
=
delete
;
void
operator
=
(
const
PathBuildingStep
&
)
=
delete
;
}
;
Result
PathBuildingStep
:
:
RecordResult
(
Result
newResult
bool
&
keepGoing
)
{
if
(
newResult
=
=
Result
:
:
ERROR_UNTRUSTED_CERT
)
{
newResult
=
Result
:
:
ERROR_UNTRUSTED_ISSUER
;
}
else
if
(
newResult
=
=
Result
:
:
ERROR_EXPIRED_CERTIFICATE
)
{
newResult
=
Result
:
:
ERROR_EXPIRED_ISSUER_CERTIFICATE
;
}
else
if
(
newResult
=
=
Result
:
:
ERROR_NOT_YET_VALID_CERTIFICATE
)
{
newResult
=
Result
:
:
ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
;
}
if
(
resultWasSet
)
{
if
(
result
=
=
Success
)
{
return
NotReached
(
"
RecordResult
called
after
finding
a
chain
"
Result
:
:
FATAL_ERROR_INVALID_STATE
)
;
}
if
(
newResult
!
=
Success
&
&
newResult
!
=
result
)
{
newResult
=
Result
:
:
ERROR_UNKNOWN_ISSUER
;
}
}
result
=
newResult
;
resultWasSet
=
true
;
keepGoing
=
result
!
=
Success
;
return
Success
;
}
Result
PathBuildingStep
:
:
CheckResult
(
)
const
{
if
(
!
resultWasSet
)
{
return
Result
:
:
ERROR_UNKNOWN_ISSUER
;
}
return
result
;
}
Result
PathBuildingStep
:
:
Check
(
Input
potentialIssuerDER
const
Input
*
additionalNameConstraints
bool
&
keepGoing
)
{
BackCert
potentialIssuer
(
potentialIssuerDER
EndEntityOrCA
:
:
MustBeCA
&
subject
)
;
Result
rv
=
potentialIssuer
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
RecordResult
(
rv
keepGoing
)
;
}
if
(
!
InputsAreEqual
(
potentialIssuer
.
GetSubject
(
)
subject
.
GetIssuer
(
)
)
)
{
keepGoing
=
true
;
return
Success
;
}
for
(
const
BackCert
*
prev
=
potentialIssuer
.
childCert
;
prev
;
prev
=
prev
-
>
childCert
)
{
if
(
InputsAreEqual
(
potentialIssuer
.
GetSubjectPublicKeyInfo
(
)
prev
-
>
GetSubjectPublicKeyInfo
(
)
)
&
&
InputsAreEqual
(
potentialIssuer
.
GetSubject
(
)
prev
-
>
GetSubject
(
)
)
)
{
return
RecordResult
(
Result
:
:
ERROR_UNKNOWN_ISSUER
keepGoing
)
;
}
}
if
(
potentialIssuer
.
GetNameConstraints
(
)
)
{
rv
=
CheckNameConstraints
(
*
potentialIssuer
.
GetNameConstraints
(
)
subject
requiredEKUIfPresent
)
;
if
(
rv
!
=
Success
)
{
return
RecordResult
(
rv
keepGoing
)
;
}
}
if
(
additionalNameConstraints
)
{
rv
=
CheckNameConstraints
(
*
additionalNameConstraints
subject
requiredEKUIfPresent
)
;
if
(
rv
!
=
Success
)
{
return
RecordResult
(
rv
keepGoing
)
;
}
}
rv
=
CheckTLSFeatures
(
subject
potentialIssuer
)
;
if
(
rv
!
=
Success
)
{
return
RecordResult
(
rv
keepGoing
)
;
}
if
(
buildForwardCallBudget
=
=
0
)
{
Result
savedRv
=
RecordResult
(
Result
:
:
ERROR_UNKNOWN_ISSUER
keepGoing
)
;
keepGoing
=
false
;
return
savedRv
;
}
buildForwardCallBudget
-
-
;
rv
=
BuildForward
(
trustDomain
potentialIssuer
time
KeyUsage
:
:
keyCertSign
requiredEKUIfPresent
requiredPolicy
nullptr
subCACount
buildForwardCallBudget
)
;
if
(
rv
!
=
Success
)
{
return
RecordResult
(
rv
keepGoing
)
;
}
rv
=
VerifySignedData
(
trustDomain
subject
.
GetSignedData
(
)
potentialIssuer
.
GetSubjectPublicKeyInfo
(
)
)
;
if
(
rv
!
=
Success
)
{
return
RecordResult
(
rv
keepGoing
)
;
}
if
(
deferredSubjectError
!
=
Result
:
:
ERROR_EXPIRED_CERTIFICATE
)
{
CertID
certID
(
subject
.
GetIssuer
(
)
potentialIssuer
.
GetSubjectPublicKeyInfo
(
)
subject
.
GetSerialNumber
(
)
)
;
Time
notBefore
(
Time
:
:
uninitialized
)
;
Time
notAfter
(
Time
:
:
uninitialized
)
;
rv
=
ParseValidity
(
subject
.
GetValidity
(
)
&
notBefore
&
notAfter
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Duration
validityDuration
(
notAfter
notBefore
)
;
rv
=
trustDomain
.
CheckRevocation
(
subject
.
endEntityOrCA
certID
time
validityDuration
stapledOCSPResponse
subject
.
GetAuthorityInfoAccess
(
)
subject
.
GetSignedCertificateTimestamps
(
)
)
;
if
(
rv
!
=
Success
)
{
Result
savedRv
=
RecordResult
(
rv
keepGoing
)
;
keepGoing
=
false
;
return
savedRv
;
}
if
(
subject
.
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeEndEntity
)
{
const
Input
*
sctExtension
=
subject
.
GetSignedCertificateTimestamps
(
)
;
if
(
sctExtension
)
{
Input
sctList
;
rv
=
ExtractSignedCertificateTimestampListFromExtension
(
*
sctExtension
sctList
)
;
if
(
rv
!
=
Success
)
{
Result
savedRv
=
RecordResult
(
rv
keepGoing
)
;
keepGoing
=
false
;
return
savedRv
;
}
trustDomain
.
NoteAuxiliaryExtension
(
AuxiliaryExtension
:
:
EmbeddedSCTList
sctList
)
;
}
}
}
return
RecordResult
(
Success
keepGoing
)
;
}
static
Result
BuildForward
(
TrustDomain
&
trustDomain
const
BackCert
&
subject
Time
time
KeyUsage
requiredKeyUsageIfPresent
KeyPurposeId
requiredEKUIfPresent
const
CertPolicyId
&
requiredPolicy
const
Input
*
stapledOCSPResponse
unsigned
int
subCACount
unsigned
int
&
buildForwardCallBudget
)
{
Result
rv
;
TrustLevel
trustLevel
;
rv
=
CheckIssuerIndependentProperties
(
trustDomain
subject
time
requiredKeyUsageIfPresent
requiredEKUIfPresent
requiredPolicy
subCACount
trustLevel
)
;
Result
deferredEndEntityError
=
Success
;
if
(
rv
!
=
Success
)
{
if
(
subject
.
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeEndEntity
&
&
trustLevel
!
=
TrustLevel
:
:
TrustAnchor
)
{
deferredEndEntityError
=
rv
;
}
else
{
return
rv
;
}
}
if
(
trustLevel
=
=
TrustLevel
:
:
TrustAnchor
)
{
NonOwningDERArray
chain
;
for
(
const
BackCert
*
cert
=
&
subject
;
cert
;
cert
=
cert
-
>
childCert
)
{
rv
=
chain
.
Append
(
cert
-
>
GetDER
(
)
)
;
if
(
rv
!
=
Success
)
{
return
NotReached
(
"
NonOwningDERArray
:
:
SetItem
failed
.
"
rv
)
;
}
}
return
trustDomain
.
IsChainValid
(
chain
time
requiredPolicy
)
;
}
if
(
subject
.
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
)
{
static
const
unsigned
int
MAX_SUBCA_COUNT
=
6
;
static_assert
(
1
+
MAX_SUBCA_COUNT
+
1
=
=
NonOwningDERArray
:
:
MAX_LENGTH
"
MAX_SUBCA_COUNT
and
NonOwningDERArray
:
:
MAX_LENGTH
mismatch
.
"
)
;
if
(
subCACount
>
=
MAX_SUBCA_COUNT
)
{
return
Result
:
:
ERROR_UNKNOWN_ISSUER
;
}
+
+
subCACount
;
}
else
{
assert
(
subCACount
=
=
0
)
;
}
PathBuildingStep
pathBuilder
(
trustDomain
subject
time
requiredEKUIfPresent
requiredPolicy
stapledOCSPResponse
subCACount
deferredEndEntityError
buildForwardCallBudget
)
;
rv
=
trustDomain
.
FindIssuer
(
subject
.
GetIssuer
(
)
pathBuilder
time
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
pathBuilder
.
CheckResult
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
deferredEndEntityError
!
=
Success
)
{
return
deferredEndEntityError
;
}
return
Success
;
}
Result
BuildCertChain
(
TrustDomain
&
trustDomain
Input
certDER
Time
time
EndEntityOrCA
endEntityOrCA
KeyUsage
requiredKeyUsageIfPresent
KeyPurposeId
requiredEKUIfPresent
const
CertPolicyId
&
requiredPolicy
const
Input
*
stapledOCSPResponse
)
{
BackCert
cert
(
certDER
endEntityOrCA
nullptr
)
;
Result
rv
=
cert
.
Init
(
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
unsigned
int
buildForwardCallBudget
=
200000
;
return
BuildForward
(
trustDomain
cert
time
requiredKeyUsageIfPresent
requiredEKUIfPresent
requiredPolicy
stapledOCSPResponse
0
buildForwardCallBudget
)
;
}
}
}
