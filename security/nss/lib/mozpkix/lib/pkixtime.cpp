#
include
"
mozpkix
/
Time
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
ifdef
_WINDOWS
#
ifdef
_MSC_VER
#
pragma
warning
(
push
3
)
#
endif
#
include
"
windows
.
h
"
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
#
else
#
include
"
sys
/
time
.
h
"
#
endif
namespace
mozilla
{
namespace
pkix
{
Time
Now
(
)
{
uint64_t
seconds
;
#
ifdef
_WINDOWS
FILETIME
ft
;
GetSystemTimeAsFileTime
(
&
ft
)
;
uint64_t
ft64
=
(
static_cast
<
uint64_t
>
(
ft
.
dwHighDateTime
)
<
<
32
)
|
ft
.
dwLowDateTime
;
seconds
=
(
DaysBeforeYear
(
1601
)
*
Time
:
:
ONE_DAY_IN_SECONDS
)
+
ft64
/
(
1000u
*
1000u
*
1000u
/
100u
)
;
#
else
timeval
tv
;
(
void
)
gettimeofday
(
&
tv
nullptr
)
;
seconds
=
(
DaysBeforeYear
(
1970
)
*
Time
:
:
ONE_DAY_IN_SECONDS
)
+
static_cast
<
uint64_t
>
(
tv
.
tv_sec
)
;
#
endif
return
TimeFromElapsedSecondsAD
(
seconds
)
;
}
Time
TimeFromEpochInSeconds
(
uint64_t
secondsSinceEpoch
)
{
uint64_t
seconds
=
(
DaysBeforeYear
(
1970
)
*
Time
:
:
ONE_DAY_IN_SECONDS
)
+
secondsSinceEpoch
;
return
TimeFromElapsedSecondsAD
(
seconds
)
;
}
Result
SecondsSinceEpochFromTime
(
Time
time
uint64_t
*
outSeconds
)
{
if
(
!
outSeconds
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
Time
epoch
=
TimeFromEpochInSeconds
(
0
)
;
if
(
time
<
epoch
)
{
return
Result
:
:
FATAL_ERROR_INVALID_ARGS
;
}
*
outSeconds
=
Duration
(
time
epoch
)
.
durationInSeconds
;
return
Result
:
:
Success
;
}
}
}
