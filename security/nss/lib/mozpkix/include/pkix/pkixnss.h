#
ifndef
mozilla_pkix_pkixnss_h
#
define
mozilla_pkix_pkixnss_h
#
include
<
seccomon
.
h
>
#
include
"
mozpkix
/
pkixtypes
.
h
"
#
include
"
prerror
.
h
"
namespace
mozilla
{
namespace
pkix
{
Result
VerifyRSAPKCS1SignedDataNSS
(
Input
data
DigestAlgorithm
digestAlgorithm
Input
signature
Input
subjectPublicKeyInfo
void
*
pkcs11PinArg
)
;
Result
VerifyRSAPSSSignedDataNSS
(
Input
data
DigestAlgorithm
digestAlgorithm
Input
signature
Input
subjectPublicKeyInfo
void
*
pkcs11PinArg
)
;
Result
VerifyECDSASignedDataNSS
(
Input
data
DigestAlgorithm
digestAlgorithm
Input
signature
Input
subjectPublicKeyInfo
void
*
pkcs11PinArg
)
;
Result
DigestBufNSS
(
Input
item
DigestAlgorithm
digestAlg
uint8_t
*
digestBuf
size_t
digestBufLen
)
;
Result
MapPRErrorCodeToResult
(
PRErrorCode
errorCode
)
;
PRErrorCode
MapResultToPRErrorCode
(
Result
result
)
;
static
const
PRErrorCode
ERROR_BASE
=
-
0x4000
;
static
const
PRErrorCode
ERROR_LIMIT
=
ERROR_BASE
+
1000
;
enum
ErrorCode
{
MOZILLA_PKIX_ERROR_KEY_PINNING_FAILURE
=
ERROR_BASE
+
0
MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY
=
ERROR_BASE
+
1
MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE
=
ERROR_BASE
+
2
MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA
=
ERROR_BASE
+
3
MOZILLA_PKIX_ERROR_NO_RFC822NAME_MATCH
=
ERROR_BASE
+
4
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
=
ERROR_BASE
+
5
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
=
ERROR_BASE
+
6
MOZILLA_PKIX_ERROR_SIGNATURE_ALGORITHM_MISMATCH
=
ERROR_BASE
+
7
MOZILLA_PKIX_ERROR_OCSP_RESPONSE_FOR_CERT_MISSING
=
ERROR_BASE
+
8
MOZILLA_PKIX_ERROR_VALIDITY_TOO_LONG
=
ERROR_BASE
+
9
MOZILLA_PKIX_ERROR_REQUIRED_TLS_FEATURE_MISSING
=
ERROR_BASE
+
10
MOZILLA_PKIX_ERROR_INVALID_INTEGER_ENCODING
=
ERROR_BASE
+
11
MOZILLA_PKIX_ERROR_EMPTY_ISSUER_NAME
=
ERROR_BASE
+
12
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
=
ERROR_BASE
+
13
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
=
ERROR_BASE
+
14
MOZILLA_PKIX_ERROR_MITM_DETECTED
=
ERROR_BASE
+
15
END_OF_LIST
}
;
void
RegisterErrorTable
(
)
;
inline
SECItem
UnsafeMapInputToSECItem
(
Input
input
)
{
SECItem
result
=
{
siBuffer
const_cast
<
uint8_t
*
>
(
input
.
UnsafeGetData
(
)
)
input
.
GetLength
(
)
}
;
static_assert
(
sizeof
(
decltype
(
input
.
GetLength
(
)
)
)
<
=
sizeof
(
result
.
len
)
"
input
.
GetLength
(
)
must
fit
in
a
SECItem
"
)
;
return
result
;
}
}
}
#
endif
