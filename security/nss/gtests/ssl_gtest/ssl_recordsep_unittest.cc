#
include
"
secerr
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslerr
.
h
"
#
include
"
sslproto
.
h
"
extern
"
C
"
{
#
include
"
libssl_internals
.
h
"
}
#
include
<
queue
>
#
include
"
gtest_utils
.
h
"
#
include
"
nss_scoped_ptrs
.
h
"
#
include
"
tls_connect
.
h
"
#
include
"
tls_filter
.
h
"
#
include
"
tls_parser
.
h
"
namespace
nss_test
{
class
HandshakeSecretTracker
{
public
:
HandshakeSecretTracker
(
const
std
:
:
shared_ptr
<
TlsAgent
>
&
agent
uint16_t
first_read_epoch
uint16_t
first_write_epoch
)
:
agent_
(
agent
)
next_read_epoch_
(
first_read_epoch
)
next_write_epoch_
(
first_write_epoch
)
{
EXPECT_EQ
(
SECSuccess
SSL_SecretCallback
(
agent_
-
>
ssl_fd
(
)
HandshakeSecretTracker
:
:
SecretCb
this
)
)
;
}
void
CheckComplete
(
)
const
{
EXPECT_EQ
(
0
next_read_epoch_
)
;
EXPECT_EQ
(
0
next_write_epoch_
)
;
}
private
:
static
void
SecretCb
(
PRFileDesc
*
fd
PRUint16
epoch
SSLSecretDirection
dir
PK11SymKey
*
secret
void
*
arg
)
{
HandshakeSecretTracker
*
t
=
reinterpret_cast
<
HandshakeSecretTracker
*
>
(
arg
)
;
t
-
>
SecretUpdated
(
epoch
dir
secret
)
;
}
void
SecretUpdated
(
PRUint16
epoch
SSLSecretDirection
dir
PK11SymKey
*
secret
)
{
if
(
g_ssl_gtest_verbose
)
{
std
:
:
cerr
<
<
agent_
-
>
role_str
(
)
<
<
"
:
secret
callback
for
"
<
<
dir
<
<
"
epoch
"
<
<
epoch
<
<
std
:
:
endl
;
}
EXPECT_TRUE
(
secret
)
;
uint16_t
*
p
;
if
(
dir
=
=
ssl_secret_read
)
{
p
=
&
next_read_epoch_
;
}
else
{
ASSERT_EQ
(
ssl_secret_write
dir
)
;
p
=
&
next_write_epoch_
;
}
EXPECT_EQ
(
*
p
epoch
)
;
switch
(
*
p
)
{
case
1
:
case
2
:
(
*
p
)
+
+
;
break
;
case
3
:
*
p
=
0
;
break
;
default
:
ADD_FAILURE
(
)
<
<
"
Unexpected
next
epoch
:
"
<
<
*
p
;
}
}
std
:
:
shared_ptr
<
TlsAgent
>
agent_
;
uint16_t
next_read_epoch_
;
uint16_t
next_write_epoch_
;
}
;
TEST_F
(
TlsConnectTest
HandshakeSecrets
)
{
ConfigureVersion
(
SSL_LIBRARY_VERSION_TLS_1_3
)
;
EnsureTlsSetup
(
)
;
HandshakeSecretTracker
c
(
client_
2
2
)
;
HandshakeSecretTracker
s
(
server_
2
2
)
;
Connect
(
)
;
SendReceive
(
)
;
c
.
CheckComplete
(
)
;
s
.
CheckComplete
(
)
;
}
TEST_F
(
TlsConnectTest
ZeroRttSecrets
)
{
SetupForZeroRtt
(
)
;
HandshakeSecretTracker
c
(
client_
2
1
)
;
HandshakeSecretTracker
s
(
server_
1
2
)
;
client_
-
>
Set0RttEnabled
(
true
)
;
server_
-
>
Set0RttEnabled
(
true
)
;
ExpectResumption
(
RESUME_TICKET
)
;
ZeroRttSendReceive
(
true
true
)
;
Handshake
(
)
;
ExpectEarlyDataAccepted
(
true
)
;
CheckConnected
(
)
;
SendReceive
(
)
;
c
.
CheckComplete
(
)
;
s
.
CheckComplete
(
)
;
}
class
KeyUpdateTracker
{
public
:
KeyUpdateTracker
(
const
std
:
:
shared_ptr
<
TlsAgent
>
&
agent
bool
expect_read_secret
)
:
agent_
(
agent
)
expect_read_secret_
(
expect_read_secret
)
called_
(
false
)
{
EXPECT_EQ
(
SECSuccess
SSL_SecretCallback
(
agent_
-
>
ssl_fd
(
)
KeyUpdateTracker
:
:
SecretCb
this
)
)
;
}
void
CheckCalled
(
)
const
{
EXPECT_TRUE
(
called_
)
;
}
private
:
static
void
SecretCb
(
PRFileDesc
*
fd
PRUint16
epoch
SSLSecretDirection
dir
PK11SymKey
*
secret
void
*
arg
)
{
KeyUpdateTracker
*
t
=
reinterpret_cast
<
KeyUpdateTracker
*
>
(
arg
)
;
t
-
>
SecretUpdated
(
epoch
dir
secret
)
;
}
void
SecretUpdated
(
PRUint16
epoch
SSLSecretDirection
dir
PK11SymKey
*
secret
)
{
EXPECT_EQ
(
4U
epoch
)
;
EXPECT_EQ
(
expect_read_secret_
dir
=
=
ssl_secret_read
)
;
EXPECT_TRUE
(
secret
)
;
called_
=
true
;
}
std
:
:
shared_ptr
<
TlsAgent
>
agent_
;
bool
expect_read_secret_
;
bool
called_
;
}
;
TEST_F
(
TlsConnectTest
KeyUpdateSecrets
)
{
ConfigureVersion
(
SSL_LIBRARY_VERSION_TLS_1_3
)
;
Connect
(
)
;
KeyUpdateTracker
c
(
client_
false
)
;
KeyUpdateTracker
s
(
server_
true
)
;
EXPECT_EQ
(
SECSuccess
SSL_KeyUpdate
(
client_
-
>
ssl_fd
(
)
PR_FALSE
)
)
;
SendReceive
(
50
)
;
SendReceive
(
60
)
;
CheckEpochs
(
4
3
)
;
c
.
CheckCalled
(
)
;
s
.
CheckCalled
(
)
;
}
class
BadPrSocket
:
public
DummyIOLayerMethods
{
public
:
BadPrSocket
(
std
:
:
shared_ptr
<
TlsAgent
>
&
agent
)
:
DummyIOLayerMethods
(
)
{
static
PRDescIdentity
bad_identity
=
PR_GetUniqueIdentity
(
"
bad
NSPR
id
"
)
;
fd_
=
DummyIOLayerMethods
:
:
CreateFD
(
bad_identity
this
)
;
dummy_layer_
=
PR_GetIdentitiesLayer
(
agent
-
>
ssl_fd
(
)
DummyPrSocket
:
:
LayerId
(
)
)
;
original_methods_
=
dummy_layer_
-
>
methods
;
original_secret_
=
dummy_layer_
-
>
secret
;
dummy_layer_
-
>
methods
=
fd_
-
>
methods
;
dummy_layer_
-
>
secret
=
reinterpret_cast
<
PRFilePrivate
*
>
(
this
)
;
}
virtual
~
BadPrSocket
(
)
{
dummy_layer_
-
>
methods
=
original_methods_
;
dummy_layer_
-
>
secret
=
original_secret_
;
}
private
:
ScopedPRFileDesc
fd_
;
PRFileDesc
*
dummy_layer_
;
const
PRIOMethods
*
original_methods_
;
PRFilePrivate
*
original_secret_
;
}
;
class
StagedRecords
{
public
:
StagedRecords
(
std
:
:
shared_ptr
<
TlsAgent
>
&
agent
)
:
agent_
(
agent
)
records_
(
)
{
EXPECT_EQ
(
SECSuccess
SSL_RecordLayerWriteCallback
(
agent_
-
>
ssl_fd
(
)
StagedRecords
:
:
StageRecordData
this
)
)
;
}
virtual
~
StagedRecords
(
)
{
EXPECT_EQ
(
SECSuccess
SSL_RecordLayerWriteCallback
(
agent_
-
>
ssl_fd
(
)
nullptr
nullptr
)
)
;
}
bool
empty
(
)
const
{
return
records_
.
empty
(
)
;
}
void
ForwardAll
(
std
:
:
shared_ptr
<
TlsAgent
>
&
peer
)
{
EXPECT_NE
(
agent_
peer
)
<
<
"
can
'
t
forward
to
self
"
;
for
(
auto
r
:
records_
)
{
r
.
Forward
(
peer
)
;
}
records_
.
clear
(
)
;
}
void
ForwardAll
(
std
:
:
shared_ptr
<
TlsAgent
>
&
peer
TlsAgent
:
:
State
expected_state
)
{
ForwardAll
(
peer
)
;
peer
-
>
Handshake
(
)
;
EXPECT_EQ
(
expected_state
peer
-
>
state
(
)
)
;
}
void
ForwardPartial
(
std
:
:
shared_ptr
<
TlsAgent
>
&
peer
)
{
if
(
records_
.
empty
(
)
)
{
ADD_FAILURE
(
)
<
<
"
No
records
to
slice
"
;
return
;
}
auto
&
last
=
records_
.
back
(
)
;
auto
tail
=
last
.
SliceTail
(
)
;
ForwardAll
(
peer
TlsAgent
:
:
STATE_CONNECTING
)
;
records_
.
push_back
(
tail
)
;
EXPECT_EQ
(
TlsAgent
:
:
STATE_CONNECTING
peer
-
>
state
(
)
)
;
}
private
:
class
StagedRecord
{
public
:
StagedRecord
(
const
std
:
:
string
role
uint16_t
epoch
SSLContentType
ct
const
uint8_t
*
data
size_t
len
)
:
role_
(
role
)
epoch_
(
epoch
)
content_type_
(
ct
)
data_
(
data
len
)
{
if
(
g_ssl_gtest_verbose
)
{
std
:
:
cerr
<
<
role_
<
<
"
:
staged
epoch
"
<
<
epoch_
<
<
"
"
<
<
content_type_
<
<
"
:
"
<
<
data_
<
<
std
:
:
endl
;
}
}
void
Forward
(
std
:
:
shared_ptr
<
TlsAgent
>
&
peer
)
{
EXPECT_FALSE
(
data_
.
empty
(
)
)
;
if
(
g_ssl_gtest_verbose
)
{
std
:
:
cerr
<
<
role_
<
<
"
:
forward
"
<
<
data_
<
<
std
:
:
endl
;
}
SECStatus
rv
=
SSL_RecordLayerData
(
peer
-
>
ssl_fd
(
)
epoch_
content_type_
data_
.
data
(
)
static_cast
<
unsigned
int
>
(
data_
.
len
(
)
)
)
;
if
(
rv
!
=
SECSuccess
)
{
EXPECT_EQ
(
PR_WOULD_BLOCK_ERROR
PORT_GetError
(
)
)
;
}
}
StagedRecord
SliceTail
(
)
{
size_t
slice
=
1
;
if
(
data_
.
len
(
)
<
=
slice
)
{
ADD_FAILURE
(
)
<
<
"
record
too
small
to
slice
in
two
"
;
slice
=
0
;
}
size_t
keep
=
data_
.
len
(
)
-
slice
;
StagedRecord
tail
(
role_
epoch_
content_type_
data_
.
data
(
)
+
keep
slice
)
;
data_
.
Truncate
(
keep
)
;
return
tail
;
}
private
:
std
:
:
string
role_
;
uint16_t
epoch_
;
SSLContentType
content_type_
;
DataBuffer
data_
;
}
;
static
SECStatus
StageRecordData
(
PRFileDesc
*
fd
PRUint16
epoch
SSLContentType
content_type
const
PRUint8
*
data
unsigned
int
len
void
*
arg
)
{
auto
stage
=
reinterpret_cast
<
StagedRecords
*
>
(
arg
)
;
stage
-
>
records_
.
push_back
(
StagedRecord
(
stage
-
>
agent_
-
>
role_str
(
)
epoch
content_type
data
static_cast
<
size_t
>
(
len
)
)
)
;
return
SECSuccess
;
}
std
:
:
shared_ptr
<
TlsAgent
>
&
agent_
;
std
:
:
deque
<
StagedRecord
>
records_
;
}
;
static
void
RefuseApplicationData
(
std
:
:
shared_ptr
<
TlsAgent
>
&
peer
uint16_t
epoch
)
{
static
const
uint8_t
d
[
]
=
{
1
2
3
}
;
EXPECT_EQ
(
SECFailure
SSL_RecordLayerData
(
peer
-
>
ssl_fd
(
)
epoch
ssl_ct_application_data
d
static_cast
<
unsigned
int
>
(
sizeof
(
d
)
)
)
)
;
EXPECT_EQ
(
SEC_ERROR_INVALID_ARGS
PORT_GetError
(
)
)
;
}
static
void
SendForwardReceive
(
std
:
:
shared_ptr
<
TlsAgent
>
&
sender
StagedRecords
&
sender_stage
std
:
:
shared_ptr
<
TlsAgent
>
&
receiver
)
{
const
size_t
count
=
10
;
sender
-
>
SendData
(
count
count
)
;
sender_stage
.
ForwardAll
(
receiver
)
;
receiver
-
>
ReadBytes
(
count
)
;
}
TEST_P
(
TlsConnectStream
ReplaceRecordLayer
)
{
StartConnect
(
)
;
client_
-
>
SetServerKeyBits
(
server_
-
>
server_key_bits
(
)
)
;
BadPrSocket
bad_layer_client
(
client_
)
;
BadPrSocket
bad_layer_server
(
server_
)
;
StagedRecords
client_stage
(
client_
)
;
StagedRecords
server_stage
(
server_
)
;
RefuseApplicationData
(
client_
0
)
;
RefuseApplicationData
(
server_
0
)
;
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTING
)
;
client_stage
.
ForwardAll
(
server_
TlsAgent
:
:
STATE_CONNECTING
)
;
RefuseApplicationData
(
server_
1
)
;
if
(
version_
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTED
)
;
client_stage
.
ForwardAll
(
server_
TlsAgent
:
:
STATE_CONNECTED
)
;
}
else
{
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTING
)
;
RefuseApplicationData
(
client_
1
)
;
client_stage
.
ForwardAll
(
server_
TlsAgent
:
:
STATE_CONNECTED
)
;
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTED
)
;
}
CheckKeys
(
)
;
SendForwardReceive
(
client_
client_stage
server_
)
;
SendForwardReceive
(
server_
server_stage
client_
)
;
}
static
SECStatus
AuthCompleteBlock
(
TlsAgent
*
PRBool
PRBool
)
{
return
SECWouldBlock
;
}
TEST_P
(
TlsConnectStream
ReplaceRecordLayerAsyncLateAuth
)
{
StartConnect
(
)
;
client_
-
>
SetServerKeyBits
(
server_
-
>
server_key_bits
(
)
)
;
BadPrSocket
bad_layer_client
(
client_
)
;
BadPrSocket
bad_layer_server
(
server_
)
;
StagedRecords
client_stage
(
client_
)
;
StagedRecords
server_stage
(
server_
)
;
client_
-
>
SetAuthCertificateCallback
(
AuthCompleteBlock
)
;
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTING
)
;
client_stage
.
ForwardAll
(
server_
TlsAgent
:
:
STATE_CONNECTING
)
;
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTING
)
;
if
(
version_
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
ASSERT_TRUE
(
client_stage
.
empty
(
)
)
;
client_
-
>
CheckEpochs
(
2
0
)
;
server_
-
>
CheckEpochs
(
2
3
)
;
client_
-
>
Handshake
(
)
;
ASSERT_TRUE
(
client_stage
.
empty
(
)
)
;
EXPECT_EQ
(
TlsAgent
:
:
STATE_CONNECTING
client_
-
>
state
(
)
)
;
}
else
{
ASSERT_FALSE
(
client_stage
.
empty
(
)
)
;
}
EXPECT_EQ
(
SECSuccess
SSL_AuthCertificateComplete
(
client_
-
>
ssl_fd
(
)
0
)
)
;
client_
-
>
Handshake
(
)
;
ASSERT_FALSE
(
client_stage
.
empty
(
)
)
;
if
(
version_
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
EXPECT_EQ
(
TlsAgent
:
:
STATE_CONNECTED
client_
-
>
state
(
)
)
;
client_stage
.
ForwardAll
(
server_
TlsAgent
:
:
STATE_CONNECTED
)
;
}
else
{
client_stage
.
ForwardAll
(
server_
TlsAgent
:
:
STATE_CONNECTED
)
;
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTED
)
;
}
CheckKeys
(
)
;
SendForwardReceive
(
client_
client_stage
server_
)
;
}
TEST_F
(
TlsConnectStreamTls13
ReplaceRecordLayerAsyncEarlyAuth
)
{
StartConnect
(
)
;
client_
-
>
SetServerKeyBits
(
server_
-
>
server_key_bits
(
)
)
;
BadPrSocket
bad_layer_client
(
client_
)
;
BadPrSocket
bad_layer_server
(
server_
)
;
StagedRecords
client_stage
(
client_
)
;
StagedRecords
server_stage
(
server_
)
;
client_
-
>
SetAuthCertificateCallback
(
AuthCompleteBlock
)
;
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTING
)
;
client_stage
.
ForwardAll
(
server_
TlsAgent
:
:
STATE_CONNECTING
)
;
server_stage
.
ForwardPartial
(
client_
)
;
EXPECT_TRUE
(
client_stage
.
empty
(
)
)
;
EXPECT_EQ
(
SECSuccess
SSL_AuthCertificateComplete
(
client_
-
>
ssl_fd
(
)
0
)
)
;
client_
-
>
Handshake
(
)
;
EXPECT_TRUE
(
client_stage
.
empty
(
)
)
;
PRBool
pending
=
PR_FALSE
;
EXPECT_EQ
(
SECSuccess
SSLInt_HasPendingHandshakeData
(
client_
-
>
ssl_fd
(
)
&
pending
)
)
;
EXPECT_EQ
(
PR_TRUE
pending
)
;
EXPECT_EQ
(
TlsAgent
:
:
STATE_CONNECTING
client_
-
>
state
(
)
)
;
server_stage
.
ForwardAll
(
client_
TlsAgent
:
:
STATE_CONNECTED
)
;
client_stage
.
ForwardAll
(
server_
TlsAgent
:
:
STATE_CONNECTED
)
;
CheckKeys
(
)
;
SendForwardReceive
(
server_
server_stage
client_
)
;
}
TEST_P
(
TlsConnectStream
ForwardDataFromWrongEpoch
)
{
const
uint8_t
data
[
]
=
{
1
}
;
Connect
(
)
;
uint16_t
next_epoch
;
if
(
version_
>
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
EXPECT_EQ
(
SECFailure
SSL_RecordLayerData
(
client_
-
>
ssl_fd
(
)
2
ssl_ct_application_data
data
sizeof
(
data
)
)
)
;
EXPECT_EQ
(
SEC_ERROR_INVALID_ARGS
PORT_GetError
(
)
)
<
<
"
Passing
data
from
an
old
epoch
is
rejected
"
;
next_epoch
=
4
;
}
else
{
next_epoch
=
2
;
}
EXPECT_EQ
(
SECFailure
SSL_RecordLayerData
(
client_
-
>
ssl_fd
(
)
next_epoch
ssl_ct_application_data
data
sizeof
(
data
)
)
)
;
EXPECT_EQ
(
PR_WOULD_BLOCK_ERROR
PORT_GetError
(
)
)
<
<
"
Passing
data
from
a
future
epoch
blocks
"
;
}
TEST_F
(
TlsConnectStreamTls13
ForwardInvalidData
)
{
const
uint8_t
data
[
1
]
=
{
0
}
;
EnsureTlsSetup
(
)
;
EXPECT_EQ
(
SECFailure
SSL_RecordLayerData
(
client_
-
>
ssl_fd
(
)
0
ssl_ct_application_data
data
0
)
)
;
EXPECT_EQ
(
SEC_ERROR_INVALID_ARGS
PORT_GetError
(
)
)
;
EXPECT_EQ
(
SECFailure
SSL_RecordLayerData
(
client_
-
>
ssl_fd
(
)
0
ssl_ct_application_data
nullptr
1
)
)
;
EXPECT_EQ
(
SEC_ERROR_INVALID_ARGS
PORT_GetError
(
)
)
;
}
TEST_F
(
TlsConnectDatagram13
ForwardDataDtls
)
{
EnsureTlsSetup
(
)
;
const
uint8_t
data
[
1
]
=
{
0
}
;
EXPECT_EQ
(
SECFailure
SSL_RecordLayerData
(
client_
-
>
ssl_fd
(
)
0
ssl_ct_application_data
data
sizeof
(
data
)
)
)
;
EXPECT_EQ
(
SEC_ERROR_INVALID_ARGS
PORT_GetError
(
)
)
;
}
}
