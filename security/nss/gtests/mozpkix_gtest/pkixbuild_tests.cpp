#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
<
1900
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4702
)
#
endif
#
include
<
map
>
#
include
<
vector
>
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
<
1900
#
pragma
warning
(
pop
)
#
endif
#
include
"
pkixgtest
.
h
"
#
include
"
mozpkix
/
pkixder
.
h
"
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
pkix
:
:
test
;
static
ByteString
CreateCert
(
const
char
*
issuerCN
const
char
*
subjectCN
EndEntityOrCA
endEntityOrCA
std
:
:
map
<
ByteString
ByteString
>
*
subjectDERToCertDER
=
nullptr
const
ByteString
*
extension
=
nullptr
const
TestKeyPair
*
issuerKeyPair
=
nullptr
const
TestKeyPair
*
subjectKeyPair
=
nullptr
)
{
static
long
serialNumberValue
=
0
;
+
+
serialNumberValue
;
ByteString
serialNumber
(
CreateEncodedSerialNumber
(
serialNumberValue
)
)
;
EXPECT_FALSE
(
ENCODING_FAILED
(
serialNumber
)
)
;
ByteString
issuerDER
(
issuerCN
?
CNToDERName
(
issuerCN
)
:
Name
(
ByteString
(
)
)
)
;
ByteString
subjectDER
(
subjectCN
?
CNToDERName
(
subjectCN
)
:
Name
(
ByteString
(
)
)
)
;
std
:
:
vector
<
ByteString
>
extensions
;
if
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
)
{
ByteString
basicConstraints
=
CreateEncodedBasicConstraints
(
true
nullptr
Critical
:
:
Yes
)
;
EXPECT_FALSE
(
ENCODING_FAILED
(
basicConstraints
)
)
;
extensions
.
push_back
(
basicConstraints
)
;
}
if
(
extension
)
{
extensions
.
push_back
(
*
extension
)
;
}
extensions
.
push_back
(
ByteString
(
)
)
;
ScopedTestKeyPair
reusedKey
(
CloneReusedKeyPair
(
)
)
;
ByteString
certDER
(
CreateEncodedCertificate
(
v3
sha256WithRSAEncryption
(
)
serialNumber
issuerDER
oneDayBeforeNow
oneDayAfterNow
subjectDER
subjectKeyPair
?
*
subjectKeyPair
:
*
reusedKey
extensions
.
data
(
)
issuerKeyPair
?
*
issuerKeyPair
:
*
reusedKey
sha256WithRSAEncryption
(
)
)
)
;
EXPECT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
if
(
subjectDERToCertDER
)
{
(
*
subjectDERToCertDER
)
[
subjectDER
]
=
certDER
;
}
return
certDER
;
}
class
TestTrustDomain
final
:
public
DefaultCryptoTrustDomain
{
public
:
bool
SetUpCertChainTail
(
)
{
static
char
const
*
const
names
[
]
=
{
"
CA1
(
Root
)
"
"
CA2
"
"
CA3
"
"
CA4
"
"
CA5
"
"
CA6
"
"
CA7
"
}
;
for
(
size_t
i
=
0
;
i
<
MOZILLA_PKIX_ARRAY_LENGTH
(
names
)
;
+
+
i
)
{
const
char
*
issuerName
=
i
=
=
0
?
names
[
0
]
:
names
[
i
-
1
]
;
CreateCACert
(
issuerName
names
[
i
]
)
;
if
(
i
=
=
0
)
{
rootCACertDER
=
leafCACertDER
;
}
}
return
true
;
}
void
CreateCACert
(
const
char
*
issuerName
const
char
*
subjectName
)
{
leafCACertDER
=
CreateCert
(
issuerName
subjectName
EndEntityOrCA
:
:
MustBeCA
&
subjectDERToCertDER
)
;
assert
(
!
ENCODING_FAILED
(
leafCACertDER
)
)
;
}
ByteString
GetLeafCACertDER
(
)
const
{
return
leafCACertDER
;
}
private
:
Result
GetCertTrust
(
EndEntityOrCA
const
CertPolicyId
&
Input
candidateCert
TrustLevel
&
trustLevel
)
override
{
trustLevel
=
InputEqualsByteString
(
candidateCert
rootCACertDER
)
?
TrustLevel
:
:
TrustAnchor
:
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
Result
FindIssuer
(
Input
encodedIssuerName
IssuerChecker
&
checker
Time
)
override
{
ByteString
subjectDER
(
InputToByteString
(
encodedIssuerName
)
)
;
ByteString
certDER
(
subjectDERToCertDER
[
subjectDER
]
)
;
Input
derCert
;
Result
rv
=
derCert
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
bool
keepGoing
;
rv
=
checker
.
Check
(
derCert
nullptr
keepGoing
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
Success
;
}
Result
CheckRevocation
(
EndEntityOrCA
const
CertID
&
Time
Time
validityBeginning
Duration
const
Input
*
const
Input
*
)
override
{
EXPECT_EQ
(
TimeFromEpochInSeconds
(
oneDayBeforeNow
)
validityBeginning
)
;
return
Success
;
}
Result
IsChainValid
(
const
DERArray
&
Time
const
CertPolicyId
&
)
override
{
return
Success
;
}
std
:
:
map
<
ByteString
ByteString
>
subjectDERToCertDER
;
ByteString
leafCACertDER
;
ByteString
rootCACertDER
;
}
;
class
pkixbuild
:
public
:
:
testing
:
:
Test
{
public
:
static
void
SetUpTestCase
(
)
{
if
(
!
trustDomain
.
SetUpCertChainTail
(
)
)
{
abort
(
)
;
}
}
protected
:
static
TestTrustDomain
trustDomain
;
}
;
TestTrustDomain
pkixbuild
:
:
trustDomain
;
TEST_F
(
pkixbuild
MaxAcceptableCertChainLength
)
{
{
ByteString
leafCACert
(
trustDomain
.
GetLeafCACertDER
(
)
)
;
Input
certDER
;
ASSERT_EQ
(
Success
certDER
.
Init
(
leafCACert
.
data
(
)
leafCACert
.
length
(
)
)
)
;
ASSERT_EQ
(
Success
BuildCertChain
(
trustDomain
certDER
Now
(
)
EndEntityOrCA
:
:
MustBeCA
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
{
ByteString
certDER
(
CreateCert
(
"
CA7
"
"
Direct
End
-
Entity
"
EndEntityOrCA
:
:
MustBeEndEntity
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
Input
certDERInput
;
ASSERT_EQ
(
Success
certDERInput
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
ASSERT_EQ
(
Success
BuildCertChain
(
trustDomain
certDERInput
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
}
TEST_F
(
pkixbuild
BeyondMaxAcceptableCertChainLength
)
{
static
char
const
*
const
caCertName
=
"
CA
Too
Far
"
;
trustDomain
.
CreateCACert
(
"
CA7
"
caCertName
)
;
{
ByteString
certDER
(
trustDomain
.
GetLeafCACertDER
(
)
)
;
Input
certDERInput
;
ASSERT_EQ
(
Success
certDERInput
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
ASSERT_EQ
(
Result
:
:
ERROR_UNKNOWN_ISSUER
BuildCertChain
(
trustDomain
certDERInput
Now
(
)
EndEntityOrCA
:
:
MustBeCA
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
{
ByteString
certDER
(
CreateCert
(
caCertName
"
End
-
Entity
Too
Far
"
EndEntityOrCA
:
:
MustBeEndEntity
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
Input
certDERInput
;
ASSERT_EQ
(
Success
certDERInput
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
ASSERT_EQ
(
Result
:
:
ERROR_UNKNOWN_ISSUER
BuildCertChain
(
trustDomain
certDERInput
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
}
class
SingleRootTrustDomain
:
public
DefaultCryptoTrustDomain
{
public
:
explicit
SingleRootTrustDomain
(
ByteString
aRootDER
)
:
rootDER
(
aRootDER
)
{
}
Result
GetCertTrust
(
EndEntityOrCA
const
CertPolicyId
&
Input
candidateCert
TrustLevel
&
trustLevel
)
override
{
Input
rootCert
;
Result
rv
=
rootCert
.
Init
(
rootDER
.
data
(
)
rootDER
.
length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
InputsAreEqual
(
candidateCert
rootCert
)
)
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
}
else
{
trustLevel
=
TrustLevel
:
:
InheritsTrust
;
}
return
Success
;
}
Result
FindIssuer
(
Input
IssuerChecker
&
checker
Time
)
override
{
bool
keepGoing
;
Input
rootCert
;
Result
rv
=
rootCert
.
Init
(
rootDER
.
data
(
)
rootDER
.
length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
checker
.
Check
(
rootCert
nullptr
keepGoing
)
;
}
Result
IsChainValid
(
const
DERArray
&
Time
const
CertPolicyId
&
)
override
{
return
Success
;
}
Result
CheckRevocation
(
EndEntityOrCA
const
CertID
&
Time
Time
validityBeginning
Duration
const
Input
*
const
Input
*
)
override
{
EXPECT_EQ
(
TimeFromEpochInSeconds
(
oneDayBeforeNow
)
validityBeginning
)
;
return
Success
;
}
private
:
ByteString
rootDER
;
}
;
class
ExpiredCertTrustDomain
final
:
public
SingleRootTrustDomain
{
public
:
explicit
ExpiredCertTrustDomain
(
ByteString
aRootDER
)
:
SingleRootTrustDomain
(
aRootDER
)
{
}
Result
CheckRevocation
(
EndEntityOrCA
const
CertID
&
Time
Time
Duration
const
Input
*
const
Input
*
)
override
{
ADD_FAILURE
(
)
;
return
NotReached
(
"
CheckRevocation
should
not
be
called
"
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
)
;
}
}
;
TEST_F
(
pkixbuild
NoRevocationCheckingForExpiredCert
)
{
const
char
*
rootCN
=
"
Root
CA
"
;
ByteString
rootDER
(
CreateCert
(
rootCN
rootCN
EndEntityOrCA
:
:
MustBeCA
nullptr
)
)
;
EXPECT_FALSE
(
ENCODING_FAILED
(
rootDER
)
)
;
ExpiredCertTrustDomain
expiredCertTrustDomain
(
rootDER
)
;
ByteString
serialNumber
(
CreateEncodedSerialNumber
(
100
)
)
;
EXPECT_FALSE
(
ENCODING_FAILED
(
serialNumber
)
)
;
ByteString
issuerDER
(
CNToDERName
(
rootCN
)
)
;
ByteString
subjectDER
(
CNToDERName
(
"
Expired
End
-
Entity
Cert
"
)
)
;
ScopedTestKeyPair
reusedKey
(
CloneReusedKeyPair
(
)
)
;
ByteString
certDER
(
CreateEncodedCertificate
(
v3
sha256WithRSAEncryption
(
)
serialNumber
issuerDER
twoDaysBeforeNow
oneDayBeforeNow
subjectDER
*
reusedKey
nullptr
*
reusedKey
sha256WithRSAEncryption
(
)
)
)
;
EXPECT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
Input
cert
;
ASSERT_EQ
(
Success
cert
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
ASSERT_EQ
(
Result
:
:
ERROR_EXPIRED_CERTIFICATE
BuildCertChain
(
expiredCertTrustDomain
cert
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
class
DSSTrustDomain
final
:
public
EverythingFailsByDefaultTrustDomain
{
public
:
Result
GetCertTrust
(
EndEntityOrCA
const
CertPolicyId
&
Input
TrustLevel
&
trustLevel
)
override
{
trustLevel
=
TrustLevel
:
:
TrustAnchor
;
return
Success
;
}
}
;
class
pkixbuild_DSS
:
public
:
:
testing
:
:
Test
{
}
;
TEST_F
(
pkixbuild_DSS
DSSEndEntityKeyNotAccepted
)
{
DSSTrustDomain
trustDomain
;
ByteString
serialNumber
(
CreateEncodedSerialNumber
(
1
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
serialNumber
)
)
;
ByteString
subjectDER
(
CNToDERName
(
"
DSS
"
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
subjectDER
)
)
;
ScopedTestKeyPair
subjectKey
(
GenerateDSSKeyPair
(
)
)
;
ASSERT_TRUE
(
subjectKey
.
get
(
)
)
;
ByteString
issuerDER
(
CNToDERName
(
"
RSA
"
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
issuerDER
)
)
;
ScopedTestKeyPair
issuerKey
(
CloneReusedKeyPair
(
)
)
;
ASSERT_TRUE
(
issuerKey
.
get
(
)
)
;
ByteString
cert
(
CreateEncodedCertificate
(
v3
sha256WithRSAEncryption
(
)
serialNumber
issuerDER
oneDayBeforeNow
oneDayAfterNow
subjectDER
*
subjectKey
nullptr
*
issuerKey
sha256WithRSAEncryption
(
)
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
cert
)
)
;
Input
certDER
;
ASSERT_EQ
(
Success
certDER
.
Init
(
cert
.
data
(
)
cert
.
length
(
)
)
)
;
ASSERT_EQ
(
Result
:
:
ERROR_UNSUPPORTED_KEYALG
BuildCertChain
(
trustDomain
certDER
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
class
IssuerNameCheckTrustDomain
final
:
public
DefaultCryptoTrustDomain
{
public
:
IssuerNameCheckTrustDomain
(
const
ByteString
&
aIssuer
bool
aExpectedKeepGoing
)
:
issuer
(
aIssuer
)
expectedKeepGoing
(
aExpectedKeepGoing
)
{
}
Result
GetCertTrust
(
EndEntityOrCA
endEntityOrCA
const
CertPolicyId
&
Input
TrustLevel
&
trustLevel
)
override
{
trustLevel
=
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeCA
?
TrustLevel
:
:
TrustAnchor
:
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
Result
FindIssuer
(
Input
IssuerChecker
&
checker
Time
)
override
{
Input
issuerInput
;
EXPECT_EQ
(
Success
issuerInput
.
Init
(
issuer
.
data
(
)
issuer
.
length
(
)
)
)
;
bool
keepGoing
;
EXPECT_EQ
(
Success
checker
.
Check
(
issuerInput
nullptr
keepGoing
)
)
;
EXPECT_EQ
(
expectedKeepGoing
keepGoing
)
;
return
Success
;
}
Result
CheckRevocation
(
EndEntityOrCA
const
CertID
&
Time
Time
validityBeginning
Duration
const
Input
*
const
Input
*
)
override
{
EXPECT_EQ
(
TimeFromEpochInSeconds
(
oneDayBeforeNow
)
validityBeginning
)
;
return
Success
;
}
Result
IsChainValid
(
const
DERArray
&
Time
const
CertPolicyId
&
)
override
{
return
Success
;
}
private
:
const
ByteString
issuer
;
const
bool
expectedKeepGoing
;
}
;
struct
IssuerNameCheckParams
{
const
char
*
subjectIssuerCN
;
const
char
*
issuerSubjectCN
;
bool
matches
;
Result
expectedError
;
}
;
static
const
IssuerNameCheckParams
ISSUER_NAME_CHECK_PARAMS
[
]
=
{
{
"
foo
"
"
foo
"
true
Success
}
{
"
foo
"
"
bar
"
false
Result
:
:
ERROR_UNKNOWN_ISSUER
}
{
"
f
"
"
foo
"
false
Result
:
:
ERROR_UNKNOWN_ISSUER
}
{
"
foo
"
"
f
"
false
Result
:
:
ERROR_UNKNOWN_ISSUER
}
{
"
foo
"
"
Foo
"
false
Result
:
:
ERROR_UNKNOWN_ISSUER
}
{
"
"
"
"
true
Success
}
{
nullptr
nullptr
false
Result
:
:
ERROR_EMPTY_ISSUER_NAME
}
{
"
foo
"
nullptr
false
Result
:
:
ERROR_UNKNOWN_ISSUER
}
{
nullptr
"
foo
"
false
Result
:
:
ERROR_UNKNOWN_ISSUER
}
}
;
class
pkixbuild_IssuerNameCheck
:
public
:
:
testing
:
:
Test
public
:
:
testing
:
:
WithParamInterface
<
IssuerNameCheckParams
>
{
}
;
TEST_P
(
pkixbuild_IssuerNameCheck
MatchingName
)
{
const
IssuerNameCheckParams
&
params
(
GetParam
(
)
)
;
ByteString
issuerCertDER
(
CreateCert
(
params
.
issuerSubjectCN
params
.
issuerSubjectCN
EndEntityOrCA
:
:
MustBeCA
nullptr
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
issuerCertDER
)
)
;
ByteString
subjectCertDER
(
CreateCert
(
params
.
subjectIssuerCN
"
end
-
entity
"
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
subjectCertDER
)
)
;
Input
subjectCertDERInput
;
ASSERT_EQ
(
Success
subjectCertDERInput
.
Init
(
subjectCertDER
.
data
(
)
subjectCertDER
.
length
(
)
)
)
;
IssuerNameCheckTrustDomain
trustDomain
(
issuerCertDER
!
params
.
matches
)
;
ASSERT_EQ
(
params
.
expectedError
BuildCertChain
(
trustDomain
subjectCertDERInput
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
INSTANTIATE_TEST_CASE_P
(
pkixbuild_IssuerNameCheck
pkixbuild_IssuerNameCheck
testing
:
:
ValuesIn
(
ISSUER_NAME_CHECK_PARAMS
)
)
;
class
EmbeddedSCTListTestTrustDomain
final
:
public
SingleRootTrustDomain
{
public
:
explicit
EmbeddedSCTListTestTrustDomain
(
ByteString
aRootDER
)
:
SingleRootTrustDomain
(
aRootDER
)
{
}
virtual
void
NoteAuxiliaryExtension
(
AuxiliaryExtension
extension
Input
extensionData
)
override
{
if
(
extension
=
=
AuxiliaryExtension
:
:
EmbeddedSCTList
)
{
signedCertificateTimestamps
=
InputToByteString
(
extensionData
)
;
}
else
{
ADD_FAILURE
(
)
;
}
}
ByteString
signedCertificateTimestamps
;
}
;
TEST_F
(
pkixbuild
CertificateTransparencyExtension
)
{
static
const
uint8_t
tlv_id_embeddedSctList
[
]
=
{
0x06
0x0a
0x2b
0x06
0x01
0x04
0x01
0xd6
0x79
0x02
0x04
0x02
}
;
static
const
uint8_t
dummySctList
[
]
=
{
0x01
0x02
0x03
0x04
0x05
}
;
ByteString
ctExtension
=
TLV
(
der
:
:
SEQUENCE
BytesToByteString
(
tlv_id_embeddedSctList
)
+
Boolean
(
false
)
+
TLV
(
der
:
:
OCTET_STRING
TLV
(
der
:
:
OCTET_STRING
BytesToByteString
(
dummySctList
)
)
)
)
;
const
char
*
rootCN
=
"
Root
CA
"
;
ByteString
rootDER
(
CreateCert
(
rootCN
rootCN
EndEntityOrCA
:
:
MustBeCA
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
rootDER
)
)
;
ByteString
certDER
(
CreateCert
(
rootCN
"
Cert
with
SCT
list
"
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
&
ctExtension
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
Input
certInput
;
ASSERT_EQ
(
Success
certInput
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
EmbeddedSCTListTestTrustDomain
extTrustDomain
(
rootDER
)
;
ASSERT_EQ
(
Success
BuildCertChain
(
extTrustDomain
certInput
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
anyExtendedKeyUsage
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
ASSERT_EQ
(
BytesToByteString
(
dummySctList
)
extTrustDomain
.
signedCertificateTimestamps
)
;
}
class
MultiplePathTrustDomain
:
public
DefaultCryptoTrustDomain
{
public
:
void
SetUpCerts
(
)
{
ASSERT_FALSE
(
ENCODING_FAILED
(
CreateCert
(
"
UntrustedRoot
"
"
UntrustedRoot
"
EndEntityOrCA
:
:
MustBeCA
&
subjectDERToCertDER
)
)
)
;
intermediateSignedByUntrustedRootCertDER
=
CreateCert
(
"
UntrustedRoot
"
"
Intermediate
"
EndEntityOrCA
:
:
MustBeCA
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
intermediateSignedByUntrustedRootCertDER
)
)
;
rootCACertDER
=
CreateCert
(
"
TrustedRoot
"
"
TrustedRoot
"
EndEntityOrCA
:
:
MustBeCA
&
subjectDERToCertDER
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
rootCACertDER
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
CreateCert
(
"
TrustedRoot
"
"
Intermediate
"
EndEntityOrCA
:
:
MustBeCA
&
subjectDERToCertDER
)
)
)
;
}
private
:
Result
GetCertTrust
(
EndEntityOrCA
const
CertPolicyId
&
Input
candidateCert
TrustLevel
&
trustLevel
)
override
{
trustLevel
=
InputEqualsByteString
(
candidateCert
rootCACertDER
)
?
TrustLevel
:
:
TrustAnchor
:
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
Result
CheckCert
(
ByteString
&
certDER
IssuerChecker
&
checker
bool
&
keepGoing
)
{
Input
derCert
;
Result
rv
=
derCert
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
checker
.
Check
(
derCert
nullptr
keepGoing
)
;
}
Result
FindIssuer
(
Input
encodedIssuerName
IssuerChecker
&
checker
Time
)
override
{
ByteString
subjectDER
(
InputToByteString
(
encodedIssuerName
)
)
;
ByteString
certDER
(
subjectDERToCertDER
[
subjectDER
]
)
;
assert
(
!
ENCODING_FAILED
(
certDER
)
)
;
bool
keepGoing
;
Result
rv
=
CheckCert
(
certDER
checker
keepGoing
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
keepGoing
)
{
rv
=
CheckCert
(
intermediateSignedByUntrustedRootCertDER
checker
keepGoing
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
}
return
Success
;
}
Result
CheckRevocation
(
EndEntityOrCA
const
CertID
&
Time
Time
validityBeginning
Duration
const
Input
*
const
Input
*
)
override
{
EXPECT_EQ
(
TimeFromEpochInSeconds
(
oneDayBeforeNow
)
validityBeginning
)
;
return
Success
;
}
Result
IsChainValid
(
const
DERArray
&
Time
const
CertPolicyId
&
)
override
{
return
Success
;
}
std
:
:
map
<
ByteString
ByteString
>
subjectDERToCertDER
;
ByteString
rootCACertDER
;
ByteString
intermediateSignedByUntrustedRootCertDER
;
}
;
TEST_F
(
pkixbuild
BadEmbeddedSCTWithMultiplePaths
)
{
MultiplePathTrustDomain
localTrustDomain
;
localTrustDomain
.
SetUpCerts
(
)
;
static
const
uint8_t
tlv_id_embeddedSctList
[
]
=
{
0x06
0x0a
0x2b
0x06
0x01
0x04
0x01
0xd6
0x79
0x02
0x04
0x02
}
;
static
const
uint8_t
dummySctList
[
]
=
{
0x01
0x02
0x03
0x04
0x05
}
;
ByteString
ctExtension
=
TLV
(
der
:
:
SEQUENCE
BytesToByteString
(
tlv_id_embeddedSctList
)
+
Boolean
(
false
)
+
TLV
(
der
:
:
OCTET_STRING
BytesToByteString
(
dummySctList
)
)
)
;
ByteString
certDER
(
CreateCert
(
"
Intermediate
"
"
Cert
with
bogus
SCT
list
"
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
&
ctExtension
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
Input
certDERInput
;
ASSERT_EQ
(
Success
certDERInput
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
ASSERT_EQ
(
Result
:
:
ERROR_BAD_DER
BuildCertChain
(
localTrustDomain
certDERInput
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
class
RevokedEndEntityTrustDomain
final
:
public
MultiplePathTrustDomain
{
public
:
Result
CheckRevocation
(
EndEntityOrCA
endEntityOrCA
const
CertID
&
Time
Time
Duration
const
Input
*
const
Input
*
)
override
{
if
(
endEntityOrCA
=
=
EndEntityOrCA
:
:
MustBeEndEntity
)
{
return
Result
:
:
ERROR_REVOKED_CERTIFICATE
;
}
return
Success
;
}
}
;
TEST_F
(
pkixbuild
RevokedEndEntityWithMultiplePaths
)
{
RevokedEndEntityTrustDomain
localTrustDomain
;
localTrustDomain
.
SetUpCerts
(
)
;
ByteString
certDER
(
CreateCert
(
"
Intermediate
"
"
RevokedEndEntity
"
EndEntityOrCA
:
:
MustBeEndEntity
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
Input
certDERInput
;
ASSERT_EQ
(
Success
certDERInput
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
ASSERT_EQ
(
Result
:
:
ERROR_REVOKED_CERTIFICATE
BuildCertChain
(
localTrustDomain
certDERInput
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
class
SelfIssuedCertificatesTrustDomain
final
:
public
DefaultCryptoTrustDomain
{
public
:
void
SetUpCerts
(
size_t
totalCerts
)
{
ASSERT_TRUE
(
totalCerts
>
0
)
;
ScopedTestKeyPair
rootKeyPair
(
GenerateKeyPair
(
)
)
;
rootCACertDER
=
CreateCert
(
"
DN
"
"
DN
"
EndEntityOrCA
:
:
MustBeCA
nullptr
nullptr
rootKeyPair
.
get
(
)
rootKeyPair
.
get
(
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
rootCACertDER
)
)
;
certs
.
push_back
(
rootCACertDER
)
;
ScopedTestKeyPair
issuerKeyPair
(
rootKeyPair
.
release
(
)
)
;
size_t
subCAsGenerated
;
for
(
subCAsGenerated
=
0
;
subCAsGenerated
<
totalCerts
-
1
&
&
subCAsGenerated
<
6
;
subCAsGenerated
+
+
)
{
ScopedTestKeyPair
keyPair
(
GenerateKeyPair
(
)
)
;
ByteString
cert
(
CreateCert
(
"
DN
"
"
DN
"
EndEntityOrCA
:
:
MustBeCA
nullptr
nullptr
issuerKeyPair
.
get
(
)
keyPair
.
get
(
)
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
cert
)
)
;
certs
.
push_back
(
cert
)
;
issuerKeyPair
.
reset
(
keyPair
.
release
(
)
)
;
}
firstIssuerKey
.
reset
(
issuerKeyPair
.
release
(
)
)
;
for
(
;
subCAsGenerated
<
totalCerts
-
1
;
subCAsGenerated
+
+
)
{
ScopedTestKeyPair
keyPair
(
GenerateKeyPair
(
)
)
;
ByteString
cert
(
CreateCert
(
"
DN
"
"
DN
"
EndEntityOrCA
:
:
MustBeCA
nullptr
nullptr
keyPair
.
get
(
)
keyPair
.
get
(
)
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
cert
)
)
;
certs
.
insert
(
certs
.
begin
(
)
cert
)
;
}
}
const
TestKeyPair
*
GetFirstIssuerKey
(
)
{
return
firstIssuerKey
.
get
(
)
;
}
private
:
Result
GetCertTrust
(
EndEntityOrCA
const
CertPolicyId
&
Input
candidateCert
TrustLevel
&
trustLevel
)
override
{
trustLevel
=
InputEqualsByteString
(
candidateCert
rootCACertDER
)
?
TrustLevel
:
:
TrustAnchor
:
TrustLevel
:
:
InheritsTrust
;
return
Success
;
}
Result
FindIssuer
(
Input
IssuerChecker
&
checker
Time
)
override
{
bool
keepGoing
;
for
(
auto
&
cert
:
certs
)
{
Input
certInput
;
Result
rv
=
certInput
.
Init
(
cert
.
data
(
)
cert
.
length
(
)
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
rv
=
checker
.
Check
(
certInput
nullptr
keepGoing
)
;
if
(
rv
!
=
Success
|
|
!
keepGoing
)
{
return
rv
;
}
}
return
Success
;
}
Result
CheckRevocation
(
EndEntityOrCA
const
CertID
&
Time
Time
validityBeginning
Duration
const
Input
*
const
Input
*
)
override
{
EXPECT_EQ
(
TimeFromEpochInSeconds
(
oneDayBeforeNow
)
validityBeginning
)
;
return
Success
;
}
Result
IsChainValid
(
const
DERArray
&
Time
const
CertPolicyId
&
)
override
{
return
Success
;
}
std
:
:
vector
<
ByteString
>
certs
;
ByteString
rootCACertDER
;
ScopedTestKeyPair
firstIssuerKey
;
}
;
TEST_F
(
pkixbuild
AvoidUnboundedPathSearchingFailure
)
{
SelfIssuedCertificatesTrustDomain
localTrustDomain
;
localTrustDomain
.
SetUpCerts
(
18
)
;
ByteString
certDER
(
CreateCert
(
"
DN
"
"
DN
"
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
nullptr
localTrustDomain
.
GetFirstIssuerKey
(
)
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
Input
certDERInput
;
ASSERT_EQ
(
Success
certDERInput
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
ASSERT_EQ
(
Result
:
:
ERROR_UNKNOWN_ISSUER
BuildCertChain
(
localTrustDomain
certDERInput
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
TEST_F
(
pkixbuild
AvoidUnboundedPathSearchingSuccess
)
{
SelfIssuedCertificatesTrustDomain
localTrustDomain
;
localTrustDomain
.
SetUpCerts
(
10
)
;
ByteString
certDER
(
CreateCert
(
"
DN
"
"
DN
"
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
nullptr
localTrustDomain
.
GetFirstIssuerKey
(
)
)
)
;
ASSERT_FALSE
(
ENCODING_FAILED
(
certDER
)
)
;
Input
certDERInput
;
ASSERT_EQ
(
Success
certDERInput
.
Init
(
certDER
.
data
(
)
certDER
.
length
(
)
)
)
;
ASSERT_EQ
(
Success
BuildCertChain
(
localTrustDomain
certDERInput
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_serverAuth
CertPolicyId
:
:
anyPolicy
nullptr
)
)
;
}
