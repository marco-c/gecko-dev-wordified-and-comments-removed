#
include
<
memory
>
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
sechash
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
nss_scoped_ptrs
.
h
"
#
include
"
pk11_signature_test
.
h
"
#
include
"
pk11_rsapss_vectors
.
h
"
namespace
nss_test
{
class
Pkcs11RsaPssTest
:
public
Pk11SignatureTest
{
public
:
Pkcs11RsaPssTest
(
)
:
Pk11SignatureTest
(
CKM_RSA_PKCS_PSS
SEC_OID_SHA1
)
{
rsaPssParams_
.
hashAlg
=
CKM_SHA_1
;
rsaPssParams_
.
mgf
=
CKG_MGF1_SHA1
;
rsaPssParams_
.
sLen
=
HASH_ResultLenByOidTag
(
SEC_OID_SHA1
)
;
params_
.
type
=
siBuffer
;
params_
.
data
=
reinterpret_cast
<
unsigned
char
*
>
(
&
rsaPssParams_
)
;
params_
.
len
=
sizeof
(
rsaPssParams_
)
;
}
protected
:
const
SECItem
*
parameters
(
)
const
{
return
&
params_
;
}
private
:
CK_RSA_PKCS_PSS_PARAMS
rsaPssParams_
;
SECItem
params_
;
}
;
TEST_F
(
Pkcs11RsaPssTest
GenerateAndSignAndVerify
)
{
SECOidTag
hashOid
=
SEC_OID_SHA256
;
CK_MECHANISM_TYPE
hashMech
=
CKM_SHA256
;
CK_RSA_PKCS_MGF_TYPE
mgf
=
CKG_MGF1_SHA256
;
PK11RSAGenParams
rsaGenParams
=
{
1024
0x10001
}
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
SECKEYPublicKey
*
pubKeyRaw
=
nullptr
;
ScopedSECKEYPrivateKey
privKey
(
PK11_GenerateKeyPair
(
slot
.
get
(
)
CKM_RSA_PKCS_KEY_PAIR_GEN
&
rsaGenParams
&
pubKeyRaw
false
false
nullptr
)
)
;
ASSERT_TRUE
(
!
!
privKey
&
&
pubKeyRaw
)
;
ScopedSECKEYPublicKey
pubKey
(
pubKeyRaw
)
;
uint8_t
dataBuf
[
50
]
;
SECItem
data
=
{
siBuffer
dataBuf
sizeof
(
dataBuf
)
}
;
unsigned
int
hLen
=
HASH_ResultLenByOidTag
(
hashOid
)
;
SECStatus
rv
=
PK11_GenerateRandomOnSlot
(
slot
.
get
(
)
data
.
data
data
.
len
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
std
:
:
vector
<
uint8_t
>
sigBuf
(
PK11_SignatureLen
(
privKey
.
get
(
)
)
)
;
SECItem
sig
=
{
siBuffer
&
sigBuf
[
0
]
static_cast
<
unsigned
int
>
(
sigBuf
.
size
(
)
)
}
;
CK_RSA_PKCS_PSS_PARAMS
rsaPssParams
=
{
hashMech
mgf
hLen
}
;
SECItem
params
=
{
siBuffer
reinterpret_cast
<
unsigned
char
*
>
(
&
rsaPssParams
)
sizeof
(
rsaPssParams
)
}
;
rv
=
PK11_SignWithMechanism
(
privKey
.
get
(
)
mechanism
(
)
&
params
&
sig
&
data
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
rv
=
PK11_VerifyWithMechanism
(
pubKey
.
get
(
)
mechanism
(
)
&
params
&
sig
&
data
nullptr
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
data
.
data
[
0
]
^
=
0xff
;
rv
=
PK11_VerifyWithMechanism
(
pubKey
.
get
(
)
mechanism
(
)
&
params
&
sig
&
data
nullptr
)
;
EXPECT_EQ
(
rv
SECFailure
)
;
data
.
data
[
0
]
^
=
0xff
;
sig
.
data
[
0
]
^
=
0xff
;
rv
=
PK11_VerifyWithMechanism
(
pubKey
.
get
(
)
mechanism
(
)
&
params
&
sig
&
data
nullptr
)
;
EXPECT_EQ
(
rv
SECFailure
)
;
}
TEST_F
(
Pkcs11RsaPssTest
NoLeakWithInvalidExponent
)
{
PK11RSAGenParams
rsaGenParams
=
{
1024
0x01
}
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
SECKEYPublicKey
*
pubKey
=
nullptr
;
SECKEYPrivateKey
*
privKey
=
PK11_GenerateKeyPair
(
slot
.
get
(
)
CKM_RSA_PKCS_KEY_PAIR_GEN
&
rsaGenParams
&
pubKey
false
false
nullptr
)
;
EXPECT_FALSE
(
privKey
)
;
EXPECT_FALSE
(
pubKey
)
;
}
class
Pkcs11RsaPssVectorTest
:
public
Pkcs11RsaPssTest
public
:
:
testing
:
:
WithParamInterface
<
Pkcs11SignatureTestParams
>
{
}
;
TEST_P
(
Pkcs11RsaPssVectorTest
Verify
)
{
Verify
(
GetParam
(
)
)
;
}
TEST_P
(
Pkcs11RsaPssVectorTest
SignAndVerify
)
{
SignAndVerify
(
GetParam
(
)
)
;
}
#
define
VECTOR
(
pkcs8
spki
data
sig
)
\
{
\
DataBuffer
(
pkcs8
sizeof
(
pkcs8
)
)
DataBuffer
(
spki
sizeof
(
spki
)
)
\
DataBuffer
(
data
sizeof
(
data
)
)
DataBuffer
(
sig
sizeof
(
sig
)
)
\
}
#
define
VECTOR_N
(
n
)
\
VECTOR
(
kTestVector
#
#
n
#
#
Pkcs8
kTestVector
#
#
n
#
#
Spki
kTestVector
#
#
n
#
#
Data
\
kTestVector
#
#
n
#
#
Sig
)
static
const
Pkcs11SignatureTestParams
kRsaPssVectors
[
]
=
{
VECTOR_N
(
1
)
VECTOR_N
(
2
)
VECTOR_N
(
3
)
VECTOR_N
(
4
)
VECTOR_N
(
5
)
VECTOR_N
(
6
)
VECTOR_N
(
7
)
VECTOR_N
(
8
)
VECTOR_N
(
9
)
VECTOR_N
(
10
)
}
;
INSTANTIATE_TEST_CASE_P
(
RsaPssSignVerify
Pkcs11RsaPssVectorTest
:
:
testing
:
:
ValuesIn
(
kRsaPssVectors
)
)
;
}
