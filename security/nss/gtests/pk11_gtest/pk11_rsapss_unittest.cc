#
include
<
memory
>
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
sechash
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
scoped_ptrs
.
h
"
#
include
"
pk11_rsapss_vectors
.
h
"
namespace
nss_test
{
static
unsigned
char
*
toUcharPtr
(
const
uint8_t
*
v
)
{
return
const_cast
<
unsigned
char
*
>
(
static_cast
<
const
unsigned
char
*
>
(
v
)
)
;
}
class
Pkcs11RsaPssTest
:
public
:
:
testing
:
:
Test
{
}
;
class
Pkcs11RsaPssVectorTest
:
public
Pkcs11RsaPssTest
{
public
:
void
Verify
(
const
uint8_t
*
spki
size_t
spki_len
const
uint8_t
*
data
size_t
data_len
const
uint8_t
*
sig
size_t
sig_len
)
{
SECOidTag
hashOid
=
SEC_OID_SHA1
;
CK_MECHANISM_TYPE
hashMech
=
CKM_SHA_1
;
CK_RSA_PKCS_MGF_TYPE
mgf
=
CKG_MGF1_SHA1
;
unsigned
int
hLen
=
HASH_ResultLenByOidTag
(
hashOid
)
;
CK_RSA_PKCS_PSS_PARAMS
rsaPssParams
=
{
hashMech
mgf
hLen
}
;
SECItem
params
=
{
siBuffer
reinterpret_cast
<
unsigned
char
*
>
(
&
rsaPssParams
)
sizeof
(
rsaPssParams
)
}
;
SECItem
spkiItem
=
{
siBuffer
toUcharPtr
(
spki
)
static_cast
<
unsigned
int
>
(
spki_len
)
}
;
ScopedCERTSubjectPublicKeyInfo
certSpki
(
SECKEY_DecodeDERSubjectPublicKeyInfo
(
&
spkiItem
)
)
;
ScopedSECKEYPublicKey
pubKey
(
SECKEY_ExtractPublicKey
(
certSpki
.
get
(
)
)
)
;
std
:
:
vector
<
uint8_t
>
hashBuf
(
hLen
)
;
SECItem
hash
=
{
siBuffer
hashBuf
.
data
(
)
static_cast
<
unsigned
int
>
(
hashBuf
.
size
(
)
)
}
;
SECStatus
rv
=
PK11_HashBuf
(
hashOid
hash
.
data
toUcharPtr
(
data
)
data_len
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
CK_MECHANISM_TYPE
mech
=
CKM_RSA_PKCS_PSS
;
SECItem
sigItem
=
{
siBuffer
toUcharPtr
(
sig
)
static_cast
<
unsigned
int
>
(
sig_len
)
}
;
rv
=
PK11_VerifyWithMechanism
(
pubKey
.
get
(
)
mech
&
params
&
sigItem
&
hash
nullptr
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
}
void
SignAndVerify
(
const
uint8_t
*
pkcs8
size_t
pkcs8_len
const
uint8_t
*
spki
size_t
spki_len
const
uint8_t
*
data
size_t
data_len
)
{
SECOidTag
hashOid
=
SEC_OID_SHA1
;
CK_MECHANISM_TYPE
hashMech
=
CKM_SHA_1
;
CK_RSA_PKCS_MGF_TYPE
mgf
=
CKG_MGF1_SHA1
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_TRUE
(
slot
)
;
SECItem
pkcs8Item
=
{
siBuffer
toUcharPtr
(
pkcs8
)
static_cast
<
unsigned
int
>
(
pkcs8_len
)
}
;
SECKEYPrivateKey
*
key
=
nullptr
;
SECStatus
rv
=
PK11_ImportDERPrivateKeyInfoAndReturnKey
(
slot
.
get
(
)
&
pkcs8Item
nullptr
nullptr
false
false
KU_ALL
&
key
nullptr
)
;
EXPECT_TRUE
(
rv
=
=
SECSuccess
&
&
!
!
key
)
;
ScopedSECKEYPrivateKey
privKey
(
key
)
;
unsigned
int
hLen
=
HASH_ResultLenByOidTag
(
hashOid
)
;
CK_RSA_PKCS_PSS_PARAMS
rsaPssParams
=
{
hashMech
mgf
hLen
}
;
SECItem
params
=
{
siBuffer
reinterpret_cast
<
unsigned
char
*
>
(
&
rsaPssParams
)
sizeof
(
rsaPssParams
)
}
;
std
:
:
vector
<
uint8_t
>
hashBuf
(
hLen
)
;
SECItem
hash
=
{
siBuffer
hashBuf
.
data
(
)
static_cast
<
unsigned
int
>
(
hashBuf
.
size
(
)
)
}
;
rv
=
PK11_HashBuf
(
hashOid
hash
.
data
toUcharPtr
(
data
)
data_len
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
uint32_t
len
=
PK11_SignatureLen
(
privKey
.
get
(
)
)
;
std
:
:
vector
<
uint8_t
>
sigBuf
(
len
)
;
SECItem
sig
=
{
siBuffer
sigBuf
.
data
(
)
static_cast
<
unsigned
int
>
(
sigBuf
.
size
(
)
)
}
;
CK_MECHANISM_TYPE
mech
=
CKM_RSA_PKCS_PSS
;
rv
=
PK11_SignWithMechanism
(
privKey
.
get
(
)
mech
&
params
&
sig
&
hash
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
Verify
(
spki
spki_len
data
data_len
sig
.
data
sig
.
len
)
;
}
}
;
#
define
PSS_TEST_VECTOR_VERIFY
(
spki
data
sig
)
\
Verify
(
spki
sizeof
(
spki
)
data
sizeof
(
data
)
sig
sizeof
(
sig
)
)
;
#
define
PSS_TEST_VECTOR_SIGN_VERIFY
(
pkcs8
spki
data
)
\
SignAndVerify
(
pkcs8
sizeof
(
pkcs8
)
spki
sizeof
(
spki
)
data
sizeof
(
data
)
)
;
TEST_F
(
Pkcs11RsaPssTest
GenerateAndSignAndVerify
)
{
SECOidTag
hashOid
=
SEC_OID_SHA256
;
CK_MECHANISM_TYPE
hashMech
=
CKM_SHA256
;
CK_RSA_PKCS_MGF_TYPE
mgf
=
CKG_MGF1_SHA256
;
PK11RSAGenParams
rsaGenParams
=
{
1024
0x10001
}
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
SECKEYPublicKey
*
pubKeyRaw
=
nullptr
;
ScopedSECKEYPrivateKey
privKey
(
PK11_GenerateKeyPair
(
slot
.
get
(
)
CKM_RSA_PKCS_KEY_PAIR_GEN
&
rsaGenParams
&
pubKeyRaw
false
false
nullptr
)
)
;
ASSERT_TRUE
(
!
!
privKey
&
&
pubKeyRaw
)
;
ScopedSECKEYPublicKey
pubKey
(
pubKeyRaw
)
;
uint8_t
dataBuf
[
50
]
;
SECItem
data
=
{
siBuffer
dataBuf
sizeof
(
dataBuf
)
}
;
unsigned
int
hLen
=
HASH_ResultLenByOidTag
(
hashOid
)
;
SECStatus
rv
=
PK11_GenerateRandomOnSlot
(
slot
.
get
(
)
data
.
data
data
.
len
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
std
:
:
vector
<
uint8_t
>
sigBuf
(
PK11_SignatureLen
(
privKey
.
get
(
)
)
)
;
SECItem
sig
=
{
siBuffer
&
sigBuf
[
0
]
static_cast
<
unsigned
int
>
(
sigBuf
.
size
(
)
)
}
;
CK_RSA_PKCS_PSS_PARAMS
rsaPssParams
=
{
hashMech
mgf
hLen
}
;
SECItem
params
=
{
siBuffer
reinterpret_cast
<
unsigned
char
*
>
(
&
rsaPssParams
)
sizeof
(
rsaPssParams
)
}
;
CK_MECHANISM_TYPE
mech
=
CKM_RSA_PKCS_PSS
;
rv
=
PK11_SignWithMechanism
(
privKey
.
get
(
)
mech
&
params
&
sig
&
data
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
rv
=
PK11_VerifyWithMechanism
(
pubKey
.
get
(
)
mech
&
params
&
sig
&
data
nullptr
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
data
.
data
[
0
]
^
=
0xff
;
rv
=
PK11_VerifyWithMechanism
(
pubKey
.
get
(
)
mech
&
params
&
sig
&
data
nullptr
)
;
EXPECT_EQ
(
rv
SECFailure
)
;
data
.
data
[
0
]
^
=
0xff
;
sig
.
data
[
0
]
^
=
0xff
;
rv
=
PK11_VerifyWithMechanism
(
pubKey
.
get
(
)
mech
&
params
&
sig
&
data
nullptr
)
;
EXPECT_EQ
(
rv
SECFailure
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature1
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector1Spki
kTestVector1Data
kTestVector1Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify1
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector1Pkcs8
kTestVector1Spki
kTestVector1Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature2
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector2Spki
kTestVector2Data
kTestVector2Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify2
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector2Pkcs8
kTestVector2Spki
kTestVector2Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature3
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector3Spki
kTestVector3Data
kTestVector3Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify3
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector3Pkcs8
kTestVector3Spki
kTestVector3Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature4
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector4Spki
kTestVector4Data
kTestVector4Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify4
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector4Pkcs8
kTestVector4Spki
kTestVector4Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature5
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector5Spki
kTestVector5Data
kTestVector5Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify5
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector5Pkcs8
kTestVector5Spki
kTestVector5Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature6
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector6Spki
kTestVector6Data
kTestVector6Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify6
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector6Pkcs8
kTestVector6Spki
kTestVector6Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature7
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector7Spki
kTestVector7Data
kTestVector7Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify7
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector7Pkcs8
kTestVector7Spki
kTestVector7Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature8
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector8Spki
kTestVector8Data
kTestVector8Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify8
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector8Pkcs8
kTestVector8Spki
kTestVector8Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature9
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector9Spki
kTestVector9Data
kTestVector9Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify9
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector9Pkcs8
kTestVector9Spki
kTestVector9Data
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
VerifyKnownSignature10
)
{
PSS_TEST_VECTOR_VERIFY
(
kTestVector10Spki
kTestVector10Data
kTestVector10Sig
)
;
}
TEST_F
(
Pkcs11RsaPssVectorTest
SignAndVerify10
)
{
PSS_TEST_VECTOR_SIGN_VERIFY
(
kTestVector10Pkcs8
kTestVector10Spki
kTestVector10Data
)
;
}
}
