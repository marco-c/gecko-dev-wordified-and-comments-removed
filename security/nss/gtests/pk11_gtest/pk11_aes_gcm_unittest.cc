#
include
<
memory
>
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
secerr
.
h
"
#
include
"
sechash
.
h
"
#
include
"
scoped_ptrs
.
h
"
#
include
"
gcm
-
vectors
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
util
.
h
"
namespace
nss_test
{
class
Pkcs11AesGcmTest
:
public
:
:
testing
:
:
TestWithParam
<
gcm_kat_value
>
{
protected
:
void
RunTest
(
const
gcm_kat_value
val
)
{
std
:
:
vector
<
uint8_t
>
key
=
hex_string_to_bytes
(
val
.
key
)
;
std
:
:
vector
<
uint8_t
>
iv
=
hex_string_to_bytes
(
val
.
iv
)
;
std
:
:
vector
<
uint8_t
>
plaintext
=
hex_string_to_bytes
(
val
.
plaintext
)
;
std
:
:
vector
<
uint8_t
>
aad
=
hex_string_to_bytes
(
val
.
additional_data
)
;
std
:
:
vector
<
uint8_t
>
result
=
hex_string_to_bytes
(
val
.
result
)
;
if
(
key
.
empty
(
)
)
{
return
;
}
CK_GCM_PARAMS
gcmParams
;
gcmParams
.
pIv
=
iv
.
data
(
)
;
gcmParams
.
ulIvLen
=
iv
.
size
(
)
;
gcmParams
.
pAAD
=
aad
.
data
(
)
;
gcmParams
.
ulAADLen
=
aad
.
size
(
)
;
gcmParams
.
ulTagBits
=
128
;
SECItem
params
=
{
siBuffer
reinterpret_cast
<
unsigned
char
*
>
(
&
gcmParams
)
sizeof
(
gcmParams
)
}
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
SECItem
keyItem
=
{
siBuffer
key
.
data
(
)
static_cast
<
unsigned
int
>
(
key
.
size
(
)
)
}
;
ScopedPK11SymKey
symKey
(
PK11_ImportSymKey
(
slot
.
get
(
)
mech
PK11_OriginUnwrap
CKA_ENCRYPT
&
keyItem
nullptr
)
)
;
EXPECT_TRUE
(
!
!
symKey
)
;
unsigned
int
outputLen
=
0
;
std
:
:
vector
<
uint8_t
>
output
(
plaintext
.
size
(
)
+
gcmParams
.
ulTagBits
/
8
)
;
SECStatus
rv
=
PK11_Encrypt
(
symKey
.
get
(
)
mech
&
params
output
.
data
(
)
&
outputLen
output
.
size
(
)
plaintext
.
data
(
)
plaintext
.
size
(
)
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
ASSERT_EQ
(
outputLen
output
.
size
(
)
)
;
EXPECT_EQ
(
result
output
)
;
unsigned
int
decryptedLen
=
0
;
std
:
:
vector
<
uint8_t
>
decrypted
(
output
.
size
(
)
)
;
rv
=
PK11_Decrypt
(
symKey
.
get
(
)
mech
&
params
decrypted
.
data
(
)
&
decryptedLen
decrypted
.
size
(
)
output
.
data
(
)
outputLen
)
;
EXPECT_EQ
(
rv
SECSuccess
)
;
ASSERT_EQ
(
decryptedLen
plaintext
.
size
(
)
)
;
EXPECT_EQ
(
plaintext
std
:
:
vector
<
uint8_t
>
(
decrypted
.
begin
(
)
decrypted
.
begin
(
)
+
decryptedLen
)
)
;
}
SECStatus
EncryptWithIV
(
std
:
:
vector
<
uint8_t
>
&
iv
)
{
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ScopedPK11SymKey
symKey
(
PK11_KeyGen
(
slot
.
get
(
)
mech
nullptr
16
nullptr
)
)
;
EXPECT_TRUE
(
!
!
symKey
)
;
std
:
:
vector
<
uint8_t
>
data
(
17
)
;
std
:
:
vector
<
uint8_t
>
output
(
33
)
;
std
:
:
vector
<
uint8_t
>
aad
(
0
)
;
CK_GCM_PARAMS
gcmParams
;
gcmParams
.
pIv
=
iv
.
data
(
)
;
gcmParams
.
ulIvLen
=
iv
.
size
(
)
;
gcmParams
.
pAAD
=
aad
.
data
(
)
;
gcmParams
.
ulAADLen
=
aad
.
size
(
)
;
gcmParams
.
ulTagBits
=
128
;
SECItem
params
=
{
siBuffer
reinterpret_cast
<
unsigned
char
*
>
(
&
gcmParams
)
sizeof
(
gcmParams
)
}
;
unsigned
int
outputLen
=
0
;
return
PK11_Encrypt
(
symKey
.
get
(
)
mech
&
params
output
.
data
(
)
&
outputLen
output
.
size
(
)
data
.
data
(
)
data
.
size
(
)
)
;
}
const
CK_MECHANISM_TYPE
mech
=
CKM_AES_GCM
;
}
;
TEST_P
(
Pkcs11AesGcmTest
TestVectors
)
{
RunTest
(
GetParam
(
)
)
;
}
INSTANTIATE_TEST_CASE_P
(
NISTTestVector
Pkcs11AesGcmTest
:
:
testing
:
:
ValuesIn
(
kGcmKatValues
)
)
;
TEST_F
(
Pkcs11AesGcmTest
ZeroLengthIV
)
{
std
:
:
vector
<
uint8_t
>
iv
(
0
)
;
EXPECT_EQ
(
EncryptWithIV
(
iv
)
SECFailure
)
;
}
TEST_F
(
Pkcs11AesGcmTest
AllZeroIV
)
{
std
:
:
vector
<
uint8_t
>
iv
(
16
0
)
;
EXPECT_EQ
(
EncryptWithIV
(
iv
)
SECSuccess
)
;
}
TEST_F
(
Pkcs11AesGcmTest
TwelveByteZeroIV
)
{
std
:
:
vector
<
uint8_t
>
iv
(
12
0
)
;
EXPECT_EQ
(
EncryptWithIV
(
iv
)
SECSuccess
)
;
}
}
