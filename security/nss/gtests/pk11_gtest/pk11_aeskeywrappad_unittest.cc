#
include
<
memory
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
nss
.
h
"
#
include
"
nss_scoped_ptrs
.
h
"
#
include
"
pk11pub
.
h
"
namespace
nss_test
{
class
Pkcs11AESKeyWrapPadTest
:
public
:
:
testing
:
:
Test
{
}
;
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapECKey
)
{
const
uint32_t
kwrappedBufLen
=
256
;
const
uint32_t
kPublicKeyLen
=
65
;
const
uint32_t
kOidLen
=
65
;
unsigned
char
param_buf
[
kOidLen
]
;
unsigned
char
unwrap_buf
[
kPublicKeyLen
]
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
SECItem
ecdsa_params
=
{
siBuffer
param_buf
sizeof
(
param_buf
)
}
;
SECOidData
*
oid_data
=
SECOID_FindOIDByTag
(
SEC_OID_SECG_EC_SECP256R1
)
;
ASSERT_NE
(
oid_data
nullptr
)
;
ecdsa_params
.
data
[
0
]
=
SEC_ASN1_OBJECT_ID
;
ecdsa_params
.
data
[
1
]
=
oid_data
-
>
oid
.
len
;
memcpy
(
ecdsa_params
.
data
+
2
oid_data
-
>
oid
.
data
oid_data
-
>
oid
.
len
)
;
ecdsa_params
.
len
=
oid_data
-
>
oid
.
len
+
2
;
SECKEYPublicKey
*
pub_tmp
;
ScopedSECKEYPublicKey
pub_key
;
ScopedSECKEYPrivateKey
priv_key
(
PK11_GenerateKeyPair
(
slot
.
get
(
)
CKM_EC_KEY_PAIR_GEN
&
ecdsa_params
&
pub_tmp
PR_FALSE
PR_TRUE
nullptr
)
)
;
ASSERT_NE
(
nullptr
priv_key
)
;
ASSERT_NE
(
nullptr
pub_tmp
)
;
pub_key
.
reset
(
pub_tmp
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
ScopedSECItem
wrapped
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
kwrappedBufLen
)
)
;
ScopedSECItem
param
(
PK11_ParamFromIV
(
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
)
)
;
SECStatus
rv
=
PK11_WrapPrivKey
(
slot
.
get
(
)
kek
.
get
(
)
priv_key
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
param
.
get
(
)
wrapped
.
get
(
)
nullptr
)
;
ASSERT_EQ
(
rv
SECSuccess
)
;
SECItem
pubKey
=
{
siBuffer
unwrap_buf
kPublicKeyLen
}
;
CK_ATTRIBUTE_TYPE
usages
[
]
=
{
CKA_SIGN
}
;
int
usageCount
=
1
;
ScopedSECKEYPrivateKey
unwrapped
(
PK11_UnwrapPrivKey
(
slot
.
get
(
)
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
param
.
get
(
)
wrapped
.
get
(
)
nullptr
&
pubKey
false
true
CKK_EC
usages
usageCount
nullptr
)
)
;
ASSERT_EQ
(
0
PORT_GetError
(
)
)
;
ASSERT_TRUE
(
!
!
unwrapped
)
;
SECKEYPrivateKey
*
tmp
=
PK11_UnwrapPrivKey
(
slot
.
get
(
)
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
wrapped
.
get
(
)
nullptr
&
pubKey
false
true
CKK_EC
usages
usageCount
nullptr
)
;
ASSERT_EQ
(
0
PORT_GetError
(
)
)
;
ASSERT_NE
(
nullptr
tmp
)
;
unwrapped
.
reset
(
tmp
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRsaKey
)
{
const
uint32_t
kwrappedBufLen
=
648
;
unsigned
char
unwrap_buf
[
kwrappedBufLen
]
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
PK11RSAGenParams
rsa_param
;
rsa_param
.
keySizeInBits
=
1024
;
rsa_param
.
pe
=
65537L
;
SECKEYPublicKey
*
pub_tmp
;
ScopedSECKEYPublicKey
pub_key
;
ScopedSECKEYPrivateKey
priv_key
(
PK11_GenerateKeyPair
(
slot
.
get
(
)
CKM_RSA_PKCS_KEY_PAIR_GEN
&
rsa_param
&
pub_tmp
PR_FALSE
PR_FALSE
nullptr
)
)
;
ASSERT_NE
(
nullptr
priv_key
)
;
ASSERT_NE
(
nullptr
pub_tmp
)
;
pub_key
.
reset
(
pub_tmp
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
ScopedSECItem
wrapped
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
kwrappedBufLen
)
)
;
ScopedSECItem
param
(
PK11_ParamFromIV
(
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
)
)
;
SECStatus
rv
=
PK11_WrapPrivKey
(
slot
.
get
(
)
kek
.
get
(
)
priv_key
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
param
.
get
(
)
wrapped
.
get
(
)
nullptr
)
;
ASSERT_EQ
(
rv
SECSuccess
)
;
SECItem
pubKey
=
{
siBuffer
unwrap_buf
kwrappedBufLen
}
;
CK_ATTRIBUTE_TYPE
usages
[
]
=
{
CKA_SIGN
}
;
int
usageCount
=
1
;
ScopedSECKEYPrivateKey
unwrapped
(
PK11_UnwrapPrivKey
(
slot
.
get
(
)
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
param
.
get
(
)
wrapped
.
get
(
)
nullptr
&
pubKey
false
false
CKK_EC
usages
usageCount
nullptr
)
)
;
ASSERT_EQ
(
0
PORT_GetError
(
)
)
;
ASSERT_TRUE
(
!
!
unwrapped
)
;
ScopedSECItem
priv_key_data
(
PK11_ExportDERPrivateKeyInfo
(
priv_key
.
get
(
)
nullptr
)
)
;
ScopedSECItem
unwrapped_data
(
PK11_ExportDERPrivateKeyInfo
(
unwrapped
.
get
(
)
nullptr
)
)
;
EXPECT_TRUE
(
!
!
priv_key_data
)
;
EXPECT_TRUE
(
!
!
unwrapped_data
)
;
ASSERT_EQ
(
priv_key_data
-
>
len
unwrapped_data
-
>
len
)
;
ASSERT_EQ
(
0
memcmp
(
priv_key_data
-
>
data
unwrapped_data
-
>
data
priv_key_data
-
>
len
)
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRandom_EvenBlock
)
{
const
uint32_t
kInputKeyLen
=
128
;
uint32_t
out_len
=
0
;
std
:
:
vector
<
unsigned
char
>
input_key
(
kInputKeyLen
)
;
std
:
:
vector
<
unsigned
char
>
wrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
std
:
:
vector
<
unsigned
char
>
unwrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
SECStatus
rv
=
PK11_GenerateRandom
(
input_key
.
data
(
)
input_key
.
size
(
)
)
;
EXPECT_EQ
(
SECSuccess
rv
)
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
rv
=
PK11_Encrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
wrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
wrapped_key
.
size
(
)
)
input_key
.
data
(
)
static_cast
<
unsigned
int
>
(
input_key
.
size
(
)
)
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
rv
=
PK11_Decrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
unwrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
unwrapped_key
.
size
(
)
)
wrapped_key
.
data
(
)
out_len
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
ASSERT_EQ
(
input_key
.
size
(
)
out_len
)
;
ASSERT_EQ
(
0
memcmp
(
input_key
.
data
(
)
unwrapped_key
.
data
(
)
out_len
)
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRandom_OddBlock1
)
{
const
uint32_t
kInputKeyLen
=
65
;
uint32_t
out_len
=
0
;
std
:
:
vector
<
unsigned
char
>
input_key
(
kInputKeyLen
)
;
std
:
:
vector
<
unsigned
char
>
wrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
std
:
:
vector
<
unsigned
char
>
unwrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
SECStatus
rv
=
PK11_GenerateRandom
(
input_key
.
data
(
)
input_key
.
size
(
)
)
;
EXPECT_EQ
(
SECSuccess
rv
)
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
rv
=
PK11_Encrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
wrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
wrapped_key
.
size
(
)
)
input_key
.
data
(
)
static_cast
<
unsigned
int
>
(
input_key
.
size
(
)
)
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
rv
=
PK11_Decrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
unwrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
unwrapped_key
.
size
(
)
)
wrapped_key
.
data
(
)
out_len
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
ASSERT_EQ
(
input_key
.
size
(
)
out_len
)
;
ASSERT_EQ
(
0
memcmp
(
input_key
.
data
(
)
unwrapped_key
.
data
(
)
out_len
)
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRandom_OddBlock2
)
{
const
uint32_t
kInputKeyLen
=
63
;
uint32_t
out_len
=
0
;
std
:
:
vector
<
unsigned
char
>
input_key
(
kInputKeyLen
)
;
std
:
:
vector
<
unsigned
char
>
wrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
std
:
:
vector
<
unsigned
char
>
unwrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
SECStatus
rv
=
PK11_GenerateRandom
(
input_key
.
data
(
)
input_key
.
size
(
)
)
;
EXPECT_EQ
(
SECSuccess
rv
)
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
rv
=
PK11_Encrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
wrapped_key
.
data
(
)
&
out_len
wrapped_key
.
size
(
)
input_key
.
data
(
)
input_key
.
size
(
)
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
rv
=
PK11_Decrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
unwrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
unwrapped_key
.
size
(
)
)
wrapped_key
.
data
(
)
out_len
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
ASSERT_EQ
(
input_key
.
size
(
)
out_len
)
;
ASSERT_EQ
(
0
memcmp
(
input_key
.
data
(
)
unwrapped_key
.
data
(
)
out_len
)
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRandom_PaddingTooLong
)
{
const
uint32_t
kInputKeyLen
=
32
;
uint32_t
out_len
=
0
;
const
unsigned
char
buf
[
32
]
=
{
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
0x20
}
;
std
:
:
vector
<
unsigned
char
>
wrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
std
:
:
vector
<
unsigned
char
>
unwrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
SECStatus
rv
=
PK11_Encrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP
nullptr
wrapped_key
.
data
(
)
&
out_len
wrapped_key
.
size
(
)
buf
sizeof
(
buf
)
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
rv
=
PK11_Decrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
unwrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
unwrapped_key
.
size
(
)
)
wrapped_key
.
data
(
)
out_len
)
;
ASSERT_EQ
(
SECFailure
rv
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRandom_NoPadding
)
{
const
uint32_t
kInputKeyLen
=
32
;
uint32_t
out_len
=
0
;
const
unsigned
char
buf
[
32
]
=
{
0
}
;
std
:
:
vector
<
unsigned
char
>
wrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
std
:
:
vector
<
unsigned
char
>
unwrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
SECStatus
rv
=
PK11_Encrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP
nullptr
wrapped_key
.
data
(
)
&
out_len
wrapped_key
.
size
(
)
buf
sizeof
(
buf
)
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
rv
=
PK11_Decrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
unwrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
unwrapped_key
.
size
(
)
)
wrapped_key
.
data
(
)
out_len
)
;
ASSERT_EQ
(
SECFailure
rv
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRandom_BadPadding1
)
{
const
uint32_t
kInputKeyLen
=
32
;
uint32_t
out_len
=
0
;
const
unsigned
char
buf
[
32
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x08
0x08
0x08
0x08
0x08
0x08
0x08
}
;
std
:
:
vector
<
unsigned
char
>
wrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
std
:
:
vector
<
unsigned
char
>
unwrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
SECStatus
rv
=
PK11_Encrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP
nullptr
wrapped_key
.
data
(
)
&
out_len
wrapped_key
.
size
(
)
buf
sizeof
(
buf
)
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
rv
=
PK11_Decrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
unwrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
unwrapped_key
.
size
(
)
)
wrapped_key
.
data
(
)
out_len
)
;
ASSERT_EQ
(
SECFailure
rv
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRandom_BadPadding2
)
{
const
uint32_t
kInputKeyLen
=
32
;
uint32_t
out_len
=
0
;
const
unsigned
char
buf
[
32
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
}
;
std
:
:
vector
<
unsigned
char
>
wrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
std
:
:
vector
<
unsigned
char
>
unwrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
SECStatus
rv
=
PK11_Encrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP
nullptr
wrapped_key
.
data
(
)
&
out_len
wrapped_key
.
size
(
)
buf
sizeof
(
buf
)
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
rv
=
PK11_Decrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
unwrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
unwrapped_key
.
size
(
)
)
wrapped_key
.
data
(
)
out_len
)
;
ASSERT_EQ
(
SECFailure
rv
)
;
}
TEST_F
(
Pkcs11AESKeyWrapPadTest
WrapUnwrapRandom_ShortValidPadding
)
{
const
uint32_t
kInputKeyLen
=
32
;
uint32_t
out_len
=
0
;
const
unsigned
char
buf
[
kInputKeyLen
]
=
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
}
;
std
:
:
vector
<
unsigned
char
>
wrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
std
:
:
vector
<
unsigned
char
>
unwrapped_key
(
kInputKeyLen
+
AES_BLOCK_SIZE
)
;
ScopedPK11SlotInfo
slot
(
PK11_GetInternalSlot
(
)
)
;
ASSERT_NE
(
nullptr
slot
)
;
ScopedPK11SymKey
kek
(
PK11_KeyGen
(
slot
.
get
(
)
CKM_AES_CBC
nullptr
16
nullptr
)
)
;
ASSERT_NE
(
nullptr
kek
)
;
SECStatus
rv
=
PK11_Encrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP
nullptr
wrapped_key
.
data
(
)
&
out_len
wrapped_key
.
size
(
)
buf
sizeof
(
buf
)
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
rv
=
PK11_Decrypt
(
kek
.
get
(
)
CKM_NSS_AES_KEY_WRAP_PAD
nullptr
unwrapped_key
.
data
(
)
&
out_len
static_cast
<
unsigned
int
>
(
unwrapped_key
.
size
(
)
)
wrapped_key
.
data
(
)
out_len
)
;
ASSERT_EQ
(
SECSuccess
rv
)
;
ASSERT_EQ
(
kInputKeyLen
-
1
out_len
)
;
ASSERT_EQ
(
0
memcmp
(
buf
unwrapped_key
.
data
(
)
out_len
)
)
;
}
}
