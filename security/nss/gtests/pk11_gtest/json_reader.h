#
ifndef
PK11GTEST_JSON_H_
#
define
PK11GTEST_JSON_H_
#
include
<
functional
>
#
include
<
iostream
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
nss_scoped_ptrs
.
h
"
#
include
"
secoidt
.
h
"
class
JsonReader
{
public
:
JsonReader
(
const
std
:
:
string
&
n
)
;
void
next
(
)
{
i_
+
+
;
}
uint8_t
peek
(
)
{
TopUp
(
)
;
return
buf_
[
i_
]
;
}
uint8_t
take
(
)
{
uint8_t
v
=
peek
(
)
;
next
(
)
;
return
v
;
}
uint64_t
ReadInt
(
)
;
std
:
:
string
ReadString
(
)
;
std
:
:
string
ReadLabel
(
)
;
std
:
:
vector
<
uint8_t
>
ReadHex
(
)
;
SECOidTag
ReadHash
(
)
;
SECStatus
ReadSECStatus
(
)
;
bool
ReadBool
(
)
;
bool
NextItem
(
uint8_t
h
=
'
{
'
uint8_t
t
=
'
}
'
)
;
bool
NextItemArray
(
)
{
return
NextItem
(
'
[
'
'
]
'
)
;
}
void
SkipValue
(
)
;
private
:
void
TopUp
(
)
;
void
SkipWhitespace
(
)
;
uint8_t
Hex
(
uint8_t
c
)
;
ScopedPRFileDesc
f_
;
uint8_t
buf_
[
4096
]
;
size_t
available_
;
size_t
i_
;
}
;
void
WycheproofHeader
(
const
std
:
:
string
&
name
const
std
:
:
string
&
algorithm
const
std
:
:
string
&
schema
std
:
:
function
<
void
(
JsonReader
&
r
)
>
group_handler
)
;
template
<
typename
T
>
struct
id
{
typedef
T
type
;
}
;
template
<
typename
T
>
using
nondeduced
=
typename
id
<
T
>
:
:
type
;
template
<
typename
T
>
void
WycheproofReadTests
(
JsonReader
&
r
std
:
:
vector
<
T
>
*
tests
const
std
:
:
function
<
nondeduced
<
void
(
T
&
const
std
:
:
string
&
JsonReader
&
)
>
>
&
attr_reader
bool
acceptable
=
true
const
std
:
:
function
<
nondeduced
<
void
(
T
&
const
std
:
:
string
&
const
std
:
:
vector
<
std
:
:
string
>
&
)
>
>
&
process_flags
=
nullptr
)
{
while
(
r
.
NextItemArray
(
)
)
{
T
tc
;
std
:
:
string
comment
;
std
:
:
string
result
;
std
:
:
vector
<
std
:
:
string
>
flags
;
while
(
r
.
NextItem
(
)
)
{
std
:
:
string
n
=
r
.
ReadLabel
(
)
;
if
(
n
=
=
"
"
)
{
break
;
}
if
(
n
=
=
"
tcId
"
)
{
tc
.
id
=
r
.
ReadInt
(
)
;
}
else
if
(
n
=
=
"
result
"
)
{
result
=
r
.
ReadString
(
)
;
}
else
if
(
n
=
=
"
comment
"
)
{
comment
=
r
.
ReadString
(
)
;
}
else
if
(
n
=
=
"
flags
"
)
{
while
(
r
.
NextItemArray
(
)
)
{
flags
.
push_back
(
r
.
ReadString
(
)
)
;
}
}
else
{
ASSERT_NO_FATAL_FAILURE
(
attr_reader
(
tc
n
r
)
)
;
}
}
tc
.
valid
=
(
result
=
=
"
valid
"
)
|
|
(
acceptable
&
&
result
=
=
"
acceptable
"
)
;
if
(
process_flags
)
{
process_flags
(
tc
result
flags
)
;
}
std
:
:
cout
<
<
"
tc
"
<
<
tc
.
id
<
<
"
:
"
<
<
comment
<
<
"
[
"
<
<
result
;
for
(
auto
&
f
:
flags
)
{
std
:
:
cout
<
<
"
"
<
<
f
;
}
std
:
:
cout
<
<
"
]
expect
"
<
<
(
tc
.
valid
?
"
success
"
:
"
failure
"
)
<
<
std
:
:
endl
;
tests
-
>
push_back
(
tc
)
;
}
}
#
endif
