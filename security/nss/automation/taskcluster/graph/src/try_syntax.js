import
*
as
queue
from
"
.
/
queue
"
;
import
intersect
from
"
intersect
"
;
import
parse_args
from
"
minimist
"
;
import
util
from
"
util
"
;
import
child_process
from
'
child_process
'
;
let
execFile
=
util
.
promisify
(
child_process
.
execFile
)
;
function
parseOptions
(
opts
)
{
opts
=
parse_args
(
opts
.
split
(
/
\
s
+
/
)
{
default
:
{
build
:
"
do
"
platform
:
"
all
"
unittests
:
"
none
"
tools
:
"
none
"
}
alias
:
{
b
:
"
build
"
p
:
"
platform
"
u
:
"
unittests
"
t
:
"
tools
"
e
:
"
extra
-
builds
"
}
string
:
[
"
build
"
"
platform
"
"
unittests
"
"
tools
"
"
extra
-
builds
"
]
}
)
;
let
builds
=
intersect
(
opts
.
build
.
split
(
"
"
)
[
"
d
"
"
o
"
]
)
;
if
(
builds
.
length
=
=
0
)
{
builds
=
[
"
d
"
"
o
"
]
;
}
let
allPlatforms
=
[
"
linux
"
"
linux64
"
"
linux64
-
asan
"
"
linux64
-
fips
"
"
win
"
"
win64
"
"
win
-
make
"
"
win64
-
make
"
"
linux64
-
make
"
"
linux
-
make
"
"
linux
-
fuzz
"
"
linux64
-
fuzz
"
"
aarch64
"
"
mac
"
]
;
let
platforms
=
intersect
(
opts
.
platform
.
split
(
/
\
s
*
\
s
*
/
)
allPlatforms
)
;
if
(
platforms
.
length
=
=
0
&
&
opts
.
platform
!
=
"
none
"
)
{
platforms
=
allPlatforms
;
}
let
aliases
=
{
"
gtests
"
:
"
gtest
"
}
;
let
allUnitTests
=
[
"
bogo
"
"
crmf
"
"
chains
"
"
cipher
"
"
db
"
"
ec
"
"
fips
"
"
gtest
"
"
interop
"
"
lowhash
"
"
merge
"
"
sdr
"
"
smime
"
"
tools
"
"
ssl
"
"
mpi
"
"
scert
"
"
spki
"
"
policy
"
"
tlsfuzzer
"
]
;
let
unittests
=
intersect
(
opts
.
unittests
.
split
(
/
\
s
*
\
s
*
/
)
.
map
(
t
=
>
{
return
aliases
[
t
]
|
|
t
;
}
)
allUnitTests
)
;
if
(
opts
.
unittests
=
=
"
all
"
)
{
unittests
=
allUnitTests
;
}
else
if
(
unittests
.
length
=
=
0
)
{
unittests
=
[
]
;
}
let
allTools
=
[
"
clang
-
format
"
"
scan
-
build
"
"
hacl
"
"
saw
"
"
abi
"
"
coverage
"
]
;
let
tools
=
intersect
(
opts
.
tools
.
split
(
/
\
s
*
\
s
*
/
)
allTools
)
;
if
(
opts
.
tools
=
=
"
all
"
)
{
tools
=
allTools
;
}
else
if
(
tools
.
length
=
=
0
)
{
tools
=
[
]
;
}
return
{
builds
:
builds
platforms
:
platforms
unittests
:
unittests
extra
:
(
opts
.
e
=
=
"
all
"
)
tools
:
tools
}
;
}
function
filter
(
opts
)
{
return
function
(
task
)
{
if
(
task
.
platform
=
=
"
nss
-
tools
"
)
{
return
opts
.
tools
.
some
(
tool
=
>
{
return
task
.
symbol
.
toLowerCase
(
)
.
startsWith
(
tool
)
|
|
(
task
.
group
&
&
task
.
group
.
toLowerCase
(
)
.
startsWith
(
tool
)
)
;
}
)
;
}
if
(
task
.
tests
)
{
let
found
=
opts
.
unittests
.
some
(
test
=
>
{
if
(
task
.
group
&
&
task
.
group
.
toLowerCase
(
)
=
=
"
ssl
"
&
&
test
=
=
"
ssl
"
)
{
return
true
;
}
if
(
task
.
group
&
&
task
.
group
.
toLowerCase
(
)
=
=
"
cipher
"
&
&
test
=
=
"
cipher
"
)
{
return
true
;
}
return
task
.
symbol
.
toLowerCase
(
)
.
startsWith
(
test
)
;
}
)
;
if
(
!
found
)
{
return
false
;
}
}
if
(
task
.
group
=
=
"
Builds
"
&
&
!
opts
.
extra
)
{
return
false
;
}
let
coll
=
name
=
>
name
=
=
(
task
.
collection
|
|
"
opt
"
)
;
let
found
=
opts
.
platforms
.
some
(
platform
=
>
{
let
aliases
=
{
"
linux
"
:
"
linux32
"
"
linux
-
fuzz
"
:
"
linux32
"
"
linux64
-
asan
"
:
"
linux64
"
"
linux64
-
fips
"
:
"
linux64
"
"
linux64
-
fuzz
"
:
"
linux64
"
"
linux64
-
make
"
:
"
linux64
"
"
linux
-
make
"
:
"
linux32
"
"
win64
-
make
"
:
"
windows2012
-
64
"
"
win
-
make
"
:
"
windows2012
-
32
"
"
win64
"
:
"
windows2012
-
64
"
"
win
"
:
"
windows2012
-
32
"
}
;
let
keep
=
(
task
.
platform
=
=
(
aliases
[
platform
]
|
|
platform
)
)
;
if
(
platform
=
=
"
linux64
-
asan
"
)
{
keep
&
=
coll
(
"
asan
"
)
;
}
else
if
(
platform
=
=
"
linux64
-
fips
"
)
{
keep
&
=
coll
(
"
fips
"
)
;
}
else
if
(
platform
=
=
"
linux64
-
make
"
|
|
platform
=
=
"
linux
-
make
"
|
|
platform
=
=
"
win64
-
make
"
|
|
platform
=
=
"
win
-
make
"
)
{
keep
&
=
coll
(
"
make
"
)
;
}
else
if
(
platform
=
=
"
linux64
-
fuzz
"
|
|
platform
=
=
"
linux
-
fuzz
"
)
{
keep
&
=
coll
(
"
fuzz
"
)
;
}
else
{
keep
&
=
coll
(
"
opt
"
)
|
|
coll
(
"
debug
"
)
;
}
return
keep
;
}
)
;
if
(
!
found
)
{
return
false
;
}
let
isDebug
=
coll
(
"
debug
"
)
|
|
coll
(
"
asan
"
)
|
|
coll
(
"
make
"
)
|
|
coll
(
"
fuzz
"
)
;
return
(
isDebug
&
&
opts
.
builds
.
includes
(
"
d
"
)
)
|
|
(
!
isDebug
&
&
opts
.
builds
.
includes
(
"
o
"
)
)
;
}
}
async
function
getCommitComment
(
)
{
const
res
=
await
execFile
(
'
hg
'
[
'
log
'
'
-
r
'
'
.
'
'
-
T
'
'
{
desc
}
'
]
)
;
return
res
.
stdout
;
}
;
export
async
function
initFilter
(
)
{
let
comment
=
await
getCommitComment
(
)
;
let
match
=
comment
.
match
(
/
^
\
s
*
try
:
\
s
*
(
.
*
)
\
s
*
/
)
;
if
(
match
)
{
queue
.
filter
(
filter
(
parseOptions
(
match
[
1
]
)
)
)
;
}
}
