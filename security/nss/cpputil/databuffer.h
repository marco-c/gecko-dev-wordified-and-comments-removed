#
ifndef
databuffer_h__
#
define
databuffer_h__
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
iomanip
>
#
include
<
iostream
>
namespace
nss_test
{
class
DataBuffer
{
public
:
DataBuffer
(
)
:
data_
(
nullptr
)
len_
(
0
)
{
}
DataBuffer
(
const
uint8_t
*
d
size_t
l
)
:
data_
(
nullptr
)
len_
(
0
)
{
Assign
(
d
l
)
;
}
DataBuffer
(
const
DataBuffer
&
other
)
:
data_
(
nullptr
)
len_
(
0
)
{
Assign
(
other
)
;
}
explicit
DataBuffer
(
size_t
l
)
:
data_
(
nullptr
)
len_
(
0
)
{
Allocate
(
l
)
;
}
~
DataBuffer
(
)
{
delete
[
]
data_
;
}
DataBuffer
&
operator
=
(
const
DataBuffer
&
other
)
{
if
(
&
other
!
=
this
)
{
Assign
(
other
)
;
}
return
*
this
;
}
DataBuffer
&
operator
=
(
DataBuffer
&
&
other
)
{
if
(
this
!
=
&
other
)
{
delete
[
]
data_
;
data_
=
other
.
data_
;
len_
=
other
.
len_
;
other
.
data_
=
nullptr
;
other
.
len_
=
0
;
}
return
*
this
;
}
void
Allocate
(
size_t
l
)
{
delete
[
]
data_
;
data_
=
new
uint8_t
[
l
?
l
:
1
]
(
)
;
len_
=
l
;
}
void
Truncate
(
size_t
l
)
{
len_
=
(
std
:
:
min
)
(
len_
l
)
;
}
void
Assign
(
const
DataBuffer
&
other
)
{
Assign
(
other
.
data
(
)
other
.
len
(
)
)
;
}
void
Assign
(
const
uint8_t
*
d
size_t
l
)
;
size_t
Write
(
size_t
index
const
uint8_t
*
val
size_t
count
)
;
size_t
Write
(
size_t
index
const
DataBuffer
&
buf
)
{
return
Write
(
index
buf
.
data
(
)
buf
.
len
(
)
)
;
}
size_t
Write
(
size_t
index
uint32_t
val
size_t
count
)
;
void
Splice
(
const
DataBuffer
&
buf
size_t
index
size_t
remove
=
0
)
{
Splice
(
buf
.
data
(
)
buf
.
len
(
)
index
remove
)
;
}
void
Splice
(
const
uint8_t
*
ins
size_t
ins_len
size_t
index
size_t
remove
=
0
)
;
void
Append
(
const
DataBuffer
&
buf
)
{
Splice
(
buf
len_
)
;
}
bool
Read
(
size_t
index
size_t
count
uint64_t
*
val
)
const
;
bool
Read
(
size_t
index
size_t
count
uint32_t
*
val
)
const
;
const
uint8_t
*
data
(
)
const
{
return
data_
;
}
uint8_t
*
data
(
)
{
return
data_
;
}
size_t
len
(
)
const
{
return
len_
;
}
bool
empty
(
)
const
{
return
len_
=
=
0
;
}
static
void
SetLogLimit
(
size_t
limit
)
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
stream
const
DataBuffer
&
buf
)
;
private
:
static
size_t
logging_limit
;
uint8_t
*
data_
;
size_t
len_
;
}
;
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
stream
const
DataBuffer
&
buf
)
{
stream
<
<
"
[
"
<
<
buf
.
len
(
)
<
<
"
]
"
;
for
(
size_t
i
=
0
;
i
<
buf
.
len
(
)
;
+
+
i
)
{
if
(
i
>
=
DataBuffer
:
:
logging_limit
)
{
stream
<
<
"
.
.
.
"
;
break
;
}
stream
<
<
std
:
:
hex
<
<
std
:
:
setfill
(
'
0
'
)
<
<
std
:
:
setw
(
2
)
<
<
static_cast
<
unsigned
>
(
buf
.
data
(
)
[
i
]
)
;
}
stream
<
<
std
:
:
dec
;
return
stream
;
}
inline
bool
operator
=
=
(
const
DataBuffer
&
a
const
DataBuffer
&
b
)
{
return
(
a
.
empty
(
)
&
&
b
.
empty
(
)
)
|
|
(
a
.
len
(
)
=
=
b
.
len
(
)
&
&
0
=
=
memcmp
(
a
.
data
(
)
b
.
data
(
)
a
.
len
(
)
)
)
;
}
inline
bool
operator
!
=
(
const
DataBuffer
&
a
const
DataBuffer
&
b
)
{
return
!
(
a
=
=
b
)
;
}
}
#
endif
