#
include
"
OSReauthenticator
.
h
"
#
include
"
OSKeyStore
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ipc
/
IPCMessageUtils
.
h
"
NS_IMPL_ISUPPORTS
(
OSReauthenticator
nsIOSReauthenticator
)
extern
mozilla
:
:
LazyLogModule
gCredentialManagerSecretLog
;
using
mozilla
:
:
LogLevel
;
using
mozilla
:
:
WindowsHandle
;
using
mozilla
:
:
dom
:
:
Promise
;
#
if
defined
(
XP_WIN
)
#
include
<
combaseapi
.
h
>
#
include
<
ntsecapi
.
h
>
#
include
<
wincred
.
h
>
#
include
<
windows
.
h
>
#
define
SECURITY_WIN32
#
include
<
security
.
h
>
#
include
<
shlwapi
.
h
>
struct
HandleCloser
{
typedef
HANDLE
pointer
;
void
operator
(
)
(
HANDLE
h
)
{
if
(
h
!
=
INVALID_HANDLE_VALUE
)
{
CloseHandle
(
h
)
;
}
}
}
;
struct
BufferFreer
{
typedef
LPVOID
pointer
;
void
operator
(
)
(
LPVOID
b
)
{
CoTaskMemFree
(
b
)
;
}
}
;
typedef
std
:
:
unique_ptr
<
HANDLE
HandleCloser
>
ScopedHANDLE
;
typedef
std
:
:
unique_ptr
<
LPVOID
BufferFreer
>
ScopedBuffer
;
std
:
:
unique_ptr
<
char
[
]
>
GetTokenInfo
(
ScopedHANDLE
&
token
)
{
DWORD
length
=
0
;
mozilla
:
:
Unused
<
<
GetTokenInformation
(
token
.
get
(
)
TokenUser
nullptr
0
&
length
)
;
if
(
!
length
|
|
GetLastError
(
)
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Unable
to
obtain
current
token
info
.
"
)
)
;
return
nullptr
;
}
std
:
:
unique_ptr
<
char
[
]
>
token_info
(
new
char
[
length
]
)
;
if
(
!
GetTokenInformation
(
token
.
get
(
)
TokenUser
token_info
.
get
(
)
length
&
length
)
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Unable
to
obtain
current
token
info
(
second
call
possible
"
"
system
error
.
"
)
)
;
return
nullptr
;
}
return
token_info
;
}
std
:
:
unique_ptr
<
char
[
]
>
GetUserTokenInfo
(
)
{
HANDLE
token
;
if
(
!
OpenProcessToken
(
GetCurrentProcess
(
)
TOKEN_QUERY
&
token
)
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Unable
to
obtain
process
token
.
"
)
)
;
return
nullptr
;
}
ScopedHANDLE
scopedToken
(
token
)
;
return
GetTokenInfo
(
scopedToken
)
;
}
static
nsresult
ReauthenticateUserWindows
(
const
nsAString
&
aMessageText
const
nsAString
&
aCaptionText
const
WindowsHandle
&
hwndParent
bool
&
reauthenticated
bool
&
isBlankPassword
)
{
reauthenticated
=
false
;
isBlankPassword
=
false
;
DWORD
usernameLength
=
CREDUI_MAX_USERNAME_LENGTH
+
1
;
WCHAR
username
[
CREDUI_MAX_USERNAME_LENGTH
+
1
]
=
{
0
}
;
if
(
!
GetUserNameEx
(
NameSamCompatible
username
&
usernameLength
)
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Error
getting
username
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
IsOS
(
OS_DOMAINMEMBER
)
)
{
HANDLE
logonUserHandle
=
nullptr
;
bool
result
=
LogonUser
(
username
L
"
.
"
L
"
"
LOGON32_LOGON_INTERACTIVE
LOGON32_PROVIDER_DEFAULT
&
logonUserHandle
)
;
if
(
result
|
|
GetLastError
(
)
=
=
ERROR_ACCOUNT_RESTRICTION
)
{
if
(
logonUserHandle
&
&
logonUserHandle
!
=
INVALID_HANDLE_VALUE
)
{
CloseHandle
(
logonUserHandle
)
;
}
reauthenticated
=
true
;
isBlankPassword
=
true
;
return
NS_OK
;
}
}
DWORD
err
=
0
;
std
:
:
unique_ptr
<
char
[
]
>
userTokenInfo
=
GetUserTokenInfo
(
)
;
CREDUI_INFOW
credui
=
{
}
;
credui
.
cbSize
=
sizeof
(
credui
)
;
credui
.
hwndParent
=
reinterpret_cast
<
HWND
>
(
hwndParent
)
;
const
nsString
&
messageText
=
PromiseFlatString
(
aMessageText
)
;
credui
.
pszMessageText
=
messageText
.
get
(
)
;
const
nsString
&
captionText
=
PromiseFlatString
(
aCaptionText
)
;
credui
.
pszCaptionText
=
captionText
.
get
(
)
;
credui
.
hbmBanner
=
nullptr
;
while
(
!
reauthenticated
)
{
HANDLE
lsa
;
if
(
LsaConnectUntrusted
(
&
lsa
)
!
=
ERROR_SUCCESS
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Error
acquiring
lsa
.
Authentication
attempts
will
fail
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
ScopedHANDLE
scopedLsa
(
lsa
)
;
if
(
!
userTokenInfo
|
|
lsa
=
=
INVALID_HANDLE_VALUE
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Error
setting
up
login
and
user
token
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
ULONG
authPackage
=
0
;
ULONG
outCredSize
=
0
;
LPVOID
outCredBuffer
=
nullptr
;
BOOL
save
=
false
;
err
=
CredUIPromptForWindowsCredentialsW
(
&
credui
err
&
authPackage
nullptr
0
&
outCredBuffer
&
outCredSize
&
save
CREDUIWIN_ENUMERATE_CURRENT_USER
)
;
ScopedBuffer
scopedOutCredBuffer
(
outCredBuffer
)
;
if
(
err
=
=
ERROR_CANCELLED
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Error
getting
authPackage
for
user
login
user
cancel
.
"
)
)
;
return
NS_OK
;
}
if
(
err
!
=
ERROR_SUCCESS
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Error
getting
authPackage
for
user
login
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
TOKEN_SOURCE
source
;
PCHAR
contextName
=
const_cast
<
PCHAR
>
(
"
Mozilla
"
)
;
size_t
nameLength
=
std
:
:
min
(
TOKEN_SOURCE_LENGTH
static_cast
<
int
>
(
strlen
(
contextName
)
)
)
;
memcpy
(
source
.
SourceName
contextName
nameLength
)
;
if
(
!
AllocateLocallyUniqueId
(
&
source
.
SourceIdentifier
)
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Error
allocating
ID
for
logon
process
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
NTSTATUS
substs
;
void
*
profileBuffer
=
nullptr
;
ULONG
profileBufferLength
=
0
;
QUOTA_LIMITS
limits
=
{
0
}
;
LUID
luid
;
HANDLE
token
;
LSA_STRING
name
;
name
.
Buffer
=
contextName
;
name
.
Length
=
strlen
(
name
.
Buffer
)
;
name
.
MaximumLength
=
name
.
Length
;
NTSTATUS
sts
=
LsaLogonUser
(
scopedLsa
.
get
(
)
&
name
(
SECURITY_LOGON_TYPE
)
Interactive
authPackage
scopedOutCredBuffer
.
get
(
)
outCredSize
nullptr
&
source
&
profileBuffer
&
profileBufferLength
&
luid
&
token
&
limits
&
substs
)
;
ScopedHANDLE
scopedToken
(
token
)
;
LsaFreeReturnBuffer
(
profileBuffer
)
;
LsaDeregisterLogonProcess
(
scopedLsa
.
get
(
)
)
;
if
(
sts
=
=
ERROR_SUCCESS
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
User
logged
in
successfully
.
"
)
)
;
}
else
{
err
=
LsaNtStatusToWinError
(
sts
)
;
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Login
failed
with
%
lx
(
%
lx
)
.
"
sts
err
)
)
;
continue
;
}
std
:
:
unique_ptr
<
char
[
]
>
logonTokenInfo
=
GetTokenInfo
(
scopedToken
)
;
if
(
!
logonTokenInfo
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Error
getting
logon
token
info
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
PSID
logonSID
=
reinterpret_cast
<
TOKEN_USER
*
>
(
logonTokenInfo
.
get
(
)
)
-
>
User
.
Sid
;
PSID
userSID
=
reinterpret_cast
<
TOKEN_USER
*
>
(
userTokenInfo
.
get
(
)
)
-
>
User
.
Sid
;
if
(
EqualSid
(
userSID
logonSID
)
)
{
MOZ_LOG
(
gCredentialManagerSecretLog
LogLevel
:
:
Debug
(
"
Login
successfully
(
correct
user
)
.
"
)
)
;
reauthenticated
=
true
;
break
;
}
else
{
err
=
ERROR_LOGON_FAILURE
;
}
}
return
NS_OK
;
}
#
endif
static
nsresult
ReauthenticateUser
(
const
nsAString
&
prompt
const
nsAString
&
caption
const
WindowsHandle
&
hwndParent
bool
&
reauthenticated
bool
&
isBlankPassword
)
{
reauthenticated
=
false
;
isBlankPassword
=
false
;
#
if
defined
(
XP_WIN
)
return
ReauthenticateUserWindows
(
prompt
caption
hwndParent
reauthenticated
isBlankPassword
)
;
#
elif
defined
(
XP_MACOSX
)
return
ReauthenticateUserMacOS
(
prompt
reauthenticated
isBlankPassword
)
;
#
endif
return
NS_OK
;
}
static
void
BackgroundReauthenticateUser
(
RefPtr
<
Promise
>
&
aPromise
const
nsAString
&
aMessageText
const
nsAString
&
aCaptionText
const
WindowsHandle
&
hwndParent
)
{
nsAutoCString
recovery
;
bool
reauthenticated
;
bool
isBlankPassword
;
nsresult
rv
=
ReauthenticateUser
(
aMessageText
aCaptionText
hwndParent
reauthenticated
isBlankPassword
)
;
nsTArray
<
bool
>
results
(
2
)
;
results
.
AppendElement
(
reauthenticated
)
;
results
.
AppendElement
(
isBlankPassword
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
BackgroundReauthenticateUserResolve
"
[
rv
results
=
std
:
:
move
(
results
)
aPromise
=
std
:
:
move
(
aPromise
)
]
(
)
{
if
(
NS_FAILED
(
rv
)
)
{
aPromise
-
>
MaybeReject
(
rv
)
;
}
else
{
aPromise
-
>
MaybeResolve
(
results
)
;
}
}
)
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
NS_IMETHODIMP
OSReauthenticator
:
:
AsyncReauthenticateUser
(
const
nsAString
&
aMessageText
const
nsAString
&
aCaptionText
mozIDOMWindow
*
aParentWindow
JSContext
*
aCx
Promise
*
*
promiseOut
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
RefPtr
<
Promise
>
promiseHandle
;
nsresult
rv
=
GetPromise
(
aCx
promiseHandle
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
WindowsHandle
hwndParent
=
0
;
if
(
aParentWindow
)
{
nsPIDOMWindowInner
*
win
=
nsPIDOMWindowInner
:
:
From
(
aParentWindow
)
;
nsIDocShell
*
docShell
=
win
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
docShell
)
;
if
(
baseWindow
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
baseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
)
{
hwndParent
=
reinterpret_cast
<
WindowsHandle
>
(
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
;
}
}
}
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
BackgroundReauthenticateUser
"
[
promiseHandle
aMessageText
=
nsAutoString
(
aMessageText
)
aCaptionText
=
nsAutoString
(
aCaptionText
)
hwndParent
]
(
)
mutable
{
BackgroundReauthenticateUser
(
promiseHandle
aMessageText
aCaptionText
hwndParent
)
;
}
)
)
;
nsCOMPtr
<
nsIEventTarget
>
target
(
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
)
;
if
(
!
target
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
target
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
promiseHandle
.
forget
(
promiseOut
)
;
return
NS_OK
;
}
