#
include
"
PKCS11ModuleDB
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsNSSCertHelper
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsPKCS11Slot
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
namespace
mozilla
{
namespace
psm
{
NS_IMPL_ISUPPORTS
(
PKCS11ModuleDB
nsIPKCS11ModuleDB
)
static
nsresult
NormalizeModuleNameIn
(
const
nsAString
&
moduleNameIn
nsCString
&
moduleNameOut
)
{
nsAutoString
localizedRootModuleName
;
nsresult
rv
=
GetPIPNSSBundleString
(
"
RootCertModuleName
"
localizedRootModuleName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
moduleNameIn
.
Equals
(
localizedRootModuleName
)
)
{
moduleNameOut
.
Assign
(
kRootModuleName
)
;
return
NS_OK
;
}
moduleNameOut
.
Assign
(
NS_ConvertUTF16toUTF8
(
moduleNameIn
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
DeleteModule
(
const
nsAString
&
aModuleName
)
{
if
(
aModuleName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
moduleNameNormalized
;
nsresult
rv
=
NormalizeModuleNameIn
(
aModuleName
moduleNameNormalized
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
modType
;
SECStatus
srv
=
SECMOD_DeleteModule
(
moduleNameNormalized
.
get
(
)
&
modType
)
;
if
(
srv
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
GetModuleNameForTelemetry
(
const
SECMODModule
*
module
nsString
&
result
)
{
result
.
Truncate
(
)
;
if
(
module
-
>
dllName
)
{
result
.
AssignASCII
(
module
-
>
dllName
)
;
int32_t
separatorIndex
=
result
.
RFind
(
FILE_PATH_SEPARATOR
)
;
if
(
separatorIndex
!
=
kNotFound
)
{
result
=
Substring
(
result
separatorIndex
+
1
)
;
}
}
else
{
result
.
AssignASCII
(
module
-
>
commonName
)
;
}
if
(
result
.
Length
(
)
>
=
70
)
{
result
.
Truncate
(
69
)
;
}
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
AddModule
(
const
nsAString
&
aModuleName
const
nsAString
&
aLibraryFullPath
int32_t
aCryptoMechanismFlags
int32_t
aCipherFlags
)
{
if
(
aModuleName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aModuleName
.
EqualsLiteral
(
"
Root
Certs
"
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsresult
rv
=
BlockUntilLoadableRootsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
moduleNameNormalized
;
rv
=
NormalizeModuleNameIn
(
aModuleName
moduleNameNormalized
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCString
fullPath
;
NS_CopyUnicodeToNative
(
aLibraryFullPath
fullPath
)
;
uint32_t
mechFlags
=
SECMOD_PubMechFlagstoInternal
(
aCryptoMechanismFlags
)
;
uint32_t
cipherFlags
=
SECMOD_PubCipherFlagstoInternal
(
aCipherFlags
)
;
SECStatus
srv
=
SECMOD_AddNewModule
(
moduleNameNormalized
.
get
(
)
fullPath
.
get
(
)
mechFlags
cipherFlags
)
;
if
(
srv
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
UniqueSECMODModule
module
(
SECMOD_FindModule
(
moduleNameNormalized
.
get
(
)
)
)
;
if
(
!
module
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
scalarKey
;
GetModuleNameForTelemetry
(
module
.
get
(
)
scalarKey
)
;
if
(
scalarKey
.
Length
(
)
>
0
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
SECURITY_PKCS11_MODULES_LOADED
scalarKey
true
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
FindModuleByName
(
const
nsAString
&
name
nsIPKCS11Module
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
nsresult
rv
=
BlockUntilLoadableRootsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
moduleNameNormalized
;
rv
=
NormalizeModuleNameIn
(
name
moduleNameNormalized
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
UniqueSECMODModule
mod
(
SECMOD_FindModule
(
moduleNameNormalized
.
get
(
)
)
)
;
if
(
!
mod
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPKCS11Module
>
module
=
new
nsPKCS11Module
(
mod
.
get
(
)
)
;
module
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
ListModules
(
nsISimpleEnumerator
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
nsresult
rv
=
BlockUntilLoadableRootsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIMutableArray
>
array
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
if
(
!
array
)
{
return
NS_ERROR_FAILURE
;
}
AutoSECMODListReadLock
lock
;
for
(
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
nsCOMPtr
<
nsIPKCS11Module
>
module
=
new
nsPKCS11Module
(
list
-
>
module
)
;
nsresult
rv
=
array
-
>
AppendElement
(
module
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
SECMODModuleList
*
list
=
SECMOD_GetDeadModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
nsCOMPtr
<
nsIPKCS11Module
>
module
=
new
nsPKCS11Module
(
list
-
>
module
)
;
nsresult
rv
=
array
-
>
AppendElement
(
module
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
array
-
>
Enumerate
(
_retval
)
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
GetCanToggleFIPS
(
bool
*
aCanToggleFIPS
)
{
NS_ENSURE_ARG_POINTER
(
aCanToggleFIPS
)
;
*
aCanToggleFIPS
=
SECMOD_CanDeleteInternalModule
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
ToggleFIPSMode
(
)
{
SECMODModule
*
internal
=
SECMOD_GetInternalModule
(
)
;
if
(
!
internal
)
{
return
NS_ERROR_FAILURE
;
}
if
(
SECMOD_DeleteInternalModule
(
internal
-
>
commonName
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
if
(
PK11_IsFIPS
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FIPS_ENABLED
true
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
GetIsFIPSEnabled
(
bool
*
aIsFIPSEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aIsFIPSEnabled
)
;
*
aIsFIPSEnabled
=
PK11_IsFIPS
(
)
;
return
NS_OK
;
}
}
}
