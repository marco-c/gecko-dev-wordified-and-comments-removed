#
include
"
PKCS11ModuleDB
.
h
"
#
include
"
CertVerifier
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
mozilla
/
glean
/
SecurityManagerSslMetrics
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsNSSCertHelper
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsPKCS11Slot
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
if
defined
(
XP_MACOSX
)
#
include
"
nsMacUtilsImpl
.
h
"
#
include
"
nsIFile
.
h
"
#
endif
namespace
mozilla
{
namespace
psm
{
NS_IMPL_ISUPPORTS
(
PKCS11ModuleDB
nsIPKCS11ModuleDB
)
static
nsresult
NormalizeModuleNameIn
(
const
nsAString
&
moduleNameIn
nsCString
&
moduleNameOut
)
{
nsAutoString
localizedRootModuleName
;
nsresult
rv
=
GetPIPNSSBundleString
(
"
RootCertModuleName
"
localizedRootModuleName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
moduleNameIn
.
Equals
(
localizedRootModuleName
)
)
{
moduleNameOut
.
Assign
(
kRootModuleName
.
get
(
)
)
;
return
NS_OK
;
}
moduleNameOut
.
Assign
(
NS_ConvertUTF16toUTF8
(
moduleNameIn
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
DeleteModule
(
const
nsAString
&
aModuleName
)
{
if
(
aModuleName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
moduleNameNormalized
;
nsresult
rv
=
NormalizeModuleNameIn
(
aModuleName
moduleNameNormalized
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
modType
;
SECStatus
srv
=
SECMOD_DeleteModule
(
moduleNameNormalized
.
get
(
)
&
modType
)
;
if
(
srv
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
SharedCertVerifier
>
certVerifier
(
GetDefaultCertVerifier
(
)
)
;
if
(
!
certVerifier
)
{
return
NS_ERROR_FAILURE
;
}
certVerifier
-
>
ClearTrustCache
(
)
;
CollectThirdPartyPKCS11ModuleTelemetry
(
)
;
return
NS_OK
;
}
#
if
defined
(
XP_MACOSX
)
nsresult
ModulePathToFilename
(
const
nsCString
&
aModulePath
nsCString
&
aFilename
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_NewLocalFile
(
NS_ConvertUTF8toUTF16
(
aModulePath
)
getter_AddRefs
(
file
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
filename
;
rv
=
file
-
>
GetLeafName
(
filename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aFilename
=
NS_ConvertUTF16toUTF8
(
filename
)
;
return
NS_OK
;
}
void
CollectThirdPartyModuleSignatureType
(
const
nsCString
&
aModulePath
)
{
using
mozilla
:
:
glean
:
:
pkcs11
:
:
third_party_module_signature_type
;
using
mozilla
:
:
glean
:
:
pkcs11
:
:
ThirdPartyModuleSignatureTypeExtra
;
using
nsMacUtilsImpl
:
:
CodeSignatureTypeToString
;
nsMacUtilsImpl
:
:
CodeSignatureType
signatureType
=
nsMacUtilsImpl
:
:
GetSignatureType
(
aModulePath
)
;
nsCString
filename
;
nsresult
rv
=
ModulePathToFilename
(
aModulePath
filename
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsCString
signatureTypeStr
(
CodeSignatureTypeToString
(
signatureType
)
)
;
third_party_module_signature_type
.
Record
(
Some
(
ThirdPartyModuleSignatureTypeExtra
{
Some
(
filename
)
Some
(
signatureTypeStr
)
}
)
)
;
}
void
CollectThirdPartyModuleFilename
(
const
nsCString
&
aModulePath
)
{
using
mozilla
:
:
glean
:
:
pkcs11
:
:
third_party_module_profile_entries
;
nsCString
filename
;
nsresult
rv
=
ModulePathToFilename
(
aModulePath
filename
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
third_party_module_profile_entries
.
Add
(
filename
)
;
}
#
endif
NS_IMETHODIMP
PKCS11ModuleDB
:
:
AddModule
(
const
nsAString
&
aModuleName
const
nsAString
&
aLibraryFullPath
int32_t
aCryptoMechanismFlags
int32_t
aCipherFlags
)
{
if
(
aModuleName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aModuleName
.
EqualsLiteral
(
"
Root
Certs
"
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsresult
rv
=
BlockUntilLoadableCertsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
moduleNameNormalized
;
rv
=
NormalizeModuleNameIn
(
aModuleName
moduleNameNormalized
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCString
fullPath
;
CopyUTF16toUTF8
(
aLibraryFullPath
fullPath
)
;
uint32_t
mechFlags
=
SECMOD_PubMechFlagstoInternal
(
aCryptoMechanismFlags
)
;
uint32_t
cipherFlags
=
SECMOD_PubCipherFlagstoInternal
(
aCipherFlags
)
;
SECStatus
srv
=
SECMOD_AddNewModule
(
moduleNameNormalized
.
get
(
)
fullPath
.
get
(
)
mechFlags
cipherFlags
)
;
if
(
srv
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
SharedCertVerifier
>
certVerifier
(
GetDefaultCertVerifier
(
)
)
;
if
(
!
certVerifier
)
{
return
NS_ERROR_FAILURE
;
}
certVerifier
-
>
ClearTrustCache
(
)
;
#
if
defined
(
XP_MACOSX
)
CollectThirdPartyModuleSignatureType
(
fullPath
)
;
#
endif
CollectThirdPartyPKCS11ModuleTelemetry
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
ListModules
(
nsISimpleEnumerator
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
nsresult
rv
=
BlockUntilLoadableCertsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIMutableArray
>
array
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
if
(
!
array
)
{
return
NS_ERROR_FAILURE
;
}
AutoSECMODListReadLock
lock
;
for
(
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
nsCOMPtr
<
nsIPKCS11Module
>
module
=
new
nsPKCS11Module
(
list
-
>
module
)
;
nsresult
rv
=
array
-
>
AppendElement
(
module
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
for
(
SECMODModuleList
*
list
=
SECMOD_GetDeadModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
nsCOMPtr
<
nsIPKCS11Module
>
module
=
new
nsPKCS11Module
(
list
-
>
module
)
;
nsresult
rv
=
array
-
>
AppendElement
(
module
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
array
-
>
Enumerate
(
_retval
NS_GET_IID
(
nsIPKCS11Module
)
)
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
GetCanToggleFIPS
(
bool
*
aCanToggleFIPS
)
{
NS_ENSURE_ARG_POINTER
(
aCanToggleFIPS
)
;
*
aCanToggleFIPS
=
SECMOD_CanDeleteInternalModule
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
ToggleFIPSMode
(
)
{
SECMODModule
*
internal
=
SECMOD_GetInternalModule
(
)
;
if
(
!
internal
)
{
return
NS_ERROR_FAILURE
;
}
if
(
SECMOD_DeleteInternalModule
(
internal
-
>
commonName
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PKCS11ModuleDB
:
:
GetIsFIPSEnabled
(
bool
*
aIsFIPSEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aIsFIPSEnabled
)
;
*
aIsFIPSEnabled
=
PK11_IsFIPS
(
)
;
return
NS_OK
;
}
const
nsLiteralCString
kBuiltInModuleNames
[
]
=
{
kNSSInternalModuleName
kRootModuleName
kOSClientCertsModuleName
kIPCClientCertsModuleName
}
;
void
CollectThirdPartyPKCS11ModuleTelemetry
(
bool
aIsInitialization
)
{
size_t
thirdPartyModulesLoaded
=
0
;
AutoSECMODListReadLock
lock
;
for
(
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
list
;
list
=
list
-
>
next
)
{
bool
isThirdParty
=
true
;
for
(
const
auto
&
builtInModuleName
:
kBuiltInModuleNames
)
{
if
(
builtInModuleName
.
Equals
(
list
-
>
module
-
>
commonName
)
)
{
isThirdParty
=
false
;
break
;
}
}
if
(
isThirdParty
)
{
thirdPartyModulesLoaded
+
+
;
#
if
defined
(
XP_MACOSX
)
if
(
aIsInitialization
)
{
nsCString
modulePath
(
list
-
>
module
-
>
dllName
)
;
NS_DispatchToMainThreadQueue
(
NS_NewRunnableFunction
(
"
CollectThirdPartyModuleFilenameIdle
"
[
modulePath
]
(
)
{
CollectThirdPartyModuleFilename
(
modulePath
)
;
}
)
EventQueuePriority
:
:
Idle
)
;
}
#
endif
}
}
mozilla
:
:
glean
:
:
pkcs11
:
:
third_party_modules_loaded
.
Set
(
thirdPartyModulesLoaded
)
;
}
}
}
