"
use
strict
"
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTextDecoder
"
(
)
=
>
new
TextDecoder
(
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
baseAttachmentsURL
"
async
(
)
=
>
{
const
server
=
Services
.
prefs
.
getCharPref
(
"
services
.
settings
.
server
"
)
;
const
serverInfo
=
await
(
await
fetch
(
{
server
}
/
)
)
.
json
(
)
;
const
{
capabilities
:
{
attachments
:
{
base_url
}
}
}
=
serverInfo
;
return
base_url
;
}
)
;
const
INTERMEDIATES_ENABLED_PREF
=
"
security
.
remote_settings
.
intermediates
.
enabled
"
;
const
INTERMEDIATES_COLLECTION_PREF
=
"
security
.
remote_settings
.
intermediates
.
collection
"
;
const
INTERMEDIATES_BUCKET_PREF
=
"
security
.
remote_settings
.
intermediates
.
bucket
"
;
const
INTERMEDIATES_SIGNER_PREF
=
"
security
.
remote_settings
.
intermediates
.
signer
"
;
const
INTERMEDIATES_CHECKED_SECONDS_PREF
=
"
security
.
remote_settings
.
intermediates
.
checked
"
;
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
function
getHash
(
aStr
)
{
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
Ci
.
nsICryptoHash
.
SHA256
)
;
let
stringStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stringStream
.
data
=
aStr
;
hasher
.
updateFromStream
(
stringStream
-
1
)
;
return
hasher
.
finish
(
true
)
;
}
function
stripColons
(
hexString
)
{
return
hexString
.
replace
(
/
:
/
g
"
"
)
;
}
this
.
RemoteSecuritySettings
=
class
RemoteSecuritySettings
{
constructor
(
)
{
this
.
onSync
=
this
.
onSync
.
bind
(
this
)
;
this
.
client
=
RemoteSettings
(
Services
.
prefs
.
getCharPref
(
INTERMEDIATES_COLLECTION_PREF
)
{
bucketNamePref
:
INTERMEDIATES_BUCKET_PREF
lastCheckTimePref
:
INTERMEDIATES_CHECKED_SECONDS_PREF
signerName
:
Services
.
prefs
.
getCharPref
(
INTERMEDIATES_SIGNER_PREF
)
localFields
:
[
"
cert_import_complete
"
]
}
)
;
this
.
client
.
on
(
"
sync
"
this
.
onSync
)
;
}
async
onSync
(
event
)
{
const
{
data
:
{
deleted
current
}
}
=
event
;
if
(
!
Services
.
prefs
.
getBoolPref
(
INTERMEDIATES_ENABLED_PREF
true
)
)
{
return
;
}
const
col
=
await
this
.
client
.
openCollection
(
)
;
this
.
removeCerts
(
deleted
)
;
const
maxDownloadsPerRun
=
100
;
let
waiting
=
current
.
filter
(
record
=
>
!
record
.
cert_import_complete
)
;
await
Promise
.
all
(
waiting
.
slice
(
0
maxDownloadsPerRun
)
.
map
(
record
=
>
this
.
maybeDownloadAttachment
(
record
col
)
)
)
;
}
async
_downloadAttachmentBytes
(
record
)
{
const
{
attachment
:
{
location
}
}
=
record
;
const
remoteFilePath
=
(
await
baseAttachmentsURL
)
+
location
;
const
headers
=
new
Headers
(
)
;
headers
.
set
(
"
Accept
-
Encoding
"
"
gzip
"
)
;
return
fetch
(
remoteFilePath
{
headers
}
)
.
then
(
resp
=
>
{
if
(
!
resp
.
ok
)
{
Cu
.
reportError
(
Failed
to
fetch
{
remoteFilePath
}
:
{
resp
.
status
}
)
;
return
Promise
.
reject
(
)
;
}
return
resp
.
arrayBuffer
(
)
;
}
)
.
then
(
buffer
=
>
new
Uint8Array
(
buffer
)
)
;
}
async
maybeDownloadAttachment
(
record
col
)
{
const
{
attachment
:
{
hash
size
}
}
=
record
;
return
this
.
_downloadAttachmentBytes
(
record
)
.
then
(
function
(
attachmentData
)
{
if
(
!
attachmentData
|
|
attachmentData
.
length
=
=
0
)
{
return
Promise
.
reject
(
)
;
}
if
(
attachmentData
.
length
!
=
=
size
)
{
return
Promise
.
reject
(
)
;
}
let
dataAsString
=
gTextDecoder
.
decode
(
attachmentData
)
;
let
calculatedHash
=
getHash
(
dataAsString
)
;
if
(
calculatedHash
!
=
=
hash
)
{
return
Promise
.
reject
(
)
;
}
let
b64data
=
dataAsString
.
split
(
"
-
-
-
-
-
"
)
[
2
]
.
replace
(
/
\
s
/
g
"
"
)
;
let
certDer
=
atob
(
b64data
)
;
certdb
.
addCert
(
certDer
"
"
)
;
record
.
cert_import_complete
=
true
;
return
col
.
update
(
record
)
;
}
)
.
catch
(
(
)
=
>
{
}
)
;
}
async
maybeSync
(
expectedTimestamp
options
)
{
return
this
.
client
.
maybeSync
(
expectedTimestamp
options
)
;
}
async
removeCerts
(
records
)
{
let
recordsToRemove
=
records
;
for
(
let
cert
of
certdb
.
getCerts
(
)
.
getEnumerator
(
)
)
{
let
certHash
=
stripColons
(
cert
.
sha256Fingerprint
)
;
for
(
let
i
=
0
;
i
<
recordsToRemove
.
length
;
i
+
+
)
{
let
record
=
recordsToRemove
[
i
]
;
if
(
record
.
pubKeyHash
=
=
certHash
)
{
certdb
.
deleteCertificate
(
cert
)
;
recordsToRemove
.
splice
(
i
1
)
;
break
;
}
}
}
if
(
recordsToRemove
.
length
>
0
)
{
Cu
.
reportError
(
Failed
to
remove
{
recordsToRemove
.
length
}
intermediate
certificates
)
;
}
}
}
;
const
EXPORTED_SYMBOLS
=
[
"
RemoteSecuritySettings
"
]
;
