#
ifndef
nsNSSIOLayer_h
#
define
nsNSSIOLayer_h
#
include
"
TransportSecurityInfo
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIClientAuthDialogs
.
h
"
#
include
"
nsIProxyInfo
.
h
"
#
include
"
nsISSLSocketControl
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
sslt
.
h
"
namespace
mozilla
{
class
OriginAttributes
;
namespace
psm
{
class
SharedSSLState
;
}
}
using
mozilla
:
:
OriginAttributes
;
class
nsIObserver
;
class
nsNSSSocketInfo
final
:
public
mozilla
:
:
psm
:
:
TransportSecurityInfo
public
nsISSLSocketControl
{
public
:
nsNSSSocketInfo
(
mozilla
:
:
psm
:
:
SharedSSLState
&
aState
uint32_t
providerFlags
uint32_t
providerTlsFlags
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSISSLSOCKETCONTROL
void
SetForSTARTTLS
(
bool
aForSTARTTLS
)
;
bool
GetForSTARTTLS
(
)
;
nsresult
GetFileDescPtr
(
PRFileDesc
*
*
aFilePtr
)
;
nsresult
SetFileDescPtr
(
PRFileDesc
*
aFilePtr
)
;
bool
IsHandshakePending
(
)
const
{
return
mHandshakePending
;
}
void
SetHandshakeNotPending
(
)
{
mHandshakePending
=
false
;
}
void
SetTLSVersionRange
(
SSLVersionRange
range
)
{
mTLSVersionRange
=
range
;
}
SSLVersionRange
GetTLSVersionRange
(
)
const
{
return
mTLSVersionRange
;
}
;
PRStatus
CloseSocketAndDestroy
(
)
;
void
SetNegotiatedNPN
(
const
char
*
value
uint32_t
length
)
;
void
SetEarlyDataAccepted
(
bool
aAccepted
)
;
void
SetResumed
(
bool
aResumed
)
;
void
SetHandshakeCompleted
(
)
;
bool
IsHandshakeCompleted
(
)
const
{
return
mHandshakeCompleted
;
}
void
NoteTimeUntilReady
(
)
;
void
SetFalseStartCallbackCalled
(
)
{
mFalseStartCallbackCalled
=
true
;
}
void
SetFalseStarted
(
)
{
mFalseStarted
=
true
;
}
void
SetFullHandshake
(
)
{
mIsFullHandshake
=
true
;
}
bool
IsFullHandshake
(
)
const
{
return
mIsFullHandshake
;
}
bool
GetJoined
(
)
{
return
mJoined
;
}
void
SetSentClientCert
(
)
{
mSentClientCert
=
true
;
}
uint32_t
GetProviderFlags
(
)
const
{
return
mProviderFlags
;
}
uint32_t
GetProviderTlsFlags
(
)
const
{
return
mProviderTlsFlags
;
}
mozilla
:
:
psm
:
:
SharedSSLState
&
SharedState
(
)
;
enum
CertVerificationState
{
before_cert_verification
waiting_for_cert_verification
after_cert_verification
}
;
void
SetCertVerificationWaiting
(
)
;
void
SetCertVerificationResult
(
PRErrorCode
errorCode
)
;
PRBool
IsWaitingForCertVerification
(
)
const
{
return
mCertVerificationState
=
=
waiting_for_cert_verification
;
}
void
AddPlaintextBytesRead
(
uint64_t
val
)
{
mPlaintextBytesRead
+
=
val
;
}
bool
IsPreliminaryHandshakeDone
(
)
const
{
return
mPreliminaryHandshakeDone
;
}
void
SetPreliminaryHandshakeDone
(
)
{
mPreliminaryHandshakeDone
=
true
;
}
void
SetKEAUsed
(
uint16_t
kea
)
{
mKEAUsed
=
kea
;
}
void
SetKEAKeyBits
(
uint32_t
keaBits
)
{
mKEAKeyBits
=
keaBits
;
}
void
SetSSLVersionUsed
(
int16_t
version
)
{
mSSLVersionUsed
=
version
;
}
void
SetMACAlgorithmUsed
(
int16_t
mac
)
{
mMACAlgorithmUsed
=
mac
;
}
void
SetShortWritePending
(
int32_t
amount
unsigned
char
data
)
{
mIsShortWritePending
=
true
;
mShortWriteOriginalAmount
=
amount
;
mShortWritePendingByte
=
data
;
}
bool
IsShortWritePending
(
)
{
return
mIsShortWritePending
;
}
unsigned
char
const
*
GetShortWritePendingByteRef
(
)
{
return
&
mShortWritePendingByte
;
}
int32_t
ResetShortWritePending
(
)
{
mIsShortWritePending
=
false
;
return
mShortWriteOriginalAmount
;
}
#
ifdef
DEBUG
void
RememberShortWrittenBuffer
(
const
unsigned
char
*
data
)
{
mShortWriteBufferCheck
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
mShortWriteOriginalAmount
)
;
memcpy
(
mShortWriteBufferCheck
.
get
(
)
data
mShortWriteOriginalAmount
)
;
}
void
CheckShortWrittenBuffer
(
const
unsigned
char
*
data
int32_t
amount
)
{
if
(
!
mShortWriteBufferCheck
)
return
;
MOZ_ASSERT
(
amount
>
=
mShortWriteOriginalAmount
"
unexpected
amount
length
after
short
write
"
)
;
MOZ_ASSERT
(
!
memcmp
(
mShortWriteBufferCheck
.
get
(
)
data
mShortWriteOriginalAmount
)
"
unexpected
buffer
content
after
short
write
"
)
;
mShortWriteBufferCheck
=
nullptr
;
}
#
endif
void
SetSharedOwningReference
(
mozilla
:
:
psm
:
:
SharedSSLState
*
ref
)
;
protected
:
virtual
~
nsNSSSocketInfo
(
)
;
private
:
PRFileDesc
*
mFd
;
CertVerificationState
mCertVerificationState
;
mozilla
:
:
psm
:
:
SharedSSLState
&
mSharedState
;
bool
mForSTARTTLS
;
SSLVersionRange
mTLSVersionRange
;
bool
mHandshakePending
;
bool
mPreliminaryHandshakeDone
;
nsresult
ActivateSSL
(
)
;
nsCString
mNegotiatedNPN
;
nsCString
mEsniTxt
;
bool
mNPNCompleted
;
bool
mEarlyDataAccepted
;
bool
mDenyClientCert
;
bool
mFalseStartCallbackCalled
;
bool
mFalseStarted
;
bool
mIsFullHandshake
;
bool
mHandshakeCompleted
;
bool
mJoined
;
bool
mSentClientCert
;
bool
mNotedTimeUntilReady
;
bool
mFailedVerification
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
mResumed
;
bool
mIsShortWritePending
;
unsigned
char
mShortWritePendingByte
;
int32_t
mShortWriteOriginalAmount
;
#
ifdef
DEBUG
mozilla
:
:
UniquePtr
<
char
[
]
>
mShortWriteBufferCheck
;
#
endif
int16_t
mKEAUsed
;
uint32_t
mKEAKeyBits
;
int16_t
mSSLVersionUsed
;
int16_t
mMACAlgorithmUsed
;
uint32_t
mProviderFlags
;
uint32_t
mProviderTlsFlags
;
mozilla
:
:
TimeStamp
mSocketCreationTimestamp
;
uint64_t
mPlaintextBytesRead
;
nsCOMPtr
<
nsIX509Cert
>
mClientCert
;
RefPtr
<
mozilla
:
:
psm
:
:
SharedSSLState
>
mOwningSharedRef
;
}
;
class
nsSSLIOLayerHelpers
{
public
:
explicit
nsSSLIOLayerHelpers
(
uint32_t
aTlsFlags
=
0
)
;
~
nsSSLIOLayerHelpers
(
)
;
nsresult
Init
(
)
;
void
Cleanup
(
)
;
static
bool
nsSSLIOLayerInitialized
;
static
PRDescIdentity
nsSSLIOLayerIdentity
;
static
PRDescIdentity
nsSSLPlaintextLayerIdentity
;
static
PRIOMethods
nsSSLIOLayerMethods
;
static
PRIOMethods
nsSSLPlaintextLayerMethods
;
bool
mTreatUnsafeNegotiationAsBroken
;
void
setTreatUnsafeNegotiationAsBroken
(
bool
broken
)
;
bool
treatUnsafeNegotiationAsBroken
(
)
;
private
:
struct
IntoleranceEntry
{
uint16_t
tolerant
;
uint16_t
intolerant
;
PRErrorCode
intoleranceReason
;
void
AssertInvariant
(
)
const
{
MOZ_ASSERT
(
intolerant
=
=
0
|
|
tolerant
<
intolerant
)
;
}
}
;
nsDataHashtable
<
nsCStringHashKey
IntoleranceEntry
>
mTLSIntoleranceInfo
;
nsTHashtable
<
nsCStringHashKey
>
mInsecureFallbackSites
;
public
:
void
rememberTolerantAtVersion
(
const
nsACString
&
hostname
int16_t
port
uint16_t
tolerant
)
;
bool
fallbackLimitReached
(
const
nsACString
&
hostname
uint16_t
intolerant
)
;
bool
rememberIntolerantAtVersion
(
const
nsACString
&
hostname
int16_t
port
uint16_t
intolerant
uint16_t
minVersion
PRErrorCode
intoleranceReason
)
;
void
forgetIntolerance
(
const
nsACString
&
hostname
int16_t
port
)
;
void
adjustForTLSIntolerance
(
const
nsACString
&
hostname
int16_t
port
SSLVersionRange
&
range
)
;
PRErrorCode
getIntoleranceReason
(
const
nsACString
&
hostname
int16_t
port
)
;
void
clearStoredData
(
)
;
void
loadVersionFallbackLimit
(
)
;
void
setInsecureFallbackSites
(
const
nsCString
&
str
)
;
void
initInsecureFallbackSites
(
)
;
bool
isPublic
(
)
const
;
void
removeInsecureFallbackSite
(
const
nsACString
&
hostname
uint16_t
port
)
;
bool
isInsecureFallbackSite
(
const
nsACString
&
hostname
)
;
uint16_t
mVersionFallbackLimit
;
private
:
mozilla
:
:
Mutex
mutex
;
nsCOMPtr
<
nsIObserver
>
mPrefObserver
;
uint32_t
mTlsFlags
;
}
;
nsresult
nsSSLIOLayerNewSocket
(
int32_t
family
const
char
*
host
int32_t
port
nsIProxyInfo
*
proxy
const
OriginAttributes
&
originAttributes
PRFileDesc
*
*
fd
nsISupports
*
*
securityInfo
bool
forSTARTTLS
uint32_t
flags
uint32_t
tlsFlags
)
;
nsresult
nsSSLIOLayerAddToSocket
(
int32_t
family
const
char
*
host
int32_t
port
nsIProxyInfo
*
proxy
const
OriginAttributes
&
originAttributes
PRFileDesc
*
fd
nsISupports
*
*
securityInfo
bool
forSTARTTLS
uint32_t
flags
uint32_t
tlsFlags
)
;
nsresult
nsSSLIOLayerFreeTLSIntolerantSites
(
)
;
#
endif
