#
ifndef
nsNSSIOLayer_h
#
define
nsNSSIOLayer_h
#
include
"
CommonSocketControl
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIProxyInfo
.
h
"
#
include
"
nsISSLSocketControl
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
sslt
.
h
"
namespace
mozilla
{
class
OriginAttributes
;
namespace
psm
{
class
SharedSSLState
;
}
}
using
mozilla
:
:
OriginAttributes
;
class
nsIObserver
;
class
nsNSSSocketInfo
final
:
public
CommonSocketControl
{
public
:
nsNSSSocketInfo
(
mozilla
:
:
psm
:
:
SharedSSLState
&
aState
uint32_t
providerFlags
uint32_t
providerTlsFlags
)
;
NS_DECL_ISUPPORTS_INHERITED
void
SetForSTARTTLS
(
bool
aForSTARTTLS
)
;
bool
GetForSTARTTLS
(
)
;
nsresult
GetFileDescPtr
(
PRFileDesc
*
*
aFilePtr
)
;
nsresult
SetFileDescPtr
(
PRFileDesc
*
aFilePtr
)
;
bool
IsHandshakePending
(
)
const
{
return
mHandshakePending
;
}
void
SetHandshakeNotPending
(
)
{
mHandshakePending
=
false
;
}
void
SetTLSVersionRange
(
SSLVersionRange
range
)
{
mTLSVersionRange
=
range
;
}
SSLVersionRange
GetTLSVersionRange
(
)
const
{
return
mTLSVersionRange
;
}
;
NS_IMETHOD
ProxyStartSSL
(
void
)
override
;
NS_IMETHOD
StartTLS
(
void
)
override
;
NS_IMETHOD
SetNPNList
(
nsTArray
<
nsCString
>
&
aNPNList
)
override
;
NS_IMETHOD
GetAlpnEarlySelection
(
nsACString
&
_retval
)
override
;
NS_IMETHOD
GetEarlyDataAccepted
(
bool
*
aEarlyDataAccepted
)
override
;
NS_IMETHOD
DriveHandshake
(
void
)
override
;
using
nsISSLSocketControl
:
:
GetKEAUsed
;
NS_IMETHOD
GetKEAUsed
(
int16_t
*
aKEAUsed
)
override
;
NS_IMETHOD
GetKEAKeyBits
(
uint32_t
*
aKEAKeyBits
)
override
;
NS_IMETHOD
GetProviderTlsFlags
(
uint32_t
*
aProviderTlsFlags
)
override
;
NS_IMETHOD
GetSSLVersionOffered
(
int16_t
*
aSSLVersionOffered
)
override
;
NS_IMETHOD
GetMACAlgorithmUsed
(
int16_t
*
aMACAlgorithmUsed
)
override
;
bool
GetDenyClientCert
(
)
override
;
void
SetDenyClientCert
(
bool
aDenyClientCert
)
override
;
NS_IMETHOD
GetClientCert
(
nsIX509Cert
*
*
aClientCert
)
override
;
NS_IMETHOD
SetClientCert
(
nsIX509Cert
*
aClientCert
)
override
;
NS_IMETHOD
GetEsniTxt
(
nsACString
&
aEsniTxt
)
override
;
NS_IMETHOD
SetEsniTxt
(
const
nsACString
&
aEsniTxt
)
override
;
NS_IMETHOD
GetPeerId
(
nsACString
&
aResult
)
override
;
PRStatus
CloseSocketAndDestroy
(
)
;
void
SetNegotiatedNPN
(
const
char
*
value
uint32_t
length
)
;
void
SetEarlyDataAccepted
(
bool
aAccepted
)
;
void
SetHandshakeCompleted
(
)
;
bool
IsHandshakeCompleted
(
)
const
{
return
mHandshakeCompleted
;
}
void
NoteTimeUntilReady
(
)
;
void
SetFalseStartCallbackCalled
(
)
{
mFalseStartCallbackCalled
=
true
;
}
void
SetFalseStarted
(
)
{
mFalseStarted
=
true
;
}
void
SetFullHandshake
(
)
{
mIsFullHandshake
=
true
;
}
bool
IsFullHandshake
(
)
const
{
return
mIsFullHandshake
;
}
bool
GetJoined
(
)
{
return
mJoined
;
}
void
SetSentClientCert
(
)
{
mSentClientCert
=
true
;
}
uint32_t
GetProviderTlsFlags
(
)
const
{
return
mProviderTlsFlags
;
}
mozilla
:
:
psm
:
:
SharedSSLState
&
SharedState
(
)
;
enum
CertVerificationState
{
before_cert_verification
waiting_for_cert_verification
after_cert_verification
}
;
void
SetCertVerificationWaiting
(
)
;
void
SetCertVerificationResult
(
PRErrorCode
errorCode
)
override
;
PRBool
IsWaitingForCertVerification
(
)
const
{
return
mCertVerificationState
=
=
waiting_for_cert_verification
;
}
void
AddPlaintextBytesRead
(
uint64_t
val
)
{
mPlaintextBytesRead
+
=
val
;
}
bool
IsPreliminaryHandshakeDone
(
)
const
{
return
mPreliminaryHandshakeDone
;
}
void
SetPreliminaryHandshakeDone
(
)
{
mPreliminaryHandshakeDone
=
true
;
}
void
SetKEAUsed
(
uint16_t
kea
)
{
mKEAUsed
=
kea
;
}
void
SetKEAKeyBits
(
uint32_t
keaBits
)
{
mKEAKeyBits
=
keaBits
;
}
void
SetMACAlgorithmUsed
(
int16_t
mac
)
{
mMACAlgorithmUsed
=
mac
;
}
void
SetShortWritePending
(
int32_t
amount
unsigned
char
data
)
{
mIsShortWritePending
=
true
;
mShortWriteOriginalAmount
=
amount
;
mShortWritePendingByte
=
data
;
}
bool
IsShortWritePending
(
)
{
return
mIsShortWritePending
;
}
unsigned
char
const
*
GetShortWritePendingByteRef
(
)
{
return
&
mShortWritePendingByte
;
}
int32_t
ResetShortWritePending
(
)
{
mIsShortWritePending
=
false
;
return
mShortWriteOriginalAmount
;
}
#
ifdef
DEBUG
void
RememberShortWrittenBuffer
(
const
unsigned
char
*
data
)
{
mShortWriteBufferCheck
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
mShortWriteOriginalAmount
)
;
memcpy
(
mShortWriteBufferCheck
.
get
(
)
data
mShortWriteOriginalAmount
)
;
}
void
CheckShortWrittenBuffer
(
const
unsigned
char
*
data
int32_t
amount
)
{
if
(
!
mShortWriteBufferCheck
)
return
;
MOZ_ASSERT
(
amount
>
=
mShortWriteOriginalAmount
"
unexpected
amount
length
after
short
write
"
)
;
MOZ_ASSERT
(
!
memcmp
(
mShortWriteBufferCheck
.
get
(
)
data
mShortWriteOriginalAmount
)
"
unexpected
buffer
content
after
short
write
"
)
;
mShortWriteBufferCheck
=
nullptr
;
}
#
endif
void
SetSharedOwningReference
(
mozilla
:
:
psm
:
:
SharedSSLState
*
ref
)
;
nsresult
SetResumptionTokenFromExternalCache
(
)
;
void
SetClientCertChain
(
mozilla
:
:
UniqueCERTCertList
&
&
clientCertChain
)
{
mClientCertChain
=
std
:
:
move
(
clientCertChain
)
;
}
protected
:
virtual
~
nsNSSSocketInfo
(
)
;
private
:
PRFileDesc
*
mFd
;
CertVerificationState
mCertVerificationState
;
mozilla
:
:
psm
:
:
SharedSSLState
&
mSharedState
;
bool
mForSTARTTLS
;
SSLVersionRange
mTLSVersionRange
;
bool
mHandshakePending
;
bool
mPreliminaryHandshakeDone
;
nsresult
ActivateSSL
(
)
;
nsCString
mEsniTxt
;
nsCString
mPeerId
;
bool
mEarlyDataAccepted
;
bool
mDenyClientCert
;
bool
mFalseStartCallbackCalled
;
bool
mFalseStarted
;
bool
mIsFullHandshake
;
bool
mNotedTimeUntilReady
;
bool
mIsShortWritePending
;
unsigned
char
mShortWritePendingByte
;
int32_t
mShortWriteOriginalAmount
;
#
ifdef
DEBUG
mozilla
:
:
UniquePtr
<
char
[
]
>
mShortWriteBufferCheck
;
#
endif
int16_t
mKEAUsed
;
uint32_t
mKEAKeyBits
;
int16_t
mMACAlgorithmUsed
;
uint32_t
mProviderTlsFlags
;
mozilla
:
:
TimeStamp
mSocketCreationTimestamp
;
uint64_t
mPlaintextBytesRead
;
nsCOMPtr
<
nsIX509Cert
>
mClientCert
;
mozilla
:
:
UniqueCERTCertList
mClientCertChain
;
RefPtr
<
mozilla
:
:
psm
:
:
SharedSSLState
>
mOwningSharedRef
;
}
;
class
ClientAuthInfo
final
{
public
:
explicit
ClientAuthInfo
(
const
nsACString
&
hostName
const
OriginAttributes
&
originAttributes
int32_t
port
uint32_t
providerFlags
uint32_t
providerTlsFlags
nsIX509Cert
*
clientCert
)
;
~
ClientAuthInfo
(
)
=
default
;
ClientAuthInfo
(
ClientAuthInfo
&
&
aOther
)
noexcept
;
const
nsACString
&
HostName
(
)
const
;
const
OriginAttributes
&
OriginAttributesRef
(
)
const
;
int32_t
Port
(
)
const
;
already_AddRefed
<
nsIX509Cert
>
GetClientCert
(
)
const
;
uint32_t
ProviderFlags
(
)
const
;
uint32_t
ProviderTlsFlags
(
)
const
;
private
:
ClientAuthInfo
(
const
ClientAuthInfo
&
)
=
delete
;
void
operator
=
(
const
ClientAuthInfo
&
)
=
delete
;
nsCString
mHostName
;
OriginAttributes
mOriginAttributes
;
int32_t
mPort
;
uint32_t
mProviderFlags
;
uint32_t
mProviderTlsFlags
;
nsCOMPtr
<
nsIX509Cert
>
mClientCert
;
}
;
class
nsSSLIOLayerHelpers
{
public
:
explicit
nsSSLIOLayerHelpers
(
uint32_t
aTlsFlags
=
0
)
;
~
nsSSLIOLayerHelpers
(
)
;
nsresult
Init
(
)
;
void
Cleanup
(
)
;
static
bool
nsSSLIOLayerInitialized
;
static
PRDescIdentity
nsSSLIOLayerIdentity
;
static
PRDescIdentity
nsSSLPlaintextLayerIdentity
;
static
PRIOMethods
nsSSLIOLayerMethods
;
static
PRIOMethods
nsSSLPlaintextLayerMethods
;
bool
mTreatUnsafeNegotiationAsBroken
;
void
setTreatUnsafeNegotiationAsBroken
(
bool
broken
)
;
bool
treatUnsafeNegotiationAsBroken
(
)
;
private
:
struct
IntoleranceEntry
{
uint16_t
tolerant
;
uint16_t
intolerant
;
PRErrorCode
intoleranceReason
;
void
AssertInvariant
(
)
const
{
MOZ_ASSERT
(
intolerant
=
=
0
|
|
tolerant
<
intolerant
)
;
}
}
;
nsDataHashtable
<
nsCStringHashKey
IntoleranceEntry
>
mTLSIntoleranceInfo
;
nsTHashtable
<
nsCStringHashKey
>
mInsecureFallbackSites
;
public
:
void
rememberTolerantAtVersion
(
const
nsACString
&
hostname
int16_t
port
uint16_t
tolerant
)
;
bool
fallbackLimitReached
(
const
nsACString
&
hostname
uint16_t
intolerant
)
;
bool
rememberIntolerantAtVersion
(
const
nsACString
&
hostname
int16_t
port
uint16_t
intolerant
uint16_t
minVersion
PRErrorCode
intoleranceReason
)
;
void
forgetIntolerance
(
const
nsACString
&
hostname
int16_t
port
)
;
void
adjustForTLSIntolerance
(
const
nsACString
&
hostname
int16_t
port
SSLVersionRange
&
range
)
;
PRErrorCode
getIntoleranceReason
(
const
nsACString
&
hostname
int16_t
port
)
;
void
clearStoredData
(
)
;
void
loadVersionFallbackLimit
(
)
;
void
setInsecureFallbackSites
(
const
nsCString
&
str
)
;
void
initInsecureFallbackSites
(
)
;
bool
isPublic
(
)
const
;
void
removeInsecureFallbackSite
(
const
nsACString
&
hostname
uint16_t
port
)
;
bool
isInsecureFallbackSite
(
const
nsACString
&
hostname
)
;
uint16_t
mVersionFallbackLimit
;
private
:
mozilla
:
:
Mutex
mutex
;
nsCOMPtr
<
nsIObserver
>
mPrefObserver
;
uint32_t
mTlsFlags
;
}
;
nsresult
nsSSLIOLayerNewSocket
(
int32_t
family
const
char
*
host
int32_t
port
nsIProxyInfo
*
proxy
const
OriginAttributes
&
originAttributes
PRFileDesc
*
*
fd
nsISupports
*
*
securityInfo
bool
forSTARTTLS
uint32_t
flags
uint32_t
tlsFlags
)
;
nsresult
nsSSLIOLayerAddToSocket
(
int32_t
family
const
char
*
host
int32_t
port
nsIProxyInfo
*
proxy
const
OriginAttributes
&
originAttributes
PRFileDesc
*
fd
nsISupports
*
*
securityInfo
bool
forSTARTTLS
uint32_t
flags
uint32_t
tlsFlags
)
;
SECStatus
DoGetClientAuthData
(
ClientAuthInfo
&
&
info
const
mozilla
:
:
UniqueCERTCertificate
&
serverCert
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
collectedCANames
mozilla
:
:
UniqueCERTCertificate
&
outCert
mozilla
:
:
UniqueSECKEYPrivateKey
&
outKey
mozilla
:
:
UniqueCERTCertList
&
outBuiltChain
)
;
#
endif
