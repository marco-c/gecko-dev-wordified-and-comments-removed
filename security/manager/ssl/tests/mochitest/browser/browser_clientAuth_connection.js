"
use
strict
"
;
const
{
MockRegistrar
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
sys
.
mjs
"
)
;
const
DialogState
=
{
ASSERT_NOT_CALLED
:
"
ASSERT_NOT_CALLED
"
RETURN_CERT_SELECTED
:
"
RETURN_CERT_SELECTED
"
RETURN_CERT_NOT_SELECTED
:
"
RETURN_CERT_NOT_SELECTED
"
}
;
var
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
let
cars
=
Cc
[
"
mozilla
.
org
/
security
/
clientAuthRememberService
;
1
"
]
.
getService
(
Ci
.
nsIClientAuthRememberService
)
;
var
gExpectedClientCertificateChoices
;
const
gClientAuthDialogService
=
{
_state
:
DialogState
.
ASSERT_NOT_CALLED
_rememberClientAuthCertificate
:
false
_chooseCertificateCalled
:
false
set
state
(
newState
)
{
info
(
old
state
:
{
this
.
_state
}
)
;
this
.
_state
=
newState
;
info
(
new
state
:
{
this
.
_state
}
)
;
}
get
state
(
)
{
return
this
.
_state
;
}
set
rememberClientAuthCertificate
(
value
)
{
this
.
_rememberClientAuthCertificate
=
value
;
}
get
rememberClientAuthCertificate
(
)
{
return
this
.
_rememberClientAuthCertificate
;
}
get
chooseCertificateCalled
(
)
{
return
this
.
_chooseCertificateCalled
;
}
set
chooseCertificateCalled
(
value
)
{
this
.
_chooseCertificateCalled
=
value
;
}
chooseCertificate
(
hostname
certArray
loadContext
callback
)
{
this
.
chooseCertificateCalled
=
true
;
Assert
.
notEqual
(
this
.
state
DialogState
.
ASSERT_NOT_CALLED
"
chooseCertificate
(
)
should
be
called
only
when
expected
"
)
;
Assert
.
equal
(
hostname
"
requireclientcert
.
example
.
com
"
"
Hostname
should
be
'
requireclientcert
.
example
.
com
'
"
)
;
Assert
.
notEqual
(
certArray
null
"
Cert
list
should
not
be
null
"
)
;
Assert
.
equal
(
certArray
.
length
gExpectedClientCertificateChoices
{
gExpectedClientCertificateChoices
}
certificates
should
be
available
)
;
for
(
let
cert
of
certArray
)
{
Assert
.
notEqual
(
cert
null
"
Cert
list
should
contain
nsIX509Certs
"
)
;
Assert
.
equal
(
cert
.
issuerCommonName
"
Temporary
Certificate
Authority
"
"
cert
should
have
expected
issuer
CN
"
)
;
}
if
(
this
.
state
=
=
DialogState
.
RETURN_CERT_SELECTED
)
{
callback
.
certificateChosen
(
certArray
[
0
]
this
.
rememberClientAuthCertificate
)
;
}
else
{
callback
.
certificateChosen
(
null
this
.
rememberClientAuthCertificate
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIClientAuthDialogService
"
]
)
}
;
add_setup
(
async
function
(
)
{
let
clientAuthDialogServiceCID
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
security
/
ClientAuthDialogService
;
1
"
gClientAuthDialogService
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
clientAuthDialogServiceCID
)
;
}
)
;
await
readCertificate
(
"
pgo
-
ca
-
regular
-
usages
.
pem
"
"
CTu
CTu
CTu
"
)
;
await
readCertificate
(
"
pgo
-
ca
-
all
-
usages
.
pem
"
"
CTu
CTu
CTu
"
)
;
await
readCertificate
(
"
client
-
cert
-
via
-
intermediate
.
pem
"
"
"
)
;
await
readCertificate
(
"
client
-
cert
-
with
-
ocsp
-
signing
.
pem
"
"
"
)
;
gExpectedClientCertificateChoices
=
3
;
}
)
;
async
function
testHelper
(
prefValue
urlToNavigate
expectedURL
expectCallingChooseCertificate
options
=
undefined
expectStringInPage
=
undefined
)
{
gClientAuthDialogService
.
chooseCertificateCalled
=
false
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
default_personal_cert
"
prefValue
]
]
}
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
options
)
;
BrowserTestUtils
.
loadURIString
(
win
.
gBrowser
.
selectedBrowser
urlToNavigate
)
;
if
(
expectedURL
)
{
await
BrowserTestUtils
.
browserLoaded
(
win
.
gBrowser
.
selectedBrowser
false
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
true
)
;
let
loadedURL
=
win
.
gBrowser
.
selectedBrowser
.
documentURI
.
spec
;
Assert
.
ok
(
loadedURL
.
startsWith
(
expectedURL
)
Expected
and
actual
URLs
should
match
(
got
'
{
loadedURL
}
'
expected
'
{
expectedURL
}
'
)
)
;
}
else
{
await
new
Promise
(
resolve
=
>
{
let
removeEventListener
=
BrowserTestUtils
.
addContentEventListener
(
win
.
gBrowser
.
selectedBrowser
"
AboutNetErrorLoad
"
(
)
=
>
{
removeEventListener
(
)
;
resolve
(
)
;
}
{
capture
:
false
wantUntrusted
:
true
}
)
;
}
)
;
}
Assert
.
equal
(
gClientAuthDialogService
.
chooseCertificateCalled
expectCallingChooseCertificate
"
chooseCertificate
should
have
been
called
if
we
were
expecting
it
to
be
called
"
)
;
if
(
expectStringInPage
)
{
let
pageContent
=
await
SpecialPowers
.
spawn
(
win
.
gBrowser
.
selectedBrowser
[
]
async
function
(
)
{
return
content
.
document
.
body
.
textContent
;
}
)
;
Assert
.
ok
(
pageContent
.
includes
(
expectStringInPage
)
page
should
contain
the
string
'
{
expectStringInPage
}
'
(
was
'
{
pageContent
}
'
)
)
;
}
await
win
.
close
(
)
;
sdr
.
logout
(
)
;
}
add_task
(
async
function
testCertChosenAutomatically
(
)
{
gClientAuthDialogService
.
state
=
DialogState
.
ASSERT_NOT_CALLED
;
await
testHelper
(
"
Select
Automatically
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
false
)
;
cars
.
clearRememberedDecisions
(
)
;
}
)
;
add_task
(
async
function
testCertNotChosenByUser
(
)
{
gClientAuthDialogService
.
state
=
DialogState
.
RETURN_CERT_NOT_SELECTED
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
undefined
true
undefined
AppConstants
.
platform
!
=
"
win
"
?
"
SSL_ERROR_RX_CERTIFICATE_REQUIRED_ALERT
"
:
undefined
)
;
cars
.
clearRememberedDecisions
(
)
;
}
)
;
add_task
(
async
function
testCertChosenByUser
(
)
{
gClientAuthDialogService
.
state
=
DialogState
.
RETURN_CERT_SELECTED
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
true
)
;
cars
.
clearRememberedDecisions
(
)
;
}
)
;
add_task
(
async
function
testEmptyCertChosenByUser
(
)
{
gClientAuthDialogService
.
state
=
DialogState
.
RETURN_CERT_NOT_SELECTED
;
gClientAuthDialogService
.
rememberClientAuthCertificate
=
true
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
undefined
true
)
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
undefined
false
)
;
cars
.
clearRememberedDecisions
(
)
;
}
)
;
add_task
(
async
function
testClearPrivateBrowsingState
(
)
{
gClientAuthDialogService
.
rememberClientAuthCertificate
=
true
;
gClientAuthDialogService
.
state
=
DialogState
.
RETURN_CERT_SELECTED
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
true
{
private
:
true
}
)
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
true
{
private
:
true
}
)
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
true
)
;
cars
.
clearRememberedDecisions
(
)
;
}
)
;
add_task
(
async
function
testCertFilteringWithIntermediate
(
)
{
let
intermediateBytes
=
await
IOUtils
.
readUTF8
(
getTestFilePath
(
"
intermediate
.
pem
"
)
)
.
then
(
pem
=
>
{
let
base64
=
pemToBase64
(
pem
)
;
let
bin
=
atob
(
base64
)
;
let
bytes
=
[
]
;
for
(
let
i
=
0
;
i
<
bin
.
length
;
i
+
+
)
{
bytes
.
push
(
bin
.
charCodeAt
(
i
)
)
;
}
return
bytes
;
}
error
=
>
{
throw
error
;
}
)
;
let
nssComponent
=
Cc
[
"
mozilla
.
org
/
psm
;
1
"
]
.
getService
(
Ci
.
nsINSSComponent
)
;
nssComponent
.
addEnterpriseIntermediate
(
intermediateBytes
)
;
gExpectedClientCertificateChoices
=
4
;
gClientAuthDialogService
.
state
=
DialogState
.
RETURN_CERT_SELECTED
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
true
)
;
cars
.
clearRememberedDecisions
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
enterprise_roots
.
enabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testNoDialogForUntrustedServerCertificate
(
)
{
gClientAuthDialogService
.
state
=
DialogState
.
ASSERT_NOT_CALLED
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
-
untrusted
.
example
.
com
/
"
undefined
false
)
;
cars
.
clearRememberedDecisions
(
)
;
}
)
;
