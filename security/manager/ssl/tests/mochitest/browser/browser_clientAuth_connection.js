"
use
strict
"
;
const
{
MockRegistrar
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
)
;
const
DialogState
=
{
ASSERT_NOT_CALLED
:
"
ASSERT_NOT_CALLED
"
RETURN_CERT_SELECTED
:
"
RETURN_CERT_SELECTED
"
RETURN_CERT_NOT_SELECTED
:
"
RETURN_CERT_NOT_SELECTED
"
}
;
let
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
const
gClientAuthDialogs
=
{
_state
:
DialogState
.
ASSERT_NOT_CALLED
_rememberClientAuthCertificate
:
false
_chooseCertificateCalled
:
false
set
state
(
newState
)
{
info
(
old
state
:
{
this
.
_state
}
)
;
this
.
_state
=
newState
;
info
(
new
state
:
{
this
.
_state
}
)
;
}
get
state
(
)
{
return
this
.
_state
;
}
set
rememberClientAuthCertificate
(
value
)
{
this
.
_rememberClientAuthCertificate
=
value
;
}
get
rememberClientAuthCertificate
(
)
{
return
this
.
_rememberClientAuthCertificate
;
}
get
chooseCertificateCalled
(
)
{
return
this
.
_chooseCertificateCalled
;
}
set
chooseCertificateCalled
(
value
)
{
this
.
_chooseCertificateCalled
=
value
;
}
chooseCertificate
(
ctx
hostname
port
organization
issuerOrg
certList
selectedIndex
)
{
this
.
chooseCertificateCalled
=
true
;
Assert
.
notEqual
(
this
.
state
DialogState
.
ASSERT_NOT_CALLED
"
chooseCertificate
(
)
should
be
called
only
when
expected
"
)
;
let
caud
=
ctx
.
QueryInterface
(
Ci
.
nsIClientAuthUserDecision
)
;
Assert
.
notEqual
(
caud
null
"
nsIClientAuthUserDecision
should
be
queryable
from
the
"
+
"
given
context
"
)
;
caud
.
rememberClientAuthCertificate
=
this
.
rememberClientAuthCertificate
;
Assert
.
equal
(
hostname
"
requireclientcert
.
example
.
com
"
"
Hostname
should
be
'
requireclientcert
.
example
.
com
'
"
)
;
Assert
.
equal
(
port
443
"
Port
should
be
443
"
)
;
Assert
.
equal
(
organization
"
"
"
Server
cert
Organization
should
be
empty
/
not
present
"
)
;
Assert
.
equal
(
issuerOrg
"
Mozilla
Testing
"
"
Server
cert
issuer
Organization
should
be
'
Mozilla
Testing
'
"
)
;
Assert
.
notEqual
(
certList
null
"
Cert
list
should
not
be
null
"
)
;
Assert
.
equal
(
certList
.
length
1
"
Only
1
certificate
should
be
available
"
)
;
let
cert
=
certList
.
queryElementAt
(
0
Ci
.
nsIX509Cert
)
;
Assert
.
notEqual
(
cert
null
"
Cert
list
should
contain
an
nsIX509Cert
"
)
;
Assert
.
equal
(
cert
.
commonName
"
Mochitest
client
"
"
Cert
CN
should
be
'
Mochitest
client
'
"
)
;
if
(
this
.
state
=
=
DialogState
.
RETURN_CERT_SELECTED
)
{
selectedIndex
.
value
=
0
;
return
true
;
}
return
false
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIClientAuthDialogs
]
)
}
;
add_task
(
async
function
setup
(
)
{
let
clientAuthDialogsCID
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
nsClientAuthDialogs
;
1
"
gClientAuthDialogs
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
clientAuthDialogsCID
)
;
}
)
;
}
)
;
async
function
testHelper
(
prefValue
expectedURL
options
=
undefined
)
{
gClientAuthDialogs
.
chooseCertificateCalled
=
false
;
await
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
security
.
default_personal_cert
"
prefValue
]
]
}
)
;
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
options
)
;
await
BrowserTestUtils
.
loadURI
(
win
.
gBrowser
.
selectedBrowser
"
https
:
/
/
requireclientcert
.
example
.
com
:
443
"
)
;
let
loadedURL
=
await
Promise
.
race
(
[
BrowserTestUtils
.
browserLoaded
(
win
.
gBrowser
.
selectedBrowser
)
BrowserTestUtils
.
waitForErrorPage
(
win
.
gBrowser
.
selectedBrowser
)
]
)
;
Assert
.
equal
(
expectedURL
loadedURL
"
Expected
and
actual
URLs
should
match
"
)
;
Assert
.
equal
(
gClientAuthDialogs
.
chooseCertificateCalled
prefValue
=
=
"
Ask
Every
Time
"
"
chooseCertificate
should
have
been
called
if
we
were
expecting
it
to
be
called
"
)
;
await
win
.
close
(
)
;
sdr
.
logout
(
)
;
}
add_task
(
async
function
testCertChosenAutomatically
(
)
{
gClientAuthDialogs
.
state
=
DialogState
.
ASSERT_NOT_CALLED
;
await
testHelper
(
"
Select
Automatically
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
)
;
sdr
.
logoutAndTeardown
(
)
;
}
)
;
add_task
(
async
function
testCertNotChosenByUser
(
)
{
gClientAuthDialogs
.
state
=
DialogState
.
RETURN_CERT_NOT_SELECTED
;
await
testHelper
(
"
Ask
Every
Time
"
undefined
)
;
sdr
.
logoutAndTeardown
(
)
;
}
)
;
add_task
(
async
function
testCertChosenByUser
(
)
{
gClientAuthDialogs
.
state
=
DialogState
.
RETURN_CERT_SELECTED
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
)
;
sdr
.
logoutAndTeardown
(
)
;
}
)
;
add_task
(
async
function
testClearPrivateBrowsingState
(
)
{
gClientAuthDialogs
.
rememberClientAuthCertificate
=
true
;
gClientAuthDialogs
.
state
=
DialogState
.
RETURN_CERT_SELECTED
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
{
private
:
true
}
)
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
{
private
:
true
}
)
;
await
testHelper
(
"
Ask
Every
Time
"
"
https
:
/
/
requireclientcert
.
example
.
com
/
"
)
;
sdr
.
logoutAndTeardown
(
)
;
}
)
;
