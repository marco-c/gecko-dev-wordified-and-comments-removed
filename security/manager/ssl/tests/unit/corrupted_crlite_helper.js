"
use
strict
"
;
add_task
(
async
function
test_crlite_corrupted
(
)
{
let
securityStateDirectory
=
do_get_profile
(
)
;
securityStateDirectory
.
append
(
"
security_state
"
)
;
Services
.
prefs
.
setIntPref
(
"
security
.
pki
.
crlite_mode
"
CRLiteModeEnforcePrefValue
)
;
if
(
coverage
!
=
undefined
)
{
coverage
.
copyTo
(
securityStateDirectory
"
crlite
.
coverage
"
)
;
}
if
(
enrollment
!
=
undefined
)
{
enrollment
.
copyTo
(
securityStateDirectory
"
crlite
.
enrollment
"
)
;
}
if
(
filter
!
=
undefined
)
{
filter
.
copyTo
(
securityStateDirectory
"
crlite
.
filter
"
)
;
}
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
let
certStorage
=
Cc
[
"
mozilla
.
org
/
security
/
certstorage
;
1
"
]
.
getService
(
Ci
.
nsICertStorage
)
;
let
revokedCert
=
constructCertFromFile
(
"
test_crlite_filters
/
revoked
.
pem
"
)
;
let
issuerCert
=
constructCertFromFile
(
"
test_crlite_filters
/
issuer
.
pem
"
)
;
ok
(
issuerCert
"
issuer
certificate
should
decode
successfully
"
)
;
await
checkCertErrorGenericAtTime
(
certdb
revokedCert
PRErrorCodeSuccess
Ci
.
nsIX509CertDB
.
verifyUsageTLSServer
new
Date
(
"
2020
-
10
-
20T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
undefined
"
us
-
datarecovery
.
com
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
let
hasFilter
=
await
new
Promise
(
resolve
=
>
{
certStorage
.
hasPriorData
(
Ci
.
nsICertStorage
.
DATA_TYPE_CRLITE_FILTER_FULL
(
rv
result
)
=
>
{
Assert
.
equal
(
rv
Cr
.
NS_OK
"
hasPriorData
should
succeed
"
)
;
resolve
(
result
)
;
}
)
;
}
)
;
Assert
.
equal
(
hasFilter
false
"
CRLite
should
not
have
a
filter
"
)
;
let
hasStash
=
await
new
Promise
(
resolve
=
>
{
certStorage
.
hasPriorData
(
Ci
.
nsICertStorage
.
DATA_TYPE_CRLITE_FILTER_INCREMENTAL
(
rv
result
)
=
>
{
Assert
.
equal
(
rv
Cr
.
NS_OK
"
hasPriorData
should
succeed
"
)
;
resolve
(
result
)
;
}
)
;
}
)
;
Assert
.
equal
(
hasStash
false
"
CRLite
should
not
have
a
stash
"
)
;
}
)
;
