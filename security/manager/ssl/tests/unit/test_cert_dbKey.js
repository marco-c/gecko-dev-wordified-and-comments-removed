"
use
strict
"
;
function
hexStringToBytes
(
hex
)
{
let
bytes
=
[
]
;
for
(
let
hexByteStr
of
hex
.
split
(
"
:
"
)
)
{
bytes
.
push
(
parseInt
(
hexByteStr
16
)
)
;
}
return
bytes
;
}
function
encodeCommonNameAsBytes
(
commonName
)
{
ok
(
commonName
.
length
<
=
116
"
test
assumption
:
common
name
can
'
t
be
longer
than
116
bytes
(
makes
"
+
"
DER
encoding
easier
)
"
)
;
let
commonNameOIDBytes
=
[
0x06
0x03
0x55
0x04
0x03
]
;
let
commonNameBytes
=
[
0x0C
commonName
.
length
]
;
for
(
let
i
=
0
;
i
<
commonName
.
length
;
i
+
+
)
{
commonNameBytes
.
push
(
commonName
.
charCodeAt
(
i
)
)
;
}
let
bytes
=
commonNameOIDBytes
.
concat
(
commonNameBytes
)
;
bytes
.
unshift
(
bytes
.
length
)
;
bytes
.
unshift
(
0x30
)
;
bytes
.
unshift
(
bytes
.
length
)
;
bytes
.
unshift
(
0x31
)
;
bytes
.
unshift
(
bytes
.
length
)
;
bytes
.
unshift
(
0x30
)
;
return
bytes
;
}
function
testInvalidDBKey
(
certDB
dbKey
)
{
let
exceptionCaught
=
false
;
try
{
let
cert
=
certDB
.
findCertByDBKey
(
dbKey
null
)
;
}
catch
(
e
)
{
do_print
(
e
)
;
exceptionCaught
=
true
;
}
ok
(
exceptionCaught
"
should
have
thrown
and
caught
an
exception
"
)
;
}
function
testDBKeyForNonexistentCert
(
certDB
dbKey
)
{
let
cert
=
certDB
.
findCertByDBKey
(
dbKey
null
)
;
ok
(
!
cert
"
shouldn
'
t
find
cert
for
given
dbKey
"
)
;
}
function
byteArrayToByteString
(
bytes
)
{
let
byteString
=
"
"
;
for
(
let
b
of
bytes
)
{
byteString
+
=
String
.
fromCharCode
(
b
)
;
}
return
byteString
;
}
function
run_test
(
)
{
do_get_profile
(
)
;
let
certDB
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
let
cert
=
constructCertFromFile
(
"
bad_certs
/
test
-
ca
.
pem
"
)
;
equal
(
cert
.
issuerName
"
CN
=
"
+
cert
.
issuerCommonName
"
test
assumption
:
this
certificate
'
s
issuer
distinguished
name
"
+
"
consists
only
of
a
common
name
"
)
;
let
issuerBytes
=
encodeCommonNameAsBytes
(
cert
.
issuerCommonName
)
;
ok
(
issuerBytes
.
length
<
256
"
test
assumption
:
length
of
encoded
issuer
is
less
than
256
bytes
"
)
;
let
serialNumberBytes
=
hexStringToBytes
(
cert
.
serialNumber
)
;
ok
(
serialNumberBytes
.
length
<
256
"
test
assumption
:
length
of
encoded
serial
number
is
less
than
256
bytes
"
)
;
let
dbKeyHeader
=
[
0
0
0
0
0
0
0
0
0
0
0
serialNumberBytes
.
length
0
0
0
issuerBytes
.
length
]
;
let
expectedDbKeyBytes
=
dbKeyHeader
.
concat
(
serialNumberBytes
issuerBytes
)
;
let
expectedDbKey
=
btoa
(
byteArrayToByteString
(
expectedDbKeyBytes
)
)
;
equal
(
cert
.
dbKey
expectedDbKey
"
actual
and
expected
dbKey
values
should
match
"
)
;
let
certFromDbKey
=
certDB
.
findCertByDBKey
(
expectedDbKey
null
)
;
ok
(
certFromDbKey
.
equals
(
cert
)
"
nsIX509CertDB
.
findCertByDBKey
should
find
the
right
certificate
"
)
;
ok
(
expectedDbKey
.
length
>
64
"
test
assumption
:
dbKey
should
be
longer
than
64
characters
"
)
;
let
expectedDbKeyWithCRLF
=
expectedDbKey
.
replace
(
/
(
.
{
64
}
)
/
"
1
\
r
\
n
"
)
;
ok
(
expectedDbKeyWithCRLF
.
indexOf
(
"
\
r
\
n
"
)
=
=
64
"
test
self
-
check
:
adding
CRLF
to
dbKey
should
succeed
"
)
;
certFromDbKey
=
certDB
.
findCertByDBKey
(
expectedDbKeyWithCRLF
null
)
;
ok
(
certFromDbKey
.
equals
(
cert
)
"
nsIX509CertDB
.
findCertByDBKey
should
work
with
dbKey
with
CRLF
"
)
;
let
expectedDbKeyWithSpaces
=
expectedDbKey
.
replace
(
/
(
.
{
64
}
)
/
"
1
"
)
;
ok
(
expectedDbKeyWithSpaces
.
indexOf
(
"
"
)
=
=
64
"
test
self
-
check
:
adding
spaces
to
dbKey
should
succeed
"
)
;
certFromDbKey
=
certDB
.
findCertByDBKey
(
expectedDbKeyWithSpaces
null
)
;
ok
(
certFromDbKey
.
equals
(
cert
)
"
nsIX509CertDB
.
findCertByDBKey
should
work
with
dbKey
with
spaces
"
)
;
testInvalidDBKey
(
certDB
"
AAAA
"
)
;
testInvalidDBKey
(
certDB
btoa
(
byteArrayToByteString
(
[
0
0
0
serialNumberBytes
.
length
0
0
0
issuerBytes
.
length
]
.
concat
(
serialNumberBytes
issuerBytes
)
)
)
)
;
testInvalidDBKey
(
certDB
btoa
(
byteArrayToByteString
(
[
0
0
0
0
0
0
0
0
255
255
255
255
255
255
255
255
0
0
0
0
]
)
)
)
;
testInvalidDBKey
(
certDB
btoa
(
byteArrayToByteString
(
[
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
10
1
1
2
3
]
)
)
)
;
testDBKeyForNonexistentCert
(
certDB
btoa
(
byteArrayToByteString
(
[
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
3
1
1
2
3
]
)
)
)
;
testDBKeyForNonexistentCert
(
certDB
btoa
(
byteArrayToByteString
(
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
)
)
;
}
