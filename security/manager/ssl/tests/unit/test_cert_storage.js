"
use
strict
"
;
const
{
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
const
{
RemoteSecuritySettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
psm
/
RemoteSecuritySettings
.
jsm
"
)
;
var
id
=
"
xpcshell
tests
.
mozilla
.
org
"
;
var
appName
=
"
XPCShell
"
;
var
version
=
"
1
"
;
var
platformVersion
=
"
1
.
9
.
2
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
this
)
;
updateAppInfo
(
{
name
:
appName
ID
:
id
version
platformVersion
:
platformVersion
?
platformVersion
:
"
1
.
0
"
crashReporter
:
true
}
)
;
var
gProfile
=
do_get_profile
(
)
;
var
gRevocations
=
gProfile
.
clone
(
)
;
gRevocations
.
append
(
"
revocations
.
txt
"
)
;
if
(
!
gRevocations
.
exists
(
)
)
{
let
existing
=
do_get_file
(
"
test_onecrl
/
sample_revocations
.
txt
"
false
)
;
existing
.
copyTo
(
gProfile
"
revocations
.
txt
"
)
;
}
var
certDB
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
const
certBlocklist
=
[
{
issuerName
:
"
Some
nonsense
in
issuer
"
serialNumber
:
"
AkHVNA
=
=
"
}
{
issuerName
:
"
MA0xCzAJBgNVBAMMAmNh
"
serialNumber
:
"
some
nonsense
in
serial
"
}
{
issuerName
:
"
and
serial
"
serialNumber
:
"
some
nonsense
in
both
issuer
"
}
{
issuerName
:
"
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
"
serialNumber
:
"
oops
!
more
nonsense
.
"
}
{
issuerName
:
"
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
"
serialNumber
:
"
a0X7
/
7DlTaedpgrIJg25iBPOkIM
=
"
}
{
issuerName
:
"
MBgxFjAUBgNVBAMMDU90aGVyIHRlc3QgQ0E
=
"
serialNumber
:
"
Rym6o
+
VN9xgZXT
/
QLrvN
/
nv1ZN4
=
"
}
{
issuerName
:
"
MBwxGjAYBgNVBAMMEVRlc3QgSW50ZXJtZWRpYXRl
"
serialNumber
:
"
Tg
=
=
"
}
{
issuerName
:
"
MBwxGjAYBgNVBAMMEVRlc3QgSW50ZXJtZWRpYXRl
"
serialNumber
:
"
Hw
=
=
"
}
{
subject
:
"
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
"
pubKeyHash
:
"
VCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
"
}
]
;
function
verify_cert
(
file
expectedError
)
{
let
ee
=
constructCertFromFile
(
file
)
;
return
checkCertErrorGeneric
(
certDB
ee
expectedError
certificateUsageSSLServer
)
;
}
async
function
verify_non_tls_usage_succeeds
(
file
)
{
let
ee
=
constructCertFromFile
(
file
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageSSLClient
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageEmailSigner
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageEmailRecipient
)
;
}
function
load_cert
(
cert
trust
)
{
let
file
=
"
bad_certs
/
"
+
cert
+
"
.
pem
"
;
addCertFromFile
(
certDB
file
trust
)
;
}
async
function
update_blocklist
(
)
{
const
{
OneCRLBlocklistClient
}
=
RemoteSecuritySettings
.
init
(
)
;
const
fakeEvent
=
{
current
:
certBlocklist
deleted
:
[
]
created
:
certBlocklist
updated
:
[
]
}
;
await
OneCRLBlocklistClient
.
emit
(
"
sync
"
{
data
:
fakeEvent
}
)
;
Services
.
prefs
.
setIntPref
(
OneCRLBlocklistClient
.
lastCheckTimePref
Math
.
floor
(
Date
.
now
(
)
/
1000
)
)
;
}
function
*
generate_revocations_txt_lines
(
)
{
let
profile
=
do_get_profile
(
)
;
let
revocations
=
profile
.
clone
(
)
;
revocations
.
append
(
"
revocations
.
txt
"
)
;
ok
(
revocations
.
exists
(
)
"
the
revocations
file
should
exist
"
)
;
let
inputStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
inputStream
.
init
(
revocations
-
1
-
1
0
)
;
inputStream
.
QueryInterface
(
Ci
.
nsILineInputStream
)
;
let
hasmore
=
false
;
do
{
let
line
=
{
}
;
hasmore
=
inputStream
.
readLine
(
line
)
;
yield
line
.
value
;
}
while
(
hasmore
)
;
}
function
run_test
(
)
{
load_cert
(
"
test
-
ca
"
"
CTu
CTu
CTu
"
)
;
load_cert
(
"
test
-
int
"
"
"
)
;
load_cert
(
"
other
-
test
-
ca
"
"
CTu
CTu
CTu
"
)
;
let
certList
=
Cc
[
"
mozilla
.
org
/
security
/
certstorage
;
1
"
]
.
getService
(
Ci
.
nsICertStorage
)
;
add_task
(
async
function
(
)
{
let
file
=
"
test_onecrl
/
ee
-
revoked
-
by
-
revocations
-
txt
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
another
-
ee
-
revoked
-
by
-
revocations
-
txt
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
another
-
ee
-
revoked
-
by
-
revocations
-
txt
-
serial
-
2
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
ee
-
revoked
-
by
-
subject
-
and
-
pubkey
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
test
-
int
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
bad_certs
/
other
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
test_onecrl
/
same
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
}
)
;
add_task
(
update_blocklist
)
;
add_task
(
async
function
(
)
{
let
file
=
"
test_onecrl
/
ee
-
revoked
-
by
-
revocations
-
txt
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
another
-
ee
-
revoked
-
by
-
revocations
-
txt
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
another
-
ee
-
revoked
-
by
-
revocations
-
txt
-
serial
-
2
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
ee
-
revoked
-
by
-
subject
-
and
-
pubkey
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
test
-
int
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
bad_certs
/
other
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
test_onecrl
/
same
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
bad_certs
/
default
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
bad_certs
/
unknownissuer
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_UNKNOWN_ISSUER
)
;
}
)
;
add_task
(
async
function
(
)
{
ok
(
certList
.
isBlocklistFresh
(
)
"
Blocklist
should
be
fresh
.
"
)
;
}
)
;
run_next_test
(
)
;
}
