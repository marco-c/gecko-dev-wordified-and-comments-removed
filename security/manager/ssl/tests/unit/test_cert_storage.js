"
use
strict
"
;
const
{
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
{
}
)
;
const
BlocklistClients
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
blocklist
-
clients
.
js
"
{
}
)
;
var
id
=
"
xpcshell
tests
.
mozilla
.
org
"
;
var
appName
=
"
XPCShell
"
;
var
version
=
"
1
"
;
var
platformVersion
=
"
1
.
9
.
2
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
this
)
;
updateAppInfo
(
{
name
:
appName
ID
:
id
version
platformVersion
:
platformVersion
?
platformVersion
:
"
1
.
0
"
crashReporter
:
true
}
)
;
var
gProfile
=
do_get_profile
(
)
;
var
gRevocations
=
gProfile
.
clone
(
)
;
gRevocations
.
append
(
"
revocations
.
txt
"
)
;
if
(
!
gRevocations
.
exists
(
)
)
{
let
existing
=
do_get_file
(
"
test_onecrl
/
sample_revocations
.
txt
"
false
)
;
existing
.
copyTo
(
gProfile
"
revocations
.
txt
"
)
;
}
var
certDB
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
var
testserver
=
new
HttpServer
(
)
;
const
kintoHelloViewJSON
=
{
"
settings
"
:
{
"
batch_max_requests
"
:
25
}
}
;
const
kintoChangesJSON
=
{
"
data
"
:
[
{
"
host
"
:
"
firefox
.
settings
.
services
.
mozilla
.
com
"
"
id
"
:
"
3ace9d8e
-
00b5
-
a353
-
7fd5
-
1f081ff482ba
"
"
last_modified
"
:
100000000000000000001
"
bucket
"
:
"
blocklists
"
"
collection
"
:
"
certificates
"
}
]
}
;
const
certMetadataJSON
=
{
"
data
"
:
{
}
}
;
const
certBlocklistJSON
=
{
"
data
"
:
[
+
{
"
id
"
:
"
1
"
"
last_modified
"
:
100000000000000000001
"
issuerName
"
:
"
Some
nonsense
in
issuer
"
"
serialNumber
"
:
"
AkHVNA
=
=
"
}
{
"
id
"
:
"
2
"
"
last_modified
"
:
100000000000000000002
"
issuerName
"
:
"
MA0xCzAJBgNVBAMMAmNh
"
"
serialNumber
"
:
"
some
nonsense
in
serial
"
}
{
"
id
"
:
"
3
"
"
last_modified
"
:
100000000000000000003
"
issuerName
"
:
"
and
serial
"
"
serialNumber
"
:
"
some
nonsense
in
both
issuer
"
}
+
{
"
id
"
:
"
4
"
"
last_modified
"
:
100000000000000000004
"
issuerName
"
:
"
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
"
"
serialNumber
"
:
"
oops
!
more
nonsense
.
"
}
+
{
"
id
"
:
"
5
"
"
last_modified
"
:
100000000000000000004
"
issuerName
"
:
"
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
"
"
serialNumber
"
:
"
a0X7
/
7DlTaedpgrIJg25iBPOkIM
=
"
}
+
{
"
id
"
:
"
6
"
"
last_modified
"
:
100000000000000000005
"
issuerName
"
:
"
MBgxFjAUBgNVBAMMDU90aGVyIHRlc3QgQ0E
=
"
"
serialNumber
"
:
"
Rym6o
+
VN9xgZXT
/
QLrvN
/
nv1ZN4
=
"
}
+
{
"
id
"
:
"
7
"
"
last_modified
"
:
100000000000000000006
"
issuerName
"
:
"
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
"
"
serialNumber
"
:
"
c2VyaWFsMi4
=
"
}
+
{
"
id
"
:
"
8
"
"
last_modified
"
:
100000000000000000006
"
issuerName
"
:
"
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
"
"
serialNumber
"
:
"
YW5vdGhlciBzZXJpYWwu
"
}
+
{
"
id
"
:
"
9
"
"
last_modified
"
:
100000000000000000007
"
subject
"
:
"
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
"
"
pubKeyHash
"
:
"
VCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
"
}
]
}
;
function
serveResponse
(
body
)
{
return
(
req
response
)
=
>
{
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
;
charset
=
UTF
-
8
"
)
;
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
body
)
;
}
;
}
testserver
.
registerPathHandler
(
"
/
v1
/
"
serveResponse
(
kintoHelloViewJSON
)
)
;
testserver
.
registerPathHandler
(
"
/
v1
/
buckets
/
monitor
/
collections
/
changes
/
records
"
serveResponse
(
kintoChangesJSON
)
)
;
testserver
.
registerPathHandler
(
"
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
"
serveResponse
(
certMetadataJSON
)
)
;
testserver
.
registerPathHandler
(
"
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
"
serveResponse
(
certBlocklistJSON
)
)
;
testserver
.
start
(
-
1
)
;
var
port
=
testserver
.
identity
.
primaryPort
;
var
addonManager
=
Cc
[
"
mozilla
.
org
/
addons
/
integration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
QueryInterface
(
Ci
.
nsITimerCallback
)
;
addonManager
.
observe
(
null
"
addons
-
startup
"
null
)
;
function
verify_cert
(
file
expectedError
)
{
let
ee
=
constructCertFromFile
(
file
)
;
return
checkCertErrorGeneric
(
certDB
ee
expectedError
certificateUsageSSLServer
)
;
}
async
function
verify_non_tls_usage_succeeds
(
file
)
{
let
ee
=
constructCertFromFile
(
file
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageSSLClient
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageEmailSigner
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageEmailRecipient
)
;
}
function
load_cert
(
cert
trust
)
{
let
file
=
"
bad_certs
/
"
+
cert
+
"
.
pem
"
;
addCertFromFile
(
certDB
file
trust
)
;
}
function
test_is_revoked
(
certList
issuerString
serialString
subjectString
pubKeyString
)
{
return
certList
.
getRevocationState
(
btoa
(
issuerString
)
btoa
(
serialString
)
btoa
(
subjectString
)
btoa
(
pubKeyString
)
)
=
=
Ci
.
nsICertStorage
.
STATE_ENFORCE
;
}
function
fetch_blocklist
(
)
{
Services
.
prefs
.
setBoolPref
(
"
services
.
settings
.
load_dump
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
services
.
settings
.
verify_signature
"
false
)
;
Services
.
prefs
.
setCharPref
(
"
services
.
settings
.
server
"
http
:
/
/
localhost
:
{
port
}
/
v1
)
;
BlocklistClients
.
initialize
(
)
;
return
RemoteSettings
.
pollChanges
(
)
;
}
function
run_test
(
)
{
load_cert
(
"
test
-
ca
"
"
CTu
CTu
CTu
"
)
;
load_cert
(
"
test
-
int
"
"
"
)
;
load_cert
(
"
other
-
test
-
ca
"
"
CTu
CTu
CTu
"
)
;
let
certList
=
Cc
[
"
mozilla
.
org
/
security
/
certstorage
;
1
"
]
.
getService
(
Ci
.
nsICertStorage
)
;
add_task
(
async
function
(
)
{
ok
(
test_is_revoked
(
certList
"
some
imaginary
issuer
"
"
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
let
file
=
"
test_onecrl
/
test
-
int
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
bad_certs
/
other
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
test_onecrl
/
same
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
}
)
;
add_task
(
fetch_blocklist
)
;
add_task
(
async
function
(
)
{
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
another
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
nonsense
"
"
more
nonsense
"
"
some
imaginary
subject
"
"
some
imaginary
pubkey
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
let
file
=
"
test_onecrl
/
test
-
int
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
bad_certs
/
other
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
test_onecrl
/
same
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
bad_certs
/
default
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
bad_certs
/
unknownissuer
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_UNKNOWN_ISSUER
)
;
}
)
;
add_task
(
async
function
(
)
{
ok
(
certList
.
isBlocklistFresh
(
)
"
Blocklist
should
be
fresh
.
"
)
;
}
)
;
run_next_test
(
)
;
}
