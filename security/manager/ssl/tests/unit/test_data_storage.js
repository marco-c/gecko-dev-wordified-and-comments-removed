"
use
strict
"
;
do_get_profile
(
)
;
let
dataStorageManager
=
Cc
[
"
mozilla
.
org
/
security
/
datastoragemanager
;
1
"
]
.
getService
(
Ci
.
nsIDataStorageManager
)
;
let
dataStorage
=
dataStorageManager
.
get
(
Ci
.
nsIDataStorageManager
.
ClientAuthRememberList
)
;
add_task
(
function
test_data_storage
(
)
{
Assert
.
equal
(
dataStorage
.
getAll
(
)
.
length
0
)
;
dataStorage
.
put
(
"
test
"
"
value
"
Ci
.
nsIDataStorage
.
Persistent
)
;
Assert
.
equal
(
dataStorage
.
get
(
"
test
"
Ci
.
nsIDataStorage
.
Persistent
)
"
value
"
)
;
Assert
.
throws
(
(
)
=
>
dataStorage
.
get
(
"
test
"
Ci
.
nsIDataStorage
.
Private
)
/
NS_ERROR_NOT_AVAILABLE
/
"
getting
a
value
of
a
type
that
hasn
'
t
been
set
yet
should
throw
"
)
;
dataStorage
.
put
(
"
test
"
"
private
"
Ci
.
nsIDataStorage
.
Private
)
;
Assert
.
equal
(
dataStorage
.
get
(
"
test
"
Ci
.
nsIDataStorage
.
Private
)
"
private
"
)
;
Assert
.
equal
(
dataStorage
.
get
(
"
test
"
Ci
.
nsIDataStorage
.
Persistent
)
"
value
"
)
;
dataStorage
.
put
(
"
test
"
"
new
"
Ci
.
nsIDataStorage
.
Persistent
)
;
Assert
.
equal
(
dataStorage
.
get
(
"
test
"
Ci
.
nsIDataStorage
.
Persistent
)
"
new
"
)
;
dataStorage
.
remove
(
"
test
"
Ci
.
nsIDataStorage
.
Persistent
)
;
Assert
.
throws
(
(
)
=
>
dataStorage
.
get
(
"
test
"
Ci
.
nsIDataStorage
.
Persistent
)
/
NS_ERROR_NOT_AVAILABLE
/
"
getting
a
removed
value
should
throw
"
)
;
Assert
.
equal
(
dataStorage
.
get
(
"
test
"
Ci
.
nsIDataStorage
.
Private
)
"
private
"
)
;
dataStorage
.
remove
(
"
test
"
Ci
.
nsIDataStorage
.
Private
)
;
Assert
.
throws
(
(
)
=
>
dataStorage
.
get
(
"
test
"
Ci
.
nsIDataStorage
.
Private
)
/
NS_ERROR_NOT_AVAILABLE
/
"
getting
a
removed
value
should
throw
"
)
;
for
(
let
i
=
0
;
i
<
2048
;
i
+
+
)
{
let
padded
=
i
.
toString
(
)
.
padStart
(
4
"
0
"
)
;
dataStorage
.
put
(
key
{
padded
}
value
{
padded
}
Ci
.
nsIDataStorage
.
Persistent
)
;
dataStorage
.
put
(
key
{
padded
}
value
{
padded
}
Ci
.
nsIDataStorage
.
Private
)
;
}
for
(
let
i
=
0
;
i
<
2048
;
i
+
+
)
{
let
padded
=
i
.
toString
(
)
.
padStart
(
4
"
0
"
)
;
let
val
=
dataStorage
.
get
(
key
{
padded
}
Ci
.
nsIDataStorage
.
Persistent
)
;
Assert
.
equal
(
val
value
{
padded
}
)
;
val
=
dataStorage
.
get
(
key
{
padded
}
Ci
.
nsIDataStorage
.
Private
)
;
Assert
.
equal
(
val
value
{
padded
}
)
;
}
for
(
let
i
=
0
;
i
<
2048
;
i
+
+
)
{
let
padded
=
i
.
toString
(
)
.
padStart
(
4
"
0
"
)
;
dataStorage
.
remove
(
key
{
padded
}
Ci
.
nsIDataStorage
.
Persistent
)
;
dataStorage
.
remove
(
key
{
padded
}
Ci
.
nsIDataStorage
.
Private
)
;
}
for
(
let
i
=
0
;
i
<
2048
;
i
+
+
)
{
let
padded
=
i
.
toString
(
)
.
padStart
(
4
"
0
"
)
;
Assert
.
throws
(
(
)
=
>
dataStorage
.
get
(
key
{
padded
}
Ci
.
nsIDataStorage
.
Persistent
)
/
NS_ERROR_NOT_AVAILABLE
/
"
getting
a
removed
value
should
throw
"
)
;
Assert
.
throws
(
(
)
=
>
dataStorage
.
get
(
key
{
padded
}
Ci
.
nsIDataStorage
.
Private
)
/
NS_ERROR_NOT_AVAILABLE
/
"
getting
a
removed
value
should
throw
"
)
;
}
Assert
.
equal
(
dataStorage
.
getAll
(
)
.
length
0
)
;
for
(
let
i
=
0
;
i
<
2048
;
i
+
+
)
{
let
padded
=
i
.
toString
(
)
.
padStart
(
5
"
*
"
)
;
dataStorage
.
put
(
key
{
padded
}
value
{
padded
}
Ci
.
nsIDataStorage
.
Persistent
)
;
dataStorage
.
put
(
key
{
padded
}
value
{
padded
}
Ci
.
nsIDataStorage
.
Private
)
;
}
for
(
let
i
=
0
;
i
<
2048
;
i
+
+
)
{
let
padded
=
i
.
toString
(
)
.
padStart
(
5
"
*
"
)
;
let
val
=
dataStorage
.
get
(
key
{
padded
}
Ci
.
nsIDataStorage
.
Persistent
)
;
Assert
.
equal
(
val
value
{
padded
}
)
;
val
=
dataStorage
.
get
(
key
{
padded
}
Ci
.
nsIDataStorage
.
Private
)
;
Assert
.
equal
(
val
value
{
padded
}
)
;
}
let
entries
=
dataStorage
.
getAll
(
)
;
Assert
.
equal
(
entries
.
length
4096
)
;
let
persistentEntries
=
entries
.
filter
(
entry
=
>
entry
.
type
=
=
Ci
.
nsIDataStorage
.
Persistent
)
;
Assert
.
equal
(
persistentEntries
.
length
2048
)
;
let
privateEntries
=
entries
.
filter
(
entry
=
>
entry
.
type
=
=
Ci
.
nsIDataStorage
.
Private
)
;
Assert
.
equal
(
privateEntries
.
length
2048
)
;
let
compareEntries
=
(
a
b
)
=
>
{
if
(
a
.
key
<
b
.
key
)
{
return
-
1
;
}
if
(
a
.
key
=
=
b
.
key
)
{
return
0
;
}
return
1
;
}
;
persistentEntries
.
sort
(
compareEntries
)
;
privateEntries
.
sort
(
compareEntries
)
;
for
(
let
i
=
0
;
i
<
2048
;
i
+
+
)
{
let
padded
=
i
.
toString
(
)
.
padStart
(
5
"
*
"
)
;
Assert
.
equal
(
persistentEntries
[
i
]
.
key
key
{
padded
}
)
;
Assert
.
equal
(
persistentEntries
[
i
]
.
value
value
{
padded
}
)
;
Assert
.
equal
(
privateEntries
[
i
]
.
key
key
{
padded
}
)
;
Assert
.
equal
(
privateEntries
[
i
]
.
value
value
{
padded
}
)
;
}
}
)
;
