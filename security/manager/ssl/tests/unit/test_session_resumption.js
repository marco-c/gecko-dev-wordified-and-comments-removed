"
use
strict
"
;
do_get_profile
(
)
;
const
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
security
.
OCSP
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
network
.
ssl_tokens_cache_enabled
"
)
;
}
)
;
Services
.
prefs
.
setIntPref
(
"
security
.
OCSP
.
enabled
"
1
)
;
addCertFromFile
(
certdb
"
bad_certs
/
evroot
.
pem
"
"
CTu
"
)
;
addCertFromFile
(
certdb
"
bad_certs
/
ev
-
test
-
intermediate
.
pem
"
"
"
)
;
function
add_resume_non_ev_with_override_test
(
)
{
add_cert_override_test
(
"
expired
.
example
.
com
"
SEC_ERROR_EXPIRED_CERTIFICATE
)
;
add_connection_test
(
"
expired
.
example
.
com
"
PRErrorCodeSuccess
null
transportSecurityInfo
=
>
{
ok
(
transportSecurityInfo
.
securityState
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_USER_OVERRIDDEN
"
expired
.
example
.
com
should
have
STATE_CERT_USER_OVERRIDDEN
flag
"
)
;
equal
(
transportSecurityInfo
.
succeededCertChain
.
length
0
"
ev
-
test
.
example
.
com
should
not
have
succeededCertChain
set
"
)
;
equal
(
transportSecurityInfo
.
overridableErrorCategory
Ci
.
nsITransportSecurityInfo
.
ERROR_TIME
"
expired
.
example
.
com
should
have
time
overridable
error
category
"
)
;
ok
(
!
transportSecurityInfo
.
isExtendedValidation
"
expired
.
example
.
com
should
not
have
isExtendedValidation
set
"
)
;
let
certOverrideService
=
Cc
[
"
mozilla
.
org
/
security
/
certoverride
;
1
"
]
.
getService
(
Ci
.
nsICertOverrideService
)
;
certOverrideService
.
clearValidityOverride
(
"
expired
.
example
.
com
"
8443
{
}
)
;
}
)
;
}
function
add_one_ev_test
(
)
{
add_connection_test
(
"
ev
-
test
.
example
.
com
"
PRErrorCodeSuccess
null
transportSecurityInfo
=
>
{
ok
(
!
(
transportSecurityInfo
.
securityState
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_USER_OVERRIDDEN
)
"
ev
-
test
.
example
.
com
should
not
have
STATE_CERT_USER_OVERRIDDEN
flag
"
)
;
ok
(
transportSecurityInfo
.
succeededCertChain
"
ev
-
test
.
example
.
com
should
have
succeededCertChain
set
"
)
;
equal
(
transportSecurityInfo
.
overridableErrorCategory
Ci
.
nsITransportSecurityInfo
.
ERROR_UNSET
"
ev
-
test
.
example
.
com
should
not
have
an
overridable
error
category
"
)
;
ok
(
!
gEVExpected
|
|
transportSecurityInfo
.
isExtendedValidation
"
ev
-
test
.
example
.
com
should
have
isExtendedValidation
set
"
+
"
(
or
this
is
a
non
-
debug
build
)
"
)
;
}
)
;
}
function
add_resume_ev_test
(
)
{
const
SERVER_PORT
=
8888
;
let
expectedRequestPaths
=
[
"
ev
-
test
"
]
;
let
responseTypes
=
[
"
good
"
]
;
let
ocspResponder
;
add_test
(
(
)
=
>
{
ocspResponder
=
startOCSPResponder
(
SERVER_PORT
"
localhost
"
"
bad_certs
"
expectedRequestPaths
expectedRequestPaths
.
slice
(
)
null
responseTypes
)
;
run_next_test
(
)
;
}
)
;
add_one_ev_test
(
)
;
add_one_ev_test
(
)
;
add_test
(
(
)
=
>
{
ocspResponder
.
stop
(
run_next_test
)
;
}
)
;
}
const
GOOD_DOMAIN
=
"
good
.
include
-
subdomains
.
pinning
.
example
.
com
"
;
function
add_one_non_ev_test
(
)
{
add_connection_test
(
GOOD_DOMAIN
PRErrorCodeSuccess
null
transportSecurityInfo
=
>
{
ok
(
!
(
transportSecurityInfo
.
securityState
&
Ci
.
nsIWebProgressListener
.
STATE_CERT_USER_OVERRIDDEN
)
{
GOOD_DOMAIN
}
should
not
have
STATE_CERT_USER_OVERRIDDEN
flag
)
;
ok
(
transportSecurityInfo
.
succeededCertChain
{
GOOD_DOMAIN
}
should
have
succeededCertChain
set
)
;
equal
(
transportSecurityInfo
.
overridableErrorCategory
0
{
GOOD_DOMAIN
}
should
not
have
an
overridable
error
category
set
)
;
ok
(
!
transportSecurityInfo
.
isExtendedValidation
{
GOOD_DOMAIN
}
should
not
have
isExtendedValidation
set
)
;
}
)
;
}
function
add_resume_non_ev_test
(
)
{
add_one_non_ev_test
(
)
;
add_one_non_ev_test
(
)
;
}
const
statsPtr
=
getSSLStatistics
(
)
;
const
toInt32
=
ctypes
.
Int64
.
lo
;
function
add_origin_attributes_test
(
originAttributes1
originAttributes2
resumeExpected
)
{
add_connection_test
(
GOOD_DOMAIN
PRErrorCodeSuccess
clearSessionCache
null
null
originAttributes1
)
;
let
hitsBeforeConnect
;
let
missesBeforeConnect
;
let
expectedHits
=
resumeExpected
?
1
:
0
;
let
expectedMisses
=
1
-
expectedHits
;
add_connection_test
(
GOOD_DOMAIN
PRErrorCodeSuccess
function
(
)
{
let
stats
=
statsPtr
.
contents
;
hitsBeforeConnect
=
toInt32
(
stats
.
sch_sid_cache_hits
)
;
missesBeforeConnect
=
toInt32
(
stats
.
sch_sid_cache_misses
)
;
}
function
(
)
{
let
stats
=
statsPtr
.
contents
;
equal
(
toInt32
(
stats
.
sch_sid_cache_hits
)
hitsBeforeConnect
+
expectedHits
"
Unexpected
cache
hits
"
)
;
equal
(
toInt32
(
stats
.
sch_sid_cache_misses
)
missesBeforeConnect
+
expectedMisses
"
Unexpected
cache
misses
"
)
;
}
null
originAttributes2
)
;
}
function
add_resumption_tests
(
)
{
add_resume_ev_test
(
)
;
add_resume_non_ev_test
(
)
;
add_resume_non_ev_with_override_test
(
)
;
add_origin_attributes_test
(
{
}
{
}
true
)
;
add_origin_attributes_test
(
{
userContextId
:
1
}
{
userContextId
:
2
}
false
)
;
add_origin_attributes_test
(
{
userContextId
:
3
}
{
userContextId
:
3
}
true
)
;
add_origin_attributes_test
(
{
firstPartyDomain
:
"
foo
.
com
"
}
{
firstPartyDomain
:
"
bar
.
com
"
}
false
)
;
add_origin_attributes_test
(
{
firstPartyDomain
:
"
baz
.
com
"
}
{
firstPartyDomain
:
"
baz
.
com
"
}
true
)
;
}
function
run_test
(
)
{
add_tls_server_setup
(
"
BadCertAndPinningServer
"
"
bad_certs
"
)
;
add_resumption_tests
(
)
;
add_test
(
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
network
.
ssl_tokens_cache_enabled
"
true
)
;
certdb
.
clearOCSPCache
(
)
;
run_next_test
(
)
;
}
)
;
add_resumption_tests
(
)
;
run_next_test
(
)
;
}
