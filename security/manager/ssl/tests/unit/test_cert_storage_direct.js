"
use
strict
"
;
do_get_profile
(
)
;
this
.
certStorage
=
Cc
[
"
mozilla
.
org
/
security
/
certstorage
;
1
"
]
.
getService
(
Ci
.
nsICertStorage
)
;
async
function
addCerts
(
certInfos
)
{
let
result
=
await
new
Promise
(
resolve
=
>
{
certStorage
.
addCerts
(
certInfos
resolve
)
;
}
)
;
Assert
.
equal
(
result
Cr
.
NS_OK
"
addCerts
should
succeed
"
)
;
}
async
function
removeCertsByHashes
(
hashesBase64
)
{
let
result
=
await
new
Promise
(
resolve
=
>
{
certStorage
.
removeCertsByHashes
(
hashesBase64
resolve
)
;
}
)
;
Assert
.
equal
(
result
Cr
.
NS_OK
"
removeCertsByHashes
should
succeed
"
)
;
}
function
getLongString
(
uniquePart
length
)
{
return
String
(
uniquePart
)
.
padStart
(
length
"
0
"
)
;
}
class
CertInfo
{
constructor
(
cert
subject
)
{
this
.
cert
=
btoa
(
cert
)
;
this
.
subject
=
btoa
(
subject
)
;
this
.
trust
=
Ci
.
nsICertStorage
.
TRUST_INHERIT
;
}
}
CertInfo
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsICertInfo
"
]
)
;
add_task
(
async
function
test_common_subject
(
)
{
let
someCert1
=
new
CertInfo
(
"
some
certificate
bytes
1
"
"
some
common
subject
"
)
;
let
someCert2
=
new
CertInfo
(
"
some
certificate
bytes
2
"
"
some
common
subject
"
)
;
let
someCert3
=
new
CertInfo
(
"
some
certificate
bytes
3
"
"
some
common
subject
"
)
;
await
addCerts
(
[
someCert1
someCert2
someCert3
]
)
;
let
storedCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
some
common
subject
"
)
)
;
let
storedCertsAsStrings
=
storedCerts
.
map
(
arrayToString
)
;
let
expectedCerts
=
[
"
some
certificate
bytes
1
"
"
some
certificate
bytes
2
"
"
some
certificate
bytes
3
"
]
;
Assert
.
deepEqual
(
storedCertsAsStrings
.
sort
(
)
expectedCerts
.
sort
(
)
"
should
find
expected
certs
"
)
;
await
addCerts
(
[
new
CertInfo
(
"
some
other
certificate
bytes
"
"
some
other
subject
"
)
]
)
;
storedCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
some
common
subject
"
)
)
;
storedCertsAsStrings
=
storedCerts
.
map
(
arrayToString
)
;
Assert
.
deepEqual
(
storedCertsAsStrings
.
sort
(
)
expectedCerts
.
sort
(
)
"
should
still
find
expected
certs
"
)
;
let
storedOtherCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
some
other
subject
"
)
)
;
let
storedOtherCertsAsStrings
=
storedOtherCerts
.
map
(
arrayToString
)
;
let
expectedOtherCerts
=
[
"
some
other
certificate
bytes
"
]
;
Assert
.
deepEqual
(
storedOtherCertsAsStrings
expectedOtherCerts
"
should
have
other
certificate
"
)
;
}
)
;
add_task
(
async
function
test_many_entries
(
)
{
const
NUM_CERTS
=
500
;
const
CERT_LENGTH
=
3000
;
const
SUBJECT_LENGTH
=
40
;
let
certs
=
[
]
;
for
(
let
i
=
0
;
i
<
NUM_CERTS
;
i
+
+
)
{
certs
.
push
(
new
CertInfo
(
getLongString
(
i
CERT_LENGTH
)
getLongString
(
i
SUBJECT_LENGTH
)
)
)
;
}
await
addCerts
(
certs
)
;
for
(
let
i
=
0
;
i
<
NUM_CERTS
;
i
+
+
)
{
let
subject
=
stringToArray
(
getLongString
(
i
SUBJECT_LENGTH
)
)
;
let
storedCerts
=
certStorage
.
findCertsBySubject
(
subject
)
;
Assert
.
equal
(
storedCerts
.
length
1
"
should
have
1
certificate
(
lots
of
data
test
)
"
)
;
let
storedCertAsString
=
arrayToString
(
storedCerts
[
0
]
)
;
Assert
.
equal
(
storedCertAsString
getLongString
(
i
CERT_LENGTH
)
"
certificate
should
be
as
expected
(
lots
of
data
test
)
"
)
;
}
}
)
;
add_task
(
async
function
test_removal
(
)
{
await
removeCertsByHashes
(
[
btoa
(
"
thishashisthewrongsize
"
)
]
)
;
let
removalCert1
=
new
CertInfo
(
"
removal
certificate
bytes
1
"
"
common
subject
to
remove
"
)
;
let
removalCert2
=
new
CertInfo
(
"
removal
certificate
bytes
2
"
"
common
subject
to
remove
"
)
;
let
removalCert3
=
new
CertInfo
(
"
removal
certificate
bytes
3
"
"
common
subject
to
remove
"
)
;
await
addCerts
(
[
removalCert1
removalCert2
removalCert3
]
)
;
let
storedCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
common
subject
to
remove
"
)
)
;
let
storedCertsAsStrings
=
storedCerts
.
map
(
arrayToString
)
;
let
expectedCerts
=
[
"
removal
certificate
bytes
1
"
"
removal
certificate
bytes
2
"
"
removal
certificate
bytes
3
"
]
;
Assert
.
deepEqual
(
storedCertsAsStrings
.
sort
(
)
expectedCerts
.
sort
(
)
"
should
find
expected
certs
before
removing
them
"
)
;
await
removeCertsByHashes
(
[
"
2nUPHwl5TVr1mAD1FU9FivLTlTb0BAdnVUhsYgBccN4
=
"
]
)
;
storedCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
common
subject
to
remove
"
)
)
;
storedCertsAsStrings
=
storedCerts
.
map
(
arrayToString
)
;
expectedCerts
=
[
"
removal
certificate
bytes
1
"
"
removal
certificate
bytes
3
"
]
;
Assert
.
deepEqual
(
storedCertsAsStrings
.
sort
(
)
expectedCerts
.
sort
(
)
"
should
only
have
first
and
third
certificates
now
"
)
;
await
removeCertsByHashes
(
[
"
8zoRqHYrklr7Zx6UWpzrPuL
+
ol8KL1Ml6XHBQmXiaTY
=
"
]
)
;
storedCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
common
subject
to
remove
"
)
)
;
storedCertsAsStrings
=
storedCerts
.
map
(
arrayToString
)
;
expectedCerts
=
[
"
removal
certificate
bytes
3
"
]
;
Assert
.
deepEqual
(
storedCertsAsStrings
.
sort
(
)
expectedCerts
.
sort
(
)
"
should
only
have
third
certificate
now
"
)
;
await
removeCertsByHashes
(
[
"
vZn7GwDSabB
/
AVo0T
+
N26nUsfSXIIx4NgQtSi7
/
0p
/
w
=
"
]
)
;
storedCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
common
subject
to
remove
"
)
)
;
Assert
.
equal
(
storedCerts
.
length
0
"
shouldn
'
t
have
any
certificates
now
"
)
;
await
removeCertsByHashes
(
[
"
vZn7GwDSabB
/
AVo0T
+
N26nUsfSXIIx4NgQtSi7
/
0p
/
w
=
"
]
)
;
}
)
;
add_task
(
async
function
test_batched_removal
(
)
{
let
removalCert1
=
new
CertInfo
(
"
batch
removal
certificate
bytes
1
"
"
batch
subject
to
remove
"
)
;
let
removalCert2
=
new
CertInfo
(
"
batch
removal
certificate
bytes
2
"
"
batch
subject
to
remove
"
)
;
let
removalCert3
=
new
CertInfo
(
"
batch
removal
certificate
bytes
3
"
"
batch
subject
to
remove
"
)
;
await
addCerts
(
[
removalCert1
removalCert2
removalCert3
]
)
;
let
storedCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
batch
subject
to
remove
"
)
)
;
let
storedCertsAsStrings
=
storedCerts
.
map
(
arrayToString
)
;
let
expectedCerts
=
[
"
batch
removal
certificate
bytes
1
"
"
batch
removal
certificate
bytes
2
"
"
batch
removal
certificate
bytes
3
"
]
;
Assert
.
deepEqual
(
storedCertsAsStrings
.
sort
(
)
expectedCerts
.
sort
(
)
"
should
find
expected
certs
before
removing
them
"
)
;
await
removeCertsByHashes
(
[
"
EOEEUTuanHZX9NFVCoMKVT22puIJC6g
+
ZuNPpJgvaa8
=
"
"
Xz6h
/
Kvn35cCLJEZXkjPqk1GG36b56sreLyAXpO
+
0zg
=
"
"
Jr7XdiTT8ZONUL
+
ogNNMW2oxKxanvYOLQPKBPgH
/
has
=
"
]
)
;
storedCerts
=
certStorage
.
findCertsBySubject
(
stringToArray
(
"
batch
subject
to
remove
"
)
)
;
Assert
.
equal
(
storedCerts
.
length
0
"
shouldn
'
t
have
any
certificates
now
"
)
;
}
)
;
class
CRLiteState
{
constructor
(
subject
spkiHash
state
)
{
this
.
subject
=
btoa
(
subject
)
;
this
.
spkiHash
=
spkiHash
;
this
.
state
=
state
;
}
}
CRLiteState
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsICRLiteState
"
]
)
;
class
CRLiteCoverage
{
constructor
(
ctLogID
minTimestamp
maxTimestamp
)
{
this
.
b64LogID
=
ctLogID
;
this
.
minTimestamp
=
minTimestamp
;
this
.
maxTimestamp
=
maxTimestamp
;
}
}
CRLiteCoverage
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsICRLiteCoverage
"
]
)
;
async
function
addCRLiteState
(
state
)
{
let
result
=
await
new
Promise
(
resolve
=
>
{
certStorage
.
setCRLiteState
(
state
resolve
)
;
}
)
;
Assert
.
equal
(
result
Cr
.
NS_OK
"
setCRLiteState
should
succeed
"
)
;
}
add_task
(
async
function
test_crlite_state
(
)
{
let
crliteState1
=
new
CRLiteState
(
"
some
subject
1
"
"
bDlKlhR5ptlvuxclnZ3RQHznG8
/
3pgIybrRJ
/
Zvn9L8
=
"
Ci
.
nsICertStorage
.
STATE_ENFORCE
)
;
let
crliteState2
=
new
CRLiteState
(
"
some
subject
2
"
"
ZlXvlHhtdx4yKwkhZqg7Opv5T1ofwzorlsCoLf0wnlY
=
"
Ci
.
nsICertStorage
.
STATE_UNSET
)
;
let
crliteState3
=
new
CRLiteState
(
"
some
subject
3
"
"
pp1SRn6njaHX
/
c
+
b2uf82JPeBkWhPfTBp
/
Mxb3xkjRM
=
"
Ci
.
nsICertStorage
.
STATE_ENFORCE
)
;
await
addCRLiteState
(
[
crliteState1
crliteState2
crliteState3
]
)
;
let
state1
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
1
"
)
stringToArray
(
"
some
spki
1
"
)
)
;
Assert
.
equal
(
state1
Ci
.
nsICertStorage
.
STATE_ENFORCE
)
;
let
state2
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
2
"
)
stringToArray
(
"
some
spki
2
"
)
)
;
Assert
.
equal
(
state2
Ci
.
nsICertStorage
.
STATE_UNSET
)
;
let
state3
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
3
"
)
stringToArray
(
"
some
spki
3
"
)
)
;
Assert
.
equal
(
state3
Ci
.
nsICertStorage
.
STATE_ENFORCE
)
;
let
stateNeverSet
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
unknown
subject
"
)
stringToArray
(
"
some
unknown
spki
"
)
)
;
Assert
.
equal
(
stateNeverSet
Ci
.
nsICertStorage
.
STATE_UNSET
)
;
let
stateDifferentSubjectSPKI
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
3
"
)
stringToArray
(
"
some
spki
1
"
)
)
;
Assert
.
equal
(
stateDifferentSubjectSPKI
Ci
.
nsICertStorage
.
STATE_UNSET
)
;
let
anotherStateDifferentSubjectSPKI
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
1
"
)
stringToArray
(
"
some
spki
2
"
)
)
;
Assert
.
equal
(
anotherStateDifferentSubjectSPKI
Ci
.
nsICertStorage
.
STATE_UNSET
)
;
let
yetAnotherStateDifferentSubjectSPKI
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
2
"
)
stringToArray
(
"
some
spki
1
"
)
)
;
Assert
.
equal
(
yetAnotherStateDifferentSubjectSPKI
Ci
.
nsICertStorage
.
STATE_UNSET
)
;
crliteState3
=
new
CRLiteState
(
"
some
subject
3
"
"
pp1SRn6njaHX
/
c
+
b2uf82JPeBkWhPfTBp
/
Mxb3xkjRM
=
"
Ci
.
nsICertStorage
.
STATE_UNSET
)
;
await
addCRLiteState
(
[
crliteState3
]
)
;
state3
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
3
"
)
stringToArray
(
"
some
spki
3
"
)
)
;
Assert
.
equal
(
state3
Ci
.
nsICertStorage
.
STATE_UNSET
)
;
crliteState2
=
new
CRLiteState
(
"
some
subject
2
"
"
ZlXvlHhtdx4yKwkhZqg7Opv5T1ofwzorlsCoLf0wnlY
=
"
Ci
.
nsICertStorage
.
STATE_ENFORCE
)
;
await
addCRLiteState
(
[
crliteState2
]
)
;
state2
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
2
"
)
stringToArray
(
"
some
spki
2
"
)
)
;
Assert
.
equal
(
state2
Ci
.
nsICertStorage
.
STATE_ENFORCE
)
;
let
bogusValueState
=
new
CRLiteState
(
"
some
subject
4
"
"
1eA0
+
+
hCqzt8vpzREYSqHAqpEOLchZca1Gx8viCVYzc
=
"
2013003773
)
;
await
addCRLiteState
(
[
bogusValueState
]
)
;
let
bogusValueStateValue
=
certStorage
.
getCRLiteState
(
stringToArray
(
"
some
subject
4
"
)
stringToArray
(
"
some
spki
4
"
)
)
;
Assert
.
equal
(
bogusValueStateValue
-
3
)
;
}
)
;
async
function
enrollCertForCRLite
(
nsCert
)
{
let
{
subjectString
spkiHashString
}
=
getSubjectAndSPKIHash
(
nsCert
)
;
let
crliteState
=
new
CRLiteState
(
subjectString
spkiHashString
Ci
.
nsICertStorage
.
STATE_ENFORCE
)
;
await
addCRLiteState
(
[
crliteState
]
)
;
}
add_task
(
async
function
test_crlite_filter
(
)
{
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
let
validCertIssuer
=
constructCertFromFile
(
"
test_cert_storage_direct
/
valid
-
cert
-
issuer
.
pem
"
)
;
await
enrollCertForCRLite
(
validCertIssuer
)
;
let
validCert
=
constructCertFromFile
(
"
test_cert_storage_direct
/
valid
-
cert
.
pem
"
)
;
let
revokedCertIssuer
=
constructCertFromFile
(
"
test_cert_storage_direct
/
revoked
-
cert
-
issuer
.
pem
"
)
;
await
enrollCertForCRLite
(
revokedCertIssuer
)
;
let
revokedCert
=
constructCertFromFile
(
"
test_cert_storage_direct
/
revoked
-
cert
.
pem
"
)
;
let
filterFile
=
do_get_file
(
"
test_cert_storage_direct
/
test
-
filter
.
crlite
"
false
)
;
ok
(
filterFile
.
exists
(
)
"
test
filter
file
should
exist
"
)
;
let
coverage
=
[
]
;
let
filterBytes
=
stringToArray
(
readFile
(
filterFile
)
)
;
let
setFullCRLiteFilterResult
=
await
new
Promise
(
resolve
=
>
{
certStorage
.
setFullCRLiteFilter
(
filterBytes
coverage
resolve
)
;
}
)
;
Assert
.
equal
(
setFullCRLiteFilterResult
Cr
.
NS_OK
"
setFullCRLiteFilter
should
succeed
"
)
;
Services
.
prefs
.
setIntPref
(
"
security
.
pki
.
crlite_mode
"
CRLiteModeEnforcePrefValue
)
;
await
checkCertErrorGenericAtTime
(
certdb
validCert
PRErrorCodeSuccess
certificateUsageSSLServer
new
Date
(
"
2019
-
11
-
04T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
false
"
skynew
.
jp
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
await
checkCertErrorGenericAtTime
(
certdb
revokedCert
PRErrorCodeSuccess
certificateUsageSSLServer
new
Date
(
"
2019
-
11
-
04T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
false
"
schunk
-
group
.
com
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
coverage
.
push
(
new
CRLiteCoverage
(
"
pLkJkLQYWBSHuxOizGdwCjw1mAT5G9
+
443fNDsgN3BA
=
"
0
1641612275000
)
)
;
setFullCRLiteFilterResult
=
await
new
Promise
(
resolve
=
>
{
certStorage
.
setFullCRLiteFilter
(
filterBytes
coverage
resolve
)
;
}
)
;
Assert
.
equal
(
setFullCRLiteFilterResult
Cr
.
NS_OK
"
setFullCRLiteFilter
should
succeed
"
)
;
await
checkCertErrorGenericAtTime
(
certdb
validCert
PRErrorCodeSuccess
certificateUsageSSLServer
new
Date
(
"
2019
-
11
-
04T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
false
"
skynew
.
jp
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
await
checkCertErrorGenericAtTime
(
certdb
revokedCert
SEC_ERROR_REVOKED_CERTIFICATE
certificateUsageSSLServer
new
Date
(
"
2019
-
11
-
04T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
false
"
schunk
-
group
.
com
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
Services
.
prefs
.
setIntPref
(
"
security
.
pki
.
crlite_mode
"
CRLiteModeTelemetryOnlyPrefValue
)
;
await
checkCertErrorGenericAtTime
(
certdb
validCert
PRErrorCodeSuccess
certificateUsageSSLServer
new
Date
(
"
2019
-
11
-
04T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
false
"
skynew
.
jp
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
await
checkCertErrorGenericAtTime
(
certdb
revokedCert
PRErrorCodeSuccess
certificateUsageSSLServer
new
Date
(
"
2019
-
11
-
04T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
false
"
schunk
-
group
.
com
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
Services
.
prefs
.
setIntPref
(
"
security
.
pki
.
crlite_mode
"
CRLiteModeDisabledPrefValue
)
;
await
checkCertErrorGenericAtTime
(
certdb
validCert
PRErrorCodeSuccess
certificateUsageSSLServer
new
Date
(
"
2019
-
11
-
04T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
false
"
skynew
.
jp
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
await
checkCertErrorGenericAtTime
(
certdb
revokedCert
PRErrorCodeSuccess
certificateUsageSSLServer
new
Date
(
"
2019
-
11
-
04T00
:
00
:
00Z
"
)
.
getTime
(
)
/
1000
false
"
schunk
-
group
.
com
"
Ci
.
nsIX509CertDB
.
FLAG_LOCAL_ONLY
)
;
}
)
;
