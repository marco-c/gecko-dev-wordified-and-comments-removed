"
use
strict
"
;
do_get_profile
(
)
;
const
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
empty
input
"
)
;
let
pkcs7
=
new
Uint8Array
(
)
;
let
data
=
[
new
Uint8Array
(
0x10
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
)
;
equal
(
firstSignatureResult
.
signerCertificate
null
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
empty
input
"
)
;
let
pkcs7
=
new
Uint8Array
(
0x10
)
;
let
data
=
[
new
Uint8Array
(
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
)
;
equal
(
firstSignatureResult
.
signerCertificate
null
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
unsupported
signature
type
"
)
;
let
pkcs7
=
new
Uint8Array
(
0x10
)
;
let
data
=
[
new
Uint8Array
(
0x10
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_SHA1
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
)
;
equal
(
firstSignatureResult
.
signerCertificate
null
)
;
}
)
;
function
pkcs7FromFile
(
certName
)
{
let
certFile
=
do_get_file
(
test_pdf_verification
/
{
certName
}
.
p7s
false
)
;
let
certBytes
=
readFile
(
certFile
)
;
let
certBytesClean
=
certBytes
.
replace
(
"
-
-
-
-
-
BEGIN
PKCS7
-
-
-
-
-
"
"
"
)
.
replace
(
"
-
-
-
-
-
END
PKCS7
-
-
-
-
-
"
"
"
)
.
replace
(
/
\
n
/
g
"
"
)
;
const
binary
=
atob
(
certBytesClean
)
;
const
len
=
binary
.
length
;
const
bytes
=
new
Uint8Array
(
len
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
bytes
[
i
]
=
binary
.
charCodeAt
(
i
)
;
}
return
bytes
;
}
function
readBinFromFile
(
dataName
)
{
let
dataFile
=
do_get_file
(
test_pdf_verification
/
{
dataName
}
.
bin
false
)
;
let
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fstream
.
init
(
dataFile
-
1
0
0
)
;
let
available
=
fstream
.
available
(
)
;
let
data
=
available
>
0
?
NetUtil
.
readInputStream
(
fstream
available
)
:
"
"
;
fstream
.
close
(
)
;
return
new
Uint8Array
(
data
)
;
}
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
a
correct
signature
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
cert_correct
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
result
.
length
1
)
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_OK
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
ok
(
firstSignatureResult
.
signerCertificate
"
Signer
certificate
should
not
be
null
/
undefined
"
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
a
correct
signature
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
certificate_two_data_inputs
"
)
;
let
dataPortion
=
readBinFromFile
(
"
data_correct
"
)
;
let
data
=
[
dataPortion
dataPortion
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_OK
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
ok
(
firstSignatureResult
.
signerCertificate
"
Signer
certificate
should
not
be
null
/
undefined
"
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
a
incorrect
signature
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
cert_with_incorrect_signature
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
getXPCOMStatusFromNSS
(
SEC_ERROR_PKCS7_BAD_SIGNATURE
)
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
equal
(
firstSignatureResult
.
signerCertificate
null
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
a
md5
signature
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
md5_signer_info
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_SIGNED
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
equal
(
firstSignatureResult
.
signerCertificate
null
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
the
CMS
message
containing
two
different
SignerInfo
both
have
correct
signatures
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
two_correct_signatures
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
2
)
;
let
firstSignatureResult
=
result
[
0
]
;
let
secondSignatureResult
=
result
[
1
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_OK
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
ok
(
firstSignatureResult
.
signerCertificate
"
Signer
certificate
should
not
be
null
/
undefined
"
)
;
equal
(
secondSignatureResult
.
signatureResult
Cr
.
NS_OK
)
;
equal
(
secondSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
ok
(
secondSignatureResult
.
signerCertificate
"
Signer
certificate
should
not
be
null
/
undefined
"
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
the
CMS
message
containing
two
different
SignerInfo
only
one
has
a
correct
signature
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
one_correct_one_incorrect_hash
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
2
)
;
let
firstSignatureResult
=
result
[
0
]
;
let
secondSignatureResult
=
result
[
1
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_OK
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
ok
(
firstSignatureResult
.
signerCertificate
"
Signer
certificate
should
not
be
null
/
undefined
"
)
;
equal
(
secondSignatureResult
.
signatureResult
getXPCOMStatusFromNSS
(
SEC_ERROR_PKCS7_BAD_SIGNATURE
)
)
;
equal
(
secondSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
equal
(
secondSignatureResult
.
signerCertificate
null
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
the
CMS
message
containing
two
different
SignerInfo
only
one
has
a
correct
signature
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
one_correct_one_incorrect_signature
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
let
firstSignatureResult
=
result
[
0
]
;
let
secondSignatureResult
=
result
[
1
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_OK
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
ok
(
firstSignatureResult
.
signerCertificate
"
Signer
certificate
should
not
be
null
/
undefined
"
)
;
equal
(
secondSignatureResult
.
signatureResult
getXPCOMStatusFromNSS
(
SEC_ERROR_PKCS7_BAD_SIGNATURE
)
)
;
equal
(
secondSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
equal
(
secondSignatureResult
.
signerCertificate
null
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
no
SignerInfo
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
no_signer_info
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_ERROR_PROCESSING
)
;
equal
(
firstSignatureResult
.
signerCertificate
null
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
an
empty
certificate
list
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
no_certificate
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_ERROR_CMS_VERIFY_NOCERT
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
equal
(
firstSignatureResult
.
signerCertificate
null
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
the
Poppler
TV
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
poppler_signature
"
)
;
let
data
=
[
readBinFromFile
(
"
poppler_data
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_OK
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
ok
(
firstSignatureResult
.
signerCertificate
"
Signer
certificate
should
not
be
null
/
undefined
"
)
;
info
(
"
Certificate
Subject
Name
:
"
+
firstSignatureResult
.
signerCertificate
.
subjectName
)
;
Assert
.
equal
(
firstSignatureResult
.
signerCertificate
.
subjectName
"
CN
=
RSA2048
test
key
for
pdfsig
"
)
;
}
)
;
add_task
(
async
function
(
)
{
info
(
"
Running
PDF
verification
service
test
with
a
correct
signature
"
)
;
let
pkcs7
=
pkcs7FromFile
(
"
cert_correct
"
)
;
let
data
=
[
readBinFromFile
(
"
data_correct
"
)
]
;
let
signatureType
=
Ci
.
nsIX509CertDB
.
ADBE_PKCS7_DETACHED
;
let
result
=
await
certdb
.
asyncVerifyPKCS7Object
(
pkcs7
data
signatureType
)
;
equal
(
result
.
length
1
)
;
let
firstSignatureResult
=
result
[
0
]
;
equal
(
firstSignatureResult
.
signatureResult
Cr
.
NS_OK
)
;
equal
(
firstSignatureResult
.
certificateResult
Cr
.
NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED
)
;
ok
(
firstSignatureResult
.
signerCertificate
"
Signer
certificate
should
not
be
null
/
undefined
"
)
;
info
(
"
Certificate
Subject
Name
:
"
+
firstSignatureResult
.
signerCertificate
.
subjectName
)
;
Assert
.
equal
(
firstSignatureResult
.
signerCertificate
.
subjectName
"
CN
=
Test
"
)
;
info
(
"
Certificate
Issuer
Name
:
"
+
firstSignatureResult
.
signerCertificate
.
issuerName
)
;
Assert
.
equal
(
firstSignatureResult
.
signerCertificate
.
issuerName
"
CN
=
Test
"
)
;
}
)
;
