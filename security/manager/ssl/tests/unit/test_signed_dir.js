"
use
strict
"
;
const
{
ZipUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ZipUtils
.
jsm
"
{
}
)
;
do_get_profile
(
)
;
const
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
var
gSignedXPI
=
do_get_file
(
"
test_signed_dir
/
lightbeam_for_firefox
-
1
.
3
.
1
-
fx
.
xpi
"
false
)
;
var
gTarget
=
FileUtils
.
getDir
(
"
TmpD
"
[
"
test_signed_dir
"
]
)
;
gTarget
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
function
prepare
(
tamper
)
{
ZipUtils
.
extractFiles
(
gSignedXPI
gTarget
)
;
if
(
tamper
.
copy
)
{
tamper
.
copy
.
forEach
(
i
=
>
{
let
f
=
gTarget
.
clone
(
)
;
i
[
0
]
.
split
(
"
/
"
)
.
forEach
(
seg
=
>
{
f
.
append
(
seg
)
;
}
)
;
f
.
copyTo
(
null
i
[
1
]
)
;
}
)
;
}
if
(
tamper
.
delete
)
{
tamper
.
delete
.
forEach
(
i
=
>
{
let
f
=
gTarget
.
clone
(
)
;
i
.
split
(
"
/
"
)
.
forEach
(
seg
=
>
{
f
.
append
(
seg
)
;
}
)
;
f
.
remove
(
true
)
;
}
)
;
}
if
(
tamper
.
corrupt
)
{
tamper
.
corrupt
.
forEach
(
i
=
>
{
let
f
=
gTarget
.
clone
(
)
;
i
.
split
(
"
/
"
)
.
forEach
(
seg
=
>
{
f
.
append
(
seg
)
;
}
)
;
let
s
=
FileUtils
.
openFileOutputStream
(
f
FileUtils
.
MODE_WRONLY
)
;
const
str
=
"
Kilroy
was
here
"
;
s
.
write
(
str
str
.
length
)
;
s
.
close
(
)
;
}
)
;
}
return
gTarget
;
}
function
checkResult
(
expectedRv
dir
resolve
)
{
return
function
verifySignedDirCallback
(
rv
aSignerCert
)
{
equal
(
rv
expectedRv
"
Actual
and
expected
return
value
should
match
"
)
;
equal
(
aSignerCert
!
=
null
Components
.
isSuccessCode
(
expectedRv
)
"
expecting
certificate
:
"
)
;
dir
.
remove
(
true
)
;
resolve
(
)
;
}
;
}
function
verifyDirAsync
(
expectedRv
tamper
)
{
let
targetDir
=
prepare
(
tamper
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
certdb
.
verifySignedDirectoryAsync
(
Ci
.
nsIX509CertDB
.
AddonsPublicRoot
targetDir
checkResult
(
expectedRv
targetDir
resolve
)
)
;
}
)
;
}
add_task
(
async
function
testValid
(
)
{
await
verifyDirAsync
(
Cr
.
NS_OK
{
}
)
;
}
)
;
add_task
(
async
function
testNoMetaDir
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_NOT_SIGNED
{
delete
:
[
"
META
-
INF
"
]
}
)
;
}
)
;
add_task
(
async
function
testEmptyMetaDir
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_NOT_SIGNED
{
delete
:
[
"
META
-
INF
/
mozilla
.
rsa
"
"
META
-
INF
/
mozilla
.
sf
"
"
META
-
INF
/
manifest
.
mf
"
]
}
)
;
}
)
;
add_task
(
async
function
testTwoRSAFiles
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
{
copy
:
[
[
"
META
-
INF
/
mozilla
.
rsa
"
"
extra
.
rsa
"
]
]
}
)
;
}
)
;
add_task
(
async
function
testCorruptRSAFile
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
{
corrupt
:
[
"
META
-
INF
/
mozilla
.
rsa
"
]
}
)
;
}
)
;
add_task
(
async
function
testMissingSFFile
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
{
delete
:
[
"
META
-
INF
/
mozilla
.
sf
"
]
}
)
;
}
)
;
add_task
(
async
function
testCorruptSFFile
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
{
corrupt
:
[
"
META
-
INF
/
mozilla
.
sf
"
]
}
)
;
}
)
;
add_task
(
async
function
testExtraInvalidSFFile
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY
{
copy
:
[
[
"
META
-
INF
/
mozilla
.
rsa
"
"
extra
.
sf
"
]
]
}
)
;
}
)
;
add_task
(
async
function
testExtraValidSFFile
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY
{
copy
:
[
[
"
META
-
INF
/
mozilla
.
sf
"
"
extra
.
sf
"
]
]
}
)
;
}
)
;
add_task
(
async
function
testMissingManifest
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
{
delete
:
[
"
META
-
INF
/
manifest
.
mf
"
]
}
)
;
}
)
;
add_task
(
async
function
testCorruptManifest
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_MANIFEST_INVALID
{
corrupt
:
[
"
META
-
INF
/
manifest
.
mf
"
]
}
)
;
}
)
;
add_task
(
async
function
testMissingFile
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
{
delete
:
[
"
bootstrap
.
js
"
]
}
)
;
}
)
;
add_task
(
async
function
testCorruptFile
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY
{
corrupt
:
[
"
bootstrap
.
js
"
]
}
)
;
}
)
;
add_task
(
async
function
testExtraFile
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY
{
copy
:
[
[
"
bootstrap
.
js
"
"
extra
"
]
]
}
)
;
}
)
;
add_task
(
async
function
testMissingFileInDir
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_ENTRY_MISSING
{
delete
:
[
"
lib
/
ui
.
js
"
]
}
)
;
}
)
;
add_task
(
async
function
testCorruptFileInDir
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY
{
corrupt
:
[
"
lib
/
ui
.
js
"
]
}
)
;
}
)
;
add_task
(
async
function
testExtraFileInDir
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY
{
copy
:
[
[
"
lib
/
ui
.
js
"
"
extra
"
]
]
}
)
;
}
)
;
registerCleanupFunction
(
function
(
)
{
if
(
gTarget
.
exists
(
)
)
{
gTarget
.
remove
(
true
)
;
}
}
)
;
