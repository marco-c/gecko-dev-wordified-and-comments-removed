"
use
strict
"
;
const
{
ZipUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ZipUtils
.
jsm
"
{
}
)
;
do_get_profile
(
)
;
const
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
var
gSignedXPI
=
do_get_file
(
"
test_signed_dir
/
lightbeam_for_firefox
-
1
.
3
.
1
-
fx
.
xpi
"
false
)
;
var
gTarget
=
FileUtils
.
getDir
(
"
TmpD
"
[
"
test_signed_dir
"
]
)
;
gTarget
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
function
prepare
(
)
{
ZipUtils
.
extractFiles
(
gSignedXPI
gTarget
)
;
return
gTarget
;
}
function
checkResult
(
expectedRv
dir
resolve
)
{
return
function
verifySignedDirCallback
(
rv
aSignerCert
)
{
equal
(
rv
expectedRv
"
Actual
and
expected
return
value
should
match
"
)
;
equal
(
aSignerCert
!
=
null
Components
.
isSuccessCode
(
expectedRv
)
"
expecting
certificate
:
"
)
;
dir
.
remove
(
true
)
;
resolve
(
)
;
}
;
}
function
verifyDirAsync
(
expectedRv
)
{
let
targetDir
=
prepare
(
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
certdb
.
verifySignedDirectoryAsync
(
Ci
.
nsIX509CertDB
.
AddonsPublicRoot
targetDir
checkResult
(
expectedRv
targetDir
resolve
)
)
;
}
)
;
}
add_task
(
async
function
testAPIFails
(
)
{
await
verifyDirAsync
(
Cr
.
NS_ERROR_SIGNED_JAR_NOT_SIGNED
)
;
}
)
;
registerCleanupFunction
(
function
(
)
{
if
(
gTarget
.
exists
(
)
)
{
gTarget
.
remove
(
true
)
;
}
}
)
;
