#
include
"
TLSServer
.
h
"
#
include
<
stdio
.
h
>
#
include
<
string
>
#
include
<
thread
>
#
include
<
vector
>
#
include
<
fstream
>
#
include
<
iostream
>
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
base64
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nspr
.
h
"
#
include
"
nss
.
h
"
#
include
"
plarenas
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prerror
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
prtime
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslproto
.
h
"
namespace
mozilla
{
namespace
test
{
static
const
uint16_t
LISTEN_PORT
=
8443
;
DebugLevel
gDebugLevel
=
DEBUG_ERRORS
;
uint16_t
gCallbackPort
=
0
;
const
std
:
:
string
kPEMBegin
=
"
-
-
-
-
-
BEGIN
"
;
const
std
:
:
string
kPEMEnd
=
"
-
-
-
-
-
END
"
;
const
char
DEFAULT_CERT_NICKNAME
[
]
=
"
default
-
ee
"
;
struct
Connection
{
PRFileDesc
*
mSocket
;
char
mByte
;
explicit
Connection
(
PRFileDesc
*
aSocket
)
;
~
Connection
(
)
;
}
;
Connection
:
:
Connection
(
PRFileDesc
*
aSocket
)
:
mSocket
(
aSocket
)
mByte
(
0
)
{
}
Connection
:
:
~
Connection
(
)
{
if
(
mSocket
)
{
PR_Close
(
mSocket
)
;
}
}
void
PrintPRError
(
const
char
*
aPrefix
)
{
const
char
*
err
=
PR_ErrorToName
(
PR_GetError
(
)
)
;
if
(
err
)
{
if
(
gDebugLevel
>
=
DEBUG_ERRORS
)
{
fprintf
(
stderr
"
%
s
:
%
s
\
n
"
aPrefix
err
)
;
}
}
else
{
if
(
gDebugLevel
>
=
DEBUG_ERRORS
)
{
fprintf
(
stderr
"
%
s
\
n
"
aPrefix
)
;
}
}
}
static
bool
DecodePEMFile
(
const
std
:
:
string
&
filename
SECItem
*
item
)
{
std
:
:
ifstream
in
(
filename
)
;
if
(
in
.
bad
(
)
)
{
return
false
;
}
char
buf
[
1024
]
;
in
.
getline
(
buf
sizeof
(
buf
)
)
;
if
(
in
.
bad
(
)
)
{
return
false
;
}
if
(
strncmp
(
buf
kPEMBegin
.
c_str
(
)
kPEMBegin
.
size
(
)
)
!
=
0
)
{
return
false
;
}
std
:
:
string
value
;
for
(
;
;
)
{
in
.
getline
(
buf
sizeof
(
buf
)
)
;
if
(
in
.
bad
(
)
)
{
return
false
;
}
if
(
strncmp
(
buf
kPEMEnd
.
c_str
(
)
kPEMEnd
.
size
(
)
)
=
=
0
)
{
break
;
}
value
+
=
buf
;
}
unsigned
int
binLength
;
UniquePORTString
bin
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
ATOB_AsciiToData
(
value
.
c_str
(
)
&
binLength
)
)
)
;
if
(
!
bin
|
|
binLength
=
=
0
)
{
PrintPRError
(
"
ATOB_AsciiToData
failed
"
)
;
return
false
;
}
if
(
SECITEM_AllocItem
(
nullptr
item
binLength
)
=
=
nullptr
)
{
return
false
;
}
PORT_Memcpy
(
item
-
>
data
bin
.
get
(
)
binLength
)
;
return
true
;
}
static
SECStatus
AddKeyFromFile
(
const
std
:
:
string
&
path
const
std
:
:
string
&
filename
)
{
ScopedAutoSECItem
item
;
std
:
:
string
file
=
path
+
"
/
"
+
filename
;
if
(
!
DecodePEMFile
(
file
&
item
)
)
{
return
SECFailure
;
}
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
PrintPRError
(
"
PK11_GetInternalKeySlot
failed
"
)
;
return
SECFailure
;
}
if
(
PK11_NeedUserInit
(
slot
.
get
(
)
)
)
{
if
(
PK11_InitPin
(
slot
.
get
(
)
nullptr
nullptr
)
!
=
SECSuccess
)
{
PrintPRError
(
"
PK11_InitPin
failed
"
)
;
return
SECFailure
;
}
}
SECKEYPrivateKey
*
privateKey
=
nullptr
;
if
(
PK11_ImportDERPrivateKeyInfoAndReturnKey
(
slot
.
get
(
)
&
item
nullptr
nullptr
true
false
KU_ALL
&
privateKey
nullptr
)
!
=
SECSuccess
)
{
PrintPRError
(
"
PK11_ImportDERPrivateKeyInfoAndReturnKey
failed
"
)
;
return
SECFailure
;
}
SECKEY_DestroyPrivateKey
(
privateKey
)
;
return
SECSuccess
;
}
static
SECStatus
AddCertificateFromFile
(
const
std
:
:
string
&
path
const
std
:
:
string
&
filename
)
{
ScopedAutoSECItem
item
;
std
:
:
string
file
=
path
+
"
/
"
+
filename
;
if
(
!
DecodePEMFile
(
file
&
item
)
)
{
return
SECFailure
;
}
UniqueCERTCertificate
cert
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
item
nullptr
false
true
)
)
;
if
(
!
cert
)
{
PrintPRError
(
"
CERT_NewTempCertificate
failed
"
)
;
return
SECFailure
;
}
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
PrintPRError
(
"
PK11_GetInternalKeySlot
failed
"
)
;
return
SECFailure
;
}
std
:
:
string
nickname
=
filename
.
substr
(
0
filename
.
length
(
)
-
4
)
;
SECStatus
rv
=
PK11_ImportCert
(
slot
.
get
(
)
cert
.
get
(
)
CK_INVALID_HANDLE
nickname
.
c_str
(
)
false
)
;
if
(
rv
!
=
SECSuccess
)
{
PrintPRError
(
"
PK11_ImportCert
failed
"
)
;
return
rv
;
}
return
SECSuccess
;
}
SECStatus
LoadCertificatesAndKeys
(
const
char
*
basePath
)
{
if
(
strncmp
(
basePath
"
sql
:
"
4
)
=
=
0
)
{
basePath
=
basePath
+
4
;
}
UniquePRDir
fdDir
(
PR_OpenDir
(
basePath
)
)
;
if
(
!
fdDir
)
{
PrintPRError
(
"
PR_OpenDir
failed
"
)
;
return
SECFailure
;
}
std
:
:
vector
<
std
:
:
string
>
certificates
;
std
:
:
vector
<
std
:
:
string
>
keys
;
for
(
PRDirEntry
*
dirEntry
=
PR_ReadDir
(
fdDir
.
get
(
)
PR_SKIP_BOTH
)
;
dirEntry
;
dirEntry
=
PR_ReadDir
(
fdDir
.
get
(
)
PR_SKIP_BOTH
)
)
{
size_t
nameLength
=
strlen
(
dirEntry
-
>
name
)
;
if
(
nameLength
>
4
)
{
if
(
strncmp
(
dirEntry
-
>
name
+
nameLength
-
4
"
.
pem
"
4
)
=
=
0
)
{
certificates
.
push_back
(
dirEntry
-
>
name
)
;
}
else
if
(
strncmp
(
dirEntry
-
>
name
+
nameLength
-
4
"
.
key
"
4
)
=
=
0
)
{
keys
.
push_back
(
dirEntry
-
>
name
)
;
}
}
}
SECStatus
rv
;
for
(
std
:
:
string
&
certificate
:
certificates
)
{
rv
=
AddCertificateFromFile
(
basePath
certificate
.
c_str
(
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
}
for
(
std
:
:
string
&
key
:
keys
)
{
rv
=
AddKeyFromFile
(
basePath
key
.
c_str
(
)
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
}
return
SECSuccess
;
}
SECStatus
InitializeNSS
(
const
char
*
nssCertDBDir
)
{
if
(
NSS_Init
(
nssCertDBDir
)
=
=
SECSuccess
)
{
return
SECSuccess
;
}
SECStatus
rv
=
NSS_Initialize
(
nssCertDBDir
nullptr
nullptr
nullptr
0
)
;
if
(
rv
!
=
SECSuccess
)
{
return
rv
;
}
return
LoadCertificatesAndKeys
(
nssCertDBDir
)
;
}
nsresult
SendAll
(
PRFileDesc
*
aSocket
const
char
*
aData
size_t
aDataLen
)
{
if
(
gDebugLevel
>
=
DEBUG_VERBOSE
)
{
fprintf
(
stderr
"
sending
'
%
s
'
\
n
"
aData
)
;
}
while
(
aDataLen
>
0
)
{
int32_t
bytesSent
=
PR_Send
(
aSocket
aData
aDataLen
0
PR_INTERVAL_NO_TIMEOUT
)
;
if
(
bytesSent
=
=
-
1
)
{
PrintPRError
(
"
PR_Send
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
aDataLen
-
=
bytesSent
;
aData
+
=
bytesSent
;
}
return
NS_OK
;
}
nsresult
ReplyToRequest
(
Connection
*
aConn
)
{
char
buf
[
2
]
=
{
aConn
-
>
mByte
0
}
;
return
SendAll
(
aConn
-
>
mSocket
buf
1
)
;
}
nsresult
SetupTLS
(
Connection
*
aConn
PRFileDesc
*
aModelSocket
)
{
PRFileDesc
*
sslSocket
=
SSL_ImportFD
(
aModelSocket
aConn
-
>
mSocket
)
;
if
(
!
sslSocket
)
{
PrintPRError
(
"
SSL_ImportFD
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
aConn
-
>
mSocket
=
sslSocket
;
SSL_OptionSet
(
sslSocket
SSL_SECURITY
true
)
;
SSL_OptionSet
(
sslSocket
SSL_HANDSHAKE_AS_CLIENT
false
)
;
SSL_OptionSet
(
sslSocket
SSL_HANDSHAKE_AS_SERVER
true
)
;
SSL_ResetHandshake
(
sslSocket
1
)
;
return
NS_OK
;
}
nsresult
ReadRequest
(
Connection
*
aConn
)
{
int32_t
bytesRead
=
PR_Recv
(
aConn
-
>
mSocket
&
aConn
-
>
mByte
1
0
PR_INTERVAL_NO_TIMEOUT
)
;
if
(
bytesRead
<
0
)
{
PrintPRError
(
"
PR_Recv
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
else
if
(
bytesRead
=
=
0
)
{
PR_SetError
(
PR_IO_ERROR
0
)
;
PrintPRError
(
"
PR_Recv
EOF
in
ReadRequest
"
)
;
return
NS_ERROR_FAILURE
;
}
else
{
if
(
gDebugLevel
>
=
DEBUG_VERBOSE
)
{
fprintf
(
stderr
"
read
'
0x
%
hhx
'
\
n
"
aConn
-
>
mByte
)
;
}
}
return
NS_OK
;
}
void
HandleConnection
(
PRFileDesc
*
aSocket
const
UniquePRFileDesc
&
aModelSocket
)
{
Connection
conn
(
aSocket
)
;
nsresult
rv
=
SetupTLS
(
&
conn
aModelSocket
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
PrintPRError
(
"
PR_Recv
failed
"
)
;
exit
(
1
)
;
}
rv
=
ReadRequest
(
&
conn
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
ReplyToRequest
(
&
conn
)
;
}
}
int
DoCallback
(
)
{
UniquePRFileDesc
socket
(
PR_NewTCPSocket
(
)
)
;
if
(
!
socket
)
{
PrintPRError
(
"
PR_NewTCPSocket
failed
"
)
;
return
1
;
}
PRNetAddr
addr
;
PR_InitializeNetAddr
(
PR_IpAddrLoopback
gCallbackPort
&
addr
)
;
if
(
PR_Connect
(
socket
.
get
(
)
&
addr
PR_INTERVAL_NO_TIMEOUT
)
!
=
PR_SUCCESS
)
{
PrintPRError
(
"
PR_Connect
failed
"
)
;
return
1
;
}
const
char
*
request
=
"
GET
/
HTTP
/
1
.
0
\
r
\
n
\
r
\
n
"
;
SendAll
(
socket
.
get
(
)
request
strlen
(
request
)
)
;
char
buf
[
4096
]
;
memset
(
buf
0
sizeof
(
buf
)
)
;
int32_t
bytesRead
=
PR_Recv
(
socket
.
get
(
)
buf
sizeof
(
buf
)
-
1
0
PR_INTERVAL_NO_TIMEOUT
)
;
if
(
bytesRead
<
0
)
{
PrintPRError
(
"
PR_Recv
failed
1
"
)
;
return
1
;
}
if
(
bytesRead
=
=
0
)
{
fprintf
(
stderr
"
PR_Recv
eof
1
\
n
"
)
;
return
1
;
}
fprintf
(
stderr
"
%
s
\
n
"
buf
)
;
return
0
;
}
SECStatus
ConfigSecureServerWithNamedCert
(
PRFileDesc
*
fd
const
char
*
certName
UniqueCERTCertificate
*
certOut
SSLKEAType
*
keaOut
SSLExtraServerCertData
*
extraData
)
{
UniqueCERTCertificate
cert
(
PK11_FindCertFromNickname
(
certName
nullptr
)
)
;
if
(
!
cert
)
{
PrintPRError
(
"
PK11_FindCertFromNickname
failed
"
)
;
return
SECFailure
;
}
UniqueCERTCertificateList
certList
;
UniqueCERTCertificate
issuerCert
(
CERT_FindCertByName
(
CERT_GetDefaultCertDB
(
)
&
cert
-
>
derIssuer
)
)
;
if
(
issuerCert
)
{
UniquePLArenaPool
arena
(
PORT_NewArena
(
DER_DEFAULT_CHUNKSIZE
)
)
;
if
(
!
arena
)
{
PrintPRError
(
"
PORT_NewArena
failed
"
)
;
return
SECFailure
;
}
certList
.
reset
(
static_cast
<
CERTCertificateList
*
>
(
PORT_ArenaAlloc
(
arena
.
get
(
)
sizeof
(
CERTCertificateList
)
)
)
)
;
if
(
!
certList
)
{
PrintPRError
(
"
PORT_ArenaAlloc
failed
"
)
;
return
SECFailure
;
}
certList
-
>
arena
=
arena
.
release
(
)
;
certList
-
>
certs
=
static_cast
<
SECItem
*
>
(
PORT_ArenaAlloc
(
certList
-
>
arena
2
*
sizeof
(
SECItem
)
)
)
;
if
(
SECITEM_CopyItem
(
certList
-
>
arena
certList
-
>
certs
&
cert
-
>
derCert
)
!
=
SECSuccess
)
{
PrintPRError
(
"
SECITEM_CopyItem
failed
"
)
;
return
SECFailure
;
}
if
(
SECITEM_CopyItem
(
certList
-
>
arena
certList
-
>
certs
+
1
&
issuerCert
-
>
derCert
)
!
=
SECSuccess
)
{
PrintPRError
(
"
SECITEM_CopyItem
failed
"
)
;
return
SECFailure
;
}
certList
-
>
len
=
2
;
}
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
PrintPRError
(
"
PK11_GetInternalKeySlot
failed
"
)
;
return
SECFailure
;
}
UniqueSECKEYPrivateKey
key
(
PK11_FindKeyByDERCert
(
slot
.
get
(
)
cert
.
get
(
)
nullptr
)
)
;
if
(
!
key
)
{
PrintPRError
(
"
PK11_FindKeyByDERCert
failed
"
)
;
return
SECFailure
;
}
if
(
extraData
)
{
SSLExtraServerCertData
dataCopy
=
{
ssl_auth_null
nullptr
nullptr
nullptr
nullptr
nullptr
}
;
memcpy
(
&
dataCopy
extraData
sizeof
(
dataCopy
)
)
;
dataCopy
.
certChain
=
certList
.
get
(
)
;
if
(
SSL_ConfigServerCert
(
fd
cert
.
get
(
)
key
.
get
(
)
&
dataCopy
sizeof
(
dataCopy
)
)
!
=
SECSuccess
)
{
PrintPRError
(
"
SSL_ConfigServerCert
failed
"
)
;
return
SECFailure
;
}
}
else
{
SSLKEAType
certKEA
=
NSS_FindCertKEAType
(
cert
.
get
(
)
)
;
if
(
SSL_ConfigSecureServerWithCertChain
(
fd
cert
.
get
(
)
certList
.
get
(
)
key
.
get
(
)
certKEA
)
!
=
SECSuccess
)
{
PrintPRError
(
"
SSL_ConfigSecureServer
failed
"
)
;
return
SECFailure
;
}
if
(
keaOut
)
{
*
keaOut
=
certKEA
;
}
}
if
(
certOut
)
{
*
certOut
=
std
:
:
move
(
cert
)
;
}
SSL_OptionSet
(
fd
SSL_NO_CACHE
false
)
;
SSL_OptionSet
(
fd
SSL_ENABLE_SESSION_TICKETS
true
)
;
return
SECSuccess
;
}
#
ifdef
XP_WIN
using
PidType
=
DWORD
;
constexpr
bool
IsValidPid
(
long
long
pid
)
{
return
pid
>
0
&
&
pid
<
std
:
:
numeric_limits
<
PidType
>
:
:
max
(
)
;
}
#
else
using
PidType
=
pid_t
;
constexpr
bool
IsValidPid
(
long
long
pid
)
{
return
pid
>
0
&
&
pid
<
=
std
:
:
numeric_limits
<
PidType
>
:
:
max
(
)
;
}
#
endif
PidType
ConvertPid
(
const
char
*
pidStr
)
{
long
long
pid
=
strtoll
(
pidStr
nullptr
10
)
;
if
(
!
IsValidPid
(
pid
)
)
{
return
0
;
}
return
static_cast
<
PidType
>
(
pid
)
;
}
int
StartServer
(
int
argc
char
*
argv
[
]
SSLSNISocketConfig
sniSocketConfig
void
*
sniSocketConfigArg
)
{
if
(
argc
!
=
3
)
{
fprintf
(
stderr
"
usage
:
%
s
<
NSS
DB
directory
>
<
ppid
>
\
n
"
argv
[
0
]
)
;
return
1
;
}
const
char
*
nssCertDBDir
=
argv
[
1
]
;
PidType
ppid
=
ConvertPid
(
argv
[
2
]
)
;
const
char
*
debugLevel
=
PR_GetEnv
(
"
MOZ_TLS_SERVER_DEBUG_LEVEL
"
)
;
if
(
debugLevel
)
{
int
level
=
atoi
(
debugLevel
)
;
switch
(
level
)
{
case
DEBUG_ERRORS
:
gDebugLevel
=
DEBUG_ERRORS
;
break
;
case
DEBUG_WARNINGS
:
gDebugLevel
=
DEBUG_WARNINGS
;
break
;
case
DEBUG_VERBOSE
:
gDebugLevel
=
DEBUG_VERBOSE
;
break
;
default
:
PrintPRError
(
"
invalid
MOZ_TLS_SERVER_DEBUG_LEVEL
"
)
;
return
1
;
}
}
const
char
*
callbackPort
=
PR_GetEnv
(
"
MOZ_TLS_SERVER_CALLBACK_PORT
"
)
;
if
(
callbackPort
)
{
gCallbackPort
=
atoi
(
callbackPort
)
;
}
if
(
InitializeNSS
(
nssCertDBDir
)
!
=
SECSuccess
)
{
PR_fprintf
(
PR_STDERR
"
InitializeNSS
failed
"
)
;
return
1
;
}
if
(
NSS_SetDomesticPolicy
(
)
!
=
SECSuccess
)
{
PrintPRError
(
"
NSS_SetDomesticPolicy
failed
"
)
;
return
1
;
}
if
(
SSL_ConfigServerSessionIDCache
(
0
0
0
nullptr
)
!
=
SECSuccess
)
{
PrintPRError
(
"
SSL_ConfigServerSessionIDCache
failed
"
)
;
return
1
;
}
UniquePRFileDesc
serverSocket
(
PR_NewTCPSocket
(
)
)
;
if
(
!
serverSocket
)
{
PrintPRError
(
"
PR_NewTCPSocket
failed
"
)
;
return
1
;
}
PRSocketOptionData
socketOption
;
socketOption
.
option
=
PR_SockOpt_Reuseaddr
;
socketOption
.
value
.
reuse_addr
=
true
;
PR_SetSocketOption
(
serverSocket
.
get
(
)
&
socketOption
)
;
PRNetAddr
serverAddr
;
PR_InitializeNetAddr
(
PR_IpAddrLoopback
LISTEN_PORT
&
serverAddr
)
;
if
(
PR_Bind
(
serverSocket
.
get
(
)
&
serverAddr
)
!
=
PR_SUCCESS
)
{
PrintPRError
(
"
PR_Bind
failed
"
)
;
return
1
;
}
if
(
PR_Listen
(
serverSocket
.
get
(
)
1
)
!
=
PR_SUCCESS
)
{
PrintPRError
(
"
PR_Listen
failed
"
)
;
return
1
;
}
UniquePRFileDesc
rawModelSocket
(
PR_NewTCPSocket
(
)
)
;
if
(
!
rawModelSocket
)
{
PrintPRError
(
"
PR_NewTCPSocket
failed
for
rawModelSocket
"
)
;
return
1
;
}
UniquePRFileDesc
modelSocket
(
SSL_ImportFD
(
nullptr
rawModelSocket
.
release
(
)
)
)
;
if
(
!
modelSocket
)
{
PrintPRError
(
"
SSL_ImportFD
of
rawModelSocket
failed
"
)
;
return
1
;
}
SSLVersionRange
range
=
{
0
0
}
;
if
(
SSL_VersionRangeGet
(
modelSocket
.
get
(
)
&
range
)
!
=
SECSuccess
)
{
PrintPRError
(
"
SSL_VersionRangeGet
failed
"
)
;
return
1
;
}
if
(
range
.
max
<
SSL_LIBRARY_VERSION_TLS_1_3
)
{
range
.
max
=
SSL_LIBRARY_VERSION_TLS_1_3
;
if
(
SSL_VersionRangeSet
(
modelSocket
.
get
(
)
&
range
)
!
=
SECSuccess
)
{
PrintPRError
(
"
SSL_VersionRangeSet
failed
"
)
;
return
1
;
}
}
if
(
SSL_SNISocketConfigHook
(
modelSocket
.
get
(
)
sniSocketConfig
sniSocketConfigArg
)
!
=
SECSuccess
)
{
PrintPRError
(
"
SSL_SNISocketConfigHook
failed
"
)
;
return
1
;
}
SSLExtraServerCertData
extra_data
=
{
ssl_auth_null
nullptr
nullptr
nullptr
nullptr
nullptr
}
;
if
(
ConfigSecureServerWithNamedCert
(
modelSocket
.
get
(
)
DEFAULT_CERT_NICKNAME
nullptr
nullptr
&
extra_data
)
!
=
SECSuccess
)
{
return
1
;
}
if
(
gCallbackPort
!
=
0
)
{
if
(
DoCallback
(
)
)
{
return
1
;
}
}
std
:
:
thread
(
[
ppid
]
{
if
(
!
ppid
)
{
if
(
gDebugLevel
>
=
DEBUG_ERRORS
)
{
fprintf
(
stderr
"
invalid
ppid
\
n
"
)
;
}
return
;
}
#
ifdef
XP_WIN
HANDLE
parent
=
OpenProcess
(
SYNCHRONIZE
false
ppid
)
;
if
(
!
parent
)
{
if
(
gDebugLevel
>
=
DEBUG_ERRORS
)
{
fprintf
(
stderr
"
OpenProcess
failed
\
n
"
)
;
}
return
;
}
WaitForSingleObject
(
parent
INFINITE
)
;
CloseHandle
(
parent
)
;
#
else
while
(
getppid
(
)
=
=
ppid
)
{
sleep
(
1
)
;
}
#
endif
if
(
gDebugLevel
>
=
DEBUG_ERRORS
)
{
fprintf
(
stderr
"
Parent
process
crashed
\
n
"
)
;
}
exit
(
1
)
;
}
)
.
detach
(
)
;
while
(
true
)
{
PRNetAddr
clientAddr
;
PRFileDesc
*
clientSocket
=
PR_Accept
(
serverSocket
.
get
(
)
&
clientAddr
PR_INTERVAL_NO_TIMEOUT
)
;
HandleConnection
(
clientSocket
modelSocket
)
;
}
return
0
;
}
}
}
