"
use
strict
"
;
const
{
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
{
}
)
;
const
BlocklistClients
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
blocklist
-
clients
.
js
"
{
}
)
;
var
id
=
"
xpcshell
tests
.
mozilla
.
org
"
;
var
appName
=
"
XPCShell
"
;
var
version
=
"
1
"
;
var
platformVersion
=
"
1
.
9
.
2
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
this
)
;
updateAppInfo
(
{
name
:
appName
ID
:
id
version
platformVersion
:
platformVersion
?
platformVersion
:
"
1
.
0
"
crashReporter
:
true
}
)
;
var
gProfile
=
do_get_profile
(
)
;
var
gRevocations
=
gProfile
.
clone
(
)
;
gRevocations
.
append
(
"
revocations
.
txt
"
)
;
if
(
!
gRevocations
.
exists
(
)
)
{
let
existing
=
do_get_file
(
"
test_onecrl
/
sample_revocations
.
txt
"
false
)
;
existing
.
copyTo
(
gProfile
"
revocations
.
txt
"
)
;
}
var
certDB
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
var
testserver
=
new
HttpServer
(
)
;
const
kintoHelloViewJSON
=
{
"
settings
"
:
{
"
batch_max_requests
"
:
25
}
}
;
const
kintoChangesJSON
=
{
"
data
"
:
[
{
"
host
"
:
"
firefox
.
settings
.
services
.
mozilla
.
com
"
"
id
"
:
"
3ace9d8e
-
00b5
-
a353
-
7fd5
-
1f081ff482ba
"
"
last_modified
"
:
100000000000000000001
"
bucket
"
:
"
blocklists
"
"
collection
"
:
"
certificates
"
}
]
}
;
const
certMetadataJSON
=
{
"
data
"
:
{
}
}
;
const
certBlocklistJSON
=
{
"
data
"
:
[
+
{
"
id
"
:
"
1
"
"
last_modified
"
:
100000000000000000001
"
issuerName
"
:
"
Some
nonsense
in
issuer
"
"
serialNumber
"
:
"
AkHVNA
=
=
"
}
{
"
id
"
:
"
2
"
"
last_modified
"
:
100000000000000000002
"
issuerName
"
:
"
MA0xCzAJBgNVBAMMAmNh
"
"
serialNumber
"
:
"
some
nonsense
in
serial
"
}
{
"
id
"
:
"
3
"
"
last_modified
"
:
100000000000000000003
"
issuerName
"
:
"
and
serial
"
"
serialNumber
"
:
"
some
nonsense
in
both
issuer
"
}
+
{
"
id
"
:
"
4
"
"
last_modified
"
:
100000000000000000004
"
issuerName
"
:
"
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
"
"
serialNumber
"
:
"
oops
!
more
nonsense
.
"
}
+
{
"
id
"
:
"
5
"
"
last_modified
"
:
100000000000000000004
"
issuerName
"
:
"
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
"
"
serialNumber
"
:
"
a0X7
/
7DlTaedpgrIJg25iBPOkIM
=
"
}
+
{
"
id
"
:
"
6
"
"
last_modified
"
:
100000000000000000005
"
issuerName
"
:
"
MBgxFjAUBgNVBAMMDU90aGVyIHRlc3QgQ0E
=
"
"
serialNumber
"
:
"
Rym6o
+
VN9xgZXT
/
QLrvN
/
nv1ZN4
=
"
}
+
{
"
id
"
:
"
7
"
"
last_modified
"
:
100000000000000000006
"
issuerName
"
:
"
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
"
"
serialNumber
"
:
"
c2VyaWFsMi4
=
"
}
+
{
"
id
"
:
"
8
"
"
last_modified
"
:
100000000000000000006
"
issuerName
"
:
"
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
"
"
serialNumber
"
:
"
YW5vdGhlciBzZXJpYWwu
"
}
+
{
"
id
"
:
"
9
"
"
last_modified
"
:
100000000000000000007
"
subject
"
:
"
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
"
"
pubKeyHash
"
:
"
VCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
"
}
]
}
;
function
serveResponse
(
body
)
{
return
(
req
response
)
=
>
{
response
.
setStatusLine
(
null
200
"
OK
"
)
;
response
.
write
(
body
)
;
}
;
}
testserver
.
registerPathHandler
(
"
/
v1
/
"
serveResponse
(
kintoHelloViewJSON
)
)
;
testserver
.
registerPathHandler
(
"
/
v1
/
buckets
/
monitor
/
collections
/
changes
/
records
"
serveResponse
(
kintoChangesJSON
)
)
;
testserver
.
registerPathHandler
(
"
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
"
serveResponse
(
certMetadataJSON
)
)
;
testserver
.
registerPathHandler
(
"
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
"
serveResponse
(
certBlocklistJSON
)
)
;
testserver
.
start
(
-
1
)
;
var
port
=
testserver
.
identity
.
primaryPort
;
var
addonManager
=
Cc
[
"
mozilla
.
org
/
addons
/
integration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
QueryInterface
(
Ci
.
nsITimerCallback
)
;
addonManager
.
observe
(
null
"
addons
-
startup
"
null
)
;
var
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
function
verify_cert
(
file
expectedError
)
{
let
ee
=
constructCertFromFile
(
file
)
;
return
checkCertErrorGeneric
(
certDB
ee
expectedError
certificateUsageSSLServer
)
;
}
async
function
verify_non_tls_usage_succeeds
(
file
)
{
let
ee
=
constructCertFromFile
(
file
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageSSLClient
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageEmailSigner
)
;
await
checkCertErrorGeneric
(
certDB
ee
PRErrorCodeSuccess
certificateUsageEmailRecipient
)
;
}
function
load_cert
(
cert
trust
)
{
let
file
=
"
bad_certs
/
"
+
cert
+
"
.
pem
"
;
addCertFromFile
(
certDB
file
trust
)
;
}
function
test_is_revoked
(
certList
issuerString
serialString
subjectString
pubKeyString
)
{
let
issuer
=
converter
.
convertToByteArray
(
issuerString
|
|
"
"
{
}
)
;
let
serial
=
converter
.
convertToByteArray
(
serialString
|
|
"
"
{
}
)
;
let
subject
=
converter
.
convertToByteArray
(
subjectString
|
|
"
"
{
}
)
;
let
pubKey
=
converter
.
convertToByteArray
(
pubKeyString
|
|
"
"
{
}
)
;
return
certList
.
isCertRevoked
(
issuer
issuerString
?
issuerString
.
length
:
0
serial
serialString
?
serialString
.
length
:
0
subject
subjectString
?
subjectString
.
length
:
0
pubKey
pubKeyString
?
pubKeyString
.
length
:
0
)
;
}
function
fetch_blocklist
(
)
{
Services
.
prefs
.
setBoolPref
(
"
services
.
settings
.
load_dump
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
services
.
settings
.
verify_signature
"
false
)
;
Services
.
prefs
.
setCharPref
(
"
services
.
settings
.
server
"
http
:
/
/
localhost
:
{
port
}
/
v1
)
;
BlocklistClients
.
initialize
(
)
;
return
RemoteSettings
.
pollChanges
(
)
;
}
function
*
generate_revocations_txt_lines
(
)
{
let
profile
=
do_get_profile
(
)
;
let
revocations
=
profile
.
clone
(
)
;
revocations
.
append
(
"
revocations
.
txt
"
)
;
ok
(
revocations
.
exists
(
)
"
the
revocations
file
should
exist
"
)
;
let
inputStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
inputStream
.
init
(
revocations
-
1
-
1
0
)
;
inputStream
.
QueryInterface
(
Ci
.
nsILineInputStream
)
;
let
hasmore
=
false
;
do
{
let
line
=
{
}
;
hasmore
=
inputStream
.
readLine
(
line
)
;
yield
line
.
value
;
}
while
(
hasmore
)
;
}
function
check_revocations_txt_contents
(
expected
)
{
let
lineGenerator
=
generate_revocations_txt_lines
(
)
;
let
firstLine
=
lineGenerator
.
next
(
)
;
equal
(
firstLine
.
done
false
"
first
line
of
revocations
.
txt
should
be
present
"
)
;
equal
(
firstLine
.
value
"
#
Auto
generated
contents
.
Do
not
edit
.
"
"
first
line
of
revocations
.
txt
"
)
;
let
line
=
lineGenerator
.
next
(
)
;
let
topLevelFound
=
{
}
;
while
(
true
)
{
if
(
line
.
done
)
{
break
;
}
ok
(
line
.
value
in
expected
{
line
.
value
}
should
be
an
expected
top
-
level
line
in
revocations
.
txt
)
;
ok
(
!
(
line
.
value
in
topLevelFound
)
should
not
have
seen
{
line
.
value
}
before
in
revocations
.
txt
)
;
topLevelFound
[
line
.
value
]
=
true
;
let
topLevelLine
=
line
.
value
;
let
sublines
=
expected
[
line
.
value
]
;
let
subFound
=
{
}
;
while
(
true
)
{
line
=
lineGenerator
.
next
(
)
;
if
(
line
.
done
|
|
!
(
line
.
value
in
sublines
)
)
{
break
;
}
ok
(
!
(
line
.
value
in
subFound
)
should
not
have
seen
{
line
.
value
}
before
in
revocations
.
txt
)
;
subFound
[
line
.
value
]
=
true
;
}
for
(
let
subline
in
sublines
)
{
ok
(
subFound
[
subline
]
should
have
found
{
subline
}
below
{
topLevelLine
}
in
revocations
.
txt
)
;
}
}
for
(
let
topLevelLine
in
expected
)
{
ok
(
topLevelFound
[
topLevelLine
]
should
have
found
{
topLevelLine
}
in
revocations
.
txt
)
;
}
}
function
run_test
(
)
{
load_cert
(
"
test
-
ca
"
"
CTu
CTu
CTu
"
)
;
load_cert
(
"
test
-
int
"
"
"
)
;
load_cert
(
"
other
-
test
-
ca
"
"
CTu
CTu
CTu
"
)
;
let
certList
=
Cc
[
"
mozilla
.
org
/
security
/
certblocklist
;
1
"
]
.
getService
(
Ci
.
nsICertBlocklist
)
;
let
expected
=
{
"
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
"
:
{
"
\
tVCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
"
:
true
}
"
MBgxFjAUBgNVBAMMDU90aGVyIHRlc3QgQ0E
=
"
:
{
"
Rym6o
+
VN9xgZXT
/
QLrvN
/
nv1ZN4
=
"
:
true
}
"
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
"
:
{
"
a0X7
/
7DlTaedpgrIJg25iBPOkIM
=
"
:
true
}
"
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
"
:
{
"
YW5vdGhlciBzZXJpYWwu
"
:
true
"
c2VyaWFsMi4
=
"
:
true
}
}
;
add_task
(
async
function
(
)
{
ok
(
test_is_revoked
(
certList
"
some
imaginary
issuer
"
"
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
let
file
=
"
test_onecrl
/
test
-
int
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
bad_certs
/
other
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
test_onecrl
/
same
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
}
)
;
add_task
(
fetch_blocklist
)
;
add_task
(
async
function
(
)
{
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
another
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
nonsense
"
"
more
nonsense
"
"
some
imaginary
subject
"
"
some
imaginary
pubkey
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
check_revocations_txt_contents
(
expected
)
;
let
file
=
"
test_onecrl
/
test
-
int
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
bad_certs
/
other
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
test_onecrl
/
same
-
issuer
-
ee
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
await
verify_non_tls_usage_succeeds
(
file
)
;
file
=
"
bad_certs
/
default
-
ee
.
pem
"
;
await
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
bad_certs
/
unknownissuer
.
pem
"
;
await
verify_cert
(
file
SEC_ERROR_UNKNOWN_ISSUER
)
;
let
lastModified
=
gRevocations
.
lastModifiedTime
;
certList
.
revokeCertByIssuerAndSerial
(
"
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
"
"
c2VyaWFsMi4
=
"
)
;
certList
.
saveEntries
(
)
;
let
newModified
=
gRevocations
.
lastModifiedTime
;
equal
(
lastModified
newModified
"
saveEntries
with
no
modifications
should
not
update
the
backing
file
"
)
;
}
)
;
add_test
(
function
(
)
{
check_revocations_txt_contents
(
expected
)
;
run_next_test
(
)
;
}
)
;
run_next_test
(
)
;
}
