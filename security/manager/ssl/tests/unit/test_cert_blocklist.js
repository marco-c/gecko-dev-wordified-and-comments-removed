"
use
strict
"
;
var
id
=
"
xpcshell
tests
.
mozilla
.
org
"
;
var
appName
=
"
XPCShell
"
;
var
version
=
"
1
"
;
var
platformVersion
=
"
1
.
9
.
2
"
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
this
)
;
updateAppInfo
(
{
name
:
appName
ID
:
id
version
:
version
platformVersion
:
platformVersion
?
platformVersion
:
"
1
.
0
"
crashReporter
:
true
}
)
;
var
profile
=
do_get_profile
(
)
;
var
blockFile
=
profile
.
clone
(
)
;
blockFile
.
append
(
"
blocklist
.
xml
"
)
;
var
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
stream
.
init
(
blockFile
FileUtils
.
MODE_WRONLY
|
FileUtils
.
MODE_CREATE
|
FileUtils
.
MODE_TRUNCATE
FileUtils
.
PERMS_FILE
0
)
;
var
data
=
"
<
?
xml
version
=
\
"
1
.
0
\
"
encoding
=
\
"
UTF
-
8
\
"
?
>
\
n
"
+
"
<
blocklist
xmlns
=
\
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
addons
-
blocklist
\
"
>
\
n
"
+
"
<
/
blocklist
>
\
n
"
;
stream
.
write
(
data
data
.
length
)
;
stream
.
close
(
)
;
const
PREF_BLOCKLIST_UPDATE_ENABLED
=
"
services
.
blocklist
.
update_enabled
"
;
const
PREF_ONECRL_VIA_AMO
=
"
security
.
onecrl
.
via
.
amo
"
;
var
revocations
=
profile
.
clone
(
)
;
revocations
.
append
(
"
revocations
.
txt
"
)
;
if
(
!
revocations
.
exists
(
)
)
{
let
existing
=
do_get_file
(
"
test_onecrl
/
sample_revocations
.
txt
"
false
)
;
existing
.
copyTo
(
profile
"
revocations
.
txt
"
)
;
}
var
certDB
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
var
testserver
=
new
HttpServer
(
)
;
var
initialBlocklist
=
"
<
?
xml
version
=
\
"
1
.
0
\
"
encoding
=
\
"
UTF
-
8
\
"
?
>
"
+
"
<
blocklist
xmlns
=
\
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
addons
-
blocklist
\
"
>
"
+
"
<
certItems
>
<
certItem
issuerName
=
'
Some
nonsense
in
issuer
'
>
"
+
"
<
serialNumber
>
AkHVNA
=
=
<
/
serialNumber
>
"
+
"
<
/
certItem
>
<
certItem
issuerName
=
'
MA0xCzAJBgNVBAMMAmNh
'
>
"
+
"
<
serialNumber
>
some
nonsense
in
serial
<
/
serialNumber
>
"
+
"
<
/
certItem
>
<
certItem
issuerName
=
'
some
nonsense
in
both
issuer
'
>
"
+
"
<
serialNumber
>
and
serial
<
/
serialNumber
>
<
/
certItem
>
"
+
"
<
certItem
issuerName
=
'
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
'
>
"
+
"
<
serialNumber
>
oops
!
more
nonsense
.
<
/
serialNumber
>
"
+
"
<
serialNumber
>
BVio
/
iQ21GCi2iUven8oJ
/
gae74
=
<
/
serialNumber
>
<
/
certItem
>
"
+
"
<
certItem
issuerName
=
'
MBgxFjAUBgNVBAMMDU90aGVyIHRlc3QgQ0E
=
'
>
"
+
"
<
serialNumber
>
exJUIJpq50jgqOwQluhVrAzTF74
=
<
/
serialNumber
>
<
/
certItem
>
"
+
"
<
certItem
issuerName
=
'
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
'
>
"
+
"
<
serialNumber
>
c2VyaWFsMi4
=
<
/
serialNumber
>
"
+
"
<
serialNumber
>
YW5vdGhlciBzZXJpYWwu
<
/
serialNumber
>
<
/
certItem
>
"
+
"
<
certItem
subject
=
'
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
'
"
+
"
pubKeyHash
=
'
VCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
'
>
"
+
"
<
/
certItem
>
<
/
certItems
>
<
/
blocklist
>
"
;
var
updatedBlocklist
=
"
<
?
xml
version
=
\
"
1
.
0
\
"
encoding
=
\
"
UTF
-
8
\
"
?
>
"
+
"
<
blocklist
xmlns
=
\
"
http
:
/
/
www
.
mozilla
.
org
/
2006
/
addons
-
blocklist
\
"
>
"
+
"
<
certItems
>
"
+
"
<
certItem
issuerName
=
'
something
new
in
both
the
issuer
'
>
"
+
"
<
serialNumber
>
and
the
serial
number
<
/
serialNumber
>
<
/
certItem
>
"
+
"
<
/
certItems
>
<
/
blocklist
>
"
;
var
blocklists
=
{
"
/
initialBlocklist
/
"
:
initialBlocklist
"
/
updatedBlocklist
/
"
:
updatedBlocklist
}
;
function
serveResponse
(
request
response
)
{
do_print
(
"
Serving
for
path
"
+
request
.
path
+
"
\
n
"
)
;
response
.
write
(
blocklists
[
request
.
path
]
)
;
}
for
(
var
path
in
blocklists
)
{
testserver
.
registerPathHandler
(
path
serveResponse
)
;
}
testserver
.
start
(
-
1
)
;
var
port
=
testserver
.
identity
.
primaryPort
;
var
addonManager
=
Cc
[
"
mozilla
.
org
/
addons
/
integration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
QueryInterface
(
Ci
.
nsITimerCallback
)
;
addonManager
.
observe
(
null
"
addons
-
startup
"
null
)
;
var
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
function
verify_cert
(
file
expectedError
)
{
let
ee
=
constructCertFromFile
(
file
)
;
checkCertErrorGeneric
(
certDB
ee
expectedError
certificateUsageSSLServer
)
;
}
function
load_cert
(
cert
trust
)
{
let
file
=
"
bad_certs
/
"
+
cert
+
"
.
pem
"
;
addCertFromFile
(
certDB
file
trust
)
;
}
function
test_is_revoked
(
certList
issuerString
serialString
subjectString
pubKeyString
)
{
let
issuer
=
converter
.
convertToByteArray
(
issuerString
?
issuerString
:
'
'
{
}
)
;
let
serial
=
converter
.
convertToByteArray
(
serialString
?
serialString
:
'
'
{
}
)
;
let
subject
=
converter
.
convertToByteArray
(
subjectString
?
subjectString
:
'
'
{
}
)
;
let
pubKey
=
converter
.
convertToByteArray
(
pubKeyString
?
pubKeyString
:
'
'
{
}
)
;
return
certList
.
isCertRevoked
(
issuer
issuerString
?
issuerString
.
length
:
0
serial
serialString
?
serialString
.
length
:
0
subject
subjectString
?
subjectString
.
length
:
0
pubKey
pubKeyString
?
pubKeyString
.
length
:
0
)
;
}
function
fetch_blocklist
(
blocklistPath
)
{
do_print
(
"
path
is
"
+
blocklistPath
+
"
\
n
"
)
;
let
certblockObserver
=
{
observe
:
function
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
this
"
blocklist
-
updated
"
)
;
run_next_test
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
certblockObserver
"
blocklist
-
updated
"
false
)
;
Services
.
prefs
.
setCharPref
(
"
extensions
.
blocklist
.
url
"
http
:
/
/
localhost
:
{
port
}
/
{
blocklistPath
}
)
;
let
blocklist
=
Cc
[
"
mozilla
.
org
/
extensions
/
blocklist
;
1
"
]
.
getService
(
Ci
.
nsITimerCallback
)
;
blocklist
.
notify
(
null
)
;
}
function
check_revocations_txt_contents
(
expected
)
{
let
profile
=
do_get_profile
(
)
;
let
revocations
=
profile
.
clone
(
)
;
revocations
.
append
(
"
revocations
.
txt
"
)
;
ok
(
revocations
.
exists
(
)
"
the
revocations
file
should
exist
"
)
;
let
inputStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
inputStream
.
init
(
revocations
-
1
-
1
0
)
;
inputStream
.
QueryInterface
(
Ci
.
nsILineInputStream
)
;
let
contents
=
"
"
;
let
hasmore
=
false
;
do
{
let
line
=
{
}
;
hasmore
=
inputStream
.
readLine
(
line
)
;
contents
+
=
(
contents
.
length
=
=
0
?
"
"
:
"
\
n
"
)
+
line
.
value
;
}
while
(
hasmore
)
;
equal
(
contents
expected
"
revocations
.
txt
should
be
as
expected
"
)
;
}
function
run_test
(
)
{
load_cert
(
"
test
-
ca
"
"
CTu
CTu
CTu
"
)
;
load_cert
(
"
test
-
int
"
"
"
)
;
load_cert
(
"
other
-
test
-
ca
"
"
CTu
CTu
CTu
"
)
;
let
certList
=
Cc
[
"
mozilla
.
org
/
security
/
certblocklist
;
1
"
]
.
getService
(
Ci
.
nsICertBlocklist
)
;
let
expected
=
"
#
Auto
generated
contents
.
Do
not
edit
.
\
n
"
+
"
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
\
n
"
+
"
\
tVCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
\
n
"
+
"
MBIxEDAOBgNVBAMMB1Rlc3QgQ0E
=
\
n
"
+
"
BVio
/
iQ21GCi2iUven8oJ
/
gae74
=
\
n
"
+
"
MBgxFjAUBgNVBAMMDU90aGVyIHRlc3QgQ0E
=
\
n
"
+
"
exJUIJpq50jgqOwQluhVrAzTF74
=
\
n
"
+
"
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
\
n
"
+
"
YW5vdGhlciBzZXJpYWwu
\
n
"
+
"
c2VyaWFsMi4
=
"
;
Services
.
prefs
.
setBoolPref
(
PREF_BLOCKLIST_UPDATE_ENABLED
false
)
;
Services
.
prefs
.
setBoolPref
(
PREF_ONECRL_VIA_AMO
true
)
;
add_test
(
function
(
)
{
ok
(
test_is_revoked
(
certList
"
some
imaginary
issuer
"
"
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
let
file
=
"
test_onecrl
/
test
-
int
-
ee
.
pem
"
;
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
bad_certs
/
other
-
issuer
-
ee
.
pem
"
;
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
test_onecrl
/
same
-
issuer
-
ee
.
pem
"
;
verify_cert
(
file
PRErrorCodeSuccess
)
;
run_next_test
(
)
;
}
)
;
add_test
(
function
(
)
{
fetch_blocklist
(
"
initialBlocklist
/
"
)
;
}
)
;
add_test
(
function
(
)
{
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
serial2
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
another
imaginary
issuer
"
"
another
serial
.
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
ok
(
test_is_revoked
(
certList
"
nonsense
"
"
more
nonsense
"
"
some
imaginary
subject
"
"
some
imaginary
pubkey
"
)
"
issuer
/
serial
pair
should
be
blocked
"
)
;
check_revocations_txt_contents
(
expected
)
;
let
file
=
"
test_onecrl
/
test
-
int
-
ee
.
pem
"
;
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
bad_certs
/
other
-
issuer
-
ee
.
pem
"
;
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
test_onecrl
/
same
-
issuer
-
ee
.
pem
"
;
verify_cert
(
file
SEC_ERROR_REVOKED_CERTIFICATE
)
;
file
=
"
bad_certs
/
default
-
ee
.
pem
"
;
verify_cert
(
file
PRErrorCodeSuccess
)
;
file
=
"
bad_certs
/
unknownissuer
.
pem
"
;
verify_cert
(
file
SEC_ERROR_UNKNOWN_ISSUER
)
;
let
lastModified
=
revocations
.
lastModifiedTime
;
certList
.
revokeCertByIssuerAndSerial
(
"
YW5vdGhlciBpbWFnaW5hcnkgaXNzdWVy
"
"
c2VyaWFsMi4
=
"
)
;
certList
.
saveEntries
(
)
;
let
newModified
=
revocations
.
lastModifiedTime
;
equal
(
lastModified
newModified
"
saveEntries
with
no
modifications
should
not
update
the
backing
file
"
)
;
run_next_test
(
)
;
}
)
;
add_test
(
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
security
.
onecrl
.
via
.
amo
"
false
)
;
fetch_blocklist
(
"
updatedBlocklist
/
"
)
;
}
)
;
add_test
(
function
(
)
{
check_revocations_txt_contents
(
expected
)
;
run_next_test
(
)
;
}
)
;
run_next_test
(
)
;
}
