"
use
strict
"
;
do_get_profile
(
)
;
let
gSetPasswordShownCount
=
0
;
const
gTokenPasswordDialogs
=
{
setPassword
(
ctx
tokenName
)
{
gSetPasswordShownCount
+
+
;
info
(
setPassword
(
)
called
;
shown
{
gSetPasswordShownCount
}
times
)
;
info
(
tokenName
:
{
tokenName
}
)
;
return
false
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsITokenPasswordDialogs
]
)
}
;
add_task
(
function
testEncryptString
(
)
{
let
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
let
inputs
=
[
"
"
"
"
"
foo
"
"
1234567890
~
!
#
%
^
&
*
(
)
-
_
=
+
{
[
}
]
|
\
\
:
;
'
\
"
<
.
>
/
?
"
"
"
"
aaa
"
]
;
for
(
let
input
of
inputs
)
{
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
convertedInput
=
converter
.
ConvertFromUnicode
(
input
)
;
convertedInput
+
=
converter
.
Finish
(
)
;
let
encrypted
=
sdr
.
encryptString
(
convertedInput
)
;
notEqual
(
convertedInput
encrypted
"
Encrypted
input
should
not
just
be
the
input
itself
"
)
;
try
{
atob
(
encrypted
)
;
}
catch
(
e
)
{
ok
(
false
encryptString
(
)
should
have
returned
Base64
:
{
e
}
)
;
}
equal
(
convertedInput
sdr
.
decryptString
(
encrypted
)
"
decryptString
(
encryptString
(
input
)
)
should
return
input
"
)
;
}
throws
(
(
)
=
>
sdr
.
decryptString
(
"
*
"
)
/
NS_ERROR_ILLEGAL_VALUE
/
"
decryptString
(
)
should
throw
if
given
non
-
Base64
input
"
)
;
if
(
AppConstants
.
platform
!
=
"
android
"
)
{
let
tokenPasswordDialogsCID
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
nsTokenPasswordDialogs
;
1
"
gTokenPasswordDialogs
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
tokenPasswordDialogsCID
)
;
}
)
;
equal
(
gSetPasswordShownCount
0
"
changePassword
(
)
dialog
should
have
been
shown
zero
times
"
)
;
sdr
.
changePassword
(
)
;
equal
(
gSetPasswordShownCount
1
"
changePassword
(
)
dialog
should
have
been
shown
exactly
once
"
)
;
}
}
)
;
add_task
(
async
function
testAsyncEncryptStrings
(
)
{
let
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
let
inputs
=
[
"
"
"
"
"
foo
"
"
1234567890
~
!
#
%
^
&
*
(
)
-
_
=
+
{
[
}
]
|
\
\
:
;
'
\
"
<
.
>
/
?
"
"
"
"
aaa
"
]
;
let
encrypteds
=
await
sdr
.
asyncEncryptStrings
(
inputs
)
;
for
(
let
i
=
0
;
i
<
inputs
.
length
;
i
+
+
)
{
let
encrypted
=
encrypteds
[
i
]
;
let
input
=
inputs
[
i
]
;
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
convertedInput
=
converter
.
ConvertFromUnicode
(
input
)
;
convertedInput
+
=
converter
.
Finish
(
)
;
notEqual
(
convertedInput
encrypted
"
Encrypted
input
should
not
just
be
the
input
itself
"
)
;
try
{
atob
(
encrypted
)
;
}
catch
(
e
)
{
ok
(
false
encryptString
(
)
should
have
returned
Base64
:
{
e
}
)
;
}
equal
(
convertedInput
sdr
.
decryptString
(
encrypted
)
"
decryptString
(
encryptString
(
input
)
)
should
return
input
"
)
;
}
}
)
;
add_task
(
async
function
testAsyncDecryptStrings
(
)
{
let
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
let
testCases
=
[
"
"
"
"
"
foo
"
"
1234567890
~
!
#
%
^
&
*
(
)
-
_
=
+
{
[
}
]
|
\
\
:
;
'
\
"
<
.
>
/
?
"
"
"
"
aaa
"
]
;
let
convertedTestCases
=
testCases
.
map
(
tc
=
>
{
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
convertedInput
=
converter
.
ConvertFromUnicode
(
tc
)
;
convertedInput
+
=
converter
.
Finish
(
)
;
return
convertedInput
;
}
)
;
let
encryptedStrings
=
convertedTestCases
.
map
(
tc
=
>
sdr
.
encryptString
(
tc
)
)
;
let
decrypteds
=
await
sdr
.
asyncDecryptStrings
(
encryptedStrings
)
;
for
(
let
i
=
0
;
i
<
encryptedStrings
.
length
;
i
+
+
)
{
let
decrypted
=
decrypteds
[
i
]
;
let
expectedDecryptedString
=
convertedTestCases
[
i
]
;
equal
(
decrypted
expectedDecryptedString
"
decrypted
string
should
match
expected
value
"
)
;
equal
(
sdr
.
decryptString
(
encryptedStrings
[
i
]
)
decrypted
"
decryptString
(
encryptString
(
input
)
)
should
return
the
initial
decrypted
string
value
"
)
;
}
}
)
;
