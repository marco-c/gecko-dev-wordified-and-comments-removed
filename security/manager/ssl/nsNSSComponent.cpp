#
include
"
nsNSSComponent
.
h
"
#
include
"
ExtendedValidation
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
SharedSSLState
.
h
"
#
include
"
cert
.
h
"
#
include
"
certdb
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
PublicSSL
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsClientAuthRemember
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsICertOverrideService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsITokenPasswordDialogs
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsNSSCertificateDB
.
h
"
#
include
"
nsNSSHelper
.
h
"
#
include
"
nsNSSShutDown
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nss
.
h
"
#
include
"
p12plcy
.
h
"
#
include
"
pkix
/
pkixnss
.
h
"
#
include
"
secerr
.
h
"
#
include
"
secmod
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslerr
.
h
"
#
include
"
sslproto
.
h
"
#
ifndef
MOZ_NO_SMART_CARDS
#
include
"
nsSmartCardMonitor
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsILocalFileWin
.
h
"
#
include
"
windows
.
h
"
#
include
"
lmcons
.
h
"
#
include
"
sddl
.
h
"
#
include
"
wincrypt
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
psm
;
LazyLogModule
gPIPNSSLog
(
"
pipnss
"
)
;
int
nsNSSComponent
:
:
mInstanceCount
=
0
;
bool
EnsureNSSInitializedChromeOrContent
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
static
Atomic
<
bool
>
initialized
(
false
)
;
if
(
initialized
)
{
return
true
;
}
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
mozilla
:
:
SyncRunnable
:
:
DispatchToThread
(
mainThread
new
SyncRunnable
(
NS_NewRunnableFunction
(
[
]
(
)
{
initialized
=
EnsureNSSInitializedChromeOrContent
(
)
;
}
)
)
)
;
return
initialized
;
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsISupports
>
nss
=
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
;
if
(
!
nss
)
{
return
false
;
}
return
true
;
}
if
(
NSS_IsInitialized
(
)
)
{
return
true
;
}
if
(
NSS_NoDB_Init
(
nullptr
)
!
=
SECSuccess
)
{
return
false
;
}
if
(
NS_FAILED
(
mozilla
:
:
psm
:
:
InitializeCipherSuite
(
)
)
)
{
return
false
;
}
mozilla
:
:
psm
:
:
DisableMD5
(
)
;
return
true
;
}
static
void
GetRevocationBehaviorFromPrefs
(
CertVerifier
:
:
OcspDownloadConfig
*
odc
CertVerifier
:
:
OcspStrictConfig
*
osc
CertVerifier
:
:
OcspGetConfig
*
ogc
uint32_t
*
certShortLifetimeInDays
const
MutexAutoLock
&
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
odc
)
;
MOZ_ASSERT
(
osc
)
;
MOZ_ASSERT
(
ogc
)
;
MOZ_ASSERT
(
certShortLifetimeInDays
)
;
int32_t
ocspLevel
=
Preferences
:
:
GetInt
(
"
security
.
OCSP
.
enabled
"
1
)
;
switch
(
ocspLevel
)
{
case
0
:
*
odc
=
CertVerifier
:
:
ocspOff
;
break
;
case
2
:
*
odc
=
CertVerifier
:
:
ocspEVOnly
;
break
;
default
:
*
odc
=
CertVerifier
:
:
ocspOn
;
break
;
}
*
osc
=
Preferences
:
:
GetBool
(
"
security
.
OCSP
.
require
"
false
)
?
CertVerifier
:
:
ocspStrict
:
CertVerifier
:
:
ocspRelaxed
;
*
ogc
=
Preferences
:
:
GetBool
(
"
security
.
OCSP
.
GET
.
enabled
"
false
)
?
CertVerifier
:
:
ocspGetEnabled
:
CertVerifier
:
:
ocspGetDisabled
;
*
certShortLifetimeInDays
=
Preferences
:
:
GetUint
(
"
security
.
pki
.
cert_short_lifetime_in_days
"
static_cast
<
uint32_t
>
(
0
)
)
;
SSL_ClearSessionCache
(
)
;
}
nsNSSComponent
:
:
nsNSSComponent
(
)
:
mutex
(
"
nsNSSComponent
.
mutex
"
)
mNSSInitialized
(
false
)
#
ifndef
MOZ_NO_SMART_CARDS
mThreadList
(
nullptr
)
#
endif
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
ctor
\
n
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mInstanceCount
=
=
0
"
nsNSSComponent
is
a
singleton
but
instantiated
multiple
times
!
"
)
;
+
+
mInstanceCount
;
}
nsNSSComponent
:
:
~
nsNSSComponent
(
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
dtor
\
n
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
ShutdownNSS
(
)
;
SharedSSLState
:
:
GlobalCleanup
(
)
;
RememberCertErrorsTable
:
:
Cleanup
(
)
;
-
-
mInstanceCount
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
dtor
finished
\
n
"
)
)
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
PIPBundleFormatStringFromName
(
const
char
*
name
const
char16_t
*
*
params
uint32_t
numParams
nsAString
&
outString
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
mPIPNSSBundle
&
&
name
)
{
nsXPIDLString
result
;
rv
=
mPIPNSSBundle
-
>
FormatStringFromName
(
NS_ConvertASCIItoUTF16
(
name
)
.
get
(
)
params
numParams
getter_Copies
(
result
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
outString
=
result
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
GetPIPNSSBundleString
(
const
char
*
name
nsAString
&
outString
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
outString
.
SetLength
(
0
)
;
if
(
mPIPNSSBundle
&
&
name
)
{
nsXPIDLString
result
;
rv
=
mPIPNSSBundle
-
>
GetStringFromName
(
NS_ConvertASCIItoUTF16
(
name
)
.
get
(
)
getter_Copies
(
result
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
outString
=
result
;
rv
=
NS_OK
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
GetNSSBundleString
(
const
char
*
name
nsAString
&
outString
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
outString
.
SetLength
(
0
)
;
if
(
mNSSErrorsBundle
&
&
name
)
{
nsXPIDLString
result
;
rv
=
mNSSErrorsBundle
-
>
GetStringFromName
(
NS_ConvertASCIItoUTF16
(
name
)
.
get
(
)
getter_Copies
(
result
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
outString
=
result
;
rv
=
NS_OK
;
}
}
return
rv
;
}
#
ifndef
MOZ_NO_SMART_CARDS
void
nsNSSComponent
:
:
LaunchSmartCardThreads
(
)
{
nsNSSShutDownPreventionLock
locker
;
{
SECMODModuleList
*
list
;
SECMODListLock
*
lock
=
SECMOD_GetDefaultModuleListLock
(
)
;
if
(
!
lock
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Couldn
'
t
get
the
module
list
lock
can
'
t
launch
smart
card
threads
\
n
"
)
)
;
return
;
}
SECMOD_GetReadLock
(
lock
)
;
list
=
SECMOD_GetDefaultModuleList
(
)
;
while
(
list
)
{
SECMODModule
*
module
=
list
-
>
module
;
LaunchSmartCardThread
(
module
)
;
list
=
list
-
>
next
;
}
SECMOD_ReleaseReadLock
(
lock
)
;
}
}
NS_IMETHODIMP
nsNSSComponent
:
:
LaunchSmartCardThread
(
SECMODModule
*
module
)
{
SmartCardMonitoringThread
*
newThread
;
if
(
SECMOD_HasRemovableSlots
(
module
)
)
{
if
(
!
mThreadList
)
{
mThreadList
=
new
SmartCardThreadList
(
)
;
}
newThread
=
new
SmartCardMonitoringThread
(
module
)
;
return
mThreadList
-
>
Add
(
newThread
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
ShutdownSmartCardThread
(
SECMODModule
*
module
)
{
if
(
!
mThreadList
)
{
return
NS_OK
;
}
mThreadList
-
>
Remove
(
module
)
;
return
NS_OK
;
}
void
nsNSSComponent
:
:
ShutdownSmartCardThreads
(
)
{
delete
mThreadList
;
mThreadList
=
nullptr
;
}
#
endif
#
ifdef
XP_WIN
static
bool
GetUserSid
(
nsAString
&
sidString
)
{
WCHAR
lpAccountName
[
UNLEN
+
1
]
;
DWORD
lcAccountName
=
sizeof
(
lpAccountName
)
/
sizeof
(
lpAccountName
[
0
]
)
;
BOOL
success
=
GetUserName
(
lpAccountName
&
lcAccountName
)
;
if
(
!
success
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
GetUserName
failed
"
)
)
;
return
false
;
}
char
sid_buffer
[
SECURITY_MAX_SID_SIZE
]
;
SID
*
sid
=
BitwiseCast
<
SID
*
char
*
>
(
sid_buffer
)
;
DWORD
cbSid
=
ArrayLength
(
sid_buffer
)
;
SID_NAME_USE
eUse
;
DWORD
cchReferencedDomainName
=
128
;
auto
ReferencedDomainName
(
MakeUnique
<
WCHAR
[
]
>
(
cchReferencedDomainName
)
)
;
success
=
LookupAccountName
(
nullptr
lpAccountName
sid
&
cbSid
ReferencedDomainName
.
get
(
)
&
cchReferencedDomainName
&
eUse
)
;
if
(
!
success
&
&
GetLastError
(
)
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
LookupAccountName
failed
"
)
)
;
return
false
;
}
if
(
!
success
)
{
ReferencedDomainName
=
MakeUnique
<
WCHAR
[
]
>
(
cchReferencedDomainName
)
;
success
=
LookupAccountName
(
nullptr
lpAccountName
sid
&
cbSid
ReferencedDomainName
.
get
(
)
&
cchReferencedDomainName
&
eUse
)
;
}
if
(
!
success
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
LookupAccountName
failed
"
)
)
;
return
false
;
}
LPTSTR
StringSid
;
success
=
ConvertSidToStringSid
(
sid
&
StringSid
)
;
if
(
!
success
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
ConvertSidToStringSid
failed
"
)
)
;
return
false
;
}
sidString
.
Assign
(
StringSid
)
;
LocalFree
(
StringSid
)
;
return
true
;
}
static
nsresult
ReadRegKeyValueWithDefault
(
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
uint32_t
flags
wchar_t
*
optionalChildName
wchar_t
*
valueName
uint32_t
defaultValue
uint32_t
&
valueOut
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
ReadRegKeyValueWithDefault
"
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
attempting
to
read
'
%
S
%
s
%
S
'
with
default
'
%
u
'
"
optionalChildName
?
optionalChildName
:
L
"
"
optionalChildName
?
"
\
\
"
:
"
"
valueName
defaultValue
)
)
;
if
(
optionalChildName
)
{
nsDependentString
childNameString
(
optionalChildName
)
;
bool
hasChild
;
nsresult
rv
=
regKey
-
>
HasChild
(
childNameString
&
hasChild
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
determine
if
child
key
is
present
"
)
)
;
return
rv
;
}
if
(
!
hasChild
)
{
valueOut
=
defaultValue
;
return
NS_OK
;
}
nsCOMPtr
<
nsIWindowsRegKey
>
childRegKey
;
rv
=
regKey
-
>
OpenChild
(
childNameString
flags
getter_AddRefs
(
childRegKey
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
open
child
key
"
)
)
;
return
rv
;
}
return
ReadRegKeyValueWithDefault
(
childRegKey
flags
nullptr
valueName
defaultValue
valueOut
)
;
}
nsDependentString
valueNameString
(
valueName
)
;
bool
hasValue
;
nsresult
rv
=
regKey
-
>
HasValue
(
valueNameString
&
hasValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
determine
if
value
is
present
"
)
)
;
return
rv
;
}
if
(
!
hasValue
)
{
valueOut
=
defaultValue
;
return
NS_OK
;
}
rv
=
regKey
-
>
ReadIntValue
(
valueNameString
&
valueOut
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
read
value
"
)
)
;
return
rv
;
}
return
NS_OK
;
}
static
nsresult
AccountHasFamilySafetyEnabled
(
bool
&
enabled
)
{
enabled
=
false
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
AccountHasFamilySafetyEnabled
?
"
)
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
parentalControlsKey
(
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
)
;
if
(
!
parentalControlsKey
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
create
nsIWindowsRegKey
"
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
flags
=
nsIWindowsRegKey
:
:
ACCESS_READ
|
nsIWindowsRegKey
:
:
WOW64_64
;
NS_NAMED_LITERAL_STRING
(
familySafetyPath
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Parental
Controls
"
)
;
nsresult
rv
=
parentalControlsKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_LOCAL_MACHINE
familySafetyPath
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
open
parentalControlsKey
"
)
)
;
return
rv
;
}
NS_NAMED_LITERAL_STRING
(
usersString
"
Users
"
)
;
bool
hasUsers
;
rv
=
parentalControlsKey
-
>
HasChild
(
usersString
&
hasUsers
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HasChild
(
Users
)
failed
"
)
)
;
return
rv
;
}
if
(
!
hasUsers
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Users
subkey
not
present
-
Parental
Controls
not
enabled
"
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIWindowsRegKey
>
usersKey
;
rv
=
parentalControlsKey
-
>
OpenChild
(
usersString
flags
getter_AddRefs
(
usersKey
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
open
Users
subkey
"
)
)
;
return
rv
;
}
nsAutoString
sid
;
if
(
!
GetUserSid
(
sid
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
get
sid
"
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
our
sid
is
'
%
S
'
"
sid
.
get
(
)
)
)
;
bool
hasSid
;
rv
=
usersKey
-
>
HasChild
(
sid
&
hasSid
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HasChild
(
sid
)
failed
"
)
)
;
return
rv
;
}
if
(
!
hasSid
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
sid
not
present
in
Family
Safety
Users
"
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIWindowsRegKey
>
sidKey
;
rv
=
usersKey
-
>
OpenChild
(
sid
flags
getter_AddRefs
(
sidKey
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
open
sid
key
"
)
)
;
return
rv
;
}
uint32_t
parentalControlsOn
;
rv
=
sidKey
-
>
ReadIntValue
(
NS_LITERAL_STRING
(
"
Parental
Controls
On
"
)
&
parentalControlsOn
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
read
Parental
Controls
On
"
)
)
;
return
rv
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Parental
Controls
On
:
%
u
"
parentalControlsOn
)
)
;
if
(
parentalControlsOn
!
=
1
)
{
return
NS_OK
;
}
uint32_t
loggingRequired
;
rv
=
ReadRegKeyValueWithDefault
(
sidKey
flags
nullptr
L
"
Logging
Required
"
1
loggingRequired
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
read
value
of
Logging
Required
"
)
)
;
return
rv
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Logging
Required
:
%
u
"
loggingRequired
)
)
;
uint32_t
webFilterOn
;
rv
=
ReadRegKeyValueWithDefault
(
sidKey
flags
L
"
Web
"
L
"
Filter
On
"
0
webFilterOn
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
read
value
of
Web
\
\
Filter
On
"
)
)
;
return
rv
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Web
\
\
Filter
On
:
%
u
"
webFilterOn
)
)
;
enabled
=
loggingRequired
=
=
1
|
|
webFilterOn
=
=
1
;
return
NS_OK
;
}
static
UniqueCERTCertificate
PCCERT_CONTEXTToCERTCertificate
(
PCCERT_CONTEXT
pccert
)
{
MOZ_ASSERT
(
pccert
)
;
if
(
!
pccert
)
{
return
nullptr
;
}
SECItem
derCert
=
{
siBuffer
pccert
-
>
pbCertEncoded
pccert
-
>
cbCertEncoded
}
;
return
UniqueCERTCertificate
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
derCert
nullptr
false
true
)
)
;
}
static
const
char
*
kMicrosoftFamilySafetyCN
=
"
Microsoft
Family
Safety
"
;
nsresult
nsNSSComponent
:
:
MaybeImportFamilySafetyRoot
(
PCCERT_CONTEXT
certificate
bool
&
wasFamilySafetyRoot
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
MaybeImportFamilySafetyRoot
"
)
)
;
wasFamilySafetyRoot
=
false
;
UniqueCERTCertificate
nssCertificate
(
PCCERT_CONTEXTToCERTCertificate
(
certificate
)
)
;
if
(
!
nssCertificate
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
decode
certificate
"
)
)
;
return
NS_ERROR_FAILURE
;
}
UniquePORTString
subjectName
(
CERT_GetCommonName
(
&
nssCertificate
-
>
subject
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
subject
name
is
'
%
s
'
"
subjectName
.
get
(
)
)
)
;
if
(
nsCRT
:
:
strcmp
(
subjectName
.
get
(
)
kMicrosoftFamilySafetyCN
)
=
=
0
)
{
wasFamilySafetyRoot
=
true
;
CERTCertTrust
trust
=
{
CERTDB_TRUSTED_CA
|
CERTDB_VALID_CA
|
CERTDB_USER
0
0
}
;
if
(
CERT_ChangeCertTrust
(
nullptr
nssCertificate
.
get
(
)
&
trust
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
trust
certificate
for
TLS
server
auth
"
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
mFamilySafetyRoot
)
;
mFamilySafetyRoot
=
Move
(
nssCertificate
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
added
Family
Safety
root
"
)
)
;
}
return
NS_OK
;
}
class
ScopedCertStore
final
{
public
:
explicit
ScopedCertStore
(
HCERTSTORE
certstore
)
:
certstore
(
certstore
)
{
}
~
ScopedCertStore
(
)
{
CertCloseStore
(
certstore
0
)
;
}
HCERTSTORE
get
(
)
{
return
certstore
;
}
private
:
ScopedCertStore
(
const
ScopedCertStore
&
)
=
delete
;
ScopedCertStore
&
operator
=
(
const
ScopedCertStore
&
)
=
delete
;
HCERTSTORE
certstore
;
}
;
static
const
wchar_t
*
kWindowsDefaultRootStoreName
=
L
"
ROOT
"
;
nsresult
nsNSSComponent
:
:
LoadFamilySafetyRoot
(
)
{
ScopedCertStore
certstore
(
CertOpenSystemStore
(
0
kWindowsDefaultRootStoreName
)
)
;
if
(
!
certstore
.
get
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
get
certstore
'
%
S
'
"
kWindowsDefaultRootStoreName
)
)
;
return
NS_ERROR_FAILURE
;
}
PCCERT_CONTEXT
certificate
=
nullptr
;
while
(
(
certificate
=
CertFindCertificateInStore
(
certstore
.
get
(
)
X509_ASN_ENCODING
0
CERT_FIND_ANY
nullptr
certificate
)
)
)
{
bool
wasFamilySafetyRoot
=
false
;
nsresult
rv
=
MaybeImportFamilySafetyRoot
(
certificate
wasFamilySafetyRoot
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
wasFamilySafetyRoot
)
{
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
void
nsNSSComponent
:
:
UnloadFamilySafetyRoot
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
UnloadFamilySafetyRoot
"
)
)
;
if
(
!
mFamilySafetyRoot
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Family
Safety
Root
wasn
'
t
present
"
)
)
;
return
;
}
CERTCertTrust
trust
=
{
CERTDB_USER
0
0
}
;
if
(
CERT_ChangeCertTrust
(
nullptr
mFamilySafetyRoot
.
get
(
)
&
trust
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
untrust
certificate
for
TLS
server
auth
"
)
)
;
}
mFamilySafetyRoot
=
nullptr
;
}
#
endif
const
char
*
kFamilySafetyModePref
=
"
security
.
family_safety
.
mode
"
;
void
nsNSSComponent
:
:
MaybeEnableFamilySafetyCompatibility
(
)
{
#
ifdef
XP_WIN
UnloadFamilySafetyRoot
(
)
;
if
(
!
(
IsWin8Point1OrLater
(
)
&
&
!
IsWin10OrLater
(
)
)
)
{
return
;
}
uint32_t
familySafetyMode
=
Preferences
:
:
GetUint
(
kFamilySafetyModePref
1
)
;
if
(
familySafetyMode
>
2
)
{
familySafetyMode
=
0
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FAMILY_SAFETY
familySafetyMode
)
;
if
(
familySafetyMode
=
=
0
)
{
return
;
}
bool
familySafetyEnabled
;
nsresult
rv
=
AccountHasFamilySafetyEnabled
(
familySafetyEnabled
)
;
if
(
NS_FAILED
(
rv
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FAMILY_SAFETY
3
)
;
return
;
}
if
(
!
familySafetyEnabled
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FAMILY_SAFETY
4
)
;
return
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FAMILY_SAFETY
5
)
;
if
(
familySafetyMode
=
=
2
)
{
rv
=
LoadFamilySafetyRoot
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FAMILY_SAFETY
6
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
load
Family
Safety
root
"
)
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FAMILY_SAFETY
7
)
;
}
}
#
endif
}
#
ifdef
XP_WIN
static
bool
CertIsTrustAnchorForTLSServerAuth
(
PCCERT_CONTEXT
certificate
)
{
MOZ_ASSERT
(
certificate
)
;
if
(
!
certificate
)
{
return
false
;
}
PCCERT_CHAIN_CONTEXT
pChainContext
=
nullptr
;
CERT_ENHKEY_USAGE
enhkeyUsage
;
memset
(
&
enhkeyUsage
0
sizeof
(
CERT_ENHKEY_USAGE
)
)
;
LPSTR
identifiers
[
]
=
{
"
1
.
3
.
6
.
1
.
5
.
5
.
7
.
3
.
1
"
}
;
enhkeyUsage
.
cUsageIdentifier
=
ArrayLength
(
identifiers
)
;
enhkeyUsage
.
rgpszUsageIdentifier
=
identifiers
;
CERT_USAGE_MATCH
certUsage
;
memset
(
&
certUsage
0
sizeof
(
CERT_USAGE_MATCH
)
)
;
certUsage
.
dwType
=
USAGE_MATCH_TYPE_AND
;
certUsage
.
Usage
=
enhkeyUsage
;
CERT_CHAIN_PARA
chainPara
;
memset
(
&
chainPara
0
sizeof
(
CERT_CHAIN_PARA
)
)
;
chainPara
.
cbSize
=
sizeof
(
CERT_CHAIN_PARA
)
;
chainPara
.
RequestedUsage
=
certUsage
;
if
(
!
CertGetCertificateChain
(
nullptr
certificate
nullptr
nullptr
&
chainPara
0
nullptr
&
pChainContext
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CertGetCertificateChain
failed
"
)
)
;
return
false
;
}
bool
trusted
=
pChainContext
-
>
TrustStatus
.
dwErrorStatus
=
=
CERT_TRUST_NO_ERROR
;
bool
isRoot
=
pChainContext
-
>
cChain
=
=
1
;
CertFreeCertificateChain
(
pChainContext
)
;
if
(
trusted
&
&
isRoot
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
certificate
is
trust
anchor
for
TLS
server
auth
"
)
)
;
return
true
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
certificate
not
trust
anchor
for
TLS
server
auth
"
)
)
;
return
false
;
}
void
nsNSSComponent
:
:
UnloadEnterpriseRoots
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
UnloadEnterpriseRoots
"
)
)
;
if
(
!
mEnterpriseRoots
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
no
enterprise
roots
were
present
"
)
)
;
return
;
}
CERTCertTrust
trust
=
{
CERTDB_USER
0
0
}
;
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
mEnterpriseRoots
.
get
(
)
)
;
!
CERT_LIST_END
(
n
mEnterpriseRoots
.
get
(
)
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
if
(
!
n
|
|
!
n
-
>
cert
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
library
failure
:
CERTCertListNode
null
or
lacks
cert
"
)
)
;
continue
;
}
if
(
CERT_ChangeCertTrust
(
nullptr
n
-
>
cert
&
trust
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
untrust
certificate
for
TLS
server
auth
"
)
)
;
}
}
mEnterpriseRoots
=
nullptr
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
unloaded
enterprise
roots
"
)
)
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
GetEnterpriseRoots
(
nsIX509CertList
*
*
enterpriseRoots
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
NS_ENSURE_ARG_POINTER
(
enterpriseRoots
)
;
nsNSSShutDownPreventionLock
lock
;
if
(
!
mEnterpriseRoots
)
{
*
enterpriseRoots
=
nullptr
;
return
NS_OK
;
}
UniqueCERTCertList
enterpriseRootsCopy
(
nsNSSCertList
:
:
DupCertList
(
mEnterpriseRoots
lock
)
)
;
if
(
!
enterpriseRootsCopy
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIX509CertList
>
enterpriseRootsCertList
(
new
nsNSSCertList
(
Move
(
enterpriseRootsCopy
)
lock
)
)
;
if
(
!
enterpriseRootsCertList
)
{
return
NS_ERROR_FAILURE
;
}
enterpriseRootsCertList
.
forget
(
enterpriseRoots
)
;
return
NS_OK
;
}
#
endif
static
const
char
*
kEnterpriseRootModePref
=
"
security
.
enterprise_roots
.
enabled
"
;
void
nsNSSComponent
:
:
MaybeImportEnterpriseRoots
(
)
{
#
ifdef
XP_WIN
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
UnloadEnterpriseRoots
(
)
;
bool
importEnterpriseRoots
=
Preferences
:
:
GetBool
(
kEnterpriseRootModePref
false
)
;
if
(
!
importEnterpriseRoots
)
{
return
;
}
MOZ_ASSERT
(
!
mEnterpriseRoots
)
;
mEnterpriseRoots
.
reset
(
CERT_NewCertList
(
)
)
;
if
(
!
mEnterpriseRoots
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
allocate
a
new
CERTCertList
for
mEnterpriseRoots
"
)
)
;
return
;
}
ImportEnterpriseRootsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE
)
;
ImportEnterpriseRootsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
)
;
ImportEnterpriseRootsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
)
;
#
endif
}
#
ifdef
XP_WIN
void
nsNSSComponent
:
:
ImportEnterpriseRootsForLocation
(
DWORD
locationFlag
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
MOZ_ASSERT
(
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
"
unexpected
locationFlag
for
ImportEnterpriseRootsForLocation
"
)
;
if
(
!
(
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
)
)
{
return
;
}
DWORD
flags
=
locationFlag
|
CERT_STORE_OPEN_EXISTING_FLAG
|
CERT_STORE_READONLY_FLAG
;
ScopedCertStore
enterpriseRootStore
(
CertOpenStore
(
CERT_STORE_PROV_SYSTEM_REGISTRY_W
0
NULL
flags
kWindowsDefaultRootStoreName
)
)
;
if
(
!
enterpriseRootStore
.
get
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
open
enterprise
root
store
"
)
)
;
return
;
}
CERTCertTrust
trust
=
{
CERTDB_TRUSTED_CA
|
CERTDB_VALID_CA
|
CERTDB_USER
0
0
}
;
PCCERT_CONTEXT
certificate
=
nullptr
;
uint32_t
numImported
=
0
;
while
(
(
certificate
=
CertFindCertificateInStore
(
enterpriseRootStore
.
get
(
)
X509_ASN_ENCODING
0
CERT_FIND_ANY
nullptr
certificate
)
)
)
{
if
(
!
CertIsTrustAnchorForTLSServerAuth
(
certificate
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
cert
not
trust
anchor
for
TLS
server
auth
"
)
)
;
continue
;
}
UniqueCERTCertificate
nssCertificate
(
PCCERT_CONTEXTToCERTCertificate
(
certificate
)
)
;
if
(
!
nssCertificate
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
decode
certificate
"
)
)
;
continue
;
}
UniquePORTString
subjectName
(
CERT_GetCommonName
(
&
nssCertificate
-
>
subject
)
)
;
if
(
nsCRT
:
:
strcmp
(
subjectName
.
get
(
)
kMicrosoftFamilySafetyCN
)
=
=
0
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
Family
Safety
Root
"
)
)
;
continue
;
}
MOZ_ASSERT
(
mEnterpriseRoots
"
mEnterpriseRoots
unexpectedly
NULL
?
"
)
;
if
(
!
mEnterpriseRoots
)
{
return
;
}
if
(
CERT_AddCertToListTail
(
mEnterpriseRoots
.
get
(
)
nssCertificate
.
get
(
)
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
add
cert
to
list
"
)
)
;
continue
;
}
if
(
CERT_ChangeCertTrust
(
nullptr
nssCertificate
.
get
(
)
&
trust
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
trust
certificate
for
TLS
server
auth
"
)
)
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Imported
'
%
s
'
"
subjectName
.
get
(
)
)
)
;
numImported
+
+
;
Unused
<
<
nssCertificate
.
release
(
)
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
imported
%
u
roots
"
numImported
)
)
;
}
#
endif
void
nsNSSComponent
:
:
LoadLoadableRoots
(
)
{
nsNSSShutDownPreventionLock
locker
;
SECMODModule
*
RootsModule
=
nullptr
;
{
SECMODModuleList
*
list
;
SECMODListLock
*
lock
=
SECMOD_GetDefaultModuleListLock
(
)
;
if
(
!
lock
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Couldn
'
t
get
the
module
list
lock
can
'
t
install
loadable
roots
\
n
"
)
)
;
return
;
}
SECMOD_GetReadLock
(
lock
)
;
list
=
SECMOD_GetDefaultModuleList
(
)
;
while
(
!
RootsModule
&
&
list
)
{
SECMODModule
*
module
=
list
-
>
module
;
for
(
int
i
=
0
;
i
<
module
-
>
slotCount
;
i
+
+
)
{
PK11SlotInfo
*
slot
=
module
-
>
slots
[
i
]
;
if
(
PK11_IsPresent
(
slot
)
)
{
if
(
PK11_HasRootCerts
(
slot
)
)
{
RootsModule
=
SECMOD_ReferenceModule
(
module
)
;
break
;
}
}
}
list
=
list
-
>
next
;
}
SECMOD_ReleaseReadLock
(
lock
)
;
}
if
(
RootsModule
)
{
int32_t
modType
;
SECMOD_DeleteModule
(
RootsModule
-
>
commonName
&
modType
)
;
SECMOD_DestroyModule
(
RootsModule
)
;
RootsModule
=
nullptr
;
}
nsAutoString
modName
;
nsresult
rv
=
GetPIPNSSBundleString
(
"
RootCertModuleName
"
modName
)
;
if
(
NS_FAILED
(
rv
)
)
{
modName
.
AssignLiteral
(
"
Builtin
Roots
Module
"
)
;
}
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
)
;
if
(
!
directoryService
)
return
;
static
const
char
nss_lib
[
]
=
"
nss3
"
;
const
char
*
possible_ckbi_locations
[
]
=
{
nss_lib
NS_XPCOM_CURRENT_PROCESS_DIR
NS_GRE_DIR
0
}
;
for
(
size_t
il
=
0
;
il
<
sizeof
(
possible_ckbi_locations
)
/
sizeof
(
const
char
*
)
;
+
+
il
)
{
nsAutoCString
libDir
;
if
(
possible_ckbi_locations
[
il
]
)
{
nsCOMPtr
<
nsIFile
>
mozFile
;
if
(
possible_ckbi_locations
[
il
]
=
=
nss_lib
)
{
char
*
nss_path
=
PR_GetLibraryFilePathname
(
DLL_PREFIX
"
nss3
"
DLL_SUFFIX
(
PRFuncPtr
)
NSS_Initialize
)
;
if
(
!
nss_path
)
{
continue
;
}
nsCOMPtr
<
nsIFile
>
nssLib
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
nssLib
-
>
InitWithNativePath
(
nsDependentCString
(
nss_path
)
)
;
}
PR_Free
(
nss_path
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_SUCCEEDED
(
nssLib
-
>
GetParent
(
getter_AddRefs
(
file
)
)
)
)
{
mozFile
=
do_QueryInterface
(
file
)
;
}
}
}
else
{
directoryService
-
>
Get
(
possible_ckbi_locations
[
il
]
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
mozFile
)
)
;
}
if
(
!
mozFile
)
{
continue
;
}
if
(
NS_FAILED
(
mozFile
-
>
GetNativePath
(
libDir
)
)
)
{
continue
;
}
}
NS_ConvertUTF16toUTF8
modNameUTF8
(
modName
)
;
if
(
mozilla
:
:
psm
:
:
LoadLoadableRoots
(
libDir
modNameUTF8
)
)
{
break
;
}
}
}
void
nsNSSComponent
:
:
UnloadLoadableRoots
(
)
{
nsresult
rv
;
nsAutoString
modName
;
rv
=
GetPIPNSSBundleString
(
"
RootCertModuleName
"
modName
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
NS_ConvertUTF16toUTF8
modNameUTF8
(
modName
)
;
:
:
mozilla
:
:
psm
:
:
UnloadLoadableRoots
(
modNameUTF8
.
get
(
)
)
;
}
nsresult
nsNSSComponent
:
:
ConfigureInternalPKCS11Token
(
)
{
nsNSSShutDownPreventionLock
locker
;
nsAutoString
manufacturerID
;
nsAutoString
libraryDescription
;
nsAutoString
tokenDescription
;
nsAutoString
privateTokenDescription
;
nsAutoString
slotDescription
;
nsAutoString
privateSlotDescription
;
nsAutoString
fips140SlotDescription
;
nsAutoString
fips140TokenDescription
;
nsresult
rv
;
rv
=
GetPIPNSSBundleString
(
"
ManufacturerID
"
manufacturerID
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
GetPIPNSSBundleString
(
"
LibraryDescription
"
libraryDescription
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
GetPIPNSSBundleString
(
"
TokenDescription
"
tokenDescription
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
GetPIPNSSBundleString
(
"
PrivateTokenDescription
"
privateTokenDescription
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
GetPIPNSSBundleString
(
"
SlotDescription
"
slotDescription
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
GetPIPNSSBundleString
(
"
PrivateSlotDescription
"
privateSlotDescription
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
GetPIPNSSBundleString
(
"
Fips140SlotDescription
"
fips140SlotDescription
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
GetPIPNSSBundleString
(
"
Fips140TokenDescription
"
fips140TokenDescription
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
PK11_ConfigurePKCS11
(
NS_ConvertUTF16toUTF8
(
manufacturerID
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
libraryDescription
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
tokenDescription
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
privateTokenDescription
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
slotDescription
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
privateSlotDescription
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
fips140SlotDescription
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
fips140TokenDescription
)
.
get
(
)
0
0
)
;
return
NS_OK
;
}
nsresult
nsNSSComponent
:
:
InitializePIPNSSBundle
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIStringBundleService
>
bundleService
(
do_GetService
(
NS_STRINGBUNDLE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
bundleService
)
return
NS_ERROR_FAILURE
;
bundleService
-
>
CreateBundle
(
"
chrome
:
/
/
pipnss
/
locale
/
pipnss
.
properties
"
getter_AddRefs
(
mPIPNSSBundle
)
)
;
if
(
!
mPIPNSSBundle
)
rv
=
NS_ERROR_FAILURE
;
bundleService
-
>
CreateBundle
(
"
chrome
:
/
/
pipnss
/
locale
/
nsserrors
.
properties
"
getter_AddRefs
(
mNSSErrorsBundle
)
)
;
if
(
!
mNSSErrorsBundle
)
rv
=
NS_ERROR_FAILURE
;
return
rv
;
}
typedef
struct
{
const
char
*
pref
;
long
id
;
bool
enabledByDefault
;
}
CipherPref
;
static
const
CipherPref
sCipherPrefs
[
]
=
{
{
"
security
.
ssl3
.
ecdhe_rsa_aes_128_gcm_sha256
"
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_aes_128_gcm_sha256
"
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_chacha20_poly1305_sha256
"
TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
true
}
{
"
security
.
ssl3
.
ecdhe_rsa_chacha20_poly1305_sha256
"
TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_aes_256_gcm_sha384
"
TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
true
}
{
"
security
.
ssl3
.
ecdhe_rsa_aes_256_gcm_sha384
"
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
true
}
{
"
security
.
ssl3
.
ecdhe_rsa_aes_128_sha
"
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_aes_128_sha
"
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
true
}
{
"
security
.
ssl3
.
ecdhe_rsa_aes_256_sha
"
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_aes_256_sha
"
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
true
}
{
"
security
.
ssl3
.
dhe_rsa_aes_128_sha
"
TLS_DHE_RSA_WITH_AES_128_CBC_SHA
true
}
{
"
security
.
ssl3
.
dhe_rsa_aes_256_sha
"
TLS_DHE_RSA_WITH_AES_256_CBC_SHA
true
}
{
"
security
.
tls13
.
aes_128_gcm_sha256
"
TLS_AES_128_GCM_SHA256
true
}
{
"
security
.
tls13
.
chacha20_poly1305_sha256
"
TLS_CHACHA20_POLY1305_SHA256
true
}
{
"
security
.
tls13
.
aes_256_gcm_sha384
"
TLS_AES_256_GCM_SHA384
true
}
{
"
security
.
ssl3
.
rsa_aes_128_sha
"
TLS_RSA_WITH_AES_128_CBC_SHA
true
}
{
"
security
.
ssl3
.
rsa_aes_256_sha
"
TLS_RSA_WITH_AES_256_CBC_SHA
true
}
{
"
security
.
ssl3
.
rsa_des_ede3_sha
"
TLS_RSA_WITH_3DES_EDE_CBC_SHA
true
}
{
nullptr
0
}
}
;
void
nsNSSComponent
:
:
FillTLSVersionRange
(
SSLVersionRange
&
rangeOut
uint32_t
minFromPrefs
uint32_t
maxFromPrefs
SSLVersionRange
defaults
)
{
rangeOut
=
defaults
;
SSLVersionRange
supported
;
if
(
SSL_VersionRangeGetSupported
(
ssl_variant_stream
&
supported
)
!
=
SECSuccess
)
{
return
;
}
rangeOut
.
min
=
std
:
:
max
(
rangeOut
.
min
supported
.
min
)
;
rangeOut
.
max
=
std
:
:
min
(
rangeOut
.
max
supported
.
max
)
;
minFromPrefs
+
=
SSL_LIBRARY_VERSION_3_0
;
maxFromPrefs
+
=
SSL_LIBRARY_VERSION_3_0
;
if
(
minFromPrefs
>
maxFromPrefs
|
|
minFromPrefs
<
supported
.
min
|
|
maxFromPrefs
>
supported
.
max
|
|
minFromPrefs
<
SSL_LIBRARY_VERSION_TLS_1_0
)
{
return
;
}
rangeOut
.
min
=
(
uint16_t
)
minFromPrefs
;
rangeOut
.
max
=
(
uint16_t
)
maxFromPrefs
;
}
static
const
int32_t
OCSP_ENABLED_DEFAULT
=
1
;
static
const
bool
REQUIRE_SAFE_NEGOTIATION_DEFAULT
=
false
;
static
const
bool
FALSE_START_ENABLED_DEFAULT
=
true
;
static
const
bool
ALPN_ENABLED_DEFAULT
=
false
;
static
const
bool
ENABLED_0RTT_DATA_DEFAULT
=
false
;
static
void
ConfigureTLSSessionIdentifiers
(
)
{
bool
disableSessionIdentifiers
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
disable_session_identifiers
"
false
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_SESSION_TICKETS
!
disableSessionIdentifiers
)
;
SSL_OptionSetDefault
(
SSL_NO_CACHE
disableSessionIdentifiers
)
;
}
namespace
{
class
CipherSuiteChangeObserver
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
static
nsresult
StartObserve
(
)
;
protected
:
virtual
~
CipherSuiteChangeObserver
(
)
{
}
private
:
static
StaticRefPtr
<
CipherSuiteChangeObserver
>
sObserver
;
CipherSuiteChangeObserver
(
)
{
}
}
;
NS_IMPL_ISUPPORTS
(
CipherSuiteChangeObserver
nsIObserver
)
StaticRefPtr
<
CipherSuiteChangeObserver
>
CipherSuiteChangeObserver
:
:
sObserver
;
nsresult
CipherSuiteChangeObserver
:
:
StartObserve
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
CipherSuiteChangeObserver
:
:
StartObserve
(
)
can
only
be
accessed
"
"
on
the
main
thread
"
)
;
if
(
!
sObserver
)
{
RefPtr
<
CipherSuiteChangeObserver
>
observer
=
new
CipherSuiteChangeObserver
(
)
;
nsresult
rv
=
Preferences
:
:
AddStrongObserver
(
observer
.
get
(
)
"
security
.
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
sObserver
=
nullptr
;
return
rv
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
observerService
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
sObserver
=
observer
;
}
return
NS_OK
;
}
nsresult
CipherSuiteChangeObserver
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
someData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
CipherSuiteChangeObserver
:
:
Observe
can
only
be
accessed
on
main
"
"
thread
"
)
;
if
(
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
=
=
0
)
{
NS_ConvertUTF16toUTF8
prefName
(
someData
)
;
const
CipherPref
*
const
cp
=
sCipherPrefs
;
for
(
size_t
i
=
0
;
cp
[
i
]
.
pref
;
+
+
i
)
{
if
(
prefName
.
Equals
(
cp
[
i
]
.
pref
)
)
{
bool
cipherEnabled
=
Preferences
:
:
GetBool
(
cp
[
i
]
.
pref
cp
[
i
]
.
enabledByDefault
)
;
SSL_CipherPrefSetDefault
(
cp
[
i
]
.
id
cipherEnabled
)
;
SSL_ClearSessionCache
(
)
;
break
;
}
}
}
else
if
(
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
Preferences
:
:
RemoveObserver
(
this
"
security
.
"
)
;
MOZ_ASSERT
(
sObserver
.
get
(
)
=
=
this
)
;
sObserver
=
nullptr
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
observerService
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
return
NS_OK
;
}
}
void
nsNSSComponent
:
:
setValidationOptions
(
bool
isInitialSetting
const
MutexAutoLock
&
lock
)
{
int32_t
ocspEnabled
=
Preferences
:
:
GetInt
(
"
security
.
OCSP
.
enabled
"
OCSP_ENABLED_DEFAULT
)
;
bool
ocspRequired
=
ocspEnabled
&
&
Preferences
:
:
GetBool
(
"
security
.
OCSP
.
require
"
false
)
;
if
(
isInitialSetting
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_OCSP_ENABLED
ocspEnabled
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_OCSP_REQUIRED
ocspRequired
)
;
}
bool
ocspStaplingEnabled
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_ocsp_stapling
"
true
)
;
PublicSSLState
(
)
-
>
SetOCSPStaplingEnabled
(
ocspStaplingEnabled
)
;
PrivateSSLState
(
)
-
>
SetOCSPStaplingEnabled
(
ocspStaplingEnabled
)
;
bool
ocspMustStapleEnabled
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_ocsp_must_staple
"
true
)
;
PublicSSLState
(
)
-
>
SetOCSPMustStapleEnabled
(
ocspMustStapleEnabled
)
;
PrivateSSLState
(
)
-
>
SetOCSPMustStapleEnabled
(
ocspMustStapleEnabled
)
;
const
CertVerifier
:
:
CertificateTransparencyMode
defaultCTMode
=
CertVerifier
:
:
CertificateTransparencyMode
:
:
TelemetryOnly
;
CertVerifier
:
:
CertificateTransparencyMode
ctMode
=
static_cast
<
CertVerifier
:
:
CertificateTransparencyMode
>
(
Preferences
:
:
GetInt
(
"
security
.
pki
.
certificate_transparency
.
mode
"
static_cast
<
int32_t
>
(
defaultCTMode
)
)
)
;
switch
(
ctMode
)
{
case
CertVerifier
:
:
CertificateTransparencyMode
:
:
Disabled
:
case
CertVerifier
:
:
CertificateTransparencyMode
:
:
TelemetryOnly
:
break
;
default
:
ctMode
=
defaultCTMode
;
break
;
}
bool
sctsEnabled
=
ctMode
!
=
CertVerifier
:
:
CertificateTransparencyMode
:
:
Disabled
;
PublicSSLState
(
)
-
>
SetSignedCertTimestampsEnabled
(
sctsEnabled
)
;
PrivateSSLState
(
)
-
>
SetSignedCertTimestampsEnabled
(
sctsEnabled
)
;
CertVerifier
:
:
PinningMode
pinningMode
=
static_cast
<
CertVerifier
:
:
PinningMode
>
(
Preferences
:
:
GetInt
(
"
security
.
cert_pinning
.
enforcement_level
"
CertVerifier
:
:
pinningDisabled
)
)
;
if
(
pinningMode
>
CertVerifier
:
:
pinningEnforceTestMode
)
{
pinningMode
=
CertVerifier
:
:
pinningDisabled
;
}
CertVerifier
:
:
SHA1Mode
sha1Mode
=
static_cast
<
CertVerifier
:
:
SHA1Mode
>
(
Preferences
:
:
GetInt
(
"
security
.
pki
.
sha1_enforcement_level
"
static_cast
<
int32_t
>
(
CertVerifier
:
:
SHA1Mode
:
:
Allowed
)
)
)
;
switch
(
sha1Mode
)
{
case
CertVerifier
:
:
SHA1Mode
:
:
Allowed
:
case
CertVerifier
:
:
SHA1Mode
:
:
Forbidden
:
case
CertVerifier
:
:
SHA1Mode
:
:
UsedToBeBefore2016ButNowIsForbidden
:
case
CertVerifier
:
:
SHA1Mode
:
:
ImportedRoot
:
case
CertVerifier
:
:
SHA1Mode
:
:
ImportedRootOrBefore2016
:
break
;
default
:
sha1Mode
=
CertVerifier
:
:
SHA1Mode
:
:
Allowed
;
break
;
}
if
(
sha1Mode
=
=
CertVerifier
:
:
SHA1Mode
:
:
UsedToBeBefore2016ButNowIsForbidden
)
{
sha1Mode
=
CertVerifier
:
:
SHA1Mode
:
:
Forbidden
;
}
BRNameMatchingPolicy
:
:
Mode
nameMatchingMode
=
static_cast
<
BRNameMatchingPolicy
:
:
Mode
>
(
Preferences
:
:
GetInt
(
"
security
.
pki
.
name_matching_mode
"
static_cast
<
int32_t
>
(
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
)
)
)
;
switch
(
nameMatchingMode
)
{
case
BRNameMatchingPolicy
:
:
Mode
:
:
Enforce
:
case
BRNameMatchingPolicy
:
:
Mode
:
:
EnforceAfter23August2015
:
case
BRNameMatchingPolicy
:
:
Mode
:
:
EnforceAfter23August2016
:
case
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
:
break
;
default
:
nameMatchingMode
=
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
;
break
;
}
NetscapeStepUpPolicy
netscapeStepUpPolicy
=
static_cast
<
NetscapeStepUpPolicy
>
(
Preferences
:
:
GetUint
(
"
security
.
pki
.
netscape_step_up_policy
"
static_cast
<
uint32_t
>
(
NetscapeStepUpPolicy
:
:
AlwaysMatch
)
)
)
;
switch
(
netscapeStepUpPolicy
)
{
case
NetscapeStepUpPolicy
:
:
AlwaysMatch
:
case
NetscapeStepUpPolicy
:
:
MatchBefore23August2016
:
case
NetscapeStepUpPolicy
:
:
MatchBefore23August2015
:
case
NetscapeStepUpPolicy
:
:
NeverMatch
:
break
;
default
:
netscapeStepUpPolicy
=
NetscapeStepUpPolicy
:
:
AlwaysMatch
;
break
;
}
CertVerifier
:
:
OcspDownloadConfig
odc
;
CertVerifier
:
:
OcspStrictConfig
osc
;
CertVerifier
:
:
OcspGetConfig
ogc
;
uint32_t
certShortLifetimeInDays
;
GetRevocationBehaviorFromPrefs
(
&
odc
&
osc
&
ogc
&
certShortLifetimeInDays
lock
)
;
mDefaultCertVerifier
=
new
SharedCertVerifier
(
odc
osc
ogc
certShortLifetimeInDays
pinningMode
sha1Mode
nameMatchingMode
netscapeStepUpPolicy
ctMode
)
;
}
nsresult
nsNSSComponent
:
:
setEnabledTLSVersions
(
)
{
static
const
uint32_t
PSM_DEFAULT_MIN_TLS_VERSION
=
1
;
static
const
uint32_t
PSM_DEFAULT_MAX_TLS_VERSION
=
4
;
uint32_t
minFromPrefs
=
Preferences
:
:
GetUint
(
"
security
.
tls
.
version
.
min
"
PSM_DEFAULT_MIN_TLS_VERSION
)
;
uint32_t
maxFromPrefs
=
Preferences
:
:
GetUint
(
"
security
.
tls
.
version
.
max
"
PSM_DEFAULT_MAX_TLS_VERSION
)
;
SSLVersionRange
defaults
=
{
SSL_LIBRARY_VERSION_3_0
+
PSM_DEFAULT_MIN_TLS_VERSION
SSL_LIBRARY_VERSION_3_0
+
PSM_DEFAULT_MAX_TLS_VERSION
}
;
SSLVersionRange
filledInRange
;
FillTLSVersionRange
(
filledInRange
minFromPrefs
maxFromPrefs
defaults
)
;
SECStatus
srv
=
SSL_VersionRangeSetDefault
(
ssl_variant_stream
&
filledInRange
)
;
if
(
srv
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
nsresult
GetNSSProfilePath
(
nsAutoCString
&
aProfilePath
)
{
aProfilePath
.
Truncate
(
)
;
const
char
*
dbDirOverride
=
getenv
(
"
MOZPSM_NSSDBDIR_OVERRIDE
"
)
;
if
(
dbDirOverride
&
&
strlen
(
dbDirOverride
)
>
0
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Using
specified
MOZPSM_NSSDBDIR_OVERRIDE
as
NSS
DB
dir
:
%
s
\
n
"
dbDirOverride
)
)
;
aProfilePath
.
Assign
(
dbDirOverride
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
profileFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profileFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NSS
will
be
initialized
without
a
profile
directory
.
"
"
Some
things
may
not
work
as
expected
.
"
)
;
return
NS_OK
;
}
#
if
defined
(
XP_WIN
)
nsCOMPtr
<
nsILocalFileWin
>
profileFileWin
(
do_QueryInterface
(
profileFile
)
)
;
if
(
!
profileFileWin
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Could
not
get
nsILocalFileWin
for
profile
directory
.
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
profileFileWin
-
>
GetNativeCanonicalPath
(
aProfilePath
)
;
#
else
rv
=
profileFile
-
>
GetNativePath
(
aProfilePath
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Could
not
get
native
path
for
profile
directory
.
\
n
"
)
)
;
return
rv
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
NSS
profile
at
'
%
s
'
\
n
"
aProfilePath
.
get
(
)
)
)
;
return
NS_OK
;
}
nsresult
nsNSSComponent
:
:
InitializeNSS
(
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
InitializeNSS
\
n
"
)
)
;
static_assert
(
nsINSSErrorsService
:
:
NSS_SEC_ERROR_BASE
=
=
SEC_ERROR_BASE
&
&
nsINSSErrorsService
:
:
NSS_SEC_ERROR_LIMIT
=
=
SEC_ERROR_LIMIT
&
&
nsINSSErrorsService
:
:
NSS_SSL_ERROR_BASE
=
=
SSL_ERROR_BASE
&
&
nsINSSErrorsService
:
:
NSS_SSL_ERROR_LIMIT
=
=
SSL_ERROR_LIMIT
"
You
must
update
the
values
in
nsINSSErrorsService
.
idl
"
)
;
MutexAutoLock
lock
(
mutex
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
NSS
Initialization
beginning
\
n
"
)
)
;
ConfigureInternalPKCS11Token
(
)
;
nsAutoCString
profileStr
;
nsresult
rv
=
GetNSSProfilePath
(
profileStr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
SECStatus
init_rv
=
SECFailure
;
bool
nocertdb
=
Preferences
:
:
GetBool
(
"
security
.
nocertdb
"
false
)
;
bool
inSafeMode
=
true
;
nsCOMPtr
<
nsIXULRuntime
>
runtime
(
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
)
;
if
(
runtime
)
{
rv
=
runtime
-
>
GetInSafeMode
(
&
inSafeMode
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
inSafeMode
:
%
u
\
n
"
inSafeMode
)
)
;
PRErrorCode
savedPRErrorCode1
=
0
;
PRErrorCode
savedPRErrorCode2
=
0
;
if
(
!
nocertdb
&
&
!
profileStr
.
IsEmpty
(
)
)
{
init_rv
=
:
:
mozilla
:
:
psm
:
:
InitializeNSS
(
profileStr
.
get
(
)
false
!
inSafeMode
)
;
if
(
init_rv
!
=
SECSuccess
)
{
savedPRErrorCode1
=
PR_GetError
(
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
could
not
init
NSS
r
/
w
in
%
s
\
n
"
profileStr
.
get
(
)
)
)
;
init_rv
=
:
:
mozilla
:
:
psm
:
:
InitializeNSS
(
profileStr
.
get
(
)
true
!
inSafeMode
)
;
}
if
(
init_rv
!
=
SECSuccess
)
{
savedPRErrorCode2
=
PR_GetError
(
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
could
not
init
in
r
/
o
either
\
n
"
)
)
;
}
}
if
(
nocertdb
|
|
init_rv
!
=
SECSuccess
)
{
init_rv
=
NSS_NoDB_Init
(
nullptr
)
;
if
(
init_rv
!
=
SECSuccess
)
{
PRErrorCode
savedPRErrorCode3
=
PR_GetError
(
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
NSS
initialization
failed
PRErrorCodes
%
d
%
d
%
d
"
savedPRErrorCode1
savedPRErrorCode2
savedPRErrorCode3
)
;
}
}
if
(
init_rv
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
could
not
initialize
NSS
-
panicking
\
n
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
mContentSigningRootHash
=
Preferences
:
:
GetString
(
"
security
.
content
.
signature
.
root_hash
"
)
;
PK11_SetPasswordFunc
(
PK11PasswordPrompt
)
;
SharedSSLState
:
:
GlobalInit
(
)
;
Preferences
:
:
AddStrongObserver
(
this
"
security
.
"
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_SSL2
false
)
;
SSL_OptionSetDefault
(
SSL_V2_COMPATIBLE_HELLO
false
)
;
rv
=
setEnabledTLSVersions
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
DisableMD5
(
)
;
LoadLoadableRoots
(
)
;
rv
=
LoadExtendedValidationInfo
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
failed
to
load
EV
info
"
)
)
;
return
rv
;
}
MaybeEnableFamilySafetyCompatibility
(
)
;
MaybeImportEnterpriseRoots
(
)
;
ConfigureTLSSessionIdentifiers
(
)
;
bool
requireSafeNegotiation
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
require_safe_negotiation
"
REQUIRE_SAFE_NEGOTIATION_DEFAULT
)
;
SSL_OptionSetDefault
(
SSL_REQUIRE_SAFE_NEGOTIATION
requireSafeNegotiation
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_RENEGOTIATION
SSL_RENEGOTIATE_REQUIRES_XTN
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_EXTENDED_MASTER_SECRET
true
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_FALSE_START
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_false_start
"
FALSE_START_ENABLED_DEFAULT
)
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_ALPN
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_alpn
"
ALPN_ENABLED_DEFAULT
)
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_0RTT_DATA
Preferences
:
:
GetBool
(
"
security
.
tls
.
enable_0rtt_data
"
ENABLED_0RTT_DATA_DEFAULT
)
)
;
if
(
NS_FAILED
(
InitializeCipherSuite
(
)
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Unable
to
initialize
cipher
suite
settings
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
SSL_ConfigServerSessionIDCache
(
1000
0
0
nullptr
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
setValidationOptions
(
true
lock
)
;
#
ifndef
MOZ_NO_SMART_CARDS
LaunchSmartCardThreads
(
)
;
#
endif
mozilla
:
:
pkix
:
:
RegisterErrorTable
(
)
;
if
(
PK11_IsFIPS
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FIPS_ENABLED
true
)
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
NSS
Initialization
done
\
n
"
)
)
;
mNSSInitialized
=
true
;
return
NS_OK
;
}
void
nsNSSComponent
:
:
ShutdownNSS
(
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
ShutdownNSS
\
n
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mutex
)
;
if
(
mNSSInitialized
)
{
mNSSInitialized
=
false
;
PK11_SetPasswordFunc
(
(
PK11PasswordFunc
)
nullptr
)
;
Preferences
:
:
RemoveObserver
(
this
"
security
.
"
)
;
#
ifdef
XP_WIN
mFamilySafetyRoot
=
nullptr
;
mEnterpriseRoots
=
nullptr
;
#
endif
#
ifndef
MOZ_NO_SMART_CARDS
ShutdownSmartCardThreads
(
)
;
#
endif
SSL_ClearSessionCache
(
)
;
Unused
<
<
SSL_ShutdownServerSessionIDCache
(
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
evaporating
psm
resources
"
)
)
;
if
(
NS_FAILED
(
nsNSSShutDownList
:
:
evaporateAllNSSResourcesAndShutDown
(
)
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
failed
to
evaporate
resources
"
)
)
;
return
;
}
UnloadLoadableRoots
(
)
;
if
(
SECSuccess
!
=
:
:
NSS_Shutdown
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
NSS
SHUTDOWN
FAILURE
"
)
)
;
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
NSS
shutdown
=
=
=
=
=
>
>
OK
<
<
=
=
=
=
=
"
)
)
;
}
}
}
nsresult
nsNSSComponent
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Beginning
NSS
initialization
\
n
"
)
)
;
nsresult
rv
=
InitializePIPNSSBundle
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Unable
to
create
pipnss
bundle
.
\
n
"
)
)
;
return
rv
;
}
{
const
char16_t
*
dummy
=
u
"
dummy
"
;
nsXPIDLString
result
;
mPIPNSSBundle
-
>
GetStringFromName
(
dummy
getter_Copies
(
result
)
)
;
mNSSErrorsBundle
-
>
GetStringFromName
(
dummy
getter_Copies
(
result
)
)
;
}
rv
=
InitializeNSS
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
nsNSSComponent
:
:
InitializeNSS
(
)
failed
\
n
"
)
)
;
return
rv
;
}
RememberCertErrorsTable
:
:
Init
(
)
;
return
RegisterObservers
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsNSSComponent
nsINSSComponent
nsIObserver
)
static
const
char
*
const
PROFILE_BEFORE_CHANGE_TOPIC
=
"
profile
-
before
-
change
"
;
NS_IMETHODIMP
nsNSSComponent
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
nsCRT
:
:
strcmp
(
aTopic
PROFILE_BEFORE_CHANGE_TOPIC
)
=
=
0
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
receiving
profile
change
topic
\
n
"
)
)
;
ShutdownNSS
(
)
;
}
else
if
(
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
=
=
0
)
{
nsNSSShutDownPreventionLock
locker
;
bool
clearSessionCache
=
true
;
NS_ConvertUTF16toUTF8
prefName
(
someData
)
;
if
(
prefName
.
EqualsLiteral
(
"
security
.
tls
.
version
.
min
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
tls
.
version
.
max
"
)
)
{
(
void
)
setEnabledTLSVersions
(
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
require_safe_negotiation
"
)
)
{
bool
requireSafeNegotiation
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
require_safe_negotiation
"
REQUIRE_SAFE_NEGOTIATION_DEFAULT
)
;
SSL_OptionSetDefault
(
SSL_REQUIRE_SAFE_NEGOTIATION
requireSafeNegotiation
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
enable_false_start
"
)
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_FALSE_START
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_false_start
"
FALSE_START_ENABLED_DEFAULT
)
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
enable_alpn
"
)
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_ALPN
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_alpn
"
ALPN_ENABLED_DEFAULT
)
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
tls
.
enable_0rtt_data
"
)
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_0RTT_DATA
Preferences
:
:
GetBool
(
"
security
.
tls
.
enable_0rtt_data
"
ENABLED_0RTT_DATA_DEFAULT
)
)
;
}
else
if
(
prefName
.
Equals
(
"
security
.
ssl
.
disable_session_identifiers
"
)
)
{
ConfigureTLSSessionIdentifiers
(
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
OCSP
.
enabled
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
OCSP
.
require
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
OCSP
.
GET
.
enabled
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
cert_short_lifetime_in_days
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
enable_ocsp_stapling
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
enable_ocsp_must_staple
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
certificate_transparency
.
mode
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
cert_pinning
.
enforcement_level
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
sha1_enforcement_level
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
name_matching_mode
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
netscape_step_up_policy
"
)
)
{
MutexAutoLock
lock
(
mutex
)
;
setValidationOptions
(
false
lock
)
;
#
ifdef
DEBUG
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
test
.
built_in_root_hash
"
)
)
{
MutexAutoLock
lock
(
mutex
)
;
mTestBuiltInRootHash
=
Preferences
:
:
GetString
(
"
security
.
test
.
built_in_root_hash
"
)
;
#
endif
}
else
if
(
prefName
.
Equals
(
kFamilySafetyModePref
)
)
{
MaybeEnableFamilySafetyCompatibility
(
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
content
.
signature
.
root_hash
"
)
)
{
MutexAutoLock
lock
(
mutex
)
;
mContentSigningRootHash
=
Preferences
:
:
GetString
(
"
security
.
content
.
signature
.
root_hash
"
)
;
}
else
if
(
prefName
.
Equals
(
kEnterpriseRootModePref
)
)
{
MaybeImportEnterpriseRoots
(
)
;
}
else
{
clearSessionCache
=
false
;
}
if
(
clearSessionCache
)
SSL_ClearSessionCache
(
)
;
}
return
NS_OK
;
}
nsresult
nsNSSComponent
:
:
GetNewPrompter
(
nsIPrompt
*
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
*
result
=
nullptr
;
if
(
!
NS_IsMainThread
(
)
)
{
NS_ERROR
(
"
nsSDRContext
:
:
GetNewPrompter
called
off
the
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
nsresult
rv
;
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
(
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
wwatch
-
>
GetNewPrompter
(
0
result
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
nsresult
nsNSSComponent
:
:
LogoutAuthenticatedPK11
(
)
{
nsCOMPtr
<
nsICertOverrideService
>
icos
=
do_GetService
(
"
mozilla
.
org
/
security
/
certoverride
;
1
"
)
;
if
(
icos
)
{
icos
-
>
ClearValidityOverride
(
NS_LITERAL_CSTRING
(
"
all
:
temporary
-
certificates
"
)
0
)
;
}
nsClientAuthRememberService
:
:
ClearAllRememberedDecisions
(
)
;
return
nsNSSShutDownList
:
:
doPK11Logout
(
)
;
}
nsresult
nsNSSComponent
:
:
RegisterObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
(
do_GetService
(
"
mozilla
.
org
/
observer
-
service
;
1
"
)
)
;
if
(
!
observerService
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
couldn
'
t
get
observer
service
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
adding
observers
\
n
"
)
)
;
observerService
-
>
AddObserver
(
this
PROFILE_BEFORE_CHANGE_TOPIC
false
)
;
return
NS_OK
;
}
#
ifdef
DEBUG
NS_IMETHODIMP
nsNSSComponent
:
:
IsCertTestBuiltInRoot
(
CERTCertificate
*
cert
bool
&
result
)
{
MutexAutoLock
lock
(
mutex
)
;
MOZ_ASSERT
(
mNSSInitialized
)
;
result
=
false
;
if
(
mTestBuiltInRootHash
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsNSSCertificate
>
nsc
=
nsNSSCertificate
:
:
Create
(
cert
)
;
if
(
!
nsc
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
certHash
;
nsresult
rv
=
nsc
-
>
GetSha256Fingerprint
(
certHash
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
result
=
mTestBuiltInRootHash
.
Equals
(
certHash
)
;
return
NS_OK
;
}
#
endif
NS_IMETHODIMP
nsNSSComponent
:
:
IsCertContentSigningRoot
(
CERTCertificate
*
cert
bool
&
result
)
{
MutexAutoLock
lock
(
mutex
)
;
MOZ_ASSERT
(
mNSSInitialized
)
;
result
=
false
;
if
(
mContentSigningRootHash
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
mContentSigningRootHash
is
empty
"
)
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsNSSCertificate
>
nsc
=
nsNSSCertificate
:
:
Create
(
cert
)
;
if
(
!
nsc
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
creating
nsNSSCertificate
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoString
certHash
;
nsresult
rv
=
nsc
-
>
GetSha256Fingerprint
(
certHash
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
getting
cert
fingerprint
failed
"
)
)
;
return
rv
;
}
result
=
mContentSigningRootHash
.
Equals
(
certHash
)
;
return
NS_OK
;
}
SharedCertVerifier
:
:
~
SharedCertVerifier
(
)
{
}
already_AddRefed
<
SharedCertVerifier
>
nsNSSComponent
:
:
GetDefaultCertVerifier
(
)
{
MutexAutoLock
lock
(
mutex
)
;
MOZ_ASSERT
(
mNSSInitialized
)
;
RefPtr
<
SharedCertVerifier
>
certVerifier
(
mDefaultCertVerifier
)
;
return
certVerifier
.
forget
(
)
;
}
namespace
mozilla
{
namespace
psm
{
already_AddRefed
<
SharedCertVerifier
>
GetDefaultCertVerifier
(
)
{
static
NS_DEFINE_CID
(
kNSSComponentCID
NS_NSSCOMPONENT_CID
)
;
nsCOMPtr
<
nsINSSComponent
>
nssComponent
(
do_GetService
(
kNSSComponentCID
)
)
;
if
(
nssComponent
)
{
return
nssComponent
-
>
GetDefaultCertVerifier
(
)
;
}
return
nullptr
;
}
}
}
NS_IMPL_ISUPPORTS
(
PipUIContext
nsIInterfaceRequestor
)
PipUIContext
:
:
PipUIContext
(
)
{
}
PipUIContext
:
:
~
PipUIContext
(
)
{
}
NS_IMETHODIMP
PipUIContext
:
:
GetInterface
(
const
nsIID
&
uuid
void
*
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
*
result
=
nullptr
;
if
(
!
NS_IsMainThread
(
)
)
{
NS_ERROR
(
"
PipUIContext
:
:
GetInterface
called
off
the
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
!
uuid
.
Equals
(
NS_GET_IID
(
nsIPrompt
)
)
)
return
NS_ERROR_NO_INTERFACE
;
nsIPrompt
*
prompt
=
nullptr
;
nsresult
rv
=
nsNSSComponent
:
:
GetNewPrompter
(
&
prompt
)
;
*
result
=
prompt
;
return
rv
;
}
nsresult
getNSSDialogs
(
void
*
*
_result
REFNSIID
aIID
const
char
*
contract
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_ERROR
(
"
getNSSDialogs
called
off
the
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
svc
=
do_GetService
(
contract
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
svc
-
>
QueryInterface
(
aIID
_result
)
;
return
rv
;
}
nsresult
setPassword
(
PK11SlotInfo
*
slot
nsIInterfaceRequestor
*
ctx
nsNSSShutDownPreventionLock
&
)
{
MOZ_ASSERT
(
slot
)
;
MOZ_ASSERT
(
ctx
)
;
NS_ENSURE_ARG_POINTER
(
slot
)
;
NS_ENSURE_ARG_POINTER
(
ctx
)
;
if
(
PK11_NeedUserInit
(
slot
)
)
{
nsCOMPtr
<
nsITokenPasswordDialogs
>
dialogs
;
nsresult
rv
=
getNSSDialogs
(
getter_AddRefs
(
dialogs
)
NS_GET_IID
(
nsITokenPasswordDialogs
)
NS_TOKENPASSWORDSDIALOG_CONTRACTID
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
canceled
;
NS_ConvertUTF8toUTF16
tokenName
(
PK11_GetTokenName
(
slot
)
)
;
rv
=
dialogs
-
>
SetPassword
(
ctx
tokenName
&
canceled
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
canceled
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
return
NS_OK
;
}
namespace
mozilla
{
namespace
psm
{
nsresult
InitializeCipherSuite
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
InitializeCipherSuite
(
)
can
only
be
accessed
on
the
main
thread
"
)
;
if
(
NSS_SetDomesticPolicy
(
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
for
(
uint16_t
i
=
0
;
i
<
SSL_NumImplementedCiphers
;
+
+
i
)
{
uint16_t
cipher_id
=
SSL_ImplementedCiphers
[
i
]
;
SSL_CipherPrefSetDefault
(
cipher_id
false
)
;
}
const
CipherPref
*
const
cp
=
sCipherPrefs
;
for
(
size_t
i
=
0
;
cp
[
i
]
.
pref
;
+
+
i
)
{
bool
cipherEnabled
=
Preferences
:
:
GetBool
(
cp
[
i
]
.
pref
cp
[
i
]
.
enabledByDefault
)
;
SSL_CipherPrefSetDefault
(
cp
[
i
]
.
id
cipherEnabled
)
;
}
SEC_PKCS12EnableCipher
(
PKCS12_RC4_40
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_RC4_128
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_RC2_CBC_40
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_RC2_CBC_128
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_DES_56
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_DES_EDE3_168
1
)
;
SEC_PKCS12SetPreferredCipher
(
PKCS12_DES_EDE3_168
1
)
;
PORT_SetUCS2_ASCIIConversionFunction
(
pip_ucs2_ascii_conversion_fn
)
;
NSS_OptionSet
(
NSS_RSA_MIN_KEY_SIZE
512
)
;
return
CipherSuiteChangeObserver
:
:
StartObserve
(
)
;
}
}
}
