#
include
"
nsNSSComponent
.
h
"
#
include
"
BinaryPath
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
EnterpriseRoots
.
h
"
#
include
"
ExtendedValidation
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
SSLTokensCache
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
SharedSSLState
.
h
"
#
include
"
cert
.
h
"
#
include
"
cert_storage
/
src
/
cert_storage
.
h
"
#
include
"
certdb
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
FilePreferences
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
PublicSSL
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessParent
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsClientAuthRemember
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsICertOverrideService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsILocalFileWin
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsITokenPasswordDialogs
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNSSCertificateDB
.
h
"
#
include
"
nsNSSHelper
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsPK11TokenDB
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nss
.
h
"
#
include
"
p12plcy
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
prmem
.
h
"
#
include
"
secerr
.
h
"
#
include
"
secmod
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslerr
.
h
"
#
include
"
sslproto
.
h
"
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
#
include
<
linux
/
magic
.
h
>
#
include
<
sys
/
vfs
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsILocalFileWin
.
h
"
#
include
"
windows
.
h
"
#
include
"
lmcons
.
h
"
#
include
"
sddl
.
h
"
#
include
"
wincrypt
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
psm
;
LazyLogModule
gPIPNSSLog
(
"
pipnss
"
)
;
int
nsNSSComponent
:
:
mInstanceCount
=
0
;
nsresult
CommonInit
(
)
;
nsresult
FileToCString
(
const
nsCOMPtr
<
nsIFile
>
&
file
nsACString
&
result
)
{
#
ifdef
XP_WIN
nsCOMPtr
<
nsILocalFileWin
>
fileWin
=
do_QueryInterface
(
file
)
;
if
(
!
fileWin
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
get
nsILocalFileWin
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
fileWin
-
>
GetNativeCanonicalPath
(
result
)
;
#
else
return
file
-
>
GetNativePath
(
result
)
;
#
endif
}
void
TruncateFromLastDirectorySeparator
(
nsCString
&
path
)
{
static
const
nsAutoCString
kSeparatorString
(
mozilla
:
:
FilePreferences
:
:
kPathSeparator
)
;
int32_t
index
=
path
.
RFind
(
kSeparatorString
)
;
if
(
index
=
=
kNotFound
)
{
return
;
}
path
.
Truncate
(
index
)
;
}
bool
LoadIPCClientCerts
(
)
{
UniqueFreePtr
<
char
>
pluginContainerPath
(
BinaryPath
:
:
Get
(
)
)
;
if
(
!
pluginContainerPath
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
get
get
plugin
-
container
path
"
)
)
;
return
false
;
}
nsAutoCString
ipcClientCertsDirString
(
pluginContainerPath
.
get
(
)
)
;
TruncateFromLastDirectorySeparator
(
ipcClientCertsDirString
)
;
#
ifdef
XP_MACOSX
TruncateFromLastDirectorySeparator
(
ipcClientCertsDirString
)
;
TruncateFromLastDirectorySeparator
(
ipcClientCertsDirString
)
;
TruncateFromLastDirectorySeparator
(
ipcClientCertsDirString
)
;
#
endif
if
(
!
LoadIPCClientCertsModule
(
ipcClientCertsDirString
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
load
ipcclientcerts
from
'
%
s
'
"
ipcClientCertsDirString
.
get
(
)
)
)
;
return
false
;
}
return
true
;
}
bool
EnsureNSSInitializedChromeOrContent
(
)
{
static
Atomic
<
bool
>
initialized
(
false
)
;
if
(
initialized
)
{
return
true
;
}
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
mozilla
:
:
SyncRunnable
:
:
DispatchToThread
(
mainThread
new
SyncRunnable
(
NS_NewRunnableFunction
(
"
EnsureNSSInitializedChromeOrContent
"
[
]
(
)
{
EnsureNSSInitializedChromeOrContent
(
)
;
}
)
)
)
;
return
initialized
;
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsISupports
>
nss
=
do_GetService
(
PSM_COMPONENT_CONTRACTID
)
;
if
(
!
nss
)
{
return
false
;
}
initialized
=
true
;
return
true
;
}
if
(
NSS_IsInitialized
(
)
)
{
initialized
=
true
;
return
true
;
}
if
(
NSS_NoDB_Init
(
nullptr
)
!
=
SECSuccess
)
{
return
false
;
}
if
(
XRE_IsSocketProcess
(
)
)
{
if
(
NS_FAILED
(
CommonInit
(
)
)
)
{
return
false
;
}
Unused
<
<
NS_WARN_IF
(
!
LoadIPCClientCerts
(
)
)
;
initialized
=
true
;
return
true
;
}
if
(
NS_FAILED
(
mozilla
:
:
psm
:
:
InitializeCipherSuite
(
)
)
)
{
return
false
;
}
mozilla
:
:
psm
:
:
DisableMD5
(
)
;
mozilla
:
:
pkix
:
:
RegisterErrorTable
(
)
;
initialized
=
true
;
return
true
;
}
static
const
uint32_t
OCSP_TIMEOUT_MILLISECONDS_SOFT_DEFAULT
=
2000
;
static
const
uint32_t
OCSP_TIMEOUT_MILLISECONDS_SOFT_MAX
=
5000
;
static
const
uint32_t
OCSP_TIMEOUT_MILLISECONDS_HARD_DEFAULT
=
10000
;
static
const
uint32_t
OCSP_TIMEOUT_MILLISECONDS_HARD_MAX
=
20000
;
void
nsNSSComponent
:
:
GetRevocationBehaviorFromPrefs
(
CertVerifier
:
:
OcspDownloadConfig
*
odc
CertVerifier
:
:
OcspStrictConfig
*
osc
uint32_t
*
certShortLifetimeInDays
TimeDuration
&
softTimeout
TimeDuration
&
hardTimeout
const
MutexAutoLock
&
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
odc
)
;
MOZ_ASSERT
(
osc
)
;
MOZ_ASSERT
(
certShortLifetimeInDays
)
;
int32_t
ocspLevel
=
Preferences
:
:
GetInt
(
"
security
.
OCSP
.
enabled
"
1
)
;
switch
(
ocspLevel
)
{
case
0
:
*
odc
=
CertVerifier
:
:
ocspOff
;
break
;
case
2
:
*
odc
=
CertVerifier
:
:
ocspEVOnly
;
break
;
default
:
*
odc
=
CertVerifier
:
:
ocspOn
;
break
;
}
*
osc
=
Preferences
:
:
GetBool
(
"
security
.
OCSP
.
require
"
false
)
?
CertVerifier
:
:
ocspStrict
:
CertVerifier
:
:
ocspRelaxed
;
*
certShortLifetimeInDays
=
Preferences
:
:
GetUint
(
"
security
.
pki
.
cert_short_lifetime_in_days
"
static_cast
<
uint32_t
>
(
0
)
)
;
uint32_t
softTimeoutMillis
=
Preferences
:
:
GetUint
(
"
security
.
OCSP
.
timeoutMilliseconds
.
soft
"
OCSP_TIMEOUT_MILLISECONDS_SOFT_DEFAULT
)
;
softTimeoutMillis
=
std
:
:
min
(
softTimeoutMillis
OCSP_TIMEOUT_MILLISECONDS_SOFT_MAX
)
;
softTimeout
=
TimeDuration
:
:
FromMilliseconds
(
softTimeoutMillis
)
;
uint32_t
hardTimeoutMillis
=
Preferences
:
:
GetUint
(
"
security
.
OCSP
.
timeoutMilliseconds
.
hard
"
OCSP_TIMEOUT_MILLISECONDS_HARD_DEFAULT
)
;
hardTimeoutMillis
=
std
:
:
min
(
hardTimeoutMillis
OCSP_TIMEOUT_MILLISECONDS_HARD_MAX
)
;
hardTimeout
=
TimeDuration
:
:
FromMilliseconds
(
hardTimeoutMillis
)
;
}
nsNSSComponent
:
:
nsNSSComponent
(
)
:
mLoadableCertsLoadedMonitor
(
"
nsNSSComponent
.
mLoadableCertsLoadedMonitor
"
)
mLoadableCertsLoaded
(
false
)
mLoadableCertsLoadedResult
(
NS_ERROR_FAILURE
)
mMutex
(
"
nsNSSComponent
.
mMutex
"
)
mMitmDetecionEnabled
(
false
)
mLoadLoadableCertsTaskDispatched
(
false
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
ctor
\
n
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mInstanceCount
=
=
0
"
nsNSSComponent
is
a
singleton
but
instantiated
multiple
times
!
"
)
;
+
+
mInstanceCount
;
}
nsNSSComponent
:
:
~
nsNSSComponent
(
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
dtor
\
n
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
ShutdownNSS
(
)
;
SharedSSLState
:
:
GlobalCleanup
(
)
;
RememberCertErrorsTable
:
:
Cleanup
(
)
;
-
-
mInstanceCount
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
dtor
finished
\
n
"
)
)
;
}
#
ifdef
XP_WIN
static
bool
GetUserSid
(
nsAString
&
sidString
)
{
WCHAR
lpAccountName
[
UNLEN
+
1
]
;
DWORD
lcAccountName
=
sizeof
(
lpAccountName
)
/
sizeof
(
lpAccountName
[
0
]
)
;
BOOL
success
=
GetUserName
(
lpAccountName
&
lcAccountName
)
;
if
(
!
success
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
GetUserName
failed
"
)
)
;
return
false
;
}
char
sid_buffer
[
SECURITY_MAX_SID_SIZE
]
;
SID
*
sid
=
BitwiseCast
<
SID
*
char
*
>
(
sid_buffer
)
;
DWORD
cbSid
=
ArrayLength
(
sid_buffer
)
;
SID_NAME_USE
eUse
;
DWORD
cchReferencedDomainName
=
128
;
auto
ReferencedDomainName
(
MakeUnique
<
WCHAR
[
]
>
(
cchReferencedDomainName
)
)
;
success
=
LookupAccountName
(
nullptr
lpAccountName
sid
&
cbSid
ReferencedDomainName
.
get
(
)
&
cchReferencedDomainName
&
eUse
)
;
if
(
!
success
&
&
GetLastError
(
)
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
LookupAccountName
failed
"
)
)
;
return
false
;
}
if
(
!
success
)
{
ReferencedDomainName
=
MakeUnique
<
WCHAR
[
]
>
(
cchReferencedDomainName
)
;
success
=
LookupAccountName
(
nullptr
lpAccountName
sid
&
cbSid
ReferencedDomainName
.
get
(
)
&
cchReferencedDomainName
&
eUse
)
;
}
if
(
!
success
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
LookupAccountName
failed
"
)
)
;
return
false
;
}
LPTSTR
StringSid
;
success
=
ConvertSidToStringSid
(
sid
&
StringSid
)
;
if
(
!
success
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
ConvertSidToStringSid
failed
"
)
)
;
return
false
;
}
sidString
.
Assign
(
StringSid
)
;
LocalFree
(
StringSid
)
;
return
true
;
}
static
nsresult
ReadRegKeyValueWithDefault
(
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
uint32_t
flags
const
wchar_t
*
optionalChildName
const
wchar_t
*
valueName
uint32_t
defaultValue
uint32_t
&
valueOut
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
ReadRegKeyValueWithDefault
"
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
attempting
to
read
'
%
S
%
s
%
S
'
with
default
'
%
u
'
"
optionalChildName
?
optionalChildName
:
L
"
"
optionalChildName
?
"
\
\
"
:
"
"
valueName
defaultValue
)
)
;
if
(
optionalChildName
)
{
nsDependentString
childNameString
(
optionalChildName
)
;
bool
hasChild
;
nsresult
rv
=
regKey
-
>
HasChild
(
childNameString
&
hasChild
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
determine
if
child
key
is
present
"
)
)
;
return
rv
;
}
if
(
!
hasChild
)
{
valueOut
=
defaultValue
;
return
NS_OK
;
}
nsCOMPtr
<
nsIWindowsRegKey
>
childRegKey
;
rv
=
regKey
-
>
OpenChild
(
childNameString
flags
getter_AddRefs
(
childRegKey
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
open
child
key
"
)
)
;
return
rv
;
}
return
ReadRegKeyValueWithDefault
(
childRegKey
flags
nullptr
valueName
defaultValue
valueOut
)
;
}
nsDependentString
valueNameString
(
valueName
)
;
bool
hasValue
;
nsresult
rv
=
regKey
-
>
HasValue
(
valueNameString
&
hasValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
determine
if
value
is
present
"
)
)
;
return
rv
;
}
if
(
!
hasValue
)
{
valueOut
=
defaultValue
;
return
NS_OK
;
}
rv
=
regKey
-
>
ReadIntValue
(
valueNameString
&
valueOut
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
read
value
"
)
)
;
return
rv
;
}
return
NS_OK
;
}
static
nsresult
AccountHasFamilySafetyEnabled
(
bool
&
enabled
)
{
enabled
=
false
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
AccountHasFamilySafetyEnabled
?
"
)
)
;
nsCOMPtr
<
nsIWindowsRegKey
>
parentalControlsKey
(
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
)
;
if
(
!
parentalControlsKey
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
create
nsIWindowsRegKey
"
)
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
flags
=
nsIWindowsRegKey
:
:
ACCESS_READ
|
nsIWindowsRegKey
:
:
WOW64_64
;
constexpr
auto
familySafetyPath
=
u
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Parental
Controls
"
_ns
;
nsresult
rv
=
parentalControlsKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_LOCAL_MACHINE
familySafetyPath
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
open
parentalControlsKey
"
)
)
;
return
rv
;
}
constexpr
auto
usersString
=
u
"
Users
"
_ns
;
bool
hasUsers
;
rv
=
parentalControlsKey
-
>
HasChild
(
usersString
&
hasUsers
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HasChild
(
Users
)
failed
"
)
)
;
return
rv
;
}
if
(
!
hasUsers
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Users
subkey
not
present
-
Parental
Controls
not
enabled
"
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIWindowsRegKey
>
usersKey
;
rv
=
parentalControlsKey
-
>
OpenChild
(
usersString
flags
getter_AddRefs
(
usersKey
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
open
Users
subkey
"
)
)
;
return
rv
;
}
nsAutoString
sid
;
if
(
!
GetUserSid
(
sid
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
get
sid
"
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
our
sid
is
'
%
S
'
"
sid
.
get
(
)
)
)
;
bool
hasSid
;
rv
=
usersKey
-
>
HasChild
(
sid
&
hasSid
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HasChild
(
sid
)
failed
"
)
)
;
return
rv
;
}
if
(
!
hasSid
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
sid
not
present
in
Family
Safety
Users
"
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIWindowsRegKey
>
sidKey
;
rv
=
usersKey
-
>
OpenChild
(
sid
flags
getter_AddRefs
(
sidKey
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
open
sid
key
"
)
)
;
return
rv
;
}
uint32_t
parentalControlsOn
;
rv
=
sidKey
-
>
ReadIntValue
(
u
"
Parental
Controls
On
"
_ns
&
parentalControlsOn
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
read
Parental
Controls
On
"
)
)
;
return
rv
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Parental
Controls
On
:
%
u
"
parentalControlsOn
)
)
;
if
(
parentalControlsOn
!
=
1
)
{
return
NS_OK
;
}
uint32_t
loggingRequired
;
rv
=
ReadRegKeyValueWithDefault
(
sidKey
flags
nullptr
L
"
Logging
Required
"
1
loggingRequired
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
read
value
of
Logging
Required
"
)
)
;
return
rv
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Logging
Required
:
%
u
"
loggingRequired
)
)
;
uint32_t
webFilterOn
;
rv
=
ReadRegKeyValueWithDefault
(
sidKey
flags
L
"
Web
"
L
"
Filter
On
"
0
webFilterOn
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
read
value
of
Web
\
\
Filter
On
"
)
)
;
return
rv
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Web
\
\
Filter
On
:
%
u
"
webFilterOn
)
)
;
enabled
=
loggingRequired
=
=
1
|
|
webFilterOn
=
=
1
;
return
NS_OK
;
}
#
endif
const
char
*
kFamilySafetyModePref
=
"
security
.
family_safety
.
mode
"
;
const
uint32_t
kFamilySafetyModeDefault
=
0
;
bool
nsNSSComponent
:
:
ShouldEnableEnterpriseRootsForFamilySafety
(
uint32_t
familySafetyMode
)
{
#
ifdef
XP_WIN
if
(
!
(
IsWin8Point1OrLater
(
)
&
&
!
IsWin10OrLater
(
)
)
)
{
return
false
;
}
if
(
familySafetyMode
!
=
2
)
{
return
false
;
}
bool
familySafetyEnabled
;
nsresult
rv
=
AccountHasFamilySafetyEnabled
(
familySafetyEnabled
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
familySafetyEnabled
;
#
else
return
false
;
#
endif
}
void
nsNSSComponent
:
:
UnloadEnterpriseRoots
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
UnloadEnterpriseRoots
"
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mEnterpriseCerts
.
clear
(
)
;
setValidationOptions
(
false
lock
)
;
ClearSSLExternalAndInternalSessionCache
(
)
;
}
static
const
char
*
kEnterpriseRootModePref
=
"
security
.
enterprise_roots
.
enabled
"
;
static
const
char
*
kOSClientCertsModulePref
=
"
security
.
osclientcerts
.
autoload
"
;
class
BackgroundImportEnterpriseCertsTask
final
:
public
CryptoTask
{
public
:
explicit
BackgroundImportEnterpriseCertsTask
(
nsNSSComponent
*
nssComponent
)
:
mNSSComponent
(
nssComponent
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
{
mNSSComponent
-
>
ImportEnterpriseRoots
(
)
;
mNSSComponent
-
>
UpdateCertVerifierWithEnterpriseRoots
(
)
;
return
NS_OK
;
}
virtual
void
CallCallback
(
nsresult
rv
)
override
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
nullptr
"
psm
:
enterprise
-
certs
-
imported
"
nullptr
)
;
}
}
RefPtr
<
nsNSSComponent
>
mNSSComponent
;
}
;
void
nsNSSComponent
:
:
MaybeImportEnterpriseRoots
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
bool
importEnterpriseRoots
=
Preferences
:
:
GetBool
(
kEnterpriseRootModePref
false
)
;
uint32_t
familySafetyMode
=
Preferences
:
:
GetUint
(
kFamilySafetyModePref
kFamilySafetyModeDefault
)
;
if
(
ShouldEnableEnterpriseRootsForFamilySafety
(
familySafetyMode
)
)
{
importEnterpriseRoots
=
true
;
}
if
(
importEnterpriseRoots
)
{
RefPtr
<
BackgroundImportEnterpriseCertsTask
>
task
=
new
BackgroundImportEnterpriseCertsTask
(
this
)
;
Unused
<
<
task
-
>
Dispatch
(
)
;
}
}
void
nsNSSComponent
:
:
ImportEnterpriseRoots
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
return
;
}
Vector
<
EnterpriseCert
>
enterpriseCerts
;
nsresult
rv
=
GatherEnterpriseCerts
(
enterpriseCerts
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
mEnterpriseCerts
=
std
:
:
move
(
enterpriseCerts
)
;
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
gathering
enterprise
roots
"
)
)
;
}
}
nsresult
nsNSSComponent
:
:
CommonGetEnterpriseCerts
(
nsTArray
<
nsTArray
<
uint8_t
>
>
&
enterpriseCerts
bool
getRoots
)
{
nsresult
rv
=
BlockUntilLoadableCertsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MutexAutoLock
nsNSSComponentLock
(
mMutex
)
;
enterpriseCerts
.
Clear
(
)
;
for
(
const
auto
&
cert
:
mEnterpriseCerts
)
{
nsTArray
<
uint8_t
>
certCopy
;
if
(
cert
.
GetIsRoot
(
)
=
=
getRoots
)
{
nsresult
rv
=
cert
.
CopyBytes
(
certCopy
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
enterpriseCerts
.
AppendElement
(
std
:
:
move
(
certCopy
)
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
GetEnterpriseRoots
(
nsTArray
<
nsTArray
<
uint8_t
>
>
&
enterpriseRoots
)
{
return
CommonGetEnterpriseCerts
(
enterpriseRoots
true
)
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
GetEnterpriseIntermediates
(
nsTArray
<
nsTArray
<
uint8_t
>
>
&
enterpriseIntermediates
)
{
return
CommonGetEnterpriseCerts
(
enterpriseIntermediates
false
)
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
AddEnterpriseIntermediate
(
const
nsTArray
<
uint8_t
>
&
intermediateBytes
)
{
nsresult
rv
=
BlockUntilLoadableCertsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
EnterpriseCert
intermediate
;
rv
=
intermediate
.
Init
(
intermediateBytes
.
Elements
(
)
intermediateBytes
.
Length
(
)
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
{
MutexAutoLock
nsNSSComponentLock
(
mMutex
)
;
if
(
!
mEnterpriseCerts
.
append
(
std
:
:
move
(
intermediate
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
UpdateCertVerifierWithEnterpriseRoots
(
)
;
return
NS_OK
;
}
class
LoadLoadableCertsTask
final
:
public
Runnable
{
public
:
LoadLoadableCertsTask
(
nsNSSComponent
*
nssComponent
bool
importEnterpriseRoots
uint32_t
familySafetyMode
Vector
<
nsCString
>
&
&
possibleLoadableRootsLocations
Maybe
<
nsCString
>
&
&
osClientCertsModuleLocation
)
:
Runnable
(
"
LoadLoadableCertsTask
"
)
mNSSComponent
(
nssComponent
)
mImportEnterpriseRoots
(
importEnterpriseRoots
)
mFamilySafetyMode
(
familySafetyMode
)
mPossibleLoadableRootsLocations
(
std
:
:
move
(
possibleLoadableRootsLocations
)
)
mOSClientCertsModuleLocation
(
std
:
:
move
(
osClientCertsModuleLocation
)
)
{
MOZ_ASSERT
(
nssComponent
)
;
}
~
LoadLoadableCertsTask
(
)
=
default
;
nsresult
Dispatch
(
)
;
private
:
NS_IMETHOD
Run
(
)
override
;
nsresult
LoadLoadableRoots
(
)
;
RefPtr
<
nsNSSComponent
>
mNSSComponent
;
bool
mImportEnterpriseRoots
;
uint32_t
mFamilySafetyMode
;
Vector
<
nsCString
>
mPossibleLoadableRootsLocations
;
Maybe
<
nsCString
>
mOSClientCertsModuleLocation
;
}
;
nsresult
LoadLoadableCertsTask
:
:
Dispatch
(
)
{
nsCOMPtr
<
nsIEventTarget
>
target
(
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
)
;
if
(
!
target
)
{
return
NS_ERROR_FAILURE
;
}
return
target
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
LoadLoadableCertsTask
:
:
Run
(
)
{
Telemetry
:
:
AutoScalarTimer
<
Telemetry
:
:
ScalarID
:
:
NETWORKING_LOADING_CERTS_TASK
>
timer
;
nsresult
loadLoadableRootsResult
=
LoadLoadableRoots
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
loadLoadableRootsResult
)
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
LoadLoadableRoots
failed
"
)
)
;
}
if
(
NS_SUCCEEDED
(
loadLoadableRootsResult
)
)
{
if
(
NS_FAILED
(
LoadExtendedValidationInfo
(
)
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
failed
to
load
EV
info
"
)
)
;
}
}
if
(
mNSSComponent
-
>
ShouldEnableEnterpriseRootsForFamilySafety
(
mFamilySafetyMode
)
)
{
mImportEnterpriseRoots
=
true
;
}
if
(
mImportEnterpriseRoots
)
{
mNSSComponent
-
>
ImportEnterpriseRoots
(
)
;
mNSSComponent
-
>
UpdateCertVerifierWithEnterpriseRoots
(
)
;
}
if
(
mOSClientCertsModuleLocation
.
isSome
(
)
)
{
bool
success
=
LoadOSClientCertsModule
(
*
mOSClientCertsModuleLocation
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
loading
OS
client
certs
module
%
s
"
success
?
"
succeeded
"
:
"
failed
"
)
)
;
}
{
MonitorAutoLock
rootsLoadedLock
(
mNSSComponent
-
>
mLoadableCertsLoadedMonitor
)
;
mNSSComponent
-
>
mLoadableCertsLoaded
=
true
;
mNSSComponent
-
>
mLoadableCertsLoadedResult
=
loadLoadableRootsResult
;
mNSSComponent
-
>
mLoadableCertsLoadedMonitor
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
static
nsresult
GetDirectoryPath
(
const
char
*
directoryKey
nsCString
&
result
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
)
;
if
(
!
directoryService
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
could
not
get
directory
service
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIFile
>
directory
;
nsresult
rv
=
directoryService
-
>
Get
(
directoryKey
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
directory
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
could
not
get
'
%
s
'
from
directory
service
"
directoryKey
)
)
;
return
rv
;
}
return
FileToCString
(
directory
result
)
;
}
class
BackgroundLoadOSClientCertsModuleTask
final
:
public
CryptoTask
{
public
:
explicit
BackgroundLoadOSClientCertsModuleTask
(
const
nsCString
&
&
libraryDir
)
:
mLibraryDir
(
std
:
:
move
(
libraryDir
)
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
{
bool
success
=
LoadOSClientCertsModule
(
mLibraryDir
)
;
return
success
?
NS_OK
:
NS_ERROR_FAILURE
;
}
virtual
void
CallCallback
(
nsresult
rv
)
override
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
loading
OS
client
certs
module
%
s
"
NS_SUCCEEDED
(
rv
)
?
"
succeeded
"
:
"
failed
"
)
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
nullptr
"
psm
:
load
-
os
-
client
-
certs
-
module
-
task
-
ran
"
nullptr
)
;
}
}
nsCString
mLibraryDir
;
}
;
void
AsyncLoadOrUnloadOSClientCertsModule
(
bool
load
)
{
if
(
load
)
{
nsCString
libraryDir
;
nsresult
rv
=
GetDirectoryPath
(
NS_GRE_BIN_DIR
libraryDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
RefPtr
<
BackgroundLoadOSClientCertsModuleTask
>
task
=
new
BackgroundLoadOSClientCertsModuleTask
(
std
:
:
move
(
libraryDir
)
)
;
Unused
<
<
task
-
>
Dispatch
(
)
;
}
else
{
UniqueSECMODModule
osClientCertsModule
(
SECMOD_FindModule
(
kOSClientCertsModuleName
)
)
;
if
(
osClientCertsModule
)
{
SECMOD_UnloadUserModule
(
osClientCertsModule
.
get
(
)
)
;
}
}
}
NS_IMETHODIMP
nsNSSComponent
:
:
HasActiveSmartCards
(
bool
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
BlockUntilLoadableCertsLoaded
(
)
;
#
ifndef
MOZ_NO_SMART_CARDS
AutoSECMODListReadLock
secmodLock
;
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
while
(
list
)
{
SECMODModule
*
module
=
list
-
>
module
;
if
(
SECMOD_HasRemovableSlots
(
module
)
)
{
*
result
=
true
;
return
NS_OK
;
}
for
(
int
i
=
0
;
i
<
module
-
>
slotCount
;
i
+
+
)
{
if
(
!
PK11_IsFriendly
(
module
-
>
slots
[
i
]
)
)
{
*
result
=
true
;
return
NS_OK
;
}
}
list
=
list
-
>
next
;
}
#
endif
*
result
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
HasUserCertsInstalled
(
bool
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
UniqueCERTCertList
certList
(
FindClientCertificatesWithPrivateKeys
(
)
)
;
*
result
=
!
!
certList
;
return
NS_OK
;
}
nsresult
nsNSSComponent
:
:
BlockUntilLoadableCertsLoaded
(
)
{
MonitorAutoLock
rootsLoadedLock
(
mLoadableCertsLoadedMonitor
)
;
while
(
!
mLoadableCertsLoaded
)
{
rootsLoadedLock
.
Wait
(
)
;
}
MOZ_ASSERT
(
mLoadableCertsLoaded
)
;
return
mLoadableCertsLoadedResult
;
}
#
ifndef
MOZ_NO_SMART_CARDS
static
StaticMutex
sCheckForSmartCardChangesMutex
;
static
TimeStamp
sLastCheckedForSmartCardChanges
=
TimeStamp
:
:
Now
(
)
;
#
endif
nsresult
nsNSSComponent
:
:
CheckForSmartCardChanges
(
)
{
#
ifndef
MOZ_NO_SMART_CARDS
{
StaticMutexAutoLock
lock
(
sCheckForSmartCardChangesMutex
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
now
-
sLastCheckedForSmartCardChanges
<
TimeDuration
:
:
FromSeconds
(
3
.
0
)
)
{
return
NS_OK
;
}
sLastCheckedForSmartCardChanges
=
now
;
}
Vector
<
UniqueSECMODModule
>
modulesWithRemovableSlots
;
{
AutoSECMODListReadLock
secmodLock
;
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
while
(
list
)
{
if
(
SECMOD_HasRemovableSlots
(
list
-
>
module
)
)
{
UniqueSECMODModule
module
(
SECMOD_ReferenceModule
(
list
-
>
module
)
)
;
if
(
!
modulesWithRemovableSlots
.
append
(
std
:
:
move
(
module
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
list
=
list
-
>
next
;
}
}
for
(
auto
&
module
:
modulesWithRemovableSlots
)
{
Unused
<
<
SECMOD_UpdateSlotList
(
module
.
get
(
)
)
;
}
AutoSECMODListReadLock
secmodLock
;
for
(
auto
&
module
:
modulesWithRemovableSlots
)
{
for
(
int
i
=
0
;
i
<
module
-
>
slotCount
;
i
+
+
)
{
Unused
<
<
PK11_IsPresent
(
module
-
>
slots
[
i
]
)
;
}
}
#
endif
return
NS_OK
;
}
static
nsresult
GetNSS3Directory
(
nsCString
&
result
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
UniquePRString
nss3Path
(
PR_GetLibraryFilePathname
(
MOZ_DLL_PREFIX
"
nss3
"
MOZ_DLL_SUFFIX
reinterpret_cast
<
PRFuncPtr
>
(
NSS_Initialize
)
)
)
;
if
(
!
nss3Path
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nss
not
loaded
?
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIFile
>
nss3File
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
)
)
;
if
(
!
nss3File
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
create
a
file
?
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoCString
nss3PathAsString
(
nss3Path
.
get
(
)
)
;
nsresult
rv
=
nss3File
-
>
InitWithNativePath
(
nss3PathAsString
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
initialize
file
with
path
'
%
s
'
"
nss3Path
.
get
(
)
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIFile
>
nss3Directory
;
rv
=
nss3File
-
>
GetParent
(
getter_AddRefs
(
nss3Directory
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
get
parent
directory
?
"
)
)
;
return
rv
;
}
return
FileToCString
(
nss3Directory
result
)
;
}
static
nsresult
ListPossibleLoadableRootsLocations
(
Vector
<
nsCString
>
&
possibleLoadableRootsLocations
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
nsAutoCString
nss3Dir
;
nsresult
rv
=
GetNSS3Directory
(
nss3Dir
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
!
possibleLoadableRootsLocations
.
append
(
std
:
:
move
(
nss3Dir
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
could
not
determine
where
nss
was
loaded
from
"
)
)
;
}
nsAutoCString
currentProcessDir
;
rv
=
GetDirectoryPath
(
NS_XPCOM_CURRENT_PROCESS_DIR
currentProcessDir
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
!
possibleLoadableRootsLocations
.
append
(
std
:
:
move
(
currentProcessDir
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
could
not
get
current
process
directory
"
)
)
;
}
nsAutoCString
greDir
;
rv
=
GetDirectoryPath
(
NS_GRE_DIR
greDir
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
!
possibleLoadableRootsLocations
.
append
(
std
:
:
move
(
greDir
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
could
not
get
gre
directory
"
)
)
;
}
nsAutoCString
emptyString
;
if
(
!
possibleLoadableRootsLocations
.
append
(
std
:
:
move
(
emptyString
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
nsresult
LoadLoadableCertsTask
:
:
LoadLoadableRoots
(
)
{
for
(
const
auto
&
possibleLocation
:
mPossibleLoadableRootsLocations
)
{
if
(
mozilla
:
:
psm
:
:
LoadLoadableRoots
(
possibleLocation
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
loaded
CKBI
from
%
s
"
possibleLocation
.
get
(
)
)
)
;
return
NS_OK
;
}
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
could
not
load
loadable
roots
"
)
)
;
return
NS_ERROR_FAILURE
;
}
typedef
struct
{
const
char
*
pref
;
int32_t
id
;
bool
enabledByDefault
;
}
CipherPref
;
static
const
CipherPref
sCipherPrefs
[
]
=
{
{
"
security
.
ssl3
.
ecdhe_rsa_aes_128_gcm_sha256
"
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_aes_128_gcm_sha256
"
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_chacha20_poly1305_sha256
"
TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
true
}
{
"
security
.
ssl3
.
ecdhe_rsa_chacha20_poly1305_sha256
"
TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_aes_256_gcm_sha384
"
TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
true
}
{
"
security
.
ssl3
.
ecdhe_rsa_aes_256_gcm_sha384
"
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
true
}
{
"
security
.
ssl3
.
ecdhe_rsa_aes_128_sha
"
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_aes_128_sha
"
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
true
}
{
"
security
.
ssl3
.
ecdhe_rsa_aes_256_sha
"
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
true
}
{
"
security
.
ssl3
.
ecdhe_ecdsa_aes_256_sha
"
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
true
}
{
"
security
.
ssl3
.
dhe_rsa_aes_128_sha
"
TLS_DHE_RSA_WITH_AES_128_CBC_SHA
false
}
{
"
security
.
ssl3
.
dhe_rsa_aes_256_sha
"
TLS_DHE_RSA_WITH_AES_256_CBC_SHA
false
}
{
"
security
.
tls13
.
aes_128_gcm_sha256
"
TLS_AES_128_GCM_SHA256
true
}
{
"
security
.
tls13
.
chacha20_poly1305_sha256
"
TLS_CHACHA20_POLY1305_SHA256
true
}
{
"
security
.
tls13
.
aes_256_gcm_sha384
"
TLS_AES_256_GCM_SHA384
true
}
{
"
security
.
ssl3
.
rsa_aes_128_gcm_sha256
"
TLS_RSA_WITH_AES_128_GCM_SHA256
true
}
{
"
security
.
ssl3
.
rsa_aes_256_gcm_sha384
"
TLS_RSA_WITH_AES_256_GCM_SHA384
true
}
{
"
security
.
ssl3
.
rsa_aes_128_sha
"
TLS_RSA_WITH_AES_128_CBC_SHA
true
}
{
"
security
.
ssl3
.
rsa_aes_256_sha
"
TLS_RSA_WITH_AES_256_CBC_SHA
true
}
}
;
static
const
CipherPref
sDeprecatedTLS1CipherPrefs
[
]
=
{
{
"
security
.
ssl3
.
deprecated
.
rsa_des_ede3_sha
"
TLS_RSA_WITH_3DES_EDE_CBC_SHA
true
}
}
;
void
nsNSSComponent
:
:
FillTLSVersionRange
(
SSLVersionRange
&
rangeOut
uint32_t
minFromPrefs
uint32_t
maxFromPrefs
SSLVersionRange
defaults
)
{
rangeOut
=
defaults
;
SSLVersionRange
supported
;
if
(
SSL_VersionRangeGetSupported
(
ssl_variant_stream
&
supported
)
!
=
SECSuccess
)
{
return
;
}
rangeOut
.
min
=
std
:
:
max
(
rangeOut
.
min
supported
.
min
)
;
rangeOut
.
max
=
std
:
:
min
(
rangeOut
.
max
supported
.
max
)
;
minFromPrefs
+
=
SSL_LIBRARY_VERSION_3_0
;
maxFromPrefs
+
=
SSL_LIBRARY_VERSION_3_0
;
if
(
minFromPrefs
>
maxFromPrefs
|
|
minFromPrefs
<
supported
.
min
|
|
maxFromPrefs
>
supported
.
max
|
|
minFromPrefs
<
SSL_LIBRARY_VERSION_TLS_1_0
)
{
return
;
}
rangeOut
.
min
=
(
uint16_t
)
minFromPrefs
;
rangeOut
.
max
=
(
uint16_t
)
maxFromPrefs
;
}
static
const
int32_t
OCSP_ENABLED_DEFAULT
=
1
;
static
const
bool
REQUIRE_SAFE_NEGOTIATION_DEFAULT
=
false
;
static
const
bool
FALSE_START_ENABLED_DEFAULT
=
true
;
static
const
bool
ALPN_ENABLED_DEFAULT
=
false
;
static
const
bool
ENABLED_0RTT_DATA_DEFAULT
=
false
;
static
const
bool
HELLO_DOWNGRADE_CHECK_DEFAULT
=
true
;
static
const
bool
ENABLED_POST_HANDSHAKE_AUTH_DEFAULT
=
false
;
static
const
bool
DELEGATED_CREDENTIALS_ENABLED_DEFAULT
=
false
;
static
void
ConfigureTLSSessionIdentifiers
(
)
{
bool
disableSessionIdentifiers
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
disable_session_identifiers
"
false
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_SESSION_TICKETS
!
disableSessionIdentifiers
)
;
SSL_OptionSetDefault
(
SSL_NO_CACHE
disableSessionIdentifiers
)
;
}
nsresult
CommonInit
(
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_SSL2
false
)
;
SSL_OptionSetDefault
(
SSL_V2_COMPATIBLE_HELLO
false
)
;
nsresult
rv
=
nsNSSComponent
:
:
SetEnabledTLSVersions
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ConfigureTLSSessionIdentifiers
(
)
;
bool
requireSafeNegotiation
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
require_safe_negotiation
"
REQUIRE_SAFE_NEGOTIATION_DEFAULT
)
;
SSL_OptionSetDefault
(
SSL_REQUIRE_SAFE_NEGOTIATION
requireSafeNegotiation
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_RENEGOTIATION
SSL_RENEGOTIATE_REQUIRES_XTN
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_EXTENDED_MASTER_SECRET
true
)
;
bool
enableDowngradeCheck
=
Preferences
:
:
GetBool
(
"
security
.
tls
.
hello_downgrade_check
"
HELLO_DOWNGRADE_CHECK_DEFAULT
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_HELLO_DOWNGRADE_CHECK
enableDowngradeCheck
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_FALSE_START
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_false_start
"
FALSE_START_ENABLED_DEFAULT
)
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_ALPN
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_alpn
"
ALPN_ENABLED_DEFAULT
)
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_0RTT_DATA
Preferences
:
:
GetBool
(
"
security
.
tls
.
enable_0rtt_data
"
ENABLED_0RTT_DATA_DEFAULT
)
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_POST_HANDSHAKE_AUTH
Preferences
:
:
GetBool
(
"
security
.
tls
.
enable_post_handshake_auth
"
ENABLED_POST_HANDSHAKE_AUTH_DEFAULT
)
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_DELEGATED_CREDENTIALS
Preferences
:
:
GetBool
(
"
security
.
tls
.
enable_delegated_credentials
"
DELEGATED_CREDENTIALS_ENABLED_DEFAULT
)
)
;
rv
=
InitializeCipherSuite
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Unable
to
initialize
cipher
suite
settings
\
n
"
)
)
;
return
rv
;
}
DisableMD5
(
)
;
mozilla
:
:
pkix
:
:
RegisterErrorTable
(
)
;
SharedSSLState
:
:
GlobalInit
(
)
;
RememberCertErrorsTable
:
:
Init
(
)
;
SetValidationOptionsCommon
(
)
;
return
NS_OK
;
}
void
NSSShutdownForSocketProcess
(
)
{
MOZ_ASSERT
(
XRE_IsSocketProcess
(
)
)
;
SharedSSLState
:
:
GlobalCleanup
(
)
;
RememberCertErrorsTable
:
:
Cleanup
(
)
;
}
bool
HandleTLSPrefChange
(
const
nsCString
&
prefName
)
{
bool
prefFound
=
true
;
if
(
prefName
.
EqualsLiteral
(
"
security
.
tls
.
version
.
min
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
tls
.
version
.
max
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
tls
.
version
.
enable
-
deprecated
"
)
)
{
(
void
)
nsNSSComponent
:
:
SetEnabledTLSVersions
(
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
tls
.
hello_downgrade_check
"
)
)
{
bool
enableDowngradeCheck
=
Preferences
:
:
GetBool
(
"
security
.
tls
.
hello_downgrade_check
"
HELLO_DOWNGRADE_CHECK_DEFAULT
)
;
SSL_OptionSetDefault
(
SSL_ENABLE_HELLO_DOWNGRADE_CHECK
enableDowngradeCheck
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
require_safe_negotiation
"
)
)
{
bool
requireSafeNegotiation
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
require_safe_negotiation
"
REQUIRE_SAFE_NEGOTIATION_DEFAULT
)
;
SSL_OptionSetDefault
(
SSL_REQUIRE_SAFE_NEGOTIATION
requireSafeNegotiation
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
enable_false_start
"
)
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_FALSE_START
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_false_start
"
FALSE_START_ENABLED_DEFAULT
)
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
enable_alpn
"
)
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_ALPN
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_alpn
"
ALPN_ENABLED_DEFAULT
)
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
tls
.
enable_0rtt_data
"
)
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_0RTT_DATA
Preferences
:
:
GetBool
(
"
security
.
tls
.
enable_0rtt_data
"
ENABLED_0RTT_DATA_DEFAULT
)
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
tls
.
enable_post_handshake_auth
"
)
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_POST_HANDSHAKE_AUTH
Preferences
:
:
GetBool
(
"
security
.
tls
.
enable_post_handshake_auth
"
ENABLED_POST_HANDSHAKE_AUTH_DEFAULT
)
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
tls
.
enable_delegated_credentials
"
)
)
{
SSL_OptionSetDefault
(
SSL_ENABLE_DELEGATED_CREDENTIALS
Preferences
:
:
GetBool
(
"
security
.
tls
.
enable_delegated_credentials
"
DELEGATED_CREDENTIALS_ENABLED_DEFAULT
)
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
disable_session_identifiers
"
)
)
{
ConfigureTLSSessionIdentifiers
(
)
;
}
else
{
prefFound
=
false
;
}
return
prefFound
;
}
void
SetValidationOptionsCommon
(
)
{
bool
ocspStaplingEnabled
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_ocsp_stapling
"
true
)
;
PublicSSLState
(
)
-
>
SetOCSPStaplingEnabled
(
ocspStaplingEnabled
)
;
PrivateSSLState
(
)
-
>
SetOCSPStaplingEnabled
(
ocspStaplingEnabled
)
;
bool
ocspMustStapleEnabled
=
Preferences
:
:
GetBool
(
"
security
.
ssl
.
enable_ocsp_must_staple
"
true
)
;
PublicSSLState
(
)
-
>
SetOCSPMustStapleEnabled
(
ocspMustStapleEnabled
)
;
PrivateSSLState
(
)
-
>
SetOCSPMustStapleEnabled
(
ocspMustStapleEnabled
)
;
const
CertVerifier
:
:
CertificateTransparencyMode
defaultCTMode
=
CertVerifier
:
:
CertificateTransparencyMode
:
:
TelemetryOnly
;
CertVerifier
:
:
CertificateTransparencyMode
ctMode
=
static_cast
<
CertVerifier
:
:
CertificateTransparencyMode
>
(
Preferences
:
:
GetInt
(
"
security
.
pki
.
certificate_transparency
.
mode
"
static_cast
<
int32_t
>
(
defaultCTMode
)
)
)
;
switch
(
ctMode
)
{
case
CertVerifier
:
:
CertificateTransparencyMode
:
:
Disabled
:
case
CertVerifier
:
:
CertificateTransparencyMode
:
:
TelemetryOnly
:
break
;
default
:
ctMode
=
defaultCTMode
;
break
;
}
bool
sctsEnabled
=
ctMode
!
=
CertVerifier
:
:
CertificateTransparencyMode
:
:
Disabled
;
PublicSSLState
(
)
-
>
SetSignedCertTimestampsEnabled
(
sctsEnabled
)
;
PrivateSSLState
(
)
-
>
SetSignedCertTimestampsEnabled
(
sctsEnabled
)
;
BRNameMatchingPolicy
:
:
Mode
nameMatchingMode
=
static_cast
<
BRNameMatchingPolicy
:
:
Mode
>
(
Preferences
:
:
GetInt
(
"
security
.
pki
.
name_matching_mode
"
static_cast
<
int32_t
>
(
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
)
)
)
;
switch
(
nameMatchingMode
)
{
case
BRNameMatchingPolicy
:
:
Mode
:
:
Enforce
:
case
BRNameMatchingPolicy
:
:
Mode
:
:
EnforceAfter23August2015
:
case
BRNameMatchingPolicy
:
:
Mode
:
:
EnforceAfter23August2016
:
case
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
:
break
;
default
:
nameMatchingMode
=
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
;
break
;
}
PublicSSLState
(
)
-
>
SetNameMatchingMode
(
nameMatchingMode
)
;
PrivateSSLState
(
)
-
>
SetNameMatchingMode
(
nameMatchingMode
)
;
}
namespace
{
class
CipherSuiteChangeObserver
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
static
nsresult
StartObserve
(
)
;
protected
:
virtual
~
CipherSuiteChangeObserver
(
)
=
default
;
private
:
static
StaticRefPtr
<
CipherSuiteChangeObserver
>
sObserver
;
CipherSuiteChangeObserver
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
CipherSuiteChangeObserver
nsIObserver
)
StaticRefPtr
<
CipherSuiteChangeObserver
>
CipherSuiteChangeObserver
:
:
sObserver
;
nsresult
CipherSuiteChangeObserver
:
:
StartObserve
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
CipherSuiteChangeObserver
:
:
StartObserve
(
)
can
only
be
accessed
"
"
on
the
main
thread
"
)
;
if
(
!
sObserver
)
{
RefPtr
<
CipherSuiteChangeObserver
>
observer
=
new
CipherSuiteChangeObserver
(
)
;
nsresult
rv
=
Preferences
:
:
AddStrongObserver
(
observer
.
get
(
)
"
security
.
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
sObserver
=
nullptr
;
return
rv
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
observerService
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
sObserver
=
observer
;
}
return
NS_OK
;
}
void
SetDeprecatedTLS1CipherPrefs
(
)
{
if
(
Preferences
:
:
GetBool
(
"
security
.
tls
.
version
.
enable
-
deprecated
"
false
)
)
{
for
(
const
auto
&
deprecatedTLS1CipherPref
:
sDeprecatedTLS1CipherPrefs
)
{
bool
cipherEnabled
=
Preferences
:
:
GetBool
(
deprecatedTLS1CipherPref
.
pref
deprecatedTLS1CipherPref
.
enabledByDefault
)
;
SSL_CipherPrefSetDefault
(
deprecatedTLS1CipherPref
.
id
cipherEnabled
)
;
}
}
else
{
for
(
const
auto
&
deprecatedTLS1CipherPref
:
sDeprecatedTLS1CipherPrefs
)
{
SSL_CipherPrefSetDefault
(
deprecatedTLS1CipherPref
.
id
false
)
;
}
}
}
nsresult
CipherSuiteChangeObserver
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
someData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
CipherSuiteChangeObserver
:
:
Observe
can
only
be
accessed
on
main
"
"
thread
"
)
;
if
(
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
=
=
0
)
{
NS_ConvertUTF16toUTF8
prefName
(
someData
)
;
for
(
const
auto
&
cipherPref
:
sCipherPrefs
)
{
if
(
prefName
.
Equals
(
cipherPref
.
pref
)
)
{
bool
cipherEnabled
=
Preferences
:
:
GetBool
(
cipherPref
.
pref
cipherPref
.
enabledByDefault
)
;
SSL_CipherPrefSetDefault
(
cipherPref
.
id
cipherEnabled
)
;
break
;
}
}
SetDeprecatedTLS1CipherPrefs
(
)
;
nsNSSComponent
:
:
DoClearSSLExternalAndInternalSessionCache
(
)
;
}
else
if
(
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
Preferences
:
:
RemoveObserver
(
this
"
security
.
"
)
;
MOZ_ASSERT
(
sObserver
.
get
(
)
=
=
this
)
;
sObserver
=
nullptr
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
observerService
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
return
NS_OK
;
}
}
void
nsNSSComponent
:
:
setValidationOptions
(
bool
isInitialSetting
const
mozilla
:
:
MutexAutoLock
&
proofOfLock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
NS_IsMainThread
(
)
)
)
{
return
;
}
SetValidationOptionsCommon
(
)
;
const
CertVerifier
:
:
CertificateTransparencyMode
defaultCTMode
=
CertVerifier
:
:
CertificateTransparencyMode
:
:
TelemetryOnly
;
CertVerifier
:
:
CertificateTransparencyMode
ctMode
=
static_cast
<
CertVerifier
:
:
CertificateTransparencyMode
>
(
Preferences
:
:
GetInt
(
"
security
.
pki
.
certificate_transparency
.
mode
"
static_cast
<
int32_t
>
(
defaultCTMode
)
)
)
;
switch
(
ctMode
)
{
case
CertVerifier
:
:
CertificateTransparencyMode
:
:
Disabled
:
case
CertVerifier
:
:
CertificateTransparencyMode
:
:
TelemetryOnly
:
break
;
default
:
ctMode
=
defaultCTMode
;
break
;
}
int32_t
ocspEnabled
=
Preferences
:
:
GetInt
(
"
security
.
OCSP
.
enabled
"
OCSP_ENABLED_DEFAULT
)
;
bool
ocspRequired
=
ocspEnabled
&
&
Preferences
:
:
GetBool
(
"
security
.
OCSP
.
require
"
false
)
;
if
(
isInitialSetting
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_OCSP_ENABLED
ocspEnabled
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_OCSP_REQUIRED
ocspRequired
)
;
}
CertVerifier
:
:
SHA1Mode
sha1Mode
=
static_cast
<
CertVerifier
:
:
SHA1Mode
>
(
Preferences
:
:
GetInt
(
"
security
.
pki
.
sha1_enforcement_level
"
static_cast
<
int32_t
>
(
CertVerifier
:
:
SHA1Mode
:
:
Allowed
)
)
)
;
switch
(
sha1Mode
)
{
case
CertVerifier
:
:
SHA1Mode
:
:
Allowed
:
case
CertVerifier
:
:
SHA1Mode
:
:
Forbidden
:
case
CertVerifier
:
:
SHA1Mode
:
:
UsedToBeBefore2016ButNowIsForbidden
:
case
CertVerifier
:
:
SHA1Mode
:
:
ImportedRoot
:
case
CertVerifier
:
:
SHA1Mode
:
:
ImportedRootOrBefore2016
:
break
;
default
:
sha1Mode
=
CertVerifier
:
:
SHA1Mode
:
:
Allowed
;
break
;
}
if
(
sha1Mode
=
=
CertVerifier
:
:
SHA1Mode
:
:
UsedToBeBefore2016ButNowIsForbidden
)
{
sha1Mode
=
CertVerifier
:
:
SHA1Mode
:
:
Forbidden
;
}
NetscapeStepUpPolicy
netscapeStepUpPolicy
=
static_cast
<
NetscapeStepUpPolicy
>
(
Preferences
:
:
GetUint
(
"
security
.
pki
.
netscape_step_up_policy
"
static_cast
<
uint32_t
>
(
NetscapeStepUpPolicy
:
:
AlwaysMatch
)
)
)
;
switch
(
netscapeStepUpPolicy
)
{
case
NetscapeStepUpPolicy
:
:
AlwaysMatch
:
case
NetscapeStepUpPolicy
:
:
MatchBefore23August2016
:
case
NetscapeStepUpPolicy
:
:
MatchBefore23August2015
:
case
NetscapeStepUpPolicy
:
:
NeverMatch
:
break
;
default
:
netscapeStepUpPolicy
=
NetscapeStepUpPolicy
:
:
AlwaysMatch
;
break
;
}
CRLiteMode
defaultCRLiteMode
=
CRLiteMode
:
:
Disabled
;
CRLiteMode
crliteMode
=
static_cast
<
CRLiteMode
>
(
Preferences
:
:
GetUint
(
"
security
.
pki
.
crlite_mode
"
static_cast
<
uint32_t
>
(
defaultCRLiteMode
)
)
)
;
switch
(
crliteMode
)
{
case
CRLiteMode
:
:
Disabled
:
case
CRLiteMode
:
:
TelemetryOnly
:
case
CRLiteMode
:
:
Enforce
:
case
CRLiteMode
:
:
ConfirmRevocations
:
break
;
default
:
crliteMode
=
defaultCRLiteMode
;
break
;
}
CertVerifier
:
:
OcspDownloadConfig
odc
;
CertVerifier
:
:
OcspStrictConfig
osc
;
uint32_t
certShortLifetimeInDays
;
TimeDuration
softTimeout
;
TimeDuration
hardTimeout
;
GetRevocationBehaviorFromPrefs
(
&
odc
&
osc
&
certShortLifetimeInDays
softTimeout
hardTimeout
proofOfLock
)
;
mDefaultCertVerifier
=
new
SharedCertVerifier
(
odc
osc
softTimeout
hardTimeout
certShortLifetimeInDays
sha1Mode
PublicSSLState
(
)
-
>
NameMatchingMode
(
)
netscapeStepUpPolicy
ctMode
crliteMode
mEnterpriseCerts
)
;
}
void
nsNSSComponent
:
:
UpdateCertVerifierWithEnterpriseRoots
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mDefaultCertVerifier
)
;
if
(
NS_WARN_IF
(
!
mDefaultCertVerifier
)
)
{
return
;
}
RefPtr
<
SharedCertVerifier
>
oldCertVerifier
=
mDefaultCertVerifier
;
mDefaultCertVerifier
=
new
SharedCertVerifier
(
oldCertVerifier
-
>
mOCSPDownloadConfig
oldCertVerifier
-
>
mOCSPStrict
?
CertVerifier
:
:
ocspStrict
:
CertVerifier
:
:
ocspRelaxed
oldCertVerifier
-
>
mOCSPTimeoutSoft
oldCertVerifier
-
>
mOCSPTimeoutHard
oldCertVerifier
-
>
mCertShortLifetimeInDays
oldCertVerifier
-
>
mSHA1Mode
oldCertVerifier
-
>
mNameMatchingMode
oldCertVerifier
-
>
mNetscapeStepUpPolicy
oldCertVerifier
-
>
mCTMode
oldCertVerifier
-
>
mCRLiteMode
mEnterpriseCerts
)
;
}
nsresult
nsNSSComponent
:
:
SetEnabledTLSVersions
(
)
{
static
const
uint32_t
PSM_DEFAULT_MIN_TLS_VERSION
=
3
;
static
const
uint32_t
PSM_DEFAULT_MAX_TLS_VERSION
=
4
;
static
const
uint32_t
PSM_DEPRECATED_TLS_VERSION
=
1
;
uint32_t
minFromPrefs
=
Preferences
:
:
GetUint
(
"
security
.
tls
.
version
.
min
"
PSM_DEFAULT_MIN_TLS_VERSION
)
;
uint32_t
maxFromPrefs
=
Preferences
:
:
GetUint
(
"
security
.
tls
.
version
.
max
"
PSM_DEFAULT_MAX_TLS_VERSION
)
;
bool
enableDeprecated
=
Preferences
:
:
GetBool
(
"
security
.
tls
.
version
.
enable
-
deprecated
"
false
)
;
if
(
enableDeprecated
)
{
minFromPrefs
=
std
:
:
min
(
minFromPrefs
PSM_DEPRECATED_TLS_VERSION
)
;
}
SSLVersionRange
defaults
=
{
SSL_LIBRARY_VERSION_3_0
+
PSM_DEFAULT_MIN_TLS_VERSION
SSL_LIBRARY_VERSION_3_0
+
PSM_DEFAULT_MAX_TLS_VERSION
}
;
SSLVersionRange
filledInRange
;
FillTLSVersionRange
(
filledInRange
minFromPrefs
maxFromPrefs
defaults
)
;
SECStatus
srv
=
SSL_VersionRangeSetDefault
(
ssl_variant_stream
&
filledInRange
)
;
if
(
srv
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
#
if
defined
(
XP_WIN
)
|
|
(
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
)
static
void
SetNSSDatabaseCacheModeAsAppropriate
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIFile
>
profileFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profileFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
static
const
char
sNSS_SDB_USE_CACHE
[
]
=
"
NSS_SDB_USE_CACHE
"
;
static
const
char
sNSS_SDB_USE_CACHE_WITH_VALUE
[
]
=
"
NSS_SDB_USE_CACHE
=
yes
"
;
auto
profilePath
=
profileFile
-
>
NativePath
(
)
;
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
struct
statfs
statfs_s
;
if
(
statfs
(
profilePath
.
get
(
)
&
statfs_s
)
=
=
0
&
&
statfs_s
.
f_type
=
=
NFS_SUPER_MAGIC
&
&
!
PR_GetEnv
(
sNSS_SDB_USE_CACHE
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
profile
is
remote
(
and
NSS_SDB_USE_CACHE
wasn
'
t
set
)
:
"
"
setting
NSS_SDB_USE_CACHE
"
)
)
;
PR_SetEnv
(
sNSS_SDB_USE_CACHE_WITH_VALUE
)
;
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
not
setting
NSS_SDB_USE_CACHE
"
)
)
;
}
#
endif
#
ifdef
XP_WIN
wchar_t
volPath
[
MAX_PATH
]
;
if
(
:
:
GetVolumePathNameW
(
profilePath
.
get
(
)
volPath
MAX_PATH
)
&
&
:
:
GetDriveTypeW
(
volPath
)
=
=
DRIVE_REMOTE
&
&
!
PR_GetEnv
(
sNSS_SDB_USE_CACHE
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
profile
is
remote
(
and
NSS_SDB_USE_CACHE
wasn
'
t
set
)
:
"
"
setting
NSS_SDB_USE_CACHE
"
)
)
;
PR_SetEnv
(
sNSS_SDB_USE_CACHE_WITH_VALUE
)
;
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
not
setting
NSS_SDB_USE_CACHE
"
)
)
;
}
#
endif
}
#
endif
static
nsresult
GetNSSProfilePath
(
nsAutoCString
&
aProfilePath
)
{
aProfilePath
.
Truncate
(
)
;
nsCOMPtr
<
nsIFile
>
profileFile
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profileFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
NSS
will
be
initialized
without
a
profile
directory
.
"
"
Some
things
may
not
work
as
expected
.
"
)
;
return
NS_OK
;
}
#
if
defined
(
XP_WIN
)
nsCOMPtr
<
nsILocalFileWin
>
profileFileWin
(
do_QueryInterface
(
profileFile
)
)
;
if
(
!
profileFileWin
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Could
not
get
nsILocalFileWin
for
profile
directory
.
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoString
u16ProfilePath
;
rv
=
profileFileWin
-
>
GetPath
(
u16ProfilePath
)
;
CopyUTF16toUTF8
(
u16ProfilePath
aProfilePath
)
;
#
else
rv
=
profileFile
-
>
GetNativePath
(
aProfilePath
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
Could
not
get
native
path
for
profile
directory
.
\
n
"
)
)
;
return
rv
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
NSS
profile
at
'
%
s
'
\
n
"
aProfilePath
.
get
(
)
)
)
;
return
NS_OK
;
}
#
ifndef
ANDROID
static
nsresult
AttemptToRenamePKCS11ModuleDB
(
const
nsACString
&
profilePath
)
{
nsCOMPtr
<
nsIFile
>
profileDir
=
do_CreateInstance
(
"
mozilla
.
org
/
file
/
local
;
1
"
)
;
if
(
!
profileDir
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
XP_WIN
nsresult
rv
=
profileDir
-
>
InitWithPath
(
NS_ConvertUTF8toUTF16
(
profilePath
)
)
;
#
else
nsresult
rv
=
profileDir
-
>
InitWithNativePath
(
profilePath
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
char
*
moduleDBFilename
=
"
pkcs11
.
txt
"
;
nsAutoCString
destModuleDBFilename
(
moduleDBFilename
)
;
destModuleDBFilename
.
Append
(
"
.
fips
"
)
;
nsCOMPtr
<
nsIFile
>
dbFile
;
rv
=
profileDir
-
>
Clone
(
getter_AddRefs
(
dbFile
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
dbFile
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
dbFile
-
>
AppendNative
(
nsAutoCString
(
moduleDBFilename
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
exists
;
rv
=
dbFile
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
exists
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
%
s
doesn
'
t
exist
?
"
moduleDBFilename
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
destDBFile
;
rv
=
profileDir
-
>
Clone
(
getter_AddRefs
(
destDBFile
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
destDBFile
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
destDBFile
-
>
AppendNative
(
destModuleDBFilename
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
destDBFile
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
exists
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
%
s
already
exists
-
not
overwriting
"
destModuleDBFilename
.
get
(
)
)
)
;
return
NS_OK
;
}
Unused
<
<
dbFile
-
>
MoveToNative
(
profileDir
destModuleDBFilename
)
;
return
NS_OK
;
}
#
endif
static
nsresult
InitializeNSSWithFallbacks
(
const
nsACString
&
profilePath
bool
nocertdb
bool
safeMode
)
{
if
(
nocertdb
|
|
profilePath
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nocertdb
mode
or
empty
profile
path
-
>
NSS_NoDB_Init
"
)
)
;
SECStatus
srv
=
NSS_NoDB_Init
(
nullptr
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
srv
!
=
SECSuccess
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
InitializeNSSWithFallbacks
failed
:
%
d
"
PR_GetError
(
)
)
;
}
#
endif
return
srv
=
=
SECSuccess
?
NS_OK
:
NS_ERROR_FAILURE
;
}
#
ifndef
ANDROID
PRErrorCode
savedPRErrorCode1
;
#
endif
PKCS11DBConfig
safeModeDBConfig
=
safeMode
?
PKCS11DBConfig
:
:
DoNotLoadModules
:
PKCS11DBConfig
:
:
LoadModules
;
SECStatus
srv
=
:
:
mozilla
:
:
psm
:
:
InitializeNSS
(
profilePath
NSSDBConfig
:
:
ReadWrite
safeModeDBConfig
)
;
if
(
srv
=
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
initialized
NSS
in
r
/
w
mode
"
)
)
;
return
NS_OK
;
}
#
ifndef
ANDROID
savedPRErrorCode1
=
PR_GetError
(
)
;
PRErrorCode
savedPRErrorCode2
;
#
endif
srv
=
:
:
mozilla
:
:
psm
:
:
InitializeNSS
(
profilePath
NSSDBConfig
:
:
ReadOnly
safeModeDBConfig
)
;
if
(
srv
=
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
initialized
NSS
in
r
-
o
mode
"
)
)
;
return
NS_OK
;
}
#
ifndef
ANDROID
savedPRErrorCode2
=
PR_GetError
(
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
initialize
NSS
with
codes
%
d
%
d
"
savedPRErrorCode1
savedPRErrorCode2
)
)
;
#
endif
#
ifndef
ANDROID
if
(
!
safeMode
&
&
(
savedPRErrorCode1
=
=
SEC_ERROR_LEGACY_DATABASE
|
|
savedPRErrorCode2
=
=
SEC_ERROR_LEGACY_DATABASE
|
|
savedPRErrorCode1
=
=
SEC_ERROR_PKCS11_DEVICE_ERROR
|
|
savedPRErrorCode2
=
=
SEC_ERROR_PKCS11_DEVICE_ERROR
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
attempting
no
-
module
db
init
"
)
)
;
srv
=
:
:
mozilla
:
:
psm
:
:
InitializeNSS
(
profilePath
NSSDBConfig
:
:
ReadWrite
PKCS11DBConfig
:
:
DoNotLoadModules
)
;
if
(
srv
=
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
FIPS
may
be
the
problem
"
)
)
;
srv
=
NSS_Shutdown
(
)
;
if
(
srv
!
=
SECSuccess
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
MOZ_CRASH_UNSAFE_PRINTF
(
"
InitializeNSSWithFallbacks
failed
:
%
d
"
PR_GetError
(
)
)
;
#
endif
return
NS_ERROR_FAILURE
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
trying
to
rename
module
db
"
)
)
;
nsresult
rv
=
AttemptToRenamePKCS11ModuleDB
(
profilePath
)
;
if
(
NS_FAILED
(
rv
)
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
MOZ_CRASH_UNSAFE_PRINTF
(
"
InitializeNSSWithFallbacks
failed
:
%
u
"
(
uint32_t
)
rv
)
;
#
endif
return
rv
;
}
srv
=
:
:
mozilla
:
:
psm
:
:
InitializeNSS
(
profilePath
NSSDBConfig
:
:
ReadWrite
PKCS11DBConfig
:
:
LoadModules
)
;
if
(
srv
=
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
initialized
in
r
/
w
mode
"
)
)
;
return
NS_OK
;
}
srv
=
:
:
mozilla
:
:
psm
:
:
InitializeNSS
(
profilePath
NSSDBConfig
:
:
ReadOnly
PKCS11DBConfig
:
:
LoadModules
)
;
if
(
srv
=
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
initialized
in
r
-
o
mode
"
)
)
;
return
NS_OK
;
}
}
}
#
endif
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
last
-
resort
NSS_NoDB_Init
"
)
)
;
srv
=
NSS_NoDB_Init
(
nullptr
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
srv
!
=
SECSuccess
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
InitializeNSSWithFallbacks
failed
:
%
d
"
PR_GetError
(
)
)
;
}
#
endif
return
srv
=
=
SECSuccess
?
NS_OK
:
NS_ERROR_FAILURE
;
}
#
if
defined
(
NIGHTLY_BUILD
)
&
&
!
defined
(
ANDROID
)
void
UnmigrateOneCertDB
(
const
nsCOMPtr
<
nsIFile
>
&
profileDirectory
const
nsACString
&
dbType
)
{
nsCOMPtr
<
nsIFile
>
dbFile
;
nsresult
rv
=
profileDirectory
-
>
Clone
(
getter_AddRefs
(
dbFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
dbFile
-
>
AppendNative
(
dbType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
bool
exists
;
rv
=
dbFile
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
exists
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
prefixedDBFile
;
rv
=
profileDirectory
-
>
Clone
(
getter_AddRefs
(
prefixedDBFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsAutoCString
prefixedDBName
(
"
gecko
-
no
-
share
-
"
)
;
prefixedDBName
.
Append
(
dbType
)
;
rv
=
prefixedDBFile
-
>
AppendNative
(
prefixedDBName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
Unused
<
<
prefixedDBFile
-
>
MoveToNative
(
nullptr
dbType
)
;
}
void
UnmigrateFromPrefixedCertDBs
(
)
{
nsCOMPtr
<
nsIFile
>
profileDirectory
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profileDirectory
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
UnmigrateOneCertDB
(
profileDirectory
"
cert9
.
db
"
_ns
)
;
UnmigrateOneCertDB
(
profileDirectory
"
key4
.
db
"
_ns
)
;
}
#
endif
nsresult
nsNSSComponent
:
:
InitializeNSS
(
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
InitializeNSS
\
n
"
)
)
;
AUTO_PROFILER_LABEL
(
"
nsNSSComponent
:
:
InitializeNSS
"
OTHER
)
;
AUTO_PROFILER_TRACING_MARKER
(
"
NSS
"
"
nsNSSComponent
:
:
InitializeNSS
"
OTHER
)
;
static_assert
(
nsINSSErrorsService
:
:
NSS_SEC_ERROR_BASE
=
=
SEC_ERROR_BASE
&
&
nsINSSErrorsService
:
:
NSS_SEC_ERROR_LIMIT
=
=
SEC_ERROR_LIMIT
&
&
nsINSSErrorsService
:
:
NSS_SSL_ERROR_BASE
=
=
SSL_ERROR_BASE
&
&
nsINSSErrorsService
:
:
NSS_SSL_ERROR_LIMIT
=
=
SSL_ERROR_LIMIT
"
You
must
update
the
values
in
nsINSSErrorsService
.
idl
"
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
NSS
Initialization
beginning
\
n
"
)
)
;
nsAutoCString
profileStr
;
nsresult
rv
=
GetNSSProfilePath
(
profileStr
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
if
defined
(
NIGHTLY_BUILD
)
&
&
!
defined
(
ANDROID
)
if
(
!
profileStr
.
IsEmpty
(
)
)
{
UnmigrateFromPrefixedCertDBs
(
)
;
}
#
endif
#
if
defined
(
XP_WIN
)
|
|
(
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
)
SetNSSDatabaseCacheModeAsAppropriate
(
)
;
#
endif
bool
nocertdb
=
Preferences
:
:
GetBool
(
"
security
.
nocertdb
"
false
)
;
bool
inSafeMode
=
true
;
nsCOMPtr
<
nsIXULRuntime
>
runtime
(
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
)
;
if
(
runtime
)
{
rv
=
runtime
-
>
GetInSafeMode
(
&
inSafeMode
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
inSafeMode
:
%
u
\
n
"
inSafeMode
)
)
;
rv
=
InitializeNSSWithFallbacks
(
profileStr
nocertdb
inSafeMode
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
initialize
NSS
"
)
)
;
return
rv
;
}
PK11_SetPasswordFunc
(
PK11PasswordPrompt
)
;
Preferences
:
:
AddStrongObserver
(
this
"
security
.
"
)
;
rv
=
CommonInit
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsICertOverrideService
>
certOverrideService
(
do_GetService
(
NS_CERTOVERRIDE_CONTRACTID
)
)
;
nsCOMPtr
<
nsIClientAuthRememberService
>
clientAuthRememberService
(
do_GetService
(
NS_CLIENTAUTHREMEMBERSERVICE_CONTRACTID
)
)
;
nsCOMPtr
<
nsISiteSecurityService
>
siteSecurityService
(
do_GetService
(
NS_SSSERVICE_CONTRACTID
)
)
;
nsCOMPtr
<
nsICertStorage
>
certStorage
(
do_GetService
(
NS_CERT_STORAGE_CID
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
NSS
Initialization
done
\
n
"
)
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
#
ifdef
DEBUG
mTestBuiltInRootHash
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
security
.
test
.
built_in_root_hash
"
mTestBuiltInRootHash
)
;
#
endif
mContentSigningRootHash
.
Truncate
(
)
;
Preferences
:
:
GetCString
(
"
security
.
content
.
signature
.
root_hash
"
mContentSigningRootHash
)
;
mMitmCanaryIssuer
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
security
.
pki
.
mitm_canary_issuer
"
mMitmCanaryIssuer
)
;
mMitmDetecionEnabled
=
Preferences
:
:
GetBool
(
"
security
.
pki
.
mitm_canary_issuer
.
enabled
"
true
)
;
setValidationOptions
(
true
lock
)
;
bool
importEnterpriseRoots
=
Preferences
:
:
GetBool
(
kEnterpriseRootModePref
false
)
;
uint32_t
familySafetyMode
=
Preferences
:
:
GetUint
(
kFamilySafetyModePref
kFamilySafetyModeDefault
)
;
Vector
<
nsCString
>
possibleLoadableRootsLocations
;
rv
=
ListPossibleLoadableRootsLocations
(
possibleLoadableRootsLocations
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
loadOSClientCertsModule
=
Preferences
:
:
GetBool
(
kOSClientCertsModulePref
false
)
;
Maybe
<
nsCString
>
maybeOSClientCertsModuleLocation
;
if
(
loadOSClientCertsModule
)
{
nsAutoCString
libraryDir
;
if
(
NS_SUCCEEDED
(
GetDirectoryPath
(
NS_GRE_BIN_DIR
libraryDir
)
)
)
{
maybeOSClientCertsModuleLocation
.
emplace
(
libraryDir
)
;
}
}
RefPtr
<
LoadLoadableCertsTask
>
loadLoadableCertsTask
(
new
LoadLoadableCertsTask
(
this
importEnterpriseRoots
familySafetyMode
std
:
:
move
(
possibleLoadableRootsLocations
)
std
:
:
move
(
maybeOSClientCertsModuleLocation
)
)
)
;
rv
=
loadLoadableCertsTask
-
>
Dispatch
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mLoadLoadableCertsTaskDispatched
=
true
;
return
NS_OK
;
}
}
void
nsNSSComponent
:
:
ShutdownNSS
(
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
ShutdownNSS
\
n
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
loadLoadableCertsTaskDispatched
;
{
MutexAutoLock
lock
(
mMutex
)
;
loadLoadableCertsTaskDispatched
=
mLoadLoadableCertsTaskDispatched
;
}
if
(
loadLoadableCertsTaskDispatched
)
{
Unused
<
<
BlockUntilLoadableCertsLoaded
(
)
;
}
PK11_SetPasswordFunc
(
(
PK11PasswordFunc
)
nullptr
)
;
Preferences
:
:
RemoveObserver
(
this
"
security
.
"
)
;
if
(
mIntermediatePreloadingHealerTimer
)
{
mIntermediatePreloadingHealerTimer
-
>
Cancel
(
)
;
mIntermediatePreloadingHealerTimer
=
nullptr
;
}
MutexAutoLock
lock
(
mMutex
)
;
mDefaultCertVerifier
=
nullptr
;
}
bool
CertHasDefaultTrust
(
CERTCertificate
*
cert
)
{
CERTCertTrust
trust
;
if
(
CERT_GetCertTrust
(
cert
&
trust
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CERT_GetCertTrust
failed
"
)
)
;
return
false
;
}
if
(
(
trust
.
sslFlags
&
(
CERTDB_TRUSTED_CA
|
CERTDB_TERMINAL_RECORD
)
)
=
=
CERTDB_TERMINAL_RECORD
)
{
return
false
;
}
if
(
trust
.
sslFlags
&
CERTDB_TRUSTED_CA
)
{
return
false
;
}
if
(
(
trust
.
emailFlags
&
(
CERTDB_TRUSTED_CA
|
CERTDB_TERMINAL_RECORD
)
)
=
=
CERTDB_TERMINAL_RECORD
)
{
return
false
;
}
if
(
trust
.
emailFlags
&
CERTDB_TRUSTED_CA
)
{
return
false
;
}
return
true
;
}
void
IntermediatePreloadingHealerCallback
(
nsITimer
*
void
*
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
IntermediatePreloadingHealerCallback
"
)
)
;
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Exiting
healer
due
to
app
shutdown
"
)
)
;
return
;
}
UniquePK11SlotInfo
softokenSlot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
softokenSlot
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
PK11_GetInternalKeySlot
failed
"
)
)
;
return
;
}
UniqueCERTCertList
softokenCertificates
(
PK11_ListCertsInSlot
(
softokenSlot
.
get
(
)
)
)
;
if
(
!
softokenCertificates
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
PK11_ListCertsInSlot
failed
"
)
)
;
return
;
}
nsCOMPtr
<
nsICertStorage
>
certStorage
(
do_GetService
(
NS_CERT_STORAGE_CID
)
)
;
if
(
!
certStorage
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
get
cert_storage
"
)
)
;
return
;
}
Vector
<
UniqueCERTCertificate
>
certsToDelete
;
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
softokenCertificates
)
;
!
CERT_LIST_END
(
n
softokenCertificates
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Exiting
healer
due
to
app
shutdown
"
)
)
;
return
;
}
nsTArray
<
uint8_t
>
subject
;
subject
.
AppendElements
(
n
-
>
cert
-
>
derSubject
.
data
n
-
>
cert
-
>
derSubject
.
len
)
;
nsTArray
<
nsTArray
<
uint8_t
>
>
certs
;
nsresult
rv
=
certStorage
-
>
FindCertsBySubject
(
subject
certs
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
FindCertsBySubject
failed
"
)
)
;
break
;
}
for
(
const
auto
&
encodedCert
:
certs
)
{
if
(
encodedCert
.
Length
(
)
!
=
n
-
>
cert
-
>
derCert
.
len
)
{
continue
;
}
if
(
memcmp
(
encodedCert
.
Elements
(
)
n
-
>
cert
-
>
derCert
.
data
encodedCert
.
Length
(
)
)
!
=
0
)
{
continue
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
found
preloaded
intermediate
in
certdb
"
)
)
;
if
(
!
CertHasDefaultTrust
(
n
-
>
cert
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
certificate
doesn
'
t
have
default
trust
-
skipping
"
)
)
;
continue
;
}
UniqueCERTCertificate
certCopy
(
CERT_DupCertificate
(
n
-
>
cert
)
)
;
if
(
!
certCopy
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CERT_DupCertificate
failed
"
)
)
;
continue
;
}
if
(
!
certsToDelete
.
append
(
std
:
:
move
(
certCopy
)
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
append
failed
-
out
of
memory
?
"
)
)
;
return
;
}
break
;
}
if
(
certsToDelete
.
length
(
)
>
=
20
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
found
limit
of
20
preloaded
intermediates
in
certdb
"
)
)
;
break
;
}
}
for
(
const
auto
&
certToDelete
:
certsToDelete
)
{
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Exiting
healer
due
to
app
shutdown
"
)
)
;
return
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
attempting
to
delete
preloaded
intermediate
'
%
s
'
"
certToDelete
-
>
subjectName
)
)
;
if
(
SEC_DeletePermCertificate
(
certToDelete
.
get
(
)
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SEC_DeletePermCertificate
failed
"
)
)
;
}
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
IntermediatePreloadingHealerCallbackDone
"
[
]
(
)
-
>
void
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
nullptr
"
psm
:
intermediate
-
preloading
-
healer
-
ran
"
nullptr
)
;
}
}
)
)
;
Unused
<
<
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
nsresult
nsNSSComponent
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
Telemetry
:
:
AutoScalarTimer
<
Telemetry
:
:
ScalarID
:
:
NETWORKING_NSS_INITIALIZATION
>
timer
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
Beginning
NSS
initialization
\
n
"
)
)
;
nsresult
rv
=
InitializeNSS
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
nsNSSComponent
:
:
InitializeNSS
(
)
failed
\
n
"
)
)
;
return
rv
;
}
rv
=
RegisterObservers
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
MaybeEnableIntermediatePreloadingHealer
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
nsNSSComponent
:
:
MaybeEnableIntermediatePreloadingHealer
(
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
:
MaybeEnableIntermediatePreloadingHealer
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
mIntermediatePreloadingHealerTimer
)
{
mIntermediatePreloadingHealerTimer
-
>
Cancel
(
)
;
mIntermediatePreloadingHealerTimer
=
nullptr
;
}
if
(
!
Preferences
:
:
GetBool
(
"
security
.
intermediate_preloading_healer
.
enabled
"
false
)
)
{
return
NS_OK
;
}
if
(
!
mIntermediatePreloadingHealerTaskQueue
)
{
nsresult
rv
=
NS_CreateBackgroundTaskQueue
(
"
IntermediatePreloadingHealer
"
getter_AddRefs
(
mIntermediatePreloadingHealerTaskQueue
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
NS_CreateBackgroundTaskQueue
failed
"
)
)
;
return
rv
;
}
}
uint32_t
timerDelayMS
=
Preferences
:
:
GetUint
(
"
security
.
intermediate_preloading_healer
.
timer_interval_ms
"
5
*
60
*
1000
)
;
nsresult
rv
=
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mIntermediatePreloadingHealerTimer
)
IntermediatePreloadingHealerCallback
nullptr
timerDelayMS
nsITimer
:
:
TYPE_REPEATING_SLACK_LOW_PRIORITY
"
IntermediatePreloadingHealer
"
mIntermediatePreloadingHealerTaskQueue
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Error
(
"
NS_NewTimerWithFuncCallback
failed
"
)
)
;
return
rv
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsNSSComponent
nsINSSComponent
nsIObserver
)
static
const
char
*
const
PROFILE_BEFORE_CHANGE_TOPIC
=
"
profile
-
before
-
change
"
;
NS_IMETHODIMP
nsNSSComponent
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
nsCRT
:
:
strcmp
(
aTopic
PROFILE_BEFORE_CHANGE_TOPIC
)
=
=
0
|
|
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
receiving
profile
change
or
XPCOM
shutdown
notification
"
)
)
;
ShutdownNSS
(
)
;
}
else
if
(
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
=
=
0
)
{
bool
clearSessionCache
=
true
;
NS_ConvertUTF16toUTF8
prefName
(
someData
)
;
if
(
HandleTLSPrefChange
(
prefName
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HandleTLSPrefChange
done
"
)
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
OCSP
.
enabled
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
OCSP
.
require
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
cert_short_lifetime_in_days
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
enable_ocsp_stapling
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
ssl
.
enable_ocsp_must_staple
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
certificate_transparency
.
mode
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
sha1_enforcement_level
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
name_matching_mode
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
netscape_step_up_policy
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
OCSP
.
timeoutMilliseconds
.
soft
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
OCSP
.
timeoutMilliseconds
.
hard
"
)
|
|
prefName
.
EqualsLiteral
(
"
security
.
pki
.
crlite_mode
"
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
setValidationOptions
(
false
lock
)
;
#
ifdef
DEBUG
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
test
.
built_in_root_hash
"
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
mTestBuiltInRootHash
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
security
.
test
.
built_in_root_hash
"
mTestBuiltInRootHash
)
;
#
endif
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
content
.
signature
.
root_hash
"
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
mContentSigningRootHash
.
Truncate
(
)
;
Preferences
:
:
GetCString
(
"
security
.
content
.
signature
.
root_hash
"
mContentSigningRootHash
)
;
}
else
if
(
prefName
.
Equals
(
kEnterpriseRootModePref
)
|
|
prefName
.
Equals
(
kFamilySafetyModePref
)
)
{
UnloadEnterpriseRoots
(
)
;
MaybeImportEnterpriseRoots
(
)
;
}
else
if
(
prefName
.
Equals
(
kOSClientCertsModulePref
)
)
{
bool
loadOSClientCertsModule
=
Preferences
:
:
GetBool
(
kOSClientCertsModulePref
false
)
;
AsyncLoadOrUnloadOSClientCertsModule
(
loadOSClientCertsModule
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
pki
.
mitm_canary_issuer
"
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
mMitmCanaryIssuer
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
security
.
pki
.
mitm_canary_issuer
"
mMitmCanaryIssuer
)
;
}
else
if
(
prefName
.
EqualsLiteral
(
"
security
.
pki
.
mitm_canary_issuer
.
enabled
"
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
mMitmDetecionEnabled
=
Preferences
:
:
GetBool
(
"
security
.
pki
.
mitm_canary_issuer
.
enabled
"
true
)
;
}
else
{
clearSessionCache
=
false
;
}
if
(
clearSessionCache
)
{
ClearSSLExternalAndInternalSessionCache
(
)
;
}
if
(
prefName
.
Equals
(
"
security
.
intermediate_preloading_healer
.
enabled
"
)
|
|
prefName
.
Equals
(
"
security
.
intermediate_preloading_healer
.
timer_interval_ms
"
)
)
{
MaybeEnableIntermediatePreloadingHealer
(
)
;
}
}
return
NS_OK
;
}
nsresult
nsNSSComponent
:
:
GetNewPrompter
(
nsIPrompt
*
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
*
result
=
nullptr
;
if
(
!
NS_IsMainThread
(
)
)
{
NS_ERROR
(
"
nsSDRContext
:
:
GetNewPrompter
called
off
the
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
nsresult
rv
;
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
(
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
wwatch
-
>
GetNewPrompter
(
0
result
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
nsresult
nsNSSComponent
:
:
LogoutAuthenticatedPK11
(
)
{
nsCOMPtr
<
nsICertOverrideService
>
icos
=
do_GetService
(
"
mozilla
.
org
/
security
/
certoverride
;
1
"
)
;
if
(
icos
)
{
icos
-
>
ClearValidityOverride
(
"
all
:
temporary
-
certificates
"
_ns
0
OriginAttributes
(
)
)
;
}
ClearSSLExternalAndInternalSessionCache
(
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
net
:
cancel
-
all
-
connections
"
nullptr
)
;
}
return
NS_OK
;
}
nsresult
nsNSSComponent
:
:
RegisterObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
(
do_GetService
(
"
mozilla
.
org
/
observer
-
service
;
1
"
)
)
;
if
(
!
observerService
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
couldn
'
t
get
observer
service
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
nsNSSComponent
:
adding
observers
\
n
"
)
)
;
observerService
-
>
AddObserver
(
this
PROFILE_BEFORE_CHANGE_TOPIC
false
)
;
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
IsCertTestBuiltInRoot
(
CERTCertificate
*
cert
bool
*
result
)
{
NS_ENSURE_ARG_POINTER
(
cert
)
;
NS_ENSURE_ARG_POINTER
(
result
)
;
*
result
=
false
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIX509Cert
>
x509Cert
(
new
nsNSSCertificate
(
cert
)
)
;
nsAutoString
certHash
;
nsresult
rv
=
x509Cert
-
>
GetSha256Fingerprint
(
certHash
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MutexAutoLock
lock
(
mMutex
)
;
if
(
mTestBuiltInRootHash
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
*
result
=
mTestBuiltInRootHash
.
Equals
(
certHash
)
;
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
IsCertContentSigningRoot
(
const
nsTArray
<
uint8_t
>
&
cert
bool
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
*
result
=
false
;
if
(
cert
.
Length
(
)
>
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsTArray
<
uint8_t
>
digestArray
;
nsresult
rv
=
Digest
:
:
DigestBuf
(
SEC_OID_SHA256
cert
.
Elements
(
)
cert
.
Length
(
)
digestArray
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
SECItem
digestItem
=
{
siBuffer
digestArray
.
Elements
(
)
static_cast
<
unsigned
int
>
(
digestArray
.
Length
(
)
)
}
;
UniquePORTString
fingerprintCString
(
CERT_Hexify
(
&
digestItem
true
)
)
;
if
(
!
fingerprintCString
)
{
return
NS_ERROR_FAILURE
;
}
MutexAutoLock
lock
(
mMutex
)
;
*
result
=
mContentSigningRootHash
.
Equals
(
fingerprintCString
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
IssuerMatchesMitmCanary
(
const
char
*
aCertIssuer
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mMitmDetecionEnabled
&
&
!
mMitmCanaryIssuer
.
IsEmpty
(
)
)
{
nsString
certIssuer
=
NS_ConvertUTF8toUTF16
(
aCertIssuer
)
;
if
(
mMitmCanaryIssuer
.
Equals
(
certIssuer
)
)
{
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
SharedCertVerifier
:
:
~
SharedCertVerifier
(
)
=
default
;
NS_IMETHODIMP
nsNSSComponent
:
:
GetDefaultCertVerifier
(
SharedCertVerifier
*
*
result
)
{
MutexAutoLock
lock
(
mMutex
)
;
NS_ENSURE_ARG_POINTER
(
result
)
;
RefPtr
<
SharedCertVerifier
>
certVerifier
(
mDefaultCertVerifier
)
;
certVerifier
.
forget
(
result
)
;
return
NS_OK
;
}
void
nsNSSComponent
:
:
DoClearSSLExternalAndInternalSessionCache
(
)
{
SSL_ClearSessionCache
(
)
;
mozilla
:
:
net
:
:
SSLTokensCache
:
:
Clear
(
)
;
}
NS_IMETHODIMP
nsNSSComponent
:
:
ClearSSLExternalAndInternalSessionCache
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
mozilla
:
:
net
:
:
nsIOService
:
:
UseSocketProcess
(
)
)
{
if
(
mozilla
:
:
net
:
:
gIOService
)
{
mozilla
:
:
net
:
:
gIOService
-
>
CallOrWaitForSocketProcess
(
[
]
(
)
{
Unused
<
<
mozilla
:
:
net
:
:
SocketProcessParent
:
:
GetSingleton
(
)
-
>
SendClearSessionCache
(
)
;
}
)
;
}
}
DoClearSSLExternalAndInternalSessionCache
(
)
;
return
NS_OK
;
}
namespace
mozilla
{
namespace
psm
{
already_AddRefed
<
SharedCertVerifier
>
GetDefaultCertVerifier
(
)
{
static
NS_DEFINE_CID
(
kNSSComponentCID
NS_NSSCOMPONENT_CID
)
;
nsCOMPtr
<
nsINSSComponent
>
nssComponent
(
do_GetService
(
kNSSComponentCID
)
)
;
if
(
!
nssComponent
)
{
return
nullptr
;
}
nsresult
rv
=
nssComponent
-
>
BlockUntilLoadableCertsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
RefPtr
<
SharedCertVerifier
>
result
;
rv
=
nssComponent
-
>
GetDefaultCertVerifier
(
getter_AddRefs
(
result
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
result
.
forget
(
)
;
}
static
inline
void
CopyCertificatesTo
(
UniqueCERTCertList
&
from
UniqueCERTCertList
&
to
)
{
MOZ_ASSERT
(
from
)
;
MOZ_ASSERT
(
to
)
;
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
from
.
get
(
)
)
;
!
CERT_LIST_END
(
n
from
.
get
(
)
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
UniqueCERTCertificate
cert
(
CERT_DupCertificate
(
n
-
>
cert
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
provisionally
adding
'
%
s
'
"
n
-
>
cert
-
>
subjectName
)
)
;
if
(
CERT_AddCertToListTail
(
to
.
get
(
)
cert
.
get
(
)
)
=
=
SECSuccess
)
{
Unused
<
<
cert
.
release
(
)
;
}
}
}
UniqueCERTCertList
FindClientCertificatesWithPrivateKeys
(
)
{
TimeStamp
begin
(
TimeStamp
:
:
Now
(
)
)
;
auto
exitTelemetry
=
MakeScopeExit
(
[
&
]
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
CLIENT_CERTIFICATE_SCAN_TIME
begin
TimeStamp
:
:
Now
(
)
)
;
}
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
FindClientCertificatesWithPrivateKeys
"
)
)
;
BlockUntilLoadableCertsLoaded
(
)
;
UniqueCERTCertList
certsWithPrivateKeys
(
CERT_NewCertList
(
)
)
;
if
(
!
certsWithPrivateKeys
)
{
return
nullptr
;
}
UniquePK11SlotInfo
internalSlot
(
PK11_GetInternalKeySlot
(
)
)
;
AutoSECMODListReadLock
secmodLock
;
SECMODModuleList
*
list
=
SECMOD_GetDefaultModuleList
(
)
;
while
(
list
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
module
'
%
s
'
"
list
-
>
module
-
>
commonName
)
)
;
for
(
int
i
=
0
;
i
<
list
-
>
module
-
>
slotCount
;
i
+
+
)
{
PK11SlotInfo
*
slot
=
list
-
>
module
-
>
slots
[
i
]
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
slot
'
%
s
'
"
PK11_GetSlotName
(
slot
)
)
)
;
if
(
internalSlot
.
get
(
)
=
=
slot
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
looking
at
internal
slot
)
"
)
)
;
if
(
PK11_Authenticate
(
slot
true
nullptr
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
couldn
'
t
authenticate
)
"
)
)
;
continue
;
}
UniqueSECKEYPrivateKeyList
privateKeys
(
PK11_ListPrivKeysInSlot
(
slot
nullptr
nullptr
)
)
;
if
(
!
privateKeys
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
no
private
keys
)
"
)
)
;
continue
;
}
for
(
SECKEYPrivateKeyListNode
*
node
=
PRIVKEY_LIST_HEAD
(
privateKeys
)
;
!
PRIVKEY_LIST_END
(
node
privateKeys
)
;
node
=
PRIVKEY_LIST_NEXT
(
node
)
)
{
UniqueCERTCertList
certs
(
PK11_GetCertsMatchingPrivateKey
(
node
-
>
key
)
)
;
if
(
!
certs
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
PK11_GetCertsMatchingPrivateKey
encountered
an
"
"
error
"
)
)
;
continue
;
}
if
(
CERT_LIST_EMPTY
(
certs
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
no
certs
for
key
)
"
)
)
;
continue
;
}
CopyCertificatesTo
(
certs
certsWithPrivateKeys
)
;
}
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
looking
at
non
-
internal
slot
)
"
)
)
;
if
(
!
PK11_IsPresent
(
slot
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
not
present
)
"
)
)
;
continue
;
}
if
(
!
PK11_IsFriendly
(
slot
)
&
&
PK11_Authenticate
(
slot
true
nullptr
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
couldn
'
t
authenticate
)
"
)
)
;
continue
;
}
UniqueCERTCertList
certsInSlot
(
PK11_ListCertsInSlot
(
slot
)
)
;
if
(
!
certsInSlot
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
couldn
'
t
list
certs
in
slot
)
"
)
)
;
continue
;
}
if
(
CERT_FilterCertListForUserCerts
(
certsInSlot
.
get
(
)
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
(
couldn
'
t
filter
certs
)
"
)
)
;
continue
;
}
CopyCertificatesTo
(
certsInSlot
certsWithPrivateKeys
)
;
}
}
list
=
list
-
>
next
;
}
if
(
CERT_FilterCertListByUsage
(
certsWithPrivateKeys
.
get
(
)
certUsageSSLClient
false
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CERT_FilterCertListByUsage
encountered
an
error
-
returning
"
)
)
;
return
nullptr
;
}
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPIPNSSLog
LogLevel
:
:
Debug
)
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
returning
:
"
)
)
;
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
certsWithPrivateKeys
)
;
!
CERT_LIST_END
(
n
certsWithPrivateKeys
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
%
s
"
n
-
>
cert
-
>
subjectName
)
)
;
}
}
if
(
CERT_LIST_EMPTY
(
certsWithPrivateKeys
)
)
{
return
nullptr
;
}
return
certsWithPrivateKeys
;
}
}
}
NS_IMPL_ISUPPORTS
(
PipUIContext
nsIInterfaceRequestor
)
PipUIContext
:
:
PipUIContext
(
)
=
default
;
PipUIContext
:
:
~
PipUIContext
(
)
=
default
;
NS_IMETHODIMP
PipUIContext
:
:
GetInterface
(
const
nsIID
&
uuid
void
*
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
*
result
=
nullptr
;
if
(
!
NS_IsMainThread
(
)
)
{
NS_ERROR
(
"
PipUIContext
:
:
GetInterface
called
off
the
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
!
uuid
.
Equals
(
NS_GET_IID
(
nsIPrompt
)
)
)
return
NS_ERROR_NO_INTERFACE
;
nsIPrompt
*
prompt
=
nullptr
;
nsresult
rv
=
nsNSSComponent
:
:
GetNewPrompter
(
&
prompt
)
;
*
result
=
prompt
;
return
rv
;
}
nsresult
getNSSDialogs
(
void
*
*
_result
REFNSIID
aIID
const
char
*
contract
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_ERROR
(
"
getNSSDialogs
called
off
the
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
svc
=
do_GetService
(
contract
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
svc
-
>
QueryInterface
(
aIID
_result
)
;
return
rv
;
}
nsresult
setPassword
(
PK11SlotInfo
*
slot
nsIInterfaceRequestor
*
ctx
)
{
MOZ_ASSERT
(
slot
)
;
MOZ_ASSERT
(
ctx
)
;
NS_ENSURE_ARG_POINTER
(
slot
)
;
NS_ENSURE_ARG_POINTER
(
ctx
)
;
if
(
PK11_NeedUserInit
(
slot
)
)
{
nsCOMPtr
<
nsITokenPasswordDialogs
>
dialogs
;
nsresult
rv
=
getNSSDialogs
(
getter_AddRefs
(
dialogs
)
NS_GET_IID
(
nsITokenPasswordDialogs
)
NS_TOKENPASSWORDSDIALOG_CONTRACTID
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
canceled
;
nsCOMPtr
<
nsIPK11Token
>
token
=
new
nsPK11Token
(
slot
)
;
rv
=
dialogs
-
>
SetPassword
(
ctx
token
&
canceled
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
canceled
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
return
NS_OK
;
}
static
PRBool
ConvertBetweenUCS2andASCII
(
PRBool
toUnicode
unsigned
char
*
inBuf
unsigned
int
inBufLen
unsigned
char
*
outBuf
unsigned
int
maxOutBufLen
unsigned
int
*
outBufLen
PRBool
swapBytes
)
{
std
:
:
unique_ptr
<
unsigned
char
[
]
>
inBufDup
(
new
unsigned
char
[
inBufLen
]
)
;
if
(
!
inBufDup
)
{
return
PR_FALSE
;
}
std
:
:
memcpy
(
inBufDup
.
get
(
)
inBuf
inBufLen
*
sizeof
(
unsigned
char
)
)
;
if
(
!
toUnicode
&
&
swapBytes
)
{
if
(
inBufLen
%
2
!
=
0
)
{
return
PR_FALSE
;
}
mozilla
:
:
NativeEndian
:
:
swapFromLittleEndianInPlace
(
reinterpret_cast
<
char16_t
*
>
(
inBufDup
.
get
(
)
)
inBufLen
/
2
)
;
}
return
PORT_UCS2_UTF8Conversion
(
toUnicode
inBufDup
.
get
(
)
inBufLen
outBuf
maxOutBufLen
outBufLen
)
;
}
namespace
mozilla
{
namespace
psm
{
nsresult
InitializeCipherSuite
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
InitializeCipherSuite
(
)
can
only
be
accessed
on
the
main
thread
"
)
;
if
(
NSS_SetDomesticPolicy
(
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
for
(
uint16_t
i
=
0
;
i
<
SSL_NumImplementedCiphers
;
+
+
i
)
{
uint16_t
cipher_id
=
SSL_ImplementedCiphers
[
i
]
;
SSL_CipherPrefSetDefault
(
cipher_id
false
)
;
}
for
(
const
auto
&
cipherPref
:
sCipherPrefs
)
{
bool
cipherEnabled
=
Preferences
:
:
GetBool
(
cipherPref
.
pref
cipherPref
.
enabledByDefault
)
;
SSL_CipherPrefSetDefault
(
cipherPref
.
id
cipherEnabled
)
;
}
SetDeprecatedTLS1CipherPrefs
(
)
;
SEC_PKCS12EnableCipher
(
PKCS12_RC4_40
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_RC4_128
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_RC2_CBC_40
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_RC2_CBC_128
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_DES_56
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_DES_EDE3_168
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_AES_CBC_128
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_AES_CBC_192
1
)
;
SEC_PKCS12EnableCipher
(
PKCS12_AES_CBC_256
1
)
;
SEC_PKCS12SetPreferredCipher
(
PKCS12_DES_EDE3_168
1
)
;
PORT_SetUCS2_ASCIIConversionFunction
(
ConvertBetweenUCS2andASCII
)
;
NSS_OptionSet
(
NSS_RSA_MIN_KEY_SIZE
512
)
;
return
CipherSuiteChangeObserver
:
:
StartObserve
(
)
;
}
}
}
