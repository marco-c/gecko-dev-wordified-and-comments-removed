#
include
"
PublicKeyPinningService
.
h
"
#
include
"
RootCertificateTelemetryUtils
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsDependentString
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsSiteSecurityService
.
h
"
#
include
"
mozpkix
/
pkixtypes
.
h
"
#
include
"
seccomon
.
h
"
#
include
"
sechash
.
h
"
#
include
"
StaticHPKPins
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
LazyLogModule
gPublicKeyPinningLog
(
"
PublicKeyPinningService
"
)
;
static
nsresult
GetBase64HashSPKI
(
const
CERTCertificate
*
cert
nsACString
&
hashSPKIDigest
)
{
hashSPKIDigest
.
Truncate
(
)
;
Digest
digest
;
nsresult
rv
=
digest
.
DigestBuf
(
SEC_OID_SHA256
cert
-
>
derPublicKey
.
data
cert
-
>
derPublicKey
.
len
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
Base64Encode
(
nsDependentCSubstring
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
digest
.
get
(
)
.
data
)
digest
.
get
(
)
.
len
)
hashSPKIDigest
)
;
}
static
nsresult
EvalCert
(
const
CERTCertificate
*
cert
const
StaticFingerprints
*
fingerprints
const
nsTArray
<
nsCString
>
*
dynamicFingerprints
bool
&
certMatchesPinset
)
{
certMatchesPinset
=
false
;
if
(
!
fingerprints
&
&
!
dynamicFingerprints
)
{
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
No
hashes
found
\
n
"
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
base64Out
;
nsresult
rv
=
GetBase64HashSPKI
(
cert
base64Out
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
GetBase64HashSPKI
failed
!
\
n
"
)
)
;
return
rv
;
}
if
(
fingerprints
)
{
for
(
size_t
i
=
0
;
i
<
fingerprints
-
>
size
;
i
+
+
)
{
if
(
base64Out
.
Equals
(
fingerprints
-
>
data
[
i
]
)
)
{
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
found
pin
base_64
=
'
%
s
'
\
n
"
base64Out
.
get
(
)
)
)
;
certMatchesPinset
=
true
;
return
NS_OK
;
}
}
}
if
(
dynamicFingerprints
)
{
for
(
size_t
i
=
0
;
i
<
dynamicFingerprints
-
>
Length
(
)
;
i
+
+
)
{
if
(
base64Out
.
Equals
(
(
*
dynamicFingerprints
)
[
i
]
)
)
{
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
found
pin
base_64
=
'
%
s
'
\
n
"
base64Out
.
get
(
)
)
)
;
certMatchesPinset
=
true
;
return
NS_OK
;
}
}
}
return
NS_OK
;
}
static
nsresult
EvalChain
(
const
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
certList
const
StaticFingerprints
*
fingerprints
const
nsTArray
<
nsCString
>
*
dynamicFingerprints
bool
&
certListIntersectsPinset
)
{
certListIntersectsPinset
=
false
;
if
(
!
fingerprints
&
&
!
dynamicFingerprints
)
{
MOZ_ASSERT
(
false
"
Must
pass
in
at
least
one
type
of
pinset
"
)
;
return
NS_ERROR_FAILURE
;
}
for
(
const
auto
&
cert
:
certList
)
{
UniqueCERTCertificate
nssCert
(
cert
-
>
GetCert
(
)
)
;
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
certArray
subject
:
'
%
s
'
\
n
"
nssCert
-
>
subjectName
)
)
;
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
certArray
issuer
:
'
%
s
'
\
n
"
nssCert
-
>
issuerName
)
)
;
nsresult
rv
=
EvalCert
(
nssCert
.
get
(
)
fingerprints
dynamicFingerprints
certListIntersectsPinset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
certListIntersectsPinset
)
{
break
;
}
}
if
(
!
certListIntersectsPinset
)
{
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
no
matches
found
\
n
"
)
)
;
}
return
NS_OK
;
}
class
TransportSecurityPreloadBinarySearchComparator
{
public
:
explicit
TransportSecurityPreloadBinarySearchComparator
(
const
char
*
aTargetHost
)
:
mTargetHost
(
aTargetHost
)
{
}
int
operator
(
)
(
const
TransportSecurityPreload
&
val
)
const
{
return
strcmp
(
mTargetHost
val
.
mHost
)
;
}
private
:
const
char
*
mTargetHost
;
}
;
nsresult
PublicKeyPinningService
:
:
ChainMatchesPinset
(
const
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
certList
const
nsTArray
<
nsCString
>
&
aSHA256keys
bool
&
chainMatchesPinset
)
{
return
EvalChain
(
certList
nullptr
&
aSHA256keys
chainMatchesPinset
)
;
}
#
ifdef
DEBUG
static
Atomic
<
bool
>
sValidatedPinningPreloadList
(
false
)
;
static
void
ValidatePinningPreloadList
(
)
{
if
(
sValidatedPinningPreloadList
)
{
return
;
}
for
(
const
auto
&
entry
:
kPublicKeyPinningPreloadList
)
{
MOZ_ASSERT
(
(
entry
.
mIsMoz
&
&
entry
.
mId
!
=
kUnknownId
)
|
|
(
!
entry
.
mIsMoz
&
&
entry
.
mId
=
=
kUnknownId
)
)
;
}
sValidatedPinningPreloadList
=
true
;
}
#
endif
static
nsresult
FindPinningInformation
(
const
char
*
hostname
mozilla
:
:
pkix
:
:
Time
time
const
OriginAttributes
&
originAttributes
nsTArray
<
nsCString
>
&
dynamicFingerprints
const
TransportSecurityPreload
*
&
staticFingerprints
)
{
#
ifdef
DEBUG
ValidatePinningPreloadList
(
)
;
#
endif
if
(
!
hostname
|
|
hostname
[
0
]
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
staticFingerprints
=
nullptr
;
dynamicFingerprints
.
Clear
(
)
;
nsCOMPtr
<
nsISiteSecurityService
>
sssService
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
)
;
if
(
!
sssService
)
{
return
NS_ERROR_FAILURE
;
}
const
TransportSecurityPreload
*
foundEntry
=
nullptr
;
const
char
*
evalHost
=
hostname
;
const
char
*
evalPart
;
while
(
!
foundEntry
&
&
(
evalPart
=
strchr
(
evalHost
'
.
'
)
)
)
{
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
Querying
pinsets
for
host
:
'
%
s
'
\
n
"
evalHost
)
)
;
nsresult
rv
;
bool
found
;
bool
includeSubdomains
;
nsTArray
<
nsCString
>
pinArray
;
rv
=
sssService
-
>
GetKeyPinsForHostname
(
nsDependentCString
(
evalHost
)
time
originAttributes
pinArray
&
includeSubdomains
&
found
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
found
&
&
(
evalHost
=
=
hostname
|
|
includeSubdomains
)
)
{
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
Found
dyn
match
for
host
:
'
%
s
'
\
n
"
evalHost
)
)
;
dynamicFingerprints
=
pinArray
;
return
NS_OK
;
}
size_t
foundEntryIndex
;
if
(
BinarySearchIf
(
kPublicKeyPinningPreloadList
0
ArrayLength
(
kPublicKeyPinningPreloadList
)
TransportSecurityPreloadBinarySearchComparator
(
evalHost
)
&
foundEntryIndex
)
)
{
foundEntry
=
&
kPublicKeyPinningPreloadList
[
foundEntryIndex
]
;
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
Found
pinset
for
host
:
'
%
s
'
\
n
"
evalHost
)
)
;
if
(
evalHost
!
=
hostname
)
{
if
(
!
foundEntry
-
>
mIncludeSubdomains
)
{
foundEntry
=
nullptr
;
}
}
}
else
{
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
Didn
'
t
find
pinset
for
host
:
'
%
s
'
\
n
"
evalHost
)
)
;
}
evalHost
=
evalPart
+
1
;
}
if
(
foundEntry
&
&
foundEntry
-
>
pinset
)
{
if
(
time
>
TimeFromEpochInSeconds
(
kPreloadPKPinsExpirationTime
/
PR_USEC_PER_SEC
)
)
{
return
NS_OK
;
}
staticFingerprints
=
foundEntry
;
}
return
NS_OK
;
}
static
nsresult
CheckPinsForHostname
(
const
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
certList
const
char
*
hostname
bool
enforceTestMode
mozilla
:
:
pkix
:
:
Time
time
const
OriginAttributes
&
originAttributes
bool
&
chainHasValidPins
PinningTelemetryInfo
*
pinningTelemetryInfo
)
{
chainHasValidPins
=
false
;
if
(
certList
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
hostname
|
|
hostname
[
0
]
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsTArray
<
nsCString
>
dynamicFingerprints
;
const
TransportSecurityPreload
*
staticFingerprints
=
nullptr
;
nsresult
rv
=
FindPinningInformation
(
hostname
time
originAttributes
dynamicFingerprints
staticFingerprints
)
;
if
(
dynamicFingerprints
.
Length
(
)
=
=
0
&
&
!
staticFingerprints
)
{
chainHasValidPins
=
true
;
return
NS_OK
;
}
if
(
dynamicFingerprints
.
Length
(
)
>
0
)
{
return
EvalChain
(
certList
nullptr
&
dynamicFingerprints
chainHasValidPins
)
;
}
if
(
staticFingerprints
)
{
bool
enforceTestModeResult
;
rv
=
EvalChain
(
certList
staticFingerprints
-
>
pinset
nullptr
enforceTestModeResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
chainHasValidPins
=
enforceTestModeResult
;
if
(
staticFingerprints
-
>
mTestMode
&
&
!
enforceTestMode
)
{
chainHasValidPins
=
true
;
}
if
(
pinningTelemetryInfo
)
{
if
(
(
staticFingerprints
-
>
mIsMoz
&
&
staticFingerprints
-
>
mId
=
=
kUnknownId
)
|
|
(
!
staticFingerprints
-
>
mIsMoz
&
&
staticFingerprints
-
>
mId
!
=
kUnknownId
)
)
{
return
NS_ERROR_FAILURE
;
}
Telemetry
:
:
HistogramID
histogram
;
int32_t
bucket
;
if
(
staticFingerprints
-
>
mIsMoz
)
{
histogram
=
staticFingerprints
-
>
mTestMode
?
Telemetry
:
:
CERT_PINNING_MOZ_TEST_RESULTS_BY_HOST
:
Telemetry
:
:
CERT_PINNING_MOZ_RESULTS_BY_HOST
;
bucket
=
staticFingerprints
-
>
mId
*
2
+
(
enforceTestModeResult
?
1
:
0
)
;
}
else
{
histogram
=
staticFingerprints
-
>
mTestMode
?
Telemetry
:
:
CERT_PINNING_TEST_RESULTS
:
Telemetry
:
:
CERT_PINNING_RESULTS
;
bucket
=
enforceTestModeResult
?
1
:
0
;
}
pinningTelemetryInfo
-
>
accumulateResult
=
true
;
pinningTelemetryInfo
-
>
certPinningResultHistogram
=
Some
(
histogram
)
;
pinningTelemetryInfo
-
>
certPinningResultBucket
=
bucket
;
if
(
!
enforceTestModeResult
)
{
nsCOMPtr
<
nsIX509Cert
>
rootCert
;
rv
=
nsNSSCertificate
:
:
GetRootCertificate
(
certList
rootCert
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
rootCert
)
{
UniqueCERTCertificate
rootCertObj
(
rootCert
-
>
GetCert
(
)
)
;
if
(
!
rootCertObj
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
binNumber
=
RootCABinNumber
(
&
rootCertObj
-
>
derCert
rootCertObj
-
>
slot
)
;
if
(
binNumber
!
=
ROOT_CERTIFICATE_UNKNOWN
)
{
pinningTelemetryInfo
-
>
accumulateForRoot
=
true
;
pinningTelemetryInfo
-
>
rootBucket
=
binNumber
;
}
}
}
}
MOZ_LOG
(
gPublicKeyPinningLog
LogLevel
:
:
Debug
(
"
pkpin
:
Pin
check
%
s
for
%
s
host
'
%
s
'
(
mode
=
%
s
)
\
n
"
enforceTestModeResult
?
"
passed
"
:
"
failed
"
staticFingerprints
-
>
mIsMoz
?
"
mozilla
"
:
"
non
-
mozilla
"
hostname
staticFingerprints
-
>
mTestMode
?
"
test
"
:
"
production
"
)
)
;
}
return
NS_OK
;
}
nsresult
PublicKeyPinningService
:
:
ChainHasValidPins
(
const
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
certList
const
char
*
hostname
mozilla
:
:
pkix
:
:
Time
time
bool
enforceTestMode
const
OriginAttributes
&
originAttributes
bool
&
chainHasValidPins
PinningTelemetryInfo
*
pinningTelemetryInfo
)
{
chainHasValidPins
=
false
;
if
(
certList
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
hostname
|
|
hostname
[
0
]
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
canonicalizedHostname
(
CanonicalizeHostname
(
hostname
)
)
;
return
CheckPinsForHostname
(
certList
canonicalizedHostname
.
get
(
)
enforceTestMode
time
originAttributes
chainHasValidPins
pinningTelemetryInfo
)
;
}
nsresult
PublicKeyPinningService
:
:
HostHasPins
(
const
char
*
hostname
mozilla
:
:
pkix
:
:
Time
time
bool
enforceTestMode
const
OriginAttributes
&
originAttributes
bool
&
hostHasPins
)
{
hostHasPins
=
false
;
nsAutoCString
canonicalizedHostname
(
CanonicalizeHostname
(
hostname
)
)
;
nsTArray
<
nsCString
>
dynamicFingerprints
;
const
TransportSecurityPreload
*
staticFingerprints
=
nullptr
;
nsresult
rv
=
FindPinningInformation
(
canonicalizedHostname
.
get
(
)
time
originAttributes
dynamicFingerprints
staticFingerprints
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
dynamicFingerprints
.
Length
(
)
>
0
)
{
hostHasPins
=
true
;
}
else
if
(
staticFingerprints
)
{
hostHasPins
=
!
staticFingerprints
-
>
mTestMode
|
|
enforceTestMode
;
}
return
NS_OK
;
}
nsAutoCString
PublicKeyPinningService
:
:
CanonicalizeHostname
(
const
char
*
hostname
)
{
nsAutoCString
canonicalizedHostname
(
hostname
)
;
ToLowerCase
(
canonicalizedHostname
)
;
while
(
canonicalizedHostname
.
Length
(
)
>
0
&
&
canonicalizedHostname
.
Last
(
)
=
=
'
.
'
)
{
canonicalizedHostname
.
Truncate
(
canonicalizedHostname
.
Length
(
)
-
1
)
;
}
return
canonicalizedHostname
;
}
