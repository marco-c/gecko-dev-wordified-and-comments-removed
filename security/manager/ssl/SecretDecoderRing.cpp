#
include
"
SecretDecoderRing
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsITokenPasswordDialogs
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsNSSHelper
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsPK11TokenDB
.
h
"
#
include
"
pk11func
.
h
"
#
include
"
pk11sdr
.
h
"
static
mozilla
:
:
LazyLogModule
gSDRLog
(
"
sdrlog
"
)
;
using
namespace
mozilla
;
using
dom
:
:
Promise
;
NS_IMPL_ISUPPORTS
(
SecretDecoderRing
nsISecretDecoderRing
)
void
BackgroundSdrEncryptStrings
(
const
nsTArray
<
nsCString
>
&
plaintexts
RefPtr
<
Promise
>
&
aPromise
)
{
nsCOMPtr
<
nsISecretDecoderRing
>
sdrService
=
do_GetService
(
NS_SECRETDECODERRING_CONTRACTID
)
;
nsTArray
<
nsString
>
cipherTexts
(
plaintexts
.
Length
(
)
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
for
(
const
auto
&
plaintext
:
plaintexts
)
{
nsCString
cipherText
;
rv
=
sdrService
-
>
EncryptString
(
plaintext
cipherText
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
break
;
}
cipherTexts
.
AppendElement
(
NS_ConvertASCIItoUTF16
(
cipherText
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
BackgroundSdrEncryptStringsResolve
"
[
rv
aPromise
=
std
:
:
move
(
aPromise
)
cipherTexts
=
std
:
:
move
(
cipherTexts
)
]
(
)
{
if
(
NS_FAILED
(
rv
)
)
{
aPromise
-
>
MaybeReject
(
rv
)
;
}
else
{
aPromise
-
>
MaybeResolve
(
cipherTexts
)
;
}
}
)
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
void
BackgroundSdrDecryptStrings
(
const
nsTArray
<
nsCString
>
&
encryptedStrings
RefPtr
<
Promise
>
&
aPromise
)
{
nsCOMPtr
<
nsISecretDecoderRing
>
sdrService
=
do_GetService
(
NS_SECRETDECODERRING_CONTRACTID
)
;
nsTArray
<
nsString
>
plainTexts
(
encryptedStrings
.
Length
(
)
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
for
(
const
auto
&
encryptedString
:
encryptedStrings
)
{
nsCString
plainText
;
rv
=
sdrService
-
>
DecryptString
(
encryptedString
plainText
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
break
;
}
MOZ_LOG
(
gSDRLog
LogLevel
:
:
Warning
(
"
Couldn
'
t
decrypt
string
:
%
s
"
encryptedString
.
get
(
)
)
)
;
plainTexts
.
AppendElement
(
nullptr
)
;
rv
=
NS_OK
;
continue
;
}
plainTexts
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
plainText
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
BackgroundSdrDecryptStringsResolve
"
[
rv
aPromise
=
std
:
:
move
(
aPromise
)
plainTexts
=
std
:
:
move
(
plainTexts
)
]
(
)
{
if
(
NS_FAILED
(
rv
)
)
{
aPromise
-
>
MaybeReject
(
rv
)
;
}
else
{
aPromise
-
>
MaybeResolve
(
plainTexts
)
;
}
}
)
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
nsresult
SecretDecoderRing
:
:
Encrypt
(
const
nsACString
&
data
nsACString
&
result
)
{
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
ctx
=
new
PipUIContext
(
)
;
nsresult
rv
=
setPassword
(
slot
.
get
(
)
ctx
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
PK11_Authenticate
(
slot
.
get
(
)
true
ctx
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
SECItem
keyid
;
keyid
.
data
=
nullptr
;
keyid
.
len
=
0
;
SECItem
request
;
request
.
data
=
BitwiseCast
<
unsigned
char
*
const
char
*
>
(
data
.
BeginReading
(
)
)
;
request
.
len
=
data
.
Length
(
)
;
ScopedAutoSECItem
reply
;
if
(
PK11SDR_Encrypt
(
&
keyid
&
request
&
reply
ctx
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
result
.
Assign
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
reply
.
data
)
reply
.
len
)
;
return
NS_OK
;
}
nsresult
SecretDecoderRing
:
:
Decrypt
(
const
nsACString
&
data
nsACString
&
result
)
{
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
ctx
=
new
PipUIContext
(
)
;
if
(
PK11_Authenticate
(
slot
.
get
(
)
true
ctx
)
!
=
SECSuccess
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
SECItem
request
;
request
.
data
=
BitwiseCast
<
unsigned
char
*
const
char
*
>
(
data
.
BeginReading
(
)
)
;
request
.
len
=
data
.
Length
(
)
;
ScopedAutoSECItem
reply
;
if
(
PK11SDR_Decrypt
(
&
request
&
reply
ctx
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
result
.
Assign
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
reply
.
data
)
reply
.
len
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SecretDecoderRing
:
:
EncryptString
(
const
nsACString
&
text
nsACString
&
encryptedBase64Text
)
{
nsAutoCString
encryptedText
;
nsresult
rv
=
Encrypt
(
text
encryptedText
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
Base64Encode
(
encryptedText
encryptedBase64Text
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SecretDecoderRing
:
:
AsyncEncryptStrings
(
const
nsTArray
<
nsCString
>
&
plaintexts
JSContext
*
aCx
Promise
*
*
aPromise
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
!
plaintexts
.
IsEmpty
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aCx
)
;
NS_ENSURE_ARG_POINTER
(
aPromise
)
;
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
BackgroundSdrEncryptStrings
"
[
promise
plaintexts
]
(
)
mutable
{
BackgroundSdrEncryptStrings
(
plaintexts
promise
)
;
}
)
)
;
nsCOMPtr
<
nsIEventTarget
>
target
(
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
)
;
if
(
!
target
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
target
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SecretDecoderRing
:
:
DecryptString
(
const
nsACString
&
encryptedBase64Text
nsACString
&
decryptedText
)
{
nsAutoCString
encryptedText
;
nsresult
rv
=
Base64Decode
(
encryptedBase64Text
encryptedText
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
Decrypt
(
encryptedText
decryptedText
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SecretDecoderRing
:
:
AsyncDecryptStrings
(
const
nsTArray
<
nsCString
>
&
encryptedStrings
JSContext
*
aCx
Promise
*
*
aPromise
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG
(
!
encryptedStrings
.
IsEmpty
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aCx
)
;
NS_ENSURE_ARG_POINTER
(
aPromise
)
;
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
BackgroundSdrDecryptStrings
"
[
promise
encryptedStrings
]
(
)
mutable
{
BackgroundSdrDecryptStrings
(
encryptedStrings
promise
)
;
}
)
)
;
nsCOMPtr
<
nsIEventTarget
>
target
(
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
)
;
if
(
!
target
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
target
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SecretDecoderRing
:
:
ChangePassword
(
)
{
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIPK11Token
>
token
=
new
nsPK11Token
(
slot
.
get
(
)
)
;
nsCOMPtr
<
nsITokenPasswordDialogs
>
dialogs
;
nsresult
rv
=
getNSSDialogs
(
getter_AddRefs
(
dialogs
)
NS_GET_IID
(
nsITokenPasswordDialogs
)
NS_TOKENPASSWORDSDIALOG_CONTRACTID
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
ctx
=
new
PipUIContext
(
)
;
bool
canceled
;
return
dialogs
-
>
SetPassword
(
ctx
token
&
canceled
)
;
}
NS_IMETHODIMP
SecretDecoderRing
:
:
Logout
(
)
{
PK11_LogoutAll
(
)
;
nsNSSComponent
:
:
ClearSSLExternalAndInternalSessionCacheNative
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SecretDecoderRing
:
:
LogoutAndTeardown
(
)
{
static
NS_DEFINE_CID
(
kNSSComponentCID
NS_NSSCOMPONENT_CID
)
;
PK11_LogoutAll
(
)
;
nsNSSComponent
:
:
ClearSSLExternalAndInternalSessionCacheNative
(
)
;
nsresult
rv
;
nsCOMPtr
<
nsINSSComponent
>
nssComponent
(
do_GetService
(
kNSSComponentCID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
nssComponent
-
>
LogoutAuthenticatedPK11
(
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
net
:
prune
-
dead
-
connections
"
nullptr
)
;
}
return
rv
;
}
