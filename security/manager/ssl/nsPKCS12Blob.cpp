#
include
"
nsPKCS12Blob
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsICertificateDialogs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsNSSCertHelper
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNSSHelper
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
pkix
/
pkixtypes
.
h
"
#
include
"
secerr
.
h
"
using
namespace
mozilla
;
extern
LazyLogModule
gPIPNSSLog
;
#
define
PIP_PKCS12_TMPFILENAME
NS_LITERAL_CSTRING
(
"
.
pip_p12tmp
"
)
#
define
PIP_PKCS12_BUFFER_SIZE
2048
#
define
PIP_PKCS12_USER_CANCELED
3
#
define
PIP_PKCS12_NOSMARTCARD_EXPORT
4
#
define
PIP_PKCS12_RESTORE_FAILED
5
#
define
PIP_PKCS12_BACKUP_FAILED
6
#
define
PIP_PKCS12_NSS_ERROR
7
nsPKCS12Blob
:
:
nsPKCS12Blob
(
)
:
mCertArray
(
nullptr
)
mTmpFile
(
nullptr
)
{
mUIContext
=
new
PipUIContext
(
)
;
}
nsresult
nsPKCS12Blob
:
:
ImportFromFile
(
nsIFile
*
file
)
{
nsresult
rv
=
NS_OK
;
RetryReason
wantRetry
;
do
{
rv
=
ImportFromFileHelper
(
file
im_standard_prompt
wantRetry
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
wantRetry
=
=
rr_auto_retry_empty_password_flavors
)
{
rv
=
ImportFromFileHelper
(
file
im_try_zero_length_secitem
wantRetry
)
;
}
}
while
(
NS_SUCCEEDED
(
rv
)
&
&
(
wantRetry
!
=
rr_do_not_retry
)
)
;
return
rv
;
}
nsresult
nsPKCS12Blob
:
:
ImportFromFileHelper
(
nsIFile
*
file
nsPKCS12Blob
:
:
ImportMode
aImportMode
nsPKCS12Blob
:
:
RetryReason
&
aWantRetry
)
{
nsresult
rv
=
NS_OK
;
SECStatus
srv
=
SECSuccess
;
SEC_PKCS12DecoderContext
*
dcx
=
nullptr
;
SECItem
unicodePw
=
{
siBuffer
nullptr
0
}
;
aWantRetry
=
rr_do_not_retry
;
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
srv
=
SECFailure
;
goto
finish
;
}
if
(
aImportMode
=
=
im_try_zero_length_secitem
)
{
unicodePw
.
len
=
0
;
}
else
{
rv
=
getPKCS12FilePassword
(
&
unicodePw
)
;
if
(
NS_FAILED
(
rv
)
)
goto
finish
;
if
(
!
unicodePw
.
data
)
{
handleError
(
PIP_PKCS12_USER_CANCELED
)
;
return
NS_OK
;
}
}
dcx
=
SEC_PKCS12DecoderStart
(
&
unicodePw
slot
.
get
(
)
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
)
;
if
(
!
dcx
)
{
srv
=
SECFailure
;
goto
finish
;
}
rv
=
inputToDecoder
(
dcx
file
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
NS_ERROR_ABORT
=
=
rv
)
{
srv
=
SECFailure
;
}
goto
finish
;
}
srv
=
SEC_PKCS12DecoderVerify
(
dcx
)
;
if
(
srv
)
goto
finish
;
srv
=
SEC_PKCS12DecoderValidateBags
(
dcx
nickname_collision
)
;
if
(
srv
)
goto
finish
;
srv
=
SEC_PKCS12DecoderImportBags
(
dcx
)
;
if
(
srv
)
goto
finish
;
finish
:
if
(
srv
!
=
SECSuccess
)
{
if
(
SEC_ERROR_BAD_PASSWORD
=
=
PORT_GetError
(
)
)
{
if
(
unicodePw
.
len
=
=
sizeof
(
char16_t
)
)
{
aWantRetry
=
rr_auto_retry_empty_password_flavors
;
}
else
{
aWantRetry
=
rr_bad_password
;
handleError
(
PIP_PKCS12_NSS_ERROR
)
;
}
}
else
{
handleError
(
PIP_PKCS12_NSS_ERROR
)
;
}
}
else
if
(
NS_FAILED
(
rv
)
)
{
handleError
(
PIP_PKCS12_RESTORE_FAILED
)
;
}
if
(
dcx
)
SEC_PKCS12DecoderFinish
(
dcx
)
;
SECITEM_ZfreeItem
(
&
unicodePw
false
)
;
return
NS_OK
;
}
static
bool
isExtractable
(
SECKEYPrivateKey
*
privKey
)
{
ScopedAutoSECItem
value
;
SECStatus
rv
=
PK11_ReadRawAttribute
(
PK11_TypePrivKey
privKey
CKA_EXTRACTABLE
&
value
)
;
if
(
rv
!
=
SECSuccess
)
{
return
false
;
}
bool
isExtractable
=
false
;
if
(
(
value
.
len
=
=
1
)
&
&
value
.
data
)
{
isExtractable
=
!
!
(
*
(
CK_BBOOL
*
)
value
.
data
)
;
}
return
isExtractable
;
}
nsresult
nsPKCS12Blob
:
:
ExportToFile
(
nsIFile
*
file
nsIX509Cert
*
*
certs
int
numCerts
)
{
nsresult
rv
;
SECStatus
srv
=
SECSuccess
;
SEC_PKCS12ExportContext
*
ecx
=
nullptr
;
SEC_PKCS12SafeInfo
*
certSafe
=
nullptr
*
keySafe
=
nullptr
;
SECItem
unicodePw
;
nsAutoString
filePath
;
int
i
;
nsCOMPtr
<
nsIFile
>
localFileRef
;
bool
InformedUserNoSmartcardBackup
=
false
;
int
numCertsExported
=
0
;
unicodePw
.
data
=
nullptr
;
rv
=
newPKCS12FilePassword
(
&
unicodePw
)
;
if
(
NS_FAILED
(
rv
)
)
goto
finish
;
if
(
!
unicodePw
.
data
)
{
handleError
(
PIP_PKCS12_USER_CANCELED
)
;
return
NS_OK
;
}
ecx
=
SEC_PKCS12CreateExportContext
(
nullptr
nullptr
nullptr
nullptr
)
;
if
(
!
ecx
)
{
srv
=
SECFailure
;
goto
finish
;
}
srv
=
SEC_PKCS12AddPasswordIntegrity
(
ecx
&
unicodePw
SEC_OID_SHA1
)
;
if
(
srv
)
goto
finish
;
for
(
i
=
0
;
i
<
numCerts
;
i
+
+
)
{
nsNSSCertificate
*
cert
=
(
nsNSSCertificate
*
)
certs
[
i
]
;
UniqueCERTCertificate
nssCert
(
cert
-
>
GetCert
(
)
)
;
if
(
!
nssCert
)
{
rv
=
NS_ERROR_FAILURE
;
goto
finish
;
}
if
(
nssCert
-
>
slot
&
&
!
PK11_IsInternal
(
nssCert
-
>
slot
)
)
{
SECKEYPrivateKey
*
privKey
=
PK11_FindKeyByDERCert
(
nssCert
-
>
slot
nssCert
.
get
(
)
this
)
;
if
(
privKey
)
{
bool
privKeyIsExtractable
=
isExtractable
(
privKey
)
;
SECKEY_DestroyPrivateKey
(
privKey
)
;
if
(
!
privKeyIsExtractable
)
{
if
(
!
InformedUserNoSmartcardBackup
)
{
InformedUserNoSmartcardBackup
=
true
;
handleError
(
PIP_PKCS12_NOSMARTCARD_EXPORT
)
;
}
continue
;
}
}
}
keySafe
=
SEC_PKCS12CreateUnencryptedSafe
(
ecx
)
;
if
(
!
SEC_PKCS12IsEncryptionAllowed
(
)
|
|
PK11_IsFIPS
(
)
)
{
certSafe
=
keySafe
;
}
else
{
certSafe
=
SEC_PKCS12CreatePasswordPrivSafe
(
ecx
&
unicodePw
SEC_OID_PKCS12_V2_PBE_WITH_SHA1_AND_40_BIT_RC2_CBC
)
;
}
if
(
!
certSafe
|
|
!
keySafe
)
{
rv
=
NS_ERROR_FAILURE
;
goto
finish
;
}
srv
=
SEC_PKCS12AddCertAndKey
(
ecx
certSafe
nullptr
nssCert
.
get
(
)
CERT_GetDefaultCertDB
(
)
keySafe
nullptr
true
&
unicodePw
SEC_OID_PKCS12_V2_PBE_WITH_SHA1_AND_3KEY_TRIPLE_DES_CBC
)
;
if
(
srv
)
goto
finish
;
+
+
numCertsExported
;
}
if
(
!
numCertsExported
)
goto
finish
;
this
-
>
mTmpFile
=
nullptr
;
file
-
>
GetPath
(
filePath
)
;
if
(
filePath
.
RFind
(
"
.
p12
"
true
-
1
4
)
<
0
)
{
filePath
.
AppendLiteral
(
"
.
p12
"
)
;
localFileRef
=
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
goto
finish
;
localFileRef
-
>
InitWithPath
(
filePath
)
;
file
=
localFileRef
;
}
rv
=
file
-
>
OpenNSPRFileDesc
(
PR_RDWR
|
PR_CREATE_FILE
|
PR_TRUNCATE
0664
&
mTmpFile
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
this
-
>
mTmpFile
)
goto
finish
;
srv
=
SEC_PKCS12Encode
(
ecx
write_export_file
this
)
;
if
(
srv
)
goto
finish
;
finish
:
if
(
NS_FAILED
(
rv
)
|
|
srv
!
=
SECSuccess
)
{
handleError
(
PIP_PKCS12_BACKUP_FAILED
)
;
}
if
(
ecx
)
SEC_PKCS12DestroyExportContext
(
ecx
)
;
if
(
this
-
>
mTmpFile
)
{
PR_Close
(
this
-
>
mTmpFile
)
;
this
-
>
mTmpFile
=
nullptr
;
}
SECITEM_ZfreeItem
(
&
unicodePw
false
)
;
return
rv
;
}
nsresult
nsPKCS12Blob
:
:
unicodeToItem
(
const
nsString
&
uni
SECItem
*
item
)
{
uint32_t
len
=
uni
.
Length
(
)
+
1
;
if
(
!
SECITEM_AllocItem
(
nullptr
item
sizeof
(
char16_t
)
*
len
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapToBigEndian
(
item
-
>
data
static_cast
<
const
char16_t
*
>
(
uni
.
get
(
)
)
len
)
;
return
NS_OK
;
}
nsresult
nsPKCS12Blob
:
:
newPKCS12FilePassword
(
SECItem
*
unicodePw
)
{
nsresult
rv
=
NS_OK
;
nsAutoString
password
;
nsCOMPtr
<
nsICertificateDialogs
>
certDialogs
;
rv
=
:
:
getNSSDialogs
(
getter_AddRefs
(
certDialogs
)
NS_GET_IID
(
nsICertificateDialogs
)
NS_CERTIFICATEDIALOGS_CONTRACTID
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
bool
pressedOK
;
rv
=
certDialogs
-
>
SetPKCS12FilePassword
(
mUIContext
password
&
pressedOK
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
pressedOK
)
return
rv
;
return
unicodeToItem
(
password
unicodePw
)
;
}
nsresult
nsPKCS12Blob
:
:
getPKCS12FilePassword
(
SECItem
*
unicodePw
)
{
nsresult
rv
=
NS_OK
;
nsAutoString
password
;
nsCOMPtr
<
nsICertificateDialogs
>
certDialogs
;
rv
=
:
:
getNSSDialogs
(
getter_AddRefs
(
certDialogs
)
NS_GET_IID
(
nsICertificateDialogs
)
NS_CERTIFICATEDIALOGS_CONTRACTID
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
bool
pressedOK
;
rv
=
certDialogs
-
>
GetPKCS12FilePassword
(
mUIContext
password
&
pressedOK
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
pressedOK
)
return
rv
;
return
unicodeToItem
(
password
unicodePw
)
;
}
nsresult
nsPKCS12Blob
:
:
inputToDecoder
(
SEC_PKCS12DecoderContext
*
dcx
nsIFile
*
file
)
{
nsresult
rv
;
SECStatus
srv
;
uint32_t
amount
;
char
buf
[
PIP_PKCS12_BUFFER_SIZE
]
;
nsCOMPtr
<
nsIInputStream
>
fileStream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
fileStream
)
file
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
while
(
true
)
{
rv
=
fileStream
-
>
Read
(
buf
PIP_PKCS12_BUFFER_SIZE
&
amount
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
srv
=
SEC_PKCS12DecoderUpdate
(
dcx
(
unsigned
char
*
)
buf
amount
)
;
if
(
srv
)
{
int
pr_err
=
PORT_GetError
(
)
;
PORT_SetError
(
pr_err
)
;
return
NS_ERROR_ABORT
;
}
if
(
amount
<
PIP_PKCS12_BUFFER_SIZE
)
break
;
}
return
NS_OK
;
}
SECItem
*
nsPKCS12Blob
:
:
nickname_collision
(
SECItem
*
oldNick
PRBool
*
cancel
void
*
wincx
)
{
*
cancel
=
false
;
int
count
=
1
;
nsCString
nickname
;
nsAutoString
nickFromProp
;
nsresult
rv
=
GetPIPNSSBundleString
(
"
P12DefaultNickname
"
nickFromProp
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
NS_ConvertUTF16toUTF8
nickFromPropC
(
nickFromProp
)
;
while
(
1
)
{
nickname
=
nickFromPropC
;
if
(
count
>
1
)
{
nickname
.
AppendPrintf
(
"
#
%
d
"
count
)
;
}
UniqueCERTCertificate
cert
(
CERT_FindCertByNickname
(
CERT_GetDefaultCertDB
(
)
nickname
.
get
(
)
)
)
;
if
(
!
cert
)
{
break
;
}
count
+
+
;
}
SECItem
*
newNick
=
new
SECItem
;
if
(
!
newNick
)
return
nullptr
;
newNick
-
>
type
=
siAsciiString
;
newNick
-
>
data
=
(
unsigned
char
*
)
strdup
(
nickname
.
get
(
)
)
;
newNick
-
>
len
=
strlen
(
(
char
*
)
newNick
-
>
data
)
;
return
newNick
;
}
void
nsPKCS12Blob
:
:
write_export_file
(
void
*
arg
const
char
*
buf
unsigned
long
len
)
{
nsPKCS12Blob
*
cx
=
(
nsPKCS12Blob
*
)
arg
;
PR_Write
(
cx
-
>
mTmpFile
buf
len
)
;
}
PRBool
pip_ucs2_ascii_conversion_fn
(
PRBool
toUnicode
unsigned
char
*
inBuf
unsigned
int
inBufLen
unsigned
char
*
outBuf
unsigned
int
maxOutBufLen
unsigned
int
*
outBufLen
PRBool
swapBytes
)
{
*
outBufLen
=
inBufLen
;
memcpy
(
outBuf
inBuf
inBufLen
)
;
return
true
;
}
void
nsPKCS12Blob
:
:
handleError
(
int
myerr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
int
prerr
=
PORT_GetError
(
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
PKCS12
:
NSS
/
NSPR
error
(
%
d
)
"
prerr
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
PKCS12
:
I
called
(
%
d
)
"
myerr
)
)
;
const
char
*
msgID
=
nullptr
;
switch
(
myerr
)
{
case
PIP_PKCS12_USER_CANCELED
:
return
;
case
PIP_PKCS12_NOSMARTCARD_EXPORT
:
msgID
=
"
PKCS12InfoNoSmartcardBackup
"
;
break
;
case
PIP_PKCS12_RESTORE_FAILED
:
msgID
=
"
PKCS12UnknownErrRestore
"
;
break
;
case
PIP_PKCS12_BACKUP_FAILED
:
msgID
=
"
PKCS12UnknownErrBackup
"
;
break
;
case
PIP_PKCS12_NSS_ERROR
:
switch
(
prerr
)
{
case
0
:
break
;
case
SEC_ERROR_PKCS12_CERT_COLLISION
:
case
SEC_ERROR_BAD_PASSWORD
:
msgID
=
"
PK11BadPassword
"
;
break
;
case
SEC_ERROR_BAD_DER
:
case
SEC_ERROR_PKCS12_CORRUPT_PFX_STRUCTURE
:
case
SEC_ERROR_PKCS12_INVALID_MAC
:
msgID
=
"
PKCS12DecodeErr
"
;
break
;
case
SEC_ERROR_PKCS12_DUPLICATE_DATA
:
msgID
=
"
PKCS12DupData
"
;
break
;
}
break
;
}
if
(
!
msgID
)
msgID
=
"
PKCS12UnknownErr
"
;
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
(
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
)
)
;
if
(
!
wwatch
)
{
return
;
}
nsCOMPtr
<
nsIPrompt
>
prompter
;
if
(
NS_FAILED
(
wwatch
-
>
GetNewPrompter
(
nullptr
getter_AddRefs
(
prompter
)
)
)
)
{
return
;
}
nsAutoString
message
;
if
(
NS_FAILED
(
GetPIPNSSBundleString
(
msgID
message
)
)
)
{
return
;
}
Unused
<
<
prompter
-
>
Alert
(
nullptr
message
.
get
(
)
)
;
}
