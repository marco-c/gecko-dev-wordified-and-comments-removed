#
include
"
EnterpriseRoots
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozpkix
/
Result
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
ifdef
XP_MACOSX
#
include
<
Security
/
Security
.
h
>
#
include
"
KeychainSecret
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
wincrypt
.
h
>
#
endif
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
using
namespace
mozilla
;
nsresult
EnterpriseCert
:
:
Init
(
const
uint8_t
*
data
size_t
len
bool
isRoot
)
{
mDER
.
clear
(
)
;
if
(
!
mDER
.
append
(
data
len
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mIsRoot
=
isRoot
;
return
NS_OK
;
}
nsresult
EnterpriseCert
:
:
Init
(
const
EnterpriseCert
&
orig
)
{
return
Init
(
orig
.
mDER
.
begin
(
)
orig
.
mDER
.
length
(
)
orig
.
mIsRoot
)
;
}
nsresult
EnterpriseCert
:
:
CopyBytes
(
nsTArray
<
uint8_t
>
&
dest
)
const
{
dest
.
Clear
(
)
;
if
(
!
dest
.
AppendElements
(
mDER
.
begin
(
)
mDER
.
length
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
pkix
:
:
Result
EnterpriseCert
:
:
GetInput
(
pkix
:
:
Input
&
input
)
const
{
return
input
.
Init
(
mDER
.
begin
(
)
mDER
.
length
(
)
)
;
}
bool
EnterpriseCert
:
:
GetIsRoot
(
)
const
{
return
mIsRoot
;
}
#
ifdef
XP_WIN
const
wchar_t
*
kWindowsDefaultRootStoreNames
[
]
=
{
L
"
ROOT
"
L
"
CA
"
}
;
static
void
CertIsTrustAnchorForTLSServerAuth
(
PCCERT_CONTEXT
certificate
bool
&
isTrusted
bool
&
isRoot
)
{
isTrusted
=
false
;
isRoot
=
false
;
MOZ_ASSERT
(
certificate
)
;
if
(
!
certificate
)
{
return
;
}
PCCERT_CHAIN_CONTEXT
pChainContext
=
nullptr
;
CERT_ENHKEY_USAGE
enhkeyUsage
;
memset
(
&
enhkeyUsage
0
sizeof
(
CERT_ENHKEY_USAGE
)
)
;
LPCSTR
identifiers
[
]
=
{
"
1
.
3
.
6
.
1
.
5
.
5
.
7
.
3
.
1
"
}
;
enhkeyUsage
.
cUsageIdentifier
=
ArrayLength
(
identifiers
)
;
enhkeyUsage
.
rgpszUsageIdentifier
=
const_cast
<
LPSTR
*
>
(
identifiers
)
;
CERT_USAGE_MATCH
certUsage
;
memset
(
&
certUsage
0
sizeof
(
CERT_USAGE_MATCH
)
)
;
certUsage
.
dwType
=
USAGE_MATCH_TYPE_AND
;
certUsage
.
Usage
=
enhkeyUsage
;
CERT_CHAIN_PARA
chainPara
;
memset
(
&
chainPara
0
sizeof
(
CERT_CHAIN_PARA
)
)
;
chainPara
.
cbSize
=
sizeof
(
CERT_CHAIN_PARA
)
;
chainPara
.
RequestedUsage
=
certUsage
;
DWORD
flags
=
CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY
|
CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL
|
CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE
|
#
if
defined
(
CERT_CHAIN_DISABLE_AIA
)
CERT_CHAIN_DISABLE_AIA
;
#
else
0x00002000
;
#
endif
if
(
!
CertGetCertificateChain
(
nullptr
certificate
nullptr
nullptr
&
chainPara
flags
nullptr
&
pChainContext
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CertGetCertificateChain
failed
"
)
)
;
return
;
}
isTrusted
=
pChainContext
-
>
TrustStatus
.
dwErrorStatus
=
=
CERT_TRUST_NO_ERROR
;
if
(
isTrusted
&
&
pChainContext
-
>
cChain
>
0
)
{
CERT_SIMPLE_CHAIN
*
finalChain
=
pChainContext
-
>
rgpChain
[
pChainContext
-
>
cChain
-
1
]
;
isRoot
=
finalChain
-
>
cElement
=
=
1
;
}
CertFreeCertificateChain
(
pChainContext
)
;
}
class
ScopedCertStore
final
{
public
:
explicit
ScopedCertStore
(
HCERTSTORE
certstore
)
:
certstore
(
certstore
)
{
}
~
ScopedCertStore
(
)
{
CertCloseStore
(
certstore
0
)
;
}
HCERTSTORE
get
(
)
{
return
certstore
;
}
private
:
ScopedCertStore
(
const
ScopedCertStore
&
)
=
delete
;
ScopedCertStore
&
operator
=
(
const
ScopedCertStore
&
)
=
delete
;
HCERTSTORE
certstore
;
}
;
static
void
GatherEnterpriseCertsForLocation
(
DWORD
locationFlag
Vector
<
EnterpriseCert
>
&
certs
)
{
MOZ_ASSERT
(
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_CURRENT_USER
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
"
unexpected
locationFlag
for
GatherEnterpriseRootsForLocation
"
)
;
if
(
!
(
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_CURRENT_USER
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
)
)
{
return
;
}
DWORD
flags
=
locationFlag
|
CERT_STORE_OPEN_EXISTING_FLAG
|
CERT_STORE_READONLY_FLAG
;
for
(
auto
name
:
kWindowsDefaultRootStoreNames
)
{
ScopedCertStore
enterpriseRootStore
(
CertOpenStore
(
CERT_STORE_PROV_SYSTEM_REGISTRY_W
0
NULL
flags
name
)
)
;
if
(
!
enterpriseRootStore
.
get
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
open
enterprise
root
store
"
)
)
;
continue
;
}
PCCERT_CONTEXT
certificate
=
nullptr
;
uint32_t
numImported
=
0
;
while
(
(
certificate
=
CertFindCertificateInStore
(
enterpriseRootStore
.
get
(
)
X509_ASN_ENCODING
0
CERT_FIND_ANY
nullptr
certificate
)
)
)
{
bool
isTrusted
;
bool
isRoot
;
CertIsTrustAnchorForTLSServerAuth
(
certificate
isTrusted
isRoot
)
;
if
(
!
isTrusted
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
cert
not
trusted
for
TLS
server
auth
"
)
)
;
continue
;
}
EnterpriseCert
enterpriseCert
;
if
(
NS_FAILED
(
enterpriseCert
.
Init
(
certificate
-
>
pbCertEncoded
certificate
-
>
cbCertEncoded
isRoot
)
)
)
{
continue
;
}
if
(
!
certs
.
append
(
std
:
:
move
(
enterpriseCert
)
)
)
{
continue
;
}
numImported
+
+
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
imported
%
u
certs
from
%
S
"
numImported
name
)
)
;
}
}
static
void
GatherEnterpriseCertsWindows
(
Vector
<
EnterpriseCert
>
&
certs
)
{
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE
certs
)
;
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
certs
)
;
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
certs
)
;
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_CURRENT_USER
certs
)
;
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
certs
)
;
}
#
endif
#
ifdef
XP_MACOSX
OSStatus
GatherEnterpriseCertsMacOS
(
Vector
<
EnterpriseCert
>
&
certs
)
{
const
CFStringRef
keys
[
]
=
{
kSecClass
kSecMatchLimit
kSecMatchPolicy
kSecMatchTrustedOnly
}
;
ScopedCFType
<
SecPolicyRef
>
sslPolicy
(
SecPolicyCreateSSL
(
true
nullptr
)
)
;
const
void
*
values
[
]
=
{
kSecClassCertificate
kSecMatchLimitAll
sslPolicy
.
get
(
)
kCFBooleanTrue
}
;
static_assert
(
ArrayLength
(
keys
)
=
=
ArrayLength
(
values
)
"
mismatched
SecItemCopyMatching
key
/
value
array
sizes
"
)
;
ScopedCFType
<
CFDictionaryRef
>
searchDictionary
(
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
keys
(
const
void
*
*
)
&
values
ArrayLength
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
CFTypeRef
items
;
OSStatus
rv
=
SecItemCopyMatching
(
searchDictionary
.
get
(
)
&
items
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SecItemCopyMatching
failed
"
)
)
;
return
rv
;
}
ScopedCFType
<
CFArrayRef
>
arr
(
reinterpret_cast
<
CFArrayRef
>
(
items
)
)
;
CFIndex
count
=
CFArrayGetCount
(
arr
.
get
(
)
)
;
uint32_t
numImported
=
0
;
for
(
CFIndex
i
=
0
;
i
<
count
;
i
+
+
)
{
const
CFTypeRef
c
=
CFArrayGetValueAtIndex
(
arr
.
get
(
)
i
)
;
SecTrustRef
trust
;
rv
=
SecTrustCreateWithCertificates
(
c
sslPolicy
.
get
(
)
&
trust
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SecTrustCreateWithCertificates
failed
"
)
)
;
continue
;
}
ScopedCFType
<
SecTrustRef
>
trustHandle
(
trust
)
;
rv
=
SecTrustSetNetworkFetchAllowed
(
trustHandle
.
get
(
)
false
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SecTrustSetNetworkFetchAllowed
failed
"
)
)
;
continue
;
}
bool
isTrusted
=
false
;
bool
fallBackToDeprecatedAPI
=
true
;
#
if
defined
MAC_OS_X_VERSION_10_14
if
(
nsCocoaFeatures
:
:
OnMojaveOrLater
(
)
)
{
if
(
__builtin_available
(
macOS
10
.
14
*
)
)
{
isTrusted
=
SecTrustEvaluateWithError
(
trustHandle
.
get
(
)
nullptr
)
;
fallBackToDeprecatedAPI
=
false
;
}
}
#
endif
if
(
fallBackToDeprecatedAPI
)
{
SecTrustResultType
result
;
rv
=
SecTrustEvaluate
(
trustHandle
.
get
(
)
&
result
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SecTrustEvaluate
failed
"
)
)
;
continue
;
}
isTrusted
=
result
=
=
kSecTrustResultProceed
|
|
result
=
=
kSecTrustResultUnspecified
;
}
if
(
!
isTrusted
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
cert
not
trusted
"
)
)
;
continue
;
}
CFIndex
count
=
SecTrustGetCertificateCount
(
trustHandle
.
get
(
)
)
;
bool
isRoot
=
count
=
=
1
;
const
SecCertificateRef
s
=
(
const
SecCertificateRef
)
c
;
ScopedCFType
<
CFDataRef
>
der
(
SecCertificateCopyData
(
s
)
)
;
EnterpriseCert
enterpriseCert
;
if
(
NS_FAILED
(
enterpriseCert
.
Init
(
CFDataGetBytePtr
(
der
.
get
(
)
)
CFDataGetLength
(
der
.
get
(
)
)
isRoot
)
)
)
{
continue
;
}
if
(
!
certs
.
append
(
std
:
:
move
(
enterpriseCert
)
)
)
{
continue
;
}
numImported
+
+
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
imported
%
u
certs
"
numImported
)
)
;
return
errSecSuccess
;
}
#
endif
nsresult
GatherEnterpriseCerts
(
Vector
<
EnterpriseCert
>
&
certs
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
certs
.
clear
(
)
;
#
ifdef
XP_WIN
GatherEnterpriseCertsWindows
(
certs
)
;
#
endif
#
ifdef
XP_MACOSX
OSStatus
rv
=
GatherEnterpriseCertsMacOS
(
certs
)
;
if
(
rv
!
=
errSecSuccess
)
{
return
NS_ERROR_FAILURE
;
}
#
endif
return
NS_OK
;
}
