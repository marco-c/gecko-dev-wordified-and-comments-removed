#
include
"
EnterpriseRoots
.
h
"
#
include
"
PKCS11ModuleDB
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozpkix
/
Result
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
mozilla
/
java
/
EnterpriseRootsWrappers
.
h
"
#
endif
#
ifdef
XP_MACOSX
#
include
<
Security
/
Security
.
h
>
#
include
"
KeychainSecret
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
wincrypt
.
h
>
#
endif
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
using
namespace
mozilla
;
void
EnterpriseCert
:
:
CopyBytes
(
nsTArray
<
uint8_t
>
&
dest
)
const
{
dest
.
Assign
(
mDER
)
;
}
pkix
:
:
Result
EnterpriseCert
:
:
GetInput
(
pkix
:
:
Input
&
input
)
const
{
return
input
.
Init
(
mDER
.
Elements
(
)
mDER
.
Length
(
)
)
;
}
bool
EnterpriseCert
:
:
GetIsRoot
(
)
const
{
return
mIsRoot
;
}
bool
EnterpriseCert
:
:
IsKnownRoot
(
UniqueSECMODModule
&
rootsModule
)
{
if
(
!
rootsModule
)
{
return
false
;
}
SECItem
certItem
=
{
siBuffer
mDER
.
Elements
(
)
static_cast
<
unsigned
int
>
(
mDER
.
Length
(
)
)
}
;
AutoSECMODListReadLock
lock
;
for
(
int
i
=
0
;
i
<
rootsModule
-
>
slotCount
;
i
+
+
)
{
PK11SlotInfo
*
slot
=
rootsModule
-
>
slots
[
i
]
;
if
(
PK11_FindEncodedCertInSlot
(
slot
&
certItem
nullptr
)
!
=
CK_INVALID_HANDLE
)
{
return
true
;
}
}
return
false
;
}
#
ifdef
XP_WIN
struct
CertStoreLocation
{
const
wchar_t
*
mName
;
const
bool
mIsRoot
;
CertStoreLocation
(
const
wchar_t
*
name
bool
isRoot
)
:
mName
(
name
)
mIsRoot
(
isRoot
)
{
}
}
;
const
CertStoreLocation
kCertStoreLocations
[
]
=
{
CertStoreLocation
(
L
"
ROOT
"
true
)
CertStoreLocation
(
L
"
CA
"
false
)
}
;
class
ScopedCertStore
final
{
public
:
explicit
ScopedCertStore
(
HCERTSTORE
certstore
)
:
certstore
(
certstore
)
{
}
~
ScopedCertStore
(
)
{
CertCloseStore
(
certstore
0
)
;
}
HCERTSTORE
get
(
)
{
return
certstore
;
}
private
:
ScopedCertStore
(
const
ScopedCertStore
&
)
=
delete
;
ScopedCertStore
&
operator
=
(
const
ScopedCertStore
&
)
=
delete
;
HCERTSTORE
certstore
;
}
;
static
bool
CertCanBeUsedForTLSServerAuth
(
PCCERT_CONTEXT
certificate
)
{
DWORD
usageSize
=
0
;
if
(
!
CertGetEnhancedKeyUsage
(
certificate
0
NULL
&
usageSize
)
)
{
return
false
;
}
nsTArray
<
uint8_t
>
usageBytes
;
usageBytes
.
SetLength
(
usageSize
)
;
PCERT_ENHKEY_USAGE
usage
(
reinterpret_cast
<
PCERT_ENHKEY_USAGE
>
(
usageBytes
.
Elements
(
)
)
)
;
if
(
!
CertGetEnhancedKeyUsage
(
certificate
0
usage
&
usageSize
)
)
{
return
false
;
}
if
(
usage
-
>
cUsageIdentifier
=
=
0
)
{
return
GetLastError
(
)
=
=
static_cast
<
DWORD
>
(
CRYPT_E_NOT_FOUND
)
;
}
for
(
DWORD
i
=
0
;
i
<
usage
-
>
cUsageIdentifier
;
i
+
+
)
{
if
(
!
nsCRT
:
:
strcmp
(
usage
-
>
rgpszUsageIdentifier
[
i
]
szOID_PKIX_KP_SERVER_AUTH
)
|
|
!
nsCRT
:
:
strcmp
(
usage
-
>
rgpszUsageIdentifier
[
i
]
szOID_ANY_ENHANCED_KEY_USAGE
)
)
{
return
true
;
}
}
return
false
;
}
static
void
GatherEnterpriseCertsForLocation
(
DWORD
locationFlag
nsTArray
<
EnterpriseCert
>
&
certs
UniqueSECMODModule
&
rootsModule
)
{
MOZ_ASSERT
(
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_CURRENT_USER
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
"
unexpected
locationFlag
for
GatherEnterpriseRootsForLocation
"
)
;
if
(
!
(
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_CURRENT_USER
|
|
locationFlag
=
=
CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
)
)
{
return
;
}
DWORD
flags
=
locationFlag
|
CERT_STORE_OPEN_EXISTING_FLAG
|
CERT_STORE_READONLY_FLAG
;
for
(
const
auto
&
location
:
kCertStoreLocations
)
{
ScopedCertStore
certStore
(
CertOpenStore
(
CERT_STORE_PROV_SYSTEM_REGISTRY_W
0
NULL
flags
location
.
mName
)
)
;
if
(
!
certStore
.
get
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
open
certificate
store
"
)
)
;
continue
;
}
PCCERT_CONTEXT
certificate
=
nullptr
;
uint32_t
numImported
=
0
;
while
(
(
certificate
=
CertFindCertificateInStore
(
certStore
.
get
(
)
X509_ASN_ENCODING
0
CERT_FIND_ANY
nullptr
certificate
)
)
)
{
if
(
!
CertCanBeUsedForTLSServerAuth
(
certificate
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
cert
not
relevant
for
TLS
server
auth
"
)
)
;
continue
;
}
EnterpriseCert
enterpriseCert
(
certificate
-
>
pbCertEncoded
certificate
-
>
cbCertEncoded
location
.
mIsRoot
)
;
if
(
!
enterpriseCert
.
IsKnownRoot
(
rootsModule
)
)
{
certs
.
AppendElement
(
std
:
:
move
(
enterpriseCert
)
)
;
numImported
+
+
;
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
known
root
cert
"
)
)
;
}
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
imported
%
u
certs
from
%
S
"
numImported
location
.
mName
)
)
;
}
}
static
void
GatherEnterpriseCertsWindows
(
nsTArray
<
EnterpriseCert
>
&
certs
UniqueSECMODModule
&
rootsModule
)
{
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE
certs
rootsModule
)
;
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
certs
rootsModule
)
;
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
certs
rootsModule
)
;
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_CURRENT_USER
certs
rootsModule
)
;
GatherEnterpriseCertsForLocation
(
CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
certs
rootsModule
)
;
}
#
endif
#
ifdef
XP_MACOSX
enum
class
CertificateTrustResult
{
CanUseAsIntermediate
CanUseAsTrustAnchor
DoNotUse
}
;
ScopedCFType
<
CFArrayRef
>
GetCertificateTrustSettingsInDomain
(
const
SecCertificateRef
certificate
SecTrustSettingsDomain
domain
)
{
CFArrayRef
trustSettingsRaw
;
OSStatus
rv
=
SecTrustSettingsCopyTrustSettings
(
certificate
domain
&
trustSettingsRaw
)
;
if
(
rv
!
=
errSecSuccess
|
|
!
trustSettingsRaw
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SecTrustSettingsCopyTrustSettings
failed
(
or
not
found
)
for
"
"
domain
%
"
PRIu32
domain
)
)
;
return
nullptr
;
}
ScopedCFType
<
CFArrayRef
>
trustSettings
(
trustSettingsRaw
)
;
return
trustSettings
;
}
CertificateTrustResult
ProcessCertificateTrustSettings
(
ScopedCFType
<
CFArrayRef
>
&
trustSettings
)
{
const
CFIndex
numTrustDictionaries
=
CFArrayGetCount
(
trustSettings
.
get
(
)
)
;
if
(
numTrustDictionaries
=
=
0
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
empty
trust
settings
-
>
trust
anchor
"
)
)
;
return
CertificateTrustResult
:
:
CanUseAsTrustAnchor
;
}
CertificateTrustResult
currentTrustSettings
=
CertificateTrustResult
:
:
CanUseAsIntermediate
;
for
(
CFIndex
i
=
0
;
i
<
numTrustDictionaries
;
i
+
+
)
{
CFDictionaryRef
trustDictionary
=
reinterpret_cast
<
CFDictionaryRef
>
(
CFArrayGetValueAtIndex
(
trustSettings
.
get
(
)
i
)
)
;
if
(
CFDictionaryContainsKey
(
trustDictionary
kSecTrustSettingsApplication
)
|
|
CFDictionaryContainsKey
(
trustDictionary
kSecTrustSettingsPolicyString
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
found
unsupported
policy
-
>
assuming
distrusted
"
)
)
;
return
CertificateTrustResult
:
:
DoNotUse
;
}
if
(
CFDictionaryContainsKey
(
trustDictionary
kSecTrustSettingsKeyUsage
)
)
{
CFNumberRef
keyUsage
=
(
CFNumberRef
)
CFDictionaryGetValue
(
trustDictionary
kSecTrustSettingsKeyUsage
)
;
int32_t
keyUsageValue
;
if
(
!
keyUsage
|
|
CFNumberGetValue
(
keyUsage
kCFNumberSInt32Type
&
keyUsageValue
)
|
|
keyUsageValue
<
0
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
no
trust
settings
key
usage
or
couldn
'
t
get
value
"
)
)
;
return
CertificateTrustResult
:
:
DoNotUse
;
}
switch
(
(
uint64_t
)
keyUsageValue
)
{
case
kSecTrustSettingsKeyUseSignature
:
case
kSecTrustSettingsKeyUseSignCert
:
case
kSecTrustSettingsKeyUseAny
:
break
;
default
:
return
CertificateTrustResult
:
:
DoNotUse
;
}
}
if
(
CFDictionaryContainsKey
(
trustDictionary
kSecTrustSettingsPolicy
)
)
{
SecPolicyRef
policy
=
(
SecPolicyRef
)
CFDictionaryGetValue
(
trustDictionary
kSecTrustSettingsPolicy
)
;
if
(
!
policy
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
kSecTrustSettingsPolicy
present
but
null
?
"
)
)
;
continue
;
}
ScopedCFType
<
CFDictionaryRef
>
policyProperties
(
SecPolicyCopyProperties
(
policy
)
)
;
CFStringRef
policyOid
=
(
CFStringRef
)
CFDictionaryGetValue
(
policyProperties
.
get
(
)
kSecPolicyOid
)
;
if
(
!
CFEqual
(
policyOid
kSecPolicyAppleSSL
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
policy
doesn
'
t
match
"
)
)
;
continue
;
}
}
int32_t
trustSettingsValue
=
kSecTrustSettingsResultTrustRoot
;
if
(
CFDictionaryContainsKey
(
trustDictionary
kSecTrustSettingsResult
)
)
{
CFNumberRef
trustSetting
=
(
CFNumberRef
)
CFDictionaryGetValue
(
trustDictionary
kSecTrustSettingsResult
)
;
if
(
!
trustSetting
|
|
!
CFNumberGetValue
(
trustSetting
kCFNumberSInt32Type
&
trustSettingsValue
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
no
trust
settings
result
or
couldn
'
t
get
value
"
)
)
;
continue
;
}
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
trust
setting
:
%
d
"
trustSettingsValue
)
)
;
if
(
trustSettingsValue
=
=
kSecTrustSettingsResultDeny
)
{
return
CertificateTrustResult
:
:
DoNotUse
;
}
if
(
trustSettingsValue
=
=
kSecTrustSettingsResultTrustRoot
|
|
trustSettingsValue
=
=
kSecTrustSettingsResultTrustAsRoot
)
{
currentTrustSettings
=
CertificateTrustResult
:
:
CanUseAsTrustAnchor
;
}
}
return
currentTrustSettings
;
}
CertificateTrustResult
GetCertificateTrustResult
(
const
SecCertificateRef
certificate
)
{
ScopedCFType
<
CFStringRef
>
subject
(
SecCertificateCopySubjectSummary
(
certificate
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
determining
trust
for
'
%
s
'
"
CFStringGetCStringPtr
(
subject
.
get
(
)
kCFStringEncodingUTF8
)
)
)
;
ScopedCFType
<
CFArrayRef
>
systemTrustSettings
(
GetCertificateTrustSettingsInDomain
(
certificate
kSecTrustSettingsDomainSystem
)
)
;
if
(
systemTrustSettings
)
{
return
CertificateTrustResult
:
:
DoNotUse
;
}
CertificateTrustResult
certificateTrustResult
=
CertificateTrustResult
:
:
CanUseAsIntermediate
;
ScopedCFType
<
CFArrayRef
>
userTrustSettings
(
GetCertificateTrustSettingsInDomain
(
certificate
kSecTrustSettingsDomainUser
)
)
;
if
(
userTrustSettings
)
{
certificateTrustResult
=
ProcessCertificateTrustSettings
(
userTrustSettings
)
;
if
(
certificateTrustResult
!
=
CertificateTrustResult
:
:
CanUseAsIntermediate
)
{
return
certificateTrustResult
;
}
}
ScopedCFType
<
CFArrayRef
>
adminTrustSettings
(
GetCertificateTrustSettingsInDomain
(
certificate
kSecTrustSettingsDomainAdmin
)
)
;
if
(
adminTrustSettings
)
{
certificateTrustResult
=
ProcessCertificateTrustSettings
(
adminTrustSettings
)
;
}
return
certificateTrustResult
;
}
OSStatus
GatherEnterpriseCertsMacOS
(
nsTArray
<
EnterpriseCert
>
&
certs
UniqueSECMODModule
&
rootsModule
)
{
const
CFStringRef
keys
[
]
=
{
kSecClass
kSecMatchLimit
}
;
const
void
*
values
[
]
=
{
kSecClassCertificate
kSecMatchLimitAll
}
;
static_assert
(
ArrayLength
(
keys
)
=
=
ArrayLength
(
values
)
"
mismatched
SecItemCopyMatching
key
/
value
array
sizes
"
)
;
ScopedCFType
<
CFDictionaryRef
>
searchDictionary
(
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
keys
(
const
void
*
*
)
&
values
ArrayLength
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
CFTypeRef
items
;
OSStatus
rv
=
SecItemCopyMatching
(
searchDictionary
.
get
(
)
&
items
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SecItemCopyMatching
failed
"
)
)
;
return
rv
;
}
ScopedCFType
<
CFArrayRef
>
arr
(
reinterpret_cast
<
CFArrayRef
>
(
items
)
)
;
CFIndex
count
=
CFArrayGetCount
(
arr
.
get
(
)
)
;
uint32_t
numImported
=
0
;
for
(
CFIndex
i
=
0
;
i
<
count
;
i
+
+
)
{
const
SecCertificateRef
certificate
=
(
const
SecCertificateRef
)
CFArrayGetValueAtIndex
(
arr
.
get
(
)
i
)
;
CertificateTrustResult
certificateTrustResult
=
GetCertificateTrustResult
(
certificate
)
;
if
(
certificateTrustResult
=
=
CertificateTrustResult
:
:
DoNotUse
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
distrusted
cert
"
)
)
;
continue
;
}
ScopedCFType
<
CFDataRef
>
der
(
SecCertificateCopyData
(
certificate
)
)
;
if
(
!
der
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
couldn
'
t
get
bytes
of
certificate
?
"
)
)
;
continue
;
}
bool
isRoot
=
certificateTrustResult
=
=
CertificateTrustResult
:
:
CanUseAsTrustAnchor
;
EnterpriseCert
enterpriseCert
(
CFDataGetBytePtr
(
der
.
get
(
)
)
CFDataGetLength
(
der
.
get
(
)
)
isRoot
)
;
if
(
!
enterpriseCert
.
IsKnownRoot
(
rootsModule
)
)
{
certs
.
AppendElement
(
std
:
:
move
(
enterpriseCert
)
)
;
numImported
+
+
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
importing
as
%
s
"
isRoot
?
"
root
"
:
"
intermediate
"
)
)
;
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
known
root
cert
"
)
)
;
}
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
imported
%
u
certs
"
numImported
)
)
;
return
errSecSuccess
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
void
GatherEnterpriseCertsAndroid
(
nsTArray
<
EnterpriseCert
>
&
certs
UniqueSECMODModule
&
rootsModule
)
{
if
(
!
jni
:
:
IsAvailable
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
JNI
not
available
"
)
)
;
return
;
}
jni
:
:
ObjectArray
:
:
LocalRef
roots
=
java
:
:
EnterpriseRoots
:
:
GatherEnterpriseRoots
(
)
;
uint32_t
numImported
=
0
;
for
(
size_t
i
=
0
;
i
<
roots
-
>
Length
(
)
;
i
+
+
)
{
jni
:
:
ByteArray
:
:
LocalRef
root
=
roots
-
>
GetElement
(
i
)
;
EnterpriseCert
enterpriseCert
(
reinterpret_cast
<
uint8_t
*
>
(
root
-
>
GetElements
(
)
.
Elements
(
)
)
root
-
>
Length
(
)
true
)
;
if
(
!
enterpriseCert
.
IsKnownRoot
(
rootsModule
)
)
{
certs
.
AppendElement
(
std
:
:
move
(
enterpriseCert
)
)
;
numImported
+
+
;
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
skipping
known
root
cert
"
)
)
;
}
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
imported
%
u
certs
"
numImported
)
)
;
}
#
endif
nsresult
GatherEnterpriseCerts
(
nsTArray
<
EnterpriseCert
>
&
certs
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
certs
.
Clear
(
)
;
UniqueSECMODModule
rootsModule
(
SECMOD_FindModule
(
kRootModuleName
.
get
(
)
)
)
;
#
ifdef
XP_WIN
GatherEnterpriseCertsWindows
(
certs
rootsModule
)
;
#
endif
#
ifdef
XP_MACOSX
OSStatus
rv
=
GatherEnterpriseCertsMacOS
(
certs
rootsModule
)
;
if
(
rv
!
=
errSecSuccess
)
{
return
NS_ERROR_FAILURE
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
GatherEnterpriseCertsAndroid
(
certs
rootsModule
)
;
#
endif
return
NS_OK
;
}
