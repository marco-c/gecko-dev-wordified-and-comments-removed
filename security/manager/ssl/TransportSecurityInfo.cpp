#
include
"
TransportSecurityInfo
.
h
"
#
include
"
DateTimeFormat
.
h
"
#
include
"
PSMRunnable
.
h
"
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsICertOverrideService
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsNSSCertHelper
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsNSSHelper
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozpkix
/
pkixtypes
.
h
"
#
include
"
secerr
.
h
"
#
include
"
ssl
.
h
"
namespace
mozilla
{
namespace
psm
{
TransportSecurityInfo
:
:
TransportSecurityInfo
(
)
:
mCipherSuite
(
0
)
mProtocolVersion
(
0
)
mCertificateTransparencyStatus
(
nsITransportSecurityInfo
:
:
CERTIFICATE_TRANSPARENCY_NOT_APPLICABLE
)
mKeaGroup
(
)
mSignatureSchemeName
(
)
mIsAcceptedEch
(
false
)
mIsDelegatedCredential
(
false
)
mIsDomainMismatch
(
false
)
mIsNotValidAtThisTime
(
false
)
mIsUntrusted
(
false
)
mIsEV
(
false
)
mHasIsEVStatus
(
false
)
mHaveCipherSuiteAndProtocol
(
false
)
mHaveCertErrorBits
(
false
)
mCanceled
(
false
)
mMutex
(
"
TransportSecurityInfo
:
:
mMutex
"
)
mNPNCompleted
(
false
)
mResumed
(
false
)
mIsBuiltCertChainRootBuiltInRoot
(
false
)
mSecurityState
(
nsIWebProgressListener
:
:
STATE_IS_INSECURE
)
mErrorCode
(
0
)
mPort
(
0
)
{
}
NS_IMPL_ISUPPORTS
(
TransportSecurityInfo
nsITransportSecurityInfo
nsIInterfaceRequestor
nsISerializable
nsIClassInfo
)
void
TransportSecurityInfo
:
:
SetHostName
(
const
char
*
host
)
{
MutexAutoLock
lock
(
mMutex
)
;
mHostName
.
Assign
(
host
)
;
}
void
TransportSecurityInfo
:
:
SetPort
(
int32_t
aPort
)
{
MutexAutoLock
lock
(
mMutex
)
;
mPort
=
aPort
;
}
void
TransportSecurityInfo
:
:
SetOriginAttributes
(
const
OriginAttributes
&
aOriginAttributes
)
{
MutexAutoLock
lock
(
mMutex
)
;
mOriginAttributes
=
aOriginAttributes
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetErrorCode
(
int32_t
*
state
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
(
(
mCanceled
&
&
mErrorCode
=
=
0
)
|
|
(
!
mCanceled
&
&
mErrorCode
!
=
0
)
)
)
;
if
(
(
mCanceled
&
&
mErrorCode
=
=
0
)
|
|
(
!
mCanceled
&
&
mErrorCode
!
=
0
)
)
{
mCanceled
=
true
;
mErrorCode
=
SEC_ERROR_LIBRARY_FAILURE
;
}
*
state
=
mErrorCode
;
return
NS_OK
;
}
void
TransportSecurityInfo
:
:
SetCanceled
(
PRErrorCode
errorCode
)
{
MOZ_ASSERT
(
errorCode
!
=
0
)
;
if
(
errorCode
=
=
0
)
{
errorCode
=
SEC_ERROR_LIBRARY_FAILURE
;
}
MutexAutoLock
lock
(
mMutex
)
;
mErrorCode
=
errorCode
;
mCanceled
=
true
;
}
bool
TransportSecurityInfo
:
:
IsCanceled
(
)
{
return
mCanceled
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetSecurityState
(
uint32_t
*
state
)
{
MutexAutoLock
lock
(
mMutex
)
;
*
state
=
mSecurityState
;
return
NS_OK
;
}
void
TransportSecurityInfo
:
:
SetSecurityState
(
uint32_t
aState
)
{
MutexAutoLock
lock
(
mMutex
)
;
mSecurityState
=
aState
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetErrorCodeString
(
nsAString
&
aErrorString
)
{
MutexAutoLock
lock
(
mMutex
)
;
const
char
*
codeName
=
PR_ErrorToName
(
mErrorCode
)
;
aErrorString
.
Truncate
(
)
;
if
(
codeName
)
{
aErrorString
=
NS_ConvertASCIItoUTF16
(
codeName
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetInterface
(
const
nsIID
&
uuid
void
*
*
result
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_ERROR
(
"
nsNSSSocketInfo
:
:
GetInterface
called
off
the
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
MutexAutoLock
lock
(
mMutex
)
;
nsresult
rv
;
if
(
!
mCallbacks
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
ir
=
new
PipUIContext
(
)
;
rv
=
ir
-
>
GetInterface
(
uuid
result
)
;
}
else
{
rv
=
mCallbacks
-
>
GetInterface
(
uuid
result
)
;
}
return
rv
;
}
#
define
TRANSPORTSECURITYINFOMAGIC
\
{
\
0xa9863a23
0x1faa
0x4169
{
\
0xb0
0xd2
0x81
0x29
0xec
0x7c
0xb1
0xde
\
}
\
}
static
NS_DEFINE_CID
(
kTransportSecurityInfoMagic
TRANSPORTSECURITYINFOMAGIC
)
;
NS_IMETHODIMP
TransportSecurityInfo
:
:
Write
(
nsIObjectOutputStream
*
aStream
)
{
nsresult
rv
=
aStream
-
>
WriteID
(
kTransportSecurityInfoMagic
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MutexAutoLock
lock
(
mMutex
)
;
rv
=
aStream
-
>
Write32
(
mSecurityState
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
Write32
(
0
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
Write32
(
0
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
Write32
(
static_cast
<
uint32_t
>
(
mErrorCode
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
WriteWStringZ
(
NS_ConvertUTF8toUTF16
(
"
6
"
)
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
NS_WriteOptionalCompoundObject
(
aStream
mServerCert
NS_GET_IID
(
nsIX509Cert
)
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
Write16
(
mCipherSuite
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
Write16
(
mProtocolVersion
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteBoolean
(
mIsDomainMismatch
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteBoolean
(
mIsNotValidAtThisTime
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteBoolean
(
mIsUntrusted
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteBoolean
(
mIsEV
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteBoolean
(
mHasIsEVStatus
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteBoolean
(
mHaveCipherSuiteAndProtocol
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteBoolean
(
mHaveCertErrorBits
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
Write16
(
mCertificateTransparencyStatus
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteStringZ
(
mKeaGroup
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
WriteStringZ
(
mSignatureSchemeName
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
Write16
(
mSucceededCertChain
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
cert
:
mSucceededCertChain
)
{
rv
=
aStream
-
>
WriteCompoundObject
(
cert
NS_GET_IID
(
nsIX509Cert
)
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
aStream
-
>
Write16
(
mFailedCertChain
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
cert
:
mFailedCertChain
)
{
rv
=
aStream
-
>
WriteCompoundObject
(
cert
NS_GET_IID
(
nsIX509Cert
)
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
aStream
-
>
WriteBoolean
(
mIsDelegatedCredential
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
WriteBoolean
(
mNPNCompleted
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
WriteStringZ
(
mNegotiatedNPN
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
WriteBoolean
(
mResumed
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
WriteBoolean
(
mIsBuiltCertChainRootBuiltInRoot
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
WriteBoolean
(
mIsAcceptedEch
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
#
define
CHILD_DIAGNOSTIC_ASSERT
(
condition
message
)
\
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
{
\
MOZ_DIAGNOSTIC_ASSERT
(
condition
message
)
;
\
}
nsresult
TransportSecurityInfo
:
:
ReadSSLStatus
(
nsIObjectInputStream
*
aStream
MutexAutoLock
&
aProofOfLock
)
{
bool
nsISSLStatusPresent
;
nsresult
rv
=
aStream
-
>
ReadBoolean
(
&
nsISSLStatusPresent
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
nsISSLStatusPresent
)
{
return
NS_OK
;
}
nsCID
cid
;
nsIID
iid
;
rv
=
aStream
-
>
ReadID
(
&
cid
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadID
(
&
iid
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
static
const
nsIID
nsSSLStatusIID
=
{
0xfa9ba95b
0xca3b
0x498a
{
0xb8
0x89
0x7c
0x79
0xcf
0x28
0xfe
0xe8
}
}
;
if
(
!
iid
.
Equals
(
nsSSLStatusIID
)
)
{
CHILD_DIAGNOSTIC_ASSERT
(
false
"
Deserialization
should
not
fail
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsISupports
>
cert
;
rv
=
aStream
-
>
ReadObject
(
true
getter_AddRefs
(
cert
)
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cert
)
{
mServerCert
=
do_QueryInterface
(
cert
)
;
if
(
!
mServerCert
)
{
CHILD_DIAGNOSTIC_ASSERT
(
false
"
Deserialization
should
not
fail
"
)
;
return
NS_NOINTERFACE
;
}
}
rv
=
aStream
-
>
Read16
(
&
mCipherSuite
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint16_t
protocolVersionAndStreamFormatVersion
;
rv
=
aStream
-
>
Read16
(
&
protocolVersionAndStreamFormatVersion
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mProtocolVersion
=
protocolVersionAndStreamFormatVersion
&
0xFF
;
const
uint8_t
streamFormatVersion
=
(
protocolVersionAndStreamFormatVersion
>
>
8
)
&
0xFF
;
rv
=
aStream
-
>
ReadBoolean
(
&
mIsDomainMismatch
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mIsNotValidAtThisTime
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mIsUntrusted
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mIsEV
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mHasIsEVStatus
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mHaveCipherSuiteAndProtocol
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mHaveCertErrorBits
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
streamFormatVersion
>
=
1
)
{
rv
=
aStream
-
>
Read16
(
&
mCertificateTransparencyStatus
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
streamFormatVersion
>
=
2
)
{
rv
=
aStream
-
>
ReadCString
(
mKeaGroup
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadCString
(
mSignatureSchemeName
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
streamFormatVersion
>
=
3
)
{
rv
=
ReadCertList
(
aStream
mSucceededCertChain
aProofOfLock
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
failedCertChain
;
rv
=
ReadCertList
(
aStream
failedCertChain
aProofOfLock
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
rv
;
}
nsresult
TransportSecurityInfo
:
:
ReadCertList
(
nsIObjectInputStream
*
aStream
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aCertList
MutexAutoLock
&
aProofOfLock
)
{
bool
nsIX509CertListPresent
;
nsresult
rv
=
aStream
-
>
ReadBoolean
(
&
nsIX509CertListPresent
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
nsIX509CertListPresent
)
{
return
NS_OK
;
}
nsCID
cid
;
nsIID
iid
;
rv
=
aStream
-
>
ReadID
(
&
cid
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadID
(
&
iid
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
static
const
nsIID
nsIX509CertListIID
=
{
0xae74cda5
0xcd2f
0x473f
{
0x96
0xf5
0xf0
0xb7
0xff
0xf6
0x2c
0x68
}
}
;
if
(
!
iid
.
Equals
(
nsIX509CertListIID
)
)
{
CHILD_DIAGNOSTIC_ASSERT
(
false
"
Deserialization
should
not
fail
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
certListSize
;
rv
=
aStream
-
>
Read32
(
&
certListSize
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ReadCertificatesFromStream
(
aStream
certListSize
aCertList
aProofOfLock
)
;
}
nsresult
TransportSecurityInfo
:
:
ReadCertificatesFromStream
(
nsIObjectInputStream
*
aStream
uint32_t
aSize
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aCertList
MutexAutoLock
&
aProofOfLock
)
{
nsresult
rv
;
for
(
uint32_t
i
=
0
;
i
<
aSize
;
+
+
i
)
{
nsCOMPtr
<
nsISupports
>
support
;
rv
=
aStream
-
>
ReadObject
(
true
getter_AddRefs
(
support
)
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIX509Cert
>
cert
=
do_QueryInterface
(
support
)
;
if
(
!
cert
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
nsIX509Cert
>
castedCert
(
cert
.
get
(
)
)
;
aCertList
.
AppendElement
(
castedCert
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
Read
(
nsIObjectInputStream
*
aStream
)
{
nsID
id
;
nsresult
rv
=
aStream
-
>
ReadID
(
&
id
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
id
.
Equals
(
kTransportSecurityInfoMagic
)
)
{
CHILD_DIAGNOSTIC_ASSERT
(
false
"
Deserialization
should
not
fail
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
MutexAutoLock
lock
(
mMutex
)
;
rv
=
aStream
-
>
Read32
(
&
mSecurityState
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
unusedSubRequestsBrokenSecurity
;
rv
=
aStream
-
>
Read32
(
&
unusedSubRequestsBrokenSecurity
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
unusedSubRequestsNoSecurity
;
rv
=
aStream
-
>
Read32
(
&
unusedSubRequestsNoSecurity
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
errorCode
;
rv
=
aStream
-
>
Read32
(
&
errorCode
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mErrorCode
=
static_cast
<
PRErrorCode
>
(
errorCode
)
;
if
(
mErrorCode
!
=
0
)
{
mCanceled
=
true
;
}
nsAutoString
serVersion
;
rv
=
aStream
-
>
ReadString
(
serVersion
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
serVersion
.
EqualsASCII
(
"
1
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
2
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
3
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
4
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
5
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
6
"
)
)
{
rv
=
ReadSSLStatus
(
aStream
lock
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsISupports
>
cert
;
rv
=
NS_ReadOptionalObject
(
aStream
true
getter_AddRefs
(
cert
)
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cert
!
=
nullptr
)
{
mServerCert
=
do_QueryInterface
(
cert
)
;
if
(
!
mServerCert
)
{
CHILD_DIAGNOSTIC_ASSERT
(
false
"
Deserialization
should
not
fail
"
)
;
return
NS_NOINTERFACE
;
}
}
rv
=
aStream
-
>
Read16
(
&
mCipherSuite
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
Read16
(
&
mProtocolVersion
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mIsDomainMismatch
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mIsNotValidAtThisTime
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mIsUntrusted
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mIsEV
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mHasIsEVStatus
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mHaveCipherSuiteAndProtocol
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
mHaveCertErrorBits
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
Read16
(
&
mCertificateTransparencyStatus
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadCString
(
mKeaGroup
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
ReadCString
(
mSignatureSchemeName
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
serVersion
.
EqualsASCII
(
"
3
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
4
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
5
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
6
"
)
)
{
rv
=
ReadCertList
(
aStream
mSucceededCertChain
lock
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
uint16_t
certCount
;
rv
=
aStream
-
>
Read16
(
&
certCount
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadCertificatesFromStream
(
aStream
certCount
mSucceededCertChain
lock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
!
serVersion
.
EqualsASCII
(
"
3
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
4
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
5
"
)
&
&
!
serVersion
.
EqualsASCII
(
"
6
"
)
)
{
rv
=
ReadCertList
(
aStream
mFailedCertChain
lock
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
uint16_t
certCount
;
rv
=
aStream
-
>
Read16
(
&
certCount
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ReadCertificatesFromStream
(
aStream
certCount
mFailedCertChain
lock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
serVersion
.
EqualsASCII
(
"
2
"
)
|
|
serVersion
.
EqualsASCII
(
"
3
"
)
|
|
serVersion
.
EqualsASCII
(
"
4
"
)
|
|
serVersion
.
EqualsASCII
(
"
5
"
)
|
|
serVersion
.
EqualsASCII
(
"
6
"
)
)
{
rv
=
aStream
-
>
ReadBoolean
(
&
mIsDelegatedCredential
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
serVersion
.
EqualsASCII
(
"
4
"
)
|
|
serVersion
.
EqualsASCII
(
"
5
"
)
|
|
serVersion
.
EqualsASCII
(
"
6
"
)
)
{
rv
=
aStream
-
>
ReadBoolean
(
&
mNPNCompleted
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
ReadCString
(
mNegotiatedNPN
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
aStream
-
>
ReadBoolean
(
&
mResumed
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
serVersion
.
EqualsASCII
(
"
5
"
)
|
|
serVersion
.
EqualsASCII
(
"
6
"
)
)
{
rv
=
aStream
-
>
ReadBoolean
(
&
mIsBuiltCertChainRootBuiltInRoot
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
serVersion
.
EqualsASCII
(
"
6
"
)
)
{
rv
=
aStream
-
>
ReadBoolean
(
&
mIsAcceptedEch
)
;
CHILD_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Deserialization
should
not
fail
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
#
undef
CHILD_DIAGNOSTIC_ASSERT
void
TransportSecurityInfo
:
:
SerializeToIPC
(
IPC
:
:
Message
*
aMsg
)
{
MutexAutoLock
guard
(
mMutex
)
;
int32_t
errorCode
=
static_cast
<
int32_t
>
(
mErrorCode
)
;
WriteParam
(
aMsg
mSecurityState
)
;
WriteParam
(
aMsg
errorCode
)
;
WriteParam
(
aMsg
mServerCert
)
;
WriteParam
(
aMsg
mCipherSuite
)
;
WriteParam
(
aMsg
mProtocolVersion
)
;
WriteParam
(
aMsg
mIsDomainMismatch
)
;
WriteParam
(
aMsg
mIsNotValidAtThisTime
)
;
WriteParam
(
aMsg
mIsUntrusted
)
;
WriteParam
(
aMsg
mIsEV
)
;
WriteParam
(
aMsg
mHasIsEVStatus
)
;
WriteParam
(
aMsg
mHaveCipherSuiteAndProtocol
)
;
WriteParam
(
aMsg
mHaveCertErrorBits
)
;
WriteParam
(
aMsg
mCertificateTransparencyStatus
)
;
WriteParam
(
aMsg
mKeaGroup
)
;
WriteParam
(
aMsg
mSignatureSchemeName
)
;
WriteParam
(
aMsg
mSucceededCertChain
)
;
WriteParam
(
aMsg
mFailedCertChain
)
;
WriteParam
(
aMsg
mIsDelegatedCredential
)
;
WriteParam
(
aMsg
mNPNCompleted
)
;
WriteParam
(
aMsg
mNegotiatedNPN
)
;
WriteParam
(
aMsg
mResumed
)
;
WriteParam
(
aMsg
mIsBuiltCertChainRootBuiltInRoot
)
;
WriteParam
(
aMsg
mIsAcceptedEch
)
;
}
bool
TransportSecurityInfo
:
:
DeserializeFromIPC
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
)
{
MutexAutoLock
guard
(
mMutex
)
;
int32_t
errorCode
=
0
;
if
(
!
ReadParam
(
aMsg
aIter
&
mSecurityState
)
|
|
!
ReadParam
(
aMsg
aIter
&
errorCode
)
|
|
!
ReadParam
(
aMsg
aIter
&
mServerCert
)
|
|
!
ReadParam
(
aMsg
aIter
&
mCipherSuite
)
|
|
!
ReadParam
(
aMsg
aIter
&
mProtocolVersion
)
|
|
!
ReadParam
(
aMsg
aIter
&
mIsDomainMismatch
)
|
|
!
ReadParam
(
aMsg
aIter
&
mIsNotValidAtThisTime
)
|
|
!
ReadParam
(
aMsg
aIter
&
mIsUntrusted
)
|
|
!
ReadParam
(
aMsg
aIter
&
mIsEV
)
|
|
!
ReadParam
(
aMsg
aIter
&
mHasIsEVStatus
)
|
|
!
ReadParam
(
aMsg
aIter
&
mHaveCipherSuiteAndProtocol
)
|
|
!
ReadParam
(
aMsg
aIter
&
mHaveCertErrorBits
)
|
|
!
ReadParam
(
aMsg
aIter
&
mCertificateTransparencyStatus
)
|
|
!
ReadParam
(
aMsg
aIter
&
mKeaGroup
)
|
|
!
ReadParam
(
aMsg
aIter
&
mSignatureSchemeName
)
|
|
!
ReadParam
(
aMsg
aIter
&
mSucceededCertChain
)
|
|
!
ReadParam
(
aMsg
aIter
&
mFailedCertChain
)
|
|
!
ReadParam
(
aMsg
aIter
&
mIsDelegatedCredential
)
|
|
!
ReadParam
(
aMsg
aIter
&
mNPNCompleted
)
|
|
!
ReadParam
(
aMsg
aIter
&
mNegotiatedNPN
)
|
|
!
ReadParam
(
aMsg
aIter
&
mResumed
)
|
|
!
ReadParam
(
aMsg
aIter
&
mIsBuiltCertChainRootBuiltInRoot
)
|
|
!
ReadParam
(
aMsg
aIter
&
mIsAcceptedEch
)
)
{
return
false
;
}
mErrorCode
=
static_cast
<
PRErrorCode
>
(
errorCode
)
;
if
(
mErrorCode
!
=
0
)
{
mCanceled
=
true
;
}
return
true
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetInterfaces
(
nsTArray
<
nsIID
>
&
array
)
{
array
.
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetScriptableHelper
(
nsIXPCScriptable
*
*
_retval
)
{
*
_retval
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetContractID
(
nsACString
&
aContractID
)
{
aContractID
.
SetIsVoid
(
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetClassDescription
(
nsACString
&
aClassDescription
)
{
aClassDescription
.
SetIsVoid
(
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetClassID
(
nsCID
*
*
aClassID
)
{
*
aClassID
=
(
nsCID
*
)
moz_xmalloc
(
sizeof
(
nsCID
)
)
;
return
GetClassIDNoAlloc
(
*
aClassID
)
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetFlags
(
uint32_t
*
aFlags
)
{
*
aFlags
=
0
;
return
NS_OK
;
}
static
NS_DEFINE_CID
(
kNSSSocketInfoCID
TRANSPORTSECURITYINFO_CID
)
;
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetClassIDNoAlloc
(
nsCID
*
aClassIDNoAlloc
)
{
*
aClassIDNoAlloc
=
kNSSSocketInfoCID
;
return
NS_OK
;
}
RememberCertErrorsTable
*
RememberCertErrorsTable
:
:
sInstance
=
nullptr
;
RememberCertErrorsTable
:
:
RememberCertErrorsTable
(
)
:
mErrorHosts
(
)
mMutex
(
"
RememberCertErrorsTable
:
:
mMutex
"
)
{
}
static
nsresult
GetHostPortKey
(
TransportSecurityInfo
*
infoObject
nsCString
&
result
)
{
MOZ_ASSERT
(
infoObject
)
;
NS_ENSURE_ARG
(
infoObject
)
;
result
.
Truncate
(
)
;
result
.
Assign
(
infoObject
-
>
GetHostName
(
)
)
;
result
.
Append
(
'
:
'
)
;
result
.
AppendInt
(
infoObject
-
>
GetPort
(
)
)
;
return
NS_OK
;
}
void
RememberCertErrorsTable
:
:
RememberCertHasError
(
TransportSecurityInfo
*
infoObject
SECStatus
certVerificationResult
)
{
nsresult
rv
;
nsAutoCString
hostPortKey
;
rv
=
GetHostPortKey
(
infoObject
hostPortKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
certVerificationResult
!
=
SECSuccess
)
{
MOZ_ASSERT
(
infoObject
-
>
mHaveCertErrorBits
"
Must
have
error
bits
when
remembering
flags
"
)
;
if
(
!
infoObject
-
>
mHaveCertErrorBits
)
{
return
;
}
CertStateBits
bits
;
bits
.
mIsDomainMismatch
=
infoObject
-
>
mIsDomainMismatch
;
bits
.
mIsNotValidAtThisTime
=
infoObject
-
>
mIsNotValidAtThisTime
;
bits
.
mIsUntrusted
=
infoObject
-
>
mIsUntrusted
;
MutexAutoLock
lock
(
mMutex
)
;
mErrorHosts
.
Put
(
hostPortKey
bits
)
;
}
else
{
MutexAutoLock
lock
(
mMutex
)
;
mErrorHosts
.
Remove
(
hostPortKey
)
;
}
}
void
RememberCertErrorsTable
:
:
LookupCertErrorBits
(
TransportSecurityInfo
*
infoObject
)
{
if
(
infoObject
-
>
mHaveCertErrorBits
)
{
return
;
}
nsresult
rv
;
nsAutoCString
hostPortKey
;
rv
=
GetHostPortKey
(
infoObject
hostPortKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CertStateBits
bits
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mErrorHosts
.
Get
(
hostPortKey
&
bits
)
)
{
return
;
}
}
infoObject
-
>
mHaveCertErrorBits
=
true
;
infoObject
-
>
mIsDomainMismatch
=
bits
.
mIsDomainMismatch
;
infoObject
-
>
mIsNotValidAtThisTime
=
bits
.
mIsNotValidAtThisTime
;
infoObject
-
>
mIsUntrusted
=
bits
.
mIsUntrusted
;
}
void
TransportSecurityInfo
:
:
SetStatusErrorBits
(
nsNSSCertificate
*
cert
uint32_t
collected_errors
)
{
SetServerCert
(
cert
EVStatus
:
:
NotEV
)
;
MutexAutoLock
lock
(
mMutex
)
;
mHaveCertErrorBits
=
true
;
mIsDomainMismatch
=
collected_errors
&
nsICertOverrideService
:
:
ERROR_MISMATCH
;
mIsNotValidAtThisTime
=
collected_errors
&
nsICertOverrideService
:
:
ERROR_TIME
;
mIsUntrusted
=
collected_errors
&
nsICertOverrideService
:
:
ERROR_UNTRUSTED
;
RememberCertErrorsTable
:
:
GetInstance
(
)
.
RememberCertHasError
(
this
SECFailure
)
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetFailedCertChain
(
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aFailedCertChain
)
{
MOZ_ASSERT
(
aFailedCertChain
.
IsEmpty
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
aFailedCertChain
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
aFailedCertChain
.
AppendElements
(
mFailedCertChain
)
;
return
NS_OK
;
}
static
nsresult
CreateCertChain
(
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aOutput
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
aCertList
)
{
nsTArray
<
nsTArray
<
uint8_t
>
>
certList
=
std
:
:
move
(
aCertList
)
;
aOutput
.
Clear
(
)
;
for
(
auto
&
certBytes
:
certList
)
{
RefPtr
<
nsIX509Cert
>
cert
=
nsNSSCertificate
:
:
ConstructFromDER
(
BitwiseCast
<
char
*
uint8_t
*
>
(
certBytes
.
Elements
(
)
)
certBytes
.
Length
(
)
)
;
if
(
!
cert
)
{
return
NS_ERROR_FAILURE
;
}
aOutput
.
AppendElement
(
cert
)
;
}
return
NS_OK
;
}
nsresult
TransportSecurityInfo
:
:
SetFailedCertChain
(
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
aCertList
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
CreateCertChain
(
mFailedCertChain
std
:
:
move
(
aCertList
)
)
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetServerCert
(
nsIX509Cert
*
*
aServerCert
)
{
NS_ENSURE_ARG_POINTER
(
aServerCert
)
;
MutexAutoLock
lock
(
mMutex
)
;
nsCOMPtr
<
nsIX509Cert
>
cert
=
mServerCert
;
cert
.
forget
(
aServerCert
)
;
return
NS_OK
;
}
void
TransportSecurityInfo
:
:
SetServerCert
(
nsNSSCertificate
*
aServerCert
EVStatus
aEVStatus
)
{
MOZ_ASSERT
(
aServerCert
)
;
MutexAutoLock
lock
(
mMutex
)
;
mServerCert
=
aServerCert
;
mIsEV
=
(
aEVStatus
=
=
EVStatus
:
:
EV
)
;
mHasIsEVStatus
=
true
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetSucceededCertChain
(
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aSucceededCertChain
)
{
MOZ_ASSERT
(
aSucceededCertChain
.
IsEmpty
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
aSucceededCertChain
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
aSucceededCertChain
.
AppendElements
(
mSucceededCertChain
)
;
return
NS_OK
;
}
nsresult
TransportSecurityInfo
:
:
SetSucceededCertChain
(
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
aCertList
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
CreateCertChain
(
mSucceededCertChain
std
:
:
move
(
aCertList
)
)
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
SetIsBuiltCertChainRootBuiltInRoot
(
bool
aIsBuiltInRoot
)
{
MutexAutoLock
lock
(
mMutex
)
;
mIsBuiltCertChainRootBuiltInRoot
=
aIsBuiltInRoot
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetIsBuiltCertChainRootBuiltInRoot
(
bool
*
aIsBuiltInRoot
)
{
NS_ENSURE_ARG_POINTER
(
aIsBuiltInRoot
)
;
MutexAutoLock
lock
(
mMutex
)
;
*
aIsBuiltInRoot
=
mIsBuiltCertChainRootBuiltInRoot
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetCipherName
(
nsACString
&
aCipherName
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mHaveCipherSuiteAndProtocol
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
SSLCipherSuiteInfo
cipherInfo
;
if
(
SSL_GetCipherSuiteInfo
(
mCipherSuite
&
cipherInfo
sizeof
(
cipherInfo
)
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
aCipherName
.
Assign
(
cipherInfo
.
cipherSuiteName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetKeyLength
(
uint32_t
*
aKeyLength
)
{
NS_ENSURE_ARG_POINTER
(
aKeyLength
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mHaveCipherSuiteAndProtocol
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
SSLCipherSuiteInfo
cipherInfo
;
if
(
SSL_GetCipherSuiteInfo
(
mCipherSuite
&
cipherInfo
sizeof
(
cipherInfo
)
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
*
aKeyLength
=
cipherInfo
.
symKeyBits
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetSecretKeyLength
(
uint32_t
*
aSecretKeyLength
)
{
NS_ENSURE_ARG_POINTER
(
aSecretKeyLength
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mHaveCipherSuiteAndProtocol
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
SSLCipherSuiteInfo
cipherInfo
;
if
(
SSL_GetCipherSuiteInfo
(
mCipherSuite
&
cipherInfo
sizeof
(
cipherInfo
)
)
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
*
aSecretKeyLength
=
cipherInfo
.
effectiveKeyBits
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetKeaGroupName
(
nsACString
&
aKeaGroup
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mHaveCipherSuiteAndProtocol
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
aKeaGroup
.
Assign
(
mKeaGroup
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetSignatureSchemeName
(
nsACString
&
aSignatureScheme
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mHaveCipherSuiteAndProtocol
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
aSignatureScheme
.
Assign
(
mSignatureSchemeName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetProtocolVersion
(
uint16_t
*
aProtocolVersion
)
{
NS_ENSURE_ARG_POINTER
(
aProtocolVersion
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mHaveCipherSuiteAndProtocol
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aProtocolVersion
=
mProtocolVersion
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetCertificateTransparencyStatus
(
uint16_t
*
aCertificateTransparencyStatus
)
{
NS_ENSURE_ARG_POINTER
(
aCertificateTransparencyStatus
)
;
MutexAutoLock
lock
(
mMutex
)
;
*
aCertificateTransparencyStatus
=
mCertificateTransparencyStatus
;
return
NS_OK
;
}
uint16_t
TransportSecurityInfo
:
:
ConvertCertificateTransparencyInfoToStatus
(
const
mozilla
:
:
psm
:
:
CertificateTransparencyInfo
&
info
)
{
using
mozilla
:
:
ct
:
:
CTPolicyCompliance
;
if
(
!
info
.
enabled
)
{
return
nsITransportSecurityInfo
:
:
CERTIFICATE_TRANSPARENCY_NOT_APPLICABLE
;
}
switch
(
info
.
policyCompliance
)
{
case
CTPolicyCompliance
:
:
Compliant
:
return
nsITransportSecurityInfo
:
:
CERTIFICATE_TRANSPARENCY_POLICY_COMPLIANT
;
case
CTPolicyCompliance
:
:
NotEnoughScts
:
return
nsITransportSecurityInfo
:
:
CERTIFICATE_TRANSPARENCY_POLICY_NOT_ENOUGH_SCTS
;
case
CTPolicyCompliance
:
:
NotDiverseScts
:
return
nsITransportSecurityInfo
:
:
CERTIFICATE_TRANSPARENCY_POLICY_NOT_DIVERSE_SCTS
;
case
CTPolicyCompliance
:
:
Unknown
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
CTPolicyCompliance
type
"
)
;
}
return
nsITransportSecurityInfo
:
:
CERTIFICATE_TRANSPARENCY_NOT_APPLICABLE
;
}
nsTArray
<
nsTArray
<
uint8_t
>
>
TransportSecurityInfo
:
:
CreateCertBytesArray
(
const
UniqueCERTCertList
&
aCertChain
)
{
nsTArray
<
nsTArray
<
uint8_t
>
>
certsBytes
;
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
aCertChain
)
;
!
CERT_LIST_END
(
n
aCertChain
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
nsTArray
<
uint8_t
>
certBytes
;
certBytes
.
AppendElements
(
n
-
>
cert
-
>
derCert
.
data
n
-
>
cert
-
>
derCert
.
len
)
;
certsBytes
.
AppendElement
(
std
:
:
move
(
certBytes
)
)
;
}
return
certsBytes
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetIsDomainMismatch
(
bool
*
aIsDomainMismatch
)
{
NS_ENSURE_ARG_POINTER
(
aIsDomainMismatch
)
;
MutexAutoLock
lock
(
mMutex
)
;
*
aIsDomainMismatch
=
mHaveCertErrorBits
&
&
mIsDomainMismatch
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetIsNotValidAtThisTime
(
bool
*
aIsNotValidAtThisTime
)
{
NS_ENSURE_ARG_POINTER
(
aIsNotValidAtThisTime
)
;
MutexAutoLock
lock
(
mMutex
)
;
*
aIsNotValidAtThisTime
=
mHaveCertErrorBits
&
&
mIsNotValidAtThisTime
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetIsUntrusted
(
bool
*
aIsUntrusted
)
{
NS_ENSURE_ARG_POINTER
(
aIsUntrusted
)
;
MutexAutoLock
lock
(
mMutex
)
;
*
aIsUntrusted
=
mHaveCertErrorBits
&
&
mIsUntrusted
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetIsExtendedValidation
(
bool
*
aIsEV
)
{
NS_ENSURE_ARG_POINTER
(
aIsEV
)
;
*
aIsEV
=
false
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
mHaveCertErrorBits
)
{
return
NS_OK
;
}
if
(
mHasIsEVStatus
)
{
*
aIsEV
=
mIsEV
;
return
NS_OK
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetIsAcceptedEch
(
bool
*
aIsAcceptedEch
)
{
NS_ENSURE_ARG_POINTER
(
aIsAcceptedEch
)
;
if
(
!
mHaveCipherSuiteAndProtocol
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aIsAcceptedEch
=
mIsAcceptedEch
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetIsDelegatedCredential
(
bool
*
aIsDelegCred
)
{
NS_ENSURE_ARG_POINTER
(
aIsDelegCred
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mHaveCipherSuiteAndProtocol
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aIsDelegCred
=
mIsDelegatedCredential
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetNegotiatedNPN
(
nsACString
&
aNegotiatedNPN
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mNPNCompleted
)
{
return
NS_ERROR_NOT_CONNECTED
;
}
aNegotiatedNPN
=
mNegotiatedNPN
;
return
NS_OK
;
}
NS_IMETHODIMP
TransportSecurityInfo
:
:
GetResumed
(
bool
*
aResumed
)
{
MutexAutoLock
lock
(
mMutex
)
;
*
aResumed
=
mResumed
;
return
NS_OK
;
}
void
TransportSecurityInfo
:
:
SetResumed
(
bool
aResumed
)
{
MutexAutoLock
lock
(
mMutex
)
;
mResumed
=
aResumed
;
}
}
}
