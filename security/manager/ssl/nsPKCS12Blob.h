#
ifndef
nsPKCS12Blob_h
#
define
nsPKCS12Blob_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsNSSShutDown
.
h
"
#
include
"
nsString
.
h
"
#
include
"
p12
.
h
"
#
include
"
seccomon
.
h
"
class
nsIFile
;
class
nsIX509Cert
;
class
nsPKCS12Blob
:
public
nsNSSShutDownObject
{
public
:
nsPKCS12Blob
(
)
;
virtual
~
nsPKCS12Blob
(
)
{
}
nsresult
ImportFromFile
(
nsIFile
*
file
)
;
nsresult
ExportToFile
(
nsIFile
*
file
nsIX509Cert
*
*
certs
int
numCerts
)
;
private
:
nsCOMPtr
<
nsIMutableArray
>
mCertArray
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mUIContext
;
nsresult
getPKCS12FilePassword
(
SECItem
*
)
;
nsresult
newPKCS12FilePassword
(
SECItem
*
)
;
nsresult
inputToDecoder
(
SEC_PKCS12DecoderContext
*
nsIFile
*
)
;
nsresult
unicodeToItem
(
const
nsString
&
uni
SECItem
*
item
)
;
void
handleError
(
int
myerr
=
0
)
;
enum
RetryReason
{
rr_do_not_retry
rr_bad_password
rr_auto_retry_empty_password_flavors
}
;
enum
ImportMode
{
im_standard_prompt
im_try_zero_length_secitem
}
;
nsresult
ImportFromFileHelper
(
nsIFile
*
file
ImportMode
aImportMode
RetryReason
&
aWantRetry
)
;
PRFileDesc
*
mTmpFile
;
static
SECItem
*
nickname_collision
(
SECItem
*
PRBool
*
void
*
)
;
static
void
write_export_file
(
void
*
arg
const
char
*
buf
unsigned
long
len
)
;
}
;
#
endif
