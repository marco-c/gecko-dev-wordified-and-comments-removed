#
include
"
DataStorage
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISafeOutputStream
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
private
/
pprio
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
nsILocalFileWin
.
h
"
#
endif
static
const
uint32_t
sDataStorageDefaultTimerDelay
=
5u
*
60u
*
1000u
;
static
const
uint32_t
sMaxScore
=
UINT32_MAX
;
static
const
uint32_t
sMaxDataEntries
=
1024
;
static
const
int64_t
sOneDayInMicroseconds
=
int64_t
(
24
*
60
*
60
)
*
PR_USEC_PER_SEC
;
namespace
mozilla
{
NS_IMPL_ISUPPORTS
(
DataStorageManager
nsIDataStorageManager
)
NS_IMPL_ISUPPORTS
(
DataStorageItem
nsIDataStorageItem
)
NS_IMPL_ISUPPORTS
(
DataStorage
nsIDataStorage
nsIMemoryReporter
nsIObserver
)
NS_IMETHODIMP
DataStorageManager
:
:
Get
(
nsIDataStorageManager
:
:
DataStorage
aDataStorage
nsIDataStorage
*
*
aResult
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
nsAutoString
filename
;
switch
(
aDataStorage
)
{
case
nsIDataStorageManager
:
:
AlternateServices
:
if
(
mAlternateServicesCreated
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
mAlternateServicesCreated
=
true
;
filename
.
Assign
(
u
"
AlternateServices
.
txt
"
_ns
)
;
break
;
case
nsIDataStorageManager
:
:
ClientAuthRememberList
:
if
(
mClientAuthRememberListCreated
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
mClientAuthRememberListCreated
=
true
;
filename
.
Assign
(
u
"
ClientAuthRememberList
.
txt
"
_ns
)
;
break
;
case
nsIDataStorageManager
:
:
SiteSecurityServiceState
:
if
(
mSiteSecurityServiceStateCreated
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
mSiteSecurityServiceStateCreated
=
true
;
filename
.
Assign
(
u
"
SiteSecurityServiceState
.
txt
"
_ns
)
;
break
;
default
:
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
mozilla
:
:
DataStorage
>
dataStorage
(
new
mozilla
:
:
DataStorage
(
filename
)
)
;
nsresult
rv
=
dataStorage
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIMemoryReporter
>
memoryReporter
(
dataStorage
.
get
(
)
)
;
RegisterStrongMemoryReporter
(
memoryReporter
)
;
*
aResult
=
dataStorage
.
forget
(
)
.
take
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DataStorageItem
:
:
GetKey
(
nsACString
&
aKey
)
{
aKey
.
Assign
(
key
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DataStorageItem
:
:
GetValue
(
nsACString
&
aValue
)
{
aValue
.
Assign
(
value
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DataStorageItem
:
:
GetType
(
nsIDataStorage
:
:
DataType
*
aType
)
{
if
(
!
aType
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aType
=
type
;
return
NS_OK
;
}
DataStorage
:
:
DataStorage
(
const
nsString
&
aFilename
)
:
mMutex
(
"
DataStorage
:
:
mMutex
"
)
mPendingWrite
(
false
)
mTimerArmed
(
false
)
mShuttingDown
(
false
)
mInitCalled
(
false
)
mReadyMonitor
(
"
DataStorage
:
:
mReadyMonitor
"
)
mReady
(
false
)
mFilename
(
aFilename
)
{
}
nsresult
DataStorage
:
:
Init
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
DataStorage
:
:
Init
called
off
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
DataStorage
used
in
non
-
parent
process
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MutexAutoLock
lock
(
mMutex
)
;
if
(
mInitCalled
)
{
return
NS_OK
;
}
mInitCalled
=
true
;
nsCOMPtr
<
nsISerialEventTarget
>
target
;
nsresult
rv
=
NS_CreateBackgroundTaskQueue
(
"
DataStorage
:
:
mBackgroundTaskQueue
"
getter_AddRefs
(
target
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mBackgroundTaskQueue
=
TaskQueue
:
:
Create
(
target
.
forget
(
)
"
PSM
DataStorage
"
)
;
mTimerDelayMS
=
Preferences
:
:
GetInt
(
"
test
.
datastorage
.
write_timer_ms
"
sDataStorageDefaultTimerDelay
)
;
rv
=
AsyncReadData
(
lock
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
os
)
)
{
return
NS_ERROR_FAILURE
;
}
os
-
>
AddObserver
(
this
"
last
-
pb
-
context
-
exited
"
false
)
;
os
-
>
AddObserver
(
this
"
profile
-
before
-
change
"
false
)
;
os
-
>
AddObserver
(
this
"
xpcom
-
shutdown
-
threads
"
false
)
;
os
-
>
AddObserver
(
this
"
application
-
background
"
false
)
;
return
NS_OK
;
}
class
DataStorage
:
:
Reader
:
public
Runnable
{
public
:
explicit
Reader
(
DataStorage
*
aDataStorage
)
:
Runnable
(
"
DataStorage
:
:
Reader
"
)
mDataStorage
(
aDataStorage
)
{
}
~
Reader
(
)
;
private
:
NS_DECL_NSIRUNNABLE
static
nsresult
ParseLine
(
nsDependentCSubstring
&
aLine
nsCString
&
aKeyOut
Entry
&
aEntryOut
)
;
RefPtr
<
DataStorage
>
mDataStorage
;
}
;
DataStorage
:
:
Reader
:
:
~
Reader
(
)
{
{
MonitorAutoLock
readyLock
(
mDataStorage
-
>
mReadyMonitor
)
;
mDataStorage
-
>
mReady
=
true
;
mDataStorage
-
>
mReadyMonitor
.
NotifyAll
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
job
=
NewRunnableMethod
<
const
char
*
>
(
"
DataStorage
:
:
NotifyObservers
"
mDataStorage
&
DataStorage
:
:
NotifyObservers
"
data
-
storage
-
ready
"
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
job
NS_DISPATCH_NORMAL
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
NS_IMETHODIMP
DataStorage
:
:
Reader
:
:
Run
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
file
;
{
MutexAutoLock
lock
(
mDataStorage
-
>
mMutex
)
;
if
(
!
mDataStorage
-
>
mBackingFile
)
{
return
NS_OK
;
}
rv
=
mDataStorage
-
>
mBackingFile
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsCOMPtr
<
nsIInputStream
>
fileInputStream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
fileInputStream
)
file
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FILE_NOT_FOUND
)
)
{
return
rv
;
}
nsCString
data
;
if
(
fileInputStream
)
{
rv
=
NS_ConsumeStream
(
fileInputStream
1u
<
<
21
data
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
{
MutexAutoLock
lock
(
mDataStorage
-
>
mMutex
)
;
int32_t
currentIndex
=
0
;
int32_t
newlineIndex
=
0
;
do
{
newlineIndex
=
data
.
FindChar
(
'
\
n
'
currentIndex
)
;
if
(
newlineIndex
<
0
|
|
mDataStorage
-
>
mPersistentDataTable
.
Count
(
)
>
=
sMaxDataEntries
)
{
break
;
}
nsDependentCSubstring
line
(
data
currentIndex
newlineIndex
-
currentIndex
)
;
currentIndex
=
newlineIndex
+
1
;
nsCString
key
;
Entry
entry
;
nsresult
parseRV
=
ParseLine
(
line
key
entry
)
;
if
(
NS_SUCCEEDED
(
parseRV
)
)
{
mDataStorage
-
>
mPersistentDataTable
.
LookupOrInsert
(
key
std
:
:
move
(
entry
)
)
;
}
}
while
(
true
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DATA_STORAGE_ENTRIES
mDataStorage
-
>
mPersistentDataTable
.
Count
(
)
)
;
}
return
NS_OK
;
}
nsresult
DataStorage
:
:
ValidateKeyAndValue
(
const
nsACString
&
aKey
const
nsACString
&
aValue
)
{
if
(
aKey
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aKey
.
Length
(
)
>
256
)
{
return
NS_ERROR_INVALID_ARG
;
}
int32_t
delimiterIndex
=
aKey
.
FindChar
(
'
\
t
'
0
)
;
if
(
delimiterIndex
>
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
delimiterIndex
=
aKey
.
FindChar
(
'
\
n
'
0
)
;
if
(
delimiterIndex
>
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
delimiterIndex
=
aValue
.
FindChar
(
'
\
n
'
0
)
;
if
(
delimiterIndex
>
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aValue
.
Length
(
)
>
1024
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
nsresult
DataStorage
:
:
Reader
:
:
ParseLine
(
nsDependentCSubstring
&
aLine
nsCString
&
aKeyOut
Entry
&
aEntryOut
)
{
int32_t
scoreIndex
;
scoreIndex
=
aLine
.
FindChar
(
'
\
t
'
0
)
+
1
;
if
(
scoreIndex
<
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
int32_t
accessedIndex
=
aLine
.
FindChar
(
'
\
t
'
scoreIndex
)
+
1
;
if
(
accessedIndex
<
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
int32_t
valueIndex
=
aLine
.
FindChar
(
'
\
t
'
accessedIndex
)
+
1
;
if
(
valueIndex
<
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsDependentCSubstring
keyPart
(
aLine
0
scoreIndex
-
1
)
;
nsDependentCSubstring
scorePart
(
aLine
scoreIndex
accessedIndex
-
scoreIndex
-
1
)
;
nsDependentCSubstring
accessedPart
(
aLine
accessedIndex
valueIndex
-
accessedIndex
-
1
)
;
nsDependentCSubstring
valuePart
(
aLine
valueIndex
)
;
nsresult
rv
;
rv
=
DataStorage
:
:
ValidateKeyAndValue
(
nsCString
(
keyPart
)
nsCString
(
valuePart
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
int32_t
integer
=
nsCString
(
scorePart
)
.
ToInteger
(
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
integer
<
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
aEntryOut
.
mScore
=
(
uint32_t
)
integer
;
integer
=
nsCString
(
accessedPart
)
.
ToInteger
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
integer
<
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
aEntryOut
.
mLastAccessed
=
integer
;
aKeyOut
.
Assign
(
keyPart
)
;
aEntryOut
.
mValue
.
Assign
(
valuePart
)
;
return
NS_OK
;
}
nsresult
DataStorage
:
:
AsyncReadData
(
const
MutexAutoLock
&
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
nsCOMPtr
<
nsIRunnable
>
job
(
new
Reader
(
this
)
)
;
nsresult
rv
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
mBackingFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mBackingFile
=
nullptr
;
return
NS_OK
;
}
rv
=
mBackingFile
-
>
Append
(
mFilename
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mBackgroundTaskQueue
-
>
Dispatch
(
job
.
forget
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DataStorage
:
:
IsReady
(
bool
*
aReady
)
{
if
(
!
aReady
)
{
return
NS_ERROR_INVALID_ARG
;
}
MonitorAutoLock
readyLock
(
mReadyMonitor
)
;
*
aReady
=
mReady
;
return
NS_OK
;
}
void
DataStorage
:
:
WaitForReady
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mInitCalled
"
Waiting
before
Init
(
)
has
been
called
?
"
)
;
MonitorAutoLock
readyLock
(
mReadyMonitor
)
;
while
(
!
mReady
)
{
readyLock
.
Wait
(
)
;
}
MOZ_ASSERT
(
mReady
)
;
}
NS_IMETHODIMP
DataStorage
:
:
Get
(
const
nsACString
&
aKey
nsIDataStorage
:
:
DataType
aType
nsACString
&
aValue
)
{
WaitForReady
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
Entry
entry
;
bool
foundValue
=
GetInternal
(
aKey
&
entry
aType
lock
)
;
if
(
!
foundValue
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
entry
.
UpdateScore
(
)
)
{
PutInternal
(
aKey
entry
aType
lock
)
;
}
aValue
.
Assign
(
entry
.
mValue
)
;
return
NS_OK
;
}
bool
DataStorage
:
:
GetInternal
(
const
nsACString
&
aKey
Entry
*
aEntry
nsIDataStorage
:
:
DataType
aType
const
MutexAutoLock
&
aProofOfLock
)
{
DataStorageTable
&
table
=
GetTableForType
(
aType
aProofOfLock
)
;
bool
foundValue
=
table
.
Get
(
aKey
aEntry
)
;
return
foundValue
;
}
DataStorage
:
:
DataStorageTable
&
DataStorage
:
:
GetTableForType
(
nsIDataStorage
:
:
DataType
aType
const
MutexAutoLock
&
)
{
switch
(
aType
)
{
case
nsIDataStorage
:
:
DataType
:
:
Persistent
:
return
mPersistentDataTable
;
case
nsIDataStorage
:
:
DataType
:
:
Temporary
:
return
mTemporaryDataTable
;
case
nsIDataStorage
:
:
DataType
:
:
Private
:
return
mPrivateDataTable
;
}
MOZ_CRASH
(
"
given
bad
DataStorage
storage
type
"
)
;
}
void
DataStorage
:
:
ReadAllFromTable
(
nsIDataStorage
:
:
DataType
aType
nsTArray
<
RefPtr
<
nsIDataStorageItem
>
>
&
aItems
const
MutexAutoLock
&
aProofOfLock
)
{
for
(
auto
iter
=
GetTableForType
(
aType
aProofOfLock
)
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCOMPtr
<
nsIDataStorageItem
>
item
(
new
DataStorageItem
(
iter
.
Key
(
)
iter
.
Data
(
)
.
mValue
aType
)
)
;
aItems
.
AppendElement
(
item
)
;
}
}
NS_IMETHODIMP
DataStorage
:
:
GetAll
(
nsTArray
<
RefPtr
<
nsIDataStorageItem
>
>
&
aItems
)
{
WaitForReady
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
aItems
.
SetCapacity
(
mPersistentDataTable
.
Count
(
)
+
mTemporaryDataTable
.
Count
(
)
+
mPrivateDataTable
.
Count
(
)
)
;
ReadAllFromTable
(
nsIDataStorage
:
:
DataType
:
:
Persistent
aItems
lock
)
;
ReadAllFromTable
(
nsIDataStorage
:
:
DataType
:
:
Temporary
aItems
lock
)
;
ReadAllFromTable
(
nsIDataStorage
:
:
DataType
:
:
Private
aItems
lock
)
;
return
NS_OK
;
}
void
DataStorage
:
:
MaybeEvictOneEntry
(
nsIDataStorage
:
:
DataType
aType
const
MutexAutoLock
&
aProofOfLock
)
{
DataStorageTable
&
table
=
GetTableForType
(
aType
aProofOfLock
)
;
if
(
table
.
Count
(
)
>
=
sMaxDataEntries
)
{
KeyAndEntry
toEvict
;
toEvict
.
mEntry
.
mScore
=
sMaxScore
;
for
(
auto
iter
=
table
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Entry
entry
=
iter
.
UserData
(
)
;
if
(
entry
.
mScore
<
toEvict
.
mEntry
.
mScore
)
{
toEvict
.
mKey
=
iter
.
Key
(
)
;
toEvict
.
mEntry
=
entry
;
}
}
table
.
Remove
(
toEvict
.
mKey
)
;
}
}
NS_IMETHODIMP
DataStorage
:
:
Put
(
const
nsACString
&
aKey
const
nsACString
&
aValue
nsIDataStorage
:
:
DataType
aType
)
{
WaitForReady
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
nsresult
rv
;
rv
=
ValidateKeyAndValue
(
aKey
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Entry
entry
;
bool
exists
=
GetInternal
(
aKey
&
entry
aType
lock
)
;
if
(
exists
)
{
entry
.
UpdateScore
(
)
;
}
else
{
MaybeEvictOneEntry
(
aType
lock
)
;
}
entry
.
mValue
=
aValue
;
return
PutInternal
(
aKey
entry
aType
lock
)
;
}
nsresult
DataStorage
:
:
PutInternal
(
const
nsACString
&
aKey
Entry
&
aEntry
nsIDataStorage
:
:
DataType
aType
const
MutexAutoLock
&
aProofOfLock
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
DataStorageTable
&
table
=
GetTableForType
(
aType
aProofOfLock
)
;
table
.
InsertOrUpdate
(
aKey
aEntry
)
;
if
(
aType
=
=
nsIDataStorage
:
:
DataType
:
:
Persistent
)
{
mPendingWrite
=
true
;
ArmTimer
(
aProofOfLock
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DataStorage
:
:
Remove
(
const
nsACString
&
aKey
nsIDataStorage
:
:
DataType
aType
)
{
WaitForReady
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
DataStorageTable
&
table
=
GetTableForType
(
aType
lock
)
;
table
.
Remove
(
aKey
)
;
if
(
aType
=
=
nsIDataStorage
:
:
DataType
:
:
Persistent
)
{
mPendingWrite
=
true
;
ArmTimer
(
lock
)
;
}
return
NS_OK
;
}
class
DataStorage
:
:
Writer
final
:
public
Runnable
{
public
:
Writer
(
nsCString
&
aData
DataStorage
*
aDataStorage
)
:
Runnable
(
"
DataStorage
:
:
Writer
"
)
mData
(
aData
)
mDataStorage
(
aDataStorage
)
{
}
protected
:
NS_DECL_NSIRUNNABLE
nsCString
mData
;
RefPtr
<
DataStorage
>
mDataStorage
;
}
;
NS_IMETHODIMP
DataStorage
:
:
Writer
:
:
Run
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
file
;
{
MutexAutoLock
lock
(
mDataStorage
-
>
mMutex
)
;
if
(
!
mDataStorage
-
>
mBackingFile
)
{
return
NS_OK
;
}
rv
=
mDataStorage
-
>
mBackingFile
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
rv
=
NS_NewSafeLocalFileOutputStream
(
getter_AddRefs
(
outputStream
)
file
PR_CREATE_FILE
|
PR_TRUNCATE
|
PR_WRONLY
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
outputStream
)
{
return
NS_OK
;
}
const
char
*
ptr
=
mData
.
get
(
)
;
uint32_t
remaining
=
mData
.
Length
(
)
;
uint32_t
written
=
0
;
while
(
remaining
>
0
)
{
rv
=
outputStream
-
>
Write
(
ptr
remaining
&
written
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
remaining
-
=
written
;
ptr
+
=
written
;
}
nsCOMPtr
<
nsISafeOutputStream
>
safeOutputStream
=
do_QueryInterface
(
outputStream
)
;
if
(
!
safeOutputStream
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
safeOutputStream
-
>
Finish
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIRunnable
>
job
=
NewRunnableMethod
<
const
char
*
>
(
"
DataStorage
:
:
NotifyObservers
"
mDataStorage
&
DataStorage
:
:
NotifyObservers
"
data
-
storage
-
written
"
)
;
rv
=
NS_DispatchToMainThread
(
job
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
DataStorage
:
:
AsyncWriteData
(
const
MutexAutoLock
&
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mPendingWrite
|
|
mShuttingDown
|
|
!
mBackingFile
)
{
return
NS_OK
;
}
nsCString
output
;
for
(
auto
iter
=
mPersistentDataTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Entry
entry
=
iter
.
UserData
(
)
;
output
.
Append
(
iter
.
Key
(
)
)
;
output
.
Append
(
'
\
t
'
)
;
output
.
AppendInt
(
entry
.
mScore
)
;
output
.
Append
(
'
\
t
'
)
;
output
.
AppendInt
(
entry
.
mLastAccessed
)
;
output
.
Append
(
'
\
t
'
)
;
output
.
Append
(
entry
.
mValue
)
;
output
.
Append
(
'
\
n
'
)
;
}
nsCOMPtr
<
nsIRunnable
>
job
(
new
Writer
(
output
this
)
)
;
nsresult
rv
=
mBackgroundTaskQueue
-
>
Dispatch
(
job
.
forget
(
)
)
;
mPendingWrite
=
false
;
if
(
mTimerArmed
)
{
rv
=
mTimer
-
>
Cancel
(
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
mTimerArmed
=
false
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DataStorage
:
:
Clear
(
)
{
WaitForReady
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
mPersistentDataTable
.
Clear
(
)
;
mTemporaryDataTable
.
Clear
(
)
;
mPrivateDataTable
.
Clear
(
)
;
mPendingWrite
=
true
;
return
AsyncWriteData
(
lock
)
;
}
void
DataStorage
:
:
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
DataStorage
>
aDataStorage
=
(
DataStorage
*
)
aClosure
;
MutexAutoLock
lock
(
aDataStorage
-
>
mMutex
)
;
aDataStorage
-
>
mTimerArmed
=
false
;
Unused
<
<
aDataStorage
-
>
AsyncWriteData
(
lock
)
;
}
void
DataStorage
:
:
NotifyObservers
(
const
char
*
aTopic
)
{
if
(
!
NS_IsMainThread
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
DataStorage
:
:
NotifyObservers
called
off
main
thread
"
)
;
return
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
aTopic
mFilename
.
get
(
)
)
;
}
}
void
DataStorage
:
:
ArmTimer
(
const
MutexAutoLock
&
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mTimerArmed
)
{
return
;
}
if
(
!
mTimer
)
{
mTimer
=
NS_NewTimer
(
mBackgroundTaskQueue
)
;
if
(
NS_WARN_IF
(
!
mTimer
)
)
{
return
;
}
}
nsresult
rv
=
mTimer
-
>
InitWithNamedFuncCallback
(
DataStorage
:
:
TimerCallback
this
mTimerDelayMS
nsITimer
:
:
TYPE_ONE_SHOT
"
DataStorageTimer
"
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
mTimerArmed
=
true
;
}
void
DataStorage
:
:
ShutdownTimer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTimer
)
{
nsresult
rv
=
mTimer
-
>
Cancel
(
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
mTimer
=
nullptr
;
}
}
NS_IMETHODIMP
DataStorage
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MutexAutoLock
lock
(
mMutex
)
;
size_t
sizeOfExcludingThis
=
mPersistentDataTable
.
ShallowSizeOfExcludingThis
(
MallocSizeOf
)
+
mTemporaryDataTable
.
ShallowSizeOfExcludingThis
(
MallocSizeOf
)
+
mPrivateDataTable
.
ShallowSizeOfExcludingThis
(
MallocSizeOf
)
+
mFilename
.
SizeOfExcludingThisIfUnshared
(
MallocSizeOf
)
;
size_t
amount
=
MallocSizeOf
(
this
)
+
sizeOfExcludingThis
;
nsPrintfCString
path
(
"
explicit
/
data
-
storage
/
%
s
"
NS_ConvertUTF16toUTF8
(
mFilename
)
.
get
(
)
)
;
return
aHandleReport
-
>
Callback
(
"
"
_ns
path
KIND_HEAP
UNITS_BYTES
amount
"
Memory
used
by
PSM
data
storage
cache
.
"
_ns
aData
)
;
}
NS_IMETHODIMP
DataStorage
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
if
(
!
NS_IsMainThread
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
DataStorage
:
:
Observe
called
off
main
thread
"
)
;
return
NS_ERROR_NOT_SAME_THREAD
;
}
if
(
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
=
=
0
)
{
MutexAutoLock
lock
(
mMutex
)
;
mPrivateDataTable
.
Clear
(
)
;
return
NS_OK
;
}
if
(
strcmp
(
aTopic
"
profile
-
before
-
change
"
)
=
=
0
|
|
strcmp
(
aTopic
"
xpcom
-
shutdown
-
threads
"
)
=
=
0
)
{
RefPtr
<
TaskQueue
>
taskQueueToAwait
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mShuttingDown
)
{
nsresult
rv
=
AsyncWriteData
(
lock
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
mShuttingDown
=
true
;
mBackgroundTaskQueue
-
>
BeginShutdown
(
)
;
taskQueueToAwait
=
mBackgroundTaskQueue
;
}
}
if
(
taskQueueToAwait
)
{
taskQueueToAwait
-
>
AwaitShutdownAndIdle
(
)
;
}
ShutdownTimer
(
)
;
}
if
(
strcmp
(
aTopic
"
application
-
background
"
)
=
=
0
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mShuttingDown
)
{
nsresult
rv
=
AsyncWriteData
(
lock
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
}
return
NS_OK
;
}
DataStorage
:
:
Entry
:
:
Entry
(
)
:
mScore
(
0
)
mLastAccessed
(
(
int32_t
)
(
PR_Now
(
)
/
sOneDayInMicroseconds
)
)
{
}
bool
DataStorage
:
:
Entry
:
:
UpdateScore
(
)
{
int32_t
nowInDays
=
(
int32_t
)
(
PR_Now
(
)
/
sOneDayInMicroseconds
)
;
int32_t
daysSinceAccessed
=
(
nowInDays
-
mLastAccessed
)
;
mLastAccessed
=
nowInDays
;
if
(
daysSinceAccessed
<
1
)
{
return
false
;
}
if
(
mScore
<
sMaxScore
)
{
mScore
+
+
;
}
return
true
;
}
}
