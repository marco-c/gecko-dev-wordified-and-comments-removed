#
include
"
nsNSSCallbacks
.
h
"
#
include
"
PSMRunnable
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
SharedCertVerifier
.
h
"
#
include
"
SharedSSLState
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIProtocolProxyService
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsIStreamLoader
.
h
"
#
include
"
nsITokenDialogs
.
h
"
#
include
"
nsIUploadChannel
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsNSSCertHelper
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsNSSHelper
.
h
"
#
include
"
nsNSSIOLayer
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsProtectedAuthThread
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozpkix
/
pkixtypes
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslproto
.
h
"
#
include
"
SSLTokensCache
.
h
"
#
include
"
TrustOverrideUtils
.
h
"
#
include
"
TrustOverride
-
SymantecData
.
inc
"
#
include
"
TrustOverride
-
AppleGoogleDigiCertData
.
inc
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
extern
LazyLogModule
gPIPNSSLog
;
static
void
AccumulateCipherSuite
(
Telemetry
:
:
HistogramID
probe
const
SSLChannelInfo
&
channelInfo
)
;
namespace
{
const
uint32_t
POSSIBLE_VERSION_DOWNGRADE
=
4
;
const
uint32_t
POSSIBLE_CIPHER_SUITE_DOWNGRADE
=
2
;
const
uint32_t
KEA_NOT_SUPPORTED
=
1
;
}
class
OCSPRequest
final
:
public
nsIStreamLoaderObserver
public
nsIRunnable
{
public
:
OCSPRequest
(
const
nsACString
&
aiaLocation
const
OriginAttributes
&
originAttributes
const
uint8_t
(
&
ocspRequest
)
[
OCSP_REQUEST_MAX_LENGTH
]
size_t
ocspRequestLength
TimeDuration
timeout
)
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSISTREAMLOADEROBSERVER
NS_DECL_NSIRUNNABLE
nsresult
DispatchToMainThreadAndWait
(
)
;
nsresult
GetResponse
(
Vector
<
uint8_t
>
&
response
)
;
private
:
~
OCSPRequest
(
)
=
default
;
static
void
OnTimeout
(
nsITimer
*
timer
void
*
closure
)
;
nsresult
NotifyDone
(
nsresult
rv
MonitorAutoLock
&
proofOfLock
)
;
Monitor
mMonitor
MOZ_UNANNOTATED
;
bool
mNotifiedDone
;
nsCOMPtr
<
nsIStreamLoader
>
mLoader
;
const
nsCString
mAIALocation
;
const
OriginAttributes
mOriginAttributes
;
const
mozilla
:
:
Span
<
const
char
>
mPOSTData
;
const
TimeDuration
mTimeout
;
nsCOMPtr
<
nsITimer
>
mTimeoutTimer
;
TimeStamp
mStartTime
;
nsresult
mResponseResult
;
Vector
<
uint8_t
>
mResponseBytes
;
}
;
NS_IMPL_ISUPPORTS
(
OCSPRequest
nsIStreamLoaderObserver
nsIRunnable
)
OCSPRequest
:
:
OCSPRequest
(
const
nsACString
&
aiaLocation
const
OriginAttributes
&
originAttributes
const
uint8_t
(
&
ocspRequest
)
[
OCSP_REQUEST_MAX_LENGTH
]
size_t
ocspRequestLength
TimeDuration
timeout
)
:
mMonitor
(
"
OCSPRequest
.
mMonitor
"
)
mNotifiedDone
(
false
)
mLoader
(
nullptr
)
mAIALocation
(
aiaLocation
)
mOriginAttributes
(
originAttributes
)
mPOSTData
(
reinterpret_cast
<
const
char
*
>
(
ocspRequest
)
ocspRequestLength
)
mTimeout
(
timeout
)
mTimeoutTimer
(
nullptr
)
mStartTime
(
)
mResponseResult
(
NS_ERROR_FAILURE
)
mResponseBytes
(
)
{
MOZ_ASSERT
(
ocspRequestLength
<
=
OCSP_REQUEST_MAX_LENGTH
)
;
}
nsresult
OCSPRequest
:
:
DispatchToMainThreadAndWait
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
return
NS_ERROR_FAILURE
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
while
(
!
mNotifiedDone
)
{
lock
.
Wait
(
)
;
}
TimeStamp
endTime
=
TimeStamp
:
:
Now
(
)
;
if
(
mStartTime
.
IsNull
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_VALIDATION_HTTP_REQUEST_RESULT
3
)
;
}
else
if
(
mResponseResult
=
=
NS_ERROR_NET_TIMEOUT
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_VALIDATION_HTTP_REQUEST_RESULT
0
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
CERT_VALIDATION_HTTP_REQUEST_CANCELED_TIME
mStartTime
endTime
)
;
}
else
if
(
NS_SUCCEEDED
(
mResponseResult
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_VALIDATION_HTTP_REQUEST_RESULT
1
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
CERT_VALIDATION_HTTP_REQUEST_SUCCEEDED_TIME
mStartTime
endTime
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_VALIDATION_HTTP_REQUEST_RESULT
2
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
CERT_VALIDATION_HTTP_REQUEST_FAILED_TIME
mStartTime
endTime
)
;
}
return
rv
;
}
nsresult
OCSPRequest
:
:
GetResponse
(
Vector
<
uint8_t
>
&
response
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
return
NS_ERROR_FAILURE
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
!
mNotifiedDone
)
{
return
NS_ERROR_IN_PROGRESS
;
}
if
(
NS_FAILED
(
mResponseResult
)
)
{
return
mResponseResult
;
}
response
.
clear
(
)
;
if
(
!
response
.
append
(
mResponseBytes
.
begin
(
)
mResponseBytes
.
length
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
static
constexpr
auto
OCSP_REQUEST_MIME_TYPE
=
"
application
/
ocsp
-
request
"
_ns
;
static
constexpr
auto
OCSP_REQUEST_METHOD
=
"
POST
"
_ns
;
NS_IMETHODIMP
OCSPRequest
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_FAILURE
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
nsCOMPtr
<
nsIIOService
>
ios
=
do_GetIOService
(
)
;
if
(
!
ios
)
{
return
NotifyDone
(
NS_ERROR_FAILURE
lock
)
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
mAIALocation
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
NS_ERROR_MALFORMED_URI
lock
)
;
}
nsAutoCString
scheme
;
rv
=
uri
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
if
(
!
scheme
.
LowerCaseEqualsLiteral
(
"
http
"
)
)
{
return
NotifyDone
(
NS_ERROR_MALFORMED_URI
lock
)
;
}
nsCOMPtr
<
nsIProtocolProxyService
>
pps
=
do_GetService
(
NS_PROTOCOLPROXYSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
if
(
pps
-
>
GetIsPACLoading
(
)
)
{
return
NotifyDone
(
NS_ERROR_FAILURE
lock
)
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
ios
-
>
NewChannel
(
mAIALocation
nullptr
nullptr
nullptr
nsContentUtils
:
:
GetSystemPrincipal
(
)
nullptr
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
getter_AddRefs
(
channel
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
nsCOMPtr
<
nsISupportsPriority
>
priorityChannel
=
do_QueryInterface
(
channel
)
;
if
(
priorityChannel
)
{
priorityChannel
-
>
AdjustPriority
(
nsISupportsPriority
:
:
PRIORITY_HIGHEST
)
;
}
channel
-
>
SetLoadFlags
(
nsIRequest
:
:
LOAD_ANONYMOUS
|
nsIRequest
:
:
LOAD_BYPASS_CACHE
|
nsIRequest
:
:
INHIBIT_CACHING
|
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
|
nsIChannel
:
:
LOAD_BYPASS_URL_CLASSIFIER
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
uint32_t
httpsOnlyStatus
=
loadInfo
-
>
GetHttpsOnlyStatus
(
)
;
httpsOnlyStatus
|
=
nsILoadInfo
:
:
HTTPS_ONLY_EXEMPT
;
loadInfo
-
>
SetHttpsOnlyStatus
(
httpsOnlyStatus
)
;
loadInfo
-
>
SetAllowDeprecatedSystemRequests
(
true
)
;
if
(
mOriginAttributes
!
=
OriginAttributes
(
)
)
{
OriginAttributes
attrs
;
attrs
.
mFirstPartyDomain
=
mOriginAttributes
.
mFirstPartyDomain
;
attrs
.
mPrivateBrowsingId
=
mOriginAttributes
.
mPrivateBrowsingId
;
rv
=
loadInfo
-
>
SetOriginAttributes
(
attrs
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
}
nsCOMPtr
<
nsIInputStream
>
uploadStream
;
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
uploadStream
)
mPOSTData
NS_ASSIGNMENT_COPY
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
nsCOMPtr
<
nsIUploadChannel
>
uploadChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
!
uploadChannel
)
{
return
NotifyDone
(
NS_ERROR_FAILURE
lock
)
;
}
rv
=
uploadChannel
-
>
SetUploadStream
(
uploadStream
OCSP_REQUEST_MIME_TYPE
-
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
channel
)
;
if
(
!
internalChannel
)
{
return
NotifyDone
(
rv
lock
)
;
}
rv
=
internalChannel
-
>
SetAllowSpdy
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
rv
=
internalChannel
-
>
SetAllowHttp3
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
rv
=
internalChannel
-
>
SetIsOCSP
(
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
hchan
=
do_QueryInterface
(
channel
)
;
if
(
!
hchan
)
{
return
NotifyDone
(
NS_ERROR_FAILURE
lock
)
;
}
rv
=
hchan
-
>
SetAllowSTS
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
rv
=
hchan
-
>
SetRequestMethod
(
OCSP_REQUEST_METHOD
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
rv
=
NS_NewStreamLoader
(
getter_AddRefs
(
mLoader
)
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
rv
=
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mTimeoutTimer
)
OCSPRequest
:
:
OnTimeout
this
mTimeout
.
ToMilliseconds
(
)
nsITimer
:
:
TYPE_ONE_SHOT
"
OCSPRequest
:
:
Run
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
rv
=
hchan
-
>
AsyncOpen
(
this
-
>
mLoader
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
mStartTime
=
TimeStamp
:
:
Now
(
)
;
return
NS_OK
;
}
nsresult
OCSPRequest
:
:
NotifyDone
(
nsresult
rv
MonitorAutoLock
&
lock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mNotifiedDone
)
{
return
mResponseResult
;
}
mLoader
=
nullptr
;
mResponseResult
=
rv
;
if
(
mTimeoutTimer
)
{
Unused
<
<
mTimeoutTimer
-
>
Cancel
(
)
;
}
mNotifiedDone
=
true
;
lock
.
Notify
(
)
;
return
rv
;
}
NS_IMETHODIMP
OCSPRequest
:
:
OnStreamComplete
(
nsIStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
responseLen
const
uint8_t
*
responseBytes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_FAILURE
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
if
(
NS_FAILED
(
aStatus
)
)
{
return
NotifyDone
(
aStatus
lock
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
hchan
=
do_QueryInterface
(
req
)
;
if
(
!
hchan
)
{
return
NotifyDone
(
NS_ERROR_FAILURE
lock
)
;
}
bool
requestSucceeded
;
rv
=
hchan
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
if
(
!
requestSucceeded
)
{
return
NotifyDone
(
NS_ERROR_FAILURE
lock
)
;
}
unsigned
int
rcode
;
rv
=
hchan
-
>
GetResponseStatus
(
&
rcode
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NotifyDone
(
rv
lock
)
;
}
if
(
rcode
!
=
200
)
{
return
NotifyDone
(
NS_ERROR_FAILURE
lock
)
;
}
mResponseBytes
.
clear
(
)
;
if
(
!
mResponseBytes
.
append
(
responseBytes
responseLen
)
)
{
return
NotifyDone
(
NS_ERROR_OUT_OF_MEMORY
lock
)
;
}
mResponseResult
=
aStatus
;
return
NotifyDone
(
NS_OK
lock
)
;
}
void
OCSPRequest
:
:
OnTimeout
(
nsITimer
*
timer
void
*
closure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
OCSPRequest
*
self
=
static_cast
<
OCSPRequest
*
>
(
closure
)
;
MonitorAutoLock
lock
(
self
-
>
mMonitor
)
;
self
-
>
mTimeoutTimer
=
nullptr
;
self
-
>
NotifyDone
(
NS_ERROR_NET_TIMEOUT
lock
)
;
}
mozilla
:
:
pkix
:
:
Result
DoOCSPRequest
(
const
nsCString
&
aiaLocation
const
OriginAttributes
&
originAttributes
uint8_t
(
&
ocspRequest
)
[
OCSP_REQUEST_MAX_LENGTH
]
size_t
ocspRequestLength
TimeDuration
timeout
Vector
<
uint8_t
>
&
result
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
return
mozilla
:
:
pkix
:
:
Result
:
:
ERROR_OCSP_UNKNOWN_CERT
;
}
if
(
ocspRequestLength
>
OCSP_REQUEST_MAX_LENGTH
)
{
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
result
.
clear
(
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
DoOCSPRequest
to
'
%
s
'
"
aiaLocation
.
get
(
)
)
)
;
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
)
;
MOZ_ASSERT
(
sts
)
;
if
(
!
sts
)
{
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_INVALID_STATE
;
}
bool
onSTSThread
;
nsresult
rv
=
sts
-
>
IsOnCurrentThread
(
&
onSTSThread
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
MOZ_ASSERT
(
!
onSTSThread
)
;
if
(
onSTSThread
)
{
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_INVALID_STATE
;
}
RefPtr
<
OCSPRequest
>
request
(
new
OCSPRequest
(
aiaLocation
originAttributes
ocspRequest
ocspRequestLength
timeout
)
)
;
rv
=
request
-
>
DispatchToMainThreadAndWait
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
mozilla
:
:
pkix
:
:
Result
:
:
FATAL_ERROR_LIBRARY_FAILURE
;
}
rv
=
request
-
>
GetResponse
(
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_MALFORMED_URI
)
{
return
mozilla
:
:
pkix
:
:
Result
:
:
ERROR_CERT_BAD_ACCESS_LOCATION
;
}
return
mozilla
:
:
pkix
:
:
Result
:
:
ERROR_OCSP_SERVER_ERROR
;
}
return
Success
;
}
static
char
*
ShowProtectedAuthPrompt
(
PK11SlotInfo
*
slot
nsIInterfaceRequestor
*
ir
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_ERROR
(
"
ShowProtectedAuthPrompt
called
off
the
main
thread
"
)
;
return
nullptr
;
}
char
*
protAuthRetVal
=
nullptr
;
nsCOMPtr
<
nsITokenDialogs
>
dialogs
;
nsresult
nsrv
=
getNSSDialogs
(
getter_AddRefs
(
dialogs
)
NS_GET_IID
(
nsITokenDialogs
)
NS_TOKENDIALOGS_CONTRACTID
)
;
if
(
NS_SUCCEEDED
(
nsrv
)
)
{
RefPtr
<
nsProtectedAuthThread
>
protectedAuthRunnable
=
new
nsProtectedAuthThread
(
)
;
protectedAuthRunnable
-
>
SetParams
(
slot
)
;
nsrv
=
dialogs
-
>
DisplayProtectedAuth
(
ir
protectedAuthRunnable
)
;
protectedAuthRunnable
-
>
Join
(
)
;
if
(
NS_SUCCEEDED
(
nsrv
)
)
{
SECStatus
rv
=
protectedAuthRunnable
-
>
GetResult
(
)
;
switch
(
rv
)
{
case
SECSuccess
:
protAuthRetVal
=
ToNewCString
(
nsDependentCString
(
PK11_PW_AUTHENTICATED
)
)
;
break
;
case
SECWouldBlock
:
protAuthRetVal
=
ToNewCString
(
nsDependentCString
(
PK11_PW_RETRY
)
)
;
break
;
default
:
protAuthRetVal
=
nullptr
;
break
;
}
}
}
return
protAuthRetVal
;
}
class
PK11PasswordPromptRunnable
:
public
SyncRunnableBase
{
public
:
PK11PasswordPromptRunnable
(
PK11SlotInfo
*
slot
nsIInterfaceRequestor
*
ir
)
:
mResult
(
nullptr
)
mSlot
(
slot
)
mIR
(
ir
)
{
}
virtual
~
PK11PasswordPromptRunnable
(
)
=
default
;
char
*
mResult
;
virtual
void
RunOnTargetThread
(
)
override
;
private
:
PK11SlotInfo
*
const
mSlot
;
nsIInterfaceRequestor
*
const
mIR
;
}
;
void
PK11PasswordPromptRunnable
:
:
RunOnTargetThread
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPrompt
>
prompt
;
if
(
!
mIR
)
{
rv
=
nsNSSComponent
:
:
GetNewPrompter
(
getter_AddRefs
(
prompt
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
else
{
prompt
=
do_GetInterface
(
mIR
)
;
MOZ_ASSERT
(
prompt
"
Interface
requestor
should
implement
nsIPrompt
"
)
;
}
if
(
!
prompt
)
{
return
;
}
if
(
PK11_ProtectedAuthenticationPath
(
mSlot
)
)
{
mResult
=
ShowProtectedAuthPrompt
(
mSlot
mIR
)
;
return
;
}
nsAutoString
promptString
;
if
(
PK11_IsInternal
(
mSlot
)
)
{
rv
=
GetPIPNSSBundleString
(
"
CertPasswordPromptDefault
"
promptString
)
;
}
else
{
AutoTArray
<
nsString
1
>
formatStrings
=
{
NS_ConvertUTF8toUTF16
(
PK11_GetTokenName
(
mSlot
)
)
}
;
rv
=
PIPBundleFormatStringFromName
(
"
CertPasswordPrompt
"
formatStrings
promptString
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsString
password
;
bool
userClickedOK
=
false
;
rv
=
prompt
-
>
PromptPassword
(
nullptr
promptString
.
get
(
)
getter_Copies
(
password
)
&
userClickedOK
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
userClickedOK
)
{
return
;
}
mResult
=
ToNewUTF8String
(
password
)
;
}
char
*
PK11PasswordPrompt
(
PK11SlotInfo
*
slot
PRBool
void
*
arg
)
{
RefPtr
<
PK11PasswordPromptRunnable
>
runnable
(
new
PK11PasswordPromptRunnable
(
slot
static_cast
<
nsIInterfaceRequestor
*
>
(
arg
)
)
)
;
runnable
-
>
DispatchToMainThreadAndWait
(
)
;
return
runnable
-
>
mResult
;
}
nsCString
getKeaGroupName
(
uint32_t
aKeaGroup
)
{
nsCString
groupName
;
switch
(
aKeaGroup
)
{
case
ssl_grp_ec_secp256r1
:
groupName
=
"
P256
"
_ns
;
break
;
case
ssl_grp_ec_secp384r1
:
groupName
=
"
P384
"
_ns
;
break
;
case
ssl_grp_ec_secp521r1
:
groupName
=
"
P521
"
_ns
;
break
;
case
ssl_grp_ec_curve25519
:
groupName
=
"
x25519
"
_ns
;
break
;
case
ssl_grp_ffdhe_2048
:
groupName
=
"
FF
2048
"
_ns
;
break
;
case
ssl_grp_ffdhe_3072
:
groupName
=
"
FF
3072
"
_ns
;
break
;
case
ssl_grp_none
:
groupName
=
"
none
"
_ns
;
break
;
case
ssl_grp_ffdhe_custom
:
groupName
=
"
custom
"
_ns
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
key
exchange
group
.
"
)
;
groupName
=
"
unknown
group
"
_ns
;
}
return
groupName
;
}
nsCString
getSignatureName
(
uint32_t
aSignatureScheme
)
{
nsCString
signatureName
;
switch
(
aSignatureScheme
)
{
case
ssl_sig_none
:
signatureName
=
"
none
"
_ns
;
break
;
case
ssl_sig_rsa_pkcs1_sha1
:
signatureName
=
"
RSA
-
PKCS1
-
SHA1
"
_ns
;
break
;
case
ssl_sig_rsa_pkcs1_sha256
:
signatureName
=
"
RSA
-
PKCS1
-
SHA256
"
_ns
;
break
;
case
ssl_sig_rsa_pkcs1_sha384
:
signatureName
=
"
RSA
-
PKCS1
-
SHA384
"
_ns
;
break
;
case
ssl_sig_rsa_pkcs1_sha512
:
signatureName
=
"
RSA
-
PKCS1
-
SHA512
"
_ns
;
break
;
case
ssl_sig_ecdsa_secp256r1_sha256
:
signatureName
=
"
ECDSA
-
P256
-
SHA256
"
_ns
;
break
;
case
ssl_sig_ecdsa_secp384r1_sha384
:
signatureName
=
"
ECDSA
-
P384
-
SHA384
"
_ns
;
break
;
case
ssl_sig_ecdsa_secp521r1_sha512
:
signatureName
=
"
ECDSA
-
P521
-
SHA512
"
_ns
;
break
;
case
ssl_sig_rsa_pss_sha256
:
signatureName
=
"
RSA
-
PSS
-
SHA256
"
_ns
;
break
;
case
ssl_sig_rsa_pss_sha384
:
signatureName
=
"
RSA
-
PSS
-
SHA384
"
_ns
;
break
;
case
ssl_sig_rsa_pss_sha512
:
signatureName
=
"
RSA
-
PSS
-
SHA512
"
_ns
;
break
;
case
ssl_sig_ecdsa_sha1
:
signatureName
=
"
ECDSA
-
SHA1
"
_ns
;
break
;
case
ssl_sig_rsa_pkcs1_sha1md5
:
signatureName
=
"
RSA
-
PKCS1
-
SHA1MD5
"
_ns
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
signature
scheme
.
"
)
;
signatureName
=
"
unknown
signature
"
_ns
;
}
return
signatureName
;
}
static
void
PreliminaryHandshakeDone
(
PRFileDesc
*
fd
)
{
nsNSSSocketInfo
*
infoObject
=
(
nsNSSSocketInfo
*
)
fd
-
>
higher
-
>
secret
;
if
(
!
infoObject
)
{
return
;
}
SSLChannelInfo
channelInfo
;
if
(
SSL_GetChannelInfo
(
fd
&
channelInfo
sizeof
(
channelInfo
)
)
!
=
SECSuccess
)
{
return
;
}
SSLCipherSuiteInfo
cipherInfo
;
if
(
SSL_GetCipherSuiteInfo
(
channelInfo
.
cipherSuite
&
cipherInfo
sizeof
(
cipherInfo
)
)
!
=
SECSuccess
)
{
return
;
}
infoObject
-
>
SetPreliminaryHandshakeInfo
(
channelInfo
cipherInfo
)
;
infoObject
-
>
SetSSLVersionUsed
(
channelInfo
.
protocolVersion
)
;
infoObject
-
>
SetEarlyDataAccepted
(
channelInfo
.
earlyDataAccepted
)
;
infoObject
-
>
SetKEAUsed
(
channelInfo
.
keaType
)
;
infoObject
-
>
SetKEAKeyBits
(
channelInfo
.
keaKeyBits
)
;
infoObject
-
>
SetMACAlgorithmUsed
(
cipherInfo
.
macAlgorithm
)
;
if
(
infoObject
-
>
IsPreliminaryHandshakeDone
(
)
)
{
return
;
}
SSLNextProtoState
state
;
unsigned
char
npnbuf
[
256
]
;
unsigned
int
npnlen
;
if
(
SSL_GetNextProto
(
fd
&
state
npnbuf
&
npnlen
AssertedCast
<
unsigned
int
>
(
ArrayLength
(
npnbuf
)
)
)
=
=
SECSuccess
)
{
if
(
state
=
=
SSL_NEXT_PROTO_NEGOTIATED
|
|
state
=
=
SSL_NEXT_PROTO_SELECTED
)
{
infoObject
-
>
SetNegotiatedNPN
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
npnbuf
)
npnlen
)
;
}
else
{
infoObject
-
>
SetNegotiatedNPN
(
nullptr
0
)
;
}
mozilla
:
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_NPN_TYPE
state
)
;
}
else
{
infoObject
-
>
SetNegotiatedNPN
(
nullptr
0
)
;
}
infoObject
-
>
SetPreliminaryHandshakeDone
(
)
;
}
SECStatus
CanFalseStartCallback
(
PRFileDesc
*
fd
void
*
client_data
PRBool
*
canFalseStart
)
{
*
canFalseStart
=
false
;
nsNSSSocketInfo
*
infoObject
=
(
nsNSSSocketInfo
*
)
fd
-
>
higher
-
>
secret
;
if
(
!
infoObject
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
infoObject
-
>
SetFalseStartCallbackCalled
(
)
;
PreliminaryHandshakeDone
(
fd
)
;
uint32_t
reasonsForNotFalseStarting
=
0
;
SSLChannelInfo
channelInfo
;
if
(
SSL_GetChannelInfo
(
fd
&
channelInfo
sizeof
(
channelInfo
)
)
!
=
SECSuccess
)
{
return
SECSuccess
;
}
SSLCipherSuiteInfo
cipherInfo
;
if
(
SSL_GetCipherSuiteInfo
(
channelInfo
.
cipherSuite
&
cipherInfo
sizeof
(
cipherInfo
)
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CanFalseStartCallback
[
%
p
]
failed
-
"
"
KEA
%
d
\
n
"
fd
static_cast
<
int32_t
>
(
channelInfo
.
keaType
)
)
)
;
return
SECSuccess
;
}
if
(
channelInfo
.
protocolVersion
!
=
SSL_LIBRARY_VERSION_TLS_1_2
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CanFalseStartCallback
[
%
p
]
failed
-
"
"
SSL
Version
must
be
TLS
1
.
2
was
%
x
\
n
"
fd
static_cast
<
int32_t
>
(
channelInfo
.
protocolVersion
)
)
)
;
reasonsForNotFalseStarting
|
=
POSSIBLE_VERSION_DOWNGRADE
;
}
if
(
channelInfo
.
keaType
!
=
ssl_kea_ecdh
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CanFalseStartCallback
[
%
p
]
failed
-
"
"
unsupported
KEA
%
d
\
n
"
fd
static_cast
<
int32_t
>
(
channelInfo
.
keaType
)
)
)
;
reasonsForNotFalseStarting
|
=
KEA_NOT_SUPPORTED
;
}
if
(
cipherInfo
.
macAlgorithm
!
=
ssl_mac_aead
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CanFalseStartCallback
[
%
p
]
failed
-
non
-
AEAD
cipher
used
%
d
"
"
is
not
supported
with
False
Start
.
\
n
"
fd
static_cast
<
int32_t
>
(
cipherInfo
.
symCipher
)
)
)
;
reasonsForNotFalseStarting
|
=
POSSIBLE_CIPHER_SUITE_DOWNGRADE
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_REASONS_FOR_NOT_FALSE_STARTING
reasonsForNotFalseStarting
)
;
if
(
reasonsForNotFalseStarting
=
=
0
)
{
*
canFalseStart
=
PR_TRUE
;
infoObject
-
>
SetFalseStarted
(
)
;
infoObject
-
>
NoteTimeUntilReady
(
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
CanFalseStartCallback
[
%
p
]
ok
\
n
"
fd
)
)
;
}
return
SECSuccess
;
}
static
void
AccumulateNonECCKeySize
(
Telemetry
:
:
HistogramID
probe
uint32_t
bits
)
{
unsigned
int
value
=
bits
<
512
?
1
:
bits
=
=
512
?
2
:
bits
<
768
?
3
:
bits
=
=
768
?
4
:
bits
<
1024
?
5
:
bits
=
=
1024
?
6
:
bits
<
1280
?
7
:
bits
=
=
1280
?
8
:
bits
<
1536
?
9
:
bits
=
=
1536
?
10
:
bits
<
2048
?
11
:
bits
=
=
2048
?
12
:
bits
<
3072
?
13
:
bits
=
=
3072
?
14
:
bits
<
4096
?
15
:
bits
=
=
4096
?
16
:
bits
<
8192
?
17
:
bits
=
=
8192
?
18
:
bits
<
16384
?
19
:
bits
=
=
16384
?
20
:
0
;
Telemetry
:
:
Accumulate
(
probe
value
)
;
}
static
void
AccumulateECCCurve
(
Telemetry
:
:
HistogramID
probe
uint32_t
bits
)
{
unsigned
int
value
=
bits
=
=
255
?
29
:
bits
=
=
256
?
23
:
bits
=
=
384
?
24
:
bits
=
=
521
?
25
:
0
;
Telemetry
:
:
Accumulate
(
probe
value
)
;
}
static
void
AccumulateCipherSuite
(
Telemetry
:
:
HistogramID
probe
const
SSLChannelInfo
&
channelInfo
)
{
uint32_t
value
;
switch
(
channelInfo
.
cipherSuite
)
{
case
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
:
value
=
1
;
break
;
case
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
:
value
=
2
;
break
;
case
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
:
value
=
3
;
break
;
case
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
:
value
=
4
;
break
;
case
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
:
value
=
5
;
break
;
case
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
:
value
=
6
;
break
;
case
TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
:
value
=
7
;
break
;
case
TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
:
value
=
10
;
break
;
case
TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
:
value
=
11
;
break
;
case
TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
:
value
=
12
;
break
;
case
TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
:
value
=
13
;
break
;
case
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
:
value
=
14
;
break
;
case
TLS_DHE_RSA_WITH_AES_128_CBC_SHA
:
value
=
21
;
break
;
case
TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
:
value
=
22
;
break
;
case
TLS_DHE_RSA_WITH_AES_256_CBC_SHA
:
value
=
23
;
break
;
case
TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
:
value
=
24
;
break
;
case
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
:
value
=
25
;
break
;
case
TLS_DHE_DSS_WITH_AES_128_CBC_SHA
:
value
=
26
;
break
;
case
TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA
:
value
=
27
;
break
;
case
TLS_DHE_DSS_WITH_AES_256_CBC_SHA
:
value
=
28
;
break
;
case
TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA
:
value
=
29
;
break
;
case
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA
:
value
=
30
;
break
;
case
TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
:
value
=
41
;
break
;
case
TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
:
value
=
42
;
break
;
case
TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
:
value
=
43
;
break
;
case
TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
:
value
=
44
;
break
;
case
TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
:
value
=
45
;
break
;
case
TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
:
value
=
46
;
break
;
case
TLS_RSA_WITH_AES_128_CBC_SHA
:
value
=
61
;
break
;
case
TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
:
value
=
62
;
break
;
case
TLS_RSA_WITH_AES_256_CBC_SHA
:
value
=
63
;
break
;
case
TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
:
value
=
64
;
break
;
case
SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA
:
value
=
65
;
break
;
case
TLS_RSA_WITH_3DES_EDE_CBC_SHA
:
value
=
66
;
break
;
case
TLS_RSA_WITH_SEED_CBC_SHA
:
value
=
67
;
break
;
case
TLS_RSA_WITH_AES_128_GCM_SHA256
:
value
=
68
;
break
;
case
TLS_RSA_WITH_AES_256_GCM_SHA384
:
value
=
69
;
break
;
case
TLS_AES_128_GCM_SHA256
:
value
=
70
;
break
;
case
TLS_CHACHA20_POLY1305_SHA256
:
value
=
71
;
break
;
case
TLS_AES_256_GCM_SHA384
:
value
=
72
;
break
;
default
:
value
=
0
;
break
;
}
MOZ_ASSERT
(
value
!
=
0
)
;
Telemetry
:
:
Accumulate
(
probe
value
)
;
}
static
void
RebuildVerifiedCertificateInformation
(
PRFileDesc
*
fd
nsNSSSocketInfo
*
infoObject
)
{
MOZ_ASSERT
(
fd
)
;
MOZ_ASSERT
(
infoObject
)
;
if
(
!
fd
|
|
!
infoObject
)
{
return
;
}
UniqueCERTCertificate
cert
(
SSL_PeerCertificate
(
fd
)
)
;
MOZ_ASSERT
(
cert
"
SSL_PeerCertificate
failed
in
TLS
handshake
callback
?
"
)
;
if
(
!
cert
)
{
return
;
}
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
maybePeerCertsBytes
;
UniqueCERTCertList
peerCertChain
(
SSL_PeerCertificateChain
(
fd
)
)
;
if
(
!
peerCertChain
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
RebuildVerifiedCertificateInformation
:
failed
to
get
peer
"
"
certificate
chain
"
)
)
;
}
else
{
nsTArray
<
nsTArray
<
uint8_t
>
>
peerCertsBytes
;
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
peerCertChain
)
;
!
CERT_LIST_END
(
n
peerCertChain
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
if
(
n
=
=
CERT_LIST_HEAD
(
peerCertChain
)
)
{
continue
;
}
nsTArray
<
uint8_t
>
certBytes
;
certBytes
.
AppendElements
(
n
-
>
cert
-
>
derCert
.
data
n
-
>
cert
-
>
derCert
.
len
)
;
peerCertsBytes
.
AppendElement
(
std
:
:
move
(
certBytes
)
)
;
}
maybePeerCertsBytes
.
emplace
(
std
:
:
move
(
peerCertsBytes
)
)
;
}
RefPtr
<
SharedCertVerifier
>
certVerifier
(
GetDefaultCertVerifier
(
)
)
;
MOZ_ASSERT
(
certVerifier
"
Certificate
verifier
uninitialized
in
TLS
handshake
callback
?
"
)
;
if
(
!
certVerifier
)
{
return
;
}
const
SECItemArray
*
stapledOCSPResponses
=
SSL_PeerStapledOCSPResponses
(
fd
)
;
Maybe
<
nsTArray
<
uint8_t
>
>
stapledOCSPResponse
;
if
(
stapledOCSPResponses
&
&
stapledOCSPResponses
-
>
len
=
=
1
)
{
stapledOCSPResponse
.
emplace
(
)
;
stapledOCSPResponse
-
>
SetCapacity
(
stapledOCSPResponses
-
>
items
[
0
]
.
len
)
;
stapledOCSPResponse
-
>
AppendElements
(
stapledOCSPResponses
-
>
items
[
0
]
.
data
stapledOCSPResponses
-
>
items
[
0
]
.
len
)
;
}
Maybe
<
nsTArray
<
uint8_t
>
>
sctsFromTLSExtension
;
const
SECItem
*
sctsFromTLSExtensionSECItem
=
SSL_PeerSignedCertTimestamps
(
fd
)
;
if
(
sctsFromTLSExtensionSECItem
)
{
sctsFromTLSExtension
.
emplace
(
)
;
sctsFromTLSExtension
-
>
SetCapacity
(
sctsFromTLSExtensionSECItem
-
>
len
)
;
sctsFromTLSExtension
-
>
AppendElements
(
sctsFromTLSExtensionSECItem
-
>
data
sctsFromTLSExtensionSECItem
-
>
len
)
;
}
int
flags
=
mozilla
:
:
psm
:
:
CertVerifier
:
:
FLAG_LOCAL_ONLY
;
if
(
!
infoObject
-
>
SharedState
(
)
.
IsOCSPStaplingEnabled
(
)
|
|
!
infoObject
-
>
SharedState
(
)
.
IsOCSPMustStapleEnabled
(
)
)
{
flags
|
=
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
;
}
EVStatus
evStatus
;
CertificateTransparencyInfo
certificateTransparencyInfo
;
nsTArray
<
nsTArray
<
uint8_t
>
>
builtChainCertBytes
;
nsTArray
<
uint8_t
>
certBytes
(
cert
-
>
derCert
.
data
cert
-
>
derCert
.
len
)
;
bool
isBuiltCertChainRootBuiltInRoot
=
false
;
mozilla
:
:
pkix
:
:
Result
rv
=
certVerifier
-
>
VerifySSLServerCert
(
certBytes
mozilla
:
:
pkix
:
:
Now
(
)
infoObject
infoObject
-
>
GetHostName
(
)
builtChainCertBytes
flags
maybePeerCertsBytes
stapledOCSPResponse
sctsFromTLSExtension
Nothing
(
)
infoObject
-
>
GetOriginAttributes
(
)
&
evStatus
nullptr
nullptr
nullptr
&
certificateTransparencyInfo
&
isBuiltCertChainRootBuiltInRoot
)
;
if
(
rv
!
=
Success
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HandshakeCallback
:
couldn
'
t
rebuild
verified
certificate
info
"
)
)
;
}
nsCOMPtr
<
nsIX509Cert
>
x509Cert
(
new
nsNSSCertificate
(
cert
.
get
(
)
)
)
;
if
(
rv
=
=
Success
&
&
evStatus
=
=
EVStatus
:
:
EV
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HandshakeCallback
using
NEW
cert
(
is
EV
)
"
)
)
;
infoObject
-
>
SetServerCert
(
x509Cert
EVStatus
:
:
EV
)
;
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HandshakeCallback
using
NEW
cert
(
is
not
EV
)
"
)
)
;
infoObject
-
>
SetServerCert
(
x509Cert
EVStatus
:
:
NotEV
)
;
}
if
(
rv
=
=
Success
)
{
uint16_t
status
=
TransportSecurityInfo
:
:
ConvertCertificateTransparencyInfoToStatus
(
certificateTransparencyInfo
)
;
infoObject
-
>
SetCertificateTransparencyStatus
(
status
)
;
infoObject
-
>
SetSucceededCertChain
(
std
:
:
move
(
builtChainCertBytes
)
)
;
infoObject
-
>
SetIsBuiltCertChainRootBuiltInRoot
(
isBuiltCertChainRootBuiltInRoot
)
;
}
}
void
HandshakeCallback
(
PRFileDesc
*
fd
void
*
client_data
)
{
SECStatus
rv
;
nsNSSSocketInfo
*
infoObject
=
(
nsNSSSocketInfo
*
)
fd
-
>
higher
-
>
secret
;
PreliminaryHandshakeDone
(
fd
)
;
nsSSLIOLayerHelpers
&
ioLayerHelpers
=
infoObject
-
>
SharedState
(
)
.
IOLayerHelpers
(
)
;
SSLVersionRange
versions
(
infoObject
-
>
GetTLSVersionRange
(
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
%
p
]
HandshakeCallback
:
succeeded
using
TLS
version
range
"
"
(
0x
%
04x
0x
%
04x
)
\
n
"
fd
static_cast
<
unsigned
int
>
(
versions
.
min
)
static_cast
<
unsigned
int
>
(
versions
.
max
)
)
)
;
ioLayerHelpers
.
rememberTolerantAtVersion
(
infoObject
-
>
GetHostName
(
)
infoObject
-
>
GetPort
(
)
versions
.
max
)
;
SSLChannelInfo
channelInfo
;
rv
=
SSL_GetChannelInfo
(
fd
&
channelInfo
sizeof
(
channelInfo
)
)
;
MOZ_ASSERT
(
rv
=
=
SECSuccess
)
;
if
(
rv
=
=
SECSuccess
)
{
unsigned
int
versionEnum
=
channelInfo
.
protocolVersion
&
0xFF
;
MOZ_ASSERT
(
versionEnum
>
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_HANDSHAKE_VERSION
versionEnum
)
;
AccumulateCipherSuite
(
infoObject
-
>
IsFullHandshake
(
)
?
Telemetry
:
:
SSL_CIPHER_SUITE_FULL
:
Telemetry
:
:
SSL_CIPHER_SUITE_RESUMED
channelInfo
)
;
SSLCipherSuiteInfo
cipherInfo
;
rv
=
SSL_GetCipherSuiteInfo
(
channelInfo
.
cipherSuite
&
cipherInfo
sizeof
cipherInfo
)
;
MOZ_ASSERT
(
rv
=
=
SECSuccess
)
;
if
(
rv
=
=
SECSuccess
)
{
Telemetry
:
:
Accumulate
(
infoObject
-
>
IsFullHandshake
(
)
?
Telemetry
:
:
SSL_KEY_EXCHANGE_ALGORITHM_FULL
:
Telemetry
:
:
SSL_KEY_EXCHANGE_ALGORITHM_RESUMED
channelInfo
.
keaType
)
;
MOZ_ASSERT
(
infoObject
-
>
GetKEAUsed
(
)
=
=
channelInfo
.
keaType
)
;
if
(
infoObject
-
>
IsFullHandshake
(
)
)
{
switch
(
channelInfo
.
keaType
)
{
case
ssl_kea_rsa
:
AccumulateNonECCKeySize
(
Telemetry
:
:
SSL_KEA_RSA_KEY_SIZE_FULL
channelInfo
.
keaKeyBits
)
;
break
;
case
ssl_kea_dh
:
AccumulateNonECCKeySize
(
Telemetry
:
:
SSL_KEA_DHE_KEY_SIZE_FULL
channelInfo
.
keaKeyBits
)
;
break
;
case
ssl_kea_ecdh
:
AccumulateECCCurve
(
Telemetry
:
:
SSL_KEA_ECDHE_CURVE_FULL
channelInfo
.
keaKeyBits
)
;
break
;
default
:
MOZ_CRASH
(
"
impossible
KEA
"
)
;
break
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_AUTH_ALGORITHM_FULL
channelInfo
.
authType
)
;
if
(
channelInfo
.
keaType
!
=
ssl_kea_rsa
)
{
switch
(
channelInfo
.
authType
)
{
case
ssl_auth_rsa
:
case
ssl_auth_rsa_sign
:
AccumulateNonECCKeySize
(
Telemetry
:
:
SSL_AUTH_RSA_KEY_SIZE_FULL
channelInfo
.
authKeyBits
)
;
break
;
case
ssl_auth_ecdsa
:
AccumulateECCCurve
(
Telemetry
:
:
SSL_AUTH_ECDSA_CURVE_FULL
channelInfo
.
authKeyBits
)
;
break
;
default
:
MOZ_CRASH
(
"
impossible
auth
algorithm
"
)
;
break
;
}
}
}
Telemetry
:
:
Accumulate
(
infoObject
-
>
IsFullHandshake
(
)
?
Telemetry
:
:
SSL_SYMMETRIC_CIPHER_FULL
:
Telemetry
:
:
SSL_SYMMETRIC_CIPHER_RESUMED
cipherInfo
.
symCipher
)
;
}
}
PRBool
siteSupportsSafeRenego
;
if
(
channelInfo
.
protocolVersion
!
=
SSL_LIBRARY_VERSION_TLS_1_3
)
{
rv
=
SSL_HandshakeNegotiatedExtension
(
fd
ssl_renegotiation_info_xtn
&
siteSupportsSafeRenego
)
;
MOZ_ASSERT
(
rv
=
=
SECSuccess
)
;
if
(
rv
!
=
SECSuccess
)
{
siteSupportsSafeRenego
=
false
;
}
}
else
{
siteSupportsSafeRenego
=
true
;
}
bool
renegotiationUnsafe
=
!
siteSupportsSafeRenego
&
&
ioLayerHelpers
.
treatUnsafeNegotiationAsBroken
(
)
;
bool
deprecatedTlsVer
=
(
channelInfo
.
protocolVersion
<
SSL_LIBRARY_VERSION_TLS_1_2
)
;
RememberCertErrorsTable
:
:
GetInstance
(
)
.
LookupCertErrorBits
(
infoObject
)
;
uint32_t
state
;
if
(
renegotiationUnsafe
|
|
deprecatedTlsVer
)
{
state
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
}
else
{
state
=
nsIWebProgressListener
:
:
STATE_IS_SECURE
;
SSLVersionRange
defVersion
;
rv
=
SSL_VersionRangeGetDefault
(
ssl_variant_stream
&
defVersion
)
;
if
(
rv
=
=
SECSuccess
&
&
versions
.
max
>
=
defVersion
.
max
)
{
ioLayerHelpers
.
removeInsecureFallbackSite
(
infoObject
-
>
GetHostName
(
)
infoObject
-
>
GetPort
(
)
)
;
}
}
if
(
infoObject
-
>
HasServerCert
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
HandshakeCallback
KEEPING
existing
cert
\
n
"
)
)
;
}
else
{
if
(
StaticPrefs
:
:
network_ssl_tokens_cache_enabled
(
)
)
{
infoObject
-
>
RebuildCertificateInfoFromSSLTokenCache
(
)
;
}
else
{
RebuildVerifiedCertificateInformation
(
fd
infoObject
)
;
}
}
nsITransportSecurityInfo
:
:
OverridableErrorCategory
overridableErrorCategory
;
Unused
<
<
infoObject
-
>
GetOverridableErrorCategory
(
&
overridableErrorCategory
)
;
if
(
overridableErrorCategory
!
=
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_UNSET
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_CERT_USER_OVERRIDDEN
;
}
infoObject
-
>
SetSecurityState
(
state
)
;
if
(
!
siteSupportsSafeRenego
)
{
NS_ConvertASCIItoUTF16
msg
(
infoObject
-
>
GetHostName
(
)
)
;
msg
.
AppendLiteral
(
"
:
server
does
not
support
RFC
5746
see
CVE
-
2009
-
3555
"
)
;
nsContentUtils
:
:
LogSimpleConsoleError
(
msg
"
SSL
"
_ns
!
!
infoObject
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
true
)
;
}
infoObject
-
>
NoteTimeUntilReady
(
)
;
infoObject
-
>
SetHandshakeCompleted
(
)
;
}
