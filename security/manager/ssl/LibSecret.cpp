#
include
"
LibSecret
.
h
"
#
include
<
gmodule
.
h
>
#
include
"
mozilla
/
Base64
.
h
"
using
namespace
mozilla
;
LazyLogModule
gLibSecretLog
(
"
libsecret
"
)
;
LibSecret
:
:
LibSecret
(
)
{
}
LibSecret
:
:
~
LibSecret
(
)
{
}
static
const
SecretSchema
kSchema
=
{
"
mozilla
.
firefox
"
SECRET_SCHEMA_NONE
{
{
"
string
"
SECRET_SCHEMA_ATTRIBUTE_STRING
}
{
"
NULL
"
SECRET_SCHEMA_ATTRIBUTE_STRING
}
}
}
;
nsresult
GetScopedServices
(
ScopedSecretService
&
aSs
ScopedSecretCollection
&
aSc
)
{
GError
*
raw_error
=
nullptr
;
aSs
=
ScopedSecretService
(
secret_service_get_sync
(
static_cast
<
SecretServiceFlags
>
(
SECRET_SERVICE_OPEN_SESSION
)
nullptr
&
raw_error
)
)
;
ScopedGError
error
(
raw_error
)
;
if
(
error
|
|
!
aSs
)
{
MOZ_LOG
(
gLibSecretLog
LogLevel
:
:
Debug
(
"
Couldn
'
t
get
a
secret
service
"
)
)
;
return
NS_ERROR_FAILURE
;
}
aSc
=
ScopedSecretCollection
(
secret_collection_for_alias_sync
(
aSs
.
get
(
)
"
default
"
static_cast
<
SecretCollectionFlags
>
(
0
)
nullptr
&
raw_error
)
)
;
error
.
reset
(
raw_error
)
;
if
(
!
aSc
)
{
MOZ_LOG
(
gLibSecretLog
LogLevel
:
:
Debug
(
"
Couldn
'
t
get
a
secret
collection
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
LibSecret
:
:
Lock
(
)
{
ScopedSecretService
ss
;
ScopedSecretCollection
sc
;
if
(
NS_FAILED
(
GetScopedServices
(
ss
sc
)
)
)
{
return
NS_ERROR_FAILURE
;
}
GError
*
raw_error
=
nullptr
;
GList
*
collections
=
nullptr
;
ScopedGList
collectionList
(
g_list_append
(
collections
sc
.
get
(
)
)
)
;
int
numLocked
=
secret_service_lock_sync
(
ss
.
get
(
)
collectionList
.
get
(
)
nullptr
nullptr
&
raw_error
)
;
ScopedGError
error
(
raw_error
)
;
if
(
numLocked
!
=
1
)
{
MOZ_LOG
(
gLibSecretLog
LogLevel
:
:
Debug
(
"
Couldn
'
t
lock
secret
collection
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
LibSecret
:
:
Unlock
(
)
{
ScopedSecretService
ss
;
ScopedSecretCollection
sc
;
if
(
NS_FAILED
(
GetScopedServices
(
ss
sc
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
LibSecret
:
:
StoreSecret
(
const
nsACString
&
aSecret
const
nsACString
&
aLabel
)
{
GError
*
raw_error
=
nullptr
;
bool
stored
=
secret_password_store_sync
(
&
kSchema
SECRET_COLLECTION_DEFAULT
PromiseFlatCString
(
aLabel
)
.
get
(
)
PromiseFlatCString
(
aSecret
)
.
get
(
)
nullptr
&
raw_error
"
string
"
PromiseFlatCString
(
aLabel
)
.
get
(
)
nullptr
)
;
ScopedGError
error
(
raw_error
)
;
if
(
raw_error
)
{
MOZ_LOG
(
gLibSecretLog
LogLevel
:
:
Debug
(
"
Error
storing
secret
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
stored
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
LibSecret
:
:
DeleteSecret
(
const
nsACString
&
aLabel
)
{
GError
*
raw_error
=
nullptr
;
bool
r
=
secret_password_clear_sync
(
&
kSchema
nullptr
&
raw_error
"
string
"
PromiseFlatCString
(
aLabel
)
.
get
(
)
nullptr
)
;
ScopedGError
error
(
raw_error
)
;
if
(
raw_error
)
{
MOZ_LOG
(
gLibSecretLog
LogLevel
:
:
Debug
(
"
Error
deleting
secret
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
r
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
LibSecret
:
:
RetrieveSecret
(
const
nsACString
&
aLabel
nsACString
&
aSecret
)
{
GError
*
raw_error
=
nullptr
;
aSecret
.
Truncate
(
)
;
ScopedPassword
s
(
secret_password_lookup_sync
(
&
kSchema
nullptr
&
raw_error
"
string
"
PromiseFlatCString
(
aLabel
)
.
get
(
)
nullptr
)
)
;
ScopedGError
error
(
raw_error
)
;
if
(
raw_error
|
|
!
s
)
{
MOZ_LOG
(
gLibSecretLog
LogLevel
:
:
Debug
(
"
Error
retrieving
secret
or
didn
'
t
find
it
"
)
)
;
return
NS_ERROR_FAILURE
;
}
aSecret
.
Assign
(
s
.
get
(
)
strlen
(
s
.
get
(
)
)
)
;
return
NS_OK
;
}
bool
LibSecret
:
:
SecretAvailable
(
const
nsACString
&
aLabel
)
{
nsAutoCString
secret
;
nsresult
rv
=
RetrieveSecret
(
aLabel
secret
)
;
if
(
NS_FAILED
(
rv
)
|
|
secret
.
Length
(
)
=
=
0
)
{
return
false
;
}
return
true
;
}
nsresult
LibSecret
:
:
EncryptDecrypt
(
const
nsACString
&
aLabel
const
std
:
:
vector
<
uint8_t
>
&
inBytes
std
:
:
vector
<
uint8_t
>
&
outBytes
bool
encrypt
)
{
nsAutoCString
secret
;
nsresult
rv
=
RetrieveSecret
(
aLabel
secret
)
;
if
(
NS_FAILED
(
rv
)
|
|
secret
.
Length
(
)
=
=
0
)
{
return
NS_ERROR_FAILURE
;
}
uint8_t
*
p
=
BitwiseCast
<
uint8_t
*
const
char
*
>
(
secret
.
BeginReading
(
)
)
;
std
:
:
vector
<
uint8_t
>
buf
(
p
p
+
secret
.
Length
(
)
)
;
UniquePK11SymKey
symKey
;
rv
=
BuildAesGcmKey
(
buf
symKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
return
DoCipher
(
symKey
inBytes
outBytes
encrypt
)
;
}
