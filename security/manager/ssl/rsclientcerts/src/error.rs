use
std
:
:
fmt
;
#
[
macro_export
]
macro_rules
!
error_here
{
(
error_type
:
expr
)
=
>
{
Error
:
:
new
(
error_type
file
!
(
)
line
!
(
)
None
)
}
;
(
error_type
:
expr
info
:
expr
)
=
>
{
Error
:
:
new
(
error_type
file
!
(
)
line
!
(
)
Some
(
info
)
)
}
;
}
pub
struct
Error
{
typ
:
ErrorType
file
:
&
'
static
str
line
:
u32
info
:
Option
<
String
>
}
impl
Error
{
pub
fn
new
(
typ
:
ErrorType
file
:
&
'
static
str
line
:
u32
info
:
Option
<
String
>
)
-
>
Error
{
Error
{
typ
file
line
info
}
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
let
Some
(
info
)
=
&
self
.
info
{
write
!
(
f
"
{
}
at
{
}
:
{
}
(
{
}
)
"
self
.
typ
self
.
file
self
.
line
info
)
}
else
{
write
!
(
f
"
{
}
at
{
}
:
{
}
"
self
.
typ
self
.
file
self
.
line
)
}
}
}
impl
Clone
for
Error
{
fn
clone
(
&
self
)
-
>
Self
{
Error
{
typ
:
self
.
typ
file
:
self
.
file
line
:
self
.
line
info
:
self
.
info
.
as_ref
(
)
.
cloned
(
)
}
}
fn
clone_from
(
&
mut
self
source
:
&
Self
)
{
self
.
typ
=
source
.
typ
;
self
.
file
=
source
.
file
;
self
.
line
=
source
.
line
;
self
.
info
=
source
.
info
.
as_ref
(
)
.
cloned
(
)
;
}
}
#
[
derive
(
Copy
Clone
)
]
pub
enum
ErrorType
{
ExternalError
ExtraInput
InvalidArgument
InvalidInput
LibraryFailure
TruncatedInput
UnsupportedInput
ValueTooLarge
}
impl
fmt
:
:
Display
for
ErrorType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
error_type_str
=
match
self
{
ErrorType
:
:
ExternalError
=
>
"
ExternalError
"
ErrorType
:
:
ExtraInput
=
>
"
ExtraInput
"
ErrorType
:
:
InvalidArgument
=
>
"
InvalidArgument
"
ErrorType
:
:
InvalidInput
=
>
"
InvalidInput
"
ErrorType
:
:
LibraryFailure
=
>
"
LibraryFailure
"
ErrorType
:
:
TruncatedInput
=
>
"
TruncatedInput
"
ErrorType
:
:
UnsupportedInput
=
>
"
UnsupportedInput
"
ErrorType
:
:
ValueTooLarge
=
>
"
ValueTooLarge
"
}
;
write
!
(
f
"
{
}
"
error_type_str
)
}
}
