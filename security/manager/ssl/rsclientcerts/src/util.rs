use
byteorder
:
:
{
BigEndian
NativeEndian
ReadBytesExt
WriteBytesExt
}
;
use
digest
:
:
{
Digest
DynDigest
}
;
use
pkcs11_bindings
:
:
*
;
use
rand
:
:
rngs
:
:
OsRng
;
use
rand
:
:
RngCore
;
use
std
:
:
convert
:
:
TryInto
;
use
std
:
:
iter
:
:
zip
;
use
crate
:
:
error
:
:
{
Error
ErrorType
}
;
use
crate
:
:
error_here
;
use
crate
:
:
manager
:
:
CryptokiObject
;
#
[
macro_export
]
macro_rules
!
unsafe_packed_field_access
{
(
e
:
expr
)
=
>
{
{
#
[
allow
(
unused_unsafe
)
]
let
tmp
=
unsafe
{
e
}
;
tmp
}
}
;
}
pub
const
ENCODED_OID_BYTES_SECP256R1
:
&
[
u8
]
=
&
[
0x06
0x08
0x2a
0x86
0x48
0xce
0x3d
0x03
0x01
0x07
]
;
pub
const
ENCODED_OID_BYTES_SECP384R1
:
&
[
u8
]
=
&
[
0x06
0x05
0x2b
0x81
0x04
0x00
0x22
]
;
pub
const
ENCODED_OID_BYTES_SECP521R1
:
&
[
u8
]
=
&
[
0x06
0x05
0x2b
0x81
0x04
0x00
0x23
]
;
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
)
)
]
pub
const
OID_BYTES_SHA_256
:
&
[
u8
]
=
&
[
0x60
0x86
0x48
0x01
0x65
0x03
0x04
0x02
0x01
]
;
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
)
)
]
pub
const
OID_BYTES_SHA_384
:
&
[
u8
]
=
&
[
0x60
0x86
0x48
0x01
0x65
0x03
0x04
0x02
0x02
]
;
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
)
)
]
pub
const
OID_BYTES_SHA_512
:
&
[
u8
]
=
&
[
0x60
0x86
0x48
0x01
0x65
0x03
0x04
0x02
0x03
]
;
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
)
)
]
pub
const
OID_BYTES_SHA_1
:
&
[
u8
]
=
&
[
0x2b
0x0e
0x03
0x02
0x1a
]
;
pub
fn
serialize_uint
<
T
:
TryInto
<
u64
>
>
(
value
:
T
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
let
value_size
=
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
;
let
mut
value_buf
=
Vec
:
:
with_capacity
(
value_size
)
;
let
value_as_u64
=
value
.
try_into
(
)
.
map_err
(
|
_
|
error_here
!
(
ErrorType
:
:
ValueTooLarge
)
)
?
;
value_buf
.
write_uint
:
:
<
NativeEndian
>
(
value_as_u64
value_size
)
.
map_err
(
|
_
|
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
?
;
Ok
(
value_buf
)
}
pub
fn
read_rsa_modulus
(
public_key
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
let
mut
sequence
=
Sequence
:
:
new
(
public_key
)
?
;
let
modulus_value
=
sequence
.
read_unsigned_integer
(
)
?
;
let
_exponent
=
sequence
.
read_unsigned_integer
(
)
?
;
if
!
sequence
.
at_end
(
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
ExtraInput
)
)
;
}
Ok
(
modulus_value
.
to_vec
(
)
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
pub
fn
read_spki_algorithm_parameters
(
spki
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
let
mut
public_key_info
=
Sequence
:
:
new
(
spki
)
?
;
let
mut
algorithm_identifier
=
public_key_info
.
read_sequence
(
)
?
;
let
_algorithm
=
algorithm_identifier
.
read_oid
(
)
?
;
Ok
(
algorithm_identifier
.
read_rest
(
)
.
to_vec
(
)
)
}
pub
fn
read_digest_info
(
digest_info
:
&
[
u8
]
)
-
>
Result
<
(
&
[
u8
]
&
[
u8
]
)
Error
>
{
let
mut
sequence
=
Sequence
:
:
new
(
digest_info
)
?
;
let
mut
algorithm
=
sequence
.
read_sequence
(
)
?
;
let
oid
=
algorithm
.
read_oid
(
)
?
;
algorithm
.
read_null
(
)
?
;
if
!
algorithm
.
at_end
(
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
ExtraInput
)
)
;
}
let
digest
=
sequence
.
read_octet_string
(
)
?
;
if
!
sequence
.
at_end
(
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
ExtraInput
)
)
;
}
Ok
(
(
oid
digest
)
)
}
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
target_os
=
"
android
"
)
)
]
pub
fn
der_ec_sig_to_raw
(
encoded
:
&
[
u8
]
coordinate_width
:
usize
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
let
(
r
s
)
=
read_ec_sig_point
(
encoded
)
?
;
if
r
.
len
(
)
>
coordinate_width
|
|
s
.
len
(
)
>
coordinate_width
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidInput
)
)
;
}
let
mut
raw_signature
=
Vec
:
:
with_capacity
(
2
*
coordinate_width
)
;
raw_signature
.
resize
(
coordinate_width
-
r
.
len
(
)
0
)
;
raw_signature
.
extend_from_slice
(
r
)
;
raw_signature
.
resize
(
(
2
*
coordinate_width
)
-
s
.
len
(
)
0
)
;
raw_signature
.
extend_from_slice
(
s
)
;
Ok
(
raw_signature
)
}
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
target_os
=
"
android
"
)
)
]
fn
read_ec_sig_point
(
signature
:
&
[
u8
]
)
-
>
Result
<
(
&
[
u8
]
&
[
u8
]
)
Error
>
{
let
mut
sequence
=
Sequence
:
:
new
(
signature
)
?
;
let
r
=
sequence
.
read_unsigned_integer
(
)
?
;
let
s
=
sequence
.
read_unsigned_integer
(
)
?
;
if
!
sequence
.
at_end
(
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
ExtraInput
)
)
;
}
Ok
(
(
r
s
)
)
}
#
[
allow
(
clippy
:
:
type_complexity
)
]
pub
fn
read_encoded_certificate_identifiers
(
certificate
:
&
[
u8
]
)
-
>
Result
<
(
Vec
<
u8
>
Vec
<
u8
>
Vec
<
u8
>
)
Error
>
{
let
mut
certificate_sequence
=
Sequence
:
:
new
(
certificate
)
?
;
let
mut
tbs_certificate_sequence
=
certificate_sequence
.
read_sequence
(
)
?
;
let
_version
=
tbs_certificate_sequence
.
read_optional_tagged_value
(
0
)
?
;
let
serial_number
=
tbs_certificate_sequence
.
read_encoded_sequence_component
(
INTEGER
)
?
;
let
_signature
=
tbs_certificate_sequence
.
read_sequence
(
)
?
;
let
issuer
=
tbs_certificate_sequence
.
read_encoded_sequence_component
(
SEQUENCE
|
CONSTRUCTED
)
?
;
let
_validity
=
tbs_certificate_sequence
.
read_sequence
(
)
?
;
let
subject
=
tbs_certificate_sequence
.
read_encoded_sequence_component
(
SEQUENCE
|
CONSTRUCTED
)
?
;
Ok
(
(
serial_number
issuer
subject
)
)
}
macro_rules
!
try_read_bytes
{
(
data
:
ident
len
:
expr
)
=
>
{
{
if
data
.
len
(
)
<
len
{
return
Err
(
error_here
!
(
ErrorType
:
:
TruncatedInput
)
)
;
}
data
.
split_at
(
len
)
}
}
;
}
const
INTEGER
:
u8
=
0x02
;
const
OCTET_STRING
:
u8
=
0x04
;
const
NULL
:
u8
=
0x05
;
const
OBJECT_IDENTIFIER
:
u8
=
0x06
;
const
SEQUENCE
:
u8
=
0x10
;
const
CONSTRUCTED
:
u8
=
0x20
;
const
CONTEXT_SPECIFIC
:
u8
=
0x80
;
struct
Sequence
<
'
a
>
{
contents
:
Der
<
'
a
>
}
impl
<
'
a
>
Sequence
<
'
a
>
{
fn
new
(
input
:
&
'
a
[
u8
]
)
-
>
Result
<
Sequence
<
'
a
>
Error
>
{
let
mut
der
=
Der
:
:
new
(
input
)
;
let
(
_
_
sequence_bytes
)
=
der
.
read_tlv
(
SEQUENCE
|
CONSTRUCTED
)
?
;
if
!
der
.
at_end
(
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
ExtraInput
)
)
;
}
Ok
(
Sequence
{
contents
:
Der
:
:
new
(
sequence_bytes
)
}
)
}
fn
read_unsigned_integer
(
&
mut
self
)
-
>
Result
<
&
'
a
[
u8
]
Error
>
{
let
(
_
_
bytes
)
=
self
.
contents
.
read_tlv
(
INTEGER
)
?
;
if
bytes
.
is_empty
(
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidInput
)
)
;
}
if
bytes
[
0
]
=
=
0
&
&
bytes
.
len
(
)
>
1
{
let
(
_
integer
)
=
bytes
.
split_at
(
1
)
;
Ok
(
integer
)
}
else
{
Ok
(
bytes
)
}
}
fn
read_octet_string
(
&
mut
self
)
-
>
Result
<
&
'
a
[
u8
]
Error
>
{
let
(
_
_
bytes
)
=
self
.
contents
.
read_tlv
(
OCTET_STRING
)
?
;
Ok
(
bytes
)
}
fn
read_oid
(
&
mut
self
)
-
>
Result
<
&
'
a
[
u8
]
Error
>
{
let
(
_
_
bytes
)
=
self
.
contents
.
read_tlv
(
OBJECT_IDENTIFIER
)
?
;
Ok
(
bytes
)
}
fn
read_null
(
&
mut
self
)
-
>
Result
<
(
)
Error
>
{
let
(
_
_
bytes
)
=
self
.
contents
.
read_tlv
(
NULL
)
?
;
if
bytes
.
is_empty
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
error_here
!
(
ErrorType
:
:
InvalidInput
)
)
}
}
fn
read_sequence
(
&
mut
self
)
-
>
Result
<
Sequence
<
'
a
>
Error
>
{
let
(
_
_
sequence_bytes
)
=
self
.
contents
.
read_tlv
(
SEQUENCE
|
CONSTRUCTED
)
?
;
Ok
(
Sequence
{
contents
:
Der
:
:
new
(
sequence_bytes
)
}
)
}
fn
read_optional_tagged_value
(
&
mut
self
tag
:
u8
)
-
>
Result
<
Option
<
&
'
a
[
u8
]
>
Error
>
{
let
expected
=
CONTEXT_SPECIFIC
|
CONSTRUCTED
|
tag
;
if
self
.
contents
.
peek
(
expected
)
{
let
(
_
_
tagged_value_bytes
)
=
self
.
contents
.
read_tlv
(
expected
)
?
;
Ok
(
Some
(
tagged_value_bytes
)
)
}
else
{
Ok
(
None
)
}
}
fn
read_encoded_sequence_component
(
&
mut
self
tag
:
u8
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
let
(
tag
length
value
)
=
self
.
contents
.
read_tlv
(
tag
)
?
;
let
mut
encoded_component_bytes
=
length
;
encoded_component_bytes
.
insert
(
0
tag
)
;
encoded_component_bytes
.
extend_from_slice
(
value
)
;
Ok
(
encoded_component_bytes
)
}
fn
at_end
(
&
self
)
-
>
bool
{
self
.
contents
.
at_end
(
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
read_rest
(
&
mut
self
)
-
>
&
[
u8
]
{
self
.
contents
.
read_rest
(
)
}
}
struct
Der
<
'
a
>
{
contents
:
&
'
a
[
u8
]
}
impl
<
'
a
>
Der
<
'
a
>
{
fn
new
(
contents
:
&
'
a
[
u8
]
)
-
>
Der
<
'
a
>
{
Der
{
contents
}
}
fn
read_tlv
(
&
mut
self
tag
:
u8
)
-
>
Result
<
(
u8
Vec
<
u8
>
&
'
a
[
u8
]
)
Error
>
{
let
contents
=
self
.
contents
;
let
(
tag_read
rest
)
=
try_read_bytes
!
(
contents
1
)
;
if
tag_read
[
0
]
!
=
tag
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidInput
)
)
;
}
let
mut
accumulated_length_bytes
=
Vec
:
:
with_capacity
(
4
)
;
let
(
length1
rest
)
=
try_read_bytes
!
(
rest
1
)
;
accumulated_length_bytes
.
extend_from_slice
(
length1
)
;
let
(
length
to_read_from
)
=
if
length1
[
0
]
<
0x80
{
(
length1
[
0
]
as
usize
rest
)
}
else
if
length1
[
0
]
=
=
0x81
{
let
(
length
rest
)
=
try_read_bytes
!
(
rest
1
)
;
accumulated_length_bytes
.
extend_from_slice
(
length
)
;
if
length
[
0
]
<
0x80
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidInput
)
)
;
}
(
length
[
0
]
as
usize
rest
)
}
else
if
length1
[
0
]
=
=
0x82
{
let
(
mut
lengths
rest
)
=
try_read_bytes
!
(
rest
2
)
;
accumulated_length_bytes
.
extend_from_slice
(
lengths
)
;
let
length
=
lengths
.
read_u16
:
:
<
BigEndian
>
(
)
.
map_err
(
|
_
|
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
?
;
if
length
<
256
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidInput
)
)
;
}
(
length
as
usize
rest
)
}
else
{
return
Err
(
error_here
!
(
ErrorType
:
:
UnsupportedInput
)
)
;
}
;
let
(
contents
rest
)
=
try_read_bytes
!
(
to_read_from
length
)
;
self
.
contents
=
rest
;
Ok
(
(
tag
accumulated_length_bytes
contents
)
)
}
fn
at_end
(
&
self
)
-
>
bool
{
self
.
contents
.
is_empty
(
)
}
fn
peek
(
&
self
expected
:
u8
)
-
>
bool
{
Some
(
&
expected
)
=
=
self
.
contents
.
first
(
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
read_rest
(
&
mut
self
)
-
>
&
'
a
[
u8
]
{
let
contents
=
self
.
contents
;
self
.
contents
=
&
[
]
;
contents
}
}
fn
make_hasher
(
params
:
&
CK_RSA_PKCS_PSS_PARAMS
)
-
>
Result
<
Box
<
dyn
DynDigest
>
Error
>
{
match
params
.
hashAlg
{
CKM_SHA256
=
>
Ok
(
Box
:
:
new
(
sha2
:
:
Sha256
:
:
new
(
)
)
)
CKM_SHA384
=
>
Ok
(
Box
:
:
new
(
sha2
:
:
Sha384
:
:
new
(
)
)
)
CKM_SHA512
=
>
Ok
(
Box
:
:
new
(
sha2
:
:
Sha512
:
:
new
(
)
)
)
_
=
>
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
}
}
fn
mgf
(
mgf_seed
:
&
[
u8
]
mask_len
:
usize
h_len
:
usize
params
:
&
CK_RSA_PKCS_PSS_PARAMS
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
if
mask_len
>
1
<
<
30
{
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
;
}
let
mut
t
=
Vec
:
:
with_capacity
(
mask_len
)
;
for
counter
in
0
.
.
mask_len
.
div_ceil
(
h_len
)
{
let
c
=
u32
:
:
to_be_bytes
(
counter
.
try_into
(
)
.
unwrap
(
)
)
;
let
mut
hasher
=
make_hasher
(
params
)
?
;
hasher
.
update
(
mgf_seed
)
;
hasher
.
update
(
&
c
)
;
t
.
extend_from_slice
(
&
mut
hasher
.
finalize
(
)
)
;
}
t
.
truncate
(
mask_len
)
;
Ok
(
t
)
}
pub
fn
modulus_bit_length
(
modulus
:
&
[
u8
]
)
-
>
usize
{
let
mut
bit_length
=
modulus
.
len
(
)
*
8
;
for
byte
in
modulus
{
if
*
byte
!
=
0
{
let
leading_zeros
:
usize
=
byte
.
leading_zeros
(
)
.
try_into
(
)
.
unwrap
(
)
;
bit_length
-
=
leading_zeros
;
return
bit_length
;
}
bit_length
-
=
8
;
}
bit_length
}
pub
fn
emsa_pss_encode
(
m_hash
:
&
[
u8
]
em_bits
:
usize
params
:
&
CK_RSA_PKCS_PSS_PARAMS
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
let
em_len
=
em_bits
.
div_ceil
(
8
)
;
let
s_len
:
usize
=
params
.
sLen
.
try_into
(
)
.
map_err
(
|
_
|
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
?
;
if
em_len
<
m_hash
.
len
(
)
+
s_len
+
2
{
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
;
}
let
salt
=
{
let
mut
salt
=
vec
!
[
0u8
;
s_len
]
;
OsRng
.
fill_bytes
(
&
mut
salt
)
;
salt
}
;
let
mut
hasher
=
make_hasher
(
params
)
?
;
let
h_len
=
hasher
.
output_size
(
)
;
hasher
.
update
(
&
[
0
0
0
0
0
0
0
0
]
)
;
hasher
.
update
(
m_hash
)
;
hasher
.
update
(
&
salt
)
;
let
h
=
hasher
.
finalize
(
)
.
to_vec
(
)
;
let
mut
db_mask
=
mgf
(
&
h
em_len
-
h_len
-
1
h_len
params
)
?
;
let
salt_index
=
db_mask
.
len
(
)
-
s_len
;
db_mask
[
salt_index
-
1
]
^
=
1
;
for
(
db_mask_byte
salt_byte
)
in
zip
(
&
mut
db_mask
[
salt_index
.
.
]
&
salt
)
{
*
db_mask_byte
^
=
salt_byte
;
}
let
mut
masked_db
=
db_mask
;
let
bit_diff
:
u32
=
(
(
8
*
em_len
)
-
em_bits
)
.
try_into
(
)
.
unwrap
(
)
;
masked_db
[
0
]
&
=
0xffu8
.
checked_shr
(
bit_diff
)
.
unwrap
(
)
;
let
mut
em
=
masked_db
;
em
.
extend_from_slice
(
&
h
)
;
em
.
push
(
0xbc
)
;
Ok
(
em
)
}
pub
struct
CryptokiCert
{
class
:
Vec
<
u8
>
token
:
Vec
<
u8
>
id
:
Vec
<
u8
>
label
:
Vec
<
u8
>
value
:
Vec
<
u8
>
issuer
:
Vec
<
u8
>
serial_number
:
Vec
<
u8
>
subject
:
Vec
<
u8
>
}
impl
CryptokiCert
{
pub
fn
new
(
der
:
Vec
<
u8
>
label
:
Vec
<
u8
>
)
-
>
Result
<
CryptokiCert
Error
>
{
let
id
=
sha2
:
:
Sha256
:
:
digest
(
&
der
)
.
to_vec
(
)
;
let
(
serial_number
issuer
subject
)
=
read_encoded_certificate_identifiers
(
&
der
)
?
;
Ok
(
CryptokiCert
{
class
:
serialize_uint
(
CKO_CERTIFICATE
)
?
token
:
serialize_uint
(
CK_TRUE
)
?
id
label
value
:
der
issuer
serial_number
subject
}
)
}
}
impl
CryptokiObject
for
CryptokiCert
{
fn
matches
(
&
self
attrs
:
&
[
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
]
)
-
>
bool
{
for
(
attr_type
attr_value
)
in
attrs
{
let
comparison
=
match
*
attr_type
{
CKA_CLASS
=
>
&
self
.
class
CKA_TOKEN
=
>
&
self
.
token
CKA_LABEL
=
>
&
self
.
label
CKA_ID
=
>
&
self
.
id
CKA_VALUE
=
>
&
self
.
value
CKA_ISSUER
=
>
&
self
.
issuer
CKA_SERIAL_NUMBER
=
>
&
self
.
serial_number
CKA_SUBJECT
=
>
&
self
.
subject
_
=
>
return
false
}
;
if
attr_value
.
as_slice
(
)
!
=
comparison
{
return
false
;
}
}
true
}
fn
get_attribute
(
&
self
attribute
:
CK_ATTRIBUTE_TYPE
)
-
>
Option
<
&
[
u8
]
>
{
let
result
=
match
attribute
{
CKA_CLASS
=
>
&
self
.
class
CKA_TOKEN
=
>
&
self
.
token
CKA_LABEL
=
>
&
self
.
label
CKA_ID
=
>
&
self
.
id
CKA_VALUE
=
>
&
self
.
value
CKA_ISSUER
=
>
&
self
.
issuer
CKA_SERIAL_NUMBER
=
>
&
self
.
serial_number
CKA_SUBJECT
=
>
&
self
.
subject
_
=
>
return
None
}
;
Some
(
result
)
}
}
#
[
allow
(
clippy
:
:
upper_case_acronyms
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
KeyType
{
EC
(
usize
)
RSA
}
pub
struct
CryptokiKey
{
class
:
Vec
<
u8
>
token
:
Vec
<
u8
>
id
:
Vec
<
u8
>
private
:
Vec
<
u8
>
key_type_attribute
:
Vec
<
u8
>
modulus
:
Option
<
Vec
<
u8
>
>
ec_params
:
Option
<
Vec
<
u8
>
>
key_type
:
KeyType
}
impl
CryptokiKey
{
pub
fn
new
(
modulus
:
Option
<
Vec
<
u8
>
>
ec_params
:
Option
<
Vec
<
u8
>
>
cert
:
&
[
u8
]
)
-
>
Result
<
CryptokiKey
Error
>
{
let
(
key_type
key_type_attribute
)
=
if
modulus
.
is_some
(
)
{
(
KeyType
:
:
RSA
CKK_RSA
)
}
else
if
let
Some
(
ec_params
)
=
ec_params
.
as_ref
(
)
{
let
coordinate_width
=
match
ec_params
.
as_slice
(
)
{
ENCODED_OID_BYTES_SECP256R1
=
>
32
ENCODED_OID_BYTES_SECP384R1
=
>
48
ENCODED_OID_BYTES_SECP521R1
=
>
66
_
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
UnsupportedInput
)
)
}
;
(
KeyType
:
:
EC
(
coordinate_width
)
CKK_EC
)
}
else
{
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
;
}
;
let
id
=
sha2
:
:
Sha256
:
:
digest
(
cert
)
.
to_vec
(
)
;
Ok
(
CryptokiKey
{
class
:
serialize_uint
(
CKO_PRIVATE_KEY
)
?
token
:
serialize_uint
(
CK_TRUE
)
?
id
private
:
serialize_uint
(
CK_TRUE
)
?
key_type_attribute
:
serialize_uint
(
key_type_attribute
)
?
modulus
ec_params
key_type
}
)
}
pub
fn
modulus
(
&
self
)
-
>
&
Option
<
Vec
<
u8
>
>
{
&
self
.
modulus
}
pub
fn
ec_params
(
&
self
)
-
>
&
Option
<
Vec
<
u8
>
>
{
&
self
.
ec_params
}
pub
fn
key_type
(
&
self
)
-
>
KeyType
{
self
.
key_type
}
}
impl
CryptokiObject
for
CryptokiKey
{
fn
matches
(
&
self
attrs
:
&
[
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
]
)
-
>
bool
{
for
(
attr_type
attr_value
)
in
attrs
{
let
comparison
=
match
*
attr_type
{
CKA_CLASS
=
>
&
self
.
class
CKA_TOKEN
=
>
&
self
.
token
CKA_ID
=
>
&
self
.
id
CKA_PRIVATE
=
>
&
self
.
private
CKA_KEY_TYPE
=
>
&
self
.
key_type_attribute
CKA_MODULUS
=
>
{
if
let
Some
(
modulus
)
=
&
self
.
modulus
{
modulus
}
else
{
return
false
;
}
}
CKA_EC_PARAMS
=
>
{
if
let
Some
(
ec_params
)
=
&
self
.
ec_params
{
ec_params
}
else
{
return
false
;
}
}
_
=
>
return
false
}
;
if
attr_value
.
as_slice
(
)
!
=
comparison
{
return
false
;
}
}
true
}
fn
get_attribute
(
&
self
attribute
:
CK_ATTRIBUTE_TYPE
)
-
>
Option
<
&
[
u8
]
>
{
match
attribute
{
CKA_CLASS
=
>
Some
(
&
self
.
class
)
CKA_TOKEN
=
>
Some
(
&
self
.
token
)
CKA_ID
=
>
Some
(
&
self
.
id
)
CKA_PRIVATE
=
>
Some
(
&
self
.
private
)
CKA_KEY_TYPE
=
>
Some
(
&
self
.
key_type_attribute
)
CKA_MODULUS
=
>
match
&
self
.
modulus
{
Some
(
modulus
)
=
>
Some
(
modulus
.
as_slice
(
)
)
None
=
>
None
}
CKA_EC_PARAMS
=
>
match
&
self
.
ec_params
{
Some
(
ec_params
)
=
>
Some
(
ec_params
.
as_slice
(
)
)
None
=
>
None
}
_
=
>
None
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
der_test_empty_input
(
)
{
let
input
=
Vec
:
:
new
(
)
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
INTEGER
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_no_length
(
)
{
let
input
=
vec
!
[
INTEGER
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
INTEGER
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_empty_sequence
(
)
{
let
input
=
vec
!
[
SEQUENCE
0
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
let
read_result
=
der
.
read_tlv
(
SEQUENCE
)
;
assert
!
(
read_result
.
is_ok
(
)
)
;
let
(
tag
length
sequence_bytes
)
=
read_result
.
unwrap
(
)
;
assert_eq
!
(
tag
SEQUENCE
)
;
assert_eq
!
(
length
vec
!
[
0
]
)
;
assert_eq
!
(
sequence_bytes
.
len
(
)
0
)
;
assert
!
(
der
.
at_end
(
)
)
;
}
#
[
test
]
fn
der_test_not_at_end
(
)
{
let
input
=
vec
!
[
SEQUENCE
0
1
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
let
read_result
=
der
.
read_tlv
(
SEQUENCE
)
;
assert
!
(
read_result
.
is_ok
(
)
)
;
let
(
tag
length
sequence_bytes
)
=
read_result
.
unwrap
(
)
;
assert_eq
!
(
tag
SEQUENCE
)
;
assert_eq
!
(
length
vec
!
[
0
]
)
;
assert_eq
!
(
sequence_bytes
.
len
(
)
0
)
;
assert
!
(
!
der
.
at_end
(
)
)
;
}
#
[
test
]
fn
der_test_wrong_tag
(
)
{
let
input
=
vec
!
[
SEQUENCE
0
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
INTEGER
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_truncated_two_byte_length
(
)
{
let
input
=
vec
!
[
SEQUENCE
0x81
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
SEQUENCE
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_truncated_three_byte_length
(
)
{
let
input
=
vec
!
[
SEQUENCE
0x82
1
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
SEQUENCE
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_truncated_data
(
)
{
let
input
=
vec
!
[
SEQUENCE
20
1
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
SEQUENCE
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_sequence
(
)
{
let
input
=
vec
!
[
SEQUENCE
20
1
1
2
2
3
3
4
4
5
5
6
6
7
7
8
8
9
9
0
0
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
let
result
=
der
.
read_tlv
(
SEQUENCE
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
(
tag
length
value
)
=
result
.
unwrap
(
)
;
assert_eq
!
(
tag
SEQUENCE
)
;
assert_eq
!
(
length
vec
!
[
20
]
)
;
assert_eq
!
(
value
[
1
1
2
2
3
3
4
4
5
5
6
6
7
7
8
8
9
9
0
0
]
)
;
assert
!
(
der
.
at_end
(
)
)
;
}
#
[
test
]
fn
der_test_not_shortest_two_byte_length_encoding
(
)
{
let
input
=
vec
!
[
SEQUENCE
0x81
1
1
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
SEQUENCE
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_not_shortest_three_byte_length_encoding
(
)
{
let
input
=
vec
!
[
SEQUENCE
0x82
0
1
1
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
SEQUENCE
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_indefinite_length_unsupported
(
)
{
let
input
=
vec
!
[
SEQUENCE
0x80
1
2
3
0x00
0x00
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
SEQUENCE
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
der_test_input_too_long
(
)
{
let
input
=
vec
!
[
SEQUENCE
0x83
0x01
0x00
0x01
1
1
1
1
]
;
let
mut
der
=
Der
:
:
new
(
&
input
)
;
assert
!
(
der
.
read_tlv
(
SEQUENCE
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
empty_input_fails
(
)
{
let
empty
=
Vec
:
:
new
(
)
;
assert
!
(
read_rsa_modulus
(
&
empty
)
.
is_err
(
)
)
;
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
)
)
]
assert
!
(
read_ec_sig_point
(
&
empty
)
.
is_err
(
)
)
;
assert
!
(
read_encoded_certificate_identifiers
(
&
empty
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
empty_sequence_fails
(
)
{
let
empty
=
vec
!
[
SEQUENCE
|
CONSTRUCTED
]
;
assert
!
(
read_rsa_modulus
(
&
empty
)
.
is_err
(
)
)
;
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
)
)
]
assert
!
(
read_ec_sig_point
(
&
empty
)
.
is_err
(
)
)
;
assert
!
(
read_encoded_certificate_identifiers
(
&
empty
)
.
is_err
(
)
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
target_os
=
"
android
"
)
)
]
fn
test_der_ec_sig_to_raw
(
)
{
let
ec_sig_point
=
vec
!
[
0x30
0x45
0x02
0x20
0x5c
0x75
0x51
0x9f
0x13
0x11
0x50
0xcd
0x5d
0x8a
0xde
0x20
0xa3
0xbc
0x06
0x30
0x91
0xff
0xb2
0x73
0x75
0x5f
0x31
0x64
0xec
0xfd
0xcb
0x42
0x80
0x0a
0x70
0xe6
0x02
0x21
0x00
0x85
0xfb
0xb4
0x75
0x5d
0xb5
0x1c
0x5f
0x97
0x52
0x27
0xd9
0x71
0x14
0xc0
0xbc
0x67
0x10
0x4f
0x72
0x2e
0x37
0xb2
0x78
0x54
0xfd
0xd0
0x9d
0x51
0xd4
0x9f
0xf2
]
;
let
result
=
der_ec_sig_to_raw
(
&
ec_sig_point
32
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
expected
=
vec
!
[
0x5c
0x75
0x51
0x9f
0x13
0x11
0x50
0xcd
0x5d
0x8a
0xde
0x20
0xa3
0xbc
0x06
0x30
0x91
0xff
0xb2
0x73
0x75
0x5f
0x31
0x64
0xec
0xfd
0xcb
0x42
0x80
0x0a
0x70
0xe6
0x85
0xfb
0xb4
0x75
0x5d
0xb5
0x1c
0x5f
0x97
0x52
0x27
0xd9
0x71
0x14
0xc0
0xbc
0x67
0x10
0x4f
0x72
0x2e
0x37
0xb2
0x78
0x54
0xfd
0xd0
0x9d
0x51
0xd4
0x9f
0xf2
]
;
assert_eq
!
(
result
.
unwrap
(
)
expected
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
target_os
=
"
android
"
)
)
]
fn
test_der_ec_sig_to_raw_long
(
)
{
let
ec_sig
=
vec
!
[
0x30
0x45
0x02
0x20
0x5c
0x75
0x51
0x9f
0x13
0x11
0x50
0xcd
0x5d
0x8a
0xde
0x20
0xa3
0xbc
0x06
0x30
0x91
0xff
0xb2
0x73
0x75
0x5f
0x31
0x64
0xec
0xfd
0xcb
0x42
0x80
0x0a
0x70
0xe6
0x02
0x21
0x00
0x85
0xfb
0xb4
0x75
0x5d
0xb5
0x1c
0x5f
0x97
0x52
0x27
0xd9
0x71
0x14
0xc0
0xbc
0x67
0x10
0x4f
0x72
0x2e
0x37
0xb2
0x78
0x54
0xfd
0xd0
0x9d
0x51
0xd4
0x9f
0xf2
]
;
let
result
=
der_ec_sig_to_raw
(
&
ec_sig
16
)
;
assert
!
(
result
.
is_err
(
)
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
macos
"
target_os
=
"
ios
"
target_os
=
"
android
"
)
)
]
fn
test_der_ec_sig_to_raw_short
(
)
{
let
ec_sig_point
=
vec
!
[
0x30
0x45
0x02
0x20
0x5c
0x75
0x51
0x9f
0x13
0x11
0x50
0xcd
0x5d
0x8a
0xde
0x20
0xa3
0xbc
0x06
0x30
0x91
0xff
0xb2
0x73
0x75
0x5f
0x31
0x64
0xec
0xfd
0xcb
0x42
0x80
0x0a
0x70
0xe6
0x02
0x21
0x00
0x85
0xfb
0xb4
0x75
0x5d
0xb5
0x1c
0x5f
0x97
0x52
0x27
0xd9
0x71
0x14
0xc0
0xbc
0x67
0x10
0x4f
0x72
0x2e
0x37
0xb2
0x78
0x54
0xfd
0xd0
0x9d
0x51
0xd4
0x9f
0xf2
]
;
let
result
=
der_ec_sig_to_raw
(
&
ec_sig_point
48
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
expected
=
vec
!
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x5c
0x75
0x51
0x9f
0x13
0x11
0x50
0xcd
0x5d
0x8a
0xde
0x20
0xa3
0xbc
0x06
0x30
0x91
0xff
0xb2
0x73
0x75
0x5f
0x31
0x64
0xec
0xfd
0xcb
0x42
0x80
0x0a
0x70
0xe6
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x85
0xfb
0xb4
0x75
0x5d
0xb5
0x1c
0x5f
0x97
0x52
0x27
0xd9
0x71
0x14
0xc0
0xbc
0x67
0x10
0x4f
0x72
0x2e
0x37
0xb2
0x78
0x54
0xfd
0xd0
0x9d
0x51
0xd4
0x9f
0xf2
]
;
assert_eq
!
(
result
.
unwrap
(
)
expected
)
;
}
#
[
test
]
fn
test_read_rsa_modulus
(
)
{
let
rsa_key
=
include_bytes
!
(
"
.
.
/
test
/
rsa
.
bin
"
)
;
let
result
=
read_rsa_modulus
(
rsa_key
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
modulus
=
result
.
unwrap
(
)
;
assert_eq
!
(
modulus
include_bytes
!
(
"
.
.
/
test
/
modulus
.
bin
"
)
.
to_vec
(
)
)
;
}
#
[
test
]
fn
test_read_certificate_identifiers
(
)
{
let
certificate
=
include_bytes
!
(
"
.
.
/
test
/
certificate
.
bin
"
)
;
let
result
=
read_encoded_certificate_identifiers
(
certificate
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
(
serial_number
issuer
subject
)
=
result
.
unwrap
(
)
;
assert_eq
!
(
serial_number
&
[
0x02
0x14
0x3f
0xed
0x7b
0x43
0x47
0x8a
0x53
0x42
0x5b
0x0d
0x50
0xe1
0x37
0x88
0x2a
0x20
0x3f
0x31
0x17
0x20
]
)
;
assert_eq
!
(
issuer
&
[
0x30
0x12
0x31
0x10
0x30
0x0e
0x06
0x03
0x55
0x04
0x03
0x0c
0x07
0x54
0x65
0x73
0x74
0x20
0x43
0x41
]
)
;
assert_eq
!
(
subject
&
[
0x30
0x1a
0x31
0x18
0x30
0x16
0x06
0x03
0x55
0x04
0x03
0x0c
0x0f
0x54
0x65
0x73
0x74
0x20
0x45
0x6e
0x64
0x2d
0x65
0x6e
0x74
0x69
0x74
0x79
]
)
;
}
#
[
test
]
fn
test_read_v1_certificate_identifiers
(
)
{
let
certificate
=
include_bytes
!
(
"
.
.
/
test
/
v1certificate
.
bin
"
)
;
let
result
=
read_encoded_certificate_identifiers
(
certificate
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
(
serial_number
issuer
subject
)
=
result
.
unwrap
(
)
;
assert_eq
!
(
serial_number
&
[
0x02
0x14
0x51
0x6b
0x24
0xaa
0xf2
0x7f
0x56
0x13
0x5f
0xc3
0x8b
0x5c
0xa7
0x00
0x83
0xa8
0xee
0xca
0xad
0xa0
]
)
;
assert_eq
!
(
issuer
&
[
0x30
0x12
0x31
0x10
0x30
0x0E
0x06
0x03
0x55
0x04
0x03
0x0C
0x07
0x54
0x65
0x73
0x74
0x20
0x43
0x41
]
)
;
assert_eq
!
(
subject
&
[
0x30
0x12
0x31
0x10
0x30
0x0E
0x06
0x03
0x55
0x04
0x03
0x0C
0x07
0x56
0x31
0x20
0x43
0x65
0x72
0x74
]
)
;
}
#
[
test
]
#
[
cfg
(
target_os
=
"
windows
"
)
]
fn
test_read_digest
(
)
{
let
digest_info
=
[
0x30
0x31
0x30
0x0d
0x06
0x09
0x60
0x86
0x48
0x1
0x65
0x03
0x04
0x02
0x01
0x05
0x00
0x04
0x20
0x1a
0x7f
0xcd
0xb9
0xa5
0xf6
0x49
0xf9
0x54
0x88
0x5c
0xfe
0x14
0x5f
0x3e
0x93
0xf0
0xd1
0xfa
0x72
0xbe
0x98
0x0c
0xc6
0xec
0x82
0xc7
0x0e
0x14
0x07
0xc7
0xd2
]
;
let
result
=
read_digest_info
(
&
digest_info
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
(
oid
digest
)
=
result
.
unwrap
(
)
;
assert_eq
!
(
oid
&
[
0x60
0x86
0x48
0x1
0x65
0x03
0x04
0x02
0x01
]
)
;
assert_eq
!
(
digest
&
[
0x1a
0x7f
0xcd
0xb9
0xa5
0xf6
0x49
0xf9
0x54
0x88
0x5c
0xfe
0x14
0x5f
0x3e
0x93
0xf0
0xd1
0xfa
0x72
0xbe
0x98
0x0c
0xc6
0xec
0x82
0xc7
0x0e
0x14
0x07
0xc7
0xd2
]
)
;
}
#
[
test
]
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
test_read_spki_algorithm_parameters
(
)
{
let
spki
=
[
0x30
0x59
0x30
0x13
0x06
0x07
0x2a
0x86
0x48
0xce
0x3d
0x02
0x01
0x06
0x08
0x2a
0x86
0x48
0xce
0x3d
0x03
0x01
0x07
0x03
0x42
0x00
0x04
0x4f
0xbf
0xbb
0xbb
0x61
0xe0
0xf8
0xf9
0xb1
0xa6
0x0a
0x59
0xac
0x87
0x04
0xe2
0xec
0x05
0x0b
0x42
0x3e
0x3c
0xf7
0x2e
0x92
0x3f
0x2c
0x4f
0x79
0x4b
0x45
0x5c
0x2a
0x69
0xd2
0x33
0x45
0x6c
0x36
0xc4
0x11
0x9d
0x07
0x06
0xe0
0x0e
0xed
0xc8
0xd1
0x93
0x90
0xd7
0x99
0x1b
0x7b
0x2d
0x07
0xa3
0x04
0xea
0xa0
0x4a
0xa6
0xc0
]
;
let
result
=
read_spki_algorithm_parameters
(
&
spki
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
parameters
=
result
.
unwrap
(
)
;
assert_eq
!
(
&
parameters
ENCODED_OID_BYTES_SECP256R1
)
;
}
}
