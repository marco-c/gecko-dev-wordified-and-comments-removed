use
pkcs11_bindings
:
:
*
;
use
std
:
:
collections
:
:
{
BTreeMap
BTreeSet
}
;
use
crate
:
:
error
:
:
{
Error
ErrorType
}
;
use
crate
:
:
error_here
;
use
crate
:
:
util
:
:
CryptokiCert
;
extern
"
C
"
{
fn
IsGeckoSearchingForClientAuthCertificates
(
)
-
>
bool
;
}
pub
trait
CryptokiObject
{
fn
matches
(
&
self
attrs
:
&
[
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
]
)
-
>
bool
;
fn
get_attribute
(
&
self
attribute
:
CK_ATTRIBUTE_TYPE
)
-
>
Option
<
&
[
u8
]
>
;
}
pub
trait
Sign
{
fn
get_signature_length
(
&
mut
self
data
:
&
[
u8
]
params
:
&
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
-
>
Result
<
usize
Error
>
;
fn
sign
(
&
mut
self
data
:
&
[
u8
]
params
:
&
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
-
>
Result
<
Vec
<
u8
>
Error
>
;
}
pub
trait
ClientCertsBackend
{
type
Key
:
CryptokiObject
+
Sign
;
#
[
allow
(
clippy
:
:
type_complexity
)
]
fn
find_objects
(
&
mut
self
)
-
>
Result
<
(
Vec
<
CryptokiCert
>
Vec
<
Self
:
:
Key
>
)
Error
>
;
}
const
SUPPORTED_ATTRIBUTES
:
&
[
CK_ATTRIBUTE_TYPE
]
=
&
[
CKA_CLASS
CKA_TOKEN
CKA_LABEL
CKA_ID
CKA_VALUE
CKA_ISSUER
CKA_SERIAL_NUMBER
CKA_SUBJECT
CKA_PRIVATE
CKA_KEY_TYPE
CKA_MODULUS
CKA_EC_PARAMS
]
;
enum
Object
<
B
:
ClientCertsBackend
>
{
Cert
(
CryptokiCert
)
Key
(
B
:
:
Key
)
}
impl
<
B
:
ClientCertsBackend
>
Object
<
B
>
{
fn
matches
(
&
self
attrs
:
&
[
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
]
)
-
>
bool
{
match
self
{
Object
:
:
Cert
(
cert
)
=
>
cert
.
matches
(
attrs
)
Object
:
:
Key
(
key
)
=
>
key
.
matches
(
attrs
)
}
}
fn
get_attribute
(
&
self
attribute
:
CK_ATTRIBUTE_TYPE
)
-
>
Option
<
&
[
u8
]
>
{
match
self
{
Object
:
:
Cert
(
cert
)
=
>
cert
.
get_attribute
(
attribute
)
Object
:
:
Key
(
key
)
=
>
key
.
get_attribute
(
attribute
)
}
}
fn
id
(
&
self
)
-
>
Result
<
&
[
u8
]
Error
>
{
self
.
get_attribute
(
CKA_ID
)
.
ok_or_else
(
|
|
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
}
fn
get_signature_length
(
&
mut
self
data
:
Vec
<
u8
>
params
:
&
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
-
>
Result
<
usize
Error
>
{
match
self
{
Object
:
:
Cert
(
_
)
=
>
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
Object
:
:
Key
(
key
)
=
>
key
.
get_signature_length
(
&
data
params
)
}
}
fn
sign
(
&
mut
self
data
:
Vec
<
u8
>
params
:
&
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
match
self
{
Object
:
:
Cert
(
_
)
=
>
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
Object
:
:
Key
(
key
)
=
>
key
.
sign
(
&
data
params
)
}
}
}
pub
struct
Manager
<
B
:
ClientCertsBackend
>
{
sessions
:
BTreeSet
<
CK_SESSION_HANDLE
>
searches
:
BTreeMap
<
CK_SESSION_HANDLE
Vec
<
CK_OBJECT_HANDLE
>
>
signs
:
BTreeMap
<
CK_SESSION_HANDLE
(
CK_OBJECT_HANDLE
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
>
objects
:
BTreeMap
<
CK_OBJECT_HANDLE
Object
<
B
>
>
cert_ids
:
BTreeSet
<
Vec
<
u8
>
>
key_ids
:
BTreeSet
<
Vec
<
u8
>
>
next_session
:
CK_SESSION_HANDLE
next_handle
:
CK_OBJECT_HANDLE
backend
:
B
}
impl
<
B
:
ClientCertsBackend
>
Manager
<
B
>
{
pub
fn
new
(
backend
:
B
)
-
>
Manager
<
B
>
{
Manager
{
sessions
:
BTreeSet
:
:
new
(
)
searches
:
BTreeMap
:
:
new
(
)
signs
:
BTreeMap
:
:
new
(
)
objects
:
BTreeMap
:
:
new
(
)
cert_ids
:
BTreeSet
:
:
new
(
)
key_ids
:
BTreeSet
:
:
new
(
)
next_session
:
1
next_handle
:
1
backend
}
}
fn
maybe_find_new_objects
(
&
mut
self
)
-
>
Result
<
(
)
Error
>
{
let
(
certs
keys
)
=
self
.
backend
.
find_objects
(
)
?
;
for
cert
in
certs
{
let
object
=
Object
:
:
Cert
(
cert
)
;
if
self
.
cert_ids
.
contains
(
object
.
id
(
)
?
)
{
continue
;
}
self
.
cert_ids
.
insert
(
object
.
id
(
)
?
.
to_vec
(
)
)
;
let
handle
=
self
.
get_next_handle
(
)
;
self
.
objects
.
insert
(
handle
object
)
;
}
for
key
in
keys
{
let
object
=
Object
:
:
Key
(
key
)
;
if
self
.
key_ids
.
contains
(
object
.
id
(
)
?
)
{
continue
;
}
self
.
key_ids
.
insert
(
object
.
id
(
)
?
.
to_vec
(
)
)
;
let
handle
=
self
.
get_next_handle
(
)
;
self
.
objects
.
insert
(
handle
object
)
;
}
Ok
(
(
)
)
}
pub
fn
open_session
(
&
mut
self
)
-
>
Result
<
CK_SESSION_HANDLE
Error
>
{
let
next_session
=
self
.
next_session
;
self
.
next_session
+
=
1
;
self
.
sessions
.
insert
(
next_session
)
;
Ok
(
next_session
)
}
pub
fn
close_session
(
&
mut
self
session
:
CK_SESSION_HANDLE
)
-
>
Result
<
(
)
Error
>
{
if
!
self
.
sessions
.
remove
(
&
session
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidInput
)
)
;
}
Ok
(
(
)
)
}
pub
fn
close_all_sessions
(
&
mut
self
)
-
>
Result
<
(
)
Error
>
{
self
.
sessions
.
clear
(
)
;
Ok
(
(
)
)
}
fn
get_next_handle
(
&
mut
self
)
-
>
CK_OBJECT_HANDLE
{
let
next_handle
=
self
.
next_handle
;
self
.
next_handle
+
=
1
;
next_handle
}
pub
fn
start_search
(
&
mut
self
session
:
CK_SESSION_HANDLE
attrs
:
Vec
<
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
>
)
-
>
Result
<
(
)
Error
>
{
if
!
self
.
sessions
.
contains
(
&
session
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
;
}
for
(
attr
_
)
in
&
attrs
{
if
!
SUPPORTED_ATTRIBUTES
.
contains
(
attr
)
{
self
.
searches
.
insert
(
session
Vec
:
:
new
(
)
)
;
return
Ok
(
(
)
)
;
}
}
if
unsafe
{
IsGeckoSearchingForClientAuthCertificates
(
)
}
{
self
.
maybe_find_new_objects
(
)
?
;
}
let
mut
handles
=
Vec
:
:
new
(
)
;
for
(
handle
object
)
in
&
self
.
objects
{
if
object
.
matches
(
&
attrs
)
{
handles
.
push
(
*
handle
)
;
}
}
self
.
searches
.
insert
(
session
handles
)
;
Ok
(
(
)
)
}
pub
fn
search
(
&
mut
self
session
:
CK_SESSION_HANDLE
max_objects
:
usize
)
-
>
Result
<
Vec
<
CK_OBJECT_HANDLE
>
Error
>
{
if
max_objects
=
=
0
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
;
}
match
self
.
searches
.
get_mut
(
&
session
)
{
Some
(
search
)
=
>
{
let
split_at
=
if
max_objects
>
=
search
.
len
(
)
{
0
}
else
{
search
.
len
(
)
-
max_objects
}
;
let
to_return
=
search
.
split_off
(
split_at
)
;
if
to_return
.
len
(
)
>
max_objects
{
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
;
}
Ok
(
to_return
)
}
None
=
>
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
}
pub
fn
clear_search
(
&
mut
self
session
:
CK_SESSION_HANDLE
)
-
>
Result
<
(
)
Error
>
{
self
.
searches
.
remove
(
&
session
)
;
Ok
(
(
)
)
}
pub
fn
get_attributes
(
&
self
object_handle
:
CK_OBJECT_HANDLE
attr_types
:
Vec
<
CK_ATTRIBUTE_TYPE
>
)
-
>
Result
<
Vec
<
Option
<
Vec
<
u8
>
>
>
Error
>
{
let
object
=
match
self
.
objects
.
get
(
&
object_handle
)
{
Some
(
object
)
=
>
object
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
let
mut
results
=
Vec
:
:
with_capacity
(
attr_types
.
len
(
)
)
;
for
attr_type
in
attr_types
{
let
result
=
object
.
get_attribute
(
attr_type
)
.
map
(
|
value
|
value
.
to_owned
(
)
)
;
results
.
push
(
result
)
;
}
Ok
(
results
)
}
pub
fn
start_sign
(
&
mut
self
session
:
CK_SESSION_HANDLE
key_handle
:
CK_OBJECT_HANDLE
params
:
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
-
>
Result
<
(
)
Error
>
{
if
self
.
signs
.
contains_key
(
&
session
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
;
}
self
.
signs
.
insert
(
session
(
key_handle
params
)
)
;
Ok
(
(
)
)
}
pub
fn
get_signature_length
(
&
mut
self
session
:
CK_SESSION_HANDLE
data
:
Vec
<
u8
>
)
-
>
Result
<
usize
Error
>
{
let
(
key_handle
params
)
=
match
self
.
signs
.
get
(
&
session
)
{
Some
(
(
key_handle
params
)
)
=
>
(
key_handle
params
)
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
let
key
=
match
self
.
objects
.
get_mut
(
key_handle
)
{
Some
(
key
)
=
>
key
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
key
.
get_signature_length
(
data
params
)
}
pub
fn
sign
(
&
mut
self
session
:
CK_SESSION_HANDLE
data
:
Vec
<
u8
>
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
let
(
key_handle
params
)
=
match
self
.
signs
.
remove
(
&
session
)
{
Some
(
(
key_handle
params
)
)
=
>
(
key_handle
params
)
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
let
key
=
match
self
.
objects
.
get_mut
(
&
key_handle
)
{
Some
(
key
)
=
>
key
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
key
.
sign
(
data
&
params
)
}
}
