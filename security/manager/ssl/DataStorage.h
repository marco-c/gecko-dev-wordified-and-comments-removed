#
ifndef
mozilla_DataStorage_h
#
define
mozilla_DataStorage_h
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
namespace
dom
{
class
DataStorageItem
;
}
enum
DataStorageType
{
DataStorage_Persistent
DataStorage_Temporary
DataStorage_Private
}
;
class
DataStorage
:
public
nsIObserver
{
typedef
dom
:
:
DataStorageItem
DataStorageItem
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
static
already_AddRefed
<
DataStorage
>
Get
(
const
nsString
&
aFilename
)
;
static
already_AddRefed
<
DataStorage
>
GetIfExists
(
const
nsString
&
aFilename
)
;
nsresult
Init
(
bool
&
aDataWillPersist
)
;
nsCString
Get
(
const
nsCString
&
aKey
DataStorageType
aType
)
;
nsresult
Put
(
const
nsCString
&
aKey
const
nsCString
&
aValue
DataStorageType
aType
)
;
void
Remove
(
const
nsCString
&
aKey
DataStorageType
aType
)
;
nsresult
Clear
(
)
;
void
GetAll
(
InfallibleTArray
<
DataStorageItem
>
*
aItems
)
;
private
:
explicit
DataStorage
(
const
nsString
&
aFilename
)
;
virtual
~
DataStorage
(
)
;
class
Writer
;
class
Reader
;
class
Entry
{
public
:
Entry
(
)
;
bool
UpdateScore
(
)
;
uint32_t
mScore
;
int32_t
mLastAccessed
;
nsCString
mValue
;
}
;
class
KeyAndEntry
{
public
:
nsCString
mKey
;
Entry
mEntry
;
}
;
typedef
nsDataHashtable
<
nsCStringHashKey
Entry
>
DataStorageTable
;
typedef
nsRefPtrHashtable
<
nsStringHashKey
DataStorage
>
DataStorages
;
void
WaitForReady
(
)
;
nsresult
AsyncWriteData
(
const
MutexAutoLock
&
aProofOfLock
)
;
nsresult
AsyncReadData
(
bool
&
aHaveProfileDir
const
MutexAutoLock
&
aProofOfLock
)
;
nsresult
AsyncSetTimer
(
const
MutexAutoLock
&
aProofOfLock
)
;
nsresult
DispatchShutdownTimer
(
const
MutexAutoLock
&
aProofOfLock
)
;
static
nsresult
ValidateKeyAndValue
(
const
nsCString
&
aKey
const
nsCString
&
aValue
)
;
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
SetTimer
(
)
;
void
ShutdownTimer
(
)
;
void
NotifyObservers
(
const
char
*
aTopic
)
;
bool
GetInternal
(
const
nsCString
&
aKey
Entry
*
aEntry
DataStorageType
aType
const
MutexAutoLock
&
aProofOfLock
)
;
nsresult
PutInternal
(
const
nsCString
&
aKey
Entry
&
aEntry
DataStorageType
aType
const
MutexAutoLock
&
aProofOfLock
)
;
void
MaybeEvictOneEntry
(
DataStorageType
aType
const
MutexAutoLock
&
aProofOfLock
)
;
DataStorageTable
&
GetTableForType
(
DataStorageType
aType
const
MutexAutoLock
&
aProofOfLock
)
;
void
ReadAllFromTable
(
DataStorageType
aType
InfallibleTArray
<
DataStorageItem
>
*
aItems
const
MutexAutoLock
&
aProofOfLock
)
;
Mutex
mMutex
;
DataStorageTable
mPersistentDataTable
;
DataStorageTable
mTemporaryDataTable
;
DataStorageTable
mPrivateDataTable
;
nsCOMPtr
<
nsIThread
>
mWorkerThread
;
nsCOMPtr
<
nsIFile
>
mBackingFile
;
nsCOMPtr
<
nsITimer
>
mTimer
;
uint32_t
mTimerDelay
;
bool
mPendingWrite
;
bool
mShuttingDown
;
bool
mInitCalled
;
Monitor
mReadyMonitor
;
bool
mReady
;
const
nsString
mFilename
;
static
StaticAutoPtr
<
DataStorages
>
sDataStorages
;
}
;
}
#
endif
