#
ifndef
mozilla_DataStorage_h
#
define
mozilla_DataStorage_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsString
.
h
"
class
psm_DataStorageTest
;
namespace
mozilla
{
class
DataStorageMemoryReporter
;
class
TaskQueue
;
enum
DataStorageType
{
DataStorage_Persistent
DataStorage_Temporary
DataStorage_Private
}
;
struct
DataStorageItem
final
{
nsCString
key
;
nsCString
value
;
DataStorageType
type
;
}
;
enum
class
DataStorageClass
{
#
define
DATA_STORAGE
(
_
)
_
#
include
"
mozilla
/
DataStorageList
.
h
"
#
undef
DATA_STORAGE
}
;
class
DataStorage
:
public
nsIObserver
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
static
already_AddRefed
<
DataStorage
>
Get
(
DataStorageClass
aFilename
)
;
nsresult
Init
(
)
;
nsCString
Get
(
const
nsCString
&
aKey
DataStorageType
aType
)
;
nsresult
Put
(
const
nsCString
&
aKey
const
nsCString
&
aValue
DataStorageType
aType
)
;
void
Remove
(
const
nsCString
&
aKey
DataStorageType
aType
)
;
nsresult
Clear
(
)
;
void
GetAll
(
nsTArray
<
DataStorageItem
>
*
aItems
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
bool
IsReady
(
)
;
void
ShutdownTimer
(
)
;
private
:
explicit
DataStorage
(
const
nsString
&
aFilename
)
;
virtual
~
DataStorage
(
)
=
default
;
static
already_AddRefed
<
DataStorage
>
GetFromRawFileName
(
const
nsString
&
aFilename
)
;
friend
class
:
:
psm_DataStorageTest
;
friend
class
mozilla
:
:
DataStorageMemoryReporter
;
class
Writer
;
class
Reader
;
class
Entry
{
public
:
Entry
(
)
;
bool
UpdateScore
(
)
;
uint32_t
mScore
;
int32_t
mLastAccessed
;
nsCString
mValue
;
}
;
class
KeyAndEntry
{
public
:
nsCString
mKey
;
Entry
mEntry
;
}
;
typedef
nsTHashMap
<
nsCStringHashKey
Entry
>
DataStorageTable
;
typedef
nsRefPtrHashtable
<
nsStringHashKey
DataStorage
>
DataStorages
;
void
WaitForReady
(
)
;
nsresult
AsyncWriteData
(
const
MutexAutoLock
&
aProofOfLock
)
;
nsresult
AsyncReadData
(
const
MutexAutoLock
&
aProofOfLock
)
;
static
nsresult
ValidateKeyAndValue
(
const
nsCString
&
aKey
const
nsCString
&
aValue
)
;
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
NotifyObservers
(
const
char
*
aTopic
)
;
bool
GetInternal
(
const
nsCString
&
aKey
Entry
*
aEntry
DataStorageType
aType
const
MutexAutoLock
&
aProofOfLock
)
;
nsresult
PutInternal
(
const
nsCString
&
aKey
Entry
&
aEntry
DataStorageType
aType
const
MutexAutoLock
&
aProofOfLock
)
;
void
MaybeEvictOneEntry
(
DataStorageType
aType
const
MutexAutoLock
&
aProofOfLock
)
;
DataStorageTable
&
GetTableForType
(
DataStorageType
aType
const
MutexAutoLock
&
aProofOfLock
)
;
void
ReadAllFromTable
(
DataStorageType
aType
nsTArray
<
DataStorageItem
>
*
aItems
const
MutexAutoLock
&
aProofOfLock
)
;
Mutex
mMutex
;
DataStorageTable
mPersistentDataTable
GUARDED_BY
(
mMutex
)
;
DataStorageTable
mTemporaryDataTable
GUARDED_BY
(
mMutex
)
;
DataStorageTable
mPrivateDataTable
GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIFile
>
mBackingFile
GUARDED_BY
(
mMutex
)
;
bool
mPendingWrite
GUARDED_BY
(
mMutex
)
;
bool
mShuttingDown
GUARDED_BY
(
mMutex
)
;
RefPtr
<
TaskQueue
>
mBackgroundTaskQueue
GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsITimer
>
mTimer
;
mozilla
:
:
Atomic
<
bool
>
mInitCalled
;
Monitor
mReadyMonitor
;
bool
mReady
GUARDED_BY
(
mReadyMonitor
)
;
const
nsString
mFilename
;
static
StaticAutoPtr
<
DataStorages
>
sDataStorages
;
}
;
}
#
endif
