#
include
"
nsPK11TokenDB
.
h
"
#
include
<
string
.
h
>
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsPromiseFlatString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
prerror
.
h
"
#
include
"
secerr
.
h
"
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
NS_IMPL_ISUPPORTS
(
nsPK11Token
nsIPK11Token
)
nsPK11Token
:
:
nsPK11Token
(
PK11SlotInfo
*
slot
)
:
mUIContext
(
new
PipUIContext
(
)
)
{
MOZ_ASSERT
(
slot
)
;
if
(
isAlreadyShutDown
(
)
)
return
;
mSlot
.
reset
(
PK11_ReferenceSlot
(
slot
)
)
;
mSeries
=
PK11_GetSlotSeries
(
slot
)
;
Unused
<
<
refreshTokenInfo
(
)
;
}
nsresult
nsPK11Token
:
:
refreshTokenInfo
(
)
{
mTokenName
=
PK11_GetTokenName
(
mSlot
.
get
(
)
)
;
CK_TOKEN_INFO
tokInfo
;
nsresult
rv
=
MapSECStatus
(
PK11_GetTokenInfo
(
mSlot
.
get
(
)
&
tokInfo
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
char
*
ccLabel
=
mozilla
:
:
BitwiseCast
<
char
*
CK_UTF8CHAR
*
>
(
tokInfo
.
label
)
;
mTokenLabel
.
Assign
(
ccLabel
strnlen
(
ccLabel
sizeof
(
tokInfo
.
label
)
)
)
;
mTokenLabel
.
Trim
(
"
"
false
true
)
;
const
char
*
ccManID
=
mozilla
:
:
BitwiseCast
<
char
*
CK_UTF8CHAR
*
>
(
tokInfo
.
manufacturerID
)
;
mTokenManufacturerID
.
Assign
(
ccManID
strnlen
(
ccManID
sizeof
(
tokInfo
.
manufacturerID
)
)
)
;
mTokenManufacturerID
.
Trim
(
"
"
false
true
)
;
mTokenHWVersion
.
Truncate
(
)
;
mTokenHWVersion
.
AppendInt
(
tokInfo
.
hardwareVersion
.
major
)
;
mTokenHWVersion
.
Append
(
'
.
'
)
;
mTokenHWVersion
.
AppendInt
(
tokInfo
.
hardwareVersion
.
minor
)
;
mTokenFWVersion
.
Truncate
(
)
;
mTokenFWVersion
.
AppendInt
(
tokInfo
.
firmwareVersion
.
major
)
;
mTokenFWVersion
.
Append
(
'
.
'
)
;
mTokenFWVersion
.
AppendInt
(
tokInfo
.
firmwareVersion
.
minor
)
;
const
char
*
ccSerial
=
mozilla
:
:
BitwiseCast
<
char
*
CK_CHAR
*
>
(
tokInfo
.
serialNumber
)
;
mTokenSerialNum
.
Assign
(
ccSerial
strnlen
(
ccSerial
sizeof
(
tokInfo
.
serialNumber
)
)
)
;
mTokenSerialNum
.
Trim
(
"
"
false
true
)
;
return
NS_OK
;
}
nsPK11Token
:
:
~
nsPK11Token
(
)
{
if
(
isAlreadyShutDown
(
)
)
{
return
;
}
destructorSafeDestroyNSSReference
(
)
;
shutdown
(
ShutdownCalledFrom
:
:
Object
)
;
}
void
nsPK11Token
:
:
virtualDestroyNSSReference
(
)
{
destructorSafeDestroyNSSReference
(
)
;
}
void
nsPK11Token
:
:
destructorSafeDestroyNSSReference
(
)
{
mSlot
=
nullptr
;
}
nsresult
nsPK11Token
:
:
GetAttributeHelper
(
const
nsACString
&
attribute
nsACString
&
xpcomOutParam
)
{
if
(
isAlreadyShutDown
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
PK11_GetSlotSeries
(
mSlot
.
get
(
)
)
!
=
mSeries
)
{
nsresult
rv
=
refreshTokenInfo
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
xpcomOutParam
=
attribute
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPK11Token
:
:
GetTokenName
(
nsACString
&
tokenName
)
{
return
GetAttributeHelper
(
mTokenName
tokenName
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
GetTokenLabel
(
nsACString
&
tokenLabel
)
{
return
GetAttributeHelper
(
mTokenLabel
tokenLabel
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
GetTokenManID
(
nsACString
&
tokenManufacturerID
)
{
return
GetAttributeHelper
(
mTokenManufacturerID
tokenManufacturerID
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
GetTokenHWVersion
(
nsACString
&
tokenHWVersion
)
{
return
GetAttributeHelper
(
mTokenHWVersion
tokenHWVersion
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
GetTokenFWVersion
(
nsACString
&
tokenFWVersion
)
{
return
GetAttributeHelper
(
mTokenFWVersion
tokenFWVersion
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
GetTokenSerialNumber
(
nsACString
&
tokenSerialNum
)
{
return
GetAttributeHelper
(
mTokenSerialNum
tokenSerialNum
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
IsLoggedIn
(
bool
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
isAlreadyShutDown
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
*
_retval
=
PK11_IsLoggedIn
(
mSlot
.
get
(
)
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPK11Token
:
:
Login
(
bool
force
)
{
if
(
isAlreadyShutDown
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
nsresult
rv
;
bool
test
;
rv
=
this
-
>
NeedsLogin
(
&
test
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
test
&
&
force
)
{
rv
=
this
-
>
LogoutSimple
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
rv
=
setPassword
(
mSlot
.
get
(
)
mUIContext
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
MapSECStatus
(
PK11_Authenticate
(
mSlot
.
get
(
)
true
mUIContext
)
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
LogoutSimple
(
)
{
if
(
isAlreadyShutDown
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
Unused
<
<
PK11_Logout
(
mSlot
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPK11Token
:
:
LogoutAndDropAuthenticatedResources
(
)
{
static
NS_DEFINE_CID
(
kNSSComponentCID
NS_NSSCOMPONENT_CID
)
;
nsresult
rv
=
LogoutSimple
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsINSSComponent
>
nssComponent
(
do_GetService
(
kNSSComponentCID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
nssComponent
-
>
LogoutAuthenticatedPK11
(
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
Reset
(
)
{
if
(
isAlreadyShutDown
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
return
MapSECStatus
(
PK11_ResetToken
(
mSlot
.
get
(
)
nullptr
)
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
GetNeedsUserInit
(
bool
*
aNeedsUserInit
)
{
NS_ENSURE_ARG_POINTER
(
aNeedsUserInit
)
;
if
(
isAlreadyShutDown
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
*
aNeedsUserInit
=
PK11_NeedUserInit
(
mSlot
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPK11Token
:
:
CheckPassword
(
const
nsACString
&
password
bool
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
isAlreadyShutDown
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
SECStatus
srv
=
PK11_CheckUserPassword
(
mSlot
.
get
(
)
PromiseFlatCString
(
password
)
.
get
(
)
)
;
if
(
srv
!
=
SECSuccess
)
{
*
_retval
=
false
;
PRErrorCode
error
=
PR_GetError
(
)
;
if
(
error
!
=
SEC_ERROR_BAD_PASSWORD
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
error
)
;
}
}
else
{
*
_retval
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPK11Token
:
:
InitPassword
(
const
nsACString
&
initialPassword
)
{
if
(
isAlreadyShutDown
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
const
nsCString
&
passwordCStr
=
PromiseFlatCString
(
initialPassword
)
;
bool
hasPassword
;
nsresult
rv
=
GetHasPassword
(
&
hasPassword
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
PK11_NeedUserInit
(
mSlot
.
get
(
)
)
&
&
!
hasPassword
)
{
return
MapSECStatus
(
PK11_ChangePW
(
mSlot
.
get
(
)
"
"
passwordCStr
.
get
(
)
)
)
;
}
return
MapSECStatus
(
PK11_InitPin
(
mSlot
.
get
(
)
"
"
passwordCStr
.
get
(
)
)
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
ChangePassword
(
const
nsACString
&
oldPassword
const
nsACString
&
newPassword
)
{
if
(
isAlreadyShutDown
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
return
MapSECStatus
(
PK11_ChangePW
(
mSlot
.
get
(
)
oldPassword
.
IsVoid
(
)
?
nullptr
:
PromiseFlatCString
(
oldPassword
)
.
get
(
)
newPassword
.
IsVoid
(
)
?
nullptr
:
PromiseFlatCString
(
newPassword
)
.
get
(
)
)
)
;
}
NS_IMETHODIMP
nsPK11Token
:
:
GetHasPassword
(
bool
*
hasPassword
)
{
NS_ENSURE_ARG_POINTER
(
hasPassword
)
;
if
(
isAlreadyShutDown
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
hasPassword
=
PK11_NeedLogin
(
mSlot
.
get
(
)
)
&
&
!
PK11_NeedUserInit
(
mSlot
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPK11Token
:
:
NeedsLogin
(
bool
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
isAlreadyShutDown
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
*
_retval
=
PK11_NeedLogin
(
mSlot
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsPK11TokenDB
nsIPK11TokenDB
)
nsPK11TokenDB
:
:
nsPK11TokenDB
(
)
{
}
nsPK11TokenDB
:
:
~
nsPK11TokenDB
(
)
{
if
(
isAlreadyShutDown
(
)
)
{
return
;
}
shutdown
(
ShutdownCalledFrom
:
:
Object
)
;
}
NS_IMETHODIMP
nsPK11TokenDB
:
:
GetInternalKeyToken
(
nsIPK11Token
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
isAlreadyShutDown
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPK11Token
>
token
=
new
nsPK11Token
(
slot
.
get
(
)
)
;
token
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPK11TokenDB
:
:
FindTokenByName
(
const
nsACString
&
tokenName
nsIPK11Token
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
isAlreadyShutDown
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
BlockUntilLoadableRootsLoaded
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
tokenName
.
IsEmpty
(
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
UniquePK11SlotInfo
slot
(
PK11_FindSlotByName
(
PromiseFlatCString
(
tokenName
)
.
get
(
)
)
)
;
if
(
!
slot
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPK11Token
>
token
=
new
nsPK11Token
(
slot
.
get
(
)
)
;
token
.
forget
(
_retval
)
;
return
NS_OK
;
}
