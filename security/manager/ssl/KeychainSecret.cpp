#
include
"
KeychainSecret
.
h
"
#
include
<
Security
/
Security
.
h
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
glean
/
SecurityManagerSslMetrics
.
h
"
#
include
"
nsPrintfCString
.
h
"
using
namespace
mozilla
;
LazyLogModule
gKeychainSecretLog
(
"
keychainsecret
"
)
;
KeychainSecret
:
:
KeychainSecret
(
)
{
}
KeychainSecret
:
:
~
KeychainSecret
(
)
{
}
ScopedCFType
<
CFStringRef
>
MozillaStringToCFString
(
const
nsACString
&
stringIn
)
{
ScopedCFType
<
CFStringRef
>
stringOut
(
CFStringCreateWithBytes
(
nullptr
reinterpret_cast
<
const
UInt8
*
>
(
stringIn
.
BeginReading
(
)
)
stringIn
.
Length
(
)
kCFStringEncodingUTF8
false
)
)
;
return
stringOut
;
}
nsresult
KeychainSecret
:
:
StoreSecret
(
const
nsACString
&
aSecret
const
nsACString
&
aLabel
)
{
nsresult
rv
=
DeleteSecret
(
aLabel
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
DeleteSecret
before
StoreSecret
failed
"
)
)
;
return
rv
;
}
const
CFStringRef
keys
[
]
=
{
kSecClass
kSecAttrAccount
kSecValueData
}
;
ScopedCFType
<
CFStringRef
>
label
(
MozillaStringToCFString
(
aLabel
)
)
;
if
(
!
label
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
MozillaStringToCFString
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
ScopedCFType
<
CFDataRef
>
secret
(
CFDataCreate
(
nullptr
reinterpret_cast
<
const
UInt8
*
>
(
aSecret
.
BeginReading
(
)
)
aSecret
.
Length
(
)
)
)
;
if
(
!
secret
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
CFDataCreate
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
const
void
*
values
[
]
=
{
kSecClassGenericPassword
label
.
get
(
)
secret
.
get
(
)
}
;
static_assert
(
std
:
:
size
(
keys
)
=
=
std
:
:
size
(
values
)
"
mismatched
SecItemAdd
key
/
value
array
sizes
"
)
;
ScopedCFType
<
CFDictionaryRef
>
addDictionary
(
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
keys
(
const
void
*
*
)
&
values
std
:
:
size
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
OSStatus
osrv
=
SecItemAdd
(
addDictionary
.
get
(
)
nullptr
)
;
if
(
osrv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
SecItemAdd
failed
:
%
d
"
osrv
)
)
;
nsPrintfCString
osrvString
(
"
%
d
"
osrv
)
;
mozilla
:
:
glean
:
:
oskeystore
:
:
ReturnCodesExtra
extra
=
{
}
;
extra
.
function
=
Some
(
"
StoreSecret_SecItemAdd
"
_ns
)
;
extra
.
result
=
Some
(
osrvString
)
;
glean
:
:
oskeystore
:
:
return_codes
.
Record
(
Some
(
extra
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
KeychainSecret
:
:
DeleteSecret
(
const
nsACString
&
aLabel
)
{
const
CFStringRef
keys
[
]
=
{
kSecClass
kSecAttrAccount
}
;
ScopedCFType
<
CFStringRef
>
label
(
MozillaStringToCFString
(
aLabel
)
)
;
if
(
!
label
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
MozillaStringToCFString
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
const
void
*
values
[
]
=
{
kSecClassGenericPassword
label
.
get
(
)
}
;
static_assert
(
std
:
:
size
(
keys
)
=
=
std
:
:
size
(
values
)
"
mismatched
SecItemDelete
key
/
value
array
sizes
"
)
;
ScopedCFType
<
CFDictionaryRef
>
deleteDictionary
(
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
keys
(
const
void
*
*
)
&
values
std
:
:
size
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
OSStatus
osrv
=
SecItemDelete
(
deleteDictionary
.
get
(
)
)
;
if
(
osrv
!
=
errSecSuccess
&
&
osrv
!
=
errSecItemNotFound
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
SecItemDelete
failed
:
%
d
"
osrv
)
)
;
mozilla
:
:
glean
:
:
oskeystore
:
:
ReturnCodesExtra
extra
=
{
}
;
extra
.
function
=
Some
(
"
DeleteSecret_SecItemDelete
"
_ns
)
;
nsPrintfCString
osrvString
(
"
%
d
"
osrv
)
;
extra
.
result
=
Some
(
osrvString
)
;
glean
:
:
oskeystore
:
:
return_codes
.
Record
(
Some
(
extra
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
KeychainSecret
:
:
RetrieveSecret
(
const
nsACString
&
aLabel
nsACString
&
aSecret
)
{
const
CFStringRef
keys
[
]
=
{
kSecClass
kSecAttrAccount
kSecMatchLimit
kSecReturnAttributes
kSecReturnData
}
;
ScopedCFType
<
CFStringRef
>
label
(
MozillaStringToCFString
(
aLabel
)
)
;
if
(
!
label
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
MozillaStringToCFString
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
const
void
*
values
[
]
=
{
kSecClassGenericPassword
label
.
get
(
)
kSecMatchLimitOne
kCFBooleanTrue
kCFBooleanTrue
}
;
static_assert
(
std
:
:
size
(
keys
)
=
=
std
:
:
size
(
values
)
"
mismatched
SecItemCopyMatching
key
/
value
array
sizes
"
)
;
ScopedCFType
<
CFDictionaryRef
>
searchDictionary
(
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
keys
(
const
void
*
*
)
&
values
std
:
:
size
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
CFTypeRef
item
;
OSStatus
osrv
=
SecItemCopyMatching
(
searchDictionary
.
get
(
)
&
item
)
;
if
(
osrv
=
=
errSecItemNotFound
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
Key
not
found
in
key
store
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
osrv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
SecItemCopyMatching
failed
:
%
d
"
osrv
)
)
;
mozilla
:
:
glean
:
:
oskeystore
:
:
ReturnCodesExtra
extra
=
{
}
;
extra
.
function
=
Some
(
"
RetrieveSecret_SecItemCopyMatching
"
_ns
)
;
nsPrintfCString
osrvString
(
"
%
d
"
osrv
)
;
extra
.
result
=
Some
(
osrvString
)
;
glean
:
:
oskeystore
:
:
return_codes
.
Record
(
Some
(
extra
)
)
;
return
NS_ERROR_FAILURE
;
}
ScopedCFType
<
CFDictionaryRef
>
dictionary
(
reinterpret_cast
<
CFDictionaryRef
>
(
item
)
)
;
CFDataRef
secret
=
reinterpret_cast
<
CFDataRef
>
(
CFDictionaryGetValue
(
dictionary
.
get
(
)
kSecValueData
)
)
;
if
(
!
secret
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
CFDictionaryGetValue
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
aSecret
.
Assign
(
reinterpret_cast
<
const
char
*
>
(
CFDataGetBytePtr
(
secret
)
)
CFDataGetLength
(
secret
)
)
;
return
NS_OK
;
}
