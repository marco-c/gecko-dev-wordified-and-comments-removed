#
include
"
KeychainSecret
.
h
"
#
include
<
Security
/
Security
.
h
>
#
include
"
mozilla
/
Logging
.
h
"
using
namespace
mozilla
;
LazyLogModule
gKeychainSecretLog
(
"
keychainsecret
"
)
;
KeychainSecret
:
:
KeychainSecret
(
)
{
}
KeychainSecret
:
:
~
KeychainSecret
(
)
{
}
nsresult
KeychainSecret
:
:
Lock
(
)
{
OSStatus
rv
=
SecKeychainLock
(
nullptr
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
SecKeychainLock
failed
:
%
d
"
rv
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
KeychainSecret
:
:
Unlock
(
)
{
OSStatus
rv
=
SecKeychainUnlock
(
nullptr
0
nullptr
false
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
SecKeychainUnlock
failed
:
%
d
"
rv
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
ScopedCFType
<
CFStringRef
>
MozillaStringToCFString
(
const
nsACString
&
stringIn
)
{
ScopedCFType
<
CFStringRef
>
stringOut
(
CFStringCreateWithBytes
(
nullptr
reinterpret_cast
<
const
UInt8
*
>
(
stringIn
.
BeginReading
(
)
)
stringIn
.
Length
(
)
kCFStringEncodingUTF8
false
)
)
;
return
stringOut
;
}
nsresult
KeychainSecret
:
:
StoreSecret
(
const
nsACString
&
aSecret
const
nsACString
&
aLabel
)
{
const
CFStringRef
keys
[
]
=
{
kSecClass
kSecAttrAccount
kSecValueData
}
;
ScopedCFType
<
CFStringRef
>
label
(
MozillaStringToCFString
(
aLabel
)
)
;
if
(
!
label
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
MozillaStringToCFString
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
ScopedCFType
<
CFDataRef
>
secret
(
CFDataCreate
(
nullptr
reinterpret_cast
<
const
UInt8
*
>
(
aSecret
.
BeginReading
(
)
)
aSecret
.
Length
(
)
)
)
;
if
(
!
secret
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
CFDataCreate
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
const
void
*
values
[
]
=
{
kSecClassGenericPassword
label
.
get
(
)
secret
.
get
(
)
}
;
static_assert
(
ArrayLength
(
keys
)
=
=
ArrayLength
(
values
)
"
mismatched
SecItemAdd
key
/
value
array
sizes
"
)
;
ScopedCFType
<
CFDictionaryRef
>
addDictionary
(
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
keys
(
const
void
*
*
)
&
values
ArrayLength
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
OSStatus
osrv
=
SecItemAdd
(
addDictionary
.
get
(
)
nullptr
)
;
if
(
osrv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
SecItemAdd
failed
:
%
d
"
osrv
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
KeychainSecret
:
:
DeleteSecret
(
const
nsACString
&
aLabel
)
{
const
CFStringRef
keys
[
]
=
{
kSecClass
kSecAttrAccount
}
;
ScopedCFType
<
CFStringRef
>
label
(
MozillaStringToCFString
(
aLabel
)
)
;
if
(
!
label
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
MozillaStringToCFString
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
const
void
*
values
[
]
=
{
kSecClassGenericPassword
label
.
get
(
)
}
;
static_assert
(
ArrayLength
(
keys
)
=
=
ArrayLength
(
values
)
"
mismatched
SecItemDelete
key
/
value
array
sizes
"
)
;
ScopedCFType
<
CFDictionaryRef
>
deleteDictionary
(
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
keys
(
const
void
*
*
)
&
values
ArrayLength
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
OSStatus
rv
=
SecItemDelete
(
deleteDictionary
.
get
(
)
)
;
if
(
rv
!
=
errSecSuccess
&
&
rv
!
=
errSecItemNotFound
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
SecItemDelete
failed
:
%
d
"
rv
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
KeychainSecret
:
:
RetrieveSecret
(
const
nsACString
&
aLabel
nsACString
&
aSecret
)
{
const
CFStringRef
keys
[
]
=
{
kSecClass
kSecAttrAccount
kSecMatchLimit
kSecReturnAttributes
kSecReturnData
}
;
ScopedCFType
<
CFStringRef
>
label
(
MozillaStringToCFString
(
aLabel
)
)
;
if
(
!
label
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
MozillaStringToCFString
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
const
void
*
values
[
]
=
{
kSecClassGenericPassword
label
.
get
(
)
kSecMatchLimitOne
kCFBooleanTrue
kCFBooleanTrue
}
;
static_assert
(
ArrayLength
(
keys
)
=
=
ArrayLength
(
values
)
"
mismatched
SecItemCopyMatching
key
/
value
array
sizes
"
)
;
ScopedCFType
<
CFDictionaryRef
>
searchDictionary
(
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
keys
(
const
void
*
*
)
&
values
ArrayLength
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
CFTypeRef
item
;
OSStatus
rv
=
SecItemCopyMatching
(
searchDictionary
.
get
(
)
&
item
)
;
if
(
rv
!
=
errSecSuccess
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
SecItemCopyMatching
failed
:
%
d
"
rv
)
)
;
return
NS_ERROR_FAILURE
;
}
ScopedCFType
<
CFDictionaryRef
>
dictionary
(
reinterpret_cast
<
CFDictionaryRef
>
(
item
)
)
;
CFDataRef
secret
=
reinterpret_cast
<
CFDataRef
>
(
CFDictionaryGetValue
(
dictionary
.
get
(
)
kSecValueData
)
)
;
if
(
!
secret
)
{
MOZ_LOG
(
gKeychainSecretLog
LogLevel
:
:
Debug
(
"
CFDictionaryGetValue
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
aSecret
.
Assign
(
reinterpret_cast
<
const
char
*
>
(
CFDataGetBytePtr
(
secret
)
)
CFDataGetLength
(
secret
)
)
;
return
NS_OK
;
}
