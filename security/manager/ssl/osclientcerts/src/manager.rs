use
pkcs11
:
:
types
:
:
*
;
use
std
:
:
collections
:
:
{
BTreeMap
BTreeSet
}
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Receiver
Sender
}
;
use
std
:
:
thread
;
use
std
:
:
thread
:
:
JoinHandle
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
use
crate
:
:
backend_macos
as
backend
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
use
crate
:
:
backend_windows
as
backend
;
use
backend
:
:
*
;
use
crate
:
:
error
:
:
{
Error
ErrorType
}
;
use
crate
:
:
util
:
:
*
;
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
SlotType
{
Modern
Legacy
}
type
ManagerArgumentsSender
=
Sender
<
ManagerArguments
>
;
type
ManagerReturnValueReceiver
=
Receiver
<
ManagerReturnValue
>
;
enum
ManagerArguments
{
OpenSession
(
SlotType
)
CloseSession
(
CK_SESSION_HANDLE
)
CloseAllSessions
(
SlotType
)
StartSearch
(
CK_SESSION_HANDLE
Vec
<
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
>
)
Search
(
CK_SESSION_HANDLE
usize
)
ClearSearch
(
CK_SESSION_HANDLE
)
GetAttributes
(
CK_OBJECT_HANDLE
Vec
<
CK_ATTRIBUTE_TYPE
>
)
StartSign
(
CK_SESSION_HANDLE
CK_OBJECT_HANDLE
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
GetSignatureLength
(
CK_SESSION_HANDLE
Vec
<
u8
>
)
Sign
(
CK_SESSION_HANDLE
Vec
<
u8
>
)
Stop
}
enum
ManagerReturnValue
{
OpenSession
(
Result
<
CK_SESSION_HANDLE
Error
>
)
CloseSession
(
Result
<
(
)
Error
>
)
CloseAllSessions
(
Result
<
(
)
Error
>
)
StartSearch
(
Result
<
(
)
Error
>
)
Search
(
Result
<
Vec
<
CK_OBJECT_HANDLE
>
Error
>
)
ClearSearch
(
Result
<
(
)
Error
>
)
GetAttributes
(
Result
<
Vec
<
Option
<
Vec
<
u8
>
>
>
Error
>
)
StartSign
(
Result
<
(
)
Error
>
)
GetSignatureLength
(
Result
<
usize
Error
>
)
Sign
(
Result
<
Vec
<
u8
>
Error
>
)
Stop
(
Result
<
(
)
Error
>
)
}
macro_rules
!
manager_proxy_fn_impl
{
(
manager
:
ident
argument_enum
:
expr
return_type
:
path
)
=
>
{
match
manager
.
proxy_call
(
argument_enum
)
{
Ok
(
return_type
(
result
)
)
=
>
result
Ok
(
_
)
=
>
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
;
}
pub
struct
ManagerProxy
{
sender
:
ManagerArgumentsSender
receiver
:
ManagerReturnValueReceiver
thread_handle
:
Option
<
JoinHandle
<
(
)
>
>
}
impl
ManagerProxy
{
pub
fn
new
(
)
-
>
Result
<
ManagerProxy
Error
>
{
let
(
proxy_sender
manager_receiver
)
=
channel
(
)
;
let
(
manager_sender
proxy_receiver
)
=
channel
(
)
;
let
thread_handle
=
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
osclientcert
"
.
into
(
)
)
.
spawn
(
move
|
|
{
let
mut
real_manager
=
Manager
:
:
new
(
)
;
loop
{
let
arguments
=
match
manager_receiver
.
recv
(
)
{
Ok
(
arguments
)
=
>
arguments
Err
(
_
)
=
>
{
break
;
}
}
;
let
results
=
match
arguments
{
ManagerArguments
:
:
OpenSession
(
slot_type
)
=
>
{
ManagerReturnValue
:
:
OpenSession
(
real_manager
.
open_session
(
slot_type
)
)
}
ManagerArguments
:
:
CloseSession
(
session_handle
)
=
>
{
ManagerReturnValue
:
:
CloseSession
(
real_manager
.
close_session
(
session_handle
)
)
}
ManagerArguments
:
:
CloseAllSessions
(
slot_type
)
=
>
{
ManagerReturnValue
:
:
CloseAllSessions
(
real_manager
.
close_all_sessions
(
slot_type
)
)
}
ManagerArguments
:
:
StartSearch
(
session
attrs
)
=
>
{
ManagerReturnValue
:
:
StartSearch
(
real_manager
.
start_search
(
session
&
attrs
)
)
}
ManagerArguments
:
:
Search
(
session
max_objects
)
=
>
{
ManagerReturnValue
:
:
Search
(
real_manager
.
search
(
session
max_objects
)
)
}
ManagerArguments
:
:
ClearSearch
(
session
)
=
>
{
ManagerReturnValue
:
:
ClearSearch
(
real_manager
.
clear_search
(
session
)
)
}
ManagerArguments
:
:
GetAttributes
(
object_handle
attr_types
)
=
>
{
ManagerReturnValue
:
:
GetAttributes
(
real_manager
.
get_attributes
(
object_handle
attr_types
)
)
}
ManagerArguments
:
:
StartSign
(
session
key_handle
params
)
=
>
{
ManagerReturnValue
:
:
StartSign
(
real_manager
.
start_sign
(
session
key_handle
params
)
)
}
ManagerArguments
:
:
GetSignatureLength
(
session
data
)
=
>
{
ManagerReturnValue
:
:
GetSignatureLength
(
real_manager
.
get_signature_length
(
session
&
data
)
)
}
ManagerArguments
:
:
Sign
(
session
data
)
=
>
{
ManagerReturnValue
:
:
Sign
(
real_manager
.
sign
(
session
&
data
)
)
}
ManagerArguments
:
:
Stop
=
>
ManagerReturnValue
:
:
Stop
(
Ok
(
(
)
)
)
}
;
let
stop_after_send
=
match
&
results
{
&
ManagerReturnValue
:
:
Stop
(
_
)
=
>
true
_
=
>
false
}
;
match
manager_sender
.
send
(
results
)
{
Ok
(
(
)
)
=
>
{
}
Err
(
_
)
=
>
{
break
;
}
}
if
stop_after_send
{
break
;
}
}
}
)
;
match
thread_handle
{
Ok
(
thread_handle
)
=
>
Ok
(
ManagerProxy
{
sender
:
proxy_sender
receiver
:
proxy_receiver
thread_handle
:
Some
(
thread_handle
)
}
)
Err
(
_
)
=
>
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
}
}
fn
proxy_call
(
&
self
args
:
ManagerArguments
)
-
>
Result
<
ManagerReturnValue
Error
>
{
match
self
.
sender
.
send
(
args
)
{
Ok
(
(
)
)
=
>
{
}
Err
(
_
)
=
>
{
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
;
}
}
;
let
result
=
match
self
.
receiver
.
recv
(
)
{
Ok
(
result
)
=
>
result
Err
(
_
)
=
>
{
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
;
}
}
;
Ok
(
result
)
}
pub
fn
open_session
(
&
mut
self
slot_type
:
SlotType
)
-
>
Result
<
CK_SESSION_HANDLE
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
OpenSession
(
slot_type
)
ManagerReturnValue
:
:
OpenSession
)
}
pub
fn
close_session
(
&
mut
self
session
:
CK_SESSION_HANDLE
)
-
>
Result
<
(
)
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
CloseSession
(
session
)
ManagerReturnValue
:
:
CloseSession
)
}
pub
fn
close_all_sessions
(
&
mut
self
slot_type
:
SlotType
)
-
>
Result
<
(
)
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
CloseAllSessions
(
slot_type
)
ManagerReturnValue
:
:
CloseAllSessions
)
}
pub
fn
start_search
(
&
mut
self
session
:
CK_SESSION_HANDLE
attrs
:
Vec
<
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
>
)
-
>
Result
<
(
)
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
StartSearch
(
session
attrs
)
ManagerReturnValue
:
:
StartSearch
)
}
pub
fn
search
(
&
mut
self
session
:
CK_SESSION_HANDLE
max_objects
:
usize
)
-
>
Result
<
Vec
<
CK_OBJECT_HANDLE
>
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
Search
(
session
max_objects
)
ManagerReturnValue
:
:
Search
)
}
pub
fn
clear_search
(
&
mut
self
session
:
CK_SESSION_HANDLE
)
-
>
Result
<
(
)
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
ClearSearch
(
session
)
ManagerReturnValue
:
:
ClearSearch
)
}
pub
fn
get_attributes
(
&
self
object_handle
:
CK_OBJECT_HANDLE
attr_types
:
Vec
<
CK_ATTRIBUTE_TYPE
>
)
-
>
Result
<
Vec
<
Option
<
Vec
<
u8
>
>
>
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
GetAttributes
(
object_handle
attr_types
)
ManagerReturnValue
:
:
GetAttributes
)
}
pub
fn
start_sign
(
&
mut
self
session
:
CK_SESSION_HANDLE
key_handle
:
CK_OBJECT_HANDLE
params
:
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
-
>
Result
<
(
)
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
StartSign
(
session
key_handle
params
)
ManagerReturnValue
:
:
StartSign
)
}
pub
fn
get_signature_length
(
&
self
session
:
CK_SESSION_HANDLE
data
:
Vec
<
u8
>
)
-
>
Result
<
usize
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
GetSignatureLength
(
session
data
)
ManagerReturnValue
:
:
GetSignatureLength
)
}
pub
fn
sign
(
&
mut
self
session
:
CK_SESSION_HANDLE
data
:
Vec
<
u8
>
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
Sign
(
session
data
)
ManagerReturnValue
:
:
Sign
)
}
pub
fn
stop
(
&
mut
self
)
-
>
Result
<
(
)
Error
>
{
manager_proxy_fn_impl
!
(
self
ManagerArguments
:
:
Stop
ManagerReturnValue
:
:
Stop
)
?
;
let
thread_handle
=
match
self
.
thread_handle
.
take
(
)
{
Some
(
thread_handle
)
=
>
thread_handle
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
}
;
thread_handle
.
join
(
)
.
map_err
(
|
_
|
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
}
}
fn
search_is_for_all_certificates_or_keys
(
attrs
:
&
[
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
]
)
-
>
Result
<
bool
Error
>
{
if
attrs
.
len
(
)
!
=
2
{
return
Ok
(
false
)
;
}
let
token_bytes
=
vec
!
[
1
as
u8
]
;
let
mut
found_token
=
false
;
let
cko_certificate_bytes
=
serialize_uint
(
CKO_CERTIFICATE
)
?
;
let
cko_private_key_bytes
=
serialize_uint
(
CKO_PRIVATE_KEY
)
?
;
let
mut
found_certificate_or_private_key
=
false
;
for
(
attr_type
attr_value
)
in
attrs
.
iter
(
)
{
if
attr_type
=
=
&
CKA_TOKEN
&
&
attr_value
=
=
&
token_bytes
{
found_token
=
true
;
}
if
attr_type
=
=
&
CKA_CLASS
&
&
(
attr_value
=
=
&
cko_certificate_bytes
|
|
attr_value
=
=
&
cko_private_key_bytes
)
{
found_certificate_or_private_key
=
true
;
}
}
Ok
(
found_token
&
&
found_certificate_or_private_key
)
}
struct
Manager
{
sessions
:
BTreeMap
<
CK_SESSION_HANDLE
SlotType
>
searches
:
BTreeMap
<
CK_SESSION_HANDLE
Vec
<
CK_OBJECT_HANDLE
>
>
signs
:
BTreeMap
<
CK_SESSION_HANDLE
(
CK_OBJECT_HANDLE
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
>
objects
:
BTreeMap
<
CK_OBJECT_HANDLE
Object
>
cert_ids
:
BTreeSet
<
Vec
<
u8
>
>
key_ids
:
BTreeSet
<
Vec
<
u8
>
>
next_session
:
CK_SESSION_HANDLE
next_handle
:
CK_OBJECT_HANDLE
last_scan_time
:
Option
<
Instant
>
}
impl
Manager
{
pub
fn
new
(
)
-
>
Manager
{
Manager
{
sessions
:
BTreeMap
:
:
new
(
)
searches
:
BTreeMap
:
:
new
(
)
signs
:
BTreeMap
:
:
new
(
)
objects
:
BTreeMap
:
:
new
(
)
cert_ids
:
BTreeSet
:
:
new
(
)
key_ids
:
BTreeSet
:
:
new
(
)
next_session
:
1
next_handle
:
1
last_scan_time
:
None
}
}
fn
maybe_find_new_objects
(
&
mut
self
)
{
let
now
=
Instant
:
:
now
(
)
;
match
self
.
last_scan_time
{
Some
(
last_scan_time
)
=
>
{
if
now
.
duration_since
(
last_scan_time
)
<
Duration
:
:
new
(
3
0
)
{
return
;
}
}
None
=
>
{
}
}
self
.
last_scan_time
=
Some
(
now
)
;
let
objects
=
list_objects
(
)
;
for
object
in
objects
{
match
&
object
{
Object
:
:
Cert
(
cert
)
=
>
{
if
self
.
cert_ids
.
contains
(
cert
.
id
(
)
)
{
continue
;
}
self
.
cert_ids
.
insert
(
cert
.
id
(
)
.
to_vec
(
)
)
;
let
handle
=
self
.
get_next_handle
(
)
;
self
.
objects
.
insert
(
handle
object
)
;
}
Object
:
:
Key
(
key
)
=
>
{
if
self
.
key_ids
.
contains
(
key
.
id
(
)
)
{
continue
;
}
self
.
key_ids
.
insert
(
key
.
id
(
)
.
to_vec
(
)
)
;
let
handle
=
self
.
get_next_handle
(
)
;
self
.
objects
.
insert
(
handle
object
)
;
}
}
}
}
pub
fn
open_session
(
&
mut
self
slot_type
:
SlotType
)
-
>
Result
<
CK_SESSION_HANDLE
Error
>
{
let
next_session
=
self
.
next_session
;
self
.
next_session
+
=
1
;
self
.
sessions
.
insert
(
next_session
slot_type
)
;
Ok
(
next_session
)
}
pub
fn
close_session
(
&
mut
self
session
:
CK_SESSION_HANDLE
)
-
>
Result
<
(
)
Error
>
{
self
.
sessions
.
remove
(
&
session
)
.
ok_or
(
error_here
!
(
ErrorType
:
:
InvalidInput
)
)
.
map
(
|
_
|
(
)
)
}
pub
fn
close_all_sessions
(
&
mut
self
slot_type
:
SlotType
)
-
>
Result
<
(
)
Error
>
{
let
mut
to_remove
=
Vec
:
:
new
(
)
;
for
(
session
open_slot_type
)
in
self
.
sessions
.
iter
(
)
{
if
slot_type
=
=
*
open_slot_type
{
to_remove
.
push
(
*
session
)
;
}
}
for
session
in
to_remove
{
if
self
.
sessions
.
remove
(
&
session
)
.
is_none
(
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
;
}
}
Ok
(
(
)
)
}
fn
get_next_handle
(
&
mut
self
)
-
>
CK_OBJECT_HANDLE
{
let
next_handle
=
self
.
next_handle
;
self
.
next_handle
+
=
1
;
next_handle
}
pub
fn
start_search
(
&
mut
self
session
:
CK_SESSION_HANDLE
attrs
:
&
[
(
CK_ATTRIBUTE_TYPE
Vec
<
u8
>
)
]
)
-
>
Result
<
(
)
Error
>
{
let
slot_type
=
match
self
.
sessions
.
get
(
&
session
)
{
Some
(
slot_type
)
=
>
*
slot_type
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
for
(
attr
_
)
in
attrs
{
if
!
SUPPORTED_ATTRIBUTES
.
contains
(
attr
)
{
self
.
searches
.
insert
(
session
Vec
:
:
new
(
)
)
;
return
Ok
(
(
)
)
;
}
}
if
search_is_for_all_certificates_or_keys
(
attrs
)
?
{
self
.
maybe_find_new_objects
(
)
;
}
let
mut
handles
=
Vec
:
:
new
(
)
;
for
(
handle
object
)
in
&
self
.
objects
{
if
object
.
matches
(
slot_type
attrs
)
{
handles
.
push
(
*
handle
)
;
}
}
self
.
searches
.
insert
(
session
handles
)
;
Ok
(
(
)
)
}
pub
fn
search
(
&
mut
self
session
:
CK_SESSION_HANDLE
max_objects
:
usize
)
-
>
Result
<
Vec
<
CK_OBJECT_HANDLE
>
Error
>
{
if
max_objects
=
=
0
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
;
}
match
self
.
searches
.
get_mut
(
&
session
)
{
Some
(
search
)
=
>
{
let
split_at
=
if
max_objects
>
=
search
.
len
(
)
{
0
}
else
{
search
.
len
(
)
-
max_objects
}
;
let
to_return
=
search
.
split_off
(
split_at
)
;
if
to_return
.
len
(
)
>
max_objects
{
return
Err
(
error_here
!
(
ErrorType
:
:
LibraryFailure
)
)
;
}
Ok
(
to_return
)
}
None
=
>
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
}
pub
fn
clear_search
(
&
mut
self
session
:
CK_SESSION_HANDLE
)
-
>
Result
<
(
)
Error
>
{
self
.
searches
.
remove
(
&
session
)
;
Ok
(
(
)
)
}
pub
fn
get_attributes
(
&
self
object_handle
:
CK_OBJECT_HANDLE
attr_types
:
Vec
<
CK_ATTRIBUTE_TYPE
>
)
-
>
Result
<
Vec
<
Option
<
Vec
<
u8
>
>
>
Error
>
{
let
object
=
match
self
.
objects
.
get
(
&
object_handle
)
{
Some
(
object
)
=
>
object
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
let
mut
results
=
Vec
:
:
with_capacity
(
attr_types
.
len
(
)
)
;
for
attr_type
in
attr_types
{
let
result
=
match
object
.
get_attribute
(
attr_type
)
{
Some
(
value
)
=
>
Some
(
value
.
to_owned
(
)
)
None
=
>
None
}
;
results
.
push
(
result
)
;
}
Ok
(
results
)
}
pub
fn
start_sign
(
&
mut
self
session
:
CK_SESSION_HANDLE
key_handle
:
CK_OBJECT_HANDLE
params
:
Option
<
CK_RSA_PKCS_PSS_PARAMS
>
)
-
>
Result
<
(
)
Error
>
{
if
self
.
signs
.
contains_key
(
&
session
)
{
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
;
}
match
self
.
objects
.
get
(
&
key_handle
)
{
Some
(
Object
:
:
Key
(
_
)
)
=
>
{
}
_
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
self
.
signs
.
insert
(
session
(
key_handle
params
)
)
;
Ok
(
(
)
)
}
pub
fn
get_signature_length
(
&
mut
self
session
:
CK_SESSION_HANDLE
data
:
&
[
u8
]
)
-
>
Result
<
usize
Error
>
{
let
(
key_handle
params
)
=
match
self
.
signs
.
get
(
&
session
)
{
Some
(
(
key_handle
params
)
)
=
>
(
key_handle
params
)
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
let
key
=
match
self
.
objects
.
get_mut
(
&
key_handle
)
{
Some
(
Object
:
:
Key
(
key
)
)
=
>
key
_
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
key
.
get_signature_length
(
data
params
)
}
pub
fn
sign
(
&
mut
self
session
:
CK_SESSION_HANDLE
data
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
let
(
key_handle
params
)
=
match
self
.
signs
.
remove
(
&
session
)
{
Some
(
(
key_handle
params
)
)
=
>
(
key_handle
params
)
None
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
let
key
=
match
self
.
objects
.
get_mut
(
&
key_handle
)
{
Some
(
Object
:
:
Key
(
key
)
)
=
>
key
_
=
>
return
Err
(
error_here
!
(
ErrorType
:
:
InvalidArgument
)
)
}
;
key
.
sign
(
data
&
params
)
}
}
