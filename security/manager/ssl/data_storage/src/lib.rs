extern
crate
byteorder
;
#
[
macro_use
]
extern
crate
cstr
;
extern
crate
firefox_on_glean
;
#
[
macro_use
]
extern
crate
log
;
#
[
macro_use
]
extern
crate
malloc_size_of_derive
;
extern
crate
moz_task
;
extern
crate
nserror
;
extern
crate
thin_vec
;
extern
crate
wr_malloc_size_of
;
#
[
macro_use
]
extern
crate
xpcom
;
use
wr_malloc_size_of
as
malloc_size_of
;
use
byteorder
:
:
{
BigEndian
ReadBytesExt
WriteBytesExt
}
;
use
firefox_on_glean
:
:
metrics
:
:
data_storage
;
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
}
;
use
moz_task
:
:
{
create_background_task_queue
RunnableBuilder
}
;
use
nserror
:
:
{
nsresult
NS_ERROR_FAILURE
NS_ERROR_ILLEGAL_INPUT
NS_ERROR_INVALID_ARG
NS_ERROR_NOT_AVAILABLE
NS_OK
}
;
use
nsstring
:
:
{
nsACString
nsAString
nsCStr
nsCString
nsString
}
;
use
thin_vec
:
:
ThinVec
;
use
xpcom
:
:
interfaces
:
:
{
nsIDataStorage
nsIDataStorageItem
nsIFile
nsIHandleReportCallback
nsIMemoryReporter
nsIMemoryReporterManager
nsIObserverService
nsIProperties
nsISerialEventTarget
nsISupports
}
;
use
xpcom
:
:
{
xpcom_method
RefPtr
XpCom
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
fs
:
:
{
File
OpenOptions
}
;
use
std
:
:
io
:
:
{
BufRead
BufReader
ErrorKind
Read
Seek
SeekFrom
Write
}
;
use
std
:
:
os
:
:
raw
:
:
{
c_char
c_void
}
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
sync
:
:
{
Condvar
Mutex
}
;
use
std
:
:
time
:
:
{
Duration
SystemTime
UNIX_EPOCH
}
;
#
[
derive
(
Copy
Clone
Eq
PartialEq
)
]
enum
DataType
{
Persistent
Private
Temporary
}
impl
From
<
u8
>
for
DataType
{
fn
from
(
value
:
u8
)
-
>
Self
{
match
value
{
nsIDataStorage
:
:
Persistent
=
>
DataType
:
:
Persistent
nsIDataStorage
:
:
Private
=
>
DataType
:
:
Private
nsIDataStorage
:
:
Temporary
=
>
DataType
:
:
Temporary
_
=
>
panic
!
(
"
invalid
nsIDataStorage
:
:
DataType
"
)
}
}
}
impl
From
<
DataType
>
for
u8
{
fn
from
(
value
:
DataType
)
-
>
Self
{
match
value
{
DataType
:
:
Persistent
=
>
nsIDataStorage
:
:
Persistent
DataType
:
:
Private
=
>
nsIDataStorage
:
:
Private
DataType
:
:
Temporary
=
>
nsIDataStorage
:
:
Temporary
}
}
}
fn
now_in_days
(
)
-
>
u16
{
const
SECONDS_PER_DAY
:
u64
=
60
*
60
*
24
;
let
now
=
SystemTime
:
:
now
(
)
.
duration_since
(
UNIX_EPOCH
)
.
unwrap_or
(
Duration
:
:
ZERO
)
;
(
now
.
as_secs
(
)
/
SECONDS_PER_DAY
)
.
try_into
(
)
.
unwrap_or
(
u16
:
:
MAX
)
}
#
[
derive
(
Clone
MallocSizeOf
)
]
struct
Entry
{
score
:
u16
last_accessed
:
u16
key
:
Vec
<
u8
>
value
:
Vec
<
u8
>
slot_index
:
usize
}
impl
Entry
{
fn
from_old_line
(
line
:
&
str
slot_index
:
usize
value_length
:
usize
)
-
>
Result
<
Self
nsresult
>
{
let
parts
:
Vec
<
&
str
>
=
line
.
split
(
'
\
t
'
)
.
collect
(
)
;
if
parts
.
len
(
)
!
=
4
{
return
Err
(
NS_ERROR_ILLEGAL_INPUT
)
;
}
let
score
=
parts
[
1
]
.
parse
:
:
<
u16
>
(
)
.
map_err
(
|
_
|
NS_ERROR_ILLEGAL_INPUT
)
?
;
let
last_accessed
=
parts
[
2
]
.
parse
:
:
<
u16
>
(
)
.
map_err
(
|
_
|
NS_ERROR_ILLEGAL_INPUT
)
?
;
let
key
=
Vec
:
:
from
(
parts
[
0
]
)
;
if
key
.
len
(
)
>
KEY_LENGTH
{
return
Err
(
NS_ERROR_ILLEGAL_INPUT
)
;
}
let
value
=
Vec
:
:
from
(
parts
[
3
]
)
;
if
value
.
len
(
)
>
value_length
{
return
Err
(
NS_ERROR_ILLEGAL_INPUT
)
;
}
Ok
(
Entry
{
score
last_accessed
key
value
slot_index
}
)
}
fn
from_slot
(
score
:
u16
last_accessed
:
u16
key
:
Vec
<
u8
>
value
:
Vec
<
u8
>
slot_index
:
usize
)
-
>
Self
{
Entry
{
score
last_accessed
key
value
slot_index
}
}
fn
new
(
key
:
Vec
<
u8
>
value
:
Vec
<
u8
>
slot_index
:
usize
)
-
>
Self
{
Entry
{
score
:
1
last_accessed
:
now_in_days
(
)
key
value
slot_index
}
}
fn
new_empty
(
slot_index
:
usize
)
-
>
Self
{
Entry
{
score
:
0
last_accessed
:
0
key
:
Vec
:
:
new
(
)
value
:
Vec
:
:
new
(
)
slot_index
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
score
=
=
0
&
&
self
.
last_accessed
=
=
0
&
&
self
.
key
.
is_empty
(
)
&
&
self
.
value
.
is_empty
(
)
}
fn
update_score
(
&
mut
self
)
-
>
bool
{
let
now_in_days
=
now_in_days
(
)
;
if
self
.
last_accessed
!
=
now_in_days
{
self
.
last_accessed
=
now_in_days
;
self
.
score
+
=
1
;
true
}
else
{
false
}
}
fn
clear
(
&
mut
self
)
{
*
self
=
Self
:
:
new_empty
(
self
.
slot_index
)
;
}
}
fn
strip_zeroes
(
vec
:
&
mut
Vec
<
u8
>
)
{
let
mut
length
=
vec
.
len
(
)
;
while
length
>
0
&
&
vec
[
length
-
1
]
=
=
0
{
length
-
=
1
;
}
vec
.
truncate
(
length
)
;
}
fn
get_entries_with_minimum_score
(
entries
:
&
[
Entry
]
)
-
>
Vec
<
&
Entry
>
{
let
mut
min_score
=
u16
:
:
MAX
;
let
mut
min_score_entries
=
Vec
:
:
new
(
)
;
for
entry
in
entries
.
iter
(
)
{
if
entry
.
score
<
min_score
{
min_score
=
entry
.
score
;
min_score_entries
.
clear
(
)
;
}
if
entry
.
score
=
=
min_score
{
min_score_entries
.
push
(
entry
)
;
}
}
min_score_entries
}
const
MAX_SLOTS
:
usize
=
2048
;
const
KEY_LENGTH
:
usize
=
256
;
type
DataStorageTable
=
HashMap
<
Vec
<
u8
>
usize
>
;
#
[
derive
(
MallocSizeOf
)
]
struct
DataStorageInner
{
persistent_table
:
DataStorageTable
persistent_slots
:
Vec
<
Entry
>
private_table
:
DataStorageTable
private_slots
:
Vec
<
Entry
>
temporary_table
:
DataStorageTable
temporary_slots
:
Vec
<
Entry
>
name
:
String
value_length
:
usize
maybe_profile_path
:
Option
<
PathBuf
>
#
[
ignore_malloc_size_of
=
"
not
implemented
for
nsISerialEventTarget
"
]
write_queue
:
Option
<
RefPtr
<
nsISerialEventTarget
>
>
}
impl
DataStorageInner
{
fn
new
(
name
:
String
value_length
:
usize
maybe_profile_path
:
Option
<
PathBuf
>
)
-
>
Result
<
Self
nsresult
>
{
Ok
(
DataStorageInner
{
persistent_table
:
DataStorageTable
:
:
new
(
)
persistent_slots
:
Vec
:
:
new
(
)
private_table
:
DataStorageTable
:
:
new
(
)
private_slots
:
Vec
:
:
new
(
)
temporary_table
:
DataStorageTable
:
:
new
(
)
temporary_slots
:
Vec
:
:
new
(
)
name
value_length
maybe_profile_path
write_queue
:
Some
(
create_background_task_queue
(
cstr
!
(
"
data_storage
"
)
)
?
)
}
)
}
fn
initialize
(
&
mut
self
)
-
>
Result
<
(
)
nsresult
>
{
let
Some
(
profile_path
)
=
self
.
maybe_profile_path
.
as_ref
(
)
else
{
return
Ok
(
(
)
)
;
}
;
let
mut
backing_path
=
profile_path
.
clone
(
)
;
backing_path
.
push
(
format
!
(
"
{
}
.
bin
"
&
self
.
name
)
)
;
let
mut
old_backing_path
=
profile_path
.
clone
(
)
;
old_backing_path
.
push
(
format
!
(
"
{
}
.
txt
"
&
self
.
name
)
)
;
if
backing_path
.
exists
(
)
{
self
.
read
(
backing_path
)
}
else
if
old_backing_path
.
exists
(
)
{
self
.
read_old_format
(
old_backing_path
)
}
else
{
Ok
(
(
)
)
}
}
fn
read
(
&
mut
self
path
:
PathBuf
)
-
>
Result
<
(
)
nsresult
>
{
let
f
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
path
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
mut
backing_file
=
BufReader
:
:
new
(
f
)
;
let
mut
slots
=
Vec
:
:
new
(
)
;
while
slots
.
len
(
)
<
MAX_SLOTS
{
if
let
Some
(
entry
)
=
self
.
process_slot
(
&
mut
backing_file
slots
.
len
(
)
)
?
{
slots
.
push
(
entry
)
;
}
else
{
break
;
}
}
self
.
persistent_slots
=
slots
;
self
.
persistent_table
=
self
.
persistent_slots
.
iter
(
)
.
filter
(
|
slot
|
!
slot
.
is_empty
(
)
)
.
map
(
|
slot
|
(
slot
.
key
.
clone
(
)
slot
.
slot_index
)
)
.
collect
(
)
;
let
num_entries
=
self
.
persistent_table
.
len
(
)
as
i64
;
match
self
.
name
.
as_str
(
)
{
"
AlternateServices
"
=
>
data_storage
:
:
alternate_services
.
set
(
num_entries
)
"
ClientAuthRememberList
"
=
>
data_storage
:
:
client_auth_remember_list
.
set
(
num_entries
)
"
SiteSecurityServiceState
"
=
>
{
data_storage
:
:
site_security_service_state
.
set
(
num_entries
)
}
_
=
>
panic
!
(
"
unknown
nsIDataStorageManager
:
:
DataStorage
"
)
}
Ok
(
(
)
)
}
fn
process_slot
<
R
:
Read
>
(
&
mut
self
reader
:
&
mut
R
slot_index
:
usize
)
-
>
Result
<
Option
<
Entry
>
nsresult
>
{
let
mut
checksum
=
match
reader
.
read_u16
:
:
<
BigEndian
>
(
)
{
Ok
(
checksum
)
=
>
checksum
Err
(
e
)
if
e
.
kind
(
)
=
=
ErrorKind
:
:
UnexpectedEof
=
>
return
Ok
(
None
)
Err
(
_
)
=
>
return
Err
(
NS_ERROR_FAILURE
)
}
;
let
score
=
reader
.
read_u16
:
:
<
BigEndian
>
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
checksum
^
=
score
;
let
last_accessed
=
reader
.
read_u16
:
:
<
BigEndian
>
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
checksum
^
=
last_accessed
;
let
mut
key
=
vec
!
[
0u8
;
KEY_LENGTH
]
;
reader
.
read_exact
(
&
mut
key
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
for
mut
chunk
in
key
.
chunks
(
2
)
{
checksum
^
=
chunk
.
read_u16
:
:
<
BigEndian
>
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
}
strip_zeroes
(
&
mut
key
)
;
let
mut
value
=
vec
!
[
0u8
;
self
.
value_length
]
;
reader
.
read_exact
(
&
mut
value
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
for
mut
chunk
in
value
.
chunks
(
2
)
{
checksum
^
=
chunk
.
read_u16
:
:
<
BigEndian
>
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
}
strip_zeroes
(
&
mut
value
)
;
if
checksum
!
=
0
|
|
score
=
=
0
|
|
last_accessed
=
=
0
{
return
Ok
(
Some
(
Entry
:
:
new_empty
(
slot_index
)
)
)
;
}
Ok
(
Some
(
Entry
:
:
from_slot
(
score
last_accessed
key
value
slot_index
)
)
)
}
fn
read_old_format
(
&
mut
self
path
:
PathBuf
)
-
>
Result
<
(
)
nsresult
>
{
let
file
=
File
:
:
open
(
path
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
reader
=
BufReader
:
:
new
(
file
)
;
for
line
in
reader
.
lines
(
)
.
flatten
(
)
.
take
(
1024
)
{
match
Entry
:
:
from_old_line
(
&
line
self
.
persistent_slots
.
len
(
)
self
.
value_length
)
{
Ok
(
entry
)
=
>
{
if
self
.
persistent_slots
.
len
(
)
>
=
MAX_SLOTS
{
warn
!
(
"
too
many
lines
in
old
DataStorage
format
"
)
;
break
;
}
if
!
entry
.
is_empty
(
)
{
self
.
persistent_slots
.
push
(
entry
)
;
}
else
{
warn
!
(
"
empty
entry
in
old
DataStorage
format
?
"
)
;
}
}
Err
(
_
)
=
>
{
warn
!
(
"
failed
to
migrate
a
line
from
old
DataStorage
format
"
)
;
}
}
}
self
.
persistent_table
=
self
.
persistent_slots
.
iter
(
)
.
filter
(
|
slot
|
!
slot
.
is_empty
(
)
)
.
map
(
|
slot
|
(
slot
.
key
.
clone
(
)
slot
.
slot_index
)
)
.
collect
(
)
;
self
.
async_write_entries
(
self
.
persistent_slots
.
clone
(
)
)
?
;
let
num_entries
=
self
.
persistent_table
.
len
(
)
as
i64
;
match
self
.
name
.
as_str
(
)
{
"
AlternateServices
"
=
>
data_storage
:
:
alternate_services
.
set
(
num_entries
)
"
ClientAuthRememberList
"
=
>
data_storage
:
:
client_auth_remember_list
.
set
(
num_entries
)
"
SiteSecurityServiceState
"
=
>
{
data_storage
:
:
site_security_service_state
.
set
(
num_entries
)
}
_
=
>
panic
!
(
"
unknown
nsIDataStorageManager
:
:
DataStorage
"
)
}
Ok
(
(
)
)
}
fn
put_internal
(
&
mut
self
entry
:
Entry
type_
:
DataType
)
-
>
Result
<
(
)
nsresult
>
{
let
(
table
slots
)
=
self
.
get_table_and_slots_for_type_mut
(
type_
)
;
if
entry
.
slot_index
<
slots
.
len
(
)
{
let
entry_to_evict
=
&
slots
[
entry
.
slot_index
]
;
if
!
entry_to_evict
.
is_empty
(
)
{
table
.
remove
(
&
entry_to_evict
.
key
)
;
}
}
let
_
=
table
.
insert
(
entry
.
key
.
clone
(
)
entry
.
slot_index
)
;
if
entry
.
slot_index
<
slots
.
len
(
)
{
slots
[
entry
.
slot_index
]
=
entry
.
clone
(
)
;
}
else
if
entry
.
slot_index
=
=
slots
.
len
(
)
{
slots
.
push
(
entry
.
clone
(
)
)
;
}
else
{
panic
!
(
"
put_internal
should
not
have
been
given
an
Entry
with
slot_index
>
slots
.
len
(
)
"
)
;
}
if
type_
=
=
DataType
:
:
Persistent
{
self
.
async_write_entry
(
entry
)
?
;
}
Ok
(
(
)
)
}
fn
slot_length
(
&
self
)
-
>
usize
{
2
+
2
+
2
+
KEY_LENGTH
+
self
.
value_length
}
fn
get_free_slot_or_slot_to_evict
(
&
self
type_
:
DataType
)
-
>
usize
{
let
(
_
slots
)
=
self
.
get_table_and_slots_for_type
(
type_
)
;
let
maybe_unoccupied_slot
=
slots
.
iter
(
)
.
enumerate
(
)
.
find
(
|
(
_
maybe_empty_entry
)
|
maybe_empty_entry
.
is_empty
(
)
)
;
if
let
Some
(
(
unoccupied_slot
_
)
)
=
maybe_unoccupied_slot
{
return
unoccupied_slot
;
}
if
slots
.
len
(
)
<
MAX_SLOTS
{
return
slots
.
len
(
)
;
}
let
min_score_entries
=
get_entries_with_minimum_score
(
&
slots
)
;
let
min_score_entry
=
min_score_entries
.
iter
(
)
.
min_by_key
(
|
e
|
e
.
last_accessed
)
.
unwrap
(
)
;
min_score_entry
.
slot_index
}
fn
get_table_and_slots_for_type
(
&
self
type_
:
DataType
)
-
>
(
&
DataStorageTable
&
[
Entry
]
)
{
match
type_
{
DataType
:
:
Persistent
=
>
(
&
self
.
persistent_table
&
self
.
persistent_slots
)
DataType
:
:
Private
=
>
(
&
self
.
private_table
&
self
.
private_slots
)
DataType
:
:
Temporary
=
>
(
&
self
.
temporary_table
&
self
.
temporary_slots
)
}
}
fn
get_table_and_slots_for_type_mut
(
&
mut
self
type_
:
DataType
)
-
>
(
&
mut
DataStorageTable
&
mut
Vec
<
Entry
>
)
{
match
type_
{
DataType
:
:
Persistent
=
>
(
&
mut
self
.
persistent_table
&
mut
self
.
persistent_slots
)
DataType
:
:
Private
=
>
(
&
mut
self
.
private_table
&
mut
self
.
private_slots
)
DataType
:
:
Temporary
=
>
(
&
mut
self
.
temporary_table
&
mut
self
.
temporary_slots
)
}
}
fn
get_entry
(
&
mut
self
key
:
&
[
u8
]
type_
:
DataType
)
-
>
Option
<
&
mut
Entry
>
{
let
(
table
slots
)
=
self
.
get_table_and_slots_for_type_mut
(
type_
)
;
let
slot_index
=
table
.
get
(
key
)
?
;
Some
(
&
mut
slots
[
*
slot_index
]
)
}
fn
get
(
&
mut
self
key
:
&
[
u8
]
type_
:
DataType
)
-
>
Result
<
Vec
<
u8
>
nsresult
>
{
let
Some
(
entry
)
=
self
.
get_entry
(
key
type_
)
else
{
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
;
let
value
=
entry
.
value
.
clone
(
)
;
if
entry
.
update_score
(
)
&
&
type_
=
=
DataType
:
:
Persistent
{
let
entry
=
entry
.
clone
(
)
;
self
.
async_write_entry
(
entry
)
?
;
}
Ok
(
value
)
}
fn
put
(
&
mut
self
key
:
Vec
<
u8
>
value
:
Vec
<
u8
>
type_
:
DataType
)
-
>
Result
<
(
)
nsresult
>
{
if
key
.
len
(
)
>
KEY_LENGTH
|
|
value
.
len
(
)
>
self
.
value_length
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
if
let
Some
(
existing_entry
)
=
self
.
get_entry
(
&
key
type_
)
{
let
data_changed
=
existing_entry
.
value
!
=
value
;
if
data_changed
{
existing_entry
.
value
=
value
;
}
if
(
existing_entry
.
update_score
(
)
|
|
data_changed
)
&
&
type_
=
=
DataType
:
:
Persistent
{
let
entry
=
existing_entry
.
clone
(
)
;
self
.
async_write_entry
(
entry
)
?
;
}
Ok
(
(
)
)
}
else
{
let
slot_index
=
self
.
get_free_slot_or_slot_to_evict
(
type_
)
;
let
entry
=
Entry
:
:
new
(
key
.
clone
(
)
value
slot_index
)
;
self
.
put_internal
(
entry
type_
)
}
}
fn
remove
(
&
mut
self
key
:
&
Vec
<
u8
>
type_
:
DataType
)
-
>
Result
<
(
)
nsresult
>
{
let
(
table
slots
)
=
self
.
get_table_and_slots_for_type_mut
(
type_
)
;
let
Some
(
slot_index
)
=
table
.
remove
(
key
)
else
{
return
Ok
(
(
)
)
;
}
;
let
entry
=
&
mut
slots
[
slot_index
]
;
entry
.
clear
(
)
;
if
type_
=
=
DataType
:
:
Persistent
{
let
entry
=
entry
.
clone
(
)
;
self
.
async_write_entry
(
entry
)
?
;
}
Ok
(
(
)
)
}
fn
clear
(
&
mut
self
)
-
>
Result
<
(
)
nsresult
>
{
self
.
persistent_table
.
clear
(
)
;
self
.
private_table
.
clear
(
)
;
self
.
temporary_table
.
clear
(
)
;
self
.
persistent_slots
.
clear
(
)
;
self
.
private_slots
.
clear
(
)
;
self
.
temporary_slots
.
clear
(
)
;
let
Some
(
profile_path
)
=
self
.
maybe_profile_path
.
clone
(
)
else
{
return
Ok
(
(
)
)
;
}
;
let
Some
(
write_queue
)
=
self
.
write_queue
.
clone
(
)
else
{
return
Ok
(
(
)
)
;
}
;
let
name
=
self
.
name
.
clone
(
)
;
RunnableBuilder
:
:
new
(
"
data_storage
:
:
remove_backing_files
"
move
|
|
{
let
old_backing_path
=
profile_path
.
join
(
format
!
(
"
{
name
}
.
txt
"
)
)
;
let
_
=
std
:
:
fs
:
:
remove_file
(
old_backing_path
)
;
let
backing_path
=
profile_path
.
join
(
format
!
(
"
{
name
}
.
bin
"
)
)
;
let
_
=
std
:
:
fs
:
:
remove_file
(
backing_path
)
;
}
)
.
may_block
(
true
)
.
dispatch
(
write_queue
.
coerce
(
)
)
}
fn
clear_private_data
(
&
mut
self
)
{
self
.
private_table
.
clear
(
)
;
self
.
private_slots
.
clear
(
)
;
}
fn
async_write_entry
(
&
self
entry
:
Entry
)
-
>
Result
<
(
)
nsresult
>
{
self
.
async_write_entries
(
vec
!
[
entry
]
)
}
fn
async_write_entries
(
&
self
entries
:
Vec
<
Entry
>
)
-
>
Result
<
(
)
nsresult
>
{
let
Some
(
mut
backing_path
)
=
self
.
maybe_profile_path
.
clone
(
)
else
{
return
Ok
(
(
)
)
;
}
;
let
Some
(
write_queue
)
=
self
.
write_queue
.
clone
(
)
else
{
return
Ok
(
(
)
)
;
}
;
backing_path
.
push
(
format
!
(
"
{
}
.
bin
"
&
self
.
name
)
)
;
let
value_length
=
self
.
value_length
;
let
slot_length
=
self
.
slot_length
(
)
;
RunnableBuilder
:
:
new
(
"
data_storage
:
:
write_entries
"
move
|
|
{
let
_
=
write_entries
(
entries
backing_path
value_length
slot_length
)
;
}
)
.
may_block
(
true
)
.
dispatch
(
write_queue
.
coerce
(
)
)
}
fn
drop_write_queue
(
&
mut
self
)
{
let
_
=
self
.
write_queue
.
take
(
)
;
}
fn
for_each
<
F
>
(
&
self
mut
f
:
F
)
where
F
:
FnMut
(
&
Entry
DataType
)
{
for
entry
in
self
.
persistent_slots
.
iter
(
)
.
filter
(
|
entry
|
!
entry
.
is_empty
(
)
)
{
f
(
entry
DataType
:
:
Persistent
)
;
}
for
entry
in
self
.
private_slots
.
iter
(
)
.
filter
(
|
entry
|
!
entry
.
is_empty
(
)
)
{
f
(
entry
DataType
:
:
Private
)
;
}
for
entry
in
self
.
temporary_slots
.
iter
(
)
.
filter
(
|
entry
|
!
entry
.
is_empty
(
)
)
{
f
(
entry
DataType
:
:
Temporary
)
;
}
}
fn
collect_reports
(
&
self
ops
:
&
mut
MallocSizeOfOps
callback
:
&
nsIHandleReportCallback
data
:
Option
<
&
nsISupports
>
)
-
>
Result
<
(
)
nsresult
>
{
let
size
=
self
.
size_of
(
ops
)
;
let
data
=
match
data
{
Some
(
data
)
=
>
data
as
*
const
nsISupports
None
=
>
std
:
:
ptr
:
:
null
(
)
as
*
const
nsISupports
}
;
unsafe
{
callback
.
Callback
(
&
nsCStr
:
:
new
(
)
as
&
nsACString
&
nsCString
:
:
from
(
format
!
(
"
explicit
/
data
-
storage
/
{
}
"
self
.
name
)
)
as
&
nsACString
nsIMemoryReporter
:
:
KIND_HEAP
nsIMemoryReporter
:
:
UNITS_BYTES
size
as
i64
&
nsCStr
:
:
from
(
"
Memory
used
by
PSM
data
storage
cache
"
)
as
&
nsACString
data
)
.
to_result
(
)
}
}
}
#
[
xpcom
(
implement
(
nsIDataStorageItem
)
atomic
)
]
struct
DataStorageItem
{
key
:
nsCString
value
:
nsCString
type_
:
u8
}
impl
DataStorageItem
{
xpcom_method
!
(
get_key
=
>
GetKey
(
)
-
>
nsACString
)
;
fn
get_key
(
&
self
)
-
>
Result
<
nsCString
nsresult
>
{
Ok
(
self
.
key
.
clone
(
)
)
}
xpcom_method
!
(
get_value
=
>
GetValue
(
)
-
>
nsACString
)
;
fn
get_value
(
&
self
)
-
>
Result
<
nsCString
nsresult
>
{
Ok
(
self
.
value
.
clone
(
)
)
}
xpcom_method
!
(
get_type
=
>
GetType
(
)
-
>
u8
)
;
fn
get_type
(
&
self
)
-
>
Result
<
u8
nsresult
>
{
Ok
(
self
.
type_
)
}
}
type
VoidPtrToSizeFn
=
unsafe
extern
"
C
"
fn
(
ptr
:
*
const
c_void
)
-
>
usize
;
#
[
xpcom
(
implement
(
nsIDataStorage
nsIMemoryReporter
nsIObserver
)
atomic
)
]
struct
DataStorage
{
ready
:
(
Mutex
<
bool
>
Condvar
)
data
:
Mutex
<
DataStorageInner
>
size_of_op
:
VoidPtrToSizeFn
enclosing_size_of_op
:
VoidPtrToSizeFn
}
impl
DataStorage
{
xpcom_method
!
(
get
=
>
Get
(
key
:
*
const
nsACString
type_
:
u8
)
-
>
nsACString
)
;
fn
get
(
&
self
key
:
&
nsACString
type_
:
u8
)
-
>
Result
<
nsCString
nsresult
>
{
self
.
wait_for_ready
(
)
?
;
let
mut
storage
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
storage
.
get
(
&
Vec
:
:
from
(
key
.
as_ref
(
)
)
type_
.
into
(
)
)
.
map
(
|
data
|
nsCString
:
:
from
(
data
)
)
}
xpcom_method
!
(
put
=
>
Put
(
key
:
*
const
nsACString
value
:
*
const
nsACString
type_
:
u8
)
)
;
fn
put
(
&
self
key
:
&
nsACString
value
:
&
nsACString
type_
:
u8
)
-
>
Result
<
(
)
nsresult
>
{
self
.
wait_for_ready
(
)
?
;
let
mut
storage
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
storage
.
put
(
Vec
:
:
from
(
key
.
as_ref
(
)
)
Vec
:
:
from
(
value
.
as_ref
(
)
)
type_
.
into
(
)
)
}
xpcom_method
!
(
remove
=
>
Remove
(
key
:
*
const
nsACString
type_
:
u8
)
)
;
fn
remove
(
&
self
key
:
&
nsACString
type_
:
u8
)
-
>
Result
<
(
)
nsresult
>
{
self
.
wait_for_ready
(
)
?
;
let
mut
storage
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
storage
.
remove
(
&
Vec
:
:
from
(
key
.
as_ref
(
)
)
type_
.
into
(
)
)
?
;
Ok
(
(
)
)
}
xpcom_method
!
(
clear
=
>
Clear
(
)
)
;
fn
clear
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
self
.
wait_for_ready
(
)
?
;
let
mut
storage
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
storage
.
clear
(
)
?
;
Ok
(
(
)
)
}
xpcom_method
!
(
is_ready
=
>
IsReady
(
)
-
>
bool
)
;
fn
is_ready
(
&
self
)
-
>
Result
<
bool
nsresult
>
{
let
ready
=
self
.
ready
.
0
.
lock
(
)
.
unwrap
(
)
;
Ok
(
*
ready
)
}
xpcom_method
!
(
get_all
=
>
GetAll
(
)
-
>
ThinVec
<
Option
<
RefPtr
<
nsIDataStorageItem
>
>
>
)
;
fn
get_all
(
&
self
)
-
>
Result
<
ThinVec
<
Option
<
RefPtr
<
nsIDataStorageItem
>
>
>
nsresult
>
{
self
.
wait_for_ready
(
)
?
;
let
storage
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
let
mut
items
=
ThinVec
:
:
new
(
)
;
let
add_item
=
|
entry
:
&
Entry
data_type
:
DataType
|
{
let
item
=
DataStorageItem
:
:
allocate
(
InitDataStorageItem
{
key
:
entry
.
key
.
clone
(
)
.
into
(
)
value
:
entry
.
value
.
clone
(
)
.
into
(
)
type_
:
data_type
.
into
(
)
}
)
;
items
.
push
(
Some
(
RefPtr
:
:
new
(
item
.
coerce
(
)
)
)
)
;
}
;
storage
.
for_each
(
add_item
)
;
Ok
(
items
)
}
fn
indicate_ready
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
let
(
ready_mutex
condvar
)
=
&
self
.
ready
;
let
mut
ready
=
ready_mutex
.
lock
(
)
.
unwrap
(
)
;
*
ready
=
true
;
condvar
.
notify_all
(
)
;
Ok
(
(
)
)
}
fn
wait_for_ready
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
let
(
ready_mutex
condvar
)
=
&
self
.
ready
;
let
mut
ready
=
ready_mutex
.
lock
(
)
.
unwrap
(
)
;
while
!
*
ready
{
ready
=
condvar
.
wait
(
ready
)
.
unwrap
(
)
;
}
Ok
(
(
)
)
}
fn
initialize
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
let
mut
storage
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
let
_
=
storage
.
initialize
(
)
;
self
.
indicate_ready
(
)
}
xpcom_method
!
(
collect_reports
=
>
CollectReports
(
callback
:
*
const
nsIHandleReportCallback
data
:
*
const
nsISupports
anonymize
:
bool
)
)
;
fn
collect_reports
(
&
self
callback
:
&
nsIHandleReportCallback
data
:
Option
<
&
nsISupports
>
_anonymize
:
bool
)
-
>
Result
<
(
)
nsresult
>
{
let
storage
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
let
mut
ops
=
MallocSizeOfOps
:
:
new
(
self
.
size_of_op
Some
(
self
.
enclosing_size_of_op
)
)
;
storage
.
collect_reports
(
&
mut
ops
callback
data
)
}
xpcom_method
!
(
observe
=
>
Observe
(
_subject
:
*
const
nsISupports
topic
:
*
const
c_char
_data
:
*
const
u16
)
)
;
unsafe
fn
observe
(
&
self
_subject
:
Option
<
&
nsISupports
>
topic
:
*
const
c_char
_data
:
*
const
u16
)
-
>
Result
<
(
)
nsresult
>
{
let
mut
storage
=
self
.
data
.
lock
(
)
.
unwrap
(
)
;
let
topic
=
CStr
:
:
from_ptr
(
topic
)
;
if
topic
=
=
cstr
!
(
"
profile
-
before
-
change
"
)
|
|
topic
=
=
cstr
!
(
"
xpcom
-
shutdown
-
threads
"
)
{
storage
.
drop_write_queue
(
)
;
}
else
if
topic
=
=
cstr
!
(
"
last
-
pb
-
context
-
exited
"
)
{
storage
.
clear_private_data
(
)
;
}
Ok
(
(
)
)
}
}
fn
write_entries
(
entries
:
Vec
<
Entry
>
backing_path
:
PathBuf
value_length
:
usize
slot_length
:
usize
)
-
>
Result
<
(
)
std
:
:
io
:
:
Error
>
{
let
mut
backing_file
=
OpenOptions
:
:
new
(
)
.
write
(
true
)
.
create
(
true
)
.
open
(
backing_path
)
?
;
let
Some
(
max_slot_index
)
=
entries
.
iter
(
)
.
map
(
|
entry
|
entry
.
slot_index
)
.
max
(
)
else
{
return
Ok
(
(
)
)
;
}
;
let
necessary_len
=
(
(
max_slot_index
+
1
)
*
slot_length
)
as
u64
;
if
backing_file
.
metadata
(
)
?
.
len
(
)
<
necessary_len
{
backing_file
.
set_len
(
necessary_len
)
?
;
}
let
mut
buf
=
vec
!
[
0u8
;
slot_length
]
;
for
entry
in
entries
{
let
mut
buf_writer
=
buf
.
as_mut_slice
(
)
;
buf_writer
.
write_u16
:
:
<
BigEndian
>
(
0
)
?
;
let
mut
checksum
=
entry
.
score
;
buf_writer
.
write_u16
:
:
<
BigEndian
>
(
entry
.
score
)
?
;
checksum
^
=
entry
.
last_accessed
;
buf_writer
.
write_u16
:
:
<
BigEndian
>
(
entry
.
last_accessed
)
?
;
for
mut
chunk
in
entry
.
key
.
chunks
(
2
)
{
if
chunk
.
len
(
)
=
=
1
{
checksum
^
=
(
chunk
[
0
]
as
u16
)
<
<
8
;
}
else
{
checksum
^
=
chunk
.
read_u16
:
:
<
BigEndian
>
(
)
?
;
}
}
if
entry
.
key
.
len
(
)
>
KEY_LENGTH
{
continue
;
}
buf_writer
.
write_all
(
&
entry
.
key
)
?
;
let
(
key_remainder
mut
buf_writer
)
=
buf_writer
.
split_at_mut
(
KEY_LENGTH
-
entry
.
key
.
len
(
)
)
;
key_remainder
.
fill
(
0
)
;
for
mut
chunk
in
entry
.
value
.
chunks
(
2
)
{
if
chunk
.
len
(
)
=
=
1
{
checksum
^
=
(
chunk
[
0
]
as
u16
)
<
<
8
;
}
else
{
checksum
^
=
chunk
.
read_u16
:
:
<
BigEndian
>
(
)
?
;
}
}
if
entry
.
value
.
len
(
)
>
value_length
{
continue
;
}
buf_writer
.
write_all
(
&
entry
.
value
)
?
;
buf_writer
.
fill
(
0
)
;
backing_file
.
seek
(
SeekFrom
:
:
Start
(
(
entry
.
slot_index
*
slot_length
)
as
u64
)
)
?
;
backing_file
.
write_all
(
&
buf
)
?
;
backing_file
.
flush
(
)
?
;
backing_file
.
seek
(
SeekFrom
:
:
Start
(
(
entry
.
slot_index
*
slot_length
)
as
u64
)
)
?
;
backing_file
.
write_u16
:
:
<
BigEndian
>
(
checksum
)
?
;
}
Ok
(
(
)
)
}
fn
get_profile_path
(
)
-
>
Result
<
PathBuf
nsresult
>
{
let
directory_service
:
RefPtr
<
nsIProperties
>
=
xpcom
:
:
components
:
:
Directory
:
:
service
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
mut
profile_dir
=
xpcom
:
:
GetterAddrefs
:
:
<
nsIFile
>
:
:
new
(
)
;
unsafe
{
directory_service
.
Get
(
cstr
!
(
"
ProfD
"
)
.
as_ptr
(
)
&
nsIFile
:
:
IID
profile_dir
.
void_ptr
(
)
)
.
to_result
(
)
?
;
}
let
profile_dir
=
profile_dir
.
refptr
(
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
let
mut
profile_path
=
nsString
:
:
new
(
)
;
unsafe
{
(
*
profile_dir
)
.
GetPath
(
&
mut
*
profile_path
)
.
to_result
(
)
?
;
}
let
profile_path
=
String
:
:
from_utf16
(
profile_path
.
as_ref
(
)
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
Ok
(
PathBuf
:
:
from
(
profile_path
)
)
}
fn
make_data_storage_internal
(
basename
:
&
str
value_length
:
usize
size_of_op
:
VoidPtrToSizeFn
enclosing_size_of_op
:
VoidPtrToSizeFn
)
-
>
Result
<
RefPtr
<
nsIDataStorage
>
nsresult
>
{
let
maybe_profile_path
=
get_profile_path
(
)
.
ok
(
)
;
let
data_storage
=
DataStorage
:
:
allocate
(
InitDataStorage
{
ready
:
(
Mutex
:
:
new
(
false
)
Condvar
:
:
new
(
)
)
data
:
Mutex
:
:
new
(
DataStorageInner
:
:
new
(
basename
.
to_string
(
)
value_length
maybe_profile_path
)
?
)
size_of_op
enclosing_size_of_op
}
)
;
let
data_storage_for_background_initialization
=
data_storage
.
clone
(
)
;
RunnableBuilder
:
:
new
(
"
data_storage
:
:
initialize
"
move
|
|
{
let
_
=
data_storage_for_background_initialization
.
initialize
(
)
;
}
)
.
may_block
(
true
)
.
dispatch_background_task
(
)
?
;
if
let
Ok
(
observer_service
)
=
xpcom
:
:
components
:
:
Observer
:
:
service
:
:
<
nsIObserverService
>
(
)
{
unsafe
{
observer_service
.
AddObserver
(
data_storage
.
coerce
(
)
cstr
!
(
"
profile
-
before
-
change
"
)
.
as_ptr
(
)
false
)
.
to_result
(
)
?
;
observer_service
.
AddObserver
(
data_storage
.
coerce
(
)
cstr
!
(
"
xpcom
-
shutdown
-
threads
"
)
.
as_ptr
(
)
false
)
.
to_result
(
)
?
;
observer_service
.
AddObserver
(
data_storage
.
coerce
(
)
cstr
!
(
"
last
-
pb
-
context
-
exited
"
)
.
as_ptr
(
)
false
)
.
to_result
(
)
?
;
}
}
if
let
Some
(
memory_reporter_manager
)
=
xpcom
:
:
get_service
:
:
<
nsIMemoryReporterManager
>
(
cstr
!
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
)
{
unsafe
{
memory_reporter_manager
.
RegisterStrongReporter
(
data_storage
.
coerce
(
)
)
.
to_result
(
)
?
;
}
}
Ok
(
RefPtr
:
:
new
(
data_storage
.
coerce
(
)
)
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
make_data_storage
(
basename
:
*
const
nsAString
value_length
:
usize
size_of_op
:
VoidPtrToSizeFn
enclosing_size_of_op
:
VoidPtrToSizeFn
result
:
*
mut
*
const
xpcom
:
:
interfaces
:
:
nsIDataStorage
)
-
>
nsresult
{
if
basename
.
is_null
(
)
|
|
result
.
is_null
(
)
{
return
NS_ERROR_INVALID_ARG
;
}
let
basename
=
&
*
basename
;
let
basename
=
basename
.
to_string
(
)
;
match
make_data_storage_internal
(
&
basename
value_length
size_of_op
enclosing_size_of_op
)
{
Ok
(
val
)
=
>
val
.
forget
(
&
mut
*
result
)
Err
(
e
)
=
>
return
e
}
NS_OK
}
