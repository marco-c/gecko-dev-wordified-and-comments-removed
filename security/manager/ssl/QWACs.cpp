#
include
"
nsIX509CertDB
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
QWACTrustDomain
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixder
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
mozpkix
/
pkixtypes
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
nsNSSCertificateDB
.
h
"
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
using
mozilla
:
:
dom
:
:
Promise
;
class
VerifyQWACTask
:
public
mozilla
:
:
CryptoTask
{
public
:
VerifyQWACTask
(
nsIX509CertDB
:
:
QWACType
aType
nsIX509Cert
*
aCert
const
nsACString
&
aHostname
const
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aCollectedCerts
RefPtr
<
Promise
>
&
aPromise
)
:
mType
(
aType
)
mCert
(
aCert
)
mHostname
(
aHostname
)
mCollectedCerts
(
aCollectedCerts
.
Clone
(
)
)
mPromise
(
new
nsMainThreadPtrHolder
<
Promise
>
(
"
VerifyQWACTask
:
:
mPromise
"
aPromise
)
)
mVerified
(
false
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
;
virtual
void
CallCallback
(
nsresult
rv
)
override
;
nsIX509CertDB
:
:
QWACType
mType
;
RefPtr
<
nsIX509Cert
>
mCert
;
nsCString
mHostname
;
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
mCollectedCerts
;
nsMainThreadPtrHandle
<
Promise
>
mPromise
;
bool
mVerified
;
}
;
bool
CertHasQWACSQCStatements
(
Input
cert
)
{
using
namespace
mozilla
:
:
pkix
:
:
der
;
static
const
uint8_t
id_etsi_qcs_QcCompliance
[
]
=
{
0x04
0x00
0x8e
0x46
0x01
0x01
}
;
static
const
uint8_t
id_etsi_qcs_QcType
[
]
=
{
0x04
0x00
0x8e
0x46
0x01
0x06
}
;
static
const
uint8_t
id_etsi_qct_web
[
]
=
{
0x04
0x00
0x8e
0x46
0x01
0x06
0x03
}
;
BackCert
backCert
(
cert
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
;
if
(
backCert
.
Init
(
)
!
=
Success
)
{
return
false
;
}
const
Input
*
qcStatementsInput
(
backCert
.
GetQCStatements
(
)
)
;
if
(
!
qcStatementsInput
)
{
return
false
;
}
Reader
qcStatements
(
*
qcStatementsInput
)
;
bool
foundQCComplianceStatement
=
false
;
bool
foundQCTypeStatementWithWebType
=
false
;
mozilla
:
:
pkix
:
:
Result
rv
=
NestedOf
(
qcStatements
SEQUENCE
SEQUENCE
EmptyAllowed
:
:
No
[
&
]
(
Reader
&
qcStatementContents
)
{
Reader
statementId
;
mozilla
:
:
pkix
:
:
Result
rv
=
ExpectTagAndGetValue
(
qcStatementContents
OIDTag
statementId
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
statementId
.
MatchRest
(
id_etsi_qcs_QcCompliance
)
)
{
foundQCComplianceStatement
=
true
;
return
End
(
qcStatementContents
)
;
}
if
(
statementId
.
MatchRest
(
id_etsi_qcs_QcType
)
)
{
Reader
supportedStatementsContents
;
rv
=
ExpectTagAndGetValue
(
qcStatementContents
SEQUENCE
supportedStatementsContents
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Reader
supportedStatementId
;
rv
=
ExpectTagAndGetValue
(
supportedStatementsContents
OIDTag
supportedStatementId
)
;
if
(
supportedStatementId
.
MatchRest
(
id_etsi_qct_web
)
)
{
foundQCTypeStatementWithWebType
=
true
;
}
rv
=
End
(
supportedStatementsContents
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
End
(
qcStatementContents
)
;
}
qcStatementContents
.
SkipToEnd
(
)
;
return
Success
;
}
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
if
(
!
qcStatements
.
AtEnd
(
)
)
{
return
false
;
}
return
foundQCComplianceStatement
&
&
foundQCTypeStatementWithWebType
;
}
bool
CertHasPolicyFrom
(
Input
cert
const
nsTArray
<
Input
>
&
policies
)
{
using
namespace
mozilla
:
:
pkix
:
:
der
;
BackCert
backCert
(
cert
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
;
if
(
backCert
.
Init
(
)
!
=
Success
)
{
return
false
;
}
const
Input
*
certificatePoliciesInput
(
backCert
.
GetCertificatePolicies
(
)
)
;
if
(
!
certificatePoliciesInput
)
{
return
false
;
}
Reader
certificatePolicies
(
*
certificatePoliciesInput
)
;
bool
foundPolicy
=
false
;
mozilla
:
:
pkix
:
:
Result
rv
=
NestedOf
(
certificatePolicies
SEQUENCE
SEQUENCE
EmptyAllowed
:
:
No
[
&
]
(
Reader
&
policyInformationContents
)
{
Reader
policyIdentifier
;
mozilla
:
:
pkix
:
:
Result
rv
=
ExpectTagAndGetValue
(
policyInformationContents
OIDTag
policyIdentifier
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
for
(
const
auto
&
policy
:
policies
)
{
if
(
policyIdentifier
.
MatchRest
(
policy
)
)
{
foundPolicy
=
true
;
}
}
return
Success
;
}
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
if
(
!
certificatePolicies
.
AtEnd
(
)
)
{
return
false
;
}
return
foundPolicy
;
}
bool
CertHas1QWACPolicy
(
Input
cert
)
{
static
const
uint8_t
qevcp_w
[
]
=
{
0x04
0x00
0x8b
0xec
0x40
0x01
0x04
}
;
static
const
uint8_t
qncp_w
[
]
=
{
0x04
0x00
0x8b
0xec
0x40
0x01
0x05
}
;
return
CertHasPolicyFrom
(
cert
{
Input
(
qevcp_w
)
Input
(
qncp_w
)
}
)
;
}
bool
CertHas2QWACPolicy
(
Input
cert
)
{
static
const
uint8_t
qevcp_w_gen
[
]
=
{
0x04
0x00
0x8b
0xec
0x40
0x01
0x06
}
;
return
CertHasPolicyFrom
(
cert
{
Input
(
qevcp_w_gen
)
}
)
;
}
bool
CertOnlyHasTLSBindingEKU
(
Input
cert
)
{
using
namespace
mozilla
:
:
pkix
:
:
der
;
static
const
uint8_t
id_kp_tls_binding
[
]
=
{
0x04
0x00
0x8b
0xec
0x43
0x01
0x00
}
;
BackCert
backCert
(
cert
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
;
if
(
backCert
.
Init
(
)
!
=
Success
)
{
return
false
;
}
const
Input
*
ekuInput
(
backCert
.
GetExtKeyUsage
(
)
)
;
if
(
!
ekuInput
)
{
return
false
;
}
Reader
eku
(
*
ekuInput
)
;
mozilla
:
:
pkix
:
:
Result
rv
=
Nested
(
eku
SEQUENCE
OIDTag
[
&
]
(
Reader
&
r
)
{
if
(
r
.
MatchRest
(
id_kp_tls_binding
)
)
{
return
Success
;
}
return
mozilla
:
:
pkix
:
:
Result
:
:
ERROR_INADEQUATE_CERT_TYPE
;
}
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
return
eku
.
AtEnd
(
)
;
}
nsresult
VerifyQWACTask
:
:
CalculateResult
(
)
{
mozilla
:
:
psm
:
:
QWACTrustDomain
trustDomain
(
mCollectedCerts
)
;
nsTArray
<
uint8_t
>
certDER
;
nsresult
rv
=
mCert
-
>
GetRawDER
(
certDER
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Input
cert
;
if
(
cert
.
Init
(
certDER
.
Elements
(
)
certDER
.
Length
(
)
)
!
=
Success
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
CertHasQWACSQCStatements
(
cert
)
)
{
return
NS_OK
;
}
if
(
mType
=
=
nsIX509CertDB
:
:
QWACType
:
:
OneQWAC
)
{
if
(
!
CertHas1QWACPolicy
(
cert
)
)
{
return
NS_OK
;
}
}
else
if
(
mType
=
=
nsIX509CertDB
:
:
QWACType
:
:
TwoQWAC
)
{
if
(
!
CertHas2QWACPolicy
(
cert
)
)
{
return
NS_OK
;
}
if
(
!
CertOnlyHasTLSBindingEKU
(
cert
)
)
{
return
NS_OK
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
unhandled
QWAC
type
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
BuildCertChain
(
trustDomain
cert
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
anyExtendedKeyUsage
CertPolicyId
:
:
anyPolicy
nullptr
)
!
=
Success
)
{
return
NS_OK
;
}
Input
hostname
;
if
(
hostname
.
Init
(
mozilla
:
:
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
mHostname
.
BeginReading
(
)
)
mHostname
.
Length
(
)
)
!
=
Success
)
{
return
NS_OK
;
}
if
(
CheckCertHostname
(
cert
hostname
)
!
=
Success
)
{
return
NS_OK
;
}
mVerified
=
true
;
return
NS_OK
;
}
void
VerifyQWACTask
:
:
CallCallback
(
nsresult
rv
)
{
if
(
NS_FAILED
(
rv
)
)
{
mPromise
-
>
MaybeReject
(
rv
)
;
}
else
{
mPromise
-
>
MaybeResolve
(
mVerified
)
;
}
}
NS_IMETHODIMP
nsNSSCertificateDB
:
:
AsyncVerifyQWAC
(
QWACType
aType
nsIX509Cert
*
aCert
const
nsACString
&
aHostname
const
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aCollectedCerts
JSContext
*
aCx
mozilla
:
:
dom
:
:
Promise
*
*
aPromise
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_UNEXPECTED
;
}
mozilla
:
:
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
result
.
Failed
(
)
)
{
return
result
.
StealNSResult
(
)
;
}
RefPtr
<
VerifyQWACTask
>
task
(
new
VerifyQWACTask
(
aType
aCert
aHostname
aCollectedCerts
promise
)
)
;
nsresult
rv
=
task
-
>
Dispatch
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
