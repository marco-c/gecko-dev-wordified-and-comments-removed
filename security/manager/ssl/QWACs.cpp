#
include
"
nsIX509CertDB
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
QWACTrustDomain
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixder
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
mozpkix
/
pkixtypes
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
nsNSSCertificateDB
.
h
"
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
pkix
:
:
der
;
using
namespace
mozilla
:
:
psm
;
using
mozilla
:
:
dom
:
:
Promise
;
class
Verify1QWACTask
:
public
mozilla
:
:
CryptoTask
{
public
:
Verify1QWACTask
(
nsIX509Cert
*
aCert
const
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aCollectedCerts
RefPtr
<
Promise
>
&
aPromise
)
:
mCert
(
aCert
)
mCollectedCerts
(
aCollectedCerts
.
Clone
(
)
)
mPromise
(
new
nsMainThreadPtrHolder
<
Promise
>
(
"
Verify1QWACTask
:
:
mPromise
"
aPromise
)
)
mVerifiedAs1QWAC
(
false
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
;
virtual
void
CallCallback
(
nsresult
rv
)
override
;
RefPtr
<
nsIX509Cert
>
mCert
;
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
mCollectedCerts
;
nsMainThreadPtrHandle
<
Promise
>
mPromise
;
bool
mVerifiedAs1QWAC
;
}
;
bool
CertHasQWACSQCStatements
(
const
nsTArray
<
uint8_t
>
&
certDER
)
{
static
const
uint8_t
id_etsi_qcs_QcCompliance
[
]
=
{
0x04
0x00
0x8e
0x46
0x01
0x01
}
;
static
const
uint8_t
id_etsi_qcs_QcType
[
]
=
{
0x04
0x00
0x8e
0x46
0x01
0x06
}
;
static
const
uint8_t
id_etsi_qct_web
[
]
=
{
0x04
0x00
0x8e
0x46
0x01
0x06
0x03
}
;
Input
cert
;
if
(
cert
.
Init
(
certDER
.
Elements
(
)
certDER
.
Length
(
)
)
!
=
Success
)
{
return
false
;
}
BackCert
backCert
(
cert
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
;
if
(
backCert
.
Init
(
)
!
=
Success
)
{
return
false
;
}
const
Input
*
qcStatementsInput
(
backCert
.
GetQCStatements
(
)
)
;
if
(
!
qcStatementsInput
)
{
return
false
;
}
Reader
qcStatements
(
*
qcStatementsInput
)
;
bool
foundQCComplianceStatement
=
false
;
bool
foundQCTypeStatementWithWebType
=
false
;
mozilla
:
:
pkix
:
:
Result
rv
=
NestedOf
(
qcStatements
SEQUENCE
SEQUENCE
EmptyAllowed
:
:
No
[
&
]
(
Reader
&
qcStatementContents
)
{
Reader
statementId
;
mozilla
:
:
pkix
:
:
Result
rv
=
ExpectTagAndGetValue
(
qcStatementContents
OIDTag
statementId
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
statementId
.
MatchRest
(
id_etsi_qcs_QcCompliance
)
)
{
foundQCComplianceStatement
=
true
;
return
End
(
qcStatementContents
)
;
}
if
(
statementId
.
MatchRest
(
id_etsi_qcs_QcType
)
)
{
Reader
supportedStatementsContents
;
rv
=
ExpectTagAndGetValue
(
qcStatementContents
SEQUENCE
supportedStatementsContents
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
Reader
supportedStatementId
;
rv
=
ExpectTagAndGetValue
(
supportedStatementsContents
OIDTag
supportedStatementId
)
;
if
(
supportedStatementId
.
MatchRest
(
id_etsi_qct_web
)
)
{
foundQCTypeStatementWithWebType
=
true
;
}
rv
=
End
(
supportedStatementsContents
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
return
End
(
qcStatementContents
)
;
}
qcStatementContents
.
SkipToEnd
(
)
;
return
Success
;
}
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
return
foundQCComplianceStatement
&
&
foundQCTypeStatementWithWebType
;
}
bool
CertHas1QWACPolicy
(
const
nsTArray
<
uint8_t
>
&
certDER
)
{
static
const
uint8_t
qevcp_w
[
]
=
{
0x04
0x00
0x8b
0xec
0x40
0x01
0x04
}
;
static
const
uint8_t
qncp_w
[
]
=
{
0x04
0x00
0x8b
0xec
0x40
0x01
0x05
}
;
Input
cert
;
if
(
cert
.
Init
(
certDER
.
Elements
(
)
certDER
.
Length
(
)
)
!
=
Success
)
{
return
false
;
}
BackCert
backCert
(
cert
EndEntityOrCA
:
:
MustBeEndEntity
nullptr
)
;
if
(
backCert
.
Init
(
)
!
=
Success
)
{
return
false
;
}
const
Input
*
certificatePoliciesInput
(
backCert
.
GetCertificatePolicies
(
)
)
;
if
(
!
certificatePoliciesInput
)
{
return
false
;
}
Reader
certificatePolicies
(
*
certificatePoliciesInput
)
;
bool
found1QWACPolicy
=
false
;
mozilla
:
:
pkix
:
:
Result
rv
=
NestedOf
(
certificatePolicies
SEQUENCE
SEQUENCE
EmptyAllowed
:
:
No
[
&
]
(
Reader
&
policyInformationContents
)
{
Reader
policyIdentifier
;
mozilla
:
:
pkix
:
:
Result
rv
=
ExpectTagAndGetValue
(
policyInformationContents
OIDTag
policyIdentifier
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
policyIdentifier
.
MatchRest
(
qevcp_w
)
|
|
policyIdentifier
.
MatchRest
(
qncp_w
)
)
{
found1QWACPolicy
=
true
;
}
return
Success
;
}
)
;
if
(
rv
!
=
Success
)
{
return
false
;
}
return
found1QWACPolicy
;
}
nsresult
Verify1QWACTask
:
:
CalculateResult
(
)
{
mozilla
:
:
psm
:
:
QWACTrustDomain
trustDomain
(
mCollectedCerts
)
;
nsTArray
<
uint8_t
>
certDER
;
nsresult
rv
=
mCert
-
>
GetRawDER
(
certDER
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
CertHasQWACSQCStatements
(
certDER
)
)
{
return
NS_OK
;
}
if
(
!
CertHas1QWACPolicy
(
certDER
)
)
{
return
NS_OK
;
}
Input
cert
;
if
(
cert
.
Init
(
certDER
.
Elements
(
)
certDER
.
Length
(
)
)
!
=
Success
)
{
return
NS_ERROR_FAILURE
;
}
if
(
BuildCertChain
(
trustDomain
cert
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
anyExtendedKeyUsage
CertPolicyId
:
:
anyPolicy
nullptr
)
!
=
Success
)
{
return
NS_OK
;
}
mVerifiedAs1QWAC
=
true
;
return
NS_OK
;
}
void
Verify1QWACTask
:
:
CallCallback
(
nsresult
rv
)
{
if
(
NS_FAILED
(
rv
)
)
{
mPromise
-
>
MaybeReject
(
rv
)
;
}
else
{
mPromise
-
>
MaybeResolve
(
mVerifiedAs1QWAC
)
;
}
}
NS_IMETHODIMP
nsNSSCertificateDB
:
:
AsyncVerify1QWAC
(
nsIX509Cert
*
aCert
const
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
&
aCollectedCerts
JSContext
*
aCx
mozilla
:
:
dom
:
:
Promise
*
*
aPromise
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_UNEXPECTED
;
}
mozilla
:
:
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
result
.
Failed
(
)
)
{
return
result
.
StealNSResult
(
)
;
}
RefPtr
<
Verify1QWACTask
>
task
(
new
Verify1QWACTask
(
aCert
aCollectedCerts
promise
)
)
;
nsresult
rv
=
task
-
>
Dispatch
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
