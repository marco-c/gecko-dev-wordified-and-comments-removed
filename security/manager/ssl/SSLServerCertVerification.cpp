#
include
"
SSLServerCertVerification
.
h
"
#
include
<
cstring
>
#
include
"
BRNameMatchingPolicy
.
h
"
#
include
"
CertVerifier
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
ExtendedValidation
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
PSMRunnable
.
h
"
#
include
"
RootCertificateTelemetryUtils
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
SharedCertVerifier
.
h
"
#
include
"
SharedSSLState
.
h
"
#
include
"
TransportSecurityInfo
.
h
"
#
include
"
cert
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsICertOverrideService
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsISocketProvider
.
h
"
#
include
"
nsThreadPool
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsNSSIOLayer
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsXPCOMCIDInternal
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
secerr
.
h
"
#
include
"
secoidt
.
h
"
#
include
"
secport
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslerr
.
h
"
#
include
"
sslexp
.
h
"
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
using
namespace
mozilla
:
:
pkix
;
namespace
mozilla
{
namespace
psm
{
namespace
{
nsIThreadPool
*
gCertVerificationThreadPool
=
nullptr
;
}
void
InitializeSSLServerCertVerificationThreads
(
)
{
gCertVerificationThreadPool
=
new
nsThreadPool
(
)
;
NS_ADDREF
(
gCertVerificationThreadPool
)
;
(
void
)
gCertVerificationThreadPool
-
>
SetIdleThreadLimit
(
5
)
;
(
void
)
gCertVerificationThreadPool
-
>
SetIdleThreadTimeout
(
30
*
1000
)
;
(
void
)
gCertVerificationThreadPool
-
>
SetThreadLimit
(
5
)
;
(
void
)
gCertVerificationThreadPool
-
>
SetName
(
NS_LITERAL_CSTRING
(
"
SSL
Cert
"
)
)
;
}
void
StopSSLServerCertVerificationThreads
(
)
{
if
(
gCertVerificationThreadPool
)
{
gCertVerificationThreadPool
-
>
Shutdown
(
)
;
NS_RELEASE
(
gCertVerificationThreadPool
)
;
}
}
namespace
{
class
SSLServerCertVerificationResult
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
SSLServerCertVerificationResult
(
TransportSecurityInfo
*
infoObject
PRErrorCode
errorCode
)
;
void
Dispatch
(
)
;
private
:
const
RefPtr
<
TransportSecurityInfo
>
mInfoObject
;
const
PRErrorCode
mErrorCode
;
}
;
uint32_t
MapOverridableErrorToProbeValue
(
PRErrorCode
errorCode
)
{
switch
(
errorCode
)
{
case
SEC_ERROR_UNKNOWN_ISSUER
:
return
2
;
case
SEC_ERROR_CA_CERT_INVALID
:
return
3
;
case
SEC_ERROR_UNTRUSTED_ISSUER
:
return
4
;
case
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
:
return
5
;
case
SEC_ERROR_UNTRUSTED_CERT
:
return
6
;
case
SEC_ERROR_INADEQUATE_KEY_USAGE
:
return
7
;
case
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
:
return
8
;
case
SSL_ERROR_BAD_CERT_DOMAIN
:
return
9
;
case
SEC_ERROR_EXPIRED_CERTIFICATE
:
return
10
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY
:
return
11
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA
:
return
12
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE
:
return
13
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
:
return
14
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
:
return
15
;
case
SEC_ERROR_INVALID_TIME
:
return
16
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_EMPTY_ISSUER_NAME
:
return
17
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
:
return
18
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
:
return
19
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_MITM_DETECTED
:
return
20
;
}
NS_WARNING
(
"
Unknown
certificate
error
code
.
Does
MapOverridableErrorToProbeValue
"
"
handle
everything
in
DetermineCertOverrideErrors
?
"
)
;
return
0
;
}
static
uint32_t
MapCertErrorToProbeValue
(
PRErrorCode
errorCode
)
{
uint32_t
probeValue
;
switch
(
errorCode
)
{
#
define
MOZILLA_PKIX_MAP
(
name
value
nss_name
)
\
case
nss_name
:
\
probeValue
=
value
;
\
break
;
MOZILLA_PKIX_MAP_LIST
#
undef
MOZILLA_PKIX_MAP
default
:
return
0
;
}
static_assert
(
FATAL_ERROR_FLAG
=
=
0x800
"
mozilla
:
:
pkix
:
:
FATAL_ERROR_FLAG
is
not
what
we
were
expecting
"
)
;
if
(
probeValue
&
FATAL_ERROR_FLAG
)
{
probeValue
^
=
FATAL_ERROR_FLAG
;
probeValue
+
=
90
;
}
return
probeValue
;
}
SECStatus
DetermineCertOverrideErrors
(
const
UniqueCERTCertificate
&
cert
const
nsACString
&
hostName
PRTime
now
PRErrorCode
defaultErrorCodeToReport
uint32_t
&
collectedErrors
PRErrorCode
&
errorCodeTrust
PRErrorCode
&
errorCodeMismatch
PRErrorCode
&
errorCodeTime
)
{
MOZ_ASSERT
(
cert
)
;
MOZ_ASSERT
(
collectedErrors
=
=
0
)
;
MOZ_ASSERT
(
errorCodeTrust
=
=
0
)
;
MOZ_ASSERT
(
errorCodeMismatch
=
=
0
)
;
MOZ_ASSERT
(
errorCodeTime
=
=
0
)
;
switch
(
defaultErrorCodeToReport
)
{
case
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
:
case
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
:
case
SEC_ERROR_UNKNOWN_ISSUER
:
case
SEC_ERROR_CA_CERT_INVALID
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_EMPTY_ISSUER_NAME
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_MITM_DETECTED
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA
:
{
collectedErrors
=
nsICertOverrideService
:
:
ERROR_UNTRUSTED
;
errorCodeTrust
=
defaultErrorCodeToReport
;
SECCertTimeValidity
validity
=
CERT_CheckCertValidTimes
(
cert
.
get
(
)
now
false
)
;
if
(
validity
=
=
secCertTimeUndetermined
)
{
MOZ_ASSERT
(
PR_GetError
(
)
=
=
SEC_ERROR_INVALID_ARGS
)
;
return
SECFailure
;
}
if
(
validity
=
=
secCertTimeExpired
)
{
collectedErrors
|
=
nsICertOverrideService
:
:
ERROR_TIME
;
errorCodeTime
=
SEC_ERROR_EXPIRED_CERTIFICATE
;
}
else
if
(
validity
=
=
secCertTimeNotValidYet
)
{
collectedErrors
|
=
nsICertOverrideService
:
:
ERROR_TIME
;
errorCodeTime
=
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
;
}
break
;
}
case
SEC_ERROR_INVALID_TIME
:
case
SEC_ERROR_EXPIRED_CERTIFICATE
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
:
collectedErrors
=
nsICertOverrideService
:
:
ERROR_TIME
;
errorCodeTime
=
defaultErrorCodeToReport
;
break
;
case
SSL_ERROR_BAD_CERT_DOMAIN
:
collectedErrors
=
nsICertOverrideService
:
:
ERROR_MISMATCH
;
errorCodeMismatch
=
SSL_ERROR_BAD_CERT_DOMAIN
;
break
;
case
0
:
NS_ERROR
(
"
No
error
code
set
during
certificate
validation
failure
.
"
)
;
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
default
:
PR_SetError
(
defaultErrorCodeToReport
0
)
;
return
SECFailure
;
}
if
(
defaultErrorCodeToReport
!
=
SSL_ERROR_BAD_CERT_DOMAIN
)
{
Input
certInput
;
if
(
certInput
.
Init
(
cert
-
>
derCert
.
data
cert
-
>
derCert
.
len
)
!
=
Success
)
{
PR_SetError
(
SEC_ERROR_BAD_DER
0
)
;
return
SECFailure
;
}
Input
hostnameInput
;
Result
result
=
hostnameInput
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
hostName
.
BeginReading
(
)
)
hostName
.
Length
(
)
)
;
if
(
result
!
=
Success
)
{
PR_SetError
(
SEC_ERROR_INVALID_ARGS
0
)
;
return
SECFailure
;
}
BRNameMatchingPolicy
nameMatchingPolicy
(
BRNameMatchingPolicy
:
:
Mode
:
:
DoNotEnforce
)
;
result
=
CheckCertHostname
(
certInput
hostnameInput
nameMatchingPolicy
)
;
if
(
result
=
=
Result
:
:
ERROR_BAD_DER
|
|
result
=
=
Result
:
:
ERROR_BAD_CERT_DOMAIN
)
{
collectedErrors
|
=
nsICertOverrideService
:
:
ERROR_MISMATCH
;
errorCodeMismatch
=
SSL_ERROR_BAD_CERT_DOMAIN
;
}
else
if
(
IsFatalError
(
result
)
)
{
PR_SetError
(
MapResultToPRErrorCode
(
result
)
0
)
;
return
SECFailure
;
}
}
return
SECSuccess
;
}
static
nsresult
OverrideAllowedForHost
(
uint64_t
aPtrForLog
const
nsACString
&
aHostname
const
OriginAttributes
&
aOriginAttributes
uint32_t
aProviderFlags
bool
&
aOverrideAllowed
)
{
aOverrideAllowed
=
false
;
if
(
net_IsValidIPv6Addr
(
aHostname
)
)
{
aOverrideAllowed
=
true
;
return
NS_OK
;
}
bool
strictTransportSecurityEnabled
=
false
;
bool
hasPinningInformation
=
false
;
nsCOMPtr
<
nsISiteSecurityService
>
sss
(
do_GetService
(
NS_SSSERVICE_CONTRACTID
)
)
;
if
(
!
sss
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
Couldn
'
t
get
nsISiteSecurityService
to
check
HSTS
/
HPKP
"
aPtrForLog
)
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
NS_LITERAL_CSTRING
(
"
https
:
/
/
"
)
+
aHostname
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
Creating
new
URI
failed
"
aPtrForLog
)
)
;
return
rv
;
}
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HSTS
uri
aProviderFlags
aOriginAttributes
nullptr
nullptr
&
strictTransportSecurityEnabled
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
checking
for
HSTS
failed
"
aPtrForLog
)
)
;
return
rv
;
}
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HPKP
uri
aProviderFlags
aOriginAttributes
nullptr
nullptr
&
hasPinningInformation
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
checking
for
HPKP
failed
"
aPtrForLog
)
)
;
return
rv
;
}
aOverrideAllowed
=
!
strictTransportSecurityEnabled
&
&
!
hasPinningInformation
;
return
NS_OK
;
}
class
SSLServerCertVerificationJob
:
public
Runnable
{
public
:
static
SECStatus
Dispatch
(
const
RefPtr
<
SharedCertVerifier
>
&
certVerifier
const
void
*
fdForLogging
TransportSecurityInfo
*
infoObject
const
UniqueCERTCertificate
&
serverCert
UniqueCERTCertList
&
peerCertChain
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
Time
time
PRTime
prtime
uint32_t
certVerifierFlags
)
;
private
:
NS_DECL_NSIRUNNABLE
SSLServerCertVerificationJob
(
const
RefPtr
<
SharedCertVerifier
>
&
certVerifier
const
void
*
fdForLogging
TransportSecurityInfo
*
infoObject
const
UniqueCERTCertificate
&
cert
UniqueCERTCertList
peerCertChain
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
Time
time
PRTime
prtime
uint32_t
certVerifierFlags
)
;
const
RefPtr
<
SharedCertVerifier
>
mCertVerifier
;
const
void
*
const
mFdForLogging
;
const
RefPtr
<
TransportSecurityInfo
>
mInfoObject
;
const
UniqueCERTCertificate
mCert
;
UniqueCERTCertList
mPeerCertChain
;
const
uint32_t
mProviderFlags
;
const
uint32_t
mCertVerifierFlags
;
const
Time
mTime
;
const
PRTime
mPRTime
;
Maybe
<
nsTArray
<
uint8_t
>
>
mStapledOCSPResponse
;
Maybe
<
nsTArray
<
uint8_t
>
>
mSCTsFromTLSExtension
;
Maybe
<
DelegatedCredentialInfo
>
mDCInfo
;
}
;
SSLServerCertVerificationJob
:
:
SSLServerCertVerificationJob
(
const
RefPtr
<
SharedCertVerifier
>
&
certVerifier
const
void
*
fdForLogging
TransportSecurityInfo
*
infoObject
const
UniqueCERTCertificate
&
cert
UniqueCERTCertList
peerCertChain
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
Time
time
PRTime
prtime
uint32_t
certVerifierFlags
)
:
Runnable
(
"
psm
:
:
SSLServerCertVerificationJob
"
)
mCertVerifier
(
certVerifier
)
mFdForLogging
(
fdForLogging
)
mInfoObject
(
infoObject
)
mCert
(
CERT_DupCertificate
(
cert
.
get
(
)
)
)
mPeerCertChain
(
std
:
:
move
(
peerCertChain
)
)
mProviderFlags
(
providerFlags
)
mCertVerifierFlags
(
certVerifierFlags
)
mTime
(
time
)
mPRTime
(
prtime
)
mStapledOCSPResponse
(
std
:
:
move
(
stapledOCSPResponse
)
)
mSCTsFromTLSExtension
(
std
:
:
move
(
sctsFromTLSExtension
)
)
mDCInfo
(
std
:
:
move
(
dcInfo
)
)
{
}
static
SECStatus
BlockServerCertChangeForSpdy
(
nsNSSSocketInfo
*
infoObject
const
UniqueCERTCertificate
&
serverCert
)
{
nsCOMPtr
<
nsIX509Cert
>
cert
;
if
(
!
infoObject
-
>
IsHandshakeCompleted
(
)
)
{
return
SECSuccess
;
}
infoObject
-
>
GetServerCert
(
getter_AddRefs
(
cert
)
)
;
if
(
!
cert
)
{
MOZ_ASSERT_UNREACHABLE
(
"
TransportSecurityInfo
must
have
a
cert
implementing
nsIX509Cert
"
)
;
PR_SetError
(
SEC_ERROR_LIBRARY_FAILURE
0
)
;
return
SECFailure
;
}
nsAutoCString
negotiatedNPN
;
nsresult
rv
=
infoObject
-
>
GetNegotiatedNPN
(
negotiatedNPN
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
GetNegotiatedNPN
(
)
failed
during
renegotiation
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
StringBeginsWith
(
negotiatedNPN
NS_LITERAL_CSTRING
(
"
spdy
/
"
)
)
)
{
return
SECSuccess
;
}
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BlockServerCertChangeForSpdy
failed
GetNegotiatedNPN
(
)
call
.
"
"
Assuming
spdy
.
\
n
"
)
)
;
}
UniqueCERTCertificate
c
(
cert
-
>
GetCert
(
)
)
;
MOZ_ASSERT
(
c
"
Somehow
couldn
'
t
get
underlying
cert
from
nsIX509Cert
"
)
;
bool
sameCert
=
CERT_CompareCerts
(
c
.
get
(
)
serverCert
.
get
(
)
)
;
if
(
sameCert
)
{
return
SECSuccess
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SPDY
Refused
to
allow
new
cert
during
renegotiation
\
n
"
)
)
;
PR_SetError
(
SSL_ERROR_RENEGOTIATION_NOT_ALLOWED
0
)
;
return
SECFailure
;
}
void
AccumulateSubjectCommonNameTelemetry
(
const
char
*
commonName
bool
commonNameInSubjectAltNames
)
{
if
(
!
commonName
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_2_SUBJECT_COMMON_NAME
1
)
;
}
else
if
(
!
commonNameInSubjectAltNames
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
common
name
'
%
s
'
not
in
subject
alt
.
names
"
"
(
or
the
subject
alt
.
names
extension
is
not
present
)
\
n
"
commonName
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_2_SUBJECT_COMMON_NAME
2
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_2_SUBJECT_COMMON_NAME
0
)
;
}
}
static
bool
TryMatchingWildcardSubjectAltName
(
const
char
*
commonName
const
nsACString
&
altName
)
{
return
commonName
&
&
StringEndsWith
(
nsDependentCString
(
commonName
)
Substring
(
altName
1
)
)
;
}
void
GatherBaselineRequirementsTelemetry
(
const
UniqueCERTCertList
&
certList
)
{
CERTCertListNode
*
endEntityNode
=
CERT_LIST_HEAD
(
certList
)
;
CERTCertListNode
*
rootNode
=
CERT_LIST_TAIL
(
certList
)
;
MOZ_ASSERT
(
!
(
CERT_LIST_END
(
endEntityNode
certList
)
|
|
CERT_LIST_END
(
rootNode
certList
)
)
)
;
if
(
CERT_LIST_END
(
endEntityNode
certList
)
|
|
CERT_LIST_END
(
rootNode
certList
)
)
{
return
;
}
CERTCertificate
*
cert
=
endEntityNode
-
>
cert
;
MOZ_ASSERT
(
cert
)
;
if
(
!
cert
)
{
return
;
}
UniquePORTString
commonName
(
CERT_GetCommonName
(
&
cert
-
>
subject
)
)
;
CERTCertificate
*
rootCert
=
rootNode
-
>
cert
;
MOZ_ASSERT
(
rootCert
)
;
if
(
!
rootCert
)
{
return
;
}
bool
isBuiltIn
=
false
;
Result
result
=
IsCertBuiltInRoot
(
rootCert
isBuiltIn
)
;
if
(
result
!
=
Success
|
|
!
isBuiltIn
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
root
certificate
for
'
%
s
'
is
not
a
built
-
in
root
"
"
(
or
IsCertBuiltInRoot
failed
)
\
n
"
commonName
.
get
(
)
)
)
;
return
;
}
ScopedAutoSECItem
altNameExtension
;
SECStatus
rv
=
CERT_FindCertExtension
(
cert
SEC_OID_X509_SUBJECT_ALT_NAME
&
altNameExtension
)
;
if
(
rv
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
no
subject
alt
names
extension
for
'
%
s
'
\
n
"
commonName
.
get
(
)
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_1_SUBJECT_ALT_NAMES
1
)
;
AccumulateSubjectCommonNameTelemetry
(
commonName
.
get
(
)
false
)
;
return
;
}
UniquePLArenaPool
arena
(
PORT_NewArena
(
DER_DEFAULT_CHUNKSIZE
)
)
;
CERTGeneralName
*
subjectAltNames
=
CERT_DecodeAltNameExtension
(
arena
.
get
(
)
&
altNameExtension
)
;
if
(
!
subjectAltNames
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
could
not
decode
subject
alt
names
for
'
%
s
'
\
n
"
commonName
.
get
(
)
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_1_SUBJECT_ALT_NAMES
2
)
;
AccumulateSubjectCommonNameTelemetry
(
commonName
.
get
(
)
false
)
;
return
;
}
CERTGeneralName
*
currentName
=
subjectAltNames
;
bool
commonNameInSubjectAltNames
=
false
;
bool
nonDNSNameOrIPAddressPresent
=
false
;
bool
malformedDNSNameOrIPAddressPresent
=
false
;
bool
nonFQDNPresent
=
false
;
do
{
nsAutoCString
altName
;
if
(
currentName
-
>
type
=
=
certDNSName
)
{
altName
.
Assign
(
BitwiseCast
<
char
*
unsigned
char
*
>
(
currentName
-
>
name
.
other
.
data
)
currentName
-
>
name
.
other
.
len
)
;
nsDependentCString
altNameWithoutWildcard
(
altName
0
)
;
if
(
StringBeginsWith
(
altNameWithoutWildcard
NS_LITERAL_CSTRING
(
"
*
.
"
)
)
)
{
altNameWithoutWildcard
.
Rebind
(
altName
2
)
;
commonNameInSubjectAltNames
|
=
TryMatchingWildcardSubjectAltName
(
commonName
.
get
(
)
altName
)
;
}
if
(
!
net_IsValidHostName
(
altNameWithoutWildcard
)
|
|
net_IsValidIPv4Addr
(
altName
)
|
|
net_IsValidIPv6Addr
(
altName
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
DNSName
'
%
s
'
not
valid
(
for
'
%
s
'
)
\
n
"
altName
.
get
(
)
commonName
.
get
(
)
)
)
;
malformedDNSNameOrIPAddressPresent
=
true
;
}
if
(
!
altName
.
Contains
(
'
.
'
)
)
{
nonFQDNPresent
=
true
;
}
}
else
if
(
currentName
-
>
type
=
=
certIPAddress
)
{
char
buf
[
net
:
:
kNetAddrMaxCStrBufSize
]
=
{
0
}
;
PRNetAddr
addr
;
if
(
currentName
-
>
name
.
other
.
len
=
=
4
)
{
addr
.
inet
.
family
=
PR_AF_INET
;
memcpy
(
&
addr
.
inet
.
ip
currentName
-
>
name
.
other
.
data
currentName
-
>
name
.
other
.
len
)
;
if
(
PR_NetAddrToString
(
&
addr
buf
sizeof
(
buf
)
-
1
)
!
=
PR_SUCCESS
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
IPAddress
(
v4
)
not
valid
(
for
'
%
s
'
)
\
n
"
commonName
.
get
(
)
)
)
;
malformedDNSNameOrIPAddressPresent
=
true
;
}
else
{
altName
.
Assign
(
buf
)
;
}
}
else
if
(
currentName
-
>
name
.
other
.
len
=
=
16
)
{
addr
.
inet
.
family
=
PR_AF_INET6
;
memcpy
(
&
addr
.
ipv6
.
ip
currentName
-
>
name
.
other
.
data
currentName
-
>
name
.
other
.
len
)
;
if
(
PR_NetAddrToString
(
&
addr
buf
sizeof
(
buf
)
-
1
)
!
=
PR_SUCCESS
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
IPAddress
(
v6
)
not
valid
(
for
'
%
s
'
)
\
n
"
commonName
.
get
(
)
)
)
;
malformedDNSNameOrIPAddressPresent
=
true
;
}
else
{
altName
.
Assign
(
buf
)
;
}
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
IPAddress
not
valid
(
for
'
%
s
'
)
\
n
"
commonName
.
get
(
)
)
)
;
malformedDNSNameOrIPAddressPresent
=
true
;
}
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BR
telemetry
:
non
-
DNSName
non
-
IPAddress
present
for
'
%
s
'
\
n
"
commonName
.
get
(
)
)
)
;
nonDNSNameOrIPAddressPresent
=
true
;
}
if
(
commonName
&
&
altName
.
Equals
(
commonName
.
get
(
)
)
)
{
commonNameInSubjectAltNames
=
true
;
}
currentName
=
CERT_GetNextGeneralName
(
currentName
)
;
}
while
(
currentName
&
&
currentName
!
=
subjectAltNames
)
;
if
(
nonDNSNameOrIPAddressPresent
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_1_SUBJECT_ALT_NAMES
3
)
;
}
if
(
malformedDNSNameOrIPAddressPresent
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_1_SUBJECT_ALT_NAMES
4
)
;
}
if
(
nonFQDNPresent
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_1_SUBJECT_ALT_NAMES
5
)
;
}
if
(
!
nonDNSNameOrIPAddressPresent
&
&
!
malformedDNSNameOrIPAddressPresent
&
&
!
nonFQDNPresent
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BR_9_2_1_SUBJECT_ALT_NAMES
0
)
;
}
AccumulateSubjectCommonNameTelemetry
(
commonName
.
get
(
)
commonNameInSubjectAltNames
)
;
}
void
GatherEKUTelemetry
(
const
UniqueCERTCertList
&
certList
)
{
CERTCertListNode
*
endEntityNode
=
CERT_LIST_HEAD
(
certList
)
;
CERTCertListNode
*
rootNode
=
CERT_LIST_TAIL
(
certList
)
;
MOZ_ASSERT
(
!
(
CERT_LIST_END
(
endEntityNode
certList
)
|
|
CERT_LIST_END
(
rootNode
certList
)
)
)
;
if
(
CERT_LIST_END
(
endEntityNode
certList
)
|
|
CERT_LIST_END
(
rootNode
certList
)
)
{
return
;
}
CERTCertificate
*
endEntityCert
=
endEntityNode
-
>
cert
;
MOZ_ASSERT
(
endEntityCert
)
;
if
(
!
endEntityCert
)
{
return
;
}
CERTCertificate
*
rootCert
=
rootNode
-
>
cert
;
MOZ_ASSERT
(
rootCert
)
;
if
(
!
rootCert
)
{
return
;
}
bool
isBuiltIn
=
false
;
Result
rv
=
IsCertBuiltInRoot
(
rootCert
isBuiltIn
)
;
if
(
rv
!
=
Success
|
|
!
isBuiltIn
)
{
return
;
}
bool
foundEKU
=
false
;
SECOidTag
oidTag
;
CERTCertExtension
*
ekuExtension
=
nullptr
;
for
(
size_t
i
=
0
;
endEntityCert
-
>
extensions
&
&
endEntityCert
-
>
extensions
[
i
]
;
i
+
+
)
{
oidTag
=
SECOID_FindOIDTag
(
&
endEntityCert
-
>
extensions
[
i
]
-
>
id
)
;
if
(
oidTag
=
=
SEC_OID_X509_EXT_KEY_USAGE
)
{
foundEKU
=
true
;
ekuExtension
=
endEntityCert
-
>
extensions
[
i
]
;
}
}
if
(
!
foundEKU
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SERVER_AUTH_EKU
0
)
;
return
;
}
UniqueCERTOidSequence
ekuSequence
(
CERT_DecodeOidSequence
(
&
ekuExtension
-
>
value
)
)
;
if
(
!
ekuSequence
)
{
return
;
}
bool
foundServerAuth
=
false
;
bool
foundOther
=
false
;
for
(
SECItem
*
*
oids
=
ekuSequence
-
>
oids
;
oids
&
&
*
oids
;
oids
+
+
)
{
oidTag
=
SECOID_FindOIDTag
(
*
oids
)
;
if
(
oidTag
=
=
SEC_OID_EXT_KEY_USAGE_SERVER_AUTH
)
{
foundServerAuth
=
true
;
}
else
{
foundOther
=
true
;
}
}
if
(
foundServerAuth
&
&
!
foundOther
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SERVER_AUTH_EKU
1
)
;
}
else
if
(
foundServerAuth
&
&
foundOther
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SERVER_AUTH_EKU
2
)
;
}
else
if
(
!
foundServerAuth
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SERVER_AUTH_EKU
3
)
;
}
}
void
GatherRootCATelemetry
(
const
UniqueCERTCertList
&
certList
)
{
CERTCertListNode
*
rootNode
=
CERT_LIST_TAIL
(
certList
)
;
MOZ_ASSERT
(
rootNode
)
;
if
(
!
rootNode
)
{
return
;
}
MOZ_ASSERT
(
!
CERT_LIST_END
(
rootNode
certList
)
)
;
if
(
CERT_LIST_END
(
rootNode
certList
)
)
{
return
;
}
CERTCertificate
*
rootCert
=
rootNode
-
>
cert
;
MOZ_ASSERT
(
rootCert
)
;
if
(
!
rootCert
)
{
return
;
}
AccumulateTelemetryForRootCA
(
Telemetry
:
:
CERT_VALIDATION_SUCCESS_BY_CA
rootCert
)
;
}
void
GatherSuccessfulValidationTelemetry
(
const
UniqueCERTCertList
&
certList
)
{
GatherBaselineRequirementsTelemetry
(
certList
)
;
GatherEKUTelemetry
(
certList
)
;
GatherRootCATelemetry
(
certList
)
;
}
void
GatherTelemetryForSingleSCT
(
const
ct
:
:
VerifiedSCT
&
verifiedSct
)
{
uint32_t
origin
=
0
;
switch
(
verifiedSct
.
origin
)
{
case
ct
:
:
VerifiedSCT
:
:
Origin
:
:
Embedded
:
origin
=
1
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Origin
:
:
TLSExtension
:
origin
=
2
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Origin
:
:
OCSPResponse
:
origin
=
3
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
VerifiedSCT
:
:
Origin
type
"
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SCTS_ORIGIN
origin
)
;
uint32_t
verificationStatus
=
0
;
switch
(
verifiedSct
.
status
)
{
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
Valid
:
verificationStatus
=
1
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
UnknownLog
:
verificationStatus
=
2
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
InvalidSignature
:
verificationStatus
=
3
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
InvalidTimestamp
:
verificationStatus
=
4
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
ValidFromDisqualifiedLog
:
verificationStatus
=
5
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
VerifiedSCT
:
:
Status
type
"
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SCTS_VERIFICATION_STATUS
verificationStatus
)
;
}
void
GatherCertificateTransparencyTelemetry
(
const
UniqueCERTCertList
&
certList
bool
isEV
const
CertificateTransparencyInfo
&
info
)
{
if
(
!
info
.
enabled
)
{
return
;
}
for
(
const
ct
:
:
VerifiedSCT
&
sct
:
info
.
verifyResult
.
verifiedScts
)
{
GatherTelemetryForSingleSCT
(
sct
)
;
}
for
(
size_t
i
=
0
;
i
<
info
.
verifyResult
.
decodingErrors
;
+
+
i
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SCTS_VERIFICATION_STATUS
0
)
;
}
uint32_t
sctsCount
=
static_cast
<
uint32_t
>
(
info
.
verifyResult
.
verifiedScts
.
size
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SCTS_PER_CONNECTION
sctsCount
)
;
if
(
isEV
)
{
uint32_t
evCompliance
=
0
;
switch
(
info
.
policyCompliance
)
{
case
ct
:
:
CTPolicyCompliance
:
:
Compliant
:
evCompliance
=
1
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
NotEnoughScts
:
evCompliance
=
2
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
NotDiverseScts
:
evCompliance
=
3
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
Unknown
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
CTPolicyCompliance
type
"
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CT_POLICY_COMPLIANCE_OF_EV_CERTS
evCompliance
)
;
}
CERTCertListNode
*
rootNode
=
CERT_LIST_TAIL
(
certList
)
;
MOZ_ASSERT
(
rootNode
)
;
if
(
!
rootNode
)
{
return
;
}
MOZ_ASSERT
(
!
CERT_LIST_END
(
rootNode
certList
)
)
;
if
(
CERT_LIST_END
(
rootNode
certList
)
)
{
return
;
}
CERTCertificate
*
rootCert
=
rootNode
-
>
cert
;
MOZ_ASSERT
(
rootCert
)
;
if
(
!
rootCert
)
{
return
;
}
switch
(
info
.
policyCompliance
)
{
case
ct
:
:
CTPolicyCompliance
:
:
Compliant
:
AccumulateTelemetryForRootCA
(
Telemetry
:
:
SSL_CT_POLICY_COMPLIANT_CONNECTIONS_BY_CA
rootCert
)
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
NotEnoughScts
:
case
ct
:
:
CTPolicyCompliance
:
:
NotDiverseScts
:
AccumulateTelemetryForRootCA
(
Telemetry
:
:
SSL_CT_POLICY_NON_COMPLIANT_CONNECTIONS_BY_CA
rootCert
)
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
Unknown
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
CTPolicyCompliance
type
"
)
;
}
}
static
void
CollectCertTelemetry
(
mozilla
:
:
pkix
:
:
Result
aCertVerificationResult
SECOidTag
aEvOidPolicy
CertVerifier
:
:
OCSPStaplingStatus
aOcspStaplingStatus
KeySizeStatus
aKeySizeStatus
SHA1ModeResult
aSha1ModeResult
const
PinningTelemetryInfo
&
aPinningTelemetryInfo
const
UniqueCERTCertList
&
aBuiltCertChain
const
CertificateTransparencyInfo
&
aCertificateTransparencyInfo
)
{
uint32_t
evStatus
=
(
aCertVerificationResult
!
=
Success
)
?
0
:
(
aEvOidPolicy
=
=
SEC_OID_UNKNOWN
)
?
1
:
2
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_EV_STATUS
evStatus
)
;
if
(
aOcspStaplingStatus
!
=
CertVerifier
:
:
OCSP_STAPLING_NEVER_CHECKED
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_OCSP_STAPLING
aOcspStaplingStatus
)
;
}
if
(
aKeySizeStatus
!
=
KeySizeStatus
:
:
NeverChecked
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_CHAIN_KEY_SIZE_STATUS
static_cast
<
uint32_t
>
(
aKeySizeStatus
)
)
;
}
if
(
aSha1ModeResult
!
=
SHA1ModeResult
:
:
NeverChecked
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_CHAIN_SHA1_POLICY_STATUS
static_cast
<
uint32_t
>
(
aSha1ModeResult
)
)
;
}
if
(
aPinningTelemetryInfo
.
accumulateForRoot
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_PINNING_FAILURES_BY_CA
aPinningTelemetryInfo
.
rootBucket
)
;
}
if
(
aPinningTelemetryInfo
.
accumulateResult
)
{
MOZ_ASSERT
(
aPinningTelemetryInfo
.
certPinningResultHistogram
.
isSome
(
)
)
;
Telemetry
:
:
Accumulate
(
aPinningTelemetryInfo
.
certPinningResultHistogram
.
value
(
)
aPinningTelemetryInfo
.
certPinningResultBucket
)
;
}
if
(
aCertVerificationResult
=
=
Success
)
{
GatherSuccessfulValidationTelemetry
(
aBuiltCertChain
)
;
GatherCertificateTransparencyTelemetry
(
aBuiltCertChain
aEvOidPolicy
!
=
SEC_OID_UNKNOWN
aCertificateTransparencyInfo
)
;
}
}
static
void
AuthCertificateSetResults
(
TransportSecurityInfo
*
aInfoObject
const
UniqueCERTCertificate
&
aCert
UniqueCERTCertList
&
aBuiltCertChain
UniqueCERTCertList
&
aPeerCertChain
const
CertificateTransparencyInfo
&
aCertificateTransparencyInfo
SECOidTag
aEvOidPolicy
bool
aSucceeded
)
{
MOZ_ASSERT
(
aInfoObject
)
;
if
(
aSucceeded
)
{
RememberCertErrorsTable
:
:
GetInstance
(
)
.
RememberCertHasError
(
aInfoObject
SECSuccess
)
;
EVStatus
evStatus
;
if
(
aEvOidPolicy
=
=
SEC_OID_UNKNOWN
)
{
evStatus
=
EVStatus
:
:
NotEV
;
}
else
{
evStatus
=
EVStatus
:
:
EV
;
}
RefPtr
<
nsNSSCertificate
>
nsc
=
nsNSSCertificate
:
:
Create
(
aCert
.
get
(
)
)
;
aInfoObject
-
>
SetServerCert
(
nsc
evStatus
)
;
aInfoObject
-
>
SetSucceededCertChain
(
std
:
:
move
(
aBuiltCertChain
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
AuthCertificate
setting
NEW
cert
%
p
"
nsc
.
get
(
)
)
)
;
aInfoObject
-
>
SetCertificateTransparencyInfo
(
aCertificateTransparencyInfo
)
;
}
else
{
aInfoObject
-
>
SetFailedCertChain
(
std
:
:
move
(
aPeerCertChain
)
)
;
}
}
Result
AuthCertificate
(
CertVerifier
&
certVerifier
TransportSecurityInfo
*
infoObject
const
UniqueCERTCertificate
&
cert
UniqueCERTCertList
&
peerCertChain
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
const
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
Time
time
uint32_t
certVerifierFlags
)
{
MOZ_ASSERT
(
infoObject
)
;
MOZ_ASSERT
(
cert
)
;
bool
saveIntermediates
=
!
(
providerFlags
&
nsISocketProvider
:
:
NO_PERMANENT_STORAGE
)
;
SECOidTag
evOidPolicy
;
UniqueCERTCertList
builtCertChain
;
CertVerifier
:
:
OCSPStaplingStatus
ocspStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_NEVER_CHECKED
;
KeySizeStatus
keySizeStatus
=
KeySizeStatus
:
:
NeverChecked
;
SHA1ModeResult
sha1ModeResult
=
SHA1ModeResult
:
:
NeverChecked
;
PinningTelemetryInfo
pinningTelemetryInfo
;
CertificateTransparencyInfo
certificateTransparencyInfo
;
nsTArray
<
nsTArray
<
uint8_t
>
>
peerCertsBytes
;
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
peerCertChain
)
;
!
CERT_LIST_END
(
n
peerCertChain
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
if
(
n
=
=
CERT_LIST_HEAD
(
peerCertChain
)
)
{
continue
;
}
nsTArray
<
uint8_t
>
certBytes
;
certBytes
.
AppendElements
(
n
-
>
cert
-
>
derCert
.
data
n
-
>
cert
-
>
derCert
.
len
)
;
peerCertsBytes
.
AppendElement
(
std
:
:
move
(
certBytes
)
)
;
}
Result
rv
=
certVerifier
.
VerifySSLServerCert
(
cert
time
infoObject
infoObject
-
>
GetHostName
(
)
builtCertChain
certVerifierFlags
Some
(
peerCertsBytes
)
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
infoObject
-
>
GetOriginAttributes
(
)
saveIntermediates
&
evOidPolicy
&
ocspStaplingStatus
&
keySizeStatus
&
sha1ModeResult
&
pinningTelemetryInfo
&
certificateTransparencyInfo
)
;
CollectCertTelemetry
(
rv
evOidPolicy
ocspStaplingStatus
keySizeStatus
sha1ModeResult
pinningTelemetryInfo
builtCertChain
certificateTransparencyInfo
)
;
AuthCertificateSetResults
(
infoObject
cert
builtCertChain
peerCertChain
certificateTransparencyInfo
evOidPolicy
rv
=
=
Success
)
;
return
rv
;
}
SECStatus
SSLServerCertVerificationJob
:
:
Dispatch
(
const
RefPtr
<
SharedCertVerifier
>
&
certVerifier
const
void
*
fdForLogging
TransportSecurityInfo
*
infoObject
const
UniqueCERTCertificate
&
serverCert
UniqueCERTCertList
&
peerCertChain
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
Time
time
PRTime
prtime
uint32_t
certVerifierFlags
)
{
if
(
!
certVerifier
|
|
!
infoObject
|
|
!
serverCert
)
{
NS_ERROR
(
"
Invalid
parameters
for
SSL
server
cert
validation
"
)
;
PR_SetError
(
PR_INVALID_ARGUMENT_ERROR
0
)
;
return
SECFailure
;
}
if
(
!
gCertVerificationThreadPool
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
UniqueCERTCertList
peerCertChainCopy
=
std
:
:
move
(
peerCertChain
)
;
RefPtr
<
SSLServerCertVerificationJob
>
job
(
new
SSLServerCertVerificationJob
(
certVerifier
fdForLogging
infoObject
serverCert
std
:
:
move
(
peerCertChainCopy
)
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
time
prtime
certVerifierFlags
)
)
;
nsresult
nrv
=
gCertVerificationThreadPool
-
>
Dispatch
(
job
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
nrv
)
)
{
PRErrorCode
error
=
nrv
=
=
NS_ERROR_OUT_OF_MEMORY
?
PR_OUT_OF_MEMORY_ERROR
:
PR_INVALID_STATE_ERROR
;
PR_SetError
(
error
0
)
;
return
SECFailure
;
}
PR_SetError
(
PR_WOULD_BLOCK_ERROR
0
)
;
return
SECWouldBlock
;
}
PRErrorCode
AuthCertificateParseResults
(
uint64_t
aPtrForLog
const
nsACString
&
aHostName
int32_t
aPort
const
OriginAttributes
&
aOriginAttributes
const
UniqueCERTCertificate
&
aCert
uint32_t
aProviderFlags
PRTime
aPRTime
PRErrorCode
aDefaultErrorCodeToReport
uint32_t
&
aCollectedErrors
)
{
if
(
aDefaultErrorCodeToReport
=
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
error
set
during
certificate
validation
failure
"
)
;
return
SEC_ERROR_LIBRARY_FAILURE
;
}
uint32_t
probeValue
=
MapCertErrorToProbeValue
(
aDefaultErrorCodeToReport
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CERT_VERIFICATION_ERRORS
probeValue
)
;
aCollectedErrors
=
0
;
PRErrorCode
errorCodeTrust
=
0
;
PRErrorCode
errorCodeMismatch
=
0
;
PRErrorCode
errorCodeTime
=
0
;
if
(
DetermineCertOverrideErrors
(
aCert
aHostName
aPRTime
aDefaultErrorCodeToReport
aCollectedErrors
errorCodeTrust
errorCodeMismatch
errorCodeTime
)
!
=
SECSuccess
)
{
PRErrorCode
errorCode
=
PR_GetError
(
)
;
MOZ_ASSERT
(
!
ErrorIsOverridable
(
errorCode
)
)
;
if
(
errorCode
=
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
error
set
during
DetermineCertOverrideErrors
failure
"
)
;
return
SEC_ERROR_LIBRARY_FAILURE
;
}
return
errorCode
;
}
if
(
!
aCollectedErrors
)
{
MOZ_ASSERT_UNREACHABLE
(
"
aCollectedErrors
should
not
be
0
"
)
;
return
SEC_ERROR_LIBRARY_FAILURE
;
}
bool
overrideAllowed
=
false
;
if
(
NS_FAILED
(
OverrideAllowedForHost
(
aPtrForLog
aHostName
aOriginAttributes
aProviderFlags
overrideAllowed
)
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
AuthCertificateParseResults
-
"
"
OverrideAllowedForHost
failed
\
n
"
aPtrForLog
)
)
;
return
aDefaultErrorCodeToReport
;
}
if
(
overrideAllowed
)
{
nsCOMPtr
<
nsICertOverrideService
>
overrideService
=
do_GetService
(
NS_CERTOVERRIDE_CONTRACTID
)
;
uint32_t
overrideBits
=
0
;
uint32_t
remainingDisplayErrors
=
aCollectedErrors
;
if
(
overrideService
)
{
bool
haveOverride
;
bool
isTemporaryOverride
;
RefPtr
<
nsIX509Cert
>
nssCert
(
nsNSSCertificate
:
:
Create
(
aCert
.
get
(
)
)
)
;
if
(
!
nssCert
)
{
MOZ_ASSERT
(
false
"
nsNSSCertificate
:
:
Create
failed
"
)
;
return
SEC_ERROR_NO_MEMORY
;
}
nsresult
rv
=
overrideService
-
>
HasMatchingOverride
(
aHostName
aPort
nssCert
&
overrideBits
&
isTemporaryOverride
&
haveOverride
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
haveOverride
)
{
remainingDisplayErrors
&
=
~
overrideBits
;
}
}
if
(
!
remainingDisplayErrors
)
{
if
(
errorCodeTrust
!
=
0
)
{
uint32_t
probeValue
=
MapOverridableErrorToProbeValue
(
errorCodeTrust
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CERT_ERROR_OVERRIDES
probeValue
)
;
}
if
(
errorCodeMismatch
!
=
0
)
{
uint32_t
probeValue
=
MapOverridableErrorToProbeValue
(
errorCodeMismatch
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CERT_ERROR_OVERRIDES
probeValue
)
;
}
if
(
errorCodeTime
!
=
0
)
{
uint32_t
probeValue
=
MapOverridableErrorToProbeValue
(
errorCodeTime
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CERT_ERROR_OVERRIDES
probeValue
)
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
All
errors
covered
by
override
rules
"
aPtrForLog
)
)
;
return
0
;
}
}
else
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
HSTS
or
HPKP
-
no
overrides
allowed
\
n
"
aPtrForLog
)
)
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
Certificate
error
was
not
overridden
\
n
"
aPtrForLog
)
)
;
return
errorCodeTrust
?
errorCodeTrust
:
errorCodeMismatch
?
errorCodeMismatch
:
errorCodeTime
?
errorCodeTime
:
aDefaultErrorCodeToReport
;
}
NS_IMETHODIMP
SSLServerCertVerificationJob
:
:
Run
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
%
p
]
SSLServerCertVerificationJob
:
:
Run
\
n
"
mInfoObject
.
get
(
)
)
)
;
TimeStamp
jobStartTime
=
TimeStamp
:
:
Now
(
)
;
Result
rv
=
AuthCertificate
(
*
mCertVerifier
mInfoObject
mCert
mPeerCertChain
mStapledOCSPResponse
mSCTsFromTLSExtension
mDCInfo
mProviderFlags
mTime
mCertVerifierFlags
)
;
MOZ_ASSERT
(
(
mPeerCertChain
&
&
rv
=
=
Success
)
|
|
(
!
mPeerCertChain
&
&
rv
!
=
Success
)
"
AuthCertificate
(
)
should
take
ownership
of
chain
on
failure
"
)
;
if
(
rv
=
=
Success
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
SSL_SUCCESFUL_CERT_VALIDATION_TIME_MOZILLAPKIX
jobStartTime
TimeStamp
:
:
Now
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CERT_ERROR_OVERRIDES
1
)
;
RefPtr
<
SSLServerCertVerificationResult
>
runnable
(
new
SSLServerCertVerificationResult
(
mInfoObject
0
)
)
;
runnable
-
>
Dispatch
(
)
;
return
NS_OK
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
SSL_INITIAL_FAILED_CERT_VALIDATION_TIME_MOZILLAPKIX
jobStartTime
TimeStamp
:
:
Now
(
)
)
;
PRErrorCode
error
=
MapResultToPRErrorCode
(
rv
)
;
uint64_t
addr
=
reinterpret_cast
<
uintptr_t
>
(
mFdForLogging
)
;
uint32_t
collectedErrors
=
0
;
PRErrorCode
finalError
=
AuthCertificateParseResults
(
addr
mInfoObject
-
>
GetHostName
(
)
mInfoObject
-
>
GetPort
(
)
mInfoObject
-
>
GetOriginAttributes
(
)
mCert
mProviderFlags
mPRTime
error
collectedErrors
)
;
if
(
collectedErrors
!
=
0
)
{
RefPtr
<
nsNSSCertificate
>
nssCert
(
nsNSSCertificate
:
:
Create
(
mCert
.
get
(
)
)
)
;
mInfoObject
-
>
SetStatusErrorBits
(
nssCert
collectedErrors
)
;
}
RefPtr
<
SSLServerCertVerificationResult
>
resultRunnable
(
new
SSLServerCertVerificationResult
(
mInfoObject
finalError
)
)
;
resultRunnable
-
>
Dispatch
(
)
;
return
NS_OK
;
}
}
SECStatus
AuthCertificateHookInternal
(
TransportSecurityInfo
*
infoObject
const
void
*
aPtrForLogging
const
UniqueCERTCertificate
&
serverCert
UniqueCERTCertList
&
peerCertChain
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
uint32_t
certVerifierFlags
)
{
RefPtr
<
SharedCertVerifier
>
certVerifier
(
GetDefaultCertVerifier
(
)
)
;
if
(
!
certVerifier
)
{
PR_SetError
(
SEC_ERROR_NOT_INITIALIZED
0
)
;
return
SECFailure
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
%
p
]
starting
AuthCertificateHookInternal
\
n
"
aPtrForLogging
)
)
;
if
(
!
infoObject
|
|
!
serverCert
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
bool
onSTSThread
;
nsresult
nrv
;
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
nrv
)
;
if
(
NS_SUCCEEDED
(
nrv
)
)
{
nrv
=
sts
-
>
IsOnCurrentThread
(
&
onSTSThread
)
;
}
if
(
NS_FAILED
(
nrv
)
)
{
NS_ERROR
(
"
Could
not
get
STS
service
or
IsOnCurrentThread
failed
"
)
;
PR_SetError
(
PR_UNKNOWN_ERROR
0
)
;
return
SECFailure
;
}
MOZ_ASSERT
(
onSTSThread
)
;
if
(
!
onSTSThread
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
return
SSLServerCertVerificationJob
:
:
Dispatch
(
certVerifier
aPtrForLogging
infoObject
serverCert
peerCertChain
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
Now
(
)
PR_Now
(
)
certVerifierFlags
)
;
}
SECStatus
AuthCertificateHook
(
void
*
arg
PRFileDesc
*
fd
PRBool
checkSig
PRBool
isServer
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
%
p
]
starting
AuthCertificateHook
\
n
"
fd
)
)
;
MOZ_ASSERT
(
checkSig
"
AuthCertificateHook
:
checkSig
unexpectedly
false
"
)
;
MOZ_ASSERT
(
!
isServer
"
AuthCertificateHook
:
isServer
unexpectedly
true
"
)
;
nsNSSSocketInfo
*
socketInfo
=
static_cast
<
nsNSSSocketInfo
*
>
(
arg
)
;
UniqueCERTCertificate
serverCert
(
SSL_PeerCertificate
(
fd
)
)
;
if
(
!
checkSig
|
|
isServer
|
|
!
socketInfo
|
|
!
serverCert
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
socketInfo
-
>
SetFullHandshake
(
)
;
if
(
BlockServerCertChangeForSpdy
(
socketInfo
serverCert
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
UniqueCERTCertList
peerCertChain
(
SSL_PeerCertificateChain
(
fd
)
)
;
if
(
!
peerCertChain
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
const
SECItemArray
*
csa
=
SSL_PeerStapledOCSPResponses
(
fd
)
;
Maybe
<
nsTArray
<
uint8_t
>
>
stapledOCSPResponse
;
if
(
csa
&
&
csa
-
>
len
=
=
1
)
{
stapledOCSPResponse
.
emplace
(
)
;
stapledOCSPResponse
-
>
SetCapacity
(
csa
-
>
items
[
0
]
.
len
)
;
stapledOCSPResponse
-
>
AppendElements
(
csa
-
>
items
[
0
]
.
data
csa
-
>
items
[
0
]
.
len
)
;
}
Maybe
<
nsTArray
<
uint8_t
>
>
sctsFromTLSExtension
;
const
SECItem
*
sctsFromTLSExtensionSECItem
=
SSL_PeerSignedCertTimestamps
(
fd
)
;
if
(
sctsFromTLSExtensionSECItem
)
{
sctsFromTLSExtension
.
emplace
(
)
;
sctsFromTLSExtension
-
>
SetCapacity
(
sctsFromTLSExtensionSECItem
-
>
len
)
;
sctsFromTLSExtension
-
>
AppendElements
(
sctsFromTLSExtensionSECItem
-
>
data
sctsFromTLSExtensionSECItem
-
>
len
)
;
}
uint32_t
providerFlags
=
0
;
socketInfo
-
>
GetProviderFlags
(
&
providerFlags
)
;
uint32_t
certVerifierFlags
=
0
;
if
(
!
socketInfo
-
>
SharedState
(
)
.
IsOCSPStaplingEnabled
(
)
|
|
!
socketInfo
-
>
SharedState
(
)
.
IsOCSPMustStapleEnabled
(
)
)
{
certVerifierFlags
|
=
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
;
}
Maybe
<
DelegatedCredentialInfo
>
dcInfo
;
SSLPreliminaryChannelInfo
channelPreInfo
;
SECStatus
rv
=
SSL_GetPreliminaryChannelInfo
(
fd
&
channelPreInfo
sizeof
(
channelPreInfo
)
)
;
if
(
rv
!
=
SECSuccess
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
if
(
channelPreInfo
.
peerDelegCred
)
{
dcInfo
.
emplace
(
DelegatedCredentialInfo
(
channelPreInfo
.
signatureScheme
channelPreInfo
.
authKeyBits
)
)
;
}
socketInfo
-
>
SetCertVerificationWaiting
(
)
;
return
AuthCertificateHookInternal
(
socketInfo
static_cast
<
const
void
*
>
(
fd
)
serverCert
peerCertChain
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
certVerifierFlags
)
;
}
SECStatus
MakeCertChain
(
nsTArray
<
nsTArray
<
uint8_t
>
>
&
inPeerCertChain
UniqueCERTCertificate
&
outCert
UniqueCERTCertList
&
outCertChain
)
{
for
(
auto
&
certDer
:
inPeerCertChain
)
{
if
(
certDer
.
Length
(
)
>
UINT32_MAX
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
MakeCertChain
:
certDer
too
long
.
"
)
)
;
return
SECFailure
;
}
SECItem
der
=
{
SECItemType
:
:
siBuffer
certDer
.
Elements
(
)
(
uint32_t
)
certDer
.
Length
(
)
}
;
if
(
!
outCert
)
{
outCert
.
reset
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
der
nullptr
false
true
)
)
;
if
(
!
outCert
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
MakeCertChain
:
cert
failed
"
)
)
;
return
SECFailure
;
}
}
UniqueCERTCertificate
tmpCert
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
der
nullptr
false
true
)
)
;
if
(
!
tmpCert
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
MakeCertChain
:
cert
failed
"
)
)
;
return
SECFailure
;
}
if
(
CERT_AddCertToListTail
(
outCertChain
.
get
(
)
tmpCert
.
get
(
)
)
!
=
SECSuccess
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
MakeCertChain
:
getting
cert
chain
failed
"
)
)
;
return
SECFailure
;
}
Unused
<
<
tmpCert
.
release
(
)
;
}
return
SECSuccess
;
}
SECStatus
AuthCertificateHookWithInfo
(
TransportSecurityInfo
*
infoObject
const
void
*
aPtrForLogging
nsTArray
<
nsTArray
<
uint8_t
>
>
&
peerCertChain
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
stapledOCSPResponses
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
uint32_t
providerFlags
)
{
UniqueCERTCertificate
cert
;
UniqueCERTCertList
certChain
(
CERT_NewCertList
(
)
)
;
if
(
!
certChain
)
{
return
SECFailure
;
}
if
(
MakeCertChain
(
peerCertChain
cert
certChain
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
Maybe
<
nsTArray
<
uint8_t
>
>
stapledOCSPResponse
;
if
(
stapledOCSPResponses
&
&
(
stapledOCSPResponses
-
>
Length
(
)
=
=
1
)
)
{
stapledOCSPResponse
.
emplace
(
stapledOCSPResponses
-
>
ElementAt
(
0
)
)
;
}
uint32_t
certVerifierFlags
=
0
;
if
(
!
PublicSSLState
(
)
-
>
IsOCSPStaplingEnabled
(
)
|
|
!
PublicSSLState
(
)
-
>
IsOCSPMustStapleEnabled
(
)
)
{
certVerifierFlags
|
=
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
;
}
Maybe
<
DelegatedCredentialInfo
>
dcInfo
;
return
AuthCertificateHookInternal
(
infoObject
aPtrForLogging
cert
certChain
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
certVerifierFlags
)
;
}
SSLServerCertVerificationResult
:
:
SSLServerCertVerificationResult
(
TransportSecurityInfo
*
infoObject
PRErrorCode
errorCode
)
:
Runnable
(
"
psm
:
:
SSLServerCertVerificationResult
"
)
mInfoObject
(
infoObject
)
mErrorCode
(
errorCode
)
{
}
void
SSLServerCertVerificationResult
:
:
Dispatch
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIEventTarget
>
stsTarget
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
MOZ_ASSERT
(
stsTarget
"
Failed
to
get
socket
transport
service
event
target
"
)
;
rv
=
stsTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
dispatch
SSLServerCertVerificationResult
"
)
;
}
NS_IMETHODIMP
SSLServerCertVerificationResult
:
:
Run
(
)
{
mInfoObject
-
>
SetCertVerificationResult
(
mErrorCode
)
;
return
NS_OK
;
}
}
}
