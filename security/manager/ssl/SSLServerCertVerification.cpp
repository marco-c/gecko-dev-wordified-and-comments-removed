#
include
"
SSLServerCertVerification
.
h
"
#
include
<
cstring
>
#
include
"
CertVerifier
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
ExtendedValidation
.
h
"
#
include
"
NSSCertDBTrustDomain
.
h
"
#
include
"
PSMRunnable
.
h
"
#
include
"
RootCertificateTelemetryUtils
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
SharedCertVerifier
.
h
"
#
include
"
SharedSSLState
.
h
"
#
include
"
TransportSecurityInfo
.
h
"
#
include
"
VerifySSLServerCertChild
.
h
"
#
include
"
cert
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsICertOverrideService
.
h
"
#
include
"
nsIPublicKeyPinningService
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsISocketProvider
.
h
"
#
include
"
nsThreadPool
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nsNSSIOLayer
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsXPCOMCIDInternal
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixcheck
.
h
"
#
include
"
mozpkix
/
pkixnss
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
secerr
.
h
"
#
include
"
secport
.
h
"
#
include
"
ssl
.
h
"
#
include
"
sslerr
.
h
"
#
include
"
sslexp
.
h
"
extern
mozilla
:
:
LazyLogModule
gPIPNSSLog
;
using
namespace
mozilla
:
:
pkix
;
namespace
mozilla
{
namespace
psm
{
nsIThreadPool
*
gCertVerificationThreadPool
=
nullptr
;
void
InitializeSSLServerCertVerificationThreads
(
)
{
gCertVerificationThreadPool
=
new
nsThreadPool
(
)
;
NS_ADDREF
(
gCertVerificationThreadPool
)
;
(
void
)
gCertVerificationThreadPool
-
>
SetIdleThreadLimit
(
5
)
;
(
void
)
gCertVerificationThreadPool
-
>
SetIdleThreadTimeout
(
30
*
1000
)
;
(
void
)
gCertVerificationThreadPool
-
>
SetThreadLimit
(
5
)
;
(
void
)
gCertVerificationThreadPool
-
>
SetName
(
"
SSL
Cert
"
_ns
)
;
}
void
StopSSLServerCertVerificationThreads
(
)
{
if
(
gCertVerificationThreadPool
)
{
gCertVerificationThreadPool
-
>
Shutdown
(
)
;
NS_RELEASE
(
gCertVerificationThreadPool
)
;
}
}
uint32_t
MapOverridableErrorToProbeValue
(
PRErrorCode
errorCode
)
{
switch
(
errorCode
)
{
case
SEC_ERROR_UNKNOWN_ISSUER
:
return
2
;
case
SEC_ERROR_CA_CERT_INVALID
:
return
3
;
case
SEC_ERROR_UNTRUSTED_ISSUER
:
return
4
;
case
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
:
return
5
;
case
SEC_ERROR_UNTRUSTED_CERT
:
return
6
;
case
SEC_ERROR_INADEQUATE_KEY_USAGE
:
return
7
;
case
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
:
return
8
;
case
SSL_ERROR_BAD_CERT_DOMAIN
:
return
9
;
case
SEC_ERROR_EXPIRED_CERTIFICATE
:
return
10
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY
:
return
11
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA
:
return
12
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE
:
return
13
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
:
return
14
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
:
return
15
;
case
SEC_ERROR_INVALID_TIME
:
return
16
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_EMPTY_ISSUER_NAME
:
return
17
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
:
return
18
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
:
return
19
;
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_MITM_DETECTED
:
return
20
;
}
NS_WARNING
(
"
Unknown
certificate
error
code
.
Does
MapOverridableErrorToProbeValue
"
"
handle
everything
in
CategorizeCertificateError
?
"
)
;
return
0
;
}
static
uint32_t
MapCertErrorToProbeValue
(
PRErrorCode
errorCode
)
{
uint32_t
probeValue
;
switch
(
errorCode
)
{
#
define
MOZILLA_PKIX_MAP
(
name
value
nss_name
)
\
case
nss_name
:
\
probeValue
=
value
;
\
break
;
MOZILLA_PKIX_MAP_LIST
#
undef
MOZILLA_PKIX_MAP
default
:
return
0
;
}
static_assert
(
FATAL_ERROR_FLAG
=
=
0x800
"
mozilla
:
:
pkix
:
:
FATAL_ERROR_FLAG
is
not
what
we
were
expecting
"
)
;
if
(
probeValue
&
FATAL_ERROR_FLAG
)
{
probeValue
^
=
FATAL_ERROR_FLAG
;
probeValue
+
=
90
;
}
return
probeValue
;
}
Maybe
<
nsITransportSecurityInfo
:
:
OverridableErrorCategory
>
CategorizeCertificateError
(
PRErrorCode
certificateError
)
{
switch
(
certificateError
)
{
case
SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
:
case
SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
:
case
SEC_ERROR_UNKNOWN_ISSUER
:
case
SEC_ERROR_CA_CERT_INVALID
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_EMPTY_ISSUER_NAME
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_MITM_DETECTED
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA
:
return
Some
(
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_TRUST
)
;
case
SSL_ERROR_BAD_CERT_DOMAIN
:
return
Some
(
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_DOMAIN
)
;
case
SEC_ERROR_INVALID_TIME
:
case
SEC_ERROR_EXPIRED_CERTIFICATE
:
case
mozilla
:
:
pkix
:
:
MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
:
return
Some
(
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_TIME
)
;
default
:
break
;
}
return
Nothing
(
)
;
}
static
nsresult
OverrideAllowedForHost
(
uint64_t
aPtrForLog
const
nsACString
&
aHostname
const
OriginAttributes
&
aOriginAttributes
bool
&
aOverrideAllowed
)
{
aOverrideAllowed
=
false
;
if
(
net_IsValidIPv6Addr
(
aHostname
)
)
{
aOverrideAllowed
=
true
;
return
NS_OK
;
}
bool
strictTransportSecurityEnabled
=
false
;
bool
isStaticallyPinned
=
false
;
nsCOMPtr
<
nsISiteSecurityService
>
sss
(
do_GetService
(
NS_SSSERVICE_CONTRACTID
)
)
;
if
(
!
sss
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
Couldn
'
t
get
nsISiteSecurityService
to
check
HSTS
"
aPtrForLog
)
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
"
https
:
/
/
"
_ns
+
aHostname
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
Creating
new
URI
failed
"
aPtrForLog
)
)
;
return
rv
;
}
rv
=
sss
-
>
IsSecureURI
(
uri
aOriginAttributes
&
strictTransportSecurityEnabled
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
checking
for
HSTS
failed
"
aPtrForLog
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIPublicKeyPinningService
>
pkps
=
do_GetService
(
NS_PKPSERVICE_CONTRACTID
&
rv
)
;
if
(
!
pkps
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
Couldn
'
t
get
nsIPublicKeyPinningService
to
check
pinning
"
aPtrForLog
)
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
pkps
-
>
HostHasPins
(
uri
&
isStaticallyPinned
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
checking
for
static
pin
failed
"
aPtrForLog
)
)
;
return
rv
;
}
aOverrideAllowed
=
!
strictTransportSecurityEnabled
&
&
!
isStaticallyPinned
;
return
NS_OK
;
}
static
SECStatus
BlockServerCertChangeForSpdy
(
nsNSSSocketInfo
*
infoObject
const
UniqueCERTCertificate
&
serverCert
)
{
if
(
!
infoObject
-
>
IsHandshakeCompleted
(
)
)
{
return
SECSuccess
;
}
nsAutoCString
negotiatedNPN
;
nsresult
rv
=
infoObject
-
>
GetNegotiatedNPN
(
negotiatedNPN
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
GetNegotiatedNPN
(
)
failed
during
renegotiation
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
StringBeginsWith
(
negotiatedNPN
"
spdy
/
"
_ns
)
)
{
return
SECSuccess
;
}
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
BlockServerCertChangeForSpdy
failed
GetNegotiatedNPN
(
)
call
.
"
"
Assuming
spdy
.
"
)
)
;
}
nsCOMPtr
<
nsIX509Cert
>
cert
;
infoObject
-
>
GetServerCert
(
getter_AddRefs
(
cert
)
)
;
if
(
!
cert
)
{
PR_SetError
(
SEC_ERROR_LIBRARY_FAILURE
0
)
;
return
SECFailure
;
}
nsTArray
<
uint8_t
>
certDER
;
if
(
NS_FAILED
(
cert
-
>
GetRawDER
(
certDER
)
)
)
{
PR_SetError
(
SEC_ERROR_LIBRARY_FAILURE
0
)
;
return
SECFailure
;
}
if
(
certDER
.
Length
(
)
=
=
serverCert
-
>
derCert
.
len
&
&
memcmp
(
certDER
.
Elements
(
)
serverCert
-
>
derCert
.
data
certDER
.
Length
(
)
)
=
=
0
)
{
return
SECSuccess
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SPDY
refused
to
allow
new
cert
during
renegotiation
"
)
)
;
PR_SetError
(
SSL_ERROR_RENEGOTIATION_NOT_ALLOWED
0
)
;
return
SECFailure
;
}
void
GatherTelemetryForSingleSCT
(
const
ct
:
:
VerifiedSCT
&
verifiedSct
)
{
uint32_t
origin
=
0
;
switch
(
verifiedSct
.
origin
)
{
case
ct
:
:
VerifiedSCT
:
:
Origin
:
:
Embedded
:
origin
=
1
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Origin
:
:
TLSExtension
:
origin
=
2
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Origin
:
:
OCSPResponse
:
origin
=
3
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
VerifiedSCT
:
:
Origin
type
"
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SCTS_ORIGIN
origin
)
;
uint32_t
verificationStatus
=
0
;
switch
(
verifiedSct
.
status
)
{
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
Valid
:
verificationStatus
=
1
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
UnknownLog
:
verificationStatus
=
2
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
InvalidSignature
:
verificationStatus
=
3
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
InvalidTimestamp
:
verificationStatus
=
4
;
break
;
case
ct
:
:
VerifiedSCT
:
:
Status
:
:
ValidFromDisqualifiedLog
:
verificationStatus
=
5
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
VerifiedSCT
:
:
Status
type
"
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SCTS_VERIFICATION_STATUS
verificationStatus
)
;
}
void
GatherCertificateTransparencyTelemetry
(
const
nsTArray
<
uint8_t
>
&
rootCert
bool
isEV
const
CertificateTransparencyInfo
&
info
)
{
if
(
!
info
.
enabled
)
{
return
;
}
for
(
const
ct
:
:
VerifiedSCT
&
sct
:
info
.
verifyResult
.
verifiedScts
)
{
GatherTelemetryForSingleSCT
(
sct
)
;
}
for
(
size_t
i
=
0
;
i
<
info
.
verifyResult
.
decodingErrors
;
+
+
i
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SCTS_VERIFICATION_STATUS
0
)
;
}
uint32_t
sctsCount
=
static_cast
<
uint32_t
>
(
info
.
verifyResult
.
verifiedScts
.
size
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_SCTS_PER_CONNECTION
sctsCount
)
;
if
(
isEV
)
{
uint32_t
evCompliance
=
0
;
switch
(
info
.
policyCompliance
)
{
case
ct
:
:
CTPolicyCompliance
:
:
Compliant
:
evCompliance
=
1
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
NotEnoughScts
:
evCompliance
=
2
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
NotDiverseScts
:
evCompliance
=
3
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
Unknown
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
CTPolicyCompliance
type
"
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CT_POLICY_COMPLIANCE_OF_EV_CERTS
evCompliance
)
;
}
switch
(
info
.
policyCompliance
)
{
case
ct
:
:
CTPolicyCompliance
:
:
Compliant
:
AccumulateTelemetryForRootCA
(
Telemetry
:
:
SSL_CT_POLICY_COMPLIANT_CONNECTIONS_BY_CA
rootCert
)
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
NotEnoughScts
:
case
ct
:
:
CTPolicyCompliance
:
:
NotDiverseScts
:
AccumulateTelemetryForRootCA
(
Telemetry
:
:
SSL_CT_POLICY_NON_COMPLIANT_CONNECTIONS_BY_CA
rootCert
)
;
break
;
case
ct
:
:
CTPolicyCompliance
:
:
Unknown
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
CTPolicyCompliance
type
"
)
;
}
}
static
void
CollectCertTelemetry
(
mozilla
:
:
pkix
:
:
Result
aCertVerificationResult
EVStatus
aEVStatus
CertVerifier
:
:
OCSPStaplingStatus
aOcspStaplingStatus
KeySizeStatus
aKeySizeStatus
const
PinningTelemetryInfo
&
aPinningTelemetryInfo
const
nsTArray
<
nsTArray
<
uint8_t
>
>
&
aBuiltCertChain
const
CertificateTransparencyInfo
&
aCertificateTransparencyInfo
)
{
uint32_t
evStatus
=
(
aCertVerificationResult
!
=
Success
)
?
0
:
(
aEVStatus
!
=
EVStatus
:
:
EV
)
?
1
:
2
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_EV_STATUS
evStatus
)
;
if
(
aOcspStaplingStatus
!
=
CertVerifier
:
:
OCSP_STAPLING_NEVER_CHECKED
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_OCSP_STAPLING
aOcspStaplingStatus
)
;
}
if
(
aKeySizeStatus
!
=
KeySizeStatus
:
:
NeverChecked
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_CHAIN_KEY_SIZE_STATUS
static_cast
<
uint32_t
>
(
aKeySizeStatus
)
)
;
}
if
(
aPinningTelemetryInfo
.
accumulateForRoot
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CERT_PINNING_FAILURES_BY_CA
aPinningTelemetryInfo
.
rootBucket
)
;
}
if
(
aPinningTelemetryInfo
.
accumulateResult
)
{
MOZ_ASSERT
(
aPinningTelemetryInfo
.
certPinningResultHistogram
.
isSome
(
)
)
;
Telemetry
:
:
Accumulate
(
aPinningTelemetryInfo
.
certPinningResultHistogram
.
value
(
)
aPinningTelemetryInfo
.
certPinningResultBucket
)
;
}
if
(
aCertVerificationResult
=
=
Success
&
&
aBuiltCertChain
.
Length
(
)
>
0
)
{
const
nsTArray
<
uint8_t
>
&
rootCert
=
aBuiltCertChain
.
LastElement
(
)
;
AccumulateTelemetryForRootCA
(
Telemetry
:
:
CERT_VALIDATION_SUCCESS_BY_CA
rootCert
)
;
GatherCertificateTransparencyTelemetry
(
rootCert
aEVStatus
=
=
EVStatus
:
:
EV
aCertificateTransparencyInfo
)
;
}
}
Result
AuthCertificate
(
CertVerifier
&
certVerifier
void
*
aPinArg
const
nsTArray
<
uint8_t
>
&
certBytes
const
nsTArray
<
nsTArray
<
uint8_t
>
>
&
peerCertChain
const
nsACString
&
aHostName
const
OriginAttributes
&
aOriginAttributes
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
const
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
Time
time
uint32_t
certVerifierFlags
nsTArray
<
nsTArray
<
uint8_t
>
>
&
builtCertChain
EVStatus
&
evStatus
CertificateTransparencyInfo
&
certificateTransparencyInfo
bool
&
aIsBuiltCertChainRootBuiltInRoot
)
{
CertVerifier
:
:
OCSPStaplingStatus
ocspStaplingStatus
=
CertVerifier
:
:
OCSP_STAPLING_NEVER_CHECKED
;
KeySizeStatus
keySizeStatus
=
KeySizeStatus
:
:
NeverChecked
;
PinningTelemetryInfo
pinningTelemetryInfo
;
nsTArray
<
nsTArray
<
uint8_t
>
>
peerCertsBytes
;
if
(
!
peerCertChain
.
IsEmpty
(
)
)
{
std
:
:
transform
(
peerCertChain
.
cbegin
(
)
+
1
peerCertChain
.
cend
(
)
MakeBackInserter
(
peerCertsBytes
)
[
]
(
const
auto
&
elementArray
)
{
return
elementArray
.
Clone
(
)
;
}
)
;
}
Result
rv
=
certVerifier
.
VerifySSLServerCert
(
certBytes
time
aPinArg
aHostName
builtCertChain
certVerifierFlags
Some
(
std
:
:
move
(
peerCertsBytes
)
)
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
aOriginAttributes
&
evStatus
&
ocspStaplingStatus
&
keySizeStatus
&
pinningTelemetryInfo
&
certificateTransparencyInfo
&
aIsBuiltCertChainRootBuiltInRoot
)
;
CollectCertTelemetry
(
rv
evStatus
ocspStaplingStatus
keySizeStatus
pinningTelemetryInfo
builtCertChain
certificateTransparencyInfo
)
;
return
rv
;
}
PRErrorCode
AuthCertificateParseResults
(
uint64_t
aPtrForLog
const
nsACString
&
aHostName
int32_t
aPort
const
OriginAttributes
&
aOriginAttributes
const
nsCOMPtr
<
nsIX509Cert
>
&
aCert
mozilla
:
:
pkix
:
:
Time
aTime
PRErrorCode
aCertVerificationError
nsITransportSecurityInfo
:
:
OverridableErrorCategory
&
aOverridableErrorCategory
)
{
uint32_t
probeValue
=
MapCertErrorToProbeValue
(
aCertVerificationError
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CERT_VERIFICATION_ERRORS
probeValue
)
;
Maybe
<
nsITransportSecurityInfo
:
:
OverridableErrorCategory
>
maybeOverridableErrorCategory
=
CategorizeCertificateError
(
aCertVerificationError
)
;
if
(
!
maybeOverridableErrorCategory
.
isSome
(
)
)
{
return
aCertVerificationError
;
}
aOverridableErrorCategory
=
*
maybeOverridableErrorCategory
;
bool
overrideAllowed
=
false
;
nsresult
rv
=
OverrideAllowedForHost
(
aPtrForLog
aHostName
aOriginAttributes
overrideAllowed
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
aCertVerificationError
;
}
if
(
!
overrideAllowed
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
HSTS
or
pinned
host
-
no
overrides
allowed
"
aPtrForLog
)
)
;
return
aCertVerificationError
;
}
nsCOMPtr
<
nsICertOverrideService
>
overrideService
=
do_GetService
(
NS_CERTOVERRIDE_CONTRACTID
)
;
if
(
!
overrideService
)
{
return
aCertVerificationError
;
}
bool
haveOverride
;
bool
isTemporaryOverride
;
rv
=
overrideService
-
>
HasMatchingOverride
(
aHostName
aPort
aOriginAttributes
aCert
&
isTemporaryOverride
&
haveOverride
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
aCertVerificationError
;
}
Unused
<
<
isTemporaryOverride
;
if
(
haveOverride
)
{
uint32_t
probeValue
=
MapOverridableErrorToProbeValue
(
aCertVerificationError
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CERT_ERROR_OVERRIDES
probeValue
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
0x
%
"
PRIx64
"
]
certificate
error
overridden
"
aPtrForLog
)
)
;
return
0
;
}
return
aCertVerificationError
;
}
static
nsTArray
<
nsTArray
<
uint8_t
>
>
CreateCertBytesArray
(
const
UniqueCERTCertList
&
aCertChain
)
{
nsTArray
<
nsTArray
<
uint8_t
>
>
certsBytes
;
for
(
CERTCertListNode
*
n
=
CERT_LIST_HEAD
(
aCertChain
)
;
!
CERT_LIST_END
(
n
aCertChain
)
;
n
=
CERT_LIST_NEXT
(
n
)
)
{
nsTArray
<
uint8_t
>
certBytes
;
certBytes
.
AppendElements
(
n
-
>
cert
-
>
derCert
.
data
n
-
>
cert
-
>
derCert
.
len
)
;
certsBytes
.
AppendElement
(
std
:
:
move
(
certBytes
)
)
;
}
return
certsBytes
;
}
SECStatus
SSLServerCertVerificationJob
:
:
Dispatch
(
uint64_t
addrForLogging
void
*
aPinArg
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
peerCertChain
const
nsACString
&
aHostName
int32_t
aPort
const
OriginAttributes
&
aOriginAttributes
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
Time
time
uint32_t
certVerifierFlags
BaseSSLServerCertVerificationResult
*
aResultTask
)
{
if
(
!
aResultTask
|
|
peerCertChain
.
IsEmpty
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
must
have
result
task
and
non
-
empty
peer
cert
chain
"
)
;
PR_SetError
(
SEC_ERROR_LIBRARY_FAILURE
0
)
;
return
SECFailure
;
}
if
(
!
gCertVerificationThreadPool
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
RefPtr
<
SSLServerCertVerificationJob
>
job
(
new
SSLServerCertVerificationJob
(
addrForLogging
aPinArg
std
:
:
move
(
peerCertChain
)
aHostName
aPort
aOriginAttributes
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
time
certVerifierFlags
aResultTask
)
)
;
nsresult
nrv
=
gCertVerificationThreadPool
-
>
Dispatch
(
job
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
nrv
)
)
{
PRErrorCode
error
=
nrv
=
=
NS_ERROR_OUT_OF_MEMORY
?
PR_OUT_OF_MEMORY_ERROR
:
PR_INVALID_STATE_ERROR
;
PR_SetError
(
error
0
)
;
return
SECFailure
;
}
PR_SetError
(
PR_WOULD_BLOCK_ERROR
0
)
;
return
SECWouldBlock
;
}
NS_IMETHODIMP
SSLServerCertVerificationJob
:
:
Run
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
%
"
PRIx64
"
]
SSLServerCertVerificationJob
:
:
Run
\
n
"
mAddrForLogging
)
)
;
RefPtr
<
SharedCertVerifier
>
certVerifier
(
GetDefaultCertVerifier
(
)
)
;
if
(
!
certVerifier
)
{
PR_SetError
(
SEC_ERROR_NOT_INITIALIZED
0
)
;
return
NS_OK
;
}
TimeStamp
jobStartTime
=
TimeStamp
:
:
Now
(
)
;
EVStatus
evStatus
;
CertificateTransparencyInfo
certificateTransparencyInfo
;
bool
isCertChainRootBuiltInRoot
=
false
;
nsTArray
<
nsTArray
<
uint8_t
>
>
builtChainBytesArray
;
nsTArray
<
uint8_t
>
certBytes
(
mPeerCertChain
.
ElementAt
(
0
)
.
Clone
(
)
)
;
Result
rv
=
AuthCertificate
(
*
certVerifier
mPinArg
certBytes
mPeerCertChain
mHostName
mOriginAttributes
mStapledOCSPResponse
mSCTsFromTLSExtension
mDCInfo
mProviderFlags
mTime
mCertVerifierFlags
builtChainBytesArray
evStatus
certificateTransparencyInfo
isCertChainRootBuiltInRoot
)
;
if
(
rv
=
=
Success
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
SSL_SUCCESFUL_CERT_VALIDATION_TIME_MOZILLAPKIX
jobStartTime
TimeStamp
:
:
Now
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SSL_CERT_ERROR_OVERRIDES
1
)
;
mResultTask
-
>
Dispatch
(
std
:
:
move
(
builtChainBytesArray
)
std
:
:
move
(
mPeerCertChain
)
TransportSecurityInfo
:
:
ConvertCertificateTransparencyInfoToStatus
(
certificateTransparencyInfo
)
evStatus
true
0
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_UNSET
isCertChainRootBuiltInRoot
mProviderFlags
)
;
return
NS_OK
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
SSL_INITIAL_FAILED_CERT_VALIDATION_TIME_MOZILLAPKIX
jobStartTime
TimeStamp
:
:
Now
(
)
)
;
PRErrorCode
error
=
MapResultToPRErrorCode
(
rv
)
;
nsITransportSecurityInfo
:
:
OverridableErrorCategory
overridableErrorCategory
=
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_UNSET
;
nsCOMPtr
<
nsIX509Cert
>
cert
(
new
nsNSSCertificate
(
std
:
:
move
(
certBytes
)
)
)
;
PRErrorCode
finalError
=
AuthCertificateParseResults
(
mAddrForLogging
mHostName
mPort
mOriginAttributes
cert
mTime
error
overridableErrorCategory
)
;
mResultTask
-
>
Dispatch
(
std
:
:
move
(
builtChainBytesArray
)
std
:
:
move
(
mPeerCertChain
)
nsITransportSecurityInfo
:
:
CERTIFICATE_TRANSPARENCY_NOT_APPLICABLE
EVStatus
:
:
NotEV
false
finalError
overridableErrorCategory
false
mProviderFlags
)
;
return
NS_OK
;
}
SECStatus
AuthCertificateHookInternal
(
TransportSecurityInfo
*
infoObject
const
void
*
aPtrForLogging
const
nsACString
&
hostName
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
peerCertChain
Maybe
<
nsTArray
<
uint8_t
>
>
&
stapledOCSPResponse
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
Maybe
<
DelegatedCredentialInfo
>
&
dcInfo
uint32_t
providerFlags
uint32_t
certVerifierFlags
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
%
p
]
starting
AuthCertificateHookInternal
\
n
"
aPtrForLogging
)
)
;
if
(
!
infoObject
|
|
peerCertChain
.
IsEmpty
(
)
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
bool
onSTSThread
;
nsresult
nrv
;
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
nrv
)
;
if
(
NS_SUCCEEDED
(
nrv
)
)
{
nrv
=
sts
-
>
IsOnCurrentThread
(
&
onSTSThread
)
;
}
if
(
NS_FAILED
(
nrv
)
)
{
NS_ERROR
(
"
Could
not
get
STS
service
or
IsOnCurrentThread
failed
"
)
;
PR_SetError
(
PR_UNKNOWN_ERROR
0
)
;
return
SECFailure
;
}
MOZ_ASSERT
(
onSTSThread
)
;
if
(
!
onSTSThread
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
uint64_t
addr
=
reinterpret_cast
<
uintptr_t
>
(
aPtrForLogging
)
;
RefPtr
<
SSLServerCertVerificationResult
>
resultTask
=
new
SSLServerCertVerificationResult
(
infoObject
)
;
if
(
XRE_IsSocketProcess
(
)
)
{
return
RemoteProcessCertVerification
(
std
:
:
move
(
peerCertChain
)
hostName
infoObject
-
>
GetPort
(
)
infoObject
-
>
GetOriginAttributes
(
)
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
certVerifierFlags
resultTask
)
;
}
return
SSLServerCertVerificationJob
:
:
Dispatch
(
addr
infoObject
std
:
:
move
(
peerCertChain
)
hostName
infoObject
-
>
GetPort
(
)
infoObject
-
>
GetOriginAttributes
(
)
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
Now
(
)
certVerifierFlags
resultTask
)
;
}
SECStatus
AuthCertificateHook
(
void
*
arg
PRFileDesc
*
fd
PRBool
checkSig
PRBool
isServer
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
[
%
p
]
starting
AuthCertificateHook
\
n
"
fd
)
)
;
MOZ_ASSERT
(
checkSig
"
AuthCertificateHook
:
checkSig
unexpectedly
false
"
)
;
MOZ_ASSERT
(
!
isServer
"
AuthCertificateHook
:
isServer
unexpectedly
true
"
)
;
nsNSSSocketInfo
*
socketInfo
=
static_cast
<
nsNSSSocketInfo
*
>
(
arg
)
;
UniqueCERTCertificate
serverCert
(
SSL_PeerCertificate
(
fd
)
)
;
if
(
!
checkSig
|
|
isServer
|
|
!
socketInfo
|
|
!
serverCert
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
socketInfo
-
>
SetFullHandshake
(
)
;
if
(
BlockServerCertChangeForSpdy
(
socketInfo
serverCert
)
!
=
SECSuccess
)
{
return
SECFailure
;
}
UniqueCERTCertList
peerCertChain
(
SSL_PeerCertificateChain
(
fd
)
)
;
if
(
!
peerCertChain
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
nsTArray
<
nsTArray
<
uint8_t
>
>
peerCertsBytes
=
CreateCertBytesArray
(
peerCertChain
)
;
const
SECItemArray
*
csa
=
SSL_PeerStapledOCSPResponses
(
fd
)
;
Maybe
<
nsTArray
<
uint8_t
>
>
stapledOCSPResponse
;
if
(
csa
&
&
csa
-
>
len
=
=
1
)
{
stapledOCSPResponse
.
emplace
(
)
;
stapledOCSPResponse
-
>
SetCapacity
(
csa
-
>
items
[
0
]
.
len
)
;
stapledOCSPResponse
-
>
AppendElements
(
csa
-
>
items
[
0
]
.
data
csa
-
>
items
[
0
]
.
len
)
;
}
Maybe
<
nsTArray
<
uint8_t
>
>
sctsFromTLSExtension
;
const
SECItem
*
sctsFromTLSExtensionSECItem
=
SSL_PeerSignedCertTimestamps
(
fd
)
;
if
(
sctsFromTLSExtensionSECItem
)
{
sctsFromTLSExtension
.
emplace
(
)
;
sctsFromTLSExtension
-
>
SetCapacity
(
sctsFromTLSExtensionSECItem
-
>
len
)
;
sctsFromTLSExtension
-
>
AppendElements
(
sctsFromTLSExtensionSECItem
-
>
data
sctsFromTLSExtensionSECItem
-
>
len
)
;
}
uint32_t
providerFlags
=
0
;
socketInfo
-
>
GetProviderFlags
(
&
providerFlags
)
;
uint32_t
certVerifierFlags
=
0
;
if
(
!
socketInfo
-
>
SharedState
(
)
.
IsOCSPStaplingEnabled
(
)
|
|
!
socketInfo
-
>
SharedState
(
)
.
IsOCSPMustStapleEnabled
(
)
)
{
certVerifierFlags
|
=
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
;
}
Maybe
<
DelegatedCredentialInfo
>
dcInfo
;
SSLPreliminaryChannelInfo
channelPreInfo
;
SECStatus
rv
=
SSL_GetPreliminaryChannelInfo
(
fd
&
channelPreInfo
sizeof
(
channelPreInfo
)
)
;
if
(
rv
!
=
SECSuccess
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
if
(
channelPreInfo
.
peerDelegCred
)
{
dcInfo
.
emplace
(
DelegatedCredentialInfo
(
channelPreInfo
.
signatureScheme
channelPreInfo
.
authKeyBits
)
)
;
}
nsCString
echConfig
;
nsresult
nsrv
=
socketInfo
-
>
GetEchConfig
(
echConfig
)
;
bool
verifyToEchPublicName
=
NS_SUCCEEDED
(
nsrv
)
&
&
echConfig
.
Length
(
)
&
&
channelPreInfo
.
echPublicName
;
const
nsCString
echPublicName
(
channelPreInfo
.
echPublicName
)
;
const
nsACString
&
hostname
=
verifyToEchPublicName
?
echPublicName
:
socketInfo
-
>
GetHostName
(
)
;
socketInfo
-
>
SetCertVerificationWaiting
(
)
;
rv
=
AuthCertificateHookInternal
(
socketInfo
static_cast
<
const
void
*
>
(
fd
)
hostname
std
:
:
move
(
peerCertsBytes
)
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
certVerifierFlags
)
;
return
rv
;
}
SECStatus
AuthCertificateHookWithInfo
(
TransportSecurityInfo
*
infoObject
const
nsACString
&
aHostName
const
void
*
aPtrForLogging
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
peerCertChain
Maybe
<
nsTArray
<
nsTArray
<
uint8_t
>
>
>
&
stapledOCSPResponses
Maybe
<
nsTArray
<
uint8_t
>
>
&
sctsFromTLSExtension
uint32_t
providerFlags
)
{
if
(
peerCertChain
.
IsEmpty
(
)
)
{
PR_SetError
(
PR_INVALID_STATE_ERROR
0
)
;
return
SECFailure
;
}
Maybe
<
nsTArray
<
uint8_t
>
>
stapledOCSPResponse
;
if
(
stapledOCSPResponses
&
&
(
stapledOCSPResponses
-
>
Length
(
)
=
=
1
)
)
{
stapledOCSPResponse
.
emplace
(
stapledOCSPResponses
-
>
ElementAt
(
0
)
.
Clone
(
)
)
;
}
uint32_t
certVerifierFlags
=
0
;
if
(
!
PublicSSLState
(
)
-
>
IsOCSPStaplingEnabled
(
)
|
|
!
PublicSSLState
(
)
-
>
IsOCSPMustStapleEnabled
(
)
)
{
certVerifierFlags
|
=
CertVerifier
:
:
FLAG_TLS_IGNORE_STATUS_REQUEST
;
}
Maybe
<
DelegatedCredentialInfo
>
dcInfo
;
return
AuthCertificateHookInternal
(
infoObject
aPtrForLogging
aHostName
std
:
:
move
(
peerCertChain
)
stapledOCSPResponse
sctsFromTLSExtension
dcInfo
providerFlags
certVerifierFlags
)
;
}
NS_IMPL_ISUPPORTS_INHERITED0
(
SSLServerCertVerificationResult
Runnable
)
SSLServerCertVerificationResult
:
:
SSLServerCertVerificationResult
(
TransportSecurityInfo
*
infoObject
)
:
Runnable
(
"
psm
:
:
SSLServerCertVerificationResult
"
)
mInfoObject
(
infoObject
)
mCertificateTransparencyStatus
(
0
)
mEVStatus
(
EVStatus
:
:
NotEV
)
mSucceeded
(
false
)
mFinalError
(
0
)
mOverridableErrorCategory
(
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_UNSET
)
mProviderFlags
(
0
)
{
}
void
SSLServerCertVerificationResult
:
:
Dispatch
(
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
aBuiltChain
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
aPeerCertChain
uint16_t
aCertificateTransparencyStatus
EVStatus
aEVStatus
bool
aSucceeded
PRErrorCode
aFinalError
nsITransportSecurityInfo
:
:
OverridableErrorCategory
aOverridableErrorCategory
bool
aIsBuiltCertChainRootBuiltInRoot
uint32_t
aProviderFlags
)
{
mBuiltChain
=
std
:
:
move
(
aBuiltChain
)
;
mPeerCertChain
=
std
:
:
move
(
aPeerCertChain
)
;
mCertificateTransparencyStatus
=
aCertificateTransparencyStatus
;
mEVStatus
=
aEVStatus
;
mSucceeded
=
aSucceeded
;
mFinalError
=
aFinalError
;
mOverridableErrorCategory
=
aOverridableErrorCategory
;
mIsBuiltCertChainRootBuiltInRoot
=
aIsBuiltCertChainRootBuiltInRoot
;
mProviderFlags
=
aProviderFlags
;
if
(
mSucceeded
&
&
mBuiltChain
.
IsEmpty
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
if
the
handshake
succeeded
the
built
chain
shouldn
'
t
be
empty
"
)
;
mSucceeded
=
false
;
mFinalError
=
SEC_ERROR_LIBRARY_FAILURE
;
}
if
(
!
mSucceeded
&
&
mPeerCertChain
.
IsEmpty
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
if
the
handshake
failed
the
peer
chain
shouldn
'
t
be
empty
"
)
;
mFinalError
=
SEC_ERROR_LIBRARY_FAILURE
;
}
nsresult
rv
;
nsCOMPtr
<
nsIEventTarget
>
stsTarget
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
MOZ_ASSERT
(
stsTarget
"
Failed
to
get
socket
transport
service
event
target
"
)
;
rv
=
stsTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
dispatch
SSLServerCertVerificationResult
"
)
;
}
NS_IMETHODIMP
SSLServerCertVerificationResult
:
:
Run
(
)
{
#
ifdef
DEBUG
bool
onSTSThread
=
false
;
nsresult
nrv
;
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
nrv
)
;
if
(
NS_SUCCEEDED
(
nrv
)
)
{
nrv
=
sts
-
>
IsOnCurrentThread
(
&
onSTSThread
)
;
}
MOZ_ASSERT
(
onSTSThread
)
;
#
endif
if
(
mSucceeded
&
&
!
XRE_IsSocketProcess
(
)
&
&
!
(
mProviderFlags
&
nsISocketProvider
:
:
NO_PERMANENT_STORAGE
)
)
{
SaveIntermediateCerts
(
mBuiltChain
)
;
}
if
(
mSucceeded
)
{
RememberCertErrorsTable
:
:
GetInstance
(
)
.
RememberCertHasError
(
mInfoObject
SECSuccess
)
;
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
SSLServerCertVerificationResult
:
:
Run
setting
NEW
cert
"
)
)
;
nsTArray
<
uint8_t
>
certBytes
(
mBuiltChain
.
ElementAt
(
0
)
.
Clone
(
)
)
;
nsCOMPtr
<
nsIX509Cert
>
cert
(
new
nsNSSCertificate
(
std
:
:
move
(
certBytes
)
)
)
;
mInfoObject
-
>
SetServerCert
(
cert
mEVStatus
)
;
mInfoObject
-
>
SetSucceededCertChain
(
std
:
:
move
(
mBuiltChain
)
)
;
mInfoObject
-
>
SetIsBuiltCertChainRootBuiltInRoot
(
mIsBuiltCertChainRootBuiltInRoot
)
;
mInfoObject
-
>
SetCertificateTransparencyStatus
(
mCertificateTransparencyStatus
)
;
}
else
{
nsTArray
<
uint8_t
>
certBytes
(
mPeerCertChain
.
ElementAt
(
0
)
.
Clone
(
)
)
;
nsCOMPtr
<
nsIX509Cert
>
cert
(
new
nsNSSCertificate
(
std
:
:
move
(
certBytes
)
)
)
;
mInfoObject
-
>
SetFailedCertChain
(
std
:
:
move
(
mPeerCertChain
)
)
;
if
(
mOverridableErrorCategory
!
=
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_UNSET
)
{
mInfoObject
-
>
SetStatusErrorBits
(
cert
mOverridableErrorCategory
)
;
}
}
mInfoObject
-
>
SetCertVerificationResult
(
mFinalError
)
;
return
NS_OK
;
}
}
}
