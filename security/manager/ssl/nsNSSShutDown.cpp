#
include
"
nsNSSShutDown
.
h
"
#
include
"
nsCOMPtr
.
h
"
using
namespace
mozilla
;
extern
LazyLogModule
gPIPNSSLog
;
struct
ObjectHashEntry
:
PLDHashEntryHdr
{
nsNSSShutDownObject
*
obj
;
}
;
static
bool
ObjectSetMatchEntry
(
PLDHashTable
*
table
const
PLDHashEntryHdr
*
hdr
const
void
*
key
)
{
const
ObjectHashEntry
*
entry
=
static_cast
<
const
ObjectHashEntry
*
>
(
hdr
)
;
return
entry
-
>
obj
=
=
static_cast
<
const
nsNSSShutDownObject
*
>
(
key
)
;
}
static
void
ObjectSetInitEntry
(
PLDHashEntryHdr
*
hdr
const
void
*
key
)
{
ObjectHashEntry
*
entry
=
static_cast
<
ObjectHashEntry
*
>
(
hdr
)
;
entry
-
>
obj
=
const_cast
<
nsNSSShutDownObject
*
>
(
static_cast
<
const
nsNSSShutDownObject
*
>
(
key
)
)
;
}
static
const
PLDHashTableOps
gSetOps
=
{
PLDHashTable
:
:
HashVoidPtrKeyStub
ObjectSetMatchEntry
PLDHashTable
:
:
MoveEntryStub
PLDHashTable
:
:
ClearEntryStub
ObjectSetInitEntry
}
;
nsNSSShutDownList
*
nsNSSShutDownList
:
:
singleton
=
nullptr
;
nsNSSShutDownList
:
:
nsNSSShutDownList
(
)
:
mListLock
(
"
nsNSSShutDownList
.
mListLock
"
)
mObjects
(
&
gSetOps
sizeof
(
ObjectHashEntry
)
)
mPK11LogoutCancelObjects
(
&
gSetOps
sizeof
(
ObjectHashEntry
)
)
{
}
nsNSSShutDownList
:
:
~
nsNSSShutDownList
(
)
{
PR_ASSERT
(
this
=
=
singleton
)
;
singleton
=
nullptr
;
}
void
nsNSSShutDownList
:
:
remember
(
nsNSSShutDownObject
*
o
)
{
if
(
!
singleton
)
return
;
PR_ASSERT
(
o
)
;
MutexAutoLock
lock
(
singleton
-
>
mListLock
)
;
singleton
-
>
mObjects
.
Add
(
o
fallible
)
;
}
void
nsNSSShutDownList
:
:
forget
(
nsNSSShutDownObject
*
o
)
{
if
(
!
singleton
)
return
;
PR_ASSERT
(
o
)
;
MutexAutoLock
lock
(
singleton
-
>
mListLock
)
;
singleton
-
>
mObjects
.
Remove
(
o
)
;
}
void
nsNSSShutDownList
:
:
remember
(
nsOnPK11LogoutCancelObject
*
o
)
{
if
(
!
singleton
)
return
;
PR_ASSERT
(
o
)
;
MutexAutoLock
lock
(
singleton
-
>
mListLock
)
;
singleton
-
>
mPK11LogoutCancelObjects
.
Add
(
o
fallible
)
;
}
void
nsNSSShutDownList
:
:
forget
(
nsOnPK11LogoutCancelObject
*
o
)
{
if
(
!
singleton
)
return
;
PR_ASSERT
(
o
)
;
MutexAutoLock
lock
(
singleton
-
>
mListLock
)
;
singleton
-
>
mPK11LogoutCancelObjects
.
Remove
(
o
)
;
}
nsresult
nsNSSShutDownList
:
:
doPK11Logout
(
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
canceling
all
open
SSL
sockets
to
disallow
future
IO
\
n
"
)
)
;
MutexAutoLock
lock
(
singleton
-
>
mListLock
)
;
for
(
auto
iter
=
mPK11LogoutCancelObjects
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
ObjectHashEntry
*
>
(
iter
.
Get
(
)
)
;
nsOnPK11LogoutCancelObject
*
pklco
=
reinterpret_cast
<
nsOnPK11LogoutCancelObject
*
>
(
entry
-
>
obj
)
;
if
(
pklco
)
{
pklco
-
>
logout
(
)
;
}
}
return
NS_OK
;
}
nsresult
nsNSSShutDownList
:
:
evaporateAllNSSResources
(
)
{
if
(
PR_SUCCESS
!
=
mActivityState
.
restrictActivityToCurrentThread
(
)
)
{
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
failed
to
restrict
activity
to
current
thread
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_LOG
(
gPIPNSSLog
LogLevel
:
:
Debug
(
"
now
evaporating
NSS
resources
\
n
"
)
)
;
while
(
true
)
{
MutexAutoLock
lock
(
mListLock
)
;
auto
iter
=
mObjects
.
Iter
(
)
;
if
(
iter
.
Done
(
)
)
{
break
;
}
auto
entry
=
static_cast
<
ObjectHashEntry
*
>
(
iter
.
Get
(
)
)
;
{
MutexAutoUnlock
unlock
(
singleton
-
>
mListLock
)
;
entry
-
>
obj
-
>
shutdown
(
nsNSSShutDownObject
:
:
calledFromList
)
;
}
iter
.
Remove
(
)
;
}
mActivityState
.
releaseCurrentThreadActivityRestriction
(
)
;
return
NS_OK
;
}
nsNSSShutDownList
*
nsNSSShutDownList
:
:
construct
(
)
{
if
(
singleton
)
{
return
nullptr
;
}
singleton
=
new
nsNSSShutDownList
(
)
;
return
singleton
;
}
nsNSSActivityState
:
:
nsNSSActivityState
(
)
:
mNSSActivityStateLock
(
"
nsNSSActivityState
.
mNSSActivityStateLock
"
)
mNSSActivityChanged
(
mNSSActivityStateLock
"
nsNSSActivityState
.
mNSSActivityStateLock
"
)
mNSSActivityCounter
(
0
)
mNSSRestrictedThread
(
nullptr
)
{
}
nsNSSActivityState
:
:
~
nsNSSActivityState
(
)
{
}
void
nsNSSActivityState
:
:
enter
(
)
{
MutexAutoLock
lock
(
mNSSActivityStateLock
)
;
while
(
mNSSRestrictedThread
&
&
mNSSRestrictedThread
!
=
PR_GetCurrentThread
(
)
)
{
mNSSActivityChanged
.
Wait
(
)
;
}
+
+
mNSSActivityCounter
;
}
void
nsNSSActivityState
:
:
leave
(
)
{
MutexAutoLock
lock
(
mNSSActivityStateLock
)
;
-
-
mNSSActivityCounter
;
mNSSActivityChanged
.
NotifyAll
(
)
;
}
PRStatus
nsNSSActivityState
:
:
restrictActivityToCurrentThread
(
)
{
MutexAutoLock
lock
(
mNSSActivityStateLock
)
;
while
(
mNSSActivityCounter
>
0
)
{
mNSSActivityChanged
.
Wait
(
PR_TicksPerSecond
(
)
)
;
}
mNSSRestrictedThread
=
PR_GetCurrentThread
(
)
;
return
PR_SUCCESS
;
}
void
nsNSSActivityState
:
:
releaseCurrentThreadActivityRestriction
(
)
{
MutexAutoLock
lock
(
mNSSActivityStateLock
)
;
mNSSRestrictedThread
=
nullptr
;
mNSSActivityChanged
.
NotifyAll
(
)
;
}
nsNSSShutDownPreventionLock
:
:
nsNSSShutDownPreventionLock
(
)
{
nsNSSActivityState
*
state
=
nsNSSShutDownList
:
:
getActivityState
(
)
;
if
(
!
state
)
return
;
state
-
>
enter
(
)
;
}
nsNSSShutDownPreventionLock
:
:
~
nsNSSShutDownPreventionLock
(
)
{
nsNSSActivityState
*
state
=
nsNSSShutDownList
:
:
getActivityState
(
)
;
if
(
!
state
)
return
;
state
-
>
leave
(
)
;
}
