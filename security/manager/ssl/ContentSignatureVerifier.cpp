#
include
"
ContentSignatureVerifier
.
h
"
#
include
"
BRNameMatchingPolicy
.
h
"
#
include
"
cryptohi
.
h
"
#
include
"
keyhi
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsNSSComponent
.
h
"
#
include
"
nssb64
.
h
"
#
include
"
nsWhitespaceTokenizer
.
h
"
#
include
"
nsXPCOMStrings
.
h
"
#
include
"
pkix
/
pkix
.
h
"
#
include
"
pkix
/
pkixtypes
.
h
"
#
include
"
secerr
.
h
"
#
include
"
SharedCertVerifier
.
h
"
#
include
"
nsSecurityHeaderParser
.
h
"
NS_IMPL_ISUPPORTS
(
ContentSignatureVerifier
nsIContentSignatureVerifier
)
using
namespace
mozilla
;
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
static
LazyLogModule
gCSVerifierPRLog
(
"
ContentSignatureVerifier
"
)
;
#
define
CSVerifier_LOG
(
args
)
MOZ_LOG
(
gCSVerifierPRLog
LogLevel
:
:
Debug
args
)
const
nsLiteralCString
kPREFIX
=
NS_LITERAL_CSTRING
(
"
Content
-
Signature
:
\
x00
"
)
;
ContentSignatureVerifier
:
:
~
ContentSignatureVerifier
(
)
{
nsNSSShutDownPreventionLock
locker
;
if
(
isAlreadyShutDown
(
)
)
{
return
;
}
destructorSafeDestroyNSSReference
(
)
;
shutdown
(
calledFromObject
)
;
}
nsresult
ContentSignatureVerifier
:
:
VerifyContentSignature
(
const
nsACString
&
aData
const
nsACString
&
aCSHeader
const
nsACString
&
aCertChain
const
uint32_t
aSource
bool
*
_retval
)
{
nsresult
rv
=
CreateContext
(
aData
aCSHeader
aCertChain
aSource
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
_retval
=
false
;
CSVerifier_LOG
(
(
"
CSVerifier
:
Signature
verification
failed
\
n
"
)
)
;
if
(
rv
=
=
NS_ERROR_INVALID_SIGNATURE
)
{
return
NS_OK
;
}
return
rv
;
}
return
End
(
_retval
)
;
}
bool
IsNewLine
(
char16_t
c
)
{
return
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
;
}
nsresult
ReadChainIntoCertList
(
const
nsACString
&
aCertChain
CERTCertList
*
aCertList
const
nsNSSShutDownPreventionLock
&
)
{
bool
inBlock
=
false
;
bool
certFound
=
false
;
const
nsCString
header
=
NS_LITERAL_CSTRING
(
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
"
)
;
const
nsCString
footer
=
NS_LITERAL_CSTRING
(
"
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
"
)
;
nsCWhitespaceTokenizerTemplate
<
IsNewLine
>
tokenizer
(
aCertChain
)
;
nsAutoCString
blockData
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
nsDependentCSubstring
token
=
tokenizer
.
nextToken
(
)
;
if
(
token
.
IsEmpty
(
)
)
{
continue
;
}
if
(
inBlock
)
{
if
(
token
.
Equals
(
footer
)
)
{
inBlock
=
false
;
certFound
=
true
;
UniqueSECItem
der
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
0
)
)
;
if
(
!
der
|
|
!
NSSBase64_DecodeBuffer
(
nullptr
der
.
get
(
)
blockData
.
BeginReading
(
)
blockData
.
Length
(
)
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
decoding
the
signature
failed
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
CERTCertificate
*
tmpCert
=
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
der
.
get
(
)
nullptr
false
true
)
;
if
(
!
tmpCert
)
{
return
NS_ERROR_FAILURE
;
}
SECStatus
res
=
CERT_AddCertToListTail
(
aCertList
tmpCert
)
;
if
(
res
!
=
SECSuccess
)
{
CERT_DestroyCertificate
(
tmpCert
)
;
return
MapSECStatus
(
res
)
;
}
}
else
{
blockData
.
Append
(
token
)
;
}
}
else
if
(
token
.
Equals
(
header
)
)
{
inBlock
=
true
;
blockData
=
"
"
;
}
}
if
(
inBlock
|
|
!
certFound
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
supplied
chain
contains
bad
data
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ContentSignatureVerifier
:
:
CreateContext
(
const
nsACString
&
aData
const
nsACString
&
aCSHeader
const
nsACString
&
aCertChain
const
uint32_t
aSource
)
{
MutexAutoLock
lock
(
mMutex
)
;
nsNSSShutDownPreventionLock
locker
;
if
(
isAlreadyShutDown
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
nss
is
already
shutdown
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mCx
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
ScopedCERTCertList
certCertList
(
CERT_NewCertList
(
)
)
;
if
(
!
certCertList
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsresult
rv
=
ReadChainIntoCertList
(
aCertChain
certCertList
.
get
(
)
locker
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
CERTCertListNode
*
node
=
CERT_LIST_HEAD
(
certCertList
.
get
(
)
)
;
if
(
!
node
|
|
!
node
-
>
cert
)
{
return
NS_ERROR_FAILURE
;
}
SECItem
*
certSecItem
=
&
node
-
>
cert
-
>
derCert
;
Input
certDER
;
Result
result
=
certDER
.
Init
(
reinterpret_cast
<
const
uint8_t
*
>
(
certSecItem
-
>
data
)
certSecItem
-
>
len
)
;
if
(
result
!
=
Success
)
{
return
NS_ERROR_FAILURE
;
}
CSTrustDomain
trustDomain
(
certCertList
)
;
result
=
BuildCertChain
(
trustDomain
certDER
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_codeSigning
CertPolicyId
:
:
anyPolicy
nullptr
)
;
if
(
result
!
=
Success
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
The
supplied
chain
is
bad
\
n
"
)
)
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
nsAutoCString
hostname
;
Input
hostnameInput
;
switch
(
aSource
)
{
case
ABOUT_NEWTAB
:
hostname
=
"
remote
-
newtab
-
signer
.
mozilla
.
org
"
;
break
;
case
ONECRL
:
hostname
=
"
oneCRL
-
signer
.
mozilla
.
org
"
;
break
;
default
:
CSVerifier_LOG
(
(
"
CSVerifier
:
bad
context
\
n
"
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
result
=
hostnameInput
.
Init
(
uint8_t_ptr_cast
(
hostname
.
BeginReading
(
)
)
hostname
.
Length
(
)
)
;
if
(
result
!
=
Success
)
{
return
NS_ERROR_FAILURE
;
}
BRNameMatchingPolicy
nameMatchingPolicy
(
BRNameMatchingPolicy
:
:
Mode
:
:
Enforce
)
;
result
=
CheckCertHostname
(
certDER
hostnameInput
nameMatchingPolicy
)
;
if
(
result
!
=
Success
)
{
return
NS_ERROR_INVALID_SIGNATURE
;
}
mKey
.
reset
(
CERT_ExtractPublicKey
(
node
-
>
cert
)
)
;
if
(
!
mKey
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
unable
to
extract
a
key
\
n
"
)
)
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
rv
=
ParseContentSignatureHeader
(
aCSHeader
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
UniqueSECItem
rawSignatureItem
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
0
)
)
;
if
(
!
rawSignatureItem
|
|
!
NSSBase64_DecodeBuffer
(
nullptr
rawSignatureItem
.
get
(
)
mSignature
.
get
(
)
mSignature
.
Length
(
)
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
decoding
the
signature
failed
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
UniqueSECItem
signatureItem
(
:
:
SECITEM_AllocItem
(
nullptr
nullptr
0
)
)
;
if
(
!
signatureItem
)
{
return
NS_ERROR_FAILURE
;
}
if
(
rawSignatureItem
-
>
len
=
=
0
|
|
rawSignatureItem
-
>
len
%
2
!
=
0
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
signature
length
is
bad
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
DSAU_EncodeDerSigWithLen
(
signatureItem
.
get
(
)
rawSignatureItem
.
get
(
)
rawSignatureItem
-
>
len
)
!
=
SECSuccess
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
encoding
the
signature
failed
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
SECOidTag
oid
=
SEC_OID_ANSIX962_ECDSA_SHA384_SIGNATURE
;
mCx
=
UniqueVFYContext
(
VFY_CreateContext
(
mKey
.
get
(
)
signatureItem
.
get
(
)
oid
nullptr
)
)
;
if
(
!
mCx
)
{
return
NS_ERROR_INVALID_SIGNATURE
;
}
if
(
VFY_Begin
(
mCx
.
get
(
)
)
!
=
SECSuccess
)
{
return
NS_ERROR_INVALID_SIGNATURE
;
}
rv
=
UpdateInternal
(
kPREFIX
lock
locker
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
UpdateInternal
(
aData
lock
locker
)
;
}
nsresult
ContentSignatureVerifier
:
:
UpdateInternal
(
const
nsACString
&
aData
MutexAutoLock
&
const
nsNSSShutDownPreventionLock
&
)
{
if
(
!
aData
.
IsEmpty
(
)
)
{
if
(
VFY_Update
(
mCx
.
get
(
)
(
const
unsigned
char
*
)
nsPromiseFlatCString
(
aData
)
.
get
(
)
aData
.
Length
(
)
)
!
=
SECSuccess
)
{
return
NS_ERROR_INVALID_SIGNATURE
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
ContentSignatureVerifier
:
:
Update
(
const
nsACString
&
aData
)
{
nsNSSShutDownPreventionLock
locker
;
if
(
isAlreadyShutDown
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
nss
is
already
shutdown
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
MutexAutoLock
lock
(
mMutex
)
;
return
UpdateInternal
(
aData
lock
locker
)
;
}
NS_IMETHODIMP
ContentSignatureVerifier
:
:
End
(
bool
*
_retval
)
{
NS_ENSURE_ARG
(
_retval
)
;
MutexAutoLock
lock
(
mMutex
)
;
nsNSSShutDownPreventionLock
locker
;
if
(
isAlreadyShutDown
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
nss
is
already
shutdown
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
*
_retval
=
(
VFY_End
(
mCx
.
get
(
)
)
=
=
SECSuccess
)
;
return
NS_OK
;
}
nsresult
ContentSignatureVerifier
:
:
ParseContentSignatureHeader
(
const
nsACString
&
aContentSignatureHeader
)
{
NS_NAMED_LITERAL_CSTRING
(
signature_var
"
p384ecdsa
"
)
;
nsSecurityHeaderParser
parser
(
aContentSignatureHeader
.
BeginReading
(
)
)
;
nsresult
rv
=
parser
.
Parse
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
could
not
parse
ContentSignature
header
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
LinkedList
<
nsSecurityHeaderDirective
>
*
directives
=
parser
.
GetDirectives
(
)
;
for
(
nsSecurityHeaderDirective
*
directive
=
directives
-
>
getFirst
(
)
;
directive
!
=
nullptr
;
directive
=
directive
-
>
getNext
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
found
directive
%
s
\
n
"
directive
-
>
mName
.
get
(
)
)
)
;
if
(
directive
-
>
mName
.
Length
(
)
=
=
signature_var
.
Length
(
)
&
&
directive
-
>
mName
.
EqualsIgnoreCase
(
signature_var
.
get
(
)
signature_var
.
Length
(
)
)
)
{
if
(
!
mSignature
.
IsEmpty
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
found
two
ContentSignatures
\
n
"
)
)
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
CSVerifier_LOG
(
(
"
CSVerifier
:
found
a
ContentSignature
directive
\
n
"
)
)
;
mSignature
=
directive
-
>
mValue
;
}
}
if
(
mSignature
.
IsEmpty
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
got
a
Content
-
Signature
header
but
didn
'
t
find
a
signature
.
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
mSignature
.
ReplaceChar
(
'
-
'
'
+
'
)
;
mSignature
.
ReplaceChar
(
'
_
'
'
/
'
)
;
return
NS_OK
;
}
