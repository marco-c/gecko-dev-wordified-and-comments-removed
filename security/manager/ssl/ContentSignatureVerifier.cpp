#
include
"
ContentSignatureVerifier
.
h
"
#
include
"
BRNameMatchingPolicy
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
SharedCertVerifier
.
h
"
#
include
"
cryptohi
.
h
"
#
include
"
keyhi
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsPromiseFlatString
.
h
"
#
include
"
nsSecurityHeaderParser
.
h
"
#
include
"
nsWhitespaceTokenizer
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
mozpkix
/
pkixtypes
.
h
"
#
include
"
secerr
.
h
"
NS_IMPL_ISUPPORTS
(
ContentSignatureVerifier
nsIContentSignatureVerifier
)
using
namespace
mozilla
;
using
namespace
mozilla
:
:
pkix
;
using
namespace
mozilla
:
:
psm
;
using
dom
:
:
Promise
;
static
LazyLogModule
gCSVerifierPRLog
(
"
ContentSignatureVerifier
"
)
;
#
define
CSVerifier_LOG
(
args
)
MOZ_LOG
(
gCSVerifierPRLog
LogLevel
:
:
Debug
args
)
const
unsigned
char
kPREFIX
[
]
=
{
'
C
'
'
o
'
'
n
'
'
t
'
'
e
'
'
n
'
'
t
'
'
-
'
'
S
'
'
i
'
'
g
'
'
n
'
'
a
'
'
t
'
'
u
'
'
r
'
'
e
'
'
:
'
0
}
;
class
VerifyContentSignatureTask
:
public
CryptoTask
{
public
:
VerifyContentSignatureTask
(
const
nsACString
&
aData
const
nsACString
&
aCSHeader
const
nsACString
&
aCertChain
const
nsACString
&
aHostname
RefPtr
<
Promise
>
&
aPromise
)
:
mData
(
aData
)
mCSHeader
(
aCSHeader
)
mCertChain
(
aCertChain
)
mHostname
(
aHostname
)
mSignatureVerified
(
false
)
mPromise
(
aPromise
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
;
virtual
void
CallCallback
(
nsresult
rv
)
override
;
nsCString
mData
;
nsCString
mCSHeader
;
nsCString
mCertChain
;
nsCString
mHostname
;
bool
mSignatureVerified
;
RefPtr
<
Promise
>
mPromise
;
}
;
NS_IMETHODIMP
ContentSignatureVerifier
:
:
AsyncVerifyContentSignature
(
const
nsACString
&
aData
const
nsACString
&
aCSHeader
const
nsACString
&
aCertChain
const
nsACString
&
aHostname
JSContext
*
aCx
Promise
*
*
aPromise
)
{
NS_ENSURE_ARG_POINTER
(
aCx
)
;
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
RefPtr
<
VerifyContentSignatureTask
>
task
(
new
VerifyContentSignatureTask
(
aData
aCSHeader
aCertChain
aHostname
promise
)
)
;
nsresult
rv
=
task
-
>
Dispatch
(
"
ContentSig
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
static
nsresult
VerifyContentSignatureInternal
(
const
nsACString
&
aData
const
nsACString
&
aCSHeader
const
nsACString
&
aCertChain
const
nsACString
&
aHostname
mozilla
:
:
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
&
aErrorLabel
nsACString
&
aCertFingerprint
uint32_t
&
aErrorValue
)
;
static
nsresult
ParseContentSignatureHeader
(
const
nsACString
&
aContentSignatureHeader
nsCString
&
aSignature
)
;
nsresult
VerifyContentSignatureTask
:
:
CalculateResult
(
)
{
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
errorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err3
;
nsAutoCString
certFingerprint
;
uint32_t
errorValue
=
3
;
nsresult
rv
=
VerifyContentSignatureInternal
(
mData
mCSHeader
mCertChain
mHostname
errorLabel
certFingerprint
errorValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
Signature
verification
failed
"
)
)
;
if
(
certFingerprint
.
Length
(
)
>
0
)
{
Telemetry
:
:
AccumulateCategoricalKeyed
(
certFingerprint
errorLabel
)
;
}
Accumulate
(
Telemetry
:
:
CONTENT_SIGNATURE_VERIFICATION_STATUS
errorValue
)
;
if
(
rv
=
=
NS_ERROR_INVALID_SIGNATURE
)
{
return
NS_OK
;
}
return
rv
;
}
mSignatureVerified
=
true
;
Accumulate
(
Telemetry
:
:
CONTENT_SIGNATURE_VERIFICATION_STATUS
0
)
;
return
NS_OK
;
}
void
VerifyContentSignatureTask
:
:
CallCallback
(
nsresult
rv
)
{
if
(
NS_FAILED
(
rv
)
)
{
mPromise
-
>
MaybeReject
(
rv
)
;
}
else
{
mPromise
-
>
MaybeResolve
(
mSignatureVerified
)
;
}
}
bool
IsNewLine
(
char16_t
c
)
{
return
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
;
}
nsresult
ReadChainIntoCertList
(
const
nsACString
&
aCertChain
CERTCertList
*
aCertList
)
{
bool
inBlock
=
false
;
bool
certFound
=
false
;
const
nsCString
header
=
NS_LITERAL_CSTRING
(
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
"
)
;
const
nsCString
footer
=
NS_LITERAL_CSTRING
(
"
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
"
)
;
nsCWhitespaceTokenizerTemplate
<
IsNewLine
>
tokenizer
(
aCertChain
)
;
nsAutoCString
blockData
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
nsDependentCSubstring
token
=
tokenizer
.
nextToken
(
)
;
if
(
token
.
IsEmpty
(
)
)
{
continue
;
}
if
(
inBlock
)
{
if
(
token
.
Equals
(
footer
)
)
{
inBlock
=
false
;
certFound
=
true
;
nsAutoCString
derString
;
nsresult
rv
=
Base64Decode
(
blockData
derString
)
;
if
(
NS_FAILED
(
rv
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
decoding
the
signature
failed
"
)
)
;
return
rv
;
}
SECItem
der
=
{
siBuffer
BitwiseCast
<
unsigned
char
*
const
char
*
>
(
derString
.
get
(
)
)
derString
.
Length
(
)
}
;
UniqueCERTCertificate
tmpCert
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
der
nullptr
false
true
)
)
;
if
(
!
tmpCert
)
{
return
NS_ERROR_FAILURE
;
}
SECStatus
res
=
CERT_AddCertToListTail
(
aCertList
tmpCert
.
get
(
)
)
;
if
(
res
!
=
SECSuccess
)
{
return
MapSECStatus
(
res
)
;
}
Unused
<
<
tmpCert
.
release
(
)
;
}
else
{
blockData
.
Append
(
token
)
;
}
}
else
if
(
token
.
Equals
(
header
)
)
{
inBlock
=
true
;
blockData
=
"
"
;
}
}
if
(
inBlock
|
|
!
certFound
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
supplied
chain
contains
bad
data
"
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
nsresult
VerifyContentSignatureInternal
(
const
nsACString
&
aData
const
nsACString
&
aCSHeader
const
nsACString
&
aCertChain
const
nsACString
&
aHostname
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
&
aErrorLabel
nsACString
&
aCertFingerprint
uint32_t
&
aErrorValue
)
{
UniqueCERTCertList
certCertList
(
CERT_NewCertList
(
)
)
;
if
(
!
certCertList
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsresult
rv
=
ReadChainIntoCertList
(
aCertChain
certCertList
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
CERTCertListNode
*
node
=
CERT_LIST_HEAD
(
certCertList
.
get
(
)
)
;
if
(
!
node
|
|
CERT_LIST_END
(
node
certCertList
.
get
(
)
)
|
|
!
node
-
>
cert
)
{
return
NS_ERROR_FAILURE
;
}
SECItem
*
certSecItem
=
&
node
-
>
cert
-
>
derCert
;
Input
certDER
;
mozilla
:
:
pkix
:
:
Result
result
=
certDER
.
Init
(
BitwiseCast
<
uint8_t
*
unsigned
char
*
>
(
certSecItem
-
>
data
)
certSecItem
-
>
len
)
;
if
(
result
!
=
Success
)
{
return
NS_ERROR_FAILURE
;
}
unsigned
char
fingerprint
[
SHA256_LENGTH
]
=
{
0
}
;
SECStatus
srv
=
PK11_HashBuf
(
SEC_OID_SHA256
fingerprint
certSecItem
-
>
data
AssertedCast
<
int32_t
>
(
certSecItem
-
>
len
)
)
;
if
(
srv
!
=
SECSuccess
)
{
return
NS_ERROR_FAILURE
;
}
SECItem
fingerprintItem
=
{
siBuffer
fingerprint
SHA256_LENGTH
}
;
UniquePORTString
tmpFingerprintString
(
CERT_Hexify
(
&
fingerprintItem
0
)
)
;
if
(
!
tmpFingerprintString
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aCertFingerprint
.
Assign
(
tmpFingerprintString
.
get
(
)
)
;
CSTrustDomain
trustDomain
(
certCertList
)
;
result
=
BuildCertChain
(
trustDomain
certDER
Now
(
)
EndEntityOrCA
:
:
MustBeEndEntity
KeyUsage
:
:
noParticularKeyUsageRequired
KeyPurposeId
:
:
id_kp_codeSigning
CertPolicyId
:
:
anyPolicy
nullptr
)
;
if
(
result
!
=
Success
)
{
if
(
IsFatalError
(
result
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
result
=
=
mozilla
:
:
pkix
:
:
Result
:
:
ERROR_EXPIRED_CERTIFICATE
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err4
;
aErrorValue
=
4
;
}
else
if
(
result
=
=
mozilla
:
:
pkix
:
:
Result
:
:
ERROR_NOT_YET_VALID_CERTIFICATE
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err5
;
aErrorValue
=
5
;
}
else
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err6
;
aErrorValue
=
6
;
}
CSVerifier_LOG
(
(
"
CSVerifier
:
The
supplied
chain
is
bad
(
%
s
)
"
MapResultToName
(
result
)
)
)
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
Input
hostnameInput
;
result
=
hostnameInput
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
aHostname
.
BeginReading
(
)
)
aHostname
.
Length
(
)
)
;
if
(
result
!
=
Success
)
{
return
NS_ERROR_FAILURE
;
}
BRNameMatchingPolicy
nameMatchingPolicy
(
BRNameMatchingPolicy
:
:
Mode
:
:
Enforce
)
;
result
=
CheckCertHostname
(
certDER
hostnameInput
nameMatchingPolicy
)
;
if
(
result
!
=
Success
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err7
;
aErrorValue
=
7
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
mozilla
:
:
UniqueSECKEYPublicKey
key
(
CERT_ExtractPublicKey
(
node
-
>
cert
)
)
;
if
(
!
key
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err8
;
aErrorValue
=
8
;
CSVerifier_LOG
(
(
"
CSVerifier
:
unable
to
extract
a
key
"
)
)
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
nsAutoCString
signature
;
rv
=
ParseContentSignatureHeader
(
aCSHeader
signature
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
rawSignature
;
rv
=
Base64Decode
(
signature
rawSignature
)
;
if
(
NS_FAILED
(
rv
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
decoding
the
signature
failed
"
)
)
;
return
rv
;
}
ScopedAutoSECItem
signatureItem
;
SECItem
rawSignatureItem
=
{
siBuffer
BitwiseCast
<
unsigned
char
*
const
char
*
>
(
rawSignature
.
get
(
)
)
rawSignature
.
Length
(
)
}
;
if
(
rawSignatureItem
.
len
=
=
0
|
|
rawSignatureItem
.
len
%
2
!
=
0
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
signature
length
is
bad
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
DSAU_EncodeDerSigWithLen
(
&
signatureItem
&
rawSignatureItem
rawSignatureItem
.
len
)
!
=
SECSuccess
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
encoding
the
signature
failed
"
)
)
;
return
NS_ERROR_FAILURE
;
}
SECOidTag
oid
=
SEC_OID_ANSIX962_ECDSA_SHA384_SIGNATURE
;
mozilla
:
:
UniqueVFYContext
cx
(
VFY_CreateContext
(
key
.
get
(
)
&
signatureItem
oid
nullptr
)
)
;
if
(
!
cx
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err9
;
aErrorValue
=
9
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
if
(
VFY_Begin
(
cx
.
get
(
)
)
!
=
SECSuccess
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err9
;
aErrorValue
=
9
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
if
(
VFY_Update
(
cx
.
get
(
)
kPREFIX
sizeof
(
kPREFIX
)
)
!
=
SECSuccess
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err1
;
aErrorValue
=
1
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
if
(
VFY_Update
(
cx
.
get
(
)
reinterpret_cast
<
const
unsigned
char
*
>
(
aData
.
BeginReading
(
)
)
aData
.
Length
(
)
)
!
=
SECSuccess
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err1
;
aErrorValue
=
1
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
if
(
VFY_End
(
cx
.
get
(
)
)
!
=
SECSuccess
)
{
aErrorLabel
=
Telemetry
:
:
LABELS_CONTENT_SIGNATURE_VERIFICATION_ERRORS
:
:
err1
;
aErrorValue
=
1
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
return
NS_OK
;
}
static
nsresult
ParseContentSignatureHeader
(
const
nsACString
&
aContentSignatureHeader
nsCString
&
aSignature
)
{
NS_NAMED_LITERAL_CSTRING
(
signature_var
"
p384ecdsa
"
)
;
aSignature
.
Truncate
(
)
;
const
nsCString
&
flatHeader
=
PromiseFlatCString
(
aContentSignatureHeader
)
;
nsSecurityHeaderParser
parser
(
flatHeader
)
;
nsresult
rv
=
parser
.
Parse
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
could
not
parse
ContentSignature
header
"
)
)
;
return
NS_ERROR_FAILURE
;
}
LinkedList
<
nsSecurityHeaderDirective
>
*
directives
=
parser
.
GetDirectives
(
)
;
for
(
nsSecurityHeaderDirective
*
directive
=
directives
-
>
getFirst
(
)
;
directive
!
=
nullptr
;
directive
=
directive
-
>
getNext
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
found
directive
'
%
s
'
"
directive
-
>
mName
.
get
(
)
)
)
;
if
(
directive
-
>
mName
.
Length
(
)
=
=
signature_var
.
Length
(
)
&
&
directive
-
>
mName
.
EqualsIgnoreCase
(
signature_var
.
get
(
)
signature_var
.
Length
(
)
)
)
{
if
(
!
aSignature
.
IsEmpty
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
found
two
ContentSignatures
"
)
)
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
CSVerifier_LOG
(
(
"
CSVerifier
:
found
a
ContentSignature
directive
"
)
)
;
aSignature
.
Assign
(
directive
-
>
mValue
)
;
}
}
if
(
aSignature
.
IsEmpty
(
)
)
{
CSVerifier_LOG
(
(
"
CSVerifier
:
got
a
Content
-
Signature
header
but
didn
'
t
find
a
"
"
signature
.
"
)
)
;
return
NS_ERROR_FAILURE
;
}
aSignature
.
ReplaceChar
(
'
-
'
'
+
'
)
;
aSignature
.
ReplaceChar
(
'
_
'
'
/
'
)
;
return
NS_OK
;
}
