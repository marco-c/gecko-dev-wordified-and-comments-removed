#
include
"
LocalCertService
.
h
"
#
include
"
CryptoTask
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
cert
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
ModuleUtils
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsIPK11Token
.
h
"
#
include
"
nsIPK11TokenDB
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
nsIX509CertValidity
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNSSCertificate
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
pk11pub
.
h
"
namespace
mozilla
{
static
nsresult
FindLocalCertByName
(
const
nsACString
&
aName
UniqueCERTCertificate
&
aResult
)
{
aResult
.
reset
(
nullptr
)
;
NS_NAMED_LITERAL_CSTRING
(
commonNamePrefix
"
CN
=
"
)
;
nsAutoCString
expectedDistinguishedName
(
commonNamePrefix
+
aName
)
;
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
UniqueCERTCertList
certList
(
PK11_ListCertsInSlot
(
slot
.
get
(
)
)
)
;
if
(
!
certList
)
{
return
NS_ERROR_UNEXPECTED
;
}
for
(
const
CERTCertListNode
*
node
=
CERT_LIST_HEAD
(
certList
)
;
!
CERT_LIST_END
(
node
certList
)
;
node
=
CERT_LIST_NEXT
(
node
)
)
{
if
(
!
node
-
>
cert
-
>
isRoot
)
{
continue
;
}
if
(
!
expectedDistinguishedName
.
Equals
(
node
-
>
cert
-
>
subjectName
)
)
{
continue
;
}
if
(
!
expectedDistinguishedName
.
Equals
(
node
-
>
cert
-
>
issuerName
)
)
{
continue
;
}
aResult
.
reset
(
CERT_DupCertificate
(
node
-
>
cert
)
)
;
return
NS_OK
;
}
return
NS_OK
;
}
class
LocalCertTask
:
public
CryptoTask
{
protected
:
explicit
LocalCertTask
(
const
nsACString
&
aNickname
)
:
mNickname
(
aNickname
)
{
}
nsresult
RemoveExisting
(
)
{
for
(
;
;
)
{
UniqueCERTCertificate
cert
;
nsresult
rv
=
FindLocalCertByName
(
mNickname
cert
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
cert
)
{
return
NS_OK
;
}
rv
=
MapSECStatus
(
PK11_DeleteTokenCertAndKey
(
cert
.
get
(
)
nullptr
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
nsCString
mNickname
;
}
;
class
LocalCertGetTask
final
:
public
LocalCertTask
{
public
:
LocalCertGetTask
(
const
nsACString
&
aNickname
nsILocalCertGetCallback
*
aCallback
)
:
LocalCertTask
(
aNickname
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsILocalCertGetCallback
>
(
"
LocalCertGetTask
:
:
mCallback
"
aCallback
)
)
mCert
(
nullptr
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
{
nsresult
rv
=
GetFromDB
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
Generate
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
Validate
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
Generate
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
Generate
(
)
{
nsresult
rv
;
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
rv
=
RemoveExisting
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NS_NAMED_LITERAL_CSTRING
(
commonNamePrefix
"
CN
=
"
)
;
nsAutoCString
subjectNameStr
(
commonNamePrefix
+
mNickname
)
;
UniqueCERTName
subjectName
(
CERT_AsciiToName
(
subjectNameStr
.
get
(
)
)
)
;
if
(
!
subjectName
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
SECOidData
*
curveOidData
=
SECOID_FindOIDByTag
(
SEC_OID_SECG_EC_SECP256R1
)
;
if
(
!
curveOidData
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
ScopedAutoSECItem
keyParams
(
2
+
curveOidData
-
>
oid
.
len
)
;
keyParams
.
data
[
0
]
=
SEC_ASN1_OBJECT_ID
;
keyParams
.
data
[
1
]
=
curveOidData
-
>
oid
.
len
;
memcpy
(
keyParams
.
data
+
2
curveOidData
-
>
oid
.
data
curveOidData
-
>
oid
.
len
)
;
SECKEYPublicKey
*
tempPublicKey
;
UniqueSECKEYPrivateKey
privateKey
(
PK11_GenerateKeyPair
(
slot
.
get
(
)
CKM_EC_KEY_PAIR_GEN
&
keyParams
&
tempPublicKey
true
true
nullptr
)
)
;
UniqueSECKEYPublicKey
publicKey
(
tempPublicKey
)
;
tempPublicKey
=
nullptr
;
if
(
!
privateKey
|
|
!
publicKey
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
UniqueCERTSubjectPublicKeyInfo
spki
(
SECKEY_CreateSubjectPublicKeyInfo
(
publicKey
.
get
(
)
)
)
;
if
(
!
spki
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
UniqueCERTCertificateRequest
certRequest
(
CERT_CreateCertificateRequest
(
subjectName
.
get
(
)
spki
.
get
(
)
nullptr
)
)
;
if
(
!
certRequest
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
static
const
PRTime
oneDay
=
PRTime
(
PR_USEC_PER_SEC
)
*
PRTime
(
60
)
*
PRTime
(
60
)
*
PRTime
(
24
)
;
PRTime
now
=
PR_Now
(
)
;
PRTime
notBefore
=
now
-
oneDay
;
PRTime
notAfter
=
now
+
(
PRTime
(
365
)
*
oneDay
)
;
UniqueCERTValidity
validity
(
CERT_CreateValidity
(
notBefore
notAfter
)
)
;
if
(
!
validity
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
unsigned
long
serial
;
rv
=
MapSECStatus
(
PK11_GenerateRandomOnSlot
(
slot
.
get
(
)
BitwiseCast
<
unsigned
char
*
unsigned
long
*
>
(
&
serial
)
sizeof
(
serial
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
UniqueCERTCertificate
cert
(
CERT_CreateCertificate
(
serial
subjectName
.
get
(
)
validity
.
get
(
)
certRequest
.
get
(
)
)
)
;
if
(
!
cert
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
if
(
!
cert
-
>
version
.
data
)
{
return
NS_ERROR_INVALID_POINTER
;
}
*
(
cert
-
>
version
.
data
)
=
SEC_CERTIFICATE_VERSION_3
;
cert
-
>
version
.
len
=
1
;
PLArenaPool
*
arena
=
cert
-
>
arena
;
if
(
!
arena
)
{
return
NS_ERROR_INVALID_POINTER
;
}
rv
=
MapSECStatus
(
SECOID_SetAlgorithmID
(
arena
&
cert
-
>
signature
SEC_OID_ANSIX962_ECDSA_SHA256_SIGNATURE
0
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
UniqueSECItem
certDER
(
SEC_ASN1EncodeItem
(
nullptr
nullptr
cert
.
get
(
)
SEC_ASN1_GET
(
CERT_CertificateTemplate
)
)
)
;
if
(
!
certDER
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
rv
=
MapSECStatus
(
SEC_DerSignData
(
arena
&
cert
-
>
derCert
certDER
-
>
data
certDER
-
>
len
privateKey
.
get
(
)
SEC_OID_ANSIX962_ECDSA_SHA256_SIGNATURE
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
UniqueCERTCertificate
certFromDER
(
CERT_NewTempCertificate
(
CERT_GetDefaultCertDB
(
)
&
cert
-
>
derCert
nullptr
true
true
)
)
;
if
(
!
certFromDER
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
rv
=
MapSECStatus
(
PK11_ImportCert
(
slot
.
get
(
)
certFromDER
.
get
(
)
CK_INVALID_HANDLE
mNickname
.
get
(
)
false
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
GetFromDB
(
)
;
}
nsresult
GetFromDB
(
)
{
UniqueCERTCertificate
cert
;
nsresult
rv
=
FindLocalCertByName
(
mNickname
cert
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
cert
)
{
return
NS_ERROR_FAILURE
;
}
mCert
=
nsNSSCertificate
:
:
Create
(
cert
.
get
(
)
)
;
return
NS_OK
;
}
nsresult
Validate
(
)
{
bool
selfSigned
;
nsresult
rv
=
mCert
-
>
GetIsSelfSigned
(
&
selfSigned
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
selfSigned
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
subjectName
;
nsAutoString
issuerName
;
mCert
-
>
GetSubjectName
(
subjectName
)
;
mCert
-
>
GetIssuerName
(
issuerName
)
;
if
(
!
subjectName
.
Equals
(
issuerName
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_NAMED_LITERAL_STRING
(
commonNamePrefix
"
CN
=
"
)
;
nsAutoString
subjectNameFromNickname
(
commonNamePrefix
+
NS_ConvertASCIItoUTF16
(
mNickname
)
)
;
if
(
!
subjectName
.
Equals
(
subjectNameFromNickname
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIX509CertValidity
>
validity
;
mCert
-
>
GetValidity
(
getter_AddRefs
(
validity
)
)
;
PRTime
notBefore
notAfter
;
validity
-
>
GetNotBefore
(
&
notBefore
)
;
validity
-
>
GetNotAfter
(
&
notAfter
)
;
static
const
PRTime
oneDay
=
PRTime
(
PR_USEC_PER_SEC
)
*
PRTime
(
60
)
*
PRTime
(
60
)
*
PRTime
(
24
)
;
PRTime
now
=
PR_Now
(
)
;
if
(
notBefore
>
now
|
|
notAfter
<
(
now
-
oneDay
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
virtual
void
CallCallback
(
nsresult
rv
)
override
{
(
void
)
mCallback
-
>
HandleCert
(
mCert
rv
)
;
}
nsMainThreadPtrHandle
<
nsILocalCertGetCallback
>
mCallback
;
nsCOMPtr
<
nsIX509Cert
>
mCert
;
}
;
class
LocalCertRemoveTask
final
:
public
LocalCertTask
{
public
:
LocalCertRemoveTask
(
const
nsACString
&
aNickname
nsILocalCertCallback
*
aCallback
)
:
LocalCertTask
(
aNickname
)
mCallback
(
new
nsMainThreadPtrHolder
<
nsILocalCertCallback
>
(
"
LocalCertRemoveTask
:
:
mCallback
"
aCallback
)
)
{
}
private
:
virtual
nsresult
CalculateResult
(
)
override
{
return
RemoveExisting
(
)
;
}
virtual
void
CallCallback
(
nsresult
rv
)
override
{
(
void
)
mCallback
-
>
HandleResult
(
rv
)
;
}
nsMainThreadPtrHandle
<
nsILocalCertCallback
>
mCallback
;
}
;
NS_IMPL_ISUPPORTS
(
LocalCertService
nsILocalCertService
)
LocalCertService
:
:
LocalCertService
(
)
{
}
LocalCertService
:
:
~
LocalCertService
(
)
{
}
nsresult
LocalCertService
:
:
LoginToKeySlot
(
)
{
nsresult
rv
;
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
if
(
PK11_NeedUserInit
(
slot
.
get
(
)
)
)
{
rv
=
MapSECStatus
(
PK11_InitPin
(
slot
.
get
(
)
"
"
"
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
PK11_NeedLogin
(
slot
.
get
(
)
)
&
&
!
PK11_IsLoggedIn
(
slot
.
get
(
)
nullptr
)
)
{
nsCOMPtr
<
nsIPK11TokenDB
>
tokenDB
=
do_GetService
(
NS_PK11TOKENDB_CONTRACTID
)
;
if
(
!
tokenDB
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPK11Token
>
keyToken
;
tokenDB
-
>
GetInternalKeyToken
(
getter_AddRefs
(
keyToken
)
)
;
if
(
!
keyToken
)
{
return
NS_ERROR_FAILURE
;
}
return
keyToken
-
>
Login
(
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
LocalCertService
:
:
GetOrCreateCert
(
const
nsACString
&
aNickname
nsILocalCertGetCallback
*
aCallback
)
{
if
(
NS_WARN_IF
(
aNickname
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aCallback
)
)
{
return
NS_ERROR_INVALID_POINTER
;
}
nsresult
rv
=
LoginToKeySlot
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
aCallback
-
>
HandleCert
(
nullptr
rv
)
;
return
NS_OK
;
}
RefPtr
<
LocalCertGetTask
>
task
(
new
LocalCertGetTask
(
aNickname
aCallback
)
)
;
return
task
-
>
Dispatch
(
)
;
}
NS_IMETHODIMP
LocalCertService
:
:
RemoveCert
(
const
nsACString
&
aNickname
nsILocalCertCallback
*
aCallback
)
{
if
(
NS_WARN_IF
(
aNickname
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aCallback
)
)
{
return
NS_ERROR_INVALID_POINTER
;
}
nsresult
rv
=
LoginToKeySlot
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
aCallback
-
>
HandleResult
(
rv
)
;
return
NS_OK
;
}
RefPtr
<
LocalCertRemoveTask
>
task
(
new
LocalCertRemoveTask
(
aNickname
aCallback
)
)
;
return
task
-
>
Dispatch
(
)
;
}
NS_IMETHODIMP
LocalCertService
:
:
GetLoginPromptRequired
(
bool
*
aRequired
)
{
nsresult
rv
;
UniquePK11SlotInfo
slot
(
PK11_GetInternalKeySlot
(
)
)
;
if
(
!
slot
)
{
return
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
PR_GetError
(
)
)
;
}
if
(
PK11_NeedUserInit
(
slot
.
get
(
)
)
)
{
rv
=
MapSECStatus
(
PK11_InitPin
(
slot
.
get
(
)
"
"
"
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
*
aRequired
=
PK11_NeedLogin
(
slot
.
get
(
)
)
&
&
!
PK11_IsLoggedIn
(
slot
.
get
(
)
nullptr
)
;
return
NS_OK
;
}
}
