#
include
"
nsSecureBrowserUIImpl
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCURILoader
.
h
"
#
include
"
nsIAssociatedContentSecurity
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIFTPChannel
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsISSLStatus
.
h
"
#
include
"
nsISecurityInfoProvider
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsITransportSecurityInfo
.
h
"
#
include
"
nsIWebProgress
.
h
"
#
include
"
nsIWyciwygChannel
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nspr
.
h
"
#
include
"
nsString
.
h
"
using
namespace
mozilla
;
LazyLogModule
gSecureDocLog
(
"
nsSecureBrowserUI
"
)
;
struct
RequestHashEntry
:
PLDHashEntryHdr
{
void
*
r
;
}
;
static
bool
RequestMapMatchEntry
(
const
PLDHashEntryHdr
*
hdr
const
void
*
key
)
{
const
RequestHashEntry
*
entry
=
static_cast
<
const
RequestHashEntry
*
>
(
hdr
)
;
return
entry
-
>
r
=
=
key
;
}
static
void
RequestMapInitEntry
(
PLDHashEntryHdr
*
hdr
const
void
*
key
)
{
RequestHashEntry
*
entry
=
static_cast
<
RequestHashEntry
*
>
(
hdr
)
;
entry
-
>
r
=
(
void
*
)
key
;
}
static
const
PLDHashTableOps
gMapOps
=
{
PLDHashTable
:
:
HashVoidPtrKeyStub
RequestMapMatchEntry
PLDHashTable
:
:
MoveEntryStub
PLDHashTable
:
:
ClearEntryStub
RequestMapInitEntry
}
;
nsSecureBrowserUIImpl
:
:
nsSecureBrowserUIImpl
(
)
:
mNotifiedSecurityState
(
lis_no_security
)
mNotifiedToplevelIsEV
(
false
)
mNewToplevelSecurityState
(
STATE_IS_INSECURE
)
mNewToplevelIsEV
(
false
)
mNewToplevelSecurityStateKnown
(
true
)
mIsViewSource
(
false
)
mSubRequestsBrokenSecurity
(
0
)
mSubRequestsNoSecurity
(
0
)
mCertUserOverridden
(
false
)
mRestoreSubrequests
(
false
)
mOnLocationChangeSeen
(
false
)
#
ifdef
DEBUG
mEntered
(
false
)
#
endif
mTransferringRequests
(
&
gMapOps
sizeof
(
RequestHashEntry
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ResetStateTracking
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsSecureBrowserUIImpl
nsISecureBrowserUI
nsIWebProgressListener
nsISupportsWeakReference
)
NS_IMETHODIMP
nsSecureBrowserUIImpl
:
:
Init
(
mozIDOMWindowProxy
*
aWindow
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
MOZ_LOG_TEST
(
gSecureDocLog
LogLevel
:
:
Debug
)
)
{
nsCOMPtr
<
nsIDOMWindow
>
window
(
do_QueryReferent
(
mWindow
)
)
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
Init
:
mWindow
:
%
p
aWindow
:
%
p
\
n
"
this
window
.
get
(
)
aWindow
)
)
;
}
if
(
!
aWindow
)
{
NS_WARNING
(
"
Null
window
passed
to
nsSecureBrowserUIImpl
:
:
Init
(
)
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mWindow
)
{
NS_WARNING
(
"
Trying
to
init
an
nsSecureBrowserUIImpl
twice
"
)
;
return
NS_ERROR_ALREADY_INITIALIZED
;
}
nsresult
rv
;
mWindow
=
do_GetWeakReference
(
aWindow
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
auto
*
piwindow
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
nsIDocShell
*
docShell
=
piwindow
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
return
NS_ERROR_FAILURE
;
docShell
-
>
SetSecurityUI
(
this
)
;
nsCOMPtr
<
nsIWebProgress
>
wp
(
do_GetInterface
(
docShell
)
)
;
if
(
!
wp
)
return
NS_ERROR_FAILURE
;
wp
-
>
AddProgressListener
(
static_cast
<
nsIWebProgressListener
*
>
(
this
)
nsIWebProgress
:
:
NOTIFY_STATE_ALL
|
nsIWebProgress
:
:
NOTIFY_LOCATION
|
nsIWebProgress
:
:
NOTIFY_SECURITY
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSecureBrowserUIImpl
:
:
GetState
(
uint32_t
*
aState
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
MapInternalToExternalState
(
aState
mNotifiedSecurityState
mNotifiedToplevelIsEV
)
;
}
already_AddRefed
<
nsISupports
>
nsSecureBrowserUIImpl
:
:
ExtractSecurityInfo
(
nsIRequest
*
aRequest
)
{
nsCOMPtr
<
nsISupports
>
retval
;
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
channel
)
channel
-
>
GetSecurityInfo
(
getter_AddRefs
(
retval
)
)
;
if
(
!
retval
)
{
nsCOMPtr
<
nsISecurityInfoProvider
>
provider
(
do_QueryInterface
(
aRequest
)
)
;
if
(
provider
)
provider
-
>
GetSecurityInfo
(
getter_AddRefs
(
retval
)
)
;
}
return
retval
.
forget
(
)
;
}
nsresult
nsSecureBrowserUIImpl
:
:
MapInternalToExternalState
(
uint32_t
*
aState
lockIconState
lock
bool
ev
)
{
NS_ENSURE_ARG
(
aState
)
;
switch
(
lock
)
{
case
lis_broken_security
:
*
aState
=
STATE_IS_BROKEN
;
break
;
case
lis_mixed_security
:
*
aState
=
STATE_IS_BROKEN
;
break
;
case
lis_high_security
:
*
aState
=
STATE_IS_SECURE
|
STATE_SECURE_HIGH
;
break
;
default
:
case
lis_no_security
:
*
aState
=
STATE_IS_INSECURE
;
break
;
}
if
(
ev
&
&
(
*
aState
&
STATE_IS_SECURE
)
)
*
aState
|
=
nsIWebProgressListener
:
:
STATE_IDENTITY_EV_TOPLEVEL
;
if
(
mCertUserOverridden
&
&
(
*
aState
&
STATE_IS_SECURE
)
)
{
*
aState
|
=
nsIWebProgressListener
:
:
STATE_CERT_USER_OVERRIDDEN
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryReferent
(
mDocShell
)
;
if
(
!
docShell
)
return
NS_OK
;
if
(
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellTreeItem
(
do_QueryInterface
(
docShell
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeRoot
;
docShellTreeItem
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
sameTypeRoot
)
)
;
MOZ_ASSERT
(
sameTypeRoot
"
No
document
shell
root
tree
item
from
document
shell
tree
item
!
"
)
;
docShell
=
do_QueryInterface
(
sameTypeRoot
)
;
if
(
!
docShell
)
return
NS_OK
;
}
if
(
lock
=
=
lis_mixed_security
&
&
!
docShell
-
>
GetHasMixedActiveContentLoaded
(
)
&
&
!
docShell
-
>
GetHasMixedDisplayContentLoaded
(
)
&
&
!
docShell
-
>
GetHasMixedActiveContentBlocked
(
)
&
&
!
docShell
-
>
GetHasMixedDisplayContentBlocked
(
)
)
{
*
aState
=
STATE_IS_SECURE
;
if
(
ev
)
{
*
aState
|
=
nsIWebProgressListener
:
:
STATE_IDENTITY_EV_TOPLEVEL
;
}
}
uint32_t
tempState
=
STATE_IS_BROKEN
;
if
(
lock
=
=
lis_no_security
)
{
tempState
=
STATE_IS_INSECURE
;
}
if
(
docShell
-
>
GetHasMixedActiveContentLoaded
(
)
&
&
docShell
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
*
aState
=
tempState
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
}
else
if
(
docShell
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
*
aState
=
tempState
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
;
}
else
if
(
docShell
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
*
aState
=
tempState
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
}
if
(
mCertUserOverridden
)
{
*
aState
|
=
nsIWebProgressListener
:
:
STATE_CERT_USER_OVERRIDDEN
;
}
if
(
docShell
-
>
GetHasMixedActiveContentBlocked
(
)
)
*
aState
|
=
nsIWebProgressListener
:
:
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
;
if
(
docShell
-
>
GetHasMixedDisplayContentBlocked
(
)
)
*
aState
|
=
nsIWebProgressListener
:
:
STATE_BLOCKED_MIXED_DISPLAY_CONTENT
;
if
(
docShell
-
>
GetHasTrackingContentBlocked
(
)
)
*
aState
|
=
nsIWebProgressListener
:
:
STATE_BLOCKED_TRACKING_CONTENT
;
if
(
docShell
-
>
GetHasTrackingContentLoaded
(
)
)
*
aState
|
=
nsIWebProgressListener
:
:
STATE_LOADED_TRACKING_CONTENT
;
if
(
mNewToplevelSecurityStateKnown
&
&
mNewToplevelSecurityState
&
STATE_CERT_DISTRUST_IMMINENT
)
{
*
aState
|
=
nsIWebProgressListener
:
:
STATE_CERT_DISTRUST_IMMINENT
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSecureBrowserUIImpl
:
:
SetDocShell
(
nsIDocShell
*
aDocShell
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
mDocShell
=
do_GetWeakReference
(
aDocShell
&
rv
)
;
return
rv
;
}
static
uint32_t
GetSecurityStateFromSecurityInfoAndRequest
(
nsISupports
*
info
nsIRequest
*
request
)
{
nsresult
res
;
uint32_t
securityState
;
nsCOMPtr
<
nsITransportSecurityInfo
>
psmInfo
(
do_QueryInterface
(
info
)
)
;
if
(
!
psmInfo
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
GetSecurityState
:
-
no
nsITransportSecurityInfo
for
%
p
\
n
"
(
nsISupports
*
)
info
)
)
;
return
nsIWebProgressListener
:
:
STATE_IS_INSECURE
;
}
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
GetSecurityState
:
-
info
is
%
p
\
n
"
(
nsISupports
*
)
info
)
)
;
res
=
psmInfo
-
>
GetSecurityState
(
&
securityState
)
;
if
(
NS_FAILED
(
res
)
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
GetSecurityState
:
-
GetSecurityState
failed
:
%
"
PRIu32
"
\
n
"
static_cast
<
uint32_t
>
(
res
)
)
)
;
securityState
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
}
if
(
securityState
!
=
nsIWebProgressListener
:
:
STATE_IS_INSECURE
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
request
)
)
;
if
(
channel
)
{
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
}
else
{
nsCOMPtr
<
imgIRequest
>
imgRequest
(
do_QueryInterface
(
request
)
)
;
if
(
imgRequest
)
{
imgRequest
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
}
}
if
(
uri
)
{
bool
isHttp
isFtp
;
if
(
(
NS_SUCCEEDED
(
uri
-
>
SchemeIs
(
"
http
"
&
isHttp
)
)
&
&
isHttp
)
|
|
(
NS_SUCCEEDED
(
uri
-
>
SchemeIs
(
"
ftp
"
&
isFtp
)
)
&
&
isFtp
)
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
GetSecurityState
:
-
"
"
channel
scheme
is
insecure
.
\
n
"
)
)
;
securityState
=
nsIWebProgressListener
:
:
STATE_IS_INSECURE
;
}
}
}
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
GetSecurityState
:
-
Returning
%
d
\
n
"
securityState
)
)
;
return
securityState
;
}
NS_IMETHODIMP
nsSecureBrowserUIImpl
:
:
OnProgressChange
(
nsIWebProgress
*
nsIRequest
*
int32_t
int32_t
int32_t
int32_t
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
have
been
excluded
in
AddProgressListener
(
)
"
)
;
return
NS_OK
;
}
void
nsSecureBrowserUIImpl
:
:
ResetStateTracking
(
)
{
mDocumentRequestsInProgress
=
0
;
mTransferringRequests
.
Clear
(
)
;
}
void
nsSecureBrowserUIImpl
:
:
EvaluateAndUpdateSecurityState
(
nsIRequest
*
aRequest
nsISupports
*
info
bool
withNewLocation
bool
withNewSink
)
{
mNewToplevelIsEV
=
false
;
bool
updateStatus
=
false
;
nsCOMPtr
<
nsISSLStatus
>
temp_SSLStatus
;
mNewToplevelSecurityState
=
GetSecurityStateFromSecurityInfoAndRequest
(
info
aRequest
)
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
remember
mNewToplevelSecurityState
=
>
%
x
\
n
"
this
mNewToplevelSecurityState
)
)
;
nsCOMPtr
<
nsITransportSecurityInfo
>
psmInfo
(
do_QueryInterface
(
info
)
)
;
if
(
psmInfo
)
{
updateStatus
=
true
;
(
void
)
psmInfo
-
>
GetSSLStatus
(
getter_AddRefs
(
temp_SSLStatus
)
)
;
if
(
temp_SSLStatus
)
{
bool
aTemp
;
if
(
NS_SUCCEEDED
(
temp_SSLStatus
-
>
GetIsExtendedValidation
(
&
aTemp
)
)
)
{
mNewToplevelIsEV
=
aTemp
;
}
}
mSecInfo
=
psmInfo
;
}
mNewToplevelSecurityStateKnown
=
true
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
remember
securityInfo
%
p
\
n
"
this
info
)
)
;
nsCOMPtr
<
nsIAssociatedContentSecurity
>
associatedContentSecurityFromRequest
(
do_QueryInterface
(
aRequest
)
)
;
if
(
associatedContentSecurityFromRequest
)
{
mCurrentToplevelSecurityInfo
=
aRequest
;
}
else
{
mCurrentToplevelSecurityInfo
=
info
;
}
mRestoreSubrequests
=
false
;
UpdateSecurityState
(
aRequest
withNewLocation
withNewSink
|
|
updateStatus
)
;
}
void
nsSecureBrowserUIImpl
:
:
UpdateSubrequestMembers
(
nsISupports
*
securityInfo
nsIRequest
*
request
)
{
uint32_t
reqState
=
GetSecurityStateFromSecurityInfoAndRequest
(
securityInfo
request
)
;
if
(
reqState
&
STATE_IS_SECURE
)
{
}
else
if
(
reqState
&
STATE_IS_BROKEN
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
subreq
BROKEN
\
n
"
this
)
)
;
+
+
mSubRequestsBrokenSecurity
;
}
else
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
subreq
INSECURE
\
n
"
this
)
)
;
+
+
mSubRequestsNoSecurity
;
}
}
NS_IMETHODIMP
nsSecureBrowserUIImpl
:
:
OnStateChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aProgressStateFlags
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ReentrancyGuard
guard
(
*
this
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
windowForProgress
;
aWebProgress
-
>
GetDOMWindow
(
getter_AddRefs
(
windowForProgress
)
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
window
(
do_QueryReferent
(
mWindow
)
)
;
MOZ_ASSERT
(
window
"
Window
has
gone
away
?
!
"
)
;
if
(
!
mIOService
)
{
mIOService
=
do_GetService
(
NS_IOSERVICE_CONTRACTID
)
;
}
bool
isNoContentResponse
=
false
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
httpChannel
)
{
uint32_t
response
;
isNoContentResponse
=
NS_SUCCEEDED
(
httpChannel
-
>
GetResponseStatus
(
&
response
)
)
&
&
(
response
=
=
204
|
|
response
=
=
205
)
;
}
const
bool
isToplevelProgress
=
(
windowForProgress
.
get
(
)
=
=
window
.
get
(
)
)
&
&
!
isNoContentResponse
;
if
(
windowForProgress
)
{
if
(
isToplevelProgress
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
progress
:
for
toplevel
\
n
"
this
)
)
;
}
else
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
progress
:
for
something
else
\
n
"
this
)
)
;
}
}
else
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
progress
:
no
window
known
\
n
"
this
)
)
;
}
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
\
n
"
this
)
)
;
if
(
mIsViewSource
)
{
return
NS_OK
;
}
if
(
!
aRequest
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
with
null
request
\
n
"
this
)
)
;
return
NS_ERROR_NULL_POINTER
;
}
if
(
MOZ_LOG_TEST
(
gSecureDocLog
LogLevel
:
:
Debug
)
)
{
nsCString
reqname
;
aRequest
-
>
GetName
(
reqname
)
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
%
p
%
p
OnStateChange
%
x
%
s
\
n
"
this
aWebProgress
aRequest
aProgressStateFlags
reqname
.
get
(
)
)
)
;
}
nsCOMPtr
<
nsISupports
>
securityInfo
(
ExtractSecurityInfo
(
aRequest
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
channel
)
{
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
}
nsCOMPtr
<
imgIRequest
>
imgRequest
(
do_QueryInterface
(
aRequest
)
)
;
if
(
imgRequest
)
{
MOZ_ASSERT
(
!
channel
"
Request
channel
somehow
not
available
"
)
;
imgRequest
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
}
if
(
uri
)
{
bool
vs
;
if
(
NS_SUCCEEDED
(
uri
-
>
SchemeIs
(
"
javascript
"
&
vs
)
)
&
&
vs
)
{
return
NS_OK
;
}
}
uint32_t
loadFlags
=
0
;
aRequest
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
aProgressStateFlags
&
STATE_START
&
&
aProgressStateFlags
&
STATE_IS_REQUEST
&
&
isToplevelProgress
&
&
loadFlags
&
nsIChannel
:
:
LOAD_DOCUMENT_URI
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
SOMETHING
STARTS
FOR
TOPMOST
DOCUMENT
\
n
"
this
)
)
;
}
if
(
aProgressStateFlags
&
STATE_STOP
&
&
aProgressStateFlags
&
STATE_IS_REQUEST
&
&
isToplevelProgress
&
&
loadFlags
&
nsIChannel
:
:
LOAD_DOCUMENT_URI
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
SOMETHING
STOPS
FOR
TOPMOST
DOCUMENT
\
n
"
this
)
)
;
}
bool
isSubDocumentRelevant
=
true
;
if
(
!
imgRequest
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpRequest
(
do_QueryInterface
(
aRequest
)
)
;
if
(
!
httpRequest
)
{
nsCOMPtr
<
nsIFileChannel
>
fileRequest
(
do_QueryInterface
(
aRequest
)
)
;
if
(
!
fileRequest
)
{
nsCOMPtr
<
nsIWyciwygChannel
>
wyciwygRequest
(
do_QueryInterface
(
aRequest
)
)
;
if
(
!
wyciwygRequest
)
{
nsCOMPtr
<
nsIFTPChannel
>
ftpRequest
(
do_QueryInterface
(
aRequest
)
)
;
if
(
!
ftpRequest
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
not
relevant
for
sub
content
\
n
"
this
)
)
;
isSubDocumentRelevant
=
false
;
}
}
}
}
}
if
(
uri
&
&
mIOService
)
{
bool
hasFlag
;
nsresult
rv
=
mIOService
-
>
URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_IS_LOCAL_RESOURCE
&
hasFlag
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
hasFlag
)
{
isSubDocumentRelevant
=
false
;
}
}
#
if
defined
(
DEBUG
)
if
(
aProgressStateFlags
&
STATE_STOP
&
&
channel
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
seeing
STOP
with
security
state
:
%
d
\
n
"
this
GetSecurityStateFromSecurityInfoAndRequest
(
securityInfo
aRequest
)
)
)
;
}
#
endif
if
(
aProgressStateFlags
&
STATE_TRANSFERRING
&
&
aProgressStateFlags
&
STATE_IS_REQUEST
)
{
mTransferringRequests
.
Add
(
aRequest
fallible
)
;
return
NS_OK
;
}
bool
requestHasTransferedData
=
false
;
if
(
aProgressStateFlags
&
STATE_STOP
&
&
aProgressStateFlags
&
STATE_IS_REQUEST
)
{
PLDHashEntryHdr
*
entry
=
mTransferringRequests
.
Search
(
aRequest
)
;
if
(
entry
)
{
mTransferringRequests
.
RemoveEntry
(
entry
)
;
requestHasTransferedData
=
true
;
}
if
(
!
requestHasTransferedData
)
{
nsCOMPtr
<
nsISecurityInfoProvider
>
securityInfoProvider
=
do_QueryInterface
(
aRequest
)
;
bool
hasTransferred
;
requestHasTransferedData
=
securityInfoProvider
&
&
(
NS_FAILED
(
securityInfoProvider
-
>
GetHasTransferredData
(
&
hasTransferred
)
)
|
|
hasTransferred
)
;
}
}
bool
allowSecurityStateChange
=
true
;
if
(
loadFlags
&
nsIChannel
:
:
LOAD_RETARGETED_DOCUMENT_URI
)
{
allowSecurityStateChange
=
false
;
}
if
(
aProgressStateFlags
&
STATE_START
&
&
aProgressStateFlags
&
STATE_IS_REQUEST
&
&
isToplevelProgress
&
&
loadFlags
&
nsIChannel
:
:
LOAD_DOCUMENT_URI
)
{
int32_t
saveSubBroken
;
int32_t
saveSubNo
;
nsCOMPtr
<
nsIAssociatedContentSecurity
>
prevContentSecurity
;
int32_t
newSubBroken
=
0
;
int32_t
newSubNo
=
0
;
bool
inProgress
=
(
mDocumentRequestsInProgress
!
=
0
)
;
if
(
allowSecurityStateChange
&
&
!
inProgress
)
{
saveSubBroken
=
mSubRequestsBrokenSecurity
;
saveSubNo
=
mSubRequestsNoSecurity
;
prevContentSecurity
=
do_QueryInterface
(
mCurrentToplevelSecurityInfo
)
;
}
if
(
allowSecurityStateChange
&
&
!
inProgress
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
start
for
toplevel
document
\
n
"
this
)
)
;
if
(
prevContentSecurity
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
start
saving
current
sub
state
\
n
"
this
)
)
;
prevContentSecurity
-
>
SetCountSubRequestsBrokenSecurity
(
saveSubBroken
)
;
prevContentSecurity
-
>
SetCountSubRequestsNoSecurity
(
saveSubNo
)
;
prevContentSecurity
-
>
Flush
(
)
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
Saving
subs
in
START
to
%
p
as
%
d
%
d
\
n
"
this
prevContentSecurity
.
get
(
)
saveSubBroken
saveSubNo
)
)
;
}
bool
retrieveAssociatedState
=
false
;
if
(
securityInfo
&
&
(
aProgressStateFlags
&
nsIWebProgressListener
:
:
STATE_RESTORING
)
!
=
0
)
{
retrieveAssociatedState
=
true
;
}
else
{
nsCOMPtr
<
nsIWyciwygChannel
>
wyciwygRequest
(
do_QueryInterface
(
aRequest
)
)
;
if
(
wyciwygRequest
)
{
retrieveAssociatedState
=
true
;
}
}
if
(
retrieveAssociatedState
)
{
nsCOMPtr
<
nsIAssociatedContentSecurity
>
newContentSecurity
(
do_QueryInterface
(
securityInfo
)
)
;
if
(
newContentSecurity
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
start
loading
old
sub
state
\
n
"
this
)
)
;
newContentSecurity
-
>
GetCountSubRequestsBrokenSecurity
(
&
newSubBroken
)
;
newContentSecurity
-
>
GetCountSubRequestsNoSecurity
(
&
newSubNo
)
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
Restoring
subs
in
START
from
%
p
to
%
d
%
d
\
n
"
this
newContentSecurity
.
get
(
)
newSubBroken
newSubNo
)
)
;
}
}
else
{
mRestoreSubrequests
=
true
;
}
}
if
(
allowSecurityStateChange
&
&
!
inProgress
)
{
ResetStateTracking
(
)
;
mSubRequestsBrokenSecurity
=
newSubBroken
;
mSubRequestsNoSecurity
=
newSubNo
;
mNewToplevelSecurityStateKnown
=
false
;
}
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
+
+
mDocumentRequestsInProgress
\
n
"
this
)
)
;
+
+
mDocumentRequestsInProgress
;
return
NS_OK
;
}
if
(
aProgressStateFlags
&
STATE_STOP
&
&
aProgressStateFlags
&
STATE_IS_REQUEST
&
&
isToplevelProgress
&
&
loadFlags
&
nsIChannel
:
:
LOAD_DOCUMENT_URI
)
{
nsCOMPtr
<
nsISecurityEventSink
>
temp_ToplevelEventSink
;
if
(
allowSecurityStateChange
)
{
temp_ToplevelEventSink
=
mToplevelEventSink
;
}
if
(
mDocumentRequestsInProgress
<
=
0
)
{
return
NS_OK
;
}
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnStateChange
:
-
-
mDocumentRequestsInProgress
\
n
"
this
)
)
;
if
(
!
temp_ToplevelEventSink
&
&
channel
)
{
if
(
allowSecurityStateChange
)
{
ObtainEventSink
(
channel
temp_ToplevelEventSink
)
;
}
}
bool
sinkChanged
=
false
;
bool
inProgress
;
if
(
allowSecurityStateChange
)
{
sinkChanged
=
(
mToplevelEventSink
!
=
temp_ToplevelEventSink
)
;
mToplevelEventSink
=
temp_ToplevelEventSink
;
}
-
-
mDocumentRequestsInProgress
;
inProgress
=
mDocumentRequestsInProgress
>
0
;
if
(
allowSecurityStateChange
&
&
requestHasTransferedData
)
{
if
(
sinkChanged
|
|
mOnLocationChangeSeen
)
{
EvaluateAndUpdateSecurityState
(
aRequest
securityInfo
false
sinkChanged
)
;
return
NS_OK
;
}
}
mOnLocationChangeSeen
=
false
;
if
(
mRestoreSubrequests
&
&
!
inProgress
)
{
nsCOMPtr
<
nsIAssociatedContentSecurity
>
currentContentSecurity
(
do_QueryInterface
(
mCurrentToplevelSecurityInfo
)
)
;
mRestoreSubrequests
=
false
;
mNewToplevelSecurityStateKnown
=
true
;
int32_t
subBroken
=
0
;
int32_t
subNo
=
0
;
if
(
currentContentSecurity
)
{
currentContentSecurity
-
>
GetCountSubRequestsBrokenSecurity
(
&
subBroken
)
;
currentContentSecurity
-
>
GetCountSubRequestsNoSecurity
(
&
subNo
)
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
Restoring
subs
in
STOP
from
%
p
to
%
d
%
d
\
n
"
this
currentContentSecurity
.
get
(
)
subBroken
subNo
)
)
;
}
mSubRequestsBrokenSecurity
=
subBroken
;
mSubRequestsNoSecurity
=
subNo
;
}
return
NS_OK
;
}
if
(
aProgressStateFlags
&
STATE_STOP
&
&
aProgressStateFlags
&
STATE_IS_REQUEST
)
{
if
(
!
isSubDocumentRelevant
)
return
NS_OK
;
if
(
allowSecurityStateChange
&
&
requestHasTransferedData
)
{
UpdateSubrequestMembers
(
securityInfo
aRequest
)
;
if
(
mNewToplevelSecurityStateKnown
)
{
UpdateSecurityState
(
aRequest
false
false
)
;
}
}
return
NS_OK
;
}
return
NS_OK
;
}
void
nsSecureBrowserUIImpl
:
:
ObtainEventSink
(
nsIChannel
*
channel
nsCOMPtr
<
nsISecurityEventSink
>
&
sink
)
{
if
(
!
sink
)
NS_QueryNotificationCallbacks
(
channel
sink
)
;
}
void
nsSecureBrowserUIImpl
:
:
UpdateSecurityState
(
nsIRequest
*
aRequest
bool
withNewLocation
bool
withUpdateStatus
)
{
lockIconState
newSecurityState
=
lis_no_security
;
if
(
mNewToplevelSecurityState
&
STATE_IS_SECURE
)
{
if
(
mSubRequestsBrokenSecurity
|
|
mSubRequestsNoSecurity
)
{
newSecurityState
=
lis_mixed_security
;
}
else
{
newSecurityState
=
lis_high_security
;
}
}
if
(
mNewToplevelSecurityState
&
STATE_IS_BROKEN
)
{
newSecurityState
=
lis_broken_security
;
}
mCertUserOverridden
=
mNewToplevelSecurityState
&
STATE_CERT_USER_OVERRIDDEN
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
UpdateSecurityState
:
old
-
new
%
d
-
%
d
\
n
"
this
mNotifiedSecurityState
newSecurityState
)
)
;
bool
flagsChanged
=
false
;
if
(
mNotifiedSecurityState
!
=
newSecurityState
)
{
flagsChanged
=
true
;
mNotifiedSecurityState
=
newSecurityState
;
if
(
newSecurityState
=
=
lis_no_security
)
{
mSecInfo
=
nullptr
;
}
}
if
(
mNotifiedToplevelIsEV
!
=
mNewToplevelIsEV
)
{
flagsChanged
=
true
;
mNotifiedToplevelIsEV
=
mNewToplevelIsEV
;
}
if
(
flagsChanged
|
|
withNewLocation
|
|
withUpdateStatus
)
{
TellTheWorld
(
aRequest
)
;
}
}
void
nsSecureBrowserUIImpl
:
:
TellTheWorld
(
nsIRequest
*
aRequest
)
{
uint32_t
state
=
STATE_IS_INSECURE
;
GetState
(
&
state
)
;
if
(
mToplevelEventSink
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
UpdateSecurityState
:
calling
OnSecurityChange
\
n
"
this
)
)
;
mToplevelEventSink
-
>
OnSecurityChange
(
aRequest
state
)
;
}
else
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
UpdateSecurityState
:
NO
mToplevelEventSink
!
\
n
"
this
)
)
;
}
}
NS_IMETHODIMP
nsSecureBrowserUIImpl
:
:
OnLocationChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsIURI
*
aLocation
uint32_t
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ReentrancyGuard
guard
(
*
this
)
;
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnLocationChange
\
n
"
this
)
)
;
bool
updateIsViewSource
=
false
;
bool
temp_IsViewSource
=
false
;
nsCOMPtr
<
mozIDOMWindowProxy
>
window
;
if
(
aLocation
)
{
bool
vs
;
nsresult
rv
=
aLocation
-
>
SchemeIs
(
"
view
-
source
"
&
vs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
vs
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnLocationChange
:
view
-
source
\
n
"
this
)
)
;
}
updateIsViewSource
=
true
;
temp_IsViewSource
=
vs
;
}
if
(
updateIsViewSource
)
{
mIsViewSource
=
temp_IsViewSource
;
}
mCurrentURI
=
aLocation
;
window
=
do_QueryReferent
(
mWindow
)
;
MOZ_ASSERT
(
window
"
Window
has
gone
away
?
!
"
)
;
if
(
aFlags
&
LOCATION_CHANGE_SAME_DOCUMENT
)
return
NS_OK
;
nsCOMPtr
<
mozIDOMWindowProxy
>
windowForProgress
;
aWebProgress
-
>
GetDOMWindow
(
getter_AddRefs
(
windowForProgress
)
)
;
nsCOMPtr
<
nsISupports
>
securityInfo
(
ExtractSecurityInfo
(
aRequest
)
)
;
if
(
windowForProgress
.
get
(
)
=
=
window
.
get
(
)
)
{
mOnLocationChangeSeen
=
true
;
EvaluateAndUpdateSecurityState
(
aRequest
securityInfo
true
false
)
;
return
NS_OK
;
}
UpdateSubrequestMembers
(
securityInfo
aRequest
)
;
if
(
mNewToplevelSecurityStateKnown
)
{
UpdateSecurityState
(
aRequest
true
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSecureBrowserUIImpl
:
:
OnStatusChange
(
nsIWebProgress
*
nsIRequest
*
nsresult
const
char16_t
*
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
have
been
excluded
in
AddProgressListener
(
)
"
)
;
return
NS_OK
;
}
nsresult
nsSecureBrowserUIImpl
:
:
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
state
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
if
defined
(
DEBUG
)
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
!
channel
)
return
NS_OK
;
nsCOMPtr
<
nsIURI
>
aURI
;
channel
-
>
GetURI
(
getter_AddRefs
(
aURI
)
)
;
if
(
aURI
)
{
MOZ_LOG
(
gSecureDocLog
LogLevel
:
:
Debug
(
"
SecureUI
:
%
p
:
OnSecurityChange
:
(
%
x
)
%
s
\
n
"
this
state
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
nsSecureBrowserUIImpl
:
:
GetSecInfo
(
nsITransportSecurityInfo
*
*
_result
)
{
NS_ENSURE_ARG_POINTER
(
_result
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
mNotifiedSecurityState
)
{
case
lis_broken_security
:
case
lis_mixed_security
:
case
lis_high_security
:
break
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
if
this
is
reached
you
must
add
more
entries
to
the
switch
"
)
;
case
lis_no_security
:
*
_result
=
nullptr
;
return
NS_OK
;
}
*
_result
=
mSecInfo
;
NS_IF_ADDREF
(
*
_result
)
;
return
NS_OK
;
}
