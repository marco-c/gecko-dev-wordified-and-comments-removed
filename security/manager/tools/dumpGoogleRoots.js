"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLHttpRequest
"
]
)
;
function
downloadRoots
(
)
{
let
req
=
new
XMLHttpRequest
(
)
;
req
.
open
(
"
GET
"
"
https
:
/
/
pki
.
google
.
com
/
roots
.
pem
"
false
)
;
try
{
req
.
send
(
)
;
}
catch
(
e
)
{
throw
new
Error
(
"
ERROR
:
problem
downloading
Google
Root
PEMs
:
"
+
e
)
;
}
if
(
req
.
status
!
=
200
)
{
throw
new
Error
(
"
ERROR
:
problem
downloading
Google
Root
PEMs
.
Status
:
"
+
req
.
status
)
;
}
let
pem
=
req
.
responseText
;
let
roots
=
[
]
;
let
currentPEM
=
"
"
;
let
readingRoot
=
false
;
let
certDB
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
for
(
let
line
of
pem
.
split
(
/
[
\
r
\
n
]
/
)
)
{
if
(
line
=
=
"
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
"
)
{
if
(
currentPEM
)
{
roots
.
push
(
certDB
.
constructX509FromBase64
(
currentPEM
)
)
;
}
currentPEM
=
"
"
;
readingRoot
=
false
;
continue
;
}
if
(
readingRoot
)
{
currentPEM
+
=
line
;
}
if
(
line
=
=
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
"
)
{
readingRoot
=
true
;
}
}
return
roots
;
}
function
makeFormattedNickname
(
cert
)
{
if
(
cert
.
isBuiltInRoot
)
{
return
"
{
cert
.
displayName
}
"
;
}
return
/
/
"
{
cert
.
displayName
}
"
;
}
var
roots
=
downloadRoots
(
)
;
var
rootNicknames
=
[
]
;
for
(
var
root
of
roots
)
{
rootNicknames
.
push
(
makeFormattedNickname
(
root
)
)
;
}
rootNicknames
.
sort
(
function
(
rootA
rootB
)
{
let
rootALowercase
=
rootA
.
toLowerCase
(
)
.
replace
(
/
(
^
[
^
"
]
*
"
)
|
"
/
g
"
"
)
;
let
rootBLowercase
=
rootB
.
toLowerCase
(
)
.
replace
(
/
(
^
[
^
"
]
*
"
)
|
"
/
g
"
"
)
;
if
(
rootALowercase
<
rootBLowercase
)
{
return
-
1
;
}
if
(
rootALowercase
>
rootBLowercase
)
{
return
1
;
}
return
0
;
}
)
;
dump
(
"
{
\
n
"
)
;
dump
(
"
\
"
name
\
"
:
\
"
google_root_pems
\
"
\
n
"
)
;
dump
(
"
\
"
sha256_hashes
\
"
:
[
\
n
"
)
;
var
first
=
true
;
for
(
var
nickname
of
rootNicknames
)
{
if
(
!
first
)
{
dump
(
"
\
n
"
)
;
}
first
=
false
;
dump
(
"
"
+
nickname
)
;
}
dump
(
"
\
n
"
)
;
dump
(
"
]
\
n
"
)
;
dump
(
"
}
\
n
"
)
;
