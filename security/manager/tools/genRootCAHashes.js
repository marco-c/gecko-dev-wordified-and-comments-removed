"
use
strict
"
;
const
nsX509CertDB
=
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
;
const
CertDb
=
Cc
[
nsX509CertDB
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
const
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
FILENAME_OUTPUT
=
"
RootHashes
.
inc
"
;
const
FILENAME_TRUST_ANCHORS
=
"
KnownRootHashes
.
json
"
;
const
ROOT_NOT_ASSIGNED
=
-
1
;
const
JSON_HEADER
=
/
/
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
/
/
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
/
/
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
/
/
/
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
/
This
is
an
automatically
generated
file
.
It
'
s
used
to
maintain
state
for
/
/
runs
of
genRootCAHashes
.
js
;
you
should
never
need
to
manually
edit
it
/
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
/
Notes
:
/
/
binNumber
1
used
to
be
for
"
GTE_CyberTrust_Global_Root
"
but
that
root
was
/
/
removed
from
the
built
-
in
roots
module
so
now
it
is
used
to
indicate
that
/
/
the
certificate
is
not
a
built
-
in
and
was
found
in
the
softoken
(
cert9
.
db
)
.
/
/
binNumber
2
used
to
be
for
"
Thawte_Server_CA
"
but
that
root
was
removed
from
/
/
the
built
-
in
roots
module
so
now
it
is
used
to
indicate
that
the
certificate
/
/
is
not
a
built
-
in
and
was
found
on
an
external
PKCS
#
11
token
.
/
/
binNumber
3
used
to
be
for
"
Thawte_Premium_Server_CA
"
but
that
root
was
/
/
removed
from
the
built
-
in
roots
module
so
now
it
is
used
to
indicate
that
/
/
the
certificate
is
not
a
built
-
in
and
was
temporarily
imported
from
the
OS
as
/
/
part
of
the
"
Enterprise
Roots
"
feature
.
;
const
FILE_HEADER
=
"
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
\
n
"
+
"
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
\
n
"
+
"
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
\
n
"
+
"
\
n
"
+
"
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
\
n
"
+
"
/
*
This
is
an
automatically
generated
file
.
If
you
'
re
not
*
/
\
n
"
+
"
/
*
RootCertificateTelemetryUtils
.
cpp
you
shouldn
'
t
be
#
including
it
.
*
/
\
n
"
+
"
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
\
n
"
+
"
\
n
"
+
"
#
define
HASH_LEN
32
\
n
"
;
const
FP_PREAMBLE
=
"
struct
CertAuthorityHash
{
\
n
"
+
"
/
/
See
bug
1338873
about
making
these
fields
const
.
\
n
"
+
"
uint8_t
hash
[
HASH_LEN
]
;
\
n
"
+
"
int32_t
binNumber
;
\
n
"
+
"
}
;
\
n
\
n
"
+
"
static
const
struct
CertAuthorityHash
ROOT_TABLE
[
]
=
{
\
n
"
;
const
FP_POSTAMBLE
=
"
}
;
\
n
"
;
function
writeString
(
fos
string
)
{
fos
.
write
(
string
string
.
length
)
;
}
function
stripColons
(
hexString
)
{
return
hexString
.
replace
(
/
:
/
g
"
"
)
;
}
function
hexSlice
(
bytes
start
end
)
{
let
ret
=
"
"
;
for
(
let
i
=
start
;
i
<
end
;
i
+
+
)
{
let
hex
=
(
0
+
bytes
.
charCodeAt
(
i
)
.
toString
(
16
)
)
.
slice
(
-
2
)
.
toUpperCase
(
)
;
ret
+
=
"
0x
"
+
hex
;
if
(
i
<
end
-
1
)
{
ret
+
=
"
"
;
}
}
return
ret
;
}
function
stripComments
(
buf
)
{
let
lines
=
buf
.
split
(
"
\
n
"
)
;
let
entryRegex
=
/
^
\
s
*
\
/
\
/
/
;
let
data
=
"
"
;
for
(
let
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
{
let
match
=
entryRegex
.
exec
(
lines
[
i
]
)
;
if
(
!
match
)
{
data
=
data
+
lines
[
i
]
;
}
}
return
data
;
}
function
loadTrustAnchors
(
file
)
{
if
(
file
.
exists
(
)
)
{
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
file
-
1
0
0
)
;
let
buf
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
return
JSON
.
parse
(
stripComments
(
buf
)
)
;
}
return
{
roots
:
[
]
maxBin
:
0
}
;
}
function
writeTrustAnchors
(
file
)
{
let
fos
=
FileUtils
.
openSafeFileOutputStream
(
file
)
;
let
serializedData
=
JSON
.
stringify
(
gTrustAnchors
null
"
"
)
;
fos
.
write
(
JSON_HEADER
JSON_HEADER
.
length
)
;
fos
.
write
(
serializedData
serializedData
.
length
)
;
FileUtils
.
closeSafeFileOutputStream
(
fos
)
;
}
function
writeRootHashes
(
fos
)
{
try
{
writeString
(
fos
FILE_HEADER
)
;
writeString
(
fos
FP_PREAMBLE
)
;
gTrustAnchors
.
roots
.
forEach
(
function
(
fp
)
{
let
fpBytes
=
atob
(
fp
.
sha256Fingerprint
)
;
writeString
(
fos
"
{
\
n
"
)
;
writeString
(
fos
"
/
*
"
+
fp
.
label
+
"
*
/
\
n
"
)
;
writeString
(
fos
"
{
"
+
hexSlice
(
fpBytes
0
16
)
+
"
\
n
"
)
;
writeString
(
fos
"
"
+
hexSlice
(
fpBytes
16
32
)
+
"
}
\
n
"
)
;
writeString
(
fos
"
"
+
fp
.
binNumber
+
"
/
*
Bin
Number
*
/
\
n
"
)
;
writeString
(
fos
"
}
\
n
"
)
;
}
)
;
writeString
(
fos
FP_POSTAMBLE
)
;
writeString
(
fos
"
\
n
"
)
;
}
catch
(
e
)
{
dump
(
"
ERROR
:
problem
writing
output
:
"
+
e
+
"
\
n
"
)
;
}
}
function
findTrustAnchorByFingerprint
(
sha256Fingerprint
)
{
for
(
let
i
=
0
;
i
<
gTrustAnchors
.
roots
.
length
;
i
+
+
)
{
if
(
sha256Fingerprint
=
=
gTrustAnchors
.
roots
[
i
]
.
sha256Fingerprint
)
{
return
i
;
}
}
return
ROOT_NOT_ASSIGNED
;
}
function
getLabelForCert
(
cert
)
{
let
label
=
cert
.
commonName
;
if
(
label
.
length
<
5
)
{
label
=
cert
.
subjectName
;
}
label
=
label
.
replace
(
/
[
^
[
:
ascii
:
]
]
/
g
"
_
"
)
;
label
=
label
.
replace
(
/
[
^
A
-
Za
-
z0
-
9
]
/
g
"
_
"
)
;
return
label
;
}
function
insertTrustAnchorsFromDatabase
(
)
{
const
CERT_TYPE
=
Ci
.
nsIX509Cert
.
CA_CERT
;
const
TRUST_TYPE
=
Ci
.
nsIX509CertDB
.
TRUSTED_SSL
;
for
(
let
cert
of
CertDb
.
getCerts
(
)
)
{
if
(
CertDb
.
isCertTrusted
(
cert
CERT_TYPE
TRUST_TYPE
)
)
{
let
binaryFingerprint
=
CommonUtils
.
hexToBytes
(
stripColons
(
cert
.
sha256Fingerprint
)
)
;
let
encodedFingerprint
=
btoa
(
binaryFingerprint
)
;
if
(
findTrustAnchorByFingerprint
(
encodedFingerprint
)
=
=
ROOT_NOT_ASSIGNED
)
{
let
label
=
getLabelForCert
(
cert
)
;
gTrustAnchors
.
maxBin
+
=
1
;
gTrustAnchors
.
roots
.
push
(
{
label
binNumber
:
gTrustAnchors
.
maxBin
sha256Fingerprint
:
encodedFingerprint
}
)
;
}
}
}
}
if
(
arguments
.
length
!
=
1
)
{
throw
new
Error
(
"
Usage
:
genRootCAHashes
.
js
<
absolute
path
to
current
RootHashes
.
inc
>
"
)
;
}
var
trustAnchorsFile
=
new
FileUtils
.
File
(
PathUtils
.
join
(
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
.
path
FILENAME_TRUST_ANCHORS
)
)
;
var
rootHashesFile
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
rootHashesFile
.
initWithPath
(
arguments
[
0
]
)
;
var
gTrustAnchors
=
loadTrustAnchors
(
trustAnchorsFile
)
;
insertTrustAnchorsFromDatabase
(
)
;
writeTrustAnchors
(
trustAnchorsFile
)
;
gTrustAnchors
.
roots
.
sort
(
function
(
a
b
)
{
let
aBin
=
atob
(
a
.
sha256Fingerprint
)
;
let
bBin
=
atob
(
b
.
sha256Fingerprint
)
;
if
(
aBin
<
bBin
)
{
return
-
1
;
}
if
(
aBin
>
bBin
)
{
return
1
;
}
return
0
;
}
)
;
var
rootHashesFileOutputStream
=
FileUtils
.
openSafeFileOutputStream
(
rootHashesFile
)
;
writeRootHashes
(
rootHashesFileOutputStream
)
;
FileUtils
.
closeSafeFileOutputStream
(
rootHashesFileOutputStream
)
;
