"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
function
setText
(
id
value
)
{
let
element
=
document
.
getElementById
(
id
)
;
if
(
!
element
)
{
return
;
}
if
(
element
.
hasChildNodes
(
)
)
{
element
.
firstChild
.
remove
(
)
;
}
element
.
appendChild
(
document
.
createTextNode
(
value
)
)
;
}
const
nsICertificateDialogs
=
Ci
.
nsICertificateDialogs
;
const
nsCertificateDialogs
=
"
mozilla
.
org
/
nsCertificateDialogs
;
1
"
;
function
viewCertHelper
(
parent
cert
)
{
if
(
!
cert
)
{
return
;
}
var
cd
=
Cc
[
nsCertificateDialogs
]
.
getService
(
nsICertificateDialogs
)
;
cd
.
viewCert
(
parent
cert
)
;
}
function
getDERString
(
cert
)
{
var
length
=
{
}
;
var
derArray
=
cert
.
getRawDER
(
length
)
;
var
derString
=
"
"
;
for
(
var
i
=
0
;
i
<
derArray
.
length
;
i
+
+
)
{
derString
+
=
String
.
fromCharCode
(
derArray
[
i
]
)
;
}
return
derString
;
}
function
getPKCS7String
(
certArray
)
{
let
certList
=
Cc
[
"
mozilla
.
org
/
security
/
x509certlist
;
1
"
]
.
createInstance
(
Ci
.
nsIX509CertList
)
;
for
(
let
cert
of
certArray
)
{
certList
.
addCert
(
cert
)
;
}
return
certList
.
asPKCS7Blob
(
)
;
}
function
getPEMString
(
cert
)
{
var
derb64
=
btoa
(
getDERString
(
cert
)
)
;
var
wrapped
=
derb64
.
replace
(
/
(
\
S
{
64
}
(
?
!
)
)
/
g
"
1
\
r
\
n
"
)
;
return
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
+
wrapped
+
"
\
r
\
n
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
;
}
function
alertPromptService
(
title
message
)
{
var
ps
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
prompt
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPromptService
)
;
ps
.
alert
(
window
title
message
)
;
}
const
DEFAULT_CERT_EXTENSION
=
"
crt
"
;
function
certToFilename
(
cert
)
{
let
filename
=
cert
.
displayName
;
filename
=
filename
.
replace
(
/
\
s
/
g
"
"
)
.
replace
(
/
\
.
/
g
"
"
)
.
replace
(
/
\
\
/
g
"
"
)
.
replace
(
/
\
/
/
g
"
"
)
;
return
{
filename
}
.
{
DEFAULT_CERT_EXTENSION
}
;
}
async
function
exportToFile
(
parent
cert
)
{
var
bundle
=
document
.
getElementById
(
"
pippki_bundle
"
)
;
if
(
!
cert
)
{
return
undefined
;
}
let
results
=
await
asyncDetermineUsages
(
cert
)
;
let
chain
=
getBestChain
(
results
)
;
if
(
!
chain
)
{
chain
=
[
cert
]
;
}
var
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
parent
bundle
.
getString
(
"
SaveCertAs
"
)
Ci
.
nsIFilePicker
.
modeSave
)
;
fp
.
defaultString
=
certToFilename
(
cert
)
;
fp
.
defaultExtension
=
DEFAULT_CERT_EXTENSION
;
fp
.
appendFilter
(
bundle
.
getString
(
"
CertFormatBase64
"
)
"
*
.
crt
;
*
.
pem
"
)
;
fp
.
appendFilter
(
bundle
.
getString
(
"
CertFormatBase64Chain
"
)
"
*
.
crt
;
*
.
pem
"
)
;
fp
.
appendFilter
(
bundle
.
getString
(
"
CertFormatDER
"
)
"
*
.
der
"
)
;
fp
.
appendFilter
(
bundle
.
getString
(
"
CertFormatPKCS7
"
)
"
*
.
p7c
"
)
;
fp
.
appendFilter
(
bundle
.
getString
(
"
CertFormatPKCS7Chain
"
)
"
*
.
p7c
"
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterAll
)
;
return
new
Promise
(
resolve
=
>
{
fp
.
open
(
res
=
>
{
resolve
(
fpCallback
(
res
)
)
;
}
)
;
}
)
;
function
fpCallback
(
res
)
{
if
(
res
!
=
Ci
.
nsIFilePicker
.
returnOK
&
&
res
!
=
Ci
.
nsIFilePicker
.
returnReplace
)
{
return
;
}
var
content
=
"
"
;
switch
(
fp
.
filterIndex
)
{
case
1
:
content
=
getPEMString
(
cert
)
;
for
(
let
i
=
1
;
i
<
chain
.
length
;
i
+
+
)
{
content
+
=
getPEMString
(
chain
[
i
]
)
;
}
break
;
case
2
:
content
=
getDERString
(
cert
)
;
break
;
case
3
:
content
=
getPKCS7String
(
[
cert
]
)
;
break
;
case
4
:
content
=
getPKCS7String
(
chain
)
;
break
;
case
0
:
default
:
content
=
getPEMString
(
cert
)
;
break
;
}
var
msg
;
var
written
=
0
;
try
{
var
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
fp
.
file
.
path
)
;
var
fos
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
fos
.
init
(
file
0x02
|
0x08
|
0x20
0o0644
0
)
;
written
=
fos
.
write
(
content
content
.
length
)
;
fos
.
close
(
)
;
}
catch
(
e
)
{
switch
(
e
.
result
)
{
case
Cr
.
NS_ERROR_FILE_ACCESS_DENIED
:
msg
=
bundle
.
getString
(
"
writeFileAccessDenied
"
)
;
break
;
case
Cr
.
NS_ERROR_FILE_IS_LOCKED
:
msg
=
bundle
.
getString
(
"
writeFileIsLocked
"
)
;
break
;
case
Cr
.
NS_ERROR_FILE_NO_DEVICE_SPACE
:
case
Cr
.
NS_ERROR_FILE_DISK_FULL
:
msg
=
bundle
.
getString
(
"
writeFileNoDeviceSpace
"
)
;
break
;
default
:
msg
=
e
.
message
;
break
;
}
}
if
(
written
!
=
content
.
length
)
{
if
(
msg
.
length
=
=
0
)
{
msg
=
bundle
.
getString
(
"
writeFileUnknownError
"
)
;
}
alertPromptService
(
bundle
.
getString
(
"
writeFileFailure
"
)
bundle
.
getFormattedString
(
"
writeFileFailed
"
[
fp
.
file
.
path
msg
]
)
)
;
}
}
}
const
PRErrorCodeSuccess
=
0
;
const
certificateUsageSSLClient
=
0x0001
;
const
certificateUsageSSLServer
=
0x0002
;
const
certificateUsageSSLCA
=
0x0008
;
const
certificateUsageEmailSigner
=
0x0010
;
const
certificateUsageEmailRecipient
=
0x0020
;
const
certificateUsages
=
{
certificateUsageSSLClient
certificateUsageSSLServer
certificateUsageSSLCA
certificateUsageEmailSigner
certificateUsageEmailRecipient
}
;
function
asyncDetermineUsages
(
cert
)
{
let
promises
=
[
]
;
let
now
=
Date
.
now
(
)
/
1000
;
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
Object
.
keys
(
certificateUsages
)
.
forEach
(
usageString
=
>
{
promises
.
push
(
new
Promise
(
(
resolve
reject
)
=
>
{
let
usage
=
certificateUsages
[
usageString
]
;
certdb
.
asyncVerifyCertAtTime
(
cert
usage
0
null
now
(
aPRErrorCode
aVerifiedChain
aHasEVPolicy
)
=
>
{
resolve
(
{
usageString
errorCode
:
aPRErrorCode
chain
:
aVerifiedChain
}
)
;
}
)
;
}
)
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
function
getBestChain
(
results
)
{
let
usages
=
[
certificateUsageSSLServer
certificateUsageSSLClient
certificateUsageEmailSigner
certificateUsageEmailRecipient
certificateUsageSSLCA
]
;
for
(
let
usage
of
usages
)
{
let
chain
=
getChainForUsage
(
results
usage
)
;
if
(
chain
)
{
return
chain
;
}
}
return
null
;
}
function
getChainForUsage
(
results
usage
)
{
for
(
let
result
of
results
)
{
if
(
certificateUsages
[
result
.
usageString
]
=
=
usage
&
&
result
.
errorCode
=
=
PRErrorCodeSuccess
)
{
let
array
=
[
]
;
let
enumerator
=
result
.
chain
.
getEnumerator
(
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
cert
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIX509Cert
)
;
array
.
push
(
cert
)
;
}
return
array
;
}
}
return
null
;
}
