"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
function
setText
(
id
value
)
{
let
element
=
document
.
getElementById
(
id
)
;
if
(
!
element
)
{
return
;
}
if
(
element
.
hasChildNodes
(
)
)
{
element
.
firstChild
.
remove
(
)
;
}
element
.
appendChild
(
document
.
createTextNode
(
value
)
)
;
}
const
nsICertificateDialogs
=
Ci
.
nsICertificateDialogs
;
const
nsCertificateDialogs
=
"
mozilla
.
org
/
nsCertificateDialogs
;
1
"
;
function
viewCertHelper
(
parent
cert
)
{
if
(
!
cert
)
{
return
;
}
Services
.
ww
.
openWindow
(
parent
"
chrome
:
/
/
pippki
/
content
/
certViewer
.
xul
"
"
_blank
"
"
centerscreen
chrome
"
cert
)
;
}
function
getDERString
(
cert
)
{
var
length
=
{
}
;
var
derArray
=
cert
.
getRawDER
(
length
)
;
var
derString
=
"
"
;
for
(
var
i
=
0
;
i
<
derArray
.
length
;
i
+
+
)
{
derString
+
=
String
.
fromCharCode
(
derArray
[
i
]
)
;
}
return
derString
;
}
function
getPKCS7String
(
certArray
)
{
let
certList
=
Cc
[
"
mozilla
.
org
/
security
/
x509certlist
;
1
"
]
.
createInstance
(
Ci
.
nsIX509CertList
)
;
for
(
let
cert
of
certArray
)
{
certList
.
addCert
(
cert
)
;
}
return
certList
.
asPKCS7Blob
(
)
;
}
function
getPEMString
(
cert
)
{
var
derb64
=
btoa
(
getDERString
(
cert
)
)
;
var
wrapped
=
derb64
.
replace
(
/
(
\
S
{
64
}
(
?
!
)
)
/
g
"
1
\
r
\
n
"
)
;
return
"
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
+
wrapped
+
"
\
r
\
n
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
\
r
\
n
"
;
}
function
alertPromptService
(
title
message
)
{
var
ps
=
Cc
[
"
mozilla
.
org
/
embedcomp
/
prompt
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPromptService
)
;
ps
.
alert
(
window
title
message
)
;
}
const
DEFAULT_CERT_EXTENSION
=
"
crt
"
;
function
certToFilename
(
cert
)
{
let
filename
=
cert
.
displayName
;
filename
=
filename
.
replace
(
/
\
s
/
g
"
"
)
.
replace
(
/
\
.
/
g
"
"
)
.
replace
(
/
\
\
/
g
"
"
)
.
replace
(
/
\
/
/
g
"
"
)
;
return
{
filename
}
.
{
DEFAULT_CERT_EXTENSION
}
;
}
async
function
exportToFile
(
parent
cert
)
{
if
(
!
cert
)
{
return
;
}
let
results
=
await
asyncDetermineUsages
(
cert
)
;
let
chain
=
getBestChain
(
results
)
;
if
(
!
chain
)
{
chain
=
[
cert
]
;
}
let
formats
=
{
"
base64
"
:
"
*
.
crt
;
*
.
pem
"
"
base64
-
chain
"
:
"
*
.
crt
;
*
.
pem
"
"
der
"
:
"
*
.
der
"
"
pkcs7
"
:
"
*
.
p7c
"
"
pkcs7
-
chain
"
:
"
*
.
p7c
"
}
;
let
[
saveCertAs
.
.
.
formatLabels
]
=
await
document
.
l10n
.
formatValues
(
[
"
save
-
cert
-
as
"
.
.
.
Object
.
keys
(
formats
)
.
map
(
f
=
>
"
cert
-
format
-
"
+
f
)
]
.
map
(
id
=
>
(
{
id
}
)
)
)
;
var
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
parent
saveCertAs
Ci
.
nsIFilePicker
.
modeSave
)
;
fp
.
defaultString
=
certToFilename
(
cert
)
;
fp
.
defaultExtension
=
DEFAULT_CERT_EXTENSION
;
for
(
let
format
of
Object
.
values
(
formats
)
)
{
fp
.
appendFilter
(
formatLabels
.
shift
(
)
format
)
;
}
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterAll
)
;
let
filePickerResult
=
await
new
Promise
(
resolve
=
>
{
fp
.
open
(
resolve
)
;
}
)
;
if
(
filePickerResult
!
=
Ci
.
nsIFilePicker
.
returnOK
&
&
filePickerResult
!
=
Ci
.
nsIFilePicker
.
returnReplace
)
{
return
;
}
var
content
=
"
"
;
switch
(
fp
.
filterIndex
)
{
case
1
:
content
=
getPEMString
(
cert
)
;
for
(
let
i
=
1
;
i
<
chain
.
length
;
i
+
+
)
{
content
+
=
getPEMString
(
chain
[
i
]
)
;
}
break
;
case
2
:
content
=
getDERString
(
cert
)
;
break
;
case
3
:
content
=
getPKCS7String
(
[
cert
]
)
;
break
;
case
4
:
content
=
getPKCS7String
(
chain
)
;
break
;
case
0
:
default
:
content
=
getPEMString
(
cert
)
;
break
;
}
try
{
await
OS
.
File
.
writeAtomic
(
fp
.
file
.
path
content
)
;
}
catch
(
ex
)
{
let
title
=
await
document
.
l10n
.
formatValue
(
"
write
-
file
-
failure
"
)
;
alertPromptService
(
title
ex
.
toString
(
)
)
;
}
if
(
Cu
.
isInAutomation
)
{
Services
.
obs
.
notifyObservers
(
null
"
cert
-
export
-
finished
"
)
;
}
}
const
PRErrorCodeSuccess
=
0
;
const
certificateUsageSSLClient
=
0x0001
;
const
certificateUsageSSLServer
=
0x0002
;
const
certificateUsageSSLCA
=
0x0008
;
const
certificateUsageEmailSigner
=
0x0010
;
const
certificateUsageEmailRecipient
=
0x0020
;
const
certificateUsages
=
{
certificateUsageSSLClient
certificateUsageSSLServer
certificateUsageSSLCA
certificateUsageEmailSigner
certificateUsageEmailRecipient
}
;
function
asyncDetermineUsages
(
cert
)
{
let
promises
=
[
]
;
let
now
=
Date
.
now
(
)
/
1000
;
let
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
Object
.
keys
(
certificateUsages
)
.
forEach
(
usageString
=
>
{
promises
.
push
(
new
Promise
(
(
resolve
reject
)
=
>
{
let
usage
=
certificateUsages
[
usageString
]
;
certdb
.
asyncVerifyCertAtTime
(
cert
usage
0
null
now
(
aPRErrorCode
aVerifiedChain
aHasEVPolicy
)
=
>
{
resolve
(
{
usageString
errorCode
:
aPRErrorCode
chain
:
aVerifiedChain
}
)
;
}
)
;
}
)
)
;
}
)
;
return
Promise
.
all
(
promises
)
;
}
function
getBestChain
(
results
)
{
let
usages
=
[
certificateUsageSSLServer
certificateUsageSSLClient
certificateUsageEmailSigner
certificateUsageEmailRecipient
certificateUsageSSLCA
]
;
for
(
let
usage
of
usages
)
{
let
chain
=
getChainForUsage
(
results
usage
)
;
if
(
chain
)
{
return
chain
;
}
}
return
null
;
}
function
getChainForUsage
(
results
usage
)
{
for
(
let
result
of
results
)
{
if
(
certificateUsages
[
result
.
usageString
]
=
=
usage
&
&
result
.
errorCode
=
=
PRErrorCodeSuccess
)
{
return
Array
.
from
(
result
.
chain
.
getEnumerator
(
)
)
;
}
}
return
null
;
}
