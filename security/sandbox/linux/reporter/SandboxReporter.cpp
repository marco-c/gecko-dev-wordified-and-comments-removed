#
include
"
SandboxReporter
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
<
algorithm
>
#
include
<
errno
.
h
>
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
time
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
#
if
defined
(
__i386__
)
#
define
SANDBOX_ARCH_NAME
"
x86
"
#
elif
defined
(
__x86_64__
)
#
define
SANDBOX_ARCH_NAME
"
amd64
"
#
else
#
error
"
unrecognized
architecture
"
#
endif
namespace
mozilla
{
StaticAutoPtr
<
SandboxReporter
>
SandboxReporter
:
:
sSingleton
;
SandboxReporter
:
:
SandboxReporter
(
)
:
mClientFd
(
-
1
)
mServerFd
(
-
1
)
mMutex
(
"
SandboxReporter
"
)
mBuffer
(
MakeUnique
<
SandboxReport
[
]
>
(
kSandboxReporterBufferSize
)
)
mCount
(
0
)
{
}
bool
SandboxReporter
:
:
Init
(
)
{
int
fds
[
2
]
;
if
(
0
!
=
socketpair
(
AF_UNIX
SOCK_SEQPACKET
0
fds
)
)
{
SANDBOX_LOG_ERROR
(
"
SandboxReporter
:
socketpair
failed
:
%
s
"
strerror
(
errno
)
)
;
return
false
;
}
mClientFd
=
fds
[
0
]
;
mServerFd
=
fds
[
1
]
;
if
(
!
PlatformThread
:
:
Create
(
0
this
&
mThread
)
)
{
SANDBOX_LOG_ERROR
(
"
SandboxReporter
:
thread
creation
failed
:
%
s
"
strerror
(
errno
)
)
;
close
(
mClientFd
)
;
close
(
mServerFd
)
;
mClientFd
=
mServerFd
=
-
1
;
return
false
;
}
return
true
;
}
SandboxReporter
:
:
~
SandboxReporter
(
)
{
if
(
mServerFd
<
0
)
{
return
;
}
shutdown
(
mServerFd
SHUT_RD
)
;
PlatformThread
:
:
Join
(
mThread
)
;
close
(
mServerFd
)
;
close
(
mClientFd
)
;
}
SandboxReporter
*
SandboxReporter
:
:
Singleton
(
)
{
static
StaticMutex
sMutex
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
sSingleton
=
=
nullptr
)
{
sSingleton
=
new
SandboxReporter
(
)
;
if
(
!
sSingleton
-
>
Init
(
)
)
{
MOZ_CRASH
(
"
SandboxRepoter
:
:
Singleton
:
initialization
failed
"
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
SandboxReporter
:
:
Singleton
"
[
]
{
ClearOnShutdown
(
&
sSingleton
)
;
}
)
)
;
}
return
sSingleton
.
get
(
)
;
}
void
SandboxReporter
:
:
GetClientFileDescriptorMapping
(
int
*
aSrcFd
int
*
aDstFd
)
const
{
MOZ_ASSERT
(
mClientFd
>
=
0
)
;
*
aSrcFd
=
mClientFd
;
*
aDstFd
=
kSandboxReporterFileDesc
;
}
static
void
SubmitToTelemetry
(
const
SandboxReport
&
aReport
)
{
nsAutoCString
key
;
switch
(
aReport
.
mProcType
)
{
case
SandboxReport
:
:
ProcType
:
:
CONTENT
:
key
.
AppendLiteral
(
"
content
"
)
;
break
;
case
SandboxReport
:
:
ProcType
:
:
MEDIA_PLUGIN
:
key
.
AppendLiteral
(
"
gmp
"
)
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
}
key
.
Append
(
'
:
'
)
;
switch
(
aReport
.
mSyscall
)
{
#
define
ARG_DECIMAL
(
name
idx
)
\
case
__NR_
#
#
name
:
\
key
.
AppendLiteral
(
#
name
"
:
"
)
;
\
key
.
AppendInt
(
aReport
.
mArgs
[
idx
]
)
;
\
break
#
define
ARG_HEX
(
name
idx
)
\
case
__NR_
#
#
name
:
\
key
.
AppendLiteral
(
#
name
"
:
0x
"
)
;
\
key
.
AppendInt
(
aReport
.
mArgs
[
idx
]
16
)
;
\
break
#
define
ARG_CLOCKID
(
name
idx
)
\
case
__NR_
#
#
name
:
\
key
.
AppendLiteral
(
#
name
"
:
"
)
;
\
if
(
static_cast
<
clockid_t
>
(
aReport
.
mArgs
[
idx
]
)
<
0
)
{
\
key
.
AppendLiteral
(
"
dynamic
"
)
;
\
}
else
{
\
key
.
AppendInt
(
aReport
.
mArgs
[
idx
]
)
;
\
}
\
break
ARG_HEX
(
clone
0
)
;
ARG_DECIMAL
(
prctl
0
)
;
ARG_DECIMAL
(
madvise
2
)
;
ARG_CLOCKID
(
clock_gettime
0
)
;
#
ifdef
__NR_socketcall
ARG_DECIMAL
(
socketcall
0
)
;
#
endif
#
ifdef
__NR_ipc
ARG_DECIMAL
(
ipc
0
)
;
#
endif
#
undef
ARG_DECIMAL
#
undef
ARG_HEX
#
undef
ARG_CLOCKID
default
:
key
.
Append
(
SANDBOX_ARCH_NAME
"
/
"
)
;
key
.
AppendInt
(
aReport
.
mSyscall
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SANDBOX_REJECTED_SYSCALLS
key
)
;
}
void
SandboxReporter
:
:
AddOne
(
const
SandboxReport
&
aReport
)
{
SubmitToTelemetry
(
aReport
)
;
MutexAutoLock
lock
(
mMutex
)
;
mBuffer
[
mCount
%
kSandboxReporterBufferSize
]
=
aReport
;
+
+
mCount
;
}
void
SandboxReporter
:
:
ThreadMain
(
void
)
{
for
(
;
;
)
{
SandboxReport
rep
;
struct
iovec
iov
;
struct
msghdr
msg
;
iov
.
iov_base
=
&
rep
;
iov
.
iov_len
=
sizeof
(
rep
)
;
PodZero
(
&
msg
)
;
msg
.
msg_iov
=
&
iov
;
msg
.
msg_iovlen
=
1
;
const
auto
recvd
=
recvmsg
(
mServerFd
&
msg
0
)
;
if
(
recvd
<
0
)
{
if
(
errno
=
=
EINTR
)
{
continue
;
}
SANDBOX_LOG_ERROR
(
"
SandboxReporter
:
recvmsg
:
%
s
"
strerror
(
errno
)
)
;
}
if
(
recvd
<
=
0
)
{
break
;
}
if
(
static_cast
<
size_t
>
(
recvd
)
<
sizeof
(
rep
)
)
{
SANDBOX_LOG_ERROR
(
"
SandboxReporter
:
packet
too
short
(
%
d
<
%
d
)
"
recvd
sizeof
(
rep
)
)
;
continue
;
}
if
(
msg
.
msg_flags
&
MSG_TRUNC
)
{
SANDBOX_LOG_ERROR
(
"
SandboxReporter
:
packet
too
long
"
)
;
continue
;
}
AddOne
(
rep
)
;
}
}
SandboxReporter
:
:
Snapshot
SandboxReporter
:
:
GetSnapshot
(
)
{
Snapshot
snapshot
;
MutexAutoLock
lock
(
mMutex
)
;
const
uint64_t
bufSize
=
static_cast
<
uint64_t
>
(
kSandboxReporterBufferSize
)
;
const
uint64_t
start
=
std
:
:
max
(
mCount
bufSize
)
-
bufSize
;
snapshot
.
mOffset
=
start
;
snapshot
.
mReports
.
Clear
(
)
;
snapshot
.
mReports
.
SetCapacity
(
mCount
-
start
)
;
for
(
size_t
i
=
start
;
i
<
mCount
;
+
+
i
)
{
const
SandboxReport
*
rep
=
&
mBuffer
[
i
%
kSandboxReporterBufferSize
]
;
MOZ_ASSERT
(
rep
-
>
IsValid
(
)
)
;
snapshot
.
mReports
.
AppendElement
(
*
rep
)
;
}
return
Move
(
snapshot
)
;
}
}
