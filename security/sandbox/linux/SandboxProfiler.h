#
ifndef
SANDBOX_PROFILER_H
#
define
SANDBOX_PROFILER_H
#
include
<
thread
>
#
include
<
utility
>
#
include
<
linux
/
limits
.
h
>
#
include
<
semaphore
.
h
>
#
include
"
base
/
trace_event
/
common
/
trace_event_common
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ProfilerNativeStack
.
h
"
#
include
"
MicroGeckoProfiler
.
h
"
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
"
mozilla
/
ProfilerState
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MPSCQueue
.
h
"
#
if
defined
(
HAVE_REPORT_UPROFILER_PARENT
)
&
&
\
defined
(
HAVE_REPORT_UPROFILER_CHILD
)
#
error
Cannot
include
SandboxProfilerChild
.
h
AND
SandboxProfilerParent
.
h
#
endif
namespace
mozilla
{
#
if
defined
(
DEBUG
)
extern
thread_local
Atomic
<
bool
>
sInSignalContext
;
class
MOZ_STACK_CLASS
AutoForbidSignalContext
{
public
:
AutoForbidSignalContext
(
)
;
~
AutoForbidSignalContext
(
)
;
}
;
#
endif
enum
class
SandboxProfilerPayloadType
:
uint8_t
{
Init
Request
Log
}
;
using
SandboxProfilerPayload
=
struct
{
NativeStack
mStack
;
uint64_t
mId
;
const
char
*
mOp
;
int
mFlags
;
char
mPath
[
PATH_MAX
]
;
char
mPath2
[
PATH_MAX
]
;
pid_t
mPid
;
SandboxProfilerPayloadType
mType
;
}
;
using
SandboxProfilerQueue
=
MPSCQueue
<
SandboxProfilerPayload
>
;
extern
struct
UprofilerFuncPtrs
uprofiler
;
extern
bool
uprofiler_initted
;
class
SandboxProfiler
final
{
public
:
SandboxProfiler
(
)
;
~
SandboxProfiler
(
)
;
static
bool
Active
(
)
{
if
(
!
uprofiler_initted
)
{
return
false
;
}
if
(
!
uprofiler
.
is_active
|
|
uprofiler
.
is_active
=
=
is_active_noop
)
{
return
false
;
}
if
(
!
uprofiler
.
feature_active
|
|
uprofiler
.
feature_active
=
=
feature_active_noop
)
{
return
false
;
}
return
uprofiler
.
is_active
(
)
&
&
uprofiler
.
feature_active
(
ProfilerFeature
:
:
Sandbox
)
;
}
static
void
Shutdown
(
)
;
static
inline
bool
Init
(
)
;
static
void
Create
(
)
;
static
void
inline
ReportAudit
(
const
char
*
aKind
const
char
*
aOp
int
aFlags
uint64_t
aId
int
aPerms
const
char
*
aPath
pid_t
aPid
)
;
static
void
ReportRequest
(
const
void
*
top
uint64_t
aId
const
char
*
aOp
int
aFlags
const
char
*
aPath
const
char
*
aPath2
pid_t
aPid
)
;
static
void
ReportInit
(
const
void
*
top
)
;
static
void
ReportLog
(
const
char
*
buf
)
;
private
:
std
:
:
thread
mThreadLogs
;
std
:
:
thread
mThreadSyscalls
;
template
<
typename
N
typename
T
typename
V
size_t
len
>
static
constexpr
void
Report
(
const
char
*
aKind
std
:
:
array
<
N
len
>
aArgNames
std
:
:
array
<
T
len
>
aArgTypes
std
:
:
array
<
V
len
>
aArgValues
void
*
aStack
)
{
if
(
!
Active
(
)
)
{
return
;
}
if
(
!
uprofiler_initted
)
{
fprintf
(
stderr
"
[
%
d
]
no
uprofiler
skip
\
n
"
getpid
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
sInSignalContext
"
SandboxProfiler
:
:
Report
called
in
SIGSYS
handler
"
)
;
if
(
aStack
)
{
uprofiler
.
simple_event_marker_with_stack
(
aKind
'
S
'
'
I
'
aArgNames
.
size
(
)
aArgNames
.
data
(
)
aArgTypes
.
data
(
)
aArgValues
.
data
(
)
aStack
)
;
}
else
{
uprofiler
.
simple_event_marker
(
aKind
'
S
'
'
I
'
aArgNames
.
size
(
)
aArgNames
.
data
(
)
aArgTypes
.
data
(
)
aArgValues
.
data
(
)
)
;
}
}
static
bool
ActiveWithQueue
(
SandboxProfilerQueue
*
aQueue
)
;
static
void
Signal
(
sem_t
*
aSem
)
;
static
int
Wait
(
sem_t
*
aSem
)
;
void
ThreadMain
(
const
char
*
aThreadName
SandboxProfilerQueue
*
aQueue
sem_t
*
aRequest
)
;
void
ReportInitImpl
(
SandboxProfilerPayload
&
payload
ProfileChunkedBuffer
&
buffer
)
;
void
ReportLogImpl
(
SandboxProfilerPayload
&
payload
)
;
void
ReportRequestImpl
(
SandboxProfilerPayload
&
payload
ProfileChunkedBuffer
&
buffer
)
;
}
;
}
#
endif
