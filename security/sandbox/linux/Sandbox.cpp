#
include
"
Sandbox
.
h
"
#
include
"
LinuxSched
.
h
"
#
include
"
SandboxBrokerClient
.
h
"
#
include
"
SandboxChrootProto
.
h
"
#
include
"
SandboxFilter
.
h
"
#
include
"
SandboxInternal
.
h
"
#
include
"
SandboxLogging
.
h
"
#
ifdef
MOZ_GMP_SANDBOX
#
include
"
SandboxOpenedFiles
.
h
"
#
endif
#
include
"
SandboxReporterClient
.
h
"
#
include
<
dirent
.
h
>
#
ifdef
NIGHTLY_BUILD
#
include
"
dlfcn
.
h
"
#
endif
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
linux
/
futex
.
h
>
#
include
<
pthread
.
h
>
#
include
<
signal
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
prctl
.
h
>
#
include
<
sys
/
ptrace
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
unistd
.
h
>
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
SandboxInfo
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
prenv
.
h
"
#
include
"
base
/
posix
/
eintr_wrapper
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
codegen
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
dump_bpf
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy_compiler
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
seccomp_macros
.
h
"
#
include
"
sandbox
/
linux
/
seccomp
-
bpf
/
trap
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_filter
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_seccomp
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
#
if
defined
(
ANDROID
)
#
include
"
sandbox
/
linux
/
system_headers
/
linux_ucontext
.
h
"
#
endif
#
ifdef
MOZ_ASAN
extern
"
C
"
{
namespace
__sanitizer
{
typedef
signed
long
sptr
;
}
typedef
struct
{
int
coverage_sandboxed
;
__sanitizer
:
:
sptr
coverage_fd
;
unsigned
int
coverage_max_block_size
;
}
__sanitizer_sandbox_arguments
;
MOZ_IMPORT_API
void
__sanitizer_sandbox_on_notify
(
__sanitizer_sandbox_arguments
*
args
)
;
}
#
endif
mozilla
:
:
Atomic
<
int
>
gSeccompTsyncBroadcastSignum
(
0
)
;
namespace
mozilla
{
static
bool
gSandboxCrashOnError
=
false
;
SandboxCrashFunc
gSandboxCrashFunc
;
static
SandboxReporterClient
*
gSandboxReporterClient
;
static
void
(
*
gChromiumSigSysHandler
)
(
int
siginfo_t
*
void
*
)
;
static
bool
ContextIsError
(
const
ucontext_t
*
aContext
int
aError
)
{
typedef
decltype
(
+
SECCOMP_RESULT
(
aContext
)
)
reg_t
;
#
ifdef
__mips__
return
SECCOMP_PARM4
(
aContext
)
!
=
0
&
&
SECCOMP_RESULT
(
aContext
)
=
=
static_cast
<
reg_t
>
(
aError
)
;
#
else
return
SECCOMP_RESULT
(
aContext
)
=
=
static_cast
<
reg_t
>
(
-
aError
)
;
#
endif
}
static
void
SigSysHandler
(
int
nr
siginfo_t
*
info
void
*
void_context
)
{
ucontext_t
*
ctx
=
static_cast
<
ucontext_t
*
>
(
void_context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ctx
)
;
if
(
!
ctx
)
{
return
;
}
ucontext_t
savedCtx
=
*
ctx
;
gChromiumSigSysHandler
(
nr
info
ctx
)
;
if
(
!
ContextIsError
(
ctx
ENOSYS
)
)
{
return
;
}
SandboxReport
report
=
gSandboxReporterClient
-
>
MakeReportAndSend
(
&
savedCtx
)
;
SANDBOX_LOG_ERROR
(
"
seccomp
sandbox
violation
:
pid
%
d
tid
%
d
syscall
%
d
"
"
args
%
d
%
d
%
d
%
d
%
d
%
d
.
%
s
"
report
.
mPid
report
.
mTid
report
.
mSyscall
report
.
mArgs
[
0
]
report
.
mArgs
[
1
]
report
.
mArgs
[
2
]
report
.
mArgs
[
3
]
report
.
mArgs
[
4
]
report
.
mArgs
[
5
]
gSandboxCrashOnError
?
"
Killing
process
.
"
:
"
"
)
;
if
(
gSandboxCrashOnError
)
{
info
-
>
si_addr
=
reinterpret_cast
<
void
*
>
(
report
.
mSyscall
)
;
gSandboxCrashFunc
(
nr
info
&
savedCtx
)
;
_exit
(
127
)
;
}
}
static
void
InstallSigSysHandler
(
void
)
{
struct
sigaction
act
;
Unused
<
<
sandbox
:
:
Trap
:
:
Registry
(
)
;
if
(
sigaction
(
SIGSYS
nullptr
&
act
)
!
=
0
)
{
MOZ_CRASH
(
"
Couldn
'
t
read
old
SIGSYS
disposition
"
)
;
}
if
(
(
act
.
sa_flags
&
SA_SIGINFO
)
!
=
SA_SIGINFO
)
{
MOZ_CRASH
(
"
SIGSYS
not
already
set
to
a
siginfo
handler
?
"
)
;
}
MOZ_RELEASE_ASSERT
(
act
.
sa_sigaction
)
;
gChromiumSigSysHandler
=
act
.
sa_sigaction
;
act
.
sa_sigaction
=
SigSysHandler
;
MOZ_ASSERT
(
act
.
sa_flags
&
SA_NODEFER
)
;
act
.
sa_flags
|
=
SA_NODEFER
;
if
(
sigaction
(
SIGSYS
&
act
nullptr
)
<
0
)
{
MOZ_CRASH
(
"
Couldn
'
t
change
SIGSYS
disposition
"
)
;
}
}
static
bool
MOZ_MUST_USE
InstallSyscallFilter
(
const
sock_fprog
*
aProg
bool
aUseTSync
)
{
if
(
prctl
(
PR_SET_NO_NEW_PRIVS
1
0
0
0
)
)
{
if
(
!
aUseTSync
&
&
errno
=
=
ETXTBSY
)
{
return
false
;
}
SANDBOX_LOG_ERROR
(
"
prctl
(
PR_SET_NO_NEW_PRIVS
)
failed
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
prctl
(
PR_SET_NO_NEW_PRIVS
)
"
)
;
}
if
(
aUseTSync
)
{
if
(
syscall
(
__NR_seccomp
SECCOMP_SET_MODE_FILTER
SECCOMP_FILTER_FLAG_TSYNC
aProg
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
thread
-
synchronized
seccomp
failed
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
)
"
)
;
}
}
else
{
if
(
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
(
unsigned
long
)
aProg
0
0
)
)
{
SANDBOX_LOG_ERROR
(
"
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
)
failed
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
seccomp
+
tsync
failed
but
kernel
supports
tsync
"
)
;
}
}
return
true
;
}
static
mozilla
:
:
Atomic
<
int
>
gSetSandboxDone
;
const
sock_fprog
*
gSetSandboxFilter
;
static
int
FindFreeSignalNumber
(
)
{
for
(
int
signum
=
SIGRTMAX
;
signum
>
=
SIGRTMIN
;
-
-
signum
)
{
struct
sigaction
sa
;
if
(
sigaction
(
signum
nullptr
&
sa
)
=
=
0
&
&
(
sa
.
sa_flags
&
SA_SIGINFO
)
=
=
0
&
&
sa
.
sa_handler
=
=
SIG_DFL
)
{
return
signum
;
}
}
return
0
;
}
static
bool
SetThreadSandbox
(
)
{
return
InstallSyscallFilter
(
gSetSandboxFilter
false
)
;
}
static
void
SetThreadSandboxHandler
(
int
signum
)
{
if
(
SetThreadSandbox
(
)
)
{
gSetSandboxDone
=
2
;
}
else
{
gSetSandboxDone
=
1
;
}
syscall
(
__NR_futex
reinterpret_cast
<
int
*
>
(
&
gSetSandboxDone
)
FUTEX_WAKE
1
)
;
}
static
void
EnterChroot
(
)
{
if
(
!
PR_GetEnv
(
kSandboxChrootEnvFlag
)
)
{
return
;
}
char
msg
=
kSandboxChrootRequest
;
ssize_t
msg_len
=
HANDLE_EINTR
(
write
(
kSandboxChrootClientFd
&
msg
1
)
)
;
MOZ_RELEASE_ASSERT
(
msg_len
=
=
1
)
;
msg_len
=
HANDLE_EINTR
(
read
(
kSandboxChrootClientFd
&
msg
1
)
)
;
MOZ_RELEASE_ASSERT
(
msg_len
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
msg
=
=
kSandboxChrootResponse
)
;
close
(
kSandboxChrootClientFd
)
;
}
static
void
BroadcastSetThreadSandbox
(
const
sock_fprog
*
aFilter
)
{
pid_t
pid
tid
myTid
;
DIR
*
taskdp
;
struct
dirent
*
de
;
gSetSandboxFilter
=
aFilter
;
static_assert
(
sizeof
(
mozilla
:
:
Atomic
<
int
>
)
=
=
sizeof
(
int
)
"
mozilla
:
:
Atomic
<
int
>
isn
'
t
represented
by
an
int
"
)
;
pid
=
getpid
(
)
;
myTid
=
syscall
(
__NR_gettid
)
;
taskdp
=
opendir
(
"
/
proc
/
self
/
task
"
)
;
if
(
taskdp
=
=
nullptr
)
{
SANDBOX_LOG_ERROR
(
"
opendir
/
proc
/
self
/
task
:
%
s
\
n
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
bool
sandboxProgress
;
const
int
tsyncSignum
=
gSeccompTsyncBroadcastSignum
;
do
{
sandboxProgress
=
false
;
while
(
(
de
=
readdir
(
taskdp
)
)
)
{
char
*
endptr
;
tid
=
strtol
(
de
-
>
d_name
&
endptr
10
)
;
if
(
*
endptr
!
=
'
\
0
'
|
|
tid
<
=
0
)
{
continue
;
}
if
(
tid
=
=
myTid
)
{
continue
;
}
MOZ_RELEASE_ASSERT
(
tsyncSignum
!
=
0
)
;
gSetSandboxDone
=
0
;
if
(
syscall
(
__NR_tgkill
pid
tid
tsyncSignum
)
!
=
0
)
{
if
(
errno
=
=
ESRCH
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unexpectedly
exited
.
"
tid
)
;
sandboxProgress
=
true
;
continue
;
}
SANDBOX_LOG_ERROR
(
"
tgkill
(
%
d
%
d
)
:
%
s
\
n
"
pid
tid
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
static
const
int
crashDelay
=
10
;
struct
timespec
timeLimit
;
clock_gettime
(
CLOCK_MONOTONIC
&
timeLimit
)
;
timeLimit
.
tv_sec
+
=
crashDelay
;
while
(
true
)
{
static
const
struct
timespec
futexTimeout
=
{
0
10
*
1000
*
1000
}
;
if
(
syscall
(
__NR_futex
reinterpret_cast
<
int
*
>
(
&
gSetSandboxDone
)
FUTEX_WAIT
0
&
futexTimeout
)
!
=
0
)
{
if
(
errno
!
=
EWOULDBLOCK
&
&
errno
!
=
ETIMEDOUT
&
&
errno
!
=
EINTR
)
{
SANDBOX_LOG_ERROR
(
"
FUTEX_WAIT
:
%
s
\
n
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
}
if
(
gSetSandboxDone
>
0
)
{
if
(
gSetSandboxDone
=
=
2
)
{
sandboxProgress
=
true
;
}
break
;
}
if
(
syscall
(
__NR_tgkill
pid
tid
0
)
!
=
0
)
{
if
(
errno
=
=
ESRCH
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unexpectedly
exited
.
"
tid
)
;
}
sandboxProgress
=
true
;
break
;
}
struct
timespec
now
;
clock_gettime
(
CLOCK_MONOTONIC
&
now
)
;
if
(
now
.
tv_sec
>
timeLimit
.
tv_sec
|
|
(
now
.
tv_sec
=
=
timeLimit
.
tv_sec
&
&
now
.
tv_nsec
>
timeLimit
.
tv_nsec
)
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unresponsive
for
%
d
seconds
.
"
"
Killing
process
.
"
tid
crashDelay
)
;
MOZ_CRASH
(
)
;
}
}
}
rewinddir
(
taskdp
)
;
}
while
(
sandboxProgress
)
;
void
(
*
oldHandler
)
(
int
)
;
oldHandler
=
signal
(
tsyncSignum
SIG_DFL
)
;
if
(
oldHandler
!
=
SetThreadSandboxHandler
)
{
SANDBOX_LOG_ERROR
(
"
handler
for
signal
%
d
was
changed
to
%
p
!
"
tsyncSignum
oldHandler
)
;
MOZ_CRASH
(
)
;
}
gSeccompTsyncBroadcastSignum
=
0
;
Unused
<
<
closedir
(
taskdp
)
;
SetThreadSandbox
(
)
;
gSetSandboxFilter
=
nullptr
;
}
static
void
ApplySandboxWithTSync
(
sock_fprog
*
aFilter
)
{
if
(
!
InstallSyscallFilter
(
aFilter
true
)
)
{
MOZ_CRASH
(
)
;
}
}
#
ifdef
NIGHTLY_BUILD
static
bool
IsLibPresent
(
const
char
*
aName
)
{
if
(
const
auto
handle
=
dlopen
(
aName
RTLD_LAZY
|
RTLD_NOLOAD
)
)
{
dlclose
(
handle
)
;
return
true
;
}
return
false
;
}
static
const
Array
<
const
char
*
1
>
kLibsThatWillCrash
{
"
libesets_pac
.
so
"
}
;
#
endif
void
SandboxEarlyInit
(
)
{
if
(
PR_GetEnv
(
"
MOZ_SANDBOXED
"
)
=
=
nullptr
)
{
return
;
}
const
char
*
oldPreload
=
PR_GetEnv
(
"
MOZ_ORIG_LD_PRELOAD
"
)
;
char
*
preloadEntry
;
if
(
asprintf
(
&
preloadEntry
"
LD_PRELOAD
=
%
s
"
oldPreload
?
oldPreload
:
"
"
)
!
=
-
1
)
{
PR_SetEnv
(
preloadEntry
)
;
}
if
(
!
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kHasSeccompTSync
)
)
{
const
int
tsyncSignum
=
FindFreeSignalNumber
(
)
;
if
(
tsyncSignum
=
=
0
)
{
SANDBOX_LOG_ERROR
(
"
No
available
signal
numbers
!
"
)
;
MOZ_CRASH
(
)
;
}
gSeccompTsyncBroadcastSignum
=
tsyncSignum
;
void
(
*
oldHandler
)
(
int
)
;
oldHandler
=
signal
(
tsyncSignum
SetThreadSandboxHandler
)
;
if
(
oldHandler
!
=
SIG_DFL
)
{
SANDBOX_LOG_ERROR
(
"
signal
%
d
in
use
by
handler
%
p
!
\
n
"
tsyncSignum
oldHandler
)
;
MOZ_CRASH
(
)
;
}
}
}
static
void
SandboxLateInit
(
)
{
#
ifdef
NIGHTLY_BUILD
gSandboxCrashOnError
=
true
;
for
(
const
char
*
name
:
kLibsThatWillCrash
)
{
if
(
IsLibPresent
(
name
)
)
{
gSandboxCrashOnError
=
false
;
break
;
}
}
#
endif
if
(
const
char
*
envVar
=
PR_GetEnv
(
"
MOZ_SANDBOX_CRASH_ON_ERROR
"
)
)
{
if
(
envVar
[
0
]
)
{
gSandboxCrashOnError
=
envVar
[
0
]
!
=
'
0
'
;
}
}
}
static
void
SetCurrentProcessSandbox
(
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
aPolicy
)
{
MOZ_ASSERT
(
gSandboxCrashFunc
)
;
MOZ_RELEASE_ASSERT
(
gSandboxReporterClient
!
=
nullptr
)
;
SandboxLateInit
(
)
;
signal
(
SIGCHLD
SIG_IGN
)
;
sandbox
:
:
bpf_dsl
:
:
PolicyCompiler
compiler
(
aPolicy
.
get
(
)
sandbox
:
:
Trap
:
:
Registry
(
)
)
;
sandbox
:
:
CodeGen
:
:
Program
program
=
compiler
.
Compile
(
)
;
if
(
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
sandbox
:
:
bpf_dsl
:
:
DumpBPF
:
:
PrintProgram
(
program
)
;
}
InstallSigSysHandler
(
)
;
#
ifdef
MOZ_ASAN
__sanitizer_sandbox_arguments
asanArgs
;
asanArgs
.
coverage_sandboxed
=
1
;
asanArgs
.
coverage_fd
=
-
1
;
asanArgs
.
coverage_max_block_size
=
0
;
__sanitizer_sandbox_on_notify
(
&
asanArgs
)
;
#
endif
size_t
programLen
=
program
.
size
(
)
;
UniquePtr
<
sock_filter
[
]
>
flatProgram
(
new
sock_filter
[
programLen
]
)
;
for
(
auto
i
=
program
.
begin
(
)
;
i
!
=
program
.
end
(
)
;
+
+
i
)
{
flatProgram
[
i
-
program
.
begin
(
)
]
=
*
i
;
}
sock_fprog
fprog
;
fprog
.
filter
=
flatProgram
.
get
(
)
;
fprog
.
len
=
static_cast
<
unsigned
short
>
(
programLen
)
;
MOZ_RELEASE_ASSERT
(
static_cast
<
size_t
>
(
fprog
.
len
)
=
=
programLen
)
;
const
SandboxInfo
info
=
SandboxInfo
:
:
Get
(
)
;
if
(
info
.
Test
(
SandboxInfo
:
:
kHasSeccompTSync
)
)
{
if
(
info
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG_ERROR
(
"
using
seccomp
tsync
"
)
;
}
ApplySandboxWithTSync
(
&
fprog
)
;
}
else
{
if
(
info
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG_ERROR
(
"
no
tsync
support
;
using
signal
broadcast
"
)
;
}
BroadcastSetThreadSandbox
(
&
fprog
)
;
}
EnterChroot
(
)
;
}
#
ifdef
MOZ_CONTENT_SANDBOX
bool
SetContentProcessSandbox
(
ContentProcessSandboxParams
&
&
aParams
)
{
int
brokerFd
=
aParams
.
mBrokerFd
;
aParams
.
mBrokerFd
=
-
1
;
if
(
!
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kEnabledForContent
)
)
{
if
(
brokerFd
>
=
0
)
{
close
(
brokerFd
)
;
}
return
false
;
}
auto
procType
=
aParams
.
mFileProcess
?
SandboxReport
:
:
ProcType
:
:
FILE
:
SandboxReport
:
:
ProcType
:
:
CONTENT
;
gSandboxReporterClient
=
new
SandboxReporterClient
(
procType
)
;
static
SandboxBrokerClient
*
sBroker
;
if
(
brokerFd
>
=
0
)
{
sBroker
=
new
SandboxBrokerClient
(
brokerFd
)
;
}
SetCurrentProcessSandbox
(
GetContentSandboxPolicy
(
sBroker
std
:
:
move
(
aParams
)
)
)
;
return
true
;
}
#
endif
#
ifdef
MOZ_GMP_SANDBOX
void
SetMediaPluginSandbox
(
const
char
*
aFilePath
)
{
MOZ_RELEASE_ASSERT
(
aFilePath
!
=
nullptr
)
;
if
(
!
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kEnabledForMedia
)
)
{
return
;
}
gSandboxReporterClient
=
new
SandboxReporterClient
(
SandboxReport
:
:
ProcType
:
:
MEDIA_PLUGIN
)
;
SandboxOpenedFile
plugin
(
aFilePath
)
;
if
(
!
plugin
.
IsOpen
(
)
)
{
SANDBOX_LOG_ERROR
(
"
failed
to
open
plugin
file
%
s
:
%
s
"
aFilePath
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
auto
files
=
new
SandboxOpenedFiles
(
)
;
files
-
>
Add
(
std
:
:
move
(
plugin
)
)
;
files
-
>
Add
(
"
/
dev
/
urandom
"
true
)
;
files
-
>
Add
(
"
/
sys
/
devices
/
system
/
cpu
/
cpu0
/
tsc_freq_khz
"
)
;
files
-
>
Add
(
"
/
sys
/
devices
/
system
/
cpu
/
cpu0
/
cpufreq
/
cpuinfo_max_freq
"
)
;
files
-
>
Add
(
"
/
proc
/
cpuinfo
"
)
;
#
ifdef
__i386__
files
-
>
Add
(
"
/
proc
/
self
/
auxv
"
)
;
#
endif
SetCurrentProcessSandbox
(
GetMediaSandboxPolicy
(
files
)
)
;
}
#
endif
}
