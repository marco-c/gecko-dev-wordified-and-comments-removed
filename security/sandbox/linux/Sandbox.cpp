#
include
"
Sandbox
.
h
"
#
include
"
LinuxCapabilities
.
h
"
#
include
"
LinuxSched
.
h
"
#
include
"
SandboxBrokerClient
.
h
"
#
include
"
SandboxChroot
.
h
"
#
include
"
SandboxFilter
.
h
"
#
include
"
SandboxInternal
.
h
"
#
include
"
SandboxLogging
.
h
"
#
ifdef
MOZ_GMP_SANDBOX
#
include
"
SandboxOpenedFiles
.
h
"
#
endif
#
include
"
SandboxReporterClient
.
h
"
#
include
"
SandboxUtil
.
h
"
#
include
<
dirent
.
h
>
#
ifdef
NIGHTLY_BUILD
#
include
"
dlfcn
.
h
"
#
endif
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
linux
/
futex
.
h
>
#
include
<
pthread
.
h
>
#
include
<
signal
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
prctl
.
h
>
#
include
<
sys
/
ptrace
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
unistd
.
h
>
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
SandboxInfo
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
codegen
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
dump_bpf
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy_compiler
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
seccomp_macros
.
h
"
#
include
"
sandbox
/
linux
/
seccomp
-
bpf
/
trap
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_filter
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_seccomp
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
#
if
defined
(
ANDROID
)
#
include
"
sandbox
/
linux
/
system_headers
/
linux_ucontext
.
h
"
#
endif
#
ifdef
MOZ_ASAN
extern
"
C
"
{
namespace
__sanitizer
{
typedef
signed
long
sptr
;
}
typedef
struct
{
int
coverage_sandboxed
;
__sanitizer
:
:
sptr
coverage_fd
;
unsigned
int
coverage_max_block_size
;
}
__sanitizer_sandbox_arguments
;
MOZ_IMPORT_API
void
__sanitizer_sandbox_on_notify
(
__sanitizer_sandbox_arguments
*
args
)
;
}
#
endif
int
gSeccompTsyncBroadcastSignum
=
0
;
namespace
mozilla
{
static
bool
gSandboxCrashOnError
=
false
;
SandboxCrashFunc
gSandboxCrashFunc
;
static
Maybe
<
SandboxReporterClient
>
gSandboxReporterClient
;
static
UniquePtr
<
SandboxChroot
>
gChrootHelper
;
static
void
(
*
gChromiumSigSysHandler
)
(
int
siginfo_t
*
void
*
)
;
static
bool
ContextIsError
(
const
ucontext_t
*
aContext
int
aError
)
{
typedef
decltype
(
+
SECCOMP_RESULT
(
aContext
)
)
reg_t
;
#
ifdef
__mips__
return
SECCOMP_PARM4
(
aContext
)
!
=
0
&
&
SECCOMP_RESULT
(
aContext
)
=
=
static_cast
<
reg_t
>
(
aError
)
;
#
else
return
SECCOMP_RESULT
(
aContext
)
=
=
static_cast
<
reg_t
>
(
-
aError
)
;
#
endif
}
static
void
SigSysHandler
(
int
nr
siginfo_t
*
info
void
*
void_context
)
{
ucontext_t
*
ctx
=
static_cast
<
ucontext_t
*
>
(
void_context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ctx
)
;
if
(
!
ctx
)
{
return
;
}
ucontext_t
savedCtx
=
*
ctx
;
gChromiumSigSysHandler
(
nr
info
ctx
)
;
if
(
!
ContextIsError
(
ctx
ENOSYS
)
)
{
return
;
}
SandboxReport
report
=
gSandboxReporterClient
-
>
MakeReportAndSend
(
&
savedCtx
)
;
SANDBOX_LOG_ERROR
(
"
seccomp
sandbox
violation
:
pid
%
d
tid
%
d
syscall
%
d
"
"
args
%
d
%
d
%
d
%
d
%
d
%
d
.
%
s
"
report
.
mPid
report
.
mTid
report
.
mSyscall
report
.
mArgs
[
0
]
report
.
mArgs
[
1
]
report
.
mArgs
[
2
]
report
.
mArgs
[
3
]
report
.
mArgs
[
4
]
report
.
mArgs
[
5
]
gSandboxCrashOnError
?
"
Killing
process
.
"
:
"
"
)
;
if
(
gSandboxCrashOnError
)
{
info
-
>
si_addr
=
reinterpret_cast
<
void
*
>
(
report
.
mSyscall
)
;
gSandboxCrashFunc
(
nr
info
&
savedCtx
)
;
_exit
(
127
)
;
}
}
static
void
InstallSigSysHandler
(
void
)
{
struct
sigaction
act
;
Unused
<
<
sandbox
:
:
Trap
:
:
Registry
(
)
;
if
(
sigaction
(
SIGSYS
nullptr
&
act
)
!
=
0
)
{
MOZ_CRASH
(
"
Couldn
'
t
read
old
SIGSYS
disposition
"
)
;
}
if
(
(
act
.
sa_flags
&
SA_SIGINFO
)
!
=
SA_SIGINFO
)
{
MOZ_CRASH
(
"
SIGSYS
not
already
set
to
a
siginfo
handler
?
"
)
;
}
MOZ_RELEASE_ASSERT
(
act
.
sa_sigaction
)
;
gChromiumSigSysHandler
=
act
.
sa_sigaction
;
act
.
sa_sigaction
=
SigSysHandler
;
MOZ_ASSERT
(
act
.
sa_flags
&
SA_NODEFER
)
;
act
.
sa_flags
|
=
SA_NODEFER
;
if
(
sigaction
(
SIGSYS
&
act
nullptr
)
<
0
)
{
MOZ_CRASH
(
"
Couldn
'
t
change
SIGSYS
disposition
"
)
;
}
}
static
bool
MOZ_MUST_USE
InstallSyscallFilter
(
const
sock_fprog
*
aProg
bool
aUseTSync
)
{
if
(
prctl
(
PR_SET_NO_NEW_PRIVS
1
0
0
0
)
)
{
if
(
!
aUseTSync
&
&
errno
=
=
ETXTBSY
)
{
return
false
;
}
SANDBOX_LOG_ERROR
(
"
prctl
(
PR_SET_NO_NEW_PRIVS
)
failed
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
prctl
(
PR_SET_NO_NEW_PRIVS
)
"
)
;
}
if
(
aUseTSync
)
{
if
(
syscall
(
__NR_seccomp
SECCOMP_SET_MODE_FILTER
SECCOMP_FILTER_FLAG_TSYNC
aProg
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
thread
-
synchronized
seccomp
failed
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
)
"
)
;
}
}
else
{
if
(
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
(
unsigned
long
)
aProg
0
0
)
)
{
SANDBOX_LOG_ERROR
(
"
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
)
failed
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
seccomp
+
tsync
failed
but
kernel
supports
tsync
"
)
;
}
}
return
true
;
}
static
mozilla
:
:
Atomic
<
int
>
gSetSandboxDone
;
const
sock_fprog
*
gSetSandboxFilter
;
static
int
FindFreeSignalNumber
(
)
{
for
(
int
signum
=
SIGRTMAX
;
signum
>
=
SIGRTMIN
;
-
-
signum
)
{
struct
sigaction
sa
;
if
(
sigaction
(
signum
nullptr
&
sa
)
=
=
0
&
&
(
sa
.
sa_flags
&
SA_SIGINFO
)
=
=
0
&
&
sa
.
sa_handler
=
=
SIG_DFL
)
{
return
signum
;
}
}
return
0
;
}
static
bool
SetThreadSandbox
(
)
{
return
InstallSyscallFilter
(
gSetSandboxFilter
false
)
;
}
static
void
SetThreadSandboxHandler
(
int
signum
)
{
if
(
SetThreadSandbox
(
)
)
{
gSetSandboxDone
=
2
;
}
else
{
gSetSandboxDone
=
1
;
}
syscall
(
__NR_futex
reinterpret_cast
<
int
*
>
(
&
gSetSandboxDone
)
FUTEX_WAKE
1
)
;
}
static
void
EnterChroot
(
)
{
if
(
gChrootHelper
)
{
gChrootHelper
-
>
Invoke
(
)
;
gChrootHelper
=
nullptr
;
}
}
static
void
BroadcastSetThreadSandbox
(
const
sock_fprog
*
aFilter
)
{
pid_t
pid
tid
myTid
;
DIR
*
taskdp
;
struct
dirent
*
de
;
gSetSandboxFilter
=
aFilter
;
static_assert
(
sizeof
(
mozilla
:
:
Atomic
<
int
>
)
=
=
sizeof
(
int
)
"
mozilla
:
:
Atomic
<
int
>
isn
'
t
represented
by
an
int
"
)
;
pid
=
getpid
(
)
;
myTid
=
syscall
(
__NR_gettid
)
;
taskdp
=
opendir
(
"
/
proc
/
self
/
task
"
)
;
if
(
taskdp
=
=
nullptr
)
{
SANDBOX_LOG_ERROR
(
"
opendir
/
proc
/
self
/
task
:
%
s
\
n
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
EnterChroot
(
)
;
bool
sandboxProgress
;
do
{
sandboxProgress
=
false
;
while
(
(
de
=
readdir
(
taskdp
)
)
)
{
char
*
endptr
;
tid
=
strtol
(
de
-
>
d_name
&
endptr
10
)
;
if
(
*
endptr
!
=
'
\
0
'
|
|
tid
<
=
0
)
{
continue
;
}
if
(
tid
=
=
myTid
)
{
continue
;
}
MOZ_RELEASE_ASSERT
(
gSeccompTsyncBroadcastSignum
!
=
0
)
;
gSetSandboxDone
=
0
;
if
(
syscall
(
__NR_tgkill
pid
tid
gSeccompTsyncBroadcastSignum
)
!
=
0
)
{
if
(
errno
=
=
ESRCH
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unexpectedly
exited
.
"
tid
)
;
sandboxProgress
=
true
;
continue
;
}
SANDBOX_LOG_ERROR
(
"
tgkill
(
%
d
%
d
)
:
%
s
\
n
"
pid
tid
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
static
const
int
crashDelay
=
10
;
struct
timespec
timeLimit
;
clock_gettime
(
CLOCK_MONOTONIC
&
timeLimit
)
;
timeLimit
.
tv_sec
+
=
crashDelay
;
while
(
true
)
{
static
const
struct
timespec
futexTimeout
=
{
0
10
*
1000
*
1000
}
;
if
(
syscall
(
__NR_futex
reinterpret_cast
<
int
*
>
(
&
gSetSandboxDone
)
FUTEX_WAIT
0
&
futexTimeout
)
!
=
0
)
{
if
(
errno
!
=
EWOULDBLOCK
&
&
errno
!
=
ETIMEDOUT
&
&
errno
!
=
EINTR
)
{
SANDBOX_LOG_ERROR
(
"
FUTEX_WAIT
:
%
s
\
n
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
}
if
(
gSetSandboxDone
>
0
)
{
if
(
gSetSandboxDone
=
=
2
)
{
sandboxProgress
=
true
;
}
break
;
}
if
(
syscall
(
__NR_tgkill
pid
tid
0
)
!
=
0
)
{
if
(
errno
=
=
ESRCH
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unexpectedly
exited
.
"
tid
)
;
}
sandboxProgress
=
true
;
break
;
}
struct
timespec
now
;
clock_gettime
(
CLOCK_MONOTONIC
&
now
)
;
if
(
now
.
tv_sec
>
timeLimit
.
tv_sec
|
|
(
now
.
tv_sec
=
=
timeLimit
.
tv_sec
&
&
now
.
tv_nsec
>
timeLimit
.
tv_nsec
)
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unresponsive
for
%
d
seconds
.
"
"
Killing
process
.
"
tid
crashDelay
)
;
MOZ_CRASH
(
)
;
}
}
}
rewinddir
(
taskdp
)
;
}
while
(
sandboxProgress
)
;
void
(
*
oldHandler
)
(
int
)
;
oldHandler
=
signal
(
gSeccompTsyncBroadcastSignum
SIG_DFL
)
;
gSeccompTsyncBroadcastSignum
=
0
;
if
(
oldHandler
!
=
SetThreadSandboxHandler
)
{
SANDBOX_LOG_ERROR
(
"
handler
for
signal
%
d
was
changed
to
%
p
!
"
gSeccompTsyncBroadcastSignum
oldHandler
)
;
MOZ_CRASH
(
)
;
}
Unused
<
<
closedir
(
taskdp
)
;
SetThreadSandbox
(
)
;
gSetSandboxFilter
=
nullptr
;
}
static
void
ApplySandboxWithTSync
(
sock_fprog
*
aFilter
)
{
EnterChroot
(
)
;
if
(
!
InstallSyscallFilter
(
aFilter
true
)
)
{
MOZ_CRASH
(
)
;
}
}
static
void
SetCurrentProcessSandbox
(
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
aPolicy
)
{
MOZ_ASSERT
(
gSandboxCrashFunc
)
;
MOZ_RELEASE_ASSERT
(
gSandboxReporterClient
.
isSome
(
)
)
;
sandbox
:
:
bpf_dsl
:
:
PolicyCompiler
compiler
(
aPolicy
.
get
(
)
sandbox
:
:
Trap
:
:
Registry
(
)
)
;
sandbox
:
:
CodeGen
:
:
Program
program
=
compiler
.
Compile
(
)
;
if
(
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
sandbox
:
:
bpf_dsl
:
:
DumpBPF
:
:
PrintProgram
(
program
)
;
}
InstallSigSysHandler
(
)
;
#
ifdef
MOZ_ASAN
__sanitizer_sandbox_arguments
asanArgs
;
asanArgs
.
coverage_sandboxed
=
1
;
asanArgs
.
coverage_fd
=
-
1
;
asanArgs
.
coverage_max_block_size
=
0
;
__sanitizer_sandbox_on_notify
(
&
asanArgs
)
;
#
endif
size_t
programLen
=
program
.
size
(
)
;
UniquePtr
<
sock_filter
[
]
>
flatProgram
(
new
sock_filter
[
programLen
]
)
;
for
(
auto
i
=
program
.
begin
(
)
;
i
!
=
program
.
end
(
)
;
+
+
i
)
{
flatProgram
[
i
-
program
.
begin
(
)
]
=
*
i
;
}
sock_fprog
fprog
;
fprog
.
filter
=
flatProgram
.
get
(
)
;
fprog
.
len
=
static_cast
<
unsigned
short
>
(
programLen
)
;
MOZ_RELEASE_ASSERT
(
static_cast
<
size_t
>
(
fprog
.
len
)
=
=
programLen
)
;
const
SandboxInfo
info
=
SandboxInfo
:
:
Get
(
)
;
if
(
info
.
Test
(
SandboxInfo
:
:
kHasSeccompTSync
)
)
{
if
(
info
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG_ERROR
(
"
using
seccomp
tsync
"
)
;
}
ApplySandboxWithTSync
(
&
fprog
)
;
}
else
{
if
(
info
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG_ERROR
(
"
no
tsync
support
;
using
signal
broadcast
"
)
;
}
BroadcastSetThreadSandbox
(
&
fprog
)
;
}
MOZ_RELEASE_ASSERT
(
!
gChrootHelper
"
forgot
to
chroot
"
)
;
}
#
ifdef
NIGHTLY_BUILD
static
bool
IsLibPresent
(
const
char
*
aName
)
{
if
(
const
auto
handle
=
dlopen
(
aName
RTLD_LAZY
|
RTLD_NOLOAD
)
)
{
dlclose
(
handle
)
;
return
true
;
}
return
false
;
}
static
const
Array
<
const
char
*
1
>
kLibsThatWillCrash
{
"
libesets_pac
.
so
"
}
;
#
endif
void
SandboxEarlyInit
(
GeckoProcessType
aType
)
{
const
SandboxInfo
info
=
SandboxInfo
:
:
Get
(
)
;
if
(
info
.
Test
(
SandboxInfo
:
:
kUnexpectedThreads
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
IsSingleThreaded
(
)
)
;
#
ifdef
NIGHTLY_BUILD
gSandboxCrashOnError
=
true
;
for
(
const
char
*
name
:
kLibsThatWillCrash
)
{
if
(
IsLibPresent
(
name
)
)
{
gSandboxCrashOnError
=
false
;
break
;
}
}
#
endif
if
(
const
char
*
envVar
=
getenv
(
"
MOZ_SANDBOX_CRASH_ON_ERROR
"
)
)
{
if
(
envVar
[
0
]
)
{
gSandboxCrashOnError
=
envVar
[
0
]
!
=
'
0
'
;
}
}
bool
canChroot
=
false
;
bool
canUnshareNet
=
false
;
bool
canUnshareIPC
=
false
;
switch
(
aType
)
{
case
GeckoProcessType_Default
:
MOZ_ASSERT
(
false
"
SandboxEarlyInit
in
parent
process
"
)
;
return
;
#
ifdef
MOZ_GMP_SANDBOX
case
GeckoProcessType_GMPlugin
:
if
(
!
info
.
Test
(
SandboxInfo
:
:
kEnabledForMedia
)
)
{
break
;
}
canUnshareNet
=
true
;
canUnshareIPC
=
true
;
canChroot
=
info
.
Test
(
SandboxInfo
:
:
kHasSeccompBPF
)
;
break
;
#
endif
default
:
break
;
}
if
(
!
info
.
Test
(
SandboxInfo
:
:
kHasSeccompTSync
)
)
{
gSeccompTsyncBroadcastSignum
=
FindFreeSignalNumber
(
)
;
if
(
gSeccompTsyncBroadcastSignum
=
=
0
)
{
SANDBOX_LOG_ERROR
(
"
No
available
signal
numbers
!
"
)
;
MOZ_CRASH
(
)
;
}
void
(
*
oldHandler
)
(
int
)
;
oldHandler
=
signal
(
gSeccompTsyncBroadcastSignum
SetThreadSandboxHandler
)
;
if
(
oldHandler
!
=
SIG_DFL
)
{
SANDBOX_LOG_ERROR
(
"
signal
%
d
in
use
by
handler
%
p
!
\
n
"
gSeccompTsyncBroadcastSignum
oldHandler
)
;
MOZ_CRASH
(
)
;
}
}
if
(
!
canChroot
&
&
!
canUnshareNet
&
&
!
canUnshareIPC
)
{
return
;
}
{
LinuxCapabilities
existingCaps
;
if
(
existingCaps
.
GetCurrent
(
)
&
&
existingCaps
.
AnyEffective
(
)
)
{
SANDBOX_LOG_ERROR
(
"
PLEASE
DO
NOT
RUN
THIS
AS
ROOT
.
Strange
things
may
"
"
happen
when
capabilities
are
dropped
.
"
)
;
}
}
if
(
!
info
.
Test
(
SandboxInfo
:
:
kHasUserNamespaces
)
)
{
LinuxCapabilities
(
)
.
SetCurrent
(
)
;
return
;
}
if
(
!
UnshareUserNamespace
(
)
)
{
SANDBOX_LOG_ERROR
(
"
unshare
(
CLONE_NEWUSER
)
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
unshare
(
CLONE_NEWUSER
)
"
)
;
}
if
(
canUnshareIPC
&
&
syscall
(
__NR_unshare
CLONE_NEWIPC
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
unshare
(
CLONE_NEWIPC
)
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
unshare
(
CLONE_NEWIPC
)
"
)
;
}
if
(
canUnshareNet
&
&
syscall
(
__NR_unshare
CLONE_NEWNET
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
unshare
(
CLONE_NEWNET
)
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
unshare
(
CLONE_NEWNET
)
"
)
;
}
if
(
canChroot
)
{
gChrootHelper
=
MakeUnique
<
SandboxChroot
>
(
)
;
if
(
!
gChrootHelper
-
>
Prepare
(
)
)
{
SANDBOX_LOG_ERROR
(
"
failed
to
set
up
chroot
helper
"
)
;
MOZ_CRASH
(
"
SandboxChroot
:
:
Prepare
"
)
;
}
}
if
(
!
LinuxCapabilities
(
)
.
SetCurrent
(
)
)
{
SANDBOX_LOG_ERROR
(
"
dropping
capabilities
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
can
'
t
drop
capabilities
"
)
;
}
}
#
ifdef
MOZ_CONTENT_SANDBOX
bool
SetContentProcessSandbox
(
int
aBrokerFd
bool
aFileProcess
std
:
:
vector
<
int
>
&
aSyscallWhitelist
)
{
if
(
!
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kEnabledForContent
)
)
{
if
(
aBrokerFd
>
=
0
)
{
close
(
aBrokerFd
)
;
}
return
false
;
}
gSandboxReporterClient
.
emplace
(
aFileProcess
?
SandboxReport
:
:
ProcType
:
:
FILE
:
SandboxReport
:
:
ProcType
:
:
CONTENT
)
;
static
Maybe
<
SandboxBrokerClient
>
sBroker
;
if
(
aBrokerFd
>
=
0
)
{
sBroker
.
emplace
(
aBrokerFd
)
;
}
SetCurrentProcessSandbox
(
GetContentSandboxPolicy
(
sBroker
.
ptrOr
(
nullptr
)
aSyscallWhitelist
)
)
;
return
true
;
}
#
endif
#
ifdef
MOZ_GMP_SANDBOX
void
SetMediaPluginSandbox
(
const
char
*
aFilePath
)
{
MOZ_RELEASE_ASSERT
(
aFilePath
!
=
nullptr
)
;
if
(
!
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kEnabledForMedia
)
)
{
return
;
}
gSandboxReporterClient
.
emplace
(
SandboxReport
:
:
ProcType
:
:
MEDIA_PLUGIN
)
;
SandboxOpenedFile
plugin
(
aFilePath
)
;
if
(
!
plugin
.
IsOpen
(
)
)
{
SANDBOX_LOG_ERROR
(
"
failed
to
open
plugin
file
%
s
:
%
s
"
aFilePath
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
auto
files
=
new
SandboxOpenedFiles
(
)
;
files
-
>
Add
(
Move
(
plugin
)
)
;
files
-
>
Add
(
"
/
dev
/
urandom
"
true
)
;
files
-
>
Add
(
"
/
sys
/
devices
/
system
/
cpu
/
cpu0
/
tsc_freq_khz
"
)
;
files
-
>
Add
(
"
/
sys
/
devices
/
system
/
cpu
/
cpu0
/
cpufreq
/
cpuinfo_max_freq
"
)
;
files
-
>
Add
(
"
/
proc
/
cpuinfo
"
)
;
#
ifdef
__i386__
files
-
>
Add
(
"
/
proc
/
self
/
auxv
"
)
;
#
endif
SetCurrentProcessSandbox
(
GetMediaSandboxPolicy
(
files
)
)
;
}
#
endif
}
