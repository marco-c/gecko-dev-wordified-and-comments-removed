#
include
"
Sandbox
.
h
"
#
include
"
LinuxCapabilities
.
h
"
#
include
"
LinuxSched
.
h
"
#
include
"
SandboxBrokerClient
.
h
"
#
include
"
SandboxChroot
.
h
"
#
include
"
SandboxFilter
.
h
"
#
include
"
SandboxInternal
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
"
SandboxUtil
.
h
"
#
include
<
dirent
.
h
>
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
linux
/
futex
.
h
>
#
include
<
pthread
.
h
>
#
include
<
signal
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
prctl
.
h
>
#
include
<
sys
/
ptrace
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
unistd
.
h
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
SandboxInfo
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
codegen
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
dump_bpf
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy_compiler
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
seccomp_macros
.
h
"
#
include
"
sandbox
/
linux
/
seccomp
-
bpf
/
trap
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_filter
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_seccomp
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
#
if
defined
(
ANDROID
)
#
include
"
sandbox
/
linux
/
system_headers
/
linux_ucontext
.
h
"
#
endif
#
ifdef
MOZ_ASAN
extern
"
C
"
{
namespace
__sanitizer
{
typedef
signed
long
sptr
;
}
typedef
struct
{
int
coverage_sandboxed
;
__sanitizer
:
:
sptr
coverage_fd
;
unsigned
int
coverage_max_block_size
;
}
__sanitizer_sandbox_arguments
;
MOZ_IMPORT_API
void
__sanitizer_sandbox_on_notify
(
__sanitizer_sandbox_arguments
*
args
)
;
}
#
endif
MOZ_EXPORT
int
gSeccompTsyncBroadcastSignum
=
0
;
namespace
mozilla
{
#
ifdef
ANDROID
SandboxCrashFunc
gSandboxCrashFunc
;
#
endif
#
ifdef
MOZ_GMP_SANDBOX
static
SandboxOpenedFile
gMediaPluginFile
;
#
endif
static
UniquePtr
<
SandboxChroot
>
gChrootHelper
;
static
void
(
*
gChromiumSigSysHandler
)
(
int
siginfo_t
*
void
*
)
;
static
bool
ContextIsError
(
const
ucontext_t
*
aContext
int
aError
)
{
typedef
decltype
(
+
SECCOMP_RESULT
(
aContext
)
)
reg_t
;
#
ifdef
__mips__
return
SECCOMP_PARM4
(
aContext
)
!
=
0
&
&
SECCOMP_RESULT
(
aContext
)
=
=
static_cast
<
reg_t
>
(
aError
)
;
#
else
return
SECCOMP_RESULT
(
aContext
)
=
=
static_cast
<
reg_t
>
(
-
aError
)
;
#
endif
}
static
void
SigSysHandler
(
int
nr
siginfo_t
*
info
void
*
void_context
)
{
ucontext_t
*
ctx
=
static_cast
<
ucontext_t
*
>
(
void_context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ctx
)
;
if
(
!
ctx
)
{
return
;
}
ucontext_t
savedCtx
=
*
ctx
;
gChromiumSigSysHandler
(
nr
info
ctx
)
;
if
(
!
ContextIsError
(
ctx
ENOSYS
)
)
{
return
;
}
pid_t
pid
=
getpid
(
)
;
unsigned
long
syscall_nr
=
SECCOMP_SYSCALL
(
&
savedCtx
)
;
unsigned
long
args
[
6
]
;
args
[
0
]
=
SECCOMP_PARM1
(
&
savedCtx
)
;
args
[
1
]
=
SECCOMP_PARM2
(
&
savedCtx
)
;
args
[
2
]
=
SECCOMP_PARM3
(
&
savedCtx
)
;
args
[
3
]
=
SECCOMP_PARM4
(
&
savedCtx
)
;
args
[
4
]
=
SECCOMP_PARM5
(
&
savedCtx
)
;
args
[
5
]
=
SECCOMP_PARM6
(
&
savedCtx
)
;
SANDBOX_LOG_ERROR
(
"
seccomp
sandbox
violation
:
pid
%
d
syscall
%
d
"
"
args
%
d
%
d
%
d
%
d
%
d
%
d
.
Killing
process
.
"
pid
syscall_nr
args
[
0
]
args
[
1
]
args
[
2
]
args
[
3
]
args
[
4
]
args
[
5
]
)
;
info
-
>
si_addr
=
reinterpret_cast
<
void
*
>
(
syscall_nr
)
;
gSandboxCrashFunc
(
nr
info
&
savedCtx
)
;
_exit
(
127
)
;
}
static
void
InstallSigSysHandler
(
void
)
{
struct
sigaction
act
;
Unused
<
<
sandbox
:
:
Trap
:
:
Registry
(
)
;
if
(
sigaction
(
SIGSYS
nullptr
&
act
)
!
=
0
)
{
MOZ_CRASH
(
"
Couldn
'
t
read
old
SIGSYS
disposition
"
)
;
}
if
(
(
act
.
sa_flags
&
SA_SIGINFO
)
!
=
SA_SIGINFO
)
{
MOZ_CRASH
(
"
SIGSYS
not
already
set
to
a
siginfo
handler
?
"
)
;
}
MOZ_RELEASE_ASSERT
(
act
.
sa_sigaction
)
;
gChromiumSigSysHandler
=
act
.
sa_sigaction
;
act
.
sa_sigaction
=
SigSysHandler
;
MOZ_ASSERT
(
act
.
sa_flags
&
SA_NODEFER
)
;
act
.
sa_flags
|
=
SA_NODEFER
;
if
(
sigaction
(
SIGSYS
&
act
nullptr
)
<
0
)
{
MOZ_CRASH
(
"
Couldn
'
t
change
SIGSYS
disposition
"
)
;
}
}
static
bool
MOZ_MUST_USE
InstallSyscallFilter
(
const
sock_fprog
*
aProg
bool
aUseTSync
)
{
if
(
prctl
(
PR_SET_NO_NEW_PRIVS
1
0
0
0
)
)
{
SANDBOX_LOG_ERROR
(
"
prctl
(
PR_SET_NO_NEW_PRIVS
)
failed
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
prctl
(
PR_SET_NO_NEW_PRIVS
)
"
)
;
}
if
(
aUseTSync
)
{
if
(
syscall
(
__NR_seccomp
SECCOMP_SET_MODE_FILTER
SECCOMP_FILTER_FLAG_TSYNC
aProg
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
thread
-
synchronized
seccomp
failed
:
%
s
"
strerror
(
errno
)
)
;
return
false
;
}
}
else
{
if
(
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
(
unsigned
long
)
aProg
0
0
)
)
{
SANDBOX_LOG_ERROR
(
"
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
)
failed
:
%
s
"
strerror
(
errno
)
)
;
return
false
;
}
}
return
true
;
}
static
mozilla
:
:
Atomic
<
int
>
gSetSandboxDone
;
static
const
sock_fprog
*
gSetSandboxFilter
;
static
int
FindFreeSignalNumber
(
)
{
for
(
int
signum
=
SIGRTMAX
;
signum
>
=
SIGRTMIN
;
-
-
signum
)
{
struct
sigaction
sa
;
if
(
sigaction
(
signum
nullptr
&
sa
)
=
=
0
&
&
(
sa
.
sa_flags
&
SA_SIGINFO
)
=
=
0
&
&
sa
.
sa_handler
=
=
SIG_DFL
)
{
return
signum
;
}
}
return
0
;
}
static
bool
SetThreadSandbox
(
)
{
if
(
prctl
(
PR_GET_SECCOMP
0
0
0
0
)
=
=
0
)
{
if
(
!
InstallSyscallFilter
(
gSetSandboxFilter
false
)
)
{
MOZ_CRASH
(
"
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
)
"
)
;
}
return
true
;
}
return
false
;
}
static
void
SetThreadSandboxHandler
(
int
signum
)
{
if
(
SetThreadSandbox
(
)
)
{
gSetSandboxDone
=
2
;
}
else
{
gSetSandboxDone
=
1
;
}
syscall
(
__NR_futex
reinterpret_cast
<
int
*
>
(
&
gSetSandboxDone
)
FUTEX_WAKE
1
)
;
}
static
void
EnterChroot
(
)
{
if
(
gChrootHelper
)
{
gChrootHelper
-
>
Invoke
(
)
;
gChrootHelper
=
nullptr
;
}
}
static
void
BroadcastSetThreadSandbox
(
const
sock_fprog
*
aFilter
)
{
pid_t
pid
tid
myTid
;
DIR
*
taskdp
;
struct
dirent
*
de
;
gSetSandboxFilter
=
aFilter
;
static_assert
(
sizeof
(
mozilla
:
:
Atomic
<
int
>
)
=
=
sizeof
(
int
)
"
mozilla
:
:
Atomic
<
int
>
isn
'
t
represented
by
an
int
"
)
;
pid
=
getpid
(
)
;
myTid
=
syscall
(
__NR_gettid
)
;
taskdp
=
opendir
(
"
/
proc
/
self
/
task
"
)
;
if
(
taskdp
=
=
nullptr
)
{
SANDBOX_LOG_ERROR
(
"
opendir
/
proc
/
self
/
task
:
%
s
\
n
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
EnterChroot
(
)
;
bool
sandboxProgress
;
do
{
sandboxProgress
=
false
;
while
(
(
de
=
readdir
(
taskdp
)
)
)
{
char
*
endptr
;
tid
=
strtol
(
de
-
>
d_name
&
endptr
10
)
;
if
(
*
endptr
!
=
'
\
0
'
|
|
tid
<
=
0
)
{
continue
;
}
if
(
tid
=
=
myTid
)
{
continue
;
}
MOZ_RELEASE_ASSERT
(
gSeccompTsyncBroadcastSignum
!
=
0
)
;
gSetSandboxDone
=
0
;
if
(
syscall
(
__NR_tgkill
pid
tid
gSeccompTsyncBroadcastSignum
)
!
=
0
)
{
if
(
errno
=
=
ESRCH
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unexpectedly
exited
.
"
tid
)
;
sandboxProgress
=
true
;
continue
;
}
SANDBOX_LOG_ERROR
(
"
tgkill
(
%
d
%
d
)
:
%
s
\
n
"
pid
tid
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
static
const
int
crashDelay
=
10
;
struct
timespec
timeLimit
;
clock_gettime
(
CLOCK_MONOTONIC
&
timeLimit
)
;
timeLimit
.
tv_sec
+
=
crashDelay
;
while
(
true
)
{
static
const
struct
timespec
futexTimeout
=
{
0
10
*
1000
*
1000
}
;
if
(
syscall
(
__NR_futex
reinterpret_cast
<
int
*
>
(
&
gSetSandboxDone
)
FUTEX_WAIT
0
&
futexTimeout
)
!
=
0
)
{
if
(
errno
!
=
EWOULDBLOCK
&
&
errno
!
=
ETIMEDOUT
&
&
errno
!
=
EINTR
)
{
SANDBOX_LOG_ERROR
(
"
FUTEX_WAIT
:
%
s
\
n
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
}
if
(
gSetSandboxDone
>
0
)
{
if
(
gSetSandboxDone
=
=
2
)
{
sandboxProgress
=
true
;
}
break
;
}
if
(
syscall
(
__NR_tgkill
pid
tid
0
)
!
=
0
)
{
if
(
errno
=
=
ESRCH
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unexpectedly
exited
.
"
tid
)
;
}
sandboxProgress
=
true
;
break
;
}
struct
timespec
now
;
clock_gettime
(
CLOCK_MONOTONIC
&
now
)
;
if
(
now
.
tv_sec
>
timeLimit
.
tv_sec
|
|
(
now
.
tv_sec
=
=
timeLimit
.
tv_sec
&
&
now
.
tv_nsec
>
timeLimit
.
tv_nsec
)
)
{
SANDBOX_LOG_ERROR
(
"
Thread
%
d
unresponsive
for
%
d
seconds
.
"
"
Killing
process
.
"
tid
crashDelay
)
;
MOZ_CRASH
(
)
;
}
}
}
rewinddir
(
taskdp
)
;
}
while
(
sandboxProgress
)
;
void
(
*
oldHandler
)
(
int
)
;
oldHandler
=
signal
(
gSeccompTsyncBroadcastSignum
SIG_DFL
)
;
gSeccompTsyncBroadcastSignum
=
0
;
if
(
oldHandler
!
=
SetThreadSandboxHandler
)
{
SANDBOX_LOG_ERROR
(
"
handler
for
signal
%
d
was
changed
to
%
p
!
"
gSeccompTsyncBroadcastSignum
oldHandler
)
;
MOZ_CRASH
(
)
;
}
Unused
<
<
closedir
(
taskdp
)
;
SetThreadSandbox
(
)
;
gSetSandboxFilter
=
nullptr
;
}
static
void
ApplySandboxWithTSync
(
sock_fprog
*
aFilter
)
{
EnterChroot
(
)
;
if
(
!
InstallSyscallFilter
(
aFilter
true
)
)
{
MOZ_CRASH
(
"
seccomp
+
tsync
failed
but
kernel
supports
tsync
"
)
;
}
}
static
void
SetCurrentProcessSandbox
(
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
aPolicy
)
{
MOZ_ASSERT
(
gSandboxCrashFunc
)
;
sandbox
:
:
bpf_dsl
:
:
PolicyCompiler
compiler
(
aPolicy
.
get
(
)
sandbox
:
:
Trap
:
:
Registry
(
)
)
;
sandbox
:
:
CodeGen
:
:
Program
program
=
compiler
.
Compile
(
)
;
if
(
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
sandbox
:
:
bpf_dsl
:
:
DumpBPF
:
:
PrintProgram
(
program
)
;
}
InstallSigSysHandler
(
)
;
#
ifdef
MOZ_ASAN
__sanitizer_sandbox_arguments
asanArgs
;
asanArgs
.
coverage_sandboxed
=
1
;
asanArgs
.
coverage_fd
=
-
1
;
asanArgs
.
coverage_max_block_size
=
0
;
__sanitizer_sandbox_on_notify
(
&
asanArgs
)
;
#
endif
size_t
programLen
=
program
.
size
(
)
;
UniquePtr
<
sock_filter
[
]
>
flatProgram
(
new
sock_filter
[
programLen
]
)
;
for
(
auto
i
=
program
.
begin
(
)
;
i
!
=
program
.
end
(
)
;
+
+
i
)
{
flatProgram
[
i
-
program
.
begin
(
)
]
=
*
i
;
}
sock_fprog
fprog
;
fprog
.
filter
=
flatProgram
.
get
(
)
;
fprog
.
len
=
static_cast
<
unsigned
short
>
(
programLen
)
;
MOZ_RELEASE_ASSERT
(
static_cast
<
size_t
>
(
fprog
.
len
)
=
=
programLen
)
;
const
SandboxInfo
info
=
SandboxInfo
:
:
Get
(
)
;
if
(
info
.
Test
(
SandboxInfo
:
:
kHasSeccompTSync
)
)
{
if
(
info
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG_ERROR
(
"
using
seccomp
tsync
"
)
;
}
ApplySandboxWithTSync
(
&
fprog
)
;
}
else
{
if
(
info
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG_ERROR
(
"
no
tsync
support
;
using
signal
broadcast
"
)
;
}
BroadcastSetThreadSandbox
(
&
fprog
)
;
}
MOZ_RELEASE_ASSERT
(
!
gChrootHelper
"
forgot
to
chroot
"
)
;
}
void
SandboxEarlyInit
(
GeckoProcessType
aType
)
{
const
SandboxInfo
info
=
SandboxInfo
:
:
Get
(
)
;
if
(
info
.
Test
(
SandboxInfo
:
:
kUnexpectedThreads
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
IsSingleThreaded
(
)
)
;
bool
canChroot
=
false
;
bool
canUnshareNet
=
false
;
bool
canUnshareIPC
=
false
;
switch
(
aType
)
{
case
GeckoProcessType_Default
:
MOZ_ASSERT
(
false
"
SandboxEarlyInit
in
parent
process
"
)
;
return
;
#
ifdef
MOZ_GMP_SANDBOX
case
GeckoProcessType_GMPlugin
:
if
(
!
info
.
Test
(
SandboxInfo
:
:
kEnabledForMedia
)
)
{
break
;
}
canUnshareNet
=
true
;
canUnshareIPC
=
true
;
canChroot
=
info
.
Test
(
SandboxInfo
:
:
kHasSeccompBPF
)
;
break
;
#
endif
default
:
break
;
}
if
(
!
info
.
Test
(
SandboxInfo
:
:
kHasSeccompTSync
)
)
{
gSeccompTsyncBroadcastSignum
=
FindFreeSignalNumber
(
)
;
if
(
gSeccompTsyncBroadcastSignum
=
=
0
)
{
SANDBOX_LOG_ERROR
(
"
No
available
signal
numbers
!
"
)
;
MOZ_CRASH
(
)
;
}
void
(
*
oldHandler
)
(
int
)
;
oldHandler
=
signal
(
gSeccompTsyncBroadcastSignum
SetThreadSandboxHandler
)
;
if
(
oldHandler
!
=
SIG_DFL
)
{
SANDBOX_LOG_ERROR
(
"
signal
%
d
in
use
by
handler
%
p
!
\
n
"
gSeccompTsyncBroadcastSignum
oldHandler
)
;
MOZ_CRASH
(
)
;
}
}
if
(
!
canChroot
&
&
!
canUnshareNet
&
&
!
canUnshareIPC
)
{
return
;
}
{
LinuxCapabilities
existingCaps
;
if
(
existingCaps
.
GetCurrent
(
)
&
&
existingCaps
.
AnyEffective
(
)
)
{
SANDBOX_LOG_ERROR
(
"
PLEASE
DO
NOT
RUN
THIS
AS
ROOT
.
Strange
things
may
"
"
happen
when
capabilities
are
dropped
.
"
)
;
}
}
if
(
!
info
.
Test
(
SandboxInfo
:
:
kHasUserNamespaces
)
)
{
LinuxCapabilities
(
)
.
SetCurrent
(
)
;
return
;
}
if
(
!
UnshareUserNamespace
(
)
)
{
SANDBOX_LOG_ERROR
(
"
unshare
(
CLONE_NEWUSER
)
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
unshare
(
CLONE_NEWUSER
)
"
)
;
}
if
(
canUnshareIPC
&
&
syscall
(
__NR_unshare
CLONE_NEWIPC
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
unshare
(
CLONE_NEWIPC
)
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
unshare
(
CLONE_NEWIPC
)
"
)
;
}
if
(
canUnshareNet
&
&
syscall
(
__NR_unshare
CLONE_NEWNET
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
unshare
(
CLONE_NEWNET
)
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
unshare
(
CLONE_NEWNET
)
"
)
;
}
if
(
canChroot
)
{
gChrootHelper
=
MakeUnique
<
SandboxChroot
>
(
)
;
if
(
!
gChrootHelper
-
>
Prepare
(
)
)
{
SANDBOX_LOG_ERROR
(
"
failed
to
set
up
chroot
helper
"
)
;
MOZ_CRASH
(
"
SandboxChroot
:
:
Prepare
"
)
;
}
}
if
(
!
LinuxCapabilities
(
)
.
SetCurrent
(
)
)
{
SANDBOX_LOG_ERROR
(
"
dropping
capabilities
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
can
'
t
drop
capabilities
"
)
;
}
}
#
ifdef
MOZ_CONTENT_SANDBOX
bool
SetContentProcessSandbox
(
int
aBrokerFd
)
{
if
(
!
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kEnabledForContent
)
)
{
if
(
aBrokerFd
>
=
0
)
{
close
(
aBrokerFd
)
;
}
return
false
;
}
static
Maybe
<
SandboxBrokerClient
>
sBroker
;
if
(
aBrokerFd
>
=
0
)
{
sBroker
.
emplace
(
aBrokerFd
)
;
}
SetCurrentProcessSandbox
(
GetContentSandboxPolicy
(
sBroker
.
ptrOr
(
nullptr
)
)
)
;
return
true
;
}
#
endif
#
ifdef
MOZ_GMP_SANDBOX
void
SetMediaPluginSandbox
(
const
char
*
aFilePath
)
{
if
(
!
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kEnabledForMedia
)
)
{
return
;
}
MOZ_ASSERT
(
!
gMediaPluginFile
.
mPath
)
;
if
(
aFilePath
)
{
gMediaPluginFile
.
mPath
=
strdup
(
aFilePath
)
;
gMediaPluginFile
.
mFd
=
open
(
aFilePath
O_RDONLY
|
O_CLOEXEC
)
;
if
(
gMediaPluginFile
.
mFd
=
=
-
1
)
{
SANDBOX_LOG_ERROR
(
"
failed
to
open
plugin
file
%
s
:
%
s
"
aFilePath
strerror
(
errno
)
)
;
MOZ_CRASH
(
)
;
}
}
else
{
gMediaPluginFile
.
mFd
=
-
1
;
}
SetCurrentProcessSandbox
(
GetMediaSandboxPolicy
(
&
gMediaPluginFile
)
)
;
}
#
endif
}
