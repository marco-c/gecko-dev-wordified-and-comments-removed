#
include
"
SandboxLaunch
.
h
"
#
include
<
fcntl
.
h
>
#
include
<
sched
.
h
>
#
include
<
setjmp
.
h
>
#
include
<
signal
.
h
>
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
unistd
.
h
>
#
include
<
utility
>
#
include
"
LinuxCapabilities
.
h
"
#
include
"
LinuxSched
.
h
"
#
include
"
SandboxChrootProto
.
h
"
#
include
"
SandboxInfo
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
strings
/
safe_sprintf
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SandboxReporter
.
h
"
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prenv
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
#
ifdef
MOZ_X11
#
ifndef
MOZ_WIDGET_GTK
#
error
"
Unknown
toolkit
"
#
endif
#
include
<
gdk
/
gdk
.
h
>
#
include
<
gdk
/
gdkx
.
h
>
#
include
"
X11UndefineNone
.
h
"
#
include
"
gfxPlatform
.
h
"
#
endif
namespace
mozilla
{
static
bool
IsDisplayLocal
(
)
{
#
ifdef
MOZ_X11
Unused
<
<
gfxPlatform
:
:
GetPlatform
(
)
;
const
auto
display
=
gdk_display_get_default
(
)
;
if
(
NS_WARN_IF
(
display
=
=
nullptr
)
)
{
return
false
;
}
if
(
GDK_IS_X11_DISPLAY
(
display
)
)
{
const
int
xSocketFd
=
ConnectionNumber
(
GDK_DISPLAY_XDISPLAY
(
display
)
)
;
if
(
NS_WARN_IF
(
xSocketFd
<
0
)
)
{
return
false
;
}
int
domain
;
socklen_t
optlen
=
static_cast
<
socklen_t
>
(
sizeof
(
domain
)
)
;
int
rv
=
getsockopt
(
xSocketFd
SOL_SOCKET
SO_DOMAIN
&
domain
&
optlen
)
;
if
(
NS_WARN_IF
(
rv
!
=
0
)
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
static_cast
<
size_t
>
(
optlen
)
=
=
sizeof
(
domain
)
)
;
if
(
domain
!
=
AF_LOCAL
)
{
return
false
;
}
const
char
*
const
displayStr
=
PR_GetEnv
(
"
DISPLAY
"
)
;
nsAutoCString
socketPath
(
"
/
tmp
/
.
X11
-
unix
"
)
;
int
accessFlags
=
X_OK
;
int
displayNum
;
if
(
displayStr
&
&
(
sscanf
(
displayStr
"
:
%
d
"
&
displayNum
)
=
=
1
|
|
sscanf
(
displayStr
"
unix
:
%
d
"
&
displayNum
)
=
=
1
)
)
{
socketPath
.
AppendPrintf
(
"
/
X
%
d
"
displayNum
)
;
accessFlags
=
R_OK
|
W_OK
;
}
if
(
access
(
socketPath
.
get
(
)
accessFlags
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
%
s
is
inaccessible
(
%
s
)
;
can
'
t
isolate
network
namespace
in
"
"
content
processes
"
socketPath
.
get
(
)
strerror
(
errno
)
)
;
return
false
;
}
}
#
endif
return
true
;
}
bool
HasAtiDrivers
(
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsAutoString
vendorID
;
static
const
Array
<
nsresult
(
nsIGfxInfo
:
:
*
)
(
nsAString
&
)
2
>
kMethods
=
{
&
nsIGfxInfo
:
:
GetAdapterVendorID
&
nsIGfxInfo
:
:
GetAdapterVendorID2
}
;
for
(
const
auto
method
:
kMethods
)
{
if
(
NS_SUCCEEDED
(
(
gfxInfo
-
>
*
method
)
(
vendorID
)
)
)
{
if
(
vendorID
.
EqualsLiteral
(
"
ATI
Technologies
Inc
.
"
)
)
{
return
true
;
}
}
}
return
false
;
}
static
bool
ContentNeedsSysVIPC
(
)
{
#
ifdef
MOZ_ALSA
if
(
!
StaticPrefs
:
:
media_cubeb_sandbox
(
)
)
{
return
true
;
}
#
endif
if
(
PR_GetEnv
(
"
VGL_ISACTIVE
"
)
!
=
nullptr
)
{
return
true
;
}
if
(
HasAtiDrivers
(
)
)
{
return
true
;
}
return
false
;
}
static
void
PreloadSandboxLib
(
base
:
:
environment_map
*
aEnv
)
{
nsAutoCString
preload
;
preload
.
AssignLiteral
(
"
libmozsandbox
.
so
"
)
;
if
(
const
char
*
oldPreload
=
PR_GetEnv
(
"
LD_PRELOAD
"
)
)
{
preload
.
Append
(
'
'
)
;
preload
.
Append
(
oldPreload
)
;
(
*
aEnv
)
[
"
MOZ_ORIG_LD_PRELOAD
"
]
=
oldPreload
;
}
MOZ_ASSERT
(
aEnv
-
>
count
(
"
LD_PRELOAD
"
)
=
=
0
)
;
(
*
aEnv
)
[
"
LD_PRELOAD
"
]
=
preload
.
get
(
)
;
}
static
void
AttachSandboxReporter
(
base
:
:
file_handle_mapping_vector
*
aFdMap
)
{
int
srcFd
dstFd
;
SandboxReporter
:
:
Singleton
(
)
-
>
GetClientFileDescriptorMapping
(
&
srcFd
&
dstFd
)
;
aFdMap
-
>
push_back
(
{
srcFd
dstFd
}
)
;
}
class
SandboxFork
:
public
base
:
:
LaunchOptions
:
:
ForkDelegate
{
public
:
explicit
SandboxFork
(
int
aFlags
bool
aChroot
int
aServerFd
=
-
1
int
aClientFd
=
-
1
)
;
virtual
~
SandboxFork
(
)
;
void
PrepareMapping
(
base
:
:
file_handle_mapping_vector
*
aMap
)
;
pid_t
Fork
(
)
override
;
private
:
int
mFlags
;
int
mChrootServer
;
int
mChrootClient
;
void
StartChrootServer
(
)
;
SandboxFork
(
const
SandboxFork
&
)
=
delete
;
SandboxFork
&
operator
=
(
const
SandboxFork
&
)
=
delete
;
}
;
static
int
GetEffectiveSandboxLevel
(
GeckoProcessType
aType
)
{
auto
info
=
SandboxInfo
:
:
Get
(
)
;
switch
(
aType
)
{
case
GeckoProcessType_GMPlugin
:
if
(
info
.
Test
(
SandboxInfo
:
:
kEnabledForMedia
)
)
{
return
1
;
}
return
0
;
case
GeckoProcessType_Content
:
#
ifdef
MOZ_ENABLE_FORKSERVER
case
GeckoProcessType_ForkServer
:
#
endif
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
info
.
Test
(
SandboxInfo
:
:
kEnabledForContent
)
)
{
return
GetEffectiveContentSandboxLevel
(
)
;
}
return
0
;
case
GeckoProcessType_RDD
:
return
PR_GetEnv
(
"
MOZ_DISABLE_RDD_SANDBOX
"
)
=
=
nullptr
?
1
:
0
;
case
GeckoProcessType_Socket
:
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
GetEffectiveSocketProcessSandboxLevel
(
)
;
default
:
return
0
;
}
}
void
SandboxLaunchPrepare
(
GeckoProcessType
aType
base
:
:
LaunchOptions
*
aOptions
)
{
auto
info
=
SandboxInfo
:
:
Get
(
)
;
if
(
!
info
.
Test
(
SandboxInfo
:
:
kHasSeccompBPF
)
)
{
return
;
}
int
level
=
GetEffectiveSandboxLevel
(
aType
)
;
if
(
level
=
=
0
)
{
return
;
}
aOptions
-
>
env_map
[
"
MOZ_SANDBOXED
"
]
=
"
1
"
;
PreloadSandboxLib
(
&
aOptions
-
>
env_map
)
;
AttachSandboxReporter
(
&
aOptions
-
>
fds_to_remap
)
;
bool
canChroot
=
false
;
int
flags
=
0
;
if
(
aType
=
=
GeckoProcessType_Content
&
&
level
>
=
1
)
{
static
const
bool
needSysV
=
ContentNeedsSysVIPC
(
)
;
if
(
needSysV
)
{
aOptions
-
>
env_map
[
"
MOZ_SANDBOX_ALLOW_SYSV
"
]
=
"
1
"
;
}
else
{
flags
|
=
CLONE_NEWIPC
;
}
}
if
(
!
info
.
Test
(
SandboxInfo
:
:
kHasUserNamespaces
)
)
{
return
;
}
switch
(
aType
)
{
case
GeckoProcessType_Socket
:
if
(
level
>
=
1
)
{
canChroot
=
true
;
flags
|
=
CLONE_NEWIPC
;
}
break
;
case
GeckoProcessType_GMPlugin
:
case
GeckoProcessType_RDD
:
if
(
level
>
=
1
)
{
canChroot
=
true
;
flags
|
=
CLONE_NEWNET
|
CLONE_NEWIPC
;
}
break
;
case
GeckoProcessType_Content
:
if
(
level
>
=
4
)
{
canChroot
=
true
;
static
const
bool
canCloneNet
=
IsDisplayLocal
(
)
&
&
!
PR_GetEnv
(
"
RENDERDOC_CAPTUREOPTS
"
)
;
if
(
canCloneNet
)
{
flags
|
=
CLONE_NEWNET
;
}
}
if
(
Preferences
:
:
GetBool
(
"
security
.
sandbox
.
content
.
force
-
namespace
"
false
)
)
{
flags
|
=
CLONE_NEWUSER
;
}
break
;
default
:
break
;
}
if
(
canChroot
|
|
flags
!
=
0
)
{
flags
|
=
CLONE_NEWUSER
;
auto
forker
=
MakeUnique
<
SandboxFork
>
(
flags
canChroot
)
;
forker
-
>
PrepareMapping
(
&
aOptions
-
>
fds_to_remap
)
;
aOptions
-
>
fork_delegate
=
std
:
:
move
(
forker
)
;
aOptions
-
>
env_map
[
kSandboxChrootEnvFlag
]
=
std
:
:
to_string
(
canChroot
?
1
:
0
)
+
std
:
:
to_string
(
flags
)
;
}
}
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
void
SandboxLaunchForkServerPrepare
(
const
std
:
:
vector
<
std
:
:
string
>
&
aArgv
base
:
:
LaunchOptions
&
aOptions
)
{
auto
chroot
=
std
:
:
find_if
(
aOptions
.
env_map
.
begin
(
)
aOptions
.
env_map
.
end
(
)
[
]
(
auto
&
elt
)
{
return
elt
.
first
=
=
kSandboxChrootEnvFlag
;
}
)
;
if
(
chroot
=
=
aOptions
.
env_map
.
end
(
)
)
{
return
;
}
bool
canChroot
=
chroot
-
>
second
.
c_str
(
)
[
0
]
=
=
'
1
'
;
int
flags
=
atoi
(
chroot
-
>
second
.
c_str
(
)
+
1
)
;
MOZ_ASSERT
(
flags
|
|
canChroot
)
;
auto
fdmap
=
std
:
:
find_if
(
aOptions
.
fds_to_remap
.
begin
(
)
aOptions
.
fds_to_remap
.
end
(
)
[
]
(
auto
&
elt
)
{
return
elt
.
second
=
=
kSandboxChrootServerFd
;
}
)
;
MOZ_ASSERT
(
fdmap
!
=
aOptions
.
fds_to_remap
.
end
(
)
"
ChrootServerFd
is
not
found
with
sandbox
chroot
"
)
;
int
chrootserverfd
=
fdmap
-
>
first
;
aOptions
.
fds_to_remap
.
erase
(
fdmap
)
;
auto
forker
=
MakeUnique
<
SandboxFork
>
(
flags
canChroot
chrootserverfd
)
;
aOptions
.
fork_delegate
=
std
:
:
move
(
forker
)
;
}
#
endif
SandboxFork
:
:
SandboxFork
(
int
aFlags
bool
aChroot
int
aServerFd
int
aClientFd
)
:
mFlags
(
aFlags
)
mChrootServer
(
aServerFd
)
mChrootClient
(
aClientFd
)
{
if
(
aChroot
&
&
mChrootServer
<
0
)
{
int
fds
[
2
]
;
int
rv
=
socketpair
(
AF_UNIX
SOCK_STREAM
|
SOCK_CLOEXEC
0
fds
)
;
if
(
rv
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
socketpair
:
%
s
"
strerror
(
errno
)
)
;
MOZ_CRASH
(
"
socketpair
failed
"
)
;
}
mChrootClient
=
fds
[
0
]
;
mChrootServer
=
fds
[
1
]
;
}
}
void
SandboxFork
:
:
PrepareMapping
(
base
:
:
file_handle_mapping_vector
*
aMap
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_ForkServer
)
;
if
(
mChrootClient
>
=
0
)
{
aMap
-
>
push_back
(
{
mChrootClient
kSandboxChrootClientFd
}
)
;
}
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
if
(
mChrootServer
>
=
0
)
{
aMap
-
>
push_back
(
{
mChrootServer
kSandboxChrootServerFd
}
)
;
}
#
endif
}
SandboxFork
:
:
~
SandboxFork
(
)
{
if
(
mChrootClient
>
=
0
)
{
close
(
mChrootClient
)
;
}
if
(
mChrootServer
>
=
0
)
{
close
(
mChrootServer
)
;
}
}
static
void
BlockAllSignals
(
sigset_t
*
aOldSigs
)
{
sigset_t
allSigs
;
int
rv
=
sigfillset
(
&
allSigs
)
;
MOZ_RELEASE_ASSERT
(
rv
=
=
0
)
;
rv
=
pthread_sigmask
(
SIG_BLOCK
&
allSigs
aOldSigs
)
;
if
(
rv
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
pthread_sigmask
(
block
all
)
:
%
s
"
strerror
(
rv
)
)
;
MOZ_CRASH
(
"
pthread_sigmask
"
)
;
}
}
static
void
RestoreSignals
(
const
sigset_t
*
aOldSigs
)
{
int
rv
=
pthread_sigmask
(
SIG_SETMASK
aOldSigs
nullptr
)
;
if
(
rv
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
pthread_sigmask
(
restore
)
:
%
s
"
strerror
(
-
rv
)
)
;
MOZ_CRASH
(
"
pthread_sigmask
"
)
;
}
}
static
void
ResetSignalHandlers
(
)
{
for
(
int
signum
=
1
;
signum
<
=
SIGRTMAX
;
+
+
signum
)
{
if
(
signal
(
signum
SIG_DFL
)
=
=
SIG_ERR
)
{
MOZ_DIAGNOSTIC_ASSERT
(
errno
=
=
EINVAL
)
;
}
}
}
namespace
{
static
int
CloneCallee
(
void
*
aPtr
)
{
auto
ctxPtr
=
reinterpret_cast
<
jmp_buf
*
>
(
aPtr
)
;
longjmp
(
*
ctxPtr
1
)
;
MOZ_CRASH
(
"
unreachable
"
)
;
return
1
;
}
MOZ_NEVER_INLINE
MOZ_ASAN_BLACKLIST
static
pid_t
DoClone
(
int
aFlags
jmp_buf
*
aCtx
)
{
uint8_t
miniStack
[
PTHREAD_STACK_MIN
]
;
#
ifdef
__hppa__
void
*
stackPtr
=
miniStack
;
#
else
void
*
stackPtr
=
ArrayEnd
(
miniStack
)
;
#
endif
return
clone
(
CloneCallee
stackPtr
aFlags
aCtx
)
;
}
}
static
pid_t
ForkWithFlags
(
int
aFlags
)
{
static
const
int
kBadFlags
=
CLONE_VM
|
CLONE_VFORK
|
CLONE_SETTLS
|
CLONE_PARENT_SETTID
|
CLONE_CHILD_SETTID
|
CLONE_CHILD_CLEARTID
;
MOZ_RELEASE_ASSERT
(
(
aFlags
&
kBadFlags
)
=
=
0
)
;
jmp_buf
ctx
;
if
(
setjmp
(
ctx
)
=
=
0
)
{
return
DoClone
(
aFlags
|
SIGCHLD
&
ctx
)
;
}
return
0
;
}
static
bool
WriteStringToFile
(
const
char
*
aPath
const
char
*
aStr
const
size_t
aLen
)
{
int
fd
=
open
(
aPath
O_WRONLY
)
;
if
(
fd
<
0
)
{
return
false
;
}
ssize_t
written
=
write
(
fd
aStr
aLen
)
;
if
(
close
(
fd
)
!
=
0
|
|
written
!
=
ssize_t
(
aLen
)
)
{
return
false
;
}
return
true
;
}
static
void
ConfigureUserNamespace
(
uid_t
uid
gid_t
gid
)
{
using
base
:
:
strings
:
:
SafeSPrintf
;
char
buf
[
sizeof
(
"
18446744073709551615
18446744073709551615
1
"
)
]
;
size_t
len
;
len
=
static_cast
<
size_t
>
(
SafeSPrintf
(
buf
"
%
d
%
d
1
"
uid
uid
)
)
;
MOZ_RELEASE_ASSERT
(
len
<
sizeof
(
buf
)
)
;
if
(
!
WriteStringToFile
(
"
/
proc
/
self
/
uid_map
"
buf
len
)
)
{
MOZ_CRASH
(
"
Failed
to
write
/
proc
/
self
/
uid_map
"
)
;
}
Unused
<
<
WriteStringToFile
(
"
/
proc
/
self
/
setgroups
"
"
deny
"
4
)
;
len
=
static_cast
<
size_t
>
(
SafeSPrintf
(
buf
"
%
d
%
d
1
"
gid
gid
)
)
;
MOZ_RELEASE_ASSERT
(
len
<
sizeof
(
buf
)
)
;
if
(
!
WriteStringToFile
(
"
/
proc
/
self
/
gid_map
"
buf
len
)
)
{
MOZ_CRASH
(
"
Failed
to
write
/
proc
/
self
/
gid_map
"
)
;
}
}
static
void
DropAllCaps
(
)
{
if
(
!
LinuxCapabilities
(
)
.
SetCurrent
(
)
)
{
SANDBOX_LOG_ERROR
(
"
capset
(
drop
all
)
:
%
s
"
strerror
(
errno
)
)
;
}
}
pid_t
SandboxFork
:
:
Fork
(
)
{
if
(
mFlags
=
=
0
)
{
MOZ_ASSERT
(
mChrootServer
<
0
)
;
return
fork
(
)
;
}
uid_t
uid
=
getuid
(
)
;
gid_t
gid
=
getgid
(
)
;
sigset_t
oldSigs
;
BlockAllSignals
(
&
oldSigs
)
;
pid_t
pid
=
ForkWithFlags
(
mFlags
)
;
if
(
pid
!
=
0
)
{
RestoreSignals
(
&
oldSigs
)
;
return
pid
;
}
ResetSignalHandlers
(
)
;
RestoreSignals
(
&
oldSigs
)
;
ConfigureUserNamespace
(
uid
gid
)
;
if
(
mChrootServer
>
=
0
)
{
StartChrootServer
(
)
;
}
DropAllCaps
(
)
;
return
0
;
}
void
SandboxFork
:
:
StartChrootServer
(
)
{
pid_t
pid
=
ForkWithFlags
(
CLONE_FS
)
;
if
(
pid
<
0
)
{
MOZ_CRASH
(
"
failed
to
clone
chroot
helper
process
"
)
;
}
if
(
pid
>
0
)
{
return
;
}
LinuxCapabilities
caps
;
caps
.
Effective
(
CAP_SYS_CHROOT
)
=
true
;
if
(
!
caps
.
SetCurrent
(
)
)
{
SANDBOX_LOG_ERROR
(
"
capset
(
chroot
helper
)
:
%
s
"
strerror
(
errno
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
false
)
;
}
base
:
:
CloseSuperfluousFds
(
this
[
]
(
void
*
aCtx
int
aFd
)
{
return
aFd
=
=
static_cast
<
decltype
(
this
)
>
(
aCtx
)
-
>
mChrootServer
;
}
)
;
char
msg
;
ssize_t
msgLen
=
HANDLE_EINTR
(
read
(
mChrootServer
&
msg
1
)
)
;
if
(
msgLen
=
=
0
)
{
_exit
(
0
)
;
}
MOZ_RELEASE_ASSERT
(
msgLen
=
=
1
)
;
MOZ_RELEASE_ASSERT
(
msg
=
=
kSandboxChrootRequest
)
;
int
rv
=
chroot
(
"
/
proc
/
self
/
fdinfo
"
)
;
MOZ_RELEASE_ASSERT
(
rv
=
=
0
)
;
DropAllCaps
(
)
;
rv
=
chdir
(
"
/
"
)
;
MOZ_RELEASE_ASSERT
(
rv
=
=
0
)
;
msg
=
kSandboxChrootResponse
;
msgLen
=
HANDLE_EINTR
(
write
(
mChrootServer
&
msg
1
)
)
;
MOZ_RELEASE_ASSERT
(
msgLen
=
=
1
)
;
_exit
(
0
)
;
}
}
