#
include
"
SandboxFilter
.
h
"
#
include
"
SandboxFilterUtil
.
h
"
#
include
"
SandboxBrokerClient
.
h
"
#
include
"
SandboxInternal
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
linux
/
ipc
.
h
>
#
include
<
linux
/
net
.
h
>
#
include
<
linux
/
prctl
.
h
>
#
include
<
linux
/
sched
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
include
"
sandbox
/
linux
/
bpf_dsl
/
bpf_dsl
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_seccomp
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
using
namespace
sandbox
:
:
bpf_dsl
;
#
define
CASES
SANDBOX_BPF_DSL_CASES
#
ifndef
MADV_NOHUGEPAGE
#
define
MADV_NOHUGEPAGE
15
#
endif
#
ifndef
MADV_DONTDUMP
#
define
MADV_DONTDUMP
16
#
endif
#
ifndef
PR_SET_PTRACER
#
define
PR_SET_PTRACER
0x59616d61
#
endif
#
ifndef
ANDROID
#
define
DESKTOP
#
endif
namespace
mozilla
{
class
SandboxPolicyCommon
:
public
SandboxPolicyBase
{
protected
:
typedef
const
sandbox
:
:
arch_seccomp_data
&
ArgsRef
;
static
intptr_t
BlockedSyscallTrap
(
ArgsRef
aArgs
void
*
aux
)
{
MOZ_ASSERT
(
!
aux
)
;
return
-
ENOSYS
;
}
private
:
#
if
defined
(
ANDROID
)
&
&
ANDROID_VERSION
<
16
static
intptr_t
TKillCompatTrap
(
const
sandbox
:
:
arch_seccomp_data
&
aArgs
void
*
aux
)
{
return
syscall
(
__NR_tgkill
getpid
(
)
aArgs
.
args
[
0
]
aArgs
.
args
[
1
]
)
;
}
#
endif
public
:
virtual
ResultExpr
InvalidSyscall
(
)
const
override
{
return
Trap
(
BlockedSyscallTrap
nullptr
)
;
}
virtual
ResultExpr
ClonePolicy
(
ResultExpr
failPolicy
)
const
{
Arg
<
int
>
flags
(
0
)
;
static
const
int
flags_common
=
CLONE_VM
|
CLONE_FS
|
CLONE_FILES
|
CLONE_SIGHAND
|
CLONE_THREAD
|
CLONE_SYSVSEM
;
static
const
int
flags_modern
=
flags_common
|
CLONE_SETTLS
|
CLONE_PARENT_SETTID
|
CLONE_CHILD_CLEARTID
;
return
Switch
(
flags
)
#
ifdef
ANDROID
.
Case
(
flags_common
|
CLONE_DETACHED
Allow
(
)
)
.
Case
(
flags_common
Allow
(
)
)
#
endif
.
Case
(
flags_modern
Allow
(
)
)
.
Default
(
failPolicy
)
;
}
virtual
ResultExpr
PrctlPolicy
(
)
const
{
Arg
<
int
>
op
(
0
)
;
return
Switch
(
op
)
.
CASES
(
(
PR_GET_SECCOMP
PR_SET_NAME
PR_SET_DUMPABLE
PR_SET_PTRACER
)
Allow
(
)
)
.
Default
(
InvalidSyscall
(
)
)
;
}
virtual
Maybe
<
ResultExpr
>
EvaluateSocketCall
(
int
aCall
)
const
override
{
switch
(
aCall
)
{
case
SYS_RECVMSG
:
case
SYS_SENDMSG
:
return
Some
(
Allow
(
)
)
;
default
:
return
Nothing
(
)
;
}
}
virtual
ResultExpr
EvaluateSyscall
(
int
sysno
)
const
override
{
switch
(
sysno
)
{
case
__NR_clock_gettime
:
{
Arg
<
clockid_t
>
clk_id
(
0
)
;
return
If
(
clk_id
=
=
CLOCK_MONOTONIC
Allow
(
)
)
#
ifdef
CLOCK_MONOTONIC_COARSE
.
ElseIf
(
clk_id
=
=
CLOCK_MONOTONIC_COARSE
Allow
(
)
)
#
endif
.
ElseIf
(
clk_id
=
=
CLOCK_PROCESS_CPUTIME_ID
Allow
(
)
)
.
ElseIf
(
clk_id
=
=
CLOCK_REALTIME
Allow
(
)
)
#
ifdef
CLOCK_REALTIME_COARSE
.
ElseIf
(
clk_id
=
=
CLOCK_REALTIME_COARSE
Allow
(
)
)
#
endif
.
ElseIf
(
clk_id
=
=
CLOCK_THREAD_CPUTIME_ID
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
case
__NR_gettimeofday
:
#
ifdef
__NR_time
case
__NR_time
:
#
endif
case
__NR_nanosleep
:
return
Allow
(
)
;
case
__NR_futex
:
return
Allow
(
)
;
case
__NR_epoll_wait
:
case
__NR_epoll_pwait
:
case
__NR_epoll_ctl
:
case
__NR_ppoll
:
case
__NR_poll
:
return
Allow
(
)
;
case
__NR_pipe
:
return
Allow
(
)
;
CASES_FOR_fstat
:
return
Allow
(
)
;
case
__NR_write
:
case
__NR_read
:
case
__NR_readv
:
case
__NR_writev
:
CASES_FOR_lseek
:
return
Allow
(
)
;
CASES_FOR_mmap
:
case
__NR_munmap
:
return
Allow
(
)
;
#
if
defined
(
ANDROID
)
|
|
defined
(
MOZ_ASAN
)
case
__NR_sigaltstack
:
#
endif
CASES_FOR_sigreturn
:
CASES_FOR_sigprocmask
:
CASES_FOR_sigaction
:
return
Allow
(
)
;
case
__NR_tgkill
:
{
Arg
<
pid_t
>
tgid
(
0
)
;
return
If
(
tgid
=
=
getpid
(
)
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
#
if
defined
(
ANDROID
)
&
&
ANDROID_VERSION
<
16
case
__NR_tkill
:
return
Trap
(
TKillCompatTrap
nullptr
)
;
#
endif
case
__NR_sched_yield
:
return
Allow
(
)
;
case
__NR_clone
:
return
ClonePolicy
(
InvalidSyscall
(
)
)
;
#
ifdef
__NR_set_robust_list
case
__NR_set_robust_list
:
return
Allow
(
)
;
#
endif
#
ifdef
ANDROID
case
__NR_set_tid_address
:
return
Allow
(
)
;
#
endif
case
__NR_prctl
:
return
PrctlPolicy
(
)
;
case
__NR_getpriority
:
case
__NR_setpriority
:
return
Error
(
EACCES
)
;
case
__NR_sched_getaffinity
:
return
Error
(
ENOSYS
)
;
case
__NR_getpid
:
case
__NR_gettid
:
return
Allow
(
)
;
case
__NR_close
:
return
Allow
(
)
;
#
ifdef
__arm__
case
__ARM_NR_breakpoint
:
case
__ARM_NR_cacheflush
:
case
__ARM_NR_usr26
:
case
__ARM_NR_usr32
:
case
__ARM_NR_set_tls
:
return
Allow
(
)
;
#
endif
case
__NR_restart_syscall
:
return
Allow
(
)
;
case
__NR_exit
:
case
__NR_exit_group
:
return
Allow
(
)
;
#
ifdef
MOZ_ASAN
case
__NR_ioctl
:
{
Arg
<
int
>
fd
(
0
)
;
return
If
(
fd
=
=
STDERR_FILENO
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
case
__NR_readlink
:
case
__NR_readlinkat
:
return
Error
(
ENOENT
)
;
CASES_FOR_stat
:
return
Error
(
ENOENT
)
;
#
endif
default
:
return
SandboxPolicyBase
:
:
EvaluateSyscall
(
sysno
)
;
}
}
}
;
#
ifdef
MOZ_CONTENT_SANDBOX
class
ContentSandboxPolicy
:
public
SandboxPolicyCommon
{
SandboxBrokerClient
*
mBroker
;
#
ifdef
__NR_open
static
intptr_t
OpenTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Open
(
path
flags
)
;
}
#
endif
static
intptr_t
OpenAtTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
fd
=
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
auto
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
2
]
)
;
if
(
fd
!
=
AT_FDCWD
&
&
path
[
0
]
!
=
'
/
'
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
fd
-
relative
openat
(
%
d
\
"
%
s
\
"
0
%
o
)
"
fd
path
flags
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
return
broker
-
>
Open
(
path
flags
)
;
}
#
ifdef
__NR_access
static
intptr_t
AccessTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
mode
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Access
(
path
mode
)
;
}
#
endif
static
intptr_t
AccessAtTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
fd
=
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
auto
mode
=
static_cast
<
int
>
(
aArgs
.
args
[
2
]
)
;
if
(
fd
!
=
AT_FDCWD
&
&
path
[
0
]
!
=
'
/
'
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
fd
-
relative
faccessat
(
%
d
\
"
%
s
\
"
%
d
)
"
fd
path
mode
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
return
broker
-
>
Access
(
path
mode
)
;
}
static
intptr_t
StatTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
buf
=
reinterpret_cast
<
struct
stat
*
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Stat
(
path
buf
)
;
}
static
intptr_t
LStatTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
buf
=
reinterpret_cast
<
struct
stat
*
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
LStat
(
path
buf
)
;
}
static
intptr_t
StatAtTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
fd
=
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
auto
buf
=
reinterpret_cast
<
struct
stat
*
>
(
aArgs
.
args
[
2
]
)
;
auto
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
3
]
)
;
if
(
fd
!
=
AT_FDCWD
&
&
path
[
0
]
!
=
'
/
'
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
fd
-
relative
fstatat
(
%
d
\
"
%
s
\
"
%
p
%
d
)
"
fd
path
buf
flags
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
if
(
(
flags
&
~
AT_SYMLINK_NOFOLLOW
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
flags
%
d
in
fstatat
(
%
d
\
"
%
s
\
"
%
p
%
d
)
"
(
flags
&
~
AT_SYMLINK_NOFOLLOW
)
fd
path
buf
flags
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
return
(
flags
&
AT_SYMLINK_NOFOLLOW
)
=
=
0
?
broker
-
>
Stat
(
path
buf
)
:
broker
-
>
LStat
(
path
buf
)
;
}
static
intptr_t
GetPPidTrap
(
ArgsRef
aArgs
void
*
aux
)
{
return
0
;
}
public
:
explicit
ContentSandboxPolicy
(
SandboxBrokerClient
*
aBroker
)
:
mBroker
(
aBroker
)
{
}
virtual
~
ContentSandboxPolicy
(
)
{
}
virtual
ResultExpr
PrctlPolicy
(
)
const
override
{
return
Allow
(
)
;
}
virtual
Maybe
<
ResultExpr
>
EvaluateSocketCall
(
int
aCall
)
const
override
{
switch
(
aCall
)
{
case
SYS_RECVFROM
:
case
SYS_SENDTO
:
return
Some
(
Allow
(
)
)
;
case
SYS_SOCKETPAIR
:
{
if
(
!
kSocketCallHasArgs
)
{
return
Some
(
Allow
(
)
)
;
}
Arg
<
int
>
domain
(
0
)
type
(
1
)
;
return
Some
(
If
(
AllOf
(
domain
=
=
AF_UNIX
AnyOf
(
type
=
=
SOCK_STREAM
type
=
=
SOCK_SEQPACKET
)
)
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
)
;
}
#
ifdef
ANDROID
case
SYS_SOCKET
:
return
Some
(
Error
(
EACCES
)
)
;
#
else
case
SYS_RECV
:
case
SYS_SEND
:
case
SYS_SOCKET
:
case
SYS_CONNECT
:
case
SYS_ACCEPT
:
case
SYS_ACCEPT4
:
case
SYS_BIND
:
case
SYS_LISTEN
:
case
SYS_GETSOCKOPT
:
case
SYS_SETSOCKOPT
:
case
SYS_GETSOCKNAME
:
case
SYS_GETPEERNAME
:
case
SYS_SHUTDOWN
:
return
Some
(
Allow
(
)
)
;
#
endif
default
:
return
SandboxPolicyCommon
:
:
EvaluateSocketCall
(
aCall
)
;
}
}
#
ifdef
DESKTOP
virtual
Maybe
<
ResultExpr
>
EvaluateIpcCall
(
int
aCall
)
const
override
{
switch
(
aCall
)
{
case
SHMGET
:
case
SHMCTL
:
case
SHMAT
:
case
SHMDT
:
case
SEMGET
:
case
SEMCTL
:
case
SEMOP
:
case
MSGGET
:
return
Some
(
Allow
(
)
)
;
default
:
return
SandboxPolicyCommon
:
:
EvaluateIpcCall
(
aCall
)
;
}
}
#
endif
virtual
ResultExpr
EvaluateSyscall
(
int
sysno
)
const
override
{
if
(
mBroker
)
{
switch
(
sysno
)
{
case
__NR_open
:
return
Trap
(
OpenTrap
mBroker
)
;
case
__NR_openat
:
return
Trap
(
OpenAtTrap
mBroker
)
;
case
__NR_access
:
return
Trap
(
AccessTrap
mBroker
)
;
case
__NR_faccessat
:
return
Trap
(
AccessAtTrap
mBroker
)
;
CASES_FOR_stat
:
return
Trap
(
StatTrap
mBroker
)
;
CASES_FOR_lstat
:
return
Trap
(
LStatTrap
mBroker
)
;
CASES_FOR_fstatat
:
return
Trap
(
StatAtTrap
mBroker
)
;
}
}
else
{
switch
(
sysno
)
{
case
__NR_open
:
case
__NR_openat
:
case
__NR_access
:
case
__NR_faccessat
:
CASES_FOR_stat
:
CASES_FOR_lstat
:
CASES_FOR_fstatat
:
return
Allow
(
)
;
}
}
switch
(
sysno
)
{
#
ifdef
DESKTOP
case
__NR_getppid
:
return
Trap
(
GetPPidTrap
nullptr
)
;
case
__NR_mkdir
:
case
__NR_rmdir
:
case
__NR_getcwd
:
CASES_FOR_statfs
:
CASES_FOR_fstatfs
:
case
__NR_chmod
:
case
__NR_rename
:
case
__NR_symlink
:
case
__NR_quotactl
:
case
__NR_link
:
case
__NR_unlink
:
CASES_FOR_fchown
:
case
__NR_fchmod
:
case
__NR_flock
:
#
endif
return
Allow
(
)
;
case
__NR_readlink
:
case
__NR_readlinkat
:
#
ifdef
DESKTOP
return
Allow
(
)
;
#
else
return
Error
(
EINVAL
)
;
#
endif
CASES_FOR_select
:
case
__NR_pselect6
:
return
Allow
(
)
;
CASES_FOR_getdents
:
CASES_FOR_ftruncate
:
case
__NR_writev
:
case
__NR_pread64
:
#
ifdef
DESKTOP
case
__NR_pwrite64
:
case
__NR_readahead
:
#
endif
return
Allow
(
)
;
case
__NR_ioctl
:
return
Allow
(
)
;
CASES_FOR_fcntl
:
return
Allow
(
)
;
case
__NR_mprotect
:
case
__NR_brk
:
case
__NR_madvise
:
#
if
!
defined
(
MOZ_MEMORY
)
case
__NR_mremap
:
#
endif
return
Allow
(
)
;
case
__NR_sigaltstack
:
return
Allow
(
)
;
#
ifdef
__NR_set_thread_area
case
__NR_set_thread_area
:
return
Allow
(
)
;
#
endif
case
__NR_getrusage
:
case
__NR_times
:
return
Allow
(
)
;
case
__NR_dup
:
return
Allow
(
)
;
CASES_FOR_getuid
:
CASES_FOR_getgid
:
CASES_FOR_geteuid
:
CASES_FOR_getegid
:
return
Allow
(
)
;
case
__NR_fsync
:
case
__NR_msync
:
return
Allow
(
)
;
case
__NR_getpriority
:
case
__NR_setpriority
:
case
__NR_sched_get_priority_min
:
case
__NR_sched_get_priority_max
:
case
__NR_sched_getscheduler
:
case
__NR_sched_setscheduler
:
case
__NR_sched_getparam
:
case
__NR_sched_setparam
:
#
ifdef
DESKTOP
case
__NR_sched_getaffinity
:
#
endif
return
Allow
(
)
;
#
ifdef
DESKTOP
case
__NR_pipe2
:
return
Allow
(
)
;
CASES_FOR_getrlimit
:
case
__NR_clock_getres
:
CASES_FOR_getresuid
:
CASES_FOR_getresgid
:
return
Allow
(
)
;
case
__NR_umask
:
case
__NR_kill
:
case
__NR_wait4
:
#
ifdef
__NR_arch_prctl
case
__NR_arch_prctl
:
#
endif
return
Allow
(
)
;
case
__NR_eventfd2
:
case
__NR_inotify_init1
:
case
__NR_inotify_add_watch
:
case
__NR_inotify_rm_watch
:
return
Allow
(
)
;
#
ifdef
__NR_memfd_create
case
__NR_memfd_create
:
return
Allow
(
)
;
#
endif
#
ifdef
__NR_rt_tgsigqueueinfo
case
__NR_rt_tgsigqueueinfo
:
{
Arg
<
pid_t
>
tgid
(
0
)
;
return
If
(
tgid
=
=
getpid
(
)
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
#
endif
case
__NR_mlock
:
case
__NR_munlock
:
return
Allow
(
)
;
case
__NR_clone
:
return
ClonePolicy
(
Error
(
EPERM
)
)
;
#
ifdef
__NR_fadvise64
case
__NR_fadvise64
:
return
Allow
(
)
;
#
endif
#
ifdef
__NR_fadvise64_64
case
__NR_fadvise64_64
:
return
Allow
(
)
;
#
endif
case
__NR_fallocate
:
return
Allow
(
)
;
case
__NR_get_mempolicy
:
return
Allow
(
)
;
#
endif
#
ifdef
__NR_getrandom
case
__NR_getrandom
:
return
Allow
(
)
;
#
endif
case
__NR_uname
:
#
ifdef
DESKTOP
case
__NR_sysinfo
:
#
endif
return
Allow
(
)
;
#
ifdef
MOZ_JPROF
case
__NR_setitimer
:
return
Allow
(
)
;
#
endif
default
:
return
SandboxPolicyCommon
:
:
EvaluateSyscall
(
sysno
)
;
}
}
}
;
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
GetContentSandboxPolicy
(
SandboxBrokerClient
*
aMaybeBroker
)
{
return
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
(
new
ContentSandboxPolicy
(
aMaybeBroker
)
)
;
}
#
endif
#
ifdef
MOZ_GMP_SANDBOX
class
GMPSandboxPolicy
:
public
SandboxPolicyCommon
{
static
intptr_t
OpenTrap
(
const
sandbox
:
:
arch_seccomp_data
&
aArgs
void
*
aux
)
{
auto
plugin
=
static_cast
<
SandboxOpenedFile
*
>
(
aux
)
;
const
char
*
path
;
int
flags
;
switch
(
aArgs
.
nr
)
{
#
ifdef
__NR_open
case
__NR_open
:
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
break
;
#
endif
case
__NR_openat
:
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
2
]
)
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
syscall
number
"
)
;
}
if
(
strcmp
(
path
plugin
-
>
mPath
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
attempt
to
open
file
%
s
(
flags
=
0
%
o
)
which
is
not
the
"
"
media
plugin
%
s
"
path
flags
plugin
-
>
mPath
)
;
return
-
EPERM
;
}
if
(
(
flags
&
O_ACCMODE
)
!
=
O_RDONLY
)
{
SANDBOX_LOG_ERROR
(
"
non
-
read
-
only
open
of
file
%
s
attempted
(
flags
=
0
%
o
)
"
path
flags
)
;
return
-
EPERM
;
}
int
fd
=
plugin
-
>
mFd
.
exchange
(
-
1
)
;
if
(
fd
<
0
)
{
SANDBOX_LOG_ERROR
(
"
multiple
opens
of
media
plugin
file
unimplemented
"
)
;
return
-
ENOSYS
;
}
return
fd
;
}
static
intptr_t
SchedTrap
(
const
sandbox
:
:
arch_seccomp_data
&
aArgs
void
*
aux
)
{
const
pid_t
tid
=
syscall
(
__NR_gettid
)
;
if
(
aArgs
.
args
[
0
]
=
=
static_cast
<
uint64_t
>
(
tid
)
)
{
return
syscall
(
aArgs
.
nr
0
aArgs
.
args
[
1
]
aArgs
.
args
[
2
]
aArgs
.
args
[
3
]
aArgs
.
args
[
4
]
aArgs
.
args
[
5
]
)
;
}
SANDBOX_LOG_ERROR
(
"
unsupported
tid
in
SchedTrap
"
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
SandboxOpenedFile
*
mPlugin
;
public
:
explicit
GMPSandboxPolicy
(
SandboxOpenedFile
*
aPlugin
)
:
mPlugin
(
aPlugin
)
{
MOZ_ASSERT
(
aPlugin
-
>
mPath
[
0
]
=
=
'
/
'
"
plugin
path
should
be
absolute
"
)
;
}
virtual
~
GMPSandboxPolicy
(
)
{
}
virtual
ResultExpr
EvaluateSyscall
(
int
sysno
)
const
override
{
switch
(
sysno
)
{
#
ifdef
__NR_open
case
__NR_open
:
#
endif
case
__NR_openat
:
return
Trap
(
OpenTrap
mPlugin
)
;
case
__NR_mprotect
:
return
Allow
(
)
;
case
__NR_madvise
:
{
Arg
<
int
>
advice
(
2
)
;
return
If
(
advice
=
=
MADV_DONTNEED
Allow
(
)
)
#
ifdef
MOZ_ASAN
.
ElseIf
(
advice
=
=
MADV_NOHUGEPAGE
Allow
(
)
)
.
ElseIf
(
advice
=
=
MADV_DONTDUMP
Allow
(
)
)
#
endif
.
Else
(
InvalidSyscall
(
)
)
;
}
case
__NR_brk
:
CASES_FOR_geteuid
:
return
Allow
(
)
;
case
__NR_sched_getparam
:
case
__NR_sched_getscheduler
:
case
__NR_sched_get_priority_min
:
case
__NR_sched_get_priority_max
:
case
__NR_sched_setscheduler
:
{
Arg
<
pid_t
>
pid
(
0
)
;
return
If
(
pid
=
=
0
Allow
(
)
)
.
Else
(
Trap
(
SchedTrap
nullptr
)
)
;
}
case
__NR_times
:
return
Allow
(
)
;
default
:
return
SandboxPolicyCommon
:
:
EvaluateSyscall
(
sysno
)
;
}
}
}
;
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
GetMediaSandboxPolicy
(
SandboxOpenedFile
*
aPlugin
)
{
return
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
(
new
GMPSandboxPolicy
(
aPlugin
)
)
;
}
#
endif
}
