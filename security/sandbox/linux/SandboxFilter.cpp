#
include
"
SandboxFilter
.
h
"
#
include
"
SandboxFilterUtil
.
h
"
#
include
"
Sandbox
.
h
"
#
include
"
SandboxBrokerClient
.
h
"
#
include
"
SandboxInfo
.
h
"
#
include
"
SandboxInternal
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
"
SandboxOpenedFiles
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
prenv
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
linux
/
ioctl
.
h
>
#
include
<
linux
/
ipc
.
h
>
#
include
<
linux
/
net
.
h
>
#
include
<
linux
/
sched
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
ioctl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
prctl
.
h
>
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
un
.
h
>
#
include
<
sys
/
utsname
.
h
>
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
include
<
vector
>
#
include
<
algorithm
>
#
include
"
sandbox
/
linux
/
bpf_dsl
/
bpf_dsl
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_seccomp
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
using
namespace
sandbox
:
:
bpf_dsl
;
#
define
CASES
SANDBOX_BPF_DSL_CASES
#
ifndef
MADV_HUGEPAGE
#
define
MADV_HUGEPAGE
14
#
endif
#
ifndef
MADV_NOHUGEPAGE
#
define
MADV_NOHUGEPAGE
15
#
endif
#
ifndef
MADV_DONTDUMP
#
define
MADV_DONTDUMP
16
#
endif
#
ifndef
MADV_FREE
#
define
MADV_FREE
8
#
endif
#
ifndef
PR_SET_PTRACER
#
define
PR_SET_PTRACER
0x59616d61
#
endif
#
define
O_LARGEFILE_REAL
00100000
#
ifndef
ANDROID
#
define
DESKTOP
#
endif
namespace
mozilla
{
class
SandboxPolicyCommon
:
public
SandboxPolicyBase
{
protected
:
enum
class
ShmemUsage
{
MAY_CREATE
ONLY_USE
}
;
SandboxBrokerClient
*
mBroker
;
ShmemUsage
mShmemUsage
;
explicit
SandboxPolicyCommon
(
SandboxBrokerClient
*
aBroker
ShmemUsage
aShmemUsage
=
ShmemUsage
:
:
MAY_CREATE
)
:
mBroker
(
aBroker
)
mShmemUsage
(
aShmemUsage
)
{
}
SandboxPolicyCommon
(
)
:
SandboxPolicyCommon
(
nullptr
ShmemUsage
:
:
ONLY_USE
)
{
}
typedef
const
sandbox
:
:
arch_seccomp_data
&
ArgsRef
;
static
intptr_t
BlockedSyscallTrap
(
ArgsRef
aArgs
void
*
aux
)
{
MOZ_ASSERT
(
!
aux
)
;
return
-
ENOSYS
;
}
static
intptr_t
ConvertError
(
long
rv
)
{
return
rv
<
0
?
-
errno
:
rv
;
}
template
<
typename
.
.
.
Args
>
static
intptr_t
DoSyscall
(
long
nr
Args
.
.
.
args
)
{
static_assert
(
tl
:
:
And
<
(
sizeof
(
Args
)
<
=
sizeof
(
void
*
)
)
.
.
.
>
:
:
value
"
each
syscall
arg
is
at
most
one
word
"
)
;
return
ConvertError
(
syscall
(
nr
args
.
.
.
)
)
;
}
private
:
static
intptr_t
TKillCompatTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
tid
=
static_cast
<
pid_t
>
(
aArgs
.
args
[
0
]
)
;
auto
sig
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
return
DoSyscall
(
__NR_tgkill
getpid
(
)
tid
sig
)
;
}
static
intptr_t
SetNoNewPrivsTrap
(
ArgsRef
&
aArgs
void
*
aux
)
{
if
(
gSetSandboxFilter
=
=
nullptr
)
{
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
return
-
ETXTBSY
;
}
#
ifdef
__NR_open
static
intptr_t
OpenTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Open
(
path
flags
)
;
}
#
endif
static
intptr_t
OpenAtTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
fd
=
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
auto
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
2
]
)
;
if
(
fd
!
=
AT_FDCWD
&
&
path
[
0
]
!
=
'
/
'
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
fd
-
relative
openat
(
%
d
\
"
%
s
\
"
0
%
o
)
"
fd
path
flags
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
return
broker
-
>
Open
(
path
flags
)
;
}
#
ifdef
__NR_access
static
intptr_t
AccessTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
mode
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Access
(
path
mode
)
;
}
#
endif
static
intptr_t
AccessAtTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
fd
=
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
auto
mode
=
static_cast
<
int
>
(
aArgs
.
args
[
2
]
)
;
if
(
fd
!
=
AT_FDCWD
&
&
path
[
0
]
!
=
'
/
'
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
fd
-
relative
faccessat
(
%
d
\
"
%
s
\
"
%
d
)
"
fd
path
mode
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
return
broker
-
>
Access
(
path
mode
)
;
}
static
intptr_t
StatTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
buf
=
reinterpret_cast
<
statstruct
*
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Stat
(
path
buf
)
;
}
static
intptr_t
LStatTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
buf
=
reinterpret_cast
<
statstruct
*
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
LStat
(
path
buf
)
;
}
static
intptr_t
StatAtTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
fd
=
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
auto
buf
=
reinterpret_cast
<
statstruct
*
>
(
aArgs
.
args
[
2
]
)
;
auto
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
3
]
)
;
if
(
fd
!
=
AT_FDCWD
&
&
path
[
0
]
!
=
'
/
'
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
fd
-
relative
fstatat
(
%
d
\
"
%
s
\
"
%
p
%
d
)
"
fd
path
buf
flags
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
if
(
(
flags
&
~
AT_SYMLINK_NOFOLLOW
)
!
=
0
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
flags
%
d
in
fstatat
(
%
d
\
"
%
s
\
"
%
p
%
d
)
"
(
flags
&
~
AT_SYMLINK_NOFOLLOW
)
fd
path
buf
flags
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
return
(
flags
&
AT_SYMLINK_NOFOLLOW
)
=
=
0
?
broker
-
>
Stat
(
path
buf
)
:
broker
-
>
LStat
(
path
buf
)
;
}
static
intptr_t
ChmodTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
mode
=
static_cast
<
mode_t
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Chmod
(
path
mode
)
;
}
static
intptr_t
LinkTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
path2
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Link
(
path
path2
)
;
}
static
intptr_t
SymlinkTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
path2
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Symlink
(
path
path2
)
;
}
static
intptr_t
RenameTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
path2
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Rename
(
path
path2
)
;
}
static
intptr_t
MkdirTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
mode
=
static_cast
<
mode_t
>
(
aArgs
.
args
[
1
]
)
;
return
broker
-
>
Mkdir
(
path
mode
)
;
}
static
intptr_t
RmdirTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
return
broker
-
>
Rmdir
(
path
)
;
}
static
intptr_t
UnlinkTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
return
broker
-
>
Unlink
(
path
)
;
}
static
intptr_t
ReadlinkTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
auto
buf
=
reinterpret_cast
<
char
*
>
(
aArgs
.
args
[
1
]
)
;
auto
size
=
static_cast
<
size_t
>
(
aArgs
.
args
[
2
]
)
;
return
broker
-
>
Readlink
(
path
buf
size
)
;
}
static
intptr_t
ReadlinkAtTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
broker
=
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
;
auto
fd
=
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
;
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
auto
buf
=
reinterpret_cast
<
char
*
>
(
aArgs
.
args
[
2
]
)
;
auto
size
=
static_cast
<
size_t
>
(
aArgs
.
args
[
3
]
)
;
if
(
fd
!
=
AT_FDCWD
&
&
path
[
0
]
!
=
'
/
'
)
{
SANDBOX_LOG_ERROR
(
"
unsupported
fd
-
relative
readlinkat
(
%
d
%
s
%
p
%
u
)
"
fd
path
buf
size
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
return
broker
-
>
Readlink
(
path
buf
size
)
;
}
static
intptr_t
SocketpairDatagramTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
fds
=
reinterpret_cast
<
int
*
>
(
aArgs
.
args
[
3
]
)
;
return
ConvertError
(
socketpair
(
AF_UNIX
SOCK_SEQPACKET
0
fds
)
)
;
}
static
intptr_t
SocketpairUnpackTrap
(
ArgsRef
aArgs
void
*
aux
)
{
#
ifdef
__NR_socketpair
auto
argsPtr
=
reinterpret_cast
<
unsigned
long
*
>
(
aArgs
.
args
[
1
]
)
;
return
DoSyscall
(
__NR_socketpair
argsPtr
[
0
]
argsPtr
[
1
]
argsPtr
[
2
]
argsPtr
[
3
]
)
;
#
else
MOZ_CRASH
(
"
unreachable
?
"
)
;
return
-
ENOSYS
;
#
endif
}
public
:
ResultExpr
InvalidSyscall
(
)
const
override
{
return
Trap
(
BlockedSyscallTrap
nullptr
)
;
}
virtual
ResultExpr
ClonePolicy
(
ResultExpr
failPolicy
)
const
{
Arg
<
int
>
flags
(
0
)
;
static
const
int
flags_required
=
CLONE_VM
|
CLONE_FS
|
CLONE_FILES
|
CLONE_SIGHAND
|
CLONE_THREAD
|
CLONE_SYSVSEM
|
CLONE_SETTLS
|
CLONE_PARENT_SETTID
|
CLONE_CHILD_CLEARTID
;
static
const
int
flags_optional
=
CLONE_DETACHED
;
return
If
(
(
flags
&
~
flags_optional
)
=
=
flags_required
Allow
(
)
)
.
Else
(
failPolicy
)
;
}
virtual
ResultExpr
PrctlPolicy
(
)
const
{
Arg
<
int
>
op
(
0
)
;
return
Switch
(
op
)
.
CASES
(
(
PR_GET_SECCOMP
PR_SET_NAME
PR_SET_DUMPABLE
PR_SET_PTRACER
)
Allow
(
)
)
.
Default
(
InvalidSyscall
(
)
)
;
}
Maybe
<
ResultExpr
>
EvaluateSocketCall
(
int
aCall
bool
aHasArgs
)
const
override
{
switch
(
aCall
)
{
case
SYS_RECVMSG
:
case
SYS_SENDMSG
:
return
Some
(
Allow
(
)
)
;
case
SYS_SOCKETPAIR
:
{
if
(
mBroker
=
=
nullptr
)
{
return
Nothing
(
)
;
}
if
(
!
aHasArgs
)
{
if
(
HasSeparateSocketCalls
(
)
)
{
return
Some
(
Trap
(
SocketpairUnpackTrap
nullptr
)
)
;
}
return
Some
(
Allow
(
)
)
;
}
Arg
<
int
>
domain
(
0
)
type
(
1
)
;
return
Some
(
If
(
domain
=
=
AF_UNIX
Switch
(
type
&
~
(
SOCK_CLOEXEC
|
SOCK_NONBLOCK
)
)
.
Case
(
SOCK_STREAM
Allow
(
)
)
.
Case
(
SOCK_SEQPACKET
Allow
(
)
)
.
Case
(
SOCK_DGRAM
Trap
(
SocketpairDatagramTrap
nullptr
)
)
.
Default
(
InvalidSyscall
(
)
)
)
.
Else
(
InvalidSyscall
(
)
)
)
;
}
default
:
return
Nothing
(
)
;
}
}
ResultExpr
EvaluateSyscall
(
int
sysno
)
const
override
{
if
(
mBroker
!
=
nullptr
)
{
switch
(
sysno
)
{
case
__NR_open
:
return
Trap
(
OpenTrap
mBroker
)
;
case
__NR_openat
:
return
Trap
(
OpenAtTrap
mBroker
)
;
case
__NR_access
:
return
Trap
(
AccessTrap
mBroker
)
;
case
__NR_faccessat
:
return
Trap
(
AccessAtTrap
mBroker
)
;
CASES_FOR_stat
:
return
Trap
(
StatTrap
mBroker
)
;
CASES_FOR_lstat
:
return
Trap
(
LStatTrap
mBroker
)
;
CASES_FOR_fstatat
:
return
Trap
(
StatAtTrap
mBroker
)
;
case
__NR_statx
:
return
Error
(
ENOSYS
)
;
case
__NR_chmod
:
return
Trap
(
ChmodTrap
mBroker
)
;
case
__NR_link
:
return
Trap
(
LinkTrap
mBroker
)
;
case
__NR_mkdir
:
return
Trap
(
MkdirTrap
mBroker
)
;
case
__NR_symlink
:
return
Trap
(
SymlinkTrap
mBroker
)
;
case
__NR_rename
:
return
Trap
(
RenameTrap
mBroker
)
;
case
__NR_rmdir
:
return
Trap
(
RmdirTrap
mBroker
)
;
case
__NR_unlink
:
return
Trap
(
UnlinkTrap
mBroker
)
;
case
__NR_readlink
:
return
Trap
(
ReadlinkTrap
mBroker
)
;
case
__NR_readlinkat
:
return
Trap
(
ReadlinkAtTrap
mBroker
)
;
}
}
switch
(
sysno
)
{
case
__NR_clock_gettime
:
{
Arg
<
clockid_t
>
clk_id
(
0
)
;
return
If
(
clk_id
=
=
CLOCK_MONOTONIC
Allow
(
)
)
#
ifdef
CLOCK_MONOTONIC_COARSE
.
ElseIf
(
clk_id
=
=
CLOCK_MONOTONIC_COARSE
Allow
(
)
)
#
endif
.
ElseIf
(
clk_id
=
=
CLOCK_PROCESS_CPUTIME_ID
Allow
(
)
)
.
ElseIf
(
clk_id
=
=
CLOCK_REALTIME
Allow
(
)
)
#
ifdef
CLOCK_REALTIME_COARSE
.
ElseIf
(
clk_id
=
=
CLOCK_REALTIME_COARSE
Allow
(
)
)
#
endif
.
ElseIf
(
clk_id
=
=
CLOCK_THREAD_CPUTIME_ID
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
case
__NR_gettimeofday
:
#
ifdef
__NR_time
case
__NR_time
:
#
endif
case
__NR_nanosleep
:
return
Allow
(
)
;
case
__NR_futex
:
return
Allow
(
)
;
case
__NR_epoll_create1
:
case
__NR_epoll_create
:
case
__NR_epoll_wait
:
case
__NR_epoll_pwait
:
case
__NR_epoll_ctl
:
case
__NR_ppoll
:
case
__NR_poll
:
return
Allow
(
)
;
case
__NR_pipe
:
return
Allow
(
)
;
CASES_FOR_fstat
:
return
Allow
(
)
;
case
__NR_write
:
case
__NR_read
:
case
__NR_readv
:
case
__NR_writev
:
CASES_FOR_lseek
:
return
Allow
(
)
;
CASES_FOR_ftruncate
:
switch
(
mShmemUsage
)
{
case
ShmemUsage
:
:
MAY_CREATE
:
return
Allow
(
)
;
case
ShmemUsage
:
:
ONLY_USE
:
return
InvalidSyscall
(
)
;
default
:
MOZ_CRASH
(
"
unreachable
"
)
;
}
case
__NR_dup
:
return
Allow
(
)
;
CASES_FOR_mmap
:
case
__NR_munmap
:
return
Allow
(
)
;
case
__NR_mprotect
:
return
Allow
(
)
;
#
if
!
defined
(
MOZ_MEMORY
)
case
__NR_brk
:
return
Allow
(
)
;
#
endif
case
__NR_madvise
:
{
Arg
<
int
>
advice
(
2
)
;
return
If
(
advice
=
=
MADV_DONTNEED
Allow
(
)
)
.
ElseIf
(
advice
=
=
MADV_FREE
Allow
(
)
)
.
ElseIf
(
advice
=
=
MADV_HUGEPAGE
Allow
(
)
)
.
ElseIf
(
advice
=
=
MADV_NOHUGEPAGE
Allow
(
)
)
#
ifdef
MOZ_ASAN
.
ElseIf
(
advice
=
=
MADV_DONTDUMP
Allow
(
)
)
#
endif
.
Else
(
InvalidSyscall
(
)
)
;
}
case
__NR_membarrier
:
return
Allow
(
)
;
#
if
defined
(
ANDROID
)
|
|
defined
(
MOZ_ASAN
)
case
__NR_sigaltstack
:
#
endif
CASES_FOR_sigreturn
:
CASES_FOR_sigprocmask
:
CASES_FOR_sigaction
:
return
Allow
(
)
;
case
__NR_tgkill
:
{
Arg
<
pid_t
>
tgid
(
0
)
;
return
If
(
tgid
=
=
getpid
(
)
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
case
__NR_tkill
:
return
Trap
(
TKillCompatTrap
nullptr
)
;
case
__NR_sched_yield
:
return
Allow
(
)
;
case
__NR_clone
:
return
ClonePolicy
(
InvalidSyscall
(
)
)
;
#
ifdef
__NR_set_robust_list
case
__NR_set_robust_list
:
return
Allow
(
)
;
#
endif
#
ifdef
ANDROID
case
__NR_set_tid_address
:
return
Allow
(
)
;
#
endif
case
__NR_prctl
:
{
if
(
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kHasSeccompTSync
)
)
{
return
PrctlPolicy
(
)
;
}
Arg
<
int
>
option
(
0
)
;
return
If
(
option
=
=
PR_SET_NO_NEW_PRIVS
Trap
(
SetNoNewPrivsTrap
nullptr
)
)
.
Else
(
PrctlPolicy
(
)
)
;
}
case
__NR_getpriority
:
case
__NR_setpriority
:
return
Error
(
EACCES
)
;
case
__NR_sched_getaffinity
:
return
Error
(
ENOSYS
)
;
case
__NR_getpid
:
case
__NR_gettid
:
return
Allow
(
)
;
case
__NR_close
:
return
Allow
(
)
;
#
ifdef
__arm__
case
__ARM_NR_breakpoint
:
case
__ARM_NR_cacheflush
:
case
__ARM_NR_usr26
:
case
__ARM_NR_usr32
:
case
__ARM_NR_set_tls
:
return
Allow
(
)
;
#
endif
case
__NR_restart_syscall
:
return
Allow
(
)
;
case
__NR_exit
:
case
__NR_exit_group
:
return
Allow
(
)
;
case
__NR_getrandom
:
return
Allow
(
)
;
#
ifdef
DESKTOP
case
__NR_sysinfo
:
return
Error
(
EPERM
)
;
#
endif
#
ifdef
MOZ_ASAN
case
__NR_ioctl
:
{
Arg
<
int
>
fd
(
0
)
;
return
If
(
fd
=
=
STDERR_FILENO
Error
(
ENOTTY
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
case
__NR_readlink
:
case
__NR_readlinkat
:
return
Error
(
ENOENT
)
;
CASES_FOR_stat
:
return
Error
(
ENOENT
)
;
#
endif
default
:
return
SandboxPolicyBase
:
:
EvaluateSyscall
(
sysno
)
;
}
}
}
;
class
ContentSandboxPolicy
:
public
SandboxPolicyCommon
{
private
:
ContentProcessSandboxParams
mParams
;
bool
mAllowSysV
;
bool
mUsingRenderDoc
;
bool
BelowLevel
(
int
aLevel
)
const
{
return
mParams
.
mLevel
<
aLevel
;
}
ResultExpr
AllowBelowLevel
(
int
aLevel
ResultExpr
aOrElse
)
const
{
return
BelowLevel
(
aLevel
)
?
Allow
(
)
:
std
:
:
move
(
aOrElse
)
;
}
ResultExpr
AllowBelowLevel
(
int
aLevel
)
const
{
return
AllowBelowLevel
(
aLevel
InvalidSyscall
(
)
)
;
}
static
intptr_t
GetPPidTrap
(
ArgsRef
aArgs
void
*
aux
)
{
return
0
;
}
static
intptr_t
StatFsTrap
(
ArgsRef
aArgs
void
*
aux
)
{
auto
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
int
fd
=
open
(
path
O_RDONLY
|
O_LARGEFILE
)
;
if
(
fd
<
0
)
{
return
-
errno
;
}
intptr_t
rv
;
switch
(
aArgs
.
nr
)
{
case
__NR_statfs
:
{
auto
buf
=
reinterpret_cast
<
void
*
>
(
aArgs
.
args
[
1
]
)
;
rv
=
DoSyscall
(
__NR_fstatfs
fd
buf
)
;
break
;
}
#
ifdef
__NR_statfs64
case
__NR_statfs64
:
{
auto
sz
=
static_cast
<
size_t
>
(
aArgs
.
args
[
1
]
)
;
auto
buf
=
reinterpret_cast
<
void
*
>
(
aArgs
.
args
[
2
]
)
;
rv
=
DoSyscall
(
__NR_fstatfs64
fd
sz
buf
)
;
break
;
}
#
endif
default
:
MOZ_ASSERT
(
false
)
;
rv
=
-
ENOSYS
;
}
close
(
fd
)
;
return
rv
;
}
static
intptr_t
FakeSocketTrapCommon
(
int
domain
int
type
int
protocol
)
{
int
fds
[
2
]
;
if
(
domain
!
=
AF_UNIX
)
{
return
-
EAFNOSUPPORT
;
}
if
(
socketpair
(
domain
type
protocol
fds
)
!
=
0
)
{
return
-
errno
;
}
close
(
fds
[
1
]
)
;
return
fds
[
0
]
;
}
static
intptr_t
FakeSocketTrap
(
ArgsRef
aArgs
void
*
aux
)
{
return
FakeSocketTrapCommon
(
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
static_cast
<
int
>
(
aArgs
.
args
[
2
]
)
)
;
}
static
intptr_t
FakeSocketTrapLegacy
(
ArgsRef
aArgs
void
*
aux
)
{
const
auto
innerArgs
=
reinterpret_cast
<
unsigned
long
*
>
(
aArgs
.
args
[
1
]
)
;
return
FakeSocketTrapCommon
(
static_cast
<
int
>
(
innerArgs
[
0
]
)
static_cast
<
int
>
(
innerArgs
[
1
]
)
static_cast
<
int
>
(
innerArgs
[
2
]
)
)
;
}
static
Maybe
<
int
>
DoGetSockOpt
(
int
fd
int
optname
)
{
int
optval
;
socklen_t
optlen
=
sizeof
(
optval
)
;
if
(
getsockopt
(
fd
SOL_SOCKET
optname
&
optval
&
optlen
)
!
=
0
)
{
return
Nothing
(
)
;
}
MOZ_RELEASE_ASSERT
(
static_cast
<
size_t
>
(
optlen
)
=
=
sizeof
(
optval
)
)
;
return
Some
(
optval
)
;
}
static
intptr_t
ConnectTrapCommon
(
SandboxBrokerClient
*
aBroker
int
aFd
const
struct
sockaddr_un
*
aAddr
socklen_t
aLen
)
{
if
(
aFd
<
0
)
{
return
-
EBADF
;
}
const
auto
maybeDomain
=
DoGetSockOpt
(
aFd
SO_DOMAIN
)
;
if
(
!
maybeDomain
)
{
return
-
errno
;
}
if
(
*
maybeDomain
!
=
AF_UNIX
)
{
return
-
EAFNOSUPPORT
;
}
const
auto
maybeType
=
DoGetSockOpt
(
aFd
SO_TYPE
)
;
if
(
!
maybeType
)
{
return
-
errno
;
}
const
int
oldFlags
=
fcntl
(
aFd
F_GETFL
)
;
if
(
oldFlags
=
=
-
1
)
{
return
-
errno
;
}
const
int
newFd
=
aBroker
-
>
Connect
(
aAddr
aLen
*
maybeType
)
;
if
(
newFd
<
0
)
{
return
newFd
;
}
if
(
fcntl
(
newFd
F_SETFL
oldFlags
&
O_NONBLOCK
)
!
=
0
)
{
close
(
newFd
)
;
return
-
errno
;
}
if
(
dup2
(
newFd
aFd
)
<
0
)
{
close
(
newFd
)
;
return
-
errno
;
}
close
(
newFd
)
;
return
0
;
}
static
intptr_t
ConnectTrap
(
ArgsRef
aArgs
void
*
aux
)
{
typedef
const
struct
sockaddr_un
*
AddrPtr
;
return
ConnectTrapCommon
(
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
static_cast
<
int
>
(
aArgs
.
args
[
0
]
)
reinterpret_cast
<
AddrPtr
>
(
aArgs
.
args
[
1
]
)
static_cast
<
socklen_t
>
(
aArgs
.
args
[
2
]
)
)
;
}
static
intptr_t
ConnectTrapLegacy
(
ArgsRef
aArgs
void
*
aux
)
{
const
auto
innerArgs
=
reinterpret_cast
<
unsigned
long
*
>
(
aArgs
.
args
[
1
]
)
;
typedef
const
struct
sockaddr_un
*
AddrPtr
;
return
ConnectTrapCommon
(
static_cast
<
SandboxBrokerClient
*
>
(
aux
)
static_cast
<
int
>
(
innerArgs
[
0
]
)
reinterpret_cast
<
AddrPtr
>
(
innerArgs
[
1
]
)
static_cast
<
socklen_t
>
(
innerArgs
[
2
]
)
)
;
}
public
:
ContentSandboxPolicy
(
SandboxBrokerClient
*
aBroker
ContentProcessSandboxParams
&
&
aParams
)
:
SandboxPolicyCommon
(
aBroker
)
mParams
(
std
:
:
move
(
aParams
)
)
mAllowSysV
(
PR_GetEnv
(
"
MOZ_SANDBOX_ALLOW_SYSV
"
)
!
=
nullptr
)
mUsingRenderDoc
(
PR_GetEnv
(
"
RENDERDOC_CAPTUREOPTS
"
)
!
=
nullptr
)
{
}
~
ContentSandboxPolicy
(
)
override
=
default
;
Maybe
<
ResultExpr
>
EvaluateSocketCall
(
int
aCall
bool
aHasArgs
)
const
override
{
switch
(
aCall
)
{
case
SYS_RECVFROM
:
case
SYS_SENDTO
:
case
SYS_SENDMMSG
:
return
Some
(
Allow
(
)
)
;
#
ifdef
ANDROID
case
SYS_SOCKET
:
return
Some
(
Error
(
EACCES
)
)
;
#
else
case
SYS_SOCKET
:
{
const
auto
trapFn
=
aHasArgs
?
FakeSocketTrap
:
FakeSocketTrapLegacy
;
return
Some
(
AllowBelowLevel
(
4
Trap
(
trapFn
nullptr
)
)
)
;
}
case
SYS_CONNECT
:
{
const
auto
trapFn
=
aHasArgs
?
ConnectTrap
:
ConnectTrapLegacy
;
return
Some
(
AllowBelowLevel
(
4
Trap
(
trapFn
mBroker
)
)
)
;
}
case
SYS_ACCEPT
:
case
SYS_ACCEPT4
:
if
(
mUsingRenderDoc
)
{
return
Some
(
Allow
(
)
)
;
}
return
SandboxPolicyCommon
:
:
EvaluateSocketCall
(
aCall
aHasArgs
)
;
case
SYS_RECV
:
case
SYS_SEND
:
case
SYS_GETSOCKOPT
:
case
SYS_SETSOCKOPT
:
case
SYS_GETSOCKNAME
:
case
SYS_GETPEERNAME
:
case
SYS_SHUTDOWN
:
return
Some
(
Allow
(
)
)
;
#
endif
default
:
return
SandboxPolicyCommon
:
:
EvaluateSocketCall
(
aCall
aHasArgs
)
;
}
}
#
ifdef
DESKTOP
Maybe
<
ResultExpr
>
EvaluateIpcCall
(
int
aCall
)
const
override
{
switch
(
aCall
)
{
case
SHMGET
:
return
Some
(
mAllowSysV
?
Allow
(
)
:
Error
(
EPERM
)
)
;
case
SHMCTL
:
case
SHMAT
:
case
SHMDT
:
case
SEMGET
:
case
SEMCTL
:
case
SEMOP
:
if
(
mAllowSysV
)
{
return
Some
(
Allow
(
)
)
;
}
return
SandboxPolicyCommon
:
:
EvaluateIpcCall
(
aCall
)
;
default
:
return
SandboxPolicyCommon
:
:
EvaluateIpcCall
(
aCall
)
;
}
}
#
endif
#
ifdef
MOZ_PULSEAUDIO
ResultExpr
PrctlPolicy
(
)
const
override
{
if
(
BelowLevel
(
4
)
)
{
Arg
<
int
>
op
(
0
)
;
return
If
(
op
=
=
PR_GET_NAME
Allow
(
)
)
.
Else
(
SandboxPolicyCommon
:
:
PrctlPolicy
(
)
)
;
}
return
SandboxPolicyCommon
:
:
PrctlPolicy
(
)
;
}
#
endif
ResultExpr
EvaluateSyscall
(
int
sysno
)
const
override
{
const
auto
&
whitelist
=
mParams
.
mSyscallWhitelist
;
if
(
std
:
:
find
(
whitelist
.
begin
(
)
whitelist
.
end
(
)
sysno
)
!
=
whitelist
.
end
(
)
)
{
if
(
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG_ERROR
(
"
Allowing
syscall
nr
%
d
via
whitelist
"
sysno
)
;
}
return
Allow
(
)
;
}
if
(
BelowLevel
(
2
)
)
{
MOZ_ASSERT
(
mBroker
=
=
nullptr
)
;
switch
(
sysno
)
{
case
__NR_open
:
case
__NR_openat
:
case
__NR_access
:
case
__NR_faccessat
:
CASES_FOR_stat
:
CASES_FOR_lstat
:
CASES_FOR_fstatat
:
case
__NR_chmod
:
case
__NR_link
:
case
__NR_mkdir
:
case
__NR_symlink
:
case
__NR_rename
:
case
__NR_rmdir
:
case
__NR_unlink
:
case
__NR_readlink
:
case
__NR_readlinkat
:
return
Allow
(
)
;
}
}
switch
(
sysno
)
{
#
ifdef
DESKTOP
case
__NR_getppid
:
return
Trap
(
GetPPidTrap
nullptr
)
;
CASES_FOR_statfs
:
return
Trap
(
StatFsTrap
nullptr
)
;
case
__NR_getcwd
:
return
Error
(
ENOENT
)
;
#
ifdef
MOZ_PULSEAUDIO
CASES_FOR_fchown
:
case
__NR_fchmod
:
return
AllowBelowLevel
(
4
)
;
#
endif
CASES_FOR_fstatfs
:
case
__NR_flock
:
return
Allow
(
)
;
#
ifdef
__NR_mknod
case
__NR_mknod
:
#
endif
case
__NR_mknodat
:
{
Arg
<
mode_t
>
mode
(
sysno
=
=
__NR_mknodat
?
2
:
1
)
;
return
If
(
(
mode
&
S_IFMT
)
=
=
S_IFCHR
Error
(
EPERM
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
#
ifdef
__NR_chown
case
__NR_chown
:
#
endif
case
__NR_fchownat
:
return
Error
(
EPERM
)
;
case
__NR_utime
:
return
Error
(
EPERM
)
;
#
endif
CASES_FOR_select
:
case
__NR_pselect6
:
return
Allow
(
)
;
CASES_FOR_getdents
:
case
__NR_writev
:
case
__NR_pread64
:
#
ifdef
DESKTOP
case
__NR_pwrite64
:
case
__NR_readahead
:
#
endif
return
Allow
(
)
;
case
__NR_ioctl
:
{
#
ifdef
MOZ_ALSA
if
(
BelowLevel
(
4
)
)
{
return
Allow
(
)
;
}
#
endif
static
const
unsigned
long
kTypeMask
=
_IOC_TYPEMASK
<
<
_IOC_TYPESHIFT
;
static
const
unsigned
long
kTtyIoctls
=
TIOCSTI
&
kTypeMask
;
static_assert
(
kTtyIoctls
=
=
(
TCSETA
&
kTypeMask
)
&
&
kTtyIoctls
=
=
(
FIOASYNC
&
kTypeMask
)
"
tty
-
related
ioctls
use
the
same
type
"
)
;
Arg
<
unsigned
long
>
request
(
1
)
;
auto
shifted_type
=
request
&
kTypeMask
;
return
If
(
request
=
=
FIOCLEX
Allow
(
)
)
.
ElseIf
(
request
=
=
FIONBIO
Allow
(
)
)
.
ElseIf
(
request
=
=
TCGETS
Error
(
ENOTTY
)
)
.
ElseIf
(
shifted_type
!
=
kTtyIoctls
Allow
(
)
)
.
Else
(
SandboxPolicyCommon
:
:
EvaluateSyscall
(
sysno
)
)
;
}
CASES_FOR_fcntl
:
{
Arg
<
int
>
cmd
(
1
)
;
Arg
<
int
>
flags
(
2
)
;
static
const
int
ignored_flags
=
O_ACCMODE
|
O_LARGEFILE_REAL
|
O_CLOEXEC
;
static
const
int
allowed_flags
=
ignored_flags
|
O_APPEND
|
O_NONBLOCK
;
return
Switch
(
cmd
)
.
Case
(
F_GETFD
Allow
(
)
)
.
Case
(
F_SETFD
If
(
(
flags
&
~
FD_CLOEXEC
)
=
=
0
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
)
.
Case
(
F_GETFL
Allow
(
)
)
.
Case
(
F_SETFL
If
(
(
flags
&
~
allowed_flags
)
=
=
0
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
)
.
Case
(
F_DUPFD_CLOEXEC
Allow
(
)
)
.
Case
(
F_SETLK
Allow
(
)
)
#
ifdef
F_SETLK64
.
Case
(
F_SETLK64
Allow
(
)
)
#
endif
.
Case
(
F_SETLKW
Allow
(
)
)
#
ifdef
F_SETLKW64
.
Case
(
F_SETLKW64
Allow
(
)
)
#
endif
.
Default
(
SandboxPolicyCommon
:
:
EvaluateSyscall
(
sysno
)
)
;
}
case
__NR_brk
:
case
__NR_madvise
:
case
__NR_mremap
:
return
Allow
(
)
;
case
__NR_mincore
:
{
Arg
<
size_t
>
length
(
1
)
;
return
If
(
length
=
=
getpagesize
(
)
Allow
(
)
)
.
Else
(
SandboxPolicyCommon
:
:
EvaluateSyscall
(
sysno
)
)
;
}
case
__NR_sigaltstack
:
return
Allow
(
)
;
#
ifdef
__NR_set_thread_area
case
__NR_set_thread_area
:
return
Allow
(
)
;
#
endif
case
__NR_getrusage
:
case
__NR_times
:
return
Allow
(
)
;
case
__NR_dup2
:
return
Allow
(
)
;
CASES_FOR_getuid
:
CASES_FOR_getgid
:
CASES_FOR_geteuid
:
CASES_FOR_getegid
:
return
Allow
(
)
;
case
__NR_fsync
:
case
__NR_msync
:
return
Allow
(
)
;
case
__NR_getpriority
:
case
__NR_setpriority
:
case
__NR_sched_get_priority_min
:
case
__NR_sched_get_priority_max
:
case
__NR_sched_getscheduler
:
case
__NR_sched_setscheduler
:
case
__NR_sched_getparam
:
case
__NR_sched_setparam
:
#
ifdef
DESKTOP
case
__NR_sched_getaffinity
:
#
endif
return
Allow
(
)
;
#
ifdef
DESKTOP
case
__NR_sched_setaffinity
:
return
Error
(
EPERM
)
;
#
endif
#
ifdef
DESKTOP
case
__NR_pipe2
:
return
Allow
(
)
;
CASES_FOR_getrlimit
:
case
__NR_clock_getres
:
CASES_FOR_getresuid
:
CASES_FOR_getresgid
:
return
Allow
(
)
;
case
__NR_prlimit64
:
{
Arg
<
pid_t
>
pid
(
0
)
;
Arg
<
uintptr_t
>
new_limit
(
2
)
;
return
If
(
AllOf
(
pid
=
=
0
new_limit
=
=
0
)
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
case
__NR_umask
:
return
AllowBelowLevel
(
4
)
;
case
__NR_kill
:
{
if
(
BelowLevel
(
4
)
)
{
Arg
<
int
>
sig
(
1
)
;
return
If
(
sig
=
=
0
Error
(
EPERM
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
return
InvalidSyscall
(
)
;
}
case
__NR_wait4
:
#
ifdef
__NR_waitpid
case
__NR_waitpid
:
#
endif
return
Error
(
ECHILD
)
;
case
__NR_eventfd2
:
return
Allow
(
)
;
#
ifdef
__NR_memfd_create
case
__NR_memfd_create
:
return
Allow
(
)
;
#
endif
#
ifdef
__NR_rt_tgsigqueueinfo
case
__NR_rt_tgsigqueueinfo
:
{
Arg
<
pid_t
>
tgid
(
0
)
;
return
If
(
tgid
=
=
getpid
(
)
Allow
(
)
)
.
Else
(
InvalidSyscall
(
)
)
;
}
#
endif
case
__NR_mlock
:
case
__NR_munlock
:
return
Allow
(
)
;
case
__NR_clone
:
return
ClonePolicy
(
Error
(
EPERM
)
)
;
#
ifdef
__NR_fadvise64
case
__NR_fadvise64
:
return
Allow
(
)
;
#
endif
#
ifdef
__NR_fadvise64_64
case
__NR_fadvise64_64
:
return
Allow
(
)
;
#
endif
case
__NR_fallocate
:
return
Allow
(
)
;
case
__NR_get_mempolicy
:
return
Allow
(
)
;
#
endif
case
__NR_uname
:
#
ifdef
DESKTOP
case
__NR_sysinfo
:
#
endif
return
Allow
(
)
;
#
ifdef
MOZ_JPROF
case
__NR_setitimer
:
return
Allow
(
)
;
#
endif
default
:
return
SandboxPolicyCommon
:
:
EvaluateSyscall
(
sysno
)
;
}
}
}
;
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
GetContentSandboxPolicy
(
SandboxBrokerClient
*
aMaybeBroker
ContentProcessSandboxParams
&
&
aParams
)
{
return
MakeUnique
<
ContentSandboxPolicy
>
(
aMaybeBroker
std
:
:
move
(
aParams
)
)
;
}
class
GMPSandboxPolicy
:
public
SandboxPolicyCommon
{
static
intptr_t
OpenTrap
(
const
sandbox
:
:
arch_seccomp_data
&
aArgs
void
*
aux
)
{
const
auto
files
=
static_cast
<
const
SandboxOpenedFiles
*
>
(
aux
)
;
const
char
*
path
;
int
flags
;
switch
(
aArgs
.
nr
)
{
#
ifdef
__NR_open
case
__NR_open
:
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
0
]
)
;
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
break
;
#
endif
case
__NR_openat
:
path
=
reinterpret_cast
<
const
char
*
>
(
aArgs
.
args
[
1
]
)
;
flags
=
static_cast
<
int
>
(
aArgs
.
args
[
2
]
)
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
syscall
number
"
)
;
}
if
(
(
flags
&
O_ACCMODE
)
!
=
O_RDONLY
)
{
SANDBOX_LOG_ERROR
(
"
non
-
read
-
only
open
of
file
%
s
attempted
(
flags
=
0
%
o
)
"
path
flags
)
;
return
-
EROFS
;
}
int
fd
=
files
-
>
GetDesc
(
path
)
;
if
(
fd
<
0
)
{
return
-
ENOENT
;
}
return
fd
;
}
static
intptr_t
SchedTrap
(
ArgsRef
aArgs
void
*
aux
)
{
const
pid_t
tid
=
syscall
(
__NR_gettid
)
;
if
(
aArgs
.
args
[
0
]
=
=
static_cast
<
uint64_t
>
(
tid
)
)
{
return
DoSyscall
(
aArgs
.
nr
0
static_cast
<
uintptr_t
>
(
aArgs
.
args
[
1
]
)
static_cast
<
uintptr_t
>
(
aArgs
.
args
[
2
]
)
static_cast
<
uintptr_t
>
(
aArgs
.
args
[
3
]
)
static_cast
<
uintptr_t
>
(
aArgs
.
args
[
4
]
)
static_cast
<
uintptr_t
>
(
aArgs
.
args
[
5
]
)
)
;
}
SANDBOX_LOG_ERROR
(
"
unsupported
tid
in
SchedTrap
"
)
;
return
BlockedSyscallTrap
(
aArgs
nullptr
)
;
}
static
intptr_t
UnameTrap
(
const
sandbox
:
:
arch_seccomp_data
&
aArgs
void
*
aux
)
{
const
auto
buf
=
reinterpret_cast
<
struct
utsname
*
>
(
aArgs
.
args
[
0
]
)
;
PodZero
(
buf
)
;
strcpy
(
buf
-
>
sysname
"
Linux
"
)
;
strcpy
(
buf
-
>
version
"
3
"
)
;
return
0
;
}
;
static
intptr_t
FcntlTrap
(
const
sandbox
:
:
arch_seccomp_data
&
aArgs
void
*
aux
)
{
const
auto
cmd
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
switch
(
cmd
)
{
case
F_GETFD
:
return
O_CLOEXEC
;
case
F_SETFD
:
return
0
;
default
:
return
-
ENOSYS
;
}
}
const
SandboxOpenedFiles
*
mFiles
;
public
:
explicit
GMPSandboxPolicy
(
const
SandboxOpenedFiles
*
aFiles
)
:
mFiles
(
aFiles
)
{
}
~
GMPSandboxPolicy
(
)
override
=
default
;
ResultExpr
EvaluateSyscall
(
int
sysno
)
const
override
{
switch
(
sysno
)
{
#
ifdef
__NR_open
case
__NR_open
:
#
endif
case
__NR_openat
:
return
Trap
(
OpenTrap
mFiles
)
;
case
__NR_brk
:
CASES_FOR_getuid
:
CASES_FOR_getgid
:
CASES_FOR_geteuid
:
CASES_FOR_getegid
:
return
Allow
(
)
;
case
__NR_sched_get_priority_min
:
case
__NR_sched_get_priority_max
:
return
Allow
(
)
;
case
__NR_sched_getparam
:
case
__NR_sched_getscheduler
:
case
__NR_sched_setscheduler
:
{
Arg
<
pid_t
>
pid
(
0
)
;
return
If
(
pid
=
=
0
Allow
(
)
)
.
Else
(
Trap
(
SchedTrap
nullptr
)
)
;
}
case
__NR_times
:
return
Allow
(
)
;
case
__NR_uname
:
return
Trap
(
UnameTrap
nullptr
)
;
CASES_FOR_fcntl
:
return
Trap
(
FcntlTrap
nullptr
)
;
default
:
return
SandboxPolicyCommon
:
:
EvaluateSyscall
(
sysno
)
;
}
}
}
;
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
GetMediaSandboxPolicy
(
const
SandboxOpenedFiles
*
aFiles
)
{
return
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
(
new
GMPSandboxPolicy
(
aFiles
)
)
;
}
class
RDDSandboxPolicy
final
:
public
SandboxPolicyCommon
{
public
:
explicit
RDDSandboxPolicy
(
SandboxBrokerClient
*
aBroker
)
:
SandboxPolicyCommon
(
aBroker
)
{
}
static
intptr_t
FcntlTrap
(
const
sandbox
:
:
arch_seccomp_data
&
aArgs
void
*
aux
)
{
const
auto
cmd
=
static_cast
<
int
>
(
aArgs
.
args
[
1
]
)
;
switch
(
cmd
)
{
case
F_GETFD
:
return
O_CLOEXEC
;
case
F_SETFD
:
return
0
;
default
:
return
-
ENOSYS
;
}
}
ResultExpr
EvaluateSyscall
(
int
sysno
)
const
override
{
switch
(
sysno
)
{
case
__NR_getrusage
:
return
Allow
(
)
;
CASES_FOR_fcntl
:
return
Trap
(
FcntlTrap
nullptr
)
;
default
:
return
SandboxPolicyCommon
:
:
EvaluateSyscall
(
sysno
)
;
}
}
}
;
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
GetDecoderSandboxPolicy
(
SandboxBrokerClient
*
aMaybeBroker
)
{
return
UniquePtr
<
sandbox
:
:
bpf_dsl
:
:
Policy
>
(
new
RDDSandboxPolicy
(
aMaybeBroker
)
)
;
}
}
