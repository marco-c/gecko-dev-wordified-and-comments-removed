#
include
"
SandboxInfo
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
"
LinuxSched
.
h
"
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
sys
/
prctl
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
include
"
base
/
posix
/
eintr_wrapper
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_seccomp
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
valgrind
.
h
>
#
endif
namespace
mozilla
{
static
bool
HasSeccompBPF
(
)
{
if
(
getenv
(
"
MOZ_FAKE_NO_SANDBOX
"
)
)
{
return
false
;
}
#
if
defined
(
MOZ_VALGRIND
)
if
(
RUNNING_ON_VALGRIND
)
{
return
false
;
}
#
endif
int
rv
=
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
nullptr
)
;
MOZ_DIAGNOSTIC_ASSERT
(
rv
=
=
-
1
"
prctl
(
PR_SET_SECCOMP
SECCOMP_MODE_FILTER
"
"
nullptr
)
didn
'
t
fail
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
errno
=
=
EFAULT
|
|
errno
=
=
EINVAL
)
;
return
rv
=
=
-
1
&
&
errno
=
=
EFAULT
;
}
static
bool
HasSeccompTSync
(
)
{
if
(
getenv
(
"
MOZ_FAKE_NO_SECCOMP_TSYNC
"
)
)
{
return
false
;
}
int
rv
=
syscall
(
__NR_seccomp
SECCOMP_SET_MODE_FILTER
SECCOMP_FILTER_FLAG_TSYNC
nullptr
)
;
MOZ_DIAGNOSTIC_ASSERT
(
rv
=
=
-
1
"
seccomp
(
.
.
.
SECCOMP_FILTER_FLAG_TSYNC
"
"
nullptr
)
didn
'
t
fail
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
errno
=
=
EFAULT
|
|
errno
=
=
EINVAL
|
|
errno
=
=
ENOSYS
)
;
return
rv
=
=
-
1
&
&
errno
=
=
EFAULT
;
}
static
bool
HasUserNamespaceSupport
(
)
{
static
const
char
*
const
paths
[
]
=
{
"
/
proc
/
self
/
ns
/
user
"
"
/
proc
/
self
/
ns
/
pid
"
"
/
proc
/
self
/
ns
/
net
"
"
/
proc
/
self
/
ns
/
ipc
"
}
;
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
paths
)
;
+
+
i
)
{
if
(
access
(
paths
[
i
]
F_OK
)
=
=
-
1
)
{
MOZ_ASSERT
(
errno
=
=
ENOENT
)
;
return
false
;
}
}
return
true
;
}
static
bool
CanCreateUserNamespace
(
)
{
static
const
char
kCacheEnvName
[
]
=
"
MOZ_ASSUME_USER_NS
"
;
const
char
*
cached
=
getenv
(
kCacheEnvName
)
;
if
(
cached
)
{
return
cached
[
0
]
>
'
0
'
;
}
pid_t
pid
=
syscall
(
__NR_clone
SIGCHLD
|
CLONE_NEWUSER
nullptr
nullptr
nullptr
nullptr
)
;
if
(
pid
=
=
0
)
{
int
rv
=
unshare
(
CLONE_NEWPID
)
;
_exit
(
rv
=
=
0
?
0
:
1
)
;
}
if
(
pid
=
=
-
1
)
{
MOZ_ASSERT
(
errno
=
=
EINVAL
|
|
errno
=
=
EPERM
|
|
errno
=
=
EUSERS
)
;
setenv
(
kCacheEnvName
"
0
"
1
)
;
return
false
;
}
int
wstatus
;
bool
waitpid_ok
=
HANDLE_EINTR
(
waitpid
(
pid
&
wstatus
0
)
)
=
=
pid
;
MOZ_ASSERT
(
waitpid_ok
)
;
if
(
!
waitpid_ok
)
{
return
false
;
}
if
(
!
WIFEXITED
(
wstatus
)
|
|
WEXITSTATUS
(
wstatus
)
!
=
0
)
{
setenv
(
kCacheEnvName
"
0
"
1
)
;
return
false
;
}
setenv
(
kCacheEnvName
"
1
"
1
)
;
return
true
;
}
MOZ_RUNINIT
const
SandboxInfo
SandboxInfo
:
:
sSingleton
=
SandboxInfo
(
)
;
SandboxInfo
:
:
SandboxInfo
(
)
{
int
flags
=
0
;
static_assert
(
sizeof
(
flags
)
>
=
sizeof
(
Flags
)
"
enum
Flags
fits
in
an
int
"
)
;
if
(
HasSeccompBPF
(
)
)
{
flags
|
=
kHasSeccompBPF
;
if
(
HasSeccompTSync
(
)
)
{
flags
|
=
kHasSeccompTSync
;
}
}
if
(
HasUserNamespaceSupport
(
)
)
{
flags
|
=
kHasPrivilegedUserNamespaces
;
if
(
CanCreateUserNamespace
(
)
)
{
flags
|
=
kHasUserNamespaces
;
}
}
if
(
!
getenv
(
"
MOZ_DISABLE_CONTENT_SANDBOX
"
)
)
{
flags
|
=
kEnabledForContent
;
}
if
(
getenv
(
"
MOZ_PERMISSIVE_CONTENT_SANDBOX
"
)
)
{
flags
|
=
kPermissive
;
}
if
(
!
getenv
(
"
MOZ_DISABLE_GMP_SANDBOX
"
)
)
{
flags
|
=
kEnabledForMedia
;
}
if
(
getenv
(
"
MOZ_SANDBOX_LOGGING
"
)
)
{
flags
|
=
kVerbose
;
}
if
(
getenv
(
"
MOZ_SANDBOX_LOGGING_FOR_TESTS
"
)
)
{
flags
|
=
kVerboseTests
;
}
mFlags
=
static_cast
<
Flags
>
(
flags
)
;
}
}
