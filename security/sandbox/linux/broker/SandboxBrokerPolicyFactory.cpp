#
include
"
SandboxBrokerPolicyFactory
.
h
"
#
include
"
SandboxInfo
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
"
base
/
shared_memory
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SandboxLaunch
.
h
"
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
SpecialSystemDirectory
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsILineInputStream
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
prenv
.
h
"
#
ifdef
ANDROID
#
include
"
cutils
/
properties
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GTK
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
include
<
glib
.
h
>
#
endif
#
ifdef
MOZ_ENABLE_V4L2
#
include
<
linux
/
videodev2
.
h
>
#
include
<
sys
/
ioctl
.
h
>
#
include
<
fcntl
.
h
>
#
endif
#
include
<
dirent
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
sysmacros
.
h
>
#
include
<
sys
/
types
.
h
>
#
ifndef
ANDROID
#
include
<
glob
.
h
>
#
endif
namespace
mozilla
{
namespace
{
static
const
int
rdonly
=
SandboxBroker
:
:
MAY_READ
;
static
const
int
wronly
=
SandboxBroker
:
:
MAY_WRITE
;
static
const
int
rdwr
=
rdonly
|
wronly
;
static
const
int
rdwrcr
=
rdwr
|
SandboxBroker
:
:
MAY_CREATE
;
static
const
int
access
=
SandboxBroker
:
:
MAY_ACCESS
;
static
const
int
deny
=
SandboxBroker
:
:
FORCE_DENY
;
}
using
CacheE
=
std
:
:
pair
<
nsCString
int
>
;
using
FileCacheT
=
nsTArray
<
CacheE
>
;
static
void
AddDriPaths
(
SandboxBroker
:
:
Policy
*
aPolicy
)
{
if
(
auto
dir
=
opendir
(
"
/
dev
/
dri
"
)
)
{
while
(
auto
entry
=
readdir
(
dir
)
)
{
if
(
entry
-
>
d_name
[
0
]
!
=
'
.
'
)
{
nsPrintfCString
devPath
(
"
/
dev
/
dri
/
%
s
"
entry
-
>
d_name
)
;
struct
stat
sb
;
if
(
stat
(
devPath
.
get
(
)
&
sb
)
=
=
0
&
&
S_ISCHR
(
sb
.
st_mode
)
)
{
static
const
Array
<
nsCString
2
>
kSuffixes
=
{
"
"
_ns
"
/
device
"
_ns
}
;
nsPrintfCString
prefix
(
"
/
sys
/
dev
/
char
/
%
u
:
%
u
"
major
(
sb
.
st_rdev
)
minor
(
sb
.
st_rdev
)
)
;
for
(
const
auto
&
suffix
:
kSuffixes
)
{
nsCString
sysPath
(
prefix
+
suffix
)
;
UniqueFreePtr
<
char
[
]
>
realSysPath
(
realpath
(
sysPath
.
get
(
)
nullptr
)
)
;
if
(
realSysPath
)
{
char
*
term
=
strrchr
(
realSysPath
.
get
(
)
'
/
'
)
;
if
(
term
&
&
strncmp
(
term
"
/
virtio
"
7
)
=
=
0
)
{
*
term
=
0
;
}
aPolicy
-
>
AddFilePrefix
(
rdonly
realSysPath
.
get
(
)
"
"
)
;
nsPrintfCString
basePath
(
"
%
s
/
"
realSysPath
.
get
(
)
)
;
aPolicy
-
>
AddAncestors
(
basePath
.
get
(
)
rdonly
)
;
}
}
nsCString
subsystemPath
(
prefix
+
"
/
device
/
subsystem
"
_ns
)
;
aPolicy
-
>
AddPath
(
rdonly
subsystemPath
.
get
(
)
)
;
aPolicy
-
>
AddAncestors
(
subsystemPath
.
get
(
)
rdonly
)
;
}
}
}
closedir
(
dir
)
;
}
aPolicy
-
>
AddPath
(
rdonly
"
/
usr
/
share
/
drirc
.
d
"
)
;
aPolicy
-
>
AddPath
(
rdonly
"
/
etc
/
drirc
"
)
;
nsCOMPtr
<
nsIFile
>
drirc
;
nsresult
rv
=
GetSpecialSystemDirectory
(
Unix_HomeDirectory
getter_AddRefs
(
drirc
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
drirc
-
>
AppendNative
(
"
.
drirc
"
_ns
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
drirc
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aPolicy
-
>
AddPath
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
}
static
void
JoinPathIfRelative
(
const
nsACString
&
aCwd
const
nsACString
&
inPath
nsACString
&
outPath
)
{
if
(
inPath
.
Length
(
)
<
1
)
{
outPath
.
Assign
(
aCwd
)
;
SANDBOX_LOG
(
"
Unjoinable
path
:
%
s
"
PromiseFlatCString
(
aCwd
)
.
get
(
)
)
;
return
;
}
const
char
*
startChar
=
inPath
.
BeginReading
(
)
;
if
(
*
startChar
!
=
'
/
'
)
{
outPath
.
Assign
(
aCwd
)
;
outPath
.
Append
(
"
/
"
)
;
outPath
.
Append
(
inPath
)
;
}
else
{
outPath
.
Assign
(
inPath
)
;
}
}
static
void
CachePathsFromFile
(
FileCacheT
&
aCache
const
nsACString
&
aPath
)
;
static
void
CachePathsFromFileInternal
(
FileCacheT
&
aCache
const
nsACString
&
aCwd
const
nsACString
&
aPath
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
ldconfig
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
ldconfig
-
>
InitWithNativePath
(
aPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsCOMPtr
<
nsIFileInputStream
>
fileStream
(
do_CreateInstance
(
NS_LOCALFILEINPUTSTREAM_CONTRACTID
&
rv
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
rv
=
fileStream
-
>
Init
(
ldconfig
-
1
-
1
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsCOMPtr
<
nsILineInputStream
>
lineStream
(
do_QueryInterface
(
fileStream
&
rv
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsAutoCString
line
;
bool
more
=
true
;
do
{
rv
=
lineStream
-
>
ReadLine
(
line
&
more
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
int32_t
hash
=
line
.
FindChar
(
'
#
'
)
;
if
(
hash
>
=
0
)
{
line
=
Substring
(
line
0
hash
)
;
}
line
.
CompressWhitespace
(
true
true
)
;
if
(
line
.
IsEmpty
(
)
)
{
continue
;
}
nsACString
:
:
const_iterator
start
end
token_end
;
line
.
BeginReading
(
start
)
;
line
.
EndReading
(
end
)
;
token_end
=
end
;
if
(
FindInReadable
(
"
include
"
_ns
start
token_end
)
)
{
nsAutoCString
includes
(
Substring
(
token_end
end
)
)
;
for
(
const
nsACString
&
includeGlob
:
includes
.
Split
(
'
'
)
)
{
nsAutoCString
includeFile
;
JoinPathIfRelative
(
aCwd
includeGlob
includeFile
)
;
glob_t
globbuf
;
if
(
!
glob
(
PromiseFlatCString
(
includeFile
)
.
get
(
)
GLOB_NOSORT
nullptr
&
globbuf
)
)
{
for
(
size_t
fileIdx
=
0
;
fileIdx
<
globbuf
.
gl_pathc
;
fileIdx
+
+
)
{
nsAutoCString
filePath
(
globbuf
.
gl_pathv
[
fileIdx
]
)
;
CachePathsFromFile
(
aCache
filePath
)
;
}
globfree
(
&
globbuf
)
;
}
}
}
int32_t
equals
=
line
.
FindChar
(
'
=
'
)
;
if
(
equals
>
=
0
)
{
line
=
Substring
(
line
0
equals
)
;
}
char
*
resolvedPath
=
realpath
(
line
.
get
(
)
nullptr
)
;
if
(
resolvedPath
)
{
aCache
.
AppendElement
(
std
:
:
make_pair
(
nsCString
(
resolvedPath
)
rdonly
)
)
;
free
(
resolvedPath
)
;
}
}
while
(
more
)
;
}
static
void
CachePathsFromFile
(
FileCacheT
&
aCache
const
nsACString
&
aPath
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
includeFile
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
includeFile
-
>
InitWithNativePath
(
aPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG
(
"
Adding
paths
from
%
s
to
policy
.
"
PromiseFlatCString
(
aPath
)
.
get
(
)
)
;
}
nsCOMPtr
<
nsIFile
>
parentDir
;
rv
=
includeFile
-
>
GetParent
(
getter_AddRefs
(
parentDir
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsAutoCString
parentPath
;
rv
=
parentDir
-
>
GetNativePath
(
parentPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
SandboxInfo
:
:
Get
(
)
.
Test
(
SandboxInfo
:
:
kVerbose
)
)
{
SANDBOX_LOG
(
"
Parent
path
is
%
s
"
PromiseFlatCString
(
parentPath
)
.
get
(
)
)
;
}
CachePathsFromFileInternal
(
aCache
parentPath
aPath
)
;
}
static
void
AddLdconfigPaths
(
SandboxBroker
:
:
Policy
*
aPolicy
)
{
static
StaticMutex
sMutex
;
StaticMutexAutoLock
lock
(
sMutex
)
;
static
FileCacheT
ldConfigCache
{
}
;
static
bool
ldConfigCachePopulated
=
false
;
if
(
!
ldConfigCachePopulated
)
{
CachePathsFromFile
(
ldConfigCache
"
/
etc
/
ld
.
so
.
conf
"
_ns
)
;
ldConfigCachePopulated
=
true
;
RunOnShutdown
(
[
&
]
{
ldConfigCache
.
Clear
(
)
;
MOZ_ASSERT
(
ldConfigCache
.
IsEmpty
(
)
"
ldconfig
cache
should
be
empty
"
)
;
}
)
;
}
for
(
const
CacheE
&
e
:
ldConfigCache
)
{
aPolicy
-
>
AddDir
(
e
.
second
e
.
first
.
get
(
)
)
;
}
}
static
void
AddLdLibraryEnvPaths
(
SandboxBroker
:
:
Policy
*
aPolicy
)
{
nsAutoCString
LdLibraryEnv
(
PR_GetEnv
(
"
LD_LIBRARY_PATH
"
)
)
;
LdLibraryEnv
.
ReplaceChar
(
'
;
'
'
:
'
)
;
for
(
const
nsACString
&
libPath
:
LdLibraryEnv
.
Split
(
'
:
'
)
)
{
char
*
resolvedPath
=
realpath
(
PromiseFlatCString
(
libPath
)
.
get
(
)
nullptr
)
;
if
(
resolvedPath
)
{
aPolicy
-
>
AddDir
(
rdonly
resolvedPath
)
;
free
(
resolvedPath
)
;
}
}
}
static
void
AddSharedMemoryPaths
(
SandboxBroker
:
:
Policy
*
aPolicy
pid_t
aPid
)
{
std
:
:
string
shmPath
(
"
/
dev
/
shm
"
)
;
if
(
base
:
:
SharedMemory
:
:
AppendPosixShmPrefix
(
&
shmPath
aPid
)
)
{
aPolicy
-
>
AddPrefix
(
rdwrcr
shmPath
.
c_str
(
)
)
;
}
}
static
void
AddMemoryReporting
(
SandboxBroker
:
:
Policy
*
aPolicy
pid_t
aPid
)
{
aPolicy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
statm
"
aPid
)
.
get
(
)
)
;
aPolicy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
smaps
"
aPid
)
.
get
(
)
)
;
}
static
void
AddDynamicPathList
(
SandboxBroker
:
:
Policy
*
policy
const
char
*
aPathListPref
int
perms
)
{
nsAutoCString
pathList
;
nsresult
rv
=
Preferences
:
:
GetCString
(
aPathListPref
pathList
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
const
nsACString
&
path
:
pathList
.
Split
(
'
'
)
)
{
nsCString
trimPath
(
path
)
;
trimPath
.
Trim
(
"
"
true
true
)
;
policy
-
>
AddDynamic
(
perms
trimPath
.
get
(
)
)
;
}
}
}
static
void
AddX11Dependencies
(
SandboxBroker
:
:
Policy
*
policy
)
{
const
char
*
bumblebeeSocket
=
PR_GetEnv
(
"
BUMBLEBEE_SOCKET
"
)
;
if
(
bumblebeeSocket
=
=
nullptr
)
{
bumblebeeSocket
=
"
/
var
/
run
/
bumblebee
.
socket
"
;
}
policy
-
>
AddPath
(
SandboxBroker
:
:
MAY_CONNECT
bumblebeeSocket
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
&
&
defined
(
MOZ_X11
)
static
const
bool
kIsX11
=
!
mozilla
:
:
widget
:
:
GdkIsWaylandDisplay
(
)
&
&
PR_GetEnv
(
"
DISPLAY
"
)
;
if
(
kIsX11
)
{
policy
-
>
AddPrefix
(
SandboxBroker
:
:
MAY_CONNECT
"
/
tmp
/
.
X11
-
unix
/
X
"
)
;
if
(
auto
*
const
xauth
=
PR_GetEnv
(
"
XAUTHORITY
"
)
)
{
policy
-
>
AddPath
(
rdonly
xauth
)
;
}
else
if
(
auto
*
const
home
=
PR_GetEnv
(
"
HOME
"
)
)
{
nsAutoCString
xauth
(
home
)
;
if
(
xauth
!
=
"
/
"
_ns
)
{
xauth
.
Append
(
'
/
'
)
;
}
xauth
.
AppendLiteral
(
"
.
Xauthority
"
)
;
policy
-
>
AddPath
(
rdonly
xauth
.
get
(
)
)
;
}
}
#
endif
}
static
void
AddGLDependencies
(
SandboxBroker
:
:
Policy
*
policy
)
{
policy
-
>
AddDir
(
rdwr
"
/
dev
/
dri
"
)
;
policy
-
>
AddFilePrefix
(
rdwr
"
/
dev
"
"
nvidia
"
)
;
AddDriPaths
(
policy
)
;
policy
-
>
AddDir
(
rdonly
"
/
etc
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
local
/
share
"
)
;
if
(
const
char
*
snapDesktopDir
=
PR_GetEnv
(
"
SNAP_DESKTOP_RUNTIME
"
)
)
{
nsAutoCString
snapDesktopShare
(
snapDesktopDir
)
;
snapDesktopShare
.
AppendLiteral
(
"
/
usr
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
snapDesktopShare
.
get
(
)
)
;
}
}
void
SandboxBrokerPolicyFactory
:
:
InitContentPolicy
(
)
{
const
bool
headless
=
StaticPrefs
:
:
security_sandbox_content_headless_AtStartup
(
)
;
SandboxBroker
:
:
Policy
*
policy
=
new
SandboxBroker
:
:
Policy
;
policy
-
>
AddPath
(
rdwr
"
/
dev
/
null
"
)
;
if
(
!
headless
)
{
AddGLDependencies
(
policy
)
;
AddX11Dependencies
(
policy
)
;
}
policy
-
>
AddPath
(
rdonly
"
/
dev
/
urandom
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
dev
/
random
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
cpuinfo
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
meminfo
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
system
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib32
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
etc
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
local
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
X11R6
/
lib
/
X11
/
fonts
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
nix
/
store
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
run
/
host
/
fonts
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
run
/
host
/
user
-
fonts
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
run
/
host
/
local
-
fonts
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
var
/
cache
/
fontconfig
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
usr
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
nix
"
)
;
AddLdconfigPaths
(
policy
)
;
AddLdLibraryEnvPaths
(
policy
)
;
if
(
!
headless
)
{
policy
-
>
AddPath
(
rdonly
"
/
proc
/
modules
"
)
;
}
nsAutoCString
xdgConfigHome
(
PR_GetEnv
(
"
XDG_CONFIG_HOME
"
)
)
;
if
(
!
xdgConfigHome
.
IsEmpty
(
)
)
{
policy
-
>
AddFutureDir
(
rdonly
xdgConfigHome
.
get
(
)
)
;
}
nsAutoCString
xdgConfigDirs
(
PR_GetEnv
(
"
XDG_CONFIG_DIRS
"
)
)
;
for
(
const
auto
&
path
:
xdgConfigDirs
.
Split
(
'
:
'
)
)
{
if
(
!
path
.
IsEmpty
(
)
)
{
policy
-
>
AddFutureDir
(
rdonly
PromiseFlatCString
(
path
)
.
get
(
)
)
;
}
}
nsAutoCString
xdgDataHome
(
PR_GetEnv
(
"
XDG_DATA_HOME
"
)
)
;
if
(
!
xdgDataHome
.
IsEmpty
(
)
)
{
nsAutoCString
fontPath
(
xdgDataHome
)
;
fontPath
.
Append
(
"
/
fonts
"
)
;
policy
-
>
AddFutureDir
(
rdonly
PromiseFlatCString
(
fontPath
)
.
get
(
)
)
;
}
nsAutoCString
xdgDataDirs
(
PR_GetEnv
(
"
XDG_DATA_DIRS
"
)
)
;
for
(
const
auto
&
path
:
xdgDataDirs
.
Split
(
'
:
'
)
)
{
nsAutoCString
fontPath
(
path
)
;
fontPath
.
Append
(
"
/
fonts
"
)
;
policy
-
>
AddFutureDir
(
rdonly
PromiseFlatCString
(
fontPath
)
.
get
(
)
)
;
}
std
:
:
vector
<
const
char
*
>
extraConfDirsAllow
=
{
"
.
themes
"
"
.
fonts
"
"
.
cache
/
fontconfig
"
}
;
if
(
xdgConfigHome
.
IsEmpty
(
)
)
{
extraConfDirsAllow
.
emplace_back
(
"
.
config
"
)
;
}
nsCOMPtr
<
nsIFile
>
homeDir
;
nsresult
rv
=
GetSpecialSystemDirectory
(
Unix_HomeDirectory
getter_AddRefs
(
homeDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
confDir
;
for
(
const
auto
&
dir
:
extraConfDirsAllow
)
{
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendRelativeNativePath
(
nsDependentCString
(
dir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
}
{
nsCOMPtr
<
nsIFile
>
confDirOrXDGConfigHomeDir
;
if
(
!
xdgConfigHome
.
IsEmpty
(
)
)
{
rv
=
NS_NewNativeLocalFile
(
xdgConfigHome
true
getter_AddRefs
(
confDirOrXDGConfigHomeDir
)
)
;
}
else
{
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDirOrXDGConfigHomeDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDirOrXDGConfigHomeDir
-
>
AppendNative
(
"
.
config
"
_ns
)
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDirOrXDGConfigHomeDir
-
>
AppendNative
(
"
mozilla
"
_ns
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDirOrXDGConfigHomeDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddFutureDir
(
deny
tmpPath
.
get
(
)
)
;
}
}
}
}
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
"
.
local
"
_ns
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
"
share
"
_ns
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
"
.
fonts
.
conf
"
_ns
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddPath
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
"
.
pangorc
"
_ns
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddPath
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
}
nsCOMPtr
<
nsIFile
>
ffDir
;
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
ffDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
ffDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
if
(
!
mozilla
:
:
IsPackagedBuild
(
)
)
{
const
char
*
developer_repo_dir
=
PR_GetEnv
(
"
MOZ_DEVELOPER_REPO_DIR
"
)
;
if
(
developer_repo_dir
)
{
policy
-
>
AddDir
(
rdonly
developer_repo_dir
)
;
}
}
#
ifdef
DEBUG
char
*
bloatLog
=
PR_GetEnv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
;
if
(
bloatLog
!
=
nullptr
)
{
size_t
bloatLen
=
strlen
(
bloatLog
)
;
if
(
bloatLen
>
=
4
)
{
nsAutoCString
bloatStr
(
bloatLog
)
;
bloatStr
.
Truncate
(
bloatLen
-
4
)
;
policy
-
>
AddPrefix
(
rdwrcr
bloatStr
.
get
(
)
)
;
}
}
#
endif
if
(
!
headless
)
{
AddX11Dependencies
(
policy
)
;
}
const
char
*
snap
=
PR_GetEnv
(
"
SNAP
"
)
;
if
(
snap
)
{
policy
-
>
AddDir
(
rdonly
snap
)
;
}
AddDynamicPathList
(
policy
"
security
.
sandbox
.
content
.
write_path_whitelist
"
rdwr
)
;
AddDynamicPathList
(
policy
"
security
.
sandbox
.
content
.
read_path_whitelist
"
rdonly
)
;
nsCOMPtr
<
nsIFile
>
profileDir
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profileDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
workDir
;
rv
=
profileDir
-
>
Clone
(
getter_AddRefs
(
workDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
workDir
-
>
AppendNative
(
"
chrome
"
_ns
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
workDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
rv
=
profileDir
-
>
Clone
(
getter_AddRefs
(
workDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
workDir
-
>
AppendNative
(
"
extensions
"
_ns
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
workDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
exists
;
rv
=
workDir
-
>
Exists
(
&
exists
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
!
exists
)
{
policy
-
>
AddPrefix
(
rdonly
tmpPath
.
get
(
)
)
;
policy
-
>
AddPath
(
rdonly
tmpPath
.
get
(
)
)
;
}
else
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
}
}
}
const
int
level
=
GetEffectiveContentSandboxLevel
(
)
;
bool
allowPulse
=
false
;
bool
allowAlsa
=
false
;
if
(
level
<
4
)
{
#
ifdef
MOZ_PULSEAUDIO
allowPulse
=
true
;
#
endif
#
ifdef
MOZ_ALSA
allowAlsa
=
true
;
#
endif
}
if
(
allowAlsa
)
{
policy
-
>
AddDir
(
rdwr
"
/
dev
/
snd
"
)
;
}
if
(
allowPulse
)
{
policy
-
>
AddDir
(
rdwrcr
"
/
dev
/
shm
"
)
;
}
#
ifdef
MOZ_WIDGET_GTK
if
(
const
auto
userDir
=
g_get_user_runtime_dir
(
)
)
{
nsPrintfCString
shmPath
(
"
%
s
/
dconf
/
"
userDir
)
;
policy
-
>
AddPrefix
(
rdwrcr
shmPath
.
get
(
)
)
;
policy
-
>
AddAncestors
(
shmPath
.
get
(
)
)
;
if
(
allowPulse
)
{
nsPrintfCString
pulsePath
(
"
%
s
/
pulse
"
userDir
)
;
policy
-
>
AddPath
(
rdonly
pulsePath
.
get
(
)
)
;
}
}
#
endif
if
(
allowPulse
)
{
policy
-
>
AddPath
(
rdonly
"
/
var
/
lib
/
dbus
/
machine
-
id
"
)
;
}
if
(
!
headless
&
&
HasAtiDrivers
(
)
)
{
policy
-
>
AddDir
(
rdonly
"
/
opt
/
amdgpu
/
share
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
sys
/
module
/
amdgpu
"
)
;
}
mCommonContentPolicy
.
reset
(
policy
)
;
}
UniquePtr
<
SandboxBroker
:
:
Policy
>
SandboxBrokerPolicyFactory
:
:
GetContentPolicy
(
int
aPid
bool
aFileProcess
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
int
level
=
GetEffectiveContentSandboxLevel
(
)
;
if
(
level
<
=
1
)
{
MOZ_ASSERT
(
level
=
=
0
)
;
return
nullptr
;
}
std
:
:
call_once
(
mContentInited
[
this
]
{
InitContentPolicy
(
)
;
}
)
;
MOZ_ASSERT
(
mCommonContentPolicy
)
;
UniquePtr
<
SandboxBroker
:
:
Policy
>
policy
(
new
SandboxBroker
:
:
Policy
(
*
mCommonContentPolicy
)
)
;
if
(
level
<
=
2
|
|
aFileProcess
)
{
policy
-
>
AddDir
(
rdonly
"
/
"
)
;
}
AddSharedMemoryPaths
(
policy
.
get
(
)
aPid
)
;
policy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
maps
"
aPid
)
.
get
(
)
)
;
policy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
stat
"
aPid
)
.
get
(
)
)
;
AddMemoryReporting
(
policy
.
get
(
)
aPid
)
;
policy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
status
"
aPid
)
.
get
(
)
)
;
policy
-
>
FixRecursivePermissions
(
)
;
return
policy
;
}
#
ifdef
MOZ_ENABLE_V4L2
static
void
AddV4l2Dependencies
(
SandboxBroker
:
:
Policy
*
policy
)
{
DIR
*
dir
=
opendir
(
"
/
dev
"
)
;
if
(
!
dir
)
{
SANDBOX_LOG
(
"
Couldn
'
t
list
/
dev
"
)
;
return
;
}
struct
dirent
*
dir_entry
;
while
(
(
dir_entry
=
readdir
(
dir
)
)
)
{
if
(
strncmp
(
dir_entry
-
>
d_name
"
video
"
5
)
)
{
continue
;
}
nsCString
path
=
"
/
dev
/
"
_ns
;
path
+
=
nsDependentCString
(
dir_entry
-
>
d_name
)
;
int
fd
=
open
(
path
.
get
(
)
O_RDWR
|
O_NONBLOCK
0
)
;
if
(
fd
<
0
)
{
SANDBOX_LOG
(
"
Couldn
'
t
open
video
device
%
s
"
path
.
get
(
)
)
;
continue
;
}
struct
v4l2_capability
cap
;
int
result
=
ioctl
(
fd
VIDIOC_QUERYCAP
&
cap
)
;
if
(
result
<
0
)
{
SANDBOX_LOG
(
"
Couldn
'
t
query
capabilities
of
video
device
%
s
"
path
.
get
(
)
)
;
close
(
fd
)
;
continue
;
}
if
(
(
cap
.
device_caps
&
V4L2_CAP_VIDEO_M2M
)
|
|
(
cap
.
device_caps
&
V4L2_CAP_VIDEO_M2M_MPLANE
)
)
{
policy
-
>
AddPath
(
rdwr
path
.
get
(
)
)
;
}
close
(
fd
)
;
}
closedir
(
dir
)
;
policy
-
>
AddPath
(
rdonly
"
/
dev
"
)
;
}
#
endif
UniquePtr
<
SandboxBroker
:
:
Policy
>
SandboxBrokerPolicyFactory
:
:
GetRDDPolicy
(
int
aPid
)
{
auto
policy
=
MakeUnique
<
SandboxBroker
:
:
Policy
>
(
)
;
AddSharedMemoryPaths
(
policy
.
get
(
)
aPid
)
;
policy
-
>
AddPath
(
rdonly
"
/
dev
/
urandom
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
cpuinfo
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
sys
/
devices
/
system
/
cpu
/
cpu0
/
cpufreq
/
cpuinfo_max_freq
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
sys
/
devices
/
system
/
cpu
/
cpu0
/
cache
/
index2
/
size
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
sys
/
devices
/
system
/
cpu
/
cpu0
/
cache
/
index3
/
size
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
system
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
system
/
node
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib32
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
run
/
opengl
-
driver
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
nix
/
store
"
)
;
AddMemoryReporting
(
policy
.
get
(
)
aPid
)
;
nsCOMPtr
<
nsIFile
>
ffDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
ffDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
ffDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
if
(
!
mozilla
:
:
IsPackagedBuild
(
)
)
{
const
char
*
developer_repo_dir
=
PR_GetEnv
(
"
MOZ_DEVELOPER_REPO_DIR
"
)
;
if
(
developer_repo_dir
)
{
policy
-
>
AddDir
(
rdonly
developer_repo_dir
)
;
}
}
AddGLDependencies
(
policy
.
get
(
)
)
;
AddLdconfigPaths
(
policy
.
get
(
)
)
;
AddLdLibraryEnvPaths
(
policy
.
get
(
)
)
;
#
ifdef
MOZ_ENABLE_V4L2
AddV4l2Dependencies
(
policy
.
get
(
)
)
;
#
endif
#
if
defined
(
__aarch64__
)
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
system
/
present
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
module
/
tegra_fuse
"
)
;
policy
-
>
AddPath
(
rdwr
"
/
dev
/
nvmap
"
)
;
policy
-
>
AddPath
(
rdwr
"
/
dev
/
nvhost
-
ctrl
"
)
;
policy
-
>
AddPath
(
rdwr
"
/
dev
/
nvhost
-
ctrl
-
gpu
"
)
;
policy
-
>
AddPath
(
rdwr
"
/
dev
/
nvhost
-
nvdec
"
)
;
policy
-
>
AddPath
(
rdwr
"
/
dev
/
nvhost
-
nvdec1
"
)
;
policy
-
>
AddPath
(
rdwr
"
/
dev
/
nvhost
-
vic
"
)
;
#
endif
if
(
policy
-
>
IsEmpty
(
)
)
{
policy
=
nullptr
;
}
return
policy
;
}
UniquePtr
<
SandboxBroker
:
:
Policy
>
SandboxBrokerPolicyFactory
:
:
GetSocketProcessPolicy
(
int
aPid
)
{
auto
policy
=
MakeUnique
<
SandboxBroker
:
:
Policy
>
(
)
;
policy
-
>
AddPath
(
rdonly
"
/
dev
/
urandom
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
dev
/
random
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
cpuinfo
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
meminfo
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
system
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib32
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
local
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
etc
"
)
;
policy
-
>
AddDir
(
access
"
/
"
)
;
AddLdconfigPaths
(
policy
.
get
(
)
)
;
AddSharedMemoryPaths
(
policy
.
get
(
)
aPid
)
;
AddMemoryReporting
(
policy
.
get
(
)
aPid
)
;
nsCOMPtr
<
nsIFile
>
ffDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
ffDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
ffDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
if
(
policy
-
>
IsEmpty
(
)
)
{
policy
=
nullptr
;
}
return
policy
;
}
UniquePtr
<
SandboxBroker
:
:
Policy
>
SandboxBrokerPolicyFactory
:
:
GetUtilityProcessPolicy
(
int
aPid
)
{
auto
policy
=
MakeUnique
<
SandboxBroker
:
:
Policy
>
(
)
;
policy
-
>
AddPath
(
rdonly
"
/
dev
/
urandom
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
cpuinfo
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
meminfo
"
)
;
policy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
exe
"
aPid
)
.
get
(
)
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
system
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib32
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
local
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
etc
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
nix
/
store
"
)
;
policy
-
>
AddDir
(
access
"
/
"
)
;
AddLdconfigPaths
(
policy
.
get
(
)
)
;
AddLdLibraryEnvPaths
(
policy
.
get
(
)
)
;
AddSharedMemoryPaths
(
policy
.
get
(
)
aPid
)
;
AddMemoryReporting
(
policy
.
get
(
)
aPid
)
;
nsCOMPtr
<
nsIFile
>
ffDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
ffDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
ffDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
if
(
policy
-
>
IsEmpty
(
)
)
{
policy
=
nullptr
;
}
return
policy
;
}
}
