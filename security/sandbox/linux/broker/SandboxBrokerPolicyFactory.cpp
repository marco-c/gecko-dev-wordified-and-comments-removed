#
include
"
SandboxBrokerPolicyFactory
.
h
"
#
include
"
SandboxInfo
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
SandboxLaunch
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
SpecialSystemDirectory
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsILineInputStream
.
h
"
#
include
"
nsNetCID
.
h
"
#
ifdef
ANDROID
#
include
"
cutils
/
properties
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GTK
#
include
<
glib
.
h
>
#
endif
#
include
<
dirent
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
sysmacros
.
h
>
#
include
<
sys
/
types
.
h
>
#
ifndef
ANDROID
#
include
<
glob
.
h
>
#
endif
namespace
mozilla
{
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
namespace
{
static
const
int
rdonly
=
SandboxBroker
:
:
MAY_READ
;
static
const
int
wronly
=
SandboxBroker
:
:
MAY_WRITE
;
static
const
int
rdwr
=
rdonly
|
wronly
;
static
const
int
rdwrcr
=
rdwr
|
SandboxBroker
:
:
MAY_CREATE
;
static
const
int
access
=
SandboxBroker
:
:
MAY_ACCESS
;
}
#
endif
static
void
AddMesaSysfsPaths
(
SandboxBroker
:
:
Policy
*
aPolicy
)
{
aPolicy
-
>
AddPrefix
(
rdonly
"
/
sys
/
dev
/
char
/
226
:
"
)
;
if
(
auto
dir
=
opendir
(
"
/
dev
/
dri
"
)
)
{
while
(
auto
entry
=
readdir
(
dir
)
)
{
if
(
entry
-
>
d_name
[
0
]
!
=
'
.
'
)
{
nsPrintfCString
devPath
(
"
/
dev
/
dri
/
%
s
"
entry
-
>
d_name
)
;
struct
stat
sb
;
if
(
stat
(
devPath
.
get
(
)
&
sb
)
=
=
0
&
&
S_ISCHR
(
sb
.
st_mode
)
)
{
static
const
Array
<
const
char
*
2
>
kSuffixes
=
{
"
"
"
/
device
"
}
;
for
(
const
auto
suffix
:
kSuffixes
)
{
nsPrintfCString
sysPath
(
"
/
sys
/
dev
/
char
/
%
u
:
%
u
%
s
"
major
(
sb
.
st_rdev
)
minor
(
sb
.
st_rdev
)
suffix
)
;
UniqueFreePtr
<
char
[
]
>
realSysPath
(
realpath
(
sysPath
.
get
(
)
nullptr
)
)
;
if
(
realSysPath
)
{
nsPrintfCString
ueventPath
(
"
%
s
/
uevent
"
realSysPath
.
get
(
)
)
;
nsPrintfCString
configPath
(
"
%
s
/
config
"
realSysPath
.
get
(
)
)
;
aPolicy
-
>
AddPath
(
rdonly
ueventPath
.
get
(
)
)
;
aPolicy
-
>
AddPath
(
rdonly
configPath
.
get
(
)
)
;
}
}
}
}
}
closedir
(
dir
)
;
}
}
static
void
AddPathsFromFile
(
SandboxBroker
:
:
Policy
*
aPolicy
nsACString
&
aPath
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
ldconfig
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
ldconfig
-
>
InitWithNativePath
(
aPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIFileInputStream
>
fileStream
(
do_CreateInstance
(
NS_LOCALFILEINPUTSTREAM_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
fileStream
-
>
Init
(
ldconfig
-
1
-
1
0
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsILineInputStream
>
lineStream
(
do_QueryInterface
(
fileStream
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsAutoCString
line
;
bool
more
=
true
;
do
{
rv
=
lineStream
-
>
ReadLine
(
line
&
more
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
int32_t
hash
=
line
.
FindChar
(
'
#
'
)
;
if
(
hash
>
=
0
)
{
line
=
Substring
(
line
0
hash
)
;
}
line
.
CompressWhitespace
(
true
true
)
;
if
(
line
.
IsEmpty
(
)
)
{
continue
;
}
nsACString
:
:
const_iterator
start
end
token_end
;
line
.
BeginReading
(
start
)
;
line
.
EndReading
(
end
)
;
token_end
=
end
;
if
(
FindInReadable
(
NS_LITERAL_CSTRING
(
"
include
"
)
start
token_end
)
)
{
nsAutoCString
includes
(
Substring
(
token_end
end
)
)
;
for
(
const
nsACString
&
includeGlob
:
includes
.
Split
(
'
'
)
)
{
glob_t
globbuf
;
if
(
!
glob
(
PromiseFlatCString
(
includeGlob
)
.
get
(
)
GLOB_NOSORT
nullptr
&
globbuf
)
)
{
for
(
size_t
fileIdx
=
0
;
fileIdx
<
globbuf
.
gl_pathc
;
fileIdx
+
+
)
{
nsAutoCString
filePath
(
globbuf
.
gl_pathv
[
fileIdx
]
)
;
AddPathsFromFile
(
aPolicy
filePath
)
;
}
globfree
(
&
globbuf
)
;
}
}
}
if
(
line
.
First
(
)
!
=
'
/
'
)
{
continue
;
}
int32_t
equals
=
line
.
FindChar
(
'
=
'
)
;
if
(
equals
>
=
0
)
{
line
=
Substring
(
line
0
equals
)
;
}
char
*
resolvedPath
=
realpath
(
line
.
get
(
)
nullptr
)
;
if
(
resolvedPath
)
{
aPolicy
-
>
AddDir
(
rdonly
resolvedPath
)
;
free
(
resolvedPath
)
;
}
}
while
(
more
)
;
}
static
void
AddLdconfigPaths
(
SandboxBroker
:
:
Policy
*
aPolicy
)
{
nsAutoCString
ldconfigPath
(
NS_LITERAL_CSTRING
(
"
/
etc
/
ld
.
so
.
conf
"
)
)
;
AddPathsFromFile
(
aPolicy
ldconfigPath
)
;
}
SandboxBrokerPolicyFactory
:
:
SandboxBrokerPolicyFactory
(
)
{
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
SandboxBroker
:
:
Policy
*
policy
=
new
SandboxBroker
:
:
Policy
;
policy
-
>
AddDir
(
rdwrcr
"
/
dev
/
shm
"
)
;
policy
-
>
AddFilePrefix
(
rdwr
"
/
dev
"
"
nvidia
"
)
;
policy
-
>
AddDir
(
rdwr
"
/
dev
/
dri
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
dev
/
urandom
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
cpuinfo
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
meminfo
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
sys
/
devices
/
system
/
cpu
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib32
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
lib64
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
etc
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
local
/
share
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
usr
/
X11R6
/
lib
/
X11
/
fonts
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
nix
/
store
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
run
/
host
/
fonts
"
)
;
policy
-
>
AddDir
(
rdonly
"
/
run
/
host
/
user
-
fonts
"
)
;
AddMesaSysfsPaths
(
policy
)
;
AddLdconfigPaths
(
policy
)
;
policy
-
>
AddPath
(
rdonly
"
/
proc
/
modules
"
)
;
if
(
const
auto
xdgConfigPath
=
PR_GetEnv
(
"
XDG_CONFIG_PATH
"
)
)
{
policy
-
>
AddDir
(
rdonly
xdgConfigPath
)
;
}
nsAutoCString
xdgConfigDirs
(
PR_GetEnv
(
"
XDG_CONFIG_DIRS
"
)
)
;
for
(
const
auto
&
path
:
xdgConfigDirs
.
Split
(
'
:
'
)
)
{
policy
-
>
AddDir
(
rdonly
PromiseFlatCString
(
path
)
.
get
(
)
)
;
}
nsAutoCString
xdgDataHome
(
PR_GetEnv
(
"
XDG_DATA_HOME
"
)
)
;
if
(
!
xdgDataHome
.
IsEmpty
(
)
)
{
nsAutoCString
fontPath
(
xdgDataHome
)
;
fontPath
.
Append
(
"
/
fonts
"
)
;
policy
-
>
AddDir
(
rdonly
PromiseFlatCString
(
fontPath
)
.
get
(
)
)
;
}
nsAutoCString
xdgDataDirs
(
PR_GetEnv
(
"
XDG_DATA_DIRS
"
)
)
;
for
(
const
auto
&
path
:
xdgDataDirs
.
Split
(
'
:
'
)
)
{
nsAutoCString
fontPath
(
path
)
;
fontPath
.
Append
(
"
/
fonts
"
)
;
policy
-
>
AddDir
(
rdonly
PromiseFlatCString
(
fontPath
)
.
get
(
)
)
;
}
mozilla
:
:
Array
<
const
char
*
3
>
extraConfDirs
=
{
"
.
config
"
"
.
themes
"
"
.
fonts
"
}
;
nsCOMPtr
<
nsIFile
>
homeDir
;
nsresult
rv
=
GetSpecialSystemDirectory
(
Unix_HomeDirectory
getter_AddRefs
(
homeDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
confDir
;
for
(
const
auto
&
dir
:
extraConfDirs
)
{
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
nsDependentCString
(
dir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
}
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
.
local
"
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
share
"
)
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
.
fonts
.
conf
"
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddPath
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
rv
=
homeDir
-
>
Clone
(
getter_AddRefs
(
confDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
confDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
.
pangorc
"
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
confDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddPath
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
}
nsCOMPtr
<
nsIFile
>
ffDir
;
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
ffDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
ffDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
nsCOMPtr
<
nsIFile
>
sysExtDevDir
;
rv
=
NS_GetSpecialDirectory
(
XRE_USER_SYS_EXTENSION_DEV_DIR
getter_AddRefs
(
sysExtDevDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
sysExtDevDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
if
(
mozilla
:
:
IsDevelopmentBuild
(
)
)
{
const
char
*
developer_repo_dir
=
PR_GetEnv
(
"
MOZ_DEVELOPER_REPO_DIR
"
)
;
if
(
developer_repo_dir
)
{
policy
-
>
AddDir
(
rdonly
developer_repo_dir
)
;
}
}
#
ifdef
DEBUG
char
*
bloatLog
=
PR_GetEnv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
;
if
(
bloatLog
!
=
nullptr
)
{
size_t
bloatLen
=
strlen
(
bloatLog
)
;
if
(
bloatLen
>
=
4
)
{
nsAutoCString
bloatStr
(
bloatLog
)
;
bloatStr
.
Truncate
(
bloatLen
-
4
)
;
policy
-
>
AddPrefix
(
rdwrcr
bloatStr
.
get
(
)
)
;
}
}
#
endif
const
char
*
bumblebeeSocket
=
PR_GetEnv
(
"
BUMBLEBEE_SOCKET
"
)
;
if
(
bumblebeeSocket
=
=
nullptr
)
{
bumblebeeSocket
=
"
/
var
/
run
/
bumblebee
.
socket
"
;
}
policy
-
>
AddPath
(
SandboxBroker
:
:
MAY_CONNECT
bumblebeeSocket
)
;
policy
-
>
AddPrefix
(
SandboxBroker
:
:
MAY_CONNECT
"
/
tmp
/
.
X11
-
unix
/
X
"
)
;
if
(
const
auto
xauth
=
PR_GetEnv
(
"
XAUTHORITY
"
)
)
{
policy
-
>
AddPath
(
rdonly
xauth
)
;
}
mCommonContentPolicy
.
reset
(
policy
)
;
#
endif
}
#
ifdef
MOZ_CONTENT_SANDBOX
UniquePtr
<
SandboxBroker
:
:
Policy
>
SandboxBrokerPolicyFactory
:
:
GetContentPolicy
(
int
aPid
bool
aFileProcess
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
IsContentSandboxEnabled
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mCommonContentPolicy
)
;
UniquePtr
<
SandboxBroker
:
:
Policy
>
policy
(
new
SandboxBroker
:
:
Policy
(
*
mCommonContentPolicy
)
)
;
const
int
level
=
GetEffectiveContentSandboxLevel
(
)
;
AddDynamicPathList
(
policy
.
get
(
)
"
security
.
sandbox
.
content
.
write_path_whitelist
"
rdwr
)
;
AddDynamicPathList
(
policy
.
get
(
)
"
security
.
sandbox
.
content
.
read_path_whitelist
"
rdonly
)
;
if
(
level
<
=
2
|
|
aFileProcess
)
{
policy
-
>
AddDir
(
rdonly
"
/
"
)
;
}
policy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
maps
"
aPid
)
.
get
(
)
)
;
policy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
statm
"
aPid
)
.
get
(
)
)
;
policy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
smaps
"
aPid
)
.
get
(
)
)
;
policy
-
>
AddPath
(
rdonly
nsPrintfCString
(
"
/
proc
/
%
d
/
status
"
aPid
)
.
get
(
)
)
;
nsCOMPtr
<
nsIFile
>
tmpDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_CONTENT_PROCESS_TEMP_DIR
getter_AddRefs
(
tmpDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
tmpDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdwrcr
tmpPath
.
get
(
)
)
;
}
}
nsCOMPtr
<
nsIFile
>
profileDir
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profileDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
workDir
;
rv
=
profileDir
-
>
Clone
(
getter_AddRefs
(
workDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
workDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
chrome
"
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
workDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
rv
=
profileDir
-
>
Clone
(
getter_AddRefs
(
workDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
workDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
extensions
"
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
tmpPath
;
rv
=
workDir
-
>
GetNativePath
(
tmpPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
policy
-
>
AddDir
(
rdonly
tmpPath
.
get
(
)
)
;
}
}
}
}
bool
allowPulse
=
false
;
bool
allowAlsa
=
false
;
if
(
level
<
4
)
{
#
ifdef
MOZ_PULSEAUDIO
allowPulse
=
true
;
#
endif
#
ifdef
MOZ_ALSA
allowAlsa
=
true
;
#
endif
}
if
(
allowAlsa
)
{
policy
-
>
AddDir
(
rdwr
"
/
dev
/
snd
"
)
;
}
#
ifdef
MOZ_WIDGET_GTK
if
(
const
auto
userDir
=
g_get_user_runtime_dir
(
)
)
{
nsPrintfCString
shmPath
(
"
%
s
/
dconf
/
"
userDir
)
;
policy
-
>
AddPrefix
(
rdwrcr
shmPath
.
get
(
)
)
;
policy
-
>
AddAncestors
(
shmPath
.
get
(
)
)
;
if
(
allowPulse
)
{
nsPrintfCString
pulsePath
(
"
%
s
/
pulse
"
userDir
)
;
policy
-
>
AddPath
(
rdonly
pulsePath
.
get
(
)
)
;
}
}
#
endif
if
(
allowPulse
)
{
policy
-
>
AddPath
(
rdonly
"
/
var
/
lib
/
dbus
/
machine
-
id
"
)
;
}
if
(
HasAtiDrivers
(
)
)
{
policy
-
>
AddDir
(
rdonly
"
/
opt
/
amdgpu
/
share
"
)
;
policy
-
>
AddPath
(
rdonly
"
/
sys
/
module
/
amdgpu
"
)
;
policy
-
>
AddDir
(
access
"
/
sys
"
)
;
}
policy
-
>
FixRecursivePermissions
(
)
;
return
policy
;
}
void
SandboxBrokerPolicyFactory
:
:
AddDynamicPathList
(
SandboxBroker
:
:
Policy
*
policy
const
char
*
aPathListPref
int
perms
)
{
nsAutoCString
pathList
;
nsresult
rv
=
Preferences
:
:
GetCString
(
aPathListPref
pathList
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
const
nsACString
&
path
:
pathList
.
Split
(
'
'
)
)
{
nsCString
trimPath
(
path
)
;
trimPath
.
Trim
(
"
"
true
true
)
;
policy
-
>
AddDynamic
(
perms
trimPath
.
get
(
)
)
;
}
}
}
#
endif
}
