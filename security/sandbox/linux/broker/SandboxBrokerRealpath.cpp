#
if
defined
(
LIBC_SCCS
)
&
&
!
defined
(
lint
)
static
char
sccsid
[
]
=
"
(
#
)
realpath
.
c
8
.
1
(
Berkeley
)
2
/
16
/
94
"
;
#
endif
#
include
<
sys
/
param
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
unistd
.
h
>
#
include
"
base
/
string_util
.
h
"
#
include
"
SandboxBroker
.
h
"
using
namespace
base
;
static
size_t
my_strlcat
(
char
*
s1
const
char
*
s2
size_t
len
)
{
size_t
pos1
=
0
;
while
(
pos1
<
len
&
&
s1
[
pos1
]
!
=
'
\
0
'
)
pos1
+
+
;
if
(
pos1
=
=
len
)
return
pos1
;
return
pos1
+
strlcpy
(
s1
+
pos1
s2
len
-
pos1
)
;
}
namespace
mozilla
{
char
*
SandboxBroker
:
:
SymlinkPath
(
const
Policy
*
policy
const
char
*
__restrict
path
char
*
__restrict
resolved
int
*
perms
)
{
struct
stat
sb
;
char
*
p
*
q
*
s
;
size_t
left_len
resolved_len
backup_allowed
;
unsigned
symlinks
;
int
m
slen
;
char
left
[
PATH_MAX
]
next_token
[
PATH_MAX
]
symlink
[
PATH_MAX
]
;
if
(
*
perms
)
{
*
perms
=
0
;
}
if
(
path
=
=
NULL
)
{
errno
=
EINVAL
;
return
(
NULL
)
;
}
if
(
path
[
0
]
=
=
'
\
0
'
)
{
errno
=
ENOENT
;
return
(
NULL
)
;
}
if
(
resolved
=
=
NULL
)
{
resolved
=
(
char
*
)
malloc
(
PATH_MAX
)
;
if
(
resolved
=
=
NULL
)
return
(
NULL
)
;
m
=
1
;
}
else
m
=
0
;
symlinks
=
0
;
backup_allowed
=
PATH_MAX
;
if
(
path
[
0
]
=
=
'
/
'
)
{
resolved
[
0
]
=
'
/
'
;
resolved
[
1
]
=
'
\
0
'
;
if
(
path
[
1
]
=
=
'
\
0
'
)
return
(
resolved
)
;
resolved_len
=
1
;
left_len
=
strlcpy
(
left
path
+
1
sizeof
(
left
)
)
;
}
else
{
if
(
getcwd
(
resolved
PATH_MAX
)
=
=
NULL
)
{
if
(
m
)
free
(
resolved
)
;
else
{
resolved
[
0
]
=
'
.
'
;
resolved
[
1
]
=
'
\
0
'
;
}
return
(
NULL
)
;
}
resolved_len
=
strlen
(
resolved
)
;
left_len
=
strlcpy
(
left
path
sizeof
(
left
)
)
;
}
if
(
left_len
>
=
sizeof
(
left
)
|
|
resolved_len
>
=
PATH_MAX
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
ENAMETOOLONG
;
return
(
NULL
)
;
}
while
(
left_len
!
=
0
)
{
p
=
strchr
(
left
'
/
'
)
;
s
=
p
?
p
:
left
+
left_len
;
if
(
s
-
left
>
=
(
ssize_t
)
sizeof
(
next_token
)
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
ENAMETOOLONG
;
return
(
NULL
)
;
}
memcpy
(
next_token
left
s
-
left
)
;
next_token
[
s
-
left
]
=
'
\
0
'
;
left_len
-
=
s
-
left
;
if
(
p
!
=
NULL
)
memmove
(
left
s
+
1
left_len
+
1
)
;
if
(
resolved
[
resolved_len
-
1
]
!
=
'
/
'
)
{
if
(
resolved_len
+
1
>
=
PATH_MAX
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
ENAMETOOLONG
;
return
(
NULL
)
;
}
resolved
[
resolved_len
+
+
]
=
'
/
'
;
resolved
[
resolved_len
]
=
'
\
0
'
;
}
if
(
next_token
[
0
]
=
=
'
\
0
'
)
{
continue
;
}
else
if
(
strcmp
(
next_token
"
.
"
)
=
=
0
)
continue
;
else
if
(
strcmp
(
next_token
"
.
.
"
)
=
=
0
)
{
if
(
resolved_len
>
1
)
{
if
(
backup_allowed
>
0
)
{
resolved
[
resolved_len
-
1
]
=
'
\
0
'
;
q
=
strrchr
(
resolved
'
/
'
)
+
1
;
*
q
=
'
\
0
'
;
resolved_len
=
q
-
resolved
;
backup_allowed
-
-
;
}
else
{
if
(
m
)
free
(
resolved
)
;
errno
=
EPERM
;
return
(
NULL
)
;
}
}
continue
;
}
resolved_len
=
my_strlcat
(
resolved
next_token
PATH_MAX
)
;
backup_allowed
+
+
;
if
(
resolved_len
>
=
PATH_MAX
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
ENAMETOOLONG
;
return
(
NULL
)
;
}
if
(
lstat
(
resolved
&
sb
)
!
=
0
)
{
if
(
m
)
free
(
resolved
)
;
return
(
NULL
)
;
}
if
(
S_ISLNK
(
sb
.
st_mode
)
)
{
if
(
symlinks
+
+
>
MAXSYMLINKS
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
ELOOP
;
return
(
NULL
)
;
}
int
link_path_perms
=
policy
-
>
Lookup
(
resolved
)
;
if
(
link_path_perms
&
MAY_WRITE
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
EPERM
;
return
(
NULL
)
;
}
else
{
*
perms
|
=
link_path_perms
;
}
slen
=
readlink
(
resolved
symlink
sizeof
(
symlink
)
-
1
)
;
if
(
slen
<
0
)
{
if
(
m
)
free
(
resolved
)
;
return
(
NULL
)
;
}
symlink
[
slen
]
=
'
\
0
'
;
if
(
symlink
[
0
]
=
=
'
/
'
)
{
resolved
[
1
]
=
0
;
resolved_len
=
1
;
}
else
if
(
resolved_len
>
1
)
{
resolved
[
resolved_len
-
1
]
=
'
\
0
'
;
q
=
strrchr
(
resolved
'
/
'
)
+
1
;
*
q
=
'
\
0
'
;
resolved_len
=
q
-
resolved
;
}
if
(
p
!
=
NULL
)
{
if
(
symlink
[
slen
-
1
]
!
=
'
/
'
)
{
if
(
slen
+
1
>
=
(
ssize_t
)
sizeof
(
symlink
)
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
ENAMETOOLONG
;
return
(
NULL
)
;
}
symlink
[
slen
]
=
'
/
'
;
symlink
[
slen
+
1
]
=
0
;
}
left_len
=
my_strlcat
(
symlink
left
sizeof
(
symlink
)
)
;
if
(
left_len
>
=
sizeof
(
left
)
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
ENAMETOOLONG
;
return
(
NULL
)
;
}
}
left_len
=
strlcpy
(
left
symlink
sizeof
(
left
)
)
;
backup_allowed
=
0
;
}
else
if
(
!
S_ISDIR
(
sb
.
st_mode
)
&
&
p
!
=
NULL
)
{
if
(
m
)
free
(
resolved
)
;
errno
=
ENOTDIR
;
return
(
NULL
)
;
}
}
if
(
resolved_len
>
1
&
&
resolved
[
resolved_len
-
1
]
=
=
'
/
'
)
resolved
[
resolved_len
-
1
]
=
'
\
0
'
;
*
perms
|
=
policy
-
>
Lookup
(
resolved
)
;
return
(
resolved
)
;
}
}
