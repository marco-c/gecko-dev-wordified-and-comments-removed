#
include
"
SandboxBrokerCommon
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
mozilla
/
ProfilerThreadSleep
.
h
"
#
else
#
define
AUTO_PROFILER_THREAD_SLEEP
#
endif
#
include
<
errno
.
h
>
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
include
<
string
.
h
>
#
ifndef
MSG_CMSG_CLOEXEC
#
ifdef
XP_LINUX
#
define
MSG_CMSG_CLOEXEC
0x40000000
#
else
#
error
"
No
MSG_CMSG_CLOEXEC
?
"
#
endif
#
endif
namespace
mozilla
{
const
char
*
SandboxBrokerCommon
:
:
OperationDescription
[
]
=
{
"
open
"
"
access
"
"
stat
"
"
chmod
"
"
link
"
"
symlink
"
"
mkdir
"
"
rename
"
"
rmdir
"
"
unlink
"
"
readlink
"
"
connect
"
"
connect
-
abstract
"
}
;
ssize_t
SandboxBrokerCommon
:
:
RecvWithFd
(
int
aFd
const
iovec
*
aIO
size_t
aNumIO
int
*
aPassedFdPtr
)
{
struct
msghdr
msg
=
{
}
;
msg
.
msg_iov
=
const_cast
<
iovec
*
>
(
aIO
)
;
msg
.
msg_iovlen
=
aNumIO
;
char
cmsg_buf
[
CMSG_SPACE
(
sizeof
(
int
)
)
]
;
if
(
aPassedFdPtr
)
{
msg
.
msg_control
=
cmsg_buf
;
msg
.
msg_controllen
=
sizeof
(
cmsg_buf
)
;
*
aPassedFdPtr
=
-
1
;
}
ssize_t
rv
;
do
{
AUTO_PROFILER_THREAD_SLEEP
;
rv
=
recvmsg
(
aFd
&
msg
MSG_CMSG_CLOEXEC
)
;
}
while
(
rv
<
0
&
&
errno
=
=
EINTR
)
;
if
(
rv
<
=
0
)
{
return
rv
;
}
if
(
msg
.
msg_controllen
>
0
)
{
MOZ_ASSERT
(
aPassedFdPtr
)
;
struct
cmsghdr
*
cmsg
=
CMSG_FIRSTHDR
(
&
msg
)
;
if
(
cmsg
-
>
cmsg_level
=
=
SOL_SOCKET
&
&
cmsg
-
>
cmsg_type
=
=
SCM_RIGHTS
)
{
int
*
fds
=
reinterpret_cast
<
int
*
>
(
CMSG_DATA
(
cmsg
)
)
;
if
(
cmsg
-
>
cmsg_len
!
=
CMSG_LEN
(
sizeof
(
int
)
)
)
{
for
(
size_t
i
=
0
;
CMSG_LEN
(
sizeof
(
int
)
*
i
)
<
cmsg
-
>
cmsg_len
;
+
+
i
)
{
close
(
fds
[
i
]
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
cmsg
-
>
cmsg_len
!
=
0
)
;
errno
=
EMSGSIZE
;
return
-
1
;
}
*
aPassedFdPtr
=
fds
[
0
]
;
}
else
{
errno
=
EPROTO
;
return
-
1
;
}
}
if
(
msg
.
msg_flags
&
(
MSG_TRUNC
|
MSG_CTRUNC
)
)
{
if
(
aPassedFdPtr
&
&
*
aPassedFdPtr
>
=
0
)
{
close
(
*
aPassedFdPtr
)
;
*
aPassedFdPtr
=
-
1
;
}
MOZ_DIAGNOSTIC_ASSERT
(
(
msg
.
msg_flags
&
MSG_TRUNC
)
=
=
0
)
;
errno
=
EMFILE
;
return
-
1
;
}
return
rv
;
}
ssize_t
SandboxBrokerCommon
:
:
SendWithFd
(
int
aFd
const
iovec
*
aIO
size_t
aNumIO
int
aPassedFd
)
{
struct
msghdr
msg
=
{
}
;
msg
.
msg_iov
=
const_cast
<
iovec
*
>
(
aIO
)
;
msg
.
msg_iovlen
=
aNumIO
;
char
cmsg_buf
[
CMSG_SPACE
(
sizeof
(
int
)
)
]
;
memset
(
cmsg_buf
0
sizeof
(
cmsg_buf
)
)
;
if
(
aPassedFd
!
=
-
1
)
{
msg
.
msg_control
=
cmsg_buf
;
msg
.
msg_controllen
=
sizeof
(
cmsg_buf
)
;
struct
cmsghdr
*
cmsg
=
CMSG_FIRSTHDR
(
&
msg
)
;
cmsg
-
>
cmsg_level
=
SOL_SOCKET
;
cmsg
-
>
cmsg_type
=
SCM_RIGHTS
;
cmsg
-
>
cmsg_len
=
CMSG_LEN
(
sizeof
(
int
)
)
;
*
reinterpret_cast
<
int
*
>
(
CMSG_DATA
(
cmsg
)
)
=
aPassedFd
;
}
ssize_t
rv
;
do
{
rv
=
sendmsg
(
aFd
&
msg
MSG_NOSIGNAL
)
;
}
while
(
rv
<
0
&
&
errno
=
=
EINTR
)
;
return
rv
;
}
}
