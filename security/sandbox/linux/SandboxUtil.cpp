#
include
"
SandboxUtil
.
h
"
#
include
"
LinuxCapabilities
.
h
"
#
include
"
LinuxSched
.
h
"
#
include
"
SandboxLogging
.
h
"
#
include
<
fcntl
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
namespace
mozilla
{
bool
IsSingleThreaded
(
)
{
struct
stat
sb
;
if
(
stat
(
"
/
proc
/
self
/
task
"
&
sb
)
<
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Couldn
'
t
access
/
proc
/
self
/
task
!
"
)
;
return
false
;
}
MOZ_DIAGNOSTIC_ASSERT
(
sb
.
st_nlink
>
=
3
)
;
return
sb
.
st_nlink
=
=
3
;
}
static
bool
WriteStringToFile
(
const
char
*
aPath
const
char
*
aStr
const
size_t
aLen
)
{
int
fd
=
open
(
aPath
O_WRONLY
)
;
if
(
fd
<
0
)
{
return
false
;
}
ssize_t
written
=
write
(
fd
aStr
aLen
)
;
if
(
close
(
fd
)
!
=
0
|
|
written
!
=
ssize_t
(
aLen
)
)
{
return
false
;
}
return
true
;
}
bool
UnshareUserNamespace
(
)
{
uid_t
uid
=
getuid
(
)
;
gid_t
gid
=
getgid
(
)
;
char
buf
[
80
]
;
if
(
syscall
(
__NR_unshare
CLONE_NEWUSER
)
!
=
0
)
{
return
false
;
}
int
len
=
SprintfLiteral
(
buf
"
%
u
%
u
1
\
n
"
uid
uid
)
;
if
(
len
>
=
int
(
sizeof
(
buf
)
)
|
|
len
<
0
)
{
return
false
;
}
if
(
!
WriteStringToFile
(
"
/
proc
/
self
/
uid_map
"
buf
size_t
(
len
)
)
)
{
MOZ_CRASH
(
"
Failed
to
write
/
proc
/
self
/
uid_map
"
)
;
}
Unused
<
<
WriteStringToFile
(
"
/
proc
/
self
/
setgroups
"
"
deny
"
4
)
;
len
=
SprintfLiteral
(
buf
"
%
u
%
u
1
\
n
"
gid
gid
)
;
if
(
len
>
=
int
(
sizeof
(
buf
)
)
|
|
len
<
0
)
{
return
false
;
}
if
(
!
WriteStringToFile
(
"
/
proc
/
self
/
gid_map
"
buf
size_t
(
len
)
)
)
{
MOZ_CRASH
(
"
Failed
to
write
/
proc
/
self
/
gid_map
"
)
;
}
return
true
;
}
}
