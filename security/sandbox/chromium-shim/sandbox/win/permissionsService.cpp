#
include
"
permissionsService
.
h
"
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
winternl
.
h
>
namespace
mozilla
{
namespace
sandboxing
{
static
const
std
:
:
wstring
ZONE_IDENTIFIER_STR
(
L
"
:
ZONE
.
IDENTIFIER
"
)
;
static
const
std
:
:
wstring
ZONE_ID_DATA_STR
(
L
"
:
ZONE
.
IDENTIFIER
:
DATA
"
)
;
static
const
std
:
:
wstring
FLASH_TEMP_FILENAME
(
L
"
FLASHTMP0
.
TMP
"
)
;
bool
StringEndsWith
(
const
std
:
:
wstring
&
str
const
std
:
:
wstring
&
strEnding
)
{
if
(
strEnding
.
size
(
)
>
str
.
size
(
)
)
{
return
false
;
}
return
std
:
:
equal
(
strEnding
.
rbegin
(
)
strEnding
.
rend
(
)
str
.
rbegin
(
)
)
;
}
bool
IsFlashTempFile
(
std
:
:
wstring
aFilename
std
:
:
wstring
*
aFolder
=
nullptr
)
{
int
slashIdx
=
aFilename
.
find_last_of
(
L
'
\
\
'
)
;
if
(
slashIdx
!
=
std
:
:
wstring
:
:
npos
)
{
if
(
aFolder
)
{
*
aFolder
=
aFilename
.
substr
(
0
slashIdx
+
1
)
;
}
aFilename
=
aFilename
.
substr
(
slashIdx
+
1
)
;
}
else
{
*
aFolder
=
L
"
\
\
"
;
}
if
(
aFilename
.
compare
(
0
8
L
"
FLASHTMP
"
)
!
=
0
)
{
return
false
;
}
int
idx
=
8
;
int
len
=
aFilename
.
length
(
)
;
while
(
idx
<
len
&
&
isdigit
(
aFilename
[
idx
]
)
)
{
+
+
idx
;
}
return
(
len
-
idx
=
=
4
)
&
&
aFilename
.
compare
(
idx
4
L
"
.
TMP
"
)
=
=
0
;
}
std
:
:
wstring
GetPlainFileName
(
const
wchar_t
*
aNTFileName
std
:
:
wstring
*
aFolder
=
nullptr
)
{
while
(
*
aNTFileName
=
=
L
'
\
\
'
|
|
*
aNTFileName
=
=
L
'
.
'
|
|
*
aNTFileName
=
=
L
'
?
'
|
|
*
aNTFileName
=
=
L
'
:
'
)
{
+
+
aNTFileName
;
}
std
:
:
wstring
nameCopy
(
aNTFileName
)
;
std
:
:
transform
(
nameCopy
.
begin
(
)
nameCopy
.
end
(
)
nameCopy
.
begin
(
)
towupper
)
;
if
(
StringEndsWith
(
nameCopy
ZONE_ID_DATA_STR
)
)
{
nameCopy
=
nameCopy
.
substr
(
0
nameCopy
.
size
(
)
-
ZONE_ID_DATA_STR
.
size
(
)
)
;
}
else
if
(
StringEndsWith
(
nameCopy
ZONE_IDENTIFIER_STR
)
)
{
nameCopy
=
nameCopy
.
substr
(
0
nameCopy
.
size
(
)
-
ZONE_IDENTIFIER_STR
.
size
(
)
)
;
}
if
(
IsFlashTempFile
(
nameCopy
aFolder
)
&
&
aFolder
)
{
return
*
aFolder
+
FLASH_TEMP_FILENAME
;
}
return
nameCopy
;
}
PermissionsService
*
PermissionsService
:
:
GetInstance
(
)
{
static
PermissionsService
sPermissionsService
;
return
&
sPermissionsService
;
}
PermissionsService
:
:
PermissionsService
(
)
:
mFileAccessViolationFunc
(
nullptr
)
{
}
void
PermissionsService
:
:
GrantFileAccess
(
uint32_t
aProcessId
const
wchar_t
*
aFilename
bool
aPermitWrite
)
{
FilePermissionMap
&
permissions
=
mProcessFilePermissions
[
aProcessId
]
;
std
:
:
wstring
containingFolder
;
std
:
:
wstring
filename
=
GetPlainFileName
(
aFilename
&
containingFolder
)
;
permissions
[
filename
]
|
=
aPermitWrite
;
if
(
aPermitWrite
)
{
permissions
[
containingFolder
+
FLASH_TEMP_FILENAME
]
=
true
;
}
}
void
PermissionsService
:
:
SetFileAccessViolationFunc
(
FileAccessViolationFunc
aFavFunc
)
{
mFileAccessViolationFunc
=
aFavFunc
;
}
void
PermissionsService
:
:
ReportBlockedFile
(
bool
aNeedsWrite
)
{
if
(
mFileAccessViolationFunc
)
{
mFileAccessViolationFunc
(
aNeedsWrite
)
;
}
}
bool
PermissionsService
:
:
UserGrantedFileAccess
(
uint32_t
aProcessId
const
wchar_t
*
aFilename
uint32_t
aAccess
uint32_t
aDisposition
)
{
const
uint32_t
FORBIDDEN_FLAGS
=
FILE_EXECUTE
|
FILE_LIST_DIRECTORY
|
FILE_TRAVERSE
|
STANDARD_RIGHTS_EXECUTE
;
const
uint32_t
NEEDS_WRITE_FLAGS
=
FILE_WRITE_DATA
|
FILE_WRITE_ATTRIBUTES
|
FILE_WRITE_EA
|
FILE_APPEND_DATA
|
DELETE
|
STANDARD_RIGHTS_WRITE
;
bool
needsWrite
=
(
aAccess
&
NEEDS_WRITE_FLAGS
)
|
|
(
aDisposition
!
=
FILE_OPEN
)
;
if
(
aAccess
&
FORBIDDEN_FLAGS
)
{
ReportBlockedFile
(
needsWrite
)
;
return
false
;
}
auto
permissions
=
mProcessFilePermissions
.
find
(
aProcessId
)
;
if
(
permissions
=
=
mProcessFilePermissions
.
end
(
)
)
{
ReportBlockedFile
(
needsWrite
)
;
return
false
;
}
std
:
:
wstring
filename
=
GetPlainFileName
(
aFilename
)
;
auto
itPermission
=
permissions
-
>
second
.
find
(
filename
)
;
if
(
itPermission
=
=
permissions
-
>
second
.
end
(
)
)
{
ReportBlockedFile
(
needsWrite
)
;
return
false
;
}
if
(
!
needsWrite
|
|
itPermission
-
>
second
)
{
return
true
;
}
ReportBlockedFile
(
needsWrite
)
;
return
false
;
}
void
PermissionsService
:
:
RemovePermissionsForProcess
(
uint32_t
aProcessId
)
{
mProcessFilePermissions
.
erase
(
aProcessId
)
;
}
}
}
