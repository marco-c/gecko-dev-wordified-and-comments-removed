#
include
"
base
/
file_version_info_win
.
h
"
#
include
"
base
/
files
/
file_path
.
h
"
#
include
"
base
/
memory
/
ptr_util
.
h
"
#
include
"
base
/
threading
/
scoped_blocking_call
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
namespace
{
struct
LanguageAndCodePage
{
WORD
language
;
WORD
code_page
;
}
;
LanguageAndCodePage
*
GetTranslate
(
const
void
*
data
)
{
static
constexpr
wchar_t
kTranslation
[
]
=
L
"
\
\
VarFileInfo
\
\
Translation
"
;
LPVOID
translate
=
nullptr
;
UINT
dummy_size
;
if
(
:
:
VerQueryValue
(
data
kTranslation
&
translate
&
dummy_size
)
)
return
static_cast
<
LanguageAndCodePage
*
>
(
translate
)
;
return
nullptr
;
}
const
VS_FIXEDFILEINFO
&
GetVsFixedFileInfo
(
const
void
*
data
)
{
static
constexpr
wchar_t
kRoot
[
]
=
L
"
\
\
"
;
LPVOID
fixed_file_info
=
nullptr
;
UINT
dummy_size
;
CHECK
(
:
:
VerQueryValue
(
data
kRoot
&
fixed_file_info
&
dummy_size
)
)
;
return
*
static_cast
<
VS_FIXEDFILEINFO
*
>
(
fixed_file_info
)
;
}
}
std
:
:
unique_ptr
<
FileVersionInfoWin
>
FileVersionInfoWin
:
:
CreateFileVersionInfoWin
(
const
base
:
:
FilePath
&
file_path
)
{
base
:
:
ScopedBlockingCall
scoped_blocking_call
(
FROM_HERE
base
:
:
BlockingType
:
:
MAY_BLOCK
)
;
DWORD
dummy
;
const
wchar_t
*
path
=
file_path
.
value
(
)
.
c_str
(
)
;
const
DWORD
length
=
:
:
GetFileVersionInfoSize
(
path
&
dummy
)
;
if
(
length
=
=
0
)
return
nullptr
;
std
:
:
vector
<
uint8_t
>
data
(
length
0
)
;
if
(
!
:
:
GetFileVersionInfo
(
path
dummy
length
data
.
data
(
)
)
)
return
nullptr
;
const
LanguageAndCodePage
*
translate
=
GetTranslate
(
data
.
data
(
)
)
;
if
(
!
translate
)
return
nullptr
;
return
base
:
:
WrapUnique
(
new
FileVersionInfoWin
(
std
:
:
move
(
data
)
translate
-
>
language
translate
-
>
code_page
)
)
;
}
base
:
:
Version
FileVersionInfoWin
:
:
GetFileVersion
(
)
const
{
return
base
:
:
Version
(
{
HIWORD
(
fixed_file_info_
.
dwFileVersionMS
)
LOWORD
(
fixed_file_info_
.
dwFileVersionMS
)
HIWORD
(
fixed_file_info_
.
dwFileVersionLS
)
LOWORD
(
fixed_file_info_
.
dwFileVersionLS
)
}
)
;
}
FileVersionInfoWin
:
:
FileVersionInfoWin
(
std
:
:
vector
<
uint8_t
>
&
&
data
WORD
language
WORD
code_page
)
:
owned_data_
(
std
:
:
move
(
data
)
)
data_
(
owned_data_
.
data
(
)
)
language_
(
language
)
code_page_
(
code_page
)
fixed_file_info_
(
GetVsFixedFileInfo
(
data_
)
)
{
DCHECK
(
!
owned_data_
.
empty
(
)
)
;
mozilla
:
:
Unused
<
<
language_
;
mozilla
:
:
Unused
<
<
code_page_
;
}
