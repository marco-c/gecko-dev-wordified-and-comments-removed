#
include
"
SandboxTestingChild
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
ifdef
XP_UNIX
#
include
<
fcntl
.
h
>
#
include
<
netdb
.
h
>
#
ifdef
XP_LINUX
#
include
<
sys
/
prctl
.
h
>
#
include
<
sys
/
ioctl
.
h
>
#
include
<
termios
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
utsname
.
h
>
#
include
<
sched
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
un
.
h
>
#
endif
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
ifdef
XP_MACOSX
#
include
<
CoreGraphics
/
CoreGraphics
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
<
stdio
.
h
>
#
endif
namespace
mozilla
{
#
ifdef
XP_LINUX
static
void
RunTestsSched
(
SandboxTestingChild
*
child
)
{
struct
sched_param
param_pid_0
=
{
}
;
child
-
>
ErrnoTest
(
"
sched_getparam
(
0
)
"
_ns
true
[
&
]
{
return
sched_getparam
(
0
&
param_pid_0
)
;
}
)
;
struct
sched_param
param_pid_tid
=
{
}
;
child
-
>
ErrnoTest
(
"
sched_getparam
(
tid
)
"
_ns
true
[
&
]
{
return
sched_getparam
(
(
pid_t
)
syscall
(
__NR_gettid
)
&
param_pid_tid
)
;
}
)
;
struct
sched_param
param_pid_Ntid
=
{
}
;
child
-
>
ErrnoValueTest
(
"
sched_getparam
(
Ntid
)
"
_ns
false
EPERM
[
&
]
{
return
sched_getparam
(
(
pid_t
)
(
syscall
(
__NR_gettid
)
-
1
)
&
param_pid_Ntid
)
;
}
)
;
}
#
endif
void
RunTestsContent
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
struct
stat
st
;
static
const
char
kAllowedPath
[
]
=
"
/
usr
/
lib
"
;
child
-
>
ErrnoTest
(
"
fstatat_as_stat
"
_ns
true
[
&
]
{
return
fstatat
(
AT_FDCWD
kAllowedPath
&
st
0
)
;
}
)
;
child
-
>
ErrnoTest
(
"
fstatat_as_lstat
"
_ns
true
[
&
]
{
return
fstatat
(
AT_FDCWD
kAllowedPath
&
st
AT_SYMLINK_NOFOLLOW
)
;
}
)
;
#
ifdef
XP_LINUX
child
-
>
ErrnoTest
(
"
fstatat_as_fstat
"
_ns
true
[
&
]
{
return
fstatat
(
0
"
"
&
st
AT_EMPTY_PATH
)
;
}
)
;
const
struct
timespec
usec
=
{
0
1000
}
;
child
-
>
ErrnoTest
(
"
nanosleep
"
_ns
true
[
&
]
{
return
nanosleep
(
&
usec
nullptr
)
;
}
)
;
struct
timespec
res
=
{
0
0
}
;
child
-
>
ErrnoTest
(
"
clock_getres
"
_ns
true
[
&
]
{
return
clock_getres
(
CLOCK_REALTIME
&
res
)
;
}
)
;
child
-
>
ErrnoValueTest
(
"
connect_abstract_blocked
"
_ns
false
ENETUNREACH
[
&
]
{
int
sockfd
;
struct
sockaddr_un
addr
;
char
str
[
]
=
"
\
0xyz
"
;
size_t
str_size
=
4
;
memset
(
&
addr
0
sizeof
(
struct
sockaddr_un
)
)
;
addr
.
sun_family
=
AF_UNIX
;
memcpy
(
&
addr
.
sun_path
str
str_size
)
;
sockfd
=
socket
(
AF_UNIX
SOCK_STREAM
0
)
;
if
(
sockfd
=
=
-
1
)
{
return
-
1
;
}
int
con_st
=
connect
(
sockfd
(
struct
sockaddr
*
)
&
addr
sizeof
(
sa_family_t
)
+
str_size
)
;
return
con_st
;
}
)
;
child
-
>
ErrnoValueTest
(
"
connect_abstract_permit
"
_ns
false
ECONNREFUSED
[
&
]
{
int
sockfd
;
struct
sockaddr_un
addr
;
char
str
[
]
=
"
\
0
/
tmp
/
.
X11
-
unix
/
X
"
;
size_t
str_size
=
17
;
memset
(
&
addr
0
sizeof
(
struct
sockaddr_un
)
)
;
addr
.
sun_family
=
AF_UNIX
;
memcpy
(
&
addr
.
sun_path
str
str_size
)
;
sockfd
=
socket
(
AF_UNIX
SOCK_STREAM
0
)
;
if
(
sockfd
=
=
-
1
)
{
return
-
1
;
}
int
con_st
=
connect
(
sockfd
(
struct
sockaddr
*
)
&
addr
sizeof
(
sa_family_t
)
+
str_size
)
;
return
con_st
;
}
)
;
std
:
:
vector
<
std
:
:
pair
<
const
char
*
bool
>
>
open_tests
=
{
{
"
/
dev
/
random
"
true
}
}
;
if
(
stat
(
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
&
st
)
=
=
0
)
{
open_tests
.
push_back
(
{
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
true
}
)
;
}
for
(
const
std
:
:
pair
<
const
char
*
bool
>
&
to_open
:
open_tests
)
{
child
-
>
ErrnoTest
(
"
open
(
"
_ns
+
nsCString
(
to_open
.
first
)
+
"
)
"
_ns
to_open
.
second
[
&
]
{
int
fd
=
open
(
to_open
.
first
O_RDONLY
)
;
if
(
to_open
.
second
&
&
fd
>
0
)
{
close
(
fd
)
;
}
return
fd
;
}
)
;
}
#
endif
#
ifdef
XP_MACOSX
CFDictionaryRef
windowServerDict
=
CGSessionCopyCurrentDictionary
(
)
;
bool
gotWindowServerDetails
=
(
windowServerDict
!
=
nullptr
)
;
child
-
>
SendReportTestResults
(
"
CGSessionCopyCurrentDictionary
"
_ns
false
gotWindowServerDetails
gotWindowServerDetails
?
"
Failed
:
dictionary
unexpectedly
returned
"
_ns
:
"
Succeeded
:
no
dictionary
returned
"
_ns
)
;
if
(
windowServerDict
!
=
nullptr
)
{
CFRelease
(
windowServerDict
)
;
}
#
endif
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
}
void
RunTestsSocket
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
child
-
>
ErrnoTest
(
"
getaddrinfo
"
_ns
true
[
&
]
{
struct
addrinfo
*
res
;
int
rv
=
getaddrinfo
(
"
localhost
"
nullptr
nullptr
&
res
)
;
if
(
res
!
=
nullptr
)
{
freeaddrinfo
(
res
)
;
}
return
rv
;
}
)
;
#
ifdef
XP_LINUX
child
-
>
ErrnoTest
(
"
prctl_allowed
"
_ns
true
[
&
]
{
int
rv
=
prctl
(
PR_SET_DUMPABLE
0
0
0
0
)
;
return
rv
;
}
)
;
child
-
>
ErrnoTest
(
"
prctl_blocked
"
_ns
false
[
&
]
{
int
rv
=
prctl
(
PR_GET_SECCOMP
0
0
0
0
)
;
return
rv
;
}
)
;
std
:
:
vector
<
std
:
:
pair
<
const
char
*
bool
>
>
open_tests
=
{
{
"
/
dev
/
random
"
true
}
}
;
struct
stat
st
;
if
(
stat
(
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
&
st
)
=
=
0
)
{
open_tests
.
push_back
(
{
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
true
}
)
;
}
for
(
const
std
:
:
pair
<
const
char
*
bool
>
&
to_open
:
open_tests
)
{
child
-
>
ErrnoTest
(
"
open
(
"
_ns
+
nsCString
(
to_open
.
first
)
+
"
)
"
_ns
to_open
.
second
[
&
]
{
int
fd
=
open
(
to_open
.
first
O_RDONLY
)
;
if
(
to_open
.
second
&
&
fd
>
0
)
{
close
(
fd
)
;
}
return
fd
;
}
)
;
}
#
endif
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
}
void
RunTestsRDD
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
#
ifdef
XP_LINUX
child
-
>
ErrnoValueTest
(
"
ioctl_tiocsti
"
_ns
false
ENOSYS
[
&
]
{
int
rv
=
ioctl
(
1
TIOCSTI
"
x
"
)
;
return
rv
;
}
)
;
struct
rusage
res
;
child
-
>
ErrnoTest
(
"
getrusage
"
_ns
true
[
&
]
{
int
rv
=
getrusage
(
RUSAGE_SELF
&
res
)
;
return
rv
;
}
)
;
child
-
>
ErrnoValueTest
(
"
unlink
"
_ns
false
ENOENT
[
&
]
{
int
rv
=
unlink
(
"
"
)
;
return
rv
;
}
)
;
child
-
>
ErrnoValueTest
(
"
unlinkat
"
_ns
false
ENOENT
[
&
]
{
int
rv
=
unlinkat
(
AT_FDCWD
"
"
0
)
;
return
rv
;
}
)
;
RunTestsSched
(
child
)
;
child
-
>
ErrnoTest
(
"
socket
"
_ns
false
[
]
{
return
socket
(
AF_UNIX
SOCK_STREAM
0
)
;
}
)
;
child
-
>
ErrnoTest
(
"
uname
"
_ns
true
[
]
{
struct
utsname
uts
;
return
uname
(
&
uts
)
;
}
)
;
child
-
>
ErrnoValueTest
(
"
ioctl_dma_buf
"
_ns
false
ENOTTY
[
]
{
return
ioctl
(
0
_IOW
(
'
b
'
0
uint64_t
)
nullptr
)
;
}
)
;
#
endif
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
}
void
RunTestsGMPlugin
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
#
ifdef
XP_LINUX
struct
utsname
utsname_res
=
{
}
;
child
-
>
ErrnoTest
(
"
uname_restricted
"
_ns
true
[
&
]
{
int
rv
=
uname
(
&
utsname_res
)
;
nsCString
expectedSysname
(
"
Linux
"
_ns
)
;
nsCString
sysname
(
utsname_res
.
sysname
)
;
nsCString
expectedVersion
(
"
3
"
_ns
)
;
nsCString
version
(
utsname_res
.
version
)
;
if
(
(
sysname
!
=
expectedSysname
)
|
|
(
version
!
=
expectedVersion
)
)
{
return
-
1
;
}
return
rv
;
}
)
;
child
-
>
ErrnoTest
(
"
getuid
"
_ns
true
[
&
]
{
return
getuid
(
)
;
}
)
;
child
-
>
ErrnoTest
(
"
getgid
"
_ns
true
[
&
]
{
return
getgid
(
)
;
}
)
;
child
-
>
ErrnoTest
(
"
geteuid
"
_ns
true
[
&
]
{
return
geteuid
(
)
;
}
)
;
child
-
>
ErrnoTest
(
"
getegid
"
_ns
true
[
&
]
{
return
getegid
(
)
;
}
)
;
RunTestsSched
(
child
)
;
std
:
:
vector
<
std
:
:
pair
<
const
char
*
bool
>
>
open_tests
=
{
{
"
/
etc
/
ld
.
so
.
cache
"
true
}
{
"
/
proc
/
cpuinfo
"
true
}
{
"
/
etc
/
hostname
"
false
}
}
;
for
(
const
std
:
:
pair
<
const
char
*
bool
>
&
to_open
:
open_tests
)
{
child
-
>
ErrnoTest
(
"
open
(
"
_ns
+
nsCString
(
to_open
.
first
)
+
"
)
"
_ns
to_open
.
second
[
&
]
{
int
fd
=
open
(
to_open
.
first
O_RDONLY
)
;
if
(
to_open
.
second
&
&
fd
>
0
)
{
close
(
fd
)
;
}
return
fd
;
}
)
;
}
#
endif
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
}
void
RunTestsUtility
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
#
ifdef
XP_LINUX
child
-
>
ErrnoValueTest
(
"
ioctl_tiocsti
"
_ns
false
ENOSYS
[
&
]
{
int
rv
=
ioctl
(
1
TIOCSTI
"
x
"
)
;
return
rv
;
}
)
;
struct
rusage
res
;
child
-
>
ErrnoTest
(
"
getrusage
"
_ns
true
[
&
]
{
int
rv
=
getrusage
(
RUSAGE_SELF
&
res
)
;
return
rv
;
}
)
;
#
endif
#
else
#
ifdef
XP_WIN
child
-
>
ErrnoValueTest
(
"
write_only
"
_ns
true
EPERM
[
&
]
{
FILE
*
rv
=
fopen
(
"
test_sandbox
.
txt
"
"
w
"
)
;
int
errno_copy
=
errno
;
if
(
rv
!
=
nullptr
)
{
fclose
(
rv
)
;
MOZ_ASSERT
(
!
rv
"
SHould
have
had
a
nullptr
"
)
;
}
return
errno_copy
;
}
)
;
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
#
endif
}
}
