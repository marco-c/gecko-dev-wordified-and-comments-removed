#
include
"
SandboxTestingChild
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
ifdef
XP_UNIX
#
include
<
fcntl
.
h
>
#
include
<
netdb
.
h
>
#
ifdef
XP_LINUX
#
include
<
sys
/
prctl
.
h
>
#
include
<
sys
/
ioctl
.
h
>
#
include
<
termios
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
utsname
.
h
>
#
include
<
sched
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
un
.
h
>
#
include
"
mozilla
/
ProcInfo_linux
.
h
"
#
ifdef
MOZ_X11
#
include
"
X11
/
Xlib
.
h
"
#
include
"
X11UndefineNone
.
h
"
#
endif
#
endif
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
ifdef
XP_MACOSX
#
include
<
CoreGraphics
/
CoreGraphics
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
<
stdio
.
h
>
#
include
<
winternl
.
h
>
#
include
"
mozilla
/
DynamicallyLinkedFunctionPtr
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
endif
constexpr
bool
kIsDebug
=
#
ifdef
DEBUG
true
;
#
else
false
;
#
endif
namespace
mozilla
{
#
ifdef
XP_LINUX
static
void
RunTestsSched
(
SandboxTestingChild
*
child
)
{
struct
sched_param
param_pid_0
=
{
}
;
child
-
>
ErrnoTest
(
"
sched_getparam
(
0
)
"
_ns
true
[
&
]
{
return
sched_getparam
(
0
&
param_pid_0
)
;
}
)
;
struct
sched_param
param_pid_tid
=
{
}
;
child
-
>
ErrnoTest
(
"
sched_getparam
(
tid
)
"
_ns
true
[
&
]
{
return
sched_getparam
(
(
pid_t
)
syscall
(
__NR_gettid
)
&
param_pid_tid
)
;
}
)
;
struct
sched_param
param_pid_Ntid
=
{
}
;
child
-
>
ErrnoValueTest
(
"
sched_getparam
(
Ntid
)
"
_ns
EPERM
[
&
]
{
return
sched_getparam
(
(
pid_t
)
(
syscall
(
__NR_gettid
)
-
1
)
&
param_pid_Ntid
)
;
}
)
;
}
#
endif
#
ifdef
XP_WIN
static
void
FileTest
(
const
nsCString
&
aName
const
char
*
aSpecialDirName
const
nsString
&
aRelativeFilePath
ACCESS_MASK
aAccess
bool
aExpectSuccess
SandboxTestingChild
*
aChild
)
{
static
const
StaticDynamicallyLinkedFunctionPtr
<
decltype
(
&
NtCreateFile
)
>
pNtCreateFile
(
L
"
ntdll
.
dll
"
"
NtCreateFile
"
)
;
static
const
StaticDynamicallyLinkedFunctionPtr
<
decltype
(
&
NtClose
)
>
pNtClose
(
L
"
ntdll
.
dll
"
"
NtClose
"
)
;
nsString
testFilename
(
u
"
\
\
?
?
\
\
"
_ns
)
;
nsString
dirPath
;
aChild
-
>
SendGetSpecialDirectory
(
nsDependentCString
(
aSpecialDirName
)
&
dirPath
)
;
testFilename
.
Append
(
dirPath
)
;
testFilename
.
AppendLiteral
(
"
\
\
"
)
;
testFilename
.
Append
(
aRelativeFilePath
)
;
UNICODE_STRING
uniFileName
;
:
:
RtlInitUnicodeString
(
&
uniFileName
testFilename
.
get
(
)
)
;
OBJECT_ATTRIBUTES
objectAttributes
;
InitializeObjectAttributes
(
&
objectAttributes
&
uniFileName
OBJ_CASE_INSENSITIVE
nullptr
nullptr
)
;
HANDLE
fileHandle
=
INVALID_HANDLE_VALUE
;
IO_STATUS_BLOCK
ioStatusBlock
=
{
}
;
ULONG
createOptions
=
StringEndsWith
(
testFilename
u
"
\
\
"
_ns
)
|
|
StringEndsWith
(
testFilename
u
"
/
"
_ns
)
?
FILE_DIRECTORY_FILE
:
FILE_NON_DIRECTORY_FILE
;
NTSTATUS
status
=
pNtCreateFile
(
&
fileHandle
aAccess
&
objectAttributes
&
ioStatusBlock
nullptr
0
0
FILE_OPEN_IF
createOptions
|
FILE_SYNCHRONOUS_IO_NONALERT
nullptr
0
)
;
if
(
fileHandle
!
=
INVALID_HANDLE_VALUE
)
{
pNtClose
(
fileHandle
)
;
}
nsCString
accessString
;
if
(
(
aAccess
&
FILE_GENERIC_READ
)
=
=
FILE_GENERIC_READ
)
{
accessString
.
AppendLiteral
(
"
r
"
)
;
}
if
(
(
aAccess
&
FILE_GENERIC_WRITE
)
=
=
FILE_GENERIC_WRITE
)
{
accessString
.
AppendLiteral
(
"
w
"
)
;
}
if
(
(
aAccess
&
FILE_GENERIC_EXECUTE
)
=
=
FILE_GENERIC_EXECUTE
)
{
accessString
.
AppendLiteral
(
"
e
"
)
;
}
nsCString
msgRelPath
=
NS_ConvertUTF16toUTF8
(
aRelativeFilePath
)
;
for
(
size_t
i
=
0
j
=
0
;
i
<
aRelativeFilePath
.
Length
(
)
;
+
+
i
+
+
j
)
{
if
(
aRelativeFilePath
[
i
]
=
=
u
'
\
\
'
)
{
msgRelPath
.
Insert
(
'
\
\
'
j
+
+
)
;
}
}
nsCString
message
;
message
.
AppendPrintf
(
"
Special
dir
:
%
s
file
:
%
s
access
:
%
s
returned
status
:
%
lx
"
aSpecialDirName
msgRelPath
.
get
(
)
accessString
.
get
(
)
status
)
;
aChild
-
>
SendReportTestResults
(
aName
aExpectSuccess
=
=
NT_SUCCESS
(
status
)
message
)
;
}
#
endif
void
RunTestsContent
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
struct
stat
st
;
static
const
char
kAllowedPath
[
]
=
"
/
usr
/
lib
"
;
child
-
>
ErrnoTest
(
"
fstatat_as_stat
"
_ns
true
[
&
]
{
return
fstatat
(
AT_FDCWD
kAllowedPath
&
st
0
)
;
}
)
;
child
-
>
ErrnoTest
(
"
fstatat_as_lstat
"
_ns
true
[
&
]
{
return
fstatat
(
AT_FDCWD
kAllowedPath
&
st
AT_SYMLINK_NOFOLLOW
)
;
}
)
;
#
ifdef
XP_LINUX
child
-
>
ErrnoTest
(
"
fstatat_as_fstat
"
_ns
true
[
&
]
{
return
fstatat
(
0
"
"
&
st
AT_EMPTY_PATH
)
;
}
)
;
const
struct
timespec
usec
=
{
0
1000
}
;
child
-
>
ErrnoTest
(
"
nanosleep
"
_ns
true
[
&
]
{
return
nanosleep
(
&
usec
nullptr
)
;
}
)
;
struct
timespec
res
=
{
0
0
}
;
child
-
>
ErrnoTest
(
"
clock_getres
"
_ns
true
[
&
]
{
return
clock_getres
(
CLOCK_REALTIME
&
res
)
;
}
)
;
struct
timespec
tproc
=
{
0
0
}
;
clockid_t
same_process
=
MAKE_PROCESS_CPUCLOCK
(
getpid
(
)
CPUCLOCK_SCHED
)
;
child
-
>
ErrnoTest
(
"
clock_gettime_same_process
"
_ns
true
[
&
]
{
return
clock_gettime
(
same_process
&
tproc
)
;
}
)
;
struct
timespec
tprocd
=
{
0
0
}
;
clockid_t
diff_process
=
MAKE_PROCESS_CPUCLOCK
(
1
CPUCLOCK_SCHED
)
;
child
-
>
ErrnoValueTest
(
"
clock_gettime_diff_process
"
_ns
ENOSYS
[
&
]
{
return
clock_gettime
(
diff_process
&
tprocd
)
;
}
)
;
struct
timespec
tthread
=
{
0
0
}
;
clockid_t
thread
=
MAKE_THREAD_CPUCLOCK
(
(
pid_t
)
syscall
(
__NR_gettid
)
CPUCLOCK_SCHED
)
;
child
-
>
ErrnoTest
(
"
clock_gettime_thread
"
_ns
true
[
&
]
{
return
clock_gettime
(
thread
&
tthread
)
;
}
)
;
int
c
;
child
-
>
ErrnoTest
(
"
getcpu
"
_ns
true
[
&
]
{
return
syscall
(
SYS_getcpu
&
c
NULL
NULL
)
;
}
)
;
child
-
>
ErrnoValueTest
(
"
connect_abstract_blocked
"
_ns
ENETUNREACH
[
&
]
{
int
sockfd
;
struct
sockaddr_un
addr
;
char
str
[
]
=
"
\
0xyz
"
;
size_t
str_size
=
4
;
memset
(
&
addr
0
sizeof
(
struct
sockaddr_un
)
)
;
addr
.
sun_family
=
AF_UNIX
;
memcpy
(
&
addr
.
sun_path
str
str_size
)
;
sockfd
=
socket
(
AF_UNIX
SOCK_STREAM
0
)
;
if
(
sockfd
=
=
-
1
)
{
return
-
1
;
}
int
con_st
=
connect
(
sockfd
(
struct
sockaddr
*
)
&
addr
sizeof
(
sa_family_t
)
+
str_size
)
;
return
con_st
;
}
)
;
const
int
errorForX
=
StaticPrefs
:
:
security_sandbox_content_headless_AtStartup
(
)
?
EACCES
:
ECONNREFUSED
;
child
-
>
ErrnoValueTest
(
"
connect_abstract_permit
"
_ns
errorForX
[
&
]
{
int
sockfd
;
struct
sockaddr_un
addr
;
char
str
[
]
=
"
\
0
/
tmp
/
.
X11
-
unix
/
X
"
;
size_t
str_size
=
17
;
memset
(
&
addr
0
sizeof
(
struct
sockaddr_un
)
)
;
addr
.
sun_family
=
AF_UNIX
;
memcpy
(
&
addr
.
sun_path
str
str_size
)
;
sockfd
=
socket
(
AF_UNIX
SOCK_STREAM
0
)
;
if
(
sockfd
=
=
-
1
)
{
return
-
1
;
}
int
con_st
=
connect
(
sockfd
(
struct
sockaddr
*
)
&
addr
sizeof
(
sa_family_t
)
+
str_size
)
;
return
con_st
;
}
)
;
std
:
:
vector
<
std
:
:
pair
<
const
char
*
bool
>
>
open_tests
=
{
{
"
/
dev
/
random
"
true
}
}
;
if
(
stat
(
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
&
st
)
=
=
0
)
{
open_tests
.
push_back
(
{
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
true
}
)
;
}
for
(
const
std
:
:
pair
<
const
char
*
bool
>
&
to_open
:
open_tests
)
{
child
-
>
ErrnoTest
(
"
open
(
"
_ns
+
nsCString
(
to_open
.
first
)
+
"
)
"
_ns
to_open
.
second
[
&
]
{
int
fd
=
open
(
to_open
.
first
O_RDONLY
)
;
if
(
to_open
.
second
&
&
fd
>
0
)
{
close
(
fd
)
;
}
return
fd
;
}
)
;
}
#
ifdef
MOZ_X11
if
(
PR_GetEnv
(
"
DISPLAY
"
)
)
{
Display
*
disp
=
XOpenDisplay
(
nullptr
)
;
child
-
>
SendReportTestResults
(
"
x11_access
"
_ns
!
disp
disp
?
"
XOpenDisplay
succeeded
"
_ns
:
"
XOpenDisplay
failed
"
_ns
)
;
if
(
disp
)
{
XCloseDisplay
(
disp
)
;
}
}
#
endif
#
endif
#
ifdef
XP_MACOSX
CFDictionaryRef
windowServerDict
=
CGSessionCopyCurrentDictionary
(
)
;
bool
gotWindowServerDetails
=
(
windowServerDict
!
=
nullptr
)
;
child
-
>
SendReportTestResults
(
"
CGSessionCopyCurrentDictionary
"
_ns
!
gotWindowServerDetails
gotWindowServerDetails
?
"
Failed
:
dictionary
unexpectedly
returned
"
_ns
:
"
Succeeded
:
no
dictionary
returned
"
_ns
)
;
if
(
windowServerDict
!
=
nullptr
)
{
CFRelease
(
windowServerDict
)
;
}
#
endif
#
elif
XP_WIN
FileTest
(
"
read
from
chrome
"
_ns
NS_APP_USER_CHROME_DIR
u
"
sandboxTest
.
txt
"
_ns
FILE_GENERIC_READ
true
child
)
;
FileTest
(
"
read
from
profile
via
relative
path
"
_ns
NS_APP_USER_CHROME_DIR
u
"
.
.
\
\
sandboxTest
.
txt
"
_ns
FILE_GENERIC_READ
false
child
)
;
FileTest
(
"
read
from
chrome
using
forward
slash
"
_ns
NS_APP_USER_PROFILE_50_DIR
u
"
chrome
/
sandboxTest
.
txt
"
_ns
FILE_GENERIC_READ
false
child
)
;
FileTest
(
"
read
from
profile
"
_ns
NS_APP_USER_PROFILE_50_DIR
u
"
sandboxTest
.
txt
"
_ns
FILE_GENERIC_READ
kIsDebug
child
)
;
FileTest
(
"
read
/
write
from
chrome
"
_ns
NS_APP_USER_CHROME_DIR
u
"
sandboxTest
.
txt
"
_ns
FILE_GENERIC_READ
|
FILE_GENERIC_WRITE
kIsDebug
child
)
;
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
}
void
RunTestsSocket
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
child
-
>
ErrnoTest
(
"
getaddrinfo
"
_ns
true
[
&
]
{
struct
addrinfo
*
res
;
int
rv
=
getaddrinfo
(
"
localhost
"
nullptr
nullptr
&
res
)
;
if
(
res
!
=
nullptr
)
{
freeaddrinfo
(
res
)
;
}
return
rv
;
}
)
;
#
ifdef
XP_LINUX
child
-
>
ErrnoTest
(
"
prctl_allowed
"
_ns
true
[
&
]
{
int
rv
=
prctl
(
PR_SET_DUMPABLE
0
0
0
0
)
;
return
rv
;
}
)
;
child
-
>
ErrnoTest
(
"
prctl_blocked
"
_ns
false
[
&
]
{
int
rv
=
prctl
(
PR_GET_SECCOMP
0
0
0
0
)
;
return
rv
;
}
)
;
std
:
:
vector
<
std
:
:
pair
<
const
char
*
bool
>
>
open_tests
=
{
{
"
/
dev
/
random
"
true
}
}
;
struct
stat
st
;
if
(
stat
(
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
&
st
)
=
=
0
)
{
open_tests
.
push_back
(
{
"
/
proc
/
sys
/
crypto
/
fips_enabled
"
true
}
)
;
}
for
(
const
std
:
:
pair
<
const
char
*
bool
>
&
to_open
:
open_tests
)
{
child
-
>
ErrnoTest
(
"
open
(
"
_ns
+
nsCString
(
to_open
.
first
)
+
"
)
"
_ns
to_open
.
second
[
&
]
{
int
fd
=
open
(
to_open
.
first
O_RDONLY
)
;
if
(
to_open
.
second
&
&
fd
>
0
)
{
close
(
fd
)
;
}
return
fd
;
}
)
;
}
int
c
;
child
-
>
ErrnoTest
(
"
getcpu
"
_ns
true
[
&
]
{
return
syscall
(
SYS_getcpu
&
c
NULL
NULL
)
;
}
)
;
#
endif
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
}
void
RunTestsRDD
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
#
ifdef
XP_LINUX
child
-
>
ErrnoValueTest
(
"
ioctl_tiocsti
"
_ns
ENOSYS
[
&
]
{
int
rv
=
ioctl
(
1
TIOCSTI
"
x
"
)
;
return
rv
;
}
)
;
struct
rusage
res
=
{
}
;
child
-
>
ErrnoTest
(
"
getrusage
"
_ns
true
[
&
]
{
int
rv
=
getrusage
(
RUSAGE_SELF
&
res
)
;
return
rv
;
}
)
;
child
-
>
ErrnoValueTest
(
"
unlink
"
_ns
ENOENT
[
&
]
{
int
rv
=
unlink
(
"
"
)
;
return
rv
;
}
)
;
child
-
>
ErrnoValueTest
(
"
unlinkat
"
_ns
ENOENT
[
&
]
{
int
rv
=
unlinkat
(
AT_FDCWD
"
"
0
)
;
return
rv
;
}
)
;
RunTestsSched
(
child
)
;
child
-
>
ErrnoTest
(
"
socket
"
_ns
false
[
]
{
return
socket
(
AF_UNIX
SOCK_STREAM
0
)
;
}
)
;
child
-
>
ErrnoTest
(
"
uname
"
_ns
true
[
]
{
struct
utsname
uts
;
return
uname
(
&
uts
)
;
}
)
;
child
-
>
ErrnoValueTest
(
"
ioctl_dma_buf
"
_ns
ENOTTY
[
]
{
return
ioctl
(
0
_IOW
(
'
b
'
0
uint64_t
)
nullptr
)
;
}
)
;
int
c
;
child
-
>
ErrnoTest
(
"
getcpu
"
_ns
true
[
&
]
{
return
syscall
(
SYS_getcpu
&
c
NULL
NULL
)
;
}
)
;
#
endif
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
}
void
RunTestsGMPlugin
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
#
ifdef
XP_LINUX
struct
utsname
utsname_res
=
{
}
;
child
-
>
ErrnoTest
(
"
uname_restricted
"
_ns
true
[
&
]
{
int
rv
=
uname
(
&
utsname_res
)
;
nsCString
expectedSysname
(
"
Linux
"
_ns
)
;
nsCString
sysname
(
utsname_res
.
sysname
)
;
nsCString
expectedVersion
(
"
3
"
_ns
)
;
nsCString
version
(
utsname_res
.
version
)
;
if
(
(
sysname
!
=
expectedSysname
)
|
|
(
version
!
=
expectedVersion
)
)
{
return
-
1
;
}
return
rv
;
}
)
;
child
-
>
ErrnoTest
(
"
getuid
"
_ns
true
[
&
]
{
return
getuid
(
)
;
}
)
;
child
-
>
ErrnoTest
(
"
getgid
"
_ns
true
[
&
]
{
return
getgid
(
)
;
}
)
;
child
-
>
ErrnoTest
(
"
geteuid
"
_ns
true
[
&
]
{
return
geteuid
(
)
;
}
)
;
child
-
>
ErrnoTest
(
"
getegid
"
_ns
true
[
&
]
{
return
getegid
(
)
;
}
)
;
RunTestsSched
(
child
)
;
std
:
:
vector
<
std
:
:
pair
<
const
char
*
bool
>
>
open_tests
=
{
{
"
/
etc
/
ld
.
so
.
cache
"
true
}
{
"
/
proc
/
cpuinfo
"
true
}
{
"
/
etc
/
hostname
"
false
}
}
;
for
(
const
std
:
:
pair
<
const
char
*
bool
>
&
to_open
:
open_tests
)
{
child
-
>
ErrnoTest
(
"
open
(
"
_ns
+
nsCString
(
to_open
.
first
)
+
"
)
"
_ns
to_open
.
second
[
&
]
{
int
fd
=
open
(
to_open
.
first
O_RDONLY
)
;
if
(
to_open
.
second
&
&
fd
>
0
)
{
close
(
fd
)
;
}
return
fd
;
}
)
;
}
#
endif
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
}
void
RunTestsUtility
(
SandboxTestingChild
*
child
)
{
MOZ_ASSERT
(
child
"
No
SandboxTestingChild
*
?
"
)
;
#
ifdef
XP_UNIX
#
ifdef
XP_LINUX
child
-
>
ErrnoValueTest
(
"
ioctl_tiocsti
"
_ns
ENOSYS
[
&
]
{
int
rv
=
ioctl
(
1
TIOCSTI
"
x
"
)
;
return
rv
;
}
)
;
struct
rusage
res
;
child
-
>
ErrnoTest
(
"
getrusage
"
_ns
true
[
&
]
{
int
rv
=
getrusage
(
RUSAGE_SELF
&
res
)
;
return
rv
;
}
)
;
#
endif
#
else
#
ifdef
XP_WIN
child
-
>
ErrnoValueTest
(
"
write_only
"
_ns
EACCES
[
&
]
{
FILE
*
rv
=
fopen
(
"
test_sandbox
.
txt
"
"
w
"
)
;
if
(
rv
!
=
nullptr
)
{
fclose
(
rv
)
;
return
0
;
}
return
-
1
;
}
)
;
#
else
child
-
>
ReportNoTests
(
)
;
#
endif
#
endif
}
}
