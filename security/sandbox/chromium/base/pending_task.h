#
ifndef
BASE_PENDING_TASK_H_
#
define
BASE_PENDING_TASK_H_
#
include
<
array
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
functional
/
callback
.
h
"
#
include
"
base
/
location
.
h
"
#
include
"
base
/
task
/
delay_policy
.
h
"
#
include
"
base
/
time
/
time
.
h
"
namespace
base
{
enum
class
Nestable
:
uint8_t
{
kNonNestable
kNestable
}
;
struct
BASE_EXPORT
PendingTask
{
PendingTask
(
)
;
PendingTask
(
const
Location
&
posted_from
OnceClosure
task
TimeTicks
queue_time
=
TimeTicks
(
)
TimeTicks
delayed_run_time
=
TimeTicks
(
)
TimeDelta
leeway
=
TimeDelta
(
)
subtle
:
:
DelayPolicy
delay_policy
=
subtle
:
:
DelayPolicy
:
:
kFlexibleNoSooner
)
;
PendingTask
(
PendingTask
&
&
other
)
;
~
PendingTask
(
)
;
PendingTask
&
operator
=
(
PendingTask
&
&
other
)
;
base
:
:
TimeTicks
GetDesiredExecutionTime
(
)
const
;
TimeTicks
earliest_delayed_run_time
(
)
const
;
TimeTicks
latest_delayed_run_time
(
)
const
;
OnceClosure
task
;
Location
posted_from
;
TimeTicks
queue_time
;
base
:
:
TimeTicks
delayed_run_time
;
TimeDelta
leeway
;
subtle
:
:
DelayPolicy
delay_policy
=
subtle
:
:
DelayPolicy
:
:
kFlexibleNoSooner
;
static
constexpr
size_t
kTaskBacktraceLength
=
4
;
std
:
:
array
<
const
void
*
kTaskBacktraceLength
>
task_backtrace
=
{
}
;
uint32_t
ipc_hash
=
0
;
const
char
*
ipc_interface_name
=
nullptr
;
int
sequence_num
=
0
;
bool
task_backtrace_overflow
=
false
;
}
;
}
#
endif
