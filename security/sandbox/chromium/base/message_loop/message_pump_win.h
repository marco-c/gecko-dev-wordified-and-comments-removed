#
ifndef
BASE_MESSAGE_LOOP_MESSAGE_PUMP_WIN_H_
#
define
BASE_MESSAGE_LOOP_MESSAGE_PUMP_WIN_H_
#
include
<
windows
.
h
>
#
include
<
atomic
>
#
include
<
memory
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
location
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
#
include
"
base
/
message_loop
/
message_pump
.
h
"
#
include
"
base
/
observer_list
.
h
"
#
include
"
base
/
threading
/
thread_checker
.
h
"
#
include
"
base
/
time
/
time
.
h
"
#
include
"
base
/
win
/
message_window
.
h
"
#
include
"
base
/
win
/
scoped_handle
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
namespace
base
{
class
BASE_EXPORT
MessagePumpWin
:
public
MessagePump
{
public
:
MessagePumpWin
(
)
;
~
MessagePumpWin
(
)
override
;
void
Run
(
Delegate
*
delegate
)
override
;
void
Quit
(
)
override
;
protected
:
struct
RunState
{
explicit
RunState
(
Delegate
*
delegate_in
)
:
delegate
(
delegate_in
)
{
}
const
raw_ptr
<
Delegate
>
delegate
;
bool
should_quit
=
false
;
bool
is_nested
=
false
;
}
;
virtual
void
DoRunLoop
(
)
=
0
;
std
:
:
atomic_bool
work_scheduled_
{
false
}
;
RAW_PTR_EXCLUSION
RunState
*
run_state_
=
nullptr
;
THREAD_CHECKER
(
bound_thread_
)
;
}
;
class
BASE_EXPORT
MessagePumpForUI
:
public
MessagePumpWin
{
public
:
MessagePumpForUI
(
)
;
~
MessagePumpForUI
(
)
override
;
void
ScheduleWork
(
)
override
;
void
ScheduleDelayedWork
(
const
Delegate
:
:
NextWorkInfo
&
next_work_info
)
override
;
class
BASE_EXPORT
Observer
{
public
:
virtual
void
WillDispatchMSG
(
const
MSG
&
msg
)
=
0
;
virtual
void
DidDispatchMSG
(
const
MSG
&
msg
)
=
0
;
}
;
void
AddObserver
(
Observer
*
observer
)
;
void
RemoveObserver
(
Observer
*
obseerver
)
;
private
:
bool
MessageCallback
(
UINT
message
WPARAM
wparam
LPARAM
lparam
LRESULT
*
result
)
;
void
DoRunLoop
(
)
override
;
NOINLINE
NOT_TAIL_CALLED
void
WaitForWork
(
Delegate
:
:
NextWorkInfo
next_work_info
)
;
void
HandleWorkMessage
(
)
;
void
HandleTimerMessage
(
)
;
void
ScheduleNativeTimer
(
Delegate
:
:
NextWorkInfo
next_work_info
)
;
void
KillNativeTimer
(
)
;
bool
ProcessNextWindowsMessage
(
)
;
bool
ProcessMessageHelper
(
const
MSG
&
msg
)
;
bool
ProcessPumpReplacementMessage
(
)
;
base
:
:
win
:
:
MessageWindow
message_window_
;
absl
:
:
optional
<
TimeTicks
>
installed_native_timer_
;
bool
in_native_loop_
=
false
;
ObserverList
<
Observer
>
:
:
Unchecked
observers_
;
}
;
class
BASE_EXPORT
MessagePumpForIO
:
public
MessagePumpWin
{
public
:
struct
BASE_EXPORT
IOContext
{
IOContext
(
)
;
OVERLAPPED
overlapped
;
}
;
class
BASE_EXPORT
IOHandler
{
public
:
explicit
IOHandler
(
const
Location
&
from_here
)
;
virtual
~
IOHandler
(
)
;
IOHandler
(
const
IOHandler
&
)
=
delete
;
IOHandler
&
operator
=
(
const
IOHandler
&
)
=
delete
;
virtual
void
OnIOCompleted
(
IOContext
*
context
DWORD
bytes_transfered
DWORD
error
)
=
0
;
const
Location
&
io_handler_location
(
)
{
return
io_handler_location_
;
}
private
:
const
Location
io_handler_location_
;
}
;
MessagePumpForIO
(
)
;
~
MessagePumpForIO
(
)
override
;
void
ScheduleWork
(
)
override
;
void
ScheduleDelayedWork
(
const
Delegate
:
:
NextWorkInfo
&
next_work_info
)
override
;
HRESULT
RegisterIOHandler
(
HANDLE
file_handle
IOHandler
*
handler
)
;
bool
RegisterJobObject
(
HANDLE
job_handle
IOHandler
*
handler
)
;
private
:
struct
IOItem
{
raw_ptr
<
IOHandler
>
handler
;
raw_ptr
<
IOContext
>
context
;
DWORD
bytes_transfered
;
DWORD
error
;
}
;
void
DoRunLoop
(
)
override
;
NOINLINE
NOT_TAIL_CALLED
void
WaitForWork
(
Delegate
:
:
NextWorkInfo
next_work_info
)
;
bool
GetIOItem
(
DWORD
timeout
IOItem
*
item
)
;
bool
ProcessInternalIOItem
(
const
IOItem
&
item
)
;
bool
WaitForIOCompletion
(
DWORD
timeout
)
;
win
:
:
ScopedHandle
port_
;
}
;
}
#
endif
