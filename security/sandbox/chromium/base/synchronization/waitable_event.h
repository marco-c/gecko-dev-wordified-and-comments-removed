#
ifndef
BASE_SYNCHRONIZATION_WAITABLE_EVENT_H_
#
define
BASE_SYNCHRONIZATION_WAITABLE_EVENT_H_
#
include
<
stddef
.
h
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
#
include
"
base
/
win
/
scoped_handle
.
h
"
#
elif
BUILDFLAG
(
IS_APPLE
)
#
include
<
mach
/
mach
.
h
>
#
include
<
list
>
#
include
<
memory
>
#
include
"
base
/
apple
/
scoped_mach_port
.
h
"
#
include
"
base
/
functional
/
callback_forward
.
h
"
#
include
"
base
/
memory
/
ref_counted
.
h
"
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
#
include
<
list
>
#
include
<
utility
>
#
include
"
base
/
memory
/
ref_counted
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
endif
namespace
base
{
class
TimeDelta
;
class
BASE_EXPORT
WaitableEvent
{
public
:
enum
class
ResetPolicy
{
MANUAL
AUTOMATIC
}
;
enum
class
InitialState
{
SIGNALED
NOT_SIGNALED
}
;
WaitableEvent
(
ResetPolicy
reset_policy
=
ResetPolicy
:
:
MANUAL
InitialState
initial_state
=
InitialState
:
:
NOT_SIGNALED
)
;
#
if
BUILDFLAG
(
IS_WIN
)
explicit
WaitableEvent
(
win
:
:
ScopedHandle
event_handle
)
;
#
endif
WaitableEvent
(
const
WaitableEvent
&
)
=
delete
;
WaitableEvent
&
operator
=
(
const
WaitableEvent
&
)
=
delete
;
~
WaitableEvent
(
)
;
void
Reset
(
)
;
void
Signal
(
)
;
bool
IsSignaled
(
)
;
NOT_TAIL_CALLED
void
Wait
(
)
;
NOT_TAIL_CALLED
bool
TimedWait
(
TimeDelta
wait_delta
)
;
#
if
BUILDFLAG
(
IS_WIN
)
HANDLE
handle
(
)
const
{
return
handle_
.
get
(
)
;
}
#
endif
void
declare_only_used_while_idle
(
)
{
only_used_while_idle_
=
true
;
}
NOT_TAIL_CALLED
static
size_t
WaitMany
(
WaitableEvent
*
*
waitables
size_t
count
)
;
class
Waiter
{
public
:
virtual
bool
Fire
(
WaitableEvent
*
signaling_event
)
=
0
;
virtual
bool
Compare
(
void
*
tag
)
=
0
;
protected
:
virtual
~
Waiter
(
)
=
default
;
}
;
private
:
friend
class
WaitableEventWatcher
;
void
SignalImpl
(
)
;
bool
TimedWaitImpl
(
TimeDelta
wait_delta
)
;
#
if
BUILDFLAG
(
IS_WIN
)
win
:
:
ScopedHandle
handle_
;
#
elif
BUILDFLAG
(
IS_APPLE
)
static
bool
PeekPort
(
mach_port_t
port
bool
dequeue
)
;
class
ReceiveRight
:
public
RefCountedThreadSafe
<
ReceiveRight
>
{
public
:
explicit
ReceiveRight
(
mach_port_t
name
)
;
ReceiveRight
(
const
ReceiveRight
&
)
=
delete
;
ReceiveRight
&
operator
=
(
const
ReceiveRight
&
)
=
delete
;
mach_port_t
Name
(
)
const
{
return
right_
.
get
(
)
;
}
private
:
friend
class
RefCountedThreadSafe
<
ReceiveRight
>
;
~
ReceiveRight
(
)
;
apple
:
:
ScopedMachReceiveRight
right_
;
}
;
const
ResetPolicy
policy_
;
scoped_refptr
<
ReceiveRight
>
receive_right_
;
apple
:
:
ScopedMachSendRight
send_right_
;
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
struct
WaitableEventKernel
:
public
RefCountedThreadSafe
<
WaitableEventKernel
>
{
public
:
WaitableEventKernel
(
ResetPolicy
reset_policy
InitialState
initial_state
)
;
bool
Dequeue
(
Waiter
*
waiter
void
*
tag
)
;
base
:
:
Lock
lock_
;
const
bool
manual_reset_
;
bool
signaled_
;
std
:
:
list
<
Waiter
*
>
waiters_
;
private
:
friend
class
RefCountedThreadSafe
<
WaitableEventKernel
>
;
~
WaitableEventKernel
(
)
;
}
;
typedef
std
:
:
pair
<
WaitableEvent
*
size_t
>
WaiterAndIndex
;
static
size_t
EnqueueMany
(
WaiterAndIndex
*
waitables
size_t
count
Waiter
*
waiter
)
;
bool
SignalAll
(
)
;
bool
SignalOne
(
)
;
void
Enqueue
(
Waiter
*
waiter
)
;
scoped_refptr
<
WaitableEventKernel
>
kernel_
;
#
endif
bool
only_used_while_idle_
=
false
;
}
;
}
#
endif
