#
include
"
base
/
cpu
.
h
"
#
include
<
inttypes
.
h
>
#
include
<
limits
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
sstream
>
#
include
<
utility
>
#
include
"
base
/
no_destructor
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
defined
(
ARCH_CPU_ARM_FAMILY
)
&
&
\
(
BUILDFLAG
(
IS_ANDROID
)
|
|
BUILDFLAG
(
IS_LINUX
)
|
|
BUILDFLAG
(
IS_CHROMEOS
)
)
#
include
<
asm
/
hwcap
.
h
>
#
include
<
sys
/
auxv
.
h
>
#
include
"
base
/
files
/
file_util
.
h
"
#
include
"
base
/
numerics
/
checked_math
.
h
"
#
include
"
base
/
ranges
/
algorithm
.
h
"
#
include
"
base
/
strings
/
string_number_conversions
.
h
"
#
include
"
base
/
strings
/
string_split
.
h
"
#
include
"
base
/
strings
/
string_util
.
h
"
#
ifndef
HWCAP2_MTE
#
define
HWCAP2_MTE
(
1
<
<
18
)
#
define
HWCAP2_BTI
(
1
<
<
17
)
#
endif
struct
ProcCpuInfo
{
std
:
:
string
brand
;
uint8_t
implementer
=
0
;
uint32_t
part_number
=
0
;
}
;
#
endif
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
#
if
defined
(
COMPILER_MSVC
)
#
include
<
intrin
.
h
>
#
include
<
immintrin
.
h
>
#
endif
#
endif
namespace
base
{
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
namespace
internal
{
X86ModelInfo
ComputeX86FamilyAndModel
(
const
std
:
:
string
&
vendor
int
signature
)
{
X86ModelInfo
results
;
results
.
family
=
(
signature
>
>
8
)
&
0xf
;
results
.
model
=
(
signature
>
>
4
)
&
0xf
;
results
.
ext_family
=
0
;
results
.
ext_model
=
0
;
if
(
results
.
family
=
=
0xf
|
|
(
results
.
family
=
=
0x6
&
&
vendor
=
=
"
GenuineIntel
"
)
)
{
results
.
ext_model
=
(
signature
>
>
16
)
&
0xf
;
results
.
model
+
=
results
.
ext_model
<
<
4
;
}
if
(
results
.
family
=
=
0xf
)
{
results
.
ext_family
=
(
signature
>
>
20
)
&
0xff
;
results
.
family
+
=
results
.
ext_family
;
}
return
results
;
}
}
#
endif
CPU
:
:
CPU
(
bool
require_branding
)
{
Initialize
(
require_branding
)
;
}
CPU
:
:
CPU
(
)
:
CPU
(
true
)
{
}
CPU
:
:
CPU
(
CPU
&
&
)
=
default
;
namespace
{
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
#
if
!
defined
(
COMPILER_MSVC
)
#
if
defined
(
__pic__
)
&
&
defined
(
__i386__
)
void
__cpuid
(
int
cpu_info
[
4
]
int
info_type
)
{
__asm__
volatile
(
"
mov
%
%
ebx
%
%
edi
\
n
"
"
cpuid
\
n
"
"
xchg
%
%
edi
%
%
ebx
\
n
"
:
"
=
a
"
(
cpu_info
[
0
]
)
"
=
D
"
(
cpu_info
[
1
]
)
"
=
c
"
(
cpu_info
[
2
]
)
"
=
d
"
(
cpu_info
[
3
]
)
:
"
a
"
(
info_type
)
"
c
"
(
0
)
)
;
}
#
else
void
__cpuid
(
int
cpu_info
[
4
]
int
info_type
)
{
__asm__
volatile
(
"
cpuid
\
n
"
:
"
=
a
"
(
cpu_info
[
0
]
)
"
=
b
"
(
cpu_info
[
1
]
)
"
=
c
"
(
cpu_info
[
2
]
)
"
=
d
"
(
cpu_info
[
3
]
)
:
"
a
"
(
info_type
)
"
c
"
(
0
)
)
;
}
#
endif
#
endif
uint64_t
xgetbv
(
uint32_t
xcr
)
{
#
if
defined
(
COMPILER_MSVC
)
return
_xgetbv
(
xcr
)
;
#
else
uint32_t
eax
edx
;
__asm__
volatile
(
"
xgetbv
"
:
"
=
a
"
(
eax
)
"
=
d
"
(
edx
)
:
"
c
"
(
xcr
)
)
;
return
(
static_cast
<
uint64_t
>
(
edx
)
<
<
32
)
|
eax
;
#
endif
}
#
endif
#
if
defined
(
ARCH_CPU_ARM_FAMILY
)
&
&
\
(
BUILDFLAG
(
IS_ANDROID
)
|
|
BUILDFLAG
(
IS_LINUX
)
|
|
BUILDFLAG
(
IS_CHROMEOS
)
)
StringPairs
:
:
const_iterator
FindFirstProcCpuKey
(
const
StringPairs
&
pairs
StringPiece
key
)
{
return
ranges
:
:
find_if
(
pairs
[
key
]
(
const
StringPairs
:
:
value_type
&
pair
)
{
return
TrimWhitespaceASCII
(
pair
.
first
base
:
:
TRIM_ALL
)
=
=
key
;
}
)
;
}
const
ProcCpuInfo
&
ParseProcCpu
(
)
{
static
const
NoDestructor
<
ProcCpuInfo
>
info
(
[
]
(
)
{
const
char
kModelNamePrefix
[
]
=
"
model
name
"
;
const
char
kProcessorPrefix
[
]
=
"
Processor
"
;
std
:
:
string
cpuinfo
;
ReadFileToString
(
FilePath
(
"
/
proc
/
cpuinfo
"
)
&
cpuinfo
)
;
DCHECK
(
!
cpuinfo
.
empty
(
)
)
;
ProcCpuInfo
info
;
StringPairs
pairs
;
if
(
!
SplitStringIntoKeyValuePairs
(
cpuinfo
'
:
'
'
\
n
'
&
pairs
)
)
{
NOTREACHED
(
)
;
return
info
;
}
auto
model_name
=
FindFirstProcCpuKey
(
pairs
kModelNamePrefix
)
;
if
(
model_name
=
=
pairs
.
end
(
)
)
model_name
=
FindFirstProcCpuKey
(
pairs
kProcessorPrefix
)
;
if
(
model_name
!
=
pairs
.
end
(
)
)
{
info
.
brand
=
std
:
:
string
(
TrimWhitespaceASCII
(
model_name
-
>
second
TRIM_ALL
)
)
;
}
auto
implementer_string
=
FindFirstProcCpuKey
(
pairs
"
CPU
implementer
"
)
;
if
(
implementer_string
!
=
pairs
.
end
(
)
)
{
uint32_t
implementer
;
HexStringToUInt
(
implementer_string
-
>
second
&
implementer
)
;
if
(
!
CheckedNumeric
<
uint32_t
>
(
implementer
)
.
AssignIfValid
(
&
info
.
implementer
)
)
{
info
.
implementer
=
0
;
}
}
auto
part_number_string
=
FindFirstProcCpuKey
(
pairs
"
CPU
part
"
)
;
if
(
part_number_string
!
=
pairs
.
end
(
)
)
HexStringToUInt
(
part_number_string
-
>
second
&
info
.
part_number
)
;
return
info
;
}
(
)
)
;
return
*
info
;
}
#
endif
}
void
CPU
:
:
Initialize
(
bool
require_branding
)
{
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
int
cpu_info
[
4
]
=
{
-
1
}
;
char
cpu_string
[
sizeof
(
cpu_info
)
*
3
+
1
]
;
__cpuid
(
cpu_info
0
)
;
int
num_ids
=
cpu_info
[
0
]
;
std
:
:
swap
(
cpu_info
[
2
]
cpu_info
[
3
]
)
;
static
constexpr
size_t
kVendorNameSize
=
3
*
sizeof
(
cpu_info
[
1
]
)
;
static_assert
(
kVendorNameSize
<
std
:
:
size
(
cpu_string
)
"
cpu_string
too
small
"
)
;
memcpy
(
cpu_string
&
cpu_info
[
1
]
kVendorNameSize
)
;
cpu_string
[
kVendorNameSize
]
=
'
\
0
'
;
cpu_vendor_
=
cpu_string
;
if
(
num_ids
>
0
)
{
int
cpu_info7
[
4
]
=
{
0
}
;
__cpuid
(
cpu_info
1
)
;
if
(
num_ids
>
=
7
)
{
__cpuid
(
cpu_info7
7
)
;
}
signature_
=
cpu_info
[
0
]
;
stepping_
=
cpu_info
[
0
]
&
0xf
;
type_
=
(
cpu_info
[
0
]
>
>
12
)
&
0x3
;
internal
:
:
X86ModelInfo
results
=
internal
:
:
ComputeX86FamilyAndModel
(
cpu_vendor_
signature_
)
;
family_
=
results
.
family
;
model_
=
results
.
model
;
ext_family_
=
results
.
ext_family
;
ext_model_
=
results
.
ext_model
;
has_mmx_
=
(
cpu_info
[
3
]
&
0x00800000
)
!
=
0
;
has_sse_
=
(
cpu_info
[
3
]
&
0x02000000
)
!
=
0
;
has_sse2_
=
(
cpu_info
[
3
]
&
0x04000000
)
!
=
0
;
has_sse3_
=
(
cpu_info
[
2
]
&
0x00000001
)
!
=
0
;
has_ssse3_
=
(
cpu_info
[
2
]
&
0x00000200
)
!
=
0
;
has_sse41_
=
(
cpu_info
[
2
]
&
0x00080000
)
!
=
0
;
has_sse42_
=
(
cpu_info
[
2
]
&
0x00100000
)
!
=
0
;
has_popcnt_
=
(
cpu_info
[
2
]
&
0x00800000
)
!
=
0
;
is_running_in_vm_
=
(
static_cast
<
uint32_t
>
(
cpu_info
[
2
]
)
&
0x80000000
)
!
=
0
;
has_avx_
=
(
cpu_info
[
2
]
&
0x10000000
)
!
=
0
&
&
(
cpu_info
[
2
]
&
0x04000000
)
!
=
0
&
&
(
cpu_info
[
2
]
&
0x08000000
)
!
=
0
&
&
(
xgetbv
(
0
)
&
6
)
=
=
6
;
has_aesni_
=
(
cpu_info
[
2
]
&
0x02000000
)
!
=
0
;
has_fma3_
=
(
cpu_info
[
2
]
&
0x00001000
)
!
=
0
;
has_avx2_
=
has_avx_
&
&
(
cpu_info7
[
1
]
&
0x00000020
)
!
=
0
;
has_pku_
=
(
cpu_info7
[
2
]
&
0x00000010
)
!
=
0
;
}
__cpuid
(
cpu_info
static_cast
<
int
>
(
0x80000000
)
)
;
const
uint32_t
max_parameter
=
static_cast
<
uint32_t
>
(
cpu_info
[
0
]
)
;
static
constexpr
uint32_t
kParameterStart
=
0x80000002
;
static
constexpr
uint32_t
kParameterEnd
=
0x80000004
;
static
constexpr
uint32_t
kParameterSize
=
kParameterEnd
-
kParameterStart
+
1
;
static_assert
(
kParameterSize
*
sizeof
(
cpu_info
)
+
1
=
=
std
:
:
size
(
cpu_string
)
"
cpu_string
has
wrong
size
"
)
;
if
(
max_parameter
>
=
kParameterEnd
)
{
size_t
i
=
0
;
for
(
uint32_t
parameter
=
kParameterStart
;
parameter
<
=
kParameterEnd
;
+
+
parameter
)
{
__cpuid
(
cpu_info
static_cast
<
int
>
(
parameter
)
)
;
memcpy
(
&
cpu_string
[
i
]
cpu_info
sizeof
(
cpu_info
)
)
;
i
+
=
sizeof
(
cpu_info
)
;
}
cpu_string
[
i
]
=
'
\
0
'
;
cpu_brand_
=
cpu_string
;
}
static
constexpr
uint32_t
kParameterContainingNonStopTimeStampCounter
=
0x80000007
;
if
(
max_parameter
>
=
kParameterContainingNonStopTimeStampCounter
)
{
__cpuid
(
cpu_info
static_cast
<
int
>
(
kParameterContainingNonStopTimeStampCounter
)
)
;
has_non_stop_time_stamp_counter_
=
(
cpu_info
[
3
]
&
(
1
<
<
8
)
)
!
=
0
;
}
if
(
!
has_non_stop_time_stamp_counter_
&
&
is_running_in_vm_
)
{
int
cpu_info_hv
[
4
]
=
{
}
;
__cpuid
(
cpu_info_hv
0x40000000
)
;
if
(
cpu_info_hv
[
1
]
=
=
0x7263694D
&
&
cpu_info_hv
[
2
]
=
=
0x666F736F
&
&
cpu_info_hv
[
3
]
=
=
0x76482074
)
{
has_non_stop_time_stamp_counter_
=
true
;
}
}
#
elif
defined
(
ARCH_CPU_ARM_FAMILY
)
#
if
BUILDFLAG
(
IS_ANDROID
)
|
|
BUILDFLAG
(
IS_LINUX
)
|
|
BUILDFLAG
(
IS_CHROMEOS
)
if
(
require_branding
)
{
const
ProcCpuInfo
&
info
=
ParseProcCpu
(
)
;
cpu_brand_
=
info
.
brand
;
implementer_
=
info
.
implementer
;
part_number_
=
info
.
part_number
;
}
#
if
defined
(
ARCH_CPU_ARM64
)
unsigned
long
hwcap2
=
getauxval
(
AT_HWCAP2
)
;
has_mte_
=
hwcap2
&
HWCAP2_MTE
;
has_bti_
=
hwcap2
&
HWCAP2_BTI
;
#
endif
#
elif
BUILDFLAG
(
IS_WIN
)
has_non_stop_time_stamp_counter_
=
true
;
#
endif
#
endif
}
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
CPU
:
:
IntelMicroArchitecture
CPU
:
:
GetIntelMicroArchitecture
(
)
const
{
if
(
has_avx2
(
)
)
return
AVX2
;
if
(
has_fma3
(
)
)
return
FMA3
;
if
(
has_avx
(
)
)
return
AVX
;
if
(
has_sse42
(
)
)
return
SSE42
;
if
(
has_sse41
(
)
)
return
SSE41
;
if
(
has_ssse3
(
)
)
return
SSSE3
;
if
(
has_sse3
(
)
)
return
SSE3
;
if
(
has_sse2
(
)
)
return
SSE2
;
if
(
has_sse
(
)
)
return
SSE
;
return
PENTIUM
;
}
#
endif
const
CPU
&
CPU
:
:
GetInstanceNoAllocation
(
)
{
static
const
base
:
:
NoDestructor
<
const
CPU
>
cpu
(
CPU
(
false
)
)
;
return
*
cpu
;
}
}
