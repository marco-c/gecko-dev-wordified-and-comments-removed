#
ifndef
BASE_OPTIONAL_H_
#
define
BASE_OPTIONAL_H_
#
include
<
type_traits
>
#
include
"
base
/
logging
.
h
"
namespace
base
{
struct
in_place_t
{
}
;
struct
nullopt_t
{
constexpr
explicit
nullopt_t
(
int
)
{
}
}
;
constexpr
in_place_t
in_place
=
{
}
;
constexpr
nullopt_t
nullopt
(
0
)
;
namespace
internal
{
template
<
typename
T
bool
=
std
:
:
is_trivially_destructible
<
T
>
:
:
value
>
struct
OptionalStorage
{
constexpr
OptionalStorage
(
)
:
empty_
(
'
\
0
'
)
{
}
constexpr
explicit
OptionalStorage
(
const
T
&
value
)
:
is_null_
(
false
)
value_
(
value
)
{
}
explicit
OptionalStorage
(
T
&
&
value
)
:
is_null_
(
false
)
value_
(
std
:
:
move
(
value
)
)
{
}
template
<
class
.
.
.
Args
>
explicit
OptionalStorage
(
base
:
:
in_place_t
Args
&
&
.
.
.
args
)
:
is_null_
(
false
)
value_
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
~
OptionalStorage
(
)
{
if
(
!
is_null_
)
value_
.
~
T
(
)
;
}
bool
is_null_
=
true
;
union
{
char
empty_
;
T
value_
;
}
;
}
;
template
<
typename
T
>
struct
OptionalStorage
<
T
true
>
{
constexpr
OptionalStorage
(
)
:
empty_
(
'
\
0
'
)
{
}
constexpr
explicit
OptionalStorage
(
const
T
&
value
)
:
is_null_
(
false
)
value_
(
value
)
{
}
explicit
OptionalStorage
(
T
&
&
value
)
:
is_null_
(
false
)
value_
(
std
:
:
move
(
value
)
)
{
}
template
<
class
.
.
.
Args
>
explicit
OptionalStorage
(
base
:
:
in_place_t
Args
&
&
.
.
.
args
)
:
is_null_
(
false
)
value_
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
~
OptionalStorage
(
)
=
default
;
bool
is_null_
=
true
;
union
{
char
empty_
;
T
value_
;
}
;
}
;
}
template
<
typename
T
>
class
Optional
{
public
:
using
value_type
=
T
;
constexpr
Optional
(
)
{
}
constexpr
Optional
(
base
:
:
nullopt_t
)
{
}
Optional
(
const
Optional
&
other
)
{
if
(
!
other
.
storage_
.
is_null_
)
Init
(
other
.
value
(
)
)
;
}
Optional
(
Optional
&
&
other
)
{
if
(
!
other
.
storage_
.
is_null_
)
Init
(
std
:
:
move
(
other
.
value
(
)
)
)
;
}
constexpr
Optional
(
const
T
&
value
)
:
storage_
(
value
)
{
}
Optional
(
T
&
&
value
)
:
storage_
(
std
:
:
move
(
value
)
)
{
}
template
<
class
.
.
.
Args
>
explicit
Optional
(
base
:
:
in_place_t
Args
&
&
.
.
.
args
)
:
storage_
(
base
:
:
in_place
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
~
Optional
(
)
=
default
;
Optional
&
operator
=
(
base
:
:
nullopt_t
)
{
FreeIfNeeded
(
)
;
return
*
this
;
}
Optional
&
operator
=
(
const
Optional
&
other
)
{
if
(
other
.
storage_
.
is_null_
)
{
FreeIfNeeded
(
)
;
return
*
this
;
}
InitOrAssign
(
other
.
value
(
)
)
;
return
*
this
;
}
Optional
&
operator
=
(
Optional
&
&
other
)
{
if
(
other
.
storage_
.
is_null_
)
{
FreeIfNeeded
(
)
;
return
*
this
;
}
InitOrAssign
(
std
:
:
move
(
other
.
value
(
)
)
)
;
return
*
this
;
}
template
<
class
U
>
typename
std
:
:
enable_if
<
std
:
:
is_same
<
std
:
:
decay
<
U
>
T
>
:
:
value
Optional
&
>
:
:
type
operator
=
(
U
&
&
value
)
{
InitOrAssign
(
std
:
:
forward
<
U
>
(
value
)
)
;
return
*
this
;
}
const
T
*
operator
-
>
(
)
const
{
DCHECK
(
!
storage_
.
is_null_
)
;
return
&
value
(
)
;
}
T
*
operator
-
>
(
)
{
DCHECK
(
!
storage_
.
is_null_
)
;
return
&
value
(
)
;
}
constexpr
const
T
&
operator
*
(
)
const
&
{
return
value
(
)
;
}
T
&
operator
*
(
)
&
{
return
value
(
)
;
}
constexpr
const
T
&
&
operator
*
(
)
const
&
&
{
return
std
:
:
move
(
value
(
)
)
;
}
T
&
&
operator
*
(
)
&
&
{
return
std
:
:
move
(
value
(
)
)
;
}
constexpr
explicit
operator
bool
(
)
const
{
return
!
storage_
.
is_null_
;
}
constexpr
bool
has_value
(
)
const
{
return
!
storage_
.
is_null_
;
}
T
&
value
(
)
&
{
DCHECK
(
!
storage_
.
is_null_
)
;
return
storage_
.
value_
;
}
const
T
&
value
(
)
const
&
{
DCHECK
(
!
storage_
.
is_null_
)
;
return
storage_
.
value_
;
}
T
&
&
value
(
)
&
&
{
DCHECK
(
!
storage_
.
is_null_
)
;
return
std
:
:
move
(
storage_
.
value_
)
;
}
const
T
&
&
value
(
)
const
&
&
{
DCHECK
(
!
storage_
.
is_null_
)
;
return
std
:
:
move
(
storage_
.
value_
)
;
}
template
<
class
U
>
constexpr
T
value_or
(
U
&
&
default_value
)
const
&
{
static_assert
(
std
:
:
is_convertible
<
U
T
>
:
:
value
"
U
must
be
convertible
to
T
"
)
;
return
storage_
.
is_null_
?
static_cast
<
T
>
(
std
:
:
forward
<
U
>
(
default_value
)
)
:
value
(
)
;
}
template
<
class
U
>
T
value_or
(
U
&
&
default_value
)
&
&
{
static_assert
(
std
:
:
is_convertible
<
U
T
>
:
:
value
"
U
must
be
convertible
to
T
"
)
;
return
storage_
.
is_null_
?
static_cast
<
T
>
(
std
:
:
forward
<
U
>
(
default_value
)
)
:
std
:
:
move
(
value
(
)
)
;
}
void
swap
(
Optional
&
other
)
{
if
(
storage_
.
is_null_
&
&
other
.
storage_
.
is_null_
)
return
;
if
(
storage_
.
is_null_
!
=
other
.
storage_
.
is_null_
)
{
if
(
storage_
.
is_null_
)
{
Init
(
std
:
:
move
(
other
.
storage_
.
value_
)
)
;
other
.
FreeIfNeeded
(
)
;
}
else
{
other
.
Init
(
std
:
:
move
(
storage_
.
value_
)
)
;
FreeIfNeeded
(
)
;
}
return
;
}
DCHECK
(
!
storage_
.
is_null_
&
&
!
other
.
storage_
.
is_null_
)
;
using
std
:
:
swap
;
swap
(
*
*
this
*
other
)
;
}
void
reset
(
)
{
FreeIfNeeded
(
)
;
}
template
<
class
.
.
.
Args
>
void
emplace
(
Args
&
&
.
.
.
args
)
{
FreeIfNeeded
(
)
;
Init
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
private
:
void
Init
(
const
T
&
value
)
{
DCHECK
(
storage_
.
is_null_
)
;
new
(
&
storage_
.
value_
)
T
(
value
)
;
storage_
.
is_null_
=
false
;
}
void
Init
(
T
&
&
value
)
{
DCHECK
(
storage_
.
is_null_
)
;
new
(
&
storage_
.
value_
)
T
(
std
:
:
move
(
value
)
)
;
storage_
.
is_null_
=
false
;
}
template
<
class
.
.
.
Args
>
void
Init
(
Args
&
&
.
.
.
args
)
{
DCHECK
(
storage_
.
is_null_
)
;
new
(
&
storage_
.
value_
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
storage_
.
is_null_
=
false
;
}
void
InitOrAssign
(
const
T
&
value
)
{
if
(
storage_
.
is_null_
)
Init
(
value
)
;
else
storage_
.
value_
=
value
;
}
void
InitOrAssign
(
T
&
&
value
)
{
if
(
storage_
.
is_null_
)
Init
(
std
:
:
move
(
value
)
)
;
else
storage_
.
value_
=
std
:
:
move
(
value
)
;
}
void
FreeIfNeeded
(
)
{
if
(
storage_
.
is_null_
)
return
;
storage_
.
value_
.
~
T
(
)
;
storage_
.
is_null_
=
true
;
}
internal
:
:
OptionalStorage
<
T
>
storage_
;
}
;
template
<
class
T
>
constexpr
bool
operator
=
=
(
const
Optional
<
T
>
&
lhs
const
Optional
<
T
>
&
rhs
)
{
return
!
!
lhs
!
=
!
!
rhs
?
false
:
lhs
=
=
nullopt
|
|
(
*
lhs
=
=
*
rhs
)
;
}
template
<
class
T
>
constexpr
bool
operator
!
=
(
const
Optional
<
T
>
&
lhs
const
Optional
<
T
>
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
template
<
class
T
>
constexpr
bool
operator
<
(
const
Optional
<
T
>
&
lhs
const
Optional
<
T
>
&
rhs
)
{
return
rhs
=
=
nullopt
?
false
:
(
lhs
=
=
nullopt
?
true
:
*
lhs
<
*
rhs
)
;
}
template
<
class
T
>
constexpr
bool
operator
<
=
(
const
Optional
<
T
>
&
lhs
const
Optional
<
T
>
&
rhs
)
{
return
!
(
rhs
<
lhs
)
;
}
template
<
class
T
>
constexpr
bool
operator
>
(
const
Optional
<
T
>
&
lhs
const
Optional
<
T
>
&
rhs
)
{
return
rhs
<
lhs
;
}
template
<
class
T
>
constexpr
bool
operator
>
=
(
const
Optional
<
T
>
&
lhs
const
Optional
<
T
>
&
rhs
)
{
return
!
(
lhs
<
rhs
)
;
}
template
<
class
T
>
constexpr
bool
operator
=
=
(
const
Optional
<
T
>
&
opt
base
:
:
nullopt_t
)
{
return
!
opt
;
}
template
<
class
T
>
constexpr
bool
operator
=
=
(
base
:
:
nullopt_t
const
Optional
<
T
>
&
opt
)
{
return
!
opt
;
}
template
<
class
T
>
constexpr
bool
operator
!
=
(
const
Optional
<
T
>
&
opt
base
:
:
nullopt_t
)
{
return
!
!
opt
;
}
template
<
class
T
>
constexpr
bool
operator
!
=
(
base
:
:
nullopt_t
const
Optional
<
T
>
&
opt
)
{
return
!
!
opt
;
}
template
<
class
T
>
constexpr
bool
operator
<
(
const
Optional
<
T
>
&
opt
base
:
:
nullopt_t
)
{
return
false
;
}
template
<
class
T
>
constexpr
bool
operator
<
(
base
:
:
nullopt_t
const
Optional
<
T
>
&
opt
)
{
return
!
!
opt
;
}
template
<
class
T
>
constexpr
bool
operator
<
=
(
const
Optional
<
T
>
&
opt
base
:
:
nullopt_t
)
{
return
!
opt
;
}
template
<
class
T
>
constexpr
bool
operator
<
=
(
base
:
:
nullopt_t
const
Optional
<
T
>
&
opt
)
{
return
true
;
}
template
<
class
T
>
constexpr
bool
operator
>
(
const
Optional
<
T
>
&
opt
base
:
:
nullopt_t
)
{
return
!
!
opt
;
}
template
<
class
T
>
constexpr
bool
operator
>
(
base
:
:
nullopt_t
const
Optional
<
T
>
&
opt
)
{
return
false
;
}
template
<
class
T
>
constexpr
bool
operator
>
=
(
const
Optional
<
T
>
&
opt
base
:
:
nullopt_t
)
{
return
true
;
}
template
<
class
T
>
constexpr
bool
operator
>
=
(
base
:
:
nullopt_t
const
Optional
<
T
>
&
opt
)
{
return
!
opt
;
}
template
<
class
T
>
constexpr
bool
operator
=
=
(
const
Optional
<
T
>
&
opt
const
T
&
value
)
{
return
opt
!
=
nullopt
?
*
opt
=
=
value
:
false
;
}
template
<
class
T
>
constexpr
bool
operator
=
=
(
const
T
&
value
const
Optional
<
T
>
&
opt
)
{
return
opt
=
=
value
;
}
template
<
class
T
>
constexpr
bool
operator
!
=
(
const
Optional
<
T
>
&
opt
const
T
&
value
)
{
return
!
(
opt
=
=
value
)
;
}
template
<
class
T
>
constexpr
bool
operator
!
=
(
const
T
&
value
const
Optional
<
T
>
&
opt
)
{
return
!
(
opt
=
=
value
)
;
}
template
<
class
T
>
constexpr
bool
operator
<
(
const
Optional
<
T
>
&
opt
const
T
&
value
)
{
return
opt
!
=
nullopt
?
*
opt
<
value
:
true
;
}
template
<
class
T
>
constexpr
bool
operator
<
(
const
T
&
value
const
Optional
<
T
>
&
opt
)
{
return
opt
!
=
nullopt
?
value
<
*
opt
:
false
;
}
template
<
class
T
>
constexpr
bool
operator
<
=
(
const
Optional
<
T
>
&
opt
const
T
&
value
)
{
return
!
(
opt
>
value
)
;
}
template
<
class
T
>
constexpr
bool
operator
<
=
(
const
T
&
value
const
Optional
<
T
>
&
opt
)
{
return
!
(
value
>
opt
)
;
}
template
<
class
T
>
constexpr
bool
operator
>
(
const
Optional
<
T
>
&
opt
const
T
&
value
)
{
return
value
<
opt
;
}
template
<
class
T
>
constexpr
bool
operator
>
(
const
T
&
value
const
Optional
<
T
>
&
opt
)
{
return
opt
<
value
;
}
template
<
class
T
>
constexpr
bool
operator
>
=
(
const
Optional
<
T
>
&
opt
const
T
&
value
)
{
return
!
(
opt
<
value
)
;
}
template
<
class
T
>
constexpr
bool
operator
>
=
(
const
T
&
value
const
Optional
<
T
>
&
opt
)
{
return
!
(
value
<
opt
)
;
}
template
<
class
T
>
constexpr
Optional
<
typename
std
:
:
decay
<
T
>
:
:
type
>
make_optional
(
T
&
&
value
)
{
return
Optional
<
typename
std
:
:
decay
<
T
>
:
:
type
>
(
std
:
:
forward
<
T
>
(
value
)
)
;
}
template
<
class
T
>
void
swap
(
Optional
<
T
>
&
lhs
Optional
<
T
>
&
rhs
)
{
lhs
.
swap
(
rhs
)
;
}
}
namespace
std
{
template
<
class
T
>
struct
hash
<
base
:
:
Optional
<
T
>
>
{
size_t
operator
(
)
(
const
base
:
:
Optional
<
T
>
&
opt
)
const
{
return
opt
=
=
base
:
:
nullopt
?
0
:
std
:
:
hash
<
T
>
(
)
(
*
opt
)
;
}
}
;
}
#
endif
