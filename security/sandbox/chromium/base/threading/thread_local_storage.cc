#
include
"
base
/
threading
/
thread_local_storage
.
h
"
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
#
include
"
base
/
notreached
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
IS_MAC
)
&
&
defined
(
ARCH_CPU_X86_64
)
#
include
<
pthread
.
h
>
#
include
<
type_traits
>
#
endif
using
base
:
:
internal
:
:
PlatformThreadLocalStorage
;
namespace
{
std
:
:
atomic
<
PlatformThreadLocalStorage
:
:
TLSKey
>
g_native_tls_key
{
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
}
;
enum
class
TlsVectorState
{
kUninitialized
=
0
kDestroying
kDestroyed
kInUse
kMaxValue
=
kInUse
}
;
constexpr
uintptr_t
kVectorStateBitMask
=
3
;
static_assert
(
static_cast
<
int
>
(
TlsVectorState
:
:
kMaxValue
)
<
=
kVectorStateBitMask
"
number
of
states
must
fit
in
header
"
)
;
static_assert
(
static_cast
<
int
>
(
TlsVectorState
:
:
kUninitialized
)
=
=
0
"
kUninitialized
must
be
null
"
)
;
constexpr
size_t
kThreadLocalStorageSize
=
256
;
enum
TlsStatus
{
FREE
IN_USE
}
;
struct
TlsMetadata
{
TlsStatus
status
;
base
:
:
ThreadLocalStorage
:
:
TLSDestructorFunc
destructor
;
uint32_t
version
;
uint32_t
sequence_num
;
}
;
struct
TlsVectorEntry
{
RAW_PTR_EXCLUSION
void
*
data
;
uint32_t
version
;
}
;
base
:
:
Lock
*
GetTLSMetadataLock
(
)
{
static
auto
*
lock
=
new
base
:
:
Lock
(
)
;
return
lock
;
}
TlsMetadata
g_tls_metadata
[
kThreadLocalStorageSize
]
;
size_t
g_last_assigned_slot
=
0
;
uint32_t
g_sequence_num
=
0
;
constexpr
size_t
kMaxDestructorIterations
=
kThreadLocalStorageSize
;
void
SetTlsVectorValue
(
PlatformThreadLocalStorage
:
:
TLSKey
key
TlsVectorEntry
*
tls_data
TlsVectorState
state
)
{
DCHECK
(
tls_data
|
|
(
state
=
=
TlsVectorState
:
:
kUninitialized
)
|
|
(
state
=
=
TlsVectorState
:
:
kDestroyed
)
)
;
PlatformThreadLocalStorage
:
:
SetTLSValue
(
key
reinterpret_cast
<
void
*
>
(
reinterpret_cast
<
uintptr_t
>
(
tls_data
)
|
static_cast
<
uintptr_t
>
(
state
)
)
)
;
}
TlsVectorState
GetTlsVectorStateAndValue
(
void
*
tls_value
TlsVectorEntry
*
*
entry
=
nullptr
)
{
if
(
entry
)
{
*
entry
=
reinterpret_cast
<
TlsVectorEntry
*
>
(
reinterpret_cast
<
uintptr_t
>
(
tls_value
)
&
~
kVectorStateBitMask
)
;
}
return
static_cast
<
TlsVectorState
>
(
reinterpret_cast
<
uintptr_t
>
(
tls_value
)
&
kVectorStateBitMask
)
;
}
TlsVectorState
GetTlsVectorStateAndValue
(
PlatformThreadLocalStorage
:
:
TLSKey
key
TlsVectorEntry
*
*
entry
=
nullptr
)
{
#
if
BUILDFLAG
(
IS_MAC
)
&
&
defined
(
ARCH_CPU_X86_64
)
static_assert
(
std
:
:
is_same_v
<
PlatformThreadLocalStorage
:
:
TLSKey
pthread_key_t
>
"
The
special
-
case
below
assumes
that
the
platform
TLS
implementation
is
"
"
pthread
.
"
)
;
intptr_t
platform_tls_value
;
asm
(
"
movq
%
%
gs
:
(
%
1
8
)
%
0
;
"
:
"
=
r
"
(
platform_tls_value
)
:
"
r
"
(
key
)
)
;
return
GetTlsVectorStateAndValue
(
reinterpret_cast
<
void
*
>
(
platform_tls_value
)
entry
)
;
#
else
return
GetTlsVectorStateAndValue
(
PlatformThreadLocalStorage
:
:
GetTLSValue
(
key
)
entry
)
;
#
endif
}
TlsVectorEntry
*
ConstructTlsVector
(
)
{
PlatformThreadLocalStorage
:
:
TLSKey
key
=
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
{
CHECK
(
PlatformThreadLocalStorage
:
:
AllocTLS
(
&
key
)
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
{
PlatformThreadLocalStorage
:
:
TLSKey
tmp
=
key
;
CHECK
(
PlatformThreadLocalStorage
:
:
AllocTLS
(
&
key
)
&
&
key
!
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
;
PlatformThreadLocalStorage
:
:
FreeTLS
(
tmp
)
;
}
PlatformThreadLocalStorage
:
:
TLSKey
old_key
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
;
if
(
!
g_native_tls_key
.
compare_exchange_strong
(
old_key
key
std
:
:
memory_order_relaxed
std
:
:
memory_order_relaxed
)
)
{
PlatformThreadLocalStorage
:
:
FreeTLS
(
key
)
;
key
=
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
;
}
}
CHECK_EQ
(
GetTlsVectorStateAndValue
(
key
)
TlsVectorState
:
:
kUninitialized
)
;
TlsVectorEntry
stack_allocated_tls_data
[
kThreadLocalStorageSize
]
;
memset
(
stack_allocated_tls_data
0
sizeof
(
stack_allocated_tls_data
)
)
;
SetTlsVectorValue
(
key
stack_allocated_tls_data
TlsVectorState
:
:
kInUse
)
;
TlsVectorEntry
*
tls_data
=
new
TlsVectorEntry
[
kThreadLocalStorageSize
]
;
memcpy
(
tls_data
stack_allocated_tls_data
sizeof
(
stack_allocated_tls_data
)
)
;
SetTlsVectorValue
(
key
tls_data
TlsVectorState
:
:
kInUse
)
;
return
tls_data
;
}
void
OnThreadExitInternal
(
TlsVectorEntry
*
tls_data
)
{
DCHECK
(
tls_data
)
;
TlsVectorEntry
stack_allocated_tls_data
[
kThreadLocalStorageSize
]
;
memcpy
(
stack_allocated_tls_data
tls_data
sizeof
(
stack_allocated_tls_data
)
)
;
PlatformThreadLocalStorage
:
:
TLSKey
key
=
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
;
SetTlsVectorValue
(
key
stack_allocated_tls_data
TlsVectorState
:
:
kDestroying
)
;
delete
[
]
tls_data
;
size_t
remaining_attempts
=
kMaxDestructorIterations
+
1
;
bool
need_to_scan_destructors
=
true
;
while
(
need_to_scan_destructors
)
{
need_to_scan_destructors
=
false
;
TlsMetadata
tls_metadata
[
kThreadLocalStorageSize
]
;
{
base
:
:
AutoLock
auto_lock
(
*
GetTLSMetadataLock
(
)
)
;
memcpy
(
tls_metadata
g_tls_metadata
sizeof
(
g_tls_metadata
)
)
;
}
struct
OrderedSlot
{
uint32_t
sequence_num
;
uint16_t
slot
;
}
slot_destruction_order
[
kThreadLocalStorageSize
]
;
for
(
uint16_t
i
=
0
;
i
<
kThreadLocalStorageSize
;
+
+
i
)
{
slot_destruction_order
[
i
]
.
sequence_num
=
tls_metadata
[
i
]
.
sequence_num
;
slot_destruction_order
[
i
]
.
slot
=
i
;
}
std
:
:
sort
(
std
:
:
begin
(
slot_destruction_order
)
std
:
:
end
(
slot_destruction_order
)
[
]
(
const
OrderedSlot
&
s1
const
OrderedSlot
&
s2
)
{
return
s1
.
sequence_num
>
s2
.
sequence_num
;
}
)
;
for
(
const
auto
&
ordered_slot
:
slot_destruction_order
)
{
size_t
slot
=
ordered_slot
.
slot
;
void
*
tls_value
=
stack_allocated_tls_data
[
slot
]
.
data
;
if
(
!
tls_value
|
|
tls_metadata
[
slot
]
.
status
=
=
TlsStatus
:
:
FREE
|
|
stack_allocated_tls_data
[
slot
]
.
version
!
=
tls_metadata
[
slot
]
.
version
)
continue
;
base
:
:
ThreadLocalStorage
:
:
TLSDestructorFunc
destructor
=
tls_metadata
[
slot
]
.
destructor
;
if
(
!
destructor
)
continue
;
stack_allocated_tls_data
[
slot
]
.
data
=
nullptr
;
destructor
(
tls_value
)
;
need_to_scan_destructors
=
true
;
}
if
(
-
-
remaining_attempts
=
=
0
)
{
NOTREACHED
(
)
;
break
;
}
}
SetTlsVectorValue
(
key
nullptr
TlsVectorState
:
:
kDestroyed
)
;
}
}
namespace
base
{
namespace
internal
{
#
if
BUILDFLAG
(
IS_WIN
)
void
PlatformThreadLocalStorage
:
:
OnThreadExit
(
)
{
PlatformThreadLocalStorage
:
:
TLSKey
key
=
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
return
;
TlsVectorEntry
*
tls_vector
=
nullptr
;
const
TlsVectorState
state
=
GetTlsVectorStateAndValue
(
key
&
tls_vector
)
;
DCHECK_NE
(
state
TlsVectorState
:
:
kDestroyed
)
;
if
(
state
=
=
TlsVectorState
:
:
kUninitialized
)
return
;
OnThreadExitInternal
(
tls_vector
)
;
}
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
void
PlatformThreadLocalStorage
:
:
OnThreadExit
(
void
*
value
)
{
TlsVectorEntry
*
tls_vector
=
nullptr
;
const
TlsVectorState
state
=
GetTlsVectorStateAndValue
(
value
&
tls_vector
)
;
if
(
state
=
=
TlsVectorState
:
:
kDestroyed
)
{
PlatformThreadLocalStorage
:
:
TLSKey
key
=
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
;
SetTlsVectorValue
(
key
nullptr
TlsVectorState
:
:
kUninitialized
)
;
return
;
}
OnThreadExitInternal
(
tls_vector
)
;
}
#
endif
}
bool
ThreadLocalStorage
:
:
HasBeenDestroyed
(
)
{
PlatformThreadLocalStorage
:
:
TLSKey
key
=
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
return
false
;
const
TlsVectorState
state
=
GetTlsVectorStateAndValue
(
key
)
;
return
state
=
=
TlsVectorState
:
:
kDestroying
|
|
state
=
=
TlsVectorState
:
:
kDestroyed
;
}
void
ThreadLocalStorage
:
:
Slot
:
:
Initialize
(
TLSDestructorFunc
destructor
)
{
PlatformThreadLocalStorage
:
:
TLSKey
key
=
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
|
|
GetTlsVectorStateAndValue
(
key
)
=
=
TlsVectorState
:
:
kUninitialized
)
{
ConstructTlsVector
(
)
;
}
{
base
:
:
AutoLock
auto_lock
(
*
GetTLSMetadataLock
(
)
)
;
for
(
size_t
i
=
0
;
i
<
kThreadLocalStorageSize
;
+
+
i
)
{
size_t
slot_candidate
=
(
g_last_assigned_slot
+
1
+
i
)
%
kThreadLocalStorageSize
;
if
(
g_tls_metadata
[
slot_candidate
]
.
status
=
=
TlsStatus
:
:
FREE
)
{
g_tls_metadata
[
slot_candidate
]
.
status
=
TlsStatus
:
:
IN_USE
;
g_tls_metadata
[
slot_candidate
]
.
destructor
=
destructor
;
g_tls_metadata
[
slot_candidate
]
.
sequence_num
=
+
+
g_sequence_num
;
g_last_assigned_slot
=
slot_candidate
;
DCHECK_EQ
(
kInvalidSlotValue
slot_
)
;
slot_
=
slot_candidate
;
version_
=
g_tls_metadata
[
slot_candidate
]
.
version
;
break
;
}
}
}
CHECK_LT
(
slot_
kThreadLocalStorageSize
)
;
}
void
ThreadLocalStorage
:
:
Slot
:
:
Free
(
)
{
DCHECK_LT
(
slot_
kThreadLocalStorageSize
)
;
{
base
:
:
AutoLock
auto_lock
(
*
GetTLSMetadataLock
(
)
)
;
g_tls_metadata
[
slot_
]
.
status
=
TlsStatus
:
:
FREE
;
g_tls_metadata
[
slot_
]
.
destructor
=
nullptr
;
+
+
(
g_tls_metadata
[
slot_
]
.
version
)
;
}
slot_
=
kInvalidSlotValue
;
}
void
*
ThreadLocalStorage
:
:
Slot
:
:
Get
(
)
const
{
TlsVectorEntry
*
tls_data
=
nullptr
;
const
TlsVectorState
state
=
GetTlsVectorStateAndValue
(
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
&
tls_data
)
;
DCHECK_NE
(
state
TlsVectorState
:
:
kDestroyed
)
;
if
(
!
tls_data
)
return
nullptr
;
DCHECK_LT
(
slot_
kThreadLocalStorageSize
)
;
if
(
tls_data
[
slot_
]
.
version
!
=
version_
)
return
nullptr
;
return
tls_data
[
slot_
]
.
data
;
}
void
ThreadLocalStorage
:
:
Slot
:
:
Set
(
void
*
value
)
{
TlsVectorEntry
*
tls_data
=
nullptr
;
const
TlsVectorState
state
=
GetTlsVectorStateAndValue
(
g_native_tls_key
.
load
(
std
:
:
memory_order_relaxed
)
&
tls_data
)
;
DCHECK_NE
(
state
TlsVectorState
:
:
kDestroyed
)
;
if
(
UNLIKELY
(
!
tls_data
)
)
{
if
(
!
value
)
return
;
tls_data
=
ConstructTlsVector
(
)
;
}
DCHECK_LT
(
slot_
kThreadLocalStorageSize
)
;
tls_data
[
slot_
]
.
data
=
value
;
tls_data
[
slot_
]
.
version
=
version_
;
}
ThreadLocalStorage
:
:
Slot
:
:
Slot
(
TLSDestructorFunc
destructor
)
{
Initialize
(
destructor
)
;
}
ThreadLocalStorage
:
:
Slot
:
:
~
Slot
(
)
{
Free
(
)
;
}
}
