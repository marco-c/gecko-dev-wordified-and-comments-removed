#
include
"
base
/
threading
/
thread_local_storage
.
h
"
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
lazy_instance
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
include
"
build
/
build_config
.
h
"
using
base
:
:
internal
:
:
PlatformThreadLocalStorage
;
namespace
{
base
:
:
subtle
:
:
Atomic32
g_native_tls_key
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
;
constexpr
int
kThreadLocalStorageSize
=
256
;
constexpr
int
kInvalidSlotValue
=
-
1
;
enum
TlsStatus
{
FREE
IN_USE
}
;
struct
TlsMetadata
{
TlsStatus
status
;
base
:
:
ThreadLocalStorage
:
:
TLSDestructorFunc
destructor
;
uint32_t
version
;
}
;
struct
TlsVectorEntry
{
void
*
data
;
uint32_t
version
;
}
;
base
:
:
LazyInstance
<
base
:
:
Lock
>
:
:
Leaky
g_tls_metadata_lock
;
TlsMetadata
g_tls_metadata
[
kThreadLocalStorageSize
]
;
size_t
g_last_assigned_slot
=
0
;
constexpr
int
kMaxDestructorIterations
=
kThreadLocalStorageSize
;
TlsVectorEntry
*
ConstructTlsVector
(
)
{
PlatformThreadLocalStorage
:
:
TLSKey
key
=
base
:
:
subtle
:
:
NoBarrier_Load
(
&
g_native_tls_key
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
{
CHECK
(
PlatformThreadLocalStorage
:
:
AllocTLS
(
&
key
)
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
{
PlatformThreadLocalStorage
:
:
TLSKey
tmp
=
key
;
CHECK
(
PlatformThreadLocalStorage
:
:
AllocTLS
(
&
key
)
&
&
key
!
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
;
PlatformThreadLocalStorage
:
:
FreeTLS
(
tmp
)
;
}
if
(
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
!
=
static_cast
<
PlatformThreadLocalStorage
:
:
TLSKey
>
(
base
:
:
subtle
:
:
NoBarrier_CompareAndSwap
(
&
g_native_tls_key
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
key
)
)
)
{
PlatformThreadLocalStorage
:
:
FreeTLS
(
key
)
;
key
=
base
:
:
subtle
:
:
NoBarrier_Load
(
&
g_native_tls_key
)
;
}
}
CHECK
(
!
PlatformThreadLocalStorage
:
:
GetTLSValue
(
key
)
)
;
TlsVectorEntry
stack_allocated_tls_data
[
kThreadLocalStorageSize
]
;
memset
(
stack_allocated_tls_data
0
sizeof
(
stack_allocated_tls_data
)
)
;
PlatformThreadLocalStorage
:
:
SetTLSValue
(
key
stack_allocated_tls_data
)
;
TlsVectorEntry
*
tls_data
=
new
TlsVectorEntry
[
kThreadLocalStorageSize
]
;
memcpy
(
tls_data
stack_allocated_tls_data
sizeof
(
stack_allocated_tls_data
)
)
;
PlatformThreadLocalStorage
:
:
SetTLSValue
(
key
tls_data
)
;
return
tls_data
;
}
void
OnThreadExitInternal
(
TlsVectorEntry
*
tls_data
)
{
DCHECK
(
tls_data
)
;
TlsVectorEntry
stack_allocated_tls_data
[
kThreadLocalStorageSize
]
;
memcpy
(
stack_allocated_tls_data
tls_data
sizeof
(
stack_allocated_tls_data
)
)
;
PlatformThreadLocalStorage
:
:
TLSKey
key
=
base
:
:
subtle
:
:
NoBarrier_Load
(
&
g_native_tls_key
)
;
PlatformThreadLocalStorage
:
:
SetTLSValue
(
key
stack_allocated_tls_data
)
;
delete
[
]
tls_data
;
TlsMetadata
tls_metadata
[
kThreadLocalStorageSize
]
;
{
base
:
:
AutoLock
auto_lock
(
g_tls_metadata_lock
.
Get
(
)
)
;
memcpy
(
tls_metadata
g_tls_metadata
sizeof
(
g_tls_metadata
)
)
;
}
int
remaining_attempts
=
kMaxDestructorIterations
;
bool
need_to_scan_destructors
=
true
;
while
(
need_to_scan_destructors
)
{
need_to_scan_destructors
=
false
;
for
(
int
slot
=
0
;
slot
<
kThreadLocalStorageSize
;
+
+
slot
)
{
void
*
tls_value
=
stack_allocated_tls_data
[
slot
]
.
data
;
if
(
!
tls_value
|
|
tls_metadata
[
slot
]
.
status
=
=
TlsStatus
:
:
FREE
|
|
stack_allocated_tls_data
[
slot
]
.
version
!
=
tls_metadata
[
slot
]
.
version
)
continue
;
base
:
:
ThreadLocalStorage
:
:
TLSDestructorFunc
destructor
=
tls_metadata
[
slot
]
.
destructor
;
if
(
!
destructor
)
continue
;
stack_allocated_tls_data
[
slot
]
.
data
=
nullptr
;
destructor
(
tls_value
)
;
need_to_scan_destructors
=
true
;
}
if
(
-
-
remaining_attempts
<
=
0
)
{
NOTREACHED
(
)
;
break
;
}
}
PlatformThreadLocalStorage
:
:
SetTLSValue
(
key
nullptr
)
;
}
}
namespace
base
{
namespace
internal
{
#
if
defined
(
OS_WIN
)
void
PlatformThreadLocalStorage
:
:
OnThreadExit
(
)
{
PlatformThreadLocalStorage
:
:
TLSKey
key
=
base
:
:
subtle
:
:
NoBarrier_Load
(
&
g_native_tls_key
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
)
return
;
void
*
tls_data
=
GetTLSValue
(
key
)
;
if
(
!
tls_data
)
return
;
OnThreadExitInternal
(
static_cast
<
TlsVectorEntry
*
>
(
tls_data
)
)
;
}
#
elif
defined
(
OS_POSIX
)
void
PlatformThreadLocalStorage
:
:
OnThreadExit
(
void
*
value
)
{
OnThreadExitInternal
(
static_cast
<
TlsVectorEntry
*
>
(
value
)
)
;
}
#
endif
}
void
ThreadLocalStorage
:
:
StaticSlot
:
:
Initialize
(
TLSDestructorFunc
destructor
)
{
PlatformThreadLocalStorage
:
:
TLSKey
key
=
base
:
:
subtle
:
:
NoBarrier_Load
(
&
g_native_tls_key
)
;
if
(
key
=
=
PlatformThreadLocalStorage
:
:
TLS_KEY_OUT_OF_INDEXES
|
|
!
PlatformThreadLocalStorage
:
:
GetTLSValue
(
key
)
)
{
ConstructTlsVector
(
)
;
}
slot_
=
kInvalidSlotValue
;
version_
=
0
;
{
base
:
:
AutoLock
auto_lock
(
g_tls_metadata_lock
.
Get
(
)
)
;
for
(
int
i
=
0
;
i
<
kThreadLocalStorageSize
;
+
+
i
)
{
size_t
slot_candidate
=
(
g_last_assigned_slot
+
1
+
i
)
%
kThreadLocalStorageSize
;
if
(
g_tls_metadata
[
slot_candidate
]
.
status
=
=
TlsStatus
:
:
FREE
)
{
g_tls_metadata
[
slot_candidate
]
.
status
=
TlsStatus
:
:
IN_USE
;
g_tls_metadata
[
slot_candidate
]
.
destructor
=
destructor
;
g_last_assigned_slot
=
slot_candidate
;
slot_
=
slot_candidate
;
version_
=
g_tls_metadata
[
slot_candidate
]
.
version
;
break
;
}
}
}
CHECK_NE
(
slot_
kInvalidSlotValue
)
;
CHECK_LT
(
slot_
kThreadLocalStorageSize
)
;
base
:
:
subtle
:
:
Release_Store
(
&
initialized_
1
)
;
}
void
ThreadLocalStorage
:
:
StaticSlot
:
:
Free
(
)
{
DCHECK_NE
(
slot_
kInvalidSlotValue
)
;
DCHECK_LT
(
slot_
kThreadLocalStorageSize
)
;
{
base
:
:
AutoLock
auto_lock
(
g_tls_metadata_lock
.
Get
(
)
)
;
g_tls_metadata
[
slot_
]
.
status
=
TlsStatus
:
:
FREE
;
g_tls_metadata
[
slot_
]
.
destructor
=
nullptr
;
+
+
(
g_tls_metadata
[
slot_
]
.
version
)
;
}
slot_
=
kInvalidSlotValue
;
base
:
:
subtle
:
:
Release_Store
(
&
initialized_
0
)
;
}
void
*
ThreadLocalStorage
:
:
StaticSlot
:
:
Get
(
)
const
{
TlsVectorEntry
*
tls_data
=
static_cast
<
TlsVectorEntry
*
>
(
PlatformThreadLocalStorage
:
:
GetTLSValue
(
base
:
:
subtle
:
:
NoBarrier_Load
(
&
g_native_tls_key
)
)
)
;
if
(
!
tls_data
)
tls_data
=
ConstructTlsVector
(
)
;
DCHECK_NE
(
slot_
kInvalidSlotValue
)
;
DCHECK_LT
(
slot_
kThreadLocalStorageSize
)
;
if
(
tls_data
[
slot_
]
.
version
!
=
version_
)
return
nullptr
;
return
tls_data
[
slot_
]
.
data
;
}
void
ThreadLocalStorage
:
:
StaticSlot
:
:
Set
(
void
*
value
)
{
TlsVectorEntry
*
tls_data
=
static_cast
<
TlsVectorEntry
*
>
(
PlatformThreadLocalStorage
:
:
GetTLSValue
(
base
:
:
subtle
:
:
NoBarrier_Load
(
&
g_native_tls_key
)
)
)
;
if
(
!
tls_data
)
tls_data
=
ConstructTlsVector
(
)
;
DCHECK_NE
(
slot_
kInvalidSlotValue
)
;
DCHECK_LT
(
slot_
kThreadLocalStorageSize
)
;
tls_data
[
slot_
]
.
data
=
value
;
tls_data
[
slot_
]
.
version
=
version_
;
}
ThreadLocalStorage
:
:
Slot
:
:
Slot
(
TLSDestructorFunc
destructor
)
{
tls_slot_
.
Initialize
(
destructor
)
;
}
ThreadLocalStorage
:
:
Slot
:
:
~
Slot
(
)
{
tls_slot_
.
Free
(
)
;
}
void
*
ThreadLocalStorage
:
:
Slot
:
:
Get
(
)
const
{
return
tls_slot_
.
Get
(
)
;
}
void
ThreadLocalStorage
:
:
Slot
:
:
Set
(
void
*
value
)
{
tls_slot_
.
Set
(
value
)
;
}
}
