#
ifndef
BASE_THREADING_SEQUENCED_WORKER_POOL_H_
#
define
BASE_THREADING_SEQUENCED_WORKER_POOL_H_
#
include
<
stddef
.
h
>
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
string
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
callback
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
memory
/
ref_counted
.
h
"
#
include
"
base
/
task_runner
.
h
"
#
include
"
base
/
task_scheduler
/
task_traits
.
h
"
namespace
tracked_objects
{
class
Location
;
}
namespace
base
{
class
SequencedTaskRunner
;
template
<
class
T
>
class
DeleteHelper
;
class
BASE_EXPORT
SequencedWorkerPool
:
public
TaskRunner
{
public
:
enum
WorkerShutdown
{
CONTINUE_ON_SHUTDOWN
SKIP_ON_SHUTDOWN
BLOCK_SHUTDOWN
}
;
class
BASE_EXPORT
SequenceToken
{
public
:
SequenceToken
(
)
:
id_
(
0
)
{
}
~
SequenceToken
(
)
{
}
bool
Equals
(
const
SequenceToken
&
other
)
const
{
return
id_
=
=
other
.
id_
;
}
bool
IsValid
(
)
const
{
return
id_
!
=
0
;
}
std
:
:
string
ToString
(
)
const
;
private
:
friend
class
SequencedWorkerPool
;
explicit
SequenceToken
(
int
id
)
:
id_
(
id
)
{
}
int
id_
;
}
;
class
TestingObserver
{
public
:
virtual
~
TestingObserver
(
)
{
}
virtual
void
OnHasWork
(
)
=
0
;
virtual
void
WillWaitForShutdown
(
)
=
0
;
virtual
void
OnDestruct
(
)
=
0
;
}
;
static
SequenceToken
GetSequenceTokenForCurrentThread
(
)
;
static
scoped_refptr
<
SequencedWorkerPool
>
GetWorkerPoolForCurrentThread
(
)
;
static
SequenceToken
GetSequenceToken
(
)
;
static
void
EnableForProcess
(
)
;
static
void
EnableWithRedirectionToTaskSchedulerForProcess
(
)
;
static
void
DisableForProcessForTesting
(
)
;
static
bool
IsEnabled
(
)
;
SequencedWorkerPool
(
size_t
max_threads
const
std
:
:
string
&
thread_name_prefix
base
:
:
TaskPriority
task_priority
)
;
SequencedWorkerPool
(
size_t
max_threads
const
std
:
:
string
&
thread_name_prefix
base
:
:
TaskPriority
task_priority
TestingObserver
*
observer
)
;
SequenceToken
GetNamedSequenceToken
(
const
std
:
:
string
&
name
)
;
scoped_refptr
<
SequencedTaskRunner
>
GetSequencedTaskRunner
(
SequenceToken
token
)
WARN_UNUSED_RESULT
;
scoped_refptr
<
SequencedTaskRunner
>
GetSequencedTaskRunnerWithShutdownBehavior
(
SequenceToken
token
WorkerShutdown
shutdown_behavior
)
WARN_UNUSED_RESULT
;
scoped_refptr
<
TaskRunner
>
GetTaskRunnerWithShutdownBehavior
(
WorkerShutdown
shutdown_behavior
)
WARN_UNUSED_RESULT
;
bool
PostWorkerTask
(
const
tracked_objects
:
:
Location
&
from_here
OnceClosure
task
)
;
bool
PostWorkerTaskWithShutdownBehavior
(
const
tracked_objects
:
:
Location
&
from_here
OnceClosure
task
WorkerShutdown
shutdown_behavior
)
;
bool
PostSequencedWorkerTask
(
SequenceToken
sequence_token
const
tracked_objects
:
:
Location
&
from_here
OnceClosure
task
)
;
bool
PostNamedSequencedWorkerTask
(
const
std
:
:
string
&
token_name
const
tracked_objects
:
:
Location
&
from_here
OnceClosure
task
)
;
bool
PostDelayedSequencedWorkerTask
(
SequenceToken
sequence_token
const
tracked_objects
:
:
Location
&
from_here
OnceClosure
task
TimeDelta
delay
)
;
bool
PostSequencedWorkerTaskWithShutdownBehavior
(
SequenceToken
sequence_token
const
tracked_objects
:
:
Location
&
from_here
OnceClosure
task
WorkerShutdown
shutdown_behavior
)
;
bool
PostDelayedTask
(
const
tracked_objects
:
:
Location
&
from_here
OnceClosure
task
TimeDelta
delay
)
override
;
bool
RunsTasksInCurrentSequence
(
)
const
override
;
void
FlushForTesting
(
)
;
void
SignalHasWorkForTesting
(
)
;
void
Shutdown
(
)
{
Shutdown
(
0
)
;
}
void
Shutdown
(
int
max_new_blocking_tasks_after_shutdown
)
;
protected
:
~
SequencedWorkerPool
(
)
override
;
void
OnDestruct
(
)
const
override
;
private
:
friend
class
RefCountedThreadSafe
<
SequencedWorkerPool
>
;
friend
class
DeleteHelper
<
SequencedWorkerPool
>
;
class
Inner
;
class
PoolSequencedTaskRunner
;
class
Worker
;
bool
IsRunningSequenceOnCurrentThread
(
SequenceToken
sequence_token
)
const
;
const
scoped_refptr
<
SequencedTaskRunner
>
constructor_task_runner_
;
const
std
:
:
unique_ptr
<
Inner
>
inner_
;
DISALLOW_COPY_AND_ASSIGN
(
SequencedWorkerPool
)
;
}
;
}
#
endif
