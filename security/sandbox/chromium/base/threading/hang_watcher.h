#
ifndef
BASE_THREADING_HANG_WATCHER_H_
#
define
BASE_THREADING_HANG_WATCHER_H_
#
include
<
atomic
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
auto_reset
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
bits
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
debug
/
crash_logging
.
h
"
#
include
"
base
/
functional
/
callback
.
h
"
#
include
"
base
/
functional
/
callback_forward
.
h
"
#
include
"
base
/
functional
/
callback_helpers
.
h
"
#
include
"
base
/
gtest_prod_util
.
h
"
#
include
"
base
/
memory
/
memory_pressure_listener
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
include
"
base
/
synchronization
/
waitable_event
.
h
"
#
include
"
base
/
template_util
.
h
"
#
include
"
base
/
thread_annotations
.
h
"
#
include
"
base
/
threading
/
platform_thread
.
h
"
#
include
"
base
/
threading
/
simple_thread
.
h
"
#
include
"
base
/
threading
/
thread_checker
.
h
"
#
include
"
base
/
time
/
tick_clock
.
h
"
#
include
"
base
/
time
/
time
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
class
WatchHangsInScope
;
namespace
internal
{
class
HangWatchState
;
}
}
namespace
base
{
class
BASE_EXPORT
[
[
maybe_unused
nodiscard
]
]
WatchHangsInScope
{
public
:
static
constexpr
base
:
:
TimeDelta
kDefaultHangWatchTime
=
base
:
:
Seconds
(
10
)
;
explicit
WatchHangsInScope
(
TimeDelta
timeout
=
kDefaultHangWatchTime
)
;
~
WatchHangsInScope
(
)
;
WatchHangsInScope
(
const
WatchHangsInScope
&
)
=
delete
;
WatchHangsInScope
&
operator
=
(
const
WatchHangsInScope
&
)
=
delete
;
private
:
bool
took_effect_
=
true
;
THREAD_CHECKER
(
thread_checker_
)
;
TimeTicks
previous_deadline_
;
bool
set_hangs_ignored_on_exit_
=
false
;
#
if
DCHECK_IS_ON
(
)
raw_ptr
<
WatchHangsInScope
>
previous_watch_hangs_in_scope_
;
#
endif
}
;
class
BASE_EXPORT
HangWatcher
:
public
DelegateSimpleThread
:
:
Delegate
{
public
:
enum
class
ProcessType
{
kUnknownProcess
=
0
kBrowserProcess
=
1
kGPUProcess
=
2
kRendererProcess
=
3
kUtilityProcess
=
4
kMax
=
kUtilityProcess
}
;
enum
class
ThreadType
{
kIOThread
=
0
kMainThread
=
1
kThreadPoolThread
=
2
kMax
=
kThreadPoolThread
}
;
HangWatcher
(
)
;
~
HangWatcher
(
)
override
;
HangWatcher
(
const
HangWatcher
&
)
=
delete
;
HangWatcher
&
operator
=
(
const
HangWatcher
&
)
=
delete
;
static
void
CreateHangWatcherInstance
(
)
;
static
HangWatcher
*
GetInstance
(
)
;
static
void
InitializeOnMainThread
(
ProcessType
process_type
bool
is_zygote_child
)
;
static
void
UnitializeOnMainThreadForTesting
(
)
;
static
bool
IsEnabled
(
)
;
static
bool
IsThreadPoolHangWatchingEnabled
(
)
;
static
bool
IsIOThreadHangWatchingEnabled
(
)
;
static
bool
IsCrashReportingEnabled
(
)
;
static
void
InvalidateActiveExpectations
(
)
;
[
[
nodiscard
]
]
static
ScopedClosureRunner
RegisterThread
(
ThreadType
thread_type
)
;
void
SetAfterMonitorClosureForTesting
(
base
:
:
RepeatingClosure
closure
)
;
void
SetOnHangClosureForTesting
(
base
:
:
RepeatingClosure
closure
)
;
void
SetMonitoringPeriodForTesting
(
base
:
:
TimeDelta
period
)
;
void
SetAfterWaitCallbackForTesting
(
RepeatingCallback
<
void
(
TimeTicks
)
>
callback
)
;
void
SignalMonitorEventForTesting
(
)
;
static
void
StopMonitoringForTesting
(
)
;
void
SetTickClockForTesting
(
const
base
:
:
TickClock
*
tick_clock
)
;
void
BlockIfCaptureInProgress
(
)
;
void
Start
(
)
;
bool
IsStarted
(
)
const
{
return
thread_started_
;
}
std
:
:
string
GetTimeSinceLastSystemPowerResumeCrashKeyValue
(
)
const
;
private
:
[
[
nodiscard
]
]
ScopedClosureRunner
RegisterThreadInternal
(
ThreadType
thread_type
)
LOCKS_EXCLUDED
(
watch_state_lock_
)
;
THREAD_CHECKER
(
hang_watcher_thread_checker_
)
;
THREAD_CHECKER
(
constructing_thread_checker_
)
;
void
OnMemoryPressure
(
base
:
:
MemoryPressureListener
:
:
MemoryPressureLevel
memory_pressure_level
)
;
#
if
!
BUILDFLAG
(
IS_NACL
)
[
[
nodiscard
]
]
debug
:
:
ScopedCrashKeyString
GetTimeSinceLastCriticalMemoryPressureCrashKey
(
)
;
#
endif
NOINLINE
static
void
RecordHang
(
)
;
using
HangWatchStates
=
std
:
:
vector
<
std
:
:
unique_ptr
<
internal
:
:
HangWatchState
>
>
;
class
BASE_EXPORT
WatchStateSnapShot
{
public
:
struct
WatchStateCopy
{
base
:
:
TimeTicks
deadline
;
base
:
:
PlatformThreadId
thread_id
;
}
;
WatchStateSnapShot
(
)
;
WatchStateSnapShot
(
const
WatchStateSnapShot
&
other
)
;
~
WatchStateSnapShot
(
)
;
void
Init
(
const
HangWatchStates
&
watch_states
base
:
:
TimeTicks
deadline_ignore_threshold
)
;
void
Clear
(
)
;
std
:
:
string
PrepareHungThreadListCrashKey
(
)
const
;
base
:
:
TimeTicks
GetHighestDeadline
(
)
const
;
bool
IsActionable
(
)
const
;
private
:
bool
initialized_
=
false
;
std
:
:
vector
<
WatchStateCopy
>
hung_watch_state_copies_
;
}
;
WatchStateSnapShot
GrabWatchStateSnapshotForTesting
(
)
const
NO_THREAD_SAFETY_ANALYSIS
;
void
Monitor
(
)
LOCKS_EXCLUDED
(
watch_state_lock_
)
;
void
DoDumpWithoutCrashing
(
const
WatchStateSnapShot
&
watch_state_snapshot
)
EXCLUSIVE_LOCKS_REQUIRED
(
watch_state_lock_
)
LOCKS_EXCLUDED
(
capture_lock_
)
;
void
Stop
(
)
;
void
Wait
(
)
;
void
Run
(
)
override
;
base
:
:
TimeDelta
monitor_period_
;
WaitableEvent
should_monitor_
;
bool
IsWatchListEmpty
(
)
LOCKS_EXCLUDED
(
watch_state_lock_
)
;
void
UnregisterThread
(
)
LOCKS_EXCLUDED
(
watch_state_lock_
)
;
Lock
watch_state_lock_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
internal
:
:
HangWatchState
>
>
watch_states_
GUARDED_BY
(
watch_state_lock_
)
;
WatchStateSnapShot
watch_state_snapshot_
GUARDED_BY_CONTEXT
(
hang_watcher_thread_checker_
)
;
base
:
:
DelegateSimpleThread
thread_
;
bool
thread_started_
=
false
;
RepeatingClosure
after_monitor_closure_for_testing_
;
RepeatingClosure
on_hang_closure_for_testing_
;
RepeatingCallback
<
void
(
TimeTicks
)
>
after_wait_callback_
;
base
:
:
Lock
capture_lock_
ACQUIRED_AFTER
(
watch_state_lock_
)
;
std
:
:
atomic
<
bool
>
capture_in_progress_
{
false
}
;
raw_ptr
<
const
base
:
:
TickClock
>
tick_clock_
;
base
:
:
MemoryPressureListener
memory_pressure_listener_
;
std
:
:
atomic
<
base
:
:
TimeTicks
>
last_critical_memory_pressure_
{
base
:
:
TimeTicks
(
)
}
;
base
:
:
TimeTicks
deadline_ignore_threshold_
;
FRIEND_TEST_ALL_PREFIXES
(
HangWatcherTest
NestedScopes
)
;
FRIEND_TEST_ALL_PREFIXES
(
HangWatcherSnapshotTest
HungThreadIDs
)
;
FRIEND_TEST_ALL_PREFIXES
(
HangWatcherSnapshotTest
NonActionableReport
)
;
}
;
namespace
internal
{
class
BASE_EXPORT
HangWatchDeadline
{
public
:
enum
class
Flag
:
uint64_t
{
kMinValue
=
bits
:
:
LeftmostBit
<
uint64_t
>
(
)
>
>
7
kIgnoreCurrentWatchHangsInScope
=
bits
:
:
LeftmostBit
<
uint64_t
>
(
)
>
>
1
kShouldBlockOnHang
=
bits
:
:
LeftmostBit
<
uint64_t
>
(
)
>
>
0
kMaxValue
=
kShouldBlockOnHang
}
;
HangWatchDeadline
(
)
;
~
HangWatchDeadline
(
)
;
HangWatchDeadline
(
const
HangWatchDeadline
&
)
=
delete
;
HangWatchDeadline
&
operator
=
(
const
HangWatchDeadline
&
)
=
delete
;
TimeTicks
GetDeadline
(
)
const
;
std
:
:
pair
<
uint64_t
TimeTicks
>
GetFlagsAndDeadline
(
)
const
;
bool
IsFlagSet
(
Flag
flag
)
const
;
static
bool
IsFlagSet
(
Flag
flag
uint64_t
flags
)
;
void
SetDeadline
(
TimeTicks
new_value
)
;
bool
SetShouldBlockOnHang
(
uint64_t
old_flags
TimeTicks
old_deadline
)
;
void
SetIgnoreCurrentWatchHangsInScope
(
)
;
void
UnsetIgnoreCurrentWatchHangsInScope
(
)
;
void
SetSwitchBitsClosureForTesting
(
RepeatingCallback
<
uint64_t
(
void
)
>
closure
)
;
void
ResetSwitchBitsClosureForTesting
(
)
;
private
:
using
TimeTicksInternalRepresentation
=
std
:
:
invoke_result
<
decltype
(
&
TimeTicks
:
:
ToInternalValue
)
TimeTicks
>
:
:
type
;
static_assert
(
std
:
:
is_same_v
<
TimeTicksInternalRepresentation
int64_t
>
"
Bit
manipulations
made
by
HangWatchDeadline
need
to
be
"
"
adapted
if
internal
representation
of
TimeTicks
changes
.
"
)
;
uint64_t
SwitchBitsForTesting
(
)
;
void
SetPersistentFlag
(
Flag
flag
)
;
void
ClearPersistentFlag
(
Flag
flag
)
;
static
TimeTicks
DeadlineFromBits
(
uint64_t
bits
)
;
static
TimeTicks
Max
(
)
;
static
uint64_t
ExtractFlags
(
uint64_t
bits
)
;
static
uint64_t
ExtractDeadline
(
uint64_t
bits
)
;
using
BitsType
=
uint64_t
;
static_assert
(
std
:
:
is_same_v
<
std
:
:
underlying_type
<
Flag
>
:
:
type
BitsType
>
"
Flag
should
have
the
same
underlying
type
as
bits_
to
"
"
simplify
thinking
about
bit
operations
"
)
;
std
:
:
atomic
<
BitsType
>
bits_
{
static_cast
<
uint64_t
>
(
Max
(
)
.
ToInternalValue
(
)
)
}
;
RepeatingCallback
<
uint64_t
(
void
)
>
switch_bits_callback_for_testing_
;
THREAD_CHECKER
(
thread_checker_
)
;
FRIEND_TEST_ALL_PREFIXES
(
HangWatchDeadlineTest
BitsPreservedThroughExtract
)
;
}
;
class
BASE_EXPORT
HangWatchState
{
public
:
explicit
HangWatchState
(
HangWatcher
:
:
ThreadType
thread_type
)
;
~
HangWatchState
(
)
;
HangWatchState
(
const
HangWatchState
&
)
=
delete
;
HangWatchState
&
operator
=
(
const
HangWatchState
&
)
=
delete
;
static
std
:
:
unique_ptr
<
HangWatchState
>
CreateHangWatchStateForCurrentThread
(
HangWatcher
:
:
ThreadType
thread_type
)
;
static
HangWatchState
*
GetHangWatchStateForCurrentThread
(
)
;
TimeTicks
GetDeadline
(
)
const
;
std
:
:
pair
<
uint64_t
TimeTicks
>
GetFlagsAndDeadline
(
)
const
;
void
SetDeadline
(
TimeTicks
deadline
)
;
void
SetIgnoreCurrentWatchHangsInScope
(
)
;
void
UnsetIgnoreCurrentWatchHangsInScope
(
)
;
bool
SetShouldBlockOnHang
(
uint64_t
old_flags
TimeTicks
old_deadline
)
;
bool
IsFlagSet
(
HangWatchDeadline
:
:
Flag
flag
)
;
bool
IsOverDeadline
(
)
const
;
#
if
DCHECK_IS_ON
(
)
void
SetCurrentWatchHangsInScope
(
WatchHangsInScope
*
scope
)
;
WatchHangsInScope
*
GetCurrentWatchHangsInScope
(
)
;
#
endif
PlatformThreadId
GetThreadID
(
)
const
;
HangWatchDeadline
*
GetHangWatchDeadlineForTesting
(
)
;
int
nesting_level
(
)
{
return
nesting_level_
;
}
void
IncrementNestingLevel
(
)
;
void
DecrementNestingLevel
(
)
;
HangWatcher
:
:
ThreadType
thread_type
(
)
const
{
return
thread_type_
;
}
private
:
THREAD_CHECKER
(
thread_checker_
)
;
const
AutoReset
<
HangWatchState
*
>
resetter_
;
HangWatchDeadline
deadline_
;
PlatformThreadId
thread_id_
;
int
nesting_level_
=
0
;
const
HangWatcher
:
:
ThreadType
thread_type_
;
#
if
DCHECK_IS_ON
(
)
raw_ptr
<
WatchHangsInScope
>
current_watch_hangs_in_scope_
{
nullptr
}
;
#
endif
}
;
}
}
#
endif
