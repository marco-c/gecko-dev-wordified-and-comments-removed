#
include
"
base
/
strings
/
stringprintf
.
h
"
#
include
<
errno
.
h
>
#
include
<
stddef
.
h
>
#
include
<
vector
>
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
scoped_clear_last_error
.
h
"
#
include
"
base
/
strings
/
string_util
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
std
:
:
string
StringPrintf
(
const
char
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
std
:
:
string
result
;
StringAppendV
(
&
result
format
ap
)
;
va_end
(
ap
)
;
return
result
;
}
std
:
:
string
StringPrintV
(
const
char
*
format
va_list
ap
)
{
std
:
:
string
result
;
StringAppendV
(
&
result
format
ap
)
;
return
result
;
}
void
StringAppendF
(
std
:
:
string
*
dst
const
char
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
StringAppendV
(
dst
format
ap
)
;
va_end
(
ap
)
;
}
void
StringAppendV
(
std
:
:
string
*
dst
const
char
*
format
va_list
ap
)
{
char
stack_buf
[
1024
]
;
va_list
ap_copy
;
va_copy
(
ap_copy
ap
)
;
base
:
:
ScopedClearLastError
last_error
;
int
result
=
vsnprintf
(
stack_buf
std
:
:
size
(
stack_buf
)
format
ap_copy
)
;
va_end
(
ap_copy
)
;
if
(
result
>
=
0
&
&
static_cast
<
size_t
>
(
result
)
<
std
:
:
size
(
stack_buf
)
)
{
dst
-
>
append
(
stack_buf
static_cast
<
size_t
>
(
result
)
)
;
return
;
}
size_t
mem_length
=
std
:
:
size
(
stack_buf
)
;
while
(
true
)
{
if
(
result
<
0
)
{
#
if
BUILDFLAG
(
IS_WIN
)
return
;
#
else
if
(
errno
!
=
0
&
&
errno
!
=
EOVERFLOW
)
{
return
;
}
mem_length
*
=
2
;
#
endif
}
else
{
mem_length
=
static_cast
<
size_t
>
(
result
)
+
1
;
}
if
(
mem_length
>
32
*
1024
*
1024
)
{
DLOG
(
WARNING
)
<
<
"
Unable
to
printf
the
requested
string
due
to
size
.
"
;
return
;
}
std
:
:
vector
<
char
>
mem_buf
(
mem_length
)
;
va_copy
(
ap_copy
ap
)
;
result
=
vsnprintf
(
&
mem_buf
[
0
]
mem_length
format
ap_copy
)
;
va_end
(
ap_copy
)
;
if
(
(
result
>
=
0
)
&
&
(
static_cast
<
size_t
>
(
result
)
<
mem_length
)
)
{
dst
-
>
append
(
&
mem_buf
[
0
]
static_cast
<
size_t
>
(
result
)
)
;
return
;
}
}
}
}
