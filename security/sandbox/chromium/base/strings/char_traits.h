#
ifndef
BASE_STRINGS_CHAR_TRAITS_H_
#
define
BASE_STRINGS_CHAR_TRAITS_H_
#
include
<
stddef
.
h
>
#
include
"
base
/
compiler_specific
.
h
"
namespace
base
{
template
<
typename
T
>
struct
CharTraits
{
static
constexpr
int
compare
(
const
T
*
s1
const
T
*
s2
size_t
n
)
noexcept
;
static
constexpr
size_t
length
(
const
T
*
s
)
noexcept
;
}
;
template
<
typename
T
>
constexpr
int
CharTraits
<
T
>
:
:
compare
(
const
T
*
s1
const
T
*
s2
size_t
n
)
noexcept
{
for
(
;
n
;
-
-
n
+
+
s1
+
+
s2
)
{
if
(
*
s1
<
*
s2
)
return
-
1
;
if
(
*
s1
>
*
s2
)
return
1
;
}
return
0
;
}
template
<
typename
T
>
constexpr
size_t
CharTraits
<
T
>
:
:
length
(
const
T
*
s
)
noexcept
{
size_t
i
=
0
;
for
(
;
*
s
;
+
+
s
)
+
+
i
;
return
i
;
}
template
<
>
struct
CharTraits
<
char
>
{
static
constexpr
int
compare
(
const
char
*
s1
const
char
*
s2
size_t
n
)
noexcept
;
static
constexpr
size_t
length
(
const
char
*
s
)
noexcept
;
}
;
constexpr
int
CharTraits
<
char
>
:
:
compare
(
const
char
*
s1
const
char
*
s2
size_t
n
)
noexcept
{
#
if
HAS_FEATURE
(
cxx_constexpr_string_builtins
)
return
__builtin_memcmp
(
s1
s2
n
)
;
#
else
for
(
;
n
;
-
-
n
+
+
s1
+
+
s2
)
{
if
(
*
s1
<
*
s2
)
return
-
1
;
if
(
*
s1
>
*
s2
)
return
1
;
}
return
0
;
#
endif
}
constexpr
size_t
CharTraits
<
char
>
:
:
length
(
const
char
*
s
)
noexcept
{
#
if
defined
(
__clang__
)
return
__builtin_strlen
(
s
)
;
#
else
size_t
i
=
0
;
for
(
;
*
s
;
+
+
s
)
+
+
i
;
return
i
;
#
endif
}
}
#
endif
