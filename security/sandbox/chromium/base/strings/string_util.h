#
ifndef
BASE_STRINGS_STRING_UTIL_H_
#
define
BASE_STRINGS_STRING_UTIL_H_
#
include
<
ctype
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
initializer_list
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
bit_cast
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
stl_util
.
h
"
#
include
"
base
/
strings
/
string16
.
h
"
#
include
"
base
/
strings
/
string_piece
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
int
vsnprintf
(
char
*
buffer
size_t
size
const
char
*
format
va_list
arguments
)
PRINTF_FORMAT
(
3
0
)
;
inline
int
snprintf
(
char
*
buffer
size_t
size
const
char
*
format
.
.
.
)
PRINTF_FORMAT
(
3
4
)
;
inline
int
snprintf
(
char
*
buffer
size_t
size
const
char
*
format
.
.
.
)
{
va_list
arguments
;
va_start
(
arguments
format
)
;
int
result
=
vsnprintf
(
buffer
size
format
arguments
)
;
va_end
(
arguments
)
;
return
result
;
}
BASE_EXPORT
size_t
strlcpy
(
char
*
dst
const
char
*
src
size_t
dst_size
)
;
BASE_EXPORT
size_t
wcslcpy
(
wchar_t
*
dst
const
wchar_t
*
src
size_t
dst_size
)
;
BASE_EXPORT
bool
IsWprintfFormatPortable
(
const
wchar_t
*
format
)
;
inline
char
ToLowerASCII
(
char
c
)
{
return
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
?
(
c
+
(
'
a
'
-
'
A
'
)
)
:
c
;
}
inline
char16
ToLowerASCII
(
char16
c
)
{
return
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
?
(
c
+
(
'
a
'
-
'
A
'
)
)
:
c
;
}
inline
char
ToUpperASCII
(
char
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
?
(
c
+
(
'
A
'
-
'
a
'
)
)
:
c
;
}
inline
char16
ToUpperASCII
(
char16
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
?
(
c
+
(
'
A
'
-
'
a
'
)
)
:
c
;
}
BASE_EXPORT
std
:
:
string
ToLowerASCII
(
StringPiece
str
)
;
BASE_EXPORT
string16
ToLowerASCII
(
StringPiece16
str
)
;
BASE_EXPORT
std
:
:
string
ToUpperASCII
(
StringPiece
str
)
;
BASE_EXPORT
string16
ToUpperASCII
(
StringPiece16
str
)
;
template
<
typename
Char
>
struct
CaseInsensitiveCompareASCII
{
public
:
bool
operator
(
)
(
Char
x
Char
y
)
const
{
return
ToLowerASCII
(
x
)
=
=
ToLowerASCII
(
y
)
;
}
}
;
BASE_EXPORT
int
CompareCaseInsensitiveASCII
(
StringPiece
a
StringPiece
b
)
;
BASE_EXPORT
int
CompareCaseInsensitiveASCII
(
StringPiece16
a
StringPiece16
b
)
;
BASE_EXPORT
bool
EqualsCaseInsensitiveASCII
(
StringPiece
a
StringPiece
b
)
;
BASE_EXPORT
bool
EqualsCaseInsensitiveASCII
(
StringPiece16
a
StringPiece16
b
)
;
BASE_EXPORT
const
std
:
:
string
&
EmptyString
(
)
;
BASE_EXPORT
const
string16
&
EmptyString16
(
)
;
BASE_EXPORT
extern
const
wchar_t
kWhitespaceWide
[
]
;
BASE_EXPORT
extern
const
char16
kWhitespaceUTF16
[
]
;
BASE_EXPORT
extern
const
char
kWhitespaceASCII
[
]
;
BASE_EXPORT
extern
const
char16
kWhitespaceASCIIAs16
[
]
;
BASE_EXPORT
extern
const
char
kUtf8ByteOrderMark
[
]
;
BASE_EXPORT
bool
RemoveChars
(
const
string16
&
input
StringPiece16
remove_chars
string16
*
output
)
;
BASE_EXPORT
bool
RemoveChars
(
const
std
:
:
string
&
input
StringPiece
remove_chars
std
:
:
string
*
output
)
;
BASE_EXPORT
bool
ReplaceChars
(
const
string16
&
input
StringPiece16
replace_chars
const
string16
&
replace_with
string16
*
output
)
;
BASE_EXPORT
bool
ReplaceChars
(
const
std
:
:
string
&
input
StringPiece
replace_chars
const
std
:
:
string
&
replace_with
std
:
:
string
*
output
)
;
enum
TrimPositions
{
TRIM_NONE
=
0
TRIM_LEADING
=
1
<
<
0
TRIM_TRAILING
=
1
<
<
1
TRIM_ALL
=
TRIM_LEADING
|
TRIM_TRAILING
}
;
BASE_EXPORT
bool
TrimString
(
const
string16
&
input
StringPiece16
trim_chars
string16
*
output
)
;
BASE_EXPORT
bool
TrimString
(
const
std
:
:
string
&
input
StringPiece
trim_chars
std
:
:
string
*
output
)
;
BASE_EXPORT
StringPiece16
TrimString
(
StringPiece16
input
StringPiece16
trim_chars
TrimPositions
positions
)
;
BASE_EXPORT
StringPiece
TrimString
(
StringPiece
input
StringPiece
trim_chars
TrimPositions
positions
)
;
BASE_EXPORT
void
TruncateUTF8ToByteSize
(
const
std
:
:
string
&
input
const
size_t
byte_size
std
:
:
string
*
output
)
;
#
if
defined
(
WCHAR_T_IS_UTF16
)
inline
wchar_t
*
as_writable_wcstr
(
char16
*
str
)
{
return
bit_cast
<
wchar_t
*
>
(
str
)
;
}
inline
wchar_t
*
as_writable_wcstr
(
string16
&
str
)
{
return
bit_cast
<
wchar_t
*
>
(
data
(
str
)
)
;
}
inline
const
wchar_t
*
as_wcstr
(
const
char16
*
str
)
{
return
bit_cast
<
const
wchar_t
*
>
(
str
)
;
}
inline
const
wchar_t
*
as_wcstr
(
StringPiece16
str
)
{
return
bit_cast
<
const
wchar_t
*
>
(
str
.
data
(
)
)
;
}
inline
char16
*
as_writable_u16cstr
(
wchar_t
*
str
)
{
return
bit_cast
<
char16
*
>
(
str
)
;
}
inline
char16
*
as_writable_u16cstr
(
std
:
:
wstring
&
str
)
{
return
bit_cast
<
char16
*
>
(
data
(
str
)
)
;
}
inline
const
char16
*
as_u16cstr
(
const
wchar_t
*
str
)
{
return
bit_cast
<
const
char16
*
>
(
str
)
;
}
inline
const
char16
*
as_u16cstr
(
WStringPiece
str
)
{
return
bit_cast
<
const
char16
*
>
(
str
.
data
(
)
)
;
}
#
endif
BASE_EXPORT
TrimPositions
TrimWhitespace
(
const
string16
&
input
TrimPositions
positions
string16
*
output
)
;
BASE_EXPORT
StringPiece16
TrimWhitespace
(
StringPiece16
input
TrimPositions
positions
)
;
BASE_EXPORT
TrimPositions
TrimWhitespaceASCII
(
const
std
:
:
string
&
input
TrimPositions
positions
std
:
:
string
*
output
)
;
BASE_EXPORT
StringPiece
TrimWhitespaceASCII
(
StringPiece
input
TrimPositions
positions
)
;
BASE_EXPORT
string16
CollapseWhitespace
(
const
string16
&
text
bool
trim_sequences_with_line_breaks
)
;
BASE_EXPORT
std
:
:
string
CollapseWhitespaceASCII
(
const
std
:
:
string
&
text
bool
trim_sequences_with_line_breaks
)
;
BASE_EXPORT
bool
ContainsOnlyChars
(
StringPiece
input
StringPiece
characters
)
;
BASE_EXPORT
bool
ContainsOnlyChars
(
StringPiece16
input
StringPiece16
characters
)
;
BASE_EXPORT
bool
IsStringUTF8
(
StringPiece
str
)
;
BASE_EXPORT
bool
IsStringASCII
(
StringPiece
str
)
;
BASE_EXPORT
bool
IsStringASCII
(
StringPiece16
str
)
;
#
if
defined
(
WCHAR_T_IS_UTF32
)
BASE_EXPORT
bool
IsStringASCII
(
WStringPiece
str
)
;
#
endif
BASE_EXPORT
bool
LowerCaseEqualsASCII
(
StringPiece
str
StringPiece
lowecase_ascii
)
;
BASE_EXPORT
bool
LowerCaseEqualsASCII
(
StringPiece16
str
StringPiece
lowecase_ascii
)
;
BASE_EXPORT
bool
EqualsASCII
(
StringPiece16
str
StringPiece
ascii
)
;
enum
class
CompareCase
{
SENSITIVE
INSENSITIVE_ASCII
}
;
BASE_EXPORT
bool
StartsWith
(
StringPiece
str
StringPiece
search_for
CompareCase
case_sensitivity
)
;
BASE_EXPORT
bool
StartsWith
(
StringPiece16
str
StringPiece16
search_for
CompareCase
case_sensitivity
)
;
BASE_EXPORT
bool
EndsWith
(
StringPiece
str
StringPiece
search_for
CompareCase
case_sensitivity
)
;
BASE_EXPORT
bool
EndsWith
(
StringPiece16
str
StringPiece16
search_for
CompareCase
case_sensitivity
)
;
template
<
typename
Char
>
inline
bool
IsAsciiWhitespace
(
Char
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
r
'
|
|
c
=
=
'
\
n
'
|
|
c
=
=
'
\
t
'
|
|
c
=
=
'
\
f
'
;
}
template
<
typename
Char
>
inline
bool
IsAsciiAlpha
(
Char
c
)
{
return
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
|
|
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
;
}
template
<
typename
Char
>
inline
bool
IsAsciiUpper
(
Char
c
)
{
return
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
;
}
template
<
typename
Char
>
inline
bool
IsAsciiLower
(
Char
c
)
{
return
c
>
=
'
a
'
&
&
c
<
=
'
z
'
;
}
template
<
typename
Char
>
inline
bool
IsAsciiDigit
(
Char
c
)
{
return
c
>
=
'
0
'
&
&
c
<
=
'
9
'
;
}
template
<
typename
Char
>
inline
bool
IsHexDigit
(
Char
c
)
{
return
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
|
|
(
c
>
=
'
A
'
&
&
c
<
=
'
F
'
)
|
|
(
c
>
=
'
a
'
&
&
c
<
=
'
f
'
)
;
}
BASE_EXPORT
char
HexDigitToInt
(
wchar_t
c
)
;
BASE_EXPORT
bool
IsUnicodeWhitespace
(
wchar_t
c
)
;
BASE_EXPORT
string16
FormatBytesUnlocalized
(
int64_t
bytes
)
;
BASE_EXPORT
void
ReplaceFirstSubstringAfterOffset
(
base
:
:
string16
*
str
size_t
start_offset
StringPiece16
find_this
StringPiece16
replace_with
)
;
BASE_EXPORT
void
ReplaceFirstSubstringAfterOffset
(
std
:
:
string
*
str
size_t
start_offset
StringPiece
find_this
StringPiece
replace_with
)
;
BASE_EXPORT
void
ReplaceSubstringsAfterOffset
(
string16
*
str
size_t
start_offset
StringPiece16
find_this
StringPiece16
replace_with
)
;
BASE_EXPORT
void
ReplaceSubstringsAfterOffset
(
std
:
:
string
*
str
size_t
start_offset
StringPiece
find_this
StringPiece
replace_with
)
;
BASE_EXPORT
char
*
WriteInto
(
std
:
:
string
*
str
size_t
length_with_null
)
;
BASE_EXPORT
char16
*
WriteInto
(
string16
*
str
size_t
length_with_null
)
;
BASE_EXPORT
std
:
:
string
JoinString
(
const
std
:
:
vector
<
std
:
:
string
>
&
parts
StringPiece
separator
)
;
BASE_EXPORT
string16
JoinString
(
const
std
:
:
vector
<
string16
>
&
parts
StringPiece16
separator
)
;
BASE_EXPORT
std
:
:
string
JoinString
(
const
std
:
:
vector
<
StringPiece
>
&
parts
StringPiece
separator
)
;
BASE_EXPORT
string16
JoinString
(
const
std
:
:
vector
<
StringPiece16
>
&
parts
StringPiece16
separator
)
;
BASE_EXPORT
std
:
:
string
JoinString
(
std
:
:
initializer_list
<
StringPiece
>
parts
StringPiece
separator
)
;
BASE_EXPORT
string16
JoinString
(
std
:
:
initializer_list
<
StringPiece16
>
parts
StringPiece16
separator
)
;
BASE_EXPORT
string16
ReplaceStringPlaceholders
(
const
string16
&
format_string
const
std
:
:
vector
<
string16
>
&
subst
std
:
:
vector
<
size_t
>
*
offsets
)
;
BASE_EXPORT
std
:
:
string
ReplaceStringPlaceholders
(
StringPiece
format_string
const
std
:
:
vector
<
std
:
:
string
>
&
subst
std
:
:
vector
<
size_t
>
*
offsets
)
;
BASE_EXPORT
string16
ReplaceStringPlaceholders
(
const
string16
&
format_string
const
string16
&
a
size_t
*
offset
)
;
}
#
if
defined
(
OS_WIN
)
#
include
"
base
/
strings
/
string_util_win
.
h
"
#
elif
defined
(
OS_POSIX
)
|
|
defined
(
OS_FUCHSIA
)
#
include
"
base
/
strings
/
string_util_posix
.
h
"
#
else
#
error
Define
string
operations
appropriately
for
your
platform
#
endif
#
endif
