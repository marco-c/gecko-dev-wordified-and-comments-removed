#
ifndef
BASE_STRINGS_STRING_UTIL_H_
#
define
BASE_STRINGS_STRING_UTIL_H_
#
include
<
stdarg
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
initializer_list
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
vector
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
containers
/
span
.
h
"
#
include
"
base
/
cxx20_to_address
.
h
"
#
include
"
base
/
strings
/
string_piece
.
h
"
#
include
"
base
/
strings
/
string_util_internal
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
int
vsnprintf
(
char
*
buffer
size_t
size
const
char
*
format
va_list
arguments
)
PRINTF_FORMAT
(
3
0
)
;
inline
int
snprintf
(
char
*
buffer
size_t
size
const
char
*
format
.
.
.
)
PRINTF_FORMAT
(
3
4
)
;
inline
int
snprintf
(
char
*
buffer
size_t
size
const
char
*
format
.
.
.
)
{
va_list
arguments
;
va_start
(
arguments
format
)
;
int
result
=
vsnprintf
(
buffer
size
format
arguments
)
;
va_end
(
arguments
)
;
return
result
;
}
BASE_EXPORT
size_t
strlcpy
(
char
*
dst
const
char
*
src
size_t
dst_size
)
;
BASE_EXPORT
size_t
u16cstrlcpy
(
char16_t
*
dst
const
char16_t
*
src
size_t
dst_size
)
;
BASE_EXPORT
size_t
wcslcpy
(
wchar_t
*
dst
const
wchar_t
*
src
size_t
dst_size
)
;
BASE_EXPORT
bool
IsWprintfFormatPortable
(
const
wchar_t
*
format
)
;
template
<
typename
CharT
typename
Iter
>
constexpr
BasicStringPiece
<
CharT
>
MakeBasicStringPiece
(
Iter
begin
Iter
end
)
{
DCHECK_GE
(
end
-
begin
0
)
;
return
{
base
:
:
to_address
(
begin
)
static_cast
<
size_t
>
(
end
-
begin
)
}
;
}
template
<
typename
Iter
>
constexpr
StringPiece
MakeStringPiece
(
Iter
begin
Iter
end
)
{
return
MakeBasicStringPiece
<
char
>
(
begin
end
)
;
}
template
<
typename
Iter
>
constexpr
StringPiece16
MakeStringPiece16
(
Iter
begin
Iter
end
)
{
return
MakeBasicStringPiece
<
char16_t
>
(
begin
end
)
;
}
template
<
typename
Iter
>
constexpr
WStringPiece
MakeWStringPiece
(
Iter
begin
Iter
end
)
{
return
MakeBasicStringPiece
<
wchar_t
>
(
begin
end
)
;
}
template
<
typename
CharT
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
CharT
>
>
>
constexpr
CharT
ToLowerASCII
(
CharT
c
)
{
return
internal
:
:
ToLowerASCII
(
c
)
;
}
template
<
typename
CharT
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
CharT
>
>
>
CharT
ToUpperASCII
(
CharT
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
?
static_cast
<
CharT
>
(
c
+
'
A
'
-
'
a
'
)
:
c
;
}
BASE_EXPORT
std
:
:
string
ToLowerASCII
(
StringPiece
str
)
;
BASE_EXPORT
std
:
:
u16string
ToLowerASCII
(
StringPiece16
str
)
;
BASE_EXPORT
std
:
:
string
ToUpperASCII
(
StringPiece
str
)
;
BASE_EXPORT
std
:
:
u16string
ToUpperASCII
(
StringPiece16
str
)
;
template
<
typename
Char
>
struct
CaseInsensitiveCompareASCII
{
public
:
bool
operator
(
)
(
Char
x
Char
y
)
const
{
return
ToLowerASCII
(
x
)
=
=
ToLowerASCII
(
y
)
;
}
}
;
BASE_EXPORT
constexpr
int
CompareCaseInsensitiveASCII
(
StringPiece
a
StringPiece
b
)
{
return
internal
:
:
CompareCaseInsensitiveASCIIT
(
a
b
)
;
}
BASE_EXPORT
constexpr
int
CompareCaseInsensitiveASCII
(
StringPiece16
a
StringPiece16
b
)
{
return
internal
:
:
CompareCaseInsensitiveASCIIT
(
a
b
)
;
}
inline
bool
EqualsCaseInsensitiveASCII
(
StringPiece
a
StringPiece
b
)
{
return
internal
:
:
EqualsCaseInsensitiveASCIIT
(
a
b
)
;
}
inline
bool
EqualsCaseInsensitiveASCII
(
StringPiece16
a
StringPiece16
b
)
{
return
internal
:
:
EqualsCaseInsensitiveASCIIT
(
a
b
)
;
}
inline
bool
EqualsCaseInsensitiveASCII
(
StringPiece16
a
StringPiece
b
)
{
return
internal
:
:
EqualsCaseInsensitiveASCIIT
(
a
b
)
;
}
inline
bool
EqualsCaseInsensitiveASCII
(
StringPiece
a
StringPiece16
b
)
{
return
internal
:
:
EqualsCaseInsensitiveASCIIT
(
a
b
)
;
}
BASE_EXPORT
const
std
:
:
string
&
EmptyString
(
)
;
BASE_EXPORT
const
std
:
:
u16string
&
EmptyString16
(
)
;
BASE_EXPORT
extern
const
wchar_t
kWhitespaceWide
[
]
;
BASE_EXPORT
extern
const
char16_t
kWhitespaceUTF16
[
]
;
BASE_EXPORT
extern
const
char16_t
kWhitespaceNoCrLfUTF16
[
]
;
BASE_EXPORT
extern
const
char
kWhitespaceASCII
[
]
;
BASE_EXPORT
extern
const
char16_t
kWhitespaceASCIIAs16
[
]
;
BASE_EXPORT
extern
const
char
kInfraAsciiWhitespace
[
]
;
BASE_EXPORT
extern
const
char
kUtf8ByteOrderMark
[
]
;
BASE_EXPORT
bool
RemoveChars
(
StringPiece16
input
StringPiece16
remove_chars
std
:
:
u16string
*
output
)
;
BASE_EXPORT
bool
RemoveChars
(
StringPiece
input
StringPiece
remove_chars
std
:
:
string
*
output
)
;
BASE_EXPORT
bool
ReplaceChars
(
StringPiece16
input
StringPiece16
replace_chars
StringPiece16
replace_with
std
:
:
u16string
*
output
)
;
BASE_EXPORT
bool
ReplaceChars
(
StringPiece
input
StringPiece
replace_chars
StringPiece
replace_with
std
:
:
string
*
output
)
;
enum
TrimPositions
{
TRIM_NONE
=
0
TRIM_LEADING
=
1
<
<
0
TRIM_TRAILING
=
1
<
<
1
TRIM_ALL
=
TRIM_LEADING
|
TRIM_TRAILING
}
;
BASE_EXPORT
bool
TrimString
(
StringPiece16
input
StringPiece16
trim_chars
std
:
:
u16string
*
output
)
;
BASE_EXPORT
bool
TrimString
(
StringPiece
input
StringPiece
trim_chars
std
:
:
string
*
output
)
;
BASE_EXPORT
StringPiece16
TrimString
(
StringPiece16
input
StringPiece16
trim_chars
TrimPositions
positions
)
;
BASE_EXPORT
StringPiece
TrimString
(
StringPiece
input
StringPiece
trim_chars
TrimPositions
positions
)
;
BASE_EXPORT
void
TruncateUTF8ToByteSize
(
const
std
:
:
string
&
input
const
size_t
byte_size
std
:
:
string
*
output
)
;
BASE_EXPORT
TrimPositions
TrimWhitespace
(
StringPiece16
input
TrimPositions
positions
std
:
:
u16string
*
output
)
;
BASE_EXPORT
StringPiece16
TrimWhitespace
(
StringPiece16
input
TrimPositions
positions
)
;
BASE_EXPORT
TrimPositions
TrimWhitespaceASCII
(
StringPiece
input
TrimPositions
positions
std
:
:
string
*
output
)
;
BASE_EXPORT
StringPiece
TrimWhitespaceASCII
(
StringPiece
input
TrimPositions
positions
)
;
BASE_EXPORT
std
:
:
u16string
CollapseWhitespace
(
StringPiece16
text
bool
trim_sequences_with_line_breaks
)
;
BASE_EXPORT
std
:
:
string
CollapseWhitespaceASCII
(
StringPiece
text
bool
trim_sequences_with_line_breaks
)
;
BASE_EXPORT
bool
ContainsOnlyChars
(
StringPiece
input
StringPiece
characters
)
;
BASE_EXPORT
bool
ContainsOnlyChars
(
StringPiece16
input
StringPiece16
characters
)
;
BASE_EXPORT
bool
IsStringUTF8
(
StringPiece
str
)
;
BASE_EXPORT
bool
IsStringUTF8AllowingNoncharacters
(
StringPiece
str
)
;
BASE_EXPORT
bool
IsStringASCII
(
StringPiece
str
)
;
BASE_EXPORT
bool
IsStringASCII
(
StringPiece16
str
)
;
#
if
defined
(
WCHAR_T_IS_UTF32
)
BASE_EXPORT
bool
IsStringASCII
(
WStringPiece
str
)
;
#
endif
BASE_EXPORT
bool
EqualsASCII
(
StringPiece16
str
StringPiece
ascii
)
;
enum
class
CompareCase
{
SENSITIVE
INSENSITIVE_ASCII
}
;
BASE_EXPORT
bool
StartsWith
(
StringPiece
str
StringPiece
search_for
CompareCase
case_sensitivity
=
CompareCase
:
:
SENSITIVE
)
;
BASE_EXPORT
bool
StartsWith
(
StringPiece16
str
StringPiece16
search_for
CompareCase
case_sensitivity
=
CompareCase
:
:
SENSITIVE
)
;
BASE_EXPORT
bool
EndsWith
(
StringPiece
str
StringPiece
search_for
CompareCase
case_sensitivity
=
CompareCase
:
:
SENSITIVE
)
;
BASE_EXPORT
bool
EndsWith
(
StringPiece16
str
StringPiece16
search_for
CompareCase
case_sensitivity
=
CompareCase
:
:
SENSITIVE
)
;
template
<
typename
Char
>
inline
bool
IsAsciiWhitespace
(
Char
c
)
{
for
(
const
char
*
cur
=
kWhitespaceASCII
;
*
cur
;
+
+
cur
)
{
if
(
*
cur
=
=
c
)
return
true
;
}
return
false
;
}
template
<
typename
Char
>
inline
bool
IsAsciiAlpha
(
Char
c
)
{
return
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
|
|
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
;
}
template
<
typename
Char
>
inline
bool
IsAsciiUpper
(
Char
c
)
{
return
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
;
}
template
<
typename
Char
>
inline
bool
IsAsciiLower
(
Char
c
)
{
return
c
>
=
'
a
'
&
&
c
<
=
'
z
'
;
}
template
<
typename
Char
>
inline
bool
IsAsciiDigit
(
Char
c
)
{
return
c
>
=
'
0
'
&
&
c
<
=
'
9
'
;
}
template
<
typename
Char
>
inline
bool
IsAsciiAlphaNumeric
(
Char
c
)
{
return
IsAsciiAlpha
(
c
)
|
|
IsAsciiDigit
(
c
)
;
}
template
<
typename
Char
>
inline
bool
IsAsciiPrintable
(
Char
c
)
{
return
c
>
=
'
'
&
&
c
<
=
'
~
'
;
}
template
<
typename
Char
>
inline
bool
IsAsciiControl
(
Char
c
)
{
if
constexpr
(
std
:
:
is_signed_v
<
Char
>
)
{
if
(
c
<
0
)
{
return
false
;
}
}
return
c
<
=
0x1f
|
|
c
=
=
0x7f
;
}
template
<
typename
Char
>
inline
bool
IsUnicodeControl
(
Char
c
)
{
return
IsAsciiControl
(
c
)
|
|
(
c
>
=
0x80
&
&
c
<
=
0x9F
)
;
}
template
<
typename
Char
>
inline
bool
IsAsciiPunctuation
(
Char
c
)
{
return
c
>
0x20
&
&
c
<
0x7f
&
&
!
IsAsciiAlphaNumeric
(
c
)
;
}
template
<
typename
Char
>
inline
bool
IsHexDigit
(
Char
c
)
{
return
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
|
|
(
c
>
=
'
A
'
&
&
c
<
=
'
F
'
)
|
|
(
c
>
=
'
a
'
&
&
c
<
=
'
f
'
)
;
}
BASE_EXPORT
char
HexDigitToInt
(
char
c
)
;
inline
char
HexDigitToInt
(
char16_t
c
)
{
DCHECK
(
IsHexDigit
(
c
)
)
;
return
HexDigitToInt
(
static_cast
<
char
>
(
c
)
)
;
}
template
<
typename
Char
typename
=
std
:
:
enable_if_t
<
(
sizeof
(
Char
)
>
1
)
>
>
inline
bool
IsUnicodeWhitespace
(
Char
c
)
{
for
(
const
auto
*
cur
=
kWhitespaceWide
;
*
cur
;
+
+
cur
)
{
if
(
static_cast
<
typename
std
:
:
make_unsigned_t
<
wchar_t
>
>
(
*
cur
)
=
=
static_cast
<
typename
std
:
:
make_unsigned_t
<
Char
>
>
(
c
)
)
return
true
;
}
return
false
;
}
template
<
typename
Char
>
inline
bool
IsWhitespace
(
Char
c
)
{
if
constexpr
(
sizeof
(
Char
)
>
1
)
{
return
IsUnicodeWhitespace
(
c
)
;
}
else
{
return
IsAsciiWhitespace
(
c
)
;
}
}
BASE_EXPORT
std
:
:
u16string
FormatBytesUnlocalized
(
int64_t
bytes
)
;
BASE_EXPORT
void
ReplaceFirstSubstringAfterOffset
(
std
:
:
u16string
*
str
size_t
start_offset
StringPiece16
find_this
StringPiece16
replace_with
)
;
BASE_EXPORT
void
ReplaceFirstSubstringAfterOffset
(
std
:
:
string
*
str
size_t
start_offset
StringPiece
find_this
StringPiece
replace_with
)
;
BASE_EXPORT
void
ReplaceSubstringsAfterOffset
(
std
:
:
u16string
*
str
size_t
start_offset
StringPiece16
find_this
StringPiece16
replace_with
)
;
BASE_EXPORT
void
ReplaceSubstringsAfterOffset
(
std
:
:
string
*
str
size_t
start_offset
StringPiece
find_this
StringPiece
replace_with
)
;
BASE_EXPORT
char
*
WriteInto
(
std
:
:
string
*
str
size_t
length_with_null
)
;
BASE_EXPORT
char16_t
*
WriteInto
(
std
:
:
u16string
*
str
size_t
length_with_null
)
;
BASE_EXPORT
std
:
:
string
JoinString
(
span
<
const
std
:
:
string
>
parts
StringPiece
separator
)
;
BASE_EXPORT
std
:
:
u16string
JoinString
(
span
<
const
std
:
:
u16string
>
parts
StringPiece16
separator
)
;
BASE_EXPORT
std
:
:
string
JoinString
(
span
<
const
StringPiece
>
parts
StringPiece
separator
)
;
BASE_EXPORT
std
:
:
u16string
JoinString
(
span
<
const
StringPiece16
>
parts
StringPiece16
separator
)
;
BASE_EXPORT
std
:
:
string
JoinString
(
std
:
:
initializer_list
<
StringPiece
>
parts
StringPiece
separator
)
;
BASE_EXPORT
std
:
:
u16string
JoinString
(
std
:
:
initializer_list
<
StringPiece16
>
parts
StringPiece16
separator
)
;
BASE_EXPORT
std
:
:
u16string
ReplaceStringPlaceholders
(
StringPiece16
format_string
const
std
:
:
vector
<
std
:
:
u16string
>
&
subst
std
:
:
vector
<
size_t
>
*
offsets
)
;
BASE_EXPORT
std
:
:
string
ReplaceStringPlaceholders
(
StringPiece
format_string
const
std
:
:
vector
<
std
:
:
string
>
&
subst
std
:
:
vector
<
size_t
>
*
offsets
)
;
BASE_EXPORT
std
:
:
u16string
ReplaceStringPlaceholders
(
const
std
:
:
u16string
&
format_string
const
std
:
:
u16string
&
a
size_t
*
offset
)
;
}
#
if
BUILDFLAG
(
IS_WIN
)
#
include
"
base
/
strings
/
string_util_win
.
h
"
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
#
include
"
base
/
strings
/
string_util_posix
.
h
"
#
else
#
error
Define
string
operations
appropriately
for
your
platform
#
endif
#
endif
