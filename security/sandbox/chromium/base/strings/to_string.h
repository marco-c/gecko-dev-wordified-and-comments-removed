#
ifndef
BASE_STRINGS_TO_STRING_H_
#
define
BASE_STRINGS_TO_STRING_H_
#
include
<
ios
>
#
include
<
memory
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
template_util
.
h
"
#
include
"
base
/
types
/
supports_ostream_operator
.
h
"
namespace
base
{
template
<
typename
.
.
.
Ts
>
std
:
:
string
ToString
(
const
Ts
&
.
.
.
values
)
;
namespace
internal
{
template
<
typename
T
typename
=
void
>
struct
SupportsToString
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
SupportsToString
<
T
decltype
(
void
(
std
:
:
declval
<
T
>
(
)
.
ToString
(
)
)
)
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
typename
=
void
>
constexpr
bool
IsIomanip
=
false
;
template
<
typename
T
>
constexpr
bool
IsIomanip
<
T
&
(
T
&
)
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
std
:
:
ios_base
T
>
>
>
=
true
;
template
<
typename
T
typename
=
void
>
constexpr
bool
WillBeIncorrectlyStreamedAsBool
=
false
;
template
<
typename
T
>
constexpr
bool
WillBeIncorrectlyStreamedAsBool
<
T
std
:
:
enable_if_t
<
std
:
:
is_function_v
<
std
:
:
remove_pointer_t
<
T
>
>
&
&
!
IsIomanip
<
std
:
:
remove_pointer_t
<
T
>
>
>
>
=
true
;
template
<
typename
T
typename
=
void
>
struct
ToStringHelper
{
static
void
Stringify
(
const
T
&
v
std
:
:
ostringstream
&
ss
)
{
ss
<
<
"
[
"
<
<
sizeof
(
v
)
<
<
"
-
byte
object
at
0x
"
<
<
std
:
:
addressof
(
v
)
<
<
"
]
"
;
}
}
;
template
<
typename
T
>
struct
ToStringHelper
<
T
std
:
:
enable_if_t
<
SupportsOstreamOperator
<
const
T
&
>
:
:
value
&
&
!
WillBeIncorrectlyStreamedAsBool
<
T
>
>
>
{
static
void
Stringify
(
const
T
&
v
std
:
:
ostringstream
&
ss
)
{
ss
<
<
v
;
}
}
;
template
<
typename
T
>
struct
ToStringHelper
<
T
std
:
:
enable_if_t
<
SupportsOstreamOperator
<
const
T
&
>
:
:
value
&
&
WillBeIncorrectlyStreamedAsBool
<
T
>
>
>
{
static
void
Stringify
(
const
T
&
v
std
:
:
ostringstream
&
ss
)
{
ToStringHelper
<
const
void
*
>
:
:
Stringify
(
reinterpret_cast
<
const
void
*
>
(
v
)
ss
)
;
}
}
;
template
<
typename
T
>
struct
ToStringHelper
<
T
std
:
:
enable_if_t
<
!
SupportsOstreamOperator
<
const
T
&
>
:
:
value
&
&
SupportsToString
<
const
T
&
>
:
:
value
>
>
{
static
void
Stringify
(
const
T
&
v
std
:
:
ostringstream
&
ss
)
{
ToStringHelper
<
decltype
(
v
.
ToString
(
)
)
>
:
:
Stringify
(
v
.
ToString
(
)
ss
)
;
}
}
;
template
<
typename
T
>
struct
ToStringHelper
<
T
std
:
:
enable_if_t
<
!
SupportsOstreamOperator
<
const
T
&
>
:
:
value
&
&
std
:
:
is_enum_v
<
T
>
>
>
{
static
void
Stringify
(
const
T
&
v
std
:
:
ostringstream
&
ss
)
{
using
UT
=
typename
std
:
:
underlying_type_t
<
T
>
;
ToStringHelper
<
UT
>
:
:
Stringify
(
static_cast
<
UT
>
(
v
)
ss
)
;
}
}
;
template
<
typename
.
.
.
T
>
struct
ToStringHelper
<
std
:
:
tuple
<
T
.
.
.
>
>
{
template
<
size_t
.
.
.
I
>
static
void
StringifyHelper
(
const
std
:
:
tuple
<
T
.
.
.
>
&
values
std
:
:
index_sequence
<
I
.
.
.
>
std
:
:
ostringstream
&
ss
)
{
ss
<
<
"
<
"
;
(
.
.
.
(
ss
<
<
(
I
=
=
0
?
"
"
:
"
"
)
ss
<
<
ToString
(
std
:
:
get
<
I
>
(
values
)
)
)
)
;
ss
<
<
"
>
"
;
}
static
void
Stringify
(
const
std
:
:
tuple
<
T
.
.
.
>
&
v
std
:
:
ostringstream
&
ss
)
{
StringifyHelper
(
v
std
:
:
make_index_sequence
<
sizeof
.
.
.
(
T
)
>
(
)
ss
)
;
}
}
;
}
template
<
typename
.
.
.
Ts
>
std
:
:
string
ToString
(
const
Ts
&
.
.
.
values
)
{
std
:
:
ostringstream
ss
;
(
.
.
.
internal
:
:
ToStringHelper
<
remove_cvref_t
<
decltype
(
values
)
>
>
:
:
Stringify
(
values
ss
)
)
;
return
ss
.
str
(
)
;
}
}
#
endif
