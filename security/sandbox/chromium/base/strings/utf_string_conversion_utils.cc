#
include
"
base
/
strings
/
utf_string_conversion_utils
.
h
"
#
include
"
base
/
third_party
/
icu
/
icu_utf
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
absl
:
:
optional
<
size_t
>
CountUnicodeCharacters
(
std
:
:
string_view
text
size_t
limit
)
{
base_icu
:
:
UChar32
unused
=
0
;
size_t
count
=
0
;
for
(
size_t
index
=
0
;
count
<
limit
&
&
index
<
text
.
size
(
)
;
+
+
count
+
+
index
)
{
if
(
!
ReadUnicodeCharacter
(
text
.
data
(
)
text
.
size
(
)
&
index
&
unused
)
)
{
return
absl
:
:
nullopt
;
}
}
return
count
;
}
bool
ReadUnicodeCharacter
(
const
char
*
src
size_t
src_len
size_t
*
char_index
base_icu
:
:
UChar32
*
code_point_out
)
{
base_icu
:
:
UChar32
code_point
;
CBU8_NEXT
(
reinterpret_cast
<
const
uint8_t
*
>
(
src
)
*
char_index
src_len
code_point
)
;
*
code_point_out
=
code_point
;
(
*
char_index
)
-
-
;
return
IsValidCodepoint
(
code_point
)
;
}
bool
ReadUnicodeCharacter
(
const
char16_t
*
src
size_t
src_len
size_t
*
char_index
base_icu
:
:
UChar32
*
code_point
)
{
if
(
CBU16_IS_SURROGATE
(
src
[
*
char_index
]
)
)
{
if
(
!
CBU16_IS_SURROGATE_LEAD
(
src
[
*
char_index
]
)
|
|
!
src_len
|
|
*
char_index
>
=
src_len
-
1
|
|
!
CBU16_IS_TRAIL
(
src
[
*
char_index
+
1
]
)
)
{
return
false
;
}
*
code_point
=
CBU16_GET_SUPPLEMENTARY
(
src
[
*
char_index
]
src
[
*
char_index
+
1
]
)
;
(
*
char_index
)
+
+
;
}
else
{
*
code_point
=
src
[
*
char_index
]
;
}
return
IsValidCodepoint
(
*
code_point
)
;
}
#
if
defined
(
WCHAR_T_IS_UTF32
)
bool
ReadUnicodeCharacter
(
const
wchar_t
*
src
size_t
src_len
size_t
*
char_index
base_icu
:
:
UChar32
*
code_point
)
{
*
code_point
=
static_cast
<
base_icu
:
:
UChar32
>
(
src
[
*
char_index
]
)
;
return
IsValidCodepoint
(
*
code_point
)
;
}
#
endif
size_t
WriteUnicodeCharacter
(
base_icu
:
:
UChar32
code_point
std
:
:
string
*
output
)
{
if
(
code_point
>
=
0
&
&
code_point
<
=
0x7f
)
{
output
-
>
push_back
(
static_cast
<
char
>
(
code_point
)
)
;
return
1
;
}
size_t
char_offset
=
output
-
>
length
(
)
;
size_t
original_char_offset
=
char_offset
;
output
-
>
resize
(
char_offset
+
CBU8_MAX_LENGTH
)
;
CBU8_APPEND_UNSAFE
(
reinterpret_cast
<
uint8_t
*
>
(
output
-
>
data
(
)
)
char_offset
code_point
)
;
output
-
>
resize
(
char_offset
)
;
return
char_offset
-
original_char_offset
;
}
size_t
WriteUnicodeCharacter
(
base_icu
:
:
UChar32
code_point
std
:
:
u16string
*
output
)
{
if
(
CBU16_LENGTH
(
code_point
)
=
=
1
)
{
output
-
>
push_back
(
static_cast
<
char16_t
>
(
code_point
)
)
;
return
1
;
}
size_t
char_offset
=
output
-
>
length
(
)
;
output
-
>
resize
(
char_offset
+
CBU16_MAX_LENGTH
)
;
CBU16_APPEND_UNSAFE
(
&
(
*
output
)
[
0
]
char_offset
code_point
)
;
return
CBU16_MAX_LENGTH
;
}
template
<
typename
CHAR
>
void
PrepareForUTF8Output
(
const
CHAR
*
src
size_t
src_len
std
:
:
string
*
output
)
{
output
-
>
clear
(
)
;
if
(
src_len
=
=
0
)
return
;
if
(
src
[
0
]
<
0x80
)
{
output
-
>
reserve
(
src_len
)
;
}
else
{
output
-
>
reserve
(
src_len
*
3
)
;
}
}
#
if
!
BUILDFLAG
(
IS_WIN
)
template
void
PrepareForUTF8Output
(
const
wchar_t
*
size_t
std
:
:
string
*
)
;
#
endif
template
void
PrepareForUTF8Output
(
const
char16_t
*
size_t
std
:
:
string
*
)
;
template
<
typename
STRING
>
void
PrepareForUTF16Or32Output
(
const
char
*
src
size_t
src_len
STRING
*
output
)
{
output
-
>
clear
(
)
;
if
(
src_len
=
=
0
)
return
;
if
(
static_cast
<
unsigned
char
>
(
src
[
0
]
)
<
0x80
)
{
output
-
>
reserve
(
src_len
)
;
}
else
{
output
-
>
reserve
(
src_len
/
2
)
;
}
}
#
if
!
BUILDFLAG
(
IS_WIN
)
template
void
PrepareForUTF16Or32Output
(
const
char
*
size_t
std
:
:
wstring
*
)
;
#
endif
template
void
PrepareForUTF16Or32Output
(
const
char
*
size_t
std
:
:
u16string
*
)
;
}
