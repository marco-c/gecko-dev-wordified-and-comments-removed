#
ifndef
BASE_HASH_HASH_H_
#
define
BASE_HASH_HASH_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
limits
>
#
include
<
string
>
#
include
<
string_view
>
#
include
<
utility
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
containers
/
span
.
h
"
#
include
"
base
/
strings
/
string_piece
.
h
"
namespace
base
{
BASE_EXPORT
uint32_t
Hash
(
const
void
*
data
size_t
length
)
;
BASE_EXPORT
uint32_t
Hash
(
const
std
:
:
string
&
str
)
;
BASE_EXPORT
size_t
FastHash
(
base
:
:
span
<
const
uint8_t
>
data
)
;
inline
size_t
FastHash
(
StringPiece
str
)
{
return
FastHash
(
as_bytes
(
make_span
(
str
)
)
)
;
}
BASE_EXPORT
uint32_t
PersistentHash
(
base
:
:
span
<
const
uint8_t
>
data
)
;
BASE_EXPORT
uint32_t
PersistentHash
(
const
void
*
data
size_t
length
)
;
BASE_EXPORT
uint32_t
PersistentHash
(
std
:
:
string_view
str
)
;
BASE_EXPORT
size_t
HashInts32
(
uint32_t
value1
uint32_t
value2
)
;
BASE_EXPORT
size_t
HashInts64
(
uint64_t
value1
uint64_t
value2
)
;
template
<
typename
T1
typename
T2
>
inline
size_t
HashInts
(
T1
value1
T2
value2
)
{
if
(
sizeof
(
T1
)
>
sizeof
(
uint32_t
)
|
|
(
sizeof
(
T2
)
>
sizeof
(
uint32_t
)
)
)
return
HashInts64
(
value1
value2
)
;
return
HashInts32
(
static_cast
<
uint32_t
>
(
value1
)
static_cast
<
uint32_t
>
(
value2
)
)
;
}
template
<
typename
T
>
struct
IntPairHash
;
template
<
typename
Type1
typename
Type2
>
struct
IntPairHash
<
std
:
:
pair
<
Type1
Type2
>
>
{
size_t
operator
(
)
(
std
:
:
pair
<
Type1
Type2
>
value
)
const
{
return
HashInts
(
value
.
first
value
.
second
)
;
}
}
;
}
#
endif
