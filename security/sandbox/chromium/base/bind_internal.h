#
ifndef
BASE_BIND_INTERNAL_H_
#
define
BASE_BIND_INTERNAL_H_
#
include
<
stddef
.
h
>
#
include
<
type_traits
>
#
include
"
base
/
bind_helpers
.
h
"
#
include
"
base
/
callback_internal
.
h
"
#
include
"
base
/
memory
/
raw_scoped_refptr_mismatch_checker
.
h
"
#
include
"
base
/
memory
/
weak_ptr
.
h
"
#
include
"
base
/
template_util
.
h
"
#
include
"
base
/
tuple
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
defined
(
OS_WIN
)
#
include
"
base
/
bind_internal_win
.
h
"
#
endif
namespace
base
{
namespace
internal
{
template
<
typename
List
>
struct
HasNonConstReferenceItem
:
false_type
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
struct
HasNonConstReferenceItem
<
TypeList
<
T
Args
.
.
.
>
>
:
std
:
:
conditional
<
is_non_const_reference
<
T
>
:
:
value
true_type
HasNonConstReferenceItem
<
TypeList
<
Args
.
.
.
>
>
>
:
:
type
{
}
;
template
<
typename
.
.
.
Args
>
struct
HasRefCountedTypeAsRawPtr
:
false_type
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
struct
HasRefCountedTypeAsRawPtr
<
T
Args
.
.
.
>
:
std
:
:
conditional
<
NeedsScopedRefptrButGetsRawPtr
<
T
>
:
:
value
true_type
HasRefCountedTypeAsRawPtr
<
Args
.
.
.
>
>
:
:
type
{
}
;
template
<
bool
is_method
typename
.
.
.
Args
>
struct
BindsArrayToFirstArg
:
false_type
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
struct
BindsArrayToFirstArg
<
true
T
Args
.
.
.
>
:
is_array
<
T
>
{
}
;
template
<
bool
is_method
typename
.
.
.
Args
>
struct
HasRefCountedParamAsRawPtr
:
HasRefCountedTypeAsRawPtr
<
Args
.
.
.
>
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
struct
HasRefCountedParamAsRawPtr
<
true
T
Args
.
.
.
>
:
HasRefCountedTypeAsRawPtr
<
Args
.
.
.
>
{
}
;
template
<
typename
Functor
>
class
RunnableAdapter
;
template
<
typename
R
typename
.
.
.
Args
>
class
RunnableAdapter
<
R
(
*
)
(
Args
.
.
.
)
>
{
public
:
typedef
R
RunType
(
Args
.
.
.
)
;
explicit
RunnableAdapter
(
R
(
*
function
)
(
Args
.
.
.
)
)
:
function_
(
function
)
{
}
R
Run
(
typename
CallbackParamTraits
<
Args
>
:
:
ForwardType
.
.
.
args
)
{
return
function_
(
CallbackForward
(
args
)
.
.
.
)
;
}
private
:
R
(
*
function_
)
(
Args
.
.
.
)
;
}
;
template
<
typename
R
typename
T
typename
.
.
.
Args
>
class
RunnableAdapter
<
R
(
T
:
:
*
)
(
Args
.
.
.
)
>
{
public
:
typedef
R
RunType
(
T
*
Args
.
.
.
)
;
using
IsMethod
=
true_type
;
explicit
RunnableAdapter
(
R
(
T
:
:
*
method
)
(
Args
.
.
.
)
)
:
method_
(
method
)
{
}
R
Run
(
T
*
object
typename
CallbackParamTraits
<
Args
>
:
:
ForwardType
.
.
.
args
)
{
return
(
object
-
>
*
method_
)
(
CallbackForward
(
args
)
.
.
.
)
;
}
private
:
R
(
T
:
:
*
method_
)
(
Args
.
.
.
)
;
}
;
template
<
typename
R
typename
T
typename
.
.
.
Args
>
class
RunnableAdapter
<
R
(
T
:
:
*
)
(
Args
.
.
.
)
const
>
{
public
:
using
RunType
=
R
(
const
T
*
Args
.
.
.
)
;
using
IsMethod
=
true_type
;
explicit
RunnableAdapter
(
R
(
T
:
:
*
method
)
(
Args
.
.
.
)
const
)
:
method_
(
method
)
{
}
R
Run
(
const
T
*
object
typename
CallbackParamTraits
<
Args
>
:
:
ForwardType
.
.
.
args
)
{
return
(
object
-
>
*
method_
)
(
CallbackForward
(
args
)
.
.
.
)
;
}
private
:
R
(
T
:
:
*
method_
)
(
Args
.
.
.
)
const
;
}
;
template
<
typename
Sig
>
struct
ForceVoidReturn
;
template
<
typename
R
typename
.
.
.
Args
>
struct
ForceVoidReturn
<
R
(
Args
.
.
.
)
>
{
typedef
void
RunType
(
Args
.
.
.
)
;
}
;
template
<
typename
T
>
struct
FunctorTraits
{
using
RunnableType
=
RunnableAdapter
<
T
>
;
using
RunType
=
typename
RunnableType
:
:
RunType
;
}
;
template
<
typename
T
>
struct
FunctorTraits
<
IgnoreResultHelper
<
T
>
>
{
using
RunnableType
=
typename
FunctorTraits
<
T
>
:
:
RunnableType
;
using
RunType
=
typename
ForceVoidReturn
<
typename
RunnableType
:
:
RunType
>
:
:
RunType
;
}
;
template
<
typename
T
>
struct
FunctorTraits
<
Callback
<
T
>
>
{
using
RunnableType
=
Callback
<
T
>
;
using
RunType
=
typename
Callback
<
T
>
:
:
RunType
;
}
;
template
<
typename
T
>
typename
FunctorTraits
<
T
>
:
:
RunnableType
MakeRunnable
(
const
T
&
t
)
{
return
RunnableAdapter
<
T
>
(
t
)
;
}
template
<
typename
T
>
typename
FunctorTraits
<
T
>
:
:
RunnableType
MakeRunnable
(
const
IgnoreResultHelper
<
T
>
&
t
)
{
return
MakeRunnable
(
t
.
functor_
)
;
}
template
<
typename
T
>
const
typename
FunctorTraits
<
Callback
<
T
>
>
:
:
RunnableType
&
MakeRunnable
(
const
Callback
<
T
>
&
t
)
{
DCHECK
(
!
t
.
is_null
(
)
)
;
return
t
;
}
template
<
bool
IsWeakCall
typename
ReturnType
typename
Runnable
typename
ArgsType
>
struct
InvokeHelper
;
template
<
typename
ReturnType
typename
Runnable
typename
.
.
.
Args
>
struct
InvokeHelper
<
false
ReturnType
Runnable
TypeList
<
Args
.
.
.
>
>
{
static
ReturnType
MakeItSo
(
Runnable
runnable
Args
.
.
.
args
)
{
return
runnable
.
Run
(
CallbackForward
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
Runnable
typename
.
.
.
Args
>
struct
InvokeHelper
<
false
void
Runnable
TypeList
<
Args
.
.
.
>
>
{
static
void
MakeItSo
(
Runnable
runnable
Args
.
.
.
args
)
{
runnable
.
Run
(
CallbackForward
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
Runnable
typename
BoundWeakPtr
typename
.
.
.
Args
>
struct
InvokeHelper
<
true
void
Runnable
TypeList
<
BoundWeakPtr
Args
.
.
.
>
>
{
static
void
MakeItSo
(
Runnable
runnable
BoundWeakPtr
weak_ptr
Args
.
.
.
args
)
{
if
(
!
weak_ptr
.
get
(
)
)
{
return
;
}
runnable
.
Run
(
weak_ptr
.
get
(
)
CallbackForward
(
args
)
.
.
.
)
;
}
}
;
#
if
!
defined
(
_MSC_VER
)
template
<
typename
ReturnType
typename
Runnable
typename
ArgsType
>
struct
InvokeHelper
<
true
ReturnType
Runnable
ArgsType
>
{
static_assert
(
is_void
<
ReturnType
>
:
:
value
"
weak_ptrs
can
only
bind
to
methods
without
return
values
"
)
;
}
;
#
endif
template
<
typename
BoundIndices
typename
StorageType
typename
Unwrappers
typename
InvokeHelperType
typename
UnboundForwardRunType
>
struct
Invoker
;
template
<
size_t
.
.
.
bound_indices
typename
StorageType
typename
.
.
.
Unwrappers
typename
InvokeHelperType
typename
R
typename
.
.
.
UnboundForwardArgs
>
struct
Invoker
<
IndexSequence
<
bound_indices
.
.
.
>
StorageType
TypeList
<
Unwrappers
.
.
.
>
InvokeHelperType
R
(
UnboundForwardArgs
.
.
.
)
>
{
static
R
Run
(
BindStateBase
*
base
UnboundForwardArgs
.
.
.
unbound_args
)
{
StorageType
*
storage
=
static_cast
<
StorageType
*
>
(
base
)
;
return
InvokeHelperType
:
:
MakeItSo
(
storage
-
>
runnable_
Unwrappers
:
:
Unwrap
(
get
<
bound_indices
>
(
storage
-
>
bound_args_
)
)
.
.
.
CallbackForward
(
unbound_args
)
.
.
.
)
;
}
}
;
template
<
typename
Runnable
typename
RunType
typename
.
.
.
BoundArgs
>
struct
BindState
;
template
<
typename
Runnable
typename
R
typename
.
.
.
Args
typename
.
.
.
BoundArgs
>
struct
BindState
<
Runnable
R
(
Args
.
.
.
)
BoundArgs
.
.
.
>
final
:
public
BindStateBase
{
private
:
using
StorageType
=
BindState
<
Runnable
R
(
Args
.
.
.
)
BoundArgs
.
.
.
>
;
using
RunnableType
=
Runnable
;
using
IsWeakCall
=
IsWeakMethod
<
HasIsMethodTag
<
Runnable
>
:
:
value
BoundArgs
.
.
.
>
;
using
BoundIndices
=
MakeIndexSequence
<
sizeof
.
.
.
(
BoundArgs
)
>
;
using
Unwrappers
=
TypeList
<
UnwrapTraits
<
BoundArgs
>
.
.
.
>
;
using
UnboundForwardArgs
=
DropTypeListItem
<
sizeof
.
.
.
(
BoundArgs
)
TypeList
<
typename
CallbackParamTraits
<
Args
>
:
:
ForwardType
.
.
.
>
>
;
using
UnboundForwardRunType
=
MakeFunctionType
<
R
UnboundForwardArgs
>
;
using
InvokeHelperArgs
=
ConcatTypeLists
<
TypeList
<
typename
UnwrapTraits
<
BoundArgs
>
:
:
ForwardType
.
.
.
>
UnboundForwardArgs
>
;
using
InvokeHelperType
=
InvokeHelper
<
IsWeakCall
:
:
value
R
Runnable
InvokeHelperArgs
>
;
using
UnboundArgs
=
DropTypeListItem
<
sizeof
.
.
.
(
BoundArgs
)
TypeList
<
Args
.
.
.
>
>
;
public
:
using
InvokerType
=
Invoker
<
BoundIndices
StorageType
Unwrappers
InvokeHelperType
UnboundForwardRunType
>
;
using
UnboundRunType
=
MakeFunctionType
<
R
UnboundArgs
>
;
BindState
(
const
Runnable
&
runnable
const
BoundArgs
&
.
.
.
bound_args
)
:
BindStateBase
(
&
Destroy
)
runnable_
(
runnable
)
ref_
(
bound_args
.
.
.
)
bound_args_
(
bound_args
.
.
.
)
{
}
RunnableType
runnable_
;
MaybeScopedRefPtr
<
HasIsMethodTag
<
Runnable
>
:
:
value
BoundArgs
.
.
.
>
ref_
;
Tuple
<
BoundArgs
.
.
.
>
bound_args_
;
private
:
~
BindState
(
)
{
}
static
void
Destroy
(
BindStateBase
*
self
)
{
delete
static_cast
<
BindState
*
>
(
self
)
;
}
}
;
}
}
#
endif
