#
ifndef
BASE_BIND_HELPERS_H_
#
define
BASE_BIND_HELPERS_H_
#
include
<
stddef
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
callback
.
h
"
#
include
"
base
/
memory
/
weak_ptr
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
template
<
typename
T
>
struct
IsWeakReceiver
;
template
<
typename
>
struct
BindUnwrapTraits
;
namespace
internal
{
template
<
typename
Functor
typename
SFINAE
=
void
>
struct
FunctorTraits
;
template
<
typename
T
>
class
UnretainedWrapper
{
public
:
explicit
UnretainedWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
T
*
get
(
)
const
{
return
ptr_
;
}
private
:
T
*
ptr_
;
}
;
template
<
typename
T
>
class
ConstRefWrapper
{
public
:
explicit
ConstRefWrapper
(
const
T
&
o
)
:
ptr_
(
&
o
)
{
}
const
T
&
get
(
)
const
{
return
*
ptr_
;
}
private
:
const
T
*
ptr_
;
}
;
template
<
typename
T
>
class
RetainedRefWrapper
{
public
:
explicit
RetainedRefWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
explicit
RetainedRefWrapper
(
scoped_refptr
<
T
>
o
)
:
ptr_
(
std
:
:
move
(
o
)
)
{
}
T
*
get
(
)
const
{
return
ptr_
.
get
(
)
;
}
private
:
scoped_refptr
<
T
>
ptr_
;
}
;
template
<
typename
T
>
struct
IgnoreResultHelper
{
explicit
IgnoreResultHelper
(
T
functor
)
:
functor_
(
std
:
:
move
(
functor
)
)
{
}
explicit
operator
bool
(
)
const
{
return
!
!
functor_
;
}
T
functor_
;
}
;
template
<
typename
T
>
class
OwnedWrapper
{
public
:
explicit
OwnedWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
~
OwnedWrapper
(
)
{
delete
ptr_
;
}
T
*
get
(
)
const
{
return
ptr_
;
}
OwnedWrapper
(
OwnedWrapper
&
&
other
)
{
ptr_
=
other
.
ptr_
;
other
.
ptr_
=
NULL
;
}
private
:
mutable
T
*
ptr_
;
}
;
template
<
typename
T
>
class
PassedWrapper
{
public
:
explicit
PassedWrapper
(
T
&
&
scoper
)
:
is_valid_
(
true
)
scoper_
(
std
:
:
move
(
scoper
)
)
{
}
PassedWrapper
(
PassedWrapper
&
&
other
)
:
is_valid_
(
other
.
is_valid_
)
scoper_
(
std
:
:
move
(
other
.
scoper_
)
)
{
}
T
Take
(
)
const
{
CHECK
(
is_valid_
)
;
is_valid_
=
false
;
return
std
:
:
move
(
scoper_
)
;
}
private
:
mutable
bool
is_valid_
;
mutable
T
scoper_
;
}
;
template
<
typename
T
>
using
Unwrapper
=
BindUnwrapTraits
<
typename
std
:
:
decay
<
T
>
:
:
type
>
;
template
<
typename
T
>
auto
Unwrap
(
T
&
&
o
)
-
>
decltype
(
Unwrapper
<
T
>
:
:
Unwrap
(
std
:
:
forward
<
T
>
(
o
)
)
)
{
return
Unwrapper
<
T
>
:
:
Unwrap
(
std
:
:
forward
<
T
>
(
o
)
)
;
}
template
<
bool
is_method
typename
.
.
.
Args
>
struct
IsWeakMethod
:
std
:
:
false_type
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
struct
IsWeakMethod
<
true
T
Args
.
.
.
>
:
IsWeakReceiver
<
T
>
{
}
;
template
<
typename
.
.
.
Types
>
struct
TypeList
{
}
;
template
<
size_t
n
typename
List
>
struct
DropTypeListItemImpl
;
template
<
size_t
n
typename
T
typename
.
.
.
List
>
struct
DropTypeListItemImpl
<
n
TypeList
<
T
List
.
.
.
>
>
:
DropTypeListItemImpl
<
n
-
1
TypeList
<
List
.
.
.
>
>
{
}
;
template
<
typename
T
typename
.
.
.
List
>
struct
DropTypeListItemImpl
<
0
TypeList
<
T
List
.
.
.
>
>
{
using
Type
=
TypeList
<
T
List
.
.
.
>
;
}
;
template
<
>
struct
DropTypeListItemImpl
<
0
TypeList
<
>
>
{
using
Type
=
TypeList
<
>
;
}
;
template
<
size_t
n
typename
List
>
using
DropTypeListItem
=
typename
DropTypeListItemImpl
<
n
List
>
:
:
Type
;
template
<
size_t
n
typename
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
;
template
<
size_t
n
typename
T
typename
.
.
.
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
n
TypeList
<
T
List
.
.
.
>
Accum
.
.
.
>
:
TakeTypeListItemImpl
<
n
-
1
TypeList
<
List
.
.
.
>
Accum
.
.
.
T
>
{
}
;
template
<
typename
T
typename
.
.
.
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
0
TypeList
<
T
List
.
.
.
>
Accum
.
.
.
>
{
using
Type
=
TypeList
<
Accum
.
.
.
>
;
}
;
template
<
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
0
TypeList
<
>
Accum
.
.
.
>
{
using
Type
=
TypeList
<
Accum
.
.
.
>
;
}
;
template
<
size_t
n
typename
List
>
using
TakeTypeListItem
=
typename
TakeTypeListItemImpl
<
n
List
>
:
:
Type
;
template
<
typename
List1
typename
List2
>
struct
ConcatTypeListsImpl
;
template
<
typename
.
.
.
Types1
typename
.
.
.
Types2
>
struct
ConcatTypeListsImpl
<
TypeList
<
Types1
.
.
.
>
TypeList
<
Types2
.
.
.
>
>
{
using
Type
=
TypeList
<
Types1
.
.
.
Types2
.
.
.
>
;
}
;
template
<
typename
List1
typename
List2
>
using
ConcatTypeLists
=
typename
ConcatTypeListsImpl
<
List1
List2
>
:
:
Type
;
template
<
typename
R
typename
ArgList
>
struct
MakeFunctionTypeImpl
;
template
<
typename
R
typename
.
.
.
Args
>
struct
MakeFunctionTypeImpl
<
R
TypeList
<
Args
.
.
.
>
>
{
typedef
R
Type
(
Args
.
.
.
)
;
}
;
template
<
typename
R
typename
ArgList
>
using
MakeFunctionType
=
typename
MakeFunctionTypeImpl
<
R
ArgList
>
:
:
Type
;
template
<
typename
Signature
>
struct
ExtractArgsImpl
;
template
<
typename
R
typename
.
.
.
Args
>
struct
ExtractArgsImpl
<
R
(
Args
.
.
.
)
>
{
using
ReturnType
=
R
;
using
ArgsList
=
TypeList
<
Args
.
.
.
>
;
}
;
template
<
typename
Signature
>
using
ExtractArgs
=
typename
ExtractArgsImpl
<
Signature
>
:
:
ArgsList
;
template
<
typename
Signature
>
using
ExtractReturnType
=
typename
ExtractArgsImpl
<
Signature
>
:
:
ReturnType
;
}
template
<
typename
T
>
static
inline
internal
:
:
UnretainedWrapper
<
T
>
Unretained
(
T
*
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
RetainedRefWrapper
<
T
>
RetainedRef
(
T
*
o
)
{
return
internal
:
:
RetainedRefWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
RetainedRefWrapper
<
T
>
RetainedRef
(
scoped_refptr
<
T
>
o
)
{
return
internal
:
:
RetainedRefWrapper
<
T
>
(
std
:
:
move
(
o
)
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
ConstRefWrapper
<
T
>
ConstRef
(
const
T
&
o
)
{
return
internal
:
:
ConstRefWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
OwnedWrapper
<
T
>
Owned
(
T
*
o
)
{
return
internal
:
:
OwnedWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
!
std
:
:
is_lvalue_reference
<
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
static
inline
internal
:
:
PassedWrapper
<
T
>
Passed
(
T
&
&
scoper
)
{
return
internal
:
:
PassedWrapper
<
T
>
(
std
:
:
move
(
scoper
)
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
PassedWrapper
<
T
>
Passed
(
T
*
scoper
)
{
return
internal
:
:
PassedWrapper
<
T
>
(
std
:
:
move
(
*
scoper
)
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
IgnoreResultHelper
<
T
>
IgnoreResult
(
T
data
)
{
return
internal
:
:
IgnoreResultHelper
<
T
>
(
std
:
:
move
(
data
)
)
;
}
BASE_EXPORT
void
DoNothing
(
)
;
template
<
typename
T
>
void
DeletePointer
(
T
*
obj
)
{
delete
obj
;
}
template
<
typename
T
>
struct
IsWeakReceiver
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
IsWeakReceiver
<
internal
:
:
ConstRefWrapper
<
T
>
>
:
IsWeakReceiver
<
T
>
{
}
;
template
<
typename
T
>
struct
IsWeakReceiver
<
WeakPtr
<
T
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
>
struct
BindUnwrapTraits
{
template
<
typename
T
>
static
T
&
&
Unwrap
(
T
&
&
o
)
{
return
std
:
:
forward
<
T
>
(
o
)
;
}
}
;
template
<
typename
T
>
struct
BindUnwrapTraits
<
internal
:
:
UnretainedWrapper
<
T
>
>
{
static
T
*
Unwrap
(
const
internal
:
:
UnretainedWrapper
<
T
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
BindUnwrapTraits
<
internal
:
:
ConstRefWrapper
<
T
>
>
{
static
const
T
&
Unwrap
(
const
internal
:
:
ConstRefWrapper
<
T
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
BindUnwrapTraits
<
internal
:
:
RetainedRefWrapper
<
T
>
>
{
static
T
*
Unwrap
(
const
internal
:
:
RetainedRefWrapper
<
T
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
BindUnwrapTraits
<
internal
:
:
OwnedWrapper
<
T
>
>
{
static
T
*
Unwrap
(
const
internal
:
:
OwnedWrapper
<
T
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
BindUnwrapTraits
<
internal
:
:
PassedWrapper
<
T
>
>
{
static
T
Unwrap
(
const
internal
:
:
PassedWrapper
<
T
>
&
o
)
{
return
o
.
Take
(
)
;
}
}
;
template
<
typename
Functor
typename
BoundArgsTuple
typename
SFINAE
=
void
>
struct
CallbackCancellationTraits
{
static
constexpr
bool
is_cancellable
=
false
;
}
;
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
struct
CallbackCancellationTraits
<
Functor
std
:
:
tuple
<
BoundArgs
.
.
.
>
typename
std
:
:
enable_if
<
internal
:
:
IsWeakMethod
<
internal
:
:
FunctorTraits
<
Functor
>
:
:
is_method
BoundArgs
.
.
.
>
:
:
value
>
:
:
type
>
{
static
constexpr
bool
is_cancellable
=
true
;
template
<
typename
Receiver
typename
.
.
.
Args
>
static
bool
IsCancelled
(
const
Functor
&
const
Receiver
&
receiver
const
Args
&
.
.
.
)
{
return
!
receiver
;
}
}
;
template
<
typename
Signature
typename
.
.
.
BoundArgs
>
struct
CallbackCancellationTraits
<
OnceCallback
<
Signature
>
std
:
:
tuple
<
BoundArgs
.
.
.
>
>
{
static
constexpr
bool
is_cancellable
=
true
;
template
<
typename
Functor
>
static
bool
IsCancelled
(
const
Functor
&
functor
const
BoundArgs
&
.
.
.
)
{
return
functor
.
IsCancelled
(
)
;
}
}
;
template
<
typename
Signature
typename
.
.
.
BoundArgs
>
struct
CallbackCancellationTraits
<
RepeatingCallback
<
Signature
>
std
:
:
tuple
<
BoundArgs
.
.
.
>
>
{
static
constexpr
bool
is_cancellable
=
true
;
template
<
typename
Functor
>
static
bool
IsCancelled
(
const
Functor
&
functor
const
BoundArgs
&
.
.
.
)
{
return
functor
.
IsCancelled
(
)
;
}
}
;
}
#
endif
