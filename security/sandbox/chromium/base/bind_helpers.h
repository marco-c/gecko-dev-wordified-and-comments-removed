#
ifndef
BASE_BIND_HELPERS_H_
#
define
BASE_BIND_HELPERS_H_
#
include
<
stddef
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
callback
.
h
"
#
include
"
base
/
memory
/
weak_ptr
.
h
"
#
include
"
base
/
template_util
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
T
>
class
SupportsAddRefAndRelease
{
using
Yes
=
char
[
1
]
;
using
No
=
char
[
2
]
;
struct
BaseMixin
{
void
AddRef
(
)
;
}
;
#
if
defined
(
OS_WIN
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4624
)
#
endif
struct
Base
:
public
T
public
BaseMixin
{
}
;
#
if
defined
(
OS_WIN
)
#
pragma
warning
(
pop
)
#
endif
template
<
void
(
BaseMixin
:
:
*
)
(
)
>
struct
Helper
{
}
;
template
<
typename
C
>
static
No
&
Check
(
Helper
<
&
C
:
:
AddRef
>
*
)
;
template
<
typename
>
static
Yes
&
Check
(
.
.
.
)
;
public
:
enum
{
value
=
sizeof
(
Check
<
Base
>
(
0
)
)
=
=
sizeof
(
Yes
)
}
;
}
;
template
<
bool
IsClasstype
typename
T
>
struct
UnsafeBindtoRefCountedArgHelper
:
false_type
{
}
;
template
<
typename
T
>
struct
UnsafeBindtoRefCountedArgHelper
<
true
T
>
:
integral_constant
<
bool
SupportsAddRefAndRelease
<
T
>
:
:
value
>
{
}
;
template
<
typename
T
>
struct
UnsafeBindtoRefCountedArg
:
false_type
{
}
;
template
<
typename
T
>
struct
UnsafeBindtoRefCountedArg
<
T
*
>
:
UnsafeBindtoRefCountedArgHelper
<
is_class
<
T
>
:
:
value
T
>
{
}
;
template
<
typename
T
>
class
HasIsMethodTag
{
using
Yes
=
char
[
1
]
;
using
No
=
char
[
2
]
;
template
<
typename
U
>
static
Yes
&
Check
(
typename
U
:
:
IsMethod
*
)
;
template
<
typename
U
>
static
No
&
Check
(
.
.
.
)
;
public
:
enum
{
value
=
sizeof
(
Check
<
T
>
(
0
)
)
=
=
sizeof
(
Yes
)
}
;
}
;
template
<
typename
T
>
class
UnretainedWrapper
{
public
:
explicit
UnretainedWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
T
*
get
(
)
const
{
return
ptr_
;
}
private
:
T
*
ptr_
;
}
;
template
<
typename
T
>
class
ConstRefWrapper
{
public
:
explicit
ConstRefWrapper
(
const
T
&
o
)
:
ptr_
(
&
o
)
{
}
const
T
&
get
(
)
const
{
return
*
ptr_
;
}
private
:
const
T
*
ptr_
;
}
;
template
<
typename
T
>
struct
IgnoreResultHelper
{
explicit
IgnoreResultHelper
(
T
functor
)
:
functor_
(
functor
)
{
}
T
functor_
;
}
;
template
<
typename
T
>
struct
IgnoreResultHelper
<
Callback
<
T
>
>
{
explicit
IgnoreResultHelper
(
const
Callback
<
T
>
&
functor
)
:
functor_
(
functor
)
{
}
const
Callback
<
T
>
&
functor_
;
}
;
template
<
typename
T
>
class
OwnedWrapper
{
public
:
explicit
OwnedWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
~
OwnedWrapper
(
)
{
delete
ptr_
;
}
T
*
get
(
)
const
{
return
ptr_
;
}
OwnedWrapper
(
const
OwnedWrapper
&
other
)
{
ptr_
=
other
.
ptr_
;
other
.
ptr_
=
NULL
;
}
private
:
mutable
T
*
ptr_
;
}
;
template
<
typename
T
>
class
PassedWrapper
{
public
:
explicit
PassedWrapper
(
T
&
&
scoper
)
:
is_valid_
(
true
)
scoper_
(
std
:
:
move
(
scoper
)
)
{
}
PassedWrapper
(
const
PassedWrapper
&
other
)
:
is_valid_
(
other
.
is_valid_
)
scoper_
(
std
:
:
move
(
other
.
scoper_
)
)
{
}
T
Pass
(
)
const
{
CHECK
(
is_valid_
)
;
is_valid_
=
false
;
return
std
:
:
move
(
scoper_
)
;
}
private
:
mutable
bool
is_valid_
;
mutable
T
scoper_
;
}
;
template
<
typename
T
>
struct
UnwrapTraits
{
using
ForwardType
=
const
T
&
;
static
ForwardType
Unwrap
(
const
T
&
o
)
{
return
o
;
}
}
;
template
<
typename
T
>
struct
UnwrapTraits
<
UnretainedWrapper
<
T
>
>
{
using
ForwardType
=
T
*
;
static
ForwardType
Unwrap
(
UnretainedWrapper
<
T
>
unretained
)
{
return
unretained
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
UnwrapTraits
<
ConstRefWrapper
<
T
>
>
{
using
ForwardType
=
const
T
&
;
static
ForwardType
Unwrap
(
ConstRefWrapper
<
T
>
const_ref
)
{
return
const_ref
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
UnwrapTraits
<
scoped_refptr
<
T
>
>
{
using
ForwardType
=
T
*
;
static
ForwardType
Unwrap
(
const
scoped_refptr
<
T
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
UnwrapTraits
<
WeakPtr
<
T
>
>
{
using
ForwardType
=
const
WeakPtr
<
T
>
&
;
static
ForwardType
Unwrap
(
const
WeakPtr
<
T
>
&
o
)
{
return
o
;
}
}
;
template
<
typename
T
>
struct
UnwrapTraits
<
OwnedWrapper
<
T
>
>
{
using
ForwardType
=
T
*
;
static
ForwardType
Unwrap
(
const
OwnedWrapper
<
T
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
UnwrapTraits
<
PassedWrapper
<
T
>
>
{
using
ForwardType
=
T
;
static
T
Unwrap
(
PassedWrapper
<
T
>
&
o
)
{
return
o
.
Pass
(
)
;
}
}
;
template
<
bool
is_method
typename
.
.
.
T
>
struct
MaybeScopedRefPtr
;
template
<
bool
is_method
>
struct
MaybeScopedRefPtr
<
is_method
>
{
MaybeScopedRefPtr
(
)
{
}
}
;
template
<
typename
T
typename
.
.
.
Rest
>
struct
MaybeScopedRefPtr
<
false
T
Rest
.
.
.
>
{
MaybeScopedRefPtr
(
const
T
&
const
Rest
&
.
.
.
)
{
}
}
;
template
<
typename
T
size_t
n
typename
.
.
.
Rest
>
struct
MaybeScopedRefPtr
<
false
T
[
n
]
Rest
.
.
.
>
{
MaybeScopedRefPtr
(
const
T
*
const
Rest
&
.
.
.
)
{
}
}
;
template
<
typename
T
typename
.
.
.
Rest
>
struct
MaybeScopedRefPtr
<
true
T
Rest
.
.
.
>
{
MaybeScopedRefPtr
(
const
T
&
o
const
Rest
&
.
.
.
)
{
}
}
;
template
<
typename
T
typename
.
.
.
Rest
>
struct
MaybeScopedRefPtr
<
true
T
*
Rest
.
.
.
>
{
MaybeScopedRefPtr
(
T
*
o
const
Rest
&
.
.
.
)
:
ref_
(
o
)
{
}
scoped_refptr
<
T
>
ref_
;
}
;
template
<
typename
T
typename
.
.
.
Rest
>
struct
MaybeScopedRefPtr
<
true
scoped_refptr
<
T
>
Rest
.
.
.
>
{
MaybeScopedRefPtr
(
const
scoped_refptr
<
T
>
&
const
Rest
&
.
.
.
)
{
}
}
;
template
<
typename
T
typename
.
.
.
Rest
>
struct
MaybeScopedRefPtr
<
true
const
T
*
Rest
.
.
.
>
{
MaybeScopedRefPtr
(
const
T
*
o
const
Rest
&
.
.
.
)
:
ref_
(
o
)
{
}
scoped_refptr
<
const
T
>
ref_
;
}
;
template
<
bool
IsMethod
typename
.
.
.
Args
>
struct
IsWeakMethod
:
public
false_type
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
struct
IsWeakMethod
<
true
WeakPtr
<
T
>
Args
.
.
.
>
:
public
true_type
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
struct
IsWeakMethod
<
true
ConstRefWrapper
<
WeakPtr
<
T
>
>
Args
.
.
.
>
:
public
true_type
{
}
;
template
<
typename
.
.
.
Types
>
struct
TypeList
{
}
;
template
<
size_t
n
typename
List
>
struct
DropTypeListItemImpl
;
template
<
size_t
n
typename
T
typename
.
.
.
List
>
struct
DropTypeListItemImpl
<
n
TypeList
<
T
List
.
.
.
>
>
:
DropTypeListItemImpl
<
n
-
1
TypeList
<
List
.
.
.
>
>
{
}
;
template
<
typename
T
typename
.
.
.
List
>
struct
DropTypeListItemImpl
<
0
TypeList
<
T
List
.
.
.
>
>
{
using
Type
=
TypeList
<
T
List
.
.
.
>
;
}
;
template
<
>
struct
DropTypeListItemImpl
<
0
TypeList
<
>
>
{
using
Type
=
TypeList
<
>
;
}
;
template
<
size_t
n
typename
List
>
using
DropTypeListItem
=
typename
DropTypeListItemImpl
<
n
List
>
:
:
Type
;
template
<
size_t
n
typename
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
;
template
<
size_t
n
typename
T
typename
.
.
.
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
n
TypeList
<
T
List
.
.
.
>
Accum
.
.
.
>
:
TakeTypeListItemImpl
<
n
-
1
TypeList
<
List
.
.
.
>
Accum
.
.
.
T
>
{
}
;
template
<
typename
T
typename
.
.
.
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
0
TypeList
<
T
List
.
.
.
>
Accum
.
.
.
>
{
using
Type
=
TypeList
<
Accum
.
.
.
>
;
}
;
template
<
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
0
TypeList
<
>
Accum
.
.
.
>
{
using
Type
=
TypeList
<
Accum
.
.
.
>
;
}
;
template
<
size_t
n
typename
List
>
using
TakeTypeListItem
=
typename
TakeTypeListItemImpl
<
n
List
>
:
:
Type
;
template
<
typename
List1
typename
List2
>
struct
ConcatTypeListsImpl
;
template
<
typename
.
.
.
Types1
typename
.
.
.
Types2
>
struct
ConcatTypeListsImpl
<
TypeList
<
Types1
.
.
.
>
TypeList
<
Types2
.
.
.
>
>
{
using
Type
=
TypeList
<
Types1
.
.
.
Types2
.
.
.
>
;
}
;
template
<
typename
List1
typename
List2
>
using
ConcatTypeLists
=
typename
ConcatTypeListsImpl
<
List1
List2
>
:
:
Type
;
template
<
typename
R
typename
ArgList
>
struct
MakeFunctionTypeImpl
;
template
<
typename
R
typename
.
.
.
Args
>
struct
MakeFunctionTypeImpl
<
R
TypeList
<
Args
.
.
.
>
>
{
typedef
R
Type
(
Args
.
.
.
)
;
}
;
template
<
typename
R
typename
ArgList
>
using
MakeFunctionType
=
typename
MakeFunctionTypeImpl
<
R
ArgList
>
:
:
Type
;
template
<
typename
Signature
>
struct
ExtractArgsImpl
;
template
<
typename
R
typename
.
.
.
Args
>
struct
ExtractArgsImpl
<
R
(
Args
.
.
.
)
>
{
using
Type
=
TypeList
<
Args
.
.
.
>
;
}
;
template
<
typename
Signature
>
using
ExtractArgs
=
typename
ExtractArgsImpl
<
Signature
>
:
:
Type
;
}
template
<
typename
T
>
static
inline
internal
:
:
UnretainedWrapper
<
T
>
Unretained
(
T
*
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
ConstRefWrapper
<
T
>
ConstRef
(
const
T
&
o
)
{
return
internal
:
:
ConstRefWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
OwnedWrapper
<
T
>
Owned
(
T
*
o
)
{
return
internal
:
:
OwnedWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
internal
:
:
IsMoveOnlyType
<
T
>
:
:
value
&
&
!
std
:
:
is_lvalue_reference
<
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
static
inline
internal
:
:
PassedWrapper
<
T
>
Passed
(
T
&
&
scoper
)
{
return
internal
:
:
PassedWrapper
<
T
>
(
std
:
:
move
(
scoper
)
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
internal
:
:
IsMoveOnlyType
<
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
static
inline
internal
:
:
PassedWrapper
<
T
>
Passed
(
T
*
scoper
)
{
return
internal
:
:
PassedWrapper
<
T
>
(
std
:
:
move
(
*
scoper
)
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
IgnoreResultHelper
<
T
>
IgnoreResult
(
T
data
)
{
return
internal
:
:
IgnoreResultHelper
<
T
>
(
data
)
;
}
template
<
typename
T
>
static
inline
internal
:
:
IgnoreResultHelper
<
Callback
<
T
>
>
IgnoreResult
(
const
Callback
<
T
>
&
data
)
{
return
internal
:
:
IgnoreResultHelper
<
Callback
<
T
>
>
(
data
)
;
}
BASE_EXPORT
void
DoNothing
(
)
;
template
<
typename
T
>
void
DeletePointer
(
T
*
obj
)
{
delete
obj
;
}
}
#
endif
