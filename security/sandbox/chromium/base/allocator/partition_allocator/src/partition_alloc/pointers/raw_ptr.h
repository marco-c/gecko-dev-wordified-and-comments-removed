#
ifndef
BASE_ALLOCATOR_PARTITION_ALLOCATOR_SRC_PARTITION_ALLOC_POINTERS_RAW_PTR_H_
#
define
BASE_ALLOCATOR_PARTITION_ALLOCATOR_SRC_PARTITION_ALLOC_POINTERS_RAW_PTR_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
cstddef
>
#
include
<
functional
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
flags
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
compiler_specific
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
component_export
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
cxx20_is_constant_evaluated
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
debug
/
debugging_buildflags
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_buildflags
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_config
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_forward
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
pointers
/
raw_ptr_exclusion
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
raw_ptr_buildflags
.
h
"
#
include
"
build
/
build_config
.
h
"
#
include
"
build
/
buildflag
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
win
/
win_handle_types
.
h
"
#
endif
#
if
BUILDFLAG
(
USE_PARTITION_ALLOC
)
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
check
.
h
"
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
|
|
\
BUILDFLAG
(
USE_ASAN_BACKUP_REF_PTR
)
#
define
PA_RAW_PTR_CHECK
(
condition
)
PA_BASE_CHECK
(
condition
)
#
else
#
define
PA_RAW_PTR_CHECK
(
condition
)
PA_BASE_DCHECK
(
condition
)
#
endif
#
else
#
define
PA_RAW_PTR_CHECK
(
condition
)
#
endif
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
pointers
/
raw_ptr_backup_ref_impl
.
h
"
#
elif
BUILDFLAG
(
USE_ASAN_UNOWNED_PTR
)
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
pointers
/
raw_ptr_asan_unowned_impl
.
h
"
#
elif
BUILDFLAG
(
USE_HOOKABLE_RAW_PTR
)
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
pointers
/
raw_ptr_hookable_impl
.
h
"
#
else
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
pointers
/
raw_ptr_noop_impl
.
h
"
#
endif
namespace
cc
{
class
Scheduler
;
}
namespace
base
:
:
internal
{
class
DelayTimerBase
;
}
namespace
content
:
:
responsiveness
{
class
Calculator
;
}
namespace
partition_alloc
:
:
internal
{
enum
class
RawPtrTraits
:
unsigned
{
kEmpty
=
0
kMayDangle
=
(
1
<
<
0
)
kDisableHooks
=
(
1
<
<
2
)
kAllowPtrArithmetic
=
(
1
<
<
3
)
kExperimentalAsh
=
(
1
<
<
4
)
kAllowUninitialized
=
(
1
<
<
5
)
kUseCountingImplForTest
=
(
1
<
<
10
)
kDummyForTest
=
(
1
<
<
11
)
kAllMask
=
kMayDangle
|
kDisableHooks
|
kAllowPtrArithmetic
|
kExperimentalAsh
|
kAllowUninitialized
|
kUseCountingImplForTest
|
kDummyForTest
}
;
template
<
>
constexpr
inline
RawPtrTraits
kAllFlags
<
RawPtrTraits
>
=
RawPtrTraits
:
:
kAllMask
;
PA_DEFINE_OPERATORS_FOR_FLAGS
(
RawPtrTraits
)
;
}
namespace
base
{
using
partition_alloc
:
:
internal
:
:
RawPtrTraits
;
namespace
raw_ptr_traits
{
template
<
typename
T
typename
SFINAE
=
void
>
struct
IsSupportedType
{
static
constexpr
bool
value
=
true
;
}
;
template
<
typename
T
>
struct
IsSupportedType
<
T
std
:
:
enable_if_t
<
std
:
:
is_function_v
<
T
>
>
>
{
static
constexpr
bool
value
=
false
;
}
;
template
<
>
struct
IsSupportedType
<
cc
:
:
Scheduler
>
{
static
constexpr
bool
value
=
false
;
}
;
template
<
>
struct
IsSupportedType
<
base
:
:
internal
:
:
DelayTimerBase
>
{
static
constexpr
bool
value
=
false
;
}
;
template
<
>
struct
IsSupportedType
<
content
:
:
responsiveness
:
:
Calculator
>
{
static
constexpr
bool
value
=
false
;
}
;
#
if
__OBJC__
template
<
typename
T
>
struct
IsSupportedType
<
T
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
T
*
id
>
>
>
{
static
constexpr
bool
value
=
false
;
}
;
#
endif
#
if
BUILDFLAG
(
IS_WIN
)
#
define
PA_WINDOWS_HANDLE_TYPE
(
name
)
\
template
<
>
\
struct
IsSupportedType
<
name
#
#
__
void
>
{
\
static
constexpr
bool
value
=
false
;
\
}
;
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
win
/
win_handle_types_list
.
inc
"
#
undef
PA_WINDOWS_HANDLE_TYPE
#
endif
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
template
<
RawPtrTraits
Traits
>
using
UnderlyingImplForTraits
=
internal
:
:
RawPtrBackupRefImpl
<
ContainsFlags
(
Traits
RawPtrTraits
:
:
kMayDangle
)
ContainsFlags
(
Traits
RawPtrTraits
:
:
kExperimentalAsh
)
>
;
#
elif
BUILDFLAG
(
USE_ASAN_UNOWNED_PTR
)
template
<
RawPtrTraits
Traits
>
using
UnderlyingImplForTraits
=
internal
:
:
RawPtrAsanUnownedImpl
<
ContainsFlags
(
Traits
RawPtrTraits
:
:
kAllowPtrArithmetic
)
ContainsFlags
(
Traits
RawPtrTraits
:
:
kMayDangle
)
>
;
#
elif
BUILDFLAG
(
USE_HOOKABLE_RAW_PTR
)
template
<
RawPtrTraits
Traits
>
using
UnderlyingImplForTraits
=
internal
:
:
RawPtrHookableImpl
<
!
ContainsFlags
(
Traits
RawPtrTraits
:
:
kDisableHooks
)
>
;
#
else
template
<
RawPtrTraits
Traits
>
using
UnderlyingImplForTraits
=
internal
:
:
RawPtrNoOpImpl
;
#
endif
constexpr
bool
IsPtrArithmeticAllowed
(
RawPtrTraits
Traits
)
{
#
if
BUILDFLAG
(
ENABLE_POINTER_ARITHMETIC_TRAIT_CHECK
)
return
ContainsFlags
(
Traits
RawPtrTraits
:
:
kAllowPtrArithmetic
)
;
#
else
return
true
;
#
endif
}
}
namespace
test
{
struct
RawPtrCountingImplForTest
;
}
namespace
raw_ptr_traits
{
template
<
RawPtrTraits
Traits
>
using
ImplForTraits
=
std
:
:
conditional_t
<
ContainsFlags
(
Traits
RawPtrTraits
:
:
kUseCountingImplForTest
)
test
:
:
RawPtrCountingImplForTest
UnderlyingImplForTraits
<
Traits
>
>
;
}
template
<
typename
T
RawPtrTraits
Traits
=
RawPtrTraits
:
:
kEmpty
>
class
PA_TRIVIAL_ABI
PA_GSL_POINTER
raw_ptr
{
public
:
using
Impl
=
typename
raw_ptr_traits
:
:
ImplForTraits
<
Traits
>
;
using
element_type
=
T
;
using
DanglingType
=
raw_ptr
<
T
Traits
|
RawPtrTraits
:
:
kMayDangle
>
;
#
if
!
BUILDFLAG
(
USE_PARTITION_ALLOC
)
static_assert
(
std
:
:
is_same_v
<
Impl
internal
:
:
RawPtrNoOpImpl
>
)
;
#
endif
static_assert
(
AreValidFlags
(
Traits
)
"
Unknown
raw_ptr
trait
(
s
)
"
)
;
static_assert
(
raw_ptr_traits
:
:
IsSupportedType
<
T
>
:
:
value
"
raw_ptr
<
T
>
doesn
'
t
work
with
this
kind
of
pointee
type
T
"
)
;
static
constexpr
bool
kZeroOnConstruct
=
Impl
:
:
kMustZeroOnConstruct
|
|
(
BUILDFLAG
(
RAW_PTR_ZERO_ON_CONSTRUCT
)
&
&
!
ContainsFlags
(
Traits
RawPtrTraits
:
:
kAllowUninitialized
)
)
;
static
constexpr
bool
kZeroOnMove
=
Impl
:
:
kMustZeroOnMove
|
|
BUILDFLAG
(
RAW_PTR_ZERO_ON_MOVE
)
;
static
constexpr
bool
kZeroOnDestruct
=
Impl
:
:
kMustZeroOnDestruct
|
|
BUILDFLAG
(
RAW_PTR_ZERO_ON_DESTRUCT
)
;
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
|
|
\
BUILDFLAG
(
USE_ASAN_UNOWNED_PTR
)
|
|
BUILDFLAG
(
USE_HOOKABLE_RAW_PTR
)
|
|
\
BUILDFLAG
(
RAW_PTR_ZERO_ON_CONSTRUCT
)
PA_ALWAYS_INLINE
constexpr
raw_ptr
(
)
noexcept
{
if
constexpr
(
kZeroOnConstruct
)
{
wrapped_ptr_
=
nullptr
;
}
}
#
else
PA_ALWAYS_INLINE
constexpr
raw_ptr
(
)
noexcept
=
default
;
static_assert
(
!
kZeroOnConstruct
)
;
#
endif
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
|
|
\
BUILDFLAG
(
USE_ASAN_UNOWNED_PTR
)
|
|
BUILDFLAG
(
USE_HOOKABLE_RAW_PTR
)
PA_ALWAYS_INLINE
constexpr
raw_ptr
(
const
raw_ptr
&
p
)
noexcept
:
wrapped_ptr_
(
Impl
:
:
Duplicate
(
p
.
wrapped_ptr_
)
)
{
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
=
(
const
raw_ptr
&
p
)
noexcept
{
T
*
new_ptr
=
Impl
:
:
Duplicate
(
p
.
wrapped_ptr_
)
;
Impl
:
:
ReleaseWrappedPtr
(
wrapped_ptr_
)
;
wrapped_ptr_
=
new_ptr
;
return
*
this
;
}
#
else
PA_ALWAYS_INLINE
raw_ptr
(
const
raw_ptr
&
)
noexcept
=
default
;
PA_ALWAYS_INLINE
raw_ptr
&
operator
=
(
const
raw_ptr
&
)
noexcept
=
default
;
#
endif
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
|
|
\
BUILDFLAG
(
USE_ASAN_UNOWNED_PTR
)
|
|
BUILDFLAG
(
USE_HOOKABLE_RAW_PTR
)
|
|
\
BUILDFLAG
(
RAW_PTR_ZERO_ON_MOVE
)
PA_ALWAYS_INLINE
constexpr
raw_ptr
(
raw_ptr
&
&
p
)
noexcept
{
wrapped_ptr_
=
p
.
wrapped_ptr_
;
if
constexpr
(
kZeroOnMove
)
{
p
.
wrapped_ptr_
=
nullptr
;
}
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
=
(
raw_ptr
&
&
p
)
noexcept
{
if
(
PA_LIKELY
(
this
!
=
&
p
)
)
{
Impl
:
:
ReleaseWrappedPtr
(
wrapped_ptr_
)
;
wrapped_ptr_
=
p
.
wrapped_ptr_
;
if
constexpr
(
kZeroOnMove
)
{
p
.
wrapped_ptr_
=
nullptr
;
}
}
return
*
this
;
}
#
else
PA_ALWAYS_INLINE
raw_ptr
(
raw_ptr
&
&
)
noexcept
=
default
;
PA_ALWAYS_INLINE
raw_ptr
&
operator
=
(
raw_ptr
&
&
)
noexcept
=
default
;
static_assert
(
!
kZeroOnMove
)
;
#
endif
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
|
|
\
BUILDFLAG
(
USE_ASAN_UNOWNED_PTR
)
|
|
BUILDFLAG
(
USE_HOOKABLE_RAW_PTR
)
|
|
\
BUILDFLAG
(
RAW_PTR_ZERO_ON_DESTRUCT
)
PA_ALWAYS_INLINE
PA_CONSTEXPR_DTOR
~
raw_ptr
(
)
noexcept
{
Impl
:
:
ReleaseWrappedPtr
(
wrapped_ptr_
)
;
if
constexpr
(
kZeroOnDestruct
)
{
wrapped_ptr_
=
nullptr
;
}
}
#
else
PA_ALWAYS_INLINE
~
raw_ptr
(
)
noexcept
=
default
;
static_assert
(
!
kZeroOnDestruct
)
;
#
endif
template
<
RawPtrTraits
PassedTraits
typename
Unused
=
std
:
:
enable_if_t
<
Traits
!
=
PassedTraits
>
>
PA_ALWAYS_INLINE
constexpr
explicit
raw_ptr
(
const
raw_ptr
<
T
PassedTraits
>
&
p
)
noexcept
:
wrapped_ptr_
(
Impl
:
:
WrapRawPtrForDuplication
(
raw_ptr_traits
:
:
ImplForTraits
<
PassedTraits
>
:
:
UnsafelyUnwrapPtrForDuplication
(
p
.
wrapped_ptr_
)
)
)
{
static_assert
(
Traits
=
=
(
PassedTraits
|
RawPtrTraits
:
:
kMayDangle
)
)
;
}
template
<
RawPtrTraits
PassedTraits
typename
Unused
=
std
:
:
enable_if_t
<
Traits
!
=
PassedTraits
>
>
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
=
(
const
raw_ptr
<
T
PassedTraits
>
&
p
)
noexcept
{
static_assert
(
Traits
=
=
(
PassedTraits
|
RawPtrTraits
:
:
kMayDangle
)
)
;
Impl
:
:
ReleaseWrappedPtr
(
wrapped_ptr_
)
;
wrapped_ptr_
=
Impl
:
:
WrapRawPtrForDuplication
(
raw_ptr_traits
:
:
ImplForTraits
<
PassedTraits
>
:
:
UnsafelyUnwrapPtrForDuplication
(
p
.
wrapped_ptr_
)
)
;
return
*
this
;
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
(
std
:
:
nullptr_t
)
noexcept
:
wrapped_ptr_
(
nullptr
)
{
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
(
T
*
p
)
noexcept
:
wrapped_ptr_
(
Impl
:
:
WrapRawPtr
(
p
)
)
{
}
template
<
typename
U
typename
Unused
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
&
&
!
std
:
:
is_void_v
<
typename
std
:
:
remove_cv
<
T
>
:
:
type
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ptr
(
const
raw_ptr
<
U
Traits
>
&
ptr
)
noexcept
:
wrapped_ptr_
(
Impl
:
:
Duplicate
(
Impl
:
:
template
Upcast
<
T
U
>
(
ptr
.
wrapped_ptr_
)
)
)
{
}
template
<
typename
U
typename
Unused
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
&
&
!
std
:
:
is_void_v
<
typename
std
:
:
remove_cv
<
T
>
:
:
type
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ptr
(
raw_ptr
<
U
Traits
>
&
&
ptr
)
noexcept
:
wrapped_ptr_
(
Impl
:
:
template
Upcast
<
T
U
>
(
ptr
.
wrapped_ptr_
)
)
{
if
constexpr
(
kZeroOnMove
)
{
ptr
.
wrapped_ptr_
=
nullptr
;
}
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
=
(
std
:
:
nullptr_t
)
noexcept
{
Impl
:
:
ReleaseWrappedPtr
(
wrapped_ptr_
)
;
wrapped_ptr_
=
nullptr
;
return
*
this
;
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
=
(
T
*
p
)
noexcept
{
Impl
:
:
ReleaseWrappedPtr
(
wrapped_ptr_
)
;
wrapped_ptr_
=
Impl
:
:
WrapRawPtr
(
p
)
;
return
*
this
;
}
template
<
typename
U
typename
Unused
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
&
&
!
std
:
:
is_void_v
<
typename
std
:
:
remove_cv
<
T
>
:
:
type
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
=
(
const
raw_ptr
<
U
Traits
>
&
ptr
)
noexcept
{
#
if
BUILDFLAG
(
PA_DCHECK_IS_ON
)
|
|
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SLOW_CHECKS
)
if
constexpr
(
std
:
:
is_same_v
<
raw_ptr
std
:
:
decay_t
<
decltype
(
ptr
)
>
>
)
{
PA_RAW_PTR_CHECK
(
this
!
=
&
ptr
)
;
}
#
endif
Impl
:
:
ReleaseWrappedPtr
(
wrapped_ptr_
)
;
wrapped_ptr_
=
Impl
:
:
Duplicate
(
Impl
:
:
template
Upcast
<
T
U
>
(
ptr
.
wrapped_ptr_
)
)
;
return
*
this
;
}
template
<
typename
U
typename
Unused
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
&
&
!
std
:
:
is_void_v
<
typename
std
:
:
remove_cv
<
T
>
:
:
type
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
=
(
raw_ptr
<
U
Traits
>
&
&
ptr
)
noexcept
{
#
if
BUILDFLAG
(
PA_DCHECK_IS_ON
)
|
|
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SLOW_CHECKS
)
if
constexpr
(
std
:
:
is_same_v
<
raw_ptr
std
:
:
decay_t
<
decltype
(
ptr
)
>
>
)
{
PA_RAW_PTR_CHECK
(
this
!
=
&
ptr
)
;
}
#
endif
Impl
:
:
ReleaseWrappedPtr
(
wrapped_ptr_
)
;
wrapped_ptr_
=
Impl
:
:
template
Upcast
<
T
U
>
(
ptr
.
wrapped_ptr_
)
;
if
constexpr
(
kZeroOnMove
)
{
ptr
.
wrapped_ptr_
=
nullptr
;
}
return
*
this
;
}
PA_ALWAYS_INLINE
constexpr
T
*
get
(
)
const
{
return
GetForExtraction
(
)
;
}
class
EphemeralRawAddr
{
public
:
EphemeralRawAddr
(
const
EphemeralRawAddr
&
)
=
delete
;
EphemeralRawAddr
&
operator
=
(
const
EphemeralRawAddr
&
)
=
delete
;
void
*
operator
new
(
size_t
)
=
delete
;
void
*
operator
new
(
size_t
void
*
)
=
delete
;
PA_ALWAYS_INLINE
PA_CONSTEXPR_DTOR
~
EphemeralRawAddr
(
)
{
original
=
copy
;
}
PA_ALWAYS_INLINE
constexpr
T
*
*
operator
&
(
)
&
&
{
return
&
copy
;
}
PA_ALWAYS_INLINE
constexpr
operator
T
*
&
(
)
&
&
{
return
copy
;
}
private
:
friend
class
raw_ptr
;
PA_ALWAYS_INLINE
constexpr
explicit
EphemeralRawAddr
(
raw_ptr
&
ptr
)
:
copy
(
ptr
.
get
(
)
)
original
(
ptr
)
{
}
T
*
copy
;
raw_ptr
&
original
;
}
;
PA_ALWAYS_INLINE
PA_CONSTEXPR_DTOR
EphemeralRawAddr
AsEphemeralRawAddr
(
)
&
{
return
EphemeralRawAddr
(
*
this
)
;
}
PA_ALWAYS_INLINE
constexpr
explicit
operator
bool
(
)
const
{
return
!
!
wrapped_ptr_
;
}
template
<
typename
U
=
T
typename
Unused
=
std
:
:
enable_if_t
<
!
std
:
:
is_void_v
<
typename
std
:
:
remove_cv
<
U
>
:
:
type
>
>
>
PA_ALWAYS_INLINE
constexpr
U
&
operator
*
(
)
const
{
return
*
GetForDereference
(
)
;
}
PA_ALWAYS_INLINE
constexpr
T
*
operator
-
>
(
)
const
{
return
GetForDereference
(
)
;
}
PA_ALWAYS_INLINE
constexpr
operator
T
*
(
)
const
{
return
GetForExtraction
(
)
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
constexpr
explicit
operator
U
*
(
)
const
{
return
static_cast
<
U
*
>
(
GetForExtraction
(
)
)
;
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
+
+
(
)
{
static_assert
(
raw_ptr_traits
:
:
IsPtrArithmeticAllowed
(
Traits
)
"
cannot
increment
raw_ptr
unless
AllowPtrArithmetic
trait
is
present
.
"
)
;
wrapped_ptr_
=
Impl
:
:
Advance
(
wrapped_ptr_
1
)
;
return
*
this
;
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
-
-
(
)
{
static_assert
(
raw_ptr_traits
:
:
IsPtrArithmeticAllowed
(
Traits
)
"
cannot
decrement
raw_ptr
unless
AllowPtrArithmetic
trait
is
present
.
"
)
;
wrapped_ptr_
=
Impl
:
:
Retreat
(
wrapped_ptr_
1
)
;
return
*
this
;
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
operator
+
+
(
int
)
{
static_assert
(
raw_ptr_traits
:
:
IsPtrArithmeticAllowed
(
Traits
)
"
cannot
increment
raw_ptr
unless
AllowPtrArithmetic
trait
is
present
.
"
)
;
raw_ptr
result
=
*
this
;
+
+
(
*
this
)
;
return
result
;
}
PA_ALWAYS_INLINE
constexpr
raw_ptr
operator
-
-
(
int
)
{
static_assert
(
raw_ptr_traits
:
:
IsPtrArithmeticAllowed
(
Traits
)
"
cannot
decrement
raw_ptr
unless
AllowPtrArithmetic
trait
is
present
.
"
)
;
raw_ptr
result
=
*
this
;
-
-
(
*
this
)
;
return
result
;
}
template
<
typename
Z
typename
=
std
:
:
enable_if_t
<
partition_alloc
:
:
internal
:
:
is_offset_type
<
Z
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
+
=
(
Z
delta_elems
)
{
static_assert
(
raw_ptr_traits
:
:
IsPtrArithmeticAllowed
(
Traits
)
"
cannot
increment
raw_ptr
unless
AllowPtrArithmetic
trait
is
present
.
"
)
;
wrapped_ptr_
=
Impl
:
:
Advance
(
wrapped_ptr_
delta_elems
)
;
return
*
this
;
}
template
<
typename
Z
typename
=
std
:
:
enable_if_t
<
partition_alloc
:
:
internal
:
:
is_offset_type
<
Z
>
>
>
PA_ALWAYS_INLINE
constexpr
raw_ptr
&
operator
-
=
(
Z
delta_elems
)
{
static_assert
(
raw_ptr_traits
:
:
IsPtrArithmeticAllowed
(
Traits
)
"
cannot
increment
raw_ptr
unless
AllowPtrArithmetic
trait
is
present
.
"
)
;
wrapped_ptr_
=
Impl
:
:
Retreat
(
wrapped_ptr_
delta_elems
)
;
return
*
this
;
}
template
<
typename
Z
typename
U
=
T
RawPtrTraits
CopyTraits
=
Traits
typename
Unused
=
std
:
:
enable_if_t
<
!
std
:
:
is_void_v
<
typename
std
:
:
remove_cv
<
U
>
:
:
type
>
&
&
partition_alloc
:
:
internal
:
:
is_offset_type
<
Z
>
>
>
U
&
operator
[
]
(
Z
delta_elems
)
const
{
static_assert
(
raw_ptr_traits
:
:
IsPtrArithmeticAllowed
(
Traits
)
"
cannot
index
raw_ptr
unless
AllowPtrArithmetic
trait
is
present
.
"
)
;
return
wrapped_ptr_
[
delta_elems
]
;
}
template
<
typename
Z
>
PA_ALWAYS_INLINE
friend
constexpr
raw_ptr
operator
+
(
const
raw_ptr
&
p
Z
delta_elems
)
{
raw_ptr
result
=
p
;
return
result
+
=
delta_elems
;
}
template
<
typename
Z
>
PA_ALWAYS_INLINE
friend
constexpr
raw_ptr
operator
-
(
const
raw_ptr
&
p
Z
delta_elems
)
{
raw_ptr
result
=
p
;
return
result
-
=
delta_elems
;
}
PA_ALWAYS_INLINE
friend
constexpr
ptrdiff_t
operator
-
(
const
raw_ptr
&
p1
const
raw_ptr
&
p2
)
{
return
Impl
:
:
GetDeltaElems
(
p1
.
wrapped_ptr_
p2
.
wrapped_ptr_
)
;
}
PA_ALWAYS_INLINE
friend
constexpr
ptrdiff_t
operator
-
(
T
*
p1
const
raw_ptr
&
p2
)
{
return
Impl
:
:
GetDeltaElems
(
p1
p2
.
wrapped_ptr_
)
;
}
PA_ALWAYS_INLINE
friend
constexpr
ptrdiff_t
operator
-
(
const
raw_ptr
&
p1
T
*
p2
)
{
return
Impl
:
:
GetDeltaElems
(
p1
.
wrapped_ptr_
p2
)
;
}
PA_ALWAYS_INLINE
constexpr
void
ClearAndDelete
(
)
noexcept
{
delete
GetForExtractionAndReset
(
)
;
}
PA_ALWAYS_INLINE
constexpr
void
ClearAndDeleteArray
(
)
noexcept
{
delete
[
]
GetForExtractionAndReset
(
)
;
}
PA_ALWAYS_INLINE
constexpr
DanglingType
ExtractAsDangling
(
)
noexcept
{
DanglingType
res
(
std
:
:
move
(
*
this
)
)
;
operator
=
(
nullptr
)
;
return
res
;
}
template
<
typename
U
typename
V
RawPtrTraits
R1
RawPtrTraits
R2
>
friend
bool
operator
=
=
(
const
raw_ptr
<
U
R1
>
&
lhs
const
raw_ptr
<
V
R2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
R1
RawPtrTraits
R2
>
friend
bool
operator
!
=
(
const
raw_ptr
<
U
R1
>
&
lhs
const
raw_ptr
<
V
R2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
R1
RawPtrTraits
R2
>
friend
bool
operator
<
(
const
raw_ptr
<
U
R1
>
&
lhs
const
raw_ptr
<
V
R2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
R1
RawPtrTraits
R2
>
friend
bool
operator
>
(
const
raw_ptr
<
U
R1
>
&
lhs
const
raw_ptr
<
V
R2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
R1
RawPtrTraits
R2
>
friend
bool
operator
<
=
(
const
raw_ptr
<
U
R1
>
&
lhs
const
raw_ptr
<
V
R2
>
&
rhs
)
;
template
<
typename
U
typename
V
RawPtrTraits
R1
RawPtrTraits
R2
>
friend
bool
operator
>
=
(
const
raw_ptr
<
U
R1
>
&
lhs
const
raw_ptr
<
V
R2
>
&
rhs
)
;
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
=
=
(
const
raw_ptr
&
lhs
U
*
rhs
)
{
return
lhs
.
GetForComparison
(
)
=
=
rhs
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
!
=
(
const
raw_ptr
&
lhs
U
*
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
=
=
(
U
*
lhs
const
raw_ptr
&
rhs
)
{
return
rhs
=
=
lhs
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
!
=
(
U
*
lhs
const
raw_ptr
&
rhs
)
{
return
rhs
!
=
lhs
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
<
(
const
raw_ptr
&
lhs
U
*
rhs
)
{
return
lhs
.
GetForComparison
(
)
<
rhs
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
<
=
(
const
raw_ptr
&
lhs
U
*
rhs
)
{
return
lhs
.
GetForComparison
(
)
<
=
rhs
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
>
(
const
raw_ptr
&
lhs
U
*
rhs
)
{
return
lhs
.
GetForComparison
(
)
>
rhs
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
>
=
(
const
raw_ptr
&
lhs
U
*
rhs
)
{
return
lhs
.
GetForComparison
(
)
>
=
rhs
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
<
(
U
*
lhs
const
raw_ptr
&
rhs
)
{
return
lhs
<
rhs
.
GetForComparison
(
)
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
<
=
(
U
*
lhs
const
raw_ptr
&
rhs
)
{
return
lhs
<
=
rhs
.
GetForComparison
(
)
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
>
(
U
*
lhs
const
raw_ptr
&
rhs
)
{
return
lhs
>
rhs
.
GetForComparison
(
)
;
}
template
<
typename
U
>
PA_ALWAYS_INLINE
friend
bool
operator
>
=
(
U
*
lhs
const
raw_ptr
&
rhs
)
{
return
lhs
>
=
rhs
.
GetForComparison
(
)
;
}
PA_ALWAYS_INLINE
friend
bool
operator
=
=
(
const
raw_ptr
&
lhs
std
:
:
nullptr_t
)
{
return
!
lhs
;
}
PA_ALWAYS_INLINE
friend
bool
operator
!
=
(
const
raw_ptr
&
lhs
std
:
:
nullptr_t
)
{
return
!
!
lhs
;
}
PA_ALWAYS_INLINE
friend
bool
operator
=
=
(
std
:
:
nullptr_t
const
raw_ptr
&
rhs
)
{
return
!
rhs
;
}
PA_ALWAYS_INLINE
friend
bool
operator
!
=
(
std
:
:
nullptr_t
const
raw_ptr
&
rhs
)
{
return
!
!
rhs
;
}
PA_ALWAYS_INLINE
friend
constexpr
void
swap
(
raw_ptr
&
lhs
raw_ptr
&
rhs
)
noexcept
{
Impl
:
:
IncrementSwapCountForTest
(
)
;
std
:
:
swap
(
lhs
.
wrapped_ptr_
rhs
.
wrapped_ptr_
)
;
}
PA_ALWAYS_INLINE
void
ReportIfDangling
(
)
const
noexcept
{
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
Impl
:
:
ReportIfDangling
(
wrapped_ptr_
)
;
#
endif
}
private
:
PA_ALWAYS_INLINE
constexpr
T
*
GetForDereference
(
)
const
{
return
Impl
:
:
SafelyUnwrapPtrForDereference
(
wrapped_ptr_
)
;
}
PA_ALWAYS_INLINE
constexpr
T
*
GetForExtraction
(
)
const
{
return
Impl
:
:
SafelyUnwrapPtrForExtraction
(
wrapped_ptr_
)
;
}
PA_ALWAYS_INLINE
constexpr
T
*
GetForComparison
(
)
const
{
return
Impl
:
:
UnsafelyUnwrapPtrForComparison
(
wrapped_ptr_
)
;
}
PA_ALWAYS_INLINE
constexpr
T
*
GetForExtractionAndReset
(
)
{
T
*
ptr
=
GetForExtraction
(
)
;
operator
=
(
nullptr
)
;
return
ptr
;
}
RAW_PTR_EXCLUSION
T
*
wrapped_ptr_
;
template
<
typename
U
base
:
:
RawPtrTraits
R
>
friend
class
raw_ptr
;
}
;
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
=
=
(
const
raw_ptr
<
U
Traits1
>
&
lhs
const
raw_ptr
<
V
Traits2
>
&
rhs
)
{
return
lhs
.
GetForComparison
(
)
=
=
rhs
.
GetForComparison
(
)
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
!
=
(
const
raw_ptr
<
U
Traits1
>
&
lhs
const
raw_ptr
<
V
Traits2
>
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
<
(
const
raw_ptr
<
U
Traits1
>
&
lhs
const
raw_ptr
<
V
Traits2
>
&
rhs
)
{
return
lhs
.
GetForComparison
(
)
<
rhs
.
GetForComparison
(
)
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
>
(
const
raw_ptr
<
U
Traits1
>
&
lhs
const
raw_ptr
<
V
Traits2
>
&
rhs
)
{
return
lhs
.
GetForComparison
(
)
>
rhs
.
GetForComparison
(
)
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
<
=
(
const
raw_ptr
<
U
Traits1
>
&
lhs
const
raw_ptr
<
V
Traits2
>
&
rhs
)
{
return
lhs
.
GetForComparison
(
)
<
=
rhs
.
GetForComparison
(
)
;
}
template
<
typename
U
typename
V
RawPtrTraits
Traits1
RawPtrTraits
Traits2
>
PA_ALWAYS_INLINE
bool
operator
>
=
(
const
raw_ptr
<
U
Traits1
>
&
lhs
const
raw_ptr
<
V
Traits2
>
&
rhs
)
{
return
lhs
.
GetForComparison
(
)
>
=
rhs
.
GetForComparison
(
)
;
}
template
<
typename
T
>
struct
IsRawPtr
:
std
:
:
false_type
{
}
;
template
<
typename
T
RawPtrTraits
Traits
>
struct
IsRawPtr
<
raw_ptr
<
T
Traits
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
>
inline
constexpr
bool
IsRawPtrV
=
IsRawPtr
<
T
>
:
:
value
;
template
<
typename
T
>
inline
constexpr
bool
IsRawPtrMayDangleV
=
false
;
template
<
typename
T
RawPtrTraits
Traits
>
inline
constexpr
bool
IsRawPtrMayDangleV
<
raw_ptr
<
T
Traits
>
>
=
ContainsFlags
(
Traits
RawPtrTraits
:
:
kMayDangle
)
;
template
<
typename
T
>
struct
IsPointer
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
IsPointer
<
T
*
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
RawPtrTraits
Traits
>
struct
IsPointer
<
raw_ptr
<
T
Traits
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
>
inline
constexpr
bool
IsPointerV
=
IsPointer
<
T
>
:
:
value
;
template
<
typename
T
>
struct
RemovePointer
{
using
type
=
T
;
}
;
template
<
typename
T
>
struct
RemovePointer
<
T
*
>
{
using
type
=
T
;
}
;
template
<
typename
T
RawPtrTraits
Traits
>
struct
RemovePointer
<
raw_ptr
<
T
Traits
>
>
{
using
type
=
T
;
}
;
template
<
typename
T
>
using
RemovePointerT
=
typename
RemovePointer
<
T
>
:
:
type
;
struct
RawPtrGlobalSettings
{
static
void
EnableExperimentalAsh
(
)
{
#
if
BUILDFLAG
(
ENABLE_BACKUP_REF_PTR_SUPPORT
)
internal
:
:
BackupRefPtrGlobalSettings
:
:
EnableExperimentalAsh
(
)
;
#
endif
}
}
;
}
using
base
:
:
raw_ptr
;
constexpr
auto
DisableDanglingPtrDetection
=
base
:
:
RawPtrTraits
:
:
kMayDangle
;
constexpr
auto
DanglingUntriaged
=
base
:
:
RawPtrTraits
:
:
kMayDangle
;
constexpr
auto
FlakyDanglingUntriaged
=
base
:
:
RawPtrTraits
:
:
kMayDangle
;
constexpr
auto
AcrossTasksDanglingUntriaged
=
base
:
:
RawPtrTraits
:
:
kMayDangle
;
constexpr
auto
AllowPtrArithmetic
=
base
:
:
RawPtrTraits
:
:
kAllowPtrArithmetic
;
constexpr
auto
ExperimentalAsh
=
base
:
:
RawPtrTraits
:
:
kExperimentalAsh
;
constexpr
auto
AllowUninitialized
=
base
:
:
RawPtrTraits
:
:
kAllowUninitialized
;
constexpr
auto
LeakedDanglingUntriaged
=
base
:
:
RawPtrTraits
:
:
kMayDangle
;
constexpr
auto
ExperimentalRenderer
=
base
:
:
RawPtrTraits
:
:
kMayDangle
;
template
<
typename
T
base
:
:
RawPtrTraits
Traits
=
base
:
:
RawPtrTraits
:
:
kEmpty
>
using
MayBeDangling
=
base
:
:
raw_ptr
<
T
Traits
|
base
:
:
RawPtrTraits
:
:
kMayDangle
>
;
namespace
std
{
template
<
typename
T
base
:
:
RawPtrTraits
Traits
>
struct
less
<
raw_ptr
<
T
Traits
>
>
{
using
Impl
=
typename
raw_ptr
<
T
Traits
>
:
:
Impl
;
using
is_transparent
=
void
;
bool
operator
(
)
(
const
raw_ptr
<
T
Traits
>
&
lhs
const
raw_ptr
<
T
Traits
>
&
rhs
)
const
{
Impl
:
:
IncrementLessCountForTest
(
)
;
return
lhs
<
rhs
;
}
bool
operator
(
)
(
T
*
lhs
const
raw_ptr
<
T
Traits
>
&
rhs
)
const
{
Impl
:
:
IncrementLessCountForTest
(
)
;
return
lhs
<
rhs
;
}
bool
operator
(
)
(
const
raw_ptr
<
T
Traits
>
&
lhs
T
*
rhs
)
const
{
Impl
:
:
IncrementLessCountForTest
(
)
;
return
lhs
<
rhs
;
}
}
;
template
<
typename
T
base
:
:
RawPtrTraits
Traits
>
struct
iterator_traits
<
raw_ptr
<
T
Traits
>
>
{
using
difference_type
=
ptrdiff_t
;
using
value_type
=
std
:
:
remove_cv_t
<
T
>
;
using
pointer
=
T
*
;
using
reference
=
T
&
;
using
iterator_category
=
std
:
:
random_access_iterator_tag
;
}
;
template
<
typename
T
:
:
base
:
:
RawPtrTraits
Traits
>
struct
pointer_traits
<
:
:
raw_ptr
<
T
Traits
>
>
{
using
pointer
=
:
:
raw_ptr
<
T
Traits
>
;
using
element_type
=
T
;
using
difference_type
=
ptrdiff_t
;
template
<
typename
U
>
using
rebind
=
:
:
raw_ptr
<
U
Traits
>
;
static
constexpr
pointer
pointer_to
(
element_type
&
r
)
noexcept
{
return
pointer
(
&
r
)
;
}
static
constexpr
element_type
*
to_address
(
pointer
p
)
noexcept
{
return
p
.
get
(
)
;
}
}
;
}
#
endif
