#
ifndef
BASE_ALLOCATOR_PARTITION_ALLOCATOR_SRC_PARTITION_ALLOC_POINTERS_RAW_PTR_NOOP_IMPL_H_
#
define
BASE_ALLOCATOR_PARTITION_ALLOCATOR_SRC_PARTITION_ALLOC_POINTERS_RAW_PTR_NOOP_IMPL_H_
#
include
<
type_traits
>
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
compiler_specific
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_forward
.
h
"
namespace
base
:
:
internal
{
struct
RawPtrNoOpImpl
{
static
constexpr
bool
kMustZeroOnConstruct
=
false
;
static
constexpr
bool
kMustZeroOnMove
=
false
;
static
constexpr
bool
kMustZeroOnDestruct
=
false
;
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
T
*
WrapRawPtr
(
T
*
ptr
)
{
return
ptr
;
}
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
void
ReleaseWrappedPtr
(
T
*
)
{
}
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
T
*
SafelyUnwrapPtrForDereference
(
T
*
wrapped_ptr
)
{
return
wrapped_ptr
;
}
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
T
*
SafelyUnwrapPtrForExtraction
(
T
*
wrapped_ptr
)
{
return
wrapped_ptr
;
}
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
T
*
UnsafelyUnwrapPtrForComparison
(
T
*
wrapped_ptr
)
{
return
wrapped_ptr
;
}
template
<
typename
To
typename
From
>
PA_ALWAYS_INLINE
static
constexpr
To
*
Upcast
(
From
*
wrapped_ptr
)
{
static_assert
(
std
:
:
is_convertible_v
<
From
*
To
*
>
"
From
must
be
convertible
to
To
.
"
)
;
return
wrapped_ptr
;
}
template
<
typename
T
typename
Z
typename
=
std
:
:
enable_if_t
<
partition_alloc
:
:
internal
:
:
is_offset_type
<
Z
>
void
>
>
PA_ALWAYS_INLINE
static
constexpr
T
*
Advance
(
T
*
wrapped_ptr
Z
delta_elems
)
{
return
wrapped_ptr
+
delta_elems
;
}
template
<
typename
T
typename
Z
typename
=
std
:
:
enable_if_t
<
partition_alloc
:
:
internal
:
:
is_offset_type
<
Z
>
void
>
>
PA_ALWAYS_INLINE
static
constexpr
T
*
Retreat
(
T
*
wrapped_ptr
Z
delta_elems
)
{
return
wrapped_ptr
-
delta_elems
;
}
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
ptrdiff_t
GetDeltaElems
(
T
*
wrapped_ptr1
T
*
wrapped_ptr2
)
{
return
wrapped_ptr1
-
wrapped_ptr2
;
}
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
T
*
Duplicate
(
T
*
wrapped_ptr
)
{
return
wrapped_ptr
;
}
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
T
*
WrapRawPtrForDuplication
(
T
*
ptr
)
{
return
ptr
;
}
template
<
typename
T
>
PA_ALWAYS_INLINE
static
constexpr
T
*
UnsafelyUnwrapPtrForDuplication
(
T
*
wrapped_ptr
)
{
return
wrapped_ptr
;
}
PA_ALWAYS_INLINE
constexpr
static
void
IncrementSwapCountForTest
(
)
{
}
PA_ALWAYS_INLINE
constexpr
static
void
IncrementLessCountForTest
(
)
{
}
}
;
}
#
endif
