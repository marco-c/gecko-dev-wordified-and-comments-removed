#
ifndef
BASE_ALLOCATOR_PARTITION_ALLOCATOR_SRC_PARTITION_ALLOC_PARTITION_ALLOC_FORWARD_H_
#
define
BASE_ALLOCATOR_PARTITION_ALLOCATOR_SRC_PARTITION_ALLOC_PARTITION_ALLOC_FORWARD_H_
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
type_traits
>
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
compiler_specific
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
component_export
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
debug
/
debugging_buildflags
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_base
/
thread_annotations
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_config
.
h
"
namespace
partition_alloc
{
namespace
internal
{
#
if
defined
(
__STDCPP_DEFAULT_NEW_ALIGNMENT__
)
constexpr
size_t
kAlignment
=
std
:
:
max
(
alignof
(
max_align_t
)
static_cast
<
size_t
>
(
__STDCPP_DEFAULT_NEW_ALIGNMENT__
)
)
;
#
else
constexpr
size_t
kAlignment
=
alignof
(
max_align_t
)
;
#
endif
static_assert
(
kAlignment
<
=
16
"
PartitionAlloc
doesn
'
t
support
a
fundamental
alignment
larger
"
"
than
16
bytes
.
"
)
;
struct
SlotSpanMetadata
;
class
PA_LOCKABLE
Lock
;
template
<
typename
Z
>
static
constexpr
bool
is_offset_type
=
std
:
:
is_integral_v
<
Z
>
&
&
sizeof
(
Z
)
<
=
sizeof
(
ptrdiff_t
)
;
}
class
PartitionStatsDumper
;
struct
PartitionRoot
;
namespace
internal
{
Lock
&
PartitionRootLock
(
PartitionRoot
*
)
;
}
}
#
if
PA_HAS_ATTRIBUTE
(
malloc
)
#
define
PA_MALLOC_FN
__attribute__
(
(
malloc
)
)
#
endif
#
if
PA_HAS_ATTRIBUTE
(
assume_aligned
)
#
define
PA_MALLOC_ALIGNED
\
__attribute__
(
(
assume_aligned
(
:
:
partition_alloc
:
:
internal
:
:
kAlignment
)
)
)
#
endif
#
if
!
defined
(
PA_MALLOC_FN
)
#
define
PA_MALLOC_FN
#
endif
#
if
!
defined
(
PA_MALLOC_ALIGNED
)
#
define
PA_MALLOC_ALIGNED
#
endif
#
endif
