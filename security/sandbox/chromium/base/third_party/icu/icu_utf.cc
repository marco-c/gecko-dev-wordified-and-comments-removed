#
include
"
base
/
third_party
/
icu
/
icu_utf
.
h
"
namespace
base_icu
{
static
const
UChar32
utf8_errorValue
[
6
]
=
{
0x15
0x9f
0xffff
0x10ffff
}
;
static
UChar32
errorValue
(
int32_t
count
int8_t
strict
)
{
if
(
strict
>
=
0
)
{
return
utf8_errorValue
[
count
]
;
}
else
if
(
strict
=
=
-
3
)
{
return
0xfffd
;
}
else
{
return
CBU_SENTINEL
;
}
}
UChar32
utf8_nextCharSafeBody
(
const
uint8_t
*
s
int32_t
*
pi
int32_t
length
UChar32
c
UBool
strict
)
{
int32_t
i
=
*
pi
;
if
(
i
=
=
length
|
|
c
>
0xf4
)
{
}
else
if
(
c
>
=
0xf0
)
{
uint8_t
t1
=
s
[
i
]
t2
t3
;
c
&
=
7
;
if
(
CBU8_IS_VALID_LEAD4_AND_T1
(
c
t1
)
&
&
+
+
i
!
=
length
&
&
(
t2
=
s
[
i
]
-
0x80
)
<
=
0x3f
&
&
+
+
i
!
=
length
&
&
(
t3
=
s
[
i
]
-
0x80
)
<
=
0x3f
)
{
+
+
i
;
c
=
(
c
<
<
18
)
|
(
(
t1
&
0x3f
)
<
<
12
)
|
(
t2
<
<
6
)
|
t3
;
if
(
strict
<
=
0
|
|
!
CBU_IS_UNICODE_NONCHAR
(
c
)
)
{
*
pi
=
i
;
return
c
;
}
}
}
else
if
(
c
>
=
0xe0
)
{
c
&
=
0xf
;
if
(
strict
!
=
-
2
)
{
uint8_t
t1
=
s
[
i
]
t2
;
if
(
CBU8_IS_VALID_LEAD3_AND_T1
(
c
t1
)
&
&
+
+
i
!
=
length
&
&
(
t2
=
s
[
i
]
-
0x80
)
<
=
0x3f
)
{
+
+
i
;
c
=
(
c
<
<
12
)
|
(
(
t1
&
0x3f
)
<
<
6
)
|
t2
;
if
(
strict
<
=
0
|
|
!
CBU_IS_UNICODE_NONCHAR
(
c
)
)
{
*
pi
=
i
;
return
c
;
}
}
}
else
{
uint8_t
t1
=
s
[
i
]
-
0x80
t2
;
if
(
t1
<
=
0x3f
&
&
(
c
>
0
|
|
t1
>
=
0x20
)
&
&
+
+
i
!
=
length
&
&
(
t2
=
s
[
i
]
-
0x80
)
<
=
0x3f
)
{
*
pi
=
i
+
1
;
return
(
c
<
<
12
)
|
(
t1
<
<
6
)
|
t2
;
}
}
}
else
if
(
c
>
=
0xc2
)
{
uint8_t
t1
=
s
[
i
]
-
0x80
;
if
(
t1
<
=
0x3f
)
{
*
pi
=
i
+
1
;
return
(
(
c
-
0xc0
)
<
<
6
)
|
t1
;
}
}
c
=
errorValue
(
i
-
*
pi
strict
)
;
*
pi
=
i
;
return
c
;
}
}
