#
ifndef
BASE_SEQUENCED_TASK_RUNNER_H_
#
define
BASE_SEQUENCED_TASK_RUNNER_H_
#
include
<
memory
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
callback
.
h
"
#
include
"
base
/
sequenced_task_runner_helpers
.
h
"
#
include
"
base
/
task_runner
.
h
"
namespace
base
{
class
BASE_EXPORT
SequencedTaskRunner
:
public
TaskRunner
{
public
:
bool
PostNonNestableTask
(
const
Location
&
from_here
OnceClosure
task
)
;
virtual
bool
PostNonNestableDelayedTask
(
const
Location
&
from_here
OnceClosure
task
base
:
:
TimeDelta
delay
)
=
0
;
template
<
class
T
>
bool
DeleteSoon
(
const
Location
&
from_here
const
T
*
object
)
{
return
DeleteOrReleaseSoonInternal
(
from_here
&
DeleteHelper
<
T
>
:
:
DoDelete
object
)
;
}
template
<
class
T
>
bool
DeleteSoon
(
const
Location
&
from_here
std
:
:
unique_ptr
<
T
>
object
)
{
return
DeleteSoon
(
from_here
object
.
release
(
)
)
;
}
template
<
class
T
>
void
ReleaseSoon
(
const
Location
&
from_here
scoped_refptr
<
T
>
&
&
object
)
{
if
(
!
object
)
return
;
DeleteOrReleaseSoonInternal
(
from_here
&
ReleaseHelper
<
T
>
:
:
DoRelease
object
.
release
(
)
)
;
}
protected
:
~
SequencedTaskRunner
(
)
override
=
default
;
private
:
bool
DeleteOrReleaseSoonInternal
(
const
Location
&
from_here
void
(
*
deleter
)
(
const
void
*
)
const
void
*
object
)
;
}
;
struct
BASE_EXPORT
OnTaskRunnerDeleter
{
explicit
OnTaskRunnerDeleter
(
scoped_refptr
<
SequencedTaskRunner
>
task_runner
)
;
~
OnTaskRunnerDeleter
(
)
;
OnTaskRunnerDeleter
(
OnTaskRunnerDeleter
&
&
)
;
OnTaskRunnerDeleter
&
operator
=
(
OnTaskRunnerDeleter
&
&
)
;
template
<
typename
T
>
void
operator
(
)
(
const
T
*
ptr
)
{
if
(
ptr
)
task_runner_
-
>
DeleteSoon
(
FROM_HERE
ptr
)
;
}
scoped_refptr
<
SequencedTaskRunner
>
task_runner_
;
}
;
}
#
endif
