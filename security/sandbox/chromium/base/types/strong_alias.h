#
ifndef
BASE_TYPES_STRONG_ALIAS_H_
#
define
BASE_TYPES_STRONG_ALIAS_H_
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
trace_event
/
base_tracing_forward
.
h
"
#
include
"
base
/
types
/
supports_ostream_operator
.
h
"
namespace
base
{
template
<
typename
TagType
typename
UnderlyingType
>
class
StrongAlias
{
public
:
using
underlying_type
=
UnderlyingType
;
constexpr
StrongAlias
(
)
=
default
;
constexpr
explicit
StrongAlias
(
const
UnderlyingType
&
v
)
:
value_
(
v
)
{
}
constexpr
explicit
StrongAlias
(
UnderlyingType
&
&
v
)
noexcept
:
value_
(
std
:
:
move
(
v
)
)
{
}
constexpr
UnderlyingType
*
operator
-
>
(
)
{
return
&
value_
;
}
constexpr
const
UnderlyingType
*
operator
-
>
(
)
const
{
return
&
value_
;
}
constexpr
UnderlyingType
&
operator
*
(
)
&
{
return
value_
;
}
constexpr
const
UnderlyingType
&
operator
*
(
)
const
&
{
return
value_
;
}
constexpr
UnderlyingType
&
&
operator
*
(
)
&
&
{
return
std
:
:
move
(
value_
)
;
}
constexpr
const
UnderlyingType
&
&
operator
*
(
)
const
&
&
{
return
std
:
:
move
(
value_
)
;
}
constexpr
UnderlyingType
&
value
(
)
&
{
return
value_
;
}
constexpr
const
UnderlyingType
&
value
(
)
const
&
{
return
value_
;
}
constexpr
UnderlyingType
&
&
value
(
)
&
&
{
return
std
:
:
move
(
value_
)
;
}
constexpr
const
UnderlyingType
&
&
value
(
)
const
&
&
{
return
std
:
:
move
(
value_
)
;
}
constexpr
explicit
operator
const
UnderlyingType
&
(
)
const
&
{
return
value_
;
}
constexpr
bool
operator
=
=
(
const
StrongAlias
&
other
)
const
{
return
value_
=
=
other
.
value_
;
}
constexpr
bool
operator
!
=
(
const
StrongAlias
&
other
)
const
{
return
value_
!
=
other
.
value_
;
}
constexpr
bool
operator
<
(
const
StrongAlias
&
other
)
const
{
return
value_
<
other
.
value_
;
}
constexpr
bool
operator
<
=
(
const
StrongAlias
&
other
)
const
{
return
value_
<
=
other
.
value_
;
}
constexpr
bool
operator
>
(
const
StrongAlias
&
other
)
const
{
return
value_
>
other
.
value_
;
}
constexpr
bool
operator
>
=
(
const
StrongAlias
&
other
)
const
{
return
value_
>
=
other
.
value_
;
}
struct
Hasher
{
using
argument_type
=
StrongAlias
;
using
result_type
=
std
:
:
size_t
;
result_type
operator
(
)
(
const
argument_type
&
id
)
const
{
return
std
:
:
hash
<
UnderlyingType
>
(
)
(
id
.
value
(
)
)
;
}
}
;
template
<
class
U
=
UnderlyingType
>
typename
perfetto
:
:
check_traced_value_support
<
U
>
:
:
type
WriteIntoTrace
(
perfetto
:
:
TracedValue
&
&
context
)
const
{
perfetto
:
:
WriteIntoTracedValue
(
std
:
:
move
(
context
)
value_
)
;
}
protected
:
UnderlyingType
value_
;
}
;
template
<
typename
TagType
typename
UnderlyingType
typename
=
std
:
:
enable_if_t
<
internal
:
:
SupportsOstreamOperator
<
UnderlyingType
>
:
:
value
>
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
stream
const
StrongAlias
<
TagType
UnderlyingType
>
&
alias
)
{
return
stream
<
<
alias
.
value
(
)
;
}
}
#
endif
