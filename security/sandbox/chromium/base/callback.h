#
ifndef
BASE_CALLBACK_H_
#
define
BASE_CALLBACK_H_
#
include
"
base
/
callback_forward
.
h
"
#
include
"
base
/
callback_internal
.
h
"
#
include
"
base
/
template_util
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
Runnable
typename
RunType
typename
.
.
.
BoundArgsType
>
struct
BindState
;
}
template
<
typename
R
typename
.
.
.
Args
>
class
Callback
<
R
(
Args
.
.
.
)
>
:
public
internal
:
:
CallbackBase
{
public
:
typedef
R
RunType
(
Args
.
.
.
)
;
Callback
(
)
:
CallbackBase
(
nullptr
)
{
}
template
<
typename
Runnable
typename
BindRunType
typename
.
.
.
BoundArgsType
>
explicit
Callback
(
internal
:
:
BindState
<
Runnable
BindRunType
BoundArgsType
.
.
.
>
*
bind_state
)
:
CallbackBase
(
bind_state
)
{
PolymorphicInvoke
invoke_func
=
&
internal
:
:
BindState
<
Runnable
BindRunType
BoundArgsType
.
.
.
>
:
:
InvokerType
:
:
Run
;
polymorphic_invoke_
=
reinterpret_cast
<
InvokeFuncStorage
>
(
invoke_func
)
;
}
bool
Equals
(
const
Callback
&
other
)
const
{
return
CallbackBase
:
:
Equals
(
other
)
;
}
R
Run
(
typename
internal
:
:
CallbackParamTraits
<
Args
>
:
:
ForwardType
.
.
.
args
)
const
{
PolymorphicInvoke
f
=
reinterpret_cast
<
PolymorphicInvoke
>
(
polymorphic_invoke_
)
;
return
f
(
bind_state_
.
get
(
)
internal
:
:
CallbackForward
(
args
)
.
.
.
)
;
}
private
:
using
PolymorphicInvoke
=
R
(
*
)
(
internal
:
:
BindStateBase
*
typename
internal
:
:
CallbackParamTraits
<
Args
>
:
:
ForwardType
.
.
.
)
;
}
;
}
#
endif
