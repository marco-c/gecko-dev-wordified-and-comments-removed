#
ifndef
BASE_LOGGING_H_
#
define
BASE_LOGGING_H_
#
include
<
stddef
.
h
>
#
include
<
cassert
>
#
include
<
cstring
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
callback_forward
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
debug
/
debugger
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
strings
/
string_piece_forward
.
h
"
#
include
"
base
/
template_util
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
logging
{
#
if
defined
(
OS_WIN
)
typedef
wchar_t
PathChar
;
#
else
typedef
char
PathChar
;
#
endif
enum
LoggingDestination
{
LOG_NONE
=
0
LOG_TO_FILE
=
1
<
<
0
LOG_TO_SYSTEM_DEBUG_LOG
=
1
<
<
1
LOG_TO_ALL
=
LOG_TO_FILE
|
LOG_TO_SYSTEM_DEBUG_LOG
#
if
defined
(
OS_WIN
)
LOG_DEFAULT
=
LOG_TO_FILE
#
elif
defined
(
OS_POSIX
)
LOG_DEFAULT
=
LOG_TO_SYSTEM_DEBUG_LOG
#
endif
}
;
enum
LogLockingState
{
LOCK_LOG_FILE
DONT_LOCK_LOG_FILE
}
;
enum
OldFileDeletionState
{
DELETE_OLD_LOG_FILE
APPEND_TO_OLD_LOG_FILE
}
;
struct
BASE_EXPORT
LoggingSettings
{
LoggingSettings
(
)
;
LoggingDestination
logging_dest
;
const
PathChar
*
log_file
;
LogLockingState
lock_log
;
OldFileDeletionState
delete_old
;
}
;
#
if
defined
(
NDEBUG
)
#
define
BaseInitLoggingImpl
BaseInitLoggingImpl_built_with_NDEBUG
#
else
#
define
BaseInitLoggingImpl
BaseInitLoggingImpl_built_without_NDEBUG
#
endif
BASE_EXPORT
bool
BaseInitLoggingImpl
(
const
LoggingSettings
&
settings
)
;
inline
bool
InitLogging
(
const
LoggingSettings
&
settings
)
{
return
BaseInitLoggingImpl
(
settings
)
;
}
BASE_EXPORT
void
SetMinLogLevel
(
int
level
)
;
BASE_EXPORT
int
GetMinLogLevel
(
)
;
BASE_EXPORT
bool
ShouldCreateLogMessage
(
int
severity
)
;
BASE_EXPORT
int
GetVlogVerbosity
(
)
;
BASE_EXPORT
int
GetVlogLevelHelper
(
const
char
*
file_start
size_t
N
)
;
template
<
size_t
N
>
int
GetVlogLevel
(
const
char
(
&
file
)
[
N
]
)
{
return
GetVlogLevelHelper
(
file
N
)
;
}
BASE_EXPORT
void
SetLogItems
(
bool
enable_process_id
bool
enable_thread_id
bool
enable_timestamp
bool
enable_tickcount
)
;
BASE_EXPORT
void
SetShowErrorDialogs
(
bool
enable_dialogs
)
;
using
LogAssertHandlerFunction
=
base
:
:
Callback
<
void
(
const
char
*
file
int
line
const
base
:
:
StringPiece
message
const
base
:
:
StringPiece
stack_trace
)
>
;
class
BASE_EXPORT
ScopedLogAssertHandler
{
public
:
explicit
ScopedLogAssertHandler
(
LogAssertHandlerFunction
handler
)
;
~
ScopedLogAssertHandler
(
)
;
private
:
DISALLOW_COPY_AND_ASSIGN
(
ScopedLogAssertHandler
)
;
}
;
typedef
bool
(
*
LogMessageHandlerFunction
)
(
int
severity
const
char
*
file
int
line
size_t
message_start
const
std
:
:
string
&
str
)
;
BASE_EXPORT
void
SetLogMessageHandler
(
LogMessageHandlerFunction
handler
)
;
BASE_EXPORT
LogMessageHandlerFunction
GetLogMessageHandler
(
)
;
#
if
defined
(
__clang_analyzer__
)
inline
constexpr
bool
AnalyzerNoReturn
(
)
__attribute__
(
(
analyzer_noreturn
)
)
{
return
false
;
}
inline
constexpr
bool
AnalyzerAssumeTrue
(
bool
arg
)
{
return
arg
|
|
AnalyzerNoReturn
(
)
;
}
#
define
ANALYZER_ASSUME_TRUE
(
arg
)
logging
:
:
AnalyzerAssumeTrue
(
!
!
(
arg
)
)
#
define
ANALYZER_SKIP_THIS_PATH
(
)
\
static_cast
<
void
>
(
:
:
logging
:
:
AnalyzerNoReturn
(
)
)
#
define
ANALYZER_ALLOW_UNUSED
(
var
)
static_cast
<
void
>
(
var
)
;
#
else
#
define
ANALYZER_ASSUME_TRUE
(
arg
)
(
arg
)
#
define
ANALYZER_SKIP_THIS_PATH
(
)
#
define
ANALYZER_ALLOW_UNUSED
(
var
)
static_cast
<
void
>
(
var
)
;
#
endif
typedef
int
LogSeverity
;
const
LogSeverity
LOG_VERBOSE
=
-
1
;
const
LogSeverity
LOG_INFO
=
0
;
const
LogSeverity
LOG_WARNING
=
1
;
const
LogSeverity
LOG_ERROR
=
2
;
const
LogSeverity
LOG_FATAL
=
3
;
const
LogSeverity
LOG_NUM_SEVERITIES
=
4
;
#
if
defined
(
NDEBUG
)
const
LogSeverity
LOG_DFATAL
=
LOG_ERROR
;
#
else
const
LogSeverity
LOG_DFATAL
=
LOG_FATAL
;
#
endif
#
define
COMPACT_GOOGLE_LOG_EX_INFO
(
ClassName
.
.
.
)
\
:
:
logging
:
:
ClassName
(
__FILE__
__LINE__
:
:
logging
:
:
LOG_INFO
#
#
__VA_ARGS__
)
#
define
COMPACT_GOOGLE_LOG_EX_WARNING
(
ClassName
.
.
.
)
\
:
:
logging
:
:
ClassName
(
__FILE__
__LINE__
:
:
logging
:
:
LOG_WARNING
\
#
#
__VA_ARGS__
)
#
define
COMPACT_GOOGLE_LOG_EX_ERROR
(
ClassName
.
.
.
)
\
:
:
logging
:
:
ClassName
(
__FILE__
__LINE__
:
:
logging
:
:
LOG_ERROR
#
#
__VA_ARGS__
)
#
define
COMPACT_GOOGLE_LOG_EX_FATAL
(
ClassName
.
.
.
)
\
:
:
logging
:
:
ClassName
(
__FILE__
__LINE__
:
:
logging
:
:
LOG_FATAL
#
#
__VA_ARGS__
)
#
define
COMPACT_GOOGLE_LOG_EX_DFATAL
(
ClassName
.
.
.
)
\
:
:
logging
:
:
ClassName
(
__FILE__
__LINE__
:
:
logging
:
:
LOG_DFATAL
#
#
__VA_ARGS__
)
#
define
COMPACT_GOOGLE_LOG_EX_DCHECK
(
ClassName
.
.
.
)
\
:
:
logging
:
:
ClassName
(
__FILE__
__LINE__
:
:
logging
:
:
LOG_DCHECK
#
#
__VA_ARGS__
)
#
define
COMPACT_GOOGLE_LOG_INFO
COMPACT_GOOGLE_LOG_EX_INFO
(
LogMessage
)
#
define
COMPACT_GOOGLE_LOG_WARNING
COMPACT_GOOGLE_LOG_EX_WARNING
(
LogMessage
)
#
define
COMPACT_GOOGLE_LOG_ERROR
COMPACT_GOOGLE_LOG_EX_ERROR
(
LogMessage
)
#
define
COMPACT_GOOGLE_LOG_FATAL
COMPACT_GOOGLE_LOG_EX_FATAL
(
LogMessage
)
#
define
COMPACT_GOOGLE_LOG_DFATAL
COMPACT_GOOGLE_LOG_EX_DFATAL
(
LogMessage
)
#
define
COMPACT_GOOGLE_LOG_DCHECK
COMPACT_GOOGLE_LOG_EX_DCHECK
(
LogMessage
)
#
if
defined
(
OS_WIN
)
#
define
ERROR
0
#
define
COMPACT_GOOGLE_LOG_EX_0
(
ClassName
.
.
.
)
\
COMPACT_GOOGLE_LOG_EX_ERROR
(
ClassName
#
#
__VA_ARGS__
)
#
define
COMPACT_GOOGLE_LOG_0
COMPACT_GOOGLE_LOG_ERROR
const
LogSeverity
LOG_0
=
LOG_ERROR
;
#
endif
#
define
LOG_IS_ON
(
severity
)
\
(
:
:
logging
:
:
ShouldCreateLogMessage
(
:
:
logging
:
:
LOG_
#
#
severity
)
)
#
define
VLOG_IS_ON
(
verboselevel
)
\
(
(
verboselevel
)
<
=
:
:
logging
:
:
GetVlogLevel
(
__FILE__
)
)
#
define
LAZY_STREAM
(
stream
condition
)
\
!
(
condition
)
?
(
void
)
0
:
:
:
logging
:
:
LogMessageVoidify
(
)
&
(
stream
)
#
define
LOG_STREAM
(
severity
)
COMPACT_GOOGLE_LOG_
#
#
severity
.
stream
(
)
#
define
LOG
(
severity
)
LAZY_STREAM
(
LOG_STREAM
(
severity
)
LOG_IS_ON
(
severity
)
)
#
define
LOG_IF
(
severity
condition
)
\
LAZY_STREAM
(
LOG_STREAM
(
severity
)
LOG_IS_ON
(
severity
)
&
&
(
condition
)
)
#
define
VLOG_STREAM
(
verbose_level
)
\
:
:
logging
:
:
LogMessage
(
__FILE__
__LINE__
-
verbose_level
)
.
stream
(
)
#
define
VLOG
(
verbose_level
)
\
LAZY_STREAM
(
VLOG_STREAM
(
verbose_level
)
VLOG_IS_ON
(
verbose_level
)
)
#
define
VLOG_IF
(
verbose_level
condition
)
\
LAZY_STREAM
(
VLOG_STREAM
(
verbose_level
)
\
VLOG_IS_ON
(
verbose_level
)
&
&
(
condition
)
)
#
if
defined
(
OS_WIN
)
#
define
VPLOG_STREAM
(
verbose_level
)
\
:
:
logging
:
:
Win32ErrorLogMessage
(
__FILE__
__LINE__
-
verbose_level
\
:
:
logging
:
:
GetLastSystemErrorCode
(
)
)
.
stream
(
)
#
elif
defined
(
OS_POSIX
)
#
define
VPLOG_STREAM
(
verbose_level
)
\
:
:
logging
:
:
ErrnoLogMessage
(
__FILE__
__LINE__
-
verbose_level
\
:
:
logging
:
:
GetLastSystemErrorCode
(
)
)
.
stream
(
)
#
endif
#
define
VPLOG
(
verbose_level
)
\
LAZY_STREAM
(
VPLOG_STREAM
(
verbose_level
)
VLOG_IS_ON
(
verbose_level
)
)
#
define
VPLOG_IF
(
verbose_level
condition
)
\
LAZY_STREAM
(
VPLOG_STREAM
(
verbose_level
)
\
VLOG_IS_ON
(
verbose_level
)
&
&
(
condition
)
)
#
define
LOG_ASSERT
(
condition
)
\
LOG_IF
(
FATAL
!
(
ANALYZER_ASSUME_TRUE
(
condition
)
)
)
\
<
<
"
Assert
failed
:
"
#
condition
"
.
"
#
if
defined
(
OS_WIN
)
#
define
PLOG_STREAM
(
severity
)
\
COMPACT_GOOGLE_LOG_EX_
#
#
severity
(
Win32ErrorLogMessage
\
:
:
logging
:
:
GetLastSystemErrorCode
(
)
)
.
stream
(
)
#
elif
defined
(
OS_POSIX
)
#
define
PLOG_STREAM
(
severity
)
\
COMPACT_GOOGLE_LOG_EX_
#
#
severity
(
ErrnoLogMessage
\
:
:
logging
:
:
GetLastSystemErrorCode
(
)
)
.
stream
(
)
#
endif
#
define
PLOG
(
severity
)
\
LAZY_STREAM
(
PLOG_STREAM
(
severity
)
LOG_IS_ON
(
severity
)
)
#
define
PLOG_IF
(
severity
condition
)
\
LAZY_STREAM
(
PLOG_STREAM
(
severity
)
LOG_IS_ON
(
severity
)
&
&
(
condition
)
)
BASE_EXPORT
extern
std
:
:
ostream
*
g_swallow_stream
;
#
define
EAT_STREAM_PARAMETERS
\
true
?
(
void
)
0
\
:
:
:
logging
:
:
LogMessageVoidify
(
)
&
(
*
:
:
logging
:
:
g_swallow_stream
)
class
CheckOpResult
{
public
:
CheckOpResult
(
std
:
:
string
*
message
)
:
message_
(
message
)
{
}
operator
bool
(
)
const
{
return
!
message_
;
}
std
:
:
string
*
message
(
)
{
return
message_
;
}
private
:
std
:
:
string
*
message_
;
}
;
#
if
defined
(
COMPILER_GCC
)
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
&
&
!
defined
(
OS_NACL
)
#
define
TRAP_SEQUENCE
(
)
\
asm
volatile
(
\
"
int3
;
ud2
;
push
%
0
;
"
:
:
"
i
"
(
static_cast
<
unsigned
char
>
(
__COUNTER__
)
)
)
#
elif
defined
(
ARCH_CPU_ARMEL
)
&
&
!
defined
(
OS_NACL
)
#
define
TRAP_SEQUENCE
(
)
\
asm
volatile
(
"
bkpt
#
0
;
udf
%
0
;
"
:
:
"
i
"
(
__COUNTER__
%
256
)
)
#
elif
defined
(
ARCH_CPU_ARM64
)
&
&
!
defined
(
OS_NACL
)
#
define
TRAP_SEQUENCE
(
)
\
asm
volatile
(
"
brk
#
0
;
hlt
%
0
;
"
:
:
"
i
"
(
__COUNTER__
%
65536
)
)
#
else
#
define
TRAP_SEQUENCE
(
)
__builtin_trap
(
)
#
endif
#
define
IMMEDIATE_CRASH
(
)
\
(
{
\
TRAP_SEQUENCE
(
)
;
\
__builtin_unreachable
(
)
;
\
}
)
#
elif
defined
(
COMPILER_MSVC
)
#
if
defined
(
__clang__
)
#
define
IMMEDIATE_CRASH
(
)
(
{
__asm
int
3
__asm
ud2
__asm
push
__COUNTER__
}
)
#
else
#
define
IMMEDIATE_CRASH
(
)
__debugbreak
(
)
#
endif
#
else
#
error
Port
#
endif
#
if
defined
(
OFFICIAL_BUILD
)
&
&
defined
(
NDEBUG
)
#
define
CHECK
(
condition
)
\
UNLIKELY
(
!
(
condition
)
)
?
IMMEDIATE_CRASH
(
)
:
EAT_STREAM_PARAMETERS
#
define
PCHECK
(
condition
)
\
LAZY_STREAM
(
PLOG_STREAM
(
FATAL
)
UNLIKELY
(
!
(
condition
)
)
)
;
\
EAT_STREAM_PARAMETERS
#
define
CHECK_OP
(
name
op
val1
val2
)
CHECK
(
(
val1
)
op
(
val2
)
)
#
else
#
if
defined
(
_PREFAST_
)
&
&
defined
(
OS_WIN
)
#
define
CHECK
(
condition
)
\
__analysis_assume
(
!
!
(
condition
)
)
\
LAZY_STREAM
(
LOG_STREAM
(
FATAL
)
false
)
\
<
<
"
Check
failed
:
"
#
condition
"
.
"
#
define
PCHECK
(
condition
)
\
__analysis_assume
(
!
!
(
condition
)
)
\
LAZY_STREAM
(
PLOG_STREAM
(
FATAL
)
false
)
\
<
<
"
Check
failed
:
"
#
condition
"
.
"
#
else
#
define
CHECK
(
condition
)
\
LAZY_STREAM
(
:
:
logging
:
:
LogMessage
(
__FILE__
__LINE__
#
condition
)
.
stream
(
)
\
!
ANALYZER_ASSUME_TRUE
(
condition
)
)
#
define
PCHECK
(
condition
)
\
LAZY_STREAM
(
PLOG_STREAM
(
FATAL
)
!
ANALYZER_ASSUME_TRUE
(
condition
)
)
\
<
<
"
Check
failed
:
"
#
condition
"
.
"
#
endif
#
define
CHECK_OP
(
name
op
val1
val2
)
\
switch
(
0
)
case
0
:
default
:
\
if
(
:
:
logging
:
:
CheckOpResult
true_if_passed
=
\
:
:
logging
:
:
Check
#
#
name
#
#
Impl
(
(
val1
)
(
val2
)
\
#
val1
"
"
#
op
"
"
#
val2
)
)
\
;
\
else
\
:
:
logging
:
:
LogMessage
(
__FILE__
__LINE__
true_if_passed
.
message
(
)
)
.
stream
(
)
#
endif
template
<
typename
T
>
inline
typename
std
:
:
enable_if
<
base
:
:
internal
:
:
SupportsOstreamOperator
<
const
T
&
>
:
:
value
&
&
!
std
:
:
is_function
<
typename
std
:
:
remove_pointer
<
T
>
:
:
type
>
:
:
value
void
>
:
:
type
MakeCheckOpValueString
(
std
:
:
ostream
*
os
const
T
&
v
)
{
(
*
os
)
<
<
v
;
}
template
<
typename
T
>
inline
typename
std
:
:
enable_if
<
std
:
:
is_function
<
typename
std
:
:
remove_pointer
<
T
>
:
:
type
>
:
:
value
void
>
:
:
type
MakeCheckOpValueString
(
std
:
:
ostream
*
os
const
T
&
v
)
{
(
*
os
)
<
<
reinterpret_cast
<
const
void
*
>
(
v
)
;
}
template
<
typename
T
>
inline
typename
std
:
:
enable_if
<
!
base
:
:
internal
:
:
SupportsOstreamOperator
<
const
T
&
>
:
:
value
&
&
std
:
:
is_enum
<
T
>
:
:
value
void
>
:
:
type
MakeCheckOpValueString
(
std
:
:
ostream
*
os
const
T
&
v
)
{
(
*
os
)
<
<
static_cast
<
typename
std
:
:
underlying_type
<
T
>
:
:
type
>
(
v
)
;
}
BASE_EXPORT
void
MakeCheckOpValueString
(
std
:
:
ostream
*
os
std
:
:
nullptr_t
p
)
;
template
<
class
t1
class
t2
>
std
:
:
string
*
MakeCheckOpString
(
const
t1
&
v1
const
t2
&
v2
const
char
*
names
)
{
std
:
:
ostringstream
ss
;
ss
<
<
names
<
<
"
(
"
;
MakeCheckOpValueString
(
&
ss
v1
)
;
ss
<
<
"
vs
.
"
;
MakeCheckOpValueString
(
&
ss
v2
)
;
ss
<
<
"
)
"
;
std
:
:
string
*
msg
=
new
std
:
:
string
(
ss
.
str
(
)
)
;
return
msg
;
}
extern
template
BASE_EXPORT
std
:
:
string
*
MakeCheckOpString
<
int
int
>
(
const
int
&
const
int
&
const
char
*
names
)
;
extern
template
BASE_EXPORT
std
:
:
string
*
MakeCheckOpString
<
unsigned
long
unsigned
long
>
(
const
unsigned
long
&
const
unsigned
long
&
const
char
*
names
)
;
extern
template
BASE_EXPORT
std
:
:
string
*
MakeCheckOpString
<
unsigned
long
unsigned
int
>
(
const
unsigned
long
&
const
unsigned
int
&
const
char
*
names
)
;
extern
template
BASE_EXPORT
std
:
:
string
*
MakeCheckOpString
<
unsigned
int
unsigned
long
>
(
const
unsigned
int
&
const
unsigned
long
&
const
char
*
names
)
;
extern
template
BASE_EXPORT
std
:
:
string
*
MakeCheckOpString
<
std
:
:
string
std
:
:
string
>
(
const
std
:
:
string
&
const
std
:
:
string
&
const
char
*
name
)
;
#
define
DEFINE_CHECK_OP_IMPL
(
name
op
)
\
template
<
class
t1
class
t2
>
\
inline
std
:
:
string
*
Check
#
#
name
#
#
Impl
(
const
t1
&
v1
const
t2
&
v2
\
const
char
*
names
)
{
\
if
(
ANALYZER_ASSUME_TRUE
(
v1
op
v2
)
)
\
return
NULL
;
\
else
\
return
:
:
logging
:
:
MakeCheckOpString
(
v1
v2
names
)
;
\
}
\
inline
std
:
:
string
*
Check
#
#
name
#
#
Impl
(
int
v1
int
v2
const
char
*
names
)
{
\
if
(
ANALYZER_ASSUME_TRUE
(
v1
op
v2
)
)
\
return
NULL
;
\
else
\
return
:
:
logging
:
:
MakeCheckOpString
(
v1
v2
names
)
;
\
}
DEFINE_CHECK_OP_IMPL
(
EQ
=
=
)
DEFINE_CHECK_OP_IMPL
(
NE
!
=
)
DEFINE_CHECK_OP_IMPL
(
LE
<
=
)
DEFINE_CHECK_OP_IMPL
(
LT
<
)
DEFINE_CHECK_OP_IMPL
(
GE
>
=
)
DEFINE_CHECK_OP_IMPL
(
GT
>
)
#
undef
DEFINE_CHECK_OP_IMPL
#
define
CHECK_EQ
(
val1
val2
)
CHECK_OP
(
EQ
=
=
val1
val2
)
#
define
CHECK_NE
(
val1
val2
)
CHECK_OP
(
NE
!
=
val1
val2
)
#
define
CHECK_LE
(
val1
val2
)
CHECK_OP
(
LE
<
=
val1
val2
)
#
define
CHECK_LT
(
val1
val2
)
CHECK_OP
(
LT
<
val1
val2
)
#
define
CHECK_GE
(
val1
val2
)
CHECK_OP
(
GE
>
=
val1
val2
)
#
define
CHECK_GT
(
val1
val2
)
CHECK_OP
(
GT
>
val1
val2
)
#
if
defined
(
NDEBUG
)
&
&
!
defined
(
DCHECK_ALWAYS_ON
)
#
define
DCHECK_IS_ON
(
)
0
#
else
#
define
DCHECK_IS_ON
(
)
1
#
endif
#
if
DCHECK_IS_ON
(
)
#
define
DLOG_IS_ON
(
severity
)
LOG_IS_ON
(
severity
)
#
define
DLOG_IF
(
severity
condition
)
LOG_IF
(
severity
condition
)
#
define
DLOG_ASSERT
(
condition
)
LOG_ASSERT
(
condition
)
#
define
DPLOG_IF
(
severity
condition
)
PLOG_IF
(
severity
condition
)
#
define
DVLOG_IF
(
verboselevel
condition
)
VLOG_IF
(
verboselevel
condition
)
#
define
DVPLOG_IF
(
verboselevel
condition
)
VPLOG_IF
(
verboselevel
condition
)
#
else
#
define
DLOG_IS_ON
(
severity
)
false
#
define
DLOG_IF
(
severity
condition
)
EAT_STREAM_PARAMETERS
#
define
DLOG_ASSERT
(
condition
)
EAT_STREAM_PARAMETERS
#
define
DPLOG_IF
(
severity
condition
)
EAT_STREAM_PARAMETERS
#
define
DVLOG_IF
(
verboselevel
condition
)
EAT_STREAM_PARAMETERS
#
define
DVPLOG_IF
(
verboselevel
condition
)
EAT_STREAM_PARAMETERS
#
endif
#
define
DLOG
(
severity
)
\
LAZY_STREAM
(
LOG_STREAM
(
severity
)
DLOG_IS_ON
(
severity
)
)
#
define
DPLOG
(
severity
)
\
LAZY_STREAM
(
PLOG_STREAM
(
severity
)
DLOG_IS_ON
(
severity
)
)
#
define
DVLOG
(
verboselevel
)
DVLOG_IF
(
verboselevel
VLOG_IS_ON
(
verboselevel
)
)
#
define
DVPLOG
(
verboselevel
)
DVPLOG_IF
(
verboselevel
VLOG_IS_ON
(
verboselevel
)
)
#
if
DCHECK_IS_ON
(
)
#
if
defined
(
SYZYASAN
)
BASE_EXPORT
extern
LogSeverity
LOG_DCHECK
;
#
else
const
LogSeverity
LOG_DCHECK
=
LOG_FATAL
;
#
endif
#
else
const
LogSeverity
LOG_DCHECK
=
LOG_INFO
;
#
endif
#
if
defined
(
_PREFAST_
)
&
&
defined
(
OS_WIN
)
#
define
DCHECK
(
condition
)
\
__analysis_assume
(
!
!
(
condition
)
)
\
LAZY_STREAM
(
LOG_STREAM
(
DCHECK
)
false
)
\
<
<
"
Check
failed
:
"
#
condition
"
.
"
#
define
DPCHECK
(
condition
)
\
__analysis_assume
(
!
!
(
condition
)
)
\
LAZY_STREAM
(
PLOG_STREAM
(
DCHECK
)
false
)
\
<
<
"
Check
failed
:
"
#
condition
"
.
"
#
else
#
if
DCHECK_IS_ON
(
)
#
define
DCHECK
(
condition
)
\
LAZY_STREAM
(
LOG_STREAM
(
DCHECK
)
!
ANALYZER_ASSUME_TRUE
(
condition
)
)
\
<
<
"
Check
failed
:
"
#
condition
"
.
"
#
define
DPCHECK
(
condition
)
\
LAZY_STREAM
(
PLOG_STREAM
(
DCHECK
)
!
ANALYZER_ASSUME_TRUE
(
condition
)
)
\
<
<
"
Check
failed
:
"
#
condition
"
.
"
#
else
#
define
DCHECK
(
condition
)
EAT_STREAM_PARAMETERS
<
<
!
(
condition
)
#
define
DPCHECK
(
condition
)
EAT_STREAM_PARAMETERS
<
<
!
(
condition
)
#
endif
#
endif
#
if
DCHECK_IS_ON
(
)
#
define
DCHECK_OP
(
name
op
val1
val2
)
\
switch
(
0
)
case
0
:
default
:
\
if
(
:
:
logging
:
:
CheckOpResult
true_if_passed
=
\
DCHECK_IS_ON
(
)
?
\
:
:
logging
:
:
Check
#
#
name
#
#
Impl
(
(
val1
)
(
val2
)
\
#
val1
"
"
#
op
"
"
#
val2
)
:
nullptr
)
\
;
\
else
\
:
:
logging
:
:
LogMessage
(
__FILE__
__LINE__
:
:
logging
:
:
LOG_DCHECK
\
true_if_passed
.
message
(
)
)
.
stream
(
)
#
else
#
define
DCHECK_OP
(
name
op
val1
val2
)
\
EAT_STREAM_PARAMETERS
<
<
(
:
:
logging
:
:
MakeCheckOpValueString
(
\
:
:
logging
:
:
g_swallow_stream
val1
)
\
:
:
logging
:
:
MakeCheckOpValueString
(
\
:
:
logging
:
:
g_swallow_stream
val2
)
\
(
val1
)
op
(
val2
)
)
#
endif
#
define
DCHECK_EQ
(
val1
val2
)
DCHECK_OP
(
EQ
=
=
val1
val2
)
#
define
DCHECK_NE
(
val1
val2
)
DCHECK_OP
(
NE
!
=
val1
val2
)
#
define
DCHECK_LE
(
val1
val2
)
DCHECK_OP
(
LE
<
=
val1
val2
)
#
define
DCHECK_LT
(
val1
val2
)
DCHECK_OP
(
LT
<
val1
val2
)
#
define
DCHECK_GE
(
val1
val2
)
DCHECK_OP
(
GE
>
=
val1
val2
)
#
define
DCHECK_GT
(
val1
val2
)
DCHECK_OP
(
GT
>
val1
val2
)
#
if
!
DCHECK_IS_ON
(
)
&
&
defined
(
OS_CHROMEOS
)
void
LogErrorNotReached
(
const
char
*
file
int
line
)
;
#
define
NOTREACHED
(
)
\
true
?
:
:
logging
:
:
LogErrorNotReached
(
__FILE__
__LINE__
)
\
:
EAT_STREAM_PARAMETERS
#
else
#
define
NOTREACHED
(
)
DCHECK
(
false
)
#
endif
#
undef
assert
#
define
assert
(
x
)
DLOG_ASSERT
(
x
)
class
BASE_EXPORT
LogMessage
{
public
:
LogMessage
(
const
char
*
file
int
line
LogSeverity
severity
)
;
LogMessage
(
const
char
*
file
int
line
const
char
*
condition
)
;
LogMessage
(
const
char
*
file
int
line
std
:
:
string
*
result
)
;
LogMessage
(
const
char
*
file
int
line
LogSeverity
severity
std
:
:
string
*
result
)
;
~
LogMessage
(
)
;
std
:
:
ostream
&
stream
(
)
{
return
stream_
;
}
LogSeverity
severity
(
)
{
return
severity_
;
}
std
:
:
string
str
(
)
{
return
stream_
.
str
(
)
;
}
private
:
void
Init
(
const
char
*
file
int
line
)
;
LogSeverity
severity_
;
std
:
:
ostringstream
stream_
;
size_t
message_start_
;
const
char
*
file_
;
const
int
line_
;
#
if
defined
(
OS_WIN
)
class
SaveLastError
{
public
:
SaveLastError
(
)
;
~
SaveLastError
(
)
;
unsigned
long
get_error
(
)
const
{
return
last_error_
;
}
protected
:
unsigned
long
last_error_
;
}
;
SaveLastError
last_error_
;
#
endif
DISALLOW_COPY_AND_ASSIGN
(
LogMessage
)
;
}
;
class
LogMessageVoidify
{
public
:
LogMessageVoidify
(
)
{
}
void
operator
&
(
std
:
:
ostream
&
)
{
}
}
;
#
if
defined
(
OS_WIN
)
typedef
unsigned
long
SystemErrorCode
;
#
elif
defined
(
OS_POSIX
)
typedef
int
SystemErrorCode
;
#
endif
BASE_EXPORT
SystemErrorCode
GetLastSystemErrorCode
(
)
;
BASE_EXPORT
std
:
:
string
SystemErrorCodeToString
(
SystemErrorCode
error_code
)
;
#
if
defined
(
OS_WIN
)
class
BASE_EXPORT
Win32ErrorLogMessage
{
public
:
Win32ErrorLogMessage
(
const
char
*
file
int
line
LogSeverity
severity
SystemErrorCode
err
)
;
~
Win32ErrorLogMessage
(
)
;
std
:
:
ostream
&
stream
(
)
{
return
log_message_
.
stream
(
)
;
}
private
:
SystemErrorCode
err_
;
LogMessage
log_message_
;
DISALLOW_COPY_AND_ASSIGN
(
Win32ErrorLogMessage
)
;
}
;
#
elif
defined
(
OS_POSIX
)
class
BASE_EXPORT
ErrnoLogMessage
{
public
:
ErrnoLogMessage
(
const
char
*
file
int
line
LogSeverity
severity
SystemErrorCode
err
)
;
~
ErrnoLogMessage
(
)
;
std
:
:
ostream
&
stream
(
)
{
return
log_message_
.
stream
(
)
;
}
private
:
SystemErrorCode
err_
;
LogMessage
log_message_
;
DISALLOW_COPY_AND_ASSIGN
(
ErrnoLogMessage
)
;
}
;
#
endif
BASE_EXPORT
void
CloseLogFile
(
)
;
BASE_EXPORT
void
RawLog
(
int
level
const
char
*
message
)
;
#
define
RAW_LOG
(
level
message
)
\
:
:
logging
:
:
RawLog
(
:
:
logging
:
:
LOG_
#
#
level
message
)
#
define
RAW_CHECK
(
condition
)
\
do
{
\
if
(
!
(
condition
)
)
\
:
:
logging
:
:
RawLog
(
:
:
logging
:
:
LOG_FATAL
\
"
Check
failed
:
"
#
condition
"
\
n
"
)
;
\
}
while
(
0
)
#
if
defined
(
OS_WIN
)
BASE_EXPORT
bool
IsLoggingToFileEnabled
(
)
;
BASE_EXPORT
std
:
:
wstring
GetLogFileFullPath
(
)
;
#
endif
}
namespace
std
{
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
wchar_t
*
wstr
)
;
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
std
:
:
wstring
&
wstr
)
{
return
out
<
<
wstr
.
c_str
(
)
;
}
}
#
ifndef
NOTIMPLEMENTED_POLICY
#
if
defined
(
OS_ANDROID
)
&
&
defined
(
OFFICIAL_BUILD
)
#
define
NOTIMPLEMENTED_POLICY
0
#
else
#
define
NOTIMPLEMENTED_POLICY
4
#
endif
#
endif
#
if
defined
(
COMPILER_GCC
)
#
define
NOTIMPLEMENTED_MSG
"
Not
implemented
reached
in
"
<
<
__PRETTY_FUNCTION__
#
else
#
define
NOTIMPLEMENTED_MSG
"
NOT
IMPLEMENTED
"
#
endif
#
if
NOTIMPLEMENTED_POLICY
=
=
0
#
define
NOTIMPLEMENTED
(
)
EAT_STREAM_PARAMETERS
#
elif
NOTIMPLEMENTED_POLICY
=
=
1
#
define
NOTIMPLEMENTED
(
)
static_assert
(
false
"
NOT_IMPLEMENTED
"
)
#
elif
NOTIMPLEMENTED_POLICY
=
=
2
#
define
NOTIMPLEMENTED
(
)
static_assert
(
false
"
NOT_IMPLEMENTED
"
)
#
elif
NOTIMPLEMENTED_POLICY
=
=
3
#
define
NOTIMPLEMENTED
(
)
NOTREACHED
(
)
#
elif
NOTIMPLEMENTED_POLICY
=
=
4
#
define
NOTIMPLEMENTED
(
)
LOG
(
ERROR
)
<
<
NOTIMPLEMENTED_MSG
#
elif
NOTIMPLEMENTED_POLICY
=
=
5
#
define
NOTIMPLEMENTED
(
)
do
{
\
static
bool
logged_once
=
false
;
\
LOG_IF
(
ERROR
!
logged_once
)
<
<
NOTIMPLEMENTED_MSG
;
\
logged_once
=
true
;
\
}
while
(
0
)
;
\
EAT_STREAM_PARAMETERS
#
endif
#
endif
