#
ifndef
BASE_STL_UTIL_H_
#
define
BASE_STL_UTIL_H_
#
include
<
algorithm
>
#
include
<
deque
>
#
include
<
forward_list
>
#
include
<
functional
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
list
>
#
include
<
map
>
#
include
<
set
>
#
include
<
string
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
vector
>
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
optional
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
Container
typename
Predicate
>
void
IterateAndEraseIf
(
Container
&
container
Predicate
pred
)
{
for
(
auto
it
=
container
.
begin
(
)
;
it
!
=
container
.
end
(
)
;
)
{
if
(
pred
(
*
it
)
)
it
=
container
.
erase
(
it
)
;
else
+
+
it
;
}
}
}
template
<
typename
Container
>
constexpr
auto
size
(
const
Container
&
c
)
-
>
decltype
(
c
.
size
(
)
)
{
return
c
.
size
(
)
;
}
template
<
typename
T
size_t
N
>
constexpr
size_t
size
(
const
T
(
&
array
)
[
N
]
)
noexcept
{
return
N
;
}
template
<
typename
Container
>
constexpr
auto
empty
(
const
Container
&
c
)
-
>
decltype
(
c
.
empty
(
)
)
{
return
c
.
empty
(
)
;
}
template
<
typename
T
size_t
N
>
constexpr
bool
empty
(
const
T
(
&
array
)
[
N
]
)
noexcept
{
return
false
;
}
template
<
typename
T
>
constexpr
bool
empty
(
std
:
:
initializer_list
<
T
>
il
)
noexcept
{
return
il
.
size
(
)
=
=
0
;
}
template
<
typename
Container
>
constexpr
auto
data
(
Container
&
c
)
-
>
decltype
(
c
.
data
(
)
)
{
return
c
.
data
(
)
;
}
template
<
typename
CharT
typename
Traits
typename
Allocator
>
CharT
*
data
(
std
:
:
basic_string
<
CharT
Traits
Allocator
>
&
str
)
{
return
std
:
:
addressof
(
str
[
0
]
)
;
}
template
<
typename
Container
>
constexpr
auto
data
(
const
Container
&
c
)
-
>
decltype
(
c
.
data
(
)
)
{
return
c
.
data
(
)
;
}
template
<
typename
T
size_t
N
>
constexpr
T
*
data
(
T
(
&
array
)
[
N
]
)
noexcept
{
return
array
;
}
template
<
typename
T
>
constexpr
const
T
*
data
(
std
:
:
initializer_list
<
T
>
il
)
noexcept
{
return
il
.
begin
(
)
;
}
template
<
class
A
>
const
typename
A
:
:
container_type
&
GetUnderlyingContainer
(
const
A
&
adapter
)
{
struct
ExposedAdapter
:
A
{
using
A
:
:
c
;
}
;
return
adapter
.
*
&
ExposedAdapter
:
:
c
;
}
template
<
class
T
>
void
STLClearObject
(
T
*
obj
)
{
T
tmp
;
tmp
.
swap
(
*
obj
)
;
obj
-
>
reserve
(
0
)
;
}
template
<
typename
Container
typename
T
>
typename
std
:
:
iterator_traits
<
typename
Container
:
:
const_iterator
>
:
:
difference_type
STLCount
(
const
Container
&
container
const
T
&
val
)
{
return
std
:
:
count
(
container
.
begin
(
)
container
.
end
(
)
val
)
;
}
template
<
typename
Collection
typename
Key
>
bool
ContainsKey
(
const
Collection
&
collection
const
Key
&
key
)
{
return
collection
.
find
(
key
)
!
=
collection
.
end
(
)
;
}
namespace
internal
{
template
<
typename
Collection
>
class
HasKeyType
{
template
<
typename
C
>
static
std
:
:
true_type
test
(
typename
C
:
:
key_type
*
)
;
template
<
typename
C
>
static
std
:
:
false_type
test
(
.
.
.
)
;
public
:
static
constexpr
bool
value
=
decltype
(
test
<
Collection
>
(
nullptr
)
)
:
:
value
;
}
;
}
template
<
typename
Collection
typename
Value
typename
std
:
:
enable_if
<
!
internal
:
:
HasKeyType
<
Collection
>
:
:
value
int
>
:
:
type
=
0
>
bool
ContainsValue
(
const
Collection
&
collection
const
Value
&
value
)
{
return
std
:
:
find
(
std
:
:
begin
(
collection
)
std
:
:
end
(
collection
)
value
)
!
=
std
:
:
end
(
collection
)
;
}
template
<
typename
Container
>
bool
STLIsSorted
(
const
Container
&
cont
)
{
return
std
:
:
is_sorted
(
std
:
:
begin
(
cont
)
std
:
:
end
(
cont
)
)
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetDifference
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
difference
;
std
:
:
set_difference
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
difference
difference
.
end
(
)
)
)
;
return
difference
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetUnion
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
result
;
std
:
:
set_union
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
result
result
.
end
(
)
)
)
;
return
result
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetIntersection
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
result
;
std
:
:
set_intersection
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
result
result
.
end
(
)
)
)
;
return
result
;
}
template
<
typename
Arg1
typename
Arg2
>
bool
STLIncludes
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
return
std
:
:
includes
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
)
;
}
template
<
typename
CharT
typename
Traits
typename
Allocator
typename
Value
>
void
Erase
(
std
:
:
basic_string
<
CharT
Traits
Allocator
>
&
container
const
Value
&
value
)
{
container
.
erase
(
std
:
:
remove
(
container
.
begin
(
)
container
.
end
(
)
value
)
container
.
end
(
)
)
;
}
template
<
typename
CharT
typename
Traits
typename
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
basic_string
<
CharT
Traits
Allocator
>
&
container
Predicate
pred
)
{
container
.
erase
(
std
:
:
remove_if
(
container
.
begin
(
)
container
.
end
(
)
pred
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Value
>
void
Erase
(
std
:
:
deque
<
T
Allocator
>
&
container
const
Value
&
value
)
{
container
.
erase
(
std
:
:
remove
(
container
.
begin
(
)
container
.
end
(
)
value
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
deque
<
T
Allocator
>
&
container
Predicate
pred
)
{
container
.
erase
(
std
:
:
remove_if
(
container
.
begin
(
)
container
.
end
(
)
pred
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Value
>
void
Erase
(
std
:
:
vector
<
T
Allocator
>
&
container
const
Value
&
value
)
{
container
.
erase
(
std
:
:
remove
(
container
.
begin
(
)
container
.
end
(
)
value
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
vector
<
T
Allocator
>
&
container
Predicate
pred
)
{
container
.
erase
(
std
:
:
remove_if
(
container
.
begin
(
)
container
.
end
(
)
pred
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Value
>
void
Erase
(
std
:
:
forward_list
<
T
Allocator
>
&
container
const
Value
&
value
)
{
container
.
remove_if
(
[
&
]
(
const
T
&
cur
)
{
return
cur
=
=
value
;
}
)
;
}
template
<
class
T
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
forward_list
<
T
Allocator
>
&
container
Predicate
pred
)
{
container
.
remove_if
(
pred
)
;
}
template
<
class
T
class
Allocator
class
Value
>
void
Erase
(
std
:
:
list
<
T
Allocator
>
&
container
const
Value
&
value
)
{
container
.
remove_if
(
[
&
]
(
const
T
&
cur
)
{
return
cur
=
=
value
;
}
)
;
}
template
<
class
T
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
list
<
T
Allocator
>
&
container
Predicate
pred
)
{
container
.
remove_if
(
pred
)
;
}
template
<
class
Key
class
T
class
Compare
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
map
<
Key
T
Compare
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
T
class
Compare
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
multimap
<
Key
T
Compare
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
Compare
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
set
<
Key
Compare
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
Compare
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
multiset
<
Key
Compare
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
T
class
Hash
class
KeyEqual
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
unordered_map
<
Key
T
Hash
KeyEqual
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
T
class
Hash
class
KeyEqual
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
unordered_multimap
<
Key
T
Hash
KeyEqual
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
Hash
class
KeyEqual
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
unordered_set
<
Key
Hash
KeyEqual
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
Hash
class
KeyEqual
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
unordered_multiset
<
Key
Hash
KeyEqual
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Collection
>
class
IsNotIn
{
public
:
explicit
IsNotIn
(
const
Collection
&
collection
)
:
i_
(
collection
.
begin
(
)
)
end_
(
collection
.
end
(
)
)
{
}
bool
operator
(
)
(
const
typename
Collection
:
:
value_type
&
x
)
{
while
(
i_
!
=
end_
&
&
*
i_
<
x
)
+
+
i_
;
if
(
i_
=
=
end_
)
return
true
;
if
(
*
i_
=
=
x
)
{
+
+
i_
;
return
false
;
}
return
true
;
}
private
:
typename
Collection
:
:
const_iterator
i_
;
const
typename
Collection
:
:
const_iterator
end_
;
}
;
template
<
class
T
>
T
*
OptionalOrNullptr
(
base
:
:
Optional
<
T
>
&
optional
)
{
return
optional
.
has_value
(
)
?
&
optional
.
value
(
)
:
nullptr
;
}
template
<
class
T
>
const
T
*
OptionalOrNullptr
(
const
base
:
:
Optional
<
T
>
&
optional
)
{
return
optional
.
has_value
(
)
?
&
optional
.
value
(
)
:
nullptr
;
}
}
#
endif
