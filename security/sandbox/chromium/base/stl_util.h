#
ifndef
BASE_STL_UTIL_H_
#
define
BASE_STL_UTIL_H_
#
include
<
algorithm
>
#
include
<
deque
>
#
include
<
forward_list
>
#
include
<
functional
>
#
include
<
iterator
>
#
include
<
list
>
#
include
<
map
>
#
include
<
set
>
#
include
<
string
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
vector
>
#
include
"
base
/
logging
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
Container
typename
Predicate
>
void
IterateAndEraseIf
(
Container
&
container
Predicate
pred
)
{
for
(
auto
it
=
container
.
begin
(
)
;
it
!
=
container
.
end
(
)
;
)
{
if
(
pred
(
*
it
)
)
it
=
container
.
erase
(
it
)
;
else
+
+
it
;
}
}
}
template
<
class
T
>
void
STLClearObject
(
T
*
obj
)
{
T
tmp
;
tmp
.
swap
(
*
obj
)
;
obj
-
>
reserve
(
0
)
;
}
template
<
typename
Container
typename
T
>
typename
std
:
:
iterator_traits
<
typename
Container
:
:
const_iterator
>
:
:
difference_type
STLCount
(
const
Container
&
container
const
T
&
val
)
{
return
std
:
:
count
(
container
.
begin
(
)
container
.
end
(
)
val
)
;
}
inline
char
*
string_as_array
(
std
:
:
string
*
str
)
{
return
str
-
>
empty
(
)
?
NULL
:
&
*
str
-
>
begin
(
)
;
}
template
<
typename
Collection
typename
Key
>
bool
ContainsKey
(
const
Collection
&
collection
const
Key
&
key
)
{
return
collection
.
find
(
key
)
!
=
collection
.
end
(
)
;
}
namespace
internal
{
template
<
typename
Collection
>
class
HasKeyType
{
template
<
typename
C
>
static
std
:
:
true_type
test
(
typename
C
:
:
key_type
*
)
;
template
<
typename
C
>
static
std
:
:
false_type
test
(
.
.
.
)
;
public
:
static
constexpr
bool
value
=
decltype
(
test
<
Collection
>
(
nullptr
)
)
:
:
value
;
}
;
}
template
<
typename
Collection
typename
Value
typename
std
:
:
enable_if
<
!
internal
:
:
HasKeyType
<
Collection
>
:
:
value
int
>
:
:
type
=
0
>
bool
ContainsValue
(
const
Collection
&
collection
const
Value
&
value
)
{
return
std
:
:
find
(
std
:
:
begin
(
collection
)
std
:
:
end
(
collection
)
value
)
!
=
std
:
:
end
(
collection
)
;
}
template
<
typename
Container
>
bool
STLIsSorted
(
const
Container
&
cont
)
{
return
std
:
:
adjacent_find
(
cont
.
rbegin
(
)
cont
.
rend
(
)
std
:
:
less
<
typename
Container
:
:
value_type
>
(
)
)
=
=
cont
.
rend
(
)
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetDifference
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
difference
;
std
:
:
set_difference
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
difference
difference
.
end
(
)
)
)
;
return
difference
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetUnion
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
result
;
std
:
:
set_union
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
result
result
.
end
(
)
)
)
;
return
result
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetIntersection
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
result
;
std
:
:
set_intersection
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
result
result
.
end
(
)
)
)
;
return
result
;
}
template
<
typename
Arg1
typename
Arg2
>
bool
STLIncludes
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
return
std
:
:
includes
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
)
;
}
template
<
typename
CharT
typename
Traits
typename
Allocator
typename
Value
>
void
Erase
(
std
:
:
basic_string
<
CharT
Traits
Allocator
>
&
container
const
Value
&
value
)
{
container
.
erase
(
std
:
:
remove
(
container
.
begin
(
)
container
.
end
(
)
value
)
container
.
end
(
)
)
;
}
template
<
typename
CharT
typename
Traits
typename
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
basic_string
<
CharT
Traits
Allocator
>
&
container
Predicate
pred
)
{
container
.
erase
(
std
:
:
remove_if
(
container
.
begin
(
)
container
.
end
(
)
pred
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Value
>
void
Erase
(
std
:
:
deque
<
T
Allocator
>
&
container
const
Value
&
value
)
{
container
.
erase
(
std
:
:
remove
(
container
.
begin
(
)
container
.
end
(
)
value
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
deque
<
T
Allocator
>
&
container
Predicate
pred
)
{
container
.
erase
(
std
:
:
remove_if
(
container
.
begin
(
)
container
.
end
(
)
pred
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Value
>
void
Erase
(
std
:
:
vector
<
T
Allocator
>
&
container
const
Value
&
value
)
{
container
.
erase
(
std
:
:
remove
(
container
.
begin
(
)
container
.
end
(
)
value
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
vector
<
T
Allocator
>
&
container
Predicate
pred
)
{
container
.
erase
(
std
:
:
remove_if
(
container
.
begin
(
)
container
.
end
(
)
pred
)
container
.
end
(
)
)
;
}
template
<
class
T
class
Allocator
class
Value
>
void
Erase
(
std
:
:
forward_list
<
T
Allocator
>
&
container
const
Value
&
value
)
{
container
.
remove_if
(
[
&
]
(
const
T
&
cur
)
{
return
cur
=
=
value
;
}
)
;
}
template
<
class
T
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
forward_list
<
T
Allocator
>
&
container
Predicate
pred
)
{
container
.
remove_if
(
pred
)
;
}
template
<
class
T
class
Allocator
class
Value
>
void
Erase
(
std
:
:
list
<
T
Allocator
>
&
container
const
Value
&
value
)
{
container
.
remove_if
(
[
&
]
(
const
T
&
cur
)
{
return
cur
=
=
value
;
}
)
;
}
template
<
class
T
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
list
<
T
Allocator
>
&
container
Predicate
pred
)
{
container
.
remove_if
(
pred
)
;
}
template
<
class
Key
class
T
class
Compare
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
map
<
Key
T
Compare
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
T
class
Compare
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
multimap
<
Key
T
Compare
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
Compare
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
set
<
Key
Compare
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
Compare
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
multiset
<
Key
Compare
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
T
class
Hash
class
KeyEqual
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
unordered_map
<
Key
T
Hash
KeyEqual
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
T
class
Hash
class
KeyEqual
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
unordered_multimap
<
Key
T
Hash
KeyEqual
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
Hash
class
KeyEqual
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
unordered_set
<
Key
Hash
KeyEqual
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
template
<
class
Key
class
Hash
class
KeyEqual
class
Allocator
class
Predicate
>
void
EraseIf
(
std
:
:
unordered_multiset
<
Key
Hash
KeyEqual
Allocator
>
&
container
Predicate
pred
)
{
internal
:
:
IterateAndEraseIf
(
container
pred
)
;
}
}
#
endif
