#
ifndef
BASE_STL_UTIL_H_
#
define
BASE_STL_UTIL_H_
#
include
<
algorithm
>
#
include
<
functional
>
#
include
<
iterator
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
base
/
logging
.
h
"
namespace
base
{
template
<
class
T
>
void
STLClearObject
(
T
*
obj
)
{
T
tmp
;
tmp
.
swap
(
*
obj
)
;
obj
-
>
reserve
(
0
)
;
}
template
<
typename
Container
typename
T
>
typename
std
:
:
iterator_traits
<
typename
Container
:
:
const_iterator
>
:
:
difference_type
STLCount
(
const
Container
&
container
const
T
&
val
)
{
return
std
:
:
count
(
container
.
begin
(
)
container
.
end
(
)
val
)
;
}
inline
char
*
string_as_array
(
std
:
:
string
*
str
)
{
return
str
-
>
empty
(
)
?
NULL
:
&
*
str
-
>
begin
(
)
;
}
template
<
class
T
>
void
STLDeleteElements
(
T
*
container
)
{
if
(
!
container
)
return
;
for
(
auto
it
=
container
-
>
begin
(
)
;
it
!
=
container
-
>
end
(
)
;
)
{
auto
temp
=
it
;
+
+
it
;
delete
*
temp
;
}
container
-
>
clear
(
)
;
}
template
<
class
T
>
void
STLDeleteValues
(
T
*
container
)
{
if
(
!
container
)
return
;
for
(
auto
it
=
container
-
>
begin
(
)
;
it
!
=
container
-
>
end
(
)
;
)
{
auto
temp
=
it
;
+
+
it
;
delete
temp
-
>
second
;
}
container
-
>
clear
(
)
;
}
template
<
typename
Collection
typename
Key
>
bool
ContainsKey
(
const
Collection
&
collection
const
Key
&
key
)
{
return
collection
.
find
(
key
)
!
=
collection
.
end
(
)
;
}
template
<
typename
Collection
typename
Value
>
bool
ContainsValue
(
const
Collection
&
collection
const
Value
&
value
)
{
return
std
:
:
find
(
collection
.
begin
(
)
collection
.
end
(
)
value
)
!
=
collection
.
end
(
)
;
}
template
<
typename
Container
>
bool
STLIsSorted
(
const
Container
&
cont
)
{
return
std
:
:
adjacent_find
(
cont
.
rbegin
(
)
cont
.
rend
(
)
std
:
:
less
<
typename
Container
:
:
value_type
>
(
)
)
=
=
cont
.
rend
(
)
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetDifference
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
difference
;
std
:
:
set_difference
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
difference
difference
.
end
(
)
)
)
;
return
difference
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetUnion
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
result
;
std
:
:
set_union
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
result
result
.
end
(
)
)
)
;
return
result
;
}
template
<
typename
ResultType
typename
Arg1
typename
Arg2
>
ResultType
STLSetIntersection
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
ResultType
result
;
std
:
:
set_intersection
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
std
:
:
inserter
(
result
result
.
end
(
)
)
)
;
return
result
;
}
template
<
typename
Arg1
typename
Arg2
>
bool
STLIncludes
(
const
Arg1
&
a1
const
Arg2
&
a2
)
{
DCHECK
(
STLIsSorted
(
a1
)
)
;
DCHECK
(
STLIsSorted
(
a2
)
)
;
return
std
:
:
includes
(
a1
.
begin
(
)
a1
.
end
(
)
a2
.
begin
(
)
a2
.
end
(
)
)
;
}
}
#
endif
