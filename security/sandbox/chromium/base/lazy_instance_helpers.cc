#
include
"
base
/
lazy_instance_helpers
.
h
"
#
include
<
atomic
>
#
include
"
base
/
at_exit
.
h
"
#
include
"
base
/
threading
/
platform_thread
.
h
"
namespace
base
{
namespace
internal
{
bool
NeedsLazyInstance
(
std
:
:
atomic
<
uintptr_t
>
&
state
)
{
uintptr_t
expected
=
0
;
if
(
state
.
compare_exchange_strong
(
expected
kLazyInstanceStateCreating
std
:
:
memory_order_relaxed
std
:
:
memory_order_relaxed
)
)
{
return
true
;
}
if
(
state
.
load
(
std
:
:
memory_order_acquire
)
=
=
kLazyInstanceStateCreating
)
{
const
base
:
:
TimeTicks
start
=
base
:
:
TimeTicks
:
:
Now
(
)
;
do
{
const
base
:
:
TimeDelta
elapsed
=
base
:
:
TimeTicks
:
:
Now
(
)
-
start
;
if
(
elapsed
<
Milliseconds
(
1
)
)
PlatformThread
:
:
YieldCurrentThread
(
)
;
else
PlatformThread
:
:
Sleep
(
Milliseconds
(
1
)
)
;
}
while
(
state
.
load
(
std
:
:
memory_order_acquire
)
=
=
kLazyInstanceStateCreating
)
;
}
return
false
;
}
void
CompleteLazyInstance
(
std
:
:
atomic
<
uintptr_t
>
&
state
uintptr_t
new_instance
void
(
*
destructor
)
(
void
*
)
void
*
destructor_arg
)
{
state
.
store
(
new_instance
std
:
:
memory_order_release
)
;
if
(
new_instance
&
&
destructor
)
AtExitManager
:
:
RegisterCallback
(
destructor
destructor_arg
)
;
}
}
}
