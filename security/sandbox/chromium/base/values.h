#
ifndef
BASE_VALUES_H_
#
define
BASE_VALUES_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
iosfwd
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
containers
/
flat_map
.
h
"
#
include
"
base
/
containers
/
span
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
strings
/
string16
.
h
"
#
include
"
base
/
strings
/
string_piece
.
h
"
#
include
"
base
/
value_iterators
.
h
"
namespace
base
{
class
DictionaryValue
;
class
ListValue
;
class
Value
;
class
BASE_EXPORT
Value
{
public
:
using
BlobStorage
=
std
:
:
vector
<
uint8_t
>
;
using
DictStorage
=
flat_map
<
std
:
:
string
std
:
:
unique_ptr
<
Value
>
>
;
using
ListStorage
=
std
:
:
vector
<
Value
>
;
enum
class
Type
{
NONE
=
0
BOOLEAN
INTEGER
DOUBLE
STRING
BINARY
DICTIONARY
LIST
}
;
static
std
:
:
unique_ptr
<
Value
>
CreateWithCopiedBuffer
(
const
char
*
buffer
size_t
size
)
;
static
Value
FromUniquePtrValue
(
std
:
:
unique_ptr
<
Value
>
val
)
;
static
std
:
:
unique_ptr
<
Value
>
ToUniquePtrValue
(
Value
val
)
;
Value
(
Value
&
&
that
)
noexcept
;
Value
(
)
noexcept
;
Value
Clone
(
)
const
;
explicit
Value
(
Type
type
)
;
explicit
Value
(
bool
in_bool
)
;
explicit
Value
(
int
in_int
)
;
explicit
Value
(
double
in_double
)
;
explicit
Value
(
const
char
*
in_string
)
;
explicit
Value
(
StringPiece
in_string
)
;
explicit
Value
(
std
:
:
string
&
&
in_string
)
noexcept
;
explicit
Value
(
const
char16
*
in_string16
)
;
explicit
Value
(
StringPiece16
in_string16
)
;
explicit
Value
(
const
std
:
:
vector
<
char
>
&
in_blob
)
;
explicit
Value
(
base
:
:
span
<
const
uint8_t
>
in_blob
)
;
explicit
Value
(
BlobStorage
&
&
in_blob
)
noexcept
;
explicit
Value
(
const
DictStorage
&
in_dict
)
;
explicit
Value
(
DictStorage
&
&
in_dict
)
noexcept
;
explicit
Value
(
const
ListStorage
&
in_list
)
;
explicit
Value
(
ListStorage
&
&
in_list
)
noexcept
;
Value
&
operator
=
(
Value
&
&
that
)
noexcept
;
~
Value
(
)
;
static
const
char
*
GetTypeName
(
Type
type
)
;
Type
type
(
)
const
{
return
type_
;
}
bool
is_none
(
)
const
{
return
type
(
)
=
=
Type
:
:
NONE
;
}
bool
is_bool
(
)
const
{
return
type
(
)
=
=
Type
:
:
BOOLEAN
;
}
bool
is_int
(
)
const
{
return
type
(
)
=
=
Type
:
:
INTEGER
;
}
bool
is_double
(
)
const
{
return
type
(
)
=
=
Type
:
:
DOUBLE
;
}
bool
is_string
(
)
const
{
return
type
(
)
=
=
Type
:
:
STRING
;
}
bool
is_blob
(
)
const
{
return
type
(
)
=
=
Type
:
:
BINARY
;
}
bool
is_dict
(
)
const
{
return
type
(
)
=
=
Type
:
:
DICTIONARY
;
}
bool
is_list
(
)
const
{
return
type
(
)
=
=
Type
:
:
LIST
;
}
bool
GetBool
(
)
const
;
int
GetInt
(
)
const
;
double
GetDouble
(
)
const
;
const
std
:
:
string
&
GetString
(
)
const
;
const
BlobStorage
&
GetBlob
(
)
const
;
ListStorage
&
GetList
(
)
;
const
ListStorage
&
GetList
(
)
const
;
Value
*
FindKey
(
StringPiece
key
)
;
const
Value
*
FindKey
(
StringPiece
key
)
const
;
Value
*
FindKeyOfType
(
StringPiece
key
Type
type
)
;
const
Value
*
FindKeyOfType
(
StringPiece
key
Type
type
)
const
;
base
:
:
Optional
<
bool
>
FindBoolKey
(
StringPiece
key
)
const
;
base
:
:
Optional
<
int
>
FindIntKey
(
StringPiece
key
)
const
;
base
:
:
Optional
<
double
>
FindDoubleKey
(
StringPiece
key
)
const
;
const
std
:
:
string
*
FindStringKey
(
StringPiece
key
)
const
;
Value
*
SetKey
(
StringPiece
key
Value
value
)
;
Value
*
SetKey
(
std
:
:
string
&
&
key
Value
value
)
;
Value
*
SetKey
(
const
char
*
key
Value
value
)
;
bool
RemoveKey
(
StringPiece
key
)
;
Value
*
FindPath
(
std
:
:
initializer_list
<
StringPiece
>
path
)
;
Value
*
FindPath
(
span
<
const
StringPiece
>
path
)
;
const
Value
*
FindPath
(
std
:
:
initializer_list
<
StringPiece
>
path
)
const
;
const
Value
*
FindPath
(
span
<
const
StringPiece
>
path
)
const
;
Value
*
FindPathOfType
(
std
:
:
initializer_list
<
StringPiece
>
path
Type
type
)
;
Value
*
FindPathOfType
(
span
<
const
StringPiece
>
path
Type
type
)
;
const
Value
*
FindPathOfType
(
std
:
:
initializer_list
<
StringPiece
>
path
Type
type
)
const
;
const
Value
*
FindPathOfType
(
span
<
const
StringPiece
>
path
Type
type
)
const
;
Value
*
SetPath
(
std
:
:
initializer_list
<
StringPiece
>
path
Value
value
)
;
Value
*
SetPath
(
span
<
const
StringPiece
>
path
Value
value
)
;
bool
RemovePath
(
std
:
:
initializer_list
<
StringPiece
>
path
)
;
bool
RemovePath
(
span
<
const
StringPiece
>
path
)
;
using
dict_iterator_proxy
=
detail
:
:
dict_iterator_proxy
;
using
const_dict_iterator_proxy
=
detail
:
:
const_dict_iterator_proxy
;
dict_iterator_proxy
DictItems
(
)
;
const_dict_iterator_proxy
DictItems
(
)
const
;
size_t
DictSize
(
)
const
;
bool
DictEmpty
(
)
const
;
void
MergeDictionary
(
const
Value
*
dictionary
)
;
bool
GetAsBoolean
(
bool
*
out_value
)
const
;
bool
GetAsInteger
(
int
*
out_value
)
const
;
bool
GetAsDouble
(
double
*
out_value
)
const
;
bool
GetAsString
(
std
:
:
string
*
out_value
)
const
;
bool
GetAsString
(
string16
*
out_value
)
const
;
bool
GetAsString
(
const
Value
*
*
out_value
)
const
;
bool
GetAsString
(
StringPiece
*
out_value
)
const
;
bool
GetAsList
(
ListValue
*
*
out_value
)
;
bool
GetAsList
(
const
ListValue
*
*
out_value
)
const
;
bool
GetAsDictionary
(
DictionaryValue
*
*
out_value
)
;
bool
GetAsDictionary
(
const
DictionaryValue
*
*
out_value
)
const
;
Value
*
DeepCopy
(
)
const
;
std
:
:
unique_ptr
<
Value
>
CreateDeepCopy
(
)
const
;
BASE_EXPORT
friend
bool
operator
=
=
(
const
Value
&
lhs
const
Value
&
rhs
)
;
BASE_EXPORT
friend
bool
operator
!
=
(
const
Value
&
lhs
const
Value
&
rhs
)
;
BASE_EXPORT
friend
bool
operator
<
(
const
Value
&
lhs
const
Value
&
rhs
)
;
BASE_EXPORT
friend
bool
operator
>
(
const
Value
&
lhs
const
Value
&
rhs
)
;
BASE_EXPORT
friend
bool
operator
<
=
(
const
Value
&
lhs
const
Value
&
rhs
)
;
BASE_EXPORT
friend
bool
operator
>
=
(
const
Value
&
lhs
const
Value
&
rhs
)
;
bool
Equals
(
const
Value
*
other
)
const
;
size_t
EstimateMemoryUsage
(
)
const
;
protected
:
static
constexpr
uint16_t
kMagicIsAlive
=
0x2f19
;
union
{
struct
{
Type
type_
:
8
;
uint16_t
is_alive_
=
kMagicIsAlive
;
}
;
struct
{
Type
bool_type_
:
8
;
uint16_t
bool_is_alive_
;
bool
bool_value_
;
}
;
struct
{
Type
int_type_
:
8
;
uint16_t
int_is_alive_
;
int
int_value_
;
}
;
struct
{
Type
double_type_
:
8
;
uint16_t
double_is_alive_
;
double
double_value_
;
}
;
struct
{
Type
string_type_
:
8
;
uint16_t
string_is_alive_
;
std
:
:
string
string_value_
;
}
;
struct
{
Type
binary_type_
:
8
;
uint16_t
binary_is_alive_
;
BlobStorage
binary_value_
;
}
;
struct
{
Type
dict_type_
:
8
;
uint16_t
dict_is_alive_
;
DictStorage
dict_
;
}
;
struct
{
Type
list_type_
:
8
;
uint16_t
list_is_alive_
;
ListStorage
list_
;
}
;
}
;
private
:
friend
class
ValuesTest_SizeOfValue_Test
;
void
InternalMoveConstructFrom
(
Value
&
&
that
)
;
void
InternalCleanup
(
)
;
DISALLOW_COPY_AND_ASSIGN
(
Value
)
;
}
;
class
BASE_EXPORT
DictionaryValue
:
public
Value
{
public
:
using
const_iterator
=
DictStorage
:
:
const_iterator
;
using
iterator
=
DictStorage
:
:
iterator
;
static
std
:
:
unique_ptr
<
DictionaryValue
>
From
(
std
:
:
unique_ptr
<
Value
>
value
)
;
DictionaryValue
(
)
;
explicit
DictionaryValue
(
const
DictStorage
&
in_dict
)
;
explicit
DictionaryValue
(
DictStorage
&
&
in_dict
)
noexcept
;
bool
HasKey
(
StringPiece
key
)
const
;
size_t
size
(
)
const
{
return
dict_
.
size
(
)
;
}
bool
empty
(
)
const
{
return
dict_
.
empty
(
)
;
}
void
Clear
(
)
;
Value
*
Set
(
StringPiece
path
std
:
:
unique_ptr
<
Value
>
in_value
)
;
Value
*
SetBoolean
(
StringPiece
path
bool
in_value
)
;
Value
*
SetInteger
(
StringPiece
path
int
in_value
)
;
Value
*
SetDouble
(
StringPiece
path
double
in_value
)
;
Value
*
SetString
(
StringPiece
path
StringPiece
in_value
)
;
Value
*
SetString
(
StringPiece
path
const
string16
&
in_value
)
;
DictionaryValue
*
SetDictionary
(
StringPiece
path
std
:
:
unique_ptr
<
DictionaryValue
>
in_value
)
;
ListValue
*
SetList
(
StringPiece
path
std
:
:
unique_ptr
<
ListValue
>
in_value
)
;
Value
*
SetWithoutPathExpansion
(
StringPiece
key
std
:
:
unique_ptr
<
Value
>
in_value
)
;
bool
Get
(
StringPiece
path
const
Value
*
*
out_value
)
const
;
bool
Get
(
StringPiece
path
Value
*
*
out_value
)
;
bool
GetBoolean
(
StringPiece
path
bool
*
out_value
)
const
;
bool
GetInteger
(
StringPiece
path
int
*
out_value
)
const
;
bool
GetDouble
(
StringPiece
path
double
*
out_value
)
const
;
bool
GetString
(
StringPiece
path
std
:
:
string
*
out_value
)
const
;
bool
GetString
(
StringPiece
path
string16
*
out_value
)
const
;
bool
GetStringASCII
(
StringPiece
path
std
:
:
string
*
out_value
)
const
;
bool
GetBinary
(
StringPiece
path
const
Value
*
*
out_value
)
const
;
bool
GetBinary
(
StringPiece
path
Value
*
*
out_value
)
;
bool
GetDictionary
(
StringPiece
path
const
DictionaryValue
*
*
out_value
)
const
;
bool
GetDictionary
(
StringPiece
path
DictionaryValue
*
*
out_value
)
;
bool
GetList
(
StringPiece
path
const
ListValue
*
*
out_value
)
const
;
bool
GetList
(
StringPiece
path
ListValue
*
*
out_value
)
;
bool
GetWithoutPathExpansion
(
StringPiece
key
const
Value
*
*
out_value
)
const
;
bool
GetWithoutPathExpansion
(
StringPiece
key
Value
*
*
out_value
)
;
bool
GetBooleanWithoutPathExpansion
(
StringPiece
key
bool
*
out_value
)
const
;
bool
GetIntegerWithoutPathExpansion
(
StringPiece
key
int
*
out_value
)
const
;
bool
GetDoubleWithoutPathExpansion
(
StringPiece
key
double
*
out_value
)
const
;
bool
GetStringWithoutPathExpansion
(
StringPiece
key
std
:
:
string
*
out_value
)
const
;
bool
GetStringWithoutPathExpansion
(
StringPiece
key
string16
*
out_value
)
const
;
bool
GetDictionaryWithoutPathExpansion
(
StringPiece
key
const
DictionaryValue
*
*
out_value
)
const
;
bool
GetDictionaryWithoutPathExpansion
(
StringPiece
key
DictionaryValue
*
*
out_value
)
;
bool
GetListWithoutPathExpansion
(
StringPiece
key
const
ListValue
*
*
out_value
)
const
;
bool
GetListWithoutPathExpansion
(
StringPiece
key
ListValue
*
*
out_value
)
;
bool
Remove
(
StringPiece
path
std
:
:
unique_ptr
<
Value
>
*
out_value
)
;
bool
RemoveWithoutPathExpansion
(
StringPiece
key
std
:
:
unique_ptr
<
Value
>
*
out_value
)
;
bool
RemovePath
(
StringPiece
path
std
:
:
unique_ptr
<
Value
>
*
out_value
)
;
using
Value
:
:
RemovePath
;
std
:
:
unique_ptr
<
DictionaryValue
>
DeepCopyWithoutEmptyChildren
(
)
const
;
void
Swap
(
DictionaryValue
*
other
)
;
class
BASE_EXPORT
Iterator
{
public
:
explicit
Iterator
(
const
DictionaryValue
&
target
)
;
Iterator
(
const
Iterator
&
other
)
;
~
Iterator
(
)
;
bool
IsAtEnd
(
)
const
{
return
it_
=
=
target_
.
dict_
.
end
(
)
;
}
void
Advance
(
)
{
+
+
it_
;
}
const
std
:
:
string
&
key
(
)
const
{
return
it_
-
>
first
;
}
const
Value
&
value
(
)
const
{
return
*
it_
-
>
second
;
}
private
:
const
DictionaryValue
&
target_
;
DictStorage
:
:
const_iterator
it_
;
}
;
iterator
begin
(
)
{
return
dict_
.
begin
(
)
;
}
iterator
end
(
)
{
return
dict_
.
end
(
)
;
}
const_iterator
begin
(
)
const
{
return
dict_
.
begin
(
)
;
}
const_iterator
end
(
)
const
{
return
dict_
.
end
(
)
;
}
DictionaryValue
*
DeepCopy
(
)
const
;
std
:
:
unique_ptr
<
DictionaryValue
>
CreateDeepCopy
(
)
const
;
}
;
class
BASE_EXPORT
ListValue
:
public
Value
{
public
:
using
const_iterator
=
ListStorage
:
:
const_iterator
;
using
iterator
=
ListStorage
:
:
iterator
;
static
std
:
:
unique_ptr
<
ListValue
>
From
(
std
:
:
unique_ptr
<
Value
>
value
)
;
ListValue
(
)
;
explicit
ListValue
(
const
ListStorage
&
in_list
)
;
explicit
ListValue
(
ListStorage
&
&
in_list
)
noexcept
;
void
Clear
(
)
;
size_t
GetSize
(
)
const
{
return
list_
.
size
(
)
;
}
bool
empty
(
)
const
{
return
list_
.
empty
(
)
;
}
void
Reserve
(
size_t
n
)
;
bool
Set
(
size_t
index
std
:
:
unique_ptr
<
Value
>
in_value
)
;
bool
Get
(
size_t
index
const
Value
*
*
out_value
)
const
;
bool
Get
(
size_t
index
Value
*
*
out_value
)
;
bool
GetBoolean
(
size_t
index
bool
*
out_value
)
const
;
bool
GetInteger
(
size_t
index
int
*
out_value
)
const
;
bool
GetDouble
(
size_t
index
double
*
out_value
)
const
;
bool
GetString
(
size_t
index
std
:
:
string
*
out_value
)
const
;
bool
GetString
(
size_t
index
string16
*
out_value
)
const
;
bool
GetDictionary
(
size_t
index
const
DictionaryValue
*
*
out_value
)
const
;
bool
GetDictionary
(
size_t
index
DictionaryValue
*
*
out_value
)
;
using
Value
:
:
GetList
;
bool
GetList
(
size_t
index
const
ListValue
*
*
out_value
)
const
;
bool
GetList
(
size_t
index
ListValue
*
*
out_value
)
;
bool
Remove
(
size_t
index
std
:
:
unique_ptr
<
Value
>
*
out_value
)
;
bool
Remove
(
const
Value
&
value
size_t
*
index
)
;
iterator
Erase
(
iterator
iter
std
:
:
unique_ptr
<
Value
>
*
out_value
)
;
void
Append
(
std
:
:
unique_ptr
<
Value
>
in_value
)
;
void
AppendBoolean
(
bool
in_value
)
;
void
AppendInteger
(
int
in_value
)
;
void
AppendDouble
(
double
in_value
)
;
void
AppendString
(
StringPiece
in_value
)
;
void
AppendString
(
const
string16
&
in_value
)
;
void
AppendStrings
(
const
std
:
:
vector
<
std
:
:
string
>
&
in_values
)
;
void
AppendStrings
(
const
std
:
:
vector
<
string16
>
&
in_values
)
;
bool
AppendIfNotPresent
(
std
:
:
unique_ptr
<
Value
>
in_value
)
;
bool
Insert
(
size_t
index
std
:
:
unique_ptr
<
Value
>
in_value
)
;
const_iterator
Find
(
const
Value
&
value
)
const
;
void
Swap
(
ListValue
*
other
)
;
iterator
begin
(
)
{
return
list_
.
begin
(
)
;
}
iterator
end
(
)
{
return
list_
.
end
(
)
;
}
const_iterator
begin
(
)
const
{
return
list_
.
begin
(
)
;
}
const_iterator
end
(
)
const
{
return
list_
.
end
(
)
;
}
ListValue
*
DeepCopy
(
)
const
;
std
:
:
unique_ptr
<
ListValue
>
CreateDeepCopy
(
)
const
;
}
;
class
BASE_EXPORT
ValueSerializer
{
public
:
virtual
~
ValueSerializer
(
)
;
virtual
bool
Serialize
(
const
Value
&
root
)
=
0
;
}
;
class
BASE_EXPORT
ValueDeserializer
{
public
:
virtual
~
ValueDeserializer
(
)
;
virtual
std
:
:
unique_ptr
<
Value
>
Deserialize
(
int
*
error_code
std
:
:
string
*
error_str
)
=
0
;
}
;
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
Value
&
value
)
;
BASE_EXPORT
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
DictionaryValue
&
value
)
{
return
out
<
<
static_cast
<
const
Value
&
>
(
value
)
;
}
BASE_EXPORT
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
ListValue
&
value
)
{
return
out
<
<
static_cast
<
const
Value
&
>
(
value
)
;
}
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
Value
:
:
Type
&
type
)
;
}
#
endif
