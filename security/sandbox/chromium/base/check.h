#
ifndef
BASE_CHECK_H_
#
define
BASE_CHECK_H_
#
include
<
iosfwd
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
immediate_crash
.
h
"
#
include
"
base
/
location
.
h
"
namespace
logging
{
class
VoidifyStream
{
public
:
VoidifyStream
(
)
=
default
;
explicit
VoidifyStream
(
bool
)
{
}
void
operator
&
(
std
:
:
ostream
&
)
{
}
}
;
#
define
EAT_CHECK_STREAM_PARAMS
(
expr
)
\
true
?
(
void
)
0
\
:
:
:
logging
:
:
VoidifyStream
(
expr
)
&
(
*
:
:
logging
:
:
g_swallow_stream
)
BASE_EXPORT
extern
std
:
:
ostream
*
g_swallow_stream
;
class
LogMessage
;
class
BASE_EXPORT
CheckError
{
public
:
static
CheckError
Check
(
const
char
*
condition
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
CheckOp
(
char
*
log_message_str
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
DCheck
(
const
char
*
condition
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
DCheckOp
(
char
*
log_message_str
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
DumpWillBeCheck
(
const
char
*
condition
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
DumpWillBeCheckOp
(
char
*
log_message_str
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
PCheck
(
const
char
*
condition
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
PCheck
(
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
DPCheck
(
const
char
*
condition
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
DumpWillBeNotReachedNoreturn
(
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
static
CheckError
NotImplemented
(
const
char
*
function
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
std
:
:
ostream
&
stream
(
)
;
NOMERGE
NOINLINE
NOT_TAIL_CALLED
~
CheckError
(
)
;
CheckError
(
const
CheckError
&
)
=
delete
;
CheckError
&
operator
=
(
const
CheckError
&
)
=
delete
;
template
<
typename
T
>
std
:
:
ostream
&
operator
<
<
(
T
&
&
streamed_type
)
{
return
stream
(
)
<
<
streamed_type
;
}
protected
:
explicit
CheckError
(
LogMessage
*
log_message
)
:
log_message_
(
log_message
)
{
}
LogMessage
*
const
log_message_
;
}
;
class
BASE_EXPORT
NotReachedError
:
public
CheckError
{
public
:
static
NotReachedError
NotReached
(
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
NOMERGE
NOINLINE
NOT_TAIL_CALLED
static
void
TriggerNotReached
(
)
;
NOMERGE
NOINLINE
NOT_TAIL_CALLED
~
NotReachedError
(
)
;
private
:
using
CheckError
:
:
CheckError
;
}
;
class
BASE_EXPORT
NotReachedNoreturnError
:
public
CheckError
{
public
:
explicit
NotReachedNoreturnError
(
const
base
:
:
Location
&
location
=
base
:
:
Location
:
:
Current
(
)
)
;
[
[
noreturn
]
]
NOMERGE
NOINLINE
NOT_TAIL_CALLED
~
NotReachedNoreturnError
(
)
;
}
;
#
define
LOGGING_CHECK_FUNCTION_IMPL
(
check_stream
condition
)
\
switch
(
0
)
\
case
0
:
\
default
:
\
/
*
Hint
to
the
optimizer
that
condition
is
unlikely
to
be
false
.
*
/
\
/
*
The
optimizer
can
use
this
as
a
hint
to
place
the
failure
path
*
/
\
/
*
out
-
of
-
line
e
.
g
.
at
the
tail
of
the
function
.
*
/
\
if
(
const
bool
probably_true
=
static_cast
<
bool
>
(
condition
)
;
\
LIKELY
(
ANALYZER_ASSUME_TRUE
(
probably_true
)
)
)
\
;
\
else
\
(
check_stream
)
#
if
defined
(
OFFICIAL_BUILD
)
&
&
!
defined
(
NDEBUG
)
#
error
"
Debug
builds
are
not
expected
to
be
optimized
as
official
builds
.
"
#
endif
#
if
defined
(
OFFICIAL_BUILD
)
&
&
!
DCHECK_IS_ON
(
)
[
[
noreturn
]
]
IMMEDIATE_CRASH_ALWAYS_INLINE
void
CheckFailure
(
)
{
base
:
:
ImmediateCrash
(
)
;
}
#
define
CHECK
(
condition
)
\
UNLIKELY
(
!
(
condition
)
)
?
logging
:
:
CheckFailure
(
)
:
EAT_CHECK_STREAM_PARAMS
(
)
#
define
CHECK_WILL_STREAM
(
)
false
#
define
PCHECK
(
condition
)
\
LOGGING_CHECK_FUNCTION_IMPL
(
:
:
logging
:
:
CheckError
:
:
PCheck
(
)
condition
)
#
else
#
define
CHECK_WILL_STREAM
(
)
true
#
define
CHECK
(
condition
)
\
LOGGING_CHECK_FUNCTION_IMPL
(
:
:
logging
:
:
CheckError
:
:
Check
(
#
condition
)
\
condition
)
#
define
PCHECK
(
condition
)
\
LOGGING_CHECK_FUNCTION_IMPL
(
:
:
logging
:
:
CheckError
:
:
PCheck
(
#
condition
)
\
condition
)
#
endif
#
if
DCHECK_IS_ON
(
)
#
define
DCHECK
(
condition
)
\
LOGGING_CHECK_FUNCTION_IMPL
(
:
:
logging
:
:
CheckError
:
:
DCheck
(
#
condition
)
\
condition
)
#
define
DPCHECK
(
condition
)
\
LOGGING_CHECK_FUNCTION_IMPL
(
:
:
logging
:
:
CheckError
:
:
DPCheck
(
#
condition
)
\
condition
)
#
else
#
define
DCHECK
(
condition
)
EAT_CHECK_STREAM_PARAMS
(
!
(
condition
)
)
#
define
DPCHECK
(
condition
)
EAT_CHECK_STREAM_PARAMS
(
!
(
condition
)
)
#
endif
#
define
DUMP_WILL_BE_CHECK
(
condition
)
\
LOGGING_CHECK_FUNCTION_IMPL
(
\
:
:
logging
:
:
CheckError
:
:
DumpWillBeCheck
(
#
condition
)
condition
)
[
[
noreturn
]
]
BASE_EXPORT
void
RawCheckFailure
(
const
char
*
message
)
;
#
define
RAW_CHECK
(
condition
)
\
do
{
\
if
(
UNLIKELY
(
!
(
condition
)
)
)
{
\
:
:
logging
:
:
RawCheckFailure
(
"
Check
failed
:
"
#
condition
"
\
n
"
)
;
\
}
\
}
while
(
0
)
}
#
endif
