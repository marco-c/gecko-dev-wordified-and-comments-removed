#
ifndef
BASE_CONTAINERS_CONTAINS_H_
#
define
BASE_CONTAINERS_CONTAINS_H_
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
ranges
/
algorithm
.
h
"
#
include
"
base
/
ranges
/
ranges
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
T
typename
SFINAE
=
void
>
struct
HasKeyType
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
HasKeyType
<
T
std
:
:
void_t
<
typename
T
:
:
key_type
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
Container
typename
Value
>
constexpr
auto
ContainsImpl
(
const
Container
&
container
const
Value
&
value
priority_tag
<
2
>
)
-
>
decltype
(
container
.
contains
(
value
)
)
{
return
container
.
contains
(
value
)
;
}
template
<
typename
Container
typename
Value
>
constexpr
auto
ContainsImpl
(
const
Container
&
container
const
Value
&
value
priority_tag
<
1
>
)
-
>
decltype
(
container
.
find
(
value
)
!
=
container
.
end
(
)
)
{
return
container
.
find
(
value
)
!
=
container
.
end
(
)
;
}
template
<
typename
Container
typename
Value
>
constexpr
auto
ContainsImpl
(
const
Container
&
container
const
Value
&
value
priority_tag
<
1
>
)
-
>
decltype
(
container
.
find
(
value
)
!
=
Container
:
:
npos
)
{
return
container
.
find
(
value
)
!
=
Container
:
:
npos
;
}
template
<
typename
Container
typename
Value
>
constexpr
bool
ContainsImpl
(
const
Container
&
container
const
Value
&
value
priority_tag
<
0
>
)
{
static_assert
(
!
HasKeyType
<
Container
>
:
:
value
"
Error
:
About
to
perform
linear
search
on
an
associative
container
.
"
"
Either
use
a
more
generic
comparator
(
e
.
g
.
std
:
:
less
<
>
)
or
if
a
linear
"
"
search
is
desired
provide
an
explicit
projection
parameter
.
"
)
;
return
ranges
:
:
find
(
container
value
)
!
=
ranges
:
:
end
(
container
)
;
}
}
template
<
typename
Container
typename
Value
>
constexpr
bool
Contains
(
const
Container
&
container
const
Value
&
value
)
{
return
internal
:
:
ContainsImpl
(
container
value
internal
:
:
priority_tag
<
2
>
(
)
)
;
}
template
<
typename
Container
typename
Value
typename
Proj
>
constexpr
bool
Contains
(
const
Container
&
container
const
Value
&
value
Proj
proj
)
{
return
ranges
:
:
find
(
container
value
std
:
:
move
(
proj
)
)
!
=
ranges
:
:
end
(
container
)
;
}
}
#
endif
