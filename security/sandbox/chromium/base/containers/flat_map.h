#
ifndef
BASE_CONTAINERS_FLAT_MAP_H_
#
define
BASE_CONTAINERS_FLAT_MAP_H_
#
include
<
functional
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
containers
/
flat_tree
.
h
"
#
include
"
base
/
template_util
.
h
"
namespace
base
{
namespace
internal
{
struct
GetFirst
{
template
<
class
Key
class
Mapped
>
constexpr
const
Key
&
operator
(
)
(
const
std
:
:
pair
<
Key
Mapped
>
&
p
)
const
{
return
p
.
first
;
}
}
;
}
template
<
class
Key
class
Mapped
class
Compare
=
std
:
:
less
<
>
class
Container
=
std
:
:
vector
<
std
:
:
pair
<
Key
Mapped
>
>
>
class
flat_map
:
public
:
:
base
:
:
internal
:
:
flat_tree
<
Key
internal
:
:
GetFirst
Compare
Container
>
{
private
:
using
tree
=
typename
:
:
base
:
:
internal
:
:
flat_tree
<
Key
internal
:
:
GetFirst
Compare
Container
>
;
public
:
using
key_type
=
typename
tree
:
:
key_type
;
using
mapped_type
=
Mapped
;
using
value_type
=
typename
tree
:
:
value_type
;
using
reference
=
typename
Container
:
:
reference
;
using
const_reference
=
typename
Container
:
:
const_reference
;
using
size_type
=
typename
Container
:
:
size_type
;
using
difference_type
=
typename
Container
:
:
difference_type
;
using
iterator
=
typename
tree
:
:
iterator
;
using
const_iterator
=
typename
tree
:
:
const_iterator
;
using
reverse_iterator
=
typename
tree
:
:
reverse_iterator
;
using
const_reverse_iterator
=
typename
tree
:
:
const_reverse_iterator
;
using
container_type
=
typename
tree
:
:
container_type
;
using
tree
:
:
tree
;
using
tree
:
:
operator
=
;
template
<
class
K
>
mapped_type
&
at
(
const
K
&
key
)
;
template
<
class
K
>
const
mapped_type
&
at
(
const
K
&
key
)
const
;
mapped_type
&
operator
[
]
(
const
key_type
&
key
)
;
mapped_type
&
operator
[
]
(
key_type
&
&
key
)
;
template
<
class
K
class
M
>
std
:
:
pair
<
iterator
bool
>
insert_or_assign
(
K
&
&
key
M
&
&
obj
)
;
template
<
class
K
class
M
>
iterator
insert_or_assign
(
const_iterator
hint
K
&
&
key
M
&
&
obj
)
;
template
<
class
K
class
.
.
.
Args
>
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
key_type
K
&
&
>
std
:
:
pair
<
iterator
bool
>
>
try_emplace
(
K
&
&
key
Args
&
&
.
.
.
args
)
;
template
<
class
K
class
.
.
.
Args
>
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
key_type
K
&
&
>
iterator
>
try_emplace
(
const_iterator
hint
K
&
&
key
Args
&
&
.
.
.
args
)
;
void
swap
(
flat_map
&
other
)
noexcept
;
friend
void
swap
(
flat_map
&
lhs
flat_map
&
rhs
)
noexcept
{
lhs
.
swap
(
rhs
)
;
}
}
;
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
template
<
class
K
>
auto
flat_map
<
Key
Mapped
Compare
Container
>
:
:
at
(
const
K
&
key
)
-
>
mapped_type
&
{
iterator
found
=
tree
:
:
find
(
key
)
;
CHECK
(
found
!
=
tree
:
:
end
(
)
)
;
return
found
-
>
second
;
}
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
template
<
class
K
>
auto
flat_map
<
Key
Mapped
Compare
Container
>
:
:
at
(
const
K
&
key
)
const
-
>
const
mapped_type
&
{
const_iterator
found
=
tree
:
:
find
(
key
)
;
CHECK
(
found
!
=
tree
:
:
cend
(
)
)
;
return
found
-
>
second
;
}
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
auto
flat_map
<
Key
Mapped
Compare
Container
>
:
:
operator
[
]
(
const
key_type
&
key
)
-
>
mapped_type
&
{
iterator
found
=
tree
:
:
lower_bound
(
key
)
;
if
(
found
=
=
tree
:
:
end
(
)
|
|
tree
:
:
key_comp
(
)
(
key
found
-
>
first
)
)
found
=
tree
:
:
unsafe_emplace
(
found
key
mapped_type
(
)
)
;
return
found
-
>
second
;
}
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
auto
flat_map
<
Key
Mapped
Compare
Container
>
:
:
operator
[
]
(
key_type
&
&
key
)
-
>
mapped_type
&
{
iterator
found
=
tree
:
:
lower_bound
(
key
)
;
if
(
found
=
=
tree
:
:
end
(
)
|
|
tree
:
:
key_comp
(
)
(
key
found
-
>
first
)
)
found
=
tree
:
:
unsafe_emplace
(
found
std
:
:
move
(
key
)
mapped_type
(
)
)
;
return
found
-
>
second
;
}
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
template
<
class
K
class
M
>
auto
flat_map
<
Key
Mapped
Compare
Container
>
:
:
insert_or_assign
(
K
&
&
key
M
&
&
obj
)
-
>
std
:
:
pair
<
iterator
bool
>
{
auto
result
=
tree
:
:
emplace_key_args
(
key
std
:
:
forward
<
K
>
(
key
)
std
:
:
forward
<
M
>
(
obj
)
)
;
if
(
!
result
.
second
)
result
.
first
-
>
second
=
std
:
:
forward
<
M
>
(
obj
)
;
return
result
;
}
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
template
<
class
K
class
M
>
auto
flat_map
<
Key
Mapped
Compare
Container
>
:
:
insert_or_assign
(
const_iterator
hint
K
&
&
key
M
&
&
obj
)
-
>
iterator
{
auto
result
=
tree
:
:
emplace_hint_key_args
(
hint
key
std
:
:
forward
<
K
>
(
key
)
std
:
:
forward
<
M
>
(
obj
)
)
;
if
(
!
result
.
second
)
result
.
first
-
>
second
=
std
:
:
forward
<
M
>
(
obj
)
;
return
result
.
first
;
}
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
template
<
class
K
class
.
.
.
Args
>
auto
flat_map
<
Key
Mapped
Compare
Container
>
:
:
try_emplace
(
K
&
&
key
Args
&
&
.
.
.
args
)
-
>
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
key_type
K
&
&
>
std
:
:
pair
<
iterator
bool
>
>
{
return
tree
:
:
emplace_key_args
(
key
std
:
:
piecewise_construct
std
:
:
forward_as_tuple
(
std
:
:
forward
<
K
>
(
key
)
)
std
:
:
forward_as_tuple
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
template
<
class
K
class
.
.
.
Args
>
auto
flat_map
<
Key
Mapped
Compare
Container
>
:
:
try_emplace
(
const_iterator
hint
K
&
&
key
Args
&
&
.
.
.
args
)
-
>
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
key_type
K
&
&
>
iterator
>
{
return
tree
:
:
emplace_hint_key_args
(
hint
key
std
:
:
piecewise_construct
std
:
:
forward_as_tuple
(
std
:
:
forward
<
K
>
(
key
)
)
std
:
:
forward_as_tuple
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
.
first
;
}
template
<
class
Key
class
Mapped
class
Compare
class
Container
>
void
flat_map
<
Key
Mapped
Compare
Container
>
:
:
swap
(
flat_map
&
other
)
noexcept
{
tree
:
:
swap
(
other
)
;
}
template
<
class
Key
class
Mapped
class
KeyCompare
=
std
:
:
less
<
>
class
Container
=
std
:
:
vector
<
std
:
:
pair
<
Key
Mapped
>
>
class
InputContainer
class
Projection
=
base
:
:
identity
>
constexpr
flat_map
<
Key
Mapped
KeyCompare
Container
>
MakeFlatMap
(
const
InputContainer
&
unprojected_elements
const
KeyCompare
&
comp
=
KeyCompare
(
)
const
Projection
&
proj
=
Projection
(
)
)
{
Container
elements
;
internal
:
:
ReserveIfSupported
(
elements
unprojected_elements
)
;
base
:
:
ranges
:
:
transform
(
unprojected_elements
std
:
:
back_inserter
(
elements
)
proj
)
;
return
flat_map
<
Key
Mapped
KeyCompare
Container
>
(
std
:
:
move
(
elements
)
comp
)
;
}
template
<
class
Container
class
Compare
=
std
:
:
less
<
>
class
Key
=
typename
std
:
:
decay_t
<
Container
>
:
:
value_type
:
:
first_type
class
Mapped
=
typename
std
:
:
decay_t
<
Container
>
:
:
value_type
:
:
second_type
>
flat_map
(
Container
&
&
Compare
comp
=
{
}
)
-
>
flat_map
<
Key
Mapped
Compare
std
:
:
decay_t
<
Container
>
>
;
}
#
endif
