#
ifndef
BASE_CONTAINERS_BUFFER_ITERATOR_H_
#
define
BASE_CONTAINERS_BUFFER_ITERATOR_H_
#
include
<
type_traits
>
#
include
"
base
/
bit_cast
.
h
"
#
include
"
base
/
containers
/
span
.
h
"
#
include
"
base
/
numerics
/
checked_math
.
h
"
namespace
base
{
template
<
typename
B
>
class
BufferIterator
{
public
:
static_assert
(
std
:
:
is_same
<
std
:
:
remove_const_t
<
B
>
char
>
:
:
value
|
|
std
:
:
is_same
<
std
:
:
remove_const_t
<
B
>
unsigned
char
>
:
:
value
"
Underlying
buffer
type
must
be
char
-
type
.
"
)
;
BufferIterator
(
)
{
}
BufferIterator
(
B
*
data
size_t
size
)
:
BufferIterator
(
make_span
(
data
size
)
)
{
}
explicit
BufferIterator
(
span
<
B
>
buffer
)
:
buffer_
(
buffer
)
remaining_
(
buffer
)
{
}
~
BufferIterator
(
)
{
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if_t
<
std
:
:
is_trivially_copyable
<
T
>
:
:
value
>
>
T
*
MutableObject
(
)
{
size_t
size
=
sizeof
(
T
)
;
size_t
next_position
;
if
(
!
CheckAdd
(
position
(
)
size
)
.
AssignIfValid
(
&
next_position
)
)
return
nullptr
;
if
(
next_position
>
total_size
(
)
)
return
nullptr
;
T
*
t
=
bit_cast
<
T
*
>
(
remaining_
.
data
(
)
)
;
remaining_
=
remaining_
.
subspan
(
size
)
;
return
t
;
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if_t
<
std
:
:
is_trivially_copyable
<
T
>
:
:
value
>
>
const
T
*
Object
(
)
{
return
MutableObject
<
const
T
>
(
)
;
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if_t
<
std
:
:
is_trivially_copyable
<
T
>
:
:
value
>
>
span
<
T
>
MutableSpan
(
size_t
count
)
{
size_t
size
;
if
(
!
CheckMul
(
sizeof
(
T
)
count
)
.
AssignIfValid
(
&
size
)
)
return
span
<
T
>
(
)
;
size_t
next_position
;
if
(
!
CheckAdd
(
position
(
)
size
)
.
AssignIfValid
(
&
next_position
)
)
return
span
<
T
>
(
)
;
if
(
next_position
>
total_size
(
)
)
return
span
<
T
>
(
)
;
auto
result
=
span
<
T
>
(
bit_cast
<
T
*
>
(
remaining_
.
data
(
)
)
count
)
;
remaining_
=
remaining_
.
subspan
(
size
)
;
return
result
;
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if_t
<
std
:
:
is_trivially_copyable
<
T
>
:
:
value
>
>
span
<
const
T
>
Span
(
size_t
count
)
{
return
MutableSpan
<
const
T
>
(
count
)
;
}
void
Seek
(
size_t
to
)
{
remaining_
=
buffer_
.
subspan
(
to
)
;
}
size_t
total_size
(
)
{
return
buffer_
.
size
(
)
;
}
size_t
position
(
)
{
return
buffer_
.
size_bytes
(
)
-
remaining_
.
size_bytes
(
)
;
}
private
:
const
span
<
B
>
buffer_
;
span
<
B
>
remaining_
;
}
;
}
#
endif
