#
ifndef
BASE_CONTAINERS_LINKED_LIST_H_
#
define
BASE_CONTAINERS_LINKED_LIST_H_
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
namespace
base
{
namespace
internal
{
class
BASE_EXPORT
LinkNodeBase
{
public
:
void
RemoveFromList
(
)
;
protected
:
LinkNodeBase
(
)
;
LinkNodeBase
(
LinkNodeBase
*
previous
LinkNodeBase
*
next
)
;
LinkNodeBase
(
LinkNodeBase
&
&
rhs
)
;
LinkNodeBase
(
const
LinkNodeBase
&
)
=
delete
;
~
LinkNodeBase
(
)
=
default
;
LinkNodeBase
&
operator
=
(
const
LinkNodeBase
&
)
=
delete
;
void
InsertBeforeBase
(
LinkNodeBase
*
e
)
;
void
InsertAfterBase
(
LinkNodeBase
*
e
)
;
LinkNodeBase
*
previous_base
(
)
const
{
return
previous_
;
}
LinkNodeBase
*
next_base
(
)
const
{
return
next_
;
}
private
:
RAW_PTR_EXCLUSION
LinkNodeBase
*
previous_
=
nullptr
;
RAW_PTR_EXCLUSION
LinkNodeBase
*
next_
=
nullptr
;
}
;
}
template
<
typename
T
>
class
LinkNode
:
public
internal
:
:
LinkNodeBase
{
public
:
LinkNode
(
)
=
default
;
LinkNode
(
LinkNode
<
T
>
*
previous
LinkNode
<
T
>
*
next
)
:
internal
:
:
LinkNodeBase
(
previous
next
)
{
}
LinkNode
(
LinkNode
<
T
>
&
&
)
=
default
;
LinkNode
(
const
LinkNode
&
)
=
delete
;
LinkNode
&
operator
=
(
const
LinkNode
&
)
=
delete
;
void
InsertBefore
(
LinkNode
<
T
>
*
e
)
{
InsertBeforeBase
(
e
)
;
}
void
InsertAfter
(
LinkNode
<
T
>
*
e
)
{
InsertAfterBase
(
e
)
;
}
LinkNode
<
T
>
*
previous
(
)
const
{
return
static_cast
<
LinkNode
<
T
>
*
>
(
previous_base
(
)
)
;
}
LinkNode
<
T
>
*
next
(
)
const
{
return
static_cast
<
LinkNode
<
T
>
*
>
(
next_base
(
)
)
;
}
const
T
*
value
(
)
const
{
return
static_cast
<
const
T
*
>
(
this
)
;
}
T
*
value
(
)
{
return
static_cast
<
T
*
>
(
this
)
;
}
}
;
template
<
typename
T
>
class
LinkedList
{
public
:
LinkedList
(
)
:
root_
(
&
root_
&
root_
)
{
}
LinkedList
(
const
LinkedList
&
)
=
delete
;
LinkedList
&
operator
=
(
const
LinkedList
&
)
=
delete
;
void
Append
(
LinkNode
<
T
>
*
e
)
{
e
-
>
InsertBefore
(
&
root_
)
;
}
LinkNode
<
T
>
*
head
(
)
const
{
return
root_
.
next
(
)
;
}
LinkNode
<
T
>
*
tail
(
)
const
{
return
root_
.
previous
(
)
;
}
const
LinkNode
<
T
>
*
end
(
)
const
{
return
&
root_
;
}
bool
empty
(
)
const
{
return
head
(
)
=
=
end
(
)
;
}
private
:
LinkNode
<
T
>
root_
;
}
;
}
#
endif
