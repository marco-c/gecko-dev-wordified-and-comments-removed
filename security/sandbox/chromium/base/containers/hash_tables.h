#
ifndef
BASE_CONTAINERS_HASH_TABLES_H_
#
define
BASE_CONTAINERS_HASH_TABLES_H_
#
include
<
cstddef
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
"
base
/
hash
.
h
"
#
define
BASE_HASH_NAMESPACE
base_hash
namespace
BASE_HASH_NAMESPACE
{
template
<
typename
T
>
struct
hash
{
std
:
:
size_t
operator
(
)
(
const
T
&
value
)
const
{
return
std
:
:
hash
<
T
>
(
)
(
value
)
;
}
}
;
template
<
typename
Type1
typename
Type2
>
struct
hash
<
std
:
:
pair
<
Type1
Type2
>
>
{
std
:
:
size_t
operator
(
)
(
std
:
:
pair
<
Type1
Type2
>
value
)
const
{
return
base
:
:
HashInts
(
value
.
first
value
.
second
)
;
}
}
;
}
namespace
base
{
template
<
class
Key
class
T
class
Hash
=
BASE_HASH_NAMESPACE
:
:
hash
<
Key
>
class
Pred
=
std
:
:
equal_to
<
Key
>
class
Alloc
=
std
:
:
allocator
<
std
:
:
pair
<
const
Key
T
>
>
>
using
hash_map
=
std
:
:
unordered_map
<
Key
T
Hash
Pred
Alloc
>
;
template
<
class
Key
class
T
class
Hash
=
BASE_HASH_NAMESPACE
:
:
hash
<
Key
>
class
Pred
=
std
:
:
equal_to
<
Key
>
class
Alloc
=
std
:
:
allocator
<
std
:
:
pair
<
const
Key
T
>
>
>
using
hash_multimap
=
std
:
:
unordered_multimap
<
Key
T
Hash
Pred
Alloc
>
;
template
<
class
Key
class
Hash
=
BASE_HASH_NAMESPACE
:
:
hash
<
Key
>
class
Pred
=
std
:
:
equal_to
<
Key
>
class
Alloc
=
std
:
:
allocator
<
Key
>
>
using
hash_multiset
=
std
:
:
unordered_multiset
<
Key
Hash
Pred
Alloc
>
;
template
<
class
Key
class
Hash
=
BASE_HASH_NAMESPACE
:
:
hash
<
Key
>
class
Pred
=
std
:
:
equal_to
<
Key
>
class
Alloc
=
std
:
:
allocator
<
Key
>
>
using
hash_set
=
std
:
:
unordered_set
<
Key
Hash
Pred
Alloc
>
;
}
#
endif
