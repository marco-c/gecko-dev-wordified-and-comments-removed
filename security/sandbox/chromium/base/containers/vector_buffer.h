#
ifndef
BASE_CONTAINERS_VECTOR_BUFFER_H_
#
define
BASE_CONTAINERS_VECTOR_BUFFER_H_
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
containers
/
util
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
#
include
"
base
/
numerics
/
checked_math
.
h
"
namespace
base
:
:
internal
{
template
<
typename
T
>
class
VectorBuffer
{
public
:
constexpr
VectorBuffer
(
)
=
default
;
#
if
defined
(
__clang__
)
&
&
!
defined
(
__native_client__
)
__attribute__
(
(
no_sanitize
(
"
cfi
-
unrelated
-
cast
"
"
vptr
"
)
)
)
#
endif
VectorBuffer
(
size_t
count
)
:
buffer_
(
reinterpret_cast
<
T
*
>
(
malloc
(
CheckMul
(
sizeof
(
T
)
count
)
.
ValueOrDie
(
)
)
)
)
capacity_
(
count
)
{
}
VectorBuffer
(
VectorBuffer
&
&
other
)
noexcept
:
buffer_
(
other
.
buffer_
)
capacity_
(
other
.
capacity_
)
{
other
.
buffer_
=
nullptr
;
other
.
capacity_
=
0
;
}
VectorBuffer
(
const
VectorBuffer
&
)
=
delete
;
VectorBuffer
&
operator
=
(
const
VectorBuffer
&
)
=
delete
;
~
VectorBuffer
(
)
{
free
(
buffer_
)
;
}
VectorBuffer
&
operator
=
(
VectorBuffer
&
&
other
)
{
free
(
buffer_
)
;
buffer_
=
other
.
buffer_
;
capacity_
=
other
.
capacity_
;
other
.
buffer_
=
nullptr
;
other
.
capacity_
=
0
;
return
*
this
;
}
size_t
capacity
(
)
const
{
return
capacity_
;
}
T
&
operator
[
]
(
size_t
i
)
{
CHECK_LE
(
i
capacity_
)
;
return
buffer_
[
i
]
;
}
const
T
&
operator
[
]
(
size_t
i
)
const
{
CHECK_LE
(
i
capacity_
)
;
return
buffer_
[
i
]
;
}
T
*
begin
(
)
{
return
buffer_
;
}
T
*
end
(
)
{
return
&
buffer_
[
capacity_
]
;
}
template
<
typename
T2
=
T
std
:
:
enable_if_t
<
std
:
:
is_trivially_destructible_v
<
T2
>
int
>
=
0
>
void
DestructRange
(
T
*
begin
T
*
end
)
{
}
template
<
typename
T2
=
T
std
:
:
enable_if_t
<
!
std
:
:
is_trivially_destructible_v
<
T2
>
int
>
=
0
>
void
DestructRange
(
T
*
begin
T
*
end
)
{
CHECK_LE
(
begin
end
)
;
while
(
begin
!
=
end
)
{
begin
-
>
~
T
(
)
;
begin
+
+
;
}
}
template
<
typename
T2
>
static
inline
constexpr
bool
is_trivially_copyable_or_relocatable
=
std
:
:
is_trivially_copyable_v
<
T2
>
|
|
IS_TRIVIALLY_RELOCATABLE
(
T2
)
;
template
<
typename
T2
=
T
std
:
:
enable_if_t
<
is_trivially_copyable_or_relocatable
<
T2
>
int
>
=
0
>
static
void
MoveRange
(
T
*
from_begin
T
*
from_end
T
*
to
)
{
CHECK
(
!
RangesOverlap
(
from_begin
from_end
to
)
)
;
memcpy
(
static_cast
<
void
*
>
(
to
)
from_begin
CheckSub
(
get_uintptr
(
from_end
)
get_uintptr
(
from_begin
)
)
.
ValueOrDie
(
)
)
;
}
template
<
typename
T2
=
T
std
:
:
enable_if_t
<
std
:
:
is_move_constructible_v
<
T2
>
&
&
!
is_trivially_copyable_or_relocatable
<
T2
>
int
>
=
0
>
static
void
MoveRange
(
T
*
from_begin
T
*
from_end
T
*
to
)
{
CHECK
(
!
RangesOverlap
(
from_begin
from_end
to
)
)
;
while
(
from_begin
!
=
from_end
)
{
new
(
to
)
T
(
std
:
:
move
(
*
from_begin
)
)
;
from_begin
-
>
~
T
(
)
;
from_begin
+
+
;
to
+
+
;
}
}
template
<
typename
T2
=
T
std
:
:
enable_if_t
<
!
std
:
:
is_move_constructible_v
<
T2
>
&
&
!
is_trivially_copyable_or_relocatable
<
T2
>
int
>
=
0
>
static
void
MoveRange
(
T
*
from_begin
T
*
from_end
T
*
to
)
{
CHECK
(
!
RangesOverlap
(
from_begin
from_end
to
)
)
;
while
(
from_begin
!
=
from_end
)
{
new
(
to
)
T
(
*
from_begin
)
;
from_begin
-
>
~
T
(
)
;
from_begin
+
+
;
to
+
+
;
}
}
private
:
static
bool
RangesOverlap
(
const
T
*
from_begin
const
T
*
from_end
const
T
*
to
)
{
const
auto
from_begin_uintptr
=
get_uintptr
(
from_begin
)
;
const
auto
from_end_uintptr
=
get_uintptr
(
from_end
)
;
const
auto
to_uintptr
=
get_uintptr
(
to
)
;
return
!
(
to
>
=
from_end
|
|
CheckAdd
(
to_uintptr
CheckSub
(
from_end_uintptr
from_begin_uintptr
)
)
.
ValueOrDie
(
)
<
=
from_begin_uintptr
)
;
}
RAW_PTR_EXCLUSION
T
*
buffer_
=
nullptr
;
size_t
capacity_
=
0
;
}
;
}
#
endif
