#
ifndef
BASE_AT_EXIT_H_
#
define
BASE_AT_EXIT_H_
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
containers
/
stack
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
functional
/
callback
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
include
"
base
/
thread_annotations
.
h
"
namespace
base
{
class
BASE_EXPORT
AtExitManager
{
public
:
typedef
void
(
*
AtExitCallbackType
)
(
void
*
)
;
AtExitManager
(
)
;
AtExitManager
(
const
AtExitManager
&
)
=
delete
;
AtExitManager
&
operator
=
(
const
AtExitManager
&
)
=
delete
;
~
AtExitManager
(
)
;
static
void
RegisterCallback
(
AtExitCallbackType
func
void
*
param
)
;
static
void
RegisterTask
(
base
:
:
OnceClosure
task
)
;
static
void
ProcessCallbacksNow
(
)
;
static
void
DisableAllAtExitManagers
(
)
;
protected
:
explicit
AtExitManager
(
bool
shadow
)
;
private
:
base
:
:
Lock
lock_
;
base
:
:
stack
<
base
:
:
OnceClosure
>
stack_
GUARDED_BY
(
lock_
)
;
#
if
DCHECK_IS_ON
(
)
bool
processing_callbacks_
GUARDED_BY
(
lock_
)
=
false
;
#
endif
const
raw_ptr
<
AtExitManager
DanglingUntriaged
>
next_manager_
;
}
;
#
if
defined
(
UNIT_TEST
)
class
ShadowingAtExitManager
:
public
AtExitManager
{
public
:
ShadowingAtExitManager
(
)
:
AtExitManager
(
true
)
{
}
}
;
#
endif
}
#
endif
