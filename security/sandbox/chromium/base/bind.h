#
ifndef
BASE_BIND_H_
#
define
BASE_BIND_H_
#
include
"
base
/
bind_internal
.
h
"
namespace
base
{
template
<
typename
Functor
typename
.
.
.
Args
>
inline
OnceCallback
<
MakeUnboundRunType
<
Functor
Args
.
.
.
>
>
BindOnce
(
Functor
&
&
functor
Args
&
&
.
.
.
args
)
{
using
BindState
=
internal
:
:
MakeBindStateType
<
Functor
Args
.
.
.
>
;
using
UnboundRunType
=
MakeUnboundRunType
<
Functor
Args
.
.
.
>
;
using
Invoker
=
internal
:
:
Invoker
<
BindState
UnboundRunType
>
;
using
CallbackType
=
OnceCallback
<
UnboundRunType
>
;
using
PolymorphicInvoke
=
typename
CallbackType
:
:
PolymorphicInvoke
;
PolymorphicInvoke
invoke_func
=
&
Invoker
:
:
RunOnce
;
using
InvokeFuncStorage
=
internal
:
:
BindStateBase
:
:
InvokeFuncStorage
;
return
CallbackType
(
new
BindState
(
reinterpret_cast
<
InvokeFuncStorage
>
(
invoke_func
)
std
:
:
forward
<
Functor
>
(
functor
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
typename
Functor
typename
.
.
.
Args
>
inline
RepeatingCallback
<
MakeUnboundRunType
<
Functor
Args
.
.
.
>
>
BindRepeating
(
Functor
&
&
functor
Args
&
&
.
.
.
args
)
{
using
BindState
=
internal
:
:
MakeBindStateType
<
Functor
Args
.
.
.
>
;
using
UnboundRunType
=
MakeUnboundRunType
<
Functor
Args
.
.
.
>
;
using
Invoker
=
internal
:
:
Invoker
<
BindState
UnboundRunType
>
;
using
CallbackType
=
RepeatingCallback
<
UnboundRunType
>
;
using
PolymorphicInvoke
=
typename
CallbackType
:
:
PolymorphicInvoke
;
PolymorphicInvoke
invoke_func
=
&
Invoker
:
:
Run
;
using
InvokeFuncStorage
=
internal
:
:
BindStateBase
:
:
InvokeFuncStorage
;
return
CallbackType
(
new
BindState
(
reinterpret_cast
<
InvokeFuncStorage
>
(
invoke_func
)
std
:
:
forward
<
Functor
>
(
functor
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
typename
Functor
typename
.
.
.
Args
>
inline
Callback
<
MakeUnboundRunType
<
Functor
Args
.
.
.
>
>
Bind
(
Functor
&
&
functor
Args
&
&
.
.
.
args
)
{
return
BindRepeating
(
std
:
:
forward
<
Functor
>
(
functor
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
#
endif
