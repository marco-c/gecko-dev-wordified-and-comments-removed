#
ifndef
BASE_BIND_H_
#
define
BASE_BIND_H_
#
include
"
base
/
bind_internal
.
h
"
#
include
"
base
/
callback_internal
.
h
"
namespace
base
{
template
<
typename
Functor
typename
.
.
.
Args
>
base
:
:
Callback
<
typename
internal
:
:
BindState
<
typename
internal
:
:
FunctorTraits
<
Functor
>
:
:
RunnableType
typename
internal
:
:
FunctorTraits
<
Functor
>
:
:
RunType
typename
internal
:
:
CallbackParamTraits
<
Args
>
:
:
StorageType
.
.
.
>
:
:
UnboundRunType
>
Bind
(
Functor
functor
const
Args
&
.
.
.
args
)
{
using
RunnableType
=
typename
internal
:
:
FunctorTraits
<
Functor
>
:
:
RunnableType
;
using
RunType
=
typename
internal
:
:
FunctorTraits
<
Functor
>
:
:
RunType
;
using
BoundRunType
=
typename
RunnableType
:
:
RunType
;
using
BoundArgs
=
internal
:
:
TakeTypeListItem
<
sizeof
.
.
.
(
Args
)
internal
:
:
ExtractArgs
<
BoundRunType
>
>
;
static_assert
(
!
internal
:
:
HasNonConstReferenceItem
<
BoundArgs
>
:
:
value
"
do
not
bind
functions
with
nonconst
ref
"
)
;
const
bool
is_method
=
internal
:
:
HasIsMethodTag
<
RunnableType
>
:
:
value
;
static_assert
(
!
internal
:
:
BindsArrayToFirstArg
<
is_method
Args
.
.
.
>
:
:
value
"
first
bound
argument
to
method
cannot
be
array
"
)
;
static_assert
(
!
internal
:
:
HasRefCountedParamAsRawPtr
<
is_method
Args
.
.
.
>
:
:
value
"
a
parameter
is
a
refcounted
type
and
needs
scoped_refptr
"
)
;
using
BindState
=
internal
:
:
BindState
<
RunnableType
RunType
typename
internal
:
:
CallbackParamTraits
<
Args
>
:
:
StorageType
.
.
.
>
;
return
Callback
<
typename
BindState
:
:
UnboundRunType
>
(
new
BindState
(
internal
:
:
MakeRunnable
(
functor
)
args
.
.
.
)
)
;
}
}
#
endif
