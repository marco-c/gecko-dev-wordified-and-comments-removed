#
ifndef
BASE_TUPLE_H_
#
define
BASE_TUPLE_H_
#
include
<
stddef
.
h
>
#
include
"
base
/
bind_helpers
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
template
<
size_t
.
.
.
>
struct
IndexSequence
{
}
;
template
<
size_t
.
.
.
Ns
>
struct
MakeIndexSequenceImpl
;
#
if
defined
(
_PREFAST_
)
&
&
defined
(
OS_WIN
)
template
<
>
struct
MakeIndexSequenceImpl
<
0
>
{
using
Type
=
IndexSequence
<
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
1
>
{
using
Type
=
IndexSequence
<
0
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
2
>
{
using
Type
=
IndexSequence
<
0
1
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
3
>
{
using
Type
=
IndexSequence
<
0
1
2
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
4
>
{
using
Type
=
IndexSequence
<
0
1
2
3
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
5
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
6
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
5
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
7
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
5
6
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
8
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
5
6
7
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
9
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
5
6
7
8
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
10
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
5
6
7
8
9
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
11
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
5
6
7
8
9
10
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
12
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
5
6
7
8
9
10
11
>
;
}
;
template
<
>
struct
MakeIndexSequenceImpl
<
13
>
{
using
Type
=
IndexSequence
<
0
1
2
3
4
5
6
7
8
9
10
11
12
>
;
}
;
#
else
template
<
size_t
.
.
.
Ns
>
struct
MakeIndexSequenceImpl
<
0
Ns
.
.
.
>
{
using
Type
=
IndexSequence
<
Ns
.
.
.
>
;
}
;
template
<
size_t
N
size_t
.
.
.
Ns
>
struct
MakeIndexSequenceImpl
<
N
Ns
.
.
.
>
:
MakeIndexSequenceImpl
<
N
-
1
N
-
1
Ns
.
.
.
>
{
}
;
#
endif
template
<
size_t
N
>
using
MakeIndexSequence
=
typename
MakeIndexSequenceImpl
<
N
>
:
:
Type
;
template
<
class
P
>
struct
TupleTraits
{
typedef
P
ValueType
;
typedef
P
&
RefType
;
typedef
const
P
&
ParamType
;
}
;
template
<
class
P
>
struct
TupleTraits
<
P
&
>
{
typedef
P
ValueType
;
typedef
P
&
RefType
;
typedef
P
&
ParamType
;
}
;
template
<
typename
IxSeq
typename
.
.
.
Ts
>
struct
TupleBaseImpl
;
template
<
typename
.
.
.
Ts
>
using
TupleBase
=
TupleBaseImpl
<
MakeIndexSequence
<
sizeof
.
.
.
(
Ts
)
>
Ts
.
.
.
>
;
template
<
size_t
N
typename
T
>
struct
TupleLeaf
;
template
<
typename
.
.
.
Ts
>
struct
Tuple
final
:
TupleBase
<
Ts
.
.
.
>
{
Tuple
(
)
:
TupleBase
<
Ts
.
.
.
>
(
)
{
}
explicit
Tuple
(
typename
TupleTraits
<
Ts
>
:
:
ParamType
.
.
.
args
)
:
TupleBase
<
Ts
.
.
.
>
(
args
.
.
.
)
{
}
}
;
template
<
>
struct
Tuple
<
>
final
{
}
;
template
<
size_t
.
.
.
Ns
typename
.
.
.
Ts
>
struct
TupleBaseImpl
<
IndexSequence
<
Ns
.
.
.
>
Ts
.
.
.
>
:
TupleLeaf
<
Ns
Ts
>
.
.
.
{
TupleBaseImpl
(
)
:
TupleLeaf
<
Ns
Ts
>
(
)
.
.
.
{
}
explicit
TupleBaseImpl
(
typename
TupleTraits
<
Ts
>
:
:
ParamType
.
.
.
args
)
:
TupleLeaf
<
Ns
Ts
>
(
args
)
.
.
.
{
}
}
;
template
<
size_t
N
typename
T
>
struct
TupleLeaf
{
TupleLeaf
(
)
{
}
explicit
TupleLeaf
(
typename
TupleTraits
<
T
>
:
:
ParamType
x
)
:
x
(
x
)
{
}
T
&
get
(
)
{
return
x
;
}
const
T
&
get
(
)
const
{
return
x
;
}
T
x
;
}
;
template
<
size_t
I
typename
T
>
T
&
get
(
TupleLeaf
<
I
T
>
&
leaf
)
{
return
leaf
.
get
(
)
;
}
template
<
size_t
I
typename
T
>
const
T
&
get
(
const
TupleLeaf
<
I
T
>
&
leaf
)
{
return
leaf
.
get
(
)
;
}
template
<
typename
T
>
struct
TupleTypes
;
template
<
typename
.
.
.
Ts
>
struct
TupleTypes
<
Tuple
<
Ts
.
.
.
>
>
{
using
ValueTuple
=
Tuple
<
typename
TupleTraits
<
Ts
>
:
:
ValueType
.
.
.
>
;
using
RefTuple
=
Tuple
<
typename
TupleTraits
<
Ts
>
:
:
RefType
.
.
.
>
;
using
ParamTuple
=
Tuple
<
typename
TupleTraits
<
Ts
>
:
:
ParamType
.
.
.
>
;
}
;
template
<
typename
.
.
.
Ts
>
inline
Tuple
<
Ts
.
.
.
>
MakeTuple
(
const
Ts
&
.
.
.
arg
)
{
return
Tuple
<
Ts
.
.
.
>
(
arg
.
.
.
)
;
}
template
<
typename
.
.
.
Ts
>
inline
Tuple
<
Ts
&
.
.
.
>
MakeRefTuple
(
Ts
&
.
.
.
arg
)
{
return
Tuple
<
Ts
&
.
.
.
>
(
arg
.
.
.
)
;
}
template
<
typename
ObjT
typename
Method
typename
.
.
.
Ts
size_t
.
.
.
Ns
>
inline
void
DispatchToMethodImpl
(
ObjT
*
obj
Method
method
const
Tuple
<
Ts
.
.
.
>
&
arg
IndexSequence
<
Ns
.
.
.
>
)
{
(
obj
-
>
*
method
)
(
base
:
:
internal
:
:
UnwrapTraits
<
Ts
>
:
:
Unwrap
(
get
<
Ns
>
(
arg
)
)
.
.
.
)
;
}
template
<
typename
ObjT
typename
Method
typename
.
.
.
Ts
>
inline
void
DispatchToMethod
(
ObjT
*
obj
Method
method
const
Tuple
<
Ts
.
.
.
>
&
arg
)
{
DispatchToMethodImpl
(
obj
method
arg
MakeIndexSequence
<
sizeof
.
.
.
(
Ts
)
>
(
)
)
;
}
template
<
typename
Function
typename
.
.
.
Ts
size_t
.
.
.
Ns
>
inline
void
DispatchToFunctionImpl
(
Function
function
const
Tuple
<
Ts
.
.
.
>
&
arg
IndexSequence
<
Ns
.
.
.
>
)
{
(
*
function
)
(
base
:
:
internal
:
:
UnwrapTraits
<
Ts
>
:
:
Unwrap
(
get
<
Ns
>
(
arg
)
)
.
.
.
)
;
}
template
<
typename
Function
typename
.
.
.
Ts
>
inline
void
DispatchToFunction
(
Function
function
const
Tuple
<
Ts
.
.
.
>
&
arg
)
{
DispatchToFunctionImpl
(
function
arg
MakeIndexSequence
<
sizeof
.
.
.
(
Ts
)
>
(
)
)
;
}
template
<
typename
ObjT
typename
Method
typename
.
.
.
InTs
typename
.
.
.
OutTs
size_t
.
.
.
InNs
size_t
.
.
.
OutNs
>
inline
void
DispatchToMethodImpl
(
ObjT
*
obj
Method
method
const
Tuple
<
InTs
.
.
.
>
&
in
Tuple
<
OutTs
.
.
.
>
*
out
IndexSequence
<
InNs
.
.
.
>
IndexSequence
<
OutNs
.
.
.
>
)
{
(
obj
-
>
*
method
)
(
base
:
:
internal
:
:
UnwrapTraits
<
InTs
>
:
:
Unwrap
(
get
<
InNs
>
(
in
)
)
.
.
.
&
get
<
OutNs
>
(
*
out
)
.
.
.
)
;
}
template
<
typename
ObjT
typename
Method
typename
.
.
.
InTs
typename
.
.
.
OutTs
>
inline
void
DispatchToMethod
(
ObjT
*
obj
Method
method
const
Tuple
<
InTs
.
.
.
>
&
in
Tuple
<
OutTs
.
.
.
>
*
out
)
{
DispatchToMethodImpl
(
obj
method
in
out
MakeIndexSequence
<
sizeof
.
.
.
(
InTs
)
>
(
)
MakeIndexSequence
<
sizeof
.
.
.
(
OutTs
)
>
(
)
)
;
}
}
#
endif
