#
ifndef
BASE_CALLBACK_INTERNAL_H_
#
define
BASE_CALLBACK_INTERNAL_H_
#
include
<
stddef
.
h
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
"
base
/
atomic_ref_count
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
memory
/
ref_counted
.
h
"
#
include
"
base
/
memory
/
scoped_ptr
.
h
"
#
include
"
base
/
template_util
.
h
"
namespace
base
{
namespace
internal
{
class
CallbackBase
;
class
BindStateBase
{
protected
:
explicit
BindStateBase
(
void
(
*
destructor
)
(
BindStateBase
*
)
)
:
ref_count_
(
0
)
destructor_
(
destructor
)
{
}
~
BindStateBase
(
)
=
default
;
private
:
friend
class
scoped_refptr
<
BindStateBase
>
;
friend
class
CallbackBase
;
void
AddRef
(
)
;
void
Release
(
)
;
AtomicRefCount
ref_count_
;
void
(
*
destructor_
)
(
BindStateBase
*
)
;
DISALLOW_COPY_AND_ASSIGN
(
BindStateBase
)
;
}
;
class
BASE_EXPORT
CallbackBase
{
public
:
CallbackBase
(
const
CallbackBase
&
c
)
;
CallbackBase
&
operator
=
(
const
CallbackBase
&
c
)
;
bool
is_null
(
)
const
{
return
bind_state_
.
get
(
)
=
=
NULL
;
}
void
Reset
(
)
;
protected
:
using
InvokeFuncStorage
=
void
(
*
)
(
)
;
bool
Equals
(
const
CallbackBase
&
other
)
const
;
explicit
CallbackBase
(
BindStateBase
*
bind_state
)
;
~
CallbackBase
(
)
;
scoped_refptr
<
BindStateBase
>
bind_state_
;
InvokeFuncStorage
polymorphic_invoke_
;
}
;
template
<
typename
T
>
struct
IsMoveOnlyType
{
template
<
typename
U
>
static
YesType
Test
(
const
typename
U
:
:
MoveOnlyTypeForCPP03
*
)
;
template
<
typename
U
>
static
NoType
Test
(
.
.
.
)
;
static
const
bool
value
=
sizeof
(
(
Test
<
T
>
(
0
)
)
)
=
=
sizeof
(
YesType
)
&
&
!
is_const
<
T
>
:
:
value
;
}
;
template
<
typename
T
>
struct
IsMoveOnlyType
<
std
:
:
unique_ptr
<
T
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
>
struct
CallbackParamTraitsForMoveOnlyType
;
template
<
typename
>
struct
CallbackParamTraitsForNonMoveOnlyType
;
template
<
typename
T
>
struct
CallbackParamTraits
:
std
:
:
conditional
<
IsMoveOnlyType
<
T
>
:
:
value
CallbackParamTraitsForMoveOnlyType
<
T
>
CallbackParamTraitsForNonMoveOnlyType
<
T
>
>
:
:
type
{
}
;
template
<
typename
T
>
struct
CallbackParamTraitsForNonMoveOnlyType
{
using
ForwardType
=
const
T
&
;
using
StorageType
=
T
;
}
;
template
<
typename
T
>
struct
CallbackParamTraitsForNonMoveOnlyType
<
T
&
>
{
using
ForwardType
=
T
&
;
using
StorageType
=
T
;
}
;
template
<
typename
T
size_t
n
>
struct
CallbackParamTraitsForNonMoveOnlyType
<
T
[
n
]
>
{
using
ForwardType
=
const
T
*
;
using
StorageType
=
const
T
*
;
}
;
template
<
typename
T
>
struct
CallbackParamTraitsForNonMoveOnlyType
<
T
[
]
>
{
using
ForwardType
=
const
T
*
;
using
StorageType
=
const
T
*
;
}
;
template
<
typename
T
>
struct
CallbackParamTraitsForMoveOnlyType
{
using
ForwardType
=
T
;
using
StorageType
=
T
;
}
;
template
<
typename
T
>
typename
std
:
:
enable_if
<
!
IsMoveOnlyType
<
T
>
:
:
value
T
>
:
:
type
&
CallbackForward
(
T
&
t
)
{
return
t
;
}
template
<
typename
T
>
typename
std
:
:
enable_if
<
IsMoveOnlyType
<
T
>
:
:
value
T
>
:
:
type
CallbackForward
(
T
&
t
)
{
return
std
:
:
move
(
t
)
;
}
}
}
#
endif
