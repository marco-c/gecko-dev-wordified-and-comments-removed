#
ifndef
BASE_MEMORY_REF_COUNTED_H_
#
define
BASE_MEMORY_REF_COUNTED_H_
#
include
<
stddef
.
h
>
#
include
<
limits
>
#
include
<
utility
>
#
include
"
base
/
atomic_ref_count
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
memory
/
scoped_refptr
.
h
"
#
include
"
base
/
sequence_checker
.
h
"
#
include
"
base
/
template_util
.
h
"
#
include
"
base
/
threading
/
thread_collision_warner
.
h
"
#
include
"
build
/
build_config
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
utility
/
utility
.
h
"
namespace
base
{
namespace
subtle
{
class
BASE_EXPORT
RefCountedBase
{
public
:
RefCountedBase
(
const
RefCountedBase
&
)
=
delete
;
RefCountedBase
&
operator
=
(
const
RefCountedBase
&
)
=
delete
;
bool
HasOneRef
(
)
const
{
return
ref_count_
=
=
1
;
}
bool
HasAtLeastOneRef
(
)
const
{
return
ref_count_
>
=
1
;
}
protected
:
explicit
RefCountedBase
(
StartRefCountFromZeroTag
)
{
#
if
DCHECK_IS_ON
(
)
sequence_checker_
.
DetachFromSequence
(
)
;
#
endif
}
explicit
RefCountedBase
(
StartRefCountFromOneTag
)
:
ref_count_
(
1
)
{
#
if
DCHECK_IS_ON
(
)
needs_adopt_ref_
=
true
;
sequence_checker_
.
DetachFromSequence
(
)
;
#
endif
}
~
RefCountedBase
(
)
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
in_dtor_
)
;
#
endif
}
void
AddRef
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
needs_adopt_ref_
)
;
if
(
ref_count_
>
=
1
)
{
DCHECK
(
CalledOnValidSequence
(
)
)
;
}
#
endif
AddRefImpl
(
)
;
}
bool
Release
(
)
const
{
ReleaseImpl
(
)
;
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
if
(
ref_count_
=
=
0
)
{
in_dtor_
=
true
;
}
if
(
ref_count_
>
=
1
)
{
DCHECK
(
CalledOnValidSequence
(
)
)
;
}
if
(
ref_count_
=
=
1
)
{
sequence_checker_
.
DetachFromSequence
(
)
;
}
#
endif
return
ref_count_
=
=
0
;
}
bool
IsOnValidSequence
(
)
const
{
#
if
DCHECK_IS_ON
(
)
return
ref_count_
<
=
1
|
|
CalledOnValidSequence
(
)
;
#
else
return
true
;
#
endif
}
private
:
template
<
typename
U
>
friend
scoped_refptr
<
U
>
base
:
:
AdoptRef
(
U
*
)
;
friend
class
RefCountedOverflowTest
;
void
Adopted
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
needs_adopt_ref_
)
;
needs_adopt_ref_
=
false
;
#
endif
}
#
if
defined
(
ARCH_CPU_64_BITS
)
void
AddRefImpl
(
)
const
;
void
ReleaseImpl
(
)
const
;
#
else
void
AddRefImpl
(
)
const
{
+
+
ref_count_
;
}
void
ReleaseImpl
(
)
const
{
-
-
ref_count_
;
}
#
endif
#
if
DCHECK_IS_ON
(
)
bool
CalledOnValidSequence
(
)
const
;
#
endif
mutable
uint32_t
ref_count_
=
0
;
static_assert
(
std
:
:
is_unsigned_v
<
decltype
(
ref_count_
)
>
"
ref_count_
must
be
an
unsigned
type
.
"
)
;
#
if
DCHECK_IS_ON
(
)
mutable
bool
needs_adopt_ref_
=
false
;
mutable
bool
in_dtor_
=
false
;
mutable
SequenceChecker
sequence_checker_
;
#
endif
DFAKE_MUTEX
(
add_release_
)
;
}
;
class
BASE_EXPORT
RefCountedThreadSafeBase
{
public
:
RefCountedThreadSafeBase
(
const
RefCountedThreadSafeBase
&
)
=
delete
;
RefCountedThreadSafeBase
&
operator
=
(
const
RefCountedThreadSafeBase
&
)
=
delete
;
bool
HasOneRef
(
)
const
;
bool
HasAtLeastOneRef
(
)
const
;
protected
:
explicit
constexpr
RefCountedThreadSafeBase
(
StartRefCountFromZeroTag
)
{
}
explicit
constexpr
RefCountedThreadSafeBase
(
StartRefCountFromOneTag
)
:
ref_count_
(
1
)
{
#
if
DCHECK_IS_ON
(
)
needs_adopt_ref_
=
true
;
#
endif
}
#
if
DCHECK_IS_ON
(
)
~
RefCountedThreadSafeBase
(
)
;
#
else
~
RefCountedThreadSafeBase
(
)
=
default
;
#
endif
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
|
|
defined
(
__ARM_FEATURE_ATOMICS
)
bool
Release
(
)
const
{
return
ReleaseImpl
(
)
;
}
void
AddRef
(
)
const
{
AddRefImpl
(
)
;
}
void
AddRefWithCheck
(
)
const
{
AddRefWithCheckImpl
(
)
;
}
#
else
bool
Release
(
)
const
;
void
AddRef
(
)
const
;
void
AddRefWithCheck
(
)
const
;
#
endif
private
:
template
<
typename
U
>
friend
scoped_refptr
<
U
>
base
:
:
AdoptRef
(
U
*
)
;
friend
class
RefCountedOverflowTest
;
void
Adopted
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
needs_adopt_ref_
)
;
needs_adopt_ref_
=
false
;
#
endif
}
ALWAYS_INLINE
void
AddRefImpl
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
needs_adopt_ref_
)
;
#
endif
CHECK_NE
(
ref_count_
.
Increment
(
)
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
;
}
ALWAYS_INLINE
void
AddRefWithCheckImpl
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
needs_adopt_ref_
)
;
#
endif
int
pre_increment_count
=
ref_count_
.
Increment
(
)
;
CHECK_GT
(
pre_increment_count
0
)
;
CHECK_NE
(
pre_increment_count
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
;
}
ALWAYS_INLINE
bool
ReleaseImpl
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
ref_count_
.
IsZero
(
)
)
;
#
endif
if
(
!
ref_count_
.
Decrement
(
)
)
{
#
if
DCHECK_IS_ON
(
)
in_dtor_
=
true
;
#
endif
return
true
;
}
return
false
;
}
mutable
AtomicRefCount
ref_count_
{
0
}
;
#
if
DCHECK_IS_ON
(
)
mutable
bool
needs_adopt_ref_
=
false
;
mutable
bool
in_dtor_
=
false
;
#
endif
}
;
}
class
BASE_EXPORT
ScopedAllowCrossThreadRefCountAccess
final
{
public
:
#
if
DCHECK_IS_ON
(
)
ScopedAllowCrossThreadRefCountAccess
(
)
;
~
ScopedAllowCrossThreadRefCountAccess
(
)
;
#
else
ScopedAllowCrossThreadRefCountAccess
(
)
{
}
~
ScopedAllowCrossThreadRefCountAccess
(
)
{
}
#
endif
}
;
#
define
REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE
(
)
\
using
RefCountPreferenceTag
=
:
:
base
:
:
subtle
:
:
StartRefCountFromOneTag
template
<
class
T
typename
Traits
>
class
RefCounted
;
template
<
typename
T
>
struct
DefaultRefCountedTraits
{
static
void
Destruct
(
const
T
*
x
)
{
RefCounted
<
T
DefaultRefCountedTraits
>
:
:
DeleteInternal
(
x
)
;
}
}
;
template
<
class
T
typename
Traits
=
DefaultRefCountedTraits
<
T
>
>
class
RefCounted
:
public
subtle
:
:
RefCountedBase
{
public
:
using
RefCountPreferenceTag
=
subtle
:
:
StartRefCountFromZeroTag
;
RefCounted
(
)
:
subtle
:
:
RefCountedBase
(
subtle
:
:
GetRefCountPreference
<
T
>
(
)
)
{
}
RefCounted
(
const
RefCounted
&
)
=
delete
;
RefCounted
&
operator
=
(
const
RefCounted
&
)
=
delete
;
void
AddRef
(
)
const
{
subtle
:
:
RefCountedBase
:
:
AddRef
(
)
;
}
void
Release
(
)
const
{
if
(
subtle
:
:
RefCountedBase
:
:
Release
(
)
)
{
ANALYZER_SKIP_THIS_PATH
(
)
;
Traits
:
:
Destruct
(
static_cast
<
const
T
*
>
(
this
)
)
;
}
}
protected
:
~
RefCounted
(
)
=
default
;
private
:
friend
struct
DefaultRefCountedTraits
<
T
>
;
template
<
typename
U
>
static
void
DeleteInternal
(
const
U
*
x
)
{
delete
x
;
}
}
;
template
<
class
T
typename
Traits
>
class
RefCountedThreadSafe
;
template
<
typename
T
>
struct
DefaultRefCountedThreadSafeTraits
{
static
void
Destruct
(
const
T
*
x
)
{
RefCountedThreadSafe
<
T
DefaultRefCountedThreadSafeTraits
>
:
:
DeleteInternal
(
x
)
;
}
}
;
template
<
class
T
typename
Traits
=
DefaultRefCountedThreadSafeTraits
<
T
>
>
class
RefCountedThreadSafe
:
public
subtle
:
:
RefCountedThreadSafeBase
{
public
:
using
RefCountPreferenceTag
=
subtle
:
:
StartRefCountFromZeroTag
;
explicit
RefCountedThreadSafe
(
)
:
subtle
:
:
RefCountedThreadSafeBase
(
subtle
:
:
GetRefCountPreference
<
T
>
(
)
)
{
}
RefCountedThreadSafe
(
const
RefCountedThreadSafe
&
)
=
delete
;
RefCountedThreadSafe
&
operator
=
(
const
RefCountedThreadSafe
&
)
=
delete
;
void
AddRef
(
)
const
{
AddRefImpl
(
subtle
:
:
GetRefCountPreference
<
T
>
(
)
)
;
}
void
Release
(
)
const
{
if
(
subtle
:
:
RefCountedThreadSafeBase
:
:
Release
(
)
)
{
ANALYZER_SKIP_THIS_PATH
(
)
;
Traits
:
:
Destruct
(
static_cast
<
const
T
*
>
(
this
)
)
;
}
}
protected
:
~
RefCountedThreadSafe
(
)
=
default
;
private
:
friend
struct
DefaultRefCountedThreadSafeTraits
<
T
>
;
template
<
typename
U
>
static
void
DeleteInternal
(
const
U
*
x
)
{
delete
x
;
}
void
AddRefImpl
(
subtle
:
:
StartRefCountFromZeroTag
)
const
{
subtle
:
:
RefCountedThreadSafeBase
:
:
AddRef
(
)
;
}
void
AddRefImpl
(
subtle
:
:
StartRefCountFromOneTag
)
const
{
subtle
:
:
RefCountedThreadSafeBase
:
:
AddRefWithCheck
(
)
;
}
}
;
template
<
typename
T
>
class
RefCountedData
:
public
base
:
:
RefCountedThreadSafe
<
base
:
:
RefCountedData
<
T
>
>
{
public
:
RefCountedData
(
)
:
data
(
)
{
}
RefCountedData
(
const
T
&
in_value
)
:
data
(
in_value
)
{
}
RefCountedData
(
T
&
&
in_value
)
:
data
(
std
:
:
move
(
in_value
)
)
{
}
template
<
typename
.
.
.
Args
>
explicit
RefCountedData
(
absl
:
:
in_place_t
Args
&
&
.
.
.
args
)
:
data
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
{
}
T
data
;
private
:
friend
class
base
:
:
RefCountedThreadSafe
<
base
:
:
RefCountedData
<
T
>
>
;
~
RefCountedData
(
)
=
default
;
}
;
template
<
typename
T
>
bool
operator
=
=
(
const
RefCountedData
<
T
>
&
lhs
const
RefCountedData
<
T
>
&
rhs
)
{
return
lhs
.
data
=
=
rhs
.
data
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
RefCountedData
<
T
>
&
lhs
const
RefCountedData
<
T
>
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
}
#
endif
