#
ifndef
BASE_MEMORY_REF_COUNTED_H_
#
define
BASE_MEMORY_REF_COUNTED_H_
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
base
/
atomic_ref_count
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
gtest_prod_util
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
memory
/
scoped_refptr
.
h
"
#
include
"
base
/
sequence_checker
.
h
"
#
include
"
base
/
threading
/
thread_collision_warner
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
namespace
subtle
{
class
BASE_EXPORT
RefCountedBase
{
public
:
bool
HasOneRef
(
)
const
{
return
ref_count_
=
=
1
;
}
bool
HasAtLeastOneRef
(
)
const
{
return
ref_count_
>
=
1
;
}
protected
:
explicit
RefCountedBase
(
StartRefCountFromZeroTag
)
{
#
if
DCHECK_IS_ON
(
)
sequence_checker_
.
DetachFromSequence
(
)
;
#
endif
}
explicit
RefCountedBase
(
StartRefCountFromOneTag
)
:
ref_count_
(
1
)
{
#
if
DCHECK_IS_ON
(
)
needs_adopt_ref_
=
true
;
sequence_checker_
.
DetachFromSequence
(
)
;
#
endif
}
~
RefCountedBase
(
)
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
in_dtor_
)
<
<
"
RefCounted
object
deleted
without
calling
Release
(
)
"
;
#
endif
}
void
AddRef
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
needs_adopt_ref_
)
<
<
"
This
RefCounted
object
is
created
with
non
-
zero
reference
count
.
"
<
<
"
The
first
reference
to
such
a
object
has
to
be
made
by
AdoptRef
or
"
<
<
"
MakeRefCounted
.
"
;
if
(
ref_count_
>
=
1
)
{
DCHECK
(
CalledOnValidSequence
(
)
)
;
}
#
endif
AddRefImpl
(
)
;
}
bool
Release
(
)
const
{
-
-
ref_count_
;
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
if
(
ref_count_
=
=
0
)
in_dtor_
=
true
;
if
(
ref_count_
>
=
1
)
DCHECK
(
CalledOnValidSequence
(
)
)
;
if
(
ref_count_
=
=
1
)
sequence_checker_
.
DetachFromSequence
(
)
;
#
endif
return
ref_count_
=
=
0
;
}
bool
IsOnValidSequence
(
)
const
{
#
if
DCHECK_IS_ON
(
)
return
ref_count_
<
=
1
|
|
CalledOnValidSequence
(
)
;
#
else
return
true
;
#
endif
}
private
:
template
<
typename
U
>
friend
scoped_refptr
<
U
>
base
:
:
AdoptRef
(
U
*
)
;
FRIEND_TEST_ALL_PREFIXES
(
RefCountedDeathTest
TestOverflowCheck
)
;
void
Adopted
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
needs_adopt_ref_
)
;
needs_adopt_ref_
=
false
;
#
endif
}
#
if
defined
(
ARCH_CPU_64_BITS
)
void
AddRefImpl
(
)
const
;
#
else
void
AddRefImpl
(
)
const
{
+
+
ref_count_
;
}
#
endif
#
if
DCHECK_IS_ON
(
)
bool
CalledOnValidSequence
(
)
const
;
#
endif
mutable
uint32_t
ref_count_
=
0
;
#
if
DCHECK_IS_ON
(
)
mutable
bool
needs_adopt_ref_
=
false
;
mutable
bool
in_dtor_
=
false
;
mutable
SequenceChecker
sequence_checker_
;
#
endif
DFAKE_MUTEX
(
add_release_
)
;
DISALLOW_COPY_AND_ASSIGN
(
RefCountedBase
)
;
}
;
class
BASE_EXPORT
RefCountedThreadSafeBase
{
public
:
bool
HasOneRef
(
)
const
;
bool
HasAtLeastOneRef
(
)
const
;
protected
:
explicit
constexpr
RefCountedThreadSafeBase
(
StartRefCountFromZeroTag
)
{
}
explicit
constexpr
RefCountedThreadSafeBase
(
StartRefCountFromOneTag
)
:
ref_count_
(
1
)
{
#
if
DCHECK_IS_ON
(
)
needs_adopt_ref_
=
true
;
#
endif
}
#
if
DCHECK_IS_ON
(
)
~
RefCountedThreadSafeBase
(
)
;
#
else
~
RefCountedThreadSafeBase
(
)
=
default
;
#
endif
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
bool
Release
(
)
const
{
return
ReleaseImpl
(
)
;
}
void
AddRef
(
)
const
{
AddRefImpl
(
)
;
}
void
AddRefWithCheck
(
)
const
{
AddRefWithCheckImpl
(
)
;
}
#
else
bool
Release
(
)
const
;
void
AddRef
(
)
const
;
void
AddRefWithCheck
(
)
const
;
#
endif
private
:
template
<
typename
U
>
friend
scoped_refptr
<
U
>
base
:
:
AdoptRef
(
U
*
)
;
void
Adopted
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
needs_adopt_ref_
)
;
needs_adopt_ref_
=
false
;
#
endif
}
ALWAYS_INLINE
void
AddRefImpl
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
needs_adopt_ref_
)
<
<
"
This
RefCounted
object
is
created
with
non
-
zero
reference
count
.
"
<
<
"
The
first
reference
to
such
a
object
has
to
be
made
by
AdoptRef
or
"
<
<
"
MakeRefCounted
.
"
;
#
endif
ref_count_
.
Increment
(
)
;
}
ALWAYS_INLINE
void
AddRefWithCheckImpl
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
needs_adopt_ref_
)
<
<
"
This
RefCounted
object
is
created
with
non
-
zero
reference
count
.
"
<
<
"
The
first
reference
to
such
a
object
has
to
be
made
by
AdoptRef
or
"
<
<
"
MakeRefCounted
.
"
;
#
endif
CHECK
(
ref_count_
.
Increment
(
)
>
0
)
;
}
ALWAYS_INLINE
bool
ReleaseImpl
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
ref_count_
.
IsZero
(
)
)
;
#
endif
if
(
!
ref_count_
.
Decrement
(
)
)
{
#
if
DCHECK_IS_ON
(
)
in_dtor_
=
true
;
#
endif
return
true
;
}
return
false
;
}
mutable
AtomicRefCount
ref_count_
{
0
}
;
#
if
DCHECK_IS_ON
(
)
mutable
bool
needs_adopt_ref_
=
false
;
mutable
bool
in_dtor_
=
false
;
#
endif
DISALLOW_COPY_AND_ASSIGN
(
RefCountedThreadSafeBase
)
;
}
;
}
class
BASE_EXPORT
ScopedAllowCrossThreadRefCountAccess
final
{
public
:
#
if
DCHECK_IS_ON
(
)
ScopedAllowCrossThreadRefCountAccess
(
)
;
~
ScopedAllowCrossThreadRefCountAccess
(
)
;
#
else
ScopedAllowCrossThreadRefCountAccess
(
)
{
}
~
ScopedAllowCrossThreadRefCountAccess
(
)
{
}
#
endif
}
;
#
define
REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE
(
)
\
static
constexpr
:
:
base
:
:
subtle
:
:
StartRefCountFromOneTag
\
kRefCountPreference
=
:
:
base
:
:
subtle
:
:
kStartRefCountFromOneTag
template
<
class
T
typename
Traits
>
class
RefCounted
;
template
<
typename
T
>
struct
DefaultRefCountedTraits
{
static
void
Destruct
(
const
T
*
x
)
{
RefCounted
<
T
DefaultRefCountedTraits
>
:
:
DeleteInternal
(
x
)
;
}
}
;
template
<
class
T
typename
Traits
=
DefaultRefCountedTraits
<
T
>
>
class
RefCounted
:
public
subtle
:
:
RefCountedBase
{
public
:
static
constexpr
subtle
:
:
StartRefCountFromZeroTag
kRefCountPreference
=
subtle
:
:
kStartRefCountFromZeroTag
;
RefCounted
(
)
:
subtle
:
:
RefCountedBase
(
T
:
:
kRefCountPreference
)
{
}
void
AddRef
(
)
const
{
subtle
:
:
RefCountedBase
:
:
AddRef
(
)
;
}
void
Release
(
)
const
{
if
(
subtle
:
:
RefCountedBase
:
:
Release
(
)
)
{
ANALYZER_SKIP_THIS_PATH
(
)
;
Traits
:
:
Destruct
(
static_cast
<
const
T
*
>
(
this
)
)
;
}
}
protected
:
~
RefCounted
(
)
=
default
;
private
:
friend
struct
DefaultRefCountedTraits
<
T
>
;
template
<
typename
U
>
static
void
DeleteInternal
(
const
U
*
x
)
{
delete
x
;
}
DISALLOW_COPY_AND_ASSIGN
(
RefCounted
)
;
}
;
template
<
class
T
typename
Traits
>
class
RefCountedThreadSafe
;
template
<
typename
T
>
struct
DefaultRefCountedThreadSafeTraits
{
static
void
Destruct
(
const
T
*
x
)
{
RefCountedThreadSafe
<
T
DefaultRefCountedThreadSafeTraits
>
:
:
DeleteInternal
(
x
)
;
}
}
;
template
<
class
T
typename
Traits
=
DefaultRefCountedThreadSafeTraits
<
T
>
>
class
RefCountedThreadSafe
:
public
subtle
:
:
RefCountedThreadSafeBase
{
public
:
static
constexpr
subtle
:
:
StartRefCountFromZeroTag
kRefCountPreference
=
subtle
:
:
kStartRefCountFromZeroTag
;
explicit
RefCountedThreadSafe
(
)
:
subtle
:
:
RefCountedThreadSafeBase
(
T
:
:
kRefCountPreference
)
{
}
void
AddRef
(
)
const
{
AddRefImpl
(
T
:
:
kRefCountPreference
)
;
}
void
Release
(
)
const
{
if
(
subtle
:
:
RefCountedThreadSafeBase
:
:
Release
(
)
)
{
ANALYZER_SKIP_THIS_PATH
(
)
;
Traits
:
:
Destruct
(
static_cast
<
const
T
*
>
(
this
)
)
;
}
}
protected
:
~
RefCountedThreadSafe
(
)
=
default
;
private
:
friend
struct
DefaultRefCountedThreadSafeTraits
<
T
>
;
template
<
typename
U
>
static
void
DeleteInternal
(
const
U
*
x
)
{
delete
x
;
}
void
AddRefImpl
(
subtle
:
:
StartRefCountFromZeroTag
)
const
{
subtle
:
:
RefCountedThreadSafeBase
:
:
AddRef
(
)
;
}
void
AddRefImpl
(
subtle
:
:
StartRefCountFromOneTag
)
const
{
subtle
:
:
RefCountedThreadSafeBase
:
:
AddRefWithCheck
(
)
;
}
DISALLOW_COPY_AND_ASSIGN
(
RefCountedThreadSafe
)
;
}
;
template
<
typename
T
>
class
RefCountedData
:
public
base
:
:
RefCountedThreadSafe
<
base
:
:
RefCountedData
<
T
>
>
{
public
:
RefCountedData
(
)
:
data
(
)
{
}
RefCountedData
(
const
T
&
in_value
)
:
data
(
in_value
)
{
}
RefCountedData
(
T
&
&
in_value
)
:
data
(
std
:
:
move
(
in_value
)
)
{
}
T
data
;
private
:
friend
class
base
:
:
RefCountedThreadSafe
<
base
:
:
RefCountedData
<
T
>
>
;
~
RefCountedData
(
)
=
default
;
}
;
}
#
endif
