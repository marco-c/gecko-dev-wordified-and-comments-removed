#
ifndef
BASE_MEMORY_REF_COUNTED_H_
#
define
BASE_MEMORY_REF_COUNTED_H_
#
include
<
stddef
.
h
>
#
include
<
cassert
>
#
include
<
iosfwd
>
#
include
<
type_traits
>
#
include
"
base
/
atomic_ref_count
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
sequence_checker
.
h
"
#
include
"
base
/
threading
/
thread_collision_warner
.
h
"
#
include
"
build
/
build_config
.
h
"
template
<
class
T
>
class
scoped_refptr
;
namespace
base
{
template
<
typename
T
>
scoped_refptr
<
T
>
AdoptRef
(
T
*
t
)
;
namespace
subtle
{
enum
AdoptRefTag
{
kAdoptRefTag
}
;
enum
StartRefCountFromZeroTag
{
kStartRefCountFromZeroTag
}
;
enum
StartRefCountFromOneTag
{
kStartRefCountFromOneTag
}
;
class
BASE_EXPORT
RefCountedBase
{
public
:
bool
HasOneRef
(
)
const
{
return
ref_count_
=
=
1
;
}
protected
:
explicit
RefCountedBase
(
StartRefCountFromZeroTag
)
{
#
if
DCHECK_IS_ON
(
)
sequence_checker_
.
DetachFromSequence
(
)
;
#
endif
}
explicit
RefCountedBase
(
StartRefCountFromOneTag
)
:
ref_count_
(
1
)
{
#
if
DCHECK_IS_ON
(
)
needs_adopt_ref_
=
true
;
sequence_checker_
.
DetachFromSequence
(
)
;
#
endif
}
~
RefCountedBase
(
)
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
in_dtor_
)
<
<
"
RefCounted
object
deleted
without
calling
Release
(
)
"
;
#
endif
}
void
AddRef
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
needs_adopt_ref_
)
<
<
"
This
RefCounted
object
is
created
with
non
-
zero
reference
count
.
"
<
<
"
The
first
reference
to
such
a
object
has
to
be
made
by
AdoptRef
or
"
<
<
"
MakeRefCounted
.
"
;
if
(
ref_count_
>
=
1
)
{
DCHECK
(
CalledOnValidSequence
(
)
)
;
}
#
endif
+
+
ref_count_
;
}
bool
Release
(
)
const
{
-
-
ref_count_
;
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
if
(
ref_count_
=
=
0
)
in_dtor_
=
true
;
if
(
ref_count_
>
=
1
)
DCHECK
(
CalledOnValidSequence
(
)
)
;
if
(
ref_count_
=
=
1
)
sequence_checker_
.
DetachFromSequence
(
)
;
#
endif
return
ref_count_
=
=
0
;
}
bool
IsOnValidSequence
(
)
const
{
#
if
DCHECK_IS_ON
(
)
return
ref_count_
<
=
1
|
|
CalledOnValidSequence
(
)
;
#
else
return
true
;
#
endif
}
private
:
template
<
typename
U
>
friend
scoped_refptr
<
U
>
base
:
:
AdoptRef
(
U
*
)
;
void
Adopted
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
needs_adopt_ref_
)
;
needs_adopt_ref_
=
false
;
#
endif
}
#
if
DCHECK_IS_ON
(
)
bool
CalledOnValidSequence
(
)
const
;
#
endif
mutable
size_t
ref_count_
=
0
;
#
if
DCHECK_IS_ON
(
)
mutable
bool
needs_adopt_ref_
=
false
;
mutable
bool
in_dtor_
=
false
;
mutable
SequenceChecker
sequence_checker_
;
#
endif
DFAKE_MUTEX
(
add_release_
)
;
DISALLOW_COPY_AND_ASSIGN
(
RefCountedBase
)
;
}
;
class
BASE_EXPORT
RefCountedThreadSafeBase
{
public
:
bool
HasOneRef
(
)
const
;
protected
:
explicit
RefCountedThreadSafeBase
(
StartRefCountFromZeroTag
)
{
}
explicit
RefCountedThreadSafeBase
(
StartRefCountFromOneTag
)
:
ref_count_
(
1
)
{
#
if
DCHECK_IS_ON
(
)
needs_adopt_ref_
=
true
;
#
endif
}
~
RefCountedThreadSafeBase
(
)
;
#
if
defined
(
ARCH_CPU_X86_FAMILY
)
bool
Release
(
)
const
{
return
ReleaseImpl
(
)
;
}
void
AddRef
(
)
const
{
AddRefImpl
(
)
;
}
#
else
bool
Release
(
)
const
;
void
AddRef
(
)
const
;
#
endif
private
:
template
<
typename
U
>
friend
scoped_refptr
<
U
>
base
:
:
AdoptRef
(
U
*
)
;
void
Adopted
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
needs_adopt_ref_
)
;
needs_adopt_ref_
=
false
;
#
endif
}
ALWAYS_INLINE
void
AddRefImpl
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
needs_adopt_ref_
)
<
<
"
This
RefCounted
object
is
created
with
non
-
zero
reference
count
.
"
<
<
"
The
first
reference
to
such
a
object
has
to
be
made
by
AdoptRef
or
"
<
<
"
MakeRefCounted
.
"
;
#
endif
ref_count_
.
Increment
(
)
;
}
ALWAYS_INLINE
bool
ReleaseImpl
(
)
const
{
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
in_dtor_
)
;
DCHECK
(
!
ref_count_
.
IsZero
(
)
)
;
#
endif
if
(
!
ref_count_
.
Decrement
(
)
)
{
#
if
DCHECK_IS_ON
(
)
in_dtor_
=
true
;
#
endif
return
true
;
}
return
false
;
}
mutable
AtomicRefCount
ref_count_
{
0
}
;
#
if
DCHECK_IS_ON
(
)
mutable
bool
needs_adopt_ref_
=
false
;
mutable
bool
in_dtor_
=
false
;
#
endif
DISALLOW_COPY_AND_ASSIGN
(
RefCountedThreadSafeBase
)
;
}
;
}
class
BASE_EXPORT
ScopedAllowCrossThreadRefCountAccess
final
{
public
:
#
if
DCHECK_IS_ON
(
)
ScopedAllowCrossThreadRefCountAccess
(
)
;
~
ScopedAllowCrossThreadRefCountAccess
(
)
;
#
else
ScopedAllowCrossThreadRefCountAccess
(
)
{
}
~
ScopedAllowCrossThreadRefCountAccess
(
)
{
}
#
endif
}
;
#
define
REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE
(
)
\
static
constexpr
:
:
base
:
:
subtle
:
:
StartRefCountFromOneTag
\
kRefCountPreference
=
:
:
base
:
:
subtle
:
:
kStartRefCountFromOneTag
template
<
class
T
>
class
RefCounted
:
public
subtle
:
:
RefCountedBase
{
public
:
static
constexpr
subtle
:
:
StartRefCountFromZeroTag
kRefCountPreference
=
subtle
:
:
kStartRefCountFromZeroTag
;
RefCounted
(
)
:
subtle
:
:
RefCountedBase
(
T
:
:
kRefCountPreference
)
{
}
void
AddRef
(
)
const
{
subtle
:
:
RefCountedBase
:
:
AddRef
(
)
;
}
void
Release
(
)
const
{
if
(
subtle
:
:
RefCountedBase
:
:
Release
(
)
)
{
ANALYZER_SKIP_THIS_PATH
(
)
;
delete
static_cast
<
const
T
*
>
(
this
)
;
}
}
protected
:
~
RefCounted
(
)
=
default
;
private
:
DISALLOW_COPY_AND_ASSIGN
(
RefCounted
)
;
}
;
template
<
class
T
typename
Traits
>
class
RefCountedThreadSafe
;
template
<
typename
T
>
struct
DefaultRefCountedThreadSafeTraits
{
static
void
Destruct
(
const
T
*
x
)
{
RefCountedThreadSafe
<
T
DefaultRefCountedThreadSafeTraits
>
:
:
DeleteInternal
(
x
)
;
}
}
;
template
<
class
T
typename
Traits
=
DefaultRefCountedThreadSafeTraits
<
T
>
>
class
RefCountedThreadSafe
:
public
subtle
:
:
RefCountedThreadSafeBase
{
public
:
static
constexpr
subtle
:
:
StartRefCountFromZeroTag
kRefCountPreference
=
subtle
:
:
kStartRefCountFromZeroTag
;
explicit
RefCountedThreadSafe
(
)
:
subtle
:
:
RefCountedThreadSafeBase
(
T
:
:
kRefCountPreference
)
{
}
void
AddRef
(
)
const
{
subtle
:
:
RefCountedThreadSafeBase
:
:
AddRef
(
)
;
}
void
Release
(
)
const
{
if
(
subtle
:
:
RefCountedThreadSafeBase
:
:
Release
(
)
)
{
ANALYZER_SKIP_THIS_PATH
(
)
;
Traits
:
:
Destruct
(
static_cast
<
const
T
*
>
(
this
)
)
;
}
}
protected
:
~
RefCountedThreadSafe
(
)
=
default
;
private
:
friend
struct
DefaultRefCountedThreadSafeTraits
<
T
>
;
static
void
DeleteInternal
(
const
T
*
x
)
{
delete
x
;
}
DISALLOW_COPY_AND_ASSIGN
(
RefCountedThreadSafe
)
;
}
;
template
<
typename
T
>
class
RefCountedData
:
public
base
:
:
RefCountedThreadSafe
<
base
:
:
RefCountedData
<
T
>
>
{
public
:
RefCountedData
(
)
:
data
(
)
{
}
RefCountedData
(
const
T
&
in_value
)
:
data
(
in_value
)
{
}
T
data
;
private
:
friend
class
base
:
:
RefCountedThreadSafe
<
base
:
:
RefCountedData
<
T
>
>
;
~
RefCountedData
(
)
=
default
;
}
;
template
<
typename
T
>
scoped_refptr
<
T
>
AdoptRef
(
T
*
obj
)
{
using
Tag
=
typename
std
:
:
decay
<
decltype
(
T
:
:
kRefCountPreference
)
>
:
:
type
;
static_assert
(
std
:
:
is_same
<
subtle
:
:
StartRefCountFromOneTag
Tag
>
:
:
value
"
Use
AdoptRef
only
for
the
reference
count
starts
from
one
.
"
)
;
DCHECK
(
obj
)
;
DCHECK
(
obj
-
>
HasOneRef
(
)
)
;
obj
-
>
Adopted
(
)
;
return
scoped_refptr
<
T
>
(
obj
subtle
:
:
kAdoptRefTag
)
;
}
namespace
subtle
{
template
<
typename
T
>
scoped_refptr
<
T
>
AdoptRefIfNeeded
(
T
*
obj
StartRefCountFromZeroTag
)
{
return
scoped_refptr
<
T
>
(
obj
)
;
}
template
<
typename
T
>
scoped_refptr
<
T
>
AdoptRefIfNeeded
(
T
*
obj
StartRefCountFromOneTag
)
{
return
AdoptRef
(
obj
)
;
}
}
template
<
typename
T
typename
.
.
.
Args
>
scoped_refptr
<
T
>
MakeRefCounted
(
Args
&
&
.
.
.
args
)
{
T
*
obj
=
new
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
subtle
:
:
AdoptRefIfNeeded
(
obj
T
:
:
kRefCountPreference
)
;
}
}
template
<
class
T
>
class
scoped_refptr
{
public
:
typedef
T
element_type
;
scoped_refptr
(
)
{
}
scoped_refptr
(
T
*
p
)
:
ptr_
(
p
)
{
if
(
ptr_
)
AddRef
(
ptr_
)
;
}
scoped_refptr
(
const
scoped_refptr
<
T
>
&
r
)
:
ptr_
(
r
.
ptr_
)
{
if
(
ptr_
)
AddRef
(
ptr_
)
;
}
template
<
typename
U
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
U
*
T
*
>
:
:
value
>
:
:
type
>
scoped_refptr
(
const
scoped_refptr
<
U
>
&
r
)
:
ptr_
(
r
.
get
(
)
)
{
if
(
ptr_
)
AddRef
(
ptr_
)
;
}
scoped_refptr
(
scoped_refptr
&
&
r
)
:
ptr_
(
r
.
get
(
)
)
{
r
.
ptr_
=
nullptr
;
}
template
<
typename
U
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
U
*
T
*
>
:
:
value
>
:
:
type
>
scoped_refptr
(
scoped_refptr
<
U
>
&
&
r
)
:
ptr_
(
r
.
get
(
)
)
{
r
.
ptr_
=
nullptr
;
}
~
scoped_refptr
(
)
{
if
(
ptr_
)
Release
(
ptr_
)
;
}
T
*
get
(
)
const
{
return
ptr_
;
}
T
&
operator
*
(
)
const
{
assert
(
ptr_
!
=
nullptr
)
;
return
*
ptr_
;
}
T
*
operator
-
>
(
)
const
{
assert
(
ptr_
!
=
nullptr
)
;
return
ptr_
;
}
scoped_refptr
<
T
>
&
operator
=
(
T
*
p
)
{
if
(
p
)
AddRef
(
p
)
;
T
*
old_ptr
=
ptr_
;
ptr_
=
p
;
if
(
old_ptr
)
Release
(
old_ptr
)
;
return
*
this
;
}
scoped_refptr
<
T
>
&
operator
=
(
const
scoped_refptr
<
T
>
&
r
)
{
return
*
this
=
r
.
ptr_
;
}
template
<
typename
U
>
scoped_refptr
<
T
>
&
operator
=
(
const
scoped_refptr
<
U
>
&
r
)
{
return
*
this
=
r
.
get
(
)
;
}
scoped_refptr
<
T
>
&
operator
=
(
scoped_refptr
<
T
>
&
&
r
)
{
scoped_refptr
<
T
>
tmp
(
std
:
:
move
(
r
)
)
;
tmp
.
swap
(
*
this
)
;
return
*
this
;
}
template
<
typename
U
>
scoped_refptr
<
T
>
&
operator
=
(
scoped_refptr
<
U
>
&
&
r
)
{
scoped_refptr
<
T
>
tmp
(
std
:
:
move
(
r
)
)
;
tmp
.
swap
(
*
this
)
;
return
*
this
;
}
void
swap
(
scoped_refptr
<
T
>
&
r
)
{
T
*
tmp
=
ptr_
;
ptr_
=
r
.
ptr_
;
r
.
ptr_
=
tmp
;
}
explicit
operator
bool
(
)
const
{
return
ptr_
!
=
nullptr
;
}
template
<
typename
U
>
bool
operator
=
=
(
const
scoped_refptr
<
U
>
&
rhs
)
const
{
return
ptr_
=
=
rhs
.
get
(
)
;
}
template
<
typename
U
>
bool
operator
!
=
(
const
scoped_refptr
<
U
>
&
rhs
)
const
{
return
!
operator
=
=
(
rhs
)
;
}
template
<
typename
U
>
bool
operator
<
(
const
scoped_refptr
<
U
>
&
rhs
)
const
{
return
ptr_
<
rhs
.
get
(
)
;
}
protected
:
T
*
ptr_
=
nullptr
;
private
:
template
<
typename
U
>
friend
scoped_refptr
<
U
>
base
:
:
AdoptRef
(
U
*
)
;
scoped_refptr
(
T
*
p
base
:
:
subtle
:
:
AdoptRefTag
)
:
ptr_
(
p
)
{
}
template
<
typename
U
>
friend
class
scoped_refptr
;
static
void
AddRef
(
T
*
ptr
)
;
static
void
Release
(
T
*
ptr
)
;
}
;
template
<
typename
T
>
void
scoped_refptr
<
T
>
:
:
AddRef
(
T
*
ptr
)
{
ptr
-
>
AddRef
(
)
;
}
template
<
typename
T
>
void
scoped_refptr
<
T
>
:
:
Release
(
T
*
ptr
)
{
ptr
-
>
Release
(
)
;
}
template
<
typename
T
>
scoped_refptr
<
T
>
make_scoped_refptr
(
T
*
t
)
{
return
scoped_refptr
<
T
>
(
t
)
;
}
template
<
typename
T
typename
U
>
bool
operator
=
=
(
const
scoped_refptr
<
T
>
&
lhs
const
U
*
rhs
)
{
return
lhs
.
get
(
)
=
=
rhs
;
}
template
<
typename
T
typename
U
>
bool
operator
=
=
(
const
T
*
lhs
const
scoped_refptr
<
U
>
&
rhs
)
{
return
lhs
=
=
rhs
.
get
(
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
scoped_refptr
<
T
>
&
lhs
std
:
:
nullptr_t
null
)
{
return
!
static_cast
<
bool
>
(
lhs
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
std
:
:
nullptr_t
null
const
scoped_refptr
<
T
>
&
rhs
)
{
return
!
static_cast
<
bool
>
(
rhs
)
;
}
template
<
typename
T
typename
U
>
bool
operator
!
=
(
const
scoped_refptr
<
T
>
&
lhs
const
U
*
rhs
)
{
return
!
operator
=
=
(
lhs
rhs
)
;
}
template
<
typename
T
typename
U
>
bool
operator
!
=
(
const
T
*
lhs
const
scoped_refptr
<
U
>
&
rhs
)
{
return
!
operator
=
=
(
lhs
rhs
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
scoped_refptr
<
T
>
&
lhs
std
:
:
nullptr_t
null
)
{
return
!
operator
=
=
(
lhs
null
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
std
:
:
nullptr_t
null
const
scoped_refptr
<
T
>
&
rhs
)
{
return
!
operator
=
=
(
null
rhs
)
;
}
template
<
typename
T
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
scoped_refptr
<
T
>
&
p
)
{
return
out
<
<
p
.
get
(
)
;
}
#
endif
