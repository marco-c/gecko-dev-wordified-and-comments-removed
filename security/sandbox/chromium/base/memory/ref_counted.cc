#
include
"
base
/
memory
/
ref_counted
.
h
"
#
include
<
limits
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
"
base
/
threading
/
thread_collision_warner
.
h
"
namespace
base
{
namespace
{
#
if
DCHECK_IS_ON
(
)
std
:
:
atomic_int
g_cross_thread_ref_count_access_allow_count
(
0
)
;
#
endif
}
namespace
subtle
{
bool
RefCountedThreadSafeBase
:
:
HasOneRef
(
)
const
{
return
ref_count_
.
IsOne
(
)
;
}
bool
RefCountedThreadSafeBase
:
:
HasAtLeastOneRef
(
)
const
{
return
!
ref_count_
.
IsZero
(
)
;
}
#
if
DCHECK_IS_ON
(
)
RefCountedThreadSafeBase
:
:
~
RefCountedThreadSafeBase
(
)
{
DCHECK
(
in_dtor_
)
<
<
"
RefCountedThreadSafe
object
deleted
without
"
"
calling
Release
(
)
"
;
}
#
endif
#
if
defined
(
ARCH_CPU_64_BITS
)
void
RefCountedBase
:
:
AddRefImpl
(
)
const
{
CHECK
(
+
+
ref_count_
!
=
0
)
;
}
void
RefCountedBase
:
:
ReleaseImpl
(
)
const
{
CHECK
(
-
-
ref_count_
!
=
std
:
:
numeric_limits
<
decltype
(
ref_count_
)
>
:
:
max
(
)
)
;
}
#
endif
#
if
!
(
defined
(
ARCH_CPU_X86_FAMILY
)
|
|
defined
(
__ARM_FEATURE_ATOMICS
)
)
bool
RefCountedThreadSafeBase
:
:
Release
(
)
const
{
return
ReleaseImpl
(
)
;
}
void
RefCountedThreadSafeBase
:
:
AddRef
(
)
const
{
AddRefImpl
(
)
;
}
void
RefCountedThreadSafeBase
:
:
AddRefWithCheck
(
)
const
{
AddRefWithCheckImpl
(
)
;
}
#
endif
#
if
DCHECK_IS_ON
(
)
bool
RefCountedBase
:
:
CalledOnValidSequence
(
)
const
{
#
if
defined
(
MOZ_SANDBOX
)
return
true
;
#
else
return
sequence_checker_
.
CalledOnValidSequence
(
)
|
|
g_cross_thread_ref_count_access_allow_count
.
load
(
)
!
=
0
;
#
endif
}
#
endif
}
#
if
DCHECK_IS_ON
(
)
ScopedAllowCrossThreadRefCountAccess
:
:
ScopedAllowCrossThreadRefCountAccess
(
)
{
+
+
g_cross_thread_ref_count_access_allow_count
;
}
ScopedAllowCrossThreadRefCountAccess
:
:
~
ScopedAllowCrossThreadRefCountAccess
(
)
{
-
-
g_cross_thread_ref_count_access_allow_count
;
}
#
endif
}
