#
ifndef
BASE_MEMORY_SCOPED_PTR_H_
#
define
BASE_MEMORY_SCOPED_PTR_H_
#
include
<
assert
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
iosfwd
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
move
.
h
"
#
include
"
base
/
template_util
.
h
"
namespace
base
{
namespace
subtle
{
class
RefCountedBase
;
class
RefCountedThreadSafeBase
;
}
struct
FreeDeleter
{
inline
void
operator
(
)
(
void
*
ptr
)
const
{
free
(
ptr
)
;
}
}
;
namespace
internal
{
template
<
typename
T
>
struct
IsNotRefCounted
{
enum
{
value
=
!
base
:
:
is_convertible
<
T
*
base
:
:
subtle
:
:
RefCountedBase
*
>
:
:
value
&
&
!
base
:
:
is_convertible
<
T
*
base
:
:
subtle
:
:
RefCountedThreadSafeBase
*
>
:
:
value
}
;
}
;
template
<
class
T
class
D
>
class
scoped_ptr_impl
{
public
:
explicit
scoped_ptr_impl
(
T
*
p
)
:
data_
(
p
)
{
}
scoped_ptr_impl
(
T
*
p
const
D
&
d
)
:
data_
(
p
d
)
{
}
template
<
typename
U
typename
V
>
scoped_ptr_impl
(
scoped_ptr_impl
<
U
V
>
*
other
)
:
data_
(
other
-
>
release
(
)
other
-
>
get_deleter
(
)
)
{
}
template
<
typename
U
typename
V
>
void
TakeState
(
scoped_ptr_impl
<
U
V
>
*
other
)
{
reset
(
other
-
>
release
(
)
)
;
get_deleter
(
)
=
other
-
>
get_deleter
(
)
;
}
~
scoped_ptr_impl
(
)
{
reset
(
nullptr
)
;
}
void
reset
(
T
*
p
)
{
T
*
old
=
data_
.
ptr
;
data_
.
ptr
=
p
;
if
(
old
!
=
nullptr
)
static_cast
<
D
&
>
(
data_
)
(
old
)
;
}
T
*
get
(
)
const
{
return
data_
.
ptr
;
}
D
&
get_deleter
(
)
{
return
data_
;
}
const
D
&
get_deleter
(
)
const
{
return
data_
;
}
void
swap
(
scoped_ptr_impl
&
p2
)
{
using
std
:
:
swap
;
swap
(
static_cast
<
D
&
>
(
data_
)
static_cast
<
D
&
>
(
p2
.
data_
)
)
;
swap
(
data_
.
ptr
p2
.
data_
.
ptr
)
;
}
T
*
release
(
)
{
T
*
old_ptr
=
data_
.
ptr
;
data_
.
ptr
=
nullptr
;
return
old_ptr
;
}
private
:
template
<
typename
U
typename
V
>
friend
class
scoped_ptr_impl
;
struct
Data
:
public
D
{
explicit
Data
(
T
*
ptr_in
)
:
ptr
(
ptr_in
)
{
}
Data
(
T
*
ptr_in
const
D
&
other
)
:
D
(
other
)
ptr
(
ptr_in
)
{
}
T
*
ptr
;
}
;
Data
data_
;
DISALLOW_COPY_AND_ASSIGN
(
scoped_ptr_impl
)
;
}
;
}
}
template
<
class
T
class
D
=
std
:
:
default_delete
<
T
>
>
class
scoped_ptr
{
DISALLOW_COPY_AND_ASSIGN_WITH_MOVE_FOR_BIND
(
scoped_ptr
)
static_assert
(
!
std
:
:
is_array
<
T
>
:
:
value
"
scoped_ptr
doesn
'
t
support
array
with
size
"
)
;
static_assert
(
base
:
:
internal
:
:
IsNotRefCounted
<
T
>
:
:
value
"
T
is
a
refcounted
type
and
needs
a
scoped_refptr
"
)
;
public
:
using
element_type
=
T
;
using
deleter_type
=
D
;
scoped_ptr
(
)
:
impl_
(
nullptr
)
{
}
explicit
scoped_ptr
(
element_type
*
p
)
:
impl_
(
p
)
{
}
scoped_ptr
(
element_type
*
p
const
D
&
d
)
:
impl_
(
p
d
)
{
}
scoped_ptr
(
std
:
:
nullptr_t
)
:
impl_
(
nullptr
)
{
}
scoped_ptr
(
scoped_ptr
&
&
other
)
:
impl_
(
&
other
.
impl_
)
{
}
template
<
typename
U
typename
E
typename
std
:
:
enable_if
<
!
std
:
:
is_array
<
U
>
:
:
value
&
&
std
:
:
is_convertible
<
U
*
T
*
>
:
:
value
&
&
std
:
:
is_convertible
<
E
D
>
:
:
value
>
:
:
type
*
=
nullptr
>
scoped_ptr
(
scoped_ptr
<
U
E
>
&
&
other
)
:
impl_
(
&
other
.
impl_
)
{
}
scoped_ptr
&
operator
=
(
scoped_ptr
&
&
rhs
)
{
impl_
.
TakeState
(
&
rhs
.
impl_
)
;
return
*
this
;
}
template
<
typename
U
typename
E
typename
std
:
:
enable_if
<
!
std
:
:
is_array
<
U
>
:
:
value
&
&
std
:
:
is_convertible
<
U
*
T
*
>
:
:
value
&
&
std
:
:
is_convertible
<
D
E
>
:
:
value
>
:
:
type
*
=
nullptr
>
scoped_ptr
&
operator
=
(
scoped_ptr
<
U
E
>
&
&
rhs
)
{
impl_
.
TakeState
(
&
rhs
.
impl_
)
;
return
*
this
;
}
scoped_ptr
&
operator
=
(
std
:
:
nullptr_t
)
{
reset
(
)
;
return
*
this
;
}
void
reset
(
element_type
*
p
=
nullptr
)
{
impl_
.
reset
(
p
)
;
}
element_type
&
operator
*
(
)
const
{
assert
(
impl_
.
get
(
)
!
=
nullptr
)
;
return
*
impl_
.
get
(
)
;
}
element_type
*
operator
-
>
(
)
const
{
assert
(
impl_
.
get
(
)
!
=
nullptr
)
;
return
impl_
.
get
(
)
;
}
element_type
*
get
(
)
const
{
return
impl_
.
get
(
)
;
}
deleter_type
&
get_deleter
(
)
{
return
impl_
.
get_deleter
(
)
;
}
const
deleter_type
&
get_deleter
(
)
const
{
return
impl_
.
get_deleter
(
)
;
}
private
:
typedef
base
:
:
internal
:
:
scoped_ptr_impl
<
element_type
deleter_type
>
scoped_ptr
:
:
*
Testable
;
public
:
operator
Testable
(
)
const
{
return
impl_
.
get
(
)
?
&
scoped_ptr
:
:
impl_
:
nullptr
;
}
void
swap
(
scoped_ptr
&
p2
)
{
impl_
.
swap
(
p2
.
impl_
)
;
}
element_type
*
release
(
)
WARN_UNUSED_RESULT
{
return
impl_
.
release
(
)
;
}
private
:
template
<
typename
U
typename
V
>
friend
class
scoped_ptr
;
base
:
:
internal
:
:
scoped_ptr_impl
<
element_type
deleter_type
>
impl_
;
explicit
scoped_ptr
(
int
disallow_construction_from_null
)
;
}
;
template
<
class
T
class
D
>
class
scoped_ptr
<
T
[
]
D
>
{
DISALLOW_COPY_AND_ASSIGN_WITH_MOVE_FOR_BIND
(
scoped_ptr
)
public
:
using
element_type
=
T
;
using
deleter_type
=
D
;
scoped_ptr
(
)
:
impl_
(
nullptr
)
{
}
explicit
scoped_ptr
(
element_type
*
array
)
:
impl_
(
array
)
{
}
scoped_ptr
(
std
:
:
nullptr_t
)
:
impl_
(
nullptr
)
{
}
scoped_ptr
(
scoped_ptr
&
&
other
)
:
impl_
(
&
other
.
impl_
)
{
}
scoped_ptr
&
operator
=
(
scoped_ptr
&
&
rhs
)
{
impl_
.
TakeState
(
&
rhs
.
impl_
)
;
return
*
this
;
}
scoped_ptr
&
operator
=
(
std
:
:
nullptr_t
)
{
reset
(
)
;
return
*
this
;
}
void
reset
(
element_type
*
array
=
nullptr
)
{
impl_
.
reset
(
array
)
;
}
element_type
&
operator
[
]
(
size_t
i
)
const
{
assert
(
impl_
.
get
(
)
!
=
nullptr
)
;
return
impl_
.
get
(
)
[
i
]
;
}
element_type
*
get
(
)
const
{
return
impl_
.
get
(
)
;
}
deleter_type
&
get_deleter
(
)
{
return
impl_
.
get_deleter
(
)
;
}
const
deleter_type
&
get_deleter
(
)
const
{
return
impl_
.
get_deleter
(
)
;
}
private
:
typedef
base
:
:
internal
:
:
scoped_ptr_impl
<
element_type
deleter_type
>
scoped_ptr
:
:
*
Testable
;
public
:
operator
Testable
(
)
const
{
return
impl_
.
get
(
)
?
&
scoped_ptr
:
:
impl_
:
nullptr
;
}
void
swap
(
scoped_ptr
&
p2
)
{
impl_
.
swap
(
p2
.
impl_
)
;
}
element_type
*
release
(
)
WARN_UNUSED_RESULT
{
return
impl_
.
release
(
)
;
}
private
:
enum
{
type_must_be_complete
=
sizeof
(
element_type
)
}
;
base
:
:
internal
:
:
scoped_ptr_impl
<
element_type
deleter_type
>
impl_
;
template
<
typename
U
>
explicit
scoped_ptr
(
U
*
array
)
;
explicit
scoped_ptr
(
int
disallow_construction_from_null
)
;
template
<
typename
U
>
void
reset
(
U
*
array
)
;
void
reset
(
int
disallow_reset_from_null
)
;
}
;
template
<
class
T
class
D
>
void
swap
(
scoped_ptr
<
T
D
>
&
p1
scoped_ptr
<
T
D
>
&
p2
)
{
p1
.
swap
(
p2
)
;
}
template
<
class
T1
class
D1
class
T2
class
D2
>
bool
operator
=
=
(
const
scoped_ptr
<
T1
D1
>
&
p1
const
scoped_ptr
<
T2
D2
>
&
p2
)
{
return
p1
.
get
(
)
=
=
p2
.
get
(
)
;
}
template
<
class
T
class
D
>
bool
operator
=
=
(
const
scoped_ptr
<
T
D
>
&
p
std
:
:
nullptr_t
)
{
return
p
.
get
(
)
=
=
nullptr
;
}
template
<
class
T
class
D
>
bool
operator
=
=
(
std
:
:
nullptr_t
const
scoped_ptr
<
T
D
>
&
p
)
{
return
p
.
get
(
)
=
=
nullptr
;
}
template
<
class
T1
class
D1
class
T2
class
D2
>
bool
operator
!
=
(
const
scoped_ptr
<
T1
D1
>
&
p1
const
scoped_ptr
<
T2
D2
>
&
p2
)
{
return
!
(
p1
=
=
p2
)
;
}
template
<
class
T
class
D
>
bool
operator
!
=
(
const
scoped_ptr
<
T
D
>
&
p
std
:
:
nullptr_t
)
{
return
!
(
p
=
=
nullptr
)
;
}
template
<
class
T
class
D
>
bool
operator
!
=
(
std
:
:
nullptr_t
const
scoped_ptr
<
T
D
>
&
p
)
{
return
!
(
p
=
=
nullptr
)
;
}
template
<
class
T1
class
D1
class
T2
class
D2
>
bool
operator
<
(
const
scoped_ptr
<
T1
D1
>
&
p1
const
scoped_ptr
<
T2
D2
>
&
p2
)
{
return
p1
.
get
(
)
<
p2
.
get
(
)
;
}
template
<
class
T
class
D
>
bool
operator
<
(
const
scoped_ptr
<
T
D
>
&
p
std
:
:
nullptr_t
)
{
return
p
.
get
(
)
<
nullptr
;
}
template
<
class
T
class
D
>
bool
operator
<
(
std
:
:
nullptr_t
const
scoped_ptr
<
T
D
>
&
p
)
{
return
nullptr
<
p
.
get
(
)
;
}
template
<
class
T1
class
D1
class
T2
class
D2
>
bool
operator
>
(
const
scoped_ptr
<
T1
D1
>
&
p1
const
scoped_ptr
<
T2
D2
>
&
p2
)
{
return
p2
<
p1
;
}
template
<
class
T
class
D
>
bool
operator
>
(
const
scoped_ptr
<
T
D
>
&
p
std
:
:
nullptr_t
)
{
return
nullptr
<
p
;
}
template
<
class
T
class
D
>
bool
operator
>
(
std
:
:
nullptr_t
const
scoped_ptr
<
T
D
>
&
p
)
{
return
p
<
nullptr
;
}
template
<
class
T1
class
D1
class
T2
class
D2
>
bool
operator
<
=
(
const
scoped_ptr
<
T1
D1
>
&
p1
const
scoped_ptr
<
T2
D2
>
&
p2
)
{
return
!
(
p1
>
p2
)
;
}
template
<
class
T
class
D
>
bool
operator
<
=
(
const
scoped_ptr
<
T
D
>
&
p
std
:
:
nullptr_t
)
{
return
!
(
p
>
nullptr
)
;
}
template
<
class
T
class
D
>
bool
operator
<
=
(
std
:
:
nullptr_t
const
scoped_ptr
<
T
D
>
&
p
)
{
return
!
(
nullptr
>
p
)
;
}
template
<
class
T1
class
D1
class
T2
class
D2
>
bool
operator
>
=
(
const
scoped_ptr
<
T1
D1
>
&
p1
const
scoped_ptr
<
T2
D2
>
&
p2
)
{
return
!
(
p1
<
p2
)
;
}
template
<
class
T
class
D
>
bool
operator
>
=
(
const
scoped_ptr
<
T
D
>
&
p
std
:
:
nullptr_t
)
{
return
!
(
p
<
nullptr
)
;
}
template
<
class
T
class
D
>
bool
operator
>
=
(
std
:
:
nullptr_t
const
scoped_ptr
<
T
D
>
&
p
)
{
return
!
(
nullptr
<
p
)
;
}
template
<
typename
T
>
scoped_ptr
<
T
>
make_scoped_ptr
(
T
*
ptr
)
{
return
scoped_ptr
<
T
>
(
ptr
)
;
}
template
<
typename
T
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
scoped_ptr
<
T
>
&
p
)
{
return
out
<
<
p
.
get
(
)
;
}
#
endif
