#
ifndef
BASE_MEMORY_SCOPED_REFPTR_H_
#
define
BASE_MEMORY_SCOPED_REFPTR_H_
#
include
<
stddef
.
h
>
#
include
<
iosfwd
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
template
<
class
T
>
class
scoped_refptr
;
namespace
base
{
template
<
class
typename
>
class
RefCounted
;
template
<
class
typename
>
class
RefCountedThreadSafe
;
template
<
class
>
class
RefCountedDeleteOnSequence
;
class
SequencedTaskRunner
;
template
<
typename
T
>
scoped_refptr
<
T
>
AdoptRef
(
T
*
t
)
;
namespace
subtle
{
enum
AdoptRefTag
{
kAdoptRefTag
}
;
enum
StartRefCountFromZeroTag
{
kStartRefCountFromZeroTag
}
;
enum
StartRefCountFromOneTag
{
kStartRefCountFromOneTag
}
;
template
<
typename
TagType
>
struct
RefCountPreferenceTagTraits
;
template
<
>
struct
RefCountPreferenceTagTraits
<
StartRefCountFromZeroTag
>
{
static
constexpr
StartRefCountFromZeroTag
kTag
=
kStartRefCountFromZeroTag
;
}
;
template
<
>
struct
RefCountPreferenceTagTraits
<
StartRefCountFromOneTag
>
{
static
constexpr
StartRefCountFromOneTag
kTag
=
kStartRefCountFromOneTag
;
}
;
template
<
typename
T
typename
Tag
=
typename
T
:
:
RefCountPreferenceTag
>
constexpr
Tag
GetRefCountPreference
(
)
{
return
RefCountPreferenceTagTraits
<
Tag
>
:
:
kTag
;
}
template
<
typename
T
typename
U
typename
V
>
constexpr
bool
IsRefCountPreferenceOverridden
(
const
T
*
const
RefCounted
<
U
V
>
*
)
{
return
!
std
:
:
is_same_v
<
std
:
:
decay_t
<
decltype
(
GetRefCountPreference
<
T
>
(
)
)
>
std
:
:
decay_t
<
decltype
(
GetRefCountPreference
<
U
>
(
)
)
>
>
;
}
template
<
typename
T
typename
U
typename
V
>
constexpr
bool
IsRefCountPreferenceOverridden
(
const
T
*
const
RefCountedThreadSafe
<
U
V
>
*
)
{
return
!
std
:
:
is_same_v
<
std
:
:
decay_t
<
decltype
(
GetRefCountPreference
<
T
>
(
)
)
>
std
:
:
decay_t
<
decltype
(
GetRefCountPreference
<
U
>
(
)
)
>
>
;
}
template
<
typename
T
typename
U
>
constexpr
bool
IsRefCountPreferenceOverridden
(
const
T
*
const
RefCountedDeleteOnSequence
<
U
>
*
)
{
return
!
std
:
:
is_same_v
<
std
:
:
decay_t
<
decltype
(
GetRefCountPreference
<
T
>
(
)
)
>
std
:
:
decay_t
<
decltype
(
GetRefCountPreference
<
U
>
(
)
)
>
>
;
}
constexpr
bool
IsRefCountPreferenceOverridden
(
.
.
.
)
{
return
false
;
}
template
<
typename
T
typename
U
typename
V
>
constexpr
void
AssertRefCountBaseMatches
(
const
T
*
const
RefCounted
<
U
V
>
*
)
{
static_assert
(
std
:
:
is_base_of_v
<
U
T
>
"
T
implements
RefCounted
<
U
>
but
U
is
not
a
base
of
T
.
"
)
;
}
template
<
typename
T
typename
U
typename
V
>
constexpr
void
AssertRefCountBaseMatches
(
const
T
*
const
RefCountedThreadSafe
<
U
V
>
*
)
{
static_assert
(
std
:
:
is_base_of_v
<
U
T
>
"
T
implements
RefCountedThreadSafe
<
U
>
but
U
is
not
a
base
of
T
.
"
)
;
}
template
<
typename
T
typename
U
>
constexpr
void
AssertRefCountBaseMatches
(
const
T
*
const
RefCountedDeleteOnSequence
<
U
>
*
)
{
static_assert
(
std
:
:
is_base_of_v
<
U
T
>
"
T
implements
RefCountedDeleteOnSequence
<
U
>
but
U
is
not
a
base
of
T
.
"
)
;
}
constexpr
void
AssertRefCountBaseMatches
(
.
.
.
)
{
}
}
template
<
typename
T
>
scoped_refptr
<
T
>
AdoptRef
(
T
*
obj
)
{
using
Tag
=
std
:
:
decay_t
<
decltype
(
subtle
:
:
GetRefCountPreference
<
T
>
(
)
)
>
;
static_assert
(
std
:
:
is_same_v
<
subtle
:
:
StartRefCountFromOneTag
Tag
>
"
Use
AdoptRef
only
if
the
reference
count
starts
from
one
.
"
)
;
DCHECK
(
obj
)
;
DCHECK
(
obj
-
>
HasOneRef
(
)
)
;
obj
-
>
Adopted
(
)
;
return
scoped_refptr
<
T
>
(
obj
subtle
:
:
kAdoptRefTag
)
;
}
namespace
subtle
{
template
<
typename
T
>
scoped_refptr
<
T
>
AdoptRefIfNeeded
(
T
*
obj
StartRefCountFromZeroTag
)
{
return
scoped_refptr
<
T
>
(
obj
)
;
}
template
<
typename
T
>
scoped_refptr
<
T
>
AdoptRefIfNeeded
(
T
*
obj
StartRefCountFromOneTag
)
{
return
AdoptRef
(
obj
)
;
}
}
template
<
typename
T
typename
.
.
.
Args
>
scoped_refptr
<
T
>
MakeRefCounted
(
Args
&
&
.
.
.
args
)
{
T
*
obj
=
new
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
subtle
:
:
AdoptRefIfNeeded
(
obj
subtle
:
:
GetRefCountPreference
<
T
>
(
)
)
;
}
template
<
typename
T
>
scoped_refptr
<
T
>
WrapRefCounted
(
T
*
t
)
{
return
scoped_refptr
<
T
>
(
t
)
;
}
}
template
<
class
T
>
class
TRIVIAL_ABI
scoped_refptr
{
public
:
typedef
T
element_type
;
constexpr
scoped_refptr
(
)
=
default
;
constexpr
scoped_refptr
(
std
:
:
nullptr_t
)
{
}
scoped_refptr
(
T
*
p
)
:
ptr_
(
p
)
{
if
(
ptr_
)
AddRef
(
ptr_
)
;
}
scoped_refptr
(
const
scoped_refptr
&
r
)
:
scoped_refptr
(
r
.
ptr_
)
{
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
>
>
scoped_refptr
(
const
scoped_refptr
<
U
>
&
r
)
:
scoped_refptr
(
r
.
ptr_
)
{
}
scoped_refptr
(
scoped_refptr
&
&
r
)
noexcept
:
ptr_
(
r
.
ptr_
)
{
r
.
ptr_
=
nullptr
;
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
>
>
scoped_refptr
(
scoped_refptr
<
U
>
&
&
r
)
noexcept
:
ptr_
(
r
.
ptr_
)
{
r
.
ptr_
=
nullptr
;
}
~
scoped_refptr
(
)
{
static_assert
(
!
base
:
:
subtle
:
:
IsRefCountPreferenceOverridden
(
static_cast
<
T
*
>
(
nullptr
)
static_cast
<
T
*
>
(
nullptr
)
)
"
It
'
s
unsafe
to
override
the
ref
count
preference
.
"
"
Please
remove
REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE
"
"
from
subclasses
.
"
)
;
if
(
ptr_
)
Release
(
ptr_
)
;
}
T
*
get
(
)
const
{
return
ptr_
;
}
T
&
operator
*
(
)
const
{
DCHECK
(
ptr_
)
;
return
*
ptr_
;
}
T
*
operator
-
>
(
)
const
{
DCHECK
(
ptr_
)
;
return
ptr_
;
}
scoped_refptr
&
operator
=
(
std
:
:
nullptr_t
)
{
reset
(
)
;
return
*
this
;
}
scoped_refptr
&
operator
=
(
T
*
p
)
{
return
*
this
=
scoped_refptr
(
p
)
;
}
scoped_refptr
&
operator
=
(
scoped_refptr
r
)
noexcept
{
swap
(
r
)
;
return
*
this
;
}
void
reset
(
)
{
scoped_refptr
(
)
.
swap
(
*
this
)
;
}
[
[
nodiscard
]
]
T
*
release
(
)
;
void
swap
(
scoped_refptr
&
r
)
noexcept
{
std
:
:
swap
(
ptr_
r
.
ptr_
)
;
}
explicit
operator
bool
(
)
const
{
return
ptr_
!
=
nullptr
;
}
template
<
typename
U
>
bool
operator
=
=
(
const
scoped_refptr
<
U
>
&
rhs
)
const
{
return
ptr_
=
=
rhs
.
get
(
)
;
}
template
<
typename
U
>
bool
operator
!
=
(
const
scoped_refptr
<
U
>
&
rhs
)
const
{
return
!
operator
=
=
(
rhs
)
;
}
template
<
typename
U
>
bool
operator
<
(
const
scoped_refptr
<
U
>
&
rhs
)
const
{
return
ptr_
<
rhs
.
get
(
)
;
}
protected
:
RAW_PTR_EXCLUSION
T
*
ptr_
=
nullptr
;
private
:
template
<
typename
U
>
friend
scoped_refptr
<
U
>
base
:
:
AdoptRef
(
U
*
)
;
friend
class
:
:
base
:
:
SequencedTaskRunner
;
scoped_refptr
(
T
*
p
base
:
:
subtle
:
:
AdoptRefTag
)
:
ptr_
(
p
)
{
}
template
<
typename
U
>
friend
class
scoped_refptr
;
static
void
AddRef
(
T
*
ptr
)
;
static
void
Release
(
T
*
ptr
)
;
}
;
template
<
typename
T
>
T
*
scoped_refptr
<
T
>
:
:
release
(
)
{
T
*
ptr
=
ptr_
;
ptr_
=
nullptr
;
return
ptr
;
}
template
<
typename
T
>
void
scoped_refptr
<
T
>
:
:
AddRef
(
T
*
ptr
)
{
base
:
:
subtle
:
:
AssertRefCountBaseMatches
(
ptr
ptr
)
;
ptr
-
>
AddRef
(
)
;
}
template
<
typename
T
>
void
scoped_refptr
<
T
>
:
:
Release
(
T
*
ptr
)
{
base
:
:
subtle
:
:
AssertRefCountBaseMatches
(
ptr
ptr
)
;
ptr
-
>
Release
(
)
;
}
template
<
typename
T
typename
U
>
bool
operator
=
=
(
const
scoped_refptr
<
T
>
&
lhs
const
U
*
rhs
)
{
return
lhs
.
get
(
)
=
=
rhs
;
}
template
<
typename
T
typename
U
>
bool
operator
=
=
(
const
T
*
lhs
const
scoped_refptr
<
U
>
&
rhs
)
{
return
lhs
=
=
rhs
.
get
(
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
const
scoped_refptr
<
T
>
&
lhs
std
:
:
nullptr_t
null
)
{
return
!
static_cast
<
bool
>
(
lhs
)
;
}
template
<
typename
T
>
bool
operator
=
=
(
std
:
:
nullptr_t
null
const
scoped_refptr
<
T
>
&
rhs
)
{
return
!
static_cast
<
bool
>
(
rhs
)
;
}
template
<
typename
T
typename
U
>
bool
operator
!
=
(
const
scoped_refptr
<
T
>
&
lhs
const
U
*
rhs
)
{
return
!
operator
=
=
(
lhs
rhs
)
;
}
template
<
typename
T
typename
U
>
bool
operator
!
=
(
const
T
*
lhs
const
scoped_refptr
<
U
>
&
rhs
)
{
return
!
operator
=
=
(
lhs
rhs
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
const
scoped_refptr
<
T
>
&
lhs
std
:
:
nullptr_t
null
)
{
return
!
operator
=
=
(
lhs
null
)
;
}
template
<
typename
T
>
bool
operator
!
=
(
std
:
:
nullptr_t
null
const
scoped_refptr
<
T
>
&
rhs
)
{
return
!
operator
=
=
(
null
rhs
)
;
}
template
<
typename
T
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
scoped_refptr
<
T
>
&
p
)
{
return
out
<
<
p
.
get
(
)
;
}
template
<
typename
T
>
void
swap
(
scoped_refptr
<
T
>
&
lhs
scoped_refptr
<
T
>
&
rhs
)
noexcept
{
lhs
.
swap
(
rhs
)
;
}
#
endif
