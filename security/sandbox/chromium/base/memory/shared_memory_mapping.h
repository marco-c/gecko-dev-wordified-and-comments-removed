#
ifndef
BASE_MEMORY_SHARED_MEMORY_MAPPING_H_
#
define
BASE_MEMORY_SHARED_MEMORY_MAPPING_H_
#
include
<
cstddef
>
#
include
<
type_traits
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
containers
/
span
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
memory
/
shared_memory_mapper
.
h
"
#
include
"
base
/
unguessable_token
.
h
"
namespace
base
{
namespace
subtle
{
class
PlatformSharedMemoryRegion
;
}
class
BASE_EXPORT
SharedMemoryMapping
{
public
:
SharedMemoryMapping
(
)
;
SharedMemoryMapping
(
SharedMemoryMapping
&
&
mapping
)
noexcept
;
SharedMemoryMapping
&
operator
=
(
SharedMemoryMapping
&
&
mapping
)
noexcept
;
SharedMemoryMapping
(
const
SharedMemoryMapping
&
)
=
delete
;
SharedMemoryMapping
&
operator
=
(
const
SharedMemoryMapping
&
)
=
delete
;
virtual
~
SharedMemoryMapping
(
)
;
bool
IsValid
(
)
const
{
return
!
mapped_span_
.
empty
(
)
;
}
size_t
size
(
)
const
{
DCHECK
(
IsValid
(
)
)
;
return
size_
;
}
size_t
mapped_size
(
)
const
{
DCHECK
(
IsValid
(
)
)
;
return
mapped_span_
.
size
(
)
;
}
const
UnguessableToken
&
guid
(
)
const
{
DCHECK
(
IsValid
(
)
)
;
return
guid_
;
}
protected
:
SharedMemoryMapping
(
span
<
uint8_t
>
mapped_span
size_t
size
const
UnguessableToken
&
guid
SharedMemoryMapper
*
mapper
)
;
void
*
raw_memory_ptr
(
)
const
{
return
reinterpret_cast
<
void
*
>
(
mapped_span_
.
data
(
)
)
;
}
private
:
friend
class
SharedMemoryTracker
;
void
Unmap
(
)
;
span
<
uint8_t
>
mapped_span_
;
size_t
size_
=
0
;
UnguessableToken
guid_
;
raw_ptr
<
SharedMemoryMapper
>
mapper_
=
nullptr
;
}
;
class
BASE_EXPORT
ReadOnlySharedMemoryMapping
:
public
SharedMemoryMapping
{
public
:
ReadOnlySharedMemoryMapping
(
)
;
ReadOnlySharedMemoryMapping
(
const
ReadOnlySharedMemoryMapping
&
)
=
delete
;
ReadOnlySharedMemoryMapping
&
operator
=
(
const
ReadOnlySharedMemoryMapping
&
)
=
delete
;
ReadOnlySharedMemoryMapping
(
ReadOnlySharedMemoryMapping
&
&
)
noexcept
;
ReadOnlySharedMemoryMapping
&
operator
=
(
ReadOnlySharedMemoryMapping
&
&
)
noexcept
;
const
void
*
memory
(
)
const
{
return
raw_memory_ptr
(
)
;
}
template
<
typename
T
>
const
T
*
GetMemoryAs
(
)
const
{
static_assert
(
std
:
:
is_trivially_copyable_v
<
T
>
"
Copying
non
-
trivially
-
copyable
object
across
memory
spaces
"
"
is
dangerous
"
)
;
if
(
!
IsValid
(
)
)
return
nullptr
;
if
(
sizeof
(
T
)
>
size
(
)
)
return
nullptr
;
return
static_cast
<
const
T
*
>
(
raw_memory_ptr
(
)
)
;
}
template
<
typename
T
>
span
<
const
T
>
GetMemoryAsSpan
(
)
const
{
static_assert
(
std
:
:
is_trivially_copyable_v
<
T
>
"
Copying
non
-
trivially
-
copyable
object
across
memory
spaces
"
"
is
dangerous
"
)
;
if
(
!
IsValid
(
)
)
return
span
<
const
T
>
(
)
;
size_t
count
=
size
(
)
/
sizeof
(
T
)
;
return
GetMemoryAsSpan
<
T
>
(
count
)
;
}
template
<
typename
T
>
span
<
const
T
>
GetMemoryAsSpan
(
size_t
count
)
const
{
static_assert
(
std
:
:
is_trivially_copyable_v
<
T
>
"
Copying
non
-
trivially
-
copyable
object
across
memory
spaces
"
"
is
dangerous
"
)
;
if
(
!
IsValid
(
)
)
return
span
<
const
T
>
(
)
;
if
(
size
(
)
/
sizeof
(
T
)
<
count
)
return
span
<
const
T
>
(
)
;
return
span
<
const
T
>
(
static_cast
<
const
T
*
>
(
raw_memory_ptr
(
)
)
count
)
;
}
private
:
friend
class
ReadOnlySharedMemoryRegion
;
ReadOnlySharedMemoryMapping
(
span
<
uint8_t
>
mapped_span
size_t
size
const
UnguessableToken
&
guid
SharedMemoryMapper
*
mapper
)
;
}
;
class
BASE_EXPORT
WritableSharedMemoryMapping
:
public
SharedMemoryMapping
{
public
:
WritableSharedMemoryMapping
(
)
;
WritableSharedMemoryMapping
(
const
WritableSharedMemoryMapping
&
)
=
delete
;
WritableSharedMemoryMapping
&
operator
=
(
const
WritableSharedMemoryMapping
&
)
=
delete
;
WritableSharedMemoryMapping
(
WritableSharedMemoryMapping
&
&
)
noexcept
;
WritableSharedMemoryMapping
&
operator
=
(
WritableSharedMemoryMapping
&
&
)
noexcept
;
void
*
memory
(
)
const
{
return
raw_memory_ptr
(
)
;
}
template
<
typename
T
>
T
*
GetMemoryAs
(
)
const
{
static_assert
(
std
:
:
is_trivially_copyable_v
<
T
>
"
Copying
non
-
trivially
-
copyable
object
across
memory
spaces
"
"
is
dangerous
"
)
;
if
(
!
IsValid
(
)
)
return
nullptr
;
if
(
sizeof
(
T
)
>
size
(
)
)
return
nullptr
;
return
static_cast
<
T
*
>
(
raw_memory_ptr
(
)
)
;
}
template
<
typename
T
>
span
<
T
>
GetMemoryAsSpan
(
)
const
{
static_assert
(
std
:
:
is_trivially_copyable_v
<
T
>
"
Copying
non
-
trivially
-
copyable
object
across
memory
spaces
"
"
is
dangerous
"
)
;
if
(
!
IsValid
(
)
)
return
span
<
T
>
(
)
;
size_t
count
=
size
(
)
/
sizeof
(
T
)
;
return
GetMemoryAsSpan
<
T
>
(
count
)
;
}
template
<
typename
T
>
span
<
T
>
GetMemoryAsSpan
(
size_t
count
)
const
{
static_assert
(
std
:
:
is_trivially_copyable_v
<
T
>
"
Copying
non
-
trivially
-
copyable
object
across
memory
spaces
"
"
is
dangerous
"
)
;
if
(
!
IsValid
(
)
)
return
span
<
T
>
(
)
;
if
(
size
(
)
/
sizeof
(
T
)
<
count
)
return
span
<
T
>
(
)
;
return
span
<
T
>
(
static_cast
<
T
*
>
(
raw_memory_ptr
(
)
)
count
)
;
}
private
:
friend
WritableSharedMemoryMapping
MapAtForTesting
(
subtle
:
:
PlatformSharedMemoryRegion
*
region
uint64_t
offset
size_t
size
)
;
friend
class
ReadOnlySharedMemoryRegion
;
friend
class
WritableSharedMemoryRegion
;
friend
class
UnsafeSharedMemoryRegion
;
WritableSharedMemoryMapping
(
span
<
uint8_t
>
mapped_span
size_t
size
const
UnguessableToken
&
guid
SharedMemoryMapper
*
mapper
)
;
}
;
}
#
endif
