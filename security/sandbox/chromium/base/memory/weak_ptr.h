#
ifndef
BASE_MEMORY_WEAK_PTR_H_
#
define
BASE_MEMORY_WEAK_PTR_H_
#
include
<
cstddef
>
#
include
<
type_traits
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
memory
/
ref_counted
.
h
"
#
include
"
base
/
sequence_checker
.
h
"
#
include
"
base
/
synchronization
/
atomic_flag
.
h
"
namespace
base
{
template
<
typename
T
>
class
SupportsWeakPtr
;
template
<
typename
T
>
class
WeakPtr
;
namespace
internal
{
class
BASE_EXPORT
WeakReference
{
public
:
class
BASE_EXPORT
Flag
:
public
RefCountedThreadSafe
<
Flag
>
{
public
:
Flag
(
)
;
void
Invalidate
(
)
;
bool
IsValid
(
)
const
;
bool
MaybeValid
(
)
const
;
void
DetachFromSequence
(
)
;
private
:
friend
class
base
:
:
RefCountedThreadSafe
<
Flag
>
;
~
Flag
(
)
;
SEQUENCE_CHECKER
(
sequence_checker_
)
;
AtomicFlag
invalidated_
;
}
;
WeakReference
(
)
;
explicit
WeakReference
(
const
scoped_refptr
<
Flag
>
&
flag
)
;
~
WeakReference
(
)
;
WeakReference
(
WeakReference
&
&
other
)
noexcept
;
WeakReference
(
const
WeakReference
&
other
)
;
WeakReference
&
operator
=
(
WeakReference
&
&
other
)
noexcept
=
default
;
WeakReference
&
operator
=
(
const
WeakReference
&
other
)
=
default
;
bool
IsValid
(
)
const
;
bool
MaybeValid
(
)
const
;
private
:
scoped_refptr
<
const
Flag
>
flag_
;
}
;
class
BASE_EXPORT
WeakReferenceOwner
{
public
:
WeakReferenceOwner
(
)
;
~
WeakReferenceOwner
(
)
;
WeakReference
GetRef
(
)
const
;
bool
HasRefs
(
)
const
{
return
!
flag_
-
>
HasOneRef
(
)
;
}
void
Invalidate
(
)
;
private
:
scoped_refptr
<
WeakReference
:
:
Flag
>
flag_
;
}
;
class
BASE_EXPORT
WeakPtrBase
{
public
:
WeakPtrBase
(
)
;
~
WeakPtrBase
(
)
;
WeakPtrBase
(
const
WeakPtrBase
&
other
)
=
default
;
WeakPtrBase
(
WeakPtrBase
&
&
other
)
noexcept
=
default
;
WeakPtrBase
&
operator
=
(
const
WeakPtrBase
&
other
)
=
default
;
WeakPtrBase
&
operator
=
(
WeakPtrBase
&
&
other
)
noexcept
=
default
;
void
reset
(
)
{
ref_
=
internal
:
:
WeakReference
(
)
;
ptr_
=
0
;
}
protected
:
WeakPtrBase
(
const
WeakReference
&
ref
uintptr_t
ptr
)
;
WeakReference
ref_
;
uintptr_t
ptr_
;
}
;
class
SupportsWeakPtrBase
{
public
:
template
<
typename
Derived
>
static
WeakPtr
<
Derived
>
StaticAsWeakPtr
(
Derived
*
t
)
{
static_assert
(
std
:
:
is_base_of
<
internal
:
:
SupportsWeakPtrBase
Derived
>
:
:
value
"
AsWeakPtr
argument
must
inherit
from
SupportsWeakPtr
"
)
;
return
AsWeakPtrImpl
<
Derived
>
(
t
)
;
}
private
:
template
<
typename
Derived
typename
Base
>
static
WeakPtr
<
Derived
>
AsWeakPtrImpl
(
SupportsWeakPtr
<
Base
>
*
t
)
{
WeakPtr
<
Base
>
ptr
=
t
-
>
AsWeakPtr
(
)
;
return
WeakPtr
<
Derived
>
(
ptr
.
ref_
static_cast
<
Derived
*
>
(
reinterpret_cast
<
Base
*
>
(
ptr
.
ptr_
)
)
)
;
}
}
;
}
template
<
typename
T
>
class
WeakPtrFactory
;
template
<
typename
T
>
class
WeakPtr
:
public
internal
:
:
WeakPtrBase
{
public
:
WeakPtr
(
)
=
default
;
WeakPtr
(
std
:
:
nullptr_t
)
{
}
template
<
typename
U
>
WeakPtr
(
const
WeakPtr
<
U
>
&
other
)
:
WeakPtrBase
(
other
)
{
T
*
t
=
reinterpret_cast
<
U
*
>
(
other
.
ptr_
)
;
ptr_
=
reinterpret_cast
<
uintptr_t
>
(
t
)
;
}
template
<
typename
U
>
WeakPtr
(
WeakPtr
<
U
>
&
&
other
)
noexcept
:
WeakPtrBase
(
std
:
:
move
(
other
)
)
{
T
*
t
=
reinterpret_cast
<
U
*
>
(
other
.
ptr_
)
;
ptr_
=
reinterpret_cast
<
uintptr_t
>
(
t
)
;
}
T
*
get
(
)
const
{
return
ref_
.
IsValid
(
)
?
reinterpret_cast
<
T
*
>
(
ptr_
)
:
nullptr
;
}
T
&
operator
*
(
)
const
{
DCHECK
(
get
(
)
!
=
nullptr
)
;
return
*
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
DCHECK
(
get
(
)
!
=
nullptr
)
;
return
get
(
)
;
}
explicit
operator
bool
(
)
const
{
return
get
(
)
!
=
nullptr
;
}
bool
MaybeValid
(
)
const
{
return
ref_
.
MaybeValid
(
)
;
}
bool
WasInvalidated
(
)
const
{
return
ptr_
&
&
!
ref_
.
IsValid
(
)
;
}
private
:
friend
class
internal
:
:
SupportsWeakPtrBase
;
template
<
typename
U
>
friend
class
WeakPtr
;
friend
class
SupportsWeakPtr
<
T
>
;
friend
class
WeakPtrFactory
<
T
>
;
WeakPtr
(
const
internal
:
:
WeakReference
&
ref
T
*
ptr
)
:
WeakPtrBase
(
ref
reinterpret_cast
<
uintptr_t
>
(
ptr
)
)
{
}
}
;
template
<
class
T
>
bool
operator
!
=
(
const
WeakPtr
<
T
>
&
weak_ptr
std
:
:
nullptr_t
)
{
return
!
(
weak_ptr
=
=
nullptr
)
;
}
template
<
class
T
>
bool
operator
!
=
(
std
:
:
nullptr_t
const
WeakPtr
<
T
>
&
weak_ptr
)
{
return
weak_ptr
!
=
nullptr
;
}
template
<
class
T
>
bool
operator
=
=
(
const
WeakPtr
<
T
>
&
weak_ptr
std
:
:
nullptr_t
)
{
return
weak_ptr
.
get
(
)
=
=
nullptr
;
}
template
<
class
T
>
bool
operator
=
=
(
std
:
:
nullptr_t
const
WeakPtr
<
T
>
&
weak_ptr
)
{
return
weak_ptr
=
=
nullptr
;
}
namespace
internal
{
class
BASE_EXPORT
WeakPtrFactoryBase
{
protected
:
WeakPtrFactoryBase
(
uintptr_t
ptr
)
;
~
WeakPtrFactoryBase
(
)
;
internal
:
:
WeakReferenceOwner
weak_reference_owner_
;
uintptr_t
ptr_
;
}
;
}
template
<
class
T
>
class
WeakPtrFactory
:
public
internal
:
:
WeakPtrFactoryBase
{
public
:
explicit
WeakPtrFactory
(
T
*
ptr
)
:
WeakPtrFactoryBase
(
reinterpret_cast
<
uintptr_t
>
(
ptr
)
)
{
}
~
WeakPtrFactory
(
)
=
default
;
WeakPtr
<
T
>
GetWeakPtr
(
)
{
return
WeakPtr
<
T
>
(
weak_reference_owner_
.
GetRef
(
)
reinterpret_cast
<
T
*
>
(
ptr_
)
)
;
}
void
InvalidateWeakPtrs
(
)
{
DCHECK
(
ptr_
)
;
weak_reference_owner_
.
Invalidate
(
)
;
}
bool
HasWeakPtrs
(
)
const
{
DCHECK
(
ptr_
)
;
return
weak_reference_owner_
.
HasRefs
(
)
;
}
private
:
DISALLOW_IMPLICIT_CONSTRUCTORS
(
WeakPtrFactory
)
;
}
;
template
<
class
T
>
class
SupportsWeakPtr
:
public
internal
:
:
SupportsWeakPtrBase
{
public
:
SupportsWeakPtr
(
)
=
default
;
WeakPtr
<
T
>
AsWeakPtr
(
)
{
return
WeakPtr
<
T
>
(
weak_reference_owner_
.
GetRef
(
)
static_cast
<
T
*
>
(
this
)
)
;
}
protected
:
~
SupportsWeakPtr
(
)
=
default
;
private
:
internal
:
:
WeakReferenceOwner
weak_reference_owner_
;
DISALLOW_COPY_AND_ASSIGN
(
SupportsWeakPtr
)
;
}
;
template
<
typename
Derived
>
WeakPtr
<
Derived
>
AsWeakPtr
(
Derived
*
t
)
{
return
internal
:
:
SupportsWeakPtrBase
:
:
StaticAsWeakPtr
<
Derived
>
(
t
)
;
}
}
#
endif
