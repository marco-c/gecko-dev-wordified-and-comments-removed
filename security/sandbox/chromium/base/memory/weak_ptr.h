#
ifndef
BASE_MEMORY_WEAK_PTR_H_
#
define
BASE_MEMORY_WEAK_PTR_H_
#
include
<
cstddef
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
memory
/
ref_counted
.
h
"
#
include
"
base
/
memory
/
safe_ref_traits
.
h
"
#
include
"
base
/
sequence_checker
.
h
"
#
include
"
base
/
synchronization
/
atomic_flag
.
h
"
#
include
"
base
/
types
/
pass_key
.
h
"
namespace
base
{
namespace
sequence_manager
:
:
internal
{
class
TaskQueueImpl
;
}
template
<
typename
T
>
class
SupportsWeakPtr
;
template
<
typename
T
>
class
WeakPtr
;
namespace
internal
{
class
BASE_EXPORT
TRIVIAL_ABI
WeakReference
{
public
:
class
BASE_EXPORT
Flag
:
public
RefCountedThreadSafe
<
Flag
>
{
public
:
Flag
(
)
;
void
Invalidate
(
)
;
bool
IsValid
(
)
const
;
bool
MaybeValid
(
)
const
;
#
if
DCHECK_IS_ON
(
)
void
DetachFromSequence
(
)
;
void
BindToCurrentSequence
(
)
;
#
endif
private
:
friend
class
base
:
:
RefCountedThreadSafe
<
Flag
>
;
~
Flag
(
)
;
SEQUENCE_CHECKER
(
sequence_checker_
)
;
AtomicFlag
invalidated_
;
}
;
WeakReference
(
)
;
explicit
WeakReference
(
const
scoped_refptr
<
Flag
>
&
flag
)
;
~
WeakReference
(
)
;
WeakReference
(
const
WeakReference
&
other
)
;
WeakReference
&
operator
=
(
const
WeakReference
&
other
)
;
WeakReference
(
WeakReference
&
&
other
)
noexcept
;
WeakReference
&
operator
=
(
WeakReference
&
&
other
)
noexcept
;
void
Reset
(
)
;
bool
IsValid
(
)
const
;
bool
MaybeValid
(
)
const
;
private
:
scoped_refptr
<
const
Flag
>
flag_
;
}
;
class
BASE_EXPORT
WeakReferenceOwner
{
public
:
WeakReferenceOwner
(
)
;
~
WeakReferenceOwner
(
)
;
WeakReference
GetRef
(
)
const
;
bool
HasRefs
(
)
const
{
return
!
flag_
-
>
HasOneRef
(
)
;
}
void
Invalidate
(
)
;
void
BindToCurrentSequence
(
)
;
private
:
scoped_refptr
<
WeakReference
:
:
Flag
>
flag_
;
}
;
class
SupportsWeakPtrBase
{
public
:
template
<
typename
Derived
>
static
WeakPtr
<
Derived
>
StaticAsWeakPtr
(
Derived
*
t
)
{
static_assert
(
std
:
:
is_base_of_v
<
internal
:
:
SupportsWeakPtrBase
Derived
>
"
AsWeakPtr
argument
must
inherit
from
SupportsWeakPtr
"
)
;
using
Base
=
typename
decltype
(
ExtractSinglyInheritedBase
(
t
)
)
:
:
Base
;
WeakPtr
<
Base
>
weak
=
static_cast
<
SupportsWeakPtr
<
Base
>
*
>
(
t
)
-
>
AsWeakPtr
(
)
;
return
WeakPtr
<
Derived
>
(
weak
.
CloneWeakReference
(
)
static_cast
<
Derived
*
>
(
weak
.
ptr_
)
)
;
}
private
:
template
<
typename
T
>
struct
ExtractSinglyInheritedBase
;
template
<
typename
T
>
struct
ExtractSinglyInheritedBase
<
SupportsWeakPtr
<
T
>
>
{
using
Base
=
T
;
explicit
ExtractSinglyInheritedBase
(
SupportsWeakPtr
<
T
>
*
)
;
}
;
#
if
!
defined
(
MOZ_SANDBOX
)
template
<
typename
T
>
ExtractSinglyInheritedBase
(
SupportsWeakPtr
<
T
>
*
)
-
>
ExtractSinglyInheritedBase
<
SupportsWeakPtr
<
T
>
>
;
#
endif
}
;
template
<
typename
T
>
SafeRef
<
T
>
MakeSafeRefFromWeakPtrInternals
(
internal
:
:
WeakReference
&
&
ref
T
*
ptr
)
;
}
template
<
typename
T
>
class
WeakPtrFactory
;
template
<
typename
T
>
class
TRIVIAL_ABI
WeakPtr
{
public
:
WeakPtr
(
)
=
default
;
WeakPtr
(
std
:
:
nullptr_t
)
{
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
>
>
WeakPtr
(
const
WeakPtr
<
U
>
&
other
)
:
ref_
(
other
.
ref_
)
ptr_
(
other
.
ptr_
)
{
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
>
>
WeakPtr
&
operator
=
(
const
WeakPtr
<
U
>
&
other
)
{
ref_
=
other
.
ref_
;
ptr_
=
other
.
ptr_
;
return
*
this
;
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
>
>
WeakPtr
(
WeakPtr
<
U
>
&
&
other
)
:
ref_
(
std
:
:
move
(
other
.
ref_
)
)
ptr_
(
std
:
:
move
(
other
.
ptr_
)
)
{
}
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
U
*
T
*
>
>
>
WeakPtr
&
operator
=
(
WeakPtr
<
U
>
&
&
other
)
{
ref_
=
std
:
:
move
(
other
.
ref_
)
;
ptr_
=
std
:
:
move
(
other
.
ptr_
)
;
return
*
this
;
}
T
*
get
(
)
const
{
return
ref_
.
IsValid
(
)
?
ptr_
:
nullptr
;
}
T
&
operator
*
(
)
const
{
CHECK
(
ref_
.
IsValid
(
)
)
;
return
*
ptr_
;
}
T
*
operator
-
>
(
)
const
{
CHECK
(
ref_
.
IsValid
(
)
)
;
return
ptr_
;
}
explicit
operator
bool
(
)
const
{
return
get
(
)
!
=
nullptr
;
}
void
reset
(
)
{
ref_
.
Reset
(
)
;
ptr_
=
nullptr
;
}
bool
MaybeValid
(
)
const
{
return
ref_
.
MaybeValid
(
)
;
}
bool
WasInvalidated
(
)
const
{
return
ptr_
&
&
!
ref_
.
IsValid
(
)
;
}
private
:
friend
class
internal
:
:
SupportsWeakPtrBase
;
template
<
typename
U
>
friend
class
WeakPtr
;
friend
class
SupportsWeakPtr
<
T
>
;
friend
class
WeakPtrFactory
<
T
>
;
friend
class
WeakPtrFactory
<
std
:
:
remove_const_t
<
T
>
>
;
WeakPtr
(
internal
:
:
WeakReference
&
&
ref
T
*
ptr
)
:
ref_
(
std
:
:
move
(
ref
)
)
ptr_
(
ptr
)
{
DCHECK
(
ptr
)
;
}
internal
:
:
WeakReference
CloneWeakReference
(
)
const
{
return
ref_
;
}
internal
:
:
WeakReference
ref_
;
RAW_PTR_EXCLUSION
T
*
ptr_
=
nullptr
;
}
;
template
<
class
T
>
bool
operator
!
=
(
const
WeakPtr
<
T
>
&
weak_ptr
std
:
:
nullptr_t
)
{
return
!
(
weak_ptr
=
=
nullptr
)
;
}
template
<
class
T
>
bool
operator
!
=
(
std
:
:
nullptr_t
const
WeakPtr
<
T
>
&
weak_ptr
)
{
return
weak_ptr
!
=
nullptr
;
}
template
<
class
T
>
bool
operator
=
=
(
const
WeakPtr
<
T
>
&
weak_ptr
std
:
:
nullptr_t
)
{
return
weak_ptr
.
get
(
)
=
=
nullptr
;
}
template
<
class
T
>
bool
operator
=
=
(
std
:
:
nullptr_t
const
WeakPtr
<
T
>
&
weak_ptr
)
{
return
weak_ptr
=
=
nullptr
;
}
namespace
internal
{
class
BASE_EXPORT
WeakPtrFactoryBase
{
protected
:
WeakPtrFactoryBase
(
uintptr_t
ptr
)
;
~
WeakPtrFactoryBase
(
)
;
internal
:
:
WeakReferenceOwner
weak_reference_owner_
;
uintptr_t
ptr_
;
}
;
}
template
<
class
T
>
class
WeakPtrFactory
:
public
internal
:
:
WeakPtrFactoryBase
{
public
:
WeakPtrFactory
(
)
=
delete
;
explicit
WeakPtrFactory
(
T
*
ptr
)
:
WeakPtrFactoryBase
(
reinterpret_cast
<
uintptr_t
>
(
ptr
)
)
{
}
WeakPtrFactory
(
const
WeakPtrFactory
&
)
=
delete
;
WeakPtrFactory
&
operator
=
(
const
WeakPtrFactory
&
)
=
delete
;
~
WeakPtrFactory
(
)
=
default
;
WeakPtr
<
const
T
>
GetWeakPtr
(
)
const
{
return
WeakPtr
<
const
T
>
(
weak_reference_owner_
.
GetRef
(
)
reinterpret_cast
<
const
T
*
>
(
ptr_
)
)
;
}
template
<
int
&
.
.
.
ExplicitArgumentBarrier
typename
U
=
T
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_const_v
<
U
>
>
>
WeakPtr
<
T
>
GetWeakPtr
(
)
{
return
WeakPtr
<
T
>
(
weak_reference_owner_
.
GetRef
(
)
reinterpret_cast
<
T
*
>
(
ptr_
)
)
;
}
template
<
int
&
.
.
.
ExplicitArgumentBarrier
typename
U
=
T
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_const_v
<
U
>
>
>
WeakPtr
<
T
>
GetMutableWeakPtr
(
)
const
{
return
WeakPtr
<
T
>
(
weak_reference_owner_
.
GetRef
(
)
reinterpret_cast
<
T
*
>
(
ptr_
)
)
;
}
SafeRef
<
T
>
GetSafeRef
(
)
const
{
return
internal
:
:
MakeSafeRefFromWeakPtrInternals
(
weak_reference_owner_
.
GetRef
(
)
reinterpret_cast
<
T
*
>
(
ptr_
)
)
;
}
void
InvalidateWeakPtrs
(
)
{
DCHECK
(
ptr_
)
;
weak_reference_owner_
.
Invalidate
(
)
;
}
bool
HasWeakPtrs
(
)
const
{
DCHECK
(
ptr_
)
;
return
weak_reference_owner_
.
HasRefs
(
)
;
}
void
BindToCurrentSequence
(
PassKey
<
sequence_manager
:
:
internal
:
:
TaskQueueImpl
>
)
{
weak_reference_owner_
.
BindToCurrentSequence
(
)
;
}
}
;
template
<
class
T
>
class
SupportsWeakPtr
:
public
internal
:
:
SupportsWeakPtrBase
{
public
:
SupportsWeakPtr
(
)
=
default
;
SupportsWeakPtr
(
const
SupportsWeakPtr
&
)
=
delete
;
SupportsWeakPtr
&
operator
=
(
const
SupportsWeakPtr
&
)
=
delete
;
WeakPtr
<
T
>
AsWeakPtr
(
)
{
return
WeakPtr
<
T
>
(
weak_reference_owner_
.
GetRef
(
)
static_cast
<
T
*
>
(
this
)
)
;
}
protected
:
~
SupportsWeakPtr
(
)
=
default
;
private
:
internal
:
:
WeakReferenceOwner
weak_reference_owner_
;
}
;
template
<
typename
Derived
>
WeakPtr
<
Derived
>
AsWeakPtr
(
Derived
*
t
)
{
return
internal
:
:
SupportsWeakPtrBase
:
:
StaticAsWeakPtr
<
Derived
>
(
t
)
;
}
}
#
endif
