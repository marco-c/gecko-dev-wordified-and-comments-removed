#
ifndef
BASE_MEMORY_SINGLETON_H_
#
define
BASE_MEMORY_SINGLETON_H_
#
include
<
atomic
>
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
lazy_instance_helpers
.
h
"
#
include
"
base
/
threading
/
thread_restrictions
.
h
"
namespace
base
{
template
<
typename
Type
>
struct
DefaultSingletonTraits
{
static
Type
*
New
(
)
{
return
new
Type
(
)
;
}
static
void
Delete
(
Type
*
x
)
{
delete
x
;
}
static
const
bool
kRegisterAtExit
=
true
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
false
;
#
endif
}
;
template
<
typename
Type
>
struct
LeakySingletonTraits
:
public
DefaultSingletonTraits
<
Type
>
{
static
const
bool
kRegisterAtExit
=
false
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
true
;
#
endif
}
;
template
<
typename
Type
>
struct
StaticMemorySingletonTraits
{
static
Type
*
New
(
)
{
if
(
dead_
.
exchange
(
true
std
:
:
memory_order_relaxed
)
)
return
nullptr
;
return
new
(
buffer_
)
Type
(
)
;
}
static
void
Delete
(
Type
*
p
)
{
if
(
p
)
p
-
>
Type
:
:
~
Type
(
)
;
}
static
const
bool
kRegisterAtExit
=
true
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
true
;
#
endif
static
void
ResurrectForTesting
(
)
{
dead_
.
store
(
false
std
:
:
memory_order_relaxed
)
;
}
private
:
alignas
(
Type
)
static
char
buffer_
[
sizeof
(
Type
)
]
;
static
std
:
:
atomic
<
bool
>
dead_
;
}
;
template
<
typename
Type
>
alignas
(
Type
)
char
StaticMemorySingletonTraits
<
Type
>
:
:
buffer_
[
sizeof
(
Type
)
]
;
template
<
typename
Type
>
std
:
:
atomic
<
bool
>
StaticMemorySingletonTraits
<
Type
>
:
:
dead_
=
false
;
template
<
typename
Type
typename
Traits
=
DefaultSingletonTraits
<
Type
>
typename
DifferentiatingType
=
Type
>
class
Singleton
{
private
:
friend
Type
;
static
Type
*
get
(
)
{
#
if
DCHECK_IS_ON
(
)
if
(
!
Traits
:
:
kAllowedToAccessOnNonjoinableThread
)
internal
:
:
AssertSingletonAllowed
(
)
;
#
endif
return
subtle
:
:
GetOrCreateLazyPointer
(
instance_
&
CreatorFunc
nullptr
Traits
:
:
kRegisterAtExit
?
OnExit
:
nullptr
nullptr
)
;
}
static
Type
*
GetIfExists
(
)
{
#
if
DCHECK_IS_ON
(
)
if
(
!
Traits
:
:
kAllowedToAccessOnNonjoinableThread
)
internal
:
:
AssertSingletonAllowed
(
)
;
#
endif
if
(
!
instance_
.
load
(
std
:
:
memory_order_relaxed
)
)
return
nullptr
;
return
get
(
)
;
}
static
Type
*
CreatorFunc
(
void
*
)
{
return
Traits
:
:
New
(
)
;
}
static
void
OnExit
(
void
*
)
{
Traits
:
:
Delete
(
reinterpret_cast
<
Type
*
>
(
instance_
.
load
(
std
:
:
memory_order_relaxed
)
)
)
;
instance_
.
store
(
0
std
:
:
memory_order_relaxed
)
;
}
static
std
:
:
atomic
<
uintptr_t
>
instance_
;
}
;
template
<
typename
Type
typename
Traits
typename
DifferentiatingType
>
std
:
:
atomic
<
uintptr_t
>
Singleton
<
Type
Traits
DifferentiatingType
>
:
:
instance_
=
0
;
}
#
endif
