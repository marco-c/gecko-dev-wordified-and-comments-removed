#
ifndef
BASE_MEMORY_SINGLETON_H_
#
define
BASE_MEMORY_SINGLETON_H_
#
include
"
base
/
at_exit
.
h
"
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
memory
/
aligned_memory
.
h
"
#
include
"
base
/
threading
/
thread_restrictions
.
h
"
namespace
base
{
namespace
internal
{
static
const
subtle
:
:
AtomicWord
kBeingCreatedMarker
=
1
;
BASE_EXPORT
subtle
:
:
AtomicWord
WaitForInstance
(
subtle
:
:
AtomicWord
*
instance
)
;
class
DeleteTraceLogForTesting
;
}
template
<
typename
Type
>
struct
DefaultSingletonTraits
{
static
Type
*
New
(
)
{
return
new
Type
(
)
;
}
static
void
Delete
(
Type
*
x
)
{
delete
x
;
}
static
const
bool
kRegisterAtExit
=
true
;
#
ifndef
NDEBUG
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
false
;
#
endif
}
;
template
<
typename
Type
>
struct
LeakySingletonTraits
:
public
DefaultSingletonTraits
<
Type
>
{
static
const
bool
kRegisterAtExit
=
false
;
#
ifndef
NDEBUG
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
true
;
#
endif
}
;
template
<
typename
Type
>
struct
StaticMemorySingletonTraits
{
static
Type
*
New
(
)
{
if
(
subtle
:
:
NoBarrier_AtomicExchange
(
&
dead_
1
)
)
return
NULL
;
return
new
(
buffer_
.
void_data
(
)
)
Type
(
)
;
}
static
void
Delete
(
Type
*
p
)
{
if
(
p
!
=
NULL
)
p
-
>
Type
:
:
~
Type
(
)
;
}
static
const
bool
kRegisterAtExit
=
true
;
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
true
;
static
void
Resurrect
(
)
{
subtle
:
:
NoBarrier_Store
(
&
dead_
0
)
;
}
private
:
static
AlignedMemory
<
sizeof
(
Type
)
ALIGNOF
(
Type
)
>
buffer_
;
static
subtle
:
:
Atomic32
dead_
;
}
;
template
<
typename
Type
>
AlignedMemory
<
sizeof
(
Type
)
ALIGNOF
(
Type
)
>
StaticMemorySingletonTraits
<
Type
>
:
:
buffer_
;
template
<
typename
Type
>
subtle
:
:
Atomic32
StaticMemorySingletonTraits
<
Type
>
:
:
dead_
=
0
;
template
<
typename
Type
typename
Traits
=
DefaultSingletonTraits
<
Type
>
typename
DifferentiatingType
=
Type
>
class
Singleton
{
private
:
friend
Type
*
Type
:
:
GetInstance
(
)
;
friend
class
internal
:
:
DeleteTraceLogForTesting
;
static
Type
*
get
(
)
{
#
ifndef
NDEBUG
if
(
!
Traits
:
:
kAllowedToAccessOnNonjoinableThread
)
ThreadRestrictions
:
:
AssertSingletonAllowed
(
)
;
#
endif
subtle
:
:
AtomicWord
value
=
subtle
:
:
Acquire_Load
(
&
instance_
)
;
if
(
value
!
=
0
&
&
value
!
=
internal
:
:
kBeingCreatedMarker
)
{
return
reinterpret_cast
<
Type
*
>
(
value
)
;
}
if
(
subtle
:
:
Acquire_CompareAndSwap
(
&
instance_
0
internal
:
:
kBeingCreatedMarker
)
=
=
0
)
{
Type
*
newval
=
Traits
:
:
New
(
)
;
subtle
:
:
Release_Store
(
&
instance_
reinterpret_cast
<
subtle
:
:
AtomicWord
>
(
newval
)
)
;
if
(
newval
!
=
NULL
&
&
Traits
:
:
kRegisterAtExit
)
AtExitManager
:
:
RegisterCallback
(
OnExit
NULL
)
;
return
newval
;
}
value
=
internal
:
:
WaitForInstance
(
&
instance_
)
;
return
reinterpret_cast
<
Type
*
>
(
value
)
;
}
static
void
OnExit
(
void
*
)
{
Traits
:
:
Delete
(
reinterpret_cast
<
Type
*
>
(
subtle
:
:
NoBarrier_Load
(
&
instance_
)
)
)
;
instance_
=
0
;
}
static
subtle
:
:
AtomicWord
instance_
;
}
;
template
<
typename
Type
typename
Traits
typename
DifferentiatingType
>
subtle
:
:
AtomicWord
Singleton
<
Type
Traits
DifferentiatingType
>
:
:
instance_
=
0
;
}
#
endif
