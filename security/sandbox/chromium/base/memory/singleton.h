#
ifndef
BASE_MEMORY_SINGLETON_H_
#
define
BASE_MEMORY_SINGLETON_H_
#
include
"
base
/
at_exit
.
h
"
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
lazy_instance_helpers
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
threading
/
thread_restrictions
.
h
"
namespace
base
{
template
<
typename
Type
>
struct
DefaultSingletonTraits
{
static
Type
*
New
(
)
{
return
new
Type
(
)
;
}
static
void
Delete
(
Type
*
x
)
{
delete
x
;
}
static
const
bool
kRegisterAtExit
=
true
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
false
;
#
endif
}
;
template
<
typename
Type
>
struct
LeakySingletonTraits
:
public
DefaultSingletonTraits
<
Type
>
{
static
const
bool
kRegisterAtExit
=
false
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
true
;
#
endif
}
;
template
<
typename
Type
>
struct
StaticMemorySingletonTraits
{
static
Type
*
New
(
)
{
if
(
subtle
:
:
NoBarrier_AtomicExchange
(
&
dead_
1
)
)
return
nullptr
;
return
new
(
buffer_
)
Type
(
)
;
}
static
void
Delete
(
Type
*
p
)
{
if
(
p
)
p
-
>
Type
:
:
~
Type
(
)
;
}
static
const
bool
kRegisterAtExit
=
true
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
true
;
#
endif
static
void
ResurrectForTesting
(
)
{
subtle
:
:
NoBarrier_Store
(
&
dead_
0
)
;
}
private
:
alignas
(
Type
)
static
char
buffer_
[
sizeof
(
Type
)
]
;
static
subtle
:
:
Atomic32
dead_
;
}
;
template
<
typename
Type
>
alignas
(
Type
)
char
StaticMemorySingletonTraits
<
Type
>
:
:
buffer_
[
sizeof
(
Type
)
]
;
template
<
typename
Type
>
subtle
:
:
Atomic32
StaticMemorySingletonTraits
<
Type
>
:
:
dead_
=
0
;
template
<
typename
Type
typename
Traits
=
DefaultSingletonTraits
<
Type
>
typename
DifferentiatingType
=
Type
>
class
Singleton
{
private
:
friend
Type
;
static
Type
*
get
(
)
{
#
if
DCHECK_IS_ON
(
)
if
(
!
Traits
:
:
kAllowedToAccessOnNonjoinableThread
)
ThreadRestrictions
:
:
AssertSingletonAllowed
(
)
;
#
endif
return
subtle
:
:
GetOrCreateLazyPointer
(
&
instance_
&
CreatorFunc
nullptr
Traits
:
:
kRegisterAtExit
?
OnExit
:
nullptr
nullptr
)
;
}
static
Type
*
GetIfExists
(
)
{
#
if
DCHECK_IS_ON
(
)
if
(
!
Traits
:
:
kAllowedToAccessOnNonjoinableThread
)
ThreadRestrictions
:
:
AssertSingletonAllowed
(
)
;
#
endif
if
(
!
subtle
:
:
NoBarrier_Load
(
&
instance_
)
)
return
nullptr
;
return
get
(
)
;
}
static
Type
*
CreatorFunc
(
void
*
)
{
return
Traits
:
:
New
(
)
;
}
static
void
OnExit
(
void
*
)
{
Traits
:
:
Delete
(
reinterpret_cast
<
Type
*
>
(
subtle
:
:
NoBarrier_Load
(
&
instance_
)
)
)
;
instance_
=
0
;
}
static
subtle
:
:
AtomicWord
instance_
;
}
;
template
<
typename
Type
typename
Traits
typename
DifferentiatingType
>
subtle
:
:
AtomicWord
Singleton
<
Type
Traits
DifferentiatingType
>
:
:
instance_
=
0
;
}
#
endif
