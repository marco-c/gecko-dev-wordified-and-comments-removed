#
ifndef
BASE_MEMORY_UNSAFE_SHARED_MEMORY_REGION_H_
#
define
BASE_MEMORY_UNSAFE_SHARED_MEMORY_REGION_H_
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
memory
/
platform_shared_memory_region
.
h
"
#
include
"
base
/
memory
/
shared_memory_mapping
.
h
"
#
include
<
stdint
.
h
>
namespace
base
{
class
BASE_EXPORT
UnsafeSharedMemoryRegion
{
public
:
using
MappingType
=
WritableSharedMemoryMapping
;
static
UnsafeSharedMemoryRegion
Create
(
size_t
size
)
;
using
CreateFunction
=
decltype
(
Create
)
;
static
UnsafeSharedMemoryRegion
Deserialize
(
subtle
:
:
PlatformSharedMemoryRegion
handle
)
;
static
subtle
:
:
PlatformSharedMemoryRegion
TakeHandleForSerialization
(
UnsafeSharedMemoryRegion
region
)
;
UnsafeSharedMemoryRegion
(
)
;
UnsafeSharedMemoryRegion
(
UnsafeSharedMemoryRegion
&
&
)
;
UnsafeSharedMemoryRegion
&
operator
=
(
UnsafeSharedMemoryRegion
&
&
)
;
UnsafeSharedMemoryRegion
(
const
UnsafeSharedMemoryRegion
&
)
=
delete
;
UnsafeSharedMemoryRegion
&
operator
=
(
const
UnsafeSharedMemoryRegion
&
)
=
delete
;
~
UnsafeSharedMemoryRegion
(
)
;
UnsafeSharedMemoryRegion
Duplicate
(
)
const
;
WritableSharedMemoryMapping
Map
(
SharedMemoryMapper
*
mapper
=
nullptr
)
const
;
WritableSharedMemoryMapping
MapAt
(
uint64_t
offset
size_t
size
SharedMemoryMapper
*
mapper
=
nullptr
)
const
;
bool
IsValid
(
)
const
;
size_t
GetSize
(
)
const
{
DCHECK
(
IsValid
(
)
)
;
return
handle_
.
GetSize
(
)
;
}
const
UnguessableToken
&
GetGUID
(
)
const
{
DCHECK
(
IsValid
(
)
)
;
return
handle_
.
GetGUID
(
)
;
}
subtle
:
:
PlatformSharedMemoryHandle
GetPlatformHandle
(
)
const
{
DCHECK
(
IsValid
(
)
)
;
return
handle_
.
GetPlatformHandle
(
)
;
}
private
:
friend
class
SharedMemoryHooks
;
explicit
UnsafeSharedMemoryRegion
(
subtle
:
:
PlatformSharedMemoryRegion
handle
)
;
static
void
set_create_hook
(
CreateFunction
*
hook
)
{
create_hook_
=
hook
;
}
static
CreateFunction
*
create_hook_
;
subtle
:
:
PlatformSharedMemoryRegion
handle_
;
}
;
}
#
endif
