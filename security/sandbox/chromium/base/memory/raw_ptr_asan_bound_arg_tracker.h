#
ifndef
BASE_MEMORY_RAW_PTR_ASAN_BOUND_ARG_TRACKER_H_
#
define
BASE_MEMORY_RAW_PTR_ASAN_BOUND_ARG_TRACKER_H_
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_buildflags
.
h
"
#
if
BUILDFLAG
(
USE_ASAN_BACKUP_REF_PTR
)
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
container
/
inlined_vector
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
typename
>
struct
Invoker
;
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
>
class
UnretainedWrapper
;
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
>
class
UnretainedRefWrapper
;
}
class
BASE_EXPORT
RawPtrAsanBoundArgTracker
{
public
:
static
constexpr
size_t
kInlineArgsCount
=
3
;
using
ProtectedArgsVector
=
absl
:
:
InlinedVector
<
uintptr_t
kInlineArgsCount
>
;
static
uintptr_t
GetProtectedArgPtr
(
uintptr_t
ptr
)
;
private
:
template
<
typename
typename
>
friend
struct
internal
:
:
Invoker
;
void
Add
(
uintptr_t
pointer
)
;
RawPtrAsanBoundArgTracker
(
)
;
~
RawPtrAsanBoundArgTracker
(
)
;
template
<
typename
T
>
void
AddArg
(
const
T
&
arg
)
{
}
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
>
void
AddArg
(
const
internal
:
:
UnretainedWrapper
<
T
UnretainedTrait
PtrTraits
>
&
arg
)
{
if
constexpr
(
raw_ptr_traits
:
:
IsSupportedType
<
T
>
:
:
value
)
{
auto
inner
=
arg
.
get
(
)
;
if
constexpr
(
IsRawPtrV
<
decltype
(
inner
)
>
)
{
Add
(
reinterpret_cast
<
uintptr_t
>
(
inner
.
get
(
)
)
)
;
}
else
{
Add
(
reinterpret_cast
<
uintptr_t
>
(
inner
)
)
;
}
}
}
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
>
void
AddArg
(
const
internal
:
:
UnretainedRefWrapper
<
T
UnretainedTrait
PtrTraits
>
&
arg
)
{
if
constexpr
(
raw_ptr_traits
:
:
IsSupportedType
<
T
>
:
:
value
)
{
Add
(
reinterpret_cast
<
uintptr_t
>
(
&
arg
.
get
(
)
)
)
;
}
}
template
<
typename
.
.
.
Args
>
void
AddArgs
(
Args
&
&
.
.
.
args
)
{
if
(
enabled_
)
{
(
AddArg
(
std
:
:
forward
<
Args
>
(
args
)
)
.
.
.
)
;
}
}
bool
enabled_
;
raw_ptr
<
ProtectedArgsVector
>
prev_protected_args_
;
ProtectedArgsVector
protected_args_
;
}
;
}
#
endif
#
endif
