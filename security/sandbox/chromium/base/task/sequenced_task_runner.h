#
ifndef
BASE_TASK_SEQUENCED_TASK_RUNNER_H_
#
define
BASE_TASK_SEQUENCED_TASK_RUNNER_H_
#
include
<
memory
>
#
include
"
base
/
auto_reset
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
functional
/
callback
.
h
"
#
include
"
base
/
task
/
delay_policy
.
h
"
#
include
"
base
/
task
/
delayed_task_handle
.
h
"
#
include
"
base
/
task
/
sequenced_task_runner_helpers
.
h
"
#
include
"
base
/
task
/
task_runner
.
h
"
#
include
"
base
/
types
/
pass_key
.
h
"
namespace
blink
{
class
LowPrecisionTimer
;
class
TimerBase
;
class
TimerBasedTickProvider
;
class
WebRtcTaskQueue
;
}
namespace
webrtc
{
class
ThreadWrapper
;
}
namespace
media
{
class
AlsaPcmOutputStream
;
class
AlsaPcmInputStream
;
class
FakeAudioWorker
;
}
namespace
base
{
namespace
internal
{
class
DelayTimerBase
;
class
DelayedTaskManager
;
}
class
DeadlineTimer
;
class
MetronomeTimer
;
class
TimeDelta
;
class
TimeTicks
;
namespace
subtle
{
class
PostDelayedTaskPassKey
{
private
:
PostDelayedTaskPassKey
(
)
{
}
friend
class
base
:
:
internal
:
:
DelayTimerBase
;
friend
class
base
:
:
internal
:
:
DelayedTaskManager
;
friend
class
base
:
:
DeadlineTimer
;
friend
class
base
:
:
MetronomeTimer
;
friend
class
blink
:
:
LowPrecisionTimer
;
friend
class
blink
:
:
TimerBase
;
friend
class
blink
:
:
TimerBasedTickProvider
;
friend
class
blink
:
:
WebRtcTaskQueue
;
friend
class
PostDelayedTaskPassKeyForTesting
;
friend
class
webrtc
:
:
ThreadWrapper
;
friend
class
media
:
:
AlsaPcmOutputStream
;
friend
class
media
:
:
AlsaPcmInputStream
;
friend
class
media
:
:
FakeAudioWorker
;
}
;
class
PostDelayedTaskPassKeyForTesting
:
public
PostDelayedTaskPassKey
{
}
;
}
class
BASE_EXPORT
SequencedTaskRunner
:
public
TaskRunner
{
public
:
bool
PostNonNestableTask
(
const
Location
&
from_here
OnceClosure
task
)
;
virtual
bool
PostNonNestableDelayedTask
(
const
Location
&
from_here
OnceClosure
task
base
:
:
TimeDelta
delay
)
=
0
;
virtual
DelayedTaskHandle
PostCancelableDelayedTask
(
subtle
:
:
PostDelayedTaskPassKey
const
Location
&
from_here
OnceClosure
task
TimeDelta
delay
)
;
[
[
nodiscard
]
]
virtual
DelayedTaskHandle
PostCancelableDelayedTaskAt
(
subtle
:
:
PostDelayedTaskPassKey
const
Location
&
from_here
OnceClosure
task
TimeTicks
delayed_run_time
subtle
:
:
DelayPolicy
delay_policy
)
;
virtual
bool
PostDelayedTaskAt
(
subtle
:
:
PostDelayedTaskPassKey
const
Location
&
from_here
OnceClosure
task
TimeTicks
delayed_run_time
subtle
:
:
DelayPolicy
delay_policy
)
;
template
<
class
T
>
bool
DeleteSoon
(
const
Location
&
from_here
const
T
*
object
)
{
return
DeleteOrReleaseSoonInternal
(
from_here
&
DeleteHelper
<
T
>
:
:
DoDelete
object
)
;
}
template
<
class
T
>
bool
DeleteSoon
(
const
Location
&
from_here
std
:
:
unique_ptr
<
T
>
object
)
{
return
DeleteOrReleaseSoonInternal
(
from_here
&
DeleteUniquePtrHelper
<
T
>
:
:
DoDelete
object
.
release
(
)
)
;
}
template
<
class
T
>
void
ReleaseSoon
(
const
Location
&
from_here
scoped_refptr
<
T
>
&
&
object
)
{
if
(
!
object
)
return
;
DeleteOrReleaseSoonInternal
(
from_here
&
ReleaseHelper
<
T
>
:
:
DoRelease
object
.
release
(
)
)
;
}
virtual
bool
RunsTasksInCurrentSequence
(
)
const
=
0
;
[
[
nodiscard
]
]
static
const
scoped_refptr
<
SequencedTaskRunner
>
&
GetCurrentDefault
(
)
;
[
[
nodiscard
]
]
static
bool
HasCurrentDefault
(
)
;
class
BASE_EXPORT
CurrentDefaultHandle
{
public
:
explicit
CurrentDefaultHandle
(
scoped_refptr
<
SequencedTaskRunner
>
task_runner
)
;
CurrentDefaultHandle
(
const
CurrentDefaultHandle
&
)
=
delete
;
CurrentDefaultHandle
&
operator
=
(
const
CurrentDefaultHandle
&
)
=
delete
;
~
CurrentDefaultHandle
(
)
;
private
:
friend
class
SequencedTaskRunner
;
friend
class
CurrentHandleOverride
;
const
AutoReset
<
CurrentDefaultHandle
*
>
resetter_
;
scoped_refptr
<
SequencedTaskRunner
>
task_runner_
;
}
;
protected
:
~
SequencedTaskRunner
(
)
override
=
default
;
static
void
SetCurrentDefaultHandleTaskRunner
(
CurrentDefaultHandle
&
current_default
scoped_refptr
<
SequencedTaskRunner
>
task_runner
)
{
current_default
.
task_runner_
=
task_runner
;
}
virtual
bool
DeleteOrReleaseSoonInternal
(
const
Location
&
from_here
void
(
*
deleter
)
(
const
void
*
)
const
void
*
object
)
;
}
;
struct
BASE_EXPORT
OnTaskRunnerDeleter
{
explicit
OnTaskRunnerDeleter
(
scoped_refptr
<
SequencedTaskRunner
>
task_runner
)
;
~
OnTaskRunnerDeleter
(
)
;
OnTaskRunnerDeleter
(
OnTaskRunnerDeleter
&
&
)
;
OnTaskRunnerDeleter
&
operator
=
(
OnTaskRunnerDeleter
&
&
)
;
template
<
typename
T
>
void
operator
(
)
(
const
T
*
ptr
)
{
if
(
ptr
)
task_runner_
-
>
DeleteSoon
(
FROM_HERE
ptr
)
;
}
scoped_refptr
<
SequencedTaskRunner
>
task_runner_
;
}
;
}
#
endif
