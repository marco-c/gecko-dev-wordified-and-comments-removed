#
ifndef
BASE_TASK_SINGLE_THREAD_TASK_RUNNER_H_
#
define
BASE_TASK_SINGLE_THREAD_TASK_RUNNER_H_
#
include
"
base
/
auto_reset
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
gtest_prod_util
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
#
include
"
base
/
task
/
sequenced_task_runner
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
namespace
blink
:
:
scheduler
{
class
MainThreadSchedulerImpl
;
}
namespace
base
{
class
ScopedDisallowRunningRunLoop
;
class
BASE_EXPORT
SingleThreadTaskRunner
:
public
SequencedTaskRunner
{
public
:
bool
BelongsToCurrentThread
(
)
const
{
return
RunsTasksInCurrentSequence
(
)
;
}
[
[
nodiscard
]
]
static
const
scoped_refptr
<
SingleThreadTaskRunner
>
&
GetCurrentDefault
(
)
;
[
[
nodiscard
]
]
static
bool
HasCurrentDefault
(
)
;
class
CurrentHandleOverride
;
class
CurrentHandleOverrideForTesting
;
class
BASE_EXPORT
CurrentDefaultHandle
{
public
:
explicit
CurrentDefaultHandle
(
scoped_refptr
<
SingleThreadTaskRunner
>
task_runner
)
;
CurrentDefaultHandle
(
const
CurrentDefaultHandle
&
)
=
delete
;
CurrentDefaultHandle
&
operator
=
(
const
CurrentDefaultHandle
&
)
=
delete
;
~
CurrentDefaultHandle
(
)
;
private
:
friend
class
SingleThreadTaskRunner
;
friend
class
CurrentHandleOverride
;
const
AutoReset
<
CurrentDefaultHandle
*
>
resetter_
;
scoped_refptr
<
SingleThreadTaskRunner
>
task_runner_
;
SequencedTaskRunner
:
:
CurrentDefaultHandle
sequenced_task_runner_current_default_
;
}
;
class
BASE_EXPORT
CurrentHandleOverride
{
public
:
CurrentHandleOverride
(
const
CurrentHandleOverride
&
)
=
delete
;
CurrentHandleOverride
&
operator
=
(
const
CurrentHandleOverride
&
)
=
delete
;
~
CurrentHandleOverride
(
)
;
private
:
friend
class
CurrentHandleOverrideForTesting
;
FRIEND_TEST_ALL_PREFIXES
(
SingleThreadTaskRunnerCurrentDefaultHandleTest
NestedRunLoop
)
;
friend
class
blink
:
:
scheduler
:
:
MainThreadSchedulerImpl
;
explicit
CurrentHandleOverride
(
scoped_refptr
<
SingleThreadTaskRunner
>
overriding_task_runner
bool
allow_nested_runloop
=
false
)
;
absl
:
:
optional
<
SingleThreadTaskRunner
:
:
CurrentDefaultHandle
>
top_level_thread_task_runner_current_default_
;
scoped_refptr
<
SingleThreadTaskRunner
>
task_runner_to_restore_
;
#
if
DCHECK_IS_ON
(
)
RAW_PTR_EXCLUSION
SingleThreadTaskRunner
*
expected_task_runner_before_restore_
{
nullptr
}
;
#
endif
std
:
:
unique_ptr
<
ScopedDisallowRunningRunLoop
>
no_running_during_override_
;
}
;
class
BASE_EXPORT
CurrentHandleOverrideForTesting
{
public
:
explicit
CurrentHandleOverrideForTesting
(
scoped_refptr
<
SingleThreadTaskRunner
>
overriding_task_runner
)
:
thread_task_runner_current_override_
(
std
:
:
move
(
overriding_task_runner
)
)
{
}
private
:
CurrentHandleOverride
thread_task_runner_current_override_
;
}
;
protected
:
~
SingleThreadTaskRunner
(
)
override
=
default
;
}
;
}
#
endif
