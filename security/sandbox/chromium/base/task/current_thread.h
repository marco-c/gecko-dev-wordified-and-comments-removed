#
ifndef
BASE_TASK_CURRENT_THREAD_H_
#
define
BASE_TASK_CURRENT_THREAD_H_
#
include
<
ostream
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
functional
/
callback_forward
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
memory
/
scoped_refptr
.
h
"
#
include
"
base
/
message_loop
/
ios_cronet_buildflags
.
h
"
#
include
"
base
/
message_loop
/
message_pump_for_io
.
h
"
#
include
"
base
/
message_loop
/
message_pump_for_ui
.
h
"
#
include
"
base
/
pending_task
.
h
"
#
include
"
base
/
task
/
sequence_manager
/
task_time_observer
.
h
"
#
include
"
base
/
task
/
single_thread_task_runner
.
h
"
#
include
"
base
/
task
/
task_observer
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
web
{
class
WebTaskEnvironment
;
}
namespace
base
{
namespace
sequence_manager
{
namespace
internal
{
class
SequenceManagerImpl
;
}
}
class
BASE_EXPORT
CurrentThread
{
public
:
CurrentThread
(
const
CurrentThread
&
other
)
=
default
;
CurrentThread
(
CurrentThread
&
&
other
)
=
default
;
CurrentThread
&
operator
=
(
const
CurrentThread
&
other
)
=
default
;
bool
operator
=
=
(
const
CurrentThread
&
other
)
const
;
static
CurrentThread
Get
(
)
;
static
CurrentThread
GetNull
(
)
;
static
bool
IsSet
(
)
;
CurrentThread
*
operator
-
>
(
)
{
return
this
;
}
explicit
operator
bool
(
)
const
{
return
!
!
current_
;
}
class
BASE_EXPORT
DestructionObserver
{
public
:
virtual
void
WillDestroyCurrentMessageLoop
(
)
=
0
;
protected
:
virtual
~
DestructionObserver
(
)
=
default
;
}
;
void
AddDestructionObserver
(
DestructionObserver
*
destruction_observer
)
;
void
RemoveDestructionObserver
(
DestructionObserver
*
destruction_observer
)
;
void
SetTaskRunner
(
scoped_refptr
<
SingleThreadTaskRunner
>
task_runner
)
;
void
AddTaskObserver
(
TaskObserver
*
task_observer
)
;
void
RemoveTaskObserver
(
TaskObserver
*
task_observer
)
;
void
SetAddQueueTimeToTasks
(
bool
enable
)
;
void
RegisterOnNextIdleCallback
(
OnceClosure
on_next_idle_callback
)
;
class
BASE_EXPORT
ScopedAllowApplicationTasksInNativeNestedLoop
{
public
:
ScopedAllowApplicationTasksInNativeNestedLoop
(
)
;
~
ScopedAllowApplicationTasksInNativeNestedLoop
(
)
;
private
:
const
raw_ptr
<
sequence_manager
:
:
internal
:
:
SequenceManagerImpl
>
sequence_manager_
;
const
bool
previous_state_
;
}
;
bool
ApplicationTasksAllowedInNativeNestedLoop
(
)
const
;
bool
IsBoundToCurrentThread
(
)
const
;
bool
IsIdleForTesting
(
)
;
void
EnableMessagePumpTimeKeeperMetrics
(
const
char
*
thread_name
)
;
protected
:
explicit
CurrentThread
(
sequence_manager
:
:
internal
:
:
SequenceManagerImpl
*
sequence_manager
)
:
current_
(
sequence_manager
)
{
}
static
sequence_manager
:
:
internal
:
:
SequenceManagerImpl
*
GetCurrentSequenceManagerImpl
(
)
;
friend
class
MessagePumpLibeventTest
;
friend
class
ScheduleWorkTest
;
friend
class
Thread
;
friend
class
sequence_manager
:
:
internal
:
:
SequenceManagerImpl
;
friend
class
MessageLoopTaskRunnerTest
;
friend
class
web
:
:
WebTaskEnvironment
;
raw_ptr
<
sequence_manager
:
:
internal
:
:
SequenceManagerImpl
>
current_
;
}
;
#
if
!
BUILDFLAG
(
IS_NACL
)
class
BASE_EXPORT
CurrentUIThread
:
public
CurrentThread
{
public
:
static
CurrentUIThread
Get
(
)
;
static
bool
IsSet
(
)
;
CurrentUIThread
*
operator
-
>
(
)
{
return
this
;
}
#
if
BUILDFLAG
(
IS_OZONE
)
&
&
!
BUILDFLAG
(
IS_FUCHSIA
)
&
&
!
BUILDFLAG
(
IS_WIN
)
static_assert
(
std
:
:
is_base_of_v
<
WatchableIOMessagePumpPosix
MessagePumpForUI
>
"
CurrentThreadForUI
:
:
WatchFileDescriptor
is
supported
only
"
"
by
MessagePumpLibevent
and
MessagePumpGlib
implementations
.
"
)
;
bool
WatchFileDescriptor
(
int
fd
bool
persistent
MessagePumpForUI
:
:
Mode
mode
MessagePumpForUI
:
:
FdWatchController
*
controller
MessagePumpForUI
:
:
FdWatcher
*
delegate
)
;
#
endif
#
if
BUILDFLAG
(
IS_IOS
)
void
Attach
(
)
;
#
endif
#
if
BUILDFLAG
(
IS_ANDROID
)
void
Abort
(
)
;
#
endif
#
if
BUILDFLAG
(
IS_WIN
)
void
AddMessagePumpObserver
(
MessagePumpForUI
:
:
Observer
*
observer
)
;
void
RemoveMessagePumpObserver
(
MessagePumpForUI
:
:
Observer
*
observer
)
;
#
endif
private
:
explicit
CurrentUIThread
(
sequence_manager
:
:
internal
:
:
SequenceManagerImpl
*
current
)
:
CurrentThread
(
current
)
{
}
MessagePumpForUI
*
GetMessagePumpForUI
(
)
const
;
}
;
#
endif
class
BASE_EXPORT
CurrentIOThread
:
public
CurrentThread
{
public
:
static
CurrentIOThread
Get
(
)
;
static
bool
IsSet
(
)
;
CurrentIOThread
*
operator
-
>
(
)
{
return
this
;
}
#
if
!
BUILDFLAG
(
IS_NACL
)
#
if
BUILDFLAG
(
IS_WIN
)
HRESULT
RegisterIOHandler
(
HANDLE
file
MessagePumpForIO
:
:
IOHandler
*
handler
)
;
bool
RegisterJobObject
(
HANDLE
job
MessagePumpForIO
:
:
IOHandler
*
handler
)
;
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
bool
WatchFileDescriptor
(
int
fd
bool
persistent
MessagePumpForIO
:
:
Mode
mode
MessagePumpForIO
:
:
FdWatchController
*
controller
MessagePumpForIO
:
:
FdWatcher
*
delegate
)
;
#
endif
#
if
BUILDFLAG
(
IS_MAC
)
|
|
(
BUILDFLAG
(
IS_IOS
)
&
&
!
BUILDFLAG
(
CRONET_BUILD
)
)
bool
WatchMachReceivePort
(
mach_port_t
port
MessagePumpForIO
:
:
MachPortWatchController
*
controller
MessagePumpForIO
:
:
MachPortWatcher
*
delegate
)
;
#
endif
#
if
BUILDFLAG
(
IS_FUCHSIA
)
bool
WatchZxHandle
(
zx_handle_t
handle
bool
persistent
zx_signals_t
signals
MessagePumpForIO
:
:
ZxHandleWatchController
*
controller
MessagePumpForIO
:
:
ZxHandleWatcher
*
delegate
)
;
#
endif
#
endif
private
:
explicit
CurrentIOThread
(
sequence_manager
:
:
internal
:
:
SequenceManagerImpl
*
current
)
:
CurrentThread
(
current
)
{
}
MessagePumpForIO
*
GetMessagePumpForIO
(
)
const
;
}
;
}
#
endif
