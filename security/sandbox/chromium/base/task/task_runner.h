#
ifndef
BASE_TASK_TASK_RUNNER_H_
#
define
BASE_TASK_TASK_RUNNER_H_
#
include
<
stddef
.
h
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
functional
/
bind
.
h
"
#
include
"
base
/
functional
/
callback
.
h
"
#
include
"
base
/
functional
/
callback_helpers
.
h
"
#
include
"
base
/
location
.
h
"
#
include
"
base
/
memory
/
ref_counted
.
h
"
#
include
"
base
/
task
/
post_task_and_reply_with_result_internal
.
h
"
namespace
base
{
struct
TaskRunnerTraits
;
class
TimeDelta
;
class
BASE_EXPORT
TaskRunner
:
public
RefCountedThreadSafe
<
TaskRunner
TaskRunnerTraits
>
{
public
:
bool
PostTask
(
const
Location
&
from_here
OnceClosure
task
)
;
virtual
bool
PostDelayedTask
(
const
Location
&
from_here
OnceClosure
task
base
:
:
TimeDelta
delay
)
=
0
;
bool
PostTaskAndReply
(
const
Location
&
from_here
OnceClosure
task
OnceClosure
reply
)
;
template
<
typename
TaskReturnType
typename
ReplyArgType
template
<
typename
>
class
TaskCallbackType
template
<
typename
>
class
ReplyCallbackType
typename
=
EnableIfIsBaseCallback
<
TaskCallbackType
>
typename
=
EnableIfIsBaseCallback
<
ReplyCallbackType
>
>
bool
PostTaskAndReplyWithResult
(
const
Location
&
from_here
TaskCallbackType
<
TaskReturnType
(
)
>
task
ReplyCallbackType
<
void
(
ReplyArgType
)
>
reply
)
{
DCHECK
(
task
)
;
DCHECK
(
reply
)
;
auto
*
result
=
new
std
:
:
unique_ptr
<
TaskReturnType
>
(
)
;
return
PostTaskAndReply
(
from_here
BindOnce
(
&
internal
:
:
ReturnAsParamAdapter
<
TaskReturnType
>
std
:
:
move
(
task
)
result
)
BindOnce
(
&
internal
:
:
ReplyAdapter
<
TaskReturnType
ReplyArgType
>
std
:
:
move
(
reply
)
Owned
(
result
)
)
)
;
}
protected
:
friend
struct
TaskRunnerTraits
;
TaskRunner
(
)
;
virtual
~
TaskRunner
(
)
;
virtual
void
OnDestruct
(
)
const
;
}
;
struct
BASE_EXPORT
TaskRunnerTraits
{
static
void
Destruct
(
const
TaskRunner
*
task_runner
)
;
}
;
}
#
endif
