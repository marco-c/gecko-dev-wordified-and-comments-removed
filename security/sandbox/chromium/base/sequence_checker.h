#
ifndef
BASE_SEQUENCE_CHECKER_H_
#
define
BASE_SEQUENCE_CHECKER_H_
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
macros
/
uniquify
.
h
"
#
include
"
base
/
sequence_checker_impl
.
h
"
#
if
DCHECK_IS_ON
(
)
#
define
SEQUENCE_CHECKER
(
name
)
base
:
:
SequenceChecker
name
#
define
DCHECK_CALLED_ON_VALID_SEQUENCE
(
name
.
.
.
)
\
base
:
:
ScopedValidateSequenceChecker
BASE_UNIQUIFY
(
\
scoped_validate_sequence_checker_
)
(
name
#
#
__VA_ARGS__
)
#
define
DETACH_FROM_SEQUENCE
(
name
)
(
name
)
.
DetachFromSequence
(
)
#
else
#
define
SEQUENCE_CHECKER
(
name
)
static_assert
(
true
"
"
)
#
define
DCHECK_CALLED_ON_VALID_SEQUENCE
(
name
.
.
.
)
EAT_CHECK_STREAM_PARAMS
(
)
#
define
DETACH_FROM_SEQUENCE
(
name
)
#
endif
namespace
base
{
class
THREAD_ANNOTATION_ATTRIBUTE__
(
capability
(
"
context
"
)
)
SequenceCheckerDoNothing
{
public
:
static
void
EnableStackLogging
(
)
{
}
SequenceCheckerDoNothing
(
)
=
default
;
SequenceCheckerDoNothing
(
SequenceCheckerDoNothing
&
&
other
)
=
default
;
SequenceCheckerDoNothing
&
operator
=
(
SequenceCheckerDoNothing
&
&
other
)
=
default
;
SequenceCheckerDoNothing
(
const
SequenceCheckerDoNothing
&
)
=
delete
;
SequenceCheckerDoNothing
&
operator
=
(
const
SequenceCheckerDoNothing
&
)
=
delete
;
[
[
nodiscard
]
]
bool
CalledOnValidSequence
(
void
*
=
nullptr
)
const
{
return
true
;
}
void
DetachFromSequence
(
)
{
}
}
;
#
if
DCHECK_IS_ON
(
)
using
SequenceChecker
=
SequenceCheckerImpl
;
#
else
using
SequenceChecker
=
SequenceCheckerDoNothing
;
#
endif
#
if
DCHECK_IS_ON
(
)
class
BASE_EXPORT
SCOPED_LOCKABLE
ScopedValidateSequenceChecker
{
public
:
explicit
ScopedValidateSequenceChecker
(
const
SequenceChecker
&
checker
)
EXCLUSIVE_LOCK_FUNCTION
(
checker
)
;
~
ScopedValidateSequenceChecker
(
)
UNLOCK_FUNCTION
(
)
;
}
;
#
endif
}
#
endif
