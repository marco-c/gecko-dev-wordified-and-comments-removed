#
ifndef
BASE_LAZY_INSTANCE_HELPERS_H_
#
define
BASE_LAZY_INSTANCE_HELPERS_H_
#
include
<
atomic
>
#
include
<
cstdint
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
namespace
base
{
namespace
internal
{
constexpr
uintptr_t
kLazyInstanceStateCreating
=
1
;
BASE_EXPORT
bool
NeedsLazyInstance
(
std
:
:
atomic
<
uintptr_t
>
&
state
)
;
BASE_EXPORT
void
CompleteLazyInstance
(
std
:
:
atomic
<
uintptr_t
>
&
state
uintptr_t
new_instance
void
(
*
destructor
)
(
void
*
)
void
*
destructor_arg
)
;
}
namespace
subtle
{
template
<
typename
Type
>
Type
*
GetOrCreateLazyPointer
(
std
:
:
atomic
<
uintptr_t
>
&
state
Type
*
(
*
creator_func
)
(
void
*
)
void
*
creator_arg
void
(
*
destructor
)
(
void
*
)
void
*
destructor_arg
)
{
DCHECK
(
creator_func
)
;
constexpr
uintptr_t
kLazyInstanceCreatedMask
=
~
internal
:
:
kLazyInstanceStateCreating
;
uintptr_t
instance
=
state
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
!
(
instance
&
kLazyInstanceCreatedMask
)
)
{
if
(
internal
:
:
NeedsLazyInstance
(
state
)
)
{
instance
=
reinterpret_cast
<
uintptr_t
>
(
(
*
creator_func
)
(
creator_arg
)
)
;
internal
:
:
CompleteLazyInstance
(
state
instance
destructor
destructor_arg
)
;
}
else
{
instance
=
state
.
load
(
std
:
:
memory_order_acquire
)
;
DCHECK
(
instance
&
kLazyInstanceCreatedMask
)
;
}
}
return
reinterpret_cast
<
Type
*
>
(
instance
)
;
}
}
}
#
endif
