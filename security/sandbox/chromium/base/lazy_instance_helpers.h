#
ifndef
BASE_LAZY_INSTANCE_INTERNAL_H_
#
define
BASE_LAZY_INSTANCE_INTERNAL_H_
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
logging
.
h
"
namespace
base
{
namespace
internal
{
constexpr
subtle
:
:
AtomicWord
kLazyInstanceStateCreating
=
1
;
BASE_EXPORT
bool
NeedsLazyInstance
(
subtle
:
:
AtomicWord
*
state
)
;
BASE_EXPORT
void
CompleteLazyInstance
(
subtle
:
:
AtomicWord
*
state
subtle
:
:
AtomicWord
new_instance
void
(
*
destructor
)
(
void
*
)
void
*
destructor_arg
)
;
}
namespace
subtle
{
template
<
typename
Type
>
Type
*
GetOrCreateLazyPointer
(
subtle
:
:
AtomicWord
*
state
Type
*
(
*
creator_func
)
(
void
*
)
void
*
creator_arg
void
(
*
destructor
)
(
void
*
)
void
*
destructor_arg
)
{
DCHECK
(
state
)
;
DCHECK
(
creator_func
)
;
constexpr
subtle
:
:
AtomicWord
kLazyInstanceCreatedMask
=
~
internal
:
:
kLazyInstanceStateCreating
;
subtle
:
:
AtomicWord
instance
=
subtle
:
:
Acquire_Load
(
state
)
;
if
(
!
(
instance
&
kLazyInstanceCreatedMask
)
)
{
if
(
internal
:
:
NeedsLazyInstance
(
state
)
)
{
instance
=
reinterpret_cast
<
subtle
:
:
AtomicWord
>
(
(
*
creator_func
)
(
creator_arg
)
)
;
internal
:
:
CompleteLazyInstance
(
state
instance
destructor
destructor_arg
)
;
}
else
{
instance
=
subtle
:
:
Acquire_Load
(
state
)
;
DCHECK
(
instance
&
kLazyInstanceCreatedMask
)
;
}
}
return
reinterpret_cast
<
Type
*
>
(
instance
)
;
}
}
}
#
endif
