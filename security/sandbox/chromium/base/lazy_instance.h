#
ifndef
BASE_LAZY_INSTANCE_H_
#
define
BASE_LAZY_INSTANCE_H_
#
include
<
new
>
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
debug
/
leak_annotations
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
threading
/
thread_restrictions
.
h
"
#
define
LAZY_INSTANCE_INITIALIZER
{
0
}
namespace
base
{
template
<
typename
Type
>
struct
LazyInstanceTraitsBase
{
static
Type
*
New
(
void
*
instance
)
{
DCHECK_EQ
(
reinterpret_cast
<
uintptr_t
>
(
instance
)
&
(
alignof
(
Type
)
-
1
)
0u
)
;
return
new
(
instance
)
Type
(
)
;
}
static
void
CallDestructor
(
Type
*
instance
)
{
instance
-
>
~
Type
(
)
;
}
}
;
namespace
internal
{
template
<
typename
Type
>
struct
DestructorAtExitLazyInstanceTraits
{
static
const
bool
kRegisterOnExit
=
true
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
false
;
#
endif
static
Type
*
New
(
void
*
instance
)
{
return
LazyInstanceTraitsBase
<
Type
>
:
:
New
(
instance
)
;
}
static
void
Delete
(
Type
*
instance
)
{
LazyInstanceTraitsBase
<
Type
>
:
:
CallDestructor
(
instance
)
;
}
}
;
template
<
typename
Type
>
struct
LeakyLazyInstanceTraits
{
static
const
bool
kRegisterOnExit
=
false
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
true
;
#
endif
static
Type
*
New
(
void
*
instance
)
{
ANNOTATE_SCOPED_MEMORY_LEAK
;
return
LazyInstanceTraitsBase
<
Type
>
:
:
New
(
instance
)
;
}
static
void
Delete
(
Type
*
instance
)
{
}
}
;
template
<
typename
Type
>
struct
ErrorMustSelectLazyOrDestructorAtExitForLazyInstance
{
}
;
constexpr
subtle
:
:
AtomicWord
kLazyInstanceStateCreating
=
1
;
BASE_EXPORT
bool
NeedsLazyInstance
(
subtle
:
:
AtomicWord
*
state
)
;
BASE_EXPORT
void
CompleteLazyInstance
(
subtle
:
:
AtomicWord
*
state
subtle
:
:
AtomicWord
new_instance
void
(
*
destructor
)
(
void
*
)
void
*
destructor_arg
)
;
template
<
typename
CreatorFunc
>
void
*
GetOrCreateLazyPointer
(
subtle
:
:
AtomicWord
*
state
const
CreatorFunc
&
creator_func
void
(
*
destructor
)
(
void
*
)
void
*
destructor_arg
)
{
constexpr
subtle
:
:
AtomicWord
kLazyInstanceCreatedMask
=
~
internal
:
:
kLazyInstanceStateCreating
;
subtle
:
:
AtomicWord
value
=
subtle
:
:
Acquire_Load
(
state
)
;
if
(
!
(
value
&
kLazyInstanceCreatedMask
)
&
&
NeedsLazyInstance
(
state
)
)
{
value
=
reinterpret_cast
<
subtle
:
:
AtomicWord
>
(
creator_func
(
)
)
;
CompleteLazyInstance
(
state
value
destructor
destructor_arg
)
;
}
return
reinterpret_cast
<
void
*
>
(
subtle
:
:
NoBarrier_Load
(
state
)
)
;
}
}
template
<
typename
Type
typename
Traits
=
internal
:
:
ErrorMustSelectLazyOrDestructorAtExitForLazyInstance
<
Type
>
>
class
LazyInstance
{
public
:
typedef
LazyInstance
<
Type
internal
:
:
LeakyLazyInstanceTraits
<
Type
>
>
Leaky
;
typedef
LazyInstance
<
Type
internal
:
:
DestructorAtExitLazyInstanceTraits
<
Type
>
>
DestructorAtExit
;
Type
&
Get
(
)
{
return
*
Pointer
(
)
;
}
Type
*
Pointer
(
)
{
#
if
DCHECK_IS_ON
(
)
if
(
!
Traits
:
:
kAllowedToAccessOnNonjoinableThread
)
ThreadRestrictions
:
:
AssertSingletonAllowed
(
)
;
#
endif
return
static_cast
<
Type
*
>
(
internal
:
:
GetOrCreateLazyPointer
(
&
private_instance_
[
this
]
(
)
{
return
Traits
:
:
New
(
private_buf_
)
;
}
Traits
:
:
kRegisterOnExit
?
OnExit
:
nullptr
this
)
)
;
}
bool
operator
=
=
(
Type
*
p
)
{
switch
(
subtle
:
:
NoBarrier_Load
(
&
private_instance_
)
)
{
case
0
:
return
p
=
=
NULL
;
case
internal
:
:
kLazyInstanceStateCreating
:
return
static_cast
<
void
*
>
(
p
)
=
=
private_buf_
;
default
:
return
p
=
=
instance
(
)
;
}
}
#
if
defined
(
OS_WIN
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4324
)
#
endif
subtle
:
:
AtomicWord
private_instance_
;
alignas
(
Type
)
char
private_buf_
[
sizeof
(
Type
)
]
;
#
if
defined
(
OS_WIN
)
#
pragma
warning
(
pop
)
#
endif
private
:
Type
*
instance
(
)
{
return
reinterpret_cast
<
Type
*
>
(
subtle
:
:
NoBarrier_Load
(
&
private_instance_
)
)
;
}
static
void
OnExit
(
void
*
lazy_instance
)
{
LazyInstance
<
Type
Traits
>
*
me
=
reinterpret_cast
<
LazyInstance
<
Type
Traits
>
*
>
(
lazy_instance
)
;
Traits
:
:
Delete
(
me
-
>
instance
(
)
)
;
subtle
:
:
NoBarrier_Store
(
&
me
-
>
private_instance_
0
)
;
}
}
;
}
#
endif
