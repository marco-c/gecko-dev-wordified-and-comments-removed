#
ifndef
BASE_LAZY_INSTANCE_H_
#
define
BASE_LAZY_INSTANCE_H_
#
include
<
new
>
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
debug
/
leak_annotations
.
h
"
#
include
"
base
/
lazy_instance_helpers
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
threading
/
thread_restrictions
.
h
"
#
define
LAZY_INSTANCE_INITIALIZER
{
}
namespace
base
{
template
<
typename
Type
>
struct
LazyInstanceTraitsBase
{
static
Type
*
New
(
void
*
instance
)
{
DCHECK_EQ
(
reinterpret_cast
<
uintptr_t
>
(
instance
)
&
(
alignof
(
Type
)
-
1
)
0u
)
;
return
new
(
instance
)
Type
(
)
;
}
static
void
CallDestructor
(
Type
*
instance
)
{
instance
-
>
~
Type
(
)
;
}
}
;
namespace
internal
{
template
<
typename
Type
>
struct
DestructorAtExitLazyInstanceTraits
{
static
const
bool
kRegisterOnExit
=
true
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
false
;
#
endif
static
Type
*
New
(
void
*
instance
)
{
return
LazyInstanceTraitsBase
<
Type
>
:
:
New
(
instance
)
;
}
static
void
Delete
(
Type
*
instance
)
{
LazyInstanceTraitsBase
<
Type
>
:
:
CallDestructor
(
instance
)
;
}
}
;
template
<
typename
Type
>
struct
LeakyLazyInstanceTraits
{
static
const
bool
kRegisterOnExit
=
false
;
#
if
DCHECK_IS_ON
(
)
static
const
bool
kAllowedToAccessOnNonjoinableThread
=
true
;
#
endif
static
Type
*
New
(
void
*
instance
)
{
ANNOTATE_SCOPED_MEMORY_LEAK
;
return
LazyInstanceTraitsBase
<
Type
>
:
:
New
(
instance
)
;
}
static
void
Delete
(
Type
*
instance
)
{
}
}
;
template
<
typename
Type
>
struct
ErrorMustSelectLazyOrDestructorAtExitForLazyInstance
{
}
;
}
template
<
typename
Type
typename
Traits
=
internal
:
:
ErrorMustSelectLazyOrDestructorAtExitForLazyInstance
<
Type
>
>
class
LazyInstance
{
public
:
typedef
LazyInstance
<
Type
internal
:
:
LeakyLazyInstanceTraits
<
Type
>
>
Leaky
;
typedef
LazyInstance
<
Type
internal
:
:
DestructorAtExitLazyInstanceTraits
<
Type
>
>
DestructorAtExit
;
Type
&
Get
(
)
{
return
*
Pointer
(
)
;
}
Type
*
Pointer
(
)
{
#
if
DCHECK_IS_ON
(
)
if
(
!
Traits
:
:
kAllowedToAccessOnNonjoinableThread
)
ThreadRestrictions
:
:
AssertSingletonAllowed
(
)
;
#
endif
return
subtle
:
:
GetOrCreateLazyPointer
(
&
private_instance_
&
Traits
:
:
New
private_buf_
Traits
:
:
kRegisterOnExit
?
OnExit
:
nullptr
this
)
;
}
bool
IsCreated
(
)
{
return
0
!
=
subtle
:
:
NoBarrier_Load
(
&
private_instance_
)
;
}
#
if
defined
(
OS_WIN
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4324
)
#
endif
subtle
:
:
AtomicWord
private_instance_
;
alignas
(
Type
)
char
private_buf_
[
sizeof
(
Type
)
]
;
#
if
defined
(
OS_WIN
)
#
pragma
warning
(
pop
)
#
endif
private
:
Type
*
instance
(
)
{
return
reinterpret_cast
<
Type
*
>
(
subtle
:
:
NoBarrier_Load
(
&
private_instance_
)
)
;
}
static
void
OnExit
(
void
*
lazy_instance
)
{
LazyInstance
<
Type
Traits
>
*
me
=
reinterpret_cast
<
LazyInstance
<
Type
Traits
>
*
>
(
lazy_instance
)
;
Traits
:
:
Delete
(
me
-
>
instance
(
)
)
;
subtle
:
:
NoBarrier_Store
(
&
me
-
>
private_instance_
0
)
;
}
}
;
}
#
endif
