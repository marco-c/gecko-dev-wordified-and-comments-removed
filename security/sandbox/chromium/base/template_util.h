#
ifndef
BASE_TEMPLATE_UTIL_H_
#
define
BASE_TEMPLATE_UTIL_H_
#
include
<
stddef
.
h
>
#
include
<
iosfwd
>
#
include
<
iterator
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
compiler_specific
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
T
typename
=
void
>
struct
is_iterator
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
is_iterator
<
T
std
:
:
void_t
<
typename
std
:
:
iterator_traits
<
T
>
:
:
iterator_category
>
>
:
std
:
:
true_type
{
}
;
template
<
size_t
I
>
struct
priority_tag
:
priority_tag
<
I
-
1
>
{
}
;
template
<
>
struct
priority_tag
<
0
>
{
}
;
}
namespace
internal
{
template
<
typename
T
bool
=
std
:
:
is_enum_v
<
T
>
>
struct
IsScopedEnumImpl
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
IsScopedEnumImpl
<
T
true
>
:
std
:
:
negation
<
std
:
:
is_convertible
<
T
std
:
:
underlying_type_t
<
T
>
>
>
{
}
;
}
template
<
typename
T
>
struct
is_scoped_enum
:
internal
:
:
IsScopedEnumImpl
<
T
>
{
}
;
template
<
typename
T
>
struct
remove_cvref
{
using
type
=
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
T
>
>
;
}
;
template
<
typename
T
>
using
remove_cvref_t
=
typename
remove_cvref
<
T
>
:
:
type
;
template
<
typename
Iter
>
struct
IterValueImpl
{
using
value_type
=
typename
std
:
:
iterator_traits
<
Iter
>
:
:
value_type
;
}
;
template
<
typename
T
bool
Cond
=
false
>
struct
IterValuePointerImpl
{
}
;
template
<
typename
T
>
struct
IterValuePointerImpl
<
T
*
true
>
{
using
value_type
=
typename
std
:
:
iterator_traits
<
T
*
>
:
:
value_type
;
}
;
template
<
typename
T
>
struct
IterValueImpl
<
T
*
>
{
using
value_type
=
typename
IterValuePointerImpl
<
T
*
std
:
:
is_object_v
<
T
>
>
:
:
value_type
;
}
;
template
<
typename
Iter
>
using
iter_value_t
=
typename
IterValueImpl
<
remove_cvref_t
<
Iter
>
>
:
:
value_type
;
template
<
typename
Iter
>
using
iter_reference_t
=
decltype
(
*
std
:
:
declval
<
Iter
&
>
(
)
)
;
template
<
typename
Func
typename
.
.
.
Iters
>
using
indirect_result_t
=
std
:
:
invoke_result_t
<
Func
iter_reference_t
<
Iters
>
.
.
.
>
;
template
<
typename
Iter
typename
Proj
typename
IndirectResultT
=
indirect_result_t
<
Proj
Iter
>
>
struct
projected
{
using
value_type
=
remove_cvref_t
<
IndirectResultT
>
;
IndirectResultT
operator
*
(
)
const
;
}
;
}
#
endif
