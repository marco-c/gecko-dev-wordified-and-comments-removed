#
ifndef
BASE_WIN_SCOPED_HANDLE_H_
#
define
BASE_WIN_SCOPED_HANDLE_H_
#
include
"
base
/
win
/
windows_types
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
gtest_prod_util
.
h
"
#
include
"
base
/
location
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
macros
.
h
"
#
if
defined
(
COMPILER_MSVC
)
#
include
<
intrin
.
h
>
#
define
BASE_WIN_GET_CALLER
_ReturnAddress
(
)
#
elif
defined
(
COMPILER_GCC
)
#
define
BASE_WIN_GET_CALLER
\
__builtin_extract_return_addr
(
__builtin_return_address
(
0
)
)
#
endif
namespace
base
{
namespace
win
{
template
<
class
Traits
class
Verifier
>
class
GenericScopedHandle
{
public
:
using
Handle
=
typename
Traits
:
:
Handle
;
GenericScopedHandle
(
)
:
handle_
(
Traits
:
:
NullHandle
(
)
)
{
}
explicit
GenericScopedHandle
(
Handle
handle
)
:
handle_
(
Traits
:
:
NullHandle
(
)
)
{
Set
(
handle
)
;
}
GenericScopedHandle
(
GenericScopedHandle
&
&
other
)
:
handle_
(
Traits
:
:
NullHandle
(
)
)
{
Set
(
other
.
Take
(
)
)
;
}
~
GenericScopedHandle
(
)
{
Close
(
)
;
}
bool
IsValid
(
)
const
{
return
Traits
:
:
IsHandleValid
(
handle_
)
;
}
GenericScopedHandle
&
operator
=
(
GenericScopedHandle
&
&
other
)
{
DCHECK_NE
(
this
&
other
)
;
Set
(
other
.
Take
(
)
)
;
return
*
this
;
}
void
Set
(
Handle
handle
)
{
if
(
handle_
!
=
handle
)
{
auto
last_error
=
:
:
GetLastError
(
)
;
Close
(
)
;
if
(
Traits
:
:
IsHandleValid
(
handle
)
)
{
handle_
=
handle
;
Verifier
:
:
StartTracking
(
handle
this
BASE_WIN_GET_CALLER
GetProgramCounter
(
)
)
;
}
:
:
SetLastError
(
last_error
)
;
}
}
Handle
Get
(
)
const
{
return
handle_
;
}
Handle
Take
(
)
WARN_UNUSED_RESULT
{
Handle
temp
=
handle_
;
handle_
=
Traits
:
:
NullHandle
(
)
;
if
(
Traits
:
:
IsHandleValid
(
temp
)
)
{
Verifier
:
:
StopTracking
(
temp
this
BASE_WIN_GET_CALLER
GetProgramCounter
(
)
)
;
}
return
temp
;
}
void
Close
(
)
{
if
(
Traits
:
:
IsHandleValid
(
handle_
)
)
{
Verifier
:
:
StopTracking
(
handle_
this
BASE_WIN_GET_CALLER
GetProgramCounter
(
)
)
;
Traits
:
:
CloseHandle
(
handle_
)
;
handle_
=
Traits
:
:
NullHandle
(
)
;
}
}
private
:
FRIEND_TEST_ALL_PREFIXES
(
ScopedHandleTest
ActiveVerifierWrongOwner
)
;
FRIEND_TEST_ALL_PREFIXES
(
ScopedHandleTest
ActiveVerifierUntrackedHandle
)
;
Handle
handle_
;
DISALLOW_COPY_AND_ASSIGN
(
GenericScopedHandle
)
;
}
;
#
undef
BASE_WIN_GET_CALLER
class
HandleTraits
{
public
:
using
Handle
=
HANDLE
;
static
bool
BASE_EXPORT
CloseHandle
(
HANDLE
handle
)
;
static
bool
IsHandleValid
(
HANDLE
handle
)
{
return
handle
!
=
nullptr
&
&
handle
!
=
INVALID_HANDLE_VALUE
;
}
static
HANDLE
NullHandle
(
)
{
return
nullptr
;
}
private
:
DISALLOW_IMPLICIT_CONSTRUCTORS
(
HandleTraits
)
;
}
;
class
DummyVerifierTraits
{
public
:
using
Handle
=
HANDLE
;
static
void
StartTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
}
static
void
StopTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
}
private
:
DISALLOW_IMPLICIT_CONSTRUCTORS
(
DummyVerifierTraits
)
;
}
;
class
BASE_EXPORT
VerifierTraits
{
public
:
using
Handle
=
HANDLE
;
static
void
StartTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
;
static
void
StopTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
;
private
:
DISALLOW_IMPLICIT_CONSTRUCTORS
(
VerifierTraits
)
;
}
;
using
ScopedHandle
=
GenericScopedHandle
<
HandleTraits
VerifierTraits
>
;
BASE_EXPORT
void
DisableHandleVerifier
(
)
;
BASE_EXPORT
void
OnHandleBeingClosed
(
HANDLE
handle
)
;
}
}
#
endif
