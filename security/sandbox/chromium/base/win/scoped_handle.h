#
ifndef
BASE_WIN_SCOPED_HANDLE_H_
#
define
BASE_WIN_SCOPED_HANDLE_H_
#
include
<
ostream
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
dcheck_is_on
.
h
"
#
include
"
base
/
gtest_prod_util
.
h
"
#
include
"
base
/
location
.
h
"
#
include
"
base
/
win
/
windows_types
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
defined
(
COMPILER_MSVC
)
#
include
<
intrin
.
h
>
#
define
BASE_WIN_GET_CALLER
_ReturnAddress
(
)
#
elif
defined
(
COMPILER_GCC
)
#
define
BASE_WIN_GET_CALLER
\
__builtin_extract_return_addr
(
__builtin_return_address
(
0
)
)
#
endif
namespace
base
{
namespace
win
{
enum
class
HandleOperation
{
kHandleAlreadyTracked
kCloseHandleNotTracked
kCloseHandleNotOwner
kCloseHandleHook
kDuplicateHandleHook
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
HandleOperation
operation
)
;
template
<
class
Traits
class
Verifier
>
class
GenericScopedHandle
{
public
:
using
Handle
=
typename
Traits
:
:
Handle
;
GenericScopedHandle
(
)
:
handle_
(
Traits
:
:
NullHandle
(
)
)
{
}
explicit
GenericScopedHandle
(
Handle
handle
)
:
handle_
(
Traits
:
:
NullHandle
(
)
)
{
Set
(
handle
)
;
}
GenericScopedHandle
(
GenericScopedHandle
&
&
other
)
:
handle_
(
Traits
:
:
NullHandle
(
)
)
{
Set
(
other
.
Take
(
)
)
;
}
GenericScopedHandle
(
const
GenericScopedHandle
&
)
=
delete
;
GenericScopedHandle
&
operator
=
(
const
GenericScopedHandle
&
)
=
delete
;
~
GenericScopedHandle
(
)
{
Close
(
)
;
}
bool
is_valid
(
)
const
{
return
Traits
:
:
IsHandleValid
(
handle_
)
;
}
bool
IsValid
(
)
const
{
return
is_valid
(
)
;
}
GenericScopedHandle
&
operator
=
(
GenericScopedHandle
&
&
other
)
{
DCHECK_NE
(
this
&
other
)
;
Set
(
other
.
Take
(
)
)
;
return
*
this
;
}
void
Set
(
Handle
handle
)
{
if
(
handle_
!
=
handle
)
{
auto
last_error
=
:
:
GetLastError
(
)
;
Close
(
)
;
if
(
Traits
:
:
IsHandleValid
(
handle
)
)
{
handle_
=
handle
;
Verifier
:
:
StartTracking
(
handle
this
BASE_WIN_GET_CALLER
GetProgramCounter
(
)
)
;
}
:
:
SetLastError
(
last_error
)
;
}
}
Handle
get
(
)
const
{
return
handle_
;
}
Handle
Get
(
)
const
{
return
get
(
)
;
}
[
[
nodiscard
]
]
Handle
release
(
)
{
Handle
temp
=
handle_
;
handle_
=
Traits
:
:
NullHandle
(
)
;
if
(
Traits
:
:
IsHandleValid
(
temp
)
)
{
Verifier
:
:
StopTracking
(
temp
this
BASE_WIN_GET_CALLER
GetProgramCounter
(
)
)
;
}
return
temp
;
}
[
[
nodiscard
]
]
Handle
Take
(
)
{
return
release
(
)
;
}
void
Close
(
)
{
if
(
Traits
:
:
IsHandleValid
(
handle_
)
)
{
Verifier
:
:
StopTracking
(
handle_
this
BASE_WIN_GET_CALLER
GetProgramCounter
(
)
)
;
Traits
:
:
CloseHandle
(
handle_
)
;
handle_
=
Traits
:
:
NullHandle
(
)
;
}
}
private
:
FRIEND_TEST_ALL_PREFIXES
(
ScopedHandleDeathTest
HandleVerifierWrongOwner
)
;
FRIEND_TEST_ALL_PREFIXES
(
ScopedHandleDeathTest
HandleVerifierUntrackedHandle
)
;
Handle
handle_
;
}
;
#
undef
BASE_WIN_GET_CALLER
class
HandleTraits
{
public
:
using
Handle
=
HANDLE
;
HandleTraits
(
)
=
delete
;
HandleTraits
(
const
HandleTraits
&
)
=
delete
;
HandleTraits
&
operator
=
(
const
HandleTraits
&
)
=
delete
;
static
bool
BASE_EXPORT
CloseHandle
(
HANDLE
handle
)
;
static
bool
IsHandleValid
(
HANDLE
handle
)
{
return
handle
!
=
nullptr
&
&
handle
!
=
INVALID_HANDLE_VALUE
;
}
static
HANDLE
NullHandle
(
)
{
return
nullptr
;
}
}
;
class
DummyVerifierTraits
{
public
:
using
Handle
=
HANDLE
;
DummyVerifierTraits
(
)
=
delete
;
DummyVerifierTraits
(
const
DummyVerifierTraits
&
)
=
delete
;
DummyVerifierTraits
&
operator
=
(
const
DummyVerifierTraits
&
)
=
delete
;
static
void
StartTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
}
static
void
StopTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
}
}
;
class
BASE_EXPORT
VerifierTraits
{
public
:
using
Handle
=
HANDLE
;
VerifierTraits
(
)
=
delete
;
VerifierTraits
(
const
VerifierTraits
&
)
=
delete
;
VerifierTraits
&
operator
=
(
const
VerifierTraits
&
)
=
delete
;
static
void
StartTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
;
static
void
StopTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
;
}
;
using
UncheckedScopedHandle
=
GenericScopedHandle
<
HandleTraits
DummyVerifierTraits
>
;
using
CheckedScopedHandle
=
GenericScopedHandle
<
HandleTraits
VerifierTraits
>
;
#
if
DCHECK_IS_ON
(
)
using
ScopedHandle
=
CheckedScopedHandle
;
#
else
using
ScopedHandle
=
UncheckedScopedHandle
;
#
endif
BASE_EXPORT
void
DisableHandleVerifier
(
)
;
BASE_EXPORT
void
OnHandleBeingClosed
(
HANDLE
handle
HandleOperation
operation
)
;
}
}
#
endif
