#
include
"
base
/
win
/
scoped_handle_verifier
.
h
"
#
include
<
windows
.
h
>
#
include
<
stddef
.
h
>
#
include
<
unordered_map
>
#
include
<
utility
>
#
include
"
base
/
auto_reset
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
debug
/
alias
.
h
"
#
include
"
base
/
debug
/
stack_trace
.
h
"
#
include
"
base
/
memory
/
raw_ref
.
h
"
#
include
"
base
/
synchronization
/
lock_impl
.
h
"
#
include
"
base
/
trace_event
/
base_tracing
.
h
"
#
include
"
base
/
win
/
base_win_buildflags
.
h
"
#
include
"
base
/
win
/
current_module
.
h
"
#
include
"
base
/
win
/
scoped_handle
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
base
/
attributes
.
h
"
extern
"
C
"
{
__declspec
(
dllexport
)
void
*
GetHandleVerifier
(
)
;
void
*
GetHandleVerifier
(
)
{
return
base
:
:
win
:
:
internal
:
:
ScopedHandleVerifier
:
:
Get
(
)
;
}
}
namespace
base
{
namespace
win
{
namespace
internal
{
namespace
{
ScopedHandleVerifier
*
g_active_verifier
=
nullptr
;
ABSL_CONST_INIT
thread_local
bool
closing
=
false
;
using
GetHandleVerifierFn
=
void
*
(
*
)
(
)
;
using
HandleMap
=
std
:
:
unordered_map
<
HANDLE
ScopedHandleVerifierInfo
HandleHash
>
;
using
NativeLock
=
base
:
:
internal
:
:
LockImpl
;
NOINLINE
void
ReportErrorOnScopedHandleOperation
(
const
debug
:
:
StackTrace
&
creation_stack
HandleOperation
operation
)
{
auto
creation_stack_copy
=
creation_stack
;
debug
:
:
Alias
(
&
creation_stack_copy
)
;
debug
:
:
Alias
(
&
operation
)
;
CHECK
(
false
)
<
<
operation
;
__builtin_unreachable
(
)
;
}
NOINLINE
void
ReportErrorOnScopedHandleOperation
(
const
debug
:
:
StackTrace
&
creation_stack
const
ScopedHandleVerifierInfo
&
other
HandleOperation
operation
)
{
auto
other_stack_copy
=
*
other
.
stack
;
debug
:
:
Alias
(
&
other_stack_copy
)
;
auto
creation_stack_copy
=
creation_stack
;
debug
:
:
Alias
(
&
creation_stack_copy
)
;
debug
:
:
Alias
(
&
operation
)
;
CHECK
(
false
)
<
<
operation
;
__builtin_unreachable
(
)
;
}
}
class
AutoNativeLock
{
public
:
explicit
AutoNativeLock
(
NativeLock
&
lock
)
:
lock_
(
lock
)
{
lock_
-
>
Lock
(
)
;
}
AutoNativeLock
(
const
AutoNativeLock
&
)
=
delete
;
AutoNativeLock
&
operator
=
(
const
AutoNativeLock
&
)
=
delete
;
~
AutoNativeLock
(
)
{
lock_
-
>
Unlock
(
)
;
}
private
:
const
raw_ref
<
NativeLock
>
lock_
;
}
;
ScopedHandleVerifierInfo
:
:
ScopedHandleVerifierInfo
(
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
std
:
:
unique_ptr
<
debug
:
:
StackTrace
>
stack
DWORD
thread_id
)
:
owner
(
owner
)
pc1
(
pc1
)
pc2
(
pc2
)
stack
(
std
:
:
move
(
stack
)
)
thread_id
(
thread_id
)
{
}
ScopedHandleVerifierInfo
:
:
~
ScopedHandleVerifierInfo
(
)
=
default
;
ScopedHandleVerifierInfo
:
:
ScopedHandleVerifierInfo
(
ScopedHandleVerifierInfo
&
&
)
noexcept
=
default
;
ScopedHandleVerifierInfo
&
ScopedHandleVerifierInfo
:
:
operator
=
(
ScopedHandleVerifierInfo
&
&
)
noexcept
=
default
;
ScopedHandleVerifier
:
:
ScopedHandleVerifier
(
bool
enabled
)
:
enabled_
(
enabled
)
lock_
(
GetLock
(
)
)
{
}
ScopedHandleVerifier
*
ScopedHandleVerifier
:
:
Get
(
)
{
if
(
!
g_active_verifier
)
ScopedHandleVerifier
:
:
InstallVerifier
(
)
;
return
g_active_verifier
;
}
bool
CloseHandleWrapper
(
HANDLE
handle
)
{
if
(
!
:
:
CloseHandle
(
handle
)
)
#
if
defined
(
NIGHTLY_BUILD
)
CHECK
(
false
)
<
<
"
CloseHandle
failed
"
;
#
else
DCHECK
(
false
)
<
<
"
CloseHandle
failed
"
;
#
endif
return
true
;
}
void
ScopedHandleVerifier
:
:
ThreadSafeAssignOrCreateScopedHandleVerifier
(
ScopedHandleVerifier
*
existing_verifier
bool
enabled
)
{
AutoNativeLock
lock
(
*
GetLock
(
)
)
;
if
(
g_active_verifier
)
return
;
g_active_verifier
=
existing_verifier
?
existing_verifier
:
new
ScopedHandleVerifier
(
enabled
)
;
}
void
ScopedHandleVerifier
:
:
InstallVerifier
(
)
{
#
if
BUILDFLAG
(
SINGLE_MODULE_MODE_HANDLE_VERIFIER
)
ThreadSafeAssignOrCreateScopedHandleVerifier
(
nullptr
true
)
;
#
else
HMODULE
main_module
=
:
:
GetModuleHandle
(
NULL
)
;
GetHandleVerifierFn
get_handle_verifier
=
reinterpret_cast
<
GetHandleVerifierFn
>
(
:
:
GetProcAddress
(
main_module
"
GetHandleVerifier
"
)
)
;
if
(
!
get_handle_verifier
)
{
ThreadSafeAssignOrCreateScopedHandleVerifier
(
nullptr
false
)
;
return
;
}
if
(
get_handle_verifier
=
=
GetHandleVerifier
)
{
ThreadSafeAssignOrCreateScopedHandleVerifier
(
nullptr
true
)
;
return
;
}
ScopedHandleVerifier
*
main_module_verifier
=
reinterpret_cast
<
ScopedHandleVerifier
*
>
(
get_handle_verifier
(
)
)
;
DCHECK
(
main_module_verifier
)
;
ThreadSafeAssignOrCreateScopedHandleVerifier
(
main_module_verifier
false
)
;
#
endif
}
bool
ScopedHandleVerifier
:
:
CloseHandle
(
HANDLE
handle
)
{
if
(
!
enabled_
)
return
CloseHandleWrapper
(
handle
)
;
const
AutoReset
<
bool
>
resetter
(
&
closing
true
)
;
CloseHandleWrapper
(
handle
)
;
return
true
;
}
NativeLock
*
ScopedHandleVerifier
:
:
GetLock
(
)
{
static
auto
*
native_lock
=
new
NativeLock
(
)
;
return
native_lock
;
}
void
ScopedHandleVerifier
:
:
StartTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
if
(
enabled_
)
StartTrackingImpl
(
handle
owner
pc1
pc2
)
;
}
void
ScopedHandleVerifier
:
:
StopTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
if
(
enabled_
)
StopTrackingImpl
(
handle
owner
pc1
pc2
)
;
}
void
ScopedHandleVerifier
:
:
Disable
(
)
{
enabled_
=
false
;
}
void
ScopedHandleVerifier
:
:
OnHandleBeingClosed
(
HANDLE
handle
HandleOperation
operation
)
{
if
(
enabled_
)
OnHandleBeingClosedImpl
(
handle
operation
)
;
}
HMODULE
ScopedHandleVerifier
:
:
GetModule
(
)
const
{
return
CURRENT_MODULE
(
)
;
}
NOINLINE
void
ScopedHandleVerifier
:
:
StartTrackingImpl
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
DWORD
thread_id
=
GetCurrentThreadId
(
)
;
auto
stacktrace
=
std
:
:
make_unique
<
debug
:
:
StackTrace
>
(
)
;
AutoNativeLock
lock
(
*
lock_
)
;
std
:
:
pair
<
HandleMap
:
:
iterator
bool
>
result
=
map_
.
emplace
(
handle
ScopedHandleVerifierInfo
{
owner
pc1
pc2
std
:
:
move
(
stacktrace
)
thread_id
}
)
;
if
(
!
result
.
second
)
{
ReportErrorOnScopedHandleOperation
(
creation_stack_
result
.
first
-
>
second
HandleOperation
:
:
kHandleAlreadyTracked
)
;
}
}
NOINLINE
void
ScopedHandleVerifier
:
:
StopTrackingImpl
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
AutoNativeLock
lock
(
*
lock_
)
;
HandleMap
:
:
iterator
i
=
map_
.
find
(
handle
)
;
if
(
i
=
=
map_
.
end
(
)
)
{
ReportErrorOnScopedHandleOperation
(
creation_stack_
HandleOperation
:
:
kCloseHandleNotTracked
)
;
}
if
(
i
-
>
second
.
owner
!
=
owner
)
{
ReportErrorOnScopedHandleOperation
(
creation_stack_
i
-
>
second
HandleOperation
:
:
kCloseHandleNotOwner
)
;
}
map_
.
erase
(
i
)
;
}
NOINLINE
void
ScopedHandleVerifier
:
:
OnHandleBeingClosedImpl
(
HANDLE
handle
HandleOperation
operation
)
{
if
(
closing
)
{
return
;
}
AutoNativeLock
lock
(
*
lock_
)
;
HandleMap
:
:
iterator
i
=
map_
.
find
(
handle
)
;
if
(
i
!
=
map_
.
end
(
)
)
{
ReportErrorOnScopedHandleOperation
(
creation_stack_
i
-
>
second
operation
)
;
}
}
HMODULE
GetHandleVerifierModuleForTesting
(
)
{
return
g_active_verifier
-
>
GetModule
(
)
;
}
}
}
}
