#
include
"
base
/
win
/
scoped_handle_verifier
.
h
"
#
include
<
stddef
.
h
>
#
include
<
windows
.
h
>
#
include
<
unordered_map
>
#
include
"
base
/
debug
/
alias
.
h
"
#
include
"
base
/
debug
/
stack_trace
.
h
"
#
include
"
base
/
synchronization
/
lock_impl
.
h
"
#
include
"
base
/
win
/
base_win_buildflags
.
h
"
#
include
"
base
/
win
/
current_module
.
h
"
extern
"
C
"
{
__declspec
(
dllexport
)
void
*
GetHandleVerifier
(
)
;
void
*
GetHandleVerifier
(
)
{
return
base
:
:
win
:
:
internal
:
:
ScopedHandleVerifier
:
:
Get
(
)
;
}
}
namespace
{
base
:
:
win
:
:
internal
:
:
ScopedHandleVerifier
*
g_active_verifier
=
NULL
;
typedef
void
*
(
*
GetHandleVerifierFn
)
(
)
;
typedef
std
:
:
unordered_map
<
HANDLE
base
:
:
win
:
:
internal
:
:
ScopedHandleVerifierInfo
base
:
:
win
:
:
internal
:
:
HandleHash
>
HandleMap
;
typedef
base
:
:
internal
:
:
LockImpl
NativeLock
;
NativeLock
*
GetLock
(
)
{
static
auto
*
native_lock
=
new
NativeLock
(
)
;
return
native_lock
;
}
class
AutoNativeLock
{
public
:
explicit
AutoNativeLock
(
NativeLock
&
lock
)
:
lock_
(
lock
)
{
lock_
.
Lock
(
)
;
}
~
AutoNativeLock
(
)
{
lock_
.
Unlock
(
)
;
}
private
:
NativeLock
&
lock_
;
DISALLOW_COPY_AND_ASSIGN
(
AutoNativeLock
)
;
}
;
}
namespace
base
{
namespace
win
{
namespace
internal
{
ScopedHandleVerifier
:
:
ScopedHandleVerifier
(
bool
enabled
)
:
enabled_
(
enabled
)
lock_
(
GetLock
(
)
)
{
}
ScopedHandleVerifier
*
ScopedHandleVerifier
:
:
Get
(
)
{
if
(
!
g_active_verifier
)
ScopedHandleVerifier
:
:
InstallVerifier
(
)
;
return
g_active_verifier
;
}
bool
CloseHandleWrapper
(
HANDLE
handle
)
{
if
(
!
:
:
CloseHandle
(
handle
)
)
#
if
defined
(
NIGHTLY_BUILD
)
CHECK
(
false
)
;
#
else
DCHECK
(
false
)
;
#
endif
return
true
;
}
void
ThreadSafeAssignOrCreateScopedHandleVerifier
(
ScopedHandleVerifier
*
existing_verifier
bool
enabled
)
{
AutoNativeLock
lock
(
*
GetLock
(
)
)
;
if
(
g_active_verifier
)
return
;
g_active_verifier
=
existing_verifier
?
existing_verifier
:
new
ScopedHandleVerifier
(
enabled
)
;
}
void
ScopedHandleVerifier
:
:
InstallVerifier
(
)
{
#
if
BUILDFLAG
(
SINGLE_MODULE_MODE_HANDLE_VERIFIER
)
ThreadSafeAssignOrCreateScopedHandleVerifier
(
nullptr
true
)
;
#
else
HMODULE
main_module
=
:
:
GetModuleHandle
(
NULL
)
;
GetHandleVerifierFn
get_handle_verifier
=
reinterpret_cast
<
GetHandleVerifierFn
>
(
:
:
GetProcAddress
(
main_module
"
GetHandleVerifier
"
)
)
;
if
(
!
get_handle_verifier
)
{
ThreadSafeAssignOrCreateScopedHandleVerifier
(
nullptr
false
)
;
return
;
}
if
(
get_handle_verifier
=
=
GetHandleVerifier
)
{
ThreadSafeAssignOrCreateScopedHandleVerifier
(
nullptr
true
)
;
return
;
}
ScopedHandleVerifier
*
main_module_verifier
=
reinterpret_cast
<
ScopedHandleVerifier
*
>
(
get_handle_verifier
(
)
)
;
DCHECK
(
main_module_verifier
)
;
ThreadSafeAssignOrCreateScopedHandleVerifier
(
main_module_verifier
false
)
;
#
endif
}
bool
ScopedHandleVerifier
:
:
CloseHandle
(
HANDLE
handle
)
{
if
(
!
enabled_
)
return
CloseHandleWrapper
(
handle
)
;
closing_
.
Set
(
true
)
;
CloseHandleWrapper
(
handle
)
;
closing_
.
Set
(
false
)
;
return
true
;
}
NativeLock
*
ScopedHandleVerifier
:
:
GetLock
(
)
{
return
:
:
GetLock
(
)
;
}
void
ScopedHandleVerifier
:
:
StartTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
if
(
!
enabled_
)
return
;
DWORD
thread_id
=
GetCurrentThreadId
(
)
;
AutoNativeLock
lock
(
*
lock_
)
;
ScopedHandleVerifierInfo
handle_info
=
{
owner
pc1
pc2
base
:
:
debug
:
:
StackTrace
(
)
thread_id
}
;
std
:
:
pair
<
HANDLE
ScopedHandleVerifierInfo
>
item
(
handle
handle_info
)
;
std
:
:
pair
<
HandleMap
:
:
iterator
bool
>
result
=
map_
.
insert
(
item
)
;
if
(
!
result
.
second
)
{
ScopedHandleVerifierInfo
other
=
result
.
first
-
>
second
;
base
:
:
debug
:
:
Alias
(
&
other
)
;
auto
creation_stack
=
creation_stack_
;
base
:
:
debug
:
:
Alias
(
&
creation_stack
)
;
CHECK
(
false
)
;
}
}
void
ScopedHandleVerifier
:
:
StopTracking
(
HANDLE
handle
const
void
*
owner
const
void
*
pc1
const
void
*
pc2
)
{
if
(
!
enabled_
)
return
;
AutoNativeLock
lock
(
*
lock_
)
;
HandleMap
:
:
iterator
i
=
map_
.
find
(
handle
)
;
if
(
i
=
=
map_
.
end
(
)
)
{
auto
creation_stack
=
creation_stack_
;
base
:
:
debug
:
:
Alias
(
&
creation_stack
)
;
CHECK
(
false
)
;
}
ScopedHandleVerifierInfo
other
=
i
-
>
second
;
if
(
other
.
owner
!
=
owner
)
{
base
:
:
debug
:
:
Alias
(
&
other
)
;
auto
creation_stack
=
creation_stack_
;
base
:
:
debug
:
:
Alias
(
&
creation_stack
)
;
CHECK
(
false
)
;
}
map_
.
erase
(
i
)
;
}
void
ScopedHandleVerifier
:
:
Disable
(
)
{
enabled_
=
false
;
}
void
ScopedHandleVerifier
:
:
OnHandleBeingClosed
(
HANDLE
handle
)
{
if
(
!
enabled_
)
return
;
if
(
closing_
.
Get
(
)
)
return
;
AutoNativeLock
lock
(
*
lock_
)
;
HandleMap
:
:
iterator
i
=
map_
.
find
(
handle
)
;
if
(
i
=
=
map_
.
end
(
)
)
return
;
ScopedHandleVerifierInfo
other
=
i
-
>
second
;
base
:
:
debug
:
:
Alias
(
&
other
)
;
auto
creation_stack
=
creation_stack_
;
base
:
:
debug
:
:
Alias
(
&
creation_stack
)
;
CHECK
(
false
)
;
}
HMODULE
ScopedHandleVerifier
:
:
GetModule
(
)
const
{
return
CURRENT_MODULE
(
)
;
}
HMODULE
GetHandleVerifierModuleForTesting
(
)
{
return
g_active_verifier
-
>
GetModule
(
)
;
}
}
}
}
