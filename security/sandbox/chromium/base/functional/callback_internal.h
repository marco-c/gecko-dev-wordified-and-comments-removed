#
ifndef
BASE_FUNCTIONAL_CALLBACK_INTERNAL_H_
#
define
BASE_FUNCTIONAL_CALLBACK_INTERNAL_H_
#
include
<
utility
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
functional
/
callback_forward
.
h
"
#
include
"
base
/
memory
/
ref_counted
.
h
"
namespace
base
{
struct
FakeBindState
;
namespace
internal
{
class
BindStateBase
;
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
struct
BindState
;
struct
BASE_EXPORT
BindStateBaseRefCountTraits
{
static
void
Destruct
(
const
BindStateBase
*
)
;
}
;
template
<
typename
T
>
using
PassingType
=
std
:
:
conditional_t
<
std
:
:
is_scalar_v
<
T
>
T
T
&
&
>
;
class
BASE_EXPORT
BindStateBase
:
public
RefCountedThreadSafe
<
BindStateBase
BindStateBaseRefCountTraits
>
{
public
:
REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE
(
)
;
enum
CancellationQueryMode
{
IS_CANCELLED
MAYBE_VALID
}
;
using
InvokeFuncStorage
=
void
(
*
)
(
)
;
BindStateBase
(
const
BindStateBase
&
)
=
delete
;
BindStateBase
&
operator
=
(
const
BindStateBase
&
)
=
delete
;
private
:
BindStateBase
(
InvokeFuncStorage
polymorphic_invoke
void
(
*
destructor
)
(
const
BindStateBase
*
)
)
;
BindStateBase
(
InvokeFuncStorage
polymorphic_invoke
void
(
*
destructor
)
(
const
BindStateBase
*
)
bool
(
*
query_cancellation_traits
)
(
const
BindStateBase
*
CancellationQueryMode
mode
)
)
;
~
BindStateBase
(
)
=
default
;
friend
struct
BindStateBaseRefCountTraits
;
friend
class
RefCountedThreadSafe
<
BindStateBase
BindStateBaseRefCountTraits
>
;
friend
class
BindStateHolder
;
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
friend
struct
BindState
;
friend
struct
:
:
base
:
:
FakeBindState
;
bool
IsCancelled
(
)
const
{
return
query_cancellation_traits_
(
this
IS_CANCELLED
)
;
}
bool
MaybeValid
(
)
const
{
return
query_cancellation_traits_
(
this
MAYBE_VALID
)
;
}
InvokeFuncStorage
polymorphic_invoke_
;
void
(
*
destructor_
)
(
const
BindStateBase
*
)
;
bool
(
*
query_cancellation_traits_
)
(
const
BindStateBase
*
CancellationQueryMode
mode
)
;
}
;
class
BASE_EXPORT
TRIVIAL_ABI
BindStateHolder
{
public
:
using
InvokeFuncStorage
=
BindStateBase
:
:
InvokeFuncStorage
;
inline
constexpr
BindStateHolder
(
)
noexcept
;
inline
explicit
BindStateHolder
(
BindStateBase
*
bind_state
)
;
BindStateHolder
(
const
BindStateHolder
&
)
;
BindStateHolder
&
operator
=
(
const
BindStateHolder
&
)
;
inline
BindStateHolder
(
BindStateHolder
&
&
)
noexcept
;
BindStateHolder
&
operator
=
(
BindStateHolder
&
&
)
noexcept
;
~
BindStateHolder
(
)
;
bool
is_null
(
)
const
{
return
!
bind_state_
;
}
explicit
operator
bool
(
)
const
{
return
!
is_null
(
)
;
}
bool
IsCancelled
(
)
const
;
bool
MaybeValid
(
)
const
;
void
Reset
(
)
;
bool
operator
=
=
(
const
BindStateHolder
&
other
)
const
{
return
bind_state_
=
=
other
.
bind_state_
;
}
const
scoped_refptr
<
BindStateBase
>
&
bind_state
(
)
const
{
return
bind_state_
;
}
InvokeFuncStorage
polymorphic_invoke
(
)
const
{
return
bind_state_
-
>
polymorphic_invoke_
;
}
private
:
scoped_refptr
<
BindStateBase
>
bind_state_
;
}
;
constexpr
BindStateHolder
:
:
BindStateHolder
(
)
noexcept
=
default
;
BindStateHolder
:
:
BindStateHolder
(
BindStateBase
*
bind_state
)
:
bind_state_
(
AdoptRef
(
bind_state
)
)
{
}
BindStateHolder
:
:
BindStateHolder
(
BindStateHolder
&
&
)
noexcept
=
default
;
template
<
typename
OriginalCallback
typename
ThenCallback
>
struct
ThenHelper
;
template
<
template
<
typename
>
class
OriginalCallback
template
<
typename
>
class
ThenCallback
typename
.
.
.
OriginalArgs
typename
ThenR
typename
.
.
.
ThenArgs
>
struct
ThenHelper
<
OriginalCallback
<
void
(
OriginalArgs
.
.
.
)
>
ThenCallback
<
ThenR
(
ThenArgs
.
.
.
)
>
>
{
static_assert
(
sizeof
.
.
.
(
ThenArgs
)
=
=
0
"
|
then
|
callback
cannot
accept
parameters
if
|
this
|
has
a
"
"
void
return
type
.
"
)
;
static
auto
CreateTrampoline
(
)
{
return
[
]
(
OriginalCallback
<
void
(
OriginalArgs
.
.
.
)
>
c1
ThenCallback
<
ThenR
(
ThenArgs
.
.
.
)
>
c2
OriginalArgs
.
.
.
c1_args
)
{
std
:
:
move
(
c1
)
.
Run
(
std
:
:
forward
<
OriginalArgs
>
(
c1_args
)
.
.
.
)
;
return
std
:
:
move
(
c2
)
.
Run
(
)
;
}
;
}
}
;
template
<
template
<
typename
>
class
OriginalCallback
template
<
typename
>
class
ThenCallback
typename
OriginalR
typename
.
.
.
OriginalArgs
typename
ThenR
typename
.
.
.
ThenArgs
>
struct
ThenHelper
<
OriginalCallback
<
OriginalR
(
OriginalArgs
.
.
.
)
>
ThenCallback
<
ThenR
(
ThenArgs
.
.
.
)
>
>
{
static_assert
(
sizeof
.
.
.
(
ThenArgs
)
=
=
1
"
|
then
|
callback
must
accept
exactly
one
parameter
if
|
this
|
"
"
has
a
non
-
void
return
type
.
"
)
;
static_assert
(
std
:
:
is_constructible_v
<
ThenArgs
.
.
.
OriginalR
&
&
>
"
|
then
|
callback
'
s
parameter
must
be
constructible
from
"
"
return
type
of
|
this
|
.
"
)
;
static
auto
CreateTrampoline
(
)
{
return
[
]
(
OriginalCallback
<
OriginalR
(
OriginalArgs
.
.
.
)
>
c1
ThenCallback
<
ThenR
(
ThenArgs
.
.
.
)
>
c2
OriginalArgs
.
.
.
c1_args
)
{
return
std
:
:
move
(
c2
)
.
Run
(
std
:
:
move
(
c1
)
.
Run
(
std
:
:
forward
<
OriginalArgs
>
(
c1_args
)
.
.
.
)
)
;
}
;
}
}
;
}
}
#
endif
