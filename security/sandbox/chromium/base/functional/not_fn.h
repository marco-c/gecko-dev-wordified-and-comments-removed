#
ifndef
BASE_FUNCTIONAL_NOT_FN_H_
#
define
BASE_FUNCTIONAL_NOT_FN_H_
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
functional
/
invoke
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
F
>
struct
NotFnImpl
{
F
f
;
template
<
typename
.
.
.
Args
>
constexpr
decltype
(
auto
)
operator
(
)
(
Args
&
&
.
.
.
args
)
&
noexcept
{
return
!
base
:
:
invoke
(
f
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
constexpr
decltype
(
auto
)
operator
(
)
(
Args
&
&
.
.
.
args
)
const
&
noexcept
{
return
!
base
:
:
invoke
(
f
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
constexpr
decltype
(
auto
)
operator
(
)
(
Args
&
&
.
.
.
args
)
&
&
noexcept
{
return
!
base
:
:
invoke
(
std
:
:
move
(
f
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
constexpr
decltype
(
auto
)
operator
(
)
(
Args
&
&
.
.
.
args
)
const
&
&
noexcept
{
return
!
base
:
:
invoke
(
std
:
:
move
(
f
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
}
template
<
typename
F
>
constexpr
internal
:
:
NotFnImpl
<
std
:
:
decay_t
<
F
>
>
not_fn
(
F
&
&
f
)
{
return
{
std
:
:
forward
<
F
>
(
f
)
}
;
}
}
#
endif
