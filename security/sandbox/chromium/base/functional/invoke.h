#
ifndef
BASE_FUNCTIONAL_INVOKE_H_
#
define
BASE_FUNCTIONAL_INVOKE_H_
#
include
<
type_traits
>
#
include
<
utility
>
namespace
base
{
namespace
internal
{
template
<
typename
DecayedF
>
struct
member_pointer_class
{
}
;
template
<
typename
ReturnT
typename
ClassT
>
struct
member_pointer_class
<
ReturnT
ClassT
:
:
*
>
{
using
type
=
ClassT
;
}
;
template
<
typename
DecayedF
>
using
member_pointer_class_t
=
typename
member_pointer_class
<
DecayedF
>
:
:
type
;
template
<
typename
T
>
struct
is_reference_wrapper
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
is_reference_wrapper
<
std
:
:
reference_wrapper
<
T
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
F
>
const
bool
&
IsMemFunPtr
=
std
:
:
is_member_function_pointer_v
<
std
:
:
decay_t
<
F
>
>
;
template
<
typename
F
>
const
bool
&
IsMemObjPtr
=
std
:
:
is_member_object_pointer_v
<
std
:
:
decay_t
<
F
>
>
;
template
<
typename
F
typename
T
typename
MemPtrClass
=
member_pointer_class_t
<
std
:
:
decay_t
<
F
>
>
>
const
bool
&
IsMemPtrToBaseOf
=
std
:
:
is_base_of_v
<
MemPtrClass
std
:
:
decay_t
<
T
>
>
;
template
<
typename
T
>
const
bool
&
IsRefWrapper
=
is_reference_wrapper
<
std
:
:
decay_t
<
T
>
>
:
:
value
;
template
<
bool
B
>
using
EnableIf
=
std
:
:
enable_if_t
<
B
bool
>
;
template
<
typename
F
typename
T1
typename
.
.
.
Args
EnableIf
<
IsMemFunPtr
<
F
>
&
&
IsMemPtrToBaseOf
<
F
T1
>
>
=
true
>
constexpr
decltype
(
auto
)
InvokeImpl
(
F
&
&
f
T1
&
&
t1
Args
&
&
.
.
.
args
)
{
return
(
std
:
:
forward
<
T1
>
(
t1
)
.
*
f
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
F
typename
T1
typename
.
.
.
Args
EnableIf
<
IsMemFunPtr
<
F
>
&
&
IsRefWrapper
<
T1
>
>
=
true
>
constexpr
decltype
(
auto
)
InvokeImpl
(
F
&
&
f
T1
&
&
t1
Args
&
&
.
.
.
args
)
{
return
(
t1
.
get
(
)
.
*
f
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
F
typename
T1
typename
.
.
.
Args
EnableIf
<
IsMemFunPtr
<
F
>
&
&
!
IsMemPtrToBaseOf
<
F
T1
>
&
&
!
IsRefWrapper
<
T1
>
>
=
true
>
constexpr
decltype
(
auto
)
InvokeImpl
(
F
&
&
f
T1
&
&
t1
Args
&
&
.
.
.
args
)
{
return
(
(
*
std
:
:
forward
<
T1
>
(
t1
)
)
.
*
f
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
F
typename
T1
EnableIf
<
IsMemObjPtr
<
F
>
&
&
IsMemPtrToBaseOf
<
F
T1
>
>
=
true
>
constexpr
decltype
(
auto
)
InvokeImpl
(
F
&
&
f
T1
&
&
t1
)
{
return
std
:
:
forward
<
T1
>
(
t1
)
.
*
f
;
}
template
<
typename
F
typename
T1
EnableIf
<
IsMemObjPtr
<
F
>
&
&
IsRefWrapper
<
T1
>
>
=
true
>
constexpr
decltype
(
auto
)
InvokeImpl
(
F
&
&
f
T1
&
&
t1
)
{
return
t1
.
get
(
)
.
*
f
;
}
template
<
typename
F
typename
T1
EnableIf
<
IsMemObjPtr
<
F
>
&
&
!
IsMemPtrToBaseOf
<
F
T1
>
&
&
!
IsRefWrapper
<
T1
>
>
=
true
>
constexpr
decltype
(
auto
)
InvokeImpl
(
F
&
&
f
T1
&
&
t1
)
{
return
(
*
std
:
:
forward
<
T1
>
(
t1
)
)
.
*
f
;
}
template
<
typename
F
typename
.
.
.
Args
>
constexpr
decltype
(
auto
)
InvokeImpl
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
return
std
:
:
forward
<
F
>
(
f
)
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
template
<
typename
F
typename
.
.
.
Args
>
constexpr
decltype
(
auto
)
invoke
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
return
internal
:
:
InvokeImpl
(
std
:
:
forward
<
F
>
(
f
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
#
endif
