#
ifndef
BASE_FUNCTIONAL_BIND_INTERNAL_H_
#
define
BASE_FUNCTIONAL_BIND_INTERNAL_H_
#
include
<
stddef
.
h
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_buildflags
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
partition_alloc_config
.
h
"
#
include
"
base
/
allocator
/
partition_allocator
/
src
/
partition_alloc
/
pointers
/
raw_ptr
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
functional
/
callback_internal
.
h
"
#
include
"
base
/
functional
/
disallow_unretained
.
h
"
#
include
"
base
/
functional
/
unretained_traits
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
base
/
memory
/
raw_ptr_asan_bound_arg_tracker
.
h
"
#
include
"
base
/
memory
/
raw_ref
.
h
"
#
include
"
base
/
memory
/
raw_scoped_refptr_mismatch_checker
.
h
"
#
include
"
base
/
memory
/
weak_ptr
.
h
"
#
include
"
base
/
notreached
.
h
"
#
include
"
base
/
types
/
always_false
.
h
"
#
include
"
build
/
build_config
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
functional
/
function_ref
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
namespace
Microsoft
{
namespace
WRL
{
template
<
typename
>
class
ComPtr
;
}
}
#
endif
namespace
base
{
template
<
typename
T
>
struct
IsWeakReceiver
;
template
<
typename
>
struct
BindUnwrapTraits
;
template
<
typename
Functor
typename
BoundArgsTuple
typename
SFINAE
=
void
>
struct
CallbackCancellationTraits
;
template
<
typename
Signature
>
class
FunctionRef
;
namespace
unretained_traits
{
struct
MayNotDangle
{
}
;
struct
MayDangle
{
}
;
struct
MayDangleUntriaged
{
}
;
}
namespace
internal
{
template
<
typename
Functor
typename
SFINAE
=
void
>
struct
FunctorTraits
;
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
=
RawPtrTraits
:
:
kEmpty
>
class
UnretainedWrapper
{
using
DanglingRawPtrType
=
MayBeDangling
<
T
PtrTraits
>
;
public
:
using
GetPtrType
=
std
:
:
conditional_t
<
raw_ptr_traits
:
:
IsSupportedType
<
T
>
:
:
value
&
&
std
:
:
is_same_v
<
UnretainedTrait
unretained_traits
:
:
MayDangle
>
DanglingRawPtrType
T
*
>
;
static_assert
(
TypeSupportsUnretainedV
<
T
>
"
Callback
cannot
capture
an
unprotected
C
+
+
pointer
since
this
"
"
Type
is
annotated
with
DISALLOW_UNRETAINED
(
)
.
Please
see
"
"
base
/
functional
/
disallow_unretained
.
h
for
alternatives
.
"
)
;
template
<
RawPtrTraits
PTraits
=
PtrTraits
typename
=
std
:
:
enable_if_t
<
PTraits
=
=
RawPtrTraits
:
:
kEmpty
>
>
explicit
UnretainedWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
template
<
typename
U
=
T
>
explicit
UnretainedWrapper
(
const
raw_ptr
<
U
PtrTraits
>
&
o
)
:
ptr_
(
o
)
{
}
template
<
typename
U
=
T
>
explicit
UnretainedWrapper
(
raw_ptr
<
U
PtrTraits
>
&
&
o
)
:
ptr_
(
std
:
:
move
(
o
)
)
{
}
GetPtrType
get
(
)
const
{
return
GetInternal
(
ptr_
)
;
}
private
:
template
<
typename
U
>
static
GetPtrType
GetInternal
(
U
*
ptr
)
{
static_assert
(
std
:
:
is_same_v
<
T
U
>
)
;
return
ptr
;
}
template
<
typename
U
RawPtrTraits
Traits
>
static
GetPtrType
GetInternal
(
const
raw_ptr
<
U
Traits
>
&
ptr
)
{
static_assert
(
std
:
:
is_same_v
<
T
U
>
)
;
if
constexpr
(
std
:
:
is_same_v
<
UnretainedTrait
unretained_traits
:
:
MayNotDangle
>
)
{
ptr
.
ReportIfDangling
(
)
;
}
return
ptr
;
}
using
StorageType
=
std
:
:
conditional_t
<
raw_ptr_traits
:
:
IsSupportedType
<
T
>
:
:
value
DanglingRawPtrType
T
*
>
;
static_assert
(
std
:
:
is_pointer_v
<
GetPtrType
>
|
|
std
:
:
is_same_v
<
GetPtrType
StorageType
>
)
;
StorageType
ptr_
;
}
;
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
=
RawPtrTraits
:
:
kEmpty
>
class
UnretainedRefWrapper
{
public
:
static_assert
(
TypeSupportsUnretainedV
<
T
>
"
Callback
cannot
capture
an
unprotected
C
+
+
reference
since
this
"
"
type
is
annotated
with
DISALLOW_UNRETAINED
(
)
.
Please
see
"
"
base
/
functional
/
disallow_unretained
.
h
for
alternatives
.
"
)
;
template
<
RawPtrTraits
PTraits
=
PtrTraits
typename
=
std
:
:
enable_if_t
<
PTraits
=
=
RawPtrTraits
:
:
kEmpty
>
>
explicit
UnretainedRefWrapper
(
T
&
o
)
:
ref_
(
o
)
{
}
template
<
typename
U
=
T
>
explicit
UnretainedRefWrapper
(
const
raw_ref
<
U
PtrTraits
>
&
o
)
:
ref_
(
o
)
{
}
template
<
typename
U
=
T
>
explicit
UnretainedRefWrapper
(
raw_ref
<
U
PtrTraits
>
&
&
o
)
:
ref_
(
std
:
:
move
(
o
)
)
{
}
T
&
get
(
)
const
{
return
GetInternal
(
ref_
)
;
}
private
:
template
<
typename
U
>
static
T
&
GetInternal
(
U
&
ref
)
{
static_assert
(
std
:
:
is_same_v
<
T
U
>
)
;
return
ref
;
}
template
<
typename
U
RawPtrTraits
Traits
>
static
T
&
GetInternal
(
const
raw_ref
<
U
Traits
>
&
ref
)
{
static_assert
(
std
:
:
is_same_v
<
T
U
>
)
;
if
constexpr
(
std
:
:
is_same_v
<
UnretainedTrait
unretained_traits
:
:
MayNotDangle
>
)
{
ref
.
ReportIfDangling
(
)
;
}
return
ref
.
get
(
)
;
}
using
StorageType
=
std
:
:
conditional_t
<
raw_ptr_traits
:
:
IsSupportedType
<
T
>
:
:
value
raw_ref
<
T
DisableDanglingPtrDetection
>
T
&
>
;
StorageType
ref_
;
}
;
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
>
class
UnretainedRefWrapperReceiver
{
public
:
UnretainedRefWrapperReceiver
(
UnretainedRefWrapper
<
T
UnretainedTrait
PtrTraits
>
&
&
obj
)
:
obj_
(
std
:
:
move
(
obj
)
)
{
}
T
&
operator
*
(
)
const
{
return
obj_
.
get
(
)
;
}
private
:
UnretainedRefWrapper
<
T
UnretainedTrait
PtrTraits
>
obj_
;
}
;
template
<
typename
T
>
struct
MethodReceiverStorageType
{
using
Type
=
std
:
:
conditional_t
<
IsPointerV
<
T
>
scoped_refptr
<
RemovePointerT
<
T
>
>
T
>
;
}
;
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
>
struct
MethodReceiverStorageType
<
UnretainedRefWrapper
<
T
UnretainedTrait
PtrTraits
>
>
{
using
Type
=
UnretainedRefWrapperReceiver
<
T
UnretainedTrait
PtrTraits
>
;
}
;
template
<
typename
T
>
class
RetainedRefWrapper
{
public
:
explicit
RetainedRefWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
explicit
RetainedRefWrapper
(
scoped_refptr
<
T
>
o
)
:
ptr_
(
std
:
:
move
(
o
)
)
{
}
T
*
get
(
)
const
{
return
ptr_
.
get
(
)
;
}
private
:
scoped_refptr
<
T
>
ptr_
;
}
;
template
<
typename
T
>
struct
IgnoreResultHelper
{
explicit
IgnoreResultHelper
(
T
functor
)
:
functor_
(
std
:
:
move
(
functor
)
)
{
}
explicit
operator
bool
(
)
const
{
return
!
!
functor_
;
}
T
functor_
;
}
;
template
<
typename
T
typename
Deleter
=
std
:
:
default_delete
<
T
>
>
class
OwnedWrapper
{
public
:
explicit
OwnedWrapper
(
T
*
o
)
:
ptr_
(
o
)
{
}
explicit
OwnedWrapper
(
std
:
:
unique_ptr
<
T
Deleter
>
&
&
ptr
)
:
ptr_
(
std
:
:
move
(
ptr
)
)
{
}
T
*
get
(
)
const
{
return
ptr_
.
get
(
)
;
}
private
:
std
:
:
unique_ptr
<
T
Deleter
>
ptr_
;
}
;
template
<
typename
T
>
class
OwnedRefWrapper
{
public
:
explicit
OwnedRefWrapper
(
const
T
&
t
)
:
t_
(
t
)
{
}
explicit
OwnedRefWrapper
(
T
&
&
t
)
:
t_
(
std
:
:
move
(
t
)
)
{
}
T
&
get
(
)
const
{
return
t_
;
}
private
:
mutable
T
t_
;
}
;
template
<
typename
T
>
class
PassedWrapper
{
public
:
explicit
PassedWrapper
(
T
&
&
scoper
)
:
scoper_
(
std
:
:
move
(
scoper
)
)
{
}
PassedWrapper
(
PassedWrapper
&
&
other
)
:
is_valid_
(
other
.
is_valid_
)
scoper_
(
std
:
:
move
(
other
.
scoper_
)
)
{
}
T
Take
(
)
const
{
CHECK
(
is_valid_
)
;
is_valid_
=
false
;
return
std
:
:
move
(
scoper_
)
;
}
private
:
mutable
bool
is_valid_
=
true
;
mutable
T
scoper_
;
}
;
template
<
typename
T
>
using
Unwrapper
=
BindUnwrapTraits
<
std
:
:
decay_t
<
T
>
>
;
template
<
typename
T
>
decltype
(
auto
)
Unwrap
(
T
&
&
o
)
{
return
Unwrapper
<
T
>
:
:
Unwrap
(
std
:
:
forward
<
T
>
(
o
)
)
;
}
template
<
bool
is_method
typename
.
.
.
Args
>
struct
IsWeakMethod
:
std
:
:
false_type
{
}
;
template
<
typename
T
typename
.
.
.
Args
>
struct
IsWeakMethod
<
true
T
Args
.
.
.
>
:
IsWeakReceiver
<
T
>
{
}
;
template
<
typename
.
.
.
Types
>
struct
TypeList
{
}
;
template
<
size_t
n
typename
List
>
struct
DropTypeListItemImpl
;
template
<
size_t
n
typename
T
typename
.
.
.
List
>
struct
DropTypeListItemImpl
<
n
TypeList
<
T
List
.
.
.
>
>
:
DropTypeListItemImpl
<
n
-
1
TypeList
<
List
.
.
.
>
>
{
}
;
template
<
typename
T
typename
.
.
.
List
>
struct
DropTypeListItemImpl
<
0
TypeList
<
T
List
.
.
.
>
>
{
using
Type
=
TypeList
<
T
List
.
.
.
>
;
}
;
template
<
>
struct
DropTypeListItemImpl
<
0
TypeList
<
>
>
{
using
Type
=
TypeList
<
>
;
}
;
template
<
size_t
n
typename
List
>
using
DropTypeListItem
=
typename
DropTypeListItemImpl
<
n
List
>
:
:
Type
;
template
<
size_t
n
typename
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
;
template
<
size_t
n
typename
T
typename
.
.
.
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
n
TypeList
<
T
List
.
.
.
>
Accum
.
.
.
>
:
TakeTypeListItemImpl
<
n
-
1
TypeList
<
List
.
.
.
>
Accum
.
.
.
T
>
{
}
;
template
<
typename
T
typename
.
.
.
List
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
0
TypeList
<
T
List
.
.
.
>
Accum
.
.
.
>
{
using
Type
=
TypeList
<
Accum
.
.
.
>
;
}
;
template
<
typename
.
.
.
Accum
>
struct
TakeTypeListItemImpl
<
0
TypeList
<
>
Accum
.
.
.
>
{
using
Type
=
TypeList
<
Accum
.
.
.
>
;
}
;
template
<
size_t
n
typename
List
>
using
TakeTypeListItem
=
typename
TakeTypeListItemImpl
<
n
List
>
:
:
Type
;
template
<
typename
List1
typename
List2
>
struct
ConcatTypeListsImpl
;
template
<
typename
.
.
.
Types1
typename
.
.
.
Types2
>
struct
ConcatTypeListsImpl
<
TypeList
<
Types1
.
.
.
>
TypeList
<
Types2
.
.
.
>
>
{
using
Type
=
TypeList
<
Types1
.
.
.
Types2
.
.
.
>
;
}
;
template
<
typename
List1
typename
List2
>
using
ConcatTypeLists
=
typename
ConcatTypeListsImpl
<
List1
List2
>
:
:
Type
;
template
<
typename
R
typename
ArgList
>
struct
MakeFunctionTypeImpl
;
template
<
typename
R
typename
.
.
.
Args
>
struct
MakeFunctionTypeImpl
<
R
TypeList
<
Args
.
.
.
>
>
{
typedef
R
Type
(
Args
.
.
.
)
;
}
;
template
<
typename
R
typename
ArgList
>
using
MakeFunctionType
=
typename
MakeFunctionTypeImpl
<
R
ArgList
>
:
:
Type
;
template
<
typename
Signature
>
struct
ExtractArgsImpl
;
template
<
typename
R
typename
.
.
.
Args
>
struct
ExtractArgsImpl
<
R
(
Args
.
.
.
)
>
{
using
ReturnType
=
R
;
using
ArgsList
=
TypeList
<
Args
.
.
.
>
;
}
;
template
<
typename
Signature
>
using
ExtractArgs
=
typename
ExtractArgsImpl
<
Signature
>
:
:
ArgsList
;
template
<
typename
Signature
>
using
ExtractReturnType
=
typename
ExtractArgsImpl
<
Signature
>
:
:
ReturnType
;
template
<
typename
Callable
typename
Signature
=
decltype
(
&
Callable
:
:
operator
(
)
)
>
struct
ExtractCallableRunTypeImpl
;
template
<
typename
Callable
typename
R
typename
.
.
.
Args
>
struct
ExtractCallableRunTypeImpl
<
Callable
R
(
Callable
:
:
*
)
(
Args
.
.
.
)
>
{
using
Type
=
R
(
Args
.
.
.
)
;
}
;
template
<
typename
Callable
typename
R
typename
.
.
.
Args
>
struct
ExtractCallableRunTypeImpl
<
Callable
R
(
Callable
:
:
*
)
(
Args
.
.
.
)
const
>
{
using
Type
=
R
(
Args
.
.
.
)
;
}
;
template
<
typename
Callable
typename
R
typename
.
.
.
Args
>
struct
ExtractCallableRunTypeImpl
<
Callable
R
(
Callable
:
:
*
)
(
Args
.
.
.
)
noexcept
>
{
using
Type
=
R
(
Args
.
.
.
)
;
}
;
template
<
typename
Callable
typename
R
typename
.
.
.
Args
>
struct
ExtractCallableRunTypeImpl
<
Callable
R
(
Callable
:
:
*
)
(
Args
.
.
.
)
const
noexcept
>
{
using
Type
=
R
(
Args
.
.
.
)
;
}
;
template
<
typename
Callable
>
using
ExtractCallableRunType
=
typename
ExtractCallableRunTypeImpl
<
Callable
>
:
:
Type
;
template
<
typename
Functor
typename
SFINAE
=
void
>
struct
IsCallableObject
:
std
:
:
false_type
{
}
;
template
<
typename
Callable
>
struct
IsCallableObject
<
Callable
std
:
:
void_t
<
decltype
(
&
Callable
:
:
operator
(
)
)
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
.
.
.
Ts
>
struct
HasRefCountedTypeAsRawPtr
:
std
:
:
disjunction
<
NeedsScopedRefptrButGetsRawPtr
<
Ts
>
.
.
.
>
{
}
;
template
<
typename
Sig
>
struct
ForceVoidReturn
;
template
<
typename
R
typename
.
.
.
Args
>
struct
ForceVoidReturn
<
R
(
Args
.
.
.
)
>
{
using
RunType
=
void
(
Args
.
.
.
)
;
}
;
template
<
typename
Functor
typename
SFINAE
>
struct
FunctorTraits
;
template
<
typename
Functor
>
struct
FunctorTraits
<
Functor
std
:
:
enable_if_t
<
IsCallableObject
<
Functor
>
:
:
value
>
>
{
using
RunType
=
ExtractCallableRunType
<
Functor
>
;
static
constexpr
bool
is_method
=
false
;
static
constexpr
bool
is_nullable
=
false
;
static
constexpr
bool
is_callback
=
false
;
static
constexpr
bool
is_stateless
=
std
:
:
is_empty_v
<
Functor
>
;
template
<
typename
RunFunctor
typename
.
.
.
RunArgs
>
static
ExtractReturnType
<
RunType
>
Invoke
(
RunFunctor
&
&
functor
RunArgs
&
&
.
.
.
args
)
{
return
std
:
:
forward
<
RunFunctor
>
(
functor
)
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
*
)
(
Args
.
.
.
)
>
{
using
RunType
=
R
(
Args
.
.
.
)
;
static
constexpr
bool
is_method
=
false
;
static
constexpr
bool
is_nullable
=
true
;
static
constexpr
bool
is_callback
=
false
;
static
constexpr
bool
is_stateless
=
true
;
template
<
typename
Function
typename
.
.
.
RunArgs
>
static
R
Invoke
(
Function
&
&
function
RunArgs
&
&
.
.
.
args
)
{
return
std
:
:
forward
<
Function
>
(
function
)
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
#
if
BUILDFLAG
(
IS_WIN
)
&
&
!
defined
(
ARCH_CPU_64_BITS
)
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
__stdcall
*
)
(
Args
.
.
.
)
>
{
using
RunType
=
R
(
Args
.
.
.
)
;
static
constexpr
bool
is_method
=
false
;
static
constexpr
bool
is_nullable
=
true
;
static
constexpr
bool
is_callback
=
false
;
static
constexpr
bool
is_stateless
=
true
;
template
<
typename
.
.
.
RunArgs
>
static
R
Invoke
(
R
(
__stdcall
*
function
)
(
Args
.
.
.
)
RunArgs
&
&
.
.
.
args
)
{
return
function
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
__fastcall
*
)
(
Args
.
.
.
)
>
{
using
RunType
=
R
(
Args
.
.
.
)
;
static
constexpr
bool
is_method
=
false
;
static
constexpr
bool
is_nullable
=
true
;
static
constexpr
bool
is_callback
=
false
;
static
constexpr
bool
is_stateless
=
true
;
template
<
typename
.
.
.
RunArgs
>
static
R
Invoke
(
R
(
__fastcall
*
function
)
(
Args
.
.
.
)
RunArgs
&
&
.
.
.
args
)
{
return
function
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
#
endif
#
if
__OBJC__
#
if
HAS_FEATURE
(
objc_arc
)
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
^
)
(
Args
.
.
.
)
>
{
using
RunType
=
R
(
Args
.
.
.
)
;
static
constexpr
bool
is_method
=
false
;
static
constexpr
bool
is_nullable
=
true
;
static
constexpr
bool
is_callback
=
false
;
static
constexpr
bool
is_stateless
=
true
;
template
<
typename
BlockType
typename
.
.
.
RunArgs
>
static
R
Invoke
(
BlockType
&
&
block
RunArgs
&
&
.
.
.
args
)
{
__attribute__
(
(
objc_precise_lifetime
)
)
R
(
^
scoped_block
)
(
Args
.
.
.
)
=
block
;
return
scoped_block
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
#
endif
#
endif
template
<
typename
R
typename
Receiver
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
Receiver
:
:
*
)
(
Args
.
.
.
)
>
{
using
RunType
=
R
(
Receiver
*
Args
.
.
.
)
;
static
constexpr
bool
is_method
=
true
;
static
constexpr
bool
is_nullable
=
true
;
static
constexpr
bool
is_callback
=
false
;
static
constexpr
bool
is_stateless
=
true
;
template
<
typename
Method
typename
ReceiverPtr
typename
.
.
.
RunArgs
>
static
R
Invoke
(
Method
method
ReceiverPtr
&
&
receiver_ptr
RunArgs
&
&
.
.
.
args
)
{
return
(
(
*
receiver_ptr
)
.
*
method
)
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
R
typename
Receiver
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
Receiver
:
:
*
)
(
Args
.
.
.
)
const
>
{
using
RunType
=
R
(
const
Receiver
*
Args
.
.
.
)
;
static
constexpr
bool
is_method
=
true
;
static
constexpr
bool
is_nullable
=
true
;
static
constexpr
bool
is_callback
=
false
;
static
constexpr
bool
is_stateless
=
true
;
template
<
typename
Method
typename
ReceiverPtr
typename
.
.
.
RunArgs
>
static
R
Invoke
(
Method
method
ReceiverPtr
&
&
receiver_ptr
RunArgs
&
&
.
.
.
args
)
{
return
(
(
*
receiver_ptr
)
.
*
method
)
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
#
if
BUILDFLAG
(
IS_WIN
)
&
&
!
defined
(
ARCH_CPU_64_BITS
)
template
<
typename
R
typename
Receiver
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
__stdcall
Receiver
:
:
*
)
(
Args
.
.
.
)
>
:
public
FunctorTraits
<
R
(
Receiver
:
:
*
)
(
Args
.
.
.
)
>
{
}
;
template
<
typename
R
typename
Receiver
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
__stdcall
Receiver
:
:
*
)
(
Args
.
.
.
)
const
>
:
public
FunctorTraits
<
R
(
Receiver
:
:
*
)
(
Args
.
.
.
)
const
>
{
}
;
#
endif
#
ifdef
__cpp_noexcept_function_type
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
*
)
(
Args
.
.
.
)
noexcept
>
:
FunctorTraits
<
R
(
*
)
(
Args
.
.
.
)
>
{
}
;
template
<
typename
R
typename
Receiver
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
Receiver
:
:
*
)
(
Args
.
.
.
)
noexcept
>
:
FunctorTraits
<
R
(
Receiver
:
:
*
)
(
Args
.
.
.
)
>
{
}
;
template
<
typename
R
typename
Receiver
typename
.
.
.
Args
>
struct
FunctorTraits
<
R
(
Receiver
:
:
*
)
(
Args
.
.
.
)
const
noexcept
>
:
FunctorTraits
<
R
(
Receiver
:
:
*
)
(
Args
.
.
.
)
const
>
{
}
;
#
endif
template
<
typename
T
>
struct
FunctorTraits
<
IgnoreResultHelper
<
T
>
>
:
FunctorTraits
<
T
>
{
using
RunType
=
typename
ForceVoidReturn
<
typename
FunctorTraits
<
T
>
:
:
RunType
>
:
:
RunType
;
template
<
typename
IgnoreResultType
typename
.
.
.
RunArgs
>
static
void
Invoke
(
IgnoreResultType
&
&
ignore_result_helper
RunArgs
&
&
.
.
.
args
)
{
FunctorTraits
<
T
>
:
:
Invoke
(
std
:
:
forward
<
IgnoreResultType
>
(
ignore_result_helper
)
.
functor_
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctorTraits
<
OnceCallback
<
R
(
Args
.
.
.
)
>
>
{
using
RunType
=
R
(
Args
.
.
.
)
;
static
constexpr
bool
is_method
=
false
;
static
constexpr
bool
is_nullable
=
true
;
static
constexpr
bool
is_callback
=
true
;
static
constexpr
bool
is_stateless
=
true
;
template
<
typename
CallbackType
typename
.
.
.
RunArgs
>
static
R
Invoke
(
CallbackType
&
&
callback
RunArgs
&
&
.
.
.
args
)
{
DCHECK
(
!
callback
.
is_null
(
)
)
;
return
std
:
:
forward
<
CallbackType
>
(
callback
)
.
Run
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
FunctorTraits
<
RepeatingCallback
<
R
(
Args
.
.
.
)
>
>
{
using
RunType
=
R
(
Args
.
.
.
)
;
static
constexpr
bool
is_method
=
false
;
static
constexpr
bool
is_nullable
=
true
;
static
constexpr
bool
is_callback
=
true
;
static
constexpr
bool
is_stateless
=
true
;
template
<
typename
CallbackType
typename
.
.
.
RunArgs
>
static
R
Invoke
(
CallbackType
&
&
callback
RunArgs
&
&
.
.
.
args
)
{
DCHECK
(
!
callback
.
is_null
(
)
)
;
return
std
:
:
forward
<
CallbackType
>
(
callback
)
.
Run
(
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
Functor
>
using
MakeFunctorTraits
=
FunctorTraits
<
std
:
:
decay_t
<
Functor
>
>
;
template
<
typename
T
>
struct
StorageTraits
{
using
Type
=
T
;
}
;
template
<
typename
T
>
struct
StorageTraits
<
T
*
>
{
using
Type
=
UnretainedWrapper
<
T
unretained_traits
:
:
MayNotDangle
>
;
}
;
template
<
typename
T
RawPtrTraits
PtrTraits
>
struct
StorageTraits
<
raw_ptr
<
T
PtrTraits
>
>
{
using
Type
=
UnretainedWrapper
<
T
unretained_traits
:
:
MayNotDangle
PtrTraits
>
;
}
;
template
<
typename
T
>
struct
StorageTraits
<
std
:
:
reference_wrapper
<
T
>
>
{
using
Type
=
UnretainedRefWrapper
<
T
unretained_traits
:
:
MayNotDangle
>
;
}
;
template
<
typename
T
>
using
MakeStorageType
=
typename
StorageTraits
<
std
:
:
decay_t
<
T
>
>
:
:
Type
;
template
<
bool
is_weak_call
typename
ReturnType
size_t
.
.
.
indices
>
struct
InvokeHelper
;
template
<
typename
ReturnType
size_t
.
.
.
indices
>
struct
InvokeHelper
<
false
ReturnType
indices
.
.
.
>
{
template
<
typename
Functor
typename
BoundArgsTuple
typename
.
.
.
RunArgs
>
static
inline
ReturnType
MakeItSo
(
Functor
&
&
functor
BoundArgsTuple
&
&
bound
RunArgs
&
&
.
.
.
args
)
{
using
Traits
=
MakeFunctorTraits
<
Functor
>
;
return
Traits
:
:
Invoke
(
std
:
:
forward
<
Functor
>
(
functor
)
Unwrap
(
std
:
:
get
<
indices
>
(
std
:
:
forward
<
BoundArgsTuple
>
(
bound
)
)
)
.
.
.
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
ReturnType
size_t
index_target
size_t
.
.
.
index_tail
>
struct
InvokeHelper
<
true
ReturnType
index_target
index_tail
.
.
.
>
{
static_assert
(
std
:
:
is_void_v
<
ReturnType
>
"
weak_ptrs
can
only
bind
to
methods
without
return
values
"
)
;
template
<
typename
Functor
typename
BoundArgsTuple
typename
.
.
.
RunArgs
>
static
inline
void
MakeItSo
(
Functor
&
&
functor
BoundArgsTuple
&
&
bound
RunArgs
&
&
.
.
.
args
)
{
static_assert
(
index_target
=
=
0
)
;
const
auto
&
target
=
Unwrap
(
std
:
:
get
<
0
>
(
bound
)
)
;
if
(
!
target
)
{
return
;
}
using
Traits
=
MakeFunctorTraits
<
Functor
>
;
Traits
:
:
Invoke
(
std
:
:
forward
<
Functor
>
(
functor
)
target
Unwrap
(
std
:
:
get
<
index_tail
>
(
std
:
:
forward
<
BoundArgsTuple
>
(
bound
)
)
)
.
.
.
std
:
:
forward
<
RunArgs
>
(
args
)
.
.
.
)
;
}
}
;
template
<
typename
StorageType
typename
UnboundRunType
>
struct
Invoker
;
template
<
typename
StorageType
typename
R
typename
.
.
.
UnboundArgs
>
struct
Invoker
<
StorageType
R
(
UnboundArgs
.
.
.
)
>
{
static
R
RunOnce
(
BindStateBase
*
base
PassingType
<
UnboundArgs
>
.
.
.
unbound_args
)
{
StorageType
*
storage
=
static_cast
<
StorageType
*
>
(
base
)
;
static
constexpr
size_t
num_bound_args
=
std
:
:
tuple_size_v
<
decltype
(
storage
-
>
bound_args_
)
>
;
return
RunImpl
(
std
:
:
move
(
storage
-
>
functor_
)
std
:
:
move
(
storage
-
>
bound_args_
)
std
:
:
make_index_sequence
<
num_bound_args
>
(
)
std
:
:
forward
<
UnboundArgs
>
(
unbound_args
)
.
.
.
)
;
}
static
R
Run
(
BindStateBase
*
base
PassingType
<
UnboundArgs
>
.
.
.
unbound_args
)
{
const
StorageType
*
storage
=
static_cast
<
StorageType
*
>
(
base
)
;
static
constexpr
size_t
num_bound_args
=
std
:
:
tuple_size_v
<
decltype
(
storage
-
>
bound_args_
)
>
;
return
RunImpl
(
storage
-
>
functor_
storage
-
>
bound_args_
std
:
:
make_index_sequence
<
num_bound_args
>
(
)
std
:
:
forward
<
UnboundArgs
>
(
unbound_args
)
.
.
.
)
;
}
private
:
template
<
typename
Functor
typename
BoundArgsTuple
size_t
.
.
.
indices
>
static
inline
R
RunImpl
(
Functor
&
&
functor
BoundArgsTuple
&
&
bound
std
:
:
index_sequence
<
indices
.
.
.
>
seq
UnboundArgs
&
&
.
.
.
unbound_args
)
{
static
constexpr
bool
is_method
=
MakeFunctorTraits
<
Functor
>
:
:
is_method
;
using
DecayedArgsTuple
=
std
:
:
decay_t
<
BoundArgsTuple
>
;
#
if
BUILDFLAG
(
USE_ASAN_BACKUP_REF_PTR
)
RawPtrAsanBoundArgTracker
raw_ptr_asan_bound_arg_tracker
;
raw_ptr_asan_bound_arg_tracker
.
AddArgs
(
std
:
:
get
<
indices
>
(
std
:
:
forward
<
BoundArgsTuple
>
(
bound
)
)
.
.
.
std
:
:
forward
<
UnboundArgs
>
(
unbound_args
)
.
.
.
)
;
#
endif
static
constexpr
bool
is_weak_call
=
IsWeakMethod
<
is_method
std
:
:
tuple_element_t
<
indices
DecayedArgsTuple
>
.
.
.
>
(
)
;
return
InvokeHelper
<
is_weak_call
R
indices
.
.
.
>
:
:
MakeItSo
(
std
:
:
forward
<
Functor
>
(
functor
)
std
:
:
forward
<
BoundArgsTuple
>
(
bound
)
std
:
:
forward
<
UnboundArgs
>
(
unbound_args
)
.
.
.
)
;
}
}
;
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
struct
BindTypeHelper
{
static
constexpr
size_t
num_bounds
=
sizeof
.
.
.
(
BoundArgs
)
;
using
FunctorTraits
=
MakeFunctorTraits
<
Functor
>
;
using
RunType
=
typename
FunctorTraits
:
:
RunType
;
using
ReturnType
=
ExtractReturnType
<
RunType
>
;
using
RunParamsList
=
ExtractArgs
<
RunType
>
;
using
BoundParamsList
=
TakeTypeListItem
<
num_bounds
RunParamsList
>
;
using
UnboundParamsList
=
DropTypeListItem
<
num_bounds
RunParamsList
>
;
using
BoundArgsList
=
TypeList
<
BoundArgs
.
.
.
>
;
using
UnboundRunType
=
MakeFunctionType
<
ReturnType
UnboundParamsList
>
;
}
;
template
<
typename
Functor
>
std
:
:
enable_if_t
<
FunctorTraits
<
Functor
>
:
:
is_nullable
bool
>
IsNull
(
const
Functor
&
functor
)
{
return
!
functor
;
}
template
<
typename
Functor
>
std
:
:
enable_if_t
<
!
FunctorTraits
<
Functor
>
:
:
is_nullable
bool
>
IsNull
(
const
Functor
&
)
{
return
false
;
}
template
<
typename
Functor
typename
BoundArgsTuple
size_t
.
.
.
indices
>
bool
QueryCancellationTraitsImpl
(
BindStateBase
:
:
CancellationQueryMode
mode
const
Functor
&
functor
const
BoundArgsTuple
&
bound_args
std
:
:
index_sequence
<
indices
.
.
.
>
)
{
switch
(
mode
)
{
case
BindStateBase
:
:
IS_CANCELLED
:
return
CallbackCancellationTraits
<
Functor
BoundArgsTuple
>
:
:
IsCancelled
(
functor
std
:
:
get
<
indices
>
(
bound_args
)
.
.
.
)
;
case
BindStateBase
:
:
MAYBE_VALID
:
return
CallbackCancellationTraits
<
Functor
BoundArgsTuple
>
:
:
MaybeValid
(
functor
std
:
:
get
<
indices
>
(
bound_args
)
.
.
.
)
;
}
NOTREACHED
(
)
;
return
false
;
}
template
<
typename
BindStateType
>
bool
QueryCancellationTraits
(
const
BindStateBase
*
base
BindStateBase
:
:
CancellationQueryMode
mode
)
{
const
BindStateType
*
storage
=
static_cast
<
const
BindStateType
*
>
(
base
)
;
static
constexpr
size_t
num_bound_args
=
std
:
:
tuple_size_v
<
decltype
(
storage
-
>
bound_args_
)
>
;
return
QueryCancellationTraitsImpl
(
mode
storage
-
>
functor_
storage
-
>
bound_args_
std
:
:
make_index_sequence
<
num_bound_args
>
(
)
)
;
}
template
<
typename
Functor
typename
Receiver
typename
.
.
.
Unused
>
std
:
:
enable_if_t
<
!
(
MakeFunctorTraits
<
Functor
>
:
:
is_method
&
&
IsPointerV
<
std
:
:
decay_t
<
Receiver
>
>
&
&
IsRefCountedType
<
RemovePointerT
<
std
:
:
decay_t
<
Receiver
>
>
>
:
:
value
)
>
BanUnconstructedRefCountedReceiver
(
const
Receiver
&
receiver
Unused
&
&
.
.
.
)
{
}
template
<
typename
Functor
>
void
BanUnconstructedRefCountedReceiver
(
)
{
}
template
<
typename
Functor
typename
Receiver
typename
.
.
.
Unused
>
std
:
:
enable_if_t
<
MakeFunctorTraits
<
Functor
>
:
:
is_method
&
&
IsPointerV
<
std
:
:
decay_t
<
Receiver
>
>
&
&
IsRefCountedType
<
RemovePointerT
<
std
:
:
decay_t
<
Receiver
>
>
>
:
:
value
>
BanUnconstructedRefCountedReceiver
(
const
Receiver
&
receiver
Unused
&
&
.
.
.
)
{
DCHECK
(
receiver
)
;
DCHECK
(
receiver
-
>
HasAtLeastOneRef
(
)
)
;
}
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
struct
BindState
final
:
BindStateBase
{
using
IsCancellable
=
std
:
:
bool_constant
<
CallbackCancellationTraits
<
Functor
std
:
:
tuple
<
BoundArgs
.
.
.
>
>
:
:
is_cancellable
>
;
template
<
typename
ForwardFunctor
typename
.
.
.
ForwardBoundArgs
>
static
BindState
*
Create
(
BindStateBase
:
:
InvokeFuncStorage
invoke_func
ForwardFunctor
&
&
functor
ForwardBoundArgs
&
&
.
.
.
bound_args
)
{
BanUnconstructedRefCountedReceiver
<
ForwardFunctor
>
(
bound_args
.
.
.
)
;
return
new
BindState
(
IsCancellable
{
}
invoke_func
std
:
:
forward
<
ForwardFunctor
>
(
functor
)
std
:
:
forward
<
ForwardBoundArgs
>
(
bound_args
)
.
.
.
)
;
}
Functor
functor_
;
std
:
:
tuple
<
BoundArgs
.
.
.
>
bound_args_
;
private
:
static
constexpr
bool
is_nested_callback
=
MakeFunctorTraits
<
Functor
>
:
:
is_callback
;
template
<
typename
ForwardFunctor
typename
.
.
.
ForwardBoundArgs
>
explicit
BindState
(
std
:
:
true_type
BindStateBase
:
:
InvokeFuncStorage
invoke_func
ForwardFunctor
&
&
functor
ForwardBoundArgs
&
&
.
.
.
bound_args
)
:
BindStateBase
(
invoke_func
&
Destroy
&
QueryCancellationTraits
<
BindState
>
)
functor_
(
std
:
:
forward
<
ForwardFunctor
>
(
functor
)
)
bound_args_
(
std
:
:
forward
<
ForwardBoundArgs
>
(
bound_args
)
.
.
.
)
{
if
(
is_nested_callback
)
{
CHECK
(
!
IsNull
(
functor_
)
)
;
}
else
{
DCHECK
(
!
IsNull
(
functor_
)
)
;
}
}
template
<
typename
ForwardFunctor
typename
.
.
.
ForwardBoundArgs
>
explicit
BindState
(
std
:
:
false_type
BindStateBase
:
:
InvokeFuncStorage
invoke_func
ForwardFunctor
&
&
functor
ForwardBoundArgs
&
&
.
.
.
bound_args
)
:
BindStateBase
(
invoke_func
&
Destroy
)
functor_
(
std
:
:
forward
<
ForwardFunctor
>
(
functor
)
)
bound_args_
(
std
:
:
forward
<
ForwardBoundArgs
>
(
bound_args
)
.
.
.
)
{
if
(
is_nested_callback
)
{
CHECK
(
!
IsNull
(
functor_
)
)
;
}
else
{
DCHECK
(
!
IsNull
(
functor_
)
)
;
}
}
~
BindState
(
)
=
default
;
static
void
Destroy
(
const
BindStateBase
*
self
)
{
delete
static_cast
<
const
BindState
*
>
(
self
)
;
}
}
;
template
<
bool
is_method
typename
Functor
typename
.
.
.
BoundArgs
>
struct
MakeBindStateTypeImpl
;
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
struct
MakeBindStateTypeImpl
<
false
Functor
BoundArgs
.
.
.
>
{
static_assert
(
!
HasRefCountedTypeAsRawPtr
<
std
:
:
decay_t
<
BoundArgs
>
.
.
.
>
:
:
value
"
A
parameter
is
a
refcounted
type
and
needs
scoped_refptr
.
"
)
;
using
Type
=
BindState
<
std
:
:
decay_t
<
Functor
>
MakeStorageType
<
BoundArgs
>
.
.
.
>
;
}
;
template
<
typename
Functor
>
struct
MakeBindStateTypeImpl
<
true
Functor
>
{
using
Type
=
BindState
<
std
:
:
decay_t
<
Functor
>
>
;
}
;
template
<
typename
Functor
typename
Receiver
typename
.
.
.
BoundArgs
>
struct
MakeBindStateTypeImpl
<
true
Functor
Receiver
BoundArgs
.
.
.
>
{
private
:
using
DecayedReceiver
=
std
:
:
decay_t
<
Receiver
>
;
static_assert
(
!
std
:
:
is_array_v
<
std
:
:
remove_reference_t
<
Receiver
>
>
"
First
bound
argument
to
a
method
cannot
be
an
array
.
"
)
;
static_assert
(
!
IsRawRefV
<
DecayedReceiver
>
"
Receivers
may
not
be
raw_ref
<
T
>
.
If
using
a
raw_ref
<
T
>
here
is
safe
"
"
and
has
no
lifetime
concerns
use
base
:
:
Unretained
(
)
and
document
why
"
"
it
'
s
safe
.
"
)
;
static_assert
(
!
IsPointerV
<
DecayedReceiver
>
|
|
IsRefCountedType
<
RemovePointerT
<
DecayedReceiver
>
>
:
:
value
"
Receivers
may
not
be
raw
pointers
.
If
using
a
raw
pointer
here
is
safe
"
"
and
has
no
lifetime
concerns
use
base
:
:
Unretained
(
)
and
document
why
"
"
it
'
s
safe
.
"
)
;
static_assert
(
!
HasRefCountedTypeAsRawPtr
<
std
:
:
decay_t
<
BoundArgs
>
.
.
.
>
:
:
value
"
A
parameter
is
a
refcounted
type
and
needs
scoped_refptr
.
"
)
;
using
ReceiverStorageType
=
typename
MethodReceiverStorageType
<
DecayedReceiver
>
:
:
Type
;
public
:
using
Type
=
BindState
<
std
:
:
decay_t
<
Functor
>
ReceiverStorageType
MakeStorageType
<
BoundArgs
>
.
.
.
>
;
}
;
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
using
MakeBindStateType
=
typename
MakeBindStateTypeImpl
<
MakeFunctorTraits
<
Functor
>
:
:
is_method
Functor
BoundArgs
.
.
.
>
:
:
Type
;
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
using
MakeUnboundRunType
=
typename
BindTypeHelper
<
Functor
BoundArgs
.
.
.
>
:
:
UnboundRunType
;
template
<
bool
is_once
typename
T
>
struct
TransformToUnwrappedTypeImpl
;
template
<
typename
T
>
struct
TransformToUnwrappedTypeImpl
<
true
T
>
{
using
StoredType
=
std
:
:
decay_t
<
T
>
;
using
ForwardType
=
StoredType
&
&
;
using
Unwrapped
=
decltype
(
Unwrap
(
std
:
:
declval
<
ForwardType
>
(
)
)
)
;
}
;
template
<
typename
T
>
struct
TransformToUnwrappedTypeImpl
<
false
T
>
{
using
StoredType
=
std
:
:
decay_t
<
T
>
;
using
ForwardType
=
const
StoredType
&
;
using
Unwrapped
=
decltype
(
Unwrap
(
std
:
:
declval
<
ForwardType
>
(
)
)
)
;
}
;
template
<
bool
is_once
typename
T
>
using
TransformToUnwrappedType
=
typename
TransformToUnwrappedTypeImpl
<
is_once
T
>
:
:
Unwrapped
;
template
<
bool
is_once
bool
is_method
typename
.
.
.
Args
>
struct
MakeUnwrappedTypeListImpl
{
using
Type
=
TypeList
<
TransformToUnwrappedType
<
is_once
Args
>
.
.
.
>
;
}
;
template
<
bool
is_once
typename
Receiver
typename
.
.
.
Args
>
struct
MakeUnwrappedTypeListImpl
<
is_once
true
Receiver
Args
.
.
.
>
{
using
ReceiverStorageType
=
typename
MethodReceiverStorageType
<
std
:
:
decay_t
<
Receiver
>
>
:
:
Type
;
using
UnwrappedReceiver
=
TransformToUnwrappedType
<
is_once
ReceiverStorageType
>
;
using
Type
=
TypeList
<
decltype
(
&
*
std
:
:
declval
<
UnwrappedReceiver
>
(
)
)
TransformToUnwrappedType
<
is_once
Args
>
.
.
.
>
;
}
;
template
<
bool
is_once
bool
is_method
typename
.
.
.
Args
>
using
MakeUnwrappedTypeList
=
typename
MakeUnwrappedTypeListImpl
<
is_once
is_method
Args
.
.
.
>
:
:
Type
;
template
<
typename
T
>
struct
IsOnceCallback
:
std
:
:
false_type
{
}
;
template
<
typename
Signature
>
struct
IsOnceCallback
<
OnceCallback
<
Signature
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
StorageType
>
inline
constexpr
bool
IsUnretainedMayDangle
=
false
;
template
<
typename
T
RawPtrTraits
PtrTraits
>
inline
constexpr
bool
IsUnretainedMayDangle
<
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangle
PtrTraits
>
>
=
true
;
template
<
typename
StorageType
typename
FunctionParamType
>
inline
constexpr
bool
UnretainedAndRawPtrHaveCompatibleTraits
=
false
;
template
<
typename
T
RawPtrTraits
PtrTraitsInUnretained
RawPtrTraits
PtrTraitsInReceiver
>
inline
constexpr
bool
UnretainedAndRawPtrHaveCompatibleTraits
<
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangle
PtrTraitsInUnretained
>
raw_ptr
<
T
PtrTraitsInReceiver
>
>
=
std
:
:
is_same_v
<
typename
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangle
PtrTraitsInUnretained
>
:
:
GetPtrType
raw_ptr
<
T
PtrTraitsInReceiver
>
>
;
template
<
int
i
>
struct
BindArgument
{
template
<
typename
ForwardingType
>
struct
ForwardedAs
{
template
<
typename
FunctorParamType
>
struct
ToParamWithType
{
static
constexpr
bool
kNotARawPtr
=
!
IsRawPtrV
<
FunctorParamType
>
;
static
constexpr
bool
kCanBeForwardedToBoundFunctor
=
std
:
:
is_convertible_v
<
ForwardingType
FunctorParamType
>
;
static
constexpr
bool
kNonConstRefParamMustBeWrapped
=
kCanBeForwardedToBoundFunctor
|
|
!
(
std
:
:
is_lvalue_reference_v
<
FunctorParamType
>
&
&
!
std
:
:
is_const_v
<
std
:
:
remove_reference_t
<
FunctorParamType
>
>
&
&
std
:
:
is_convertible_v
<
std
:
:
decay_t
<
ForwardingType
>
&
FunctorParamType
>
)
;
static
constexpr
bool
kMoveOnlyTypeMustUseBasePassed
=
kCanBeForwardedToBoundFunctor
|
|
!
std
:
:
is_convertible_v
<
std
:
:
decay_t
<
ForwardingType
>
&
&
FunctorParamType
>
;
}
;
}
;
template
<
typename
BoundAsType
>
struct
BoundAs
{
template
<
typename
StorageType
>
struct
StoredAs
{
static
constexpr
bool
kBindArgumentCanBeCaptured
=
std
:
:
is_constructible_v
<
StorageType
BoundAsType
>
;
static
constexpr
bool
kMoveOnlyTypeMustUseStdMove
=
kBindArgumentCanBeCaptured
|
|
!
std
:
:
is_constructible_v
<
StorageType
std
:
:
decay_t
<
BoundAsType
>
&
&
>
;
}
;
}
;
template
<
typename
FunctionParamType
>
struct
ToParamWithType
{
template
<
typename
StorageType
>
struct
StoredAs
{
template
<
bool
is_method
>
static
constexpr
bool
kParamIsThisPointer
=
is_method
&
&
i
=
=
0
;
static
constexpr
bool
kParamIsDanglingRawPtr
=
IsRawPtrMayDangleV
<
FunctionParamType
>
;
static
constexpr
bool
kBoundPtrMayDangle
=
IsUnretainedMayDangle
<
StorageType
>
;
static
constexpr
bool
kMayBeDanglingTraitsCorrectness
=
UnretainedAndRawPtrHaveCompatibleTraits
<
StorageType
FunctionParamType
>
;
static
constexpr
bool
kMayBeDanglingMustBeUsed
=
kBoundPtrMayDangle
&
&
kParamIsDanglingRawPtr
;
template
<
bool
is_method
>
static
constexpr
bool
kMayBeDanglingPtrPassedCorrectly
=
kParamIsThisPointer
<
is_method
>
|
|
kBoundPtrMayDangle
=
=
kParamIsDanglingRawPtr
;
static
constexpr
bool
kUnsafeDanglingAndMayBeDanglingHaveMatchingTraits
=
!
kMayBeDanglingMustBeUsed
|
|
kMayBeDanglingTraitsCorrectness
;
}
;
}
;
}
;
template
<
int
i
bool
is_method
typename
Arg
typename
Storage
typename
Unwrapped
typename
Param
>
struct
AssertConstructible
{
private
:
static_assert
(
BindArgument
<
i
>
:
:
template
ForwardedAs
<
Unwrapped
>
:
:
template
ToParamWithType
<
Param
>
:
:
kNotARawPtr
|
|
BindArgument
<
i
>
:
:
template
ToParamWithType
<
Param
>
:
:
template
StoredAs
<
Storage
>
:
:
kMayBeDanglingMustBeUsed
"
base
:
:
Bind
(
)
target
functor
has
a
parameter
of
type
raw_ptr
<
T
>
.
"
"
raw_ptr
<
T
>
should
not
be
used
for
function
parameters
please
use
T
*
or
"
"
T
&
instead
.
"
)
;
static_assert
(
BindArgument
<
i
>
:
:
template
ToParamWithType
<
Param
>
:
:
template
StoredAs
<
Storage
>
:
:
template
kMayBeDanglingPtrPassedCorrectly
<
is_method
>
"
base
:
:
UnsafeDangling
(
)
pointers
must
be
received
by
functors
with
"
"
MayBeDangling
<
T
>
as
parameter
.
"
)
;
static_assert
(
BindArgument
<
i
>
:
:
template
ToParamWithType
<
Param
>
:
:
template
StoredAs
<
Storage
>
:
:
kUnsafeDanglingAndMayBeDanglingHaveMatchingTraits
"
MayBeDangling
<
T
>
parameter
must
receive
the
same
RawPtrTraits
as
the
"
"
one
passed
to
the
corresponding
base
:
:
UnsafeDangling
(
)
call
.
"
)
;
static_assert
(
BindArgument
<
i
>
:
:
template
ForwardedAs
<
Unwrapped
>
:
:
template
ToParamWithType
<
Param
>
:
:
kMoveOnlyTypeMustUseBasePassed
"
base
:
:
BindRepeating
(
)
argument
is
a
move
-
only
type
.
Use
base
:
:
Passed
(
)
"
"
instead
of
std
:
:
move
(
)
to
transfer
ownership
from
the
callback
to
the
"
"
bound
functor
.
"
)
;
static_assert
(
BindArgument
<
i
>
:
:
template
ForwardedAs
<
Unwrapped
>
:
:
template
ToParamWithType
<
Param
>
:
:
kNonConstRefParamMustBeWrapped
"
Bound
argument
for
non
-
const
reference
parameter
must
be
wrapped
in
"
"
std
:
:
ref
(
)
or
base
:
:
OwnedRef
(
)
.
"
)
;
static_assert
(
BindArgument
<
i
>
:
:
template
ForwardedAs
<
Unwrapped
>
:
:
template
ToParamWithType
<
Param
>
:
:
kCanBeForwardedToBoundFunctor
"
Type
mismatch
between
bound
argument
and
bound
functor
'
s
parameter
.
"
)
;
static_assert
(
BindArgument
<
i
>
:
:
template
BoundAs
<
Arg
>
:
:
template
StoredAs
<
Storage
>
:
:
kMoveOnlyTypeMustUseStdMove
"
Attempting
to
bind
a
move
-
only
type
.
Use
std
:
:
move
(
)
to
"
"
transfer
ownership
to
the
created
callback
.
"
)
;
static_assert
(
BindArgument
<
i
>
:
:
template
BoundAs
<
Arg
>
:
:
template
StoredAs
<
Storage
>
:
:
kBindArgumentCanBeCaptured
"
Cannot
capture
argument
:
is
the
argument
copyable
or
movable
?
"
)
;
}
;
template
<
bool
is_method
typename
Index
typename
Args
typename
UnwrappedTypeList
typename
ParamsList
>
struct
AssertBindArgsValidity
;
template
<
bool
is_method
size_t
.
.
.
Ns
typename
.
.
.
Args
typename
.
.
.
Unwrapped
typename
.
.
.
Params
>
struct
AssertBindArgsValidity
<
is_method
std
:
:
index_sequence
<
Ns
.
.
.
>
TypeList
<
Args
.
.
.
>
TypeList
<
Unwrapped
.
.
.
>
TypeList
<
Params
.
.
.
>
>
:
AssertConstructible
<
Ns
is_method
Args
std
:
:
decay_t
<
Args
>
Unwrapped
Params
>
.
.
.
{
static
constexpr
bool
ok
=
true
;
}
;
template
<
typename
T
>
struct
AssertBindArgIsNotBasePassed
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
AssertBindArgIsNotBasePassed
<
PassedWrapper
<
T
>
>
:
public
std
:
:
false_type
{
}
;
template
<
template
<
typename
>
class
CallbackT
typename
Functor
typename
.
.
.
Args
>
decltype
(
auto
)
BindImpl
(
Functor
&
&
functor
Args
&
&
.
.
.
args
)
{
static
constexpr
bool
kIsOnce
=
IsOnceCallback
<
CallbackT
<
void
(
)
>
>
:
:
value
;
using
Helper
=
BindTypeHelper
<
Functor
Args
.
.
.
>
;
using
FunctorTraits
=
typename
Helper
:
:
FunctorTraits
;
using
BoundArgsList
=
typename
Helper
:
:
BoundArgsList
;
using
UnwrappedArgsList
=
MakeUnwrappedTypeList
<
kIsOnce
FunctorTraits
:
:
is_method
Args
&
&
.
.
.
>
;
using
BoundParamsList
=
typename
Helper
:
:
BoundParamsList
;
static_assert
(
MakeFunctorTraits
<
Functor
>
:
:
is_stateless
"
Capturing
lambdas
and
stateful
lambdas
are
intentionally
not
supported
.
"
"
Please
use
base
:
:
Bind
{
Once
Repeating
}
directly
to
bind
arguments
.
"
)
;
static_assert
(
AssertBindArgsValidity
<
FunctorTraits
:
:
is_method
std
:
:
make_index_sequence
<
Helper
:
:
num_bounds
>
BoundArgsList
UnwrappedArgsList
BoundParamsList
>
:
:
ok
"
The
bound
args
need
to
be
convertible
to
the
target
params
.
"
)
;
using
BindState
=
MakeBindStateType
<
Functor
Args
.
.
.
>
;
using
UnboundRunType
=
MakeUnboundRunType
<
Functor
Args
.
.
.
>
;
using
Invoker
=
Invoker
<
BindState
UnboundRunType
>
;
using
CallbackType
=
CallbackT
<
UnboundRunType
>
;
using
PolymorphicInvoke
=
typename
CallbackType
:
:
PolymorphicInvoke
;
PolymorphicInvoke
invoke_func
;
if
constexpr
(
kIsOnce
)
{
invoke_func
=
Invoker
:
:
RunOnce
;
}
else
{
invoke_func
=
Invoker
:
:
Run
;
}
using
InvokeFuncStorage
=
BindStateBase
:
:
InvokeFuncStorage
;
return
CallbackType
(
BindState
:
:
Create
(
reinterpret_cast
<
InvokeFuncStorage
>
(
invoke_func
)
std
:
:
forward
<
Functor
>
(
functor
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
template
<
typename
>
class
CallbackT
typename
Signature
std
:
:
enable_if_t
<
std
:
:
is_same_v
<
CallbackT
<
Signature
>
OnceCallback
<
Signature
>
>
>
*
=
nullptr
>
OnceCallback
<
Signature
>
BindImpl
(
OnceCallback
<
Signature
>
callback
)
{
CHECK
(
callback
)
;
return
callback
;
}
template
<
template
<
typename
>
class
CallbackT
typename
Signature
std
:
:
enable_if_t
<
std
:
:
is_same_v
<
CallbackT
<
Signature
>
OnceCallback
<
Signature
>
>
>
*
=
nullptr
>
OnceCallback
<
Signature
>
BindImpl
(
RepeatingCallback
<
Signature
>
callback
)
{
CHECK
(
callback
)
;
return
callback
;
}
template
<
template
<
typename
>
class
CallbackT
typename
Signature
std
:
:
enable_if_t
<
std
:
:
is_same_v
<
CallbackT
<
Signature
>
RepeatingCallback
<
Signature
>
>
>
*
=
nullptr
>
RepeatingCallback
<
Signature
>
BindImpl
(
RepeatingCallback
<
Signature
>
callback
)
{
CHECK
(
callback
)
;
return
callback
;
}
template
<
template
<
typename
>
class
CallbackT
typename
Signature
>
auto
BindImpl
(
absl
:
:
FunctionRef
<
Signature
>
.
.
.
)
{
static_assert
(
AlwaysFalse
<
Signature
>
"
base
:
:
Bind
{
Once
Repeating
}
require
strong
ownership
:
non
-
owning
"
"
function
references
may
not
bound
as
the
functor
due
to
potential
"
"
lifetime
issues
.
"
)
;
return
nullptr
;
}
template
<
template
<
typename
>
class
CallbackT
typename
Signature
>
auto
BindImpl
(
FunctionRef
<
Signature
>
.
.
.
)
{
static_assert
(
AlwaysFalse
<
Signature
>
"
base
:
:
Bind
{
Once
Repeating
}
require
strong
ownership
:
non
-
owning
"
"
function
references
may
not
bound
as
the
functor
due
to
potential
"
"
lifetime
issues
.
"
)
;
return
nullptr
;
}
}
template
<
typename
T
>
struct
IsWeakReceiver
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
IsWeakReceiver
<
std
:
:
reference_wrapper
<
T
>
>
:
IsWeakReceiver
<
T
>
{
}
;
template
<
typename
T
>
struct
IsWeakReceiver
<
WeakPtr
<
T
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
>
struct
MaybeValidTraits
{
template
<
typename
T
>
static
bool
MaybeValid
(
const
T
&
o
)
{
return
o
.
MaybeValid
(
)
;
}
}
;
template
<
typename
>
struct
BindUnwrapTraits
{
template
<
typename
T
>
static
T
&
&
Unwrap
(
T
&
&
o
)
{
return
std
:
:
forward
<
T
>
(
o
)
;
}
}
;
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
>
struct
BindUnwrapTraits
<
internal
:
:
UnretainedWrapper
<
T
UnretainedTrait
PtrTraits
>
>
{
static
auto
Unwrap
(
const
internal
:
:
UnretainedWrapper
<
T
UnretainedTrait
PtrTraits
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
typename
UnretainedTrait
RawPtrTraits
PtrTraits
>
struct
BindUnwrapTraits
<
internal
:
:
UnretainedRefWrapper
<
T
UnretainedTrait
PtrTraits
>
>
{
static
T
&
Unwrap
(
const
internal
:
:
UnretainedRefWrapper
<
T
UnretainedTrait
PtrTraits
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
BindUnwrapTraits
<
internal
:
:
RetainedRefWrapper
<
T
>
>
{
static
T
*
Unwrap
(
const
internal
:
:
RetainedRefWrapper
<
T
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
typename
Deleter
>
struct
BindUnwrapTraits
<
internal
:
:
OwnedWrapper
<
T
Deleter
>
>
{
static
T
*
Unwrap
(
const
internal
:
:
OwnedWrapper
<
T
Deleter
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
BindUnwrapTraits
<
internal
:
:
OwnedRefWrapper
<
T
>
>
{
static
T
&
Unwrap
(
const
internal
:
:
OwnedRefWrapper
<
T
>
&
o
)
{
return
o
.
get
(
)
;
}
}
;
template
<
typename
T
>
struct
BindUnwrapTraits
<
internal
:
:
PassedWrapper
<
T
>
>
{
static
T
Unwrap
(
const
internal
:
:
PassedWrapper
<
T
>
&
o
)
{
return
o
.
Take
(
)
;
}
}
;
#
if
BUILDFLAG
(
IS_WIN
)
template
<
typename
T
>
struct
BindUnwrapTraits
<
Microsoft
:
:
WRL
:
:
ComPtr
<
T
>
>
{
static
T
*
Unwrap
(
const
Microsoft
:
:
WRL
:
:
ComPtr
<
T
>
&
ptr
)
{
return
ptr
.
Get
(
)
;
}
}
;
#
endif
template
<
typename
Functor
typename
BoundArgsTuple
typename
SFINAE
>
struct
CallbackCancellationTraits
{
static
constexpr
bool
is_cancellable
=
false
;
}
;
template
<
typename
Functor
typename
.
.
.
BoundArgs
>
struct
CallbackCancellationTraits
<
Functor
std
:
:
tuple
<
BoundArgs
.
.
.
>
std
:
:
enable_if_t
<
internal
:
:
IsWeakMethod
<
internal
:
:
FunctorTraits
<
Functor
>
:
:
is_method
BoundArgs
.
.
.
>
:
:
value
>
>
{
static
constexpr
bool
is_cancellable
=
true
;
template
<
typename
Receiver
typename
.
.
.
Args
>
static
bool
IsCancelled
(
const
Functor
&
const
Receiver
&
receiver
const
Args
&
.
.
.
)
{
return
!
receiver
;
}
template
<
typename
Receiver
typename
.
.
.
Args
>
static
bool
MaybeValid
(
const
Functor
&
const
Receiver
&
receiver
const
Args
&
.
.
.
)
{
return
MaybeValidTraits
<
Receiver
>
:
:
MaybeValid
(
receiver
)
;
}
}
;
template
<
typename
Signature
typename
.
.
.
BoundArgs
>
struct
CallbackCancellationTraits
<
OnceCallback
<
Signature
>
std
:
:
tuple
<
BoundArgs
.
.
.
>
>
{
static
constexpr
bool
is_cancellable
=
true
;
template
<
typename
Functor
>
static
bool
IsCancelled
(
const
Functor
&
functor
const
BoundArgs
&
.
.
.
)
{
return
functor
.
IsCancelled
(
)
;
}
template
<
typename
Functor
>
static
bool
MaybeValid
(
const
Functor
&
functor
const
BoundArgs
&
.
.
.
)
{
return
MaybeValidTraits
<
Functor
>
:
:
MaybeValid
(
functor
)
;
}
}
;
template
<
typename
Signature
typename
.
.
.
BoundArgs
>
struct
CallbackCancellationTraits
<
RepeatingCallback
<
Signature
>
std
:
:
tuple
<
BoundArgs
.
.
.
>
>
{
static
constexpr
bool
is_cancellable
=
true
;
template
<
typename
Functor
>
static
bool
IsCancelled
(
const
Functor
&
functor
const
BoundArgs
&
.
.
.
)
{
return
functor
.
IsCancelled
(
)
;
}
template
<
typename
Functor
>
static
bool
MaybeValid
(
const
Functor
&
functor
const
BoundArgs
&
.
.
.
)
{
return
MaybeValidTraits
<
Functor
>
:
:
MaybeValid
(
functor
)
;
}
}
;
}
#
endif
