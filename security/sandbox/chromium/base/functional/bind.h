#
ifndef
BASE_FUNCTIONAL_BIND_H_
#
define
BASE_FUNCTIONAL_BIND_H_
#
include
<
functional
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
functional
/
bind_internal
.
h
"
#
include
"
base
/
memory
/
raw_ptr
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
template
<
typename
Functor
typename
.
.
.
Args
>
inline
OnceCallback
<
internal
:
:
MakeUnboundRunType
<
Functor
Args
.
.
.
>
>
BindOnce
(
Functor
&
&
functor
Args
&
&
.
.
.
args
)
{
static_assert
(
!
internal
:
:
IsOnceCallback
<
std
:
:
decay_t
<
Functor
>
>
(
)
|
|
(
std
:
:
is_rvalue_reference
<
Functor
&
&
>
(
)
&
&
!
std
:
:
is_const
<
std
:
:
remove_reference_t
<
Functor
>
>
(
)
)
"
BindOnce
requires
non
-
const
rvalue
for
OnceCallback
binding
.
"
"
I
.
e
.
:
base
:
:
BindOnce
(
std
:
:
move
(
callback
)
)
.
"
)
;
static_assert
(
std
:
:
conjunction_v
<
internal
:
:
AssertBindArgIsNotBasePassed
<
std
:
:
decay_t
<
Args
>
>
.
.
.
>
"
Use
std
:
:
move
(
)
instead
of
base
:
:
Passed
(
)
with
base
:
:
BindOnce
(
)
"
)
;
return
internal
:
:
BindImpl
<
OnceCallback
>
(
std
:
:
forward
<
Functor
>
(
functor
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
Functor
typename
.
.
.
Args
>
inline
RepeatingCallback
<
internal
:
:
MakeUnboundRunType
<
Functor
Args
.
.
.
>
>
BindRepeating
(
Functor
&
&
functor
Args
&
&
.
.
.
args
)
{
static_assert
(
!
internal
:
:
IsOnceCallback
<
std
:
:
decay_t
<
Functor
>
>
(
)
"
BindRepeating
cannot
bind
OnceCallback
.
Use
BindOnce
with
std
:
:
move
(
)
.
"
)
;
return
internal
:
:
BindImpl
<
RepeatingCallback
>
(
std
:
:
forward
<
Functor
>
(
functor
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
struct
BindFailedCheckPreviousErrors
{
}
;
BindFailedCheckPreviousErrors
BindOnce
(
.
.
.
)
;
BindFailedCheckPreviousErrors
BindRepeating
(
.
.
.
)
;
template
<
typename
T
>
inline
auto
Unretained
(
T
*
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayNotDangle
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
inline
auto
Unretained
(
const
raw_ptr
<
T
Traits
>
&
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayNotDangle
Traits
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
inline
auto
Unretained
(
raw_ptr
<
T
Traits
>
&
&
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayNotDangle
Traits
>
(
std
:
:
move
(
o
)
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
inline
auto
Unretained
(
const
raw_ref
<
T
Traits
>
&
o
)
{
return
internal
:
:
UnretainedRefWrapper
<
T
unretained_traits
:
:
MayNotDangle
Traits
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
inline
auto
Unretained
(
raw_ref
<
T
Traits
>
&
&
o
)
{
return
internal
:
:
UnretainedRefWrapper
<
T
unretained_traits
:
:
MayNotDangle
Traits
>
(
std
:
:
move
(
o
)
)
;
}
template
<
typename
T
>
inline
auto
UnsafeDangling
(
T
*
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangle
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
auto
UnsafeDangling
(
const
raw_ptr
<
T
Traits
>
&
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangle
Traits
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
auto
UnsafeDangling
(
raw_ptr
<
T
Traits
>
&
&
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangle
Traits
>
(
std
:
:
move
(
o
)
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
auto
UnsafeDangling
(
const
raw_ref
<
T
Traits
>
&
o
)
{
return
internal
:
:
UnretainedRefWrapper
<
T
unretained_traits
:
:
MayDangle
Traits
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
auto
UnsafeDangling
(
raw_ref
<
T
Traits
>
&
&
o
)
{
return
internal
:
:
UnretainedRefWrapper
<
T
unretained_traits
:
:
MayDangle
Traits
>
(
std
:
:
move
(
o
)
)
;
}
template
<
typename
T
>
inline
auto
UnsafeDanglingUntriaged
(
T
*
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangleUntriaged
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
auto
UnsafeDanglingUntriaged
(
const
raw_ptr
<
T
Traits
>
&
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangleUntriaged
Traits
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
auto
UnsafeDanglingUntriaged
(
raw_ptr
<
T
Traits
>
&
&
o
)
{
return
internal
:
:
UnretainedWrapper
<
T
unretained_traits
:
:
MayDangleUntriaged
Traits
>
(
std
:
:
move
(
o
)
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
auto
UnsafeDanglingUntriaged
(
const
raw_ref
<
T
Traits
>
&
o
)
{
return
internal
:
:
UnretainedRefWrapper
<
T
unretained_traits
:
:
MayDangleUntriaged
Traits
>
(
o
)
;
}
template
<
typename
T
RawPtrTraits
Traits
>
auto
UnsafeDanglingUntriaged
(
raw_ref
<
T
Traits
>
&
&
o
)
{
return
internal
:
:
UnretainedRefWrapper
<
T
unretained_traits
:
:
MayDangleUntriaged
Traits
>
(
std
:
:
move
(
o
)
)
;
}
template
<
typename
T
>
inline
internal
:
:
RetainedRefWrapper
<
T
>
RetainedRef
(
T
*
o
)
{
return
internal
:
:
RetainedRefWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
>
inline
internal
:
:
RetainedRefWrapper
<
T
>
RetainedRef
(
scoped_refptr
<
T
>
o
)
{
return
internal
:
:
RetainedRefWrapper
<
T
>
(
std
:
:
move
(
o
)
)
;
}
template
<
typename
T
>
inline
internal
:
:
OwnedWrapper
<
T
>
Owned
(
T
*
o
)
{
return
internal
:
:
OwnedWrapper
<
T
>
(
o
)
;
}
template
<
typename
T
typename
Deleter
>
inline
internal
:
:
OwnedWrapper
<
T
Deleter
>
Owned
(
std
:
:
unique_ptr
<
T
Deleter
>
&
&
ptr
)
{
return
internal
:
:
OwnedWrapper
<
T
Deleter
>
(
std
:
:
move
(
ptr
)
)
;
}
template
<
typename
T
>
internal
:
:
OwnedRefWrapper
<
std
:
:
decay_t
<
T
>
>
OwnedRef
(
T
&
&
t
)
{
return
internal
:
:
OwnedRefWrapper
<
std
:
:
decay_t
<
T
>
>
(
std
:
:
forward
<
T
>
(
t
)
)
;
}
template
<
typename
T
std
:
:
enable_if_t
<
!
std
:
:
is_lvalue_reference_v
<
T
>
>
*
=
nullptr
>
inline
internal
:
:
PassedWrapper
<
T
>
Passed
(
T
&
&
scoper
)
{
return
internal
:
:
PassedWrapper
<
T
>
(
std
:
:
move
(
scoper
)
)
;
}
template
<
typename
T
>
inline
internal
:
:
PassedWrapper
<
T
>
Passed
(
T
*
scoper
)
{
return
internal
:
:
PassedWrapper
<
T
>
(
std
:
:
move
(
*
scoper
)
)
;
}
template
<
typename
T
>
inline
internal
:
:
IgnoreResultHelper
<
T
>
IgnoreResult
(
T
data
)
{
return
internal
:
:
IgnoreResultHelper
<
T
>
(
std
:
:
move
(
data
)
)
;
}
}
#
endif
