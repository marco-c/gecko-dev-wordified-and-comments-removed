#
ifndef
BASE_FUNCTIONAL_CALLBACK_HELPERS_H_
#
define
BASE_FUNCTIONAL_CALLBACK_HELPERS_H_
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
functional
/
bind
.
h
"
#
include
"
base
/
functional
/
callback
.
h
"
#
include
"
base
/
functional
/
callback_tags
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
T
>
struct
IsBaseCallbackImpl
:
std
:
:
false_type
{
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
IsBaseCallbackImpl
<
OnceCallback
<
R
(
Args
.
.
.
)
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
IsBaseCallbackImpl
<
RepeatingCallback
<
R
(
Args
.
.
.
)
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
IsOnceCallbackImpl
:
std
:
:
false_type
{
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
IsOnceCallbackImpl
<
OnceCallback
<
R
(
Args
.
.
.
)
>
>
:
std
:
:
true_type
{
}
;
}
template
<
typename
T
>
using
IsBaseCallback
=
internal
:
:
IsBaseCallbackImpl
<
std
:
:
decay_t
<
T
>
>
;
template
<
typename
T
>
using
IsOnceCallback
=
internal
:
:
IsOnceCallbackImpl
<
std
:
:
decay_t
<
T
>
>
;
template
<
template
<
typename
>
class
CallbackType
>
using
EnableIfIsBaseCallback
=
std
:
:
enable_if_t
<
IsBaseCallback
<
CallbackType
<
void
(
)
>
>
:
:
value
>
;
namespace
internal
{
template
<
typename
.
.
.
Args
>
class
OnceCallbackHolder
final
{
public
:
OnceCallbackHolder
(
OnceCallback
<
void
(
Args
.
.
.
)
>
callback
bool
ignore_extra_runs
)
:
callback_
(
std
:
:
move
(
callback
)
)
ignore_extra_runs_
(
ignore_extra_runs
)
{
DCHECK
(
callback_
)
;
}
OnceCallbackHolder
(
const
OnceCallbackHolder
&
)
=
delete
;
OnceCallbackHolder
&
operator
=
(
const
OnceCallbackHolder
&
)
=
delete
;
void
Run
(
Args
.
.
.
args
)
{
if
(
has_run_
.
exchange
(
true
std
:
:
memory_order_relaxed
)
)
{
CHECK
(
ignore_extra_runs_
)
<
<
"
Both
OnceCallbacks
returned
by
"
"
base
:
:
SplitOnceCallback
(
)
were
run
.
"
"
At
most
one
of
the
pair
should
be
run
.
"
;
return
;
}
DCHECK
(
callback_
)
;
std
:
:
move
(
callback_
)
.
Run
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
private
:
std
:
:
atomic
<
bool
>
has_run_
{
false
}
;
base
:
:
OnceCallback
<
void
(
Args
.
.
.
)
>
callback_
;
const
bool
ignore_extra_runs_
;
}
;
template
<
typename
.
.
.
Args
>
void
ForwardRepeatingCallbacksImpl
(
std
:
:
vector
<
RepeatingCallback
<
void
(
Args
.
.
.
)
>
>
cbs
Args
.
.
.
args
)
{
for
(
auto
&
cb
:
cbs
)
{
if
(
cb
)
{
cb
.
Run
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
}
}
template
<
typename
.
.
.
Args
>
RepeatingCallback
<
void
(
Args
.
.
.
)
>
ForwardRepeatingCallbacks
(
std
:
:
initializer_list
<
RepeatingCallback
<
void
(
Args
.
.
.
)
>
>
&
&
cbs
)
{
std
:
:
vector
<
RepeatingCallback
<
void
(
Args
.
.
.
)
>
>
v
(
std
:
:
forward
<
std
:
:
initializer_list
<
RepeatingCallback
<
void
(
Args
.
.
.
)
>
>
>
(
cbs
)
)
;
return
BindRepeating
(
&
internal
:
:
ForwardRepeatingCallbacksImpl
<
Args
.
.
.
>
std
:
:
move
(
v
)
)
;
}
template
<
typename
.
.
.
Args
>
std
:
:
pair
<
OnceCallback
<
void
(
Args
.
.
.
)
>
OnceCallback
<
void
(
Args
.
.
.
)
>
>
SplitOnceCallback
(
OnceCallback
<
void
(
Args
.
.
.
)
>
callback
)
{
if
(
!
callback
)
{
return
std
:
:
make_pair
(
OnceCallback
<
void
(
Args
.
.
.
)
>
(
)
OnceCallback
<
void
(
Args
.
.
.
)
>
(
)
)
;
}
using
Helper
=
internal
:
:
OnceCallbackHolder
<
Args
.
.
.
>
;
auto
wrapped_once
=
base
:
:
BindRepeating
(
&
Helper
:
:
Run
std
:
:
make_unique
<
Helper
>
(
std
:
:
move
(
callback
)
false
)
)
;
return
std
:
:
make_pair
(
wrapped_once
wrapped_once
)
;
}
template
<
typename
.
.
.
Preargs
typename
.
.
.
Args
>
RepeatingCallback
<
void
(
Preargs
.
.
.
Args
.
.
.
)
>
IgnoreArgs
(
RepeatingCallback
<
void
(
Args
.
.
.
)
>
callback
)
{
return
callback
?
BindRepeating
(
[
]
(
RepeatingCallback
<
void
(
Args
.
.
.
)
>
callback
Preargs
.
.
.
Args
.
.
.
args
)
{
std
:
:
move
(
callback
)
.
Run
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
std
:
:
move
(
callback
)
)
:
RepeatingCallback
<
void
(
Preargs
.
.
.
Args
.
.
.
)
>
(
)
;
}
template
<
typename
.
.
.
Preargs
typename
.
.
.
Args
>
OnceCallback
<
void
(
Preargs
.
.
.
Args
.
.
.
)
>
IgnoreArgs
(
OnceCallback
<
void
(
Args
.
.
.
)
>
callback
)
{
return
callback
?
BindOnce
(
[
]
(
OnceCallback
<
void
(
Args
.
.
.
)
>
callback
Preargs
.
.
.
Args
.
.
.
args
)
{
std
:
:
move
(
callback
)
.
Run
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
std
:
:
move
(
callback
)
)
:
OnceCallback
<
void
(
Preargs
.
.
.
Args
.
.
.
)
>
(
)
;
}
class
BASE_EXPORT
ScopedClosureRunner
{
public
:
ScopedClosureRunner
(
)
;
explicit
ScopedClosureRunner
(
OnceClosure
closure
)
;
ScopedClosureRunner
(
ScopedClosureRunner
&
&
other
)
;
ScopedClosureRunner
&
operator
=
(
ScopedClosureRunner
&
&
other
)
;
~
ScopedClosureRunner
(
)
;
explicit
operator
bool
(
)
const
{
return
!
!
closure_
;
}
void
RunAndReset
(
)
;
void
ReplaceClosure
(
OnceClosure
closure
)
;
[
[
nodiscard
]
]
OnceClosure
Release
(
)
;
private
:
OnceClosure
closure_
;
}
;
constexpr
auto
NullCallback
(
)
{
return
internal
:
:
NullCallbackTag
(
)
;
}
constexpr
auto
DoNothing
(
)
{
return
internal
:
:
DoNothingCallbackTag
(
)
;
}
template
<
typename
Signature
>
constexpr
auto
NullCallbackAs
(
)
{
return
internal
:
:
NullCallbackTag
:
:
WithSignature
<
Signature
>
(
)
;
}
template
<
typename
Signature
>
constexpr
auto
DoNothingAs
(
)
{
return
internal
:
:
DoNothingCallbackTag
:
:
WithSignature
<
Signature
>
(
)
;
}
template
<
typename
.
.
.
Args
>
constexpr
auto
DoNothingWithBoundArgs
(
Args
&
&
.
.
.
args
)
{
return
internal
:
:
DoNothingCallbackTag
:
:
WithBoundArguments
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
>
constexpr
OnceCallback
<
T
(
void
)
>
ReturnValueOnce
(
T
value
)
{
static_assert
(
!
std
:
:
is_reference_v
<
T
>
)
;
return
base
:
:
BindOnce
(
[
]
(
T
value
)
{
return
value
;
}
std
:
:
move
(
value
)
)
;
}
template
<
typename
T
>
void
DeletePointer
(
T
*
obj
)
{
delete
obj
;
}
#
if
__OBJC__
template
<
typename
R
typename
.
.
.
Args
>
auto
CallbackToBlock
(
base
:
:
OnceCallback
<
R
(
Args
.
.
.
)
>
callback
)
{
__block
base
:
:
OnceCallback
<
R
(
Args
.
.
.
)
>
block_callback
=
std
:
:
move
(
callback
)
;
return
^
(
Args
.
.
.
args
)
{
return
std
:
:
move
(
block_callback
)
.
Run
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
;
}
template
<
typename
R
typename
.
.
.
Args
>
auto
CallbackToBlock
(
base
:
:
RepeatingCallback
<
R
(
Args
.
.
.
)
>
callback
)
{
return
^
(
Args
.
.
.
args
)
{
return
callback
.
Run
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
;
}
#
endif
}
#
endif
