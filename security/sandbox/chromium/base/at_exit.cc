#
include
"
base
/
at_exit
.
h
"
#
include
<
stddef
.
h
>
#
include
<
ostream
>
#
include
<
utility
>
#
include
"
base
/
bind
.
h
"
#
include
"
base
/
callback
.
h
"
#
include
"
base
/
logging
.
h
"
namespace
base
{
static
AtExitManager
*
g_top_manager
=
nullptr
;
static
bool
g_disable_managers
=
false
;
AtExitManager
:
:
AtExitManager
(
)
:
next_manager_
(
g_top_manager
)
{
#
if
!
defined
(
COMPONENT_BUILD
)
DCHECK
(
!
g_top_manager
)
;
#
endif
g_top_manager
=
this
;
}
AtExitManager
:
:
~
AtExitManager
(
)
{
if
(
!
g_top_manager
)
{
NOTREACHED
(
)
<
<
"
Tried
to
~
AtExitManager
without
an
AtExitManager
"
;
return
;
}
DCHECK_EQ
(
this
g_top_manager
)
;
if
(
!
g_disable_managers
)
ProcessCallbacksNow
(
)
;
g_top_manager
=
next_manager_
;
}
void
AtExitManager
:
:
RegisterCallback
(
AtExitCallbackType
func
void
*
param
)
{
DCHECK
(
func
)
;
RegisterTask
(
base
:
:
Bind
(
func
param
)
)
;
}
void
AtExitManager
:
:
RegisterTask
(
base
:
:
Closure
task
)
{
if
(
!
g_top_manager
)
{
NOTREACHED
(
)
<
<
"
Tried
to
RegisterCallback
without
an
AtExitManager
"
;
return
;
}
AutoLock
lock
(
g_top_manager
-
>
lock_
)
;
#
if
DCHECK_IS_ON
(
)
DCHECK
(
!
g_top_manager
-
>
processing_callbacks_
)
;
#
endif
g_top_manager
-
>
stack_
.
push
(
std
:
:
move
(
task
)
)
;
}
void
AtExitManager
:
:
ProcessCallbacksNow
(
)
{
if
(
!
g_top_manager
)
{
NOTREACHED
(
)
<
<
"
Tried
to
ProcessCallbacksNow
without
an
AtExitManager
"
;
return
;
}
base
:
:
stack
<
base
:
:
Closure
>
tasks
;
{
AutoLock
lock
(
g_top_manager
-
>
lock_
)
;
tasks
.
swap
(
g_top_manager
-
>
stack_
)
;
#
if
DCHECK_IS_ON
(
)
g_top_manager
-
>
processing_callbacks_
=
true
;
#
endif
}
ScopedAllowCrossThreadRefCountAccess
allow_cross_thread_ref_count_access
;
while
(
!
tasks
.
empty
(
)
)
{
base
:
:
Closure
task
=
tasks
.
top
(
)
;
task
.
Run
(
)
;
tasks
.
pop
(
)
;
}
#
if
DCHECK_IS_ON
(
)
AutoLock
lock
(
g_top_manager
-
>
lock_
)
;
DCHECK
(
g_top_manager
-
>
stack_
.
empty
(
)
)
;
g_top_manager
-
>
processing_callbacks_
=
false
;
#
endif
}
void
AtExitManager
:
:
DisableAllAtExitManagers
(
)
{
AutoLock
lock
(
g_top_manager
-
>
lock_
)
;
g_disable_managers
=
true
;
}
AtExitManager
:
:
AtExitManager
(
bool
shadow
)
:
next_manager_
(
g_top_manager
)
{
DCHECK
(
shadow
|
|
!
g_top_manager
)
;
g_top_manager
=
this
;
}
}
