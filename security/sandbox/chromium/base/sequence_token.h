#
ifndef
BASE_SEQUENCE_TOKEN_H_
#
define
BASE_SEQUENCE_TOKEN_H_
#
include
"
base
/
auto_reset
.
h
"
#
include
"
base
/
base_export
.
h
"
namespace
base
{
class
BASE_EXPORT
SequenceToken
{
public
:
constexpr
SequenceToken
(
)
=
default
;
SequenceToken
(
const
SequenceToken
&
other
)
=
default
;
SequenceToken
&
operator
=
(
const
SequenceToken
&
other
)
=
default
;
bool
operator
=
=
(
const
SequenceToken
&
other
)
const
;
bool
operator
!
=
(
const
SequenceToken
&
other
)
const
;
bool
IsValid
(
)
const
;
int
ToInternalValue
(
)
const
;
static
SequenceToken
Create
(
)
;
static
SequenceToken
GetForCurrentThread
(
)
;
private
:
explicit
SequenceToken
(
int
token
)
:
token_
(
token
)
{
}
static
constexpr
int
kInvalidSequenceToken
=
-
1
;
int
token_
=
kInvalidSequenceToken
;
}
;
class
BASE_EXPORT
TaskToken
{
public
:
constexpr
TaskToken
(
)
=
default
;
TaskToken
(
const
TaskToken
&
other
)
=
default
;
TaskToken
&
operator
=
(
const
TaskToken
&
other
)
=
default
;
bool
operator
=
=
(
const
TaskToken
&
other
)
const
;
bool
operator
!
=
(
const
TaskToken
&
other
)
const
;
bool
IsValid
(
)
const
;
static
TaskToken
GetForCurrentThread
(
)
;
private
:
friend
class
ScopedSetSequenceTokenForCurrentThread
;
explicit
TaskToken
(
int
token
)
:
token_
(
token
)
{
}
static
TaskToken
Create
(
)
;
static
constexpr
int
kInvalidTaskToken
=
-
1
;
int
token_
=
kInvalidTaskToken
;
}
;
class
BASE_EXPORT
[
[
maybe_unused
nodiscard
]
]
ScopedSetSequenceTokenForCurrentThread
{
public
:
explicit
ScopedSetSequenceTokenForCurrentThread
(
const
SequenceToken
&
sequence_token
)
;
ScopedSetSequenceTokenForCurrentThread
(
const
ScopedSetSequenceTokenForCurrentThread
&
)
=
delete
;
ScopedSetSequenceTokenForCurrentThread
&
operator
=
(
const
ScopedSetSequenceTokenForCurrentThread
&
)
=
delete
;
~
ScopedSetSequenceTokenForCurrentThread
(
)
;
private
:
const
AutoReset
<
SequenceToken
>
sequence_token_resetter_
;
const
AutoReset
<
TaskToken
>
task_token_resetter_
;
}
;
}
#
endif
