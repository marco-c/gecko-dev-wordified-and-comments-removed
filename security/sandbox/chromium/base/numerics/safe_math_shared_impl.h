#
ifndef
BASE_NUMERICS_SAFE_MATH_SHARED_IMPL_H_
#
define
BASE_NUMERICS_SAFE_MATH_SHARED_IMPL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
cassert
>
#
include
<
climits
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
base
/
numerics
/
safe_conversions
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
IS_ASMJS
)
#
define
BASE_HAS_OPTIMIZED_SAFE_MATH
(
0
)
#
elif
!
defined
(
__native_client__
)
&
&
\
(
(
defined
(
__clang__
)
&
&
\
(
(
__clang_major__
>
3
)
|
|
\
(
__clang_major__
=
=
3
&
&
__clang_minor__
>
=
4
)
)
)
|
|
\
(
defined
(
__GNUC__
)
&
&
__GNUC__
>
=
5
)
)
#
include
"
base
/
numerics
/
safe_math_clang_gcc_impl
.
h
"
#
define
BASE_HAS_OPTIMIZED_SAFE_MATH
(
1
)
#
else
#
define
BASE_HAS_OPTIMIZED_SAFE_MATH
(
0
)
#
endif
namespace
base
{
namespace
internal
{
#
if
!
BASE_HAS_OPTIMIZED_SAFE_MATH
template
<
typename
T
typename
U
>
struct
CheckedAddFastOp
{
static
const
bool
is_supported
=
false
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
U
V
*
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
bool
>
(
)
;
}
}
;
template
<
typename
T
typename
U
>
struct
CheckedSubFastOp
{
static
const
bool
is_supported
=
false
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
U
V
*
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
bool
>
(
)
;
}
}
;
template
<
typename
T
typename
U
>
struct
CheckedMulFastOp
{
static
const
bool
is_supported
=
false
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
U
V
*
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
bool
>
(
)
;
}
}
;
template
<
typename
T
typename
U
>
struct
ClampedAddFastOp
{
static
const
bool
is_supported
=
false
;
template
<
typename
V
>
static
constexpr
V
Do
(
T
U
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
V
>
(
)
;
}
}
;
template
<
typename
T
typename
U
>
struct
ClampedSubFastOp
{
static
const
bool
is_supported
=
false
;
template
<
typename
V
>
static
constexpr
V
Do
(
T
U
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
V
>
(
)
;
}
}
;
template
<
typename
T
typename
U
>
struct
ClampedMulFastOp
{
static
const
bool
is_supported
=
false
;
template
<
typename
V
>
static
constexpr
V
Do
(
T
U
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
V
>
(
)
;
}
}
;
template
<
typename
T
>
struct
ClampedNegFastOp
{
static
const
bool
is_supported
=
false
;
static
constexpr
T
Do
(
T
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
T
>
(
)
;
}
}
;
#
endif
#
undef
BASE_HAS_OPTIMIZED_SAFE_MATH
template
<
typename
Numeric
bool
IsInteger
=
std
:
:
is_integral_v
<
Numeric
>
bool
IsFloat
=
std
:
:
is_floating_point_v
<
Numeric
>
>
struct
UnsignedOrFloatForSize
;
template
<
typename
Numeric
>
struct
UnsignedOrFloatForSize
<
Numeric
true
false
>
{
using
type
=
typename
std
:
:
make_unsigned
<
Numeric
>
:
:
type
;
}
;
template
<
typename
Numeric
>
struct
UnsignedOrFloatForSize
<
Numeric
false
true
>
{
using
type
=
Numeric
;
}
;
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
>
*
=
nullptr
>
constexpr
T
NegateWrapper
(
T
value
)
{
using
UnsignedT
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
return
static_cast
<
T
>
(
UnsignedT
(
0
)
-
static_cast
<
UnsignedT
>
(
value
)
)
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_floating_point_v
<
T
>
>
*
=
nullptr
>
constexpr
T
NegateWrapper
(
T
value
)
{
return
-
value
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
>
*
=
nullptr
>
constexpr
typename
std
:
:
make_unsigned
<
T
>
:
:
type
InvertWrapper
(
T
value
)
{
return
~
value
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
>
*
=
nullptr
>
constexpr
T
AbsWrapper
(
T
value
)
{
return
static_cast
<
T
>
(
SafeUnsignedAbs
(
value
)
)
;
}
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_floating_point_v
<
T
>
>
*
=
nullptr
>
constexpr
T
AbsWrapper
(
T
value
)
{
return
value
<
0
?
-
value
:
value
;
}
template
<
template
<
typename
typename
typename
>
class
M
typename
L
typename
R
>
struct
MathWrapper
{
using
math
=
M
<
typename
UnderlyingType
<
L
>
:
:
type
typename
UnderlyingType
<
R
>
:
:
type
void
>
;
using
type
=
typename
math
:
:
result_type
;
}
;
#
define
BASE_NUMERIC_ARITHMETIC_VARIADIC
(
CLASS
CL_ABBR
OP_NAME
)
\
template
<
typename
L
typename
R
typename
.
.
.
Args
>
\
constexpr
auto
CL_ABBR
#
#
OP_NAME
(
const
L
lhs
const
R
rhs
\
const
Args
.
.
.
args
)
{
\
return
CL_ABBR
#
#
MathOp
<
CLASS
#
#
OP_NAME
#
#
Op
L
R
Args
.
.
.
>
(
lhs
rhs
\
args
.
.
.
)
;
\
}
#
define
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
CLASS
CL_ABBR
OP_NAME
OP
CMP_OP
)
\
template
<
typename
L
typename
R
\
std
:
:
enable_if_t
<
Is
#
#
CLASS
#
#
Op
<
L
R
>
:
:
value
>
*
=
nullptr
>
\
constexpr
CLASS
#
#
Numeric
<
\
typename
MathWrapper
<
CLASS
#
#
OP_NAME
#
#
Op
L
R
>
:
:
type
>
\
operator
OP
(
const
L
lhs
const
R
rhs
)
{
\
return
decltype
(
lhs
OP
rhs
)
:
:
template
MathOp
<
CLASS
#
#
OP_NAME
#
#
Op
>
(
lhs
\
rhs
)
;
\
}
\
/
*
Assignment
arithmetic
operator
implementation
from
CLASS
#
#
Numeric
.
*
/
\
template
<
typename
L
>
\
template
<
typename
R
>
\
constexpr
CLASS
#
#
Numeric
<
L
>
&
CLASS
#
#
Numeric
<
L
>
:
:
operator
CMP_OP
(
\
const
R
rhs
)
{
\
return
MathOp
<
CLASS
#
#
OP_NAME
#
#
Op
>
(
rhs
)
;
\
}
\
/
*
Variadic
arithmetic
functions
that
return
CLASS
#
#
Numeric
.
*
/
\
BASE_NUMERIC_ARITHMETIC_VARIADIC
(
CLASS
CL_ABBR
OP_NAME
)
}
}
#
endif
