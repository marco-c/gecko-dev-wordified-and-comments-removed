#
ifndef
BASE_NUMERICS_CHECKED_MATH_IMPL_H_
#
define
BASE_NUMERICS_CHECKED_MATH_IMPL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
climits
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
base
/
numerics
/
safe_conversions
.
h
"
#
include
"
base
/
numerics
/
safe_math_shared_impl
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
T
>
constexpr
bool
CheckedAddImpl
(
T
x
T
y
T
*
result
)
{
static_assert
(
std
:
:
is_integral_v
<
T
>
"
Type
must
be
integral
"
)
;
using
UnsignedDst
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
using
SignedDst
=
typename
std
:
:
make_signed
<
T
>
:
:
type
;
const
UnsignedDst
ux
=
static_cast
<
UnsignedDst
>
(
x
)
;
const
UnsignedDst
uy
=
static_cast
<
UnsignedDst
>
(
y
)
;
const
UnsignedDst
uresult
=
static_cast
<
UnsignedDst
>
(
ux
+
uy
)
;
if
(
std
:
:
is_signed_v
<
T
>
?
static_cast
<
SignedDst
>
(
(
uresult
^
ux
)
&
(
uresult
^
uy
)
)
<
0
:
uresult
<
uy
)
{
return
false
;
}
*
result
=
static_cast
<
T
>
(
uresult
)
;
return
true
;
}
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedAddOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedAddOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
if
constexpr
(
CheckedAddFastOp
<
T
U
>
:
:
is_supported
)
return
CheckedAddFastOp
<
T
U
>
:
:
Do
(
x
y
result
)
;
using
FastPromotion
=
typename
FastIntegerArithmeticPromotion
<
T
U
>
:
:
type
;
using
Promotion
=
typename
std
:
:
conditional
<
(
IntegerBitsPlusSign
<
FastPromotion
>
:
:
value
>
IntegerBitsPlusSign
<
intptr_t
>
:
:
value
)
typename
BigEnoughPromotion
<
T
U
>
:
:
type
FastPromotion
>
:
:
type
;
if
(
BASE_NUMERICS_UNLIKELY
(
!
IsValueInRangeForNumericType
<
Promotion
>
(
x
)
|
|
!
IsValueInRangeForNumericType
<
Promotion
>
(
y
)
)
)
{
return
false
;
}
Promotion
presult
=
{
}
;
bool
is_valid
=
true
;
if
(
IsIntegerArithmeticSafe
<
Promotion
T
U
>
:
:
value
)
{
presult
=
static_cast
<
Promotion
>
(
x
)
+
static_cast
<
Promotion
>
(
y
)
;
}
else
{
is_valid
=
CheckedAddImpl
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
}
if
(
!
is_valid
|
|
!
IsValueInRangeForNumericType
<
V
>
(
presult
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
presult
)
;
return
true
;
}
}
;
template
<
typename
T
>
constexpr
bool
CheckedSubImpl
(
T
x
T
y
T
*
result
)
{
static_assert
(
std
:
:
is_integral_v
<
T
>
"
Type
must
be
integral
"
)
;
using
UnsignedDst
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
using
SignedDst
=
typename
std
:
:
make_signed
<
T
>
:
:
type
;
const
UnsignedDst
ux
=
static_cast
<
UnsignedDst
>
(
x
)
;
const
UnsignedDst
uy
=
static_cast
<
UnsignedDst
>
(
y
)
;
const
UnsignedDst
uresult
=
static_cast
<
UnsignedDst
>
(
ux
-
uy
)
;
if
(
std
:
:
is_signed_v
<
T
>
?
static_cast
<
SignedDst
>
(
(
uresult
^
ux
)
&
(
ux
^
uy
)
)
<
0
:
x
<
y
)
{
return
false
;
}
*
result
=
static_cast
<
T
>
(
uresult
)
;
return
true
;
}
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedSubOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedSubOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
if
constexpr
(
CheckedSubFastOp
<
T
U
>
:
:
is_supported
)
return
CheckedSubFastOp
<
T
U
>
:
:
Do
(
x
y
result
)
;
using
FastPromotion
=
typename
FastIntegerArithmeticPromotion
<
T
U
>
:
:
type
;
using
Promotion
=
typename
std
:
:
conditional
<
(
IntegerBitsPlusSign
<
FastPromotion
>
:
:
value
>
IntegerBitsPlusSign
<
intptr_t
>
:
:
value
)
typename
BigEnoughPromotion
<
T
U
>
:
:
type
FastPromotion
>
:
:
type
;
if
(
BASE_NUMERICS_UNLIKELY
(
!
IsValueInRangeForNumericType
<
Promotion
>
(
x
)
|
|
!
IsValueInRangeForNumericType
<
Promotion
>
(
y
)
)
)
{
return
false
;
}
Promotion
presult
=
{
}
;
bool
is_valid
=
true
;
if
(
IsIntegerArithmeticSafe
<
Promotion
T
U
>
:
:
value
)
{
presult
=
static_cast
<
Promotion
>
(
x
)
-
static_cast
<
Promotion
>
(
y
)
;
}
else
{
is_valid
=
CheckedSubImpl
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
}
if
(
!
is_valid
|
|
!
IsValueInRangeForNumericType
<
V
>
(
presult
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
presult
)
;
return
true
;
}
}
;
template
<
typename
T
>
constexpr
bool
CheckedMulImpl
(
T
x
T
y
T
*
result
)
{
static_assert
(
std
:
:
is_integral_v
<
T
>
"
Type
must
be
integral
"
)
;
using
UnsignedDst
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
using
SignedDst
=
typename
std
:
:
make_signed
<
T
>
:
:
type
;
const
UnsignedDst
ux
=
SafeUnsignedAbs
(
x
)
;
const
UnsignedDst
uy
=
SafeUnsignedAbs
(
y
)
;
const
UnsignedDst
uresult
=
static_cast
<
UnsignedDst
>
(
ux
*
uy
)
;
const
bool
is_negative
=
std
:
:
is_signed_v
<
T
>
&
&
static_cast
<
SignedDst
>
(
x
^
y
)
<
0
;
if
(
uy
>
UnsignedDst
(
!
std
:
:
is_signed_v
<
T
>
|
|
is_negative
)
&
&
ux
>
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
+
UnsignedDst
(
is_negative
)
)
/
uy
)
{
return
false
;
}
*
result
=
static_cast
<
T
>
(
is_negative
?
0
-
uresult
:
uresult
)
;
return
true
;
}
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedMulOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedMulOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
if
constexpr
(
CheckedMulFastOp
<
T
U
>
:
:
is_supported
)
return
CheckedMulFastOp
<
T
U
>
:
:
Do
(
x
y
result
)
;
using
Promotion
=
typename
FastIntegerArithmeticPromotion
<
T
U
>
:
:
type
;
if
(
BASE_NUMERICS_UNLIKELY
(
(
!
IsValueInRangeForNumericType
<
Promotion
>
(
x
)
|
|
!
IsValueInRangeForNumericType
<
Promotion
>
(
y
)
)
&
&
x
&
&
y
)
)
{
return
false
;
}
Promotion
presult
=
{
}
;
bool
is_valid
=
true
;
if
(
CheckedMulFastOp
<
Promotion
Promotion
>
:
:
is_supported
)
{
is_valid
=
CheckedMulFastOp
<
Promotion
Promotion
>
:
:
Do
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
}
else
if
(
IsIntegerArithmeticSafe
<
Promotion
T
U
>
:
:
value
)
{
presult
=
static_cast
<
Promotion
>
(
x
)
*
static_cast
<
Promotion
>
(
y
)
;
}
else
{
is_valid
=
CheckedMulImpl
(
static_cast
<
Promotion
>
(
x
)
static_cast
<
Promotion
>
(
y
)
&
presult
)
;
}
if
(
!
is_valid
|
|
!
IsValueInRangeForNumericType
<
V
>
(
presult
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
presult
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedDivOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedDivOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
if
(
BASE_NUMERICS_UNLIKELY
(
!
y
)
)
return
false
;
using
Promotion
=
typename
BigEnoughPromotion
<
T
U
>
:
:
type
;
if
(
BASE_NUMERICS_UNLIKELY
(
(
std
:
:
is_signed_v
<
T
>
&
&
std
:
:
is_signed_v
<
U
>
&
&
IsTypeInRangeForNumericType
<
T
Promotion
>
:
:
value
&
&
static_cast
<
Promotion
>
(
x
)
=
=
std
:
:
numeric_limits
<
Promotion
>
:
:
lowest
(
)
&
&
y
=
=
static_cast
<
U
>
(
-
1
)
)
)
)
{
return
false
;
}
if
(
BASE_NUMERICS_UNLIKELY
(
(
!
IsValueInRangeForNumericType
<
Promotion
>
(
x
)
|
|
!
IsValueInRangeForNumericType
<
Promotion
>
(
y
)
)
&
&
x
)
)
{
return
false
;
}
const
Promotion
presult
=
Promotion
(
x
)
/
Promotion
(
y
)
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
presult
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
presult
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedModOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedModOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
if
(
BASE_NUMERICS_UNLIKELY
(
!
y
)
)
return
false
;
using
Promotion
=
typename
BigEnoughPromotion
<
T
U
>
:
:
type
;
if
(
BASE_NUMERICS_UNLIKELY
(
(
std
:
:
is_signed_v
<
T
>
&
&
std
:
:
is_signed_v
<
U
>
&
&
IsTypeInRangeForNumericType
<
T
Promotion
>
:
:
value
&
&
static_cast
<
Promotion
>
(
x
)
=
=
std
:
:
numeric_limits
<
Promotion
>
:
:
lowest
(
)
&
&
y
=
=
static_cast
<
U
>
(
-
1
)
)
)
)
{
*
result
=
0
;
return
true
;
}
const
Promotion
presult
=
static_cast
<
Promotion
>
(
x
)
%
static_cast
<
Promotion
>
(
y
)
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
presult
)
)
return
false
;
*
result
=
static_cast
<
Promotion
>
(
presult
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedLshOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedLshOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
T
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
shift
V
*
result
)
{
if
(
BASE_NUMERICS_LIKELY
(
!
IsValueNegative
(
x
)
&
&
as_unsigned
(
shift
)
<
as_unsigned
(
std
:
:
numeric_limits
<
T
>
:
:
digits
)
)
)
{
*
result
=
static_cast
<
V
>
(
as_unsigned
(
x
)
<
<
shift
)
;
return
*
result
>
>
shift
=
=
x
;
}
if
(
!
std
:
:
is_signed_v
<
T
>
|
|
x
|
|
as_unsigned
(
shift
)
!
=
as_unsigned
(
std
:
:
numeric_limits
<
T
>
:
:
digits
)
)
{
return
false
;
}
*
result
=
0
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedRshOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedRshOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
T
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
shift
V
*
result
)
{
if
(
BASE_NUMERICS_UNLIKELY
(
as_unsigned
(
shift
)
>
=
IntegerBitsPlusSign
<
T
>
:
:
value
)
)
{
return
false
;
}
const
T
tmp
=
x
>
>
shift
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
tmp
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedAndOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedAndOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
typename
std
:
:
make_unsigned
<
typename
MaxExponentPromotion
<
T
U
>
:
:
type
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
const
result_type
tmp
=
static_cast
<
result_type
>
(
x
)
&
static_cast
<
result_type
>
(
y
)
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
tmp
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedOrOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedOrOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
typename
std
:
:
make_unsigned
<
typename
MaxExponentPromotion
<
T
U
>
:
:
type
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
const
result_type
tmp
=
static_cast
<
result_type
>
(
x
)
|
static_cast
<
result_type
>
(
y
)
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
tmp
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedXorOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedXorOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
std
:
:
is_integral_v
<
U
>
>
>
{
using
result_type
=
typename
std
:
:
make_unsigned
<
typename
MaxExponentPromotion
<
T
U
>
:
:
type
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
const
result_type
tmp
=
static_cast
<
result_type
>
(
x
)
^
static_cast
<
result_type
>
(
y
)
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
tmp
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedMaxOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedMaxOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_arithmetic_v
<
T
>
&
&
std
:
:
is_arithmetic_v
<
U
>
>
>
{
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
const
result_type
tmp
=
IsGreater
<
T
U
>
:
:
Test
(
x
y
)
?
static_cast
<
result_type
>
(
x
)
:
static_cast
<
result_type
>
(
y
)
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
tmp
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
class
Enable
=
void
>
struct
CheckedMinOp
{
}
;
template
<
typename
T
typename
U
>
struct
CheckedMinOp
<
T
U
std
:
:
enable_if_t
<
std
:
:
is_arithmetic_v
<
T
>
&
&
std
:
:
is_arithmetic_v
<
U
>
>
>
{
using
result_type
=
typename
LowestValuePromotion
<
T
U
>
:
:
type
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
const
result_type
tmp
=
IsLess
<
T
U
>
:
:
Test
(
x
y
)
?
static_cast
<
result_type
>
(
x
)
:
static_cast
<
result_type
>
(
y
)
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
tmp
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
tmp
)
;
return
true
;
}
}
;
#
define
BASE_FLOAT_ARITHMETIC_OPS
(
NAME
OP
)
\
template
<
typename
T
typename
U
>
\
struct
Checked
#
#
NAME
#
#
Op
<
T
U
\
std
:
:
enable_if_t
<
std
:
:
is_floating_point_v
<
T
>
|
|
\
std
:
:
is_floating_point_v
<
U
>
>
>
{
\
using
result_type
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
\
template
<
typename
V
>
\
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
\
using
Promotion
=
typename
MaxExponentPromotion
<
T
U
>
:
:
type
;
\
const
Promotion
presult
=
x
OP
y
;
\
if
(
!
IsValueInRangeForNumericType
<
V
>
(
presult
)
)
\
return
false
;
\
*
result
=
static_cast
<
V
>
(
presult
)
;
\
return
true
;
\
}
\
}
;
BASE_FLOAT_ARITHMETIC_OPS
(
Add
+
)
BASE_FLOAT_ARITHMETIC_OPS
(
Sub
-
)
BASE_FLOAT_ARITHMETIC_OPS
(
Mul
*
)
BASE_FLOAT_ARITHMETIC_OPS
(
Div
/
)
#
undef
BASE_FLOAT_ARITHMETIC_OPS
enum
NumericRepresentation
{
NUMERIC_INTEGER
NUMERIC_FLOATING
NUMERIC_UNKNOWN
}
;
template
<
typename
NumericType
>
struct
GetNumericRepresentation
{
static
const
NumericRepresentation
value
=
std
:
:
is_integral_v
<
NumericType
>
?
NUMERIC_INTEGER
:
(
std
:
:
is_floating_point_v
<
NumericType
>
?
NUMERIC_FLOATING
:
NUMERIC_UNKNOWN
)
;
}
;
template
<
typename
T
NumericRepresentation
type
=
GetNumericRepresentation
<
T
>
:
:
value
>
class
CheckedNumericState
{
}
;
template
<
typename
T
>
class
CheckedNumericState
<
T
NUMERIC_INTEGER
>
{
public
:
template
<
typename
Src
=
int
>
constexpr
explicit
CheckedNumericState
(
Src
value
=
0
bool
is_valid
=
true
)
:
is_valid_
(
is_valid
&
&
IsValueInRangeForNumericType
<
T
>
(
value
)
)
value_
(
WellDefinedConversionOrZero
(
value
is_valid_
)
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
Src
>
"
Argument
must
be
numeric
.
"
)
;
}
template
<
typename
Src
>
constexpr
CheckedNumericState
(
const
CheckedNumericState
<
Src
>
&
rhs
)
:
CheckedNumericState
(
rhs
.
value
(
)
rhs
.
is_valid
(
)
)
{
}
constexpr
bool
is_valid
(
)
const
{
return
is_valid_
;
}
constexpr
T
value
(
)
const
{
return
value_
;
}
private
:
template
<
typename
Src
>
static
constexpr
T
WellDefinedConversionOrZero
(
Src
value
bool
is_valid
)
{
using
SrcType
=
typename
internal
:
:
UnderlyingType
<
Src
>
:
:
type
;
return
(
std
:
:
is_integral_v
<
SrcType
>
|
|
is_valid
)
?
static_cast
<
T
>
(
value
)
:
0
;
}
bool
is_valid_
;
T
value_
;
}
;
template
<
typename
T
>
class
CheckedNumericState
<
T
NUMERIC_FLOATING
>
{
public
:
template
<
typename
Src
=
double
>
constexpr
explicit
CheckedNumericState
(
Src
value
=
0
.
0
bool
is_valid
=
true
)
:
value_
(
WellDefinedConversionOrNaN
(
value
is_valid
&
&
IsValueInRangeForNumericType
<
T
>
(
value
)
)
)
{
}
template
<
typename
Src
>
constexpr
CheckedNumericState
(
const
CheckedNumericState
<
Src
>
&
rhs
)
:
CheckedNumericState
(
rhs
.
value
(
)
rhs
.
is_valid
(
)
)
{
}
constexpr
bool
is_valid
(
)
const
{
return
IsConstantEvaluated
(
)
?
value_
<
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
&
&
value_
>
=
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
:
std
:
:
isfinite
(
value_
)
;
}
constexpr
T
value
(
)
const
{
return
value_
;
}
private
:
template
<
typename
Src
>
static
constexpr
T
WellDefinedConversionOrNaN
(
Src
value
bool
is_valid
)
{
using
SrcType
=
typename
internal
:
:
UnderlyingType
<
Src
>
:
:
type
;
return
(
StaticDstRangeRelationToSrcRange
<
T
SrcType
>
:
:
value
=
=
NUMERIC_RANGE_CONTAINED
|
|
is_valid
)
?
static_cast
<
T
>
(
value
)
:
std
:
:
numeric_limits
<
T
>
:
:
quiet_NaN
(
)
;
}
T
value_
;
}
;
}
}
#
endif
