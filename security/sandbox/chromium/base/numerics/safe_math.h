#
ifndef
BASE_NUMERICS_SAFE_MATH_H_
#
define
BASE_NUMERICS_SAFE_MATH_H_
#
include
<
stddef
.
h
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
numerics
/
safe_math_impl
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
T
>
class
CheckedNumeric
{
static_assert
(
std
:
:
is_arithmetic
<
T
>
:
:
value
"
CheckedNumeric
<
T
>
:
T
must
be
a
numeric
type
.
"
)
;
public
:
typedef
T
type
;
CheckedNumeric
(
)
{
}
template
<
typename
Src
>
CheckedNumeric
(
const
CheckedNumeric
<
Src
>
&
rhs
)
:
state_
(
rhs
.
ValueUnsafe
(
)
rhs
.
IsValid
(
)
)
{
}
template
<
typename
Src
>
CheckedNumeric
(
Src
value
bool
is_valid
)
:
state_
(
value
is_valid
)
{
}
template
<
typename
Src
>
CheckedNumeric
(
Src
value
)
:
state_
(
value
)
{
static_assert
(
std
:
:
numeric_limits
<
Src
>
:
:
is_specialized
"
Argument
must
be
numeric
.
"
)
;
}
template
<
typename
Src
>
CheckedNumeric
(
StrictNumeric
<
Src
>
value
)
:
state_
(
static_cast
<
Src
>
(
value
)
)
{
}
bool
IsValid
(
)
const
{
return
state_
.
is_valid
(
)
;
}
T
ValueOrDie
(
)
const
{
CHECK
(
IsValid
(
)
)
;
return
state_
.
value
(
)
;
}
T
ValueOrDefault
(
T
default_value
)
const
{
return
IsValid
(
)
?
state_
.
value
(
)
:
default_value
;
}
T
ValueFloating
(
)
const
{
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
is_iec559
"
Argument
must
be
float
.
"
)
;
return
CheckedNumeric
<
T
>
:
:
cast
(
*
this
)
.
ValueUnsafe
(
)
;
}
T
ValueUnsafe
(
)
const
{
return
state_
.
value
(
)
;
}
template
<
typename
Src
>
CheckedNumeric
&
operator
+
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
-
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
*
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
/
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
%
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
<
<
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
>
>
=
(
Src
rhs
)
;
CheckedNumeric
operator
-
(
)
const
{
T
value
=
0
;
bool
is_valid
=
(
std
:
:
numeric_limits
<
T
>
:
:
is_iec559
|
|
IsValid
(
)
)
&
&
CheckedNeg
(
state_
.
value
(
)
&
value
)
;
return
CheckedNumeric
<
T
>
(
value
is_valid
)
;
}
CheckedNumeric
Abs
(
)
const
{
T
value
=
0
;
bool
is_valid
=
(
std
:
:
numeric_limits
<
T
>
:
:
is_iec559
|
|
IsValid
(
)
)
&
&
CheckedAbs
(
state_
.
value
(
)
&
value
)
;
return
CheckedNumeric
<
T
>
(
value
is_valid
)
;
}
CheckedNumeric
<
typename
UnsignedOrFloatForSize
<
T
>
:
:
type
>
UnsignedAbs
(
)
const
{
return
CheckedNumeric
<
typename
UnsignedOrFloatForSize
<
T
>
:
:
type
>
(
SafeUnsignedAbs
(
state_
.
value
(
)
)
state_
.
is_valid
(
)
)
;
}
CheckedNumeric
&
operator
+
+
(
)
{
*
this
+
=
1
;
return
*
this
;
}
CheckedNumeric
operator
+
+
(
int
)
{
CheckedNumeric
value
=
*
this
;
*
this
+
=
1
;
return
value
;
}
CheckedNumeric
&
operator
-
-
(
)
{
*
this
-
=
1
;
return
*
this
;
}
CheckedNumeric
operator
-
-
(
int
)
{
CheckedNumeric
value
=
*
this
;
*
this
-
=
1
;
return
value
;
}
template
<
typename
Src
>
static
CheckedNumeric
<
T
>
cast
(
Src
u
typename
std
:
:
enable_if
<
std
:
:
numeric_limits
<
Src
>
:
:
is_specialized
int
>
:
:
type
=
0
)
{
return
u
;
}
template
<
typename
Src
>
static
CheckedNumeric
<
T
>
cast
(
const
CheckedNumeric
<
Src
>
&
u
typename
std
:
:
enable_if
<
!
std
:
:
is_same
<
Src
T
>
:
:
value
int
>
:
:
type
=
0
)
{
return
u
;
}
static
const
CheckedNumeric
<
T
>
&
cast
(
const
CheckedNumeric
<
T
>
&
u
)
{
return
u
;
}
private
:
CheckedNumericState
<
T
>
state_
;
}
;
#
define
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
NAME
OP
COMPOUND_OP
PROMOTION
)
\
template
<
typename
L
typename
R
>
\
CheckedNumeric
<
typename
ArithmeticPromotion
<
PROMOTION
L
R
>
:
:
type
>
\
operator
OP
(
const
CheckedNumeric
<
L
>
&
lhs
const
CheckedNumeric
<
R
>
&
rhs
)
{
\
using
P
=
typename
ArithmeticPromotion
<
PROMOTION
L
R
>
:
:
type
;
\
if
(
!
rhs
.
IsValid
(
)
|
|
!
lhs
.
IsValid
(
)
)
\
return
CheckedNumeric
<
P
>
(
0
false
)
;
\
/
*
Floating
point
always
takes
the
fast
path
*
/
\
if
(
std
:
:
is_floating_point
<
L
>
:
:
value
|
|
std
:
:
is_floating_point
<
R
>
:
:
value
)
\
return
CheckedNumeric
<
P
>
(
lhs
.
ValueUnsafe
(
)
OP
rhs
.
ValueUnsafe
(
)
)
;
\
P
result
=
0
;
\
bool
is_valid
=
\
Checked
#
#
NAME
(
lhs
.
ValueUnsafe
(
)
rhs
.
ValueUnsafe
(
)
&
result
)
;
\
return
CheckedNumeric
<
P
>
(
result
is_valid
)
;
\
}
\
/
*
Assignment
arithmetic
operator
implementation
from
CheckedNumeric
.
*
/
\
template
<
typename
L
>
\
template
<
typename
R
>
\
CheckedNumeric
<
L
>
&
CheckedNumeric
<
L
>
:
:
operator
COMPOUND_OP
(
R
rhs
)
{
\
*
this
=
*
this
OP
rhs
;
\
return
*
this
;
\
}
\
/
*
Binary
arithmetic
operator
for
left
CheckedNumeric
and
right
numeric
.
*
/
\
template
<
typename
L
typename
R
\
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
R
>
:
:
value
>
:
:
type
*
=
\
nullptr
>
\
CheckedNumeric
<
typename
ArithmeticPromotion
<
PROMOTION
L
R
>
:
:
type
>
\
operator
OP
(
const
CheckedNumeric
<
L
>
&
lhs
R
rhs
)
{
\
return
lhs
OP
CheckedNumeric
<
R
>
(
rhs
)
;
\
}
\
/
*
Binary
arithmetic
operator
for
left
numeric
and
right
CheckedNumeric
.
*
/
\
template
<
typename
L
typename
R
\
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
L
>
:
:
value
>
:
:
type
*
=
\
nullptr
>
\
CheckedNumeric
<
typename
ArithmeticPromotion
<
PROMOTION
L
R
>
:
:
type
>
\
operator
OP
(
L
lhs
const
CheckedNumeric
<
R
>
&
rhs
)
{
\
return
CheckedNumeric
<
L
>
(
lhs
)
OP
rhs
;
\
}
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Add
+
+
=
MAX_EXPONENT_PROMOTION
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Sub
-
-
=
MAX_EXPONENT_PROMOTION
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Mul
*
*
=
MAX_EXPONENT_PROMOTION
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Div
/
/
=
MAX_EXPONENT_PROMOTION
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
Mod
%
%
=
MAX_EXPONENT_PROMOTION
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
LeftShift
<
<
<
<
=
LEFT_PROMOTION
)
BASE_NUMERIC_ARITHMETIC_OPERATORS
(
RightShift
>
>
>
>
=
LEFT_PROMOTION
)
#
undef
BASE_NUMERIC_ARITHMETIC_OPERATORS
}
using
internal
:
:
CheckedNumeric
;
}
#
endif
