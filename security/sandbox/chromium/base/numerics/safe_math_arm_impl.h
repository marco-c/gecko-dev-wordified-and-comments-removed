#
ifndef
BASE_NUMERICS_SAFE_MATH_ARM_IMPL_H_
#
define
BASE_NUMERICS_SAFE_MATH_ARM_IMPL_H_
#
include
<
cassert
>
#
include
<
type_traits
>
#
include
"
base
/
numerics
/
safe_conversions
.
h
"
namespace
base
{
namespace
internal
{
template
<
typename
T
typename
U
>
struct
CheckedMulFastAsmOp
{
static
const
bool
is_supported
=
kEnableAsmCode
&
&
FastIntegerArithmeticPromotion
<
T
U
>
:
:
is_contained
;
template
<
typename
V
>
static
constexpr
bool
Do
(
T
x
U
y
V
*
result
)
{
using
Promotion
=
typename
FastIntegerArithmeticPromotion
<
T
U
>
:
:
type
;
Promotion
presult
;
presult
=
static_cast
<
Promotion
>
(
x
)
*
static_cast
<
Promotion
>
(
y
)
;
if
(
!
IsValueInRangeForNumericType
<
V
>
(
presult
)
)
return
false
;
*
result
=
static_cast
<
V
>
(
presult
)
;
return
true
;
}
}
;
template
<
typename
T
typename
U
>
struct
ClampedAddFastAsmOp
{
static
const
bool
is_supported
=
kEnableAsmCode
&
&
BigEnoughPromotion
<
T
U
>
:
:
is_contained
&
&
IsTypeInRangeForNumericType
<
int32_t
typename
BigEnoughPromotion
<
T
U
>
:
:
type
>
:
:
value
;
template
<
typename
V
>
__attribute__
(
(
always_inline
)
)
static
V
Do
(
T
x
U
y
)
{
if
(
IsIntegerArithmeticSafe
<
int
T
U
>
:
:
value
)
return
saturated_cast
<
V
>
(
static_cast
<
int
>
(
x
)
+
static_cast
<
int
>
(
y
)
)
;
int32_t
result
;
int32_t
x_i32
=
checked_cast
<
int32_t
>
(
x
)
;
int32_t
y_i32
=
checked_cast
<
int32_t
>
(
y
)
;
asm
(
"
qadd
%
[
result
]
%
[
first
]
%
[
second
]
"
:
[
result
]
"
=
r
"
(
result
)
:
[
first
]
"
r
"
(
x_i32
)
[
second
]
"
r
"
(
y_i32
)
)
;
return
saturated_cast
<
V
>
(
result
)
;
}
}
;
template
<
typename
T
typename
U
>
struct
ClampedSubFastAsmOp
{
static
const
bool
is_supported
=
kEnableAsmCode
&
&
BigEnoughPromotion
<
T
U
>
:
:
is_contained
&
&
IsTypeInRangeForNumericType
<
int32_t
typename
BigEnoughPromotion
<
T
U
>
:
:
type
>
:
:
value
;
template
<
typename
V
>
__attribute__
(
(
always_inline
)
)
static
V
Do
(
T
x
U
y
)
{
if
(
IsIntegerArithmeticSafe
<
int
T
U
>
:
:
value
)
return
saturated_cast
<
V
>
(
static_cast
<
int
>
(
x
)
-
static_cast
<
int
>
(
y
)
)
;
int32_t
result
;
int32_t
x_i32
=
checked_cast
<
int32_t
>
(
x
)
;
int32_t
y_i32
=
checked_cast
<
int32_t
>
(
y
)
;
asm
(
"
qsub
%
[
result
]
%
[
first
]
%
[
second
]
"
:
[
result
]
"
=
r
"
(
result
)
:
[
first
]
"
r
"
(
x_i32
)
[
second
]
"
r
"
(
y_i32
)
)
;
return
saturated_cast
<
V
>
(
result
)
;
}
}
;
template
<
typename
T
typename
U
>
struct
ClampedMulFastAsmOp
{
static
const
bool
is_supported
=
kEnableAsmCode
&
&
CheckedMulFastAsmOp
<
T
U
>
:
:
is_supported
;
template
<
typename
V
>
__attribute__
(
(
always_inline
)
)
static
V
Do
(
T
x
U
y
)
{
if
(
!
IsIntegerArithmeticSafe
<
int32_t
T
U
>
:
:
value
&
&
!
IsIntegerArithmeticSafe
<
uint32_t
T
U
>
:
:
value
)
{
V
result
;
return
CheckedMulFastAsmOp
<
T
U
>
:
:
Do
(
x
y
&
result
)
?
result
:
CommonMaxOrMin
<
V
>
(
IsValueNegative
(
x
)
^
IsValueNegative
(
y
)
)
;
}
assert
(
(
FastIntegerArithmeticPromotion
<
T
U
>
:
:
is_contained
)
)
;
using
Promotion
=
typename
FastIntegerArithmeticPromotion
<
T
U
>
:
:
type
;
return
saturated_cast
<
V
>
(
static_cast
<
Promotion
>
(
x
)
*
static_cast
<
Promotion
>
(
y
)
)
;
}
}
;
}
}
#
endif
