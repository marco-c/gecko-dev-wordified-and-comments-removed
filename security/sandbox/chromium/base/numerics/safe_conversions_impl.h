#
ifndef
BASE_NUMERICS_SAFE_CONVERSIONS_IMPL_H_
#
define
BASE_NUMERICS_SAFE_CONVERSIONS_IMPL_H_
#
include
<
limits
.
h
>
#
include
<
stdint
.
h
>
#
include
<
climits
>
#
include
<
limits
>
#
include
<
type_traits
>
namespace
base
{
namespace
internal
{
template
<
typename
NumericType
>
struct
MaxExponent
{
static_assert
(
std
:
:
is_arithmetic
<
NumericType
>
:
:
value
"
Argument
must
be
numeric
.
"
)
;
static
const
int
value
=
std
:
:
numeric_limits
<
NumericType
>
:
:
is_iec559
?
std
:
:
numeric_limits
<
NumericType
>
:
:
max_exponent
:
(
sizeof
(
NumericType
)
*
CHAR_BIT
+
1
-
std
:
:
numeric_limits
<
NumericType
>
:
:
is_signed
)
;
}
;
enum
IntegerRepresentation
{
INTEGER_REPRESENTATION_UNSIGNED
INTEGER_REPRESENTATION_SIGNED
}
;
enum
NumericRangeRepresentation
{
NUMERIC_RANGE_NOT_CONTAINED
NUMERIC_RANGE_CONTAINED
}
;
template
<
typename
Dst
typename
Src
IntegerRepresentation
DstSign
=
std
:
:
numeric_limits
<
Dst
>
:
:
is_signed
?
INTEGER_REPRESENTATION_SIGNED
:
INTEGER_REPRESENTATION_UNSIGNED
IntegerRepresentation
SrcSign
=
std
:
:
numeric_limits
<
Src
>
:
:
is_signed
?
INTEGER_REPRESENTATION_SIGNED
:
INTEGER_REPRESENTATION_UNSIGNED
>
struct
StaticDstRangeRelationToSrcRange
;
template
<
typename
Dst
typename
Src
IntegerRepresentation
Sign
>
struct
StaticDstRangeRelationToSrcRange
<
Dst
Src
Sign
Sign
>
{
static
const
NumericRangeRepresentation
value
=
MaxExponent
<
Dst
>
:
:
value
>
=
MaxExponent
<
Src
>
:
:
value
?
NUMERIC_RANGE_CONTAINED
:
NUMERIC_RANGE_NOT_CONTAINED
;
}
;
template
<
typename
Dst
typename
Src
>
struct
StaticDstRangeRelationToSrcRange
<
Dst
Src
INTEGER_REPRESENTATION_SIGNED
INTEGER_REPRESENTATION_UNSIGNED
>
{
static
const
NumericRangeRepresentation
value
=
MaxExponent
<
Dst
>
:
:
value
>
MaxExponent
<
Src
>
:
:
value
?
NUMERIC_RANGE_CONTAINED
:
NUMERIC_RANGE_NOT_CONTAINED
;
}
;
template
<
typename
Dst
typename
Src
>
struct
StaticDstRangeRelationToSrcRange
<
Dst
Src
INTEGER_REPRESENTATION_UNSIGNED
INTEGER_REPRESENTATION_SIGNED
>
{
static
const
NumericRangeRepresentation
value
=
NUMERIC_RANGE_NOT_CONTAINED
;
}
;
enum
RangeConstraint
{
RANGE_VALID
=
0x0
RANGE_UNDERFLOW
=
0x1
RANGE_OVERFLOW
=
0x2
RANGE_INVALID
=
RANGE_UNDERFLOW
|
RANGE_OVERFLOW
}
;
constexpr
RangeConstraint
GetRangeConstraint
(
int
integer_range_constraint
)
{
return
static_cast
<
RangeConstraint
>
(
integer_range_constraint
)
;
}
constexpr
inline
RangeConstraint
GetRangeConstraint
(
bool
is_in_upper_bound
bool
is_in_lower_bound
)
{
return
GetRangeConstraint
(
(
is_in_upper_bound
?
0
:
RANGE_OVERFLOW
)
|
(
is_in_lower_bound
?
0
:
RANGE_UNDERFLOW
)
)
;
}
template
<
typename
Dst
typename
Src
>
struct
NarrowingRange
{
typedef
typename
std
:
:
numeric_limits
<
Src
>
SrcLimits
;
typedef
typename
std
:
:
numeric_limits
<
Dst
>
DstLimits
;
static
const
int
shift
=
(
MaxExponent
<
Src
>
:
:
value
>
MaxExponent
<
Dst
>
:
:
value
&
&
SrcLimits
:
:
digits
<
DstLimits
:
:
digits
&
&
SrcLimits
:
:
is_iec559
&
&
DstLimits
:
:
is_integer
)
?
(
DstLimits
:
:
digits
-
SrcLimits
:
:
digits
)
:
0
;
static
constexpr
Dst
max
(
)
{
return
DstLimits
:
:
max
(
)
-
static_cast
<
Dst
>
(
(
UINTMAX_C
(
1
)
<
<
shift
)
-
1
)
;
}
static
constexpr
Dst
min
(
)
{
return
std
:
:
numeric_limits
<
Dst
>
:
:
is_iec559
?
-
DstLimits
:
:
max
(
)
:
DstLimits
:
:
min
(
)
;
}
}
;
template
<
typename
Dst
typename
Src
IntegerRepresentation
DstSign
=
std
:
:
numeric_limits
<
Dst
>
:
:
is_signed
?
INTEGER_REPRESENTATION_SIGNED
:
INTEGER_REPRESENTATION_UNSIGNED
IntegerRepresentation
SrcSign
=
std
:
:
numeric_limits
<
Src
>
:
:
is_signed
?
INTEGER_REPRESENTATION_SIGNED
:
INTEGER_REPRESENTATION_UNSIGNED
NumericRangeRepresentation
DstRange
=
StaticDstRangeRelationToSrcRange
<
Dst
Src
>
:
:
value
>
struct
DstRangeRelationToSrcRangeImpl
;
template
<
typename
Dst
typename
Src
IntegerRepresentation
DstSign
IntegerRepresentation
SrcSign
>
struct
DstRangeRelationToSrcRangeImpl
<
Dst
Src
DstSign
SrcSign
NUMERIC_RANGE_CONTAINED
>
{
static
constexpr
RangeConstraint
Check
(
Src
value
)
{
return
RANGE_VALID
;
}
}
;
template
<
typename
Dst
typename
Src
>
struct
DstRangeRelationToSrcRangeImpl
<
Dst
Src
INTEGER_REPRESENTATION_SIGNED
INTEGER_REPRESENTATION_SIGNED
NUMERIC_RANGE_NOT_CONTAINED
>
{
static
constexpr
RangeConstraint
Check
(
Src
value
)
{
return
GetRangeConstraint
(
(
value
<
=
NarrowingRange
<
Dst
Src
>
:
:
max
(
)
)
(
value
>
=
NarrowingRange
<
Dst
Src
>
:
:
min
(
)
)
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
struct
DstRangeRelationToSrcRangeImpl
<
Dst
Src
INTEGER_REPRESENTATION_UNSIGNED
INTEGER_REPRESENTATION_UNSIGNED
NUMERIC_RANGE_NOT_CONTAINED
>
{
static
constexpr
RangeConstraint
Check
(
Src
value
)
{
return
GetRangeConstraint
(
value
<
=
NarrowingRange
<
Dst
Src
>
:
:
max
(
)
true
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
struct
DstRangeRelationToSrcRangeImpl
<
Dst
Src
INTEGER_REPRESENTATION_SIGNED
INTEGER_REPRESENTATION_UNSIGNED
NUMERIC_RANGE_NOT_CONTAINED
>
{
static
constexpr
RangeConstraint
Check
(
Src
value
)
{
return
sizeof
(
Dst
)
>
sizeof
(
Src
)
?
RANGE_VALID
:
GetRangeConstraint
(
value
<
=
static_cast
<
Src
>
(
NarrowingRange
<
Dst
Src
>
:
:
max
(
)
)
true
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
struct
DstRangeRelationToSrcRangeImpl
<
Dst
Src
INTEGER_REPRESENTATION_UNSIGNED
INTEGER_REPRESENTATION_SIGNED
NUMERIC_RANGE_NOT_CONTAINED
>
{
static
constexpr
RangeConstraint
Check
(
Src
value
)
{
return
(
MaxExponent
<
Dst
>
:
:
value
>
=
MaxExponent
<
Src
>
:
:
value
)
?
GetRangeConstraint
(
true
value
>
=
static_cast
<
Src
>
(
0
)
)
:
GetRangeConstraint
(
value
<
=
static_cast
<
Src
>
(
NarrowingRange
<
Dst
Src
>
:
:
max
(
)
)
value
>
=
static_cast
<
Src
>
(
0
)
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
constexpr
RangeConstraint
DstRangeRelationToSrcRange
(
Src
value
)
{
static_assert
(
std
:
:
numeric_limits
<
Src
>
:
:
is_specialized
"
Argument
must
be
numeric
.
"
)
;
static_assert
(
std
:
:
numeric_limits
<
Dst
>
:
:
is_specialized
"
Result
must
be
numeric
.
"
)
;
return
DstRangeRelationToSrcRangeImpl
<
Dst
Src
>
:
:
Check
(
value
)
;
}
}
}
#
endif
