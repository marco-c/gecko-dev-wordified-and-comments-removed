#
ifndef
BASE_NUMERICS_SAFE_CONVERSIONS_H_
#
define
BASE_NUMERICS_SAFE_CONVERSIONS_H_
#
include
<
stddef
.
h
>
#
include
<
cmath
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
base
/
numerics
/
safe_conversions_impl
.
h
"
#
if
defined
(
__ARMEL__
)
&
&
!
defined
(
__native_client__
)
#
include
"
base
/
numerics
/
safe_conversions_arm_impl
.
h
"
#
define
BASE_HAS_OPTIMIZED_SAFE_CONVERSIONS
(
1
)
#
else
#
define
BASE_HAS_OPTIMIZED_SAFE_CONVERSIONS
(
0
)
#
endif
namespace
base
{
namespace
internal
{
#
if
!
BASE_HAS_OPTIMIZED_SAFE_CONVERSIONS
template
<
typename
Dst
typename
Src
>
struct
SaturateFastAsmOp
{
static
constexpr
bool
is_supported
=
false
;
static
constexpr
Dst
Do
(
Src
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
Dst
>
(
)
;
}
}
;
#
endif
#
undef
BASE_HAS_OPTIMIZED_SAFE_CONVERSIONS
template
<
typename
Dst
typename
Src
typename
Enable
=
void
>
struct
IsValueInRangeFastOp
{
static
constexpr
bool
is_supported
=
false
;
static
constexpr
bool
Do
(
Src
value
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
bool
>
(
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
struct
IsValueInRangeFastOp
<
Dst
Src
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
Dst
>
&
&
std
:
:
is_integral_v
<
Src
>
&
&
std
:
:
is_signed_v
<
Dst
>
&
&
std
:
:
is_signed_v
<
Src
>
&
&
!
IsTypeInRangeForNumericType
<
Dst
Src
>
:
:
value
>
>
{
static
constexpr
bool
is_supported
=
true
;
static
constexpr
bool
Do
(
Src
value
)
{
return
value
=
=
static_cast
<
Dst
>
(
value
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
struct
IsValueInRangeFastOp
<
Dst
Src
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
Dst
>
&
&
std
:
:
is_integral_v
<
Src
>
&
&
!
std
:
:
is_signed_v
<
Dst
>
&
&
std
:
:
is_signed_v
<
Src
>
&
&
!
IsTypeInRangeForNumericType
<
Dst
Src
>
:
:
value
>
>
{
static
constexpr
bool
is_supported
=
true
;
static
constexpr
bool
Do
(
Src
value
)
{
return
as_unsigned
(
value
)
<
=
as_unsigned
(
CommonMax
<
Src
Dst
>
(
)
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
constexpr
bool
IsValueInRangeForNumericType
(
Src
value
)
{
using
SrcType
=
typename
internal
:
:
UnderlyingType
<
Src
>
:
:
type
;
return
internal
:
:
IsValueInRangeFastOp
<
Dst
SrcType
>
:
:
is_supported
?
internal
:
:
IsValueInRangeFastOp
<
Dst
SrcType
>
:
:
Do
(
static_cast
<
SrcType
>
(
value
)
)
:
internal
:
:
DstRangeRelationToSrcRange
<
Dst
>
(
static_cast
<
SrcType
>
(
value
)
)
.
IsValid
(
)
;
}
template
<
typename
Dst
class
CheckHandler
=
internal
:
:
CheckOnFailure
typename
Src
>
constexpr
Dst
checked_cast
(
Src
value
)
{
using
SrcType
=
typename
internal
:
:
UnderlyingType
<
Src
>
:
:
type
;
return
BASE_NUMERICS_LIKELY
(
(
IsValueInRangeForNumericType
<
Dst
>
(
value
)
)
)
?
static_cast
<
Dst
>
(
static_cast
<
SrcType
>
(
value
)
)
:
CheckHandler
:
:
template
HandleFailure
<
Dst
>
(
)
;
}
template
<
typename
T
>
struct
SaturationDefaultLimits
:
public
std
:
:
numeric_limits
<
T
>
{
static
constexpr
T
NaN
(
)
{
if
constexpr
(
std
:
:
numeric_limits
<
T
>
:
:
has_quiet_NaN
)
{
return
std
:
:
numeric_limits
<
T
>
:
:
quiet_NaN
(
)
;
}
else
{
return
T
(
)
;
}
}
using
std
:
:
numeric_limits
<
T
>
:
:
max
;
static
constexpr
T
Overflow
(
)
{
if
constexpr
(
std
:
:
numeric_limits
<
T
>
:
:
has_infinity
)
{
return
std
:
:
numeric_limits
<
T
>
:
:
infinity
(
)
;
}
else
{
return
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
;
}
}
using
std
:
:
numeric_limits
<
T
>
:
:
lowest
;
static
constexpr
T
Underflow
(
)
{
if
constexpr
(
std
:
:
numeric_limits
<
T
>
:
:
has_infinity
)
{
return
std
:
:
numeric_limits
<
T
>
:
:
infinity
(
)
*
-
1
;
}
else
{
return
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
;
}
}
}
;
template
<
typename
Dst
template
<
typename
>
class
S
typename
Src
>
constexpr
Dst
saturated_cast_impl
(
Src
value
RangeCheck
constraint
)
{
return
!
constraint
.
IsOverflowFlagSet
(
)
?
(
!
constraint
.
IsUnderflowFlagSet
(
)
?
static_cast
<
Dst
>
(
value
)
:
S
<
Dst
>
:
:
Underflow
(
)
)
:
(
std
:
:
is_integral_v
<
Src
>
|
|
!
constraint
.
IsUnderflowFlagSet
(
)
?
S
<
Dst
>
:
:
Overflow
(
)
:
S
<
Dst
>
:
:
NaN
(
)
)
;
}
template
<
typename
Dst
typename
Src
typename
Enable
=
void
>
struct
SaturateFastOp
{
static
constexpr
bool
is_supported
=
false
;
static
constexpr
Dst
Do
(
Src
value
)
{
return
CheckOnFailure
:
:
template
HandleFailure
<
Dst
>
(
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
struct
SaturateFastOp
<
Dst
Src
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
Src
>
&
&
std
:
:
is_integral_v
<
Dst
>
&
&
SaturateFastAsmOp
<
Dst
Src
>
:
:
is_supported
>
>
{
static
constexpr
bool
is_supported
=
true
;
static
constexpr
Dst
Do
(
Src
value
)
{
return
SaturateFastAsmOp
<
Dst
Src
>
:
:
Do
(
value
)
;
}
}
;
template
<
typename
Dst
typename
Src
>
struct
SaturateFastOp
<
Dst
Src
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
Src
>
&
&
std
:
:
is_integral_v
<
Dst
>
&
&
!
SaturateFastAsmOp
<
Dst
Src
>
:
:
is_supported
>
>
{
static
constexpr
bool
is_supported
=
true
;
static
constexpr
Dst
Do
(
Src
value
)
{
const
Dst
saturated
=
CommonMaxOrMin
<
Dst
Src
>
(
IsMaxInRangeForNumericType
<
Dst
Src
>
(
)
|
|
(
!
IsMinInRangeForNumericType
<
Dst
Src
>
(
)
&
&
IsValueNegative
(
value
)
)
)
;
return
BASE_NUMERICS_LIKELY
(
IsValueInRangeForNumericType
<
Dst
>
(
value
)
)
?
static_cast
<
Dst
>
(
value
)
:
saturated
;
}
}
;
template
<
typename
Dst
template
<
typename
>
class
SaturationHandler
=
SaturationDefaultLimits
typename
Src
>
constexpr
Dst
saturated_cast
(
Src
value
)
{
using
SrcType
=
typename
UnderlyingType
<
Src
>
:
:
type
;
return
!
IsConstantEvaluated
(
)
&
&
SaturateFastOp
<
Dst
SrcType
>
:
:
is_supported
&
&
std
:
:
is_same_v
<
SaturationHandler
<
Dst
>
SaturationDefaultLimits
<
Dst
>
>
?
SaturateFastOp
<
Dst
SrcType
>
:
:
Do
(
static_cast
<
SrcType
>
(
value
)
)
:
saturated_cast_impl
<
Dst
SaturationHandler
SrcType
>
(
static_cast
<
SrcType
>
(
value
)
DstRangeRelationToSrcRange
<
Dst
SaturationHandler
SrcType
>
(
static_cast
<
SrcType
>
(
value
)
)
)
;
}
template
<
typename
Dst
typename
Src
>
constexpr
Dst
strict_cast
(
Src
value
)
{
using
SrcType
=
typename
UnderlyingType
<
Src
>
:
:
type
;
static_assert
(
UnderlyingType
<
Src
>
:
:
is_numeric
"
Argument
must
be
numeric
.
"
)
;
static_assert
(
std
:
:
is_arithmetic_v
<
Dst
>
"
Result
must
be
numeric
.
"
)
;
static_assert
(
StaticDstRangeRelationToSrcRange
<
Dst
SrcType
>
:
:
value
=
=
NUMERIC_RANGE_CONTAINED
"
The
source
type
is
out
of
range
for
the
destination
type
.
"
"
Please
see
strict_cast
<
>
comments
for
more
information
.
"
)
;
return
static_cast
<
Dst
>
(
static_cast
<
SrcType
>
(
value
)
)
;
}
template
<
typename
Dst
typename
Src
class
Enable
=
void
>
struct
IsNumericRangeContained
{
static
constexpr
bool
value
=
false
;
}
;
template
<
typename
Dst
typename
Src
>
struct
IsNumericRangeContained
<
Dst
Src
std
:
:
enable_if_t
<
ArithmeticOrUnderlyingEnum
<
Dst
>
:
:
value
&
&
ArithmeticOrUnderlyingEnum
<
Src
>
:
:
value
>
>
{
static
constexpr
bool
value
=
StaticDstRangeRelationToSrcRange
<
Dst
Src
>
:
:
value
=
=
NUMERIC_RANGE_CONTAINED
;
}
;
template
<
typename
T
>
class
StrictNumeric
{
public
:
using
type
=
T
;
constexpr
StrictNumeric
(
)
:
value_
(
0
)
{
}
template
<
typename
Src
>
constexpr
StrictNumeric
(
const
StrictNumeric
<
Src
>
&
rhs
)
:
value_
(
strict_cast
<
T
>
(
rhs
.
value_
)
)
{
}
constexpr
StrictNumeric
(
T
value
)
:
value_
(
value
)
{
}
template
<
typename
Src
>
constexpr
StrictNumeric
(
Src
value
)
:
value_
(
strict_cast
<
T
>
(
value
)
)
{
}
template
<
typename
Dst
std
:
:
enable_if_t
<
IsNumericRangeContained
<
Dst
T
>
:
:
value
>
*
=
nullptr
>
constexpr
operator
Dst
(
)
const
{
return
static_cast
<
typename
ArithmeticOrUnderlyingEnum
<
Dst
>
:
:
type
>
(
value_
)
;
}
private
:
const
T
value_
;
}
;
template
<
typename
T
>
constexpr
StrictNumeric
<
typename
UnderlyingType
<
T
>
:
:
type
>
MakeStrictNum
(
const
T
value
)
{
return
value
;
}
#
define
BASE_NUMERIC_COMPARISON_OPERATORS
(
CLASS
NAME
OP
)
\
template
<
typename
L
typename
R
\
std
:
:
enable_if_t
<
internal
:
:
Is
#
#
CLASS
#
#
Op
<
L
R
>
:
:
value
>
*
=
nullptr
>
\
constexpr
bool
operator
OP
(
const
L
lhs
const
R
rhs
)
{
\
return
SafeCompare
<
NAME
typename
UnderlyingType
<
L
>
:
:
type
\
typename
UnderlyingType
<
R
>
:
:
type
>
(
lhs
rhs
)
;
\
}
BASE_NUMERIC_COMPARISON_OPERATORS
(
Strict
IsLess
<
)
BASE_NUMERIC_COMPARISON_OPERATORS
(
Strict
IsLessOrEqual
<
=
)
BASE_NUMERIC_COMPARISON_OPERATORS
(
Strict
IsGreater
>
)
BASE_NUMERIC_COMPARISON_OPERATORS
(
Strict
IsGreaterOrEqual
>
=
)
BASE_NUMERIC_COMPARISON_OPERATORS
(
Strict
IsEqual
=
=
)
BASE_NUMERIC_COMPARISON_OPERATORS
(
Strict
IsNotEqual
!
=
)
}
using
internal
:
:
as_signed
;
using
internal
:
:
as_unsigned
;
using
internal
:
:
checked_cast
;
using
internal
:
:
IsTypeInRangeForNumericType
;
using
internal
:
:
IsValueInRangeForNumericType
;
using
internal
:
:
IsValueNegative
;
using
internal
:
:
MakeStrictNum
;
using
internal
:
:
SafeUnsignedAbs
;
using
internal
:
:
saturated_cast
;
using
internal
:
:
strict_cast
;
using
internal
:
:
StrictNumeric
;
using
SizeT
=
StrictNumeric
<
size_t
>
;
template
<
typename
Dst
=
int
typename
Src
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
Dst
>
&
&
std
:
:
is_floating_point_v
<
Src
>
>
>
Dst
ClampFloor
(
Src
value
)
{
return
saturated_cast
<
Dst
>
(
std
:
:
floor
(
value
)
)
;
}
template
<
typename
Dst
=
int
typename
Src
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
Dst
>
&
&
std
:
:
is_floating_point_v
<
Src
>
>
>
Dst
ClampCeil
(
Src
value
)
{
return
saturated_cast
<
Dst
>
(
std
:
:
ceil
(
value
)
)
;
}
template
<
typename
Dst
=
int
typename
Src
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
Dst
>
&
&
std
:
:
is_floating_point_v
<
Src
>
>
>
Dst
ClampRound
(
Src
value
)
{
const
Src
rounded
=
std
:
:
round
(
value
)
;
return
saturated_cast
<
Dst
>
(
rounded
)
;
}
}
#
endif
