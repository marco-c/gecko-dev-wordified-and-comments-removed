#
include
"
base
/
time
/
time
.
h
"
#
include
<
windows
.
foundation
.
h
>
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
stdint
.
h
>
#
include
<
atomic
>
#
include
<
ostream
>
#
include
"
base
/
bit_cast
.
h
"
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
cpu
.
h
"
#
include
"
base
/
notreached
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
include
"
base
/
threading
/
platform_thread
.
h
"
#
include
"
base
/
time
/
time_override
.
h
"
#
include
"
build
/
build_config
.
h
"
namespace
base
{
namespace
{
int64_t
FileTimeToMicroseconds
(
const
FILETIME
&
ft
)
{
return
bit_cast
<
int64_t
FILETIME
>
(
ft
)
/
10
;
}
bool
CanConvertToFileTime
(
int64_t
us
)
{
return
us
>
=
0
&
&
us
<
=
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
/
10
)
;
}
FILETIME
MicrosecondsToFileTime
(
int64_t
us
)
{
DCHECK
(
CanConvertToFileTime
(
us
)
)
<
<
"
Out
-
of
-
range
:
Cannot
convert
"
<
<
us
<
<
"
microseconds
to
FILETIME
units
.
"
;
return
bit_cast
<
FILETIME
int64_t
>
(
us
*
10
)
;
}
int64_t
CurrentWallclockMicroseconds
(
)
{
FILETIME
ft
;
:
:
GetSystemTimeAsFileTime
(
&
ft
)
;
return
FileTimeToMicroseconds
(
ft
)
;
}
constexpr
TimeDelta
kMaxTimeToAvoidDrift
=
Seconds
(
60
)
;
int64_t
g_initial_time
=
0
;
TimeTicks
g_initial_ticks
;
void
InitializeClock
(
)
{
g_initial_ticks
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
;
g_initial_time
=
CurrentWallclockMicroseconds
(
)
;
}
UINT
g_last_interval_requested_ms
=
0
;
bool
g_high_res_timer_enabled
=
false
;
uint32_t
g_high_res_timer_count
=
0
;
TimeTicks
g_high_res_timer_usage_start
;
TimeDelta
g_high_res_timer_usage
;
TimeTicks
g_high_res_timer_last_activation
;
Lock
*
GetHighResLock
(
)
{
static
auto
*
lock
=
new
Lock
(
)
;
return
lock
;
}
constexpr
UINT
kMinTimerIntervalHighResMs
=
1
;
constexpr
UINT
kMinTimerIntervalLowResMs
=
8
;
UINT
GetIntervalMs
(
)
{
if
(
!
g_high_res_timer_count
)
return
0
;
if
(
g_high_res_timer_enabled
)
return
kMinTimerIntervalHighResMs
;
return
kMinTimerIntervalLowResMs
;
}
void
UpdateTimerIntervalLocked
(
)
{
UINT
new_interval
=
GetIntervalMs
(
)
;
if
(
new_interval
=
=
g_last_interval_requested_ms
)
return
;
if
(
g_last_interval_requested_ms
)
{
g_high_res_timer_usage
+
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
-
g_high_res_timer_last_activation
;
timeEndPeriod
(
g_last_interval_requested_ms
)
;
}
g_last_interval_requested_ms
=
new_interval
;
if
(
g_last_interval_requested_ms
)
{
g_high_res_timer_last_activation
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
;
timeBeginPeriod
(
g_last_interval_requested_ms
)
;
}
}
int64_t
QPCNowRaw
(
)
{
LARGE_INTEGER
perf_counter_now
=
{
}
;
:
:
QueryPerformanceCounter
(
&
perf_counter_now
)
;
return
perf_counter_now
.
QuadPart
;
}
bool
SafeConvertToWord
(
int
in
WORD
*
out
)
{
CheckedNumeric
<
WORD
>
result
=
in
;
*
out
=
result
.
ValueOrDefault
(
std
:
:
numeric_limits
<
WORD
>
:
:
max
(
)
)
;
return
result
.
IsValid
(
)
;
}
}
namespace
subtle
{
Time
TimeNowIgnoringOverride
(
)
{
if
(
g_initial_time
=
=
0
)
InitializeClock
(
)
;
while
(
true
)
{
TimeTicks
ticks
=
TimeTicksNowIgnoringOverride
(
)
;
TimeDelta
elapsed
=
ticks
-
g_initial_ticks
;
if
(
elapsed
>
kMaxTimeToAvoidDrift
)
{
InitializeClock
(
)
;
continue
;
}
return
Time
(
)
+
elapsed
+
Microseconds
(
g_initial_time
)
;
}
}
Time
TimeNowFromSystemTimeIgnoringOverride
(
)
{
InitializeClock
(
)
;
return
Time
(
)
+
Microseconds
(
g_initial_time
)
;
}
}
Time
Time
:
:
FromFileTime
(
FILETIME
ft
)
{
if
(
bit_cast
<
int64_t
FILETIME
>
(
ft
)
=
=
0
)
return
Time
(
)
;
if
(
ft
.
dwHighDateTime
=
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
&
&
ft
.
dwLowDateTime
=
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
)
return
Max
(
)
;
return
Time
(
FileTimeToMicroseconds
(
ft
)
)
;
}
FILETIME
Time
:
:
ToFileTime
(
)
const
{
if
(
is_null
(
)
)
return
bit_cast
<
FILETIME
int64_t
>
(
0
)
;
if
(
is_max
(
)
)
{
FILETIME
result
;
result
.
dwHighDateTime
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
;
result
.
dwLowDateTime
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
;
return
result
;
}
return
MicrosecondsToFileTime
(
us_
)
;
}
void
Time
:
:
EnableHighResolutionTimer
(
bool
enable
)
{
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
g_high_res_timer_enabled
=
enable
;
UpdateTimerIntervalLocked
(
)
;
}
bool
Time
:
:
ActivateHighResolutionTimer
(
bool
activating
)
{
const
uint32_t
max
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
if
(
activating
)
{
DCHECK_NE
(
g_high_res_timer_count
max
)
;
+
+
g_high_res_timer_count
;
}
else
{
DCHECK_NE
(
g_high_res_timer_count
0u
)
;
-
-
g_high_res_timer_count
;
}
UpdateTimerIntervalLocked
(
)
;
return
true
;
}
bool
Time
:
:
IsHighResolutionTimerInUse
(
)
{
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
return
g_last_interval_requested_ms
=
=
kMinTimerIntervalHighResMs
;
}
void
Time
:
:
ResetHighResolutionTimerUsage
(
)
{
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
g_high_res_timer_usage
=
TimeDelta
(
)
;
g_high_res_timer_usage_start
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
;
if
(
g_high_res_timer_count
>
0
)
g_high_res_timer_last_activation
=
g_high_res_timer_usage_start
;
}
double
Time
:
:
GetHighResolutionTimerUsage
(
)
{
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
TimeTicks
now
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
;
TimeDelta
elapsed_time
=
now
-
g_high_res_timer_usage_start
;
if
(
elapsed_time
.
is_zero
(
)
)
{
return
0
.
0
;
}
TimeDelta
used_time
=
g_high_res_timer_usage
;
if
(
g_high_res_timer_count
>
0
)
{
used_time
+
=
now
-
g_high_res_timer_last_activation
;
}
return
used_time
/
elapsed_time
*
100
;
}
bool
Time
:
:
FromExploded
(
bool
is_local
const
Exploded
&
exploded
Time
*
time
)
{
SYSTEMTIME
st
;
if
(
!
SafeConvertToWord
(
exploded
.
year
&
st
.
wYear
)
|
|
!
SafeConvertToWord
(
exploded
.
month
&
st
.
wMonth
)
|
|
!
SafeConvertToWord
(
exploded
.
day_of_week
&
st
.
wDayOfWeek
)
|
|
!
SafeConvertToWord
(
exploded
.
day_of_month
&
st
.
wDay
)
|
|
!
SafeConvertToWord
(
exploded
.
hour
&
st
.
wHour
)
|
|
!
SafeConvertToWord
(
exploded
.
minute
&
st
.
wMinute
)
|
|
!
SafeConvertToWord
(
exploded
.
second
&
st
.
wSecond
)
|
|
!
SafeConvertToWord
(
exploded
.
millisecond
&
st
.
wMilliseconds
)
)
{
*
time
=
Time
(
0
)
;
return
false
;
}
FILETIME
ft
;
bool
success
=
true
;
if
(
is_local
)
{
SYSTEMTIME
utc_st
;
success
=
TzSpecificLocalTimeToSystemTime
(
nullptr
&
st
&
utc_st
)
&
&
SystemTimeToFileTime
(
&
utc_st
&
ft
)
;
}
else
{
success
=
!
!
SystemTimeToFileTime
(
&
st
&
ft
)
;
}
*
time
=
Time
(
success
?
FileTimeToMicroseconds
(
ft
)
:
0
)
;
return
success
;
}
void
Time
:
:
Explode
(
bool
is_local
Exploded
*
exploded
)
const
{
if
(
!
CanConvertToFileTime
(
us_
)
)
{
ZeroMemory
(
exploded
sizeof
(
*
exploded
)
)
;
return
;
}
const
FILETIME
utc_ft
=
MicrosecondsToFileTime
(
us_
)
;
bool
success
=
true
;
SYSTEMTIME
st
=
{
0
}
;
if
(
is_local
)
{
SYSTEMTIME
utc_st
;
success
=
FileTimeToSystemTime
(
&
utc_ft
&
utc_st
)
&
&
SystemTimeToTzSpecificLocalTime
(
nullptr
&
utc_st
&
st
)
;
}
else
{
success
=
!
!
FileTimeToSystemTime
(
&
utc_ft
&
st
)
;
}
if
(
!
success
)
{
ZeroMemory
(
exploded
sizeof
(
*
exploded
)
)
;
return
;
}
exploded
-
>
year
=
st
.
wYear
;
exploded
-
>
month
=
st
.
wMonth
;
exploded
-
>
day_of_week
=
st
.
wDayOfWeek
;
exploded
-
>
day_of_month
=
st
.
wDay
;
exploded
-
>
hour
=
st
.
wHour
;
exploded
-
>
minute
=
st
.
wMinute
;
exploded
-
>
second
=
st
.
wSecond
;
exploded
-
>
millisecond
=
st
.
wMilliseconds
;
}
namespace
{
DWORD
timeGetTimeWrapper
(
)
{
return
timeGetTime
(
)
;
}
DWORD
(
*
g_tick_function
)
(
void
)
=
&
timeGetTimeWrapper
;
union
LastTimeAndRolloversState
{
std
:
:
atomic
<
int32_t
>
as_opaque_32
{
0
}
;
struct
{
uint8_t
last_8
;
uint16_t
rollovers
;
}
as_values
;
}
;
std
:
:
atomic
<
int32_t
>
g_last_time_and_rollovers
=
0
;
static_assert
(
sizeof
(
LastTimeAndRolloversState
)
<
=
sizeof
(
g_last_time_and_rollovers
)
"
LastTimeAndRolloversState
does
not
fit
in
a
single
atomic
word
"
)
;
TimeTicks
RolloverProtectedNow
(
)
{
LastTimeAndRolloversState
state
;
DWORD
now
;
while
(
true
)
{
int32_t
original
=
g_last_time_and_rollovers
.
load
(
std
:
:
memory_order_acquire
)
;
state
.
as_opaque_32
=
original
;
now
=
g_tick_function
(
)
;
uint8_t
now_8
=
static_cast
<
uint8_t
>
(
now
>
>
24
)
;
if
(
now_8
<
state
.
as_values
.
last_8
)
+
+
state
.
as_values
.
rollovers
;
state
.
as_values
.
last_8
=
now_8
;
if
(
state
.
as_opaque_32
=
=
original
)
break
;
bool
success
=
g_last_time_and_rollovers
.
compare_exchange_strong
(
original
state
.
as_opaque_32
std
:
:
memory_order_release
)
;
if
(
success
)
break
;
}
return
TimeTicks
(
)
+
Milliseconds
(
now
+
(
static_cast
<
uint64_t
>
(
state
.
as_values
.
rollovers
)
<
<
32
)
)
;
}
TimeTicks
InitialNowFunction
(
)
;
std
:
:
atomic
<
TimeTicksNowFunction
>
g_time_ticks_now_ignoring_override_function
{
&
InitialNowFunction
}
;
int64_t
g_qpc_ticks_per_second
=
0
;
TimeDelta
QPCValueToTimeDelta
(
LONGLONG
qpc_value
)
{
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_acquire
)
;
DCHECK_GT
(
g_qpc_ticks_per_second
0
)
;
if
(
qpc_value
<
Time
:
:
kQPCOverflowThreshold
)
{
return
Microseconds
(
qpc_value
*
Time
:
:
kMicrosecondsPerSecond
/
g_qpc_ticks_per_second
)
;
}
int64_t
whole_seconds
=
qpc_value
/
g_qpc_ticks_per_second
;
int64_t
leftover_ticks
=
qpc_value
-
(
whole_seconds
*
g_qpc_ticks_per_second
)
;
return
Microseconds
(
(
whole_seconds
*
Time
:
:
kMicrosecondsPerSecond
)
+
(
(
leftover_ticks
*
Time
:
:
kMicrosecondsPerSecond
)
/
g_qpc_ticks_per_second
)
)
;
}
TimeTicks
QPCNow
(
)
{
return
TimeTicks
(
)
+
QPCValueToTimeDelta
(
QPCNowRaw
(
)
)
;
}
void
InitializeNowFunctionPointer
(
)
{
LARGE_INTEGER
ticks_per_sec
=
{
}
;
if
(
!
QueryPerformanceFrequency
(
&
ticks_per_sec
)
)
ticks_per_sec
.
QuadPart
=
0
;
CPU
cpu
;
const
TimeTicksNowFunction
now_function
=
(
ticks_per_sec
.
QuadPart
<
=
0
|
|
!
cpu
.
has_non_stop_time_stamp_counter
(
)
)
?
&
RolloverProtectedNow
:
&
QPCNow
;
g_qpc_ticks_per_second
=
ticks_per_sec
.
QuadPart
;
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_release
)
;
base
:
:
TimeTicksNowFunction
initial_time_ticks_now_function
=
&
subtle
:
:
TimeTicksNowIgnoringOverride
;
internal
:
:
g_time_ticks_now_function
.
compare_exchange_strong
(
initial_time_ticks_now_function
now_function
std
:
:
memory_order_relaxed
)
;
g_time_ticks_now_ignoring_override_function
.
store
(
now_function
std
:
:
memory_order_relaxed
)
;
}
TimeTicks
InitialNowFunction
(
)
{
InitializeNowFunctionPointer
(
)
;
return
g_time_ticks_now_ignoring_override_function
.
load
(
std
:
:
memory_order_relaxed
)
(
)
;
}
}
TimeTicks
:
:
TickFunctionType
TimeTicks
:
:
SetMockTickFunction
(
TickFunctionType
ticker
)
{
TickFunctionType
old
=
g_tick_function
;
g_tick_function
=
ticker
;
g_last_time_and_rollovers
.
store
(
0
std
:
:
memory_order_relaxed
)
;
return
old
;
}
namespace
subtle
{
TimeTicks
TimeTicksNowIgnoringOverride
(
)
{
return
g_time_ticks_now_ignoring_override_function
.
load
(
std
:
:
memory_order_relaxed
)
(
)
;
}
}
bool
TimeTicks
:
:
IsHighResolution
(
)
{
if
(
g_time_ticks_now_ignoring_override_function
=
=
&
InitialNowFunction
)
InitializeNowFunctionPointer
(
)
;
return
g_time_ticks_now_ignoring_override_function
=
=
&
QPCNow
;
}
bool
TimeTicks
:
:
IsConsistentAcrossProcesses
(
)
{
return
IsHighResolution
(
)
;
}
TimeTicks
:
:
Clock
TimeTicks
:
:
GetClock
(
)
{
return
IsHighResolution
(
)
?
Clock
:
:
WIN_QPC
:
Clock
:
:
WIN_ROLLOVER_PROTECTED_TIME_GET_TIME
;
}
namespace
subtle
{
LiveTicks
LiveTicksNowIgnoringOverride
(
)
{
ULONGLONG
unbiased_interrupt_time
;
QueryUnbiasedInterruptTimePrecise
(
&
unbiased_interrupt_time
)
;
return
LiveTicks
(
)
+
Nanoseconds
(
unbiased_interrupt_time
*
100
)
;
}
}
namespace
subtle
{
ThreadTicks
ThreadTicksNowIgnoringOverride
(
)
{
return
ThreadTicks
:
:
GetForThread
(
PlatformThread
:
:
CurrentHandle
(
)
)
;
}
}
ThreadTicks
ThreadTicks
:
:
GetForThread
(
const
PlatformThreadHandle
&
thread_handle
)
{
DCHECK
(
IsSupported
(
)
)
;
#
if
defined
(
ARCH_CPU_ARM64
)
FILETIME
creation_time
exit_time
kernel_time
user_time
;
:
:
GetThreadTimes
(
thread_handle
.
platform_handle
(
)
&
creation_time
&
exit_time
&
kernel_time
&
user_time
)
;
const
int64_t
us
=
FileTimeToMicroseconds
(
user_time
)
;
#
else
ULONG64
thread_cycle_time
=
0
;
:
:
QueryThreadCycleTime
(
thread_handle
.
platform_handle
(
)
&
thread_cycle_time
)
;
const
double
tsc_ticks_per_second
=
time_internal
:
:
TSCTicksPerSecond
(
)
;
if
(
tsc_ticks_per_second
=
=
0
)
return
ThreadTicks
(
)
;
const
double
thread_time_seconds
=
thread_cycle_time
/
tsc_ticks_per_second
;
const
int64_t
us
=
static_cast
<
int64_t
>
(
thread_time_seconds
*
Time
:
:
kMicrosecondsPerSecond
)
;
#
endif
return
ThreadTicks
(
us
)
;
}
bool
ThreadTicks
:
:
IsSupportedWin
(
)
{
#
if
defined
(
ARCH_CPU_ARM64
)
return
true
;
#
else
return
time_internal
:
:
HasConstantRateTSC
(
)
;
#
endif
}
void
ThreadTicks
:
:
WaitUntilInitializedWin
(
)
{
#
if
!
defined
(
ARCH_CPU_ARM64
)
while
(
time_internal
:
:
TSCTicksPerSecond
(
)
=
=
0
)
:
:
Sleep
(
10
)
;
#
endif
}
TimeTicks
TimeTicks
:
:
FromQPCValue
(
LONGLONG
qpc_value
)
{
return
TimeTicks
(
)
+
QPCValueToTimeDelta
(
qpc_value
)
;
}
TimeDelta
TimeDelta
:
:
FromQPCValue
(
LONGLONG
qpc_value
)
{
return
QPCValueToTimeDelta
(
qpc_value
)
;
}
TimeDelta
TimeDelta
:
:
FromFileTime
(
FILETIME
ft
)
{
return
Microseconds
(
FileTimeToMicroseconds
(
ft
)
)
;
}
TimeDelta
TimeDelta
:
:
FromWinrtDateTime
(
ABI
:
:
Windows
:
:
Foundation
:
:
DateTime
dt
)
{
return
Microseconds
(
dt
.
UniversalTime
/
10
)
;
}
ABI
:
:
Windows
:
:
Foundation
:
:
DateTime
TimeDelta
:
:
ToWinrtDateTime
(
)
const
{
ABI
:
:
Windows
:
:
Foundation
:
:
DateTime
date_time
;
date_time
.
UniversalTime
=
InMicroseconds
(
)
*
10
;
return
date_time
;
}
TimeDelta
TimeDelta
:
:
FromWinrtTimeSpan
(
ABI
:
:
Windows
:
:
Foundation
:
:
TimeSpan
ts
)
{
return
Microseconds
(
ts
.
Duration
/
10
)
;
}
ABI
:
:
Windows
:
:
Foundation
:
:
TimeSpan
TimeDelta
:
:
ToWinrtTimeSpan
(
)
const
{
ABI
:
:
Windows
:
:
Foundation
:
:
TimeSpan
time_span
;
time_span
.
Duration
=
InMicroseconds
(
)
*
10
;
return
time_span
;
}
#
if
!
defined
(
ARCH_CPU_ARM64
)
namespace
time_internal
{
bool
HasConstantRateTSC
(
)
{
static
bool
is_supported
=
CPU
(
)
.
has_non_stop_time_stamp_counter
(
)
;
return
is_supported
;
}
double
TSCTicksPerSecond
(
)
{
DCHECK
(
HasConstantRateTSC
(
)
)
;
static
double
tsc_ticks_per_second
=
0
;
if
(
tsc_ticks_per_second
!
=
0
)
return
tsc_ticks_per_second
;
const
int
previous_priority
=
:
:
GetThreadPriority
(
:
:
GetCurrentThread
(
)
)
;
:
:
SetThreadPriority
(
:
:
GetCurrentThread
(
)
THREAD_PRIORITY_HIGHEST
)
;
static
const
uint64_t
tsc_initial
=
__rdtsc
(
)
;
static
const
int64_t
perf_counter_initial
=
QPCNowRaw
(
)
;
const
uint64_t
tsc_now
=
__rdtsc
(
)
;
const
int64_t
perf_counter_now
=
QPCNowRaw
(
)
;
:
:
SetThreadPriority
(
:
:
GetCurrentThread
(
)
previous_priority
)
;
LARGE_INTEGER
perf_counter_frequency
=
{
}
;
:
:
QueryPerformanceFrequency
(
&
perf_counter_frequency
)
;
DCHECK_GE
(
perf_counter_now
perf_counter_initial
)
;
const
int64_t
perf_counter_ticks
=
perf_counter_now
-
perf_counter_initial
;
const
double
elapsed_time_seconds
=
perf_counter_ticks
/
static_cast
<
double
>
(
perf_counter_frequency
.
QuadPart
)
;
constexpr
double
kMinimumEvaluationPeriodSeconds
=
0
.
05
;
if
(
elapsed_time_seconds
<
kMinimumEvaluationPeriodSeconds
)
return
0
;
DCHECK_GE
(
tsc_now
tsc_initial
)
;
const
uint64_t
tsc_ticks
=
tsc_now
-
tsc_initial
;
tsc_ticks_per_second
=
tsc_ticks
/
elapsed_time_seconds
;
return
tsc_ticks_per_second
;
}
}
#
endif
}
