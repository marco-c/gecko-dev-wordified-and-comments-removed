#
include
"
base
/
time
/
time
.
h
"
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
stdint
.
h
>
#
include
"
base
/
atomicops
.
h
"
#
include
"
base
/
bit_cast
.
h
"
#
include
"
base
/
cpu
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
include
"
base
/
threading
/
platform_thread
.
h
"
#
include
"
base
/
time
/
time_override
.
h
"
namespace
base
{
namespace
{
int64_t
FileTimeToMicroseconds
(
const
FILETIME
&
ft
)
{
return
bit_cast
<
int64_t
FILETIME
>
(
ft
)
/
10
;
}
void
MicrosecondsToFileTime
(
int64_t
us
FILETIME
*
ft
)
{
DCHECK_GE
(
us
0LL
)
<
<
"
Time
is
less
than
0
negative
values
are
not
"
"
representable
in
FILETIME
"
;
*
ft
=
bit_cast
<
FILETIME
int64_t
>
(
us
*
10
)
;
}
int64_t
CurrentWallclockMicroseconds
(
)
{
FILETIME
ft
;
:
:
GetSystemTimeAsFileTime
(
&
ft
)
;
return
FileTimeToMicroseconds
(
ft
)
;
}
constexpr
TimeDelta
kMaxTimeToAvoidDrift
=
TimeDelta
:
:
FromSeconds
(
60
)
;
int64_t
g_initial_time
=
0
;
TimeTicks
g_initial_ticks
;
void
InitializeClock
(
)
{
g_initial_ticks
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
;
g_initial_time
=
CurrentWallclockMicroseconds
(
)
;
}
const
int
kMinTimerIntervalHighResMs
=
1
;
const
int
kMinTimerIntervalLowResMs
=
4
;
bool
g_high_res_timer_enabled
=
false
;
uint32_t
g_high_res_timer_count
=
0
;
TimeTicks
g_high_res_timer_usage_start
;
TimeDelta
g_high_res_timer_usage
;
TimeTicks
g_high_res_timer_last_activation
;
Lock
*
GetHighResLock
(
)
{
static
auto
*
lock
=
new
Lock
(
)
;
return
lock
;
}
uint64_t
QPCNowRaw
(
)
{
LARGE_INTEGER
perf_counter_now
=
{
}
;
:
:
QueryPerformanceCounter
(
&
perf_counter_now
)
;
return
perf_counter_now
.
QuadPart
;
}
bool
SafeConvertToWord
(
int
in
WORD
*
out
)
{
CheckedNumeric
<
WORD
>
result
=
in
;
*
out
=
result
.
ValueOrDefault
(
std
:
:
numeric_limits
<
WORD
>
:
:
max
(
)
)
;
return
result
.
IsValid
(
)
;
}
}
namespace
subtle
{
Time
TimeNowIgnoringOverride
(
)
{
if
(
g_initial_time
=
=
0
)
InitializeClock
(
)
;
while
(
true
)
{
TimeTicks
ticks
=
TimeTicksNowIgnoringOverride
(
)
;
TimeDelta
elapsed
=
ticks
-
g_initial_ticks
;
if
(
elapsed
>
kMaxTimeToAvoidDrift
)
{
InitializeClock
(
)
;
continue
;
}
return
Time
(
)
+
elapsed
+
TimeDelta
:
:
FromMicroseconds
(
g_initial_time
)
;
}
}
Time
TimeNowFromSystemTimeIgnoringOverride
(
)
{
InitializeClock
(
)
;
return
Time
(
)
+
TimeDelta
:
:
FromMicroseconds
(
g_initial_time
)
;
}
}
Time
Time
:
:
FromFileTime
(
FILETIME
ft
)
{
if
(
bit_cast
<
int64_t
FILETIME
>
(
ft
)
=
=
0
)
return
Time
(
)
;
if
(
ft
.
dwHighDateTime
=
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
&
&
ft
.
dwLowDateTime
=
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
)
return
Max
(
)
;
return
Time
(
FileTimeToMicroseconds
(
ft
)
)
;
}
FILETIME
Time
:
:
ToFileTime
(
)
const
{
if
(
is_null
(
)
)
return
bit_cast
<
FILETIME
int64_t
>
(
0
)
;
if
(
is_max
(
)
)
{
FILETIME
result
;
result
.
dwHighDateTime
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
;
result
.
dwLowDateTime
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
;
return
result
;
}
FILETIME
utc_ft
;
MicrosecondsToFileTime
(
us_
&
utc_ft
)
;
return
utc_ft
;
}
void
Time
:
:
EnableHighResolutionTimer
(
bool
enable
)
{
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
if
(
g_high_res_timer_enabled
=
=
enable
)
return
;
g_high_res_timer_enabled
=
enable
;
if
(
!
g_high_res_timer_count
)
return
;
if
(
enable
)
{
timeEndPeriod
(
kMinTimerIntervalLowResMs
)
;
timeBeginPeriod
(
kMinTimerIntervalHighResMs
)
;
}
else
{
timeEndPeriod
(
kMinTimerIntervalHighResMs
)
;
timeBeginPeriod
(
kMinTimerIntervalLowResMs
)
;
}
}
bool
Time
:
:
ActivateHighResolutionTimer
(
bool
activating
)
{
const
uint32_t
max
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
UINT
period
=
g_high_res_timer_enabled
?
kMinTimerIntervalHighResMs
:
kMinTimerIntervalLowResMs
;
if
(
activating
)
{
DCHECK_NE
(
g_high_res_timer_count
max
)
;
+
+
g_high_res_timer_count
;
if
(
g_high_res_timer_count
=
=
1
)
{
g_high_res_timer_last_activation
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
;
timeBeginPeriod
(
period
)
;
}
}
else
{
DCHECK_NE
(
g_high_res_timer_count
0u
)
;
-
-
g_high_res_timer_count
;
if
(
g_high_res_timer_count
=
=
0
)
{
g_high_res_timer_usage
+
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
-
g_high_res_timer_last_activation
;
timeEndPeriod
(
period
)
;
}
}
return
(
period
=
=
kMinTimerIntervalHighResMs
)
;
}
bool
Time
:
:
IsHighResolutionTimerInUse
(
)
{
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
return
g_high_res_timer_enabled
&
&
g_high_res_timer_count
>
0
;
}
void
Time
:
:
ResetHighResolutionTimerUsage
(
)
{
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
g_high_res_timer_usage
=
TimeDelta
(
)
;
g_high_res_timer_usage_start
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
;
if
(
g_high_res_timer_count
>
0
)
g_high_res_timer_last_activation
=
g_high_res_timer_usage_start
;
}
double
Time
:
:
GetHighResolutionTimerUsage
(
)
{
AutoLock
lock
(
*
GetHighResLock
(
)
)
;
TimeTicks
now
=
subtle
:
:
TimeTicksNowIgnoringOverride
(
)
;
TimeDelta
elapsed_time
=
now
-
g_high_res_timer_usage_start
;
if
(
elapsed_time
.
is_zero
(
)
)
{
return
0
.
0
;
}
TimeDelta
used_time
=
g_high_res_timer_usage
;
if
(
g_high_res_timer_count
>
0
)
{
used_time
+
=
now
-
g_high_res_timer_last_activation
;
}
return
used_time
.
InMillisecondsF
(
)
/
elapsed_time
.
InMillisecondsF
(
)
*
100
;
}
bool
Time
:
:
FromExploded
(
bool
is_local
const
Exploded
&
exploded
Time
*
time
)
{
SYSTEMTIME
st
;
if
(
!
SafeConvertToWord
(
exploded
.
year
&
st
.
wYear
)
|
|
!
SafeConvertToWord
(
exploded
.
month
&
st
.
wMonth
)
|
|
!
SafeConvertToWord
(
exploded
.
day_of_week
&
st
.
wDayOfWeek
)
|
|
!
SafeConvertToWord
(
exploded
.
day_of_month
&
st
.
wDay
)
|
|
!
SafeConvertToWord
(
exploded
.
hour
&
st
.
wHour
)
|
|
!
SafeConvertToWord
(
exploded
.
minute
&
st
.
wMinute
)
|
|
!
SafeConvertToWord
(
exploded
.
second
&
st
.
wSecond
)
|
|
!
SafeConvertToWord
(
exploded
.
millisecond
&
st
.
wMilliseconds
)
)
{
*
time
=
Time
(
0
)
;
return
false
;
}
FILETIME
ft
;
bool
success
=
true
;
if
(
is_local
)
{
SYSTEMTIME
utc_st
;
success
=
TzSpecificLocalTimeToSystemTime
(
nullptr
&
st
&
utc_st
)
&
&
SystemTimeToFileTime
(
&
utc_st
&
ft
)
;
}
else
{
success
=
!
!
SystemTimeToFileTime
(
&
st
&
ft
)
;
}
if
(
!
success
)
{
*
time
=
Time
(
0
)
;
return
false
;
}
*
time
=
Time
(
FileTimeToMicroseconds
(
ft
)
)
;
return
true
;
}
void
Time
:
:
Explode
(
bool
is_local
Exploded
*
exploded
)
const
{
if
(
us_
<
0LL
)
{
ZeroMemory
(
exploded
sizeof
(
*
exploded
)
)
;
return
;
}
FILETIME
utc_ft
;
MicrosecondsToFileTime
(
us_
&
utc_ft
)
;
bool
success
=
true
;
SYSTEMTIME
st
=
{
0
}
;
if
(
is_local
)
{
SYSTEMTIME
utc_st
;
success
=
FileTimeToSystemTime
(
&
utc_ft
&
utc_st
)
&
&
SystemTimeToTzSpecificLocalTime
(
nullptr
&
utc_st
&
st
)
;
}
else
{
success
=
!
!
FileTimeToSystemTime
(
&
utc_ft
&
st
)
;
}
if
(
!
success
)
{
NOTREACHED
(
)
<
<
"
Unable
to
convert
time
don
'
t
know
why
"
;
ZeroMemory
(
exploded
sizeof
(
*
exploded
)
)
;
return
;
}
exploded
-
>
year
=
st
.
wYear
;
exploded
-
>
month
=
st
.
wMonth
;
exploded
-
>
day_of_week
=
st
.
wDayOfWeek
;
exploded
-
>
day_of_month
=
st
.
wDay
;
exploded
-
>
hour
=
st
.
wHour
;
exploded
-
>
minute
=
st
.
wMinute
;
exploded
-
>
second
=
st
.
wSecond
;
exploded
-
>
millisecond
=
st
.
wMilliseconds
;
}
namespace
{
DWORD
timeGetTimeWrapper
(
)
{
return
timeGetTime
(
)
;
}
DWORD
(
*
g_tick_function
)
(
void
)
=
&
timeGetTimeWrapper
;
union
LastTimeAndRolloversState
{
subtle
:
:
Atomic32
as_opaque_32
;
struct
{
uint8_t
last_8
;
uint16_t
rollovers
;
}
as_values
;
}
;
subtle
:
:
Atomic32
g_last_time_and_rollovers
=
0
;
static_assert
(
sizeof
(
LastTimeAndRolloversState
)
<
=
sizeof
(
g_last_time_and_rollovers
)
"
LastTimeAndRolloversState
does
not
fit
in
a
single
atomic
word
"
)
;
TimeTicks
RolloverProtectedNow
(
)
{
LastTimeAndRolloversState
state
;
DWORD
now
;
while
(
true
)
{
int32_t
original
=
subtle
:
:
Acquire_Load
(
&
g_last_time_and_rollovers
)
;
state
.
as_opaque_32
=
original
;
now
=
g_tick_function
(
)
;
uint8_t
now_8
=
static_cast
<
uint8_t
>
(
now
>
>
24
)
;
if
(
now_8
<
state
.
as_values
.
last_8
)
+
+
state
.
as_values
.
rollovers
;
state
.
as_values
.
last_8
=
now_8
;
if
(
state
.
as_opaque_32
=
=
original
)
break
;
int32_t
check
=
subtle
:
:
Release_CompareAndSwap
(
&
g_last_time_and_rollovers
original
state
.
as_opaque_32
)
;
if
(
check
=
=
original
)
break
;
}
return
TimeTicks
(
)
+
TimeDelta
:
:
FromMilliseconds
(
now
+
(
static_cast
<
uint64_t
>
(
state
.
as_values
.
rollovers
)
<
<
32
)
)
;
}
TimeTicks
InitialNowFunction
(
)
;
TimeTicksNowFunction
g_time_ticks_now_ignoring_override_function
=
&
InitialNowFunction
;
int64_t
g_qpc_ticks_per_second
=
0
;
#
define
ATOMIC_THREAD_FENCE
(
memory_order
)
_ReadWriteBarrier
(
)
;
TimeDelta
QPCValueToTimeDelta
(
LONGLONG
qpc_value
)
{
ATOMIC_THREAD_FENCE
(
memory_order_acquire
)
;
DCHECK_GT
(
g_qpc_ticks_per_second
0
)
;
if
(
qpc_value
<
Time
:
:
kQPCOverflowThreshold
)
{
return
TimeDelta
:
:
FromMicroseconds
(
qpc_value
*
Time
:
:
kMicrosecondsPerSecond
/
g_qpc_ticks_per_second
)
;
}
int64_t
whole_seconds
=
qpc_value
/
g_qpc_ticks_per_second
;
int64_t
leftover_ticks
=
qpc_value
-
(
whole_seconds
*
g_qpc_ticks_per_second
)
;
return
TimeDelta
:
:
FromMicroseconds
(
(
whole_seconds
*
Time
:
:
kMicrosecondsPerSecond
)
+
(
(
leftover_ticks
*
Time
:
:
kMicrosecondsPerSecond
)
/
g_qpc_ticks_per_second
)
)
;
}
TimeTicks
QPCNow
(
)
{
return
TimeTicks
(
)
+
QPCValueToTimeDelta
(
QPCNowRaw
(
)
)
;
}
void
InitializeNowFunctionPointer
(
)
{
LARGE_INTEGER
ticks_per_sec
=
{
}
;
if
(
!
QueryPerformanceFrequency
(
&
ticks_per_sec
)
)
ticks_per_sec
.
QuadPart
=
0
;
TimeTicksNowFunction
now_function
;
CPU
cpu
;
if
(
ticks_per_sec
.
QuadPart
<
=
0
|
|
!
cpu
.
has_non_stop_time_stamp_counter
(
)
)
{
now_function
=
&
RolloverProtectedNow
;
}
else
{
now_function
=
&
QPCNow
;
}
g_qpc_ticks_per_second
=
ticks_per_sec
.
QuadPart
;
ATOMIC_THREAD_FENCE
(
memory_order_release
)
;
if
(
internal
:
:
g_time_ticks_now_function
=
=
&
subtle
:
:
TimeTicksNowIgnoringOverride
)
{
internal
:
:
g_time_ticks_now_function
=
now_function
;
}
g_time_ticks_now_ignoring_override_function
=
now_function
;
}
TimeTicks
InitialNowFunction
(
)
{
InitializeNowFunctionPointer
(
)
;
return
g_time_ticks_now_ignoring_override_function
(
)
;
}
}
TimeTicks
:
:
TickFunctionType
TimeTicks
:
:
SetMockTickFunction
(
TickFunctionType
ticker
)
{
TickFunctionType
old
=
g_tick_function
;
g_tick_function
=
ticker
;
subtle
:
:
NoBarrier_Store
(
&
g_last_time_and_rollovers
0
)
;
return
old
;
}
namespace
subtle
{
TimeTicks
TimeTicksNowIgnoringOverride
(
)
{
return
g_time_ticks_now_ignoring_override_function
(
)
;
}
}
bool
TimeTicks
:
:
IsHighResolution
(
)
{
if
(
g_time_ticks_now_ignoring_override_function
=
=
&
InitialNowFunction
)
InitializeNowFunctionPointer
(
)
;
return
g_time_ticks_now_ignoring_override_function
=
=
&
QPCNow
;
}
bool
TimeTicks
:
:
IsConsistentAcrossProcesses
(
)
{
return
IsHighResolution
(
)
;
}
TimeTicks
:
:
Clock
TimeTicks
:
:
GetClock
(
)
{
return
IsHighResolution
(
)
?
Clock
:
:
WIN_QPC
:
Clock
:
:
WIN_ROLLOVER_PROTECTED_TIME_GET_TIME
;
}
namespace
subtle
{
ThreadTicks
ThreadTicksNowIgnoringOverride
(
)
{
return
ThreadTicks
:
:
GetForThread
(
PlatformThread
:
:
CurrentHandle
(
)
)
;
}
}
ThreadTicks
ThreadTicks
:
:
GetForThread
(
const
PlatformThreadHandle
&
thread_handle
)
{
DCHECK
(
IsSupported
(
)
)
;
ULONG64
thread_cycle_time
=
0
;
:
:
QueryThreadCycleTime
(
thread_handle
.
platform_handle
(
)
&
thread_cycle_time
)
;
double
tsc_ticks_per_second
=
TSCTicksPerSecond
(
)
;
if
(
tsc_ticks_per_second
=
=
0
)
return
ThreadTicks
(
)
;
double
thread_time_seconds
=
thread_cycle_time
/
tsc_ticks_per_second
;
return
ThreadTicks
(
static_cast
<
int64_t
>
(
thread_time_seconds
*
Time
:
:
kMicrosecondsPerSecond
)
)
;
}
bool
ThreadTicks
:
:
IsSupportedWin
(
)
{
static
bool
is_supported
=
CPU
(
)
.
has_non_stop_time_stamp_counter
(
)
;
return
is_supported
;
}
void
ThreadTicks
:
:
WaitUntilInitializedWin
(
)
{
while
(
TSCTicksPerSecond
(
)
=
=
0
)
:
:
Sleep
(
10
)
;
}
#
if
defined
(
_M_ARM64
)
&
&
defined
(
__clang__
)
#
define
ReadCycleCounter
(
)
_ReadStatusReg
(
ARM64_PMCCNTR_EL0
)
#
else
#
define
ReadCycleCounter
(
)
__rdtsc
(
)
#
endif
double
ThreadTicks
:
:
TSCTicksPerSecond
(
)
{
DCHECK
(
IsSupported
(
)
)
;
static
double
tsc_ticks_per_second
=
0
;
if
(
tsc_ticks_per_second
!
=
0
)
return
tsc_ticks_per_second
;
int
previous_priority
=
:
:
GetThreadPriority
(
:
:
GetCurrentThread
(
)
)
;
:
:
SetThreadPriority
(
:
:
GetCurrentThread
(
)
THREAD_PRIORITY_HIGHEST
)
;
static
const
uint64_t
tsc_initial
=
ReadCycleCounter
(
)
;
static
const
uint64_t
perf_counter_initial
=
QPCNowRaw
(
)
;
uint64_t
tsc_now
=
ReadCycleCounter
(
)
;
uint64_t
perf_counter_now
=
QPCNowRaw
(
)
;
:
:
SetThreadPriority
(
:
:
GetCurrentThread
(
)
previous_priority
)
;
LARGE_INTEGER
perf_counter_frequency
=
{
}
;
:
:
QueryPerformanceFrequency
(
&
perf_counter_frequency
)
;
DCHECK_GE
(
perf_counter_now
perf_counter_initial
)
;
uint64_t
perf_counter_ticks
=
perf_counter_now
-
perf_counter_initial
;
double
elapsed_time_seconds
=
perf_counter_ticks
/
static_cast
<
double
>
(
perf_counter_frequency
.
QuadPart
)
;
static
constexpr
double
kMinimumEvaluationPeriodSeconds
=
0
.
05
;
if
(
elapsed_time_seconds
<
kMinimumEvaluationPeriodSeconds
)
return
0
;
DCHECK_GE
(
tsc_now
tsc_initial
)
;
uint64_t
tsc_ticks
=
tsc_now
-
tsc_initial
;
tsc_ticks_per_second
=
tsc_ticks
/
elapsed_time_seconds
;
return
tsc_ticks_per_second
;
}
#
undef
ReadCycleCounter
TimeTicks
TimeTicks
:
:
FromQPCValue
(
LONGLONG
qpc_value
)
{
return
TimeTicks
(
)
+
QPCValueToTimeDelta
(
qpc_value
)
;
}
TimeDelta
TimeDelta
:
:
FromQPCValue
(
LONGLONG
qpc_value
)
{
return
QPCValueToTimeDelta
(
qpc_value
)
;
}
TimeDelta
TimeDelta
:
:
FromFileTime
(
FILETIME
ft
)
{
return
TimeDelta
:
:
FromMicroseconds
(
FileTimeToMicroseconds
(
ft
)
)
;
}
}
