#
ifndef
BASE_TIME_TIME_H_
#
define
BASE_TIME_TIME_H_
#
include
<
stdint
.
h
>
#
include
<
time
.
h
>
#
include
<
iosfwd
>
#
include
<
limits
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
check
.
h
"
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
numerics
/
clamped_math
.
h
"
#
include
"
build
/
build_config
.
h
"
#
include
"
build
/
chromeos_buildflags
.
h
"
#
if
BUILDFLAG
(
IS_FUCHSIA
)
#
include
<
zircon
/
types
.
h
>
#
endif
#
if
BUILDFLAG
(
IS_APPLE
)
#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
include
<
mach
/
mach_time
.
h
>
#
undef
TYPE_BOOL
#
endif
#
if
BUILDFLAG
(
IS_ANDROID
)
#
include
<
jni
.
h
>
#
endif
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
#
include
<
unistd
.
h
>
#
include
<
sys
/
time
.
h
>
#
endif
#
if
BUILDFLAG
(
IS_WIN
)
#
include
"
base
/
gtest_prod_util
.
h
"
#
include
"
base
/
win
/
windows_types
.
h
"
namespace
ABI
{
namespace
Windows
{
namespace
Foundation
{
struct
DateTime
;
struct
TimeSpan
;
}
}
}
#
endif
namespace
base
{
class
PlatformThreadHandle
;
class
TimeDelta
;
template
<
typename
T
>
constexpr
TimeDelta
Microseconds
(
T
n
)
;
namespace
{
constexpr
bool
isnan
(
double
d
)
{
return
d
!
=
d
;
}
}
class
BASE_EXPORT
TimeDelta
{
public
:
constexpr
TimeDelta
(
)
=
default
;
#
if
BUILDFLAG
(
IS_WIN
)
static
TimeDelta
FromQPCValue
(
LONGLONG
qpc_value
)
;
static
TimeDelta
FromFileTime
(
FILETIME
ft
)
;
static
TimeDelta
FromWinrtDateTime
(
ABI
:
:
Windows
:
:
Foundation
:
:
DateTime
dt
)
;
static
TimeDelta
FromWinrtTimeSpan
(
ABI
:
:
Windows
:
:
Foundation
:
:
TimeSpan
ts
)
;
#
elif
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
static
TimeDelta
FromTimeSpec
(
const
timespec
&
ts
)
;
#
endif
#
if
BUILDFLAG
(
IS_FUCHSIA
)
static
TimeDelta
FromZxDuration
(
zx_duration_t
nanos
)
;
#
endif
#
if
BUILDFLAG
(
IS_APPLE
)
static
TimeDelta
FromMachTime
(
uint64_t
mach_time
)
;
#
endif
static
constexpr
TimeDelta
FromInternalValue
(
int64_t
delta
)
{
return
TimeDelta
(
delta
)
;
}
static
constexpr
TimeDelta
Max
(
)
;
static
constexpr
TimeDelta
Min
(
)
;
static
constexpr
TimeDelta
FiniteMax
(
)
;
static
constexpr
TimeDelta
FiniteMin
(
)
;
constexpr
int64_t
ToInternalValue
(
)
const
{
return
delta_
;
}
constexpr
TimeDelta
magnitude
(
)
const
{
return
TimeDelta
(
delta_
.
Abs
(
)
)
;
}
constexpr
bool
is_zero
(
)
const
{
return
delta_
=
=
0
;
}
constexpr
bool
is_positive
(
)
const
{
return
delta_
>
0
;
}
constexpr
bool
is_negative
(
)
const
{
return
delta_
<
0
;
}
constexpr
bool
is_max
(
)
const
{
return
*
this
=
=
Max
(
)
;
}
constexpr
bool
is_min
(
)
const
{
return
*
this
=
=
Min
(
)
;
}
constexpr
bool
is_inf
(
)
const
{
return
is_min
(
)
|
|
is_max
(
)
;
}
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
struct
timespec
ToTimeSpec
(
)
const
;
#
endif
#
if
BUILDFLAG
(
IS_FUCHSIA
)
zx_duration_t
ToZxDuration
(
)
const
;
#
endif
#
if
BUILDFLAG
(
IS_WIN
)
ABI
:
:
Windows
:
:
Foundation
:
:
DateTime
ToWinrtDateTime
(
)
const
;
ABI
:
:
Windows
:
:
Foundation
:
:
TimeSpan
ToWinrtTimeSpan
(
)
const
;
#
endif
constexpr
double
ToHz
(
)
const
;
constexpr
int
InDays
(
)
const
;
constexpr
int
InDaysFloored
(
)
const
;
constexpr
int
InHours
(
)
const
;
constexpr
int
InMinutes
(
)
const
;
constexpr
double
InSecondsF
(
)
const
;
constexpr
int64_t
InSeconds
(
)
const
;
constexpr
int64_t
InSecondsFloored
(
)
const
;
constexpr
double
InMillisecondsF
(
)
const
;
constexpr
int64_t
InMilliseconds
(
)
const
;
constexpr
int64_t
InMillisecondsRoundedUp
(
)
const
;
constexpr
int64_t
InMicroseconds
(
)
const
{
return
delta_
;
}
constexpr
double
InMicrosecondsF
(
)
const
;
constexpr
int64_t
InNanoseconds
(
)
const
;
constexpr
TimeDelta
operator
+
(
TimeDelta
other
)
const
;
constexpr
TimeDelta
operator
-
(
TimeDelta
other
)
const
;
constexpr
TimeDelta
&
operator
+
=
(
TimeDelta
other
)
{
return
*
this
=
(
*
this
+
other
)
;
}
constexpr
TimeDelta
&
operator
-
=
(
TimeDelta
other
)
{
return
*
this
=
(
*
this
-
other
)
;
}
constexpr
TimeDelta
operator
-
(
)
const
{
if
(
!
is_inf
(
)
)
return
TimeDelta
(
-
delta_
)
;
return
(
delta_
<
0
)
?
Max
(
)
:
Min
(
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
operator
*
(
T
a
)
const
{
return
TimeDelta
(
int64_t
{
delta_
*
a
}
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
operator
/
(
T
a
)
const
{
return
TimeDelta
(
int64_t
{
delta_
/
a
}
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
&
operator
*
=
(
T
a
)
{
return
*
this
=
(
*
this
*
a
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
&
operator
/
=
(
T
a
)
{
return
*
this
=
(
*
this
/
a
)
;
}
constexpr
double
operator
/
(
TimeDelta
a
)
const
{
CHECK
(
!
is_zero
(
)
|
|
!
a
.
is_zero
(
)
)
;
CHECK
(
!
is_inf
(
)
|
|
!
a
.
is_inf
(
)
)
;
return
ToDouble
(
)
/
a
.
ToDouble
(
)
;
}
constexpr
int64_t
IntDiv
(
TimeDelta
a
)
const
{
if
(
!
is_inf
(
)
&
&
!
a
.
is_zero
(
)
)
return
int64_t
{
delta_
/
a
.
delta_
}
;
CHECK
(
!
is_zero
(
)
|
|
!
a
.
is_zero
(
)
)
;
CHECK
(
!
is_inf
(
)
|
|
!
a
.
is_inf
(
)
)
;
return
(
(
delta_
<
0
)
=
=
(
a
.
delta_
<
0
)
)
?
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
:
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
;
}
constexpr
TimeDelta
operator
%
(
TimeDelta
a
)
const
{
return
TimeDelta
(
(
is_inf
(
)
|
|
a
.
is_zero
(
)
|
|
a
.
is_inf
(
)
)
?
delta_
:
(
delta_
%
a
.
delta_
)
)
;
}
constexpr
TimeDelta
&
operator
%
=
(
TimeDelta
other
)
{
return
*
this
=
(
*
this
%
other
)
;
}
constexpr
bool
operator
=
=
(
TimeDelta
other
)
const
{
return
delta_
=
=
other
.
delta_
;
}
constexpr
bool
operator
!
=
(
TimeDelta
other
)
const
{
return
delta_
!
=
other
.
delta_
;
}
constexpr
bool
operator
<
(
TimeDelta
other
)
const
{
return
delta_
<
other
.
delta_
;
}
constexpr
bool
operator
<
=
(
TimeDelta
other
)
const
{
return
delta_
<
=
other
.
delta_
;
}
constexpr
bool
operator
>
(
TimeDelta
other
)
const
{
return
delta_
>
other
.
delta_
;
}
constexpr
bool
operator
>
=
(
TimeDelta
other
)
const
{
return
delta_
>
=
other
.
delta_
;
}
TimeDelta
CeilToMultiple
(
TimeDelta
interval
)
const
;
TimeDelta
FloorToMultiple
(
TimeDelta
interval
)
const
;
TimeDelta
RoundToMultiple
(
TimeDelta
interval
)
const
;
private
:
constexpr
explicit
TimeDelta
(
int64_t
delta_us
)
:
delta_
(
delta_us
)
{
}
constexpr
explicit
TimeDelta
(
ClampedNumeric
<
int64_t
>
delta_us
)
:
delta_
(
delta_us
)
{
}
constexpr
double
ToDouble
(
)
const
{
if
(
!
is_inf
(
)
)
return
static_cast
<
double
>
(
delta_
)
;
return
(
delta_
<
0
)
?
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
:
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
ClampedNumeric
<
int64_t
>
delta_
=
0
;
}
;
constexpr
TimeDelta
TimeDelta
:
:
operator
+
(
TimeDelta
other
)
const
{
if
(
!
other
.
is_inf
(
)
)
return
TimeDelta
(
delta_
+
other
.
delta_
)
;
CHECK
(
!
is_inf
(
)
|
|
(
delta_
=
=
other
.
delta_
)
)
;
return
other
;
}
constexpr
TimeDelta
TimeDelta
:
:
operator
-
(
TimeDelta
other
)
const
{
if
(
!
other
.
is_inf
(
)
)
return
TimeDelta
(
delta_
-
other
.
delta_
)
;
CHECK_NE
(
int64_t
{
delta_
}
int64_t
{
other
.
delta_
}
)
;
return
(
other
.
delta_
<
0
)
?
Max
(
)
:
Min
(
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
operator
*
(
T
a
TimeDelta
td
)
{
return
td
*
a
;
}
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
TimeDelta
time_delta
)
;
namespace
time_internal
{
template
<
class
TimeClass
>
class
TimeBase
{
public
:
static
constexpr
int64_t
kHoursPerDay
=
24
;
static
constexpr
int64_t
kSecondsPerMinute
=
60
;
static
constexpr
int64_t
kMinutesPerHour
=
60
;
static
constexpr
int64_t
kSecondsPerHour
=
kSecondsPerMinute
*
kMinutesPerHour
;
static
constexpr
int64_t
kMillisecondsPerSecond
=
1000
;
static
constexpr
int64_t
kMillisecondsPerDay
=
kMillisecondsPerSecond
*
kSecondsPerHour
*
kHoursPerDay
;
static
constexpr
int64_t
kMicrosecondsPerMillisecond
=
1000
;
static
constexpr
int64_t
kMicrosecondsPerSecond
=
kMicrosecondsPerMillisecond
*
kMillisecondsPerSecond
;
static
constexpr
int64_t
kMicrosecondsPerMinute
=
kMicrosecondsPerSecond
*
kSecondsPerMinute
;
static
constexpr
int64_t
kMicrosecondsPerHour
=
kMicrosecondsPerMinute
*
kMinutesPerHour
;
static
constexpr
int64_t
kMicrosecondsPerDay
=
kMicrosecondsPerHour
*
kHoursPerDay
;
static
constexpr
int64_t
kMicrosecondsPerWeek
=
kMicrosecondsPerDay
*
7
;
static
constexpr
int64_t
kNanosecondsPerMicrosecond
=
1000
;
static
constexpr
int64_t
kNanosecondsPerSecond
=
kNanosecondsPerMicrosecond
*
kMicrosecondsPerSecond
;
constexpr
bool
is_null
(
)
const
{
return
us_
=
=
0
;
}
constexpr
bool
is_max
(
)
const
{
return
*
this
=
=
Max
(
)
;
}
constexpr
bool
is_min
(
)
const
{
return
*
this
=
=
Min
(
)
;
}
constexpr
bool
is_inf
(
)
const
{
return
is_min
(
)
|
|
is_max
(
)
;
}
static
constexpr
TimeClass
Max
(
)
{
return
TimeClass
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
;
}
static
constexpr
TimeClass
Min
(
)
{
return
TimeClass
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
)
;
}
constexpr
int64_t
ToInternalValue
(
)
const
{
return
us_
;
}
constexpr
TimeDelta
since_origin
(
)
const
;
#
if
!
defined
(
__aarch64__
)
&
&
BUILDFLAG
(
IS_ANDROID
)
NOINLINE
#
endif
constexpr
TimeDelta
operator
-
(
const
TimeBase
<
TimeClass
>
&
other
)
const
;
constexpr
TimeClass
operator
+
(
TimeDelta
delta
)
const
;
constexpr
TimeClass
operator
-
(
TimeDelta
delta
)
const
;
constexpr
TimeClass
&
operator
+
=
(
TimeDelta
delta
)
{
return
static_cast
<
TimeClass
&
>
(
*
this
=
(
*
this
+
delta
)
)
;
}
constexpr
TimeClass
&
operator
-
=
(
TimeDelta
delta
)
{
return
static_cast
<
TimeClass
&
>
(
*
this
=
(
*
this
-
delta
)
)
;
}
constexpr
bool
operator
=
=
(
const
TimeBase
<
TimeClass
>
&
other
)
const
{
return
us_
=
=
other
.
us_
;
}
constexpr
bool
operator
!
=
(
const
TimeBase
<
TimeClass
>
&
other
)
const
{
return
us_
!
=
other
.
us_
;
}
constexpr
bool
operator
<
(
const
TimeBase
<
TimeClass
>
&
other
)
const
{
return
us_
<
other
.
us_
;
}
constexpr
bool
operator
<
=
(
const
TimeBase
<
TimeClass
>
&
other
)
const
{
return
us_
<
=
other
.
us_
;
}
constexpr
bool
operator
>
(
const
TimeBase
<
TimeClass
>
&
other
)
const
{
return
us_
>
other
.
us_
;
}
constexpr
bool
operator
>
=
(
const
TimeBase
<
TimeClass
>
&
other
)
const
{
return
us_
>
=
other
.
us_
;
}
protected
:
constexpr
explicit
TimeBase
(
int64_t
us
)
:
us_
(
us
)
{
}
ClampedNumeric
<
int64_t
>
us_
;
}
;
#
if
BUILDFLAG
(
IS_WIN
)
#
if
defined
(
ARCH_CPU_ARM64
)
#
else
[
[
nodiscard
]
]
BASE_EXPORT
bool
HasConstantRateTSC
(
)
;
[
[
nodiscard
]
]
BASE_EXPORT
double
TSCTicksPerSecond
(
)
;
#
endif
#
endif
}
template
<
class
TimeClass
>
inline
constexpr
TimeClass
operator
+
(
TimeDelta
delta
TimeClass
t
)
{
return
t
+
delta
;
}
class
BASE_EXPORT
Time
:
public
time_internal
:
:
TimeBase
<
Time
>
{
public
:
static
constexpr
int64_t
kTimeTToMicrosecondsOffset
=
INT64_C
(
11644473600000000
)
;
#
if
BUILDFLAG
(
IS_WIN
)
static
constexpr
int64_t
kQPCOverflowThreshold
=
INT64_C
(
0x8637BD05AF7
)
;
#
endif
#
if
BUILDFLAG
(
IS_WIN
)
static
constexpr
int
kExplodedMinYear
=
1601
;
static
constexpr
int
kExplodedMaxYear
=
30827
;
#
elif
BUILDFLAG
(
IS_IOS
)
&
&
!
__LP64__
static
constexpr
int
kExplodedMinYear
=
std
:
:
numeric_limits
<
int
>
:
:
min
(
)
;
static
constexpr
int
kExplodedMaxYear
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
#
elif
BUILDFLAG
(
IS_APPLE
)
static
constexpr
int
kExplodedMinYear
=
1902
;
static
constexpr
int
kExplodedMaxYear
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
#
elif
BUILDFLAG
(
IS_ANDROID
)
static
constexpr
int
kExplodedMinYear
=
1902
;
static
constexpr
int
kExplodedMaxYear
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
#
else
static
constexpr
int
kExplodedMinYear
=
(
sizeof
(
time_t
)
=
=
4
?
1902
:
std
:
:
numeric_limits
<
int
>
:
:
min
(
)
)
;
static
constexpr
int
kExplodedMaxYear
=
(
sizeof
(
time_t
)
=
=
4
?
2037
:
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
;
#
endif
struct
BASE_EXPORT
Exploded
{
int
year
;
int
month
;
int
day_of_week
;
int
day_of_month
;
int
hour
;
int
minute
;
int
second
;
int
millisecond
;
bool
HasValidValues
(
)
const
;
}
;
constexpr
Time
(
)
:
TimeBase
(
0
)
{
}
static
constexpr
Time
UnixEpoch
(
)
{
return
Time
(
kTimeTToMicrosecondsOffset
)
;
}
static
Time
Now
(
)
;
static
Time
NowFromSystemTime
(
)
;
static
constexpr
Time
FromDeltaSinceWindowsEpoch
(
TimeDelta
delta
)
{
return
Time
(
delta
.
InMicroseconds
(
)
)
;
}
constexpr
TimeDelta
ToDeltaSinceWindowsEpoch
(
)
const
{
return
Microseconds
(
us_
)
;
}
static
constexpr
Time
FromTimeT
(
time_t
tt
)
;
constexpr
time_t
ToTimeT
(
)
const
;
static
constexpr
Time
FromSecondsSinceUnixEpoch
(
double
dt
)
;
constexpr
double
InSecondsFSinceUnixEpoch
(
)
const
;
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
static
constexpr
Time
FromTimeSpec
(
const
timespec
&
ts
)
;
#
endif
static
constexpr
Time
FromMillisecondsSinceUnixEpoch
(
int64_t
dt
)
;
static
constexpr
Time
FromMillisecondsSinceUnixEpoch
(
double
dt
)
;
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
&
&
!
std
:
:
is_same_v
<
T
int64_t
>
&
&
(
sizeof
(
T
)
<
sizeof
(
int64_t
)
|
|
(
sizeof
(
T
)
=
=
sizeof
(
int64_t
)
&
&
std
:
:
is_signed_v
<
T
>
)
)
>
>
static
constexpr
Time
FromMillisecondsSinceUnixEpoch
(
T
ms_since_epoch
)
{
return
FromMillisecondsSinceUnixEpoch
(
int64_t
{
ms_since_epoch
}
)
;
}
constexpr
int64_t
InMillisecondsSinceUnixEpoch
(
)
const
;
constexpr
double
InMillisecondsFSinceUnixEpoch
(
)
const
;
constexpr
double
InMillisecondsFSinceUnixEpochIgnoringNull
(
)
const
;
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
static
Time
FromTimeVal
(
struct
timeval
t
)
;
struct
timeval
ToTimeVal
(
)
const
;
#
endif
#
if
BUILDFLAG
(
IS_FUCHSIA
)
static
Time
FromZxTime
(
zx_time_t
time
)
;
zx_time_t
ToZxTime
(
)
const
;
#
endif
#
if
BUILDFLAG
(
IS_APPLE
)
static
Time
FromCFAbsoluteTime
(
CFAbsoluteTime
t
)
;
CFAbsoluteTime
ToCFAbsoluteTime
(
)
const
;
#
if
defined
(
__OBJC__
)
static
Time
FromNSDate
(
NSDate
*
date
)
;
NSDate
*
ToNSDate
(
)
const
;
#
endif
#
endif
#
if
BUILDFLAG
(
IS_WIN
)
static
Time
FromFileTime
(
FILETIME
ft
)
;
FILETIME
ToFileTime
(
)
const
;
static
const
int
kMinLowResolutionThresholdMs
=
16
;
static
void
EnableHighResolutionTimer
(
bool
enable
)
;
static
bool
ActivateHighResolutionTimer
(
bool
activate
)
;
static
bool
IsHighResolutionTimerInUse
(
)
;
static
void
ResetHighResolutionTimerUsage
(
)
;
static
double
GetHighResolutionTimerUsage
(
)
;
#
endif
[
[
nodiscard
]
]
static
bool
FromUTCExploded
(
const
Exploded
&
exploded
Time
*
time
)
{
return
FromExploded
(
false
exploded
time
)
;
}
[
[
nodiscard
]
]
static
bool
FromLocalExploded
(
const
Exploded
&
exploded
Time
*
time
)
{
return
FromExploded
(
true
exploded
time
)
;
}
[
[
nodiscard
]
]
static
bool
FromString
(
const
char
*
time_string
Time
*
parsed_time
)
{
return
FromStringInternal
(
time_string
true
parsed_time
)
;
}
[
[
nodiscard
]
]
static
bool
FromUTCString
(
const
char
*
time_string
Time
*
parsed_time
)
{
return
FromStringInternal
(
time_string
false
parsed_time
)
;
}
#
if
!
defined
(
MOZ_SANDBOX
)
void
UTCExplode
(
Exploded
*
exploded
)
const
{
Explode
(
false
exploded
)
;
}
void
LocalExplode
(
Exploded
*
exploded
)
const
{
Explode
(
true
exploded
)
;
}
Time
UTCMidnight
(
)
const
{
return
Midnight
(
false
)
;
}
Time
LocalMidnight
(
)
const
{
return
Midnight
(
true
)
;
}
#
endif
static
constexpr
Time
FromInternalValue
(
int64_t
us
)
{
return
Time
(
us
)
;
}
private
:
friend
class
time_internal
:
:
TimeBase
<
Time
>
;
constexpr
explicit
Time
(
int64_t
microseconds_since_win_epoch
)
:
TimeBase
(
microseconds_since_win_epoch
)
{
}
void
Explode
(
bool
is_local
Exploded
*
exploded
)
const
;
[
[
nodiscard
]
]
static
bool
FromExploded
(
bool
is_local
const
Exploded
&
exploded
Time
*
time
)
;
static
void
ExplodeUsingIcu
(
int64_t
millis_since_unix_epoch
bool
is_local
Exploded
*
exploded
)
;
[
[
nodiscard
]
]
static
bool
FromExplodedUsingIcu
(
bool
is_local
const
Exploded
&
exploded
int64_t
*
millis_since_unix_epoch
)
;
Time
Midnight
(
bool
is_local
)
const
;
[
[
nodiscard
]
]
static
bool
FromStringInternal
(
const
char
*
time_string
bool
is_local
Time
*
parsed_time
)
;
[
[
nodiscard
]
]
static
bool
ExplodedMostlyEquals
(
const
Exploded
&
lhs
const
Exploded
&
rhs
)
;
[
[
nodiscard
]
]
static
bool
FromMillisecondsSinceUnixEpoch
(
int64_t
unix_milliseconds
Time
*
time
)
;
int64_t
ToRoundedDownMillisecondsSinceUnixEpoch
(
)
const
;
}
;
template
<
typename
T
>
constexpr
TimeDelta
Days
(
T
n
)
{
return
TimeDelta
:
:
FromInternalValue
(
MakeClampedNum
(
n
)
*
Time
:
:
kMicrosecondsPerDay
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
Hours
(
T
n
)
{
return
TimeDelta
:
:
FromInternalValue
(
MakeClampedNum
(
n
)
*
Time
:
:
kMicrosecondsPerHour
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
Minutes
(
T
n
)
{
return
TimeDelta
:
:
FromInternalValue
(
MakeClampedNum
(
n
)
*
Time
:
:
kMicrosecondsPerMinute
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
Seconds
(
T
n
)
{
return
TimeDelta
:
:
FromInternalValue
(
MakeClampedNum
(
n
)
*
Time
:
:
kMicrosecondsPerSecond
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
Milliseconds
(
T
n
)
{
return
TimeDelta
:
:
FromInternalValue
(
MakeClampedNum
(
n
)
*
Time
:
:
kMicrosecondsPerMillisecond
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
Microseconds
(
T
n
)
{
return
TimeDelta
:
:
FromInternalValue
(
MakeClampedNum
(
n
)
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
Nanoseconds
(
T
n
)
{
return
TimeDelta
:
:
FromInternalValue
(
MakeClampedNum
(
n
)
/
Time
:
:
kNanosecondsPerMicrosecond
)
;
}
template
<
typename
T
>
constexpr
TimeDelta
Hertz
(
T
n
)
{
return
n
?
TimeDelta
:
:
FromInternalValue
(
Time
:
:
kMicrosecondsPerSecond
/
MakeClampedNum
(
n
)
)
:
TimeDelta
:
:
Max
(
)
;
}
constexpr
double
TimeDelta
:
:
ToHz
(
)
const
{
return
Seconds
(
1
)
/
*
this
;
}
constexpr
int
TimeDelta
:
:
InDays
(
)
const
{
if
(
!
is_inf
(
)
)
{
return
static_cast
<
int
>
(
delta_
/
Time
:
:
kMicrosecondsPerDay
)
;
}
return
(
delta_
<
0
)
?
std
:
:
numeric_limits
<
int
>
:
:
min
(
)
:
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
}
constexpr
int
TimeDelta
:
:
InDaysFloored
(
)
const
{
if
(
!
is_inf
(
)
)
{
const
int
result
=
delta_
/
Time
:
:
kMicrosecondsPerDay
;
return
(
result
*
Time
:
:
kMicrosecondsPerDay
>
delta_
)
?
(
result
-
1
)
:
result
;
}
return
(
delta_
<
0
)
?
std
:
:
numeric_limits
<
int
>
:
:
min
(
)
:
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
}
constexpr
int
TimeDelta
:
:
InHours
(
)
const
{
return
saturated_cast
<
int
>
(
delta_
/
Time
:
:
kMicrosecondsPerHour
)
;
}
constexpr
int
TimeDelta
:
:
InMinutes
(
)
const
{
return
saturated_cast
<
int
>
(
delta_
/
Time
:
:
kMicrosecondsPerMinute
)
;
}
constexpr
double
TimeDelta
:
:
InSecondsF
(
)
const
{
if
(
!
is_inf
(
)
)
return
static_cast
<
double
>
(
delta_
)
/
Time
:
:
kMicrosecondsPerSecond
;
return
(
delta_
<
0
)
?
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
:
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
constexpr
int64_t
TimeDelta
:
:
InSeconds
(
)
const
{
return
is_inf
(
)
?
delta_
:
(
delta_
/
Time
:
:
kMicrosecondsPerSecond
)
;
}
constexpr
int64_t
TimeDelta
:
:
InSecondsFloored
(
)
const
{
if
(
!
is_inf
(
)
)
{
const
int64_t
result
=
delta_
/
Time
:
:
kMicrosecondsPerSecond
;
return
(
result
*
Time
:
:
kMicrosecondsPerSecond
>
delta_
)
?
(
result
-
1
)
:
result
;
}
return
delta_
;
}
constexpr
double
TimeDelta
:
:
InMillisecondsF
(
)
const
{
if
(
!
is_inf
(
)
)
{
return
static_cast
<
double
>
(
delta_
)
/
Time
:
:
kMicrosecondsPerMillisecond
;
}
return
(
delta_
<
0
)
?
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
:
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
constexpr
int64_t
TimeDelta
:
:
InMilliseconds
(
)
const
{
if
(
!
is_inf
(
)
)
{
return
delta_
/
Time
:
:
kMicrosecondsPerMillisecond
;
}
return
(
delta_
<
0
)
?
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
:
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
;
}
constexpr
int64_t
TimeDelta
:
:
InMillisecondsRoundedUp
(
)
const
{
if
(
!
is_inf
(
)
)
{
const
int64_t
result
=
delta_
/
Time
:
:
kMicrosecondsPerMillisecond
;
return
(
delta_
>
result
*
Time
:
:
kMicrosecondsPerMillisecond
)
?
(
result
+
1
)
:
result
;
}
return
delta_
;
}
constexpr
double
TimeDelta
:
:
InMicrosecondsF
(
)
const
{
if
(
!
is_inf
(
)
)
{
return
static_cast
<
double
>
(
delta_
)
;
}
return
(
delta_
<
0
)
?
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
:
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
constexpr
int64_t
TimeDelta
:
:
InNanoseconds
(
)
const
{
return
base
:
:
ClampMul
(
delta_
Time
:
:
kNanosecondsPerMicrosecond
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
Max
(
)
{
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
Min
(
)
{
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FiniteMax
(
)
{
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
-
1
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FiniteMin
(
)
{
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
+
1
)
;
}
namespace
time_internal
{
template
<
class
TimeClass
>
constexpr
TimeDelta
TimeBase
<
TimeClass
>
:
:
since_origin
(
)
const
{
return
Microseconds
(
us_
)
;
}
template
<
class
TimeClass
>
constexpr
TimeDelta
TimeBase
<
TimeClass
>
:
:
operator
-
(
const
TimeBase
<
TimeClass
>
&
other
)
const
{
return
Microseconds
(
us_
-
other
.
us_
)
;
}
template
<
class
TimeClass
>
constexpr
TimeClass
TimeBase
<
TimeClass
>
:
:
operator
+
(
TimeDelta
delta
)
const
{
return
TimeClass
(
(
Microseconds
(
us_
)
+
delta
)
.
InMicroseconds
(
)
)
;
}
template
<
class
TimeClass
>
constexpr
TimeClass
TimeBase
<
TimeClass
>
:
:
operator
-
(
TimeDelta
delta
)
const
{
return
TimeClass
(
(
Microseconds
(
us_
)
-
delta
)
.
InMicroseconds
(
)
)
;
}
}
constexpr
Time
Time
:
:
FromTimeT
(
time_t
tt
)
{
if
(
tt
=
=
0
)
return
Time
(
)
;
return
(
tt
=
=
std
:
:
numeric_limits
<
time_t
>
:
:
max
(
)
)
?
Max
(
)
:
(
UnixEpoch
(
)
+
Seconds
(
tt
)
)
;
}
constexpr
time_t
Time
:
:
ToTimeT
(
)
const
{
if
(
is_null
(
)
)
{
return
0
;
}
if
(
!
is_inf
(
)
)
{
return
saturated_cast
<
time_t
>
(
(
*
this
-
UnixEpoch
(
)
)
.
InSecondsFloored
(
)
)
;
}
return
(
us_
<
0
)
?
std
:
:
numeric_limits
<
time_t
>
:
:
min
(
)
:
std
:
:
numeric_limits
<
time_t
>
:
:
max
(
)
;
}
constexpr
Time
Time
:
:
FromSecondsSinceUnixEpoch
(
double
dt
)
{
return
(
dt
=
=
0
|
|
isnan
(
dt
)
)
?
Time
(
)
:
(
UnixEpoch
(
)
+
Seconds
(
dt
)
)
;
}
constexpr
double
Time
:
:
InSecondsFSinceUnixEpoch
(
)
const
{
if
(
is_null
(
)
)
{
return
0
;
}
if
(
!
is_inf
(
)
)
{
return
(
*
this
-
UnixEpoch
(
)
)
.
InSecondsF
(
)
;
}
return
(
us_
<
0
)
?
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
:
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
#
if
BUILDFLAG
(
IS_POSIX
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
constexpr
Time
Time
:
:
FromTimeSpec
(
const
timespec
&
ts
)
{
return
FromSecondsSinceUnixEpoch
(
ts
.
tv_sec
+
static_cast
<
double
>
(
ts
.
tv_nsec
)
/
kNanosecondsPerSecond
)
;
}
#
endif
constexpr
Time
Time
:
:
FromMillisecondsSinceUnixEpoch
(
int64_t
dt
)
{
return
UnixEpoch
(
)
+
Milliseconds
(
dt
)
;
}
constexpr
Time
Time
:
:
FromMillisecondsSinceUnixEpoch
(
double
dt
)
{
return
isnan
(
dt
)
?
Time
(
)
:
(
UnixEpoch
(
)
+
Milliseconds
(
dt
)
)
;
}
constexpr
int64_t
Time
:
:
InMillisecondsSinceUnixEpoch
(
)
const
{
if
(
is_null
(
)
)
{
return
0
;
}
if
(
!
is_inf
(
)
)
{
return
(
*
this
-
UnixEpoch
(
)
)
.
InMilliseconds
(
)
;
}
return
(
us_
<
0
)
?
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
:
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
;
}
constexpr
double
Time
:
:
InMillisecondsFSinceUnixEpoch
(
)
const
{
return
is_null
(
)
?
0
:
InMillisecondsFSinceUnixEpochIgnoringNull
(
)
;
}
constexpr
double
Time
:
:
InMillisecondsFSinceUnixEpochIgnoringNull
(
)
const
{
if
(
!
is_inf
(
)
)
{
return
(
*
this
-
UnixEpoch
(
)
)
.
InMillisecondsF
(
)
;
}
return
(
us_
<
0
)
?
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
:
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
Time
time
)
;
class
BASE_EXPORT
TimeTicks
:
public
time_internal
:
:
TimeBase
<
TimeTicks
>
{
public
:
enum
class
Clock
{
FUCHSIA_ZX_CLOCK_MONOTONIC
LINUX_CLOCK_MONOTONIC
IOS_CF_ABSOLUTE_TIME_MINUS_KERN_BOOTTIME
MAC_MACH_ABSOLUTE_TIME
WIN_QPC
WIN_ROLLOVER_PROTECTED_TIME_GET_TIME
}
;
constexpr
TimeTicks
(
)
:
TimeBase
(
0
)
{
}
static
TimeTicks
Now
(
)
;
[
[
nodiscard
]
]
static
bool
IsHighResolution
(
)
;
[
[
nodiscard
]
]
static
bool
IsConsistentAcrossProcesses
(
)
;
#
if
BUILDFLAG
(
IS_FUCHSIA
)
static
TimeTicks
FromZxTime
(
zx_time_t
nanos_since_boot
)
;
zx_time_t
ToZxTime
(
)
const
;
#
endif
#
if
BUILDFLAG
(
IS_WIN
)
static
TimeTicks
FromQPCValue
(
LONGLONG
qpc_value
)
;
#
endif
#
if
BUILDFLAG
(
IS_APPLE
)
static
TimeTicks
FromMachAbsoluteTime
(
uint64_t
mach_absolute_time
)
;
static
mach_timebase_info_data_t
SetMachTimebaseInfoForTesting
(
mach_timebase_info_data_t
timebase
)
;
#
endif
#
if
BUILDFLAG
(
IS_ANDROID
)
|
|
BUILDFLAG
(
IS_CHROMEOS_ASH
)
static
TimeTicks
FromUptimeMillis
(
int64_t
uptime_millis_value
)
;
#
endif
#
if
BUILDFLAG
(
IS_ANDROID
)
static
TimeTicks
FromJavaNanoTime
(
int64_t
nano_time_value
)
;
jlong
ToUptimeMillis
(
)
const
;
jlong
ToUptimeMicros
(
)
const
;
#
endif
static
TimeTicks
UnixEpoch
(
)
;
static
void
SetSharedUnixEpoch
(
TimeTicks
)
;
TimeTicks
SnappedToNextTick
(
TimeTicks
tick_phase
TimeDelta
tick_interval
)
const
;
static
Clock
GetClock
(
)
;
static
constexpr
TimeTicks
FromInternalValue
(
int64_t
us
)
{
return
TimeTicks
(
us
)
;
}
protected
:
#
if
BUILDFLAG
(
IS_WIN
)
typedef
DWORD
(
*
TickFunctionType
)
(
void
)
;
static
TickFunctionType
SetMockTickFunction
(
TickFunctionType
ticker
)
;
#
endif
private
:
friend
class
time_internal
:
:
TimeBase
<
TimeTicks
>
;
constexpr
explicit
TimeTicks
(
int64_t
us
)
:
TimeBase
(
us
)
{
}
}
;
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
TimeTicks
time_ticks
)
;
class
BASE_EXPORT
LiveTicks
:
public
time_internal
:
:
TimeBase
<
LiveTicks
>
{
public
:
constexpr
LiveTicks
(
)
:
TimeBase
(
0
)
{
}
static
LiveTicks
Now
(
)
;
private
:
friend
class
time_internal
:
:
TimeBase
<
LiveTicks
>
;
constexpr
explicit
LiveTicks
(
int64_t
us
)
:
TimeBase
(
us
)
{
}
}
;
class
BASE_EXPORT
ThreadTicks
:
public
time_internal
:
:
TimeBase
<
ThreadTicks
>
{
public
:
constexpr
ThreadTicks
(
)
:
TimeBase
(
0
)
{
}
[
[
nodiscard
]
]
static
bool
IsSupported
(
)
{
#
if
(
defined
(
_POSIX_THREAD_CPUTIME
)
&
&
(
_POSIX_THREAD_CPUTIME
>
=
0
)
)
|
|
\
BUILDFLAG
(
IS_APPLE
)
|
|
BUILDFLAG
(
IS_ANDROID
)
|
|
BUILDFLAG
(
IS_FUCHSIA
)
return
true
;
#
elif
BUILDFLAG
(
IS_WIN
)
return
IsSupportedWin
(
)
;
#
else
return
false
;
#
endif
}
static
void
WaitUntilInitialized
(
)
{
#
if
BUILDFLAG
(
IS_WIN
)
WaitUntilInitializedWin
(
)
;
#
endif
}
static
ThreadTicks
Now
(
)
;
#
if
BUILDFLAG
(
IS_WIN
)
static
ThreadTicks
GetForThread
(
const
PlatformThreadHandle
&
thread_handle
)
;
#
endif
static
constexpr
ThreadTicks
FromInternalValue
(
int64_t
us
)
{
return
ThreadTicks
(
us
)
;
}
private
:
friend
class
time_internal
:
:
TimeBase
<
ThreadTicks
>
;
constexpr
explicit
ThreadTicks
(
int64_t
us
)
:
TimeBase
(
us
)
{
}
#
if
BUILDFLAG
(
IS_WIN
)
[
[
nodiscard
]
]
static
bool
IsSupportedWin
(
)
;
static
void
WaitUntilInitializedWin
(
)
;
#
endif
}
;
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
ThreadTicks
time_ticks
)
;
}
#
endif
