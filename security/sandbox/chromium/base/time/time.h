#
ifndef
BASE_TIME_TIME_H_
#
define
BASE_TIME_TIME_H_
#
include
<
stdint
.
h
>
#
include
<
time
.
h
>
#
include
<
iosfwd
>
#
include
<
limits
>
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
numerics
/
safe_math
.
h
"
#
include
"
build
/
build_config
.
h
"
#
if
defined
(
OS_FUCHSIA
)
#
include
<
magenta
/
types
.
h
>
#
endif
#
if
defined
(
OS_MACOSX
)
#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
undef
TYPE_BOOL
#
endif
#
if
defined
(
OS_POSIX
)
#
include
<
unistd
.
h
>
#
include
<
sys
/
time
.
h
>
#
endif
#
if
defined
(
OS_WIN
)
#
include
<
windows
.
h
>
#
include
"
base
/
gtest_prod_util
.
h
"
#
endif
namespace
base
{
class
PlatformThreadHandle
;
class
TimeDelta
;
namespace
time_internal
{
BASE_EXPORT
int64_t
SaturatedAdd
(
TimeDelta
delta
int64_t
value
)
;
BASE_EXPORT
int64_t
SaturatedSub
(
TimeDelta
delta
int64_t
value
)
;
}
class
BASE_EXPORT
TimeDelta
{
public
:
TimeDelta
(
)
:
delta_
(
0
)
{
}
static
constexpr
TimeDelta
FromDays
(
int
days
)
;
static
constexpr
TimeDelta
FromHours
(
int
hours
)
;
static
constexpr
TimeDelta
FromMinutes
(
int
minutes
)
;
static
constexpr
TimeDelta
FromSeconds
(
int64_t
secs
)
;
static
constexpr
TimeDelta
FromMilliseconds
(
int64_t
ms
)
;
static
constexpr
TimeDelta
FromSecondsD
(
double
secs
)
;
static
constexpr
TimeDelta
FromMillisecondsD
(
double
ms
)
;
static
constexpr
TimeDelta
FromMicroseconds
(
int64_t
us
)
;
#
if
defined
(
OS_POSIX
)
static
TimeDelta
FromTimeSpec
(
const
timespec
&
ts
)
;
#
endif
#
if
defined
(
OS_WIN
)
static
TimeDelta
FromQPCValue
(
LONGLONG
qpc_value
)
;
#
endif
static
TimeDelta
FromInternalValue
(
int64_t
delta
)
{
return
TimeDelta
(
delta
)
;
}
static
constexpr
TimeDelta
Max
(
)
;
static
constexpr
TimeDelta
Min
(
)
;
int64_t
ToInternalValue
(
)
const
{
return
delta_
;
}
TimeDelta
magnitude
(
)
const
{
const
int64_t
mask
=
delta_
>
>
(
sizeof
(
delta_
)
*
8
-
1
)
;
return
TimeDelta
(
(
delta_
+
mask
)
^
mask
)
;
}
bool
is_zero
(
)
const
{
return
delta_
=
=
0
;
}
bool
is_max
(
)
const
{
return
delta_
=
=
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
;
}
bool
is_min
(
)
const
{
return
delta_
=
=
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
;
}
#
if
defined
(
OS_POSIX
)
struct
timespec
ToTimeSpec
(
)
const
;
#
endif
int
InDays
(
)
const
;
int
InHours
(
)
const
;
int
InMinutes
(
)
const
;
double
InSecondsF
(
)
const
;
int64_t
InSeconds
(
)
const
;
double
InMillisecondsF
(
)
const
;
int64_t
InMilliseconds
(
)
const
;
int64_t
InMillisecondsRoundedUp
(
)
const
;
int64_t
InMicroseconds
(
)
const
;
int64_t
InNanoseconds
(
)
const
;
TimeDelta
&
operator
=
(
TimeDelta
other
)
{
delta_
=
other
.
delta_
;
return
*
this
;
}
TimeDelta
operator
+
(
TimeDelta
other
)
const
{
return
TimeDelta
(
time_internal
:
:
SaturatedAdd
(
*
this
other
.
delta_
)
)
;
}
TimeDelta
operator
-
(
TimeDelta
other
)
const
{
return
TimeDelta
(
time_internal
:
:
SaturatedSub
(
*
this
other
.
delta_
)
)
;
}
TimeDelta
&
operator
+
=
(
TimeDelta
other
)
{
return
*
this
=
(
*
this
+
other
)
;
}
TimeDelta
&
operator
-
=
(
TimeDelta
other
)
{
return
*
this
=
(
*
this
-
other
)
;
}
TimeDelta
operator
-
(
)
const
{
return
TimeDelta
(
-
delta_
)
;
}
template
<
typename
T
>
TimeDelta
operator
*
(
T
a
)
const
{
CheckedNumeric
<
int64_t
>
rv
(
delta_
)
;
rv
*
=
a
;
if
(
rv
.
IsValid
(
)
)
return
TimeDelta
(
rv
.
ValueOrDie
(
)
)
;
if
(
(
delta_
<
0
)
^
(
a
<
0
)
)
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
)
;
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
;
}
template
<
typename
T
>
TimeDelta
operator
/
(
T
a
)
const
{
CheckedNumeric
<
int64_t
>
rv
(
delta_
)
;
rv
/
=
a
;
if
(
rv
.
IsValid
(
)
)
return
TimeDelta
(
rv
.
ValueOrDie
(
)
)
;
if
(
(
delta_
<
0
)
^
(
a
<
=
0
)
)
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
)
;
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
;
}
template
<
typename
T
>
TimeDelta
&
operator
*
=
(
T
a
)
{
return
*
this
=
(
*
this
*
a
)
;
}
template
<
typename
T
>
TimeDelta
&
operator
/
=
(
T
a
)
{
return
*
this
=
(
*
this
/
a
)
;
}
int64_t
operator
/
(
TimeDelta
a
)
const
{
return
delta_
/
a
.
delta_
;
}
TimeDelta
operator
%
(
TimeDelta
a
)
const
{
return
TimeDelta
(
delta_
%
a
.
delta_
)
;
}
constexpr
bool
operator
=
=
(
TimeDelta
other
)
const
{
return
delta_
=
=
other
.
delta_
;
}
constexpr
bool
operator
!
=
(
TimeDelta
other
)
const
{
return
delta_
!
=
other
.
delta_
;
}
constexpr
bool
operator
<
(
TimeDelta
other
)
const
{
return
delta_
<
other
.
delta_
;
}
constexpr
bool
operator
<
=
(
TimeDelta
other
)
const
{
return
delta_
<
=
other
.
delta_
;
}
constexpr
bool
operator
>
(
TimeDelta
other
)
const
{
return
delta_
>
other
.
delta_
;
}
constexpr
bool
operator
>
=
(
TimeDelta
other
)
const
{
return
delta_
>
=
other
.
delta_
;
}
#
if
defined
(
OS_WIN
)
constexpr
TimeDelta
(
const
TimeDelta
&
other
)
:
delta_
(
other
.
delta_
)
{
}
#
endif
private
:
friend
int64_t
time_internal
:
:
SaturatedAdd
(
TimeDelta
delta
int64_t
value
)
;
friend
int64_t
time_internal
:
:
SaturatedSub
(
TimeDelta
delta
int64_t
value
)
;
constexpr
explicit
TimeDelta
(
int64_t
delta_us
)
:
delta_
(
delta_us
)
{
}
static
constexpr
TimeDelta
FromDouble
(
double
value
)
;
static
constexpr
TimeDelta
FromProduct
(
int64_t
value
int64_t
positive_value
)
;
int64_t
delta_
;
}
;
template
<
typename
T
>
inline
TimeDelta
operator
*
(
T
a
TimeDelta
td
)
{
return
td
*
a
;
}
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
TimeDelta
time_delta
)
;
namespace
time_internal
{
template
<
class
TimeClass
>
class
TimeBase
{
public
:
static
const
int64_t
kHoursPerDay
=
24
;
static
const
int64_t
kMillisecondsPerSecond
=
1000
;
static
const
int64_t
kMillisecondsPerDay
=
kMillisecondsPerSecond
*
60
*
60
*
kHoursPerDay
;
static
const
int64_t
kMicrosecondsPerMillisecond
=
1000
;
static
const
int64_t
kMicrosecondsPerSecond
=
kMicrosecondsPerMillisecond
*
kMillisecondsPerSecond
;
static
const
int64_t
kMicrosecondsPerMinute
=
kMicrosecondsPerSecond
*
60
;
static
const
int64_t
kMicrosecondsPerHour
=
kMicrosecondsPerMinute
*
60
;
static
const
int64_t
kMicrosecondsPerDay
=
kMicrosecondsPerHour
*
kHoursPerDay
;
static
const
int64_t
kMicrosecondsPerWeek
=
kMicrosecondsPerDay
*
7
;
static
const
int64_t
kNanosecondsPerMicrosecond
=
1000
;
static
const
int64_t
kNanosecondsPerSecond
=
kNanosecondsPerMicrosecond
*
kMicrosecondsPerSecond
;
bool
is_null
(
)
const
{
return
us_
=
=
0
;
}
bool
is_max
(
)
const
{
return
us_
=
=
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
;
}
bool
is_min
(
)
const
{
return
us_
=
=
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
;
}
static
TimeClass
Max
(
)
{
return
TimeClass
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
;
}
static
TimeClass
Min
(
)
{
return
TimeClass
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
)
;
}
int64_t
ToInternalValue
(
)
const
{
return
us_
;
}
TimeDelta
since_origin
(
)
const
{
return
TimeDelta
:
:
FromMicroseconds
(
us_
)
;
}
TimeClass
&
operator
=
(
TimeClass
other
)
{
us_
=
other
.
us_
;
return
*
(
static_cast
<
TimeClass
*
>
(
this
)
)
;
}
TimeDelta
operator
-
(
TimeClass
other
)
const
{
return
TimeDelta
:
:
FromMicroseconds
(
us_
-
other
.
us_
)
;
}
TimeClass
operator
+
(
TimeDelta
delta
)
const
{
return
TimeClass
(
time_internal
:
:
SaturatedAdd
(
delta
us_
)
)
;
}
TimeClass
operator
-
(
TimeDelta
delta
)
const
{
return
TimeClass
(
-
time_internal
:
:
SaturatedSub
(
delta
us_
)
)
;
}
TimeClass
&
operator
+
=
(
TimeDelta
delta
)
{
return
static_cast
<
TimeClass
&
>
(
*
this
=
(
*
this
+
delta
)
)
;
}
TimeClass
&
operator
-
=
(
TimeDelta
delta
)
{
return
static_cast
<
TimeClass
&
>
(
*
this
=
(
*
this
-
delta
)
)
;
}
bool
operator
=
=
(
TimeClass
other
)
const
{
return
us_
=
=
other
.
us_
;
}
bool
operator
!
=
(
TimeClass
other
)
const
{
return
us_
!
=
other
.
us_
;
}
bool
operator
<
(
TimeClass
other
)
const
{
return
us_
<
other
.
us_
;
}
bool
operator
<
=
(
TimeClass
other
)
const
{
return
us_
<
=
other
.
us_
;
}
bool
operator
>
(
TimeClass
other
)
const
{
return
us_
>
other
.
us_
;
}
bool
operator
>
=
(
TimeClass
other
)
const
{
return
us_
>
=
other
.
us_
;
}
static
TimeClass
FromInternalValue
(
int64_t
us
)
{
return
TimeClass
(
us
)
;
}
protected
:
constexpr
explicit
TimeBase
(
int64_t
us
)
:
us_
(
us
)
{
}
int64_t
us_
;
}
;
}
template
<
class
TimeClass
>
inline
TimeClass
operator
+
(
TimeDelta
delta
TimeClass
t
)
{
return
t
+
delta
;
}
class
BASE_EXPORT
Time
:
public
time_internal
:
:
TimeBase
<
Time
>
{
public
:
static
constexpr
int64_t
kTimeTToMicrosecondsOffset
=
INT64_C
(
11644473600000000
)
;
#
if
defined
(
OS_WIN
)
static
constexpr
int64_t
kQPCOverflowThreshold
=
INT64_C
(
0x8637BD05AF7
)
;
#
endif
struct
BASE_EXPORT
Exploded
{
int
year
;
int
month
;
int
day_of_week
;
int
day_of_month
;
int
hour
;
int
minute
;
int
second
;
int
millisecond
;
bool
HasValidValues
(
)
const
;
}
;
Time
(
)
:
TimeBase
(
0
)
{
}
static
Time
UnixEpoch
(
)
;
static
Time
Now
(
)
;
static
Time
NowFromSystemTime
(
)
;
static
Time
FromTimeT
(
time_t
tt
)
;
time_t
ToTimeT
(
)
const
;
static
Time
FromDoubleT
(
double
dt
)
;
double
ToDoubleT
(
)
const
;
#
if
defined
(
OS_POSIX
)
static
Time
FromTimeSpec
(
const
timespec
&
ts
)
;
#
endif
static
Time
FromJsTime
(
double
ms_since_epoch
)
;
double
ToJsTime
(
)
const
;
static
Time
FromJavaTime
(
int64_t
ms_since_epoch
)
;
int64_t
ToJavaTime
(
)
const
;
#
if
defined
(
OS_POSIX
)
static
Time
FromTimeVal
(
struct
timeval
t
)
;
struct
timeval
ToTimeVal
(
)
const
;
#
endif
#
if
defined
(
OS_MACOSX
)
static
Time
FromCFAbsoluteTime
(
CFAbsoluteTime
t
)
;
CFAbsoluteTime
ToCFAbsoluteTime
(
)
const
;
#
endif
#
if
defined
(
OS_WIN
)
static
Time
FromFileTime
(
FILETIME
ft
)
;
FILETIME
ToFileTime
(
)
const
;
static
const
int
kMinLowResolutionThresholdMs
=
16
;
static
void
EnableHighResolutionTimer
(
bool
enable
)
;
static
bool
ActivateHighResolutionTimer
(
bool
activate
)
;
static
bool
IsHighResolutionTimerInUse
(
)
;
static
void
ResetHighResolutionTimerUsage
(
)
;
static
double
GetHighResolutionTimerUsage
(
)
;
#
endif
static
bool
FromUTCExploded
(
const
Exploded
&
exploded
Time
*
time
)
WARN_UNUSED_RESULT
{
return
FromExploded
(
false
exploded
time
)
;
}
static
bool
FromLocalExploded
(
const
Exploded
&
exploded
Time
*
time
)
WARN_UNUSED_RESULT
{
return
FromExploded
(
true
exploded
time
)
;
}
static
bool
FromString
(
const
char
*
time_string
Time
*
parsed_time
)
WARN_UNUSED_RESULT
{
return
FromStringInternal
(
time_string
true
parsed_time
)
;
}
static
bool
FromUTCString
(
const
char
*
time_string
Time
*
parsed_time
)
WARN_UNUSED_RESULT
{
return
FromStringInternal
(
time_string
false
parsed_time
)
;
}
void
UTCExplode
(
Exploded
*
exploded
)
const
{
return
Explode
(
false
exploded
)
;
}
void
LocalExplode
(
Exploded
*
exploded
)
const
{
return
Explode
(
true
exploded
)
;
}
Time
LocalMidnight
(
)
const
;
private
:
friend
class
time_internal
:
:
TimeBase
<
Time
>
;
explicit
Time
(
int64_t
us
)
:
TimeBase
(
us
)
{
}
void
Explode
(
bool
is_local
Exploded
*
exploded
)
const
;
static
bool
FromExploded
(
bool
is_local
const
Exploded
&
exploded
Time
*
time
)
WARN_UNUSED_RESULT
;
static
bool
FromStringInternal
(
const
char
*
time_string
bool
is_local
Time
*
parsed_time
)
WARN_UNUSED_RESULT
;
static
bool
ExplodedMostlyEquals
(
const
Exploded
&
lhs
const
Exploded
&
rhs
)
WARN_UNUSED_RESULT
;
}
;
constexpr
TimeDelta
TimeDelta
:
:
FromDays
(
int
days
)
{
return
days
=
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
?
Max
(
)
:
TimeDelta
(
days
*
Time
:
:
kMicrosecondsPerDay
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromHours
(
int
hours
)
{
return
hours
=
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
?
Max
(
)
:
TimeDelta
(
hours
*
Time
:
:
kMicrosecondsPerHour
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromMinutes
(
int
minutes
)
{
return
minutes
=
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
?
Max
(
)
:
TimeDelta
(
minutes
*
Time
:
:
kMicrosecondsPerMinute
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromSeconds
(
int64_t
secs
)
{
return
FromProduct
(
secs
Time
:
:
kMicrosecondsPerSecond
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromMilliseconds
(
int64_t
ms
)
{
return
FromProduct
(
ms
Time
:
:
kMicrosecondsPerMillisecond
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromSecondsD
(
double
secs
)
{
return
FromDouble
(
secs
*
Time
:
:
kMicrosecondsPerSecond
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromMillisecondsD
(
double
ms
)
{
return
FromDouble
(
ms
*
Time
:
:
kMicrosecondsPerMillisecond
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromMicroseconds
(
int64_t
us
)
{
return
TimeDelta
(
us
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
Max
(
)
{
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
Min
(
)
{
return
TimeDelta
(
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromDouble
(
double
value
)
{
return
value
>
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
?
Max
(
)
:
value
<
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
?
Min
(
)
:
TimeDelta
(
static_cast
<
int64_t
>
(
value
)
)
;
}
constexpr
TimeDelta
TimeDelta
:
:
FromProduct
(
int64_t
value
int64_t
positive_value
)
{
return
(
#
if
!
defined
(
_PREFAST_
)
|
|
!
defined
(
OS_WIN
)
static_cast
<
void
>
(
DCHECK
(
positive_value
>
0
)
)
#
endif
value
>
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
/
positive_value
?
Max
(
)
:
value
<
std
:
:
numeric_limits
<
int64_t
>
:
:
min
(
)
/
positive_value
?
Min
(
)
:
TimeDelta
(
value
*
positive_value
)
)
;
}
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
Time
time
)
;
class
BASE_EXPORT
TimeTicks
:
public
time_internal
:
:
TimeBase
<
TimeTicks
>
{
public
:
enum
class
Clock
{
FUCHSIA_MX_CLOCK_MONOTONIC
LINUX_CLOCK_MONOTONIC
IOS_CF_ABSOLUTE_TIME_MINUS_KERN_BOOTTIME
MAC_MACH_ABSOLUTE_TIME
WIN_QPC
WIN_ROLLOVER_PROTECTED_TIME_GET_TIME
}
;
constexpr
TimeTicks
(
)
:
TimeBase
(
0
)
{
}
static
TimeTicks
Now
(
)
;
static
bool
IsHighResolution
(
)
WARN_UNUSED_RESULT
;
static
bool
IsConsistentAcrossProcesses
(
)
WARN_UNUSED_RESULT
;
#
if
defined
(
OS_FUCHSIA
)
static
TimeTicks
FromMXTime
(
mx_time_t
nanos_since_boot
)
;
mx_time_t
ToMXTime
(
)
const
;
#
endif
#
if
defined
(
OS_WIN
)
static
TimeTicks
FromQPCValue
(
LONGLONG
qpc_value
)
;
#
endif
#
if
defined
(
OS_MACOSX
)
&
&
!
defined
(
OS_IOS
)
static
TimeTicks
FromMachAbsoluteTime
(
uint64_t
mach_absolute_time
)
;
#
endif
static
TimeTicks
UnixEpoch
(
)
;
TimeTicks
SnappedToNextTick
(
TimeTicks
tick_phase
TimeDelta
tick_interval
)
const
;
static
Clock
GetClock
(
)
;
#
if
defined
(
OS_WIN
)
protected
:
typedef
DWORD
(
*
TickFunctionType
)
(
void
)
;
static
TickFunctionType
SetMockTickFunction
(
TickFunctionType
ticker
)
;
#
endif
private
:
friend
class
time_internal
:
:
TimeBase
<
TimeTicks
>
;
explicit
TimeTicks
(
int64_t
us
)
:
TimeBase
(
us
)
{
}
}
;
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
TimeTicks
time_ticks
)
;
class
BASE_EXPORT
ThreadTicks
:
public
time_internal
:
:
TimeBase
<
ThreadTicks
>
{
public
:
ThreadTicks
(
)
:
TimeBase
(
0
)
{
}
static
bool
IsSupported
(
)
WARN_UNUSED_RESULT
{
#
if
(
defined
(
_POSIX_THREAD_CPUTIME
)
&
&
(
_POSIX_THREAD_CPUTIME
>
=
0
)
)
|
|
\
(
defined
(
OS_MACOSX
)
&
&
!
defined
(
OS_IOS
)
)
|
|
defined
(
OS_ANDROID
)
|
|
\
defined
(
OS_FUCHSIA
)
return
true
;
#
elif
defined
(
OS_WIN
)
return
IsSupportedWin
(
)
;
#
else
return
false
;
#
endif
}
static
void
WaitUntilInitialized
(
)
{
#
if
defined
(
OS_WIN
)
WaitUntilInitializedWin
(
)
;
#
endif
}
static
ThreadTicks
Now
(
)
;
#
if
defined
(
OS_WIN
)
static
ThreadTicks
GetForThread
(
const
PlatformThreadHandle
&
thread_handle
)
;
#
endif
private
:
friend
class
time_internal
:
:
TimeBase
<
ThreadTicks
>
;
explicit
ThreadTicks
(
int64_t
us
)
:
TimeBase
(
us
)
{
}
#
if
defined
(
OS_WIN
)
FRIEND_TEST_ALL_PREFIXES
(
TimeTicks
TSCTicksPerSecond
)
;
static
double
TSCTicksPerSecond
(
)
;
static
bool
IsSupportedWin
(
)
WARN_UNUSED_RESULT
;
static
void
WaitUntilInitializedWin
(
)
;
#
endif
}
;
BASE_EXPORT
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
ThreadTicks
time_ticks
)
;
}
#
endif
