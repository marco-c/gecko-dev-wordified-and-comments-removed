#
include
"
sandbox
/
linux
/
bpf_dsl
/
codegen
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
limits
>
#
include
<
ostream
>
#
include
<
utility
>
#
include
"
base
/
check_op
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_filter
.
h
"
namespace
sandbox
{
const
size_t
kBranchRange
=
std
:
:
numeric_limits
<
uint8_t
>
:
:
max
(
)
;
const
CodeGen
:
:
Node
CodeGen
:
:
kNullNode
;
CodeGen
:
:
CodeGen
(
)
:
program_
(
)
equivalent_
(
)
memos_
(
)
{
}
CodeGen
:
:
~
CodeGen
(
)
{
}
CodeGen
:
:
Program
CodeGen
:
:
Compile
(
CodeGen
:
:
Node
head
)
{
return
Program
(
program_
.
rbegin
(
)
+
Offset
(
head
)
program_
.
rend
(
)
)
;
}
CodeGen
:
:
Node
CodeGen
:
:
MakeInstruction
(
uint16_t
code
uint32_t
k
Node
jt
Node
jf
)
{
auto
res
=
memos_
.
insert
(
std
:
:
make_pair
(
MemoKey
(
code
k
jt
jf
)
kNullNode
)
)
;
CodeGen
:
:
Node
*
node
=
&
res
.
first
-
>
second
;
if
(
res
.
second
)
{
*
node
=
AppendInstruction
(
code
k
jt
jf
)
;
}
return
*
node
;
}
CodeGen
:
:
Node
CodeGen
:
:
AppendInstruction
(
uint16_t
code
uint32_t
k
Node
jt
Node
jf
)
{
if
(
BPF_CLASS
(
code
)
=
=
BPF_JMP
)
{
CHECK_NE
(
BPF_JA
BPF_OP
(
code
)
)
<
<
"
CodeGen
inserts
JAs
as
needed
"
;
jt
=
WithinRange
(
jt
kBranchRange
-
1
)
;
jf
=
WithinRange
(
jf
kBranchRange
)
;
return
Append
(
code
k
Offset
(
jt
)
Offset
(
jf
)
)
;
}
CHECK_EQ
(
kNullNode
jf
)
<
<
"
Non
-
branch
instructions
shouldn
'
t
provide
jf
"
;
if
(
BPF_CLASS
(
code
)
=
=
BPF_RET
)
{
CHECK_EQ
(
kNullNode
jt
)
<
<
"
Return
instructions
shouldn
'
t
provide
jt
"
;
}
else
{
jt
=
WithinRange
(
jt
0
)
;
CHECK_EQ
(
0U
Offset
(
jt
)
)
<
<
"
ICE
:
Failed
to
setup
next
instruction
"
;
}
return
Append
(
code
k
0
0
)
;
}
CodeGen
:
:
Node
CodeGen
:
:
WithinRange
(
Node
target
size_t
range
)
{
if
(
Offset
(
target
)
<
=
range
)
{
return
target
;
}
if
(
Offset
(
equivalent_
.
at
(
target
)
)
<
=
range
)
{
return
equivalent_
.
at
(
target
)
;
}
Node
jump
=
Append
(
BPF_JMP
|
BPF_JA
Offset
(
target
)
0
0
)
;
equivalent_
.
at
(
target
)
=
jump
;
return
jump
;
}
CodeGen
:
:
Node
CodeGen
:
:
Append
(
uint16_t
code
uint32_t
k
size_t
jt
size_t
jf
)
{
if
(
BPF_CLASS
(
code
)
=
=
BPF_JMP
&
&
BPF_OP
(
code
)
!
=
BPF_JA
)
{
CHECK_LE
(
jt
kBranchRange
)
;
CHECK_LE
(
jf
kBranchRange
)
;
}
else
{
CHECK_EQ
(
0U
jt
)
;
CHECK_EQ
(
0U
jf
)
;
}
CHECK_LT
(
program_
.
size
(
)
static_cast
<
size_t
>
(
BPF_MAXINSNS
)
)
;
CHECK_EQ
(
program_
.
size
(
)
equivalent_
.
size
(
)
)
;
Node
res
=
program_
.
size
(
)
;
program_
.
push_back
(
sock_filter
{
code
static_cast
<
uint8_t
>
(
jt
)
static_cast
<
uint8_t
>
(
jf
)
k
}
)
;
equivalent_
.
push_back
(
res
)
;
return
res
;
}
size_t
CodeGen
:
:
Offset
(
Node
target
)
const
{
CHECK_LT
(
target
program_
.
size
(
)
)
<
<
"
Bogus
offset
target
node
"
;
return
(
program_
.
size
(
)
-
1
)
-
target
;
}
}
