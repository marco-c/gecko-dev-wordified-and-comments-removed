#
ifndef
SANDBOX_LINUX_BPF_DSL_CONS_H_
#
define
SANDBOX_LINUX_BPF_DSL_CONS_H_
#
include
<
memory
>
#
include
"
sandbox
/
sandbox_export
.
h
"
namespace
sandbox
{
namespace
cons
{
template
<
typename
T
>
class
Cell
;
template
<
typename
T
>
class
ListIterator
;
template
<
typename
T
>
using
List
=
std
:
:
shared_ptr
<
const
Cell
<
T
>
>
;
template
<
typename
T
>
List
<
T
>
Cons
(
const
T
&
head
List
<
T
>
tail
)
{
return
std
:
:
make_shared
<
Cell
<
T
>
>
(
head
std
:
:
move
(
tail
)
)
;
}
template
<
typename
T
>
class
Cell
{
public
:
Cell
(
const
T
&
head
List
<
T
>
tail
)
:
head_
(
head
)
tail_
(
std
:
:
move
(
tail
)
)
{
}
Cell
(
const
Cell
&
)
=
delete
;
Cell
&
operator
=
(
const
Cell
&
)
=
delete
;
const
T
&
head
(
)
const
{
return
head_
;
}
const
List
<
T
>
&
tail
(
)
const
{
return
tail_
;
}
private
:
T
head_
;
List
<
T
>
tail_
;
}
;
template
<
typename
T
>
ListIterator
<
T
>
begin
(
const
List
<
T
>
&
list
)
{
return
ListIterator
<
T
>
(
list
)
;
}
template
<
typename
T
>
ListIterator
<
T
>
end
(
const
List
<
T
>
&
list
)
{
return
ListIterator
<
T
>
(
)
;
}
template
<
typename
T
>
class
ListIterator
{
public
:
ListIterator
(
)
:
list_
(
)
{
}
explicit
ListIterator
(
const
List
<
T
>
&
list
)
:
list_
(
list
)
{
}
const
T
&
operator
*
(
)
const
{
return
list_
-
>
head
(
)
;
}
ListIterator
&
operator
+
+
(
)
{
list_
=
list_
-
>
tail
(
)
;
return
*
this
;
}
friend
bool
operator
=
=
(
const
ListIterator
&
lhs
const
ListIterator
&
rhs
)
{
return
lhs
.
list_
=
=
rhs
.
list_
;
}
private
:
List
<
T
>
list_
;
}
;
template
<
typename
T
>
bool
operator
!
=
(
const
ListIterator
<
T
>
&
lhs
const
ListIterator
<
T
>
&
rhs
)
{
return
!
(
lhs
=
=
rhs
)
;
}
}
}
#
endif
