#
ifndef
SANDBOX_LINUX_BPF_DSL_BPF_DSL_H_
#
define
SANDBOX_LINUX_BPF_DSL_BPF_DSL_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
base
/
macros
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
bpf_dsl_forward
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
cons
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
trap_registry
.
h
"
#
include
"
sandbox
/
sandbox_export
.
h
"
namespace
sandbox
{
namespace
bpf_dsl
{
template
<
typename
T
>
class
Caser
;
class
Elser
;
using
ResultExpr
=
std
:
:
shared_ptr
<
const
internal
:
:
ResultExprImpl
>
;
using
BoolExpr
=
std
:
:
shared_ptr
<
const
internal
:
:
BoolExprImpl
>
;
SANDBOX_EXPORT
ResultExpr
Allow
(
)
;
SANDBOX_EXPORT
ResultExpr
Error
(
int
err
)
;
SANDBOX_EXPORT
ResultExpr
Kill
(
)
;
SANDBOX_EXPORT
ResultExpr
Trace
(
uint16_t
aux
)
;
SANDBOX_EXPORT
ResultExpr
Trap
(
TrapRegistry
:
:
TrapFnc
trap_func
const
void
*
aux
)
;
SANDBOX_EXPORT
ResultExpr
UnsafeTrap
(
TrapRegistry
:
:
TrapFnc
trap_func
const
void
*
aux
)
;
SANDBOX_EXPORT
BoolExpr
BoolConst
(
bool
value
)
;
SANDBOX_EXPORT
BoolExpr
Not
(
BoolExpr
cond
)
;
SANDBOX_EXPORT
BoolExpr
AllOf
(
)
;
SANDBOX_EXPORT
BoolExpr
AllOf
(
BoolExpr
lhs
BoolExpr
rhs
)
;
template
<
typename
.
.
.
Rest
>
SANDBOX_EXPORT
BoolExpr
AllOf
(
BoolExpr
first
Rest
&
&
.
.
.
rest
)
;
SANDBOX_EXPORT
BoolExpr
AnyOf
(
)
;
SANDBOX_EXPORT
BoolExpr
AnyOf
(
BoolExpr
lhs
BoolExpr
rhs
)
;
template
<
typename
.
.
.
Rest
>
SANDBOX_EXPORT
BoolExpr
AnyOf
(
BoolExpr
first
Rest
&
&
.
.
.
rest
)
;
template
<
typename
T
>
class
SANDBOX_EXPORT
Arg
{
public
:
explicit
Arg
(
int
num
)
;
Arg
(
const
Arg
&
arg
)
:
num_
(
arg
.
num_
)
mask_
(
arg
.
mask_
)
{
}
friend
Arg
operator
&
(
const
Arg
&
lhs
uint64_t
rhs
)
{
return
Arg
(
lhs
.
num_
lhs
.
mask_
&
rhs
)
;
}
friend
BoolExpr
operator
=
=
(
const
Arg
&
lhs
T
rhs
)
{
return
lhs
.
EqualTo
(
rhs
)
;
}
friend
BoolExpr
operator
!
=
(
const
Arg
&
lhs
T
rhs
)
{
return
Not
(
lhs
=
=
rhs
)
;
}
private
:
Arg
(
int
num
uint64_t
mask
)
:
num_
(
num
)
mask_
(
mask
)
{
}
BoolExpr
EqualTo
(
T
val
)
const
;
int
num_
;
uint64_t
mask_
;
DISALLOW_ASSIGN
(
Arg
)
;
}
;
SANDBOX_EXPORT
Elser
If
(
BoolExpr
cond
ResultExpr
then_result
)
;
class
SANDBOX_EXPORT
Elser
{
public
:
Elser
(
const
Elser
&
elser
)
;
~
Elser
(
)
;
Elser
ElseIf
(
BoolExpr
cond
ResultExpr
then_result
)
const
;
ResultExpr
Else
(
ResultExpr
else_result
)
const
;
private
:
using
Clause
=
std
:
:
pair
<
BoolExpr
ResultExpr
>
;
explicit
Elser
(
cons
:
:
List
<
Clause
>
clause_list
)
;
cons
:
:
List
<
Clause
>
clause_list_
;
friend
Elser
If
(
BoolExpr
ResultExpr
)
;
template
<
typename
T
>
friend
Caser
<
T
>
Switch
(
const
Arg
<
T
>
&
)
;
DISALLOW_ASSIGN
(
Elser
)
;
}
;
template
<
typename
T
>
SANDBOX_EXPORT
Caser
<
T
>
Switch
(
const
Arg
<
T
>
&
arg
)
;
template
<
typename
T
>
class
SANDBOX_EXPORT
Caser
{
public
:
Caser
(
const
Caser
<
T
>
&
caser
)
:
arg_
(
caser
.
arg_
)
elser_
(
caser
.
elser_
)
{
}
~
Caser
(
)
{
}
Caser
<
T
>
Case
(
T
value
ResultExpr
result
)
const
;
template
<
typename
.
.
.
Values
>
Caser
<
T
>
CasesImpl
(
ResultExpr
result
const
Values
&
.
.
.
values
)
const
;
ResultExpr
Default
(
ResultExpr
result
)
const
;
private
:
Caser
(
const
Arg
<
T
>
&
arg
Elser
elser
)
:
arg_
(
arg
)
elser_
(
elser
)
{
}
Arg
<
T
>
arg_
;
Elser
elser_
;
template
<
typename
U
>
friend
Caser
<
U
>
Switch
(
const
Arg
<
U
>
&
)
;
DISALLOW_ASSIGN
(
Caser
)
;
}
;
#
define
SANDBOX_BPF_DSL_CASES
(
values
result
)
\
CasesImpl
(
result
SANDBOX_BPF_DSL_CASES_HELPER
values
)
#
define
SANDBOX_BPF_DSL_CASES_HELPER
(
.
.
.
)
__VA_ARGS__
namespace
internal
{
using
bpf_dsl
:
:
Not
;
using
bpf_dsl
:
:
AllOf
;
using
bpf_dsl
:
:
AnyOf
;
SANDBOX_EXPORT
BoolExpr
ArgEq
(
int
num
size_t
size
uint64_t
mask
uint64_t
val
)
;
SANDBOX_EXPORT
uint64_t
DefaultMask
(
size_t
size
)
;
}
template
<
typename
T
>
Arg
<
T
>
:
:
Arg
(
int
num
)
:
num_
(
num
)
mask_
(
internal
:
:
DefaultMask
(
sizeof
(
T
)
)
)
{
}
template
<
typename
T
>
BoolExpr
Arg
<
T
>
:
:
EqualTo
(
T
val
)
const
{
if
(
sizeof
(
T
)
=
=
4
)
{
return
internal
:
:
ArgEq
(
num_
sizeof
(
T
)
mask_
static_cast
<
uint32_t
>
(
val
)
)
;
}
return
internal
:
:
ArgEq
(
num_
sizeof
(
T
)
mask_
static_cast
<
uint64_t
>
(
val
)
)
;
}
template
<
typename
T
>
SANDBOX_EXPORT
Caser
<
T
>
Switch
(
const
Arg
<
T
>
&
arg
)
{
return
Caser
<
T
>
(
arg
Elser
(
nullptr
)
)
;
}
template
<
typename
T
>
Caser
<
T
>
Caser
<
T
>
:
:
Case
(
T
value
ResultExpr
result
)
const
{
return
SANDBOX_BPF_DSL_CASES
(
(
value
)
std
:
:
move
(
result
)
)
;
}
template
<
typename
T
>
template
<
typename
.
.
.
Values
>
Caser
<
T
>
Caser
<
T
>
:
:
CasesImpl
(
ResultExpr
result
const
Values
&
.
.
.
values
)
const
{
return
Caser
<
T
>
(
arg_
elser_
.
ElseIf
(
AnyOf
(
(
arg_
=
=
values
)
.
.
.
)
std
:
:
move
(
result
)
)
)
;
}
template
<
typename
T
>
ResultExpr
Caser
<
T
>
:
:
Default
(
ResultExpr
result
)
const
{
return
elser_
.
Else
(
std
:
:
move
(
result
)
)
;
}
template
<
typename
.
.
.
Rest
>
BoolExpr
AllOf
(
BoolExpr
first
Rest
&
&
.
.
.
rest
)
{
return
AllOf
(
std
:
:
move
(
first
)
AllOf
(
std
:
:
forward
<
Rest
>
(
rest
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Rest
>
BoolExpr
AnyOf
(
BoolExpr
first
Rest
&
&
.
.
.
rest
)
{
return
AnyOf
(
std
:
:
move
(
first
)
AnyOf
(
std
:
:
forward
<
Rest
>
(
rest
)
.
.
.
)
)
;
}
}
}
#
endif
