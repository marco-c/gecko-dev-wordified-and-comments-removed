#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy_compiler
.
h
"
#
include
<
errno
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
limits
>
#
include
<
ostream
>
#
include
"
base
/
bits
.
h
"
#
include
"
base
/
check_op
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
bpf_dsl
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
bpf_dsl_impl
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
codegen
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
seccomp_macros
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
syscall_set
.
h
"
#
include
"
sandbox
/
linux
/
seccomp
-
bpf
/
syscall
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_filter
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_seccomp
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_syscalls
.
h
"
namespace
sandbox
{
namespace
bpf_dsl
{
namespace
{
#
if
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
const
bool
kIsIntel
=
true
;
#
else
const
bool
kIsIntel
=
false
;
#
endif
#
if
defined
(
__x86_64__
)
&
&
defined
(
__ILP32__
)
const
bool
kIsX32
=
true
;
#
else
const
bool
kIsX32
=
false
;
#
endif
const
int
kSyscallsRequiredForUnsafeTraps
[
]
=
{
__NR_rt_sigprocmask
__NR_rt_sigreturn
#
if
defined
(
__NR_sigprocmask
)
__NR_sigprocmask
#
endif
#
if
defined
(
__NR_sigreturn
)
__NR_sigreturn
#
endif
}
;
ResultExpr
DefaultPanic
(
const
char
*
error
)
{
return
Kill
(
)
;
}
intptr_t
ReturnErrno
(
const
struct
arch_seccomp_data
&
void
*
aux
)
{
int
err
=
reinterpret_cast
<
intptr_t
>
(
aux
)
&
SECCOMP_RET_DATA
;
return
-
err
;
}
bool
HasUnsafeTraps
(
const
Policy
*
policy
)
{
DCHECK
(
policy
)
;
for
(
uint32_t
sysnum
:
SyscallSet
:
:
ValidOnly
(
)
)
{
if
(
policy
-
>
EvaluateSyscall
(
sysnum
)
-
>
HasUnsafeTraps
(
)
)
{
return
true
;
}
}
return
policy
-
>
InvalidSyscall
(
)
-
>
HasUnsafeTraps
(
)
;
}
}
struct
PolicyCompiler
:
:
Range
{
uint32_t
from
;
CodeGen
:
:
Node
node
;
}
;
PolicyCompiler
:
:
PolicyCompiler
(
const
Policy
*
policy
TrapRegistry
*
registry
)
:
policy_
(
policy
)
registry_
(
registry
)
escapepc_
(
0
)
panic_func_
(
DefaultPanic
)
gen_
(
)
has_unsafe_traps_
(
HasUnsafeTraps
(
policy_
)
)
{
DCHECK
(
policy
)
;
}
PolicyCompiler
:
:
~
PolicyCompiler
(
)
{
}
CodeGen
:
:
Program
PolicyCompiler
:
:
Compile
(
)
{
CHECK
(
policy_
-
>
InvalidSyscall
(
)
-
>
IsDeny
(
)
)
<
<
"
Policies
should
deny
invalid
system
calls
"
;
if
(
has_unsafe_traps_
)
{
CHECK_NE
(
0U
escapepc_
)
<
<
"
UnsafeTrap
(
)
requires
a
valid
escape
PC
"
;
for
(
int
sysnum
:
kSyscallsRequiredForUnsafeTraps
)
{
CHECK
(
policy_
-
>
EvaluateSyscall
(
sysnum
)
-
>
IsAllow
(
)
)
<
<
"
Policies
that
use
UnsafeTrap
(
)
must
unconditionally
allow
all
"
"
required
system
calls
"
;
}
CHECK
(
registry_
-
>
EnableUnsafeTraps
(
)
)
<
<
"
We
'
d
rather
die
than
enable
unsafe
traps
"
;
}
return
gen_
.
Compile
(
AssemblePolicy
(
)
)
;
}
void
PolicyCompiler
:
:
DangerousSetEscapePC
(
uint64_t
escapepc
)
{
escapepc_
=
escapepc
;
}
void
PolicyCompiler
:
:
SetPanicFunc
(
PanicFunc
panic_func
)
{
panic_func_
=
panic_func
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
AssemblePolicy
(
)
{
return
CheckArch
(
MaybeAddEscapeHatch
(
DispatchSyscall
(
)
)
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
CheckArch
(
CodeGen
:
:
Node
passed
)
{
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
SECCOMP_ARCH_IDX
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JEQ
+
BPF_K
SECCOMP_ARCH
passed
CompileResult
(
panic_func_
(
"
Invalid
audit
architecture
in
BPF
filter
"
)
)
)
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
MaybeAddEscapeHatch
(
CodeGen
:
:
Node
rest
)
{
if
(
!
has_unsafe_traps_
)
{
return
rest
;
}
CHECK
(
registry_
-
>
EnableUnsafeTraps
(
)
)
;
const
uint32_t
lopc
=
static_cast
<
uint32_t
>
(
escapepc_
)
;
const
uint32_t
hipc
=
static_cast
<
uint32_t
>
(
escapepc_
>
>
32
)
;
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
SECCOMP_IP_LSB_IDX
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JEQ
+
BPF_K
lopc
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
SECCOMP_IP_MSB_IDX
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JEQ
+
BPF_K
hipc
CompileResult
(
Allow
(
)
)
rest
)
)
rest
)
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
DispatchSyscall
(
)
{
Ranges
ranges
;
FindRanges
(
&
ranges
)
;
CodeGen
:
:
Node
jumptable
=
AssembleJumpTable
(
ranges
.
begin
(
)
ranges
.
end
(
)
)
;
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
SECCOMP_NR_IDX
CheckSyscallNumber
(
jumptable
)
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
CheckSyscallNumber
(
CodeGen
:
:
Node
passed
)
{
if
(
kIsIntel
)
{
CodeGen
:
:
Node
invalidX32
=
CompileResult
(
panic_func_
(
"
Illegal
mixing
of
system
call
ABIs
"
)
)
;
if
(
kIsX32
)
{
return
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JSET
+
BPF_K
0x40000000
passed
invalidX32
)
;
}
else
{
return
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JSET
+
BPF_K
0x40000000
invalidX32
passed
)
;
}
}
return
passed
;
}
void
PolicyCompiler
:
:
FindRanges
(
Ranges
*
ranges
)
{
const
CodeGen
:
:
Node
invalid_node
=
CompileResult
(
policy_
-
>
InvalidSyscall
(
)
)
;
uint32_t
old_sysnum
=
0
;
CodeGen
:
:
Node
old_node
=
SyscallSet
:
:
IsValid
(
old_sysnum
)
?
CompileResult
(
policy_
-
>
EvaluateSyscall
(
old_sysnum
)
)
:
invalid_node
;
for
(
uint32_t
sysnum
:
SyscallSet
:
:
All
(
)
)
{
CodeGen
:
:
Node
node
=
SyscallSet
:
:
IsValid
(
sysnum
)
?
CompileResult
(
policy_
-
>
EvaluateSyscall
(
static_cast
<
int
>
(
sysnum
)
)
)
:
invalid_node
;
if
(
node
!
=
old_node
)
{
ranges
-
>
push_back
(
Range
{
old_sysnum
old_node
}
)
;
old_sysnum
=
sysnum
;
old_node
=
node
;
}
}
ranges
-
>
push_back
(
Range
{
old_sysnum
old_node
}
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
AssembleJumpTable
(
Ranges
:
:
const_iterator
start
Ranges
:
:
const_iterator
stop
)
{
CHECK
(
start
<
stop
)
<
<
"
Invalid
iterator
range
"
;
const
auto
n
=
stop
-
start
;
if
(
n
=
=
1
)
{
return
start
-
>
node
;
}
Ranges
:
:
const_iterator
mid
=
start
+
n
/
2
;
CodeGen
:
:
Node
jf
=
AssembleJumpTable
(
start
mid
)
;
CodeGen
:
:
Node
jt
=
AssembleJumpTable
(
mid
stop
)
;
return
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JGE
+
BPF_K
mid
-
>
from
jt
jf
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
CompileResult
(
const
ResultExpr
&
res
)
{
return
res
-
>
Compile
(
this
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
MaskedEqual
(
int
argno
size_t
width
uint64_t
mask
uint64_t
value
CodeGen
:
:
Node
passed
CodeGen
:
:
Node
failed
)
{
CHECK
(
argno
>
=
0
&
&
argno
<
6
)
<
<
"
Invalid
argument
number
"
<
<
argno
;
CHECK
(
width
=
=
4
|
|
width
=
=
8
)
<
<
"
Invalid
argument
width
"
<
<
width
;
CHECK_NE
(
0U
mask
)
<
<
"
Zero
mask
is
invalid
"
;
CHECK_EQ
(
value
value
&
mask
)
<
<
"
Value
contains
masked
out
bits
"
;
if
(
sizeof
(
void
*
)
=
=
4
)
{
CHECK_EQ
(
4U
width
)
<
<
"
Invalid
width
on
32
-
bit
platform
"
;
}
if
(
width
=
=
4
)
{
CHECK_EQ
(
0U
mask
>
>
32
)
<
<
"
Mask
exceeds
argument
size
"
;
CHECK_EQ
(
0U
value
>
>
32
)
<
<
"
Value
exceeds
argument
size
"
;
}
return
MaskedEqualHalf
(
argno
width
mask
value
ArgHalf
:
:
UPPER
MaskedEqualHalf
(
argno
width
mask
value
ArgHalf
:
:
LOWER
passed
failed
)
failed
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
MaskedEqualHalf
(
int
argno
size_t
width
uint64_t
full_mask
uint64_t
full_value
ArgHalf
half
CodeGen
:
:
Node
passed
CodeGen
:
:
Node
failed
)
{
if
(
width
=
=
4
&
&
half
=
=
ArgHalf
:
:
UPPER
)
{
CodeGen
:
:
Node
invalid_64bit
=
Unexpected64bitArgument
(
argno
)
;
const
uint32_t
upper
=
SECCOMP_ARG_MSB_IDX
(
argno
)
;
const
uint32_t
lower
=
SECCOMP_ARG_LSB_IDX
(
argno
)
;
if
(
sizeof
(
void
*
)
=
=
4
)
{
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
upper
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JEQ
+
BPF_K
0
passed
invalid_64bit
)
)
;
}
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
upper
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JEQ
+
BPF_K
0
passed
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JEQ
+
BPF_K
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
lower
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JSET
+
BPF_K
1U
<
<
31
passed
invalid_64bit
)
)
invalid_64bit
)
)
)
;
}
const
uint32_t
idx
=
(
half
=
=
ArgHalf
:
:
UPPER
)
?
SECCOMP_ARG_MSB_IDX
(
argno
)
:
SECCOMP_ARG_LSB_IDX
(
argno
)
;
const
uint32_t
mask
=
(
half
=
=
ArgHalf
:
:
UPPER
)
?
full_mask
>
>
32
:
full_mask
;
const
uint32_t
value
=
(
half
=
=
ArgHalf
:
:
UPPER
)
?
full_value
>
>
32
:
full_value
;
if
(
mask
=
=
0
)
{
CHECK_EQ
(
0U
value
)
;
return
passed
;
}
if
(
mask
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
{
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
idx
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JEQ
+
BPF_K
value
passed
failed
)
)
;
}
if
(
value
=
=
0
)
{
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
idx
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JSET
+
BPF_K
mask
failed
passed
)
)
;
}
if
(
mask
=
=
value
&
&
base
:
:
bits
:
:
IsPowerOfTwo
(
mask
)
)
{
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
idx
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JSET
+
BPF_K
mask
passed
failed
)
)
;
}
return
gen_
.
MakeInstruction
(
BPF_LD
+
BPF_W
+
BPF_ABS
idx
gen_
.
MakeInstruction
(
BPF_ALU
+
BPF_AND
+
BPF_K
mask
gen_
.
MakeInstruction
(
BPF_JMP
+
BPF_JEQ
+
BPF_K
value
passed
failed
)
)
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
Unexpected64bitArgument
(
int
argno
)
{
return
CompileResult
(
bpf_dsl
:
:
Trap
(
[
]
(
const
arch_seccomp_data
&
args_ref
void
*
aux
)
-
>
intptr_t
{
arch_seccomp_data
args
=
args_ref
;
int
argno
=
(
int
)
(
intptr_t
)
aux
;
args
.
args
[
argno
]
&
=
0xFFFFFFFF
;
return
Syscall
:
:
Call
(
args
.
nr
args
.
args
[
0
]
args
.
args
[
1
]
args
.
args
[
2
]
args
.
args
[
3
]
args
.
args
[
4
]
args
.
args
[
5
]
)
;
}
(
void
*
)
(
intptr_t
)
argno
)
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
Return
(
uint32_t
ret
)
{
if
(
has_unsafe_traps_
&
&
(
ret
&
SECCOMP_RET_ACTION
)
=
=
SECCOMP_RET_ERRNO
)
{
return
Trap
(
{
ReturnErrno
reinterpret_cast
<
void
*
>
(
ret
&
SECCOMP_RET_DATA
)
true
}
)
;
}
return
gen_
.
MakeInstruction
(
BPF_RET
+
BPF_K
ret
)
;
}
CodeGen
:
:
Node
PolicyCompiler
:
:
Trap
(
const
TrapRegistry
:
:
Handler
&
handler
)
{
uint16_t
trap_id
=
registry_
-
>
Add
(
handler
)
;
return
gen_
.
MakeInstruction
(
BPF_RET
+
BPF_K
SECCOMP_RET_TRAP
+
trap_id
)
;
}
bool
PolicyCompiler
:
:
IsRequiredForUnsafeTrap
(
int
sysno
)
{
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
kSyscallsRequiredForUnsafeTraps
)
;
+
+
i
)
{
if
(
sysno
=
=
kSyscallsRequiredForUnsafeTraps
[
i
]
)
{
return
true
;
}
}
return
false
;
}
}
}
