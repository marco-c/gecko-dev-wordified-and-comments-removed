#
include
"
sandbox
/
linux
/
seccomp
-
bpf
/
sandbox_bpf_test_runner
.
h
"
#
include
<
fcntl
.
h
>
#
include
<
memory
>
#
include
"
base
/
logging
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy
.
h
"
#
include
"
sandbox
/
linux
/
seccomp
-
bpf
/
die
.
h
"
#
include
"
sandbox
/
linux
/
seccomp
-
bpf
/
sandbox_bpf
.
h
"
#
include
"
sandbox
/
linux
/
system_headers
/
linux_filter
.
h
"
#
include
"
sandbox
/
linux
/
tests
/
unit_tests
.
h
"
namespace
sandbox
{
SandboxBPFTestRunner
:
:
SandboxBPFTestRunner
(
BPFTesterDelegate
*
bpf_tester_delegate
)
:
bpf_tester_delegate_
(
bpf_tester_delegate
)
{
}
SandboxBPFTestRunner
:
:
~
SandboxBPFTestRunner
(
)
{
}
void
SandboxBPFTestRunner
:
:
Run
(
)
{
DCHECK
(
bpf_tester_delegate_
)
;
sandbox
:
:
Die
:
:
EnableSimpleExit
(
)
;
std
:
:
unique_ptr
<
bpf_dsl
:
:
Policy
>
policy
=
bpf_tester_delegate_
-
>
GetSandboxBPFPolicy
(
)
;
if
(
sandbox
:
:
SandboxBPF
:
:
SupportsSeccompSandbox
(
SandboxBPF
:
:
SeccompLevel
:
:
SINGLE_THREADED
)
)
{
sandbox
:
:
SandboxBPF
sandbox
(
std
:
:
move
(
policy
)
)
;
SANDBOX_ASSERT
(
sandbox
.
StartSandbox
(
sandbox
:
:
SandboxBPF
:
:
SeccompLevel
:
:
SINGLE_THREADED
)
)
;
bpf_tester_delegate_
-
>
RunTestFunction
(
)
;
}
else
{
printf
(
"
This
BPF
test
is
not
fully
running
in
this
configuration
!
\
n
"
)
;
if
(
!
IsAndroid
(
)
)
{
const
bool
seccomp_bpf_is_supported
=
false
;
SANDBOX_ASSERT
(
seccomp_bpf_is_supported
)
;
}
sandbox
:
:
SandboxBPF
sandbox
(
std
:
:
move
(
policy
)
)
;
sandbox
.
AssembleFilter
(
)
;
sandbox
:
:
UnitTests
:
:
IgnoreThisTest
(
)
;
}
}
bool
SandboxBPFTestRunner
:
:
ShouldCheckForLeaks
(
)
const
{
return
false
;
}
}
