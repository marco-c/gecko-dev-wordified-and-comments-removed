#
ifndef
SANDBOX_LINUX_SECCOMP_BPF_SANDBOX_BPF_H_
#
define
SANDBOX_LINUX_SECCOMP_BPF_SANDBOX_BPF_H_
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
"
base
/
files
/
scoped_file
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
codegen
.
h
"
#
include
"
sandbox
/
linux
/
bpf_dsl
/
policy
.
h
"
#
include
"
sandbox
/
sandbox_export
.
h
"
namespace
sandbox
{
struct
arch_seccomp_data
;
class
SANDBOX_EXPORT
SandboxBPF
{
public
:
enum
class
SeccompLevel
{
SINGLE_THREADED
MULTI_THREADED
}
;
explicit
SandboxBPF
(
std
:
:
unique_ptr
<
bpf_dsl
:
:
Policy
>
policy
)
;
~
SandboxBPF
(
)
;
static
bool
SupportsSeccompSandbox
(
SeccompLevel
level
)
;
bool
StartSandbox
(
SeccompLevel
level
)
WARN_UNUSED_RESULT
;
void
SetProcFd
(
base
:
:
ScopedFD
proc_fd
)
;
static
bool
IsValidSyscallNumber
(
int
sysnum
)
;
static
bool
IsRequiredForUnsafeTrap
(
int
sysno
)
;
static
intptr_t
ForwardSyscall
(
const
struct
arch_seccomp_data
&
args
)
;
private
:
friend
class
SandboxBPFTestRunner
;
CodeGen
:
:
Program
AssembleFilter
(
)
;
void
InstallFilter
(
bool
must_sync_threads
)
;
base
:
:
ScopedFD
proc_fd_
;
bool
sandbox_has_started_
;
std
:
:
unique_ptr
<
bpf_dsl
:
:
Policy
>
policy_
;
DISALLOW_COPY_AND_ASSIGN
(
SandboxBPF
)
;
}
;
}
#
endif
