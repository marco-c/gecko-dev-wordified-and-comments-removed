#
include
"
sandbox
/
win
/
src
/
service_resolver
.
h
"
#
include
<
windows
.
h
>
#
include
<
ntstatus
.
h
>
#
include
<
stddef
.
h
>
#
include
<
winternl
.
h
>
#
include
<
memory
>
namespace
{
#
if
defined
(
_M_X64
)
#
pragma
pack
(
push
1
)
const
ULONG
kMmovR10EcxMovEax
=
0xB8D18B4C
;
const
USHORT
kSyscall
=
0x050F
;
const
BYTE
kRetNp
=
0xC3
;
const
ULONG64
kMov1
=
0x54894808244C8948
;
const
ULONG64
kMov2
=
0x4C182444894C1024
;
const
ULONG
kMov3
=
0x20244C89
;
const
USHORT
kTestByte
=
0x04F6
;
const
BYTE
kPtr
=
0x25
;
const
BYTE
kRet
=
0xC3
;
const
USHORT
kJne
=
0x0375
;
struct
ServiceEntry
{
ULONG
mov_r10_rcx_mov_eax
;
ULONG
service_id
;
USHORT
syscall
;
BYTE
ret
;
BYTE
pad
;
USHORT
xchg_ax_ax1
;
USHORT
xchg_ax_ax2
;
}
;
struct
ServiceEntryW8
{
ULONG64
mov_1
;
ULONG64
mov_2
;
ULONG
mov_3
;
ULONG
mov_r10_rcx_mov_eax
;
ULONG
service_id
;
USHORT
syscall
;
BYTE
ret
;
BYTE
nop
;
}
;
struct
ServiceEntryWithInt2E
{
ULONG
mov_r10_rcx_mov_eax
;
ULONG
service_id
;
USHORT
test_byte
;
BYTE
ptr
;
ULONG
user_shared_data_ptr
;
BYTE
one
;
USHORT
jne_over_syscall
;
USHORT
syscall
;
BYTE
ret
;
USHORT
int2e
;
BYTE
ret2
;
}
;
struct
ServiceFullThunk
{
union
{
ServiceEntry
original
;
ServiceEntryW8
original_w8
;
ServiceEntryWithInt2E
original_int2e_fallback
;
}
;
}
;
#
pragma
pack
(
pop
)
bool
IsService
(
const
void
*
source
)
{
const
ServiceEntry
*
service
=
reinterpret_cast
<
const
ServiceEntry
*
>
(
source
)
;
return
(
kMmovR10EcxMovEax
=
=
service
-
>
mov_r10_rcx_mov_eax
&
&
kSyscall
=
=
service
-
>
syscall
&
&
kRetNp
=
=
service
-
>
ret
)
;
}
bool
IsServiceW8
(
const
void
*
source
)
{
const
ServiceEntryW8
*
service
=
reinterpret_cast
<
const
ServiceEntryW8
*
>
(
source
)
;
return
(
kMmovR10EcxMovEax
=
=
service
-
>
mov_r10_rcx_mov_eax
&
&
kMov1
=
=
service
-
>
mov_1
&
&
kMov2
=
=
service
-
>
mov_2
&
&
kMov3
=
=
service
-
>
mov_3
)
;
}
bool
IsServiceWithInt2E
(
const
void
*
source
)
{
const
ServiceEntryWithInt2E
*
service
=
reinterpret_cast
<
const
ServiceEntryWithInt2E
*
>
(
source
)
;
return
(
kMmovR10EcxMovEax
=
=
service
-
>
mov_r10_rcx_mov_eax
&
&
kTestByte
=
=
service
-
>
test_byte
&
&
kPtr
=
=
service
-
>
ptr
&
&
kJne
=
=
service
-
>
jne_over_syscall
&
&
kSyscall
=
=
service
-
>
syscall
&
&
kRet
=
=
service
-
>
ret
&
&
kRet
=
=
service
-
>
ret2
)
;
}
bool
IsAnyService
(
const
void
*
source
)
{
return
IsService
(
source
)
|
|
IsServiceW8
(
source
)
|
|
IsServiceWithInt2E
(
source
)
;
}
#
elif
defined
(
_M_ARM64
)
#
pragma
pack
(
push
4
)
const
ULONG
kSvc
=
0xD4000001
;
const
ULONG
kRetNp
=
0xD65F03C0
;
const
ULONG
kServiceIdMask
=
0x001FFFE0
;
struct
ServiceEntry
{
ULONG
svc
;
ULONG
ret
;
ULONG64
unused
;
}
;
struct
ServiceFullThunk
{
ServiceEntry
original
;
}
;
#
pragma
pack
(
pop
)
bool
IsService
(
const
void
*
source
)
{
const
ServiceEntry
*
service
=
reinterpret_cast
<
const
ServiceEntry
*
>
(
source
)
;
return
(
kSvc
=
=
(
service
-
>
svc
&
~
kServiceIdMask
)
&
&
kRetNp
=
=
service
-
>
ret
&
&
0
=
=
service
-
>
unused
)
;
}
bool
IsAnyService
(
const
void
*
source
)
{
return
IsService
(
source
)
;
}
#
else
#
error
"
Unsupported
Windows
64
-
bit
Arch
"
#
endif
}
namespace
sandbox
{
NTSTATUS
ServiceResolverThunk
:
:
Setup
(
const
void
*
target_module
const
void
*
interceptor_module
const
char
*
target_name
const
char
*
interceptor_name
const
void
*
interceptor_entry_point
void
*
thunk_storage
size_t
storage_bytes
size_t
*
storage_used
)
{
NTSTATUS
ret
=
Init
(
target_module
interceptor_module
target_name
interceptor_name
interceptor_entry_point
thunk_storage
storage_bytes
)
;
if
(
!
NT_SUCCESS
(
ret
)
)
return
ret
;
size_t
thunk_bytes
=
GetThunkSize
(
)
;
std
:
:
unique_ptr
<
char
[
]
>
thunk_buffer
(
new
char
[
thunk_bytes
]
)
;
ServiceFullThunk
*
thunk
=
reinterpret_cast
<
ServiceFullThunk
*
>
(
thunk_buffer
.
get
(
)
)
;
if
(
!
IsFunctionAService
(
&
thunk
-
>
original
)
)
return
STATUS_OBJECT_NAME_COLLISION
;
ret
=
PerformPatch
(
thunk
thunk_storage
)
;
if
(
storage_used
)
*
storage_used
=
thunk_bytes
;
return
ret
;
}
size_t
ServiceResolverThunk
:
:
GetThunkSize
(
)
const
{
return
sizeof
(
ServiceFullThunk
)
;
}
NTSTATUS
ServiceResolverThunk
:
:
CopyThunk
(
const
void
*
target_module
const
char
*
target_name
BYTE
*
thunk_storage
size_t
storage_bytes
size_t
*
storage_used
)
{
NTSTATUS
ret
=
ResolveTarget
(
target_module
target_name
&
target_
)
;
if
(
!
NT_SUCCESS
(
ret
)
)
return
ret
;
size_t
thunk_bytes
=
GetThunkSize
(
)
;
if
(
storage_bytes
<
thunk_bytes
)
return
STATUS_UNSUCCESSFUL
;
ServiceFullThunk
*
thunk
=
reinterpret_cast
<
ServiceFullThunk
*
>
(
thunk_storage
)
;
if
(
!
IsFunctionAService
(
&
thunk
-
>
original
)
)
return
STATUS_OBJECT_NAME_COLLISION
;
if
(
storage_used
)
*
storage_used
=
thunk_bytes
;
return
ret
;
}
bool
ServiceResolverThunk
:
:
IsFunctionAService
(
void
*
local_thunk
)
const
{
ServiceFullThunk
function_code
;
SIZE_T
read
;
if
(
!
:
:
ReadProcessMemory
(
process_
target_
&
function_code
sizeof
(
function_code
)
&
read
)
)
return
false
;
if
(
sizeof
(
function_code
)
!
=
read
)
return
false
;
if
(
!
IsAnyService
(
&
function_code
)
)
return
false
;
memcpy
(
local_thunk
&
function_code
sizeof
(
function_code
)
)
;
return
true
;
}
NTSTATUS
ServiceResolverThunk
:
:
PerformPatch
(
void
*
local_thunk
void
*
remote_thunk
)
{
ServiceEntry
local_service
;
if
(
!
SetInternalThunk
(
&
local_service
sizeof
(
local_service
)
nullptr
interceptor_
)
)
return
STATUS_UNSUCCESSFUL
;
SIZE_T
actual
;
if
(
!
:
:
WriteProcessMemory
(
process_
remote_thunk
local_thunk
sizeof
(
ServiceFullThunk
)
&
actual
)
)
return
STATUS_UNSUCCESSFUL
;
if
(
sizeof
(
ServiceFullThunk
)
!
=
actual
)
return
STATUS_UNSUCCESSFUL
;
if
(
ntdll_base_
)
{
if
(
!
:
:
WriteProcessMemory
(
process_
target_
&
local_service
sizeof
(
local_service
)
&
actual
)
)
return
STATUS_UNSUCCESSFUL
;
}
else
{
if
(
!
WriteProtectedChildMemory
(
process_
target_
&
local_service
sizeof
(
local_service
)
)
)
return
STATUS_UNSUCCESSFUL
;
}
return
STATUS_SUCCESS
;
}
bool
ServiceResolverThunk
:
:
VerifyJumpTargetForTesting
(
void
*
)
const
{
return
true
;
}
}
