#
include
"
sandbox
/
win
/
src
/
interception
.
h
"
#
include
<
windows
.
h
>
#
include
<
stddef
.
h
>
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
set
>
#
include
"
base
/
bits
.
h
"
#
include
"
sandbox
/
win
/
src
/
interception_internal
.
h
"
#
include
"
sandbox
/
win
/
src
/
interceptors
.
h
"
#
include
"
sandbox
/
win
/
src
/
target_process
.
h
"
#
include
"
testing
/
gtest
/
include
/
gtest
/
gtest
.
h
"
namespace
sandbox
{
namespace
internal
{
size_t
GetGranularAlignedRandomOffset
(
size_t
size
)
;
}
void
WalkBuffer
(
void
*
buffer
size_t
size
int
*
num_dlls
int
*
num_functions
int
*
num_names
)
{
ASSERT_TRUE
(
buffer
)
;
ASSERT_TRUE
(
num_functions
)
;
ASSERT_TRUE
(
num_names
)
;
*
num_dlls
=
*
num_functions
=
*
num_names
=
0
;
SharedMemory
*
memory
=
reinterpret_cast
<
SharedMemory
*
>
(
buffer
)
;
ASSERT_GT
(
size
sizeof
(
SharedMemory
)
)
;
DllPatchInfo
*
dll
=
&
memory
-
>
dll_list
[
0
]
;
for
(
int
i
=
0
;
i
<
memory
-
>
num_intercepted_dlls
;
i
+
+
)
{
ASSERT_NE
(
0u
wcslen
(
dll
-
>
dll_name
)
)
;
ASSERT_EQ
(
0u
dll
-
>
record_bytes
%
sizeof
(
size_t
)
)
;
ASSERT_EQ
(
0u
dll
-
>
offset_to_functions
%
sizeof
(
size_t
)
)
;
ASSERT_NE
(
0
dll
-
>
num_functions
)
;
FunctionInfo
*
function
=
reinterpret_cast
<
FunctionInfo
*
>
(
reinterpret_cast
<
char
*
>
(
dll
)
+
dll
-
>
offset_to_functions
)
;
for
(
int
j
=
0
;
j
<
dll
-
>
num_functions
;
j
+
+
)
{
ASSERT_EQ
(
0u
function
-
>
record_bytes
%
sizeof
(
size_t
)
)
;
char
*
name
=
function
-
>
function
;
size_t
length
=
strlen
(
name
)
;
ASSERT_NE
(
0u
length
)
;
name
+
=
length
+
1
;
ASSERT_GT
(
reinterpret_cast
<
char
*
>
(
buffer
)
+
size
name
+
strlen
(
name
)
)
;
if
(
strlen
(
name
)
)
{
(
*
num_names
)
+
+
;
EXPECT_TRUE
(
!
function
-
>
interceptor_address
)
;
}
else
{
EXPECT_TRUE
(
function
-
>
interceptor_address
)
;
}
(
*
num_functions
)
+
+
;
function
=
reinterpret_cast
<
FunctionInfo
*
>
(
reinterpret_cast
<
char
*
>
(
function
)
+
function
-
>
record_bytes
)
;
}
(
*
num_dlls
)
+
+
;
dll
=
reinterpret_cast
<
DllPatchInfo
*
>
(
reinterpret_cast
<
char
*
>
(
dll
)
+
dll
-
>
record_bytes
)
;
}
}
TEST
(
InterceptionManagerTest
GetGranularAlignedRandomOffset
)
{
std
:
:
set
<
size_t
>
sizes
;
const
size_t
kThunkBytes
=
544
;
const
size_t
kAlignmentBits
=
base
:
:
bits
:
:
Log2Ceiling
(
kThunkBytes
)
;
const
size_t
kAlignment
=
static_cast
<
size_t
>
(
1
)
<
<
kAlignmentBits
;
const
size_t
kAllocGranularity
=
65536
;
for
(
size_t
i
=
0
;
i
<
1000000
;
i
+
+
)
sizes
.
insert
(
internal
:
:
GetGranularAlignedRandomOffset
(
kThunkBytes
)
)
;
size_t
prev_val
=
0
;
size_t
min_val
=
kAllocGranularity
;
size_t
min_nonzero_val
=
kAllocGranularity
;
size_t
max_val
=
0
;
for
(
size_t
val
:
sizes
)
{
ASSERT_LT
(
val
kAllocGranularity
)
;
if
(
prev_val
)
ASSERT_EQ
(
val
-
prev_val
kAlignment
)
;
if
(
val
)
min_nonzero_val
=
std
:
:
min
(
val
min_nonzero_val
)
;
min_val
=
std
:
:
min
(
val
min_val
)
;
prev_val
=
val
;
max_val
=
std
:
:
max
(
val
max_val
)
;
}
ASSERT_EQ
(
max_val
kAllocGranularity
-
kAlignment
)
;
ASSERT_EQ
(
0u
min_val
)
;
ASSERT_EQ
(
min_nonzero_val
kAlignment
)
;
}
TEST
(
InterceptionManagerTest
BufferLayout1
)
{
wchar_t
exe_name
[
MAX_PATH
]
;
ASSERT_NE
(
0u
GetModuleFileName
(
nullptr
exe_name
MAX_PATH
-
1
)
)
;
TargetProcess
*
target
=
MakeTestTargetProcess
(
:
:
GetCurrentProcess
(
)
:
:
GetModuleHandle
(
exe_name
)
)
;
InterceptionManager
interceptions
(
target
true
)
;
void
*
function
=
&
interceptions
;
interceptions
.
AddToPatchedFunctions
(
L
"
ntdll
.
dll
"
"
NtCreateFile
"
INTERCEPTION_SERVICE_CALL
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
kernel32
.
dll
"
"
CreateFileEx
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
kernel32
.
dll
"
"
SomeFileEx
"
INTERCEPTION_SMART_SIDESTEP
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
user32
.
dll
"
"
FindWindow
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
kernel32
.
dll
"
"
CreateMutex
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
user32
.
dll
"
"
PostMsg
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
user32
.
dll
"
"
PostMsg
"
INTERCEPTION_EAT
"
replacement
"
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
comctl
.
dll
"
"
SaveAsDlg
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
ntdll
.
dll
"
"
NtClose
"
INTERCEPTION_SERVICE_CALL
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
ntdll
.
dll
"
"
NtOpenFile
"
INTERCEPTION_SIDESTEP
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
some
.
dll
"
"
Superfn
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
comctl
.
dll
"
"
SaveAsDlg
"
INTERCEPTION_EAT
"
a
"
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
comctl
.
dll
"
"
SaveAsDlg
"
INTERCEPTION_SIDESTEP
"
ab
"
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
comctl
.
dll
"
"
SaveAsDlg
"
INTERCEPTION_EAT
"
abc
"
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
a
.
dll
"
"
p
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
b
.
dll
"
"
TheIncredibleCallToSaveTheWorld
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
a
.
dll
"
"
BIsLame
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
a
.
dll
"
"
ARules
"
INTERCEPTION_EAT
function
OPEN_KEY_ID
)
;
ASSERT_EQ
(
18u
interceptions
.
interceptions_
.
size
(
)
)
;
size_t
buffer_size
=
interceptions
.
GetBufferSize
(
)
;
std
:
:
unique_ptr
<
BYTE
[
]
>
local_buffer
(
new
BYTE
[
buffer_size
]
)
;
ASSERT_TRUE
(
interceptions
.
SetupConfigBuffer
(
local_buffer
.
get
(
)
buffer_size
)
)
;
EXPECT_EQ
(
3u
interceptions
.
interceptions_
.
size
(
)
)
;
int
num_dlls
num_functions
num_names
;
WalkBuffer
(
local_buffer
.
get
(
)
buffer_size
&
num_dlls
&
num_functions
&
num_names
)
;
EXPECT_EQ
(
6
num_dlls
)
;
EXPECT_EQ
(
15
num_functions
)
;
EXPECT_EQ
(
4
num_names
)
;
}
TEST
(
InterceptionManagerTest
BufferLayout2
)
{
wchar_t
exe_name
[
MAX_PATH
]
;
ASSERT_NE
(
0u
GetModuleFileName
(
nullptr
exe_name
MAX_PATH
-
1
)
)
;
TargetProcess
*
target
=
MakeTestTargetProcess
(
:
:
GetCurrentProcess
(
)
:
:
GetModuleHandle
(
exe_name
)
)
;
InterceptionManager
interceptions
(
target
true
)
;
void
*
function
=
&
interceptions
;
interceptions
.
AddToUnloadModules
(
L
"
some01
.
dll
"
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
ntdll
.
dll
"
"
NtCreateFile
"
INTERCEPTION_SERVICE_CALL
function
OPEN_FILE_ID
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
kernel32
.
dll
"
"
CreateFileEx
"
INTERCEPTION_EAT
function
OPEN_FILE_ID
)
;
interceptions
.
AddToUnloadModules
(
L
"
some02
.
dll
"
)
;
interceptions
.
AddToPatchedFunctions
(
L
"
kernel32
.
dll
"
"
SomeFileEx
"
INTERCEPTION_SMART_SIDESTEP
function
OPEN_FILE_ID
)
;
ASSERT_EQ
(
5u
interceptions
.
interceptions_
.
size
(
)
)
;
size_t
buffer_size
=
interceptions
.
GetBufferSize
(
)
;
std
:
:
unique_ptr
<
BYTE
[
]
>
local_buffer
(
new
BYTE
[
buffer_size
]
)
;
ASSERT_TRUE
(
interceptions
.
SetupConfigBuffer
(
local_buffer
.
get
(
)
buffer_size
)
)
;
EXPECT_EQ
(
1u
interceptions
.
interceptions_
.
size
(
)
)
;
int
num_dlls
num_functions
num_names
;
WalkBuffer
(
local_buffer
.
get
(
)
buffer_size
&
num_dlls
&
num_functions
&
num_names
)
;
EXPECT_EQ
(
3
num_dlls
)
;
EXPECT_EQ
(
4
num_functions
)
;
EXPECT_EQ
(
0
num_names
)
;
}
}
