#
include
"
sandbox
/
win
/
src
/
crosscall_server
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
atomic
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
strings
/
utf_string_conversions
.
h
"
#
include
"
sandbox
/
win
/
src
/
crosscall_client
.
h
"
#
include
"
sandbox
/
win
/
src
/
crosscall_params
.
h
"
#
undef
MemoryBarrier
namespace
{
const
size_t
kMaxBufferSize
=
sandbox
:
:
kIPCChannelSize
;
}
namespace
sandbox
{
typedef
ActualCallParams
<
0
kMaxBufferSize
>
ActualCP0
;
typedef
ActualCallParams
<
1
kMaxBufferSize
>
ActualCP1
;
typedef
ActualCallParams
<
2
kMaxBufferSize
>
ActualCP2
;
typedef
ActualCallParams
<
3
kMaxBufferSize
>
ActualCP3
;
typedef
ActualCallParams
<
4
kMaxBufferSize
>
ActualCP4
;
typedef
ActualCallParams
<
5
kMaxBufferSize
>
ActualCP5
;
typedef
ActualCallParams
<
6
kMaxBufferSize
>
ActualCP6
;
typedef
ActualCallParams
<
7
kMaxBufferSize
>
ActualCP7
;
typedef
ActualCallParams
<
8
kMaxBufferSize
>
ActualCP8
;
typedef
ActualCallParams
<
9
kMaxBufferSize
>
ActualCP9
;
uint32_t
GetActualBufferSize
(
uint32_t
param_count
void
*
buffer_base
)
{
switch
(
param_count
)
{
case
0
:
return
0
;
case
1
:
return
reinterpret_cast
<
ActualCP1
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
case
2
:
return
reinterpret_cast
<
ActualCP2
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
case
3
:
return
reinterpret_cast
<
ActualCP3
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
case
4
:
return
reinterpret_cast
<
ActualCP4
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
case
5
:
return
reinterpret_cast
<
ActualCP5
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
case
6
:
return
reinterpret_cast
<
ActualCP6
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
case
7
:
return
reinterpret_cast
<
ActualCP7
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
case
8
:
return
reinterpret_cast
<
ActualCP8
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
case
9
:
return
reinterpret_cast
<
ActualCP9
*
>
(
buffer_base
)
-
>
GetSize
(
)
;
default
:
return
0
;
}
}
uint32_t
GetMinDeclaredActualCallParamsSize
(
uint32_t
param_count
)
{
switch
(
param_count
)
{
case
0
:
return
offsetof
(
ActualCP0
parameters_
)
;
case
1
:
return
offsetof
(
ActualCP1
parameters_
)
;
case
2
:
return
offsetof
(
ActualCP2
parameters_
)
;
case
3
:
return
offsetof
(
ActualCP3
parameters_
)
;
case
4
:
return
offsetof
(
ActualCP4
parameters_
)
;
case
5
:
return
offsetof
(
ActualCP5
parameters_
)
;
case
6
:
return
offsetof
(
ActualCP6
parameters_
)
;
case
7
:
return
offsetof
(
ActualCP7
parameters_
)
;
case
8
:
return
offsetof
(
ActualCP8
parameters_
)
;
case
9
:
return
offsetof
(
ActualCP9
parameters_
)
;
default
:
return
0
;
}
}
bool
IsSizeWithinRange
(
uint32_t
buffer_size
uint32_t
min_declared_size
uint32_t
declared_size
)
{
if
(
(
buffer_size
<
min_declared_size
)
|
|
(
sizeof
(
CrossCallParamsEx
)
>
min_declared_size
)
)
{
return
false
;
}
if
(
(
declared_size
>
buffer_size
)
|
|
(
declared_size
<
min_declared_size
)
)
{
return
false
;
}
return
true
;
}
CrossCallParamsEx
:
:
CrossCallParamsEx
(
)
:
CrossCallParams
(
IpcTag
:
:
UNUSED
0
)
{
}
void
CrossCallParamsEx
:
:
operator
delete
(
void
*
raw_memory
)
throw
(
)
{
if
(
!
raw_memory
)
{
return
;
}
delete
[
]
reinterpret_cast
<
char
*
>
(
raw_memory
)
;
}
CrossCallParamsEx
*
CrossCallParamsEx
:
:
CreateFromBuffer
(
void
*
buffer_base
uint32_t
buffer_size
uint32_t
*
output_size
)
{
if
(
!
buffer_base
)
return
nullptr
;
if
(
buffer_size
<
sizeof
(
CrossCallParams
)
)
return
nullptr
;
if
(
buffer_size
>
kMaxBufferSize
)
return
nullptr
;
char
*
backing_mem
=
nullptr
;
uint32_t
param_count
=
0
;
uint32_t
declared_size
;
uint32_t
min_declared_size
;
CrossCallParamsEx
*
copied_params
=
nullptr
;
__try
{
CrossCallParams
*
call_params
=
reinterpret_cast
<
CrossCallParams
*
>
(
buffer_base
)
;
param_count
=
call_params
-
>
GetParamsCount
(
)
;
min_declared_size
=
GetMinDeclaredActualCallParamsSize
(
param_count
)
;
if
(
buffer_size
<
min_declared_size
)
return
nullptr
;
declared_size
=
GetActualBufferSize
(
param_count
buffer_base
)
;
if
(
!
IsSizeWithinRange
(
buffer_size
min_declared_size
declared_size
)
)
return
nullptr
;
*
output_size
=
declared_size
;
backing_mem
=
new
char
[
declared_size
]
;
copied_params
=
reinterpret_cast
<
CrossCallParamsEx
*
>
(
backing_mem
)
;
memcpy
(
backing_mem
call_params
declared_size
)
;
std
:
:
atomic_thread_fence
(
std
:
:
memory_order_seq_cst
)
;
min_declared_size
=
GetMinDeclaredActualCallParamsSize
(
param_count
)
;
if
(
copied_params
-
>
GetParamsCount
(
)
!
=
param_count
|
|
GetActualBufferSize
(
param_count
backing_mem
)
!
=
declared_size
|
|
!
IsSizeWithinRange
(
buffer_size
min_declared_size
declared_size
)
)
{
delete
[
]
backing_mem
;
return
nullptr
;
}
}
__except
(
EXCEPTION_EXECUTE_HANDLER
)
{
delete
[
]
backing_mem
;
return
nullptr
;
}
auto
backing_mem_ptr
=
reinterpret_cast
<
uintptr_t
>
(
backing_mem
)
;
auto
last_byte
=
reinterpret_cast
<
uintptr_t
>
(
&
backing_mem
[
declared_size
]
)
;
auto
first_byte
=
reinterpret_cast
<
uintptr_t
>
(
&
backing_mem
[
min_declared_size
]
)
;
for
(
uint32_t
ix
=
0
;
ix
!
=
param_count
;
+
+
ix
)
{
uint32_t
size
=
0
;
ArgType
type
;
auto
address
=
reinterpret_cast
<
uintptr_t
>
(
copied_params
-
>
GetRawParameter
(
ix
&
size
&
type
)
)
;
if
(
(
!
address
)
|
|
(
INVALID_TYPE
>
=
type
)
|
|
(
LAST_TYPE
<
=
type
)
|
|
(
address
<
backing_mem_ptr
)
|
|
(
address
<
first_byte
)
|
|
(
address
>
last_byte
)
|
|
(
(
address
+
size
)
<
address
)
|
|
(
(
address
+
size
)
>
last_byte
)
)
{
delete
[
]
backing_mem
;
return
nullptr
;
}
}
return
copied_params
;
}
void
*
CrossCallParamsEx
:
:
GetRawParameter
(
uint32_t
index
uint32_t
*
size
ArgType
*
type
)
{
if
(
index
>
=
GetParamsCount
(
)
)
return
nullptr
;
*
size
=
param_info_
[
index
]
.
size_
;
*
type
=
param_info_
[
index
]
.
type_
;
return
param_info_
[
index
]
.
offset_
+
reinterpret_cast
<
char
*
>
(
this
)
;
}
bool
CrossCallParamsEx
:
:
GetParameter32
(
uint32_t
index
uint32_t
*
param
)
{
uint32_t
size
=
0
;
ArgType
type
;
void
*
start
=
GetRawParameter
(
index
&
size
&
type
)
;
if
(
!
start
|
|
(
4
!
=
size
)
|
|
(
UINT32_TYPE
!
=
type
)
)
return
false
;
*
(
reinterpret_cast
<
uint32_t
*
>
(
param
)
)
=
*
(
reinterpret_cast
<
uint32_t
*
>
(
start
)
)
;
return
true
;
}
bool
CrossCallParamsEx
:
:
GetParameterVoidPtr
(
uint32_t
index
void
*
*
param
)
{
uint32_t
size
=
0
;
ArgType
type
;
void
*
start
=
GetRawParameter
(
index
&
size
&
type
)
;
if
(
!
start
|
|
(
sizeof
(
void
*
)
!
=
size
)
|
|
(
VOIDPTR_TYPE
!
=
type
)
)
return
false
;
*
param
=
*
(
reinterpret_cast
<
void
*
*
>
(
start
)
)
;
return
true
;
}
bool
CrossCallParamsEx
:
:
GetParameterStr
(
uint32_t
index
std
:
:
wstring
*
string
)
{
DCHECK
(
string
-
>
empty
(
)
)
;
uint32_t
size
=
0
;
ArgType
type
;
void
*
start
=
GetRawParameter
(
index
&
size
&
type
)
;
if
(
WCHAR_TYPE
!
=
type
)
return
false
;
if
(
size
=
=
0
)
{
*
string
=
std
:
:
wstring
(
)
;
return
true
;
}
if
(
!
start
|
|
(
(
size
%
sizeof
(
wchar_t
)
)
!
=
0
)
)
return
false
;
string
-
>
assign
(
reinterpret_cast
<
const
wchar_t
*
>
(
start
)
size
/
sizeof
(
wchar_t
)
)
;
return
true
;
}
bool
CrossCallParamsEx
:
:
GetParameterPtr
(
uint32_t
index
uint32_t
expected_size
void
*
*
pointer
)
{
uint32_t
size
=
0
;
ArgType
type
;
void
*
start
=
GetRawParameter
(
index
&
size
&
type
)
;
if
(
(
size
!
=
expected_size
)
|
|
(
INOUTPTR_TYPE
!
=
type
&
&
INPTR_TYPE
!
=
type
)
)
return
false
;
if
(
!
start
)
return
false
;
*
pointer
=
start
;
return
true
;
}
void
SetCallError
(
ResultCode
error
CrossCallReturn
*
call_return
)
{
call_return
-
>
call_outcome
=
error
;
call_return
-
>
extended_count
=
0
;
}
void
SetCallSuccess
(
CrossCallReturn
*
call_return
)
{
call_return
-
>
call_outcome
=
SBOX_ALL_OK
;
}
Dispatcher
*
Dispatcher
:
:
OnMessageReady
(
IPCParams
*
ipc
CallbackGeneric
*
callback
)
{
DCHECK
(
callback
)
;
std
:
:
vector
<
IPCCall
>
:
:
iterator
it
=
ipc_calls_
.
begin
(
)
;
for
(
;
it
!
=
ipc_calls_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
params
.
Matches
(
ipc
)
)
{
*
callback
=
it
-
>
callback
;
return
this
;
}
}
return
nullptr
;
}
Dispatcher
:
:
Dispatcher
(
)
{
}
Dispatcher
:
:
~
Dispatcher
(
)
{
}
}
