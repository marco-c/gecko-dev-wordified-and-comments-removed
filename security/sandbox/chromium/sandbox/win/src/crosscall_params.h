#
ifndef
SANDBOX_WIN_SRC_CROSSCALL_PARAMS_H_
#
define
SANDBOX_WIN_SRC_CROSSCALL_PARAMS_H_
#
include
<
windows
.
h
>
#
include
<
lmaccess
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
#
include
"
sandbox
/
win
/
src
/
internal_types
.
h
"
#
include
"
sandbox
/
win
/
src
/
ipc_tags
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_nt_types
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_types
.
h
"
namespace
sandbox
{
const
uint32_t
kIPCChannelSize
=
1024
;
SANDBOX_INTERCEPT
NtExports
g_nt
;
namespace
{
inline
uint32_t
Align
(
uint32_t
value
)
{
uint32_t
alignment
=
sizeof
(
int64_t
)
;
return
(
(
value
+
alignment
-
1
)
/
alignment
)
*
alignment
;
}
inline
void
*
memcpy_wrapper
(
void
*
dest
const
void
*
src
size_t
count
)
{
if
(
g_nt
.
memcpy
)
return
g_nt
.
memcpy
(
dest
src
count
)
;
return
memcpy
(
dest
src
count
)
;
}
}
const
size_t
kExtendedReturnCount
=
8
;
union
MultiType
{
uint32_t
unsigned_int
;
RAW_PTR_EXCLUSION
void
*
pointer
;
HANDLE
handle
;
ULONG_PTR
ulong_ptr
;
}
;
const
int
kMaxIpcParams
=
9
;
struct
ParamInfo
{
ArgType
type_
;
uint32_t
offset_
;
uint32_t
size_
;
}
;
struct
CrossCallReturn
{
uint32_t
tag
;
ResultCode
call_outcome
;
union
{
NTSTATUS
nt_status
;
DWORD
win32_result
;
}
;
uint32_t
extended_count
;
HANDLE
handle
;
MultiType
extended
[
kExtendedReturnCount
]
;
}
;
class
CrossCallParams
{
public
:
CrossCallParams
(
const
CrossCallParams
&
)
=
delete
;
CrossCallParams
&
operator
=
(
const
CrossCallParams
&
)
=
delete
;
IpcTag
GetTag
(
)
const
{
return
tag_
;
}
const
void
*
GetBuffer
(
)
const
{
return
this
;
}
uint32_t
GetParamsCount
(
)
const
{
return
params_count_
;
}
CrossCallReturn
*
GetCallReturn
(
)
{
return
&
call_return
;
}
bool
IsInOut
(
)
const
{
return
(
1
=
=
is_in_out_
)
;
}
void
SetIsInOut
(
bool
value
)
{
if
(
value
)
is_in_out_
=
1
;
else
is_in_out_
=
0
;
}
protected
:
CrossCallParams
(
IpcTag
tag
uint32_t
params_count
)
:
tag_
(
tag
)
is_in_out_
(
0
)
params_count_
(
params_count
)
{
}
private
:
IpcTag
tag_
;
uint32_t
is_in_out_
;
CrossCallReturn
call_return
;
const
uint32_t
params_count_
;
}
;
template
<
size_t
NUMBER_PARAMS
size_t
BLOCK_SIZE
>
class
ActualCallParams
:
public
CrossCallParams
{
public
:
explicit
ActualCallParams
(
IpcTag
tag
)
:
CrossCallParams
(
tag
NUMBER_PARAMS
)
{
param_info_
[
0
]
.
offset_
=
static_cast
<
uint32_t
>
(
parameters_
-
reinterpret_cast
<
char
*
>
(
this
)
)
;
}
ActualCallParams
(
IpcTag
tag
uint32_t
number_params
)
:
CrossCallParams
(
tag
number_params
)
{
param_info_
[
0
]
.
offset_
=
static_cast
<
uint32_t
>
(
parameters_
-
reinterpret_cast
<
char
*
>
(
this
)
)
;
}
ActualCallParams
(
const
ActualCallParams
&
)
=
delete
;
ActualCallParams
&
operator
=
(
const
ActualCallParams
&
)
=
delete
;
static
constexpr
size_t
MaxParamsSize
(
)
{
return
sizeof
(
ActualCallParams
<
NUMBER_PARAMS
kIPCChannelSize
>
:
:
parameters_
)
;
}
uint32_t
OverrideSize
(
uint32_t
new_size
)
{
uint32_t
previous_size
=
param_info_
[
NUMBER_PARAMS
]
.
offset_
;
param_info_
[
NUMBER_PARAMS
]
.
offset_
=
new_size
;
return
previous_size
;
}
bool
CopyParamIn
(
uint32_t
index
const
void
*
parameter_address
uint32_t
size
bool
is_in_out
ArgType
type
)
{
if
(
index
>
=
NUMBER_PARAMS
)
{
return
false
;
}
if
(
UINT32_MAX
=
=
size
)
{
return
false
;
}
if
(
size
&
&
!
parameter_address
)
{
return
false
;
}
if
(
(
size
>
sizeof
(
*
this
)
)
|
|
(
param_info_
[
index
]
.
offset_
>
(
sizeof
(
*
this
)
-
size
)
)
)
{
return
false
;
}
char
*
dest
=
reinterpret_cast
<
char
*
>
(
this
)
+
param_info_
[
index
]
.
offset_
;
__try
{
memcpy_wrapper
(
dest
parameter_address
size
)
;
}
__except
(
EXCEPTION_EXECUTE_HANDLER
)
{
return
false
;
}
if
(
is_in_out
)
SetIsInOut
(
true
)
;
param_info_
[
index
+
1
]
.
offset_
=
Align
(
param_info_
[
index
]
.
offset_
+
size
)
;
param_info_
[
index
]
.
size_
=
size
;
param_info_
[
index
]
.
type_
=
type
;
return
true
;
}
void
*
GetParamPtr
(
size_t
index
)
{
return
reinterpret_cast
<
char
*
>
(
this
)
+
param_info_
[
index
]
.
offset_
;
}
uint32_t
GetSize
(
)
const
{
return
param_info_
[
NUMBER_PARAMS
]
.
offset_
;
}
protected
:
ActualCallParams
(
)
:
CrossCallParams
(
IpcTag
:
:
UNUSED
NUMBER_PARAMS
)
{
}
private
:
ParamInfo
param_info_
[
NUMBER_PARAMS
+
1
]
;
char
parameters_
[
BLOCK_SIZE
-
sizeof
(
CrossCallParams
)
-
sizeof
(
ParamInfo
)
*
(
NUMBER_PARAMS
+
1
)
]
;
friend
uint32_t
GetMinDeclaredActualCallParamsSize
(
uint32_t
param_count
)
;
}
;
static_assert
(
sizeof
(
ActualCallParams
<
1
1024
>
)
=
=
1024
"
bad
size
buffer
"
)
;
static_assert
(
sizeof
(
ActualCallParams
<
2
1024
>
)
=
=
1024
"
bad
size
buffer
"
)
;
static_assert
(
sizeof
(
ActualCallParams
<
3
1024
>
)
=
=
1024
"
bad
size
buffer
"
)
;
}
#
endif
