#
include
"
sandbox
/
win
/
src
/
win_utils
.
h
"
#
include
<
psapi
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
base
/
numerics
/
safe_math
.
h
"
#
include
"
base
/
stl_util
.
h
"
#
include
"
base
/
strings
/
string16
.
h
"
#
include
"
base
/
strings
/
string_util
.
h
"
#
include
"
base
/
win
/
pe_image
.
h
"
#
include
"
sandbox
/
win
/
src
/
internal_types
.
h
"
#
include
"
sandbox
/
win
/
src
/
nt_internals
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_nt_util
.
h
"
namespace
{
const
size_t
kDriveLetterLen
=
3
;
constexpr
wchar_t
kNTDotPrefix
[
]
=
L
"
\
\
\
\
.
\
\
"
;
const
size_t
kNTDotPrefixLen
=
base
:
:
size
(
kNTDotPrefix
)
-
1
;
struct
KnownReservedKey
{
const
wchar_t
*
name
;
HKEY
key
;
}
;
const
KnownReservedKey
kKnownKey
[
]
=
{
{
L
"
HKEY_CLASSES_ROOT
"
HKEY_CLASSES_ROOT
}
{
L
"
HKEY_CURRENT_USER
"
HKEY_CURRENT_USER
}
{
L
"
HKEY_LOCAL_MACHINE
"
HKEY_LOCAL_MACHINE
}
{
L
"
HKEY_USERS
"
HKEY_USERS
}
{
L
"
HKEY_PERFORMANCE_DATA
"
HKEY_PERFORMANCE_DATA
}
{
L
"
HKEY_PERFORMANCE_TEXT
"
HKEY_PERFORMANCE_TEXT
}
{
L
"
HKEY_PERFORMANCE_NLSTEXT
"
HKEY_PERFORMANCE_NLSTEXT
}
{
L
"
HKEY_CURRENT_CONFIG
"
HKEY_CURRENT_CONFIG
}
{
L
"
HKEY_DYN_DATA
"
HKEY_DYN_DATA
}
}
;
bool
EqualPath
(
const
base
:
:
string16
&
first
const
base
:
:
string16
&
second
)
{
return
_wcsicmp
(
first
.
c_str
(
)
second
.
c_str
(
)
)
=
=
0
;
}
bool
EqualPath
(
const
base
:
:
string16
&
first
size_t
first_offset
const
base
:
:
string16
&
second
size_t
second_offset
)
{
return
_wcsicmp
(
first
.
c_str
(
)
+
first_offset
second
.
c_str
(
)
+
second_offset
)
=
=
0
;
}
bool
EqualPath
(
const
base
:
:
string16
&
first
const
wchar_t
*
second
size_t
second_len
)
{
return
_wcsnicmp
(
first
.
c_str
(
)
second
second_len
)
=
=
0
;
}
bool
EqualPath
(
const
base
:
:
string16
&
first
size_t
first_offset
const
wchar_t
*
second
size_t
second_len
)
{
return
_wcsnicmp
(
first
.
c_str
(
)
+
first_offset
second
second_len
)
=
=
0
;
}
bool
IsNTPath
(
const
base
:
:
string16
&
path
base
:
:
string16
*
trimmed_path
)
{
if
(
(
path
.
size
(
)
<
sandbox
:
:
kNTPrefixLen
)
|
|
!
EqualPath
(
path
sandbox
:
:
kNTPrefix
sandbox
:
:
kNTPrefixLen
)
)
{
*
trimmed_path
=
path
;
return
false
;
}
*
trimmed_path
=
path
.
substr
(
sandbox
:
:
kNTPrefixLen
)
;
return
true
;
}
bool
IsDevicePath
(
const
base
:
:
string16
&
path
base
:
:
string16
*
trimmed_path
)
{
if
(
(
path
.
size
(
)
<
sandbox
:
:
kNTDevicePrefixLen
)
|
|
(
!
EqualPath
(
path
sandbox
:
:
kNTDevicePrefix
sandbox
:
:
kNTDevicePrefixLen
)
)
)
{
*
trimmed_path
=
path
;
return
false
;
}
*
trimmed_path
=
path
.
substr
(
sandbox
:
:
kNTDevicePrefixLen
)
;
return
true
;
}
size_t
PassHarddiskVolume
(
const
base
:
:
string16
&
path
)
{
static
constexpr
wchar_t
pattern
[
]
=
L
"
\
\
Device
\
\
HarddiskVolume
"
;
const
size_t
patternLen
=
base
:
:
size
(
pattern
)
-
1
;
if
(
(
path
.
size
(
)
<
patternLen
)
|
|
(
!
EqualPath
(
path
pattern
patternLen
)
)
)
return
base
:
:
string16
:
:
npos
;
return
path
.
find_first_of
(
L
'
\
\
'
patternLen
-
1
)
;
}
bool
IsDeviceHarddiskPath
(
const
base
:
:
string16
&
path
base
:
:
string16
*
trimmed_path
base
:
:
string16
*
removed
)
{
size_t
offset
=
PassHarddiskVolume
(
path
)
;
if
(
offset
=
=
base
:
:
string16
:
:
npos
)
return
false
;
*
removed
=
path
.
substr
(
0
offset
+
1
)
;
*
trimmed_path
=
path
.
substr
(
offset
+
1
)
;
return
true
;
}
bool
StartsWithDriveLetter
(
const
base
:
:
string16
&
path
)
{
if
(
path
.
size
(
)
<
kDriveLetterLen
)
return
false
;
if
(
path
[
1
]
!
=
L
'
:
'
|
|
path
[
2
]
!
=
L
'
\
\
'
)
return
false
;
return
base
:
:
IsAsciiAlpha
(
path
[
0
]
)
;
}
void
RemoveImpliedDevice
(
base
:
:
string16
*
path
)
{
if
(
EqualPath
(
*
path
kNTDotPrefix
kNTDotPrefixLen
)
)
*
path
=
path
-
>
substr
(
kNTDotPrefixLen
)
;
}
}
namespace
sandbox
{
bool
IsPipe
(
const
base
:
:
string16
&
path
)
{
size_t
start
=
0
;
if
(
EqualPath
(
path
sandbox
:
:
kNTPrefix
sandbox
:
:
kNTPrefixLen
)
)
start
=
sandbox
:
:
kNTPrefixLen
;
const
wchar_t
kPipe
[
]
=
L
"
pipe
\
\
"
;
if
(
path
.
size
(
)
<
start
+
base
:
:
size
(
kPipe
)
-
1
)
return
false
;
return
EqualPath
(
path
start
kPipe
base
:
:
size
(
kPipe
)
-
1
)
;
}
HKEY
GetReservedKeyFromName
(
const
base
:
:
string16
&
name
)
{
for
(
size_t
i
=
0
;
i
<
base
:
:
size
(
kKnownKey
)
;
+
+
i
)
{
if
(
name
=
=
kKnownKey
[
i
]
.
name
)
return
kKnownKey
[
i
]
.
key
;
}
return
nullptr
;
}
bool
ResolveRegistryName
(
base
:
:
string16
name
base
:
:
string16
*
resolved_name
)
{
for
(
size_t
i
=
0
;
i
<
base
:
:
size
(
kKnownKey
)
;
+
+
i
)
{
if
(
name
.
find
(
kKnownKey
[
i
]
.
name
)
=
=
0
)
{
HKEY
key
;
DWORD
disposition
;
if
(
ERROR_SUCCESS
!
=
:
:
RegCreateKeyEx
(
kKnownKey
[
i
]
.
key
L
"
"
0
nullptr
0
MAXIMUM_ALLOWED
nullptr
&
key
&
disposition
)
)
return
false
;
bool
result
=
GetPathFromHandle
(
key
resolved_name
)
;
:
:
RegCloseKey
(
key
)
;
if
(
!
result
)
return
false
;
*
resolved_name
+
=
name
.
substr
(
wcslen
(
kKnownKey
[
i
]
.
name
)
)
;
return
true
;
}
}
return
false
;
}
DWORD
IsReparsePoint
(
const
base
:
:
string16
&
full_path
)
{
if
(
IsPipe
(
full_path
)
)
return
ERROR_NOT_A_REPARSE_POINT
;
base
:
:
string16
path
;
bool
nt_path
=
IsNTPath
(
full_path
&
path
)
;
bool
has_drive
=
StartsWithDriveLetter
(
path
)
;
bool
is_device_path
=
IsDevicePath
(
path
&
path
)
;
if
(
!
has_drive
&
&
!
is_device_path
&
&
!
nt_path
)
return
ERROR_INVALID_NAME
;
bool
added_implied_device
=
false
;
if
(
!
has_drive
)
{
path
=
base
:
:
string16
(
kNTDotPrefix
)
+
path
;
added_implied_device
=
true
;
}
base
:
:
string16
:
:
size_type
last_pos
=
base
:
:
string16
:
:
npos
;
bool
passed_once
=
false
;
do
{
path
=
path
.
substr
(
0
last_pos
)
;
DWORD
attributes
=
:
:
GetFileAttributes
(
path
.
c_str
(
)
)
;
if
(
INVALID_FILE_ATTRIBUTES
=
=
attributes
)
{
DWORD
error
=
:
:
GetLastError
(
)
;
if
(
error
!
=
ERROR_FILE_NOT_FOUND
&
&
error
!
=
ERROR_PATH_NOT_FOUND
&
&
error
!
=
ERROR_INVALID_NAME
)
{
if
(
passed_once
&
&
added_implied_device
&
&
(
path
.
rfind
(
L
'
\
\
'
)
=
=
kNTDotPrefixLen
-
1
)
)
{
break
;
}
NOTREACHED_NT
(
)
;
return
error
;
}
}
else
if
(
FILE_ATTRIBUTE_REPARSE_POINT
&
attributes
)
{
return
ERROR_SUCCESS
;
}
passed_once
=
true
;
last_pos
=
path
.
rfind
(
L
'
\
\
'
)
;
}
while
(
last_pos
>
2
)
;
return
ERROR_NOT_A_REPARSE_POINT
;
}
bool
SameObject
(
HANDLE
handle
const
wchar_t
*
full_path
)
{
if
(
IsPipe
(
full_path
)
)
return
true
;
base
:
:
string16
actual_path
;
if
(
!
GetPathFromHandle
(
handle
&
actual_path
)
)
return
false
;
base
:
:
string16
path
(
full_path
)
;
DCHECK_NT
(
!
path
.
empty
(
)
)
;
const
wchar_t
kBackslash
=
'
\
\
'
;
if
(
path
.
back
(
)
=
=
kBackslash
)
path
=
path
.
substr
(
0
path
.
length
(
)
-
1
)
;
if
(
EqualPath
(
actual_path
path
)
)
return
true
;
bool
nt_path
=
IsNTPath
(
path
&
path
)
;
bool
has_drive
=
StartsWithDriveLetter
(
path
)
;
if
(
!
has_drive
&
&
nt_path
)
{
base
:
:
string16
simple_actual_path
;
if
(
!
IsDevicePath
(
actual_path
&
simple_actual_path
)
)
return
false
;
return
(
EqualPath
(
simple_actual_path
path
)
)
;
}
if
(
!
has_drive
)
return
false
;
wchar_t
drive
[
4
]
=
{
0
}
;
wchar_t
vol_name
[
MAX_PATH
]
;
memcpy
(
drive
&
path
[
0
]
2
*
sizeof
(
*
drive
)
)
;
DWORD
vol_length
=
:
:
QueryDosDeviceW
(
drive
vol_name
MAX_PATH
)
;
if
(
vol_length
<
2
|
|
vol_length
=
=
MAX_PATH
)
return
false
;
vol_length
=
static_cast
<
DWORD
>
(
wcslen
(
vol_name
)
)
;
if
(
vol_length
+
path
.
size
(
)
-
2
!
=
actual_path
.
size
(
)
)
return
false
;
if
(
!
EqualPath
(
actual_path
vol_name
vol_length
)
)
return
false
;
if
(
!
EqualPath
(
actual_path
vol_length
path
2
)
)
return
false
;
return
true
;
}
bool
ConvertToLongPath
(
base
:
:
string16
*
native_path
const
base
:
:
string16
*
drive_letter
)
{
if
(
IsPipe
(
*
native_path
)
)
return
true
;
bool
is_device_harddisk_path
=
false
;
bool
is_nt_path
=
false
;
bool
added_implied_device
=
false
;
base
:
:
string16
temp_path
;
base
:
:
string16
to_restore
;
if
(
IsNTPath
(
*
native_path
&
temp_path
)
)
{
if
(
!
StartsWithDriveLetter
(
temp_path
)
)
{
temp_path
=
base
:
:
string16
(
kNTDotPrefix
)
+
temp_path
;
added_implied_device
=
true
;
}
is_nt_path
=
true
;
}
else
if
(
IsDeviceHarddiskPath
(
*
native_path
&
temp_path
&
to_restore
)
)
{
if
(
!
drive_letter
|
|
drive_letter
-
>
empty
(
)
)
return
false
;
temp_path
=
*
drive_letter
+
temp_path
;
is_device_harddisk_path
=
true
;
}
else
if
(
IsDevicePath
(
*
native_path
&
temp_path
)
)
{
return
false
;
}
DWORD
size
=
MAX_PATH
;
std
:
:
unique_ptr
<
wchar_t
[
]
>
long_path_buf
(
new
wchar_t
[
size
]
)
;
DWORD
return_value
=
:
:
GetLongPathName
(
temp_path
.
c_str
(
)
long_path_buf
.
get
(
)
size
)
;
while
(
return_value
>
=
size
)
{
size
*
=
2
;
long_path_buf
.
reset
(
new
wchar_t
[
size
]
)
;
return_value
=
:
:
GetLongPathName
(
temp_path
.
c_str
(
)
long_path_buf
.
get
(
)
size
)
;
}
DWORD
last_error
=
:
:
GetLastError
(
)
;
if
(
0
=
=
return_value
&
&
(
ERROR_FILE_NOT_FOUND
=
=
last_error
|
|
ERROR_PATH_NOT_FOUND
=
=
last_error
|
|
ERROR_INVALID_NAME
=
=
last_error
)
)
{
base
:
:
string16
:
:
size_type
last_slash
=
temp_path
.
rfind
(
L
'
\
\
'
)
;
if
(
base
:
:
string16
:
:
npos
=
=
last_slash
)
return
false
;
base
:
:
string16
begin
=
temp_path
.
substr
(
0
last_slash
)
;
base
:
:
string16
end
=
temp_path
.
substr
(
last_slash
)
;
if
(
!
ConvertToLongPath
(
&
begin
)
)
return
false
;
temp_path
=
begin
+
end
;
return_value
=
1
;
}
else
if
(
0
!
=
return_value
)
{
temp_path
=
long_path_buf
.
get
(
)
;
}
if
(
return_value
!
=
0
)
{
if
(
added_implied_device
)
RemoveImpliedDevice
(
&
temp_path
)
;
if
(
is_nt_path
)
{
*
native_path
=
kNTPrefix
;
*
native_path
+
=
temp_path
;
}
else
if
(
is_device_harddisk_path
)
{
temp_path
=
temp_path
.
substr
(
kDriveLetterLen
)
;
*
native_path
=
to_restore
;
*
native_path
+
=
temp_path
;
}
else
{
*
native_path
=
temp_path
;
}
return
true
;
}
return
false
;
}
bool
GetPathFromHandle
(
HANDLE
handle
base
:
:
string16
*
path
)
{
NtQueryObjectFunction
NtQueryObject
=
nullptr
;
ResolveNTFunctionPtr
(
"
NtQueryObject
"
&
NtQueryObject
)
;
OBJECT_NAME_INFORMATION
initial_buffer
;
OBJECT_NAME_INFORMATION
*
name
=
&
initial_buffer
;
ULONG
size
=
sizeof
(
initial_buffer
)
;
NTSTATUS
status
=
NtQueryObject
(
handle
ObjectNameInformation
name
size
&
size
)
;
std
:
:
unique_ptr
<
BYTE
[
]
>
name_ptr
;
if
(
size
)
{
name_ptr
.
reset
(
new
BYTE
[
size
]
)
;
name
=
reinterpret_cast
<
OBJECT_NAME_INFORMATION
*
>
(
name_ptr
.
get
(
)
)
;
status
=
NtQueryObject
(
handle
ObjectNameInformation
name
size
&
size
)
;
}
if
(
STATUS_SUCCESS
!
=
status
)
return
false
;
path
-
>
assign
(
name
-
>
ObjectName
.
Buffer
name
-
>
ObjectName
.
Length
/
sizeof
(
name
-
>
ObjectName
.
Buffer
[
0
]
)
)
;
return
true
;
}
bool
GetNtPathFromWin32Path
(
const
base
:
:
string16
&
path
base
:
:
string16
*
nt_path
)
{
HANDLE
file
=
:
:
CreateFileW
(
path
.
c_str
(
)
0
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
nullptr
)
;
if
(
file
=
=
INVALID_HANDLE_VALUE
)
return
false
;
bool
rv
=
GetPathFromHandle
(
file
nt_path
)
;
:
:
CloseHandle
(
file
)
;
return
rv
;
}
bool
WriteProtectedChildMemory
(
HANDLE
child_process
void
*
address
const
void
*
buffer
size_t
length
)
{
DWORD
old_protection
;
if
(
!
:
:
VirtualProtectEx
(
child_process
address
length
PAGE_WRITECOPY
&
old_protection
)
)
return
false
;
SIZE_T
written
;
bool
ok
=
:
:
WriteProcessMemory
(
child_process
address
buffer
length
&
written
)
&
&
(
length
=
=
written
)
;
if
(
!
:
:
VirtualProtectEx
(
child_process
address
length
old_protection
&
old_protection
)
)
return
false
;
return
ok
;
}
DWORD
GetLastErrorFromNtStatus
(
NTSTATUS
status
)
{
RtlNtStatusToDosErrorFunction
NtStatusToDosError
=
nullptr
;
ResolveNTFunctionPtr
(
"
RtlNtStatusToDosError
"
&
NtStatusToDosError
)
;
return
NtStatusToDosError
(
status
)
;
}
void
*
GetProcessBaseAddress
(
HANDLE
process
)
{
NtQueryInformationProcessFunction
query_information_process
=
nullptr
;
ResolveNTFunctionPtr
(
"
NtQueryInformationProcess
"
&
query_information_process
)
;
if
(
!
query_information_process
)
return
nullptr
;
PROCESS_BASIC_INFORMATION
process_basic_info
=
{
}
;
NTSTATUS
status
=
query_information_process
(
process
ProcessBasicInformation
&
process_basic_info
sizeof
(
process_basic_info
)
nullptr
)
;
if
(
STATUS_SUCCESS
!
=
status
)
return
nullptr
;
PEB
peb
=
{
}
;
SIZE_T
bytes_read
=
0
;
if
(
!
:
:
ReadProcessMemory
(
process
process_basic_info
.
PebBaseAddress
&
peb
sizeof
(
peb
)
&
bytes_read
)
|
|
(
sizeof
(
peb
)
!
=
bytes_read
)
)
{
return
nullptr
;
}
void
*
base_address
=
peb
.
ImageBaseAddress
;
char
magic
[
2
]
=
{
}
;
if
(
!
:
:
ReadProcessMemory
(
process
base_address
magic
sizeof
(
magic
)
&
bytes_read
)
|
|
(
sizeof
(
magic
)
!
=
bytes_read
)
)
{
return
nullptr
;
}
if
(
magic
[
0
]
!
=
'
M
'
|
|
magic
[
1
]
!
=
'
Z
'
)
return
nullptr
;
return
base_address
;
}
}
void
ResolveNTFunctionPtr
(
const
char
*
name
void
*
ptr
)
{
static
volatile
HMODULE
ntdll
=
nullptr
;
if
(
!
ntdll
)
{
HMODULE
ntdll_local
=
:
:
GetModuleHandle
(
sandbox
:
:
kNtdllName
)
;
base
:
:
win
:
:
PEImage
ntdll_peimage
(
ntdll_local
)
;
CHECK_NT
(
ntdll_peimage
.
VerifyMagic
(
)
)
;
:
:
InterlockedCompareExchangePointer
(
reinterpret_cast
<
PVOID
volatile
*
>
(
&
ntdll
)
ntdll_local
nullptr
)
;
}
CHECK_NT
(
ntdll
)
;
FARPROC
*
function_ptr
=
reinterpret_cast
<
FARPROC
*
>
(
ptr
)
;
*
function_ptr
=
:
:
GetProcAddress
(
ntdll
name
)
;
CHECK_NT
(
*
function_ptr
)
;
}
