#
include
"
sandbox
/
win
/
src
/
process_thread_dispatcher
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
base
/
logging
.
h
"
#
include
"
sandbox
/
win
/
src
/
crosscall_client
.
h
"
#
include
"
sandbox
/
win
/
src
/
interception
.
h
"
#
include
"
sandbox
/
win
/
src
/
interceptors
.
h
"
#
include
"
sandbox
/
win
/
src
/
ipc_tags
.
h
"
#
include
"
sandbox
/
win
/
src
/
policy_broker
.
h
"
#
include
"
sandbox
/
win
/
src
/
policy_params
.
h
"
#
include
"
sandbox
/
win
/
src
/
process_thread_interception
.
h
"
#
include
"
sandbox
/
win
/
src
/
process_thread_policy
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox
.
h
"
namespace
{
std
:
:
wstring
GetPathFromCmdLine
(
const
std
:
:
wstring
&
cmd_line
)
{
std
:
:
wstring
exe_name
;
if
(
cmd_line
[
0
]
=
=
L
'
\
"
'
)
{
std
:
:
wstring
:
:
size_type
pos
=
cmd_line
.
find
(
L
'
\
"
'
1
)
;
if
(
std
:
:
wstring
:
:
npos
=
=
pos
)
return
cmd_line
;
exe_name
=
cmd_line
.
substr
(
1
pos
-
1
)
;
}
else
{
std
:
:
wstring
:
:
size_type
pos
=
cmd_line
.
find
(
L
'
'
)
;
if
(
std
:
:
wstring
:
:
npos
=
=
pos
)
{
exe_name
=
cmd_line
;
}
else
{
exe_name
=
cmd_line
.
substr
(
0
pos
)
;
}
}
return
exe_name
;
}
bool
IsPathRelative
(
const
std
:
:
wstring
&
path
)
{
if
(
path
.
find
(
L
"
\
\
\
\
"
)
=
=
0
|
|
path
.
find
(
L
"
:
\
\
"
)
=
=
1
)
return
false
;
return
true
;
}
bool
ConvertToAbsolutePath
(
const
std
:
:
wstring
&
child_current_directory
bool
use_env_path
std
:
:
wstring
*
path
)
{
wchar_t
file_buffer
[
MAX_PATH
]
;
wchar_t
*
file_part
=
nullptr
;
DWORD
result
=
0
;
if
(
use_env_path
)
{
result
=
:
:
SearchPath
(
nullptr
path
-
>
c_str
(
)
nullptr
MAX_PATH
file_buffer
&
file_part
)
;
}
if
(
0
=
=
result
)
{
result
=
:
:
SearchPath
(
child_current_directory
.
c_str
(
)
path
-
>
c_str
(
)
nullptr
MAX_PATH
file_buffer
&
file_part
)
;
}
if
(
0
=
=
result
|
|
result
>
=
MAX_PATH
)
return
false
;
*
path
=
file_buffer
;
return
true
;
}
}
namespace
sandbox
{
ThreadProcessDispatcher
:
:
ThreadProcessDispatcher
(
PolicyBase
*
policy_base
)
:
policy_base_
(
policy_base
)
{
static
const
IPCCall
open_thread
=
{
{
IpcTag
:
:
NTOPENTHREAD
{
UINT32_TYPE
UINT32_TYPE
}
}
reinterpret_cast
<
CallbackGeneric
>
(
&
ThreadProcessDispatcher
:
:
NtOpenThread
)
}
;
static
const
IPCCall
open_process
=
{
{
IpcTag
:
:
NTOPENPROCESS
{
UINT32_TYPE
UINT32_TYPE
}
}
reinterpret_cast
<
CallbackGeneric
>
(
&
ThreadProcessDispatcher
:
:
NtOpenProcess
)
}
;
static
const
IPCCall
process_token
=
{
{
IpcTag
:
:
NTOPENPROCESSTOKEN
{
VOIDPTR_TYPE
UINT32_TYPE
}
}
reinterpret_cast
<
CallbackGeneric
>
(
&
ThreadProcessDispatcher
:
:
NtOpenProcessToken
)
}
;
static
const
IPCCall
process_tokenex
=
{
{
IpcTag
:
:
NTOPENPROCESSTOKENEX
{
VOIDPTR_TYPE
UINT32_TYPE
UINT32_TYPE
}
}
reinterpret_cast
<
CallbackGeneric
>
(
&
ThreadProcessDispatcher
:
:
NtOpenProcessTokenEx
)
}
;
static
const
IPCCall
create_params
=
{
{
IpcTag
:
:
CREATEPROCESSW
{
WCHAR_TYPE
WCHAR_TYPE
WCHAR_TYPE
WCHAR_TYPE
INOUTPTR_TYPE
}
}
reinterpret_cast
<
CallbackGeneric
>
(
&
ThreadProcessDispatcher
:
:
CreateProcessW
)
}
;
static_assert
(
sizeof
(
size_t
)
=
=
sizeof
(
void
*
)
"
VOIDPTR_TYPE
not
same
size
as
size_t
"
)
;
static
const
IPCCall
create_thread_params
=
{
{
IpcTag
:
:
CREATETHREAD
{
VOIDPTR_TYPE
VOIDPTR_TYPE
VOIDPTR_TYPE
UINT32_TYPE
}
}
reinterpret_cast
<
CallbackGeneric
>
(
&
ThreadProcessDispatcher
:
:
CreateThread
)
}
;
ipc_calls_
.
push_back
(
open_thread
)
;
ipc_calls_
.
push_back
(
open_process
)
;
ipc_calls_
.
push_back
(
process_token
)
;
ipc_calls_
.
push_back
(
process_tokenex
)
;
ipc_calls_
.
push_back
(
create_params
)
;
ipc_calls_
.
push_back
(
create_thread_params
)
;
}
bool
ThreadProcessDispatcher
:
:
SetupService
(
InterceptionManager
*
manager
IpcTag
service
)
{
switch
(
service
)
{
case
IpcTag
:
:
NTOPENTHREAD
:
case
IpcTag
:
:
NTOPENPROCESS
:
case
IpcTag
:
:
NTOPENPROCESSTOKEN
:
case
IpcTag
:
:
NTOPENPROCESSTOKENEX
:
case
IpcTag
:
:
CREATETHREAD
:
NOTREACHED
(
)
;
return
false
;
case
IpcTag
:
:
CREATEPROCESSW
:
return
INTERCEPT_EAT
(
manager
kKerneldllName
CreateProcessW
CREATE_PROCESSW_ID
44
)
&
&
INTERCEPT_EAT
(
manager
L
"
kernel32
.
dll
"
CreateProcessA
CREATE_PROCESSA_ID
44
)
;
default
:
return
false
;
}
}
bool
ThreadProcessDispatcher
:
:
NtOpenThread
(
IPCInfo
*
ipc
uint32_t
desired_access
uint32_t
thread_id
)
{
HANDLE
handle
;
NTSTATUS
ret
=
ProcessPolicy
:
:
OpenThreadAction
(
*
ipc
-
>
client_info
desired_access
thread_id
&
handle
)
;
ipc
-
>
return_info
.
nt_status
=
ret
;
ipc
-
>
return_info
.
handle
=
handle
;
return
true
;
}
bool
ThreadProcessDispatcher
:
:
NtOpenProcess
(
IPCInfo
*
ipc
uint32_t
desired_access
uint32_t
process_id
)
{
HANDLE
handle
;
NTSTATUS
ret
=
ProcessPolicy
:
:
OpenProcessAction
(
*
ipc
-
>
client_info
desired_access
process_id
&
handle
)
;
ipc
-
>
return_info
.
nt_status
=
ret
;
ipc
-
>
return_info
.
handle
=
handle
;
return
true
;
}
bool
ThreadProcessDispatcher
:
:
NtOpenProcessToken
(
IPCInfo
*
ipc
HANDLE
process
uint32_t
desired_access
)
{
HANDLE
handle
;
NTSTATUS
ret
=
ProcessPolicy
:
:
OpenProcessTokenAction
(
*
ipc
-
>
client_info
process
desired_access
&
handle
)
;
ipc
-
>
return_info
.
nt_status
=
ret
;
ipc
-
>
return_info
.
handle
=
handle
;
return
true
;
}
bool
ThreadProcessDispatcher
:
:
NtOpenProcessTokenEx
(
IPCInfo
*
ipc
HANDLE
process
uint32_t
desired_access
uint32_t
attributes
)
{
HANDLE
handle
;
NTSTATUS
ret
=
ProcessPolicy
:
:
OpenProcessTokenExAction
(
*
ipc
-
>
client_info
process
desired_access
attributes
&
handle
)
;
ipc
-
>
return_info
.
nt_status
=
ret
;
ipc
-
>
return_info
.
handle
=
handle
;
return
true
;
}
bool
ThreadProcessDispatcher
:
:
CreateProcessW
(
IPCInfo
*
ipc
std
:
:
wstring
*
name
std
:
:
wstring
*
cmd_line
std
:
:
wstring
*
cur_dir
std
:
:
wstring
*
target_cur_dir
CountedBuffer
*
info
)
{
if
(
sizeof
(
PROCESS_INFORMATION
)
!
=
info
-
>
Size
(
)
)
return
false
;
std
:
:
wstring
exe_name
;
if
(
!
name
-
>
empty
(
)
)
exe_name
=
*
name
;
else
exe_name
=
GetPathFromCmdLine
(
*
cmd_line
)
;
if
(
IsPathRelative
(
exe_name
)
)
{
if
(
!
ConvertToAbsolutePath
(
*
cur_dir
name
-
>
empty
(
)
&
exe_name
)
)
{
ipc
-
>
return_info
.
win32_result
=
ERROR_FILE_NOT_FOUND
;
return
true
;
}
}
const
wchar_t
*
const_exe_name
=
exe_name
.
c_str
(
)
;
CountedParameterSet
<
NameBased
>
params
;
params
[
NameBased
:
:
NAME
]
=
ParamPickerMake
(
const_exe_name
)
;
EvalResult
eval
=
policy_base_
-
>
EvalPolicy
(
IpcTag
:
:
CREATEPROCESSW
params
.
GetBase
(
)
)
;
PROCESS_INFORMATION
*
proc_info
=
reinterpret_cast
<
PROCESS_INFORMATION
*
>
(
info
-
>
Buffer
(
)
)
;
DWORD
ret
=
ProcessPolicy
:
:
CreateProcessWAction
(
eval
*
ipc
-
>
client_info
exe_name
*
cmd_line
*
target_cur_dir
proc_info
)
;
ipc
-
>
return_info
.
win32_result
=
ret
;
return
true
;
}
bool
ThreadProcessDispatcher
:
:
CreateThread
(
IPCInfo
*
ipc
SIZE_T
stack_size
LPTHREAD_START_ROUTINE
start_address
LPVOID
parameter
DWORD
creation_flags
)
{
if
(
!
start_address
)
{
return
false
;
}
HANDLE
handle
;
DWORD
ret
=
ProcessPolicy
:
:
CreateThreadAction
(
*
ipc
-
>
client_info
stack_size
start_address
parameter
creation_flags
nullptr
&
handle
)
;
ipc
-
>
return_info
.
nt_status
=
ret
;
ipc
-
>
return_info
.
handle
=
handle
;
return
true
;
}
}
