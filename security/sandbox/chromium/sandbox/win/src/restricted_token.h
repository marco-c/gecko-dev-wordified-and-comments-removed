#
ifndef
SANDBOX_SRC_RESTRICTED_TOKEN_H_
#
define
SANDBOX_SRC_RESTRICTED_TOKEN_H_
#
include
<
windows
.
h
>
#
include
<
tuple
>
#
include
<
vector
>
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
strings
/
string16
.
h
"
#
include
"
base
/
win
/
scoped_handle
.
h
"
#
include
"
sandbox
/
win
/
src
/
restricted_token_utils
.
h
"
#
include
"
sandbox
/
win
/
src
/
security_level
.
h
"
#
include
"
sandbox
/
win
/
src
/
sid
.
h
"
#
ifndef
SE_GROUP_INTEGRITY
#
define
SE_GROUP_INTEGRITY
(
0x00000020L
)
#
endif
#
ifndef
SE_GROUP_INTEGRITY_ENABLED
#
define
SE_GROUP_INTEGRITY_ENABLED
(
0x00000040L
)
#
endif
namespace
sandbox
{
class
RestrictedToken
{
public
:
RestrictedToken
(
)
;
~
RestrictedToken
(
)
;
DWORD
Init
(
HANDLE
effective_token
)
;
DWORD
GetRestrictedToken
(
base
:
:
win
:
:
ScopedHandle
*
token
)
const
;
DWORD
GetRestrictedTokenForImpersonation
(
base
:
:
win
:
:
ScopedHandle
*
token
)
const
;
DWORD
AddAllSidsForDenyOnly
(
std
:
:
vector
<
Sid
>
*
exceptions
)
;
DWORD
AddSidForDenyOnly
(
const
Sid
&
sid
)
;
DWORD
AddUserSidForDenyOnly
(
)
;
DWORD
DeleteAllPrivileges
(
const
std
:
:
vector
<
base
:
:
string16
>
*
exceptions
)
;
DWORD
DeletePrivilege
(
const
wchar_t
*
privilege
)
;
DWORD
AddRestrictingSid
(
const
Sid
&
sid
)
;
DWORD
AddRestrictingSidLogonSession
(
)
;
DWORD
AddRestrictingSidCurrentUser
(
)
;
DWORD
AddRestrictingSidAllSids
(
)
;
DWORD
SetIntegrityLevel
(
IntegrityLevel
integrity_level
)
;
void
SetLockdownDefaultDacl
(
)
;
DWORD
AddDefaultDaclSid
(
const
Sid
&
sid
ACCESS_MODE
access_mode
ACCESS_MASK
access
)
;
private
:
std
:
:
vector
<
Sid
>
sids_to_restrict_
;
std
:
:
vector
<
LUID
>
privileges_to_disable_
;
std
:
:
vector
<
Sid
>
sids_for_deny_only_
;
std
:
:
vector
<
std
:
:
tuple
<
Sid
ACCESS_MODE
ACCESS_MASK
>
>
sids_for_default_dacl_
;
base
:
:
win
:
:
ScopedHandle
effective_token_
;
IntegrityLevel
integrity_level_
;
bool
init_
;
bool
lockdown_default_dacl_
;
DISALLOW_COPY_AND_ASSIGN
(
RestrictedToken
)
;
}
;
}
#
endif
