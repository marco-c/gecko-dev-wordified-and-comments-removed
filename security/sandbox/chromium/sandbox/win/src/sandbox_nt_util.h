#
ifndef
SANDBOX_WIN_SRC_SANDBOX_NT_UTIL_H_
#
define
SANDBOX_WIN_SRC_SANDBOX_NT_UTIL_H_
#
include
<
intrin
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
"
base
/
containers
/
span
.
h
"
#
include
"
base
/
memory
/
raw_ptr_exclusion
.
h
"
#
include
"
sandbox
/
win
/
src
/
nt_internals
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_nt_types
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
void
*
__cdecl
operator
new
(
size_t
size
sandbox
:
:
AllocationType
type
void
*
near_to
=
nullptr
)
;
void
*
__cdecl
operator
new
[
]
(
size_t
size
sandbox
:
:
AllocationType
type
void
*
near_to
=
nullptr
)
;
void
__cdecl
operator
delete
(
void
*
memory
sandbox
:
:
AllocationType
type
)
;
void
__cdecl
operator
delete
(
void
*
memory
sandbox
:
:
AllocationType
type
void
*
near_to
)
;
void
*
__cdecl
operator
new
(
size_t
size
void
*
buffer
sandbox
:
:
AllocationType
type
)
;
void
__cdecl
operator
delete
(
void
*
memory
void
*
buffer
sandbox
:
:
AllocationType
type
)
;
#
ifndef
NDEBUG
#
define
DCHECK_NT
(
condition
)
\
{
(
condition
)
?
(
void
)
0
:
__debugbreak
(
)
;
}
#
define
VERIFY
(
action
)
DCHECK_NT
(
action
)
#
define
VERIFY_SUCCESS
(
action
)
DCHECK_NT
(
NT_SUCCESS
(
action
)
)
#
else
#
define
DCHECK_NT
(
condition
)
#
define
VERIFY
(
action
)
(
action
)
#
define
VERIFY_SUCCESS
(
action
)
(
action
)
#
endif
#
define
CHECK_NT
(
condition
)
\
{
(
condition
)
?
(
void
)
0
:
__debugbreak
(
)
;
}
#
define
NOTREACHED_NT
(
)
DCHECK_NT
(
false
)
namespace
sandbox
{
#
if
defined
(
_M_X64
)
|
|
defined
(
_M_ARM64
)
#
pragma
intrinsic
(
_InterlockedCompareExchange
)
#
pragma
intrinsic
(
_InterlockedCompareExchangePointer
)
#
elif
defined
(
_M_IX86
)
extern
"
C
"
long
_InterlockedCompareExchange
(
long
volatile
*
destination
long
exchange
long
comperand
)
;
#
pragma
intrinsic
(
_InterlockedCompareExchange
)
__forceinline
void
*
_InterlockedCompareExchangePointer
(
void
*
volatile
*
destination
void
*
exchange
void
*
comperand
)
{
long
ret
=
_InterlockedCompareExchange
(
reinterpret_cast
<
long
volatile
*
>
(
destination
)
static_cast
<
long
>
(
reinterpret_cast
<
size_t
>
(
exchange
)
)
static_cast
<
long
>
(
reinterpret_cast
<
size_t
>
(
comperand
)
)
)
;
return
reinterpret_cast
<
void
*
>
(
static_cast
<
size_t
>
(
ret
)
)
;
}
#
else
#
error
Architecture
not
supported
.
#
endif
struct
NtAllocDeleter
{
inline
void
operator
(
)
(
void
*
ptr
)
const
{
operator
delete
(
ptr
AllocationType
:
:
NT_ALLOC
)
;
}
}
;
void
*
GetGlobalIPCMemory
(
)
;
void
*
GetGlobalPolicyMemoryForTesting
(
)
;
absl
:
:
optional
<
base
:
:
span
<
const
uint8_t
>
>
GetGlobalDelegateData
(
)
;
const
NtExports
*
GetNtExports
(
)
;
enum
RequiredAccess
{
READ
WRITE
}
;
bool
ValidParameter
(
void
*
buffer
size_t
size
RequiredAccess
intent
)
;
NTSTATUS
CopyData
(
void
*
destination
const
void
*
source
size_t
bytes
)
;
NTSTATUS
CopyNameAndAttributes
(
const
OBJECT_ATTRIBUTES
*
in_object
std
:
:
unique_ptr
<
wchar_t
NtAllocDeleter
>
*
out_name
size_t
*
out_name_len
uint32_t
*
attributes
=
nullptr
)
;
NTSTATUS
AllocAndCopyName
(
const
OBJECT_ATTRIBUTES
*
in_object
std
:
:
unique_ptr
<
wchar_t
NtAllocDeleter
>
*
out_name
uint32_t
*
attributes
HANDLE
*
root
)
;
NTSTATUS
AllocAndGetFullPath
(
HANDLE
root
const
wchar_t
*
path
std
:
:
unique_ptr
<
wchar_t
NtAllocDeleter
>
*
full_path
)
;
bool
InitHeap
(
)
;
bool
IsSameProcess
(
HANDLE
process
)
;
enum
MappedModuleFlags
{
MODULE_IS_PE_IMAGE
=
1
MODULE_HAS_ENTRY_POINT
=
2
MODULE_HAS_CODE
=
4
}
;
UNICODE_STRING
*
GetImageInfoFromModule
(
HMODULE
module
uint32_t
*
flags
)
;
const
char
*
GetAnsiImageInfoFromModule
(
HMODULE
module
)
;
UNICODE_STRING
*
GetBackingFilePath
(
PVOID
address
)
;
UNICODE_STRING
*
ExtractModuleName
(
const
UNICODE_STRING
*
module_path
)
;
bool
IsValidImageSection
(
HANDLE
section
PVOID
*
base
PLARGE_INTEGER
offset
PSIZE_T
view_size
)
;
UNICODE_STRING
*
AnsiToUnicode
(
const
char
*
string
)
;
bool
NtGetPathFromHandle
(
HANDLE
handle
std
:
:
unique_ptr
<
wchar_t
NtAllocDeleter
>
*
path
)
;
class
AutoProtectMemory
{
public
:
AutoProtectMemory
(
)
:
changed_
(
false
)
address_
(
nullptr
)
bytes_
(
0
)
old_protect_
(
0
)
{
}
AutoProtectMemory
(
const
AutoProtectMemory
&
)
=
delete
;
AutoProtectMemory
&
operator
=
(
const
AutoProtectMemory
&
)
=
delete
;
~
AutoProtectMemory
(
)
{
RevertProtection
(
)
;
}
NTSTATUS
ChangeProtection
(
void
*
address
size_t
bytes
ULONG
protect
)
;
NTSTATUS
RevertProtection
(
)
;
private
:
bool
changed_
;
RAW_PTR_EXCLUSION
void
*
address_
;
size_t
bytes_
;
ULONG
old_protect_
;
}
;
bool
IsSupportedRenameCall
(
FILE_RENAME_INFORMATION
*
file_info
DWORD
length
uint32_t
file_info_class
)
;
CLIENT_ID
GetCurrentClientId
(
)
;
__forceinline
void
Memset
(
void
*
ptr
int
value
size_t
num_bytes
)
{
unsigned
char
*
byte_ptr
=
static_cast
<
unsigned
char
*
>
(
ptr
)
;
while
(
num_bytes
-
-
)
{
*
byte_ptr
+
+
=
static_cast
<
unsigned
char
>
(
value
)
;
}
}
}
#
endif
