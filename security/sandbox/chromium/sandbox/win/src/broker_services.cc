#
include
"
sandbox
/
win
/
src
/
broker_services
.
h
"
#
include
<
aclapi
.
h
>
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
memory
/
ptr_util
.
h
"
#
include
"
base
/
threading
/
platform_thread
.
h
"
#
include
"
base
/
win
/
scoped_handle
.
h
"
#
include
"
base
/
win
/
scoped_process_information
.
h
"
#
include
"
base
/
win
/
startup_information
.
h
"
#
include
"
base
/
win
/
windows_version
.
h
"
#
include
"
sandbox
/
win
/
src
/
app_container_profile
.
h
"
#
include
"
sandbox
/
win
/
src
/
process_mitigations
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_policy_base
.
h
"
#
include
"
sandbox
/
win
/
src
/
target_process
.
h
"
#
include
"
sandbox
/
win
/
src
/
win2k_threadpool
.
h
"
#
include
"
sandbox
/
win
/
src
/
win_utils
.
h
"
namespace
{
bool
AssociateCompletionPort
(
HANDLE
job
HANDLE
port
void
*
key
)
{
JOBOBJECT_ASSOCIATE_COMPLETION_PORT
job_acp
=
{
key
port
}
;
return
:
:
SetInformationJobObject
(
job
JobObjectAssociateCompletionPortInformation
&
job_acp
sizeof
(
job_acp
)
)
?
true
:
false
;
}
sandbox
:
:
ResultCode
SpawnCleanup
(
sandbox
:
:
TargetProcess
*
target
)
{
target
-
>
Terminate
(
)
;
delete
target
;
return
sandbox
:
:
SBOX_ERROR_GENERIC
;
}
enum
{
THREAD_CTRL_NONE
THREAD_CTRL_REMOVE_PEER
THREAD_CTRL_QUIT
THREAD_CTRL_LAST
}
;
struct
JobTracker
{
JobTracker
(
base
:
:
win
:
:
ScopedHandle
job
scoped_refptr
<
sandbox
:
:
PolicyBase
>
policy
)
:
job
(
std
:
:
move
(
job
)
)
policy
(
policy
)
{
}
~
JobTracker
(
)
{
FreeResources
(
)
;
}
void
FreeResources
(
)
;
base
:
:
win
:
:
ScopedHandle
job
;
scoped_refptr
<
sandbox
:
:
PolicyBase
>
policy
;
}
;
void
JobTracker
:
:
FreeResources
(
)
{
if
(
policy
)
{
bool
res
=
:
:
TerminateJobObject
(
job
.
Get
(
)
sandbox
:
:
SBOX_ALL_OK
)
;
DCHECK
(
res
)
;
HANDLE
stale_job_handle
=
job
.
Get
(
)
;
job
.
Close
(
)
;
policy
-
>
OnJobEmpty
(
stale_job_handle
)
;
policy
=
nullptr
;
}
}
struct
PeerTracker
{
PeerTracker
(
DWORD
process_id
HANDLE
broker_job_port
)
:
wait_object
(
NULL
)
id
(
process_id
)
job_port
(
broker_job_port
)
{
}
HANDLE
wait_object
;
base
:
:
win
:
:
ScopedHandle
process
;
DWORD
id
;
HANDLE
job_port
;
}
;
void
DeregisterPeerTracker
(
PeerTracker
*
peer
)
{
if
(
:
:
UnregisterWaitEx
(
peer
-
>
wait_object
INVALID_HANDLE_VALUE
)
)
{
delete
peer
;
}
else
{
NOTREACHED
(
)
;
}
}
}
namespace
sandbox
{
BrokerServicesBase
:
:
BrokerServicesBase
(
)
{
}
ResultCode
BrokerServicesBase
:
:
Init
(
)
{
if
(
job_port_
.
IsValid
(
)
|
|
thread_pool_
)
return
SBOX_ERROR_UNEXPECTED_CALL
;
:
:
InitializeCriticalSection
(
&
lock_
)
;
job_port_
.
Set
(
:
:
CreateIoCompletionPort
(
INVALID_HANDLE_VALUE
nullptr
0
0
)
)
;
if
(
!
job_port_
.
IsValid
(
)
)
return
SBOX_ERROR_GENERIC
;
no_targets_
.
Set
(
:
:
CreateEventW
(
nullptr
true
false
nullptr
)
)
;
job_thread_
.
Set
(
:
:
CreateThread
(
nullptr
0
TargetEventsThread
this
0
nullptr
)
)
;
if
(
!
job_thread_
.
IsValid
(
)
)
return
SBOX_ERROR_GENERIC
;
return
SBOX_ALL_OK
;
}
BrokerServicesBase
:
:
~
BrokerServicesBase
(
)
{
if
(
!
job_port_
.
IsValid
(
)
)
return
;
:
:
PostQueuedCompletionStatus
(
job_port_
.
Get
(
)
0
THREAD_CTRL_QUIT
nullptr
)
;
if
(
job_thread_
.
IsValid
(
)
&
&
WAIT_TIMEOUT
=
=
:
:
WaitForSingleObject
(
job_thread_
.
Get
(
)
1000
)
)
{
NOTREACHED
(
)
;
return
;
}
tracker_list_
.
clear
(
)
;
thread_pool_
.
reset
(
)
;
for
(
PeerTrackerMap
:
:
iterator
it
=
peer_map_
.
begin
(
)
;
it
!
=
peer_map_
.
end
(
)
;
+
+
it
)
{
DeregisterPeerTracker
(
it
-
>
second
)
;
}
:
:
DeleteCriticalSection
(
&
lock_
)
;
}
scoped_refptr
<
TargetPolicy
>
BrokerServicesBase
:
:
CreatePolicy
(
)
{
scoped_refptr
<
TargetPolicy
>
policy
(
new
PolicyBase
)
;
policy
-
>
Release
(
)
;
return
policy
;
}
DWORD
WINAPI
BrokerServicesBase
:
:
TargetEventsThread
(
PVOID
param
)
{
if
(
!
param
)
return
1
;
base
:
:
PlatformThread
:
:
SetName
(
"
BrokerEvent
"
)
;
BrokerServicesBase
*
broker
=
reinterpret_cast
<
BrokerServicesBase
*
>
(
param
)
;
HANDLE
port
=
broker
-
>
job_port_
.
Get
(
)
;
HANDLE
no_targets
=
broker
-
>
no_targets_
.
Get
(
)
;
int
target_counter
=
0
;
int
untracked_target_counter
=
0
;
:
:
ResetEvent
(
no_targets
)
;
while
(
true
)
{
DWORD
events
=
0
;
ULONG_PTR
key
=
0
;
LPOVERLAPPED
ovl
=
nullptr
;
if
(
!
:
:
GetQueuedCompletionStatus
(
port
&
events
&
key
&
ovl
INFINITE
)
)
{
return
1
;
}
if
(
key
>
THREAD_CTRL_LAST
)
{
JobTracker
*
tracker
=
reinterpret_cast
<
JobTracker
*
>
(
key
)
;
switch
(
events
)
{
case
JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO
:
{
tracker
-
>
FreeResources
(
)
;
break
;
}
case
JOB_OBJECT_MSG_NEW_PROCESS
:
{
DWORD
handle
=
static_cast
<
DWORD
>
(
reinterpret_cast
<
uintptr_t
>
(
ovl
)
)
;
{
AutoLock
lock
(
&
broker
-
>
lock_
)
;
size_t
count
=
broker
-
>
child_process_ids_
.
count
(
handle
)
;
if
(
count
=
=
0
)
untracked_target_counter
+
+
;
}
+
+
target_counter
;
if
(
1
=
=
target_counter
)
{
:
:
ResetEvent
(
no_targets
)
;
}
break
;
}
case
JOB_OBJECT_MSG_EXIT_PROCESS
:
case
JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS
:
{
size_t
erase_result
=
0
;
{
AutoLock
lock
(
&
broker
-
>
lock_
)
;
erase_result
=
broker
-
>
child_process_ids_
.
erase
(
static_cast
<
DWORD
>
(
reinterpret_cast
<
uintptr_t
>
(
ovl
)
)
)
;
}
if
(
erase_result
!
=
1U
)
{
-
-
untracked_target_counter
;
DCHECK
(
untracked_target_counter
>
=
0
)
;
}
-
-
target_counter
;
if
(
0
=
=
target_counter
)
:
:
SetEvent
(
no_targets
)
;
DCHECK
(
target_counter
>
=
0
)
;
break
;
}
case
JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT
:
{
untracked_target_counter
+
+
;
target_counter
+
+
;
break
;
}
case
JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT
:
{
bool
res
=
:
:
TerminateJobObject
(
tracker
-
>
job
.
Get
(
)
SBOX_FATAL_MEMORY_EXCEEDED
)
;
DCHECK
(
res
)
;
break
;
}
default
:
{
NOTREACHED
(
)
;
break
;
}
}
}
else
if
(
THREAD_CTRL_REMOVE_PEER
=
=
key
)
{
AutoLock
lock
(
&
broker
-
>
lock_
)
;
PeerTrackerMap
:
:
iterator
it
=
broker
-
>
peer_map_
.
find
(
static_cast
<
DWORD
>
(
reinterpret_cast
<
uintptr_t
>
(
ovl
)
)
)
;
DeregisterPeerTracker
(
it
-
>
second
)
;
broker
-
>
peer_map_
.
erase
(
it
)
;
}
else
if
(
THREAD_CTRL_QUIT
=
=
key
)
{
return
0
;
}
else
{
NOTREACHED
(
)
;
}
}
NOTREACHED
(
)
;
return
0
;
}
ResultCode
BrokerServicesBase
:
:
SpawnTarget
(
const
wchar_t
*
exe_path
const
wchar_t
*
command_line
base
:
:
EnvironmentMap
&
env_map
scoped_refptr
<
TargetPolicy
>
policy
ResultCode
*
last_warning
DWORD
*
last_error
PROCESS_INFORMATION
*
target_info
)
{
if
(
!
exe_path
)
return
SBOX_ERROR_BAD_PARAMS
;
if
(
!
policy
)
return
SBOX_ERROR_BAD_PARAMS
;
static
DWORD
thread_id
=
:
:
GetCurrentThreadId
(
)
;
DCHECK
(
thread_id
=
=
:
:
GetCurrentThreadId
(
)
)
;
*
last_warning
=
SBOX_ALL_OK
;
AutoLock
lock
(
&
lock_
)
;
scoped_refptr
<
PolicyBase
>
policy_base
(
static_cast
<
PolicyBase
*
>
(
policy
.
get
(
)
)
)
;
base
:
:
win
:
:
ScopedHandle
initial_token
;
base
:
:
win
:
:
ScopedHandle
lockdown_token
;
base
:
:
win
:
:
ScopedHandle
lowbox_token
;
ResultCode
result
=
SBOX_ALL_OK
;
result
=
policy_base
-
>
MakeTokens
(
&
initial_token
&
lockdown_token
&
lowbox_token
)
;
if
(
SBOX_ALL_OK
!
=
result
)
return
result
;
if
(
lowbox_token
.
IsValid
(
)
&
&
base
:
:
win
:
:
GetVersion
(
)
<
base
:
:
win
:
:
VERSION_WIN8
)
{
return
SBOX_ERROR_BAD_PARAMS
;
}
base
:
:
win
:
:
ScopedHandle
job
;
result
=
policy_base
-
>
MakeJobObject
(
&
job
)
;
if
(
SBOX_ALL_OK
!
=
result
)
return
result
;
base
:
:
win
:
:
StartupInformation
startup_info
;
startup_info
.
startup_info
(
)
-
>
dwFlags
|
=
STARTF_FORCEOFFFEEDBACK
;
DWORD64
mitigations
[
2
]
;
std
:
:
vector
<
HANDLE
>
inherited_handle_list
;
DWORD
child_process_creation
=
PROCESS_CREATION_CHILD_PROCESS_RESTRICTED
;
base
:
:
string16
desktop
=
policy_base
-
>
GetAlternateDesktop
(
)
;
if
(
!
desktop
.
empty
(
)
)
{
startup_info
.
startup_info
(
)
-
>
lpDesktop
=
const_cast
<
wchar_t
*
>
(
desktop
.
c_str
(
)
)
;
}
bool
inherit_handles
=
false
;
int
attribute_count
=
0
;
size_t
mitigations_size
;
ConvertProcessMitigationsToPolicy
(
policy_base
-
>
GetProcessMitigations
(
)
&
mitigations
[
0
]
&
mitigations_size
)
;
if
(
mitigations
[
0
]
|
|
mitigations
[
1
]
)
+
+
attribute_count
;
bool
restrict_child_process_creation
=
false
;
if
(
base
:
:
win
:
:
GetVersion
(
)
>
=
base
:
:
win
:
:
VERSION_WIN10_TH2
&
&
policy_base
-
>
GetJobLevel
(
)
<
=
JOB_LIMITED_USER
)
{
restrict_child_process_creation
=
true
;
+
+
attribute_count
;
}
HANDLE
stdout_handle
=
policy_base
-
>
GetStdoutHandle
(
)
;
HANDLE
stderr_handle
=
policy_base
-
>
GetStderrHandle
(
)
;
if
(
stdout_handle
!
=
INVALID_HANDLE_VALUE
)
inherited_handle_list
.
push_back
(
stdout_handle
)
;
if
(
stderr_handle
!
=
stdout_handle
&
&
stderr_handle
!
=
INVALID_HANDLE_VALUE
)
inherited_handle_list
.
push_back
(
stderr_handle
)
;
const
auto
&
policy_handle_list
=
policy_base
-
>
GetHandlesBeingShared
(
)
;
for
(
HANDLE
handle
:
policy_handle_list
)
inherited_handle_list
.
push_back
(
handle
)
;
if
(
inherited_handle_list
.
size
(
)
)
+
+
attribute_count
;
scoped_refptr
<
AppContainerProfileBase
>
profile
=
policy_base
-
>
GetAppContainerProfileBase
(
)
;
if
(
profile
)
{
if
(
base
:
:
win
:
:
GetVersion
(
)
<
base
:
:
win
:
:
VERSION_WIN8
)
return
SBOX_ERROR_BAD_PARAMS
;
+
+
attribute_count
;
if
(
profile
-
>
GetEnableLowPrivilegeAppContainer
(
)
)
{
if
(
base
:
:
win
:
:
GetVersion
(
)
<
base
:
:
win
:
:
VERSION_WIN10_RS1
)
return
SBOX_ERROR_BAD_PARAMS
;
+
+
attribute_count
;
}
}
if
(
!
startup_info
.
InitializeProcThreadAttributeList
(
attribute_count
)
)
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
if
(
mitigations
[
0
]
|
|
mitigations
[
1
]
)
{
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY
&
mitigations
[
0
]
mitigations_size
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
}
if
(
restrict_child_process_creation
)
{
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY
&
child_process_creation
sizeof
(
child_process_creation
)
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
}
if
(
inherited_handle_list
.
size
(
)
)
{
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_HANDLE_LIST
&
inherited_handle_list
[
0
]
sizeof
(
HANDLE
)
*
inherited_handle_list
.
size
(
)
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
startup_info
.
startup_info
(
)
-
>
dwFlags
|
=
STARTF_USESTDHANDLES
;
startup_info
.
startup_info
(
)
-
>
hStdInput
=
INVALID_HANDLE_VALUE
;
startup_info
.
startup_info
(
)
-
>
hStdOutput
=
stdout_handle
;
startup_info
.
startup_info
(
)
-
>
hStdError
=
stderr_handle
;
inherit_handles
=
true
;
}
std
:
:
unique_ptr
<
SecurityCapabilities
>
security_capabilities
;
DWORD
all_applications_package_policy
=
PROCESS_CREATION_ALL_APPLICATION_PACKAGES_OPT_OUT
;
if
(
profile
)
{
security_capabilities
=
profile
-
>
GetSecurityCapabilities
(
)
;
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES
security_capabilities
.
get
(
)
sizeof
(
SECURITY_CAPABILITIES
)
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
if
(
profile
-
>
GetEnableLowPrivilegeAppContainer
(
)
)
{
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY
&
all_applications_package_policy
sizeof
(
all_applications_package_policy
)
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
}
}
if
(
!
thread_pool_
)
thread_pool_
=
std
:
:
make_unique
<
Win2kThreadPool
>
(
)
;
base
:
:
win
:
:
ScopedProcessInformation
process_info
;
TargetProcess
*
target
=
new
TargetProcess
(
std
:
:
move
(
initial_token
)
std
:
:
move
(
lockdown_token
)
job
.
Get
(
)
thread_pool_
.
get
(
)
profile
?
profile
-
>
GetImpersonationCapabilities
(
)
:
std
:
:
vector
<
Sid
>
(
)
)
;
result
=
target
-
>
Create
(
exe_path
command_line
inherit_handles
startup_info
&
process_info
env_map
last_error
)
;
if
(
result
!
=
SBOX_ALL_OK
)
{
SpawnCleanup
(
target
)
;
return
result
;
}
if
(
lowbox_token
.
IsValid
(
)
)
{
*
last_warning
=
target
-
>
AssignLowBoxToken
(
lowbox_token
)
;
if
(
*
last_warning
!
=
SBOX_ALL_OK
)
*
last_error
=
:
:
GetLastError
(
)
;
}
result
=
policy_base
-
>
AddTarget
(
target
)
;
if
(
result
!
=
SBOX_ALL_OK
)
{
*
last_error
=
:
:
GetLastError
(
)
;
SpawnCleanup
(
target
)
;
return
result
;
}
if
(
job
.
IsValid
(
)
)
{
std
:
:
unique_ptr
<
JobTracker
>
tracker
=
std
:
:
make_unique
<
JobTracker
>
(
std
:
:
move
(
job
)
policy_base
)
;
CHECK
(
AssociateCompletionPort
(
tracker
-
>
job
.
Get
(
)
job_port_
.
Get
(
)
tracker
.
get
(
)
)
)
;
tracker_list_
.
push_back
(
std
:
:
move
(
tracker
)
)
;
child_process_ids_
.
insert
(
process_info
.
process_id
(
)
)
;
}
else
{
policy_base
-
>
AddRef
(
)
;
if
(
child_process_ids_
.
empty
(
)
)
:
:
SetEvent
(
no_targets_
.
Get
(
)
)
;
AddTargetPeer
(
process_info
.
process_handle
(
)
)
;
}
*
target_info
=
process_info
.
Take
(
)
;
return
result
;
}
ResultCode
BrokerServicesBase
:
:
WaitForAllTargets
(
)
{
:
:
WaitForSingleObject
(
no_targets_
.
Get
(
)
INFINITE
)
;
return
SBOX_ALL_OK
;
}
bool
BrokerServicesBase
:
:
IsActiveTarget
(
DWORD
process_id
)
{
AutoLock
lock
(
&
lock_
)
;
return
child_process_ids_
.
find
(
process_id
)
!
=
child_process_ids_
.
end
(
)
|
|
peer_map_
.
find
(
process_id
)
!
=
peer_map_
.
end
(
)
;
}
VOID
CALLBACK
BrokerServicesBase
:
:
RemovePeer
(
PVOID
parameter
BOOLEAN
timeout
)
{
PeerTracker
*
peer
=
reinterpret_cast
<
PeerTracker
*
>
(
parameter
)
;
:
:
PostQueuedCompletionStatus
(
peer
-
>
job_port
0
THREAD_CTRL_REMOVE_PEER
reinterpret_cast
<
LPOVERLAPPED
>
(
static_cast
<
uintptr_t
>
(
peer
-
>
id
)
)
)
;
}
ResultCode
BrokerServicesBase
:
:
AddTargetPeer
(
HANDLE
peer_process
)
{
std
:
:
unique_ptr
<
PeerTracker
>
peer
(
new
PeerTracker
(
:
:
GetProcessId
(
peer_process
)
job_port_
.
Get
(
)
)
)
;
if
(
!
peer
-
>
id
)
return
SBOX_ERROR_GENERIC
;
HANDLE
process_handle
;
if
(
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
peer_process
:
:
GetCurrentProcess
(
)
&
process_handle
SYNCHRONIZE
FALSE
0
)
)
{
return
SBOX_ERROR_GENERIC
;
}
peer
-
>
process
.
Set
(
process_handle
)
;
AutoLock
lock
(
&
lock_
)
;
if
(
!
peer_map_
.
insert
(
std
:
:
make_pair
(
peer
-
>
id
peer
.
get
(
)
)
)
.
second
)
return
SBOX_ERROR_BAD_PARAMS
;
if
(
!
:
:
RegisterWaitForSingleObject
(
&
peer
-
>
wait_object
peer
-
>
process
.
Get
(
)
RemovePeer
peer
.
get
(
)
INFINITE
WT_EXECUTEONLYONCE
|
WT_EXECUTEINWAITTHREAD
)
)
{
peer_map_
.
erase
(
peer
-
>
id
)
;
return
SBOX_ERROR_GENERIC
;
}
ignore_result
(
peer
.
release
(
)
)
;
return
SBOX_ALL_OK
;
}
}
