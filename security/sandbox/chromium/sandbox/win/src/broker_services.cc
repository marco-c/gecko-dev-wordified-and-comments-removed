#
include
"
sandbox
/
win
/
src
/
broker_services
.
h
"
#
include
<
aclapi
.
h
>
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
memory
/
ptr_util
.
h
"
#
include
"
base
/
threading
/
platform_thread
.
h
"
#
include
"
base
/
win
/
scoped_handle
.
h
"
#
include
"
base
/
win
/
scoped_process_information
.
h
"
#
include
"
base
/
win
/
startup_information
.
h
"
#
include
"
base
/
win
/
windows_version
.
h
"
#
include
"
sandbox
/
win
/
src
/
app_container_profile
.
h
"
#
include
"
sandbox
/
win
/
src
/
process_mitigations
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_policy_base
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_policy_diagnostic
.
h
"
#
include
"
sandbox
/
win
/
src
/
target_process
.
h
"
#
include
"
sandbox
/
win
/
src
/
win2k_threadpool
.
h
"
#
include
"
sandbox
/
win
/
src
/
win_utils
.
h
"
namespace
{
bool
AssociateCompletionPort
(
HANDLE
job
HANDLE
port
void
*
key
)
{
JOBOBJECT_ASSOCIATE_COMPLETION_PORT
job_acp
=
{
key
port
}
;
return
:
:
SetInformationJobObject
(
job
JobObjectAssociateCompletionPortInformation
&
job_acp
sizeof
(
job_acp
)
)
?
true
:
false
;
}
sandbox
:
:
ResultCode
SpawnCleanup
(
sandbox
:
:
TargetProcess
*
target
)
{
target
-
>
Terminate
(
)
;
delete
target
;
return
sandbox
:
:
SBOX_ERROR_GENERIC
;
}
enum
{
THREAD_CTRL_NONE
THREAD_CTRL_NEW_JOB_TRACKER
THREAD_CTRL_NEW_PROCESS_TRACKER
THREAD_CTRL_PROCESS_SIGNALLED
THREAD_CTRL_GET_POLICY_INFO
THREAD_CTRL_QUIT
THREAD_CTRL_LAST
}
;
struct
JobTracker
{
JobTracker
(
base
:
:
win
:
:
ScopedHandle
job
scoped_refptr
<
sandbox
:
:
PolicyBase
>
policy
DWORD
process_id
)
:
job
(
std
:
:
move
(
job
)
)
policy
(
policy
)
process_id
(
process_id
)
{
}
~
JobTracker
(
)
{
FreeResources
(
)
;
}
void
FreeResources
(
)
;
base
:
:
win
:
:
ScopedHandle
job
;
scoped_refptr
<
sandbox
:
:
PolicyBase
>
policy
;
DWORD
process_id
;
}
;
void
JobTracker
:
:
FreeResources
(
)
{
if
(
policy
)
{
bool
res
=
:
:
TerminateJobObject
(
job
.
Get
(
)
sandbox
:
:
SBOX_ALL_OK
)
;
DCHECK
(
res
)
;
HANDLE
stale_job_handle
=
job
.
Get
(
)
;
job
.
Close
(
)
;
policy
-
>
OnJobEmpty
(
stale_job_handle
)
;
policy
=
nullptr
;
}
}
struct
ProcessTracker
{
ProcessTracker
(
scoped_refptr
<
sandbox
:
:
PolicyBase
>
policy
DWORD
process_id
base
:
:
win
:
:
ScopedHandle
process
)
:
policy
(
policy
)
process_id
(
process_id
)
process
(
std
:
:
move
(
process
)
)
{
}
~
ProcessTracker
(
)
{
FreeResources
(
)
;
}
void
FreeResources
(
)
;
scoped_refptr
<
sandbox
:
:
PolicyBase
>
policy
;
DWORD
process_id
;
base
:
:
win
:
:
ScopedHandle
process
;
HANDLE
wait_handle
;
HANDLE
iocp
;
}
;
void
ProcessTracker
:
:
FreeResources
(
)
{
if
(
policy
)
{
policy
-
>
OnJobEmpty
(
nullptr
)
;
policy
=
nullptr
;
}
}
void
WINAPI
ProcessEventCallback
(
PVOID
param
BOOLEAN
ignored
)
{
ProcessTracker
*
tracker
=
reinterpret_cast
<
ProcessTracker
*
>
(
param
)
;
:
:
PostQueuedCompletionStatus
(
tracker
-
>
iocp
0
THREAD_CTRL_PROCESS_SIGNALLED
reinterpret_cast
<
LPOVERLAPPED
>
(
tracker
)
)
;
}
class
PolicyDiagnosticList
final
:
public
sandbox
:
:
PolicyList
{
public
:
PolicyDiagnosticList
(
)
{
}
~
PolicyDiagnosticList
(
)
override
{
}
void
push_back
(
std
:
:
unique_ptr
<
sandbox
:
:
PolicyInfo
>
info
)
{
internal_list_
.
push_back
(
std
:
:
move
(
info
)
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
sandbox
:
:
PolicyInfo
>
>
:
:
iterator
begin
(
)
override
{
return
internal_list_
.
begin
(
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
sandbox
:
:
PolicyInfo
>
>
:
:
iterator
end
(
)
override
{
return
internal_list_
.
end
(
)
;
}
size_t
size
(
)
const
override
{
return
internal_list_
.
size
(
)
;
}
private
:
std
:
:
vector
<
std
:
:
unique_ptr
<
sandbox
:
:
PolicyInfo
>
>
internal_list_
;
}
;
}
namespace
sandbox
{
BrokerServicesBase
:
:
BrokerServicesBase
(
)
{
}
ResultCode
BrokerServicesBase
:
:
Init
(
)
{
if
(
job_port_
.
IsValid
(
)
|
|
thread_pool_
)
return
SBOX_ERROR_UNEXPECTED_CALL
;
:
:
InitializeCriticalSection
(
&
lock_
)
;
job_port_
.
Set
(
:
:
CreateIoCompletionPort
(
INVALID_HANDLE_VALUE
nullptr
0
0
)
)
;
if
(
!
job_port_
.
IsValid
(
)
)
return
SBOX_ERROR_CANNOT_INIT_BROKERSERVICES
;
no_targets_
.
Set
(
:
:
CreateEventW
(
nullptr
true
false
nullptr
)
)
;
job_thread_
.
Set
(
:
:
CreateThread
(
nullptr
0
TargetEventsThread
this
0
nullptr
)
)
;
if
(
!
job_thread_
.
IsValid
(
)
)
return
SBOX_ERROR_CANNOT_INIT_BROKERSERVICES
;
if
(
!
SharedMemIPCServer
:
:
CreateBrokerAliveMutex
(
)
)
return
SBOX_ERROR_CANNOT_INIT_BROKERSERVICES
;
return
SBOX_ALL_OK
;
}
BrokerServicesBase
:
:
~
BrokerServicesBase
(
)
{
if
(
!
job_port_
.
IsValid
(
)
)
return
;
:
:
PostQueuedCompletionStatus
(
job_port_
.
Get
(
)
0
THREAD_CTRL_QUIT
nullptr
)
;
if
(
job_thread_
.
IsValid
(
)
&
&
WAIT_TIMEOUT
=
=
:
:
WaitForSingleObject
(
job_thread_
.
Get
(
)
1000
)
)
{
NOTREACHED
(
)
;
return
;
}
thread_pool_
.
reset
(
)
;
:
:
DeleteCriticalSection
(
&
lock_
)
;
}
scoped_refptr
<
TargetPolicy
>
BrokerServicesBase
:
:
CreatePolicy
(
)
{
scoped_refptr
<
TargetPolicy
>
policy
(
new
PolicyBase
)
;
policy
-
>
Release
(
)
;
return
policy
;
}
DWORD
WINAPI
BrokerServicesBase
:
:
TargetEventsThread
(
PVOID
param
)
{
if
(
!
param
)
return
1
;
base
:
:
PlatformThread
:
:
SetName
(
"
BrokerEvent
"
)
;
BrokerServicesBase
*
broker
=
reinterpret_cast
<
BrokerServicesBase
*
>
(
param
)
;
HANDLE
port
=
broker
-
>
job_port_
.
Get
(
)
;
HANDLE
no_targets
=
broker
-
>
no_targets_
.
Get
(
)
;
std
:
:
set
<
DWORD
>
child_process_ids
;
std
:
:
list
<
std
:
:
unique_ptr
<
JobTracker
>
>
jobs
;
std
:
:
list
<
std
:
:
unique_ptr
<
ProcessTracker
>
>
processes
;
int
target_counter
=
0
;
int
untracked_target_counter
=
0
;
:
:
ResetEvent
(
no_targets
)
;
while
(
true
)
{
DWORD
events
=
0
;
ULONG_PTR
key
=
0
;
LPOVERLAPPED
ovl
=
nullptr
;
if
(
!
:
:
GetQueuedCompletionStatus
(
port
&
events
&
key
&
ovl
INFINITE
)
)
{
return
1
;
}
if
(
key
>
THREAD_CTRL_LAST
)
{
JobTracker
*
tracker
=
reinterpret_cast
<
JobTracker
*
>
(
key
)
;
if
(
std
:
:
find_if
(
jobs
.
begin
(
)
jobs
.
end
(
)
[
&
]
(
auto
&
&
p
)
-
>
bool
{
return
p
.
get
(
)
=
=
tracker
;
}
)
=
=
jobs
.
end
(
)
)
{
CHECK
(
false
)
;
}
switch
(
events
)
{
case
JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO
:
{
HANDLE
job_handle
=
tracker
-
>
job
.
Get
(
)
;
jobs
.
erase
(
std
:
:
remove_if
(
jobs
.
begin
(
)
jobs
.
end
(
)
[
&
]
(
auto
&
&
p
)
-
>
bool
{
return
p
-
>
job
.
Get
(
)
=
=
job_handle
;
}
)
jobs
.
end
(
)
)
;
break
;
}
case
JOB_OBJECT_MSG_NEW_PROCESS
:
{
DWORD
process_id
=
static_cast
<
DWORD
>
(
reinterpret_cast
<
uintptr_t
>
(
ovl
)
)
;
size_t
count
=
child_process_ids
.
count
(
process_id
)
;
if
(
count
=
=
0
)
untracked_target_counter
+
+
;
+
+
target_counter
;
if
(
1
=
=
target_counter
)
{
:
:
ResetEvent
(
no_targets
)
;
}
break
;
}
case
JOB_OBJECT_MSG_EXIT_PROCESS
:
case
JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS
:
{
{
AutoLock
lock
(
&
broker
-
>
lock_
)
;
broker
-
>
active_targets_
.
erase
(
static_cast
<
DWORD
>
(
reinterpret_cast
<
uintptr_t
>
(
ovl
)
)
)
;
}
size_t
erase_result
=
child_process_ids
.
erase
(
static_cast
<
DWORD
>
(
reinterpret_cast
<
uintptr_t
>
(
ovl
)
)
)
;
if
(
erase_result
!
=
1U
)
{
-
-
untracked_target_counter
;
DCHECK
(
untracked_target_counter
>
=
0
)
;
}
-
-
target_counter
;
if
(
0
=
=
target_counter
)
:
:
SetEvent
(
no_targets
)
;
DCHECK
(
target_counter
>
=
0
)
;
break
;
}
case
JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT
:
{
untracked_target_counter
+
+
;
target_counter
+
+
;
break
;
}
case
JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT
:
{
bool
res
=
:
:
TerminateJobObject
(
tracker
-
>
job
.
Get
(
)
SBOX_FATAL_MEMORY_EXCEEDED
)
;
DCHECK
(
res
)
;
break
;
}
default
:
{
NOTREACHED
(
)
;
break
;
}
}
}
else
if
(
THREAD_CTRL_NEW_JOB_TRACKER
=
=
key
)
{
std
:
:
unique_ptr
<
JobTracker
>
tracker
;
tracker
.
reset
(
reinterpret_cast
<
JobTracker
*
>
(
ovl
)
)
;
DCHECK
(
tracker
-
>
job
.
IsValid
(
)
)
;
child_process_ids
.
insert
(
tracker
-
>
process_id
)
;
jobs
.
push_back
(
std
:
:
move
(
tracker
)
)
;
}
else
if
(
THREAD_CTRL_NEW_PROCESS_TRACKER
=
=
key
)
{
std
:
:
unique_ptr
<
ProcessTracker
>
tracker
;
tracker
.
reset
(
reinterpret_cast
<
ProcessTracker
*
>
(
ovl
)
)
;
if
(
child_process_ids
.
empty
(
)
)
{
:
:
SetEvent
(
broker
-
>
no_targets_
.
Get
(
)
)
;
}
tracker
-
>
iocp
=
port
;
if
(
!
:
:
RegisterWaitForSingleObject
(
&
(
tracker
-
>
wait_handle
)
tracker
-
>
process
.
Get
(
)
ProcessEventCallback
tracker
.
get
(
)
INFINITE
WT_EXECUTEONLYONCE
)
)
{
tracker
-
>
wait_handle
=
INVALID_HANDLE_VALUE
;
}
processes
.
push_back
(
std
:
:
move
(
tracker
)
)
;
}
else
if
(
THREAD_CTRL_PROCESS_SIGNALLED
=
=
key
)
{
ProcessTracker
*
tracker
=
static_cast
<
ProcessTracker
*
>
(
reinterpret_cast
<
void
*
>
(
ovl
)
)
;
{
AutoLock
lock
(
&
broker
-
>
lock_
)
;
broker
-
>
active_targets_
.
erase
(
tracker
-
>
process_id
)
;
}
:
:
UnregisterWait
(
tracker
-
>
wait_handle
)
;
tracker
-
>
wait_handle
=
INVALID_HANDLE_VALUE
;
const
DWORD
process_id
=
tracker
-
>
process_id
;
processes
.
erase
(
std
:
:
remove_if
(
processes
.
begin
(
)
processes
.
end
(
)
[
&
]
(
auto
&
&
p
)
-
>
bool
{
return
p
-
>
process_id
=
=
process_id
;
}
)
processes
.
end
(
)
)
;
}
else
if
(
THREAD_CTRL_GET_POLICY_INFO
=
=
key
)
{
std
:
:
unique_ptr
<
PolicyDiagnosticsReceiver
>
receiver
;
receiver
.
reset
(
static_cast
<
PolicyDiagnosticsReceiver
*
>
(
reinterpret_cast
<
void
*
>
(
ovl
)
)
)
;
auto
policy_list
=
std
:
:
make_unique
<
PolicyDiagnosticList
>
(
)
;
for
(
auto
&
&
process_tracker
:
processes
)
{
if
(
process_tracker
-
>
policy
)
{
policy_list
-
>
push_back
(
std
:
:
make_unique
<
PolicyDiagnostic
>
(
process_tracker
-
>
policy
.
get
(
)
)
)
;
}
}
for
(
auto
&
&
job_tracker
:
jobs
)
{
if
(
job_tracker
-
>
policy
)
{
policy_list
-
>
push_back
(
std
:
:
make_unique
<
PolicyDiagnostic
>
(
job_tracker
-
>
policy
.
get
(
)
)
)
;
}
}
receiver
-
>
ReceiveDiagnostics
(
std
:
:
move
(
policy_list
)
)
;
}
else
if
(
THREAD_CTRL_QUIT
=
=
key
)
{
for
(
auto
&
&
tracker
:
processes
)
{
:
:
UnregisterWait
(
tracker
-
>
wait_handle
)
;
tracker
-
>
wait_handle
=
INVALID_HANDLE_VALUE
;
}
return
0
;
}
else
{
NOTREACHED
(
)
;
}
}
NOTREACHED
(
)
;
return
0
;
}
ResultCode
BrokerServicesBase
:
:
SpawnTarget
(
const
wchar_t
*
exe_path
const
wchar_t
*
command_line
base
:
:
EnvironmentMap
&
env_map
scoped_refptr
<
TargetPolicy
>
policy
ResultCode
*
last_warning
DWORD
*
last_error
PROCESS_INFORMATION
*
target_info
)
{
if
(
!
exe_path
)
return
SBOX_ERROR_BAD_PARAMS
;
if
(
!
policy
)
return
SBOX_ERROR_BAD_PARAMS
;
static
DWORD
thread_id
=
:
:
GetCurrentThreadId
(
)
;
DCHECK
(
thread_id
=
=
:
:
GetCurrentThreadId
(
)
)
;
*
last_warning
=
SBOX_ALL_OK
;
static
bool
launcher_thread_opted_out
=
false
;
if
(
!
launcher_thread_opted_out
)
{
sandbox
:
:
ApplyMitigationsToCurrentThread
(
sandbox
:
:
MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD
)
;
launcher_thread_opted_out
=
true
;
}
scoped_refptr
<
PolicyBase
>
policy_base
(
static_cast
<
PolicyBase
*
>
(
policy
.
get
(
)
)
)
;
base
:
:
win
:
:
ScopedHandle
initial_token
;
base
:
:
win
:
:
ScopedHandle
lockdown_token
;
base
:
:
win
:
:
ScopedHandle
lowbox_token
;
ResultCode
result
=
SBOX_ALL_OK
;
result
=
policy_base
-
>
MakeTokens
(
&
initial_token
&
lockdown_token
&
lowbox_token
)
;
if
(
SBOX_ALL_OK
!
=
result
)
return
result
;
if
(
lowbox_token
.
IsValid
(
)
&
&
base
:
:
win
:
:
GetVersion
(
)
<
base
:
:
win
:
:
Version
:
:
WIN8
)
{
return
SBOX_ERROR_BAD_PARAMS
;
}
base
:
:
win
:
:
ScopedHandle
job
;
result
=
policy_base
-
>
MakeJobObject
(
&
job
)
;
if
(
SBOX_ALL_OK
!
=
result
)
return
result
;
base
:
:
win
:
:
StartupInformation
startup_info
;
startup_info
.
startup_info
(
)
-
>
dwFlags
|
=
STARTF_FORCEOFFFEEDBACK
;
DWORD64
mitigations
[
2
]
;
std
:
:
vector
<
HANDLE
>
inherited_handle_list
;
DWORD
child_process_creation
=
PROCESS_CREATION_CHILD_PROCESS_RESTRICTED
;
std
:
:
wstring
desktop
=
policy_base
-
>
GetAlternateDesktop
(
)
;
if
(
!
desktop
.
empty
(
)
)
{
startup_info
.
startup_info
(
)
-
>
lpDesktop
=
const_cast
<
wchar_t
*
>
(
desktop
.
c_str
(
)
)
;
}
bool
inherit_handles
=
false
;
int
attribute_count
=
0
;
size_t
mitigations_size
;
ConvertProcessMitigationsToPolicy
(
policy_base
-
>
GetProcessMitigations
(
)
&
mitigations
[
0
]
&
mitigations_size
)
;
if
(
mitigations
[
0
]
|
|
mitigations
[
1
]
)
+
+
attribute_count
;
bool
restrict_child_process_creation
=
false
;
if
(
base
:
:
win
:
:
GetVersion
(
)
>
=
base
:
:
win
:
:
Version
:
:
WIN10_TH2
&
&
policy_base
-
>
GetJobLevel
(
)
<
=
JOB_LIMITED_USER
)
{
restrict_child_process_creation
=
true
;
+
+
attribute_count
;
}
HANDLE
stdout_handle
=
policy_base
-
>
GetStdoutHandle
(
)
;
HANDLE
stderr_handle
=
policy_base
-
>
GetStderrHandle
(
)
;
if
(
stdout_handle
!
=
INVALID_HANDLE_VALUE
)
inherited_handle_list
.
push_back
(
stdout_handle
)
;
if
(
stderr_handle
!
=
stdout_handle
&
&
stderr_handle
!
=
INVALID_HANDLE_VALUE
)
inherited_handle_list
.
push_back
(
stderr_handle
)
;
const
auto
&
policy_handle_list
=
policy_base
-
>
GetHandlesBeingShared
(
)
;
for
(
HANDLE
handle
:
policy_handle_list
)
inherited_handle_list
.
push_back
(
handle
)
;
if
(
inherited_handle_list
.
size
(
)
)
+
+
attribute_count
;
scoped_refptr
<
AppContainerProfileBase
>
profile
=
policy_base
-
>
GetAppContainerProfileBase
(
)
;
if
(
profile
)
{
if
(
base
:
:
win
:
:
GetVersion
(
)
<
base
:
:
win
:
:
Version
:
:
WIN8
)
return
SBOX_ERROR_BAD_PARAMS
;
+
+
attribute_count
;
if
(
profile
-
>
GetEnableLowPrivilegeAppContainer
(
)
)
{
if
(
base
:
:
win
:
:
GetVersion
(
)
<
base
:
:
win
:
:
Version
:
:
WIN10_RS1
)
return
SBOX_ERROR_BAD_PARAMS
;
+
+
attribute_count
;
}
}
if
(
!
startup_info
.
InitializeProcThreadAttributeList
(
attribute_count
)
)
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
if
(
mitigations
[
0
]
|
|
mitigations
[
1
]
)
{
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY
&
mitigations
[
0
]
mitigations_size
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
}
if
(
restrict_child_process_creation
)
{
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY
&
child_process_creation
sizeof
(
child_process_creation
)
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
}
if
(
inherited_handle_list
.
size
(
)
)
{
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_HANDLE_LIST
&
inherited_handle_list
[
0
]
sizeof
(
HANDLE
)
*
inherited_handle_list
.
size
(
)
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
startup_info
.
startup_info
(
)
-
>
dwFlags
|
=
STARTF_USESTDHANDLES
;
startup_info
.
startup_info
(
)
-
>
hStdInput
=
INVALID_HANDLE_VALUE
;
startup_info
.
startup_info
(
)
-
>
hStdOutput
=
stdout_handle
;
startup_info
.
startup_info
(
)
-
>
hStdError
=
stderr_handle
;
inherit_handles
=
true
;
}
std
:
:
unique_ptr
<
SecurityCapabilities
>
security_capabilities
;
DWORD
all_applications_package_policy
=
PROCESS_CREATION_ALL_APPLICATION_PACKAGES_OPT_OUT
;
if
(
profile
)
{
security_capabilities
=
profile
-
>
GetSecurityCapabilities
(
)
;
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES
security_capabilities
.
get
(
)
sizeof
(
SECURITY_CAPABILITIES
)
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
if
(
profile
-
>
GetEnableLowPrivilegeAppContainer
(
)
)
{
if
(
!
startup_info
.
UpdateProcThreadAttribute
(
PROC_THREAD_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY
&
all_applications_package_policy
sizeof
(
all_applications_package_policy
)
)
)
{
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
}
}
}
if
(
!
thread_pool_
)
thread_pool_
=
std
:
:
make_unique
<
Win2kThreadPool
>
(
)
;
base
:
:
win
:
:
ScopedProcessInformation
process_info
;
TargetProcess
*
target
=
new
TargetProcess
(
std
:
:
move
(
initial_token
)
std
:
:
move
(
lockdown_token
)
job
.
Get
(
)
thread_pool_
.
get
(
)
profile
?
profile
-
>
GetImpersonationCapabilities
(
)
:
std
:
:
vector
<
Sid
>
(
)
)
;
result
=
target
-
>
Create
(
exe_path
command_line
inherit_handles
startup_info
&
process_info
env_map
last_error
)
;
if
(
result
!
=
SBOX_ALL_OK
)
{
SpawnCleanup
(
target
)
;
return
result
;
}
if
(
lowbox_token
.
IsValid
(
)
)
{
*
last_warning
=
target
-
>
AssignLowBoxToken
(
lowbox_token
)
;
if
(
*
last_warning
!
=
SBOX_ALL_OK
)
*
last_error
=
:
:
GetLastError
(
)
;
}
result
=
policy_base
-
>
AddTarget
(
target
)
;
if
(
result
!
=
SBOX_ALL_OK
)
{
*
last_error
=
:
:
GetLastError
(
)
;
SpawnCleanup
(
target
)
;
return
result
;
}
if
(
job
.
IsValid
(
)
)
{
JobTracker
*
tracker
=
new
JobTracker
(
std
:
:
move
(
job
)
policy_base
process_info
.
process_id
(
)
)
;
CHECK
(
:
:
PostQueuedCompletionStatus
(
job_port_
.
Get
(
)
0
THREAD_CTRL_NEW_JOB_TRACKER
reinterpret_cast
<
LPOVERLAPPED
>
(
tracker
)
)
)
;
CHECK
(
AssociateCompletionPort
(
tracker
-
>
job
.
Get
(
)
job_port_
.
Get
(
)
tracker
)
)
;
AutoLock
lock
(
&
lock_
)
;
active_targets_
.
insert
(
process_info
.
process_id
(
)
)
;
}
else
{
result
=
AddTargetPeerInternal
(
process_info
.
process_handle
(
)
process_info
.
process_id
(
)
policy_base
last_error
)
;
if
(
result
!
=
SBOX_ALL_OK
)
{
target
-
>
Terminate
(
)
;
return
result
;
}
}
*
target_info
=
process_info
.
Take
(
)
;
return
result
;
}
ResultCode
BrokerServicesBase
:
:
WaitForAllTargets
(
)
{
:
:
WaitForSingleObject
(
no_targets_
.
Get
(
)
INFINITE
)
;
return
SBOX_ALL_OK
;
}
bool
BrokerServicesBase
:
:
IsSafeDuplicationTarget
(
DWORD
process_id
)
{
AutoLock
lock
(
&
lock_
)
;
return
active_targets_
.
find
(
process_id
)
!
=
active_targets_
.
end
(
)
;
}
ResultCode
BrokerServicesBase
:
:
AddTargetPeerInternal
(
HANDLE
peer_process_handle
DWORD
peer_process_id
scoped_refptr
<
PolicyBase
>
policy_base
DWORD
*
last_error
)
{
HANDLE
tmp_process_handle
=
INVALID_HANDLE_VALUE
;
if
(
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
peer_process_handle
:
:
GetCurrentProcess
(
)
&
tmp_process_handle
SYNCHRONIZE
false
0
)
)
{
*
last_error
=
:
:
GetLastError
(
)
;
return
SBOX_ERROR_CANNOT_DUPLICATE_PROCESS_HANDLE
;
}
base
:
:
win
:
:
ScopedHandle
dup_process_handle
(
tmp_process_handle
)
;
ProcessTracker
*
tracker
=
new
ProcessTracker
(
policy_base
peer_process_id
std
:
:
move
(
dup_process_handle
)
)
;
:
:
PostQueuedCompletionStatus
(
job_port_
.
Get
(
)
0
THREAD_CTRL_NEW_PROCESS_TRACKER
reinterpret_cast
<
LPOVERLAPPED
>
(
tracker
)
)
;
AutoLock
lock
(
&
lock_
)
;
active_targets_
.
insert
(
peer_process_id
)
;
return
SBOX_ALL_OK
;
}
ResultCode
BrokerServicesBase
:
:
AddTargetPeer
(
HANDLE
peer_process
)
{
DWORD
last_error
;
return
AddTargetPeerInternal
(
peer_process
:
:
GetProcessId
(
peer_process
)
nullptr
&
last_error
)
;
}
ResultCode
BrokerServicesBase
:
:
GetPolicyDiagnostics
(
std
:
:
unique_ptr
<
PolicyDiagnosticsReceiver
>
receiver
)
{
CHECK
(
job_thread_
.
IsValid
(
)
)
;
if
(
!
:
:
PostQueuedCompletionStatus
(
job_port_
.
Get
(
)
0
THREAD_CTRL_GET_POLICY_INFO
reinterpret_cast
<
LPOVERLAPPED
>
(
receiver
.
get
(
)
)
)
)
{
receiver
-
>
OnError
(
SBOX_ERROR_GENERIC
)
;
return
SBOX_ERROR_GENERIC
;
}
receiver
.
release
(
)
;
return
SBOX_ALL_OK
;
}
bool
BrokerServicesBase
:
:
DeriveCapabilitySidFromName
(
const
wchar_t
*
name
PSID
derived_sid
DWORD
sid_buffer_length
)
{
return
:
:
CopySid
(
sid_buffer_length
derived_sid
Sid
:
:
FromNamedCapability
(
name
)
.
GetPSID
(
)
)
;
}
}
