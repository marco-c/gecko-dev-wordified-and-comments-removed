#
include
"
sandbox
/
win
/
src
/
broker_services
.
h
"
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
containers
/
contains
.
h
"
#
include
"
base
/
memory
/
ptr_util
.
h
"
#
include
"
base
/
notreached
.
h
"
#
include
"
base
/
threading
/
platform_thread
.
h
"
#
include
"
base
/
win
/
access_token
.
h
"
#
include
"
base
/
win
/
current_module
.
h
"
#
include
"
base
/
win
/
scoped_handle
.
h
"
#
include
"
base
/
win
/
scoped_process_information
.
h
"
#
include
"
base
/
win
/
sid
.
h
"
#
include
"
base
/
win
/
windows_version
.
h
"
#
include
"
build
/
build_config
.
h
"
#
include
"
sandbox
/
win
/
src
/
app_container
.
h
"
#
include
"
sandbox
/
win
/
src
/
process_mitigations
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_policy_base
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_policy_diagnostic
.
h
"
#
include
"
sandbox
/
win
/
src
/
startup_information_helper
.
h
"
#
include
"
sandbox
/
win
/
src
/
target_process
.
h
"
#
include
"
sandbox
/
win
/
src
/
threadpool
.
h
"
#
include
"
sandbox
/
win
/
src
/
win_utils
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
namespace
{
bool
AssociateCompletionPort
(
HANDLE
job
HANDLE
port
void
*
key
)
{
JOBOBJECT_ASSOCIATE_COMPLETION_PORT
job_acp
=
{
key
port
}
;
return
:
:
SetInformationJobObject
(
job
JobObjectAssociateCompletionPortInformation
&
job_acp
sizeof
(
job_acp
)
)
?
true
:
false
;
}
enum
{
THREAD_CTRL_NONE
THREAD_CTRL_NEW_JOB_TRACKER
THREAD_CTRL_GET_POLICY_INFO
THREAD_CTRL_QUIT
THREAD_CTRL_LAST
}
;
struct
TargetEventsThreadParams
{
TargetEventsThreadParams
(
HANDLE
iocp
std
:
:
unique_ptr
<
sandbox
:
:
BrokerServicesTargetTracker
>
target_tracker
std
:
:
unique_ptr
<
sandbox
:
:
ThreadPool
>
thread_pool
)
:
iocp
(
iocp
)
target_tracker_
(
std
:
:
move
(
target_tracker
)
)
thread_pool
(
std
:
:
move
(
thread_pool
)
)
{
}
~
TargetEventsThreadParams
(
)
{
}
HANDLE
iocp
;
std
:
:
unique_ptr
<
sandbox
:
:
BrokerServicesTargetTracker
>
target_tracker_
;
std
:
:
unique_ptr
<
sandbox
:
:
ThreadPool
>
thread_pool
;
}
;
struct
JobTracker
{
JobTracker
(
std
:
:
unique_ptr
<
sandbox
:
:
PolicyBase
>
policy
DWORD
process_id
)
:
policy
(
std
:
:
move
(
policy
)
)
process_id
(
process_id
)
{
}
~
JobTracker
(
)
{
:
:
TerminateJobObject
(
policy
-
>
GetJobHandle
(
)
sandbox
:
:
SBOX_ALL_OK
)
;
}
std
:
:
unique_ptr
<
sandbox
:
:
PolicyBase
>
policy
;
DWORD
process_id
;
}
;
class
PolicyDiagnosticList
final
:
public
sandbox
:
:
PolicyList
{
public
:
PolicyDiagnosticList
(
)
{
}
~
PolicyDiagnosticList
(
)
override
{
}
void
push_back
(
std
:
:
unique_ptr
<
sandbox
:
:
PolicyInfo
>
info
)
{
internal_list_
.
push_back
(
std
:
:
move
(
info
)
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
sandbox
:
:
PolicyInfo
>
>
:
:
iterator
begin
(
)
override
{
return
internal_list_
.
begin
(
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
sandbox
:
:
PolicyInfo
>
>
:
:
iterator
end
(
)
override
{
return
internal_list_
.
end
(
)
;
}
size_t
size
(
)
const
override
{
return
internal_list_
.
size
(
)
;
}
private
:
std
:
:
vector
<
std
:
:
unique_ptr
<
sandbox
:
:
PolicyInfo
>
>
internal_list_
;
}
;
DWORD
WINAPI
TargetEventsThread
(
PVOID
param
)
{
if
(
!
param
)
return
1
;
base
:
:
PlatformThread
:
:
SetName
(
"
BrokerEvent
"
)
;
std
:
:
unique_ptr
<
TargetEventsThreadParams
>
params
(
reinterpret_cast
<
TargetEventsThreadParams
*
>
(
param
)
)
;
std
:
:
list
<
std
:
:
unique_ptr
<
JobTracker
>
>
jobs
;
while
(
true
)
{
DWORD
event
=
0
;
ULONG_PTR
key
=
0
;
LPOVERLAPPED
ovl
=
nullptr
;
if
(
!
:
:
GetQueuedCompletionStatus
(
params
-
>
iocp
&
event
&
key
&
ovl
INFINITE
)
)
{
return
1
;
}
if
(
key
>
THREAD_CTRL_LAST
)
{
JobTracker
*
tracker
=
reinterpret_cast
<
JobTracker
*
>
(
key
)
;
if
(
!
base
:
:
Contains
(
jobs
tracker
&
std
:
:
unique_ptr
<
JobTracker
>
:
:
get
)
)
{
CHECK_NE
(
static_cast
<
int
>
(
event
)
JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO
)
;
continue
;
}
switch
(
event
)
{
case
JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO
:
{
jobs
.
erase
(
std
:
:
remove_if
(
jobs
.
begin
(
)
jobs
.
end
(
)
[
&
]
(
auto
&
&
p
)
-
>
bool
{
return
p
.
get
(
)
=
=
tracker
;
}
)
jobs
.
end
(
)
)
;
break
;
}
case
JOB_OBJECT_MSG_NEW_PROCESS
:
{
if
(
params
-
>
target_tracker_
)
{
params
-
>
target_tracker_
-
>
OnTargetAdded
(
)
;
}
break
;
}
case
JOB_OBJECT_MSG_EXIT_PROCESS
:
case
JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS
:
{
if
(
params
-
>
target_tracker_
)
{
params
-
>
target_tracker_
-
>
OnTargetRemoved
(
)
;
}
break
;
}
case
JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT
:
{
if
(
params
-
>
target_tracker_
)
{
params
-
>
target_tracker_
-
>
OnTargetAdded
(
)
;
}
break
;
}
case
JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT
:
{
bool
res
=
:
:
TerminateJobObject
(
tracker
-
>
policy
-
>
GetJobHandle
(
)
sandbox
:
:
SBOX_FATAL_MEMORY_EXCEEDED
)
;
DCHECK
(
res
)
;
if
(
params
-
>
target_tracker_
)
{
params
-
>
target_tracker_
-
>
OnTargetRemoved
(
)
;
}
break
;
}
default
:
{
NOTREACHED
(
)
;
break
;
}
}
}
else
if
(
THREAD_CTRL_NEW_JOB_TRACKER
=
=
key
)
{
std
:
:
unique_ptr
<
JobTracker
>
tracker
;
tracker
.
reset
(
reinterpret_cast
<
JobTracker
*
>
(
ovl
)
)
;
DCHECK
(
tracker
-
>
policy
-
>
HasJob
(
)
)
;
jobs
.
push_back
(
std
:
:
move
(
tracker
)
)
;
}
else
if
(
THREAD_CTRL_GET_POLICY_INFO
=
=
key
)
{
std
:
:
unique_ptr
<
sandbox
:
:
PolicyDiagnosticsReceiver
>
receiver
;
receiver
.
reset
(
static_cast
<
sandbox
:
:
PolicyDiagnosticsReceiver
*
>
(
reinterpret_cast
<
void
*
>
(
ovl
)
)
)
;
auto
policy_list
=
std
:
:
make_unique
<
PolicyDiagnosticList
>
(
)
;
for
(
auto
&
&
job_tracker
:
jobs
)
{
if
(
job_tracker
-
>
policy
)
{
policy_list
-
>
push_back
(
std
:
:
make_unique
<
sandbox
:
:
PolicyDiagnostic
>
(
job_tracker
-
>
policy
.
get
(
)
)
)
;
}
}
receiver
-
>
ReceiveDiagnostics
(
std
:
:
move
(
policy_list
)
)
;
}
else
if
(
THREAD_CTRL_QUIT
=
=
key
)
{
return
0
;
}
else
{
NOTREACHED
(
)
;
}
}
NOTREACHED
(
)
;
return
0
;
}
}
namespace
sandbox
{
BrokerServicesBase
:
:
BrokerServicesBase
(
)
{
}
ResultCode
BrokerServicesBase
:
:
Init
(
std
:
:
unique_ptr
<
BrokerServicesTargetTracker
>
target_tracker
)
{
if
(
job_port_
.
IsValid
(
)
|
|
thread_pool_
)
return
SBOX_ERROR_UNEXPECTED_CALL
;
job_port_
.
Set
(
:
:
CreateIoCompletionPort
(
INVALID_HANDLE_VALUE
nullptr
0
0
)
)
;
if
(
!
job_port_
.
IsValid
(
)
)
return
SBOX_ERROR_CANNOT_INIT_BROKERSERVICES
;
auto
params
=
std
:
:
make_unique
<
TargetEventsThreadParams
>
(
job_port_
.
Get
(
)
std
:
:
move
(
target_tracker
)
std
:
:
make_unique
<
ThreadPool
>
(
)
)
;
thread_pool_
=
params
-
>
thread_pool
.
get
(
)
;
#
if
defined
(
ARCH_CPU_32_BITS
)
constexpr
unsigned
flags
=
STACK_SIZE_PARAM_IS_A_RESERVATION
;
constexpr
size_t
stack_size
=
128
*
1024
;
#
else
constexpr
unsigned
int
flags
=
0
;
constexpr
size_t
stack_size
=
0
;
#
endif
job_thread_
.
Set
(
:
:
CreateThread
(
nullptr
stack_size
TargetEventsThread
params
.
get
(
)
flags
nullptr
)
)
;
if
(
!
job_thread_
.
IsValid
(
)
)
{
thread_pool_
=
nullptr
;
return
SBOX_ERROR_CANNOT_INIT_BROKERSERVICES
;
}
if
(
!
SharedMemIPCServer
:
:
CreateBrokerAliveMutex
(
)
)
return
SBOX_ERROR_CANNOT_INIT_BROKERSERVICES
;
params
.
release
(
)
;
return
SBOX_ALL_OK
;
}
ResultCode
BrokerServicesBase
:
:
Init
(
)
{
return
BrokerServicesBase
:
:
Init
(
nullptr
)
;
}
ResultCode
BrokerServicesBase
:
:
InitForTesting
(
std
:
:
unique_ptr
<
BrokerServicesTargetTracker
>
target_tracker
)
{
return
BrokerServicesBase
:
:
Init
(
std
:
:
move
(
target_tracker
)
)
;
}
BrokerServicesBase
:
:
~
BrokerServicesBase
(
)
{
if
(
!
job_port_
.
IsValid
(
)
)
return
;
:
:
PostQueuedCompletionStatus
(
job_port_
.
Get
(
)
0
THREAD_CTRL_QUIT
nullptr
)
;
if
(
job_thread_
.
IsValid
(
)
&
&
WAIT_TIMEOUT
=
=
:
:
WaitForSingleObject
(
job_thread_
.
Get
(
)
5000
)
)
{
NOTREACHED
(
)
;
return
;
}
}
std
:
:
unique_ptr
<
TargetPolicy
>
BrokerServicesBase
:
:
CreatePolicy
(
)
{
return
CreatePolicy
(
"
"
)
;
}
std
:
:
unique_ptr
<
TargetPolicy
>
BrokerServicesBase
:
:
CreatePolicy
(
base
:
:
StringPiece
tag
)
{
auto
policy
=
std
:
:
make_unique
<
PolicyBase
>
(
tag
)
;
if
(
!
tag
.
empty
(
)
)
{
auto
found
=
config_cache_
.
find
(
tag
)
;
ConfigBase
*
shared_config
=
nullptr
;
if
(
found
=
=
config_cache_
.
end
(
)
)
{
auto
new_config
=
std
:
:
make_unique
<
ConfigBase
>
(
)
;
shared_config
=
new_config
.
get
(
)
;
config_cache_
[
std
:
:
string
(
tag
)
]
=
std
:
:
move
(
new_config
)
;
policy
-
>
SetConfig
(
shared_config
)
;
}
else
{
policy
-
>
SetConfig
(
found
-
>
second
.
get
(
)
)
;
}
}
return
policy
;
}
ResultCode
BrokerServicesBase
:
:
SpawnTarget
(
const
wchar_t
*
exe_path
const
wchar_t
*
command_line
base
:
:
EnvironmentMap
&
env_map
std
:
:
unique_ptr
<
TargetPolicy
>
policy
DWORD
*
last_error
PROCESS_INFORMATION
*
target_info
)
{
if
(
!
exe_path
)
return
SBOX_ERROR_BAD_PARAMS
;
HMODULE
exe_module
=
nullptr
;
CHECK
(
:
:
GetModuleHandleEx
(
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
nullptr
&
exe_module
)
)
;
if
(
CURRENT_MODULE
(
)
!
=
exe_module
)
return
SBOX_ERROR_INVALID_LINK_STATE
;
if
(
!
policy
)
return
SBOX_ERROR_BAD_PARAMS
;
std
:
:
unique_ptr
<
PolicyBase
>
policy_base
;
policy_base
.
reset
(
static_cast
<
PolicyBase
*
>
(
policy
.
release
(
)
)
)
;
ConfigBase
*
config_base
=
static_cast
<
ConfigBase
*
>
(
policy_base
-
>
GetConfig
(
)
)
;
if
(
!
config_base
-
>
IsConfigured
(
)
)
{
if
(
!
config_base
-
>
Freeze
(
)
)
return
SBOX_ERROR_FAILED_TO_FREEZE_CONFIG
;
}
static
DWORD
thread_id
=
:
:
GetCurrentThreadId
(
)
;
DCHECK
(
thread_id
=
=
:
:
GetCurrentThreadId
(
)
)
;
static
bool
launcher_thread_opted_out
=
false
;
if
(
!
launcher_thread_opted_out
)
{
sandbox
:
:
ApplyMitigationsToCurrentThread
(
sandbox
:
:
MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD
)
;
launcher_thread_opted_out
=
true
;
}
absl
:
:
optional
<
base
:
:
win
:
:
AccessToken
>
initial_token
;
absl
:
:
optional
<
base
:
:
win
:
:
AccessToken
>
lockdown_token
;
ResultCode
result
=
SBOX_ALL_OK
;
result
=
policy_base
-
>
MakeTokens
(
initial_token
lockdown_token
)
;
if
(
SBOX_ALL_OK
!
=
result
)
return
result
;
result
=
UpdateDesktopIntegrity
(
config_base
-
>
desktop
(
)
config_base
-
>
integrity_level
(
)
)
;
if
(
result
!
=
SBOX_ALL_OK
)
return
result
;
result
=
policy_base
-
>
InitJob
(
)
;
if
(
SBOX_ALL_OK
!
=
result
)
return
result
;
auto
startup_info
=
std
:
:
make_unique
<
StartupInformationHelper
>
(
)
;
startup_info
-
>
UpdateFlags
(
STARTF_FORCEOFFFEEDBACK
)
;
startup_info
-
>
SetDesktop
(
GetDesktopName
(
config_base
-
>
desktop
(
)
)
)
;
startup_info
-
>
SetMitigations
(
config_base
-
>
GetProcessMitigations
(
)
)
;
startup_info
-
>
SetFilterEnvironment
(
config_base
-
>
GetEnvironmentFiltered
(
)
)
;
if
(
base
:
:
win
:
:
GetVersion
(
)
>
=
base
:
:
win
:
:
Version
:
:
WIN10_TH2
&
&
config_base
-
>
GetJobLevel
(
)
<
=
JobLevel
:
:
kLimitedUser
)
{
startup_info
-
>
SetRestrictChildProcessCreation
(
true
)
;
}
startup_info
-
>
SetStdHandles
(
policy_base
-
>
GetStdoutHandle
(
)
policy_base
-
>
GetStderrHandle
(
)
)
;
const
auto
&
policy_handle_list
=
policy_base
-
>
GetHandlesBeingShared
(
)
;
for
(
HANDLE
handle
:
policy_handle_list
)
startup_info
-
>
AddInheritedHandle
(
handle
)
;
scoped_refptr
<
AppContainer
>
container
=
config_base
-
>
GetAppContainer
(
)
;
if
(
container
)
startup_info
-
>
SetAppContainer
(
container
)
;
startup_info
-
>
AddJobToAssociate
(
policy_base
-
>
GetJobHandle
(
)
)
;
if
(
!
startup_info
-
>
BuildStartupInformation
(
)
)
return
SBOX_ERROR_PROC_THREAD_ATTRIBUTES
;
base
:
:
win
:
:
ScopedProcessInformation
process_info
;
std
:
:
unique_ptr
<
TargetProcess
>
target
=
std
:
:
make_unique
<
TargetProcess
>
(
std
:
:
move
(
*
initial_token
)
std
:
:
move
(
*
lockdown_token
)
thread_pool_
)
;
result
=
target
-
>
Create
(
exe_path
command_line
std
:
:
move
(
startup_info
)
&
process_info
env_map
last_error
)
;
if
(
result
!
=
SBOX_ALL_OK
)
{
target
-
>
Terminate
(
)
;
return
result
;
}
if
(
config_base
-
>
GetJobLevel
(
)
<
=
JobLevel
:
:
kLimitedUser
)
{
result
=
policy_base
-
>
DropActiveProcessLimit
(
)
;
if
(
result
!
=
SBOX_ALL_OK
)
{
target
-
>
Terminate
(
)
;
return
result
;
}
}
result
=
policy_base
-
>
ApplyToTarget
(
std
:
:
move
(
target
)
)
;
if
(
result
!
=
SBOX_ALL_OK
)
{
*
last_error
=
:
:
GetLastError
(
)
;
return
result
;
}
HANDLE
job_handle
=
policy_base
-
>
GetJobHandle
(
)
;
JobTracker
*
tracker
=
new
JobTracker
(
std
:
:
move
(
policy_base
)
process_info
.
process_id
(
)
)
;
CHECK
(
:
:
PostQueuedCompletionStatus
(
job_port_
.
Get
(
)
0
THREAD_CTRL_NEW_JOB_TRACKER
reinterpret_cast
<
LPOVERLAPPED
>
(
tracker
)
)
)
;
CHECK
(
AssociateCompletionPort
(
job_handle
job_port_
.
Get
(
)
tracker
)
)
;
*
target_info
=
process_info
.
Take
(
)
;
return
result
;
}
ResultCode
BrokerServicesBase
:
:
GetPolicyDiagnostics
(
std
:
:
unique_ptr
<
PolicyDiagnosticsReceiver
>
receiver
)
{
CHECK
(
job_thread_
.
IsValid
(
)
)
;
if
(
!
:
:
PostQueuedCompletionStatus
(
job_port_
.
Get
(
)
0
THREAD_CTRL_GET_POLICY_INFO
reinterpret_cast
<
LPOVERLAPPED
>
(
receiver
.
get
(
)
)
)
)
{
receiver
-
>
OnError
(
SBOX_ERROR_GENERIC
)
;
return
SBOX_ERROR_GENERIC
;
}
receiver
.
release
(
)
;
return
SBOX_ALL_OK
;
}
void
BrokerServicesBase
:
:
SetStartingMitigations
(
sandbox
:
:
MitigationFlags
starting_mitigations
)
{
sandbox
:
:
SetStartingMitigations
(
starting_mitigations
)
;
}
bool
BrokerServicesBase
:
:
RatchetDownSecurityMitigations
(
MitigationFlags
additional_flags
)
{
return
sandbox
:
:
RatchetDownSecurityMitigations
(
additional_flags
)
;
}
std
:
:
wstring
BrokerServicesBase
:
:
GetDesktopName
(
Desktop
desktop
)
{
switch
(
desktop
)
{
case
Desktop
:
:
kDefault
:
return
std
:
:
wstring
(
)
;
case
Desktop
:
:
kAlternateWinstation
:
return
alt_winstation_
-
>
GetDesktopName
(
)
;
case
Desktop
:
:
kAlternateDesktop
:
return
alt_desktop_
-
>
GetDesktopName
(
)
;
}
}
ResultCode
BrokerServicesBase
:
:
UpdateDesktopIntegrity
(
Desktop
desktop
IntegrityLevel
integrity
)
{
if
(
integrity
=
=
INTEGRITY_LEVEL_LAST
)
return
SBOX_ALL_OK
;
switch
(
desktop
)
{
case
Desktop
:
:
kDefault
:
return
SBOX_ALL_OK
;
case
Desktop
:
:
kAlternateWinstation
:
return
alt_winstation_
-
>
UpdateDesktopIntegrity
(
integrity
)
;
case
Desktop
:
:
kAlternateDesktop
:
return
alt_desktop_
-
>
UpdateDesktopIntegrity
(
integrity
)
;
}
}
ResultCode
BrokerServicesBase
:
:
CreateAlternateDesktop
(
Desktop
desktop
)
{
switch
(
desktop
)
{
case
Desktop
:
:
kAlternateWinstation
:
{
if
(
alt_winstation_
)
return
SBOX_ALL_OK
;
alt_winstation_
=
std
:
:
make_unique
<
AlternateDesktop
>
(
)
;
ResultCode
result
=
alt_winstation_
-
>
Initialize
(
true
)
;
if
(
result
!
=
SBOX_ALL_OK
)
alt_winstation_
.
reset
(
)
;
return
result
;
}
;
case
Desktop
:
:
kAlternateDesktop
:
{
if
(
alt_desktop_
)
return
SBOX_ALL_OK
;
alt_desktop_
=
std
:
:
make_unique
<
AlternateDesktop
>
(
)
;
ResultCode
result
=
alt_desktop_
-
>
Initialize
(
false
)
;
if
(
result
!
=
SBOX_ALL_OK
)
alt_desktop_
.
reset
(
)
;
return
result
;
}
;
case
Desktop
:
:
kDefault
:
return
SBOX_ALL_OK
;
}
}
void
BrokerServicesBase
:
:
DestroyDesktops
(
)
{
alt_winstation_
.
reset
(
)
;
alt_desktop_
.
reset
(
)
;
}
void
BrokerServicesBase
:
:
FreezeTargetConfigForTesting
(
TargetConfig
*
config
)
{
CHECK
(
!
config
-
>
IsConfigured
(
)
)
;
static_cast
<
ConfigBase
*
>
(
config
)
-
>
Freeze
(
)
;
}
bool
BrokerServicesBase
:
:
DeriveCapabilitySidFromName
(
const
wchar_t
*
name
PSID
derived_sid
DWORD
sid_buffer_length
)
{
return
:
:
CopySid
(
sid_buffer_length
derived_sid
base
:
:
win
:
:
Sid
:
:
FromNamedCapability
(
name
)
.
GetPSID
(
)
)
;
}
}
