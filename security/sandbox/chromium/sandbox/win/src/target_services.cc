#
include
"
sandbox
/
win
/
src
/
target_services
.
h
"
#
include
<
new
>
#
include
<
process
.
h
>
#
include
<
stdint
.
h
>
#
include
"
base
/
win
/
windows_version
.
h
"
#
include
"
sandbox
/
win
/
src
/
crosscall_client
.
h
"
#
include
"
sandbox
/
win
/
src
/
handle_closer_agent
.
h
"
#
include
"
sandbox
/
win
/
src
/
handle_interception
.
h
"
#
include
"
sandbox
/
win
/
src
/
heap_helper
.
h
"
#
include
"
sandbox
/
win
/
src
/
ipc_tags
.
h
"
#
include
"
sandbox
/
win
/
src
/
process_mitigations
.
h
"
#
include
"
sandbox
/
win
/
src
/
restricted_token_utils
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_nt_util
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox_types
.
h
"
#
include
"
sandbox
/
win
/
src
/
sharedmem_ipc_client
.
h
"
namespace
sandbox
{
namespace
{
bool
FlushRegKey
(
HKEY
root
)
{
HKEY
key
;
if
(
ERROR_SUCCESS
=
=
:
:
RegOpenKeyExW
(
root
nullptr
0
MAXIMUM_ALLOWED
&
key
)
)
{
if
(
ERROR_SUCCESS
!
=
:
:
RegCloseKey
(
key
)
)
return
false
;
}
return
true
;
}
bool
FlushCachedRegHandles
(
)
{
return
(
FlushRegKey
(
HKEY_LOCAL_MACHINE
)
&
&
FlushRegKey
(
HKEY_CLASSES_ROOT
)
&
&
FlushRegKey
(
HKEY_USERS
)
)
;
}
bool
CsrssDisconnectCleanup
(
)
{
HANDLE
csr_port_heap
=
FindCsrPortHeap
(
)
;
if
(
!
csr_port_heap
)
{
DLOG
(
ERROR
)
<
<
"
Failed
to
find
CSR
Port
heap
handle
"
;
return
false
;
}
HeapDestroy
(
csr_port_heap
)
;
return
true
;
}
static
BOOL
CALLBACK
EnumLocalesProcEx
(
LPWSTR
lpLocaleString
DWORD
dwFlags
LPARAM
lParam
)
{
return
TRUE
;
}
bool
CsrssDisconnectWarmup
(
)
{
return
:
:
EnumSystemLocalesEx
(
EnumLocalesProcEx
LOCALE_WINDOWS
0
0
)
;
}
bool
CloseOpenHandles
(
bool
*
is_csrss_connected
)
{
if
(
HandleCloserAgent
:
:
NeedsHandlesClosed
(
)
)
{
HandleCloserAgent
handle_closer
;
handle_closer
.
InitializeHandlesToClose
(
is_csrss_connected
)
;
if
(
!
*
is_csrss_connected
)
{
if
(
!
CsrssDisconnectWarmup
(
)
|
|
!
CsrssDisconnectCleanup
(
)
)
{
return
false
;
}
}
if
(
!
handle_closer
.
CloseHandles
(
)
)
return
false
;
}
return
true
;
}
bool
WarmupWindowsLocales
(
)
{
:
:
GetUserDefaultLangID
(
)
;
:
:
GetUserDefaultLCID
(
)
;
wchar_t
localeName
[
LOCALE_NAME_MAX_LENGTH
]
=
{
0
}
;
return
(
0
!
=
:
:
GetUserDefaultLocaleName
(
localeName
LOCALE_NAME_MAX_LENGTH
)
)
;
}
char
g_target_services_memory
[
sizeof
(
TargetServicesBase
)
]
;
TargetServicesBase
*
g_target_services
=
nullptr
;
}
SANDBOX_INTERCEPT
IntegrityLevel
g_shared_delayed_integrity_level
=
INTEGRITY_LEVEL_LAST
;
SANDBOX_INTERCEPT
MitigationFlags
g_shared_delayed_mitigations
=
0
;
TargetServicesBase
:
:
TargetServicesBase
(
)
{
}
ResultCode
TargetServicesBase
:
:
Init
(
)
{
process_state_
.
SetInitCalled
(
)
;
return
SBOX_ALL_OK
;
}
void
TargetServicesBase
:
:
LowerToken
(
)
{
if
(
ERROR_SUCCESS
!
=
SetProcessIntegrityLevel
(
g_shared_delayed_integrity_level
)
)
:
:
TerminateProcess
(
:
:
GetCurrentProcess
(
)
SBOX_FATAL_INTEGRITY
)
;
process_state_
.
SetRevertedToSelf
(
)
;
if
(
!
:
:
RevertToSelf
(
)
)
:
:
TerminateProcess
(
:
:
GetCurrentProcess
(
)
SBOX_FATAL_DROPTOKEN
)
;
if
(
!
FlushCachedRegHandles
(
)
)
:
:
TerminateProcess
(
:
:
GetCurrentProcess
(
)
SBOX_FATAL_FLUSHANDLES
)
;
if
(
ERROR_SUCCESS
!
=
:
:
RegDisablePredefinedCache
(
)
)
:
:
TerminateProcess
(
:
:
GetCurrentProcess
(
)
SBOX_FATAL_CACHEDISABLE
)
;
if
(
!
WarmupWindowsLocales
(
)
)
:
:
TerminateProcess
(
:
:
GetCurrentProcess
(
)
SBOX_FATAL_WARMUP
)
;
bool
is_csrss_connected
=
true
;
if
(
!
CloseOpenHandles
(
&
is_csrss_connected
)
)
:
:
TerminateProcess
(
:
:
GetCurrentProcess
(
)
SBOX_FATAL_CLOSEHANDLES
)
;
process_state_
.
SetCsrssConnected
(
is_csrss_connected
)
;
if
(
g_shared_delayed_mitigations
&
&
!
ApplyProcessMitigationsToCurrentProcess
(
g_shared_delayed_mitigations
)
)
:
:
TerminateProcess
(
:
:
GetCurrentProcess
(
)
SBOX_FATAL_MITIGATION
)
;
}
ProcessState
*
TargetServicesBase
:
:
GetState
(
)
{
return
&
process_state_
;
}
TargetServicesBase
*
TargetServicesBase
:
:
GetInstance
(
)
{
if
(
!
g_target_services
)
g_target_services
=
new
(
g_target_services_memory
)
TargetServicesBase
;
return
g_target_services
;
}
bool
TargetServicesBase
:
:
TestIPCPing
(
int
version
)
{
void
*
memory
=
GetGlobalIPCMemory
(
)
;
if
(
!
memory
)
return
false
;
SharedMemIPCClient
ipc
(
memory
)
;
CrossCallReturn
answer
=
{
0
}
;
if
(
1
=
=
version
)
{
uint32_t
tick1
=
:
:
GetTickCount
(
)
;
uint32_t
cookie
=
717115
;
ResultCode
code
=
CrossCall
(
ipc
IpcTag
:
:
PING1
cookie
&
answer
)
;
if
(
SBOX_ALL_OK
!
=
code
)
{
return
false
;
}
if
(
(
answer
.
extended_count
!
=
2
)
)
{
return
false
;
}
uint32_t
tick2
=
:
:
GetTickCount
(
)
;
if
(
tick2
>
=
tick1
)
{
if
(
(
answer
.
extended
[
0
]
.
unsigned_int
<
tick1
)
|
|
(
answer
.
extended
[
0
]
.
unsigned_int
>
tick2
)
)
{
return
false
;
}
}
if
(
answer
.
extended
[
1
]
.
unsigned_int
!
=
cookie
*
2
)
{
return
false
;
}
}
else
if
(
2
=
=
version
)
{
uint32_t
cookie
=
717111
;
InOutCountedBuffer
counted_buffer
(
&
cookie
sizeof
(
cookie
)
)
;
ResultCode
code
=
CrossCall
(
ipc
IpcTag
:
:
PING2
counted_buffer
&
answer
)
;
if
(
SBOX_ALL_OK
!
=
code
)
{
return
false
;
}
if
(
cookie
!
=
717111
*
3
)
{
return
false
;
}
}
else
{
return
false
;
}
return
true
;
}
ProcessState
:
:
ProcessState
(
)
:
process_state_
(
ProcessStateInternal
:
:
NONE
)
csrss_connected_
(
true
)
{
}
bool
ProcessState
:
:
InitCalled
(
)
const
{
return
process_state_
>
=
ProcessStateInternal
:
:
INIT_CALLED
;
}
bool
ProcessState
:
:
RevertedToSelf
(
)
const
{
return
process_state_
>
=
ProcessStateInternal
:
:
REVERTED_TO_SELF
;
}
bool
ProcessState
:
:
IsCsrssConnected
(
)
const
{
return
csrss_connected_
;
}
void
ProcessState
:
:
SetInitCalled
(
)
{
if
(
process_state_
<
ProcessStateInternal
:
:
INIT_CALLED
)
process_state_
=
ProcessStateInternal
:
:
INIT_CALLED
;
}
void
ProcessState
:
:
SetRevertedToSelf
(
)
{
if
(
process_state_
<
ProcessStateInternal
:
:
REVERTED_TO_SELF
)
process_state_
=
ProcessStateInternal
:
:
REVERTED_TO_SELF
;
}
void
ProcessState
:
:
SetCsrssConnected
(
bool
csrss_connected
)
{
csrss_connected_
=
csrss_connected
;
}
ResultCode
TargetServicesBase
:
:
DuplicateHandle
(
HANDLE
source_handle
DWORD
target_process_id
HANDLE
*
target_handle
DWORD
desired_access
DWORD
options
)
{
return
sandbox
:
:
DuplicateHandleProxy
(
source_handle
target_process_id
target_handle
desired_access
options
)
;
}
}
