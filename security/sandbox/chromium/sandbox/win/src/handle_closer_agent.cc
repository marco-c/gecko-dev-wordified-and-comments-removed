#
include
"
sandbox
/
win
/
src
/
handle_closer_agent
.
h
"
#
include
<
stddef
.
h
>
#
include
"
base
/
check
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
win
/
static_constants
.
h
"
#
include
"
base
/
win
/
win_util
.
h
"
#
include
"
sandbox
/
win
/
src
/
win_utils
.
h
"
#
include
"
third_party
/
abseil
-
cpp
/
absl
/
types
/
optional
.
h
"
namespace
sandbox
{
SANDBOX_INTERCEPT
HandleCloserInfo
*
g_handles_to_close
=
nullptr
;
bool
HandleCloserAgent
:
:
NeedsHandlesClosed
(
)
{
return
!
!
g_handles_to_close
;
}
HandleCloserAgent
:
:
HandleCloserAgent
(
)
:
dummy_handle_
(
:
:
CreateEvent
(
nullptr
false
false
nullptr
)
)
{
}
HandleCloserAgent
:
:
~
HandleCloserAgent
(
)
{
}
bool
HandleCloserAgent
:
:
AttemptToStuffHandleSlot
(
HANDLE
closed_handle
const
std
:
:
wstring
&
type
)
{
if
(
type
!
=
L
"
Event
"
&
&
type
!
=
L
"
File
"
)
{
return
true
;
}
if
(
!
dummy_handle_
.
IsValid
(
)
)
return
false
;
DCHECK
(
dummy_handle_
.
Get
(
)
!
=
closed_handle
)
;
std
:
:
vector
<
HANDLE
>
to_close
;
const
DWORD
original_proc_num
=
GetCurrentProcessorNumber
(
)
;
DWORD
proc_num
=
original_proc_num
;
DWORD_PTR
original_affinity_mask
=
SetThreadAffinityMask
(
GetCurrentThread
(
)
DWORD_PTR
{
1
}
<
<
proc_num
)
;
bool
found_handle
=
false
;
BOOL
result
=
FALSE
;
do
{
DWORD_PTR
current_mask
=
DWORD_PTR
{
1
}
<
<
proc_num
;
if
(
original_affinity_mask
&
current_mask
)
{
if
(
proc_num
!
=
original_proc_num
)
{
SetThreadAffinityMask
(
GetCurrentThread
(
)
current_mask
)
;
}
HANDLE
dup_dummy
=
nullptr
;
size_t
count
=
16
;
do
{
result
=
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
dummy_handle_
.
Get
(
)
:
:
GetCurrentProcess
(
)
&
dup_dummy
0
false
0
)
;
if
(
!
result
)
{
break
;
}
if
(
dup_dummy
!
=
closed_handle
)
{
to_close
.
push_back
(
dup_dummy
)
;
}
else
{
found_handle
=
true
;
}
}
while
(
count
-
-
&
&
reinterpret_cast
<
uintptr_t
>
(
dup_dummy
)
<
reinterpret_cast
<
uintptr_t
>
(
closed_handle
)
)
;
}
proc_num
+
+
;
if
(
proc_num
=
=
sizeof
(
DWORD_PTR
)
*
8
)
{
proc_num
=
0
;
}
if
(
proc_num
=
=
original_proc_num
)
{
break
;
}
}
while
(
result
&
&
!
found_handle
)
;
SetThreadAffinityMask
(
GetCurrentThread
(
)
original_affinity_mask
)
;
for
(
HANDLE
h
:
to_close
)
:
:
CloseHandle
(
h
)
;
return
found_handle
;
}
void
HandleCloserAgent
:
:
InitializeHandlesToClose
(
bool
*
is_csrss_connected
)
{
CHECK
(
g_handles_to_close
)
;
*
is_csrss_connected
=
true
;
HandleListEntry
*
entry
=
g_handles_to_close
-
>
handle_entries
;
for
(
size_t
i
=
0
;
i
<
g_handles_to_close
-
>
num_handle_types
;
+
+
i
)
{
wchar_t
*
input
=
entry
-
>
handle_type
;
if
(
!
wcscmp
(
input
L
"
ALPC
Port
"
)
)
{
*
is_csrss_connected
=
false
;
}
HandleMap
:
:
mapped_type
&
handle_names
=
handles_to_close_
[
input
]
;
input
=
reinterpret_cast
<
wchar_t
*
>
(
reinterpret_cast
<
char
*
>
(
entry
)
+
entry
-
>
offset_to_names
)
;
for
(
size_t
j
=
0
;
j
<
entry
-
>
name_count
;
+
+
j
)
{
std
:
:
pair
<
HandleMap
:
:
mapped_type
:
:
iterator
bool
>
name
=
handle_names
.
insert
(
input
)
;
CHECK
(
name
.
second
)
;
input
+
=
name
.
first
-
>
size
(
)
+
1
;
}
entry
=
reinterpret_cast
<
HandleListEntry
*
>
(
reinterpret_cast
<
char
*
>
(
entry
)
+
entry
-
>
record_bytes
)
;
DCHECK
(
reinterpret_cast
<
wchar_t
*
>
(
entry
)
>
=
input
)
;
DCHECK
(
reinterpret_cast
<
wchar_t
*
>
(
entry
)
-
input
<
static_cast
<
ptrdiff_t
>
(
sizeof
(
size_t
)
/
sizeof
(
wchar_t
)
)
)
;
}
:
:
VirtualFree
(
g_handles_to_close
0
MEM_RELEASE
)
;
g_handles_to_close
=
nullptr
;
}
bool
HandleCloserAgent
:
:
CloseHandles
(
)
{
if
(
base
:
:
win
:
:
IsAppVerifierLoaded
(
)
)
return
true
;
absl
:
:
optional
<
ProcessHandleMap
>
handle_map
=
GetCurrentProcessHandles
(
)
;
if
(
!
handle_map
)
return
false
;
for
(
const
HandleMap
:
:
value_type
&
handle_to_close
:
handles_to_close_
)
{
ProcessHandleMap
:
:
iterator
result
=
handle_map
-
>
find
(
handle_to_close
.
first
)
;
if
(
result
=
=
handle_map
-
>
end
(
)
)
continue
;
const
HandleMap
:
:
mapped_type
&
names
=
handle_to_close
.
second
;
for
(
HANDLE
handle
:
result
-
>
second
)
{
if
(
!
names
.
empty
(
)
)
{
auto
handle_name
=
GetPathFromHandle
(
handle
)
;
if
(
!
handle_name
|
|
!
names
.
count
(
handle_name
.
value
(
)
)
)
{
continue
;
}
}
if
(
!
:
:
SetHandleInformation
(
handle
HANDLE_FLAG_PROTECT_FROM_CLOSE
0
)
)
continue
;
if
(
!
:
:
CloseHandle
(
handle
)
)
continue
;
AttemptToStuffHandleSlot
(
handle
result
-
>
first
)
;
}
}
return
true
;
}
}
