#
include
"
remoteSandboxBroker
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
nsIThread
.
h
"
namespace
mozilla
{
RemoteSandboxBroker
:
:
RemoteSandboxBroker
(
)
{
}
RemoteSandboxBroker
:
:
~
RemoteSandboxBroker
(
)
{
MOZ_ASSERT
(
mShutdown
"
Shutdown
must
be
called
on
RemoteSandboxBroker
before
destruction
!
"
)
;
}
void
RemoteSandboxBroker
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
!
mShutdown
"
Don
'
t
call
Shutdown
(
)
twice
!
"
)
;
mShutdown
=
true
;
if
(
!
mIPCLaunchThread
)
{
return
;
}
RefPtr
<
RemoteSandboxBroker
>
self
=
this
;
mIPCLaunchThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
Remote
Sandbox
Launch
"
[
self
this
]
(
)
{
mParent
.
Shutdown
(
)
;
mIPCLaunchThread
=
nullptr
;
}
)
)
;
}
bool
RemoteSandboxBroker
:
:
LaunchApp
(
const
wchar_t
*
aPath
const
wchar_t
*
aArguments
base
:
:
EnvironmentMap
&
aEnvironment
GeckoProcessType
aProcessType
const
bool
aEnableLogging
const
IMAGE_THUNK_DATA
*
void
*
*
aProcessHandle
)
{
mIPCLaunchThread
=
GetCurrentSerialEventTarget
(
)
;
mParameters
.
path
(
)
=
nsDependentString
(
aPath
)
;
mParameters
.
args
(
)
=
nsDependentString
(
aArguments
)
;
auto
toNsString
=
[
]
(
const
std
:
:
wstring
&
s
)
{
return
nsDependentString
(
s
.
c_str
(
)
)
;
}
;
for
(
auto
itr
:
aEnvironment
)
{
mParameters
.
env
(
)
.
AppendElement
(
EnvVar
(
toNsString
(
itr
.
first
)
toNsString
(
itr
.
second
)
)
)
;
}
mParameters
.
processType
(
)
=
uint32_t
(
aProcessType
)
;
mParameters
.
enableLogging
(
)
=
aEnableLogging
;
enum
Result
{
Pending
Succeeded
Failed
}
;
Result
res
=
Pending
;
auto
resolve
=
[
&
]
(
bool
ok
)
{
res
=
Succeeded
;
return
GenericPromise
:
:
CreateAndResolve
(
ok
__func__
)
;
}
;
auto
reject
=
[
&
]
(
nsresult
)
{
res
=
Failed
;
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
;
nsCOMPtr
<
nsISerialEventTarget
>
target
=
NS_GetCurrentThread
(
)
;
mParent
.
Launch
(
mParameters
.
shareHandles
(
)
target
)
-
>
Then
(
target
__func__
std
:
:
move
(
resolve
)
std
:
:
move
(
reject
)
)
;
SpinEventLoopUntil
(
"
RemoteSandboxBroker
:
:
LaunchApp
"
_ns
[
&
]
(
)
{
return
res
!
=
Pending
;
}
)
;
if
(
res
=
=
Failed
)
{
return
false
;
}
uint64_t
handle
=
0
;
bool
ok
=
false
;
bool
rv
=
mParent
.
CallLaunchApp
(
std
:
:
move
(
mParameters
)
&
ok
&
handle
)
&
&
ok
;
mParameters
.
shareHandles
(
)
.
Clear
(
)
;
if
(
!
rv
)
{
return
false
;
}
HANDLE
ourChildHandle
=
0
;
bool
dh
=
mParent
.
DuplicateFromLauncher
(
(
HANDLE
)
handle
&
ourChildHandle
)
;
if
(
!
dh
)
{
return
false
;
}
*
aProcessHandle
=
(
void
*
*
)
(
ourChildHandle
)
;
base
:
:
ProcessHandle
process
=
*
aProcessHandle
;
SandboxBroker
:
:
AddTargetPeer
(
process
)
;
return
true
;
}
bool
RemoteSandboxBroker
:
:
SetSecurityLevelForGMPlugin
(
SandboxLevel
aLevel
bool
aIsRemoteLaunch
)
{
mParameters
.
sandboxLevel
(
)
=
uint32_t
(
aLevel
)
;
return
true
;
}
bool
RemoteSandboxBroker
:
:
AllowReadFile
(
wchar_t
const
*
aFile
)
{
mParameters
.
allowedReadFiles
(
)
.
AppendElement
(
nsDependentString
(
aFile
)
)
;
return
true
;
}
void
RemoteSandboxBroker
:
:
AddHandleToShare
(
HANDLE
aHandle
)
{
mParameters
.
shareHandles
(
)
.
AppendElement
(
uint64_t
(
aHandle
)
)
;
}
void
RemoteSandboxBroker
:
:
SetSecurityLevelForContentProcess
(
int32_t
aSandboxLevel
bool
aIsFileProcess
)
{
MOZ_CRASH
(
"
RemoteSandboxBroker
:
:
SetSecurityLevelForContentProcess
not
Implemented
"
)
;
}
void
RemoteSandboxBroker
:
:
SetSecurityLevelForGPUProcess
(
int32_t
aSandboxLevel
const
nsCOMPtr
<
nsIFile
>
&
aProfileDir
)
{
MOZ_CRASH
(
"
RemoteSandboxBroker
:
:
SetSecurityLevelForGPUProcess
not
Implemented
"
)
;
}
bool
RemoteSandboxBroker
:
:
SetSecurityLevelForRDDProcess
(
)
{
MOZ_CRASH
(
"
RemoteSandboxBroker
:
:
SetSecurityLevelForRDDProcess
not
Implemented
"
)
;
}
bool
RemoteSandboxBroker
:
:
SetSecurityLevelForSocketProcess
(
)
{
MOZ_CRASH
(
"
RemoteSandboxBroker
:
:
SetSecurityLevelForSocketProcess
not
Implemented
"
)
;
}
AbstractSandboxBroker
*
CreateRemoteSandboxBroker
(
)
{
return
new
RemoteSandboxBroker
(
)
;
}
}
