#
include
"
sandboxBroker
.
h
"
#
include
<
string
>
#
include
"
base
/
win
/
windows_version
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ImportDir
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
NSPRLogModulesParser
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox
.
h
"
#
include
"
sandbox
/
win
/
src
/
security_level
.
h
"
#
include
"
WinUtils
.
h
"
namespace
mozilla
{
sandbox
:
:
BrokerServices
*
SandboxBroker
:
:
sBrokerService
=
nullptr
;
bool
SandboxBroker
:
:
sRunningFromNetworkDrive
=
false
;
static
UniquePtr
<
nsString
>
sBinDir
;
static
UniquePtr
<
nsString
>
sProfileDir
;
static
UniquePtr
<
nsString
>
sContentTempDir
;
static
UniquePtr
<
nsString
>
sPluginTempDir
;
static
UniquePtr
<
nsString
>
sRoamingAppDataDir
;
static
UniquePtr
<
nsString
>
sLocalAppDataDir
;
static
UniquePtr
<
nsString
>
sUserExtensionsDevDir
;
#
ifdef
ENABLE_SYSTEM_EXTENSION_DIRS
static
UniquePtr
<
nsString
>
sUserExtensionsDir
;
#
endif
static
bool
sRddWin32kDisable
=
false
;
static
bool
sGmpWin32kDisable
=
false
;
static
LazyLogModule
sSandboxBrokerLog
(
"
SandboxBroker
"
)
;
#
define
LOG_E
(
.
.
.
)
MOZ_LOG
(
sSandboxBrokerLog
LogLevel
:
:
Error
(
__VA_ARGS__
)
)
#
define
LOG_W
(
.
.
.
)
MOZ_LOG
(
sSandboxBrokerLog
LogLevel
:
:
Warning
(
__VA_ARGS__
)
)
static
UniquePtr
<
nsTHashtable
<
nsCStringHashKey
>
>
sLaunchErrors
;
void
SandboxBroker
:
:
Initialize
(
sandbox
:
:
BrokerServices
*
aBrokerServices
)
{
sBrokerService
=
aBrokerServices
;
sRunningFromNetworkDrive
=
widget
:
:
WinUtils
:
:
RunningFromANetworkDrive
(
)
;
}
static
void
CacheDirAndAutoClear
(
nsIProperties
*
aDirSvc
const
char
*
aDirKey
UniquePtr
<
nsString
>
*
cacheVar
)
{
nsCOMPtr
<
nsIFile
>
dirToCache
;
nsresult
rv
=
aDirSvc
-
>
Get
(
aDirKey
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
dirToCache
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
directory
to
cache
.
"
)
;
LOG_E
(
"
Failed
to
get
directory
to
cache
key
:
%
s
.
"
aDirKey
)
;
return
;
}
*
cacheVar
=
MakeUnique
<
nsString
>
(
)
;
ClearOnShutdown
(
cacheVar
)
;
MOZ_ALWAYS_SUCCEEDS
(
dirToCache
-
>
GetPath
(
*
*
cacheVar
)
)
;
if
(
Substring
(
*
*
cacheVar
0
2
)
.
Equals
(
NS_LITERAL_STRING
(
"
\
\
\
\
"
)
)
)
{
(
*
cacheVar
)
-
>
InsertLiteral
(
u
"
?
?
\
\
UNC
"
1
)
;
}
}
void
SandboxBroker
:
:
GeckoDependentInitialize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
haveXPCOM
=
XRE_GetProcessType
(
)
!
=
GeckoProcessType_RemoteSandboxBroker
;
if
(
haveXPCOM
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
dirSvc
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
get
directory
service
cannot
cache
directories
"
"
for
rules
.
"
)
;
LOG_E
(
"
Failed
to
get
directory
service
cannot
cache
directories
for
"
"
rules
.
"
)
;
return
;
}
CacheDirAndAutoClear
(
dirSvc
NS_GRE_DIR
&
sBinDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_APP_USER_PROFILE_50_DIR
&
sProfileDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_APP_CONTENT_PROCESS_TEMP_DIR
&
sContentTempDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_APP_PLUGIN_PROCESS_TEMP_DIR
&
sPluginTempDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_WIN_APPDATA_DIR
&
sRoamingAppDataDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_WIN_LOCAL_APPDATA_DIR
&
sLocalAppDataDir
)
;
CacheDirAndAutoClear
(
dirSvc
XRE_USER_SYS_EXTENSION_DEV_DIR
&
sUserExtensionsDevDir
)
;
#
ifdef
ENABLE_SYSTEM_EXTENSION_DIRS
CacheDirAndAutoClear
(
dirSvc
XRE_USER_SYS_EXTENSION_DIR
&
sUserExtensionsDir
)
;
#
endif
}
sLaunchErrors
=
MakeUnique
<
nsTHashtable
<
nsCStringHashKey
>
>
(
)
;
ClearOnShutdown
(
&
sLaunchErrors
)
;
if
(
haveXPCOM
)
{
Preferences
:
:
AddBoolVarCache
(
&
sRddWin32kDisable
"
security
.
sandbox
.
rdd
.
win32k
-
disable
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sGmpWin32kDisable
"
security
.
sandbox
.
gmp
.
win32k
-
disable
"
)
;
}
else
{
sRddWin32kDisable
=
false
;
sGmpWin32kDisable
=
false
;
}
}
SandboxBroker
:
:
SandboxBroker
(
)
{
if
(
sBrokerService
)
{
scoped_refptr
<
sandbox
:
:
TargetPolicy
>
policy
=
sBrokerService
-
>
CreatePolicy
(
)
;
mPolicy
=
policy
.
get
(
)
;
mPolicy
-
>
AddRef
(
)
;
if
(
sRunningFromNetworkDrive
)
{
mPolicy
-
>
SetDoNotUseRestrictingSIDs
(
)
;
}
}
else
{
mPolicy
=
nullptr
;
}
}
bool
SandboxBroker
:
:
LaunchApp
(
const
wchar_t
*
aPath
const
wchar_t
*
aArguments
base
:
:
EnvironmentMap
&
aEnvironment
GeckoProcessType
aProcessType
const
bool
aEnableLogging
void
*
*
aProcessHandle
)
{
if
(
!
sBrokerService
|
|
!
mPolicy
)
{
return
false
;
}
mPolicy
-
>
SetStdoutHandle
(
:
:
GetStdHandle
(
STD_OUTPUT_HANDLE
)
)
;
mPolicy
-
>
SetStderrHandle
(
:
:
GetStdHandle
(
STD_ERROR_HANDLE
)
)
;
if
(
aEnableLogging
)
{
ApplyLoggingPolicy
(
)
;
}
#
if
defined
(
DEBUG
)
wchar_t
tempPath
[
MAX_PATH
+
2
]
;
uint32_t
pathLen
=
:
:
GetTempPathW
(
MAX_PATH
+
1
tempPath
)
;
if
(
pathLen
>
0
)
{
tempPath
[
pathLen
]
=
L
'
*
'
;
tempPath
[
pathLen
+
1
]
=
L
'
\
0
'
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
tempPath
)
;
}
#
endif
wchar_t
const
*
logFileName
=
nullptr
;
auto
it
=
aEnvironment
.
find
(
ENVIRONMENT_LITERAL
(
"
MOZ_LOG_FILE
"
)
)
;
if
(
it
!
=
aEnvironment
.
end
(
)
)
{
logFileName
=
(
it
-
>
second
)
.
c_str
(
)
;
}
char
const
*
logFileModules
=
getenv
(
"
MOZ_LOG
"
)
;
if
(
logFileName
&
&
logFileModules
)
{
bool
rotate
=
false
;
NSPRLogModulesParser
(
logFileModules
[
&
rotate
]
(
const
char
*
aName
LogLevel
aLevel
int32_t
aValue
)
mutable
{
if
(
strcmp
(
aName
"
rotate
"
)
=
=
0
)
{
rotate
=
aValue
>
0
;
}
}
)
;
if
(
rotate
)
{
wchar_t
logFileNameWild
[
MAX_PATH
+
2
]
;
_snwprintf
(
logFileNameWild
sizeof
(
logFileNameWild
)
L
"
%
s
.
?
"
logFileName
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
logFileNameWild
)
;
}
else
{
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
logFileName
)
;
}
}
logFileName
=
nullptr
;
it
=
aEnvironment
.
find
(
ENVIRONMENT_LITERAL
(
"
NSPR_LOG_FILE
"
)
)
;
if
(
it
!
=
aEnvironment
.
end
(
)
)
{
logFileName
=
(
it
-
>
second
)
.
c_str
(
)
;
}
if
(
logFileName
)
{
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
logFileName
)
;
}
PROCESS_INFORMATION
targetInfo
=
{
0
}
;
sandbox
:
:
ResultCode
result
;
sandbox
:
:
ResultCode
last_warning
=
sandbox
:
:
SBOX_ALL_OK
;
DWORD
last_error
=
ERROR_SUCCESS
;
result
=
sBrokerService
-
>
SpawnTarget
(
aPath
aArguments
aEnvironment
mPolicy
&
last_warning
&
last_error
&
targetInfo
)
;
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
{
nsAutoCString
key
;
key
.
AppendASCII
(
XRE_ChildProcessTypeToString
(
aProcessType
)
)
;
key
.
AppendLiteral
(
"
/
0x
"
)
;
key
.
AppendInt
(
static_cast
<
uint32_t
>
(
last_error
)
16
)
;
if
(
sLaunchErrors
)
{
if
(
!
sLaunchErrors
-
>
Contains
(
key
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SANDBOX_FAILED_LAUNCH_KEYED
key
result
)
;
sLaunchErrors
-
>
PutEntry
(
key
)
;
}
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SANDBOX_FAILED_LAUNCH_KEYED
key
result
)
;
}
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
SpawnTarget
with
last_error
=
%
d
"
"
last_warning
=
%
d
"
result
last_error
last_warning
)
;
return
false
;
}
else
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
last_warning
)
{
LOG_W
(
"
Warning
on
SpawnTarget
with
last_error
=
%
d
last_warning
=
%
d
"
last_error
last_warning
)
;
}
nsModuleHandle
moduleHandle
;
HMODULE
realBase
=
nullptr
;
if
(
XRE_GetChildProcBinPathType
(
aProcessType
)
=
=
BinPathType
:
:
Self
)
{
HMODULE
ourExe
;
if
(
:
:
GetModuleHandleExW
(
0
nullptr
&
ourExe
)
)
{
moduleHandle
.
own
(
ourExe
)
;
realBase
=
ourExe
;
}
}
else
{
moduleHandle
.
own
(
:
:
LoadLibraryExW
(
aPath
nullptr
LOAD_LIBRARY_AS_DATAFILE
)
)
;
LauncherResult
<
HMODULE
>
procExeModule
=
nt
:
:
GetProcessExeModule
(
targetInfo
.
hProcess
)
;
if
(
procExeModule
.
isOk
(
)
)
{
realBase
=
procExeModule
.
unwrap
(
)
;
}
else
{
LOG_E
(
"
nt
:
:
GetProcessExeModule
failed
with
HRESULT
0x
%
08lX
"
procExeModule
.
unwrapErr
(
)
.
AsHResult
(
)
)
;
}
}
if
(
moduleHandle
&
&
realBase
)
{
nt
:
:
PEHeaders
exeImage
(
moduleHandle
.
get
(
)
)
;
if
(
!
!
exeImage
)
{
LauncherVoidResult
importsRestored
=
RestoreImportDirectory
(
aPath
exeImage
targetInfo
.
hProcess
realBase
)
;
if
(
importsRestored
.
isErr
(
)
)
{
LOG_E
(
"
Failed
to
restore
import
directory
with
HRESULT
0x
%
08lX
"
importsRestored
.
unwrapErr
(
)
.
AsHResult
(
)
)
;
TerminateProcess
(
targetInfo
.
hProcess
1
)
;
CloseHandle
(
targetInfo
.
hThread
)
;
CloseHandle
(
targetInfo
.
hProcess
)
;
return
false
;
}
}
}
ResumeThread
(
targetInfo
.
hThread
)
;
CloseHandle
(
targetInfo
.
hThread
)
;
*
aProcessHandle
=
targetInfo
.
hProcess
;
return
true
;
}
static
void
AddCachedDirRule
(
sandbox
:
:
TargetPolicy
*
aPolicy
sandbox
:
:
TargetPolicy
:
:
Semantics
aAccess
const
UniquePtr
<
nsString
>
&
aBaseDir
const
nsLiteralString
&
aRelativePath
)
{
if
(
!
aBaseDir
)
{
NS_WARNING
(
"
Tried
to
add
rule
with
null
base
dir
.
"
)
;
LOG_E
(
"
Tried
to
add
rule
with
null
base
dir
.
Relative
path
:
%
S
Access
:
%
d
"
aRelativePath
.
get
(
)
aAccess
)
;
return
;
}
nsAutoString
rulePath
(
*
aBaseDir
)
;
rulePath
.
Append
(
aRelativePath
)
;
sandbox
:
:
ResultCode
result
=
aPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
aAccess
rulePath
.
get
(
)
)
;
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
{
NS_ERROR
(
"
Failed
to
add
file
policy
rule
.
"
)
;
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
%
d
access
to
:
%
S
"
result
aAccess
rulePath
.
get
(
)
)
;
}
}
static
bool
CanUseJob
(
)
{
if
(
IsWin8OrLater
(
)
)
{
return
true
;
}
BOOL
inJob
=
true
;
if
(
!
:
:
IsProcessInJob
(
:
:
GetCurrentProcess
(
)
nullptr
&
inJob
)
)
{
return
true
;
}
if
(
!
inJob
)
{
return
true
;
}
JOBOBJECT_EXTENDED_LIMIT_INFORMATION
job_info
=
{
}
;
if
(
!
:
:
QueryInformationJobObject
(
nullptr
JobObjectExtendedLimitInformation
&
job_info
sizeof
(
job_info
)
nullptr
)
)
{
return
true
;
}
if
(
job_info
.
BasicLimitInformation
.
LimitFlags
&
JOB_OBJECT_LIMIT_BREAKAWAY_OK
)
{
return
true
;
}
nsAutoString
localRemote
(
:
:
GetSystemMetrics
(
SM_REMOTESESSION
)
?
u
"
remote
"
:
u
"
local
"
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
SANDBOX_NO_JOB
localRemote
true
)
;
return
false
;
}
static
sandbox
:
:
ResultCode
SetJobLevel
(
sandbox
:
:
TargetPolicy
*
aPolicy
sandbox
:
:
JobLevel
aJobLevel
uint32_t
aUiExceptions
)
{
static
bool
sCanUseJob
=
CanUseJob
(
)
;
if
(
sCanUseJob
)
{
return
aPolicy
-
>
SetJobLevel
(
aJobLevel
aUiExceptions
)
;
}
return
aPolicy
-
>
SetJobLevel
(
sandbox
:
:
JOB_NONE
0
)
;
}
void
SandboxBroker
:
:
SetSecurityLevelForContentProcess
(
int32_t
aSandboxLevel
bool
aIsFileProcess
)
{
MOZ_RELEASE_ASSERT
(
mPolicy
"
mPolicy
must
be
set
before
this
call
.
"
)
;
sandbox
:
:
JobLevel
jobLevel
;
sandbox
:
:
TokenLevel
accessTokenLevel
;
sandbox
:
:
IntegrityLevel
initialIntegrityLevel
;
sandbox
:
:
IntegrityLevel
delayedIntegrityLevel
;
MOZ_RELEASE_ASSERT
(
aSandboxLevel
>
=
1
"
Should
not
be
called
with
aSandboxLevel
<
1
"
)
;
if
(
aSandboxLevel
>
=
20
)
{
jobLevel
=
sandbox
:
:
JOB_LOCKDOWN
;
accessTokenLevel
=
sandbox
:
:
USER_LOCKDOWN
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_UNTRUSTED
;
}
else
if
(
aSandboxLevel
>
=
4
)
{
jobLevel
=
sandbox
:
:
JOB_LOCKDOWN
;
accessTokenLevel
=
sandbox
:
:
USER_LIMITED
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
if
(
aSandboxLevel
>
=
3
)
{
jobLevel
=
sandbox
:
:
JOB_RESTRICTED
;
accessTokenLevel
=
sandbox
:
:
USER_LIMITED
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
if
(
aSandboxLevel
=
=
2
)
{
jobLevel
=
sandbox
:
:
JOB_INTERACTIVE
;
accessTokenLevel
=
sandbox
:
:
USER_INTERACTIVE
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
{
MOZ_ASSERT
(
aSandboxLevel
=
=
1
)
;
jobLevel
=
sandbox
:
:
JOB_NONE
;
accessTokenLevel
=
sandbox
:
:
USER_NON_ADMIN
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
if
(
aIsFileProcess
)
{
if
(
accessTokenLevel
<
sandbox
:
:
USER_NON_ADMIN
)
{
accessTokenLevel
=
sandbox
:
:
USER_NON_ADMIN
;
}
if
(
delayedIntegrityLevel
>
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
{
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
}
#
if
defined
(
DEBUG
)
DWORD
uiExceptions
=
JOB_OBJECT_UILIMIT_HANDLES
;
#
else
DWORD
uiExceptions
=
0
;
#
endif
sandbox
:
:
ResultCode
result
=
SetJobLevel
(
mPolicy
jobLevel
uiExceptions
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Setting
job
level
failed
have
you
set
memory
limit
when
"
"
jobLevel
=
=
JOB_NONE
?
"
)
;
sandbox
:
:
TokenLevel
initialAccessTokenLevel
=
(
accessTokenLevel
=
=
sandbox
:
:
USER_UNPROTECTED
|
|
accessTokenLevel
=
=
sandbox
:
:
USER_NON_ADMIN
)
?
sandbox
:
:
USER_UNPROTECTED
:
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
;
result
=
mPolicy
-
>
SetTokenLevel
(
initialAccessTokenLevel
accessTokenLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Lockdown
level
cannot
be
USER_UNPROTECTED
or
USER_LAST
"
"
if
initial
level
was
USER_RESTRICTED_SAME_ACCESS
"
)
;
result
=
mPolicy
-
>
SetIntegrityLevel
(
initialIntegrityLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetIntegrityLevel
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
delayedIntegrityLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetDelayedIntegrityLevel
should
never
fail
what
happened
?
"
)
;
if
(
aSandboxLevel
>
5
&
&
IsWin10OrLater
(
)
)
{
mPolicy
-
>
SetLockdownDefaultDacl
(
)
;
}
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_PREFER_SYS32
;
#
if
defined
(
_M_ARM64
)
if
(
!
IsWin10Sep2018UpdateOrLater
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_CONTROL_FLOW_GUARD_DISABLE
;
}
#
endif
if
(
aSandboxLevel
>
4
)
{
result
=
mPolicy
-
>
SetAlternateDesktop
(
false
)
;
if
(
NS_WARN_IF
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
)
{
LOG_W
(
"
SetAlternateDesktop
failed
result
:
%
i
last
error
:
%
x
"
result
:
:
GetLastError
(
)
)
;
}
}
if
(
aSandboxLevel
>
3
)
{
if
(
!
sRunningFromNetworkDrive
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_IMAGE_LOAD_NO_REMOTE
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_NO_LOW_LABEL
;
}
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
sContentTempDir
NS_LITERAL_STRING
(
"
\
\
*
"
)
)
;
if
(
aSandboxLevel
=
=
1
|
|
aIsFileProcess
)
{
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
L
"
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
"
"
what
happened
?
"
)
;
}
else
{
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sLocalAppDataDir
NS_LITERAL_STRING
(
"
\
\
Microsoft
\
\
Windows
\
\
Fonts
\
\
*
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sBinDir
NS_LITERAL_STRING
(
"
\
\
*
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sProfileDir
NS_LITERAL_STRING
(
"
\
\
chrome
\
\
*
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sProfileDir
NS_LITERAL_STRING
(
"
\
\
extensions
\
\
*
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sUserExtensionsDevDir
NS_LITERAL_STRING
(
"
\
\
*
"
)
)
;
#
ifdef
ENABLE_SYSTEM_EXTENSION_DIRS
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sUserExtensionsDir
NS_LITERAL_STRING
(
"
\
\
*
"
)
)
;
#
endif
}
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
File
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Section
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Semaphore
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Semaphore
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
}
void
SandboxBroker
:
:
SetSecurityLevelForGPUProcess
(
int32_t
aSandboxLevel
)
{
MOZ_RELEASE_ASSERT
(
mPolicy
"
mPolicy
must
be
set
before
this
call
.
"
)
;
sandbox
:
:
JobLevel
jobLevel
;
sandbox
:
:
TokenLevel
accessTokenLevel
;
sandbox
:
:
IntegrityLevel
initialIntegrityLevel
;
sandbox
:
:
IntegrityLevel
delayedIntegrityLevel
;
if
(
aSandboxLevel
>
=
2
)
{
jobLevel
=
sandbox
:
:
JOB_NONE
;
accessTokenLevel
=
sandbox
:
:
USER_LIMITED
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
{
MOZ_RELEASE_ASSERT
(
aSandboxLevel
>
=
1
"
Should
not
be
called
with
aSandboxLevel
<
1
"
)
;
jobLevel
=
sandbox
:
:
JOB_NONE
;
accessTokenLevel
=
sandbox
:
:
USER_NON_ADMIN
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
sandbox
:
:
ResultCode
result
=
SetJobLevel
(
mPolicy
jobLevel
0
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Setting
job
level
failed
have
you
set
memory
limit
when
"
"
jobLevel
=
=
JOB_NONE
?
"
)
;
sandbox
:
:
TokenLevel
initialAccessTokenLevel
=
(
accessTokenLevel
=
=
sandbox
:
:
USER_UNPROTECTED
|
|
accessTokenLevel
=
=
sandbox
:
:
USER_NON_ADMIN
)
?
sandbox
:
:
USER_UNPROTECTED
:
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
;
result
=
mPolicy
-
>
SetTokenLevel
(
initialAccessTokenLevel
accessTokenLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Lockdown
level
cannot
be
USER_UNPROTECTED
or
USER_LAST
"
"
if
initial
level
was
USER_RESTRICTED_SAME_ACCESS
"
)
;
result
=
mPolicy
-
>
SetIntegrityLevel
(
initialIntegrityLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetIntegrityLevel
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
delayedIntegrityLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetDelayedIntegrityLevel
should
never
fail
what
happened
?
"
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
;
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Section
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
}
#
define
SANDBOX_ENSURE_SUCCESS
(
result
message
)
\
do
{
\
MOZ_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
message
)
;
\
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
return
false
;
\
}
while
(
0
)
bool
SandboxBroker
:
:
SetSecurityLevelForRDDProcess
(
)
{
if
(
!
mPolicy
)
{
return
false
;
}
auto
result
=
SetJobLevel
(
mPolicy
sandbox
:
:
JOB_LOCKDOWN
0
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetJobLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetTokenLevel
(
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
sandbox
:
:
USER_LOCKDOWN
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetTokenLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetAlternateDesktop
(
true
)
;
if
(
NS_WARN_IF
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
)
{
LOG_W
(
"
SetAlternateDesktop
failed
result
:
%
i
last
error
:
%
x
"
result
:
:
GetLastError
(
)
)
;
}
result
=
mPolicy
-
>
SetIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetIntegrityLevel
should
never
fail
with
these
"
"
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_UNTRUSTED
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetDelayedIntegrityLevel
should
never
fail
with
"
"
these
arguments
what
happened
?
"
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_PREFER_SYS32
;
if
(
sRddWin32kDisable
&
&
IsWin8OrLater
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_WIN32K_DISABLE
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_WIN32K_LOCKDOWN
sandbox
:
:
TargetPolicy
:
:
FAKE_USER_GDI_INIT
nullptr
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Failed
to
set
FAKE_USER_GDI_INIT
policy
.
"
)
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DYNAMIC_CODE_DISABLE
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
|
sandbox
:
:
MITIGATION_FORCE_MS_SIGNED_BINS
;
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Section
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
return
true
;
}
bool
SandboxBroker
:
:
SetSecurityLevelForPluginProcess
(
int32_t
aSandboxLevel
)
{
if
(
!
mPolicy
)
{
return
false
;
}
sandbox
:
:
JobLevel
jobLevel
;
sandbox
:
:
TokenLevel
accessTokenLevel
;
sandbox
:
:
IntegrityLevel
initialIntegrityLevel
;
sandbox
:
:
IntegrityLevel
delayedIntegrityLevel
;
if
(
aSandboxLevel
>
2
)
{
jobLevel
=
sandbox
:
:
JOB_UNPROTECTED
;
accessTokenLevel
=
sandbox
:
:
USER_LIMITED
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
if
(
aSandboxLevel
=
=
2
)
{
jobLevel
=
sandbox
:
:
JOB_UNPROTECTED
;
accessTokenLevel
=
sandbox
:
:
USER_INTERACTIVE
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
{
jobLevel
=
sandbox
:
:
JOB_NONE
;
accessTokenLevel
=
sandbox
:
:
USER_NON_ADMIN
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_MEDIUM
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_MEDIUM
;
}
sandbox
:
:
ResultCode
result
=
SetJobLevel
(
mPolicy
jobLevel
0
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Setting
job
level
failed
have
you
set
memory
limit
"
"
when
jobLevel
=
=
JOB_NONE
?
"
)
;
result
=
mPolicy
-
>
SetTokenLevel
(
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
accessTokenLevel
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Lockdown
level
cannot
be
USER_UNPROTECTED
or
USER_LAST
if
initial
level
"
"
was
USER_RESTRICTED_SAME_ACCESS
"
)
;
result
=
mPolicy
-
>
SetIntegrityLevel
(
initialIntegrityLevel
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetIntegrityLevel
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
delayedIntegrityLevel
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetDelayedIntegrityLevel
should
never
fail
what
happened
?
"
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
|
sandbox
:
:
MITIGATION_HARDEN_TOKEN_IL_POLICY
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_NONSYSTEM_FONT_DISABLE
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_PREFER_SYS32
;
if
(
!
sRunningFromNetworkDrive
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_IMAGE_LOAD_NO_REMOTE
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_NO_LOW_LABEL
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
sandbox
:
:
MitigationFlags
delayedMitigations
=
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
delayedMitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
sPluginTempDir
NS_LITERAL_STRING
(
"
\
\
*
"
)
)
;
if
(
aSandboxLevel
>
=
2
)
{
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
sRoamingAppDataDir
NS_LITERAL_STRING
(
"
\
\
Macromedia
\
\
Flash
Player
\
\
*
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
sLocalAppDataDir
NS_LITERAL_STRING
(
"
\
\
Macromedia
\
\
Flash
Player
\
\
*
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
sRoamingAppDataDir
NS_LITERAL_STRING
(
"
\
\
Adobe
\
\
Flash
Player
\
\
*
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_DIR_ANY
sRoamingAppDataDir
NS_LITERAL_STRING
(
"
\
\
Macromedia
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_QUERY
sRoamingAppDataDir
NS_LITERAL_STRING
(
"
\
\
Macromedia
\
\
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_DIR_ANY
sRoamingAppDataDir
NS_LITERAL_STRING
(
"
\
\
Macromedia
\
\
Flash
Player
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_DIR_ANY
sLocalAppDataDir
NS_LITERAL_STRING
(
"
\
\
Macromedia
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_DIR_ANY
sLocalAppDataDir
NS_LITERAL_STRING
(
"
\
\
Macromedia
\
\
Flash
Player
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_DIR_ANY
sRoamingAppDataDir
NS_LITERAL_STRING
(
"
\
\
Adobe
"
)
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_DIR_ANY
sRoamingAppDataDir
NS_LITERAL_STRING
(
"
\
\
Adobe
\
\
Flash
Player
"
)
)
;
}
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Section
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_ANY
L
"
HKEY_CURRENT_
"
L
"
USER
\
\
Software
\
\
Microsoft
\
\
Windows
\
\
CurrentVersio
"
L
"
n
\
\
Explorer
\
\
ComDlg32
\
\
OpenSavePidlMRU
\
\
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_ANY
L
"
HKEY_CURRENT_
"
L
"
USER
\
\
Software
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Ex
"
L
"
plorer
\
\
ComDlg32
\
\
LastVisitedPidlMRULegacy
\
\
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
return
true
;
}
bool
SandboxBroker
:
:
SetSecurityLevelForGMPlugin
(
SandboxLevel
aLevel
)
{
if
(
!
mPolicy
)
{
return
false
;
}
auto
result
=
SetJobLevel
(
mPolicy
sandbox
:
:
JOB_LOCKDOWN
0
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetJobLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
auto
level
=
(
aLevel
=
=
Restricted
)
?
sandbox
:
:
USER_RESTRICTED
:
sandbox
:
:
USER_LOCKDOWN
;
result
=
mPolicy
-
>
SetTokenLevel
(
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
level
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetTokenLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetAlternateDesktop
(
true
)
;
if
(
NS_WARN_IF
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
)
{
LOG_W
(
"
SetAlternateDesktop
failed
result
:
%
i
last
error
:
%
x
"
result
:
:
GetLastError
(
)
)
;
}
result
=
mPolicy
-
>
SetIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
;
MOZ_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetIntegrityLevel
should
never
fail
with
these
arguments
what
"
"
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_UNTRUSTED
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetIntegrityLevel
should
never
fail
with
these
"
"
arguments
what
happened
?
"
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
;
if
(
sGmpWin32kDisable
&
&
IsWin10OrLater
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_WIN32K_DISABLE
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_WIN32K_LOCKDOWN
sandbox
:
:
TargetPolicy
:
:
IMPLEMENT_OPM_APIS
nullptr
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Failed
to
set
OPM
policy
.
"
)
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
#
ifdef
DEBUG
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_SYNC
sandbox
:
:
TargetPolicy
:
:
EVENTS_ALLOW_ANY
L
"
ChromeIPCLog
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
#
endif
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
Control
Panel
\
\
Desktop
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
Control
Panel
\
\
Desktop
\
\
LanguageConfiguration
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_
"
L
"
MACHINE
\
\
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
SideBySide
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_MACHINE
\
\
SOFTWARE
\
\
Policies
\
\
Microsoft
\
\
MUI
\
\
Settings
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
Software
\
\
Policies
\
\
Microsoft
\
\
Control
"
L
"
Panel
\
\
Desktop
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
Control
Panel
\
\
Desktop
\
\
PreferredUILanguages
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_
"
L
"
MACHINE
\
\
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVer
"
L
"
sion
\
\
SideBySide
\
\
PreferExternalManifest
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
L
"
\
\
Device
\
\
SrpDevice
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_MACHINE
\
\
System
\
\
CurrentControlSet
\
\
Control
\
\
Srp
\
\
GP
\
\
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_MACHINE
\
\
System
\
\
CurrentControlSet
\
\
Control
\
\
Srp
\
\
\
\
GP
\
\
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
return
true
;
}
#
undef
SANDBOX_ENSURE_SUCCESS
bool
SandboxBroker
:
:
AllowReadFile
(
wchar_t
const
*
file
)
{
if
(
!
mPolicy
)
{
return
false
;
}
auto
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
file
)
;
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
{
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
file
)
;
return
false
;
}
return
true
;
}
bool
SandboxBroker
:
:
AddTargetPeer
(
HANDLE
aPeerProcess
)
{
if
(
!
sBrokerService
)
{
return
false
;
}
sandbox
:
:
ResultCode
result
=
sBrokerService
-
>
AddTargetPeer
(
aPeerProcess
)
;
return
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
)
;
}
void
SandboxBroker
:
:
AddHandleToShare
(
HANDLE
aHandle
)
{
mPolicy
-
>
AddHandleToShare
(
aHandle
)
;
}
void
SandboxBroker
:
:
ApplyLoggingPolicy
(
)
{
MOZ_ASSERT
(
mPolicy
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_NAMED_PIPES
sandbox
:
:
TargetPolicy
:
:
NAMEDPIPES_ALLOW_ANY
L
"
dummy
"
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_PROCESS
sandbox
:
:
TargetPolicy
:
:
PROCESS_MIN_EXEC
L
"
dummy
"
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
dummy
"
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_SYNC
sandbox
:
:
TargetPolicy
:
:
EVENTS_ALLOW_READONLY
L
"
dummy
"
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
dummy
"
)
;
}
SandboxBroker
:
:
~
SandboxBroker
(
)
{
if
(
mPolicy
)
{
mPolicy
-
>
Release
(
)
;
mPolicy
=
nullptr
;
}
}
#
ifdef
_ARM64_
extern
AbstractSandboxBroker
*
CreateRemoteSandboxBroker
(
)
;
#
endif
AbstractSandboxBroker
*
AbstractSandboxBroker
:
:
Create
(
GeckoProcessType
aProcessType
)
{
#
ifdef
_ARM64_
if
(
aProcessType
=
=
GeckoProcessType_GMPlugin
)
{
return
CreateRemoteSandboxBroker
(
)
;
}
#
endif
return
new
SandboxBroker
(
)
;
}
}
