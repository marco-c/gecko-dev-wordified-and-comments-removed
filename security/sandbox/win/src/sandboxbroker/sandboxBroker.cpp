#
define
MOZ_USE_LAUNCHER_ERROR
#
include
"
sandboxBroker
.
h
"
#
include
<
shlobj
.
h
>
#
include
<
string
>
#
include
"
base
/
win
/
windows_version
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ImportDir
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
NSPRLogModulesParser
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
WinDllServices
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
sandbox
/
win
/
src
/
sandbox
.
h
"
#
include
"
sandbox
/
win
/
src
/
security_level
.
h
"
#
include
"
WinUtils
.
h
"
namespace
mozilla
{
sandbox
:
:
BrokerServices
*
SandboxBroker
:
:
sBrokerService
=
nullptr
;
bool
SandboxBroker
:
:
sRunningFromNetworkDrive
=
false
;
static
UniquePtr
<
nsString
>
sBinDir
;
static
UniquePtr
<
nsString
>
sProfileDir
;
static
UniquePtr
<
nsString
>
sContentTempDir
;
static
UniquePtr
<
nsString
>
sRoamingAppDataDir
;
static
UniquePtr
<
nsString
>
sLocalAppDataDir
;
#
ifdef
ENABLE_SYSTEM_EXTENSION_DIRS
static
UniquePtr
<
nsString
>
sUserExtensionsDir
;
#
endif
static
LazyLogModule
sSandboxBrokerLog
(
"
SandboxBroker
"
)
;
#
define
LOG_E
(
.
.
.
)
MOZ_LOG
(
sSandboxBrokerLog
LogLevel
:
:
Error
(
__VA_ARGS__
)
)
#
define
LOG_W
(
.
.
.
)
MOZ_LOG
(
sSandboxBrokerLog
LogLevel
:
:
Warning
(
__VA_ARGS__
)
)
static
UniquePtr
<
nsTHashtable
<
nsCStringHashKey
>
>
sLaunchErrors
;
static
sandbox
:
:
ResultCode
AddWin32kLockdownPolicy
(
sandbox
:
:
TargetPolicy
*
aPolicy
bool
aEnableOpm
)
{
if
(
!
IsWin8OrLater
(
)
)
{
return
sandbox
:
:
SBOX_ALL_OK
;
}
sandbox
:
:
MitigationFlags
flags
=
aPolicy
-
>
GetProcessMitigations
(
)
;
MOZ_ASSERT
(
!
(
flags
&
sandbox
:
:
MITIGATION_WIN32K_DISABLE
)
"
Check
not
enabling
twice
.
Should
not
happen
.
"
)
;
flags
|
=
sandbox
:
:
MITIGATION_WIN32K_DISABLE
;
sandbox
:
:
ResultCode
result
=
aPolicy
-
>
SetProcessMitigations
(
flags
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
return
result
;
}
result
=
aPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_WIN32K_LOCKDOWN
aEnableOpm
?
sandbox
:
:
TargetPolicy
:
:
IMPLEMENT_OPM_APIS
:
sandbox
:
:
TargetPolicy
:
:
FAKE_USER_GDI_INIT
nullptr
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
return
result
;
}
if
(
aEnableOpm
)
{
aPolicy
-
>
SetEnableOPMRedirection
(
)
;
}
return
result
;
}
void
SandboxBroker
:
:
Initialize
(
sandbox
:
:
BrokerServices
*
aBrokerServices
)
{
sBrokerService
=
aBrokerServices
;
sRunningFromNetworkDrive
=
widget
:
:
WinUtils
:
:
RunningFromANetworkDrive
(
)
;
}
static
void
CacheDirAndAutoClear
(
nsIProperties
*
aDirSvc
const
char
*
aDirKey
UniquePtr
<
nsString
>
*
cacheVar
)
{
nsCOMPtr
<
nsIFile
>
dirToCache
;
nsresult
rv
=
aDirSvc
-
>
Get
(
aDirKey
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
dirToCache
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
directory
to
cache
.
"
)
;
LOG_E
(
"
Failed
to
get
directory
to
cache
key
:
%
s
.
"
aDirKey
)
;
return
;
}
*
cacheVar
=
MakeUnique
<
nsString
>
(
)
;
ClearOnShutdown
(
cacheVar
)
;
MOZ_ALWAYS_SUCCEEDS
(
dirToCache
-
>
GetPath
(
*
*
cacheVar
)
)
;
if
(
Substring
(
*
*
cacheVar
0
2
)
.
Equals
(
u
"
\
\
\
\
"
_ns
)
)
{
(
*
cacheVar
)
-
>
InsertLiteral
(
u
"
?
?
\
\
UNC
"
1
)
;
}
}
void
SandboxBroker
:
:
GeckoDependentInitialize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
haveXPCOM
=
XRE_GetProcessType
(
)
!
=
GeckoProcessType_RemoteSandboxBroker
;
if
(
haveXPCOM
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
dirSvc
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
get
directory
service
cannot
cache
directories
"
"
for
rules
.
"
)
;
LOG_E
(
"
Failed
to
get
directory
service
cannot
cache
directories
for
"
"
rules
.
"
)
;
return
;
}
CacheDirAndAutoClear
(
dirSvc
NS_GRE_DIR
&
sBinDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_APP_USER_PROFILE_50_DIR
&
sProfileDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_APP_CONTENT_PROCESS_TEMP_DIR
&
sContentTempDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_WIN_APPDATA_DIR
&
sRoamingAppDataDir
)
;
CacheDirAndAutoClear
(
dirSvc
NS_WIN_LOCAL_APPDATA_DIR
&
sLocalAppDataDir
)
;
#
ifdef
ENABLE_SYSTEM_EXTENSION_DIRS
CacheDirAndAutoClear
(
dirSvc
XRE_USER_SYS_EXTENSION_DIR
&
sUserExtensionsDir
)
;
#
endif
}
sLaunchErrors
=
MakeUnique
<
nsTHashtable
<
nsCStringHashKey
>
>
(
)
;
ClearOnShutdown
(
&
sLaunchErrors
)
;
}
SandboxBroker
:
:
SandboxBroker
(
)
{
if
(
sBrokerService
)
{
scoped_refptr
<
sandbox
:
:
TargetPolicy
>
policy
=
sBrokerService
-
>
CreatePolicy
(
)
;
mPolicy
=
policy
.
get
(
)
;
mPolicy
-
>
AddRef
(
)
;
if
(
sRunningFromNetworkDrive
)
{
mPolicy
-
>
SetDoNotUseRestrictingSIDs
(
)
;
}
}
else
{
mPolicy
=
nullptr
;
}
}
#
define
WSTRING
(
STRING
)
L
"
"
STRING
static
void
AddMozLogRulesToPolicy
(
sandbox
:
:
TargetPolicy
*
aPolicy
const
base
:
:
EnvironmentMap
&
aEnvironment
)
{
auto
it
=
aEnvironment
.
find
(
ENVIRONMENT_LITERAL
(
"
MOZ_LOG_FILE
"
)
)
;
if
(
it
=
=
aEnvironment
.
end
(
)
)
{
it
=
aEnvironment
.
find
(
ENVIRONMENT_LITERAL
(
"
NSPR_LOG_FILE
"
)
)
;
}
if
(
it
=
=
aEnvironment
.
end
(
)
)
{
return
;
}
char
const
*
logFileModules
=
getenv
(
"
MOZ_LOG
"
)
;
if
(
!
logFileModules
)
{
return
;
}
std
:
:
wstring
logFileName
(
it
-
>
second
)
;
logFileName
.
append
(
WSTRING
(
MOZ_LOG_FILE_EXTENSION
)
)
;
bool
rotate
=
false
;
NSPRLogModulesParser
(
logFileModules
[
&
rotate
]
(
const
char
*
aName
LogLevel
aLevel
int32_t
aValue
)
{
if
(
strcmp
(
aName
"
rotate
"
)
=
=
0
)
{
rotate
=
aValue
>
0
;
}
}
)
;
if
(
rotate
)
{
logFileName
.
append
(
L
"
.
?
"
)
;
}
auto
pidPos
=
logFileName
.
find
(
WSTRING
(
MOZ_LOG_PID_TOKEN
)
)
;
auto
lastSlash
=
logFileName
.
find_last_of
(
L
"
/
\
\
"
)
;
if
(
pidPos
!
=
std
:
:
wstring
:
:
npos
&
&
(
lastSlash
=
=
std
:
:
wstring
:
:
npos
|
|
lastSlash
<
pidPos
)
)
{
logFileName
.
replace
(
pidPos
strlen
(
MOZ_LOG_PID_TOKEN
)
L
"
*
"
)
;
}
aPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
logFileName
.
c_str
(
)
)
;
}
static
void
AddDeveloperRepoDirToPolicy
(
sandbox
:
:
TargetPolicy
*
aPolicy
)
{
const
wchar_t
*
developer_repo_dir
=
_wgetenv
(
WSTRING
(
"
MOZ_DEVELOPER_REPO_DIR
"
)
)
;
if
(
!
developer_repo_dir
)
{
return
;
}
std
:
:
wstring
repoPath
(
developer_repo_dir
)
;
std
:
:
replace
(
repoPath
.
begin
(
)
repoPath
.
end
(
)
'
/
'
'
\
\
'
)
;
repoPath
.
append
(
WSTRING
(
"
\
\
*
"
)
)
;
aPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
repoPath
.
c_str
(
)
)
;
}
#
undef
WSTRING
bool
SandboxBroker
:
:
LaunchApp
(
const
wchar_t
*
aPath
const
wchar_t
*
aArguments
base
:
:
EnvironmentMap
&
aEnvironment
GeckoProcessType
aProcessType
const
bool
aEnableLogging
const
IMAGE_THUNK_DATA
*
aCachedNtdllThunk
void
*
*
aProcessHandle
)
{
if
(
!
sBrokerService
|
|
!
mPolicy
)
{
return
false
;
}
mPolicy
-
>
SetStdoutHandle
(
:
:
GetStdHandle
(
STD_OUTPUT_HANDLE
)
)
;
mPolicy
-
>
SetStderrHandle
(
:
:
GetStdHandle
(
STD_ERROR_HANDLE
)
)
;
if
(
aEnableLogging
)
{
ApplyLoggingPolicy
(
)
;
}
#
if
defined
(
DEBUG
)
wchar_t
tempPath
[
MAX_PATH
+
2
]
;
uint32_t
pathLen
=
:
:
GetTempPathW
(
MAX_PATH
+
1
tempPath
)
;
if
(
pathLen
>
0
)
{
tempPath
[
pathLen
]
=
L
'
*
'
;
tempPath
[
pathLen
+
1
]
=
L
'
\
0
'
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
tempPath
)
;
}
#
endif
AddMozLogRulesToPolicy
(
mPolicy
aEnvironment
)
;
if
(
mozilla
:
:
IsDevelopmentBuild
(
)
)
{
AddDeveloperRepoDirToPolicy
(
mPolicy
)
;
}
PROCESS_INFORMATION
targetInfo
=
{
0
}
;
sandbox
:
:
ResultCode
result
;
sandbox
:
:
ResultCode
last_warning
=
sandbox
:
:
SBOX_ALL_OK
;
DWORD
last_error
=
ERROR_SUCCESS
;
result
=
sBrokerService
-
>
SpawnTarget
(
aPath
aArguments
aEnvironment
mPolicy
&
last_warning
&
last_error
&
targetInfo
)
;
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
{
nsAutoCString
key
;
key
.
AppendASCII
(
XRE_GeckoProcessTypeToString
(
aProcessType
)
)
;
key
.
AppendLiteral
(
"
/
0x
"
)
;
key
.
AppendInt
(
static_cast
<
uint32_t
>
(
last_error
)
16
)
;
if
(
sLaunchErrors
)
{
if
(
!
sLaunchErrors
-
>
Contains
(
key
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SANDBOX_FAILED_LAUNCH_KEYED
key
result
)
;
sLaunchErrors
-
>
PutEntry
(
key
)
;
}
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SANDBOX_FAILED_LAUNCH_KEYED
key
result
)
;
}
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
SpawnTarget
with
last_error
=
%
lu
"
"
last_warning
=
%
d
"
result
last_error
last_warning
)
;
return
false
;
}
else
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
last_warning
)
{
LOG_W
(
"
Warning
on
SpawnTarget
with
last_error
=
%
lu
last_warning
=
%
d
"
last_error
last_warning
)
;
}
#
ifdef
MOZ_THUNDERBIRD
constexpr
bool
isThunderbird
=
true
;
#
else
constexpr
bool
isThunderbird
=
false
;
#
endif
if
(
!
isThunderbird
&
&
XRE_GetChildProcBinPathType
(
aProcessType
)
=
=
BinPathType
:
:
Self
)
{
bool
isUtilityProcess
=
aProcessType
=
=
GeckoProcessType_Utility
;
RefPtr
<
DllServices
>
dllSvc
(
DllServices
:
:
Get
(
)
)
;
LauncherVoidResultWithLineInfo
blocklistInitOk
=
dllSvc
-
>
InitDllBlocklistOOP
(
aPath
targetInfo
.
hProcess
aCachedNtdllThunk
isUtilityProcess
)
;
if
(
blocklistInitOk
.
isErr
(
)
)
{
dllSvc
-
>
HandleLauncherError
(
blocklistInitOk
.
unwrapErr
(
)
XRE_GeckoProcessTypeToString
(
aProcessType
)
)
;
LOG_E
(
"
InitDllBlocklistOOP
failed
at
%
s
:
%
d
with
HRESULT
0x
%
08lX
"
blocklistInitOk
.
unwrapErr
(
)
.
mFile
blocklistInitOk
.
unwrapErr
(
)
.
mLine
blocklistInitOk
.
unwrapErr
(
)
.
mError
.
AsHResult
(
)
)
;
TerminateProcess
(
targetInfo
.
hProcess
1
)
;
CloseHandle
(
targetInfo
.
hThread
)
;
CloseHandle
(
targetInfo
.
hProcess
)
;
return
false
;
}
}
else
{
nsModuleHandle
moduleHandle
(
:
:
LoadLibraryExW
(
aPath
nullptr
LOAD_LIBRARY_AS_DATAFILE
)
)
;
if
(
moduleHandle
)
{
nt
:
:
CrossExecTransferManager
transferMgr
(
targetInfo
.
hProcess
moduleHandle
)
;
if
(
!
!
transferMgr
)
{
LauncherVoidResult
importsRestored
=
RestoreImportDirectory
(
aPath
transferMgr
)
;
if
(
importsRestored
.
isErr
(
)
)
{
RefPtr
<
DllServices
>
dllSvc
(
DllServices
:
:
Get
(
)
)
;
dllSvc
-
>
HandleLauncherError
(
importsRestored
.
unwrapErr
(
)
XRE_GeckoProcessTypeToString
(
aProcessType
)
)
;
LOG_E
(
"
Failed
to
restore
import
directory
with
HRESULT
0x
%
08lX
"
importsRestored
.
unwrapErr
(
)
.
mError
.
AsHResult
(
)
)
;
TerminateProcess
(
targetInfo
.
hProcess
1
)
;
CloseHandle
(
targetInfo
.
hThread
)
;
CloseHandle
(
targetInfo
.
hProcess
)
;
return
false
;
}
}
}
}
ResumeThread
(
targetInfo
.
hThread
)
;
CloseHandle
(
targetInfo
.
hThread
)
;
*
aProcessHandle
=
targetInfo
.
hProcess
;
return
true
;
}
static
void
AddCachedDirRule
(
sandbox
:
:
TargetPolicy
*
aPolicy
sandbox
:
:
TargetPolicy
:
:
Semantics
aAccess
const
UniquePtr
<
nsString
>
&
aBaseDir
const
nsLiteralString
&
aRelativePath
)
{
if
(
!
aBaseDir
)
{
NS_WARNING
(
"
Tried
to
add
rule
with
null
base
dir
.
"
)
;
LOG_E
(
"
Tried
to
add
rule
with
null
base
dir
.
Relative
path
:
%
S
Access
:
%
d
"
static_cast
<
const
wchar_t
*
>
(
aRelativePath
.
get
(
)
)
aAccess
)
;
return
;
}
nsAutoString
rulePath
(
*
aBaseDir
)
;
rulePath
.
Append
(
aRelativePath
)
;
sandbox
:
:
ResultCode
result
=
aPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
aAccess
rulePath
.
get
(
)
)
;
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
{
NS_ERROR
(
"
Failed
to
add
file
policy
rule
.
"
)
;
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
%
d
access
to
:
%
S
"
result
aAccess
static_cast
<
const
wchar_t
*
>
(
rulePath
.
get
(
)
)
)
;
}
}
static
const
Maybe
<
Vector
<
const
wchar_t
*
>
>
&
GetPrespawnCigExceptionModules
(
)
{
static
Maybe
<
Vector
<
const
wchar_t
*
>
>
sDependentModules
=
[
]
(
)
-
>
Maybe
<
Vector
<
const
wchar_t
*
>
>
{
using
GetDependentModulePathsFn
=
const
wchar_t
*
(
*
)
(
)
;
GetDependentModulePathsFn
getDependentModulePaths
=
reinterpret_cast
<
GetDependentModulePathsFn
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
nullptr
)
"
GetDependentModulePaths
"
)
)
;
if
(
!
getDependentModulePaths
)
{
return
Nothing
(
)
;
}
const
wchar_t
*
arrayBase
=
getDependentModulePaths
(
)
;
if
(
!
arrayBase
)
{
return
Nothing
(
)
;
}
Vector
<
const
wchar_t
*
>
paths
;
for
(
const
wchar_t
*
p
=
arrayBase
;
*
p
;
)
{
Unused
<
<
paths
.
append
(
p
)
;
while
(
*
p
)
{
+
+
p
;
}
+
+
p
;
}
return
Some
(
std
:
:
move
(
paths
)
)
;
}
(
)
;
return
sDependentModules
;
}
static
sandbox
:
:
ResultCode
InitSignedPolicyRulesToBypassCig
(
sandbox
:
:
TargetPolicy
*
aPolicy
const
Vector
<
const
wchar_t
*
>
&
aExceptionModules
)
{
static
UniquePtr
<
nsString
>
sInstallDir
;
if
(
!
sInstallDir
)
{
UniquePtr
<
wchar_t
[
]
>
appDirStr
;
if
(
GetInstallDirectory
(
appDirStr
)
)
{
sInstallDir
=
MakeUnique
<
nsString
>
(
appDirStr
.
get
(
)
)
;
sInstallDir
-
>
Append
(
u
"
\
\
*
"
)
;
auto
setClearOnShutdown
=
[
ptr
=
&
sInstallDir
]
(
)
-
>
void
{
ClearOnShutdown
(
ptr
)
;
}
;
if
(
NS_IsMainThread
(
)
)
{
setClearOnShutdown
(
)
;
}
else
{
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NS_NewRunnableFunction
(
"
InitSignedPolicyRulesToBypassCig
"
std
:
:
move
(
setClearOnShutdown
)
)
)
;
}
}
if
(
!
sInstallDir
)
{
return
sandbox
:
:
SBOX_ERROR_GENERIC
;
}
}
auto
result
=
aPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_SIGNED_BINARY
sandbox
:
:
TargetPolicy
:
:
SIGNED_ALLOW_LOAD
sInstallDir
-
>
get
(
)
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
return
result
;
}
if
(
aExceptionModules
.
empty
(
)
)
{
return
sandbox
:
:
SBOX_ALL_OK
;
}
for
(
const
wchar_t
*
path
:
aExceptionModules
)
{
result
=
aPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_SIGNED_BINARY
sandbox
:
:
TargetPolicy
:
:
SIGNED_ALLOW_LOAD
path
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
return
result
;
}
}
return
sandbox
:
:
SBOX_ALL_OK
;
}
static
bool
CanUseJob
(
)
{
if
(
IsWin8OrLater
(
)
)
{
return
true
;
}
BOOL
inJob
=
true
;
if
(
!
:
:
IsProcessInJob
(
:
:
GetCurrentProcess
(
)
nullptr
&
inJob
)
)
{
return
true
;
}
if
(
!
inJob
)
{
return
true
;
}
JOBOBJECT_EXTENDED_LIMIT_INFORMATION
job_info
=
{
}
;
if
(
!
:
:
QueryInformationJobObject
(
nullptr
JobObjectExtendedLimitInformation
&
job_info
sizeof
(
job_info
)
nullptr
)
)
{
return
true
;
}
if
(
job_info
.
BasicLimitInformation
.
LimitFlags
&
JOB_OBJECT_LIMIT_BREAKAWAY_OK
)
{
return
true
;
}
nsAutoString
localRemote
(
:
:
GetSystemMetrics
(
SM_REMOTESESSION
)
?
u
"
remote
"
:
u
"
local
"
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
SANDBOX_NO_JOB
localRemote
true
)
;
return
false
;
}
static
sandbox
:
:
ResultCode
SetJobLevel
(
sandbox
:
:
TargetPolicy
*
aPolicy
sandbox
:
:
JobLevel
aJobLevel
uint32_t
aUiExceptions
)
{
static
bool
sCanUseJob
=
CanUseJob
(
)
;
if
(
sCanUseJob
)
{
return
aPolicy
-
>
SetJobLevel
(
aJobLevel
aUiExceptions
)
;
}
return
aPolicy
-
>
SetJobLevel
(
sandbox
:
:
JOB_NONE
0
)
;
}
void
SandboxBroker
:
:
SetSecurityLevelForContentProcess
(
int32_t
aSandboxLevel
bool
aIsFileProcess
)
{
MOZ_RELEASE_ASSERT
(
mPolicy
"
mPolicy
must
be
set
before
this
call
.
"
)
;
sandbox
:
:
JobLevel
jobLevel
;
sandbox
:
:
TokenLevel
accessTokenLevel
;
sandbox
:
:
IntegrityLevel
initialIntegrityLevel
;
sandbox
:
:
IntegrityLevel
delayedIntegrityLevel
;
MOZ_RELEASE_ASSERT
(
aSandboxLevel
>
=
1
"
Should
not
be
called
with
aSandboxLevel
<
1
"
)
;
if
(
aSandboxLevel
>
=
20
)
{
jobLevel
=
sandbox
:
:
JOB_LOCKDOWN
;
accessTokenLevel
=
sandbox
:
:
USER_LOCKDOWN
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_UNTRUSTED
;
}
else
if
(
aSandboxLevel
>
=
4
)
{
jobLevel
=
sandbox
:
:
JOB_LOCKDOWN
;
accessTokenLevel
=
sandbox
:
:
USER_LIMITED
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
if
(
aSandboxLevel
>
=
3
)
{
jobLevel
=
sandbox
:
:
JOB_RESTRICTED
;
accessTokenLevel
=
sandbox
:
:
USER_LIMITED
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
if
(
aSandboxLevel
=
=
2
)
{
jobLevel
=
sandbox
:
:
JOB_INTERACTIVE
;
accessTokenLevel
=
sandbox
:
:
USER_INTERACTIVE
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
{
MOZ_ASSERT
(
aSandboxLevel
=
=
1
)
;
jobLevel
=
sandbox
:
:
JOB_NONE
;
accessTokenLevel
=
sandbox
:
:
USER_NON_ADMIN
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
if
(
aIsFileProcess
)
{
if
(
accessTokenLevel
<
sandbox
:
:
USER_NON_ADMIN
)
{
accessTokenLevel
=
sandbox
:
:
USER_NON_ADMIN
;
}
if
(
delayedIntegrityLevel
>
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
{
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
}
#
if
defined
(
DEBUG
)
DWORD
uiExceptions
=
JOB_OBJECT_UILIMIT_HANDLES
;
#
else
DWORD
uiExceptions
=
0
;
#
endif
sandbox
:
:
ResultCode
result
=
SetJobLevel
(
mPolicy
jobLevel
uiExceptions
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Setting
job
level
failed
have
you
set
memory
limit
when
"
"
jobLevel
=
=
JOB_NONE
?
"
)
;
sandbox
:
:
TokenLevel
initialAccessTokenLevel
=
(
accessTokenLevel
=
=
sandbox
:
:
USER_UNPROTECTED
|
|
accessTokenLevel
=
=
sandbox
:
:
USER_NON_ADMIN
)
?
sandbox
:
:
USER_UNPROTECTED
:
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
;
result
=
mPolicy
-
>
SetTokenLevel
(
initialAccessTokenLevel
accessTokenLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Lockdown
level
cannot
be
USER_UNPROTECTED
or
USER_LAST
"
"
if
initial
level
was
USER_RESTRICTED_SAME_ACCESS
"
)
;
result
=
mPolicy
-
>
SetIntegrityLevel
(
initialIntegrityLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetIntegrityLevel
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
delayedIntegrityLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetDelayedIntegrityLevel
should
never
fail
what
happened
?
"
)
;
if
(
aSandboxLevel
>
5
)
{
mPolicy
-
>
SetLockdownDefaultDacl
(
)
;
mPolicy
-
>
AddRestrictingRandomSid
(
)
;
}
if
(
aSandboxLevel
>
4
)
{
bool
useAlternateWinstation
=
StaticPrefs
:
:
widget_non_native_theme_enabled
(
)
;
result
=
mPolicy
-
>
SetAlternateDesktop
(
useAlternateWinstation
)
;
if
(
NS_WARN_IF
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
)
{
LOG_W
(
"
SetAlternateDesktop
failed
result
:
%
i
last
error
:
%
lx
"
result
:
:
GetLastError
(
)
)
;
}
}
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_PREFER_SYS32
;
#
if
defined
(
_M_ARM64
)
if
(
!
IsWin10Sep2018UpdateOrLater
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_CONTROL_FLOW_GUARD_DISABLE
;
}
#
endif
if
(
aSandboxLevel
>
3
)
{
if
(
!
sRunningFromNetworkDrive
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_IMAGE_LOAD_NO_REMOTE
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_NO_LOW_LABEL
;
}
}
if
(
StaticPrefs
:
:
security_sandbox_content_shadow_stack_enabled
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_CET_COMPAT_MODE
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
nsIXULRuntime
:
:
ContentWin32kLockdownState
win32kLockdownState
=
GetContentWin32kLockdownState
(
)
;
LOG_W
(
"
Win32k
Lockdown
State
:
'
%
s
'
"
ContentWin32kLockdownStateToString
(
win32kLockdownState
)
)
;
if
(
GetContentWin32kLockdownEnabled
(
)
)
{
result
=
AddWin32kLockdownPolicy
(
mPolicy
false
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
sandbox
:
:
SBOX_ALL_OK
"
Failed
to
add
the
win32k
lockdown
policy
"
)
;
}
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
sContentTempDir
u
"
\
\
*
"
_ns
)
;
if
(
aSandboxLevel
=
=
1
|
|
aIsFileProcess
)
{
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
L
"
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
"
"
what
happened
?
"
)
;
}
else
{
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sLocalAppDataDir
u
"
\
\
Microsoft
\
\
Windows
\
\
Fonts
\
\
*
"
_ns
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sBinDir
u
"
\
\
*
"
_ns
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sProfileDir
u
"
\
\
chrome
\
\
*
"
_ns
)
;
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sProfileDir
u
"
\
\
extensions
\
\
*
"
_ns
)
;
#
ifdef
ENABLE_SYSTEM_EXTENSION_DIRS
AddCachedDirRule
(
mPolicy
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
sUserExtensionsDir
u
"
\
\
*
"
_ns
)
;
#
endif
}
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
File
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
File
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Section
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Semaphore
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Semaphore
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_LINE_BREAK
sandbox
:
:
TargetPolicy
:
:
LINE_BREAK_ALLOW
nullptr
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
if
(
aSandboxLevel
>
=
20
)
{
wchar_t
*
fontsPath
;
if
(
SUCCEEDED
(
:
:
SHGetKnownFolderPath
(
FOLDERID_Fonts
0
nullptr
&
fontsPath
)
)
)
{
std
:
:
wstring
fontsStr
=
fontsPath
;
:
:
CoTaskMemFree
(
fontsPath
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
fontsStr
.
c_str
(
)
)
;
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
{
NS_ERROR
(
"
Failed
to
add
fonts
dir
read
access
policy
rule
.
"
)
;
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
fontsStr
.
c_str
(
)
)
;
}
fontsStr
+
=
L
"
\
\
*
"
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
fontsStr
.
c_str
(
)
)
;
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
{
NS_ERROR
(
"
Failed
to
add
fonts
read
access
policy
rule
.
"
)
;
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
fontsStr
.
c_str
(
)
)
;
}
}
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_NAMED_PIPES
sandbox
:
:
TargetPolicy
:
:
NAMEDPIPES_ALLOW_ANY
L
"
\
\
\
\
.
\
\
pipe
\
\
chrome
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
.
"
)
;
}
}
void
SandboxBroker
:
:
SetSecurityLevelForGPUProcess
(
int32_t
aSandboxLevel
const
nsCOMPtr
<
nsIFile
>
&
aProfileDir
)
{
MOZ_RELEASE_ASSERT
(
mPolicy
"
mPolicy
must
be
set
before
this
call
.
"
)
;
sandbox
:
:
JobLevel
jobLevel
;
sandbox
:
:
TokenLevel
accessTokenLevel
;
sandbox
:
:
IntegrityLevel
initialIntegrityLevel
;
sandbox
:
:
IntegrityLevel
delayedIntegrityLevel
;
if
(
aSandboxLevel
>
=
2
)
{
jobLevel
=
sandbox
:
:
JOB_NONE
;
accessTokenLevel
=
sandbox
:
:
USER_LIMITED
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
else
{
MOZ_RELEASE_ASSERT
(
aSandboxLevel
>
=
1
"
Should
not
be
called
with
aSandboxLevel
<
1
"
)
;
jobLevel
=
sandbox
:
:
JOB_NONE
;
accessTokenLevel
=
sandbox
:
:
USER_NON_ADMIN
;
initialIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
delayedIntegrityLevel
=
sandbox
:
:
INTEGRITY_LEVEL_LOW
;
}
sandbox
:
:
ResultCode
result
=
SetJobLevel
(
mPolicy
jobLevel
0
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Setting
job
level
failed
have
you
set
memory
limit
when
"
"
jobLevel
=
=
JOB_NONE
?
"
)
;
sandbox
:
:
TokenLevel
initialAccessTokenLevel
=
(
accessTokenLevel
=
=
sandbox
:
:
USER_UNPROTECTED
|
|
accessTokenLevel
=
=
sandbox
:
:
USER_NON_ADMIN
)
?
sandbox
:
:
USER_UNPROTECTED
:
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
;
result
=
mPolicy
-
>
SetTokenLevel
(
initialAccessTokenLevel
accessTokenLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Lockdown
level
cannot
be
USER_UNPROTECTED
or
USER_LAST
"
"
if
initial
level
was
USER_RESTRICTED_SAME_ACCESS
"
)
;
result
=
mPolicy
-
>
SetIntegrityLevel
(
initialIntegrityLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetIntegrityLevel
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
delayedIntegrityLevel
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetDelayedIntegrityLevel
should
never
fail
what
happened
?
"
)
;
mPolicy
-
>
SetLockdownDefaultDacl
(
)
;
mPolicy
-
>
AddRestrictingRandomSid
(
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
;
if
(
StaticPrefs
:
:
security_sandbox_gpu_shadow_stack_enabled
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_CET_COMPAT_MODE
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
if
(
aProfileDir
)
{
if
(
!
[
&
aProfileDir
this
]
{
nsString
shaderCacheRulePath
;
nsresult
rv
=
aProfileDir
-
>
GetPath
(
shaderCacheRulePath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
shaderCacheRulePath
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
Substring
(
shaderCacheRulePath
0
2
)
.
Equals
(
u
"
\
\
\
\
"
)
)
{
shaderCacheRulePath
.
InsertLiteral
(
u
"
?
?
\
\
UNC
"
1
)
;
}
shaderCacheRulePath
.
Append
(
u
"
\
\
shader
-
cache
"
)
;
sandbox
:
:
ResultCode
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_DIR_ANY
shaderCacheRulePath
.
get
(
)
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
return
false
;
}
shaderCacheRulePath
.
Append
(
u
"
\
\
*
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
shaderCacheRulePath
.
get
(
)
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
return
false
;
}
return
true
;
}
(
)
)
{
NS_WARNING
(
"
Failed
to
add
rule
enabling
GPU
shader
cache
.
Performance
will
be
"
"
negatively
affected
"
)
;
}
}
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Section
"
)
;
MOZ_RELEASE_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
}
#
define
SANDBOX_ENSURE_SUCCESS
(
result
message
)
\
do
{
\
MOZ_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
message
)
;
\
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
return
false
;
\
}
while
(
0
)
bool
SandboxBroker
:
:
SetSecurityLevelForRDDProcess
(
)
{
if
(
!
mPolicy
)
{
return
false
;
}
auto
result
=
SetJobLevel
(
mPolicy
sandbox
:
:
JOB_LOCKDOWN
0
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetJobLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetTokenLevel
(
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
sandbox
:
:
USER_LIMITED
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetTokenLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetAlternateDesktop
(
true
)
;
if
(
NS_WARN_IF
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
)
{
LOG_W
(
"
SetAlternateDesktop
failed
result
:
%
i
last
error
:
%
lx
"
result
:
:
GetLastError
(
)
)
;
}
result
=
mPolicy
-
>
SetIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetIntegrityLevel
should
never
fail
with
these
"
"
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetDelayedIntegrityLevel
should
never
fail
with
"
"
these
arguments
what
happened
?
"
)
;
mPolicy
-
>
SetLockdownDefaultDacl
(
)
;
mPolicy
-
>
AddRestrictingRandomSid
(
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_PREFER_SYS32
;
const
Maybe
<
Vector
<
const
wchar_t
*
>
>
&
exceptionModules
=
GetPrespawnCigExceptionModules
(
)
;
if
(
exceptionModules
.
isSome
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_FORCE_MS_SIGNED_BINS
;
}
if
(
StaticPrefs
:
:
security_sandbox_rdd_shadow_stack_enabled
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_CET_COMPAT_MODE
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
if
(
exceptionModules
.
isSome
(
)
)
{
result
=
InitSignedPolicyRulesToBypassCig
(
mPolicy
exceptionModules
.
ref
(
)
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Failed
to
initialize
signed
policy
rules
.
"
)
;
}
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
if
(
exceptionModules
.
isNothing
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_FORCE_MS_SIGNED_BINS
;
}
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
L
"
Section
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
return
true
;
}
bool
SandboxBroker
:
:
SetSecurityLevelForSocketProcess
(
)
{
if
(
!
mPolicy
)
{
return
false
;
}
auto
result
=
SetJobLevel
(
mPolicy
sandbox
:
:
JOB_LOCKDOWN
0
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetJobLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetTokenLevel
(
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
sandbox
:
:
USER_LIMITED
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetTokenLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetAlternateDesktop
(
true
)
;
if
(
NS_WARN_IF
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
)
{
LOG_W
(
"
SetAlternateDesktop
failed
result
:
%
i
last
error
:
%
lx
"
result
:
:
GetLastError
(
)
)
;
}
result
=
mPolicy
-
>
SetIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetIntegrityLevel
should
never
fail
with
these
"
"
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_UNTRUSTED
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetDelayedIntegrityLevel
should
never
fail
with
"
"
these
arguments
what
happened
?
"
)
;
mPolicy
-
>
SetLockdownDefaultDacl
(
)
;
mPolicy
-
>
AddRestrictingRandomSid
(
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_PREFER_SYS32
;
const
Maybe
<
Vector
<
const
wchar_t
*
>
>
&
exceptionModules
=
GetPrespawnCigExceptionModules
(
)
;
if
(
exceptionModules
.
isSome
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_FORCE_MS_SIGNED_BINS
;
}
if
(
StaticPrefs
:
:
security_sandbox_socket_shadow_stack_enabled
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_CET_COMPAT_MODE
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
if
(
exceptionModules
.
isSome
(
)
)
{
result
=
InitSignedPolicyRulesToBypassCig
(
mPolicy
exceptionModules
.
ref
(
)
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Failed
to
initialize
signed
policy
rules
.
"
)
;
}
if
(
StaticPrefs
:
:
security_sandbox_socket_win32k_disable
(
)
)
{
result
=
AddWin32kLockdownPolicy
(
mPolicy
false
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Failed
to
add
the
win32k
lockdown
policy
"
)
;
}
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
|
sandbox
:
:
MITIGATION_DYNAMIC_CODE_DISABLE
;
if
(
exceptionModules
.
isNothing
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_FORCE_MS_SIGNED_BINS
;
}
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
return
true
;
}
bool
SandboxBroker
:
:
SetSecurityLevelForUtilityProcess
(
mozilla
:
:
ipc
:
:
SandboxingKind
aSandbox
)
{
if
(
!
mPolicy
)
{
return
false
;
}
auto
result
=
SetJobLevel
(
mPolicy
sandbox
:
:
JOB_LOCKDOWN
0
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetJobLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
auto
lockdownLevel
=
sandbox
:
:
USER_LOCKDOWN
;
if
(
aSandbox
=
=
mozilla
:
:
ipc
:
:
SandboxingKind
:
:
UTILITY_AUDIO_DECODING
)
{
lockdownLevel
=
sandbox
:
:
USER_LIMITED
;
}
result
=
mPolicy
-
>
SetTokenLevel
(
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
lockdownLevel
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetTokenLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetAlternateDesktop
(
true
)
;
if
(
NS_WARN_IF
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
)
{
LOG_W
(
"
SetAlternateDesktop
failed
result
:
%
i
last
error
:
%
lx
"
result
:
:
GetLastError
(
)
)
;
}
result
=
mPolicy
-
>
SetIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetIntegrityLevel
should
never
fail
with
these
"
"
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_UNTRUSTED
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetDelayedIntegrityLevel
should
never
fail
with
"
"
these
arguments
what
happened
?
"
)
;
mPolicy
-
>
SetLockdownDefaultDacl
(
)
;
mPolicy
-
>
AddRestrictingRandomSid
(
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
|
sandbox
:
:
MITIGATION_IMAGE_LOAD_PREFER_SYS32
|
sandbox
:
:
MITIGATION_CET_COMPAT_MODE
;
const
Maybe
<
Vector
<
const
wchar_t
*
>
>
&
exceptionModules
=
GetPrespawnCigExceptionModules
(
)
;
if
(
exceptionModules
.
isSome
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_FORCE_MS_SIGNED_BINS
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
if
(
exceptionModules
.
isSome
(
)
)
{
result
=
InitSignedPolicyRulesToBypassCig
(
mPolicy
exceptionModules
.
ref
(
)
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Failed
to
initialize
signed
policy
rules
.
"
)
;
}
if
(
IsWin10FallCreatorsUpdateOrLater
(
)
)
{
result
=
AddWin32kLockdownPolicy
(
mPolicy
false
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Failed
to
add
the
win32k
lockdown
policy
"
)
;
}
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
if
(
IsWin10CreatorsUpdateOrLater
(
)
)
{
#
if
defined
(
_M_X64
)
&
&
!
defined
(
__MINGW64__
)
mitigations
|
=
sandbox
:
:
MITIGATION_DYNAMIC_CODE_DISABLE
;
#
endif
}
if
(
exceptionModules
.
isNothing
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_FORCE_MS_SIGNED_BINS
;
}
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
switch
(
aSandbox
)
{
case
mozilla
:
:
ipc
:
:
SandboxingKind
:
:
GENERIC_UTILITY
:
case
mozilla
:
:
ipc
:
:
SandboxingKind
:
:
UTILITY_AUDIO_DECODING
:
break
;
default
:
MOZ_ASSERT
(
false
"
Invalid
SandboxingKind
"
)
;
break
;
}
return
true
;
}
bool
SandboxBroker
:
:
SetSecurityLevelForGMPlugin
(
SandboxLevel
aLevel
bool
aIsRemoteLaunch
)
{
if
(
!
mPolicy
)
{
return
false
;
}
auto
result
=
SetJobLevel
(
mPolicy
sandbox
:
:
JOB_LOCKDOWN
0
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetJobLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
auto
level
=
(
aLevel
=
=
Restricted
)
?
sandbox
:
:
USER_RESTRICTED
:
sandbox
:
:
USER_LOCKDOWN
;
result
=
mPolicy
-
>
SetTokenLevel
(
sandbox
:
:
USER_RESTRICTED_SAME_ACCESS
level
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetTokenLevel
should
never
fail
with
these
arguments
what
happened
?
"
)
;
result
=
mPolicy
-
>
SetAlternateDesktop
(
true
)
;
if
(
NS_WARN_IF
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
)
{
LOG_W
(
"
SetAlternateDesktop
failed
result
:
%
i
last
error
:
%
lx
"
result
:
:
GetLastError
(
)
)
;
}
result
=
mPolicy
-
>
SetIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_LOW
)
;
MOZ_ASSERT
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
"
SetIntegrityLevel
should
never
fail
with
these
arguments
what
"
"
happened
?
"
)
;
result
=
mPolicy
-
>
SetDelayedIntegrityLevel
(
sandbox
:
:
INTEGRITY_LEVEL_UNTRUSTED
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
SetIntegrityLevel
should
never
fail
with
these
"
"
arguments
what
happened
?
"
)
;
mPolicy
-
>
SetLockdownDefaultDacl
(
)
;
mPolicy
-
>
AddRestrictingRandomSid
(
)
;
sandbox
:
:
MitigationFlags
mitigations
=
sandbox
:
:
MITIGATION_BOTTOM_UP_ASLR
|
sandbox
:
:
MITIGATION_HEAP_TERMINATE
|
sandbox
:
:
MITIGATION_SEHOP
|
sandbox
:
:
MITIGATION_EXTENSION_POINT_DISABLE
|
sandbox
:
:
MITIGATION_DEP_NO_ATL_THUNK
|
sandbox
:
:
MITIGATION_DEP
;
if
(
StaticPrefs
:
:
security_sandbox_gmp_shadow_stack_enabled
(
)
)
{
mitigations
|
=
sandbox
:
:
MITIGATION_CET_COMPAT_MODE
;
}
result
=
mPolicy
-
>
SetProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetProcessMitigations
.
"
)
;
if
(
StaticPrefs
:
:
security_sandbox_gmp_win32k_disable
(
)
&
&
IsWin10OrLater
(
)
)
{
result
=
AddWin32kLockdownPolicy
(
mPolicy
true
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Failed
to
add
the
win32k
lockdown
policy
"
)
;
}
mitigations
=
sandbox
:
:
MITIGATION_STRICT_HANDLE_CHECKS
|
sandbox
:
:
MITIGATION_DLL_SEARCH_ORDER
;
result
=
mPolicy
-
>
SetDelayedProcessMitigations
(
mitigations
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
Invalid
flags
for
SetDelayedProcessMitigations
.
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
chrome
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_ANY
L
"
\
\
?
?
\
\
pipe
\
\
gecko
-
crash
-
server
-
pipe
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
#
ifdef
DEBUG
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_SYNC
sandbox
:
:
TargetPolicy
:
:
EVENTS_ALLOW_ANY
L
"
ChromeIPCLog
.
*
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
#
endif
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
Control
Panel
\
\
Desktop
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
Control
Panel
\
\
Desktop
\
\
LanguageConfiguration
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_
"
L
"
MACHINE
\
\
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
SideBySide
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_MACHINE
\
\
SOFTWARE
\
\
Policies
\
\
Microsoft
\
\
MUI
\
\
Settings
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
Software
\
\
Policies
\
\
Microsoft
\
\
Control
"
L
"
Panel
\
\
Desktop
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
Control
Panel
\
\
Desktop
\
\
PreferredUILanguages
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_
"
L
"
MACHINE
\
\
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVer
"
L
"
sion
\
\
SideBySide
\
\
PreferExternalManifest
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
L
"
\
\
Device
\
\
SrpDevice
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_MACHINE
\
\
System
\
\
CurrentControlSet
\
\
Control
\
\
Srp
\
\
GP
\
\
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_LOCAL_MACHINE
\
\
System
\
\
CurrentControlSet
\
\
Control
\
\
Srp
\
\
\
\
GP
\
\
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
aIsRemoteLaunch
?
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_ANY
:
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
Section
"
)
;
SANDBOX_ENSURE_SUCCESS
(
result
"
With
these
static
arguments
AddRule
should
never
fail
what
happened
?
"
)
;
return
true
;
}
#
undef
SANDBOX_ENSURE_SUCCESS
bool
SandboxBroker
:
:
AllowReadFile
(
wchar_t
const
*
file
)
{
if
(
!
mPolicy
)
{
return
false
;
}
auto
result
=
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_FILES
sandbox
:
:
TargetPolicy
:
:
FILES_ALLOW_READONLY
file
)
;
if
(
sandbox
:
:
SBOX_ALL_OK
!
=
result
)
{
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
file
)
;
return
false
;
}
return
true
;
}
bool
SandboxBroker
:
:
AddTargetPeer
(
HANDLE
aPeerProcess
)
{
if
(
!
sBrokerService
)
{
return
false
;
}
sandbox
:
:
ResultCode
result
=
sBrokerService
-
>
AddTargetPeer
(
aPeerProcess
)
;
return
(
sandbox
:
:
SBOX_ALL_OK
=
=
result
)
;
}
void
SandboxBroker
:
:
AddHandleToShare
(
HANDLE
aHandle
)
{
mPolicy
-
>
AddHandleToShare
(
aHandle
)
;
}
bool
SandboxBroker
:
:
IsWin32kLockedDown
(
)
{
return
mPolicy
-
>
GetProcessMitigations
(
)
&
sandbox
:
:
MITIGATION_WIN32K_DISABLE
;
}
void
SandboxBroker
:
:
ApplyLoggingPolicy
(
)
{
MOZ_ASSERT
(
mPolicy
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_NAMED_PIPES
sandbox
:
:
TargetPolicy
:
:
NAMEDPIPES_ALLOW_ANY
L
"
dummy
"
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_PROCESS
sandbox
:
:
TargetPolicy
:
:
PROCESS_MIN_EXEC
L
"
dummy
"
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_REGISTRY
sandbox
:
:
TargetPolicy
:
:
REG_ALLOW_READONLY
L
"
HKEY_CURRENT_USER
\
\
dummy
"
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_SYNC
sandbox
:
:
TargetPolicy
:
:
EVENTS_ALLOW_READONLY
L
"
dummy
"
)
;
mPolicy
-
>
AddRule
(
sandbox
:
:
TargetPolicy
:
:
SUBSYS_HANDLES
sandbox
:
:
TargetPolicy
:
:
HANDLES_DUP_BROKER
L
"
dummy
"
)
;
}
SandboxBroker
:
:
~
SandboxBroker
(
)
{
if
(
mPolicy
)
{
mPolicy
-
>
Release
(
)
;
mPolicy
=
nullptr
;
}
}
#
ifdef
_ARM64_
extern
AbstractSandboxBroker
*
CreateRemoteSandboxBroker
(
)
;
#
endif
AbstractSandboxBroker
*
AbstractSandboxBroker
:
:
Create
(
GeckoProcessType
aProcessType
)
{
#
ifdef
_ARM64_
if
(
aProcessType
=
=
GeckoProcessType_GMPlugin
)
{
return
CreateRemoteSandboxBroker
(
)
;
}
#
endif
return
new
SandboxBroker
(
)
;
}
}
