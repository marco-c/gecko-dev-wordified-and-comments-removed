#
include
"
ConfigHelpers
.
h
"
#
include
<
windows
.
h
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
sandbox
/
win
/
src
/
policy_engine_opcodes
.
h
"
namespace
mozilla
{
extern
LazyLogModule
sSandboxBrokerLog
;
#
define
LOG_E
(
.
.
.
)
MOZ_LOG
(
sSandboxBrokerLog
LogLevel
:
:
Error
(
__VA_ARGS__
)
)
#
define
LOG_W
(
.
.
.
)
MOZ_LOG
(
sSandboxBrokerLog
LogLevel
:
:
Warning
(
__VA_ARGS__
)
)
namespace
sandboxing
{
SizeTrackingConfig
:
:
SizeTrackingConfig
(
sandbox
:
:
TargetConfig
*
aConfig
int32_t
aStoragePages
)
:
mConfig
(
aConfig
)
{
MOZ_ASSERT
(
mConfig
)
;
MOZ_ASSERT
(
aStoragePages
>
0
)
;
MOZ_ASSERT
(
static_cast
<
size_t
>
(
aStoragePages
)
<
sandbox
:
:
kPolMemPageCount
)
;
constexpr
int32_t
kOneMemPage
=
4096
;
mRemainingSize
=
kOneMemPage
*
aStoragePages
;
}
sandbox
:
:
ResultCode
SizeTrackingConfig
:
:
AllowFileAccess
(
sandbox
:
:
FileSemantics
aSemantics
const
wchar_t
*
aPattern
)
{
auto
patternRuleSize
=
(
wcslen
(
aPattern
)
+
4
)
*
sizeof
(
wchar_t
)
;
int32_t
requiredSize
;
constexpr
auto
opcodeSize
=
sizeof
(
sandbox
:
:
PolicyOpcode
)
;
switch
(
aSemantics
)
{
case
sandbox
:
:
FileSemantics
:
:
kAllowAny
:
requiredSize
=
(
patternRuleSize
*
5
)
+
(
opcodeSize
*
10
)
;
break
;
case
sandbox
:
:
FileSemantics
:
:
kAllowReadonly
:
requiredSize
=
(
patternRuleSize
*
4
)
+
(
opcodeSize
*
12
)
;
break
;
case
sandbox
:
:
FileSemantics
:
:
kAllowQuery
:
requiredSize
=
(
patternRuleSize
*
2
)
+
(
opcodeSize
*
4
)
;
break
;
default
:
MOZ_CRASH
(
"
Unknown
FileSemantics
"
)
;
}
if
(
requiredSize
>
mRemainingSize
)
{
return
sandbox
:
:
SBOX_ERROR_NO_SPACE
;
}
mRemainingSize
-
=
requiredSize
;
return
mConfig
-
>
AllowFileAccess
(
aSemantics
aPattern
)
;
}
UserFontConfigHelper
:
:
UserFontConfigHelper
(
const
wchar_t
*
aUserFontKeyPath
const
nsString
&
aWinUserProfile
const
nsString
&
aLocalAppData
const
nsString
&
aRoamingAppData
)
:
mWinUserProfile
(
aWinUserProfile
)
mLocalAppData
(
aLocalAppData
)
mRoamingAppData
(
aRoamingAppData
)
{
LSTATUS
lStatus
=
:
:
RegOpenKeyExW
(
HKEY_CURRENT_USER
aUserFontKeyPath
0
KEY_QUERY_VALUE
|
KEY_ENUMERATE_SUB_KEYS
&
mUserFontKey
)
;
if
(
lStatus
!
=
ERROR_SUCCESS
)
{
mUserFontKey
=
nullptr
;
}
}
UserFontConfigHelper
:
:
~
UserFontConfigHelper
(
)
{
if
(
mUserFontKey
)
{
:
:
RegCloseKey
(
mUserFontKey
)
;
}
}
static
auto
AddRulesForKey
(
HKEY
aFontKey
const
nsAString
&
aWindowsUserFontDir
const
nsAString
&
aWinUserProfile
SizeTrackingConfig
&
aConfig
Vector
<
nsString
>
&
aNonUserDirFonts
)
{
for
(
DWORD
valueIndex
=
0
;
;
+
+
valueIndex
)
{
DWORD
keyType
;
wchar_t
name
[
1024
]
;
wchar_t
data
[
2048
]
;
auto
*
dataAsBytes
=
reinterpret_cast
<
LPBYTE
>
(
data
)
;
DWORD
nameLength
=
std
:
:
size
(
name
)
;
DWORD
dataSizeInBytes
=
sizeof
(
data
)
-
sizeof
(
wchar_t
)
;
LSTATUS
lStatus
=
:
:
RegEnumValueW
(
aFontKey
valueIndex
name
&
nameLength
NULL
&
keyType
dataAsBytes
&
dataSizeInBytes
)
;
if
(
lStatus
=
=
ERROR_NO_MORE_ITEMS
)
{
break
;
}
if
(
lStatus
!
=
ERROR_SUCCESS
)
{
continue
;
}
if
(
keyType
!
=
REG_SZ
)
{
continue
;
}
auto
dataSizeInWChars
=
dataSizeInBytes
/
sizeof
(
wchar_t
)
;
if
(
dataSizeInWChars
<
2
)
{
continue
;
}
if
(
data
[
dataSizeInWChars
-
1
]
=
=
L
'
\
0
'
)
{
-
-
dataSizeInWChars
;
}
else
{
data
[
dataSizeInWChars
]
=
L
'
\
0
'
;
}
if
(
data
[
dataSizeInWChars
-
1
]
=
=
L
'
\
\
'
)
{
continue
;
}
if
(
dataSizeInWChars
<
aWinUserProfile
.
Length
(
)
|
|
!
aWinUserProfile
.
Equals
(
nsDependentSubstring
(
data
aWinUserProfile
.
Length
(
)
)
nsCaseInsensitiveStringComparator
)
)
{
(
void
)
aNonUserDirFonts
.
emplaceBack
(
data
dataSizeInWChars
)
;
continue
;
}
if
(
dataSizeInWChars
>
aWindowsUserFontDir
.
Length
(
)
&
&
aWindowsUserFontDir
.
Equals
(
nsDependentSubstring
(
data
aWindowsUserFontDir
.
Length
(
)
)
nsCaseInsensitiveStringComparator
)
)
{
continue
;
}
auto
result
=
aConfig
.
AllowFileAccess
(
sandbox
:
:
FileSemantics
:
:
kAllowReadonly
data
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
NS_WARNING
(
"
Failed
to
add
specific
user
font
policy
rule
.
"
)
;
LOG_W
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
data
)
;
if
(
result
=
=
sandbox
:
:
SBOX_ERROR_NO_SPACE
)
{
return
result
;
}
}
}
for
(
DWORD
keyIndex
=
0
;
;
+
+
keyIndex
)
{
wchar_t
name
[
1024
]
;
DWORD
nameLength
=
std
:
:
size
(
name
)
;
LSTATUS
lStatus
=
:
:
RegEnumKeyExW
(
aFontKey
keyIndex
name
&
nameLength
nullptr
nullptr
nullptr
nullptr
)
;
if
(
lStatus
=
=
ERROR_NO_MORE_ITEMS
)
{
break
;
}
if
(
lStatus
!
=
ERROR_SUCCESS
)
{
continue
;
}
std
:
:
unique_ptr
<
HKEY
RegCloseKeyDeleter
>
subKey
;
lStatus
=
:
:
RegOpenKeyExW
(
aFontKey
name
0
KEY_QUERY_VALUE
|
KEY_ENUMERATE_SUB_KEYS
getter_Transfers
(
subKey
)
)
;
if
(
lStatus
!
=
ERROR_SUCCESS
)
{
continue
;
}
auto
result
=
AddRulesForKey
(
subKey
.
get
(
)
aWindowsUserFontDir
aWinUserProfile
aConfig
aNonUserDirFonts
)
;
if
(
result
=
=
sandbox
:
:
SBOX_ERROR_NO_SPACE
)
{
return
result
;
}
}
return
sandbox
:
:
SBOX_ALL_OK
;
}
void
UserFontConfigHelper
:
:
AddRules
(
SizeTrackingConfig
&
aConfig
)
const
{
nsAutoString
windowsUserFontDir
(
mLocalAppData
)
;
windowsUserFontDir
+
=
uR
"
(
\
Microsoft
\
Windows
\
Fonts
\
*
)
"
_ns
;
auto
result
=
aConfig
.
AllowFileAccess
(
sandbox
:
:
FileSemantics
:
:
kAllowReadonly
windowsUserFontDir
.
getW
(
)
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
NS_ERROR
(
"
Failed
to
add
Windows
user
font
dir
policy
rule
.
"
)
;
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
windowsUserFontDir
.
getW
(
)
)
;
}
nsAutoString
adobeLiveTypeFonts
(
mRoamingAppData
)
;
adobeLiveTypeFonts
+
=
uR
"
(
\
ADOBE
\
CORESYNC
\
PLUGINS
\
LIVETYPE
\
R
\
*
)
"
_ns
;
result
=
aConfig
.
AllowFileAccess
(
sandbox
:
:
FileSemantics
:
:
kAllowReadonly
adobeLiveTypeFonts
.
getW
(
)
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
NS_ERROR
(
"
Failed
to
add
Adobe
LiveType
font
dir
policy
rule
.
"
)
;
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
adobeLiveTypeFonts
.
getW
(
)
)
;
}
nsAutoString
adobeUserOwnedFonts
(
mRoamingAppData
)
;
adobeUserOwnedFonts
+
=
uR
"
(
\
ADOBE
\
USER
OWNED
FONTS
\
*
)
"
_ns
;
result
=
aConfig
.
AllowFileAccess
(
sandbox
:
:
FileSemantics
:
:
kAllowReadonly
adobeUserOwnedFonts
.
getW
(
)
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
NS_ERROR
(
"
Failed
to
add
Adobe
user
owned
font
dir
policy
rule
.
"
)
;
LOG_E
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
adobeUserOwnedFonts
.
getW
(
)
)
;
}
if
(
!
mUserFontKey
)
{
return
;
}
windowsUserFontDir
.
SetLength
(
windowsUserFontDir
.
Length
(
)
-
1
)
;
nsAutoString
winUserProfile
(
mWinUserProfile
)
;
winUserProfile
+
=
L
'
\
\
'
;
Vector
<
nsString
>
nonUserDirFonts
;
result
=
AddRulesForKey
(
mUserFontKey
windowsUserFontDir
winUserProfile
aConfig
nonUserDirFonts
)
;
if
(
result
=
=
sandbox
:
:
SBOX_ERROR_NO_SPACE
)
{
CrashReporter
:
:
RecordAnnotationCString
(
CrashReporter
:
:
Annotation
:
:
UserFontRulesExhausted
"
inside
"
)
;
return
;
}
for
(
const
auto
&
fontPath
:
nonUserDirFonts
)
{
result
=
aConfig
.
AllowFileAccess
(
sandbox
:
:
FileSemantics
:
:
kAllowReadonly
fontPath
.
getW
(
)
)
;
if
(
result
!
=
sandbox
:
:
SBOX_ALL_OK
)
{
NS_WARNING
(
"
Failed
to
add
specific
user
font
policy
rule
.
"
)
;
LOG_W
(
"
Failed
(
ResultCode
%
d
)
to
add
read
access
to
:
%
S
"
result
fontPath
.
getW
(
)
)
;
if
(
result
=
=
sandbox
:
:
SBOX_ERROR_NO_SPACE
)
{
CrashReporter
:
:
RecordAnnotationCString
(
CrashReporter
:
:
Annotation
:
:
UserFontRulesExhausted
"
outside
"
)
;
return
;
}
}
}
}
}
}
