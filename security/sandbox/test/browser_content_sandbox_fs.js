"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
+
"
security
/
sandbox
/
test
/
browser_content_sandbox_utils
.
js
"
this
)
;
function
createFile
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
encoder
=
new
TextEncoder
(
)
;
let
array
=
encoder
.
encode
(
"
TEST
FILE
DUMMY
DATA
"
)
;
return
OS
.
File
.
writeAtomic
(
path
array
)
.
then
(
function
(
value
)
{
return
true
;
}
function
(
reason
)
{
return
false
;
}
)
;
}
function
createSymlink
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
return
OS
.
File
.
unixSymLink
(
"
/
Users
"
path
)
.
then
(
function
(
value
)
{
return
true
;
}
function
(
reason
)
{
return
false
;
}
)
;
}
function
deleteFile
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
return
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
false
}
)
.
then
(
function
(
value
)
{
return
true
;
}
)
.
catch
(
function
(
err
)
{
return
false
;
}
)
;
}
function
readDir
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
numEntries
=
0
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
path
)
;
let
promise
=
iterator
.
forEach
(
function
(
dirEntry
)
{
numEntries
+
+
;
}
)
.
then
(
function
(
)
{
iterator
.
close
(
)
;
return
{
ok
:
true
numEntries
}
;
}
)
.
catch
(
function
(
)
{
return
{
ok
:
false
numEntries
}
;
}
)
;
return
promise
;
}
function
readFile
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
promise
=
OS
.
File
.
read
(
path
)
.
then
(
function
(
binaryData
)
{
return
{
ok
:
true
}
;
}
)
.
catch
(
function
(
error
)
{
return
{
ok
:
false
}
;
}
)
;
return
promise
;
}
function
statPath
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
promise
=
OS
.
File
.
stat
(
path
)
.
then
(
function
(
stat
)
{
return
{
ok
:
true
}
;
}
)
.
catch
(
function
(
error
)
{
return
{
ok
:
false
}
;
}
)
;
return
promise
;
}
function
isContentFileIOSandboxed
(
level
)
{
let
fileIOSandboxMinLevel
=
0
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
fileIOSandboxMinLevel
=
1
;
break
;
case
"
Darwin
"
:
fileIOSandboxMinLevel
=
1
;
break
;
case
"
Linux
"
:
fileIOSandboxMinLevel
=
2
;
break
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
}
return
level
>
=
fileIOSandboxMinLevel
;
}
function
minProfileReadSandboxLevel
(
level
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
3
;
case
"
Darwin
"
:
return
2
;
case
"
Linux
"
:
return
3
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
return
0
;
}
}
function
minHomeReadSandboxLevel
(
level
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
3
;
case
"
Darwin
"
:
return
3
;
case
"
Linux
"
:
return
3
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
return
0
;
}
}
add_task
(
async
function
(
)
{
if
(
!
gMultiProcessBrowser
)
{
ok
(
false
"
e10s
is
enabled
"
)
;
info
(
"
e10s
is
not
enabled
exiting
"
)
;
return
;
}
let
level
=
0
;
let
prefExists
=
true
;
try
{
level
=
Services
.
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
}
catch
(
e
)
{
prefExists
=
false
;
}
ok
(
prefExists
"
pref
security
.
sandbox
.
content
.
level
exists
"
)
;
if
(
!
prefExists
)
{
return
;
}
info
(
security
.
sandbox
.
content
.
level
=
{
level
}
)
;
ok
(
level
>
0
"
content
sandbox
is
enabled
.
"
)
;
let
isFileIOSandboxed
=
isContentFileIOSandboxed
(
level
)
;
ok
(
isFileIOSandboxed
"
content
file
I
/
O
sandboxing
is
enabled
.
"
)
;
if
(
!
isFileIOSandboxed
)
{
info
(
"
content
sandbox
level
too
low
for
file
I
/
O
tests
exiting
\
n
"
)
;
return
;
}
add_task
(
createFileInHome
)
;
add_task
(
createTempFile
)
;
add_task
(
testFileAccess
)
;
}
)
;
async
function
createFileInHome
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
let
homeFile
=
fileInHomeDir
(
)
;
let
path
=
homeFile
.
path
;
let
fileCreated
=
await
SpecialPowers
.
spawn
(
browser
[
path
]
createFile
)
;
ok
(
!
fileCreated
"
creating
a
file
in
home
dir
is
not
permitted
"
)
;
if
(
fileCreated
)
{
homeFile
.
remove
(
false
)
;
}
}
async
function
createTempFile
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
let
path
=
fileInTempDir
(
)
.
path
;
let
fileCreated
=
await
SpecialPowers
.
spawn
(
browser
[
path
]
createFile
)
;
if
(
isMac
(
)
)
{
ok
(
!
fileCreated
"
creating
a
file
in
content
temp
is
not
permitted
"
)
;
}
else
{
ok
(
!
!
fileCreated
"
creating
a
file
in
content
temp
is
permitted
"
)
;
}
let
fileDeleted
=
await
SpecialPowers
.
spawn
(
browser
[
path
]
deleteFile
)
;
if
(
isMac
(
)
)
{
ok
(
!
fileDeleted
"
deleting
a
file
in
content
temp
is
not
permitted
"
)
;
let
path
=
fileInTempDir
(
)
.
path
;
let
symlinkCreated
=
await
SpecialPowers
.
spawn
(
browser
[
path
]
createSymlink
)
;
ok
(
!
symlinkCreated
"
created
a
symlink
in
content
temp
is
not
permitted
"
)
;
}
else
{
ok
(
!
!
fileDeleted
"
deleting
a
file
in
content
temp
is
permitted
"
)
;
}
}
async
function
testFileAccess
(
)
{
let
webBrowser
=
gBrowser
.
selectedBrowser
;
let
fileContentProcessEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
remote
.
separateFileUriProcess
"
)
;
ok
(
fileContentProcessEnabled
"
separate
file
content
process
is
enabled
"
)
;
let
fileBrowser
=
undefined
;
if
(
fileContentProcessEnabled
)
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
{
preferredRemoteType
:
"
file
"
}
)
;
fileBrowser
=
gBrowser
.
getBrowserForTab
(
gBrowser
.
selectedTab
)
;
}
let
level
=
Services
.
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
let
tests
=
[
]
;
let
profileDir
=
GetProfileDir
(
)
;
tests
.
push
(
{
desc
:
"
profile
dir
"
ok
:
false
browser
:
webBrowser
file
:
profileDir
minLevel
:
minProfileReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
"
profile
dir
"
ok
:
true
browser
:
fileBrowser
file
:
profileDir
minLevel
:
0
func
:
readDir
}
)
;
}
let
homeDir
=
GetHomeDir
(
)
;
tests
.
push
(
{
desc
:
"
home
dir
"
ok
:
false
browser
:
webBrowser
file
:
homeDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
"
home
dir
"
ok
:
true
browser
:
fileBrowser
file
:
homeDir
minLevel
:
0
func
:
readDir
}
)
;
}
let
sysExtDevDir
=
GetSystemExtensionsDevDir
(
)
;
tests
.
push
(
{
desc
:
"
system
extensions
dev
dir
"
ok
:
true
browser
:
webBrowser
file
:
sysExtDevDir
minLevel
:
0
func
:
readDir
}
)
;
if
(
isWin
(
)
)
{
let
extDir
=
GetPerUserExtensionDir
(
)
;
tests
.
push
(
{
desc
:
"
per
-
user
extensions
dir
"
ok
:
true
browser
:
webBrowser
file
:
extDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
}
if
(
isMac
(
)
)
{
let
homeTempDir
=
GetHomeDir
(
)
;
homeTempDir
.
appendRelativePath
(
"
Library
/
Caches
/
TemporaryItems
"
)
;
if
(
homeTempDir
.
exists
(
)
)
{
let
shouldBeReadable
minLevel
;
if
(
level
>
=
minHomeReadSandboxLevel
(
)
)
{
shouldBeReadable
=
false
;
minLevel
=
minHomeReadSandboxLevel
(
)
;
}
else
{
shouldBeReadable
=
true
;
minLevel
=
0
;
}
tests
.
push
(
{
desc
:
"
home
library
cache
temp
dir
"
ok
:
shouldBeReadable
browser
:
webBrowser
file
:
homeTempDir
minLevel
func
:
readDir
}
)
;
}
}
if
(
isMac
(
)
|
|
isLinux
(
)
)
{
let
varDir
=
GetDir
(
"
/
var
"
)
;
if
(
isMac
(
)
)
{
varDir
.
normalize
(
)
;
Assert
.
ok
(
varDir
.
path
=
=
=
"
/
private
/
var
"
"
/
var
resolves
to
/
private
/
var
"
)
;
}
tests
.
push
(
{
desc
:
"
/
var
"
ok
:
false
browser
:
webBrowser
file
:
varDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
"
/
var
"
ok
:
true
browser
:
fileBrowser
file
:
varDir
minLevel
:
0
func
:
readDir
}
)
;
}
}
if
(
isLinux
(
)
)
{
let
selfFdDir
=
GetDir
(
"
/
proc
/
self
/
fd
"
)
;
tests
.
push
(
{
desc
:
"
/
proc
/
self
/
fd
"
ok
:
false
browser
:
webBrowser
file
:
selfFdDir
minLevel
:
isContentFileIOSandboxed
(
)
func
:
readDir
}
)
;
}
if
(
isMac
(
)
)
{
let
macTempDir
=
GetDirFromEnvVariable
(
"
TMPDIR
"
)
;
macTempDir
.
normalize
(
)
;
Assert
.
ok
(
macTempDir
.
path
.
startsWith
(
"
/
private
/
var
"
)
"
TMPDIR
is
in
/
private
/
var
"
)
;
tests
.
push
(
{
desc
:
TMPDIR
(
{
macTempDir
.
path
}
)
ok
:
false
browser
:
webBrowser
file
:
macTempDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
TMPDIR
(
{
macTempDir
.
path
}
)
ok
:
true
browser
:
fileBrowser
file
:
macTempDir
minLevel
:
0
func
:
readDir
}
)
;
}
let
fontRegistryDir
=
macTempDir
.
parent
.
clone
(
)
;
fontRegistryDir
.
appendRelativePath
(
"
C
/
com
.
apple
.
FontRegistry
"
)
;
Assert
.
ok
(
fontRegistryDir
.
exists
(
)
{
fontRegistryDir
.
path
}
exists
)
;
if
(
fontRegistryDir
.
exists
(
)
)
{
tests
.
push
(
{
desc
:
FontRegistry
(
{
fontRegistryDir
.
path
}
)
ok
:
true
browser
:
webBrowser
file
:
fontRegistryDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
let
fontFile
=
fontRegistryDir
.
clone
(
)
;
fontFile
.
appendRelativePath
(
"
font
"
)
;
Assert
.
ok
(
fontFile
.
exists
(
)
{
fontFile
.
path
}
exists
)
;
if
(
fontFile
.
exists
(
)
)
{
tests
.
push
(
{
desc
:
FontRegistry
file
(
{
fontFile
.
path
}
)
ok
:
true
browser
:
webBrowser
file
:
fontFile
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readFile
}
)
;
}
}
let
volumes
=
GetDir
(
"
/
Volumes
"
)
;
tests
.
push
(
{
desc
:
"
/
Volumes
"
ok
:
false
browser
:
webBrowser
file
:
volumes
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
AppConstants
.
isPlatformAndVersionAtMost
(
"
macosx
"
18
)
)
{
let
network
=
GetDir
(
"
/
Network
"
)
;
tests
.
push
(
{
desc
:
"
/
Network
"
ok
:
false
browser
:
webBrowser
file
:
network
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
}
let
users
=
GetDir
(
"
/
Users
"
)
;
tests
.
push
(
{
desc
:
"
/
Users
"
ok
:
false
browser
:
webBrowser
file
:
users
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
tests
.
push
(
{
desc
:
"
/
Users
"
ok
:
true
browser
:
webBrowser
file
:
users
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
statPath
}
)
;
let
libraryDir
=
GetDir
(
"
/
Library
"
)
;
tests
.
push
(
{
desc
:
"
/
Library
"
ok
:
true
browser
:
webBrowser
file
:
libraryDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
statPath
}
)
;
tests
.
push
(
{
desc
:
"
/
Library
"
ok
:
false
browser
:
webBrowser
file
:
libraryDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
let
privateDir
=
GetDir
(
"
/
private
"
)
;
tests
.
push
(
{
desc
:
"
/
private
"
ok
:
true
browser
:
webBrowser
file
:
privateDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
statPath
}
)
;
}
let
extensionsDir
=
GetProfileEntry
(
"
extensions
"
)
;
if
(
extensionsDir
.
exists
(
)
&
&
extensionsDir
.
isDirectory
(
)
)
{
tests
.
push
(
{
desc
:
"
extensions
dir
"
ok
:
true
browser
:
webBrowser
file
:
extensionsDir
minLevel
:
0
func
:
readDir
}
)
;
}
else
{
ok
(
false
{
extensionsDir
.
path
}
is
a
valid
dir
)
;
}
let
chromeDir
=
GetProfileEntry
(
"
chrome
"
)
;
if
(
chromeDir
.
exists
(
)
&
&
chromeDir
.
isDirectory
(
)
)
{
tests
.
push
(
{
desc
:
"
chrome
dir
"
ok
:
true
browser
:
webBrowser
file
:
chromeDir
minLevel
:
0
func
:
readDir
}
)
;
}
else
{
ok
(
false
{
chromeDir
.
path
}
is
valid
dir
)
;
}
let
cookiesFile
=
GetProfileEntry
(
"
cookies
.
sqlite
"
)
;
if
(
cookiesFile
.
exists
(
)
&
&
!
cookiesFile
.
isDirectory
(
)
)
{
tests
.
push
(
{
desc
:
"
cookies
file
"
ok
:
false
browser
:
webBrowser
file
:
cookiesFile
minLevel
:
minProfileReadSandboxLevel
(
)
func
:
readFile
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
"
cookies
file
"
ok
:
true
browser
:
fileBrowser
file
:
cookiesFile
minLevel
:
0
func
:
readFile
}
)
;
}
}
else
{
ok
(
false
{
cookiesFile
.
path
}
is
a
valid
file
)
;
}
tests
=
tests
.
filter
(
test
=
>
test
.
minLevel
<
=
level
)
;
for
(
let
test
of
tests
)
{
let
okString
=
test
.
ok
?
"
allowed
"
:
"
blocked
"
;
let
processType
=
test
.
browser
=
=
=
webBrowser
?
"
web
"
:
"
file
"
;
if
(
test
.
func
=
=
=
statPath
)
{
ok
(
test
.
file
.
exists
(
)
{
test
.
file
.
path
}
exists
)
;
}
let
result
=
await
ContentTask
.
spawn
(
test
.
browser
test
.
file
.
path
test
.
func
)
;
ok
(
result
.
ok
=
=
test
.
ok
reading
{
test
.
desc
}
from
a
{
processType
}
process
+
is
{
okString
}
(
{
test
.
file
.
path
}
)
)
;
if
(
test
.
func
=
=
=
readDir
&
&
!
test
.
ok
)
{
ok
(
result
.
numEntries
=
=
0
directory
list
is
empty
(
{
test
.
file
.
path
}
)
)
;
}
}
if
(
fileContentProcessEnabled
)
{
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
}
