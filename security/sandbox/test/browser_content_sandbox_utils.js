"
use
strict
"
;
const
uuidGenerator
=
Services
.
uuid
;
const
environment
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
function
sanityChecks
(
)
{
if
(
!
gMultiProcessBrowser
)
{
ok
(
false
"
e10s
is
enabled
"
)
;
info
(
"
e10s
is
not
enabled
exiting
"
)
;
return
;
}
let
level
=
0
;
let
prefExists
=
true
;
try
{
level
=
Services
.
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
}
catch
(
e
)
{
prefExists
=
false
;
}
ok
(
prefExists
"
pref
security
.
sandbox
.
content
.
level
exists
"
)
;
if
(
!
prefExists
)
{
return
;
}
info
(
security
.
sandbox
.
content
.
level
=
{
level
}
)
;
ok
(
level
>
0
"
content
sandbox
is
enabled
.
"
)
;
let
isFileIOSandboxed
=
isContentFileIOSandboxed
(
level
)
;
ok
(
isFileIOSandboxed
"
content
file
I
/
O
sandboxing
is
enabled
.
"
)
;
if
(
!
isFileIOSandboxed
)
{
info
(
"
content
sandbox
level
too
low
for
file
I
/
O
tests
exiting
\
n
"
)
;
}
}
function
createFile
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
encoder
=
new
TextEncoder
(
)
;
let
array
=
encoder
.
encode
(
"
TEST
FILE
DUMMY
DATA
"
)
;
return
OS
.
File
.
writeAtomic
(
path
array
)
.
then
(
function
(
value
)
{
return
{
ok
:
true
}
;
}
function
(
reason
)
{
return
{
ok
:
false
}
;
}
)
;
}
function
createSymlink
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
return
OS
.
File
.
unixSymLink
(
"
/
Users
"
path
)
.
then
(
function
(
value
)
{
return
{
ok
:
true
}
;
}
function
(
reason
)
{
return
{
ok
:
false
}
;
}
)
;
}
function
deleteFile
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
return
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
false
}
)
.
then
(
function
(
value
)
{
return
{
ok
:
true
}
;
}
)
.
catch
(
function
(
err
)
{
return
{
ok
:
false
}
;
}
)
;
}
function
readDir
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
numEntries
=
0
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
path
)
;
let
promise
=
iterator
.
forEach
(
function
(
dirEntry
)
{
numEntries
+
+
;
}
)
.
then
(
function
(
)
{
iterator
.
close
(
)
;
return
{
ok
:
true
numEntries
}
;
}
)
.
catch
(
function
(
)
{
return
{
ok
:
false
numEntries
}
;
}
)
;
return
promise
;
}
function
readFile
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
promise
=
OS
.
File
.
read
(
path
)
.
then
(
function
(
binaryData
)
{
return
{
ok
:
true
}
;
}
)
.
catch
(
function
(
error
)
{
return
{
ok
:
false
}
;
}
)
;
return
promise
;
}
function
statPath
(
path
)
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
let
promise
=
OS
.
File
.
stat
(
path
)
.
then
(
function
(
stat
)
{
return
{
ok
:
true
}
;
}
)
.
catch
(
function
(
error
)
{
return
{
ok
:
false
}
;
}
)
;
return
promise
;
}
function
isContentFileIOSandboxed
(
level
)
{
let
fileIOSandboxMinLevel
=
0
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
fileIOSandboxMinLevel
=
1
;
break
;
case
"
Darwin
"
:
fileIOSandboxMinLevel
=
1
;
break
;
case
"
Linux
"
:
fileIOSandboxMinLevel
=
2
;
break
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
}
return
level
>
=
fileIOSandboxMinLevel
;
}
function
minProfileReadSandboxLevel
(
level
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
3
;
case
"
Darwin
"
:
return
2
;
case
"
Linux
"
:
return
3
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
return
0
;
}
}
function
minHomeReadSandboxLevel
(
level
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
3
;
case
"
Darwin
"
:
return
3
;
case
"
Linux
"
:
return
3
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
return
0
;
}
}
function
isMac
(
)
{
return
Services
.
appinfo
.
OS
=
=
"
Darwin
"
;
}
function
isWin
(
)
{
return
Services
.
appinfo
.
OS
=
=
"
WINNT
"
;
}
function
isLinux
(
)
{
return
Services
.
appinfo
.
OS
=
=
"
Linux
"
;
}
function
isNightly
(
)
{
let
version
=
SpecialPowers
.
Services
.
appinfo
.
version
;
return
version
.
endsWith
(
"
a1
"
)
;
}
function
uuid
(
)
{
return
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
}
function
fileInHomeDir
(
)
{
let
homeDir
=
Services
.
dirsvc
.
get
(
"
Home
"
Ci
.
nsIFile
)
;
Assert
.
ok
(
homeDir
.
exists
(
)
"
Home
dir
exists
"
)
;
Assert
.
ok
(
homeDir
.
isDirectory
(
)
"
Home
dir
is
a
directory
"
)
;
let
homeFile
=
homeDir
.
clone
(
)
;
homeFile
.
appendRelativePath
(
uuid
(
)
)
;
Assert
.
ok
(
!
homeFile
.
exists
(
)
homeFile
.
path
+
"
does
not
exist
"
)
;
return
homeFile
;
}
function
fileInTempDir
(
)
{
let
contentTempKey
=
"
ContentTmpD
"
;
let
ctmp
=
Services
.
dirsvc
.
get
(
contentTempKey
Ci
.
nsIFile
)
;
Assert
.
ok
(
ctmp
.
exists
(
)
"
Content
temp
dir
exists
"
)
;
Assert
.
ok
(
ctmp
.
isDirectory
(
)
"
Content
temp
dir
is
a
directory
"
)
;
let
tempFile
=
ctmp
.
clone
(
)
;
tempFile
.
appendRelativePath
(
uuid
(
)
)
;
Assert
.
ok
(
!
tempFile
.
exists
(
)
tempFile
.
path
+
"
does
not
exist
"
)
;
return
tempFile
;
}
function
GetProfileDir
(
)
{
let
profileDir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
return
profileDir
;
}
function
GetHomeDir
(
)
{
let
homeDir
=
Services
.
dirsvc
.
get
(
"
Home
"
Ci
.
nsIFile
)
;
return
homeDir
;
}
function
GetHomeSubdir
(
subdir
)
{
return
GetSubdir
(
GetHomeDir
(
)
subdir
)
;
}
function
GetHomeSubdirFile
(
subdir
)
{
return
GetSubdirFile
(
GetHomeSubdir
(
subdir
)
)
;
}
function
GetSubdir
(
dir
subdir
)
{
let
newSubdir
=
dir
.
clone
(
)
;
newSubdir
.
appendRelativePath
(
subdir
)
;
return
newSubdir
;
}
function
GetSubdirFile
(
dir
)
{
let
newFile
=
dir
.
clone
(
)
;
newFile
.
appendRelativePath
(
uuid
(
)
)
;
return
newFile
;
}
function
GetPerUserExtensionDir
(
)
{
return
Services
.
dirsvc
.
get
(
"
XREUSysExt
"
Ci
.
nsIFile
)
;
}
function
GetProfileEntry
(
name
)
{
let
entry
=
GetProfileDir
(
)
;
entry
.
append
(
name
)
;
return
entry
;
}
function
GetDir
(
path
)
{
let
dir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
dir
.
initWithPath
(
path
)
;
Assert
.
ok
(
dir
.
isDirectory
(
)
{
path
}
is
a
directory
)
;
return
dir
;
}
function
GetDirFromEnvVariable
(
varName
)
{
return
GetDir
(
environment
.
get
(
varName
)
)
;
}
function
GetFile
(
path
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
path
)
;
return
file
;
}
function
GetEnvironmentVariable
(
varName
)
{
return
environment
.
get
(
varName
)
;
}
function
GetBrowserType
(
type
)
{
let
browserType
=
undefined
;
if
(
!
GetBrowserType
[
type
]
)
{
if
(
type
=
=
=
"
web
"
)
{
GetBrowserType
[
type
]
=
gBrowser
.
selectedBrowser
;
}
else
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
{
preferredRemoteType
:
type
}
)
;
GetBrowserType
[
type
]
=
gBrowser
.
getBrowserForTab
(
gBrowser
.
selectedTab
)
;
}
}
browserType
=
GetBrowserType
[
type
]
;
ok
(
browserType
.
remoteType
=
=
=
type
GetBrowserType
(
{
type
}
)
returns
a
{
type
}
process
)
;
return
browserType
;
}
function
GetWebBrowser
(
)
{
return
GetBrowserType
(
"
web
"
)
;
}
function
isFileContentProcessEnabled
(
)
{
let
fileContentProcessEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
remote
.
separateFileUriProcess
"
)
;
ok
(
fileContentProcessEnabled
"
separate
file
content
process
is
enabled
"
)
;
return
fileContentProcessEnabled
;
}
function
GetFileBrowser
(
)
{
if
(
!
isFileContentProcessEnabled
(
)
)
{
return
undefined
;
}
return
GetBrowserType
(
"
file
"
)
;
}
function
GetSandboxLevel
(
)
{
return
Services
.
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
}
async
function
runTestsList
(
tests
)
{
let
level
=
GetSandboxLevel
(
)
;
tests
=
tests
.
filter
(
test
=
>
test
.
minLevel
<
=
level
)
;
for
(
let
test
of
tests
)
{
let
okString
=
test
.
ok
?
"
allowed
"
:
"
blocked
"
;
let
processType
=
test
.
browser
.
remoteType
;
if
(
test
.
func
=
=
=
statPath
)
{
ok
(
test
.
file
.
exists
(
)
{
test
.
file
.
path
}
exists
)
;
}
let
result
=
await
ContentTask
.
spawn
(
test
.
browser
test
.
file
.
path
test
.
func
)
;
ok
(
result
.
ok
=
=
test
.
ok
reading
{
test
.
desc
}
from
a
{
processType
}
process
+
is
{
okString
}
(
{
test
.
file
.
path
}
)
)
;
if
(
test
.
func
=
=
=
readDir
&
&
!
test
.
ok
)
{
ok
(
result
.
numEntries
=
=
0
directory
list
is
empty
(
{
test
.
file
.
path
}
)
)
;
}
if
(
test
.
cleanup
!
=
undefined
)
{
await
test
.
cleanup
(
test
.
file
.
path
)
;
}
}
}
