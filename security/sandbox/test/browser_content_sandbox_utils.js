"
use
strict
"
;
const
uuidGenerator
=
Services
.
uuid
;
function
sanityChecks
(
)
{
if
(
!
gMultiProcessBrowser
)
{
ok
(
false
"
e10s
is
enabled
"
)
;
info
(
"
e10s
is
not
enabled
exiting
"
)
;
return
;
}
let
level
=
0
;
let
prefExists
=
true
;
try
{
level
=
Services
.
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
}
catch
(
e
)
{
prefExists
=
false
;
}
ok
(
prefExists
"
pref
security
.
sandbox
.
content
.
level
exists
"
)
;
if
(
!
prefExists
)
{
return
;
}
info
(
security
.
sandbox
.
content
.
level
=
{
level
}
)
;
Assert
.
greater
(
level
0
"
content
sandbox
is
enabled
.
"
)
;
let
isFileIOSandboxed
=
isContentFileIOSandboxed
(
level
)
;
ok
(
isFileIOSandboxed
"
content
file
I
/
O
sandboxing
is
enabled
.
"
)
;
if
(
!
isFileIOSandboxed
)
{
info
(
"
content
sandbox
level
too
low
for
file
I
/
O
tests
exiting
\
n
"
)
;
}
}
function
createFile
(
path
)
{
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
try
{
const
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
fstream
.
init
(
new
FileUtils
.
File
(
path
)
-
1
-
1
0
)
;
const
ostream
=
Cc
[
"
mozilla
.
org
/
binaryoutputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryOutputStream
)
;
ostream
.
setOutputStream
(
fstream
)
;
const
data
=
"
TEST
FILE
DUMMY
DATA
"
;
ostream
.
writeBytes
(
data
data
.
length
)
;
ostream
.
close
(
)
;
fstream
.
close
(
)
;
}
catch
(
e
)
{
return
{
ok
:
false
}
;
}
return
{
ok
:
true
}
;
}
function
createSymlink
(
path
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
try
{
const
libc
=
ctypes
.
open
(
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
"
libSystem
.
B
.
dylib
"
:
"
libc
.
so
"
)
;
const
symlink
=
libc
.
declare
(
"
symlink
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
ctypes
.
char
.
ptr
)
;
if
(
symlink
(
"
/
etc
"
path
)
)
{
return
{
ok
:
false
}
;
}
}
catch
(
e
)
{
return
{
ok
:
false
}
;
}
return
{
ok
:
true
}
;
}
function
deleteFile
(
path
)
{
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
try
{
const
file
=
new
FileUtils
.
File
(
path
)
;
file
.
remove
(
false
)
;
}
catch
(
e
)
{
return
{
ok
:
false
}
;
}
return
{
ok
:
true
}
;
}
function
readDir
(
path
)
{
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
let
numEntries
=
0
;
try
{
const
file
=
new
FileUtils
.
File
(
path
)
;
const
enumerator
=
file
.
directoryEntries
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
void
enumerator
.
nextFile
;
numEntries
+
+
;
}
}
catch
(
e
)
{
return
{
ok
:
false
numEntries
}
;
}
return
{
ok
:
true
numEntries
}
;
}
function
readFile
(
path
)
{
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
try
{
const
file
=
new
FileUtils
.
File
(
path
)
;
const
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fstream
.
init
(
file
-
1
-
1
0
)
;
const
istream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
istream
.
setInputStream
(
fstream
)
;
const
available
=
istream
.
available
(
)
;
void
istream
.
readBytes
(
available
)
;
}
catch
(
e
)
{
return
{
ok
:
false
}
;
}
return
{
ok
:
true
}
;
}
function
statPath
(
path
)
{
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
try
{
const
file
=
new
FileUtils
.
File
(
path
)
;
void
file
.
lastModifiedTime
;
}
catch
(
e
)
{
return
{
ok
:
false
}
;
}
return
{
ok
:
true
}
;
}
function
isContentFileIOSandboxed
(
level
)
{
let
fileIOSandboxMinLevel
=
0
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
fileIOSandboxMinLevel
=
1
;
break
;
case
"
Darwin
"
:
fileIOSandboxMinLevel
=
1
;
break
;
case
"
Linux
"
:
fileIOSandboxMinLevel
=
2
;
break
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
}
return
level
>
=
fileIOSandboxMinLevel
;
}
function
minProfileReadSandboxLevel
(
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
3
;
case
"
Darwin
"
:
return
2
;
case
"
Linux
"
:
return
3
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
return
0
;
}
}
function
minHomeReadSandboxLevel
(
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
3
;
case
"
Darwin
"
:
return
3
;
case
"
Linux
"
:
return
3
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
return
0
;
}
}
function
isMac
(
)
{
return
Services
.
appinfo
.
OS
=
=
"
Darwin
"
;
}
function
isWin
(
)
{
return
Services
.
appinfo
.
OS
=
=
"
WINNT
"
;
}
function
isLinux
(
)
{
return
Services
.
appinfo
.
OS
=
=
"
Linux
"
;
}
function
isNightly
(
)
{
let
version
=
SpecialPowers
.
Services
.
appinfo
.
version
;
return
version
.
endsWith
(
"
a1
"
)
;
}
function
uuid
(
)
{
return
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
}
function
fileInHomeDir
(
)
{
let
homeDir
=
Services
.
dirsvc
.
get
(
"
Home
"
Ci
.
nsIFile
)
;
Assert
.
ok
(
homeDir
.
exists
(
)
"
Home
dir
exists
"
)
;
Assert
.
ok
(
homeDir
.
isDirectory
(
)
"
Home
dir
is
a
directory
"
)
;
let
homeFile
=
homeDir
.
clone
(
)
;
homeFile
.
appendRelativePath
(
uuid
(
)
)
;
Assert
.
ok
(
!
homeFile
.
exists
(
)
homeFile
.
path
+
"
does
not
exist
"
)
;
return
homeFile
;
}
function
fileInTempDir
(
)
{
let
contentTempKey
=
"
TmpD
"
;
let
ctmp
=
Services
.
dirsvc
.
get
(
contentTempKey
Ci
.
nsIFile
)
;
Assert
.
ok
(
ctmp
.
exists
(
)
"
Temp
dir
exists
"
)
;
Assert
.
ok
(
ctmp
.
isDirectory
(
)
"
Temp
dir
is
a
directory
"
)
;
let
tempFile
=
ctmp
.
clone
(
)
;
tempFile
.
appendRelativePath
(
uuid
(
)
)
;
Assert
.
ok
(
!
tempFile
.
exists
(
)
tempFile
.
path
+
"
does
not
exist
"
)
;
return
tempFile
;
}
function
GetProfileDir
(
)
{
let
profileDir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
return
profileDir
;
}
function
GetHomeDir
(
)
{
let
homeDir
=
Services
.
dirsvc
.
get
(
"
Home
"
Ci
.
nsIFile
)
;
return
homeDir
;
}
function
GetHomeSubdir
(
subdir
)
{
return
GetSubdir
(
GetHomeDir
(
)
subdir
)
;
}
function
GetHomeSubdirFile
(
subdir
)
{
return
GetSubdirFile
(
GetHomeSubdir
(
subdir
)
)
;
}
function
GetSubdir
(
dir
subdir
)
{
let
newSubdir
=
dir
.
clone
(
)
;
newSubdir
.
appendRelativePath
(
subdir
)
;
return
newSubdir
;
}
function
GetSubdirFile
(
dir
)
{
let
newFile
=
dir
.
clone
(
)
;
newFile
.
appendRelativePath
(
uuid
(
)
)
;
return
newFile
;
}
function
GetPerUserExtensionDir
(
)
{
return
Services
.
dirsvc
.
get
(
"
XREUSysExt
"
Ci
.
nsIFile
)
;
}
function
GetProfileEntry
(
name
)
{
let
entry
=
GetProfileDir
(
)
;
entry
.
append
(
name
)
;
return
entry
;
}
function
GetDir
(
path
)
{
let
dir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
dir
.
initWithPath
(
path
)
;
Assert
.
ok
(
dir
.
isDirectory
(
)
{
path
}
is
a
directory
)
;
return
dir
;
}
function
GetDirFromEnvVariable
(
varName
)
{
return
GetDir
(
Services
.
env
.
get
(
varName
)
)
;
}
function
GetFile
(
path
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
path
)
;
return
file
;
}
function
GetBrowserType
(
type
)
{
let
browserType
=
undefined
;
if
(
!
GetBrowserType
[
type
]
)
{
if
(
type
=
=
=
"
web
"
)
{
GetBrowserType
[
type
]
=
gBrowser
.
selectedBrowser
;
}
else
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
{
preferredRemoteType
:
type
}
)
;
GetBrowserType
[
type
]
=
gBrowser
.
getBrowserForTab
(
gBrowser
.
selectedTab
)
;
}
}
browserType
=
GetBrowserType
[
type
]
;
Assert
.
strictEqual
(
browserType
.
remoteType
type
GetBrowserType
(
{
type
}
)
returns
a
{
type
}
process
)
;
return
browserType
;
}
function
GetWebBrowser
(
)
{
return
GetBrowserType
(
"
web
"
)
;
}
function
isFileContentProcessEnabled
(
)
{
let
fileContentProcessEnabled
=
Services
.
prefs
.
getBoolPref
(
"
browser
.
tabs
.
remote
.
separateFileUriProcess
"
)
;
ok
(
fileContentProcessEnabled
"
separate
file
content
process
is
enabled
"
)
;
return
fileContentProcessEnabled
;
}
function
GetFileBrowser
(
)
{
if
(
!
isFileContentProcessEnabled
(
)
)
{
return
undefined
;
}
return
GetBrowserType
(
"
file
"
)
;
}
function
GetSandboxLevel
(
)
{
return
Services
.
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
}
async
function
runTestsList
(
tests
)
{
let
level
=
GetSandboxLevel
(
)
;
tests
=
tests
.
filter
(
test
=
>
test
.
minLevel
<
=
level
)
;
for
(
let
test
of
tests
)
{
let
okString
=
test
.
ok
?
"
allowed
"
:
"
blocked
"
;
let
processType
=
test
.
browser
.
remoteType
;
if
(
test
.
func
=
=
=
statPath
)
{
ok
(
test
.
file
.
exists
(
)
{
test
.
file
.
path
}
exists
)
;
}
let
result
=
await
ContentTask
.
spawn
(
test
.
browser
test
.
file
.
path
test
.
func
)
;
Assert
.
equal
(
result
.
ok
test
.
ok
reading
{
test
.
desc
}
from
a
{
processType
}
process
+
is
{
okString
}
(
{
test
.
file
.
path
}
)
)
;
if
(
test
.
func
=
=
=
readDir
&
&
!
test
.
ok
)
{
Assert
.
equal
(
result
.
numEntries
0
directory
list
is
empty
(
{
test
.
file
.
path
}
)
)
;
}
if
(
test
.
cleanup
!
=
undefined
)
{
await
test
.
cleanup
(
test
.
file
.
path
)
;
}
}
}
