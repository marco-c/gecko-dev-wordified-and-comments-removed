"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
+
"
security
/
sandbox
/
test
/
browser_content_sandbox_utils
.
js
"
this
)
;
function
callExec
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
{
lib
cmd
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
exec
=
libc
.
declare
(
"
execv
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
)
;
let
rv
=
exec
(
cmd
)
;
libc
.
close
(
)
;
return
(
rv
)
;
}
function
callFork
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
{
lib
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
fork
=
libc
.
declare
(
"
fork
"
ctypes
.
default_abi
ctypes
.
int
)
;
let
rv
=
fork
(
)
;
libc
.
close
(
)
;
return
(
rv
)
;
}
function
callSysctl
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
{
lib
name
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
sysctlbyname
=
libc
.
declare
(
"
sysctlbyname
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
ctypes
.
voidptr_t
ctypes
.
size_t
.
ptr
ctypes
.
voidptr_t
ctypes
.
size_t
.
ptr
)
;
let
rv
=
sysctlbyname
(
name
null
null
null
null
)
;
libc
.
close
(
)
;
return
rv
;
}
function
callOpen
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
{
lib
path
flags
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
open
=
libc
.
declare
(
"
open
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
ctypes
.
int
)
;
let
close
=
libc
.
declare
(
"
close
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
int
)
;
let
fd
=
open
(
path
flags
)
;
close
(
fd
)
;
libc
.
close
(
)
;
return
(
fd
)
;
}
function
openWriteCreateFlags
(
)
{
Assert
.
ok
(
isMac
(
)
|
|
isLinux
(
)
)
;
if
(
isMac
(
)
)
{
let
O_WRONLY
=
0x001
;
let
O_CREAT
=
0x200
;
return
(
O_WRONLY
|
O_CREAT
)
;
}
let
O_WRONLY
=
0x01
;
let
O_CREAT
=
0x40
;
return
(
O_WRONLY
|
O_CREAT
)
;
}
function
getOSLib
(
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
"
kernel32
.
dll
"
;
case
"
Darwin
"
:
return
"
libc
.
dylib
"
;
case
"
Linux
"
:
return
"
libc
.
so
.
6
"
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
return
0
;
}
}
function
getOSExecCmd
(
)
{
Assert
.
ok
(
!
isWin
(
)
)
;
return
(
"
/
bin
/
cat
"
)
;
}
function
areContentSyscallsSandboxed
(
level
)
{
let
syscallsSandboxMinLevel
=
0
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
syscallsSandboxMinLevel
=
1
;
break
;
case
"
Darwin
"
:
syscallsSandboxMinLevel
=
1
;
break
;
case
"
Linux
"
:
syscallsSandboxMinLevel
=
1
;
break
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
}
return
(
level
>
=
syscallsSandboxMinLevel
)
;
}
add_task
(
async
function
(
)
{
if
(
!
gMultiProcessBrowser
)
{
ok
(
false
"
e10s
is
enabled
"
)
;
info
(
"
e10s
is
not
enabled
exiting
"
)
;
return
;
}
let
level
=
0
;
let
prefExists
=
true
;
try
{
level
=
Services
.
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
}
catch
(
e
)
{
prefExists
=
false
;
}
ok
(
prefExists
"
pref
security
.
sandbox
.
content
.
level
exists
"
)
;
if
(
!
prefExists
)
{
return
;
}
info
(
security
.
sandbox
.
content
.
level
=
{
level
}
)
;
ok
(
level
>
0
"
content
sandbox
is
enabled
.
"
)
;
let
areSyscallsSandboxed
=
areContentSyscallsSandboxed
(
level
)
;
ok
(
areSyscallsSandboxed
"
content
syscall
sandboxing
is
enabled
.
"
)
;
if
(
!
areSyscallsSandboxed
)
{
info
(
"
content
sandbox
level
too
low
for
syscall
tests
exiting
\
n
"
)
;
return
;
}
let
browser
=
gBrowser
.
selectedBrowser
;
let
lib
=
getOSLib
(
)
;
if
(
isMac
(
)
)
{
let
cmd
=
getOSExecCmd
(
)
;
let
rv
=
await
ContentTask
.
spawn
(
browser
{
lib
cmd
}
callExec
)
;
ok
(
rv
=
=
-
1
exec
(
{
cmd
}
)
is
not
permitted
)
;
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
path
=
fileInHomeDir
(
)
.
path
;
let
flags
=
openWriteCreateFlags
(
)
;
let
fd
=
await
ContentTask
.
spawn
(
browser
{
lib
path
flags
}
callOpen
)
;
ok
(
fd
<
0
"
opening
a
file
for
writing
in
home
is
not
permitted
"
)
;
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
path
=
fileInTempDir
(
)
.
path
;
let
flags
=
openWriteCreateFlags
(
)
;
let
fd
=
await
ContentTask
.
spawn
(
browser
{
lib
path
flags
}
callOpen
)
;
if
(
isMac
(
)
)
{
ok
(
fd
=
=
=
-
1
"
opening
a
file
for
writing
in
content
temp
is
not
permitted
"
)
;
}
else
{
ok
(
fd
>
=
0
"
opening
a
file
for
writing
in
content
temp
is
permitted
"
)
;
}
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
rv
=
await
ContentTask
.
spawn
(
browser
{
lib
}
callFork
)
;
ok
(
rv
=
=
-
1
"
calling
fork
is
not
permitted
"
)
;
}
if
(
isMac
(
)
&
&
Services
.
sysinfo
.
getProperty
(
"
version
"
)
>
=
"
14
.
0
.
0
"
)
{
let
rv
=
await
ContentTask
.
spawn
(
browser
{
lib
name
:
"
kern
.
boottime
"
}
callSysctl
)
;
ok
(
rv
=
=
-
1
"
calling
sysctl
(
'
kern
.
boottime
'
)
is
not
permitted
"
)
;
rv
=
await
ContentTask
.
spawn
(
browser
{
lib
name
:
"
net
.
inet
.
ip
.
ttl
"
}
callSysctl
)
;
ok
(
rv
=
=
-
1
"
calling
sysctl
(
'
net
.
inet
.
ip
.
ttl
'
)
is
not
permitted
"
)
;
rv
=
await
ContentTask
.
spawn
(
browser
{
lib
name
:
"
hw
.
ncpu
"
}
callSysctl
)
;
ok
(
rv
=
=
0
"
calling
sysctl
(
'
hw
.
ncpu
'
)
is
permitted
"
)
;
}
}
)
;
