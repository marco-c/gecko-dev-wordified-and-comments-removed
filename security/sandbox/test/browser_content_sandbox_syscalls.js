var
prefs
=
Cc
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrefBranch
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
+
"
security
/
sandbox
/
test
/
browser_content_sandbox_utils
.
js
"
this
)
;
function
callExec
(
args
)
{
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
{
lib
cmd
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
exec
=
libc
.
declare
(
"
execv
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
)
;
let
rv
=
exec
(
cmd
)
;
libc
.
close
(
)
;
return
(
rv
)
;
}
function
callFork
(
args
)
{
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
{
lib
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
fork
=
libc
.
declare
(
"
fork
"
ctypes
.
default_abi
ctypes
.
int
)
;
let
rv
=
fork
(
)
;
libc
.
close
(
)
;
return
(
rv
)
;
}
function
callOpen
(
args
)
{
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
let
{
lib
path
flags
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
open
=
libc
.
declare
(
"
open
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
ctypes
.
int
)
;
let
close
=
libc
.
declare
(
"
close
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
int
)
;
let
fd
=
open
(
path
flags
)
;
close
(
fd
)
;
libc
.
close
(
)
;
return
(
fd
)
;
}
function
openWriteCreateFlags
(
)
{
Assert
.
ok
(
isMac
(
)
|
|
isLinux
(
)
)
;
if
(
isMac
(
)
)
{
let
O_WRONLY
=
0x001
;
let
O_CREAT
=
0x200
;
return
(
O_WRONLY
|
O_CREAT
)
;
}
else
{
let
O_WRONLY
=
0x01
;
let
O_CREAT
=
0x40
;
return
(
O_WRONLY
|
O_CREAT
)
;
}
}
function
getOSLib
(
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
"
kernel32
.
dll
"
;
case
"
Darwin
"
:
return
"
libc
.
dylib
"
;
case
"
Linux
"
:
return
"
libc
.
so
.
6
"
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
}
}
function
getOSExecCmd
(
)
{
Assert
.
ok
(
!
isWin
(
)
)
;
return
(
"
/
bin
/
cat
"
)
;
}
function
areContentSyscallsSandboxed
(
level
)
{
let
syscallsSandboxMinLevel
=
0
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
syscallsSandboxMinLevel
=
1
;
break
;
case
"
Darwin
"
:
syscallsSandboxMinLevel
=
1
;
break
;
case
"
Linux
"
:
syscallsSandboxMinLevel
=
2
;
break
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
}
return
(
level
>
=
syscallsSandboxMinLevel
)
;
}
add_task
(
function
*
(
)
{
if
(
!
gMultiProcessBrowser
)
{
ok
(
false
"
e10s
is
enabled
"
)
;
info
(
"
e10s
is
not
enabled
exiting
"
)
;
return
;
}
let
level
=
0
;
let
prefExists
=
true
;
try
{
level
=
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
}
catch
(
e
)
{
prefExists
=
false
;
}
if
(
isLinux
(
)
&
&
!
isNightly
(
)
)
{
todo
(
prefExists
"
pref
security
.
sandbox
.
content
.
level
exists
"
)
;
if
(
!
prefExists
)
{
return
;
}
}
ok
(
prefExists
"
pref
security
.
sandbox
.
content
.
level
exists
"
)
;
if
(
!
prefExists
)
{
return
;
}
if
(
isLinux
(
)
&
&
!
isNightly
(
)
)
{
todo
(
level
>
0
"
content
sandbox
enabled
for
!
nightly
.
"
)
;
return
;
}
info
(
security
.
sandbox
.
content
.
level
=
{
level
}
)
;
ok
(
level
>
0
"
content
sandbox
is
enabled
.
"
)
;
if
(
level
=
=
0
)
{
info
(
"
content
sandbox
is
not
enabled
exiting
"
)
;
return
;
}
let
areSyscallsSandboxed
=
areContentSyscallsSandboxed
(
level
)
;
if
(
isLinux
(
)
&
&
!
isNightly
(
)
)
{
todo
(
areSyscallsSandboxed
"
content
syscall
sandbox
enabled
for
!
nightly
.
"
)
;
return
;
}
ok
(
areSyscallsSandboxed
"
content
syscall
sandboxing
is
enabled
.
"
)
;
if
(
!
areSyscallsSandboxed
)
{
info
(
"
content
sandbox
level
too
low
for
syscall
tests
exiting
\
n
"
)
;
return
;
}
let
browser
=
gBrowser
.
selectedBrowser
;
let
lib
=
getOSLib
(
)
;
if
(
isMac
(
)
)
{
let
cmd
=
getOSExecCmd
(
)
;
let
rv
=
yield
ContentTask
.
spawn
(
browser
{
lib
cmd
}
callExec
)
;
ok
(
rv
=
=
-
1
exec
(
{
cmd
}
)
is
not
permitted
)
;
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
path
=
fileInHomeDir
(
)
.
path
;
let
flags
=
openWriteCreateFlags
(
)
;
let
fd
=
yield
ContentTask
.
spawn
(
browser
{
lib
path
flags
}
callOpen
)
;
ok
(
fd
<
0
"
opening
a
file
for
writing
in
home
is
not
permitted
"
)
;
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
path
=
fileInTempDir
(
)
.
path
;
let
flags
=
openWriteCreateFlags
(
)
;
let
fd
=
yield
ContentTask
.
spawn
(
browser
{
lib
path
flags
}
callOpen
)
;
ok
(
fd
>
=
0
"
opening
a
file
for
writing
in
content
temp
is
permitted
"
)
;
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
rv
=
yield
ContentTask
.
spawn
(
browser
{
lib
}
callFork
)
;
ok
(
rv
=
=
-
1
"
calling
fork
is
not
permitted
"
)
;
}
}
)
;
