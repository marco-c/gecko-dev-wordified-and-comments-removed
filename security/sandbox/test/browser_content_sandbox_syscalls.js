"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
+
"
security
/
sandbox
/
test
/
browser_content_sandbox_utils
.
js
"
this
)
;
const
ERRNO
=
{
EACCES
:
13
EINVAL
:
22
get
ENOSYS
(
)
{
const
os
=
Services
.
appinfo
.
OS
;
if
(
[
"
Linux
"
"
Android
"
]
.
includes
(
os
)
)
{
return
38
;
}
else
if
(
[
"
Darwin
"
"
FreeBSD
"
"
OpenBSD
"
"
NetBSD
"
]
.
includes
(
os
)
)
{
return
78
;
}
else
if
(
os
=
=
=
"
WINNT
"
)
{
return
40
;
}
throw
new
Error
(
"
Unsupported
OS
"
)
;
}
}
;
function
callExec
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
let
{
lib
cmd
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
exec
=
libc
.
declare
(
"
execv
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
)
;
let
rv
=
exec
(
cmd
)
;
libc
.
close
(
)
;
return
rv
;
}
function
callFork
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
let
{
lib
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
fork
=
libc
.
declare
(
"
fork
"
ctypes
.
default_abi
ctypes
.
int
)
;
let
rv
=
fork
(
)
;
libc
.
close
(
)
;
return
rv
;
}
function
callSysctl
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
let
{
lib
name
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
sysctlbyname
=
libc
.
declare
(
"
sysctlbyname
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
ctypes
.
voidptr_t
ctypes
.
size_t
.
ptr
ctypes
.
voidptr_t
ctypes
.
size_t
.
ptr
)
;
let
rv
=
sysctlbyname
(
name
null
null
null
null
)
;
libc
.
close
(
)
;
return
rv
;
}
function
callPrctl
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
let
{
lib
option
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
prctl
=
libc
.
declare
(
"
prctl
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
int
ctypes
.
unsigned_long
ctypes
.
unsigned_long
ctypes
.
unsigned_long
ctypes
.
unsigned_long
)
;
let
rv
=
prctl
(
option
0
0
0
0
)
;
if
(
rv
=
=
-
1
)
{
rv
=
ctypes
.
errno
;
}
libc
.
close
(
)
;
return
rv
;
}
function
callOpen
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
let
{
lib
path
flags
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
open
=
libc
.
declare
(
"
open
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
char
.
ptr
ctypes
.
int
)
;
let
close
=
libc
.
declare
(
"
close
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
int
)
;
let
fd
=
open
(
path
flags
)
;
close
(
fd
)
;
libc
.
close
(
)
;
return
fd
;
}
function
callFaccessat2
(
args
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
let
{
lib
dirfd
path
mode
flag
}
=
args
;
let
libc
=
ctypes
.
open
(
lib
)
;
let
faccessat
=
libc
.
declare
(
"
faccessat
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
int
ctypes
.
char
.
ptr
ctypes
.
int
ctypes
.
int
)
;
let
rv
=
faccessat
(
dirfd
path
mode
flag
)
;
if
(
rv
=
=
-
1
)
{
rv
=
ctypes
.
errno
;
}
libc
.
close
(
)
;
return
rv
;
}
function
openWriteCreateFlags
(
)
{
Assert
.
ok
(
isMac
(
)
|
|
isLinux
(
)
)
;
if
(
isMac
(
)
)
{
let
O_WRONLY
=
0x001
;
let
O_CREAT
=
0x200
;
return
O_WRONLY
|
O_CREAT
;
}
let
O_WRONLY
=
0x01
;
let
O_CREAT
=
0x40
;
return
O_WRONLY
|
O_CREAT
;
}
function
getOSLib
(
)
{
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
return
"
kernel32
.
dll
"
;
case
"
Darwin
"
:
return
"
libc
.
dylib
"
;
case
"
Linux
"
:
return
"
libc
.
so
.
6
"
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
return
0
;
}
}
async
function
getKernelVersion
(
)
{
let
header
=
await
IOUtils
.
readUTF8
(
"
/
usr
/
include
/
linux
/
version
.
h
"
)
;
let
hr
=
header
.
split
(
"
\
n
"
)
;
for
(
let
line
in
hr
)
{
let
hrs
=
hr
[
line
]
.
split
(
"
"
)
;
if
(
hrs
[
0
]
=
=
=
"
#
define
"
&
&
hrs
[
1
]
=
=
=
"
LINUX_VERSION_CODE
"
)
{
return
Number
(
hrs
[
2
]
)
;
}
}
throw
Error
(
"
No
LINUX_VERSION_CODE
"
)
;
}
function
computeKernelVersion
(
major
minor
dot
)
{
return
(
major
<
<
16
)
+
(
minor
<
<
8
)
+
dot
;
}
function
getGlibcVersion
(
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
let
libc
=
ctypes
.
open
(
getOSLib
(
)
)
;
let
gnu_get_libc_version
=
libc
.
declare
(
"
gnu_get_libc_version
"
ctypes
.
default_abi
ctypes
.
char
.
ptr
)
;
let
rv
=
gnu_get_libc_version
(
)
.
readString
(
)
;
libc
.
close
(
)
;
let
ar
=
rv
.
split
(
"
.
"
)
;
return
Number
(
ar
[
0
]
+
ar
[
1
]
)
;
}
function
getOSExecCmd
(
)
{
Assert
.
ok
(
!
isWin
(
)
)
;
return
"
/
bin
/
cat
"
;
}
function
areContentSyscallsSandboxed
(
level
)
{
let
syscallsSandboxMinLevel
=
0
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
WINNT
"
:
syscallsSandboxMinLevel
=
1
;
break
;
case
"
Darwin
"
:
syscallsSandboxMinLevel
=
1
;
break
;
case
"
Linux
"
:
syscallsSandboxMinLevel
=
1
;
break
;
default
:
Assert
.
ok
(
false
"
Unknown
OS
"
)
;
}
return
level
>
=
syscallsSandboxMinLevel
;
}
add_task
(
async
function
(
)
{
if
(
!
gMultiProcessBrowser
)
{
ok
(
false
"
e10s
is
enabled
"
)
;
info
(
"
e10s
is
not
enabled
exiting
"
)
;
return
;
}
let
level
=
0
;
let
prefExists
=
true
;
try
{
level
=
Services
.
prefs
.
getIntPref
(
"
security
.
sandbox
.
content
.
level
"
)
;
}
catch
(
e
)
{
prefExists
=
false
;
}
ok
(
prefExists
"
pref
security
.
sandbox
.
content
.
level
exists
"
)
;
if
(
!
prefExists
)
{
return
;
}
info
(
security
.
sandbox
.
content
.
level
=
{
level
}
)
;
ok
(
level
>
0
"
content
sandbox
is
enabled
.
"
)
;
let
areSyscallsSandboxed
=
areContentSyscallsSandboxed
(
level
)
;
ok
(
areSyscallsSandboxed
"
content
syscall
sandboxing
is
enabled
.
"
)
;
if
(
!
areSyscallsSandboxed
)
{
info
(
"
content
sandbox
level
too
low
for
syscall
tests
exiting
\
n
"
)
;
return
;
}
let
browser
=
gBrowser
.
selectedBrowser
;
let
lib
=
getOSLib
(
)
;
if
(
isMac
(
)
)
{
let
cmd
=
getOSExecCmd
(
)
;
let
rv
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
cmd
}
]
callExec
)
;
ok
(
rv
=
=
-
1
exec
(
{
cmd
}
)
is
not
permitted
)
;
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
path
=
fileInHomeDir
(
)
.
path
;
let
flags
=
openWriteCreateFlags
(
)
;
let
fd
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
path
flags
}
]
callOpen
)
;
ok
(
fd
<
0
"
opening
a
file
for
writing
in
home
is
not
permitted
"
)
;
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
path
=
fileInTempDir
(
)
.
path
;
let
flags
=
openWriteCreateFlags
(
)
;
let
fd
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
path
flags
}
]
callOpen
)
;
if
(
isMac
(
)
)
{
ok
(
fd
=
=
=
-
1
"
opening
a
file
for
writing
in
content
temp
is
not
permitted
"
)
;
}
else
{
ok
(
fd
>
=
0
"
opening
a
file
for
writing
in
content
temp
is
permitted
"
)
;
}
}
if
(
isLinux
(
)
|
|
isMac
(
)
)
{
let
rv
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
}
]
callFork
)
;
ok
(
rv
=
=
-
1
"
calling
fork
is
not
permitted
"
)
;
}
if
(
isMac
(
)
&
&
Services
.
sysinfo
.
getProperty
(
"
version
"
)
>
=
"
14
.
0
.
0
"
)
{
let
rv
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
name
:
"
kern
.
boottime
"
}
]
callSysctl
)
;
ok
(
rv
=
=
-
1
"
calling
sysctl
(
'
kern
.
boottime
'
)
is
not
permitted
"
)
;
rv
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
name
:
"
net
.
inet
.
ip
.
ttl
"
}
]
callSysctl
)
;
ok
(
rv
=
=
-
1
"
calling
sysctl
(
'
net
.
inet
.
ip
.
ttl
'
)
is
not
permitted
"
)
;
rv
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
name
:
"
hw
.
ncpu
"
}
]
callSysctl
)
;
ok
(
rv
=
=
0
"
calling
sysctl
(
'
hw
.
ncpu
'
)
is
permitted
"
)
;
}
if
(
isLinux
(
)
)
{
const
AT_EACCESS
=
512
;
const
PR_CAPBSET_READ
=
23
;
let
option
=
PR_CAPBSET_READ
;
let
rv
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
option
}
]
callPrctl
)
;
ok
(
rv
=
=
=
ERRNO
.
EINVAL
"
prctl
(
PR_CAPBSET_READ
)
is
blocked
"
)
;
const
kernelVersion
=
await
getKernelVersion
(
)
;
const
glibcVersion
=
getGlibcVersion
(
)
;
if
(
glibcVersion
>
=
233
&
&
kernelVersion
>
=
computeKernelVersion
(
5
8
0
)
)
{
info
(
"
Linux
v5
.
8
+
glibc
2
.
33
+
checking
faccessat2
"
)
;
const
dirfd
=
0
;
const
path
=
"
/
"
;
const
mode
=
0
;
let
rv
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
dirfd
path
mode
flag
:
0x01
}
]
callFaccessat2
)
;
ok
(
rv
=
=
=
ERRNO
.
ENOSYS
"
faccessat2
(
flag
=
0x01
)
was
blocked
with
ENOSYS
"
)
;
rv
=
await
SpecialPowers
.
spawn
(
browser
[
{
lib
dirfd
path
mode
flag
:
AT_EACCESS
}
]
callFaccessat2
)
;
ok
(
rv
=
=
=
ERRNO
.
EACCES
"
faccessat2
(
flag
=
0x200
)
was
allowed
errno
=
EACCES
"
)
;
}
else
{
info
(
"
Unsupported
kernel
(
"
+
kernelVersion
+
"
)
/
glibc
(
"
+
glibcVersion
+
"
)
skipping
faccessat2
"
)
;
}
}
}
)
;
