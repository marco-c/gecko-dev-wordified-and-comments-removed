"
use
strict
"
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
async
function
createFileInHome
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
let
homeFile
=
fileInHomeDir
(
)
;
let
path
=
homeFile
.
path
;
let
fileCreated
=
await
SpecialPowers
.
spawn
(
browser
[
path
]
createFile
)
;
ok
(
!
fileCreated
.
ok
"
creating
a
file
in
home
dir
is
not
permitted
"
)
;
if
(
fileCreated
.
ok
)
{
homeFile
.
remove
(
false
)
;
}
}
async
function
createTempFile
(
)
{
let
browser
=
gBrowser
.
selectedBrowser
;
let
path
=
fileInTempDir
(
)
.
path
;
let
fileCreated
=
await
SpecialPowers
.
spawn
(
browser
[
path
]
createFile
)
;
if
(
isMac
(
)
)
{
ok
(
!
fileCreated
.
ok
"
creating
a
file
in
content
temp
is
not
permitted
"
)
;
}
else
{
ok
(
!
!
fileCreated
.
ok
"
creating
a
file
in
content
temp
is
permitted
"
)
;
}
let
fileDeleted
=
await
SpecialPowers
.
spawn
(
browser
[
path
]
deleteFile
)
;
if
(
isMac
(
)
)
{
ok
(
!
fileDeleted
.
ok
"
deleting
a
file
in
content
temp
is
not
permitted
"
)
;
let
path
=
fileInTempDir
(
)
.
path
;
let
symlinkCreated
=
await
SpecialPowers
.
spawn
(
browser
[
path
]
createSymlink
)
;
ok
(
!
symlinkCreated
.
ok
"
created
a
symlink
in
content
temp
is
not
permitted
"
)
;
}
else
{
ok
(
!
!
fileDeleted
.
ok
"
deleting
a
file
in
content
temp
is
permitted
"
)
;
}
}
async
function
testFileAccessAllPlatforms
(
)
{
let
webBrowser
=
GetWebBrowser
(
)
;
let
fileContentProcessEnabled
=
isFileContentProcessEnabled
(
)
;
let
fileBrowser
=
GetFileBrowser
(
)
;
let
tests
=
[
]
;
let
profileDir
=
GetProfileDir
(
)
;
tests
.
push
(
{
desc
:
"
profile
dir
"
ok
:
false
browser
:
webBrowser
file
:
profileDir
minLevel
:
minProfileReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
"
profile
dir
"
ok
:
true
browser
:
fileBrowser
file
:
profileDir
minLevel
:
0
func
:
readDir
}
)
;
}
let
homeDir
=
GetHomeDir
(
)
;
tests
.
push
(
{
desc
:
"
home
dir
"
ok
:
false
browser
:
webBrowser
file
:
homeDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
"
home
dir
"
ok
:
true
browser
:
fileBrowser
file
:
homeDir
minLevel
:
0
func
:
readDir
}
)
;
}
let
extensionsDir
=
GetProfileEntry
(
"
extensions
"
)
;
if
(
extensionsDir
.
exists
(
)
&
&
extensionsDir
.
isDirectory
(
)
)
{
tests
.
push
(
{
desc
:
"
extensions
dir
"
ok
:
true
browser
:
webBrowser
file
:
extensionsDir
minLevel
:
0
func
:
readDir
}
)
;
}
else
{
ok
(
false
{
extensionsDir
.
path
}
is
a
valid
dir
)
;
}
let
chromeDir
=
GetProfileEntry
(
"
chrome
"
)
;
if
(
chromeDir
.
exists
(
)
&
&
chromeDir
.
isDirectory
(
)
)
{
tests
.
push
(
{
desc
:
"
chrome
dir
"
ok
:
true
browser
:
webBrowser
file
:
chromeDir
minLevel
:
0
func
:
readDir
}
)
;
}
else
{
ok
(
false
{
chromeDir
.
path
}
is
valid
dir
)
;
}
let
cookiesFile
=
GetProfileEntry
(
"
cookies
.
sqlite
"
)
;
if
(
cookiesFile
.
exists
(
)
&
&
!
cookiesFile
.
isDirectory
(
)
)
{
tests
.
push
(
{
desc
:
"
cookies
file
"
ok
:
false
browser
:
webBrowser
file
:
cookiesFile
minLevel
:
minProfileReadSandboxLevel
(
)
func
:
readFile
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
"
cookies
file
"
ok
:
true
browser
:
fileBrowser
file
:
cookiesFile
minLevel
:
0
func
:
readFile
}
)
;
}
}
else
{
ok
(
false
{
cookiesFile
.
path
}
is
a
valid
file
)
;
}
if
(
isMac
(
)
|
|
isLinux
(
)
)
{
let
varDir
=
GetDir
(
"
/
var
"
)
;
if
(
isMac
(
)
)
{
varDir
.
normalize
(
)
;
Assert
.
ok
(
varDir
.
path
=
=
=
"
/
private
/
var
"
"
/
var
resolves
to
/
private
/
var
"
)
;
}
tests
.
push
(
{
desc
:
"
/
var
"
ok
:
false
browser
:
webBrowser
file
:
varDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
"
/
var
"
ok
:
true
browser
:
fileBrowser
file
:
varDir
minLevel
:
0
func
:
readDir
}
)
;
}
}
await
runTestsList
(
tests
)
;
}
async
function
testFileAccessMacOnly
(
)
{
if
(
!
isMac
(
)
)
{
return
;
}
let
webBrowser
=
GetWebBrowser
(
)
;
let
fileContentProcessEnabled
=
isFileContentProcessEnabled
(
)
;
let
fileBrowser
=
GetFileBrowser
(
)
;
let
level
=
GetSandboxLevel
(
)
;
let
tests
=
[
]
;
let
homeTempDir
=
GetHomeDir
(
)
;
homeTempDir
.
appendRelativePath
(
"
Library
/
Caches
/
TemporaryItems
"
)
;
if
(
homeTempDir
.
exists
(
)
)
{
let
shouldBeReadable
minLevel
;
if
(
level
>
=
minHomeReadSandboxLevel
(
)
)
{
shouldBeReadable
=
false
;
minLevel
=
minHomeReadSandboxLevel
(
)
;
}
else
{
shouldBeReadable
=
true
;
minLevel
=
0
;
}
tests
.
push
(
{
desc
:
"
home
library
cache
temp
dir
"
ok
:
shouldBeReadable
browser
:
webBrowser
file
:
homeTempDir
minLevel
func
:
readDir
}
)
;
}
let
macTempDir
=
GetDirFromEnvVariable
(
"
TMPDIR
"
)
;
macTempDir
.
normalize
(
)
;
Assert
.
ok
(
macTempDir
.
path
.
startsWith
(
"
/
private
/
var
"
)
"
TMPDIR
is
in
/
private
/
var
"
)
;
tests
.
push
(
{
desc
:
TMPDIR
(
{
macTempDir
.
path
}
)
ok
:
false
browser
:
webBrowser
file
:
macTempDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
TMPDIR
(
{
macTempDir
.
path
}
)
ok
:
true
browser
:
fileBrowser
file
:
macTempDir
minLevel
:
0
func
:
readDir
}
)
;
}
let
fontRegistryDir
=
macTempDir
.
parent
.
clone
(
)
;
fontRegistryDir
.
appendRelativePath
(
"
C
/
com
.
apple
.
FontRegistry
"
)
;
if
(
fontRegistryDir
.
exists
(
)
)
{
tests
.
push
(
{
desc
:
FontRegistry
(
{
fontRegistryDir
.
path
}
)
ok
:
true
browser
:
webBrowser
file
:
fontRegistryDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
let
fontFile
=
fontRegistryDir
.
clone
(
)
;
fontFile
.
appendRelativePath
(
"
font
"
)
;
if
(
fontFile
.
exists
(
)
)
{
tests
.
push
(
{
desc
:
FontRegistry
file
(
{
fontFile
.
path
}
)
ok
:
true
browser
:
webBrowser
file
:
fontFile
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readFile
}
)
;
}
}
let
volumes
=
GetDir
(
"
/
Volumes
"
)
;
tests
.
push
(
{
desc
:
"
/
Volumes
"
ok
:
false
browser
:
webBrowser
file
:
volumes
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
AppConstants
.
isPlatformAndVersionAtMost
(
"
macosx
"
18
)
)
{
let
network
=
GetDir
(
"
/
Network
"
)
;
tests
.
push
(
{
desc
:
"
/
Network
"
ok
:
false
browser
:
webBrowser
file
:
network
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
}
let
users
=
GetDir
(
"
/
Users
"
)
;
tests
.
push
(
{
desc
:
"
/
Users
"
ok
:
false
browser
:
webBrowser
file
:
users
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
tests
.
push
(
{
desc
:
"
/
Users
"
ok
:
true
browser
:
webBrowser
file
:
users
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
statPath
}
)
;
let
libraryDir
=
GetDir
(
"
/
Library
"
)
;
tests
.
push
(
{
desc
:
"
/
Library
"
ok
:
true
browser
:
webBrowser
file
:
libraryDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
statPath
}
)
;
tests
.
push
(
{
desc
:
"
/
Library
"
ok
:
false
browser
:
webBrowser
file
:
libraryDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
let
privateDir
=
GetDir
(
"
/
private
"
)
;
tests
.
push
(
{
desc
:
"
/
private
"
ok
:
true
browser
:
webBrowser
file
:
privateDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
statPath
}
)
;
await
runTestsList
(
tests
)
;
}
async
function
testFileAccessLinuxOnly
(
)
{
if
(
!
isLinux
(
)
)
{
return
;
}
let
webBrowser
=
GetWebBrowser
(
)
;
let
fileContentProcessEnabled
=
isFileContentProcessEnabled
(
)
;
let
fileBrowser
=
GetFileBrowser
(
)
;
let
tests
=
[
]
;
let
selfFdDir
=
GetDir
(
"
/
proc
/
self
/
fd
"
)
;
tests
.
push
(
{
desc
:
"
/
proc
/
self
/
fd
"
ok
:
false
browser
:
webBrowser
file
:
selfFdDir
minLevel
:
isContentFileIOSandboxed
(
)
func
:
readDir
}
)
;
let
cacheFontConfigDir
=
GetHomeSubdir
(
"
.
cache
/
fontconfig
/
"
)
;
tests
.
push
(
{
desc
:
HOME
/
.
cache
/
fontconfig
/
(
{
cacheFontConfigDir
.
path
}
)
ok
:
true
browser
:
webBrowser
file
:
cacheFontConfigDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
let
configDir
=
GetHomeSubdir
(
"
.
config
"
)
;
const
xdgConfigHome
=
Services
.
env
.
get
(
"
XDG_CONFIG_HOME
"
)
;
if
(
xdgConfigHome
.
length
>
1
)
{
configDir
=
GetDir
(
xdgConfigHome
)
;
configDir
.
normalize
(
)
;
tests
.
push
(
{
desc
:
XDG_CONFIG_HOME
(
{
configDir
.
path
}
)
ok
:
true
browser
:
webBrowser
file
:
configDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
}
tests
.
push
(
{
desc
:
{
configDir
.
path
}
dir
ok
:
true
browser
:
webBrowser
file
:
configDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
{
configDir
.
path
}
dir
ok
:
true
browser
:
fileBrowser
file
:
configDir
minLevel
:
0
func
:
readDir
}
)
;
}
if
(
xdgConfigHome
.
length
>
1
)
{
const
homeConfigDir
=
GetHomeSubdir
(
"
.
config
"
)
;
tests
.
push
(
{
desc
:
{
homeConfigDir
.
path
}
dir
ok
:
false
browser
:
webBrowser
file
:
homeConfigDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
{
homeConfigDir
.
path
}
dir
ok
:
true
browser
:
fileBrowser
file
:
homeConfigDir
minLevel
:
0
func
:
readDir
}
)
;
}
}
else
{
const
homeConfigPrefix
=
GetHomeSubdir
(
"
.
configlol
"
)
;
tests
.
push
(
{
desc
:
{
homeConfigPrefix
.
path
}
dir
ok
:
false
browser
:
webBrowser
file
:
homeConfigPrefix
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
{
homeConfigPrefix
.
path
}
dir
ok
:
false
browser
:
fileBrowser
file
:
homeConfigPrefix
minLevel
:
0
func
:
readDir
}
)
;
}
}
let
fileUnderConfig
=
GetSubdirFile
(
configDir
)
;
let
fileUnderConfigCreated
=
await
createFile
(
fileUnderConfig
.
path
)
;
if
(
!
fileUnderConfigCreated
.
ok
)
{
ok
(
false
Failure
to
create
{
fileUnderConfig
.
path
}
)
;
}
ok
(
fileUnderConfigCreated
File
{
fileUnderConfig
.
path
}
was
properly
created
)
;
let
removeFileUnderConfig
=
async
aPath
=
>
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
await
OS
.
File
.
remove
(
aPath
)
;
}
;
tests
.
push
(
{
desc
:
{
configDir
.
path
}
/
xxx
is
readable
(
{
fileUnderConfig
.
path
}
)
ok
:
true
browser
:
webBrowser
file
:
fileUnderConfig
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readFile
cleanup
:
removeFileUnderConfig
}
)
;
let
configFile
=
GetSubdirFile
(
configDir
)
;
tests
.
push
(
{
desc
:
{
configDir
.
path
}
file
write
ok
:
false
browser
:
webBrowser
file
:
configFile
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
createFile
}
)
;
if
(
fileContentProcessEnabled
)
{
tests
.
push
(
{
desc
:
{
configDir
.
path
}
file
write
ok
:
false
browser
:
fileBrowser
file
:
configFile
minLevel
:
0
func
:
createFile
}
)
;
}
let
configMozilla
=
GetSubdir
(
configDir
"
mozilla
"
)
;
const
emptyFileName
=
"
.
test_run_browser_sandbox
.
tmp
"
;
let
emptyFile
=
configMozilla
.
clone
(
)
;
emptyFile
.
appendRelativePath
(
emptyFileName
)
;
let
populateFakeConfigMozilla
=
async
aPath
=
>
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
await
OS
.
File
.
makeDir
(
aPath
{
unixMode
:
OS
.
Constants
.
S_IRWXU
}
)
;
await
createFile
(
emptyFile
.
path
)
;
ok
(
await
OS
.
File
.
exists
(
emptyFile
.
path
)
Temp
file
{
emptyFile
.
path
}
was
created
)
;
}
;
let
unpopulateFakeConfigMozilla
=
async
aPath
=
>
{
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
await
OS
.
File
.
remove
(
aPath
)
;
ok
(
!
(
await
OS
.
File
.
exists
(
aPath
)
)
Temp
file
{
aPath
}
was
removed
)
;
const
parentDir
=
OS
.
Path
.
dirname
(
aPath
)
;
try
{
await
OS
.
File
.
removeEmptyDir
(
parentDir
)
;
}
catch
(
ex
)
{
if
(
ex
.
unixErrno
!
=
=
39
)
{
throw
ex
;
}
}
}
;
await
populateFakeConfigMozilla
(
configMozilla
.
path
)
;
tests
.
push
(
{
desc
:
stat
{
configDir
.
path
}
/
mozilla
(
{
configMozilla
.
path
}
)
ok
:
false
browser
:
webBrowser
file
:
configMozilla
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
statPath
}
)
;
tests
.
push
(
{
desc
:
read
{
configDir
.
path
}
/
mozilla
(
{
configMozilla
.
path
}
)
ok
:
false
browser
:
webBrowser
file
:
configMozilla
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
tests
.
push
(
{
desc
:
stat
{
configDir
.
path
}
/
mozilla
/
{
emptyFileName
}
(
{
emptyFile
.
path
}
)
ok
:
false
browser
:
webBrowser
file
:
emptyFile
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
statPath
}
)
;
tests
.
push
(
{
desc
:
read
{
configDir
.
path
}
/
mozilla
/
{
emptyFileName
}
(
{
emptyFile
.
path
}
)
ok
:
false
browser
:
webBrowser
file
:
emptyFile
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readFile
cleanup
:
unpopulateFakeConfigMozilla
}
)
;
if
(
xdgConfigHome
.
length
>
1
)
{
tests
.
push
(
{
desc
:
XDG_CONFIG_HOME
(
{
configDir
.
path
}
)
cleanup
ok
:
true
browser
:
webBrowser
file
:
configDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
}
await
runTestsList
(
tests
)
;
}
async
function
testFileAccessLinuxSnap
(
)
{
let
webBrowser
=
GetWebBrowser
(
)
;
let
tests
=
[
]
;
let
snap
=
Services
.
env
.
get
(
"
SNAP
"
)
;
let
snapExpectedResult
=
false
;
if
(
snap
.
length
>
1
)
{
snapExpectedResult
=
true
;
}
else
{
snap
=
"
/
tmp
/
.
snap_firefox_current
/
"
;
}
let
snapDir
=
GetDir
(
snap
)
;
snapDir
.
normalize
(
)
;
let
snapFile
=
GetSubdirFile
(
snapDir
)
;
await
createFile
(
snapFile
.
path
)
;
ok
(
await
OS
.
File
.
exists
(
snapFile
.
path
)
SNAP
{
snapFile
.
path
}
was
created
)
;
info
(
SNAP
(
file
)
{
snapFile
.
path
}
was
created
)
;
tests
.
push
(
{
desc
:
SNAP
(
{
snapDir
.
path
}
=
>
{
snapFile
.
path
}
)
ok
:
snapExpectedResult
browser
:
webBrowser
file
:
snapFile
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readFile
}
)
;
await
runTestsList
(
tests
)
;
}
async
function
testFileAccessWindowsOnly
(
)
{
if
(
!
isWin
(
)
)
{
return
;
}
let
webBrowser
=
GetWebBrowser
(
)
;
let
tests
=
[
]
;
let
extDir
=
GetPerUserExtensionDir
(
)
;
tests
.
push
(
{
desc
:
"
per
-
user
extensions
dir
"
ok
:
true
browser
:
webBrowser
file
:
extDir
minLevel
:
minHomeReadSandboxLevel
(
)
func
:
readDir
}
)
;
await
runTestsList
(
tests
)
;
}
function
cleanupBrowserTabs
(
)
{
let
fileBrowser
=
GetFileBrowser
(
)
;
if
(
fileBrowser
.
selectedTab
)
{
gBrowser
.
removeTab
(
fileBrowser
.
selectedTab
)
;
}
let
webBrowser
=
GetWebBrowser
(
)
;
if
(
webBrowser
.
selectedTab
)
{
gBrowser
.
removeTab
(
webBrowser
.
selectedTab
)
;
}
let
tab1
=
gBrowser
.
tabs
[
1
]
;
if
(
tab1
)
{
gBrowser
.
removeTab
(
tab1
)
;
}
}
