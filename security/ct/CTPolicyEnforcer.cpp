#
include
"
CTPolicyEnforcer
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
algorithm
>
#
include
<
stdint
.
h
>
#
include
<
vector
>
namespace
mozilla
{
namespace
ct
{
using
namespace
mozilla
:
:
pkix
;
static
size_t
GetRequiredEmbeddedSctsCount
(
size_t
certLifetimeInFullCalendarMonths
)
{
return
1
+
(
certLifetimeInFullCalendarMonths
+
9
)
/
12
;
}
static
bool
HasValidEmbeddedSct
(
const
VerifiedSCTList
&
verifiedScts
)
{
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
if
(
verifiedSct
.
logState
=
=
CTLogState
:
:
Admissible
&
&
verifiedSct
.
origin
=
=
SCTOrigin
:
:
Embedded
)
{
return
true
;
}
}
return
false
;
}
static
bool
HasValidNonEmbeddedSct
(
const
VerifiedSCTList
&
verifiedScts
)
{
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
if
(
verifiedSct
.
logState
=
=
CTLogState
:
:
Admissible
&
&
(
verifiedSct
.
origin
=
=
SCTOrigin
:
:
TLSExtension
|
|
verifiedSct
.
origin
=
=
SCTOrigin
:
:
OCSPResponse
)
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
SelectFunc
>
void
CountIndependentLogOperatorsForSelectedScts
(
const
VerifiedSCTList
&
verifiedScts
const
CTLogOperatorList
&
dependentOperators
size_t
&
count
SelectFunc
selected
)
{
CTLogOperatorList
operatorIds
;
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
CTLogOperatorId
sctLogOperatorId
=
verifiedSct
.
logOperatorId
;
bool
isDependentOperator
=
false
;
for
(
CTLogOperatorId
dependentOperator
:
dependentOperators
)
{
if
(
sctLogOperatorId
=
=
dependentOperator
)
{
isDependentOperator
=
true
;
break
;
}
}
if
(
isDependentOperator
|
|
!
selected
(
verifiedSct
)
)
{
continue
;
}
bool
alreadyAdded
=
false
;
for
(
CTLogOperatorId
id
:
operatorIds
)
{
if
(
id
=
=
sctLogOperatorId
)
{
alreadyAdded
=
true
;
break
;
}
}
if
(
!
alreadyAdded
)
{
operatorIds
.
push_back
(
sctLogOperatorId
)
;
}
}
count
=
operatorIds
.
size
(
)
;
}
template
<
typename
SelectFunc
>
static
void
CountLogsForSelectedScts
(
const
VerifiedSCTList
&
verifiedScts
size_t
&
count
SelectFunc
selected
)
{
std
:
:
vector
<
const
Buffer
*
>
logIds
;
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
if
(
!
selected
(
verifiedSct
)
)
{
continue
;
}
const
Buffer
*
sctLogId
=
&
verifiedSct
.
sct
.
logId
;
bool
alreadyAdded
=
false
;
for
(
const
Buffer
*
logId
:
logIds
)
{
if
(
*
logId
=
=
*
sctLogId
)
{
alreadyAdded
=
true
;
break
;
}
}
if
(
!
alreadyAdded
)
{
logIds
.
push_back
(
sctLogId
)
;
}
}
count
=
logIds
.
size
(
)
;
}
static
uint64_t
GetEffectiveCertIssuanceTime
(
const
VerifiedSCTList
&
verifiedScts
)
{
uint64_t
result
=
UINT64_MAX
;
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
if
(
verifiedSct
.
logState
=
=
CTLogState
:
:
Admissible
)
{
result
=
std
:
:
min
(
result
verifiedSct
.
sct
.
timestamp
)
;
}
}
return
result
;
}
static
bool
LogWasQualifiedForSct
(
const
VerifiedSCT
&
verifiedSct
uint64_t
certIssuanceTime
)
{
switch
(
verifiedSct
.
logState
)
{
case
CTLogState
:
:
Admissible
:
return
true
;
case
CTLogState
:
:
Retired
:
{
uint64_t
logRetirementTime
=
verifiedSct
.
logTimestamp
;
return
certIssuanceTime
<
logRetirementTime
&
&
verifiedSct
.
sct
.
timestamp
<
logRetirementTime
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
verifiedSct
.
logState
must
be
Admissible
or
Retired
"
)
;
return
false
;
}
static
void
CheckOperatorDiversityCompliance
(
const
VerifiedSCTList
&
verifiedScts
uint64_t
certIssuanceTime
const
CTLogOperatorList
&
dependentOperators
bool
&
compliant
)
{
size_t
independentOperatorsCount
;
CountIndependentLogOperatorsForSelectedScts
(
verifiedScts
dependentOperators
independentOperatorsCount
[
certIssuanceTime
]
(
const
VerifiedSCT
&
verifiedSct
)
-
>
bool
{
return
LogWasQualifiedForSct
(
verifiedSct
certIssuanceTime
)
;
}
)
;
compliant
=
independentOperatorsCount
>
=
2
;
}
static
void
CheckNonEmbeddedCompliance
(
const
VerifiedSCTList
&
verifiedScts
bool
&
compliant
)
{
if
(
!
HasValidNonEmbeddedSct
(
verifiedScts
)
)
{
compliant
=
false
;
return
;
}
size_t
validSctsCount
;
CountLogsForSelectedScts
(
verifiedScts
validSctsCount
[
]
(
const
VerifiedSCT
&
verifiedSct
)
-
>
bool
{
return
verifiedSct
.
logState
=
=
CTLogState
:
:
Admissible
;
}
)
;
compliant
=
validSctsCount
>
=
2
;
}
static
void
CheckEmbeddedCompliance
(
const
VerifiedSCTList
&
verifiedScts
size_t
certLifetimeInCalendarMonths
uint64_t
certIssuanceTime
bool
&
compliant
)
{
if
(
!
HasValidEmbeddedSct
(
verifiedScts
)
)
{
compliant
=
false
;
return
;
}
size_t
embeddedSctsCount
;
CountLogsForSelectedScts
(
verifiedScts
embeddedSctsCount
[
certIssuanceTime
]
(
const
VerifiedSCT
&
verifiedSct
)
-
>
bool
{
return
verifiedSct
.
origin
=
=
SCTOrigin
:
:
Embedded
&
&
LogWasQualifiedForSct
(
verifiedSct
certIssuanceTime
)
;
}
)
;
size_t
requiredSctsCount
=
GetRequiredEmbeddedSctsCount
(
certLifetimeInCalendarMonths
)
;
compliant
=
embeddedSctsCount
>
=
requiredSctsCount
;
}
void
CTPolicyEnforcer
:
:
CheckCompliance
(
const
VerifiedSCTList
&
verifiedScts
size_t
certLifetimeInCalendarMonths
const
CTLogOperatorList
&
dependentOperators
CTPolicyCompliance
&
compliance
)
{
uint64_t
certIssuanceTime
=
GetEffectiveCertIssuanceTime
(
verifiedScts
)
;
bool
diversityOK
;
CheckOperatorDiversityCompliance
(
verifiedScts
certIssuanceTime
dependentOperators
diversityOK
)
;
bool
nonEmbeddedCaseOK
;
CheckNonEmbeddedCompliance
(
verifiedScts
nonEmbeddedCaseOK
)
;
bool
embeddedCaseOK
;
CheckEmbeddedCompliance
(
verifiedScts
certLifetimeInCalendarMonths
certIssuanceTime
embeddedCaseOK
)
;
if
(
nonEmbeddedCaseOK
|
|
embeddedCaseOK
)
{
compliance
=
diversityOK
?
CTPolicyCompliance
:
:
Compliant
:
CTPolicyCompliance
:
:
NotDiverseScts
;
}
else
{
compliance
=
CTPolicyCompliance
:
:
NotEnoughScts
;
}
switch
(
compliance
)
{
case
CTPolicyCompliance
:
:
Compliant
:
case
CTPolicyCompliance
:
:
NotEnoughScts
:
case
CTPolicyCompliance
:
:
NotDiverseScts
:
break
;
case
CTPolicyCompliance
:
:
Unknown
:
default
:
assert
(
false
)
;
}
}
}
}
