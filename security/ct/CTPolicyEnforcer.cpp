#
include
"
CTPolicyEnforcer
.
h
"
#
include
<
algorithm
>
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
extern
mozilla
:
:
LazyLogModule
gCertVerifierLog
;
namespace
mozilla
{
namespace
ct
{
using
namespace
mozilla
:
:
pkix
;
static
size_t
GetRequiredEmbeddedSctsCount
(
size_t
certLifetimeInFullCalendarMonths
)
{
return
1
+
(
certLifetimeInFullCalendarMonths
+
9
)
/
12
;
}
static
bool
HasValidEmbeddedSct
(
const
VerifiedSCTList
&
verifiedScts
)
{
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
if
(
verifiedSct
.
status
=
=
VerifiedSCT
:
:
Status
:
:
Valid
&
&
verifiedSct
.
origin
=
=
VerifiedSCT
:
:
Origin
:
:
Embedded
)
{
return
true
;
}
}
return
false
;
}
static
bool
HasValidNonEmbeddedSct
(
const
VerifiedSCTList
&
verifiedScts
)
{
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
if
(
verifiedSct
.
status
=
=
VerifiedSCT
:
:
Status
:
:
Valid
&
&
(
verifiedSct
.
origin
=
=
VerifiedSCT
:
:
Origin
:
:
TLSExtension
|
|
verifiedSct
.
origin
=
=
VerifiedSCT
:
:
Origin
:
:
OCSPResponse
)
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
SelectFunc
>
static
Result
CountIndependentLogOperatorsForSelectedScts
(
const
VerifiedSCTList
&
verifiedScts
const
CTLogOperatorList
&
dependentOperators
size_t
&
count
SelectFunc
selected
)
{
CTLogOperatorList
operatorIds
;
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
CTLogOperatorId
sctLogOperatorId
=
verifiedSct
.
logOperatorId
;
bool
isDependentOperator
=
false
;
for
(
CTLogOperatorId
dependentOperator
:
dependentOperators
)
{
if
(
sctLogOperatorId
=
=
dependentOperator
)
{
isDependentOperator
=
true
;
break
;
}
}
if
(
isDependentOperator
|
|
!
selected
(
verifiedSct
)
)
{
continue
;
}
bool
alreadyAdded
=
false
;
for
(
CTLogOperatorId
id
:
operatorIds
)
{
if
(
id
=
=
sctLogOperatorId
)
{
alreadyAdded
=
true
;
break
;
}
}
if
(
!
alreadyAdded
)
{
if
(
!
operatorIds
.
append
(
sctLogOperatorId
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
}
count
=
operatorIds
.
length
(
)
;
return
Success
;
}
template
<
typename
SelectFunc
>
static
Result
CountLogsForSelectedScts
(
const
VerifiedSCTList
&
verifiedScts
size_t
&
count
SelectFunc
selected
)
{
Vector
<
const
Buffer
*
8
>
logIds
;
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
if
(
!
selected
(
verifiedSct
)
)
{
continue
;
}
const
Buffer
*
sctLogId
=
&
verifiedSct
.
sct
.
logId
;
bool
alreadyAdded
=
false
;
for
(
const
Buffer
*
logId
:
logIds
)
{
if
(
*
logId
=
=
*
sctLogId
)
{
alreadyAdded
=
true
;
break
;
}
}
if
(
!
alreadyAdded
)
{
if
(
!
logIds
.
append
(
sctLogId
)
)
{
return
Result
:
:
FATAL_ERROR_NO_MEMORY
;
}
}
}
count
=
logIds
.
length
(
)
;
return
Success
;
}
static
uint64_t
GetEffectiveCertIssuanceTime
(
const
VerifiedSCTList
&
verifiedScts
)
{
uint64_t
result
=
UINT64_MAX
;
for
(
const
VerifiedSCT
&
verifiedSct
:
verifiedScts
)
{
if
(
verifiedSct
.
status
=
=
VerifiedSCT
:
:
Status
:
:
Valid
)
{
result
=
std
:
:
min
(
result
verifiedSct
.
sct
.
timestamp
)
;
}
}
return
result
;
}
static
bool
LogWasQualifiedForSct
(
const
VerifiedSCT
&
verifiedSct
uint64_t
certIssuanceTime
)
{
if
(
verifiedSct
.
status
=
=
VerifiedSCT
:
:
Status
:
:
Valid
)
{
return
true
;
}
if
(
verifiedSct
.
status
=
=
VerifiedSCT
:
:
Status
:
:
ValidFromDisqualifiedLog
)
{
uint64_t
logDisqualificationTime
=
verifiedSct
.
logDisqualificationTime
;
return
certIssuanceTime
<
logDisqualificationTime
&
&
verifiedSct
.
sct
.
timestamp
<
logDisqualificationTime
;
}
return
false
;
}
static
Result
CheckOperatorDiversityCompliance
(
const
VerifiedSCTList
&
verifiedScts
uint64_t
certIssuanceTime
const
CTLogOperatorList
&
dependentOperators
bool
&
compliant
)
{
size_t
independentOperatorsCount
;
Result
rv
=
CountIndependentLogOperatorsForSelectedScts
(
verifiedScts
dependentOperators
independentOperatorsCount
[
certIssuanceTime
]
(
const
VerifiedSCT
&
verifiedSct
)
-
>
bool
{
return
LogWasQualifiedForSct
(
verifiedSct
certIssuanceTime
)
;
}
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
compliant
=
independentOperatorsCount
>
=
2
;
return
Success
;
}
static
Result
CheckNonEmbeddedCompliance
(
const
VerifiedSCTList
&
verifiedScts
bool
&
compliant
)
{
if
(
!
HasValidNonEmbeddedSct
(
verifiedScts
)
)
{
compliant
=
false
;
return
Success
;
}
size_t
validSctsCount
;
Result
rv
=
CountLogsForSelectedScts
(
verifiedScts
validSctsCount
[
]
(
const
VerifiedSCT
&
verifiedSct
)
-
>
bool
{
return
verifiedSct
.
status
=
=
VerifiedSCT
:
:
Status
:
:
Valid
;
}
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
CT
Policy
non
-
embedded
case
status
:
validSCTs
=
%
zu
\
n
"
validSctsCount
)
)
;
compliant
=
validSctsCount
>
=
2
;
return
Success
;
}
static
Result
CheckEmbeddedCompliance
(
const
VerifiedSCTList
&
verifiedScts
size_t
certLifetimeInCalendarMonths
uint64_t
certIssuanceTime
bool
&
compliant
)
{
if
(
!
HasValidEmbeddedSct
(
verifiedScts
)
)
{
compliant
=
false
;
return
Success
;
}
size_t
embeddedSctsCount
;
Result
rv
=
CountLogsForSelectedScts
(
verifiedScts
embeddedSctsCount
[
certIssuanceTime
]
(
const
VerifiedSCT
&
verifiedSct
)
-
>
bool
{
return
verifiedSct
.
origin
=
=
VerifiedSCT
:
:
Origin
:
:
Embedded
&
&
LogWasQualifiedForSct
(
verifiedSct
certIssuanceTime
)
;
}
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
size_t
requiredSctsCount
=
GetRequiredEmbeddedSctsCount
(
certLifetimeInCalendarMonths
)
;
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
CT
Policy
embedded
case
status
:
"
"
requiredSCTs
=
%
zu
embeddedSCTs
=
%
zu
\
n
"
requiredSctsCount
embeddedSctsCount
)
)
;
compliant
=
embeddedSctsCount
>
=
requiredSctsCount
;
return
Success
;
}
Result
CTPolicyEnforcer
:
:
CheckCompliance
(
const
VerifiedSCTList
&
verifiedScts
size_t
certLifetimeInCalendarMonths
const
CTLogOperatorList
&
dependentOperators
CTPolicyCompliance
&
compliance
)
{
uint64_t
certIssuanceTime
=
GetEffectiveCertIssuanceTime
(
verifiedScts
)
;
bool
diversityOK
;
Result
rv
=
CheckOperatorDiversityCompliance
(
verifiedScts
certIssuanceTime
dependentOperators
diversityOK
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
diversityOK
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
CT
Policy
:
diversity
satisfied
\
n
"
)
)
;
}
bool
nonEmbeddedCaseOK
;
rv
=
CheckNonEmbeddedCompliance
(
verifiedScts
nonEmbeddedCaseOK
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
nonEmbeddedCaseOK
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
CT
Policy
:
non
-
embedded
case
satisfied
)
\
n
"
)
)
;
}
bool
embeddedCaseOK
;
rv
=
CheckEmbeddedCompliance
(
verifiedScts
certLifetimeInCalendarMonths
certIssuanceTime
embeddedCaseOK
)
;
if
(
rv
!
=
Success
)
{
return
rv
;
}
if
(
embeddedCaseOK
)
{
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
CT
Policy
:
embedded
case
satisfied
\
n
"
)
)
;
}
if
(
nonEmbeddedCaseOK
|
|
embeddedCaseOK
)
{
compliance
=
diversityOK
?
CTPolicyCompliance
:
:
Compliant
:
CTPolicyCompliance
:
:
NotDiverseScts
;
}
else
{
compliance
=
CTPolicyCompliance
:
:
NotEnoughScts
;
}
switch
(
compliance
)
{
case
CTPolicyCompliance
:
:
Compliant
:
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
CT
Policy
compliance
:
Compliant
\
n
"
)
)
;
break
;
case
CTPolicyCompliance
:
:
NotEnoughScts
:
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
CT
Policy
compliance
:
NotEnoughScts
\
n
"
)
)
;
break
;
case
CTPolicyCompliance
:
:
NotDiverseScts
:
MOZ_LOG
(
gCertVerifierLog
LogLevel
:
:
Debug
(
"
CT
Policy
compliance
:
NotDiverseScts
\
n
"
)
)
;
break
;
case
CTPolicyCompliance
:
:
Unknown
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
CTPolicyCompliance
type
"
)
;
}
return
Success
;
}
}
}
