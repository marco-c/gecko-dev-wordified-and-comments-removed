#
include
"
SignedCertificateTimestamp
.
h
"
#
include
"
CTUtils
.
h
"
namespace
mozilla
{
namespace
ct
{
pkix
:
:
Result
SignedCertificateTimestamp
:
:
DecodeExtensions
(
)
{
if
(
extensions
.
empty
(
)
)
{
return
pkix
:
:
Success
;
}
const
size_t
kExtensionDataLengthBytes
=
2
;
const
size_t
kExtensionTypeLength
=
1
;
const
uint8_t
kExtensionTypeLeafIndex
=
0
;
pkix
:
:
Input
input
;
pkix
:
:
Result
rv
=
input
.
Init
(
extensions
.
data
(
)
extensions
.
size
(
)
)
;
if
(
rv
!
=
pkix
:
:
Success
)
{
return
rv
;
}
pkix
:
:
Reader
reader
(
input
)
;
while
(
!
reader
.
AtEnd
(
)
)
{
uint8_t
extensionType
;
rv
=
ReadUint
<
kExtensionTypeLength
>
(
reader
extensionType
)
;
if
(
rv
!
=
pkix
:
:
Success
)
{
return
rv
;
}
pkix
:
:
Input
extensionData
;
rv
=
ReadVariableBytes
<
kExtensionDataLengthBytes
>
(
reader
extensionData
)
;
if
(
rv
!
=
pkix
:
:
Success
)
{
return
rv
;
}
if
(
extensionType
=
=
kExtensionTypeLeafIndex
)
{
if
(
leafIndex
.
isSome
(
)
)
{
return
pkix
:
:
Result
:
:
ERROR_EXTENSION_VALUE_INVALID
;
}
const
size_t
kLeafIndexLength
=
5
;
uint64_t
leafIndexValue
;
pkix
:
:
Reader
leafIndexReader
(
extensionData
)
;
rv
=
ReadUint
<
kLeafIndexLength
>
(
leafIndexReader
leafIndexValue
)
;
if
(
rv
!
=
pkix
:
:
Success
)
{
return
rv
;
}
if
(
!
leafIndexReader
.
AtEnd
(
)
)
{
return
pkix
:
:
Result
:
:
ERROR_EXTENSION_VALUE_INVALID
;
}
leafIndex
.
emplace
(
leafIndexValue
)
;
}
}
return
pkix
:
:
Success
;
}
void
LogEntry
:
:
Reset
(
)
{
type
=
LogEntry
:
:
Type
:
:
X509
;
leafCertificate
.
clear
(
)
;
issuerKeyHash
.
clear
(
)
;
tbsCertificate
.
clear
(
)
;
}
bool
DigitallySigned
:
:
SignatureParametersMatch
(
HashAlgorithm
aHashAlgorithm
SignatureAlgorithm
aSignatureAlgorithm
)
const
{
return
(
hashAlgorithm
=
=
aHashAlgorithm
)
&
&
(
signatureAlgorithm
=
=
aSignatureAlgorithm
)
;
}
}
}
