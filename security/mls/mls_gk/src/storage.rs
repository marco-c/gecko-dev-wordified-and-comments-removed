use
nsstring
:
:
nsACString
;
use
std
:
:
fs
;
use
std
:
:
io
;
pub
fn
get_storage_path
(
storage_prefix
:
&
nsACString
)
-
>
String
{
format
!
(
"
{
storage_prefix
}
.
sqlite
.
enc
"
)
}
pub
fn
get_key_path
(
storage_prefix
:
&
nsACString
)
-
>
String
{
format
!
(
"
{
storage_prefix
}
.
key
"
)
}
fn
read_existing_storage_key
(
key_path
:
&
str
)
-
>
io
:
:
Result
<
[
u8
;
32
]
>
{
let
key_hex
=
fs
:
:
read_to_string
(
key_path
)
?
;
let
bytes
=
hex
:
:
decode
(
&
key_hex
)
.
map_err
(
|
e
|
io
:
:
Error
:
:
other
(
e
)
)
?
;
bytes
[
.
.
]
.
try_into
(
)
.
map_err
(
|
e
|
io
:
:
Error
:
:
other
(
e
)
)
}
pub
fn
get_storage_key
(
storage_prefix
:
&
nsACString
)
-
>
io
:
:
Result
<
[
u8
;
32
]
>
{
let
key_path
=
get_key_path
(
storage_prefix
)
;
if
let
Ok
(
key
)
=
read_existing_storage_key
(
&
key_path
)
{
return
Ok
(
key
)
;
}
nss_gk_api
:
:
init
(
)
;
let
key
:
[
u8
;
32
]
=
nss_gk_api
:
:
p11
:
:
random
(
32
)
[
.
.
]
.
try_into
(
)
.
expect
(
"
nss
returned
the
wrong
number
of
bytes
"
)
;
std
:
:
fs
:
:
write
(
key_path
&
hex
:
:
encode
(
&
key
)
)
?
;
Ok
(
key
)
}
