#
ifndef
_SYS_SOCKET_H_
#
define
_SYS_SOCKET_H_
#
define
SOCK_STREAM
1
/
*
stream
socket
*
/
#
define
SOCK_DGRAM
2
/
*
datagram
socket
*
/
#
define
SOCK_RAW
3
/
*
raw
-
protocol
interface
*
/
#
define
SOCK_RDM
4
/
*
reliably
-
delivered
message
*
/
#
define
SOCK_SEQPACKET
5
/
*
sequenced
packet
stream
*
/
#
define
SO_DEBUG
0x0001
/
*
turn
on
debugging
info
recording
*
/
#
define
SO_ACCEPTCONN
0x0002
/
*
socket
has
had
listen
(
)
*
/
#
define
SO_REUSEADDR
0x0004
/
*
allow
local
address
reuse
*
/
#
define
SO_KEEPALIVE
0x0008
/
*
keep
connections
alive
*
/
#
define
SO_DONTROUTE
0x0010
/
*
just
use
interface
addresses
*
/
#
define
SO_BROADCAST
0x0020
/
*
permit
sending
of
broadcast
msgs
*
/
#
define
SO_USELOOPBACK
0x0040
/
*
bypass
hardware
when
possible
*
/
#
define
SO_LINGER
0x0080
/
*
linger
on
close
if
data
present
*
/
#
define
SO_OOBINLINE
0x0100
/
*
leave
received
OOB
data
in
line
*
/
#
define
SO_REUSEPORT
0x0200
/
*
allow
local
address
&
port
reuse
*
/
#
define
SO_SNDBUF
0x1001
/
*
send
buffer
size
*
/
#
define
SO_RCVBUF
0x1002
/
*
receive
buffer
size
*
/
#
define
SO_SNDLOWAT
0x1003
/
*
send
low
-
water
mark
*
/
#
define
SO_RCVLOWAT
0x1004
/
*
receive
low
-
water
mark
*
/
#
define
SO_SNDTIMEO
0x1005
/
*
send
timeout
*
/
#
define
SO_RCVTIMEO
0x1006
/
*
receive
timeout
*
/
#
define
SO_ERROR
0x1007
/
*
get
error
status
and
clear
*
/
#
define
SO_TYPE
0x1008
/
*
get
socket
type
*
/
typedef
unsigned
socklen_t
;
struct
linger
{
int
l_onoff
;
int
l_linger
;
}
;
#
define
SOL_SOCKET
0xffff
/
*
options
for
socket
level
*
/
#
define
AF_UNSPEC
0
/
*
unspecified
*
/
#
define
AF_LOCAL
1
/
*
local
to
host
(
pipes
portals
)
*
/
#
define
AF_UNIX
AF_LOCAL
/
*
backward
compatibility
*
/
#
define
AF_INET
2
/
*
internetwork
:
UDP
TCP
etc
.
*
/
#
define
AF_PPC
3
/
*
PPC
Toolbox
*
/
#
define
AF_PAP
4
/
*
Printer
Access
Protocol
*
/
#
define
AF_APPLETALK
16
/
*
Apple
Talk
*
/
#
define
ATALK_SYMADDR
272
/
*
Symbolic
Address
for
AppleTalk
*
/
#
define
AF_MAX
20
#
define
PF_UNSPEC
0
/
*
unspecified
*
/
#
define
PF_LOCAL
1
/
*
local
to
host
(
pipes
portals
)
*
/
#
define
PF_UNIX
AF_LOCAL
/
*
backward
compatibility
*
/
#
define
PF_INET
2
/
*
internetwork
:
UDP
TCP
etc
.
*
/
#
define
PF_PPC
3
/
*
PPC
Toolbox
*
/
#
define
PF_PAP
4
/
*
Printer
Access
Protocol
*
/
#
define
PF_APPLETALK
16
/
*
Apple
Talk
*
/
#
define
SHUT_RD
0
#
define
SHUT_WR
1
#
define
SHUT_RDWR
2
#
ifndef
_SA_FAMILY_T_DEFINED
#
define
_SA_FAMILY_T_DEFINED
typedef
unsigned
short
sa_family_t
;
#
endif
struct
sockaddr
{
sa_family_t
sa_family
;
char
sa_data
[
14
]
;
}
;
#
define
NET_MAXID
AF_MAX
#
define
CTL_NET_NAMES
{
\
{
0
0
}
\
{
"
unix
"
CTLTYPE_NODE
}
\
{
"
inet
"
CTLTYPE_NODE
}
\
{
"
ppc
"
CTLTYPE_NODE
}
\
{
"
pap
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
"
CTLTYPE_NODE
}
\
{
"
appletalk
"
CTLTYPE_NODE
}
\
}
#
define
NET_RT_DUMP
1
/
*
dump
;
may
limit
to
a
.
f
.
*
/
#
define
NET_RT_FLAGS
2
/
*
by
flags
e
.
g
.
RESOLVING
*
/
#
define
NET_RT_IFLIST
3
/
*
survey
interface
list
*
/
#
define
NET_RT_MAXID
4
#
define
CTL_NET_RT_NAMES
{
\
{
0
0
}
\
{
"
dump
"
CTLTYPE_STRUCT
}
\
{
"
flags
"
CTLTYPE_STRUCT
}
\
{
"
iflist
"
CTLTYPE_STRUCT
}
\
}
#
define
SOMAXCONN
5
struct
msghdr
{
void
*
msg_name
;
socklen_t
msg_namelen
;
struct
iovec
*
msg_iov
;
int
msg_iovlen
;
void
*
msg_control
;
socklen_t
msg_controllen
;
int
msg_flags
;
}
;
#
define
MSG_OOB
0x1
/
*
process
out
-
of
-
band
data
*
/
#
define
MSG_PEEK
0x2
/
*
peek
at
incoming
message
*
/
#
define
MSG_DONTROUTE
0x4
/
*
send
without
using
routing
tables
*
/
#
define
MSG_EOR
0x8
/
*
data
completes
record
*
/
#
define
MSG_TRUNC
0x10
/
*
data
discarded
before
delivery
*
/
#
define
MSG_CTRUNC
0x20
/
*
control
data
lost
before
delivery
*
/
#
define
MSG_WAITALL
0x40
/
*
wait
for
full
request
or
error
*
/
#
define
MSG_DONTWAIT
0x80
/
*
this
message
should
be
nonblocking
*
/
struct
cmsghdr
{
socklen_t
cmsg_len
;
int
cmsg_level
;
int
cmsg_type
;
}
;
#
define
CMSG_DATA
(
cmsg
)
(
(
u_char
*
)
(
(
cmsg
)
+
1
)
)
#
define
CMSG_NXTHDR
(
mhdr
cmsg
)
\
(
(
(
caddr_t
)
(
cmsg
)
+
(
cmsg
)
-
>
cmsg_len
+
sizeof
(
struct
cmsghdr
)
>
\
(
mhdr
)
-
>
msg_control
+
(
mhdr
)
-
>
msg_controllen
)
?
\
(
struct
cmsghdr
*
)
NULL
:
\
(
struct
cmsghdr
*
)
(
(
caddr_t
)
(
cmsg
)
+
ALIGN
(
(
cmsg
)
-
>
cmsg_len
)
)
)
#
define
CMSG_FIRSTHDR
(
mhdr
)
(
(
struct
cmsghdr
*
)
(
mhdr
)
-
>
msg_control
)
#
define
SCM_RIGHTS
0x01
/
*
access
rights
(
array
of
int
)
*
/
#
include
<
sys
/
cdefs
.
h
>
__BEGIN_DECLS
int
accept
__P
(
(
int
struct
sockaddr
*
socklen_t
*
)
)
;
int
bind
__P
(
(
int
const
struct
sockaddr
*
socklen_t
)
)
;
int
connect
__P
(
(
int
const
struct
sockaddr
*
socklen_t
)
)
;
int
getpeername
__P
(
(
int
struct
sockaddr
*
socklen_t
*
)
)
;
int
getsockname
__P
(
(
int
struct
sockaddr
*
socklen_t
*
)
)
;
int
getsockopt
__P
(
(
int
int
int
void
*
socklen_t
*
)
)
;
int
listen
__P
(
(
int
int
)
)
;
ssize_t
recv
__P
(
(
int
void
*
size_t
int
)
)
;
ssize_t
recvfrom
__P
(
(
int
void
*
size_t
int
struct
sockaddr
*
socklen_t
*
)
)
;
ssize_t
recvmsg
__P
(
(
int
struct
msghdr
*
int
)
)
;
ssize_t
send
__P
(
(
int
const
void
*
size_t
int
)
)
;
ssize_t
sendto
__P
(
(
int
const
void
*
size_t
int
const
struct
sockaddr
*
socklen_t
)
)
;
ssize_t
sendmsg
__P
(
(
int
const
struct
msghdr
*
int
)
)
;
int
setsockopt
__P
(
(
int
int
int
const
void
*
socklen_t
)
)
;
int
shutdown
__P
(
(
int
int
)
)
;
int
socket
__P
(
(
int
int
int
)
)
;
int
socketpair
__P
(
(
int
int
int
int
*
)
)
;
__END_DECLS
#
endif
