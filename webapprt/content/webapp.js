var
Cc
=
Components
.
classes
;
var
Ci
=
Components
.
interfaces
;
var
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
webapprt
/
modules
/
WebappRT
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAppBrowser
"
(
)
=
>
document
.
getElementById
(
"
content
"
)
)
;
#
ifdef
MOZ_CRASHREPORTER
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gCrashReporter
"
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
"
nsICrashReporter
"
)
;
#
endif
var
progressListener
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
onLocationChange
:
function
onLocationChange
(
progress
request
location
flags
)
{
let
pageTooltip
=
document
.
getElementById
(
"
contentAreaTooltip
"
)
;
let
tooltipNode
=
pageTooltip
.
triggerNode
;
if
(
tooltipNode
)
{
if
(
progress
.
isTopLevel
)
{
pageTooltip
.
hidePopup
(
)
;
}
else
{
for
(
let
tooltipWindow
=
tooltipNode
.
ownerDocument
.
defaultView
;
tooltipWindow
!
=
tooltipWindow
.
parent
;
tooltipWindow
=
tooltipWindow
.
parent
)
{
if
(
tooltipWindow
=
=
progress
.
DOMWindow
)
{
pageTooltip
.
hidePopup
(
)
;
break
;
}
}
}
}
let
isSameOrigin
=
(
location
.
prePath
=
=
=
WebappRT
.
config
.
app
.
origin
)
;
let
title
=
WebappRT
.
localeManifest
.
name
;
if
(
!
isSameOrigin
)
{
title
=
location
.
prePath
+
"
-
"
+
title
;
}
document
.
documentElement
.
setAttribute
(
"
title
"
title
)
;
#
ifndef
XP_WIN
#
ifndef
XP_MACOSX
if
(
isSameOrigin
)
{
if
(
document
.
fullscreenElement
)
{
document
.
getElementById
(
"
main
-
menubar
"
)
.
style
.
display
=
"
none
"
;
}
}
#
endif
#
endif
}
onStateChange
:
function
onStateChange
(
aProgress
aRequest
aFlags
aStatus
)
{
if
(
aRequest
instanceof
Ci
.
nsIChannel
&
&
aFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
&
&
aFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
)
{
updateCrashReportURL
(
aRequest
.
URI
)
;
}
}
}
;
function
onOpenWindow
(
event
)
{
if
(
event
.
detail
.
name
=
=
=
"
_blank
"
)
{
let
uri
=
Services
.
io
.
newURI
(
event
.
detail
.
url
null
null
)
;
event
.
preventDefault
(
)
;
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
]
.
getService
(
Ci
.
nsIExternalProtocolService
)
.
getProtocolHandlerInfo
(
uri
.
scheme
)
.
launchWithURI
(
uri
)
;
}
}
function
onDOMContentLoaded
(
)
{
window
.
removeEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
if
(
gAppBrowser
.
docShell
.
appId
=
=
=
Ci
.
nsIScriptSecurityManager
.
NO_APP_ID
)
{
gAppBrowser
.
docShell
.
setIsApp
(
WebappRT
.
appID
)
;
}
}
window
.
addEventListener
(
"
DOMContentLoaded
"
onDOMContentLoaded
false
)
;
function
onLoad
(
)
{
window
.
removeEventListener
(
"
load
"
onLoad
false
)
;
gAppBrowser
.
addProgressListener
(
progressListener
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
updateMenuItems
(
)
;
gAppBrowser
.
addEventListener
(
"
mozbrowseropenwindow
"
onOpenWindow
)
;
}
window
.
addEventListener
(
"
load
"
onLoad
false
)
;
function
onUnload
(
)
{
gAppBrowser
.
removeProgressListener
(
progressListener
)
;
gAppBrowser
.
removeEventListener
(
"
mozbrowseropenwindow
"
onOpenWindow
)
;
}
window
.
addEventListener
(
"
unload
"
onUnload
false
)
;
#
ifndef
XP_MACOSX
document
.
addEventListener
(
'
fullscreenchange
'
function
(
)
{
if
(
document
.
fullscreenElement
)
{
document
.
getElementById
(
"
main
-
menubar
"
)
.
style
.
display
=
"
none
"
;
}
else
{
document
.
getElementById
(
"
main
-
menubar
"
)
.
style
.
display
=
"
"
;
}
}
false
)
;
#
endif
var
updateMenuItems
=
Task
.
async
(
function
*
(
)
{
#
ifdef
XP_MACOSX
yield
WebappRT
.
configPromise
;
let
manifest
=
WebappRT
.
localeManifest
;
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
webapprt
/
locale
/
webapp
.
properties
"
)
;
let
quitLabel
=
bundle
.
formatStringFromName
(
"
quitApplicationCmdMac
.
label
"
[
manifest
.
name
]
1
)
;
let
hideLabel
=
bundle
.
formatStringFromName
(
"
hideApplicationCmdMac
.
label
"
[
manifest
.
name
]
1
)
;
document
.
getElementById
(
"
menu_FileQuitItem
"
)
.
setAttribute
(
"
label
"
quitLabel
)
;
document
.
getElementById
(
"
menu_mac_hide_app
"
)
.
setAttribute
(
"
label
"
hideLabel
)
;
#
endif
}
)
;
#
ifndef
XP_MACOSX
var
gEditUIVisible
=
true
;
#
endif
function
updateEditUIVisibility
(
)
{
#
ifndef
XP_MACOSX
let
editMenuPopupState
=
document
.
getElementById
(
"
menu_EditPopup
"
)
.
state
;
let
contextMenuPopupState
=
document
.
getElementById
(
"
contentAreaContextMenu
"
)
.
state
;
gEditUIVisible
=
editMenuPopupState
=
=
"
showing
"
|
|
editMenuPopupState
=
=
"
open
"
|
|
contextMenuPopupState
=
=
"
showing
"
|
|
contextMenuPopupState
=
=
"
open
"
;
if
(
gEditUIVisible
)
{
goUpdateGlobalEditMenuItems
(
)
;
}
else
{
goSetCommandEnabled
(
"
cmd_undo
"
true
)
;
goSetCommandEnabled
(
"
cmd_redo
"
true
)
;
goSetCommandEnabled
(
"
cmd_cut
"
true
)
;
goSetCommandEnabled
(
"
cmd_copy
"
true
)
;
goSetCommandEnabled
(
"
cmd_paste
"
true
)
;
goSetCommandEnabled
(
"
cmd_selectAll
"
true
)
;
goSetCommandEnabled
(
"
cmd_delete
"
true
)
;
goSetCommandEnabled
(
"
cmd_switchTextDirection
"
true
)
;
}
#
endif
}
function
updateCrashReportURL
(
aURI
)
{
#
ifdef
MOZ_CRASHREPORTER
if
(
!
gCrashReporter
.
enabled
)
return
;
let
uri
=
aURI
.
clone
(
)
;
try
{
if
(
uri
.
userPass
!
=
"
"
)
{
uri
.
userPass
=
"
"
;
}
}
catch
(
e
)
{
}
gCrashReporter
.
annotateCrashReport
(
"
URL
"
uri
.
spec
)
;
#
endif
}
var
gContextMenu
=
null
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PageMenu
"
function
(
)
{
let
tmp
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PageMenu
.
jsm
"
tmp
)
;
return
new
tmp
.
PageMenu
(
)
;
}
)
;
function
showContextMenu
(
aEvent
aXULMenu
)
{
if
(
aEvent
.
target
!
=
aXULMenu
)
{
return
true
;
}
gContextMenu
=
new
nsContextMenu
(
aXULMenu
)
;
if
(
gContextMenu
.
shouldDisplay
)
{
updateEditUIVisibility
(
)
;
}
return
gContextMenu
.
shouldDisplay
;
}
function
hideContextMenu
(
aEvent
aXULMenu
)
{
if
(
aEvent
.
target
!
=
aXULMenu
)
{
return
;
}
gContextMenu
=
null
;
updateEditUIVisibility
(
)
;
}
function
nsContextMenu
(
aXULMenu
)
{
this
.
initMenu
(
aXULMenu
)
;
}
nsContextMenu
.
prototype
=
{
initMenu
:
function
(
aXULMenu
)
{
this
.
hasPageMenu
=
PageMenu
.
maybeBuildAndAttachMenu
(
document
.
popupNode
aXULMenu
)
;
this
.
shouldDisplay
=
this
.
hasPageMenu
;
}
}
;
