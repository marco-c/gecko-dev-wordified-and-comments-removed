#
include
"
gtest
/
gtest
.
h
"
#
include
<
sys
/
eventfd
.
h
>
#
include
<
sched
.
h
>
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsProfileLock
.
h
"
#
include
"
nsString
.
h
"
TEST
(
ProfileLock
RetryLock
)
{
char
templ
[
]
=
"
/
tmp
/
profilelocktest
.
XXXXXX
"
;
char
*
tmpdir
=
mkdtemp
(
templ
)
;
ASSERT_NE
(
tmpdir
nullptr
)
;
nsProfileLock
myLock
;
nsProfileLock
myLock2
;
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
dir
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
rv
=
dir
-
>
InitWithNativePath
(
nsCString
(
tmpdir
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
int
eventfd_fd
=
eventfd
(
0
0
)
;
ASSERT_GE
(
eventfd_fd
0
)
;
pid_t
childpid
=
fork
(
)
;
if
(
childpid
)
{
eventfd_t
value
;
EXPECT_EQ
(
0
eventfd_read
(
eventfd_fd
&
value
)
)
;
rv
=
myLock2
.
Lock
(
dir
nullptr
)
;
EXPECT_EQ
(
NS_ERROR_FILE_ACCESS_DENIED
rv
)
;
EXPECT_EQ
(
0
kill
(
childpid
SIGTERM
)
)
;
int
status
;
EXPECT_EQ
(
childpid
waitpid
(
childpid
&
status
0
)
)
;
rv
=
myLock2
.
Lock
(
dir
nullptr
)
;
EXPECT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
}
else
{
rv
=
myLock
.
Lock
(
dir
nullptr
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
EXPECT_EQ
(
0
eventfd_write
(
eventfd_fd
1
)
)
;
for
(
;
;
)
sleep
(
1
)
;
}
close
(
eventfd_fd
)
;
myLock
.
Cleanup
(
)
;
myLock2
.
Cleanup
(
)
;
}
