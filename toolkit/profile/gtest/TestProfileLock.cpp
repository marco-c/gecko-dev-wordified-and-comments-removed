#
include
"
gtest
/
gtest
.
h
"
#
include
<
sys
/
eventfd
.
h
>
#
include
<
sched
.
h
>
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsProfileLock
.
h
"
#
include
"
nsString
.
h
"
static
void
CleanParentLock
(
const
char
*
tmpdir
)
{
char
permanent_lockfile
[
]
=
"
/
.
parentlock
"
;
char
*
parentlock_name
;
size_t
parentlock_name_size
=
strlen
(
tmpdir
)
+
strlen
(
permanent_lockfile
)
+
1
;
parentlock_name
=
(
char
*
)
malloc
(
parentlock_name_size
)
;
strcpy
(
parentlock_name
tmpdir
)
;
strcat
(
parentlock_name
permanent_lockfile
)
;
EXPECT_EQ
(
0
unlink
(
parentlock_name
)
)
;
EXPECT_EQ
(
0
rmdir
(
tmpdir
)
)
;
free
(
parentlock_name
)
;
}
TEST
(
ProfileLock
BasicLock
)
{
char
templ
[
]
=
"
/
tmp
/
profilelocktest
.
XXXXXX
"
;
char
*
tmpdir
=
mkdtemp
(
templ
)
;
ASSERT_NE
(
tmpdir
nullptr
)
;
{
nsProfileLock
myLock
;
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
dir
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
rv
=
dir
-
>
InitWithNativePath
(
nsCString
(
tmpdir
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
rv
=
myLock
.
Lock
(
dir
nullptr
)
;
EXPECT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
}
CleanParentLock
(
tmpdir
)
;
}
TEST
(
ProfileLock
RetryLock
)
{
char
templ
[
]
=
"
/
tmp
/
profilelocktest
.
XXXXXX
"
;
char
*
tmpdir
=
mkdtemp
(
templ
)
;
ASSERT_NE
(
tmpdir
nullptr
)
;
{
nsProfileLock
myLock
;
nsProfileLock
myLock2
;
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
dir
(
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
rv
=
dir
-
>
InitWithNativePath
(
nsCString
(
tmpdir
)
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
int
eventfd_fd
=
eventfd
(
0
0
)
;
ASSERT_GE
(
eventfd_fd
0
)
;
pid_t
childpid
=
fork
(
)
;
if
(
childpid
)
{
eventfd_t
value
;
EXPECT_EQ
(
0
eventfd_read
(
eventfd_fd
&
value
)
)
;
rv
=
myLock2
.
Lock
(
dir
nullptr
)
;
EXPECT_EQ
(
NS_ERROR_FILE_ACCESS_DENIED
rv
)
;
EXPECT_EQ
(
0
kill
(
childpid
SIGTERM
)
)
;
int
status
;
EXPECT_EQ
(
childpid
waitpid
(
childpid
&
status
0
)
)
;
rv
=
myLock2
.
Lock
(
dir
nullptr
)
;
EXPECT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
}
else
{
rv
=
myLock
.
Lock
(
dir
nullptr
)
;
ASSERT_EQ
(
NS_SUCCEEDED
(
rv
)
true
)
;
EXPECT_EQ
(
0
eventfd_write
(
eventfd_fd
1
)
)
;
for
(
;
;
)
sleep
(
1
)
;
}
close
(
eventfd_fd
)
;
}
CleanParentLock
(
tmpdir
)
;
}
