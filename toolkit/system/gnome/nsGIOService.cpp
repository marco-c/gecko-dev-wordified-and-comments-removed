#
include
"
nsGIOService
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsStringEnumerator
.
h
"
#
include
"
nsIMIMEInfo
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsArray
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
<
gio
/
gio
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
ifdef
MOZ_ENABLE_DBUS
#
include
<
dbus
/
dbus
-
glib
.
h
>
#
include
<
dbus
/
dbus
-
glib
-
lowlevel
.
h
>
#
endif
using
namespace
mozilla
;
static
bool
GetFlatpakPortalEnv
(
)
{
bool
shouldUsePortal
;
if
(
g_file_test
(
"
/
.
flatpak
-
info
"
G_FILE_TEST_EXISTS
)
)
{
shouldUsePortal
=
true
;
}
else
{
const
char
*
portalEnvString
=
g_getenv
(
"
GTK_USE_PORTAL
"
)
;
shouldUsePortal
=
portalEnvString
!
=
nullptr
&
&
atoi
(
portalEnvString
)
!
=
0
;
}
return
shouldUsePortal
;
}
static
bool
GetShouldUseFlatpakPortal
(
)
{
static
bool
sFlatpakPortalEnv
=
GetFlatpakPortalEnv
(
)
;
return
Preferences
:
:
HasUserValue
(
"
widget
.
use
-
xdg
-
desktop
-
portal
"
)
?
Preferences
:
:
GetBool
(
"
widget
.
use
-
xdg
-
desktop
-
portal
"
false
)
:
sFlatpakPortalEnv
;
}
class
nsFlatpakHandlerApp
:
public
nsIHandlerApp
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIHANDLERAPP
nsFlatpakHandlerApp
(
)
=
default
;
private
:
virtual
~
nsFlatpakHandlerApp
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
nsFlatpakHandlerApp
nsIHandlerApp
)
NS_IMETHODIMP
nsFlatpakHandlerApp
:
:
GetName
(
nsAString
&
aName
)
{
aName
.
AssignLiteral
(
"
System
Handler
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFlatpakHandlerApp
:
:
SetName
(
const
nsAString
&
aName
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsFlatpakHandlerApp
:
:
GetDetailedDescription
(
nsAString
&
aDetailedDescription
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsFlatpakHandlerApp
:
:
SetDetailedDescription
(
const
nsAString
&
aDetailedDescription
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsFlatpakHandlerApp
:
:
Equals
(
nsIHandlerApp
*
aHandlerApp
bool
*
_retval
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsFlatpakHandlerApp
:
:
LaunchWithURI
(
nsIURI
*
aUri
mozilla
:
:
dom
:
:
BrowsingContext
*
aBrowsingContext
)
{
nsCString
spec
;
aUri
-
>
GetSpec
(
spec
)
;
GError
*
error
=
nullptr
;
gtk_show_uri
(
nullptr
spec
.
get
(
)
GDK_CURRENT_TIME
&
error
)
;
if
(
error
)
{
NS_WARNING
(
nsPrintfCString
(
"
Cannot
launch
flatpak
handler
:
%
s
"
error
-
>
message
)
.
get
(
)
)
;
g_error_free
(
error
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
nsresult
GetCommandFromCommandline
(
nsACString
const
&
aCommandWithArguments
nsACString
&
aCommand
)
{
GError
*
error
=
nullptr
;
gchar
*
*
argv
=
nullptr
;
if
(
!
g_shell_parse_argv
(
aCommandWithArguments
.
BeginReading
(
)
nullptr
&
argv
&
error
)
|
|
!
argv
[
0
]
)
{
g_warning
(
"
Cannot
parse
command
with
arguments
:
%
s
"
error
-
>
message
)
;
g_error_free
(
error
)
;
g_strfreev
(
argv
)
;
return
NS_ERROR_FAILURE
;
}
aCommand
.
Assign
(
argv
[
0
]
)
;
g_strfreev
(
argv
)
;
return
NS_OK
;
}
class
nsGIOMimeApp
final
:
public
nsIGIOMimeApp
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIHANDLERAPP
NS_DECL_NSIGIOMIMEAPP
explicit
nsGIOMimeApp
(
GAppInfo
*
aApp
)
:
mApp
(
aApp
)
{
}
private
:
~
nsGIOMimeApp
(
)
{
g_object_unref
(
mApp
)
;
}
GAppInfo
*
mApp
;
}
;
NS_IMPL_ISUPPORTS
(
nsGIOMimeApp
nsIGIOMimeApp
nsIHandlerApp
)
NS_IMETHODIMP
nsGIOMimeApp
:
:
GetId
(
nsACString
&
aId
)
{
aId
.
Assign
(
g_app_info_get_id
(
mApp
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
GetName
(
nsAString
&
aName
)
{
aName
.
Assign
(
NS_ConvertUTF8toUTF16
(
g_app_info_get_name
(
mApp
)
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
SetName
(
const
nsAString
&
aName
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
GetCommand
(
nsACString
&
aCommand
)
{
const
char
*
cmd
=
g_app_info_get_commandline
(
mApp
)
;
if
(
!
cmd
)
return
NS_ERROR_FAILURE
;
aCommand
.
Assign
(
cmd
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
GetExpectsURIs
(
int32_t
*
aExpects
)
{
*
aExpects
=
g_app_info_supports_uris
(
mApp
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
GetDetailedDescription
(
nsAString
&
aDetailedDescription
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
SetDetailedDescription
(
const
nsAString
&
aDetailedDescription
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
Equals
(
nsIHandlerApp
*
aHandlerApp
bool
*
_retval
)
{
if
(
!
aHandlerApp
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsILocalHandlerApp
>
localHandlerApp
=
do_QueryInterface
(
aHandlerApp
)
;
if
(
localHandlerApp
)
{
nsAutoString
theirName
;
nsAutoString
thisName
;
GetName
(
thisName
)
;
localHandlerApp
-
>
GetName
(
theirName
)
;
*
_retval
=
thisName
.
Equals
(
theirName
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIGIOMimeApp
>
gioMimeApp
=
do_QueryInterface
(
aHandlerApp
)
;
if
(
gioMimeApp
)
{
nsAutoCString
thisCommandline
thisCommand
;
nsresult
rv
=
GetCommand
(
thisCommandline
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetCommandFromCommandline
(
thisCommandline
thisCommand
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
theirCommandline
theirCommand
;
gioMimeApp
-
>
GetCommand
(
theirCommandline
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetCommandFromCommandline
(
theirCommandline
theirCommand
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
_retval
=
thisCommand
.
Equals
(
theirCommand
)
;
return
NS_OK
;
}
*
_retval
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
LaunchWithURI
(
nsIURI
*
aUri
mozilla
:
:
dom
:
:
BrowsingContext
*
aBrowsingContext
)
{
GList
uris
=
{
0
}
;
nsCString
spec
;
aUri
-
>
GetSpec
(
spec
)
;
uris
.
data
=
const_cast
<
char
*
>
(
spec
.
get
(
)
)
;
GError
*
error
=
nullptr
;
gboolean
result
=
g_app_info_launch_uris
(
mApp
&
uris
nullptr
&
error
)
;
if
(
!
result
)
{
g_warning
(
"
Cannot
launch
application
:
%
s
"
error
-
>
message
)
;
g_error_free
(
error
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
class
GIOUTF8StringEnumerator
final
:
public
nsStringEnumeratorBase
{
~
GIOUTF8StringEnumerator
(
)
=
default
;
public
:
GIOUTF8StringEnumerator
(
)
:
mIndex
(
0
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIUTF8STRINGENUMERATOR
using
nsStringEnumeratorBase
:
:
GetNext
;
nsTArray
<
nsCString
>
mStrings
;
uint32_t
mIndex
;
}
;
NS_IMPL_ISUPPORTS
(
GIOUTF8StringEnumerator
nsIUTF8StringEnumerator
nsIStringEnumerator
)
NS_IMETHODIMP
GIOUTF8StringEnumerator
:
:
HasMore
(
bool
*
aResult
)
{
*
aResult
=
mIndex
<
mStrings
.
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GIOUTF8StringEnumerator
:
:
GetNext
(
nsACString
&
aResult
)
{
if
(
mIndex
>
=
mStrings
.
Length
(
)
)
return
NS_ERROR_UNEXPECTED
;
aResult
.
Assign
(
mStrings
[
mIndex
]
)
;
+
+
mIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
GetSupportedURISchemes
(
nsIUTF8StringEnumerator
*
*
aSchemes
)
{
*
aSchemes
=
nullptr
;
RefPtr
<
GIOUTF8StringEnumerator
>
array
=
new
GIOUTF8StringEnumerator
(
)
;
GVfs
*
gvfs
=
g_vfs_get_default
(
)
;
if
(
!
gvfs
)
{
g_warning
(
"
Cannot
get
GVfs
object
.
"
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
const
gchar
*
const
*
uri_schemes
=
g_vfs_get_supported_uri_schemes
(
gvfs
)
;
while
(
*
uri_schemes
!
=
nullptr
)
{
array
-
>
mStrings
.
AppendElement
(
*
uri_schemes
)
;
uri_schemes
+
+
;
}
array
.
forget
(
aSchemes
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
SetAsDefaultForMimeType
(
nsACString
const
&
aMimeType
)
{
char
*
content_type
=
g_content_type_from_mime_type
(
PromiseFlatCString
(
aMimeType
)
.
get
(
)
)
;
if
(
!
content_type
)
return
NS_ERROR_FAILURE
;
GError
*
error
=
nullptr
;
g_app_info_set_as_default_for_type
(
mApp
content_type
&
error
)
;
if
(
error
)
{
g_warning
(
"
Cannot
set
application
as
default
for
MIME
type
(
%
s
)
:
%
s
"
PromiseFlatCString
(
aMimeType
)
.
get
(
)
error
-
>
message
)
;
g_error_free
(
error
)
;
g_free
(
content_type
)
;
return
NS_ERROR_FAILURE
;
}
g_free
(
content_type
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
SetAsDefaultForFileExtensions
(
nsACString
const
&
fileExts
)
{
GError
*
error
=
nullptr
;
char
*
extensions
=
g_strdup
(
PromiseFlatCString
(
fileExts
)
.
get
(
)
)
;
char
*
ext_pos
=
extensions
;
char
*
space_pos
;
while
(
(
space_pos
=
strchr
(
ext_pos
'
'
)
)
|
|
(
*
ext_pos
!
=
'
\
0
'
)
)
{
if
(
space_pos
)
{
*
space_pos
=
'
\
0
'
;
}
g_app_info_set_as_default_for_extension
(
mApp
ext_pos
&
error
)
;
if
(
error
)
{
g_warning
(
"
Cannot
set
application
as
default
for
extension
(
%
s
)
:
%
s
"
ext_pos
error
-
>
message
)
;
g_error_free
(
error
)
;
g_free
(
extensions
)
;
return
NS_ERROR_FAILURE
;
}
if
(
space_pos
)
{
ext_pos
=
space_pos
+
1
;
}
else
{
*
ext_pos
=
'
\
0
'
;
}
}
g_free
(
extensions
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOMimeApp
:
:
SetAsDefaultForURIScheme
(
nsACString
const
&
aURIScheme
)
{
GError
*
error
=
nullptr
;
nsAutoCString
contentType
(
"
x
-
scheme
-
handler
/
"
)
;
contentType
.
Append
(
aURIScheme
)
;
g_app_info_set_as_default_for_type
(
mApp
contentType
.
get
(
)
&
error
)
;
if
(
error
)
{
g_warning
(
"
Cannot
set
application
as
default
for
URI
scheme
(
%
s
)
:
%
s
"
PromiseFlatCString
(
aURIScheme
)
.
get
(
)
error
-
>
message
)
;
g_error_free
(
error
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsGIOService
nsIGIOService
)
NS_IMETHODIMP
nsGIOService
:
:
GetMimeTypeFromExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
)
{
nsAutoCString
fileExtToUse
(
"
file
.
"
)
;
fileExtToUse
.
Append
(
aExtension
)
;
gboolean
result_uncertain
;
char
*
content_type
=
g_content_type_guess
(
fileExtToUse
.
get
(
)
nullptr
0
&
result_uncertain
)
;
if
(
!
content_type
)
return
NS_ERROR_FAILURE
;
char
*
mime_type
=
g_content_type_get_mime_type
(
content_type
)
;
if
(
!
mime_type
)
{
g_free
(
content_type
)
;
return
NS_ERROR_FAILURE
;
}
aMimeType
.
Assign
(
mime_type
)
;
g_free
(
mime_type
)
;
g_free
(
content_type
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOService
:
:
GetAppForURIScheme
(
const
nsACString
&
aURIScheme
nsIHandlerApp
*
*
aApp
)
{
*
aApp
=
nullptr
;
if
(
GetShouldUseFlatpakPortal
(
)
)
{
nsFlatpakHandlerApp
*
mozApp
=
new
nsFlatpakHandlerApp
(
)
;
NS_ADDREF
(
*
aApp
=
mozApp
)
;
return
NS_OK
;
}
GAppInfo
*
app_info
=
g_app_info_get_default_for_uri_scheme
(
PromiseFlatCString
(
aURIScheme
)
.
get
(
)
)
;
if
(
app_info
)
{
nsGIOMimeApp
*
mozApp
=
new
nsGIOMimeApp
(
app_info
)
;
NS_ADDREF
(
*
aApp
=
mozApp
)
;
}
else
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOService
:
:
GetAppsForURIScheme
(
const
nsACString
&
aURIScheme
nsIMutableArray
*
*
aResult
)
{
nsCOMPtr
<
nsIMutableArray
>
handlersArray
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
nsAutoCString
contentType
(
"
x
-
scheme
-
handler
/
"
)
;
contentType
.
Append
(
aURIScheme
)
;
GList
*
appInfoList
=
g_app_info_get_all_for_type
(
contentType
.
get
(
)
)
;
if
(
appInfoList
)
{
GList
*
appInfo
=
appInfoList
;
while
(
appInfo
)
{
nsCOMPtr
<
nsIGIOMimeApp
>
mimeApp
=
new
nsGIOMimeApp
(
G_APP_INFO
(
appInfo
-
>
data
)
)
;
handlersArray
-
>
AppendElement
(
mimeApp
)
;
appInfo
=
appInfo
-
>
next
;
}
g_list_free
(
appInfoList
)
;
}
NS_ADDREF
(
*
aResult
=
handlersArray
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOService
:
:
GetAppForMimeType
(
const
nsACString
&
aMimeType
nsIHandlerApp
*
*
aApp
)
{
*
aApp
=
nullptr
;
if
(
GetShouldUseFlatpakPortal
(
)
)
{
nsFlatpakHandlerApp
*
mozApp
=
new
nsFlatpakHandlerApp
(
)
;
NS_ADDREF
(
*
aApp
=
mozApp
)
;
return
NS_OK
;
}
char
*
content_type
=
g_content_type_from_mime_type
(
PromiseFlatCString
(
aMimeType
)
.
get
(
)
)
;
if
(
!
content_type
)
return
NS_ERROR_FAILURE
;
if
(
g_content_type_is_unknown
(
content_type
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
if
defined
(
__OpenBSD__
)
&
&
defined
(
MOZ_SANDBOX
)
GAppInfo
*
app_info
=
g_app_info_create_from_commandline
(
"
/
usr
/
local
/
bin
/
xdg
-
open
"
nsPrintfCString
(
"
System
default
for
%
s
"
content_type
)
.
get
(
)
G_APP_INFO_CREATE_NONE
NULL
)
;
#
else
GAppInfo
*
app_info
=
g_app_info_get_default_for_type
(
content_type
false
)
;
#
endif
if
(
app_info
)
{
nsGIOMimeApp
*
mozApp
=
new
nsGIOMimeApp
(
app_info
)
;
NS_ADDREF
(
*
aApp
=
mozApp
)
;
}
else
{
g_free
(
content_type
)
;
return
NS_ERROR_FAILURE
;
}
g_free
(
content_type
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOService
:
:
GetDescriptionForMimeType
(
const
nsACString
&
aMimeType
nsACString
&
aDescription
)
{
char
*
content_type
=
g_content_type_from_mime_type
(
PromiseFlatCString
(
aMimeType
)
.
get
(
)
)
;
if
(
!
content_type
)
return
NS_ERROR_FAILURE
;
char
*
desc
=
g_content_type_get_description
(
content_type
)
;
if
(
!
desc
)
{
g_free
(
content_type
)
;
return
NS_ERROR_FAILURE
;
}
aDescription
.
Assign
(
desc
)
;
g_free
(
content_type
)
;
g_free
(
desc
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOService
:
:
ShowURI
(
nsIURI
*
aURI
)
{
nsAutoCString
spec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
GError
*
error
=
nullptr
;
if
(
!
g_app_info_launch_default_for_uri
(
spec
.
get
(
)
nullptr
&
error
)
)
{
g_warning
(
"
Could
not
launch
default
application
for
URI
:
%
s
"
error
-
>
message
)
;
g_error_free
(
error
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOService
:
:
ShowURIForInput
(
const
nsACString
&
aUri
)
{
GFile
*
file
=
g_file_new_for_commandline_arg
(
PromiseFlatCString
(
aUri
)
.
get
(
)
)
;
char
*
spec
=
g_file_get_uri
(
file
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
GError
*
error
=
nullptr
;
g_app_info_launch_default_for_uri
(
spec
nullptr
&
error
)
;
if
(
error
)
{
g_warning
(
"
Cannot
launch
default
application
:
%
s
"
error
-
>
message
)
;
g_error_free
(
error
)
;
}
else
{
rv
=
NS_OK
;
}
g_object_unref
(
file
)
;
g_free
(
spec
)
;
return
rv
;
}
NS_IMETHODIMP
nsGIOService
:
:
OrgFreedesktopFileManager1ShowItems
(
const
nsACString
&
aPath
)
{
#
ifndef
MOZ_ENABLE_DBUS
return
NS_ERROR_FAILURE
;
#
else
GError
*
error
=
nullptr
;
static
bool
org_freedesktop_FileManager1_exists
=
true
;
if
(
!
org_freedesktop_FileManager1_exists
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
DBusGConnection
*
dbusGConnection
=
dbus_g_bus_get
(
DBUS_BUS_SESSION
&
error
)
;
if
(
!
dbusGConnection
)
{
if
(
error
)
{
g_printerr
(
"
Failed
to
open
connection
to
session
bus
:
%
s
\
n
"
error
-
>
message
)
;
g_error_free
(
error
)
;
}
return
NS_ERROR_FAILURE
;
}
char
*
uri
=
g_filename_to_uri
(
PromiseFlatCString
(
aPath
)
.
get
(
)
nullptr
nullptr
)
;
if
(
uri
=
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
DBusConnection
*
dbusConnection
=
dbus_g_connection_get_connection
(
dbusGConnection
)
;
dbus_connection_set_exit_on_disconnect
(
dbusConnection
false
)
;
DBusGProxy
*
dbusGProxy
=
dbus_g_proxy_new_for_name
(
dbusGConnection
"
org
.
freedesktop
.
FileManager1
"
"
/
org
/
freedesktop
/
FileManager1
"
"
org
.
freedesktop
.
FileManager1
"
)
;
const
char
*
uris
[
2
]
=
{
uri
nullptr
}
;
gboolean
rv_dbus_call
=
dbus_g_proxy_call
(
dbusGProxy
"
ShowItems
"
nullptr
G_TYPE_STRV
uris
G_TYPE_STRING
"
"
G_TYPE_INVALID
G_TYPE_INVALID
)
;
g_object_unref
(
dbusGProxy
)
;
dbus_g_connection_unref
(
dbusGConnection
)
;
g_free
(
uri
)
;
if
(
!
rv_dbus_call
)
{
org_freedesktop_FileManager1_exists
=
false
;
return
NS_ERROR_NOT_AVAILABLE
;
}
return
NS_OK
;
#
endif
}
NS_IMETHODIMP
nsGIOService
:
:
FindAppFromCommand
(
nsACString
const
&
aCmd
nsIGIOMimeApp
*
*
aAppInfo
)
{
GAppInfo
*
app_info
=
nullptr
*
app_info_from_list
=
nullptr
;
GList
*
apps
=
g_app_info_get_all
(
)
;
GList
*
apps_p
=
apps
;
while
(
apps_p
)
{
app_info_from_list
=
(
GAppInfo
*
)
apps_p
-
>
data
;
if
(
!
app_info
)
{
char
*
executable
=
g_find_program_in_path
(
g_app_info_get_executable
(
app_info_from_list
)
)
;
if
(
executable
&
&
strcmp
(
executable
PromiseFlatCString
(
aCmd
)
.
get
(
)
)
=
=
0
)
{
g_object_ref
(
app_info_from_list
)
;
app_info
=
app_info_from_list
;
}
g_free
(
executable
)
;
}
g_object_unref
(
app_info_from_list
)
;
apps_p
=
apps_p
-
>
next
;
}
g_list_free
(
apps
)
;
if
(
app_info
)
{
nsGIOMimeApp
*
app
=
new
nsGIOMimeApp
(
app_info
)
;
NS_ADDREF
(
*
aAppInfo
=
app
)
;
return
NS_OK
;
}
*
aAppInfo
=
nullptr
;
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
nsGIOService
:
:
CreateAppFromCommand
(
nsACString
const
&
cmd
nsACString
const
&
appName
nsIGIOMimeApp
*
*
appInfo
)
{
GError
*
error
=
nullptr
;
*
appInfo
=
nullptr
;
nsAutoCString
commandWithoutArgs
;
nsresult
rv
=
GetCommandFromCommandline
(
cmd
commandWithoutArgs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
GAppInfo
*
app_info
=
g_app_info_create_from_commandline
(
commandWithoutArgs
.
BeginReading
(
)
PromiseFlatCString
(
appName
)
.
get
(
)
G_APP_INFO_CREATE_SUPPORTS_URIS
&
error
)
;
if
(
!
app_info
)
{
g_warning
(
"
Cannot
create
application
info
from
command
:
%
s
"
error
-
>
message
)
;
g_error_free
(
error
)
;
return
NS_ERROR_FAILURE
;
}
gchar
*
executableWithFullPath
=
g_find_program_in_path
(
commandWithoutArgs
.
BeginReading
(
)
)
;
if
(
!
executableWithFullPath
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
g_free
(
executableWithFullPath
)
;
nsGIOMimeApp
*
mozApp
=
new
nsGIOMimeApp
(
app_info
)
;
NS_ADDREF
(
*
appInfo
=
mozApp
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsGIOService
:
:
ShouldUseFlatpakPortal
(
bool
*
aRes
)
{
*
aRes
=
GetShouldUseFlatpakPortal
(
)
;
return
NS_OK
;
}
