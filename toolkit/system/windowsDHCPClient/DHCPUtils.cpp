#
include
"
DHCPUtils
.
h
"
#
include
<
vector
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsString
.
h
"
#
define
MOZ_WORKING_BUFFER_SIZE_NETWORK_ADAPTERS
15000
#
define
MOZ_WORKING_BUFFER_SIZE_DHCP_PARAMS
1000
#
define
MOZ_MAX_TRIES
3
namespace
mozilla
{
namespace
toolkit
{
namespace
system
{
namespace
windowsDHCPClient
{
mozilla
:
:
LazyLogModule
gDhcpUtilsLog
(
"
dhcpUtils
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
gDhcpUtilsLog
LogLevel
:
:
Debug
args
)
bool
IsCurrentAndHasDHCP
(
PIP_ADAPTER_ADDRESSES
aAddresses
)
{
return
aAddresses
-
>
OperStatus
=
=
1
&
&
(
aAddresses
-
>
Dhcpv4Server
.
iSockaddrLength
|
|
aAddresses
-
>
Dhcpv6Server
.
iSockaddrLength
)
;
}
nsresult
GetActiveDHCPNetworkAdapterName
(
nsACString
&
aNetworkAdapterName
WindowsNetworkFunctionsWrapper
*
aWindowsNetworkFunctionsWrapper
)
{
uint32_t
dwRetVal
=
0
;
nsresult
rv
=
NS_ERROR_FAILURE
;
uint32_t
flags
=
GAA_FLAG_INCLUDE_PREFIX
;
uint32_t
family
=
AF_UNSPEC
;
uint32_t
outBufLen
=
MOZ_WORKING_BUFFER_SIZE_NETWORK_ADAPTERS
;
uint32_t
iterations
=
0
;
aNetworkAdapterName
.
Truncate
(
)
;
std
:
:
vector
<
IP_ADAPTER_ADDRESSES
>
pAddresses
;
do
{
outBufLen
=
(
(
outBufLen
+
sizeof
(
IP_ADAPTER_ADDRESSES
)
-
1
)
/
sizeof
(
IP_ADAPTER_ADDRESSES
)
)
*
sizeof
(
IP_ADAPTER_ADDRESSES
)
;
pAddresses
.
resize
(
outBufLen
/
sizeof
(
IP_ADAPTER_ADDRESSES
)
)
;
LOG
(
(
"
Trying
GetAdaptersAddresses
with
pAddresses
sized
to
%
zu
and
buffer
"
"
length
of
%
d
"
pAddresses
.
size
(
)
outBufLen
)
)
;
dwRetVal
=
aWindowsNetworkFunctionsWrapper
-
>
GetAdaptersAddressesWrapped
(
family
flags
nullptr
pAddresses
.
data
(
)
(
PULONG
)
&
outBufLen
)
;
if
(
dwRetVal
=
=
ERROR_BUFFER_OVERFLOW
)
{
iterations
+
+
;
}
}
while
(
dwRetVal
=
=
ERROR_BUFFER_OVERFLOW
&
&
iterations
<
MOZ_MAX_TRIES
)
;
switch
(
dwRetVal
)
{
case
NO_ERROR
:
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
PIP_ADAPTER_ADDRESSES
pCurrAddresses
=
pAddresses
.
data
(
)
;
while
(
pCurrAddresses
)
{
if
(
IsCurrentAndHasDHCP
(
pCurrAddresses
)
)
{
rv
=
NS_OK
;
aNetworkAdapterName
.
Assign
(
pCurrAddresses
-
>
AdapterName
)
;
break
;
}
pCurrAddresses
=
pCurrAddresses
-
>
Next
;
}
}
break
;
case
ERROR_NO_DATA
:
rv
=
NS_ERROR_NOT_AVAILABLE
;
break
;
default
:
MOZ_LOG
(
gDhcpUtilsLog
mozilla
:
:
LogLevel
:
:
Warning
(
"
GetAdaptersAddresses
returned
%
d
"
dwRetVal
)
)
;
rv
=
NS_ERROR_FAILURE
;
break
;
}
return
rv
;
}
DWORD
IterateDHCPInformRequestsUntilBufferLargeEnough
(
DHCPCAPI_PARAMS
&
aDhcpRequestedOptionParams
wchar_t
*
aWideNetworkAdapterName
std
:
:
vector
<
char
>
&
aBuffer
WindowsNetworkFunctionsWrapper
*
aWindowsNetworkFunctionsWrapper
)
{
uint32_t
iterations
=
0
;
uint32_t
outBufLen
=
MOZ_WORKING_BUFFER_SIZE_DHCP_PARAMS
;
DHCPCAPI_PARAMS_ARRAY
RequestParams
=
{
1
&
aDhcpRequestedOptionParams
}
;
DHCPCAPI_PARAMS_ARRAY
SendParams
=
{
0
nullptr
}
;
DWORD
winAPIResponse
;
do
{
aBuffer
.
resize
(
outBufLen
)
;
winAPIResponse
=
aWindowsNetworkFunctionsWrapper
-
>
DhcpRequestParamsWrapped
(
DHCPCAPI_REQUEST_SYNCHRONOUS
nullptr
aWideNetworkAdapterName
nullptr
SendParams
RequestParams
(
PBYTE
)
aBuffer
.
data
(
)
(
PULONG
)
&
outBufLen
nullptr
)
;
if
(
winAPIResponse
=
=
ERROR_MORE_DATA
)
{
iterations
+
+
;
}
}
while
(
winAPIResponse
=
=
ERROR_MORE_DATA
&
&
iterations
<
MOZ_MAX_TRIES
)
;
return
winAPIResponse
;
}
nsresult
RetrieveOption
(
const
nsACString
&
aAdapterName
uint8_t
aOption
std
:
:
vector
<
char
>
&
aOptionValueBuf
uint32_t
*
aOptionSize
WindowsNetworkFunctionsWrapper
*
aWindowsNetworkFunctionsWrapper
)
{
nsresult
rv
;
nsAutoString
wideNetworkAdapterName
=
NS_ConvertUTF8toUTF16
(
aAdapterName
)
;
DHCPCAPI_PARAMS
DhcpRequestedOptionParams
=
{
0
aOption
false
nullptr
0
}
;
std
:
:
vector
<
char
>
tmpBuffer
(
MOZ_WORKING_BUFFER_SIZE_DHCP_PARAMS
)
;
DWORD
winAPIResponse
=
IterateDHCPInformRequestsUntilBufferLargeEnough
(
DhcpRequestedOptionParams
wideNetworkAdapterName
.
get
(
)
tmpBuffer
aWindowsNetworkFunctionsWrapper
)
;
switch
(
winAPIResponse
)
{
case
NO_ERROR
:
{
if
(
DhcpRequestedOptionParams
.
nBytesData
=
=
0
)
{
*
aOptionSize
=
0
;
rv
=
NS_ERROR_NOT_AVAILABLE
;
break
;
}
if
(
*
aOptionSize
>
=
DhcpRequestedOptionParams
.
nBytesData
)
{
rv
=
NS_OK
;
}
else
{
rv
=
NS_ERROR_LOSS_OF_SIGNIFICANT_DATA
;
}
uint32_t
actualSizeReturned
=
*
aOptionSize
>
DhcpRequestedOptionParams
.
nBytesData
?
DhcpRequestedOptionParams
.
nBytesData
:
*
aOptionSize
;
memcpy
(
aOptionValueBuf
.
data
(
)
DhcpRequestedOptionParams
.
Data
actualSizeReturned
)
;
*
aOptionSize
=
DhcpRequestedOptionParams
.
nBytesData
;
break
;
}
case
ERROR_INVALID_PARAMETER
:
MOZ_LOG
(
gDhcpUtilsLog
mozilla
:
:
LogLevel
:
:
Warning
(
"
RetrieveOption
returned
%
lu
(
ERROR_INVALID_PARAMETER
)
when
"
"
option
%
d
requested
"
winAPIResponse
aOption
)
)
;
rv
=
NS_ERROR_INVALID_ARG
;
break
;
default
:
MOZ_LOG
(
gDhcpUtilsLog
mozilla
:
:
LogLevel
:
:
Warning
(
"
RetrieveOption
returned
%
lu
when
option
%
d
requested
"
winAPIResponse
aOption
)
)
;
rv
=
NS_ERROR_FAILURE
;
}
return
rv
;
}
}
}
}
}
