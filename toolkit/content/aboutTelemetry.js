"
use
strict
"
;
var
Ci
=
Components
.
interfaces
;
var
Cc
=
Components
.
classes
;
var
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryTimestamps
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryArchive
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryLog
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Preferences
"
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
const
Telemetry
=
Services
.
telemetry
;
const
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
aboutTelemetry
.
properties
"
)
;
const
brandBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
const
MAX_BAR_HEIGHT
=
18
;
const
MAX_BAR_CHARS
=
25
;
const
PREF_TELEMETRY_SERVER_OWNER
=
"
toolkit
.
telemetry
.
server_owner
"
;
const
PREF_TELEMETRY_ENABLED
=
"
toolkit
.
telemetry
.
enabled
"
;
const
PREF_DEBUG_SLOW_SQL
=
"
toolkit
.
telemetry
.
debugSlowSql
"
;
const
PREF_SYMBOL_SERVER_URI
=
"
profiler
.
symbolicationUrl
"
;
const
DEFAULT_SYMBOL_SERVER_URI
=
"
http
:
/
/
symbolapi
.
mozilla
.
org
"
;
const
PREF_FHR_UPLOAD_ENABLED
=
"
datareporting
.
healthreport
.
uploadEnabled
"
;
const
FILTER_IDLE_TIMEOUT
=
500
;
const
isWindows
=
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
;
const
EOL
=
isWindows
?
"
\
r
\
n
"
:
"
\
n
"
;
var
gPingData
=
null
;
var
documentRTLMode
=
"
"
;
function
isRTL
(
)
{
if
(
!
documentRTLMode
)
documentRTLMode
=
window
.
getComputedStyle
(
document
.
body
)
.
direction
;
return
(
documentRTLMode
=
=
"
rtl
"
)
;
}
function
isFlatArray
(
obj
)
{
if
(
!
Array
.
isArray
(
obj
)
)
{
return
false
;
}
return
!
obj
.
some
(
e
=
>
typeof
(
e
)
=
=
"
object
"
)
;
}
function
flattenObject
(
obj
map
path
array
)
{
for
(
let
k
of
Object
.
keys
(
obj
)
)
{
let
newPath
=
[
.
.
.
path
array
?
"
[
"
+
k
+
"
]
"
:
k
]
;
let
v
=
obj
[
k
]
;
if
(
!
v
|
|
(
typeof
(
v
)
!
=
"
object
"
)
)
{
map
.
set
(
newPath
.
join
(
"
.
"
)
v
)
;
}
else
if
(
isFlatArray
(
v
)
)
{
map
.
set
(
newPath
.
join
(
"
.
"
)
"
[
"
+
v
.
join
(
"
"
)
+
"
]
"
)
;
}
else
{
flattenObject
(
v
map
newPath
Array
.
isArray
(
v
)
)
;
}
}
}
function
explodeObject
(
obj
)
{
let
map
=
new
Map
(
)
;
flattenObject
(
obj
map
[
]
)
;
return
map
;
}
function
filterObject
(
obj
filterOut
)
{
let
ret
=
{
}
;
for
(
let
k
of
Object
.
keys
(
obj
)
)
{
if
(
filterOut
.
indexOf
(
k
)
=
=
-
1
)
{
ret
[
k
]
=
obj
[
k
]
;
}
}
return
ret
;
}
function
sectionalizeObject
(
obj
)
{
let
map
=
new
Map
(
)
;
for
(
let
k
of
Object
.
keys
(
obj
)
)
{
map
.
set
(
k
explodeObject
(
obj
[
k
]
)
)
;
}
return
map
;
}
function
getMainWindow
(
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
function
getMainWindowWithPreferencesPane
(
)
{
let
mainWindow
=
getMainWindow
(
)
;
if
(
mainWindow
&
&
"
openAdvancedPreferences
"
in
mainWindow
)
{
return
mainWindow
;
}
return
null
;
}
function
removeAllChildNodes
(
node
)
{
while
(
node
.
hasChildNodes
(
)
)
{
node
.
removeChild
(
node
.
lastChild
)
;
}
}
function
padToTwoDigits
(
n
)
{
return
new
String
(
n
)
.
padStart
(
2
"
0
"
)
;
}
function
yesterday
(
date
)
{
let
d
=
new
Date
(
date
)
;
d
.
setDate
(
d
.
getDate
(
)
-
1
)
;
return
d
;
}
function
shortDateString
(
date
)
{
return
date
.
getFullYear
(
)
+
"
/
"
+
padToTwoDigits
(
date
.
getMonth
(
)
+
1
)
+
"
/
"
+
padToTwoDigits
(
date
.
getDate
(
)
)
;
}
function
shortTimeString
(
date
)
{
return
padToTwoDigits
(
date
.
getHours
(
)
)
+
"
:
"
+
padToTwoDigits
(
date
.
getMinutes
(
)
)
+
"
:
"
+
padToTwoDigits
(
date
.
getSeconds
(
)
)
;
}
var
Settings
=
{
SETTINGS
:
[
{
pref
:
PREF_FHR_UPLOAD_ENABLED
defaultPrefValue
:
false
}
{
pref
:
PREF_TELEMETRY_ENABLED
defaultPrefValue
:
false
}
]
attachObservers
(
)
{
for
(
let
s
of
this
.
SETTINGS
)
{
let
setting
=
s
;
Preferences
.
observe
(
setting
.
pref
this
.
render
this
)
;
}
let
elements
=
document
.
getElementsByClassName
(
"
change
-
data
-
choices
-
link
"
)
;
for
(
let
el
of
elements
)
{
el
.
addEventListener
(
"
click
"
function
(
)
{
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
)
;
EventDispatcher
.
instance
.
sendRequest
(
{
type
:
"
Settings
:
Show
"
resource
:
"
preferences_privacy
"
}
)
;
}
else
{
let
mainWindow
=
getMainWindowWithPreferencesPane
(
)
;
if
(
Preferences
.
get
(
"
browser
.
preferences
.
useOldOrganization
"
)
)
{
mainWindow
.
openAdvancedPreferences
(
"
dataChoicesTab
"
{
origin
:
"
aboutTelemetry
"
}
)
;
}
else
{
mainWindow
.
openPreferences
(
"
privacy
-
reports
"
{
origin
:
"
aboutTelemetry
"
}
)
;
}
}
}
)
;
}
}
detachObservers
(
)
{
for
(
let
setting
of
this
.
SETTINGS
)
{
Preferences
.
ignore
(
setting
.
pref
this
.
render
this
)
;
}
}
getStatusStringForSetting
(
setting
)
{
let
enabled
=
Preferences
.
get
(
setting
.
pref
setting
.
defaultPrefValue
)
;
let
status
=
bundle
.
GetStringFromName
(
enabled
?
"
telemetryEnabled
"
:
"
telemetryDisabled
"
)
;
return
status
;
}
render
(
)
{
let
homeExplanation
=
document
.
getElementById
(
"
home
-
explanation
"
)
;
let
fhrEnabled
=
this
.
getStatusStringForSetting
(
this
.
SETTINGS
[
0
]
)
;
let
extendedEnabled
=
this
.
getStatusStringForSetting
(
this
.
SETTINGS
[
1
]
)
;
let
parameters
=
[
fhrEnabled
extendedEnabled
]
.
map
(
this
.
convertStringToLink
)
;
let
explanation
=
bundle
.
formatStringFromName
(
"
homeExplanation
"
parameters
2
)
;
homeExplanation
.
innerHTML
=
explanation
;
this
.
attachObservers
(
)
}
convertStringToLink
(
string
)
{
return
"
<
a
href
=
\
"
\
"
class
=
\
"
change
-
data
-
choices
-
link
\
"
>
"
+
string
+
"
<
/
a
>
"
;
}
}
;
var
PingPicker
=
{
viewCurrentPingData
:
null
_archivedPings
:
null
attachObservers
(
)
{
let
elements
=
document
.
getElementsByName
(
"
choose
-
ping
-
source
"
)
;
for
(
let
el
of
elements
)
{
el
.
addEventListener
(
"
change
"
(
)
=
>
this
.
onPingSourceChanged
(
)
)
;
}
let
displays
=
document
.
getElementsByName
(
"
choose
-
ping
-
display
"
)
;
for
(
let
el
of
displays
)
{
el
.
addEventListener
(
"
change
"
(
)
=
>
this
.
onPingDisplayChanged
(
)
)
;
}
document
.
getElementById
(
"
show
-
subsession
-
data
"
)
.
addEventListener
(
"
change
"
(
)
=
>
{
this
.
_updateCurrentPingData
(
)
;
}
)
;
document
.
getElementById
(
"
choose
-
ping
-
week
"
)
.
addEventListener
(
"
change
"
(
)
=
>
{
this
.
_renderPingList
(
)
;
this
.
_updateArchivedPingData
(
)
;
}
)
;
document
.
getElementById
(
"
choose
-
ping
-
id
"
)
.
addEventListener
(
"
change
"
(
)
=
>
{
this
.
_updateArchivedPingData
(
)
}
)
;
document
.
getElementById
(
"
newer
-
ping
"
)
.
addEventListener
(
"
click
"
(
)
=
>
this
.
_movePingIndex
(
-
1
)
)
;
document
.
getElementById
(
"
older
-
ping
"
)
.
addEventListener
(
"
click
"
(
)
=
>
this
.
_movePingIndex
(
1
)
)
;
document
.
getElementById
(
"
choose
-
payload
"
)
.
addEventListener
(
"
change
"
(
)
=
>
displayPingData
(
gPingData
)
)
;
document
.
getElementById
(
"
scalars
-
processes
"
)
.
addEventListener
(
"
change
"
(
)
=
>
displayPingData
(
gPingData
)
)
;
document
.
getElementById
(
"
keyed
-
scalars
-
processes
"
)
.
addEventListener
(
"
change
"
(
)
=
>
displayPingData
(
gPingData
)
)
;
document
.
getElementById
(
"
histograms
-
processes
"
)
.
addEventListener
(
"
change
"
(
)
=
>
displayPingData
(
gPingData
)
)
;
document
.
getElementById
(
"
keyed
-
histograms
-
processes
"
)
.
addEventListener
(
"
change
"
(
)
=
>
displayPingData
(
gPingData
)
)
;
document
.
getElementById
(
"
events
-
processes
"
)
.
addEventListener
(
"
change
"
(
)
=
>
displayPingData
(
gPingData
)
)
;
}
onPingSourceChanged
(
)
{
this
.
update
(
)
;
}
onPingDisplayChanged
(
)
{
this
.
update
(
)
;
}
render
(
)
{
let
pings
=
bundle
.
GetStringFromName
(
"
pingExplanationLink
"
)
;
let
pingLink
=
"
<
a
href
=
\
"
http
:
/
/
gecko
.
readthedocs
.
io
/
en
/
latest
/
toolkit
/
components
/
telemetry
/
telemetry
/
concepts
/
pings
.
html
\
"
>
&
quot
;
"
+
pings
+
"
&
quot
;
<
/
a
>
"
;
let
pingName
=
"
<
span
class
=
\
"
change
-
ping
\
"
>
"
+
this
.
_getSelectedPingName
(
)
+
"
<
/
span
>
"
;
let
explanation
=
bundle
.
formatStringFromName
(
"
pingExplanation
"
[
pingLink
pingName
]
2
)
;
let
pingExplanation
=
document
.
getElementById
(
"
ping
-
explanation
"
)
;
pingExplanation
.
innerHTML
=
explanation
;
GenericSubsection
.
deleteAllSubSections
(
)
;
}
async
update
(
)
{
let
viewCurrent
=
document
.
getElementById
(
"
ping
-
source
-
current
"
)
.
checked
;
let
currentChanged
=
viewCurrent
!
=
=
this
.
viewCurrentPingData
;
this
.
viewCurrentPingData
=
viewCurrent
;
let
archivedPingList
=
await
TelemetryArchive
.
promiseArchivedPingList
(
)
;
let
sourceArchived
=
document
.
getElementById
(
"
ping
-
source
-
archive
"
)
;
sourceArchived
.
disabled
=
(
archivedPingList
.
length
=
=
0
)
;
if
(
currentChanged
)
{
if
(
this
.
viewCurrentPingData
)
{
document
.
getElementById
(
"
current
-
ping
-
picker
"
)
.
hidden
=
false
;
document
.
getElementById
(
"
archived
-
ping
-
picker
"
)
.
hidden
=
true
;
this
.
_updateCurrentPingData
(
)
;
}
else
{
document
.
getElementById
(
"
current
-
ping
-
picker
"
)
.
hidden
=
true
;
await
this
.
_updateArchivedPingList
(
archivedPingList
)
;
document
.
getElementById
(
"
archived
-
ping
-
picker
"
)
.
hidden
=
false
;
}
}
}
_updateCurrentPingData
(
)
{
const
subsession
=
document
.
getElementById
(
"
show
-
subsession
-
data
"
)
.
checked
;
const
ping
=
TelemetryController
.
getCurrentPingData
(
subsession
)
;
if
(
!
ping
)
{
return
;
}
displayPingData
(
ping
true
)
;
}
_updateArchivedPingData
(
)
{
let
id
=
this
.
_getSelectedPingId
(
)
;
return
TelemetryArchive
.
promiseArchivedPingById
(
id
)
.
then
(
(
ping
)
=
>
displayPingData
(
ping
true
)
)
;
}
async
_updateArchivedPingList
(
pingList
)
{
pingList
.
reverse
(
)
;
this
.
_archivedPings
=
pingList
;
let
weekStart
=
(
date
)
=
>
{
let
weekDay
=
(
date
.
getDay
(
)
+
6
)
%
7
;
let
monday
=
new
Date
(
date
)
;
monday
.
setDate
(
date
.
getDate
(
)
-
weekDay
)
;
return
TelemetryUtils
.
truncateToDays
(
monday
)
;
}
;
let
weekStartDates
=
new
Set
(
)
;
for
(
let
p
of
pingList
)
{
weekStartDates
.
add
(
weekStart
(
new
Date
(
p
.
timestampCreated
)
)
.
getTime
(
)
)
;
}
let
plusOneWeek
=
(
date
)
=
>
{
let
d
=
date
;
d
.
setDate
(
d
.
getDate
(
)
+
7
)
;
return
d
;
}
;
this
.
_weeks
=
Array
.
from
(
weekStartDates
.
values
(
)
startTime
=
>
(
{
startDate
:
new
Date
(
startTime
)
endDate
:
plusOneWeek
(
new
Date
(
startTime
)
)
}
)
)
;
this
.
_renderWeeks
(
)
;
this
.
_renderPingList
(
)
;
await
this
.
_updateArchivedPingData
(
)
;
}
_renderWeeks
(
)
{
let
weekSelector
=
document
.
getElementById
(
"
choose
-
ping
-
week
"
)
;
removeAllChildNodes
(
weekSelector
)
;
for
(
let
week
of
this
.
_weeks
)
{
let
text
=
shortDateString
(
week
.
startDate
)
+
"
-
"
+
shortDateString
(
yesterday
(
week
.
endDate
)
)
;
let
option
=
document
.
createElement
(
"
option
"
)
;
let
content
=
document
.
createTextNode
(
text
)
;
option
.
appendChild
(
content
)
;
weekSelector
.
appendChild
(
option
)
;
}
}
_getSelectedWeek
(
)
{
let
weekSelector
=
document
.
getElementById
(
"
choose
-
ping
-
week
"
)
;
return
this
.
_weeks
[
weekSelector
.
selectedIndex
]
;
}
_renderPingList
(
id
=
null
)
{
let
pingSelector
=
document
.
getElementById
(
"
choose
-
ping
-
id
"
)
;
removeAllChildNodes
(
pingSelector
)
;
let
weekRange
=
this
.
_getSelectedWeek
(
)
;
let
pings
=
this
.
_archivedPings
.
filter
(
(
p
)
=
>
p
.
timestampCreated
>
=
weekRange
.
startDate
.
getTime
(
)
&
&
p
.
timestampCreated
<
weekRange
.
endDate
.
getTime
(
)
)
;
for
(
let
p
of
pings
)
{
let
date
=
new
Date
(
p
.
timestampCreated
)
;
let
text
=
shortDateString
(
date
)
+
"
"
+
shortTimeString
(
date
)
+
"
-
"
+
p
.
type
;
let
option
=
document
.
createElement
(
"
option
"
)
;
let
content
=
document
.
createTextNode
(
text
)
;
option
.
appendChild
(
content
)
;
option
.
setAttribute
(
"
value
"
p
.
id
)
;
if
(
id
&
&
p
.
id
=
=
id
)
{
option
.
selected
=
true
;
}
pingSelector
.
appendChild
(
option
)
;
}
}
_getSelectedPingName
(
)
{
if
(
this
.
viewCurrentPingData
)
return
"
current
"
;
let
pingSelector
=
document
.
getElementById
(
"
choose
-
ping
-
id
"
)
;
let
selected
=
pingSelector
.
selectedOptions
.
item
(
0
)
;
return
selected
.
textContent
;
}
_getSelectedPingId
(
)
{
let
pingSelector
=
document
.
getElementById
(
"
choose
-
ping
-
id
"
)
;
let
selected
=
pingSelector
.
selectedOptions
.
item
(
0
)
;
return
selected
.
getAttribute
(
"
value
"
)
;
}
_movePingIndex
(
offset
)
{
const
id
=
this
.
_getSelectedPingId
(
)
;
const
index
=
this
.
_archivedPings
.
findIndex
(
(
p
)
=
>
p
.
id
=
=
id
)
;
const
newIndex
=
Math
.
min
(
Math
.
max
(
index
+
offset
0
)
this
.
_archivedPings
.
length
-
1
)
;
const
ping
=
this
.
_archivedPings
[
newIndex
]
;
const
weekIndex
=
this
.
_weeks
.
findIndex
(
(
week
)
=
>
ping
.
timestampCreated
>
=
week
.
startDate
.
getTime
(
)
&
&
ping
.
timestampCreated
<
week
.
endDate
.
getTime
(
)
)
;
const
options
=
document
.
getElementById
(
"
choose
-
ping
-
week
"
)
.
options
;
options
.
item
(
weekIndex
)
.
selected
=
true
;
this
.
_renderPingList
(
ping
.
id
)
;
this
.
_updateArchivedPingData
(
)
;
}
_showRawPingData
(
)
{
show
(
document
.
getElementById
(
"
category
-
raw
"
)
)
;
}
_showStructuredPingData
(
)
{
show
(
document
.
getElementById
(
"
category
-
home
"
)
)
;
}
}
;
var
GeneralData
=
{
render
(
aPing
)
{
setHasData
(
"
general
-
data
-
section
"
true
)
;
let
generalDataSection
=
document
.
getElementById
(
"
general
-
data
"
)
;
removeAllChildNodes
(
generalDataSection
)
;
const
headings
=
[
"
namesHeader
"
"
valuesHeader
"
]
.
map
(
h
=
>
bundle
.
GetStringFromName
(
h
)
)
;
let
ignoreSections
=
[
"
payload
"
"
environment
"
]
;
let
data
=
explodeObject
(
filterObject
(
aPing
ignoreSections
)
)
;
const
table
=
GenericTable
.
render
(
data
headings
)
;
generalDataSection
.
appendChild
(
table
)
;
}
}
;
var
EnvironmentData
=
{
render
(
ping
)
{
let
dataDiv
=
document
.
getElementById
(
"
environment
-
data
"
)
;
removeAllChildNodes
(
dataDiv
)
;
const
hasData
=
!
!
ping
.
environment
;
setHasData
(
"
environment
-
data
-
section
"
hasData
)
;
if
(
!
hasData
)
{
return
;
}
let
ignore
=
[
"
addons
"
]
;
let
env
=
filterObject
(
ping
.
environment
ignore
)
;
let
sections
=
sectionalizeObject
(
env
)
;
GenericSubsection
.
render
(
sections
dataDiv
"
environment
-
data
-
section
"
)
;
this
.
createAddonSection
(
dataDiv
ping
)
;
}
renderPersona
(
addonObj
addonSection
sectionTitle
)
{
let
table
=
document
.
createElement
(
"
table
"
)
;
table
.
setAttribute
(
"
id
"
sectionTitle
)
;
this
.
appendAddonSubsectionTitle
(
sectionTitle
table
)
;
this
.
appendRow
(
table
"
persona
"
addonObj
.
persona
)
;
addonSection
.
appendChild
(
table
)
;
}
renderActivePlugins
(
addonObj
addonSection
sectionTitle
)
{
let
table
=
document
.
createElement
(
"
table
"
)
;
table
.
setAttribute
(
"
id
"
sectionTitle
)
;
this
.
appendAddonSubsectionTitle
(
sectionTitle
table
)
;
for
(
let
plugin
of
addonObj
)
{
let
data
=
explodeObject
(
plugin
)
;
this
.
appendHeadingName
(
table
data
.
get
(
"
name
"
)
)
;
for
(
let
[
key
value
]
of
data
)
{
this
.
appendRow
(
table
key
value
)
;
}
}
addonSection
.
appendChild
(
table
)
;
}
renderAddonsObject
(
addonObj
addonSection
sectionTitle
)
{
let
table
=
document
.
createElement
(
"
table
"
)
;
table
.
setAttribute
(
"
id
"
sectionTitle
)
;
this
.
appendAddonSubsectionTitle
(
sectionTitle
table
)
;
for
(
let
id
of
Object
.
keys
(
addonObj
)
)
{
let
addon
=
addonObj
[
id
]
;
this
.
appendHeadingName
(
table
addon
.
name
|
|
id
)
;
this
.
appendAddonID
(
table
id
)
;
let
data
=
explodeObject
(
addon
)
;
for
(
let
[
key
value
]
of
data
)
{
this
.
appendRow
(
table
key
value
)
;
}
}
addonSection
.
appendChild
(
table
)
;
}
renderKeyValueObject
(
addonObj
addonSection
sectionTitle
)
{
let
data
=
explodeObject
(
addonObj
)
;
let
table
=
GenericTable
.
render
(
data
)
;
table
.
setAttribute
(
"
class
"
sectionTitle
)
;
this
.
appendAddonSubsectionTitle
(
sectionTitle
table
)
;
addonSection
.
appendChild
(
table
)
;
}
appendAddonID
(
table
addonID
)
{
this
.
appendRow
(
table
"
id
"
addonID
)
;
}
appendHeadingName
(
table
name
)
{
let
headings
=
document
.
createElement
(
"
tr
"
)
;
this
.
appendColumn
(
headings
"
th
"
name
)
;
headings
.
cells
[
0
]
.
colSpan
=
2
;
table
.
appendChild
(
headings
)
;
}
appendAddonSubsectionTitle
(
section
table
)
{
let
caption
=
document
.
createElement
(
"
caption
"
)
;
caption
.
setAttribute
(
"
class
"
"
addon
-
caption
"
)
;
caption
.
appendChild
(
document
.
createTextNode
(
section
)
)
;
table
.
appendChild
(
caption
)
;
}
createAddonSection
(
dataDiv
ping
)
{
let
addonSection
=
document
.
createElement
(
"
div
"
)
;
addonSection
.
setAttribute
(
"
class
"
"
subsection
-
data
subdata
"
)
;
let
addons
=
ping
.
environment
.
addons
;
this
.
renderAddonsObject
(
addons
.
activeAddons
addonSection
"
activeAddons
"
)
;
this
.
renderActivePlugins
(
addons
.
activePlugins
addonSection
"
activePlugins
"
)
;
this
.
renderKeyValueObject
(
addons
.
theme
addonSection
"
theme
"
)
;
this
.
renderKeyValueObject
(
addons
.
activeExperiment
addonSection
"
activeExperiment
"
)
;
this
.
renderAddonsObject
(
addons
.
activeGMPlugins
addonSection
"
activeGMPlugins
"
)
;
this
.
renderPersona
(
addons
addonSection
"
persona
"
)
;
let
hasAddonData
=
Object
.
keys
(
ping
.
environment
.
addons
)
.
length
>
0
;
let
s
=
GenericSubsection
.
renderSubsectionHeader
(
"
addons
"
hasAddonData
"
environment
-
data
-
section
"
)
;
s
.
appendChild
(
addonSection
)
;
dataDiv
.
appendChild
(
s
)
;
}
appendRow
(
table
id
value
)
{
let
row
=
document
.
createElement
(
"
tr
"
)
;
this
.
appendColumn
(
row
"
td
"
id
)
;
this
.
appendColumn
(
row
"
td
"
value
)
;
table
.
appendChild
(
row
)
;
}
appendColumn
(
aRowElement
aColType
aColText
)
{
let
colElement
=
document
.
createElement
(
aColType
)
;
let
colTextElement
=
document
.
createTextNode
(
aColText
)
;
colElement
.
appendChild
(
colTextElement
)
;
aRowElement
.
appendChild
(
colElement
)
;
}
}
;
var
TelLog
=
{
render
(
aPing
)
{
let
entries
=
aPing
.
payload
.
log
;
const
hasData
=
entries
&
&
entries
.
length
>
0
;
setHasData
(
"
telemetry
-
log
-
section
"
hasData
)
;
if
(
!
hasData
)
{
return
;
}
let
table
=
document
.
createElement
(
"
table
"
)
;
let
caption
=
document
.
createElement
(
"
caption
"
)
;
let
captionString
=
bundle
.
GetStringFromName
(
"
telemetryLogTitle
"
)
;
caption
.
appendChild
(
document
.
createTextNode
(
captionString
+
"
\
n
"
)
)
;
table
.
appendChild
(
caption
)
;
let
headings
=
document
.
createElement
(
"
tr
"
)
;
this
.
appendColumn
(
headings
"
th
"
bundle
.
GetStringFromName
(
"
telemetryLogHeadingId
"
)
+
"
\
t
"
)
;
this
.
appendColumn
(
headings
"
th
"
bundle
.
GetStringFromName
(
"
telemetryLogHeadingTimestamp
"
)
+
"
\
t
"
)
;
this
.
appendColumn
(
headings
"
th
"
bundle
.
GetStringFromName
(
"
telemetryLogHeadingData
"
)
+
"
\
t
"
)
;
table
.
appendChild
(
headings
)
;
for
(
let
entry
of
entries
)
{
let
row
=
document
.
createElement
(
"
tr
"
)
;
for
(
let
elem
of
entry
)
{
this
.
appendColumn
(
row
"
td
"
elem
+
"
\
t
"
)
;
}
table
.
appendChild
(
row
)
;
}
let
dataDiv
=
document
.
getElementById
(
"
telemetry
-
log
"
)
;
removeAllChildNodes
(
dataDiv
)
;
dataDiv
.
appendChild
(
table
)
;
}
appendColumn
(
aRowElement
aColType
aColText
)
{
let
colElement
=
document
.
createElement
(
aColType
)
;
let
colTextElement
=
document
.
createTextNode
(
aColText
)
;
colElement
.
appendChild
(
colTextElement
)
;
aRowElement
.
appendChild
(
colElement
)
;
}
}
;
var
SlowSQL
=
{
slowSqlHits
:
bundle
.
GetStringFromName
(
"
slowSqlHits
"
)
slowSqlAverage
:
bundle
.
GetStringFromName
(
"
slowSqlAverage
"
)
slowSqlStatement
:
bundle
.
GetStringFromName
(
"
slowSqlStatement
"
)
mainThreadTitle
:
bundle
.
GetStringFromName
(
"
slowSqlMain
"
)
otherThreadTitle
:
bundle
.
GetStringFromName
(
"
slowSqlOther
"
)
render
:
function
SlowSQL_render
(
aPing
)
{
let
debugSlowSql
=
PingPicker
.
viewCurrentPingData
&
&
Preferences
.
get
(
PREF_DEBUG_SLOW_SQL
false
)
;
let
slowSql
=
debugSlowSql
?
Telemetry
.
debugSlowSQL
:
aPing
.
payload
.
slowSQL
;
if
(
!
slowSql
)
{
setHasData
(
"
slow
-
sql
-
section
"
false
)
;
return
;
}
let
{
mainThread
otherThreads
}
=
debugSlowSql
?
Telemetry
.
debugSlowSQL
:
aPing
.
payload
.
slowSQL
;
let
mainThreadCount
=
Object
.
keys
(
mainThread
)
.
length
;
let
otherThreadCount
=
Object
.
keys
(
otherThreads
)
.
length
;
if
(
mainThreadCount
=
=
0
&
&
otherThreadCount
=
=
0
)
{
setHasData
(
"
slow
-
sql
-
section
"
false
)
;
return
;
}
setHasData
(
"
slow
-
sql
-
section
"
true
)
;
if
(
debugSlowSql
)
{
document
.
getElementById
(
"
sql
-
warning
"
)
.
hidden
=
false
;
}
let
slowSqlDiv
=
document
.
getElementById
(
"
slow
-
sql
-
tables
"
)
;
removeAllChildNodes
(
slowSqlDiv
)
;
if
(
mainThreadCount
>
0
)
{
let
table
=
document
.
createElement
(
"
table
"
)
;
this
.
renderTableHeader
(
table
this
.
mainThreadTitle
)
;
this
.
renderTable
(
table
mainThread
)
;
slowSqlDiv
.
appendChild
(
table
)
;
slowSqlDiv
.
appendChild
(
document
.
createElement
(
"
hr
"
)
)
;
}
if
(
otherThreadCount
>
0
)
{
let
table
=
document
.
createElement
(
"
table
"
)
;
this
.
renderTableHeader
(
table
this
.
otherThreadTitle
)
;
this
.
renderTable
(
table
otherThreads
)
;
slowSqlDiv
.
appendChild
(
table
)
;
slowSqlDiv
.
appendChild
(
document
.
createElement
(
"
hr
"
)
)
;
}
}
renderTableHeader
:
function
SlowSQL_renderTableHeader
(
aTable
aTitle
)
{
let
caption
=
document
.
createElement
(
"
caption
"
)
;
caption
.
appendChild
(
document
.
createTextNode
(
aTitle
+
"
\
n
"
)
)
;
aTable
.
appendChild
(
caption
)
;
let
headings
=
document
.
createElement
(
"
tr
"
)
;
this
.
appendColumn
(
headings
"
th
"
this
.
slowSqlHits
+
"
\
t
"
)
;
this
.
appendColumn
(
headings
"
th
"
this
.
slowSqlAverage
+
"
\
t
"
)
;
this
.
appendColumn
(
headings
"
th
"
this
.
slowSqlStatement
+
"
\
n
"
)
;
aTable
.
appendChild
(
headings
)
;
}
renderTable
:
function
SlowSQL_renderTable
(
aTable
aSql
)
{
for
(
let
[
sql
[
hitCount
totalTime
]
]
of
Object
.
entries
(
aSql
)
)
{
let
averageTime
=
totalTime
/
hitCount
;
let
sqlRow
=
document
.
createElement
(
"
tr
"
)
;
this
.
appendColumn
(
sqlRow
"
td
"
hitCount
+
"
\
t
"
)
;
this
.
appendColumn
(
sqlRow
"
td
"
averageTime
.
toFixed
(
0
)
+
"
\
t
"
)
;
this
.
appendColumn
(
sqlRow
"
td
"
sql
+
"
\
n
"
)
;
aTable
.
appendChild
(
sqlRow
)
;
}
}
appendColumn
:
function
SlowSQL_appendColumn
(
aRowElement
aColType
aColText
)
{
let
colElement
=
document
.
createElement
(
aColType
)
;
let
colTextElement
=
document
.
createTextNode
(
aColText
)
;
colElement
.
appendChild
(
colTextElement
)
;
aRowElement
.
appendChild
(
colElement
)
;
}
}
;
var
StackRenderer
=
{
stackTitle
:
bundle
.
GetStringFromName
(
"
stackTitle
"
)
memoryMapTitle
:
bundle
.
GetStringFromName
(
"
memoryMapTitle
"
)
renderMemoryMap
:
function
StackRenderer_renderMemoryMap
(
aDiv
memoryMap
)
{
aDiv
.
appendChild
(
document
.
createTextNode
(
this
.
memoryMapTitle
)
)
;
aDiv
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
for
(
let
currentModule
of
memoryMap
)
{
aDiv
.
appendChild
(
document
.
createTextNode
(
currentModule
.
join
(
"
"
)
)
)
;
aDiv
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
}
aDiv
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
}
renderStack
:
function
StackRenderer_renderStack
(
aDiv
aStack
)
{
aDiv
.
appendChild
(
document
.
createTextNode
(
this
.
stackTitle
)
)
;
let
stackText
=
"
"
+
aStack
.
join
(
"
"
)
;
aDiv
.
appendChild
(
document
.
createTextNode
(
stackText
)
)
;
aDiv
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
aDiv
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
}
renderStacks
:
function
StackRenderer_renderStacks
(
aPrefix
aStacks
aMemoryMap
aRenderHeader
)
{
let
div
=
document
.
getElementById
(
aPrefix
+
"
-
data
"
)
;
removeAllChildNodes
(
div
)
;
let
fetchE
=
document
.
getElementById
(
aPrefix
+
"
-
fetch
-
symbols
"
)
;
if
(
fetchE
)
{
fetchE
.
hidden
=
false
;
}
let
hideE
=
document
.
getElementById
(
aPrefix
+
"
-
hide
-
symbols
"
)
;
if
(
hideE
)
{
hideE
.
hidden
=
true
;
}
if
(
aStacks
.
length
=
=
0
)
{
return
;
}
setHasData
(
aPrefix
+
"
-
section
"
true
)
;
this
.
renderMemoryMap
(
div
aMemoryMap
)
;
for
(
let
i
=
0
;
i
<
aStacks
.
length
;
+
+
i
)
{
let
stack
=
aStacks
[
i
]
;
aRenderHeader
(
i
)
;
this
.
renderStack
(
div
stack
)
}
}
renderHeader
:
function
StackRenderer_renderHeader
(
aPrefix
aFormatArgs
)
{
let
div
=
document
.
getElementById
(
aPrefix
+
"
-
data
"
)
;
let
titleElement
=
document
.
createElement
(
"
span
"
)
;
titleElement
.
className
=
"
stack
-
title
"
;
let
titleText
=
bundle
.
formatStringFromName
(
aPrefix
+
"
-
title
"
aFormatArgs
aFormatArgs
.
length
)
;
titleElement
.
appendChild
(
document
.
createTextNode
(
titleText
)
)
;
div
.
appendChild
(
titleElement
)
;
div
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
}
}
;
var
RawPayload
=
{
render
(
aPing
)
{
setHasData
(
"
raw
-
ping
-
data
-
section
"
true
)
;
let
pre
=
document
.
getElementById
(
"
raw
-
ping
-
data
"
)
;
pre
.
textContent
=
JSON
.
stringify
(
aPing
.
payload
null
2
)
;
}
}
;
function
SymbolicationRequest
(
aPrefix
aRenderHeader
aMemoryMap
aStacks
aDurations
=
null
)
{
this
.
prefix
=
aPrefix
;
this
.
renderHeader
=
aRenderHeader
;
this
.
memoryMap
=
aMemoryMap
;
this
.
stacks
=
aStacks
;
this
.
durations
=
aDurations
;
}
SymbolicationRequest
.
prototype
.
handleSymbolResponse
=
function
SymbolicationRequest_handleSymbolResponse
(
)
{
if
(
this
.
symbolRequest
.
readyState
!
=
4
)
return
;
let
fetchElement
=
document
.
getElementById
(
this
.
prefix
+
"
-
fetch
-
symbols
"
)
;
fetchElement
.
hidden
=
true
;
let
hideElement
=
document
.
getElementById
(
this
.
prefix
+
"
-
hide
-
symbols
"
)
;
hideElement
.
hidden
=
false
;
let
div
=
document
.
getElementById
(
this
.
prefix
+
"
-
data
"
)
;
removeAllChildNodes
(
div
)
;
let
errorMessage
=
bundle
.
GetStringFromName
(
"
errorFetchingSymbols
"
)
;
if
(
this
.
symbolRequest
.
status
!
=
200
)
{
div
.
appendChild
(
document
.
createTextNode
(
errorMessage
)
)
;
return
;
}
let
jsonResponse
=
{
}
;
try
{
jsonResponse
=
JSON
.
parse
(
this
.
symbolRequest
.
responseText
)
;
}
catch
(
e
)
{
div
.
appendChild
(
document
.
createTextNode
(
errorMessage
)
)
;
return
;
}
for
(
let
i
=
0
;
i
<
jsonResponse
.
length
;
+
+
i
)
{
let
stack
=
jsonResponse
[
i
]
;
this
.
renderHeader
(
i
this
.
durations
)
;
for
(
let
symbol
of
stack
)
{
div
.
appendChild
(
document
.
createTextNode
(
symbol
)
)
;
div
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
}
div
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
}
}
;
SymbolicationRequest
.
prototype
.
fetchSymbols
=
function
SymbolicationRequest_fetchSymbols
(
)
{
let
symbolServerURI
=
Preferences
.
get
(
PREF_SYMBOL_SERVER_URI
DEFAULT_SYMBOL_SERVER_URI
)
;
let
request
=
{
"
memoryMap
"
:
this
.
memoryMap
"
stacks
"
:
this
.
stacks
"
version
"
:
3
}
;
let
requestJSON
=
JSON
.
stringify
(
request
)
;
this
.
symbolRequest
=
new
XMLHttpRequest
(
)
;
this
.
symbolRequest
.
open
(
"
POST
"
symbolServerURI
true
)
;
this
.
symbolRequest
.
setRequestHeader
(
"
Content
-
type
"
"
application
/
json
"
)
;
this
.
symbolRequest
.
setRequestHeader
(
"
Content
-
length
"
requestJSON
.
length
)
;
this
.
symbolRequest
.
setRequestHeader
(
"
Connection
"
"
close
"
)
;
this
.
symbolRequest
.
onreadystatechange
=
this
.
handleSymbolResponse
.
bind
(
this
)
;
this
.
symbolRequest
.
send
(
requestJSON
)
;
}
var
ChromeHangs
=
{
symbolRequest
:
null
render
:
function
ChromeHangs_render
(
aPing
)
{
let
hangs
=
aPing
.
payload
.
chromeHangs
;
setHasData
(
"
chrome
-
hangs
-
section
"
!
!
hangs
)
;
if
(
!
hangs
)
{
return
;
}
let
stacks
=
hangs
.
stacks
;
let
memoryMap
=
hangs
.
memoryMap
;
let
durations
=
hangs
.
durations
;
StackRenderer
.
renderStacks
(
"
chrome
-
hangs
"
stacks
memoryMap
(
index
)
=
>
this
.
renderHangHeader
(
index
durations
)
)
;
}
renderHangHeader
:
function
ChromeHangs_renderHangHeader
(
aIndex
aDurations
)
{
StackRenderer
.
renderHeader
(
"
chrome
-
hangs
"
[
aIndex
+
1
aDurations
[
aIndex
]
]
)
;
}
}
;
var
CapturedStacks
=
{
symbolRequest
:
null
render
:
function
CapturedStacks_render
(
payload
)
{
let
capturedStacks
=
"
processes
"
in
payload
&
&
"
parent
"
in
payload
.
processes
?
payload
.
processes
.
parent
.
capturedStacks
:
false
;
let
hasData
=
capturedStacks
&
&
capturedStacks
.
stacks
&
&
capturedStacks
.
stacks
.
length
>
0
;
setHasData
(
"
captured
-
stacks
-
section
"
hasData
)
;
if
(
!
hasData
)
{
return
;
}
let
stacks
=
capturedStacks
.
stacks
;
let
memoryMap
=
capturedStacks
.
memoryMap
;
let
captures
=
capturedStacks
.
captures
;
StackRenderer
.
renderStacks
(
"
captured
-
stacks
"
stacks
memoryMap
(
index
)
=
>
this
.
renderCaptureHeader
(
index
captures
)
)
;
}
renderCaptureHeader
:
function
CaptureStacks_renderCaptureHeader
(
index
captures
)
{
let
key
=
captures
[
index
]
[
0
]
;
let
cardinality
=
captures
[
index
]
[
2
]
;
StackRenderer
.
renderHeader
(
"
captured
-
stacks
"
[
key
cardinality
]
)
;
}
}
;
var
ThreadHangStats
=
{
render
(
aPayload
)
{
let
div
=
document
.
getElementById
(
"
thread
-
hang
-
stats
"
)
;
removeAllChildNodes
(
div
)
;
let
stats
=
aPayload
.
threadHangStats
;
setHasData
(
"
thread
-
hang
-
stats
-
section
"
stats
&
&
(
stats
.
length
>
0
)
)
;
if
(
!
stats
)
{
return
;
}
stats
.
forEach
(
(
thread
)
=
>
{
div
.
appendChild
(
this
.
renderThread
(
thread
)
)
;
}
)
;
}
renderThread
(
aThread
)
{
let
div
=
document
.
createElement
(
"
div
"
)
;
let
title
=
document
.
createElement
(
"
h2
"
)
;
title
.
textContent
=
aThread
.
name
;
div
.
appendChild
(
title
)
;
Histogram
.
render
(
div
aThread
.
name
+
"
-
Activity
"
aThread
.
activity
{
exponential
:
true
}
true
)
;
aThread
.
hangs
.
forEach
(
(
hang
index
)
=
>
{
let
hangName
=
aThread
.
name
+
"
-
Hang
-
"
+
(
index
+
1
)
;
let
hangDiv
=
Histogram
.
render
(
div
hangName
hang
.
histogram
{
exponential
:
true
}
true
)
;
let
stackDiv
=
document
.
createElement
(
"
div
"
)
;
hang
.
stack
.
forEach
(
(
frame
)
=
>
{
stackDiv
.
appendChild
(
document
.
createTextNode
(
frame
)
)
;
stackDiv
.
appendChild
(
document
.
createElement
(
"
br
"
)
)
;
}
)
;
hangDiv
.
insertBefore
(
stackDiv
hangDiv
.
childNodes
[
1
]
)
;
}
)
;
return
div
;
}
}
;
var
Histogram
=
{
hgramSamplesCaption
:
bundle
.
GetStringFromName
(
"
histogramSamples
"
)
hgramAverageCaption
:
bundle
.
GetStringFromName
(
"
histogramAverage
"
)
hgramSumCaption
:
bundle
.
GetStringFromName
(
"
histogramSum
"
)
hgramCopyCaption
:
bundle
.
GetStringFromName
(
"
histogramCopy
"
)
render
:
function
Histogram_render
(
aParent
aName
aHgram
aOptions
aIsBHR
)
{
let
options
=
aOptions
|
|
{
}
;
let
hgram
=
this
.
processHistogram
(
aHgram
aName
aIsBHR
)
;
let
outerDiv
=
document
.
createElement
(
"
div
"
)
;
outerDiv
.
className
=
"
histogram
"
;
outerDiv
.
id
=
aName
;
let
divTitle
=
document
.
createElement
(
"
div
"
)
;
divTitle
.
className
=
"
histogram
-
title
"
;
divTitle
.
appendChild
(
document
.
createTextNode
(
aName
)
)
;
outerDiv
.
appendChild
(
divTitle
)
;
let
stats
=
hgram
.
sample_count
+
"
"
+
this
.
hgramSamplesCaption
+
"
"
+
this
.
hgramAverageCaption
+
"
=
"
+
hgram
.
pretty_average
+
"
"
+
this
.
hgramSumCaption
+
"
=
"
+
hgram
.
sum
;
let
divStats
=
document
.
createElement
(
"
div
"
)
;
divStats
.
appendChild
(
document
.
createTextNode
(
stats
)
)
;
outerDiv
.
appendChild
(
divStats
)
;
if
(
isRTL
(
)
)
{
hgram
.
buckets
.
reverse
(
)
;
hgram
.
values
.
reverse
(
)
;
}
let
textData
=
this
.
renderValues
(
outerDiv
hgram
options
)
;
let
copyButton
=
document
.
createElement
(
"
button
"
)
;
copyButton
.
className
=
"
copy
-
node
"
;
copyButton
.
appendChild
(
document
.
createTextNode
(
this
.
hgramCopyCaption
)
)
;
copyButton
.
histogramText
=
aName
+
EOL
+
stats
+
EOL
+
EOL
+
textData
;
copyButton
.
addEventListener
(
"
click
"
function
(
)
{
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
.
copyString
(
this
.
histogramText
)
;
}
)
;
outerDiv
.
appendChild
(
copyButton
)
;
aParent
.
appendChild
(
outerDiv
)
;
return
outerDiv
;
}
processHistogram
(
aHgram
aName
aIsBHR
)
{
const
values
=
Object
.
keys
(
aHgram
.
values
)
.
map
(
k
=
>
aHgram
.
values
[
k
]
)
;
if
(
!
values
.
length
)
{
return
{
values
:
[
]
pretty_average
:
0
max
:
0
sample_count
:
0
sum
:
0
}
;
}
const
sample_count
=
values
.
reduceRight
(
(
a
b
)
=
>
a
+
b
)
;
const
average
=
Math
.
round
(
aHgram
.
sum
*
10
/
sample_count
)
/
10
;
const
max_value
=
Math
.
max
(
.
.
.
values
)
;
function
labelFunc
(
k
)
{
if
(
!
aIsBHR
)
{
return
k
;
}
return
k
=
=
1
?
0
:
(
k
+
1
)
/
2
;
}
const
labelledValues
=
Object
.
keys
(
aHgram
.
values
)
.
filter
(
label
=
>
!
aIsBHR
|
|
Number
(
label
)
!
=
0
)
.
map
(
k
=
>
[
labelFunc
(
Number
(
k
)
)
aHgram
.
values
[
k
]
]
)
;
let
result
=
{
values
:
labelledValues
pretty_average
:
average
max
:
max_value
sample_count
sum
:
aHgram
.
sum
}
;
return
result
;
}
getLogValue
(
aNumber
)
{
return
Math
.
max
(
0
Math
.
log10
(
aNumber
)
+
1
)
;
}
renderValues
:
function
Histogram_renderValues
(
aDiv
aHgram
aOptions
)
{
let
text
=
"
"
;
let
labelPadTo
=
0
;
if
(
aHgram
.
values
.
length
)
{
labelPadTo
=
String
(
aHgram
.
values
[
aHgram
.
values
.
length
-
1
]
[
0
]
)
.
length
;
}
let
maxBarValue
=
aOptions
.
exponential
?
this
.
getLogValue
(
aHgram
.
max
)
:
aHgram
.
max
;
for
(
let
[
label
value
]
of
aHgram
.
values
)
{
let
barValue
=
aOptions
.
exponential
?
this
.
getLogValue
(
value
)
:
value
;
text
+
=
EOL
+
"
"
.
repeat
(
Math
.
max
(
0
labelPadTo
-
String
(
label
)
.
length
)
)
+
label
+
"
|
"
+
"
#
"
.
repeat
(
Math
.
round
(
MAX_BAR_CHARS
*
barValue
/
maxBarValue
)
)
+
"
"
+
value
+
"
"
+
Math
.
round
(
100
*
value
/
aHgram
.
sample_count
)
+
"
%
"
;
let
belowEm
=
Math
.
round
(
MAX_BAR_HEIGHT
*
(
barValue
/
maxBarValue
)
*
10
)
/
10
;
let
aboveEm
=
MAX_BAR_HEIGHT
-
belowEm
;
let
barDiv
=
document
.
createElement
(
"
div
"
)
;
barDiv
.
className
=
"
bar
"
;
barDiv
.
style
.
paddingTop
=
aboveEm
+
"
em
"
;
barDiv
.
appendChild
(
document
.
createTextNode
(
value
?
value
:
"
\
u00A0
"
)
)
;
let
bar
=
document
.
createElement
(
"
div
"
)
;
bar
.
className
=
"
bar
-
inner
"
;
bar
.
style
.
height
=
belowEm
+
"
em
"
;
barDiv
.
appendChild
(
bar
)
;
barDiv
.
appendChild
(
document
.
createTextNode
(
label
)
)
;
aDiv
.
appendChild
(
barDiv
)
;
}
return
text
.
substr
(
EOL
.
length
)
;
}
filterHistograms
:
function
_filterHistograms
(
aContainerNode
aFilterText
)
{
let
filter
=
aFilterText
.
toString
(
)
;
function
isPassText
(
subject
filter
)
{
for
(
let
item
of
filter
)
{
if
(
item
.
length
&
&
subject
.
indexOf
(
item
)
<
0
)
{
return
false
;
}
}
return
true
;
}
function
isPassRegex
(
subject
filter
)
{
return
filter
.
test
(
subject
)
;
}
let
isPassFunc
;
filter
=
filter
.
trim
(
)
;
if
(
filter
[
0
]
!
=
"
/
"
)
{
isPassFunc
=
isPassText
;
filter
=
filter
.
toLowerCase
(
)
.
split
(
"
"
)
;
}
else
{
isPassFunc
=
isPassRegex
;
var
r
=
filter
.
match
(
/
^
\
/
(
.
*
)
\
/
(
i
?
)
/
)
;
try
{
filter
=
RegExp
(
r
[
1
]
r
[
2
]
)
;
}
catch
(
e
)
{
isPassFunc
=
function
(
)
{
return
false
;
}
;
}
}
let
needLower
=
(
isPassFunc
=
=
=
isPassText
)
;
let
histograms
=
aContainerNode
.
getElementsByClassName
(
"
histogram
"
)
;
for
(
let
hist
of
histograms
)
{
hist
.
classList
[
isPassFunc
(
(
needLower
?
hist
.
id
.
toLowerCase
(
)
:
hist
.
id
)
filter
)
?
"
remove
"
:
"
add
"
]
(
"
filter
-
blocked
"
)
;
}
}
histogramFilterChanged
:
function
_histogramFilterChanged
(
)
{
if
(
this
.
idleTimeout
)
{
clearTimeout
(
this
.
idleTimeout
)
;
}
this
.
idleTimeout
=
setTimeout
(
(
)
=
>
{
Histogram
.
filterHistograms
(
document
.
getElementById
(
this
.
getAttribute
(
"
target_id
"
)
)
this
.
value
)
;
}
FILTER_IDLE_TIMEOUT
)
;
}
}
;
function
RenderObject
(
aObject
)
{
let
output
=
"
"
;
if
(
Array
.
isArray
(
aObject
)
)
{
if
(
aObject
.
length
=
=
0
)
{
return
"
[
]
"
;
}
output
=
"
[
"
+
JSON
.
stringify
(
aObject
[
0
]
)
;
for
(
let
i
=
1
;
i
<
aObject
.
length
;
i
+
+
)
{
output
+
=
"
"
+
JSON
.
stringify
(
aObject
[
i
]
)
;
}
return
output
+
"
]
"
;
}
let
keys
=
Object
.
keys
(
aObject
)
;
if
(
keys
.
length
=
=
0
)
{
return
"
{
}
"
;
}
output
=
"
{
\
"
"
+
keys
[
0
]
+
"
\
"
:
\
u00A0
"
+
JSON
.
stringify
(
aObject
[
keys
[
0
]
]
)
;
for
(
let
i
=
1
;
i
<
keys
.
length
;
i
+
+
)
{
output
+
=
"
\
"
"
+
keys
[
i
]
+
"
\
"
:
\
u00A0
"
+
JSON
.
stringify
(
aObject
[
keys
[
i
]
]
)
;
}
return
output
+
"
}
"
;
}
var
GenericSubsection
=
{
addSubSectionToSidebar
(
id
title
)
{
let
category
=
document
.
querySelector
(
"
#
categories
>
[
value
=
"
+
id
+
"
]
"
)
;
category
.
classList
.
add
(
"
has
-
subsection
"
)
;
let
subCategory
=
document
.
createElement
(
"
div
"
)
;
subCategory
.
classList
.
add
(
"
category
-
subsection
"
)
;
subCategory
.
setAttribute
(
"
value
"
id
+
"
-
"
+
title
)
;
subCategory
.
addEventListener
(
"
click
"
(
ev
)
=
>
{
let
section
=
ev
.
target
;
showSubSection
(
section
)
;
}
)
;
subCategory
.
appendChild
(
document
.
createTextNode
(
title
)
)
category
.
appendChild
(
subCategory
)
;
}
render
(
data
dataDiv
sectionID
)
{
for
(
let
[
title
sectionData
]
of
data
)
{
let
hasData
=
sectionData
.
size
>
0
;
let
s
=
this
.
renderSubsectionHeader
(
title
hasData
sectionID
)
;
s
.
appendChild
(
this
.
renderSubsectionData
(
title
sectionData
)
)
;
dataDiv
.
appendChild
(
s
)
;
}
}
renderSubsectionHeader
(
title
hasData
sectionID
)
{
this
.
addSubSectionToSidebar
(
sectionID
title
)
;
let
section
=
document
.
createElement
(
"
section
"
)
;
section
.
setAttribute
(
"
id
"
sectionID
+
"
-
"
+
title
)
;
section
.
classList
.
add
(
"
data
-
subsection
"
"
expanded
"
)
;
if
(
hasData
)
{
section
.
classList
.
add
(
"
has
-
subdata
"
)
;
}
return
section
;
}
renderSubsectionData
(
title
data
)
{
let
dataDiv
=
document
.
createElement
(
"
div
"
)
;
dataDiv
.
setAttribute
(
"
class
"
"
subsection
-
data
subdata
"
)
;
let
table
=
GenericTable
.
render
(
data
)
;
let
caption
=
document
.
createElement
(
"
caption
"
)
;
caption
.
textContent
=
title
;
table
.
appendChild
(
caption
)
;
dataDiv
.
appendChild
(
table
)
;
return
dataDiv
;
}
deleteAllSubSections
(
)
{
let
subsections
=
document
.
querySelectorAll
(
"
.
category
-
subsection
"
)
;
subsections
.
forEach
(
(
el
)
=
>
{
el
.
parentElement
.
removeChild
(
el
)
;
}
)
}
}
var
GenericTable
=
{
defaultHeadings
:
[
bundle
.
GetStringFromName
(
"
keysHeader
"
)
bundle
.
GetStringFromName
(
"
valuesHeader
"
)
]
render
(
rows
headings
=
this
.
defaultHeadings
)
{
let
table
=
document
.
createElement
(
"
table
"
)
;
this
.
renderHeader
(
table
headings
)
;
this
.
renderBody
(
table
rows
)
;
return
table
;
}
renderHeader
(
table
headings
)
{
let
headerRow
=
document
.
createElement
(
"
tr
"
)
;
table
.
appendChild
(
headerRow
)
;
for
(
let
i
=
0
;
i
<
headings
.
length
;
+
+
i
)
{
let
suffix
=
(
i
=
=
(
headings
.
length
-
1
)
)
?
"
\
n
"
:
"
\
t
"
;
let
column
=
document
.
createElement
(
"
th
"
)
;
column
.
appendChild
(
document
.
createTextNode
(
headings
[
i
]
+
suffix
)
)
;
headerRow
.
appendChild
(
column
)
;
}
}
renderBody
(
table
rows
)
{
for
(
let
row
of
rows
)
{
row
=
row
.
map
(
value
=
>
{
if
(
value
&
&
(
typeof
value
=
=
"
object
"
)
&
&
(
typeof
value
.
valueOf
(
)
=
=
"
object
"
)
)
{
return
RenderObject
(
value
)
;
}
return
value
;
}
)
;
let
newRow
=
document
.
createElement
(
"
tr
"
)
;
table
.
appendChild
(
newRow
)
;
for
(
let
i
=
0
;
i
<
row
.
length
;
+
+
i
)
{
let
suffix
=
(
i
=
=
(
row
.
length
-
1
)
)
?
"
\
n
"
:
"
\
t
"
;
let
field
=
document
.
createElement
(
"
td
"
)
;
field
.
appendChild
(
document
.
createTextNode
(
row
[
i
]
+
suffix
)
)
;
newRow
.
appendChild
(
field
)
;
}
}
}
}
;
var
KeyedHistogram
=
{
render
(
parent
id
keyedHistogram
)
{
let
outerDiv
=
document
.
createElement
(
"
div
"
)
;
outerDiv
.
className
=
"
keyed
-
histogram
"
;
outerDiv
.
id
=
id
;
let
divTitle
=
document
.
createElement
(
"
div
"
)
;
divTitle
.
className
=
"
keyed
-
histogram
-
title
"
;
divTitle
.
appendChild
(
document
.
createTextNode
(
id
)
)
;
outerDiv
.
appendChild
(
divTitle
)
;
for
(
let
[
name
hgram
]
of
Object
.
entries
(
keyedHistogram
)
)
{
Histogram
.
render
(
outerDiv
name
hgram
)
;
}
parent
.
appendChild
(
outerDiv
)
;
return
outerDiv
;
}
}
;
var
AddonDetails
=
{
tableIDTitle
:
bundle
.
GetStringFromName
(
"
addonTableID
"
)
tableDetailsTitle
:
bundle
.
GetStringFromName
(
"
addonTableDetails
"
)
render
:
function
AddonDetails_render
(
aPing
)
{
let
addonSection
=
document
.
getElementById
(
"
addon
-
details
"
)
;
removeAllChildNodes
(
addonSection
)
;
let
addonDetails
=
aPing
.
payload
.
addonDetails
;
const
hasData
=
addonDetails
&
&
Object
.
keys
(
addonDetails
)
.
length
>
0
;
setHasData
(
"
addon
-
details
-
section
"
hasData
)
;
if
(
!
hasData
)
{
return
;
}
for
(
let
provider
in
addonDetails
)
{
let
providerSection
=
document
.
createElement
(
"
h2
"
)
;
let
titleText
=
bundle
.
formatStringFromName
(
"
addonProvider
"
[
provider
]
1
)
;
providerSection
.
appendChild
(
document
.
createTextNode
(
titleText
)
)
;
addonSection
.
appendChild
(
providerSection
)
;
let
headingStrings
=
[
this
.
tableIDTitle
this
.
tableDetailsTitle
]
let
table
=
GenericTable
.
render
(
explodeObject
(
addonDetails
[
provider
]
)
headingStrings
)
;
addonSection
.
appendChild
(
table
)
;
}
}
}
;
var
Scalars
=
{
render
(
aPayload
)
{
let
scalarsSection
=
document
.
getElementById
(
"
scalars
"
)
;
removeAllChildNodes
(
scalarsSection
)
;
let
processesSelect
=
document
.
getElementById
(
"
scalars
-
processes
"
)
;
let
selectedProcess
=
processesSelect
.
selectedOptions
.
item
(
0
)
.
getAttribute
(
"
value
"
)
;
if
(
!
aPayload
.
processes
|
|
!
selectedProcess
|
|
!
(
selectedProcess
in
aPayload
.
processes
)
)
{
return
;
}
let
scalars
=
aPayload
.
processes
[
selectedProcess
]
.
scalars
;
const
hasData
=
scalars
&
&
Object
.
keys
(
scalars
)
.
length
>
0
;
setHasData
(
"
scalars
-
section
"
hasData
|
|
processesSelect
.
options
.
length
)
;
if
(
!
hasData
)
{
return
;
}
const
headings
=
[
"
namesHeader
"
"
valuesHeader
"
]
.
map
(
h
=
>
bundle
.
GetStringFromName
(
h
)
)
;
const
table
=
GenericTable
.
render
(
explodeObject
(
scalars
)
headings
)
;
scalarsSection
.
appendChild
(
table
)
;
}
}
;
var
KeyedScalars
=
{
render
(
aPayload
)
{
let
scalarsSection
=
document
.
getElementById
(
"
keyed
-
scalars
"
)
;
removeAllChildNodes
(
scalarsSection
)
;
let
processesSelect
=
document
.
getElementById
(
"
keyed
-
scalars
-
processes
"
)
;
let
selectedProcess
=
processesSelect
.
selectedOptions
.
item
(
0
)
.
getAttribute
(
"
value
"
)
;
if
(
!
aPayload
.
processes
|
|
!
selectedProcess
|
|
!
(
selectedProcess
in
aPayload
.
processes
)
)
{
return
;
}
let
keyedScalars
=
aPayload
.
processes
[
selectedProcess
]
.
keyedScalars
;
const
hasData
=
keyedScalars
&
&
Object
.
keys
(
keyedScalars
)
.
length
>
0
;
setHasData
(
"
keyed
-
scalars
-
section
"
hasData
|
|
processesSelect
.
options
.
length
)
;
if
(
!
hasData
)
{
return
;
}
const
headings
=
[
"
namesHeader
"
"
valuesHeader
"
]
.
map
(
h
=
>
bundle
.
GetStringFromName
(
h
)
)
;
for
(
let
scalar
in
keyedScalars
)
{
let
scalarNameSection
=
document
.
createElement
(
"
h2
"
)
;
scalarNameSection
.
appendChild
(
document
.
createTextNode
(
scalar
)
)
;
scalarsSection
.
appendChild
(
scalarNameSection
)
;
const
table
=
GenericTable
.
render
(
explodeObject
(
keyedScalars
[
scalar
]
)
headings
)
;
scalarsSection
.
appendChild
(
table
)
;
}
}
}
;
var
Events
=
{
render
(
aPayload
)
{
let
eventsSection
=
document
.
getElementById
(
"
events
"
)
;
removeAllChildNodes
(
eventsSection
)
;
if
(
!
aPayload
.
processes
|
|
!
aPayload
.
processes
.
parent
)
{
return
;
}
let
processesSelect
=
document
.
getElementById
(
"
events
-
processes
"
)
;
let
selectedProcess
=
processesSelect
.
selectedOptions
.
item
(
0
)
.
getAttribute
(
"
value
"
)
;
if
(
!
aPayload
.
processes
|
|
!
selectedProcess
|
|
!
(
selectedProcess
in
aPayload
.
processes
)
)
{
return
;
}
let
events
=
aPayload
.
processes
[
selectedProcess
]
.
events
;
const
hasData
=
events
&
&
Object
.
keys
(
events
)
.
length
>
0
;
setHasData
(
"
events
-
section
"
hasData
)
;
if
(
!
hasData
)
{
return
;
}
const
headings
=
[
"
timestampHeader
"
"
categoryHeader
"
"
methodHeader
"
"
objectHeader
"
"
valuesHeader
"
"
extraHeader
"
]
.
map
(
h
=
>
bundle
.
GetStringFromName
(
h
)
)
;
const
table
=
GenericTable
.
render
(
events
headings
)
;
eventsSection
.
appendChild
(
table
)
;
}
}
;
function
setHasData
(
aSectionID
aHasData
)
{
let
sectionElement
=
document
.
getElementById
(
aSectionID
)
;
sectionElement
.
classList
[
aHasData
?
"
add
"
:
"
remove
"
]
(
"
has
-
data
"
)
;
let
sectionCategory
=
document
.
querySelector
(
"
.
category
[
value
=
"
+
aSectionID
+
"
]
"
)
;
sectionCategory
.
classList
[
aHasData
?
"
add
"
:
"
remove
"
]
(
"
has
-
data
"
)
;
}
function
toggleSection
(
aEvent
)
{
let
parentElement
=
aEvent
.
target
.
parentElement
;
if
(
!
parentElement
.
classList
.
contains
(
"
has
-
data
"
)
&
&
!
parentElement
.
classList
.
contains
(
"
has
-
subdata
"
)
)
{
return
;
}
parentElement
.
classList
.
toggle
(
"
expanded
"
)
;
let
statebox
=
parentElement
.
getElementsByClassName
(
"
statebox
"
)
[
0
]
;
if
(
statebox
)
{
statebox
.
checked
=
parentElement
.
classList
.
contains
(
"
expanded
"
)
;
}
}
function
setupPageHeader
(
)
{
let
serverOwner
=
Preferences
.
get
(
PREF_TELEMETRY_SERVER_OWNER
"
Mozilla
"
)
;
let
brandName
=
brandBundle
.
GetStringFromName
(
"
brandFullName
"
)
;
let
subtitleText
=
bundle
.
formatStringFromName
(
"
pageSubtitle
"
[
serverOwner
brandName
]
2
)
;
let
subtitleElement
=
document
.
getElementById
(
"
page
-
subtitle
"
)
;
subtitleElement
.
appendChild
(
document
.
createTextNode
(
subtitleText
)
)
;
}
function
show
(
selected
)
{
let
current_button
=
document
.
querySelector
(
"
.
category
.
selected
"
)
;
current_button
.
classList
.
remove
(
"
selected
"
)
;
selected
.
classList
.
add
(
"
selected
"
)
;
document
.
getSelection
(
)
.
empty
(
)
;
let
current_section
=
document
.
querySelector
(
"
.
active
"
)
;
let
selected_section
=
document
.
getElementById
(
selected
.
getAttribute
(
"
value
"
)
)
;
if
(
current_section
=
=
selected_section
)
return
;
current_section
.
classList
.
remove
(
"
active
"
)
;
current_section
.
hidden
=
true
;
selected_section
.
classList
.
add
(
"
active
"
)
;
selected_section
.
hidden
=
false
;
let
title
=
selected
.
querySelector
(
"
.
category
-
name
"
)
.
textContent
;
document
.
getElementById
(
"
sectionTitle
"
)
.
textContent
=
title
;
}
function
showSubSection
(
selected
)
{
let
current_selection
=
document
.
querySelector
(
"
.
category
-
subsection
.
selected
"
)
;
if
(
current_selection
)
current_selection
.
classList
.
remove
(
"
selected
"
)
;
selected
.
classList
.
add
(
"
selected
"
)
;
let
section
=
document
.
getElementById
(
selected
.
getAttribute
(
"
value
"
)
)
;
section
.
parentElement
.
childNodes
.
forEach
(
(
element
)
=
>
{
element
.
classList
.
remove
(
"
expanded
"
)
;
}
this
)
;
section
.
classList
.
add
(
"
expanded
"
)
;
let
title
=
selected
.
parentElement
.
querySelector
(
"
.
category
-
name
"
)
.
textContent
;
document
.
getElementById
(
"
sectionTitle
"
)
.
textContent
=
title
+
"
-
"
+
selected
.
textContent
;
document
.
getSelection
(
)
.
empty
(
)
;
}
function
setupListeners
(
)
{
Settings
.
attachObservers
(
)
;
PingPicker
.
attachObservers
(
)
;
let
menu
=
document
.
getElementById
(
"
categories
"
)
;
menu
.
addEventListener
(
"
click
"
(
e
)
=
>
{
if
(
e
.
target
&
&
e
.
target
.
parentNode
=
=
menu
)
{
show
(
e
.
target
)
}
}
)
;
window
.
addEventListener
(
"
unload
"
function
(
aEvent
)
{
Settings
.
detachObservers
(
)
;
}
{
once
:
true
}
)
;
document
.
getElementById
(
"
chrome
-
hangs
-
fetch
-
symbols
"
)
.
addEventListener
(
"
click
"
function
(
)
{
if
(
!
gPingData
)
{
return
;
}
let
hangs
=
gPingData
.
payload
.
chromeHangs
;
let
req
=
new
SymbolicationRequest
(
"
chrome
-
hangs
"
ChromeHangs
.
renderHangHeader
hangs
.
memoryMap
hangs
.
stacks
hangs
.
durations
)
;
req
.
fetchSymbols
(
)
;
}
)
;
document
.
getElementById
(
"
chrome
-
hangs
-
hide
-
symbols
"
)
.
addEventListener
(
"
click
"
function
(
)
{
if
(
!
gPingData
)
{
return
;
}
ChromeHangs
.
render
(
gPingData
)
;
}
)
;
document
.
getElementById
(
"
captured
-
stacks
-
fetch
-
symbols
"
)
.
addEventListener
(
"
click
"
function
(
)
{
if
(
!
gPingData
)
{
return
;
}
let
capturedStacks
=
gPingData
.
payload
.
processes
.
parent
.
capturedStacks
;
let
req
=
new
SymbolicationRequest
(
"
captured
-
stacks
"
CapturedStacks
.
renderCaptureHeader
capturedStacks
.
memoryMap
capturedStacks
.
stacks
capturedStacks
.
captures
)
;
req
.
fetchSymbols
(
)
;
}
)
;
document
.
getElementById
(
"
captured
-
stacks
-
hide
-
symbols
"
)
.
addEventListener
(
"
click
"
function
(
)
{
if
(
gPingData
)
{
CapturedStacks
.
render
(
gPingData
.
payload
)
;
}
}
)
;
document
.
getElementById
(
"
late
-
writes
-
fetch
-
symbols
"
)
.
addEventListener
(
"
click
"
function
(
)
{
if
(
!
gPingData
)
{
return
;
}
let
lateWrites
=
gPingData
.
payload
.
lateWrites
;
let
req
=
new
SymbolicationRequest
(
"
late
-
writes
"
LateWritesSingleton
.
renderHeader
lateWrites
.
memoryMap
lateWrites
.
stacks
)
;
req
.
fetchSymbols
(
)
;
}
)
;
document
.
getElementById
(
"
late
-
writes
-
hide
-
symbols
"
)
.
addEventListener
(
"
click
"
function
(
)
{
if
(
!
gPingData
)
{
return
;
}
LateWritesSingleton
.
renderLateWrites
(
gPingData
.
payload
.
lateWrites
)
;
}
)
;
let
sectionHeaders
=
document
.
getElementsByClassName
(
"
section
-
name
"
)
;
for
(
let
sectionHeader
of
sectionHeaders
)
{
sectionHeader
.
addEventListener
(
"
click
"
toggleSection
)
;
}
let
toggleLinks
=
document
.
getElementsByClassName
(
"
toggle
-
caption
"
)
;
for
(
let
toggleLink
of
toggleLinks
)
{
toggleLink
.
addEventListener
(
"
click
"
toggleSection
)
;
}
}
function
onLoad
(
)
{
window
.
removeEventListener
(
"
load
"
onLoad
)
;
setupPageHeader
(
)
;
setupListeners
(
)
;
Settings
.
render
(
)
;
let
stateboxes
=
document
.
getElementsByClassName
(
"
statebox
"
)
;
for
(
let
box
of
stateboxes
)
{
if
(
box
.
checked
)
{
box
.
parentElement
.
classList
.
add
(
"
expanded
"
)
;
}
}
Telemetry
.
asyncFetchTelemetryData
(
(
)
=
>
PingPicker
.
update
(
)
)
;
}
var
LateWritesSingleton
=
{
renderHeader
:
function
LateWritesSingleton_renderHeader
(
aIndex
)
{
StackRenderer
.
renderHeader
(
"
late
-
writes
"
[
aIndex
+
1
]
)
;
}
renderLateWrites
:
function
LateWritesSingleton_renderLateWrites
(
lateWrites
)
{
setHasData
(
"
late
-
writes
-
section
"
!
!
lateWrites
)
;
if
(
!
lateWrites
)
{
return
;
}
let
stacks
=
lateWrites
.
stacks
;
let
memoryMap
=
lateWrites
.
memoryMap
;
StackRenderer
.
renderStacks
(
"
late
-
writes
"
stacks
memoryMap
LateWritesSingleton
.
renderHeader
)
;
}
}
;
var
HistogramSection
=
{
render
(
aPayload
)
{
let
hgramDiv
=
document
.
getElementById
(
"
histograms
"
)
;
removeAllChildNodes
(
hgramDiv
)
;
let
histograms
=
aPayload
.
histograms
;
let
hgramsSelect
=
document
.
getElementById
(
"
histograms
-
processes
"
)
;
let
hgramsOption
=
hgramsSelect
.
selectedOptions
.
item
(
0
)
;
let
hgramsProcess
=
hgramsOption
.
getAttribute
(
"
value
"
)
;
if
(
hgramsProcess
=
=
=
"
parent
"
)
{
hgramsProcess
=
"
"
;
}
if
(
hgramsProcess
&
&
"
processes
"
in
aPayload
&
&
hgramsProcess
in
aPayload
.
processes
)
{
histograms
=
aPayload
.
processes
[
hgramsProcess
]
.
histograms
;
}
let
hasData
=
Object
.
keys
(
histograms
)
.
length
>
0
;
setHasData
(
"
histograms
-
section
"
hasData
|
|
hgramsSelect
.
options
.
length
)
;
if
(
hasData
)
{
for
(
let
[
name
hgram
]
of
Object
.
entries
(
histograms
)
)
{
Histogram
.
render
(
hgramDiv
name
hgram
{
unpacked
:
true
}
)
;
}
let
filterBox
=
document
.
getElementById
(
"
histograms
-
filter
"
)
;
filterBox
.
addEventListener
(
"
input
"
Histogram
.
histogramFilterChanged
)
;
if
(
filterBox
.
value
.
trim
(
)
!
=
"
"
)
{
Histogram
.
filterHistograms
(
hgramDiv
filterBox
.
value
)
;
}
setHasData
(
"
histograms
-
section
"
true
)
;
}
}
}
var
KeyedHistogramSection
=
{
render
(
aPayload
)
{
let
keyedDiv
=
document
.
getElementById
(
"
keyed
-
histograms
"
)
;
removeAllChildNodes
(
keyedDiv
)
;
let
keyedHistograms
=
aPayload
.
keyedHistograms
;
let
keyedHgramsSelect
=
document
.
getElementById
(
"
keyed
-
histograms
-
processes
"
)
;
let
keyedHgramsOption
=
keyedHgramsSelect
.
selectedOptions
.
item
(
0
)
;
let
keyedHgramsProcess
=
keyedHgramsOption
.
getAttribute
(
"
value
"
)
;
if
(
keyedHgramsProcess
=
=
=
"
parent
"
)
{
keyedHgramsProcess
=
"
"
;
}
if
(
keyedHgramsProcess
&
&
"
processes
"
in
aPayload
&
&
keyedHgramsProcess
in
aPayload
.
processes
)
{
keyedHistograms
=
aPayload
.
processes
[
keyedHgramsProcess
]
.
keyedHistograms
;
}
setHasData
(
"
keyed
-
histograms
-
section
"
keyedHgramsSelect
.
options
.
length
)
;
if
(
keyedHistograms
)
{
let
hasData
=
false
;
for
(
let
[
id
keyed
]
of
Object
.
entries
(
keyedHistograms
)
)
{
if
(
Object
.
keys
(
keyed
)
.
length
>
0
)
{
hasData
=
true
;
KeyedHistogram
.
render
(
keyedDiv
id
keyed
{
unpacked
:
true
}
)
;
}
}
setHasData
(
"
keyed
-
histograms
-
section
"
hasData
|
|
keyedHgramsSelect
.
options
.
length
)
;
}
}
}
var
AddonHistogramSection
=
{
render
(
aPayload
)
{
let
addonDiv
=
document
.
getElementById
(
"
addon
-
histograms
"
)
;
removeAllChildNodes
(
addonDiv
)
;
let
addonHistogramsRendered
=
false
;
let
addonData
=
aPayload
.
addonHistograms
;
if
(
addonData
)
{
for
(
let
[
addon
histograms
]
of
Object
.
entries
(
addonData
)
)
{
for
(
let
[
name
hgram
]
of
Object
.
entries
(
histograms
)
)
{
addonHistogramsRendered
=
true
;
Histogram
.
render
(
addonDiv
addon
+
"
:
"
+
name
hgram
{
unpacked
:
true
}
)
;
}
}
}
setHasData
(
"
addon
-
histograms
-
section
"
addonHistogramsRendered
)
;
}
}
var
SessionInformation
=
{
render
(
aPayload
)
{
let
infoSection
=
document
.
getElementById
(
"
session
-
info
"
)
;
removeAllChildNodes
(
infoSection
)
;
let
hasData
=
Object
.
keys
(
aPayload
.
info
)
.
length
>
0
;
setHasData
(
"
session
-
info
-
section
"
hasData
)
;
if
(
hasData
)
{
const
table
=
GenericTable
.
render
(
explodeObject
(
aPayload
.
info
)
)
;
infoSection
.
appendChild
(
table
)
;
}
}
}
var
SimpleMeasurements
=
{
render
(
aPayload
)
{
let
simpleSection
=
document
.
getElementById
(
"
simple
-
measurements
"
)
;
removeAllChildNodes
(
simpleSection
)
;
let
simpleMeasurements
=
this
.
sortStartupMilestones
(
aPayload
.
simpleMeasurements
)
;
let
hasData
=
Object
.
keys
(
simpleMeasurements
)
.
length
>
0
;
setHasData
(
"
simple
-
measurements
-
section
"
hasData
)
;
if
(
hasData
)
{
const
table
=
GenericTable
.
render
(
explodeObject
(
simpleMeasurements
)
)
;
simpleSection
.
appendChild
(
table
)
;
}
}
sortStartupMilestones
(
aSimpleMeasurements
)
{
const
telemetryTimestamps
=
TelemetryTimestamps
.
get
(
)
;
let
startupEvents
=
Services
.
startup
.
getStartupInfo
(
)
;
delete
startupEvents
[
"
process
"
]
;
function
keyIsMilestone
(
k
)
{
return
(
k
in
startupEvents
)
|
|
(
k
in
telemetryTimestamps
)
;
}
let
sortedKeys
=
Object
.
keys
(
aSimpleMeasurements
)
;
sortedKeys
.
sort
(
function
keyCompare
(
keyA
keyB
)
{
let
isKeyAMilestone
=
keyIsMilestone
(
keyA
)
;
let
isKeyBMilestone
=
keyIsMilestone
(
keyB
)
;
if
(
isKeyAMilestone
&
&
!
isKeyBMilestone
)
return
-
1
;
if
(
!
isKeyAMilestone
&
&
isKeyBMilestone
)
return
1
;
if
(
!
isKeyAMilestone
&
&
!
isKeyBMilestone
)
return
0
;
return
aSimpleMeasurements
[
keyA
]
-
aSimpleMeasurements
[
keyB
]
;
}
)
;
let
result
=
{
}
;
for
(
let
key
of
sortedKeys
)
{
result
[
key
]
=
aSimpleMeasurements
[
key
]
;
}
return
result
;
}
}
function
renderProcessList
(
ping
selectEl
)
{
removeAllChildNodes
(
selectEl
)
;
let
option
=
document
.
createElement
(
"
option
"
)
;
option
.
appendChild
(
document
.
createTextNode
(
"
parent
"
)
)
;
option
.
setAttribute
(
"
value
"
"
parent
"
)
;
option
.
selected
=
true
;
selectEl
.
appendChild
(
option
)
;
if
(
!
(
"
processes
"
in
ping
.
payload
)
)
{
selectEl
.
disabled
=
true
;
return
;
}
selectEl
.
disabled
=
false
;
for
(
let
process
of
Object
.
keys
(
ping
.
payload
.
processes
)
)
{
if
(
process
=
=
=
"
parent
"
)
{
continue
;
}
option
=
document
.
createElement
(
"
option
"
)
;
option
.
appendChild
(
document
.
createTextNode
(
process
)
)
;
option
.
setAttribute
(
"
value
"
process
)
;
selectEl
.
appendChild
(
option
)
;
}
}
function
renderPayloadList
(
ping
)
{
let
listEl
=
document
.
getElementById
(
"
choose
-
payload
"
)
;
removeAllChildNodes
(
listEl
)
;
let
option
=
document
.
createElement
(
"
option
"
)
;
let
text
=
bundle
.
GetStringFromName
(
"
parentPayload
"
)
;
let
content
=
document
.
createTextNode
(
text
)
;
let
payloadIndex
=
0
;
option
.
appendChild
(
content
)
;
option
.
setAttribute
(
"
value
"
payloadIndex
+
+
)
;
option
.
selected
=
true
;
listEl
.
appendChild
(
option
)
;
if
(
!
ping
.
payload
.
childPayloads
)
{
listEl
.
disabled
=
true
;
return
}
listEl
.
disabled
=
false
;
for
(
;
payloadIndex
<
=
ping
.
payload
.
childPayloads
.
length
;
+
+
payloadIndex
)
{
option
=
document
.
createElement
(
"
option
"
)
;
text
=
bundle
.
formatStringFromName
(
"
childPayloadN
"
[
payloadIndex
]
1
)
;
content
=
document
.
createTextNode
(
text
)
;
option
.
appendChild
(
content
)
;
option
.
setAttribute
(
"
value
"
payloadIndex
)
;
listEl
.
appendChild
(
option
)
;
}
}
function
togglePingSections
(
isMainPing
)
{
let
commonSections
=
new
Set
(
[
"
heading
"
"
home
"
"
general
-
data
-
section
"
"
environment
-
data
-
section
"
"
raw
-
ping
-
data
-
section
"
]
)
;
let
elements
=
document
.
querySelectorAll
(
"
.
category
"
)
;
for
(
let
section
of
elements
)
{
if
(
commonSections
.
has
(
section
.
getAttribute
(
"
value
"
)
)
)
{
continue
;
}
section
.
classList
.
toggle
(
"
has
-
data
"
isMainPing
)
;
}
}
function
displayPingData
(
ping
updatePayloadList
=
false
)
{
gPingData
=
ping
;
RawPayload
.
render
(
ping
)
;
try
{
PingPicker
.
render
(
)
;
displayRichPingData
(
ping
updatePayloadList
)
;
}
catch
(
err
)
{
console
.
log
(
err
)
;
PingPicker
.
_showRawPingData
(
)
;
}
}
function
displayRichPingData
(
ping
updatePayloadList
)
{
if
(
updatePayloadList
)
{
renderPayloadList
(
ping
)
;
renderProcessList
(
ping
document
.
getElementById
(
"
scalars
-
processes
"
)
)
;
renderProcessList
(
ping
document
.
getElementById
(
"
keyed
-
scalars
-
processes
"
)
)
;
renderProcessList
(
ping
document
.
getElementById
(
"
histograms
-
processes
"
)
)
;
renderProcessList
(
ping
document
.
getElementById
(
"
keyed
-
histograms
-
processes
"
)
)
;
renderProcessList
(
ping
document
.
getElementById
(
"
events
-
processes
"
)
)
;
}
GeneralData
.
render
(
ping
)
;
EnvironmentData
.
render
(
ping
)
;
let
isMainPing
=
(
ping
.
type
=
=
"
main
"
|
|
ping
.
type
=
=
"
saved
-
session
"
)
;
togglePingSections
(
isMainPing
)
;
if
(
!
isMainPing
)
{
return
;
}
TelLog
.
render
(
ping
)
;
SlowSQL
.
render
(
ping
)
;
ChromeHangs
.
render
(
ping
)
;
AddonDetails
.
render
(
ping
)
;
let
payloadSelect
=
document
.
getElementById
(
"
choose
-
payload
"
)
;
let
payloadOption
=
payloadSelect
.
selectedOptions
.
item
(
0
)
;
let
payloadIndex
=
payloadOption
.
getAttribute
(
"
value
"
)
;
let
payload
=
ping
.
payload
;
if
(
payloadIndex
>
0
)
{
payload
=
ping
.
payload
.
childPayloads
[
payloadIndex
-
1
]
;
}
ThreadHangStats
.
render
(
payload
)
;
CapturedStacks
.
render
(
payload
)
;
SimpleMeasurements
.
render
(
payload
)
;
LateWritesSingleton
.
renderLateWrites
(
payload
.
lateWrites
)
;
SessionInformation
.
render
(
payload
)
;
Scalars
.
render
(
payload
)
;
KeyedScalars
.
render
(
payload
)
;
HistogramSection
.
render
(
payload
)
;
KeyedHistogramSection
.
render
(
payload
)
;
Events
.
render
(
payload
)
;
AddonHistogramSection
.
render
(
payload
)
;
}
window
.
addEventListener
(
"
load
"
onLoad
)
;
