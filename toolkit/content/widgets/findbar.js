"
use
strict
"
;
{
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
class
MozFindbar
extends
XULElement
{
constructor
(
)
{
super
(
)
;
MozXULElement
.
insertFTLIfNeeded
(
"
toolkit
/
main
-
window
/
findbar
.
ftl
"
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
addEventListener
(
"
keypress
"
event
=
>
{
if
(
event
.
keyCode
=
=
event
.
DOM_VK_ESCAPE
)
{
if
(
this
.
close
)
{
this
.
close
(
)
;
}
event
.
preventDefault
(
)
;
}
}
true
)
;
this
.
content
=
MozXULElement
.
parseXULToFragment
(
<
hbox
anonid
=
"
findbar
-
container
"
class
=
"
findbar
-
container
"
flex
=
"
1
"
align
=
"
center
"
>
<
hbox
anonid
=
"
findbar
-
textbox
-
wrapper
"
align
=
"
stretch
"
>
<
html
:
input
anonid
=
"
findbar
-
textbox
"
class
=
"
findbar
-
textbox
findbar
-
find
-
fast
"
/
>
<
toolbarbutton
anonid
=
"
find
-
previous
"
class
=
"
findbar
-
find
-
previous
tabbable
"
data
-
l10n
-
attrs
=
"
tooltiptext
"
data
-
l10n
-
id
=
"
findbar
-
previous
"
oncommand
=
"
onFindAgainCommand
(
true
)
;
"
disabled
=
"
true
"
/
>
<
toolbarbutton
anonid
=
"
find
-
next
"
class
=
"
findbar
-
find
-
next
tabbable
"
data
-
l10n
-
id
=
"
findbar
-
next
"
oncommand
=
"
onFindAgainCommand
(
false
)
;
"
disabled
=
"
true
"
/
>
<
/
hbox
>
<
toolbarbutton
anonid
=
"
highlight
"
class
=
"
findbar
-
highlight
findbar
-
button
tabbable
"
data
-
l10n
-
id
=
"
findbar
-
highlight
-
all2
"
oncommand
=
"
toggleHighlight
(
this
.
checked
)
;
"
type
=
"
checkbox
"
/
>
<
toolbarbutton
anonid
=
"
find
-
case
-
sensitive
"
class
=
"
findbar
-
case
-
sensitive
findbar
-
button
tabbable
"
data
-
l10n
-
id
=
"
findbar
-
case
-
sensitive
"
oncommand
=
"
_setCaseSensitivity
(
this
.
checked
?
1
:
0
)
;
"
type
=
"
checkbox
"
/
>
<
toolbarbutton
anonid
=
"
find
-
entire
-
word
"
class
=
"
findbar
-
entire
-
word
findbar
-
button
tabbable
"
data
-
l10n
-
id
=
"
findbar
-
entire
-
word
"
oncommand
=
"
toggleEntireWord
(
this
.
checked
)
;
"
type
=
"
checkbox
"
/
>
<
label
anonid
=
"
match
-
case
-
status
"
class
=
"
findbar
-
find
-
fast
"
/
>
<
label
anonid
=
"
entire
-
word
-
status
"
class
=
"
findbar
-
find
-
fast
"
/
>
<
label
anonid
=
"
found
-
matches
"
class
=
"
findbar
-
find
-
fast
found
-
matches
"
hidden
=
"
true
"
/
>
<
image
anonid
=
"
find
-
status
-
icon
"
class
=
"
findbar
-
find
-
fast
find
-
status
-
icon
"
/
>
<
description
anonid
=
"
find
-
status
"
control
=
"
findbar
-
textbox
"
class
=
"
findbar
-
find
-
fast
findbar
-
find
-
status
"
/
>
<
/
hbox
>
<
toolbarbutton
anonid
=
"
find
-
closebutton
"
class
=
"
findbar
-
closebutton
close
-
icon
"
data
-
l10n
-
id
=
"
findbar
-
find
-
button
-
close
"
oncommand
=
"
close
(
)
;
"
/
>
)
;
}
connectedCallback
(
)
{
this
.
setAttribute
(
"
noanim
"
"
true
"
)
;
this
.
hidden
=
true
;
this
.
appendChild
(
document
.
importNode
(
this
.
content
true
)
)
;
this
.
FIND_NORMAL
=
0
;
this
.
FIND_TYPEAHEAD
=
1
;
this
.
FIND_LINKS
=
2
;
this
.
__findMode
=
0
;
this
.
_flashFindBar
=
0
;
this
.
_initialFlashFindBarCount
=
6
;
this
.
_startFindDeferred
=
null
;
this
.
_browser
=
null
;
this
.
__prefsvc
=
null
;
this
.
_observer
=
{
_self
:
this
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
"
nsISupportsWeakReference
"
]
)
observe
(
aSubject
aTopic
aPrefName
)
{
if
(
aTopic
!
=
"
nsPref
:
changed
"
)
{
return
;
}
let
prefsvc
=
this
.
_self
.
_prefsvc
;
switch
(
aPrefName
)
{
case
"
accessibility
.
typeaheadfind
"
:
this
.
_self
.
_findAsYouType
=
prefsvc
.
getBoolPref
(
aPrefName
)
;
break
;
case
"
accessibility
.
typeaheadfind
.
manual
"
:
this
.
_self
.
_manualFAYT
=
prefsvc
.
getBoolPref
(
aPrefName
)
;
break
;
case
"
accessibility
.
typeaheadfind
.
timeout
"
:
this
.
_self
.
quickFindTimeoutLength
=
prefsvc
.
getIntPref
(
aPrefName
)
;
break
;
case
"
accessibility
.
typeaheadfind
.
linksonly
"
:
this
.
_self
.
_typeAheadLinksOnly
=
prefsvc
.
getBoolPref
(
aPrefName
)
;
break
;
case
"
accessibility
.
typeaheadfind
.
casesensitive
"
:
this
.
_self
.
_setCaseSensitivity
(
prefsvc
.
getIntPref
(
aPrefName
)
)
;
break
;
case
"
findbar
.
entireword
"
:
this
.
_self
.
_entireWord
=
prefsvc
.
getBoolPref
(
aPrefName
)
;
this
.
_self
.
toggleEntireWord
(
this
.
_self
.
_entireWord
true
)
;
break
;
case
"
findbar
.
highlightAll
"
:
this
.
_self
.
toggleHighlight
(
prefsvc
.
getBoolPref
(
aPrefName
)
true
)
;
break
;
case
"
findbar
.
modalHighlight
"
:
this
.
_self
.
_useModalHighlight
=
prefsvc
.
getBoolPref
(
aPrefName
)
;
if
(
this
.
_self
.
browser
.
finder
)
{
this
.
_self
.
browser
.
finder
.
onModalHighlightChange
(
this
.
_self
.
_useModalHighlight
)
;
}
break
;
}
}
}
;
this
.
_destroyed
=
false
;
this
.
_pluralForm
=
null
;
this
.
_strBundle
=
null
;
this
.
_xulBrowserWindow
=
null
;
this
.
_findField
=
this
.
getElement
(
"
findbar
-
textbox
"
)
;
this
.
_foundMatches
=
this
.
getElement
(
"
found
-
matches
"
)
;
this
.
_findStatusIcon
=
this
.
getElement
(
"
find
-
status
-
icon
"
)
;
this
.
_findStatusDesc
=
this
.
getElement
(
"
find
-
status
"
)
;
this
.
_foundURL
=
null
;
let
prefsvc
=
this
.
_prefsvc
;
this
.
quickFindTimeoutLength
=
prefsvc
.
getIntPref
(
"
accessibility
.
typeaheadfind
.
timeout
"
)
;
this
.
_flashFindBar
=
prefsvc
.
getIntPref
(
"
accessibility
.
typeaheadfind
.
flashBar
"
)
;
this
.
_useModalHighlight
=
prefsvc
.
getBoolPref
(
"
findbar
.
modalHighlight
"
)
;
prefsvc
.
addObserver
(
"
accessibility
.
typeaheadfind
"
this
.
_observer
)
;
prefsvc
.
addObserver
(
"
accessibility
.
typeaheadfind
.
manual
"
this
.
_observer
)
;
prefsvc
.
addObserver
(
"
accessibility
.
typeaheadfind
.
linksonly
"
this
.
_observer
)
;
prefsvc
.
addObserver
(
"
accessibility
.
typeaheadfind
.
casesensitive
"
this
.
_observer
)
;
prefsvc
.
addObserver
(
"
findbar
.
entireword
"
this
.
_observer
)
;
prefsvc
.
addObserver
(
"
findbar
.
highlightAll
"
this
.
_observer
)
;
prefsvc
.
addObserver
(
"
findbar
.
modalHighlight
"
this
.
_observer
)
;
this
.
_findAsYouType
=
prefsvc
.
getBoolPref
(
"
accessibility
.
typeaheadfind
"
)
;
this
.
_manualFAYT
=
prefsvc
.
getBoolPref
(
"
accessibility
.
typeaheadfind
.
manual
"
)
;
this
.
_typeAheadLinksOnly
=
prefsvc
.
getBoolPref
(
"
accessibility
.
typeaheadfind
.
linksonly
"
)
;
this
.
_typeAheadCaseSensitive
=
prefsvc
.
getIntPref
(
"
accessibility
.
typeaheadfind
.
casesensitive
"
)
;
this
.
_entireWord
=
prefsvc
.
getBoolPref
(
"
findbar
.
entireword
"
)
;
this
.
_highlightAll
=
prefsvc
.
getBoolPref
(
"
findbar
.
highlightAll
"
)
;
this
.
nsITypeAheadFind
=
Ci
.
nsITypeAheadFind
;
this
.
nsISelectionController
=
Ci
.
nsISelectionController
;
this
.
_findSelection
=
this
.
nsISelectionController
.
SELECTION_FIND
;
this
.
_findResetTimeout
=
-
1
;
if
(
this
.
getAttribute
(
"
browserid
"
)
)
{
setTimeout
(
function
(
aSelf
)
{
aSelf
.
browser
=
aSelf
.
browser
;
}
0
this
)
;
}
window
.
addEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
_findField
.
addEventListener
(
"
input
"
event
=
>
{
if
(
this
.
_isIMEComposing
)
{
return
;
}
const
value
=
this
.
_findField
.
value
;
if
(
this
.
_hadValue
&
&
!
value
)
{
this
.
_willfullyDeleted
=
true
;
this
.
_hadValue
=
false
;
}
else
if
(
value
.
trim
(
)
)
{
this
.
_hadValue
=
true
;
this
.
_willfullyDeleted
=
false
;
}
this
.
_find
(
value
)
;
}
)
;
this
.
_findField
.
addEventListener
(
"
keypress
"
event
=
>
{
switch
(
event
.
keyCode
)
{
case
KeyEvent
.
DOM_VK_RETURN
:
if
(
this
.
_findMode
=
=
this
.
FIND_NORMAL
)
{
let
findString
=
this
.
_findField
;
if
(
!
findString
.
value
)
{
return
;
}
if
(
event
.
getModifierState
(
"
Accel
"
)
)
{
this
.
getElement
(
"
highlight
"
)
.
click
(
)
;
return
;
}
this
.
onFindAgainCommand
(
event
.
shiftKey
)
;
}
else
{
this
.
_finishFAYT
(
event
)
;
}
break
;
case
KeyEvent
.
DOM_VK_TAB
:
let
shouldHandle
=
!
event
.
altKey
&
&
!
event
.
ctrlKey
&
&
!
event
.
metaKey
;
if
(
shouldHandle
&
&
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
{
this
.
_finishFAYT
(
event
)
;
}
break
;
case
KeyEvent
.
DOM_VK_PAGE_UP
:
case
KeyEvent
.
DOM_VK_PAGE_DOWN
:
if
(
!
event
.
altKey
&
&
!
event
.
ctrlKey
&
&
!
event
.
metaKey
&
&
!
event
.
shiftKey
)
{
this
.
browser
.
finder
.
keyPress
(
event
)
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyEvent
.
DOM_VK_UP
:
case
KeyEvent
.
DOM_VK_DOWN
:
this
.
browser
.
finder
.
keyPress
(
event
)
;
event
.
preventDefault
(
)
;
break
;
}
}
)
;
this
.
_findField
.
addEventListener
(
"
blur
"
event
=
>
{
this
.
browser
.
finder
.
enableSelection
(
)
;
}
)
;
this
.
_findField
.
addEventListener
(
"
focus
"
event
=
>
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
_onFindFieldFocus
(
)
;
}
this
.
_updateBrowserWithState
(
)
;
}
)
;
this
.
_findField
.
addEventListener
(
"
compositionstart
"
event
=
>
{
let
findbar
=
this
;
findbar
.
_isIMEComposing
=
true
;
if
(
findbar
.
_quickFindTimeout
)
{
clearTimeout
(
findbar
.
_quickFindTimeout
)
;
findbar
.
_quickFindTimeout
=
null
;
findbar
.
_updateBrowserWithState
(
)
;
}
}
)
;
this
.
_findField
.
addEventListener
(
"
compositionend
"
event
=
>
{
this
.
_isIMEComposing
=
false
;
if
(
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
{
this
.
_setFindCloseTimeout
(
)
;
}
}
)
;
this
.
_findField
.
addEventListener
(
"
dragover
"
event
=
>
{
if
(
event
.
dataTransfer
.
types
.
includes
(
"
text
/
plain
"
)
)
{
event
.
preventDefault
(
)
;
}
}
)
;
this
.
_findField
.
addEventListener
(
"
drop
"
event
=
>
{
let
value
=
event
.
dataTransfer
.
getData
(
"
text
/
plain
"
)
;
this
.
_findField
.
value
=
value
;
this
.
_find
(
value
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
)
;
}
set
_findMode
(
val
)
{
this
.
__findMode
=
val
;
this
.
_updateBrowserWithState
(
)
;
return
val
;
}
get
_findMode
(
)
{
return
this
.
__findMode
;
}
set
prefillWithSelection
(
val
)
{
this
.
setAttribute
(
"
prefillwithselection
"
val
)
;
return
val
;
}
get
prefillWithSelection
(
)
{
return
this
.
getAttribute
(
"
prefillwithselection
"
)
!
=
"
false
"
;
}
get
findMode
(
)
{
return
this
.
_findMode
;
}
get
hasTransactions
(
)
{
if
(
this
.
_findField
.
value
)
{
return
true
;
}
if
(
this
.
_findField
.
editor
)
{
let
tm
=
this
.
_findField
.
editor
.
transactionManager
;
return
!
!
(
tm
.
numberOfUndoItems
|
|
tm
.
numberOfRedoItems
)
;
}
return
false
;
}
set
browser
(
val
)
{
function
setFindbarInActor
(
browser
findbar
)
{
if
(
!
browser
.
frameLoader
)
{
return
;
}
let
windowGlobal
=
browser
.
browsingContext
.
currentWindowGlobal
;
if
(
windowGlobal
)
{
let
findbarParent
=
windowGlobal
.
getActor
(
"
FindBar
"
)
;
if
(
findbarParent
)
{
findbarParent
.
setFindbar
(
browser
findbar
)
;
}
}
}
if
(
this
.
_browser
)
{
setFindbarInActor
(
this
.
_browser
null
)
;
let
finder
=
this
.
_browser
.
finder
;
if
(
finder
)
{
finder
.
removeResultListener
(
this
)
;
}
}
this
.
_browser
=
val
;
if
(
this
.
_browser
)
{
this
.
_updateBrowserWithState
(
)
;
setFindbarInActor
(
this
.
_browser
this
)
;
this
.
_browser
.
finder
.
addResultListener
(
this
)
;
this
.
_findField
.
value
=
this
.
_browser
.
_lastSearchString
;
}
return
val
;
}
get
browser
(
)
{
if
(
!
this
.
_browser
)
{
this
.
_browser
=
document
.
getElementById
(
this
.
getAttribute
(
"
browserid
"
)
)
;
}
return
this
.
_browser
;
}
get
_prefsvc
(
)
{
return
Services
.
prefs
;
}
get
pluralForm
(
)
{
if
(
!
this
.
_pluralForm
)
{
this
.
_pluralForm
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
{
}
)
.
PluralForm
;
}
return
this
.
_pluralForm
;
}
get
strBundle
(
)
{
if
(
!
this
.
_strBundle
)
{
this
.
_strBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
findbar
.
properties
"
)
;
}
return
this
.
_strBundle
;
}
getElement
(
aAnonymousID
)
{
return
this
.
querySelector
(
[
anonid
=
{
aAnonymousID
}
]
)
;
}
destroy
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
window
.
removeEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
_destroyed
=
true
;
if
(
this
.
browser
&
&
this
.
browser
.
finder
)
{
this
.
browser
.
finder
.
destroy
(
)
;
}
this
.
browser
=
null
;
let
prefsvc
=
this
.
_prefsvc
;
prefsvc
.
removeObserver
(
"
accessibility
.
typeaheadfind
"
this
.
_observer
)
;
prefsvc
.
removeObserver
(
"
accessibility
.
typeaheadfind
.
manual
"
this
.
_observer
)
;
prefsvc
.
removeObserver
(
"
accessibility
.
typeaheadfind
.
linksonly
"
this
.
_observer
)
;
prefsvc
.
removeObserver
(
"
accessibility
.
typeaheadfind
.
casesensitive
"
this
.
_observer
)
;
prefsvc
.
removeObserver
(
"
findbar
.
entireword
"
this
.
_observer
)
;
prefsvc
.
removeObserver
(
"
findbar
.
highlightAll
"
this
.
_observer
)
;
prefsvc
.
removeObserver
(
"
findbar
.
modalHighlight
"
this
.
_observer
)
;
this
.
_cancelTimers
(
)
;
}
_cancelTimers
(
)
{
if
(
this
.
_flashFindBarTimeout
)
{
clearInterval
(
this
.
_flashFindBarTimeout
)
;
this
.
_flashFindBarTimeout
=
null
;
}
if
(
this
.
_quickFindTimeout
)
{
clearTimeout
(
this
.
_quickFindTimeout
)
;
this
.
_quickFindTimeout
=
null
;
}
if
(
this
.
_findResetTimeout
)
{
clearTimeout
(
this
.
_findResetTimeout
)
;
this
.
_findResetTimeout
=
null
;
}
}
_setFindCloseTimeout
(
)
{
if
(
this
.
_quickFindTimeout
)
{
clearTimeout
(
this
.
_quickFindTimeout
)
;
}
if
(
this
.
_isIMEComposing
|
|
this
.
hidden
)
{
this
.
_quickFindTimeout
=
null
;
this
.
_updateBrowserWithState
(
)
;
return
;
}
if
(
this
.
quickFindTimeoutLength
<
1
)
{
this
.
_quickFindTimeout
=
null
;
}
else
{
this
.
_quickFindTimeout
=
setTimeout
(
(
)
=
>
{
if
(
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
{
this
.
close
(
)
;
}
this
.
_quickFindTimeout
=
null
;
}
this
.
quickFindTimeoutLength
)
;
}
this
.
_updateBrowserWithState
(
)
;
}
_updateMatchesCount
(
)
{
if
(
!
this
.
_dispatchFindEvent
(
"
matchescount
"
)
)
{
return
;
}
this
.
browser
.
finder
.
requestMatchesCount
(
this
.
_findField
.
value
this
.
_findMode
=
=
this
.
FIND_LINKS
)
;
}
toggleHighlight
(
aHighlight
aFromPrefObserver
)
{
if
(
aHighlight
=
=
=
this
.
_highlightAll
)
{
return
;
}
this
.
browser
.
finder
.
onHighlightAllChange
(
aHighlight
)
;
this
.
_setHighlightAll
(
aHighlight
aFromPrefObserver
)
;
if
(
!
this
.
_dispatchFindEvent
(
"
highlightallchange
"
)
)
{
return
;
}
let
word
=
this
.
_findField
.
value
;
if
(
aHighlight
&
&
!
word
)
{
return
;
}
this
.
browser
.
finder
.
highlight
(
aHighlight
word
this
.
_findMode
=
=
this
.
FIND_LINKS
)
;
this
.
_updateMatchesCount
(
this
.
nsITypeAheadFind
.
FIND_FOUND
)
;
}
_setHighlightAll
(
aHighlight
aFromPrefObserver
)
{
if
(
typeof
aHighlight
!
=
"
boolean
"
)
{
aHighlight
=
this
.
_highlightAll
;
}
if
(
aHighlight
!
=
=
this
.
_highlightAll
)
{
this
.
_highlightAll
=
aHighlight
;
if
(
!
aFromPrefObserver
)
{
this
.
_prefsvc
.
setBoolPref
(
"
findbar
.
highlightAll
"
aHighlight
)
;
}
}
let
checkbox
=
this
.
getElement
(
"
highlight
"
)
;
checkbox
.
checked
=
this
.
_highlightAll
;
}
_updateCaseSensitivity
(
aString
)
{
let
val
=
aString
|
|
this
.
_findField
.
value
;
let
caseSensitive
=
this
.
_shouldBeCaseSensitive
(
val
)
;
let
checkbox
=
this
.
getElement
(
"
find
-
case
-
sensitive
"
)
;
let
statusLabel
=
this
.
getElement
(
"
match
-
case
-
status
"
)
;
checkbox
.
checked
=
caseSensitive
;
statusLabel
.
value
=
caseSensitive
?
this
.
_caseSensitiveStr
:
"
"
;
let
hideCheckbox
=
this
.
_findMode
!
=
this
.
FIND_NORMAL
|
|
(
this
.
_typeAheadCaseSensitive
!
=
0
&
&
this
.
_typeAheadCaseSensitive
!
=
1
)
;
checkbox
.
hidden
=
hideCheckbox
;
statusLabel
.
hidden
=
!
hideCheckbox
;
this
.
browser
.
finder
.
caseSensitive
=
caseSensitive
;
}
_setCaseSensitivity
(
aCaseSensitivity
)
{
this
.
_typeAheadCaseSensitive
=
aCaseSensitivity
;
this
.
_updateCaseSensitivity
(
)
;
this
.
_findFailedString
=
null
;
this
.
_find
(
)
;
this
.
_dispatchFindEvent
(
"
casesensitivitychange
"
)
;
}
_setEntireWord
(
)
{
let
entireWord
=
this
.
_entireWord
;
let
checkbox
=
this
.
getElement
(
"
find
-
entire
-
word
"
)
;
let
statusLabel
=
this
.
getElement
(
"
entire
-
word
-
status
"
)
;
checkbox
.
checked
=
entireWord
;
statusLabel
.
value
=
entireWord
?
this
.
_entireWordStr
:
"
"
;
let
hideCheckbox
=
this
.
_findMode
!
=
this
.
FIND_NORMAL
;
checkbox
.
hidden
=
hideCheckbox
;
statusLabel
.
hidden
=
!
hideCheckbox
;
this
.
browser
.
finder
.
entireWord
=
entireWord
;
}
toggleEntireWord
(
aEntireWord
aFromPrefObserver
)
{
if
(
!
aFromPrefObserver
)
{
this
.
_prefsvc
.
setBoolPref
(
"
findbar
.
entireword
"
aEntireWord
)
;
return
;
}
this
.
_findFailedString
=
null
;
this
.
_find
(
)
;
}
open
(
aMode
)
{
if
(
aMode
!
=
undefined
)
{
this
.
_findMode
=
aMode
;
}
if
(
!
this
.
_notFoundStr
)
{
var
stringsBundle
=
this
.
strBundle
;
this
.
_notFoundStr
=
stringsBundle
.
GetStringFromName
(
"
NotFound
"
)
;
this
.
_wrappedToTopStr
=
stringsBundle
.
GetStringFromName
(
"
WrappedToTop
"
)
;
this
.
_wrappedToBottomStr
=
stringsBundle
.
GetStringFromName
(
"
WrappedToBottom
"
)
;
this
.
_normalFindStr
=
stringsBundle
.
GetStringFromName
(
"
NormalFind
"
)
;
this
.
_fastFindStr
=
stringsBundle
.
GetStringFromName
(
"
FastFind
"
)
;
this
.
_fastFindLinksStr
=
stringsBundle
.
GetStringFromName
(
"
FastFindLinks
"
)
;
this
.
_caseSensitiveStr
=
stringsBundle
.
GetStringFromName
(
"
CaseSensitive
"
)
;
this
.
_entireWordStr
=
stringsBundle
.
GetStringFromName
(
"
EntireWord
"
)
;
}
this
.
_findFailedString
=
null
;
this
.
_updateFindUI
(
)
;
if
(
this
.
hidden
)
{
this
.
removeAttribute
(
"
noanim
"
)
;
this
.
hidden
=
false
;
this
.
_updateStatusUI
(
this
.
nsITypeAheadFind
.
FIND_FOUND
)
;
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
findbaropen
"
true
false
)
;
this
.
dispatchEvent
(
event
)
;
this
.
browser
.
finder
.
onFindbarOpen
(
)
;
return
true
;
}
return
false
;
}
close
(
aNoAnim
)
{
if
(
this
.
hidden
)
{
return
;
}
if
(
aNoAnim
)
{
this
.
setAttribute
(
"
noanim
"
true
)
;
}
this
.
hidden
=
true
;
let
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
findbarclose
"
true
false
)
;
this
.
dispatchEvent
(
event
)
;
this
.
browser
.
finder
.
focusContent
(
)
;
this
.
browser
.
finder
.
onFindbarClose
(
)
;
this
.
_cancelTimers
(
)
;
this
.
_updateBrowserWithState
(
)
;
this
.
_findFailedString
=
null
;
}
clear
(
)
{
this
.
browser
.
finder
.
removeSelection
(
)
;
this
.
_findField
.
value
=
"
"
;
if
(
this
.
_findField
.
editor
)
{
this
.
_findField
.
editor
.
transactionManager
.
clear
(
)
;
}
this
.
toggleHighlight
(
false
)
;
this
.
_updateStatusUI
(
)
;
this
.
_enableFindButtons
(
false
)
;
}
_dispatchKeypressEvent
(
aTarget
fakeEvent
)
{
if
(
!
aTarget
)
{
return
;
}
let
event
=
new
aTarget
.
ownerGlobal
.
KeyboardEvent
(
fakeEvent
.
type
fakeEvent
)
;
aTarget
.
dispatchEvent
(
event
)
;
}
_updateStatusUIBar
(
aFoundURL
)
{
if
(
!
this
.
_xulBrowserWindow
)
{
try
{
this
.
_xulBrowserWindow
=
window
.
docShell
.
treeOwner
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIAppWindow
)
.
XULBrowserWindow
;
}
catch
(
ex
)
{
}
if
(
!
this
.
_xulBrowserWindow
)
{
return
false
;
}
}
this
.
_xulBrowserWindow
.
setOverLink
(
aFoundURL
|
|
"
"
null
)
;
return
true
;
}
_finishFAYT
(
aKeypressEvent
)
{
this
.
browser
.
finder
.
focusContent
(
)
;
if
(
aKeypressEvent
)
{
aKeypressEvent
.
preventDefault
(
)
;
}
this
.
browser
.
finder
.
keyPress
(
aKeypressEvent
)
;
this
.
close
(
)
;
return
true
;
}
_shouldBeCaseSensitive
(
aString
)
{
if
(
this
.
_typeAheadCaseSensitive
=
=
0
)
{
return
false
;
}
if
(
this
.
_typeAheadCaseSensitive
=
=
1
)
{
return
true
;
}
return
aString
!
=
aString
.
toLowerCase
(
)
;
}
onMouseUp
(
)
{
if
(
!
this
.
hidden
&
&
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
{
this
.
close
(
)
;
}
}
_onBrowserKeypress
(
aFakeEvent
)
{
const
FAYT_LINKS_KEY
=
"
'
"
;
const
FAYT_TEXT_KEY
=
"
/
"
;
if
(
!
this
.
hidden
&
&
this
.
_findField
=
=
document
.
activeElement
)
{
this
.
_dispatchKeypressEvent
(
this
.
_findField
aFakeEvent
)
;
return
;
}
if
(
this
.
_findMode
!
=
this
.
FIND_NORMAL
&
&
this
.
_quickFindTimeout
)
{
this
.
_findField
.
select
(
)
;
this
.
_findField
.
focus
(
)
;
this
.
_dispatchKeypressEvent
(
this
.
_findField
aFakeEvent
)
;
return
;
}
let
key
=
aFakeEvent
.
charCode
?
String
.
fromCharCode
(
aFakeEvent
.
charCode
)
:
null
;
let
manualstartFAYT
=
(
key
=
=
FAYT_LINKS_KEY
|
|
key
=
=
FAYT_TEXT_KEY
)
&
&
this
.
_manualFAYT
;
let
autostartFAYT
=
!
manualstartFAYT
&
&
this
.
_findAsYouType
&
&
key
&
&
key
!
=
"
"
;
if
(
manualstartFAYT
|
|
autostartFAYT
)
{
let
mode
=
key
=
=
FAYT_LINKS_KEY
|
|
(
autostartFAYT
&
&
this
.
_typeAheadLinksOnly
)
?
this
.
FIND_LINKS
:
this
.
FIND_TYPEAHEAD
;
this
.
_findField
.
value
=
"
"
;
this
.
open
(
mode
)
;
this
.
_setFindCloseTimeout
(
)
;
this
.
_findField
.
select
(
)
;
this
.
_findField
.
focus
(
)
;
if
(
autostartFAYT
)
{
this
.
_dispatchKeypressEvent
(
this
.
_findField
aFakeEvent
)
;
}
else
{
this
.
_updateStatusUI
(
this
.
nsITypeAheadFind
.
FIND_FOUND
)
;
}
}
}
_updateBrowserWithState
(
)
{
if
(
this
.
_browser
)
{
this
.
_browser
.
sendMessageToActor
(
"
Findbar
:
UpdateState
"
{
findMode
:
this
.
_findMode
isOpenAndFocused
:
!
this
.
hidden
&
&
document
.
activeElement
=
=
this
.
_findField
hasQuickFindTimeout
:
!
!
this
.
_quickFindTimeout
}
"
FindBar
"
)
;
}
}
_enableFindButtons
(
aEnable
)
{
this
.
getElement
(
"
find
-
next
"
)
.
disabled
=
this
.
getElement
(
"
find
-
previous
"
)
.
disabled
=
!
aEnable
;
}
_updateFindUI
(
)
{
let
showMinimalUI
=
this
.
_findMode
!
=
this
.
FIND_NORMAL
;
let
nodes
=
this
.
getElement
(
"
findbar
-
container
"
)
.
children
;
let
wrapper
=
this
.
getElement
(
"
findbar
-
textbox
-
wrapper
"
)
;
let
foundMatches
=
this
.
_foundMatches
;
for
(
let
node
of
nodes
)
{
if
(
node
=
=
wrapper
|
|
node
=
=
foundMatches
)
{
continue
;
}
node
.
hidden
=
showMinimalUI
;
}
this
.
getElement
(
"
find
-
next
"
)
.
hidden
=
this
.
getElement
(
"
find
-
previous
"
)
.
hidden
=
showMinimalUI
;
foundMatches
.
hidden
=
showMinimalUI
|
|
!
foundMatches
.
value
;
this
.
_updateCaseSensitivity
(
)
;
this
.
_setEntireWord
(
)
;
this
.
_setHighlightAll
(
)
;
if
(
showMinimalUI
)
{
this
.
_findField
.
classList
.
add
(
"
minimal
"
)
;
}
else
{
this
.
_findField
.
classList
.
remove
(
"
minimal
"
)
;
}
if
(
this
.
_findMode
=
=
this
.
FIND_TYPEAHEAD
)
{
this
.
_findField
.
placeholder
=
this
.
_fastFindStr
;
}
else
if
(
this
.
_findMode
=
=
this
.
FIND_LINKS
)
{
this
.
_findField
.
placeholder
=
this
.
_fastFindLinksStr
;
}
else
{
this
.
_findField
.
placeholder
=
this
.
_normalFindStr
;
}
}
_find
(
aValue
)
{
if
(
!
this
.
_dispatchFindEvent
(
"
"
)
)
{
return
;
}
let
val
=
aValue
|
|
this
.
_findField
.
value
;
this
.
browser
.
_lastSearchString
=
val
;
if
(
!
this
.
_findFailedString
|
|
!
val
.
startsWith
(
this
.
_findFailedString
)
|
|
this
.
_entireWord
)
{
if
(
this
.
_startFindDeferred
)
{
this
.
_startFindDeferred
.
resolve
(
)
;
this
.
_startFindDeferred
=
null
;
}
this
.
_enableFindButtons
(
val
)
;
this
.
_updateCaseSensitivity
(
val
)
;
this
.
_setEntireWord
(
)
;
this
.
browser
.
finder
.
fastFind
(
val
this
.
_findMode
=
=
this
.
FIND_LINKS
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
;
}
if
(
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
{
this
.
_setFindCloseTimeout
(
)
;
}
if
(
this
.
_findResetTimeout
!
=
-
1
)
{
clearTimeout
(
this
.
_findResetTimeout
)
;
}
this
.
_findResetTimeout
=
setTimeout
(
(
)
=
>
{
this
.
_findFailedString
=
null
;
this
.
_findResetTimeout
=
-
1
;
}
1000
)
;
}
_flash
(
)
{
if
(
this
.
_flashFindBarCount
=
=
=
undefined
)
{
this
.
_flashFindBarCount
=
this
.
_initialFlashFindBarCount
;
}
if
(
this
.
_flashFindBarCount
-
-
=
=
0
)
{
clearInterval
(
this
.
_flashFindBarTimeout
)
;
this
.
_findField
.
removeAttribute
(
"
flash
"
)
;
this
.
_flashFindBarCount
=
6
;
return
;
}
this
.
_findField
.
setAttribute
(
"
flash
"
this
.
_flashFindBarCount
%
2
=
=
0
?
"
false
"
:
"
true
"
)
;
}
_findAgain
(
aFindPrevious
)
{
this
.
browser
.
finder
.
findAgain
(
this
.
_findField
.
value
aFindPrevious
this
.
_findMode
=
=
this
.
FIND_LINKS
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
;
}
_updateStatusUI
(
res
aFindPrevious
)
{
switch
(
res
)
{
case
this
.
nsITypeAheadFind
.
FIND_WRAPPED
:
this
.
_findStatusIcon
.
setAttribute
(
"
status
"
"
wrapped
"
)
;
this
.
_findStatusDesc
.
textContent
=
aFindPrevious
?
this
.
_wrappedToBottomStr
:
this
.
_wrappedToTopStr
;
this
.
_findField
.
removeAttribute
(
"
status
"
)
;
break
;
case
this
.
nsITypeAheadFind
.
FIND_NOTFOUND
:
this
.
_findStatusIcon
.
setAttribute
(
"
status
"
"
notfound
"
)
;
this
.
_findStatusDesc
.
textContent
=
this
.
_notFoundStr
;
this
.
_findField
.
setAttribute
(
"
status
"
"
notfound
"
)
;
break
;
case
this
.
nsITypeAheadFind
.
FIND_PENDING
:
this
.
_findStatusIcon
.
setAttribute
(
"
status
"
"
pending
"
)
;
this
.
_findStatusDesc
.
textContent
=
"
"
;
this
.
_findField
.
removeAttribute
(
"
status
"
)
;
break
;
case
this
.
nsITypeAheadFind
.
FIND_FOUND
:
default
:
this
.
_findStatusIcon
.
removeAttribute
(
"
status
"
)
;
this
.
_findStatusDesc
.
textContent
=
"
"
;
this
.
_findField
.
removeAttribute
(
"
status
"
)
;
break
;
}
}
updateControlState
(
aResult
aFindPrevious
)
{
this
.
_updateStatusUI
(
aResult
aFindPrevious
)
;
this
.
_enableFindButtons
(
aResult
!
=
=
this
.
nsITypeAheadFind
.
FIND_NOTFOUND
&
&
!
!
this
.
_findField
.
value
)
;
}
_dispatchFindEvent
(
aType
aFindPrevious
)
{
let
event
=
document
.
createEvent
(
"
CustomEvent
"
)
;
event
.
initCustomEvent
(
"
find
"
+
aType
true
true
{
query
:
this
.
_findField
.
value
caseSensitive
:
!
!
this
.
_typeAheadCaseSensitive
entireWord
:
this
.
_entireWord
highlightAll
:
this
.
_highlightAll
findPrevious
:
aFindPrevious
}
)
;
return
this
.
dispatchEvent
(
event
)
;
}
startFind
(
aMode
)
{
let
prefsvc
=
this
.
_prefsvc
;
let
userWantsPrefill
=
true
;
this
.
open
(
aMode
)
;
if
(
this
.
_flashFindBar
)
{
this
.
_flashFindBarTimeout
=
setInterval
(
(
)
=
>
this
.
_flash
(
)
500
)
;
prefsvc
.
setIntPref
(
"
accessibility
.
typeaheadfind
.
flashBar
"
-
-
this
.
_flashFindBar
)
;
}
let
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
this
.
_startFindDeferred
=
PromiseUtils
.
defer
(
)
;
let
startFindPromise
=
this
.
_startFindDeferred
.
promise
;
if
(
this
.
prefillWithSelection
)
{
userWantsPrefill
=
prefsvc
.
getBoolPref
(
"
accessibility
.
typeaheadfind
.
prefillwithselection
"
)
;
}
if
(
this
.
prefillWithSelection
&
&
userWantsPrefill
)
{
this
.
_findField
.
focus
(
)
;
this
.
_findField
.
select
(
)
;
this
.
browser
.
finder
.
getInitialSelection
(
)
;
return
startFindPromise
;
}
this
.
onCurrentSelection
(
"
"
true
)
;
return
startFindPromise
;
}
onFindCommand
(
)
{
return
this
.
startFind
(
this
.
FIND_NORMAL
)
;
}
onFindAgainCommand
(
aFindPrevious
)
{
let
findString
=
this
.
_browser
.
finder
.
searchString
|
|
this
.
_findField
.
value
;
if
(
!
findString
)
{
return
this
.
startFind
(
)
;
}
if
(
!
this
.
_dispatchFindEvent
(
"
again
"
aFindPrevious
)
)
{
return
undefined
;
}
this
.
_findFailedString
=
null
;
if
(
this
.
_findField
.
value
!
=
this
.
_browser
.
finder
.
searchString
)
{
this
.
_find
(
this
.
_findField
.
value
)
;
}
else
{
this
.
_findAgain
(
aFindPrevious
)
;
if
(
this
.
_useModalHighlight
)
{
this
.
open
(
)
;
this
.
_findField
.
focus
(
)
;
}
}
return
undefined
;
}
onFindSelectionCommand
(
)
{
this
.
browser
.
finder
.
setSearchStringToSelection
(
)
.
then
(
searchInfo
=
>
{
if
(
searchInfo
.
selectedText
)
{
this
.
_findField
.
value
=
searchInfo
.
selectedText
;
}
}
)
;
}
_onFindFieldFocus
(
)
{
let
prefsvc
=
this
.
_prefsvc
;
const
kPref
=
"
accessibility
.
typeaheadfind
.
prefillwithselection
"
;
if
(
this
.
prefillWithSelection
&
&
prefsvc
.
getBoolPref
(
kPref
)
)
{
return
;
}
let
clipboardSearchString
=
this
.
_browser
.
finder
.
clipboardSearchString
;
if
(
clipboardSearchString
&
&
this
.
_findField
.
value
!
=
clipboardSearchString
&
&
!
this
.
_findField
.
_willfullyDeleted
)
{
this
.
_findField
.
value
=
clipboardSearchString
;
this
.
_findField
.
_hadValue
=
true
;
this
.
_updateStatusUI
(
)
;
}
}
onFindResult
(
aData
)
{
if
(
aData
.
result
=
=
this
.
nsITypeAheadFind
.
FIND_NOTFOUND
)
{
if
(
aData
.
storeResult
&
&
this
.
open
(
)
)
{
this
.
_findField
.
select
(
)
;
this
.
_findField
.
focus
(
)
;
}
this
.
_findFailedString
=
aData
.
searchString
;
}
else
{
this
.
_findFailedString
=
null
;
}
this
.
_updateStatusUI
(
aData
.
result
aData
.
findBackwards
)
;
this
.
_updateStatusUIBar
(
aData
.
linkURL
)
;
if
(
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
{
this
.
_setFindCloseTimeout
(
)
;
}
}
onMatchesCountResult
(
aResult
)
{
if
(
aResult
.
total
!
=
=
0
)
{
if
(
aResult
.
total
=
=
-
1
)
{
this
.
_foundMatches
.
value
=
this
.
pluralForm
.
get
(
aResult
.
limit
this
.
strBundle
.
GetStringFromName
(
"
FoundMatchesCountLimit
"
)
)
.
replace
(
"
#
1
"
aResult
.
limit
)
;
}
else
{
this
.
_foundMatches
.
value
=
this
.
pluralForm
.
get
(
aResult
.
total
this
.
strBundle
.
GetStringFromName
(
"
FoundMatches
"
)
)
.
replace
(
"
#
1
"
aResult
.
current
)
.
replace
(
"
#
2
"
aResult
.
total
)
;
}
this
.
_foundMatches
.
hidden
=
false
;
}
else
{
this
.
_foundMatches
.
hidden
=
true
;
this
.
_foundMatches
.
value
=
"
"
;
}
}
onHighlightFinished
(
result
)
{
}
onCurrentSelection
(
aSelectionString
aIsInitialSelection
)
{
if
(
aIsInitialSelection
&
&
!
this
.
_startFindDeferred
)
{
return
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
aIsInitialSelection
&
&
!
aSelectionString
)
{
let
clipboardSearchString
=
this
.
browser
.
finder
.
clipboardSearchString
;
if
(
clipboardSearchString
)
{
aSelectionString
=
clipboardSearchString
;
}
}
if
(
aSelectionString
)
{
this
.
_findField
.
value
=
aSelectionString
;
}
if
(
aIsInitialSelection
)
{
this
.
_enableFindButtons
(
!
!
this
.
_findField
.
value
)
;
this
.
_findField
.
select
(
)
;
this
.
_findField
.
focus
(
)
;
this
.
_startFindDeferred
.
resolve
(
)
;
this
.
_startFindDeferred
=
null
;
}
}
shouldFocusContent
(
)
{
const
fm
=
Services
.
focus
;
if
(
fm
.
focusedWindow
!
=
window
)
{
return
false
;
}
let
focusedElement
=
fm
.
focusedElement
;
if
(
!
focusedElement
)
{
return
false
;
}
let
focusedParent
=
focusedElement
.
closest
(
"
findbar
"
)
;
if
(
focusedParent
!
=
this
&
&
focusedParent
!
=
this
.
_findField
)
{
return
false
;
}
return
true
;
}
disconnectedCallback
(
)
{
while
(
this
.
lastChild
)
{
this
.
removeChild
(
this
.
lastChild
)
;
}
this
.
destroy
(
)
;
}
}
customElements
.
define
(
"
findbar
"
MozFindbar
)
;
}
