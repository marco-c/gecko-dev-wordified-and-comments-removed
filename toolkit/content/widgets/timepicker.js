"
use
strict
"
;
function
TimePicker
(
context
)
{
this
.
context
=
context
;
this
.
_attachEventListeners
(
)
;
}
{
const
DAY_PERIOD_IN_HOURS
=
12
DAY_IN_MS
=
86400000
;
TimePicker
.
prototype
=
{
init
(
props
)
{
if
(
props
.
type
=
=
"
date
"
)
{
return
;
}
if
(
props
.
type
=
=
"
datetime
-
local
"
)
{
const
timepicker
=
this
.
context
;
const
datetimepicker
=
timepicker
.
parentNode
;
const
datepicker
=
datetimepicker
.
children
.
namedItem
(
"
date
-
picker
"
)
;
timepicker
.
setAttribute
(
"
role
"
"
group
"
)
;
timepicker
.
removeAttribute
(
"
aria
-
modal
"
)
;
datepicker
.
setAttribute
(
"
role
"
"
group
"
)
;
datepicker
.
removeAttribute
(
"
aria
-
modal
"
)
;
datetimepicker
.
setAttribute
(
"
role
"
"
dialog
"
)
;
datetimepicker
.
setAttribute
(
"
aria
-
modal
"
"
true
"
)
;
datetimepicker
.
setAttribute
(
"
data
-
l10n
-
id
"
"
datetime
-
picker
-
label
"
)
;
}
this
.
context
.
hidden
=
false
;
this
.
props
=
props
|
|
{
}
;
this
.
_setDefaultState
(
)
;
this
.
_createComponents
(
)
;
this
.
_setComponentStates
(
)
;
window
.
PICKER_READY
=
true
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
PickerReady
"
)
)
;
if
(
props
.
type
=
=
"
time
"
)
{
this
.
components
.
hour
.
elements
.
spinner
.
focus
(
)
;
}
}
_setDefaultState
(
)
{
const
{
hour
minute
min
max
step
format
}
=
this
.
props
;
const
now
=
new
Date
(
)
;
let
timerHour
=
hour
=
=
undefined
?
now
.
getHours
(
)
:
hour
;
let
timerMinute
=
minute
=
=
undefined
?
now
.
getMinutes
(
)
:
minute
;
let
timeKeeper
=
new
TimeKeeper
(
{
min
:
new
Date
(
Number
.
isNaN
(
min
)
?
0
:
min
)
max
:
new
Date
(
Number
.
isNaN
(
max
)
?
DAY_IN_MS
-
1
:
max
)
step
format
:
format
|
|
"
12
"
}
)
;
timeKeeper
.
setState
(
{
hour
:
timerHour
minute
:
timerMinute
}
)
;
this
.
state
=
{
timeKeeper
}
;
}
_createComponents
(
)
{
const
{
locale
format
}
=
this
.
props
;
const
{
timeKeeper
}
=
this
.
state
;
const
wrapSetValueFn
=
setTimeFunction
=
>
{
return
value
=
>
{
setTimeFunction
(
value
)
;
this
.
_setComponentStates
(
)
;
this
.
_dispatchState
(
)
;
}
;
}
;
const
numberFormat
=
new
Intl
.
NumberFormat
(
locale
)
.
format
;
this
.
components
=
{
hour
:
new
Spinner
(
{
setValue
:
wrapSetValueFn
(
value
=
>
{
timeKeeper
.
setHour
(
value
)
;
this
.
state
.
isHourSet
=
true
;
}
)
getDisplayString
:
hour
=
>
{
if
(
format
=
=
"
24
"
)
{
return
numberFormat
(
hour
)
;
}
const
hourIn12
=
hour
%
DAY_PERIOD_IN_HOURS
;
return
hourIn12
=
=
0
?
numberFormat
(
12
)
:
numberFormat
(
hourIn12
)
;
}
}
this
.
context
)
minute
:
new
Spinner
(
{
setValue
:
wrapSetValueFn
(
value
=
>
{
timeKeeper
.
setMinute
(
value
)
;
this
.
state
.
isMinuteSet
=
true
;
}
)
getDisplayString
:
minute
=
>
numberFormat
(
minute
)
}
this
.
context
)
}
;
this
.
_insertLayoutElement
(
{
tag
:
"
div
"
textContent
:
"
:
"
className
:
"
colon
"
insertBefore
:
this
.
components
.
minute
.
elements
.
container
}
)
;
if
(
format
=
=
"
12
"
)
{
this
.
components
.
dayPeriod
=
new
Spinner
(
{
setValue
:
wrapSetValueFn
(
value
=
>
{
timeKeeper
.
setDayPeriod
(
value
)
;
this
.
state
.
isDayPeriodSet
=
true
;
}
)
getDisplayString
:
dayPeriod
=
>
(
dayPeriod
=
=
0
?
"
AM
"
:
"
PM
"
)
hideButtons
:
true
}
this
.
context
)
;
this
.
_insertLayoutElement
(
{
tag
:
"
div
"
className
:
"
spacer
"
insertBefore
:
this
.
components
.
dayPeriod
.
elements
.
container
}
)
;
}
this
.
_updateButtonIds
(
)
;
}
_insertLayoutElement
(
{
tag
insertBefore
className
textContent
}
)
{
let
el
=
document
.
createElement
(
tag
)
;
el
.
textContent
=
textContent
;
el
.
className
=
className
;
this
.
context
.
insertBefore
(
el
insertBefore
)
;
}
_setComponentStates
(
)
{
const
{
timeKeeper
isHourSet
isMinuteSet
isDayPeriodSet
}
=
this
.
state
;
const
isInvalid
=
timeKeeper
.
state
.
isInvalid
;
const
setToMinValue
=
!
isHourSet
&
&
!
isMinuteSet
&
&
!
isDayPeriodSet
&
&
isInvalid
;
this
.
components
.
hour
.
setState
(
{
value
:
setToMinValue
?
timeKeeper
.
ranges
.
hours
[
0
]
.
value
:
timeKeeper
.
hour
items
:
timeKeeper
.
ranges
.
hours
isInfiniteScroll
:
true
isValueSet
:
isHourSet
isInvalid
}
)
;
this
.
components
.
minute
.
setState
(
{
value
:
setToMinValue
?
timeKeeper
.
ranges
.
minutes
[
0
]
.
value
:
timeKeeper
.
minute
items
:
timeKeeper
.
ranges
.
minutes
isInfiniteScroll
:
true
isValueSet
:
isMinuteSet
isInvalid
}
)
;
if
(
this
.
props
.
format
=
=
"
12
"
)
{
this
.
components
.
dayPeriod
.
setState
(
{
value
:
setToMinValue
?
timeKeeper
.
ranges
.
dayPeriod
[
0
]
.
value
:
timeKeeper
.
dayPeriod
items
:
timeKeeper
.
ranges
.
dayPeriod
isInfiniteScroll
:
false
isValueSet
:
isDayPeriodSet
isInvalid
}
)
;
}
}
_dispatchState
(
)
{
const
{
hour
minute
}
=
this
.
state
.
timeKeeper
;
const
{
isHourSet
isMinuteSet
isDayPeriodSet
}
=
this
.
state
;
window
.
postMessage
(
{
name
:
"
PickerPopupChanged
"
detail
:
{
hour
minute
isHourSet
isMinuteSet
isDayPeriodSet
}
}
"
*
"
)
;
}
_closePopup
(
)
{
window
.
postMessage
(
{
name
:
"
ClosePopup
"
}
"
*
"
)
;
}
_attachEventListeners
(
)
{
window
.
addEventListener
(
"
message
"
this
)
;
document
.
addEventListener
(
"
mousedown
"
this
)
;
document
.
addEventListener
(
"
keydown
"
this
)
;
}
focusNextSpinner
(
isReverse
)
{
let
focusedSpinner
=
document
.
activeElement
;
let
spinners
=
focusedSpinner
.
parentNode
.
parentNode
.
querySelectorAll
(
"
.
spinner
"
)
;
spinners
=
[
.
.
.
spinners
]
;
let
next
=
isReverse
?
spinners
[
spinners
.
indexOf
(
focusedSpinner
)
-
1
]
:
spinners
[
spinners
.
indexOf
(
focusedSpinner
)
+
1
]
;
next
?
.
focus
(
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
message
"
:
{
this
.
handleMessage
(
event
)
;
break
;
}
case
"
mousedown
"
:
{
event
.
preventDefault
(
)
;
event
.
target
.
setPointerCapture
(
event
.
pointerId
)
;
break
;
}
case
"
keydown
"
:
{
if
(
this
.
context
.
parentNode
.
id
=
=
"
datetime
-
picker
"
&
&
!
event
.
target
.
closest
(
"
#
time
-
picker
"
)
)
{
break
;
}
switch
(
event
.
key
)
{
case
"
Enter
"
:
case
"
"
:
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
_dispatchState
(
)
;
this
.
_closePopup
(
)
;
break
;
}
case
"
Escape
"
:
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
_closePopup
(
)
;
break
;
}
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
{
const
isReverse
=
event
.
key
=
=
"
ArrowLeft
"
;
this
.
focusNextSpinner
(
isReverse
)
;
break
;
}
}
break
;
}
}
}
handleMessage
(
event
)
{
switch
(
event
.
data
.
name
)
{
case
"
PickerInit
"
:
{
this
.
init
(
event
.
data
.
detail
)
;
break
;
}
}
}
_updateButtonIds
(
)
{
const
buttons
=
[
[
this
.
components
.
hour
.
elements
.
prev
"
spinner
-
hour
-
previous
"
"
time
-
spinner
-
hour
-
previous
"
]
[
this
.
components
.
hour
.
elements
.
spinner
"
spinner
-
hour
"
"
time
-
spinner
-
hour
-
label
"
]
[
this
.
components
.
hour
.
elements
.
next
"
spinner
-
hour
-
next
"
"
time
-
spinner
-
hour
-
next
"
]
[
this
.
components
.
minute
.
elements
.
prev
"
spinner
-
minute
-
previous
"
"
time
-
spinner
-
minute
-
previous
"
]
[
this
.
components
.
minute
.
elements
.
spinner
"
spinner
-
minute
"
"
time
-
spinner
-
minute
-
label
"
]
[
this
.
components
.
minute
.
elements
.
next
"
spinner
-
minute
-
next
"
"
time
-
spinner
-
minute
-
next
"
]
[
this
.
components
.
dayPeriod
.
elements
.
prev
"
spinner
-
time
-
previous
"
"
time
-
spinner
-
day
-
period
-
previous
"
]
[
this
.
components
.
dayPeriod
.
elements
.
spinner
"
spinner
-
time
"
"
time
-
spinner
-
day
-
period
-
label
"
]
[
this
.
components
.
dayPeriod
.
elements
.
next
"
spinner
-
time
-
next
"
"
time
-
spinner
-
day
-
period
-
next
"
]
]
;
for
(
const
[
btn
id
l10nId
]
of
buttons
)
{
btn
.
setAttribute
(
"
id
"
id
)
;
document
.
l10n
.
setAttributes
(
btn
l10nId
)
;
}
}
}
;
}
document
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
new
TimePicker
(
document
.
getElementById
(
"
time
-
picker
"
)
)
;
}
)
;
