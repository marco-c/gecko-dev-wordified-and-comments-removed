"
use
strict
"
;
{
class
MozMenuPopup
extends
MozElements
.
MozElementMixin
(
XULPopupElement
)
{
constructor
(
)
{
super
(
)
;
this
.
AUTOSCROLL_INTERVAL
=
25
;
this
.
NOT_DRAGGING
=
0
;
this
.
DRAG_OVER_BUTTON
=
-
1
;
this
.
DRAG_OVER_POPUP
=
1
;
this
.
_draggingState
=
this
.
NOT_DRAGGING
;
this
.
_scrollTimer
=
0
;
this
.
addEventListener
(
"
popupshowing
"
event
=
>
{
if
(
event
.
target
!
=
this
)
{
return
;
}
let
array
=
[
]
;
let
width
=
0
;
for
(
let
menuitem
=
this
.
firstElementChild
;
menuitem
;
menuitem
=
menuitem
.
nextElementSibling
)
{
if
(
menuitem
.
localName
=
=
"
menuitem
"
&
&
menuitem
.
hasAttribute
(
"
acceltext
"
)
)
{
let
accel
=
menuitem
.
querySelector
(
"
.
menu
-
accel
-
container
"
)
;
if
(
accel
&
&
accel
.
boxObject
)
{
array
.
push
(
accel
)
;
if
(
accel
.
boxObject
.
width
>
width
)
{
width
=
accel
.
boxObject
.
width
;
}
}
}
}
array
.
forEach
(
accel
=
>
(
accel
.
width
=
width
)
)
;
}
)
;
}
connectedCallback
(
)
{
if
(
this
.
delayConnectedCallback
(
)
|
|
this
.
hasConnected
)
{
return
;
}
this
.
hasConnected
=
true
;
this
.
appendChild
(
MozXULElement
.
parseXULToFragment
(
<
arrowscrollbox
class
=
"
popup
-
internal
-
box
"
flex
=
"
1
"
orient
=
"
vertical
"
smoothscroll
=
"
false
"
/
>
)
)
;
this
.
scrollBox
=
this
.
querySelector
(
"
.
popup
-
internal
-
box
"
)
;
if
(
this
.
parentNode
&
&
this
.
parentNode
.
localName
=
=
"
menulist
"
)
{
this
.
_setUpMenulistPopup
(
)
;
}
}
_setUpChildElements
(
)
{
while
(
this
.
childElementCount
>
1
)
{
this
.
scrollBox
.
appendChild
(
this
.
firstElementChild
)
;
}
}
_setUpMenulistPopup
(
)
{
this
.
addEventListener
(
"
popupshown
"
(
)
=
>
{
this
.
_enableDragScrolling
(
false
)
;
}
)
;
this
.
addEventListener
(
"
popuphidden
"
(
)
=
>
{
this
.
_draggingState
=
this
.
NOT_DRAGGING
;
this
.
_clearScrollTimer
(
)
;
this
.
releaseCapture
(
)
;
}
)
;
this
.
addEventListener
(
"
mousedown
"
event
=
>
{
if
(
event
.
button
!
=
0
)
{
return
;
}
if
(
this
.
state
=
=
"
open
"
&
&
(
event
.
target
.
localName
=
=
"
menuitem
"
|
|
event
.
target
.
localName
=
=
"
menu
"
|
|
event
.
target
.
localName
=
=
"
menucaption
"
)
)
{
this
.
_enableDragScrolling
(
true
)
;
}
}
)
;
this
.
addEventListener
(
"
mouseup
"
event
=
>
{
if
(
event
.
button
!
=
0
)
{
return
;
}
this
.
_draggingState
=
this
.
NOT_DRAGGING
;
this
.
_clearScrollTimer
(
)
;
}
)
;
this
.
addEventListener
(
"
mousemove
"
event
=
>
{
if
(
!
this
.
_draggingState
)
{
return
;
}
this
.
_clearScrollTimer
(
)
;
if
(
!
(
event
.
buttons
&
1
)
)
{
this
.
_draggingState
=
this
.
NOT_DRAGGING
;
this
.
releaseCapture
(
)
;
return
;
}
let
popupRect
=
this
.
getOuterScreenRect
(
)
;
if
(
event
.
screenX
>
=
popupRect
.
left
&
&
event
.
screenX
<
=
popupRect
.
right
)
{
if
(
this
.
_draggingState
=
=
this
.
DRAG_OVER_BUTTON
)
{
if
(
event
.
screenY
>
popupRect
.
top
&
&
event
.
screenY
<
popupRect
.
bottom
)
{
this
.
_draggingState
=
this
.
DRAG_OVER_POPUP
;
}
}
if
(
this
.
_draggingState
=
=
this
.
DRAG_OVER_POPUP
&
&
(
event
.
screenY
<
=
popupRect
.
top
|
|
event
.
screenY
>
=
popupRect
.
bottom
)
)
{
let
scrollAmount
=
event
.
screenY
<
=
popupRect
.
top
?
-
1
:
1
;
this
.
scrollBox
.
scrollByIndex
(
scrollAmount
true
)
;
let
win
=
this
.
ownerGlobal
;
this
.
_scrollTimer
=
win
.
setInterval
(
(
)
=
>
{
this
.
scrollBox
.
scrollByIndex
(
scrollAmount
true
)
;
}
this
.
AUTOSCROLL_INTERVAL
)
;
}
}
}
)
;
this
.
_menulistPopupIsSetUp
=
true
;
}
_enableDragScrolling
(
overItem
)
{
if
(
!
this
.
_draggingState
)
{
this
.
setCaptureAlways
(
)
;
this
.
_draggingState
=
overItem
?
this
.
DRAG_OVER_POPUP
:
this
.
DRAG_OVER_BUTTON
;
}
}
_clearScrollTimer
(
)
{
if
(
this
.
_scrollTimer
)
{
this
.
ownerGlobal
.
clearInterval
(
this
.
_scrollTimer
)
;
this
.
_scrollTimer
=
0
;
}
}
}
MozElements
.
MozMenuPopup
=
MozMenuPopup
;
}
