"
use
strict
"
;
{
class
MozPanel
extends
MozElements
.
MozElementMixin
(
XULPopupElement
)
{
static
get
markup
(
)
{
return
<
html
:
slot
part
=
"
content
"
style
=
"
display
:
none
!
important
"
/
>
;
}
constructor
(
)
{
super
(
)
;
this
.
_prevFocus
=
0
;
this
.
_fadeTimer
=
null
;
this
.
attachShadow
(
{
mode
:
"
open
"
}
)
;
this
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
addEventListener
(
"
popupshown
"
this
)
;
this
.
addEventListener
(
"
popuphiding
"
this
)
;
this
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
addEventListener
(
"
popuppositioned
"
this
)
;
}
connectedCallback
(
)
{
if
(
!
this
.
hidden
)
{
this
.
ensureInitialized
(
)
;
}
if
(
this
.
isArrowPanel
)
{
if
(
!
this
.
hasAttribute
(
"
flip
"
)
)
{
this
.
setAttribute
(
"
flip
"
"
both
"
)
;
}
if
(
!
this
.
hasAttribute
(
"
side
"
)
)
{
this
.
setAttribute
(
"
side
"
"
top
"
)
;
}
if
(
!
this
.
hasAttribute
(
"
position
"
)
)
{
this
.
setAttribute
(
"
position
"
"
bottomleft
topleft
"
)
;
}
if
(
!
this
.
hasAttribute
(
"
consumeoutsideclicks
"
)
)
{
this
.
setAttribute
(
"
consumeoutsideclicks
"
"
false
"
)
;
}
}
}
ensureInitialized
(
)
{
if
(
this
.
shadowRoot
.
firstChild
)
{
return
;
}
this
.
shadowRoot
.
appendChild
(
this
.
constructor
.
fragment
)
;
if
(
this
.
hasAttribute
(
"
neverhidden
"
)
)
{
this
.
panelContent
.
style
.
display
=
"
"
;
}
}
get
panelContent
(
)
{
return
this
.
shadowRoot
.
querySelector
(
"
[
part
=
content
]
"
)
;
}
get
hidden
(
)
{
return
super
.
hidden
;
}
set
hidden
(
v
)
{
if
(
!
v
)
{
this
.
ensureInitialized
(
)
;
}
super
.
hidden
=
v
;
}
removeAttribute
(
name
)
{
if
(
name
=
=
"
hidden
"
)
{
this
.
ensureInitialized
(
)
;
}
super
.
removeAttribute
(
name
)
;
}
get
isArrowPanel
(
)
{
return
this
.
getAttribute
(
"
type
"
)
=
=
"
arrow
"
;
}
get
noOpenOnAnchor
(
)
{
return
this
.
hasAttribute
(
"
no
-
open
-
on
-
anchor
"
)
;
}
_setSideAttribute
(
event
)
{
if
(
!
this
.
isArrowPanel
|
|
!
event
.
isAnchored
)
{
return
;
}
let
position
=
event
.
alignmentPosition
;
if
(
position
.
indexOf
(
"
start_
"
)
=
=
0
|
|
position
.
indexOf
(
"
end_
"
)
=
=
0
)
{
let
isRTL
=
window
.
getComputedStyle
(
this
)
.
direction
=
=
"
rtl
"
;
if
(
position
.
indexOf
(
"
start_
"
)
=
=
0
)
{
this
.
setAttribute
(
"
side
"
isRTL
?
"
left
"
:
"
right
"
)
;
}
else
{
this
.
setAttribute
(
"
side
"
isRTL
?
"
right
"
:
"
left
"
)
;
}
}
else
if
(
position
.
indexOf
(
"
before_
"
)
=
=
0
|
|
position
.
indexOf
(
"
after_
"
)
=
=
0
)
{
if
(
position
.
indexOf
(
"
before_
"
)
=
=
0
)
{
this
.
setAttribute
(
"
side
"
"
bottom
"
)
;
}
else
{
this
.
setAttribute
(
"
side
"
"
top
"
)
;
}
}
this
.
setArrowPosition
?
.
(
event
)
;
}
on_popupshowing
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
panelContent
.
style
.
display
=
"
"
;
}
if
(
this
.
isArrowPanel
&
&
event
.
target
=
=
this
)
{
if
(
this
.
anchorNode
&
&
!
this
.
noOpenOnAnchor
)
{
let
anchorRoot
=
this
.
anchorNode
.
closest
(
"
toolbarbutton
.
anchor
-
root
"
)
|
|
this
.
anchorNode
;
anchorRoot
.
setAttribute
(
"
open
"
"
true
"
)
;
}
if
(
this
.
getAttribute
(
"
animate
"
)
!
=
"
false
"
)
{
this
.
setAttribute
(
"
animate
"
"
open
"
)
;
this
.
setAttribute
(
"
animating
"
"
true
"
)
;
}
var
fade
=
this
.
getAttribute
(
"
fade
"
)
;
var
fadeDelay
=
0
;
if
(
fade
=
=
"
fast
"
)
{
fadeDelay
=
1
;
}
else
if
(
fade
=
=
"
slow
"
)
{
fadeDelay
=
4000
;
}
if
(
fadeDelay
!
=
0
)
{
this
.
_fadeTimer
=
setTimeout
(
(
)
=
>
this
.
hidePopup
(
true
)
fadeDelay
this
)
;
}
}
try
{
this
.
_prevFocus
=
Cu
.
getWeakReference
(
document
.
commandDispatcher
.
focusedElement
)
;
if
(
!
this
.
_prevFocus
.
get
(
)
)
{
this
.
_prevFocus
=
Cu
.
getWeakReference
(
document
.
activeElement
)
;
}
}
catch
(
ex
)
{
this
.
_prevFocus
=
Cu
.
getWeakReference
(
document
.
activeElement
)
;
}
}
on_popupshown
(
event
)
{
if
(
this
.
isArrowPanel
&
&
event
.
target
=
=
this
)
{
this
.
removeAttribute
(
"
animating
"
)
;
this
.
setAttribute
(
"
panelopen
"
"
true
"
)
;
}
let
alertEvent
=
document
.
createEvent
(
"
Events
"
)
;
alertEvent
.
initEvent
(
"
AlertActive
"
true
true
)
;
this
.
dispatchEvent
(
alertEvent
)
;
}
on_popuphiding
(
event
)
{
if
(
this
.
isArrowPanel
&
&
event
.
target
=
=
this
)
{
let
animate
=
this
.
getAttribute
(
"
animate
"
)
!
=
"
false
"
;
if
(
this
.
_fadeTimer
)
{
clearTimeout
(
this
.
_fadeTimer
)
;
if
(
animate
)
{
this
.
setAttribute
(
"
animate
"
"
fade
"
)
;
}
}
else
if
(
animate
)
{
this
.
setAttribute
(
"
animate
"
"
cancel
"
)
;
}
if
(
this
.
anchorNode
&
&
!
this
.
noOpenOnAnchor
)
{
let
anchorRoot
=
this
.
anchorNode
.
closest
(
"
toolbarbutton
.
anchor
-
root
"
)
|
|
this
.
anchorNode
;
anchorRoot
.
removeAttribute
(
"
open
"
)
;
}
}
try
{
this
.
_currentFocus
=
document
.
commandDispatcher
.
focusedElement
;
}
catch
(
e
)
{
this
.
_currentFocus
=
document
.
activeElement
;
}
}
on_popuphidden
(
event
)
{
if
(
event
.
target
=
=
this
&
&
!
this
.
hasAttribute
(
"
neverhidden
"
)
)
{
this
.
panelContent
.
style
.
setProperty
(
"
display
"
"
none
"
"
important
"
)
;
}
if
(
this
.
isArrowPanel
&
&
event
.
target
=
=
this
)
{
this
.
removeAttribute
(
"
panelopen
"
)
;
if
(
this
.
getAttribute
(
"
animate
"
)
!
=
"
false
"
)
{
this
.
removeAttribute
(
"
animate
"
)
;
}
}
function
doFocus
(
)
{
prevFocus
.
setAttribute
(
"
refocused
-
by
-
panel
"
true
)
;
try
{
let
fm
=
Services
.
focus
;
fm
.
setFocus
(
prevFocus
fm
.
FLAG_NOSCROLL
)
;
}
catch
(
e
)
{
prevFocus
.
focus
(
)
;
}
prevFocus
.
removeAttribute
(
"
refocused
-
by
-
panel
"
)
;
}
var
currentFocus
=
this
.
_currentFocus
;
var
prevFocus
=
this
.
_prevFocus
?
this
.
_prevFocus
.
get
(
)
:
null
;
this
.
_currentFocus
=
null
;
this
.
_prevFocus
=
null
;
let
nowFocus
;
try
{
nowFocus
=
document
.
commandDispatcher
.
focusedElement
;
}
catch
(
e
)
{
nowFocus
=
document
.
activeElement
;
}
if
(
nowFocus
&
&
nowFocus
!
=
currentFocus
)
{
return
;
}
if
(
prevFocus
&
&
this
.
getAttribute
(
"
norestorefocus
"
)
!
=
"
true
"
)
{
try
{
if
(
document
.
commandDispatcher
.
focusedWindow
!
=
window
)
{
return
;
}
}
catch
(
ex
)
{
}
if
(
!
currentFocus
)
{
doFocus
(
)
;
return
;
}
while
(
currentFocus
)
{
if
(
currentFocus
=
=
this
)
{
doFocus
(
)
;
return
;
}
currentFocus
=
currentFocus
.
parentNode
;
}
}
}
on_popuppositioned
(
event
)
{
if
(
event
.
target
=
=
this
)
{
this
.
_setSideAttribute
(
event
)
;
}
}
}
customElements
.
define
(
"
panel
"
MozPanel
)
;
}
