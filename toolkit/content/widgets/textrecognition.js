"
use
strict
"
;
this
.
TextRecognitionWidget
=
class
{
constructor
(
shadowRoot
_prefs
)
{
this
.
shadowRoot
=
shadowRoot
;
this
.
element
=
shadowRoot
.
host
;
this
.
document
=
this
.
element
.
ownerDocument
;
this
.
window
=
this
.
document
.
defaultView
;
this
.
resizeObserver
=
null
;
this
.
spanRects
=
new
Map
(
)
;
this
.
isInitialized
=
false
;
this
.
lastCanvasStyleWidth
=
null
;
}
onsetup
(
)
{
this
.
resizeObserver
=
new
this
.
window
.
ResizeObserver
(
(
)
=
>
{
this
.
positionSpans
(
)
;
}
)
;
this
.
resizeObserver
.
observe
(
this
.
element
)
;
}
positionSpans
(
)
{
if
(
!
this
.
shadowRoot
.
firstChild
)
{
return
;
}
this
.
lazilyInitialize
(
)
;
const
div
=
this
.
shadowRoot
.
firstChild
;
const
canvas
=
div
.
querySelector
(
"
canvas
"
)
;
const
spans
=
div
.
querySelectorAll
(
"
span
"
)
;
const
imgRect
=
this
.
element
.
getBoundingClientRect
(
)
;
div
.
style
.
width
=
imgRect
.
width
+
"
px
"
;
div
.
style
.
height
=
imgRect
.
height
+
"
px
"
;
canvas
.
style
.
width
=
imgRect
.
width
+
"
px
"
;
canvas
.
style
.
height
=
imgRect
.
height
+
"
px
"
;
let
ctx
=
null
;
if
(
this
.
lastCanvasStyleWidth
=
=
=
null
|
|
imgRect
.
width
>
this
.
lastCanvasStyleWidth
*
1
.
25
)
{
const
dpr
=
this
.
window
.
devicePixelRatio
;
canvas
.
width
=
imgRect
.
width
*
dpr
;
canvas
.
height
=
imgRect
.
height
*
dpr
;
this
.
lastCanvasStyleWidth
=
imgRect
.
width
;
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
scale
(
dpr
dpr
)
;
ctx
.
fillStyle
=
"
#
00000088
"
;
ctx
.
fillRect
(
0
0
imgRect
.
width
imgRect
.
height
)
;
ctx
.
beginPath
(
)
;
}
for
(
const
span
of
spans
)
{
let
spanRect
=
this
.
spanRects
.
get
(
span
)
;
if
(
!
spanRect
)
{
spanRect
=
span
.
getBoundingClientRect
(
)
;
this
.
spanRects
.
set
(
span
spanRect
)
;
}
const
points
=
span
.
dataset
.
points
.
split
(
"
"
)
.
map
(
p
=
>
Number
(
p
)
)
;
let
[
bottomLeftX
bottomLeftY
topLeftX
topLeftY
topRightX
topRightY
bottomRightX
bottomRightY
]
=
points
;
topLeftY
=
1
-
topLeftY
;
topRightY
=
1
-
topRightY
;
bottomLeftY
=
1
-
bottomLeftY
;
bottomRightY
=
1
-
bottomRightY
;
const
mat4
=
projectPoints
(
spanRect
.
width
spanRect
.
height
imgRect
.
width
*
topLeftX
imgRect
.
height
*
topLeftY
imgRect
.
width
*
topRightX
imgRect
.
height
*
topRightY
imgRect
.
width
*
bottomLeftX
imgRect
.
height
*
bottomLeftY
imgRect
.
width
*
bottomRightX
imgRect
.
height
*
bottomRightY
)
;
span
.
style
.
transform
=
"
matrix3d
(
"
+
mat4
.
join
(
"
"
)
+
"
)
"
;
if
(
ctx
)
{
const
inset
=
3
;
ctx
.
moveTo
(
imgRect
.
width
*
bottomLeftX
+
inset
imgRect
.
height
*
bottomLeftY
-
inset
)
;
ctx
.
lineTo
(
imgRect
.
width
*
topLeftX
+
inset
imgRect
.
height
*
topLeftY
+
inset
)
;
ctx
.
lineTo
(
imgRect
.
width
*
topRightX
-
inset
imgRect
.
height
*
topRightY
+
inset
)
;
ctx
.
lineTo
(
imgRect
.
width
*
bottomRightX
-
inset
imgRect
.
height
*
bottomRightY
-
inset
)
;
ctx
.
closePath
(
)
;
}
}
if
(
ctx
)
{
ctx
.
globalCompositeOperation
=
"
destination
-
out
"
;
ctx
.
fillStyle
=
"
#
ffffff
"
;
ctx
.
fill
(
)
;
ctx
.
lineWidth
=
10
;
ctx
.
lineJoin
=
"
round
"
;
ctx
.
strokeStyle
=
"
#
ffffff
"
;
ctx
.
stroke
(
)
;
}
}
teardown
(
)
{
this
.
shadowRoot
.
firstChild
.
remove
(
)
;
this
.
resizeObserver
.
disconnect
(
)
;
this
.
spanRects
.
clear
(
)
;
}
lazilyInitialize
(
)
{
if
(
this
.
isInitialized
)
{
return
;
}
this
.
isInitialized
=
true
;
const
parser
=
new
this
.
window
.
DOMParser
(
)
;
let
parserDoc
=
parser
.
parseFromString
(
<
div
class
=
"
textrecognition
"
xmlns
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
role
=
"
none
"
>
<
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
global
/
skin
/
media
/
textrecognition
.
css
"
/
>
<
canvas
/
>
<
!
-
-
The
spans
will
be
reattached
here
-
-
>
<
/
div
>
"
application
/
xml
"
)
;
if
(
this
.
shadowRoot
.
children
.
length
!
=
=
1
|
|
this
.
shadowRoot
.
firstChild
.
tagName
!
=
=
"
DIV
"
)
{
throw
new
Error
(
"
Expected
the
shadowRoot
to
have
a
single
div
as
the
root
element
.
"
)
;
}
const
spansDiv
=
this
.
shadowRoot
.
firstChild
;
spansDiv
.
remove
(
)
;
this
.
shadowRoot
.
importNodeAndAppendChildAt
(
this
.
shadowRoot
parserDoc
.
documentElement
true
)
;
this
.
shadowRoot
.
importNodeAndAppendChildAt
(
this
.
shadowRoot
.
firstChild
spansDiv
true
)
;
}
}
;
function
computeAdjugate
(
m
)
{
return
[
m
[
4
]
*
m
[
8
]
-
m
[
5
]
*
m
[
7
]
m
[
2
]
*
m
[
7
]
-
m
[
1
]
*
m
[
8
]
m
[
1
]
*
m
[
5
]
-
m
[
2
]
*
m
[
4
]
m
[
5
]
*
m
[
6
]
-
m
[
3
]
*
m
[
8
]
m
[
0
]
*
m
[
8
]
-
m
[
2
]
*
m
[
6
]
m
[
2
]
*
m
[
3
]
-
m
[
0
]
*
m
[
5
]
m
[
3
]
*
m
[
7
]
-
m
[
4
]
*
m
[
6
]
m
[
1
]
*
m
[
6
]
-
m
[
0
]
*
m
[
7
]
m
[
0
]
*
m
[
4
]
-
m
[
1
]
*
m
[
3
]
]
;
}
function
multiplyMat3
(
a
b
)
{
let
out
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
3
;
j
+
+
)
{
let
sum
=
0
;
for
(
let
k
=
0
;
k
<
3
;
k
+
+
)
{
sum
+
=
a
[
3
*
i
+
k
]
*
b
[
3
*
k
+
j
]
;
}
out
[
3
*
i
+
j
]
=
sum
;
}
}
return
out
;
}
function
multiplyMat3Vec3
(
m
v
)
{
return
[
m
[
0
]
*
v
[
0
]
+
m
[
1
]
*
v
[
1
]
+
m
[
2
]
*
v
[
2
]
m
[
3
]
*
v
[
0
]
+
m
[
4
]
*
v
[
1
]
+
m
[
5
]
*
v
[
2
]
m
[
6
]
*
v
[
0
]
+
m
[
7
]
*
v
[
1
]
+
m
[
8
]
*
v
[
2
]
]
;
}
function
basisToPoints
(
x1
y1
x2
y2
x3
y3
x4
y4
)
{
let
mat3
=
[
x1
x2
x3
y1
y2
y3
1
1
1
]
;
let
vec3
=
multiplyMat3Vec3
(
computeAdjugate
(
mat3
)
[
x4
y4
1
]
)
;
return
multiplyMat3
(
mat3
[
vec3
[
0
]
0
0
0
vec3
[
1
]
0
0
0
vec3
[
2
]
]
)
;
}
function
general2DProjection
(
x1s
y1s
x1d
y1d
x2s
y2s
x2d
y2d
x3s
y3s
x3d
y3d
x4s
y4s
x4d
y4d
)
{
let
s
=
basisToPoints
(
x1s
y1s
x2s
y2s
x3s
y3s
x4s
y4s
)
;
let
d
=
basisToPoints
(
x1d
y1d
x2d
y2d
x3d
y3d
x4d
y4d
)
;
return
multiplyMat3
(
d
computeAdjugate
(
s
)
)
;
}
function
projectPoints
(
w
h
x1
y1
x2
y2
x3
y3
x4
y4
)
{
const
mat3
=
general2DProjection
(
0
0
x1
y1
w
0
x2
y2
0
h
x3
y3
w
h
x4
y4
)
;
for
(
let
i
=
0
;
i
<
9
;
i
+
+
)
{
mat3
[
i
]
=
mat3
[
i
]
/
mat3
[
8
]
;
}
return
[
mat3
[
0
]
mat3
[
3
]
0
mat3
[
6
]
mat3
[
1
]
mat3
[
4
]
0
mat3
[
7
]
0
0
1
0
mat3
[
2
]
mat3
[
5
]
0
mat3
[
8
]
]
;
}
