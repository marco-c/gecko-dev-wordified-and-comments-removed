"
use
strict
"
;
function
TimeKeeper
(
props
)
{
this
.
props
=
props
;
this
.
state
=
{
time
:
new
Date
(
0
)
ranges
:
{
}
}
;
}
{
const
debug
=
0
?
console
.
log
.
bind
(
console
'
[
timekeeper
]
'
)
:
function
(
)
{
}
;
const
DAY_PERIOD_IN_HOURS
=
12
SECOND_IN_MS
=
1000
MINUTE_IN_MS
=
60000
HOUR_IN_MS
=
3600000
DAY_PERIOD_IN_MS
=
43200000
DAY_IN_MS
=
86400000
TIME_FORMAT_24
=
"
24
"
;
TimeKeeper
.
prototype
=
{
get
hour
(
)
{
return
this
.
state
.
time
.
getUTCHours
(
)
;
}
get
minute
(
)
{
return
this
.
state
.
time
.
getUTCMinutes
(
)
;
}
get
second
(
)
{
return
this
.
state
.
time
.
getUTCSeconds
(
)
;
}
get
millisecond
(
)
{
return
this
.
state
.
time
.
getUTCMilliseconds
(
)
;
}
get
dayPeriod
(
)
{
return
this
.
state
.
time
.
getUTCHours
(
)
<
DAY_PERIOD_IN_HOURS
?
0
:
DAY_PERIOD_IN_HOURS
;
}
get
ranges
(
)
{
return
this
.
state
.
ranges
;
}
setState
(
timeState
)
{
const
{
min
max
}
=
this
.
props
;
const
{
hour
minute
second
millisecond
}
=
timeState
;
if
(
hour
!
=
undefined
)
{
this
.
state
.
time
.
setUTCHours
(
hour
)
;
}
if
(
minute
!
=
undefined
)
{
this
.
state
.
time
.
setUTCMinutes
(
minute
)
;
}
if
(
second
!
=
undefined
)
{
this
.
state
.
time
.
setUTCSeconds
(
second
)
;
}
if
(
millisecond
!
=
undefined
)
{
this
.
state
.
time
.
setUTCMilliseconds
(
millisecond
)
;
}
this
.
state
.
isOffStep
=
this
.
_isOffStep
(
this
.
state
.
time
)
;
this
.
state
.
isOutOfRange
=
(
this
.
state
.
time
<
min
|
|
this
.
state
.
time
>
max
)
;
this
.
state
.
isInvalid
=
this
.
state
.
isOutOfRange
|
|
this
.
state
.
isOffStep
;
this
.
_setRanges
(
this
.
dayPeriod
this
.
hour
this
.
minute
this
.
second
)
;
}
setDayPeriod
(
dayPeriod
)
{
if
(
dayPeriod
=
=
this
.
dayPeriod
)
{
return
;
}
if
(
dayPeriod
=
=
0
)
{
this
.
setState
(
{
hour
:
this
.
hour
-
DAY_PERIOD_IN_HOURS
}
)
;
}
else
{
this
.
setState
(
{
hour
:
this
.
hour
+
DAY_PERIOD_IN_HOURS
}
)
;
}
}
setHour
(
hour
)
{
this
.
setState
(
{
hour
}
)
;
}
setMinute
(
minute
)
{
this
.
setState
(
{
minute
}
)
;
}
setSecond
(
second
)
{
this
.
setState
(
{
second
}
)
;
}
setMillisecond
(
millisecond
)
{
this
.
setState
(
{
millisecond
}
)
;
}
_setRanges
(
dayPeriod
hour
minute
second
)
{
this
.
state
.
ranges
.
dayPeriod
=
this
.
state
.
ranges
.
dayPeriod
|
|
this
.
_getDayPeriodRange
(
)
;
if
(
this
.
state
.
dayPeriod
!
=
dayPeriod
)
{
this
.
state
.
ranges
.
hours
=
this
.
_getHoursRange
(
dayPeriod
)
;
}
if
(
this
.
state
.
hour
!
=
hour
)
{
this
.
state
.
ranges
.
minutes
=
this
.
_getMinutesRange
(
hour
)
;
}
if
(
this
.
state
.
hour
!
=
hour
|
|
this
.
state
.
minute
!
=
minute
)
{
this
.
state
.
ranges
.
seconds
=
this
.
_getSecondsRange
(
hour
minute
)
;
}
if
(
this
.
state
.
hour
!
=
hour
|
|
this
.
state
.
minute
!
=
minute
|
|
this
.
state
.
second
!
=
second
)
{
this
.
state
.
ranges
.
milliseconds
=
this
.
_getMillisecondsRange
(
hour
minute
second
)
;
}
this
.
state
.
dayPeriod
=
dayPeriod
;
this
.
state
.
hour
=
hour
;
this
.
state
.
minute
=
minute
;
this
.
state
.
second
=
second
;
}
_getDayPeriodRange
(
)
{
if
(
this
.
props
.
format
=
=
TIME_FORMAT_24
)
{
return
[
]
;
}
const
start
=
0
;
const
end
=
DAY_IN_MS
-
1
;
const
minStep
=
DAY_PERIOD_IN_MS
;
const
formatter
=
(
time
)
=
>
new
Date
(
time
)
.
getUTCHours
(
)
<
DAY_PERIOD_IN_HOURS
?
0
:
DAY_PERIOD_IN_HOURS
;
return
this
.
_getSteps
(
start
end
minStep
formatter
)
;
}
_getHoursRange
(
dayPeriod
)
{
const
{
format
}
=
this
.
props
;
const
start
=
format
=
=
"
24
"
?
0
:
dayPeriod
*
HOUR_IN_MS
;
const
end
=
format
=
=
"
24
"
?
DAY_IN_MS
-
1
:
start
+
DAY_PERIOD_IN_MS
-
1
;
const
minStep
=
HOUR_IN_MS
;
const
formatter
=
(
time
)
=
>
new
Date
(
time
)
.
getUTCHours
(
)
;
return
this
.
_getSteps
(
start
end
minStep
formatter
)
;
}
_getMinutesRange
(
hour
)
{
const
start
=
hour
*
HOUR_IN_MS
;
const
end
=
start
+
HOUR_IN_MS
-
1
;
const
minStep
=
MINUTE_IN_MS
;
const
formatter
=
(
time
)
=
>
new
Date
(
time
)
.
getUTCMinutes
(
)
;
return
this
.
_getSteps
(
start
end
minStep
formatter
)
;
}
_getSecondsRange
(
hour
minute
)
{
const
start
=
hour
*
HOUR_IN_MS
+
minute
*
MINUTE_IN_MS
;
const
end
=
start
+
MINUTE_IN_MS
-
1
;
const
minStep
=
SECOND_IN_MS
;
const
formatter
=
(
time
)
=
>
new
Date
(
time
)
.
getUTCSeconds
(
)
;
return
this
.
_getSteps
(
start
end
minStep
formatter
)
;
}
_getMillisecondsRange
(
hour
minute
second
)
{
const
start
=
hour
*
HOUR_IN_MS
+
minute
*
MINUTE_IN_MS
+
second
*
SECOND_IN_MS
;
const
end
=
start
+
SECOND_IN_MS
-
1
;
const
minStep
=
1
;
const
formatter
=
(
time
)
=
>
new
Date
(
time
)
.
getUTCMilliseconds
(
)
;
return
this
.
_getSteps
(
start
end
minStep
formatter
)
;
}
_getSteps
(
startValue
endValue
minStep
formatter
)
{
const
{
min
max
stepInMs
}
=
this
.
props
;
const
timeStep
=
Math
.
max
(
minStep
stepInMs
)
;
let
time
=
min
.
valueOf
(
)
+
Math
.
ceil
(
(
startValue
-
min
.
valueOf
(
)
)
/
timeStep
)
*
timeStep
;
let
maxValue
=
min
.
valueOf
(
)
+
Math
.
floor
(
(
max
.
valueOf
(
)
-
min
.
valueOf
(
)
)
/
stepInMs
)
*
stepInMs
;
let
steps
=
[
]
;
while
(
time
<
=
endValue
)
{
steps
.
push
(
{
value
:
formatter
(
time
)
enabled
:
(
time
>
=
min
.
valueOf
(
)
&
&
time
<
=
max
.
valueOf
(
)
)
|
|
(
time
>
maxValue
&
&
startValue
<
=
maxValue
&
&
endValue
>
=
maxValue
&
&
formatter
(
time
)
=
=
formatter
(
maxValue
)
)
}
)
;
time
+
=
timeStep
;
}
return
steps
;
}
_step
(
current
offset
range
)
{
const
index
=
range
.
findIndex
(
step
=
>
step
.
value
=
=
current
)
;
const
newIndex
=
offset
>
0
?
Math
.
min
(
index
+
offset
range
.
length
-
1
)
:
Math
.
max
(
index
+
offset
0
)
;
return
range
[
newIndex
]
.
value
;
}
stepDayPeriodBy
(
offset
)
{
const
current
=
this
.
dayPeriod
;
const
dayPeriod
=
this
.
_step
(
current
offset
this
.
state
.
ranges
.
dayPeriod
)
;
if
(
current
!
=
dayPeriod
)
{
this
.
hour
<
DAY_PERIOD_IN_HOURS
?
this
.
setState
(
{
hour
:
this
.
hour
+
DAY_PERIOD_IN_HOURS
}
)
:
this
.
setState
(
{
hour
:
this
.
hour
-
DAY_PERIOD_IN_HOURS
}
)
;
}
}
stepHourBy
(
offset
)
{
const
current
=
this
.
hour
;
const
hour
=
this
.
_step
(
current
offset
this
.
state
.
ranges
.
hours
)
;
if
(
current
!
=
hour
)
{
this
.
setState
(
{
hour
}
)
;
}
}
stepMinuteBy
(
offset
)
{
const
current
=
this
.
minute
;
const
minute
=
this
.
_step
(
current
offset
this
.
state
.
ranges
.
minutes
)
;
if
(
current
!
=
minute
)
{
this
.
setState
(
{
minute
}
)
;
}
}
stepSecondBy
(
offset
)
{
const
current
=
this
.
second
;
const
second
=
this
.
_step
(
current
offset
this
.
state
.
ranges
.
seconds
)
;
if
(
current
!
=
second
)
{
this
.
setState
(
{
second
}
)
;
}
}
stepMillisecondBy
(
offset
)
{
const
current
=
this
.
milliseconds
;
const
millisecond
=
this
.
_step
(
current
offset
this
.
state
.
ranges
.
millisecond
)
;
if
(
current
!
=
millisecond
)
{
this
.
setState
(
{
millisecond
}
)
;
}
}
_isOffStep
(
time
)
{
const
{
min
stepInMs
}
=
this
.
props
;
return
(
time
.
valueOf
(
)
-
min
.
valueOf
(
)
)
%
stepInMs
!
=
0
;
}
}
;
}
