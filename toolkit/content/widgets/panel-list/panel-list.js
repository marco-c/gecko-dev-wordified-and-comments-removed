"
use
strict
"
;
{
class
PanelList
extends
HTMLElement
{
static
get
observedAttributes
(
)
{
return
[
"
open
"
]
;
}
static
get
fragment
(
)
{
if
(
!
this
.
_template
)
{
let
parser
=
new
DOMParser
(
)
;
let
doc
=
parser
.
parseFromString
(
<
template
>
<
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
global
/
content
/
elements
/
panel
-
list
.
css
"
>
<
div
class
=
"
arrow
top
"
role
=
"
presentation
"
>
<
/
div
>
<
div
class
=
"
list
"
role
=
"
presentation
"
>
<
slot
>
<
/
slot
>
<
/
div
>
<
div
class
=
"
arrow
bottom
"
role
=
"
presentation
"
>
<
/
div
>
<
/
template
>
"
text
/
html
"
)
;
this
.
_template
=
document
.
importNode
(
doc
.
querySelector
(
"
template
"
)
true
)
;
}
let
frag
=
this
.
_template
.
content
.
cloneNode
(
true
)
;
if
(
window
.
IS_STORYBOOK
)
{
frag
.
querySelector
(
"
link
"
)
.
href
=
"
.
/
panel
-
list
/
panel
-
list
.
css
"
;
}
return
frag
;
}
constructor
(
)
{
super
(
)
;
this
.
attachShadow
(
{
mode
:
"
open
"
}
)
;
let
style
=
document
.
createElement
(
"
style
"
)
;
style
.
textContent
=
:
host
(
:
not
(
[
open
]
)
)
{
display
:
none
;
}
;
this
.
shadowRoot
.
appendChild
(
style
)
;
this
.
shadowRoot
.
appendChild
(
this
.
constructor
.
fragment
)
;
}
connectedCallback
(
)
{
this
.
setAttribute
(
"
role
"
"
menu
"
)
;
}
attributeChangedCallback
(
name
oldVal
newVal
)
{
if
(
name
=
=
"
open
"
&
&
newVal
!
=
oldVal
)
{
if
(
this
.
open
)
{
this
.
onShow
(
)
;
}
else
{
this
.
onHide
(
)
;
}
}
}
get
open
(
)
{
return
this
.
hasAttribute
(
"
open
"
)
;
}
set
open
(
val
)
{
this
.
toggleAttribute
(
"
open
"
val
)
;
}
getTargetForEvent
(
event
)
{
if
(
!
event
)
{
return
null
;
}
if
(
event
.
_savedComposedTarget
)
{
return
event
.
_savedComposedTarget
;
}
if
(
event
.
composed
)
{
event
.
_savedComposedTarget
=
event
.
composedTarget
|
|
event
.
composedPath
(
)
[
0
]
;
}
return
event
.
_savedComposedTarget
|
|
event
.
target
;
}
show
(
triggeringEvent
)
{
this
.
triggeringEvent
=
triggeringEvent
;
this
.
lastAnchorNode
=
this
.
getTargetForEvent
(
this
.
triggeringEvent
)
;
this
.
wasOpenedByKeyboard
=
triggeringEvent
&
&
(
triggeringEvent
.
inputSource
=
=
MouseEvent
.
MOZ_SOURCE_KEYBOARD
|
|
triggeringEvent
.
inputSource
=
=
MouseEvent
.
MOZ_SOURCE_UNKNOWN
)
;
this
.
open
=
true
;
if
(
this
.
parentIsXULPanel
(
)
)
{
this
.
toggleAttribute
(
"
inxulpanel
"
true
)
;
let
panel
=
this
.
parentElement
;
panel
.
hidden
=
false
;
requestAnimationFrame
(
(
)
=
>
{
setTimeout
(
(
)
=
>
{
panel
.
openPopup
(
this
.
lastAnchorNode
"
after_start
"
0
0
false
false
this
.
triggeringEvent
)
;
}
0
)
;
}
)
;
}
else
{
this
.
toggleAttribute
(
"
inxulpanel
"
false
)
;
}
}
hide
(
triggeringEvent
{
force
=
false
}
=
{
}
)
{
const
autohideDisabled
=
this
.
hasServices
(
)
?
Services
.
prefs
.
getBoolPref
(
"
ui
.
popup
.
disable_autohide
"
false
)
:
false
;
if
(
autohideDisabled
&
&
!
force
)
{
return
;
}
let
openingEvent
=
this
.
triggeringEvent
;
this
.
triggeringEvent
=
triggeringEvent
;
this
.
open
=
false
;
if
(
this
.
parentIsXULPanel
(
)
)
{
let
panel
=
this
.
parentElement
;
panel
.
hidePopup
(
)
;
}
let
target
=
this
.
getTargetForEvent
(
openingEvent
)
;
if
(
target
&
&
this
.
wasOpenedByKeyboard
)
{
target
.
focus
(
)
;
}
}
toggle
(
triggeringEvent
)
{
if
(
this
.
open
)
{
this
.
hide
(
triggeringEvent
{
force
:
true
}
)
;
}
else
{
this
.
show
(
triggeringEvent
)
;
}
}
hasServices
(
)
{
return
typeof
Services
!
=
=
"
undefined
"
;
}
isDocumentRTL
(
)
{
if
(
this
.
hasServices
(
)
)
{
return
Services
.
locale
.
isAppLocaleRTL
;
}
return
document
.
dir
=
=
=
"
rtl
"
;
}
parentIsXULPanel
(
)
{
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
return
(
this
.
parentElement
?
.
namespaceURI
=
=
XUL_NS
&
&
this
.
parentElement
?
.
localName
=
=
"
panel
"
)
;
}
async
setAlign
(
)
{
const
hostElement
=
this
.
parentElement
|
|
this
.
getRootNode
(
)
.
host
;
if
(
!
hostElement
)
{
return
;
}
this
.
setAttribute
(
"
showing
"
"
true
"
)
;
hostElement
.
style
.
overflow
=
"
hidden
"
;
let
{
anchorHeight
anchorLeft
anchorTop
anchorWidth
panelHeight
panelWidth
winHeight
winScrollY
winScrollX
winWidth
}
=
await
new
Promise
(
resolve
=
>
{
this
.
style
.
left
=
0
;
this
.
style
.
top
=
0
;
requestAnimationFrame
(
(
)
=
>
setTimeout
(
(
)
=
>
{
let
target
=
this
.
getTargetForEvent
(
this
.
triggeringEvent
)
;
let
anchorElement
=
target
|
|
hostElement
;
let
getBounds
=
el
=
>
window
.
windowUtils
?
window
.
windowUtils
.
getBoundsWithoutFlushing
(
el
)
:
el
.
getBoundingClientRect
(
)
;
let
anchorBounds
=
getBounds
(
anchorElement
)
;
let
panelBounds
=
getBounds
(
this
)
;
resolve
(
{
anchorHeight
:
anchorBounds
.
height
anchorLeft
:
anchorBounds
.
left
anchorTop
:
anchorBounds
.
top
anchorWidth
:
anchorBounds
.
width
panelHeight
:
panelBounds
.
height
panelWidth
:
panelBounds
.
width
winHeight
:
innerHeight
winWidth
:
innerWidth
winScrollX
:
scrollX
winScrollY
:
scrollY
}
)
;
}
0
)
)
;
}
)
;
if
(
!
this
.
parentIsXULPanel
(
)
)
{
let
align
;
let
leftOffset
;
let
leftAlignX
=
anchorLeft
;
let
rightAlignX
=
anchorLeft
+
anchorWidth
-
panelWidth
;
if
(
this
.
isDocumentRTL
(
)
)
{
align
=
rightAlignX
<
0
?
"
left
"
:
"
right
"
;
}
else
{
align
=
leftAlignX
+
panelWidth
>
winWidth
?
"
right
"
:
"
left
"
;
}
leftOffset
=
align
=
=
=
"
left
"
?
leftAlignX
:
rightAlignX
;
let
bottomAlignY
=
anchorTop
+
anchorHeight
;
let
valign
;
let
topOffset
;
if
(
bottomAlignY
+
panelHeight
>
winHeight
)
{
topOffset
=
anchorTop
-
panelHeight
;
valign
=
"
top
"
;
}
else
{
topOffset
=
bottomAlignY
;
valign
=
"
bottom
"
;
}
this
.
setAttribute
(
"
align
"
align
)
;
this
.
setAttribute
(
"
valign
"
valign
)
;
hostElement
.
style
.
overflow
=
"
"
;
this
.
style
.
left
=
{
leftOffset
+
winScrollX
}
px
;
this
.
style
.
top
=
{
topOffset
+
winScrollY
}
px
;
}
this
.
style
.
minWidth
=
this
.
hasAttribute
(
"
min
-
width
-
from
-
anchor
"
)
?
{
anchorWidth
}
px
:
"
"
;
this
.
removeAttribute
(
"
showing
"
)
;
}
addHideListeners
(
)
{
if
(
this
.
hasAttribute
(
"
stay
-
open
"
)
)
{
return
;
}
this
.
addEventListener
(
"
click
"
this
)
;
document
.
addEventListener
(
"
keydown
"
this
)
;
document
.
addEventListener
(
"
mousedown
"
this
)
;
document
.
addEventListener
(
"
focusin
"
this
)
;
this
.
focusHasChanged
=
false
;
window
.
addEventListener
(
"
resize
"
this
)
;
window
.
addEventListener
(
"
scroll
"
this
{
capture
:
true
}
)
;
window
.
addEventListener
(
"
blur
"
this
)
;
if
(
this
.
parentIsXULPanel
(
)
)
{
this
.
parentElement
.
addEventListener
(
"
popuphidden
"
this
)
;
}
}
removeHideListeners
(
)
{
this
.
removeEventListener
(
"
click
"
this
)
;
document
.
removeEventListener
(
"
keydown
"
this
)
;
document
.
removeEventListener
(
"
mousedown
"
this
)
;
document
.
removeEventListener
(
"
focusin
"
this
)
;
window
.
removeEventListener
(
"
resize
"
this
)
;
window
.
removeEventListener
(
"
scroll
"
this
{
capture
:
true
}
)
;
window
.
removeEventListener
(
"
blur
"
this
)
;
if
(
this
.
parentIsXULPanel
(
)
)
{
this
.
parentElement
.
removeEventListener
(
"
popuphidden
"
this
)
;
}
}
handleEvent
(
e
)
{
if
(
e
=
=
this
.
triggeringEvent
)
{
return
;
}
let
target
=
this
.
getTargetForEvent
(
e
)
;
let
inPanelList
=
e
.
composed
?
e
.
composedPath
(
)
.
some
(
el
=
>
el
=
=
this
)
:
e
.
target
.
closest
&
&
e
.
target
.
closest
(
"
panel
-
list
"
)
=
=
this
;
switch
(
e
.
type
)
{
case
"
resize
"
:
case
"
scroll
"
:
if
(
inPanelList
)
{
break
;
}
case
"
blur
"
:
case
"
popuphidden
"
:
this
.
hide
(
)
;
break
;
case
"
click
"
:
if
(
inPanelList
)
{
this
.
hide
(
undefined
{
force
:
true
}
)
;
}
else
{
e
.
stopPropagation
(
)
;
}
break
;
case
"
mousedown
"
:
if
(
!
inPanelList
)
{
this
.
hide
(
)
;
}
break
;
case
"
keydown
"
:
if
(
e
.
key
=
=
=
"
ArrowDown
"
|
|
e
.
key
=
=
=
"
ArrowUp
"
|
|
e
.
key
=
=
=
"
Tab
"
)
{
if
(
e
.
key
=
=
=
"
Tab
"
&
&
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
metaKey
)
)
{
return
;
}
e
.
preventDefault
(
)
;
let
moveForward
=
e
.
key
=
=
=
"
ArrowDown
"
|
|
(
e
.
key
=
=
=
"
Tab
"
&
&
!
e
.
shiftKey
)
;
this
.
focusWalker
.
currentNode
=
this
.
contains
(
this
.
getRootNode
(
)
.
activeElement
)
?
this
.
getRootNode
(
)
.
activeElement
:
this
;
let
nextItem
=
moveForward
?
this
.
focusWalker
.
nextNode
(
)
:
this
.
focusWalker
.
previousNode
(
)
;
if
(
!
nextItem
)
{
this
.
focusWalker
.
currentNode
=
this
;
if
(
moveForward
)
{
nextItem
=
this
.
focusWalker
.
firstChild
(
)
;
}
else
{
nextItem
=
this
.
focusWalker
.
lastChild
(
)
;
}
}
break
;
}
else
if
(
e
.
key
=
=
=
"
Escape
"
)
{
this
.
hide
(
undefined
{
force
:
true
}
)
;
}
else
if
(
!
e
.
metaKey
&
&
!
e
.
ctrlKey
&
&
!
e
.
shiftKey
&
&
!
e
.
altKey
)
{
let
item
=
this
.
querySelector
(
[
accesskey
=
"
{
e
.
key
.
toLowerCase
(
)
}
"
]
[
accesskey
=
"
{
e
.
key
.
toUpperCase
(
)
}
"
]
)
;
if
(
item
)
{
item
.
click
(
)
;
}
}
break
;
case
"
focusin
"
:
if
(
this
.
triggeringEvent
&
&
target
=
=
this
.
getTargetForEvent
(
this
.
triggeringEvent
)
&
&
!
this
.
focusHasChanged
)
{
this
.
focusHasChanged
=
true
;
}
else
if
(
!
target
|
|
!
inPanelList
)
{
this
.
hide
(
)
;
}
else
{
this
.
focusHasChanged
=
true
;
}
break
;
}
}
get
focusWalker
(
)
{
if
(
!
this
.
_focusWalker
)
{
this
.
_focusWalker
=
document
.
createTreeWalker
(
this
NodeFilter
.
SHOW_ELEMENT
{
acceptNode
:
node
=
>
{
if
(
node
.
hidden
)
{
return
NodeFilter
.
FILTER_REJECT
;
}
node
.
focus
(
)
;
if
(
node
=
=
=
node
.
getRootNode
(
)
.
activeElement
)
{
return
NodeFilter
.
FILTER_ACCEPT
;
}
return
NodeFilter
.
FILTER_SKIP
;
}
}
)
;
}
return
this
.
_focusWalker
;
}
async
onShow
(
)
{
this
.
sendEvent
(
"
showing
"
)
;
this
.
addHideListeners
(
)
;
await
this
.
setAlign
(
)
;
requestAnimationFrame
(
(
)
=
>
{
if
(
this
.
wasOpenedByKeyboard
)
{
this
.
focusWalker
.
currentNode
=
this
;
this
.
focusWalker
.
nextNode
(
)
;
}
this
.
lastAnchorNode
?
.
setAttribute
(
"
aria
-
expanded
"
"
true
"
)
;
this
.
sendEvent
(
"
shown
"
)
;
}
)
;
}
onHide
(
)
{
requestAnimationFrame
(
(
)
=
>
{
this
.
sendEvent
(
"
hidden
"
)
;
this
.
lastAnchorNode
?
.
setAttribute
(
"
aria
-
expanded
"
"
false
"
)
;
}
)
;
this
.
removeHideListeners
(
)
;
}
sendEvent
(
name
detail
)
{
this
.
dispatchEvent
(
new
CustomEvent
(
name
{
detail
bubbles
:
true
composed
:
true
}
)
)
;
}
}
customElements
.
define
(
"
panel
-
list
"
PanelList
)
;
class
PanelItem
extends
HTMLElement
{
#
initialized
=
false
;
#
defaultSlot
;
static
get
observedAttributes
(
)
{
return
[
"
accesskey
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
attachShadow
(
{
mode
:
"
open
"
}
)
;
let
style
=
document
.
createElement
(
"
link
"
)
;
style
.
rel
=
"
stylesheet
"
;
style
.
href
=
window
.
IS_STORYBOOK
?
"
.
/
panel
-
list
/
panel
-
item
.
css
"
:
"
chrome
:
/
/
global
/
content
/
elements
/
panel
-
item
.
css
"
;
this
.
button
=
document
.
createElement
(
"
button
"
)
;
this
.
button
.
setAttribute
(
"
role
"
"
menuitem
"
)
;
this
.
button
.
setAttribute
(
"
part
"
"
button
"
)
;
this
.
label
=
document
.
createXULElement
?
document
.
createXULElement
(
"
label
"
)
:
document
.
createElement
(
"
span
"
)
;
this
.
button
.
appendChild
(
this
.
label
)
;
let
supportLinkSlot
=
document
.
createElement
(
"
slot
"
)
;
supportLinkSlot
.
name
=
"
support
-
link
"
;
this
.
#
defaultSlot
=
document
.
createElement
(
"
slot
"
)
;
this
.
#
defaultSlot
.
style
.
display
=
"
none
"
;
this
.
shadowRoot
.
append
(
style
this
.
button
supportLinkSlot
this
.
#
defaultSlot
)
;
}
connectedCallback
(
)
{
if
(
!
this
.
#
initialized
)
{
this
.
#
initialized
=
true
;
this
.
setAttribute
(
"
role
"
"
presentation
"
)
;
this
.
#
setLabelContents
(
)
;
new
MutationObserver
(
(
)
=
>
this
.
#
setLabelContents
(
)
)
.
observe
(
this
{
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
}
this
.
panel
=
this
.
closest
(
"
panel
-
list
"
)
;
if
(
this
.
panel
)
{
this
.
panel
.
addEventListener
(
"
hidden
"
this
)
;
this
.
panel
.
addEventListener
(
"
shown
"
this
)
;
}
}
disconnectedCallback
(
)
{
if
(
this
.
panel
)
{
this
.
panel
.
removeEventListener
(
"
hidden
"
this
)
;
this
.
panel
.
removeEventListener
(
"
shown
"
this
)
;
this
.
panel
=
null
;
}
}
attributeChangedCallback
(
name
oldVal
newVal
)
{
if
(
name
=
=
=
"
accesskey
"
)
{
if
(
this
.
_modifyingAccessKey
)
{
this
.
_modifyingAccessKey
=
false
;
return
;
}
this
.
label
.
accessKey
=
newVal
|
|
"
"
;
if
(
!
this
.
panel
|
|
!
this
.
panel
.
open
)
{
this
.
_accessKey
=
newVal
|
|
null
;
this
.
_modifyingAccessKey
=
true
;
this
.
accessKey
=
"
"
;
}
else
{
this
.
_accessKey
=
null
;
}
}
}
#
setLabelContents
(
)
{
this
.
label
.
textContent
=
this
.
#
defaultSlot
.
assignedNodes
(
)
.
map
(
node
=
>
node
.
textContent
)
.
join
(
"
"
)
;
}
get
disabled
(
)
{
return
this
.
button
.
hasAttribute
(
"
disabled
"
)
;
}
set
disabled
(
val
)
{
this
.
button
.
toggleAttribute
(
"
disabled
"
val
)
;
}
get
checked
(
)
{
return
this
.
hasAttribute
(
"
checked
"
)
;
}
set
checked
(
val
)
{
this
.
toggleAttribute
(
"
checked
"
val
)
;
}
focus
(
)
{
this
.
button
.
focus
(
)
;
}
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
shown
"
:
if
(
this
.
_accessKey
)
{
this
.
accessKey
=
this
.
_accessKey
;
this
.
_accessKey
=
null
;
}
break
;
case
"
hidden
"
:
if
(
this
.
accessKey
)
{
this
.
_accessKey
=
this
.
accessKey
;
this
.
_modifyingAccessKey
=
true
;
this
.
accessKey
=
"
"
;
}
break
;
}
}
}
customElements
.
define
(
"
panel
-
item
"
PanelItem
)
;
}
