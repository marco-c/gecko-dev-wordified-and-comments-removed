"
use
strict
"
;
{
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
MozElements
.
NotificationBox
=
class
NotificationBox
{
constructor
(
insertElementFn
)
{
this
.
_insertElementFn
=
insertElementFn
;
this
.
_animating
=
false
;
this
.
currentNotification
=
null
;
}
get
stack
(
)
{
if
(
!
this
.
_stack
)
{
let
stack
;
stack
=
document
.
createXULElement
(
this
.
protonInfobarsEnabled
?
"
vbox
"
:
"
legacy
-
stack
"
)
;
stack
.
_notificationBox
=
this
;
stack
.
className
=
"
notificationbox
-
stack
"
;
if
(
!
this
.
protonInfobarsEnabled
)
{
stack
.
appendChild
(
document
.
createXULElement
(
"
spacer
"
)
)
;
}
stack
.
addEventListener
(
"
transitionend
"
event
=
>
{
if
(
(
event
.
target
.
localName
=
=
"
notification
"
|
|
event
.
target
.
localName
=
=
"
notification
-
message
"
)
&
&
event
.
propertyName
=
=
"
margin
-
top
"
)
{
this
.
_finishAnimation
(
)
;
}
}
)
;
this
.
_stack
=
stack
;
this
.
_insertElementFn
(
stack
)
;
}
return
this
.
_stack
;
}
get
_allowAnimation
(
)
{
return
window
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
:
no
-
preference
)
"
)
.
matches
;
}
get
allNotifications
(
)
{
if
(
!
this
.
_stack
)
{
return
[
]
;
}
var
closedNotification
=
this
.
_closedNotification
;
var
notifications
=
[
.
.
.
this
.
stack
.
getElementsByTagName
(
"
notification
"
)
.
.
.
this
.
stack
.
getElementsByTagName
(
"
notification
-
message
"
)
]
;
return
notifications
.
filter
(
n
=
>
n
!
=
closedNotification
)
;
}
getNotificationWithValue
(
aValue
)
{
var
notifications
=
this
.
allNotifications
;
for
(
var
n
=
notifications
.
length
-
1
;
n
>
=
0
;
n
-
-
)
{
if
(
aValue
=
=
notifications
[
n
]
.
getAttribute
(
"
value
"
)
)
{
return
notifications
[
n
]
;
}
}
return
null
;
}
appendNotification
(
aLabel
aValue
aImage
aPriority
aButtons
aEventCallback
aNotificationIs
aFtlFilePaths
)
{
if
(
aPriority
<
this
.
PRIORITY_SYSTEM
|
|
aPriority
>
this
.
PRIORITY_CRITICAL_HIGH
)
{
throw
new
Error
(
"
Invalid
notification
priority
"
+
aPriority
)
;
}
var
notifications
=
this
.
allNotifications
;
var
insertPos
=
null
;
for
(
var
n
=
notifications
.
length
-
1
;
n
>
=
0
;
n
-
-
)
{
if
(
notifications
[
n
]
.
priority
<
aPriority
)
{
break
;
}
insertPos
=
notifications
[
n
]
;
}
MozXULElement
.
insertFTLIfNeeded
(
"
toolkit
/
global
/
notification
.
ftl
"
)
;
var
newitem
;
if
(
this
.
protonInfobarsEnabled
&
&
!
aNotificationIs
)
{
if
(
!
customElements
.
get
(
"
notification
-
message
"
)
)
{
createNotificationMessageElement
(
)
;
}
newitem
=
document
.
createElement
(
"
notification
-
message
"
)
;
newitem
.
setAttribute
(
"
message
-
bar
-
type
"
"
infobar
"
)
;
if
(
aFtlFilePaths
)
{
newitem
.
addFtl
(
aFtlFilePaths
)
;
}
}
else
{
newitem
=
document
.
createXULElement
(
"
notification
"
aNotificationIs
?
{
is
:
aNotificationIs
}
:
{
}
)
;
}
this
.
stack
.
insertBefore
(
newitem
insertPos
)
;
if
(
newitem
.
messageText
)
{
if
(
aLabel
&
&
typeof
aLabel
=
=
"
object
"
&
&
aLabel
.
nodeType
&
&
aLabel
.
nodeType
=
=
aLabel
.
DOCUMENT_FRAGMENT_NODE
)
{
newitem
.
messageText
.
appendChild
(
aLabel
)
;
}
else
{
newitem
.
messageText
.
textContent
=
aLabel
;
}
}
newitem
.
setAttribute
(
"
value
"
aValue
)
;
if
(
aImage
&
&
!
this
.
protonInfobarsEnabled
)
{
newitem
.
messageImage
.
setAttribute
(
"
src
"
aImage
)
;
}
newitem
.
eventCallback
=
aEventCallback
;
if
(
aButtons
)
{
newitem
.
setButtons
(
aButtons
)
;
}
newitem
.
priority
=
aPriority
;
if
(
aPriority
=
=
this
.
PRIORITY_SYSTEM
)
{
newitem
.
setAttribute
(
"
type
"
"
system
"
)
;
}
else
if
(
aPriority
>
=
this
.
PRIORITY_CRITICAL_LOW
)
{
newitem
.
setAttribute
(
"
type
"
"
critical
"
)
;
}
else
if
(
aPriority
<
=
this
.
PRIORITY_INFO_HIGH
)
{
newitem
.
setAttribute
(
"
type
"
"
info
"
)
;
}
else
{
newitem
.
setAttribute
(
"
type
"
"
warning
"
)
;
}
if
(
!
insertPos
)
{
newitem
.
style
.
display
=
"
block
"
;
newitem
.
style
.
position
=
"
fixed
"
;
newitem
.
style
.
top
=
"
100
%
"
;
newitem
.
style
.
marginTop
=
"
-
15px
"
;
newitem
.
style
.
opacity
=
"
0
"
;
this
.
_showNotification
(
newitem
true
)
;
}
var
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
"
AlertActive
"
true
true
)
;
newitem
.
dispatchEvent
(
event
)
;
return
newitem
;
}
removeNotification
(
aItem
aSkipAnimation
)
{
if
(
!
aItem
.
parentNode
)
{
return
;
}
if
(
this
.
protonInfobarsEnabled
)
{
this
.
currentNotification
=
aItem
;
this
.
removeCurrentNotification
(
aSkipAnimation
)
;
}
else
if
(
aItem
=
=
this
.
currentNotification
)
{
this
.
removeCurrentNotification
(
aSkipAnimation
)
;
}
else
if
(
aItem
!
=
this
.
_closedNotification
)
{
this
.
_removeNotificationElement
(
aItem
)
;
}
}
_removeNotificationElement
(
aChild
)
{
if
(
aChild
.
eventCallback
)
{
aChild
.
eventCallback
(
"
removed
"
)
;
}
aChild
.
remove
(
)
;
if
(
!
Services
.
focus
.
getFocusedElementForWindow
(
window
false
{
}
)
)
{
Services
.
focus
.
moveFocus
(
window
this
.
stack
Services
.
focus
.
MOVEFOCUS_FORWARD
0
)
;
}
}
removeCurrentNotification
(
aSkipAnimation
)
{
this
.
_showNotification
(
this
.
currentNotification
false
aSkipAnimation
)
;
}
removeAllNotifications
(
aImmediate
)
{
var
notifications
=
this
.
allNotifications
;
for
(
var
n
=
notifications
.
length
-
1
;
n
>
=
0
;
n
-
-
)
{
if
(
aImmediate
)
{
this
.
_removeNotificationElement
(
notifications
[
n
]
)
;
}
else
{
this
.
removeNotification
(
notifications
[
n
]
)
;
}
}
this
.
currentNotification
=
null
;
if
(
aImmediate
|
|
!
this
.
_allowAnimation
)
{
this
.
_finishAnimation
(
)
;
}
}
removeTransientNotifications
(
)
{
var
notifications
=
this
.
allNotifications
;
for
(
var
n
=
notifications
.
length
-
1
;
n
>
=
0
;
n
-
-
)
{
var
notification
=
notifications
[
n
]
;
if
(
notification
.
persistence
)
{
notification
.
persistence
-
-
;
}
else
if
(
Date
.
now
(
)
>
notification
.
timeout
)
{
this
.
removeNotification
(
notification
true
)
;
}
}
}
_showNotification
(
aNotification
aSlideIn
aSkipAnimation
)
{
this
.
_finishAnimation
(
)
;
let
{
marginTop
marginBottom
}
=
getComputedStyle
(
aNotification
)
;
let
baseHeight
=
aNotification
.
getBoundingClientRect
(
)
.
height
;
var
height
=
baseHeight
+
parseInt
(
marginTop
10
)
+
parseInt
(
marginBottom
10
)
;
var
skipAnimation
=
aSkipAnimation
|
|
baseHeight
=
=
0
|
|
!
this
.
_allowAnimation
;
aNotification
.
classList
.
toggle
(
"
animated
"
!
skipAnimation
)
;
if
(
aSlideIn
)
{
this
.
currentNotification
=
aNotification
;
aNotification
.
style
.
removeProperty
(
"
display
"
)
;
aNotification
.
style
.
removeProperty
(
"
position
"
)
;
aNotification
.
style
.
removeProperty
(
"
top
"
)
;
aNotification
.
style
.
removeProperty
(
"
margin
-
top
"
)
;
aNotification
.
style
.
removeProperty
(
"
opacity
"
)
;
if
(
skipAnimation
)
{
return
;
}
}
else
{
this
.
_closedNotification
=
aNotification
;
var
notifications
=
this
.
allNotifications
;
var
idx
=
notifications
.
length
-
1
;
this
.
currentNotification
=
idx
>
=
0
?
notifications
[
idx
]
:
null
;
if
(
skipAnimation
)
{
this
.
_removeNotificationElement
(
this
.
_closedNotification
)
;
delete
this
.
_closedNotification
;
return
;
}
aNotification
.
style
.
marginTop
=
-
height
+
"
px
"
;
aNotification
.
style
.
opacity
=
0
;
}
this
.
_animating
=
true
;
}
_finishAnimation
(
)
{
if
(
this
.
_animating
)
{
this
.
_animating
=
false
;
if
(
this
.
_closedNotification
)
{
this
.
_removeNotificationElement
(
this
.
_closedNotification
)
;
delete
this
.
_closedNotification
;
}
}
}
get
protonInfobarsEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
proton
.
infobars
.
enabled
"
false
)
;
}
}
;
Object
.
assign
(
MozElements
.
NotificationBox
.
prototype
{
PRIORITY_SYSTEM
:
0
PRIORITY_INFO_LOW
:
1
PRIORITY_INFO_MEDIUM
:
2
PRIORITY_INFO_HIGH
:
3
PRIORITY_WARNING_LOW
:
4
PRIORITY_WARNING_MEDIUM
:
5
PRIORITY_WARNING_HIGH
:
6
PRIORITY_CRITICAL_LOW
:
7
PRIORITY_CRITICAL_MEDIUM
:
8
PRIORITY_CRITICAL_HIGH
:
9
}
)
;
MozElements
.
Notification
=
class
Notification
extends
MozXULElement
{
static
get
markup
(
)
{
return
<
hbox
class
=
"
messageDetails
"
align
=
"
center
"
flex
=
"
1
"
oncommand
=
"
this
.
parentNode
.
_doButtonCommand
(
event
)
;
"
>
<
image
class
=
"
messageImage
"
/
>
<
description
class
=
"
messageText
"
flex
=
"
1
"
/
>
<
spacer
flex
=
"
1
"
/
>
<
/
hbox
>
<
toolbarbutton
ondblclick
=
"
event
.
stopPropagation
(
)
;
"
class
=
"
messageCloseButton
close
-
icon
tabbable
"
tooltiptext
=
"
&
closeNotification
.
tooltip
;
"
oncommand
=
"
this
.
parentNode
.
dismiss
(
)
;
"
/
>
;
}
static
get
entities
(
)
{
return
[
"
chrome
:
/
/
global
/
locale
/
notification
.
dtd
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
persistence
=
0
;
this
.
priority
=
0
;
this
.
timeout
=
0
;
}
connectedCallback
(
)
{
this
.
appendChild
(
this
.
constructor
.
fragment
)
;
for
(
let
[
propertyName
selector
]
of
[
[
"
messageDetails
"
"
.
messageDetails
"
]
[
"
messageImage
"
"
.
messageImage
"
]
[
"
messageText
"
"
.
messageText
"
]
[
"
spacer
"
"
spacer
"
]
[
"
buttonContainer
"
"
.
messageDetails
"
]
[
"
closeButton
"
"
.
messageCloseButton
"
]
]
)
{
this
[
propertyName
]
=
this
.
querySelector
(
selector
)
;
}
}
disconnectedCallback
(
)
{
if
(
this
.
eventCallback
)
{
this
.
eventCallback
(
"
disconnected
"
)
;
}
}
setButtons
(
aButtons
)
{
for
(
let
button
of
aButtons
)
{
let
buttonElem
;
let
link
=
button
.
link
;
let
localeId
=
button
[
"
l10n
-
id
"
]
;
if
(
!
link
&
&
button
.
supportPage
)
{
link
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
button
.
supportPage
;
if
(
!
button
.
label
&
&
!
localeId
)
{
localeId
=
"
notification
-
learnmore
-
default
-
label
"
;
}
}
if
(
link
)
{
buttonElem
=
document
.
createXULElement
(
"
label
"
{
is
:
"
text
-
link
"
}
)
;
buttonElem
.
setAttribute
(
"
href
"
link
)
;
buttonElem
.
classList
.
add
(
"
notification
-
link
"
)
;
}
else
{
buttonElem
=
document
.
createXULElement
(
"
button
"
button
.
is
?
{
is
:
button
.
is
}
:
{
}
)
;
buttonElem
.
classList
.
add
(
"
notification
-
button
"
)
;
if
(
button
.
primary
)
{
buttonElem
.
classList
.
add
(
"
primary
"
)
;
}
}
if
(
localeId
)
{
buttonElem
.
setAttribute
(
"
data
-
l10n
-
id
"
localeId
)
;
}
else
{
buttonElem
.
setAttribute
(
link
?
"
value
"
:
"
label
"
button
.
label
)
;
if
(
typeof
button
.
accessKey
=
=
"
string
"
)
{
buttonElem
.
setAttribute
(
"
accesskey
"
button
.
accessKey
)
;
}
}
if
(
link
)
{
this
.
messageText
.
appendChild
(
buttonElem
)
;
}
else
{
this
.
messageDetails
.
appendChild
(
buttonElem
)
;
}
buttonElem
.
buttonInfo
=
button
;
}
}
get
control
(
)
{
return
this
.
closest
(
"
.
notificationbox
-
stack
"
)
.
_notificationBox
;
}
set
label
(
value
)
{
this
.
messageText
.
textContent
=
value
;
}
dismiss
(
)
{
if
(
this
.
eventCallback
)
{
this
.
eventCallback
(
"
dismissed
"
)
;
}
this
.
close
(
)
;
}
close
(
)
{
if
(
!
this
.
parentNode
)
{
return
;
}
this
.
control
.
removeNotification
(
this
)
;
}
_doButtonCommand
(
event
)
{
if
(
!
(
"
buttonInfo
"
in
event
.
target
)
)
{
return
;
}
var
button
=
event
.
target
.
buttonInfo
;
if
(
button
.
popup
)
{
document
.
getElementById
(
button
.
popup
)
.
openPopup
(
event
.
originalTarget
"
after_start
"
0
0
false
false
event
)
;
event
.
stopPropagation
(
)
;
}
else
{
var
callback
=
button
.
callback
;
if
(
callback
)
{
var
result
=
callback
(
this
button
event
.
target
event
)
;
if
(
!
result
)
{
this
.
close
(
)
;
}
event
.
stopPropagation
(
)
;
}
}
}
get
protonInfobarsEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
browser
.
proton
.
infobars
.
enabled
"
false
)
;
}
}
;
customElements
.
define
(
"
notification
"
MozElements
.
Notification
)
;
function
createNotificationMessageElement
(
)
{
class
NotificationMessage
extends
document
.
createElement
(
"
message
-
bar
"
)
.
constructor
{
constructor
(
)
{
super
(
)
;
this
.
persistence
=
0
;
this
.
priority
=
0
;
this
.
timeout
=
0
;
}
connectedCallback
(
)
{
this
.
toggleAttribute
(
"
dismissable
"
true
)
;
this
.
closeButton
.
classList
.
add
(
"
notification
-
close
"
)
;
this
.
shadowRoot
.
querySelector
(
"
.
container
"
)
.
classList
.
add
(
"
infobar
"
)
;
let
messageContent
=
this
.
shadowRoot
.
querySelector
(
"
.
content
"
)
;
messageContent
.
classList
.
add
(
"
notification
-
content
"
)
;
messageContent
.
textContent
=
"
"
;
this
.
messageText
=
document
.
createElement
(
"
span
"
)
;
this
.
messageText
.
classList
.
add
(
"
notification
-
message
"
)
;
this
.
buttonContainer
=
document
.
createElement
(
"
span
"
)
;
this
.
buttonContainer
.
classList
.
add
(
"
notification
-
button
-
container
"
)
;
this
.
messageImage
=
this
.
shadowRoot
.
querySelector
(
"
.
icon
"
)
;
messageContent
.
append
(
this
.
messageText
this
.
buttonContainer
)
;
this
.
shadowRoot
.
addEventListener
(
"
click
"
this
)
;
}
disconnectedCallback
(
)
{
if
(
this
.
eventCallback
)
{
this
.
eventCallback
(
"
disconnected
"
)
;
}
}
close
(
)
{
if
(
!
this
.
parentNode
)
{
return
;
}
this
.
closest
(
"
.
notificationbox
-
stack
"
)
.
_notificationBox
.
removeNotification
(
this
)
;
}
addFtl
(
filepaths
)
{
for
(
let
filepath
of
filepaths
)
{
let
link
=
document
.
createElement
(
"
link
"
)
;
link
.
setAttribute
(
"
rel
"
"
localization
"
)
;
link
.
href
=
filepath
;
this
.
shadowRoot
.
append
(
link
)
;
}
document
.
l10n
.
connectRoot
(
this
.
shadowRoot
)
;
}
_insertNotificationFtl
(
)
{
if
(
!
this
.
_insertedNotificationFtl
)
{
this
.
_insertedNotificationFtl
=
true
;
this
.
addFtl
(
[
"
toolkit
/
global
/
notification
.
ftl
"
]
)
;
}
}
handleEvent
(
e
)
{
if
(
"
buttonInfo
"
in
e
.
target
)
{
let
{
buttonInfo
}
=
e
.
target
;
let
{
callback
popup
}
=
buttonInfo
;
if
(
popup
)
{
document
.
getElementById
(
popup
)
.
openPopup
(
e
.
originalTarget
"
after_start
"
0
0
false
false
e
)
;
e
.
stopPropagation
(
)
;
}
else
if
(
callback
)
{
if
(
!
callback
(
this
buttonInfo
e
.
target
e
)
)
{
this
.
close
(
)
;
}
e
.
stopPropagation
(
)
;
}
}
}
set
label
(
value
)
{
this
.
messageText
.
textContent
=
value
;
}
setButtons
(
buttons
)
{
this
.
_buttons
=
buttons
;
for
(
let
button
of
buttons
)
{
let
link
=
button
.
link
;
let
localeId
=
button
[
"
l10n
-
id
"
]
;
if
(
!
link
&
&
button
.
supportPage
)
{
link
=
Services
.
urlFormatter
.
formatURLPref
(
"
app
.
support
.
baseURL
"
)
+
button
.
supportPage
;
if
(
!
button
.
label
&
&
!
localeId
)
{
localeId
=
"
notification
-
learnmore
-
default
-
label
"
;
}
this
.
_insertNotificationFtl
(
)
;
}
let
buttonElem
;
if
(
link
)
{
buttonElem
=
document
.
createXULElement
(
"
label
"
{
is
:
"
text
-
link
"
}
)
;
buttonElem
.
setAttribute
(
"
href
"
link
)
;
buttonElem
.
classList
.
add
(
"
notification
-
link
"
)
;
}
else
{
buttonElem
=
document
.
createXULElement
(
"
button
"
button
.
is
?
{
is
:
button
.
is
}
:
{
}
)
;
buttonElem
.
classList
.
add
(
"
notification
-
button
"
"
small
"
)
;
if
(
button
.
primary
)
{
buttonElem
.
classList
.
add
(
"
primary
"
)
;
}
}
if
(
localeId
)
{
document
.
l10n
.
setAttributes
(
buttonElem
localeId
)
;
}
else
{
buttonElem
.
setAttribute
(
link
?
"
value
"
:
"
label
"
button
.
label
)
;
if
(
typeof
button
.
accessKey
=
=
"
string
"
)
{
buttonElem
.
setAttribute
(
"
accesskey
"
button
.
accessKey
)
;
}
}
if
(
link
)
{
this
.
messageText
.
append
(
new
Text
(
"
"
)
buttonElem
)
;
}
else
{
this
.
buttonContainer
.
appendChild
(
buttonElem
)
;
}
buttonElem
.
buttonInfo
=
button
;
}
}
dismiss
(
)
{
if
(
this
.
eventCallback
)
{
this
.
eventCallback
(
"
dismissed
"
)
;
}
super
.
dismiss
(
)
;
}
}
customElements
.
define
(
"
notification
-
message
"
NotificationMessage
)
;
}
}
