"
use
strict
"
;
function
Calendar
(
options
context
)
{
this
.
context
=
context
;
this
.
context
.
DAYS_IN_A_WEEK
=
7
;
this
.
state
=
{
days
:
[
]
weekHeaders
:
[
]
setSelection
:
options
.
setSelection
setMonthByOffset
:
options
.
setMonthByOffset
getDayString
:
options
.
getDayString
getWeekHeaderString
:
options
.
getWeekHeaderString
}
;
this
.
elements
=
{
weekHeaders
:
this
.
_generateNodes
(
this
.
context
.
DAYS_IN_A_WEEK
context
.
weekHeader
)
daysView
:
this
.
_generateNodes
(
options
.
calViewSize
context
.
daysView
)
}
;
this
.
_attachEventListeners
(
)
;
}
Calendar
.
prototype
=
{
setProps
(
props
)
{
if
(
props
.
isVisible
)
{
const
days
=
props
.
days
.
map
(
(
{
dateObj
content
classNames
enabled
}
)
=
>
{
return
{
dateObj
textContent
:
this
.
state
.
getDayString
(
content
)
className
:
classNames
.
join
(
"
"
)
enabled
}
;
}
)
;
const
weekHeaders
=
props
.
weekHeaders
.
map
(
(
{
content
classNames
}
)
=
>
{
return
{
textContent
:
this
.
state
.
getWeekHeaderString
(
content
)
className
:
classNames
.
join
(
"
"
)
}
;
}
)
;
this
.
_render
(
{
elements
:
this
.
elements
.
daysView
items
:
days
prevState
:
this
.
state
.
days
}
)
;
this
.
_render
(
{
elements
:
this
.
elements
.
weekHeaders
items
:
weekHeaders
prevState
:
this
.
state
.
weekHeaders
}
)
;
this
.
state
.
days
=
days
;
this
.
state
.
weekHeaders
=
weekHeaders
;
}
}
_render
(
{
elements
items
prevState
}
)
{
let
selectedEl
;
let
todayEl
;
let
firstDayEl
;
for
(
let
i
=
0
l
=
items
.
length
;
i
<
l
;
i
+
+
)
{
let
el
=
elements
[
i
]
;
if
(
!
prevState
[
i
]
|
|
prevState
[
i
]
.
textContent
!
=
items
[
i
]
.
textContent
)
{
el
.
textContent
=
items
[
i
]
.
textContent
;
}
if
(
!
prevState
[
i
]
|
|
prevState
[
i
]
.
className
!
=
items
[
i
]
.
className
)
{
el
.
className
=
items
[
i
]
.
className
;
}
if
(
el
.
tagName
=
=
=
"
td
"
)
{
el
.
setAttribute
(
"
role
"
"
gridcell
"
)
;
el
.
removeAttribute
(
"
tabindex
"
)
;
el
.
removeAttribute
(
"
aria
-
disabled
"
)
;
el
.
removeAttribute
(
"
aria
-
selected
"
)
;
el
.
removeAttribute
(
"
aria
-
current
"
)
;
if
(
el
.
classList
.
contains
(
"
today
"
)
)
{
el
.
setAttribute
(
"
aria
-
current
"
"
date
"
)
;
todayEl
=
el
;
}
if
(
el
.
classList
.
contains
(
"
selection
"
)
)
{
el
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
if
(
!
el
.
classList
.
contains
(
"
outside
"
)
)
{
selectedEl
=
el
;
}
}
else
if
(
el
.
classList
.
contains
(
"
out
-
of
-
range
"
)
)
{
el
.
setAttribute
(
"
aria
-
disabled
"
"
true
"
)
;
el
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
else
{
el
.
setAttribute
(
"
aria
-
selected
"
"
false
"
)
;
}
if
(
el
.
textContent
=
=
=
"
1
"
&
&
!
firstDayEl
)
{
let
firstDay
=
new
Date
(
items
[
i
]
.
dateObj
)
;
firstDay
.
setUTCDate
(
"
1
"
)
;
if
(
this
.
_isSameDay
(
items
[
i
]
.
dateObj
firstDay
)
)
{
firstDayEl
=
el
;
}
}
}
}
if
(
selectedEl
)
{
selectedEl
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
}
else
if
(
todayEl
)
{
todayEl
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
}
else
if
(
firstDayEl
)
{
firstDayEl
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
}
}
_generateNodes
(
size
context
)
{
let
frag
=
document
.
createDocumentFragment
(
)
;
let
refs
=
[
]
;
let
rowEl
=
document
.
createElement
(
"
tr
"
)
;
for
(
let
i
=
0
;
i
<
size
;
i
+
+
)
{
let
el
;
if
(
context
.
classList
.
contains
(
"
week
-
header
"
)
)
{
el
=
document
.
createElement
(
"
th
"
)
;
el
.
setAttribute
(
"
scope
"
"
col
"
)
;
el
.
setAttribute
(
"
role
"
"
columnheader
"
)
;
}
else
{
el
=
document
.
createElement
(
"
td
"
)
;
}
el
.
dataset
.
id
=
i
;
refs
.
push
(
el
)
;
rowEl
.
appendChild
(
el
)
;
if
(
(
i
+
1
)
%
this
.
context
.
DAYS_IN_A_WEEK
=
=
=
0
)
{
frag
.
appendChild
(
rowEl
)
;
rowEl
=
document
.
createElement
(
"
tr
"
)
;
}
}
context
.
appendChild
(
frag
)
;
return
refs
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
click
"
:
{
if
(
this
.
context
.
daysView
.
contains
(
event
.
target
)
)
{
let
targetId
=
event
.
target
.
dataset
.
id
;
let
targetObj
=
this
.
state
.
days
[
targetId
]
;
if
(
targetObj
.
enabled
)
{
this
.
state
.
setSelection
(
targetObj
.
dateObj
)
;
}
}
break
;
}
case
"
keydown
"
:
{
if
(
this
.
context
.
daysView
.
contains
(
event
.
target
)
)
{
const
direction
=
Services
.
locale
.
isAppLocaleRTL
?
-
1
:
1
;
switch
(
event
.
key
)
{
case
"
Enter
"
:
case
"
"
:
{
let
targetId
=
event
.
target
.
dataset
.
id
;
let
targetObj
=
this
.
state
.
days
[
targetId
]
;
if
(
targetObj
.
enabled
)
{
this
.
state
.
setSelection
(
targetObj
.
dateObj
)
;
}
break
;
}
case
"
ArrowRight
"
:
{
this
.
_handleKeydownEvent
(
event
.
target
1
*
direction
)
;
break
;
}
case
"
ArrowLeft
"
:
{
this
.
_handleKeydownEvent
(
event
.
target
-
1
*
direction
)
;
break
;
}
case
"
ArrowUp
"
:
{
this
.
_handleKeydownEvent
(
event
.
target
-
1
this
.
context
.
DAYS_IN_A_WEEK
)
;
break
;
}
case
"
ArrowDown
"
:
{
this
.
_handleKeydownEvent
(
event
.
target
1
this
.
context
.
DAYS_IN_A_WEEK
)
;
break
;
}
case
"
Home
"
:
{
let
nextId
;
if
(
event
.
ctrlKey
)
{
for
(
let
i
=
0
;
i
<
this
.
state
.
days
.
length
;
i
+
+
)
{
if
(
this
.
state
.
days
[
i
]
.
dateObj
.
getUTCDate
(
)
=
=
1
)
{
nextId
=
i
;
break
;
}
}
}
else
{
nextId
=
Number
(
event
.
target
.
dataset
.
id
)
-
(
Number
(
event
.
target
.
dataset
.
id
)
%
this
.
context
.
DAYS_IN_A_WEEK
)
;
nextId
=
this
.
_updateViewIfOutside
(
nextId
-
1
)
;
}
this
.
_updateKeyboardFocus
(
event
.
target
nextId
)
;
break
;
}
case
"
End
"
:
{
let
nextId
;
if
(
event
.
ctrlKey
)
{
for
(
let
i
=
this
.
state
.
days
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
this
.
state
.
days
[
i
]
.
dateObj
.
getUTCDate
(
)
=
=
1
)
{
nextId
=
i
-
1
;
break
;
}
}
}
else
{
nextId
=
Number
(
event
.
target
.
dataset
.
id
)
+
(
this
.
context
.
DAYS_IN_A_WEEK
-
1
)
-
(
Number
(
event
.
target
.
dataset
.
id
)
%
this
.
context
.
DAYS_IN_A_WEEK
)
;
nextId
=
this
.
_updateViewIfOutside
(
nextId
1
)
;
}
this
.
_updateKeyboardFocus
(
event
.
target
nextId
)
;
break
;
}
case
"
PageUp
"
:
{
let
targetId
=
event
.
target
.
dataset
.
id
;
let
nextDate
=
this
.
state
.
days
[
targetId
]
.
dateObj
;
if
(
event
.
shiftKey
)
{
this
.
state
.
setMonthByOffset
(
-
12
)
;
nextDate
.
setYear
(
nextDate
.
getFullYear
(
)
-
1
)
;
}
else
{
this
.
state
.
setMonthByOffset
(
-
1
)
;
nextDate
.
setMonth
(
nextDate
.
getMonth
(
)
-
1
)
;
}
let
nextId
=
this
.
_calculateNextId
(
nextDate
)
;
nextId
=
this
.
_updateViewIfOutside
(
nextId
1
)
;
this
.
_updateKeyboardFocus
(
event
.
target
nextId
)
;
break
;
}
case
"
PageDown
"
:
{
let
targetId
=
event
.
target
.
dataset
.
id
;
let
nextDate
=
this
.
state
.
days
[
targetId
]
.
dateObj
;
if
(
event
.
shiftKey
)
{
this
.
state
.
setMonthByOffset
(
12
)
;
nextDate
.
setYear
(
nextDate
.
getFullYear
(
)
+
1
)
;
}
else
{
this
.
state
.
setMonthByOffset
(
1
)
;
nextDate
.
setMonth
(
nextDate
.
getMonth
(
)
+
1
)
;
}
let
nextId
=
this
.
_calculateNextId
(
nextDate
)
;
nextId
=
this
.
_updateViewIfOutside
(
nextId
1
)
;
this
.
_updateKeyboardFocus
(
event
.
target
nextId
)
;
break
;
}
}
}
break
;
}
}
}
_attachEventListeners
(
)
{
this
.
context
.
daysView
.
addEventListener
(
"
click
"
this
)
;
this
.
context
.
daysView
.
addEventListener
(
"
keydown
"
this
)
;
}
_calculateNextId
(
nextDate
)
{
for
(
let
i
=
0
;
i
<
this
.
state
.
days
.
length
;
i
+
+
)
{
if
(
this
.
_isSameDay
(
this
.
state
.
days
[
i
]
.
dateObj
nextDate
)
)
{
return
i
;
}
}
return
null
;
}
_isSameDay
(
dateObj1
dateObj2
)
{
return
(
dateObj1
.
getUTCFullYear
(
)
=
=
dateObj2
.
getUTCFullYear
(
)
&
&
dateObj1
.
getUTCMonth
(
)
=
=
dateObj2
.
getUTCMonth
(
)
&
&
dateObj1
.
getUTCDate
(
)
=
=
dateObj2
.
getUTCDate
(
)
)
;
}
_handleKeydownEvent
(
eTarget
offsetDir
offsetSize
=
1
)
{
let
offset
=
offsetDir
*
offsetSize
;
let
nextId
=
Number
(
eTarget
.
dataset
.
id
)
+
offset
;
if
(
!
this
.
state
.
days
[
nextId
]
)
{
nextId
=
this
.
_updateViewIfUndefined
(
nextId
offset
eTarget
.
dataset
.
id
)
;
}
nextId
=
this
.
_updateViewIfOutside
(
nextId
offsetDir
)
;
this
.
_updateKeyboardFocus
(
eTarget
nextId
)
;
}
_updateKeyboardFocus
(
targetEl
nextId
)
{
const
nextEl
=
this
.
elements
.
daysView
[
nextId
]
;
targetEl
.
removeAttribute
(
"
tabindex
"
)
;
nextEl
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
nextEl
.
focus
(
)
;
}
_updateViewIfOutside
(
nextId
offset
)
{
if
(
this
.
elements
.
daysView
[
nextId
]
.
classList
.
contains
(
"
outside
"
)
)
{
let
nextDate
=
this
.
state
.
days
[
nextId
]
.
dateObj
;
this
.
state
.
setMonthByOffset
(
offset
)
;
nextId
=
this
.
_calculateNextId
(
nextDate
)
;
}
return
nextId
;
}
_updateViewIfUndefined
(
nextId
offset
targetId
)
{
let
targetDate
=
this
.
state
.
days
[
targetId
]
.
dateObj
;
let
nextDate
=
targetDate
;
nextDate
.
setDate
(
targetDate
.
getDate
(
)
+
offset
)
;
this
.
state
.
setMonthByOffset
(
Math
.
sign
(
offset
)
)
;
nextId
=
this
.
_calculateNextId
(
nextDate
)
;
return
nextId
;
}
focus
(
)
{
const
focus
=
this
.
context
.
daysView
.
querySelector
(
'
[
tabindex
=
"
0
"
]
'
)
;
if
(
focus
)
{
focus
.
focus
(
)
;
}
}
}
;
