"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
async
function
promiseFindFinished
(
gBrowser
searchText
highlightOn
=
false
)
{
let
findbar
=
await
gBrowser
.
getFindBar
(
)
;
findbar
.
startFind
(
findbar
.
FIND_NORMAL
)
;
let
highlightElement
=
findbar
.
getElement
(
"
highlight
"
)
;
if
(
highlightElement
.
checked
!
=
highlightOn
)
{
highlightElement
.
click
(
)
;
}
return
new
Promise
(
resolve
=
>
{
executeSoon
(
(
)
=
>
{
findbar
.
_findField
.
value
=
searchText
;
let
resultListener
;
let
waitMore
=
highlightOn
;
let
findTimeout
=
setTimeout
(
(
)
=
>
foundOrTimedout
(
null
)
5000
)
;
let
foundOrTimedout
=
function
(
aData
)
{
if
(
aData
!
=
=
null
&
&
waitMore
)
{
waitMore
=
false
;
return
;
}
if
(
aData
=
=
=
null
)
{
info
(
"
Result
listener
not
called
timeout
reached
.
"
)
;
}
clearTimeout
(
findTimeout
)
;
findbar
.
browser
?
.
finder
.
removeResultListener
(
resultListener
)
;
resolve
(
)
;
}
;
resultListener
=
{
onFindResult
:
foundOrTimedout
onCurrentSelection
(
)
{
}
onMatchesCountResult
(
)
{
}
onHighlightFinished
(
)
{
}
}
;
findbar
.
browser
.
finder
.
addResultListener
(
resultListener
)
;
findbar
.
_find
(
)
;
}
)
;
}
)
;
}
function
closeFindbarAndWait
(
findbar
)
{
return
new
Promise
(
resolve
=
>
{
if
(
findbar
.
hidden
)
{
resolve
(
)
;
return
;
}
findbar
.
addEventListener
(
"
transitionend
"
function
cont
(
aEvent
)
{
if
(
aEvent
.
propertyName
!
=
"
visibility
"
)
{
return
;
}
findbar
.
removeEventListener
(
"
transitionend
"
cont
)
;
resolve
(
)
;
}
)
;
let
close
=
findbar
.
getElement
(
"
find
-
closebutton
"
)
;
close
.
doCommand
(
)
;
}
)
;
}
function
pushPrefs
(
.
.
.
aPrefs
)
{
return
new
Promise
(
resolve
=
>
{
SpecialPowers
.
pushPrefEnv
(
{
set
:
aPrefs
}
resolve
)
;
}
)
;
}
async
function
waitForTabBlockEvent
(
tab
expectBlocked
)
{
if
(
tab
.
activeMediaBlocked
=
=
expectBlocked
)
{
ok
(
true
"
The
tab
should
"
+
(
expectBlocked
?
"
"
:
"
not
"
)
+
"
be
blocked
"
)
;
}
else
{
info
(
"
Block
state
doens
'
t
match
wait
for
attributes
changes
.
"
)
;
await
BrowserTestUtils
.
waitForEvent
(
tab
"
TabAttrModified
"
false
event
=
>
{
if
(
event
.
detail
.
changed
.
includes
(
"
activemedia
-
blocked
"
)
)
{
is
(
tab
.
activeMediaBlocked
expectBlocked
"
The
tab
should
"
+
(
expectBlocked
?
"
"
:
"
not
"
)
+
"
be
blocked
"
)
;
return
true
;
}
return
false
;
}
)
;
}
}
async
function
waitForTabPlayingEvent
(
tab
expectPlaying
)
{
if
(
tab
.
soundPlaying
=
=
expectPlaying
)
{
ok
(
true
"
The
tab
should
"
+
(
expectPlaying
?
"
"
:
"
not
"
)
+
"
be
playing
"
)
;
}
else
{
info
(
"
Playing
state
doesn
'
t
match
wait
for
attributes
changes
.
"
)
;
await
BrowserTestUtils
.
waitForEvent
(
tab
"
TabAttrModified
"
false
event
=
>
{
if
(
event
.
detail
.
changed
.
includes
(
"
soundplaying
"
)
)
{
is
(
tab
.
soundPlaying
expectPlaying
"
The
tab
should
"
+
(
expectPlaying
?
"
"
:
"
not
"
)
+
"
be
playing
"
)
;
return
true
;
}
return
false
;
}
)
;
}
}
function
disable_non_test_mouse
(
disable
)
{
let
utils
=
window
.
windowUtils
;
utils
.
disableNonTestMouseEvents
(
disable
)
;
}
function
hover_icon
(
icon
tooltip
)
{
disable_non_test_mouse
(
true
)
;
let
popupShownPromise
=
BrowserTestUtils
.
waitForEvent
(
tooltip
"
popupshown
"
)
;
EventUtils
.
synthesizeMouse
(
icon
1
1
{
type
:
"
mouseover
"
}
)
;
EventUtils
.
synthesizeMouse
(
icon
2
2
{
type
:
"
mousemove
"
}
)
;
EventUtils
.
synthesizeMouse
(
icon
3
3
{
type
:
"
mousemove
"
}
)
;
EventUtils
.
synthesizeMouse
(
icon
4
4
{
type
:
"
mousemove
"
}
)
;
return
popupShownPromise
;
}
function
leave_icon
(
icon
)
{
EventUtils
.
synthesizeMouse
(
icon
0
0
{
type
:
"
mouseout
"
}
)
;
EventUtils
.
synthesizeMouseAtCenter
(
document
.
documentElement
{
type
:
"
mousemove
"
}
)
;
EventUtils
.
synthesizeMouseAtCenter
(
document
.
documentElement
{
type
:
"
mousemove
"
}
)
;
EventUtils
.
synthesizeMouseAtCenter
(
document
.
documentElement
{
type
:
"
mousemove
"
}
)
;
disable_non_test_mouse
(
false
)
;
}
class
DateTimeTestHelper
{
constructor
(
)
{
this
.
panel
=
gBrowser
.
_getAndMaybeCreateDateTimePickerPanel
(
)
;
this
.
panel
.
setAttribute
(
"
animate
"
false
)
;
this
.
tab
=
null
;
this
.
frame
=
null
;
}
async
openPicker
(
pageUrl
inFrame
openMethod
=
"
click
"
)
{
this
.
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
pageUrl
)
;
let
bc
=
gBrowser
.
selectedBrowser
;
if
(
inFrame
)
{
await
SpecialPowers
.
spawn
(
bc
[
]
async
function
(
)
{
const
iframe
=
content
.
document
.
querySelector
(
"
iframe
"
)
;
iframe
.
getBoundingClientRect
(
)
;
}
)
;
bc
=
bc
.
browsingContext
.
children
[
0
]
;
}
await
SpecialPowers
.
spawn
(
bc
[
]
async
function
(
)
{
await
SpecialPowers
.
contentTransformsReceived
(
content
)
;
}
)
;
if
(
openMethod
=
=
=
"
click
"
)
{
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
input
"
{
}
bc
)
;
}
else
if
(
openMethod
=
=
=
"
showPicker
"
)
{
await
SpecialPowers
.
spawn
(
bc
[
]
function
(
)
{
content
.
document
.
notifyUserGestureActivation
(
)
;
content
.
document
.
querySelector
(
"
input
"
)
.
showPicker
(
)
;
}
)
;
}
this
.
frame
=
this
.
panel
.
querySelector
(
"
#
dateTimePopupFrame
"
)
;
await
this
.
waitForPickerReady
(
)
;
}
promisePickerClosed
(
)
{
return
new
Promise
(
resolve
=
>
{
this
.
panel
.
addEventListener
(
"
popuphidden
"
resolve
{
once
:
true
}
)
;
}
)
;
}
promiseChange
(
selector
=
"
input
"
)
{
return
SpecialPowers
.
spawn
(
this
.
tab
.
linkedBrowser
[
selector
]
async
selector
=
>
{
let
input
=
content
.
document
.
querySelector
(
selector
)
;
await
ContentTaskUtils
.
waitForEvent
(
input
"
change
"
false
e
=
>
{
ok
(
content
.
window
.
windowUtils
.
isHandlingUserInput
"
isHandlingUserInput
should
be
true
"
)
;
return
true
;
}
)
;
}
)
;
}
async
waitForPickerReady
(
)
{
let
readyPromise
;
let
loadPromise
=
new
Promise
(
resolve
=
>
{
let
listener
=
(
)
=
>
{
if
(
this
.
frame
.
browsingContext
.
currentURI
.
spec
!
=
"
chrome
:
/
/
global
/
content
/
datepicker
.
xhtml
"
)
{
return
;
}
this
.
frame
.
removeEventListener
(
"
load
"
listener
{
capture
:
true
}
)
;
readyPromise
=
BrowserTestUtils
.
waitForEvent
(
this
.
frame
.
contentDocument
"
PickerReady
"
)
;
resolve
(
)
;
}
;
this
.
frame
.
addEventListener
(
"
load
"
listener
{
capture
:
true
}
)
;
}
)
;
await
loadPromise
;
await
readyPromise
;
}
getElement
(
selector
)
{
return
this
.
frame
.
contentDocument
.
querySelector
(
selector
)
;
}
getChildren
(
selector
)
{
return
Array
.
from
(
this
.
getElement
(
selector
)
.
children
)
;
}
click
(
element
)
{
EventUtils
.
synthesizeMouseAtCenter
(
element
{
}
this
.
frame
.
contentWindow
)
;
}
async
tearDown
(
)
{
if
(
this
.
panel
.
state
!
=
"
closed
"
)
{
let
pickerClosePromise
=
this
.
promisePickerClosed
(
)
;
this
.
panel
.
hidePopup
(
)
;
await
pickerClosePromise
;
}
BrowserTestUtils
.
removeTab
(
this
.
tab
)
;
this
.
tab
=
null
;
}
cleanup
(
)
{
this
.
frame
.
remove
(
)
;
this
.
frame
=
null
;
this
.
panel
.
removeAttribute
(
"
animate
"
)
;
this
.
panel
=
null
;
}
}
function
once
(
target
name
)
{
var
p
=
new
Promise
(
function
(
resolve
reject
)
{
target
.
addEventListener
(
name
function
(
)
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
return
p
;
}
async
function
waitForExpectedWakeLockState
(
topic
{
needLock
isForegroundLock
}
)
{
const
powerManagerService
=
Cc
[
"
mozilla
.
org
/
power
/
powermanagerservice
;
1
"
]
;
const
powerManager
=
powerManagerService
.
getService
(
Ci
.
nsIPowerManagerService
)
;
const
wakelockState
=
powerManager
.
getWakeLockState
(
topic
)
;
let
expectedLockState
=
"
unlocked
"
;
if
(
needLock
)
{
expectedLockState
=
isForegroundLock
?
"
locked
-
foreground
"
:
"
locked
-
background
"
;
}
if
(
wakelockState
!
=
expectedLockState
)
{
info
(
wait
until
wakelock
becomes
{
expectedLockState
}
)
;
await
wakeLockObserved
(
powerManager
topic
state
=
>
state
=
=
expectedLockState
)
;
}
is
(
powerManager
.
getWakeLockState
(
topic
)
expectedLockState
the
wakelock
state
for
'
{
topic
}
'
is
equal
to
'
{
expectedLockState
}
'
)
;
}
function
wakeLockObserved
(
powerManager
observeTopic
checkFn
)
{
return
new
Promise
(
resolve
=
>
{
function
wakeLockListener
(
)
{
}
wakeLockListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIDOMMozWakeLockListener
"
]
)
callback
(
topic
state
)
{
if
(
topic
=
=
observeTopic
&
&
checkFn
(
state
)
)
{
powerManager
.
removeWakeLockListener
(
wakeLockListener
.
prototype
)
;
resolve
(
)
;
}
}
}
;
powerManager
.
addWakeLockListener
(
wakeLockListener
.
prototype
)
;
}
)
;
}
function
getTestWebBasedURL
(
fileName
{
crossOrigin
=
false
}
=
{
}
)
{
const
origin
=
crossOrigin
?
"
http
:
/
/
example
.
org
"
:
"
http
:
/
/
example
.
com
"
;
return
(
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
origin
)
+
fileName
)
;
}
