add_task
(
async
function
startTestingWebAudioWithGUM
(
)
{
info
(
"
-
setup
test
preference
-
"
)
;
await
setupTestPreferences
(
)
;
info
(
"
-
test
web
audio
with
gUM
success
-
"
)
;
await
testWebAudioWithGUM
(
{
constraints
:
{
audio
:
true
}
shouldAllowStartingContext
:
true
}
)
;
await
testWebAudioWithGUM
(
{
constraints
:
{
video
:
true
}
shouldAllowStartingContext
:
true
}
)
;
await
testWebAudioWithGUM
(
{
constraints
:
{
video
:
true
audio
:
true
}
shouldAllowStartingContext
:
true
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
navigator
.
permission
.
force
"
true
]
]
}
)
.
then
(
async
function
(
)
{
info
(
"
-
test
web
audio
with
gUM
denied
-
"
)
;
await
testWebAudioWithGUM
(
{
constraints
:
{
video
:
true
}
shouldAllowStartingContext
:
false
}
)
;
await
testWebAudioWithGUM
(
{
constraints
:
{
audio
:
true
}
shouldAllowStartingContext
:
false
}
)
;
await
testWebAudioWithGUM
(
{
constraints
:
{
video
:
true
audio
:
true
}
shouldAllowStartingContext
:
false
}
)
;
}
)
;
}
)
;
function
setupTestPreferences
(
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
autoplay
.
default
"
SpecialPowers
.
Ci
.
nsIAutoplay
.
BLOCKED
]
[
"
media
.
autoplay
.
enabled
.
user
-
gestures
-
needed
"
true
]
[
"
media
.
autoplay
.
block
-
event
.
enabled
"
true
]
[
"
media
.
autoplay
.
block
-
webaudio
"
true
]
[
"
media
.
navigator
.
permission
.
fake
"
true
]
]
}
)
;
}
function
createAudioContext
(
)
{
content
.
ac
=
new
content
.
AudioContext
(
)
;
let
ac
=
content
.
ac
;
ac
.
resumePromises
=
[
]
;
ac
.
stateChangePromise
=
new
Promise
(
resolve
=
>
{
ac
.
addEventListener
(
"
statechange
"
function
(
)
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
ac
.
notAllowedToStart
=
new
Promise
(
resolve
=
>
{
ac
.
addEventListener
(
"
blocked
"
function
(
)
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
async
function
checkingAudioContextRunningState
(
)
{
let
ac
=
content
.
ac
;
await
ac
.
notAllowedToStart
;
ok
(
ac
.
state
=
=
=
"
suspended
"
AudioContext
is
not
started
yet
.
)
;
}
function
resumeWithoutExpectedSuccess
(
)
{
let
ac
=
content
.
ac
;
let
promise
=
ac
.
resume
(
)
;
ac
.
resumePromises
.
push
(
promise
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
content
.
setTimeout
(
(
)
=
>
{
if
(
ac
.
state
=
=
"
suspended
"
)
{
ok
(
true
"
audio
context
is
still
suspended
"
)
;
resolve
(
)
;
}
else
{
reject
(
"
audio
context
should
not
be
allowed
to
start
"
)
;
}
}
2000
)
;
}
)
;
}
function
resumeWithExpectedSuccess
(
)
{
let
ac
=
content
.
ac
;
ac
.
resumePromises
.
push
(
ac
.
resume
(
)
)
;
return
Promise
.
all
(
ac
.
resumePromises
)
.
then
(
(
)
=
>
{
ok
(
ac
.
state
=
=
"
running
"
"
audio
context
starts
running
"
)
;
}
)
;
}
function
callGUM
(
testParameters
)
{
info
(
"
-
calling
gum
with
"
+
JSON
.
stringify
(
testParameters
.
constraints
)
)
;
if
(
testParameters
.
shouldAllowStartingContext
)
{
testParameters
.
constraints
.
fake
=
true
;
return
content
.
navigator
.
mediaDevices
.
getUserMedia
(
testParameters
.
constraints
)
;
}
content
.
navigator
.
mediaDevices
.
getUserMedia
(
testParameters
.
constraints
)
;
return
Promise
.
resolve
(
)
;
}
async
function
testWebAudioWithGUM
(
testParameters
)
{
info
(
"
-
open
new
tab
-
"
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
window
.
gBrowser
"
https
:
/
/
example
.
com
"
)
;
info
(
"
-
create
audio
context
-
"
)
;
const
mm
=
tab
.
linkedBrowser
.
messageManager
;
mm
.
loadFrameScript
(
"
data
:
(
"
+
createAudioContext
.
toString
(
)
+
"
)
(
)
;
"
false
)
;
info
(
"
-
check
whether
audio
context
starts
running
-
"
)
;
try
{
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
checkingAudioContextRunningState
)
;
}
catch
(
error
)
{
ok
(
false
error
.
toString
(
)
)
;
}
try
{
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
testParameters
callGUM
)
;
}
catch
(
error
)
{
ok
(
false
error
.
toString
(
)
)
;
}
info
(
"
-
calling
resume
(
)
again
"
)
;
try
{
let
resumeFunc
=
testParameters
.
shouldAllowStartingContext
?
resumeWithExpectedSuccess
:
resumeWithoutExpectedSuccess
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
resumeFunc
)
;
}
catch
(
error
)
{
ok
(
false
error
.
toString
(
)
)
;
}
info
(
"
-
remove
tab
-
"
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
