"
use
strict
"
;
class
DateTimeTestHelper
{
constructor
(
)
{
this
.
panel
=
gBrowser
.
_getAndMaybeCreateDateTimePickerPanel
(
)
;
this
.
panel
.
setAttribute
(
"
animate
"
false
)
;
this
.
tab
=
null
;
this
.
frame
=
null
;
}
async
openPicker
(
pageUrl
inFrame
openMethod
=
"
click
"
)
{
this
.
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
pageUrl
)
;
let
bc
=
gBrowser
.
selectedBrowser
;
if
(
inFrame
)
{
await
SpecialPowers
.
spawn
(
bc
[
]
async
function
(
)
{
const
iframe
=
content
.
document
.
querySelector
(
"
iframe
"
)
;
iframe
.
getBoundingClientRect
(
)
;
}
)
;
bc
=
bc
.
browsingContext
.
children
[
0
]
;
}
await
SpecialPowers
.
spawn
(
bc
[
]
async
function
(
)
{
await
SpecialPowers
.
contentTransformsReceived
(
content
)
;
}
)
;
if
(
openMethod
=
=
=
"
click
"
)
{
await
SpecialPowers
.
spawn
(
bc
[
]
(
)
=
>
{
const
input
=
content
.
document
.
querySelector
(
"
input
"
)
;
const
shadowRoot
=
SpecialPowers
.
wrap
(
input
)
.
openOrClosedShadowRoot
;
shadowRoot
.
getElementById
(
"
calendar
-
button
"
)
.
click
(
)
;
}
)
;
}
else
if
(
openMethod
=
=
=
"
showPicker
"
)
{
await
SpecialPowers
.
spawn
(
bc
[
]
function
(
)
{
content
.
document
.
notifyUserGestureActivation
(
)
;
content
.
document
.
querySelector
(
"
input
"
)
.
showPicker
(
)
;
}
)
;
}
this
.
frame
=
this
.
panel
.
querySelector
(
"
#
dateTimePopupFrame
"
)
;
await
this
.
waitForPickerReady
(
)
;
}
promisePickerClosed
(
)
{
return
new
Promise
(
resolve
=
>
{
this
.
panel
.
addEventListener
(
"
popuphidden
"
resolve
{
once
:
true
}
)
;
}
)
;
}
promiseChange
(
selector
=
"
input
"
)
{
return
SpecialPowers
.
spawn
(
this
.
tab
.
linkedBrowser
[
selector
]
async
selector
=
>
{
let
input
=
content
.
document
.
querySelector
(
selector
)
;
await
ContentTaskUtils
.
waitForEvent
(
input
"
change
"
false
e
=
>
{
ok
(
content
.
window
.
windowUtils
.
isHandlingUserInput
"
isHandlingUserInput
should
be
true
"
)
;
return
true
;
}
)
;
}
)
;
}
async
waitForPickerReady
(
)
{
let
readyPromise
;
let
loadPromise
=
new
Promise
(
resolve
=
>
{
let
listener
=
(
)
=
>
{
if
(
this
.
frame
.
browsingContext
.
currentURI
.
spec
!
=
"
chrome
:
/
/
global
/
content
/
datepicker
.
xhtml
"
&
&
this
.
frame
.
browsingContext
.
currentURI
.
spec
!
=
"
chrome
:
/
/
global
/
content
/
timepicker
.
xhtml
"
)
{
return
;
}
this
.
frame
.
removeEventListener
(
"
load
"
listener
{
capture
:
true
}
)
;
readyPromise
=
BrowserTestUtils
.
waitForEvent
(
this
.
frame
.
contentDocument
"
PickerReady
"
)
;
resolve
(
)
;
}
;
this
.
frame
.
addEventListener
(
"
load
"
listener
{
capture
:
true
}
)
;
}
)
;
await
loadPromise
;
await
readyPromise
;
}
getElement
(
selector
)
{
return
this
.
frame
.
contentDocument
.
querySelector
(
selector
)
;
}
getChildren
(
selector
)
{
return
Array
.
from
(
this
.
getElement
(
selector
)
.
children
)
;
}
click
(
element
)
{
EventUtils
.
synthesizeMouseAtCenter
(
element
{
}
this
.
frame
.
contentWindow
)
;
}
async
tearDown
(
)
{
if
(
this
.
panel
.
state
!
=
"
closed
"
)
{
let
pickerClosePromise
=
this
.
promisePickerClosed
(
)
;
this
.
panel
.
hidePopup
(
)
;
await
pickerClosePromise
;
}
BrowserTestUtils
.
removeTab
(
this
.
tab
)
;
this
.
tab
=
null
;
}
cleanup
(
)
{
this
.
frame
.
remove
(
)
;
this
.
frame
=
null
;
this
.
panel
.
removeAttribute
(
"
animate
"
)
;
this
.
panel
=
null
;
}
}
let
helper
=
new
DateTimeTestHelper
(
)
;
registerCleanupFunction
(
(
)
=
>
{
helper
.
cleanup
(
)
;
}
)
;
const
BTN_MONTH_YEAR
=
"
#
month
-
year
-
label
"
BTN_NEXT_MONTH
=
"
.
next
"
BTN_PREV_MONTH
=
"
.
prev
"
BTN_CLEAR
=
"
#
clear
-
button
"
DAY_SELECTED
=
"
.
selection
"
DAY_TODAY
=
"
.
today
"
DAYS_VIEW
=
"
.
days
-
view
"
DIALOG_PICKER
=
"
#
date
-
picker
"
MONTH_YEAR
=
"
.
month
-
year
"
MONTH_YEAR_NAV
=
"
.
month
-
year
-
nav
"
MONTH_YEAR_VIEW
=
"
.
month
-
year
-
view
"
SPINNER_MONTH
=
"
#
spinner
-
month
"
SPINNER_YEAR
=
"
#
spinner
-
year
"
WEEK_HEADER
=
"
.
week
-
header
"
;
const
DATE_FORMAT
=
new
Intl
.
DateTimeFormat
(
"
en
-
US
"
{
year
:
"
numeric
"
month
:
"
long
"
timeZone
:
"
UTC
"
}
)
.
format
;
const
DATE_FORMAT_LOCAL
=
new
Intl
.
DateTimeFormat
(
"
en
-
US
"
{
year
:
"
numeric
"
month
:
"
long
"
}
)
.
format
;
function
getCalendarText
(
)
{
let
calendarCells
=
[
]
;
for
(
const
tr
of
helper
.
getChildren
(
DAYS_VIEW
)
)
{
for
(
const
td
of
tr
.
children
)
{
calendarCells
.
push
(
td
.
textContent
)
;
}
}
return
calendarCells
;
}
function
getCalendarClassList
(
)
{
let
calendarCellsClasses
=
[
]
;
for
(
const
tr
of
helper
.
getChildren
(
DAYS_VIEW
)
)
{
for
(
const
td
of
tr
.
children
)
{
calendarCellsClasses
.
push
(
td
.
classList
)
;
}
}
return
calendarCellsClasses
;
}
function
getDayEl
(
dayNum
)
{
const
dayEls
=
Array
.
from
(
helper
.
getElement
(
DAYS_VIEW
)
.
querySelectorAll
(
"
td
"
)
)
;
return
dayEls
.
find
(
el
=
>
el
.
textContent
=
=
=
dayNum
.
toString
(
)
)
;
}
function
mergeArrays
(
a
b
)
{
return
a
.
map
(
(
classlist
index
)
=
>
classlist
.
concat
(
b
[
index
]
)
)
;
}
function
testAttribute
(
el
attr
)
{
Assert
.
ok
(
el
.
hasAttribute
(
attr
)
The
"
{
el
}
"
element
has
a
"
{
attr
}
"
attribute
)
;
}
function
testAttributeL10n
(
el
attr
id
args
=
null
)
{
testAttribute
(
el
attr
)
;
testLocalization
(
el
id
args
)
;
}
async
function
testCalendarBtnAttribute
(
attr
val
presenceOnly
=
false
)
{
let
browser
=
helper
.
tab
.
linkedBrowser
;
await
SpecialPowers
.
spawn
(
browser
[
attr
val
presenceOnly
]
(
attr
val
presenceOnly
)
=
>
{
const
input
=
content
.
document
.
querySelector
(
"
input
"
)
;
const
shadowRoot
=
SpecialPowers
.
wrap
(
input
)
.
openOrClosedShadowRoot
;
const
calendarBtn
=
shadowRoot
.
getElementById
(
"
calendar
-
button
"
)
;
if
(
presenceOnly
)
{
Assert
.
ok
(
calendarBtn
.
hasAttribute
(
attr
)
Calendar
button
has
{
attr
}
attribute
)
;
}
else
{
Assert
.
equal
(
calendarBtn
.
getAttribute
(
attr
)
val
Calendar
button
has
{
attr
}
attribute
set
to
{
val
}
)
;
}
}
)
;
}
async
function
testKeyOnSpinners
(
key
document
tabs
=
1
)
{
info
(
Testing
"
{
key
}
"
key
behavior
)
;
Assert
.
equal
(
document
.
activeElement
helper
.
getElement
(
BTN_MONTH_YEAR
)
"
The
month
-
year
toggle
button
is
focused
"
)
;
await
EventUtils
.
synthesizeKey
(
"
"
{
}
)
;
Assert
.
equal
(
helper
.
getElement
(
BTN_MONTH_YEAR
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
true
"
"
Month
-
year
button
is
expanded
when
the
spinners
are
shown
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_visible
(
helper
.
getElement
(
MONTH_YEAR_VIEW
)
)
"
Month
-
year
selection
panel
is
visible
"
)
;
await
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
{
repeat
:
tabs
}
)
;
Assert
.
equal
(
document
.
activeElement
.
getAttribute
(
"
role
"
)
"
spinbutton
"
"
The
spinner
is
focused
"
)
;
await
EventUtils
.
synthesizeKey
(
key
{
}
)
;
Assert
.
equal
(
helper
.
getElement
(
BTN_MONTH_YEAR
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
false
"
"
Month
-
year
button
is
collapsed
when
the
spinners
are
hidden
"
)
;
Assert
.
ok
(
BrowserTestUtils
.
is_hidden
(
helper
.
getElement
(
MONTH_YEAR_VIEW
)
)
"
Month
-
year
selection
panel
is
not
visible
"
)
;
Assert
.
equal
(
document
.
activeElement
helper
.
getElement
(
DAYS_VIEW
)
.
querySelector
(
'
[
tabindex
=
"
0
"
]
'
)
"
A
focusable
day
within
a
calendar
grid
is
focused
"
)
;
await
EventUtils
.
synthesizeKey
(
"
KEY_Tab
"
{
repeat
:
3
}
)
;
}
function
testLocalization
(
el
id
args
=
null
)
{
const
l10nAttrs
=
document
.
l10n
.
getAttributes
(
el
)
;
Assert
.
deepEqual
(
l10nAttrs
{
id
args
}
The
"
{
id
}
"
element
is
localizable
)
;
}
async
function
testReducedMotionProp
(
el
prop
valueNotReduced
valueReduced
)
{
info
(
Test
the
panel
'
s
CSS
{
prop
}
value
depending
on
a
reduced
motion
mode
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
ui
.
prefersReducedMotion
"
0
]
]
}
)
;
ok
(
matchMedia
(
"
(
prefers
-
reduced
-
motion
:
no
-
preference
)
"
)
.
matches
"
The
reduce
motion
mode
is
not
active
"
)
;
is
(
getComputedStyle
(
el
)
.
getPropertyValue
(
prop
)
valueNotReduced
Default
{
prop
}
will
be
provided
when
a
reduce
motion
mode
is
not
active
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
ui
.
prefersReducedMotion
"
1
]
]
}
)
;
ok
(
matchMedia
(
"
(
prefers
-
reduced
-
motion
:
reduce
)
"
)
.
matches
"
The
reduce
motion
mode
is
active
"
)
;
is
(
getComputedStyle
(
el
)
.
getPropertyValue
(
prop
)
valueReduced
Reduced
{
prop
}
will
be
provided
when
a
reduce
motion
mode
is
active
)
;
}
async
function
verifyPickerPosition
(
browsingContext
inputId
)
{
let
inputRect
=
await
SpecialPowers
.
spawn
(
browsingContext
[
inputId
]
async
function
(
inputIdChild
)
{
let
rect
=
content
.
document
.
getElementById
(
inputIdChild
)
.
getBoundingClientRect
(
)
;
return
{
left
:
content
.
mozInnerScreenX
+
rect
.
left
bottom
:
content
.
mozInnerScreenY
+
rect
.
bottom
}
;
}
)
;
function
is_close
(
got
exp
msg
)
{
Assert
.
ok
(
Math
.
abs
(
got
-
exp
)
<
1
msg
+
"
:
"
+
got
+
"
should
be
equal
(
-
ish
)
to
"
+
exp
)
;
}
const
marginLeft
=
parseFloat
(
getComputedStyle
(
helper
.
panel
)
.
marginLeft
)
;
const
marginTop
=
parseFloat
(
getComputedStyle
(
helper
.
panel
)
.
marginTop
)
;
is_close
(
helper
.
panel
.
screenX
-
marginLeft
inputRect
.
left
"
datepicker
x
position
"
)
;
is_close
(
helper
.
panel
.
screenY
-
marginTop
inputRect
.
bottom
"
datepicker
y
position
"
)
;
}
