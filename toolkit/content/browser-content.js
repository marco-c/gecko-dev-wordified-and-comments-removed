ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ReaderMode
"
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SelectContentHelper
"
"
resource
:
/
/
gre
/
modules
/
SelectContentHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FindContent
"
"
resource
:
/
/
gre
/
modules
/
FindContent
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
RemoteFinder
"
"
resource
:
/
/
gre
/
modules
/
RemoteFinder
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AutoScrollController
"
"
resource
:
/
/
gre
/
modules
/
AutoScrollController
.
jsm
"
)
;
var
global
=
this
;
addMessageListener
(
"
Finder
:
Initialize
"
function
(
)
{
let
{
RemoteFinderListener
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
RemoteFinder
.
jsm
"
{
}
)
;
new
RemoteFinderListener
(
global
)
;
}
)
;
var
AutoScrollListener
=
{
handleEvent
(
event
)
{
if
(
event
.
isTrusted
&
!
event
.
defaultPrevented
)
{
if
(
!
this
.
_controller
)
{
this
.
_controller
=
new
AutoScrollController
(
global
)
;
}
this
.
_controller
.
handleEvent
(
event
)
;
}
}
}
;
Services
.
els
.
addSystemEventListener
(
global
"
mousedown
"
AutoScrollListener
true
)
;
var
PopupBlocking
=
{
popupData
:
null
popupDataInternal
:
null
init
(
)
{
addEventListener
(
"
DOMPopupBlocked
"
this
true
)
;
addEventListener
(
"
pageshow
"
this
true
)
;
addEventListener
(
"
pagehide
"
this
true
)
;
addMessageListener
(
"
PopupBlocking
:
UnblockPopup
"
this
)
;
addMessageListener
(
"
PopupBlocking
:
GetBlockedPopupList
"
this
)
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
PopupBlocking
:
UnblockPopup
"
:
{
let
i
=
msg
.
data
.
index
;
if
(
this
.
popupData
&
&
this
.
popupData
[
i
]
)
{
let
data
=
this
.
popupData
[
i
]
;
let
internals
=
this
.
popupDataInternal
[
i
]
;
let
dwi
=
internals
.
requestingWindow
;
if
(
dwi
&
&
dwi
.
document
=
=
internals
.
requestingDocument
)
{
dwi
.
open
(
data
.
popupWindowURIspec
data
.
popupWindowName
data
.
popupWindowFeatures
)
;
}
}
break
;
}
case
"
PopupBlocking
:
GetBlockedPopupList
"
:
{
let
popupData
=
[
]
;
let
length
=
this
.
popupData
?
this
.
popupData
.
length
:
0
;
length
=
Math
.
min
(
length
15
)
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
let
popupWindowURIspec
=
this
.
popupData
[
i
]
.
popupWindowURIspec
;
if
(
popupWindowURIspec
=
=
global
.
content
.
location
.
href
)
{
popupWindowURIspec
=
"
<
self
>
"
;
}
else
{
popupWindowURIspec
=
popupWindowURIspec
.
substring
(
0
500
)
;
}
popupData
.
push
(
{
popupWindowURIspec
}
)
;
}
sendAsyncMessage
(
"
PopupBlocking
:
ReplyGetBlockedPopupList
"
{
popupData
}
)
;
break
;
}
}
}
handleEvent
(
ev
)
{
switch
(
ev
.
type
)
{
case
"
DOMPopupBlocked
"
:
return
this
.
onPopupBlocked
(
ev
)
;
case
"
pageshow
"
:
return
this
.
_removeIrrelevantPopupData
(
)
;
case
"
pagehide
"
:
return
this
.
_removeIrrelevantPopupData
(
ev
.
target
)
;
}
return
undefined
;
}
onPopupBlocked
(
ev
)
{
if
(
!
this
.
popupData
)
{
this
.
popupData
=
[
]
;
this
.
popupDataInternal
=
[
]
;
}
let
obj
=
{
popupWindowURIspec
:
ev
.
popupWindowURI
?
ev
.
popupWindowURI
.
spec
:
"
about
:
blank
"
popupWindowFeatures
:
ev
.
popupWindowFeatures
popupWindowName
:
ev
.
popupWindowName
}
;
let
internals
=
{
requestingWindow
:
ev
.
requestingWindow
requestingDocument
:
ev
.
requestingWindow
.
document
}
;
this
.
popupData
.
push
(
obj
)
;
this
.
popupDataInternal
.
push
(
internals
)
;
this
.
updateBlockedPopups
(
true
)
;
}
_removeIrrelevantPopupData
(
removedDoc
=
null
)
{
if
(
this
.
popupData
)
{
let
i
=
0
;
let
oldLength
=
this
.
popupData
.
length
;
while
(
i
<
this
.
popupData
.
length
)
{
let
{
requestingWindow
requestingDocument
}
=
this
.
popupDataInternal
[
i
]
;
if
(
requestingWindow
&
&
requestingWindow
.
document
=
=
requestingDocument
&
&
requestingDocument
!
=
removedDoc
)
{
i
+
+
;
}
else
{
this
.
popupData
.
splice
(
i
1
)
;
this
.
popupDataInternal
.
splice
(
i
1
)
;
}
}
if
(
this
.
popupData
.
length
=
=
0
)
{
this
.
popupData
=
null
;
this
.
popupDataInternal
=
null
;
}
if
(
!
this
.
popupData
|
|
oldLength
>
this
.
popupData
.
length
)
{
this
.
updateBlockedPopups
(
false
)
;
}
}
}
updateBlockedPopups
(
freshPopup
)
{
sendAsyncMessage
(
"
PopupBlocking
:
UpdateBlockedPopups
"
{
count
:
this
.
popupData
?
this
.
popupData
.
length
:
0
freshPopup
}
)
;
}
}
;
PopupBlocking
.
init
(
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
(
)
=
>
{
let
Console
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
return
new
Console
.
ConsoleAPI
(
)
;
}
)
;
var
Printing
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsIPrintingPromptService
]
)
MESSAGES
:
[
"
Printing
:
Preview
:
Enter
"
"
Printing
:
Preview
:
Exit
"
"
Printing
:
Preview
:
Navigate
"
"
Printing
:
Preview
:
ParseDocument
"
"
Printing
:
Print
"
]
init
(
)
{
this
.
MESSAGES
.
forEach
(
msgName
=
>
addMessageListener
(
msgName
this
)
)
;
addEventListener
(
"
PrintingError
"
this
true
)
;
addEventListener
(
"
printPreviewUpdate
"
this
true
)
;
}
get
shouldSavePrintSettings
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
print
.
use_global_printsettings
"
)
&
&
Services
.
prefs
.
getBoolPref
(
"
print
.
save_print_settings
"
)
;
}
printPreviewInitializingInfo
:
null
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
PrintingError
"
:
{
let
win
=
event
.
target
.
defaultView
;
let
wbp
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebBrowserPrint
)
;
let
nsresult
=
event
.
detail
;
sendAsyncMessage
(
"
Printing
:
Error
"
{
isPrinting
:
wbp
.
doingPrint
nsresult
}
)
;
break
;
}
case
"
printPreviewUpdate
"
:
{
let
info
=
this
.
printPreviewInitializingInfo
;
if
(
!
info
)
{
return
;
}
if
(
!
info
.
entered
)
{
info
.
entered
=
true
;
sendAsyncMessage
(
"
Printing
:
Preview
:
Entered
"
{
failed
:
false
changingBrowsers
:
info
.
changingBrowsers
}
)
;
if
(
info
.
nextRequest
)
{
Services
.
tm
.
dispatchToMainThread
(
info
.
nextRequest
)
;
}
}
this
.
updatePageCount
(
)
;
break
;
}
}
}
receiveMessage
(
message
)
{
let
data
=
message
.
data
;
switch
(
message
.
name
)
{
case
"
Printing
:
Preview
:
Enter
"
:
{
this
.
enterPrintPreview
(
Services
.
wm
.
getOuterWindowWithId
(
data
.
windowID
)
data
.
simplifiedMode
data
.
changingBrowsers
data
.
defaultPrinterName
)
;
break
;
}
case
"
Printing
:
Preview
:
Exit
"
:
{
this
.
exitPrintPreview
(
)
;
break
;
}
case
"
Printing
:
Preview
:
Navigate
"
:
{
this
.
navigate
(
data
.
navType
data
.
pageNum
)
;
break
;
}
case
"
Printing
:
Preview
:
ParseDocument
"
:
{
this
.
parseDocument
(
data
.
URL
Services
.
wm
.
getOuterWindowWithId
(
data
.
windowID
)
)
;
break
;
}
case
"
Printing
:
Print
"
:
{
this
.
print
(
Services
.
wm
.
getOuterWindowWithId
(
data
.
windowID
)
data
.
simplifiedMode
data
.
defaultPrinterName
)
;
break
;
}
}
}
getPrintSettings
(
defaultPrinterName
)
{
try
{
let
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
let
printSettings
=
PSSVC
.
globalPrintSettings
;
if
(
!
printSettings
.
printerName
)
{
printSettings
.
printerName
=
defaultPrinterName
;
}
PSSVC
.
initPrintSettingsFromPrinter
(
printSettings
.
printerName
printSettings
)
;
PSSVC
.
initPrintSettingsFromPrefs
(
printSettings
true
printSettings
.
kInitSaveAll
)
;
return
printSettings
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
null
;
}
parseDocument
(
URL
contentWindow
)
{
let
articlePromise
=
ReaderMode
.
parseDocument
(
contentWindow
.
document
)
.
catch
(
Cu
.
reportError
)
;
articlePromise
.
then
(
function
(
article
)
{
let
webProgressListener
=
{
onStateChange
(
webProgress
req
flags
status
)
{
if
(
flags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
webProgress
.
removeProgressListener
(
webProgressListener
)
;
let
domUtils
=
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
if
(
domUtils
.
isMozAfterPaintPending
)
{
let
onPaint
=
function
(
)
{
removeEventListener
(
"
MozAfterPaint
"
onPaint
)
;
sendAsyncMessage
(
"
Printing
:
Preview
:
ReaderModeReady
"
)
;
}
;
contentWindow
.
addEventListener
(
"
MozAfterPaint
"
onPaint
)
;
setTimeout
(
(
)
=
>
{
removeEventListener
(
"
MozAfterPaint
"
onPaint
)
;
sendAsyncMessage
(
"
Printing
:
Preview
:
ReaderModeReady
"
)
;
}
100
)
;
}
else
{
sendAsyncMessage
(
"
Printing
:
Preview
:
ReaderModeReady
"
)
;
}
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
Ci
.
nsIObserver
]
)
}
;
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
webProgressListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_REQUEST
)
;
content
.
document
.
head
.
innerHTML
=
"
"
;
let
headBaseElement
=
content
.
document
.
createElement
(
"
base
"
)
;
headBaseElement
.
setAttribute
(
"
href
"
URL
)
;
content
.
document
.
head
.
appendChild
(
headBaseElement
)
;
let
headStyleElement
=
content
.
document
.
createElement
(
"
link
"
)
;
headStyleElement
.
setAttribute
(
"
rel
"
"
stylesheet
"
)
;
headStyleElement
.
setAttribute
(
"
href
"
"
chrome
:
/
/
global
/
skin
/
aboutReader
.
css
"
)
;
headStyleElement
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
content
.
document
.
head
.
appendChild
(
headStyleElement
)
;
headStyleElement
=
content
.
document
.
createElement
(
"
link
"
)
;
headStyleElement
.
setAttribute
(
"
rel
"
"
stylesheet
"
)
;
headStyleElement
.
setAttribute
(
"
href
"
"
chrome
:
/
/
global
/
content
/
simplifyMode
.
css
"
)
;
headStyleElement
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
content
.
document
.
head
.
appendChild
(
headStyleElement
)
;
content
.
document
.
body
.
innerHTML
=
"
"
;
let
containerElement
=
content
.
document
.
createElement
(
"
div
"
)
;
containerElement
.
setAttribute
(
"
id
"
"
container
"
)
;
content
.
document
.
body
.
appendChild
(
containerElement
)
;
if
(
article
)
{
content
.
document
.
title
=
article
.
title
;
let
headerElement
=
content
.
document
.
createElement
(
"
div
"
)
;
headerElement
.
setAttribute
(
"
id
"
"
reader
-
header
"
)
;
headerElement
.
setAttribute
(
"
class
"
"
header
"
)
;
containerElement
.
appendChild
(
headerElement
)
;
let
titleElement
=
content
.
document
.
createElement
(
"
h1
"
)
;
titleElement
.
setAttribute
(
"
id
"
"
reader
-
title
"
)
;
titleElement
.
textContent
=
article
.
title
;
headerElement
.
appendChild
(
titleElement
)
;
let
bylineElement
=
content
.
document
.
createElement
(
"
div
"
)
;
bylineElement
.
setAttribute
(
"
id
"
"
reader
-
credits
"
)
;
bylineElement
.
setAttribute
(
"
class
"
"
credits
"
)
;
bylineElement
.
textContent
=
article
.
byline
;
headerElement
.
appendChild
(
bylineElement
)
;
headerElement
.
style
.
display
=
"
block
"
;
let
contentElement
=
content
.
document
.
createElement
(
"
div
"
)
;
contentElement
.
setAttribute
(
"
class
"
"
content
"
)
;
containerElement
.
appendChild
(
contentElement
)
;
let
readerContent
=
content
.
document
.
createElement
(
"
div
"
)
;
readerContent
.
setAttribute
(
"
id
"
"
moz
-
reader
-
content
"
)
;
contentElement
.
appendChild
(
readerContent
)
;
let
articleUri
=
Services
.
io
.
newURI
(
article
.
url
)
;
let
parserUtils
=
Cc
[
"
mozilla
.
org
/
parserutils
;
1
"
]
.
getService
(
Ci
.
nsIParserUtils
)
;
let
contentFragment
=
parserUtils
.
parseFragment
(
article
.
content
Ci
.
nsIParserUtils
.
SanitizerDropForms
|
Ci
.
nsIParserUtils
.
SanitizerAllowStyle
false
articleUri
readerContent
)
;
readerContent
.
appendChild
(
contentFragment
)
;
readerContent
.
style
.
display
=
"
block
"
;
}
else
{
let
aboutReaderStrings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
aboutReader
.
properties
"
)
;
let
errorMessage
=
aboutReaderStrings
.
GetStringFromName
(
"
aboutReader
.
loadError
"
)
;
content
.
document
.
title
=
errorMessage
;
let
readerMessageElement
=
content
.
document
.
createElement
(
"
div
"
)
;
readerMessageElement
.
setAttribute
(
"
class
"
"
reader
-
message
"
)
;
readerMessageElement
.
textContent
=
errorMessage
;
containerElement
.
appendChild
(
readerMessageElement
)
;
readerMessageElement
.
style
.
display
=
"
block
"
;
}
}
)
;
}
enterPrintPreview
(
contentWindow
simplifiedMode
changingBrowsers
defaultPrinterName
)
{
try
{
let
printSettings
=
this
.
getPrintSettings
(
defaultPrinterName
)
;
if
(
printSettings
&
&
simplifiedMode
)
printSettings
.
docURL
=
contentWindow
.
document
.
baseURI
;
let
printPreviewInitialize
=
(
)
=
>
{
try
{
this
.
printPreviewInitializingInfo
=
{
changingBrowsers
}
;
docShell
.
printPreview
.
printPreview
(
printSettings
contentWindow
this
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
this
.
printPreviewInitializingInfo
=
null
;
sendAsyncMessage
(
"
Printing
:
Preview
:
Entered
"
{
failed
:
true
}
)
;
}
}
;
if
(
this
.
printPreviewInitializingInfo
&
&
!
this
.
printPreviewInitializingInfo
.
entered
)
{
this
.
printPreviewInitializingInfo
.
nextRequest
=
printPreviewInitialize
;
}
else
{
Services
.
tm
.
dispatchToMainThread
(
printPreviewInitialize
)
;
}
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
sendAsyncMessage
(
"
Printing
:
Preview
:
Entered
"
{
failed
:
true
}
)
;
}
}
exitPrintPreview
(
)
{
this
.
printPreviewInitializingInfo
=
null
;
docShell
.
printPreview
.
exitPrintPreview
(
)
;
}
print
(
contentWindow
simplifiedMode
defaultPrinterName
)
{
let
printSettings
=
this
.
getPrintSettings
(
defaultPrinterName
)
;
if
(
printSettings
&
&
simplifiedMode
)
{
printSettings
.
docURL
=
contentWindow
.
document
.
baseURI
;
}
try
{
let
print
=
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebBrowserPrint
)
;
if
(
print
.
doingPrintPreview
)
{
this
.
logKeyedTelemetry
(
"
PRINT_DIALOG_OPENED_COUNT
"
"
FROM_PREVIEW
"
)
;
}
else
{
this
.
logKeyedTelemetry
(
"
PRINT_DIALOG_OPENED_COUNT
"
"
FROM_PAGE
"
)
;
}
print
.
print
(
printSettings
null
)
;
if
(
print
.
doingPrintPreview
)
{
if
(
simplifiedMode
)
{
this
.
logKeyedTelemetry
(
"
PRINT_COUNT
"
"
SIMPLIFIED
"
)
;
}
else
{
this
.
logKeyedTelemetry
(
"
PRINT_COUNT
"
"
WITH_PREVIEW
"
)
;
}
}
else
{
this
.
logKeyedTelemetry
(
"
PRINT_COUNT
"
"
WITHOUT_PREVIEW
"
)
;
}
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_ABORT
)
{
Cu
.
reportError
(
In
Printing
:
Print
:
Done
handler
got
unexpected
rv
{
e
.
result
}
.
)
;
sendAsyncMessage
(
"
Printing
:
Error
"
{
isPrinting
:
true
nsresult
:
e
.
result
}
)
;
}
}
if
(
this
.
shouldSavePrintSettings
)
{
let
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
PSSVC
.
savePrintSettingsToPrefs
(
printSettings
true
printSettings
.
kInitSaveAll
)
;
PSSVC
.
savePrintSettingsToPrefs
(
printSettings
false
printSettings
.
kInitSavePrinterName
)
;
}
}
logKeyedTelemetry
(
id
key
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
id
)
;
histogram
.
add
(
key
)
;
}
updatePageCount
(
)
{
let
numPages
=
docShell
.
printPreview
.
printPreviewNumPages
;
sendAsyncMessage
(
"
Printing
:
Preview
:
UpdatePageCount
"
{
numPages
}
)
;
}
navigate
(
navType
pageNum
)
{
docShell
.
printPreview
.
printPreviewNavigate
(
navType
pageNum
)
;
}
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
sendAsyncMessage
(
"
Printing
:
Preview
:
StateChange
"
{
stateFlags
:
aStateFlags
status
:
aStatus
}
)
;
}
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
sendAsyncMessage
(
"
Printing
:
Preview
:
ProgressChange
"
{
curSelfProgress
:
aCurSelfProgress
maxSelfProgress
:
aMaxSelfProgress
curTotalProgress
:
aCurTotalProgress
maxTotalProgress
:
aMaxTotalProgress
}
)
;
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
}
onStatusChange
(
aWebProgress
aRequest
aStatus
aMessage
)
{
}
onSecurityChange
(
aWebProgress
aRequest
aState
)
{
}
}
;
Printing
.
init
(
)
;
function
SwitchDocumentDirection
(
aWindow
)
{
if
(
aWindow
.
document
.
dir
=
=
"
ltr
"
|
|
aWindow
.
document
.
dir
=
=
"
"
)
{
aWindow
.
document
.
dir
=
"
rtl
"
;
}
else
if
(
aWindow
.
document
.
dir
=
=
"
rtl
"
)
{
aWindow
.
document
.
dir
=
"
ltr
"
;
}
for
(
let
run
=
0
;
run
<
aWindow
.
frames
.
length
;
run
+
+
)
{
SwitchDocumentDirection
(
aWindow
.
frames
[
run
]
)
;
}
}
addMessageListener
(
"
SwitchDocumentDirection
"
(
)
=
>
{
SwitchDocumentDirection
(
content
.
window
)
;
}
)
;
var
FindBar
=
{
FIND_NORMAL
:
0
FIND_TYPEAHEAD
:
1
FIND_LINKS
:
2
_findMode
:
0
_findKey
:
null
_findModifiers
:
null
init
(
)
{
addMessageListener
(
"
Findbar
:
UpdateState
"
this
)
;
Services
.
els
.
addSystemEventListener
(
global
"
keypress
"
this
false
)
;
Services
.
els
.
addSystemEventListener
(
global
"
mouseup
"
this
false
)
;
this
.
_initShortcutData
(
)
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
Findbar
:
UpdateState
"
:
this
.
_findMode
=
msg
.
data
.
findMode
;
this
.
_quickFindTimeout
=
msg
.
data
.
hasQuickFindTimeout
;
if
(
msg
.
data
.
isOpenAndFocused
)
{
this
.
_keepPassingUntilToldOtherwise
=
false
;
}
break
;
case
"
Findbar
:
ShortcutData
"
:
Services
.
cpmm
.
initialProcessData
.
findBarShortcutData
=
msg
.
data
;
Services
.
cpmm
.
removeMessageListener
(
"
Findbar
:
ShortcutData
"
this
)
;
this
.
_initShortcutData
(
msg
.
data
)
;
break
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
keypress
"
:
this
.
_onKeypress
(
event
)
;
break
;
case
"
mouseup
"
:
this
.
_onMouseup
(
event
)
;
break
;
}
}
_initShortcutData
(
data
=
Services
.
cpmm
.
initialProcessData
.
findBarShortcutData
)
{
if
(
data
)
{
this
.
_findKey
=
data
.
key
;
this
.
_findModifiers
=
data
.
modifiers
;
}
else
{
Services
.
cpmm
.
addMessageListener
(
"
Findbar
:
ShortcutData
"
this
)
;
}
}
_eventMatchesFindShortcut
(
aEvent
)
{
let
modifiers
=
this
.
_findModifiers
;
if
(
!
modifiers
)
{
return
false
;
}
return
aEvent
.
ctrlKey
=
=
modifiers
.
ctrlKey
&
&
aEvent
.
altKey
=
=
modifiers
.
altKey
&
&
aEvent
.
shiftKey
=
=
modifiers
.
shiftKey
&
&
aEvent
.
metaKey
=
=
modifiers
.
metaKey
&
&
aEvent
.
key
=
=
this
.
_findKey
;
}
_canAndShouldFastFind
(
)
{
let
should
=
false
;
let
can
=
BrowserUtils
.
canFastFind
(
content
)
;
if
(
can
)
{
let
focusedWindow
=
{
}
;
let
elt
=
Services
.
focus
.
getFocusedElementForWindow
(
content
true
focusedWindow
)
;
let
win
=
focusedWindow
.
value
;
should
=
BrowserUtils
.
shouldFastFind
(
elt
win
)
;
}
return
{
can
should
}
;
}
_onKeypress
(
event
)
{
const
FAYT_LINKS_KEY
=
"
'
"
;
const
FAYT_TEXT_KEY
=
"
/
"
;
if
(
this
.
_eventMatchesFindShortcut
(
event
)
)
{
this
.
_keepPassingUntilToldOtherwise
=
true
;
}
if
(
event
.
ctrlKey
|
|
event
.
altKey
|
|
event
.
metaKey
|
|
event
.
defaultPrevented
)
{
return
;
}
let
fastFind
=
this
.
_canAndShouldFastFind
(
)
;
if
(
!
fastFind
.
can
)
{
return
;
}
if
(
this
.
_keepPassingUntilToldOtherwise
)
{
this
.
_passKeyToParent
(
event
)
;
return
;
}
if
(
!
fastFind
.
should
)
{
return
;
}
let
charCode
=
event
.
charCode
;
if
(
this
.
_findMode
!
=
this
.
FIND_NORMAL
&
&
this
.
_quickFindTimeout
)
{
if
(
!
charCode
)
return
;
this
.
_passKeyToParent
(
event
)
;
}
else
{
let
key
=
charCode
?
String
.
fromCharCode
(
charCode
)
:
null
;
let
manualstartFAYT
=
(
key
=
=
FAYT_LINKS_KEY
|
|
key
=
=
FAYT_TEXT_KEY
)
;
let
autostartFAYT
=
!
manualstartFAYT
&
&
RemoteFinder
.
_findAsYouType
&
&
key
&
&
key
!
=
"
"
;
if
(
manualstartFAYT
|
|
autostartFAYT
)
{
let
mode
=
(
key
=
=
FAYT_LINKS_KEY
|
|
(
autostartFAYT
&
&
RemoteFinder
.
_typeAheadLinksOnly
)
)
?
this
.
FIND_LINKS
:
this
.
FIND_TYPEAHEAD
;
this
.
_findMode
=
mode
;
this
.
_passKeyToParent
(
event
)
;
}
}
}
_passKeyToParent
(
event
)
{
event
.
preventDefault
(
)
;
const
kRequiredProps
=
[
"
type
"
"
bubbles
"
"
cancelable
"
"
ctrlKey
"
"
altKey
"
"
shiftKey
"
"
metaKey
"
"
keyCode
"
"
charCode
"
]
;
let
fakeEvent
=
{
}
;
for
(
let
prop
of
kRequiredProps
)
{
fakeEvent
[
prop
]
=
event
[
prop
]
;
}
sendAsyncMessage
(
"
Findbar
:
Keypress
"
fakeEvent
)
;
}
_onMouseup
(
event
)
{
if
(
this
.
_findMode
!
=
this
.
FIND_NORMAL
)
sendAsyncMessage
(
"
Findbar
:
Mouseup
"
)
;
}
}
;
FindBar
.
init
(
)
;
let
WebChannelMessageToChromeListener
=
{
URL_WHITELIST_PREF
:
"
webchannel
.
allowObject
.
urlWhitelist
"
_cachedWhitelist
:
[
]
_lastWhitelistValue
:
"
"
init
(
)
{
addEventListener
(
"
WebChannelMessageToChrome
"
e
=
>
{
this
.
_onMessageToChrome
(
e
)
;
}
true
true
)
;
}
_getWhitelistedPrincipals
(
)
{
let
whitelist
=
Services
.
prefs
.
getCharPref
(
this
.
URL_WHITELIST_PREF
)
;
if
(
whitelist
!
=
this
.
_lastWhitelistValue
)
{
let
urls
=
whitelist
.
split
(
/
\
s
+
/
)
;
this
.
_cachedWhitelist
=
urls
.
map
(
origin
=
>
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
origin
)
)
;
}
return
this
.
_cachedWhitelist
;
}
_onMessageToChrome
(
e
)
{
let
principal
=
e
.
target
.
nodePrincipal
?
e
.
target
.
nodePrincipal
:
e
.
target
.
document
.
nodePrincipal
;
if
(
e
.
detail
)
{
if
(
typeof
e
.
detail
!
=
"
string
"
)
{
let
objectsAllowed
=
this
.
_getWhitelistedPrincipals
(
)
.
some
(
whitelisted
=
>
principal
.
originNoSuffix
=
=
whitelisted
.
originNoSuffix
)
;
if
(
!
objectsAllowed
)
{
Cu
.
reportError
(
"
WebChannelMessageToChrome
sent
with
an
object
from
a
non
-
whitelisted
principal
"
)
;
return
;
}
}
sendAsyncMessage
(
"
WebChannelMessageToChrome
"
e
.
detail
{
eventTarget
:
e
.
target
}
principal
)
;
}
else
{
Cu
.
reportError
(
"
WebChannel
message
failed
.
No
message
detail
.
"
)
;
}
}
}
;
WebChannelMessageToChromeListener
.
init
(
)
;
addMessageListener
(
"
WebChannelMessageToContent
"
function
(
e
)
{
if
(
e
.
data
)
{
let
eventTarget
=
e
.
objects
.
eventTarget
|
|
content
;
let
targetPrincipal
=
eventTarget
instanceof
Ci
.
nsIDOMWindow
?
eventTarget
.
document
.
nodePrincipal
:
eventTarget
.
nodePrincipal
;
if
(
e
.
principal
.
subsumes
(
targetPrincipal
)
)
{
let
targetWindow
=
eventTarget
instanceof
Ci
.
nsIDOMWindow
?
eventTarget
:
eventTarget
.
ownerGlobal
;
eventTarget
.
dispatchEvent
(
new
targetWindow
.
CustomEvent
(
"
WebChannelMessageToContent
"
{
detail
:
Cu
.
cloneInto
(
{
id
:
e
.
data
.
id
message
:
e
.
data
.
message
}
targetWindow
)
}
)
)
;
}
else
{
Cu
.
reportError
(
"
WebChannel
message
failed
.
Principal
mismatch
.
"
)
;
}
}
else
{
Cu
.
reportError
(
"
WebChannel
message
failed
.
No
message
data
.
"
)
;
}
}
)
;
var
AudioPlaybackListener
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
audio
-
playback
"
)
;
addMessageListener
(
"
AudioPlayback
"
this
)
;
addEventListener
(
"
unload
"
(
)
=
>
{
AudioPlaybackListener
.
uninit
(
)
;
}
)
;
}
uninit
(
)
{
Services
.
obs
.
removeObserver
(
this
"
audio
-
playback
"
)
;
removeMessageListener
(
"
AudioPlayback
"
this
)
;
}
handleMediaControlMessage
(
msg
)
{
let
utils
=
global
.
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
suspendTypes
=
Ci
.
nsISuspendedTypes
;
switch
(
msg
)
{
case
"
mute
"
:
utils
.
audioMuted
=
true
;
break
;
case
"
unmute
"
:
utils
.
audioMuted
=
false
;
break
;
case
"
lostAudioFocus
"
:
utils
.
mediaSuspend
=
suspendTypes
.
SUSPENDED_PAUSE_DISPOSABLE
;
break
;
case
"
lostAudioFocusTransiently
"
:
utils
.
mediaSuspend
=
suspendTypes
.
SUSPENDED_PAUSE
;
break
;
case
"
gainAudioFocus
"
:
utils
.
mediaSuspend
=
suspendTypes
.
NONE_SUSPENDED
;
break
;
case
"
mediaControlPaused
"
:
utils
.
mediaSuspend
=
suspendTypes
.
SUSPENDED_PAUSE_DISPOSABLE
;
break
;
case
"
mediaControlStopped
"
:
utils
.
mediaSuspend
=
suspendTypes
.
SUSPENDED_STOP_DISPOSABLE
;
break
;
case
"
resumeMedia
"
:
utils
.
mediaSuspend
=
suspendTypes
.
NONE_SUSPENDED
;
break
;
default
:
dump
(
"
Error
:
wrong
media
control
msg
!
\
n
"
)
;
break
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
audio
-
playback
"
)
{
if
(
subject
&
&
subject
.
top
=
=
global
.
content
)
{
let
name
=
"
AudioPlayback
:
"
;
if
(
data
=
=
=
"
activeMediaBlockStart
"
)
{
name
+
=
"
ActiveMediaBlockStart
"
;
}
else
if
(
data
=
=
=
"
activeMediaBlockStop
"
)
{
name
+
=
"
ActiveMediaBlockStop
"
;
}
else
{
name
+
=
(
data
=
=
=
"
active
"
)
?
"
Start
"
:
"
Stop
"
;
}
sendAsyncMessage
(
name
)
;
}
}
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
=
=
"
AudioPlayback
"
)
{
this
.
handleMediaControlMessage
(
msg
.
data
.
type
)
;
}
}
}
;
AudioPlaybackListener
.
init
(
)
;
var
UnselectedTabHoverObserver
=
{
init
(
)
{
addMessageListener
(
"
Browser
:
UnselectedTabHover
"
this
)
;
addEventListener
(
"
UnselectedTabHover
:
Enable
"
this
)
;
addEventListener
(
"
UnselectedTabHover
:
Disable
"
this
)
;
}
receiveMessage
(
message
)
{
Services
.
obs
.
notifyObservers
(
content
.
window
"
unselected
-
tab
-
hover
"
message
.
data
.
hovered
)
;
}
handleEvent
(
event
)
{
sendAsyncMessage
(
"
UnselectedTabHover
:
Toggle
"
{
enable
:
event
.
type
=
=
"
UnselectedTabHover
:
Enable
"
}
)
;
}
}
;
UnselectedTabHoverObserver
.
init
(
)
;
addMessageListener
(
"
Browser
:
PurgeSessionHistory
"
function
BrowserPurgeHistory
(
)
{
let
sessionHistory
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
if
(
!
sessionHistory
)
{
return
;
}
if
(
sessionHistory
.
index
<
sessionHistory
.
count
-
1
)
{
let
legacy
=
sessionHistory
.
legacySHistory
;
legacy
.
QueryInterface
(
Ci
.
nsISHistoryInternal
)
;
let
indexEntry
=
legacy
.
getEntryAtIndex
(
sessionHistory
.
index
false
)
;
indexEntry
.
QueryInterface
(
Ci
.
nsISHEntry
)
;
legacy
.
addEntry
(
indexEntry
true
)
;
}
let
purge
=
sessionHistory
.
count
;
if
(
global
.
content
.
location
.
href
!
=
"
about
:
blank
"
)
{
-
-
purge
;
}
if
(
purge
>
0
)
{
sessionHistory
.
legacySHistory
.
PurgeHistory
(
purge
)
;
}
}
)
;
var
ViewSelectionSource
=
{
init
(
)
{
addMessageListener
(
"
ViewSource
:
GetSelection
"
this
)
;
}
receiveMessage
(
message
)
{
if
(
message
.
name
=
=
"
ViewSource
:
GetSelection
"
)
{
let
selectionDetails
;
try
{
selectionDetails
=
message
.
objects
.
target
?
this
.
getMathMLSelection
(
message
.
objects
.
target
)
:
this
.
getSelection
(
)
;
}
finally
{
sendAsyncMessage
(
"
ViewSource
:
GetSelectionDone
"
selectionDetails
)
;
}
}
}
getPath
(
ancestor
node
)
{
var
n
=
node
;
var
p
=
n
.
parentNode
;
if
(
n
=
=
ancestor
|
|
!
p
)
return
null
;
var
path
=
[
]
;
if
(
!
path
)
return
null
;
do
{
for
(
var
i
=
0
;
i
<
p
.
childNodes
.
length
;
i
+
+
)
{
if
(
p
.
childNodes
.
item
(
i
)
=
=
n
)
{
path
.
push
(
i
)
;
break
;
}
}
n
=
p
;
p
=
n
.
parentNode
;
}
while
(
n
!
=
ancestor
&
&
p
)
;
return
path
;
}
getSelection
(
)
{
const
MARK_SELECTION_START
=
"
\
uFDD0
"
;
const
MARK_SELECTION_END
=
"
\
uFDEF
"
;
var
focusedWindow
=
Services
.
focus
.
focusedWindow
|
|
content
;
var
selection
=
focusedWindow
.
getSelection
(
)
;
var
range
=
selection
.
getRangeAt
(
0
)
;
var
ancestorContainer
=
range
.
commonAncestorContainer
;
var
doc
=
ancestorContainer
.
ownerDocument
;
var
startContainer
=
range
.
startContainer
;
var
endContainer
=
range
.
endContainer
;
var
startOffset
=
range
.
startOffset
;
var
endOffset
=
range
.
endOffset
;
var
Node
=
doc
.
defaultView
.
Node
;
if
(
ancestorContainer
.
nodeType
=
=
Node
.
TEXT_NODE
|
|
ancestorContainer
.
nodeType
=
=
Node
.
CDATA_SECTION_NODE
)
ancestorContainer
=
ancestorContainer
.
parentNode
;
try
{
if
(
ancestorContainer
=
=
doc
.
body
)
ancestorContainer
=
doc
.
documentElement
;
}
catch
(
e
)
{
}
var
startPath
=
this
.
getPath
(
ancestorContainer
startContainer
)
;
var
endPath
=
this
.
getPath
(
ancestorContainer
endContainer
)
;
var
isHTML
=
(
doc
.
createElement
(
"
div
"
)
.
tagName
=
=
"
DIV
"
)
;
var
dataDoc
=
isHTML
?
ancestorContainer
.
ownerDocument
.
implementation
.
createHTMLDocument
(
"
"
)
:
ancestorContainer
.
ownerDocument
.
implementation
.
createDocument
(
"
"
"
"
null
)
;
ancestorContainer
=
dataDoc
.
importNode
(
ancestorContainer
true
)
;
startContainer
=
ancestorContainer
;
endContainer
=
ancestorContainer
;
var
canDrawSelection
=
ancestorContainer
.
hasChildNodes
(
)
;
var
tmpNode
;
if
(
canDrawSelection
)
{
var
i
;
for
(
i
=
startPath
?
startPath
.
length
-
1
:
-
1
;
i
>
=
0
;
i
-
-
)
{
startContainer
=
startContainer
.
childNodes
.
item
(
startPath
[
i
]
)
;
}
for
(
i
=
endPath
?
endPath
.
length
-
1
:
-
1
;
i
>
=
0
;
i
-
-
)
{
endContainer
=
endContainer
.
childNodes
.
item
(
endPath
[
i
]
)
;
}
if
(
endContainer
.
nodeType
=
=
Node
.
TEXT_NODE
|
|
endContainer
.
nodeType
=
=
Node
.
CDATA_SECTION_NODE
)
{
if
(
(
endOffset
>
0
&
&
endOffset
<
endContainer
.
data
.
length
)
|
|
!
endContainer
.
parentNode
|
|
!
endContainer
.
parentNode
.
parentNode
)
endContainer
.
insertData
(
endOffset
MARK_SELECTION_END
)
;
else
{
tmpNode
=
dataDoc
.
createTextNode
(
MARK_SELECTION_END
)
;
endContainer
=
endContainer
.
parentNode
;
if
(
endOffset
=
=
=
0
)
endContainer
.
parentNode
.
insertBefore
(
tmpNode
endContainer
)
;
else
endContainer
.
parentNode
.
insertBefore
(
tmpNode
endContainer
.
nextSibling
)
;
}
}
else
{
tmpNode
=
dataDoc
.
createTextNode
(
MARK_SELECTION_END
)
;
endContainer
.
insertBefore
(
tmpNode
endContainer
.
childNodes
.
item
(
endOffset
)
)
;
}
if
(
startContainer
.
nodeType
=
=
Node
.
TEXT_NODE
|
|
startContainer
.
nodeType
=
=
Node
.
CDATA_SECTION_NODE
)
{
if
(
(
startOffset
>
0
&
&
startOffset
<
startContainer
.
data
.
length
)
|
|
!
startContainer
.
parentNode
|
|
!
startContainer
.
parentNode
.
parentNode
|
|
startContainer
!
=
startContainer
.
parentNode
.
lastChild
)
startContainer
.
insertData
(
startOffset
MARK_SELECTION_START
)
;
else
{
tmpNode
=
dataDoc
.
createTextNode
(
MARK_SELECTION_START
)
;
startContainer
=
startContainer
.
parentNode
;
if
(
startOffset
=
=
=
0
)
startContainer
.
parentNode
.
insertBefore
(
tmpNode
startContainer
)
;
else
startContainer
.
parentNode
.
insertBefore
(
tmpNode
startContainer
.
nextSibling
)
;
}
}
else
{
tmpNode
=
dataDoc
.
createTextNode
(
MARK_SELECTION_START
)
;
startContainer
.
insertBefore
(
tmpNode
startContainer
.
childNodes
.
item
(
startOffset
)
)
;
}
}
tmpNode
=
dataDoc
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
div
"
)
;
tmpNode
.
appendChild
(
ancestorContainer
)
;
return
{
uri
:
(
isHTML
?
"
view
-
source
:
data
:
text
/
html
;
charset
=
utf
-
8
"
:
"
view
-
source
:
data
:
application
/
xml
;
charset
=
utf
-
8
"
)
+
encodeURIComponent
(
tmpNode
.
innerHTML
)
drawSelection
:
canDrawSelection
baseURI
:
doc
.
baseURI
}
;
}
getMathMLSelection
(
node
)
{
var
Node
=
node
.
ownerGlobal
.
Node
;
this
.
_lineCount
=
0
;
this
.
_startTargetLine
=
0
;
this
.
_endTargetLine
=
0
;
this
.
_targetNode
=
node
;
if
(
this
.
_targetNode
&
&
this
.
_targetNode
.
nodeType
=
=
Node
.
TEXT_NODE
)
this
.
_targetNode
=
this
.
_targetNode
.
parentNode
;
var
topTag
=
"
math
"
;
var
topNode
=
this
.
_targetNode
;
while
(
topNode
&
&
topNode
.
localName
!
=
topTag
)
{
topNode
=
topNode
.
parentNode
;
}
if
(
!
topNode
)
return
undefined
;
const
VIEW_SOURCE_CSS
=
"
resource
:
/
/
content
-
accessible
/
viewsource
.
css
"
;
const
BUNDLE_URL
=
"
chrome
:
/
/
global
/
locale
/
viewSource
.
properties
"
;
let
bundle
=
Services
.
strings
.
createBundle
(
BUNDLE_URL
)
;
var
title
=
bundle
.
GetStringFromName
(
"
viewMathMLSourceTitle
"
)
;
var
wrapClass
=
this
.
wrapLongLines
?
'
class
=
"
wrap
"
'
:
"
"
;
var
source
=
"
<
!
DOCTYPE
html
>
"
+
"
<
html
>
"
+
'
<
head
>
<
meta
name
=
"
viewport
"
content
=
"
width
=
device
-
width
"
/
>
'
+
"
<
title
>
"
+
title
+
"
<
/
title
>
"
+
'
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
'
+
VIEW_SOURCE_CSS
+
'
"
>
'
+
'
<
style
type
=
"
text
/
css
"
>
'
+
"
#
target
{
border
:
dashed
1px
;
background
-
color
:
lightyellow
;
}
"
+
"
<
/
style
>
"
+
"
<
/
head
>
"
+
'
<
body
id
=
"
viewsource
"
'
+
wrapClass
+
'
onload
=
"
document
.
title
=
\
'
'
+
title
+
'
\
'
;
document
.
getElementById
(
\
'
target
\
'
)
.
scrollIntoView
(
true
)
"
>
'
+
"
<
pre
>
"
+
this
.
getOuterMarkup
(
topNode
0
)
+
"
<
/
pre
>
<
/
body
>
<
/
html
>
"
;
return
{
uri
:
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
encodeURIComponent
(
source
)
drawSelection
:
false
baseURI
:
node
.
ownerDocument
.
baseURI
}
;
}
get
wrapLongLines
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
view_source
.
wrap_long_lines
"
)
;
}
getInnerMarkup
(
node
indent
)
{
var
str
=
"
"
;
for
(
var
i
=
0
;
i
<
node
.
childNodes
.
length
;
i
+
+
)
{
str
+
=
this
.
getOuterMarkup
(
node
.
childNodes
.
item
(
i
)
indent
)
;
}
return
str
;
}
getOuterMarkup
(
node
indent
)
{
var
Node
=
node
.
ownerGlobal
.
Node
;
var
newline
=
"
"
;
var
padding
=
"
"
;
var
str
=
"
"
;
if
(
node
=
=
this
.
_targetNode
)
{
this
.
_startTargetLine
=
this
.
_lineCount
;
str
+
=
'
<
/
pre
>
<
pre
id
=
"
target
"
>
'
;
}
switch
(
node
.
nodeType
)
{
case
Node
.
ELEMENT_NODE
:
if
(
this
.
_lineCount
>
0
&
&
this
.
_lineCount
!
=
this
.
_startTargetLine
&
&
this
.
_lineCount
!
=
this
.
_endTargetLine
)
{
newline
=
"
\
n
"
;
}
this
.
_lineCount
+
+
;
for
(
var
k
=
0
;
k
<
indent
;
k
+
+
)
{
padding
+
=
"
"
;
}
str
+
=
newline
+
padding
+
'
&
lt
;
<
span
class
=
"
start
-
tag
"
>
'
+
node
.
nodeName
+
"
<
/
span
>
"
;
for
(
var
i
=
0
;
i
<
node
.
attributes
.
length
;
i
+
+
)
{
var
attr
=
node
.
attributes
.
item
(
i
)
;
if
(
attr
.
nodeName
.
match
(
/
^
[
-
_
]
moz
/
)
)
{
continue
;
}
str
+
=
'
<
span
class
=
"
attribute
-
name
"
>
'
+
attr
.
nodeName
+
'
<
/
span
>
=
<
span
class
=
"
attribute
-
value
"
>
"
'
+
this
.
unicodeToEntity
(
attr
.
nodeValue
)
+
'
"
<
/
span
>
'
;
}
if
(
!
node
.
hasChildNodes
(
)
)
{
str
+
=
"
/
&
gt
;
"
;
}
else
{
str
+
=
"
&
gt
;
"
;
var
oldLine
=
this
.
_lineCount
;
str
+
=
this
.
getInnerMarkup
(
node
indent
+
2
)
;
if
(
oldLine
=
=
this
.
_lineCount
)
{
newline
=
"
"
;
padding
=
"
"
;
}
else
{
newline
=
(
this
.
_lineCount
=
=
this
.
_endTargetLine
)
?
"
"
:
"
\
n
"
;
this
.
_lineCount
+
+
;
}
str
+
=
newline
+
padding
+
'
&
lt
;
/
<
span
class
=
"
end
-
tag
"
>
'
+
node
.
nodeName
+
"
<
/
span
>
&
gt
;
"
;
}
break
;
case
Node
.
TEXT_NODE
:
var
tmp
=
node
.
nodeValue
;
tmp
=
tmp
.
replace
(
/
(
\
n
|
\
r
|
\
t
)
+
/
g
"
"
)
;
tmp
=
tmp
.
replace
(
/
^
+
/
"
"
)
;
tmp
=
tmp
.
replace
(
/
+
/
"
"
)
;
if
(
tmp
.
length
!
=
0
)
{
str
+
=
'
<
span
class
=
"
text
"
>
'
+
this
.
unicodeToEntity
(
tmp
)
+
"
<
/
span
>
"
;
}
break
;
default
:
break
;
}
if
(
node
=
=
this
.
_targetNode
)
{
this
.
_endTargetLine
=
this
.
_lineCount
;
str
+
=
"
<
/
pre
>
<
pre
>
"
;
}
return
str
;
}
unicodeToEntity
(
text
)
{
const
charTable
=
{
"
&
"
:
'
&
amp
;
<
span
class
=
"
entity
"
>
amp
;
<
/
span
>
'
"
<
"
:
'
&
amp
;
<
span
class
=
"
entity
"
>
lt
;
<
/
span
>
'
"
>
"
:
'
&
amp
;
<
span
class
=
"
entity
"
>
gt
;
<
/
span
>
'
'
"
'
:
'
&
amp
;
<
span
class
=
"
entity
"
>
quot
;
<
/
span
>
'
}
;
function
charTableLookup
(
letter
)
{
return
charTable
[
letter
]
;
}
return
text
.
replace
(
/
[
<
>
&
"
]
/
g
charTableLookup
)
;
}
}
;
ViewSelectionSource
.
init
(
)
;
addEventListener
(
"
MozApplicationManifest
"
function
(
e
)
{
let
doc
=
e
.
target
;
let
info
=
{
uri
:
doc
.
documentURI
characterSet
:
doc
.
characterSet
manifest
:
doc
.
documentElement
.
getAttribute
(
"
manifest
"
)
principal
:
doc
.
nodePrincipal
}
;
sendAsyncMessage
(
"
MozApplicationManifest
"
info
)
;
}
false
)
;
let
AutoCompletePopup
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompletePopup
]
)
_connected
:
false
MESSAGES
:
[
"
FormAutoComplete
:
HandleEnter
"
"
FormAutoComplete
:
PopupClosed
"
"
FormAutoComplete
:
PopupOpened
"
"
FormAutoComplete
:
RequestFocus
"
]
init
(
)
{
addEventListener
(
"
unload
"
this
)
;
addEventListener
(
"
DOMContentLoaded
"
this
)
;
addEventListener
(
"
pageshow
"
this
true
)
;
for
(
let
messageName
of
this
.
MESSAGES
)
{
addMessageListener
(
messageName
this
)
;
}
this
.
_input
=
null
;
this
.
_popupOpen
=
false
;
}
destroy
(
)
{
if
(
this
.
_connected
)
{
let
controller
=
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
]
.
getService
(
Ci
.
nsIFormFillController
)
;
controller
.
detachFromBrowser
(
docShell
)
;
this
.
_connected
=
false
;
}
removeEventListener
(
"
pageshow
"
this
)
;
removeEventListener
(
"
unload
"
this
)
;
removeEventListener
(
"
DOMContentLoaded
"
this
)
;
for
(
let
messageName
of
this
.
MESSAGES
)
{
removeMessageListener
(
messageName
this
)
;
}
}
connect
(
)
{
if
(
this
.
_connected
)
{
return
;
}
let
controller
=
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
]
.
getService
(
Ci
.
nsIFormFillController
)
;
controller
.
attachToBrowser
(
docShell
this
.
QueryInterface
(
Ci
.
nsIAutoCompletePopup
)
)
;
this
.
_connected
=
true
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
pageshow
"
:
{
removeEventListener
(
"
pageshow
"
this
)
;
this
.
connect
(
)
;
break
;
}
case
"
DOMContentLoaded
"
:
{
removeEventListener
(
"
DOMContentLoaded
"
this
)
;
this
.
connect
(
)
;
break
;
}
case
"
unload
"
:
{
this
.
destroy
(
)
;
break
;
}
}
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
FormAutoComplete
:
HandleEnter
"
:
{
this
.
selectedIndex
=
message
.
data
.
selectedIndex
;
let
controller
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
controller
;
1
"
]
.
getService
(
Ci
.
nsIAutoCompleteController
)
;
controller
.
handleEnter
(
message
.
data
.
isPopupSelection
)
;
break
;
}
case
"
FormAutoComplete
:
PopupClosed
"
:
{
this
.
_popupOpen
=
false
;
break
;
}
case
"
FormAutoComplete
:
PopupOpened
"
:
{
this
.
_popupOpen
=
true
;
break
;
}
case
"
FormAutoComplete
:
RequestFocus
"
:
{
if
(
this
.
_input
)
{
this
.
_input
.
focus
(
)
;
}
break
;
}
}
}
get
input
(
)
{
return
this
.
_input
;
}
get
overrideValue
(
)
{
return
null
;
}
set
selectedIndex
(
index
)
{
sendAsyncMessage
(
"
FormAutoComplete
:
SetSelectedIndex
"
{
index
}
)
;
}
get
selectedIndex
(
)
{
return
sendSyncMessage
(
"
FormAutoComplete
:
GetSelectedIndex
"
{
}
)
;
}
get
popupOpen
(
)
{
return
this
.
_popupOpen
;
}
openAutocompletePopup
(
input
element
)
{
if
(
this
.
_popupOpen
|
|
!
input
)
{
return
;
}
let
rect
=
BrowserUtils
.
getElementBoundingScreenRect
(
element
)
;
let
window
=
element
.
ownerGlobal
;
let
dir
=
window
.
getComputedStyle
(
element
)
.
direction
;
let
results
=
this
.
getResultsFromController
(
input
)
;
sendAsyncMessage
(
"
FormAutoComplete
:
MaybeOpenPopup
"
{
results
rect
dir
}
)
;
this
.
_input
=
input
;
}
closePopup
(
)
{
this
.
_popupOpen
=
false
;
sendAsyncMessage
(
"
FormAutoComplete
:
ClosePopup
"
{
}
)
;
}
invalidate
(
)
{
if
(
this
.
_popupOpen
)
{
let
results
=
this
.
getResultsFromController
(
this
.
_input
)
;
sendAsyncMessage
(
"
FormAutoComplete
:
Invalidate
"
{
results
}
)
;
}
}
selectBy
(
reverse
page
)
{
this
.
_index
=
sendSyncMessage
(
"
FormAutoComplete
:
SelectBy
"
{
reverse
page
}
)
;
}
getResultsFromController
(
inputField
)
{
let
results
=
[
]
;
if
(
!
inputField
)
{
return
results
;
}
let
controller
=
inputField
.
controller
;
if
(
!
(
controller
instanceof
Ci
.
nsIAutoCompleteController
)
)
{
return
results
;
}
for
(
let
i
=
0
;
i
<
controller
.
matchCount
;
+
+
i
)
{
let
result
=
{
}
;
result
.
value
=
controller
.
getValueAt
(
i
)
;
result
.
label
=
controller
.
getLabelAt
(
i
)
;
result
.
comment
=
controller
.
getCommentAt
(
i
)
;
result
.
style
=
controller
.
getStyleAt
(
i
)
;
result
.
image
=
controller
.
getImageAt
(
i
)
;
results
.
push
(
result
)
;
}
return
results
;
}
}
;
AutoCompletePopup
.
init
(
)
;
let
DateTimePickerListener
=
{
init
(
)
{
addEventListener
(
"
MozOpenDateTimePicker
"
this
)
;
this
.
_inputElement
=
null
;
addEventListener
(
"
unload
"
(
)
=
>
{
this
.
uninit
(
)
;
}
)
;
}
uninit
(
)
{
removeEventListener
(
"
MozOpenDateTimePicker
"
this
)
;
this
.
_inputElement
=
null
;
}
close
(
)
{
this
.
removeListeners
(
)
;
this
.
_inputElement
.
setDateTimePickerState
(
false
)
;
this
.
_inputElement
=
null
;
}
addListeners
(
)
{
addEventListener
(
"
MozUpdateDateTimePicker
"
this
)
;
addEventListener
(
"
MozCloseDateTimePicker
"
this
)
;
addEventListener
(
"
pagehide
"
this
)
;
addMessageListener
(
"
FormDateTime
:
PickerValueChanged
"
this
)
;
addMessageListener
(
"
FormDateTime
:
PickerClosed
"
this
)
;
}
removeListeners
(
)
{
removeEventListener
(
"
MozUpdateDateTimePicker
"
this
)
;
removeEventListener
(
"
MozCloseDateTimePicker
"
this
)
;
removeEventListener
(
"
pagehide
"
this
)
;
removeMessageListener
(
"
FormDateTime
:
PickerValueChanged
"
this
)
;
removeMessageListener
(
"
FormDateTime
:
PickerClosed
"
this
)
;
}
getComputedDirection
(
aElement
)
{
return
aElement
.
ownerGlobal
.
getComputedStyle
(
aElement
)
.
getPropertyValue
(
"
direction
"
)
;
}
getBoundingContentRect
(
aElement
)
{
return
BrowserUtils
.
getElementBoundingRect
(
aElement
)
;
}
getTimePickerPref
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
dom
.
forms
.
datetime
.
timepicker
"
)
;
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
FormDateTime
:
PickerClosed
"
:
{
this
.
close
(
)
;
break
;
}
case
"
FormDateTime
:
PickerValueChanged
"
:
{
this
.
_inputElement
.
updateDateTimeInputBox
(
aMessage
.
data
)
;
break
;
}
default
:
break
;
}
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
MozOpenDateTimePicker
"
:
{
if
(
!
(
aEvent
.
originalTarget
instanceof
content
.
HTMLInputElement
)
|
|
(
aEvent
.
originalTarget
.
type
=
=
"
time
"
&
&
!
this
.
getTimePickerPref
(
)
)
)
{
return
;
}
if
(
this
.
_inputElement
)
{
return
;
}
this
.
_inputElement
=
aEvent
.
originalTarget
;
this
.
_inputElement
.
setDateTimePickerState
(
true
)
;
this
.
addListeners
(
)
;
let
value
=
this
.
_inputElement
.
getDateTimeInputBoxValue
(
)
;
sendAsyncMessage
(
"
FormDateTime
:
OpenPicker
"
{
rect
:
this
.
getBoundingContentRect
(
this
.
_inputElement
)
dir
:
this
.
getComputedDirection
(
this
.
_inputElement
)
type
:
this
.
_inputElement
.
type
detail
:
{
value
:
Object
.
keys
(
value
)
.
length
>
0
?
value
:
this
.
_inputElement
.
value
min
:
this
.
_inputElement
.
getMinimum
(
)
max
:
this
.
_inputElement
.
getMaximum
(
)
step
:
this
.
_inputElement
.
getStep
(
)
stepBase
:
this
.
_inputElement
.
getStepBase
(
)
}
}
)
;
break
;
}
case
"
MozUpdateDateTimePicker
"
:
{
let
value
=
this
.
_inputElement
.
getDateTimeInputBoxValue
(
)
;
value
.
type
=
this
.
_inputElement
.
type
;
sendAsyncMessage
(
"
FormDateTime
:
UpdatePicker
"
{
value
}
)
;
break
;
}
case
"
MozCloseDateTimePicker
"
:
{
sendAsyncMessage
(
"
FormDateTime
:
ClosePicker
"
)
;
this
.
close
(
)
;
break
;
}
case
"
pagehide
"
:
{
if
(
this
.
_inputElement
&
&
this
.
_inputElement
.
ownerDocument
=
=
aEvent
.
target
)
{
sendAsyncMessage
(
"
FormDateTime
:
ClosePicker
"
)
;
this
.
close
(
)
;
}
break
;
}
default
:
break
;
}
}
}
;
DateTimePickerListener
.
init
(
)
;
addEventListener
(
"
mozshowdropdown
"
event
=
>
{
if
(
!
event
.
isTrusted
)
return
;
if
(
!
SelectContentHelper
.
open
)
{
new
SelectContentHelper
(
event
.
target
{
isOpenedViaTouch
:
false
}
this
)
;
}
}
)
;
addEventListener
(
"
mozshowdropdown
-
sourcetouch
"
event
=
>
{
if
(
!
event
.
isTrusted
)
return
;
if
(
!
SelectContentHelper
.
open
)
{
new
SelectContentHelper
(
event
.
target
{
isOpenedViaTouch
:
true
}
this
)
;
}
}
)
;
let
ExtFind
=
{
init
(
)
{
addMessageListener
(
"
ext
-
Finder
:
CollectResults
"
this
)
;
addMessageListener
(
"
ext
-
Finder
:
HighlightResults
"
this
)
;
addMessageListener
(
"
ext
-
Finder
:
clearHighlighting
"
this
)
;
}
_findContent
:
null
async
receiveMessage
(
message
)
{
if
(
!
this
.
_findContent
)
{
this
.
_findContent
=
new
FindContent
(
docShell
)
;
}
let
data
;
switch
(
message
.
name
)
{
case
"
ext
-
Finder
:
CollectResults
"
:
this
.
finderInited
=
true
;
data
=
await
this
.
_findContent
.
findRanges
(
message
.
data
)
;
sendAsyncMessage
(
"
ext
-
Finder
:
CollectResultsFinished
"
data
)
;
break
;
case
"
ext
-
Finder
:
HighlightResults
"
:
data
=
this
.
_findContent
.
highlightResults
(
message
.
data
)
;
sendAsyncMessage
(
"
ext
-
Finder
:
HighlightResultsFinished
"
data
)
;
break
;
case
"
ext
-
Finder
:
clearHighlighting
"
:
this
.
_findContent
.
highlighter
.
highlight
(
false
)
;
break
;
}
}
}
;
ExtFind
.
init
(
)
;
