#
include
"
MiddlemanCall
.
h
"
#
include
<
unordered_map
>
namespace
mozilla
{
namespace
recordreplay
{
static
StaticInfallibleVector
<
MiddlemanCall
*
>
gMiddlemanCalls
;
typedef
std
:
:
unordered_map
<
const
void
*
MiddlemanCall
*
>
MiddlemanCallMap
;
static
MiddlemanCallMap
*
gMiddlemanCallMap
;
static
StaticInfallibleVector
<
void
*
>
gAllocatedBuffers
;
static
Monitor
*
gMonitor
;
void
InitializeMiddlemanCalls
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
|
|
IsMiddleman
(
)
)
;
gMiddlemanCallMap
=
new
MiddlemanCallMap
(
)
;
gMonitor
=
new
Monitor
(
)
;
}
static
bool
GatherDependentCalls
(
InfallibleVector
<
MiddlemanCall
*
>
&
aOutgoingCalls
MiddlemanCall
*
aCall
)
{
MOZ_RELEASE_ASSERT
(
!
aCall
-
>
mSent
)
;
aCall
-
>
mSent
=
true
;
const
Redirection
&
redirection
=
GetRedirection
(
aCall
-
>
mCallId
)
;
CallArguments
arguments
;
aCall
-
>
mArguments
.
CopyTo
(
&
arguments
)
;
InfallibleVector
<
MiddlemanCall
*
>
dependentCalls
;
MiddlemanCallContext
cx
(
aCall
&
arguments
MiddlemanCallPhase
:
:
ReplayInput
)
;
cx
.
mDependentCalls
=
&
dependentCalls
;
redirection
.
mMiddlemanCall
(
cx
)
;
if
(
cx
.
mFailed
)
{
if
(
child
:
:
CurrentRepaintCannotFail
(
)
)
{
child
:
:
ReportFatalError
(
Nothing
(
)
"
Middleman
call
input
failed
:
%
s
\
n
"
redirection
.
mName
)
;
}
return
false
;
}
for
(
MiddlemanCall
*
dependent
:
dependentCalls
)
{
if
(
!
dependent
-
>
mSent
&
&
!
GatherDependentCalls
(
aOutgoingCalls
dependent
)
)
{
return
false
;
}
}
aOutgoingCalls
.
append
(
aCall
)
;
return
true
;
}
bool
SendCallToMiddleman
(
size_t
aCallId
CallArguments
*
aArguments
bool
aDiverged
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
const
Redirection
&
redirection
=
GetRedirection
(
aCallId
)
;
MOZ_RELEASE_ASSERT
(
redirection
.
mMiddlemanCall
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
size_t
id
=
gMiddlemanCalls
.
length
(
)
;
MiddlemanCall
*
newCall
=
new
MiddlemanCall
(
)
;
gMiddlemanCalls
.
emplaceBack
(
newCall
)
;
newCall
-
>
mId
=
id
;
newCall
-
>
mCallId
=
aCallId
;
newCall
-
>
mArguments
.
CopyFrom
(
aArguments
)
;
{
MiddlemanCallContext
cx
(
newCall
aArguments
MiddlemanCallPhase
:
:
ReplayPreface
)
;
redirection
.
mMiddlemanCall
(
cx
)
;
if
(
cx
.
mFailed
)
{
delete
newCall
;
gMiddlemanCalls
.
popBack
(
)
;
if
(
child
:
:
CurrentRepaintCannotFail
(
)
)
{
child
:
:
ReportFatalError
(
Nothing
(
)
"
Middleman
call
preface
failed
:
%
s
\
n
"
redirection
.
mName
)
;
}
return
false
;
}
}
if
(
!
aDiverged
)
{
return
true
;
}
InfallibleVector
<
MiddlemanCall
*
>
outgoingCalls
;
if
(
!
GatherDependentCalls
(
outgoingCalls
newCall
)
)
{
for
(
MiddlemanCall
*
call
:
outgoingCalls
)
{
call
-
>
mSent
=
false
;
}
return
false
;
}
InfallibleVector
<
char
>
inputData
;
BufferStream
inputStream
(
&
inputData
)
;
for
(
MiddlemanCall
*
call
:
outgoingCalls
)
{
call
-
>
EncodeInput
(
inputStream
)
;
}
InfallibleVector
<
char
>
outputData
;
child
:
:
SendMiddlemanCallRequest
(
inputData
.
begin
(
)
inputData
.
length
(
)
&
outputData
)
;
BufferStream
outputStream
(
outputData
.
begin
(
)
outputData
.
length
(
)
)
;
for
(
MiddlemanCall
*
call
:
outgoingCalls
)
{
call
-
>
DecodeOutput
(
outputStream
)
;
if
(
call
!
=
newCall
)
{
CallArguments
oldArguments
;
call
-
>
mArguments
.
CopyTo
(
&
oldArguments
)
;
MiddlemanCallContext
cx
(
call
&
oldArguments
MiddlemanCallPhase
:
:
ReplayOutput
)
;
cx
.
mReplayOutputIsOld
=
true
;
GetRedirection
(
call
-
>
mCallId
)
.
mMiddlemanCall
(
cx
)
;
}
}
newCall
-
>
mArguments
.
CopyTo
(
aArguments
)
;
MiddlemanCallContext
cx
(
newCall
aArguments
MiddlemanCallPhase
:
:
ReplayOutput
)
;
redirection
.
mMiddlemanCall
(
cx
)
;
return
true
;
}
void
ProcessMiddlemanCall
(
const
char
*
aInputData
size_t
aInputSize
InfallibleVector
<
char
>
*
aOutputData
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
BufferStream
inputStream
(
aInputData
aInputSize
)
;
BufferStream
outputStream
(
aOutputData
)
;
while
(
!
inputStream
.
IsEmpty
(
)
)
{
MiddlemanCall
*
call
=
new
MiddlemanCall
(
)
;
call
-
>
DecodeInput
(
inputStream
)
;
const
Redirection
&
redirection
=
GetRedirection
(
call
-
>
mCallId
)
;
MOZ_RELEASE_ASSERT
(
redirection
.
mMiddlemanCall
)
;
CallArguments
arguments
;
call
-
>
mArguments
.
CopyTo
(
&
arguments
)
;
bool
skipCall
;
{
MiddlemanCallContext
cx
(
call
&
arguments
MiddlemanCallPhase
:
:
MiddlemanInput
)
;
redirection
.
mMiddlemanCall
(
cx
)
;
skipCall
=
cx
.
mSkipCallInMiddleman
;
}
if
(
!
skipCall
)
{
RecordReplayInvokeCall
(
redirection
.
mBaseFunction
&
arguments
)
;
}
{
MiddlemanCallContext
cx
(
call
&
arguments
MiddlemanCallPhase
:
:
MiddlemanOutput
)
;
redirection
.
mMiddlemanCall
(
cx
)
;
}
call
-
>
mArguments
.
CopyFrom
(
&
arguments
)
;
call
-
>
EncodeOutput
(
outputStream
)
;
while
(
call
-
>
mId
>
=
gMiddlemanCalls
.
length
(
)
)
{
gMiddlemanCalls
.
emplaceBack
(
nullptr
)
;
}
MOZ_RELEASE_ASSERT
(
!
gMiddlemanCalls
[
call
-
>
mId
]
)
;
gMiddlemanCalls
[
call
-
>
mId
]
=
call
;
}
}
void
*
MiddlemanCallContext
:
:
AllocateBytes
(
size_t
aSize
)
{
void
*
rv
=
malloc
(
aSize
)
;
if
(
IsMiddleman
(
)
)
{
gAllocatedBuffers
.
append
(
rv
)
;
}
return
rv
;
}
void
ResetMiddlemanCalls
(
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
for
(
MiddlemanCall
*
call
:
gMiddlemanCalls
)
{
if
(
call
)
{
CallArguments
arguments
;
call
-
>
mArguments
.
CopyTo
(
&
arguments
)
;
MiddlemanCallContext
cx
(
call
&
arguments
MiddlemanCallPhase
:
:
MiddlemanRelease
)
;
GetRedirection
(
call
-
>
mCallId
)
.
mMiddlemanCall
(
cx
)
;
}
}
for
(
MiddlemanCall
*
call
:
gMiddlemanCalls
)
{
delete
call
;
}
gMiddlemanCalls
.
clear
(
)
;
for
(
auto
buffer
:
gAllocatedBuffers
)
{
free
(
buffer
)
;
}
gAllocatedBuffers
.
clear
(
)
;
gMiddlemanCallMap
-
>
clear
(
)
;
}
static
void
AddMiddlemanCallValue
(
const
void
*
aThing
MiddlemanCall
*
aCall
)
{
gMiddlemanCallMap
-
>
erase
(
aThing
)
;
gMiddlemanCallMap
-
>
insert
(
MiddlemanCallMap
:
:
value_type
(
aThing
aCall
)
)
;
}
static
MiddlemanCall
*
LookupMiddlemanCall
(
const
void
*
aThing
)
{
MiddlemanCallMap
:
:
const_iterator
iter
=
gMiddlemanCallMap
-
>
find
(
aThing
)
;
if
(
iter
!
=
gMiddlemanCallMap
-
>
end
(
)
)
{
return
iter
-
>
second
;
}
return
nullptr
;
}
static
const
void
*
GetMiddlemanCallValue
(
size_t
aId
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
MOZ_RELEASE_ASSERT
(
aId
<
gMiddlemanCalls
.
length
(
)
&
&
gMiddlemanCalls
[
aId
]
&
&
gMiddlemanCalls
[
aId
]
-
>
mMiddlemanValue
.
isSome
(
)
)
;
return
gMiddlemanCalls
[
aId
]
-
>
mMiddlemanValue
.
ref
(
)
;
}
bool
MM_SystemInput
(
MiddlemanCallContext
&
aCx
const
void
*
*
aThingPtr
)
{
MOZ_RELEASE_ASSERT
(
aCx
.
AccessPreface
(
)
)
;
if
(
!
*
aThingPtr
)
{
return
true
;
}
Maybe
<
size_t
>
callId
;
if
(
aCx
.
mPhase
=
=
MiddlemanCallPhase
:
:
ReplayPreface
)
{
MiddlemanCall
*
call
=
LookupMiddlemanCall
(
*
aThingPtr
)
;
if
(
call
)
{
callId
.
emplace
(
call
-
>
mId
)
;
}
}
aCx
.
ReadOrWritePrefaceBytes
(
&
callId
sizeof
(
callId
)
)
;
switch
(
aCx
.
mPhase
)
{
case
MiddlemanCallPhase
:
:
ReplayPreface
:
return
true
;
case
MiddlemanCallPhase
:
:
ReplayInput
:
if
(
callId
.
isSome
(
)
)
{
aCx
.
WriteInputScalar
(
callId
.
ref
(
)
)
;
aCx
.
mDependentCalls
-
>
append
(
gMiddlemanCalls
[
callId
.
ref
(
)
]
)
;
return
true
;
}
return
false
;
case
MiddlemanCallPhase
:
:
MiddlemanInput
:
if
(
callId
.
isSome
(
)
)
{
size_t
callIndex
=
aCx
.
ReadInputScalar
(
)
;
*
aThingPtr
=
GetMiddlemanCallValue
(
callIndex
)
;
return
true
;
}
return
false
;
default
:
MOZ_CRASH
(
"
Bad
phase
"
)
;
}
}
static
const
void
*
MangleSystemValue
(
const
void
*
aValue
bool
aFromRecording
)
{
return
(
const
void
*
)
(
(
size_t
)
aValue
|
(
1ULL
<
<
(
aFromRecording
?
63
:
62
)
)
)
;
}
void
MM_SystemOutput
(
MiddlemanCallContext
&
aCx
const
void
*
*
aOutput
bool
aUpdating
)
{
if
(
!
*
aOutput
)
{
if
(
aCx
.
mPhase
=
=
MiddlemanCallPhase
:
:
MiddlemanOutput
)
{
aCx
.
mCall
-
>
SetMiddlemanValue
(
*
aOutput
)
;
}
return
;
}
switch
(
aCx
.
mPhase
)
{
case
MiddlemanCallPhase
:
:
ReplayPreface
:
if
(
!
HasDivergedFromRecording
(
)
)
{
if
(
!
aUpdating
)
{
*
aOutput
=
MangleSystemValue
(
*
aOutput
true
)
;
}
aCx
.
mCall
-
>
SetRecordingValue
(
*
aOutput
)
;
AddMiddlemanCallValue
(
*
aOutput
aCx
.
mCall
)
;
}
break
;
case
MiddlemanCallPhase
:
:
MiddlemanOutput
:
aCx
.
mCall
-
>
SetMiddlemanValue
(
*
aOutput
)
;
AddMiddlemanCallValue
(
*
aOutput
aCx
.
mCall
)
;
break
;
case
MiddlemanCallPhase
:
:
ReplayOutput
:
{
if
(
!
aUpdating
)
{
*
aOutput
=
MangleSystemValue
(
*
aOutput
false
)
;
}
aCx
.
mCall
-
>
SetMiddlemanValue
(
*
aOutput
)
;
MiddlemanCall
*
previousCall
=
LookupMiddlemanCall
(
*
aOutput
)
;
if
(
previousCall
)
{
if
(
previousCall
-
>
mRecordingValue
.
isSome
(
)
)
{
*
aOutput
=
previousCall
-
>
mRecordingValue
.
ref
(
)
;
}
}
else
{
AddMiddlemanCallValue
(
*
aOutput
aCx
.
mCall
)
;
}
break
;
}
default
:
return
;
}
}
void
MiddlemanCall
:
:
EncodeInput
(
BufferStream
&
aStream
)
const
{
aStream
.
WriteScalar
(
mId
)
;
aStream
.
WriteScalar
(
mCallId
)
;
aStream
.
WriteBytes
(
&
mArguments
sizeof
(
CallRegisterArguments
)
)
;
aStream
.
WriteScalar
(
mPreface
.
length
(
)
)
;
aStream
.
WriteBytes
(
mPreface
.
begin
(
)
mPreface
.
length
(
)
)
;
aStream
.
WriteScalar
(
mInput
.
length
(
)
)
;
aStream
.
WriteBytes
(
mInput
.
begin
(
)
mInput
.
length
(
)
)
;
}
void
MiddlemanCall
:
:
DecodeInput
(
BufferStream
&
aStream
)
{
mId
=
aStream
.
ReadScalar
(
)
;
mCallId
=
aStream
.
ReadScalar
(
)
;
aStream
.
ReadBytes
(
&
mArguments
sizeof
(
CallRegisterArguments
)
)
;
size_t
prefaceLength
=
aStream
.
ReadScalar
(
)
;
mPreface
.
appendN
(
0
prefaceLength
)
;
aStream
.
ReadBytes
(
mPreface
.
begin
(
)
prefaceLength
)
;
size_t
inputLength
=
aStream
.
ReadScalar
(
)
;
mInput
.
appendN
(
0
inputLength
)
;
aStream
.
ReadBytes
(
mInput
.
begin
(
)
inputLength
)
;
}
void
MiddlemanCall
:
:
EncodeOutput
(
BufferStream
&
aStream
)
const
{
aStream
.
WriteBytes
(
&
mArguments
sizeof
(
CallRegisterArguments
)
)
;
aStream
.
WriteScalar
(
mOutput
.
length
(
)
)
;
aStream
.
WriteBytes
(
mOutput
.
begin
(
)
mOutput
.
length
(
)
)
;
}
void
MiddlemanCall
:
:
DecodeOutput
(
BufferStream
&
aStream
)
{
CallRegisterArguments
newArguments
;
aStream
.
ReadBytes
(
&
newArguments
sizeof
(
CallRegisterArguments
)
)
;
mArguments
.
CopyRvalFrom
(
&
newArguments
)
;
size_t
outputLength
=
aStream
.
ReadScalar
(
)
;
mOutput
.
appendN
(
0
outputLength
)
;
aStream
.
ReadBytes
(
mOutput
.
begin
(
)
outputLength
)
;
}
}
}
