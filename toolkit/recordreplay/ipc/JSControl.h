#
ifndef
mozilla_recordreplay_JSControl_h
#
define
mozilla_recordreplay_JSControl_h
#
include
"
jsapi
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
ProcessRewind
.
h
"
#
include
"
mozilla
/
DefineEnum
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
js
{
struct
BreakpointPosition
{
MOZ_DEFINE_ENUM_AT_CLASS_SCOPE
(
Kind
(
Invalid
Break
OnStep
OnPop
EnterFrame
NewScript
)
)
;
Kind
mKind
;
uint32_t
mScript
;
uint32_t
mOffset
;
uint32_t
mFrameIndex
;
static
const
uint32_t
EMPTY_SCRIPT
=
(
uint32_t
)
-
1
;
static
const
uint32_t
EMPTY_OFFSET
=
(
uint32_t
)
-
1
;
static
const
uint32_t
EMPTY_FRAME_INDEX
=
(
uint32_t
)
-
1
;
BreakpointPosition
(
)
:
mKind
(
Invalid
)
mScript
(
EMPTY_SCRIPT
)
mOffset
(
EMPTY_OFFSET
)
mFrameIndex
(
EMPTY_FRAME_INDEX
)
{
}
explicit
BreakpointPosition
(
Kind
aKind
uint32_t
aScript
=
EMPTY_SCRIPT
uint32_t
aOffset
=
EMPTY_OFFSET
uint32_t
aFrameIndex
=
EMPTY_FRAME_INDEX
)
:
mKind
(
aKind
)
mScript
(
aScript
)
mOffset
(
aOffset
)
mFrameIndex
(
aFrameIndex
)
{
}
bool
IsValid
(
)
const
{
return
mKind
!
=
Invalid
;
}
inline
bool
operator
=
=
(
const
BreakpointPosition
&
o
)
const
{
return
mKind
=
=
o
.
mKind
&
&
mScript
=
=
o
.
mScript
&
&
mOffset
=
=
o
.
mOffset
&
&
mFrameIndex
=
=
o
.
mFrameIndex
;
}
inline
bool
operator
!
=
(
const
BreakpointPosition
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
inline
bool
Subsumes
(
const
BreakpointPosition
&
o
)
const
{
return
(
*
this
=
=
o
)
|
|
(
mKind
=
=
OnPop
&
&
o
.
mKind
=
=
OnPop
&
&
mScript
=
=
EMPTY_SCRIPT
)
|
|
(
mKind
=
=
Break
&
&
o
.
mKind
=
=
OnStep
&
&
mScript
=
=
o
.
mScript
&
&
mOffset
=
=
o
.
mOffset
)
;
}
static
const
char
*
StaticKindString
(
Kind
aKind
)
{
switch
(
aKind
)
{
case
Invalid
:
return
"
Invalid
"
;
case
Break
:
return
"
Break
"
;
case
OnStep
:
return
"
OnStep
"
;
case
OnPop
:
return
"
OnPop
"
;
case
EnterFrame
:
return
"
EnterFrame
"
;
case
NewScript
:
return
"
NewScript
"
;
}
MOZ_CRASH
(
"
Bad
BreakpointPosition
kind
"
)
;
}
const
char
*
KindString
(
)
const
{
return
StaticKindString
(
mKind
)
;
}
JSObject
*
Encode
(
JSContext
*
aCx
)
const
;
bool
Decode
(
JSContext
*
aCx
JS
:
:
HandleObject
aObject
)
;
}
;
struct
ExecutionPoint
{
size_t
mCheckpoint
;
ProgressCounter
mProgress
;
BreakpointPosition
mPosition
;
ExecutionPoint
(
)
:
mCheckpoint
(
CheckpointId
:
:
Invalid
)
mProgress
(
0
)
{
}
explicit
ExecutionPoint
(
size_t
aCheckpoint
)
:
mCheckpoint
(
aCheckpoint
)
mProgress
(
0
)
{
}
ExecutionPoint
(
size_t
aCheckpoint
ProgressCounter
aProgress
const
BreakpointPosition
&
aPosition
)
:
mCheckpoint
(
aCheckpoint
)
mProgress
(
aProgress
)
mPosition
(
aPosition
)
{
MOZ_RELEASE_ASSERT
(
aPosition
.
IsValid
(
)
)
;
MOZ_RELEASE_ASSERT
(
aPosition
.
mKind
!
=
BreakpointPosition
:
:
OnPop
|
|
aPosition
.
mScript
!
=
BreakpointPosition
:
:
EMPTY_SCRIPT
)
;
MOZ_RELEASE_ASSERT
(
aPosition
.
mKind
!
=
BreakpointPosition
:
:
Break
)
;
}
bool
HasPosition
(
)
const
{
return
mPosition
.
IsValid
(
)
;
}
inline
bool
operator
=
=
(
const
ExecutionPoint
&
o
)
const
{
return
mCheckpoint
=
=
o
.
mCheckpoint
&
&
mProgress
=
=
o
.
mProgress
&
&
mPosition
=
=
o
.
mPosition
;
}
inline
bool
operator
!
=
(
const
ExecutionPoint
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
}
;
typedef
InfallibleVector
<
char16_t
>
CharBuffer
;
bool
HitBreakpoint
(
JSContext
*
aCx
size_t
id
)
;
void
SetupDevtoolsSandbox
(
)
;
void
ProcessRequest
(
const
char16_t
*
aRequest
size_t
aRequestLength
CharBuffer
*
aResponse
)
;
void
EnsurePositionHandler
(
const
BreakpointPosition
&
aPosition
)
;
void
ClearPositionHandlers
(
)
;
void
ClearPausedState
(
)
;
Maybe
<
BreakpointPosition
>
GetEntryPosition
(
const
BreakpointPosition
&
aPosition
)
;
}
}
}
#
endif
