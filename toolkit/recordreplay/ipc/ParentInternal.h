#
ifndef
mozilla_recordreplay_ParentInternal_h
#
define
mozilla_recordreplay_ParentInternal_h
#
include
"
ParentIPC
.
h
"
#
include
"
Channel
.
h
"
#
include
"
mozilla
/
ipc
/
GeckoChildProcessHost
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
class
ChildProcessInfo
;
MessageLoop
*
MainThreadMessageLoop
(
)
;
void
PreferencesLoaded
(
)
;
bool
CanRewind
(
)
;
bool
ActiveChildIsRecording
(
)
;
ChildProcessInfo
*
ActiveRecordingChild
(
)
;
bool
MainThreadIsWaitingForIPDLReply
(
)
;
void
InitializeForwarding
(
)
;
void
Shutdown
(
)
;
static
Monitor
*
gMonitor
;
void
Resume
(
bool
aForward
)
;
void
Pause
(
)
;
void
SendRequest
(
const
js
:
:
CharBuffer
&
aBuffer
js
:
:
CharBuffer
*
aResponse
)
;
void
SetBreakpoint
(
size_t
aId
const
js
:
:
BreakpointPosition
&
aPosition
)
;
extern
void
*
gGraphicsMemory
;
void
InitializeGraphicsMemory
(
)
;
void
SendGraphicsMemoryToChild
(
)
;
void
UpdateGraphicsInUIProcess
(
const
PaintMessage
*
aMsg
)
;
static
const
int32_t
GraphicsHandshakeMessageId
=
42
;
static
const
int32_t
GraphicsMemoryMessageId
=
43
;
static
const
size_t
GraphicsMemorySize
=
4096
*
4096
*
4
;
class
ChildRole
{
public
:
#
define
ForEachRoleType
(
Macro
)
\
Macro
(
Active
)
\
Macro
(
Standby
)
\
Macro
(
Inert
)
enum
Type
{
#
define
DefineType
(
Name
)
Name
ForEachRoleType
(
DefineType
)
#
undef
DefineType
}
;
static
const
char
*
TypeString
(
Type
aType
)
{
switch
(
aType
)
{
#
define
GetTypeString
(
Name
)
case
Name
:
return
#
Name
;
ForEachRoleType
(
GetTypeString
)
#
undef
GetTypeString
default
:
MOZ_CRASH
(
"
Bad
ChildRole
type
"
)
;
}
}
protected
:
ChildProcessInfo
*
mProcess
;
Type
mType
;
explicit
ChildRole
(
Type
aType
)
:
mProcess
(
nullptr
)
mType
(
aType
)
{
}
public
:
void
SetProcess
(
ChildProcessInfo
*
aProcess
)
{
MOZ_RELEASE_ASSERT
(
!
mProcess
)
;
mProcess
=
aProcess
;
}
Type
GetType
(
)
const
{
return
mType
;
}
virtual
~
ChildRole
(
)
{
}
virtual
void
Initialize
(
)
{
}
virtual
void
Poke
(
)
{
}
virtual
void
OnIncomingMessage
(
const
Message
&
aMsg
)
=
0
;
}
;
extern
ipc
:
:
GeckoChildProcessHost
*
gRecordingProcess
;
class
ChildProcessInfo
{
Channel
*
mChannel
;
TimeStamp
mLastMessageTime
;
bool
mRecording
;
enum
class
RecoveryStage
{
None
ReachingCheckpoint
PlayingMessages
}
;
RecoveryStage
mRecoveryStage
;
bool
mPaused
;
Message
*
mPausedMessage
;
size_t
mLastCheckpoint
;
InfallibleVector
<
Message
*
>
mMessages
;
size_t
mNumRecoveredMessages
;
size_t
mNumRestarts
;
UniquePtr
<
ChildRole
>
mRole
;
InfallibleVector
<
size_t
>
mShouldSaveCheckpoints
;
InfallibleVector
<
size_t
>
mMajorCheckpoints
;
bool
mPauseNeeded
;
void
OnIncomingMessage
(
size_t
aChannelId
const
Message
&
aMsg
)
;
void
OnIncomingRecoveryMessage
(
const
Message
&
aMsg
)
;
void
SendNextRecoveryMessage
(
)
;
void
SendMessageRaw
(
const
Message
&
aMsg
)
;
static
void
MaybeProcessPendingMessageRunnable
(
)
;
void
ReceiveChildMessageOnMainThread
(
size_t
aChannelId
Message
*
aMsg
)
;
enum
Disposition
{
AtLastCheckpoint
BeforeLastCheckpoint
AfterLastCheckpoint
}
;
Disposition
GetDisposition
(
)
;
void
Recover
(
bool
aPaused
Message
*
aPausedMessage
size_t
aLastCheckpoint
Message
*
*
aMessages
size_t
aNumMessages
)
;
bool
CanRestart
(
)
;
void
AttemptRestart
(
const
char
*
aWhy
)
;
void
LaunchSubprocess
(
)
;
public
:
ChildProcessInfo
(
UniquePtr
<
ChildRole
>
aRole
bool
aRecording
)
;
~
ChildProcessInfo
(
)
;
ChildRole
*
Role
(
)
{
return
mRole
.
get
(
)
;
}
size_t
GetId
(
)
{
return
mChannel
-
>
GetId
(
)
;
}
bool
IsRecording
(
)
{
return
mRecording
;
}
size_t
LastCheckpoint
(
)
{
return
mLastCheckpoint
;
}
bool
IsRecovering
(
)
{
return
mRecoveryStage
!
=
RecoveryStage
:
:
None
;
}
bool
PauseNeeded
(
)
{
return
mPauseNeeded
;
}
const
InfallibleVector
<
size_t
>
&
MajorCheckpoints
(
)
{
return
mMajorCheckpoints
;
}
bool
IsPaused
(
)
{
return
mPaused
;
}
bool
IsPausedAtCheckpoint
(
)
;
bool
IsPausedAtRecordingEndpoint
(
)
;
typedef
std
:
:
function
<
bool
(
js
:
:
BreakpointPosition
:
:
Kind
)
>
BreakpointFilter
;
bool
IsPausedAtMatchingBreakpoint
(
const
BreakpointFilter
&
aFilter
)
;
size_t
MostRecentCheckpoint
(
)
{
return
(
GetDisposition
(
)
=
=
BeforeLastCheckpoint
)
?
mLastCheckpoint
-
1
:
mLastCheckpoint
;
}
size_t
RewindTargetCheckpoint
(
)
{
switch
(
GetDisposition
(
)
)
{
case
BeforeLastCheckpoint
:
case
AtLastCheckpoint
:
return
LastCheckpoint
(
)
-
1
;
case
AfterLastCheckpoint
:
return
LastCheckpoint
(
)
;
}
}
bool
ShouldSaveCheckpoint
(
size_t
aId
)
{
return
VectorContains
(
mShouldSaveCheckpoints
aId
)
;
}
bool
IsMajorCheckpoint
(
size_t
aId
)
{
return
VectorContains
(
mMajorCheckpoints
aId
)
;
}
bool
HasSavedCheckpoint
(
size_t
aId
)
{
return
(
aId
<
=
MostRecentCheckpoint
(
)
)
&
&
ShouldSaveCheckpoint
(
aId
)
;
}
size_t
MostRecentSavedCheckpoint
(
)
{
size_t
id
=
MostRecentCheckpoint
(
)
;
while
(
!
ShouldSaveCheckpoint
(
id
)
)
{
id
-
-
;
}
return
id
;
}
void
SetPauseNeeded
(
)
{
MOZ_RELEASE_ASSERT
(
!
mPauseNeeded
)
;
mPauseNeeded
=
true
;
}
void
ClearPauseNeeded
(
)
{
MOZ_RELEASE_ASSERT
(
IsPaused
(
)
)
;
mPauseNeeded
=
false
;
mRole
-
>
Poke
(
)
;
}
void
AddMajorCheckpoint
(
size_t
aId
)
;
void
SetRole
(
UniquePtr
<
ChildRole
>
aRole
)
;
void
SendMessage
(
const
Message
&
aMessage
)
;
void
Recover
(
ChildProcessInfo
*
aTargetProcess
)
;
void
RecoverToCheckpoint
(
size_t
aCheckpoint
)
;
void
WaitUntil
(
const
std
:
:
function
<
bool
(
)
>
&
aCallback
)
;
void
WaitUntilPaused
(
)
{
WaitUntil
(
[
=
]
(
)
{
return
IsPaused
(
)
;
}
)
;
}
static
bool
MaybeProcessPendingMessage
(
ChildProcessInfo
*
aProcess
)
;
static
void
SetIntroductionMessage
(
IntroductionMessage
*
aMessage
)
;
}
;
}
}
}
#
endif
