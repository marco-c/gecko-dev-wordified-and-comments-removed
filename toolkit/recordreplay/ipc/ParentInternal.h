#
ifndef
mozilla_recordreplay_ParentInternal_h
#
define
mozilla_recordreplay_ParentInternal_h
#
include
"
ParentIPC
.
h
"
#
include
"
Channel
.
h
"
#
include
"
mozilla
/
ipc
/
GeckoChildProcessHost
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
class
ChildProcessInfo
;
MessageLoop
*
MainThreadMessageLoop
(
)
;
void
ChromeRegistered
(
)
;
bool
CanRewind
(
)
;
ChildProcessInfo
*
GetActiveChild
(
)
;
ChildProcessInfo
*
GetChildProcess
(
size_t
aId
)
;
size_t
SpawnReplayingChild
(
)
;
void
SetActiveChild
(
ChildProcessInfo
*
aChild
)
;
bool
MainThreadIsWaitingForIPDLReply
(
)
;
void
ResumeBeforeWaitingForIPDLReply
(
)
;
void
MaybeHandlePendingSyncMessage
(
)
;
void
InitializeForwarding
(
)
;
void
Shutdown
(
)
;
static
Monitor
*
gMonitor
;
extern
void
*
gGraphicsMemory
;
void
InitializeGraphicsMemory
(
)
;
void
SendGraphicsMemoryToChild
(
)
;
void
UpdateGraphicsAfterPaint
(
const
PaintMessage
&
aMsg
)
;
void
UpdateGraphicsAfterRepaint
(
const
nsACString
&
imageData
)
;
void
RestoreMainGraphics
(
)
;
void
ClearGraphics
(
)
;
static
const
int32_t
GraphicsHandshakeMessageId
=
42
;
static
const
int32_t
GraphicsMemoryMessageId
=
43
;
static
const
size_t
GraphicsMemorySize
=
4096
*
4096
*
4
;
bool
InRepaintStressMode
(
)
;
extern
ipc
:
:
GeckoChildProcessHost
*
gRecordingProcess
;
struct
RecordingProcessData
{
const
base
:
:
SharedMemoryHandle
&
mPrefsHandle
;
const
ipc
:
:
FileDescriptor
&
mPrefMapHandle
;
RecordingProcessData
(
const
base
:
:
SharedMemoryHandle
&
aPrefsHandle
const
ipc
:
:
FileDescriptor
&
aPrefMapHandle
)
:
mPrefsHandle
(
aPrefsHandle
)
mPrefMapHandle
(
aPrefMapHandle
)
{
}
}
;
class
ChildProcessInfo
{
Channel
*
mChannel
=
nullptr
;
bool
mRecording
=
false
;
bool
mPaused
=
false
;
bool
mHasBegunFatalError
=
false
;
bool
mHasFatalError
=
false
;
bool
mMightRewind
=
false
;
bool
mSentTerminateMessage
=
false
;
TimeStamp
mLastPingTime
;
struct
PingInfo
{
uint32_t
mId
;
uint64_t
mProgress
;
explicit
PingInfo
(
uint32_t
aId
)
:
mId
(
aId
)
mProgress
(
0
)
{
}
}
;
InfallibleVector
<
PingInfo
>
mPings
;
void
OnIncomingMessage
(
const
Message
&
aMsg
)
;
static
void
MaybeProcessPendingMessageRunnable
(
)
;
void
ReceiveChildMessageOnMainThread
(
Message
:
:
UniquePtr
aMsg
)
;
bool
IsHanged
(
)
;
void
OnPingResponse
(
const
PingResponseMessage
&
aMsg
)
;
void
OnCrash
(
const
char
*
aWhy
)
;
void
LaunchSubprocess
(
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
;
public
:
explicit
ChildProcessInfo
(
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
;
~
ChildProcessInfo
(
)
;
size_t
GetId
(
)
{
return
mChannel
-
>
GetId
(
)
;
}
bool
IsRecording
(
)
{
return
mRecording
;
}
bool
IsPaused
(
)
{
return
mPaused
;
}
bool
HasCrashed
(
)
{
return
mHasFatalError
;
}
void
SendMessage
(
Message
&
&
aMessage
)
;
void
WaitUntilPaused
(
)
;
static
void
SetIntroductionMessage
(
IntroductionMessage
*
aMessage
)
;
void
ResetPings
(
bool
aMightRewind
)
;
void
MaybePing
(
)
;
}
;
}
}
}
#
endif
