#
include
"
ChildIPC
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
chrome
/
common
/
child_thread
.
h
"
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
ipc
/
Channel
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
MemorySnapshot
.
h
"
#
include
"
Monitor
.
h
"
#
include
"
ParentInternal
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ProcessRedirect
.
h
"
#
include
"
ProcessRewind
.
h
"
#
include
"
Thread
.
h
"
#
include
"
Units
.
h
"
#
include
<
algorithm
>
#
include
<
mach
/
mach_vm
.
h
>
#
include
<
unistd
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
namespace
child
{
static
Monitor
*
gMonitor
;
Channel
*
gChannel
;
static
base
:
:
ProcessId
gMiddlemanPid
;
static
base
:
:
ProcessId
gParentPid
;
static
StaticInfallibleVector
<
char
*
>
gParentArgv
;
static
char
*
gShmemPrefs
;
static
size_t
gShmemPrefsLen
;
static
FileHandle
gCheckpointWriteFd
;
static
FileHandle
gCheckpointReadFd
;
static
IntroductionMessage
*
gIntroductionMessage
;
static
void
ChannelMessageHandler
(
Message
*
aMsg
)
{
MOZ_RELEASE_ASSERT
(
MainThreadShouldPause
(
)
|
|
aMsg
-
>
mType
=
=
MessageType
:
:
CreateCheckpoint
|
|
aMsg
-
>
mType
=
=
MessageType
:
:
Terminate
)
;
switch
(
aMsg
-
>
mType
)
{
case
MessageType
:
:
Introduction
:
{
MOZ_RELEASE_ASSERT
(
!
gIntroductionMessage
)
;
gIntroductionMessage
=
(
IntroductionMessage
*
)
aMsg
-
>
Clone
(
)
;
break
;
}
case
MessageType
:
:
CreateCheckpoint
:
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
)
;
uint8_t
data
=
0
;
DirectWrite
(
gCheckpointWriteFd
&
data
1
)
;
break
;
}
case
MessageType
:
:
Terminate
:
{
PrintSpew
(
"
Terminate
message
received
exiting
.
.
.
\
n
"
)
;
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
)
;
_exit
(
0
)
;
}
case
MessageType
:
:
SetIsActive
:
{
const
SetIsActiveMessage
&
nmsg
=
(
const
SetIsActiveMessage
&
)
*
aMsg
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
SetIsActiveChild
(
nmsg
.
mActive
)
;
}
)
;
break
;
}
case
MessageType
:
:
SetAllowIntentionalCrashes
:
{
const
SetAllowIntentionalCrashesMessage
&
nmsg
=
(
const
SetAllowIntentionalCrashesMessage
&
)
*
aMsg
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
SetAllowIntentionalCrashes
(
nmsg
.
mAllowed
)
;
}
)
;
break
;
}
case
MessageType
:
:
SetSaveCheckpoint
:
{
const
SetSaveCheckpointMessage
&
nmsg
=
(
const
SetSaveCheckpointMessage
&
)
*
aMsg
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
SetSaveCheckpoint
(
nmsg
.
mCheckpoint
nmsg
.
mSave
)
;
}
)
;
break
;
}
case
MessageType
:
:
FlushRecording
:
{
PauseMainThreadAndInvokeCallback
(
FlushRecording
)
;
break
;
}
case
MessageType
:
:
DebuggerRequest
:
{
const
DebuggerRequestMessage
&
nmsg
=
(
const
DebuggerRequestMessage
&
)
*
aMsg
;
JS
:
:
replay
:
:
CharBuffer
*
buf
=
js_new
<
JS
:
:
replay
:
:
CharBuffer
>
(
)
;
if
(
!
buf
-
>
append
(
nmsg
.
Buffer
(
)
nmsg
.
BufferSize
(
)
)
)
{
MOZ_CRASH
(
)
;
}
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
JS
:
:
replay
:
:
hooks
.
debugRequestReplay
(
buf
)
;
}
)
;
break
;
}
case
MessageType
:
:
SetBreakpoint
:
{
const
SetBreakpointMessage
&
nmsg
=
(
const
SetBreakpointMessage
&
)
*
aMsg
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
JS
:
:
replay
:
:
hooks
.
setBreakpointReplay
(
nmsg
.
mId
nmsg
.
mPosition
)
;
}
)
;
break
;
}
case
MessageType
:
:
Resume
:
{
const
ResumeMessage
&
nmsg
=
(
const
ResumeMessage
&
)
*
aMsg
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
if
(
JS
:
:
replay
:
:
hooks
.
resumeReplay
)
{
JS
:
:
replay
:
:
hooks
.
resumeReplay
(
nmsg
.
mForward
)
;
}
else
{
ResumeExecution
(
)
;
}
}
)
;
break
;
}
case
MessageType
:
:
RestoreCheckpoint
:
{
const
RestoreCheckpointMessage
&
nmsg
=
(
const
RestoreCheckpointMessage
&
)
*
aMsg
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
JS
:
:
replay
:
:
hooks
.
restoreCheckpointReplay
(
nmsg
.
mCheckpoint
)
;
}
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
free
(
aMsg
)
;
}
char
*
PrefsShmemContents
(
size_t
aPrefsLen
)
{
MOZ_RELEASE_ASSERT
(
aPrefsLen
=
=
gShmemPrefsLen
)
;
return
gShmemPrefs
;
}
static
void
InitDebuggerHooks
(
)
;
static
void
HitCheckpoint
(
size_t
aId
bool
aRecordingEndpoint
)
;
static
void
ListenForCheckpointThreadMain
(
void
*
)
{
while
(
true
)
{
uint8_t
data
=
0
;
ssize_t
rv
=
read
(
gCheckpointReadFd
&
data
1
)
;
if
(
rv
>
0
)
{
NS_DispatchToMainThread
(
NewRunnableFunction
(
"
NewCheckpoint
"
NewCheckpoint
false
)
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
errno
=
=
EINTR
)
;
}
}
}
void
*
gGraphicsShmem
;
void
InitRecordingOrReplayingProcess
(
int
*
aArgc
char
*
*
*
aArgv
)
{
if
(
!
IsRecordingOrReplaying
(
)
)
{
return
;
}
Maybe
<
int
>
middlemanPid
;
Maybe
<
int
>
channelID
;
for
(
int
i
=
0
;
i
<
*
aArgc
;
i
+
+
)
{
if
(
!
strcmp
(
(
*
aArgv
)
[
i
]
gMiddlemanPidOption
)
)
{
MOZ_RELEASE_ASSERT
(
middlemanPid
.
isNothing
(
)
&
&
i
+
1
<
*
aArgc
)
;
middlemanPid
.
emplace
(
atoi
(
(
*
aArgv
)
[
i
+
1
]
)
)
;
}
if
(
!
strcmp
(
(
*
aArgv
)
[
i
]
gChannelIDOption
)
)
{
MOZ_RELEASE_ASSERT
(
channelID
.
isNothing
(
)
&
&
i
+
1
<
*
aArgc
)
;
channelID
.
emplace
(
atoi
(
(
*
aArgv
)
[
i
+
1
]
)
)
;
}
}
MOZ_RELEASE_ASSERT
(
middlemanPid
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
channelID
.
isSome
(
)
)
;
gMiddlemanPid
=
middlemanPid
.
ref
(
)
;
Maybe
<
AutoPassThroughThreadEvents
>
pt
;
pt
.
emplace
(
)
;
gMonitor
=
new
Monitor
(
)
;
gChannel
=
new
Channel
(
channelID
.
ref
(
)
ChannelMessageHandler
)
;
pt
.
reset
(
)
;
DirectCreatePipe
(
&
gCheckpointWriteFd
&
gCheckpointReadFd
)
;
Thread
:
:
StartThread
(
ListenForCheckpointThreadMain
nullptr
false
)
;
InitDebuggerHooks
(
)
;
pt
.
emplace
(
)
;
ReceivePort
receivePort
(
nsPrintfCString
(
"
WebReplay
.
%
d
.
%
d
"
gMiddlemanPid
(
int
)
channelID
.
ref
(
)
)
.
get
(
)
)
;
MachSendMessage
handshakeMessage
(
parent
:
:
GraphicsHandshakeMessageId
)
;
handshakeMessage
.
AddDescriptor
(
MachMsgPortDescriptor
(
receivePort
.
GetPort
(
)
MACH_MSG_TYPE_COPY_SEND
)
)
;
MachPortSender
sender
(
nsPrintfCString
(
"
WebReplay
.
%
d
"
gMiddlemanPid
)
.
get
(
)
)
;
kern_return_t
kr
=
sender
.
SendMessage
(
handshakeMessage
1000
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MachReceiveMessage
message
;
kr
=
receivePort
.
WaitForMessage
(
&
message
0
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
message
.
GetMessageID
(
)
=
=
parent
:
:
GraphicsMemoryMessageId
)
;
mach_port_t
graphicsPort
=
message
.
GetTranslatedPort
(
0
)
;
MOZ_RELEASE_ASSERT
(
graphicsPort
!
=
MACH_PORT_NULL
)
;
mach_vm_address_t
address
=
0
;
kr
=
mach_vm_map
(
mach_task_self
(
)
&
address
parent
:
:
GraphicsMemorySize
0
VM_FLAGS_ANYWHERE
graphicsPort
0
false
VM_PROT_READ
|
VM_PROT_WRITE
VM_PROT_READ
|
VM_PROT_WRITE
VM_INHERIT_NONE
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
gGraphicsShmem
=
(
void
*
)
address
;
pt
.
reset
(
)
;
HitCheckpoint
(
CheckpointId
:
:
Invalid
false
)
;
MOZ_RELEASE_ASSERT
(
!
gShmemPrefs
)
;
MOZ_RELEASE_ASSERT
(
gParentArgv
.
empty
(
)
)
;
gParentPid
=
gIntroductionMessage
-
>
mParentPid
;
{
IntroductionMessage
*
msg
=
IntroductionMessage
:
:
RecordReplay
(
*
gIntroductionMessage
)
;
gShmemPrefs
=
new
char
[
msg
-
>
mPrefsLen
]
;
memcpy
(
gShmemPrefs
msg
-
>
PrefsData
(
)
msg
-
>
mPrefsLen
)
;
gShmemPrefsLen
=
msg
-
>
mPrefsLen
;
const
char
*
pos
=
msg
-
>
ArgvString
(
)
;
for
(
size_t
i
=
0
;
i
<
msg
-
>
mArgc
;
i
+
+
)
{
gParentArgv
.
append
(
strdup
(
pos
)
)
;
pos
+
=
strlen
(
pos
)
+
1
;
}
free
(
msg
)
;
}
free
(
gIntroductionMessage
)
;
gIntroductionMessage
=
nullptr
;
gParentArgv
.
append
(
nullptr
)
;
MOZ_RELEASE_ASSERT
(
*
aArgc
>
=
1
)
;
MOZ_RELEASE_ASSERT
(
!
strcmp
(
(
*
aArgv
)
[
0
]
gParentArgv
[
0
]
)
)
;
MOZ_RELEASE_ASSERT
(
gParentArgv
.
back
(
)
=
=
nullptr
)
;
*
aArgc
=
gParentArgv
.
length
(
)
-
1
;
*
aArgv
=
gParentArgv
.
begin
(
)
;
if
(
gInitializationFailureMessage
)
{
ReportFatalError
(
"
%
s
"
gInitializationFailureMessage
)
;
Unreachable
(
)
;
}
}
base
:
:
ProcessId
MiddlemanProcessId
(
)
{
return
gMiddlemanPid
;
}
base
:
:
ProcessId
ParentProcessId
(
)
{
return
gParentPid
;
}
void
ReportFatalError
(
const
char
*
aFormat
.
.
.
)
{
va_list
ap
;
va_start
(
ap
aFormat
)
;
char
buf
[
2048
]
;
VsprintfLiteral
(
buf
aFormat
ap
)
;
va_end
(
ap
)
;
char
msgBuf
[
4096
]
;
size_t
header
=
sizeof
(
FatalErrorMessage
)
;
size_t
len
=
std
:
:
min
(
strlen
(
buf
)
+
1
sizeof
(
msgBuf
)
-
header
)
;
FatalErrorMessage
*
msg
=
new
(
msgBuf
)
FatalErrorMessage
(
header
+
len
)
;
memcpy
(
&
msgBuf
[
header
]
buf
len
)
;
msgBuf
[
sizeof
(
msgBuf
)
-
1
]
=
0
;
gChannel
-
>
SendMessage
(
*
msg
)
;
DirectPrint
(
"
*
*
*
*
*
Fatal
Record
/
Replay
Error
*
*
*
*
*
\
n
"
)
;
DirectPrint
(
buf
)
;
DirectPrint
(
"
\
n
"
)
;
UnrecoverableSnapshotFailure
(
)
;
Thread
:
:
WaitForeverNoIdle
(
)
;
}
void
NotifyFlushedRecording
(
)
{
gChannel
-
>
SendMessage
(
RecordingFlushedMessage
(
)
)
;
}
void
NotifyAlwaysMarkMajorCheckpoints
(
)
{
if
(
IsActiveChild
(
)
)
{
gChannel
-
>
SendMessage
(
AlwaysMarkMajorCheckpointsMessage
(
)
)
;
}
}
static
double
gLastCheckpointTime
;
static
double
gIdleTimeStart
;
void
BeginIdleTime
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
&
&
NS_IsMainThread
(
)
&
&
!
gIdleTimeStart
)
;
gIdleTimeStart
=
CurrentTime
(
)
;
}
void
EndIdleTime
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
&
&
NS_IsMainThread
(
)
&
&
gIdleTimeStart
)
;
gLastCheckpointTime
+
=
CurrentTime
(
)
-
gIdleTimeStart
;
gIdleTimeStart
=
0
;
}
static
void
HitCheckpoint
(
size_t
aId
bool
aRecordingEndpoint
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
double
time
=
CurrentTime
(
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
double
duration
=
0
;
if
(
aId
>
CheckpointId
:
:
First
)
{
duration
=
time
-
gLastCheckpointTime
;
MOZ_RELEASE_ASSERT
(
duration
>
0
)
;
}
gChannel
-
>
SendMessage
(
HitCheckpointMessage
(
aId
aRecordingEndpoint
duration
)
)
;
}
)
;
gLastCheckpointTime
=
time
;
}
static
void
DebuggerResponseHook
(
const
JS
:
:
replay
:
:
CharBuffer
&
aBuffer
)
{
DebuggerResponseMessage
*
msg
=
DebuggerResponseMessage
:
:
New
(
aBuffer
.
begin
(
)
aBuffer
.
length
(
)
)
;
gChannel
-
>
SendMessage
(
*
msg
)
;
free
(
msg
)
;
}
static
void
HitBreakpoint
(
bool
aRecordingEndpoint
const
uint32_t
*
aBreakpoints
size_t
aNumBreakpoints
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
HitBreakpointMessage
*
msg
=
HitBreakpointMessage
:
:
New
(
aRecordingEndpoint
aBreakpoints
aNumBreakpoints
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
gChannel
-
>
SendMessage
(
*
msg
)
;
free
(
msg
)
;
}
)
;
}
static
void
PauseAfterRecoveringFromDivergence
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
JS
:
:
replay
:
:
hooks
.
respondAfterRecoveringFromDivergence
(
)
;
}
)
;
}
static
void
InitDebuggerHooks
(
)
{
JS
:
:
replay
:
:
hooks
.
hitBreakpointReplay
=
HitBreakpoint
;
JS
:
:
replay
:
:
hooks
.
hitCheckpointReplay
=
HitCheckpoint
;
JS
:
:
replay
:
:
hooks
.
debugResponseReplay
=
DebuggerResponseHook
;
JS
:
:
replay
:
:
hooks
.
pauseAndRespondAfterRecoveringFromDivergence
=
PauseAfterRecoveringFromDivergence
;
JS
:
:
replay
:
:
hooks
.
hitCurrentRecordingEndpointReplay
=
HitRecordingEndpoint
;
JS
:
:
replay
:
:
hooks
.
canRewindReplay
=
HasSavedCheckpoint
;
}
}
}
}
