#
include
"
ChildInternal
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
chrome
/
common
/
child_thread
.
h
"
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
ipc
/
Channel
.
h
"
#
include
"
mac
/
handler
/
exception_handler
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
MemorySnapshot
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
ParentInternal
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ProcessRedirect
.
h
"
#
include
"
ProcessRewind
.
h
"
#
include
"
Thread
.
h
"
#
include
"
Units
.
h
"
#
include
"
imgIEncoder
.
h
"
#
include
<
algorithm
>
#
include
<
mach
/
mach_vm
.
h
>
#
include
<
unistd
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
namespace
child
{
Monitor
*
gMonitor
;
Channel
*
gChannel
;
static
base
:
:
ProcessId
gMiddlemanPid
;
static
base
:
:
ProcessId
gParentPid
;
static
StaticInfallibleVector
<
char
*
>
gParentArgv
;
static
FileHandle
gCheckpointWriteFd
;
static
FileHandle
gCheckpointReadFd
;
static
UniquePtr
<
IntroductionMessage
Message
:
:
FreePolicy
>
gIntroductionMessage
;
static
bool
gDebuggerRunsInMiddleman
;
static
UniquePtr
<
MiddlemanCallResponseMessage
Message
:
:
FreePolicy
>
gCallResponseMessage
;
static
bool
gWaitingForCallResponse
;
static
void
ChannelMessageHandler
(
Message
:
:
UniquePtr
aMsg
)
{
MOZ_RELEASE_ASSERT
(
MainThreadShouldPause
(
)
|
|
aMsg
-
>
CanBeSentWhileUnpaused
(
)
)
;
switch
(
aMsg
-
>
mType
)
{
case
MessageType
:
:
Introduction
:
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
!
gIntroductionMessage
)
;
gIntroductionMessage
.
reset
(
static_cast
<
IntroductionMessage
*
>
(
aMsg
.
release
(
)
)
)
;
gMonitor
-
>
NotifyAll
(
)
;
break
;
}
case
MessageType
:
:
CreateCheckpoint
:
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
)
;
if
(
js
:
:
IsInitialized
(
)
)
{
uint8_t
data
=
0
;
DirectWrite
(
gCheckpointWriteFd
&
data
1
)
;
}
break
;
}
case
MessageType
:
:
SetDebuggerRunsInMiddleman
:
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
gDebuggerRunsInMiddleman
=
true
;
}
)
;
break
;
}
case
MessageType
:
:
Terminate
:
{
if
(
IsRecording
(
)
)
{
PrintSpew
(
"
Terminate
message
received
exiting
.
.
.
\
n
"
)
;
_exit
(
0
)
;
}
else
{
ReportFatalError
(
Nothing
(
)
"
Hung
replaying
process
"
)
;
}
break
;
}
case
MessageType
:
:
ManifestStart
:
{
const
ManifestStartMessage
&
nmsg
=
(
const
ManifestStartMessage
&
)
*
aMsg
;
js
:
:
CharBuffer
*
buf
=
new
js
:
:
CharBuffer
(
)
;
buf
-
>
append
(
nmsg
.
Buffer
(
)
nmsg
.
BufferSize
(
)
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
js
:
:
ManifestStart
(
*
buf
)
;
delete
buf
;
}
)
;
break
;
}
case
MessageType
:
:
MiddlemanCallResponse
:
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
gWaitingForCallResponse
)
;
MOZ_RELEASE_ASSERT
(
!
gCallResponseMessage
)
;
gCallResponseMessage
.
reset
(
static_cast
<
MiddlemanCallResponseMessage
*
>
(
aMsg
.
release
(
)
)
)
;
gMonitor
-
>
NotifyAll
(
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
}
static
void
ListenForCheckpointThreadMain
(
void
*
)
{
while
(
true
)
{
uint8_t
data
=
0
;
ssize_t
rv
=
HANDLE_EINTR
(
read
(
gCheckpointReadFd
&
data
1
)
)
;
if
(
rv
>
0
)
{
NS_DispatchToMainThread
(
NewRunnableFunction
(
"
NewCheckpoint
"
NewCheckpoint
)
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
errno
=
=
EIO
)
;
MOZ_RELEASE_ASSERT
(
HasDivergedFromRecording
(
)
)
;
Thread
:
:
WaitForever
(
)
;
}
}
}
void
*
gGraphicsShmem
;
void
InitRecordingOrReplayingProcess
(
int
*
aArgc
char
*
*
*
aArgv
)
{
if
(
!
IsRecordingOrReplaying
(
)
)
{
return
;
}
Maybe
<
int
>
middlemanPid
;
Maybe
<
int
>
channelID
;
for
(
int
i
=
0
;
i
<
*
aArgc
;
i
+
+
)
{
if
(
!
strcmp
(
(
*
aArgv
)
[
i
]
gMiddlemanPidOption
)
)
{
MOZ_RELEASE_ASSERT
(
middlemanPid
.
isNothing
(
)
&
&
i
+
1
<
*
aArgc
)
;
middlemanPid
.
emplace
(
atoi
(
(
*
aArgv
)
[
i
+
1
]
)
)
;
}
if
(
!
strcmp
(
(
*
aArgv
)
[
i
]
gChannelIDOption
)
)
{
MOZ_RELEASE_ASSERT
(
channelID
.
isNothing
(
)
&
&
i
+
1
<
*
aArgc
)
;
channelID
.
emplace
(
atoi
(
(
*
aArgv
)
[
i
+
1
]
)
)
;
}
}
MOZ_RELEASE_ASSERT
(
middlemanPid
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
channelID
.
isSome
(
)
)
;
gMiddlemanPid
=
middlemanPid
.
ref
(
)
;
Maybe
<
AutoPassThroughThreadEvents
>
pt
;
pt
.
emplace
(
)
;
gMonitor
=
new
Monitor
(
)
;
gChannel
=
new
Channel
(
channelID
.
ref
(
)
false
ChannelMessageHandler
)
;
pt
.
reset
(
)
;
if
(
!
gInitializationFailureMessage
)
{
DirectCreatePipe
(
&
gCheckpointWriteFd
&
gCheckpointReadFd
)
;
Thread
:
:
StartThread
(
ListenForCheckpointThreadMain
nullptr
false
)
;
}
pt
.
emplace
(
)
;
ReceivePort
receivePort
(
nsPrintfCString
(
"
WebReplay
.
%
d
.
%
d
"
gMiddlemanPid
(
int
)
channelID
.
ref
(
)
)
.
get
(
)
)
;
MachSendMessage
handshakeMessage
(
parent
:
:
GraphicsHandshakeMessageId
)
;
handshakeMessage
.
AddDescriptor
(
MachMsgPortDescriptor
(
receivePort
.
GetPort
(
)
MACH_MSG_TYPE_COPY_SEND
)
)
;
MachPortSender
sender
(
nsPrintfCString
(
"
WebReplay
.
%
d
"
gMiddlemanPid
)
.
get
(
)
)
;
kern_return_t
kr
=
sender
.
SendMessage
(
handshakeMessage
1000
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MachReceiveMessage
message
;
kr
=
receivePort
.
WaitForMessage
(
&
message
0
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
message
.
GetMessageID
(
)
=
=
parent
:
:
GraphicsMemoryMessageId
)
;
mach_port_t
graphicsPort
=
message
.
GetTranslatedPort
(
0
)
;
MOZ_RELEASE_ASSERT
(
graphicsPort
!
=
MACH_PORT_NULL
)
;
mach_vm_address_t
address
=
0
;
kr
=
mach_vm_map
(
mach_task_self
(
)
&
address
parent
:
:
GraphicsMemorySize
0
VM_FLAGS_ANYWHERE
graphicsPort
0
false
VM_PROT_READ
|
VM_PROT_WRITE
VM_PROT_READ
|
VM_PROT_WRITE
VM_INHERIT_NONE
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
gGraphicsShmem
=
(
void
*
)
address
;
AddInitialUntrackedMemoryRegion
(
(
uint8_t
*
)
gGraphicsShmem
parent
:
:
GraphicsMemorySize
)
;
pt
.
reset
(
)
;
if
(
gInitializationFailureMessage
)
{
ReportFatalError
(
Nothing
(
)
"
%
s
"
gInitializationFailureMessage
)
;
Unreachable
(
)
;
}
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
!
gIntroductionMessage
)
{
gMonitor
-
>
Wait
(
)
;
}
}
MOZ_RELEASE_ASSERT
(
gParentArgv
.
empty
(
)
)
;
gParentPid
=
gIntroductionMessage
-
>
mParentPid
;
{
IntroductionMessage
*
msg
=
IntroductionMessage
:
:
RecordReplay
(
*
gIntroductionMessage
)
;
const
char
*
pos
=
msg
-
>
ArgvString
(
)
;
for
(
size_t
i
=
0
;
i
<
msg
-
>
mArgc
;
i
+
+
)
{
gParentArgv
.
append
(
strdup
(
pos
)
)
;
pos
+
=
strlen
(
pos
)
+
1
;
}
free
(
msg
)
;
}
gIntroductionMessage
=
nullptr
;
gParentArgv
.
append
(
nullptr
)
;
MOZ_RELEASE_ASSERT
(
*
aArgc
>
=
1
)
;
MOZ_RELEASE_ASSERT
(
gParentArgv
.
back
(
)
=
=
nullptr
)
;
*
aArgc
=
gParentArgv
.
length
(
)
-
1
;
*
aArgv
=
gParentArgv
.
begin
(
)
;
}
base
:
:
ProcessId
MiddlemanProcessId
(
)
{
return
gMiddlemanPid
;
}
base
:
:
ProcessId
ParentProcessId
(
)
{
return
gParentPid
;
}
bool
DebuggerRunsInMiddleman
(
)
{
return
RecordReplayValue
(
gDebuggerRunsInMiddleman
)
;
}
void
CreateCheckpoint
(
)
{
if
(
!
HasDivergedFromRecording
(
)
)
{
NewCheckpoint
(
)
;
}
}
void
ReportFatalError
(
const
Maybe
<
MinidumpInfo
>
&
aMinidump
const
char
*
aFormat
.
.
.
)
{
gChannel
-
>
SendMessage
(
BeginFatalErrorMessage
(
)
)
;
UnrecoverableSnapshotFailure
(
)
;
AutoEnsurePassThroughThreadEvents
pt
;
#
ifdef
MOZ_CRASHREPORTER
MinidumpInfo
info
=
aMinidump
.
isSome
(
)
?
aMinidump
.
ref
(
)
:
MinidumpInfo
(
EXC_CRASH
1
0
mach_thread_self
(
)
)
;
google_breakpad
:
:
ExceptionHandler
:
:
WriteForwardedExceptionMinidump
(
info
.
mExceptionType
info
.
mCode
info
.
mSubcode
info
.
mThread
)
;
#
endif
va_list
ap
;
va_start
(
ap
aFormat
)
;
char
buf
[
2048
]
;
VsprintfLiteral
(
buf
aFormat
ap
)
;
va_end
(
ap
)
;
char
msgBuf
[
4096
]
;
size_t
header
=
sizeof
(
FatalErrorMessage
)
;
size_t
len
=
std
:
:
min
(
strlen
(
buf
)
+
1
sizeof
(
msgBuf
)
-
header
)
;
FatalErrorMessage
*
msg
=
new
(
msgBuf
)
FatalErrorMessage
(
header
+
len
)
;
memcpy
(
&
msgBuf
[
header
]
buf
len
)
;
msgBuf
[
sizeof
(
msgBuf
)
-
1
]
=
0
;
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
DirectPrint
(
"
*
*
*
*
*
Fatal
Record
/
Replay
Error
*
*
*
*
*
\
n
"
)
;
DirectPrint
(
buf
)
;
DirectPrint
(
"
\
n
"
)
;
Thread
:
:
WaitForeverNoIdle
(
)
;
}
size_t
GetId
(
)
{
return
gChannel
-
>
GetId
(
)
;
}
static
VsyncObserver
*
gVsyncObserver
;
void
SetVsyncObserver
(
VsyncObserver
*
aObserver
)
{
MOZ_RELEASE_ASSERT
(
!
gVsyncObserver
|
|
!
aObserver
)
;
gVsyncObserver
=
aObserver
;
}
void
NotifyVsyncObserver
(
)
{
if
(
gVsyncObserver
)
{
static
VsyncId
vsyncId
;
vsyncId
=
vsyncId
.
Next
(
)
;
VsyncEvent
event
(
vsyncId
TimeStamp
:
:
Now
(
)
)
;
gVsyncObserver
-
>
NotifyVsync
(
event
)
;
}
}
static
int32_t
gNumPendingMainThreadPaints
;
bool
OnVsync
(
)
{
if
(
parent
:
:
InRepaintStressMode
(
)
)
{
CreateCheckpoint
(
)
;
}
return
gNumPendingMainThreadPaints
=
=
0
;
}
static
void
*
gDrawTargetBuffer
;
static
size_t
gDrawTargetBufferSize
;
static
size_t
gPaintWidth
gPaintHeight
;
static
Atomic
<
int32_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gNumPendingPaints
;
static
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gCompositorThreadId
;
static
bool
gAllowRepaintFailures
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
DrawTargetForRemoteDrawing
(
LayoutDeviceIntSize
aSize
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
size_t
threadId
=
Thread
:
:
Current
(
)
-
>
Id
(
)
;
if
(
gCompositorThreadId
)
{
MOZ_RELEASE_ASSERT
(
threadId
=
=
gCompositorThreadId
)
;
}
else
{
gCompositorThreadId
=
threadId
;
}
if
(
aSize
.
IsEmpty
(
)
)
{
return
nullptr
;
}
gPaintWidth
=
aSize
.
width
;
gPaintHeight
=
aSize
.
height
;
gfx
:
:
IntSize
size
(
aSize
.
width
aSize
.
height
)
;
size_t
bufferSize
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBBufferSize
(
size
gSurfaceFormat
)
;
MOZ_RELEASE_ASSERT
(
bufferSize
<
=
parent
:
:
GraphicsMemorySize
)
;
if
(
bufferSize
!
=
gDrawTargetBufferSize
)
{
free
(
gDrawTargetBuffer
)
;
gDrawTargetBuffer
=
malloc
(
bufferSize
)
;
gDrawTargetBufferSize
=
bufferSize
;
}
size_t
stride
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBStride
(
gSurfaceFormat
aSize
.
width
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
drawTarget
=
gfx
:
:
Factory
:
:
CreateDrawTargetForData
(
gfx
:
:
BackendType
:
:
SKIA
(
uint8_t
*
)
gDrawTargetBuffer
size
stride
gSurfaceFormat
true
)
;
if
(
!
drawTarget
)
{
MOZ_CRASH
(
)
;
}
return
drawTarget
.
forget
(
)
;
}
void
NotifyPaintStart
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
gPainted
;
if
(
!
gPainted
)
{
gPainted
=
true
;
gAllowRepaintFailures
=
Preferences
:
:
GetBool
(
"
devtools
.
recordreplay
.
allowRepaintFailures
"
)
&
&
!
parent
:
:
InRepaintStressMode
(
)
;
}
gNumPendingPaints
+
+
;
gNumPendingMainThreadPaints
+
+
;
}
static
void
PaintFromMainThread
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
gNumPendingMainThreadPaints
-
-
;
if
(
gNumPendingMainThreadPaints
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
!
gNumPendingPaints
)
;
if
(
IsMainChild
(
)
&
&
gDrawTargetBuffer
)
{
memcpy
(
gGraphicsShmem
gDrawTargetBuffer
gDrawTargetBufferSize
)
;
gChannel
-
>
SendMessage
(
PaintMessage
(
GetLastCheckpoint
(
)
gPaintWidth
gPaintHeight
)
)
;
}
}
void
NotifyPaintComplete
(
)
{
MOZ_RELEASE_ASSERT
(
!
gCompositorThreadId
|
|
Thread
:
:
Current
(
)
-
>
Id
(
)
=
=
gCompositorThreadId
)
;
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
-
-
gNumPendingPaints
=
=
0
)
{
gMonitor
-
>
Notify
(
)
;
}
}
NS_DispatchToMainThread
(
NewRunnableFunction
(
"
PaintFromMainThread
"
PaintFromMainThread
)
)
;
}
static
bool
gDidRepaint
;
static
bool
gRepainting
;
bool
Repaint
(
nsAString
&
aData
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
HasDivergedFromRecording
(
)
)
;
if
(
!
gCompositorThreadId
)
{
return
false
;
}
if
(
!
gDidRepaint
)
{
gDidRepaint
=
true
;
gRepainting
=
true
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
Thread
:
:
GetById
(
i
)
-
>
SetShouldDivergeFromRecording
(
)
;
}
Thread
:
:
ResumeIdleThreads
(
)
;
NotifyVsyncObserver
(
)
;
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
gNumPendingPaints
)
{
gMonitor
-
>
Wait
(
)
;
}
}
Thread
:
:
WaitForIdleThreads
(
)
;
gRepainting
=
false
;
}
if
(
!
gDrawTargetBuffer
)
{
return
false
;
}
nsCString
encoderCID
(
"
mozilla
.
org
/
image
/
encoder
;
2
?
type
=
image
/
png
"
)
;
nsCOMPtr
<
imgIEncoder
>
encoder
=
do_CreateInstance
(
encoderCID
.
get
(
)
)
;
nsString
options
;
nsresult
rv
=
encoder
-
>
InitFromData
(
(
const
uint8_t
*
)
gDrawTargetBuffer
gPaintWidth
*
gPaintHeight
*
4
gPaintWidth
gPaintHeight
gPaintWidth
*
4
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
options
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
uint64_t
count
;
rv
=
encoder
-
>
Available
(
&
count
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
rv
=
Base64EncodeInputStream
(
encoder
aData
count
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
bool
CurrentRepaintCannotFail
(
)
{
return
gRepainting
&
&
!
gAllowRepaintFailures
;
}
void
ManifestFinished
(
const
js
:
:
CharBuffer
&
aBuffer
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
ManifestFinishedMessage
*
msg
=
ManifestFinishedMessage
:
:
New
(
aBuffer
.
begin
(
)
aBuffer
.
length
(
)
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
free
(
msg
)
;
}
)
;
}
void
SendMiddlemanCallRequest
(
const
char
*
aInputData
size_t
aInputSize
InfallibleVector
<
char
>
*
aOutputData
)
{
AutoPassThroughThreadEvents
pt
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
gWaitingForCallResponse
)
{
gMonitor
-
>
Wait
(
)
;
}
gWaitingForCallResponse
=
true
;
MiddlemanCallRequestMessage
*
msg
=
MiddlemanCallRequestMessage
:
:
New
(
aInputData
aInputSize
)
;
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
free
(
msg
)
;
while
(
!
gCallResponseMessage
)
{
gMonitor
-
>
Wait
(
)
;
}
aOutputData
-
>
append
(
gCallResponseMessage
-
>
BinaryData
(
)
gCallResponseMessage
-
>
BinaryDataSize
(
)
)
;
gCallResponseMessage
=
nullptr
;
gWaitingForCallResponse
=
false
;
gMonitor
-
>
Notify
(
)
;
}
void
SendResetMiddlemanCalls
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
gChannel
-
>
SendMessage
(
ResetMiddlemanCallsMessage
(
)
)
;
}
}
}
}
