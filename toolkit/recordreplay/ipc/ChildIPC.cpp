#
include
"
ChildInternal
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
chrome
/
common
/
child_thread
.
h
"
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
ipc
/
Channel
.
h
"
#
include
"
mac
/
handler
/
exception_handler
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
ParentInternal
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ProcessRedirect
.
h
"
#
include
"
ProcessRewind
.
h
"
#
include
"
Thread
.
h
"
#
include
"
Units
.
h
"
#
include
"
imgIEncoder
.
h
"
#
include
<
algorithm
>
#
include
<
mach
/
mach_vm
.
h
>
#
include
<
unistd
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
namespace
child
{
Monitor
*
gMonitor
;
Channel
*
gChannel
;
static
size_t
gForkId
;
static
base
:
:
ProcessId
gMiddlemanPid
;
static
base
:
:
ProcessId
gParentPid
;
static
StaticInfallibleVector
<
char
*
>
gParentArgv
;
static
FileHandle
gCheckpointWriteFd
;
static
FileHandle
gCheckpointReadFd
;
static
UniquePtr
<
IntroductionMessage
Message
:
:
FreePolicy
>
gIntroductionMessage
;
static
StaticInfallibleVector
<
char
>
gPendingRecordingData
;
static
bool
gDebuggerRunsInMiddleman
;
static
UniquePtr
<
ExternalCallResponseMessage
Message
:
:
FreePolicy
>
gCallResponseMessage
;
static
bool
gWaitingForCallResponse
;
static
void
HandleMessageToForkedProcess
(
Message
:
:
UniquePtr
aMsg
)
;
static
void
ChannelMessageHandler
(
Message
:
:
UniquePtr
aMsg
)
{
MOZ_RELEASE_ASSERT
(
MainThreadShouldPause
(
)
|
|
aMsg
-
>
CanBeSentWhileUnpaused
(
)
)
;
if
(
aMsg
-
>
mForkId
!
=
gForkId
)
{
MOZ_RELEASE_ASSERT
(
!
gForkId
)
;
HandleMessageToForkedProcess
(
std
:
:
move
(
aMsg
)
)
;
return
;
}
switch
(
aMsg
-
>
mType
)
{
case
MessageType
:
:
Introduction
:
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
!
gIntroductionMessage
)
;
gIntroductionMessage
.
reset
(
static_cast
<
IntroductionMessage
*
>
(
aMsg
.
release
(
)
)
)
;
gMonitor
-
>
NotifyAll
(
)
;
break
;
}
case
MessageType
:
:
CreateCheckpoint
:
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
)
;
if
(
js
:
:
IsInitialized
(
)
)
{
uint8_t
data
=
0
;
DirectWrite
(
gCheckpointWriteFd
&
data
1
)
;
}
break
;
}
case
MessageType
:
:
SetDebuggerRunsInMiddleman
:
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
gDebuggerRunsInMiddleman
=
true
;
}
)
;
break
;
}
case
MessageType
:
:
Ping
:
{
const
PingMessage
&
nmsg
=
(
const
PingMessage
&
)
*
aMsg
;
uint64_t
total
=
*
ExecutionProgressCounter
(
)
+
Thread
:
:
TotalEventProgress
(
)
;
gChannel
-
>
SendMessage
(
PingResponseMessage
(
gForkId
nmsg
.
mId
total
)
)
;
break
;
}
case
MessageType
:
:
Terminate
:
{
PrintSpew
(
"
Terminate
message
received
exiting
.
.
.
\
n
"
)
;
_exit
(
0
)
;
break
;
}
case
MessageType
:
:
Crash
:
{
ReportFatalError
(
"
Hung
replaying
process
"
)
;
break
;
}
case
MessageType
:
:
ManifestStart
:
{
const
ManifestStartMessage
&
nmsg
=
(
const
ManifestStartMessage
&
)
*
aMsg
;
js
:
:
CharBuffer
*
buf
=
new
js
:
:
CharBuffer
(
)
;
buf
-
>
append
(
nmsg
.
Buffer
(
)
nmsg
.
BufferSize
(
)
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
js
:
:
ManifestStart
(
*
buf
)
;
delete
buf
;
}
)
;
break
;
}
case
MessageType
:
:
ExternalCallResponse
:
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
gWaitingForCallResponse
)
;
MOZ_RELEASE_ASSERT
(
!
gCallResponseMessage
)
;
gCallResponseMessage
.
reset
(
static_cast
<
ExternalCallResponseMessage
*
>
(
aMsg
.
release
(
)
)
)
;
gMonitor
-
>
NotifyAll
(
)
;
break
;
}
case
MessageType
:
:
RecordingData
:
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
const
RecordingDataMessage
&
nmsg
=
(
const
RecordingDataMessage
&
)
*
aMsg
;
MOZ_RELEASE_ASSERT
(
nmsg
.
mTag
=
=
gRecording
-
>
Size
(
)
+
gPendingRecordingData
.
length
(
)
)
;
gPendingRecordingData
.
append
(
nmsg
.
BinaryData
(
)
nmsg
.
BinaryDataSize
(
)
)
;
gMonitor
-
>
NotifyAll
(
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
}
static
void
ListenForCheckpointThreadMain
(
void
*
)
{
while
(
true
)
{
uint8_t
data
=
0
;
ssize_t
rv
=
HANDLE_EINTR
(
read
(
gCheckpointReadFd
&
data
1
)
)
;
if
(
rv
>
0
)
{
NS_DispatchToMainThread
(
NewRunnableFunction
(
"
NewCheckpoint
"
NewCheckpoint
)
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
errno
=
=
EIO
)
;
MOZ_RELEASE_ASSERT
(
HasDivergedFromRecording
(
)
)
;
Thread
:
:
WaitForever
(
)
;
}
}
}
void
*
gGraphicsShmem
;
static
void
WaitForGraphicsShmem
(
)
{
nsPrintfCString
portString
(
"
WebReplay
.
%
d
.
%
lu
"
gMiddlemanPid
GetId
(
)
)
;
ReceivePort
receivePort
(
portString
.
get
(
)
)
;
MachSendMessage
handshakeMessage
(
parent
:
:
GraphicsHandshakeMessageId
)
;
handshakeMessage
.
AddDescriptor
(
MachMsgPortDescriptor
(
receivePort
.
GetPort
(
)
MACH_MSG_TYPE_COPY_SEND
)
)
;
MachPortSender
sender
(
nsPrintfCString
(
"
WebReplay
.
%
d
"
gMiddlemanPid
)
.
get
(
)
)
;
kern_return_t
kr
=
sender
.
SendMessage
(
handshakeMessage
1000
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MachReceiveMessage
message
;
kr
=
receivePort
.
WaitForMessage
(
&
message
0
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
message
.
GetMessageID
(
)
=
=
parent
:
:
GraphicsMemoryMessageId
)
;
mach_port_t
graphicsPort
=
message
.
GetTranslatedPort
(
0
)
;
MOZ_RELEASE_ASSERT
(
graphicsPort
!
=
MACH_PORT_NULL
)
;
mach_vm_address_t
address
=
0
;
kr
=
mach_vm_map
(
mach_task_self
(
)
&
address
parent
:
:
GraphicsMemorySize
0
VM_FLAGS_ANYWHERE
graphicsPort
0
false
VM_PROT_READ
|
VM_PROT_WRITE
VM_PROT_READ
|
VM_PROT_WRITE
VM_INHERIT_NONE
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
gGraphicsShmem
=
(
void
*
)
address
;
}
static
void
InitializeForkListener
(
)
;
void
SetupRecordReplayChannel
(
int
aArgc
char
*
aArgv
[
]
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
&
&
AreThreadEventsPassedThrough
(
)
)
;
Maybe
<
int
>
channelID
;
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
if
(
!
strcmp
(
aArgv
[
i
]
gMiddlemanPidOption
)
)
{
MOZ_RELEASE_ASSERT
(
!
gMiddlemanPid
&
&
i
+
1
<
aArgc
)
;
gMiddlemanPid
=
atoi
(
aArgv
[
i
+
1
]
)
;
}
if
(
!
strcmp
(
aArgv
[
i
]
gChannelIDOption
)
)
{
MOZ_RELEASE_ASSERT
(
channelID
.
isNothing
(
)
&
&
i
+
1
<
aArgc
)
;
channelID
.
emplace
(
atoi
(
aArgv
[
i
+
1
]
)
)
;
}
}
MOZ_RELEASE_ASSERT
(
channelID
.
isSome
(
)
)
;
gMonitor
=
new
Monitor
(
)
;
gChannel
=
new
Channel
(
channelID
.
ref
(
)
Channel
:
:
Kind
:
:
RecordReplay
ChannelMessageHandler
gMiddlemanPid
)
;
if
(
gInitializationFailureMessage
)
{
ReportFatalError
(
"
%
s
"
gInitializationFailureMessage
)
;
Unreachable
(
)
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
!
gIntroductionMessage
)
{
gMonitor
-
>
Wait
(
)
;
}
if
(
IsReplaying
(
)
)
{
while
(
gPendingRecordingData
.
empty
(
)
)
{
gMonitor
-
>
Wait
(
)
;
}
}
}
void
InitRecordingOrReplayingProcess
(
int
*
aArgc
char
*
*
*
aArgv
)
{
if
(
!
IsRecordingOrReplaying
(
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
{
AutoPassThroughThreadEvents
pt
;
if
(
IsRecording
(
)
)
{
WaitForGraphicsShmem
(
)
;
}
else
{
InitializeForkListener
(
)
;
}
}
DirectCreatePipe
(
&
gCheckpointWriteFd
&
gCheckpointReadFd
)
;
Thread
:
:
StartThread
(
ListenForCheckpointThreadMain
nullptr
false
)
;
MOZ_RELEASE_ASSERT
(
gParentArgv
.
empty
(
)
)
;
{
IntroductionMessage
*
msg
=
IntroductionMessage
:
:
RecordReplay
(
*
gIntroductionMessage
)
;
gParentPid
=
gIntroductionMessage
-
>
mParentPid
;
const
char
*
pos
=
msg
-
>
ArgvString
(
)
;
for
(
size_t
i
=
0
;
i
<
msg
-
>
mArgc
;
i
+
+
)
{
gParentArgv
.
append
(
strdup
(
pos
)
)
;
pos
+
=
strlen
(
pos
)
+
1
;
}
free
(
msg
)
;
}
gIntroductionMessage
=
nullptr
;
gParentArgv
.
append
(
nullptr
)
;
MOZ_RELEASE_ASSERT
(
*
aArgc
>
=
1
)
;
MOZ_RELEASE_ASSERT
(
gParentArgv
.
back
(
)
=
=
nullptr
)
;
*
aArgc
=
gParentArgv
.
length
(
)
-
1
;
*
aArgv
=
gParentArgv
.
begin
(
)
;
}
base
:
:
ProcessId
MiddlemanProcessId
(
)
{
return
gMiddlemanPid
;
}
base
:
:
ProcessId
ParentProcessId
(
)
{
return
gParentPid
;
}
bool
DebuggerRunsInMiddleman
(
)
{
return
RecordReplayValue
(
gDebuggerRunsInMiddleman
)
;
}
static
void
HandleMessageFromForkedProcess
(
Message
:
:
UniquePtr
aMsg
)
;
static
StaticInfallibleVector
<
Message
:
:
UniquePtr
>
gPendingForkMessages
;
struct
ForkedProcess
{
base
:
:
ProcessId
mPid
;
size_t
mForkId
;
Channel
*
mChannel
;
}
;
static
StaticInfallibleVector
<
ForkedProcess
>
gForkedProcesses
;
static
FileHandle
gForkWriteFd
gForkReadFd
;
static
char
*
gFatalErrorMemory
;
static
const
size_t
FatalErrorMemorySize
=
PageSize
;
static
void
ForkListenerThread
(
void
*
)
{
while
(
true
)
{
ForkedProcess
process
;
int
nbytes
=
read
(
gForkReadFd
&
process
sizeof
(
process
)
)
;
MOZ_RELEASE_ASSERT
(
nbytes
=
=
sizeof
(
process
)
)
;
process
.
mChannel
=
new
Channel
(
0
Channel
:
:
Kind
:
:
ReplayRoot
HandleMessageFromForkedProcess
process
.
mPid
)
;
size_t
i
=
0
;
while
(
i
<
gPendingForkMessages
.
length
(
)
)
{
auto
&
pending
=
gPendingForkMessages
[
i
]
;
if
(
pending
-
>
mForkId
=
=
process
.
mForkId
)
{
process
.
mChannel
-
>
SendMessage
(
std
:
:
move
(
*
pending
)
)
;
gPendingForkMessages
.
erase
(
&
pending
)
;
}
else
{
i
+
+
;
}
}
gForkedProcesses
.
emplaceBack
(
process
)
;
}
}
static
void
InitializeForkListener
(
)
{
DirectCreatePipe
(
&
gForkWriteFd
&
gForkReadFd
)
;
Thread
:
:
SpawnNonRecordedThread
(
ForkListenerThread
nullptr
)
;
if
(
!
ReplayingInCloud
(
)
)
{
gFatalErrorMemory
=
(
char
*
)
mmap
(
nullptr
FatalErrorMemorySize
PROT_READ
|
PROT_WRITE
MAP_ANON
|
MAP_SHARED
-
1
0
)
;
MOZ_RELEASE_ASSERT
(
gFatalErrorMemory
!
=
MAP_FAILED
)
;
}
}
static
void
SendMessageToForkedProcess
(
Message
:
:
UniquePtr
aMsg
)
{
for
(
ForkedProcess
&
process
:
gForkedProcesses
)
{
if
(
process
.
mForkId
=
=
aMsg
-
>
mForkId
)
{
bool
remove
=
aMsg
-
>
mType
=
=
MessageType
:
:
Terminate
|
|
aMsg
-
>
mType
=
=
MessageType
:
:
Crash
;
process
.
mChannel
-
>
SendMessage
(
std
:
:
move
(
*
aMsg
)
)
;
if
(
remove
)
{
gForkedProcesses
.
erase
(
&
process
)
;
}
return
;
}
}
gPendingForkMessages
.
append
(
std
:
:
move
(
aMsg
)
)
;
}
static
bool
MaybeHandleExternalCallResponse
(
const
Message
&
aMsg
)
{
if
(
aMsg
.
mType
=
=
MessageType
:
:
ExternalCallResponse
)
{
const
auto
&
nmsg
=
static_cast
<
const
ExternalCallResponseMessage
&
>
(
aMsg
)
;
AddExternalCallOutput
(
nmsg
.
mTag
nmsg
.
BinaryData
(
)
nmsg
.
BinaryDataSize
(
)
)
;
return
true
;
}
return
false
;
}
static
void
HandleMessageToForkedProcess
(
Message
:
:
UniquePtr
aMsg
)
{
MaybeHandleExternalCallResponse
(
*
aMsg
)
;
SendMessageToForkedProcess
(
std
:
:
move
(
aMsg
)
)
;
}
static
void
HandleMessageFromForkedProcess
(
Message
:
:
UniquePtr
aMsg
)
{
if
(
aMsg
-
>
mType
=
=
MessageType
:
:
ExternalCallRequest
)
{
const
auto
&
nmsg
=
static_cast
<
const
ExternalCallRequestMessage
&
>
(
*
aMsg
)
;
InfallibleVector
<
char
>
outputData
;
if
(
HasExternalCallOutput
(
nmsg
.
mTag
&
outputData
)
)
{
Message
:
:
UniquePtr
response
(
ExternalCallResponseMessage
:
:
New
(
nmsg
.
mForkId
nmsg
.
mTag
outputData
.
begin
(
)
outputData
.
length
(
)
)
)
;
SendMessageToForkedProcess
(
std
:
:
move
(
response
)
)
;
return
;
}
}
if
(
MaybeHandleExternalCallResponse
(
*
aMsg
)
)
{
return
;
}
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
aMsg
)
)
;
}
static
const
size_t
ForkTimeoutSeconds
=
10
;
void
RegisterFork
(
size_t
aForkId
)
{
AutoPassThroughThreadEvents
pt
;
gForkId
=
aForkId
;
gChannel
=
new
Channel
(
0
Channel
:
:
Kind
:
:
ReplayForked
ChannelMessageHandler
)
;
ForkedProcess
process
;
process
.
mPid
=
getpid
(
)
;
process
.
mForkId
=
aForkId
;
int
nbytes
=
write
(
gForkWriteFd
&
process
sizeof
(
process
)
)
;
MOZ_RELEASE_ASSERT
(
nbytes
=
=
sizeof
(
process
)
)
;
TimeStamp
deadline
=
TimeStamp
:
:
Now
(
)
+
TimeDuration
:
:
FromSeconds
(
ForkTimeoutSeconds
)
;
gChannel
-
>
ExitIfNotInitializedBefore
(
deadline
)
;
}
static
void
SendFatalErrorMessage
(
size_t
aForkId
const
char
*
aMessage
)
{
char
msgBuf
[
4096
]
;
size_t
header
=
sizeof
(
FatalErrorMessage
)
;
size_t
len
=
std
:
:
min
(
strlen
(
aMessage
)
+
1
sizeof
(
msgBuf
)
-
header
)
;
FatalErrorMessage
*
msg
=
new
(
msgBuf
)
FatalErrorMessage
(
header
+
len
aForkId
)
;
memcpy
(
&
msgBuf
[
header
]
aMessage
len
)
;
msgBuf
[
sizeof
(
msgBuf
)
-
1
]
=
0
;
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
Print
(
"
*
*
*
*
*
Fatal
Record
/
Replay
Error
#
%
lu
:
%
lu
*
*
*
*
*
\
n
%
s
\
n
"
GetId
(
)
aForkId
aMessage
)
;
}
void
ReportCrash
(
const
MinidumpInfo
&
aInfo
void
*
aFaultingAddress
)
{
int
pid
;
pid_for_task
(
aInfo
.
mTask
&
pid
)
;
uint32_t
forkId
=
UINT32_MAX
;
if
(
aInfo
.
mTask
!
=
mach_task_self
(
)
)
{
for
(
const
ForkedProcess
&
fork
:
gForkedProcesses
)
{
if
(
fork
.
mPid
=
=
pid
)
{
forkId
=
fork
.
mForkId
;
}
}
if
(
forkId
=
=
UINT32_MAX
)
{
Print
(
"
Could
not
find
fork
ID
for
crashing
task
\
n
"
)
;
}
}
AutoEnsurePassThroughThreadEvents
pt
;
#
ifdef
MOZ_CRASHREPORTER
google_breakpad
:
:
ExceptionHandler
:
:
WriteForwardedExceptionMinidump
(
aInfo
.
mExceptionType
aInfo
.
mCode
aInfo
.
mSubcode
aInfo
.
mThread
aInfo
.
mTask
)
;
#
endif
char
buf
[
2048
]
;
if
(
gFatalErrorMemory
&
&
gFatalErrorMemory
[
0
]
)
{
SprintfLiteral
(
buf
"
%
s
"
gFatalErrorMemory
)
;
memset
(
gFatalErrorMemory
0
FatalErrorMemorySize
)
;
}
else
{
SprintfLiteral
(
buf
"
Fault
%
p
"
aFaultingAddress
)
;
}
SendFatalErrorMessage
(
forkId
buf
)
;
}
void
ReportFatalError
(
const
char
*
aFormat
.
.
.
)
{
if
(
!
gFatalErrorMemory
)
{
gFatalErrorMemory
=
new
char
[
4096
]
;
}
va_list
ap
;
va_start
(
ap
aFormat
)
;
vsnprintf
(
gFatalErrorMemory
FatalErrorMemorySize
-
1
aFormat
ap
)
;
va_end
(
ap
)
;
Print
(
"
FatalError
:
%
s
\
n
"
gFatalErrorMemory
)
;
MOZ_CRASH
(
"
ReportFatalError
"
)
;
}
extern
"
C
"
{
MOZ_EXPORT
void
RecordReplayInterface_ReportCrash
(
const
char
*
aMessage
)
{
SendFatalErrorMessage
(
gForkId
aMessage
)
;
}
}
void
ReportUnhandledDivergence
(
)
{
gChannel
-
>
SendMessage
(
UnhandledDivergenceMessage
(
gForkId
)
)
;
Thread
:
:
WaitForeverNoIdle
(
)
;
}
size_t
GetId
(
)
{
return
gChannel
-
>
GetId
(
)
;
}
size_t
GetForkId
(
)
{
return
gForkId
;
}
void
AddPendingRecordingData
(
)
{
Thread
:
:
WaitForIdleThreads
(
)
;
InfallibleVector
<
Stream
*
>
updatedStreams
;
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
!
gPendingRecordingData
.
empty
(
)
)
;
gRecording
-
>
NewContents
(
(
const
uint8_t
*
)
gPendingRecordingData
.
begin
(
)
gPendingRecordingData
.
length
(
)
&
updatedStreams
)
;
gPendingRecordingData
.
clear
(
)
;
}
for
(
Stream
*
stream
:
updatedStreams
)
{
if
(
stream
-
>
Name
(
)
=
=
StreamName
:
:
Lock
)
{
Lock
:
:
LockAcquiresUpdated
(
stream
-
>
NameIndex
(
)
)
;
}
}
Thread
:
:
ResumeIdleThreads
(
)
;
}
static
VsyncObserver
*
gVsyncObserver
;
void
SetVsyncObserver
(
VsyncObserver
*
aObserver
)
{
MOZ_RELEASE_ASSERT
(
!
gVsyncObserver
|
|
!
aObserver
)
;
gVsyncObserver
=
aObserver
;
}
void
NotifyVsyncObserver
(
)
{
if
(
gVsyncObserver
)
{
static
VsyncId
vsyncId
;
vsyncId
=
vsyncId
.
Next
(
)
;
VsyncEvent
event
(
vsyncId
TimeStamp
:
:
Now
(
)
)
;
gVsyncObserver
-
>
NotifyVsync
(
event
)
;
}
}
static
int32_t
gNumPendingMainThreadPaints
;
bool
OnVsync
(
)
{
if
(
parent
:
:
InRepaintStressMode
(
)
)
{
CreateCheckpoint
(
)
;
}
return
gNumPendingMainThreadPaints
=
=
0
;
}
static
void
*
gDrawTargetBuffer
;
static
size_t
gDrawTargetBufferSize
;
static
size_t
gPaintWidth
gPaintHeight
;
static
Atomic
<
int32_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gNumPendingPaints
;
static
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gCompositorThreadId
;
static
bool
gAllowRepaintFailures
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
DrawTargetForRemoteDrawing
(
LayoutDeviceIntSize
aSize
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
size_t
threadId
=
Thread
:
:
Current
(
)
-
>
Id
(
)
;
if
(
gCompositorThreadId
)
{
MOZ_RELEASE_ASSERT
(
threadId
=
=
gCompositorThreadId
)
;
}
else
{
gCompositorThreadId
=
threadId
;
}
if
(
aSize
.
IsEmpty
(
)
)
{
return
nullptr
;
}
gPaintWidth
=
aSize
.
width
;
gPaintHeight
=
aSize
.
height
;
gfx
:
:
IntSize
size
(
aSize
.
width
aSize
.
height
)
;
size_t
bufferSize
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBBufferSize
(
size
gSurfaceFormat
)
;
MOZ_RELEASE_ASSERT
(
bufferSize
<
=
parent
:
:
GraphicsMemorySize
)
;
if
(
bufferSize
!
=
gDrawTargetBufferSize
)
{
free
(
gDrawTargetBuffer
)
;
gDrawTargetBuffer
=
malloc
(
bufferSize
)
;
gDrawTargetBufferSize
=
bufferSize
;
}
size_t
stride
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBStride
(
gSurfaceFormat
aSize
.
width
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
drawTarget
=
gfx
:
:
Factory
:
:
CreateDrawTargetForData
(
gfx
:
:
BackendType
:
:
SKIA
(
uint8_t
*
)
gDrawTargetBuffer
size
stride
gSurfaceFormat
true
)
;
if
(
!
drawTarget
)
{
MOZ_CRASH
(
)
;
}
return
drawTarget
.
forget
(
)
;
}
bool
EncodeGraphics
(
nsACString
&
aData
)
{
nsCString
encoderCID
(
"
mozilla
.
org
/
image
/
encoder
;
2
?
type
=
image
/
png
"
)
;
nsCOMPtr
<
imgIEncoder
>
encoder
=
do_CreateInstance
(
encoderCID
.
get
(
)
)
;
size_t
stride
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBStride
(
gSurfaceFormat
gPaintWidth
)
;
nsString
options
;
nsresult
rv
=
encoder
-
>
InitFromData
(
(
const
uint8_t
*
)
gDrawTargetBuffer
stride
*
gPaintHeight
gPaintWidth
gPaintHeight
stride
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
options
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
uint64_t
count
;
rv
=
encoder
-
>
Available
(
&
count
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
rv
=
Base64EncodeInputStream
(
encoder
aData
count
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
void
NotifyPaintStart
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
gPainted
;
if
(
!
gPainted
)
{
gPainted
=
true
;
gAllowRepaintFailures
=
Preferences
:
:
GetBool
(
"
devtools
.
recordreplay
.
allowRepaintFailures
"
)
&
&
!
parent
:
:
InRepaintStressMode
(
)
;
}
gNumPendingPaints
+
+
;
gNumPendingMainThreadPaints
+
+
;
}
static
void
PaintFromMainThread
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
gNumPendingMainThreadPaints
-
-
;
if
(
gNumPendingMainThreadPaints
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
!
gNumPendingPaints
)
;
if
(
IsMainChild
(
)
&
&
gDrawTargetBuffer
)
{
if
(
IsRecording
(
)
)
{
memcpy
(
gGraphicsShmem
gDrawTargetBuffer
gDrawTargetBufferSize
)
;
gChannel
-
>
SendMessage
(
PaintMessage
(
gPaintWidth
gPaintHeight
)
)
;
}
else
{
AutoPassThroughThreadEvents
pt
;
nsAutoCString
data
;
if
(
!
EncodeGraphics
(
data
)
)
{
MOZ_CRASH
(
"
EncodeGraphics
failed
"
)
;
}
Message
*
msg
=
PaintEncodedMessage
:
:
New
(
gForkId
0
data
.
BeginReading
(
)
data
.
Length
(
)
)
;
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
free
(
msg
)
;
}
}
}
void
NotifyPaintComplete
(
)
{
MOZ_RELEASE_ASSERT
(
!
gCompositorThreadId
|
|
Thread
:
:
Current
(
)
-
>
Id
(
)
=
=
gCompositorThreadId
)
;
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
-
-
gNumPendingPaints
=
=
0
)
{
gMonitor
-
>
Notify
(
)
;
}
}
NS_DispatchToMainThread
(
NewRunnableFunction
(
"
PaintFromMainThread
"
PaintFromMainThread
)
)
;
}
static
bool
gDidRepaint
;
static
bool
gRepainting
;
bool
Repaint
(
nsACString
&
aData
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
HasDivergedFromRecording
(
)
)
;
EnsureNonMainThreadsAreSpawned
(
)
;
if
(
!
gCompositorThreadId
)
{
return
false
;
}
if
(
!
gDidRepaint
)
{
gDidRepaint
=
true
;
gRepainting
=
true
;
NotifyVsyncObserver
(
)
;
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
gNumPendingPaints
)
{
gMonitor
-
>
Wait
(
)
;
}
}
gRepainting
=
false
;
}
if
(
!
gDrawTargetBuffer
)
{
return
false
;
}
return
EncodeGraphics
(
aData
)
;
}
bool
CurrentRepaintCannotFail
(
)
{
return
gRepainting
&
&
!
gAllowRepaintFailures
;
}
void
ManifestFinished
(
const
js
:
:
CharBuffer
&
aBuffer
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
ManifestFinishedMessage
*
msg
=
ManifestFinishedMessage
:
:
New
(
gForkId
aBuffer
.
begin
(
)
aBuffer
.
length
(
)
)
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
free
(
msg
)
;
}
)
;
}
void
SendExternalCallRequest
(
ExternalCallId
aId
const
char
*
aInputData
size_t
aInputSize
InfallibleVector
<
char
>
*
aOutputData
)
{
AutoPassThroughThreadEvents
pt
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
gWaitingForCallResponse
)
{
gMonitor
-
>
Wait
(
)
;
}
gWaitingForCallResponse
=
true
;
UniquePtr
<
ExternalCallRequestMessage
>
msg
(
ExternalCallRequestMessage
:
:
New
(
gForkId
aId
aInputData
aInputSize
)
)
;
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
while
(
!
gCallResponseMessage
)
{
gMonitor
-
>
Wait
(
)
;
}
aOutputData
-
>
append
(
gCallResponseMessage
-
>
BinaryData
(
)
gCallResponseMessage
-
>
BinaryDataSize
(
)
)
;
gCallResponseMessage
=
nullptr
;
gWaitingForCallResponse
=
false
;
gMonitor
-
>
Notify
(
)
;
}
void
SendExternalCallOutput
(
ExternalCallId
aId
const
char
*
aOutputData
size_t
aOutputSize
)
{
Message
:
:
UniquePtr
msg
(
ExternalCallResponseMessage
:
:
New
(
gForkId
aId
aOutputData
aOutputSize
)
)
;
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
}
void
SendRecordingData
(
size_t
aStart
const
uint8_t
*
aData
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
RecordingDataMessage
*
msg
=
RecordingDataMessage
:
:
New
(
gForkId
aStart
(
const
char
*
)
aData
aSize
)
;
gChannel
-
>
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
free
(
msg
)
;
}
}
}
}
