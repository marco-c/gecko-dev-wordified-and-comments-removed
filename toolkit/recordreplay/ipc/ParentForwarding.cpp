#
include
"
ParentInternal
.
h
"
#
include
"
mozilla
/
dom
/
PBrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
static
StaticInfallibleVector
<
std
:
:
pair
<
int32_t
int32_t
>
>
gProtocolManagers
;
static
StaticInfallibleVector
<
int32_t
>
gDeadRoutingIds
;
static
void
NoteProtocolManager
(
int32_t
aManagee
int32_t
aManager
)
{
gProtocolManagers
.
emplaceBack
(
aManagee
aManager
)
;
for
(
auto
id
:
gDeadRoutingIds
)
{
if
(
id
=
=
aManager
)
{
gDeadRoutingIds
.
emplaceBack
(
aManagee
)
;
}
}
}
static
void
DestroyRoutingId
(
int32_t
aId
)
{
gDeadRoutingIds
.
emplaceBack
(
aId
)
;
for
(
auto
manager
:
gProtocolManagers
)
{
if
(
manager
.
second
=
=
aId
)
{
DestroyRoutingId
(
manager
.
first
)
;
}
}
}
static
bool
MessageTargetIsDead
(
const
IPC
:
:
Message
&
aMessage
)
{
for
(
int32_t
id
:
gDeadRoutingIds
)
{
if
(
id
=
=
aMessage
.
routing_id
(
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
HandleMessageInMiddleman
(
ipc
:
:
Side
aSide
const
IPC
:
:
Message
&
aMessage
)
{
IPC
:
:
Message
:
:
msgid_t
type
=
aMessage
.
type
(
)
;
if
(
aSide
=
=
ipc
:
:
ParentSide
)
{
if
(
type
=
=
dom
:
:
PBrowser
:
:
Msg_PDocAccessibleConstructor__ID
)
{
PickleIterator
iter
(
aMessage
)
;
ipc
:
:
ActorHandle
handle
;
if
(
!
IPC
:
:
ReadParam
(
&
aMessage
&
iter
&
handle
)
)
MOZ_CRASH
(
"
IPC
:
:
ReadParam
failed
"
)
;
NoteProtocolManager
(
handle
.
mId
aMessage
.
routing_id
(
)
)
;
}
if
(
MessageTargetIsDead
(
aMessage
)
)
{
PrintSpew
(
"
Suppressing
%
s
message
to
dead
target
\
n
"
IPC
:
:
StringFromIPCMessageType
(
type
)
)
;
return
true
;
}
return
false
;
}
if
(
type
=
=
dom
:
:
PContent
:
:
Msg_PBrowserConstructor__ID
|
|
type
=
=
dom
:
:
PContent
:
:
Msg_RegisterChrome__ID
|
|
type
=
=
dom
:
:
PContent
:
:
Msg_SetXPCOMProcessAttributes__ID
|
|
type
=
=
dom
:
:
PContent
:
:
Msg_SetProcessSandbox__ID
|
|
type
=
=
dom
:
:
PBrowser
:
:
Msg_InitRendering__ID
|
|
type
=
=
dom
:
:
PBrowser
:
:
Msg_SetDocShellIsActive__ID
|
|
type
=
=
dom
:
:
PBrowser
:
:
Msg_PRenderFrameConstructor__ID
|
|
type
=
=
dom
:
:
PBrowser
:
:
Msg_RenderLayers__ID
|
|
type
=
=
dom
:
:
PBrowser
:
:
Msg_LoadRemoteScript__ID
|
|
type
=
=
dom
:
:
PBrowser
:
:
Msg_AsyncMessage__ID
|
|
type
=
=
dom
:
:
PBrowser
:
:
Msg_Destroy__ID
)
{
ipc
:
:
IProtocol
:
:
Result
r
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
PContentChild
:
:
OnMessageReceived
(
aMessage
)
;
MOZ_RELEASE_ASSERT
(
r
=
=
ipc
:
:
IProtocol
:
:
MsgProcessed
)
;
if
(
type
=
=
dom
:
:
PContent
:
:
Msg_SetXPCOMProcessAttributes__ID
)
{
PreferencesLoaded
(
)
;
}
if
(
type
=
=
dom
:
:
PBrowser
:
:
Msg_Destroy__ID
)
{
DestroyRoutingId
(
aMessage
.
routing_id
(
)
)
;
}
if
(
type
=
=
dom
:
:
PBrowser
:
:
Msg_RenderLayers__ID
)
{
UpdateGraphicsInUIProcess
(
nullptr
)
;
}
return
false
;
}
if
(
type
=
=
dom
:
:
PContent
:
:
Msg_InitRendering__ID
|
|
type
=
=
dom
:
:
PContent
:
:
Msg_SaveRecording__ID
|
|
type
=
=
dom
:
:
PContent
:
:
Msg_Shutdown__ID
)
{
ipc
:
:
IProtocol
:
:
Result
r
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
PContentChild
:
:
OnMessageReceived
(
aMessage
)
;
MOZ_RELEASE_ASSERT
(
r
=
=
ipc
:
:
IProtocol
:
:
MsgProcessed
)
;
return
true
;
}
if
(
type
>
=
layers
:
:
PCompositorBridge
:
:
PCompositorBridgeStart
&
&
type
<
=
layers
:
:
PCompositorBridge
:
:
PCompositorBridgeEnd
)
{
layers
:
:
CompositorBridgeChild
*
compositorChild
=
layers
:
:
CompositorBridgeChild
:
:
Get
(
)
;
ipc
:
:
IProtocol
:
:
Result
r
=
compositorChild
-
>
OnMessageReceived
(
aMessage
)
;
MOZ_RELEASE_ASSERT
(
r
=
=
ipc
:
:
IProtocol
:
:
MsgProcessed
)
;
return
true
;
}
return
false
;
}
static
bool
gMainThreadIsWaitingForIPDLReply
=
false
;
bool
MainThreadIsWaitingForIPDLReply
(
)
{
return
gMainThreadIsWaitingForIPDLReply
;
}
struct
MOZ_RAII
AutoMarkMainThreadWaitingForIPDLReply
{
AutoMarkMainThreadWaitingForIPDLReply
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gMainThreadIsWaitingForIPDLReply
)
;
gMainThreadIsWaitingForIPDLReply
=
true
;
}
~
AutoMarkMainThreadWaitingForIPDLReply
(
)
{
gMainThreadIsWaitingForIPDLReply
=
false
;
}
}
;
class
MiddlemanProtocol
:
public
ipc
:
:
IToplevelProtocol
{
public
:
ipc
:
:
Side
mSide
;
MiddlemanProtocol
*
mOpposite
;
MessageLoop
*
mOppositeMessageLoop
;
explicit
MiddlemanProtocol
(
ipc
:
:
Side
aSide
)
:
ipc
:
:
IToplevelProtocol
(
"
MiddlemanProtocol
"
PContentMsgStart
aSide
)
mSide
(
aSide
)
mOpposite
(
nullptr
)
mOppositeMessageLoop
(
nullptr
)
{
}
virtual
void
RemoveManagee
(
int32_t
IProtocol
*
)
override
{
MOZ_CRASH
(
"
MiddlemanProtocol
:
:
RemoveManagee
"
)
;
}
static
void
ForwardMessageAsync
(
MiddlemanProtocol
*
aProtocol
Message
*
aMessage
)
{
if
(
ActiveChildIsRecording
(
)
)
{
PrintSpew
(
"
ForwardAsyncMsg
%
s
%
s
%
d
\
n
"
(
aProtocol
-
>
mSide
=
=
ipc
:
:
ChildSide
)
?
"
Child
"
:
"
Parent
"
IPC
:
:
StringFromIPCMessageType
(
aMessage
-
>
type
(
)
)
(
int
)
aMessage
-
>
routing_id
(
)
)
;
if
(
!
aProtocol
-
>
GetIPCChannel
(
)
-
>
Send
(
aMessage
)
)
{
MOZ_CRASH
(
"
MiddlemanProtocol
:
:
ForwardMessageAsync
"
)
;
}
}
else
{
delete
aMessage
;
}
}
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
)
override
{
if
(
!
mOppositeMessageLoop
)
{
MOZ_RELEASE_ASSERT
(
mSide
=
=
ipc
:
:
ChildSide
)
;
HandleMessageInMiddleman
(
mSide
aMessage
)
;
return
MsgProcessed
;
}
Message
*
nMessage
=
new
Message
(
)
;
nMessage
-
>
CopyFrom
(
aMessage
)
;
if
(
HandleMessageInMiddleman
(
mSide
aMessage
)
)
{
delete
nMessage
;
return
MsgProcessed
;
}
mOppositeMessageLoop
-
>
PostTask
(
NewRunnableFunction
(
"
ForwardMessageAsync
"
ForwardMessageAsync
mOpposite
nMessage
)
)
;
return
MsgProcessed
;
}
static
void
ForwardMessageSync
(
MiddlemanProtocol
*
aProtocol
Message
*
aMessage
Message
*
*
aReply
)
{
PrintSpew
(
"
ForwardSyncMsg
%
s
\
n
"
IPC
:
:
StringFromIPCMessageType
(
aMessage
-
>
type
(
)
)
)
;
MOZ_RELEASE_ASSERT
(
!
*
aReply
)
;
Message
*
nReply
=
new
Message
(
)
;
if
(
!
aProtocol
-
>
GetIPCChannel
(
)
-
>
Send
(
aMessage
nReply
)
)
{
MOZ_CRASH
(
"
MiddlemanProtocol
:
:
ForwardMessageSync
"
)
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
*
aReply
=
nReply
;
gMonitor
-
>
Notify
(
)
;
}
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
Message
*
&
aReply
)
override
{
MOZ_RELEASE_ASSERT
(
mOppositeMessageLoop
)
;
MOZ_RELEASE_ASSERT
(
mSide
=
=
ipc
:
:
ChildSide
|
|
!
MessageTargetIsDead
(
aMessage
)
)
;
Message
*
nMessage
=
new
Message
(
)
;
nMessage
-
>
CopyFrom
(
aMessage
)
;
mOppositeMessageLoop
-
>
PostTask
(
NewRunnableFunction
(
"
ForwardMessageSync
"
ForwardMessageSync
mOpposite
nMessage
&
aReply
)
)
;
if
(
mSide
=
=
ipc
:
:
ChildSide
)
{
AutoMarkMainThreadWaitingForIPDLReply
blocked
;
ActiveRecordingChild
(
)
-
>
WaitUntil
(
[
&
]
(
)
{
return
!
!
aReply
;
}
)
;
}
else
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
!
aReply
)
{
gMonitor
-
>
Wait
(
)
;
}
}
PrintSpew
(
"
SyncMsgDone
\
n
"
)
;
return
MsgProcessed
;
}
static
void
ForwardCallMessage
(
MiddlemanProtocol
*
aProtocol
Message
*
aMessage
Message
*
*
aReply
)
{
PrintSpew
(
"
ForwardSyncCall
%
s
\
n
"
IPC
:
:
StringFromIPCMessageType
(
aMessage
-
>
type
(
)
)
)
;
MOZ_RELEASE_ASSERT
(
!
*
aReply
)
;
Message
*
nReply
=
new
Message
(
)
;
if
(
!
aProtocol
-
>
GetIPCChannel
(
)
-
>
Call
(
aMessage
nReply
)
)
{
MOZ_CRASH
(
"
MiddlemanProtocol
:
:
ForwardCallMessage
"
)
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
*
aReply
=
nReply
;
gMonitor
-
>
Notify
(
)
;
}
virtual
Result
OnCallReceived
(
const
Message
&
aMessage
Message
*
&
aReply
)
override
{
MOZ_RELEASE_ASSERT
(
mOppositeMessageLoop
)
;
MOZ_RELEASE_ASSERT
(
mSide
=
=
ipc
:
:
ChildSide
|
|
!
MessageTargetIsDead
(
aMessage
)
)
;
Message
*
nMessage
=
new
Message
(
)
;
nMessage
-
>
CopyFrom
(
aMessage
)
;
mOppositeMessageLoop
-
>
PostTask
(
NewRunnableFunction
(
"
ForwardCallMessage
"
ForwardCallMessage
mOpposite
nMessage
&
aReply
)
)
;
if
(
mSide
=
=
ipc
:
:
ChildSide
)
{
AutoMarkMainThreadWaitingForIPDLReply
blocked
;
ActiveRecordingChild
(
)
-
>
WaitUntil
(
[
&
]
(
)
{
return
!
!
aReply
;
}
)
;
}
else
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
!
aReply
)
{
gMonitor
-
>
Wait
(
)
;
}
}
PrintSpew
(
"
SyncCallDone
\
n
"
)
;
return
MsgProcessed
;
}
virtual
int32_t
GetProtocolTypeId
(
)
override
{
MOZ_CRASH
(
"
MiddlemanProtocol
:
:
GetProtocolTypeId
"
)
;
}
virtual
void
OnChannelClose
(
)
override
{
MOZ_RELEASE_ASSERT
(
mSide
=
=
ipc
:
:
ChildSide
)
;
MainThreadMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
Shutdown
"
Shutdown
)
)
;
}
virtual
void
OnChannelError
(
)
override
{
MOZ_CRASH
(
"
MiddlemanProtocol
:
:
OnChannelError
"
)
;
}
}
;
static
MiddlemanProtocol
*
gChildProtocol
;
static
MiddlemanProtocol
*
gParentProtocol
;
ipc
:
:
MessageChannel
*
ChannelToUIProcess
(
)
{
return
gChildProtocol
-
>
GetIPCChannel
(
)
;
}
static
MessageLoop
*
gForwardingMessageLoop
;
static
bool
gParentProtocolOpened
=
false
;
static
void
ForwardingMessageLoopMain
(
void
*
)
{
MOZ_RELEASE_ASSERT
(
ActiveChildIsRecording
(
)
)
;
MessageLoop
messageLoop
;
gForwardingMessageLoop
=
&
messageLoop
;
gChildProtocol
-
>
mOppositeMessageLoop
=
gForwardingMessageLoop
;
gParentProtocol
-
>
Open
(
gRecordingProcess
-
>
GetChannel
(
)
base
:
:
GetProcId
(
gRecordingProcess
-
>
GetChildProcessHandle
(
)
)
)
;
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
gParentProtocolOpened
=
true
;
gMonitor
-
>
Notify
(
)
;
}
messageLoop
.
Run
(
)
;
}
void
InitializeForwarding
(
)
{
gChildProtocol
=
new
MiddlemanProtocol
(
ipc
:
:
ChildSide
)
;
if
(
gProcessKind
=
=
ProcessKind
:
:
MiddlemanRecording
)
{
gParentProtocol
=
new
MiddlemanProtocol
(
ipc
:
:
ParentSide
)
;
gParentProtocol
-
>
mOpposite
=
gChildProtocol
;
gChildProtocol
-
>
mOpposite
=
gParentProtocol
;
gParentProtocol
-
>
mOppositeMessageLoop
=
MainThreadMessageLoop
(
)
;
if
(
!
PR_CreateThread
(
PR_USER_THREAD
ForwardingMessageLoopMain
nullptr
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
0
)
)
{
MOZ_CRASH
(
"
parent
:
:
Initialize
"
)
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
!
gParentProtocolOpened
)
{
gMonitor
-
>
Wait
(
)
;
}
}
}
}
}
}
