#
include
"
ParentInternal
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
Thread
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
static
IntroductionMessage
*
gIntroductionMessage
;
static
size_t
gNumChannels
;
static
bool
gChildrenAreDebugging
;
void
ChildProcessInfo
:
:
SetIntroductionMessage
(
IntroductionMessage
*
aMessage
)
{
gIntroductionMessage
=
aMessage
;
}
ChildProcessInfo
:
:
ChildProcessInfo
(
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
:
mChannel
(
nullptr
)
mRecording
(
aRecordingProcessData
.
isSome
(
)
)
mPaused
(
false
)
mHasBegunFatalError
(
false
)
mHasFatalError
(
false
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
gFirst
=
false
;
if
(
!
gFirst
)
{
gFirst
=
true
;
gChildrenAreDebugging
=
!
!
getenv
(
"
WAIT_AT_START
"
)
;
}
LaunchSubprocess
(
aRecordingProcessData
)
;
}
ChildProcessInfo
:
:
~
ChildProcessInfo
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsRecording
(
)
)
{
SendMessage
(
TerminateMessage
(
)
)
;
}
}
void
ChildProcessInfo
:
:
OnIncomingMessage
(
const
Message
&
aMsg
bool
aForwardToControl
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
mLastMessageTime
=
TimeStamp
:
:
Now
(
)
;
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
BeginFatalError
:
mHasBegunFatalError
=
true
;
return
;
case
MessageType
:
:
FatalError
:
{
mHasFatalError
=
true
;
const
FatalErrorMessage
&
nmsg
=
static_cast
<
const
FatalErrorMessage
&
>
(
aMsg
)
;
OnCrash
(
nmsg
.
Error
(
)
)
;
return
;
}
case
MessageType
:
:
HitExecutionPoint
:
{
const
HitExecutionPointMessage
&
nmsg
=
static_cast
<
const
HitExecutionPointMessage
&
>
(
aMsg
)
;
mPaused
=
true
;
if
(
this
=
=
GetActiveChild
(
)
&
&
!
nmsg
.
mPoint
.
HasPosition
(
)
)
{
MaybeUpdateGraphicsAtCheckpoint
(
nmsg
.
mPoint
.
mCheckpoint
)
;
}
if
(
aForwardToControl
)
{
js
:
:
ForwardHitExecutionPointMessage
(
GetId
(
)
nmsg
)
;
}
break
;
}
case
MessageType
:
:
Paint
:
MaybeUpdateGraphicsAtPaint
(
static_cast
<
const
PaintMessage
&
>
(
aMsg
)
)
;
break
;
case
MessageType
:
:
DebuggerResponse
:
mPaused
=
true
;
js
:
:
OnDebuggerResponse
(
aMsg
)
;
break
;
case
MessageType
:
:
RecordingFlushed
:
mPaused
=
true
;
break
;
case
MessageType
:
:
MiddlemanCallRequest
:
{
const
MiddlemanCallRequestMessage
&
nmsg
=
static_cast
<
const
MiddlemanCallRequestMessage
&
>
(
aMsg
)
;
InfallibleVector
<
char
>
outputData
;
ProcessMiddlemanCall
(
GetId
(
)
nmsg
.
BinaryData
(
)
nmsg
.
BinaryDataSize
(
)
&
outputData
)
;
Message
:
:
UniquePtr
response
(
MiddlemanCallResponseMessage
:
:
New
(
outputData
.
begin
(
)
outputData
.
length
(
)
)
)
;
SendMessage
(
*
response
)
;
break
;
}
case
MessageType
:
:
ResetMiddlemanCalls
:
ResetMiddlemanCalls
(
GetId
(
)
)
;
break
;
default
:
break
;
}
}
void
ChildProcessInfo
:
:
SendMessage
(
const
Message
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsPaused
(
)
|
|
aMsg
.
CanBeSentWhileUnpaused
(
)
)
;
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
Resume
:
case
MessageType
:
:
RestoreCheckpoint
:
case
MessageType
:
:
RunToPoint
:
case
MessageType
:
:
DebuggerRequest
:
case
MessageType
:
:
FlushRecording
:
mPaused
=
false
;
break
;
default
:
break
;
}
mLastMessageTime
=
TimeStamp
:
:
Now
(
)
;
mChannel
-
>
SendMessage
(
aMsg
)
;
}
ipc
:
:
GeckoChildProcessHost
*
gRecordingProcess
;
void
GetArgumentsForChildProcess
(
base
:
:
ProcessId
aMiddlemanPid
uint32_t
aChannelId
const
char
*
aRecordingFile
bool
aRecording
std
:
:
vector
<
std
:
:
string
>
&
aExtraArgs
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
|
|
XRE_IsParentProcess
(
)
)
;
aExtraArgs
.
push_back
(
gMiddlemanPidOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
aMiddlemanPid
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gChannelIDOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
(
int
)
aChannelId
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gProcessKindOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
aRecording
?
(
int
)
ProcessKind
:
:
Recording
:
(
int
)
ProcessKind
:
:
Replaying
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gRecordingFileOption
)
;
aExtraArgs
.
push_back
(
aRecordingFile
)
;
}
void
ChildProcessInfo
:
:
LaunchSubprocess
(
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
{
size_t
channelId
=
gNumChannels
+
+
;
mChannel
=
new
Channel
(
channelId
IsRecording
(
)
[
=
]
(
Message
:
:
UniquePtr
aMsg
)
{
ReceiveChildMessageOnMainThread
(
std
:
:
move
(
aMsg
)
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
=
=
aRecordingProcessData
.
isSome
(
)
)
;
if
(
IsRecording
(
)
)
{
std
:
:
vector
<
std
:
:
string
>
extraArgs
;
GetArgumentsForChildProcess
(
base
:
:
GetCurrentProcId
(
)
channelId
gRecordingFilename
true
extraArgs
)
;
MOZ_RELEASE_ASSERT
(
!
gRecordingProcess
)
;
gRecordingProcess
=
new
ipc
:
:
GeckoChildProcessHost
(
GeckoProcessType_Content
)
;
gRecordingProcess
-
>
AddFdToRemap
(
aRecordingProcessData
.
ref
(
)
.
mPrefsHandle
.
fd
kPrefsFileDescriptor
)
;
ipc
:
:
FileDescriptor
:
:
UniquePlatformHandle
prefMapHandle
=
aRecordingProcessData
.
ref
(
)
.
mPrefMapHandle
.
ClonePlatformHandle
(
)
;
gRecordingProcess
-
>
AddFdToRemap
(
prefMapHandle
.
get
(
)
kPrefMapFileDescriptor
)
;
if
(
!
gRecordingProcess
-
>
LaunchAndWaitForProcessHandle
(
extraArgs
)
)
{
MOZ_CRASH
(
"
ChildProcessInfo
:
:
LaunchSubprocess
"
)
;
}
}
else
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendCreateReplayingProcess
(
channelId
)
;
}
mLastMessageTime
=
TimeStamp
:
:
Now
(
)
;
SendGraphicsMemoryToChild
(
)
;
WaitUntilPaused
(
)
;
MOZ_RELEASE_ASSERT
(
gIntroductionMessage
)
;
SendMessage
(
*
gIntroductionMessage
)
;
if
(
!
IsRecording
(
)
)
{
SendMessage
(
SetSaveCheckpointMessage
(
CheckpointId
:
:
First
true
)
)
;
}
SendMessage
(
ResumeMessage
(
true
)
)
;
}
void
ChildProcessInfo
:
:
OnCrash
(
const
char
*
aWhy
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplayError
nsAutoCString
(
aWhy
)
)
;
if
(
mHasFatalError
)
{
Shutdown
(
)
;
}
MOZ_RELEASE_ASSERT
(
!
mHasBegunFatalError
)
;
MOZ_CRASH
(
"
Unexpected
child
crash
"
)
;
}
struct
PendingMessage
{
ChildProcessInfo
*
mProcess
;
Message
:
:
UniquePtr
mMsg
;
PendingMessage
(
)
:
mProcess
(
nullptr
)
{
}
PendingMessage
&
operator
=
(
PendingMessage
&
&
aOther
)
{
mProcess
=
aOther
.
mProcess
;
mMsg
=
std
:
:
move
(
aOther
.
mMsg
)
;
return
*
this
;
}
PendingMessage
(
PendingMessage
&
&
aOther
)
{
*
this
=
std
:
:
move
(
aOther
)
;
}
}
;
static
StaticInfallibleVector
<
PendingMessage
>
gPendingMessages
;
static
Message
:
:
UniquePtr
ExtractChildMessage
(
ChildProcessInfo
*
*
aProcess
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
size_t
i
=
0
;
i
<
gPendingMessages
.
length
(
)
;
i
+
+
)
{
PendingMessage
&
pending
=
gPendingMessages
[
i
]
;
if
(
!
*
aProcess
|
|
pending
.
mProcess
=
=
*
aProcess
)
{
*
aProcess
=
pending
.
mProcess
;
Message
:
:
UniquePtr
msg
=
std
:
:
move
(
pending
.
mMsg
)
;
gPendingMessages
.
erase
(
&
pending
)
;
return
msg
;
}
}
return
nullptr
;
}
static
bool
gHasPendingMessageRunnable
;
static
const
size_t
HangSeconds
=
30
;
Message
:
:
UniquePtr
ChildProcessInfo
:
:
WaitUntilPaused
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsPaused
(
)
)
{
return
nullptr
;
}
bool
sentTerminateMessage
=
false
;
while
(
true
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
ChildProcessInfo
*
process
=
this
;
Message
:
:
UniquePtr
msg
=
ExtractChildMessage
(
&
process
)
;
if
(
msg
)
{
OnIncomingMessage
(
*
msg
false
)
;
if
(
IsPaused
(
)
)
{
return
msg
;
}
}
else
{
if
(
gChildrenAreDebugging
|
|
IsRecording
(
)
)
{
gMonitor
-
>
Wait
(
)
;
}
else
{
TimeStamp
deadline
=
mLastMessageTime
+
TimeDuration
:
:
FromSeconds
(
HangSeconds
)
;
if
(
TimeStamp
:
:
Now
(
)
>
=
deadline
)
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
if
(
!
sentTerminateMessage
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplayHang
true
)
;
SendMessage
(
TerminateMessage
(
)
)
;
sentTerminateMessage
=
true
;
}
else
{
OnCrash
(
"
Child
process
non
-
responsive
"
)
;
}
}
gMonitor
-
>
WaitUntil
(
deadline
)
;
}
}
}
}
void
ChildProcessInfo
:
:
MaybeProcessPendingMessageRunnable
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
gHasPendingMessageRunnable
)
;
gHasPendingMessageRunnable
=
false
;
while
(
true
)
{
ChildProcessInfo
*
process
=
nullptr
;
Message
:
:
UniquePtr
msg
=
ExtractChildMessage
(
&
process
)
;
if
(
msg
)
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
process
-
>
OnIncomingMessage
(
*
msg
true
)
;
}
else
{
break
;
}
}
}
void
ChildProcessInfo
:
:
ReceiveChildMessageOnMainThread
(
Message
:
:
UniquePtr
aMsg
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
PendingMessage
pending
;
pending
.
mProcess
=
this
;
pending
.
mMsg
=
std
:
:
move
(
aMsg
)
;
gPendingMessages
.
append
(
std
:
:
move
(
pending
)
)
;
gMonitor
-
>
NotifyAll
(
)
;
if
(
!
gHasPendingMessageRunnable
)
{
gHasPendingMessageRunnable
=
true
;
MainThreadMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
MaybeProcessPendingMessageRunnable
"
MaybeProcessPendingMessageRunnable
)
)
;
}
}
}
}
}
