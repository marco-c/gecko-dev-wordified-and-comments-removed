#
include
"
ParentInternal
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
Thread
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
static
IntroductionMessage
*
gIntroductionMessage
;
static
size_t
gNumChannels
;
static
bool
gChildrenAreDebugging
;
void
ChildProcessInfo
:
:
SetIntroductionMessage
(
IntroductionMessage
*
aMessage
)
{
gIntroductionMessage
=
aMessage
;
}
ChildProcessInfo
:
:
ChildProcessInfo
(
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
:
mRecording
(
aRecordingProcessData
.
isSome
(
)
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
gFirst
=
false
;
if
(
!
gFirst
)
{
gFirst
=
true
;
gChildrenAreDebugging
=
!
!
getenv
(
"
MOZ_REPLAYING_WAIT_AT_START
"
)
;
}
LaunchSubprocess
(
aRecordingProcessData
)
;
}
ChildProcessInfo
:
:
~
ChildProcessInfo
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsRecording
(
)
&
&
!
HasCrashed
(
)
)
{
SendMessage
(
TerminateMessage
(
)
)
;
}
}
void
ChildProcessInfo
:
:
OnIncomingMessage
(
const
Message
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
BeginFatalError
:
mHasBegunFatalError
=
true
;
return
;
case
MessageType
:
:
FatalError
:
{
mHasFatalError
=
true
;
const
FatalErrorMessage
&
nmsg
=
static_cast
<
const
FatalErrorMessage
&
>
(
aMsg
)
;
OnCrash
(
nmsg
.
Error
(
)
)
;
return
;
}
case
MessageType
:
:
Paint
:
UpdateGraphicsAfterPaint
(
static_cast
<
const
PaintMessage
&
>
(
aMsg
)
)
;
break
;
case
MessageType
:
:
ManifestFinished
:
mPaused
=
true
;
js
:
:
ForwardManifestFinished
(
this
aMsg
)
;
break
;
case
MessageType
:
:
MiddlemanCallRequest
:
{
const
MiddlemanCallRequestMessage
&
nmsg
=
static_cast
<
const
MiddlemanCallRequestMessage
&
>
(
aMsg
)
;
InfallibleVector
<
char
>
outputData
;
ProcessMiddlemanCall
(
GetId
(
)
nmsg
.
BinaryData
(
)
nmsg
.
BinaryDataSize
(
)
&
outputData
)
;
Message
:
:
UniquePtr
response
(
MiddlemanCallResponseMessage
:
:
New
(
outputData
.
begin
(
)
outputData
.
length
(
)
)
)
;
SendMessage
(
std
:
:
move
(
*
response
)
)
;
break
;
}
case
MessageType
:
:
ResetMiddlemanCalls
:
ResetMiddlemanCalls
(
GetId
(
)
)
;
break
;
case
MessageType
:
:
PingResponse
:
OnPingResponse
(
static_cast
<
const
PingResponseMessage
&
>
(
aMsg
)
)
;
break
;
default
:
break
;
}
}
void
ChildProcessInfo
:
:
SendMessage
(
Message
&
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
HasCrashed
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsPaused
(
)
|
|
aMsg
.
CanBeSentWhileUnpaused
(
)
)
;
if
(
aMsg
.
mType
=
=
MessageType
:
:
ManifestStart
)
{
mPaused
=
false
;
}
mChannel
-
>
SendMessage
(
std
:
:
move
(
aMsg
)
)
;
}
ipc
:
:
GeckoChildProcessHost
*
gRecordingProcess
;
void
GetArgumentsForChildProcess
(
base
:
:
ProcessId
aMiddlemanPid
uint32_t
aChannelId
const
char
*
aRecordingFile
bool
aRecording
std
:
:
vector
<
std
:
:
string
>
&
aExtraArgs
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
|
|
XRE_IsParentProcess
(
)
)
;
aExtraArgs
.
push_back
(
gMiddlemanPidOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
aMiddlemanPid
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gChannelIDOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
(
int
)
aChannelId
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gProcessKindOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
aRecording
?
(
int
)
ProcessKind
:
:
Recording
:
(
int
)
ProcessKind
:
:
Replaying
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gRecordingFileOption
)
;
aExtraArgs
.
push_back
(
aRecordingFile
)
;
}
void
ChildProcessInfo
:
:
LaunchSubprocess
(
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
{
size_t
channelId
=
gNumChannels
+
+
;
mChannel
=
new
Channel
(
channelId
IsRecording
(
)
[
=
]
(
Message
:
:
UniquePtr
aMsg
)
{
ReceiveChildMessageOnMainThread
(
std
:
:
move
(
aMsg
)
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
=
=
aRecordingProcessData
.
isSome
(
)
)
;
if
(
IsRecording
(
)
)
{
std
:
:
vector
<
std
:
:
string
>
extraArgs
;
GetArgumentsForChildProcess
(
base
:
:
GetCurrentProcId
(
)
channelId
gRecordingFilename
true
extraArgs
)
;
MOZ_RELEASE_ASSERT
(
!
gRecordingProcess
)
;
gRecordingProcess
=
new
ipc
:
:
GeckoChildProcessHost
(
GeckoProcessType_Content
)
;
gRecordingProcess
-
>
AddFdToRemap
(
aRecordingProcessData
.
ref
(
)
.
mPrefsHandle
.
fd
kPrefsFileDescriptor
)
;
ipc
:
:
FileDescriptor
:
:
UniquePlatformHandle
prefMapHandle
=
aRecordingProcessData
.
ref
(
)
.
mPrefMapHandle
.
ClonePlatformHandle
(
)
;
gRecordingProcess
-
>
AddFdToRemap
(
prefMapHandle
.
get
(
)
kPrefMapFileDescriptor
)
;
if
(
!
gRecordingProcess
-
>
LaunchAndWaitForProcessHandle
(
extraArgs
)
)
{
MOZ_CRASH
(
"
ChildProcessInfo
:
:
LaunchSubprocess
"
)
;
}
}
else
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendCreateReplayingProcess
(
channelId
)
;
}
SendGraphicsMemoryToChild
(
)
;
MOZ_RELEASE_ASSERT
(
gIntroductionMessage
)
;
SendMessage
(
std
:
:
move
(
*
gIntroductionMessage
)
)
;
}
void
ChildProcessInfo
:
:
OnCrash
(
const
char
*
aWhy
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplayError
nsAutoCString
(
aWhy
)
)
;
if
(
!
IsRecording
(
)
)
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendGenerateReplayCrashReport
(
GetId
(
)
)
;
if
(
js
:
:
RecoverFromCrash
(
this
)
)
{
mHasFatalError
=
true
;
return
;
}
}
if
(
mHasFatalError
)
{
Shutdown
(
)
;
}
MOZ_RELEASE_ASSERT
(
!
mHasBegunFatalError
)
;
MOZ_CRASH
(
"
Unexpected
child
crash
"
)
;
}
struct
PendingMessage
{
ChildProcessInfo
*
mProcess
;
Message
:
:
UniquePtr
mMsg
;
PendingMessage
(
)
:
mProcess
(
nullptr
)
{
}
PendingMessage
&
operator
=
(
PendingMessage
&
&
aOther
)
{
mProcess
=
aOther
.
mProcess
;
mMsg
=
std
:
:
move
(
aOther
.
mMsg
)
;
return
*
this
;
}
PendingMessage
(
PendingMessage
&
&
aOther
)
{
*
this
=
std
:
:
move
(
aOther
)
;
}
}
;
static
StaticInfallibleVector
<
PendingMessage
>
gPendingMessages
;
static
Message
:
:
UniquePtr
ExtractChildMessage
(
ChildProcessInfo
*
*
aProcess
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
size_t
i
=
0
;
i
<
gPendingMessages
.
length
(
)
;
i
+
+
)
{
PendingMessage
&
pending
=
gPendingMessages
[
i
]
;
if
(
!
*
aProcess
|
|
pending
.
mProcess
=
=
*
aProcess
)
{
*
aProcess
=
pending
.
mProcess
;
Message
:
:
UniquePtr
msg
=
std
:
:
move
(
pending
.
mMsg
)
;
gPendingMessages
.
erase
(
&
pending
)
;
return
msg
;
}
}
return
nullptr
;
}
static
const
size_t
PingIntervalSeconds
=
2
;
static
const
size_t
MaxStalledPings
=
10
;
bool
ChildProcessInfo
:
:
IsHanged
(
)
{
if
(
mPings
.
length
(
)
<
MaxStalledPings
)
{
return
false
;
}
size_t
firstIndex
=
mPings
.
length
(
)
-
MaxStalledPings
;
uint64_t
firstValue
=
mPings
[
firstIndex
]
.
mProgress
;
if
(
!
firstValue
)
{
return
true
;
}
for
(
size_t
i
=
firstIndex
;
i
<
mPings
.
length
(
)
;
i
+
+
)
{
if
(
mPings
[
i
]
.
mProgress
&
&
mPings
[
i
]
.
mProgress
!
=
firstValue
)
{
return
false
;
}
}
return
true
;
}
void
ChildProcessInfo
:
:
ResetPings
(
bool
aMightRewind
)
{
mMightRewind
=
aMightRewind
;
mPings
.
clear
(
)
;
mLastPingTime
=
TimeStamp
:
:
Now
(
)
;
}
static
uint32_t
gNumPings
;
void
ChildProcessInfo
:
:
MaybePing
(
)
{
if
(
IsRecording
(
)
|
|
IsPaused
(
)
|
|
gChildrenAreDebugging
)
{
return
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mSentTerminateMessage
|
|
mMightRewind
)
{
size_t
TerminateSeconds
=
PingIntervalSeconds
*
MaxStalledPings
;
if
(
now
>
=
mLastPingTime
+
TimeDuration
:
:
FromSeconds
(
TerminateSeconds
)
)
{
OnCrash
(
mMightRewind
?
"
Rewinding
child
process
non
-
responsive
"
:
"
Child
process
non
-
responsive
"
)
;
}
return
;
}
if
(
now
<
mLastPingTime
+
TimeDuration
:
:
FromSeconds
(
PingIntervalSeconds
)
)
{
return
;
}
if
(
IsHanged
(
)
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplayHang
true
)
;
SendMessage
(
TerminateMessage
(
)
)
;
mSentTerminateMessage
=
true
;
}
else
{
uint32_t
id
=
+
+
gNumPings
;
mPings
.
emplaceBack
(
id
)
;
SendMessage
(
PingMessage
(
id
)
)
;
}
mLastPingTime
=
now
;
}
void
ChildProcessInfo
:
:
OnPingResponse
(
const
PingResponseMessage
&
aMsg
)
{
for
(
size_t
i
=
0
;
i
<
mPings
.
length
(
)
;
i
+
+
)
{
if
(
mPings
[
i
]
.
mId
=
=
aMsg
.
mId
)
{
mPings
[
i
]
.
mProgress
=
aMsg
.
mProgress
;
break
;
}
}
}
void
ChildProcessInfo
:
:
WaitUntilPaused
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
while
(
!
IsPaused
(
)
)
{
MaybePing
(
)
;
Maybe
<
MonitorAutoLock
>
lock
;
lock
.
emplace
(
*
gMonitor
)
;
MaybeHandlePendingSyncMessage
(
)
;
ChildProcessInfo
*
process
=
this
;
Message
:
:
UniquePtr
msg
=
ExtractChildMessage
(
&
process
)
;
if
(
msg
)
{
lock
.
reset
(
)
;
OnIncomingMessage
(
*
msg
)
;
}
else
if
(
HasCrashed
(
)
)
{
break
;
}
else
{
TimeStamp
deadline
=
TimeStamp
:
:
Now
(
)
+
TimeDuration
:
:
FromSeconds
(
PingIntervalSeconds
)
;
gMonitor
-
>
WaitUntil
(
deadline
)
;
}
}
}
static
bool
gHasPendingMessageRunnable
;
void
ChildProcessInfo
:
:
MaybeProcessPendingMessageRunnable
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
gHasPendingMessageRunnable
)
;
gHasPendingMessageRunnable
=
false
;
while
(
true
)
{
ChildProcessInfo
*
process
=
nullptr
;
Message
:
:
UniquePtr
msg
=
ExtractChildMessage
(
&
process
)
;
if
(
msg
)
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
process
-
>
OnIncomingMessage
(
*
msg
)
;
}
else
{
break
;
}
}
}
void
ChildProcessInfo
:
:
ReceiveChildMessageOnMainThread
(
Message
:
:
UniquePtr
aMsg
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
PendingMessage
pending
;
pending
.
mProcess
=
this
;
pending
.
mMsg
=
std
:
:
move
(
aMsg
)
;
gPendingMessages
.
append
(
std
:
:
move
(
pending
)
)
;
gMonitor
-
>
NotifyAll
(
)
;
if
(
!
gHasPendingMessageRunnable
)
{
gHasPendingMessageRunnable
=
true
;
MainThreadMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
MaybeProcessPendingMessageRunnable
"
MaybeProcessPendingMessageRunnable
)
)
;
}
}
}
}
}
