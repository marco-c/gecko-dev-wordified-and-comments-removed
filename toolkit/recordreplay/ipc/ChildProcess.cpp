#
include
"
ParentInternal
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
Thread
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
static
IntroductionMessage
*
gIntroductionMessage
;
void
ChildProcessInfo
:
:
SetIntroductionMessage
(
IntroductionMessage
*
aMessage
)
{
gIntroductionMessage
=
aMessage
;
}
ChildProcessInfo
:
:
ChildProcessInfo
(
size_t
aId
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
:
mRecording
(
aRecordingProcessData
.
isSome
(
)
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
Channel
:
:
Kind
kind
=
IsRecording
(
)
?
Channel
:
:
Kind
:
:
MiddlemanRecord
:
Channel
:
:
Kind
:
:
MiddlemanReplay
;
mChannel
=
new
Channel
(
aId
kind
[
=
]
(
Message
:
:
UniquePtr
aMsg
)
{
ReceiveChildMessageOnMainThread
(
aId
std
:
:
move
(
aMsg
)
)
;
}
)
;
LaunchSubprocess
(
aId
aRecordingProcessData
)
;
}
ChildProcessInfo
:
:
~
ChildProcessInfo
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
SendMessage
(
TerminateMessage
(
0
)
)
;
}
void
ChildProcessInfo
:
:
OnIncomingMessage
(
const
Message
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
FatalError
:
{
const
FatalErrorMessage
&
nmsg
=
static_cast
<
const
FatalErrorMessage
&
>
(
aMsg
)
;
OnCrash
(
nmsg
.
mForkId
nmsg
.
Error
(
)
)
;
return
;
}
case
MessageType
:
:
CloudError
:
{
const
auto
&
nmsg
=
static_cast
<
const
CloudErrorMessage
&
>
(
aMsg
)
;
Print
(
"
Fatal
Cloud
Error
:
%
s
\
n
"
nmsg
.
Error
(
)
)
;
MOZ_CRASH
(
"
Cloud
Error
"
)
;
return
;
}
case
MessageType
:
:
Paint
:
UpdateGraphicsAfterPaint
(
static_cast
<
const
PaintMessage
&
>
(
aMsg
)
)
;
break
;
case
MessageType
:
:
PaintEncoded
:
{
const
PaintEncodedMessage
&
nmsg
=
static_cast
<
const
PaintEncodedMessage
&
>
(
aMsg
)
;
nsDependentCSubstring
data
(
nmsg
.
BinaryData
(
)
nmsg
.
BinaryDataSize
(
)
)
;
nsAutoCString
dataBinary
;
if
(
NS_FAILED
(
Base64Decode
(
data
dataBinary
)
)
)
{
MOZ_CRASH
(
"
Base64Decode
failed
"
)
;
}
UpdateGraphicsAfterRepaint
(
dataBinary
)
;
break
;
}
case
MessageType
:
:
ManifestFinished
:
{
const
auto
&
nmsg
=
static_cast
<
const
ManifestFinishedMessage
&
>
(
aMsg
)
;
js
:
:
ForwardManifestFinished
(
this
nmsg
)
;
break
;
}
case
MessageType
:
:
UnhandledDivergence
:
{
const
auto
&
nmsg
=
static_cast
<
const
UnhandledDivergenceMessage
&
>
(
aMsg
)
;
js
:
:
ForwardUnhandledDivergence
(
this
nmsg
)
;
break
;
}
case
MessageType
:
:
PingResponse
:
{
const
auto
&
nmsg
=
static_cast
<
const
PingResponseMessage
&
>
(
aMsg
)
;
js
:
:
ForwardPingResponse
(
this
nmsg
)
;
break
;
}
case
MessageType
:
:
ExternalCallRequest
:
{
const
auto
&
nmsg
=
static_cast
<
const
ExternalCallRequestMessage
&
>
(
aMsg
)
;
InfallibleVector
<
char
>
outputData
;
ProcessExternalCall
(
nmsg
.
BinaryData
(
)
nmsg
.
BinaryDataSize
(
)
&
outputData
)
;
Message
:
:
UniquePtr
response
(
ExternalCallResponseMessage
:
:
New
(
nmsg
.
mForkId
nmsg
.
mTag
outputData
.
begin
(
)
outputData
.
length
(
)
)
)
;
SendMessage
(
std
:
:
move
(
*
response
)
)
;
break
;
}
case
MessageType
:
:
RecordingData
:
{
const
auto
&
msg
=
static_cast
<
const
RecordingDataMessage
&
>
(
aMsg
)
;
MOZ_RELEASE_ASSERT
(
msg
.
mTag
=
=
gRecordingContents
.
length
(
)
)
;
gRecordingContents
.
append
(
msg
.
BinaryData
(
)
msg
.
BinaryDataSize
(
)
)
;
break
;
}
default
:
break
;
}
}
void
ChildProcessInfo
:
:
SendMessage
(
Message
&
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
mChannel
-
>
SendMessage
(
std
:
:
move
(
aMsg
)
)
;
}
ipc
:
:
GeckoChildProcessHost
*
gRecordingProcess
;
void
GetArgumentsForChildProcess
(
base
:
:
ProcessId
aMiddlemanPid
uint32_t
aChannelId
const
char
*
aRecordingFile
bool
aRecording
std
:
:
vector
<
std
:
:
string
>
&
aExtraArgs
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
|
|
XRE_IsParentProcess
(
)
)
;
aExtraArgs
.
push_back
(
gMiddlemanPidOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
aMiddlemanPid
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gChannelIDOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
(
int
)
aChannelId
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gProcessKindOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
aRecording
?
(
int
)
ProcessKind
:
:
Recording
:
(
int
)
ProcessKind
:
:
Replaying
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gRecordingFileOption
)
;
aExtraArgs
.
push_back
(
aRecordingFile
)
;
}
void
ChildProcessInfo
:
:
LaunchSubprocess
(
size_t
aChannelId
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
=
=
aRecordingProcessData
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
gIntroductionMessage
)
;
SendMessage
(
std
:
:
move
(
*
gIntroductionMessage
)
)
;
if
(
IsRecording
(
)
)
{
std
:
:
vector
<
std
:
:
string
>
extraArgs
;
GetArgumentsForChildProcess
(
base
:
:
GetCurrentProcId
(
)
aChannelId
gRecordingFilename
true
extraArgs
)
;
MOZ_RELEASE_ASSERT
(
!
gRecordingProcess
)
;
gRecordingProcess
=
new
ipc
:
:
GeckoChildProcessHost
(
GeckoProcessType_Content
)
;
gRecordingProcess
-
>
AddFdToRemap
(
aRecordingProcessData
.
ref
(
)
.
mPrefsHandle
.
fd
kPrefsFileDescriptor
)
;
ipc
:
:
FileDescriptor
:
:
UniquePlatformHandle
prefMapHandle
=
aRecordingProcessData
.
ref
(
)
.
mPrefMapHandle
.
ClonePlatformHandle
(
)
;
gRecordingProcess
-
>
AddFdToRemap
(
prefMapHandle
.
get
(
)
kPrefMapFileDescriptor
)
;
if
(
!
gRecordingProcess
-
>
LaunchAndWaitForProcessHandle
(
extraArgs
)
)
{
MOZ_CRASH
(
"
ChildProcessInfo
:
:
LaunchSubprocess
"
)
;
}
SendGraphicsMemoryToChild
(
)
;
}
else
{
UniquePtr
<
Message
>
msg
(
RecordingDataMessage
:
:
New
(
0
0
gRecordingContents
.
begin
(
)
gRecordingContents
.
length
(
)
)
)
;
SendMessage
(
std
:
:
move
(
*
msg
)
)
;
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendCreateReplayingProcess
(
aChannelId
)
;
}
}
void
ChildProcessInfo
:
:
OnCrash
(
size_t
aForkId
const
char
*
aWhy
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplayError
nsAutoCString
(
aWhy
)
)
;
if
(
!
IsRecording
(
)
)
{
if
(
!
UseCloudForReplayingProcesses
(
)
)
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendGenerateReplayCrashReport
(
GetId
(
)
)
;
}
if
(
js
:
:
RecoverFromCrash
(
GetId
(
)
aForkId
)
)
{
return
;
}
}
Shutdown
(
)
;
}
struct
PendingMessage
{
size_t
mChildId
=
0
;
Message
:
:
UniquePtr
mMsg
;
PendingMessage
(
)
{
}
PendingMessage
&
operator
=
(
PendingMessage
&
&
aOther
)
{
mChildId
=
aOther
.
mChildId
;
mMsg
=
std
:
:
move
(
aOther
.
mMsg
)
;
return
*
this
;
}
PendingMessage
(
PendingMessage
&
&
aOther
)
{
*
this
=
std
:
:
move
(
aOther
)
;
}
}
;
static
StaticInfallibleVector
<
PendingMessage
>
gPendingMessages
;
static
Message
:
:
UniquePtr
ExtractChildMessage
(
ChildProcessInfo
*
*
aProcess
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gPendingMessages
.
length
(
)
)
{
return
nullptr
;
}
PendingMessage
&
pending
=
gPendingMessages
[
0
]
;
*
aProcess
=
GetChildProcess
(
pending
.
mChildId
)
;
MOZ_RELEASE_ASSERT
(
*
aProcess
)
;
Message
:
:
UniquePtr
msg
=
std
:
:
move
(
pending
.
mMsg
)
;
gPendingMessages
.
erase
(
&
pending
)
;
return
msg
;
}
void
ChildProcessInfo
:
:
MaybeProcessNextMessage
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
MonitorAutoLock
>
lock
;
lock
.
emplace
(
*
gMonitor
)
;
MaybeHandlePendingSyncMessage
(
)
;
ChildProcessInfo
*
process
;
Message
:
:
UniquePtr
msg
=
ExtractChildMessage
(
&
process
)
;
if
(
msg
)
{
lock
.
reset
(
)
;
process
-
>
OnIncomingMessage
(
*
msg
)
;
}
else
{
TimeStamp
deadline
=
TimeStamp
:
:
Now
(
)
+
TimeDuration
:
:
FromSeconds
(
1
)
;
gMonitor
-
>
WaitUntil
(
deadline
)
;
}
}
static
bool
gHasPendingMessageRunnable
;
void
ChildProcessInfo
:
:
MaybeProcessPendingMessageRunnable
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
gHasPendingMessageRunnable
)
;
gHasPendingMessageRunnable
=
false
;
while
(
true
)
{
ChildProcessInfo
*
process
=
nullptr
;
Message
:
:
UniquePtr
msg
=
ExtractChildMessage
(
&
process
)
;
if
(
msg
)
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
process
-
>
OnIncomingMessage
(
*
msg
)
;
}
else
{
break
;
}
}
}
void
ChildProcessInfo
:
:
ReceiveChildMessageOnMainThread
(
size_t
aChildId
Message
:
:
UniquePtr
aMsg
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
PendingMessage
pending
;
pending
.
mChildId
=
aChildId
;
pending
.
mMsg
=
std
:
:
move
(
aMsg
)
;
gPendingMessages
.
append
(
std
:
:
move
(
pending
)
)
;
gMonitor
-
>
NotifyAll
(
)
;
if
(
!
gHasPendingMessageRunnable
)
{
gHasPendingMessageRunnable
=
true
;
MainThreadMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
MaybeProcessPendingMessageRunnable
"
MaybeProcessPendingMessageRunnable
)
)
;
}
}
}
}
}
