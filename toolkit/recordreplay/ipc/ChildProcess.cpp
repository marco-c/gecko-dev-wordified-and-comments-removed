#
include
"
ParentInternal
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
Thread
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
static
IntroductionMessage
*
gIntroductionMessage
;
static
size_t
gNumChannels
;
static
bool
gChildrenAreDebugging
;
void
ChildProcessInfo
:
:
SetIntroductionMessage
(
IntroductionMessage
*
aMessage
)
{
gIntroductionMessage
=
aMessage
;
}
ChildProcessInfo
:
:
ChildProcessInfo
(
UniquePtr
<
ChildRole
>
aRole
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
:
mChannel
(
nullptr
)
mRecording
(
aRecordingProcessData
.
isSome
(
)
)
mRecoveryStage
(
RecoveryStage
:
:
None
)
mPaused
(
false
)
mPausedMessage
(
nullptr
)
mLastCheckpoint
(
CheckpointId
:
:
Invalid
)
mNumRecoveredMessages
(
0
)
mRole
(
std
:
:
move
(
aRole
)
)
mPauseNeeded
(
false
)
mHasBegunFatalError
(
false
)
mHasFatalError
(
false
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
gFirst
=
false
;
if
(
!
gFirst
)
{
gFirst
=
true
;
gChildrenAreDebugging
=
!
!
getenv
(
"
WAIT_AT_START
"
)
;
}
mRole
-
>
SetProcess
(
this
)
;
LaunchSubprocess
(
aRecordingProcessData
)
;
if
(
!
IsRecording
(
)
&
&
CanRewind
(
)
)
{
SendMessage
(
SetSaveCheckpointMessage
(
CheckpointId
:
:
First
true
)
)
;
}
mRole
-
>
Initialize
(
)
;
}
ChildProcessInfo
:
:
~
ChildProcessInfo
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsRecording
(
)
)
{
SendMessage
(
TerminateMessage
(
)
)
;
}
}
ChildProcessInfo
:
:
Disposition
ChildProcessInfo
:
:
GetDisposition
(
)
{
for
(
Message
*
msg
:
mMessages
)
{
if
(
msg
-
>
mType
=
=
MessageType
:
:
Resume
)
{
const
ResumeMessage
&
nmsg
=
static_cast
<
const
ResumeMessage
&
>
(
*
msg
)
;
return
nmsg
.
mForward
?
AfterLastCheckpoint
:
BeforeLastCheckpoint
;
}
}
return
AtLastCheckpoint
;
}
bool
ChildProcessInfo
:
:
IsPausedAtCheckpoint
(
)
{
return
IsPaused
(
)
&
&
mPausedMessage
-
>
mType
=
=
MessageType
:
:
HitCheckpoint
;
}
bool
ChildProcessInfo
:
:
IsPausedAtRecordingEndpoint
(
)
{
if
(
!
IsPaused
(
)
)
{
return
false
;
}
if
(
mPausedMessage
-
>
mType
=
=
MessageType
:
:
HitCheckpoint
)
{
return
static_cast
<
HitCheckpointMessage
*
>
(
mPausedMessage
)
-
>
mRecordingEndpoint
;
}
if
(
mPausedMessage
-
>
mType
=
=
MessageType
:
:
HitBreakpoint
)
{
return
static_cast
<
HitBreakpointMessage
*
>
(
mPausedMessage
)
-
>
mRecordingEndpoint
;
}
return
false
;
}
void
ChildProcessInfo
:
:
GetInstalledBreakpoints
(
InfallibleVector
<
AddBreakpointMessage
*
>
&
aBreakpoints
)
{
MOZ_RELEASE_ASSERT
(
aBreakpoints
.
empty
(
)
)
;
for
(
Message
*
msg
:
mMessages
)
{
if
(
msg
-
>
mType
=
=
MessageType
:
:
AddBreakpoint
)
{
aBreakpoints
.
append
(
static_cast
<
AddBreakpointMessage
*
>
(
msg
)
)
;
}
else
if
(
msg
-
>
mType
=
=
MessageType
:
:
ClearBreakpoints
)
{
aBreakpoints
.
clear
(
)
;
}
}
}
void
ChildProcessInfo
:
:
AddMajorCheckpoint
(
size_t
aId
)
{
MOZ_RELEASE_ASSERT
(
mMajorCheckpoints
.
empty
(
)
|
|
aId
>
mMajorCheckpoints
.
back
(
)
)
;
mMajorCheckpoints
.
append
(
aId
)
;
}
void
ChildProcessInfo
:
:
SetRole
(
UniquePtr
<
ChildRole
>
aRole
)
{
MOZ_RELEASE_ASSERT
(
!
IsRecovering
(
)
)
;
PrintSpew
(
"
SetRole
:
%
d
%
s
\
n
"
(
int
)
GetId
(
)
ChildRole
:
:
TypeString
(
aRole
-
>
GetType
(
)
)
)
;
mRole
=
std
:
:
move
(
aRole
)
;
mRole
-
>
SetProcess
(
this
)
;
mRole
-
>
Initialize
(
)
;
}
void
ChildProcessInfo
:
:
OnIncomingMessage
(
size_t
aChannelId
const
Message
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aChannelId
!
=
mChannel
-
>
GetId
(
)
)
{
return
;
}
if
(
aMsg
.
mType
=
=
MessageType
:
:
BeginFatalError
)
{
mHasBegunFatalError
=
true
;
return
;
}
else
if
(
aMsg
.
mType
=
=
MessageType
:
:
FatalError
)
{
mHasFatalError
=
true
;
const
FatalErrorMessage
&
nmsg
=
static_cast
<
const
FatalErrorMessage
&
>
(
aMsg
)
;
OnCrash
(
nmsg
.
Error
(
)
)
;
return
;
}
mLastMessageTime
=
TimeStamp
:
:
Now
(
)
;
if
(
IsRecovering
(
)
)
{
OnIncomingRecoveryMessage
(
aMsg
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
!
IsPaused
(
)
)
;
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
HitCheckpoint
:
case
MessageType
:
:
HitBreakpoint
:
MOZ_RELEASE_ASSERT
(
!
mPausedMessage
)
;
mPausedMessage
=
aMsg
.
Clone
(
)
;
MOZ_FALLTHROUGH
;
case
MessageType
:
:
DebuggerResponse
:
case
MessageType
:
:
RecordingFlushed
:
MOZ_RELEASE_ASSERT
(
mPausedMessage
)
;
mPaused
=
true
;
break
;
default
:
break
;
}
if
(
aMsg
.
mType
=
=
MessageType
:
:
HitCheckpoint
)
{
const
HitCheckpointMessage
&
nmsg
=
static_cast
<
const
HitCheckpointMessage
&
>
(
aMsg
)
;
mLastCheckpoint
=
nmsg
.
mCheckpointId
;
InfallibleVector
<
Message
*
>
newMessages
;
for
(
Message
*
msg
:
mMessages
)
{
if
(
msg
-
>
mType
=
=
MessageType
:
:
AddBreakpoint
)
{
newMessages
.
append
(
msg
)
;
}
else
{
if
(
msg
-
>
mType
=
=
MessageType
:
:
ClearBreakpoints
)
{
for
(
Message
*
existing
:
newMessages
)
{
free
(
existing
)
;
}
newMessages
.
clear
(
)
;
}
free
(
msg
)
;
}
}
mMessages
=
std
:
:
move
(
newMessages
)
;
}
if
(
aMsg
.
mType
!
=
MessageType
:
:
HitCheckpoint
|
|
mLastCheckpoint
)
{
mRole
-
>
OnIncomingMessage
(
aMsg
)
;
}
}
void
ChildProcessInfo
:
:
SendMessage
(
const
Message
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
!
IsRecovering
(
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsPaused
(
)
|
|
aMsg
.
CanBeSentWhileUnpaused
(
)
)
;
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
Resume
:
case
MessageType
:
:
RestoreCheckpoint
:
case
MessageType
:
:
RunToPoint
:
free
(
mPausedMessage
)
;
mPausedMessage
=
nullptr
;
MOZ_FALLTHROUGH
;
case
MessageType
:
:
DebuggerRequest
:
case
MessageType
:
:
FlushRecording
:
mPaused
=
false
;
break
;
default
:
break
;
}
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
Resume
:
case
MessageType
:
:
RestoreCheckpoint
:
case
MessageType
:
:
RunToPoint
:
case
MessageType
:
:
DebuggerRequest
:
case
MessageType
:
:
AddBreakpoint
:
case
MessageType
:
:
ClearBreakpoints
:
mMessages
.
emplaceBack
(
aMsg
.
Clone
(
)
)
;
break
;
default
:
break
;
}
if
(
aMsg
.
mType
=
=
MessageType
:
:
SetSaveCheckpoint
)
{
const
SetSaveCheckpointMessage
&
nmsg
=
static_cast
<
const
SetSaveCheckpointMessage
&
>
(
aMsg
)
;
MOZ_RELEASE_ASSERT
(
nmsg
.
mCheckpoint
>
MostRecentCheckpoint
(
)
)
;
VectorAddOrRemoveEntry
(
mShouldSaveCheckpoints
nmsg
.
mCheckpoint
nmsg
.
mSave
)
;
}
SendMessageRaw
(
aMsg
)
;
}
void
ChildProcessInfo
:
:
SendMessageRaw
(
const
Message
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
mLastMessageTime
=
TimeStamp
:
:
Now
(
)
;
mChannel
-
>
SendMessage
(
aMsg
)
;
}
void
ChildProcessInfo
:
:
Recover
(
bool
aPaused
Message
*
aPausedMessage
size_t
aLastCheckpoint
Message
*
*
aMessages
size_t
aNumMessages
)
{
MOZ_RELEASE_ASSERT
(
IsPaused
(
)
)
;
SendMessageRaw
(
SetIsActiveMessage
(
false
)
)
;
size_t
mostRecentCheckpoint
=
MostRecentCheckpoint
(
)
;
bool
pausedAtCheckpoint
=
IsPausedAtCheckpoint
(
)
;
for
(
Message
*
msg
:
mMessages
)
{
free
(
msg
)
;
}
mMessages
.
clear
(
)
;
SendMessageRaw
(
ClearBreakpointsMessage
(
)
)
;
mPaused
=
aPaused
;
mPausedMessage
=
aPausedMessage
;
mLastCheckpoint
=
aLastCheckpoint
;
for
(
size_t
i
=
0
;
i
<
aNumMessages
;
i
+
+
)
{
mMessages
.
append
(
aMessages
[
i
]
-
>
Clone
(
)
)
;
}
mNumRecoveredMessages
=
0
;
if
(
mostRecentCheckpoint
<
mLastCheckpoint
)
{
mRecoveryStage
=
RecoveryStage
:
:
ReachingCheckpoint
;
SendMessageRaw
(
ResumeMessage
(
true
)
)
;
}
else
if
(
mostRecentCheckpoint
>
mLastCheckpoint
|
|
!
pausedAtCheckpoint
)
{
mRecoveryStage
=
RecoveryStage
:
:
ReachingCheckpoint
;
size_t
targetCheckpoint
=
CheckpointId
:
:
Invalid
;
for
(
size_t
saved
:
mShouldSaveCheckpoints
)
{
if
(
saved
<
=
mLastCheckpoint
&
&
saved
>
targetCheckpoint
)
{
targetCheckpoint
=
saved
;
}
}
MOZ_RELEASE_ASSERT
(
targetCheckpoint
!
=
CheckpointId
:
:
Invalid
)
;
SendMessageRaw
(
RestoreCheckpointMessage
(
targetCheckpoint
)
)
;
}
else
{
mRecoveryStage
=
RecoveryStage
:
:
PlayingMessages
;
SendNextRecoveryMessage
(
)
;
}
WaitUntil
(
[
=
]
(
)
{
return
!
IsRecovering
(
)
;
}
)
;
}
void
ChildProcessInfo
:
:
Recover
(
ChildProcessInfo
*
aTargetProcess
)
{
MOZ_RELEASE_ASSERT
(
aTargetProcess
-
>
IsPaused
(
)
)
;
Recover
(
true
aTargetProcess
-
>
mPausedMessage
-
>
Clone
(
)
aTargetProcess
-
>
mLastCheckpoint
aTargetProcess
-
>
mMessages
.
begin
(
)
aTargetProcess
-
>
mMessages
.
length
(
)
)
;
}
void
ChildProcessInfo
:
:
RecoverToCheckpoint
(
size_t
aCheckpoint
)
{
HitCheckpointMessage
pausedMessage
(
aCheckpoint
false
0
)
;
Recover
(
true
pausedMessage
.
Clone
(
)
aCheckpoint
nullptr
0
)
;
}
void
ChildProcessInfo
:
:
OnIncomingRecoveryMessage
(
const
Message
&
aMsg
)
{
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
HitCheckpoint
:
{
MOZ_RELEASE_ASSERT
(
mRecoveryStage
=
=
RecoveryStage
:
:
ReachingCheckpoint
)
;
const
HitCheckpointMessage
&
nmsg
=
static_cast
<
const
HitCheckpointMessage
&
>
(
aMsg
)
;
if
(
nmsg
.
mCheckpointId
<
mLastCheckpoint
)
{
SendMessageRaw
(
ResumeMessage
(
true
)
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
nmsg
.
mCheckpointId
=
=
mLastCheckpoint
)
;
mRecoveryStage
=
RecoveryStage
:
:
PlayingMessages
;
SendNextRecoveryMessage
(
)
;
}
break
;
}
case
MessageType
:
:
HitBreakpoint
:
case
MessageType
:
:
DebuggerResponse
:
SendNextRecoveryMessage
(
)
;
break
;
case
MessageType
:
:
MiddlemanCallRequest
:
{
MiddlemanCallResponseMessage
*
response
=
ProcessMiddlemanCallMessage
(
(
MiddlemanCallRequestMessage
&
)
aMsg
)
;
SendMessageRaw
(
*
response
)
;
free
(
response
)
;
break
;
}
case
MessageType
:
:
ResetMiddlemanCalls
:
ResetMiddlemanCalls
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
message
during
recovery
"
)
;
}
}
void
ChildProcessInfo
:
:
SendNextRecoveryMessage
(
)
{
MOZ_RELEASE_ASSERT
(
mRecoveryStage
=
=
RecoveryStage
:
:
PlayingMessages
)
;
Message
*
msg
;
do
{
if
(
mNumRecoveredMessages
=
=
mMessages
.
length
(
)
)
{
MOZ_RELEASE_ASSERT
(
IsPaused
(
)
)
;
mRecoveryStage
=
RecoveryStage
:
:
None
;
return
;
}
msg
=
mMessages
[
mNumRecoveredMessages
+
+
]
;
SendMessageRaw
(
*
msg
)
;
}
while
(
msg
-
>
mType
=
=
MessageType
:
:
AddBreakpoint
|
|
msg
-
>
mType
=
=
MessageType
:
:
ClearBreakpoints
)
;
if
(
mNumRecoveredMessages
=
=
mMessages
.
length
(
)
&
&
!
IsPaused
(
)
)
{
mRecoveryStage
=
RecoveryStage
:
:
None
;
}
}
ipc
:
:
GeckoChildProcessHost
*
gRecordingProcess
;
void
GetArgumentsForChildProcess
(
base
:
:
ProcessId
aMiddlemanPid
uint32_t
aChannelId
const
char
*
aRecordingFile
bool
aRecording
std
:
:
vector
<
std
:
:
string
>
&
aExtraArgs
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
|
|
XRE_IsParentProcess
(
)
)
;
aExtraArgs
.
push_back
(
gMiddlemanPidOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
aMiddlemanPid
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gChannelIDOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
(
int
)
aChannelId
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gProcessKindOption
)
;
aExtraArgs
.
push_back
(
nsPrintfCString
(
"
%
d
"
aRecording
?
(
int
)
ProcessKind
:
:
Recording
:
(
int
)
ProcessKind
:
:
Replaying
)
.
get
(
)
)
;
aExtraArgs
.
push_back
(
gRecordingFileOption
)
;
aExtraArgs
.
push_back
(
aRecordingFile
)
;
}
void
ChildProcessInfo
:
:
LaunchSubprocess
(
const
Maybe
<
RecordingProcessData
>
&
aRecordingProcessData
)
{
size_t
channelId
=
gNumChannels
+
+
;
mChannel
=
new
Channel
(
channelId
IsRecording
(
)
[
=
]
(
Message
*
aMsg
)
{
ReceiveChildMessageOnMainThread
(
channelId
aMsg
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
=
=
aRecordingProcessData
.
isSome
(
)
)
;
if
(
IsRecording
(
)
)
{
std
:
:
vector
<
std
:
:
string
>
extraArgs
;
GetArgumentsForChildProcess
(
base
:
:
GetCurrentProcId
(
)
channelId
gRecordingFilename
true
extraArgs
)
;
MOZ_RELEASE_ASSERT
(
!
gRecordingProcess
)
;
gRecordingProcess
=
new
ipc
:
:
GeckoChildProcessHost
(
GeckoProcessType_Content
)
;
gRecordingProcess
-
>
AddFdToRemap
(
aRecordingProcessData
.
ref
(
)
.
mPrefsHandle
.
fd
kPrefsFileDescriptor
)
;
ipc
:
:
FileDescriptor
:
:
UniquePlatformHandle
prefMapHandle
=
aRecordingProcessData
.
ref
(
)
.
mPrefMapHandle
.
ClonePlatformHandle
(
)
;
gRecordingProcess
-
>
AddFdToRemap
(
prefMapHandle
.
get
(
)
kPrefMapFileDescriptor
)
;
if
(
!
gRecordingProcess
-
>
LaunchAndWaitForProcessHandle
(
extraArgs
)
)
{
MOZ_CRASH
(
"
ChildProcessInfo
:
:
LaunchSubprocess
"
)
;
}
}
else
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendCreateReplayingProcess
(
channelId
)
;
}
mLastMessageTime
=
TimeStamp
:
:
Now
(
)
;
SendGraphicsMemoryToChild
(
)
;
WaitUntilPaused
(
)
;
MOZ_RELEASE_ASSERT
(
gIntroductionMessage
)
;
SendMessage
(
*
gIntroductionMessage
)
;
}
void
ChildProcessInfo
:
:
OnCrash
(
const
char
*
aWhy
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplayError
nsAutoCString
(
aWhy
)
)
;
if
(
mHasFatalError
)
{
Shutdown
(
)
;
}
MOZ_RELEASE_ASSERT
(
!
mHasBegunFatalError
)
;
MOZ_CRASH
(
"
Unexpected
child
crash
"
)
;
}
struct
PendingMessage
{
ChildProcessInfo
*
mProcess
;
size_t
mChannelId
;
Message
*
mMsg
;
}
;
static
StaticInfallibleVector
<
PendingMessage
>
gPendingMessages
;
static
bool
gHasPendingMessageRunnable
;
bool
ChildProcessInfo
:
:
MaybeProcessPendingMessage
(
ChildProcessInfo
*
aProcess
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
size_t
i
=
0
;
i
<
gPendingMessages
.
length
(
)
;
i
+
+
)
{
if
(
!
aProcess
|
|
gPendingMessages
[
i
]
.
mProcess
=
=
aProcess
)
{
PendingMessage
copy
=
gPendingMessages
[
i
]
;
gPendingMessages
.
erase
(
&
gPendingMessages
[
i
]
)
;
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
copy
.
mProcess
-
>
OnIncomingMessage
(
copy
.
mChannelId
*
copy
.
mMsg
)
;
free
(
copy
.
mMsg
)
;
return
true
;
}
}
return
false
;
}
static
const
size_t
HangSeconds
=
30
;
void
ChildProcessInfo
:
:
WaitUntil
(
const
std
:
:
function
<
bool
(
)
>
&
aCallback
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
sentTerminateMessage
=
false
;
while
(
!
aCallback
(
)
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
!
MaybeProcessPendingMessage
(
this
)
)
{
if
(
gChildrenAreDebugging
|
|
IsRecording
(
)
)
{
gMonitor
-
>
Wait
(
)
;
}
else
{
TimeStamp
deadline
=
mLastMessageTime
+
TimeDuration
:
:
FromSeconds
(
HangSeconds
)
;
if
(
TimeStamp
:
:
Now
(
)
>
=
deadline
)
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
if
(
!
sentTerminateMessage
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplayHang
true
)
;
SendMessageRaw
(
TerminateMessage
(
)
)
;
sentTerminateMessage
=
true
;
}
else
{
OnCrash
(
"
Child
process
non
-
responsive
"
)
;
}
}
gMonitor
-
>
WaitUntil
(
deadline
)
;
}
}
}
}
void
ChildProcessInfo
:
:
MaybeProcessPendingMessageRunnable
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
MOZ_RELEASE_ASSERT
(
gHasPendingMessageRunnable
)
;
gHasPendingMessageRunnable
=
false
;
while
(
MaybeProcessPendingMessage
(
nullptr
)
)
{
}
}
void
ChildProcessInfo
:
:
ReceiveChildMessageOnMainThread
(
size_t
aChannelId
Message
*
aMsg
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
PendingMessage
pending
;
pending
.
mProcess
=
this
;
pending
.
mChannelId
=
aChannelId
;
pending
.
mMsg
=
aMsg
;
gPendingMessages
.
append
(
pending
)
;
gMonitor
-
>
NotifyAll
(
)
;
if
(
!
gHasPendingMessageRunnable
)
{
gHasPendingMessageRunnable
=
true
;
MainThreadMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
MaybeProcessPendingMessageRunnable
"
MaybeProcessPendingMessageRunnable
)
)
;
}
}
}
}
}
