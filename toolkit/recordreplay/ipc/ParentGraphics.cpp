#
include
"
ParentInternal
.
h
"
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
PTextureChild
.
h
"
#
include
"
nsImportModule
.
h
"
#
include
"
rrIGraphics
.
h
"
#
include
<
mach
/
mach_vm
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
void
*
gGraphicsMemory
;
static
mach_port_t
gGraphicsPort
;
static
ReceivePort
*
gGraphicsReceiver
;
void
InitializeGraphicsMemory
(
)
{
mach_vm_address_t
address
;
kern_return_t
kr
=
mach_vm_allocate
(
mach_task_self
(
)
&
address
GraphicsMemorySize
VM_FLAGS_ANYWHERE
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
memory_object_size_t
memoryObjectSize
=
GraphicsMemorySize
;
kr
=
mach_make_memory_entry_64
(
mach_task_self
(
)
&
memoryObjectSize
address
VM_PROT_DEFAULT
&
gGraphicsPort
MACH_PORT_NULL
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
memoryObjectSize
=
=
GraphicsMemorySize
)
;
gGraphicsMemory
=
(
void
*
)
address
;
gGraphicsReceiver
=
new
ReceivePort
(
nsPrintfCString
(
"
WebReplay
.
%
d
"
getpid
(
)
)
.
get
(
)
)
;
}
void
SendGraphicsMemoryToChild
(
)
{
MachReceiveMessage
handshakeMessage
;
kern_return_t
kr
=
gGraphicsReceiver
-
>
WaitForMessage
(
&
handshakeMessage
0
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
handshakeMessage
.
GetMessageID
(
)
=
=
GraphicsHandshakeMessageId
)
;
mach_port_t
childPort
=
handshakeMessage
.
GetTranslatedPort
(
0
)
;
MOZ_RELEASE_ASSERT
(
childPort
!
=
MACH_PORT_NULL
)
;
MachSendMessage
message
(
GraphicsMemoryMessageId
)
;
message
.
AddDescriptor
(
MachMsgPortDescriptor
(
gGraphicsPort
MACH_MSG_TYPE_COPY_SEND
)
)
;
MachPortSender
sender
(
childPort
)
;
kr
=
sender
.
SendMessage
(
message
1000
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
}
static
StaticRefPtr
<
rrIGraphics
>
gGraphics
;
static
void
InitGraphicsSandbox
(
)
{
MOZ_RELEASE_ASSERT
(
!
gGraphics
)
;
nsCOMPtr
<
rrIGraphics
>
graphics
=
do_ImportModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
replay
/
graphics
.
js
"
)
;
gGraphics
=
graphics
.
forget
(
)
;
ClearOnShutdown
(
&
gGraphics
)
;
MOZ_RELEASE_ASSERT
(
gGraphics
)
;
}
static
void
*
gBufferMemory
;
static
size_t
gLastPaintWidth
gLastPaintHeight
;
void
UpdateGraphicsInUIProcess
(
const
PaintMessage
*
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aMsg
)
{
gLastPaintWidth
=
aMsg
-
>
mWidth
;
gLastPaintHeight
=
aMsg
-
>
mHeight
;
}
if
(
!
gLastPaintWidth
|
|
!
gLastPaintHeight
)
{
return
;
}
bool
hadFailure
=
!
aMsg
;
if
(
!
gGraphics
)
{
InitGraphicsSandbox
(
)
;
}
size_t
width
=
gLastPaintWidth
;
size_t
height
=
gLastPaintHeight
;
size_t
stride
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBStride
(
gSurfaceFormat
width
)
;
CheckedInt
<
size_t
>
scaledWidth
=
CheckedInt
<
size_t
>
(
width
)
*
4
;
CheckedInt
<
size_t
>
scaledHeight
=
CheckedInt
<
size_t
>
(
height
)
*
stride
;
MOZ_RELEASE_ASSERT
(
scaledWidth
.
isValid
(
)
&
&
scaledWidth
.
value
(
)
<
=
stride
)
;
MOZ_RELEASE_ASSERT
(
scaledHeight
.
isValid
(
)
&
&
scaledHeight
.
value
(
)
<
=
GraphicsMemorySize
)
;
MOZ_RELEASE_ASSERT
(
gGraphicsMemory
)
;
void
*
memory
=
gGraphicsMemory
;
if
(
stride
!
=
width
*
4
)
{
if
(
!
gBufferMemory
)
{
gBufferMemory
=
malloc
(
GraphicsMemorySize
)
;
}
memory
=
gBufferMemory
;
for
(
size_t
y
=
0
;
y
<
height
;
y
+
+
)
{
char
*
src
=
(
char
*
)
gGraphicsMemory
+
y
*
stride
;
char
*
dst
=
(
char
*
)
gBufferMemory
+
y
*
width
*
4
;
memcpy
(
dst
src
width
*
4
)
;
}
}
AutoSafeJSContext
cx
;
JSAutoRealm
ar
(
cx
xpc
:
:
PrivilegedJunkScope
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
bufferObject
(
cx
)
;
bufferObject
=
JS
:
:
NewArrayBufferWithUserOwnedContents
(
cx
width
*
height
*
4
memory
)
;
MOZ_RELEASE_ASSERT
(
bufferObject
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
buffer
(
cx
JS
:
:
ObjectValue
(
*
bufferObject
)
)
;
if
(
NS_FAILED
(
gGraphics
-
>
UpdateCanvas
(
buffer
width
height
hadFailure
)
)
)
{
MOZ_CRASH
(
"
UpdateGraphicsInUIProcess
"
)
;
}
MOZ_ALWAYS_TRUE
(
JS
:
:
DetachArrayBuffer
(
cx
bufferObject
)
)
;
}
bool
InRepaintStressMode
(
)
{
static
bool
checked
=
false
;
static
bool
rv
;
if
(
!
checked
)
{
AutoEnsurePassThroughThreadEvents
pt
;
rv
=
TestEnv
(
"
MOZ_RECORD_REPLAY_REPAINT_STRESS
"
)
;
checked
=
true
;
}
return
rv
;
}
}
}
}
