#
include
"
ParentInternal
.
h
"
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
PTextureChild
.
h
"
#
include
<
mach
/
mach_vm
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
void
*
gGraphicsMemory
;
static
mach_port_t
gGraphicsPort
;
static
ReceivePort
*
gGraphicsReceiver
;
void
InitializeGraphicsMemory
(
)
{
mach_vm_address_t
address
;
kern_return_t
kr
=
mach_vm_allocate
(
mach_task_self
(
)
&
address
GraphicsMemorySize
VM_FLAGS_ANYWHERE
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
memory_object_size_t
memoryObjectSize
=
GraphicsMemorySize
;
kr
=
mach_make_memory_entry_64
(
mach_task_self
(
)
&
memoryObjectSize
address
VM_PROT_DEFAULT
&
gGraphicsPort
MACH_PORT_NULL
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
memoryObjectSize
=
=
GraphicsMemorySize
)
;
gGraphicsMemory
=
(
void
*
)
address
;
gGraphicsReceiver
=
new
ReceivePort
(
nsPrintfCString
(
"
WebReplay
.
%
d
"
getpid
(
)
)
.
get
(
)
)
;
}
void
SendGraphicsMemoryToChild
(
)
{
MachReceiveMessage
handshakeMessage
;
kern_return_t
kr
=
gGraphicsReceiver
-
>
WaitForMessage
(
&
handshakeMessage
0
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
handshakeMessage
.
GetMessageID
(
)
=
=
GraphicsHandshakeMessageId
)
;
mach_port_t
childPort
=
handshakeMessage
.
GetTranslatedPort
(
0
)
;
MOZ_RELEASE_ASSERT
(
childPort
!
=
MACH_PORT_NULL
)
;
MachSendMessage
message
(
GraphicsMemoryMessageId
)
;
message
.
AddDescriptor
(
MachMsgPortDescriptor
(
gGraphicsPort
MACH_MSG_TYPE_COPY_SEND
)
)
;
MachPortSender
sender
(
childPort
)
;
kr
=
sender
.
SendMessage
(
message
1000
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
}
static
JS
:
:
PersistentRootedObject
*
gGraphicsSandbox
;
static
void
InitGraphicsSandbox
(
)
{
MOZ_RELEASE_ASSERT
(
!
gGraphicsSandbox
)
;
dom
:
:
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
{
MOZ_CRASH
(
"
InitGraphicsSandbox
"
)
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
xpc
:
:
SandboxOptions
options
;
options
.
sandboxName
.
AssignLiteral
(
"
Record
/
Replay
Graphics
Sandbox
"
)
;
options
.
invisibleToDebugger
=
true
;
RootedValue
v
(
cx
)
;
nsresult
rv
=
CreateSandboxObject
(
cx
&
v
nsXPConnect
:
:
SystemPrincipal
(
)
options
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
gGraphicsSandbox
=
new
JS
:
:
PersistentRootedObject
(
cx
)
;
*
gGraphicsSandbox
=
:
:
js
:
:
UncheckedUnwrap
(
&
v
.
toObject
(
)
)
;
JSAutoRealm
ar
(
cx
*
gGraphicsSandbox
)
;
ErrorResult
er
;
dom
:
:
GlobalObject
global
(
cx
*
gGraphicsSandbox
)
;
RootedObject
obj
(
cx
)
;
dom
:
:
ChromeUtils
:
:
Import
(
global
NS_LITERAL_STRING
(
"
resource
:
/
/
devtools
/
server
/
actors
/
replay
/
graphics
.
js
"
)
dom
:
:
Optional
<
HandleObject
>
(
)
&
obj
er
)
;
MOZ_RELEASE_ASSERT
(
!
er
.
Failed
(
)
)
;
}
static
void
*
gBufferMemory
;
static
size_t
gLastPaintWidth
gLastPaintHeight
;
static
UniquePtr
<
PaintMessage
>
gLastExplicitPaint
;
static
size_t
gLastCheckpoint
;
void
UpdateGraphicsInUIProcess
(
const
PaintMessage
*
aMsg
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aMsg
)
{
gLastPaintWidth
=
aMsg
-
>
mWidth
;
gLastPaintHeight
=
aMsg
-
>
mHeight
;
}
if
(
!
gLastPaintWidth
|
|
!
gLastPaintHeight
)
{
return
;
}
bool
hadFailure
=
!
aMsg
;
gLastExplicitPaint
=
nullptr
;
gLastCheckpoint
=
CheckpointId
:
:
Invalid
;
if
(
!
gGraphicsSandbox
)
{
InitGraphicsSandbox
(
)
;
}
AutoSafeJSContext
cx
;
JSAutoRealm
ar
(
cx
*
gGraphicsSandbox
)
;
size_t
width
=
gLastPaintWidth
;
size_t
height
=
gLastPaintHeight
;
size_t
stride
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBStride
(
gSurfaceFormat
width
)
;
CheckedInt
<
size_t
>
scaledWidth
=
CheckedInt
<
size_t
>
(
width
)
*
4
;
CheckedInt
<
size_t
>
scaledHeight
=
CheckedInt
<
size_t
>
(
height
)
*
stride
;
MOZ_RELEASE_ASSERT
(
scaledWidth
.
isValid
(
)
&
&
scaledWidth
.
value
(
)
<
=
stride
)
;
MOZ_RELEASE_ASSERT
(
scaledHeight
.
isValid
(
)
&
&
scaledHeight
.
value
(
)
<
=
GraphicsMemorySize
)
;
MOZ_RELEASE_ASSERT
(
gGraphicsMemory
)
;
void
*
memory
=
gGraphicsMemory
;
if
(
stride
!
=
width
*
4
)
{
if
(
!
gBufferMemory
)
{
gBufferMemory
=
malloc
(
GraphicsMemorySize
)
;
}
memory
=
gBufferMemory
;
for
(
size_t
y
=
0
;
y
<
height
;
y
+
+
)
{
char
*
src
=
(
char
*
)
gGraphicsMemory
+
y
*
stride
;
char
*
dst
=
(
char
*
)
gBufferMemory
+
y
*
width
*
4
;
memcpy
(
dst
src
width
*
4
)
;
}
}
JSObject
*
bufferObject
=
JS_NewArrayBufferWithExternalContents
(
cx
width
*
height
*
4
memory
)
;
MOZ_RELEASE_ASSERT
(
bufferObject
)
;
JS
:
:
AutoValueArray
<
4
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
bufferObject
)
;
args
[
1
]
.
setInt32
(
width
)
;
args
[
2
]
.
setInt32
(
height
)
;
args
[
3
]
.
setBoolean
(
hadFailure
)
;
RootedValue
rval
(
cx
)
;
if
(
!
JS_CallFunctionName
(
cx
*
gGraphicsSandbox
"
Update
"
args
&
rval
)
)
{
MOZ_CRASH
(
"
UpdateGraphicsInUIProcess
"
)
;
}
}
static
void
MaybeTriggerExplicitPaint
(
)
{
if
(
gLastExplicitPaint
&
&
gLastExplicitPaint
-
>
mCheckpointId
=
=
gLastCheckpoint
)
{
UpdateGraphicsInUIProcess
(
gLastExplicitPaint
.
get
(
)
)
;
}
}
void
MaybeUpdateGraphicsAtPaint
(
const
PaintMessage
&
aMsg
)
{
gLastExplicitPaint
.
reset
(
new
PaintMessage
(
aMsg
)
)
;
MaybeTriggerExplicitPaint
(
)
;
}
void
MaybeUpdateGraphicsAtCheckpoint
(
size_t
aCheckpointId
)
{
gLastCheckpoint
=
aCheckpointId
;
MaybeTriggerExplicitPaint
(
)
;
}
bool
InRepaintStressMode
(
)
{
static
bool
checked
=
false
;
static
bool
rv
;
if
(
!
checked
)
{
AutoEnsurePassThroughThreadEvents
pt
;
rv
=
TestEnv
(
"
MOZ_RECORD_REPLAY_REPAINT_STRESS
"
)
;
checked
=
true
;
}
return
rv
;
}
}
}
}
