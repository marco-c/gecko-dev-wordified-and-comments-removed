#
include
"
ParentInternal
.
h
"
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
PTextureChild
.
h
"
#
include
<
mach
/
mach_vm
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
void
*
gGraphicsMemory
;
static
mach_port_t
gGraphicsPort
;
static
ReceivePort
*
gGraphicsReceiver
;
void
InitializeGraphicsMemory
(
)
{
mach_vm_address_t
address
;
kern_return_t
kr
=
mach_vm_allocate
(
mach_task_self
(
)
&
address
GraphicsMemorySize
VM_FLAGS_ANYWHERE
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
memory_object_size_t
memoryObjectSize
=
GraphicsMemorySize
;
kr
=
mach_make_memory_entry_64
(
mach_task_self
(
)
&
memoryObjectSize
address
VM_PROT_DEFAULT
&
gGraphicsPort
MACH_PORT_NULL
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
memoryObjectSize
=
=
GraphicsMemorySize
)
;
gGraphicsMemory
=
(
void
*
)
address
;
gGraphicsReceiver
=
new
ReceivePort
(
nsPrintfCString
(
"
WebReplay
.
%
d
"
getpid
(
)
)
.
get
(
)
)
;
}
void
SendGraphicsMemoryToChild
(
)
{
MachReceiveMessage
handshakeMessage
;
kern_return_t
kr
=
gGraphicsReceiver
-
>
WaitForMessage
(
&
handshakeMessage
0
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
MOZ_RELEASE_ASSERT
(
handshakeMessage
.
GetMessageID
(
)
=
=
GraphicsHandshakeMessageId
)
;
mach_port_t
childPort
=
handshakeMessage
.
GetTranslatedPort
(
0
)
;
MOZ_RELEASE_ASSERT
(
childPort
!
=
MACH_PORT_NULL
)
;
MachSendMessage
message
(
GraphicsMemoryMessageId
)
;
message
.
AddDescriptor
(
MachMsgPortDescriptor
(
gGraphicsPort
MACH_MSG_TYPE_COPY_SEND
)
)
;
MachPortSender
sender
(
childPort
)
;
kr
=
sender
.
SendMessage
(
message
1000
)
;
MOZ_RELEASE_ASSERT
(
kr
=
=
KERN_SUCCESS
)
;
}
}
}
}
