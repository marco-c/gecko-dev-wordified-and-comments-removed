#
ifndef
mozilla_recordreplay_Channel_h
#
define
mozilla_recordreplay_Channel_h
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ExternalCall
.
h
"
#
include
"
Monitor
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
#
define
ForEachMessageType
(
_Macro
)
\
_Macro
(
Introduction
)
\
\
/
*
An
error
occurred
in
the
cloud
server
.
*
/
\
_Macro
(
CloudError
)
\
\
/
*
Messages
sent
from
the
middleman
to
the
child
process
.
*
/
\
\
/
*
Sent
to
recording
processes
to
indicate
that
the
middleman
will
be
running
*
/
\
/
*
developer
tools
server
-
side
code
instead
of
the
recording
process
itself
.
*
/
\
_Macro
(
SetDebuggerRunsInMiddleman
)
\
\
/
*
Periodically
sent
to
replaying
processes
to
make
sure
they
are
*
/
\
/
*
responsive
and
determine
how
much
progress
they
have
made
.
This
can
be
*
/
\
/
*
sent
while
the
process
is
unpaused
but
only
when
it
will
not
be
*
/
\
/
*
rewinding
.
*
/
\
_Macro
(
Ping
)
\
\
/
*
Sent
to
child
processes
which
should
exit
normally
.
*
/
\
_Macro
(
Terminate
)
\
\
/
*
Force
a
hanged
replaying
process
to
crash
and
produce
a
dump
.
*
/
\
_Macro
(
Crash
)
\
\
/
*
Poke
a
child
that
is
recording
to
create
an
artificial
checkpoint
rather
than
*
/
\
/
*
(
potentially
)
idling
indefinitely
.
This
has
no
effect
on
a
replaying
process
.
*
/
\
_Macro
(
CreateCheckpoint
)
\
\
/
*
Unpause
the
child
and
perform
a
debugger
-
defined
operation
.
*
/
\
_Macro
(
ManifestStart
)
\
\
/
*
Respond
to
a
ExternalCallRequest
message
.
This
is
also
sent
between
separate
*
/
\
/
*
replaying
processes
to
fill
the
external
call
cache
in
root
replaying
processes
.
*
/
\
_Macro
(
ExternalCallResponse
)
\
\
/
*
Messages
sent
from
the
child
process
to
the
middleman
.
*
/
\
\
/
*
Pause
after
executing
a
manifest
specifying
its
response
.
*
/
\
_Macro
(
ManifestFinished
)
\
\
/
*
Respond
to
a
ping
message
*
/
\
_Macro
(
PingResponse
)
\
\
/
*
An
unhandled
recording
divergence
occurred
and
execution
cannot
continue
.
*
/
\
_Macro
(
UnhandledDivergence
)
\
\
/
*
A
critical
error
occurred
and
execution
cannot
continue
.
The
child
will
*
/
\
/
*
stop
executing
after
sending
this
message
and
will
wait
to
be
terminated
.
*
/
\
/
*
A
minidump
for
the
child
has
been
generated
.
*
/
\
_Macro
(
FatalError
)
\
\
/
*
The
child
'
s
graphics
were
repainted
into
the
graphics
shmem
.
*
/
\
_Macro
(
Paint
)
\
\
/
*
The
child
'
s
graphics
were
repainted
and
have
been
encoded
as
an
image
.
*
/
\
_Macro
(
PaintEncoded
)
\
\
/
*
Get
the
result
of
performing
an
external
call
.
*
/
\
_Macro
(
ExternalCallRequest
)
\
\
/
*
Messages
sent
in
both
directions
.
*
/
\
\
/
*
Send
recording
data
from
a
recording
process
to
the
middleman
or
from
the
*
/
\
/
*
middleman
to
a
replaying
process
.
*
/
\
_Macro
(
RecordingData
)
enum
class
MessageType
{
#
define
DefineEnum
(
Kind
)
Kind
ForEachMessageType
(
DefineEnum
)
#
undef
DefineEnum
}
;
struct
Message
{
MessageType
mType
;
uint32_t
mSize
;
uint32_t
mForkId
;
protected
:
Message
(
MessageType
aType
uint32_t
aSize
uint32_t
aForkId
)
:
mType
(
aType
)
mSize
(
aSize
)
mForkId
(
aForkId
)
{
MOZ_RELEASE_ASSERT
(
mSize
>
=
sizeof
(
*
this
)
)
;
}
public
:
struct
FreePolicy
{
void
operator
(
)
(
Message
*
msg
)
{
}
}
;
typedef
UniquePtr
<
Message
FreePolicy
>
UniquePtr
;
UniquePtr
Clone
(
)
const
{
Message
*
res
=
static_cast
<
Message
*
>
(
malloc
(
mSize
)
)
;
memcpy
(
res
this
mSize
)
;
return
UniquePtr
(
res
)
;
}
const
char
*
TypeString
(
)
const
{
switch
(
mType
)
{
#
define
EnumToString
(
Kind
)
\
case
MessageType
:
:
Kind
:
\
return
#
Kind
;
ForEachMessageType
(
EnumToString
)
#
undef
EnumToString
default
:
return
"
Unknown
"
;
}
}
bool
CanBeSentWhileUnpaused
(
)
const
{
return
mType
=
=
MessageType
:
:
CreateCheckpoint
|
|
mType
=
=
MessageType
:
:
SetDebuggerRunsInMiddleman
|
|
mType
=
=
MessageType
:
:
ExternalCallResponse
|
|
mType
=
=
MessageType
:
:
Ping
|
|
mType
=
=
MessageType
:
:
Terminate
|
|
mType
=
=
MessageType
:
:
Crash
|
|
mType
=
=
MessageType
:
:
Introduction
|
|
mType
=
=
MessageType
:
:
RecordingData
;
}
protected
:
template
<
typename
T
typename
Elem
>
Elem
*
Data
(
)
{
return
(
Elem
*
)
(
sizeof
(
T
)
+
(
char
*
)
this
)
;
}
template
<
typename
T
typename
Elem
>
const
Elem
*
Data
(
)
const
{
return
(
const
Elem
*
)
(
sizeof
(
T
)
+
(
const
char
*
)
this
)
;
}
template
<
typename
T
typename
Elem
>
size_t
DataSize
(
)
const
{
return
(
mSize
-
sizeof
(
T
)
)
/
sizeof
(
Elem
)
;
}
template
<
typename
T
typename
Elem
typename
.
.
.
Args
>
static
T
*
NewWithData
(
size_t
aBufferSize
Args
&
&
.
.
.
aArgs
)
{
size_t
size
=
sizeof
(
T
)
+
aBufferSize
*
sizeof
(
Elem
)
;
void
*
ptr
=
malloc
(
size
)
;
return
new
(
ptr
)
T
(
size
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
}
;
struct
IntroductionMessage
:
public
Message
{
BuildId
mBuildId
;
base
:
:
ProcessId
mParentPid
;
uint32_t
mArgc
;
IntroductionMessage
(
uint32_t
aSize
base
:
:
ProcessId
aParentPid
uint32_t
aArgc
)
:
Message
(
MessageType
:
:
Introduction
aSize
0
)
mParentPid
(
aParentPid
)
mArgc
(
aArgc
)
{
}
char
*
ArgvString
(
)
{
return
Data
<
IntroductionMessage
char
>
(
)
;
}
const
char
*
ArgvString
(
)
const
{
return
Data
<
IntroductionMessage
char
>
(
)
;
}
static
IntroductionMessage
*
New
(
base
:
:
ProcessId
aParentPid
int
aArgc
char
*
aArgv
[
]
)
{
size_t
argsLen
=
0
;
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
argsLen
+
=
strlen
(
aArgv
[
i
]
)
+
1
;
}
IntroductionMessage
*
res
=
NewWithData
<
IntroductionMessage
char
>
(
argsLen
aParentPid
aArgc
)
;
size_t
offset
=
0
;
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
memcpy
(
&
res
-
>
ArgvString
(
)
[
offset
]
aArgv
[
i
]
strlen
(
aArgv
[
i
]
)
+
1
)
;
offset
+
=
strlen
(
aArgv
[
i
]
)
+
1
;
}
MOZ_RELEASE_ASSERT
(
offset
=
=
argsLen
)
;
return
res
;
}
static
IntroductionMessage
*
RecordReplay
(
const
IntroductionMessage
&
aMsg
)
{
size_t
introductionSize
=
RecordReplayValue
(
aMsg
.
mSize
)
;
IntroductionMessage
*
msg
=
(
IntroductionMessage
*
)
malloc
(
introductionSize
)
;
if
(
IsRecording
(
)
)
{
memcpy
(
msg
&
aMsg
introductionSize
)
;
}
RecordReplayBytes
(
msg
introductionSize
)
;
return
msg
;
}
}
;
template
<
MessageType
Type
>
struct
EmptyMessage
:
public
Message
{
explicit
EmptyMessage
(
uint32_t
aForkId
=
0
)
:
Message
(
Type
sizeof
(
*
this
)
aForkId
)
{
}
}
;
typedef
EmptyMessage
<
MessageType
:
:
SetDebuggerRunsInMiddleman
>
SetDebuggerRunsInMiddlemanMessage
;
typedef
EmptyMessage
<
MessageType
:
:
Terminate
>
TerminateMessage
;
typedef
EmptyMessage
<
MessageType
:
:
Crash
>
CrashMessage
;
typedef
EmptyMessage
<
MessageType
:
:
CreateCheckpoint
>
CreateCheckpointMessage
;
template
<
MessageType
Type
>
struct
JSONMessage
:
public
Message
{
explicit
JSONMessage
(
uint32_t
aSize
uint32_t
aForkId
)
:
Message
(
Type
aSize
aForkId
)
{
}
const
char16_t
*
Buffer
(
)
const
{
return
Data
<
JSONMessage
<
Type
>
char16_t
>
(
)
;
}
size_t
BufferSize
(
)
const
{
return
DataSize
<
JSONMessage
<
Type
>
char16_t
>
(
)
;
}
static
JSONMessage
<
Type
>
*
New
(
uint32_t
aForkId
const
char16_t
*
aBuffer
size_t
aBufferSize
)
{
JSONMessage
<
Type
>
*
res
=
NewWithData
<
JSONMessage
<
Type
>
char16_t
>
(
aBufferSize
aForkId
)
;
MOZ_RELEASE_ASSERT
(
res
-
>
BufferSize
(
)
=
=
aBufferSize
)
;
PodCopy
(
res
-
>
Data
<
JSONMessage
<
Type
>
char16_t
>
(
)
aBuffer
aBufferSize
)
;
return
res
;
}
}
;
typedef
JSONMessage
<
MessageType
:
:
ManifestStart
>
ManifestStartMessage
;
typedef
JSONMessage
<
MessageType
:
:
ManifestFinished
>
ManifestFinishedMessage
;
template
<
MessageType
Type
>
struct
ErrorMessage
:
public
Message
{
explicit
ErrorMessage
(
uint32_t
aSize
uint32_t
aForkId
)
:
Message
(
Type
aSize
aForkId
)
{
}
const
char
*
Error
(
)
const
{
return
Data
<
ErrorMessage
<
Type
>
const
char
>
(
)
;
}
}
;
typedef
ErrorMessage
<
MessageType
:
:
FatalError
>
FatalErrorMessage
;
typedef
ErrorMessage
<
MessageType
:
:
CloudError
>
CloudErrorMessage
;
typedef
EmptyMessage
<
MessageType
:
:
UnhandledDivergence
>
UnhandledDivergenceMessage
;
static
const
gfx
:
:
SurfaceFormat
gSurfaceFormat
=
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
;
struct
PaintMessage
:
public
Message
{
uint32_t
mWidth
;
uint32_t
mHeight
;
PaintMessage
(
uint32_t
aWidth
uint32_t
aHeight
)
:
Message
(
MessageType
:
:
Paint
sizeof
(
*
this
)
0
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
{
}
}
;
template
<
MessageType
Type
>
struct
BinaryMessage
:
public
Message
{
uint64_t
mTag
;
explicit
BinaryMessage
(
uint32_t
aSize
uint32_t
aForkId
uint64_t
aTag
)
:
Message
(
Type
aSize
aForkId
)
mTag
(
aTag
)
{
}
const
char
*
BinaryData
(
)
const
{
return
Data
<
BinaryMessage
<
Type
>
char
>
(
)
;
}
size_t
BinaryDataSize
(
)
const
{
return
DataSize
<
BinaryMessage
<
Type
>
char
>
(
)
;
}
static
BinaryMessage
<
Type
>
*
New
(
uint32_t
aForkId
uint64_t
aTag
const
char
*
aData
size_t
aDataSize
)
{
BinaryMessage
<
Type
>
*
res
=
NewWithData
<
BinaryMessage
<
Type
>
char
>
(
aDataSize
aForkId
aTag
)
;
MOZ_RELEASE_ASSERT
(
res
-
>
BinaryDataSize
(
)
=
=
aDataSize
)
;
PodCopy
(
res
-
>
Data
<
BinaryMessage
<
Type
>
char
>
(
)
aData
aDataSize
)
;
return
res
;
}
}
;
typedef
BinaryMessage
<
MessageType
:
:
PaintEncoded
>
PaintEncodedMessage
;
typedef
BinaryMessage
<
MessageType
:
:
ExternalCallRequest
>
ExternalCallRequestMessage
;
typedef
BinaryMessage
<
MessageType
:
:
ExternalCallResponse
>
ExternalCallResponseMessage
;
typedef
BinaryMessage
<
MessageType
:
:
RecordingData
>
RecordingDataMessage
;
struct
PingMessage
:
public
Message
{
uint32_t
mId
;
explicit
PingMessage
(
uint32_t
aForkId
uint32_t
aId
)
:
Message
(
MessageType
:
:
Ping
sizeof
(
*
this
)
aForkId
)
mId
(
aId
)
{
}
}
;
struct
PingResponseMessage
:
public
Message
{
uint32_t
mId
;
uint64_t
mProgress
;
PingResponseMessage
(
uint32_t
aForkId
uint32_t
aId
uint64_t
aProgress
)
:
Message
(
MessageType
:
:
PingResponse
sizeof
(
*
this
)
aForkId
)
mId
(
aId
)
mProgress
(
aProgress
)
{
}
}
;
class
Channel
{
public
:
typedef
std
:
:
function
<
void
(
Message
:
:
UniquePtr
)
>
MessageHandler
;
enum
class
Kind
{
MiddlemanRecord
MiddlemanReplay
RecordReplay
ParentCloud
ReplayRoot
ReplayForked
}
;
private
:
size_t
mId
;
Kind
mKind
;
MessageHandler
mHandler
;
bool
mInitialized
;
int
mConnectionFd
;
int
mFd
;
Monitor
mMonitor
;
typedef
InfallibleVector
<
char
>
MessageBuffer
;
MessageBuffer
mMessageBuffer
;
size_t
mMessageBytes
;
InfallibleVector
<
char
>
mPendingData
;
void
PrintMessage
(
const
char
*
aPrefix
const
Message
&
aMsg
)
;
Message
:
:
UniquePtr
WaitForMessage
(
)
;
static
void
ThreadMain
(
void
*
aChannel
)
;
void
SendRaw
(
const
char
*
aData
size_t
aSize
)
;
bool
IsParent
(
)
{
switch
(
mKind
)
{
case
Kind
:
:
MiddlemanRecord
:
case
Kind
:
:
MiddlemanReplay
:
case
Kind
:
:
ReplayForked
:
return
true
;
case
Kind
:
:
RecordReplay
:
case
Kind
:
:
ParentCloud
:
case
Kind
:
:
ReplayRoot
:
return
false
;
}
MOZ_CRASH
(
"
Bad
kind
"
)
;
}
bool
ExitProcessOnDisconnect
(
)
{
switch
(
mKind
)
{
case
Kind
:
:
RecordReplay
:
case
Kind
:
:
ReplayForked
:
return
true
;
case
Kind
:
:
MiddlemanRecord
:
case
Kind
:
:
MiddlemanReplay
:
case
Kind
:
:
ParentCloud
:
case
Kind
:
:
ReplayRoot
:
return
false
;
}
MOZ_CRASH
(
"
Bad
kind
"
)
;
}
public
:
Channel
(
size_t
aId
Kind
aKind
const
MessageHandler
&
aHandler
base
:
:
ProcessId
aParentPid
=
0
)
;
size_t
GetId
(
)
{
return
mId
;
}
void
SendMessage
(
Message
&
&
aMsg
)
;
void
SendMessageData
(
const
char
*
aData
size_t
aSize
)
;
void
ExitIfNotInitializedBefore
(
const
TimeStamp
&
aDeadline
)
;
}
;
static
const
char
*
gMiddlemanPidOption
=
"
-
middlemanPid
"
;
static
const
char
*
gChannelIDOption
=
"
-
recordReplayChannelID
"
;
}
}
#
endif
