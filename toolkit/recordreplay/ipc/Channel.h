#
ifndef
mozilla_recordreplay_Channel_h
#
define
mozilla_recordreplay_Channel_h
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
File
.
h
"
#
include
"
JSControl
.
h
"
#
include
"
Monitor
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
#
define
ForEachMessageType
(
_Macro
)
\
_Macro
(
Introduction
)
\
\
/
*
Sent
to
recording
processes
to
indicate
that
the
middleman
will
be
running
*
/
\
/
*
developer
tools
server
-
side
code
instead
of
the
recording
process
itself
.
*
/
\
_Macro
(
SetDebuggerRunsInMiddleman
)
\
\
/
*
Sent
to
recording
processes
when
exiting
or
to
force
a
hanged
replaying
*
/
\
/
*
process
to
crash
.
*
/
\
_Macro
(
Terminate
)
\
\
/
*
Flush
the
current
recording
to
disk
.
*
/
\
_Macro
(
FlushRecording
)
\
\
/
*
Poke
a
child
that
is
recording
to
create
an
artificial
checkpoint
rather
than
*
/
\
/
*
(
potentially
)
idling
indefinitely
.
This
has
no
effect
on
a
replaying
process
.
*
/
\
_Macro
(
CreateCheckpoint
)
\
\
/
*
Debugger
JSON
messages
are
initially
sent
from
the
parent
.
The
child
unpauses
*
/
\
/
*
after
receiving
the
message
and
will
pause
after
it
sends
a
DebuggerResponse
.
*
/
\
_Macro
(
DebuggerRequest
)
\
\
/
*
Set
or
clear
a
JavaScript
breakpoint
.
*
/
\
_Macro
(
SetBreakpoint
)
\
\
/
*
Unpause
the
child
and
play
execution
either
to
the
next
point
when
a
*
/
\
/
*
breakpoint
is
hit
or
to
the
next
checkpoint
.
Resumption
may
be
either
*
/
\
/
*
forward
or
backward
.
*
/
\
_Macro
(
Resume
)
\
\
/
*
Rewind
to
a
particular
saved
checkpoint
in
the
past
.
*
/
\
_Macro
(
RestoreCheckpoint
)
\
\
/
*
Run
forward
to
a
particular
execution
point
between
the
current
checkpoint
*
/
\
/
*
and
the
next
one
.
*
/
\
_Macro
(
RunToPoint
)
\
\
/
*
Notify
the
child
whether
it
is
the
active
child
and
should
send
paint
and
similar
*
/
\
/
*
messages
to
the
middleman
.
*
/
\
_Macro
(
SetIsActive
)
\
\
/
*
Set
whether
to
perform
intentional
crashes
for
testing
.
*
/
\
_Macro
(
SetAllowIntentionalCrashes
)
\
\
/
*
Set
whether
to
save
a
particular
checkpoint
.
*
/
\
_Macro
(
SetSaveCheckpoint
)
\
\
/
*
Messages
sent
from
the
child
process
to
the
middleman
.
*
/
\
\
/
*
Sent
in
response
to
a
FlushRecording
telling
the
middleman
that
the
flush
*
/
\
/
*
has
finished
.
*
/
\
_Macro
(
RecordingFlushed
)
\
\
/
*
A
critical
error
occurred
and
execution
cannot
continue
.
The
child
will
*
/
\
/
*
stop
executing
after
sending
this
message
and
will
wait
to
be
terminated
.
*
/
\
_Macro
(
FatalError
)
\
\
/
*
The
child
'
s
graphics
were
repainted
.
*
/
\
_Macro
(
Paint
)
\
\
/
*
Notify
the
middleman
that
a
checkpoint
or
breakpoint
was
hit
.
*
/
\
/
*
The
child
will
pause
after
sending
these
messages
.
*
/
\
_Macro
(
HitCheckpoint
)
\
_Macro
(
HitBreakpoint
)
\
\
/
*
Send
a
response
to
a
DebuggerRequest
message
.
*
/
\
_Macro
(
DebuggerResponse
)
\
\
/
*
Notify
that
the
'
AlwaysMarkMajorCheckpoints
'
directive
was
invoked
.
*
/
\
_Macro
(
AlwaysMarkMajorCheckpoints
)
enum
class
MessageType
{
#
define
DefineEnum
(
Kind
)
Kind
ForEachMessageType
(
DefineEnum
)
#
undef
DefineEnum
}
;
struct
Message
{
MessageType
mType
;
uint32_t
mSize
;
protected
:
Message
(
MessageType
aType
uint32_t
aSize
)
:
mType
(
aType
)
mSize
(
aSize
)
{
MOZ_RELEASE_ASSERT
(
mSize
>
=
sizeof
(
*
this
)
)
;
}
public
:
Message
*
Clone
(
)
const
{
char
*
res
=
(
char
*
)
malloc
(
mSize
)
;
memcpy
(
res
this
mSize
)
;
return
(
Message
*
)
res
;
}
const
char
*
TypeString
(
)
const
{
switch
(
mType
)
{
#
define
EnumToString
(
Kind
)
case
MessageType
:
:
Kind
:
return
#
Kind
;
ForEachMessageType
(
EnumToString
)
#
undef
EnumToString
default
:
return
"
Unknown
"
;
}
}
bool
CanBeSentWhileUnpaused
(
)
const
{
return
mType
=
=
MessageType
:
:
CreateCheckpoint
|
|
mType
=
=
MessageType
:
:
SetDebuggerRunsInMiddleman
|
|
mType
=
=
MessageType
:
:
Terminate
;
}
protected
:
template
<
typename
T
typename
Elem
>
Elem
*
Data
(
)
{
return
(
Elem
*
)
(
sizeof
(
T
)
+
(
char
*
)
this
)
;
}
template
<
typename
T
typename
Elem
>
const
Elem
*
Data
(
)
const
{
return
(
const
Elem
*
)
(
sizeof
(
T
)
+
(
const
char
*
)
this
)
;
}
template
<
typename
T
typename
Elem
>
size_t
DataSize
(
)
const
{
return
(
mSize
-
sizeof
(
T
)
)
/
sizeof
(
Elem
)
;
}
template
<
typename
T
typename
Elem
typename
.
.
.
Args
>
static
T
*
NewWithData
(
size_t
aBufferSize
Args
&
&
.
.
.
aArgs
)
{
size_t
size
=
sizeof
(
T
)
+
aBufferSize
*
sizeof
(
Elem
)
;
void
*
ptr
=
malloc
(
size
)
;
return
new
(
ptr
)
T
(
size
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
}
;
struct
IntroductionMessage
:
public
Message
{
base
:
:
ProcessId
mParentPid
;
uint32_t
mArgc
;
IntroductionMessage
(
uint32_t
aSize
base
:
:
ProcessId
aParentPid
uint32_t
aArgc
)
:
Message
(
MessageType
:
:
Introduction
aSize
)
mParentPid
(
aParentPid
)
mArgc
(
aArgc
)
{
}
char
*
ArgvString
(
)
{
return
Data
<
IntroductionMessage
char
>
(
)
;
}
const
char
*
ArgvString
(
)
const
{
return
Data
<
IntroductionMessage
char
>
(
)
;
}
static
IntroductionMessage
*
New
(
base
:
:
ProcessId
aParentPid
int
aArgc
char
*
aArgv
[
]
)
{
size_t
argsLen
=
0
;
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
argsLen
+
=
strlen
(
aArgv
[
i
]
)
+
1
;
}
IntroductionMessage
*
res
=
NewWithData
<
IntroductionMessage
char
>
(
argsLen
aParentPid
aArgc
)
;
size_t
offset
=
0
;
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
memcpy
(
&
res
-
>
ArgvString
(
)
[
offset
]
aArgv
[
i
]
strlen
(
aArgv
[
i
]
)
+
1
)
;
offset
+
=
strlen
(
aArgv
[
i
]
)
+
1
;
}
MOZ_RELEASE_ASSERT
(
offset
=
=
argsLen
)
;
return
res
;
}
static
IntroductionMessage
*
RecordReplay
(
const
IntroductionMessage
&
aMsg
)
{
size_t
introductionSize
=
RecordReplayValue
(
aMsg
.
mSize
)
;
IntroductionMessage
*
msg
=
(
IntroductionMessage
*
)
malloc
(
introductionSize
)
;
if
(
IsRecording
(
)
)
{
memcpy
(
msg
&
aMsg
introductionSize
)
;
}
RecordReplayBytes
(
msg
introductionSize
)
;
return
msg
;
}
}
;
template
<
MessageType
Type
>
struct
EmptyMessage
:
public
Message
{
EmptyMessage
(
)
:
Message
(
Type
sizeof
(
*
this
)
)
{
}
}
;
typedef
EmptyMessage
<
MessageType
:
:
SetDebuggerRunsInMiddleman
>
SetDebuggerRunsInMiddlemanMessage
;
typedef
EmptyMessage
<
MessageType
:
:
Terminate
>
TerminateMessage
;
typedef
EmptyMessage
<
MessageType
:
:
CreateCheckpoint
>
CreateCheckpointMessage
;
typedef
EmptyMessage
<
MessageType
:
:
FlushRecording
>
FlushRecordingMessage
;
template
<
MessageType
Type
>
struct
JSONMessage
:
public
Message
{
explicit
JSONMessage
(
uint32_t
aSize
)
:
Message
(
Type
aSize
)
{
}
const
char16_t
*
Buffer
(
)
const
{
return
Data
<
JSONMessage
<
Type
>
char16_t
>
(
)
;
}
size_t
BufferSize
(
)
const
{
return
DataSize
<
JSONMessage
<
Type
>
char16_t
>
(
)
;
}
static
JSONMessage
<
Type
>
*
New
(
const
char16_t
*
aBuffer
size_t
aBufferSize
)
{
JSONMessage
<
Type
>
*
res
=
NewWithData
<
JSONMessage
<
Type
>
char16_t
>
(
aBufferSize
)
;
MOZ_RELEASE_ASSERT
(
res
-
>
BufferSize
(
)
=
=
aBufferSize
)
;
PodCopy
(
res
-
>
Data
<
JSONMessage
<
Type
>
char16_t
>
(
)
aBuffer
aBufferSize
)
;
return
res
;
}
}
;
typedef
JSONMessage
<
MessageType
:
:
DebuggerRequest
>
DebuggerRequestMessage
;
typedef
JSONMessage
<
MessageType
:
:
DebuggerResponse
>
DebuggerResponseMessage
;
struct
SetBreakpointMessage
:
public
Message
{
size_t
mId
;
js
:
:
BreakpointPosition
mPosition
;
SetBreakpointMessage
(
size_t
aId
const
js
:
:
BreakpointPosition
&
aPosition
)
:
Message
(
MessageType
:
:
SetBreakpoint
sizeof
(
*
this
)
)
mId
(
aId
)
mPosition
(
aPosition
)
{
}
}
;
struct
ResumeMessage
:
public
Message
{
bool
mForward
;
explicit
ResumeMessage
(
bool
aForward
)
:
Message
(
MessageType
:
:
Resume
sizeof
(
*
this
)
)
mForward
(
aForward
)
{
}
}
;
struct
RestoreCheckpointMessage
:
public
Message
{
size_t
mCheckpoint
;
explicit
RestoreCheckpointMessage
(
size_t
aCheckpoint
)
:
Message
(
MessageType
:
:
RestoreCheckpoint
sizeof
(
*
this
)
)
mCheckpoint
(
aCheckpoint
)
{
}
}
;
struct
RunToPointMessage
:
public
Message
{
js
:
:
ExecutionPoint
mTarget
;
explicit
RunToPointMessage
(
const
js
:
:
ExecutionPoint
&
aTarget
)
:
Message
(
MessageType
:
:
RunToPoint
sizeof
(
*
this
)
)
mTarget
(
aTarget
)
{
}
}
;
struct
SetIsActiveMessage
:
public
Message
{
bool
mActive
;
explicit
SetIsActiveMessage
(
bool
aActive
)
:
Message
(
MessageType
:
:
SetIsActive
sizeof
(
*
this
)
)
mActive
(
aActive
)
{
}
}
;
struct
SetAllowIntentionalCrashesMessage
:
public
Message
{
bool
mAllowed
;
explicit
SetAllowIntentionalCrashesMessage
(
bool
aAllowed
)
:
Message
(
MessageType
:
:
SetAllowIntentionalCrashes
sizeof
(
*
this
)
)
mAllowed
(
aAllowed
)
{
}
}
;
struct
SetSaveCheckpointMessage
:
public
Message
{
size_t
mCheckpoint
;
bool
mSave
;
SetSaveCheckpointMessage
(
size_t
aCheckpoint
bool
aSave
)
:
Message
(
MessageType
:
:
SetSaveCheckpoint
sizeof
(
*
this
)
)
mCheckpoint
(
aCheckpoint
)
mSave
(
aSave
)
{
}
}
;
typedef
EmptyMessage
<
MessageType
:
:
RecordingFlushed
>
RecordingFlushedMessage
;
struct
FatalErrorMessage
:
public
Message
{
explicit
FatalErrorMessage
(
uint32_t
aSize
)
:
Message
(
MessageType
:
:
FatalError
aSize
)
{
}
const
char
*
Error
(
)
const
{
return
Data
<
FatalErrorMessage
const
char
>
(
)
;
}
}
;
static
const
gfx
:
:
SurfaceFormat
gSurfaceFormat
=
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
;
struct
PaintMessage
:
public
Message
{
uint32_t
mWidth
;
uint32_t
mHeight
;
PaintMessage
(
uint32_t
aWidth
uint32_t
aHeight
)
:
Message
(
MessageType
:
:
Paint
sizeof
(
*
this
)
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
{
}
}
;
struct
HitCheckpointMessage
:
public
Message
{
uint32_t
mCheckpointId
;
bool
mRecordingEndpoint
;
double
mDurationMicroseconds
;
HitCheckpointMessage
(
uint32_t
aCheckpointId
bool
aRecordingEndpoint
double
aDurationMicroseconds
)
:
Message
(
MessageType
:
:
HitCheckpoint
sizeof
(
*
this
)
)
mCheckpointId
(
aCheckpointId
)
mRecordingEndpoint
(
aRecordingEndpoint
)
mDurationMicroseconds
(
aDurationMicroseconds
)
{
}
}
;
struct
HitBreakpointMessage
:
public
Message
{
bool
mRecordingEndpoint
;
HitBreakpointMessage
(
uint32_t
aSize
bool
aRecordingEndpoint
)
:
Message
(
MessageType
:
:
HitBreakpoint
aSize
)
mRecordingEndpoint
(
aRecordingEndpoint
)
{
}
const
uint32_t
*
Breakpoints
(
)
const
{
return
Data
<
HitBreakpointMessage
uint32_t
>
(
)
;
}
uint32_t
NumBreakpoints
(
)
const
{
return
DataSize
<
HitBreakpointMessage
uint32_t
>
(
)
;
}
static
HitBreakpointMessage
*
New
(
bool
aRecordingEndpoint
const
uint32_t
*
aBreakpoints
size_t
aNumBreakpoints
)
{
HitBreakpointMessage
*
res
=
NewWithData
<
HitBreakpointMessage
uint32_t
>
(
aNumBreakpoints
aRecordingEndpoint
)
;
MOZ_RELEASE_ASSERT
(
res
-
>
NumBreakpoints
(
)
=
=
aNumBreakpoints
)
;
PodCopy
(
res
-
>
Data
<
HitBreakpointMessage
uint32_t
>
(
)
aBreakpoints
aNumBreakpoints
)
;
return
res
;
}
}
;
typedef
EmptyMessage
<
MessageType
:
:
AlwaysMarkMajorCheckpoints
>
AlwaysMarkMajorCheckpointsMessage
;
class
Channel
{
public
:
typedef
std
:
:
function
<
void
(
Message
*
)
>
MessageHandler
;
private
:
size_t
mId
;
MessageHandler
mHandler
;
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mInitialized
;
int
mConnectionFd
;
int
mFd
;
Monitor
mMonitor
;
InfallibleVector
<
char
0
AllocPolicy
<
MemoryKind
:
:
Generic
>
>
mMessageBuffer
;
size_t
mMessageBytes
;
void
PrintMessage
(
const
char
*
aPrefix
const
Message
&
aMsg
)
;
Message
*
WaitForMessage
(
)
;
static
void
ThreadMain
(
void
*
aChannel
)
;
public
:
Channel
(
size_t
aId
bool
aMiddlemanRecording
const
MessageHandler
&
aHandler
)
;
size_t
GetId
(
)
{
return
mId
;
}
void
SendMessage
(
const
Message
&
aMsg
)
;
}
;
static
const
char
*
gMiddlemanPidOption
=
"
-
middlemanPid
"
;
static
const
char
*
gChannelIDOption
=
"
-
recordReplayChannelID
"
;
}
}
#
endif
