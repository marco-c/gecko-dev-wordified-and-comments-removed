#
include
"
ChildInternal
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
namespace
navigation
{
typedef
js
:
:
BreakpointPosition
BreakpointPosition
;
typedef
js
:
:
ExecutionPoint
ExecutionPoint
;
static
void
BreakpointPositionToString
(
const
BreakpointPosition
&
aPos
nsAutoCString
&
aStr
)
{
aStr
.
AppendPrintf
(
"
{
Kind
:
%
s
Script
:
%
d
Offset
:
%
d
Frame
:
%
d
}
"
aPos
.
KindString
(
)
(
int
)
aPos
.
mScript
(
int
)
aPos
.
mOffset
(
int
)
aPos
.
mFrameIndex
)
;
}
static
void
ExecutionPointToString
(
const
ExecutionPoint
&
aPoint
nsAutoCString
&
aStr
)
{
aStr
.
AppendPrintf
(
"
{
Checkpoint
%
d
"
(
int
)
aPoint
.
mCheckpoint
)
;
if
(
aPoint
.
HasPosition
(
)
)
{
aStr
.
AppendPrintf
(
"
Progress
%
llu
Position
"
aPoint
.
mProgress
)
;
BreakpointPositionToString
(
aPoint
.
mPosition
aStr
)
;
}
aStr
.
AppendPrintf
(
"
}
"
)
;
}
typedef
AllocPolicy
<
MemoryKind
:
:
Navigation
>
UntrackedAllocPolicy
;
class
NavigationPhase
{
friend
class
NavigationState
;
private
:
MOZ_NORETURN
void
Unsupported
(
const
char
*
aOperation
)
{
nsAutoCString
str
;
ToString
(
str
)
;
Print
(
"
Operation
%
s
not
supported
:
%
s
\
n
"
aOperation
str
.
get
(
)
)
;
MOZ_CRASH
(
"
Unsupported
navigation
operation
"
)
;
}
public
:
virtual
void
ToString
(
nsAutoCString
&
aStr
)
=
0
;
virtual
void
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
{
Unsupported
(
"
AfterCheckpoint
"
)
;
}
virtual
void
PositionHit
(
const
ExecutionPoint
&
aPoint
)
{
Unsupported
(
"
PositionHit
"
)
;
}
virtual
void
Resume
(
bool
aForward
)
{
Unsupported
(
"
Resume
"
)
;
}
virtual
void
RestoreCheckpoint
(
size_t
aCheckpoint
)
{
Unsupported
(
"
RestoreCheckpoint
"
)
;
}
virtual
void
RunToPoint
(
const
ExecutionPoint
&
aTarget
)
{
Unsupported
(
"
RunToPoint
"
)
;
}
virtual
void
HandleDebuggerRequest
(
js
:
:
CharBuffer
*
aRequestBuffer
)
{
Unsupported
(
"
HandleDebuggerRequest
"
)
;
}
virtual
bool
MaybeDivergeFromRecording
(
)
{
Unsupported
(
"
MaybeDivergeFromRecording
"
)
;
}
virtual
ExecutionPoint
GetRecordingEndpoint
(
)
{
Unsupported
(
"
GetRecordingEndpoint
"
)
;
}
virtual
void
HitRecordingEndpoint
(
const
ExecutionPoint
&
aPoint
)
{
Unsupported
(
"
HitRecordingEndpoint
"
)
;
}
}
;
struct
RequestInfo
{
InfallibleVector
<
char16_t
0
UntrackedAllocPolicy
>
mRequestBuffer
;
InfallibleVector
<
char16_t
0
UntrackedAllocPolicy
>
mResponseBuffer
;
bool
mUnhandledDivergence
;
RequestInfo
(
)
:
mUnhandledDivergence
(
false
)
{
}
RequestInfo
(
const
RequestInfo
&
o
)
:
mUnhandledDivergence
(
o
.
mUnhandledDivergence
)
{
mRequestBuffer
.
append
(
o
.
mRequestBuffer
.
begin
(
)
o
.
mRequestBuffer
.
length
(
)
)
;
mResponseBuffer
.
append
(
o
.
mResponseBuffer
.
begin
(
)
o
.
mResponseBuffer
.
length
(
)
)
;
}
}
;
typedef
InfallibleVector
<
RequestInfo
4
UntrackedAllocPolicy
>
UntrackedRequestVector
;
typedef
InfallibleVector
<
uint32_t
>
BreakpointVector
;
class
BreakpointPausedPhase
final
:
public
NavigationPhase
{
ExecutionPoint
mPoint
;
UntrackedRequestVector
mRequests
;
bool
mRecoveringFromDivergence
;
size_t
mRequestIndex
;
bool
mResumeForward
;
public
:
void
Enter
(
const
ExecutionPoint
&
aPoint
bool
aRecordingEndpoint
const
BreakpointVector
&
aBreakpoints
)
;
void
ToString
(
nsAutoCString
&
aStr
)
override
{
aStr
.
AppendPrintf
(
"
BreakpointPaused
RecoveringFromDivergence
%
d
"
mRecoveringFromDivergence
)
;
}
void
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
override
;
void
PositionHit
(
const
ExecutionPoint
&
aPoint
)
override
;
void
Resume
(
bool
aForward
)
override
;
void
RestoreCheckpoint
(
size_t
aCheckpoint
)
override
;
void
HandleDebuggerRequest
(
js
:
:
CharBuffer
*
aRequestBuffer
)
override
;
bool
MaybeDivergeFromRecording
(
)
override
;
ExecutionPoint
GetRecordingEndpoint
(
)
override
;
void
RespondAfterRecoveringFromDivergence
(
)
;
}
;
class
CheckpointPausedPhase
final
:
public
NavigationPhase
{
size_t
mCheckpoint
;
bool
mAtRecordingEndpoint
;
public
:
void
Enter
(
size_t
aCheckpoint
bool
aRewind
bool
aRecordingEndpoint
)
;
void
ToString
(
nsAutoCString
&
aStr
)
override
{
aStr
.
AppendPrintf
(
"
CheckpointPaused
"
)
;
}
void
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
override
;
void
PositionHit
(
const
ExecutionPoint
&
aPoint
)
override
;
void
Resume
(
bool
aForward
)
override
;
void
RestoreCheckpoint
(
size_t
aCheckpoint
)
override
;
void
RunToPoint
(
const
ExecutionPoint
&
aTarget
)
override
;
void
HandleDebuggerRequest
(
js
:
:
CharBuffer
*
aRequestBuffer
)
override
;
ExecutionPoint
GetRecordingEndpoint
(
)
override
;
}
;
class
ForwardPhase
final
:
public
NavigationPhase
{
ExecutionPoint
mPoint
;
public
:
void
Enter
(
const
ExecutionPoint
&
aPoint
)
;
void
ToString
(
nsAutoCString
&
aStr
)
override
{
aStr
.
AppendPrintf
(
"
Forward
"
)
;
}
void
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
override
;
void
PositionHit
(
const
ExecutionPoint
&
aPoint
)
override
;
void
HitRecordingEndpoint
(
const
ExecutionPoint
&
aPoint
)
override
;
}
;
class
ReachBreakpointPhase
final
:
public
NavigationPhase
{
private
:
CheckpointId
mStart
;
ExecutionPoint
mPoint
;
Maybe
<
ExecutionPoint
>
mTemporaryCheckpoint
;
bool
mSavedTemporaryCheckpoint
;
double
mStartTime
;
public
:
void
Enter
(
const
CheckpointId
&
aStart
bool
aRewind
const
ExecutionPoint
&
aPoint
const
Maybe
<
ExecutionPoint
>
&
aTemporaryCheckpoint
)
;
void
ToString
(
nsAutoCString
&
aStr
)
override
{
aStr
.
AppendPrintf
(
"
ReachBreakpoint
:
"
)
;
ExecutionPointToString
(
mPoint
aStr
)
;
if
(
mTemporaryCheckpoint
.
isSome
(
)
)
{
aStr
.
AppendPrintf
(
"
TemporaryCheckpoint
:
"
)
;
ExecutionPointToString
(
mTemporaryCheckpoint
.
ref
(
)
aStr
)
;
}
}
void
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
override
;
void
PositionHit
(
const
ExecutionPoint
&
aPoint
)
override
;
}
;
class
FindLastHitPhase
final
:
public
NavigationPhase
{
CheckpointId
mStart
;
Maybe
<
ExecutionPoint
>
mEnd
;
size_t
mCounter
;
struct
TrackedPosition
{
BreakpointPosition
mPosition
;
ExecutionPoint
mLastHit
;
size_t
mLastHitCount
;
explicit
TrackedPosition
(
const
BreakpointPosition
&
aPosition
)
:
mPosition
(
aPosition
)
mLastHitCount
(
0
)
{
}
}
;
InfallibleVector
<
TrackedPosition
4
UntrackedAllocPolicy
>
mTrackedPositions
;
const
TrackedPosition
&
FindTrackedPosition
(
const
BreakpointPosition
&
aPos
)
;
void
OnRegionEnd
(
)
;
public
:
void
Enter
(
const
CheckpointId
&
aStart
const
Maybe
<
ExecutionPoint
>
&
aEnd
)
;
void
ToString
(
nsAutoCString
&
aStr
)
override
{
aStr
.
AppendPrintf
(
"
FindLastHit
"
)
;
}
void
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
override
;
void
PositionHit
(
const
ExecutionPoint
&
aPoint
)
override
;
void
HitRecordingEndpoint
(
const
ExecutionPoint
&
aPoint
)
override
;
}
;
class
NavigationState
{
ExecutionPoint
mRecordingEndpoint
;
size_t
mRecordingEndpointIndex
;
CheckpointId
mLastCheckpoint
;
InfallibleVector
<
ExecutionPoint
0
UntrackedAllocPolicy
>
mTemporaryCheckpoints
;
public
:
InfallibleVector
<
BreakpointPosition
4
UntrackedAllocPolicy
>
mBreakpoints
;
BreakpointPosition
&
GetBreakpoint
(
size_t
id
)
{
while
(
id
>
=
mBreakpoints
.
length
(
)
)
{
mBreakpoints
.
emplaceBack
(
)
;
}
return
mBreakpoints
[
id
]
;
}
CheckpointId
LastCheckpoint
(
)
{
return
mLastCheckpoint
;
}
NavigationPhase
*
mPhase
;
void
SetPhase
(
NavigationPhase
*
phase
)
{
mPhase
=
phase
;
if
(
SpewEnabled
(
)
)
{
nsAutoCString
str
;
mPhase
-
>
ToString
(
str
)
;
PrintSpew
(
"
SetNavigationPhase
%
s
\
n
"
str
.
get
(
)
)
;
}
}
BreakpointPausedPhase
mBreakpointPausedPhase
;
CheckpointPausedPhase
mCheckpointPausedPhase
;
ForwardPhase
mForwardPhase
;
ReachBreakpointPhase
mReachBreakpointPhase
;
FindLastHitPhase
mFindLastHitPhase
;
bool
mAlwaysSaveTemporaryCheckpoints
;
InfallibleVector
<
std
:
:
pair
<
ProgressCounter
size_t
>
0
UntrackedAllocPolicy
>
mTimeWarpTargetCheckpoints
;
NavigationState
(
)
:
mPhase
(
&
mForwardPhase
)
{
if
(
IsReplaying
(
)
)
{
mRecordingEndpoint
=
ExecutionPoint
(
CheckpointId
:
:
First
)
;
}
}
void
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
{
mLastCheckpoint
=
aCheckpoint
;
while
(
mTemporaryCheckpoints
.
length
(
)
>
aCheckpoint
.
mTemporary
)
{
mTemporaryCheckpoints
.
popBack
(
)
;
}
mPhase
-
>
AfterCheckpoint
(
aCheckpoint
)
;
if
(
!
aCheckpoint
.
mTemporary
)
{
ExecutionPoint
point
(
aCheckpoint
.
mNormal
)
;
CheckForRecordingEndpoint
(
point
)
;
}
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
|
|
aCheckpoint
.
mNormal
<
=
mRecordingEndpoint
.
mCheckpoint
)
;
if
(
aCheckpoint
.
mNormal
=
=
mRecordingEndpoint
.
mCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
mRecordingEndpoint
.
HasPosition
(
)
)
;
js
:
:
EnsurePositionHandler
(
mRecordingEndpoint
.
mPosition
)
;
}
}
void
PositionHit
(
const
ExecutionPoint
&
aPoint
)
{
mPhase
-
>
PositionHit
(
aPoint
)
;
CheckForRecordingEndpoint
(
aPoint
)
;
}
void
Resume
(
bool
aForward
)
{
mPhase
-
>
Resume
(
aForward
)
;
}
void
RestoreCheckpoint
(
size_t
aCheckpoint
)
{
mPhase
-
>
RestoreCheckpoint
(
aCheckpoint
)
;
}
void
RunToPoint
(
const
ExecutionPoint
&
aTarget
)
{
mPhase
-
>
RunToPoint
(
aTarget
)
;
}
void
HandleDebuggerRequest
(
js
:
:
CharBuffer
*
aRequestBuffer
)
{
mPhase
-
>
HandleDebuggerRequest
(
aRequestBuffer
)
;
}
bool
MaybeDivergeFromRecording
(
)
{
return
mPhase
-
>
MaybeDivergeFromRecording
(
)
;
}
ExecutionPoint
GetRecordingEndpoint
(
)
{
return
mPhase
-
>
GetRecordingEndpoint
(
)
;
}
void
SetRecordingEndpoint
(
size_t
aIndex
const
ExecutionPoint
&
aEndpoint
)
{
if
(
aIndex
<
=
mRecordingEndpointIndex
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
mRecordingEndpoint
.
mCheckpoint
<
=
aEndpoint
.
mCheckpoint
)
;
mRecordingEndpointIndex
=
aIndex
;
mRecordingEndpoint
=
aEndpoint
;
if
(
aEndpoint
.
HasPosition
(
)
)
{
js
:
:
EnsurePositionHandler
(
aEndpoint
.
mPosition
)
;
}
}
void
CheckForRecordingEndpoint
(
const
ExecutionPoint
&
aPoint
)
{
while
(
aPoint
=
=
mRecordingEndpoint
)
{
if
(
!
recordreplay
:
:
HitRecordingEndpoint
(
)
)
{
mPhase
-
>
HitRecordingEndpoint
(
mRecordingEndpoint
)
;
}
}
}
size_t
NumTemporaryCheckpoints
(
)
{
return
mTemporaryCheckpoints
.
length
(
)
;
}
bool
SaveTemporaryCheckpoint
(
const
ExecutionPoint
&
aPoint
)
{
MOZ_RELEASE_ASSERT
(
aPoint
.
mCheckpoint
=
=
mLastCheckpoint
.
mNormal
)
;
mTemporaryCheckpoints
.
append
(
aPoint
)
;
return
NewCheckpoint
(
true
)
;
}
ExecutionPoint
LastTemporaryCheckpointLocation
(
)
{
MOZ_RELEASE_ASSERT
(
!
mTemporaryCheckpoints
.
empty
(
)
)
;
return
mTemporaryCheckpoints
.
back
(
)
;
}
CheckpointId
LastTemporaryCheckpointId
(
)
{
MOZ_RELEASE_ASSERT
(
!
mTemporaryCheckpoints
.
empty
(
)
)
;
size_t
normal
=
mTemporaryCheckpoints
.
back
(
)
.
mCheckpoint
;
size_t
temporary
=
mTemporaryCheckpoints
.
length
(
)
;
return
CheckpointId
(
normal
temporary
)
;
}
}
;
static
NavigationState
*
gNavigation
;
static
void
GetAllBreakpointHits
(
const
ExecutionPoint
&
aPoint
BreakpointVector
&
aHitBreakpoints
)
{
MOZ_RELEASE_ASSERT
(
aPoint
.
HasPosition
(
)
)
;
for
(
size_t
id
=
0
;
id
<
gNavigation
-
>
mBreakpoints
.
length
(
)
;
id
+
+
)
{
const
BreakpointPosition
&
breakpoint
=
gNavigation
-
>
mBreakpoints
[
id
]
;
if
(
breakpoint
.
IsValid
(
)
&
&
breakpoint
.
Subsumes
(
aPoint
.
mPosition
)
)
{
aHitBreakpoints
.
append
(
id
)
;
}
}
}
static
bool
ThisProcessCanRewind
(
)
{
return
HasSavedCheckpoint
(
)
;
}
void
BreakpointPausedPhase
:
:
Enter
(
const
ExecutionPoint
&
aPoint
bool
aRecordingEndpoint
const
BreakpointVector
&
aBreakpoints
)
{
MOZ_RELEASE_ASSERT
(
aPoint
.
HasPosition
(
)
)
;
mPoint
=
aPoint
;
mRequests
.
clear
(
)
;
mRecoveringFromDivergence
=
false
;
mRequestIndex
=
0
;
mResumeForward
=
false
;
gNavigation
-
>
SetPhase
(
this
)
;
if
(
ThisProcessCanRewind
(
)
)
{
if
(
!
gNavigation
-
>
SaveTemporaryCheckpoint
(
aPoint
)
)
{
if
(
gNavigation
-
>
mPhase
=
=
this
)
{
MOZ_RELEASE_ASSERT
(
!
mRecoveringFromDivergence
)
;
if
(
mResumeForward
)
{
gNavigation
-
>
mForwardPhase
.
Enter
(
aPoint
)
;
return
;
}
mRecoveringFromDivergence
=
true
;
PauseMainThreadAndInvokeCallback
(
[
=
]
(
)
{
RespondAfterRecoveringFromDivergence
(
)
;
}
)
;
Unreachable
(
)
;
}
gNavigation
-
>
PositionHit
(
aPoint
)
;
return
;
}
}
child
:
:
HitBreakpoint
(
aRecordingEndpoint
aBreakpoints
.
begin
(
)
aBreakpoints
.
length
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
ThisProcessCanRewind
(
)
)
;
}
void
BreakpointPausedPhase
:
:
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
ThisProcessCanRewind
(
)
)
;
MOZ_RELEASE_ASSERT
(
aCheckpoint
=
=
gNavigation
-
>
LastTemporaryCheckpointId
(
)
)
;
}
void
BreakpointPausedPhase
:
:
PositionHit
(
const
ExecutionPoint
&
aPoint
)
{
}
void
BreakpointPausedPhase
:
:
Resume
(
bool
aForward
)
{
MOZ_RELEASE_ASSERT
(
!
mRecoveringFromDivergence
)
;
if
(
aForward
)
{
if
(
ThisProcessCanRewind
(
)
)
{
mResumeForward
=
true
;
RestoreCheckpointAndResume
(
gNavigation
-
>
LastTemporaryCheckpointId
(
)
)
;
Unreachable
(
)
;
}
js
:
:
ClearPausedState
(
)
;
gNavigation
-
>
mForwardPhase
.
Enter
(
mPoint
)
;
return
;
}
CheckpointId
start
=
gNavigation
-
>
LastTemporaryCheckpointId
(
)
;
start
.
mTemporary
-
-
;
gNavigation
-
>
mFindLastHitPhase
.
Enter
(
start
Some
(
mPoint
)
)
;
Unreachable
(
)
;
}
void
BreakpointPausedPhase
:
:
RestoreCheckpoint
(
size_t
aCheckpoint
)
{
gNavigation
-
>
mCheckpointPausedPhase
.
Enter
(
aCheckpoint
true
false
)
;
}
void
BreakpointPausedPhase
:
:
HandleDebuggerRequest
(
js
:
:
CharBuffer
*
aRequestBuffer
)
{
MOZ_RELEASE_ASSERT
(
!
mRecoveringFromDivergence
)
;
mRequests
.
emplaceBack
(
)
;
RequestInfo
&
info
=
mRequests
.
back
(
)
;
mRequestIndex
=
mRequests
.
length
(
)
-
1
;
info
.
mRequestBuffer
.
append
(
aRequestBuffer
-
>
begin
(
)
aRequestBuffer
-
>
length
(
)
)
;
js
:
:
CharBuffer
responseBuffer
;
js
:
:
ProcessRequest
(
aRequestBuffer
-
>
begin
(
)
aRequestBuffer
-
>
length
(
)
&
responseBuffer
)
;
delete
aRequestBuffer
;
info
.
mResponseBuffer
.
append
(
responseBuffer
.
begin
(
)
responseBuffer
.
length
(
)
)
;
child
:
:
RespondToRequest
(
responseBuffer
)
;
}
void
BreakpointPausedPhase
:
:
RespondAfterRecoveringFromDivergence
(
)
{
MOZ_RELEASE_ASSERT
(
mRecoveringFromDivergence
)
;
MOZ_RELEASE_ASSERT
(
mRequests
.
length
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
mRequests
.
back
(
)
.
mUnhandledDivergence
)
;
mRequests
.
back
(
)
.
mUnhandledDivergence
=
true
;
for
(
size_t
i
=
0
;
i
<
mRequests
.
length
(
)
;
i
+
+
)
{
RequestInfo
&
info
=
mRequests
[
i
]
;
mRequestIndex
=
i
;
js
:
:
CharBuffer
responseBuffer
;
js
:
:
ProcessRequest
(
info
.
mRequestBuffer
.
begin
(
)
info
.
mRequestBuffer
.
length
(
)
&
responseBuffer
)
;
if
(
i
<
mRequests
.
length
(
)
-
1
)
{
MOZ_RELEASE_ASSERT
(
responseBuffer
.
length
(
)
=
=
info
.
mResponseBuffer
.
length
(
)
)
;
MOZ_RELEASE_ASSERT
(
memcmp
(
responseBuffer
.
begin
(
)
info
.
mResponseBuffer
.
begin
(
)
responseBuffer
.
length
(
)
*
sizeof
(
char16_t
)
)
=
=
0
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
info
.
mResponseBuffer
.
empty
(
)
)
;
info
.
mResponseBuffer
.
append
(
responseBuffer
.
begin
(
)
responseBuffer
.
length
(
)
)
;
child
:
:
RespondToRequest
(
responseBuffer
)
;
}
}
mRecoveringFromDivergence
=
false
;
}
bool
BreakpointPausedPhase
:
:
MaybeDivergeFromRecording
(
)
{
if
(
!
ThisProcessCanRewind
(
)
)
{
return
false
;
}
if
(
mRequests
[
mRequestIndex
]
.
mUnhandledDivergence
)
{
return
false
;
}
DivergeFromRecording
(
)
;
return
true
;
}
ExecutionPoint
BreakpointPausedPhase
:
:
GetRecordingEndpoint
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
)
;
return
mPoint
;
}
void
CheckpointPausedPhase
:
:
Enter
(
size_t
aCheckpoint
bool
aRewind
bool
aAtRecordingEndpoint
)
{
mCheckpoint
=
aCheckpoint
;
mAtRecordingEndpoint
=
aAtRecordingEndpoint
;
gNavigation
-
>
SetPhase
(
this
)
;
if
(
aRewind
)
{
RestoreCheckpointAndResume
(
CheckpointId
(
mCheckpoint
)
)
;
Unreachable
(
)
;
}
AfterCheckpoint
(
CheckpointId
(
mCheckpoint
)
)
;
}
void
CheckpointPausedPhase
:
:
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
aCheckpoint
=
=
CheckpointId
(
mCheckpoint
)
)
;
child
:
:
HitCheckpoint
(
mCheckpoint
mAtRecordingEndpoint
)
;
}
void
CheckpointPausedPhase
:
:
PositionHit
(
const
ExecutionPoint
&
aPoint
)
{
}
void
CheckpointPausedPhase
:
:
Resume
(
bool
aForward
)
{
MOZ_RELEASE_ASSERT
(
aForward
|
|
mCheckpoint
!
=
CheckpointId
:
:
First
)
;
if
(
aForward
)
{
js
:
:
ClearPausedState
(
)
;
ExecutionPoint
search
(
mCheckpoint
)
;
gNavigation
-
>
mForwardPhase
.
Enter
(
search
)
;
}
else
{
CheckpointId
start
(
mCheckpoint
-
1
)
;
gNavigation
-
>
mFindLastHitPhase
.
Enter
(
start
Nothing
(
)
)
;
Unreachable
(
)
;
}
}
void
CheckpointPausedPhase
:
:
RestoreCheckpoint
(
size_t
aCheckpoint
)
{
Enter
(
aCheckpoint
aCheckpoint
!
=
mCheckpoint
false
)
;
}
void
CheckpointPausedPhase
:
:
RunToPoint
(
const
ExecutionPoint
&
aTarget
)
{
MOZ_RELEASE_ASSERT
(
aTarget
.
mCheckpoint
=
=
mCheckpoint
)
;
ResumeExecution
(
)
;
gNavigation
-
>
mReachBreakpointPhase
.
Enter
(
CheckpointId
(
mCheckpoint
)
false
aTarget
Nothing
(
)
)
;
}
void
CheckpointPausedPhase
:
:
HandleDebuggerRequest
(
js
:
:
CharBuffer
*
aRequestBuffer
)
{
js
:
:
CharBuffer
responseBuffer
;
js
:
:
ProcessRequest
(
aRequestBuffer
-
>
begin
(
)
aRequestBuffer
-
>
length
(
)
&
responseBuffer
)
;
delete
aRequestBuffer
;
child
:
:
RespondToRequest
(
responseBuffer
)
;
}
ExecutionPoint
CheckpointPausedPhase
:
:
GetRecordingEndpoint
(
)
{
return
ExecutionPoint
(
mCheckpoint
)
;
}
void
ForwardPhase
:
:
Enter
(
const
ExecutionPoint
&
aPoint
)
{
mPoint
=
aPoint
;
gNavigation
-
>
SetPhase
(
this
)
;
for
(
const
BreakpointPosition
&
breakpoint
:
gNavigation
-
>
mBreakpoints
)
{
if
(
breakpoint
.
IsValid
(
)
)
{
js
:
:
EnsurePositionHandler
(
breakpoint
)
;
}
}
ResumeExecution
(
)
;
}
void
ForwardPhase
:
:
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
!
aCheckpoint
.
mTemporary
&
&
aCheckpoint
.
mNormal
=
=
mPoint
.
mCheckpoint
+
1
)
;
gNavigation
-
>
mCheckpointPausedPhase
.
Enter
(
aCheckpoint
.
mNormal
false
false
)
;
}
void
ForwardPhase
:
:
PositionHit
(
const
ExecutionPoint
&
aPoint
)
{
BreakpointVector
hitBreakpoints
;
GetAllBreakpointHits
(
aPoint
hitBreakpoints
)
;
if
(
!
hitBreakpoints
.
empty
(
)
)
{
gNavigation
-
>
mBreakpointPausedPhase
.
Enter
(
aPoint
false
hitBreakpoints
)
;
}
}
void
ForwardPhase
:
:
HitRecordingEndpoint
(
const
ExecutionPoint
&
aPoint
)
{
if
(
aPoint
.
HasPosition
(
)
)
{
BreakpointVector
emptyBreakpoints
;
gNavigation
-
>
mBreakpointPausedPhase
.
Enter
(
aPoint
true
emptyBreakpoints
)
;
}
else
{
gNavigation
-
>
mCheckpointPausedPhase
.
Enter
(
aPoint
.
mCheckpoint
false
true
)
;
}
}
void
ReachBreakpointPhase
:
:
Enter
(
const
CheckpointId
&
aStart
bool
aRewind
const
ExecutionPoint
&
aPoint
const
Maybe
<
ExecutionPoint
>
&
aTemporaryCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
aPoint
.
HasPosition
(
)
)
;
MOZ_RELEASE_ASSERT
(
aTemporaryCheckpoint
.
isNothing
(
)
|
|
(
aTemporaryCheckpoint
.
ref
(
)
.
HasPosition
(
)
&
&
aTemporaryCheckpoint
.
ref
(
)
!
=
aPoint
)
)
;
mStart
=
aStart
;
mPoint
=
aPoint
;
mTemporaryCheckpoint
=
aTemporaryCheckpoint
;
mSavedTemporaryCheckpoint
=
false
;
gNavigation
-
>
SetPhase
(
this
)
;
if
(
aRewind
)
{
RestoreCheckpointAndResume
(
aStart
)
;
Unreachable
(
)
;
}
else
{
AfterCheckpoint
(
aStart
)
;
}
}
void
ReachBreakpointPhase
:
:
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
{
if
(
aCheckpoint
=
=
mStart
&
&
mTemporaryCheckpoint
.
isSome
(
)
)
{
js
:
:
EnsurePositionHandler
(
mTemporaryCheckpoint
.
ref
(
)
.
mPosition
)
;
mStartTime
=
CurrentTime
(
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
(
aCheckpoint
=
=
mStart
&
&
mTemporaryCheckpoint
.
isNothing
(
)
)
|
|
(
aCheckpoint
=
=
mStart
.
NextCheckpoint
(
true
)
&
&
mSavedTemporaryCheckpoint
)
)
;
}
js
:
:
EnsurePositionHandler
(
mPoint
.
mPosition
)
;
}
static
const
double
kTemporaryCheckpointThresholdMs
=
10
;
void
AlwaysSaveTemporaryCheckpoints
(
)
{
gNavigation
-
>
mAlwaysSaveTemporaryCheckpoints
=
true
;
}
void
ReachBreakpointPhase
:
:
PositionHit
(
const
ExecutionPoint
&
aPoint
)
{
if
(
mTemporaryCheckpoint
.
isSome
(
)
&
&
mTemporaryCheckpoint
.
ref
(
)
=
=
aPoint
)
{
double
elapsedMs
=
(
CurrentTime
(
)
-
mStartTime
)
/
1000
.
0
;
if
(
elapsedMs
>
=
kTemporaryCheckpointThresholdMs
|
|
gNavigation
-
>
mAlwaysSaveTemporaryCheckpoints
)
{
MOZ_RELEASE_ASSERT
(
!
mSavedTemporaryCheckpoint
)
;
mSavedTemporaryCheckpoint
=
true
;
if
(
!
gNavigation
-
>
SaveTemporaryCheckpoint
(
aPoint
)
)
{
gNavigation
-
>
PositionHit
(
aPoint
)
;
return
;
}
}
}
if
(
mPoint
=
=
aPoint
)
{
BreakpointVector
hitBreakpoints
;
GetAllBreakpointHits
(
aPoint
hitBreakpoints
)
;
gNavigation
-
>
mBreakpointPausedPhase
.
Enter
(
aPoint
false
hitBreakpoints
)
;
}
}
void
FindLastHitPhase
:
:
Enter
(
const
CheckpointId
&
aStart
const
Maybe
<
ExecutionPoint
>
&
aEnd
)
{
MOZ_RELEASE_ASSERT
(
aEnd
.
isNothing
(
)
|
|
aEnd
.
ref
(
)
.
HasPosition
(
)
)
;
mStart
=
aStart
;
mEnd
=
aEnd
;
mCounter
=
0
;
mTrackedPositions
.
clear
(
)
;
gNavigation
-
>
SetPhase
(
this
)
;
for
(
const
BreakpointPosition
&
breakpoint
:
gNavigation
-
>
mBreakpoints
)
{
if
(
breakpoint
.
IsValid
(
)
)
{
mTrackedPositions
.
emplaceBack
(
breakpoint
)
;
}
}
for
(
const
BreakpointPosition
&
breakpoint
:
gNavigation
-
>
mBreakpoints
)
{
Maybe
<
BreakpointPosition
>
entry
=
GetEntryPosition
(
breakpoint
)
;
if
(
entry
.
isSome
(
)
)
{
mTrackedPositions
.
emplaceBack
(
entry
.
ref
(
)
)
;
}
}
RestoreCheckpointAndResume
(
mStart
)
;
Unreachable
(
)
;
}
void
FindLastHitPhase
:
:
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
{
if
(
aCheckpoint
=
=
mStart
.
NextCheckpoint
(
false
)
)
{
MOZ_RELEASE_ASSERT
(
mEnd
.
isNothing
(
)
)
;
OnRegionEnd
(
)
;
Unreachable
(
)
;
}
MOZ_RELEASE_ASSERT
(
aCheckpoint
=
=
mStart
)
;
for
(
const
TrackedPosition
&
tracked
:
mTrackedPositions
)
{
js
:
:
EnsurePositionHandler
(
tracked
.
mPosition
)
;
}
if
(
mEnd
.
isSome
(
)
)
{
js
:
:
EnsurePositionHandler
(
mEnd
.
ref
(
)
.
mPosition
)
;
}
}
void
FindLastHitPhase
:
:
PositionHit
(
const
ExecutionPoint
&
aPoint
)
{
if
(
mEnd
.
isSome
(
)
&
&
mEnd
.
ref
(
)
=
=
aPoint
)
{
OnRegionEnd
(
)
;
Unreachable
(
)
;
}
+
+
mCounter
;
for
(
TrackedPosition
&
tracked
:
mTrackedPositions
)
{
if
(
tracked
.
mPosition
.
Subsumes
(
aPoint
.
mPosition
)
)
{
tracked
.
mLastHit
=
aPoint
;
tracked
.
mLastHitCount
=
mCounter
;
break
;
}
}
}
void
FindLastHitPhase
:
:
HitRecordingEndpoint
(
const
ExecutionPoint
&
aPoint
)
{
OnRegionEnd
(
)
;
Unreachable
(
)
;
}
const
FindLastHitPhase
:
:
TrackedPosition
&
FindLastHitPhase
:
:
FindTrackedPosition
(
const
BreakpointPosition
&
aPos
)
{
for
(
const
TrackedPosition
&
tracked
:
mTrackedPositions
)
{
if
(
tracked
.
mPosition
=
=
aPos
)
{
return
tracked
;
}
}
MOZ_CRASH
(
"
Could
not
find
tracked
position
"
)
;
}
void
FindLastHitPhase
:
:
OnRegionEnd
(
)
{
Maybe
<
TrackedPosition
>
lastBreakpoint
;
for
(
const
BreakpointPosition
&
breakpoint
:
gNavigation
-
>
mBreakpoints
)
{
if
(
!
breakpoint
.
IsValid
(
)
)
{
continue
;
}
const
TrackedPosition
&
tracked
=
FindTrackedPosition
(
breakpoint
)
;
if
(
tracked
.
mLastHit
.
HasPosition
(
)
&
&
(
lastBreakpoint
.
isNothing
(
)
|
|
lastBreakpoint
.
ref
(
)
.
mLastHitCount
<
tracked
.
mLastHitCount
)
)
{
lastBreakpoint
=
Some
(
tracked
)
;
}
}
if
(
lastBreakpoint
.
isNothing
(
)
)
{
if
(
mStart
.
mTemporary
)
{
CheckpointId
start
=
mStart
;
start
.
mTemporary
-
-
;
ExecutionPoint
end
=
gNavigation
-
>
LastTemporaryCheckpointLocation
(
)
;
gNavigation
-
>
mFindLastHitPhase
.
Enter
(
start
Some
(
end
)
)
;
Unreachable
(
)
;
}
else
{
gNavigation
-
>
mCheckpointPausedPhase
.
Enter
(
mStart
.
mNormal
true
false
)
;
Unreachable
(
)
;
}
}
Maybe
<
BreakpointPosition
>
baseEntry
=
GetEntryPosition
(
lastBreakpoint
.
ref
(
)
.
mPosition
)
;
if
(
baseEntry
.
isSome
(
)
)
{
const
TrackedPosition
&
tracked
=
FindTrackedPosition
(
baseEntry
.
ref
(
)
)
;
if
(
tracked
.
mLastHit
.
HasPosition
(
)
&
&
tracked
.
mLastHitCount
<
lastBreakpoint
.
ref
(
)
.
mLastHitCount
)
{
gNavigation
-
>
mReachBreakpointPhase
.
Enter
(
mStart
true
lastBreakpoint
.
ref
(
)
.
mLastHit
Some
(
tracked
.
mLastHit
)
)
;
Unreachable
(
)
;
}
}
gNavigation
-
>
mReachBreakpointPhase
.
Enter
(
mStart
true
lastBreakpoint
.
ref
(
)
.
mLastHit
Nothing
(
)
)
;
Unreachable
(
)
;
}
bool
IsInitialized
(
)
{
return
!
!
gNavigation
;
}
void
BeforeCheckpoint
(
)
{
if
(
!
IsInitialized
(
)
)
{
void
*
navigationMem
=
AllocateMemory
(
sizeof
(
NavigationState
)
MemoryKind
:
:
Navigation
)
;
gNavigation
=
new
(
navigationMem
)
NavigationState
(
)
;
js
:
:
SetupDevtoolsSandbox
(
)
;
}
AutoDisallowThreadEvents
disallow
;
js
:
:
ClearPositionHandlers
(
)
;
}
void
AfterCheckpoint
(
const
CheckpointId
&
aCheckpoint
)
{
AutoDisallowThreadEvents
disallow
;
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
gNavigation
-
>
AfterCheckpoint
(
aCheckpoint
)
;
}
void
DebuggerRequest
(
js
:
:
CharBuffer
*
aRequestBuffer
)
{
gNavigation
-
>
HandleDebuggerRequest
(
aRequestBuffer
)
;
}
void
SetBreakpoint
(
size_t
aId
const
BreakpointPosition
&
aPosition
)
{
gNavigation
-
>
GetBreakpoint
(
aId
)
=
aPosition
;
}
void
Resume
(
bool
aForward
)
{
if
(
!
gNavigation
)
{
ResumeExecution
(
)
;
return
;
}
gNavigation
-
>
Resume
(
aForward
)
;
}
void
RestoreCheckpoint
(
size_t
aId
)
{
gNavigation
-
>
RestoreCheckpoint
(
aId
)
;
}
void
RunToPoint
(
const
ExecutionPoint
&
aTarget
)
{
gNavigation
-
>
RunToPoint
(
aTarget
)
;
}
ExecutionPoint
GetRecordingEndpoint
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecording
(
)
)
;
return
gNavigation
-
>
GetRecordingEndpoint
(
)
;
}
void
SetRecordingEndpoint
(
size_t
aIndex
const
ExecutionPoint
&
aEndpoint
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
gNavigation
-
>
SetRecordingEndpoint
(
aIndex
aEndpoint
)
;
}
static
ProgressCounter
gProgressCounter
;
extern
"
C
"
{
MOZ_EXPORT
ProgressCounter
*
RecordReplayInterface_ExecutionProgressCounter
(
)
{
return
&
gProgressCounter
;
}
}
ExecutionPoint
CurrentExecutionPoint
(
const
BreakpointPosition
&
aPosition
)
{
return
ExecutionPoint
(
gNavigation
-
>
LastCheckpoint
(
)
.
mNormal
gProgressCounter
aPosition
)
;
}
void
PositionHit
(
const
BreakpointPosition
&
position
)
{
AutoDisallowThreadEvents
disallow
;
gNavigation
-
>
PositionHit
(
CurrentExecutionPoint
(
position
)
)
;
}
extern
"
C
"
{
MOZ_EXPORT
ProgressCounter
RecordReplayInterface_NewTimeWarpTarget
(
)
{
recordreplay
:
:
RecordReplayAssert
(
"
NewTimeWarpTarget
"
)
;
if
(
!
gNavigation
)
{
return
0
;
}
ProgressCounter
progress
=
+
+
gProgressCounter
;
PositionHit
(
BreakpointPosition
(
BreakpointPosition
:
:
WarpTarget
)
)
;
if
(
gNavigation
-
>
mTimeWarpTargetCheckpoints
.
empty
(
)
|
|
progress
>
gNavigation
-
>
mTimeWarpTargetCheckpoints
.
back
(
)
.
first
)
{
size_t
checkpoint
=
gNavigation
-
>
LastCheckpoint
(
)
.
mNormal
;
gNavigation
-
>
mTimeWarpTargetCheckpoints
.
emplaceBack
(
progress
checkpoint
)
;
}
return
progress
;
}
}
ExecutionPoint
TimeWarpTargetExecutionPoint
(
ProgressCounter
aTarget
)
{
Maybe
<
size_t
>
checkpoint
;
for
(
auto
entry
:
gNavigation
-
>
mTimeWarpTargetCheckpoints
)
{
if
(
entry
.
first
=
=
aTarget
)
{
checkpoint
.
emplace
(
entry
.
second
)
;
break
;
}
}
MOZ_RELEASE_ASSERT
(
checkpoint
.
isSome
(
)
)
;
return
ExecutionPoint
(
checkpoint
.
ref
(
)
aTarget
BreakpointPosition
(
BreakpointPosition
:
:
WarpTarget
)
)
;
}
bool
MaybeDivergeFromRecording
(
)
{
return
gNavigation
-
>
MaybeDivergeFromRecording
(
)
;
}
}
}
}
