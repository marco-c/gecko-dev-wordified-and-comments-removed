#
include
"
ParentInternal
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
ipc
/
Channel
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
mozilla
/
dom
/
ProcessGlobal
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
Monitor
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ProcessRedirect
.
h
"
#
include
<
algorithm
>
using
std
:
:
min
;
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
const
char
*
gSaveAllRecordingsDirectory
=
nullptr
;
void
InitializeUIProcess
(
int
aArgc
char
*
*
aArgv
)
{
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
if
(
!
strcmp
(
aArgv
[
i
]
"
-
-
save
-
recordings
"
)
&
&
i
+
1
<
aArgc
)
{
gSaveAllRecordingsDirectory
=
strdup
(
aArgv
[
i
+
1
]
)
;
}
}
}
const
char
*
SaveAllRecordingsDirectory
(
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
gSaveAllRecordingsDirectory
;
}
static
const
double
FlushSeconds
=
.
5
;
static
const
double
MajorCheckpointSeconds
=
2
;
static
ChildProcessInfo
*
gActiveChild
;
static
ChildProcessInfo
*
gRecordingChild
;
static
ChildProcessInfo
*
gFirstReplayingChild
;
static
ChildProcessInfo
*
gSecondReplayingChild
;
static
bool
gRecordingFileIsTemporary
;
void
Shutdown
(
)
{
if
(
gRecordingFileIsTemporary
)
{
DirectDeleteFile
(
gRecordingFilename
)
;
}
delete
gRecordingChild
;
delete
gFirstReplayingChild
;
delete
gSecondReplayingChild
;
_exit
(
0
)
;
}
static
ChildProcessInfo
*
OtherReplayingChild
(
ChildProcessInfo
*
aChild
)
{
MOZ_RELEASE_ASSERT
(
!
aChild
-
>
IsRecording
(
)
&
&
gFirstReplayingChild
&
&
gSecondReplayingChild
)
;
return
aChild
=
=
gFirstReplayingChild
?
gSecondReplayingChild
:
gFirstReplayingChild
;
}
static
void
ForEachReplayingChild
(
const
std
:
:
function
<
void
(
ChildProcessInfo
*
)
>
&
aCallback
)
{
if
(
gFirstReplayingChild
)
{
aCallback
(
gFirstReplayingChild
)
;
}
if
(
gSecondReplayingChild
)
{
aCallback
(
gSecondReplayingChild
)
;
}
}
static
void
PokeChildren
(
)
{
ForEachReplayingChild
(
[
=
]
(
ChildProcessInfo
*
aChild
)
{
if
(
aChild
-
>
IsPaused
(
)
)
{
aChild
-
>
Role
(
)
-
>
Poke
(
)
;
}
}
)
;
}
static
void
RecvHitCheckpoint
(
const
HitCheckpointMessage
&
aMsg
)
;
static
void
RecvHitBreakpoint
(
const
HitBreakpointMessage
&
aMsg
)
;
static
void
RecvDebuggerResponse
(
const
DebuggerResponseMessage
&
aMsg
)
;
static
void
RecvRecordingFlushed
(
)
;
static
void
RecvAlwaysMarkMajorCheckpoints
(
)
;
class
ChildRoleActive
final
:
public
ChildRole
{
public
:
ChildRoleActive
(
)
:
ChildRole
(
Active
)
{
}
void
Initialize
(
)
override
{
gActiveChild
=
mProcess
;
mProcess
-
>
SendMessage
(
SetIsActiveMessage
(
true
)
)
;
if
(
mProcess
-
>
LastCheckpoint
(
)
=
=
CheckpointId
:
:
Invalid
)
{
mProcess
-
>
SendMessage
(
ResumeMessage
(
true
)
)
;
}
}
void
OnIncomingMessage
(
const
Message
&
aMsg
)
override
{
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
Paint
:
UpdateGraphicsInUIProcess
(
(
const
PaintMessage
*
)
&
aMsg
)
;
break
;
case
MessageType
:
:
HitCheckpoint
:
RecvHitCheckpoint
(
(
const
HitCheckpointMessage
&
)
aMsg
)
;
break
;
case
MessageType
:
:
HitBreakpoint
:
RecvHitBreakpoint
(
(
const
HitBreakpointMessage
&
)
aMsg
)
;
break
;
case
MessageType
:
:
DebuggerResponse
:
RecvDebuggerResponse
(
(
const
DebuggerResponseMessage
&
)
aMsg
)
;
break
;
case
MessageType
:
:
RecordingFlushed
:
RecvRecordingFlushed
(
)
;
break
;
case
MessageType
:
:
AlwaysMarkMajorCheckpoints
:
RecvAlwaysMarkMajorCheckpoints
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
message
"
)
;
}
}
}
;
bool
ActiveChildIsRecording
(
)
{
return
gActiveChild
-
>
IsRecording
(
)
;
}
ChildProcessInfo
*
ActiveRecordingChild
(
)
{
MOZ_RELEASE_ASSERT
(
ActiveChildIsRecording
(
)
)
;
return
gActiveChild
;
}
static
size_t
gLastRecordingCheckpoint
;
class
ChildRoleStandby
final
:
public
ChildRole
{
public
:
ChildRoleStandby
(
)
:
ChildRole
(
Standby
)
{
}
void
Initialize
(
)
override
{
MOZ_RELEASE_ASSERT
(
mProcess
-
>
IsPausedAtCheckpoint
(
)
)
;
mProcess
-
>
SendMessage
(
SetIsActiveMessage
(
false
)
)
;
Poke
(
)
;
}
void
OnIncomingMessage
(
const
Message
&
aMsg
)
override
{
MOZ_RELEASE_ASSERT
(
aMsg
.
mType
=
=
MessageType
:
:
HitCheckpoint
)
;
Poke
(
)
;
}
void
Poke
(
)
override
;
}
;
class
ChildRoleInert
final
:
public
ChildRole
{
public
:
ChildRoleInert
(
)
:
ChildRole
(
Inert
)
{
}
void
Initialize
(
)
override
{
MOZ_RELEASE_ASSERT
(
mProcess
-
>
IsRecording
(
)
&
&
mProcess
-
>
IsPaused
(
)
)
;
}
void
OnIncomingMessage
(
const
Message
&
aMsg
)
override
{
MOZ_CRASH
(
"
Unexpected
message
from
inert
recording
child
"
)
;
}
}
;
static
size_t
LastMajorCheckpointPreceding
(
ChildProcessInfo
*
aChild
size_t
aId
)
{
size_t
last
=
CheckpointId
:
:
Invalid
;
for
(
size_t
majorCheckpoint
:
aChild
-
>
MajorCheckpoints
(
)
)
{
if
(
majorCheckpoint
>
aId
)
{
break
;
}
last
=
majorCheckpoint
;
}
return
last
;
}
static
ChildProcessInfo
*
ReplayingChildResponsibleForSavingCheckpoint
(
size_t
aId
)
{
MOZ_RELEASE_ASSERT
(
CanRewind
(
)
&
&
gFirstReplayingChild
&
&
gSecondReplayingChild
)
;
size_t
firstMajor
=
LastMajorCheckpointPreceding
(
gFirstReplayingChild
aId
)
;
size_t
secondMajor
=
LastMajorCheckpointPreceding
(
gSecondReplayingChild
aId
)
;
return
(
firstMajor
<
secondMajor
)
?
gSecondReplayingChild
:
gFirstReplayingChild
;
}
static
bool
ActiveChildIsPausedOrRewinding
(
)
;
static
void
ClearIfSavedNonMajorCheckpoint
(
ChildProcessInfo
*
aChild
size_t
aCheckpoint
)
{
if
(
aChild
-
>
ShouldSaveCheckpoint
(
aCheckpoint
)
&
&
!
aChild
-
>
IsMajorCheckpoint
(
aCheckpoint
)
&
&
aCheckpoint
!
=
CheckpointId
:
:
First
)
{
aChild
-
>
SendMessage
(
SetSaveCheckpointMessage
(
aCheckpoint
false
)
)
;
}
}
void
ChildRoleStandby
:
:
Poke
(
)
{
MOZ_RELEASE_ASSERT
(
mProcess
-
>
IsPausedAtCheckpoint
(
)
)
;
if
(
mProcess
-
>
PauseNeeded
(
)
)
{
return
;
}
do
{
if
(
!
ActiveChildIsPausedOrRewinding
(
)
)
{
break
;
}
size_t
targetCheckpoint
=
gActiveChild
-
>
RewindTargetCheckpoint
(
)
;
size_t
lastMajorCheckpoint
=
LastMajorCheckpointPreceding
(
mProcess
targetCheckpoint
)
;
if
(
lastMajorCheckpoint
=
=
CheckpointId
:
:
Invalid
)
{
return
;
}
if
(
mProcess
-
>
LastCheckpoint
(
)
<
lastMajorCheckpoint
)
{
break
;
}
size_t
otherMajorCheckpoint
=
LastMajorCheckpointPreceding
(
OtherReplayingChild
(
mProcess
)
targetCheckpoint
)
;
if
(
otherMajorCheckpoint
>
lastMajorCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
otherMajorCheckpoint
<
=
targetCheckpoint
)
;
targetCheckpoint
=
otherMajorCheckpoint
-
1
;
}
Maybe
<
size_t
>
missingCheckpoint
;
for
(
size_t
i
=
lastMajorCheckpoint
;
i
<
=
targetCheckpoint
;
i
+
+
)
{
if
(
!
mProcess
-
>
HasSavedCheckpoint
(
i
)
)
{
missingCheckpoint
.
emplace
(
i
)
;
break
;
}
}
if
(
!
missingCheckpoint
.
isSome
(
)
)
{
return
;
}
size_t
restoreTarget
=
missingCheckpoint
.
ref
(
)
-
1
;
MOZ_RELEASE_ASSERT
(
mProcess
-
>
HasSavedCheckpoint
(
restoreTarget
)
)
;
if
(
mProcess
-
>
LastCheckpoint
(
)
!
=
restoreTarget
)
{
mProcess
-
>
SendMessage
(
RestoreCheckpointMessage
(
restoreTarget
)
)
;
return
;
}
if
(
!
mProcess
-
>
ShouldSaveCheckpoint
(
missingCheckpoint
.
ref
(
)
)
)
{
mProcess
-
>
SendMessage
(
SetSaveCheckpointMessage
(
missingCheckpoint
.
ref
(
)
true
)
)
;
}
mProcess
-
>
SendMessage
(
ResumeMessage
(
true
)
)
;
return
;
}
while
(
false
)
;
if
(
(
mProcess
-
>
LastCheckpoint
(
)
<
gActiveChild
-
>
LastCheckpoint
(
)
)
&
&
(
!
gRecordingChild
|
|
mProcess
-
>
LastCheckpoint
(
)
<
gLastRecordingCheckpoint
)
)
{
ClearIfSavedNonMajorCheckpoint
(
mProcess
mProcess
-
>
LastCheckpoint
(
)
+
1
)
;
mProcess
-
>
SendMessage
(
ResumeMessage
(
true
)
)
;
}
}
static
StaticInfallibleVector
<
TimeDuration
>
gCheckpointTimes
;
static
TimeDuration
gTimeSinceLastFlush
;
static
TimeDuration
gTimeSinceLastMajorCheckpoint
;
static
ChildProcessInfo
*
gLastAssignedMajorCheckpoint
;
static
bool
gAlwaysMarkMajorCheckpoints
;
static
void
RecvAlwaysMarkMajorCheckpoints
(
)
{
gAlwaysMarkMajorCheckpoints
=
true
;
}
static
void
AssignMajorCheckpoint
(
ChildProcessInfo
*
aChild
size_t
aId
)
{
PrintSpew
(
"
AssignMajorCheckpoint
:
Process
%
d
Checkpoint
%
d
\
n
"
(
int
)
aChild
-
>
GetId
(
)
(
int
)
aId
)
;
aChild
-
>
AddMajorCheckpoint
(
aId
)
;
if
(
aId
!
=
CheckpointId
:
:
First
)
{
aChild
-
>
WaitUntilPaused
(
)
;
aChild
-
>
SendMessage
(
SetSaveCheckpointMessage
(
aId
true
)
)
;
}
gLastAssignedMajorCheckpoint
=
aChild
;
}
static
void
FlushRecording
(
)
;
static
void
UpdateCheckpointTimes
(
const
HitCheckpointMessage
&
aMsg
)
{
if
(
!
CanRewind
(
)
|
|
(
aMsg
.
mCheckpointId
!
=
gCheckpointTimes
.
length
(
)
+
1
)
)
{
return
;
}
gCheckpointTimes
.
append
(
TimeDuration
:
:
FromMicroseconds
(
aMsg
.
mDurationMicroseconds
)
)
;
if
(
gActiveChild
-
>
IsRecording
(
)
)
{
gTimeSinceLastFlush
+
=
gCheckpointTimes
.
back
(
)
;
if
(
aMsg
.
mCheckpointId
=
=
CheckpointId
:
:
First
|
|
gTimeSinceLastFlush
>
=
TimeDuration
:
:
FromSeconds
(
FlushSeconds
)
)
{
FlushRecording
(
)
;
gTimeSinceLastFlush
=
0
;
}
}
gTimeSinceLastMajorCheckpoint
+
=
gCheckpointTimes
.
back
(
)
;
if
(
gTimeSinceLastMajorCheckpoint
>
=
TimeDuration
:
:
FromSeconds
(
MajorCheckpointSeconds
)
|
|
gAlwaysMarkMajorCheckpoints
)
{
MOZ_RELEASE_ASSERT
(
gLastAssignedMajorCheckpoint
)
;
ChildProcessInfo
*
child
=
OtherReplayingChild
(
gLastAssignedMajorCheckpoint
)
;
AssignMajorCheckpoint
(
child
aMsg
.
mCheckpointId
+
1
)
;
gTimeSinceLastMajorCheckpoint
=
0
;
}
}
static
void
SpawnRecordingChild
(
)
{
MOZ_RELEASE_ASSERT
(
!
gRecordingChild
&
&
!
gFirstReplayingChild
&
&
!
gSecondReplayingChild
)
;
gRecordingChild
=
new
ChildProcessInfo
(
MakeUnique
<
ChildRoleActive
>
(
)
true
)
;
}
static
void
SpawnSingleReplayingChild
(
)
{
MOZ_RELEASE_ASSERT
(
!
gRecordingChild
&
&
!
gFirstReplayingChild
&
&
!
gSecondReplayingChild
)
;
gFirstReplayingChild
=
new
ChildProcessInfo
(
MakeUnique
<
ChildRoleActive
>
(
)
false
)
;
}
static
void
SpawnReplayingChildren
(
)
{
MOZ_RELEASE_ASSERT
(
CanRewind
(
)
&
&
!
gFirstReplayingChild
&
&
!
gSecondReplayingChild
)
;
UniquePtr
<
ChildRole
>
firstRole
;
if
(
gRecordingChild
)
{
firstRole
=
MakeUnique
<
ChildRoleStandby
>
(
)
;
}
else
{
firstRole
=
MakeUnique
<
ChildRoleActive
>
(
)
;
}
gFirstReplayingChild
=
new
ChildProcessInfo
(
std
:
:
move
(
firstRole
)
false
)
;
gSecondReplayingChild
=
new
ChildProcessInfo
(
MakeUnique
<
ChildRoleStandby
>
(
)
false
)
;
AssignMajorCheckpoint
(
gSecondReplayingChild
CheckpointId
:
:
First
)
;
}
static
void
SwitchActiveChild
(
ChildProcessInfo
*
aChild
)
{
MOZ_RELEASE_ASSERT
(
aChild
!
=
gActiveChild
)
;
ChildProcessInfo
*
oldActiveChild
=
gActiveChild
;
aChild
-
>
WaitUntilPaused
(
)
;
if
(
!
aChild
-
>
IsRecording
(
)
)
{
aChild
-
>
Recover
(
gActiveChild
)
;
}
aChild
-
>
SetRole
(
MakeUnique
<
ChildRoleActive
>
(
)
)
;
if
(
oldActiveChild
-
>
IsRecording
(
)
)
{
oldActiveChild
-
>
SetRole
(
MakeUnique
<
ChildRoleInert
>
(
)
)
;
}
else
{
oldActiveChild
-
>
RecoverToCheckpoint
(
oldActiveChild
-
>
MostRecentSavedCheckpoint
(
)
)
;
oldActiveChild
-
>
SetRole
(
MakeUnique
<
ChildRoleStandby
>
(
)
)
;
}
}
static
bool
gPreferencesLoaded
;
static
bool
gRewindingEnabled
;
void
PreferencesLoaded
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gPreferencesLoaded
)
;
gPreferencesLoaded
=
true
;
gRewindingEnabled
=
Preferences
:
:
GetBool
(
"
devtools
.
recordreplay
.
enableRewinding
"
)
;
if
(
getenv
(
"
NO_REWIND
"
)
)
{
gRewindingEnabled
=
false
;
}
if
(
!
gRecordingChild
)
{
if
(
CanRewind
(
)
)
{
SpawnReplayingChildren
(
)
;
}
else
{
SpawnSingleReplayingChild
(
)
;
}
}
}
bool
CanRewind
(
)
{
MOZ_RELEASE_ASSERT
(
gPreferencesLoaded
)
;
return
gRewindingEnabled
;
}
static
void
FlushRecording
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gActiveChild
-
>
IsRecording
(
)
&
&
gActiveChild
-
>
IsPaused
(
)
)
;
ForEachReplayingChild
(
[
=
]
(
ChildProcessInfo
*
aChild
)
{
aChild
-
>
SetPauseNeeded
(
)
;
aChild
-
>
WaitUntilPaused
(
)
;
}
)
;
gActiveChild
-
>
SendMessage
(
FlushRecordingMessage
(
)
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
gLastRecordingCheckpoint
=
gActiveChild
-
>
LastCheckpoint
(
)
;
static
bool
gHasFlushed
=
false
;
if
(
!
gHasFlushed
&
&
CanRewind
(
)
)
{
SpawnReplayingChildren
(
)
;
}
gHasFlushed
=
true
;
}
static
void
RecvRecordingFlushed
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
ForEachReplayingChild
(
[
=
]
(
ChildProcessInfo
*
aChild
)
{
aChild
-
>
ClearPauseNeeded
(
)
;
}
)
;
}
static
void
MaybeCreateCheckpointInRecordingChild
(
)
{
if
(
gActiveChild
-
>
IsRecording
(
)
&
&
!
gActiveChild
-
>
IsPaused
(
)
)
{
gActiveChild
-
>
SendMessage
(
CreateCheckpointMessage
(
)
)
;
}
}
static
void
SendMessageToUIProcess
(
const
char
*
aMessage
)
{
AutoSafeJSContext
cx
;
dom
:
:
ProcessGlobal
*
cpmm
=
dom
:
:
ProcessGlobal
:
:
Get
(
)
;
ErrorResult
err
;
nsAutoString
message
;
message
.
Append
(
NS_ConvertUTF8toUTF16
(
aMessage
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
undefined
(
cx
)
;
cpmm
-
>
SendAsyncMessage
(
cx
message
undefined
nullptr
nullptr
undefined
err
)
;
MOZ_RELEASE_ASSERT
(
!
err
.
Failed
(
)
)
;
err
.
SuppressException
(
)
;
}
static
void
SaveRecordingInternal
(
char
*
aFilename
)
{
MOZ_RELEASE_ASSERT
(
gRecordingChild
)
;
if
(
gRecordingChild
=
=
gActiveChild
)
{
MOZ_RELEASE_ASSERT
(
gRecordingChild
=
=
gActiveChild
)
;
MaybeCreateCheckpointInRecordingChild
(
)
;
gRecordingChild
-
>
WaitUntilPaused
(
)
;
FlushRecording
(
)
;
}
int
readfd
=
DirectOpenFile
(
gRecordingFilename
false
)
;
int
writefd
=
DirectOpenFile
(
aFilename
true
)
;
char
buf
[
4096
]
;
while
(
true
)
{
size_t
n
=
DirectRead
(
readfd
buf
sizeof
(
buf
)
)
;
if
(
!
n
)
{
break
;
}
DirectWrite
(
writefd
buf
n
)
;
}
DirectCloseFile
(
readfd
)
;
DirectCloseFile
(
writefd
)
;
PrintSpew
(
"
Copied
Recording
%
s
\
n
"
aFilename
)
;
SendMessageToUIProcess
(
"
SaveRecordingFinished
"
)
;
free
(
aFilename
)
;
}
void
SaveRecording
(
const
nsCString
&
aFilename
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
char
*
filename
=
strdup
(
aFilename
.
get
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
SaveRecordingInternal
(
filename
)
;
}
else
{
MainThreadMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
SaveRecordingInternal
"
SaveRecordingInternal
filename
)
)
;
}
}
static
size_t
gLastExplicitPause
;
static
bool
HasSavedCheckpointsInRange
(
ChildProcessInfo
*
aChild
size_t
aStart
size_t
aEnd
)
{
for
(
size_t
i
=
aStart
;
i
<
=
aEnd
;
i
+
+
)
{
if
(
!
aChild
-
>
HasSavedCheckpoint
(
i
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsUserBreakpoint
(
JS
:
:
replay
:
:
ExecutionPosition
:
:
Kind
aKind
)
{
MOZ_RELEASE_ASSERT
(
aKind
!
=
JS
:
:
replay
:
:
ExecutionPosition
:
:
Invalid
)
;
return
aKind
!
=
JS
:
:
replay
:
:
ExecutionPosition
:
:
NewScript
;
}
static
void
MarkActiveChildExplicitPause
(
)
{
MOZ_RELEASE_ASSERT
(
gActiveChild
-
>
IsPaused
(
)
)
;
size_t
targetCheckpoint
=
gActiveChild
-
>
RewindTargetCheckpoint
(
)
;
if
(
gActiveChild
-
>
IsRecording
(
)
)
{
FlushRecording
(
)
;
if
(
CanRewind
(
)
&
&
gActiveChild
-
>
IsPausedAtMatchingBreakpoint
(
IsUserBreakpoint
)
)
{
ChildProcessInfo
*
child
=
OtherReplayingChild
(
ReplayingChildResponsibleForSavingCheckpoint
(
targetCheckpoint
)
)
;
SwitchActiveChild
(
child
)
;
}
}
else
if
(
CanRewind
(
)
)
{
if
(
gActiveChild
=
=
ReplayingChildResponsibleForSavingCheckpoint
(
targetCheckpoint
)
)
{
size_t
lastMajorCheckpoint
=
LastMajorCheckpointPreceding
(
gActiveChild
targetCheckpoint
)
;
if
(
!
HasSavedCheckpointsInRange
(
gActiveChild
lastMajorCheckpoint
targetCheckpoint
)
)
{
SwitchActiveChild
(
OtherReplayingChild
(
gActiveChild
)
)
;
}
}
}
gLastExplicitPause
=
targetCheckpoint
;
PrintSpew
(
"
MarkActiveChildExplicitPause
%
d
\
n
"
(
int
)
gLastExplicitPause
)
;
PokeChildren
(
)
;
}
static
bool
ActiveChildIsPausedOrRewinding
(
)
{
return
gActiveChild
-
>
RewindTargetCheckpoint
(
)
<
=
gLastExplicitPause
;
}
static
MessageLoop
*
gMainThreadMessageLoop
;
MessageLoop
*
MainThreadMessageLoop
(
)
{
return
gMainThreadMessageLoop
;
}
static
void
InitDebuggerHooks
(
)
;
static
char
*
gShmemPrefs
;
static
size_t
gShmemPrefsLen
;
void
NotePrefsShmemContents
(
char
*
aPrefs
size_t
aPrefsLen
)
{
MOZ_RELEASE_ASSERT
(
!
gShmemPrefs
)
;
gShmemPrefs
=
new
char
[
aPrefsLen
]
;
memcpy
(
gShmemPrefs
aPrefs
aPrefsLen
)
;
gShmemPrefsLen
=
aPrefsLen
;
}
void
InitializeMiddleman
(
int
aArgc
char
*
aArgv
[
]
base
:
:
ProcessId
aParentPid
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gShmemPrefs
)
;
IntroductionMessage
*
msg
=
IntroductionMessage
:
:
New
(
aParentPid
gShmemPrefs
gShmemPrefsLen
aArgc
aArgv
)
;
ChildProcessInfo
:
:
SetIntroductionMessage
(
msg
)
;
MOZ_RELEASE_ASSERT
(
gProcessKind
=
=
ProcessKind
:
:
MiddlemanRecording
|
|
gProcessKind
=
=
ProcessKind
:
:
MiddlemanReplaying
)
;
if
(
!
strcmp
(
gRecordingFilename
"
*
"
)
)
{
MOZ_RELEASE_ASSERT
(
gProcessKind
=
=
ProcessKind
:
:
MiddlemanRecording
)
;
free
(
gRecordingFilename
)
;
gRecordingFilename
=
mktemp
(
strdup
(
"
/
tmp
/
RecordingXXXXXX
"
)
)
;
gRecordingFileIsTemporary
=
true
;
}
InitDebuggerHooks
(
)
;
InitializeGraphicsMemory
(
)
;
gMonitor
=
new
Monitor
(
)
;
gMainThreadMessageLoop
=
MessageLoop
:
:
current
(
)
;
if
(
gProcessKind
=
=
ProcessKind
:
:
MiddlemanRecording
)
{
SpawnRecordingChild
(
)
;
}
InitializeForwarding
(
)
;
}
static
JS
:
:
replay
:
:
CharBuffer
*
gResponseBuffer
;
static
void
RecvDebuggerResponse
(
const
DebuggerResponseMessage
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
gResponseBuffer
&
&
gResponseBuffer
-
>
empty
(
)
)
;
if
(
!
gResponseBuffer
-
>
append
(
aMsg
.
Buffer
(
)
aMsg
.
BufferSize
(
)
)
)
{
MOZ_CRASH
(
"
RecvDebuggerResponse
"
)
;
}
}
static
void
HookDebuggerRequest
(
const
JS
:
:
replay
:
:
CharBuffer
&
aBuffer
JS
:
:
replay
:
:
CharBuffer
*
aResponse
)
{
MaybeCreateCheckpointInRecordingChild
(
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
MOZ_RELEASE_ASSERT
(
!
gResponseBuffer
)
;
gResponseBuffer
=
aResponse
;
DebuggerRequestMessage
*
msg
=
DebuggerRequestMessage
:
:
New
(
aBuffer
.
begin
(
)
aBuffer
.
length
(
)
)
;
gActiveChild
-
>
SendMessage
(
*
msg
)
;
free
(
msg
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
MOZ_RELEASE_ASSERT
(
gResponseBuffer
=
=
aResponse
)
;
MOZ_RELEASE_ASSERT
(
gResponseBuffer
-
>
length
(
)
!
=
0
)
;
gResponseBuffer
=
nullptr
;
}
static
void
HookSetBreakpoint
(
size_t
aId
const
JS
:
:
replay
:
:
ExecutionPosition
&
aPosition
)
{
MaybeCreateCheckpointInRecordingChild
(
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
gActiveChild
-
>
SendMessage
(
SetBreakpointMessage
(
aId
aPosition
)
)
;
if
(
!
gActiveChild
-
>
IsRecording
(
)
&
&
gRecordingChild
)
{
gRecordingChild
-
>
SendMessage
(
SetBreakpointMessage
(
aId
aPosition
)
)
;
}
}
static
bool
gChildExecuteForward
=
true
;
static
bool
gChildExecuteBackward
=
false
;
static
bool
gResumeForwardOrBackward
=
false
;
static
void
HookResume
(
bool
aForward
)
{
gActiveChild
-
>
WaitUntilPaused
(
)
;
gResumeForwardOrBackward
=
false
;
gChildExecuteForward
=
aForward
;
gChildExecuteBackward
=
!
aForward
;
if
(
!
aForward
&
&
!
gActiveChild
-
>
HasSavedCheckpoint
(
gActiveChild
-
>
RewindTargetCheckpoint
(
)
)
)
{
MOZ_RELEASE_ASSERT
(
ActiveChildIsPausedOrRewinding
(
)
)
;
size_t
targetCheckpoint
=
gActiveChild
-
>
RewindTargetCheckpoint
(
)
;
if
(
targetCheckpoint
=
=
CheckpointId
:
:
Invalid
)
{
SendMessageToUIProcess
(
"
HitRecordingBeginning
"
)
;
return
;
}
ChildProcessInfo
*
targetChild
=
ReplayingChildResponsibleForSavingCheckpoint
(
targetCheckpoint
)
;
MOZ_RELEASE_ASSERT
(
targetChild
!
=
gActiveChild
)
;
targetChild
-
>
WaitUntil
(
[
=
]
(
)
{
return
targetChild
-
>
HasSavedCheckpoint
(
targetCheckpoint
)
&
&
targetChild
-
>
IsPaused
(
)
;
}
)
;
SwitchActiveChild
(
targetChild
)
;
}
if
(
aForward
)
{
if
(
gActiveChild
-
>
IsPausedAtRecordingEndpoint
(
)
)
{
MOZ_RELEASE_ASSERT
(
!
gActiveChild
-
>
IsRecording
(
)
)
;
if
(
!
gRecordingChild
)
{
MarkActiveChildExplicitPause
(
)
;
SendMessageToUIProcess
(
"
HitRecordingEndpoint
"
)
;
return
;
}
SwitchActiveChild
(
gRecordingChild
)
;
}
ClearIfSavedNonMajorCheckpoint
(
gActiveChild
gActiveChild
-
>
LastCheckpoint
(
)
+
1
)
;
PokeChildren
(
)
;
}
gActiveChild
-
>
SendMessage
(
ResumeMessage
(
aForward
)
)
;
}
static
void
HookPause
(
)
{
MaybeCreateCheckpointInRecordingChild
(
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
gChildExecuteForward
=
false
;
gChildExecuteBackward
=
false
;
MarkActiveChildExplicitPause
(
)
;
}
static
void
ResumeForwardOrBackward
(
)
{
MOZ_RELEASE_ASSERT
(
!
gChildExecuteForward
|
|
!
gChildExecuteBackward
)
;
if
(
gResumeForwardOrBackward
&
&
(
gChildExecuteForward
|
|
gChildExecuteBackward
)
)
{
HookResume
(
gChildExecuteForward
)
;
}
}
static
void
RecvHitCheckpoint
(
const
HitCheckpointMessage
&
aMsg
)
{
UpdateCheckpointTimes
(
aMsg
)
;
if
(
MainThreadIsWaitingForIPDLReply
(
)
)
{
MOZ_RELEASE_ASSERT
(
gChildExecuteForward
)
;
HookResume
(
true
)
;
}
else
if
(
!
gResumeForwardOrBackward
)
{
gResumeForwardOrBackward
=
true
;
gMainThreadMessageLoop
-
>
PostTask
(
NewRunnableFunction
(
"
ResumeForwardOrBackward
"
ResumeForwardOrBackward
)
)
;
}
}
static
void
HitBreakpoint
(
uint32_t
*
aBreakpoints
size_t
aNumBreakpoints
)
{
MarkActiveChildExplicitPause
(
)
;
MOZ_RELEASE_ASSERT
(
!
gResumeForwardOrBackward
)
;
gResumeForwardOrBackward
=
true
;
for
(
size_t
i
=
0
;
i
<
aNumBreakpoints
&
&
gResumeForwardOrBackward
;
i
+
+
)
{
AutoSafeJSContext
cx
;
if
(
!
JS
:
:
replay
:
:
hooks
.
hitBreakpointMiddleman
(
cx
aBreakpoints
[
i
]
)
)
{
Print
(
"
Warning
:
hitBreakpoint
hook
threw
an
exception
.
\
n
"
)
;
}
}
if
(
gResumeForwardOrBackward
)
{
ResumeForwardOrBackward
(
)
;
}
delete
[
]
aBreakpoints
;
}
static
void
RecvHitBreakpoint
(
const
HitBreakpointMessage
&
aMsg
)
{
uint32_t
*
breakpoints
=
new
uint32_t
[
aMsg
.
NumBreakpoints
(
)
]
;
PodCopy
(
breakpoints
aMsg
.
Breakpoints
(
)
aMsg
.
NumBreakpoints
(
)
)
;
gMainThreadMessageLoop
-
>
PostTask
(
NewRunnableFunction
(
"
HitBreakpoint
"
HitBreakpoint
breakpoints
aMsg
.
NumBreakpoints
(
)
)
)
;
}
static
void
InitDebuggerHooks
(
)
{
JS
:
:
replay
:
:
hooks
.
debugRequestMiddleman
=
HookDebuggerRequest
;
JS
:
:
replay
:
:
hooks
.
setBreakpointMiddleman
=
HookSetBreakpoint
;
JS
:
:
replay
:
:
hooks
.
resumeMiddleman
=
HookResume
;
JS
:
:
replay
:
:
hooks
.
pauseMiddleman
=
HookPause
;
JS
:
:
replay
:
:
hooks
.
canRewindMiddleman
=
CanRewind
;
}
}
}
}
