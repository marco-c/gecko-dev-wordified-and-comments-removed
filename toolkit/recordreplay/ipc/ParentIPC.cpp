#
include
"
ParentInternal
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
ipc
/
Channel
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessMessageManager
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
Monitor
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ProcessRedirect
.
h
"
#
include
<
algorithm
>
using
std
:
:
min
;
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
const
char
*
gSaveAllRecordingsDirectory
=
nullptr
;
void
InitializeUIProcess
(
int
aArgc
char
*
*
aArgv
)
{
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
if
(
!
strcmp
(
aArgv
[
i
]
"
-
-
save
-
recordings
"
)
&
&
i
+
1
<
aArgc
)
{
gSaveAllRecordingsDirectory
=
strdup
(
aArgv
[
i
+
1
]
)
;
}
}
}
const
char
*
SaveAllRecordingsDirectory
(
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
gSaveAllRecordingsDirectory
;
}
static
const
double
FlushSeconds
=
.
5
;
static
const
double
MajorCheckpointSeconds
=
2
;
static
ChildProcessInfo
*
gActiveChild
;
static
ChildProcessInfo
*
gRecordingChild
;
static
ChildProcessInfo
*
gFirstReplayingChild
;
static
ChildProcessInfo
*
gSecondReplayingChild
;
void
Shutdown
(
)
{
delete
gRecordingChild
;
delete
gFirstReplayingChild
;
delete
gSecondReplayingChild
;
_exit
(
0
)
;
}
bool
IsMiddlemanWithRecordingChild
(
)
{
return
IsMiddleman
(
)
&
&
gRecordingChild
;
}
static
ChildProcessInfo
*
OtherReplayingChild
(
ChildProcessInfo
*
aChild
)
{
MOZ_RELEASE_ASSERT
(
!
aChild
-
>
IsRecording
(
)
&
&
gFirstReplayingChild
&
&
gSecondReplayingChild
)
;
return
aChild
=
=
gFirstReplayingChild
?
gSecondReplayingChild
:
gFirstReplayingChild
;
}
static
void
ForEachReplayingChild
(
const
std
:
:
function
<
void
(
ChildProcessInfo
*
)
>
&
aCallback
)
{
if
(
gFirstReplayingChild
)
{
aCallback
(
gFirstReplayingChild
)
;
}
if
(
gSecondReplayingChild
)
{
aCallback
(
gSecondReplayingChild
)
;
}
}
static
void
PokeChildren
(
)
{
ForEachReplayingChild
(
[
=
]
(
ChildProcessInfo
*
aChild
)
{
if
(
aChild
-
>
IsPaused
(
)
)
{
aChild
-
>
Role
(
)
-
>
Poke
(
)
;
}
}
)
;
}
static
void
RecvHitCheckpoint
(
const
HitCheckpointMessage
&
aMsg
)
;
static
void
RecvHitBreakpoint
(
const
HitBreakpointMessage
&
aMsg
)
;
static
void
RecvDebuggerResponse
(
const
DebuggerResponseMessage
&
aMsg
)
;
static
void
RecvRecordingFlushed
(
)
;
static
void
RecvAlwaysMarkMajorCheckpoints
(
)
;
static
void
RecvMiddlemanCallRequest
(
const
MiddlemanCallRequestMessage
&
aMsg
)
;
class
ChildRoleActive
final
:
public
ChildRole
{
public
:
ChildRoleActive
(
)
:
ChildRole
(
Active
)
{
}
void
Initialize
(
)
override
{
gActiveChild
=
mProcess
;
mProcess
-
>
SendMessage
(
SetIsActiveMessage
(
true
)
)
;
if
(
mProcess
-
>
LastCheckpoint
(
)
=
=
CheckpointId
:
:
Invalid
)
{
mProcess
-
>
SendMessage
(
ResumeMessage
(
true
)
)
;
}
}
void
OnIncomingMessage
(
const
Message
&
aMsg
)
override
{
switch
(
aMsg
.
mType
)
{
case
MessageType
:
:
Paint
:
MaybeUpdateGraphicsAtPaint
(
(
const
PaintMessage
&
)
aMsg
)
;
break
;
case
MessageType
:
:
HitCheckpoint
:
RecvHitCheckpoint
(
(
const
HitCheckpointMessage
&
)
aMsg
)
;
break
;
case
MessageType
:
:
HitBreakpoint
:
RecvHitBreakpoint
(
(
const
HitBreakpointMessage
&
)
aMsg
)
;
break
;
case
MessageType
:
:
DebuggerResponse
:
RecvDebuggerResponse
(
(
const
DebuggerResponseMessage
&
)
aMsg
)
;
break
;
case
MessageType
:
:
RecordingFlushed
:
RecvRecordingFlushed
(
)
;
break
;
case
MessageType
:
:
AlwaysMarkMajorCheckpoints
:
RecvAlwaysMarkMajorCheckpoints
(
)
;
break
;
case
MessageType
:
:
MiddlemanCallRequest
:
RecvMiddlemanCallRequest
(
(
const
MiddlemanCallRequestMessage
&
)
aMsg
)
;
break
;
case
MessageType
:
:
ResetMiddlemanCalls
:
ResetMiddlemanCalls
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
message
"
)
;
}
}
}
;
bool
ActiveChildIsRecording
(
)
{
return
gActiveChild
-
>
IsRecording
(
)
;
}
ChildProcessInfo
*
ActiveRecordingChild
(
)
{
MOZ_RELEASE_ASSERT
(
ActiveChildIsRecording
(
)
)
;
return
gActiveChild
;
}
static
size_t
gLastRecordingCheckpoint
;
class
ChildRoleStandby
final
:
public
ChildRole
{
public
:
ChildRoleStandby
(
)
:
ChildRole
(
Standby
)
{
}
void
Initialize
(
)
override
{
MOZ_RELEASE_ASSERT
(
mProcess
-
>
IsPausedAtCheckpoint
(
)
)
;
mProcess
-
>
SendMessage
(
SetIsActiveMessage
(
false
)
)
;
Poke
(
)
;
}
void
OnIncomingMessage
(
const
Message
&
aMsg
)
override
{
MOZ_RELEASE_ASSERT
(
aMsg
.
mType
=
=
MessageType
:
:
HitCheckpoint
)
;
Poke
(
)
;
}
void
Poke
(
)
override
;
}
;
class
ChildRoleInert
final
:
public
ChildRole
{
public
:
ChildRoleInert
(
)
:
ChildRole
(
Inert
)
{
}
void
Initialize
(
)
override
{
MOZ_RELEASE_ASSERT
(
mProcess
-
>
IsRecording
(
)
&
&
mProcess
-
>
IsPaused
(
)
)
;
}
void
OnIncomingMessage
(
const
Message
&
aMsg
)
override
{
MOZ_CRASH
(
"
Unexpected
message
from
inert
recording
child
"
)
;
}
}
;
static
size_t
LastMajorCheckpointPreceding
(
ChildProcessInfo
*
aChild
size_t
aId
)
{
size_t
last
=
CheckpointId
:
:
Invalid
;
for
(
size_t
majorCheckpoint
:
aChild
-
>
MajorCheckpoints
(
)
)
{
if
(
majorCheckpoint
>
aId
)
{
break
;
}
last
=
majorCheckpoint
;
}
return
last
;
}
static
ChildProcessInfo
*
ReplayingChildResponsibleForSavingCheckpoint
(
size_t
aId
)
{
MOZ_RELEASE_ASSERT
(
CanRewind
(
)
&
&
gFirstReplayingChild
&
&
gSecondReplayingChild
)
;
size_t
firstMajor
=
LastMajorCheckpointPreceding
(
gFirstReplayingChild
aId
)
;
size_t
secondMajor
=
LastMajorCheckpointPreceding
(
gSecondReplayingChild
aId
)
;
return
(
firstMajor
<
secondMajor
)
?
gSecondReplayingChild
:
gFirstReplayingChild
;
}
static
Maybe
<
size_t
>
ActiveChildTargetCheckpoint
(
)
;
static
void
ClearIfSavedNonMajorCheckpoint
(
ChildProcessInfo
*
aChild
size_t
aCheckpoint
)
{
if
(
aChild
-
>
ShouldSaveCheckpoint
(
aCheckpoint
)
&
&
!
aChild
-
>
IsMajorCheckpoint
(
aCheckpoint
)
&
&
aCheckpoint
!
=
CheckpointId
:
:
First
)
{
aChild
-
>
SendMessage
(
SetSaveCheckpointMessage
(
aCheckpoint
false
)
)
;
}
}
void
ChildRoleStandby
:
:
Poke
(
)
{
MOZ_RELEASE_ASSERT
(
mProcess
-
>
IsPausedAtCheckpoint
(
)
)
;
if
(
mProcess
-
>
PauseNeeded
(
)
)
{
return
;
}
do
{
Maybe
<
size_t
>
targetCheckpoint
=
ActiveChildTargetCheckpoint
(
)
;
if
(
targetCheckpoint
.
isNothing
(
)
)
{
break
;
}
size_t
lastMajorCheckpoint
=
LastMajorCheckpointPreceding
(
mProcess
targetCheckpoint
.
ref
(
)
)
;
if
(
lastMajorCheckpoint
=
=
CheckpointId
:
:
Invalid
)
{
return
;
}
if
(
mProcess
-
>
LastCheckpoint
(
)
<
lastMajorCheckpoint
)
{
ClearIfSavedNonMajorCheckpoint
(
mProcess
mProcess
-
>
LastCheckpoint
(
)
+
1
)
;
mProcess
-
>
SendMessage
(
ResumeMessage
(
true
)
)
;
return
;
}
size_t
otherMajorCheckpoint
=
LastMajorCheckpointPreceding
(
OtherReplayingChild
(
mProcess
)
targetCheckpoint
.
ref
(
)
)
;
if
(
otherMajorCheckpoint
>
lastMajorCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
otherMajorCheckpoint
<
=
targetCheckpoint
.
ref
(
)
)
;
targetCheckpoint
.
ref
(
)
=
otherMajorCheckpoint
-
1
;
}
Maybe
<
size_t
>
missingCheckpoint
;
for
(
size_t
i
=
lastMajorCheckpoint
;
i
<
=
targetCheckpoint
.
ref
(
)
;
i
+
+
)
{
if
(
!
mProcess
-
>
HasSavedCheckpoint
(
i
)
)
{
missingCheckpoint
.
emplace
(
i
)
;
break
;
}
}
if
(
!
missingCheckpoint
.
isSome
(
)
)
{
return
;
}
size_t
restoreTarget
=
missingCheckpoint
.
ref
(
)
-
1
;
MOZ_RELEASE_ASSERT
(
mProcess
-
>
HasSavedCheckpoint
(
restoreTarget
)
)
;
if
(
mProcess
-
>
LastCheckpoint
(
)
!
=
restoreTarget
)
{
mProcess
-
>
SendMessage
(
RestoreCheckpointMessage
(
restoreTarget
)
)
;
return
;
}
if
(
!
mProcess
-
>
ShouldSaveCheckpoint
(
missingCheckpoint
.
ref
(
)
)
)
{
mProcess
-
>
SendMessage
(
SetSaveCheckpointMessage
(
missingCheckpoint
.
ref
(
)
true
)
)
;
}
mProcess
-
>
SendMessage
(
ResumeMessage
(
true
)
)
;
return
;
}
while
(
false
)
;
if
(
(
mProcess
-
>
LastCheckpoint
(
)
<
gActiveChild
-
>
LastCheckpoint
(
)
)
&
&
(
!
gRecordingChild
|
|
mProcess
-
>
LastCheckpoint
(
)
<
gLastRecordingCheckpoint
)
)
{
ClearIfSavedNonMajorCheckpoint
(
mProcess
mProcess
-
>
LastCheckpoint
(
)
+
1
)
;
mProcess
-
>
SendMessage
(
ResumeMessage
(
true
)
)
;
}
}
static
StaticInfallibleVector
<
TimeDuration
>
gCheckpointTimes
;
static
TimeDuration
gTimeSinceLastFlush
;
static
TimeDuration
gTimeSinceLastMajorCheckpoint
;
static
ChildProcessInfo
*
gLastAssignedMajorCheckpoint
;
static
bool
gAlwaysMarkMajorCheckpoints
;
static
void
RecvAlwaysMarkMajorCheckpoints
(
)
{
gAlwaysMarkMajorCheckpoints
=
true
;
}
static
void
AssignMajorCheckpoint
(
ChildProcessInfo
*
aChild
size_t
aId
)
{
PrintSpew
(
"
AssignMajorCheckpoint
:
Process
%
d
Checkpoint
%
d
\
n
"
(
int
)
aChild
-
>
GetId
(
)
(
int
)
aId
)
;
aChild
-
>
AddMajorCheckpoint
(
aId
)
;
if
(
aId
!
=
CheckpointId
:
:
First
)
{
aChild
-
>
WaitUntilPaused
(
)
;
aChild
-
>
SendMessage
(
SetSaveCheckpointMessage
(
aId
true
)
)
;
}
gLastAssignedMajorCheckpoint
=
aChild
;
}
static
void
FlushRecording
(
)
;
static
void
UpdateCheckpointTimes
(
const
HitCheckpointMessage
&
aMsg
)
{
if
(
!
CanRewind
(
)
|
|
(
aMsg
.
mCheckpointId
!
=
gCheckpointTimes
.
length
(
)
+
1
)
)
{
return
;
}
gCheckpointTimes
.
append
(
TimeDuration
:
:
FromMicroseconds
(
aMsg
.
mDurationMicroseconds
)
)
;
if
(
gActiveChild
-
>
IsRecording
(
)
)
{
gTimeSinceLastFlush
+
=
gCheckpointTimes
.
back
(
)
;
if
(
aMsg
.
mCheckpointId
=
=
CheckpointId
:
:
First
|
|
gTimeSinceLastFlush
>
=
TimeDuration
:
:
FromSeconds
(
FlushSeconds
)
)
{
FlushRecording
(
)
;
gTimeSinceLastFlush
=
0
;
}
}
gTimeSinceLastMajorCheckpoint
+
=
gCheckpointTimes
.
back
(
)
;
if
(
gTimeSinceLastMajorCheckpoint
>
=
TimeDuration
:
:
FromSeconds
(
MajorCheckpointSeconds
)
|
|
gAlwaysMarkMajorCheckpoints
)
{
MOZ_RELEASE_ASSERT
(
gLastAssignedMajorCheckpoint
)
;
ChildProcessInfo
*
child
=
OtherReplayingChild
(
gLastAssignedMajorCheckpoint
)
;
AssignMajorCheckpoint
(
child
aMsg
.
mCheckpointId
+
1
)
;
gTimeSinceLastMajorCheckpoint
=
0
;
}
}
static
void
SpawnRecordingChild
(
const
RecordingProcessData
&
aRecordingProcessData
)
{
MOZ_RELEASE_ASSERT
(
!
gRecordingChild
&
&
!
gFirstReplayingChild
&
&
!
gSecondReplayingChild
)
;
gRecordingChild
=
new
ChildProcessInfo
(
MakeUnique
<
ChildRoleActive
>
(
)
Some
(
aRecordingProcessData
)
)
;
}
static
void
SpawnSingleReplayingChild
(
)
{
MOZ_RELEASE_ASSERT
(
!
gRecordingChild
&
&
!
gFirstReplayingChild
&
&
!
gSecondReplayingChild
)
;
gFirstReplayingChild
=
new
ChildProcessInfo
(
MakeUnique
<
ChildRoleActive
>
(
)
Nothing
(
)
)
;
}
static
void
SpawnReplayingChildren
(
)
{
MOZ_RELEASE_ASSERT
(
CanRewind
(
)
&
&
!
gFirstReplayingChild
&
&
!
gSecondReplayingChild
)
;
UniquePtr
<
ChildRole
>
firstRole
;
if
(
gRecordingChild
)
{
firstRole
=
MakeUnique
<
ChildRoleStandby
>
(
)
;
}
else
{
firstRole
=
MakeUnique
<
ChildRoleActive
>
(
)
;
}
gFirstReplayingChild
=
new
ChildProcessInfo
(
std
:
:
move
(
firstRole
)
Nothing
(
)
)
;
gSecondReplayingChild
=
new
ChildProcessInfo
(
MakeUnique
<
ChildRoleStandby
>
(
)
Nothing
(
)
)
;
AssignMajorCheckpoint
(
gSecondReplayingChild
CheckpointId
:
:
First
)
;
}
static
void
SwitchActiveChild
(
ChildProcessInfo
*
aChild
bool
aRecoverPosition
=
true
)
{
MOZ_RELEASE_ASSERT
(
aChild
!
=
gActiveChild
)
;
ChildProcessInfo
*
oldActiveChild
=
gActiveChild
;
aChild
-
>
WaitUntilPaused
(
)
;
if
(
!
aChild
-
>
IsRecording
(
)
)
{
if
(
aRecoverPosition
)
{
aChild
-
>
Recover
(
gActiveChild
)
;
}
else
{
Vector
<
SetBreakpointMessage
*
>
breakpoints
;
gActiveChild
-
>
GetInstalledBreakpoints
(
breakpoints
)
;
for
(
SetBreakpointMessage
*
msg
:
breakpoints
)
{
aChild
-
>
SendMessage
(
*
msg
)
;
}
}
}
aChild
-
>
SetRole
(
MakeUnique
<
ChildRoleActive
>
(
)
)
;
if
(
oldActiveChild
-
>
IsRecording
(
)
)
{
oldActiveChild
-
>
SetRole
(
MakeUnique
<
ChildRoleInert
>
(
)
)
;
}
else
{
oldActiveChild
-
>
RecoverToCheckpoint
(
oldActiveChild
-
>
MostRecentSavedCheckpoint
(
)
)
;
oldActiveChild
-
>
SetRole
(
MakeUnique
<
ChildRoleStandby
>
(
)
)
;
}
}
static
bool
gPreferencesLoaded
;
static
bool
gRewindingEnabled
;
void
PreferencesLoaded
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gPreferencesLoaded
)
;
gPreferencesLoaded
=
true
;
gRewindingEnabled
=
Preferences
:
:
GetBool
(
"
devtools
.
recordreplay
.
enableRewinding
"
)
;
if
(
getenv
(
"
NO_REWIND
"
)
)
{
gRewindingEnabled
=
false
;
}
if
(
gRecordingChild
)
{
if
(
DebuggerRunsInMiddleman
(
)
)
{
gRecordingChild
-
>
SendMessage
(
SetDebuggerRunsInMiddlemanMessage
(
)
)
;
}
}
else
{
if
(
CanRewind
(
)
)
{
SpawnReplayingChildren
(
)
;
}
else
{
SpawnSingleReplayingChild
(
)
;
}
}
}
bool
CanRewind
(
)
{
MOZ_RELEASE_ASSERT
(
gPreferencesLoaded
)
;
return
gRewindingEnabled
;
}
bool
DebuggerRunsInMiddleman
(
)
{
if
(
IsRecordingOrReplaying
(
)
)
{
return
child
:
:
DebuggerRunsInMiddleman
(
)
;
}
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
return
!
gRecordingChild
|
|
CanRewind
(
)
;
}
static
void
FlushRecording
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gActiveChild
-
>
IsRecording
(
)
&
&
gActiveChild
-
>
IsPaused
(
)
)
;
ForEachReplayingChild
(
[
=
]
(
ChildProcessInfo
*
aChild
)
{
aChild
-
>
SetPauseNeeded
(
)
;
aChild
-
>
WaitUntilPaused
(
)
;
}
)
;
gActiveChild
-
>
SendMessage
(
FlushRecordingMessage
(
)
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
gLastRecordingCheckpoint
=
gActiveChild
-
>
LastCheckpoint
(
)
;
static
bool
gHasFlushed
=
false
;
if
(
!
gHasFlushed
&
&
CanRewind
(
)
)
{
SpawnReplayingChildren
(
)
;
}
gHasFlushed
=
true
;
}
static
void
RecvRecordingFlushed
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
ForEachReplayingChild
(
[
=
]
(
ChildProcessInfo
*
aChild
)
{
aChild
-
>
ClearPauseNeeded
(
)
;
}
)
;
}
static
void
MaybeCreateCheckpointInRecordingChild
(
)
{
if
(
gActiveChild
-
>
IsRecording
(
)
&
&
!
gActiveChild
-
>
IsPaused
(
)
)
{
gActiveChild
-
>
SendMessage
(
CreateCheckpointMessage
(
)
)
;
}
}
static
void
SendMessageToUIProcess
(
const
char
*
aMessage
)
{
AutoSafeJSContext
cx
;
auto
*
cpmm
=
dom
:
:
ContentProcessMessageManager
:
:
Get
(
)
;
ErrorResult
err
;
nsAutoString
message
;
message
.
Append
(
NS_ConvertUTF8toUTF16
(
aMessage
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
undefined
(
cx
)
;
cpmm
-
>
SendAsyncMessage
(
cx
message
undefined
nullptr
nullptr
undefined
err
)
;
MOZ_RELEASE_ASSERT
(
!
err
.
Failed
(
)
)
;
err
.
SuppressException
(
)
;
}
static
FileHandle
gRecordingFd
;
static
void
SaveRecordingInternal
(
const
ipc
:
:
FileDescriptor
&
aFile
)
{
MOZ_RELEASE_ASSERT
(
gRecordingChild
)
;
if
(
gRecordingChild
=
=
gActiveChild
)
{
MOZ_RELEASE_ASSERT
(
gRecordingChild
=
=
gActiveChild
)
;
MaybeCreateCheckpointInRecordingChild
(
)
;
gRecordingChild
-
>
WaitUntilPaused
(
)
;
FlushRecording
(
)
;
}
DirectSeekFile
(
gRecordingFd
0
)
;
ipc
:
:
FileDescriptor
:
:
UniquePlatformHandle
writefd
=
aFile
.
ClonePlatformHandle
(
)
;
char
buf
[
4096
]
;
while
(
true
)
{
size_t
n
=
DirectRead
(
gRecordingFd
buf
sizeof
(
buf
)
)
;
if
(
!
n
)
{
break
;
}
DirectWrite
(
writefd
.
get
(
)
buf
n
)
;
}
PrintSpew
(
"
Saved
Recording
Copy
.
\
n
"
)
;
SendMessageToUIProcess
(
"
SaveRecordingFinished
"
)
;
}
void
SaveRecording
(
const
ipc
:
:
FileDescriptor
&
aFile
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
SaveRecordingInternal
(
aFile
)
;
}
else
{
MainThreadMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
SaveRecordingInternal
"
SaveRecordingInternal
aFile
)
)
;
}
}
static
size_t
gLastExplicitPause
;
static
Maybe
<
size_t
>
gTimeWarpTarget
;
static
bool
HasSavedCheckpointsInRange
(
ChildProcessInfo
*
aChild
size_t
aStart
size_t
aEnd
)
{
for
(
size_t
i
=
aStart
;
i
<
=
aEnd
;
i
+
+
)
{
if
(
!
aChild
-
>
HasSavedCheckpoint
(
i
)
)
{
return
false
;
}
}
return
true
;
}
static
void
MarkActiveChildExplicitPause
(
)
{
MOZ_RELEASE_ASSERT
(
gActiveChild
-
>
IsPaused
(
)
)
;
size_t
targetCheckpoint
=
gActiveChild
-
>
RewindTargetCheckpoint
(
)
;
if
(
gActiveChild
-
>
IsRecording
(
)
)
{
FlushRecording
(
)
;
}
else
if
(
CanRewind
(
)
)
{
if
(
gActiveChild
=
=
ReplayingChildResponsibleForSavingCheckpoint
(
targetCheckpoint
)
)
{
size_t
lastMajorCheckpoint
=
LastMajorCheckpointPreceding
(
gActiveChild
targetCheckpoint
)
;
if
(
!
HasSavedCheckpointsInRange
(
gActiveChild
lastMajorCheckpoint
targetCheckpoint
)
)
{
SwitchActiveChild
(
OtherReplayingChild
(
gActiveChild
)
)
;
}
}
}
gLastExplicitPause
=
targetCheckpoint
;
PrintSpew
(
"
MarkActiveChildExplicitPause
%
d
\
n
"
(
int
)
gLastExplicitPause
)
;
PokeChildren
(
)
;
}
static
Maybe
<
size_t
>
ActiveChildTargetCheckpoint
(
)
{
if
(
gTimeWarpTarget
.
isSome
(
)
)
{
return
gTimeWarpTarget
;
}
if
(
gActiveChild
-
>
RewindTargetCheckpoint
(
)
<
=
gLastExplicitPause
)
{
return
Some
(
gActiveChild
-
>
RewindTargetCheckpoint
(
)
)
;
}
return
Nothing
(
)
;
}
void
MaybeSwitchToReplayingChild
(
)
{
if
(
gActiveChild
-
>
IsRecording
(
)
&
&
CanRewind
(
)
)
{
FlushRecording
(
)
;
size_t
checkpoint
=
gActiveChild
-
>
RewindTargetCheckpoint
(
)
;
ChildProcessInfo
*
child
=
OtherReplayingChild
(
ReplayingChildResponsibleForSavingCheckpoint
(
checkpoint
)
)
;
SwitchActiveChild
(
child
)
;
}
}
Maybe
<
double
>
GetRecordingPosition
(
)
{
if
(
gActiveChild
-
>
IsRecording
(
)
)
{
return
Nothing
(
)
;
}
double
fraction
=
(
gActiveChild
-
>
MostRecentCheckpoint
(
)
-
CheckpointId
:
:
First
)
/
(
double
)
(
gCheckpointTimes
.
length
(
)
-
CheckpointId
:
:
First
)
;
return
Some
(
fraction
)
;
}
static
MessageLoop
*
gMainThreadMessageLoop
;
MessageLoop
*
MainThreadMessageLoop
(
)
{
return
gMainThreadMessageLoop
;
}
static
base
:
:
ProcessId
gParentPid
;
base
:
:
ProcessId
ParentProcessId
(
)
{
return
gParentPid
;
}
void
InitializeMiddleman
(
int
aArgc
char
*
aArgv
[
]
base
:
:
ProcessId
aParentPid
const
base
:
:
SharedMemoryHandle
&
aPrefsHandle
const
ipc
:
:
FileDescriptor
&
aPrefMapHandle
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplay
true
)
;
gParentPid
=
aParentPid
;
IntroductionMessage
*
msg
=
IntroductionMessage
:
:
New
(
aParentPid
aArgc
aArgv
)
;
ChildProcessInfo
:
:
SetIntroductionMessage
(
msg
)
;
MOZ_RELEASE_ASSERT
(
gProcessKind
=
=
ProcessKind
:
:
MiddlemanRecording
|
|
gProcessKind
=
=
ProcessKind
:
:
MiddlemanReplaying
)
;
InitializeGraphicsMemory
(
)
;
gMonitor
=
new
Monitor
(
)
;
gMainThreadMessageLoop
=
MessageLoop
:
:
current
(
)
;
if
(
gProcessKind
=
=
ProcessKind
:
:
MiddlemanRecording
)
{
RecordingProcessData
data
(
aPrefsHandle
aPrefMapHandle
)
;
SpawnRecordingChild
(
data
)
;
}
InitializeForwarding
(
)
;
gRecordingFd
=
DirectOpenFile
(
gRecordingFilename
false
)
;
}
static
js
:
:
CharBuffer
*
gResponseBuffer
;
static
void
RecvDebuggerResponse
(
const
DebuggerResponseMessage
&
aMsg
)
{
MOZ_RELEASE_ASSERT
(
gResponseBuffer
&
&
gResponseBuffer
-
>
empty
(
)
)
;
gResponseBuffer
-
>
append
(
aMsg
.
Buffer
(
)
aMsg
.
BufferSize
(
)
)
;
}
void
SendRequest
(
const
js
:
:
CharBuffer
&
aBuffer
js
:
:
CharBuffer
*
aResponse
)
{
MaybeCreateCheckpointInRecordingChild
(
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
MOZ_RELEASE_ASSERT
(
!
gResponseBuffer
)
;
gResponseBuffer
=
aResponse
;
DebuggerRequestMessage
*
msg
=
DebuggerRequestMessage
:
:
New
(
aBuffer
.
begin
(
)
aBuffer
.
length
(
)
)
;
gActiveChild
-
>
SendMessage
(
*
msg
)
;
free
(
msg
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
MOZ_RELEASE_ASSERT
(
gResponseBuffer
=
=
aResponse
)
;
MOZ_RELEASE_ASSERT
(
gResponseBuffer
-
>
length
(
)
!
=
0
)
;
gResponseBuffer
=
nullptr
;
}
void
SetBreakpoint
(
size_t
aId
const
js
:
:
BreakpointPosition
&
aPosition
)
{
MaybeCreateCheckpointInRecordingChild
(
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
gActiveChild
-
>
SendMessage
(
SetBreakpointMessage
(
aId
aPosition
)
)
;
if
(
!
gActiveChild
-
>
IsRecording
(
)
&
&
gRecordingChild
)
{
gRecordingChild
-
>
SendMessage
(
SetBreakpointMessage
(
aId
aPosition
)
)
;
}
}
static
bool
gChildExecuteForward
=
true
;
static
bool
gChildExecuteBackward
=
false
;
static
bool
gResumeForwardOrBackward
=
false
;
static
void
HitForcedPauseBreakpoints
(
bool
aRecordingBoundary
)
;
static
void
MaybeSendRepaintMessage
(
)
{
if
(
InRepaintStressMode
(
)
)
{
MaybeSwitchToReplayingChild
(
)
;
const
char16_t
contents
[
]
=
u
"
{
\
"
type
\
"
:
\
"
repaint
\
"
}
"
;
js
:
:
CharBuffer
request
response
;
request
.
append
(
contents
ArrayLength
(
contents
)
-
1
)
;
SendRequest
(
request
&
response
)
;
AutoSafeJSContext
cx
;
JS
:
:
RootedValue
value
(
cx
)
;
if
(
JS_ParseJSON
(
cx
response
.
begin
(
)
response
.
length
(
)
&
value
)
)
{
MOZ_RELEASE_ASSERT
(
value
.
isObject
(
)
)
;
JS
:
:
RootedObject
obj
(
cx
&
value
.
toObject
(
)
)
;
RootedValue
width
(
cx
)
height
(
cx
)
;
if
(
JS_GetProperty
(
cx
obj
"
width
"
&
width
)
&
&
width
.
isNumber
(
)
&
&
width
.
toNumber
(
)
&
&
JS_GetProperty
(
cx
obj
"
height
"
&
height
)
&
&
height
.
isNumber
(
)
&
&
height
.
toNumber
(
)
)
{
PaintMessage
message
(
CheckpointId
:
:
Invalid
width
.
toNumber
(
)
height
.
toNumber
(
)
)
;
UpdateGraphicsInUIProcess
(
&
message
)
;
}
}
}
}
void
Resume
(
bool
aForward
)
{
gActiveChild
-
>
WaitUntilPaused
(
)
;
MaybeSendRepaintMessage
(
)
;
gResumeForwardOrBackward
=
false
;
gChildExecuteForward
=
aForward
;
gChildExecuteBackward
=
!
aForward
;
if
(
!
aForward
&
&
!
gActiveChild
-
>
HasSavedCheckpoint
(
gActiveChild
-
>
RewindTargetCheckpoint
(
)
)
)
{
size_t
targetCheckpoint
=
gActiveChild
-
>
RewindTargetCheckpoint
(
)
;
if
(
targetCheckpoint
=
=
CheckpointId
:
:
Invalid
)
{
SendMessageToUIProcess
(
"
HitRecordingBeginning
"
)
;
HitForcedPauseBreakpoints
(
true
)
;
return
;
}
ChildProcessInfo
*
targetChild
=
ReplayingChildResponsibleForSavingCheckpoint
(
targetCheckpoint
)
;
MOZ_RELEASE_ASSERT
(
targetChild
!
=
gActiveChild
)
;
targetChild
-
>
WaitUntil
(
[
=
]
(
)
{
return
targetChild
-
>
HasSavedCheckpoint
(
targetCheckpoint
)
&
&
targetChild
-
>
IsPaused
(
)
;
}
)
;
SwitchActiveChild
(
targetChild
)
;
}
if
(
aForward
)
{
if
(
gActiveChild
-
>
IsPausedAtRecordingEndpoint
(
)
)
{
MOZ_RELEASE_ASSERT
(
!
gActiveChild
-
>
IsRecording
(
)
)
;
if
(
!
gRecordingChild
)
{
SendMessageToUIProcess
(
"
HitRecordingEndpoint
"
)
;
HitForcedPauseBreakpoints
(
true
)
;
return
;
}
SwitchActiveChild
(
gRecordingChild
)
;
}
ClearIfSavedNonMajorCheckpoint
(
gActiveChild
gActiveChild
-
>
LastCheckpoint
(
)
+
1
)
;
PokeChildren
(
)
;
}
gActiveChild
-
>
SendMessage
(
ResumeMessage
(
aForward
)
)
;
}
void
TimeWarp
(
const
js
:
:
ExecutionPoint
&
aTarget
)
{
gActiveChild
-
>
WaitUntilPaused
(
)
;
gResumeForwardOrBackward
=
false
;
gChildExecuteForward
=
false
;
gChildExecuteBackward
=
false
;
MOZ_RELEASE_ASSERT
(
gTimeWarpTarget
.
isNothing
(
)
)
;
gTimeWarpTarget
.
emplace
(
aTarget
.
mCheckpoint
)
;
PokeChildren
(
)
;
if
(
!
gActiveChild
-
>
HasSavedCheckpoint
(
aTarget
.
mCheckpoint
)
)
{
ChildProcessInfo
*
targetChild
=
ReplayingChildResponsibleForSavingCheckpoint
(
aTarget
.
mCheckpoint
)
;
if
(
targetChild
=
=
gActiveChild
)
{
SwitchActiveChild
(
OtherReplayingChild
(
gActiveChild
)
)
;
}
targetChild
-
>
WaitUntil
(
[
=
]
(
)
{
return
targetChild
-
>
HasSavedCheckpoint
(
aTarget
.
mCheckpoint
)
&
&
targetChild
-
>
IsPaused
(
)
;
}
)
;
SwitchActiveChild
(
targetChild
false
)
;
}
gTimeWarpTarget
.
reset
(
)
;
if
(
!
gActiveChild
-
>
IsPausedAtCheckpoint
(
)
|
|
gActiveChild
-
>
LastCheckpoint
(
)
!
=
aTarget
.
mCheckpoint
)
{
gActiveChild
-
>
SendMessage
(
RestoreCheckpointMessage
(
aTarget
.
mCheckpoint
)
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
}
gActiveChild
-
>
SendMessage
(
RunToPointMessage
(
aTarget
)
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
SendMessageToUIProcess
(
"
TimeWarpFinished
"
)
;
HitForcedPauseBreakpoints
(
false
)
;
}
void
Pause
(
)
{
MaybeCreateCheckpointInRecordingChild
(
)
;
gActiveChild
-
>
WaitUntilPaused
(
)
;
gChildExecuteForward
=
false
;
gChildExecuteBackward
=
false
;
MarkActiveChildExplicitPause
(
)
;
}
static
void
ResumeForwardOrBackward
(
)
{
MOZ_RELEASE_ASSERT
(
!
gChildExecuteForward
|
|
!
gChildExecuteBackward
)
;
if
(
gResumeForwardOrBackward
&
&
(
gChildExecuteForward
|
|
gChildExecuteBackward
)
)
{
Resume
(
gChildExecuteForward
)
;
}
}
void
ResumeBeforeWaitingForIPDLReply
(
)
{
MOZ_RELEASE_ASSERT
(
gActiveChild
-
>
IsRecording
(
)
)
;
if
(
gActiveChild
-
>
IsPaused
(
)
)
{
MOZ_RELEASE_ASSERT
(
gChildExecuteForward
)
;
Resume
(
true
)
;
}
}
static
void
RecvHitCheckpoint
(
const
HitCheckpointMessage
&
aMsg
)
{
UpdateCheckpointTimes
(
aMsg
)
;
MaybeUpdateGraphicsAtCheckpoint
(
aMsg
.
mCheckpointId
)
;
if
(
MainThreadIsWaitingForIPDLReply
(
)
)
{
MOZ_RELEASE_ASSERT
(
gChildExecuteForward
)
;
Resume
(
true
)
;
}
else
if
(
!
gResumeForwardOrBackward
)
{
gResumeForwardOrBackward
=
true
;
gMainThreadMessageLoop
-
>
PostTask
(
NewRunnableFunction
(
"
ResumeForwardOrBackward
"
ResumeForwardOrBackward
)
)
;
}
}
static
void
HitBreakpoint
(
uint32_t
*
aBreakpoints
size_t
aNumBreakpoints
bool
aRecordingBoundary
)
{
if
(
!
gActiveChild
-
>
IsPaused
(
)
)
{
if
(
aNumBreakpoints
)
{
Print
(
"
Warning
:
Process
resumed
before
breakpoints
were
hit
.
\
n
"
)
;
}
delete
[
]
aBreakpoints
;
return
;
}
MarkActiveChildExplicitPause
(
)
;
gResumeForwardOrBackward
=
true
;
for
(
size_t
i
=
0
;
i
<
aNumBreakpoints
&
&
gResumeForwardOrBackward
;
i
+
+
)
{
AutoSafeJSContext
cx
;
if
(
!
js
:
:
HitBreakpoint
(
cx
aBreakpoints
[
i
]
)
)
{
Print
(
"
Warning
:
hitBreakpoint
hook
threw
an
exception
.
\
n
"
)
;
}
}
if
(
gResumeForwardOrBackward
&
&
!
aRecordingBoundary
)
{
ResumeForwardOrBackward
(
)
;
}
delete
[
]
aBreakpoints
;
}
static
void
RecvHitBreakpoint
(
const
HitBreakpointMessage
&
aMsg
)
{
uint32_t
*
breakpoints
=
new
uint32_t
[
aMsg
.
NumBreakpoints
(
)
]
;
PodCopy
(
breakpoints
aMsg
.
Breakpoints
(
)
aMsg
.
NumBreakpoints
(
)
)
;
gMainThreadMessageLoop
-
>
PostTask
(
NewRunnableFunction
(
"
HitBreakpoint
"
HitBreakpoint
breakpoints
aMsg
.
NumBreakpoints
(
)
false
)
)
;
}
static
void
HitForcedPauseBreakpoints
(
bool
aRecordingBoundary
)
{
Vector
<
uint32_t
>
breakpoints
;
gActiveChild
-
>
GetMatchingInstalledBreakpoints
(
[
=
]
(
js
:
:
BreakpointPosition
:
:
Kind
aKind
)
{
return
aKind
=
=
js
:
:
BreakpointPosition
:
:
ForcedPause
;
}
breakpoints
)
;
if
(
!
breakpoints
.
empty
(
)
)
{
uint32_t
*
newBreakpoints
=
new
uint32_t
[
breakpoints
.
length
(
)
]
;
PodCopy
(
newBreakpoints
breakpoints
.
begin
(
)
breakpoints
.
length
(
)
)
;
gMainThreadMessageLoop
-
>
PostTask
(
NewRunnableFunction
(
"
HitBreakpoint
"
HitBreakpoint
newBreakpoints
breakpoints
.
length
(
)
aRecordingBoundary
)
)
;
}
}
static
void
RecvMiddlemanCallRequest
(
const
MiddlemanCallRequestMessage
&
aMsg
)
{
InfallibleVector
<
char
>
outputData
;
ProcessMiddlemanCall
(
aMsg
.
BinaryData
(
)
aMsg
.
BinaryDataSize
(
)
&
outputData
)
;
MiddlemanCallResponseMessage
*
response
=
MiddlemanCallResponseMessage
:
:
New
(
outputData
.
begin
(
)
outputData
.
length
(
)
)
;
gActiveChild
-
>
SendMessage
(
*
response
)
;
free
(
response
)
;
}
}
}
}
