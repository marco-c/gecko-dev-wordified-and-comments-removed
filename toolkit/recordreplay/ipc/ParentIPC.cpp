#
include
"
ParentInternal
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
ipc
/
Channel
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessMessageManager
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
JSControl
.
h
"
#
include
"
Monitor
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ProcessRedirect
.
h
"
#
include
<
algorithm
>
using
std
:
:
min
;
namespace
mozilla
{
namespace
recordreplay
{
namespace
parent
{
const
char
*
gSaveAllRecordingsDirectory
=
nullptr
;
void
InitializeUIProcess
(
int
aArgc
char
*
*
aArgv
)
{
for
(
int
i
=
0
;
i
<
aArgc
;
i
+
+
)
{
if
(
!
strcmp
(
aArgv
[
i
]
"
-
-
save
-
recordings
"
)
&
&
i
+
1
<
aArgc
)
{
gSaveAllRecordingsDirectory
=
strdup
(
aArgv
[
i
+
1
]
)
;
}
}
}
const
char
*
SaveAllRecordingsDirectory
(
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
gSaveAllRecordingsDirectory
;
}
static
ChildProcessInfo
*
gRecordingChild
;
static
StaticInfallibleVector
<
UniquePtr
<
ChildProcessInfo
>
>
gReplayingChildren
;
static
ChildProcessInfo
*
gActiveChild
;
void
Shutdown
(
)
{
delete
gRecordingChild
;
gReplayingChildren
.
clear
(
)
;
_exit
(
0
)
;
}
bool
IsMiddlemanWithRecordingChild
(
)
{
return
IsMiddleman
(
)
&
&
gRecordingChild
;
}
ChildProcessInfo
*
GetActiveChild
(
)
{
return
gActiveChild
;
}
ChildProcessInfo
*
GetChildProcess
(
size_t
aId
)
{
if
(
gRecordingChild
&
&
gRecordingChild
-
>
GetId
(
)
=
=
aId
)
{
return
gRecordingChild
;
}
for
(
const
auto
&
child
:
gReplayingChildren
)
{
if
(
child
-
>
GetId
(
)
=
=
aId
)
{
return
child
.
get
(
)
;
}
}
return
nullptr
;
}
size_t
SpawnReplayingChild
(
)
{
ChildProcessInfo
*
child
=
new
ChildProcessInfo
(
Nothing
(
)
)
;
gReplayingChildren
.
append
(
child
)
;
return
child
-
>
GetId
(
)
;
}
void
SetActiveChild
(
ChildProcessInfo
*
aChild
)
{
MOZ_RELEASE_ASSERT
(
aChild
-
>
IsPaused
(
)
)
;
if
(
gActiveChild
)
{
MOZ_RELEASE_ASSERT
(
gActiveChild
-
>
IsPaused
(
)
)
;
gActiveChild
-
>
SendMessage
(
SetIsActiveMessage
(
false
)
)
;
}
aChild
-
>
SendMessage
(
SetIsActiveMessage
(
true
)
)
;
gActiveChild
=
aChild
;
}
void
ResumeBeforeWaitingForIPDLReply
(
)
{
MOZ_RELEASE_ASSERT
(
gActiveChild
-
>
IsRecording
(
)
)
;
if
(
gActiveChild
-
>
IsPaused
(
)
)
{
gActiveChild
-
>
SendMessage
(
ResumeMessage
(
true
)
)
;
}
}
static
bool
gChromeRegistered
;
static
bool
gRewindingEnabled
;
void
ChromeRegistered
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
gChromeRegistered
)
{
return
;
}
gChromeRegistered
=
true
;
gRewindingEnabled
=
Preferences
:
:
GetBool
(
"
devtools
.
recordreplay
.
enableRewinding
"
)
;
if
(
getenv
(
"
NO_REWIND
"
)
)
{
gRewindingEnabled
=
false
;
}
Maybe
<
size_t
>
recordingChildId
;
if
(
gRecordingChild
)
{
if
(
DebuggerRunsInMiddleman
(
)
)
{
gRecordingChild
-
>
SendMessage
(
SetDebuggerRunsInMiddlemanMessage
(
)
)
;
}
recordingChildId
.
emplace
(
gRecordingChild
-
>
GetId
(
)
)
;
}
js
:
:
SetupMiddlemanControl
(
recordingChildId
)
;
}
bool
CanRewind
(
)
{
MOZ_RELEASE_ASSERT
(
gChromeRegistered
)
;
return
gRewindingEnabled
;
}
bool
DebuggerRunsInMiddleman
(
)
{
if
(
IsRecordingOrReplaying
(
)
)
{
return
child
:
:
DebuggerRunsInMiddleman
(
)
;
}
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
return
!
gRecordingChild
|
|
CanRewind
(
)
;
}
static
FileHandle
gRecordingFd
;
static
void
SaveRecordingInternal
(
const
ipc
:
:
FileDescriptor
&
aFile
)
{
js
:
:
BeforeSaveRecording
(
)
;
DirectSeekFile
(
gRecordingFd
0
)
;
ipc
:
:
FileDescriptor
:
:
UniquePlatformHandle
writefd
=
aFile
.
ClonePlatformHandle
(
)
;
char
buf
[
4096
]
;
while
(
true
)
{
size_t
n
=
DirectRead
(
gRecordingFd
buf
sizeof
(
buf
)
)
;
if
(
!
n
)
{
break
;
}
DirectWrite
(
writefd
.
get
(
)
buf
n
)
;
}
PrintSpew
(
"
Saved
Recording
Copy
.
\
n
"
)
;
js
:
:
AfterSaveRecording
(
)
;
}
void
SaveRecording
(
const
ipc
:
:
FileDescriptor
&
aFile
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
SaveRecordingInternal
(
aFile
)
;
}
else
{
MainThreadMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
SaveRecordingInternal
"
SaveRecordingInternal
aFile
)
)
;
}
}
static
MessageLoop
*
gMainThreadMessageLoop
;
MessageLoop
*
MainThreadMessageLoop
(
)
{
return
gMainThreadMessageLoop
;
}
static
base
:
:
ProcessId
gParentPid
;
base
:
:
ProcessId
ParentProcessId
(
)
{
return
gParentPid
;
}
void
InitializeMiddleman
(
int
aArgc
char
*
aArgv
[
]
base
:
:
ProcessId
aParentPid
const
base
:
:
SharedMemoryHandle
&
aPrefsHandle
const
ipc
:
:
FileDescriptor
&
aPrefMapHandle
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
RecordReplay
true
)
;
gParentPid
=
aParentPid
;
IntroductionMessage
*
msg
=
IntroductionMessage
:
:
New
(
aParentPid
aArgc
aArgv
)
;
ChildProcessInfo
:
:
SetIntroductionMessage
(
msg
)
;
MOZ_RELEASE_ASSERT
(
gProcessKind
=
=
ProcessKind
:
:
MiddlemanRecording
|
|
gProcessKind
=
=
ProcessKind
:
:
MiddlemanReplaying
)
;
InitializeGraphicsMemory
(
)
;
gMonitor
=
new
Monitor
(
)
;
gMainThreadMessageLoop
=
MessageLoop
:
:
current
(
)
;
if
(
gProcessKind
=
=
ProcessKind
:
:
MiddlemanRecording
)
{
RecordingProcessData
data
(
aPrefsHandle
aPrefMapHandle
)
;
gRecordingChild
=
new
ChildProcessInfo
(
Some
(
data
)
)
;
gActiveChild
=
gRecordingChild
;
}
InitializeForwarding
(
)
;
gRecordingFd
=
DirectOpenFile
(
gRecordingFilename
false
)
;
}
}
}
}
