#
include
"
Thread
.
h
"
#
include
"
ipc
/
ChildIPC
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
ChunkAllocator
.
h
"
#
include
"
ProcessRewind
.
h
"
#
include
"
SpinLock
.
h
"
#
include
"
ThreadSnapshot
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
Monitor
*
Thread
:
:
gMonitor
;
bool
Thread
:
:
CurrentIsMainThread
(
)
{
Thread
*
thread
=
Current
(
)
;
return
thread
&
&
thread
-
>
IsMainThread
(
)
;
}
void
Thread
:
:
BindToCurrent
(
)
{
pthread_t
self
=
DirectCurrentThread
(
)
;
size_t
size
=
pthread_get_stacksize_np
(
self
)
;
uint8_t
*
base
=
(
uint8_t
*
)
pthread_get_stackaddr_np
(
self
)
-
size
;
if
(
IsMainThread
(
)
)
{
mStackBase
=
base
;
mStackSize
=
size
;
}
else
{
MOZ_RELEASE_ASSERT
(
base
=
=
mStackBase
)
;
MOZ_RELEASE_ASSERT
(
size
=
=
mStackSize
)
;
}
if
(
!
IsMainThread
(
)
&
&
!
mMachId
)
{
MOZ_RELEASE_ASSERT
(
this
=
=
Current
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
mMachId
=
RecordReplayValue
(
IsRecording
(
)
?
mach_thread_self
(
)
:
0
)
;
}
}
static
Thread
*
gThreads
;
Thread
*
Thread
:
:
GetById
(
size_t
aId
)
{
MOZ_RELEASE_ASSERT
(
aId
)
;
MOZ_RELEASE_ASSERT
(
aId
<
=
MaxThreadId
)
;
return
&
gThreads
[
aId
]
;
}
Thread
*
Thread
:
:
GetByNativeId
(
NativeThreadId
aNativeId
)
{
for
(
size_t
id
=
MainThreadId
;
id
<
=
MaxThreadId
;
id
+
+
)
{
Thread
*
thread
=
GetById
(
id
)
;
if
(
thread
-
>
mNativeId
=
=
aNativeId
)
{
return
thread
;
}
}
return
nullptr
;
}
static
uint8_t
*
gThreadStackMemory
=
nullptr
;
static
const
size_t
ThreadStackSize
=
2
*
1024
*
1024
;
Thread
*
Thread
:
:
Current
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
!
gThreads
)
{
return
nullptr
;
}
uint8_t
*
ptr
=
(
uint8_t
*
)
&
ptr
;
Thread
*
mainThread
=
GetById
(
MainThreadId
)
;
if
(
MemoryContains
(
mainThread
-
>
mStackBase
mainThread
-
>
mStackSize
ptr
)
)
{
return
mainThread
;
}
if
(
ptr
>
=
gThreadStackMemory
)
{
size_t
id
=
MainThreadId
+
1
+
(
ptr
-
gThreadStackMemory
)
/
ThreadStackSize
;
if
(
id
<
=
MaxThreadId
)
{
return
GetById
(
id
)
;
}
}
return
nullptr
;
}
static
int
gWaitForeverFd
;
void
Thread
:
:
InitializeThreads
(
)
{
FileHandle
writeFd
readFd
;
DirectCreatePipe
(
&
writeFd
&
readFd
)
;
gWaitForeverFd
=
readFd
;
gThreads
=
new
Thread
[
MaxThreadId
+
1
]
;
size_t
nbytes
=
(
MaxThreadId
-
MainThreadId
)
*
ThreadStackSize
;
gThreadStackMemory
=
(
uint8_t
*
)
DirectAllocateMemory
(
nbytes
)
;
for
(
size_t
i
=
MainThreadId
;
i
<
=
MaxThreadId
;
i
+
+
)
{
Thread
*
thread
=
&
gThreads
[
i
]
;
PodZero
(
thread
)
;
new
(
thread
)
Thread
(
)
;
thread
-
>
mId
=
i
;
thread
-
>
mEvents
=
gRecording
-
>
OpenStream
(
StreamName
:
:
Event
i
)
;
if
(
i
=
=
MainThreadId
)
{
thread
-
>
BindToCurrent
(
)
;
thread
-
>
mNativeId
=
DirectCurrentThread
(
)
;
}
else
{
thread
-
>
mStackBase
=
gThreadStackMemory
+
(
i
-
MainThreadId
-
1
)
*
ThreadStackSize
;
thread
-
>
mStackSize
=
ThreadStackSize
-
PageSize
*
2
;
DirectMakeInaccessible
(
thread
-
>
mStackBase
+
ThreadStackSize
-
PageSize
PageSize
)
;
thread
-
>
SetPassThrough
(
true
)
;
}
DirectCreatePipe
(
&
thread
-
>
mNotifyfd
&
thread
-
>
mIdlefd
)
;
}
}
void
Thread
:
:
ThreadMain
(
void
*
aArgument
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
*
thread
=
(
Thread
*
)
aArgument
;
MOZ_ASSERT
(
thread
-
>
mId
>
MainThreadId
)
;
bool
forked
=
!
!
thread
-
>
mMachId
;
thread
-
>
SetPassThrough
(
false
)
;
thread
-
>
BindToCurrent
(
)
;
if
(
forked
)
{
AutoPassThroughThreadEvents
pt
;
RestoreThreadStack
(
thread
-
>
Id
(
)
)
;
}
while
(
true
)
{
while
(
true
)
{
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
thread
-
>
mStart
)
{
break
;
}
}
Wait
(
)
;
}
thread
-
>
mStart
(
thread
-
>
mStartArg
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
thread
-
>
mStart
=
nullptr
;
thread
-
>
mStartArg
=
nullptr
;
gMonitor
-
>
NotifyAll
(
)
;
}
}
void
Thread
:
:
SpawnAllThreads
(
)
{
MOZ_ASSERT
(
AreThreadEventsPassedThrough
(
)
)
;
InitializeThreadSnapshots
(
)
;
gMonitor
=
new
Monitor
(
)
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxThreadId
;
i
+
+
)
{
Thread
*
thread
=
GetById
(
i
)
;
thread
-
>
mNativeId
=
SpawnThread
(
thread
)
;
}
}
void
Thread
:
:
SpawnNonRecordedThread
(
Callback
aStart
void
*
aArgument
)
{
DirectSpawnThread
(
aStart
aArgument
nullptr
0
)
;
}
void
Thread
:
:
RespawnAllThreadsAfterFork
(
)
{
MOZ_ASSERT
(
AreThreadEventsPassedThrough
(
)
)
;
for
(
size_t
id
=
MainThreadId
;
id
<
=
MaxThreadId
;
id
+
+
)
{
Thread
*
thread
=
GetById
(
id
)
;
DirectCloseFile
(
thread
-
>
mNotifyfd
)
;
DirectCloseFile
(
thread
-
>
mIdlefd
)
;
DirectCreatePipe
(
&
thread
-
>
mNotifyfd
&
thread
-
>
mIdlefd
)
;
if
(
!
thread
-
>
IsMainThread
(
)
)
{
SaveThreadStack
(
id
)
;
SpawnThread
(
thread
)
;
}
}
}
NativeThreadId
Thread
:
:
SpawnThread
(
Thread
*
aThread
)
{
return
DirectSpawnThread
(
ThreadMain
aThread
aThread
-
>
mStackBase
aThread
-
>
mStackSize
)
;
}
NativeThreadId
Thread
:
:
StartThread
(
Callback
aStart
void
*
aArgument
bool
aNeedsJoin
)
{
Thread
*
thread
=
Thread
:
:
Current
(
)
;
RecordingEventSection
res
(
thread
)
;
if
(
!
res
.
CanAccessEvents
(
)
)
{
return
0
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
size_t
id
=
0
;
if
(
IsRecording
(
)
)
{
for
(
id
=
MainThreadId
+
1
;
id
<
=
MaxThreadId
;
id
+
+
)
{
Thread
*
targetThread
=
Thread
:
:
GetById
(
id
)
;
if
(
!
targetThread
-
>
mStart
&
&
!
targetThread
-
>
mNeedsJoin
)
{
break
;
}
}
if
(
id
>
MaxThreadId
)
{
child
:
:
ReportFatalError
(
"
Too
many
threads
"
)
;
}
MOZ_RELEASE_ASSERT
(
id
<
=
MaxThreadId
)
;
}
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
CreateThread
)
;
thread
-
>
Events
(
)
.
RecordOrReplayScalar
(
&
id
)
;
Thread
*
targetThread
=
GetById
(
id
)
;
while
(
targetThread
-
>
mStart
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
gMonitor
-
>
Wait
(
)
;
}
targetThread
-
>
mStart
=
aStart
;
targetThread
-
>
mStartArg
=
aArgument
;
targetThread
-
>
mNeedsJoin
=
aNeedsJoin
;
Notify
(
id
)
;
return
targetThread
-
>
mNativeId
;
}
void
Thread
:
:
Join
(
)
{
MOZ_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
EnsureNotDivergedFromRecording
(
Nothing
(
)
)
;
while
(
true
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
!
mStart
)
{
MOZ_RELEASE_ASSERT
(
mNeedsJoin
)
;
mNeedsJoin
=
false
;
break
;
}
gMonitor
-
>
Wait
(
)
;
}
}
void
Thread
:
:
AddOwnedLock
(
NativeLock
*
aNativeLock
)
{
mOwnedLocks
.
append
(
aNativeLock
)
;
}
void
Thread
:
:
RemoveOwnedLock
(
NativeLock
*
aNativeLock
)
{
for
(
int
i
=
mOwnedLocks
.
length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
mOwnedLocks
[
i
]
=
=
aNativeLock
)
{
mOwnedLocks
.
erase
(
&
mOwnedLocks
[
i
]
)
;
return
;
}
}
MOZ_CRASH
(
"
RemoveOwnedLock
"
)
;
}
void
Thread
:
:
ReleaseOrAcquireOwnedLocks
(
OwnedLockState
aState
)
{
MOZ_RELEASE_ASSERT
(
aState
!
=
OwnedLockState
:
:
None
)
;
for
(
NativeLock
*
lock
:
mOwnedLocks
)
{
if
(
aState
=
=
OwnedLockState
:
:
NeedRelease
)
{
DirectUnlockMutex
(
lock
false
)
;
}
else
{
DirectLockMutex
(
lock
false
)
;
}
}
}
void
*
*
Thread
:
:
GetOrCreateStorage
(
uintptr_t
aKey
)
{
for
(
StorageEntry
*
*
pentry
=
&
mStorageEntries
;
*
pentry
;
pentry
=
&
(
*
pentry
)
-
>
mNext
)
{
StorageEntry
*
entry
=
*
pentry
;
if
(
entry
-
>
mKey
=
=
aKey
)
{
*
pentry
=
entry
-
>
mNext
;
entry
-
>
mNext
=
mStorageEntries
;
mStorageEntries
=
entry
;
return
&
entry
-
>
mData
;
}
}
StorageEntry
*
entry
=
(
StorageEntry
*
)
AllocateStorage
(
sizeof
(
StorageEntry
)
)
;
entry
-
>
mKey
=
aKey
;
entry
-
>
mData
=
0
;
entry
-
>
mNext
=
mStorageEntries
;
mStorageEntries
=
entry
;
return
&
entry
-
>
mData
;
}
uint8_t
*
Thread
:
:
AllocateStorage
(
size_t
aSize
)
{
if
(
mStorageCursor
+
aSize
>
=
mStorageLimit
)
{
size_t
nbytes
=
std
:
:
max
(
aSize
PageSize
)
;
mStorageCursor
=
(
uint8_t
*
)
DirectAllocateMemory
(
nbytes
)
;
mStorageLimit
=
mStorageCursor
+
nbytes
;
}
uint8_t
*
res
=
mStorageCursor
;
mStorageCursor
+
=
aSize
;
return
res
;
}
extern
"
C
"
{
MOZ_EXPORT
void
RecordReplayInterface_InternalBeginPassThroughThreadEvents
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
!
gInitializationFailureMessage
)
{
Thread
:
:
Current
(
)
-
>
SetPassThrough
(
true
)
;
}
}
MOZ_EXPORT
void
RecordReplayInterface_InternalEndPassThroughThreadEvents
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
!
gInitializationFailureMessage
)
{
Thread
:
:
Current
(
)
-
>
SetPassThrough
(
false
)
;
}
}
MOZ_EXPORT
bool
RecordReplayInterface_InternalAreThreadEventsPassedThrough
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
gInitializationFailureMessage
)
{
return
true
;
}
Thread
*
thread
=
Thread
:
:
Current
(
)
;
return
!
thread
|
|
thread
-
>
PassThroughEvents
(
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_InternalBeginDisallowThreadEvents
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
:
:
Current
(
)
-
>
BeginDisallowEvents
(
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_InternalEndDisallowThreadEvents
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
:
:
Current
(
)
-
>
EndDisallowEvents
(
)
;
}
MOZ_EXPORT
bool
RecordReplayInterface_InternalAreThreadEventsDisallowed
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
return
thread
&
&
thread
-
>
AreEventsDisallowed
(
)
;
}
}
void
Thread
:
:
WaitForIdleThreads
(
)
{
MOZ_RELEASE_ASSERT
(
CurrentIsMainThread
(
)
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxThreadId
;
i
+
+
)
{
Thread
*
thread
=
GetById
(
i
)
;
thread
-
>
mShouldIdle
=
true
;
thread
-
>
mUnrecordedWaitNotified
=
false
;
}
while
(
true
)
{
bool
done
=
true
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxThreadId
;
i
+
+
)
{
Thread
*
thread
=
GetById
(
i
)
;
if
(
!
thread
-
>
mIdle
)
{
done
=
false
;
if
(
thread
-
>
mUnrecordedWaitCallback
&
&
!
thread
-
>
mUnrecordedWaitNotified
)
{
thread
-
>
mUnrecordedWaitNotified
=
true
;
std
:
:
function
<
void
(
)
>
callback
=
thread
-
>
mUnrecordedWaitCallback
;
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
AutoPassThroughThreadEvents
pt
;
callback
(
)
;
}
done
=
true
;
i
=
MainThreadId
;
}
}
}
if
(
done
)
{
break
;
}
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
WaitNoIdle
(
)
;
}
}
void
Thread
:
:
OperateOnIdleThreadLocks
(
OwnedLockState
aState
)
{
MOZ_RELEASE_ASSERT
(
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
aState
!
=
OwnedLockState
:
:
None
)
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxThreadId
;
i
+
+
)
{
Thread
*
thread
=
GetById
(
i
)
;
if
(
thread
-
>
mOwnedLocks
.
length
(
)
)
{
thread
-
>
mOwnedLockState
=
aState
;
Notify
(
i
)
;
while
(
thread
-
>
mOwnedLockState
!
=
OwnedLockState
:
:
None
)
{
WaitNoIdle
(
)
;
}
}
}
}
void
Thread
:
:
ResumeIdleThreads
(
)
{
MOZ_RELEASE_ASSERT
(
CurrentIsMainThread
(
)
)
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxThreadId
;
i
+
+
)
{
GetById
(
i
)
-
>
mShouldIdle
=
false
;
Notify
(
i
)
;
}
}
void
Thread
:
:
NotifyUnrecordedWait
(
const
std
:
:
function
<
void
(
)
>
&
aNotifyCallback
)
{
if
(
IsMainThread
(
)
)
{
return
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
mUnrecordedWaitCallback
)
{
mUnrecordedWaitNotified
=
false
;
}
else
{
MOZ_RELEASE_ASSERT
(
!
mUnrecordedWaitNotified
)
;
}
mUnrecordedWaitCallback
=
aNotifyCallback
;
if
(
mShouldIdle
)
{
Notify
(
MainThreadId
)
;
}
}
bool
Thread
:
:
MaybeWaitForFork
(
const
std
:
:
function
<
void
(
)
>
&
aReleaseCallback
)
{
MOZ_RELEASE_ASSERT
(
!
PassThroughEvents
(
)
)
;
if
(
IsMainThread
(
)
)
{
return
false
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
!
mShouldIdle
)
{
return
false
;
}
aReleaseCallback
(
)
;
while
(
mShouldIdle
)
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
Wait
(
)
;
}
return
true
;
}
void
Thread
:
:
WaitNoIdle
(
)
{
Thread
*
thread
=
Current
(
)
;
uint8_t
data
=
0
;
size_t
read
=
DirectRead
(
thread
-
>
mIdlefd
&
data
1
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
}
void
Thread
:
:
Wait
(
)
{
Thread
*
thread
=
Current
(
)
;
if
(
thread
-
>
IsMainThread
(
)
)
{
WaitNoIdle
(
)
;
return
;
}
thread
-
>
SetPassThrough
(
true
)
;
int
stackSeparator
=
0
;
if
(
!
SaveThreadState
(
thread
-
>
Id
(
)
&
stackSeparator
)
)
{
Notify
(
MainThreadId
)
;
}
thread
-
>
mIdle
=
true
;
if
(
thread
-
>
mShouldIdle
)
{
Notify
(
MainThreadId
)
;
}
do
{
if
(
thread
-
>
mOwnedLockState
!
=
OwnedLockState
:
:
None
)
{
thread
-
>
ReleaseOrAcquireOwnedLocks
(
thread
-
>
mOwnedLockState
)
;
thread
-
>
mOwnedLockState
=
OwnedLockState
:
:
None
;
Notify
(
MainThreadId
)
;
}
WaitNoIdle
(
)
;
}
while
(
thread
-
>
mShouldIdle
)
;
thread
-
>
mIdle
=
false
;
thread
-
>
SetPassThrough
(
false
)
;
}
void
Thread
:
:
WaitForever
(
)
{
while
(
true
)
{
Wait
(
)
;
}
Unreachable
(
)
;
}
void
Thread
:
:
WaitForeverNoIdle
(
)
{
while
(
true
)
{
uint8_t
data
;
DirectRead
(
gWaitForeverFd
&
data
1
)
;
}
}
void
Thread
:
:
Notify
(
size_t
aId
)
{
uint8_t
data
=
0
;
DirectWrite
(
GetById
(
aId
)
-
>
mNotifyfd
&
data
1
)
;
}
size_t
Thread
:
:
TotalEventProgress
(
)
{
size_t
result
=
0
;
for
(
size_t
id
=
MainThreadId
;
id
<
=
MaxThreadId
;
id
+
+
)
{
Thread
*
thread
=
GetById
(
id
)
;
result
+
=
thread
-
>
mEvents
-
>
StreamPosition
(
)
;
}
return
result
;
}
}
}
