#
include
"
Thread
.
h
"
#
include
"
ipc
/
ChildIPC
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
ChunkAllocator
.
h
"
#
include
"
MemorySnapshot
.
h
"
#
include
"
ProcessRewind
.
h
"
#
include
"
SpinLock
.
h
"
#
include
"
ThreadSnapshot
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
static
MOZ_THREAD_LOCAL
(
Thread
*
)
gTlsThreadKey
;
Monitor
*
Thread
:
:
gMonitor
;
Thread
*
Thread
:
:
Current
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
*
thread
=
gTlsThreadKey
.
get
(
)
;
if
(
!
thread
&
&
IsReplaying
(
)
)
{
WaitForeverNoIdle
(
)
;
}
return
thread
;
}
bool
Thread
:
:
CurrentIsMainThread
(
)
{
Thread
*
thread
=
Current
(
)
;
return
thread
&
&
thread
-
>
IsMainThread
(
)
;
}
void
Thread
:
:
BindToCurrent
(
)
{
MOZ_ASSERT
(
!
mStackBase
)
;
gTlsThreadKey
.
set
(
this
)
;
mNativeId
=
pthread_self
(
)
;
size_t
size
=
pthread_get_stacksize_np
(
mNativeId
)
;
uint8_t
*
base
=
(
uint8_t
*
)
pthread_get_stackaddr_np
(
mNativeId
)
-
size
;
Maybe
<
MonitorAutoLock
>
lock
;
if
(
mId
!
=
MainThreadId
)
{
lock
.
emplace
(
*
gMonitor
)
;
}
mStackBase
=
base
;
mStackSize
=
size
;
if
(
mId
!
=
MainThreadId
)
{
gMonitor
-
>
NotifyAll
(
)
;
}
}
static
Thread
*
gThreads
;
Thread
*
Thread
:
:
GetById
(
size_t
aId
)
{
MOZ_ASSERT
(
aId
)
;
MOZ_ASSERT
(
aId
<
=
MaxThreadId
)
;
return
&
gThreads
[
aId
]
;
}
Thread
*
Thread
:
:
GetByNativeId
(
NativeThreadId
aNativeId
)
{
for
(
size_t
id
=
MainThreadId
;
id
<
=
MaxRecordedThreadId
;
id
+
+
)
{
Thread
*
thread
=
GetById
(
id
)
;
if
(
thread
-
>
mNativeId
=
=
aNativeId
)
{
return
thread
;
}
}
return
nullptr
;
}
Thread
*
Thread
:
:
GetByStackPointer
(
void
*
aSp
)
{
if
(
!
gThreads
)
{
return
nullptr
;
}
for
(
size_t
i
=
MainThreadId
;
i
<
=
MaxThreadId
;
i
+
+
)
{
Thread
*
thread
=
&
gThreads
[
i
]
;
if
(
MemoryContains
(
thread
-
>
mStackBase
thread
-
>
mStackSize
aSp
)
)
{
return
thread
;
}
}
return
nullptr
;
}
void
Thread
:
:
InitializeThreads
(
)
{
gThreads
=
new
Thread
[
MaxThreadId
+
1
]
;
for
(
size_t
i
=
MainThreadId
;
i
<
=
MaxThreadId
;
i
+
+
)
{
Thread
*
thread
=
&
gThreads
[
i
]
;
PodZero
(
thread
)
;
new
(
thread
)
Thread
(
)
;
thread
-
>
mId
=
i
;
if
(
i
<
=
MaxRecordedThreadId
)
{
thread
-
>
mEvents
=
gRecordingFile
-
>
OpenStream
(
StreamName
:
:
Event
i
)
;
thread
-
>
mAsserts
=
gRecordingFile
-
>
OpenStream
(
StreamName
:
:
Assert
i
)
;
}
DirectCreatePipe
(
&
thread
-
>
mNotifyfd
&
thread
-
>
mIdlefd
)
;
}
if
(
!
gTlsThreadKey
.
init
(
)
)
{
MOZ_CRASH
(
)
;
}
}
void
Thread
:
:
WaitUntilInitialized
(
Thread
*
aThread
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
!
aThread
-
>
mStackBase
)
{
gMonitor
-
>
Wait
(
)
;
}
}
void
Thread
:
:
ThreadMain
(
void
*
aArgument
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
*
thread
=
(
Thread
*
)
aArgument
;
MOZ_ASSERT
(
thread
-
>
mId
>
MainThreadId
)
;
thread
-
>
BindToCurrent
(
)
;
while
(
true
)
{
while
(
true
)
{
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
thread
-
>
mStart
)
{
break
;
}
}
Wait
(
)
;
}
{
Maybe
<
AutoPassThroughThreadEvents
>
pt
;
if
(
!
thread
-
>
IsRecordedThread
(
)
)
pt
.
emplace
(
)
;
thread
-
>
mStart
(
thread
-
>
mStartArg
)
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
thread
-
>
mStart
=
nullptr
;
thread
-
>
mStartArg
=
nullptr
;
gMonitor
-
>
NotifyAll
(
)
;
}
}
void
Thread
:
:
SpawnAllThreads
(
)
{
MOZ_ASSERT
(
AreThreadEventsPassedThrough
(
)
)
;
InitializeThreadSnapshots
(
MaxRecordedThreadId
+
1
)
;
gMonitor
=
new
Monitor
(
)
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
SpawnThread
(
GetById
(
i
)
)
;
}
}
static
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gNumNonRecordedThreads
;
Thread
*
Thread
:
:
SpawnNonRecordedThread
(
Callback
aStart
void
*
aArgument
)
{
if
(
IsMiddleman
(
)
|
|
gInitializationFailureMessage
)
{
DirectSpawnThread
(
aStart
aArgument
)
;
return
nullptr
;
}
size_t
id
=
MaxRecordedThreadId
+
+
+
gNumNonRecordedThreads
;
MOZ_RELEASE_ASSERT
(
id
<
=
MaxThreadId
)
;
Thread
*
thread
=
GetById
(
id
)
;
thread
-
>
mStart
=
aStart
;
thread
-
>
mStartArg
=
aArgument
;
SpawnThread
(
thread
)
;
return
thread
;
}
void
Thread
:
:
SpawnThread
(
Thread
*
aThread
)
{
DirectSpawnThread
(
ThreadMain
aThread
)
;
WaitUntilInitialized
(
aThread
)
;
}
NativeThreadId
Thread
:
:
StartThread
(
Callback
aStart
void
*
aArgument
bool
aNeedsJoin
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
MOZ_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_ASSERT
(
!
AreThreadEventsDisallowed
(
)
)
;
EnsureNotDivergedFromRecording
(
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
RecordReplayAssert
(
"
StartThread
"
)
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
size_t
id
=
0
;
if
(
IsRecording
(
)
)
{
for
(
id
=
MainThreadId
+
1
;
id
<
=
MaxRecordedThreadId
;
id
+
+
)
{
Thread
*
targetThread
=
Thread
:
:
GetById
(
id
)
;
if
(
!
targetThread
-
>
mStart
&
&
!
targetThread
-
>
mNeedsJoin
)
{
break
;
}
}
if
(
id
>
=
MaxRecordedThreadId
)
{
child
:
:
ReportFatalError
(
"
Too
many
threads
"
)
;
}
MOZ_RELEASE_ASSERT
(
id
<
=
MaxRecordedThreadId
)
;
}
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
CreateThread
)
;
thread
-
>
Events
(
)
.
RecordOrReplayScalar
(
&
id
)
;
Thread
*
targetThread
=
GetById
(
id
)
;
while
(
targetThread
-
>
mStart
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
gMonitor
-
>
Wait
(
)
;
}
targetThread
-
>
mStart
=
aStart
;
targetThread
-
>
mStartArg
=
aArgument
;
targetThread
-
>
mNeedsJoin
=
aNeedsJoin
;
Notify
(
id
)
;
return
targetThread
-
>
mNativeId
;
}
void
Thread
:
:
Join
(
)
{
MOZ_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
EnsureNotDivergedFromRecording
(
)
;
while
(
true
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
!
mStart
)
{
MOZ_RELEASE_ASSERT
(
mNeedsJoin
)
;
mNeedsJoin
=
false
;
break
;
}
gMonitor
-
>
Wait
(
)
;
}
}
char
*
Thread
:
:
TakeBuffer
(
size_t
aSize
)
{
MOZ_ASSERT
(
mBuffer
!
=
(
char
*
)
0x1
)
;
if
(
aSize
>
mBufferCapacity
)
{
mBufferCapacity
=
aSize
;
mBuffer
=
(
char
*
)
realloc
(
mBuffer
aSize
)
;
}
char
*
buf
=
mBuffer
;
mBuffer
=
(
char
*
)
0x1
;
return
buf
;
}
void
Thread
:
:
RestoreBuffer
(
char
*
aBuf
)
{
MOZ_ASSERT
(
mBuffer
=
=
(
char
*
)
0x1
)
;
mBuffer
=
aBuf
;
}
extern
"
C
"
{
MOZ_EXPORT
void
RecordReplayInterface_InternalBeginPassThroughThreadEvents
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
!
gInitializationFailureMessage
)
{
Thread
:
:
Current
(
)
-
>
SetPassThrough
(
true
)
;
}
}
MOZ_EXPORT
void
RecordReplayInterface_InternalEndPassThroughThreadEvents
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
!
gInitializationFailureMessage
)
{
Thread
:
:
Current
(
)
-
>
SetPassThrough
(
false
)
;
}
}
MOZ_EXPORT
bool
RecordReplayInterface_InternalAreThreadEventsPassedThrough
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
return
!
thread
|
|
thread
-
>
PassThroughEvents
(
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_InternalBeginDisallowThreadEvents
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
:
:
Current
(
)
-
>
BeginDisallowEvents
(
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_InternalEndDisallowThreadEvents
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
:
:
Current
(
)
-
>
EndDisallowEvents
(
)
;
}
MOZ_EXPORT
bool
RecordReplayInterface_InternalAreThreadEventsDisallowed
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
return
thread
&
&
thread
-
>
AreEventsDisallowed
(
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_InternalBeginCaptureEventStacks
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
:
:
Current
(
)
-
>
BeginCaptureEventStacks
(
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_InternalEndCaptureEventStacks
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
:
:
Current
(
)
-
>
EndCaptureEventStacks
(
)
;
}
}
static
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gThreadsShouldIdle
;
static
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gThreadsAreIdle
;
void
Thread
:
:
WaitForIdleThreads
(
)
{
MOZ_RELEASE_ASSERT
(
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gThreadsShouldIdle
)
;
MOZ_RELEASE_ASSERT
(
!
gThreadsAreIdle
)
;
gThreadsShouldIdle
=
true
;
MonitorAutoLock
lock
(
*
gMonitor
)
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
GetById
(
i
)
-
>
mUnrecordedWaitNotified
=
false
;
}
while
(
true
)
{
bool
done
=
true
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
Thread
*
thread
=
GetById
(
i
)
;
if
(
!
thread
-
>
mIdle
)
{
done
=
false
;
if
(
thread
-
>
mUnrecordedWaitCallback
&
&
!
thread
-
>
mUnrecordedWaitNotified
)
{
thread
-
>
mUnrecordedWaitNotified
=
true
;
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
AutoPassThroughThreadEvents
pt
;
thread
-
>
mUnrecordedWaitCallback
(
)
;
}
done
=
true
;
i
=
MainThreadId
;
}
}
}
if
(
done
)
{
break
;
}
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
WaitNoIdle
(
)
;
}
gThreadsAreIdle
=
true
;
}
void
Thread
:
:
ResumeIdleThreads
(
)
{
MOZ_RELEASE_ASSERT
(
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gThreadsAreIdle
)
;
gThreadsAreIdle
=
false
;
MOZ_RELEASE_ASSERT
(
gThreadsShouldIdle
)
;
gThreadsShouldIdle
=
false
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
Notify
(
i
)
;
}
}
void
Thread
:
:
NotifyUnrecordedWait
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
mUnrecordedWaitCallback
)
{
mUnrecordedWaitNotified
=
false
;
}
else
{
MOZ_RELEASE_ASSERT
(
!
mUnrecordedWaitNotified
)
;
}
mUnrecordedWaitCallback
=
aCallback
;
if
(
gThreadsShouldIdle
)
{
Notify
(
MainThreadId
)
;
}
}
void
Thread
:
:
MaybeWaitForCheckpointSave
(
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
while
(
gThreadsShouldIdle
)
{
MonitorAutoUnlock
unlock
(
*
gMonitor
)
;
Wait
(
)
;
}
}
extern
"
C
"
{
MOZ_EXPORT
void
RecordReplayInterface_NotifyUnrecordedWait
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
Thread
:
:
Current
(
)
-
>
NotifyUnrecordedWait
(
aCallback
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_MaybeWaitForCheckpointSave
(
)
{
Thread
:
:
MaybeWaitForCheckpointSave
(
)
;
}
}
void
Thread
:
:
WaitNoIdle
(
)
{
Thread
*
thread
=
Current
(
)
;
uint8_t
data
=
0
;
size_t
read
=
DirectRead
(
thread
-
>
mIdlefd
&
data
1
)
;
MOZ_RELEASE_ASSERT
(
read
=
=
1
)
;
}
void
Thread
:
:
Wait
(
)
{
Thread
*
thread
=
Current
(
)
;
MOZ_ASSERT
(
!
thread
-
>
mIdle
)
;
MOZ_ASSERT
(
thread
-
>
IsRecordedThread
(
)
&
&
!
thread
-
>
PassThroughEvents
(
)
)
;
if
(
thread
-
>
IsMainThread
(
)
)
{
WaitNoIdle
(
)
;
return
;
}
thread
-
>
SetPassThrough
(
true
)
;
int
stackSeparator
=
0
;
if
(
!
SaveThreadState
(
thread
-
>
Id
(
)
&
stackSeparator
)
)
{
Notify
(
MainThreadId
)
;
}
thread
-
>
mIdle
=
true
;
if
(
gThreadsShouldIdle
)
{
Notify
(
MainThreadId
)
;
}
do
{
WaitNoIdle
(
)
;
if
(
ShouldRestoreThreadStack
(
thread
-
>
Id
(
)
)
)
{
RestoreThreadStack
(
thread
-
>
Id
(
)
)
;
Unreachable
(
)
;
}
}
while
(
gThreadsShouldIdle
)
;
thread
-
>
mIdle
=
false
;
thread
-
>
SetPassThrough
(
false
)
;
}
void
Thread
:
:
WaitForever
(
)
{
while
(
true
)
{
Wait
(
)
;
}
Unreachable
(
)
;
}
void
Thread
:
:
WaitForeverNoIdle
(
)
{
FileHandle
writeFd
readFd
;
DirectCreatePipe
(
&
writeFd
&
readFd
)
;
while
(
true
)
{
uint8_t
data
;
DirectRead
(
readFd
&
data
1
)
;
}
}
void
Thread
:
:
Notify
(
size_t
aId
)
{
uint8_t
data
=
0
;
DirectWrite
(
GetById
(
aId
)
-
>
mNotifyfd
&
data
1
)
;
}
}
}
