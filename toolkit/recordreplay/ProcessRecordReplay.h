#
ifndef
mozilla_recordreplay_ProcessRecordReplay_h
#
define
mozilla_recordreplay_ProcessRecordReplay_h
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
RecordReplay
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
namespace
recordreplay
{
#
define
ForEachThreadEvent
(
_Macro
)
\
_Macro
(
CreateThread
)
\
\
/
*
Created
a
recorded
lock
.
*
/
\
_Macro
(
CreateLock
)
\
\
/
*
Acquired
a
recorded
lock
.
*
/
\
_Macro
(
Lock
)
\
\
/
*
Called
RecordReplayValue
.
*
/
\
_Macro
(
Value
)
\
\
/
*
Called
RecordReplayBytes
.
*
/
\
_Macro
(
Bytes
)
\
\
/
*
Called
RecordReplayAssert
or
RecordReplayAssertBytes
.
*
/
\
_Macro
(
Assert
)
_Macro
(
AssertBytes
)
\
\
/
*
Performed
an
atomic
access
.
*
/
\
_Macro
(
AtomicAccess
)
\
\
/
*
Executed
a
nested
callback
(
see
Callback
.
h
)
.
*
/
\
_Macro
(
ExecuteCallback
)
\
\
/
*
Finished
executing
nested
callbacks
in
a
library
API
(
see
\
Callback
.
h
)
.
*
/
\
_Macro
(
CallbacksFinished
)
\
\
/
*
Restoring
a
data
pointer
used
in
a
callback
(
see
Callback
.
h
)
.
*
/
\
_Macro
(
RestoreCallbackData
)
enum
class
ThreadEvent
:
uint32_t
{
#
define
DefineEnum
(
Kind
)
Kind
ForEachThreadEvent
(
DefineEnum
)
#
undef
DefineEnum
CallStart
}
;
const
char
*
ThreadEventName
(
ThreadEvent
aEvent
)
;
class
Recording
;
extern
Recording
*
gRecording
;
extern
bool
gInitialized
;
extern
char
*
gInitializationFailureMessage
;
static
inline
void
AssertEventsAreNotPassedThrough
(
)
{
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
|
|
gInitializationFailureMessage
)
;
}
void
FlushRecording
(
)
;
void
HitEndOfRecording
(
)
;
size_t
RecordingEndpoint
(
)
;
bool
IsMainChild
(
)
;
void
SetMainChild
(
)
;
bool
ReplayingInCloud
(
)
;
extern
ProcessKind
gProcessKind
;
extern
char
*
gRecordingFilename
;
void
BusyWait
(
)
;
static
inline
void
Unreachable
(
)
{
MOZ_CRASH
(
"
Unreachable
"
)
;
}
const
char
*
SymbolNameRaw
(
void
*
aAddress
)
;
static
inline
bool
MemoryContains
(
void
*
aBase
size_t
aSize
void
*
aPtr
size_t
aPtrSize
=
1
)
{
MOZ_ASSERT
(
aPtrSize
)
;
return
(
uint8_t
*
)
aPtr
>
=
(
uint8_t
*
)
aBase
&
&
(
uint8_t
*
)
aPtr
+
aPtrSize
<
=
(
uint8_t
*
)
aBase
+
aSize
;
}
static
inline
bool
MemoryIntersects
(
void
*
aBase0
size_t
aSize0
void
*
aBase1
size_t
aSize1
)
{
MOZ_ASSERT
(
aSize0
&
&
aSize1
)
;
return
MemoryContains
(
aBase0
aSize0
aBase1
)
|
|
MemoryContains
(
aBase0
aSize0
(
uint8_t
*
)
aBase1
+
aSize1
-
1
)
|
|
MemoryContains
(
aBase1
aSize1
aBase0
)
;
}
static
const
size_t
PageSize
=
4096
;
static
inline
uint8_t
*
PageBase
(
void
*
aAddress
)
{
return
(
uint8_t
*
)
aAddress
-
(
(
size_t
)
aAddress
%
PageSize
)
;
}
static
inline
size_t
RoundupSizeToPageBoundary
(
size_t
aSize
)
{
if
(
aSize
%
PageSize
)
{
return
aSize
+
PageSize
-
(
aSize
%
PageSize
)
;
}
return
aSize
;
}
static
inline
bool
TestEnv
(
const
char
*
env
)
{
const
char
*
value
=
getenv
(
env
)
;
return
value
&
&
value
[
0
]
;
}
template
<
typename
Vector
typename
Entry
>
inline
bool
VectorContains
(
const
Vector
&
aVector
const
Entry
&
aEntry
)
{
return
std
:
:
find
(
aVector
.
begin
(
)
aVector
.
end
(
)
aEntry
)
!
=
aVector
.
end
(
)
;
}
template
<
typename
Vector
typename
Entry
>
inline
void
VectorAddOrRemoveEntry
(
Vector
&
aVector
const
Entry
&
aEntry
bool
aAdding
)
{
for
(
Entry
&
existing
:
aVector
)
{
if
(
existing
=
=
aEntry
)
{
MOZ_RELEASE_ASSERT
(
!
aAdding
)
;
aVector
.
erase
(
&
existing
)
;
return
;
}
}
MOZ_RELEASE_ASSERT
(
aAdding
)
;
aVector
.
append
(
aEntry
)
;
}
bool
SpewEnabled
(
)
;
void
InternalPrint
(
const
char
*
aFormat
va_list
aArgs
)
;
#
define
MOZ_MakeRecordReplayPrinter
(
aName
aSpewing
)
\
static
inline
void
aName
(
const
char
*
aFormat
.
.
.
)
{
\
if
(
(
IsRecordingOrReplaying
(
)
|
|
IsMiddleman
(
)
)
&
&
\
(
!
aSpewing
|
|
SpewEnabled
(
)
)
)
{
\
va_list
ap
;
\
va_start
(
ap
aFormat
)
;
\
InternalPrint
(
aFormat
ap
)
;
\
va_end
(
ap
)
;
\
}
\
}
MOZ_MakeRecordReplayPrinter
(
Print
false
)
MOZ_MakeRecordReplayPrinter
(
PrintSpew
true
)
#
undef
MOZ_MakeRecordReplayPrinter
int
GetRecordingPid
(
)
;
void
ResetPid
(
)
;
void
InitializeCurrentTime
(
)
;
double
CurrentTime
(
)
;
#
define
ForEachTimerKind
(
Macro
)
Macro
(
Default
)
enum
class
TimerKind
{
#
define
DefineTimerKind
(
aKind
)
aKind
ForEachTimerKind
(
DefineTimerKind
)
#
undef
DefineTimerKind
Count
}
;
struct
AutoTimer
{
explicit
AutoTimer
(
TimerKind
aKind
)
;
~
AutoTimer
(
)
;
private
:
TimerKind
mKind
;
double
mStart
;
}
;
void
DumpTimers
(
)
;
typedef
size_t
FileHandle
;
void
*
DirectAllocateMemory
(
size_t
aSize
)
;
void
DirectDeallocateMemory
(
void
*
aAddress
size_t
aSize
)
;
void
DirectMakeInaccessible
(
void
*
aAddress
size_t
aSize
)
;
FileHandle
DirectOpenFile
(
const
char
*
aFilename
bool
aWriting
)
;
void
DirectSeekFile
(
FileHandle
aFd
uint64_t
aOffset
)
;
void
DirectCloseFile
(
FileHandle
aFd
)
;
void
DirectDeleteFile
(
const
char
*
aFilename
)
;
void
DirectWrite
(
FileHandle
aFd
const
void
*
aData
size_t
aSize
)
;
void
DirectPrint
(
const
char
*
aString
)
;
size_t
DirectRead
(
FileHandle
aFd
void
*
aData
size_t
aSize
)
;
void
DirectCreatePipe
(
FileHandle
*
aWriteFd
FileHandle
*
aReadFd
)
;
typedef
pthread_t
NativeThreadId
;
NativeThreadId
DirectSpawnThread
(
void
(
*
aFunction
)
(
void
*
)
void
*
aArgument
void
*
aStackBase
size_t
aStackSize
)
;
NativeThreadId
DirectCurrentThread
(
)
;
typedef
pthread_mutex_t
NativeLock
;
void
DirectLockMutex
(
NativeLock
*
aLock
bool
aPassThroughEvents
=
true
)
;
void
DirectUnlockMutex
(
NativeLock
*
aLock
bool
aPassThroughEvents
=
true
)
;
}
}
#
endif
