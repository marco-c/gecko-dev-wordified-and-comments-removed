#
ifndef
mozilla_recordreplay_ProcessRecordReplay_h
#
define
mozilla_recordreplay_ProcessRecordReplay_h
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
RecordReplay
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
namespace
recordreplay
{
#
define
ForEachThreadEvent
(
_Macro
)
\
_Macro
(
CreateThread
)
\
\
/
*
Created
a
recorded
lock
.
*
/
\
_Macro
(
CreateLock
)
\
\
/
*
Acquired
a
recorded
lock
.
*
/
\
_Macro
(
Lock
)
\
\
/
*
Called
RecordReplayValue
.
*
/
\
_Macro
(
Value
)
\
\
/
*
Called
RecordReplayBytes
.
*
/
\
_Macro
(
Bytes
)
\
\
/
*
Called
RecordReplayAssert
or
RecordReplayAssertBytes
.
*
/
\
_Macro
(
Assert
)
_Macro
(
AssertBytes
)
\
\
/
*
Performed
an
atomic
access
.
*
/
\
_Macro
(
AtomicAccess
)
\
\
/
*
Executed
a
nested
callback
(
see
Callback
.
h
)
.
*
/
\
_Macro
(
ExecuteCallback
)
\
\
/
*
Finished
executing
nested
callbacks
in
a
library
API
(
see
\
Callback
.
h
)
.
*
/
\
_Macro
(
CallbacksFinished
)
\
\
/
*
Restoring
a
data
pointer
used
in
a
callback
(
see
Callback
.
h
)
.
*
/
\
_Macro
(
RestoreCallbackData
)
\
\
/
*
Called
RegisterTrigger
.
*
/
\
_Macro
(
RegisterTrigger
)
\
\
/
*
Executed
a
trigger
within
a
call
to
ExecuteTriggers
.
*
/
\
_Macro
(
ExecuteTrigger
)
\
\
/
*
Finished
executing
triggers
within
a
call
to
ExecuteTriggers
.
*
/
\
_Macro
(
ExecuteTriggersFinished
)
enum
class
ThreadEvent
:
uint32_t
{
#
define
DefineEnum
(
Kind
)
Kind
ForEachThreadEvent
(
DefineEnum
)
#
undef
DefineEnum
CallStart
}
;
const
char
*
ThreadEventName
(
ThreadEvent
aEvent
)
;
class
File
;
extern
File
*
gRecordingFile
;
extern
bool
gInitialized
;
extern
char
*
gInitializationFailureMessage
;
static
inline
void
AssertEventsAreNotPassedThrough
(
)
{
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
|
|
gInitializationFailureMessage
)
;
}
void
FlushRecording
(
)
;
void
HitEndOfRecording
(
)
;
bool
HitRecordingEndpoint
(
)
;
enum
class
Directive
{
CrashSoon
=
1
MaybeCrash
=
2
AlwaysSaveTemporaryCheckpoints
=
3
AlwaysMarkMajorCheckpoints
=
4
}
;
extern
ProcessKind
gProcessKind
;
extern
char
*
gRecordingFilename
;
void
BusyWait
(
)
;
static
inline
void
Unreachable
(
)
{
MOZ_CRASH
(
"
Unreachable
"
)
;
}
const
char
*
SymbolNameRaw
(
void
*
aAddress
)
;
static
inline
bool
MemoryContains
(
void
*
aBase
size_t
aSize
void
*
aPtr
size_t
aPtrSize
=
1
)
{
MOZ_ASSERT
(
aPtrSize
)
;
return
(
uint8_t
*
)
aPtr
>
=
(
uint8_t
*
)
aBase
&
&
(
uint8_t
*
)
aPtr
+
aPtrSize
<
=
(
uint8_t
*
)
aBase
+
aSize
;
}
static
inline
bool
MemoryIntersects
(
void
*
aBase0
size_t
aSize0
void
*
aBase1
size_t
aSize1
)
{
MOZ_ASSERT
(
aSize0
&
&
aSize1
)
;
return
MemoryContains
(
aBase0
aSize0
aBase1
)
|
|
MemoryContains
(
aBase0
aSize0
(
uint8_t
*
)
aBase1
+
aSize1
-
1
)
|
|
MemoryContains
(
aBase1
aSize1
aBase0
)
;
}
static
const
size_t
PageSize
=
4096
;
static
inline
uint8_t
*
PageBase
(
void
*
aAddress
)
{
return
(
uint8_t
*
)
aAddress
-
(
(
size_t
)
aAddress
%
PageSize
)
;
}
static
inline
size_t
RoundupSizeToPageBoundary
(
size_t
aSize
)
{
if
(
aSize
%
PageSize
)
{
return
aSize
+
PageSize
-
(
aSize
%
PageSize
)
;
}
return
aSize
;
}
static
inline
bool
TestEnv
(
const
char
*
env
)
{
const
char
*
value
=
getenv
(
env
)
;
return
value
&
&
value
[
0
]
;
}
template
<
typename
Vector
typename
Entry
>
inline
bool
VectorContains
(
const
Vector
&
aVector
const
Entry
&
aEntry
)
{
return
std
:
:
find
(
aVector
.
begin
(
)
aVector
.
end
(
)
aEntry
)
!
=
aVector
.
end
(
)
;
}
template
<
typename
Vector
typename
Entry
>
inline
void
VectorAddOrRemoveEntry
(
Vector
&
aVector
const
Entry
&
aEntry
bool
aAdding
)
{
for
(
Entry
&
existing
:
aVector
)
{
if
(
existing
=
=
aEntry
)
{
MOZ_RELEASE_ASSERT
(
!
aAdding
)
;
aVector
.
erase
(
&
existing
)
;
return
;
}
}
MOZ_RELEASE_ASSERT
(
aAdding
)
;
aVector
.
append
(
aEntry
)
;
}
bool
SpewEnabled
(
)
;
void
InternalPrint
(
const
char
*
aFormat
va_list
aArgs
)
;
#
define
MOZ_MakeRecordReplayPrinter
(
aName
aSpewing
)
\
static
inline
void
aName
(
const
char
*
aFormat
.
.
.
)
{
\
if
(
(
IsRecordingOrReplaying
(
)
|
|
IsMiddleman
(
)
)
&
&
\
(
!
aSpewing
|
|
SpewEnabled
(
)
)
)
{
\
va_list
ap
;
\
va_start
(
ap
aFormat
)
;
\
InternalPrint
(
aFormat
ap
)
;
\
va_end
(
ap
)
;
\
}
\
}
MOZ_MakeRecordReplayPrinter
(
Print
false
)
MOZ_MakeRecordReplayPrinter
(
PrintSpew
true
)
#
undef
MOZ_MakeRecordReplayPrinter
int
GetRecordingPid
(
)
;
void
InitializeCurrentTime
(
)
;
double
CurrentTime
(
)
;
#
define
ForEachTimerKind
(
Macro
)
Macro
(
Default
)
enum
class
TimerKind
{
#
define
DefineTimerKind
(
aKind
)
aKind
ForEachTimerKind
(
DefineTimerKind
)
#
undef
DefineTimerKind
Count
}
;
struct
AutoTimer
{
explicit
AutoTimer
(
TimerKind
aKind
)
;
~
AutoTimer
(
)
;
private
:
TimerKind
mKind
;
double
mStart
;
}
;
void
DumpTimers
(
)
;
enum
class
MemoryKind
{
Tracked
Generic
ThreadSnapshot
TrackedRegions
FreeRegions
DirtyPageSet
SortedDirtyPageSet
PageCopy
Navigation
Count
}
;
void
*
AllocateMemory
(
size_t
aSize
MemoryKind
aKind
)
;
void
DeallocateMemory
(
void
*
aAddress
size_t
aSize
MemoryKind
aKind
)
;
template
<
MemoryKind
Kind
>
class
AllocPolicy
{
public
:
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
aNumElems
)
{
if
(
aNumElems
&
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
{
MOZ_CRASH
(
)
;
}
return
static_cast
<
T
*
>
(
AllocateMemory
(
aNumElems
*
sizeof
(
T
)
Kind
)
)
;
}
template
<
typename
T
>
void
free_
(
T
*
aPtr
size_t
aSize
)
{
DeallocateMemory
(
aPtr
aSize
*
sizeof
(
T
)
Kind
)
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
aPtr
size_t
aOldSize
size_t
aNewSize
)
{
T
*
res
=
maybe_pod_calloc
<
T
>
(
aNewSize
)
;
memcpy
(
res
aPtr
aOldSize
*
sizeof
(
T
)
)
;
free_
<
T
>
(
aPtr
aOldSize
)
;
return
res
;
}
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
aNumElems
)
{
return
maybe_pod_calloc
<
T
>
(
aNumElems
)
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
aNumElems
)
{
return
maybe_pod_malloc
<
T
>
(
aNumElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
aNumElems
)
{
return
maybe_pod_calloc
<
T
>
(
aNumElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
aPtr
size_t
aOldSize
size_t
aNewSize
)
{
return
maybe_pod_realloc
<
T
>
(
aPtr
aOldSize
aNewSize
)
;
}
void
reportAllocOverflow
(
)
const
{
}
MOZ_MUST_USE
bool
checkSimulatedOOM
(
)
const
{
return
true
;
}
}
;
typedef
size_t
FileHandle
;
void
*
DirectAllocateMemory
(
void
*
aAddress
size_t
aSize
)
;
void
DirectDeallocateMemory
(
void
*
aAddress
size_t
aSize
)
;
void
DirectWriteProtectMemory
(
void
*
aAddress
size_t
aSize
bool
aExecutable
bool
aIgnoreFailures
=
false
)
;
void
DirectUnprotectMemory
(
void
*
aAddress
size_t
aSize
bool
aExecutable
bool
aIgnoreFailures
=
false
)
;
FileHandle
DirectOpenFile
(
const
char
*
aFilename
bool
aWriting
)
;
void
DirectSeekFile
(
FileHandle
aFd
uint64_t
aOffset
)
;
void
DirectCloseFile
(
FileHandle
aFd
)
;
void
DirectDeleteFile
(
const
char
*
aFilename
)
;
void
DirectWrite
(
FileHandle
aFd
const
void
*
aData
size_t
aSize
)
;
void
DirectPrint
(
const
char
*
aString
)
;
size_t
DirectRead
(
FileHandle
aFd
void
*
aData
size_t
aSize
)
;
void
DirectCreatePipe
(
FileHandle
*
aWriteFd
FileHandle
*
aReadFd
)
;
void
DirectSpawnThread
(
void
(
*
aFunction
)
(
void
*
)
void
*
aArgument
)
;
}
}
#
endif
