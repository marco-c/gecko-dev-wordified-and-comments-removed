#
ifndef
mozilla_recordreplay_ProcessRecordReplay_h
#
define
mozilla_recordreplay_ProcessRecordReplay_h
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
RecordReplay
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
namespace
recordreplay
{
enum
class
ThreadEvent
:
uint32_t
{
CreateThread
CreateLock
Lock
WaitForCvarUntil
Value
Bytes
ExecuteCallback
CallbacksFinished
RestoreCallbackData
ExecuteTrigger
ExecuteTriggersFinished
GraphicsArgument
GraphicsRval
CallStart
}
;
class
File
;
extern
File
*
gRecordingFile
;
extern
bool
gInitialized
;
extern
char
*
gInitializationFailureMessage
;
#
define
INCLUDE_RECORD_REPLAY_ASSERTIONS
1
void
FlushRecording
(
)
;
void
HitEndOfRecording
(
)
;
bool
HitRecordingEndpoint
(
)
;
enum
class
Directive
{
CrashSoon
=
1
MaybeCrash
=
2
AlwaysSaveTemporaryCheckpoints
=
3
AlwaysMarkMajorCheckpoints
=
4
}
;
extern
ProcessKind
gProcessKind
;
extern
char
*
gRecordingFilename
;
void
BusyWait
(
)
;
static
inline
void
Unreachable
(
)
{
MOZ_CRASH
(
"
Unreachable
"
)
;
}
const
char
*
SymbolNameRaw
(
void
*
aAddress
)
;
static
inline
bool
MemoryContains
(
void
*
aBase
size_t
aSize
void
*
aPtr
size_t
aPtrSize
=
1
)
{
MOZ_ASSERT
(
aPtrSize
)
;
return
(
uint8_t
*
)
aPtr
>
=
(
uint8_t
*
)
aBase
&
&
(
uint8_t
*
)
aPtr
+
aPtrSize
<
=
(
uint8_t
*
)
aBase
+
aSize
;
}
static
inline
bool
MemoryIntersects
(
void
*
aBase0
size_t
aSize0
void
*
aBase1
size_t
aSize1
)
{
MOZ_ASSERT
(
aSize0
&
&
aSize1
)
;
return
MemoryContains
(
aBase0
aSize0
aBase1
)
|
|
MemoryContains
(
aBase0
aSize0
(
uint8_t
*
)
aBase1
+
aSize1
-
1
)
|
|
MemoryContains
(
aBase1
aSize1
aBase0
)
;
}
static
const
size_t
PageSize
=
4096
;
static
inline
uint8_t
*
PageBase
(
void
*
aAddress
)
{
return
(
uint8_t
*
)
aAddress
-
(
(
size_t
)
aAddress
%
PageSize
)
;
}
static
inline
size_t
RoundupSizeToPageBoundary
(
size_t
aSize
)
{
if
(
aSize
%
PageSize
)
{
return
aSize
+
PageSize
-
(
aSize
%
PageSize
)
;
}
return
aSize
;
}
static
inline
bool
TestEnv
(
const
char
*
env
)
{
const
char
*
value
=
getenv
(
env
)
;
return
value
&
&
value
[
0
]
;
}
template
<
typename
Vector
typename
Entry
>
inline
bool
VectorContains
(
const
Vector
&
aVector
const
Entry
&
aEntry
)
{
return
std
:
:
find
(
aVector
.
begin
(
)
aVector
.
end
(
)
aEntry
)
!
=
aVector
.
end
(
)
;
}
template
<
typename
Vector
typename
Entry
>
inline
void
VectorAddOrRemoveEntry
(
Vector
&
aVector
const
Entry
&
aEntry
bool
aAdding
)
{
for
(
Entry
&
existing
:
aVector
)
{
if
(
existing
=
=
aEntry
)
{
MOZ_RELEASE_ASSERT
(
!
aAdding
)
;
aVector
.
erase
(
&
existing
)
;
return
;
}
}
MOZ_RELEASE_ASSERT
(
aAdding
)
;
aVector
.
append
(
aEntry
)
;
}
void
InitializeCurrentTime
(
)
;
double
CurrentTime
(
)
;
#
define
ForEachTimerKind
(
Macro
)
\
Macro
(
Default
)
enum
class
TimerKind
{
#
define
DefineTimerKind
(
aKind
)
aKind
ForEachTimerKind
(
DefineTimerKind
)
#
undef
DefineTimerKind
Count
}
;
struct
AutoTimer
{
explicit
AutoTimer
(
TimerKind
aKind
)
;
~
AutoTimer
(
)
;
private
:
TimerKind
mKind
;
double
mStart
;
}
;
void
DumpTimers
(
)
;
namespace
UntrackedMemoryKind
{
static
const
AllocatedMemoryKind
Generic
=
2
;
static
const
AllocatedMemoryKind
File
=
3
;
static
const
AllocatedMemoryKind
ThreadSnapshot
=
4
;
static
const
AllocatedMemoryKind
TrackedRegions
=
5
;
static
const
AllocatedMemoryKind
FreeRegions
=
6
;
static
const
AllocatedMemoryKind
DirtyPageSet
=
7
;
static
const
AllocatedMemoryKind
SortedDirtyPageSet
=
8
;
static
const
AllocatedMemoryKind
PageCopy
=
9
;
static
const
size_t
Count
=
10
;
}
typedef
size_t
FileHandle
;
void
*
DirectAllocateMemory
(
void
*
aAddress
size_t
aSize
)
;
void
DirectDeallocateMemory
(
void
*
aAddress
size_t
aSize
)
;
void
DirectWriteProtectMemory
(
void
*
aAddress
size_t
aSize
bool
aExecutable
bool
aIgnoreFailures
=
false
)
;
void
DirectUnprotectMemory
(
void
*
aAddress
size_t
aSize
bool
aExecutable
bool
aIgnoreFailures
=
false
)
;
FileHandle
DirectOpenFile
(
const
char
*
aFilename
bool
aWriting
)
;
void
DirectSeekFile
(
FileHandle
aFd
uint64_t
aOffset
)
;
void
DirectCloseFile
(
FileHandle
aFd
)
;
void
DirectDeleteFile
(
const
char
*
aFilename
)
;
void
DirectWrite
(
FileHandle
aFd
const
void
*
aData
size_t
aSize
)
;
void
DirectPrint
(
const
char
*
aString
)
;
size_t
DirectRead
(
FileHandle
aFd
void
*
aData
size_t
aSize
)
;
void
DirectCreatePipe
(
FileHandle
*
aWriteFd
FileHandle
*
aReadFd
)
;
void
DirectSpawnThread
(
void
(
*
aFunction
)
(
void
*
)
void
*
aArgument
)
;
}
}
#
endif
