#
ifndef
mozilla_recordreplay_Assembler_h
#
define
mozilla_recordreplay_Assembler_h
#
include
"
InfallibleVector
.
h
"
#
include
<
utility
>
namespace
mozilla
{
namespace
recordreplay
{
enum
class
Register
{
RAX
RCX
RDX
RBX
RSP
RBP
RSI
RDI
R8
R9
R10
R11
R12
R13
R14
R15
}
;
class
Assembler
{
public
:
Assembler
(
uint8_t
*
aStorage
size_t
aSize
)
;
uint8_t
*
Current
(
)
;
void
Jump
(
void
*
aTarget
)
;
static
const
size_t
JumpBytes
=
17
;
void
PushImmediate
(
void
*
aValue
)
;
static
const
size_t
PushImmediateBytes
=
16
;
void
Return
(
)
;
void
Breakpoint
(
)
;
void
PushRax
(
)
;
void
PopRax
(
)
;
void
PopRegister
(
Register
aRegister
)
;
void
MoveImmediateToRax
(
void
*
aValue
)
;
void
MoveRaxToRegister
(
Register
aRegister
)
;
void
MoveRegisterToRax
(
Register
aRegister
)
;
private
:
void
Advance
(
size_t
aSize
)
;
void
Push16
(
uint16_t
aValue
)
;
inline
size_t
CountBytes
(
)
{
return
0
;
}
template
<
typename
.
.
.
Tail
>
inline
size_t
CountBytes
(
uint8_t
aByte
Tail
.
.
.
aMoreBytes
)
{
return
1
+
CountBytes
(
aMoreBytes
.
.
.
)
;
}
inline
void
CopyBytes
(
uint8_t
*
aIp
)
{
}
template
<
typename
.
.
.
Tail
>
inline
void
CopyBytes
(
uint8_t
*
aIp
uint8_t
aByte
Tail
.
.
.
aMoreBytes
)
{
*
aIp
=
aByte
;
CopyBytes
(
aIp
+
1
aMoreBytes
.
.
.
)
;
}
template
<
typename
.
.
.
ByteList
>
inline
void
NewInstruction
(
ByteList
.
.
.
aBytes
)
{
size_t
numBytes
=
CountBytes
(
aBytes
.
.
.
)
;
uint8_t
*
ip
=
Current
(
)
;
CopyBytes
(
ip
aBytes
.
.
.
)
;
Advance
(
numBytes
)
;
}
uint8_t
*
mCursor
;
uint8_t
*
mCursorEnd
;
}
;
void
UnprotectExecutableMemory
(
uint8_t
*
aAddress
size_t
aSize
)
;
}
}
#
endif
