#
ifndef
mozilla_recordreplay_Assembler_h
#
define
mozilla_recordreplay_Assembler_h
#
include
"
InfallibleVector
.
h
"
#
include
<
utility
>
namespace
mozilla
{
namespace
recordreplay
{
class
Assembler
{
public
:
Assembler
(
)
;
Assembler
(
uint8_t
*
aStorage
size_t
aSize
)
;
~
Assembler
(
)
;
void
NoteOriginalInstruction
(
uint8_t
*
aIp
)
;
uint8_t
*
Current
(
)
;
void
Jump
(
void
*
aTarget
)
;
void
ConditionalJump
(
uint8_t
aCode
void
*
aTarget
)
;
void
CopyInstruction
(
uint8_t
*
aIp
size_t
aSize
)
;
void
PushRax
(
)
;
void
PopRax
(
)
;
void
JumpToRax
(
)
;
void
CallRax
(
)
;
void
LoadRax
(
size_t
aWidth
)
;
void
CompareRaxWithTopOfStack
(
)
;
void
PushRbx
(
)
;
void
PopRbx
(
)
;
void
StoreRbxToRax
(
size_t
aWidth
)
;
void
CompareValueWithRax
(
uint8_t
aValue
size_t
aWidth
)
;
void
MoveImmediateToRax
(
void
*
aValue
)
;
void
MoveRaxToRegister
(
int
aRegister
)
;
void
MoveRegisterToRax
(
int
aRegister
)
;
static
int
NormalizeRegister
(
int
aRegister
)
;
static
bool
CanPatchShortJump
(
uint8_t
*
aIp
void
*
aTarget
)
;
static
void
PatchShortJump
(
uint8_t
*
aIp
void
*
aTarget
)
;
static
void
PatchJumpClobberRax
(
uint8_t
*
aIp
void
*
aTarget
)
;
static
void
PatchMoveImmediateToRax
(
uint8_t
*
aIp
void
*
aValue
)
;
static
void
PatchClobber
(
uint8_t
*
aIp
)
;
private
:
static
void
PatchJump
(
uint8_t
*
aIp
void
*
aTarget
)
;
void
Advance
(
size_t
aSize
)
;
static
const
size_t
MaximumAdvance
=
20
;
inline
size_t
CountBytes
(
)
{
return
0
;
}
template
<
typename
.
.
.
Tail
>
inline
size_t
CountBytes
(
uint8_t
aByte
Tail
.
.
.
aMoreBytes
)
{
return
1
+
CountBytes
(
aMoreBytes
.
.
.
)
;
}
inline
void
CopyBytes
(
uint8_t
*
aIp
)
{
}
template
<
typename
.
.
.
Tail
>
inline
void
CopyBytes
(
uint8_t
*
aIp
uint8_t
aByte
Tail
.
.
.
aMoreBytes
)
{
*
aIp
=
aByte
;
CopyBytes
(
aIp
+
1
aMoreBytes
.
.
.
)
;
}
template
<
typename
.
.
.
ByteList
>
inline
void
NewInstruction
(
ByteList
.
.
.
aBytes
)
{
size_t
numBytes
=
CountBytes
(
aBytes
.
.
.
)
;
MOZ_ASSERT
(
numBytes
<
=
MaximumAdvance
)
;
uint8_t
*
ip
=
Current
(
)
;
CopyBytes
(
ip
aBytes
.
.
.
)
;
Advance
(
numBytes
)
;
}
uint8_t
*
mCursor
;
uint8_t
*
mCursorEnd
;
bool
mCanAllocateStorage
;
InfallibleVector
<
std
:
:
pair
<
uint8_t
*
uint8_t
*
>
>
mCopiedInstructions
;
InfallibleVector
<
std
:
:
pair
<
uint8_t
*
uint8_t
*
>
>
mJumps
;
}
;
static
const
size_t
ShortJumpBytes
=
2
;
static
const
size_t
JumpBytesClobberRax
=
12
;
static
const
size_t
MaximumInstructionLength
=
15
;
void
UnprotectExecutableMemory
(
uint8_t
*
aAddress
size_t
aSize
)
;
}
}
#
endif
