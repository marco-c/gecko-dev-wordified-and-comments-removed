#
include
"
Lock
.
h
"
#
include
"
ChunkAllocator
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
SpinLock
.
h
"
#
include
"
Thread
.
h
"
#
include
<
unordered_map
>
namespace
mozilla
{
namespace
recordreplay
{
static
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gNumLocks
;
struct
LockAcquires
{
Stream
*
mAcquires
;
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mNextOwner
;
static
const
size_t
NoNextOwner
=
0
;
void
ReadAndNotifyNextOwner
(
Thread
*
aCurrentThread
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
if
(
mAcquires
-
>
AtEnd
(
)
)
{
mNextOwner
=
NoNextOwner
;
}
else
{
mNextOwner
=
mAcquires
-
>
ReadScalar
(
)
;
if
(
mNextOwner
!
=
aCurrentThread
-
>
Id
(
)
)
{
Thread
:
:
Notify
(
mNextOwner
)
;
}
}
}
}
;
static
ChunkAllocator
<
LockAcquires
>
gLockAcquires
;
typedef
std
:
:
unordered_map
<
void
*
Lock
*
>
LockMap
;
static
LockMap
*
gLocks
;
static
ReadWriteSpinLock
gLocksLock
;
static
Lock
*
CreateNewLock
(
Thread
*
aThread
size_t
aId
)
{
LockAcquires
*
info
=
gLockAcquires
.
Create
(
aId
)
;
info
-
>
mAcquires
=
gRecordingFile
-
>
OpenStream
(
StreamName
:
:
Lock
aId
)
;
if
(
IsReplaying
(
)
)
{
info
-
>
ReadAndNotifyNextOwner
(
aThread
)
;
}
return
new
Lock
(
aId
)
;
}
void
Lock
:
:
New
(
void
*
aNativeLock
)
{
Thread
*
thread
=
Thread
:
:
Current
(
)
;
RecordingEventSection
res
(
thread
)
;
if
(
!
res
.
CanAccessEvents
(
)
)
{
Destroy
(
aNativeLock
)
;
return
;
}
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
CreateLock
)
;
size_t
id
;
if
(
IsRecording
(
)
)
{
id
=
gNumLocks
+
+
;
}
thread
-
>
Events
(
)
.
RecordOrReplayScalar
(
&
id
)
;
Lock
*
lock
=
CreateNewLock
(
thread
id
)
;
Destroy
(
aNativeLock
)
;
AutoWriteSpinLock
ex
(
gLocksLock
)
;
thread
-
>
BeginDisallowEvents
(
)
;
if
(
!
gLocks
)
{
gLocks
=
new
LockMap
(
)
;
}
gLocks
-
>
insert
(
LockMap
:
:
value_type
(
aNativeLock
lock
)
)
;
thread
-
>
EndDisallowEvents
(
)
;
}
void
Lock
:
:
Destroy
(
void
*
aNativeLock
)
{
Lock
*
lock
=
nullptr
;
{
AutoWriteSpinLock
ex
(
gLocksLock
)
;
if
(
gLocks
)
{
LockMap
:
:
iterator
iter
=
gLocks
-
>
find
(
aNativeLock
)
;
if
(
iter
!
=
gLocks
-
>
end
(
)
)
{
lock
=
iter
-
>
second
;
gLocks
-
>
erase
(
iter
)
;
}
}
}
delete
lock
;
}
Lock
*
Lock
:
:
Find
(
void
*
aNativeLock
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Maybe
<
AutoReadSpinLock
>
ex
;
ex
.
emplace
(
gLocksLock
)
;
if
(
gLocks
)
{
LockMap
:
:
iterator
iter
=
gLocks
-
>
find
(
aNativeLock
)
;
if
(
iter
!
=
gLocks
-
>
end
(
)
)
{
Lock
*
lock
=
iter
-
>
second
;
if
(
AreThreadEventsPassedThrough
(
)
)
{
return
nullptr
;
}
if
(
HasDivergedFromRecording
(
)
)
{
if
(
lock
-
>
mOwner
&
&
Thread
:
:
GetById
(
lock
-
>
mOwner
)
-
>
ShouldIdle
(
)
)
{
ex
.
reset
(
)
;
EnsureNotDivergedFromRecording
(
)
;
Unreachable
(
)
;
}
return
nullptr
;
}
return
lock
;
}
}
return
nullptr
;
}
void
Lock
:
:
Enter
(
)
{
Thread
*
thread
=
Thread
:
:
Current
(
)
;
RecordingEventSection
res
(
thread
)
;
if
(
!
res
.
CanAccessEvents
(
)
)
{
return
;
}
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
Lock
)
;
thread
-
>
Events
(
)
.
CheckInput
(
mId
)
;
LockAcquires
*
acquires
=
gLockAcquires
.
Get
(
mId
)
;
if
(
IsRecording
(
)
)
{
acquires
-
>
mAcquires
-
>
WriteScalar
(
thread
-
>
Id
(
)
)
;
}
else
{
while
(
thread
-
>
Id
(
)
!
=
acquires
-
>
mNextOwner
&
&
!
thread
-
>
MaybeDivergeFromRecording
(
)
)
{
Thread
:
:
Wait
(
)
;
}
if
(
!
thread
-
>
HasDivergedFromRecording
(
)
)
{
mOwner
=
thread
-
>
Id
(
)
;
}
}
}
void
Lock
:
:
Exit
(
)
{
Thread
*
thread
=
Thread
:
:
Current
(
)
;
if
(
IsReplaying
(
)
&
&
!
thread
-
>
HasDivergedFromRecording
(
)
)
{
mOwner
=
0
;
LockAcquires
*
acquires
=
gLockAcquires
.
Get
(
mId
)
;
acquires
-
>
ReadAndNotifyNextOwner
(
thread
)
;
}
}
void
Lock
:
:
LockAquiresUpdated
(
size_t
aLockId
)
{
LockAcquires
*
acquires
=
gLockAcquires
.
MaybeGet
(
aLockId
)
;
if
(
acquires
&
&
acquires
-
>
mAcquires
&
&
acquires
-
>
mNextOwner
=
=
LockAcquires
:
:
NoNextOwner
)
{
acquires
-
>
ReadAndNotifyNextOwner
(
Thread
:
:
Current
(
)
)
;
}
}
static
const
size_t
NumAtomicLocks
=
89
;
static
Lock
*
*
gAtomicLocks
;
static
SpinLock
*
gAtomicLockOwners
;
void
Lock
:
:
InitializeLocks
(
)
{
Thread
*
thread
=
Thread
:
:
Current
(
)
;
gNumLocks
=
1
;
gAtomicLocks
=
new
Lock
*
[
NumAtomicLocks
]
;
for
(
size_t
i
=
0
;
i
<
NumAtomicLocks
;
i
+
+
)
{
gAtomicLocks
[
i
]
=
CreateNewLock
(
thread
gNumLocks
+
+
)
;
}
if
(
IsRecording
(
)
)
{
gAtomicLockOwners
=
new
SpinLock
[
NumAtomicLocks
]
;
PodZero
(
gAtomicLockOwners
NumAtomicLocks
)
;
}
}
extern
"
C
"
{
MOZ_EXPORT
void
RecordReplayInterface_InternalBeginOrderedAtomicAccess
(
const
void
*
aValue
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
size_t
atomicId
;
{
RecordingEventSection
res
(
thread
)
;
if
(
!
res
.
CanAccessEvents
(
)
)
{
return
;
}
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
AtomicAccess
)
;
atomicId
=
IsRecording
(
)
?
(
HashGeneric
(
aValue
)
%
NumAtomicLocks
)
:
0
;
thread
-
>
Events
(
)
.
RecordOrReplayScalar
(
&
atomicId
)
;
MOZ_RELEASE_ASSERT
(
atomicId
<
NumAtomicLocks
)
;
}
if
(
IsRecording
(
)
)
{
gAtomicLockOwners
[
atomicId
]
.
Lock
(
)
;
}
gAtomicLocks
[
atomicId
]
-
>
Enter
(
)
;
MOZ_RELEASE_ASSERT
(
thread
-
>
AtomicLockId
(
)
.
isNothing
(
)
)
;
thread
-
>
AtomicLockId
(
)
.
emplace
(
atomicId
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_InternalEndOrderedAtomicAccess
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
if
(
!
thread
|
|
thread
-
>
PassThroughEvents
(
)
|
|
thread
-
>
HasDivergedFromRecording
(
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
thread
-
>
AtomicLockId
(
)
.
isSome
(
)
)
;
size_t
atomicId
=
thread
-
>
AtomicLockId
(
)
.
ref
(
)
;
thread
-
>
AtomicLockId
(
)
.
reset
(
)
;
if
(
IsRecording
(
)
)
{
gAtomicLockOwners
[
atomicId
]
.
Unlock
(
)
;
}
gAtomicLocks
[
atomicId
]
-
>
Exit
(
)
;
}
}
}
}
