#
include
"
Lock
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
ChunkAllocator
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
SpinLock
.
h
"
#
include
"
Thread
.
h
"
#
include
<
unordered_map
>
namespace
mozilla
{
namespace
recordreplay
{
static
const
size_t
gAtomicLockId
=
1
;
static
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gNumLocks
;
struct
LockAcquires
{
Stream
*
mAcquires
;
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mNextOwner
;
static
const
size_t
NoNextOwner
=
0
;
void
ReadAndNotifyNextOwner
(
Thread
*
aCurrentThread
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
if
(
mAcquires
-
>
AtEnd
(
)
)
{
mNextOwner
=
NoNextOwner
;
}
else
{
mNextOwner
=
mAcquires
-
>
ReadScalar
(
)
;
if
(
mNextOwner
!
=
aCurrentThread
-
>
Id
(
)
)
{
Thread
:
:
Notify
(
mNextOwner
)
;
}
}
}
}
;
static
ChunkAllocator
<
LockAcquires
>
gLockAcquires
;
typedef
std
:
:
unordered_map
<
void
*
Lock
*
>
LockMap
;
static
LockMap
*
gLocks
;
static
ReadWriteSpinLock
gLocksLock
;
void
Lock
:
:
New
(
void
*
aNativeLock
)
{
if
(
AreThreadEventsPassedThrough
(
)
|
|
HasDivergedFromRecording
(
)
)
{
Destroy
(
aNativeLock
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsDisallowed
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
RecordReplayAssert
(
"
CreateLock
"
)
;
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
CreateLock
)
;
size_t
id
;
if
(
IsRecording
(
)
)
{
id
=
gNumLocks
+
+
;
}
thread
-
>
Events
(
)
.
RecordOrReplayScalar
(
&
id
)
;
LockAcquires
*
info
=
gLockAcquires
.
Create
(
id
)
;
info
-
>
mAcquires
=
gRecordingFile
-
>
OpenStream
(
StreamName
:
:
Lock
id
)
;
if
(
IsReplaying
(
)
)
{
info
-
>
ReadAndNotifyNextOwner
(
thread
)
;
}
Destroy
(
aNativeLock
)
;
AutoWriteSpinLock
ex
(
gLocksLock
)
;
thread
-
>
BeginDisallowEvents
(
)
;
if
(
!
gLocks
)
{
gLocks
=
new
LockMap
(
)
;
}
gLocks
-
>
insert
(
LockMap
:
:
value_type
(
aNativeLock
new
Lock
(
id
)
)
)
;
thread
-
>
EndDisallowEvents
(
)
;
}
void
Lock
:
:
Destroy
(
void
*
aNativeLock
)
{
Lock
*
lock
=
nullptr
;
{
AutoWriteSpinLock
ex
(
gLocksLock
)
;
if
(
gLocks
)
{
LockMap
:
:
iterator
iter
=
gLocks
-
>
find
(
aNativeLock
)
;
if
(
iter
!
=
gLocks
-
>
end
(
)
)
{
lock
=
iter
-
>
second
;
gLocks
-
>
erase
(
iter
)
;
}
}
}
delete
lock
;
}
Lock
*
Lock
:
:
Find
(
void
*
aNativeLock
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
AutoReadSpinLock
ex
(
gLocksLock
)
;
if
(
gLocks
)
{
LockMap
:
:
iterator
iter
=
gLocks
-
>
find
(
aNativeLock
)
;
if
(
iter
!
=
gLocks
-
>
end
(
)
)
{
if
(
AreThreadEventsPassedThrough
(
)
|
|
HasDivergedFromRecording
(
)
)
{
return
nullptr
;
}
return
iter
-
>
second
;
}
}
return
nullptr
;
}
void
Lock
:
:
Enter
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
&
&
!
HasDivergedFromRecording
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsDisallowed
(
)
)
;
RecordReplayAssert
(
"
Lock
%
d
"
(
int
)
mId
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
Lock
)
;
thread
-
>
Events
(
)
.
CheckInput
(
mId
)
;
LockAcquires
*
acquires
=
gLockAcquires
.
Get
(
mId
)
;
if
(
IsRecording
(
)
)
{
acquires
-
>
mAcquires
-
>
WriteScalar
(
thread
-
>
Id
(
)
)
;
}
else
{
while
(
thread
-
>
Id
(
)
!
=
acquires
-
>
mNextOwner
)
{
Thread
:
:
Wait
(
)
;
}
aCallback
(
)
;
acquires
-
>
ReadAndNotifyNextOwner
(
thread
)
;
}
}
struct
AtomicLock
:
public
detail
:
:
MutexImpl
{
using
detail
:
:
MutexImpl
:
:
lock
;
using
detail
:
:
MutexImpl
:
:
unlock
;
}
;
static
AtomicLock
*
gAtomicLock
=
nullptr
;
void
Lock
:
:
InitializeLocks
(
)
{
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
gNumLocks
=
gAtomicLockId
;
gAtomicLock
=
new
AtomicLock
(
)
;
MOZ_RELEASE_ASSERT
(
!
IsRecording
(
)
|
|
gNumLocks
=
=
gAtomicLockId
+
1
)
;
}
void
Lock
:
:
LockAquiresUpdated
(
size_t
aLockId
)
{
LockAcquires
*
acquires
=
gLockAcquires
.
MaybeGet
(
aLockId
)
;
if
(
acquires
&
&
acquires
-
>
mAcquires
&
&
acquires
-
>
mNextOwner
=
=
LockAcquires
:
:
NoNextOwner
)
{
acquires
-
>
ReadAndNotifyNextOwner
(
Thread
:
:
Current
(
)
)
;
}
}
extern
"
C
"
{
MOZ_EXPORT
void
RecordReplayInterface_InternalBeginOrderedAtomicAccess
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
!
gInitializationFailureMessage
)
{
gAtomicLock
-
>
lock
(
)
;
}
}
MOZ_EXPORT
void
RecordReplayInterface_InternalEndOrderedAtomicAccess
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
!
gInitializationFailureMessage
)
{
gAtomicLock
-
>
unlock
(
)
;
}
}
}
}
}
