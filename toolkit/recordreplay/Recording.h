#
ifndef
mozilla_recordreplay_Recording_h
#
define
mozilla_recordreplay_Recording_h
#
include
"
InfallibleVector
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
SpinLock
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
RecordReplay
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
struct
StreamChunkLocation
{
uint64_t
mOffset
;
uint32_t
mCompressedSize
;
uint32_t
mDecompressedSize
;
uint32_t
mHash
;
uint64_t
mStreamPos
;
}
;
enum
class
StreamName
{
Event
Lock
Endpoint
LocalReplaySkip
Count
}
;
class
Recording
;
class
RecordingEventSection
;
class
Stream
{
friend
class
Recording
;
friend
class
RecordingEventSection
;
Recording
*
mRecording
;
StreamName
mName
;
size_t
mNameIndex
;
InfallibleVector
<
StreamChunkLocation
>
mChunks
;
UniquePtr
<
char
[
]
>
mBuffer
;
static
const
size_t
BUFFER_MAX
=
1024
*
1024
;
size_t
mBufferSize
;
size_t
mBufferLength
;
size_t
mBufferPos
;
size_t
mStreamPos
;
UniquePtr
<
char
[
]
>
mBallast
;
size_t
mBallastSize
;
UniquePtr
<
char
[
]
>
mInputBallast
;
size_t
mInputBallastSize
;
ThreadEvent
mLastEvent
;
size_t
mChunkIndex
;
bool
mInRecordingEventSection
;
InfallibleVector
<
char
*
>
mEvents
;
Stream
(
Recording
*
aRecording
StreamName
aName
size_t
aNameIndex
)
:
mRecording
(
aRecording
)
mName
(
aName
)
mNameIndex
(
aNameIndex
)
mBuffer
(
nullptr
)
mBufferSize
(
0
)
mBufferLength
(
0
)
mBufferPos
(
0
)
mStreamPos
(
0
)
mBallast
(
nullptr
)
mBallastSize
(
0
)
mInputBallast
(
nullptr
)
mInputBallastSize
(
0
)
mLastEvent
(
(
ThreadEvent
)
0
)
mChunkIndex
(
0
)
mInRecordingEventSection
(
false
)
{
}
public
:
StreamName
Name
(
)
const
{
return
mName
;
}
size_t
NameIndex
(
)
const
{
return
mNameIndex
;
}
void
ReadBytes
(
void
*
aData
size_t
aSize
)
;
void
WriteBytes
(
const
void
*
aData
size_t
aSize
)
;
size_t
ReadScalar
(
)
;
void
WriteScalar
(
size_t
aValue
)
;
bool
AtEnd
(
)
;
inline
void
RecordOrReplayBytes
(
void
*
aData
size_t
aSize
)
{
if
(
IsRecording
(
)
)
{
WriteBytes
(
aData
aSize
)
;
}
else
{
ReadBytes
(
aData
aSize
)
;
}
}
template
<
typename
T
>
inline
void
RecordOrReplayScalar
(
T
*
aPtr
)
{
if
(
IsRecording
(
)
)
{
WriteScalar
(
(
size_t
)
*
aPtr
)
;
}
else
{
*
aPtr
=
(
T
)
ReadScalar
(
)
;
}
}
template
<
typename
T
>
inline
void
RecordOrReplayValue
(
T
*
aPtr
)
{
RecordOrReplayBytes
(
aPtr
sizeof
(
T
)
)
;
}
void
RecordOrReplayThreadEvent
(
ThreadEvent
aEvent
const
char
*
aExtra
=
nullptr
)
;
ThreadEvent
ReplayThreadEvent
(
)
;
void
CheckInput
(
size_t
aValue
)
;
void
CheckInput
(
const
char
*
aValue
)
;
void
CheckInput
(
const
void
*
aData
size_t
aSize
)
;
inline
size_t
StreamPosition
(
)
{
return
mStreamPos
;
}
private
:
enum
ShouldCopy
{
DontCopyExistingData
CopyExistingData
}
;
void
EnsureMemory
(
UniquePtr
<
char
[
]
>
*
aBuf
size_t
*
aSize
size_t
aNeededSize
size_t
aMaxSize
ShouldCopy
aCopy
)
;
void
EnsureInputBallast
(
size_t
aSize
)
;
void
Flush
(
bool
aTakeLock
)
;
const
char
*
ReadInputString
(
)
;
static
size_t
BallastMaxSize
(
)
;
void
PushEvent
(
const
char
*
aEvent
)
;
void
DumpEvents
(
)
;
bool
ReadMismatchedEventData
(
ThreadEvent
aEvent
)
;
}
;
struct
BuildId
{
char
mContents
[
128
]
;
BuildId
(
)
{
PodZero
(
this
)
;
}
bool
Matches
(
const
BuildId
&
aOther
)
{
return
!
memcmp
(
this
&
aOther
sizeof
(
*
this
)
)
;
}
}
;
void
GetCurrentBuildId
(
BuildId
*
aBuildId
)
;
class
Recording
{
public
:
enum
Mode
{
WRITE
READ
}
;
friend
class
Stream
;
friend
class
RecordingEventSection
;
private
:
Mode
mMode
=
READ
;
InfallibleVector
<
uint8_t
>
mContents
;
typedef
InfallibleVector
<
UniquePtr
<
Stream
>
>
StreamVector
;
StreamVector
mStreams
[
(
size_t
)
StreamName
:
:
Count
]
;
SpinLock
mLock
;
ReadWriteSpinLock
mStreamLock
;
public
:
Recording
(
)
;
bool
IsWriting
(
)
const
{
return
mMode
=
=
WRITE
;
}
bool
IsReading
(
)
const
{
return
mMode
=
=
READ
;
}
const
uint8_t
*
Data
(
)
const
{
return
mContents
.
begin
(
)
;
}
size_t
Size
(
)
const
{
return
mContents
.
length
(
)
;
}
Stream
*
OpenStream
(
StreamName
aName
size_t
aNameIndex
)
;
void
NewContents
(
const
uint8_t
*
aContents
size_t
aSize
InfallibleVector
<
Stream
*
>
*
aUpdatedStreams
)
;
void
PreventStreamWrites
(
)
{
mStreamLock
.
WriteLock
(
)
;
}
void
AllowStreamWrites
(
)
{
mStreamLock
.
WriteUnlock
(
)
;
}
void
Flush
(
)
;
static
void
ExtractBuildId
(
const
char
*
aContents
size_t
aLength
BuildId
*
aBuildId
)
;
private
:
StreamChunkLocation
WriteChunk
(
StreamName
aName
size_t
aNameIndex
const
char
*
aStart
size_t
aCompressedSize
size_t
aDecompressedSize
uint64_t
aStreamPos
bool
aTakeLock
)
;
void
ReadChunk
(
char
*
aDest
const
StreamChunkLocation
&
aChunk
)
;
}
;
}
}
#
endif
