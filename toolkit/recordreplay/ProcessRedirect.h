#
ifndef
mozilla_recordreplay_ProcessRedirect_h
#
define
mozilla_recordreplay_ProcessRedirect_h
#
include
"
Assembler
.
h
"
#
include
"
Callback
.
h
"
#
include
"
CallFunction
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ProcessRewind
.
h
"
#
include
"
Thread
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
<
errno
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
struct
CallArguments
{
static
const
size_t
NumStackArguments
=
64
;
protected
:
size_t
arg0
;
size_t
arg1
;
size_t
arg2
;
size_t
arg3
;
size_t
arg4
;
size_t
arg5
;
double
floatarg0
;
double
floatarg1
;
double
floatarg2
;
size_t
rval0
;
size_t
rval1
;
double
floatrval0
;
double
floatrval1
;
size_t
stack
[
NumStackArguments
]
;
public
:
template
<
typename
T
>
T
&
Arg
(
size_t
aIndex
)
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
size_t
)
"
Size
must
match
"
)
;
static_assert
(
IsFloatingPoint
<
T
>
:
:
value
=
=
false
"
Use
FloatArg
"
)
;
MOZ_RELEASE_ASSERT
(
aIndex
<
70
)
;
switch
(
aIndex
)
{
case
0
:
return
(
T
&
)
arg0
;
case
1
:
return
(
T
&
)
arg1
;
case
2
:
return
(
T
&
)
arg2
;
case
3
:
return
(
T
&
)
arg3
;
case
4
:
return
(
T
&
)
arg4
;
case
5
:
return
(
T
&
)
arg5
;
default
:
return
(
T
&
)
stack
[
aIndex
-
6
]
;
}
}
template
<
size_t
Index
typename
T
>
T
&
Arg
(
)
{
return
Arg
<
T
>
(
Index
)
;
}
template
<
size_t
Index
>
double
&
FloatArg
(
)
{
static_assert
(
Index
<
3
"
Bad
index
"
)
;
switch
(
Index
)
{
case
0
:
return
floatarg0
;
case
1
:
return
floatarg1
;
case
2
:
return
floatarg2
;
}
}
template
<
size_t
Offset
>
size_t
*
StackAddress
(
)
{
static_assert
(
Offset
%
sizeof
(
size_t
)
=
=
0
"
Bad
stack
offset
"
)
;
return
&
stack
[
Offset
/
sizeof
(
size_t
)
]
;
}
template
<
typename
T
size_t
Index
=
0
>
T
&
Rval
(
)
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
size_t
)
"
Size
must
match
"
)
;
static_assert
(
IsFloatingPoint
<
T
>
:
:
value
=
=
false
"
Use
FloatRval
instead
"
)
;
static_assert
(
Index
=
=
0
|
|
Index
=
=
1
"
Bad
index
"
)
;
switch
(
Index
)
{
case
0
:
return
(
T
&
)
rval0
;
case
1
:
return
(
T
&
)
rval1
;
}
}
template
<
size_t
Index
=
0
>
double
&
FloatRval
(
)
{
static_assert
(
Index
=
=
0
|
|
Index
=
=
1
"
Bad
index
"
)
;
switch
(
Index
)
{
case
0
:
return
floatrval0
;
case
1
:
return
floatrval1
;
}
}
}
;
typedef
ssize_t
ErrorType
;
typedef
void
(
*
SaveOutputFn
)
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
;
enum
class
PreambleResult
{
Veto
Redirect
IgnoreRedirect
PassThrough
}
;
typedef
PreambleResult
(
*
PreambleFn
)
(
CallArguments
*
aArguments
)
;
struct
ExternalCallContext
;
typedef
void
(
*
ExternalCallFn
)
(
ExternalCallContext
&
aCx
)
;
struct
Redirection
{
const
char
*
mName
;
uint8_t
*
mOriginalFunction
;
uint8_t
*
mRedirectedFunction
;
SaveOutputFn
mSaveOutput
;
PreambleFn
mPreamble
;
ExternalCallFn
mExternalCall
;
PreambleFn
mExternalPreamble
;
}
;
size_t
NumRedirections
(
)
;
Redirection
&
GetRedirection
(
size_t
aCallId
)
;
void
InitializeRedirections
(
)
;
void
ApplyLibraryRedirections
(
void
*
aLibrary
)
;
uint8_t
*
GenerateRedirectStub
(
Assembler
&
aAssembler
size_t
aCallId
bool
aPreserveCallerSaveRegisters
)
;
static
inline
ErrorType
SaveError
(
)
{
return
errno
;
}
static
inline
void
RestoreError
(
ErrorType
aError
)
{
errno
=
aError
;
}
#
define
DEFAULTABI
DefineAllCallFunctions
(
DEFAULTABI
)
static
inline
void
*
OriginalFunction
(
size_t
aCallId
)
{
return
GetRedirection
(
aCallId
)
.
mOriginalFunction
;
}
void
*
OriginalFunction
(
const
char
*
aName
)
;
static
inline
ThreadEvent
CallIdToThreadEvent
(
size_t
aCallId
)
{
return
(
ThreadEvent
)
(
(
uint32_t
)
ThreadEvent
:
:
CallStart
+
aCallId
)
;
}
void
RecordReplayInvokeCall
(
void
*
aFunction
CallArguments
*
aArguments
)
;
struct
CallbackWrapperData
{
void
*
mFunction
;
void
*
mData
;
template
<
typename
FunctionType
>
CallbackWrapperData
(
FunctionType
aFunction
void
*
aData
)
:
mFunction
(
BitwiseCast
<
void
*
>
(
aFunction
)
)
mData
(
aData
)
{
}
}
;
template
<
typename
FunctionType
>
struct
AutoRecordReplayCallback
{
FunctionType
mFunction
;
AutoRecordReplayCallback
(
void
*
*
aDataArgument
size_t
aCallbackId
)
:
mFunction
(
nullptr
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
if
(
IsRecording
(
)
)
{
CallbackWrapperData
*
wrapperData
=
(
CallbackWrapperData
*
)
*
aDataArgument
;
mFunction
=
(
FunctionType
)
wrapperData
-
>
mFunction
;
*
aDataArgument
=
wrapperData
-
>
mData
;
BeginCallback
(
aCallbackId
)
;
}
SaveOrRestoreCallbackData
(
(
void
*
*
)
&
mFunction
)
;
SaveOrRestoreCallbackData
(
aDataArgument
)
;
}
~
AutoRecordReplayCallback
(
)
{
if
(
IsRecording
(
)
)
{
EndCallback
(
)
;
}
}
}
;
#
define
RecordReplayCallback
(
aFunctionType
aDataArgument
)
\
AutoRecordReplayCallback
<
aFunctionType
>
rrc
(
aDataArgument
\
CallbackEvent_
#
#
aFunctionType
)
extern
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gMemoryLeakBytes
;
template
<
typename
T
>
static
inline
T
*
NewLeakyArray
(
size_t
aSize
)
{
gMemoryLeakBytes
+
=
aSize
*
sizeof
(
T
)
;
return
new
T
[
aSize
]
;
}
static
inline
void
RR_CStringRval
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
rval
=
aArguments
-
>
Rval
<
char
*
>
(
)
;
size_t
len
=
(
IsRecording
(
)
&
&
rval
)
?
strlen
(
rval
)
+
1
:
0
;
aEvents
.
RecordOrReplayValue
(
&
len
)
;
if
(
IsReplaying
(
)
)
{
rval
=
len
?
(
char
*
)
malloc
(
len
)
:
nullptr
;
}
if
(
len
)
{
aEvents
.
RecordOrReplayBytes
(
rval
len
)
;
}
}
template
<
size_t
ByteCount
>
static
inline
void
RR_RvalBuffer
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
rval
=
aArguments
-
>
Rval
<
void
*
>
(
)
;
bool
hasRval
=
IsRecording
(
)
&
&
rval
;
aEvents
.
RecordOrReplayValue
(
&
hasRval
)
;
if
(
IsReplaying
(
)
)
{
rval
=
hasRval
?
NewLeakyArray
<
char
>
(
ByteCount
)
:
nullptr
;
}
if
(
hasRval
)
{
aEvents
.
RecordOrReplayBytes
(
rval
ByteCount
)
;
}
}
template
<
size_t
Argument
>
static
inline
void
RR_RvalIsArgument
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
rval
=
aArguments
-
>
Rval
<
size_t
>
(
)
;
auto
&
arg
=
aArguments
-
>
Arg
<
Argument
size_t
>
(
)
;
if
(
IsRecording
(
)
)
{
MOZ_RELEASE_ASSERT
(
rval
=
=
arg
)
;
}
else
{
rval
=
arg
;
}
}
static
inline
void
RR_NoOp
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
}
template
<
SaveOutputFn
Fn0
SaveOutputFn
Fn1
SaveOutputFn
Fn2
=
RR_NoOp
SaveOutputFn
Fn3
=
RR_NoOp
SaveOutputFn
Fn4
=
RR_NoOp
>
static
inline
void
RR_Compose
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
Fn0
(
aEvents
aArguments
aError
)
;
Fn1
(
aEvents
aArguments
aError
)
;
Fn2
(
aEvents
aArguments
aError
)
;
Fn3
(
aEvents
aArguments
aError
)
;
Fn4
(
aEvents
aArguments
aError
)
;
}
template
<
SaveOutputFn
SuccessFn
=
RR_NoOp
>
static
inline
void
RR_SaveRvalHadErrorNegative
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
rval
=
aArguments
-
>
Rval
<
ssize_t
>
(
)
;
aEvents
.
RecordOrReplayValue
(
&
rval
)
;
if
(
rval
<
0
)
{
aEvents
.
RecordOrReplayValue
(
aError
)
;
}
else
{
SuccessFn
(
aEvents
aArguments
aError
)
;
}
}
template
<
SaveOutputFn
SuccessFn
=
RR_NoOp
>
static
inline
void
RR_SaveRvalHadErrorZero
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
rval
=
aArguments
-
>
Rval
<
ssize_t
>
(
)
;
aEvents
.
RecordOrReplayValue
(
&
rval
)
;
if
(
rval
=
=
0
)
{
aEvents
.
RecordOrReplayValue
(
aError
)
;
}
else
{
SuccessFn
(
aEvents
aArguments
aError
)
;
}
}
template
<
size_t
BufferArg
size_t
CountArg
typename
ElemType
=
char
>
static
inline
void
RR_WriteBuffer
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
buf
=
aArguments
-
>
Arg
<
BufferArg
ElemType
*
>
(
)
;
auto
&
count
=
aArguments
-
>
Arg
<
CountArg
size_t
>
(
)
;
aEvents
.
CheckInput
(
count
)
;
aEvents
.
RecordOrReplayBytes
(
buf
count
*
sizeof
(
ElemType
)
)
;
}
template
<
size_t
BufferArg
size_t
CountArg
typename
ElemType
=
char
>
static
inline
void
RR_WriteOptionalBuffer
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
buf
=
aArguments
-
>
Arg
<
BufferArg
ElemType
*
>
(
)
;
auto
&
count
=
aArguments
-
>
Arg
<
CountArg
size_t
>
(
)
;
aEvents
.
CheckInput
(
!
!
buf
)
;
if
(
buf
)
{
aEvents
.
CheckInput
(
count
)
;
aEvents
.
RecordOrReplayBytes
(
buf
count
*
sizeof
(
ElemType
)
)
;
}
}
template
<
size_t
BufferArg
size_t
ByteCount
>
static
inline
void
RR_WriteBufferFixedSize
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
buf
=
aArguments
-
>
Arg
<
BufferArg
void
*
>
(
)
;
aEvents
.
RecordOrReplayBytes
(
buf
ByteCount
)
;
}
template
<
size_t
BufferArg
size_t
ByteCount
>
static
inline
void
RR_WriteOptionalBufferFixedSize
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
buf
=
aArguments
-
>
Arg
<
BufferArg
void
*
>
(
)
;
aEvents
.
CheckInput
(
!
!
buf
)
;
if
(
buf
)
{
aEvents
.
RecordOrReplayBytes
(
buf
ByteCount
)
;
}
}
template
<
size_t
Arg
typename
Type
>
static
inline
void
RR_OutParam
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
RR_WriteOptionalBufferFixedSize
<
Arg
sizeof
(
Type
)
>
(
aEvents
aArguments
aError
)
;
}
template
<
size_t
BufferArg
size_t
CountArg
size_t
Offset
=
0
>
static
inline
void
RR_WriteBufferViaRval
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
auto
&
buf
=
aArguments
-
>
Arg
<
BufferArg
void
*
>
(
)
;
auto
&
count
=
aArguments
-
>
Arg
<
CountArg
size_t
>
(
)
;
aEvents
.
CheckInput
(
count
)
;
auto
&
rval
=
aArguments
-
>
Rval
<
size_t
>
(
)
;
MOZ_RELEASE_ASSERT
(
rval
+
Offset
<
=
count
)
;
aEvents
.
RecordOrReplayBytes
(
buf
rval
+
Offset
)
;
}
static
inline
void
RR_ScalarRval
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
aEvents
.
RecordOrReplayValue
(
&
aArguments
-
>
Rval
<
size_t
>
(
)
)
;
}
static
inline
void
RR_ComplexScalarRval
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
aEvents
.
RecordOrReplayValue
(
&
aArguments
-
>
Rval
<
size_t
>
(
)
)
;
aEvents
.
RecordOrReplayValue
(
&
aArguments
-
>
Rval
<
size_t
1
>
(
)
)
;
}
static
inline
void
RR_FloatRval
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
aEvents
.
RecordOrReplayValue
(
&
aArguments
-
>
FloatRval
(
)
)
;
}
static
inline
void
RR_ComplexFloatRval
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
aEvents
.
RecordOrReplayValue
(
&
aArguments
-
>
FloatRval
(
)
)
;
aEvents
.
RecordOrReplayValue
(
&
aArguments
-
>
FloatRval
<
1
>
(
)
)
;
}
template
<
size_t
ByteCount
>
static
inline
void
RR_OversizeRval
(
Stream
&
aEvents
CallArguments
*
aArguments
ErrorType
*
aError
)
{
RR_WriteBufferFixedSize
<
0
ByteCount
>
(
aEvents
aArguments
aError
)
;
}
template
<
size_t
ReturnValue
>
static
inline
PreambleResult
Preamble_Veto
(
CallArguments
*
aArguments
)
{
aArguments
-
>
Rval
<
size_t
>
(
)
=
ReturnValue
;
return
PreambleResult
:
:
Veto
;
}
template
<
size_t
ReturnValue
>
static
inline
PreambleResult
Preamble_VetoIfNotPassedThrough
(
CallArguments
*
aArguments
)
{
if
(
AreThreadEventsPassedThrough
(
)
)
{
return
PreambleResult
:
:
PassThrough
;
}
aArguments
-
>
Rval
<
size_t
>
(
)
=
ReturnValue
;
return
PreambleResult
:
:
Veto
;
}
static
inline
PreambleResult
Preamble_PassThrough
(
CallArguments
*
aArguments
)
{
return
PreambleResult
:
:
PassThrough
;
}
static
inline
PreambleResult
Preamble_WaitForever
(
CallArguments
*
aArguments
)
{
Thread
:
:
WaitForever
(
)
;
Unreachable
(
)
;
return
PreambleResult
:
:
PassThrough
;
}
static
inline
PreambleResult
Preamble_NYI
(
CallArguments
*
aArguments
)
{
if
(
AreThreadEventsPassedThrough
(
)
)
{
return
PreambleResult
:
:
PassThrough
;
}
MOZ_CRASH
(
"
Redirection
NYI
"
)
;
return
PreambleResult
:
:
Veto
;
}
void
*
BindFunctionArgument
(
void
*
aFunction
void
*
aArgument
size_t
aArgumentPosition
Assembler
&
aAssembler
)
;
}
}
#
endif
