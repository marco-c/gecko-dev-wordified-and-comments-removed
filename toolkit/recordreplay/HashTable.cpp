#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
HashTable
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ProcessRedirect
.
h
"
#
include
"
ValueIndex
.
h
"
#
include
<
unordered_set
>
namespace
mozilla
{
namespace
recordreplay
{
typedef
uint32_t
HashNumber
;
class
StableHashTableInfo
{
struct
KeyInfo
{
const
void
*
mKey
;
HashNumber
mNewHash
;
}
;
struct
HashInfo
{
InfallibleVector
<
KeyInfo
>
mKeys
;
}
;
typedef
std
:
:
unordered_map
<
HashNumber
UniquePtr
<
HashInfo
>
>
HashToKeyMap
;
HashToKeyMap
mHashToKey
;
typedef
std
:
:
unordered_map
<
const
void
*
HashNumber
>
KeyToHashMap
;
KeyToHashMap
mKeyToHash
;
const
void
*
mLastKey
;
HashNumber
mLastNewHash
;
uint32_t
mHashGenerator
;
uint8_t
*
mCallbackStorage
;
uint32_t
mCallbackStorageSize
;
static
const
size_t
CallbackStorageCapacity
=
4096
;
bool
mDestroyed
;
void
*
mTable
;
uint32_t
mCallbackHash
;
KeyInfo
*
FindKeyInfo
(
HashNumber
aOriginalHash
const
void
*
aKey
HashInfo
*
*
aHashInfo
=
nullptr
)
{
HashToKeyMap
:
:
iterator
iter
=
mHashToKey
.
find
(
aOriginalHash
)
;
MOZ_RELEASE_ASSERT
(
iter
!
=
mHashToKey
.
end
(
)
)
;
HashInfo
*
hashInfo
=
iter
-
>
second
.
get
(
)
;
for
(
KeyInfo
&
keyInfo
:
hashInfo
-
>
mKeys
)
{
if
(
keyInfo
.
mKey
=
=
aKey
)
{
if
(
aHashInfo
)
{
*
aHashInfo
=
hashInfo
;
}
return
&
keyInfo
;
}
}
MOZ_CRASH
(
)
;
}
public
:
StableHashTableInfo
(
)
:
mLastKey
(
nullptr
)
mLastNewHash
(
0
)
mHashGenerator
(
0
)
mCallbackStorage
(
nullptr
)
mDestroyed
(
false
)
mTable
(
nullptr
)
mCallbackHash
(
0
)
{
mCallbackStorage
=
(
uint8_t
*
)
DirectAllocateMemory
(
CallbackStorageCapacity
)
;
MarkValid
(
)
;
}
~
StableHashTableInfo
(
)
{
MOZ_RELEASE_ASSERT
(
mHashToKey
.
empty
(
)
)
;
DirectDeallocateMemory
(
mCallbackStorage
CallbackStorageCapacity
)
;
UnmarkValid
(
)
;
}
bool
IsDestroyed
(
)
{
return
mDestroyed
;
}
void
MarkDestroyed
(
)
{
MOZ_RELEASE_ASSERT
(
!
IsDestroyed
(
)
)
;
mDestroyed
=
true
;
}
void
CheckIntegrity
(
void
*
aTable
)
{
MOZ_RELEASE_ASSERT
(
aTable
)
;
if
(
!
mTable
)
{
mTable
=
aTable
;
mCallbackHash
=
HashBytes
(
mCallbackStorage
mCallbackStorageSize
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
mTable
=
=
aTable
)
;
MOZ_RELEASE_ASSERT
(
mCallbackHash
=
=
HashBytes
(
mCallbackStorage
mCallbackStorageSize
)
)
;
}
}
void
AddKey
(
HashNumber
aOriginalHash
const
void
*
aKey
HashNumber
aNewHash
)
{
HashToKeyMap
:
:
iterator
iter
=
mHashToKey
.
find
(
aOriginalHash
)
;
if
(
iter
=
=
mHashToKey
.
end
(
)
)
{
iter
=
mHashToKey
.
insert
(
HashToKeyMap
:
:
value_type
(
aOriginalHash
MakeUnique
<
HashInfo
>
(
)
)
)
.
first
;
}
HashInfo
*
hashInfo
=
iter
-
>
second
.
get
(
)
;
KeyInfo
key
;
key
.
mKey
=
aKey
;
key
.
mNewHash
=
aNewHash
;
hashInfo
-
>
mKeys
.
append
(
key
)
;
mKeyToHash
.
insert
(
KeyToHashMap
:
:
value_type
(
aKey
aOriginalHash
)
)
;
}
void
RemoveKey
(
HashNumber
aOriginalHash
const
void
*
aKey
)
{
HashInfo
*
hashInfo
;
KeyInfo
*
keyInfo
=
FindKeyInfo
(
aOriginalHash
aKey
&
hashInfo
)
;
hashInfo
-
>
mKeys
.
erase
(
keyInfo
)
;
if
(
hashInfo
-
>
mKeys
.
length
(
)
=
=
0
)
{
mHashToKey
.
erase
(
aOriginalHash
)
;
}
mKeyToHash
.
erase
(
aKey
)
;
}
HashNumber
FindKeyHash
(
HashNumber
aOriginalHash
const
void
*
aKey
)
{
KeyInfo
*
info
=
FindKeyInfo
(
aOriginalHash
aKey
)
;
return
info
-
>
mNewHash
;
}
bool
HasMatchingKey
(
HashNumber
aOriginalHash
const
std
:
:
function
<
bool
(
const
void
*
)
>
&
aMatch
HashNumber
*
aNewHash
)
{
HashToKeyMap
:
:
const_iterator
iter
=
mHashToKey
.
find
(
aOriginalHash
)
;
if
(
iter
!
=
mHashToKey
.
end
(
)
)
{
HashInfo
*
hashInfo
=
iter
-
>
second
.
get
(
)
;
for
(
const
KeyInfo
&
keyInfo
:
hashInfo
-
>
mKeys
)
{
if
(
aMatch
(
keyInfo
.
mKey
)
)
{
*
aNewHash
=
keyInfo
.
mNewHash
;
return
true
;
}
}
}
return
false
;
}
HashNumber
GetOriginalHashNumber
(
const
void
*
aKey
)
{
KeyToHashMap
:
:
iterator
iter
=
mKeyToHash
.
find
(
aKey
)
;
MOZ_RELEASE_ASSERT
(
iter
!
=
mKeyToHash
.
end
(
)
)
;
return
iter
-
>
second
;
}
class
Assembler
:
public
recordreplay
:
:
Assembler
{
public
:
StableHashTableInfo
&
mInfo
;
explicit
Assembler
(
StableHashTableInfo
&
aInfo
)
:
recordreplay
:
:
Assembler
(
aInfo
.
mCallbackStorage
CallbackStorageCapacity
)
mInfo
(
aInfo
)
{
}
~
Assembler
(
)
{
mInfo
.
mCallbackStorageSize
=
Current
(
)
-
mInfo
.
mCallbackStorage
;
}
}
;
template
<
typename
S
typename
T
>
void
NewBoundFunction
(
Assembler
&
aAssembler
S
aFunction
void
*
aArgument
size_t
aArgumentPosition
T
*
aTarget
)
{
void
*
nfn
=
BindFunctionArgument
(
BitwiseCast
<
void
*
>
(
aFunction
)
aArgument
aArgumentPosition
aAssembler
)
;
BitwiseCast
(
nfn
aTarget
)
;
}
HashNumber
SetLastKey
(
const
void
*
aKey
)
{
mLastKey
=
aKey
;
mLastNewHash
=
mHashGenerator
+
+
;
return
mLastNewHash
;
}
bool
HasLastKey
(
)
{
return
!
!
mLastKey
;
}
HashNumber
GetLastNewHash
(
const
void
*
aKey
)
{
MOZ_RELEASE_ASSERT
(
aKey
=
=
mLastKey
)
;
return
mLastNewHash
;
}
bool
IsEmpty
(
)
{
return
mHashToKey
.
empty
(
)
;
}
void
MoveContentsFrom
(
StableHashTableInfo
&
aOther
)
{
mHashToKey
=
std
:
:
move
(
aOther
.
mHashToKey
)
;
mKeyToHash
=
std
:
:
move
(
aOther
.
mKeyToHash
)
;
mHashGenerator
=
aOther
.
mHashGenerator
;
aOther
.
mHashToKey
.
clear
(
)
;
aOther
.
mKeyToHash
.
clear
(
)
;
aOther
.
mHashGenerator
=
0
;
mLastKey
=
aOther
.
mLastKey
=
nullptr
;
mLastNewHash
=
aOther
.
mLastNewHash
=
0
;
}
static
std
:
:
unordered_set
<
StableHashTableInfo
*
>
*
gHashInfos
;
static
SpinLock
gHashInfosLock
;
inline
bool
IsValid
(
)
{
AutoSpinLock
lock
(
gHashInfosLock
)
;
return
gHashInfos
&
&
gHashInfos
-
>
find
(
this
)
!
=
gHashInfos
-
>
end
(
)
;
}
inline
void
MarkValid
(
)
{
AutoSpinLock
lock
(
gHashInfosLock
)
;
if
(
!
gHashInfos
)
{
gHashInfos
=
new
std
:
:
unordered_set
<
StableHashTableInfo
*
>
(
)
;
}
gHashInfos
-
>
insert
(
this
)
;
}
inline
void
UnmarkValid
(
)
{
AutoSpinLock
lock
(
gHashInfosLock
)
;
gHashInfos
-
>
erase
(
this
)
;
}
}
;
std
:
:
unordered_set
<
StableHashTableInfo
*
>
*
StableHashTableInfo
:
:
gHashInfos
;
SpinLock
StableHashTableInfo
:
:
gHashInfosLock
;
struct
PLHashTableInfo
:
public
StableHashTableInfo
{
PLHashFunction
mKeyHash
;
PLHashComparator
mKeyCompare
;
PLHashComparator
mValueCompare
;
const
PLHashAllocOps
*
mAllocOps
;
void
*
mAllocPrivate
;
PLHashTableInfo
(
PLHashFunction
aKeyHash
PLHashComparator
aKeyCompare
PLHashComparator
aValueCompare
const
PLHashAllocOps
*
aAllocOps
void
*
aAllocPrivate
)
:
mKeyHash
(
aKeyHash
)
mKeyCompare
(
aKeyCompare
)
mValueCompare
(
aValueCompare
)
mAllocOps
(
aAllocOps
)
mAllocPrivate
(
aAllocPrivate
)
{
}
static
PLHashTableInfo
*
MaybeFromPrivate
(
void
*
aAllocPrivate
)
{
PLHashTableInfo
*
info
=
reinterpret_cast
<
PLHashTableInfo
*
>
(
aAllocPrivate
)
;
if
(
info
-
>
IsValid
(
)
)
{
MOZ_RELEASE_ASSERT
(
!
info
-
>
IsDestroyed
(
)
)
;
return
info
;
}
return
nullptr
;
}
static
PLHashTableInfo
*
FromPrivate
(
void
*
aAllocPrivate
)
{
PLHashTableInfo
*
info
=
MaybeFromPrivate
(
aAllocPrivate
)
;
MOZ_RELEASE_ASSERT
(
info
)
;
return
info
;
}
}
;
static
void
*
WrapPLHashAllocTable
(
void
*
aAllocPrivate
PRSize
aSize
)
{
PLHashTableInfo
*
info
=
PLHashTableInfo
:
:
FromPrivate
(
aAllocPrivate
)
;
return
info
-
>
mAllocOps
?
info
-
>
mAllocOps
-
>
allocTable
(
info
-
>
mAllocPrivate
aSize
)
:
malloc
(
aSize
)
;
}
static
void
WrapPLHashFreeTable
(
void
*
aAllocPrivate
void
*
aItem
)
{
PLHashTableInfo
*
info
=
PLHashTableInfo
:
:
FromPrivate
(
aAllocPrivate
)
;
if
(
info
-
>
mAllocOps
)
{
info
-
>
mAllocOps
-
>
freeTable
(
info
-
>
mAllocPrivate
aItem
)
;
}
else
{
free
(
aItem
)
;
}
}
static
PLHashEntry
*
WrapPLHashAllocEntry
(
void
*
aAllocPrivate
const
void
*
aKey
)
{
PLHashTableInfo
*
info
=
PLHashTableInfo
:
:
FromPrivate
(
aAllocPrivate
)
;
if
(
info
-
>
HasLastKey
(
)
)
{
uint32_t
originalHash
=
info
-
>
mKeyHash
(
aKey
)
;
info
-
>
AddKey
(
originalHash
aKey
info
-
>
GetLastNewHash
(
aKey
)
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
info
-
>
IsEmpty
(
)
)
;
}
return
info
-
>
mAllocOps
?
info
-
>
mAllocOps
-
>
allocEntry
(
info
-
>
mAllocPrivate
aKey
)
:
(
PLHashEntry
*
)
malloc
(
sizeof
(
PLHashEntry
)
)
;
}
static
void
WrapPLHashFreeEntry
(
void
*
aAllocPrivate
PLHashEntry
*
he
PRUintn
flag
)
{
PLHashTableInfo
*
info
=
PLHashTableInfo
:
:
FromPrivate
(
aAllocPrivate
)
;
if
(
flag
=
=
HT_FREE_ENTRY
&
&
!
info
-
>
IsEmpty
(
)
)
{
uint32_t
originalHash
=
info
-
>
GetOriginalHashNumber
(
he
-
>
key
)
;
info
-
>
RemoveKey
(
originalHash
he
-
>
key
)
;
}
if
(
info
-
>
mAllocOps
)
{
info
-
>
mAllocOps
-
>
freeEntry
(
info
-
>
mAllocPrivate
he
flag
)
;
}
else
if
(
flag
=
=
HT_FREE_ENTRY
)
{
free
(
he
)
;
}
}
static
PLHashAllocOps
gWrapPLHashAllocOps
=
{
WrapPLHashAllocTable
WrapPLHashFreeTable
WrapPLHashAllocEntry
WrapPLHashFreeEntry
}
;
static
uint32_t
PLHashComputeHash
(
void
*
aKey
PLHashTableInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
!
aInfo
-
>
IsDestroyed
(
)
)
;
uint32_t
originalHash
=
aInfo
-
>
mKeyHash
(
aKey
)
;
HashNumber
newHash
;
if
(
aInfo
-
>
HasMatchingKey
(
originalHash
[
=
]
(
const
void
*
aExistingKey
)
{
return
aInfo
-
>
mKeyCompare
(
aKey
aExistingKey
)
;
}
&
newHash
)
)
{
return
newHash
;
}
return
aInfo
-
>
SetLastKey
(
aKey
)
;
}
void
GeneratePLHashTableCallbacks
(
PLHashFunction
*
aKeyHash
PLHashComparator
*
aKeyCompare
PLHashComparator
*
aValueCompare
const
PLHashAllocOps
*
*
aAllocOps
void
*
*
aAllocPrivate
)
{
PLHashTableInfo
*
info
=
new
PLHashTableInfo
(
*
aKeyHash
*
aKeyCompare
*
aValueCompare
*
aAllocOps
*
aAllocPrivate
)
;
PLHashTableInfo
:
:
Assembler
assembler
(
*
info
)
;
info
-
>
NewBoundFunction
(
assembler
PLHashComputeHash
info
1
aKeyHash
)
;
*
aAllocOps
=
&
gWrapPLHashAllocOps
;
*
aAllocPrivate
=
info
;
}
void
DestroyPLHashTableCallbacks
(
void
*
aAllocPrivate
)
{
PLHashTableInfo
*
info
=
PLHashTableInfo
:
:
MaybeFromPrivate
(
aAllocPrivate
)
;
if
(
info
)
{
info
-
>
MarkDestroyed
(
)
;
}
}
void
CheckPLHashTable
(
PLHashTable
*
aTable
)
{
PLHashTableInfo
*
info
=
PLHashTableInfo
:
:
MaybeFromPrivate
(
aTable
-
>
allocPriv
)
;
if
(
info
)
{
info
-
>
CheckIntegrity
(
aTable
)
;
}
}
struct
PLDHashTableInfo
:
public
StableHashTableInfo
{
const
PLDHashTableOps
*
mOps
;
PLDHashTableOps
mNewOps
;
explicit
PLDHashTableInfo
(
const
PLDHashTableOps
*
aOps
)
:
mOps
(
aOps
)
{
PodZero
(
&
mNewOps
)
;
}
static
PLDHashTableInfo
*
MaybeFromOps
(
const
PLDHashTableOps
*
aOps
)
{
PLDHashTableInfo
*
res
=
reinterpret_cast
<
PLDHashTableInfo
*
>
(
(
uint8_t
*
)
aOps
-
offsetof
(
PLDHashTableInfo
mNewOps
)
)
;
if
(
res
-
>
IsValid
(
)
)
{
MOZ_RELEASE_ASSERT
(
!
res
-
>
IsDestroyed
(
)
)
;
return
res
;
}
return
nullptr
;
}
static
PLDHashTableInfo
*
FromOps
(
const
PLDHashTableOps
*
aOps
)
{
PLDHashTableInfo
*
res
=
MaybeFromOps
(
aOps
)
;
MOZ_RELEASE_ASSERT
(
res
)
;
return
res
;
}
static
void
CheckIntegrity
(
PLDHashTable
*
aTable
)
{
PLDHashTableInfo
*
info
=
MaybeFromOps
(
aTable
-
>
RecordReplayWrappedOps
(
)
)
;
if
(
info
)
{
info
-
>
StableHashTableInfo
:
:
CheckIntegrity
(
aTable
)
;
}
}
}
;
static
PLDHashNumber
PLDHashTableComputeHash
(
const
void
*
aKey
PLDHashTableInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
!
aInfo
-
>
IsDestroyed
(
)
)
;
uint32_t
originalHash
=
aInfo
-
>
mOps
-
>
hashKey
(
aKey
)
;
HashNumber
newHash
;
if
(
aInfo
-
>
HasMatchingKey
(
originalHash
[
=
]
(
const
void
*
aExistingKey
)
{
return
aInfo
-
>
mOps
-
>
matchEntry
(
(
PLDHashEntryHdr
*
)
aExistingKey
aKey
)
;
}
&
newHash
)
)
{
return
newHash
;
}
return
aInfo
-
>
SetLastKey
(
aKey
)
;
}
static
void
PLDHashTableMoveEntry
(
PLDHashTable
*
aTable
const
PLDHashEntryHdr
*
aFrom
PLDHashEntryHdr
*
aTo
PLDHashTableInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
!
aInfo
-
>
IsDestroyed
(
)
)
;
aInfo
-
>
mOps
-
>
moveEntry
(
aTable
aFrom
aTo
)
;
uint32_t
originalHash
=
aInfo
-
>
GetOriginalHashNumber
(
aFrom
)
;
uint32_t
newHash
=
aInfo
-
>
FindKeyHash
(
originalHash
aFrom
)
;
aInfo
-
>
RemoveKey
(
originalHash
aFrom
)
;
aInfo
-
>
AddKey
(
originalHash
aTo
newHash
)
;
}
static
void
PLDHashTableClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
PLDHashTableInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
!
aInfo
-
>
IsDestroyed
(
)
)
;
aInfo
-
>
mOps
-
>
clearEntry
(
aTable
aEntry
)
;
uint32_t
originalHash
=
aInfo
-
>
GetOriginalHashNumber
(
aEntry
)
;
aInfo
-
>
RemoveKey
(
originalHash
aEntry
)
;
}
static
void
PLDHashTableInitEntry
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
PLDHashTableInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
!
aInfo
-
>
IsDestroyed
(
)
)
;
if
(
aInfo
-
>
mOps
-
>
initEntry
)
{
aInfo
-
>
mOps
-
>
initEntry
(
aEntry
aKey
)
;
}
uint32_t
originalHash
=
aInfo
-
>
mOps
-
>
hashKey
(
aKey
)
;
aInfo
-
>
AddKey
(
originalHash
aEntry
aInfo
-
>
GetLastNewHash
(
aKey
)
)
;
}
extern
"
C
"
{
MOZ_EXPORT
const
PLDHashTableOps
*
RecordReplayInterface_InternalGeneratePLDHashTableCallbacks
(
const
PLDHashTableOps
*
aOps
)
{
PLDHashTableInfo
*
info
=
new
PLDHashTableInfo
(
aOps
)
;
PLDHashTableInfo
:
:
Assembler
assembler
(
*
info
)
;
info
-
>
NewBoundFunction
(
assembler
PLDHashTableComputeHash
info
1
&
info
-
>
mNewOps
.
hashKey
)
;
info
-
>
mNewOps
.
matchEntry
=
aOps
-
>
matchEntry
;
info
-
>
NewBoundFunction
(
assembler
PLDHashTableMoveEntry
info
3
&
info
-
>
mNewOps
.
moveEntry
)
;
info
-
>
NewBoundFunction
(
assembler
PLDHashTableClearEntry
info
2
&
info
-
>
mNewOps
.
clearEntry
)
;
info
-
>
NewBoundFunction
(
assembler
PLDHashTableInitEntry
info
2
&
info
-
>
mNewOps
.
initEntry
)
;
return
&
info
-
>
mNewOps
;
}
MOZ_EXPORT
const
PLDHashTableOps
*
RecordReplayInterface_InternalUnwrapPLDHashTableCallbacks
(
const
PLDHashTableOps
*
aOps
)
{
PLDHashTableInfo
*
info
=
PLDHashTableInfo
:
:
FromOps
(
aOps
)
;
return
info
-
>
mOps
;
}
MOZ_EXPORT
void
RecordReplayInterface_InternalDestroyPLDHashTableCallbacks
(
const
PLDHashTableOps
*
aOps
)
{
if
(
!
aOps
)
{
return
;
}
PLDHashTableInfo
*
info
=
PLDHashTableInfo
:
:
MaybeFromOps
(
aOps
)
;
if
(
info
)
{
info
-
>
MarkDestroyed
(
)
;
}
}
MOZ_EXPORT
void
RecordReplayInterface_InternalMovePLDHashTableContents
(
const
PLDHashTableOps
*
aFirstOps
const
PLDHashTableOps
*
aSecondOps
)
{
PLDHashTableInfo
*
firstInfo
=
PLDHashTableInfo
:
:
FromOps
(
aFirstOps
)
;
PLDHashTableInfo
*
secondInfo
=
PLDHashTableInfo
:
:
FromOps
(
aSecondOps
)
;
secondInfo
-
>
MoveContentsFrom
(
*
firstInfo
)
;
}
}
void
CheckPLDHashTable
(
PLDHashTable
*
aTable
)
{
PLDHashTableInfo
:
:
CheckIntegrity
(
aTable
)
;
}
}
}
