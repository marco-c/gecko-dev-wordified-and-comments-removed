#
ifndef
mozilla_recordreplay_InfallibleVector_h
#
define
mozilla_recordreplay_InfallibleVector_h
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
template
<
typename
Outer
typename
T
size_t
MinInlineCapacity
class
AllocPolicy
>
class
InfallibleVectorOperations
{
typedef
Vector
<
T
MinInlineCapacity
AllocPolicy
>
InnerVector
;
InnerVector
&
Vector
(
)
{
return
static_cast
<
Outer
*
>
(
this
)
-
>
Vector
(
)
;
}
const
InnerVector
&
Vector
(
)
const
{
return
static_cast
<
const
Outer
*
>
(
this
)
-
>
Vector
(
)
;
}
public
:
size_t
length
(
)
const
{
return
Vector
(
)
.
length
(
)
;
}
bool
empty
(
)
const
{
return
Vector
(
)
.
empty
(
)
;
}
T
*
begin
(
)
{
return
Vector
(
)
.
begin
(
)
;
}
const
T
*
begin
(
)
const
{
return
Vector
(
)
.
begin
(
)
;
}
T
*
end
(
)
{
return
Vector
(
)
.
end
(
)
;
}
const
T
*
end
(
)
const
{
return
Vector
(
)
.
end
(
)
;
}
T
&
operator
[
]
(
size_t
aIndex
)
{
return
Vector
(
)
[
aIndex
]
;
}
const
T
&
operator
[
]
(
size_t
aIndex
)
const
{
return
Vector
(
)
[
aIndex
]
;
}
T
&
back
(
)
{
return
Vector
(
)
.
back
(
)
;
}
const
T
&
back
(
)
const
{
return
Vector
(
)
.
back
(
)
;
}
void
popBack
(
)
{
Vector
(
)
.
popBack
(
)
;
}
T
popCopy
(
)
{
return
Vector
(
)
.
popCopy
(
)
;
}
void
erase
(
T
*
aT
)
{
Vector
(
)
.
erase
(
aT
)
;
}
void
clear
(
)
{
Vector
(
)
.
clear
(
)
;
}
void
reserve
(
size_t
aRequest
)
{
if
(
!
Vector
(
)
.
reserve
(
aRequest
)
)
{
MOZ_CRASH
(
)
;
}
}
void
resize
(
size_t
aNewLength
)
{
if
(
!
Vector
(
)
.
resize
(
aNewLength
)
)
{
MOZ_CRASH
(
)
;
}
}
template
<
typename
U
>
void
append
(
U
&
&
aU
)
{
if
(
!
Vector
(
)
.
append
(
std
:
:
forward
<
U
>
(
aU
)
)
)
{
MOZ_CRASH
(
)
;
}
}
template
<
typename
U
>
void
append
(
const
U
*
aBegin
size_t
aLength
)
{
if
(
!
Vector
(
)
.
append
(
aBegin
aLength
)
)
{
MOZ_CRASH
(
)
;
}
}
void
appendN
(
const
T
&
aT
size_t
aN
)
{
if
(
!
Vector
(
)
.
appendN
(
aT
aN
)
)
{
MOZ_CRASH
(
)
;
}
}
template
<
typename
.
.
.
Args
>
void
emplaceBack
(
Args
&
&
.
.
.
aArgs
)
{
if
(
!
Vector
(
)
.
emplaceBack
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
{
MOZ_CRASH
(
)
;
}
}
template
<
typename
.
.
.
Args
>
void
infallibleEmplaceBack
(
Args
&
&
.
.
.
aArgs
)
{
Vector
(
)
.
infallibleEmplaceBack
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
U
>
void
insert
(
T
*
aP
U
&
&
aVal
)
{
if
(
!
Vector
(
)
.
insert
(
aP
std
:
:
forward
<
U
>
(
aVal
)
)
)
{
MOZ_CRASH
(
)
;
}
}
}
;
template
<
typename
T
size_t
MinInlineCapacity
=
0
class
AllocPolicy
=
MallocAllocPolicy
>
class
InfallibleVector
:
public
InfallibleVectorOperations
<
InfallibleVector
<
T
MinInlineCapacity
AllocPolicy
>
T
MinInlineCapacity
AllocPolicy
>
{
typedef
Vector
<
T
MinInlineCapacity
AllocPolicy
>
InnerVector
;
InnerVector
mVector
;
public
:
InnerVector
&
Vector
(
)
{
return
mVector
;
}
const
InnerVector
&
Vector
(
)
const
{
return
mVector
;
}
}
;
template
<
typename
T
size_t
MinInlineCapacity
=
0
class
AllocPolicy
=
MallocAllocPolicy
>
class
StaticInfallibleVector
:
public
InfallibleVectorOperations
<
StaticInfallibleVector
<
T
MinInlineCapacity
AllocPolicy
>
T
MinInlineCapacity
AllocPolicy
>
{
typedef
Vector
<
T
MinInlineCapacity
AllocPolicy
>
InnerVector
;
mutable
InnerVector
*
mVector
;
void
EnsureVector
(
)
const
{
if
(
!
mVector
)
{
AllocPolicy
policy
;
void
*
memory
=
policy
.
template
pod_malloc
<
InnerVector
>
(
1
)
;
MOZ_RELEASE_ASSERT
(
memory
)
;
mVector
=
new
(
memory
)
InnerVector
(
)
;
}
}
public
:
InnerVector
&
Vector
(
)
{
EnsureVector
(
)
;
return
*
mVector
;
}
const
InnerVector
&
Vector
(
)
const
{
EnsureVector
(
)
;
return
*
mVector
;
}
}
;
}
}
#
endif
