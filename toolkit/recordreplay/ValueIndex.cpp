#
include
"
ValueIndex
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
size_t
ValueIndex
:
:
Insert
(
const
void
*
aValue
)
{
MOZ_RELEASE_ASSERT
(
!
Contains
(
aValue
)
)
;
size_t
index
=
mIndexCount
+
+
;
mValueToIndex
.
insert
(
ValueToIndexMap
:
:
value_type
(
aValue
index
)
)
;
mIndexToValue
.
insert
(
IndexToValueMap
:
:
value_type
(
index
aValue
)
)
;
return
index
;
}
void
ValueIndex
:
:
Remove
(
const
void
*
aValue
)
{
size_t
index
;
if
(
!
MaybeGetIndex
(
aValue
&
index
)
)
{
return
;
}
mValueToIndex
.
erase
(
aValue
)
;
mIndexToValue
.
erase
(
index
)
;
}
size_t
ValueIndex
:
:
GetIndex
(
const
void
*
aValue
)
{
size_t
index
;
if
(
!
MaybeGetIndex
(
aValue
&
index
)
)
{
MOZ_CRASH
(
)
;
}
return
index
;
}
bool
ValueIndex
:
:
MaybeGetIndex
(
const
void
*
aValue
size_t
*
aIndex
)
{
ValueToIndexMap
:
:
const_iterator
iter
=
mValueToIndex
.
find
(
aValue
)
;
if
(
iter
!
=
mValueToIndex
.
end
(
)
)
{
*
aIndex
=
iter
-
>
second
;
return
true
;
}
return
false
;
}
bool
ValueIndex
:
:
Contains
(
const
void
*
aValue
)
{
size_t
index
;
return
MaybeGetIndex
(
aValue
&
index
)
;
}
const
void
*
ValueIndex
:
:
GetValue
(
size_t
aIndex
)
{
IndexToValueMap
:
:
const_iterator
iter
=
mIndexToValue
.
find
(
aIndex
)
;
MOZ_RELEASE_ASSERT
(
iter
!
=
mIndexToValue
.
end
(
)
)
;
return
iter
-
>
second
;
}
bool
ValueIndex
:
:
IsEmpty
(
)
{
MOZ_ASSERT
(
mValueToIndex
.
empty
(
)
=
=
mIndexToValue
.
empty
(
)
)
;
return
mValueToIndex
.
empty
(
)
;
}
const
ValueIndex
:
:
ValueToIndexMap
&
ValueIndex
:
:
GetValueToIndexMap
(
)
{
return
mValueToIndex
;
}
}
}
