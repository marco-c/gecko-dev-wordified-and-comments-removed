#
ifndef
mozilla_recordreplay_ChunkAllocator_h
#
define
mozilla_recordreplay_ChunkAllocator_h
#
include
"
SpinLock
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
template
<
typename
T
>
class
ChunkAllocator
{
struct
Chunk
;
typedef
Atomic
<
Chunk
*
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
ChunkPointer
;
struct
Chunk
{
uint8_t
mStorage
[
PageSize
-
sizeof
(
Chunk
*
)
]
;
ChunkPointer
mNext
;
Chunk
(
)
:
mStorage
{
}
mNext
(
nullptr
)
{
}
static
size_t
MaxThings
(
)
{
return
sizeof
(
mStorage
)
/
sizeof
(
T
)
;
}
T
*
GetThing
(
size_t
i
)
{
MOZ_RELEASE_ASSERT
(
i
<
MaxThings
(
)
)
;
return
reinterpret_cast
<
T
*
>
(
&
mStorage
[
i
*
sizeof
(
T
)
]
)
;
}
}
;
ChunkPointer
mFirstChunk
;
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mCapacity
;
SpinLock
mLock
;
void
EnsureChunk
(
ChunkPointer
*
aChunk
)
{
if
(
!
*
aChunk
)
{
*
aChunk
=
new
Chunk
(
)
;
mCapacity
+
=
Chunk
:
:
MaxThings
(
)
;
}
}
ChunkAllocator
(
const
ChunkAllocator
&
)
=
delete
;
ChunkAllocator
&
operator
=
(
const
ChunkAllocator
&
)
=
delete
;
public
:
ChunkAllocator
(
)
=
default
;
~
ChunkAllocator
(
)
=
default
;
inline
T
*
Get
(
size_t
aId
)
{
Chunk
*
chunk
=
mFirstChunk
;
while
(
aId
>
=
Chunk
:
:
MaxThings
(
)
)
{
aId
-
=
Chunk
:
:
MaxThings
(
)
;
chunk
=
chunk
-
>
mNext
;
}
return
chunk
-
>
GetThing
(
aId
)
;
}
inline
T
*
MaybeGet
(
size_t
aId
)
{
return
(
aId
<
mCapacity
)
?
Get
(
aId
)
:
nullptr
;
}
inline
T
*
Create
(
size_t
aId
)
{
if
(
aId
<
mCapacity
)
{
T
*
res
=
Get
(
aId
)
;
return
new
(
res
)
T
(
)
;
}
AutoSpinLock
lock
(
mLock
)
;
ChunkPointer
*
pchunk
=
&
mFirstChunk
;
while
(
aId
>
=
Chunk
:
:
MaxThings
(
)
)
{
aId
-
=
Chunk
:
:
MaxThings
(
)
;
EnsureChunk
(
pchunk
)
;
Chunk
*
chunk
=
*
pchunk
;
pchunk
=
&
chunk
-
>
mNext
;
}
EnsureChunk
(
pchunk
)
;
Chunk
*
chunk
=
*
pchunk
;
T
*
res
=
chunk
-
>
GetThing
(
aId
)
;
return
new
(
res
)
T
(
)
;
}
}
;
}
}
#
endif
