#
include
"
Trigger
.
h
"
#
include
"
ipc
/
ChildIPC
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
RecordReplay
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
ProcessRewind
.
h
"
#
include
"
Thread
.
h
"
#
include
"
ValueIndex
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
struct
TriggerInfo
{
size_t
mThreadId
;
std
:
:
function
<
void
(
)
>
mCallback
;
size_t
mRegisterCount
;
TriggerInfo
(
size_t
aThreadId
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
:
mThreadId
(
aThreadId
)
mCallback
(
aCallback
)
mRegisterCount
(
1
)
{
}
}
;
static
ValueIndex
*
gTriggers
;
typedef
std
:
:
unordered_map
<
void
*
TriggerInfo
>
TriggerInfoMap
;
static
TriggerInfoMap
*
gTriggerInfoMap
;
static
StaticInfallibleVector
<
size_t
>
gActivatedTriggers
;
static
StaticMutexNotRecorded
gTriggersMutex
;
void
InitializeTriggers
(
)
{
gTriggers
=
new
ValueIndex
(
)
;
gTriggerInfoMap
=
new
TriggerInfoMap
(
)
;
}
extern
"
C
"
{
MOZ_EXPORT
void
RecordReplayInterface_RegisterTrigger
(
void
*
aObj
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
aObj
)
;
if
(
HasDivergedFromRecording
(
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsDisallowed
(
)
)
;
size_t
threadId
=
Thread
:
:
Current
(
)
-
>
Id
(
)
;
size_t
id
;
{
AutoOrderedAtomicAccess
order
;
StaticMutexAutoLock
lock
(
gTriggersMutex
)
;
TriggerInfoMap
:
:
iterator
iter
=
gTriggerInfoMap
-
>
find
(
aObj
)
;
if
(
iter
!
=
gTriggerInfoMap
-
>
end
(
)
)
{
id
=
gTriggers
-
>
GetIndex
(
aObj
)
;
MOZ_RELEASE_ASSERT
(
iter
-
>
second
.
mThreadId
=
=
threadId
)
;
iter
-
>
second
.
mCallback
=
aCallback
;
iter
-
>
second
.
mRegisterCount
+
+
;
}
else
{
id
=
gTriggers
-
>
Insert
(
aObj
)
;
TriggerInfo
info
(
threadId
aCallback
)
;
gTriggerInfoMap
-
>
insert
(
TriggerInfoMap
:
:
value_type
(
aObj
info
)
)
;
}
}
RecordReplayAssert
(
"
RegisterTrigger
%
zu
"
id
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_UnregisterTrigger
(
void
*
aObj
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
StaticMutexAutoLock
lock
(
gTriggersMutex
)
;
TriggerInfoMap
:
:
iterator
iter
=
gTriggerInfoMap
-
>
find
(
aObj
)
;
MOZ_RELEASE_ASSERT
(
iter
!
=
gTriggerInfoMap
-
>
end
(
)
)
;
if
(
-
-
iter
-
>
second
.
mRegisterCount
=
=
0
)
{
gTriggerInfoMap
-
>
erase
(
iter
)
;
gTriggers
-
>
Remove
(
aObj
)
;
}
}
MOZ_EXPORT
void
RecordReplayInterface_ActivateTrigger
(
void
*
aObj
)
{
if
(
!
IsRecording
(
)
)
{
return
;
}
StaticMutexAutoLock
lock
(
gTriggersMutex
)
;
size_t
id
=
gTriggers
-
>
GetIndex
(
aObj
)
;
gActivatedTriggers
.
emplaceBack
(
id
)
;
}
static
void
InvokeTriggerCallback
(
size_t
aId
)
{
void
*
obj
;
std
:
:
function
<
void
(
)
>
callback
;
{
StaticMutexAutoLock
lock
(
gTriggersMutex
)
;
obj
=
const_cast
<
void
*
>
(
gTriggers
-
>
GetValue
(
aId
)
)
;
TriggerInfoMap
:
:
iterator
iter
=
gTriggerInfoMap
-
>
find
(
obj
)
;
MOZ_RELEASE_ASSERT
(
iter
!
=
gTriggerInfoMap
-
>
end
(
)
)
;
MOZ_RELEASE_ASSERT
(
iter
-
>
second
.
mThreadId
=
=
Thread
:
:
Current
(
)
-
>
Id
(
)
)
;
MOZ_RELEASE_ASSERT
(
iter
-
>
second
.
mRegisterCount
)
;
MOZ_RELEASE_ASSERT
(
iter
-
>
second
.
mCallback
)
;
callback
=
iter
-
>
second
.
mCallback
;
}
callback
(
)
;
}
static
Maybe
<
size_t
>
RemoveTriggerCallbackForThreadId
(
size_t
aThreadId
)
{
StaticMutexAutoLock
lock
(
gTriggersMutex
)
;
for
(
size_t
i
=
0
;
i
<
gActivatedTriggers
.
length
(
)
;
i
+
+
)
{
size_t
id
=
gActivatedTriggers
[
i
]
;
void
*
obj
=
const_cast
<
void
*
>
(
gTriggers
-
>
GetValue
(
id
)
)
;
TriggerInfoMap
:
:
iterator
iter
=
gTriggerInfoMap
-
>
find
(
obj
)
;
MOZ_RELEASE_ASSERT
(
iter
!
=
gTriggerInfoMap
-
>
end
(
)
)
;
if
(
iter
-
>
second
.
mThreadId
=
=
aThreadId
)
{
gActivatedTriggers
.
erase
(
&
gActivatedTriggers
[
i
]
)
;
return
Some
(
id
)
;
}
}
return
Nothing
(
)
;
}
MOZ_EXPORT
void
RecordReplayInterface_ExecuteTriggers
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsDisallowed
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
RecordReplayAssert
(
"
ExecuteTriggers
"
)
;
if
(
IsRecording
(
)
)
{
while
(
true
)
{
Maybe
<
size_t
>
id
=
RemoveTriggerCallbackForThreadId
(
thread
-
>
Id
(
)
)
;
if
(
id
.
isNothing
(
)
)
{
break
;
}
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
ExecuteTrigger
)
;
thread
-
>
Events
(
)
.
WriteScalar
(
id
.
ref
(
)
)
;
InvokeTriggerCallback
(
id
.
ref
(
)
)
;
}
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
ThreadEvent
:
:
ExecuteTriggersFinished
)
;
}
else
{
while
(
true
)
{
ThreadEvent
ev
=
(
ThreadEvent
)
thread
-
>
Events
(
)
.
ReadScalar
(
)
;
if
(
ev
!
=
ThreadEvent
:
:
ExecuteTrigger
)
{
if
(
ev
!
=
ThreadEvent
:
:
ExecuteTriggersFinished
)
{
child
:
:
ReportFatalError
(
"
ExecuteTrigger
Mismatch
"
)
;
Unreachable
(
)
;
}
break
;
}
size_t
id
=
thread
-
>
Events
(
)
.
ReadScalar
(
)
;
InvokeTriggerCallback
(
id
)
;
}
}
RecordReplayAssert
(
"
ExecuteTriggers
DONE
"
)
;
}
}
}
}
