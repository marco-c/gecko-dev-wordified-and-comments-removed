#
ifndef
mozilla_recordreplay_ExternalCall_h
#
define
mozilla_recordreplay_ExternalCall_h
#
include
"
BufferStream
.
h
"
#
include
"
ProcessRedirect
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
enum
class
ExternalCallPhase
{
SaveInput
RestoreInput
SaveOutput
RestoreOutput
}
;
typedef
uintptr_t
ExternalCallId
;
struct
CallReturnRegisters
{
size_t
rval0
rval1
;
double
floatrval0
floatrval1
;
void
CopyFrom
(
CallArguments
*
aArguments
)
;
void
CopyTo
(
CallArguments
*
aArguments
)
;
}
;
struct
ExternalCall
{
ExternalCallId
mId
=
0
;
size_t
mCallId
=
0
;
InfallibleVector
<
char
>
mInput
;
size_t
mExcludeInput
=
0
;
InfallibleVector
<
ExternalCallId
>
mDependentCalls
;
InfallibleVector
<
char
>
mOutput
;
CallReturnRegisters
mReturnRegisters
;
Maybe
<
const
void
*
>
mValue
;
void
EncodeInput
(
BufferStream
&
aStream
)
const
;
void
DecodeInput
(
BufferStream
&
aStream
)
;
void
EncodeOutput
(
BufferStream
&
aStream
)
const
;
void
DecodeOutput
(
BufferStream
&
aStream
)
;
void
ComputeId
(
)
{
MOZ_RELEASE_ASSERT
(
!
mId
)
;
size_t
extent
=
mExcludeInput
?
mExcludeInput
:
mInput
.
length
(
)
;
mId
=
HashGeneric
(
mCallId
HashBytes
(
mInput
.
begin
(
)
extent
)
)
;
if
(
!
mId
)
{
mId
=
1
;
}
}
}
;
struct
ExternalCallContext
{
ExternalCall
*
mCall
;
CallArguments
*
mArguments
;
ExternalCallPhase
mPhase
;
bool
mFailed
=
false
;
bool
mSkipExecuting
=
false
;
Maybe
<
BufferStream
>
mInputStream
;
Maybe
<
BufferStream
>
mOutputStream
;
typedef
InfallibleVector
<
std
:
:
function
<
void
(
)
>
>
ReleaseCallbackVector
;
ReleaseCallbackVector
*
mReleaseCallbacks
=
nullptr
;
ExternalCallContext
(
ExternalCall
*
aCall
CallArguments
*
aArguments
ExternalCallPhase
aPhase
)
:
mCall
(
aCall
)
mArguments
(
aArguments
)
mPhase
(
aPhase
)
{
switch
(
mPhase
)
{
case
ExternalCallPhase
:
:
SaveInput
:
mInputStream
.
emplace
(
&
mCall
-
>
mInput
)
;
break
;
case
ExternalCallPhase
:
:
RestoreInput
:
mInputStream
.
emplace
(
mCall
-
>
mInput
.
begin
(
)
mCall
-
>
mInput
.
length
(
)
)
;
break
;
case
ExternalCallPhase
:
:
SaveOutput
:
mCall
-
>
mReturnRegisters
.
CopyFrom
(
aArguments
)
;
mOutputStream
.
emplace
(
&
mCall
-
>
mOutput
)
;
break
;
case
ExternalCallPhase
:
:
RestoreOutput
:
mCall
-
>
mReturnRegisters
.
CopyTo
(
aArguments
)
;
mOutputStream
.
emplace
(
mCall
-
>
mOutput
.
begin
(
)
mCall
-
>
mOutput
.
length
(
)
)
;
break
;
}
}
void
MarkAsFailed
(
)
{
MOZ_RELEASE_ASSERT
(
mPhase
=
=
ExternalCallPhase
:
:
SaveInput
)
;
mFailed
=
true
;
}
void
WriteInputBytes
(
const
void
*
aBuffer
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
mPhase
=
=
ExternalCallPhase
:
:
SaveInput
)
;
mInputStream
.
ref
(
)
.
WriteBytes
(
aBuffer
aSize
)
;
}
void
WriteInputScalar
(
size_t
aValue
)
{
MOZ_RELEASE_ASSERT
(
mPhase
=
=
ExternalCallPhase
:
:
SaveInput
)
;
mInputStream
.
ref
(
)
.
WriteScalar
(
aValue
)
;
}
void
ReadInputBytes
(
void
*
aBuffer
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
mPhase
=
=
ExternalCallPhase
:
:
RestoreInput
)
;
mInputStream
.
ref
(
)
.
ReadBytes
(
aBuffer
aSize
)
;
}
size_t
ReadInputScalar
(
)
{
MOZ_RELEASE_ASSERT
(
mPhase
=
=
ExternalCallPhase
:
:
RestoreInput
)
;
return
mInputStream
.
ref
(
)
.
ReadScalar
(
)
;
}
bool
AccessInput
(
)
{
return
mInputStream
.
isSome
(
)
;
}
void
ReadOrWriteInputBytes
(
void
*
aBuffer
size_t
aSize
bool
aExcludeInput
=
false
)
{
switch
(
mPhase
)
{
case
ExternalCallPhase
:
:
SaveInput
:
MOZ_RELEASE_ASSERT
(
!
mCall
-
>
mExcludeInput
)
;
if
(
aExcludeInput
)
{
mCall
-
>
mExcludeInput
=
mCall
-
>
mInput
.
length
(
)
;
}
WriteInputBytes
(
aBuffer
aSize
)
;
break
;
case
ExternalCallPhase
:
:
RestoreInput
:
ReadInputBytes
(
aBuffer
aSize
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
}
void
ReadOrWriteInputBuffer
(
void
*
*
aBufferPtr
size_t
aSize
bool
aIncludeContents
=
true
)
{
switch
(
mPhase
)
{
case
ExternalCallPhase
:
:
SaveInput
:
if
(
aIncludeContents
)
{
WriteInputBytes
(
*
aBufferPtr
aSize
)
;
}
break
;
case
ExternalCallPhase
:
:
RestoreInput
:
*
aBufferPtr
=
AllocateBytes
(
aSize
)
;
if
(
aIncludeContents
)
{
ReadInputBytes
(
*
aBufferPtr
aSize
)
;
}
break
;
default
:
MOZ_CRASH
(
)
;
}
}
bool
AccessOutput
(
)
{
return
mOutputStream
.
isSome
(
)
;
}
void
ReadOrWriteOutputBytes
(
void
*
aBuffer
size_t
aSize
)
{
switch
(
mPhase
)
{
case
ExternalCallPhase
:
:
SaveOutput
:
mOutputStream
.
ref
(
)
.
WriteBytes
(
aBuffer
aSize
)
;
break
;
case
ExternalCallPhase
:
:
RestoreOutput
:
mOutputStream
.
ref
(
)
.
ReadBytes
(
aBuffer
aSize
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
}
void
ReadOrWriteOutputBuffer
(
void
*
*
aBuffer
size_t
aSize
)
{
if
(
AccessInput
(
)
)
{
bool
isNull
=
*
aBuffer
=
=
nullptr
;
ReadOrWriteInputBytes
(
&
isNull
sizeof
(
isNull
)
)
;
if
(
isNull
)
{
*
aBuffer
=
nullptr
;
}
else
if
(
mPhase
=
=
ExternalCallPhase
:
:
RestoreInput
)
{
*
aBuffer
=
AllocateBytes
(
aSize
)
;
}
}
if
(
AccessOutput
(
)
&
&
*
aBuffer
)
{
ReadOrWriteOutputBytes
(
*
aBuffer
aSize
)
;
}
}
void
*
AllocateBytes
(
size_t
aSize
)
;
}
;
bool
OnExternalCall
(
size_t
aCallId
CallArguments
*
aArguments
bool
aDiverged
)
;
void
ProcessExternalCall
(
const
char
*
aInputData
size_t
aInputSize
InfallibleVector
<
char
>
*
aOutputData
)
;
void
FlushExternalCalls
(
)
;
void
AddExternalCallOutput
(
ExternalCallId
aId
const
char
*
aOutput
size_t
aOutputSize
)
;
bool
HasExternalCallOutput
(
ExternalCallId
aId
InfallibleVector
<
char
>
*
aOutput
)
;
template
<
size_t
Arg
>
static
inline
void
EX_ScalarArg
(
ExternalCallContext
&
aCx
)
{
if
(
aCx
.
AccessInput
(
)
)
{
auto
&
arg
=
aCx
.
mArguments
-
>
Arg
<
Arg
size_t
>
(
)
;
aCx
.
ReadOrWriteInputBytes
(
&
arg
sizeof
(
arg
)
)
;
}
}
template
<
size_t
Arg
>
static
inline
void
EX_FloatArg
(
ExternalCallContext
&
aCx
)
{
if
(
aCx
.
AccessInput
(
)
)
{
auto
&
arg
=
aCx
.
mArguments
-
>
FloatArg
<
Arg
>
(
)
;
aCx
.
ReadOrWriteInputBytes
(
&
arg
sizeof
(
arg
)
)
;
}
}
template
<
size_t
BufferArg
size_t
CountArg
typename
ElemType
=
char
bool
IncludeContents
=
true
>
static
inline
void
EX_Buffer
(
ExternalCallContext
&
aCx
)
{
EX_ScalarArg
<
CountArg
>
(
aCx
)
;
if
(
aCx
.
AccessInput
(
)
)
{
auto
&
buffer
=
aCx
.
mArguments
-
>
Arg
<
BufferArg
void
*
>
(
)
;
auto
byteSize
=
aCx
.
mArguments
-
>
Arg
<
CountArg
size_t
>
(
)
*
sizeof
(
ElemType
)
;
aCx
.
ReadOrWriteInputBuffer
(
&
buffer
byteSize
IncludeContents
)
;
}
}
template
<
size_t
BufferArg
typename
Type
>
static
inline
void
EX_InParam
(
ExternalCallContext
&
aCx
)
{
if
(
aCx
.
AccessInput
(
)
)
{
auto
&
param
=
aCx
.
mArguments
-
>
Arg
<
BufferArg
void
*
>
(
)
;
bool
hasParam
=
!
!
param
;
aCx
.
ReadOrWriteInputBytes
(
&
hasParam
sizeof
(
hasParam
)
)
;
if
(
hasParam
)
{
aCx
.
ReadOrWriteInputBuffer
(
&
param
sizeof
(
Type
)
)
;
}
else
{
param
=
nullptr
;
}
}
}
template
<
size_t
StringArg
>
static
inline
void
EX_CString
(
ExternalCallContext
&
aCx
)
{
if
(
aCx
.
AccessInput
(
)
)
{
auto
&
buffer
=
aCx
.
mArguments
-
>
Arg
<
StringArg
char
*
>
(
)
;
size_t
len
=
(
aCx
.
mPhase
=
=
ExternalCallPhase
:
:
SaveInput
)
?
strlen
(
buffer
)
+
1
:
0
;
aCx
.
ReadOrWriteInputBytes
(
&
len
sizeof
(
len
)
)
;
aCx
.
ReadOrWriteInputBuffer
(
(
void
*
*
)
&
buffer
len
)
;
}
}
template
<
size_t
BufferArg
size_t
CountArg
typename
ElemType
>
static
inline
void
EX_WriteBuffer
(
ExternalCallContext
&
aCx
)
{
EX_ScalarArg
<
CountArg
>
(
aCx
)
;
auto
&
buffer
=
aCx
.
mArguments
-
>
Arg
<
BufferArg
void
*
>
(
)
;
auto
count
=
aCx
.
mArguments
-
>
Arg
<
CountArg
size_t
>
(
)
;
aCx
.
ReadOrWriteOutputBuffer
(
&
buffer
count
*
sizeof
(
ElemType
)
)
;
}
template
<
size_t
BufferArg
typename
Type
>
static
inline
void
EX_OutParam
(
ExternalCallContext
&
aCx
)
{
auto
&
buffer
=
aCx
.
mArguments
-
>
Arg
<
BufferArg
void
*
>
(
)
;
aCx
.
ReadOrWriteOutputBuffer
(
&
buffer
sizeof
(
Type
)
)
;
}
template
<
typename
Type
>
static
inline
void
EX_OversizeRval
(
ExternalCallContext
&
aCx
)
{
EX_OutParam
<
0
Type
>
(
aCx
)
;
}
template
<
size_t
ByteSize
>
static
inline
void
EX_StackArgumentData
(
ExternalCallContext
&
aCx
)
{
if
(
aCx
.
AccessInput
(
)
)
{
auto
stack
=
aCx
.
mArguments
-
>
StackAddress
<
0
>
(
)
;
aCx
.
ReadOrWriteInputBytes
(
stack
ByteSize
)
;
}
}
static
inline
void
EX_SkipExecuting
(
ExternalCallContext
&
aCx
)
{
if
(
aCx
.
mPhase
=
=
ExternalCallPhase
:
:
RestoreInput
)
{
aCx
.
mSkipExecuting
=
true
;
}
}
static
inline
void
EX_NoOp
(
ExternalCallContext
&
aCx
)
{
}
template
<
ExternalCallFn
Fn0
ExternalCallFn
Fn1
ExternalCallFn
Fn2
=
EX_NoOp
ExternalCallFn
Fn3
=
EX_NoOp
ExternalCallFn
Fn4
=
EX_NoOp
ExternalCallFn
Fn5
=
EX_NoOp
>
static
inline
void
EX_Compose
(
ExternalCallContext
&
aCx
)
{
Fn0
(
aCx
)
;
Fn1
(
aCx
)
;
Fn2
(
aCx
)
;
Fn3
(
aCx
)
;
Fn4
(
aCx
)
;
Fn5
(
aCx
)
;
}
bool
EX_SystemInput
(
ExternalCallContext
&
aCx
const
void
*
*
aThingPtr
)
;
void
EX_SystemOutput
(
ExternalCallContext
&
aCx
const
void
*
*
aOutput
bool
aUpdating
=
false
)
;
void
InitializeExternalCalls
(
)
;
}
}
#
endif
