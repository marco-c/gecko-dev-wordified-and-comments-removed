#
include
"
ExternalCall
.
h
"
#
include
<
unordered_map
>
namespace
mozilla
{
namespace
recordreplay
{
typedef
std
:
:
unordered_map
<
ExternalCallId
ExternalCall
*
>
CallsByIdMap
;
typedef
std
:
:
unordered_map
<
const
void
*
ExternalCallId
>
CallsByValueMap
;
struct
ExternalCallState
{
CallsByIdMap
mCallsById
;
CallsByValueMap
mCallsByValue
;
InfallibleVector
<
void
*
>
mAllocatedBuffers
;
}
;
static
ExternalCallState
*
gState
;
static
StaticInfallibleVector
<
ExternalCall
*
>
gUnflushedCalls
;
static
Monitor
*
gMonitor
;
void
InitializeExternalCalls
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
|
|
IsMiddleman
(
)
)
;
if
(
IsReplaying
(
)
)
{
gState
=
new
ExternalCallState
(
)
;
gMonitor
=
new
Monitor
(
)
;
}
}
static
void
SetExternalCallValue
(
ExternalCall
*
aCall
const
void
*
aValue
)
{
aCall
-
>
mValue
.
reset
(
)
;
aCall
-
>
mValue
.
emplace
(
aValue
)
;
gState
-
>
mCallsByValue
.
erase
(
aValue
)
;
gState
-
>
mCallsByValue
.
insert
(
CallsByValueMap
:
:
value_type
(
aValue
aCall
-
>
mId
)
)
;
}
static
void
GatherDependentCalls
(
InfallibleVector
<
ExternalCall
*
>
&
aOutgoingCalls
ExternalCall
*
aCall
)
{
for
(
ExternalCall
*
existing
:
aOutgoingCalls
)
{
if
(
existing
=
=
aCall
)
{
return
;
}
}
aOutgoingCalls
.
append
(
aCall
)
;
for
(
ExternalCallId
dependentId
:
aCall
-
>
mDependentCalls
)
{
auto
iter
=
gState
-
>
mCallsById
.
find
(
dependentId
)
;
MOZ_RELEASE_ASSERT
(
iter
!
=
gState
-
>
mCallsById
.
end
(
)
)
;
ExternalCall
*
dependent
=
iter
-
>
second
;
GatherDependentCalls
(
aOutgoingCalls
dependent
)
;
}
}
bool
OnExternalCall
(
size_t
aCallId
CallArguments
*
aArguments
bool
aDiverged
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
const
Redirection
&
redirection
=
GetRedirection
(
aCallId
)
;
MOZ_RELEASE_ASSERT
(
redirection
.
mExternalCall
)
;
const
char
*
messageName
=
"
"
;
if
(
!
strcmp
(
redirection
.
mName
"
objc_msgSend
"
)
)
{
messageName
=
aArguments
-
>
Arg
<
1
const
char
*
>
(
)
;
}
if
(
aDiverged
)
{
PrintSpew
(
"
OnExternalCall
Diverged
%
s
%
s
\
n
"
redirection
.
mName
messageName
)
;
}
MonitorAutoLock
lock
(
*
gMonitor
)
;
ExternalCall
*
call
=
new
ExternalCall
(
)
;
call
-
>
mCallId
=
aCallId
;
{
ExternalCallContext
cx
(
call
aArguments
ExternalCallPhase
:
:
SaveInput
)
;
redirection
.
mExternalCall
(
cx
)
;
if
(
cx
.
mFailed
)
{
delete
call
;
if
(
child
:
:
CurrentRepaintCannotFail
(
)
&
&
aDiverged
)
{
child
:
:
ReportFatalError
(
"
External
call
input
failed
:
%
s
\
n
"
redirection
.
mName
)
;
}
return
false
;
}
}
call
-
>
ComputeId
(
)
;
bool
isNewCall
=
false
;
auto
iter
=
gState
-
>
mCallsById
.
find
(
call
-
>
mId
)
;
if
(
iter
=
=
gState
-
>
mCallsById
.
end
(
)
)
{
isNewCall
=
true
;
gState
-
>
mCallsById
.
insert
(
CallsByIdMap
:
:
value_type
(
call
-
>
mId
call
)
)
;
}
else
{
delete
call
;
call
=
iter
-
>
second
;
if
(
aDiverged
)
{
ExternalCallContext
cx
(
call
aArguments
ExternalCallPhase
:
:
RestoreOutput
)
;
redirection
.
mExternalCall
(
cx
)
;
return
true
;
}
}
if
(
!
aDiverged
)
{
ExternalCallContext
cx
(
call
aArguments
ExternalCallPhase
:
:
SaveOutput
)
;
redirection
.
mExternalCall
(
cx
)
;
if
(
isNewCall
)
{
gUnflushedCalls
.
append
(
call
)
;
}
return
true
;
}
PrintSpew
(
"
OnExternalCall
Send
%
s
%
s
\
n
"
redirection
.
mName
messageName
)
;
InfallibleVector
<
ExternalCall
*
>
outgoingCalls
;
GatherDependentCalls
(
outgoingCalls
call
)
;
InfallibleVector
<
char
>
inputData
;
BufferStream
inputStream
(
&
inputData
)
;
for
(
int
i
=
outgoingCalls
.
length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
outgoingCalls
[
i
]
-
>
EncodeInput
(
inputStream
)
;
}
InfallibleVector
<
char
>
outputData
;
child
:
:
SendExternalCallRequest
(
call
-
>
mId
inputData
.
begin
(
)
inputData
.
length
(
)
&
outputData
)
;
BufferStream
outputStream
(
outputData
.
begin
(
)
outputData
.
length
(
)
)
;
call
-
>
DecodeOutput
(
outputStream
)
;
ExternalCallContext
cx
(
call
aArguments
ExternalCallPhase
:
:
RestoreOutput
)
;
redirection
.
mExternalCall
(
cx
)
;
return
true
;
}
void
ProcessExternalCall
(
const
char
*
aInputData
size_t
aInputSize
InfallibleVector
<
char
>
*
aOutputData
)
{
MOZ_RELEASE_ASSERT
(
IsMiddleman
(
)
)
;
gState
=
new
ExternalCallState
(
)
;
auto
&
calls
=
gState
-
>
mCallsById
;
BufferStream
inputStream
(
aInputData
aInputSize
)
;
ExternalCall
*
lastCall
=
nullptr
;
ExternalCallContext
:
:
ReleaseCallbackVector
releaseCallbacks
;
while
(
!
inputStream
.
IsEmpty
(
)
)
{
ExternalCall
*
call
=
new
ExternalCall
(
)
;
call
-
>
DecodeInput
(
inputStream
)
;
const
Redirection
&
redirection
=
GetRedirection
(
call
-
>
mCallId
)
;
MOZ_RELEASE_ASSERT
(
redirection
.
mExternalCall
)
;
PrintSpew
(
"
ProcessExternalCall
%
lu
%
s
\
n
"
call
-
>
mId
redirection
.
mName
)
;
CallArguments
arguments
;
bool
skipCall
;
{
ExternalCallContext
cx
(
call
&
arguments
ExternalCallPhase
:
:
RestoreInput
)
;
redirection
.
mExternalCall
(
cx
)
;
skipCall
=
cx
.
mSkipExecuting
;
}
if
(
!
skipCall
)
{
RecordReplayInvokeCall
(
redirection
.
mOriginalFunction
&
arguments
)
;
}
{
ExternalCallContext
cx
(
call
&
arguments
ExternalCallPhase
:
:
SaveOutput
)
;
cx
.
mReleaseCallbacks
=
&
releaseCallbacks
;
redirection
.
mExternalCall
(
cx
)
;
}
lastCall
=
call
;
MOZ_RELEASE_ASSERT
(
calls
.
find
(
call
-
>
mId
)
=
=
calls
.
end
(
)
)
;
calls
.
insert
(
CallsByIdMap
:
:
value_type
(
call
-
>
mId
call
)
)
;
}
BufferStream
outputStream
(
aOutputData
)
;
lastCall
-
>
EncodeOutput
(
outputStream
)
;
for
(
const
auto
&
callback
:
releaseCallbacks
)
{
callback
(
)
;
}
for
(
auto
iter
=
calls
.
begin
(
)
;
iter
!
=
calls
.
end
(
)
;
+
+
iter
)
{
delete
iter
-
>
second
;
}
for
(
auto
buffer
:
gState
-
>
mAllocatedBuffers
)
{
free
(
buffer
)
;
}
delete
gState
;
gState
=
nullptr
;
}
void
*
ExternalCallContext
:
:
AllocateBytes
(
size_t
aSize
)
{
void
*
rv
=
malloc
(
aSize
)
;
if
(
IsMiddleman
(
)
)
{
gState
-
>
mAllocatedBuffers
.
append
(
rv
)
;
}
return
rv
;
}
void
FlushExternalCalls
(
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
for
(
ExternalCall
*
call
:
gUnflushedCalls
)
{
InfallibleVector
<
char
>
outputData
;
BufferStream
outputStream
(
&
outputData
)
;
call
-
>
EncodeOutput
(
outputStream
)
;
child
:
:
SendExternalCallOutput
(
call
-
>
mId
outputData
.
begin
(
)
outputData
.
length
(
)
)
;
}
gUnflushedCalls
.
clear
(
)
;
}
struct
ExternalCallOutput
{
char
*
mOutput
;
size_t
mOutputSize
;
}
;
typedef
std
:
:
unordered_map
<
ExternalCallId
ExternalCallOutput
>
CallOutputMap
;
static
CallOutputMap
*
gCallOutputMap
;
void
AddExternalCallOutput
(
ExternalCallId
aId
const
char
*
aOutput
size_t
aOutputSize
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
!
gCallOutputMap
)
{
gCallOutputMap
=
new
CallOutputMap
(
)
;
}
ExternalCallOutput
output
;
output
.
mOutput
=
new
char
[
aOutputSize
]
;
memcpy
(
output
.
mOutput
aOutput
aOutputSize
)
;
output
.
mOutputSize
=
aOutputSize
;
gCallOutputMap
-
>
insert
(
CallOutputMap
:
:
value_type
(
aId
output
)
)
;
}
bool
HasExternalCallOutput
(
ExternalCallId
aId
InfallibleVector
<
char
>
*
aOutput
)
{
MonitorAutoLock
lock
(
*
gMonitor
)
;
if
(
!
gCallOutputMap
)
{
return
false
;
}
auto
iter
=
gCallOutputMap
-
>
find
(
aId
)
;
if
(
iter
=
=
gCallOutputMap
-
>
end
(
)
)
{
return
false
;
}
aOutput
-
>
append
(
iter
-
>
second
.
mOutput
iter
-
>
second
.
mOutputSize
)
;
return
true
;
}
static
ExternalCall
*
LookupExternalCall
(
const
void
*
aThing
)
{
CallsByValueMap
:
:
const_iterator
iter
=
gState
-
>
mCallsByValue
.
find
(
aThing
)
;
if
(
iter
!
=
gState
-
>
mCallsByValue
.
end
(
)
)
{
CallsByIdMap
:
:
const_iterator
iter2
=
gState
-
>
mCallsById
.
find
(
iter
-
>
second
)
;
if
(
iter2
!
=
gState
-
>
mCallsById
.
end
(
)
)
{
return
iter2
-
>
second
;
}
}
return
nullptr
;
}
static
Maybe
<
const
void
*
>
GetExternalCallValue
(
ExternalCallId
aId
)
{
auto
iter
=
gState
-
>
mCallsById
.
find
(
aId
)
;
if
(
iter
!
=
gState
-
>
mCallsById
.
end
(
)
)
{
return
iter
-
>
second
-
>
mValue
;
}
return
Nothing
(
)
;
}
bool
EX_SystemInput
(
ExternalCallContext
&
aCx
const
void
*
*
aThingPtr
)
{
MOZ_RELEASE_ASSERT
(
aCx
.
AccessInput
(
)
)
;
bool
isNull
=
*
aThingPtr
=
=
nullptr
;
aCx
.
ReadOrWriteInputBytes
(
&
isNull
sizeof
(
isNull
)
)
;
if
(
isNull
)
{
*
aThingPtr
=
nullptr
;
return
true
;
}
ExternalCallId
callId
=
0
;
if
(
aCx
.
mPhase
=
=
ExternalCallPhase
:
:
SaveInput
)
{
ExternalCall
*
call
=
LookupExternalCall
(
*
aThingPtr
)
;
if
(
call
)
{
callId
=
call
-
>
mId
;
MOZ_RELEASE_ASSERT
(
callId
)
;
aCx
.
mCall
-
>
mDependentCalls
.
append
(
call
-
>
mId
)
;
}
}
aCx
.
ReadOrWriteInputBytes
(
&
callId
sizeof
(
callId
)
)
;
if
(
aCx
.
mPhase
=
=
ExternalCallPhase
:
:
RestoreInput
)
{
if
(
callId
)
{
Maybe
<
const
void
*
>
value
=
GetExternalCallValue
(
callId
)
;
MOZ_RELEASE_ASSERT
(
value
.
isSome
(
)
)
;
*
aThingPtr
=
value
.
ref
(
)
;
}
}
return
callId
!
=
0
;
}
static
const
void
*
MangledSystemValue
(
ExternalCallId
aId
)
{
return
(
const
void
*
)
(
(
size_t
)
aId
|
(
1ULL
<
<
63
)
)
;
}
void
EX_SystemOutput
(
ExternalCallContext
&
aCx
const
void
*
*
aOutput
bool
aUpdating
)
{
if
(
!
aCx
.
AccessOutput
(
)
)
{
return
;
}
bool
isNull
=
false
;
Maybe
<
ExternalCallId
>
aliasedCall
;
if
(
aCx
.
mPhase
=
=
ExternalCallPhase
:
:
SaveOutput
)
{
SetExternalCallValue
(
aCx
.
mCall
*
aOutput
)
;
isNull
=
*
aOutput
=
=
nullptr
;
if
(
!
isNull
)
{
ExternalCall
*
call
=
LookupExternalCall
(
*
aOutput
)
;
if
(
call
)
{
aliasedCall
.
emplace
(
call
-
>
mId
)
;
}
}
}
aCx
.
ReadOrWriteOutputBytes
(
&
isNull
sizeof
(
isNull
)
)
;
aCx
.
ReadOrWriteOutputBytes
(
&
aliasedCall
sizeof
(
aliasedCall
)
)
;
if
(
aCx
.
mPhase
=
=
ExternalCallPhase
:
:
RestoreOutput
)
{
do
{
if
(
isNull
)
{
*
aOutput
=
nullptr
;
break
;
}
if
(
aliasedCall
.
isSome
(
)
)
{
auto
iter
=
gState
-
>
mCallsById
.
find
(
aliasedCall
.
ref
(
)
)
;
if
(
iter
!
=
gState
-
>
mCallsById
.
end
(
)
)
{
*
aOutput
=
iter
-
>
second
;
break
;
}
}
*
aOutput
=
MangledSystemValue
(
aCx
.
mCall
-
>
mId
)
;
}
while
(
false
)
;
SetExternalCallValue
(
aCx
.
mCall
*
aOutput
)
;
}
}
void
CallReturnRegisters
:
:
CopyFrom
(
CallArguments
*
aArguments
)
{
rval0
=
aArguments
-
>
Rval
<
size_t
0
>
(
)
;
rval1
=
aArguments
-
>
Rval
<
size_t
1
>
(
)
;
floatrval0
=
aArguments
-
>
FloatRval
<
0
>
(
)
;
floatrval1
=
aArguments
-
>
FloatRval
<
1
>
(
)
;
}
void
CallReturnRegisters
:
:
CopyTo
(
CallArguments
*
aArguments
)
{
aArguments
-
>
Rval
<
size_t
0
>
(
)
=
rval0
;
aArguments
-
>
Rval
<
size_t
1
>
(
)
=
rval1
;
aArguments
-
>
FloatRval
<
0
>
(
)
=
floatrval0
;
aArguments
-
>
FloatRval
<
1
>
(
)
=
floatrval1
;
}
void
ExternalCall
:
:
EncodeInput
(
BufferStream
&
aStream
)
const
{
aStream
.
WriteScalar
(
mId
)
;
aStream
.
WriteScalar
(
mCallId
)
;
aStream
.
WriteScalar
(
mExcludeInput
)
;
aStream
.
WriteScalar
(
mInput
.
length
(
)
)
;
aStream
.
WriteBytes
(
mInput
.
begin
(
)
mInput
.
length
(
)
)
;
}
void
ExternalCall
:
:
DecodeInput
(
BufferStream
&
aStream
)
{
mId
=
aStream
.
ReadScalar
(
)
;
mCallId
=
aStream
.
ReadScalar
(
)
;
mExcludeInput
=
aStream
.
ReadScalar
(
)
;
size_t
inputLength
=
aStream
.
ReadScalar
(
)
;
mInput
.
appendN
(
0
inputLength
)
;
aStream
.
ReadBytes
(
mInput
.
begin
(
)
inputLength
)
;
}
void
ExternalCall
:
:
EncodeOutput
(
BufferStream
&
aStream
)
const
{
aStream
.
WriteBytes
(
&
mReturnRegisters
sizeof
(
CallReturnRegisters
)
)
;
aStream
.
WriteScalar
(
mOutput
.
length
(
)
)
;
aStream
.
WriteBytes
(
mOutput
.
begin
(
)
mOutput
.
length
(
)
)
;
}
void
ExternalCall
:
:
DecodeOutput
(
BufferStream
&
aStream
)
{
aStream
.
ReadBytes
(
&
mReturnRegisters
sizeof
(
CallReturnRegisters
)
)
;
size_t
outputLength
=
aStream
.
ReadScalar
(
)
;
mOutput
.
appendN
(
0
outputLength
)
;
aStream
.
ReadBytes
(
mOutput
.
begin
(
)
outputLength
)
;
}
}
}
