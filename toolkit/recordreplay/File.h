#
ifndef
mozilla_recordreplay_File_h
#
define
mozilla_recordreplay_File_h
#
include
"
InfallibleVector
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
SpinLock
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
RecordReplay
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
struct
StreamChunkLocation
{
uint64_t
mOffset
;
uint32_t
mCompressedSize
;
uint32_t
mDecompressedSize
;
inline
bool
operator
=
=
(
const
StreamChunkLocation
&
aOther
)
const
{
return
mOffset
=
=
aOther
.
mOffset
&
&
mCompressedSize
=
=
aOther
.
mCompressedSize
&
&
mDecompressedSize
=
=
aOther
.
mDecompressedSize
;
}
}
;
enum
class
StreamName
{
Main
Lock
Event
Assert
Count
}
;
class
File
;
class
Stream
{
friend
class
File
;
File
*
mFile
;
StreamName
mName
;
size_t
mNameIndex
;
InfallibleVector
<
StreamChunkLocation
>
mChunks
;
UniquePtr
<
char
[
]
>
mBuffer
;
static
const
size_t
BUFFER_MAX
=
1024
*
1024
;
size_t
mBufferSize
;
size_t
mBufferLength
;
size_t
mBufferPos
;
size_t
mStreamPos
;
UniquePtr
<
char
[
]
>
mBallast
;
size_t
mBallastSize
;
size_t
mChunkIndex
;
size_t
mFlushedChunks
;
Stream
(
File
*
aFile
StreamName
aName
size_t
aNameIndex
)
:
mFile
(
aFile
)
mName
(
aName
)
mNameIndex
(
aNameIndex
)
mBuffer
(
nullptr
)
mBufferSize
(
0
)
mBufferLength
(
0
)
mBufferPos
(
0
)
mStreamPos
(
0
)
mBallast
(
nullptr
)
mBallastSize
(
0
)
mChunkIndex
(
0
)
mFlushedChunks
(
0
)
{
}
public
:
StreamName
Name
(
)
const
{
return
mName
;
}
size_t
NameIndex
(
)
const
{
return
mNameIndex
;
}
void
ReadBytes
(
void
*
aData
size_t
aSize
)
;
void
WriteBytes
(
const
void
*
aData
size_t
aSize
)
;
size_t
ReadScalar
(
)
;
void
WriteScalar
(
size_t
aValue
)
;
bool
AtEnd
(
)
;
inline
void
RecordOrReplayBytes
(
void
*
aData
size_t
aSize
)
{
if
(
IsRecording
(
)
)
{
WriteBytes
(
aData
aSize
)
;
}
else
{
ReadBytes
(
aData
aSize
)
;
}
}
template
<
typename
T
>
inline
void
RecordOrReplayScalar
(
T
*
aPtr
)
{
if
(
IsRecording
(
)
)
{
WriteScalar
(
(
size_t
)
*
aPtr
)
;
}
else
{
*
aPtr
=
(
T
)
ReadScalar
(
)
;
}
}
template
<
typename
T
>
inline
void
RecordOrReplayValue
(
T
*
aPtr
)
{
RecordOrReplayBytes
(
aPtr
sizeof
(
T
)
)
;
}
void
CheckInput
(
size_t
aValue
)
;
inline
void
RecordOrReplayThreadEvent
(
ThreadEvent
aEvent
)
{
CheckInput
(
(
size_t
)
aEvent
)
;
}
inline
size_t
StreamPosition
(
)
{
return
mStreamPos
;
}
private
:
enum
ShouldCopy
{
DontCopyExistingData
CopyExistingData
}
;
void
EnsureMemory
(
UniquePtr
<
char
[
]
>
*
aBuf
size_t
*
aSize
size_t
aNeededSize
size_t
aMaxSize
ShouldCopy
aCopy
)
;
void
Flush
(
bool
aTakeLock
)
;
static
size_t
BallastMaxSize
(
)
;
}
;
class
File
{
public
:
enum
Mode
{
WRITE
READ
}
;
friend
class
Stream
;
private
:
FileHandle
mFd
;
Mode
mMode
;
uint64_t
mWriteOffset
;
uint64_t
mLastIndexOffset
;
typedef
InfallibleVector
<
UniquePtr
<
Stream
>
>
StreamVector
;
StreamVector
mStreams
[
(
size_t
)
StreamName
:
:
Count
]
;
SpinLock
mLock
;
ReadWriteSpinLock
mStreamLock
;
void
Clear
(
)
{
mFd
=
0
;
mMode
=
READ
;
mWriteOffset
=
0
;
mLastIndexOffset
=
0
;
for
(
auto
&
vector
:
mStreams
)
{
vector
.
clear
(
)
;
}
PodZero
(
&
mLock
)
;
PodZero
(
&
mStreamLock
)
;
}
public
:
File
(
)
{
Clear
(
)
;
}
~
File
(
)
{
Close
(
)
;
}
bool
Open
(
const
char
*
aName
Mode
aMode
)
;
void
Close
(
)
;
bool
OpenForWriting
(
)
const
{
return
mFd
&
&
mMode
=
=
WRITE
;
}
bool
OpenForReading
(
)
const
{
return
mFd
&
&
mMode
=
=
READ
;
}
Stream
*
OpenStream
(
StreamName
aName
size_t
aNameIndex
)
;
void
PreventStreamWrites
(
)
{
mStreamLock
.
WriteLock
(
)
;
}
void
AllowStreamWrites
(
)
{
mStreamLock
.
WriteUnlock
(
)
;
}
bool
Flush
(
)
;
enum
class
ReadIndexResult
{
InvalidFile
EndOfFile
FoundIndex
}
;
ReadIndexResult
ReadNextIndex
(
InfallibleVector
<
Stream
*
>
*
aUpdatedStreams
)
;
private
:
StreamChunkLocation
WriteChunk
(
const
char
*
aStart
size_t
aCompressedSize
size_t
aDecompressedSize
bool
aTakeLock
)
;
void
ReadChunk
(
char
*
aDest
const
StreamChunkLocation
&
aChunk
)
;
}
;
}
}
#
endif
