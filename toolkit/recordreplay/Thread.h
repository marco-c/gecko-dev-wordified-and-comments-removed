#
ifndef
mozilla_recordreplay_Thread_h
#
define
mozilla_recordreplay_Thread_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
File
.
h
"
#
include
"
Lock
.
h
"
#
include
"
Monitor
.
h
"
#
include
<
pthread
.
h
>
#
include
<
setjmp
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
static
const
size_t
MainThreadId
=
1
;
static
const
size_t
MaxRecordedThreadId
=
70
;
static
const
size_t
MaxNumNonRecordedThreads
=
12
;
static
const
size_t
MaxThreadId
=
MaxRecordedThreadId
+
MaxNumNonRecordedThreads
;
typedef
pthread_t
NativeThreadId
;
class
Thread
{
public
:
typedef
void
(
*
Callback
)
(
void
*
)
;
private
:
static
Monitor
*
gMonitor
;
size_t
mId
;
bool
mPassThroughEvents
;
size_t
mDisallowEvents
;
bool
mDivergedFromRecording
;
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mShouldDivergeFromRecording
;
Callback
mStart
;
void
*
mStartArg
;
bool
mNeedsJoin
;
NativeThreadId
mNativeId
;
Stream
*
mEvents
;
uint8_t
*
mStackBase
;
size_t
mStackSize
;
FileHandle
mIdlefd
;
FileHandle
mNotifyfd
;
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mShouldIdle
;
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mIdle
;
std
:
:
function
<
void
(
)
>
mUnrecordedWaitCallback
;
bool
mUnrecordedWaitNotified
;
Maybe
<
size_t
>
mAtomicLockId
;
public
:
size_t
Id
(
)
{
return
mId
;
}
NativeThreadId
NativeId
(
)
{
return
mNativeId
;
}
Stream
&
Events
(
)
{
return
*
mEvents
;
}
uint8_t
*
StackBase
(
)
{
return
mStackBase
;
}
size_t
StackSize
(
)
{
return
mStackSize
;
}
inline
bool
IsMainThread
(
)
const
{
return
mId
=
=
MainThreadId
;
}
inline
bool
IsRecordedThread
(
)
const
{
return
mId
<
=
MaxRecordedThreadId
;
}
inline
bool
IsNonMainRecordedThread
(
)
const
{
return
IsRecordedThread
(
)
&
&
!
IsMainThread
(
)
;
}
void
SetPassThrough
(
bool
aPassThrough
)
{
MOZ_RELEASE_ASSERT
(
mPassThroughEvents
=
=
!
aPassThrough
)
;
mPassThroughEvents
=
aPassThrough
;
}
bool
PassThroughEvents
(
)
const
{
return
mPassThroughEvents
;
}
void
BeginDisallowEvents
(
)
{
mDisallowEvents
+
+
;
}
void
EndDisallowEvents
(
)
{
MOZ_RELEASE_ASSERT
(
mDisallowEvents
)
;
mDisallowEvents
-
-
;
}
bool
AreEventsDisallowed
(
)
const
{
return
mDisallowEvents
!
=
0
;
}
void
DivergeFromRecording
(
)
{
mDivergedFromRecording
=
true
;
}
bool
HasDivergedFromRecording
(
)
const
{
return
mDivergedFromRecording
;
}
void
SetShouldDivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
CurrentIsMainThread
(
)
)
;
mShouldDivergeFromRecording
=
true
;
Notify
(
mId
)
;
}
bool
MaybeDivergeFromRecording
(
)
{
if
(
mShouldDivergeFromRecording
)
{
mDivergedFromRecording
=
true
;
}
return
mDivergedFromRecording
;
}
bool
CanAccessRecording
(
)
const
{
return
!
PassThroughEvents
(
)
&
&
!
AreEventsDisallowed
(
)
&
&
!
HasDivergedFromRecording
(
)
;
}
static
void
ThreadMain
(
void
*
aArgument
)
;
void
BindToCurrent
(
)
;
static
void
InitializeThreads
(
)
;
static
Thread
*
Current
(
)
;
static
bool
CurrentIsMainThread
(
)
;
static
Thread
*
GetById
(
size_t
aId
)
;
static
Thread
*
GetByNativeId
(
NativeThreadId
aNativeId
)
;
static
Thread
*
GetByStackPointer
(
void
*
aSp
)
;
static
void
SpawnAllThreads
(
)
;
static
void
SpawnThread
(
Thread
*
aThread
)
;
static
Thread
*
SpawnNonRecordedThread
(
Callback
aStart
void
*
aArgument
)
;
static
void
WaitUntilInitialized
(
Thread
*
aThread
)
;
static
NativeThreadId
StartThread
(
Callback
aStart
void
*
aArgument
bool
aNeedsJoin
)
;
void
Join
(
)
;
Maybe
<
size_t
>
&
AtomicLockId
(
)
{
return
mAtomicLockId
;
}
static
void
Wait
(
)
;
static
void
WaitNoIdle
(
)
;
static
void
Notify
(
size_t
aId
)
;
static
void
WaitForever
(
)
;
static
void
WaitForeverNoIdle
(
)
;
void
NotifyUnrecordedWait
(
const
std
:
:
function
<
void
(
)
>
&
aNotifyCallback
)
;
bool
MaybeWaitForSnapshot
(
const
std
:
:
function
<
void
(
)
>
&
aReleaseCallback
)
;
static
void
WaitForIdleThreads
(
)
;
static
void
ResumeIdleThreads
(
)
;
static
void
ResumeSingleIdleThread
(
size_t
aId
)
;
bool
ShouldIdle
(
)
{
return
mShouldIdle
;
}
}
;
class
AutoEnsurePassThroughThreadEventsUseStackPointer
{
Thread
*
mThread
;
bool
mPassedThrough
;
public
:
AutoEnsurePassThroughThreadEventsUseStackPointer
(
)
:
mThread
(
Thread
:
:
GetByStackPointer
(
this
)
)
mPassedThrough
(
!
mThread
|
|
mThread
-
>
PassThroughEvents
(
)
)
{
if
(
!
mPassedThrough
)
{
mThread
-
>
SetPassThrough
(
true
)
;
}
}
~
AutoEnsurePassThroughThreadEventsUseStackPointer
(
)
{
if
(
!
mPassedThrough
)
{
mThread
-
>
SetPassThrough
(
false
)
;
}
}
}
;
class
MOZ_RAII
RecordingEventSection
{
Thread
*
mThread
;
public
:
explicit
RecordingEventSection
(
Thread
*
aThread
)
:
mThread
(
aThread
)
{
if
(
!
aThread
|
|
!
aThread
-
>
CanAccessRecording
(
)
)
{
return
;
}
if
(
IsRecording
(
)
)
{
MOZ_RELEASE_ASSERT
(
!
aThread
-
>
Events
(
)
.
mInRecordingEventSection
)
;
aThread
-
>
Events
(
)
.
mFile
-
>
mStreamLock
.
ReadLock
(
)
;
aThread
-
>
Events
(
)
.
mInRecordingEventSection
=
true
;
}
else
{
while
(
!
aThread
-
>
MaybeDivergeFromRecording
(
)
&
&
aThread
-
>
Events
(
)
.
AtEnd
(
)
)
{
HitEndOfRecording
(
)
;
}
}
}
~
RecordingEventSection
(
)
{
if
(
!
mThread
|
|
!
mThread
-
>
CanAccessRecording
(
)
)
{
return
;
}
if
(
IsRecording
(
)
)
{
mThread
-
>
Events
(
)
.
mFile
-
>
mStreamLock
.
ReadUnlock
(
)
;
mThread
-
>
Events
(
)
.
mInRecordingEventSection
=
false
;
}
}
bool
CanAccessEvents
(
)
{
if
(
!
mThread
|
|
mThread
-
>
PassThroughEvents
(
)
|
|
mThread
-
>
HasDivergedFromRecording
(
)
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
mThread
-
>
CanAccessRecording
(
)
)
;
return
true
;
}
}
;
}
}
#
endif
