#
ifndef
mozilla_recordreplay_Thread_h
#
define
mozilla_recordreplay_Thread_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
Recording
.
h
"
#
include
"
Lock
.
h
"
#
include
"
Monitor
.
h
"
#
include
<
pthread
.
h
>
namespace
mozilla
{
namespace
recordreplay
{
static
const
size_t
MainThreadId
=
1
;
static
const
size_t
MaxThreadId
=
70
;
class
Thread
{
public
:
typedef
void
(
*
Callback
)
(
void
*
)
;
enum
OwnedLockState
{
None
NeedRelease
NeedAcquire
}
;
private
:
static
Monitor
*
gMonitor
;
size_t
mId
;
bool
mPassThroughEvents
;
size_t
mDisallowEvents
;
bool
mDivergedFromRecording
;
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mShouldDivergeFromRecording
;
Callback
mStart
;
void
*
mStartArg
;
bool
mNeedsJoin
;
NativeThreadId
mNativeId
;
uintptr_t
mMachId
;
Stream
*
mEvents
;
uint8_t
*
mStackBase
;
size_t
mStackSize
;
FileHandle
mIdlefd
;
FileHandle
mNotifyfd
;
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mShouldIdle
;
Atomic
<
bool
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mIdle
;
Atomic
<
OwnedLockState
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
mOwnedLockState
;
std
:
:
function
<
void
(
)
>
mUnrecordedWaitCallback
;
bool
mUnrecordedWaitNotified
;
Maybe
<
size_t
>
mAtomicLockId
;
InfallibleVector
<
NativeLock
*
>
mOwnedLocks
;
struct
StorageEntry
{
uintptr_t
mKey
;
void
*
mData
;
StorageEntry
*
mNext
;
}
;
StorageEntry
*
mStorageEntries
;
uint8_t
*
mStorageCursor
;
uint8_t
*
mStorageLimit
;
uint8_t
*
AllocateStorage
(
size_t
aSize
)
;
public
:
uintptr_t
mRedirectionValue
;
InfallibleVector
<
char
>
mRedirectionData
;
size_t
Id
(
)
{
return
mId
;
}
NativeThreadId
NativeId
(
)
{
return
mNativeId
;
}
Stream
&
Events
(
)
{
return
*
mEvents
;
}
uint8_t
*
StackBase
(
)
{
return
mStackBase
;
}
size_t
StackSize
(
)
{
return
mStackSize
;
}
inline
bool
IsMainThread
(
)
const
{
return
mId
=
=
MainThreadId
;
}
void
SetPassThrough
(
bool
aPassThrough
)
{
MOZ_RELEASE_ASSERT
(
mPassThroughEvents
=
=
!
aPassThrough
)
;
mPassThroughEvents
=
aPassThrough
;
}
bool
PassThroughEvents
(
)
const
{
return
mPassThroughEvents
;
}
void
BeginDisallowEvents
(
)
{
mDisallowEvents
+
+
;
}
void
EndDisallowEvents
(
)
{
MOZ_RELEASE_ASSERT
(
mDisallowEvents
)
;
mDisallowEvents
-
-
;
}
bool
AreEventsDisallowed
(
)
const
{
return
mDisallowEvents
!
=
0
;
}
void
DivergeFromRecording
(
)
{
mDivergedFromRecording
=
true
;
}
bool
HasDivergedFromRecording
(
)
const
{
return
mDivergedFromRecording
;
}
void
SetShouldDivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
CurrentIsMainThread
(
)
)
;
mShouldDivergeFromRecording
=
true
;
Notify
(
mId
)
;
}
bool
MaybeDivergeFromRecording
(
)
{
if
(
mShouldDivergeFromRecording
)
{
mDivergedFromRecording
=
true
;
}
return
mDivergedFromRecording
;
}
bool
CanAccessRecording
(
)
const
{
return
!
PassThroughEvents
(
)
&
&
!
AreEventsDisallowed
(
)
&
&
!
HasDivergedFromRecording
(
)
;
}
uintptr_t
GetMachId
(
)
const
{
return
mMachId
;
}
static
void
ThreadMain
(
void
*
aArgument
)
;
void
BindToCurrent
(
)
;
static
void
InitializeThreads
(
)
;
static
Thread
*
Current
(
)
;
static
bool
CurrentIsMainThread
(
)
;
static
Thread
*
GetById
(
size_t
aId
)
;
static
Thread
*
GetByNativeId
(
NativeThreadId
aNativeId
)
;
static
void
SpawnAllThreads
(
)
;
static
void
RespawnAllThreadsAfterFork
(
)
;
static
NativeThreadId
SpawnThread
(
Thread
*
aThread
)
;
static
void
SpawnNonRecordedThread
(
Callback
aStart
void
*
aArgument
)
;
static
NativeThreadId
StartThread
(
Callback
aStart
void
*
aArgument
bool
aNeedsJoin
)
;
void
Join
(
)
;
Maybe
<
size_t
>
&
AtomicLockId
(
)
{
return
mAtomicLockId
;
}
void
AddOwnedLock
(
NativeLock
*
aLock
)
;
void
RemoveOwnedLock
(
NativeLock
*
aLock
)
;
void
ReleaseOrAcquireOwnedLocks
(
OwnedLockState
aState
)
;
void
*
*
GetOrCreateStorage
(
uintptr_t
aKey
)
;
static
void
Wait
(
)
;
static
void
WaitNoIdle
(
)
;
static
void
Notify
(
size_t
aId
)
;
static
void
WaitForever
(
)
;
static
void
WaitForeverNoIdle
(
)
;
void
NotifyUnrecordedWait
(
const
std
:
:
function
<
void
(
)
>
&
aNotifyCallback
)
;
bool
MaybeWaitForFork
(
const
std
:
:
function
<
void
(
)
>
&
aReleaseCallback
)
;
static
void
WaitForIdleThreads
(
)
;
static
void
OperateOnIdleThreadLocks
(
OwnedLockState
aState
)
;
static
void
ResumeIdleThreads
(
)
;
bool
ShouldIdle
(
)
{
return
mShouldIdle
;
}
static
size_t
TotalEventProgress
(
)
;
}
;
class
MOZ_RAII
RecordingEventSection
{
Thread
*
mThread
;
public
:
explicit
RecordingEventSection
(
Thread
*
aThread
)
:
mThread
(
aThread
)
{
if
(
!
aThread
|
|
!
aThread
-
>
CanAccessRecording
(
)
)
{
return
;
}
if
(
IsRecording
(
)
)
{
MOZ_RELEASE_ASSERT
(
!
aThread
-
>
Events
(
)
.
mInRecordingEventSection
)
;
aThread
-
>
Events
(
)
.
mRecording
-
>
mStreamLock
.
ReadLock
(
)
;
aThread
-
>
Events
(
)
.
mInRecordingEventSection
=
true
;
}
else
{
while
(
!
aThread
-
>
MaybeDivergeFromRecording
(
)
&
&
aThread
-
>
Events
(
)
.
AtEnd
(
)
)
{
HitEndOfRecording
(
)
;
}
}
}
~
RecordingEventSection
(
)
{
if
(
!
mThread
|
|
!
mThread
-
>
CanAccessRecording
(
)
)
{
return
;
}
if
(
IsRecording
(
)
)
{
mThread
-
>
Events
(
)
.
mRecording
-
>
mStreamLock
.
ReadUnlock
(
)
;
mThread
-
>
Events
(
)
.
mInRecordingEventSection
=
false
;
}
}
bool
CanAccessEvents
(
)
{
if
(
!
mThread
|
|
mThread
-
>
PassThroughEvents
(
)
|
|
mThread
-
>
HasDivergedFromRecording
(
)
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
mThread
-
>
CanAccessRecording
(
)
)
;
return
true
;
}
}
;
}
}
#
endif
