#
include
"
ProcessRewind
.
h
"
#
include
"
nsString
.
h
"
#
include
"
ipc
/
ChildInternal
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
MemorySnapshot
.
h
"
#
include
"
Monitor
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ThreadSnapshot
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
struct
RewindInfo
{
CheckpointId
mLastCheckpoint
;
bool
mIsActiveChild
;
InfallibleVector
<
SavedCheckpoint
1024
AllocPolicy
<
MemoryKind
:
:
Generic
>
>
mSavedCheckpoints
;
InfallibleVector
<
size_t
1024
AllocPolicy
<
MemoryKind
:
:
Generic
>
>
mShouldSaveCheckpoints
;
}
;
static
RewindInfo
*
gRewindInfo
;
static
Monitor
*
gMainThreadCallbackMonitor
;
static
StaticInfallibleVector
<
std
:
:
function
<
void
(
)
>
>
gMainThreadCallbacks
;
void
InitializeRewindState
(
)
{
MOZ_RELEASE_ASSERT
(
gRewindInfo
=
=
nullptr
)
;
void
*
memory
=
AllocateMemory
(
sizeof
(
RewindInfo
)
MemoryKind
:
:
Generic
)
;
gRewindInfo
=
new
(
memory
)
RewindInfo
(
)
;
gMainThreadCallbackMonitor
=
new
Monitor
(
)
;
}
static
bool
CheckpointPrecedes
(
const
CheckpointId
&
aFirst
const
CheckpointId
&
aSecond
)
{
return
aFirst
.
mNormal
<
aSecond
.
mNormal
|
|
aFirst
.
mTemporary
<
aSecond
.
mTemporary
;
}
void
RestoreCheckpointAndResume
(
const
CheckpointId
&
aCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
aCheckpoint
=
=
gRewindInfo
-
>
mLastCheckpoint
|
|
CheckpointPrecedes
(
aCheckpoint
gRewindInfo
-
>
mLastCheckpoint
)
)
;
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
MOZ_RELEASE_ASSERT
(
gMainThreadCallbacks
.
empty
(
)
)
;
}
Thread
:
:
WaitForIdleThreads
(
)
;
double
start
=
CurrentTime
(
)
;
{
AutoDisallowMemoryChanges
disallow
;
CheckpointId
newCheckpoint
=
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
mCheckpoint
;
RestoreMemoryToLastSavedCheckpoint
(
)
;
while
(
CheckpointPrecedes
(
aCheckpoint
newCheckpoint
)
)
{
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
ReleaseContents
(
)
;
gRewindInfo
-
>
mSavedCheckpoints
.
popBack
(
)
;
RestoreMemoryToLastSavedDiffCheckpoint
(
)
;
newCheckpoint
=
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
mCheckpoint
;
}
MOZ_RELEASE_ASSERT
(
newCheckpoint
=
=
aCheckpoint
)
;
}
FixupFreeRegionsAfterRewind
(
)
;
double
end
=
CurrentTime
(
)
;
PrintSpew
(
"
Restore
#
%
d
:
%
d
-
>
#
%
d
:
%
d
%
.
2fs
\
n
"
(
int
)
gRewindInfo
-
>
mLastCheckpoint
.
mNormal
(
int
)
gRewindInfo
-
>
mLastCheckpoint
.
mTemporary
(
int
)
aCheckpoint
.
mNormal
(
int
)
aCheckpoint
.
mTemporary
(
end
-
start
)
/
1000000
.
0
)
;
RestoreAllThreads
(
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
)
;
Unreachable
(
)
;
}
void
SetSaveCheckpoint
(
size_t
aCheckpoint
bool
aSave
)
{
MOZ_RELEASE_ASSERT
(
aCheckpoint
>
gRewindInfo
-
>
mLastCheckpoint
.
mNormal
)
;
VectorAddOrRemoveEntry
(
gRewindInfo
-
>
mShouldSaveCheckpoints
aCheckpoint
aSave
)
;
}
bool
NewCheckpoint
(
bool
aTemporary
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
|
|
!
aTemporary
)
;
navigation
:
:
BeforeCheckpoint
(
)
;
CheckpointId
checkpoint
=
gRewindInfo
-
>
mLastCheckpoint
.
NextCheckpoint
(
aTemporary
)
;
bool
save
=
aTemporary
|
|
VectorContains
(
gRewindInfo
-
>
mShouldSaveCheckpoints
checkpoint
.
mNormal
)
;
bool
reachedCheckpoint
=
true
;
if
(
save
)
{
Thread
:
:
WaitForIdleThreads
(
)
;
PrintSpew
(
"
Starting
checkpoint
.
.
.
\
n
"
)
;
double
start
=
CurrentTime
(
)
;
if
(
gRewindInfo
-
>
mSavedCheckpoints
.
empty
(
)
)
{
TakeFirstMemorySnapshot
(
)
;
}
else
{
TakeDiffMemorySnapshot
(
)
;
}
gRewindInfo
-
>
mSavedCheckpoints
.
emplaceBack
(
checkpoint
)
;
double
end
=
CurrentTime
(
)
;
if
(
SaveAllThreads
(
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
)
)
{
PrintSpew
(
"
Saved
checkpoint
#
%
d
:
%
d
%
.
2fs
\
n
"
(
int
)
checkpoint
.
mNormal
(
int
)
checkpoint
.
mTemporary
(
end
-
start
)
/
1000000
.
0
)
;
}
else
{
PrintSpew
(
"
Restored
checkpoint
#
%
d
:
%
d
\
n
"
(
int
)
checkpoint
.
mNormal
(
int
)
checkpoint
.
mTemporary
)
;
reachedCheckpoint
=
false
;
WaitForIdleThreadsToRestoreTheirStacks
(
)
;
}
Thread
:
:
ResumeIdleThreads
(
)
;
}
gRewindInfo
-
>
mLastCheckpoint
=
checkpoint
;
navigation
:
:
AfterCheckpoint
(
checkpoint
)
;
return
reachedCheckpoint
;
}
static
bool
gRecordingDiverged
;
static
bool
gUnhandledDivergeAllowed
;
void
DivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
gRecordingDiverged
=
true
;
gUnhandledDivergeAllowed
=
true
;
}
extern
"
C
"
{
MOZ_EXPORT
bool
RecordReplayInterface_InternalHasDivergedFromRecording
(
)
{
return
Thread
:
:
CurrentIsMainThread
(
)
&
&
gRecordingDiverged
;
}
}
void
DisallowUnhandledDivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
gUnhandledDivergeAllowed
=
false
;
}
void
EnsureNotDivergedFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
if
(
HasDivergedFromRecording
(
)
)
{
MOZ_RELEASE_ASSERT
(
gUnhandledDivergeAllowed
)
;
PrintSpew
(
"
Unhandled
recording
divergence
restoring
checkpoint
.
.
.
\
n
"
)
;
RestoreCheckpointAndResume
(
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
mCheckpoint
)
;
Unreachable
(
)
;
}
}
bool
HasSavedCheckpoint
(
)
{
return
gRewindInfo
&
&
!
gRewindInfo
-
>
mSavedCheckpoints
.
empty
(
)
;
}
CheckpointId
GetLastSavedCheckpoint
(
)
{
MOZ_RELEASE_ASSERT
(
HasSavedCheckpoint
(
)
)
;
return
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
mCheckpoint
;
}
static
bool
gMainThreadShouldPause
=
false
;
bool
MainThreadShouldPause
(
)
{
return
gMainThreadShouldPause
;
}
void
PauseMainThreadAndServiceCallbacks
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gRecordingDiverged
)
;
static
bool
gMainThreadIsPaused
=
false
;
if
(
gMainThreadIsPaused
)
{
return
;
}
gMainThreadIsPaused
=
true
;
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
while
(
gMainThreadShouldPause
)
{
if
(
!
gMainThreadCallbacks
.
empty
(
)
)
{
std
:
:
function
<
void
(
)
>
callback
=
gMainThreadCallbacks
[
0
]
;
gMainThreadCallbacks
.
erase
(
&
gMainThreadCallbacks
[
0
]
)
;
{
MonitorAutoUnlock
unlock
(
*
gMainThreadCallbackMonitor
)
;
AutoDisallowThreadEvents
disallow
;
callback
(
)
;
}
}
else
{
gMainThreadCallbackMonitor
-
>
Wait
(
)
;
}
}
MOZ_RELEASE_ASSERT
(
gMainThreadCallbacks
.
empty
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gRecordingDiverged
)
;
gMainThreadIsPaused
=
false
;
}
void
PauseMainThreadAndInvokeCallback
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
gMainThreadShouldPause
=
true
;
gMainThreadCallbacks
.
append
(
aCallback
)
;
gMainThreadCallbackMonitor
-
>
Notify
(
)
;
}
if
(
Thread
:
:
CurrentIsMainThread
(
)
)
{
PauseMainThreadAndServiceCallbacks
(
)
;
}
}
void
ResumeExecution
(
)
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
gMainThreadShouldPause
=
false
;
gMainThreadCallbackMonitor
-
>
Notify
(
)
;
}
void
SetIsActiveChild
(
bool
aActive
)
{
gRewindInfo
-
>
mIsActiveChild
=
aActive
;
}
bool
IsActiveChild
(
)
{
return
gRewindInfo
-
>
mIsActiveChild
;
}
}
}
