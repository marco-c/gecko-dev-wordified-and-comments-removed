#
include
"
ProcessRewind
.
h
"
#
include
"
nsString
.
h
"
#
include
"
ipc
/
ChildInternal
.
h
"
#
include
"
ipc
/
ParentInternal
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
MemorySnapshot
.
h
"
#
include
"
Monitor
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ThreadSnapshot
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
static
size_t
gLastCheckpoint
=
InvalidCheckpointId
;
struct
RewindInfo
{
InfallibleVector
<
AllSavedThreadStacks
1024
AllocPolicy
<
MemoryKind
:
:
Generic
>
>
mSnapshots
;
}
;
static
RewindInfo
*
gRewindInfo
;
static
Monitor
*
gMainThreadCallbackMonitor
;
static
StaticInfallibleVector
<
std
:
:
function
<
void
(
)
>
>
gMainThreadCallbacks
;
void
InitializeRewindState
(
)
{
MOZ_RELEASE_ASSERT
(
gRewindInfo
=
=
nullptr
)
;
void
*
memory
=
AllocateMemory
(
sizeof
(
RewindInfo
)
MemoryKind
:
:
Generic
)
;
gRewindInfo
=
new
(
memory
)
RewindInfo
(
)
;
gMainThreadCallbackMonitor
=
new
Monitor
(
)
;
}
void
RestoreSnapshotAndResume
(
size_t
aNumSnapshots
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
aNumSnapshots
<
gRewindInfo
-
>
mSnapshots
.
length
(
)
)
;
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
MOZ_RELEASE_ASSERT
(
gMainThreadCallbacks
.
empty
(
)
)
;
}
Thread
:
:
WaitForIdleThreads
(
)
;
double
start
=
CurrentTime
(
)
;
{
AutoDisallowMemoryChanges
disallow
;
RestoreMemoryToLastSnapshot
(
)
;
for
(
size_t
i
=
0
;
i
<
aNumSnapshots
;
i
+
+
)
{
gRewindInfo
-
>
mSnapshots
.
back
(
)
.
ReleaseContents
(
)
;
gRewindInfo
-
>
mSnapshots
.
popBack
(
)
;
RestoreMemoryToLastDiffSnapshot
(
)
;
}
}
FixupFreeRegionsAfterRewind
(
)
;
double
end
=
CurrentTime
(
)
;
PrintSpew
(
"
Restore
%
.
2fs
\
n
"
(
end
-
start
)
/
1000000
.
0
)
;
RestoreAllThreads
(
gRewindInfo
-
>
mSnapshots
.
back
(
)
)
;
Unreachable
(
)
;
}
bool
NewSnapshot
(
)
{
if
(
IsRecording
(
)
)
{
return
true
;
}
Thread
:
:
WaitForIdleThreads
(
)
;
PrintSpew
(
"
Saving
snapshot
.
.
.
\
n
"
)
;
double
start
=
CurrentTime
(
)
;
if
(
gRewindInfo
-
>
mSnapshots
.
empty
(
)
)
{
TakeFirstMemorySnapshot
(
)
;
}
else
{
TakeDiffMemorySnapshot
(
)
;
}
gRewindInfo
-
>
mSnapshots
.
emplaceBack
(
)
;
double
end
=
CurrentTime
(
)
;
bool
reached
=
true
;
if
(
SaveAllThreads
(
gRewindInfo
-
>
mSnapshots
.
back
(
)
)
)
{
PrintSpew
(
"
Saved
snapshot
%
.
2fs
\
n
"
(
end
-
start
)
/
1000000
.
0
)
;
}
else
{
PrintSpew
(
"
Restored
snapshot
\
n
"
)
;
reached
=
false
;
WaitForIdleThreadsToRestoreTheirStacks
(
)
;
}
Thread
:
:
ResumeIdleThreads
(
)
;
return
reached
;
}
void
NewCheckpoint
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
gLastCheckpoint
+
+
;
js
:
:
HitCheckpoint
(
gLastCheckpoint
)
;
}
static
bool
gUnhandledDivergeAllowed
;
void
DivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
MOZ_RELEASE_ASSERT
(
thread
-
>
IsMainThread
(
)
)
;
if
(
!
thread
-
>
HasDivergedFromRecording
(
)
)
{
child
:
:
SendResetMiddlemanCalls
(
)
;
thread
-
>
DivergeFromRecording
(
)
;
Thread
:
:
WaitForIdleThreads
(
)
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
Thread
:
:
GetById
(
i
)
-
>
SetShouldDivergeFromRecording
(
)
;
}
Thread
:
:
ResumeIdleThreads
(
)
;
}
gUnhandledDivergeAllowed
=
true
;
}
extern
"
C
"
{
MOZ_EXPORT
bool
RecordReplayInterface_InternalHasDivergedFromRecording
(
)
{
Thread
*
thread
=
Thread
:
:
Current
(
)
;
return
thread
&
&
thread
-
>
HasDivergedFromRecording
(
)
;
}
}
void
DisallowUnhandledDivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
gUnhandledDivergeAllowed
=
false
;
}
void
EnsureNotDivergedFromRecording
(
)
{
AssertEventsAreNotPassedThrough
(
)
;
if
(
HasDivergedFromRecording
(
)
)
{
MOZ_RELEASE_ASSERT
(
gUnhandledDivergeAllowed
)
;
if
(
child
:
:
CurrentRepaintCannotFail
(
)
)
{
MOZ_CRASH
(
"
Recording
divergence
while
repainting
"
)
;
}
PrintSpew
(
"
Unhandled
recording
divergence
restoring
snapshot
.
.
.
\
n
"
)
;
RestoreSnapshotAndResume
(
0
)
;
Unreachable
(
)
;
}
}
size_t
NumSnapshots
(
)
{
return
gRewindInfo
?
gRewindInfo
-
>
mSnapshots
.
length
(
)
:
0
;
}
size_t
GetLastCheckpoint
(
)
{
return
gLastCheckpoint
;
}
static
bool
gMainThreadShouldPause
=
false
;
bool
MainThreadShouldPause
(
)
{
return
gMainThreadShouldPause
;
}
void
PauseMainThreadAndServiceCallbacks
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
AssertEventsAreNotPassedThrough
(
)
;
static
bool
gMainThreadIsPaused
=
false
;
if
(
gMainThreadIsPaused
)
{
return
;
}
gMainThreadIsPaused
=
true
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
while
(
gMainThreadShouldPause
)
{
if
(
!
gMainThreadCallbacks
.
empty
(
)
)
{
std
:
:
function
<
void
(
)
>
callback
=
gMainThreadCallbacks
[
0
]
;
gMainThreadCallbacks
.
erase
(
&
gMainThreadCallbacks
[
0
]
)
;
{
MonitorAutoUnlock
unlock
(
*
gMainThreadCallbackMonitor
)
;
AutoDisallowThreadEvents
disallow
;
callback
(
)
;
}
}
else
{
gMainThreadCallbackMonitor
-
>
Wait
(
)
;
}
}
MOZ_RELEASE_ASSERT
(
gMainThreadCallbacks
.
empty
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
gMainThreadIsPaused
=
false
;
}
void
PauseMainThreadAndInvokeCallback
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
gMainThreadShouldPause
=
true
;
gMainThreadCallbacks
.
append
(
aCallback
)
;
gMainThreadCallbackMonitor
-
>
Notify
(
)
;
}
if
(
Thread
:
:
CurrentIsMainThread
(
)
)
{
PauseMainThreadAndServiceCallbacks
(
)
;
}
}
void
ResumeExecution
(
)
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
gMainThreadShouldPause
=
false
;
gMainThreadCallbackMonitor
-
>
Notify
(
)
;
}
}
}
