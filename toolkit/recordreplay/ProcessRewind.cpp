#
include
"
ProcessRewind
.
h
"
#
include
"
nsString
.
h
"
#
include
"
ipc
/
ChildInternal
.
h
"
#
include
"
ipc
/
ParentInternal
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
MemorySnapshot
.
h
"
#
include
"
Monitor
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
#
include
"
ThreadSnapshot
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
struct
RewindInfo
{
size_t
mLastCheckpoint
;
InfallibleVector
<
SavedCheckpoint
1024
AllocPolicy
<
MemoryKind
:
:
Generic
>
>
mSavedCheckpoints
;
InfallibleVector
<
size_t
1024
AllocPolicy
<
MemoryKind
:
:
Generic
>
>
mShouldSaveCheckpoints
;
}
;
static
RewindInfo
*
gRewindInfo
;
static
Monitor
*
gMainThreadCallbackMonitor
;
static
StaticInfallibleVector
<
std
:
:
function
<
void
(
)
>
>
gMainThreadCallbacks
;
void
InitializeRewindState
(
)
{
MOZ_RELEASE_ASSERT
(
gRewindInfo
=
=
nullptr
)
;
void
*
memory
=
AllocateMemory
(
sizeof
(
RewindInfo
)
MemoryKind
:
:
Generic
)
;
gRewindInfo
=
new
(
memory
)
RewindInfo
(
)
;
if
(
IsReplaying
(
)
)
{
gRewindInfo
-
>
mShouldSaveCheckpoints
.
append
(
FirstCheckpointId
)
;
}
gMainThreadCallbackMonitor
=
new
Monitor
(
)
;
}
void
RestoreCheckpointAndResume
(
size_t
aCheckpoint
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
aCheckpoint
=
=
gRewindInfo
-
>
mLastCheckpoint
|
|
aCheckpoint
<
gRewindInfo
-
>
mLastCheckpoint
)
;
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
MOZ_RELEASE_ASSERT
(
gMainThreadCallbacks
.
empty
(
)
)
;
}
Thread
:
:
WaitForIdleThreads
(
)
;
double
start
=
CurrentTime
(
)
;
{
AutoDisallowMemoryChanges
disallow
;
size_t
newCheckpoint
=
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
mCheckpoint
;
RestoreMemoryToLastSavedCheckpoint
(
)
;
while
(
aCheckpoint
<
newCheckpoint
)
{
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
ReleaseContents
(
)
;
gRewindInfo
-
>
mSavedCheckpoints
.
popBack
(
)
;
RestoreMemoryToLastSavedDiffCheckpoint
(
)
;
newCheckpoint
=
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
mCheckpoint
;
}
MOZ_RELEASE_ASSERT
(
newCheckpoint
=
=
aCheckpoint
)
;
}
FixupFreeRegionsAfterRewind
(
)
;
double
end
=
CurrentTime
(
)
;
PrintSpew
(
"
Restore
#
%
d
-
>
#
%
d
%
.
2fs
\
n
"
(
int
)
gRewindInfo
-
>
mLastCheckpoint
(
int
)
aCheckpoint
(
end
-
start
)
/
1000000
.
0
)
;
RestoreAllThreads
(
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
)
;
Unreachable
(
)
;
}
void
SetSaveCheckpoint
(
size_t
aCheckpoint
bool
aSave
)
{
MOZ_RELEASE_ASSERT
(
aCheckpoint
>
gRewindInfo
-
>
mLastCheckpoint
)
;
VectorAddOrRemoveEntry
(
gRewindInfo
-
>
mShouldSaveCheckpoints
aCheckpoint
aSave
)
;
}
bool
NewCheckpoint
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
js
:
:
BeforeCheckpoint
(
)
;
size_t
checkpoint
=
gRewindInfo
-
>
mLastCheckpoint
+
1
;
bool
save
=
VectorContains
(
gRewindInfo
-
>
mShouldSaveCheckpoints
checkpoint
)
;
bool
reachedCheckpoint
=
true
;
if
(
save
)
{
Thread
:
:
WaitForIdleThreads
(
)
;
PrintSpew
(
"
Starting
checkpoint
.
.
.
\
n
"
)
;
double
start
=
CurrentTime
(
)
;
if
(
gRewindInfo
-
>
mSavedCheckpoints
.
empty
(
)
)
{
TakeFirstMemorySnapshot
(
)
;
}
else
{
TakeDiffMemorySnapshot
(
)
;
}
gRewindInfo
-
>
mSavedCheckpoints
.
emplaceBack
(
checkpoint
)
;
double
end
=
CurrentTime
(
)
;
if
(
SaveAllThreads
(
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
)
)
{
PrintSpew
(
"
Saved
checkpoint
#
%
d
%
.
2fs
\
n
"
(
int
)
checkpoint
(
end
-
start
)
/
1000000
.
0
)
;
}
else
{
PrintSpew
(
"
Restored
checkpoint
#
%
d
\
n
"
(
int
)
checkpoint
)
;
reachedCheckpoint
=
false
;
WaitForIdleThreadsToRestoreTheirStacks
(
)
;
}
Thread
:
:
ResumeIdleThreads
(
)
;
}
else
{
PrintSpew
(
"
Skipping
checkpoint
#
%
d
\
n
"
(
int
)
checkpoint
)
;
}
gRewindInfo
-
>
mLastCheckpoint
=
checkpoint
;
js
:
:
AfterCheckpoint
(
checkpoint
!
reachedCheckpoint
)
;
return
reachedCheckpoint
;
}
static
bool
gUnhandledDivergeAllowed
;
void
DivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
MOZ_RELEASE_ASSERT
(
thread
-
>
IsMainThread
(
)
)
;
if
(
!
thread
-
>
HasDivergedFromRecording
(
)
)
{
child
:
:
SendResetMiddlemanCalls
(
)
;
Thread
:
:
WaitForIdleThreads
(
)
;
thread
-
>
DivergeFromRecording
(
)
;
}
gUnhandledDivergeAllowed
=
true
;
}
extern
"
C
"
{
MOZ_EXPORT
bool
RecordReplayInterface_InternalHasDivergedFromRecording
(
)
{
Thread
*
thread
=
Thread
:
:
Current
(
)
;
return
thread
&
&
thread
-
>
HasDivergedFromRecording
(
)
;
}
}
void
DisallowUnhandledDivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
gUnhandledDivergeAllowed
=
false
;
}
void
EnsureNotDivergedFromRecording
(
)
{
AssertEventsAreNotPassedThrough
(
)
;
if
(
HasDivergedFromRecording
(
)
)
{
MOZ_RELEASE_ASSERT
(
gUnhandledDivergeAllowed
)
;
if
(
child
:
:
CurrentRepaintCannotFail
(
)
)
{
MOZ_CRASH
(
"
Recording
divergence
while
repainting
"
)
;
}
PrintSpew
(
"
Unhandled
recording
divergence
restoring
checkpoint
.
.
.
\
n
"
)
;
RestoreCheckpointAndResume
(
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
mCheckpoint
)
;
Unreachable
(
)
;
}
}
bool
HasSavedAnyCheckpoint
(
)
{
return
gRewindInfo
&
&
!
gRewindInfo
-
>
mSavedCheckpoints
.
empty
(
)
;
}
bool
HasSavedCheckpoint
(
size_t
aCheckpoint
)
{
if
(
!
gRewindInfo
)
{
return
false
;
}
for
(
const
SavedCheckpoint
&
saved
:
gRewindInfo
-
>
mSavedCheckpoints
)
{
if
(
saved
.
mCheckpoint
=
=
aCheckpoint
)
{
return
true
;
}
}
return
false
;
}
size_t
GetLastCheckpoint
(
)
{
return
gRewindInfo
?
gRewindInfo
-
>
mLastCheckpoint
:
InvalidCheckpointId
;
}
size_t
GetLastSavedCheckpoint
(
)
{
MOZ_RELEASE_ASSERT
(
HasSavedAnyCheckpoint
(
)
)
;
return
gRewindInfo
-
>
mSavedCheckpoints
.
back
(
)
.
mCheckpoint
;
}
static
bool
gMainThreadShouldPause
=
false
;
bool
MainThreadShouldPause
(
)
{
return
gMainThreadShouldPause
;
}
void
PauseMainThreadAndServiceCallbacks
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
AssertEventsAreNotPassedThrough
(
)
;
static
bool
gMainThreadIsPaused
=
false
;
if
(
gMainThreadIsPaused
)
{
return
;
}
gMainThreadIsPaused
=
true
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
while
(
gMainThreadShouldPause
)
{
if
(
!
gMainThreadCallbacks
.
empty
(
)
)
{
std
:
:
function
<
void
(
)
>
callback
=
gMainThreadCallbacks
[
0
]
;
gMainThreadCallbacks
.
erase
(
&
gMainThreadCallbacks
[
0
]
)
;
{
MonitorAutoUnlock
unlock
(
*
gMainThreadCallbackMonitor
)
;
AutoDisallowThreadEvents
disallow
;
callback
(
)
;
}
}
else
{
gMainThreadCallbackMonitor
-
>
Wait
(
)
;
}
}
MOZ_RELEASE_ASSERT
(
gMainThreadCallbacks
.
empty
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
gMainThreadIsPaused
=
false
;
}
void
PauseMainThreadAndInvokeCallback
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
gMainThreadShouldPause
=
true
;
gMainThreadCallbacks
.
append
(
aCallback
)
;
gMainThreadCallbackMonitor
-
>
Notify
(
)
;
}
if
(
Thread
:
:
CurrentIsMainThread
(
)
)
{
PauseMainThreadAndServiceCallbacks
(
)
;
}
}
void
ResumeExecution
(
)
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
gMainThreadShouldPause
=
false
;
gMainThreadCallbackMonitor
-
>
Notify
(
)
;
}
}
}
