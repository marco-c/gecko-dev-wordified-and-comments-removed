#
include
"
ProcessRewind
.
h
"
#
include
"
ipc
/
ChildInternal
.
h
"
#
include
"
ipc
/
ParentInternal
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
Monitor
.
h
"
#
include
"
ProcessRecordReplay
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
static
size_t
gLastCheckpoint
=
InvalidCheckpointId
;
static
Monitor
*
gMainThreadCallbackMonitor
;
static
StaticInfallibleVector
<
std
:
:
function
<
void
(
)
>
>
gMainThreadCallbacks
;
void
InitializeRewindState
(
)
{
gMainThreadCallbackMonitor
=
new
Monitor
(
)
;
}
void
NewCheckpoint
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
AreThreadEventsPassedThrough
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
gLastCheckpoint
+
+
;
js
:
:
HitCheckpoint
(
gLastCheckpoint
)
;
}
static
bool
gUnhandledDivergeAllowed
;
void
DivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
Thread
*
thread
=
Thread
:
:
Current
(
)
;
MOZ_RELEASE_ASSERT
(
thread
-
>
IsMainThread
(
)
)
;
gUnhandledDivergeAllowed
=
true
;
if
(
!
thread
-
>
HasDivergedFromRecording
(
)
)
{
thread
-
>
DivergeFromRecording
(
)
;
Thread
:
:
WaitForIdleThreads
(
)
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxThreadId
;
i
+
+
)
{
Thread
:
:
GetById
(
i
)
-
>
SetShouldDivergeFromRecording
(
)
;
}
Thread
:
:
ResumeIdleThreads
(
)
;
}
}
extern
"
C
"
{
MOZ_EXPORT
bool
RecordReplayInterface_InternalHasDivergedFromRecording
(
)
{
Thread
*
thread
=
Thread
:
:
Current
(
)
;
return
thread
&
&
thread
-
>
HasDivergedFromRecording
(
)
;
}
}
void
DisallowUnhandledDivergeFromRecording
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
gUnhandledDivergeAllowed
=
false
;
}
void
EnsureNotDivergedFromRecording
(
const
Maybe
<
int
>
&
aCallId
)
{
AssertEventsAreNotPassedThrough
(
)
;
if
(
HasDivergedFromRecording
(
)
)
{
MOZ_RELEASE_ASSERT
(
gUnhandledDivergeAllowed
)
;
PrintSpew
(
"
Unhandled
recording
divergence
:
%
s
\
n
"
aCallId
.
isSome
(
)
?
GetRedirection
(
aCallId
.
ref
(
)
)
.
mName
:
"
"
)
;
child
:
:
ReportUnhandledDivergence
(
)
;
Unreachable
(
)
;
}
}
size_t
GetLastCheckpoint
(
)
{
return
gLastCheckpoint
;
}
static
bool
gMainThreadShouldPause
=
false
;
bool
MainThreadShouldPause
(
)
{
return
gMainThreadShouldPause
;
}
void
PauseMainThreadAndServiceCallbacks
(
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
AssertEventsAreNotPassedThrough
(
)
;
static
bool
gMainThreadIsPaused
=
false
;
if
(
gMainThreadIsPaused
)
{
return
;
}
gMainThreadIsPaused
=
true
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
while
(
gMainThreadShouldPause
)
{
if
(
!
gMainThreadCallbacks
.
empty
(
)
)
{
std
:
:
function
<
void
(
)
>
callback
=
gMainThreadCallbacks
[
0
]
;
gMainThreadCallbacks
.
erase
(
&
gMainThreadCallbacks
[
0
]
)
;
{
MonitorAutoUnlock
unlock
(
*
gMainThreadCallbackMonitor
)
;
AutoDisallowThreadEvents
disallow
;
callback
(
)
;
}
}
else
{
gMainThreadCallbackMonitor
-
>
Wait
(
)
;
}
}
MOZ_RELEASE_ASSERT
(
gMainThreadCallbacks
.
empty
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
HasDivergedFromRecording
(
)
)
;
gMainThreadIsPaused
=
false
;
}
void
PauseMainThreadAndInvokeCallback
(
const
std
:
:
function
<
void
(
)
>
&
aCallback
)
{
{
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
gMainThreadShouldPause
=
true
;
gMainThreadCallbacks
.
append
(
aCallback
)
;
gMainThreadCallbackMonitor
-
>
Notify
(
)
;
}
if
(
Thread
:
:
CurrentIsMainThread
(
)
)
{
PauseMainThreadAndServiceCallbacks
(
)
;
}
}
static
bool
gNeedRespawnThreads
;
void
EnsureNonMainThreadsAreSpawned
(
)
{
if
(
gNeedRespawnThreads
)
{
AutoPassThroughThreadEvents
pt
;
Thread
:
:
RespawnAllThreadsAfterFork
(
)
;
Thread
:
:
OperateOnIdleThreadLocks
(
Thread
:
:
OwnedLockState
:
:
NeedAcquire
)
;
Thread
:
:
ResumeIdleThreads
(
)
;
gNeedRespawnThreads
=
false
;
}
}
void
ResumeExecution
(
)
{
EnsureNonMainThreadsAreSpawned
(
)
;
MonitorAutoLock
lock
(
*
gMainThreadCallbackMonitor
)
;
gMainThreadShouldPause
=
false
;
gMainThreadCallbackMonitor
-
>
Notify
(
)
;
}
bool
ForkProcess
(
)
{
MOZ_RELEASE_ASSERT
(
IsReplaying
(
)
)
;
if
(
!
gNeedRespawnThreads
)
{
Thread
:
:
WaitForIdleThreads
(
)
;
Thread
:
:
OperateOnIdleThreadLocks
(
Thread
:
:
OwnedLockState
:
:
NeedRelease
)
;
}
AutoEnsurePassThroughThreadEvents
pt
;
pid_t
pid
=
fork
(
)
;
if
(
pid
>
0
)
{
if
(
!
gNeedRespawnThreads
)
{
Thread
:
:
OperateOnIdleThreadLocks
(
Thread
:
:
OwnedLockState
:
:
NeedAcquire
)
;
Thread
:
:
ResumeIdleThreads
(
)
;
}
return
true
;
}
Print
(
"
FORKED
%
d
\
n
"
getpid
(
)
)
;
if
(
TestEnv
(
"
MOZ_REPLAYING_WAIT_AT_FORK
"
)
)
{
BusyWait
(
)
;
}
ResetPid
(
)
;
gNeedRespawnThreads
=
true
;
return
false
;
}
}
}
