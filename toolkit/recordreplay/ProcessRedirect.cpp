#
include
"
ProcessRedirect
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
string
.
h
>
namespace
{
#
include
"
udis86
/
udis86
.
c
"
#
include
"
udis86
/
decode
.
c
"
#
include
"
udis86
/
itab
.
c
"
}
namespace
mozilla
{
namespace
recordreplay
{
static
StaticInfallibleVector
<
std
:
:
pair
<
uint8_t
*
uint8_t
*
>
>
gInternalJumps
;
struct
JumpPatch
{
uint8_t
*
mStart
;
uint8_t
*
mTarget
;
bool
mShort
;
JumpPatch
(
uint8_t
*
aStart
uint8_t
*
aTarget
bool
aShort
)
:
mStart
(
aStart
)
mTarget
(
aTarget
)
mShort
(
aShort
)
{
}
}
;
static
StaticInfallibleVector
<
JumpPatch
>
gJumpPatches
;
static
void
AddJumpPatch
(
uint8_t
*
aStart
uint8_t
*
aTarget
bool
aShort
)
{
gInternalJumps
.
emplaceBack
(
aStart
aTarget
)
;
gJumpPatches
.
emplaceBack
(
aStart
aTarget
aShort
)
;
}
struct
ClobberPatch
{
uint8_t
*
mStart
;
uint8_t
*
mEnd
;
ClobberPatch
(
uint8_t
*
aStart
uint8_t
*
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
}
;
static
StaticInfallibleVector
<
ClobberPatch
>
gClobberPatches
;
static
void
AddClobberPatch
(
uint8_t
*
aStart
uint8_t
*
aEnd
)
{
if
(
aStart
<
aEnd
)
{
gClobberPatches
.
emplaceBack
(
aStart
aEnd
)
;
}
}
static
uint8_t
*
SymbolBase
(
uint8_t
*
aPtr
)
{
Dl_info
info
;
if
(
!
dladdr
(
aPtr
&
info
)
)
{
MOZ_CRASH
(
)
;
}
return
static_cast
<
uint8_t
*
>
(
info
.
dli_saddr
)
;
}
static
size_t
DecodeInstruction
(
uint8_t
*
aIp
ud_t
*
aUd
)
{
ud_init
(
aUd
)
;
ud_set_input_buffer
(
aUd
aIp
MaximumInstructionLength
)
;
ud_set_mode
(
aUd
64
)
;
size_t
nbytes
=
ud_decode
(
aUd
)
;
MOZ_RELEASE_ASSERT
(
nbytes
&
&
nbytes
<
=
MaximumInstructionLength
)
;
return
nbytes
;
}
static
uint8_t
*
MaybeInternalJumpTarget
(
uint8_t
*
aIpStart
uint8_t
*
aIpEnd
)
{
const
char
*
startName
=
SymbolNameRaw
(
aIpStart
)
;
const
char
*
endName
=
SymbolNameRaw
(
aIpEnd
-
1
)
;
if
(
strcmp
(
startName
endName
)
)
{
return
SymbolBase
(
aIpEnd
-
1
)
;
}
for
(
auto
jump
:
gInternalJumps
)
{
if
(
!
(
jump
.
first
>
=
aIpStart
&
&
jump
.
first
<
aIpEnd
)
&
&
jump
.
second
>
aIpStart
&
&
jump
.
second
<
aIpEnd
)
{
return
jump
.
second
;
}
}
for
(
auto
patch
:
gJumpPatches
)
{
uint8_t
*
end
=
patch
.
mStart
+
(
patch
.
mShort
?
ShortJumpBytes
:
JumpBytesClobberRax
)
;
if
(
MemoryIntersects
(
aIpStart
aIpEnd
-
aIpStart
patch
.
mStart
end
-
patch
.
mStart
)
)
{
return
end
;
}
}
for
(
auto
patch
:
gClobberPatches
)
{
if
(
MemoryIntersects
(
aIpStart
aIpEnd
-
aIpStart
patch
.
mStart
patch
.
mEnd
-
patch
.
mStart
)
)
{
return
patch
.
mEnd
;
}
}
if
(
(
size_t
)
(
aIpEnd
-
aIpStart
)
>
ShortJumpBytes
)
{
if
(
(
strstr
(
startName
"
CTRunGetGlyphs
"
)
&
&
!
strstr
(
startName
"
CTRunGetGlyphsPtr
"
)
)
|
|
(
strstr
(
startName
"
CTRunGetPositions
"
)
&
&
!
strstr
(
startName
"
CTRunGetPositionsPtr
"
)
)
|
|
(
strstr
(
startName
"
CTRunGetStringIndices
"
)
&
&
!
strstr
(
startName
"
CTRunGetStringIndicesPtr
"
)
)
|
|
strstr
(
startName
"
CGColorSpaceCreateDeviceRGB
"
)
|
|
strstr
(
startName
"
__workq_kernreturn
"
)
|
|
strstr
(
startName
"
kevent64
"
)
)
{
return
aIpEnd
-
1
;
}
}
return
nullptr
;
}
static
StaticInfallibleVector
<
char
*
>
gRedirectFailures
;
static
void
RedirectFailure
(
const
char
*
aFormat
.
.
.
)
{
va_list
ap
;
va_start
(
ap
aFormat
)
;
char
buf
[
4096
]
;
VsprintfLiteral
(
buf
aFormat
ap
)
;
va_end
(
ap
)
;
gRedirectFailures
.
emplaceBack
(
strdup
(
buf
)
)
;
}
static
void
UnknownInstruction
(
const
char
*
aName
uint8_t
*
aIp
size_t
aNbytes
)
{
char
buf
[
4096
]
;
char
*
ptr
=
buf
;
for
(
size_t
i
=
0
;
i
<
aNbytes
;
i
+
+
)
{
int
written
=
snprintf
(
ptr
sizeof
(
buf
)
-
(
ptr
-
buf
)
"
%
d
"
(
int
)
aIp
[
i
]
)
;
ptr
+
=
written
;
}
RedirectFailure
(
"
Unknown
instruction
in
%
s
:
%
s
"
aName
buf
)
;
}
static
bool
CopySpecialInstruction
(
uint8_t
*
aIp
ud_t
*
aUd
size_t
aNbytes
Assembler
&
aAssembler
)
{
aAssembler
.
NoteOriginalInstruction
(
aIp
)
;
if
(
aUd
-
>
pfx_seg
)
{
return
false
;
}
ud_mnemonic_code
mnemonic
=
ud_insn_mnemonic
(
aUd
)
;
if
(
mnemonic
=
=
UD_Icall
|
|
mnemonic
=
=
UD_Ijmp
|
|
(
mnemonic
>
=
UD_Ijo
&
&
mnemonic
<
=
UD_Ijg
)
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
1
)
)
;
const
ud_operand
*
op
=
ud_insn_opr
(
aUd
0
)
;
if
(
op
-
>
type
=
=
UD_OP_JIMM
)
{
uint8_t
*
target
=
aIp
+
aNbytes
;
switch
(
op
-
>
size
)
{
case
8
:
target
+
=
op
-
>
lval
.
sbyte
;
break
;
case
32
:
target
+
=
op
-
>
lval
.
sdword
;
break
;
default
:
return
false
;
}
gInternalJumps
.
emplaceBack
(
nullptr
target
)
;
if
(
mnemonic
=
=
UD_Icall
)
{
aAssembler
.
MoveImmediateToRax
(
target
)
;
aAssembler
.
CallRax
(
)
;
}
else
if
(
mnemonic
=
=
UD_Ijmp
)
{
aAssembler
.
Jump
(
target
)
;
}
else
{
aAssembler
.
ConditionalJump
(
aUd
-
>
primary_opcode
target
)
;
}
return
true
;
}
if
(
op
-
>
type
=
=
UD_OP_MEM
&
&
op
-
>
base
=
=
UD_R_RIP
&
&
!
op
-
>
index
&
&
op
-
>
offset
=
=
32
)
{
uint8_t
*
addr
=
aIp
+
aNbytes
+
op
-
>
lval
.
sdword
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
8
)
;
aAssembler
.
JumpToRax
(
)
;
return
true
;
}
}
if
(
mnemonic
=
=
UD_Imov
|
|
mnemonic
=
=
UD_Ilea
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
2
)
)
;
const
ud_operand
*
dst
=
ud_insn_opr
(
aUd
0
)
;
const
ud_operand
*
src
=
ud_insn_opr
(
aUd
1
)
;
if
(
dst
-
>
type
=
=
UD_OP_REG
&
&
src
-
>
type
=
=
UD_OP_MEM
&
&
src
-
>
base
=
=
UD_R_RIP
&
&
!
src
-
>
index
&
&
src
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
dst
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
src
-
>
lval
.
sdword
;
if
(
reg
!
=
UD_R_RAX
)
{
aAssembler
.
PushRax
(
)
;
}
aAssembler
.
MoveImmediateToRax
(
addr
)
;
if
(
mnemonic
=
=
UD_Imov
)
{
aAssembler
.
LoadRax
(
src
-
>
size
/
8
)
;
}
if
(
reg
!
=
UD_R_RAX
)
{
aAssembler
.
MoveRaxToRegister
(
reg
)
;
aAssembler
.
PopRax
(
)
;
}
return
true
;
}
if
(
dst
-
>
type
=
=
UD_OP_MEM
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
&
&
src
-
>
type
=
=
UD_OP_REG
&
&
mnemonic
=
=
UD_Imov
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
src
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
PushRbx
(
)
;
aAssembler
.
MoveRegisterToRax
(
reg
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
PopRbx
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
StoreRbxToRax
(
src
-
>
size
/
8
)
;
aAssembler
.
PopRbx
(
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
}
if
(
mnemonic
=
=
UD_Icmp
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
2
)
)
;
const
ud_operand
*
dst
=
ud_insn_opr
(
aUd
0
)
;
const
ud_operand
*
src
=
ud_insn_opr
(
aUd
1
)
;
if
(
dst
-
>
type
=
=
UD_OP_MEM
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
&
&
src
-
>
type
=
=
UD_OP_IMM
&
&
src
-
>
size
=
=
8
)
{
uint8_t
value
=
src
-
>
lval
.
ubyte
;
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
dst
-
>
size
/
8
)
;
aAssembler
.
CompareValueWithRax
(
value
dst
-
>
size
/
8
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
if
(
dst
-
>
type
=
=
UD_OP_REG
&
&
src
-
>
type
=
=
UD_OP_MEM
&
&
src
-
>
base
=
=
UD_R_RIP
&
&
!
src
-
>
index
&
&
src
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
dst
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
src
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveRegisterToRax
(
reg
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
8
)
;
aAssembler
.
CompareRaxWithTopOfStack
(
)
;
aAssembler
.
PopRax
(
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
}
return
false
;
}
static
size_t
CopyInstruction
(
const
char
*
aName
uint8_t
*
aIp
Assembler
&
aAssembler
)
{
ud_t
ud
;
size_t
nbytes
=
DecodeInstruction
(
aIp
&
ud
)
;
if
(
CopySpecialInstruction
(
aIp
&
ud
nbytes
aAssembler
)
)
{
return
nbytes
;
}
ud_mnemonic_code_t
mnemonic
=
ud_insn_mnemonic
(
&
ud
)
;
if
(
mnemonic
=
=
UD_Icall
|
|
(
mnemonic
>
=
UD_Ijo
&
&
mnemonic
<
=
UD_Ijmp
)
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
for
(
size_t
i
=
0
;
;
i
+
+
)
{
const
ud_operand_t
*
op
=
ud_insn_opr
(
&
ud
i
)
;
if
(
!
op
)
{
break
;
}
switch
(
op
-
>
type
)
{
case
UD_OP_MEM
:
if
(
op
-
>
index
=
=
UD_R_RIP
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
MOZ_FALLTHROUGH
;
case
UD_OP_REG
:
if
(
op
-
>
base
=
=
UD_R_RIP
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
break
;
default
:
break
;
}
}
aAssembler
.
CopyInstruction
(
aIp
nbytes
)
;
return
nbytes
;
}
static
uint8_t
*
CopyInstructions
(
const
char
*
aName
uint8_t
*
aIpStart
uint8_t
*
aIpEnd
Assembler
&
aAssembler
)
{
MOZ_RELEASE_ASSERT
(
!
MaybeInternalJumpTarget
(
aIpStart
aIpEnd
)
)
;
uint8_t
*
ip
=
aIpStart
;
while
(
ip
<
aIpEnd
)
{
ip
+
=
CopyInstruction
(
aName
ip
aAssembler
)
;
}
return
ip
;
}
static
uint8_t
*
FunctionStartAddress
(
Redirection
&
aRedirection
)
{
uint8_t
*
addr
=
static_cast
<
uint8_t
*
>
(
dlsym
(
RTLD_DEFAULT
aRedirection
.
mName
)
)
;
if
(
!
addr
)
return
nullptr
;
if
(
addr
[
0
]
=
=
0xFF
&
&
addr
[
1
]
=
=
0x25
)
{
return
*
(
uint8_t
*
*
)
(
addr
+
6
+
*
reinterpret_cast
<
int32_t
*
>
(
addr
+
2
)
)
;
}
return
addr
;
}
static
void
Redirect
(
Redirection
&
aRedirection
Assembler
&
aAssembler
bool
aFirstPass
)
{
uint8_t
*
functionStart
=
aRedirection
.
mBaseFunction
;
uint8_t
*
ro
=
functionStart
;
if
(
!
functionStart
)
{
if
(
aFirstPass
)
{
PrintSpew
(
"
Could
not
find
symbol
%
s
for
redirecting
.
\
n
"
aRedirection
.
mName
)
;
}
return
;
}
if
(
aRedirection
.
mOriginalFunction
!
=
aRedirection
.
mBaseFunction
)
{
MOZ_RELEASE_ASSERT
(
!
aFirstPass
)
;
return
;
}
uint8_t
*
extent
=
ro
+
JumpBytesClobberRax
;
if
(
!
MaybeInternalJumpTarget
(
ro
extent
)
)
{
aRedirection
.
mOriginalFunction
=
aAssembler
.
Current
(
)
;
ro
=
CopyInstructions
(
aRedirection
.
mName
ro
extent
aAssembler
)
;
aAssembler
.
Jump
(
ro
)
;
AddJumpPatch
(
functionStart
aRedirection
.
mNewFunction
false
)
;
AddClobberPatch
(
functionStart
+
JumpBytesClobberRax
ro
)
;
return
;
}
if
(
aFirstPass
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
!
MaybeInternalJumpTarget
(
ro
ro
+
ShortJumpBytes
)
)
;
aRedirection
.
mOriginalFunction
=
aAssembler
.
Current
(
)
;
uint8_t
*
nro
=
CopyInstructions
(
aRedirection
.
mName
ro
ro
+
ShortJumpBytes
aAssembler
)
;
aAssembler
.
Jump
(
nro
)
;
ro
=
SymbolBase
(
extent
)
;
while
(
true
)
{
extent
=
ro
+
JumpBytesClobberRax
*
2
;
uint8_t
*
target
=
MaybeInternalJumpTarget
(
ro
extent
)
;
if
(
target
)
{
ro
=
target
;
continue
;
}
break
;
}
uint8_t
*
firstJumpTarget
=
aAssembler
.
Current
(
)
;
uint8_t
*
afterip
=
CopyInstructions
(
aRedirection
.
mName
ro
extent
aAssembler
)
;
aAssembler
.
Jump
(
afterip
)
;
AddJumpPatch
(
ro
firstJumpTarget
false
)
;
AddJumpPatch
(
ro
+
JumpBytesClobberRax
aRedirection
.
mNewFunction
false
)
;
AddClobberPatch
(
ro
+
2
*
JumpBytesClobberRax
afterip
)
;
AddJumpPatch
(
functionStart
ro
+
JumpBytesClobberRax
true
)
;
AddClobberPatch
(
functionStart
+
ShortJumpBytes
nro
)
;
}
void
EarlyInitializeRedirections
(
)
{
for
(
size_t
i
=
0
;
;
i
+
+
)
{
Redirection
&
redirection
=
gRedirections
[
i
]
;
if
(
!
redirection
.
mName
)
{
break
;
}
MOZ_ASSERT
(
!
redirection
.
mBaseFunction
)
;
MOZ_ASSERT
(
redirection
.
mNewFunction
)
;
MOZ_ASSERT
(
!
redirection
.
mOriginalFunction
)
;
redirection
.
mBaseFunction
=
FunctionStartAddress
(
redirection
)
;
redirection
.
mOriginalFunction
=
redirection
.
mBaseFunction
;
if
(
redirection
.
mBaseFunction
&
&
IsRecordingOrReplaying
(
)
)
{
for
(
size_t
j
=
0
;
j
<
i
;
j
+
+
)
{
if
(
gRedirections
[
j
]
.
mBaseFunction
=
=
redirection
.
mBaseFunction
)
{
PrintSpew
(
"
Redirection
%
s
shares
the
same
address
as
%
s
skipping
.
\
n
"
redirection
.
mName
gRedirections
[
j
]
.
mName
)
;
redirection
.
mBaseFunction
=
nullptr
;
break
;
}
}
}
}
}
bool
InitializeRedirections
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
{
Assembler
assembler
;
for
(
size_t
i
=
0
;
;
i
+
+
)
{
Redirection
&
redirection
=
gRedirections
[
i
]
;
if
(
!
redirection
.
mName
)
{
break
;
}
Redirect
(
redirection
assembler
true
)
;
}
for
(
size_t
i
=
0
;
;
i
+
+
)
{
Redirection
&
redirection
=
gRedirections
[
i
]
;
if
(
!
redirection
.
mName
)
{
break
;
}
Redirect
(
redirection
assembler
false
)
;
}
}
if
(
!
gRedirectFailures
.
empty
(
)
)
{
size_t
len
=
4096
;
gInitializationFailureMessage
=
new
char
[
4096
]
;
gInitializationFailureMessage
[
-
-
len
]
=
0
;
char
*
ptr
=
gInitializationFailureMessage
;
for
(
char
*
reason
:
gRedirectFailures
)
{
size_t
n
=
snprintf
(
ptr
len
"
%
s
\
n
"
reason
)
;
if
(
n
>
=
len
)
{
break
;
}
ptr
+
=
n
;
len
-
=
n
;
}
return
false
;
}
for
(
const
JumpPatch
&
patch
:
gJumpPatches
)
{
UnprotectExecutableMemory
(
patch
.
mStart
patch
.
mShort
?
ShortJumpBytes
:
JumpBytesClobberRax
)
;
}
for
(
const
ClobberPatch
&
patch
:
gClobberPatches
)
{
UnprotectExecutableMemory
(
patch
.
mStart
patch
.
mEnd
-
patch
.
mStart
)
;
}
for
(
const
JumpPatch
&
patch
:
gJumpPatches
)
{
if
(
patch
.
mShort
)
{
Assembler
:
:
PatchShortJump
(
patch
.
mStart
patch
.
mTarget
)
;
}
else
{
Assembler
:
:
PatchJumpClobberRax
(
patch
.
mStart
patch
.
mTarget
)
;
}
}
for
(
const
ClobberPatch
&
patch
:
gClobberPatches
)
{
for
(
uint8_t
*
ip
=
patch
.
mStart
;
ip
<
patch
.
mEnd
;
ip
+
+
)
{
Assembler
:
:
PatchClobber
(
ip
)
;
}
}
return
true
;
}
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gMemoryLeakBytes
;
void
*
BindFunctionArgument
(
void
*
aFunction
void
*
aArgument
size_t
aArgumentPosition
Assembler
&
aAssembler
)
{
void
*
res
=
aAssembler
.
Current
(
)
;
aAssembler
.
MoveImmediateToRax
(
aArgument
)
;
switch
(
aArgumentPosition
)
{
case
1
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RSI
)
;
break
;
case
2
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RDX
)
;
break
;
case
3
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RCX
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
aAssembler
.
Jump
(
aFunction
)
;
return
res
;
}
}
}
