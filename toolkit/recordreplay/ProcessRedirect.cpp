#
include
"
ProcessRedirect
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
string
.
h
>
namespace
{
#
include
"
udis86
/
udis86
.
c
"
#
include
"
udis86
/
decode
.
c
"
#
include
"
udis86
/
itab
.
c
"
}
namespace
mozilla
{
namespace
recordreplay
{
extern
"
C
"
{
__attribute__
(
(
used
)
)
int
RecordReplayInterceptCall
(
int
aCallId
CallArguments
*
aArguments
)
{
Redirection
&
redirection
=
gRedirections
[
aCallId
]
;
if
(
redirection
.
mPreamble
)
{
PreambleResult
result
=
redirection
.
mPreamble
(
aArguments
)
;
switch
(
result
)
{
case
PreambleResult
:
:
Veto
:
return
0
;
case
PreambleResult
:
:
PassThrough
:
{
AutoEnsurePassThroughThreadEvents
pt
;
RecordReplayInvokeCall
(
aCallId
aArguments
)
;
return
0
;
}
case
PreambleResult
:
:
Redirect
:
break
;
}
}
Thread
*
thread
=
Thread
:
:
Current
(
)
;
if
(
!
thread
|
|
thread
-
>
PassThroughEvents
(
)
)
{
aArguments
-
>
Rval
<
uint8_t
*
>
(
)
=
redirection
.
mOriginalFunction
;
return
1
;
}
EnsureNotDivergedFromRecording
(
)
;
MOZ_RELEASE_ASSERT
(
thread
-
>
CanAccessRecording
(
)
)
;
if
(
IsRecording
(
)
)
{
thread
-
>
SetPassThrough
(
true
)
;
RecordReplayInvokeCall
(
aCallId
aArguments
)
;
thread
-
>
SetPassThrough
(
false
)
;
}
ErrorType
error
=
SaveError
(
)
;
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
CallIdToThreadEvent
(
aCallId
)
)
;
if
(
redirection
.
mSaveOutput
)
{
redirection
.
mSaveOutput
(
thread
-
>
Events
(
)
aArguments
&
error
)
;
}
RestoreError
(
error
)
;
return
0
;
}
extern
size_t
RecordReplayRedirectCall
(
.
.
.
)
;
__asm
(
"
_RecordReplayRedirectCall
:
"
"
subq
616
%
rsp
;
"
"
movq
%
rdi
0
(
%
rsp
)
;
"
"
movq
%
rsi
8
(
%
rsp
)
;
"
"
movq
%
rdx
16
(
%
rsp
)
;
"
"
movq
%
rcx
24
(
%
rsp
)
;
"
"
movq
%
r8
32
(
%
rsp
)
;
"
"
movq
%
r9
40
(
%
rsp
)
;
"
"
movsd
%
xmm0
48
(
%
rsp
)
;
"
"
movsd
%
xmm1
56
(
%
rsp
)
;
"
"
movsd
%
xmm2
64
(
%
rsp
)
;
"
"
movq
64
%
rsi
;
"
"
jmp
_RecordReplayRedirectCall_Loop
;
"
"
_RecordReplayRedirectCall_Loop
:
"
"
subq
1
%
rsi
;
"
"
movq
624
(
%
rsp
%
rsi
8
)
%
rdx
;
"
"
movq
%
rdx
104
(
%
rsp
%
rsi
8
)
;
"
"
testq
%
rsi
%
rsi
;
"
"
jne
_RecordReplayRedirectCall_Loop
;
"
"
movq
%
rax
%
rdi
;
"
"
movq
%
rsp
%
rsi
;
"
"
call
_RecordReplayInterceptCall
;
"
"
testq
%
rax
%
rax
;
"
"
je
RecordReplayRedirectCall_done
;
"
"
movq
0
(
%
rsp
)
%
rdi
;
"
"
movq
8
(
%
rsp
)
%
rsi
;
"
"
movq
16
(
%
rsp
)
%
rdx
;
"
"
movq
24
(
%
rsp
)
%
rcx
;
"
"
movq
32
(
%
rsp
)
%
r8
;
"
"
movq
40
(
%
rsp
)
%
r9
;
"
"
movsd
48
(
%
rsp
)
%
xmm0
;
"
"
movsd
56
(
%
rsp
)
%
xmm1
;
"
"
movsd
64
(
%
rsp
)
%
xmm2
;
"
"
movq
72
(
%
rsp
)
%
rax
;
"
"
addq
616
%
rsp
;
"
"
jmpq
*
%
rax
;
"
"
RecordReplayRedirectCall_done
:
"
"
movq
72
(
%
rsp
)
%
rax
;
"
"
movq
80
(
%
rsp
)
%
rdx
;
"
"
movsd
88
(
%
rsp
)
%
xmm0
;
"
"
movsd
96
(
%
rsp
)
%
xmm1
;
"
"
addq
616
%
rsp
;
"
"
ret
;
"
)
;
extern
void
RecordReplayInvokeCallRaw
(
CallArguments
*
aArguments
void
*
aFnPtr
)
;
__asm
(
"
_RecordReplayInvokeCallRaw
:
"
"
movq
%
rsi
%
rax
;
"
"
push
%
rdi
;
"
"
movq
64
%
rsi
;
"
"
jmp
_RecordReplayInvokeCallRaw_Loop
;
"
"
_RecordReplayInvokeCallRaw_Loop
:
"
"
subq
1
%
rsi
;
"
"
movq
104
(
%
rdi
%
rsi
8
)
%
rdx
;
"
"
push
%
rdx
;
"
"
testq
%
rsi
%
rsi
;
"
"
jne
_RecordReplayInvokeCallRaw_Loop
;
"
"
movq
8
(
%
rdi
)
%
rsi
;
"
"
movq
16
(
%
rdi
)
%
rdx
;
"
"
movq
24
(
%
rdi
)
%
rcx
;
"
"
movq
32
(
%
rdi
)
%
r8
;
"
"
movq
40
(
%
rdi
)
%
r9
;
"
"
movsd
48
(
%
rdi
)
%
xmm0
;
"
"
movsd
56
(
%
rdi
)
%
xmm1
;
"
"
movsd
64
(
%
rdi
)
%
xmm2
;
"
"
movq
0
(
%
rdi
)
%
rdi
;
"
"
callq
*
%
rax
;
"
"
addq
512
%
rsp
;
"
"
pop
%
rdi
;
"
"
movq
%
rax
72
(
%
rdi
)
;
"
"
movq
%
rdx
80
(
%
rdi
)
;
"
"
movsd
%
xmm0
88
(
%
rdi
)
;
"
"
movsd
%
xmm1
96
(
%
rdi
)
;
"
"
ret
;
"
)
;
}
MOZ_NEVER_INLINE
void
RecordReplayInvokeCall
(
size_t
aCallId
CallArguments
*
aArguments
)
{
RecordReplayInvokeCallRaw
(
aArguments
OriginalFunction
(
aCallId
)
)
;
}
static
StaticInfallibleVector
<
std
:
:
pair
<
uint8_t
*
uint8_t
*
>
>
gInternalJumps
;
struct
JumpPatch
{
uint8_t
*
mStart
;
uint8_t
*
mTarget
;
bool
mShort
;
JumpPatch
(
uint8_t
*
aStart
uint8_t
*
aTarget
bool
aShort
)
:
mStart
(
aStart
)
mTarget
(
aTarget
)
mShort
(
aShort
)
{
}
}
;
static
StaticInfallibleVector
<
JumpPatch
>
gJumpPatches
;
static
void
AddJumpPatch
(
uint8_t
*
aStart
uint8_t
*
aTarget
bool
aShort
)
{
gInternalJumps
.
emplaceBack
(
aStart
aTarget
)
;
gJumpPatches
.
emplaceBack
(
aStart
aTarget
aShort
)
;
}
struct
ClobberPatch
{
uint8_t
*
mStart
;
uint8_t
*
mEnd
;
ClobberPatch
(
uint8_t
*
aStart
uint8_t
*
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
}
;
static
StaticInfallibleVector
<
ClobberPatch
>
gClobberPatches
;
static
void
AddClobberPatch
(
uint8_t
*
aStart
uint8_t
*
aEnd
)
{
if
(
aStart
<
aEnd
)
{
gClobberPatches
.
emplaceBack
(
aStart
aEnd
)
;
}
}
static
uint8_t
*
SymbolBase
(
uint8_t
*
aPtr
)
{
Dl_info
info
;
if
(
!
dladdr
(
aPtr
&
info
)
)
{
MOZ_CRASH
(
)
;
}
return
static_cast
<
uint8_t
*
>
(
info
.
dli_saddr
)
;
}
static
size_t
DecodeInstruction
(
uint8_t
*
aIp
ud_t
*
aUd
)
{
ud_init
(
aUd
)
;
ud_set_input_buffer
(
aUd
aIp
MaximumInstructionLength
)
;
ud_set_mode
(
aUd
64
)
;
size_t
nbytes
=
ud_decode
(
aUd
)
;
MOZ_RELEASE_ASSERT
(
nbytes
&
&
nbytes
<
=
MaximumInstructionLength
)
;
return
nbytes
;
}
static
uint8_t
*
MaybeInternalJumpTarget
(
uint8_t
*
aIpStart
uint8_t
*
aIpEnd
)
{
const
char
*
startName
=
SymbolNameRaw
(
aIpStart
)
;
const
char
*
endName
=
SymbolNameRaw
(
aIpEnd
-
1
)
;
if
(
strcmp
(
startName
endName
)
)
{
return
SymbolBase
(
aIpEnd
-
1
)
;
}
for
(
auto
jump
:
gInternalJumps
)
{
if
(
!
(
jump
.
first
>
=
aIpStart
&
&
jump
.
first
<
aIpEnd
)
&
&
jump
.
second
>
aIpStart
&
&
jump
.
second
<
aIpEnd
)
{
return
jump
.
second
;
}
}
for
(
auto
patch
:
gJumpPatches
)
{
uint8_t
*
end
=
patch
.
mStart
+
(
patch
.
mShort
?
ShortJumpBytes
:
JumpBytesClobberRax
)
;
if
(
MemoryIntersects
(
aIpStart
aIpEnd
-
aIpStart
patch
.
mStart
end
-
patch
.
mStart
)
)
{
return
end
;
}
}
for
(
auto
patch
:
gClobberPatches
)
{
if
(
MemoryIntersects
(
aIpStart
aIpEnd
-
aIpStart
patch
.
mStart
patch
.
mEnd
-
patch
.
mStart
)
)
{
return
patch
.
mEnd
;
}
}
if
(
(
size_t
)
(
aIpEnd
-
aIpStart
)
>
ShortJumpBytes
)
{
if
(
(
strstr
(
startName
"
CTRunGetGlyphs
"
)
&
&
!
strstr
(
startName
"
CTRunGetGlyphsPtr
"
)
)
|
|
(
strstr
(
startName
"
CTRunGetPositions
"
)
&
&
!
strstr
(
startName
"
CTRunGetPositionsPtr
"
)
)
|
|
(
strstr
(
startName
"
CTRunGetStringIndices
"
)
&
&
!
strstr
(
startName
"
CTRunGetStringIndicesPtr
"
)
)
|
|
strstr
(
startName
"
CGColorSpaceCreateDeviceRGB
"
)
|
|
strstr
(
startName
"
__workq_kernreturn
"
)
|
|
strstr
(
startName
"
kevent64
"
)
)
{
return
aIpEnd
-
1
;
}
}
return
nullptr
;
}
static
StaticInfallibleVector
<
char
*
>
gRedirectFailures
;
static
void
RedirectFailure
(
const
char
*
aFormat
.
.
.
)
{
va_list
ap
;
va_start
(
ap
aFormat
)
;
char
buf
[
4096
]
;
VsprintfLiteral
(
buf
aFormat
ap
)
;
va_end
(
ap
)
;
gRedirectFailures
.
emplaceBack
(
strdup
(
buf
)
)
;
}
static
void
UnknownInstruction
(
const
char
*
aName
uint8_t
*
aIp
size_t
aNbytes
)
{
char
buf
[
4096
]
;
char
*
ptr
=
buf
;
for
(
size_t
i
=
0
;
i
<
aNbytes
;
i
+
+
)
{
int
written
=
snprintf
(
ptr
sizeof
(
buf
)
-
(
ptr
-
buf
)
"
%
d
"
(
int
)
aIp
[
i
]
)
;
ptr
+
=
written
;
}
RedirectFailure
(
"
Unknown
instruction
in
%
s
:
%
s
"
aName
buf
)
;
}
static
bool
CopySpecialInstruction
(
uint8_t
*
aIp
ud_t
*
aUd
size_t
aNbytes
Assembler
&
aAssembler
)
{
aAssembler
.
NoteOriginalInstruction
(
aIp
)
;
if
(
aUd
-
>
pfx_seg
)
{
return
false
;
}
ud_mnemonic_code
mnemonic
=
ud_insn_mnemonic
(
aUd
)
;
if
(
mnemonic
=
=
UD_Icall
|
|
mnemonic
=
=
UD_Ijmp
|
|
(
mnemonic
>
=
UD_Ijo
&
&
mnemonic
<
=
UD_Ijg
)
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
1
)
)
;
const
ud_operand
*
op
=
ud_insn_opr
(
aUd
0
)
;
if
(
op
-
>
type
=
=
UD_OP_JIMM
)
{
uint8_t
*
target
=
aIp
+
aNbytes
;
switch
(
op
-
>
size
)
{
case
8
:
target
+
=
op
-
>
lval
.
sbyte
;
break
;
case
32
:
target
+
=
op
-
>
lval
.
sdword
;
break
;
default
:
return
false
;
}
gInternalJumps
.
emplaceBack
(
nullptr
target
)
;
if
(
mnemonic
=
=
UD_Icall
)
{
aAssembler
.
MoveImmediateToRax
(
target
)
;
aAssembler
.
CallRax
(
)
;
}
else
if
(
mnemonic
=
=
UD_Ijmp
)
{
aAssembler
.
Jump
(
target
)
;
}
else
{
aAssembler
.
ConditionalJump
(
aUd
-
>
primary_opcode
target
)
;
}
return
true
;
}
if
(
op
-
>
type
=
=
UD_OP_MEM
&
&
op
-
>
base
=
=
UD_R_RIP
&
&
!
op
-
>
index
&
&
op
-
>
offset
=
=
32
)
{
uint8_t
*
addr
=
aIp
+
aNbytes
+
op
-
>
lval
.
sdword
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
8
)
;
aAssembler
.
JumpToRax
(
)
;
return
true
;
}
}
if
(
mnemonic
=
=
UD_Imov
|
|
mnemonic
=
=
UD_Ilea
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
2
)
)
;
const
ud_operand
*
dst
=
ud_insn_opr
(
aUd
0
)
;
const
ud_operand
*
src
=
ud_insn_opr
(
aUd
1
)
;
if
(
dst
-
>
type
=
=
UD_OP_REG
&
&
src
-
>
type
=
=
UD_OP_MEM
&
&
src
-
>
base
=
=
UD_R_RIP
&
&
!
src
-
>
index
&
&
src
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
dst
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
src
-
>
lval
.
sdword
;
if
(
reg
!
=
UD_R_RAX
)
{
aAssembler
.
PushRax
(
)
;
}
aAssembler
.
MoveImmediateToRax
(
addr
)
;
if
(
mnemonic
=
=
UD_Imov
)
{
aAssembler
.
LoadRax
(
src
-
>
size
/
8
)
;
}
if
(
reg
!
=
UD_R_RAX
)
{
aAssembler
.
MoveRaxToRegister
(
reg
)
;
aAssembler
.
PopRax
(
)
;
}
return
true
;
}
if
(
dst
-
>
type
=
=
UD_OP_MEM
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
&
&
src
-
>
type
=
=
UD_OP_REG
&
&
mnemonic
=
=
UD_Imov
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
src
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
PushRbx
(
)
;
aAssembler
.
MoveRegisterToRax
(
reg
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
PopRbx
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
StoreRbxToRax
(
src
-
>
size
/
8
)
;
aAssembler
.
PopRbx
(
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
}
if
(
mnemonic
=
=
UD_Icmp
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
2
)
)
;
const
ud_operand
*
dst
=
ud_insn_opr
(
aUd
0
)
;
const
ud_operand
*
src
=
ud_insn_opr
(
aUd
1
)
;
if
(
dst
-
>
type
=
=
UD_OP_MEM
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
&
&
src
-
>
type
=
=
UD_OP_IMM
&
&
src
-
>
size
=
=
8
)
{
uint8_t
value
=
src
-
>
lval
.
ubyte
;
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
dst
-
>
size
/
8
)
;
aAssembler
.
CompareValueWithRax
(
value
dst
-
>
size
/
8
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
if
(
dst
-
>
type
=
=
UD_OP_REG
&
&
src
-
>
type
=
=
UD_OP_MEM
&
&
src
-
>
base
=
=
UD_R_RIP
&
&
!
src
-
>
index
&
&
src
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
dst
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
src
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveRegisterToRax
(
reg
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
8
)
;
aAssembler
.
CompareRaxWithTopOfStack
(
)
;
aAssembler
.
PopRax
(
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
}
if
(
mnemonic
=
=
UD_Ixchg
)
{
const
ud_operand
*
dst
=
ud_insn_opr
(
aUd
0
)
;
const
ud_operand
*
src
=
ud_insn_opr
(
aUd
1
)
;
if
(
src
-
>
type
=
=
UD_OP_REG
&
&
src
-
>
size
=
=
8
&
&
dst
-
>
type
=
=
UD_OP_MEM
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
src
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
if
(
reg
=
=
UD_R_RBX
)
{
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
ExchangeByteRbxWithAddressAtRax
(
)
;
aAssembler
.
PopRax
(
)
;
}
else
{
aAssembler
.
PushRbx
(
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
MoveRaxToRegister
(
UD_R_RBX
)
;
aAssembler
.
PopRax
(
)
;
aAssembler
.
ExchangeByteRegisterWithAddressAtRbx
(
reg
)
;
aAssembler
.
PopRbx
(
)
;
}
return
true
;
}
}
return
false
;
}
static
size_t
CopyInstruction
(
const
char
*
aName
uint8_t
*
aIp
Assembler
&
aAssembler
)
{
ud_t
ud
;
size_t
nbytes
=
DecodeInstruction
(
aIp
&
ud
)
;
if
(
CopySpecialInstruction
(
aIp
&
ud
nbytes
aAssembler
)
)
{
return
nbytes
;
}
ud_mnemonic_code_t
mnemonic
=
ud_insn_mnemonic
(
&
ud
)
;
if
(
mnemonic
=
=
UD_Icall
|
|
(
mnemonic
>
=
UD_Ijo
&
&
mnemonic
<
=
UD_Ijmp
)
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
for
(
size_t
i
=
0
;
;
i
+
+
)
{
const
ud_operand_t
*
op
=
ud_insn_opr
(
&
ud
i
)
;
if
(
!
op
)
{
break
;
}
switch
(
op
-
>
type
)
{
case
UD_OP_MEM
:
if
(
op
-
>
index
=
=
UD_R_RIP
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
MOZ_FALLTHROUGH
;
case
UD_OP_REG
:
if
(
op
-
>
base
=
=
UD_R_RIP
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
break
;
default
:
break
;
}
}
aAssembler
.
CopyInstruction
(
aIp
nbytes
)
;
return
nbytes
;
}
static
uint8_t
*
CopyInstructions
(
const
char
*
aName
uint8_t
*
aIpStart
uint8_t
*
aIpEnd
Assembler
&
aAssembler
)
{
MOZ_RELEASE_ASSERT
(
!
MaybeInternalJumpTarget
(
aIpStart
aIpEnd
)
)
;
uint8_t
*
ip
=
aIpStart
;
while
(
ip
<
aIpEnd
)
{
ip
+
=
CopyInstruction
(
aName
ip
aAssembler
)
;
}
return
ip
;
}
static
uint8_t
*
FunctionStartAddress
(
Redirection
&
aRedirection
)
{
uint8_t
*
addr
=
static_cast
<
uint8_t
*
>
(
dlsym
(
RTLD_DEFAULT
aRedirection
.
mName
)
)
;
if
(
!
addr
)
return
nullptr
;
if
(
addr
[
0
]
=
=
0xFF
&
&
addr
[
1
]
=
=
0x25
)
{
return
*
(
uint8_t
*
*
)
(
addr
+
6
+
*
reinterpret_cast
<
int32_t
*
>
(
addr
+
2
)
)
;
}
return
addr
;
}
static
uint8_t
*
GenerateRedirectStub
(
Assembler
&
aAssembler
size_t
aCallId
)
{
uint8_t
*
newFunction
=
aAssembler
.
Current
(
)
;
aAssembler
.
MoveImmediateToRax
(
(
void
*
)
aCallId
)
;
aAssembler
.
Jump
(
BitwiseCast
<
void
*
>
(
RecordReplayRedirectCall
)
)
;
return
newFunction
;
}
static
void
Redirect
(
size_t
aCallId
Redirection
&
aRedirection
Assembler
&
aAssembler
bool
aFirstPass
)
{
uint8_t
*
functionStart
=
aRedirection
.
mBaseFunction
;
uint8_t
*
ro
=
functionStart
;
if
(
!
functionStart
)
{
if
(
aFirstPass
)
{
PrintSpew
(
"
Could
not
find
symbol
%
s
for
redirecting
.
\
n
"
aRedirection
.
mName
)
;
}
return
;
}
if
(
aRedirection
.
mOriginalFunction
!
=
aRedirection
.
mBaseFunction
)
{
MOZ_RELEASE_ASSERT
(
!
aFirstPass
)
;
return
;
}
uint8_t
*
extent
=
ro
+
JumpBytesClobberRax
;
if
(
!
MaybeInternalJumpTarget
(
ro
extent
)
)
{
aRedirection
.
mOriginalFunction
=
aAssembler
.
Current
(
)
;
ro
=
CopyInstructions
(
aRedirection
.
mName
ro
extent
aAssembler
)
;
aAssembler
.
Jump
(
ro
)
;
uint8_t
*
newFunction
=
GenerateRedirectStub
(
aAssembler
aCallId
)
;
AddJumpPatch
(
functionStart
newFunction
false
)
;
AddClobberPatch
(
functionStart
+
JumpBytesClobberRax
ro
)
;
return
;
}
if
(
aFirstPass
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
!
MaybeInternalJumpTarget
(
ro
ro
+
ShortJumpBytes
)
)
;
aRedirection
.
mOriginalFunction
=
aAssembler
.
Current
(
)
;
uint8_t
*
nro
=
CopyInstructions
(
aRedirection
.
mName
ro
ro
+
ShortJumpBytes
aAssembler
)
;
aAssembler
.
Jump
(
nro
)
;
ro
=
SymbolBase
(
extent
)
;
while
(
true
)
{
extent
=
ro
+
JumpBytesClobberRax
*
2
;
uint8_t
*
target
=
MaybeInternalJumpTarget
(
ro
extent
)
;
if
(
target
)
{
ro
=
target
;
continue
;
}
break
;
}
uint8_t
*
firstJumpTarget
=
aAssembler
.
Current
(
)
;
uint8_t
*
afterip
=
CopyInstructions
(
aRedirection
.
mName
ro
extent
aAssembler
)
;
aAssembler
.
Jump
(
afterip
)
;
AddJumpPatch
(
ro
firstJumpTarget
false
)
;
uint8_t
*
newFunction
=
GenerateRedirectStub
(
aAssembler
aCallId
)
;
AddJumpPatch
(
ro
+
JumpBytesClobberRax
newFunction
false
)
;
AddClobberPatch
(
ro
+
2
*
JumpBytesClobberRax
afterip
)
;
AddJumpPatch
(
functionStart
ro
+
JumpBytesClobberRax
true
)
;
AddClobberPatch
(
functionStart
+
ShortJumpBytes
nro
)
;
}
void
EarlyInitializeRedirections
(
)
{
for
(
size_t
i
=
0
;
;
i
+
+
)
{
Redirection
&
redirection
=
gRedirections
[
i
]
;
if
(
!
redirection
.
mName
)
{
break
;
}
MOZ_ASSERT
(
!
redirection
.
mBaseFunction
)
;
MOZ_ASSERT
(
!
redirection
.
mOriginalFunction
)
;
redirection
.
mBaseFunction
=
FunctionStartAddress
(
redirection
)
;
redirection
.
mOriginalFunction
=
redirection
.
mBaseFunction
;
if
(
redirection
.
mBaseFunction
&
&
IsRecordingOrReplaying
(
)
)
{
for
(
size_t
j
=
0
;
j
<
i
;
j
+
+
)
{
if
(
gRedirections
[
j
]
.
mBaseFunction
=
=
redirection
.
mBaseFunction
)
{
PrintSpew
(
"
Redirection
%
s
shares
the
same
address
as
%
s
skipping
.
\
n
"
redirection
.
mName
gRedirections
[
j
]
.
mName
)
;
redirection
.
mBaseFunction
=
nullptr
;
break
;
}
}
}
}
}
bool
InitializeRedirections
(
)
{
MOZ_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
{
Assembler
assembler
;
for
(
size_t
i
=
0
;
;
i
+
+
)
{
Redirection
&
redirection
=
gRedirections
[
i
]
;
if
(
!
redirection
.
mName
)
{
break
;
}
Redirect
(
i
redirection
assembler
true
)
;
}
for
(
size_t
i
=
0
;
;
i
+
+
)
{
Redirection
&
redirection
=
gRedirections
[
i
]
;
if
(
!
redirection
.
mName
)
{
break
;
}
Redirect
(
i
redirection
assembler
false
)
;
}
}
if
(
!
gRedirectFailures
.
empty
(
)
)
{
size_t
len
=
4096
;
gInitializationFailureMessage
=
new
char
[
4096
]
;
gInitializationFailureMessage
[
-
-
len
]
=
0
;
char
*
ptr
=
gInitializationFailureMessage
;
for
(
char
*
reason
:
gRedirectFailures
)
{
size_t
n
=
snprintf
(
ptr
len
"
%
s
\
n
"
reason
)
;
if
(
n
>
=
len
)
{
break
;
}
ptr
+
=
n
;
len
-
=
n
;
}
return
false
;
}
for
(
const
JumpPatch
&
patch
:
gJumpPatches
)
{
UnprotectExecutableMemory
(
patch
.
mStart
patch
.
mShort
?
ShortJumpBytes
:
JumpBytesClobberRax
)
;
}
for
(
const
ClobberPatch
&
patch
:
gClobberPatches
)
{
UnprotectExecutableMemory
(
patch
.
mStart
patch
.
mEnd
-
patch
.
mStart
)
;
}
for
(
const
JumpPatch
&
patch
:
gJumpPatches
)
{
if
(
patch
.
mShort
)
{
Assembler
:
:
PatchShortJump
(
patch
.
mStart
patch
.
mTarget
)
;
}
else
{
Assembler
:
:
PatchJumpClobberRax
(
patch
.
mStart
patch
.
mTarget
)
;
}
}
for
(
const
ClobberPatch
&
patch
:
gClobberPatches
)
{
for
(
uint8_t
*
ip
=
patch
.
mStart
;
ip
<
patch
.
mEnd
;
ip
+
+
)
{
Assembler
:
:
PatchClobber
(
ip
)
;
}
}
return
true
;
}
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gMemoryLeakBytes
;
void
*
BindFunctionArgument
(
void
*
aFunction
void
*
aArgument
size_t
aArgumentPosition
Assembler
&
aAssembler
)
{
void
*
res
=
aAssembler
.
Current
(
)
;
aAssembler
.
MoveImmediateToRax
(
aArgument
)
;
switch
(
aArgumentPosition
)
{
case
1
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RSI
)
;
break
;
case
2
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RDX
)
;
break
;
case
3
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RCX
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
aAssembler
.
Jump
(
aFunction
)
;
return
res
;
}
}
}
