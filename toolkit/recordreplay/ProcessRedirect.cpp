#
include
"
ProcessRedirect
.
h
"
#
include
"
InfallibleVector
.
h
"
#
include
"
ExternalCall
.
h
"
#
include
"
ipc
/
ChildInternal
.
h
"
#
include
"
ipc
/
ParentInternal
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
string
.
h
>
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Wimplicit
-
fallthrough
"
#
endif
namespace
{
#
include
"
udis86
/
udis86
.
c
"
#
include
"
udis86
/
decode
.
c
"
#
include
"
udis86
/
itab
.
c
"
}
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
pop
#
endif
namespace
mozilla
{
namespace
recordreplay
{
static
bool
CallPreambleHook
(
PreambleFn
aPreamble
size_t
aCallId
CallArguments
*
aArguments
)
{
PreambleResult
result
=
aPreamble
(
aArguments
)
;
switch
(
result
)
{
case
PreambleResult
:
:
Veto
:
return
true
;
case
PreambleResult
:
:
IgnoreRedirect
:
RecordReplayInvokeCall
(
OriginalFunction
(
aCallId
)
aArguments
)
;
return
true
;
case
PreambleResult
:
:
PassThrough
:
{
AutoEnsurePassThroughThreadEvents
pt
;
RecordReplayInvokeCall
(
OriginalFunction
(
aCallId
)
aArguments
)
;
return
true
;
}
case
PreambleResult
:
:
Redirect
:
return
false
;
}
Unreachable
(
)
;
}
extern
"
C
"
{
__attribute__
(
(
used
)
)
int
RecordReplayInterceptCall
(
int
aCallId
CallArguments
*
aArguments
)
{
Redirection
&
redirection
=
GetRedirection
(
aCallId
)
;
if
(
redirection
.
mPreamble
)
{
if
(
CallPreambleHook
(
redirection
.
mPreamble
aCallId
aArguments
)
)
{
return
0
;
}
}
Thread
*
thread
=
Thread
:
:
Current
(
)
;
Maybe
<
RecordingEventSection
>
res
;
res
.
emplace
(
thread
)
;
if
(
!
res
.
ref
(
)
.
CanAccessEvents
(
)
)
{
if
(
!
thread
|
|
thread
-
>
PassThroughEvents
(
)
)
{
aArguments
-
>
Rval
<
uint8_t
*
>
(
)
=
redirection
.
mOriginalFunction
;
return
1
;
}
MOZ_RELEASE_ASSERT
(
thread
-
>
HasDivergedFromRecording
(
)
)
;
if
(
redirection
.
mExternalPreamble
)
{
if
(
CallPreambleHook
(
redirection
.
mExternalPreamble
aCallId
aArguments
)
)
{
return
0
;
}
}
if
(
redirection
.
mExternalCall
)
{
if
(
OnExternalCall
(
aCallId
aArguments
true
)
)
{
return
0
;
}
}
if
(
child
:
:
CurrentRepaintCannotFail
(
)
)
{
child
:
:
ReportFatalError
(
"
Could
not
perform
external
call
:
%
s
\
n
"
redirection
.
mName
)
;
}
EnsureNotDivergedFromRecording
(
Some
(
aCallId
)
)
;
Unreachable
(
)
;
}
if
(
IsRecording
(
)
)
{
res
.
reset
(
)
;
thread
-
>
SetPassThrough
(
true
)
;
RecordReplayInvokeCall
(
redirection
.
mOriginalFunction
aArguments
)
;
thread
-
>
SetPassThrough
(
false
)
;
res
.
emplace
(
thread
)
;
}
ErrorType
error
=
SaveError
(
)
;
thread
-
>
Events
(
)
.
RecordOrReplayThreadEvent
(
CallIdToThreadEvent
(
aCallId
)
)
;
if
(
redirection
.
mSaveOutput
)
{
redirection
.
mSaveOutput
(
thread
-
>
Events
(
)
aArguments
&
error
)
;
}
if
(
IsReplaying
(
)
&
&
redirection
.
mExternalCall
)
{
(
void
)
OnExternalCall
(
aCallId
aArguments
false
)
;
}
RestoreError
(
error
)
;
return
0
;
}
extern
size_t
RecordReplayRedirectCall
(
.
.
.
)
;
__asm
(
"
_RecordReplayRedirectCall
:
"
"
pushq
%
rbp
;
"
"
movq
%
rsp
%
rbp
;
"
"
subq
624
%
rsp
;
"
"
movq
%
rdi
0
(
%
rsp
)
;
"
"
movq
%
rsi
8
(
%
rsp
)
;
"
"
movq
%
rdx
16
(
%
rsp
)
;
"
"
movq
%
rcx
24
(
%
rsp
)
;
"
"
movq
%
r8
32
(
%
rsp
)
;
"
"
movq
%
r9
40
(
%
rsp
)
;
"
"
movsd
%
xmm0
48
(
%
rsp
)
;
"
"
movsd
%
xmm1
56
(
%
rsp
)
;
"
"
movsd
%
xmm2
64
(
%
rsp
)
;
"
"
movq
64
%
rsi
;
"
"
jmp
_RecordReplayRedirectCall_Loop
;
"
"
_RecordReplayRedirectCall_Loop
:
"
"
subq
1
%
rsi
;
"
"
movq
640
(
%
rsp
%
rsi
8
)
%
rdx
;
"
"
movq
%
rdx
104
(
%
rsp
%
rsi
8
)
;
"
"
testq
%
rsi
%
rsi
;
"
"
jne
_RecordReplayRedirectCall_Loop
;
"
"
movq
%
rax
%
rdi
;
"
"
movq
%
rsp
%
rsi
;
"
"
call
_RecordReplayInterceptCall
;
"
"
testq
%
rax
%
rax
;
"
"
je
RecordReplayRedirectCall_done
;
"
"
movq
0
(
%
rsp
)
%
rdi
;
"
"
movq
8
(
%
rsp
)
%
rsi
;
"
"
movq
16
(
%
rsp
)
%
rdx
;
"
"
movq
24
(
%
rsp
)
%
rcx
;
"
"
movq
32
(
%
rsp
)
%
r8
;
"
"
movq
40
(
%
rsp
)
%
r9
;
"
"
movsd
48
(
%
rsp
)
%
xmm0
;
"
"
movsd
56
(
%
rsp
)
%
xmm1
;
"
"
movsd
64
(
%
rsp
)
%
xmm2
;
"
"
movq
72
(
%
rsp
)
%
rax
;
"
"
addq
624
%
rsp
;
"
"
popq
%
rbp
;
"
"
jmpq
*
%
rax
;
"
"
RecordReplayRedirectCall_done
:
"
"
movq
72
(
%
rsp
)
%
rax
;
"
"
movq
80
(
%
rsp
)
%
rdx
;
"
"
movsd
88
(
%
rsp
)
%
xmm0
;
"
"
movsd
96
(
%
rsp
)
%
xmm1
;
"
"
addq
624
%
rsp
;
"
"
popq
%
rbp
;
"
"
ret
;
"
)
;
extern
void
RecordReplayInvokeCallRaw
(
CallArguments
*
aArguments
void
*
aFnPtr
)
;
__asm
(
"
_RecordReplayInvokeCallRaw
:
"
"
pushq
%
rbp
;
"
"
movq
%
rsp
%
rbp
;
"
"
movq
%
rsi
%
rax
;
"
"
push
%
rdi
;
"
"
push
%
rdi
;
"
"
movq
64
%
rsi
;
"
"
jmp
_RecordReplayInvokeCallRaw_Loop
;
"
"
_RecordReplayInvokeCallRaw_Loop
:
"
"
subq
1
%
rsi
;
"
"
movq
104
(
%
rdi
%
rsi
8
)
%
rdx
;
"
"
push
%
rdx
;
"
"
testq
%
rsi
%
rsi
;
"
"
jne
_RecordReplayInvokeCallRaw_Loop
;
"
"
movq
8
(
%
rdi
)
%
rsi
;
"
"
movq
16
(
%
rdi
)
%
rdx
;
"
"
movq
24
(
%
rdi
)
%
rcx
;
"
"
movq
32
(
%
rdi
)
%
r8
;
"
"
movq
40
(
%
rdi
)
%
r9
;
"
"
movsd
48
(
%
rdi
)
%
xmm0
;
"
"
movsd
56
(
%
rdi
)
%
xmm1
;
"
"
movsd
64
(
%
rdi
)
%
xmm2
;
"
"
movq
0
(
%
rdi
)
%
rdi
;
"
"
callq
*
%
rax
;
"
"
addq
512
%
rsp
;
"
"
pop
%
rdi
;
"
"
pop
%
rdi
;
"
"
movq
%
rax
72
(
%
rdi
)
;
"
"
movq
%
rdx
80
(
%
rdi
)
;
"
"
movsd
%
xmm0
88
(
%
rdi
)
;
"
"
movsd
%
xmm1
96
(
%
rdi
)
;
"
"
popq
%
rbp
;
"
"
ret
;
"
)
;
}
MOZ_NEVER_INLINE
void
RecordReplayInvokeCall
(
void
*
aFunction
CallArguments
*
aArguments
)
{
RecordReplayInvokeCallRaw
(
aArguments
aFunction
)
;
}
static
void
PrintRedirectSpew
(
const
char
*
aFormat
.
.
.
)
{
static
bool
spewEnabled
=
TestEnv
(
"
MOZ_RECORD_REPLAY_REDIRECT_SPEW
"
)
;
if
(
spewEnabled
)
{
va_list
ap
;
va_start
(
ap
aFormat
)
;
char
buf
[
4096
]
;
VsprintfLiteral
(
buf
aFormat
ap
)
;
va_end
(
ap
)
;
Print
(
"
%
s
"
buf
)
;
}
}
static
StaticInfallibleVector
<
std
:
:
pair
<
uint8_t
*
uint8_t
*
>
>
gInternalJumps
;
struct
JumpPatch
{
uint8_t
*
mStart
;
uint8_t
*
mTarget
;
bool
mShort
;
JumpPatch
(
uint8_t
*
aStart
uint8_t
*
aTarget
bool
aShort
)
:
mStart
(
aStart
)
mTarget
(
aTarget
)
mShort
(
aShort
)
{
}
}
;
static
StaticInfallibleVector
<
JumpPatch
>
gJumpPatches
;
static
void
AddJumpPatch
(
uint8_t
*
aStart
uint8_t
*
aTarget
bool
aShort
)
{
PrintRedirectSpew
(
"
Adding
jump
patch
:
%
p
-
>
%
p
[
Short
%
d
]
\
n
"
aStart
aTarget
aShort
)
;
gInternalJumps
.
emplaceBack
(
aStart
aTarget
)
;
gJumpPatches
.
emplaceBack
(
aStart
aTarget
aShort
)
;
}
static
void
AddLongJumpPatch
(
uint8_t
*
aStart
uint8_t
*
aTarget
)
{
AddJumpPatch
(
aStart
aTarget
false
)
;
}
static
bool
AddShortJumpPatch
(
uint8_t
*
aStart
uint8_t
*
aTarget
)
{
if
(
!
Assembler
:
:
CanPatchShortJump
(
aStart
aTarget
)
)
{
return
false
;
}
AddJumpPatch
(
aStart
aTarget
true
)
;
return
true
;
}
struct
ClobberPatch
{
uint8_t
*
mStart
;
uint8_t
*
mEnd
;
ClobberPatch
(
uint8_t
*
aStart
uint8_t
*
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
}
;
static
StaticInfallibleVector
<
ClobberPatch
>
gClobberPatches
;
static
void
AddClobberPatch
(
uint8_t
*
aStart
uint8_t
*
aEnd
)
{
if
(
aStart
<
aEnd
)
{
PrintRedirectSpew
(
"
Adding
clobber
patch
:
[
%
p
%
p
]
\
n
"
aStart
aEnd
)
;
gClobberPatches
.
emplaceBack
(
aStart
aEnd
)
;
}
}
static
uint8_t
*
SymbolBase
(
uint8_t
*
aPtr
)
{
Dl_info
info
;
if
(
!
dladdr
(
aPtr
&
info
)
)
{
MOZ_CRASH
(
)
;
}
return
static_cast
<
uint8_t
*
>
(
info
.
dli_saddr
)
;
}
static
size_t
DecodeInstruction
(
uint8_t
*
aIp
ud_t
*
aUd
)
{
ud_init
(
aUd
)
;
ud_set_input_buffer
(
aUd
aIp
MaximumInstructionLength
)
;
ud_set_mode
(
aUd
64
)
;
size_t
nbytes
=
ud_decode
(
aUd
)
;
MOZ_RELEASE_ASSERT
(
nbytes
&
&
nbytes
<
=
MaximumInstructionLength
)
;
return
nbytes
;
}
static
uint8_t
*
MaybeInternalJumpTarget
(
uint8_t
*
aIpStart
uint8_t
*
aIpEnd
)
{
PrintRedirectSpew
(
"
Checking
for
internal
jump
targets
:
[
%
p
%
p
]
\
n
"
aIpStart
aIpEnd
)
;
const
char
*
startName
=
SymbolNameRaw
(
aIpStart
)
;
const
char
*
endName
=
SymbolNameRaw
(
aIpEnd
-
1
)
;
if
(
strcmp
(
startName
endName
)
)
{
uint8_t
*
target
=
SymbolBase
(
aIpEnd
-
1
)
;
PrintRedirectSpew
(
"
Failed
[
%
p
]
:
Different
symbol
names
:
%
s
%
s
\
n
"
target
startName
endName
)
;
return
target
;
}
for
(
auto
jump
:
gInternalJumps
)
{
if
(
!
(
jump
.
first
>
=
aIpStart
&
&
jump
.
first
<
aIpEnd
)
&
&
jump
.
second
>
aIpStart
&
&
jump
.
second
<
aIpEnd
)
{
PrintRedirectSpew
(
"
Failed
[
%
p
]
:
Internal
jump
target
\
n
"
jump
.
second
)
;
return
jump
.
second
;
}
}
for
(
auto
patch
:
gJumpPatches
)
{
uint8_t
*
end
=
patch
.
mStart
+
(
patch
.
mShort
?
ShortJumpBytes
:
JumpBytesClobberRax
)
;
if
(
MemoryIntersects
(
aIpStart
aIpEnd
-
aIpStart
patch
.
mStart
end
-
patch
.
mStart
)
)
{
PrintRedirectSpew
(
"
Failed
[
%
p
]
:
Patched
region
\
n
"
end
)
;
return
end
;
}
}
for
(
auto
patch
:
gClobberPatches
)
{
if
(
MemoryIntersects
(
aIpStart
aIpEnd
-
aIpStart
patch
.
mStart
patch
.
mEnd
-
patch
.
mStart
)
)
{
PrintRedirectSpew
(
"
Failed
[
%
p
]
:
Clobbered
region
\
n
"
patch
.
mEnd
)
;
return
patch
.
mEnd
;
}
}
if
(
(
size_t
)
(
aIpEnd
-
aIpStart
)
>
ShortJumpBytes
)
{
if
(
(
strstr
(
startName
"
CTRunGetGlyphs
"
)
&
&
!
strstr
(
startName
"
CTRunGetGlyphsPtr
"
)
)
|
|
(
strstr
(
startName
"
CTRunGetPositions
"
)
&
&
!
strstr
(
startName
"
CTRunGetPositionsPtr
"
)
)
|
|
(
strstr
(
startName
"
CTRunGetStringIndices
"
)
&
&
!
strstr
(
startName
"
CTRunGetStringIndicesPtr
"
)
)
|
|
(
strstr
(
startName
"
CGColorSpaceCreateDeviceGray
"
)
&
&
!
strstr
(
startName
"
CGColorSpaceCreateDeviceGray_block_invoke
"
)
)
|
|
(
strstr
(
startName
"
CGColorSpaceCreateDeviceRGB
"
)
&
&
!
strstr
(
startName
"
CGColorSpaceCreateDeviceRGB_block_invoke
"
)
)
|
|
strstr
(
startName
"
__workq_kernreturn
"
)
|
|
strstr
(
startName
"
kevent64
"
)
|
|
strstr
(
startName
"
CGAffineTransformMakeScale
"
)
)
{
PrintRedirectSpew
(
"
Failed
[
%
p
]
:
Vetoed
by
annotation
\
n
"
aIpEnd
-
1
)
;
return
aIpEnd
-
1
;
}
}
PrintRedirectSpew
(
"
Success
!
\
n
"
)
;
return
nullptr
;
}
static
StaticInfallibleVector
<
char
*
>
gRedirectFailures
;
static
void
RedirectFailure
(
const
char
*
aFormat
.
.
.
)
{
va_list
ap
;
va_start
(
ap
aFormat
)
;
char
buf
[
4096
]
;
VsprintfLiteral
(
buf
aFormat
ap
)
;
va_end
(
ap
)
;
gRedirectFailures
.
emplaceBack
(
strdup
(
buf
)
)
;
PrintRedirectSpew
(
"
Redirection
failure
:
%
s
\
n
"
buf
)
;
}
static
void
UnknownInstruction
(
const
char
*
aName
uint8_t
*
aIp
size_t
aNbytes
)
{
nsCString
byteData
;
for
(
size_t
i
=
0
;
i
<
aNbytes
;
i
+
+
)
{
byteData
.
AppendPrintf
(
"
%
d
"
(
int
)
aIp
[
i
]
)
;
}
RedirectFailure
(
"
Unknown
instruction
in
%
s
[
%
p
]
:
%
s
"
aName
aIp
byteData
.
get
(
)
)
;
}
static
bool
CopySpecialInstruction
(
uint8_t
*
aIp
ud_t
*
aUd
size_t
aNbytes
Assembler
&
aAssembler
)
{
aAssembler
.
NoteOriginalInstruction
(
aIp
)
;
if
(
aUd
-
>
pfx_seg
)
{
return
false
;
}
ud_mnemonic_code
mnemonic
=
ud_insn_mnemonic
(
aUd
)
;
if
(
mnemonic
=
=
UD_Icall
|
|
mnemonic
=
=
UD_Ijmp
|
|
(
mnemonic
>
=
UD_Ijo
&
&
mnemonic
<
=
UD_Ijg
)
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
1
)
)
;
const
ud_operand
*
op
=
ud_insn_opr
(
aUd
0
)
;
if
(
op
-
>
type
=
=
UD_OP_JIMM
)
{
uint8_t
*
target
=
aIp
+
aNbytes
;
switch
(
op
-
>
size
)
{
case
8
:
target
+
=
op
-
>
lval
.
sbyte
;
break
;
case
32
:
target
+
=
op
-
>
lval
.
sdword
;
break
;
default
:
return
false
;
}
gInternalJumps
.
emplaceBack
(
nullptr
target
)
;
if
(
mnemonic
=
=
UD_Icall
)
{
aAssembler
.
MoveImmediateToRax
(
target
)
;
aAssembler
.
CallRax
(
)
;
}
else
if
(
mnemonic
=
=
UD_Ijmp
)
{
aAssembler
.
Jump
(
target
)
;
}
else
{
aAssembler
.
ConditionalJump
(
aUd
-
>
primary_opcode
target
)
;
}
return
true
;
}
if
(
op
-
>
type
=
=
UD_OP_MEM
&
&
!
op
-
>
index
)
{
if
(
op
-
>
base
=
=
UD_R_RIP
)
{
if
(
op
-
>
offset
=
=
32
)
{
uint8_t
*
addr
=
aIp
+
aNbytes
+
op
-
>
lval
.
sdword
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
8
)
;
aAssembler
.
JumpToRax
(
)
;
return
true
;
}
}
else
{
aAssembler
.
CopyInstruction
(
aIp
aNbytes
)
;
return
true
;
}
}
}
if
(
mnemonic
=
=
UD_Imov
|
|
mnemonic
=
=
UD_Ilea
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
2
)
)
;
const
ud_operand
*
dst
=
ud_insn_opr
(
aUd
0
)
;
const
ud_operand
*
src
=
ud_insn_opr
(
aUd
1
)
;
if
(
dst
-
>
type
=
=
UD_OP_REG
&
&
src
-
>
type
=
=
UD_OP_MEM
&
&
src
-
>
base
=
=
UD_R_RIP
&
&
!
src
-
>
index
&
&
src
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
dst
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
src
-
>
lval
.
sdword
;
if
(
reg
!
=
UD_R_RAX
)
{
aAssembler
.
PushRax
(
)
;
}
aAssembler
.
MoveImmediateToRax
(
addr
)
;
if
(
mnemonic
=
=
UD_Imov
)
{
aAssembler
.
LoadRax
(
src
-
>
size
/
8
)
;
}
if
(
reg
!
=
UD_R_RAX
)
{
aAssembler
.
MoveRaxToRegister
(
reg
)
;
aAssembler
.
PopRax
(
)
;
}
return
true
;
}
if
(
dst
-
>
type
=
=
UD_OP_MEM
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
&
&
src
-
>
type
=
=
UD_OP_REG
&
&
mnemonic
=
=
UD_Imov
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
src
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
PushRbx
(
)
;
aAssembler
.
MoveRegisterToRax
(
reg
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
PopRbx
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
StoreRbxToRax
(
src
-
>
size
/
8
)
;
aAssembler
.
PopRbx
(
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
}
if
(
mnemonic
=
=
UD_Icmp
)
{
MOZ_RELEASE_ASSERT
(
!
ud_insn_opr
(
aUd
2
)
)
;
const
ud_operand
*
dst
=
ud_insn_opr
(
aUd
0
)
;
const
ud_operand
*
src
=
ud_insn_opr
(
aUd
1
)
;
if
(
dst
-
>
type
=
=
UD_OP_MEM
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
&
&
src
-
>
type
=
=
UD_OP_IMM
&
&
src
-
>
size
=
=
8
)
{
uint8_t
value
=
src
-
>
lval
.
ubyte
;
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
dst
-
>
size
/
8
)
;
aAssembler
.
CompareValueWithRax
(
value
dst
-
>
size
/
8
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
if
(
dst
-
>
type
=
=
UD_OP_REG
&
&
src
-
>
type
=
=
UD_OP_MEM
&
&
src
-
>
base
=
=
UD_R_RIP
&
&
!
src
-
>
index
&
&
src
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
dst
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
src
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveRegisterToRax
(
reg
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
8
)
;
aAssembler
.
CompareRaxWithTopOfStack
(
)
;
aAssembler
.
PopRax
(
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
if
(
dst
-
>
type
=
=
UD_OP_MEM
&
&
src
-
>
type
=
=
UD_OP_REG
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
src
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveRegisterToRax
(
reg
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
LoadRax
(
8
)
;
aAssembler
.
CompareTopOfStackWithRax
(
)
;
aAssembler
.
PopRax
(
)
;
aAssembler
.
PopRax
(
)
;
return
true
;
}
}
if
(
mnemonic
=
=
UD_Ixchg
)
{
const
ud_operand
*
dst
=
ud_insn_opr
(
aUd
0
)
;
const
ud_operand
*
src
=
ud_insn_opr
(
aUd
1
)
;
if
(
src
-
>
type
=
=
UD_OP_REG
&
&
src
-
>
size
=
=
8
&
&
dst
-
>
type
=
=
UD_OP_MEM
&
&
dst
-
>
base
=
=
UD_R_RIP
&
&
!
dst
-
>
index
&
&
dst
-
>
offset
=
=
32
)
{
int
reg
=
Assembler
:
:
NormalizeRegister
(
src
-
>
base
)
;
if
(
!
reg
)
{
return
false
;
}
uint8_t
*
addr
=
aIp
+
aNbytes
+
dst
-
>
lval
.
sdword
;
if
(
reg
=
=
UD_R_RBX
)
{
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
ExchangeByteRbxWithAddressAtRax
(
)
;
aAssembler
.
PopRax
(
)
;
}
else
{
aAssembler
.
PushRbx
(
)
;
aAssembler
.
PushRax
(
)
;
aAssembler
.
MoveImmediateToRax
(
addr
)
;
aAssembler
.
MoveRaxToRegister
(
UD_R_RBX
)
;
aAssembler
.
PopRax
(
)
;
aAssembler
.
ExchangeByteRegisterWithAddressAtRbx
(
reg
)
;
aAssembler
.
PopRbx
(
)
;
}
return
true
;
}
}
return
false
;
}
static
size_t
CopyInstruction
(
const
char
*
aName
uint8_t
*
aIp
Assembler
&
aAssembler
)
{
ud_t
ud
;
size_t
nbytes
=
DecodeInstruction
(
aIp
&
ud
)
;
if
(
CopySpecialInstruction
(
aIp
&
ud
nbytes
aAssembler
)
)
{
return
nbytes
;
}
ud_mnemonic_code_t
mnemonic
=
ud_insn_mnemonic
(
&
ud
)
;
if
(
mnemonic
=
=
UD_Icall
|
|
(
mnemonic
>
=
UD_Ijo
&
&
mnemonic
<
=
UD_Ijmp
)
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
for
(
size_t
i
=
0
;
;
i
+
+
)
{
const
ud_operand_t
*
op
=
ud_insn_opr
(
&
ud
i
)
;
if
(
!
op
)
{
break
;
}
switch
(
op
-
>
type
)
{
case
UD_OP_MEM
:
if
(
op
-
>
index
=
=
UD_R_RIP
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
[
[
fallthrough
]
]
;
case
UD_OP_REG
:
if
(
op
-
>
base
=
=
UD_R_RIP
)
{
UnknownInstruction
(
aName
aIp
nbytes
)
;
return
nbytes
;
}
break
;
default
:
break
;
}
}
aAssembler
.
CopyInstruction
(
aIp
nbytes
)
;
return
nbytes
;
}
static
uint8_t
*
CopyInstructions
(
const
char
*
aName
uint8_t
*
aIpStart
uint8_t
*
aIpEnd
Assembler
&
aAssembler
)
{
uint8_t
*
ip
=
aIpStart
;
while
(
ip
<
aIpEnd
)
{
ip
+
=
CopyInstruction
(
aName
ip
aAssembler
)
;
}
return
ip
;
}
static
bool
PreserveCallerSaveRegisters
(
const
char
*
aName
)
{
return
!
strcmp
(
aName
"
tlv_get_addr
"
)
;
}
static
uint8_t
*
GenerateRedirectStub
(
Assembler
&
aAssembler
size_t
aCallId
)
{
uint8_t
*
newFunction
=
aAssembler
.
Current
(
)
;
if
(
PreserveCallerSaveRegisters
(
GetRedirection
(
aCallId
)
.
mName
)
)
{
static
int
registers
[
]
=
{
UD_R_RDI
UD_R_RDI
UD_R_RSI
UD_R_RDX
UD_R_RCX
UD_R_R8
UD_R_R9
UD_R_R10
UD_R_R11
}
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
registers
)
;
i
+
+
)
{
aAssembler
.
MoveRegisterToRax
(
registers
[
i
]
)
;
aAssembler
.
PushRax
(
)
;
}
aAssembler
.
MoveImmediateToRax
(
(
void
*
)
aCallId
)
;
uint8_t
*
after
=
aAssembler
.
Current
(
)
+
PushImmediateBytes
+
JumpBytes
;
aAssembler
.
PushImmediate
(
after
)
;
aAssembler
.
Jump
(
BitwiseCast
<
void
*
>
(
RecordReplayRedirectCall
)
)
;
for
(
int
i
=
ArrayLength
(
registers
)
-
1
;
i
>
=
0
;
i
-
-
)
{
aAssembler
.
PopRegister
(
registers
[
i
]
)
;
}
aAssembler
.
Return
(
)
;
}
else
{
aAssembler
.
MoveImmediateToRax
(
(
void
*
)
aCallId
)
;
aAssembler
.
Jump
(
BitwiseCast
<
void
*
>
(
RecordReplayRedirectCall
)
)
;
}
return
newFunction
;
}
static
void
Redirect
(
size_t
aCallId
Redirection
&
aRedirection
Assembler
&
aAssembler
bool
aFirstPass
)
{
uint8_t
*
functionStart
=
aRedirection
.
mBaseFunction
;
uint8_t
*
ro
=
functionStart
;
if
(
!
functionStart
)
{
if
(
aFirstPass
)
{
PrintRedirectSpew
(
"
Could
not
find
symbol
%
s
for
redirecting
.
\
n
"
aRedirection
.
mName
)
;
}
return
;
}
if
(
aRedirection
.
mOriginalFunction
!
=
aRedirection
.
mBaseFunction
)
{
MOZ_RELEASE_ASSERT
(
!
aFirstPass
)
;
return
;
}
PrintRedirectSpew
(
"
Redirecting
[
FirstPass
%
d
]
%
s
:
%
p
\
n
"
aFirstPass
aRedirection
.
mName
functionStart
)
;
uint8_t
*
extent
=
ro
+
JumpBytesClobberRax
;
if
(
!
MaybeInternalJumpTarget
(
ro
extent
)
)
{
aRedirection
.
mOriginalFunction
=
aAssembler
.
Current
(
)
;
ro
=
CopyInstructions
(
aRedirection
.
mName
ro
extent
aAssembler
)
;
aAssembler
.
Jump
(
ro
)
;
uint8_t
*
newFunction
=
GenerateRedirectStub
(
aAssembler
aCallId
)
;
AddLongJumpPatch
(
functionStart
newFunction
)
;
AddClobberPatch
(
functionStart
+
JumpBytesClobberRax
ro
)
;
return
;
}
if
(
aFirstPass
)
{
return
;
}
if
(
MaybeInternalJumpTarget
(
ro
ro
+
ShortJumpBytes
)
)
{
RedirectFailure
(
"
Can
'
t
patch
short
jump
for
%
s
"
aRedirection
.
mName
)
;
}
aRedirection
.
mOriginalFunction
=
aAssembler
.
Current
(
)
;
uint8_t
*
nro
=
CopyInstructions
(
aRedirection
.
mName
ro
ro
+
ShortJumpBytes
aAssembler
)
;
aAssembler
.
Jump
(
nro
)
;
ro
=
SymbolBase
(
extent
)
;
while
(
true
)
{
extent
=
ro
+
JumpBytesClobberRax
*
2
;
uint8_t
*
target
=
MaybeInternalJumpTarget
(
ro
extent
)
;
if
(
target
)
{
ro
=
target
;
continue
;
}
break
;
}
uint8_t
*
firstJumpTarget
=
aAssembler
.
Current
(
)
;
uint8_t
*
afterip
=
CopyInstructions
(
aRedirection
.
mName
ro
extent
aAssembler
)
;
aAssembler
.
Jump
(
afterip
)
;
AddLongJumpPatch
(
ro
firstJumpTarget
)
;
uint8_t
*
newFunction
=
GenerateRedirectStub
(
aAssembler
aCallId
)
;
AddLongJumpPatch
(
ro
+
JumpBytesClobberRax
newFunction
)
;
AddClobberPatch
(
ro
+
2
*
JumpBytesClobberRax
afterip
)
;
if
(
!
AddShortJumpPatch
(
functionStart
ro
+
JumpBytesClobberRax
)
)
{
RedirectFailure
(
"
Short
jump
distance
too
long
for
%
s
"
aRedirection
.
mName
)
;
}
AddClobberPatch
(
functionStart
+
ShortJumpBytes
nro
)
;
}
bool
InitializeRedirections
(
)
{
MOZ_RELEASE_ASSERT
(
IsRecordingOrReplaying
(
)
)
;
{
Assembler
assembler
;
size_t
numRedirections
=
NumRedirections
(
)
;
for
(
size_t
i
=
0
;
i
<
numRedirections
;
i
+
+
)
{
Redirection
&
redirection
=
GetRedirection
(
i
)
;
Redirect
(
i
redirection
assembler
true
)
;
}
for
(
size_t
i
=
0
;
i
<
numRedirections
;
i
+
+
)
{
Redirection
&
redirection
=
GetRedirection
(
i
)
;
Redirect
(
i
redirection
assembler
false
)
;
}
}
if
(
!
gRedirectFailures
.
empty
(
)
)
{
nsCString
data
;
for
(
char
*
reason
:
gRedirectFailures
)
{
data
.
AppendPrintf
(
"
%
s
\
n
"
reason
)
;
}
gInitializationFailureMessage
=
strdup
(
data
.
get
(
)
)
;
return
false
;
}
for
(
const
JumpPatch
&
patch
:
gJumpPatches
)
{
UnprotectExecutableMemory
(
patch
.
mStart
patch
.
mShort
?
ShortJumpBytes
:
JumpBytesClobberRax
)
;
}
for
(
const
ClobberPatch
&
patch
:
gClobberPatches
)
{
UnprotectExecutableMemory
(
patch
.
mStart
patch
.
mEnd
-
patch
.
mStart
)
;
}
for
(
const
JumpPatch
&
patch
:
gJumpPatches
)
{
if
(
patch
.
mShort
)
{
Assembler
:
:
PatchShortJump
(
patch
.
mStart
patch
.
mTarget
)
;
}
else
{
Assembler
:
:
PatchJumpClobberRax
(
patch
.
mStart
patch
.
mTarget
)
;
}
}
for
(
const
ClobberPatch
&
patch
:
gClobberPatches
)
{
for
(
uint8_t
*
ip
=
patch
.
mStart
;
ip
<
patch
.
mEnd
;
ip
+
+
)
{
Assembler
:
:
PatchClobber
(
ip
)
;
}
}
return
true
;
}
void
*
OriginalFunction
(
const
char
*
aName
)
{
size_t
numRedirections
=
NumRedirections
(
)
;
for
(
size_t
i
=
0
;
i
<
numRedirections
;
i
+
+
)
{
const
Redirection
&
redirection
=
GetRedirection
(
i
)
;
if
(
!
strcmp
(
aName
redirection
.
mName
)
)
{
return
redirection
.
mOriginalFunction
;
}
}
MOZ_CRASH
(
"
OriginalFunction
:
unknown
redirection
"
)
;
}
Atomic
<
size_t
SequentiallyConsistent
Behavior
:
:
DontPreserve
>
gMemoryLeakBytes
;
void
*
BindFunctionArgument
(
void
*
aFunction
void
*
aArgument
size_t
aArgumentPosition
Assembler
&
aAssembler
)
{
void
*
res
=
aAssembler
.
Current
(
)
;
aAssembler
.
MoveImmediateToRax
(
aArgument
)
;
switch
(
aArgumentPosition
)
{
case
1
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RSI
)
;
break
;
case
2
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RDX
)
;
break
;
case
3
:
aAssembler
.
MoveRaxToRegister
(
UD_R_RCX
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
aAssembler
.
Jump
(
aFunction
)
;
return
res
;
}
}
}
