#
include
"
ThreadSnapshot
.
h
"
#
include
"
Thread
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
#
define
QuoteString
(
aString
)
#
aString
#
define
ExpandAndQuote
(
aMacro
)
QuoteString
(
aMacro
)
#
define
THREAD_STACK_TOP_SIZE
2048
struct
ThreadState
{
uintptr_t
mCalleeSaveRegisters
[
6
]
;
uintptr_t
mStackPointer
;
uint8_t
mStackTop
[
THREAD_STACK_TOP_SIZE
]
;
size_t
mStackTopBytes
;
uint8_t
*
mStackContents
;
size_t
mStackBytes
;
}
;
static
ThreadState
*
gThreadState
;
void
InitializeThreadSnapshots
(
)
{
size_t
numThreads
=
MaxThreadId
+
1
;
gThreadState
=
new
ThreadState
[
numThreads
]
;
memset
(
gThreadState
0
numThreads
*
sizeof
(
ThreadState
)
)
;
}
static
void
ClearThreadState
(
ThreadState
*
aInfo
)
{
free
(
aInfo
-
>
mStackContents
)
;
aInfo
-
>
mStackContents
=
nullptr
;
aInfo
-
>
mStackBytes
=
0
;
}
extern
"
C
"
{
#
define
THREAD_STACK_POINTER_OFFSET
48
#
define
THREAD_STACK_TOP_OFFSET
56
#
define
THREAD_STACK_TOP_BYTES_OFFSET
2104
#
define
THREAD_STACK_CONTENTS_OFFSET
2112
#
define
THREAD_STACK_BYTES_OFFSET
2120
extern
int
SaveThreadStateOrReturnFromRestore
(
ThreadState
*
aInfo
int
*
aStackSeparator
)
;
__asm
(
"
_SaveThreadStateOrReturnFromRestore
:
"
"
movq
%
rsp
"
ExpandAndQuote
(
THREAD_STACK_POINTER_OFFSET
)
"
(
%
rdi
)
;
"
"
subq
%
rsp
%
rsi
;
"
/
/
rsi
is
the
second
arg
reg
"
cmpl
"
ExpandAndQuote
(
THREAD_STACK_TOP_SIZE
)
"
%
esi
;
"
"
jg
SaveThreadStateOrReturnFromRestore_crash
;
"
"
movq
%
rsi
"
ExpandAndQuote
(
THREAD_STACK_TOP_BYTES_OFFSET
)
"
(
%
rdi
)
;
"
"
movq
%
rsp
%
r8
;
"
"
movq
%
rdi
%
r9
;
"
"
addq
"
ExpandAndQuote
(
THREAD_STACK_TOP_OFFSET
)
"
%
r9
;
"
"
jmp
SaveThreadStateOrReturnFromRestore_copyTopRestart
;
"
"
SaveThreadStateOrReturnFromRestore_copyTopRestart
:
"
"
testq
%
rsi
%
rsi
;
"
"
je
SaveThreadStateOrReturnFromRestore_copyTopDone
;
"
"
movl
0
(
%
r8
)
%
ecx
;
"
"
movl
%
ecx
0
(
%
r9
)
;
"
"
addq
4
%
r8
;
"
"
addq
4
%
r9
;
"
"
subq
4
%
rsi
;
"
"
jmp
SaveThreadStateOrReturnFromRestore_copyTopRestart
;
"
"
SaveThreadStateOrReturnFromRestore_copyTopDone
:
"
"
movq
%
rbx
0
(
%
rdi
)
;
"
"
movq
%
rbp
8
(
%
rdi
)
;
"
"
movq
%
r12
16
(
%
rdi
)
;
"
"
movq
%
r13
24
(
%
rdi
)
;
"
"
movq
%
r14
32
(
%
rdi
)
;
"
"
movq
%
r15
40
(
%
rdi
)
;
"
"
movq
0
%
rax
;
"
"
ret
;
"
"
SaveThreadStateOrReturnFromRestore_crash
:
"
"
movq
0
%
rbx
;
"
"
movq
0
(
%
rbx
)
%
rbx
;
"
)
;
extern
void
RestoreThreadState
(
ThreadState
*
aInfo
)
;
__asm
(
"
_RestoreThreadState
:
"
"
movq
0
(
%
rdi
)
%
rbx
;
"
"
movq
8
(
%
rdi
)
%
rbp
;
"
"
movq
16
(
%
rdi
)
%
r12
;
"
"
movq
24
(
%
rdi
)
%
r13
;
"
"
movq
32
(
%
rdi
)
%
r14
;
"
"
movq
40
(
%
rdi
)
%
r15
;
"
"
movq
"
ExpandAndQuote
(
THREAD_STACK_POINTER_OFFSET
)
"
(
%
rdi
)
%
rsp
;
"
"
movq
%
rsp
%
rcx
;
"
"
movq
"
ExpandAndQuote
(
THREAD_STACK_CONTENTS_OFFSET
)
"
(
%
rdi
)
%
r8
;
"
"
movq
"
ExpandAndQuote
(
THREAD_STACK_BYTES_OFFSET
)
"
(
%
rdi
)
%
r9
;
"
"
jmp
RestoreThreadState_copyAfterRestart
;
"
"
RestoreThreadState_copyAfterRestart
:
"
"
testq
%
r9
%
r9
;
"
"
je
RestoreThreadState_done
;
"
"
movl
0
(
%
r8
)
%
edx
;
"
"
movl
%
edx
0
(
%
rcx
)
;
"
"
addq
4
%
rcx
;
"
"
addq
4
%
r8
;
"
"
subq
4
%
r9
;
"
"
jmp
RestoreThreadState_copyAfterRestart
;
"
"
RestoreThreadState_done
:
"
"
movq
1
%
rax
;
"
"
ret
;
"
)
;
}
bool
SaveThreadState
(
size_t
aId
int
*
aStackSeparator
)
{
static_assert
(
offsetof
(
ThreadState
mStackPointer
)
=
=
THREAD_STACK_POINTER_OFFSET
&
&
offsetof
(
ThreadState
mStackTop
)
=
=
THREAD_STACK_TOP_OFFSET
&
&
offsetof
(
ThreadState
mStackTopBytes
)
=
=
THREAD_STACK_TOP_BYTES_OFFSET
&
&
offsetof
(
ThreadState
mStackContents
)
=
=
THREAD_STACK_CONTENTS_OFFSET
&
&
offsetof
(
ThreadState
mStackBytes
)
=
=
THREAD_STACK_BYTES_OFFSET
"
Incorrect
ThreadState
offsets
"
)
;
MOZ_RELEASE_ASSERT
(
aId
<
=
MaxThreadId
)
;
ThreadState
*
info
=
&
gThreadState
[
aId
]
;
bool
res
=
SaveThreadStateOrReturnFromRestore
(
info
aStackSeparator
)
=
=
0
;
if
(
!
res
)
{
ClearThreadState
(
info
)
;
}
return
res
;
}
void
SaveThreadStack
(
size_t
aId
)
{
Thread
*
thread
=
Thread
:
:
GetById
(
aId
)
;
MOZ_RELEASE_ASSERT
(
aId
<
=
MaxThreadId
)
;
ThreadState
&
info
=
gThreadState
[
aId
]
;
uint8_t
*
stackPointer
=
(
uint8_t
*
)
info
.
mStackPointer
;
uint8_t
*
stackTop
=
thread
-
>
StackBase
(
)
+
thread
-
>
StackSize
(
)
;
MOZ_RELEASE_ASSERT
(
stackTop
>
=
stackPointer
)
;
size_t
stackBytes
=
stackTop
-
stackPointer
;
MOZ_RELEASE_ASSERT
(
stackBytes
>
=
info
.
mStackTopBytes
)
;
free
(
info
.
mStackContents
)
;
info
.
mStackContents
=
(
uint8_t
*
)
malloc
(
stackBytes
)
;
info
.
mStackBytes
=
stackBytes
;
memcpy
(
info
.
mStackContents
info
.
mStackTop
info
.
mStackTopBytes
)
;
memcpy
(
info
.
mStackContents
+
info
.
mStackTopBytes
stackPointer
+
info
.
mStackTopBytes
stackBytes
-
info
.
mStackTopBytes
)
;
}
void
RestoreThreadStack
(
size_t
aId
)
{
MOZ_RELEASE_ASSERT
(
aId
<
=
MaxThreadId
)
;
ThreadState
*
info
=
&
gThreadState
[
aId
]
;
MOZ_RELEASE_ASSERT
(
info
-
>
mStackContents
)
;
RestoreThreadState
(
info
)
;
Unreachable
(
)
;
}
}
}
