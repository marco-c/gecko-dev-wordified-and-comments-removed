#
include
"
ThreadSnapshot
.
h
"
#
include
"
MemorySnapshot
.
h
"
#
include
"
SpinLock
.
h
"
#
include
"
Thread
.
h
"
namespace
mozilla
{
namespace
recordreplay
{
#
define
QuoteString
(
aString
)
#
aString
#
define
ExpandAndQuote
(
aMacro
)
QuoteString
(
aMacro
)
#
define
THREAD_STACK_TOP_SIZE
2048
struct
ThreadState
{
size_t
mShouldRestore
;
jmp_buf
mRegisters
;
uint32_t
mPadding
;
void
*
mStackPointer
;
uint8_t
mStackTop
[
THREAD_STACK_TOP_SIZE
]
;
size_t
mStackTopBytes
;
uint8_t
*
mStackContents
;
size_t
mStackBytes
;
}
;
static
ThreadState
*
gThreadState
;
void
InitializeThreadSnapshots
(
size_t
aNumThreads
)
{
gThreadState
=
(
ThreadState
*
)
AllocateMemory
(
aNumThreads
*
sizeof
(
ThreadState
)
UntrackedMemoryKind
:
:
ThreadSnapshot
)
;
jmp_buf
buf
;
if
(
setjmp
(
buf
)
=
=
0
)
{
longjmp
(
buf
1
)
;
}
ThreadYield
(
)
;
}
static
void
ClearThreadState
(
ThreadState
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
aInfo
-
>
mShouldRestore
)
;
DeallocateMemory
(
aInfo
-
>
mStackContents
aInfo
-
>
mStackBytes
UntrackedMemoryKind
:
:
ThreadSnapshot
)
;
aInfo
-
>
mShouldRestore
=
false
;
aInfo
-
>
mStackContents
=
nullptr
;
aInfo
-
>
mStackBytes
=
0
;
}
extern
"
C
"
{
extern
int
SaveThreadStateOrReturnFromRestore
(
ThreadState
*
aInfo
int
(
*
aSetjmpArg
)
(
jmp_buf
)
int
*
aStackSeparator
)
;
#
define
THREAD_REGISTERS_OFFSET
8
#
define
THREAD_STACK_POINTER_OFFSET
160
#
define
THREAD_STACK_TOP_OFFSET
168
#
define
THREAD_STACK_TOP_BYTES_OFFSET
2216
#
define
THREAD_STACK_CONTENTS_OFFSET
2224
#
define
THREAD_STACK_BYTES_OFFSET
2232
__asm
(
"
_SaveThreadStateOrReturnFromRestore
:
"
"
push
%
rbx
;
"
"
movq
%
rdi
%
rbx
;
"
"
movq
%
rsp
"
ExpandAndQuote
(
THREAD_STACK_POINTER_OFFSET
)
"
(
%
rbx
)
;
"
"
subq
%
rsp
%
rdx
;
"
/
/
rdx
is
the
third
arg
reg
"
cmpl
"
ExpandAndQuote
(
THREAD_STACK_TOP_SIZE
)
"
%
edx
;
"
"
jg
SaveThreadStateOrReturnFromRestore_crash
;
"
"
movq
%
rdx
"
ExpandAndQuote
(
THREAD_STACK_TOP_BYTES_OFFSET
)
"
(
%
rbx
)
;
"
"
movq
%
rsp
%
r8
;
"
"
movq
%
rbx
%
r9
;
"
"
addq
"
ExpandAndQuote
(
THREAD_STACK_TOP_OFFSET
)
"
%
r9
;
"
"
jmp
SaveThreadStateOrReturnFromRestore_copyTopRestart
;
"
"
SaveThreadStateOrReturnFromRestore_copyTopRestart
:
"
"
testq
%
rdx
%
rdx
;
"
"
je
SaveThreadStateOrReturnFromRestore_copyTopDone
;
"
"
movl
0
(
%
r8
)
%
ecx
;
"
"
movl
%
ecx
0
(
%
r9
)
;
"
"
addq
4
%
r8
;
"
"
addq
4
%
r9
;
"
"
subq
4
%
rdx
;
"
"
jmp
SaveThreadStateOrReturnFromRestore_copyTopRestart
;
"
"
SaveThreadStateOrReturnFromRestore_copyTopDone
:
"
"
addq
"
ExpandAndQuote
(
THREAD_REGISTERS_OFFSET
)
"
%
rdi
;
"
"
callq
*
%
rsi
;
"
"
testl
%
eax
%
eax
;
"
"
je
SaveThreadStateOrReturnFromRestore_done
;
"
"
movq
"
ExpandAndQuote
(
THREAD_STACK_POINTER_OFFSET
)
"
(
%
rbx
)
%
rcx
;
"
"
movq
"
ExpandAndQuote
(
THREAD_STACK_CONTENTS_OFFSET
)
"
(
%
rbx
)
%
r8
;
"
"
movq
"
ExpandAndQuote
(
THREAD_STACK_BYTES_OFFSET
)
"
(
%
rbx
)
%
r9
;
"
"
cmpq
%
rsp
%
rcx
;
"
"
jne
SaveThreadStateOrReturnFromRestore_crash
;
"
"
jmp
SaveThreadStateOrReturnFromRestore_copyAfterRestart
;
"
"
SaveThreadStateOrReturnFromRestore_copyAfterRestart
:
"
"
testq
%
r9
%
r9
;
"
"
je
SaveThreadStateOrReturnFromRestore_done
;
"
"
movl
0
(
%
r8
)
%
edx
;
"
"
movl
%
edx
0
(
%
rcx
)
;
"
"
addq
4
%
rcx
;
"
"
addq
4
%
r8
;
"
"
subq
4
%
r9
;
"
"
jmp
SaveThreadStateOrReturnFromRestore_copyAfterRestart
;
"
"
SaveThreadStateOrReturnFromRestore_crash
:
"
"
movq
0
%
rbx
;
"
"
movq
0
(
%
rbx
)
%
rbx
;
"
"
SaveThreadStateOrReturnFromRestore_done
:
"
"
pop
%
rbx
;
"
"
ret
;
"
)
;
}
bool
SaveThreadState
(
size_t
aId
int
*
aStackSeparator
)
{
static_assert
(
offsetof
(
ThreadState
mRegisters
)
=
=
THREAD_REGISTERS_OFFSET
&
&
offsetof
(
ThreadState
mStackPointer
)
=
=
THREAD_STACK_POINTER_OFFSET
&
&
offsetof
(
ThreadState
mStackTop
)
=
=
THREAD_STACK_TOP_OFFSET
&
&
offsetof
(
ThreadState
mStackTopBytes
)
=
=
THREAD_STACK_TOP_BYTES_OFFSET
&
&
offsetof
(
ThreadState
mStackContents
)
=
=
THREAD_STACK_CONTENTS_OFFSET
&
&
offsetof
(
ThreadState
mStackBytes
)
=
=
THREAD_STACK_BYTES_OFFSET
"
Incorrect
ThreadState
offsets
"
)
;
ThreadState
*
info
=
&
gThreadState
[
aId
]
;
MOZ_RELEASE_ASSERT
(
!
info
-
>
mShouldRestore
)
;
bool
res
=
SaveThreadStateOrReturnFromRestore
(
info
setjmp
aStackSeparator
)
=
=
0
;
if
(
!
res
)
{
ClearThreadState
(
info
)
;
}
return
res
;
}
void
RestoreThreadStack
(
size_t
aId
)
{
ThreadState
*
info
=
&
gThreadState
[
aId
]
;
longjmp
(
info
-
>
mRegisters
1
)
;
MOZ_CRASH
(
)
;
}
static
void
SaveThreadStack
(
SavedThreadStack
&
aStack
size_t
aId
)
{
Thread
*
thread
=
Thread
:
:
GetById
(
aId
)
;
ThreadState
&
info
=
gThreadState
[
aId
]
;
aStack
.
mStackPointer
=
info
.
mStackPointer
;
MemoryMove
(
aStack
.
mRegisters
info
.
mRegisters
sizeof
(
jmp_buf
)
)
;
uint8_t
*
stackPointer
=
(
uint8_t
*
)
info
.
mStackPointer
;
uint8_t
*
stackTop
=
thread
-
>
StackBase
(
)
+
thread
-
>
StackSize
(
)
;
MOZ_RELEASE_ASSERT
(
stackTop
>
=
stackPointer
)
;
size_t
stackBytes
=
stackTop
-
stackPointer
;
MOZ_RELEASE_ASSERT
(
stackBytes
>
=
info
.
mStackTopBytes
)
;
aStack
.
mStack
=
(
uint8_t
*
)
AllocateMemory
(
stackBytes
UntrackedMemoryKind
:
:
ThreadSnapshot
)
;
aStack
.
mStackBytes
=
stackBytes
;
MemoryMove
(
aStack
.
mStack
info
.
mStackTop
info
.
mStackTopBytes
)
;
MemoryMove
(
aStack
.
mStack
+
info
.
mStackTopBytes
stackPointer
+
info
.
mStackTopBytes
stackBytes
-
info
.
mStackTopBytes
)
;
}
static
void
RestoreStackForLoadingByThread
(
const
SavedThreadStack
&
aStack
size_t
aId
)
{
ThreadState
&
info
=
gThreadState
[
aId
]
;
MOZ_RELEASE_ASSERT
(
!
info
.
mShouldRestore
)
;
info
.
mStackPointer
=
aStack
.
mStackPointer
;
MemoryMove
(
info
.
mRegisters
aStack
.
mRegisters
sizeof
(
jmp_buf
)
)
;
info
.
mStackBytes
=
aStack
.
mStackBytes
;
uint8_t
*
stackContents
=
(
uint8_t
*
)
AllocateMemory
(
info
.
mStackBytes
UntrackedMemoryKind
:
:
ThreadSnapshot
)
;
MemoryMove
(
stackContents
aStack
.
mStack
aStack
.
mStackBytes
)
;
info
.
mStackContents
=
stackContents
;
info
.
mShouldRestore
=
true
;
}
bool
ShouldRestoreThreadStack
(
size_t
aId
)
{
return
gThreadState
[
aId
]
.
mShouldRestore
;
}
bool
SaveAllThreads
(
SavedCheckpoint
&
aSaved
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
AutoPassThroughThreadEvents
pt
;
AutoDisallowMemoryChanges
disallow
;
int
stackSeparator
=
0
;
if
(
!
SaveThreadState
(
MainThreadId
&
stackSeparator
)
)
{
return
false
;
}
for
(
size_t
i
=
MainThreadId
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
SaveThreadStack
(
aSaved
.
mStacks
[
i
-
1
]
i
)
;
}
return
true
;
}
void
RestoreAllThreads
(
const
SavedCheckpoint
&
aSaved
)
{
MOZ_RELEASE_ASSERT
(
Thread
:
:
CurrentIsMainThread
(
)
)
;
BeginPassThroughThreadEvents
(
)
;
SetMemoryChangesAllowed
(
false
)
;
for
(
size_t
i
=
MainThreadId
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
RestoreStackForLoadingByThread
(
aSaved
.
mStacks
[
i
-
1
]
i
)
;
}
RestoreThreadStack
(
MainThreadId
)
;
Unreachable
(
)
;
}
void
WaitForIdleThreadsToRestoreTheirStacks
(
)
{
while
(
true
)
{
bool
done
=
true
;
for
(
size_t
i
=
MainThreadId
+
1
;
i
<
=
MaxRecordedThreadId
;
i
+
+
)
{
if
(
ShouldRestoreThreadStack
(
i
)
)
{
Thread
:
:
Notify
(
i
)
;
done
=
false
;
}
}
if
(
done
)
{
break
;
}
Thread
:
:
WaitNoIdle
(
)
;
}
}
}
}
