const
{
EnableDelayHelper
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PrivateBrowsingUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
class
MozHandler
extends
window
.
MozElements
.
MozRichlistitem
{
connectedCallback
(
)
{
this
.
textContent
=
"
"
;
this
.
appendChild
(
window
.
MozXULElement
.
parseXULToFragment
(
<
vbox
pack
=
"
center
"
>
<
image
height
=
"
32
"
width
=
"
32
"
/
>
<
/
vbox
>
<
vbox
flex
=
"
1
"
>
<
label
class
=
"
name
"
/
>
<
label
class
=
"
description
"
/
>
<
/
vbox
>
)
)
;
this
.
initializeAttributeInheritance
(
)
;
}
static
get
inheritedAttributes
(
)
{
return
{
image
:
"
src
=
image
disabled
"
"
.
name
"
:
"
value
=
name
disabled
"
"
.
description
"
:
"
value
=
description
disabled
"
}
;
}
get
label
(
)
{
return
{
this
.
getAttribute
(
"
name
"
)
}
{
this
.
getAttribute
(
"
description
"
)
}
;
}
}
customElements
.
define
(
"
mozapps
-
handler
"
MozHandler
{
extends
:
"
richlistitem
"
}
)
;
var
dialog
=
{
_handlerInfo
:
null
_URI
:
null
_itemChoose
:
null
_okButton
:
null
_windowCtxt
:
null
_buttonDisabled
:
true
initialize
:
function
initialize
(
)
{
this
.
_handlerInfo
=
window
.
arguments
[
7
]
.
QueryInterface
(
Ci
.
nsIHandlerInfo
)
;
this
.
_URI
=
window
.
arguments
[
8
]
.
QueryInterface
(
Ci
.
nsIURI
)
;
this
.
_windowCtxt
=
window
.
arguments
[
9
]
;
let
usePrivateBrowsing
=
false
;
if
(
this
.
_windowCtxt
)
{
try
{
usePrivateBrowsing
=
this
.
_windowCtxt
.
getInterface
(
Ci
.
nsIRemoteWindowContext
)
.
usePrivateBrowsing
;
}
catch
(
e
)
{
try
{
let
opener
=
this
.
_windowCtxt
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
usePrivateBrowsing
=
PrivateBrowsingUtils
.
isContentWindowPrivate
(
opener
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
No
interface
to
determine
privateness
:
{
e
}
)
;
}
}
this
.
_windowCtxt
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
}
this
.
isPrivate
=
usePrivateBrowsing
|
|
(
window
.
opener
&
&
PrivateBrowsingUtils
.
isWindowPrivate
(
window
.
opener
)
)
;
this
.
_itemChoose
=
document
.
getElementById
(
"
item
-
choose
"
)
;
this
.
_okButton
=
document
.
getElementById
(
"
handling
"
)
.
getButton
(
"
extra1
"
)
;
var
description
=
{
image
:
document
.
getElementById
(
"
description
-
image
"
)
text
:
document
.
getElementById
(
"
description
-
text
"
)
}
;
var
options
=
document
.
getElementById
(
"
item
-
action
-
text
"
)
;
var
checkbox
=
{
desc
:
document
.
getElementById
(
"
remember
"
)
text
:
document
.
getElementById
(
"
remember
-
text
"
)
}
;
document
.
title
=
window
.
arguments
[
0
]
;
description
.
image
.
src
=
window
.
arguments
[
1
]
;
description
.
text
.
textContent
=
window
.
arguments
[
2
]
;
options
.
value
=
window
.
arguments
[
3
]
;
checkbox
.
desc
.
label
=
window
.
arguments
[
4
]
;
checkbox
.
desc
.
accessKey
=
window
.
arguments
[
5
]
;
checkbox
.
text
.
textContent
=
window
.
arguments
[
6
]
;
if
(
!
checkbox
.
desc
.
label
)
{
checkbox
.
desc
.
hidden
=
true
;
}
this
.
populateList
(
)
;
document
.
addEventListener
(
"
dialogextra1
"
(
)
=
>
{
this
.
onOK
(
)
;
}
)
;
document
.
addEventListener
(
"
dialogaccept
"
e
=
>
{
e
.
preventDefault
(
)
;
}
)
;
this
.
_delayHelper
=
new
EnableDelayHelper
(
{
disableDialog
:
(
)
=
>
{
this
.
_buttonDisabled
=
true
;
this
.
updateOKButton
(
)
;
}
enableDialog
:
(
)
=
>
{
this
.
_buttonDisabled
=
false
;
this
.
updateOKButton
(
)
;
}
focusTarget
:
window
}
)
;
}
populateList
:
function
populateList
(
)
{
var
items
=
document
.
getElementById
(
"
items
"
)
;
var
possibleHandlers
=
this
.
_handlerInfo
.
possibleApplicationHandlers
;
var
preferredHandler
=
this
.
_handlerInfo
.
preferredApplicationHandler
;
for
(
let
i
=
possibleHandlers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
app
=
possibleHandlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
let
elm
=
document
.
createXULElement
(
"
richlistitem
"
{
is
:
"
mozapps
-
handler
"
}
)
;
elm
.
setAttribute
(
"
name
"
app
.
name
)
;
elm
.
obj
=
app
;
if
(
app
instanceof
Ci
.
nsILocalHandlerApp
)
{
let
uri
=
Services
.
io
.
newFileURI
(
app
.
executable
)
;
elm
.
setAttribute
(
"
image
"
"
moz
-
icon
:
/
/
"
+
uri
.
spec
+
"
?
size
=
32
"
)
;
}
else
if
(
app
instanceof
Ci
.
nsIWebHandlerApp
)
{
let
uri
=
Services
.
io
.
newURI
(
app
.
uriTemplate
)
;
if
(
/
^
https
?
/
.
test
(
uri
.
scheme
)
)
{
elm
.
setAttribute
(
"
image
"
uri
.
prePath
+
"
/
favicon
.
ico
"
)
;
}
elm
.
setAttribute
(
"
description
"
uri
.
prePath
)
;
if
(
this
.
isPrivate
)
{
let
policy
=
WebExtensionPolicy
.
getByURI
(
uri
)
;
if
(
policy
&
&
!
policy
.
privateBrowsingAllowed
)
{
var
bundle
=
document
.
getElementById
(
"
base
-
strings
"
)
;
var
disabledLabel
=
bundle
.
getString
(
"
privatebrowsing
.
disabled
.
label
"
)
;
elm
.
setAttribute
(
"
disabled
"
true
)
;
elm
.
setAttribute
(
"
description
"
disabledLabel
)
;
if
(
app
=
=
preferredHandler
)
{
preferredHandler
=
null
;
}
}
}
}
else
if
(
app
instanceof
Ci
.
nsIDBusHandlerApp
)
{
elm
.
setAttribute
(
"
description
"
app
.
method
)
;
}
else
if
(
!
(
app
instanceof
Ci
.
nsIGIOMimeApp
)
)
{
throw
new
Error
(
"
unknown
handler
type
"
)
;
}
items
.
insertBefore
(
elm
this
.
_itemChoose
)
;
if
(
preferredHandler
&
&
app
=
=
preferredHandler
)
{
this
.
selectedItem
=
elm
;
}
}
if
(
this
.
_handlerInfo
.
hasDefaultHandler
)
{
let
elm
=
document
.
createXULElement
(
"
richlistitem
"
{
is
:
"
mozapps
-
handler
"
}
)
;
elm
.
id
=
"
os
-
default
-
handler
"
;
elm
.
setAttribute
(
"
name
"
this
.
_handlerInfo
.
defaultDescription
)
;
items
.
insertBefore
(
elm
items
.
firstChild
)
;
if
(
this
.
_handlerInfo
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
)
{
this
.
selectedItem
=
elm
;
}
}
if
(
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
)
{
let
gIOSvc
=
Cc
[
"
mozilla
.
org
/
gio
-
service
;
1
"
]
.
getService
(
Ci
.
nsIGIOService
)
;
var
gioApps
=
gIOSvc
.
getAppsForURIScheme
(
this
.
_URI
.
scheme
)
;
for
(
let
handler
of
gioApps
.
enumerate
(
Ci
.
nsIHandlerApp
)
)
{
if
(
handler
.
name
=
=
this
.
_handlerInfo
.
defaultDescription
)
{
continue
;
}
let
appAlreadyInHandlers
=
false
;
for
(
let
i
=
possibleHandlers
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
let
app
=
possibleHandlers
.
queryElementAt
(
i
Ci
.
nsIHandlerApp
)
;
if
(
handler
.
equals
(
app
)
)
{
appAlreadyInHandlers
=
true
;
break
;
}
}
if
(
!
appAlreadyInHandlers
)
{
let
elm
=
document
.
createXULElement
(
"
richlistitem
"
{
is
:
"
mozapps
-
handler
"
}
)
;
elm
.
setAttribute
(
"
name
"
handler
.
name
)
;
elm
.
obj
=
handler
;
items
.
insertBefore
(
elm
this
.
_itemChoose
)
;
}
}
}
items
.
ensureSelectedElementIsVisible
(
)
;
}
chooseApplication
:
function
chooseApplication
(
)
{
var
bundle
=
document
.
getElementById
(
"
base
-
strings
"
)
;
var
title
=
bundle
.
getString
(
"
choose
.
application
.
title
"
)
;
var
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
title
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilters
(
Ci
.
nsIFilePicker
.
filterApps
)
;
fp
.
open
(
rv
=
>
{
if
(
rv
=
=
Ci
.
nsIFilePicker
.
returnOK
&
&
fp
.
file
)
{
let
uri
=
Services
.
io
.
newFileURI
(
fp
.
file
)
;
let
handlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
handlerApp
.
executable
=
fp
.
file
;
let
parent
=
document
.
getElementById
(
"
items
"
)
;
for
(
let
i
=
0
;
i
<
parent
.
childNodes
.
length
;
+
+
i
)
{
let
elm
=
parent
.
childNodes
[
i
]
;
if
(
elm
.
obj
instanceof
Ci
.
nsILocalHandlerApp
&
&
elm
.
obj
.
equals
(
handlerApp
)
)
{
parent
.
selectedItem
=
elm
;
parent
.
ensureSelectedElementIsVisible
(
)
;
return
;
}
}
let
elm
=
document
.
createXULElement
(
"
richlistitem
"
{
is
:
"
mozapps
-
handler
"
}
)
;
elm
.
setAttribute
(
"
name
"
fp
.
file
.
leafName
)
;
elm
.
setAttribute
(
"
image
"
"
moz
-
icon
:
/
/
"
+
uri
.
spec
+
"
?
size
=
32
"
)
;
elm
.
obj
=
handlerApp
;
parent
.
selectedItem
=
parent
.
insertBefore
(
elm
parent
.
firstChild
)
;
parent
.
ensureSelectedElementIsVisible
(
)
;
}
}
)
;
}
onOK
:
function
onOK
(
)
{
if
(
this
.
_buttonDisabled
)
{
return
;
}
var
checkbox
=
document
.
getElementById
(
"
remember
"
)
;
if
(
!
checkbox
.
hidden
)
{
if
(
this
.
selectedItem
.
obj
)
{
this
.
_handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useHelperApp
;
this
.
_handlerInfo
.
preferredApplicationHandler
=
this
.
selectedItem
.
obj
;
}
else
{
this
.
_handlerInfo
.
preferredAction
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
;
}
}
this
.
_handlerInfo
.
alwaysAskBeforeHandling
=
!
checkbox
.
checked
;
var
hs
=
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
;
hs
.
store
(
this
.
_handlerInfo
)
;
this
.
_handlerInfo
.
launchWithURI
(
this
.
_URI
this
.
_windowCtxt
)
;
window
.
close
(
)
;
}
updateOKButton
:
function
updateOKButton
(
)
{
this
.
_okButton
.
disabled
=
this
.
_itemChoose
.
selected
|
|
this
.
_buttonDisabled
;
}
onCheck
:
function
onCheck
(
)
{
if
(
document
.
getElementById
(
"
remember
"
)
.
checked
)
{
document
.
getElementById
(
"
remember
-
text
"
)
.
setAttribute
(
"
visible
"
"
true
"
)
;
}
else
{
document
.
getElementById
(
"
remember
-
text
"
)
.
removeAttribute
(
"
visible
"
)
;
}
}
onDblClick
:
function
onDblClick
(
)
{
if
(
this
.
selectedItem
=
=
this
.
_itemChoose
)
{
this
.
chooseApplication
(
)
;
}
else
{
this
.
onOK
(
)
;
}
}
get
selectedItem
(
)
{
return
document
.
getElementById
(
"
items
"
)
.
selectedItem
;
}
set
selectedItem
(
aItem
)
{
return
(
document
.
getElementById
(
"
items
"
)
.
selectedItem
=
aItem
)
;
}
}
;
