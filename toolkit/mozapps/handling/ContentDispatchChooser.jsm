const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
E10SUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
)
;
const
DIALOG_URL_APP_CHOOSER
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
appChooser
.
xhtml
"
;
const
DIALOG_URL_PERMISSION
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
permissionDialog
.
xhtml
"
;
var
EXPORTED_SYMBOLS
=
[
"
nsContentDispatchChooser
"
"
ContentDispatchChooserTelemetry
"
]
;
const
gPrefs
=
{
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
gPrefs
"
promptForExternal
"
"
network
.
protocol
-
handler
.
prompt
-
from
-
external
"
true
)
;
const
PROTOCOL_HANDLER_OPEN_PERM_KEY
=
"
open
-
protocol
-
handler
"
;
const
PERMISSION_KEY_DELIMITER
=
"
^
"
;
let
ContentDispatchChooserTelemetry
=
{
SCHEME_TO_LABEL
:
{
bingmaps
:
"
BING
"
bingweather
:
"
BING
"
fb
:
"
FACEBOOK
"
fbmessenger
:
"
FACEBOOK
"
findmy
:
"
APPLE_FINDMY
"
findmyfriends
:
"
APPLE_FINDMY
"
fmf1
:
"
APPLE_FINDMY
"
fmip1
:
"
APPLE_FINDMY
"
git
:
"
GIT
"
"
git
-
client
"
:
"
GIT
"
grenada
:
"
APPLE_FINDMY
"
ichat
:
"
IMESSAGE
"
im
:
"
INSTANT_MESSAGE
"
imessage
:
"
IMESSAGE
"
ipp
:
"
IPP
"
ipps
:
"
IPP
"
irc
:
"
IRC
"
irc6
:
"
IRC
"
ircs
:
"
IRC
"
itals
:
"
APPLE_LIVESTREAM
"
italss
:
"
APPLE_LIVESTREAM
"
itls
:
"
APPLE_LIVESTREAM
"
itlss
:
"
APPLE_LIVESTREAM
"
itms
:
"
APPLE_MUSIC
"
itmss
:
"
APPLE_MUSIC
"
itsradio
:
"
APPLE_MUSIC
"
itunes
:
"
APPLE_MUSIC
"
itunesradio
:
"
APPLE_MUSIC
"
itvls
:
"
APPLE_LIVESTREAM
"
itvlss
:
"
APPLE_LIVESTREAM
"
macappstore
:
"
MACAPPSTORE
"
macappstores
:
"
MACAPPSTORE
"
map
:
"
MAP
"
mapitem
:
"
MAP
"
maps
:
"
MAP
"
message
:
"
MESSAGE
"
messages
:
"
MESSAGE
"
microsoftmusic
:
"
MICROSOFT_APP
"
microsoftvideo
:
"
MICROSOFT_APP
"
mswindowsmusic
:
"
MICROSOFT_APP
"
music
:
"
MUSIC
"
musics
:
"
MUSIC
"
onenote
:
"
ONENOTE
"
"
onenote
-
cmd
"
:
"
ONENOTE
"
pcast
:
"
PODCAST
"
podcast
:
"
PODCAST
"
podcasts
:
"
PODCAST
"
"
roblox
-
player
"
:
"
ROBLOX
"
search
:
"
SEARCH
"
"
search
-
ms
"
:
"
SEARCH
"
sip
:
"
SIP
"
sips
:
"
SIP
"
skype
:
"
SKYPE
"
"
skype
-
meetnow
"
:
"
SKYPE
"
skypewin
:
"
SKYPE
"
tg
:
"
TELEGRAM
"
tv
:
"
TELEVISION
"
zoommtg
:
"
ZOOM
"
zoompbx
:
"
ZOOM
"
zoomus
:
"
ZOOM
"
zune
:
"
MICROSOFT_APP
"
}
SCHEME_PREFIX_TO_LABEL
:
{
apple
:
"
APPLE
"
"
com
.
microsoft
"
:
"
MICROSOFT_APP
"
facetime
:
"
FACETIME
"
"
fb
-
messenger
"
:
"
FACEBOOK
"
icloud
:
"
ICLOUD
"
"
itms
-
"
:
"
APPLE_MUSIC
"
microsoft
:
"
MICROSOFT_APP
"
"
ms
-
"
:
"
MICROSOFT_APP
"
outlook
:
"
OUTLOOK
"
photos
:
"
PHOTOS
"
"
web
+
"
:
"
WEBHANDLER
"
windows
:
"
WINDOWS_PREFIX
"
"
x
-
apple
"
:
"
APPLE
"
xbox
:
"
XBOX
"
}
SANDBOXED_AUXILIARY_NAVIGATION
:
0x2
SANDBOXED_TOPLEVEL_NAVIGATION
:
0x4
SANDBOXED_TOPLEVEL_NAVIGATION_USER_ACTIVATION
:
0x20000
get
_telemetryLabels
(
)
{
if
(
!
this
.
_telemetryLabelArray
)
{
this
.
_telemetryLabelArray
=
Services
.
telemetry
.
getCategoricalLabels
(
)
.
EXTERNAL_PROTOCOL_HANDLER_DIALOG_CONTEXT_SCHEME
;
}
return
this
.
_telemetryLabelArray
;
}
_getTelemetryLabel
(
aScheme
)
{
if
(
!
aScheme
)
{
throw
new
Error
(
"
Invalid
scheme
"
)
;
}
let
labels
=
this
.
_telemetryLabels
;
let
mappedLabel
=
this
.
SCHEME_TO_LABEL
[
aScheme
]
;
if
(
mappedLabel
)
{
return
mappedLabel
;
}
for
(
let
prefix
of
Object
.
keys
(
this
.
SCHEME_PREFIX_TO_LABEL
)
)
{
if
(
aScheme
.
startsWith
(
prefix
)
)
{
return
this
.
SCHEME_PREFIX_TO_LABEL
[
prefix
]
;
}
}
if
(
labels
.
includes
(
aScheme
)
)
{
return
aScheme
;
}
return
"
OTHER
"
;
}
_getTelemetryKey
(
aBrowsingContext
aTriggeringPrincipal
)
{
if
(
!
aBrowsingContext
)
{
return
"
UNKNOWN
"
;
}
if
(
aBrowsingContext
.
top
=
=
aBrowsingContext
)
{
return
"
TOPLEVEL
"
;
}
let
{
sandboxFlags
}
=
aBrowsingContext
;
if
(
sandboxFlags
)
{
if
(
!
(
sandboxFlags
&
this
.
SANDBOXED_TOPLEVEL_NAVIGATION
)
|
|
!
(
sandboxFlags
&
this
.
SANDBOXED_TOPLEVEL_NAVIGATION_USER_ACTIVATION
)
|
|
!
(
sandboxFlags
&
this
.
SANDBOXED_AUXILIARY_NAVIGATION
)
)
{
return
"
SUB_SANDBOX_ALLOW
"
;
}
return
"
SUB_SANDBOX_NOALLOW
"
;
}
if
(
!
aTriggeringPrincipal
)
{
return
"
UNKNOWN
"
;
}
let
topLevelPrincipal
=
aBrowsingContext
.
top
.
embedderElement
?
.
contentPrincipal
;
if
(
!
topLevelPrincipal
)
{
return
"
UNKNOWN
"
;
}
if
(
topLevelPrincipal
.
isThirdPartyPrincipal
(
aTriggeringPrincipal
)
)
{
return
"
SUB_CROSSORIGIN
"
;
}
return
"
SUB_SAMEORIGIN
"
;
}
recordTelemetry
(
aScheme
aBrowsingContext
aTriggeringPrincipal
)
{
let
type
=
this
.
_getTelemetryKey
(
aBrowsingContext
aTriggeringPrincipal
)
;
let
label
=
this
.
_getTelemetryLabel
(
aScheme
)
;
Services
.
telemetry
.
getKeyedHistogramById
(
"
EXTERNAL_PROTOCOL_HANDLER_DIALOG_CONTEXT_SCHEME
"
)
.
add
(
type
label
)
;
}
}
;
class
nsContentDispatchChooser
{
async
handleURI
(
aHandler
aURI
aPrincipal
aBrowsingContext
aTriggeredExternally
=
false
)
{
let
callerHasPermission
=
this
.
_hasProtocolHandlerPermission
(
aHandler
.
type
aPrincipal
)
;
if
(
aTriggeredExternally
&
&
gPrefs
.
promptForExternal
&
&
!
(
aHandler
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
&
&
aHandler
.
preferredApplicationHandler
instanceof
Ci
.
nsIWebHandlerApp
)
)
{
aHandler
.
alwaysAskBeforeHandling
=
true
;
}
if
(
callerHasPermission
&
&
!
aHandler
.
alwaysAskBeforeHandling
&
&
(
aHandler
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
|
|
aHandler
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
)
)
{
try
{
aHandler
.
launchWithURI
(
aURI
aBrowsingContext
)
;
}
catch
(
error
)
{
if
(
error
.
result
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
aHandler
.
alwaysAskBeforeHandling
=
true
;
}
else
{
throw
error
;
}
}
}
try
{
ContentDispatchChooserTelemetry
.
recordTelemetry
(
aHandler
.
type
aBrowsingContext
aPrincipal
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
}
let
shouldOpenHandler
=
false
;
try
{
shouldOpenHandler
=
await
this
.
_prompt
(
aHandler
aPrincipal
callerHasPermission
aBrowsingContext
aURI
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
.
message
)
;
}
if
(
!
shouldOpenHandler
)
{
return
;
}
aHandler
.
launchWithURI
(
aURI
aBrowsingContext
)
;
}
_getHandlerName
(
aHandler
)
{
if
(
aHandler
.
alwaysAskBeforeHandling
)
{
return
null
;
}
if
(
aHandler
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
&
&
aHandler
.
hasDefaultHandler
)
{
return
aHandler
.
defaultDescription
;
}
return
aHandler
.
preferredApplicationHandler
?
.
name
;
}
async
_prompt
(
aHandler
aPrincipal
aHasPermission
aBrowsingContext
aURI
)
{
let
shouldOpenHandler
=
false
;
let
resetHandlerChoice
=
false
;
let
updateHandlerData
=
false
;
const
isStandardProtocol
=
E10SUtils
.
STANDARD_SAFE_PROTOCOLS
.
includes
(
aURI
.
scheme
)
;
const
{
hasDefaultHandler
preferredApplicationHandler
alwaysAskBeforeHandling
}
=
aHandler
;
if
(
!
isStandardProtocol
&
&
hasDefaultHandler
&
&
preferredApplicationHandler
=
=
null
&
&
alwaysAskBeforeHandling
)
{
aHandler
.
alwaysAskBeforeHandling
=
false
;
updateHandlerData
=
true
;
}
if
(
!
aHasPermission
)
{
let
canPersistPermission
=
this
.
_isSupportedPrincipal
(
aPrincipal
)
;
let
outArgs
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
outArgs
.
setProperty
(
"
granted
"
false
)
;
outArgs
.
setProperty
(
"
resetHandlerChoice
"
null
)
;
outArgs
.
setProperty
(
"
remember
"
null
)
;
await
this
.
_openDialog
(
DIALOG_URL_PERMISSION
{
handler
:
aHandler
principal
:
aPrincipal
browsingContext
:
aBrowsingContext
outArgs
canPersistPermission
preferredHandlerName
:
this
.
_getHandlerName
(
aHandler
)
}
aBrowsingContext
)
;
if
(
!
outArgs
.
getProperty
(
"
granted
"
)
)
{
return
false
;
}
resetHandlerChoice
=
outArgs
.
getProperty
(
"
resetHandlerChoice
"
)
;
if
(
!
resetHandlerChoice
&
&
aPrincipal
)
{
let
remember
=
outArgs
.
getProperty
(
"
remember
"
)
;
this
.
_updatePermission
(
aPrincipal
aHandler
.
type
remember
)
;
}
shouldOpenHandler
=
true
;
}
if
(
aHandler
.
alwaysAskBeforeHandling
|
|
resetHandlerChoice
)
{
let
outArgs
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
outArgs
.
setProperty
(
"
openHandler
"
false
)
;
outArgs
.
setProperty
(
"
preferredAction
"
aHandler
.
preferredAction
)
;
outArgs
.
setProperty
(
"
preferredApplicationHandler
"
aHandler
.
preferredApplicationHandler
)
;
outArgs
.
setProperty
(
"
alwaysAskBeforeHandling
"
aHandler
.
alwaysAskBeforeHandling
)
;
let
usePrivateBrowsing
=
aBrowsingContext
?
.
usePrivateBrowsing
;
await
this
.
_openDialog
(
DIALOG_URL_APP_CHOOSER
{
handler
:
aHandler
outArgs
usePrivateBrowsing
enableButtonDelay
:
aHasPermission
}
aBrowsingContext
)
;
shouldOpenHandler
=
outArgs
.
getProperty
(
"
openHandler
"
)
;
if
(
shouldOpenHandler
)
{
for
(
let
prop
of
[
"
preferredAction
"
"
preferredApplicationHandler
"
"
alwaysAskBeforeHandling
"
]
)
{
aHandler
[
prop
]
=
outArgs
.
getProperty
(
prop
)
;
}
updateHandlerData
=
true
;
}
}
if
(
updateHandlerData
)
{
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
.
store
(
aHandler
)
;
}
return
shouldOpenHandler
;
}
_hasProtocolHandlerPermission
(
scheme
aPrincipal
)
{
if
(
!
nsContentDispatchChooser
.
isPermissionEnabled
)
{
return
true
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
network
.
protocol
-
handler
.
external
.
"
+
scheme
false
)
)
{
return
true
;
}
if
(
!
aPrincipal
)
{
return
false
;
}
if
(
aPrincipal
.
isAddonOrExpandedAddonPrincipal
)
{
return
true
;
}
let
key
=
this
.
_getSkipProtoDialogPermissionKey
(
scheme
)
;
return
(
Services
.
perms
.
testPermissionFromPrincipal
(
aPrincipal
key
)
=
=
=
Services
.
perms
.
ALLOW_ACTION
)
;
}
_getSkipProtoDialogPermissionKey
(
aProtocolScheme
)
{
return
(
PROTOCOL_HANDLER_OPEN_PERM_KEY
+
PERMISSION_KEY_DELIMITER
+
aProtocolScheme
)
;
}
async
_openDialog
(
aDialogURL
aDialogArgs
aBrowsingContext
)
{
let
resizable
=
resizable
=
{
aDialogURL
=
=
DIALOG_URL_APP_CHOOSER
?
"
yes
"
:
"
no
"
}
;
if
(
aBrowsingContext
)
{
let
window
=
aBrowsingContext
.
topChromeWindow
;
if
(
!
window
)
{
throw
new
Error
(
"
Can
'
t
show
external
protocol
dialog
.
BrowsingContext
has
no
chrome
window
associated
.
"
)
;
}
let
{
topFrameElement
}
=
aBrowsingContext
;
if
(
topFrameElement
?
.
tagName
!
=
"
browser
"
)
{
throw
new
Error
(
"
Can
'
t
show
external
protocol
dialog
.
BrowsingContext
has
no
browser
associated
.
"
)
;
}
let
tabDialogBox
=
window
.
gBrowser
.
getTabDialogBox
(
topFrameElement
)
;
return
tabDialogBox
.
open
(
aDialogURL
{
features
:
resizable
allowDuplicateDialogs
:
false
keepOpenSameOriginNav
:
true
}
aDialogArgs
)
.
closedPromise
;
}
let
win
=
Services
.
ww
.
openWindow
(
null
aDialogURL
null
chrome
dialog
=
yes
centerscreen
{
resizable
}
aDialogArgs
)
;
return
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
unload
"
function
onUnload
(
event
)
{
if
(
event
.
target
.
location
!
=
aDialogURL
)
{
return
;
}
win
.
removeEventListener
(
"
unload
"
onUnload
)
;
resolve
(
)
;
}
)
;
}
)
;
}
_updatePermission
(
aPrincipal
aScheme
aAllow
)
{
if
(
!
nsContentDispatchChooser
.
isPermissionEnabled
|
|
aPrincipal
.
isSystemPrincipal
|
|
!
this
.
_isSupportedPrincipal
(
aPrincipal
)
)
{
return
;
}
let
permKey
=
this
.
_getSkipProtoDialogPermissionKey
(
aScheme
)
;
if
(
aAllow
)
{
Services
.
perms
.
addFromPrincipal
(
aPrincipal
permKey
Services
.
perms
.
ALLOW_ACTION
Services
.
perms
.
EXPIRE_NEVER
)
;
}
else
{
Services
.
perms
.
removeFromPrincipal
(
aPrincipal
permKey
)
;
}
}
_isSupportedPrincipal
(
aPrincipal
)
{
return
(
aPrincipal
&
&
[
"
http
"
"
https
"
"
moz
-
extension
"
"
file
"
]
.
some
(
scheme
=
>
aPrincipal
.
schemeIs
(
scheme
)
)
)
;
}
}
nsContentDispatchChooser
.
prototype
.
classID
=
Components
.
ID
(
"
e35d5067
-
95bc
-
4029
-
8432
-
e8f1e431148d
"
)
;
nsContentDispatchChooser
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIContentDispatchChooser
"
]
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
nsContentDispatchChooser
"
isPermissionEnabled
"
"
security
.
external_protocol_requires_permission
"
true
)
;
