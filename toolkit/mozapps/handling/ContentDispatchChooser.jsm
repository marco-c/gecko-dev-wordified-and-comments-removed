const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
E10SUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
sys
.
mjs
"
)
;
const
DIALOG_URL_APP_CHOOSER
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
appChooser
.
xhtml
"
;
const
DIALOG_URL_PERMISSION
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
permissionDialog
.
xhtml
"
;
var
EXPORTED_SYMBOLS
=
[
"
nsContentDispatchChooser
"
]
;
const
gPrefs
=
{
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
gPrefs
"
promptForExternal
"
"
network
.
protocol
-
handler
.
prompt
-
from
-
external
"
true
)
;
const
PROTOCOL_HANDLER_OPEN_PERM_KEY
=
"
open
-
protocol
-
handler
"
;
const
PERMISSION_KEY_DELIMITER
=
"
^
"
;
class
nsContentDispatchChooser
{
async
handleURI
(
aHandler
aURI
aPrincipal
aBrowsingContext
aTriggeredExternally
=
false
)
{
let
callerHasPermission
=
this
.
_hasProtocolHandlerPermission
(
aHandler
.
type
aPrincipal
)
;
if
(
aTriggeredExternally
&
&
gPrefs
.
promptForExternal
&
&
!
(
aHandler
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
&
&
aHandler
.
preferredApplicationHandler
instanceof
Ci
.
nsIWebHandlerApp
)
)
{
aHandler
.
alwaysAskBeforeHandling
=
true
;
}
if
(
callerHasPermission
&
&
!
aHandler
.
alwaysAskBeforeHandling
&
&
(
aHandler
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useHelperApp
|
|
aHandler
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
)
)
{
try
{
aHandler
.
launchWithURI
(
aURI
aBrowsingContext
)
;
}
catch
(
error
)
{
if
(
error
.
result
=
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
aHandler
.
alwaysAskBeforeHandling
=
true
;
}
else
{
throw
error
;
}
}
}
let
shouldOpenHandler
=
false
;
try
{
shouldOpenHandler
=
await
this
.
_prompt
(
aHandler
aPrincipal
callerHasPermission
aBrowsingContext
aURI
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
.
message
)
;
}
if
(
!
shouldOpenHandler
)
{
return
;
}
aHandler
.
launchWithURI
(
aURI
aBrowsingContext
)
;
}
_getHandlerName
(
aHandler
)
{
if
(
aHandler
.
alwaysAskBeforeHandling
)
{
return
null
;
}
if
(
aHandler
.
preferredAction
=
=
Ci
.
nsIHandlerInfo
.
useSystemDefault
&
&
aHandler
.
hasDefaultHandler
)
{
return
aHandler
.
defaultDescription
;
}
return
aHandler
.
preferredApplicationHandler
?
.
name
;
}
async
_prompt
(
aHandler
aPrincipal
aHasPermission
aBrowsingContext
aURI
)
{
let
shouldOpenHandler
=
false
;
let
resetHandlerChoice
=
false
;
let
updateHandlerData
=
false
;
const
isStandardProtocol
=
E10SUtils
.
STANDARD_SAFE_PROTOCOLS
.
includes
(
aURI
.
scheme
)
;
const
{
hasDefaultHandler
preferredApplicationHandler
alwaysAskBeforeHandling
}
=
aHandler
;
if
(
!
isStandardProtocol
&
&
hasDefaultHandler
&
&
preferredApplicationHandler
=
=
null
&
&
alwaysAskBeforeHandling
)
{
aHandler
.
alwaysAskBeforeHandling
=
false
;
updateHandlerData
=
true
;
}
if
(
!
aHasPermission
)
{
let
canPersistPermission
=
this
.
_isSupportedPrincipal
(
aPrincipal
)
;
let
outArgs
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
outArgs
.
setProperty
(
"
granted
"
false
)
;
outArgs
.
setProperty
(
"
resetHandlerChoice
"
null
)
;
outArgs
.
setProperty
(
"
remember
"
null
)
;
await
this
.
_openDialog
(
DIALOG_URL_PERMISSION
{
handler
:
aHandler
principal
:
aPrincipal
browsingContext
:
aBrowsingContext
outArgs
canPersistPermission
preferredHandlerName
:
this
.
_getHandlerName
(
aHandler
)
}
aBrowsingContext
)
;
if
(
!
outArgs
.
getProperty
(
"
granted
"
)
)
{
return
false
;
}
resetHandlerChoice
=
outArgs
.
getProperty
(
"
resetHandlerChoice
"
)
;
if
(
!
resetHandlerChoice
&
&
aPrincipal
)
{
let
remember
=
outArgs
.
getProperty
(
"
remember
"
)
;
this
.
_updatePermission
(
aPrincipal
aHandler
.
type
remember
)
;
}
shouldOpenHandler
=
true
;
}
if
(
aHandler
.
alwaysAskBeforeHandling
|
|
resetHandlerChoice
)
{
let
outArgs
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
outArgs
.
setProperty
(
"
openHandler
"
false
)
;
outArgs
.
setProperty
(
"
preferredAction
"
aHandler
.
preferredAction
)
;
outArgs
.
setProperty
(
"
preferredApplicationHandler
"
aHandler
.
preferredApplicationHandler
)
;
outArgs
.
setProperty
(
"
alwaysAskBeforeHandling
"
aHandler
.
alwaysAskBeforeHandling
)
;
let
usePrivateBrowsing
=
aBrowsingContext
?
.
usePrivateBrowsing
;
await
this
.
_openDialog
(
DIALOG_URL_APP_CHOOSER
{
handler
:
aHandler
outArgs
usePrivateBrowsing
enableButtonDelay
:
aHasPermission
}
aBrowsingContext
)
;
shouldOpenHandler
=
outArgs
.
getProperty
(
"
openHandler
"
)
;
if
(
shouldOpenHandler
)
{
for
(
let
prop
of
[
"
preferredAction
"
"
preferredApplicationHandler
"
"
alwaysAskBeforeHandling
"
]
)
{
aHandler
[
prop
]
=
outArgs
.
getProperty
(
prop
)
;
}
updateHandlerData
=
true
;
}
}
if
(
updateHandlerData
)
{
Cc
[
"
mozilla
.
org
/
uriloader
/
handler
-
service
;
1
"
]
.
getService
(
Ci
.
nsIHandlerService
)
.
store
(
aHandler
)
;
}
return
shouldOpenHandler
;
}
_hasProtocolHandlerPermission
(
scheme
aPrincipal
)
{
if
(
!
nsContentDispatchChooser
.
isPermissionEnabled
)
{
return
true
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
network
.
protocol
-
handler
.
external
.
"
+
scheme
false
)
)
{
return
true
;
}
if
(
!
aPrincipal
)
{
return
false
;
}
let
key
=
this
.
_getSkipProtoDialogPermissionKey
(
scheme
)
;
return
(
Services
.
perms
.
testPermissionFromPrincipal
(
aPrincipal
key
)
=
=
=
Services
.
perms
.
ALLOW_ACTION
)
;
}
_getSkipProtoDialogPermissionKey
(
aProtocolScheme
)
{
return
(
PROTOCOL_HANDLER_OPEN_PERM_KEY
+
PERMISSION_KEY_DELIMITER
+
aProtocolScheme
)
;
}
async
_openDialog
(
aDialogURL
aDialogArgs
aBrowsingContext
)
{
let
resizable
=
resizable
=
{
aDialogURL
=
=
DIALOG_URL_APP_CHOOSER
?
"
yes
"
:
"
no
"
}
;
if
(
aBrowsingContext
)
{
let
window
=
aBrowsingContext
.
topChromeWindow
;
if
(
!
window
)
{
throw
new
Error
(
"
Can
'
t
show
external
protocol
dialog
.
BrowsingContext
has
no
chrome
window
associated
.
"
)
;
}
let
{
topFrameElement
}
=
aBrowsingContext
;
if
(
topFrameElement
?
.
tagName
!
=
"
browser
"
)
{
throw
new
Error
(
"
Can
'
t
show
external
protocol
dialog
.
BrowsingContext
has
no
browser
associated
.
"
)
;
}
let
tabDialogBox
=
window
.
gBrowser
.
getTabDialogBox
(
topFrameElement
)
;
return
tabDialogBox
.
open
(
aDialogURL
{
features
:
resizable
allowDuplicateDialogs
:
false
keepOpenSameOriginNav
:
true
}
aDialogArgs
)
.
closedPromise
;
}
let
win
=
Services
.
ww
.
openWindow
(
null
aDialogURL
null
chrome
dialog
=
yes
centerscreen
{
resizable
}
aDialogArgs
)
;
return
new
Promise
(
resolve
=
>
{
win
.
addEventListener
(
"
unload
"
function
onUnload
(
event
)
{
if
(
event
.
target
.
location
!
=
aDialogURL
)
{
return
;
}
win
.
removeEventListener
(
"
unload
"
onUnload
)
;
resolve
(
)
;
}
)
;
}
)
;
}
_updatePermission
(
aPrincipal
aScheme
aAllow
)
{
if
(
!
nsContentDispatchChooser
.
isPermissionEnabled
|
|
aPrincipal
.
isSystemPrincipal
|
|
!
this
.
_isSupportedPrincipal
(
aPrincipal
)
)
{
return
;
}
let
principal
=
aPrincipal
;
let
addonPolicy
=
aPrincipal
.
contentScriptAddonPolicy
;
if
(
addonPolicy
)
{
principal
=
Services
.
scriptSecurityManager
.
principalWithOA
(
addonPolicy
.
extension
.
principal
principal
.
originAttributes
)
;
}
let
permKey
=
this
.
_getSkipProtoDialogPermissionKey
(
aScheme
)
;
if
(
aAllow
)
{
Services
.
perms
.
addFromPrincipal
(
principal
permKey
Services
.
perms
.
ALLOW_ACTION
Services
.
perms
.
EXPIRE_NEVER
)
;
}
else
{
Services
.
perms
.
removeFromPrincipal
(
principal
permKey
)
;
}
}
_isSupportedPrincipal
(
aPrincipal
)
{
if
(
!
aPrincipal
)
{
return
false
;
}
if
(
aPrincipal
.
contentScriptAddonPolicy
)
{
return
true
;
}
return
[
"
http
"
"
https
"
"
moz
-
extension
"
"
file
"
]
.
some
(
scheme
=
>
aPrincipal
.
schemeIs
(
scheme
)
)
;
}
}
nsContentDispatchChooser
.
prototype
.
classID
=
Components
.
ID
(
"
e35d5067
-
95bc
-
4029
-
8432
-
e8f1e431148d
"
)
;
nsContentDispatchChooser
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIContentDispatchChooser
"
]
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
nsContentDispatchChooser
"
isPermissionEnabled
"
"
security
.
external_protocol_requires_permission
"
true
)
;
