const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
CONTENT_HANDLING_URL
=
"
chrome
:
/
/
mozapps
/
content
/
handling
/
dialog
.
xhtml
"
;
const
STRINGBUNDLE_URL
=
"
chrome
:
/
/
mozapps
/
locale
/
handling
/
handling
.
properties
"
;
const
gContextsToDialogs
=
new
WeakMap
(
)
;
const
gBoundWPLMap
=
new
WeakMap
(
)
;
class
BoundProgresslistener
{
constructor
(
browser
)
{
this
.
browsingContext
=
browser
.
browsingContext
;
this
.
_knownPrincipal
=
browser
.
contentPrincipal
;
}
onLocationChange
(
webProgress
channel
uri
flags
)
{
if
(
webProgress
.
isTopLevel
&
&
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
let
isPrivate
=
this
.
browsingContext
.
usePrivateBrowsing
;
if
(
!
uri
|
|
!
this
.
_knownPrincipal
.
isSameOrigin
(
uri
isPrivate
)
)
{
gChooserTracker
.
unregisterContext
(
this
.
browsingContext
)
;
}
}
}
}
const
gChooserTracker
=
{
getDialogFor
(
browsingContext
)
{
return
gContextsToDialogs
.
get
(
browsingContext
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
dom
-
window
-
destroyed
"
&
&
aSubject
.
document
.
URL
=
=
CONTENT_HANDLING_URL
)
{
let
browsingContext
=
aSubject
.
arguments
[
10
]
;
this
.
unregisterContext
(
browsingContext
?
.
top
)
;
}
if
(
aTopic
=
=
"
browsing
-
context
-
discarded
"
)
{
let
browsingContext
=
aSubject
;
if
(
browsingContext
&
&
browsingContext
=
=
browsingContext
.
top
)
{
this
.
unregisterContext
(
browsingContext
)
;
}
}
}
newDialogForContext
(
browsingContext
dialog
)
{
if
(
!
browsingContext
)
{
return
;
}
gContextsToDialogs
.
set
(
browsingContext
dialog
)
;
if
(
!
this
.
_haveObserver
)
{
Services
.
obs
.
addObserver
(
this
"
dom
-
window
-
destroyed
"
true
)
;
Services
.
obs
.
addObserver
(
this
"
browsing
-
context
-
discarded
"
true
)
;
this
.
_haveObserver
=
true
;
}
let
browser
=
browsingContext
.
embedderElement
;
if
(
!
browser
)
{
return
;
}
let
listener
=
new
BoundProgresslistener
(
browser
)
;
let
filter
=
Cc
[
"
mozilla
.
org
/
appshell
/
component
/
browser
-
status
-
filter
;
1
"
]
.
createInstance
(
Ci
.
nsIWebProgress
)
;
filter
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
gBoundWPLMap
.
set
(
browsingContext
filter
)
;
browser
.
addProgressListener
(
filter
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
unregisterContext
(
browsingContext
)
{
if
(
!
browsingContext
)
{
return
;
}
let
dialog
=
gContextsToDialogs
.
get
(
browsingContext
)
;
if
(
!
dialog
)
{
return
;
}
if
(
!
dialog
.
closed
)
{
dialog
.
close
(
)
;
}
let
browser
=
browsingContext
.
embedderElement
;
if
(
browser
)
{
browser
.
removeProgressListener
(
gBoundWPLMap
.
get
(
browsingContext
)
)
;
}
gContextsToDialogs
.
delete
(
browsingContext
)
;
gBoundWPLMap
.
delete
(
browsingContext
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
function
nsContentDispatchChooser
(
)
{
}
nsContentDispatchChooser
.
prototype
=
{
classID
:
Components
.
ID
(
"
e35d5067
-
95bc
-
4029
-
8432
-
e8f1e431148d
"
)
ask
:
function
ask
(
aHandler
aURI
aPrincipal
aBrowsingContext
aReason
)
{
let
window
=
aBrowsingContext
?
.
topChromeWindow
|
|
null
;
if
(
aBrowsingContext
)
{
const
topBC
=
aBrowsingContext
.
top
;
let
existingDialog
=
gChooserTracker
.
getDialogFor
(
topBC
)
;
if
(
existingDialog
)
{
existingDialog
.
focus
(
)
;
return
;
}
}
var
bundle
=
Services
.
strings
.
createBundle
(
STRINGBUNDLE_URL
)
;
var
arr
=
[
bundle
.
GetStringFromName
(
"
protocol
.
title
"
)
"
"
bundle
.
GetStringFromName
(
"
protocol
.
description
"
)
bundle
.
GetStringFromName
(
"
protocol
.
choices
.
label
"
)
bundle
.
formatStringFromName
(
"
protocol
.
checkbox
.
label
"
[
aURI
.
scheme
]
)
bundle
.
GetStringFromName
(
"
protocol
.
checkbox
.
accesskey
"
)
bundle
.
formatStringFromName
(
"
protocol
.
checkbox
.
extra
"
[
Services
.
appinfo
.
name
]
)
]
;
var
params
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
SupportsString
=
Components
.
Constructor
(
"
mozilla
.
org
/
supports
-
string
;
1
"
"
nsISupportsString
"
)
;
for
(
let
text
of
arr
)
{
let
string
=
new
SupportsString
(
)
;
string
.
data
=
text
;
params
.
appendElement
(
string
)
;
}
params
.
appendElement
(
aHandler
)
;
params
.
appendElement
(
aURI
)
;
params
.
appendElement
(
aPrincipal
)
;
params
.
appendElement
(
aBrowsingContext
)
;
let
dialog
=
Services
.
ww
.
openWindow
(
window
CONTENT_HANDLING_URL
null
"
chrome
dialog
=
yes
resizable
centerscreen
"
params
)
;
gChooserTracker
.
newDialogForContext
(
aBrowsingContext
?
.
top
dialog
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIContentDispatchChooser
]
)
}
;
var
EXPORTED_SYMBOLS
=
[
"
nsContentDispatchChooser
"
]
;
