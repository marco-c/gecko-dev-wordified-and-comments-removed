"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
runBackgroundTask
"
]
;
const
{
EXIT_CODE
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BackgroundTasksManager
.
jsm
"
)
.
BackgroundTasksManager
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
AppUpdater
:
"
resource
:
/
/
/
modules
/
AppUpdater
.
jsm
"
BackgroundTasksUtils
:
"
resource
:
/
/
gre
/
modules
/
BackgroundTasksUtils
.
jsm
"
BackgroundUpdate
:
"
resource
:
/
/
gre
/
modules
/
BackgroundUpdate
.
jsm
"
ExtensionUtils
:
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
UpdateService
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
app
.
update
.
background
.
loglevel
"
prefix
:
"
BackgroundUpdate
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
async
function
_attemptBackgroundUpdate
(
)
{
let
SLUG
=
"
_attemptBackgroundUpdate
"
;
log
.
debug
(
{
SLUG
}
:
creating
UpdateServiceStub
(
)
for
"
post
-
update
-
processing
"
)
;
Cc
[
"
mozilla
.
org
/
updates
/
update
-
service
-
stub
;
1
"
]
.
createInstance
(
Ci
.
nsISupports
)
;
log
.
debug
(
{
SLUG
}
:
checking
for
preconditions
necessary
to
update
this
installation
)
;
let
reasons
=
await
BackgroundUpdate
.
_reasonsToNotUpdateInstallation
(
)
;
if
(
!
reasons
.
length
)
{
log
.
debug
(
{
SLUG
}
:
checking
if
other
instance
is
running
)
;
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
if
(
syncManager
.
isOtherInstanceRunning
(
)
)
{
reasons
=
BackgroundUpdate
.
REASON
.
OTHER_INSTANCE
;
}
}
let
enabled
=
!
reasons
.
length
;
if
(
!
enabled
)
{
log
.
info
(
{
SLUG
}
:
not
running
background
update
task
:
'
{
JSON
.
stringify
(
reasons
)
}
'
)
;
return
false
;
}
let
result
=
new
Promise
(
resolve
=
>
{
let
appUpdater
=
new
AppUpdater
(
)
;
let
_appUpdaterListener
=
(
status
progress
progressMax
)
=
>
{
let
stringStatus
=
AppUpdater
.
STATUS
.
debugStringFor
(
status
)
;
if
(
AppUpdater
.
STATUS
.
isTerminalStatus
(
status
)
)
{
log
.
debug
(
{
SLUG
}
:
background
update
transitioned
to
terminal
status
{
status
}
:
{
stringStatus
}
)
;
appUpdater
.
removeListener
(
_appUpdaterListener
)
;
resolve
(
true
)
;
}
else
if
(
status
=
=
AppUpdater
.
STATUS
.
CHECKING
)
{
log
.
debug
(
{
SLUG
}
:
This
session
will
be
limited
to
downloading
updates
only
.
)
;
UpdateService
.
onlyDownloadUpdatesThisSession
=
true
;
}
else
if
(
status
=
=
AppUpdater
.
STATUS
.
DOWNLOADING
&
&
progress
!
=
=
undefined
&
&
progressMax
!
=
=
undefined
)
{
if
(
progressMax
<
0
|
|
progress
!
=
progressMax
|
|
UpdateService
.
onlyDownloadUpdatesThisSession
)
{
log
.
debug
(
{
SLUG
}
:
Download
in
progress
.
Exiting
task
while
download
+
transfers
)
;
UpdateService
.
onlyDownloadUpdatesThisSession
=
true
;
appUpdater
.
removeListener
(
_appUpdaterListener
)
;
resolve
(
true
)
;
}
else
{
log
.
debug
(
{
SLUG
}
:
Download
has
completed
!
)
;
}
}
else
{
log
.
debug
(
{
SLUG
}
:
background
update
transitioned
to
status
{
status
}
:
{
stringStatus
}
)
;
}
}
;
appUpdater
.
addListener
(
_appUpdaterListener
)
;
appUpdater
.
check
(
)
;
}
)
;
return
result
;
}
async
function
runBackgroundTask
(
)
{
let
SLUG
=
"
runBackgroundTask
"
;
log
.
info
(
{
SLUG
}
:
backgroundupdate
)
;
let
data
=
{
name
:
Services
.
appinfo
.
name
osVersion
:
Services
.
sysinfo
.
getProperty
(
"
name
"
)
+
"
"
+
Services
.
sysinfo
.
getProperty
(
"
version
"
)
+
"
"
+
Services
.
sysinfo
.
getProperty
(
"
build
"
)
version
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
buildID
:
Services
.
appinfo
.
appBuildID
distributionID
:
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
getCharPref
(
"
distribution
.
id
"
"
"
)
updateChannel
:
UpdateUtils
.
UpdateChannel
UpdRootD
:
Services
.
dirsvc
.
get
(
"
UpdRootD
"
Ci
.
nsIFile
)
.
path
}
;
log
.
debug
(
{
SLUG
}
:
current
configuration
data
)
;
try
{
let
defaultProfilePrefs
=
await
BackgroundTasksUtils
.
readPreferences
(
name
=
>
name
.
startsWith
(
"
app
.
update
.
"
)
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
defaultProfilePrefs
)
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
Services
.
prefs
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
Services
.
prefs
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
Services
.
prefs
.
setCharPref
(
name
value
)
;
break
;
default
:
throw
new
Error
(
Pref
from
default
profile
with
name
"
{
name
}
"
has
unrecognized
type
)
;
}
}
}
catch
(
e
)
{
log
.
error
(
{
SLUG
}
:
caught
exception
reading
preferences
from
default
profile
e
)
;
return
EXIT_CODE
.
EXCEPTION
;
}
Services
.
prefs
.
setBoolPref
(
"
app
.
update
.
langpack
.
enabled
"
false
)
;
let
result
=
EXIT_CODE
.
SUCCESS
;
try
{
await
_attemptBackgroundUpdate
(
)
;
log
.
info
(
{
SLUG
}
:
attempted
background
update
)
;
await
ExtensionUtils
.
promiseTimeout
(
500
)
;
}
catch
(
e
)
{
log
.
error
(
{
SLUG
}
:
caught
exception
attempting
background
update
e
)
;
result
=
EXIT_CODE
.
EXCEPTION
;
}
finally
{
}
return
result
;
}
