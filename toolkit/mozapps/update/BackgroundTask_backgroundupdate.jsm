"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
backgroundTaskTimeoutSec
"
"
maybeSubmitBackgroundUpdatePing
"
"
runBackgroundTask
"
]
;
const
{
EXIT_CODE
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
BackgroundUpdate
.
jsm
"
)
.
BackgroundUpdate
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
AppUpdater
:
"
resource
:
/
/
/
modules
/
AppUpdater
.
jsm
"
BackgroundTasksUtils
:
"
resource
:
/
/
gre
/
modules
/
BackgroundTasksUtils
.
jsm
"
BackgroundUpdate
:
"
resource
:
/
/
gre
/
modules
/
BackgroundUpdate
.
jsm
"
ExtensionUtils
:
"
resource
:
/
/
gre
/
modules
/
ExtensionUtils
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
UpdateService
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
app
.
update
.
background
.
loglevel
"
prefix
:
"
BackgroundUpdate
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
const
backgroundTaskTimeoutSec
=
Services
.
prefs
.
getIntPref
(
"
app
.
update
.
background
.
timeoutSec
"
10
*
60
)
;
async
function
_attemptBackgroundUpdate
(
)
{
let
SLUG
=
"
_attemptBackgroundUpdate
"
;
log
.
debug
(
{
SLUG
}
:
creating
UpdateServiceStub
(
)
for
"
post
-
update
-
processing
"
)
;
Cc
[
"
mozilla
.
org
/
updates
/
update
-
service
-
stub
;
1
"
]
.
createInstance
(
Ci
.
nsISupports
)
;
log
.
debug
(
{
SLUG
}
:
checking
for
preconditions
necessary
to
update
this
installation
)
;
let
reasons
=
await
BackgroundUpdate
.
_reasonsToNotUpdateInstallation
(
)
;
if
(
BackgroundUpdate
.
_force
(
)
)
{
log
.
debug
(
{
SLUG
}
:
app
.
update
.
background
.
force
=
true
ignoring
reasons
:
{
JSON
.
stringify
(
reasons
)
}
)
;
reasons
=
[
]
;
}
reasons
.
sort
(
)
;
for
(
let
reason
of
reasons
)
{
Glean
.
backgroundUpdate
.
reasons
.
add
(
reason
)
;
}
let
enabled
=
!
reasons
.
length
;
if
(
!
enabled
)
{
log
.
info
(
{
SLUG
}
:
not
running
background
update
task
:
'
{
JSON
.
stringify
(
reasons
)
}
'
)
;
return
false
;
}
let
result
=
new
Promise
(
resolve
=
>
{
let
appUpdater
=
new
AppUpdater
(
)
;
let
_appUpdaterListener
=
(
status
progress
progressMax
)
=
>
{
let
stringStatus
=
AppUpdater
.
STATUS
.
debugStringFor
(
status
)
;
Glean
.
backgroundUpdate
.
states
.
add
(
stringStatus
)
;
Glean
.
backgroundUpdate
.
finalState
.
set
(
stringStatus
)
;
if
(
AppUpdater
.
STATUS
.
isTerminalStatus
(
status
)
)
{
log
.
debug
(
{
SLUG
}
:
background
update
transitioned
to
terminal
status
{
status
}
:
{
stringStatus
}
)
;
appUpdater
.
removeListener
(
_appUpdaterListener
)
;
resolve
(
true
)
;
}
else
if
(
status
=
=
AppUpdater
.
STATUS
.
CHECKING
)
{
log
.
debug
(
{
SLUG
}
:
This
session
will
be
limited
to
downloading
updates
only
.
)
;
UpdateService
.
onlyDownloadUpdatesThisSession
=
true
;
}
else
if
(
status
=
=
AppUpdater
.
STATUS
.
DOWNLOADING
&
&
(
UpdateService
.
onlyDownloadUpdatesThisSession
|
|
(
progress
!
=
=
undefined
&
&
progressMax
!
=
=
undefined
)
)
)
{
if
(
UpdateService
.
onlyDownloadUpdatesThisSession
|
|
progressMax
<
0
|
|
progress
!
=
progressMax
)
{
log
.
debug
(
{
SLUG
}
:
Download
in
progress
.
Exiting
task
while
download
+
transfers
)
;
UpdateService
.
onlyDownloadUpdatesThisSession
=
true
;
appUpdater
.
removeListener
(
_appUpdaterListener
)
;
resolve
(
true
)
;
}
else
{
log
.
debug
(
{
SLUG
}
:
Download
has
completed
!
)
;
}
}
else
{
log
.
debug
(
{
SLUG
}
:
background
update
transitioned
to
status
{
status
}
:
{
stringStatus
}
)
;
}
}
;
appUpdater
.
addListener
(
_appUpdaterListener
)
;
appUpdater
.
check
(
)
;
}
)
;
return
result
;
}
async
function
maybeSubmitBackgroundUpdatePing
(
)
{
let
SLUG
=
"
maybeSubmitBackgroundUpdatePing
"
;
GleanPings
.
backgroundUpdate
.
submit
(
)
;
log
.
info
(
{
SLUG
}
:
submitted
"
background
-
update
"
ping
)
;
}
async
function
runBackgroundTask
(
)
{
let
SLUG
=
"
runBackgroundTask
"
;
log
.
error
(
{
SLUG
}
:
backgroundupdate
)
;
let
data
=
{
name
:
Services
.
appinfo
.
name
osVersion
:
Services
.
sysinfo
.
getProperty
(
"
name
"
)
+
"
"
+
Services
.
sysinfo
.
getProperty
(
"
version
"
)
+
"
"
+
Services
.
sysinfo
.
getProperty
(
"
build
"
)
version
:
AppConstants
.
MOZ_APP_VERSION_DISPLAY
buildID
:
Services
.
appinfo
.
appBuildID
distributionID
:
Services
.
prefs
.
getDefaultBranch
(
"
"
)
.
getCharPref
(
"
distribution
.
id
"
"
"
)
updateChannel
:
UpdateUtils
.
UpdateChannel
UpdRootD
:
Services
.
dirsvc
.
get
(
"
UpdRootD
"
Ci
.
nsIFile
)
.
path
}
;
log
.
debug
(
{
SLUG
}
:
current
configuration
data
)
;
log
.
debug
(
{
SLUG
}
:
checking
if
other
instance
is
running
)
;
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
if
(
syncManager
.
isOtherInstanceRunning
(
)
)
{
log
.
error
(
{
SLUG
}
:
another
instance
is
running
)
;
return
EXIT_CODE
.
OTHER_INSTANCE
;
}
try
{
let
defaultProfilePrefs
;
await
BackgroundTasksUtils
.
withProfileLock
(
async
lock
=
>
{
let
predicate
=
name
=
>
{
return
(
name
.
startsWith
(
"
app
.
update
.
"
)
|
|
name
.
startsWith
(
"
datareporting
.
"
)
|
|
name
.
startsWith
(
"
logging
.
"
)
|
|
name
.
startsWith
(
"
telemetry
.
fog
.
"
)
|
|
name
.
startsWith
(
"
app
.
partner
.
"
)
)
;
}
;
defaultProfilePrefs
=
await
BackgroundTasksUtils
.
readPreferences
(
predicate
lock
)
;
let
telemetryClientID
=
await
BackgroundTasksUtils
.
readTelemetryClientID
(
lock
)
;
Glean
.
backgroundUpdate
.
clientId
.
set
(
telemetryClientID
)
;
}
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
defaultProfilePrefs
)
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
Services
.
prefs
.
setBoolPref
(
name
value
)
;
break
;
case
"
number
"
:
Services
.
prefs
.
setIntPref
(
name
value
)
;
break
;
case
"
string
"
:
Services
.
prefs
.
setCharPref
(
name
value
)
;
break
;
default
:
throw
new
Error
(
Pref
from
default
profile
with
name
"
{
name
}
"
has
unrecognized
type
)
;
}
}
}
catch
(
e
)
{
if
(
!
BackgroundTasksUtils
.
hasDefaultProfile
(
)
)
{
log
.
error
(
{
SLUG
}
:
caught
exception
;
no
default
profile
exists
e
)
;
return
EXIT_CODE
.
DEFAULT_PROFILE_DOES_NOT_EXIST
;
}
if
(
e
.
name
=
=
"
CannotLockProfileError
"
)
{
log
.
error
(
{
SLUG
}
:
caught
exception
;
could
not
lock
default
profile
e
)
;
return
EXIT_CODE
.
DEFAULT_PROFILE_CANNOT_BE_LOCKED
;
}
log
.
error
(
{
SLUG
}
:
caught
exception
reading
preferences
and
telemetry
client
ID
from
default
profile
e
)
;
return
EXIT_CODE
.
DEFAULT_PROFILE_CANNOT_BE_READ
;
}
await
BackgroundUpdate
.
recordUpdateEnvironment
(
)
;
let
gleanRoot
=
FileUtils
.
getFile
(
"
UpdRootD
"
[
"
backgroundupdate
"
"
datareporting
"
"
glean
"
"
__dummy__
"
]
)
.
parent
.
path
;
Services
.
fog
.
initializeFOG
(
gleanRoot
"
firefox
.
desktop
.
background
.
update
"
)
;
Services
.
prefs
.
setCharPref
(
"
toolkit
.
backgroundtasks
.
loglevel
"
Services
.
prefs
.
getCharPref
(
"
app
.
update
.
background
.
loglevel
"
"
error
"
)
)
;
Services
.
prefs
.
setBoolPref
(
"
app
.
update
.
langpack
.
enabled
"
false
)
;
let
result
=
EXIT_CODE
.
SUCCESS
;
let
stringStatus
=
AppUpdater
.
STATUS
.
debugStringFor
(
AppUpdater
.
STATUS
.
NEVER_CHECKED
)
;
Glean
.
backgroundUpdate
.
states
.
add
(
stringStatus
)
;
Glean
.
backgroundUpdate
.
finalState
.
set
(
stringStatus
)
;
try
{
await
_attemptBackgroundUpdate
(
)
;
log
.
info
(
{
SLUG
}
:
attempted
background
update
)
;
Glean
.
backgroundUpdate
.
exitCodeSuccess
.
set
(
true
)
;
}
catch
(
e
)
{
log
.
error
(
{
SLUG
}
:
caught
exception
attempting
background
update
e
)
;
result
=
EXIT_CODE
.
EXCEPTION
;
Glean
.
backgroundUpdate
.
exitCodeException
.
set
(
true
)
;
}
finally
{
await
maybeSubmitBackgroundUpdatePing
(
)
;
}
await
ExtensionUtils
.
promiseTimeout
(
500
)
;
return
result
;
}
