#
include
"
updateutils_win
.
h
"
#
include
<
errno
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
string
.
h
>
#
ifdef
MOZ_CLANG_PLUGIN
#
define
MOZ_RUNINIT
__attribute__
(
(
annotate
(
"
moz_global_var
"
)
)
)
#
else
#
define
MOZ_RUNINIT
#
endif
MOZ_RUNINIT
static
dirent
gDirEnt
;
DIR
:
:
DIR
(
const
WCHAR
*
path
)
:
findHandle
(
INVALID_HANDLE_VALUE
)
{
memset
(
name
0
sizeof
(
name
)
)
;
wcsncpy
(
name
path
sizeof
(
name
)
/
sizeof
(
name
[
0
]
)
)
;
wcsncat
(
name
L
"
\
\
*
"
sizeof
(
name
)
/
sizeof
(
name
[
0
]
)
-
wcslen
(
name
)
-
1
)
;
}
DIR
:
:
~
DIR
(
)
{
if
(
findHandle
!
=
INVALID_HANDLE_VALUE
)
{
FindClose
(
findHandle
)
;
}
}
dirent
:
:
dirent
(
)
{
d_name
[
0
]
=
L
'
\
0
'
;
}
DIR
*
opendir
(
const
WCHAR
*
path
)
{
return
new
DIR
(
path
)
;
}
int
closedir
(
DIR
*
dir
)
{
delete
dir
;
return
0
;
}
dirent
*
readdir
(
DIR
*
dir
)
{
WIN32_FIND_DATAW
data
;
if
(
dir
-
>
findHandle
!
=
INVALID_HANDLE_VALUE
)
{
BOOL
result
=
FindNextFileW
(
dir
-
>
findHandle
&
data
)
;
if
(
!
result
)
{
if
(
GetLastError
(
)
!
=
ERROR_NO_MORE_FILES
)
{
errno
=
ENOENT
;
}
return
0
;
}
}
else
{
dir
-
>
findHandle
=
FindFirstFileW
(
dir
-
>
name
&
data
)
;
if
(
dir
-
>
findHandle
=
=
INVALID_HANDLE_VALUE
)
{
if
(
GetLastError
(
)
=
=
ERROR_FILE_NOT_FOUND
)
{
errno
=
ENOENT
;
}
else
{
errno
=
EBADF
;
}
return
0
;
}
}
size_t
direntBufferLength
=
sizeof
(
gDirEnt
.
d_name
)
/
sizeof
(
gDirEnt
.
d_name
[
0
]
)
;
wcsncpy
(
gDirEnt
.
d_name
data
.
cFileName
direntBufferLength
)
;
gDirEnt
.
d_name
[
direntBufferLength
-
1
]
=
'
\
0
'
;
return
&
gDirEnt
;
}
BOOL
PathAppendSafe
(
LPWSTR
base
LPCWSTR
extra
)
{
if
(
wcslen
(
base
)
+
wcslen
(
extra
)
>
=
MAX_PATH
)
{
return
FALSE
;
}
return
PathAppendW
(
base
extra
)
;
}
BOOL
GetUUIDString
(
LPWSTR
outBuf
)
{
UUID
uuid
;
RPC_WSTR
uuidString
=
nullptr
;
if
(
UuidCreate
(
&
uuid
)
!
=
RPC_S_OK
)
{
return
FALSE
;
}
if
(
UuidToStringW
(
&
uuid
&
uuidString
)
!
=
RPC_S_OK
)
{
return
FALSE
;
}
if
(
!
uuidString
)
{
return
FALSE
;
}
if
(
wcslen
(
reinterpret_cast
<
LPCWSTR
>
(
uuidString
)
)
>
MAX_PATH
)
{
return
FALSE
;
}
wcsncpy
(
outBuf
reinterpret_cast
<
LPCWSTR
>
(
uuidString
)
MAX_PATH
+
1
)
;
RpcStringFreeW
(
&
uuidString
)
;
return
TRUE
;
}
BOOL
GetUUIDTempFilePath
(
LPCWSTR
basePath
LPCWSTR
prefix
LPWSTR
tmpPath
)
{
WCHAR
filename
[
MAX_PATH
+
1
]
=
{
L
"
\
0
"
}
;
if
(
prefix
)
{
if
(
wcslen
(
prefix
)
>
MAX_PATH
)
{
return
FALSE
;
}
wcsncpy
(
filename
prefix
MAX_PATH
+
1
)
;
}
WCHAR
tmpFileNameString
[
MAX_PATH
+
1
]
=
{
L
"
\
0
"
}
;
if
(
!
GetUUIDString
(
tmpFileNameString
)
)
{
return
FALSE
;
}
size_t
tmpFileNameStringLen
=
wcslen
(
tmpFileNameString
)
;
if
(
wcslen
(
filename
)
+
tmpFileNameStringLen
>
MAX_PATH
)
{
return
FALSE
;
}
wcsncat
(
filename
tmpFileNameString
tmpFileNameStringLen
)
;
size_t
basePathLen
=
wcslen
(
basePath
)
;
if
(
basePathLen
>
MAX_PATH
)
{
return
FALSE
;
}
wcsncpy
(
tmpPath
basePath
basePathLen
+
1
)
;
if
(
!
PathAppendSafe
(
tmpPath
filename
)
)
{
return
FALSE
;
}
return
TRUE
;
}
