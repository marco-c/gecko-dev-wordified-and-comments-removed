#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
include
<
winioctl
.
h
>
#
endif
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdarg
.
h
>
#
include
"
updatecommon
.
h
"
#
ifdef
XP_WIN
#
include
"
updatehelper
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
typedef
struct
_REPARSE_DATA_BUFFER
{
ULONG
ReparseTag
;
USHORT
ReparseDataLength
;
USHORT
Reserved
;
union
{
struct
{
USHORT
SubstituteNameOffset
;
USHORT
SubstituteNameLength
;
USHORT
PrintNameOffset
;
USHORT
PrintNameLength
;
ULONG
Flags
;
WCHAR
PathBuffer
[
1
]
;
}
SymbolicLinkReparseBuffer
;
struct
{
USHORT
SubstituteNameOffset
;
USHORT
SubstituteNameLength
;
USHORT
PrintNameOffset
;
USHORT
PrintNameLength
;
WCHAR
PathBuffer
[
1
]
;
}
MountPointReparseBuffer
;
struct
{
UCHAR
DataBuffer
[
1
]
;
}
GenericReparseBuffer
;
}
DUMMYUNIONNAME
;
}
REPARSE_DATA_BUFFER
*
PREPARSE_DATA_BUFFER
;
#
endif
UpdateLog
:
:
UpdateLog
(
)
:
logFP
(
nullptr
)
{
}
void
UpdateLog
:
:
Init
(
NS_tchar
*
logFilePath
)
{
if
(
logFP
)
{
return
;
}
int
dstFilePathLen
=
NS_tstrlen
(
logFilePath
)
;
if
(
dstFilePathLen
>
0
&
&
dstFilePathLen
<
MAXPATHLEN
-
1
)
{
NS_tstrncpy
(
mDstFilePath
logFilePath
MAXPATHLEN
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
logFP
=
NS_tfopen
(
mDstFilePath
NS_T
(
"
w
"
)
)
;
#
else
logFP
=
tmpfile
(
)
;
#
endif
}
}
void
UpdateLog
:
:
Finish
(
)
{
if
(
!
logFP
)
{
return
;
}
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
XP_MACOSX
)
const
int
blockSize
=
1024
;
char
buffer
[
blockSize
]
;
fflush
(
logFP
)
;
rewind
(
logFP
)
;
FILE
*
updateLogFP
=
NS_tfopen
(
mDstFilePath
NS_T
(
"
wb
+
"
)
)
;
while
(
!
feof
(
logFP
)
)
{
size_t
read
=
fread
(
buffer
1
blockSize
logFP
)
;
if
(
ferror
(
logFP
)
)
{
fclose
(
logFP
)
;
logFP
=
nullptr
;
fclose
(
updateLogFP
)
;
updateLogFP
=
nullptr
;
return
;
}
size_t
written
=
0
;
while
(
written
<
read
)
{
size_t
chunkWritten
=
fwrite
(
buffer
1
read
-
written
updateLogFP
)
;
if
(
chunkWritten
<
=
0
)
{
fclose
(
logFP
)
;
logFP
=
nullptr
;
fclose
(
updateLogFP
)
;
updateLogFP
=
nullptr
;
return
;
}
written
+
=
chunkWritten
;
}
}
fclose
(
updateLogFP
)
;
updateLogFP
=
nullptr
;
#
endif
fclose
(
logFP
)
;
logFP
=
nullptr
;
}
void
UpdateLog
:
:
Flush
(
)
{
if
(
!
logFP
)
{
return
;
}
fflush
(
logFP
)
;
}
void
UpdateLog
:
:
Printf
(
const
char
*
fmt
.
.
.
)
{
if
(
!
logFP
)
{
return
;
}
va_list
ap
;
va_start
(
ap
fmt
)
;
vfprintf
(
logFP
fmt
ap
)
;
fprintf
(
logFP
"
\
n
"
)
;
va_end
(
ap
)
;
}
void
UpdateLog
:
:
WarnPrintf
(
const
char
*
fmt
.
.
.
)
{
if
(
!
logFP
)
{
return
;
}
va_list
ap
;
va_start
(
ap
fmt
)
;
fprintf
(
logFP
"
*
*
*
Warning
:
"
)
;
vfprintf
(
logFP
fmt
ap
)
;
fprintf
(
logFP
"
*
*
*
\
n
"
)
;
va_end
(
ap
)
;
}
#
ifdef
XP_WIN
bool
PathContainsInvalidLinks
(
wchar_t
*
const
fullPath
)
{
wchar_t
pathCopy
[
MAXPATHLEN
+
1
]
=
L
"
"
;
wcsncpy
(
pathCopy
fullPath
MAXPATHLEN
)
;
wchar_t
*
remainingPath
=
nullptr
;
wchar_t
*
nextToken
=
wcstok_s
(
pathCopy
L
"
\
\
"
&
remainingPath
)
;
wchar_t
*
partialPath
=
nextToken
;
while
(
nextToken
)
{
if
(
(
GetFileAttributesW
(
partialPath
)
&
FILE_ATTRIBUTE_REPARSE_POINT
)
!
=
0
)
{
nsAutoHandle
h
(
CreateFileW
(
partialPath
0
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
|
FILE_FLAG_OPEN_REPARSE_POINT
nullptr
)
)
;
if
(
h
=
=
INVALID_HANDLE_VALUE
)
{
if
(
GetLastError
(
)
=
=
ERROR_FILE_NOT_FOUND
)
{
return
false
;
}
else
{
return
true
;
}
}
mozilla
:
:
UniquePtr
<
UINT8
[
]
>
byteBuffer
=
mozilla
:
:
MakeUnique
<
UINT8
[
]
>
(
MAXIMUM_REPARSE_DATA_BUFFER_SIZE
)
;
if
(
!
byteBuffer
)
{
return
true
;
}
ZeroMemory
(
byteBuffer
.
get
(
)
MAXIMUM_REPARSE_DATA_BUFFER_SIZE
)
;
REPARSE_DATA_BUFFER
*
buffer
=
(
REPARSE_DATA_BUFFER
*
)
byteBuffer
.
get
(
)
;
DWORD
bytes
=
0
;
if
(
!
DeviceIoControl
(
h
FSCTL_GET_REPARSE_POINT
nullptr
0
buffer
MAXIMUM_REPARSE_DATA_BUFFER_SIZE
&
bytes
nullptr
)
)
{
return
true
;
}
wchar_t
*
reparseTarget
=
nullptr
;
switch
(
buffer
-
>
ReparseTag
)
{
case
IO_REPARSE_TAG_MOUNT_POINT
:
reparseTarget
=
buffer
-
>
MountPointReparseBuffer
.
PathBuffer
+
(
buffer
-
>
MountPointReparseBuffer
.
SubstituteNameOffset
/
sizeof
(
wchar_t
)
)
;
if
(
buffer
-
>
MountPointReparseBuffer
.
SubstituteNameLength
<
ARRAYSIZE
(
L
"
\
\
?
?
\
\
"
)
)
{
return
false
;
}
break
;
case
IO_REPARSE_TAG_SYMLINK
:
reparseTarget
=
buffer
-
>
SymbolicLinkReparseBuffer
.
PathBuffer
+
(
buffer
-
>
SymbolicLinkReparseBuffer
.
SubstituteNameOffset
/
sizeof
(
wchar_t
)
)
;
if
(
buffer
-
>
SymbolicLinkReparseBuffer
.
SubstituteNameLength
<
ARRAYSIZE
(
L
"
\
\
?
?
\
\
"
)
)
{
return
false
;
}
break
;
default
:
return
true
;
break
;
}
if
(
!
reparseTarget
)
{
return
false
;
}
if
(
wcsncmp
(
reparseTarget
L
"
\
\
?
?
\
\
"
ARRAYSIZE
(
L
"
\
\
?
?
\
\
"
)
-
1
)
!
=
0
)
{
return
true
;
}
}
nextToken
=
wcstok_s
(
nullptr
L
"
\
\
"
&
remainingPath
)
;
PathAppendW
(
partialPath
nextToken
)
;
}
return
false
;
}
#
endif
bool
IsValidFullPath
(
NS_tchar
*
origFullPath
)
{
if
(
NS_tstrlen
(
origFullPath
)
>
MAXPATHLEN
-
1
)
{
return
false
;
}
#
ifdef
XP_WIN
NS_tchar
testPath
[
MAXPATHLEN
]
=
{
NS_T
(
'
\
0
'
)
}
;
if
(
GetFullPathNameW
(
origFullPath
MAXPATHLEN
testPath
nullptr
)
=
=
0
)
{
return
false
;
}
NS_tchar
canonicalPath
[
MAXPATHLEN
]
=
{
NS_T
(
'
\
0
'
)
}
;
if
(
!
PathCanonicalizeW
(
canonicalPath
testPath
)
)
{
return
false
;
}
if
(
NS_tstricmp
(
origFullPath
canonicalPath
)
!
=
0
)
{
return
false
;
}
NS_tstrncpy
(
testPath
origFullPath
MAXPATHLEN
)
;
if
(
!
PathStripToRootW
(
testPath
)
)
{
return
false
;
}
if
(
origFullPath
[
0
]
=
=
NS_T
(
'
\
\
'
)
)
{
if
(
!
PathIsUNCServerShareW
(
testPath
)
)
{
return
false
;
}
}
if
(
PathContainsInvalidLinks
(
canonicalPath
)
)
{
return
false
;
}
#
else
if
(
origFullPath
[
0
]
!
=
NS_T
(
'
/
'
)
)
{
return
false
;
}
if
(
NS_tstrstr
(
origFullPath
NS_T
(
"
.
.
"
)
)
!
=
nullptr
|
|
NS_tstrstr
(
origFullPath
NS_T
(
"
.
/
"
)
)
!
=
nullptr
)
{
return
false
;
}
#
endif
return
true
;
}
