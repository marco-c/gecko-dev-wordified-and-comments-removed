#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
endif
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdarg
.
h
>
#
include
"
updatecommon
.
h
"
UpdateLog
:
:
UpdateLog
(
)
:
logFP
(
nullptr
)
{
}
void
UpdateLog
:
:
Init
(
NS_tchar
*
sourcePath
const
NS_tchar
*
fileName
)
{
if
(
logFP
)
{
return
;
}
int
dstFilePathLen
=
NS_tsnprintf
(
mDstFilePath
sizeof
(
mDstFilePath
)
/
sizeof
(
mDstFilePath
[
0
]
)
NS_T
(
"
%
s
/
%
s
"
)
sourcePath
fileName
)
;
if
(
(
dstFilePathLen
>
0
)
&
&
(
dstFilePathLen
<
static_cast
<
int
>
(
sizeof
(
mDstFilePath
)
/
sizeof
(
mDstFilePath
[
0
]
)
)
)
)
{
#
ifdef
XP_WIN
if
(
GetTempFileNameW
(
sourcePath
L
"
log
"
0
mTmpFilePath
)
!
=
0
)
{
logFP
=
NS_tfopen
(
mTmpFilePath
NS_T
(
"
w
"
)
)
;
DeleteFileW
(
mDstFilePath
)
;
}
#
elif
XP_MACOSX
logFP
=
NS_tfopen
(
mDstFilePath
NS_T
(
"
w
"
)
)
;
#
else
logFP
=
tmpfile
(
)
;
#
endif
}
}
void
UpdateLog
:
:
Finish
(
)
{
if
(
!
logFP
)
{
return
;
}
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
XP_MACOSX
)
const
int
blockSize
=
1024
;
char
buffer
[
blockSize
]
;
fflush
(
logFP
)
;
rewind
(
logFP
)
;
FILE
*
updateLogFP
=
NS_tfopen
(
mDstFilePath
NS_T
(
"
wb
+
"
)
)
;
while
(
!
feof
(
logFP
)
)
{
size_t
read
=
fread
(
buffer
1
blockSize
logFP
)
;
if
(
ferror
(
logFP
)
)
{
fclose
(
logFP
)
;
logFP
=
nullptr
;
fclose
(
updateLogFP
)
;
updateLogFP
=
nullptr
;
return
;
}
size_t
written
=
0
;
while
(
written
<
read
)
{
size_t
chunkWritten
=
fwrite
(
buffer
1
read
-
written
updateLogFP
)
;
if
(
chunkWritten
<
=
0
)
{
fclose
(
logFP
)
;
logFP
=
nullptr
;
fclose
(
updateLogFP
)
;
updateLogFP
=
nullptr
;
return
;
}
written
+
=
chunkWritten
;
}
}
fclose
(
updateLogFP
)
;
updateLogFP
=
nullptr
;
#
endif
fclose
(
logFP
)
;
logFP
=
nullptr
;
#
ifdef
XP_WIN
if
(
!
NS_taccess
(
mDstFilePath
F_OK
)
)
{
DeleteFileW
(
mTmpFilePath
)
;
}
else
{
MoveFileW
(
mTmpFilePath
mDstFilePath
)
;
}
#
endif
}
void
UpdateLog
:
:
Flush
(
)
{
if
(
!
logFP
)
{
return
;
}
fflush
(
logFP
)
;
}
void
UpdateLog
:
:
Printf
(
const
char
*
fmt
.
.
.
)
{
if
(
!
logFP
)
{
return
;
}
va_list
ap
;
va_start
(
ap
fmt
)
;
vfprintf
(
logFP
fmt
ap
)
;
fprintf
(
logFP
"
\
n
"
)
;
va_end
(
ap
)
;
}
void
UpdateLog
:
:
WarnPrintf
(
const
char
*
fmt
.
.
.
)
{
if
(
!
logFP
)
{
return
;
}
va_list
ap
;
va_start
(
ap
fmt
)
;
fprintf
(
logFP
"
*
*
*
Warning
:
"
)
;
vfprintf
(
logFP
fmt
ap
)
;
fprintf
(
logFP
"
*
*
*
\
n
"
)
;
va_end
(
ap
)
;
}
bool
IsValidFullPath
(
NS_tchar
*
origFullPath
)
{
if
(
NS_tstrlen
(
origFullPath
)
>
MAXPATHLEN
-
1
)
{
return
false
;
}
#
ifdef
XP_WIN
NS_tchar
testPath
[
MAXPATHLEN
]
=
{
NS_T
(
'
\
0
'
)
}
;
if
(
GetFullPathNameW
(
origFullPath
MAXPATHLEN
testPath
nullptr
)
=
=
0
)
{
return
false
;
}
NS_tchar
canonicalPath
[
MAXPATHLEN
]
=
{
NS_T
(
'
\
0
'
)
}
;
if
(
!
PathCanonicalizeW
(
canonicalPath
testPath
)
)
{
return
false
;
}
if
(
NS_tstricmp
(
origFullPath
canonicalPath
)
!
=
0
)
{
return
false
;
}
NS_tstrncpy
(
testPath
origFullPath
MAXPATHLEN
)
;
if
(
!
PathStripToRootW
(
testPath
)
)
{
return
false
;
}
if
(
origFullPath
[
0
]
=
=
NS_T
(
'
\
\
'
)
)
{
if
(
!
PathIsUNCServerShareW
(
testPath
)
)
{
return
false
;
}
}
#
else
if
(
origFullPath
[
0
]
!
=
NS_T
(
'
/
'
)
)
{
return
false
;
}
if
(
NS_tstrstr
(
origFullPath
NS_T
(
"
.
.
"
)
)
!
=
nullptr
|
|
NS_tstrstr
(
origFullPath
NS_T
(
"
.
/
"
)
)
!
=
nullptr
)
{
return
false
;
}
#
endif
return
true
;
}
