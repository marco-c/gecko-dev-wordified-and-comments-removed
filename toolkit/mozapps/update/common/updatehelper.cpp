#
include
<
windows
.
h
>
#
include
<
tlhelp32
.
h
>
#
include
<
stdio
.
h
>
#
include
<
direct
.
h
>
#
include
"
shlobj
.
h
"
#
include
<
shlwapi
.
h
>
#
include
"
updatecommon
.
h
"
#
include
"
updatehelper
.
h
"
#
include
"
updateutils_win
.
h
"
#
ifdef
MOZ_MAINTENANCE_SERVICE
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
pathhash
.
h
"
#
include
"
registrycertificates
.
h
"
#
include
"
uachelper
.
h
"
using
mozilla
:
:
MakeUnique
;
using
mozilla
:
:
UniquePtr
;
#
endif
BOOL
PathGetSiblingFilePath
(
LPWSTR
destinationBuffer
LPCWSTR
siblingFilePath
LPCWSTR
newFileName
)
;
BOOL
PathGetSiblingFilePath
(
LPWSTR
destinationBuffer
LPCWSTR
siblingFilePath
LPCWSTR
newFileName
)
{
if
(
wcslen
(
siblingFilePath
)
>
MAX_PATH
)
{
return
FALSE
;
}
wcsncpy
(
destinationBuffer
siblingFilePath
MAX_PATH
+
1
)
;
if
(
!
PathRemoveFileSpecW
(
destinationBuffer
)
)
{
return
FALSE
;
}
return
PathAppendSafe
(
destinationBuffer
newFileName
)
;
}
BOOL
GetSecureOutputDirectoryPath
(
LPWSTR
outBuf
)
{
PWSTR
progFilesX86
;
if
(
FAILED
(
SHGetKnownFolderPath
(
FOLDERID_ProgramFilesX86
KF_FLAG_CREATE
nullptr
&
progFilesX86
)
)
)
{
return
FALSE
;
}
if
(
wcslen
(
progFilesX86
)
>
MAX_PATH
)
{
CoTaskMemFree
(
progFilesX86
)
;
return
FALSE
;
}
wcsncpy
(
outBuf
progFilesX86
MAX_PATH
+
1
)
;
CoTaskMemFree
(
progFilesX86
)
;
if
(
!
PathAppendSafe
(
outBuf
L
"
Mozilla
Maintenance
Service
"
)
)
{
return
FALSE
;
}
if
(
!
CreateDirectoryW
(
outBuf
nullptr
)
&
&
GetLastError
(
)
!
=
ERROR_ALREADY_EXISTS
)
{
return
FALSE
;
}
if
(
!
PathAppendSafe
(
outBuf
L
"
UpdateLogs
"
)
)
{
return
FALSE
;
}
if
(
!
CreateDirectoryW
(
outBuf
nullptr
)
&
&
GetLastError
(
)
!
=
ERROR_ALREADY_EXISTS
)
{
return
FALSE
;
}
return
TRUE
;
}
BOOL
GetSecureOutputFileName
(
LPCWSTR
patchDirPath
LPCWSTR
fileExt
LPWSTR
outBuf
)
{
size_t
fullPathLen
=
wcslen
(
patchDirPath
)
;
if
(
fullPathLen
>
MAX_PATH
)
{
return
FALSE
;
}
size_t
relPathLen
=
wcslen
(
PATCH_DIR_PATH
)
;
if
(
relPathLen
>
fullPathLen
)
{
return
FALSE
;
}
if
(
_wcsnicmp
(
patchDirPath
+
fullPathLen
-
relPathLen
PATCH_DIR_PATH
relPathLen
)
!
=
0
)
{
return
FALSE
;
}
wcsncpy
(
outBuf
patchDirPath
MAX_PATH
+
1
)
;
if
(
!
PathRemoveFileSpecW
(
outBuf
)
)
{
return
FALSE
;
}
if
(
!
PathRemoveFileSpecW
(
outBuf
)
)
{
return
FALSE
;
}
PathStripPathW
(
outBuf
)
;
size_t
outBufLen
=
wcslen
(
outBuf
)
;
size_t
fileExtLen
=
wcslen
(
fileExt
)
;
if
(
outBufLen
+
fileExtLen
>
MAX_PATH
)
{
return
FALSE
;
}
wcsncat
(
outBuf
fileExt
fileExtLen
)
;
return
TRUE
;
}
BOOL
GetSecureOutputFilePath
(
LPCWSTR
patchDirPath
LPCWSTR
fileExt
LPWSTR
outBuf
)
{
if
(
!
GetSecureOutputDirectoryPath
(
outBuf
)
)
{
return
FALSE
;
}
WCHAR
statusFileName
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
GetSecureOutputFileName
(
patchDirPath
fileExt
statusFileName
)
)
{
return
FALSE
;
}
return
PathAppendSafe
(
outBuf
statusFileName
)
;
}
BOOL
WriteSecureIDFile
(
LPCWSTR
patchDirPath
)
{
WCHAR
uuidString
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
GetUUIDString
(
uuidString
)
)
{
return
FALSE
;
}
WCHAR
idFilePath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
GetSecureOutputFilePath
(
patchDirPath
L
"
.
id
"
idFilePath
)
)
{
return
FALSE
;
}
FILE
*
idFile
=
_wfopen
(
idFilePath
L
"
wb
+
"
)
;
if
(
idFile
=
=
nullptr
)
{
return
FALSE
;
}
if
(
fprintf
(
idFile
"
%
ls
\
n
"
uuidString
)
=
=
-
1
)
{
fclose
(
idFile
)
;
return
FALSE
;
}
fclose
(
idFile
)
;
return
TRUE
;
}
void
RemoveSecureOutputFiles
(
LPCWSTR
patchDirPath
)
{
WCHAR
filePath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
GetSecureOutputFilePath
(
patchDirPath
L
"
.
id
"
filePath
)
)
{
(
void
)
_wremove
(
filePath
)
;
}
if
(
GetSecureOutputFilePath
(
patchDirPath
L
"
.
status
"
filePath
)
)
{
(
void
)
_wremove
(
filePath
)
;
}
if
(
GetSecureOutputFilePath
(
patchDirPath
L
"
.
log
"
filePath
)
)
{
(
void
)
_wremove
(
filePath
)
;
}
}
#
ifdef
MOZ_MAINTENANCE_SERVICE
BOOL
StartServiceUpdate
(
LPCWSTR
installDir
)
{
SC_HANDLE
manager
=
OpenSCManager
(
nullptr
nullptr
SC_MANAGER_ALL_ACCESS
)
;
if
(
!
manager
)
{
LOG
(
(
"
StartServiceUpdate
:
Failed
to
open
SCM
"
)
)
;
return
FALSE
;
}
SC_HANDLE
svc
=
OpenServiceW
(
manager
SVC_NAME
SERVICE_ALL_ACCESS
)
;
if
(
!
svc
)
{
LOG
(
(
"
StartServiceUpdate
:
Unable
to
open
service
"
)
)
;
CloseServiceHandle
(
manager
)
;
return
FALSE
;
}
CloseServiceHandle
(
manager
)
;
DWORD
bytesNeeded
;
if
(
!
QueryServiceConfigW
(
svc
nullptr
0
&
bytesNeeded
)
)
{
DWORD
lastError
=
GetLastError
(
)
;
if
(
lastError
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
LOG
(
(
"
StartServiceUpdate
:
Failed
to
query
MMS
:
%
lu
"
lastError
)
)
;
CloseServiceHandle
(
svc
)
;
return
FALSE
;
}
}
UniquePtr
<
char
[
]
>
serviceConfigBuffer
=
MakeUnique
<
char
[
]
>
(
bytesNeeded
)
;
if
(
!
QueryServiceConfigW
(
svc
reinterpret_cast
<
QUERY_SERVICE_CONFIGW
*
>
(
serviceConfigBuffer
.
get
(
)
)
bytesNeeded
&
bytesNeeded
)
)
{
LOG
(
(
"
StartServiceUpdate
:
Failed
to
read
MMS
:
%
lu
"
GetLastError
(
)
)
)
;
CloseServiceHandle
(
svc
)
;
return
FALSE
;
}
CloseServiceHandle
(
svc
)
;
QUERY_SERVICE_CONFIGW
&
serviceConfig
=
*
reinterpret_cast
<
QUERY_SERVICE_CONFIGW
*
>
(
serviceConfigBuffer
.
get
(
)
)
;
PathUnquoteSpacesW
(
serviceConfig
.
lpBinaryPathName
)
;
WCHAR
tmpService
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
PathGetSiblingFilePath
(
tmpService
serviceConfig
.
lpBinaryPathName
L
"
maintenanceservice_tmp
.
exe
"
)
)
{
LOG
(
(
"
StartServiceUpdate
:
Failed
to
get
temp
bin
path
"
)
)
;
return
FALSE
;
}
if
(
wcslen
(
installDir
)
>
MAX_PATH
)
{
LOG
(
(
"
StartServiceUpdate
:
Install
dir
path
too
long
"
)
)
;
return
FALSE
;
}
WCHAR
newMaintServicePath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
wcsncpy
(
newMaintServicePath
installDir
MAX_PATH
)
;
PathAppendSafe
(
newMaintServicePath
L
"
maintenanceservice
.
exe
"
)
;
if
(
!
CopyFileW
(
newMaintServicePath
tmpService
FALSE
)
)
{
LOG
(
(
"
StartServiceUpdate
:
Failed
to
copy
temp
MMS
"
)
)
;
return
FALSE
;
}
if
(
!
DoesBinaryMatchAllowedCertificates
(
installDir
tmpService
)
)
{
LOG
(
(
"
StartServiceUpdate
:
Binary
doesn
'
t
match
certs
"
)
)
;
DeleteFileW
(
tmpService
)
;
return
FALSE
;
}
STARTUPINFOW
si
=
{
0
}
;
si
.
cb
=
sizeof
(
STARTUPINFOW
)
;
si
.
lpDesktop
=
const_cast
<
LPWSTR
>
(
L
"
"
)
;
PROCESS_INFORMATION
pi
=
{
0
}
;
WCHAR
cmdLine
[
64
]
=
{
'
\
0
'
}
;
wcsncpy
(
cmdLine
L
"
dummyparam
.
exe
upgrade
"
sizeof
(
cmdLine
)
/
sizeof
(
cmdLine
[
0
]
)
-
1
)
;
BOOL
svcUpdateProcessStarted
=
CreateProcessW
(
tmpService
cmdLine
nullptr
nullptr
FALSE
0
nullptr
installDir
&
si
&
pi
)
;
if
(
svcUpdateProcessStarted
)
{
LOG
(
(
"
StartServiceUpdate
:
Launched
MMS
update
successfully
"
)
)
;
CloseHandle
(
pi
.
hProcess
)
;
CloseHandle
(
pi
.
hThread
)
;
}
else
{
LOG
(
(
"
StartServiceUpdate
:
MMS
update
failed
:
%
lu
"
GetLastError
(
)
)
)
;
}
return
svcUpdateProcessStarted
;
}
DWORD
StartServiceCommand
(
int
argc
LPCWSTR
*
argv
)
{
DWORD
lastState
=
WaitForServiceStop
(
SVC_NAME
5
)
;
if
(
lastState
!
=
SERVICE_STOPPED
)
{
return
20000
+
lastState
;
}
SC_HANDLE
serviceManager
=
OpenSCManager
(
nullptr
nullptr
SC_MANAGER_CONNECT
|
SC_MANAGER_ENUMERATE_SERVICE
)
;
if
(
!
serviceManager
)
{
return
17001
;
}
SC_HANDLE
service
=
OpenServiceW
(
serviceManager
SVC_NAME
SERVICE_START
)
;
if
(
!
service
)
{
CloseServiceHandle
(
serviceManager
)
;
return
17002
;
}
const
DWORD
maxWaitMS
=
5000
;
DWORD
currentWaitMS
=
0
;
DWORD
lastError
=
ERROR_SUCCESS
;
while
(
currentWaitMS
<
maxWaitMS
)
{
BOOL
result
=
StartServiceW
(
service
argc
argv
)
;
if
(
result
)
{
lastError
=
ERROR_SUCCESS
;
break
;
}
else
{
lastError
=
GetLastError
(
)
;
}
Sleep
(
100
)
;
currentWaitMS
+
=
100
;
}
CloseServiceHandle
(
service
)
;
CloseServiceHandle
(
serviceManager
)
;
return
lastError
;
}
DWORD
LaunchServiceSoftwareUpdateCommand
(
int
argc
LPCWSTR
*
argv
)
{
LPCWSTR
*
updaterServiceArgv
=
new
LPCWSTR
[
argc
+
2
]
;
updaterServiceArgv
[
0
]
=
L
"
MozillaMaintenance
"
;
updaterServiceArgv
[
1
]
=
L
"
software
-
update
"
;
for
(
int
i
=
0
;
i
<
argc
;
+
+
i
)
{
updaterServiceArgv
[
i
+
2
]
=
argv
[
i
]
;
}
DWORD
ret
=
StartServiceCommand
(
argc
+
2
updaterServiceArgv
)
;
delete
[
]
updaterServiceArgv
;
return
ret
;
}
BOOL
WriteStatusFailure
(
LPCWSTR
patchDirPath
int
errorCode
)
{
WCHAR
statusFilePath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
!
GetSecureOutputFilePath
(
patchDirPath
L
"
.
status
"
statusFilePath
)
)
{
return
FALSE
;
}
HANDLE
hStatusFile
=
CreateFileW
(
statusFilePath
GENERIC_WRITE
0
nullptr
CREATE_ALWAYS
0
nullptr
)
;
if
(
hStatusFile
=
=
INVALID_HANDLE_VALUE
)
{
return
FALSE
;
}
char
failure
[
32
]
;
sprintf
(
failure
"
failed
:
%
d
"
errorCode
)
;
DWORD
toWrite
=
strlen
(
failure
)
;
DWORD
wrote
;
BOOL
ok
=
WriteFile
(
hStatusFile
failure
toWrite
&
wrote
nullptr
)
;
CloseHandle
(
hStatusFile
)
;
if
(
!
ok
|
|
wrote
!
=
toWrite
)
{
return
FALSE
;
}
return
TRUE
;
}
DWORD
WaitForServiceStop
(
LPCWSTR
serviceName
DWORD
maxWaitSeconds
)
{
DWORD
lastServiceState
=
0x000000CF
;
SC_HANDLE
serviceManager
=
OpenSCManager
(
nullptr
nullptr
SC_MANAGER_CONNECT
|
SC_MANAGER_ENUMERATE_SERVICE
)
;
if
(
!
serviceManager
)
{
DWORD
lastError
=
GetLastError
(
)
;
switch
(
lastError
)
{
case
ERROR_ACCESS_DENIED
:
return
0x000000FD
;
case
ERROR_DATABASE_DOES_NOT_EXIST
:
return
0x000000FE
;
default
:
return
0x000000FF
;
}
}
SC_HANDLE
service
=
OpenServiceW
(
serviceManager
serviceName
SERVICE_QUERY_STATUS
)
;
if
(
!
service
)
{
DWORD
lastError
=
GetLastError
(
)
;
CloseServiceHandle
(
serviceManager
)
;
switch
(
lastError
)
{
case
ERROR_ACCESS_DENIED
:
return
0x000000EB
;
case
ERROR_INVALID_HANDLE
:
return
0x000000EC
;
case
ERROR_INVALID_NAME
:
return
0x000000ED
;
case
ERROR_SERVICE_DOES_NOT_EXIST
:
return
0x000000EE
;
default
:
return
0x000000EF
;
}
}
DWORD
currentWaitMS
=
0
;
SERVICE_STATUS_PROCESS
ssp
;
ssp
.
dwCurrentState
=
lastServiceState
;
while
(
currentWaitMS
<
maxWaitSeconds
*
1000
)
{
DWORD
bytesNeeded
;
if
(
!
QueryServiceStatusEx
(
service
SC_STATUS_PROCESS_INFO
(
LPBYTE
)
&
ssp
sizeof
(
SERVICE_STATUS_PROCESS
)
&
bytesNeeded
)
)
{
DWORD
lastError
=
GetLastError
(
)
;
switch
(
lastError
)
{
case
ERROR_INVALID_HANDLE
:
ssp
.
dwCurrentState
=
0x000000D9
;
break
;
case
ERROR_ACCESS_DENIED
:
ssp
.
dwCurrentState
=
0x000000DA
;
break
;
case
ERROR_INSUFFICIENT_BUFFER
:
ssp
.
dwCurrentState
=
0x000000DB
;
break
;
case
ERROR_INVALID_PARAMETER
:
ssp
.
dwCurrentState
=
0x000000DC
;
break
;
case
ERROR_INVALID_LEVEL
:
ssp
.
dwCurrentState
=
0x000000DD
;
break
;
case
ERROR_SHUTDOWN_IN_PROGRESS
:
ssp
.
dwCurrentState
=
0x000000DE
;
break
;
case
ERROR_INVALID_SERVICE_CONTROL
:
case
ERROR_SERVICE_CANNOT_ACCEPT_CTRL
:
case
ERROR_SERVICE_NOT_ACTIVE
:
currentWaitMS
+
=
50
;
Sleep
(
50
)
;
continue
;
default
:
ssp
.
dwCurrentState
=
0x000000DF
;
}
break
;
}
if
(
ssp
.
dwCurrentState
=
=
SERVICE_STOPPED
)
{
break
;
}
currentWaitMS
+
=
50
;
Sleep
(
50
)
;
}
lastServiceState
=
ssp
.
dwCurrentState
;
CloseServiceHandle
(
service
)
;
CloseServiceHandle
(
serviceManager
)
;
return
lastServiceState
;
}
#
endif
DWORD
IsProcessRunning
(
LPCWSTR
filename
)
{
HANDLE
snapshot
=
CreateToolhelp32Snapshot
(
TH32CS_SNAPPROCESS
0
)
;
if
(
INVALID_HANDLE_VALUE
=
=
snapshot
)
{
return
GetLastError
(
)
;
}
PROCESSENTRY32W
processEntry
;
processEntry
.
dwSize
=
sizeof
(
PROCESSENTRY32W
)
;
if
(
!
Process32FirstW
(
snapshot
&
processEntry
)
)
{
DWORD
lastError
=
GetLastError
(
)
;
CloseHandle
(
snapshot
)
;
return
lastError
;
}
do
{
if
(
wcsicmp
(
filename
processEntry
.
szExeFile
)
=
=
0
)
{
CloseHandle
(
snapshot
)
;
return
ERROR_SUCCESS
;
}
}
while
(
Process32NextW
(
snapshot
&
processEntry
)
)
;
CloseHandle
(
snapshot
)
;
return
ERROR_NOT_FOUND
;
}
DWORD
WaitForProcessExit
(
LPCWSTR
filename
DWORD
maxSeconds
)
{
DWORD
applicationRunningError
=
WAIT_TIMEOUT
;
for
(
DWORD
i
=
0
;
i
<
maxSeconds
;
i
+
+
)
{
DWORD
applicationRunningError
=
IsProcessRunning
(
filename
)
;
if
(
ERROR_NOT_FOUND
=
=
applicationRunningError
)
{
return
ERROR_SUCCESS
;
}
Sleep
(
1000
)
;
}
if
(
ERROR_SUCCESS
=
=
applicationRunningError
)
{
return
WAIT_TIMEOUT
;
}
return
applicationRunningError
;
}
#
ifdef
MOZ_MAINTENANCE_SERVICE
BOOL
DoesFallbackKeyExist
(
)
{
HKEY
testOnlyFallbackKey
;
if
(
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
TEST_ONLY_FALLBACK_KEY_PATH
0
KEY_READ
|
KEY_WOW64_64KEY
&
testOnlyFallbackKey
)
!
=
ERROR_SUCCESS
)
{
return
FALSE
;
}
RegCloseKey
(
testOnlyFallbackKey
)
;
return
TRUE
;
}
BOOL
IsLocalFile
(
LPCWSTR
file
BOOL
&
isLocal
)
{
WCHAR
rootPath
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
if
(
wcslen
(
file
)
>
MAX_PATH
)
{
return
FALSE
;
}
wcsncpy
(
rootPath
file
MAX_PATH
)
;
PathStripToRootW
(
rootPath
)
;
isLocal
=
GetDriveTypeW
(
rootPath
)
=
=
DRIVE_FIXED
;
return
TRUE
;
}
static
BOOL
GetDWORDValue
(
HKEY
key
LPCWSTR
valueName
DWORD
&
retValue
)
{
DWORD
regDWORDValueSize
=
sizeof
(
DWORD
)
;
LONG
retCode
=
RegQueryValueExW
(
key
valueName
0
nullptr
reinterpret_cast
<
LPBYTE
>
(
&
retValue
)
&
regDWORDValueSize
)
;
return
ERROR_SUCCESS
=
=
retCode
;
}
BOOL
IsUnpromptedElevation
(
BOOL
&
isUnpromptedElevation
)
{
if
(
!
UACHelper
:
:
CanUserElevate
(
)
)
{
return
FALSE
;
}
LPCWSTR
UACBaseRegKey
=
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Policies
\
\
System
"
;
HKEY
baseKey
;
LONG
retCode
=
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
UACBaseRegKey
0
KEY_READ
&
baseKey
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
return
FALSE
;
}
DWORD
consent
secureDesktop
;
BOOL
success
=
GetDWORDValue
(
baseKey
L
"
ConsentPromptBehaviorAdmin
"
consent
)
;
success
=
success
&
&
GetDWORDValue
(
baseKey
L
"
PromptOnSecureDesktop
"
secureDesktop
)
;
RegCloseKey
(
baseKey
)
;
if
(
success
)
{
isUnpromptedElevation
=
!
consent
&
&
!
secureDesktop
;
}
return
success
;
}
#
endif
