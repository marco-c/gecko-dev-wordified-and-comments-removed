#
include
<
windows
.
h
>
#
include
"
registrycertificates
.
h
"
#
include
"
pathhash
.
h
"
#
include
"
updatecommon
.
h
"
#
include
"
updatehelper
.
h
"
#
define
MAX_KEY_LENGTH
255
BOOL
DoesBinaryMatchAllowedCertificates
(
LPCWSTR
basePathForUpdate
LPCWSTR
filePath
BOOL
allowFallbackKeySkip
)
{
#
ifdef
DISABLE_UPDATER_AUTHENTICODE_CHECK
if
(
allowFallbackKeySkip
)
{
LOG_WARN
(
(
"
Skipping
authenticode
check
"
)
)
;
return
TRUE
;
}
else
{
LOG
(
(
"
Performing
a
diagnostic
authenticode
check
"
)
)
;
}
#
endif
WCHAR
maintenanceServiceKey
[
MAX_PATH
+
1
]
;
if
(
!
CalculateRegistryPathFromFilePath
(
basePathForUpdate
maintenanceServiceKey
)
)
{
return
FALSE
;
}
HKEY
baseKey
;
LONG
retCode
=
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
maintenanceServiceKey
0
KEY_READ
|
KEY_WOW64_64KEY
&
baseKey
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Could
not
open
key
.
(
%
ld
)
"
retCode
)
)
;
retCode
=
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
TEST_ONLY_FALLBACK_KEY_PATH
0
KEY_READ
|
KEY_WOW64_64KEY
&
baseKey
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Could
not
open
fallback
key
.
(
%
ld
)
"
retCode
)
)
;
return
FALSE
;
}
else
if
(
allowFallbackKeySkip
)
{
LOG_WARN
(
(
"
Fallback
key
present
skipping
VerifyCertificateTrustForFile
"
"
check
and
the
certificate
attribute
registry
matching
"
"
check
.
"
)
)
;
RegCloseKey
(
baseKey
)
;
return
TRUE
;
}
}
DWORD
subkeyCount
=
0
;
retCode
=
RegQueryInfoKeyW
(
baseKey
nullptr
nullptr
nullptr
&
subkeyCount
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Could
not
query
info
key
.
(
%
ld
)
"
retCode
)
)
;
RegCloseKey
(
baseKey
)
;
return
FALSE
;
}
for
(
DWORD
i
=
0
;
i
<
subkeyCount
;
i
+
+
)
{
WCHAR
subkeyBuffer
[
MAX_KEY_LENGTH
]
;
DWORD
subkeyBufferCount
=
MAX_KEY_LENGTH
;
retCode
=
RegEnumKeyExW
(
baseKey
i
subkeyBuffer
&
subkeyBufferCount
nullptr
nullptr
nullptr
nullptr
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Could
not
enum
certs
.
(
%
ld
)
"
retCode
)
)
;
RegCloseKey
(
baseKey
)
;
return
FALSE
;
}
HKEY
subKey
;
retCode
=
RegOpenKeyExW
(
baseKey
subkeyBuffer
0
KEY_READ
|
KEY_WOW64_64KEY
&
subKey
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Could
not
open
subkey
.
(
%
ld
)
"
retCode
)
)
;
continue
;
}
const
int
MAX_CHAR_COUNT
=
256
;
DWORD
valueBufSize
=
MAX_CHAR_COUNT
*
sizeof
(
WCHAR
)
;
WCHAR
name
[
MAX_CHAR_COUNT
]
=
{
L
'
\
0
'
}
;
WCHAR
issuer
[
MAX_CHAR_COUNT
]
=
{
L
'
\
0
'
}
;
retCode
=
RegQueryValueExW
(
subKey
L
"
name
"
0
nullptr
(
LPBYTE
)
name
&
valueBufSize
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Could
not
obtain
name
from
registry
.
(
%
ld
)
"
retCode
)
)
;
RegCloseKey
(
subKey
)
;
continue
;
}
valueBufSize
=
MAX_CHAR_COUNT
*
sizeof
(
WCHAR
)
;
retCode
=
RegQueryValueExW
(
subKey
L
"
issuer
"
0
nullptr
(
LPBYTE
)
issuer
&
valueBufSize
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Could
not
obtain
issuer
from
registry
.
(
%
ld
)
"
retCode
)
)
;
RegCloseKey
(
subKey
)
;
continue
;
}
CertificateCheckInfo
allowedCertificate
=
{
name
issuer
}
;
retCode
=
CheckCertificateForPEFile
(
filePath
allowedCertificate
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Error
on
certificate
check
.
(
%
ld
)
"
retCode
)
)
;
RegCloseKey
(
subKey
)
;
continue
;
}
retCode
=
VerifyCertificateTrustForFile
(
filePath
)
;
if
(
retCode
!
=
ERROR_SUCCESS
)
{
LOG_WARN
(
(
"
Error
on
certificate
trust
check
.
(
%
ld
)
"
retCode
)
)
;
RegCloseKey
(
subKey
)
;
continue
;
}
RegCloseKey
(
baseKey
)
;
return
TRUE
;
}
RegCloseKey
(
baseKey
)
;
return
FALSE
;
}
