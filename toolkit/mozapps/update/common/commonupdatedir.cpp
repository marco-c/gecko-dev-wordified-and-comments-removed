#
include
<
cinttypes
>
#
include
<
cwchar
>
#
include
<
string
>
#
include
"
city
.
h
"
#
include
"
commonupdatedir
.
h
"
#
include
"
updatedefines
.
h
"
#
ifdef
XP_WIN
#
include
<
accctrl
.
h
>
#
include
<
aclapi
.
h
>
#
include
<
cstdarg
>
#
include
<
errno
.
h
>
#
include
<
objbase
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
shlobj
.
h
>
#
include
<
strsafe
.
h
>
#
include
<
winerror
.
h
>
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
updateutils_win
.
h
"
#
endif
#
ifdef
XP_WIN
#
define
OLD_ROOT_UPDATE_DIR_NAME
"
Mozilla
"
#
define
ROOT_UPDATE_DIR_NAME
"
Mozilla
-
1de4eec8
-
1241
-
4177
-
a864
-
e594e8d1fb38
"
#
define
UPDATE_PATH_MID_DIR_NAME
"
updates
"
enum
class
WhichUpdateDir
{
CurrentUpdateDir
UnmigratedUpdateDir
}
;
class
SimpleAutoString
{
private
:
size_t
mLength
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
mString
;
bool
AllocLen
(
size_t
len
)
{
mString
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
len
+
1
)
;
return
mString
.
get
(
)
!
=
nullptr
;
}
bool
AllocSize
(
size_t
size
)
{
mString
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
size
)
;
return
mString
.
get
(
)
!
=
nullptr
;
}
public
:
SimpleAutoString
(
)
:
mLength
(
0
)
{
}
bool
AllocEmpty
(
size_t
len
)
{
bool
success
=
AllocLen
(
len
)
;
Truncate
(
)
;
return
success
;
}
wchar_t
*
MutableString
(
)
{
return
mString
.
get
(
)
;
}
const
wchar_t
*
String
(
)
const
{
return
mString
.
get
(
)
;
}
size_t
Length
(
)
const
{
return
mLength
;
}
bool
Check
(
)
{
mLength
=
wcslen
(
mString
.
get
(
)
)
;
return
true
;
}
void
SwapBufferWith
(
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
other
)
{
mString
.
swap
(
other
)
;
if
(
mString
)
{
mLength
=
wcslen
(
mString
.
get
(
)
)
;
}
else
{
mLength
=
0
;
}
}
void
Swap
(
SimpleAutoString
&
other
)
{
mString
.
swap
(
other
.
mString
)
;
size_t
newLength
=
other
.
mLength
;
other
.
mLength
=
mLength
;
mLength
=
newLength
;
}
void
Truncate
(
size_t
len
=
0
)
{
if
(
len
>
mLength
)
{
return
;
}
mLength
=
len
;
if
(
mString
)
{
mString
.
get
(
)
[
len
]
=
L
'
\
0
'
;
}
}
size_t
AssignSprintf
(
size_t
bufferSize
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
returnValue
=
AssignVsprintf
(
bufferSize
format
ap
)
;
va_end
(
ap
)
;
return
returnValue
;
}
size_t
AssignVsprintf
(
size_t
bufferSize
const
wchar_t
*
format
va_list
ap
)
{
if
(
!
mString
)
{
Truncate
(
)
;
return
0
;
}
int
charsWritten
=
vswprintf
(
mString
.
get
(
)
bufferSize
format
ap
)
;
if
(
charsWritten
<
0
|
|
static_cast
<
size_t
>
(
charsWritten
)
>
=
bufferSize
)
{
Truncate
(
)
;
return
0
;
}
mString
.
get
(
)
[
charsWritten
]
=
L
'
\
0
'
;
mLength
=
charsWritten
;
return
mLength
;
}
size_t
AllocAndAssignSprintf
(
size_t
maxLength
const
wchar_t
*
format
.
.
.
)
{
if
(
!
AllocLen
(
maxLength
)
)
{
Truncate
(
)
;
return
0
;
}
va_list
ap
;
va_start
(
ap
format
)
;
size_t
charsWritten
=
AssignVsprintf
(
maxLength
+
1
format
ap
)
;
va_end
(
ap
)
;
return
charsWritten
;
}
size_t
AllocFromScprintf
(
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
returnValue
=
AllocFromVscprintf
(
format
ap
)
;
va_end
(
ap
)
;
return
returnValue
;
}
size_t
AllocFromVscprintf
(
const
wchar_t
*
format
va_list
ap
)
{
int
len
=
_vscwprintf
(
format
ap
)
;
if
(
len
<
0
)
{
Truncate
(
)
;
return
0
;
}
if
(
!
AllocEmpty
(
len
)
)
{
return
0
;
}
return
len
;
}
size_t
AutoAllocAndAssignSprintf
(
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
len
=
AllocFromVscprintf
(
format
ap
)
;
va_end
(
ap
)
;
if
(
len
=
=
0
)
{
return
0
;
}
va_start
(
ap
format
)
;
size_t
charsWritten
=
AssignVsprintf
(
len
+
1
format
ap
)
;
va_end
(
ap
)
;
if
(
len
!
=
charsWritten
)
{
Truncate
(
)
;
return
0
;
}
return
charsWritten
;
}
HRESULT
CopyFrom
(
const
wchar_t
*
src
)
{
mLength
=
wcslen
(
src
)
;
if
(
!
AllocLen
(
mLength
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
HRESULT
hrv
=
StringCchCopyW
(
mString
.
get
(
)
mLength
+
1
src
)
;
if
(
FAILED
(
hrv
)
)
{
Truncate
(
)
;
}
return
hrv
;
}
HRESULT
CopyFrom
(
const
SimpleAutoString
&
src
)
{
if
(
!
src
.
mString
)
{
Truncate
(
)
;
return
S_OK
;
}
mLength
=
src
.
mLength
;
if
(
!
AllocLen
(
mLength
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
HRESULT
hrv
=
StringCchCopyW
(
mString
.
get
(
)
mLength
+
1
src
.
mString
.
get
(
)
)
;
if
(
FAILED
(
hrv
)
)
{
Truncate
(
)
;
}
return
hrv
;
}
HRESULT
CopyFrom
(
const
char
*
src
)
{
int
bufferSize
=
MultiByteToWideChar
(
CP_UTF8
MB_ERR_INVALID_CHARS
src
-
1
nullptr
0
)
;
if
(
bufferSize
=
=
0
)
{
Truncate
(
)
;
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
if
(
!
AllocSize
(
bufferSize
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
int
charsWritten
=
MultiByteToWideChar
(
CP_UTF8
MB_ERR_INVALID_CHARS
src
-
1
mString
.
get
(
)
bufferSize
)
;
if
(
charsWritten
=
=
0
)
{
Truncate
(
)
;
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
else
if
(
charsWritten
!
=
bufferSize
)
{
Truncate
(
)
;
return
E_FAIL
;
}
mLength
=
charsWritten
-
1
;
return
S_OK
;
}
bool
StartsWith
(
const
SimpleAutoString
&
prefix
)
const
{
if
(
!
mString
)
{
return
(
prefix
.
mLength
=
=
0
)
;
}
if
(
!
prefix
.
mString
)
{
return
true
;
}
if
(
prefix
.
mLength
>
mLength
)
{
return
false
;
}
return
(
wcsncmp
(
mString
.
get
(
)
prefix
.
mString
.
get
(
)
prefix
.
mLength
)
=
=
0
)
;
}
}
;
struct
CoTaskMemFreeDeleter
{
void
operator
(
)
(
void
*
aPtr
)
{
:
:
CoTaskMemFree
(
aPtr
)
;
}
}
;
struct
AutoPerms
{
SID_IDENTIFIER_AUTHORITY
sidIdentifierAuthority
;
UniqueSidPtr
usersSID
;
UniqueSidPtr
adminsSID
;
UniqueSidPtr
systemSID
;
EXPLICIT_ACCESS_W
ea
[
3
]
;
mozilla
:
:
UniquePtr
<
ACL
LocalFreeDeleter
>
acl
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
securityDescriptorBuffer
;
PSECURITY_DESCRIPTOR
securityDescriptor
;
SECURITY_ATTRIBUTES
securityAttributes
;
}
;
static
bool
GetCachedHash
(
const
char16_t
*
installPath
HKEY
rootKey
const
SimpleAutoString
&
regPath
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
)
;
static
HRESULT
GetUpdateDirectory
(
const
wchar_t
*
installPath
WhichUpdateDir
whichDir
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
;
static
HRESULT
GeneratePermissions
(
AutoPerms
&
result
)
;
static
HRESULT
MakeDir
(
const
SimpleAutoString
&
path
const
AutoPerms
&
perms
)
;
#
endif
bool
GetInstallHash
(
const
char16_t
*
installPath
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
)
{
MOZ_ASSERT
(
installPath
!
=
nullptr
"
Install
path
must
not
be
null
in
GetInstallHash
"
)
;
size_t
pathSize
=
std
:
:
char_traits
<
char16_t
>
:
:
length
(
installPath
)
*
sizeof
(
*
installPath
)
;
uint64_t
hash
=
CityHash64
(
reinterpret_cast
<
const
char
*
>
(
installPath
)
pathSize
)
;
size_t
hashStrSize
=
sizeof
(
hash
)
*
2
+
1
;
result
=
mozilla
:
:
MakeUnique
<
NS_tchar
[
]
>
(
hashStrSize
)
;
int
charsWritten
=
NS_tsnprintf
(
result
.
get
(
)
hashStrSize
NS_T
(
"
%
"
)
NS_T
(
PRIX64
)
hash
)
;
return
!
(
charsWritten
<
1
|
|
static_cast
<
size_t
>
(
charsWritten
)
>
hashStrSize
-
1
)
;
}
#
ifdef
XP_WIN
static
bool
GetCachedHash
(
const
char16_t
*
installPath
HKEY
rootKey
const
SimpleAutoString
&
regPath
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
)
{
unsigned
long
bufferSize
;
LSTATUS
lrv
=
RegGetValueW
(
rootKey
regPath
.
String
(
)
reinterpret_cast
<
const
wchar_t
*
>
(
installPath
)
RRF_RT_REG_SZ
nullptr
nullptr
&
bufferSize
)
;
if
(
lrv
!
=
ERROR_SUCCESS
)
{
return
false
;
}
result
=
mozilla
:
:
MakeUnique
<
NS_tchar
[
]
>
(
bufferSize
)
;
lrv
=
RegGetValueW
(
rootKey
regPath
.
String
(
)
reinterpret_cast
<
const
wchar_t
*
>
(
installPath
)
RRF_RT_REG_SZ
nullptr
result
.
get
(
)
&
bufferSize
)
;
return
(
lrv
=
=
ERROR_SUCCESS
)
;
}
HRESULT
GetCommonUpdateDirectory
(
const
wchar_t
*
installPath
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
return
GetUpdateDirectory
(
installPath
WhichUpdateDir
:
:
CurrentUpdateDir
result
)
;
}
HRESULT
GetOldUpdateDirectory
(
const
wchar_t
*
installPath
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
return
GetUpdateDirectory
(
installPath
WhichUpdateDir
:
:
UnmigratedUpdateDir
result
)
;
}
extern
"
C
"
HRESULT
get_common_update_directory
(
const
wchar_t
*
installPath
wchar_t
*
result
)
{
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
uniqueResult
;
HRESULT
hr
=
GetCommonUpdateDirectory
(
installPath
uniqueResult
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
return
StringCchCopyW
(
result
MAX_PATH
+
1
uniqueResult
.
get
(
)
)
;
}
static
HRESULT
GetUpdateDirectory
(
const
wchar_t
*
installPath
WhichUpdateDir
whichDir
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
MOZ_ASSERT
(
installPath
!
=
nullptr
"
Install
path
must
not
be
null
in
GetUpdateDirectory
"
)
;
AutoPerms
perms
;
HRESULT
hrv
=
GeneratePermissions
(
perms
)
;
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
PWSTR
baseDirParentPath
;
hrv
=
SHGetKnownFolderPath
(
FOLDERID_ProgramData
KF_FLAG_CREATE
nullptr
&
baseDirParentPath
)
;
mozilla
:
:
UniquePtr
<
wchar_t
CoTaskMemFreeDeleter
>
baseDirParentPathUnique
(
baseDirParentPath
)
;
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
SimpleAutoString
baseDir
;
if
(
whichDir
=
=
WhichUpdateDir
:
:
UnmigratedUpdateDir
)
{
const
wchar_t
baseDirLiteral
[
]
=
NS_T
(
OLD_ROOT_UPDATE_DIR_NAME
)
;
hrv
=
baseDir
.
CopyFrom
(
baseDirLiteral
)
;
}
else
{
const
wchar_t
baseDirLiteral
[
]
=
NS_T
(
ROOT_UPDATE_DIR_NAME
)
;
hrv
=
baseDir
.
CopyFrom
(
baseDirLiteral
)
;
}
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
SimpleAutoString
basePath
;
size_t
basePathLen
=
wcslen
(
baseDirParentPath
)
+
1
+
baseDir
.
Length
(
)
;
basePath
.
AllocAndAssignSprintf
(
basePathLen
L
"
%
s
\
\
%
s
"
baseDirParentPath
baseDir
.
String
(
)
)
;
if
(
basePath
.
Length
(
)
!
=
basePathLen
)
{
return
E_FAIL
;
}
if
(
whichDir
=
=
WhichUpdateDir
:
:
CurrentUpdateDir
)
{
hrv
=
MakeDir
(
basePath
perms
)
;
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
}
const
wchar_t
midPathDirName
[
]
=
NS_T
(
UPDATE_PATH_MID_DIR_NAME
)
;
size_t
midPathLen
=
basePath
.
Length
(
)
+
1
+
wcslen
(
midPathDirName
)
;
SimpleAutoString
midPath
;
midPath
.
AllocAndAssignSprintf
(
midPathLen
L
"
%
s
\
\
%
s
"
basePath
.
String
(
)
midPathDirName
)
;
if
(
midPath
.
Length
(
)
!
=
midPathLen
)
{
return
E_FAIL
;
}
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
hash
;
bool
gotHash
=
false
;
SimpleAutoString
regPath
;
regPath
.
AutoAllocAndAssignSprintf
(
L
"
SOFTWARE
\
\
Mozilla
\
\
%
S
\
\
TaskBarIDs
"
MOZ_APP_BASENAME
)
;
if
(
regPath
.
Length
(
)
!
=
0
)
{
gotHash
=
GetCachedHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
HKEY_LOCAL_MACHINE
regPath
hash
)
;
if
(
!
gotHash
)
{
gotHash
=
GetCachedHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
HKEY_CURRENT_USER
regPath
hash
)
;
}
}
if
(
!
gotHash
)
{
bool
success
=
GetInstallHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
hash
)
;
if
(
!
success
)
{
return
E_FAIL
;
}
}
size_t
updatePathLen
=
midPath
.
Length
(
)
+
1
+
wcslen
(
hash
.
get
(
)
)
;
SimpleAutoString
updatePath
;
updatePath
.
AllocAndAssignSprintf
(
updatePathLen
L
"
%
s
\
\
%
s
"
midPath
.
String
(
)
hash
.
get
(
)
)
;
if
(
updatePath
.
Length
(
)
!
=
updatePathLen
)
{
return
E_FAIL
;
}
updatePath
.
SwapBufferWith
(
result
)
;
return
S_OK
;
}
static
HRESULT
GeneratePermissions
(
AutoPerms
&
result
)
{
result
.
sidIdentifierAuthority
=
SECURITY_NT_AUTHORITY
;
ZeroMemory
(
&
result
.
ea
sizeof
(
result
.
ea
)
)
;
PSID
usersSID
=
nullptr
;
BOOL
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
2
SECURITY_BUILTIN_DOMAIN_RID
DOMAIN_ALIAS_RID_USERS
0
0
0
0
0
0
&
usersSID
)
;
result
.
usersSID
.
reset
(
usersSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
0
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
0
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
0
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
0
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
0
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_GROUP
;
result
.
ea
[
0
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
usersSID
)
;
PSID
adminsSID
=
nullptr
;
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
2
SECURITY_BUILTIN_DOMAIN_RID
DOMAIN_ALIAS_RID_ADMINS
0
0
0
0
0
0
&
adminsSID
)
;
result
.
adminsSID
.
reset
(
adminsSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
1
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
1
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
1
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
1
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
1
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_GROUP
;
result
.
ea
[
1
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
adminsSID
)
;
PSID
systemSID
=
nullptr
;
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
1
SECURITY_LOCAL_SYSTEM_RID
0
0
0
0
0
0
0
&
systemSID
)
;
result
.
systemSID
.
reset
(
systemSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
2
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
2
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
2
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
2
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
2
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_USER
;
result
.
ea
[
2
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
systemSID
)
;
PACL
acl
=
nullptr
;
DWORD
drv
=
SetEntriesInAclW
(
3
result
.
ea
nullptr
&
acl
)
;
result
.
acl
.
reset
(
acl
)
;
if
(
drv
!
=
ERROR_SUCCESS
)
{
return
HRESULT_FROM_WIN32
(
drv
)
;
}
result
.
securityDescriptorBuffer
=
mozilla
:
:
MakeUnique
<
uint8_t
[
]
>
(
SECURITY_DESCRIPTOR_MIN_LENGTH
)
;
if
(
!
result
.
securityDescriptorBuffer
)
{
return
E_OUTOFMEMORY
;
}
result
.
securityDescriptor
=
reinterpret_cast
<
PSECURITY_DESCRIPTOR
>
(
result
.
securityDescriptorBuffer
.
get
(
)
)
;
success
=
InitializeSecurityDescriptor
(
result
.
securityDescriptor
SECURITY_DESCRIPTOR_REVISION
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
success
=
SetSecurityDescriptorDacl
(
result
.
securityDescriptor
TRUE
acl
FALSE
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
securityAttributes
.
nLength
=
sizeof
(
SECURITY_ATTRIBUTES
)
;
result
.
securityAttributes
.
lpSecurityDescriptor
=
result
.
securityDescriptor
;
result
.
securityAttributes
.
bInheritHandle
=
FALSE
;
return
S_OK
;
}
static
HRESULT
MakeDir
(
const
SimpleAutoString
&
path
const
AutoPerms
&
perms
)
{
BOOL
success
=
CreateDirectoryW
(
path
.
String
(
)
const_cast
<
LPSECURITY_ATTRIBUTES
>
(
&
perms
.
securityAttributes
)
)
;
if
(
success
)
{
return
S_OK
;
}
DWORD
error
=
GetLastError
(
)
;
if
(
error
=
=
ERROR_ALREADY_EXISTS
)
{
return
S_OK
;
}
return
HRESULT_FROM_WIN32
(
error
)
;
}
#
endif
