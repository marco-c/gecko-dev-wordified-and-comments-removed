#
include
<
cinttypes
>
#
include
<
cwchar
>
#
include
<
string
>
#
include
"
city
.
h
"
#
include
"
commonupdatedir
.
h
"
#
include
"
updatedefines
.
h
"
#
ifdef
XP_WIN
#
include
<
accctrl
.
h
>
#
include
<
aclapi
.
h
>
#
include
<
cstdarg
>
#
include
<
errno
.
h
>
#
include
<
objbase
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
shlobj
.
h
>
#
include
<
strsafe
.
h
>
#
include
<
winerror
.
h
>
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
win_dirent
.
h
"
#
endif
#
ifdef
XP_WIN
#
define
FALLBACK_VENDOR_NAME
"
Mozilla
"
#
define
UPDATE_PATH_MID_DIR_NAME
"
updates
"
#
define
UPDATE_SUBDIRECTORY
"
updates
"
#
define
PATCH_DIRECTORY
"
0
"
enum
class
WhichUpdateDir
{
CommonAppData
UserAppData
}
;
class
SimpleAutoString
{
private
:
size_t
mLength
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
mString
;
bool
AllocLen
(
size_t
len
)
{
mString
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
len
+
1
)
;
return
mString
.
get
(
)
!
=
nullptr
;
}
bool
AllocSize
(
size_t
size
)
{
mString
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
size
)
;
return
mString
.
get
(
)
!
=
nullptr
;
}
public
:
SimpleAutoString
(
)
:
mLength
(
0
)
{
}
bool
AllocEmpty
(
size_t
len
)
{
bool
success
=
AllocLen
(
len
)
;
Truncate
(
)
;
return
success
;
}
wchar_t
*
MutableString
(
)
{
return
mString
.
get
(
)
;
}
const
wchar_t
*
String
(
)
const
{
return
mString
.
get
(
)
;
}
size_t
Length
(
)
const
{
return
mLength
;
}
void
SwapBufferWith
(
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
other
)
{
mString
.
swap
(
other
)
;
if
(
mString
)
{
mLength
=
wcslen
(
mString
.
get
(
)
)
;
}
else
{
mLength
=
0
;
}
}
void
Truncate
(
)
{
mLength
=
0
;
if
(
mString
)
{
mString
.
get
(
)
[
0
]
=
L
'
\
0
'
;
}
}
size_t
AssignSprintf
(
size_t
bufferSize
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
returnValue
=
AssignVsprintf
(
bufferSize
format
ap
)
;
va_end
(
ap
)
;
return
returnValue
;
}
size_t
AssignVsprintf
(
size_t
bufferSize
const
wchar_t
*
format
va_list
ap
)
{
if
(
!
mString
)
{
Truncate
(
)
;
return
0
;
}
int
charsWritten
=
vswprintf
(
mString
.
get
(
)
bufferSize
format
ap
)
;
if
(
charsWritten
<
0
|
|
static_cast
<
size_t
>
(
charsWritten
)
>
=
bufferSize
)
{
Truncate
(
)
;
return
0
;
}
mString
.
get
(
)
[
charsWritten
]
=
L
'
\
0
'
;
mLength
=
charsWritten
;
return
mLength
;
}
size_t
AllocAndAssignSprintf
(
size_t
maxLength
const
wchar_t
*
format
.
.
.
)
{
if
(
!
AllocLen
(
maxLength
)
)
{
Truncate
(
)
;
return
0
;
}
va_list
ap
;
va_start
(
ap
format
)
;
size_t
charsWritten
=
AssignVsprintf
(
maxLength
+
1
format
ap
)
;
va_end
(
ap
)
;
return
charsWritten
;
}
size_t
AllocFromScprintf
(
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
returnValue
=
AllocFromVscprintf
(
format
ap
)
;
va_end
(
ap
)
;
return
returnValue
;
}
size_t
AllocFromVscprintf
(
const
wchar_t
*
format
va_list
ap
)
{
int
len
=
_vscwprintf
(
format
ap
)
;
if
(
len
<
0
)
{
Truncate
(
)
;
return
0
;
}
if
(
!
AllocEmpty
(
len
)
)
{
return
0
;
}
return
len
;
}
size_t
AutoAllocAndAssignSprintf
(
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
len
=
AllocFromVscprintf
(
format
ap
)
;
va_end
(
ap
)
;
if
(
len
=
=
0
)
{
return
0
;
}
va_start
(
ap
format
)
;
size_t
charsWritten
=
AssignVsprintf
(
len
+
1
format
ap
)
;
va_end
(
ap
)
;
if
(
len
!
=
charsWritten
)
{
Truncate
(
)
;
return
0
;
}
return
charsWritten
;
}
HRESULT
CopyFrom
(
const
wchar_t
*
src
)
{
mLength
=
wcslen
(
src
)
;
if
(
!
AllocLen
(
mLength
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
HRESULT
hrv
=
StringCchCopyW
(
mString
.
get
(
)
mLength
+
1
src
)
;
if
(
FAILED
(
hrv
)
)
{
Truncate
(
)
;
}
return
hrv
;
}
HRESULT
CopyFrom
(
const
SimpleAutoString
&
src
)
{
if
(
!
src
.
mString
)
{
Truncate
(
)
;
return
S_OK
;
}
mLength
=
src
.
mLength
;
if
(
!
AllocLen
(
mLength
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
HRESULT
hrv
=
StringCchCopyW
(
mString
.
get
(
)
mLength
+
1
src
.
mString
.
get
(
)
)
;
if
(
FAILED
(
hrv
)
)
{
Truncate
(
)
;
}
return
hrv
;
}
HRESULT
CopyFrom
(
const
char
*
src
)
{
int
bufferSize
=
MultiByteToWideChar
(
CP_UTF8
MB_ERR_INVALID_CHARS
src
-
1
nullptr
0
)
;
if
(
bufferSize
=
=
0
)
{
Truncate
(
)
;
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
if
(
!
AllocSize
(
bufferSize
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
int
charsWritten
=
MultiByteToWideChar
(
CP_UTF8
MB_ERR_INVALID_CHARS
src
-
1
mString
.
get
(
)
bufferSize
)
;
if
(
charsWritten
=
=
0
)
{
Truncate
(
)
;
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
else
if
(
charsWritten
!
=
bufferSize
)
{
Truncate
(
)
;
return
E_FAIL
;
}
mLength
=
charsWritten
-
1
;
return
S_OK
;
}
bool
StartsWith
(
const
SimpleAutoString
&
prefix
)
const
{
if
(
!
mString
)
{
return
(
prefix
.
mLength
=
=
0
)
;
}
if
(
!
prefix
.
mString
)
{
return
true
;
}
if
(
prefix
.
mLength
>
mLength
)
{
return
false
;
}
return
(
wcsncmp
(
mString
.
get
(
)
prefix
.
mString
.
get
(
)
prefix
.
mLength
)
=
=
0
)
;
}
}
;
struct
CoTaskMemFreeDeleter
{
void
operator
(
)
(
void
*
aPtr
)
{
:
:
CoTaskMemFree
(
aPtr
)
;
}
}
;
struct
AutoPerms
{
SID_IDENTIFIER_AUTHORITY
sidIdentifierAuthority
;
nsAutoSid
usersSID
;
nsAutoSid
adminsSID
;
nsAutoSid
systemSID
;
EXPLICIT_ACCESS_W
ea
[
3
]
;
mozilla
:
:
UniquePtr
<
ACL
LocalFreeDeleter
>
acl
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
securityDescriptorBuffer
;
PSECURITY_DESCRIPTOR
securityDescriptor
;
SECURITY_ATTRIBUTES
securityAttributes
;
}
;
static
bool
GetCachedHash
(
const
char16_t
*
installPath
HKEY
rootKey
const
SimpleAutoString
&
regPath
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
)
;
static
HRESULT
GetUpdateDirectory
(
const
wchar_t
*
installPath
const
char
*
vendor
const
char
*
appName
WhichUpdateDir
whichDir
SetPermissionsOf
permsToSet
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
;
static
HRESULT
SetUpdateDirectoryPermissions
(
const
SimpleAutoString
&
basePath
const
SimpleAutoString
&
updatePath
bool
fullUpdatePath
SetPermissionsOf
permsToSet
)
;
static
HRESULT
GeneratePermissions
(
AutoPerms
&
result
)
;
static
HRESULT
SetPathPerms
(
SimpleAutoString
&
path
const
AutoPerms
&
perms
)
;
static
HRESULT
MoveConflicting
(
const
SimpleAutoString
&
path
)
;
static
HRESULT
SetPermissionsOfContents
(
const
SimpleAutoString
&
basePath
const
SimpleAutoString
&
leafUpdateDir
const
AutoPerms
&
perms
)
;
static
bool
PathConflictsWithLeaf
(
const
SimpleAutoString
&
path
DWORD
pathAttributes
bool
permsSuccessfullySet
const
SimpleAutoString
&
leafPath
)
;
#
endif
nsresult
GetInstallHash
(
const
char16_t
*
installPath
const
char
*
vendor
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
bool
useCompatibilityMode
)
{
MOZ_ASSERT
(
installPath
!
=
nullptr
"
Install
path
must
not
be
null
in
GetInstallHash
"
)
;
size_t
pathSize
=
std
:
:
char_traits
<
char16_t
>
:
:
length
(
installPath
)
*
sizeof
(
*
installPath
)
;
uint64_t
hash
=
CityHash64
(
reinterpret_cast
<
const
char
*
>
(
installPath
)
pathSize
)
;
size_t
hashStrSize
=
sizeof
(
hash
)
*
2
+
1
;
result
=
mozilla
:
:
MakeUnique
<
NS_tchar
[
]
>
(
hashStrSize
)
;
int
charsWritten
;
if
(
useCompatibilityMode
)
{
charsWritten
=
NS_tsnprintf
(
result
.
get
(
)
hashStrSize
NS_T
(
"
%
"
)
NS_T
(
PRIX32
)
NS_T
(
"
%
"
)
NS_T
(
PRIX32
)
static_cast
<
uint32_t
>
(
hash
>
>
32
)
static_cast
<
uint32_t
>
(
hash
)
)
;
}
else
{
charsWritten
=
NS_tsnprintf
(
result
.
get
(
)
hashStrSize
NS_T
(
"
%
"
)
NS_T
(
PRIX64
)
hash
)
;
}
if
(
charsWritten
<
1
|
|
static_cast
<
size_t
>
(
charsWritten
)
>
hashStrSize
-
1
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
#
ifdef
XP_WIN
static
bool
GetCachedHash
(
const
char16_t
*
installPath
HKEY
rootKey
const
SimpleAutoString
&
regPath
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
)
{
unsigned
long
bufferSize
;
LSTATUS
lrv
=
RegGetValueW
(
rootKey
regPath
.
String
(
)
reinterpret_cast
<
const
wchar_t
*
>
(
installPath
)
RRF_RT_REG_SZ
nullptr
nullptr
&
bufferSize
)
;
if
(
lrv
!
=
ERROR_SUCCESS
)
{
return
false
;
}
result
=
mozilla
:
:
MakeUnique
<
NS_tchar
[
]
>
(
bufferSize
)
;
if
(
!
result
)
{
return
false
;
}
lrv
=
RegGetValueW
(
rootKey
regPath
.
String
(
)
reinterpret_cast
<
const
wchar_t
*
>
(
installPath
)
RRF_RT_REG_SZ
nullptr
result
.
get
(
)
&
bufferSize
)
;
return
(
lrv
=
=
ERROR_SUCCESS
)
;
}
HRESULT
GetCommonUpdateDirectory
(
const
wchar_t
*
installPath
SetPermissionsOf
permsToSet
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
return
GetUpdateDirectory
(
installPath
nullptr
nullptr
WhichUpdateDir
:
:
CommonAppData
permsToSet
result
)
;
}
HRESULT
GetUserUpdateDirectory
(
const
wchar_t
*
installPath
const
char
*
vendor
const
char
*
appName
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
return
GetUpdateDirectory
(
installPath
vendor
appName
WhichUpdateDir
:
:
UserAppData
SetPermissionsOf
:
:
BaseDir
result
)
;
}
static
HRESULT
GetUpdateDirectory
(
const
wchar_t
*
installPath
const
char
*
vendor
const
char
*
appName
WhichUpdateDir
whichDir
SetPermissionsOf
permsToSet
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
PWSTR
baseDirParentPath
;
REFKNOWNFOLDERID
folderID
=
(
whichDir
=
=
WhichUpdateDir
:
:
CommonAppData
)
?
FOLDERID_ProgramData
:
FOLDERID_LocalAppData
;
HRESULT
hrv
=
SHGetKnownFolderPath
(
folderID
KF_FLAG_CREATE
nullptr
&
baseDirParentPath
)
;
mozilla
:
:
UniquePtr
<
wchar_t
CoTaskMemFreeDeleter
>
baseDirParentPathUnique
(
baseDirParentPath
)
;
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
SimpleAutoString
baseDir
;
if
(
whichDir
=
=
WhichUpdateDir
:
:
UserAppData
&
&
(
vendor
|
|
appName
)
)
{
const
char
*
rawBaseDir
=
vendor
?
vendor
:
appName
;
hrv
=
baseDir
.
CopyFrom
(
rawBaseDir
)
;
}
else
{
const
wchar_t
baseDirLiteral
[
]
=
NS_T
(
FALLBACK_VENDOR_NAME
)
;
hrv
=
baseDir
.
CopyFrom
(
baseDirLiteral
)
;
}
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
SimpleAutoString
basePath
;
size_t
basePathLen
=
wcslen
(
baseDirParentPath
)
+
1
+
baseDir
.
Length
(
)
;
basePath
.
AllocAndAssignSprintf
(
basePathLen
L
"
%
s
\
\
%
s
"
baseDirParentPath
baseDir
.
String
(
)
)
;
if
(
basePath
.
Length
(
)
!
=
basePathLen
)
{
return
E_FAIL
;
}
SimpleAutoString
updatePath
;
if
(
installPath
)
{
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
hash
;
bool
gotHash
=
false
;
SimpleAutoString
regPath
;
regPath
.
AutoAllocAndAssignSprintf
(
L
"
SOFTWARE
\
\
%
S
\
\
%
S
\
\
TaskBarIDs
"
vendor
?
vendor
:
"
Mozilla
"
MOZ_APP_BASENAME
)
;
if
(
regPath
.
Length
(
)
!
=
0
)
{
gotHash
=
GetCachedHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
HKEY_LOCAL_MACHINE
regPath
hash
)
;
if
(
!
gotHash
)
{
gotHash
=
GetCachedHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
HKEY_CURRENT_USER
regPath
hash
)
;
}
}
nsresult
rv
=
NS_OK
;
if
(
!
gotHash
)
{
bool
useCompatibilityMode
=
(
whichDir
=
=
WhichUpdateDir
:
:
UserAppData
)
;
rv
=
GetInstallHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
vendor
hash
useCompatibilityMode
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
const
wchar_t
midPathDirName
[
]
=
NS_T
(
UPDATE_PATH_MID_DIR_NAME
)
;
size_t
updatePathLen
=
basePath
.
Length
(
)
+
1
+
wcslen
(
midPathDirName
)
+
1
+
wcslen
(
hash
.
get
(
)
)
;
updatePath
.
AllocAndAssignSprintf
(
updatePathLen
L
"
%
s
\
\
%
s
\
\
%
s
"
basePath
.
String
(
)
midPathDirName
hash
.
get
(
)
)
;
}
}
if
(
whichDir
=
=
WhichUpdateDir
:
:
CommonAppData
)
{
if
(
updatePath
.
Length
(
)
>
0
)
{
hrv
=
SetUpdateDirectoryPermissions
(
basePath
updatePath
true
permsToSet
)
;
}
else
{
hrv
=
SetUpdateDirectoryPermissions
(
basePath
basePath
false
permsToSet
)
;
}
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
}
if
(
!
installPath
)
{
basePath
.
SwapBufferWith
(
result
)
;
return
S_OK
;
}
if
(
updatePath
.
Length
(
)
=
=
0
)
{
return
E_FAIL
;
}
updatePath
.
SwapBufferWith
(
result
)
;
return
S_OK
;
}
static
HRESULT
SetUpdateDirectoryPermissions
(
const
SimpleAutoString
&
basePath
const
SimpleAutoString
&
updatePath
bool
fullUpdatePath
SetPermissionsOf
permsToSet
)
{
HRESULT
returnValue
=
S_OK
;
DWORD
attributes
=
GetFileAttributesW
(
basePath
.
String
(
)
)
;
bool
validBaseDir
=
attributes
!
=
INVALID_FILE_ATTRIBUTES
&
&
attributes
&
FILE_ATTRIBUTE_DIRECTORY
&
&
!
(
attributes
&
FILE_ATTRIBUTE_REPARSE_POINT
)
;
if
(
permsToSet
=
=
SetPermissionsOf
:
:
BaseDirIfNotExists
&
&
validBaseDir
)
{
return
S_OK
;
}
AutoPerms
perms
;
HRESULT
hrv
=
GeneratePermissions
(
perms
)
;
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
SimpleAutoString
mutableBasePath
;
mutableBasePath
.
CopyFrom
(
basePath
)
;
if
(
mutableBasePath
.
Length
(
)
=
=
0
)
{
if
(
validBaseDir
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_OUTOFMEMORY
;
}
}
else
{
hrv
=
SetPathPerms
(
mutableBasePath
perms
)
;
if
(
FAILED
(
hrv
)
)
{
validBaseDir
=
false
;
}
}
if
(
!
validBaseDir
)
{
MoveConflicting
(
basePath
)
;
BOOL
success
=
CreateDirectoryW
(
basePath
.
String
(
)
&
perms
.
securityAttributes
)
;
if
(
success
)
{
return
returnValue
;
}
else
{
DWORD
error
=
GetLastError
(
)
;
if
(
error
!
=
ERROR_ALREADY_EXISTS
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
error
)
;
}
else
{
attributes
=
GetFileAttributesW
(
basePath
.
String
(
)
)
;
if
(
attributes
=
=
INVALID_FILE_ATTRIBUTES
|
|
!
(
attributes
&
FILE_ATTRIBUTE_DIRECTORY
)
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
error
)
;
}
else
if
(
permsToSet
!
=
SetPermissionsOf
:
:
BaseDirIfNotExists
)
{
mutableBasePath
.
CopyFrom
(
basePath
)
;
if
(
mutableBasePath
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_OUTOFMEMORY
;
}
else
{
hrv
=
SetPathPerms
(
mutableBasePath
perms
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
}
}
}
}
}
if
(
permsToSet
!
=
SetPermissionsOf
:
:
AllFilesAndDirs
)
{
return
returnValue
;
}
if
(
fullUpdatePath
)
{
SimpleAutoString
leafDirPath
;
wchar_t
updateSubdirectoryName
[
]
=
NS_T
(
UPDATE_SUBDIRECTORY
)
;
wchar_t
patchDirectoryName
[
]
=
NS_T
(
PATCH_DIRECTORY
)
;
size_t
leafDirLen
=
updatePath
.
Length
(
)
+
wcslen
(
updateSubdirectoryName
)
+
wcslen
(
patchDirectoryName
)
+
2
;
leafDirPath
.
AllocAndAssignSprintf
(
leafDirLen
L
"
%
s
\
\
%
s
\
\
%
s
"
updatePath
.
String
(
)
updateSubdirectoryName
patchDirectoryName
)
;
if
(
leafDirPath
.
Length
(
)
=
=
leafDirLen
)
{
hrv
=
SetPermissionsOfContents
(
basePath
leafDirPath
perms
)
;
}
else
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
hrv
=
SetPermissionsOfContents
(
basePath
updatePath
perms
)
;
}
}
else
{
hrv
=
SetPermissionsOfContents
(
basePath
updatePath
perms
)
;
}
return
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
}
static
HRESULT
GeneratePermissions
(
AutoPerms
&
result
)
{
result
.
sidIdentifierAuthority
=
SECURITY_NT_AUTHORITY
;
ZeroMemory
(
&
result
.
ea
sizeof
(
result
.
ea
)
)
;
PSID
usersSID
=
nullptr
;
BOOL
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
2
SECURITY_BUILTIN_DOMAIN_RID
DOMAIN_ALIAS_RID_USERS
0
0
0
0
0
0
&
usersSID
)
;
result
.
usersSID
.
own
(
usersSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
0
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
0
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
0
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
0
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
0
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_GROUP
;
result
.
ea
[
0
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
usersSID
)
;
PSID
adminsSID
=
nullptr
;
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
2
SECURITY_BUILTIN_DOMAIN_RID
DOMAIN_ALIAS_RID_ADMINS
0
0
0
0
0
0
&
adminsSID
)
;
result
.
adminsSID
.
own
(
adminsSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
1
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
1
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
1
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
1
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
1
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_GROUP
;
result
.
ea
[
1
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
adminsSID
)
;
PSID
systemSID
=
nullptr
;
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
1
SECURITY_LOCAL_SYSTEM_RID
0
0
0
0
0
0
0
&
systemSID
)
;
result
.
systemSID
.
own
(
systemSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
2
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
2
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
2
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
2
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
2
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_USER
;
result
.
ea
[
2
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
systemSID
)
;
PACL
acl
=
nullptr
;
DWORD
drv
=
SetEntriesInAclW
(
3
result
.
ea
nullptr
&
acl
)
;
result
.
acl
.
reset
(
acl
)
;
if
(
drv
!
=
ERROR_SUCCESS
)
{
return
HRESULT_FROM_WIN32
(
drv
)
;
}
result
.
securityDescriptorBuffer
=
mozilla
:
:
MakeUnique
<
uint8_t
[
]
>
(
SECURITY_DESCRIPTOR_MIN_LENGTH
)
;
if
(
!
result
.
securityDescriptorBuffer
)
{
return
E_OUTOFMEMORY
;
}
result
.
securityDescriptor
=
reinterpret_cast
<
PSECURITY_DESCRIPTOR
>
(
result
.
securityDescriptorBuffer
.
get
(
)
)
;
success
=
InitializeSecurityDescriptor
(
result
.
securityDescriptor
SECURITY_DESCRIPTOR_REVISION
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
success
=
SetSecurityDescriptorDacl
(
result
.
securityDescriptor
TRUE
acl
FALSE
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
securityAttributes
.
nLength
=
sizeof
(
SECURITY_ATTRIBUTES
)
;
result
.
securityAttributes
.
lpSecurityDescriptor
=
result
.
securityDescriptor
;
result
.
securityAttributes
.
bInheritHandle
=
FALSE
;
return
S_OK
;
}
static
HRESULT
SetPathPerms
(
SimpleAutoString
&
path
const
AutoPerms
&
perms
)
{
DWORD
drv
=
SetNamedSecurityInfoW
(
path
.
MutableString
(
)
SE_FILE_OBJECT
DACL_SECURITY_INFORMATION
nullptr
nullptr
perms
.
acl
.
get
(
)
nullptr
)
;
return
HRESULT_FROM_WIN32
(
drv
)
;
}
static
HRESULT
RemoveRecursive
(
const
SimpleAutoString
&
path
)
{
DWORD
attributes
=
GetFileAttributesW
(
path
.
String
(
)
)
;
if
(
attributes
=
=
INVALID_FILE_ATTRIBUTES
)
{
SetFileAttributesW
(
path
.
String
(
)
FILE_ATTRIBUTE_NORMAL
)
;
}
else
if
(
attributes
&
FILE_ATTRIBUTE_READONLY
)
{
SetFileAttributesW
(
path
.
String
(
)
attributes
&
~
FILE_ATTRIBUTE_READONLY
)
;
}
SimpleAutoString
pathList
;
pathList
.
AllocAndAssignSprintf
(
path
.
Length
(
)
+
1
L
"
%
s
\
0
"
path
.
String
(
)
)
;
SHFILEOPSTRUCTW
fileOperation
;
fileOperation
.
hwnd
=
nullptr
;
fileOperation
.
wFunc
=
FO_DELETE
;
fileOperation
.
pFrom
=
pathList
.
String
(
)
;
fileOperation
.
pTo
=
nullptr
;
fileOperation
.
fFlags
=
FOF_ALLOWUNDO
|
FOF_NO_UI
;
fileOperation
.
lpszProgressTitle
=
nullptr
;
int
rv
=
SHFileOperationW
(
&
fileOperation
)
;
if
(
rv
!
=
0
&
&
rv
!
=
ERROR_FILE_NOT_FOUND
)
{
return
E_FAIL
;
}
return
S_OK
;
}
static
HRESULT
MoveConflicting
(
const
SimpleAutoString
&
path
)
{
SimpleAutoString
newPath
;
unsigned
int
maxTries
=
9
;
const
wchar_t
newPathFormat
[
]
=
L
"
%
s
.
bak
%
u
"
;
size_t
newPathMaxLength
=
newPath
.
AllocFromScprintf
(
newPathFormat
path
.
String
(
)
maxTries
)
;
if
(
newPathMaxLength
>
0
)
{
for
(
unsigned
int
suffix
=
0
;
suffix
<
=
maxTries
;
+
+
suffix
)
{
newPath
.
AssignSprintf
(
newPathMaxLength
+
1
newPathFormat
path
.
String
(
)
suffix
)
;
if
(
newPath
.
Length
(
)
=
=
0
)
{
break
;
}
BOOL
success
;
if
(
suffix
<
maxTries
)
{
success
=
MoveFileW
(
path
.
String
(
)
newPath
.
String
(
)
)
;
}
else
{
success
=
MoveFileExW
(
path
.
String
(
)
newPath
.
String
(
)
MOVEFILE_REPLACE_EXISTING
)
;
}
if
(
success
)
{
return
S_OK
;
}
DWORD
drv
=
GetLastError
(
)
;
if
(
drv
=
=
ERROR_FILE_NOT_FOUND
)
{
return
S_OK
;
}
if
(
drv
!
=
ERROR_ALREADY_EXISTS
)
{
break
;
}
}
}
return
RemoveRecursive
(
path
)
;
}
static
HRESULT
SetPermissionsOfContents
(
const
SimpleAutoString
&
basePath
const
SimpleAutoString
&
leafUpdateDir
const
AutoPerms
&
perms
)
{
HRESULT
returnValue
=
S_OK
;
SimpleAutoString
pathBuffer
;
if
(
!
pathBuffer
.
AllocEmpty
(
MAX_PATH
)
)
{
return
FAILED
(
returnValue
)
?
returnValue
:
E_OUTOFMEMORY
;
}
DIR
directoryHandle
(
basePath
.
String
(
)
)
;
errno
=
0
;
for
(
dirent
*
entry
=
readdir
(
&
directoryHandle
)
;
entry
;
entry
=
readdir
(
&
directoryHandle
)
)
{
if
(
wcscmp
(
entry
-
>
d_name
L
"
.
"
)
=
=
0
|
|
wcscmp
(
entry
-
>
d_name
L
"
.
.
"
)
=
=
0
)
{
continue
;
}
pathBuffer
.
AssignSprintf
(
MAX_PATH
+
1
L
"
%
s
\
\
%
s
"
basePath
.
String
(
)
entry
-
>
d_name
)
;
if
(
pathBuffer
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
ERROR_BUFFER_OVERFLOW
)
;
continue
;
}
HRESULT
hrv
=
SetPathPerms
(
pathBuffer
perms
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
bool
permsSuccessfullySet
=
SUCCEEDED
(
hrv
)
;
pathBuffer
.
AssignSprintf
(
MAX_PATH
+
1
L
"
%
s
\
\
%
s
"
basePath
.
String
(
)
entry
-
>
d_name
)
;
if
(
pathBuffer
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
ERROR_BUFFER_OVERFLOW
)
;
continue
;
}
DWORD
attributes
=
GetFileAttributesW
(
pathBuffer
.
String
(
)
)
;
if
(
attributes
=
=
INVALID_FILE_ATTRIBUTES
|
|
attributes
&
FILE_ATTRIBUTE_REPARSE_POINT
)
{
hrv
=
RemoveRecursive
(
pathBuffer
)
;
if
(
SUCCEEDED
(
hrv
)
)
{
continue
;
}
else
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
}
}
if
(
PathConflictsWithLeaf
(
pathBuffer
attributes
permsSuccessfullySet
leafUpdateDir
)
)
{
hrv
=
MoveConflicting
(
pathBuffer
)
;
if
(
SUCCEEDED
(
hrv
)
)
{
continue
;
}
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
}
if
(
attributes
!
=
INVALID_FILE_ATTRIBUTES
&
&
attributes
&
FILE_ATTRIBUTE_DIRECTORY
&
&
!
(
attributes
&
FILE_ATTRIBUTE_REPARSE_POINT
)
)
{
hrv
=
SetPermissionsOfContents
(
pathBuffer
leafUpdateDir
perms
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
}
errno
=
0
;
}
if
(
errno
!
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
}
return
returnValue
;
}
static
bool
PathConflictsWithLeaf
(
const
SimpleAutoString
&
path
DWORD
pathAttributes
bool
permsSuccessfullySet
const
SimpleAutoString
&
leafPath
)
{
if
(
pathAttributes
!
=
INVALID_FILE_ATTRIBUTES
&
&
pathAttributes
&
FILE_ATTRIBUTE_DIRECTORY
&
&
permsSuccessfullySet
)
{
return
false
;
}
if
(
!
leafPath
.
StartsWith
(
path
)
)
{
return
false
;
}
wchar_t
charAfterPath
=
leafPath
.
String
(
)
[
path
.
Length
(
)
]
;
return
(
charAfterPath
=
=
L
'
\
\
'
|
|
charAfterPath
=
=
L
'
\
0
'
)
;
}
#
endif
