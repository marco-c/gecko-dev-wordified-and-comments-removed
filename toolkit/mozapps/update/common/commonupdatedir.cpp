#
include
<
cinttypes
>
#
include
<
cwchar
>
#
include
<
string
>
#
include
"
city
.
h
"
#
include
"
commonupdatedir
.
h
"
#
include
"
updatedefines
.
h
"
#
ifdef
XP_WIN
#
include
<
accctrl
.
h
>
#
include
<
aclapi
.
h
>
#
include
<
cstdarg
>
#
include
<
errno
.
h
>
#
include
<
objbase
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
shlobj
.
h
>
#
include
<
strsafe
.
h
>
#
include
<
winerror
.
h
>
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
updateutils_win
.
h
"
#
endif
#
ifdef
XP_WIN
#
define
FALLBACK_VENDOR_NAME
"
Mozilla
"
#
define
UPDATE_PATH_MID_DIR_NAME
"
updates
"
#
define
UPDATE_SUBDIRECTORY
"
updates
"
#
define
PATCH_DIRECTORY
"
0
"
#
define
LOCK_FILE_PREFIX
"
mozlock
.
"
enum
class
WhichUpdateDir
{
CommonAppData
UserAppData
}
;
class
SimpleAutoString
{
private
:
size_t
mLength
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
mString
;
bool
AllocLen
(
size_t
len
)
{
mString
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
len
+
1
)
;
return
mString
.
get
(
)
!
=
nullptr
;
}
bool
AllocSize
(
size_t
size
)
{
mString
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
size
)
;
return
mString
.
get
(
)
!
=
nullptr
;
}
public
:
SimpleAutoString
(
)
:
mLength
(
0
)
{
}
bool
AllocEmpty
(
size_t
len
)
{
bool
success
=
AllocLen
(
len
)
;
Truncate
(
)
;
return
success
;
}
wchar_t
*
MutableString
(
)
{
return
mString
.
get
(
)
;
}
const
wchar_t
*
String
(
)
const
{
return
mString
.
get
(
)
;
}
size_t
Length
(
)
const
{
return
mLength
;
}
bool
Check
(
)
{
mLength
=
wcslen
(
mString
.
get
(
)
)
;
return
true
;
}
void
SwapBufferWith
(
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
other
)
{
mString
.
swap
(
other
)
;
if
(
mString
)
{
mLength
=
wcslen
(
mString
.
get
(
)
)
;
}
else
{
mLength
=
0
;
}
}
void
Swap
(
SimpleAutoString
&
other
)
{
mString
.
swap
(
other
.
mString
)
;
size_t
newLength
=
other
.
mLength
;
other
.
mLength
=
mLength
;
mLength
=
newLength
;
}
void
Truncate
(
size_t
len
=
0
)
{
if
(
len
>
mLength
)
{
return
;
}
mLength
=
len
;
if
(
mString
)
{
mString
.
get
(
)
[
len
]
=
L
'
\
0
'
;
}
}
size_t
AssignSprintf
(
size_t
bufferSize
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
returnValue
=
AssignVsprintf
(
bufferSize
format
ap
)
;
va_end
(
ap
)
;
return
returnValue
;
}
size_t
AssignVsprintf
(
size_t
bufferSize
const
wchar_t
*
format
va_list
ap
)
{
if
(
!
mString
)
{
Truncate
(
)
;
return
0
;
}
int
charsWritten
=
vswprintf
(
mString
.
get
(
)
bufferSize
format
ap
)
;
if
(
charsWritten
<
0
|
|
static_cast
<
size_t
>
(
charsWritten
)
>
=
bufferSize
)
{
Truncate
(
)
;
return
0
;
}
mString
.
get
(
)
[
charsWritten
]
=
L
'
\
0
'
;
mLength
=
charsWritten
;
return
mLength
;
}
size_t
AllocAndAssignSprintf
(
size_t
maxLength
const
wchar_t
*
format
.
.
.
)
{
if
(
!
AllocLen
(
maxLength
)
)
{
Truncate
(
)
;
return
0
;
}
va_list
ap
;
va_start
(
ap
format
)
;
size_t
charsWritten
=
AssignVsprintf
(
maxLength
+
1
format
ap
)
;
va_end
(
ap
)
;
return
charsWritten
;
}
size_t
AllocFromScprintf
(
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
returnValue
=
AllocFromVscprintf
(
format
ap
)
;
va_end
(
ap
)
;
return
returnValue
;
}
size_t
AllocFromVscprintf
(
const
wchar_t
*
format
va_list
ap
)
{
int
len
=
_vscwprintf
(
format
ap
)
;
if
(
len
<
0
)
{
Truncate
(
)
;
return
0
;
}
if
(
!
AllocEmpty
(
len
)
)
{
return
0
;
}
return
len
;
}
size_t
AutoAllocAndAssignSprintf
(
const
wchar_t
*
format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
format
)
;
size_t
len
=
AllocFromVscprintf
(
format
ap
)
;
va_end
(
ap
)
;
if
(
len
=
=
0
)
{
return
0
;
}
va_start
(
ap
format
)
;
size_t
charsWritten
=
AssignVsprintf
(
len
+
1
format
ap
)
;
va_end
(
ap
)
;
if
(
len
!
=
charsWritten
)
{
Truncate
(
)
;
return
0
;
}
return
charsWritten
;
}
HRESULT
CopyFrom
(
const
wchar_t
*
src
)
{
mLength
=
wcslen
(
src
)
;
if
(
!
AllocLen
(
mLength
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
HRESULT
hrv
=
StringCchCopyW
(
mString
.
get
(
)
mLength
+
1
src
)
;
if
(
FAILED
(
hrv
)
)
{
Truncate
(
)
;
}
return
hrv
;
}
HRESULT
CopyFrom
(
const
SimpleAutoString
&
src
)
{
if
(
!
src
.
mString
)
{
Truncate
(
)
;
return
S_OK
;
}
mLength
=
src
.
mLength
;
if
(
!
AllocLen
(
mLength
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
HRESULT
hrv
=
StringCchCopyW
(
mString
.
get
(
)
mLength
+
1
src
.
mString
.
get
(
)
)
;
if
(
FAILED
(
hrv
)
)
{
Truncate
(
)
;
}
return
hrv
;
}
HRESULT
CopyFrom
(
const
char
*
src
)
{
int
bufferSize
=
MultiByteToWideChar
(
CP_UTF8
MB_ERR_INVALID_CHARS
src
-
1
nullptr
0
)
;
if
(
bufferSize
=
=
0
)
{
Truncate
(
)
;
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
if
(
!
AllocSize
(
bufferSize
)
)
{
Truncate
(
)
;
return
E_OUTOFMEMORY
;
}
int
charsWritten
=
MultiByteToWideChar
(
CP_UTF8
MB_ERR_INVALID_CHARS
src
-
1
mString
.
get
(
)
bufferSize
)
;
if
(
charsWritten
=
=
0
)
{
Truncate
(
)
;
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
else
if
(
charsWritten
!
=
bufferSize
)
{
Truncate
(
)
;
return
E_FAIL
;
}
mLength
=
charsWritten
-
1
;
return
S_OK
;
}
bool
StartsWith
(
const
SimpleAutoString
&
prefix
)
const
{
if
(
!
mString
)
{
return
(
prefix
.
mLength
=
=
0
)
;
}
if
(
!
prefix
.
mString
)
{
return
true
;
}
if
(
prefix
.
mLength
>
mLength
)
{
return
false
;
}
return
(
wcsncmp
(
mString
.
get
(
)
prefix
.
mString
.
get
(
)
prefix
.
mLength
)
=
=
0
)
;
}
}
;
struct
CoTaskMemFreeDeleter
{
void
operator
(
)
(
void
*
aPtr
)
{
:
:
CoTaskMemFree
(
aPtr
)
;
}
}
;
struct
AutoPerms
{
SID_IDENTIFIER_AUTHORITY
sidIdentifierAuthority
;
UniqueSidPtr
usersSID
;
UniqueSidPtr
adminsSID
;
UniqueSidPtr
systemSID
;
EXPLICIT_ACCESS_W
ea
[
3
]
;
mozilla
:
:
UniquePtr
<
ACL
LocalFreeDeleter
>
acl
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
securityDescriptorBuffer
;
PSECURITY_DESCRIPTOR
securityDescriptor
;
SECURITY_ATTRIBUTES
securityAttributes
;
}
;
static
HRESULT
GetFilename
(
SimpleAutoString
&
path
SimpleAutoString
&
filename
)
;
enum
class
Tristate
{
False
True
Unknown
}
;
enum
class
Lockstate
{
Locked
Unlocked
}
;
class
FileOrDirectory
{
private
:
Tristate
mIsHardLink
;
DWORD
mAttributes
;
nsAutoHandle
mLockHandle
;
SimpleAutoString
mDirLockFilename
;
bool
Lock
(
const
wchar_t
*
path
)
{
mAttributes
=
GetFileAttributesW
(
path
)
;
Tristate
isDir
=
IsDirectory
(
)
;
if
(
isDir
=
=
Tristate
:
:
Unknown
)
{
return
false
;
}
if
(
isDir
=
=
Tristate
:
:
True
)
{
SimpleAutoString
lockPath
;
if
(
!
lockPath
.
AllocEmpty
(
MAX_PATH
)
)
{
return
false
;
}
BOOL
success
=
GetUUIDTempFilePath
(
path
NS_T
(
LOCK_FILE_PREFIX
)
lockPath
.
MutableString
(
)
)
;
if
(
!
success
|
|
!
lockPath
.
Check
(
)
)
{
return
false
;
}
HRESULT
hrv
=
GetFilename
(
lockPath
mDirLockFilename
)
;
if
(
FAILED
(
hrv
)
|
|
mDirLockFilename
.
Length
(
)
=
=
0
)
{
return
false
;
}
mLockHandle
.
own
(
CreateFileW
(
lockPath
.
String
(
)
0
0
nullptr
OPEN_ALWAYS
FILE_FLAG_DELETE_ON_CLOSE
nullptr
)
)
;
}
else
{
mLockHandle
.
own
(
CreateFileW
(
path
WRITE_DAC
|
READ_CONTROL
0
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
nullptr
)
)
;
}
if
(
!
IsLocked
(
)
)
{
return
false
;
}
mAttributes
=
GetFileAttributesW
(
path
)
;
if
(
isDir
!
=
IsDirectory
(
)
)
{
Unlock
(
)
;
return
false
;
}
return
true
;
}
void
NormalizeAccessMask
(
ACCESS_MASK
&
mask
)
{
if
(
(
mask
&
GENERIC_ALL
)
=
=
GENERIC_ALL
)
{
mask
&
=
~
GENERIC_ALL
;
mask
|
=
FILE_ALL_ACCESS
;
}
if
(
(
mask
&
GENERIC_READ
)
=
=
GENERIC_READ
)
{
mask
&
=
~
GENERIC_READ
;
mask
|
=
FILE_GENERIC_READ
;
}
if
(
(
mask
&
GENERIC_WRITE
)
=
=
GENERIC_WRITE
)
{
mask
&
=
~
GENERIC_WRITE
;
mask
|
=
FILE_GENERIC_WRITE
;
}
if
(
(
mask
&
GENERIC_EXECUTE
)
=
=
GENERIC_EXECUTE
)
{
mask
&
=
~
GENERIC_EXECUTE
;
mask
|
=
FILE_GENERIC_EXECUTE
;
}
}
public
:
FileOrDirectory
(
)
:
mIsHardLink
(
Tristate
:
:
Unknown
)
mAttributes
(
INVALID_FILE_ATTRIBUTES
)
mLockHandle
(
INVALID_HANDLE_VALUE
)
{
}
FileOrDirectory
(
const
SimpleAutoString
&
path
Lockstate
shouldLock
)
:
FileOrDirectory
(
)
{
Reset
(
path
shouldLock
)
;
}
void
Reset
(
const
SimpleAutoString
&
path
Lockstate
shouldLock
)
{
Unlock
(
)
;
mDirLockFilename
.
Truncate
(
)
;
if
(
shouldLock
=
=
Lockstate
:
:
Locked
)
{
Lock
(
path
.
String
(
)
)
;
}
else
{
mAttributes
=
GetFileAttributesW
(
path
.
String
(
)
)
;
}
mIsHardLink
=
Tristate
:
:
Unknown
;
nsAutoHandle
autoHandle
;
HANDLE
handle
;
if
(
IsLocked
(
)
&
&
IsDirectory
(
)
=
=
Tristate
:
:
False
)
{
handle
=
mLockHandle
.
get
(
)
;
}
else
{
handle
=
CreateFileW
(
path
.
String
(
)
0
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
nullptr
)
;
autoHandle
.
own
(
handle
)
;
}
Tristate
isLink
=
Tristate
:
:
Unknown
;
if
(
handle
!
=
INVALID_HANDLE_VALUE
)
{
BY_HANDLE_FILE_INFORMATION
info
;
BOOL
success
=
GetFileInformationByHandle
(
handle
&
info
)
;
if
(
success
)
{
if
(
info
.
nNumberOfLinks
>
1
)
{
isLink
=
Tristate
:
:
True
;
}
else
{
isLink
=
Tristate
:
:
False
;
}
}
}
mIsHardLink
=
Tristate
:
:
Unknown
;
Tristate
isSymLink
=
IsSymLink
(
)
;
if
(
isLink
=
=
Tristate
:
:
False
|
|
isSymLink
=
=
Tristate
:
:
True
)
{
mIsHardLink
=
Tristate
:
:
False
;
}
else
if
(
isLink
=
=
Tristate
:
:
True
&
&
isSymLink
=
=
Tristate
:
:
False
)
{
mIsHardLink
=
Tristate
:
:
True
;
}
}
void
Unlock
(
)
{
mLockHandle
.
own
(
INVALID_HANDLE_VALUE
)
;
}
bool
IsLocked
(
)
const
{
return
mLockHandle
.
get
(
)
!
=
INVALID_HANDLE_VALUE
;
}
Tristate
IsSymLink
(
)
const
{
if
(
mAttributes
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
Tristate
:
:
Unknown
;
}
if
(
mAttributes
&
FILE_ATTRIBUTE_REPARSE_POINT
)
{
return
Tristate
:
:
True
;
}
return
Tristate
:
:
False
;
}
Tristate
IsHardLink
(
)
const
{
return
mIsHardLink
;
}
Tristate
IsLink
(
)
const
{
Tristate
isSymLink
=
IsSymLink
(
)
;
if
(
mIsHardLink
=
=
Tristate
:
:
True
|
|
isSymLink
=
=
Tristate
:
:
True
)
{
return
Tristate
:
:
True
;
}
if
(
mIsHardLink
=
=
Tristate
:
:
Unknown
|
|
isSymLink
=
=
Tristate
:
:
Unknown
)
{
return
Tristate
:
:
Unknown
;
}
return
Tristate
:
:
False
;
}
Tristate
IsDirectory
(
)
const
{
if
(
mAttributes
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
Tristate
:
:
Unknown
;
}
if
(
mAttributes
&
FILE_ATTRIBUTE_DIRECTORY
)
{
return
Tristate
:
:
True
;
}
return
Tristate
:
:
False
;
}
Tristate
IsReadonly
(
)
const
{
if
(
mAttributes
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
Tristate
:
:
Unknown
;
}
if
(
mAttributes
&
FILE_ATTRIBUTE_READONLY
)
{
return
Tristate
:
:
True
;
}
return
Tristate
:
:
False
;
}
DWORD
Attributes
(
)
const
{
return
mAttributes
;
}
HRESULT
SetPerms
(
const
AutoPerms
&
perms
)
{
if
(
IsDirectory
(
)
!
=
Tristate
:
:
False
|
|
!
IsLocked
(
)
|
|
IsHardLink
(
)
!
=
Tristate
:
:
False
)
{
return
E_FAIL
;
}
DWORD
drv
=
SetSecurityInfo
(
mLockHandle
.
get
(
)
SE_FILE_OBJECT
DACL_SECURITY_INFORMATION
nullptr
nullptr
perms
.
acl
.
get
(
)
nullptr
)
;
return
HRESULT_FROM_WIN32
(
drv
)
;
}
Tristate
PermsOk
(
const
SimpleAutoString
&
path
const
AutoPerms
&
perms
)
{
nsAutoHandle
autoHandle
;
HANDLE
handle
;
if
(
IsDirectory
(
)
=
=
Tristate
:
:
False
&
&
IsLocked
(
)
)
{
handle
=
mLockHandle
.
get
(
)
;
}
else
{
handle
=
CreateFileW
(
path
.
String
(
)
READ_CONTROL
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
nullptr
)
;
autoHandle
.
own
(
handle
)
;
}
PACL
dacl
=
nullptr
;
SECURITY_DESCRIPTOR
*
securityDescriptor
=
nullptr
;
DWORD
drv
=
GetSecurityInfo
(
handle
SE_FILE_OBJECT
DACL_SECURITY_INFORMATION
nullptr
nullptr
&
dacl
nullptr
reinterpret_cast
<
PSECURITY_DESCRIPTOR
*
>
(
&
securityDescriptor
)
)
;
mozilla
:
:
UniquePtr
<
SECURITY_DESCRIPTOR
LocalFreeDeleter
>
autoSecurityDescriptor
(
securityDescriptor
)
;
if
(
drv
=
=
ERROR_ACCESS_DENIED
)
{
return
Tristate
:
:
False
;
}
if
(
drv
!
=
ERROR_SUCCESS
|
|
dacl
=
=
nullptr
)
{
return
Tristate
:
:
Unknown
;
}
size_t
eaLen
=
sizeof
(
perms
.
ea
)
/
sizeof
(
perms
.
ea
[
0
]
)
;
for
(
size_t
eaIndex
=
0
;
eaIndex
<
eaLen
;
+
+
eaIndex
)
{
PTRUSTEE_W
trustee
=
const_cast
<
PTRUSTEE_W
>
(
&
perms
.
ea
[
eaIndex
]
.
Trustee
)
;
ACCESS_MASK
expectedMask
=
perms
.
ea
[
eaIndex
]
.
grfAccessPermissions
;
ACCESS_MASK
actualMask
;
drv
=
GetEffectiveRightsFromAclW
(
dacl
trustee
&
actualMask
)
;
if
(
drv
=
=
ERROR_ACCESS_DENIED
)
{
return
Tristate
:
:
False
;
}
if
(
drv
!
=
ERROR_SUCCESS
)
{
return
Tristate
:
:
Unknown
;
}
NormalizeAccessMask
(
expectedMask
)
;
NormalizeAccessMask
(
actualMask
)
;
if
(
(
actualMask
&
expectedMask
)
!
=
expectedMask
)
{
return
Tristate
:
:
False
;
}
}
return
Tristate
:
:
True
;
}
bool
LockFilenameMatches
(
const
wchar_t
*
filename
)
{
if
(
mDirLockFilename
.
Length
(
)
=
=
0
)
{
return
false
;
}
return
wcscmp
(
filename
mDirLockFilename
.
String
(
)
)
=
=
0
;
}
}
;
static
bool
GetCachedHash
(
const
char16_t
*
installPath
HKEY
rootKey
const
SimpleAutoString
&
regPath
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
)
;
static
HRESULT
GetUpdateDirectory
(
const
wchar_t
*
installPath
const
char
*
vendor
const
char
*
appName
WhichUpdateDir
whichDir
SetPermissionsOf
permsToSet
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
;
static
HRESULT
EnsureUpdateDirectoryPermissions
(
const
SimpleAutoString
&
basePath
const
SimpleAutoString
&
updatePath
bool
fullUpdatePath
SetPermissionsOf
permsToSet
)
;
static
HRESULT
GeneratePermissions
(
AutoPerms
&
result
)
;
static
HRESULT
MakeDir
(
const
SimpleAutoString
&
path
const
AutoPerms
&
perms
)
;
static
HRESULT
RemoveRecursive
(
const
SimpleAutoString
&
path
FileOrDirectory
&
file
)
;
static
HRESULT
MoveConflicting
(
const
SimpleAutoString
&
path
FileOrDirectory
&
file
SimpleAutoString
*
outPath
)
;
static
HRESULT
EnsureCorrectPermissions
(
SimpleAutoString
&
path
FileOrDirectory
&
file
const
SimpleAutoString
&
leafUpdateDir
const
AutoPerms
&
perms
SetPermissionsOf
permsToSet
)
;
static
HRESULT
FixDirectoryPermissions
(
const
SimpleAutoString
&
path
FileOrDirectory
&
directory
const
AutoPerms
&
perms
bool
&
permissionsFixed
)
;
static
HRESULT
MoveFileOrDir
(
const
SimpleAutoString
&
moveFrom
const
SimpleAutoString
&
moveTo
const
AutoPerms
&
perms
)
;
static
HRESULT
SplitPath
(
const
SimpleAutoString
&
path
SimpleAutoString
&
parentPath
SimpleAutoString
&
filename
)
;
static
bool
PathConflictsWithLeaf
(
const
SimpleAutoString
&
path
const
SimpleAutoString
&
leafPath
)
;
#
endif
nsresult
GetInstallHash
(
const
char16_t
*
installPath
const
char
*
vendor
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
bool
useCompatibilityMode
)
{
MOZ_ASSERT
(
installPath
!
=
nullptr
"
Install
path
must
not
be
null
in
GetInstallHash
"
)
;
size_t
pathSize
=
std
:
:
char_traits
<
char16_t
>
:
:
length
(
installPath
)
*
sizeof
(
*
installPath
)
;
uint64_t
hash
=
CityHash64
(
reinterpret_cast
<
const
char
*
>
(
installPath
)
pathSize
)
;
size_t
hashStrSize
=
sizeof
(
hash
)
*
2
+
1
;
result
=
mozilla
:
:
MakeUnique
<
NS_tchar
[
]
>
(
hashStrSize
)
;
int
charsWritten
;
if
(
useCompatibilityMode
)
{
charsWritten
=
NS_tsnprintf
(
result
.
get
(
)
hashStrSize
NS_T
(
"
%
"
)
NS_T
(
PRIX32
)
NS_T
(
"
%
"
)
NS_T
(
PRIX32
)
static_cast
<
uint32_t
>
(
hash
>
>
32
)
static_cast
<
uint32_t
>
(
hash
)
)
;
}
else
{
charsWritten
=
NS_tsnprintf
(
result
.
get
(
)
hashStrSize
NS_T
(
"
%
"
)
NS_T
(
PRIX64
)
hash
)
;
}
if
(
charsWritten
<
1
|
|
static_cast
<
size_t
>
(
charsWritten
)
>
hashStrSize
-
1
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
#
ifdef
XP_WIN
static
bool
GetCachedHash
(
const
char16_t
*
installPath
HKEY
rootKey
const
SimpleAutoString
&
regPath
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
&
result
)
{
unsigned
long
bufferSize
;
LSTATUS
lrv
=
RegGetValueW
(
rootKey
regPath
.
String
(
)
reinterpret_cast
<
const
wchar_t
*
>
(
installPath
)
RRF_RT_REG_SZ
nullptr
nullptr
&
bufferSize
)
;
if
(
lrv
!
=
ERROR_SUCCESS
)
{
return
false
;
}
result
=
mozilla
:
:
MakeUnique
<
NS_tchar
[
]
>
(
bufferSize
)
;
if
(
!
result
)
{
return
false
;
}
lrv
=
RegGetValueW
(
rootKey
regPath
.
String
(
)
reinterpret_cast
<
const
wchar_t
*
>
(
installPath
)
RRF_RT_REG_SZ
nullptr
result
.
get
(
)
&
bufferSize
)
;
return
(
lrv
=
=
ERROR_SUCCESS
)
;
}
HRESULT
GetCommonUpdateDirectory
(
const
wchar_t
*
installPath
SetPermissionsOf
permsToSet
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
return
GetUpdateDirectory
(
installPath
nullptr
nullptr
WhichUpdateDir
:
:
CommonAppData
permsToSet
result
)
;
}
HRESULT
GetUserUpdateDirectory
(
const
wchar_t
*
installPath
const
char
*
vendor
const
char
*
appName
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
return
GetUpdateDirectory
(
installPath
vendor
appName
WhichUpdateDir
:
:
UserAppData
SetPermissionsOf
:
:
BaseDirIfNotExists
result
)
;
}
static
HRESULT
GetUpdateDirectory
(
const
wchar_t
*
installPath
const
char
*
vendor
const
char
*
appName
WhichUpdateDir
whichDir
SetPermissionsOf
permsToSet
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
&
result
)
{
PWSTR
baseDirParentPath
;
REFKNOWNFOLDERID
folderID
=
(
whichDir
=
=
WhichUpdateDir
:
:
CommonAppData
)
?
FOLDERID_ProgramData
:
FOLDERID_LocalAppData
;
HRESULT
hrv
=
SHGetKnownFolderPath
(
folderID
KF_FLAG_CREATE
nullptr
&
baseDirParentPath
)
;
mozilla
:
:
UniquePtr
<
wchar_t
CoTaskMemFreeDeleter
>
baseDirParentPathUnique
(
baseDirParentPath
)
;
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
SimpleAutoString
baseDir
;
if
(
whichDir
=
=
WhichUpdateDir
:
:
UserAppData
&
&
(
vendor
|
|
appName
)
)
{
const
char
*
rawBaseDir
=
vendor
?
vendor
:
appName
;
hrv
=
baseDir
.
CopyFrom
(
rawBaseDir
)
;
}
else
{
const
wchar_t
baseDirLiteral
[
]
=
NS_T
(
FALLBACK_VENDOR_NAME
)
;
hrv
=
baseDir
.
CopyFrom
(
baseDirLiteral
)
;
}
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
SimpleAutoString
basePath
;
size_t
basePathLen
=
wcslen
(
baseDirParentPath
)
+
1
+
baseDir
.
Length
(
)
;
basePath
.
AllocAndAssignSprintf
(
basePathLen
L
"
%
s
\
\
%
s
"
baseDirParentPath
baseDir
.
String
(
)
)
;
if
(
basePath
.
Length
(
)
!
=
basePathLen
)
{
return
E_FAIL
;
}
SimpleAutoString
updatePath
;
if
(
installPath
)
{
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
hash
;
bool
gotHash
=
false
;
SimpleAutoString
regPath
;
regPath
.
AutoAllocAndAssignSprintf
(
L
"
SOFTWARE
\
\
%
S
\
\
%
S
\
\
TaskBarIDs
"
vendor
?
vendor
:
"
Mozilla
"
MOZ_APP_BASENAME
)
;
if
(
regPath
.
Length
(
)
!
=
0
)
{
gotHash
=
GetCachedHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
HKEY_LOCAL_MACHINE
regPath
hash
)
;
if
(
!
gotHash
)
{
gotHash
=
GetCachedHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
HKEY_CURRENT_USER
regPath
hash
)
;
}
}
nsresult
rv
=
NS_OK
;
if
(
!
gotHash
)
{
bool
useCompatibilityMode
=
(
whichDir
=
=
WhichUpdateDir
:
:
UserAppData
)
;
rv
=
GetInstallHash
(
reinterpret_cast
<
const
char16_t
*
>
(
installPath
)
vendor
hash
useCompatibilityMode
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
const
wchar_t
midPathDirName
[
]
=
NS_T
(
UPDATE_PATH_MID_DIR_NAME
)
;
size_t
updatePathLen
=
basePath
.
Length
(
)
+
1
+
wcslen
(
midPathDirName
)
+
1
+
wcslen
(
hash
.
get
(
)
)
;
updatePath
.
AllocAndAssignSprintf
(
updatePathLen
L
"
%
s
\
\
%
s
\
\
%
s
"
basePath
.
String
(
)
midPathDirName
hash
.
get
(
)
)
;
}
}
if
(
whichDir
=
=
WhichUpdateDir
:
:
CommonAppData
)
{
if
(
updatePath
.
Length
(
)
>
0
)
{
hrv
=
EnsureUpdateDirectoryPermissions
(
basePath
updatePath
true
permsToSet
)
;
}
else
{
hrv
=
EnsureUpdateDirectoryPermissions
(
basePath
basePath
false
permsToSet
)
;
}
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
}
if
(
!
installPath
)
{
basePath
.
SwapBufferWith
(
result
)
;
return
S_OK
;
}
if
(
updatePath
.
Length
(
)
=
=
0
)
{
return
E_FAIL
;
}
updatePath
.
SwapBufferWith
(
result
)
;
return
S_OK
;
}
static
HRESULT
EnsureUpdateDirectoryPermissions
(
const
SimpleAutoString
&
basePath
const
SimpleAutoString
&
updatePath
bool
fullUpdatePath
SetPermissionsOf
permsToSet
)
{
HRESULT
returnValue
=
S_OK
;
Lockstate
shouldLock
=
permsToSet
=
=
SetPermissionsOf
:
:
BaseDirIfNotExists
?
Lockstate
:
:
Unlocked
:
Lockstate
:
:
Locked
;
FileOrDirectory
baseDir
(
basePath
shouldLock
)
;
bool
validBaseDir
=
baseDir
.
IsDirectory
(
)
=
=
Tristate
:
:
True
&
&
baseDir
.
IsLink
(
)
=
=
Tristate
:
:
False
;
if
(
permsToSet
=
=
SetPermissionsOf
:
:
BaseDirIfNotExists
&
&
validBaseDir
)
{
return
S_OK
;
}
AutoPerms
perms
;
HRESULT
hrv
=
GeneratePermissions
(
perms
)
;
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
if
(
permsToSet
=
=
SetPermissionsOf
:
:
BaseDirIfNotExists
)
{
MoveConflicting
(
basePath
baseDir
nullptr
)
;
hrv
=
MakeDir
(
basePath
perms
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
return
returnValue
;
}
SimpleAutoString
mutBasePath
;
hrv
=
mutBasePath
.
CopyFrom
(
basePath
)
;
if
(
FAILED
(
hrv
)
|
|
mutBasePath
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
return
returnValue
;
}
if
(
fullUpdatePath
)
{
SimpleAutoString
leafDirPath
;
wchar_t
updateSubdirectoryName
[
]
=
NS_T
(
UPDATE_SUBDIRECTORY
)
;
wchar_t
patchDirectoryName
[
]
=
NS_T
(
PATCH_DIRECTORY
)
;
size_t
leafDirLen
=
updatePath
.
Length
(
)
+
wcslen
(
updateSubdirectoryName
)
+
wcslen
(
patchDirectoryName
)
+
2
;
leafDirPath
.
AllocAndAssignSprintf
(
leafDirLen
L
"
%
s
\
\
%
s
\
\
%
s
"
updatePath
.
String
(
)
updateSubdirectoryName
patchDirectoryName
)
;
if
(
leafDirPath
.
Length
(
)
=
=
leafDirLen
)
{
hrv
=
EnsureCorrectPermissions
(
mutBasePath
baseDir
leafDirPath
perms
permsToSet
)
;
}
else
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
hrv
=
EnsureCorrectPermissions
(
mutBasePath
baseDir
updatePath
perms
permsToSet
)
;
}
}
else
{
hrv
=
EnsureCorrectPermissions
(
mutBasePath
baseDir
updatePath
perms
permsToSet
)
;
}
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
BOOL
success
=
CreateDirectoryW
(
basePath
.
String
(
)
const_cast
<
LPSECURITY_ATTRIBUTES
>
(
&
perms
.
securityAttributes
)
)
;
if
(
success
)
{
return
S_OK
;
}
if
(
SUCCEEDED
(
returnValue
)
)
{
baseDir
.
Reset
(
basePath
Lockstate
:
:
Unlocked
)
;
if
(
baseDir
.
IsDirectory
(
)
!
=
Tristate
:
:
True
|
|
baseDir
.
IsLink
(
)
!
=
Tristate
:
:
False
|
|
baseDir
.
PermsOk
(
basePath
perms
)
!
=
Tristate
:
:
True
)
{
return
E_FAIL
;
}
}
return
returnValue
;
}
static
HRESULT
GeneratePermissions
(
AutoPerms
&
result
)
{
result
.
sidIdentifierAuthority
=
SECURITY_NT_AUTHORITY
;
ZeroMemory
(
&
result
.
ea
sizeof
(
result
.
ea
)
)
;
PSID
usersSID
=
nullptr
;
BOOL
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
2
SECURITY_BUILTIN_DOMAIN_RID
DOMAIN_ALIAS_RID_USERS
0
0
0
0
0
0
&
usersSID
)
;
result
.
usersSID
.
reset
(
usersSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
0
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
0
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
0
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
0
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
0
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_GROUP
;
result
.
ea
[
0
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
usersSID
)
;
PSID
adminsSID
=
nullptr
;
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
2
SECURITY_BUILTIN_DOMAIN_RID
DOMAIN_ALIAS_RID_ADMINS
0
0
0
0
0
0
&
adminsSID
)
;
result
.
adminsSID
.
reset
(
adminsSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
1
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
1
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
1
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
1
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
1
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_GROUP
;
result
.
ea
[
1
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
adminsSID
)
;
PSID
systemSID
=
nullptr
;
success
=
AllocateAndInitializeSid
(
&
result
.
sidIdentifierAuthority
1
SECURITY_LOCAL_SYSTEM_RID
0
0
0
0
0
0
0
&
systemSID
)
;
result
.
systemSID
.
reset
(
systemSID
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
ea
[
2
]
.
grfAccessPermissions
=
FILE_ALL_ACCESS
;
result
.
ea
[
2
]
.
grfAccessMode
=
SET_ACCESS
;
result
.
ea
[
2
]
.
grfInheritance
=
SUB_CONTAINERS_AND_OBJECTS_INHERIT
;
result
.
ea
[
2
]
.
Trustee
.
TrusteeForm
=
TRUSTEE_IS_SID
;
result
.
ea
[
2
]
.
Trustee
.
TrusteeType
=
TRUSTEE_IS_USER
;
result
.
ea
[
2
]
.
Trustee
.
ptstrName
=
static_cast
<
LPWSTR
>
(
systemSID
)
;
PACL
acl
=
nullptr
;
DWORD
drv
=
SetEntriesInAclW
(
3
result
.
ea
nullptr
&
acl
)
;
result
.
acl
.
reset
(
acl
)
;
if
(
drv
!
=
ERROR_SUCCESS
)
{
return
HRESULT_FROM_WIN32
(
drv
)
;
}
result
.
securityDescriptorBuffer
=
mozilla
:
:
MakeUnique
<
uint8_t
[
]
>
(
SECURITY_DESCRIPTOR_MIN_LENGTH
)
;
if
(
!
result
.
securityDescriptorBuffer
)
{
return
E_OUTOFMEMORY
;
}
result
.
securityDescriptor
=
reinterpret_cast
<
PSECURITY_DESCRIPTOR
>
(
result
.
securityDescriptorBuffer
.
get
(
)
)
;
success
=
InitializeSecurityDescriptor
(
result
.
securityDescriptor
SECURITY_DESCRIPTOR_REVISION
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
success
=
SetSecurityDescriptorDacl
(
result
.
securityDescriptor
TRUE
acl
FALSE
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
result
.
securityAttributes
.
nLength
=
sizeof
(
SECURITY_ATTRIBUTES
)
;
result
.
securityAttributes
.
lpSecurityDescriptor
=
result
.
securityDescriptor
;
result
.
securityAttributes
.
bInheritHandle
=
FALSE
;
return
S_OK
;
}
static
HRESULT
MakeDir
(
const
SimpleAutoString
&
path
const
AutoPerms
&
perms
)
{
BOOL
success
=
CreateDirectoryW
(
path
.
String
(
)
const_cast
<
LPSECURITY_ATTRIBUTES
>
(
&
perms
.
securityAttributes
)
)
;
if
(
success
)
{
return
S_OK
;
}
DWORD
error
=
GetLastError
(
)
;
if
(
error
!
=
ERROR_ALREADY_EXISTS
)
{
return
HRESULT_FROM_WIN32
(
error
)
;
}
FileOrDirectory
dir
(
path
Lockstate
:
:
Unlocked
)
;
if
(
dir
.
IsDirectory
(
)
=
=
Tristate
:
:
True
&
&
dir
.
IsLink
(
)
=
=
Tristate
:
:
False
)
{
return
S_OK
;
}
return
HRESULT_FROM_WIN32
(
error
)
;
}
static
HRESULT
RemoveRecursive
(
const
SimpleAutoString
&
path
FileOrDirectory
&
file
)
{
file
.
Unlock
(
)
;
if
(
file
.
IsReadonly
(
)
!
=
Tristate
:
:
False
)
{
DWORD
attributes
=
file
.
Attributes
(
)
;
if
(
attributes
=
=
INVALID_FILE_ATTRIBUTES
)
{
SetFileAttributesW
(
path
.
String
(
)
FILE_ATTRIBUTE_NORMAL
)
;
}
else
{
SetFileAttributesW
(
path
.
String
(
)
attributes
&
~
FILE_ATTRIBUTE_READONLY
)
;
}
}
SimpleAutoString
pathList
;
pathList
.
AllocAndAssignSprintf
(
path
.
Length
(
)
+
1
L
"
%
s
\
0
"
path
.
String
(
)
)
;
SHFILEOPSTRUCTW
fileOperation
;
fileOperation
.
hwnd
=
nullptr
;
fileOperation
.
wFunc
=
FO_DELETE
;
fileOperation
.
pFrom
=
pathList
.
String
(
)
;
fileOperation
.
pTo
=
nullptr
;
fileOperation
.
fFlags
=
FOF_ALLOWUNDO
|
FOF_NO_UI
;
fileOperation
.
lpszProgressTitle
=
nullptr
;
int
rv
=
SHFileOperationW
(
&
fileOperation
)
;
if
(
rv
=
=
0
|
|
rv
=
=
ERROR_FILE_NOT_FOUND
)
{
return
S_OK
;
}
BOOL
success
=
DeleteFileW
(
path
.
String
(
)
)
;
return
success
?
S_OK
:
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
static
HRESULT
MoveConflicting
(
const
SimpleAutoString
&
path
FileOrDirectory
&
file
SimpleAutoString
*
outPath
)
{
file
.
Unlock
(
)
;
SimpleAutoString
newPath
;
unsigned
int
maxTries
=
3
;
const
wchar_t
newPathFormat
[
]
=
L
"
%
s
.
bak
%
u
"
;
size_t
newPathMaxLength
=
newPath
.
AllocFromScprintf
(
newPathFormat
path
.
String
(
)
maxTries
)
;
if
(
newPathMaxLength
>
0
)
{
for
(
unsigned
int
suffix
=
0
;
suffix
<
=
maxTries
;
+
+
suffix
)
{
newPath
.
AssignSprintf
(
newPathMaxLength
+
1
newPathFormat
path
.
String
(
)
suffix
)
;
if
(
newPath
.
Length
(
)
=
=
0
)
{
break
;
}
BOOL
success
;
if
(
suffix
<
maxTries
)
{
success
=
MoveFileW
(
path
.
String
(
)
newPath
.
String
(
)
)
;
}
else
{
success
=
MoveFileExW
(
path
.
String
(
)
newPath
.
String
(
)
MOVEFILE_REPLACE_EXISTING
)
;
}
if
(
success
)
{
if
(
outPath
)
{
outPath
-
>
Swap
(
newPath
)
;
}
return
S_OK
;
}
DWORD
drv
=
GetLastError
(
)
;
if
(
drv
=
=
ERROR_FILE_NOT_FOUND
)
{
if
(
outPath
)
{
outPath
-
>
Truncate
(
)
;
}
return
S_OK
;
}
if
(
drv
!
=
ERROR_ALREADY_EXISTS
&
&
drv
!
=
ERROR_ACCESS_DENIED
)
{
break
;
}
}
}
HRESULT
hrv
=
RemoveRecursive
(
path
file
)
;
if
(
SUCCEEDED
(
hrv
)
)
{
if
(
outPath
)
{
outPath
-
>
Truncate
(
)
;
}
}
return
hrv
;
}
static
HRESULT
EnsureCorrectPermissions
(
SimpleAutoString
&
path
FileOrDirectory
&
file
const
SimpleAutoString
&
leafUpdateDir
const
AutoPerms
&
perms
SetPermissionsOf
permsToSet
)
{
HRESULT
returnValue
=
S_OK
;
HRESULT
hrv
;
bool
conflictsWithLeaf
=
PathConflictsWithLeaf
(
path
leafUpdateDir
)
;
if
(
file
.
IsDirectory
(
)
!
=
Tristate
:
:
True
|
|
file
.
IsLink
(
)
!
=
Tristate
:
:
False
)
{
HRESULT
permSetResult
=
file
.
SetPerms
(
perms
)
;
bool
removed
=
false
;
if
(
file
.
IsLink
(
)
!
=
Tristate
:
:
False
)
{
hrv
=
RemoveRecursive
(
path
file
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
if
(
SUCCEEDED
(
hrv
)
)
{
removed
=
true
;
}
}
if
(
FAILED
(
permSetResult
)
&
&
!
removed
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
permSetResult
;
}
if
(
conflictsWithLeaf
&
&
!
removed
)
{
hrv
=
MoveConflicting
(
path
file
nullptr
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
}
return
returnValue
;
}
Tristate
permissionsOk
=
file
.
PermsOk
(
path
perms
)
;
if
(
permissionsOk
=
=
Tristate
:
:
False
|
|
(
permissionsOk
=
=
Tristate
:
:
Unknown
&
&
permsToSet
=
=
SetPermissionsOf
:
:
AllFilesAndDirs
)
)
{
bool
permissionsFixed
;
hrv
=
FixDirectoryPermissions
(
path
file
perms
permissionsFixed
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
if
(
!
permissionsFixed
&
&
conflictsWithLeaf
)
{
MoveConflicting
(
path
file
&
path
)
;
if
(
path
.
Length
(
)
=
=
0
)
{
return
returnValue
;
}
}
if
(
!
file
.
IsLocked
(
)
)
{
file
.
Reset
(
path
Lockstate
:
:
Locked
)
;
}
}
else
if
(
permissionsOk
!
=
Tristate
:
:
True
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
}
if
(
!
file
.
IsLocked
(
)
|
|
file
.
IsLink
(
)
!
=
Tristate
:
:
False
|
|
file
.
IsDirectory
(
)
!
=
Tristate
:
:
True
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
return
returnValue
;
}
DIR
directoryHandle
(
path
.
String
(
)
)
;
errno
=
0
;
for
(
dirent
*
entry
=
readdir
(
&
directoryHandle
)
;
entry
;
entry
=
readdir
(
&
directoryHandle
)
)
{
if
(
wcscmp
(
entry
-
>
d_name
L
"
.
"
)
=
=
0
|
|
wcscmp
(
entry
-
>
d_name
L
"
.
.
"
)
=
=
0
|
|
file
.
LockFilenameMatches
(
entry
-
>
d_name
)
)
{
continue
;
}
SimpleAutoString
childBuffer
;
if
(
!
childBuffer
.
AllocEmpty
(
MAX_PATH
)
)
{
return
FAILED
(
returnValue
)
?
returnValue
:
E_OUTOFMEMORY
;
}
childBuffer
.
AssignSprintf
(
MAX_PATH
+
1
L
"
%
s
\
\
%
s
"
path
.
String
(
)
entry
-
>
d_name
)
;
if
(
childBuffer
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
ERROR_BUFFER_OVERFLOW
)
;
continue
;
}
FileOrDirectory
child
(
childBuffer
Lockstate
:
:
Locked
)
;
hrv
=
EnsureCorrectPermissions
(
childBuffer
child
leafUpdateDir
perms
permsToSet
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
errno
=
0
;
}
if
(
errno
!
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
}
return
returnValue
;
}
static
HRESULT
FixDirectoryPermissions
(
const
SimpleAutoString
&
path
FileOrDirectory
&
directory
const
AutoPerms
&
perms
bool
&
permissionsFixed
)
{
permissionsFixed
=
false
;
SimpleAutoString
parent
;
SimpleAutoString
dirName
;
HRESULT
hrv
=
SplitPath
(
path
parent
dirName
)
;
if
(
FAILED
(
hrv
)
)
{
return
E_FAIL
;
}
SimpleAutoString
tempPath
;
if
(
!
tempPath
.
AllocEmpty
(
MAX_PATH
)
)
{
return
E_FAIL
;
}
BOOL
success
=
GetUUIDTempFilePath
(
parent
.
String
(
)
dirName
.
String
(
)
tempPath
.
MutableString
(
)
)
;
if
(
!
success
|
|
!
tempPath
.
Check
(
)
|
|
tempPath
.
Length
(
)
=
=
0
)
{
return
E_FAIL
;
}
directory
.
Unlock
(
)
;
success
=
MoveFileW
(
path
.
String
(
)
tempPath
.
String
(
)
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
success
=
CreateDirectoryW
(
path
.
String
(
)
const_cast
<
LPSECURITY_ATTRIBUTES
>
(
&
perms
.
securityAttributes
)
)
;
if
(
!
success
)
{
return
E_FAIL
;
}
directory
.
Reset
(
path
Lockstate
:
:
Locked
)
;
if
(
!
directory
.
IsLocked
(
)
|
|
directory
.
IsLink
(
)
!
=
Tristate
:
:
False
|
|
directory
.
IsDirectory
(
)
!
=
Tristate
:
:
True
|
|
directory
.
PermsOk
(
path
perms
)
!
=
Tristate
:
:
True
)
{
directory
.
Unlock
(
)
;
return
E_FAIL
;
}
permissionsFixed
=
true
;
FileOrDirectory
tempDir
(
tempPath
Lockstate
:
:
Locked
)
;
if
(
!
tempDir
.
IsLocked
(
)
|
|
tempDir
.
IsLink
(
)
!
=
Tristate
:
:
False
|
|
tempDir
.
IsDirectory
(
)
!
=
Tristate
:
:
True
)
{
return
E_FAIL
;
}
SimpleAutoString
moveFrom
;
SimpleAutoString
moveTo
;
if
(
!
moveFrom
.
AllocEmpty
(
MAX_PATH
)
|
|
!
moveTo
.
AllocEmpty
(
MAX_PATH
)
)
{
return
E_OUTOFMEMORY
;
}
HRESULT
returnValue
=
S_OK
;
DIR
directoryHandle
(
tempPath
.
String
(
)
)
;
errno
=
0
;
for
(
dirent
*
entry
=
readdir
(
&
directoryHandle
)
;
entry
;
entry
=
readdir
(
&
directoryHandle
)
)
{
if
(
wcscmp
(
entry
-
>
d_name
L
"
.
"
)
=
=
0
|
|
wcscmp
(
entry
-
>
d_name
L
"
.
.
"
)
=
=
0
|
|
tempDir
.
LockFilenameMatches
(
entry
-
>
d_name
)
)
{
continue
;
}
moveFrom
.
AssignSprintf
(
MAX_PATH
+
1
L
"
%
s
\
\
%
s
"
tempPath
.
String
(
)
entry
-
>
d_name
)
;
if
(
moveFrom
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
ERROR_BUFFER_OVERFLOW
)
;
continue
;
}
moveTo
.
AssignSprintf
(
MAX_PATH
+
1
L
"
%
s
\
\
%
s
"
path
.
String
(
)
entry
-
>
d_name
)
;
if
(
moveTo
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
ERROR_BUFFER_OVERFLOW
)
;
continue
;
}
hrv
=
MoveFileOrDir
(
moveFrom
moveTo
perms
)
;
if
(
FAILED
(
hrv
)
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
}
errno
=
0
;
}
if
(
errno
!
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
}
hrv
=
RemoveRecursive
(
tempPath
tempDir
)
;
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
return
returnValue
;
}
static
HRESULT
MoveFileOrDir
(
const
SimpleAutoString
&
moveFrom
const
SimpleAutoString
&
moveTo
const
AutoPerms
&
perms
)
{
BOOL
success
=
MoveFileW
(
moveFrom
.
String
(
)
moveTo
.
String
(
)
)
;
if
(
success
)
{
return
S_OK
;
}
FileOrDirectory
fileToMove
(
moveFrom
Lockstate
:
:
Locked
)
;
HRESULT
returnValue
=
S_OK
;
if
(
fileToMove
.
IsDirectory
(
)
!
=
Tristate
:
:
True
)
{
fileToMove
.
Unlock
(
)
;
if
(
fileToMove
.
IsLink
(
)
=
=
Tristate
:
:
False
)
{
success
=
CopyFileW
(
moveFrom
.
String
(
)
moveTo
.
String
(
)
TRUE
)
;
if
(
!
success
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
}
success
=
DeleteFileW
(
moveFrom
.
String
(
)
)
;
if
(
!
success
)
{
success
=
MoveFileExW
(
moveFrom
.
String
(
)
nullptr
MOVEFILE_DELAY_UNTIL_REBOOT
)
;
if
(
!
success
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
}
return
returnValue
;
}
success
=
CreateDirectoryW
(
moveTo
.
String
(
)
const_cast
<
LPSECURITY_ATTRIBUTES
>
(
&
perms
.
securityAttributes
)
)
;
if
(
!
success
)
{
return
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
FileOrDirectory
destDir
(
moveTo
Lockstate
:
:
Locked
)
;
SimpleAutoString
childPath
;
SimpleAutoString
childDestPath
;
if
(
!
childPath
.
AllocEmpty
(
MAX_PATH
)
|
|
!
childDestPath
.
AllocEmpty
(
MAX_PATH
)
)
{
return
E_OUTOFMEMORY
;
}
if
(
!
fileToMove
.
IsLocked
(
)
|
|
!
destDir
.
IsLocked
(
)
|
|
destDir
.
IsDirectory
(
)
!
=
Tristate
:
:
True
|
|
destDir
.
IsLink
(
)
!
=
Tristate
:
:
False
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
}
else
if
(
fileToMove
.
IsLink
(
)
=
=
Tristate
:
:
False
)
{
DIR
directoryHandle
(
moveFrom
.
String
(
)
)
;
errno
=
0
;
for
(
dirent
*
entry
=
readdir
(
&
directoryHandle
)
;
entry
;
entry
=
readdir
(
&
directoryHandle
)
)
{
if
(
wcscmp
(
entry
-
>
d_name
L
"
.
"
)
=
=
0
|
|
wcscmp
(
entry
-
>
d_name
L
"
.
.
"
)
=
=
0
|
|
fileToMove
.
LockFilenameMatches
(
entry
-
>
d_name
)
)
{
continue
;
}
childPath
.
AssignSprintf
(
MAX_PATH
+
1
L
"
%
s
\
\
%
s
"
moveFrom
.
String
(
)
entry
-
>
d_name
)
;
if
(
childPath
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
ERROR_BUFFER_OVERFLOW
)
;
continue
;
}
childDestPath
.
AssignSprintf
(
MAX_PATH
+
1
L
"
%
s
\
\
%
s
"
moveTo
.
String
(
)
entry
-
>
d_name
)
;
if
(
childDestPath
.
Length
(
)
=
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
ERROR_BUFFER_OVERFLOW
)
;
continue
;
}
HRESULT
hrv
=
MoveFileOrDir
(
childPath
childDestPath
perms
)
;
if
(
FAILED
(
hrv
)
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
hrv
;
}
errno
=
0
;
}
if
(
errno
!
=
0
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
E_FAIL
;
}
}
HRESULT
hrv
=
RemoveRecursive
(
moveFrom
fileToMove
)
;
if
(
FAILED
(
hrv
)
)
{
success
=
MoveFileExW
(
moveFrom
.
String
(
)
nullptr
MOVEFILE_DELAY_UNTIL_REBOOT
)
;
if
(
!
success
)
{
returnValue
=
FAILED
(
returnValue
)
?
returnValue
:
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
;
}
}
return
returnValue
;
}
static
HRESULT
SplitPath
(
const
SimpleAutoString
&
path
SimpleAutoString
&
parentPath
SimpleAutoString
&
filename
)
{
HRESULT
hrv
=
parentPath
.
CopyFrom
(
path
)
;
if
(
FAILED
(
hrv
)
|
|
parentPath
.
Length
(
)
=
=
0
)
{
return
hrv
;
}
hrv
=
GetFilename
(
parentPath
filename
)
;
if
(
FAILED
(
hrv
)
)
{
return
hrv
;
}
size_t
parentPathLen
=
parentPath
.
Length
(
)
;
if
(
parentPathLen
<
filename
.
Length
(
)
+
1
)
{
return
E_FAIL
;
}
parentPathLen
-
=
filename
.
Length
(
)
+
1
;
parentPath
.
Truncate
(
parentPathLen
)
;
if
(
parentPath
.
Length
(
)
=
=
0
)
{
return
E_FAIL
;
}
return
S_OK
;
}
static
HRESULT
GetFilename
(
SimpleAutoString
&
path
SimpleAutoString
&
filename
)
{
size_t
pathLen
=
path
.
Length
(
)
;
if
(
pathLen
=
=
0
)
{
return
E_FAIL
;
}
wchar_t
lastChar
=
path
.
String
(
)
[
pathLen
-
1
]
;
while
(
lastChar
=
=
'
/
'
|
|
lastChar
=
=
'
\
\
'
)
{
-
-
pathLen
;
path
.
Truncate
(
pathLen
)
;
if
(
pathLen
=
=
0
)
{
return
E_FAIL
;
}
lastChar
=
path
.
String
(
)
[
pathLen
-
1
]
;
}
const
wchar_t
*
separator1
=
wcsrchr
(
path
.
String
(
)
'
/
'
)
;
const
wchar_t
*
separator2
=
wcsrchr
(
path
.
String
(
)
'
\
\
'
)
;
const
wchar_t
*
separator
=
(
separator1
>
separator2
)
?
separator1
:
separator2
;
if
(
separator
=
=
nullptr
)
{
return
E_FAIL
;
}
HRESULT
hrv
=
filename
.
CopyFrom
(
separator
+
1
)
;
if
(
FAILED
(
hrv
)
|
|
filename
.
Length
(
)
=
=
0
)
{
return
E_FAIL
;
}
return
S_OK
;
}
static
bool
PathConflictsWithLeaf
(
const
SimpleAutoString
&
path
const
SimpleAutoString
&
leafPath
)
{
if
(
!
leafPath
.
StartsWith
(
path
)
)
{
return
false
;
}
wchar_t
charAfterPath
=
leafPath
.
String
(
)
[
path
.
Length
(
)
]
;
return
(
charAfterPath
=
=
L
'
\
\
'
|
|
charAfterPath
=
=
L
'
\
0
'
)
;
}
#
endif
