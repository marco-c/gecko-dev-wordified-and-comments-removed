#
ifndef
READSTRINGS_H__
#
define
READSTRINGS_H__
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
vector
>
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
typedef
WCHAR
NS_tchar
;
#
else
typedef
char
NS_tchar
;
#
endif
struct
StringTable
{
mozilla
:
:
UniquePtr
<
char
[
]
>
title
;
mozilla
:
:
UniquePtr
<
char
[
]
>
info
;
}
;
struct
MARChannelStringTable
{
MARChannelStringTable
(
)
{
MARChannelID
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
1
)
;
MARChannelID
[
0
]
=
'
\
0
'
;
}
mozilla
:
:
UniquePtr
<
char
[
]
>
MARChannelID
;
}
;
int
ReadStrings
(
const
NS_tchar
*
path
StringTable
*
results
)
;
int
ReadStrings
(
const
NS_tchar
*
path
const
char
*
keyList
unsigned
int
numStrings
mozilla
:
:
UniquePtr
<
char
[
]
>
*
results
const
char
*
section
=
nullptr
)
;
int
ReadStringsFromBuffer
(
char
*
stringBuffer
const
char
*
keyList
unsigned
int
numStrings
mozilla
:
:
UniquePtr
<
char
[
]
>
*
results
const
char
*
section
=
nullptr
)
;
class
IniReader
{
public
:
explicit
IniReader
(
const
NS_tchar
*
iniPath
const
char
*
section
=
nullptr
)
;
void
AddKey
(
const
char
*
key
mozilla
:
:
UniquePtr
<
char
[
]
>
*
outputPtr
)
;
#
ifdef
XP_WIN
void
AddKey
(
const
char
*
key
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
*
outputPtr
)
;
#
endif
bool
HasRead
(
)
{
return
mMaybeStatusCode
.
isSome
(
)
;
}
int
Read
(
)
;
private
:
bool
MaybeAddKey
(
const
char
*
key
size_t
&
insertionIndex
)
;
mozilla
:
:
UniquePtr
<
NS_tchar
[
]
>
mPath
;
mozilla
:
:
UniquePtr
<
char
[
]
>
mSection
;
std
:
:
vector
<
mozilla
:
:
UniquePtr
<
char
[
]
>
>
mKeys
;
template
<
class
T
>
struct
ValueOutput
{
size_t
keyIndex
;
T
*
outputPtr
;
}
;
std
:
:
vector
<
ValueOutput
<
mozilla
:
:
UniquePtr
<
char
[
]
>
>
>
mNarrowOutputs
;
#
ifdef
XP_WIN
std
:
:
vector
<
ValueOutput
<
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
>
>
mWideOutputs
;
#
endif
mozilla
:
:
Maybe
<
int
>
mMaybeStatusCode
;
}
;
#
endif
