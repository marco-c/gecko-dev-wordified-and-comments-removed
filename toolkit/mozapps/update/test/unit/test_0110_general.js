function
run_test
(
)
{
var
testDir
=
do_get_file
(
"
mar_test
"
true
)
;
try
{
if
(
testDir
.
exists
(
)
)
testDir
.
remove
(
true
)
;
}
catch
(
e
)
{
dump
(
"
Unable
to
remove
directory
\
npath
:
"
+
testDir
.
path
+
"
\
nException
:
"
+
e
+
"
\
n
"
)
;
}
dump
(
"
Testing
:
successful
removal
of
the
directory
used
to
apply
the
mar
file
\
n
"
)
;
do_check_false
(
testDir
.
exists
(
)
)
;
testDir
=
do_get_file
(
"
mar_test
/
1
/
1_1
/
"
true
)
;
testDir
.
create
(
AUS_Ci
.
nsIFile
.
DIRECTORY_TYPE
PERMS_DIRECTORY
)
;
var
testFile
=
do_get_file
(
"
mar_test
/
1
/
1_1
/
1_1_text1
"
true
)
;
testFile
.
create
(
AUS_Ci
.
nsIFile
.
NORMAL_FILE_TYPE
PERMS_FILE
)
;
var
binDir
=
getGREDir
(
)
;
var
updater
=
binDir
.
clone
(
)
;
updater
.
append
(
"
updater
.
app
"
)
;
if
(
!
updater
.
exists
(
)
)
{
updater
=
binDir
.
clone
(
)
;
updater
.
append
(
"
updater
.
exe
"
)
;
if
(
!
updater
.
exists
(
)
)
{
updater
=
binDir
.
clone
(
)
;
updater
.
append
(
"
updater
"
)
;
if
(
!
updater
.
exists
(
)
)
{
do_throw
(
"
Unable
to
find
updater
binary
!
"
)
;
}
}
}
var
updatesSubDir
=
do_get_file
(
"
0110_complete_mar
"
true
)
;
try
{
if
(
updatesSubDir
.
exists
(
)
)
updatesSubDir
.
remove
(
true
)
;
}
catch
(
e
)
{
dump
(
"
Unable
to
remove
directory
\
npath
:
"
+
updatesSubDir
.
path
+
"
\
nException
:
"
+
e
+
"
\
n
"
)
;
}
var
mar
=
do_get_file
(
"
data
/
aus
-
0110_general
.
mar
"
)
;
mar
.
copyTo
(
updatesSubDir
"
update
.
mar
"
)
;
var
exitValue
=
runUpdate
(
updatesSubDir
updater
)
;
dump
(
"
Testing
:
updater
binary
process
exitValue
for
success
when
applying
"
+
"
a
complete
mar
\
n
"
)
;
do_check_eq
(
exitValue
0
)
;
dump
(
"
Testing
:
update
.
status
should
be
set
to
STATE_SUCCEEDED
\
n
"
)
;
testFile
=
updatesSubDir
.
clone
(
)
;
testFile
.
append
(
"
update
.
status
"
)
;
do_check_eq
(
readFile
(
testFile
)
.
split
(
"
\
n
"
)
[
0
]
STATE_SUCCEEDED
)
;
dump
(
"
Testing
:
contents
of
files
added
by
a
complete
mar
\
n
"
)
;
do_check_eq
(
getFileBytes
(
do_get_file
(
"
mar_test
/
1
/
1_1
/
1_1_text1
"
true
)
)
"
ToBeModified
\
n
"
)
;
do_check_eq
(
getFileBytes
(
do_get_file
(
"
mar_test
/
1
/
1_1
/
1_1_text2
"
true
)
)
"
ToBeDeleted
\
n
"
)
;
var
refImage
=
do_get_file
(
"
data
/
aus
-
0110_general_ref_image
.
png
"
)
;
var
srcImage
=
do_get_file
(
"
mar_test
/
1
/
1_1
/
1_1_image1
.
png
"
true
)
;
do_check_eq
(
getFileBytes
(
srcImage
)
getFileBytes
(
refImage
)
)
;
do_check_eq
(
getFileBytes
(
do_get_file
(
"
mar_test
/
2
/
2_1
/
2_1_text1
"
true
)
)
"
ToBeDeleted
\
n
"
)
;
try
{
if
(
updatesSubDir
.
exists
(
)
)
updatesSubDir
.
remove
(
true
)
;
}
catch
(
e
)
{
dump
(
"
Unable
to
remove
directory
\
npath
:
"
+
updatesSubDir
.
path
+
"
\
nException
:
"
+
e
+
"
\
n
"
)
;
}
cleanUp
(
)
;
}
function
runUpdate
(
aUpdatesSubDir
aUpdater
)
{
aUpdater
.
copyTo
(
aUpdatesSubDir
aUpdater
.
leafName
)
;
var
updateBin
=
aUpdatesSubDir
.
clone
(
)
;
updateBin
.
append
(
aUpdater
.
leafName
)
;
if
(
updateBin
.
leafName
=
=
"
updater
.
app
"
)
{
updateBin
.
append
(
"
Contents
"
)
;
updateBin
.
append
(
"
MacOS
"
)
;
updateBin
.
append
(
"
updater
"
)
;
if
(
!
updateBin
.
exists
(
)
)
do_throw
(
"
Unable
to
find
the
updater
executable
!
"
)
;
}
var
updatesSubDirPath
=
aUpdatesSubDir
.
path
;
if
(
/
/
.
test
(
updatesSubDirPath
)
)
updatesSubDirPath
=
'
"
'
+
updatesSubDirPath
+
'
"
'
;
var
cwdPath
=
do_get_file
(
"
/
"
true
)
.
path
;
if
(
/
/
.
test
(
cwdPath
)
)
cwdPath
=
'
"
'
+
cwdPath
+
'
"
'
;
var
process
=
AUS_Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
AUS_Ci
.
nsIProcess
)
;
process
.
init
(
updateBin
)
;
var
args
=
[
updatesSubDirPath
0
cwdPath
]
;
process
.
run
(
true
args
args
.
length
)
;
return
process
.
exitValue
;
}
function
getFileBytes
(
aFile
)
{
var
fis
=
AUS_Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
AUS_Ci
.
nsIFileInputStream
)
;
fis
.
init
(
aFile
-
1
-
1
false
)
;
var
bis
=
AUS_Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
AUS_Ci
.
nsIBinaryInputStream
)
;
bis
.
setInputStream
(
fis
)
;
var
data
=
bis
.
readBytes
(
bis
.
available
(
)
)
;
bis
.
close
(
)
;
fis
.
close
(
)
;
return
data
;
}
