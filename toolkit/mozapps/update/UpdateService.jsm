"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
AUSTLMY
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
UpdateTelemetry
.
jsm
"
)
;
const
{
Bits
BitsRequest
BitsUnknownError
BitsVerificationError
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Bits
.
jsm
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
CertUtils
:
"
resource
:
/
/
gre
/
modules
/
CertUtils
.
sys
.
mjs
"
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
sys
.
mjs
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
sys
.
mjs
"
WindowsRegistry
:
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
sys
.
mjs
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
ctypes
:
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
AUS
"
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
"
nsIApplicationUpdateService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
UM
"
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
"
nsIUpdateManager
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
CheckSvc
"
"
mozilla
.
org
/
updates
/
update
-
checker
;
1
"
"
nsIUpdateChecker
"
)
;
if
(
AppConstants
.
ENABLE_WEBDRIVER
)
{
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
Marionette
"
"
mozilla
.
org
/
remote
/
marionette
;
1
"
"
nsIMarionette
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
RemoteAgent
"
"
mozilla
.
org
/
remote
/
agent
;
1
"
"
nsIRemoteAgent
"
)
;
}
else
{
lazy
.
Marionette
=
{
running
:
false
}
;
lazy
.
RemoteAgent
=
{
running
:
false
}
;
}
const
UPDATESERVICE_CID
=
Components
.
ID
(
"
{
B3C290A6
-
3943
-
4B89
-
8BBE
-
C01EB7B3B311
}
"
)
;
const
PREF_APP_UPDATE_ALTUPDATEDIRPATH
=
"
app
.
update
.
altUpdateDirPath
"
;
const
PREF_APP_UPDATE_BACKGROUNDERRORS
=
"
app
.
update
.
backgroundErrors
"
;
const
PREF_APP_UPDATE_BACKGROUNDMAXERRORS
=
"
app
.
update
.
backgroundMaxErrors
"
;
const
PREF_APP_UPDATE_BITS_ENABLED
=
"
app
.
update
.
BITS
.
enabled
"
;
const
PREF_APP_UPDATE_CANCELATIONS
=
"
app
.
update
.
cancelations
"
;
const
PREF_APP_UPDATE_CANCELATIONS_OSX
=
"
app
.
update
.
cancelations
.
osx
"
;
const
PREF_APP_UPDATE_CANCELATIONS_OSX_MAX
=
"
app
.
update
.
cancelations
.
osx
.
max
"
;
const
PREF_APP_UPDATE_CHECK_ONLY_INSTANCE_ENABLED
=
"
app
.
update
.
checkOnlyInstance
.
enabled
"
;
const
PREF_APP_UPDATE_CHECK_ONLY_INSTANCE_INTERVAL
=
"
app
.
update
.
checkOnlyInstance
.
interval
"
;
const
PREF_APP_UPDATE_CHECK_ONLY_INSTANCE_TIMEOUT
=
"
app
.
update
.
checkOnlyInstance
.
timeout
"
;
const
PREF_APP_UPDATE_DISABLEDFORTESTING
=
"
app
.
update
.
disabledForTesting
"
;
const
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
=
"
app
.
update
.
download
.
attempts
"
;
const
PREF_APP_UPDATE_DOWNLOAD_MAXATTEMPTS
=
"
app
.
update
.
download
.
maxAttempts
"
;
const
PREF_APP_UPDATE_ELEVATE_NEVER
=
"
app
.
update
.
elevate
.
never
"
;
const
PREF_APP_UPDATE_ELEVATE_VERSION
=
"
app
.
update
.
elevate
.
version
"
;
const
PREF_APP_UPDATE_ELEVATE_ATTEMPTS
=
"
app
.
update
.
elevate
.
attempts
"
;
const
PREF_APP_UPDATE_ELEVATE_MAXATTEMPTS
=
"
app
.
update
.
elevate
.
maxAttempts
"
;
const
PREF_APP_UPDATE_LANGPACK_ENABLED
=
"
app
.
update
.
langpack
.
enabled
"
;
const
PREF_APP_UPDATE_LANGPACK_TIMEOUT
=
"
app
.
update
.
langpack
.
timeout
"
;
const
PREF_APP_UPDATE_LOG
=
"
app
.
update
.
log
"
;
const
PREF_APP_UPDATE_LOG_FILE
=
"
app
.
update
.
log
.
file
"
;
const
PREF_APP_UPDATE_NOTIFYDURINGDOWNLOAD
=
"
app
.
update
.
notifyDuringDownload
"
;
const
PREF_APP_UPDATE_NO_WINDOW_AUTO_RESTART_ENABLED
=
"
app
.
update
.
noWindowAutoRestart
.
enabled
"
;
const
PREF_APP_UPDATE_NO_WINDOW_AUTO_RESTART_DELAY_MS
=
"
app
.
update
.
noWindowAutoRestart
.
delayMs
"
;
const
PREF_APP_UPDATE_PROMPTWAITTIME
=
"
app
.
update
.
promptWaitTime
"
;
const
PREF_APP_UPDATE_SERVICE_ENABLED
=
"
app
.
update
.
service
.
enabled
"
;
const
PREF_APP_UPDATE_SERVICE_ERRORS
=
"
app
.
update
.
service
.
errors
"
;
const
PREF_APP_UPDATE_SERVICE_MAXERRORS
=
"
app
.
update
.
service
.
maxErrors
"
;
const
PREF_APP_UPDATE_SOCKET_MAXERRORS
=
"
app
.
update
.
socket
.
maxErrors
"
;
const
PREF_APP_UPDATE_SOCKET_RETRYTIMEOUT
=
"
app
.
update
.
socket
.
retryTimeout
"
;
const
PREF_APP_UPDATE_STAGING_ENABLED
=
"
app
.
update
.
staging
.
enabled
"
;
const
PREF_APP_UPDATE_URL_DETAILS
=
"
app
.
update
.
url
.
details
"
;
const
PREF_NETWORK_PROXY_TYPE
=
"
network
.
proxy
.
type
"
;
const
URI_BRAND_PROPERTIES
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
URI_UPDATE_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
2005
/
app
-
update
"
;
const
URI_UPDATES_PROPERTIES
=
"
chrome
:
/
/
mozapps
/
locale
/
update
/
updates
.
properties
"
;
const
KEY_EXECUTABLE
=
"
XREExeF
"
;
const
KEY_PROFILE_DIR
=
"
ProfD
"
;
const
KEY_UPDROOT
=
"
UpdRootD
"
;
const
DIR_UPDATES
=
"
updates
"
;
const
FILE_ACTIVE_UPDATE_XML
=
"
active
-
update
.
xml
"
;
const
FILE_BACKUP_UPDATE_LOG
=
"
backup
-
update
.
log
"
;
const
FILE_BT_RESULT
=
"
bt
.
result
"
;
const
FILE_LAST_UPDATE_LOG
=
"
last
-
update
.
log
"
;
const
FILE_UPDATES_XML
=
"
updates
.
xml
"
;
const
FILE_UPDATE_LOG
=
"
update
.
log
"
;
const
FILE_UPDATE_MAR
=
"
update
.
mar
"
;
const
FILE_UPDATE_STATUS
=
"
update
.
status
"
;
const
FILE_UPDATE_TEST
=
"
update
.
test
"
;
const
FILE_UPDATE_VERSION
=
"
update
.
version
"
;
const
FILE_UPDATE_MESSAGES
=
"
update_messages
.
log
"
;
const
STATE_NONE
=
"
null
"
;
const
STATE_DOWNLOADING
=
"
downloading
"
;
const
STATE_PENDING
=
"
pending
"
;
const
STATE_PENDING_SERVICE
=
"
pending
-
service
"
;
const
STATE_PENDING_ELEVATE
=
"
pending
-
elevate
"
;
const
STATE_APPLYING
=
"
applying
"
;
const
STATE_APPLIED
=
"
applied
"
;
const
STATE_APPLIED_SERVICE
=
"
applied
-
service
"
;
const
STATE_SUCCEEDED
=
"
succeeded
"
;
const
STATE_DOWNLOAD_FAILED
=
"
download
-
failed
"
;
const
STATE_FAILED
=
"
failed
"
;
const
BITS_IDLE_NO_PROGRESS_TIMEOUT_SECS
=
3600
;
const
BITS_ACTIVE_NO_PROGRESS_TIMEOUT_SECS
=
5
;
const
BITS_IDLE_POLL_RATE_MS
=
1000
;
const
BITS_ACTIVE_POLL_RATE_MS
=
200
;
const
WRITE_ERROR
=
7
;
const
ELEVATION_CANCELED
=
9
;
const
SERVICE_UPDATER_COULD_NOT_BE_STARTED
=
24
;
const
SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS
=
25
;
const
SERVICE_UPDATER_SIGN_ERROR
=
26
;
const
SERVICE_UPDATER_COMPARE_ERROR
=
27
;
const
SERVICE_UPDATER_IDENTITY_ERROR
=
28
;
const
SERVICE_STILL_APPLYING_ON_SUCCESS
=
29
;
const
SERVICE_STILL_APPLYING_ON_FAILURE
=
30
;
const
SERVICE_UPDATER_NOT_FIXED_DRIVE
=
31
;
const
SERVICE_COULD_NOT_LOCK_UPDATER
=
32
;
const
SERVICE_INSTALLDIR_ERROR
=
33
;
const
WRITE_ERROR_ACCESS_DENIED
=
35
;
const
WRITE_ERROR_CALLBACK_APP
=
37
;
const
UNEXPECTED_STAGING_ERROR
=
43
;
const
DELETE_ERROR_STAGING_LOCK_FILE
=
44
;
const
SERVICE_COULD_NOT_COPY_UPDATER
=
49
;
const
SERVICE_STILL_APPLYING_TERMINATED
=
50
;
const
SERVICE_STILL_APPLYING_NO_EXIT_CODE
=
51
;
const
SERVICE_COULD_NOT_IMPERSONATE
=
58
;
const
WRITE_ERROR_FILE_COPY
=
61
;
const
WRITE_ERROR_DELETE_FILE
=
62
;
const
WRITE_ERROR_OPEN_PATCH_FILE
=
63
;
const
WRITE_ERROR_PATCH_FILE
=
64
;
const
WRITE_ERROR_APPLY_DIR_PATH
=
65
;
const
WRITE_ERROR_CALLBACK_PATH
=
66
;
const
WRITE_ERROR_FILE_ACCESS_DENIED
=
67
;
const
WRITE_ERROR_DIR_ACCESS_DENIED
=
68
;
const
WRITE_ERROR_DELETE_BACKUP
=
69
;
const
WRITE_ERROR_EXTRACT
=
70
;
const
ERR_UPDATER_CRASHED
=
89
;
const
ERR_OLDER_VERSION_OR_SAME_BUILD
=
90
;
const
ERR_UPDATE_STATE_NONE
=
91
;
const
ERR_CHANNEL_CHANGE
=
92
;
const
INVALID_UPDATER_STATE_CODE
=
98
;
const
INVALID_UPDATER_STATUS_CODE
=
99
;
const
SILENT_UPDATE_NEEDED_ELEVATION_ERROR
=
105
;
const
WRITE_ERROR_BACKGROUND_TASK_SHARING_VIOLATION
=
106
;
const
WRITE_ERRORS
=
[
WRITE_ERROR
WRITE_ERROR_ACCESS_DENIED
WRITE_ERROR_CALLBACK_APP
WRITE_ERROR_FILE_COPY
WRITE_ERROR_DELETE_FILE
WRITE_ERROR_OPEN_PATCH_FILE
WRITE_ERROR_PATCH_FILE
WRITE_ERROR_APPLY_DIR_PATH
WRITE_ERROR_CALLBACK_PATH
WRITE_ERROR_FILE_ACCESS_DENIED
WRITE_ERROR_DIR_ACCESS_DENIED
WRITE_ERROR_DELETE_BACKUP
WRITE_ERROR_EXTRACT
WRITE_ERROR_BACKGROUND_TASK_SHARING_VIOLATION
]
;
const
SERVICE_ERRORS
=
[
SERVICE_UPDATER_COULD_NOT_BE_STARTED
SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS
SERVICE_UPDATER_SIGN_ERROR
SERVICE_UPDATER_COMPARE_ERROR
SERVICE_UPDATER_IDENTITY_ERROR
SERVICE_STILL_APPLYING_ON_SUCCESS
SERVICE_STILL_APPLYING_ON_FAILURE
SERVICE_UPDATER_NOT_FIXED_DRIVE
SERVICE_COULD_NOT_LOCK_UPDATER
SERVICE_INSTALLDIR_ERROR
SERVICE_COULD_NOT_COPY_UPDATER
SERVICE_STILL_APPLYING_TERMINATED
SERVICE_STILL_APPLYING_NO_EXIT_CODE
SERVICE_COULD_NOT_IMPERSONATE
]
;
const
BACKGROUNDCHECK_MULTIPLE_FAILURES
=
110
;
const
NETWORK_ERROR_OFFLINE
=
111
;
const
HTTP_ERROR_OFFSET
=
1000
;
const
HRESULT_E_ACCESSDENIED
=
-
2147024891
;
const
DOWNLOAD_CHUNK_SIZE
=
300000
;
const
DEFAULT_SERVICE_MAX_ERRORS
=
10
;
const
DEFAULT_SOCKET_MAX_ERRORS
=
10
;
const
DEFAULT_SOCKET_RETRYTIMEOUT
=
2000
;
const
DEFAULT_CANCELATIONS_OSX_MAX
=
3
;
const
APPID_TO_TOPIC
=
{
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
:
"
sessionstore
-
windows
-
restored
"
"
{
92650c4d
-
4b8e
-
4d2a
-
b7eb
-
24ecf4f6b63a
}
"
:
"
sessionstore
-
windows
-
restored
"
"
{
3550f703
-
e582
-
4d05
-
9a08
-
453d09bdfdc6
}
"
:
"
mail
-
startup
-
done
"
}
;
const
XML_SAVER_INTERVAL_MS
=
200
;
const
LANGPACK_UPDATE_DEFAULT_TIMEOUT
=
300000
;
const
ONLY_INSTANCE_CHECK_DEFAULT_POLL_INTERVAL_MS
=
5
*
60
*
1000
;
const
ONLY_INSTANCE_CHECK_DEFAULT_TIMEOUT_MS
=
6
*
60
*
60
*
1000
;
const
ONLY_INSTANCE_CHECK_MAX_TIMEOUT_MS
=
2
*
24
*
60
*
60
*
1000
;
const
STAGING_POLLING_MIN_INTERVAL_MS
=
15
*
1000
;
const
STAGING_POLLING_MAX_INTERVAL_MS
=
5
*
60
*
1000
;
const
STAGING_POLLING_ATTEMPTS_PER_INTERVAL
=
5
;
const
STAGING_POLLING_MAX_DURATION_MS
=
1
*
60
*
60
*
1000
;
var
gUpdateMutexHandle
=
null
;
var
gLogfileOutputStream
;
var
gBITSInUseByAnotherUser
=
false
;
let
gOnlyDownloadUpdatesThisSession
=
false
;
var
gUpdateState
=
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
;
class
SelfContainedPromise
{
constructor
(
)
{
this
.
promise
=
new
Promise
(
resolve
=
>
{
this
.
resolve
=
resolve
;
}
)
;
}
}
var
gStateTransitionPromise
=
new
SelfContainedPromise
(
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gLogEnabled
"
function
aus_gLogEnabled
(
)
{
return
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
|
|
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gLogfileEnabled
"
function
aus_gLogfileEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gUpdateBundle
"
function
aus_gUpdateBundle
(
)
{
return
Services
.
strings
.
createBundle
(
URI_UPDATES_PROPERTIES
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gIsBackgroundTaskMode
"
function
aus_gCurrentlyRunningAsBackgroundTask
(
)
{
if
(
!
(
"
mozilla
.
org
/
backgroundtasks
;
1
"
in
Cc
)
)
{
return
false
;
}
const
bts
=
Cc
[
"
mozilla
.
org
/
backgroundtasks
;
1
"
]
.
getService
(
Ci
.
nsIBackgroundTasks
)
;
if
(
!
bts
)
{
return
false
;
}
return
bts
.
isBackgroundTaskMode
;
}
)
;
function
transitionState
(
newState
)
{
if
(
newState
=
=
gUpdateState
)
{
LOG
(
"
transitionState
-
Not
transitioning
state
because
it
isn
'
t
changing
.
"
)
;
return
;
}
LOG
(
transitionState
-
"
{
lazy
.
AUS
.
getStateName
(
gUpdateState
)
}
"
-
>
+
"
{
lazy
.
AUS
.
getStateName
(
newState
)
}
"
.
)
;
gUpdateState
=
newState
;
let
oldStateTransitionPromise
=
gStateTransitionPromise
;
gStateTransitionPromise
=
new
SelfContainedPromise
(
)
;
oldStateTransitionPromise
.
resolve
(
)
;
}
function
unwrap
(
obj
)
{
return
obj
.
wrappedJSObject
?
?
obj
;
}
const
LangPackUpdates
=
new
WeakMap
(
)
;
let
gOtherInstancePollPromise
;
function
isOtherInstanceRunning
(
callback
)
{
const
checkEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_CHECK_ONLY_INSTANCE_ENABLED
true
)
;
if
(
!
checkEnabled
)
{
LOG
(
"
isOtherInstanceRunning
-
disabled
by
pref
skipping
check
"
)
;
return
false
;
}
try
{
let
syncManager
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
sync
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateSyncManager
)
;
return
syncManager
.
isOtherInstanceRunning
(
)
;
}
catch
(
ex
)
{
LOG
(
isOtherInstanceRunning
-
sync
manager
failed
with
exception
:
{
ex
}
)
;
return
false
;
}
}
function
waitForOtherInstances
(
)
{
if
(
gOtherInstancePollPromise
)
{
return
gOtherInstancePollPromise
;
}
let
timeout
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CHECK_ONLY_INSTANCE_TIMEOUT
ONLY_INSTANCE_CHECK_DEFAULT_TIMEOUT_MS
)
;
if
(
timeout
>
ONLY_INSTANCE_CHECK_MAX_TIMEOUT_MS
)
{
timeout
=
ONLY_INSTANCE_CHECK_MAX_TIMEOUT_MS
;
}
let
interval
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CHECK_ONLY_INSTANCE_INTERVAL
ONLY_INSTANCE_CHECK_DEFAULT_POLL_INTERVAL_MS
)
;
interval
=
Math
.
min
(
interval
timeout
)
;
let
iterations
=
0
;
const
maxIterations
=
Math
.
ceil
(
timeout
/
interval
)
;
gOtherInstancePollPromise
=
new
Promise
(
function
(
resolve
reject
)
{
let
poll
=
function
(
)
{
iterations
+
+
;
if
(
!
isOtherInstanceRunning
(
)
)
{
LOG
(
"
waitForOtherInstances
-
no
other
instances
found
exiting
"
)
;
resolve
(
false
)
;
gOtherInstancePollPromise
=
undefined
;
}
else
if
(
iterations
>
=
maxIterations
)
{
LOG
(
"
waitForOtherInstances
-
timeout
expired
while
other
instances
"
+
"
are
still
running
"
)
;
resolve
(
true
)
;
gOtherInstancePollPromise
=
undefined
;
}
else
if
(
iterations
+
1
=
=
maxIterations
&
&
timeout
%
interval
!
=
0
)
{
lazy
.
setTimeout
(
poll
timeout
%
interval
)
;
}
else
{
lazy
.
setTimeout
(
poll
interval
)
;
}
}
;
LOG
(
"
waitForOtherInstances
-
beginning
polling
"
)
;
poll
(
)
;
}
)
;
return
gOtherInstancePollPromise
;
}
function
testWriteAccess
(
updateTestFile
createDirectory
)
{
const
NORMAL_FILE_TYPE
=
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
;
const
DIRECTORY_TYPE
=
Ci
.
nsIFile
.
DIRECTORY_TYPE
;
if
(
updateTestFile
.
exists
(
)
)
{
updateTestFile
.
remove
(
false
)
;
}
updateTestFile
.
create
(
createDirectory
?
DIRECTORY_TYPE
:
NORMAL_FILE_TYPE
createDirectory
?
FileUtils
.
PERMS_DIRECTORY
:
FileUtils
.
PERMS_FILE
)
;
updateTestFile
.
remove
(
false
)
;
}
function
closeHandle
(
handle
)
{
if
(
handle
)
{
let
lib
=
lazy
.
ctypes
.
open
(
"
kernel32
.
dll
"
)
;
let
CloseHandle
=
lib
.
declare
(
"
CloseHandle
"
lazy
.
ctypes
.
winapi_abi
lazy
.
ctypes
.
int32_t
lazy
.
ctypes
.
void_t
.
ptr
)
;
CloseHandle
(
handle
)
;
lib
.
close
(
)
;
}
}
function
createMutex
(
aName
aAllowExisting
=
true
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
const
INITIAL_OWN
=
1
;
const
ERROR_ALREADY_EXISTS
=
0xb7
;
let
lib
=
lazy
.
ctypes
.
open
(
"
kernel32
.
dll
"
)
;
let
CreateMutexW
=
lib
.
declare
(
"
CreateMutexW
"
lazy
.
ctypes
.
winapi_abi
lazy
.
ctypes
.
void_t
.
ptr
lazy
.
ctypes
.
void_t
.
ptr
lazy
.
ctypes
.
int32_t
lazy
.
ctypes
.
char16_t
.
ptr
)
;
let
handle
=
CreateMutexW
(
null
INITIAL_OWN
aName
)
;
let
alreadyExists
=
lazy
.
ctypes
.
winLastError
=
=
ERROR_ALREADY_EXISTS
;
if
(
handle
&
&
!
handle
.
isNull
(
)
&
&
!
aAllowExisting
&
&
alreadyExists
)
{
closeHandle
(
handle
)
;
handle
=
null
;
}
lib
.
close
(
)
;
if
(
handle
&
&
handle
.
isNull
(
)
)
{
handle
=
null
;
}
return
handle
;
}
function
getPerInstallationMutexName
(
aGlobal
=
true
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA1
)
;
let
exeFile
=
Services
.
dirsvc
.
get
(
KEY_EXECUTABLE
Ci
.
nsIFile
)
;
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
var
data
=
converter
.
convertToByteArray
(
exeFile
.
path
.
toLowerCase
(
)
)
;
hasher
.
update
(
data
data
.
length
)
;
return
(
(
aGlobal
?
"
Global
\
\
"
:
"
"
)
+
"
MozillaUpdateMutex
-
"
+
hasher
.
finish
(
true
)
)
;
}
function
hasUpdateMutex
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
return
true
;
}
if
(
!
gUpdateMutexHandle
)
{
gUpdateMutexHandle
=
createMutex
(
getPerInstallationMutexName
(
true
)
false
)
;
}
return
!
!
gUpdateMutexHandle
;
}
function
areDirectoryEntriesWriteable
(
aDir
)
{
let
items
=
aDir
.
directoryEntries
;
while
(
items
.
hasMoreElements
(
)
)
{
let
item
=
items
.
nextFile
;
if
(
!
item
.
isWritable
(
)
)
{
LOG
(
"
areDirectoryEntriesWriteable
-
unable
to
write
to
"
+
item
.
path
)
;
return
false
;
}
if
(
item
.
isDirectory
(
)
&
&
!
areDirectoryEntriesWriteable
(
item
)
)
{
return
false
;
}
}
return
true
;
}
function
getElevationRequired
(
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
return
false
;
}
try
{
LOG
(
"
getElevationRequired
-
recursively
testing
write
access
on
"
+
getInstallDirRoot
(
)
.
path
)
;
if
(
!
getInstallDirRoot
(
)
.
isWritable
(
)
|
|
!
areDirectoryEntriesWriteable
(
getInstallDirRoot
(
)
)
)
{
LOG
(
"
getElevationRequired
-
unable
to
write
to
application
bundle
"
+
"
elevation
required
"
)
;
return
true
;
}
}
catch
(
ex
)
{
LOG
(
"
getElevationRequired
-
unable
to
write
to
application
bundle
"
+
"
elevation
required
.
Exception
:
"
+
ex
)
;
return
true
;
}
LOG
(
"
getElevationRequired
-
able
to
write
to
application
bundle
elevation
"
+
"
not
required
"
)
;
return
false
;
}
function
promiseLangPacksUpdated
(
update
)
{
let
promise
=
LangPackUpdates
.
get
(
unwrap
(
update
)
)
;
if
(
promise
)
{
LOG
(
"
promiseLangPacksUpdated
-
waiting
for
language
pack
updates
to
stage
.
"
)
;
return
promise
;
}
return
Promise
.
resolve
(
)
;
}
function
getCanApplyUpdates
(
)
{
try
{
let
updateTestFile
=
getUpdateFile
(
[
FILE_UPDATE_TEST
]
)
;
LOG
(
"
getCanApplyUpdates
-
testing
write
access
"
+
updateTestFile
.
path
)
;
testWriteAccess
(
updateTestFile
false
)
;
}
catch
(
e
)
{
LOG
(
"
getCanApplyUpdates
-
unable
to
apply
updates
without
write
"
+
"
access
to
the
update
directory
.
Exception
:
"
+
e
)
;
return
false
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
LOG
(
"
getCanApplyUpdates
-
bypass
the
write
since
elevation
can
be
used
"
+
"
on
Mac
OS
X
"
)
;
return
true
;
}
if
(
shouldUseService
(
)
)
{
LOG
(
"
getCanApplyUpdates
-
bypass
the
write
checks
because
the
Windows
"
+
"
Maintenance
Service
can
be
used
"
)
;
return
true
;
}
try
{
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
userCanElevate
=
Services
.
appinfo
.
QueryInterface
(
Ci
.
nsIWinAppHelper
)
.
userCanElevate
;
if
(
lazy
.
gIsBackgroundTaskMode
)
{
LOG
(
"
getCanApplyUpdates
-
in
background
task
mode
assuming
user
can
'
t
elevate
"
)
;
userCanElevate
=
false
;
}
if
(
!
userCanElevate
)
{
let
appDirTestFile
=
getAppBaseDir
(
)
;
appDirTestFile
.
append
(
FILE_UPDATE_TEST
)
;
LOG
(
"
getCanApplyUpdates
-
testing
write
access
"
+
appDirTestFile
.
path
)
;
if
(
appDirTestFile
.
exists
(
)
)
{
appDirTestFile
.
remove
(
false
)
;
}
appDirTestFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
appDirTestFile
.
remove
(
false
)
;
}
}
}
catch
(
e
)
{
LOG
(
"
getCanApplyUpdates
-
unable
to
apply
updates
.
Exception
:
"
+
e
)
;
return
false
;
}
LOG
(
"
getCanApplyUpdates
-
able
to
apply
updates
"
)
;
return
true
;
}
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gCanStageUpdatesSession
"
function
aus_gCSUS
(
)
{
if
(
getElevationRequired
(
)
)
{
LOG
(
"
gCanStageUpdatesSession
-
unable
to
stage
updates
because
elevation
"
+
"
is
required
.
"
)
;
return
false
;
}
try
{
let
updateTestFile
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
updateTestFile
=
getUpdateFile
(
[
FILE_UPDATE_TEST
]
)
;
}
else
{
updateTestFile
=
getInstallDirRoot
(
)
;
updateTestFile
.
append
(
FILE_UPDATE_TEST
)
;
}
LOG
(
"
gCanStageUpdatesSession
-
testing
write
access
"
+
updateTestFile
.
path
)
;
testWriteAccess
(
updateTestFile
true
)
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
updateTestFile
=
getInstallDirRoot
(
)
.
parent
;
updateTestFile
.
append
(
FILE_UPDATE_TEST
)
;
LOG
(
"
gCanStageUpdatesSession
-
testing
write
access
"
+
updateTestFile
.
path
)
;
updateTestFile
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
updateTestFile
.
remove
(
false
)
;
}
}
catch
(
e
)
{
LOG
(
"
gCanStageUpdatesSession
-
unable
to
stage
updates
.
Exception
:
"
+
e
)
;
return
false
;
}
LOG
(
"
gCanStageUpdatesSession
-
able
to
stage
updates
"
)
;
return
true
;
}
)
;
function
getCanStageUpdates
(
transient
=
true
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
false
)
)
{
LOG
(
"
getCanStageUpdates
-
staging
updates
is
disabled
by
preference
"
+
PREF_APP_UPDATE_STAGING_ENABLED
)
;
return
false
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
shouldUseService
(
)
)
{
LOG
(
"
getCanStageUpdates
-
able
to
stage
updates
using
the
service
"
)
;
return
true
;
}
if
(
transient
&
&
!
hasUpdateMutex
(
)
)
{
LOG
(
"
getCanStageUpdates
-
unable
to
apply
updates
because
another
"
+
"
instance
of
the
application
is
already
handling
updates
for
this
"
+
"
installation
.
"
)
;
return
false
;
}
return
lazy
.
gCanStageUpdatesSession
;
}
function
getCanUseBits
(
transient
=
true
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
LOG
(
"
getCanUseBits
-
Not
using
BITS
because
this
is
not
Windows
"
)
;
return
"
NoBits_NotWindows
"
;
}
if
(
!
AppConstants
.
MOZ_BITS_DOWNLOAD
)
{
LOG
(
"
getCanUseBits
-
Not
using
BITS
because
the
feature
is
disabled
"
)
;
return
"
NoBits_FeatureOff
"
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_BITS_ENABLED
true
)
)
{
LOG
(
"
getCanUseBits
-
Not
using
BITS
.
Disabled
by
pref
.
"
)
;
return
"
NoBits_Pref
"
;
}
let
defaultProxy
=
Ci
.
nsIProtocolProxyService
.
PROXYCONFIG_SYSTEM
;
if
(
Services
.
prefs
.
getIntPref
(
PREF_NETWORK_PROXY_TYPE
defaultProxy
)
!
=
defaultProxy
&
&
!
Cu
.
isInAutomation
)
{
LOG
(
"
getCanUseBits
-
Not
using
BITS
because
of
proxy
usage
"
)
;
return
"
NoBits_Proxy
"
;
}
if
(
transient
&
&
gBITSInUseByAnotherUser
)
{
LOG
(
"
getCanUseBits
-
Not
using
BITS
.
Already
in
use
by
another
user
"
)
;
return
"
NoBits_OtherUser
"
;
}
LOG
(
"
getCanUseBits
-
BITS
can
be
used
to
download
updates
"
)
;
return
"
CanUseBits
"
;
}
function
LOG
(
string
)
{
if
(
lazy
.
gLogEnabled
)
{
dump
(
"
*
*
*
AUS
:
SVC
"
+
string
+
"
\
n
"
)
;
if
(
!
Cu
.
isInAutomation
)
{
Services
.
console
.
logStringMessage
(
"
AUS
:
SVC
"
+
string
)
;
}
if
(
lazy
.
gLogfileEnabled
)
{
if
(
!
gLogfileOutputStream
)
{
let
logfile
=
Services
.
dirsvc
.
get
(
KEY_PROFILE_DIR
Ci
.
nsIFile
)
;
logfile
.
append
(
FILE_UPDATE_MESSAGES
)
;
gLogfileOutputStream
=
FileUtils
.
openAtomicFileOutputStream
(
logfile
)
;
}
try
{
let
encoded
=
new
TextEncoder
(
)
.
encode
(
string
+
"
\
n
"
)
;
gLogfileOutputStream
.
write
(
encoded
encoded
.
length
)
;
gLogfileOutputStream
.
flush
(
)
;
}
catch
(
e
)
{
dump
(
"
*
*
*
AUS
:
SVC
Unable
to
write
to
messages
file
:
"
+
e
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
"
AUS
:
SVC
Unable
to
write
to
messages
file
:
"
+
e
)
;
}
}
}
}
function
getUpdateDirCreate
(
pathArray
)
{
if
(
Cu
.
isInAutomation
)
{
const
MAGIC_TEST_ROOT_PREFIX
=
"
<
test
-
root
>
"
;
const
PREF_TEST_ROOT
=
"
mochitest
.
testRoot
"
;
let
alternatePath
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_ALTUPDATEDIRPATH
null
)
;
if
(
alternatePath
&
&
alternatePath
.
startsWith
(
MAGIC_TEST_ROOT_PREFIX
)
)
{
let
testRoot
=
Services
.
prefs
.
getCharPref
(
PREF_TEST_ROOT
)
;
let
relativePath
=
alternatePath
.
substring
(
MAGIC_TEST_ROOT_PREFIX
.
length
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
relativePath
=
relativePath
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
alternatePath
=
testRoot
+
relativePath
;
let
updateDir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
updateDir
.
initWithPath
(
alternatePath
)
;
for
(
let
i
=
0
;
i
<
pathArray
.
length
;
+
+
i
)
{
updateDir
.
append
(
pathArray
[
i
]
)
;
}
return
updateDir
;
}
}
return
FileUtils
.
getDir
(
KEY_UPDROOT
pathArray
true
)
;
}
function
getAppBaseDir
(
)
{
return
Services
.
dirsvc
.
get
(
KEY_EXECUTABLE
Ci
.
nsIFile
)
.
parent
;
}
function
getInstallDirRoot
(
)
{
let
dir
=
getAppBaseDir
(
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
dir
=
dir
.
parent
.
parent
;
}
return
dir
;
}
function
getUpdateFile
(
pathArray
)
{
let
file
=
getUpdateDirCreate
(
pathArray
.
slice
(
0
-
1
)
)
;
file
.
append
(
pathArray
[
pathArray
.
length
-
1
]
)
;
return
file
;
}
function
maybeMapErrorCode
(
code
)
{
switch
(
code
)
{
case
Cr
.
NS_BINDING_ABORTED
:
case
Cr
.
NS_ERROR_ABORT
:
return
"
connection_aborted
"
;
}
return
code
;
}
function
getStatusTextFromCode
(
code
defaultCode
)
{
code
=
maybeMapErrorCode
(
code
)
;
let
reason
;
try
{
reason
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
check_error
-
"
+
code
)
;
LOG
(
"
getStatusTextFromCode
-
transfer
error
:
"
+
reason
+
"
code
:
"
+
code
)
;
}
catch
(
e
)
{
defaultCode
=
maybeMapErrorCode
(
defaultCode
)
;
reason
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
check_error
-
"
+
defaultCode
)
;
LOG
(
"
getStatusTextFromCode
-
transfer
error
:
"
+
reason
+
"
default
code
:
"
+
defaultCode
)
;
}
return
reason
;
}
function
getReadyUpdateDir
(
)
{
return
getUpdateDirCreate
(
[
DIR_UPDATES
"
0
"
]
)
;
}
function
getDownloadingUpdateDir
(
)
{
return
getUpdateDirCreate
(
[
DIR_UPDATES
"
downloading
"
]
)
;
}
function
readStatusFile
(
dir
)
{
let
statusFile
=
dir
.
clone
(
)
;
statusFile
.
append
(
FILE_UPDATE_STATUS
)
;
let
status
=
readStringFromFile
(
statusFile
)
|
|
STATE_NONE
;
LOG
(
"
readStatusFile
-
status
:
"
+
status
+
"
path
:
"
+
statusFile
.
path
)
;
return
status
;
}
function
readBinaryTransparencyResult
(
dir
)
{
let
binaryTransparencyResultFile
=
dir
.
clone
(
)
;
binaryTransparencyResultFile
.
append
(
FILE_BT_RESULT
)
;
let
result
=
readStringFromFile
(
binaryTransparencyResultFile
)
;
LOG
(
"
readBinaryTransparencyResult
-
result
:
"
+
result
+
"
path
:
"
+
binaryTransparencyResultFile
.
path
)
;
if
(
result
)
{
binaryTransparencyResultFile
.
remove
(
false
)
;
}
return
result
;
}
function
writeStatusFile
(
dir
state
)
{
let
statusFile
=
dir
.
clone
(
)
;
statusFile
.
append
(
FILE_UPDATE_STATUS
)
;
writeStringToFile
(
statusFile
state
)
;
}
function
writeVersionFile
(
dir
version
)
{
let
versionFile
=
dir
.
clone
(
)
;
versionFile
.
append
(
FILE_UPDATE_VERSION
)
;
writeStringToFile
(
versionFile
version
)
;
}
function
shouldUseService
(
)
{
if
(
!
AppConstants
.
MOZ_MAINTENANCE_SERVICE
|
|
!
isServiceInstalled
(
)
|
|
!
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
false
)
)
{
LOG
(
"
shouldUseService
-
returning
false
"
)
;
return
false
;
}
LOG
(
"
shouldUseService
-
returning
true
"
)
;
return
true
;
}
function
isServiceInstalled
(
)
{
if
(
!
AppConstants
.
MOZ_MAINTENANCE_SERVICE
|
|
AppConstants
.
platform
!
=
"
win
"
)
{
LOG
(
"
isServiceInstalled
-
returning
false
"
)
;
return
false
;
}
let
installed
=
0
;
try
{
let
wrk
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
wrk
.
open
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
"
SOFTWARE
\
\
Mozilla
\
\
MaintenanceService
"
wrk
.
ACCESS_READ
|
wrk
.
WOW64_64
)
;
installed
=
wrk
.
readIntValue
(
"
Installed
"
)
;
wrk
.
close
(
)
;
}
catch
(
e
)
{
}
installed
=
installed
=
=
1
;
LOG
(
"
isServiceInstalled
-
returning
"
+
installed
)
;
return
installed
;
}
function
getBestPendingState
(
)
{
if
(
shouldUseService
(
)
)
{
return
STATE_PENDING_SERVICE
;
}
else
if
(
getElevationRequired
(
)
)
{
return
STATE_PENDING_ELEVATE
;
}
return
STATE_PENDING
;
}
function
cleanUpReadyUpdateDir
(
aRemovePatchFiles
=
true
)
{
let
updateDir
;
try
{
updateDir
=
getReadyUpdateDir
(
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpReadyUpdateDir
-
unable
to
get
the
updates
patch
directory
.
"
+
"
Exception
:
"
+
e
)
;
return
;
}
let
updateLogFile
=
updateDir
.
clone
(
)
;
updateLogFile
.
append
(
FILE_UPDATE_LOG
)
;
if
(
updateLogFile
.
exists
(
)
)
{
let
dir
=
updateDir
.
parent
;
let
logFile
=
dir
.
clone
(
)
;
logFile
.
append
(
FILE_LAST_UPDATE_LOG
)
;
if
(
logFile
.
exists
(
)
)
{
try
{
logFile
.
moveTo
(
dir
FILE_BACKUP_UPDATE_LOG
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpReadyUpdateDir
-
failed
to
rename
file
"
+
logFile
.
path
+
"
to
"
+
FILE_BACKUP_UPDATE_LOG
)
;
}
}
try
{
updateLogFile
.
moveTo
(
dir
FILE_LAST_UPDATE_LOG
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpReadyUpdateDir
-
failed
to
rename
file
"
+
updateLogFile
.
path
+
"
to
"
+
FILE_LAST_UPDATE_LOG
)
;
}
}
if
(
aRemovePatchFiles
)
{
let
dirEntries
=
updateDir
.
directoryEntries
;
while
(
dirEntries
.
hasMoreElements
(
)
)
{
let
file
=
dirEntries
.
nextFile
;
try
{
file
.
remove
(
true
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpReadyUpdateDir
-
failed
to
remove
file
"
+
file
.
path
)
;
}
}
}
}
function
cleanUpDownloadingUpdateDir
(
)
{
let
updateDir
;
try
{
updateDir
=
getDownloadingUpdateDir
(
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpDownloadUpdatesDir
-
unable
to
get
the
updates
patch
"
+
"
directory
.
Exception
:
"
+
e
)
;
return
;
}
let
dirEntries
=
updateDir
.
directoryEntries
;
while
(
dirEntries
.
hasMoreElements
(
)
)
{
let
file
=
dirEntries
.
nextFile
;
try
{
file
.
remove
(
true
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpDownloadUpdatesDir
-
failed
to
remove
file
"
+
file
.
path
)
;
}
}
}
function
cleanupReadyUpdate
(
)
{
if
(
lazy
.
UM
.
readyUpdate
)
{
LOG
(
"
cleanupReadyUpdate
-
Clearing
readyUpdate
"
)
;
lazy
.
UM
.
addUpdateToHistory
(
lazy
.
UM
.
readyUpdate
)
;
lazy
.
UM
.
readyUpdate
=
null
;
}
lazy
.
UM
.
saveUpdates
(
)
;
let
readyUpdateDir
=
getReadyUpdateDir
(
)
;
let
shouldSetDownloadingStatus
=
lazy
.
UM
.
downloadingUpdate
|
|
readStatusFile
(
readyUpdateDir
)
=
=
STATE_DOWNLOADING
;
cleanUpReadyUpdateDir
(
)
;
if
(
shouldSetDownloadingStatus
)
{
LOG
(
"
cleanupReadyUpdate
-
Transitioning
back
to
downloading
state
.
"
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
)
;
writeStatusFile
(
readyUpdateDir
STATE_DOWNLOADING
)
;
}
}
function
cleanupDownloadingUpdate
(
)
{
if
(
lazy
.
UM
.
downloadingUpdate
)
{
LOG
(
"
cleanupDownloadingUpdate
-
Clearing
downloadingUpdate
.
"
)
;
lazy
.
UM
.
addUpdateToHistory
(
lazy
.
UM
.
downloadingUpdate
)
;
lazy
.
UM
.
downloadingUpdate
=
null
;
}
lazy
.
UM
.
saveUpdates
(
)
;
cleanUpDownloadingUpdateDir
(
)
;
let
readyUpdateDir
=
getReadyUpdateDir
(
)
;
let
status
=
readStatusFile
(
readyUpdateDir
)
;
if
(
status
=
=
STATE_DOWNLOADING
)
{
let
statusFile
=
readyUpdateDir
.
clone
(
)
;
statusFile
.
append
(
FILE_UPDATE_STATUS
)
;
statusFile
.
remove
(
)
;
}
}
function
cleanupActiveUpdates
(
)
{
if
(
lazy
.
UM
.
readyUpdate
)
{
LOG
(
"
cleanupActiveUpdates
-
Clearing
readyUpdate
"
)
;
lazy
.
UM
.
addUpdateToHistory
(
lazy
.
UM
.
readyUpdate
)
;
lazy
.
UM
.
readyUpdate
=
null
;
}
if
(
lazy
.
UM
.
downloadingUpdate
)
{
LOG
(
"
cleanupActiveUpdates
-
Clearing
downloadingUpdate
.
"
)
;
lazy
.
UM
.
addUpdateToHistory
(
lazy
.
UM
.
downloadingUpdate
)
;
lazy
.
UM
.
downloadingUpdate
=
null
;
}
lazy
.
UM
.
saveUpdates
(
)
;
cleanUpReadyUpdateDir
(
)
;
cleanUpDownloadingUpdateDir
(
)
;
}
function
writeStringToFile
(
file
text
)
{
try
{
let
fos
=
FileUtils
.
openSafeFileOutputStream
(
file
)
;
text
+
=
"
\
n
"
;
fos
.
write
(
text
text
.
length
)
;
FileUtils
.
closeSafeFileOutputStream
(
fos
)
;
}
catch
(
e
)
{
LOG
(
writeStringToFile
-
Failed
to
write
to
file
:
"
{
file
}
"
.
Error
:
{
e
}
"
)
;
return
false
;
}
return
true
;
}
function
readStringFromInputStream
(
inputStream
)
{
var
sis
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableInputStream
)
;
sis
.
init
(
inputStream
)
;
var
text
=
sis
.
read
(
sis
.
available
(
)
)
;
sis
.
close
(
)
;
if
(
text
&
&
text
[
text
.
length
-
1
]
=
=
"
\
n
"
)
{
text
=
text
.
slice
(
0
-
1
)
;
}
return
text
;
}
function
readStringFromFile
(
file
)
{
if
(
!
file
.
exists
(
)
)
{
LOG
(
"
readStringFromFile
-
file
doesn
'
t
exist
:
"
+
file
.
path
)
;
return
null
;
}
var
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
file
FileUtils
.
MODE_RDONLY
FileUtils
.
PERMS_FILE
0
)
;
return
readStringFromInputStream
(
fis
)
;
}
function
handleUpdateFailure
(
update
)
{
if
(
WRITE_ERRORS
.
includes
(
update
.
errorCode
)
)
{
LOG
(
"
handleUpdateFailure
-
Failure
is
a
write
error
.
Setting
state
to
pending
"
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
(
update
.
state
=
STATE_PENDING
)
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
;
return
true
;
}
if
(
update
.
errorCode
=
=
SILENT_UPDATE_NEEDED_ELEVATION_ERROR
)
{
let
bestState
=
getBestPendingState
(
)
;
LOG
(
"
handleUpdateFailure
-
witnessed
SILENT_UPDATE_NEEDED_ELEVATION_ERROR
"
+
"
returning
to
"
+
bestState
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
(
update
.
state
=
bestState
)
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
;
return
true
;
}
if
(
update
.
errorCode
=
=
ELEVATION_CANCELED
)
{
let
elevationAttempts
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_ELEVATE_ATTEMPTS
0
)
;
elevationAttempts
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_ELEVATE_ATTEMPTS
elevationAttempts
)
;
let
maxAttempts
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_ELEVATE_MAXATTEMPTS
2
)
10
)
;
if
(
elevationAttempts
>
maxAttempts
)
{
LOG
(
"
handleUpdateFailure
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
elevation
-
attempts
-
exceeded
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
elevation
-
attempts
-
exceeded
"
)
;
}
else
{
LOG
(
"
handleUpdateFailure
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
elevation
-
attempt
-
failed
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
elevation
-
attempt
-
failed
"
)
;
}
let
cancelations
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS
0
)
;
cancelations
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_CANCELATIONS
cancelations
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
osxCancelations
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
0
)
;
osxCancelations
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
osxCancelations
)
;
let
maxCancels
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX_MAX
DEFAULT_CANCELATIONS_OSX_MAX
)
;
maxCancels
=
Math
.
min
(
maxCancels
5
)
;
if
(
osxCancelations
>
=
maxCancels
)
{
LOG
(
"
handleUpdateFailure
-
Too
many
OSX
cancellations
.
Cleaning
up
"
+
"
ready
update
.
"
)
;
cleanupReadyUpdate
(
)
;
return
false
;
}
LOG
(
handleUpdateFailure
-
OSX
cancellation
.
Trying
again
by
setting
+
status
to
"
{
STATE_PENDING_ELEVATE
}
"
.
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
(
update
.
state
=
STATE_PENDING_ELEVATE
)
)
;
update
.
statusText
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
elevationFailure
"
)
;
}
else
{
LOG
(
"
handleUpdateFailure
-
Failure
because
elevation
was
cancelled
.
"
+
"
again
by
setting
status
to
pending
.
"
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
(
update
.
state
=
STATE_PENDING
)
)
;
}
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
;
return
true
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
SERVICE_ERRORS
.
includes
(
update
.
errorCode
)
)
{
var
failCount
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_SERVICE_ERRORS
0
)
;
var
maxFail
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_SERVICE_MAXERRORS
DEFAULT_SERVICE_MAX_ERRORS
)
;
maxFail
=
Math
.
min
(
maxFail
10
)
;
if
(
failCount
>
=
maxFail
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
false
)
;
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_SERVICE_ERRORS
)
;
}
else
{
failCount
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_SERVICE_ERRORS
failCount
)
;
}
LOG
(
"
handleUpdateFailure
-
Got
a
service
error
.
Try
to
update
without
the
"
+
"
service
by
setting
the
state
to
pending
.
"
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
(
update
.
state
=
STATE_PENDING
)
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
;
return
true
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_SERVICE_ERRORS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_SERVICE_ERRORS
)
;
}
return
false
;
}
function
getPatchOfType
(
update
patch_type
)
{
for
(
var
i
=
0
;
i
<
update
.
patchCount
;
+
+
i
)
{
var
patch
=
update
.
getPatchAt
(
i
)
;
if
(
patch
&
&
patch
.
type
=
=
patch_type
)
{
return
patch
;
}
}
return
null
;
}
async
function
handleFallbackToCompleteUpdate
(
)
{
let
update
=
lazy
.
UM
.
downloadingUpdate
|
|
lazy
.
UM
.
readyUpdate
;
if
(
!
update
)
{
LOG
(
"
handleFallbackToCompleteUpdate
-
Unable
to
find
an
update
to
fall
"
+
"
back
to
.
"
)
;
return
;
}
LOG
(
"
handleFallbackToCompleteUpdate
-
Cleaning
up
active
updates
in
"
+
"
preparation
of
falling
back
to
complete
update
.
"
)
;
await
lazy
.
AUS
.
stopDownload
(
)
;
cleanupActiveUpdates
(
)
;
if
(
!
update
.
selectedPatch
)
{
let
patch
=
getPatchOfType
(
update
"
partial
"
)
;
if
(
patch
)
{
patch
.
selected
=
true
;
}
}
update
.
statusText
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
patchApplyFailure
"
)
;
var
oldType
=
update
.
selectedPatch
?
update
.
selectedPatch
.
type
:
"
complete
"
;
if
(
update
.
selectedPatch
&
&
oldType
=
=
"
partial
"
&
&
update
.
patchCount
=
=
2
)
{
LOG
(
"
handleFallbackToCompleteUpdate
-
install
of
partial
patch
"
+
"
failed
downloading
complete
patch
"
)
;
var
success
=
await
lazy
.
AUS
.
downloadUpdate
(
update
)
;
if
(
!
success
)
{
LOG
(
"
handleFallbackToCompleteUpdate
-
Starting
complete
patch
download
"
+
"
failed
.
Cleaning
up
downloading
patch
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
}
else
{
LOG
(
"
handleFallbackToCompleteUpdate
-
install
of
complete
or
"
+
"
only
one
patch
offered
failed
.
Notifying
observers
.
topic
:
"
+
"
update
-
error
status
:
unknown
"
+
"
update
.
patchCount
:
"
+
update
.
patchCount
+
"
"
+
"
oldType
:
"
+
oldType
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
unknown
"
)
;
}
}
function
pingStateAndStatusCodes
(
aUpdate
aStartup
aStatus
)
{
let
patchType
=
AUSTLMY
.
PATCH_UNKNOWN
;
if
(
aUpdate
&
&
aUpdate
.
selectedPatch
&
&
aUpdate
.
selectedPatch
.
type
)
{
if
(
aUpdate
.
selectedPatch
.
type
=
=
"
complete
"
)
{
patchType
=
AUSTLMY
.
PATCH_COMPLETE
;
}
else
if
(
aUpdate
.
selectedPatch
.
type
=
=
"
partial
"
)
{
patchType
=
AUSTLMY
.
PATCH_PARTIAL
;
}
}
let
suffix
=
patchType
+
"
_
"
+
(
aStartup
?
AUSTLMY
.
STARTUP
:
AUSTLMY
.
STAGE
)
;
let
stateCode
=
0
;
let
parts
=
aStatus
.
split
(
"
:
"
)
;
if
(
parts
.
length
)
{
switch
(
parts
[
0
]
)
{
case
STATE_NONE
:
stateCode
=
2
;
break
;
case
STATE_DOWNLOADING
:
stateCode
=
3
;
break
;
case
STATE_PENDING
:
stateCode
=
4
;
break
;
case
STATE_PENDING_SERVICE
:
stateCode
=
5
;
break
;
case
STATE_APPLYING
:
stateCode
=
6
;
break
;
case
STATE_APPLIED
:
stateCode
=
7
;
break
;
case
STATE_APPLIED_SERVICE
:
stateCode
=
9
;
break
;
case
STATE_SUCCEEDED
:
stateCode
=
10
;
break
;
case
STATE_DOWNLOAD_FAILED
:
stateCode
=
11
;
break
;
case
STATE_FAILED
:
stateCode
=
12
;
break
;
case
STATE_PENDING_ELEVATE
:
stateCode
=
13
;
break
;
default
:
stateCode
=
1
;
}
if
(
parts
.
length
>
1
)
{
let
statusErrorCode
=
INVALID_UPDATER_STATE_CODE
;
if
(
parts
[
0
]
=
=
STATE_FAILED
)
{
statusErrorCode
=
parseInt
(
parts
[
1
]
)
|
|
INVALID_UPDATER_STATUS_CODE
;
}
AUSTLMY
.
pingStatusErrorCode
(
suffix
statusErrorCode
)
;
}
}
let
binaryTransparencyResult
=
readBinaryTransparencyResult
(
getReadyUpdateDir
(
)
)
;
if
(
binaryTransparencyResult
)
{
AUSTLMY
.
pingBinaryTransparencyResult
(
suffix
parseInt
(
binaryTransparencyResult
)
)
;
}
AUSTLMY
.
pingStateCode
(
suffix
stateCode
)
;
}
function
updateIsAtLeastAsOldAs
(
update
version
buildID
)
{
if
(
!
update
|
|
!
update
.
appVersion
|
|
!
update
.
buildID
)
{
return
false
;
}
let
versionComparison
=
Services
.
vc
.
compare
(
update
.
appVersion
version
)
;
return
(
versionComparison
<
0
|
|
(
versionComparison
=
=
0
&
&
update
.
buildID
=
=
buildID
)
)
;
}
function
updateIsAtLeastAsOldAsCurrentVersion
(
update
)
{
return
updateIsAtLeastAsOldAs
(
update
Services
.
appinfo
.
version
Services
.
appinfo
.
appBuildID
)
;
}
function
updateIsAtLeastAsOldAsReadyUpdate
(
update
)
{
if
(
!
lazy
.
UM
.
readyUpdate
|
|
!
lazy
.
UM
.
readyUpdate
.
appVersion
|
|
!
lazy
.
UM
.
readyUpdate
.
buildID
)
{
return
false
;
}
return
updateIsAtLeastAsOldAs
(
update
lazy
.
UM
.
readyUpdate
.
appVersion
lazy
.
UM
.
readyUpdate
.
buildID
)
;
}
function
isServiceSpecificErrorCode
(
errorCode
)
{
return
(
(
errorCode
>
=
24
&
&
errorCode
<
=
33
)
|
|
(
errorCode
>
=
49
&
&
errorCode
<
=
58
)
)
;
}
function
pollForStagingEnd
(
)
{
let
pollingIntervalMs
=
STAGING_POLLING_MIN_INTERVAL_MS
;
let
pollAttemptsAtIntervalRemaining
=
STAGING_POLLING_ATTEMPTS_PER_INTERVAL
;
let
timeElapsedMs
=
0
;
let
pollingFn
=
(
)
=
>
{
pollAttemptsAtIntervalRemaining
-
=
1
;
timeElapsedMs
+
=
pollingIntervalMs
;
if
(
timeElapsedMs
>
=
STAGING_POLLING_MAX_DURATION_MS
)
{
lazy
.
UM
.
refreshUpdateStatus
(
)
;
return
;
}
if
(
readStatusFile
(
getReadyUpdateDir
(
)
)
!
=
STATE_APPLYING
)
{
lazy
.
UM
.
refreshUpdateStatus
(
)
;
return
;
}
if
(
pollAttemptsAtIntervalRemaining
<
=
0
)
{
pollingIntervalMs
=
Math
.
min
(
pollingIntervalMs
*
2
STAGING_POLLING_MAX_INTERVAL_MS
)
;
pollAttemptsAtIntervalRemaining
=
STAGING_POLLING_ATTEMPTS_PER_INTERVAL
;
}
lazy
.
setTimeout
(
pollingFn
pollingIntervalMs
)
;
}
;
lazy
.
setTimeout
(
pollingFn
pollingIntervalMs
)
;
}
function
UpdatePatch
(
patch
)
{
this
.
_properties
=
{
}
;
this
.
errorCode
=
0
;
this
.
finalURL
=
null
;
this
.
state
=
STATE_NONE
;
for
(
let
i
=
0
;
i
<
patch
.
attributes
.
length
;
+
+
i
)
{
var
attr
=
patch
.
attributes
.
item
(
i
)
;
if
(
attr
.
value
=
=
"
undefined
"
)
{
continue
;
}
switch
(
attr
.
name
)
{
case
"
xmlns
"
:
break
;
case
"
selected
"
:
this
.
selected
=
attr
.
value
=
=
"
true
"
;
break
;
case
"
size
"
:
if
(
0
=
=
parseInt
(
attr
.
value
)
)
{
LOG
(
"
UpdatePatch
:
init
-
0
-
sized
patch
!
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
this
[
attr
.
name
]
=
attr
.
value
;
break
;
case
"
errorCode
"
:
if
(
attr
.
value
)
{
let
val
=
parseInt
(
attr
.
value
)
;
if
(
val
)
{
this
.
errorCode
=
val
;
}
}
break
;
case
"
finalURL
"
:
case
"
state
"
:
case
"
type
"
:
case
"
URL
"
:
this
[
attr
.
name
]
=
attr
.
value
;
break
;
default
:
if
(
!
this
.
_attrNames
.
includes
(
attr
.
name
)
)
{
this
.
setProperty
(
attr
.
name
attr
.
value
)
;
}
break
;
}
}
}
UpdatePatch
.
prototype
=
{
_attrNames
:
[
"
errorCode
"
"
finalURL
"
"
selected
"
"
size
"
"
state
"
"
type
"
"
URL
"
]
serialize
:
function
UpdatePatch_serialize
(
updates
)
{
var
patch
=
updates
.
createElementNS
(
URI_UPDATE_NS
"
patch
"
)
;
patch
.
setAttribute
(
"
size
"
this
.
size
)
;
patch
.
setAttribute
(
"
type
"
this
.
type
)
;
patch
.
setAttribute
(
"
URL
"
this
.
URL
)
;
if
(
this
.
errorCode
)
{
patch
.
setAttribute
(
"
errorCode
"
this
.
errorCode
)
;
}
if
(
this
.
finalURL
)
{
patch
.
setAttribute
(
"
finalURL
"
this
.
finalURL
)
;
}
if
(
this
.
selected
)
{
patch
.
setAttribute
(
"
selected
"
this
.
selected
)
;
}
if
(
this
.
state
!
=
STATE_NONE
)
{
patch
.
setAttribute
(
"
state
"
this
.
state
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
_properties
)
)
{
if
(
value
.
present
&
&
!
this
.
_attrNames
.
includes
(
name
)
)
{
patch
.
setAttribute
(
name
value
.
data
)
;
}
}
return
patch
;
}
setProperty
:
function
UpdatePatch_setProperty
(
name
value
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdatePatch
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
setProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
this
.
_properties
[
name
]
=
{
data
:
value
present
:
true
}
;
}
deleteProperty
:
function
UpdatePatch_deleteProperty
(
name
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdatePatch
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
deleteProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
name
in
this
.
_properties
)
{
this
.
_properties
[
name
]
.
present
=
false
;
}
else
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
get
enumerator
(
)
{
return
this
.
enumerate
(
)
;
}
*
enumerate
(
)
{
let
ip
=
Cc
[
"
mozilla
.
org
/
supports
-
interface
-
pointer
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsInterfacePointer
)
;
let
qi
=
ChromeUtils
.
generateQI
(
[
"
nsIProperty
"
]
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
_properties
)
)
{
if
(
value
.
present
&
&
!
this
.
_attrNames
.
includes
(
name
)
)
{
ip
.
data
=
{
name
value
:
value
.
data
QueryInterface
:
qi
}
;
yield
ip
.
data
.
QueryInterface
(
Ci
.
nsIProperty
)
;
}
}
}
getProperty
:
function
UpdatePatch_getProperty
(
name
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdatePatch
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
getProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
name
in
this
.
_properties
&
&
this
.
_properties
[
name
]
.
present
)
{
return
this
.
_properties
[
name
]
.
data
;
}
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdatePatch
"
"
nsIPropertyBag
"
"
nsIWritablePropertyBag
"
]
)
}
;
function
Update
(
update
)
{
this
.
_patches
=
[
]
;
this
.
_properties
=
{
}
;
this
.
isCompleteUpdate
=
false
;
this
.
channel
=
"
default
"
;
this
.
promptWaitTime
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_PROMPTWAITTIME
43200
)
;
this
.
unsupported
=
false
;
if
(
!
update
)
{
return
;
}
for
(
let
i
=
0
;
i
<
update
.
childNodes
.
length
;
+
+
i
)
{
let
patchElement
=
update
.
childNodes
.
item
(
i
)
;
if
(
patchElement
.
nodeType
!
=
patchElement
.
ELEMENT_NODE
|
|
patchElement
.
localName
!
=
"
patch
"
)
{
continue
;
}
let
patch
;
try
{
patch
=
new
UpdatePatch
(
patchElement
)
;
}
catch
(
e
)
{
continue
;
}
this
.
_patches
.
push
(
patch
)
;
}
if
(
!
this
.
_patches
.
length
&
&
!
update
.
hasAttribute
(
"
unsupported
"
)
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
this
.
installDate
=
new
Date
(
)
.
getTime
(
)
;
this
.
patchCount
=
this
.
_patches
.
length
;
for
(
let
i
=
0
;
i
<
update
.
attributes
.
length
;
+
+
i
)
{
let
attr
=
update
.
attributes
.
item
(
i
)
;
if
(
attr
.
name
=
=
"
xmlns
"
|
|
attr
.
value
=
=
"
undefined
"
)
{
continue
;
}
else
if
(
attr
.
name
=
=
"
detailsURL
"
)
{
this
.
detailsURL
=
attr
.
value
;
}
else
if
(
attr
.
name
=
=
"
installDate
"
&
&
attr
.
value
)
{
let
val
=
parseInt
(
attr
.
value
)
;
if
(
val
)
{
this
.
installDate
=
val
;
}
}
else
if
(
attr
.
name
=
=
"
errorCode
"
&
&
attr
.
value
)
{
let
val
=
parseInt
(
attr
.
value
)
;
if
(
val
)
{
this
.
_errorCode
=
val
;
}
}
else
if
(
attr
.
name
=
=
"
isCompleteUpdate
"
)
{
this
.
isCompleteUpdate
=
attr
.
value
=
=
"
true
"
;
}
else
if
(
attr
.
name
=
=
"
promptWaitTime
"
)
{
if
(
!
isNaN
(
attr
.
value
)
)
{
this
.
promptWaitTime
=
parseInt
(
attr
.
value
)
;
}
}
else
if
(
attr
.
name
=
=
"
unsupported
"
)
{
this
.
unsupported
=
attr
.
value
=
=
"
true
"
;
}
else
{
switch
(
attr
.
name
)
{
case
"
appVersion
"
:
case
"
buildID
"
:
case
"
channel
"
:
case
"
displayVersion
"
:
case
"
elevationFailure
"
:
case
"
name
"
:
case
"
previousAppVersion
"
:
case
"
serviceURL
"
:
case
"
statusText
"
:
case
"
type
"
:
this
[
attr
.
name
]
=
attr
.
value
;
break
;
default
:
if
(
!
this
.
_attrNames
.
includes
(
attr
.
name
)
)
{
this
.
setProperty
(
attr
.
name
attr
.
value
)
;
}
break
;
}
}
}
if
(
!
this
.
previousAppVersion
)
{
this
.
previousAppVersion
=
Services
.
appinfo
.
version
;
}
if
(
!
this
.
elevationFailure
)
{
this
.
elevationFailure
=
false
;
}
if
(
!
this
.
detailsURL
)
{
try
{
this
.
detailsURL
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_APP_UPDATE_URL_DETAILS
)
;
}
catch
(
e
)
{
this
.
detailsURL
=
"
"
;
}
}
if
(
!
this
.
displayVersion
)
{
this
.
displayVersion
=
this
.
appVersion
;
}
if
(
!
this
.
name
)
{
let
brandBundle
=
Services
.
strings
.
createBundle
(
URI_BRAND_PROPERTIES
)
;
let
appName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
this
.
name
=
lazy
.
gUpdateBundle
.
formatStringFromName
(
"
updateName
"
[
appName
this
.
displayVersion
]
)
;
}
}
Update
.
prototype
=
{
_attrNames
:
[
"
appVersion
"
"
buildID
"
"
channel
"
"
detailsURL
"
"
displayVersion
"
"
elevationFailure
"
"
errorCode
"
"
installDate
"
"
isCompleteUpdate
"
"
name
"
"
previousAppVersion
"
"
promptWaitTime
"
"
serviceURL
"
"
state
"
"
statusText
"
"
type
"
"
unsupported
"
]
getPatchAt
:
function
Update_getPatchAt
(
index
)
{
return
this
.
_patches
[
index
]
;
}
_state
:
"
"
get
state
(
)
{
if
(
this
.
selectedPatch
)
{
return
this
.
selectedPatch
.
state
;
}
return
this
.
_state
;
}
set
state
(
state
)
{
if
(
this
.
selectedPatch
)
{
this
.
selectedPatch
.
state
=
state
;
}
this
.
_state
=
state
;
}
_errorCode
:
0
get
errorCode
(
)
{
if
(
this
.
selectedPatch
)
{
return
this
.
selectedPatch
.
errorCode
;
}
return
this
.
_errorCode
;
}
set
errorCode
(
errorCode
)
{
if
(
this
.
selectedPatch
)
{
this
.
selectedPatch
.
errorCode
=
errorCode
;
}
this
.
_errorCode
=
errorCode
;
}
get
selectedPatch
(
)
{
for
(
let
i
=
0
;
i
<
this
.
patchCount
;
+
+
i
)
{
if
(
this
.
_patches
[
i
]
.
selected
)
{
return
this
.
_patches
[
i
]
;
}
}
return
null
;
}
serialize
:
function
Update_serialize
(
updates
)
{
if
(
!
this
.
appVersion
)
{
return
null
;
}
let
update
=
updates
.
createElementNS
(
URI_UPDATE_NS
"
update
"
)
;
update
.
setAttribute
(
"
appVersion
"
this
.
appVersion
)
;
update
.
setAttribute
(
"
buildID
"
this
.
buildID
)
;
update
.
setAttribute
(
"
channel
"
this
.
channel
)
;
update
.
setAttribute
(
"
detailsURL
"
this
.
detailsURL
)
;
update
.
setAttribute
(
"
displayVersion
"
this
.
displayVersion
)
;
update
.
setAttribute
(
"
installDate
"
this
.
installDate
)
;
update
.
setAttribute
(
"
isCompleteUpdate
"
this
.
isCompleteUpdate
)
;
update
.
setAttribute
(
"
name
"
this
.
name
)
;
update
.
setAttribute
(
"
previousAppVersion
"
this
.
previousAppVersion
)
;
update
.
setAttribute
(
"
promptWaitTime
"
this
.
promptWaitTime
)
;
update
.
setAttribute
(
"
serviceURL
"
this
.
serviceURL
)
;
update
.
setAttribute
(
"
type
"
this
.
type
)
;
if
(
this
.
statusText
)
{
update
.
setAttribute
(
"
statusText
"
this
.
statusText
)
;
}
if
(
this
.
unsupported
)
{
update
.
setAttribute
(
"
unsupported
"
this
.
unsupported
)
;
}
if
(
this
.
elevationFailure
)
{
update
.
setAttribute
(
"
elevationFailure
"
this
.
elevationFailure
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
_properties
)
)
{
if
(
value
.
present
&
&
!
this
.
_attrNames
.
includes
(
name
)
)
{
update
.
setAttribute
(
name
value
.
data
)
;
}
}
for
(
let
i
=
0
;
i
<
this
.
patchCount
;
+
+
i
)
{
update
.
appendChild
(
this
.
getPatchAt
(
i
)
.
serialize
(
updates
)
)
;
}
updates
.
documentElement
.
appendChild
(
update
)
;
return
update
;
}
setProperty
:
function
Update_setProperty
(
name
value
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdate
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
setProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
this
.
_properties
[
name
]
=
{
data
:
value
present
:
true
}
;
}
deleteProperty
:
function
Update_deleteProperty
(
name
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdate
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
deleteProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
name
in
this
.
_properties
)
{
this
.
_properties
[
name
]
.
present
=
false
;
}
else
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_FAILURE
)
;
}
}
get
enumerator
(
)
{
return
this
.
enumerate
(
)
;
}
*
enumerate
(
)
{
let
ip
=
Cc
[
"
mozilla
.
org
/
supports
-
interface
-
pointer
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsInterfacePointer
)
;
let
qi
=
ChromeUtils
.
generateQI
(
[
"
nsIProperty
"
]
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
_properties
)
)
{
if
(
value
.
present
&
&
!
this
.
_attrNames
.
includes
(
name
)
)
{
ip
.
data
=
{
name
value
:
value
.
data
QueryInterface
:
qi
}
;
yield
ip
.
data
.
QueryInterface
(
Ci
.
nsIProperty
)
;
}
}
}
getProperty
:
function
Update_getProperty
(
name
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdate
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
getProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
name
in
this
.
_properties
&
&
this
.
_properties
[
name
]
.
present
)
{
return
this
.
_properties
[
name
]
.
data
;
}
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdate
"
"
nsIPropertyBag
"
"
nsIWritablePropertyBag
"
]
)
}
;
function
UpdateService
(
)
{
LOG
(
"
Creating
UpdateService
"
)
;
Services
.
obs
.
addObserver
(
this
"
quit
-
application
"
)
;
Services
.
prefs
.
addObserver
(
PREF_APP_UPDATE_LOG
this
)
;
this
.
_logStatus
(
)
;
}
UpdateService
.
prototype
=
{
_downloader
:
null
_registeredOnlineObserver
:
false
_consecutiveSocketErrors
:
0
_retryTimer
:
null
_isNotify
:
true
observe
:
async
function
AUS_observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
post
-
update
-
processing
"
:
Services
.
prefs
.
clearUserPref
(
"
app
.
update
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
app
.
update
.
BITS
.
inTrialGroup
"
)
;
if
(
!
lazy
.
gIsBackgroundTaskMode
&
&
Services
.
appinfo
.
ID
in
APPID_TO_TOPIC
)
{
Services
.
obs
.
addObserver
(
this
APPID_TO_TOPIC
[
Services
.
appinfo
.
ID
]
)
;
break
;
}
case
"
sessionstore
-
windows
-
restored
"
:
case
"
mail
-
startup
-
done
"
:
if
(
!
lazy
.
gIsBackgroundTaskMode
&
&
Services
.
appinfo
.
ID
in
APPID_TO_TOPIC
)
{
Services
.
obs
.
removeObserver
(
this
APPID_TO_TOPIC
[
Services
.
appinfo
.
ID
]
)
;
}
case
"
test
-
post
-
update
-
processing
"
:
await
this
.
_postUpdateProcessing
(
)
;
break
;
case
"
network
:
offline
-
status
-
changed
"
:
await
this
.
_offlineStatusChanged
(
data
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
data
=
=
PREF_APP_UPDATE_LOG
|
|
data
=
=
PREF_APP_UPDATE_LOG_FILE
)
{
lazy
.
gLogEnabled
;
lazy
.
gLogEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
|
|
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
;
}
if
(
data
=
=
PREF_APP_UPDATE_LOG_FILE
)
{
lazy
.
gLogfileEnabled
;
lazy
.
gLogfileEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG_FILE
false
)
;
if
(
lazy
.
gLogfileEnabled
)
{
this
.
_logStatus
(
)
;
}
}
break
;
case
"
quit
-
application
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
Services
.
prefs
.
removeObserver
(
PREF_APP_UPDATE_LOG
this
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
gUpdateMutexHandle
)
{
closeHandle
(
gUpdateMutexHandle
)
;
gUpdateMutexHandle
=
null
;
}
if
(
this
.
_retryTimer
)
{
this
.
_retryTimer
.
cancel
(
)
;
}
if
(
this
.
_downloader
)
{
if
(
this
.
_downloader
.
usingBits
)
{
await
this
.
_downloader
.
cleanup
(
)
;
}
else
{
await
this
.
stopDownload
(
)
;
}
}
this
.
_downloader
=
null
;
lazy
.
CheckSvc
.
stopAllChecks
(
)
;
if
(
gLogfileOutputStream
)
{
gLogfileOutputStream
.
close
(
)
;
}
break
;
case
"
test
-
close
-
handle
-
update
-
mutex
"
:
if
(
Cu
.
isInAutomation
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
gUpdateMutexHandle
)
{
LOG
(
"
UpdateService
:
observe
-
closing
mutex
handle
for
testing
"
)
;
closeHandle
(
gUpdateMutexHandle
)
;
gUpdateMutexHandle
=
null
;
}
}
break
;
}
}
_postUpdateProcessing
:
async
function
AUS__postUpdateProcessing
(
)
{
if
(
this
.
disabled
)
{
return
;
}
if
(
!
this
.
canCheckForUpdates
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
unable
to
check
for
"
+
"
updates
.
.
.
returning
early
"
)
;
return
;
}
let
status
=
readStatusFile
(
getReadyUpdateDir
(
)
)
;
LOG
(
UpdateService
:
_postUpdateProcessing
-
status
=
"
{
status
}
"
)
;
if
(
!
this
.
canApplyUpdates
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
unable
to
apply
"
+
"
updates
.
.
.
returning
early
"
)
;
if
(
hasUpdateMutex
(
)
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Cleaning
up
active
updates
.
"
)
;
cleanupActiveUpdates
(
)
;
}
return
;
}
let
updates
=
[
]
;
if
(
lazy
.
UM
.
readyUpdate
)
{
updates
.
push
(
lazy
.
UM
.
readyUpdate
)
;
}
if
(
lazy
.
UM
.
downloadingUpdate
)
{
updates
.
push
(
lazy
.
UM
.
downloadingUpdate
)
;
}
if
(
status
=
=
STATE_NONE
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Cleaning
up
unexpected
state
.
"
)
;
if
(
!
updates
.
length
)
{
updates
.
push
(
new
Update
(
null
)
)
;
}
for
(
let
update
of
updates
)
{
update
.
state
=
STATE_FAILED
;
update
.
errorCode
=
ERR_UPDATE_STATE_NONE
;
update
.
statusText
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
statusFailed
"
)
;
}
let
newStatus
=
STATE_FAILED
+
"
:
"
+
ERR_UPDATE_STATE_NONE
;
pingStateAndStatusCodes
(
updates
[
0
]
true
newStatus
)
;
cleanupActiveUpdates
(
)
;
return
;
}
let
channelChanged
=
updates
=
>
{
for
(
let
update
of
updates
)
{
if
(
update
.
channel
!
=
lazy
.
UpdateUtils
.
UpdateChannel
)
{
return
true
;
}
}
return
false
;
}
;
if
(
channelChanged
(
updates
)
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
channel
has
changed
"
+
"
reloading
default
preferences
to
workaround
bug
802022
"
)
;
let
prefSvc
=
Services
.
prefs
.
QueryInterface
(
Ci
.
nsIObserver
)
;
prefSvc
.
observe
(
null
"
reload
-
default
-
prefs
"
null
)
;
if
(
channelChanged
(
updates
)
)
{
let
channel
=
lazy
.
UM
.
readyUpdate
?
lazy
.
UM
.
readyUpdate
.
channel
:
lazy
.
UM
.
downloadingUpdate
.
channel
;
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
update
channel
is
"
+
"
different
than
application
'
s
channel
removing
update
.
update
"
+
"
channel
:
"
+
channel
+
"
expected
channel
:
"
+
lazy
.
UpdateUtils
.
UpdateChannel
)
;
for
(
let
update
of
updates
)
{
update
.
state
=
STATE_FAILED
;
update
.
errorCode
=
ERR_CHANNEL_CHANGE
;
update
.
statusText
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
statusFailed
"
)
;
}
let
newStatus
=
STATE_FAILED
+
"
:
"
+
ERR_CHANNEL_CHANGE
;
pingStateAndStatusCodes
(
updates
[
0
]
true
newStatus
)
;
cleanupActiveUpdates
(
)
;
return
;
}
}
if
(
status
=
=
STATE_PENDING
|
|
status
=
=
STATE_PENDING_SERVICE
|
|
status
=
=
STATE_APPLIED
|
|
status
=
=
STATE_APPLIED_SERVICE
|
|
status
=
=
STATE_PENDING_ELEVATE
|
|
status
=
=
STATE_DOWNLOADING
)
{
let
tooOldUpdate
;
if
(
updateIsAtLeastAsOldAs
(
lazy
.
UM
.
readyUpdate
Services
.
appinfo
.
version
Services
.
appinfo
.
appBuildID
)
)
{
tooOldUpdate
=
lazy
.
UM
.
readyUpdate
;
}
else
if
(
updateIsAtLeastAsOldAs
(
lazy
.
UM
.
downloadingUpdate
Services
.
appinfo
.
version
Services
.
appinfo
.
appBuildID
)
)
{
tooOldUpdate
=
lazy
.
UM
.
downloadingUpdate
;
}
if
(
tooOldUpdate
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
removing
update
for
older
"
+
"
application
version
or
same
application
version
with
same
build
"
+
"
ID
.
update
application
version
:
"
+
tooOldUpdate
.
appVersion
+
"
"
+
"
application
version
:
"
+
Services
.
appinfo
.
version
+
"
update
"
+
"
build
ID
:
"
+
tooOldUpdate
.
buildID
+
"
application
build
ID
:
"
+
Services
.
appinfo
.
appBuildID
)
;
tooOldUpdate
.
state
=
STATE_FAILED
;
tooOldUpdate
.
statusText
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
statusFailed
"
)
;
tooOldUpdate
.
errorCode
=
ERR_OLDER_VERSION_OR_SAME_BUILD
;
let
newStatus
=
STATE_FAILED
+
"
:
"
+
ERR_OLDER_VERSION_OR_SAME_BUILD
;
pingStateAndStatusCodes
(
tooOldUpdate
true
newStatus
)
;
cleanupActiveUpdates
(
)
;
return
;
}
}
pingStateAndStatusCodes
(
status
=
=
STATE_DOWNLOADING
?
lazy
.
UM
.
downloadingUpdate
:
lazy
.
UM
.
readyUpdate
true
status
)
;
if
(
lazy
.
UM
.
downloadingUpdate
|
|
status
=
=
STATE_DOWNLOADING
)
{
if
(
status
=
=
STATE_SUCCEEDED
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
removing
downloading
patch
"
+
"
because
we
installed
a
different
patch
before
it
finished
"
+
"
downloading
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
else
{
if
(
lazy
.
UM
.
downloadingUpdate
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
resuming
patch
found
in
"
+
"
downloading
state
"
)
;
let
success
=
await
this
.
downloadUpdate
(
lazy
.
UM
.
downloadingUpdate
)
;
if
(
!
success
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Failed
to
resume
patch
.
"
+
"
Cleaning
up
downloading
update
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
}
else
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Warning
:
found
"
+
"
downloading
state
but
no
downloading
patch
.
Cleaning
up
"
+
"
active
updates
.
"
)
;
cleanupActiveUpdates
(
)
;
}
if
(
status
=
=
STATE_DOWNLOADING
)
{
return
;
}
}
}
let
update
=
lazy
.
UM
.
readyUpdate
;
if
(
status
=
=
STATE_APPLYING
)
{
if
(
update
&
&
(
update
.
state
=
=
STATE_PENDING
|
|
update
.
state
=
=
STATE_PENDING_SERVICE
)
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
patch
found
in
applying
"
+
"
state
for
the
first
time
"
)
;
update
.
state
=
STATE_APPLYING
;
lazy
.
UM
.
saveUpdates
(
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
)
;
pollForStagingEnd
(
)
;
}
else
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
patch
found
in
applying
"
+
"
state
for
the
second
time
.
Cleaning
up
ready
update
.
"
)
;
cleanupReadyUpdate
(
)
;
}
return
;
}
if
(
!
update
)
{
if
(
status
!
=
STATE_SUCCEEDED
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
previous
patch
failed
"
+
"
and
no
patch
available
.
Cleaning
up
ready
update
.
"
)
;
cleanupReadyUpdate
(
)
;
return
;
}
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Update
data
missing
.
Creating
"
+
"
an
empty
update
object
.
"
)
;
update
=
new
Update
(
null
)
;
}
let
parts
=
status
.
split
(
"
:
"
)
;
update
.
state
=
parts
[
0
]
;
LOG
(
UpdateService
:
_postUpdateProcessing
-
Setting
update
'
s
state
from
+
the
status
file
(
=
"
{
update
.
state
}
"
)
)
;
if
(
update
.
state
=
=
STATE_FAILED
&
&
parts
[
1
]
)
{
update
.
errorCode
=
parseInt
(
parts
[
1
]
)
;
LOG
(
UpdateService
:
_postUpdateProcessing
-
Setting
update
'
s
errorCode
+
from
the
status
file
(
=
"
{
update
.
errorCode
}
"
)
)
;
}
if
(
status
!
=
STATE_SUCCEEDED
)
{
cleanUpReadyUpdateDir
(
false
)
;
}
if
(
status
=
=
STATE_SUCCEEDED
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS
)
;
}
update
.
statusText
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
installSuccess
"
)
;
if
(
!
lazy
.
UM
.
readyUpdate
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Assigning
successful
update
"
+
"
readyUpdate
before
cleaning
it
up
.
"
)
;
lazy
.
UM
.
readyUpdate
=
update
;
}
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Cleaning
up
successful
ready
"
+
"
update
.
"
)
;
cleanupReadyUpdate
(
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_ELEVATE_ATTEMPTS
0
)
;
}
else
if
(
status
=
=
STATE_PENDING_ELEVATE
)
{
if
(
!
update
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
status
is
pending
-
elevate
"
+
"
but
there
isn
'
t
a
ready
update
removing
update
"
)
;
cleanupReadyUpdate
(
)
;
}
else
{
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
;
if
(
Services
.
startup
.
wasSilentlyStarted
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
status
is
"
+
"
pending
-
elevate
but
this
is
a
silent
startup
so
the
"
+
"
elevation
window
has
been
suppressed
.
"
)
;
}
else
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
status
is
"
+
"
pending
-
elevate
.
Showing
Update
elevation
dialog
.
"
)
;
let
uri
=
"
chrome
:
/
/
mozapps
/
content
/
update
/
updateElevation
.
xhtml
"
;
let
features
=
"
chrome
centerscreen
resizable
=
no
titlebar
toolbar
=
no
dialog
=
no
"
;
Services
.
ww
.
openWindow
(
null
uri
"
Update
:
Elevation
"
features
null
)
;
}
}
}
else
{
if
(
update
.
state
=
=
STATE_FAILED
&
&
update
.
errorCode
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Attempting
handleUpdateFailure
"
)
;
if
(
handleUpdateFailure
(
update
)
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
handleUpdateFailure
success
.
"
)
;
return
;
}
}
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
Attempting
to
fall
back
to
a
"
+
"
complete
update
.
"
)
;
await
handleFallbackToCompleteUpdate
(
)
;
}
}
_registerOnlineObserver
:
function
AUS__registerOnlineObserver
(
)
{
if
(
this
.
_registeredOnlineObserver
)
{
LOG
(
"
UpdateService
:
_registerOnlineObserver
-
observer
already
registered
"
)
;
return
;
}
LOG
(
"
UpdateService
:
_registerOnlineObserver
-
waiting
for
the
network
to
"
+
"
be
online
then
forcing
another
check
"
)
;
Services
.
obs
.
addObserver
(
this
"
network
:
offline
-
status
-
changed
"
)
;
this
.
_registeredOnlineObserver
=
true
;
}
_offlineStatusChanged
:
async
function
AUS__offlineStatusChanged
(
status
)
{
if
(
status
!
=
=
"
online
"
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
"
network
:
offline
-
status
-
changed
"
)
;
this
.
_registeredOnlineObserver
=
false
;
LOG
(
"
UpdateService
:
_offlineStatusChanged
-
network
is
online
forcing
"
+
"
another
background
check
"
)
;
await
this
.
_attemptResume
(
)
;
}
onCheckComplete
:
async
function
AUS_onCheckComplete
(
result
)
{
if
(
result
.
succeeded
)
{
await
this
.
_selectAndInstallUpdate
(
result
.
updates
)
;
return
;
}
if
(
!
result
.
checksAllowed
)
{
LOG
(
"
UpdateService
:
onCheckComplete
-
checks
not
allowed
"
)
;
return
;
}
let
update
=
result
.
updates
[
0
]
;
LOG
(
"
UpdateService
:
onCheckComplete
-
error
during
background
update
.
error
"
+
"
code
:
"
+
update
.
errorCode
+
"
status
text
:
"
+
update
.
statusText
)
;
if
(
update
.
errorCode
=
=
NETWORK_ERROR_OFFLINE
)
{
this
.
_registerOnlineObserver
(
)
;
if
(
this
.
_pingSuffix
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_OFFLINE
)
;
}
return
;
}
AUSTLMY
.
pingCheckExError
(
this
.
_pingSuffix
update
.
errorCode
)
;
update
.
errorCode
=
BACKGROUNDCHECK_MULTIPLE_FAILURES
;
let
errCount
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
0
)
;
if
(
lazy
.
UM
.
readyUpdate
)
{
LOG
(
"
UpdateService
:
onCheckComplete
-
Ignoring
error
because
another
"
+
"
update
is
ready
.
"
)
;
return
;
}
errCount
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
errCount
)
;
let
maxErrors
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_BACKGROUNDMAXERRORS
10
)
20
)
;
if
(
errCount
>
=
maxErrors
)
{
LOG
(
"
UpdateService
:
onCheckComplete
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
check
-
attempts
-
exceeded
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
check
-
attempts
-
exceeded
"
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_GENERAL_ERROR_PROMPT
)
;
}
else
{
LOG
(
"
UpdateService
:
onCheckComplete
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
check
-
attempt
-
failed
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
check
-
attempt
-
failed
"
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_GENERAL_ERROR_SILENT
)
;
}
}
_attemptResume
:
async
function
AUS_attemptResume
(
)
{
LOG
(
"
UpdateService
:
_attemptResume
"
)
;
if
(
this
.
isDownloading
)
{
LOG
(
"
UpdateService
:
_attemptResume
-
already
downloading
.
"
)
;
return
;
}
if
(
this
.
_downloader
&
&
this
.
_downloader
.
_patch
&
&
this
.
_downloader
.
_patch
.
state
=
=
STATE_DOWNLOADING
&
&
this
.
_downloader
.
_update
)
{
LOG
(
"
UpdateService
:
_attemptResume
-
_patch
.
state
:
"
+
this
.
_downloader
.
_patch
.
state
)
;
let
success
=
await
this
.
downloadUpdate
(
this
.
_downloader
.
_update
)
;
LOG
(
"
UpdateService
:
_attemptResume
-
downloadUpdate
success
:
"
+
success
)
;
if
(
!
success
)
{
LOG
(
"
UpdateService
:
_attemptResume
-
Resuming
download
failed
.
Cleaning
"
+
"
up
downloading
update
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
return
;
}
(
async
(
)
=
>
{
let
check
=
lazy
.
CheckSvc
.
checkForUpdates
(
lazy
.
CheckSvc
.
BACKGROUND_CHECK
)
;
await
this
.
onCheckComplete
(
await
check
.
result
)
;
}
)
(
)
;
}
notify
:
function
AUS_notify
(
timer
)
{
this
.
_checkForBackgroundUpdates
(
true
)
;
}
checkForBackgroundUpdates
:
function
AUS_checkForBackgroundUpdates
(
)
{
return
this
.
_checkForBackgroundUpdates
(
false
)
;
}
get
_pingSuffix
(
)
{
if
(
lazy
.
UM
.
readyUpdate
)
{
return
AUSTLMY
.
SUBSEQUENT
;
}
return
this
.
_isNotify
?
AUSTLMY
.
NOTIFY
:
AUSTLMY
.
EXTERNAL
;
}
_checkForBackgroundUpdates
:
function
AUS__checkForBackgroundUpdates
(
isNotify
)
{
if
(
!
this
.
disabled
&
&
AppConstants
.
NIGHTLY_BUILD
)
{
AUSTLMY
.
pingSuppressPrompts
(
)
;
}
if
(
this
.
disabled
|
|
this
.
manualUpdateOnly
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_DISABLED_BY_POLICY
)
;
return
false
;
}
this
.
_isNotify
=
isNotify
;
AUSTLMY
.
pingGeneric
(
"
UPDATE_PING_COUNT_
"
+
this
.
_pingSuffix
true
false
)
;
AUSTLMY
.
pingGeneric
(
"
UPDATE_UNABLE_TO_APPLY_
"
+
this
.
_pingSuffix
getCanApplyUpdates
(
)
true
)
;
AUSTLMY
.
pingGeneric
(
"
UPDATE_CANNOT_STAGE_
"
+
this
.
_pingSuffix
getCanStageUpdates
(
)
true
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
AUSTLMY
.
pingGeneric
(
"
UPDATE_CAN_USE_BITS_
"
+
this
.
_pingSuffix
getCanUseBits
(
)
)
;
}
AUSTLMY
.
pingLastUpdateTime
(
this
.
_pingSuffix
)
;
lazy
.
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
.
then
(
enabled
=
>
{
AUSTLMY
.
pingGeneric
(
"
UPDATE_NOT_PREF_UPDATE_AUTO_
"
+
this
.
_pingSuffix
enabled
true
)
;
}
)
;
AUSTLMY
.
pingBoolPref
(
"
UPDATE_NOT_PREF_UPDATE_STAGING_ENABLED_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_STAGING_ENABLED
true
true
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
)
{
AUSTLMY
.
pingIntPref
(
"
UPDATE_PREF_UPDATE_CANCELATIONS_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_CANCELATIONS
0
0
)
;
}
if
(
AppConstants
.
MOZ_MAINTENANCE_SERVICE
)
{
AUSTLMY
.
pingBoolPref
(
"
UPDATE_NOT_PREF_UPDATE_SERVICE_ENABLED_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_SERVICE_ENABLED
true
)
;
AUSTLMY
.
pingIntPref
(
"
UPDATE_PREF_SERVICE_ERRORS_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_SERVICE_ERRORS
0
0
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
AUSTLMY
.
pingServiceInstallStatus
(
this
.
_pingSuffix
isServiceInstalled
(
)
)
;
}
}
if
(
this
.
isDownloading
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_IS_DOWNLOADING
)
;
return
false
;
}
if
(
lazy
.
UM
.
readyUpdate
&
&
lazy
.
UM
.
readyUpdate
.
selectedPatch
&
&
lazy
.
UM
.
readyUpdate
.
selectedPatch
.
type
=
=
"
complete
"
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_IS_DOWNLOADED
)
;
return
false
;
}
if
(
this
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_IS_DOWNLOADED
)
;
return
false
;
}
(
async
(
)
=
>
{
let
validUpdateURL
=
true
;
try
{
await
lazy
.
CheckSvc
.
getUpdateURL
(
lazy
.
CheckSvc
.
BACKGROUND_CHECK
)
;
}
catch
(
e
)
{
validUpdateURL
=
false
;
}
if
(
!
lazy
.
UpdateUtils
.
OSVersion
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_NO_OS_VERSION
)
;
}
else
if
(
!
lazy
.
UpdateUtils
.
ABI
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_NO_OS_ABI
)
;
}
else
if
(
!
validUpdateURL
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_INVALID_DEFAULT_URL
)
;
}
else
if
(
!
hasUpdateMutex
(
)
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_NO_MUTEX
)
;
}
else
if
(
isOtherInstanceRunning
(
)
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_OTHER_INSTANCE
)
;
}
else
if
(
!
this
.
canCheckForUpdates
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_UNABLE_TO_CHECK
)
;
}
let
check
=
lazy
.
CheckSvc
.
checkForUpdates
(
lazy
.
CheckSvc
.
BACKGROUND_CHECK
)
;
await
this
.
onCheckComplete
(
await
check
.
result
)
;
}
)
(
)
;
return
true
;
}
selectUpdate
:
function
AUS_selectUpdate
(
updates
)
{
if
(
!
updates
.
length
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_NO_UPDATE_FOUND
)
;
return
null
;
}
if
(
updates
.
length
=
=
1
&
&
updates
[
0
]
.
unsupported
)
{
return
updates
[
0
]
;
}
var
majorUpdate
=
null
;
var
minorUpdate
=
null
;
var
vc
=
Services
.
vc
;
let
lastCheckCode
=
AUSTLMY
.
CHK_NO_COMPAT_UPDATE_FOUND
;
updates
.
forEach
(
function
(
aUpdate
)
{
if
(
updateIsAtLeastAsOldAsCurrentVersion
(
aUpdate
)
)
{
LOG
(
"
UpdateService
:
selectUpdate
-
skipping
update
because
the
"
+
"
update
'
s
application
version
is
not
greater
than
the
current
"
+
"
application
version
"
)
;
lastCheckCode
=
AUSTLMY
.
CHK_UPDATE_PREVIOUS_VERSION
;
return
;
}
if
(
updateIsAtLeastAsOldAsReadyUpdate
(
aUpdate
)
)
{
LOG
(
"
UpdateService
:
selectUpdate
-
skipping
update
because
the
"
+
"
update
'
s
application
version
is
not
greater
than
that
of
the
"
+
"
currently
downloaded
update
"
)
;
lastCheckCode
=
AUSTLMY
.
CHK_UPDATE_PREVIOUS_VERSION
;
return
;
}
if
(
lazy
.
UM
.
readyUpdate
&
&
!
getPatchOfType
(
aUpdate
"
partial
"
)
)
{
LOG
(
"
UpdateService
:
selectUpdate
-
skipping
update
because
no
partial
"
+
"
patch
is
available
and
an
update
has
already
been
downloaded
.
"
)
;
lastCheckCode
=
AUSTLMY
.
CHK_NO_PARTIAL_PATCH
;
return
;
}
switch
(
aUpdate
.
type
)
{
case
"
major
"
:
if
(
!
majorUpdate
)
{
majorUpdate
=
aUpdate
;
}
else
if
(
vc
.
compare
(
majorUpdate
.
appVersion
aUpdate
.
appVersion
)
<
=
0
)
{
majorUpdate
=
aUpdate
;
}
break
;
case
"
minor
"
:
if
(
!
minorUpdate
)
{
minorUpdate
=
aUpdate
;
}
else
if
(
vc
.
compare
(
minorUpdate
.
appVersion
aUpdate
.
appVersion
)
<
=
0
)
{
minorUpdate
=
aUpdate
;
}
break
;
default
:
LOG
(
"
UpdateService
:
selectUpdate
-
skipping
unknown
update
type
:
"
+
aUpdate
.
type
)
;
lastCheckCode
=
AUSTLMY
.
CHK_UPDATE_INVALID_TYPE
;
break
;
}
}
)
;
let
update
=
minorUpdate
|
|
majorUpdate
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
update
)
{
if
(
getElevationRequired
(
)
)
{
let
installAttemptVersion
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_ELEVATE_VERSION
null
)
;
if
(
vc
.
compare
(
installAttemptVersion
update
.
appVersion
)
!
=
0
)
{
Services
.
prefs
.
setCharPref
(
PREF_APP_UPDATE_ELEVATE_VERSION
update
.
appVersion
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
}
else
{
let
numCancels
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
0
)
;
let
rejectedVersion
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
"
"
)
;
let
maxCancels
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX_MAX
DEFAULT_CANCELATIONS_OSX_MAX
)
;
if
(
numCancels
>
=
maxCancels
)
{
LOG
(
"
UpdateService
:
selectUpdate
-
the
user
requires
elevation
to
"
+
"
install
this
update
but
the
user
has
exceeded
the
max
"
+
"
number
of
elevation
attempts
.
"
)
;
update
.
elevationFailure
=
true
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_ELEVATION_DISABLED_FOR_VERSION
)
;
}
else
if
(
vc
.
compare
(
rejectedVersion
update
.
appVersion
)
=
=
0
)
{
LOG
(
"
UpdateService
:
selectUpdate
-
the
user
requires
elevation
to
"
+
"
install
this
update
but
elevation
is
disabled
for
this
"
+
"
version
.
"
)
;
update
.
elevationFailure
=
true
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_ELEVATION_OPTOUT_FOR_VERSION
)
;
}
else
{
LOG
(
"
UpdateService
:
selectUpdate
-
the
user
requires
elevation
to
"
+
"
install
the
update
.
"
)
;
}
}
}
else
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_VERSION
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_VERSION
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
}
}
else
if
(
!
update
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
lastCheckCode
)
;
}
return
update
;
}
_selectAndInstallUpdate
:
async
function
AUS__selectAndInstallUpdate
(
updates
)
{
if
(
lazy
.
UM
.
downloadingUpdate
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_HAS_ACTIVEUPDATE
)
;
return
;
}
if
(
this
.
disabled
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_DISABLED_BY_POLICY
)
;
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
not
prompting
because
"
+
"
update
is
disabled
"
)
;
return
;
}
var
update
=
this
.
selectUpdate
(
updates
)
;
if
(
!
update
|
|
update
.
elevationFailure
)
{
return
;
}
if
(
update
.
unsupported
)
{
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
update
not
supported
for
"
+
"
this
system
.
Notifying
observers
.
topic
:
update
-
available
"
+
"
status
:
unsupported
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
available
"
"
unsupported
"
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_UNSUPPORTED
)
;
return
;
}
if
(
!
getCanApplyUpdates
(
)
)
{
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
the
user
is
unable
to
"
+
"
apply
updates
.
.
.
prompting
.
Notifying
observers
.
"
+
"
topic
:
update
-
available
status
:
cant
-
apply
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
update
-
available
"
"
cant
-
apply
"
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_UNABLE_TO_APPLY
)
;
return
;
}
let
updateAuto
=
await
lazy
.
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
if
(
!
updateAuto
)
{
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
prompting
because
silent
"
+
"
install
is
disabled
.
Notifying
observers
.
topic
:
update
-
available
"
+
"
status
:
show
-
prompt
"
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_SHOWPROMPT_PREF
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
available
"
"
show
-
prompt
"
)
;
return
;
}
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
download
the
update
"
)
;
let
success
=
await
this
.
downloadUpdate
(
update
)
;
if
(
!
success
&
&
!
this
.
isDownloading
)
{
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
Failed
to
start
downloading
"
+
"
update
.
Cleaning
up
downloading
update
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_DOWNLOAD_UPDATE
)
;
}
get
disabledForTesting
(
)
{
return
(
(
Cu
.
isInAutomation
|
|
lazy
.
Marionette
.
running
|
|
lazy
.
RemoteAgent
.
running
)
&
&
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
false
)
)
;
}
get
disabled
(
)
{
return
(
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
|
|
this
.
disabledForTesting
|
|
Services
.
sysinfo
.
getProperty
(
"
isPackagedApp
"
)
)
;
}
get
manualUpdateOnly
(
)
{
return
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
autoAppUpdateChecking
"
)
)
;
}
get
canUsuallyCheckForUpdates
(
)
{
if
(
this
.
disabled
)
{
LOG
(
"
UpdateService
.
canUsuallyCheckForUpdates
-
unable
to
automatically
check
"
+
"
for
updates
the
option
has
been
disabled
by
the
administrator
.
"
)
;
return
false
;
}
if
(
!
lazy
.
UpdateUtils
.
ABI
)
{
LOG
(
"
UpdateService
.
canUsuallyCheckForUpdates
-
unable
to
check
for
updates
"
+
"
unknown
ABI
"
)
;
return
false
;
}
if
(
!
lazy
.
UpdateUtils
.
OSVersion
)
{
LOG
(
"
UpdateService
.
canUsuallyCheckForUpdates
-
unable
to
check
for
updates
"
+
"
unknown
OS
version
"
)
;
return
false
;
}
LOG
(
"
UpdateService
.
canUsuallyCheckForUpdates
-
able
to
check
for
updates
"
)
;
return
true
;
}
get
canCheckForUpdates
(
)
{
if
(
!
this
.
canUsuallyCheckForUpdates
)
{
return
false
;
}
if
(
!
hasUpdateMutex
(
)
)
{
LOG
(
"
UpdateService
.
canCheckForUpdates
-
unable
to
check
for
updates
"
+
"
unable
to
acquire
update
mutex
"
)
;
return
false
;
}
if
(
isOtherInstanceRunning
(
)
)
{
LOG
(
"
UpdateService
.
canCheckForUpdates
-
another
instance
is
holding
the
"
+
"
lock
will
need
to
wait
for
it
prior
to
checking
for
updates
"
)
;
}
LOG
(
"
UpdateService
.
canCheckForUpdates
-
able
to
check
for
updates
"
)
;
return
true
;
}
get
elevationRequired
(
)
{
return
getElevationRequired
(
)
;
}
get
canUsuallyApplyUpdates
(
)
{
return
getCanApplyUpdates
(
)
;
}
get
canApplyUpdates
(
)
{
return
(
this
.
canUsuallyApplyUpdates
&
&
hasUpdateMutex
(
)
&
&
!
isOtherInstanceRunning
(
)
)
;
}
get
canUsuallyStageUpdates
(
)
{
return
getCanStageUpdates
(
false
)
;
}
get
canStageUpdates
(
)
{
return
getCanStageUpdates
(
)
;
}
get
canUsuallyUseBits
(
)
{
return
getCanUseBits
(
false
)
=
=
"
CanUseBits
"
;
}
get
canUseBits
(
)
{
return
getCanUseBits
(
)
=
=
"
CanUseBits
"
;
}
get
isOtherInstanceHandlingUpdates
(
)
{
return
!
hasUpdateMutex
(
)
|
|
isOtherInstanceRunning
(
)
;
}
_downloadListeners
:
new
Set
(
)
addDownloadListener
:
function
AUS_addDownloadListener
(
listener
)
{
let
oldSize
=
this
.
_downloadListeners
.
size
;
this
.
_downloadListeners
.
add
(
listener
)
;
if
(
this
.
_downloadListeners
.
size
=
=
oldSize
)
{
LOG
(
"
UpdateService
:
addDownloadListener
-
Warning
:
Didn
'
t
add
duplicate
"
+
"
listener
"
)
;
return
;
}
if
(
this
.
_downloader
)
{
this
.
_downloader
.
onDownloadListenerAdded
(
)
;
}
}
removeDownloadListener
:
function
AUS_removeDownloadListener
(
listener
)
{
let
elementRemoved
=
this
.
_downloadListeners
.
delete
(
listener
)
;
if
(
!
elementRemoved
)
{
LOG
(
"
UpdateService
:
removeDownloadListener
-
Warning
:
Didn
'
t
remove
"
+
"
non
-
existent
listener
"
)
;
return
;
}
if
(
this
.
_downloader
)
{
this
.
_downloader
.
onDownloadListenerRemoved
(
)
;
}
}
get
hasDownloadListeners
(
)
{
return
!
!
this
.
_downloadListeners
.
length
;
}
forEachDownloadListener
:
function
AUS_forEachDownloadListener
(
fn
)
{
let
listeners
=
new
Set
(
this
.
_downloadListeners
)
;
listeners
.
forEach
(
fn
)
;
}
downloadUpdate
:
async
function
AUS_downloadUpdate
(
update
)
{
if
(
!
update
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NULL_POINTER
)
;
}
if
(
updateIsAtLeastAsOldAsCurrentVersion
(
update
)
)
{
LOG
(
"
UpdateService
:
downloadUpdate
-
Skipping
download
of
update
since
"
+
"
it
is
for
an
earlier
or
same
application
version
and
build
ID
.
\
n
"
+
"
current
application
version
:
"
+
Services
.
appinfo
.
version
+
"
\
n
"
+
"
update
application
version
:
"
+
update
.
appVersion
+
"
\
n
"
+
"
current
build
ID
:
"
+
Services
.
appinfo
.
appBuildID
+
"
\
n
"
+
"
update
build
ID
:
"
+
update
.
buildID
)
;
return
false
;
}
if
(
updateIsAtLeastAsOldAsReadyUpdate
(
update
)
)
{
LOG
(
"
UpdateService
:
downloadUpdate
-
not
downloading
update
because
the
"
+
"
update
that
'
s
already
been
downloaded
is
the
same
version
or
"
+
"
newer
.
\
n
"
+
"
currently
downloaded
update
application
version
:
"
+
lazy
.
UM
.
readyUpdate
.
appVersion
+
"
\
n
"
+
"
available
update
application
version
:
"
+
update
.
appVersion
+
"
\
n
"
+
"
currently
downloaded
update
build
ID
:
"
+
lazy
.
UM
.
readyUpdate
.
buildID
+
"
\
n
"
+
"
available
update
build
ID
:
"
+
update
.
buildID
)
;
return
false
;
}
if
(
this
.
isDownloading
)
{
if
(
update
.
isCompleteUpdate
=
=
this
.
_downloader
.
isCompleteUpdate
)
{
LOG
(
"
UpdateService
:
downloadUpdate
-
no
support
for
downloading
more
"
+
"
than
one
update
at
a
time
"
)
;
return
true
;
}
this
.
_downloader
.
cancel
(
)
;
}
this
.
_downloader
=
new
Downloader
(
this
)
;
return
this
.
_downloader
.
downloadUpdate
(
update
)
;
}
stopDownload
:
async
function
AUS_stopDownload
(
)
{
if
(
this
.
isDownloading
)
{
await
this
.
_downloader
.
cancel
(
)
;
}
else
if
(
this
.
_retryTimer
)
{
this
.
_retryTimer
.
cancel
(
)
;
this
.
_retryTimer
=
null
;
if
(
this
.
_downloader
)
{
await
this
.
_downloader
.
cancel
(
)
;
}
}
if
(
this
.
_downloader
)
{
await
this
.
_downloader
.
cleanup
(
)
;
}
this
.
_downloader
=
null
;
}
get
isDownloading
(
)
{
return
this
.
_downloader
&
&
this
.
_downloader
.
isBusy
;
}
_logStatus
:
function
AUS__logStatus
(
)
{
if
(
!
lazy
.
gLogEnabled
)
{
return
;
}
if
(
this
.
disabled
)
{
LOG
(
"
Current
UpdateService
status
:
disabled
"
)
;
return
;
}
LOG
(
"
Logging
current
UpdateService
status
:
"
)
;
this
.
canCheckForUpdates
;
this
.
canApplyUpdates
;
this
.
canStageUpdates
;
LOG
(
"
Elevation
required
:
"
+
this
.
elevationRequired
)
;
LOG
(
"
Other
instance
of
the
application
currently
running
:
"
+
this
.
isOtherInstanceHandlingUpdates
)
;
LOG
(
"
Downloading
:
"
+
!
!
this
.
isDownloading
)
;
if
(
this
.
_downloader
&
&
this
.
_downloader
.
isBusy
)
{
LOG
(
"
Downloading
complete
update
:
"
+
this
.
_downloader
.
isCompleteUpdate
)
;
LOG
(
"
Downloader
using
BITS
:
"
+
this
.
_downloader
.
usingBits
)
;
if
(
this
.
_downloader
.
_patch
)
{
this
.
_downloader
.
_canUseBits
(
this
.
_downloader
.
_patch
)
;
let
bitsResult
=
this
.
_downloader
.
_patch
.
getProperty
(
"
bitsResult
"
)
;
if
(
bitsResult
!
=
null
)
{
LOG
(
"
Patch
BITS
result
:
"
+
bitsResult
)
;
}
let
internalResult
=
this
.
_downloader
.
_patch
.
getProperty
(
"
internalResult
"
)
;
if
(
internalResult
!
=
null
)
{
LOG
(
"
Patch
nsIIncrementalDownload
result
:
"
+
internalResult
)
;
}
}
}
LOG
(
"
End
of
UpdateService
status
"
)
;
}
get
onlyDownloadUpdatesThisSession
(
)
{
return
gOnlyDownloadUpdatesThisSession
;
}
set
onlyDownloadUpdatesThisSession
(
newValue
)
{
gOnlyDownloadUpdatesThisSession
=
newValue
;
}
getStateName
(
state
)
{
switch
(
state
)
{
case
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
:
return
"
STATE_IDLE
"
;
case
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
:
return
"
STATE_DOWNLOADING
"
;
case
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
:
return
"
STATE_STAGING
"
;
case
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
:
return
"
STATE_PENDING
"
;
case
Ci
.
nsIApplicationUpdateService
.
STATE_SWAP
:
return
"
STATE_SWAP
"
;
}
return
[
unknown
update
state
:
{
state
}
]
;
}
get
currentState
(
)
{
return
gUpdateState
;
}
get
stateTransition
(
)
{
return
gStateTransitionPromise
.
promise
;
}
classID
:
UPDATESERVICE_CID
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIApplicationUpdateService
"
"
nsITimerCallback
"
"
nsIObserver
"
]
)
}
;
function
UpdateManager
(
)
{
let
activeUpdates
=
this
.
_loadXMLFileIntoArray
(
FILE_ACTIVE_UPDATE_XML
)
;
if
(
activeUpdates
.
length
)
{
this
.
_readyUpdate
=
activeUpdates
[
0
]
;
if
(
activeUpdates
.
length
>
=
2
)
{
this
.
_downloadingUpdate
=
activeUpdates
[
1
]
;
}
let
status
=
readStatusFile
(
getReadyUpdateDir
(
)
)
;
LOG
(
UpdateManager
:
UpdateManager
-
status
=
"
{
status
}
"
)
;
if
(
status
=
=
STATE_NONE
)
{
LOG
(
"
UpdateManager
:
UpdateManager
-
Found
update
data
with
no
status
"
+
"
file
.
Cleaning
up
.
.
.
"
)
;
this
.
_readyUpdate
.
state
=
STATE_FAILED
;
this
.
_readyUpdate
.
errorCode
=
ERR_UPDATE_STATE_NONE
;
this
.
_readyUpdate
.
statusText
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
statusFailed
"
)
;
let
newStatus
=
STATE_FAILED
+
"
:
"
+
ERR_UPDATE_STATE_NONE
;
pingStateAndStatusCodes
(
this
.
_readyUpdate
true
newStatus
)
;
this
.
addUpdateToHistory
(
this
.
_readyUpdate
)
;
this
.
_readyUpdate
=
null
;
this
.
saveUpdates
(
)
;
cleanUpReadyUpdateDir
(
)
;
cleanUpDownloadingUpdateDir
(
)
;
}
else
if
(
status
=
=
STATE_DOWNLOADING
)
{
if
(
this
.
_downloadingUpdate
)
{
LOG
(
"
UpdateManager
:
UpdateManager
-
Warning
:
Found
and
discarded
a
"
+
"
second
downloading
update
.
"
)
;
}
this
.
_downloadingUpdate
=
this
.
_readyUpdate
;
this
.
_readyUpdate
=
null
;
}
}
LOG
(
"
UpdateManager
:
UpdateManager
-
Initialized
downloadingUpdate
to
"
+
this
.
_downloadingUpdate
)
;
if
(
this
.
_downloadingUpdate
)
{
LOG
(
"
UpdateManager
:
UpdateManager
-
Initialized
downloadingUpdate
state
to
"
+
this
.
_downloadingUpdate
.
state
)
;
}
LOG
(
"
UpdateManager
:
UpdateManager
-
Initialized
readyUpdate
to
"
+
this
.
_readyUpdate
)
;
if
(
this
.
_readyUpdate
)
{
LOG
(
"
UpdateManager
:
UpdateManager
-
Initialized
readyUpdate
state
to
"
+
this
.
_readyUpdate
.
state
)
;
}
}
UpdateManager
.
prototype
=
{
_readyUpdate
:
null
_downloadingUpdate
:
null
_updatesDirty
:
false
observe
:
function
UM_observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
um
-
reload
-
update
-
data
"
)
{
if
(
!
Cu
.
isInAutomation
)
{
return
;
}
LOG
(
"
UpdateManager
:
observe
-
Reloading
update
data
.
"
)
;
if
(
this
.
_updatesXMLSaver
)
{
this
.
_updatesXMLSaver
.
disarm
(
)
;
}
let
updates
=
[
]
;
this
.
_updatesDirty
=
true
;
this
.
_readyUpdate
=
null
;
this
.
_downloadingUpdate
=
null
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
;
if
(
data
!
=
"
skip
-
files
"
)
{
let
activeUpdates
=
this
.
_loadXMLFileIntoArray
(
FILE_ACTIVE_UPDATE_XML
)
;
if
(
activeUpdates
.
length
)
{
this
.
_readyUpdate
=
activeUpdates
[
0
]
;
if
(
activeUpdates
.
length
>
=
2
)
{
this
.
_downloadingUpdate
=
activeUpdates
[
1
]
;
}
let
status
=
readStatusFile
(
getReadyUpdateDir
(
)
)
;
LOG
(
UpdateManager
:
observe
-
Got
status
=
{
status
}
)
;
if
(
status
=
=
STATE_DOWNLOADING
)
{
this
.
_downloadingUpdate
=
this
.
_readyUpdate
;
this
.
_readyUpdate
=
null
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
)
;
}
else
if
(
[
STATE_PENDING
STATE_PENDING_SERVICE
STATE_PENDING_ELEVATE
STATE_APPLIED
STATE_APPLIED_SERVICE
]
.
includes
(
status
)
)
{
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
;
}
}
updates
=
this
.
_loadXMLFileIntoArray
(
FILE_UPDATES_XML
)
;
}
this
.
_updatesCache
=
updates
;
LOG
(
"
UpdateManager
:
observe
-
Reloaded
downloadingUpdate
as
"
+
this
.
_downloadingUpdate
)
;
if
(
this
.
_downloadingUpdate
)
{
LOG
(
"
UpdateManager
:
observe
-
Reloaded
downloadingUpdate
state
as
"
+
this
.
_downloadingUpdate
.
state
)
;
}
LOG
(
"
UpdateManager
:
observe
-
Reloaded
readyUpdate
as
"
+
this
.
_readyUpdate
)
;
if
(
this
.
_readyUpdate
)
{
LOG
(
"
UpdateManager
:
observe
-
Reloaded
readyUpdate
state
as
"
+
this
.
_readyUpdate
.
state
)
;
}
}
}
_loadXMLFileIntoArray
:
function
UM__loadXMLFileIntoArray
(
fileName
)
{
let
updates
=
[
]
;
let
file
=
getUpdateFile
(
[
fileName
]
)
;
if
(
!
file
.
exists
(
)
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
XML
file
does
not
exist
.
"
+
"
path
:
"
+
file
.
path
)
;
return
updates
;
}
let
mode
=
fileName
=
=
FILE_ACTIVE_UPDATE_XML
?
FileUtils
.
MODE_RDWR
:
FileUtils
.
MODE_RDONLY
;
let
fileStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
try
{
fileStream
.
init
(
file
mode
FileUtils
.
PERMS_FILE
0
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
error
initializing
file
"
+
"
stream
.
Exception
:
"
+
e
)
;
return
updates
;
}
try
{
var
parser
=
new
DOMParser
(
)
;
var
doc
=
parser
.
parseFromStream
(
fileStream
"
UTF
-
8
"
fileStream
.
available
(
)
"
text
/
xml
"
)
;
var
updateCount
=
doc
.
documentElement
.
childNodes
.
length
;
for
(
var
i
=
0
;
i
<
updateCount
;
+
+
i
)
{
var
updateElement
=
doc
.
documentElement
.
childNodes
.
item
(
i
)
;
if
(
updateElement
.
nodeType
!
=
updateElement
.
ELEMENT_NODE
|
|
updateElement
.
localName
!
=
"
update
"
)
{
continue
;
}
let
update
;
try
{
update
=
new
Update
(
updateElement
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
invalid
update
"
)
;
continue
;
}
updates
.
push
(
update
)
;
}
}
catch
(
ex
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
error
constructing
update
"
+
"
list
.
Exception
:
"
+
ex
)
;
}
fileStream
.
close
(
)
;
if
(
!
updates
.
length
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
update
xml
file
"
+
fileName
+
"
exists
but
doesn
'
t
contain
any
updates
"
)
;
try
{
file
.
remove
(
false
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
error
removing
"
+
fileName
+
"
file
.
Exception
:
"
+
e
)
;
}
}
return
updates
;
}
_getUpdates
(
)
{
if
(
!
this
.
_updatesCache
)
{
this
.
_updatesCache
=
this
.
_loadXMLFileIntoArray
(
FILE_UPDATES_XML
)
;
}
return
this
.
_updatesCache
;
}
getUpdateAt
:
function
UM_getUpdateAt
(
aIndex
)
{
return
this
.
_getUpdates
(
)
[
aIndex
]
;
}
getUpdateCount
(
)
{
return
this
.
_getUpdates
(
)
.
length
;
}
get
readyUpdate
(
)
{
return
this
.
_readyUpdate
;
}
set
readyUpdate
(
aUpdate
)
{
this
.
_readyUpdate
=
aUpdate
;
}
get
downloadingUpdate
(
)
{
return
this
.
_downloadingUpdate
;
}
set
downloadingUpdate
(
aUpdate
)
{
this
.
_downloadingUpdate
=
aUpdate
;
}
addUpdateToHistory
(
aUpdate
)
{
this
.
_updatesDirty
=
true
;
let
updates
=
this
.
_getUpdates
(
)
;
updates
.
unshift
(
aUpdate
)
;
updates
.
splice
(
10
)
;
}
_writeUpdatesToXMLFile
:
async
function
UM__writeUpdatesToXMLFile
(
updates
fileName
)
{
let
file
;
try
{
file
=
getUpdateFile
(
[
fileName
]
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_writeUpdatesToXMLFile
-
Unable
to
get
XML
file
-
"
+
"
Exception
:
"
+
e
)
;
return
false
;
}
if
(
!
updates
.
length
)
{
LOG
(
"
UpdateManager
:
_writeUpdatesToXMLFile
-
no
updates
to
write
.
"
+
"
removing
file
:
"
+
file
.
path
)
;
try
{
await
IOUtils
.
remove
(
file
.
path
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_writeUpdatesToXMLFile
-
Delete
file
exception
:
"
+
e
)
;
return
false
;
}
return
true
;
}
const
EMPTY_UPDATES_DOCUMENT_OPEN
=
'
<
?
xml
version
=
"
1
.
0
"
?
>
<
updates
xmlns
=
"
'
+
URI_UPDATE_NS
+
'
"
>
'
;
const
EMPTY_UPDATES_DOCUMENT_CLOSE
=
"
<
/
updates
>
"
;
try
{
var
parser
=
new
DOMParser
(
)
;
var
doc
=
parser
.
parseFromString
(
EMPTY_UPDATES_DOCUMENT_OPEN
+
EMPTY_UPDATES_DOCUMENT_CLOSE
"
text
/
xml
"
)
;
for
(
var
i
=
0
;
i
<
updates
.
length
;
+
+
i
)
{
doc
.
documentElement
.
appendChild
(
updates
[
i
]
.
serialize
(
doc
)
)
;
}
var
xml
=
EMPTY_UPDATES_DOCUMENT_OPEN
+
doc
.
documentElement
.
innerHTML
+
EMPTY_UPDATES_DOCUMENT_CLOSE
;
await
IOUtils
.
writeUTF8
(
file
.
path
xml
{
tmpPath
:
file
.
path
+
"
.
tmp
"
}
)
;
await
IOUtils
.
setPermissions
(
file
.
path
FileUtils
.
PERMS_FILE
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_writeUpdatesToXMLFile
-
Exception
:
"
+
e
)
;
return
false
;
}
return
true
;
}
_updatesXMLSaver
:
null
_updatesXMLSaverCallback
:
null
saveUpdates
:
function
UM_saveUpdates
(
)
{
if
(
!
this
.
_updatesXMLSaver
)
{
this
.
_updatesXMLSaverCallback
=
(
)
=
>
this
.
_updatesXMLSaver
.
finalize
(
)
;
this
.
_updatesXMLSaver
=
new
lazy
.
DeferredTask
(
(
)
=
>
this
.
_saveUpdatesXML
(
)
XML_SAVER_INTERVAL_MS
)
;
lazy
.
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
UpdateManager
:
writing
update
xml
data
"
this
.
_updatesXMLSaverCallback
)
;
}
else
{
this
.
_updatesXMLSaver
.
disarm
(
)
;
}
this
.
_updatesXMLSaver
.
arm
(
)
;
}
_saveUpdatesXML
:
function
UM__saveUpdatesXML
(
)
{
let
updates
=
[
]
;
if
(
this
.
_readyUpdate
)
{
updates
.
push
(
this
.
_readyUpdate
)
;
}
if
(
this
.
_downloadingUpdate
)
{
updates
.
push
(
this
.
_downloadingUpdate
)
;
}
let
promises
=
[
]
;
promises
[
0
]
=
this
.
_writeUpdatesToXMLFile
(
updates
FILE_ACTIVE_UPDATE_XML
)
;
if
(
this
.
_updatesDirty
)
{
this
.
_updatesDirty
=
false
;
promises
[
1
]
=
this
.
_writeUpdatesToXMLFile
(
this
.
_getUpdates
(
)
FILE_UPDATES_XML
)
;
}
return
Promise
.
all
(
promises
)
;
}
refreshUpdateStatus
:
async
function
UM_refreshUpdateStatus
(
)
{
try
{
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Staging
done
.
"
)
;
var
update
=
this
.
_readyUpdate
;
if
(
!
update
)
{
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Missing
ready
update
?
"
)
;
return
;
}
var
status
=
readStatusFile
(
getReadyUpdateDir
(
)
)
;
pingStateAndStatusCodes
(
update
false
status
)
;
LOG
(
UpdateManager
:
refreshUpdateStatus
-
status
=
{
status
}
)
;
let
parts
=
status
.
split
(
"
:
"
)
;
update
.
state
=
parts
[
0
]
;
if
(
update
.
state
=
=
STATE_APPLYING
)
{
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Staging
appears
to
have
crashed
.
"
)
;
update
.
state
=
STATE_FAILED
;
update
.
errorCode
=
ERR_UPDATER_CRASHED
;
}
else
if
(
update
.
state
=
=
STATE_FAILED
)
{
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Staging
failed
.
"
)
;
if
(
parts
[
1
]
)
{
update
.
errorCode
=
parseInt
(
parts
[
1
]
)
|
|
INVALID_UPDATER_STATUS_CODE
;
}
else
{
update
.
errorCode
=
INVALID_UPDATER_STATUS_CODE
;
}
}
cleanUpReadyUpdateDir
(
false
)
;
if
(
update
.
state
=
=
STATE_FAILED
)
{
if
(
update
.
errorCode
=
=
DELETE_ERROR_STAGING_LOCK_FILE
|
|
update
.
errorCode
=
=
UNEXPECTED_STAGING_ERROR
)
{
update
.
state
=
getBestPendingState
(
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
update
.
state
)
;
LOG
(
UpdateManager
:
refreshUpdateStatus
-
Unexpected
staging
error
.
+
Setting
status
to
"
{
update
.
state
}
"
)
;
}
else
if
(
isServiceSpecificErrorCode
(
update
.
errorCode
)
)
{
LOG
(
UpdateManager
:
refreshUpdateStatus
-
Encountered
service
+
specific
error
code
:
{
update
.
errorCode
}
.
Will
try
installing
+
update
without
the
Maintenance
Service
.
Setting
state
to
pending
)
;
update
.
state
=
STATE_PENDING
;
writeStatusFile
(
getReadyUpdateDir
(
)
update
.
state
)
;
}
else
{
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Attempting
handleUpdateFailure
"
)
;
if
(
!
handleUpdateFailure
(
update
)
)
{
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
handleUpdateFailure
"
+
"
failed
.
Attempting
to
fall
back
to
complete
update
.
"
)
;
await
handleFallbackToCompleteUpdate
(
)
;
}
}
}
if
(
update
.
state
=
=
STATE_APPLIED
&
&
shouldUseService
(
)
)
{
LOG
(
UpdateManager
:
refreshUpdateStatus
-
Staging
successful
.
+
Setting
status
to
"
{
STATE_APPLIED_SERVICE
}
"
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
(
update
.
state
=
STATE_APPLIED_SERVICE
)
)
;
}
this
.
saveUpdates
(
)
;
await
promiseLangPacksUpdated
(
update
)
;
if
(
update
.
state
=
=
STATE_APPLIED
|
|
update
.
state
=
=
STATE_APPLIED_SERVICE
|
|
update
.
state
=
=
STATE_PENDING
|
|
update
.
state
=
=
STATE_PENDING_SERVICE
|
|
update
.
state
=
=
STATE_PENDING_ELEVATE
)
{
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Setting
state
STATE_PENDING
"
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
;
}
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Notifying
observers
that
"
+
"
the
update
was
staged
.
topic
:
update
-
staged
status
:
"
+
update
.
state
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
staged
"
update
.
state
)
;
}
finally
{
if
(
lazy
.
AUS
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
)
{
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Setting
state
STATE_IDLE
"
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
;
}
}
}
elevationOptedIn
:
function
UM_elevationOptedIn
(
)
{
let
update
=
this
.
_readyUpdate
;
if
(
!
update
)
{
return
;
}
let
status
=
readStatusFile
(
getReadyUpdateDir
(
)
)
;
let
parts
=
status
.
split
(
"
:
"
)
;
update
.
state
=
parts
[
0
]
;
if
(
update
.
state
=
=
STATE_PENDING_ELEVATE
)
{
LOG
(
"
UpdateManager
:
elevationOptedIn
-
Setting
state
to
pending
.
"
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
STATE_PENDING
)
;
}
else
{
LOG
(
"
UpdateManager
:
elevationOptedIn
-
Not
in
pending
-
elevate
state
.
"
)
;
}
}
cleanupDownloadingUpdate
:
function
UM_cleanupDownloadingUpdate
(
)
{
LOG
(
"
UpdateManager
:
cleanupDownloadingUpdate
-
cleaning
up
downloading
update
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
cleanupReadyUpdate
:
function
UM_cleanupReadyUpdate
(
)
{
LOG
(
"
UpdateManager
:
cleanupReadyUpdate
-
cleaning
up
ready
update
.
"
)
;
cleanupReadyUpdate
(
)
;
}
classID
:
Components
.
ID
(
"
{
093C2356
-
4843
-
4C65
-
8709
-
D7DBCBBE7DFB
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateManager
"
"
nsIObserver
"
]
)
}
;
class
CheckerService
{
#
nextUpdateCheckId
=
1
;
#
requestKeyByCheckId
=
{
}
;
#
updateCheckData
=
{
}
;
#
makeUpdateCheckDataObject
(
type
promise
)
{
return
{
type
promise
request
:
null
}
;
}
#
validUpdateCheckType
(
checkType
)
{
return
[
Ci
.
nsIUpdateChecker
.
BACKGROUND_CHECK
Ci
.
nsIUpdateChecker
.
FOREGROUND_CHECK
]
.
includes
(
checkType
)
;
}
#
getCanMigrate
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
return
false
;
}
let
aryABI
=
lazy
.
UpdateUtils
.
ABI
.
split
(
"
-
"
)
;
if
(
aryABI
[
0
]
!
=
"
x86
"
|
|
aryABI
[
2
]
!
=
"
x64
"
)
{
return
false
;
}
let
wrk
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
let
regPath
=
"
SOFTWARE
\
\
Mozilla
\
\
"
+
Services
.
appinfo
.
name
+
"
\
\
32to64DidMigrate
"
;
let
regValHKCU
=
lazy
.
WindowsRegistry
.
readRegKey
(
wrk
.
ROOT_KEY_CURRENT_USER
regPath
"
Never
"
wrk
.
WOW64_32
)
;
let
regValHKLM
=
lazy
.
WindowsRegistry
.
readRegKey
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
regPath
"
Never
"
wrk
.
WOW64_32
)
;
if
(
regValHKCU
=
=
=
1
|
|
regValHKLM
=
=
=
1
)
{
LOG
(
"
CheckerService
:
#
getCanMigrate
-
all
installations
should
not
be
"
+
"
migrated
"
)
;
return
false
;
}
let
appBaseDirPath
=
getAppBaseDir
(
)
.
path
;
regValHKCU
=
lazy
.
WindowsRegistry
.
readRegKey
(
wrk
.
ROOT_KEY_CURRENT_USER
regPath
appBaseDirPath
wrk
.
WOW64_32
)
;
regValHKLM
=
lazy
.
WindowsRegistry
.
readRegKey
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
regPath
appBaseDirPath
wrk
.
WOW64_32
)
;
if
(
regValHKCU
=
=
=
1
|
|
regValHKLM
=
=
=
1
)
{
LOG
(
"
CheckerService
:
#
getCanMigrate
-
this
installation
should
not
be
"
+
"
migrated
"
)
;
return
false
;
}
if
(
regValHKCU
=
=
=
0
|
|
regValHKLM
=
=
=
0
)
{
LOG
(
"
CheckerService
:
#
getCanMigrate
-
this
installation
can
be
migrated
"
)
;
return
true
;
}
LOG
(
"
CheckerService
:
#
getCanMigrate
-
no
registry
entries
for
this
"
+
"
installation
"
)
;
return
false
;
}
async
getUpdateURL
(
checkType
)
{
LOG
(
"
CheckerService
:
getUpdateURL
-
checkType
:
"
+
checkType
)
;
if
(
!
this
.
#
validUpdateCheckType
(
checkType
)
)
{
LOG
(
"
CheckerService
:
getUpdateURL
-
Invalid
checkType
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
url
=
Services
.
appinfo
.
updateURL
;
let
updatePin
;
if
(
Services
.
policies
)
{
let
policies
=
Services
.
policies
.
getActivePolicies
(
)
;
if
(
policies
)
{
if
(
"
AppUpdateURL
"
in
policies
)
{
url
=
policies
.
AppUpdateURL
.
toString
(
)
;
}
if
(
"
AppUpdatePin
"
in
policies
)
{
updatePin
=
policies
.
AppUpdatePin
;
AUSTLMY
.
pingPinPolicy
(
updatePin
)
;
}
}
}
if
(
!
url
)
{
LOG
(
"
CheckerService
:
getUpdateURL
-
update
URL
not
defined
"
)
;
return
null
;
}
url
=
await
lazy
.
UpdateUtils
.
formatUpdateURL
(
url
)
;
if
(
checkType
=
=
Ci
.
nsIUpdateChecker
.
FOREGROUND_CHECK
)
{
url
+
=
(
url
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
)
+
"
force
=
1
"
;
}
if
(
this
.
#
getCanMigrate
(
)
)
{
url
+
=
(
url
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
)
+
"
mig64
=
1
"
;
}
if
(
updatePin
)
{
url
+
=
(
url
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
)
+
"
pin
=
"
+
encodeURIComponent
(
updatePin
)
;
}
LOG
(
"
CheckerService
:
getUpdateURL
-
update
URL
:
"
+
url
)
;
return
url
;
}
checkForUpdates
(
checkType
)
{
LOG
(
"
CheckerService
:
checkForUpdates
-
checkType
:
"
+
checkType
)
;
if
(
!
this
.
#
validUpdateCheckType
(
checkType
)
)
{
LOG
(
"
CheckerService
:
checkForUpdates
-
Invalid
checkType
"
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
checkId
=
this
.
#
nextUpdateCheckId
;
this
.
#
nextUpdateCheckId
+
=
1
;
if
(
lazy
.
AUS
.
disabled
)
{
LOG
(
"
CheckerService
:
checkForUpdates
-
disabled
by
policy
"
)
;
return
this
.
#
getChecksNotAllowedObject
(
checkId
)
;
}
if
(
checkType
=
=
Ci
.
nsIUpdateChecker
.
BACKGROUND_CHECK
&
&
!
lazy
.
AUS
.
canCheckForUpdates
)
{
LOG
(
"
CheckerService
:
checkForUpdates
-
!
canCheckForUpdates
"
)
;
return
this
.
#
getChecksNotAllowedObject
(
checkId
)
;
}
let
requestKey
=
checkType
;
if
(
requestKey
in
this
.
#
updateCheckData
)
{
LOG
(
CheckerService
:
checkForUpdates
-
Connecting
check
id
{
checkId
}
to
+
existing
check
request
.
)
;
}
else
{
LOG
(
CheckerService
:
checkForUpdates
-
Making
new
check
request
for
check
+
id
{
checkId
}
.
)
;
this
.
#
updateCheckData
[
requestKey
]
=
this
.
#
makeUpdateCheckDataObject
(
checkType
this
.
#
updateCheck
(
checkType
requestKey
)
)
;
}
this
.
#
requestKeyByCheckId
[
checkId
]
=
requestKey
;
return
{
id
:
checkId
result
:
this
.
#
updateCheckData
[
requestKey
]
.
promise
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheck
"
]
)
}
;
}
#
getChecksNotAllowedObject
(
checkId
)
{
return
{
id
:
checkId
result
:
Promise
.
resolve
(
Object
.
freeze
(
{
checksAllowed
:
false
succeeded
:
false
request
:
null
updates
:
[
]
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheckResult
"
]
)
}
)
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheck
"
]
)
}
;
}
async
#
updateCheck
(
checkType
requestKey
)
{
await
waitForOtherInstances
(
)
;
let
url
;
try
{
url
=
await
this
.
getUpdateURL
(
checkType
)
;
}
catch
(
ex
)
{
}
if
(
!
url
)
{
LOG
(
"
CheckerService
:
#
updateCheck
-
!
url
"
)
;
return
this
.
#
getCheckFailedObject
(
"
update_url_not_available
"
)
;
}
let
request
=
new
XMLHttpRequest
(
)
;
request
.
open
(
"
GET
"
url
true
)
;
request
.
channel
.
notificationCallbacks
=
new
lazy
.
CertUtils
.
BadCertHandler
(
false
)
;
request
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
;
request
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
INHIBIT_CACHING
;
request
.
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
.
beConservative
=
true
;
request
.
overrideMimeType
(
"
text
/
xml
"
)
;
request
.
setRequestHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
)
;
request
.
setRequestHeader
(
"
Pragma
"
"
no
-
cache
"
)
;
const
UPDATE_CHECK_LOAD_SUCCESS
=
1
;
const
UPDATE_CHECK_LOAD_ERROR
=
2
;
const
UPDATE_CHECK_CANCELLED
=
3
;
let
result
=
await
new
Promise
(
resolve
=
>
{
if
(
!
(
requestKey
in
this
.
#
updateCheckData
)
)
{
LOG
(
"
CheckerService
:
#
updateCheck
-
check
was
cancelled
before
request
"
+
"
was
able
to
start
"
)
;
resolve
(
UPDATE_CHECK_CANCELLED
)
;
return
;
}
let
onLoad
=
event
=
>
{
request
.
removeEventListener
(
"
load
"
onLoad
)
;
LOG
(
"
CheckerService
:
#
updateCheck
-
request
got
'
load
'
event
"
)
;
resolve
(
UPDATE_CHECK_LOAD_SUCCESS
)
;
}
;
request
.
addEventListener
(
"
load
"
onLoad
)
;
let
onError
=
event
=
>
{
request
.
removeEventListener
(
"
error
"
onLoad
)
;
LOG
(
"
CheckerService
:
#
updateCheck
-
request
got
'
error
'
event
"
)
;
resolve
(
UPDATE_CHECK_LOAD_ERROR
)
;
}
;
request
.
addEventListener
(
"
error
"
onError
)
;
LOG
(
"
CheckerService
:
#
updateCheck
-
sending
request
to
:
"
+
url
)
;
request
.
send
(
null
)
;
this
.
#
updateCheckData
[
requestKey
]
.
request
=
request
;
}
)
;
delete
this
.
#
updateCheckData
[
requestKey
]
;
for
(
const
checkId
of
Object
.
keys
(
this
.
#
requestKeyByCheckId
)
)
{
if
(
this
.
#
requestKeyByCheckId
[
checkId
]
=
=
requestKey
)
{
delete
this
.
#
requestKeyByCheckId
[
checkId
]
;
}
}
if
(
result
=
=
UPDATE_CHECK_CANCELLED
)
{
return
this
.
#
getCheckFailedObject
(
Cr
.
NS_BINDING_ABORTED
)
;
}
if
(
result
=
=
UPDATE_CHECK_LOAD_ERROR
)
{
let
status
=
this
.
#
getChannelStatus
(
request
)
;
LOG
(
"
CheckerService
:
#
updateCheck
-
Failed
.
request
.
status
:
"
+
status
)
;
try
{
let
secInfo
=
request
.
channel
.
securityInfo
;
if
(
secInfo
.
serverCert
&
&
secInfo
.
serverCert
.
issuerName
)
{
Services
.
prefs
.
setStringPref
(
"
security
.
pki
.
mitm_canary_issuer
"
secInfo
.
serverCert
.
issuerName
)
;
}
}
catch
(
e
)
{
LOG
(
"
CheckerService
:
#
updateCheck
-
Getting
secInfo
failed
.
"
)
;
}
return
this
.
#
getCheckFailedObject
(
status
404
request
)
;
}
LOG
(
"
CheckerService
:
#
updateCheck
-
request
completed
downloading
document
"
)
;
Services
.
prefs
.
clearUserPref
(
"
security
.
pki
.
mitm_canary_issuer
"
)
;
try
{
let
sslStatus
=
request
.
channel
.
securityInfo
;
if
(
sslStatus
&
&
sslStatus
.
succeededCertChain
)
{
let
rootCert
=
null
;
if
(
sslStatus
.
succeededCertChain
.
length
)
{
rootCert
=
sslStatus
.
succeededCertChain
[
sslStatus
.
succeededCertChain
.
length
-
1
]
;
}
if
(
rootCert
)
{
Services
.
prefs
.
setStringPref
(
"
security
.
pki
.
mitm_detected
"
!
rootCert
.
isBuiltInRoot
)
;
}
}
}
catch
(
e
)
{
LOG
(
"
CheckerService
:
#
updateCheck
-
Getting
sslStatus
failed
.
"
)
;
}
let
updates
;
try
{
updates
=
this
.
#
parseUpdates
(
request
)
;
}
catch
(
e
)
{
LOG
(
"
CheckerService
:
#
updateCheck
-
there
was
a
problem
checking
for
"
+
"
updates
.
Exception
:
"
+
e
)
;
let
status
=
this
.
#
getChannelStatus
(
request
)
;
return
this
.
#
getCheckFailedObject
(
status
200
request
)
;
}
LOG
(
"
CheckerService
:
#
updateCheck
-
number
of
updates
available
:
"
+
updates
.
length
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
;
}
return
Object
.
freeze
(
{
checksAllowed
:
true
succeeded
:
true
request
updates
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheckResult
"
]
)
}
)
;
}
#
getCheckFailedObject
(
errorCode
defaultCode
=
Cr
.
NS_BINDING_FAILED
request
=
null
)
{
let
update
=
new
Update
(
null
)
;
update
.
errorCode
=
errorCode
;
update
.
statusText
=
getStatusTextFromCode
(
errorCode
defaultCode
)
;
if
(
errorCode
=
=
Cr
.
NS_ERROR_OFFLINE
)
{
update
.
errorCode
=
NETWORK_ERROR_OFFLINE
;
}
else
if
(
this
.
#
isHttpStatusCode
(
errorCode
)
)
{
update
.
errorCode
=
HTTP_ERROR_OFFSET
+
errorCode
;
}
return
Object
.
freeze
(
{
checksAllowed
:
true
succeeded
:
false
request
updates
:
[
update
]
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIUpdateCheckResult
"
]
)
}
)
;
}
#
getChannelStatus
(
request
)
{
var
status
=
0
;
try
{
status
=
request
.
status
;
}
catch
(
e
)
{
}
if
(
status
=
=
0
)
{
status
=
request
.
channel
.
QueryInterface
(
Ci
.
nsIRequest
)
.
status
;
}
return
status
;
}
#
isHttpStatusCode
(
status
)
{
return
status
>
=
100
&
&
status
<
=
599
;
}
#
parseUpdates
(
request
)
{
let
updatesElement
=
request
.
responseXML
.
documentElement
;
if
(
!
updatesElement
)
{
LOG
(
"
CheckerService
:
#
parseUpdates
-
empty
updates
document
?
!
"
)
;
return
[
]
;
}
if
(
updatesElement
.
nodeName
!
=
"
updates
"
)
{
LOG
(
"
CheckerService
:
#
parseUpdates
-
unexpected
node
name
!
"
)
;
throw
new
Error
(
"
Unexpected
node
name
expected
:
updates
got
:
"
+
updatesElement
.
nodeName
)
;
}
let
updates
=
[
]
;
for
(
const
updateElement
of
updatesElement
.
childNodes
)
{
if
(
updateElement
.
nodeType
!
=
updateElement
.
ELEMENT_NODE
|
|
updateElement
.
localName
!
=
"
update
"
)
{
continue
;
}
let
update
;
try
{
update
=
new
Update
(
updateElement
)
;
}
catch
(
e
)
{
LOG
(
"
CheckerService
:
#
parseUpdates
-
invalid
<
update
/
>
ignoring
.
.
.
"
)
;
continue
;
}
update
.
serviceURL
=
request
.
responseURL
;
update
.
channel
=
lazy
.
UpdateUtils
.
UpdateChannel
;
updates
.
push
(
update
)
;
}
return
updates
;
}
stopCheck
(
checkId
)
{
if
(
!
(
checkId
in
this
.
#
requestKeyByCheckId
)
)
{
LOG
(
CheckerService
:
stopCheck
-
Non
-
existent
check
id
{
checkId
}
)
;
return
;
}
LOG
(
CheckerService
:
stopCheck
-
Cancelling
check
id
{
checkId
}
)
;
let
requestKey
=
this
.
#
requestKeyByCheckId
[
checkId
]
;
delete
this
.
#
requestKeyByCheckId
[
checkId
]
;
if
(
Object
.
values
(
this
.
#
requestKeyByCheckId
)
.
includes
(
requestKey
)
)
{
LOG
(
CheckerService
:
stopCheck
-
Not
actually
cancelling
request
because
+
other
check
id
'
s
depend
on
it
.
)
;
}
else
{
LOG
(
CheckerService
:
stopCheck
-
This
is
the
last
check
using
this
+
request
.
Cancelling
the
request
now
.
)
;
let
request
=
this
.
#
updateCheckData
[
requestKey
]
.
request
;
delete
this
.
#
updateCheckData
[
requestKey
]
;
if
(
request
)
{
LOG
(
CheckerService
:
stopCheck
-
Aborting
XMLHttpRequest
)
;
request
.
abort
(
)
;
}
else
{
LOG
(
CheckerService
:
stopCheck
-
Not
aborting
XMLHttpRequest
.
It
+
doesn
'
t
appear
to
have
started
yet
.
)
;
}
}
}
stopAllChecks
(
)
{
LOG
(
"
CheckerService
:
stopAllChecks
-
stopping
all
checks
.
"
)
;
for
(
const
checkId
of
Object
.
keys
(
this
.
#
requestKeyByCheckId
)
)
{
this
.
stopCheck
(
checkId
)
;
}
}
classID
=
Components
.
ID
(
"
{
898CDC9B
-
E43F
-
422F
-
9CC4
-
2F6291B415A3
}
"
)
;
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIUpdateChecker
"
]
)
;
}
function
Downloader
(
updateService
)
{
LOG
(
"
Creating
Downloader
"
)
;
this
.
updateService
=
updateService
;
}
Downloader
.
prototype
=
{
_patch
:
null
_update
:
null
_request
:
null
isCompleteUpdate
:
null
_pendingRequest
:
null
_cancelPromise
:
null
_bitsActiveNotifications
:
false
_langPackTimeout
:
null
_pretendingDownloadIsNotDone
:
false
cancel
:
async
function
Downloader_cancel
(
cancelError
)
{
LOG
(
"
Downloader
:
cancel
"
)
;
if
(
cancelError
=
=
=
undefined
)
{
cancelError
=
Cr
.
NS_BINDING_ABORTED
;
}
if
(
this
.
usingBits
)
{
if
(
this
.
_cancelPromise
)
{
await
this
.
_cancelPromise
;
return
;
}
if
(
this
.
_pendingRequest
)
{
await
this
.
_pendingRequest
;
}
if
(
this
.
_patch
.
getProperty
(
"
bitsId
"
)
!
=
null
)
{
this
.
_patch
.
deleteProperty
(
"
bitsId
"
)
;
}
try
{
this
.
_cancelPromise
=
this
.
_request
.
cancelAsync
(
cancelError
)
;
await
this
.
_cancelPromise
;
}
catch
(
e
)
{
this
.
_cancelPromise
=
null
;
throw
e
;
}
}
else
if
(
this
.
_request
&
&
this
.
_request
instanceof
Ci
.
nsIRequest
)
{
if
(
this
.
_pretendingDownloadIsNotDone
)
{
LOG
(
"
Downloader
:
cancel
-
Ignoring
cancel
request
of
finished
download
"
)
;
}
else
{
this
.
_request
.
cancel
(
cancelError
)
;
}
}
}
_verifyDownload
:
function
Downloader__verifyDownload
(
)
{
LOG
(
"
Downloader
:
_verifyDownload
called
"
)
;
if
(
!
this
.
_request
)
{
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_ERR_VERIFY_NO_REQUEST
)
;
return
false
;
}
let
destination
=
getDownloadingUpdateDir
(
)
;
destination
.
append
(
FILE_UPDATE_MAR
)
;
if
(
destination
.
fileSize
!
=
this
.
_patch
.
size
)
{
LOG
(
"
Downloader
:
_verifyDownload
downloaded
size
!
=
expected
size
.
"
)
;
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_ERR_VERIFY_PATCH_SIZE_NOT_EQUAL
)
;
return
false
;
}
LOG
(
"
Downloader
:
_verifyDownload
downloaded
size
=
=
expected
size
.
"
)
;
return
true
;
}
_selectPatch
:
function
Downloader__selectPatch
(
update
updateDir
)
{
var
selectedPatch
=
update
.
selectedPatch
;
var
state
=
selectedPatch
?
selectedPatch
.
state
:
STATE_NONE
;
var
useComplete
=
false
;
if
(
selectedPatch
)
{
LOG
(
"
Downloader
:
_selectPatch
-
found
existing
patch
with
state
:
"
+
state
)
;
if
(
state
=
=
STATE_DOWNLOADING
)
{
LOG
(
"
Downloader
:
_selectPatch
-
resuming
download
"
)
;
return
selectedPatch
;
}
if
(
state
=
=
STATE_PENDING
|
|
state
=
=
STATE_PENDING_SERVICE
|
|
state
=
=
STATE_PENDING_ELEVATE
|
|
state
=
=
STATE_APPLIED
|
|
state
=
=
STATE_APPLIED_SERVICE
)
{
LOG
(
"
Downloader
:
_selectPatch
-
already
downloaded
"
)
;
return
null
;
}
selectedPatch
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
if
(
selectedPatch
.
getProperty
(
"
bitsResult
"
)
!
=
null
&
&
selectedPatch
.
getProperty
(
"
internalResult
"
)
=
=
null
&
&
!
selectedPatch
.
errorCode
)
{
LOG
(
"
Downloader
:
_selectPatch
-
Falling
back
to
non
-
BITS
download
"
+
"
mechanism
for
the
same
patch
due
to
existing
BITS
result
:
"
+
selectedPatch
.
getProperty
(
"
bitsResult
"
)
)
;
return
selectedPatch
;
}
if
(
update
&
&
selectedPatch
.
type
=
=
"
complete
"
)
{
LOG
(
"
Downloader
:
_selectPatch
-
failed
to
apply
complete
patch
!
"
)
;
cleanupDownloadingUpdate
(
)
;
return
null
;
}
useComplete
=
true
;
selectedPatch
=
null
;
}
var
partialPatch
=
getPatchOfType
(
update
"
partial
"
)
;
if
(
!
useComplete
)
{
selectedPatch
=
partialPatch
;
}
if
(
!
selectedPatch
)
{
if
(
lazy
.
UM
.
readyUpdate
)
{
LOG
(
"
Downloader
:
_selectPatch
-
not
selecting
a
complete
patch
because
"
+
"
this
is
not
the
first
download
of
the
session
"
)
;
return
null
;
}
if
(
partialPatch
)
{
partialPatch
.
selected
=
false
;
}
selectedPatch
=
getPatchOfType
(
update
"
complete
"
)
;
}
if
(
selectedPatch
)
{
selectedPatch
.
selected
=
true
;
update
.
isCompleteUpdate
=
selectedPatch
.
type
=
=
"
complete
"
;
}
LOG
(
"
Downloader
:
_selectPatch
-
Patch
selected
.
Assigning
update
to
"
+
"
downloadingUpdate
.
"
)
;
lazy
.
UM
.
downloadingUpdate
=
update
;
return
selectedPatch
;
}
get
_notifyDuringDownload
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_NOTIFYDURINGDOWNLOAD
false
)
;
}
_notifyDownloadStatusObservers
:
function
Downloader_notifyDownloadStatusObservers
(
)
{
if
(
this
.
_notifyDuringDownload
)
{
let
status
=
this
.
updateService
.
isDownloading
?
"
downloading
"
:
"
idle
"
;
Services
.
obs
.
notifyObservers
(
this
.
_update
"
update
-
downloading
"
status
)
;
}
}
get
isBusy
(
)
{
return
this
.
_request
!
=
null
|
|
this
.
_pendingRequest
!
=
null
;
}
get
usingBits
(
)
{
return
this
.
_pendingRequest
!
=
null
|
|
this
.
_request
instanceof
BitsRequest
;
}
_canUseBits
:
function
Downloader__canUseBits
(
patch
)
{
if
(
getCanUseBits
(
)
!
=
"
CanUseBits
"
)
{
return
false
;
}
if
(
patch
.
getProperty
(
"
bitsResult
"
)
!
=
null
)
{
LOG
(
"
Downloader
:
_canUseBits
-
Not
using
BITS
because
it
was
already
tried
"
)
;
return
false
;
}
LOG
(
"
Downloader
:
_canUseBits
-
Patch
is
able
to
use
BITS
download
"
)
;
return
true
;
}
_startLangPackUpdates
:
function
Downloader__startLangPackUpdates
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LANGPACK_ENABLED
false
)
)
{
return
;
}
let
timeoutPromise
=
new
Promise
(
resolve
=
>
{
this
.
_langPackTimeout
=
resolve
;
}
)
;
let
update
=
unwrap
(
this
.
_update
)
;
let
existing
=
LangPackUpdates
.
get
(
update
)
;
if
(
existing
)
{
return
;
}
let
langPackPromise
=
lazy
.
AddonManager
.
stageLangpacksForAppUpdate
(
update
.
appVersion
update
.
appVersion
)
.
catch
(
error
=
>
{
LOG
(
Add
-
ons
manager
threw
exception
while
updating
language
packs
:
{
error
}
)
;
}
)
.
finally
(
(
)
=
>
{
this
.
_langPackTimeout
=
null
;
if
(
TelemetryStopwatch
.
running
(
"
UPDATE_LANGPACK_OVERTIME
"
update
)
)
{
TelemetryStopwatch
.
finish
(
"
UPDATE_LANGPACK_OVERTIME
"
update
)
;
}
}
)
;
LangPackUpdates
.
set
(
update
Promise
.
race
(
[
langPackPromise
timeoutPromise
]
)
)
;
}
downloadUpdate
:
async
function
Downloader_downloadUpdate
(
update
)
{
LOG
(
"
UpdateService
:
downloadUpdate
"
)
;
if
(
!
update
)
{
AUSTLMY
.
pingDownloadCode
(
undefined
AUSTLMY
.
DWNLD_ERR_NO_UPDATE
)
;
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NULL_POINTER
)
;
}
var
updateDir
=
getDownloadingUpdateDir
(
)
;
this
.
_update
=
update
;
this
.
_patch
=
this
.
_selectPatch
(
update
updateDir
)
;
if
(
!
this
.
_patch
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
no
patch
to
download
"
)
;
AUSTLMY
.
pingDownloadCode
(
undefined
AUSTLMY
.
DWNLD_ERR_NO_UPDATE_PATCH
)
;
return
false
;
}
this
.
_update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
this
.
_patch
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
if
(
this
.
_update
.
getProperty
(
"
disableBackgroundUpdates
"
)
!
=
null
&
&
lazy
.
gIsBackgroundTaskMode
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
Background
update
disabled
by
update
"
+
"
advertisement
"
)
;
return
false
;
}
this
.
isCompleteUpdate
=
this
.
_patch
.
type
=
=
"
complete
"
;
let
canUseBits
=
false
;
if
(
this
.
_update
.
getProperty
(
"
disableBITS
"
)
!
=
null
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
BITS
downloads
disabled
by
update
"
+
"
advertisement
"
)
;
}
else
{
canUseBits
=
this
.
_canUseBits
(
this
.
_patch
)
;
}
if
(
!
canUseBits
)
{
this
.
_pendingRequest
=
null
;
let
patchFile
=
updateDir
.
clone
(
)
;
patchFile
.
append
(
FILE_UPDATE_MAR
)
;
if
(
lazy
.
gIsBackgroundTaskMode
)
{
let
readyUpdateDir
=
getReadyUpdateDir
(
)
;
let
status
=
readStatusFile
(
readyUpdateDir
)
;
if
(
!
(
status
=
=
STATE_DOWNLOADING
&
&
patchFile
.
exists
(
)
)
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
Can
'
t
download
with
internal
"
+
"
downloader
from
a
background
task
.
Cleaning
up
downloading
"
+
"
update
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
return
false
;
}
let
interval
=
0
;
LOG
(
"
Downloader
:
downloadUpdate
-
Starting
nsIIncrementalDownload
with
"
+
"
url
:
"
+
this
.
_patch
.
URL
+
"
path
:
"
+
patchFile
.
path
+
"
interval
:
"
+
interval
)
;
let
uri
=
Services
.
io
.
newURI
(
this
.
_patch
.
URL
)
;
this
.
_request
=
Cc
[
"
mozilla
.
org
/
network
/
incremental
-
download
;
1
"
]
.
createInstance
(
Ci
.
nsIIncrementalDownload
)
;
this
.
_request
.
init
(
uri
patchFile
DOWNLOAD_CHUNK_SIZE
interval
)
;
this
.
_request
.
start
(
this
null
)
;
}
else
{
let
noProgressTimeout
=
BITS_IDLE_NO_PROGRESS_TIMEOUT_SECS
;
let
monitorInterval
=
BITS_IDLE_POLL_RATE_MS
;
this
.
_bitsActiveNotifications
=
false
;
let
monitorTimeout
=
Math
.
max
(
10
*
monitorInterval
10
*
60
*
1000
)
;
if
(
this
.
hasDownloadListeners
)
{
noProgressTimeout
=
BITS_ACTIVE_NO_PROGRESS_TIMEOUT_SECS
;
monitorInterval
=
BITS_ACTIVE_POLL_RATE_MS
;
this
.
_bitsActiveNotifications
=
true
;
}
let
updateRootDir
=
FileUtils
.
getDir
(
KEY_UPDROOT
[
]
true
)
;
let
jobName
=
"
MozillaUpdate
"
+
updateRootDir
.
leafName
;
let
updatePath
=
updateDir
.
path
;
if
(
!
Bits
.
initialized
)
{
Bits
.
init
(
jobName
updatePath
monitorTimeout
)
;
}
this
.
_cancelPromise
=
null
;
let
bitsId
=
this
.
_patch
.
getProperty
(
"
bitsId
"
)
;
if
(
bitsId
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
Connecting
to
in
-
progress
download
.
"
+
"
BITS
ID
:
"
+
bitsId
)
;
this
.
_pendingRequest
=
Bits
.
monitorDownload
(
bitsId
monitorInterval
this
null
)
;
}
else
{
LOG
(
"
Downloader
:
downloadUpdate
-
Starting
BITS
download
with
url
:
"
+
this
.
_patch
.
URL
+
"
updateDir
:
"
+
updatePath
+
"
filename
:
"
+
FILE_UPDATE_MAR
)
;
this
.
_pendingRequest
=
Bits
.
startDownload
(
this
.
_patch
.
URL
FILE_UPDATE_MAR
Ci
.
nsIBits
.
PROXY_PRECONFIG
noProgressTimeout
monitorInterval
this
null
)
;
}
let
request
;
try
{
request
=
await
this
.
_pendingRequest
;
}
catch
(
error
)
{
if
(
(
error
.
type
=
=
Ci
.
nsIBits
.
ERROR_TYPE_FAILED_TO_GET_BITS_JOB
|
|
error
.
type
=
=
Ci
.
nsIBits
.
ERROR_TYPE_FAILED_TO_CONNECT_TO_BCM
)
&
&
error
.
action
=
=
Ci
.
nsIBits
.
ERROR_ACTION_MONITOR_DOWNLOAD
&
&
error
.
stage
=
=
Ci
.
nsIBits
.
ERROR_STAGE_BITS_CLIENT
&
&
error
.
codeType
=
=
Ci
.
nsIBits
.
ERROR_CODE_TYPE_HRESULT
&
&
error
.
code
=
=
HRESULT_E_ACCESSDENIED
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
Failed
to
connect
to
existing
"
+
"
BITS
job
.
It
is
likely
owned
by
another
user
.
"
)
;
error
.
type
=
Ci
.
nsIBits
.
ERROR_TYPE_ACCESS_DENIED_EXPECTED
;
error
.
codeType
=
Ci
.
nsIBits
.
ERROR_CODE_TYPE_NONE
;
error
.
code
=
null
;
gBITSInUseByAnotherUser
=
true
;
}
else
{
this
.
_patch
.
setProperty
(
"
bitsResult
"
Cr
.
NS_ERROR_FAILURE
)
;
lazy
.
UM
.
saveUpdates
(
)
;
LOG
(
"
Downloader
:
downloadUpdate
-
Failed
to
start
to
BITS
job
.
"
+
"
Error
:
"
+
error
)
;
}
this
.
_pendingRequest
=
null
;
AUSTLMY
.
pingBitsError
(
this
.
isCompleteUpdate
error
)
;
return
this
.
downloadUpdate
(
this
.
_update
)
;
}
this
.
_request
=
request
;
this
.
_patch
.
setProperty
(
"
bitsId
"
request
.
bitsId
)
;
LOG
(
"
Downloader
:
downloadUpdate
-
BITS
download
running
.
BITS
ID
:
"
+
request
.
bitsId
)
;
if
(
this
.
hasDownloadListeners
)
{
this
.
_maybeStartActiveNotifications
(
)
;
}
else
{
this
.
_maybeStopActiveNotifications
(
)
;
}
lazy
.
UM
.
saveUpdates
(
)
;
this
.
_pendingRequest
=
null
;
}
if
(
!
lazy
.
UM
.
readyUpdate
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
Setting
status
to
downloading
"
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
STATE_DOWNLOADING
)
;
}
if
(
this
.
_patch
.
state
!
=
STATE_DOWNLOADING
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
Setting
state
to
downloading
"
)
;
this
.
_patch
.
state
=
STATE_DOWNLOADING
;
lazy
.
UM
.
saveUpdates
(
)
;
}
if
(
lazy
.
AUS
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
not
setting
state
because
download
is
"
+
"
already
pending
.
"
)
;
}
else
{
LOG
(
"
Downloader
:
downloadUpdate
-
setting
currentState
to
STATE_DOWNLOADING
"
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_DOWNLOADING
)
;
}
this
.
_startLangPackUpdates
(
)
;
this
.
_notifyDownloadStatusObservers
(
)
;
return
true
;
}
onDownloadListenerAdded
:
function
Downloader_onDownloadListenerAdded
(
)
{
this
.
_maybeStartActiveNotifications
(
)
;
}
onDownloadListenerRemoved
:
function
Downloader_onDownloadListenerRemoved
(
)
{
if
(
!
this
.
hasDownloadListeners
)
{
this
.
_maybeStopActiveNotifications
(
)
;
}
}
get
hasDownloadListeners
(
)
{
return
this
.
updateService
.
hasDownloadListeners
;
}
_maybeStartActiveNotifications
:
async
function
Downloader__maybeStartActiveNotifications
(
)
{
if
(
this
.
usingBits
&
&
!
this
.
_bitsActiveNotifications
&
&
this
.
hasDownloadListeners
&
&
this
.
_request
)
{
LOG
(
"
Downloader
:
_maybeStartActiveNotifications
-
Starting
active
"
+
"
notifications
"
)
;
this
.
_bitsActiveNotifications
=
true
;
await
Promise
.
all
(
[
this
.
_request
.
setNoProgressTimeout
(
BITS_ACTIVE_NO_PROGRESS_TIMEOUT_SECS
)
.
catch
(
error
=
>
{
LOG
(
"
Downloader
:
_maybeStartActiveNotifications
-
Failed
to
set
"
+
"
no
progress
timeout
.
Error
:
"
+
error
)
;
}
)
this
.
_request
.
changeMonitorInterval
(
BITS_ACTIVE_POLL_RATE_MS
)
.
catch
(
error
=
>
{
LOG
(
"
Downloader
:
_maybeStartActiveNotifications
-
Failed
to
increase
"
+
"
status
update
frequency
.
Error
:
"
+
error
)
;
}
)
]
)
;
}
}
_maybeStopActiveNotifications
:
async
function
Downloader__maybeStopActiveNotifications
(
)
{
if
(
this
.
usingBits
&
&
this
.
_bitsActiveNotifications
&
&
!
this
.
hasDownloadListeners
&
&
this
.
_request
)
{
LOG
(
"
Downloader
:
_maybeStopActiveNotifications
-
Stopping
active
"
+
"
notifications
"
)
;
this
.
_bitsActiveNotifications
=
false
;
await
Promise
.
all
(
[
this
.
_request
.
setNoProgressTimeout
(
BITS_IDLE_NO_PROGRESS_TIMEOUT_SECS
)
.
catch
(
error
=
>
{
LOG
(
"
Downloader
:
_maybeStopActiveNotifications
-
Failed
to
set
"
+
"
no
progress
timeout
:
"
+
error
)
;
}
)
this
.
_request
.
changeMonitorInterval
(
BITS_IDLE_POLL_RATE_MS
)
.
catch
(
error
=
>
{
LOG
(
"
Downloader
:
_maybeStopActiveNotifications
-
Failed
to
decrease
"
+
"
status
update
frequency
:
"
+
error
)
;
}
)
]
)
;
}
}
onStartRequest
:
function
Downloader_onStartRequest
(
request
)
{
if
(
this
.
usingBits
)
{
LOG
(
"
Downloader
:
onStartRequest
"
)
;
}
else
{
LOG
(
"
Downloader
:
onStartRequest
-
original
URI
spec
:
"
+
request
.
URI
.
spec
+
"
final
URI
spec
:
"
+
request
.
finalURI
.
spec
)
;
if
(
this
.
_patch
.
finalURL
!
=
request
.
finalURI
.
spec
)
{
this
.
_patch
.
finalURL
=
request
.
finalURI
.
spec
;
lazy
.
UM
.
saveUpdates
(
)
;
}
}
this
.
updateService
.
forEachDownloadListener
(
listener
=
>
{
listener
.
onStartRequest
(
request
)
;
}
)
;
}
onProgress
:
function
Downloader_onProgress
(
request
progress
maxProgress
)
{
LOG
(
"
Downloader
:
onProgress
-
progress
:
"
+
progress
+
"
/
"
+
maxProgress
)
;
if
(
progress
>
this
.
_patch
.
size
)
{
LOG
(
"
Downloader
:
onProgress
-
progress
:
"
+
progress
+
"
is
higher
than
patch
size
:
"
+
this
.
_patch
.
size
)
;
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_ERR_PATCH_SIZE_LARGER
)
;
this
.
cancel
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
progress
>
0
&
&
maxProgress
!
=
this
.
_patch
.
size
)
{
LOG
(
"
Downloader
:
onProgress
-
maxProgress
:
"
+
maxProgress
+
"
is
not
equal
to
expected
patch
size
:
"
+
this
.
_patch
.
size
)
;
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_ERR_PATCH_SIZE_NOT_EQUAL
)
;
this
.
cancel
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
this
.
updateService
.
forEachDownloadListener
(
listener
=
>
{
if
(
listener
instanceof
Ci
.
nsIProgressEventSink
)
{
listener
.
onProgress
(
request
progress
maxProgress
)
;
}
}
)
;
this
.
updateService
.
_consecutiveSocketErrors
=
0
;
}
onStatus
:
function
Downloader_onStatus
(
request
status
statusText
)
{
LOG
(
"
Downloader
:
onStatus
-
status
:
"
+
status
+
"
statusText
:
"
+
statusText
)
;
this
.
updateService
.
forEachDownloadListener
(
listener
=
>
{
if
(
listener
instanceof
Ci
.
nsIProgressEventSink
)
{
listener
.
onStatus
(
request
status
statusText
)
;
}
}
)
;
}
onStopRequest
:
async
function
Downloader_onStopRequest
(
request
status
)
{
if
(
gOnlyDownloadUpdatesThisSession
)
{
LOG
(
"
Downloader
:
onStopRequest
-
End
of
update
download
detected
and
"
+
"
ignored
because
we
are
restricted
to
update
downloads
this
"
+
"
session
.
We
will
continue
with
this
update
next
session
.
"
)
;
this
.
_pretendingDownloadIsNotDone
=
true
;
Services
.
obs
.
notifyObservers
(
null
"
update
-
download
-
restriction
-
hit
"
)
;
return
;
}
if
(
!
this
.
usingBits
)
{
LOG
(
"
Downloader
:
onStopRequest
-
downloader
:
nsIIncrementalDownload
"
+
"
original
URI
spec
:
"
+
request
.
URI
.
spec
+
"
final
URI
spec
:
"
+
request
.
finalURI
.
spec
+
"
status
:
"
+
status
)
;
}
else
{
LOG
(
"
Downloader
:
onStopRequest
-
downloader
:
BITS
status
:
"
+
status
)
;
}
let
bitsCompletionError
;
if
(
this
.
usingBits
)
{
if
(
Components
.
isSuccessCode
(
status
)
)
{
try
{
await
request
.
complete
(
)
;
}
catch
(
e
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Unable
to
complete
BITS
download
:
"
+
e
)
;
status
=
Cr
.
NS_ERROR_FAILURE
;
bitsCompletionError
=
e
;
}
}
else
{
try
{
await
this
.
cancel
(
)
;
}
catch
(
e
)
{
}
}
}
var
state
=
this
.
_patch
.
state
;
var
shouldShowPrompt
=
false
;
var
shouldRegisterOnlineObserver
=
false
;
var
shouldRetrySoon
=
false
;
var
deleteActiveUpdate
=
false
;
let
migratedToReadyUpdate
=
false
;
let
nonDownloadFailure
=
false
;
var
retryTimeout
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_SOCKET_RETRYTIMEOUT
DEFAULT_SOCKET_RETRYTIMEOUT
)
;
retryTimeout
=
Math
.
min
(
retryTimeout
10000
)
;
var
maxFail
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_SOCKET_MAXERRORS
DEFAULT_SOCKET_MAX_ERRORS
)
;
maxFail
=
Math
.
min
(
maxFail
20
)
;
LOG
(
"
Downloader
:
onStopRequest
-
status
:
"
+
status
+
"
"
+
"
current
fail
:
"
+
this
.
updateService
.
_consecutiveSocketErrors
+
"
"
+
"
max
fail
:
"
+
maxFail
+
"
"
+
"
retryTimeout
:
"
+
retryTimeout
)
;
if
(
Components
.
isSuccessCode
(
status
)
)
{
if
(
this
.
_verifyDownload
(
)
)
{
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_SUCCESS
)
;
LOG
(
"
Downloader
:
onStopRequest
-
Clearing
readyUpdate
in
preparation
of
"
+
"
moving
downloadingUpdate
into
readyUpdate
.
"
)
;
lazy
.
UM
.
readyUpdate
=
null
;
if
(
lazy
.
AUS
.
currentState
=
=
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
{
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_SWAP
)
;
}
Services
.
obs
.
notifyObservers
(
this
.
_update
"
update
-
swap
"
)
;
cleanUpReadyUpdateDir
(
)
;
let
downloadedMar
=
getDownloadingUpdateDir
(
)
;
downloadedMar
.
append
(
FILE_UPDATE_MAR
)
;
let
readyDir
=
getReadyUpdateDir
(
)
;
try
{
downloadedMar
.
moveTo
(
readyDir
FILE_UPDATE_MAR
)
;
migratedToReadyUpdate
=
true
;
}
catch
(
e
)
{
migratedToReadyUpdate
=
false
;
}
if
(
migratedToReadyUpdate
)
{
AUSTLMY
.
pingMoveResult
(
AUSTLMY
.
MOVE_RESULT_SUCCESS
)
;
state
=
getBestPendingState
(
)
;
shouldShowPrompt
=
!
getCanStageUpdates
(
)
;
LOG
(
Downloader
:
onStopRequest
-
Ready
to
apply
.
Setting
state
to
+
"
{
state
}
"
.
)
;
writeStatusFile
(
getReadyUpdateDir
(
)
state
)
;
writeVersionFile
(
getReadyUpdateDir
(
)
this
.
_update
.
appVersion
)
;
this
.
_update
.
installDate
=
new
Date
(
)
.
getTime
(
)
;
this
.
_update
.
statusText
=
lazy
.
gUpdateBundle
.
GetStringFromName
(
"
installPending
"
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
0
)
;
}
else
{
LOG
(
"
Downloader
:
onStopRequest
-
failed
to
move
the
downloading
"
+
"
update
to
the
ready
update
directory
.
"
)
;
AUSTLMY
.
pingMoveResult
(
AUSTLMY
.
MOVE_RESULT_UNKNOWN_FAILURE
)
;
state
=
STATE_DOWNLOAD_FAILED
;
status
=
Cr
.
NS_ERROR_FILE_COPY_OR_MOVE_FAILED
;
const
mfCode
=
"
move_failed
"
;
let
message
=
getStatusTextFromCode
(
mfCode
mfCode
)
;
this
.
_update
.
statusText
=
message
;
nonDownloadFailure
=
true
;
deleteActiveUpdate
=
true
;
cleanUpDownloadingUpdateDir
(
)
;
}
}
else
{
LOG
(
"
Downloader
:
onStopRequest
-
download
verification
failed
"
)
;
state
=
STATE_DOWNLOAD_FAILED
;
status
=
Cr
.
NS_ERROR_CORRUPTED_CONTENT
;
const
vfCode
=
"
verification_failed
"
;
var
message
=
getStatusTextFromCode
(
vfCode
vfCode
)
;
this
.
_update
.
statusText
=
message
;
if
(
this
.
_update
.
isCompleteUpdate
|
|
this
.
_update
.
patchCount
!
=
2
)
{
LOG
(
"
Downloader
:
onStopRequest
-
No
alternative
patch
to
try
"
)
;
deleteActiveUpdate
=
true
;
}
cleanUpDownloadingUpdateDir
(
)
;
}
}
else
if
(
status
=
=
Cr
.
NS_ERROR_OFFLINE
)
{
LOG
(
"
Downloader
:
onStopRequest
-
offline
register
online
observer
:
true
"
)
;
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_RETRY_OFFLINE
)
;
shouldRegisterOnlineObserver
=
true
;
deleteActiveUpdate
=
false
;
}
else
if
(
(
status
=
=
Cr
.
NS_ERROR_NET_TIMEOUT
|
|
status
=
=
Cr
.
NS_ERROR_CONNECTION_REFUSED
|
|
status
=
=
Cr
.
NS_ERROR_NET_RESET
|
|
status
=
=
Cr
.
NS_ERROR_DOCUMENT_NOT_CACHED
)
&
&
this
.
updateService
.
_consecutiveSocketErrors
<
maxFail
)
{
LOG
(
"
Downloader
:
onStopRequest
-
socket
error
shouldRetrySoon
:
true
"
)
;
let
dwnldCode
=
AUSTLMY
.
DWNLD_RETRY_CONNECTION_REFUSED
;
if
(
status
=
=
Cr
.
NS_ERROR_NET_TIMEOUT
)
{
dwnldCode
=
AUSTLMY
.
DWNLD_RETRY_NET_TIMEOUT
;
}
else
if
(
status
=
=
Cr
.
NS_ERROR_NET_RESET
)
{
dwnldCode
=
AUSTLMY
.
DWNLD_RETRY_NET_RESET
;
}
else
if
(
status
=
=
Cr
.
NS_ERROR_DOCUMENT_NOT_CACHED
)
{
dwnldCode
=
AUSTLMY
.
DWNLD_ERR_DOCUMENT_NOT_CACHED
;
}
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
dwnldCode
)
;
shouldRetrySoon
=
true
;
deleteActiveUpdate
=
false
;
}
else
if
(
status
!
=
Cr
.
NS_BINDING_ABORTED
&
&
status
!
=
Cr
.
NS_ERROR_ABORT
)
{
if
(
status
=
=
Cr
.
NS_ERROR_FILE_ACCESS_DENIED
|
|
status
=
=
Cr
.
NS_ERROR_FILE_READ_ONLY
)
{
LOG
(
"
Downloader
:
onStopRequest
-
permission
error
"
)
;
nonDownloadFailure
=
true
;
}
else
{
LOG
(
"
Downloader
:
onStopRequest
-
non
-
verification
failure
"
)
;
}
let
dwnldCode
=
AUSTLMY
.
DWNLD_ERR_BINDING_ABORTED
;
if
(
status
=
=
Cr
.
NS_ERROR_ABORT
)
{
dwnldCode
=
AUSTLMY
.
DWNLD_ERR_ABORT
;
}
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
dwnldCode
)
;
state
=
STATE_DOWNLOAD_FAILED
;
this
.
_update
.
statusText
=
getStatusTextFromCode
(
status
Cr
.
NS_BINDING_FAILED
)
;
cleanUpDownloadingUpdateDir
(
)
;
deleteActiveUpdate
=
true
;
}
if
(
!
this
.
usingBits
)
{
LOG
(
Downloader
:
onStopRequest
-
Setting
internalResult
to
{
status
}
)
;
this
.
_patch
.
setProperty
(
"
internalResult
"
status
)
;
}
else
{
LOG
(
Downloader
:
onStopRequest
-
Setting
bitsResult
to
{
status
}
)
;
this
.
_patch
.
setProperty
(
"
bitsResult
"
status
)
;
if
(
!
Components
.
isSuccessCode
(
status
)
&
&
status
!
=
Cr
.
NS_BINDING_ABORTED
&
&
status
!
=
Cr
.
NS_ERROR_ABORT
)
{
deleteActiveUpdate
=
false
;
shouldRetrySoon
=
true
;
}
if
(
Components
.
isSuccessCode
(
status
)
)
{
AUSTLMY
.
pingBitsSuccess
(
this
.
isCompleteUpdate
)
;
}
else
{
let
error
;
if
(
bitsCompletionError
)
{
error
=
bitsCompletionError
;
}
else
if
(
status
=
=
Cr
.
NS_ERROR_CORRUPTED_CONTENT
)
{
error
=
new
BitsVerificationError
(
)
;
}
else
{
error
=
request
.
transferError
;
if
(
!
error
)
{
error
=
new
BitsUnknownError
(
)
;
}
}
AUSTLMY
.
pingBitsError
(
this
.
isCompleteUpdate
error
)
;
}
}
LOG
(
"
Downloader
:
onStopRequest
-
setting
state
to
:
"
+
state
)
;
if
(
this
.
_patch
.
state
!
=
state
)
{
this
.
_patch
.
state
=
state
;
}
if
(
deleteActiveUpdate
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Clearing
downloadingUpdate
.
"
)
;
this
.
_update
.
installDate
=
new
Date
(
)
.
getTime
(
)
;
lazy
.
UM
.
addUpdateToHistory
(
lazy
.
UM
.
downloadingUpdate
)
;
lazy
.
UM
.
downloadingUpdate
=
null
;
}
else
if
(
lazy
.
UM
.
downloadingUpdate
&
&
lazy
.
UM
.
downloadingUpdate
.
state
!
=
state
)
{
lazy
.
UM
.
downloadingUpdate
.
state
=
state
;
}
if
(
migratedToReadyUpdate
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Moving
downloadingUpdate
into
readyUpdate
"
)
;
lazy
.
UM
.
readyUpdate
=
lazy
.
UM
.
downloadingUpdate
;
lazy
.
UM
.
downloadingUpdate
=
null
;
}
lazy
.
UM
.
saveUpdates
(
)
;
if
(
!
shouldRetrySoon
&
&
!
shouldRegisterOnlineObserver
)
{
this
.
updateService
.
forEachDownloadListener
(
listener
=
>
{
listener
.
onStopRequest
(
request
status
)
;
}
)
;
}
this
.
_request
=
null
;
this
.
_notifyDownloadStatusObservers
(
)
;
if
(
state
=
=
STATE_DOWNLOAD_FAILED
)
{
var
allFailed
=
true
;
if
(
!
nonDownloadFailure
)
{
if
(
request
instanceof
BitsRequest
)
{
LOG
(
"
Downloader
:
onStopRequest
-
BITS
download
failed
.
Falling
back
"
+
"
to
nsIIncrementalDownload
"
)
;
let
success
=
await
this
.
downloadUpdate
(
this
.
_update
)
;
if
(
!
success
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Failed
to
fall
back
to
"
+
"
nsIIncrementalDownload
.
Cleaning
up
downloading
update
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
else
{
allFailed
=
false
;
}
}
if
(
allFailed
&
&
!
this
.
_update
.
isCompleteUpdate
&
&
this
.
_update
.
patchCount
=
=
2
)
{
LOG
(
"
Downloader
:
onStopRequest
-
verification
of
patch
failed
"
+
"
downloading
complete
update
patch
"
)
;
this
.
_update
.
isCompleteUpdate
=
true
;
let
success
=
await
this
.
downloadUpdate
(
this
.
_update
)
;
if
(
!
success
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Failed
to
fall
back
to
complete
"
+
"
patch
.
Cleaning
up
downloading
update
.
"
)
;
cleanupDownloadingUpdate
(
)
;
}
else
{
allFailed
=
false
;
}
}
}
if
(
allFailed
)
{
let
downloadAttempts
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
0
)
;
downloadAttempts
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
downloadAttempts
)
;
let
maxAttempts
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_DOWNLOAD_MAXATTEMPTS
2
)
10
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_IDLE
)
;
if
(
downloadAttempts
>
maxAttempts
)
{
LOG
(
"
Downloader
:
onStopRequest
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
download
-
attempts
-
exceeded
"
+
"
downloadAttempts
:
"
+
downloadAttempts
+
"
"
+
"
maxAttempts
:
"
+
maxAttempts
)
;
Services
.
obs
.
notifyObservers
(
this
.
_update
"
update
-
error
"
"
download
-
attempts
-
exceeded
"
)
;
}
else
{
this
.
_update
.
selectedPatch
.
selected
=
false
;
LOG
(
"
Downloader
:
onStopRequest
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
download
-
attempt
-
failed
"
)
;
Services
.
obs
.
notifyObservers
(
this
.
_update
"
update
-
error
"
"
download
-
attempt
-
failed
"
)
;
}
this
.
_langPackTimeout
=
null
;
LangPackUpdates
.
delete
(
unwrap
(
this
.
_update
)
)
;
this
.
_update
=
null
;
this
.
updateService
.
_downloader
=
null
;
}
return
;
}
if
(
state
!
=
STATE_DOWNLOADING
)
{
this
.
updateService
.
_downloader
=
null
;
}
if
(
state
=
=
STATE_PENDING
|
|
state
=
=
STATE_PENDING_SERVICE
|
|
state
=
=
STATE_PENDING_ELEVATE
)
{
if
(
getCanStageUpdates
(
)
)
{
LOG
(
"
Downloader
:
onStopRequest
-
attempting
to
stage
update
:
"
+
this
.
_update
.
name
)
;
let
stagingStarted
=
true
;
try
{
Cc
[
"
mozilla
.
org
/
updates
/
update
-
processor
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdateProcessor
)
.
processUpdate
(
)
;
}
catch
(
e
)
{
LOG
(
"
Downloader
:
onStopRequest
-
failed
to
stage
update
.
Exception
:
"
+
e
)
;
stagingStarted
=
false
;
}
if
(
stagingStarted
)
{
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_STAGING
)
;
}
else
{
shouldShowPrompt
=
true
;
}
}
}
if
(
this
.
_langPackTimeout
)
{
TelemetryStopwatch
.
start
(
"
UPDATE_LANGPACK_OVERTIME
"
unwrap
(
this
.
_update
)
{
inSeconds
:
true
}
)
;
lazy
.
setTimeout
(
this
.
_langPackTimeout
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_LANGPACK_TIMEOUT
LANGPACK_UPDATE_DEFAULT_TIMEOUT
)
)
;
}
if
(
shouldShowPrompt
)
{
let
update
=
this
.
_update
;
promiseLangPacksUpdated
(
update
)
.
then
(
(
)
=
>
{
LOG
(
"
Downloader
:
onStopRequest
-
Notifying
observers
that
"
+
"
an
update
was
downloaded
.
topic
:
update
-
downloaded
status
:
"
+
update
.
state
)
;
transitionState
(
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
downloaded
"
update
.
state
)
;
}
)
;
}
if
(
shouldRegisterOnlineObserver
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Registering
online
observer
"
)
;
this
.
updateService
.
_registerOnlineObserver
(
)
;
}
else
if
(
shouldRetrySoon
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Retrying
soon
"
)
;
this
.
updateService
.
_consecutiveSocketErrors
+
+
;
if
(
this
.
updateService
.
_retryTimer
)
{
this
.
updateService
.
_retryTimer
.
cancel
(
)
;
}
this
.
updateService
.
_retryTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
updateService
.
_retryTimer
.
initWithCallback
(
async
(
)
=
>
{
await
this
.
updateService
.
_attemptResume
(
)
;
}
retryTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
{
this
.
_update
=
null
;
}
}
cleanup
:
async
function
Downloader_cleanup
(
)
{
if
(
this
.
usingBits
)
{
if
(
this
.
_pendingRequest
)
{
await
this
.
_pendingRequest
;
}
this
.
_request
.
shutdown
(
)
;
}
}
getInterface
:
function
Downloader_getInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIAuthPrompt
)
)
{
var
prompt
=
Cc
[
"
mozilla
.
org
/
network
/
default
-
auth
-
prompt
;
1
"
]
.
createInstance
(
)
;
return
prompt
.
QueryInterface
(
iid
)
;
}
throw
Components
.
Exception
(
"
"
Cr
.
NS_NOINTERFACE
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIRequestObserver
"
"
nsIProgressEventSink
"
"
nsIInterfaceRequestor
"
]
)
}
;
class
RestartOnLastWindowClosed
{
#
enabled
=
false
;
#
hasShutdown
=
false
;
#
restartTimer
=
null
;
#
restartTimerExpired
=
false
;
constructor
(
)
{
this
.
#
maybeEnableOrDisable
(
)
;
Services
.
prefs
.
addObserver
(
PREF_APP_UPDATE_NO_WINDOW_AUTO_RESTART_ENABLED
this
)
;
Services
.
obs
.
addObserver
(
this
"
quit
-
application
"
)
;
}
shutdown
(
)
{
LOG
(
"
RestartOnLastWindowClosed
.
shutdown
-
Shutting
down
"
)
;
this
.
#
hasShutdown
=
true
;
Services
.
prefs
.
removeObserver
(
PREF_APP_UPDATE_NO_WINDOW_AUTO_RESTART_ENABLED
this
)
;
Services
.
obs
.
removeObserver
(
this
"
quit
-
application
"
)
;
this
.
#
maybeEnableOrDisable
(
)
;
}
get
shouldEnable
(
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
return
false
;
}
if
(
this
.
#
hasShutdown
)
{
return
false
;
}
return
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_NO_WINDOW_AUTO_RESTART_ENABLED
false
)
;
}
get
enabled
(
)
{
return
this
.
#
enabled
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
nsPref
:
changed
"
:
if
(
data
=
=
PREF_APP_UPDATE_NO_WINDOW_AUTO_RESTART_ENABLED
)
{
this
.
#
maybeEnableOrDisable
(
)
;
}
break
;
case
"
quit
-
application
"
:
this
.
shutdown
(
)
;
break
;
case
"
domwindowclosed
"
:
this
.
#
onWindowClose
(
)
;
break
;
case
"
domwindowopened
"
:
this
.
#
onWindowOpen
(
)
;
break
;
case
"
update
-
downloaded
"
:
case
"
update
-
staged
"
:
this
.
#
onUpdateReady
(
data
)
;
break
;
}
}
#
windowsAreOpen
(
)
{
for
(
const
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
return
true
;
}
return
false
;
}
#
maybeEnableOrDisable
(
)
{
if
(
this
.
shouldEnable
)
{
if
(
this
.
#
enabled
)
{
return
;
}
LOG
(
"
RestartOnLastWindowClosed
.
#
maybeEnableOrDisable
-
Enabling
"
)
;
Services
.
obs
.
addObserver
(
this
"
domwindowclosed
"
)
;
Services
.
obs
.
addObserver
(
this
"
domwindowopened
"
)
;
Services
.
obs
.
addObserver
(
this
"
update
-
downloaded
"
)
;
Services
.
obs
.
addObserver
(
this
"
update
-
staged
"
)
;
this
.
#
restartTimer
=
null
;
this
.
#
restartTimerExpired
=
false
;
this
.
#
enabled
=
true
;
this
.
#
onWindowClose
(
)
;
}
else
{
if
(
!
this
.
#
enabled
)
{
return
;
}
LOG
(
"
RestartOnLastWindowClosed
.
#
maybeEnableOrDisable
-
Disabling
"
)
;
Services
.
obs
.
removeObserver
(
this
"
domwindowclosed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
domwindowopened
"
)
;
Services
.
obs
.
removeObserver
(
this
"
update
-
downloaded
"
)
;
Services
.
obs
.
removeObserver
(
this
"
update
-
staged
"
)
;
this
.
#
enabled
=
false
;
if
(
this
.
#
restartTimer
)
{
this
.
#
restartTimer
.
cancel
(
)
;
}
this
.
#
restartTimer
=
null
;
}
}
#
onUpdateReady
(
updateState
)
{
if
(
[
STATE_APPLIED
STATE_PENDING
STATE_APPLIED_SERVICE
STATE_PENDING_SERVICE
]
.
includes
(
updateState
)
)
{
if
(
this
.
#
enabled
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
onUpdateReady
-
update
ready
"
)
;
this
.
#
maybeRestartBrowser
(
)
;
}
}
else
if
(
this
.
#
enabled
)
{
LOG
(
RestartOnLastWindowClosed
.
#
onUpdateReady
-
Not
counting
update
as
+
ready
because
the
state
is
{
updateState
}
)
;
}
}
#
onWindowClose
(
)
{
if
(
!
this
.
#
windowsAreOpen
(
)
)
{
this
.
#
onLastWindowClose
(
)
;
}
}
#
onLastWindowClose
(
)
{
if
(
this
.
#
restartTimer
|
|
this
.
#
restartTimerExpired
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
onLastWindowClose
-
Restart
timer
is
"
+
"
either
already
running
or
has
already
expired
"
)
;
return
;
}
let
timeout
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_NO_WINDOW_AUTO_RESTART_DELAY_MS
5
*
60
*
1000
)
;
LOG
(
"
RestartOnLastWindowClosed
.
#
onLastWindowClose
-
Last
window
closed
.
"
+
"
Starting
restart
timer
"
)
;
this
.
#
restartTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
#
restartTimer
.
initWithCallback
(
(
)
=
>
this
.
#
onRestartTimerExpire
(
)
timeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
#
onWindowOpen
(
)
{
if
(
this
.
#
restartTimer
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
onWindowOpen
-
Window
opened
.
Cancelling
"
+
"
restart
timer
.
"
)
;
this
.
#
restartTimer
.
cancel
(
)
;
}
this
.
#
restartTimer
=
null
;
this
.
#
restartTimerExpired
=
false
;
}
#
onRestartTimerExpire
(
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
onRestartTimerExpire
-
Timer
Expired
"
)
;
this
.
#
restartTimer
=
null
;
this
.
#
restartTimerExpired
=
true
;
this
.
#
maybeRestartBrowser
(
)
;
}
#
maybeRestartBrowser
(
)
{
if
(
!
this
.
#
restartTimerExpired
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
maybeRestartBrowser
-
Still
waiting
for
"
+
"
all
windows
to
be
closed
and
restartTimer
to
expire
.
"
+
"
(
not
restarting
)
"
)
;
return
;
}
if
(
lazy
.
AUS
.
currentState
!
=
Ci
.
nsIApplicationUpdateService
.
STATE_PENDING
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
maybeRestartBrowser
-
No
update
ready
.
"
+
"
(
not
restarting
)
"
)
;
return
;
}
if
(
getElevationRequired
(
)
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
maybeRestartBrowser
-
This
update
will
"
+
"
require
user
elevation
(
not
restarting
)
"
)
;
return
;
}
if
(
this
.
#
windowsAreOpen
(
)
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
maybeRestartBrowser
-
Window
"
+
"
unexpectedly
still
open
!
(
not
restarting
)
"
)
;
return
;
}
if
(
!
this
.
shouldEnable
)
{
LOG
(
"
RestartOnLastWindowClosed
.
#
maybeRestartBrowser
-
Unexpectedly
"
+
"
attempted
to
restart
when
RestartOnLastWindowClosed
ought
to
be
"
+
"
disabled
!
(
not
restarting
)
"
)
;
return
;
}
LOG
(
"
RestartOnLastWindowClosed
.
#
maybeRestartBrowser
-
Restarting
now
"
)
;
Services
.
telemetry
.
scalarAdd
(
"
update
.
no_window_auto_restarts
"
1
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
|
Ci
.
nsIAppStartup
.
eSilently
)
;
}
}
let
restartOnLastWindowClosed
=
new
RestartOnLastWindowClosed
(
)
;
var
EXPORTED_SYMBOLS
=
[
"
UpdateService
"
"
CheckerService
"
"
UpdateManager
"
]
;
