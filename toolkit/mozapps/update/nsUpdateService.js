"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AUSTLMY
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
UpdateTelemetry
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
DOMParser
"
"
XMLHttpRequest
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
CertUtils
:
"
resource
:
/
/
gre
/
modules
/
CertUtils
.
jsm
"
ctypes
:
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
DeferredTask
:
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
WindowsRegistry
:
"
resource
:
/
/
gre
/
modules
/
WindowsRegistry
.
jsm
"
}
)
;
const
UPDATESERVICE_CID
=
Components
.
ID
(
"
{
B3C290A6
-
3943
-
4B89
-
8BBE
-
C01EB7B3B311
}
"
)
;
const
PREF_APP_UPDATE_ALTWINDOWTYPE
=
"
app
.
update
.
altwindowtype
"
;
const
PREF_APP_UPDATE_BACKGROUNDERRORS
=
"
app
.
update
.
backgroundErrors
"
;
const
PREF_APP_UPDATE_BACKGROUNDMAXERRORS
=
"
app
.
update
.
backgroundMaxErrors
"
;
const
PREF_APP_UPDATE_CANCELATIONS
=
"
app
.
update
.
cancelations
"
;
const
PREF_APP_UPDATE_CANCELATIONS_OSX
=
"
app
.
update
.
cancelations
.
osx
"
;
const
PREF_APP_UPDATE_CANCELATIONS_OSX_MAX
=
"
app
.
update
.
cancelations
.
osx
.
max
"
;
const
PREF_APP_UPDATE_DOORHANGER
=
"
app
.
update
.
doorhanger
"
;
const
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
=
"
app
.
update
.
download
.
attempts
"
;
const
PREF_APP_UPDATE_DOWNLOAD_MAXATTEMPTS
=
"
app
.
update
.
download
.
maxAttempts
"
;
const
PREF_APP_UPDATE_ELEVATE_NEVER
=
"
app
.
update
.
elevate
.
never
"
;
const
PREF_APP_UPDATE_ELEVATE_VERSION
=
"
app
.
update
.
elevate
.
version
"
;
const
PREF_APP_UPDATE_ELEVATE_ATTEMPTS
=
"
app
.
update
.
elevate
.
attempts
"
;
const
PREF_APP_UPDATE_ELEVATE_MAXATTEMPTS
=
"
app
.
update
.
elevate
.
maxAttempts
"
;
const
PREF_APP_UPDATE_DISABLEDFORTESTING
=
"
app
.
update
.
disabledForTesting
"
;
const
PREF_APP_UPDATE_IDLETIME
=
"
app
.
update
.
idletime
"
;
const
PREF_APP_UPDATE_LOG
=
"
app
.
update
.
log
"
;
const
PREF_APP_UPDATE_NOTIFIEDUNSUPPORTED
=
"
app
.
update
.
notifiedUnsupported
"
;
const
PREF_APP_UPDATE_POSTUPDATE
=
"
app
.
update
.
postupdate
"
;
const
PREF_APP_UPDATE_PROMPTWAITTIME
=
"
app
.
update
.
promptWaitTime
"
;
const
PREF_APP_UPDATE_SERVICE_ENABLED
=
"
app
.
update
.
service
.
enabled
"
;
const
PREF_APP_UPDATE_SERVICE_ERRORS
=
"
app
.
update
.
service
.
errors
"
;
const
PREF_APP_UPDATE_SERVICE_MAXERRORS
=
"
app
.
update
.
service
.
maxErrors
"
;
const
PREF_APP_UPDATE_SILENT
=
"
app
.
update
.
silent
"
;
const
PREF_APP_UPDATE_SOCKET_MAXERRORS
=
"
app
.
update
.
socket
.
maxErrors
"
;
const
PREF_APP_UPDATE_SOCKET_RETRYTIMEOUT
=
"
app
.
update
.
socket
.
retryTimeout
"
;
const
PREF_APP_UPDATE_STAGING_ENABLED
=
"
app
.
update
.
staging
.
enabled
"
;
const
PREF_APP_UPDATE_URL
=
"
app
.
update
.
url
"
;
const
PREF_APP_UPDATE_URL_DETAILS
=
"
app
.
update
.
url
.
details
"
;
const
URI_BRAND_PROPERTIES
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
URI_UPDATE_HISTORY_DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
update
/
history
.
xul
"
;
const
URI_UPDATE_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
2005
/
app
-
update
"
;
const
URI_UPDATE_PROMPT_DIALOG
=
"
chrome
:
/
/
mozapps
/
content
/
update
/
updates
.
xul
"
;
const
URI_UPDATES_PROPERTIES
=
"
chrome
:
/
/
mozapps
/
locale
/
update
/
updates
.
properties
"
;
const
KEY_UPDROOT
=
"
UpdRootD
"
;
const
KEY_EXECUTABLE
=
"
XREExeF
"
;
const
DIR_UPDATES
=
"
updates
"
;
const
FILE_ACTIVE_UPDATE_XML
=
"
active
-
update
.
xml
"
;
const
FILE_BACKUP_UPDATE_LOG
=
"
backup
-
update
.
log
"
;
const
FILE_BT_RESULT
=
"
bt
.
result
"
;
const
FILE_LAST_UPDATE_LOG
=
"
last
-
update
.
log
"
;
const
FILE_UPDATES_XML
=
"
updates
.
xml
"
;
const
FILE_UPDATE_LOG
=
"
update
.
log
"
;
const
FILE_UPDATE_MAR
=
"
update
.
mar
"
;
const
FILE_UPDATE_STATUS
=
"
update
.
status
"
;
const
FILE_UPDATE_TEST
=
"
update
.
test
"
;
const
FILE_UPDATE_VERSION
=
"
update
.
version
"
;
const
STATE_NONE
=
"
null
"
;
const
STATE_DOWNLOADING
=
"
downloading
"
;
const
STATE_PENDING
=
"
pending
"
;
const
STATE_PENDING_SERVICE
=
"
pending
-
service
"
;
const
STATE_PENDING_ELEVATE
=
"
pending
-
elevate
"
;
const
STATE_APPLYING
=
"
applying
"
;
const
STATE_APPLIED
=
"
applied
"
;
const
STATE_APPLIED_SERVICE
=
"
applied
-
service
"
;
const
STATE_SUCCEEDED
=
"
succeeded
"
;
const
STATE_DOWNLOAD_FAILED
=
"
download
-
failed
"
;
const
STATE_FAILED
=
"
failed
"
;
const
WRITE_ERROR
=
7
;
const
ELEVATION_CANCELED
=
9
;
const
SERVICE_UPDATER_COULD_NOT_BE_STARTED
=
24
;
const
SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS
=
25
;
const
SERVICE_UPDATER_SIGN_ERROR
=
26
;
const
SERVICE_UPDATER_COMPARE_ERROR
=
27
;
const
SERVICE_UPDATER_IDENTITY_ERROR
=
28
;
const
SERVICE_STILL_APPLYING_ON_SUCCESS
=
29
;
const
SERVICE_STILL_APPLYING_ON_FAILURE
=
30
;
const
SERVICE_UPDATER_NOT_FIXED_DRIVE
=
31
;
const
SERVICE_COULD_NOT_LOCK_UPDATER
=
32
;
const
SERVICE_INSTALLDIR_ERROR
=
33
;
const
WRITE_ERROR_ACCESS_DENIED
=
35
;
const
WRITE_ERROR_CALLBACK_APP
=
37
;
const
SERVICE_COULD_NOT_COPY_UPDATER
=
49
;
const
SERVICE_STILL_APPLYING_TERMINATED
=
50
;
const
SERVICE_STILL_APPLYING_NO_EXIT_CODE
=
51
;
const
SERVICE_COULD_NOT_IMPERSONATE
=
58
;
const
WRITE_ERROR_FILE_COPY
=
61
;
const
WRITE_ERROR_DELETE_FILE
=
62
;
const
WRITE_ERROR_OPEN_PATCH_FILE
=
63
;
const
WRITE_ERROR_PATCH_FILE
=
64
;
const
WRITE_ERROR_APPLY_DIR_PATH
=
65
;
const
WRITE_ERROR_CALLBACK_PATH
=
66
;
const
WRITE_ERROR_FILE_ACCESS_DENIED
=
67
;
const
WRITE_ERROR_DIR_ACCESS_DENIED
=
68
;
const
WRITE_ERROR_DELETE_BACKUP
=
69
;
const
WRITE_ERROR_EXTRACT
=
70
;
const
WRITE_ERRORS
=
[
WRITE_ERROR
WRITE_ERROR_ACCESS_DENIED
WRITE_ERROR_CALLBACK_APP
WRITE_ERROR_FILE_COPY
WRITE_ERROR_DELETE_FILE
WRITE_ERROR_OPEN_PATCH_FILE
WRITE_ERROR_PATCH_FILE
WRITE_ERROR_APPLY_DIR_PATH
WRITE_ERROR_CALLBACK_PATH
WRITE_ERROR_FILE_ACCESS_DENIED
WRITE_ERROR_DIR_ACCESS_DENIED
WRITE_ERROR_DELETE_BACKUP
WRITE_ERROR_EXTRACT
]
;
const
SERVICE_ERRORS
=
[
SERVICE_UPDATER_COULD_NOT_BE_STARTED
SERVICE_NOT_ENOUGH_COMMAND_LINE_ARGS
SERVICE_UPDATER_SIGN_ERROR
SERVICE_UPDATER_COMPARE_ERROR
SERVICE_UPDATER_IDENTITY_ERROR
SERVICE_STILL_APPLYING_ON_SUCCESS
SERVICE_STILL_APPLYING_ON_FAILURE
SERVICE_UPDATER_NOT_FIXED_DRIVE
SERVICE_COULD_NOT_LOCK_UPDATER
SERVICE_INSTALLDIR_ERROR
SERVICE_COULD_NOT_COPY_UPDATER
SERVICE_STILL_APPLYING_TERMINATED
SERVICE_STILL_APPLYING_NO_EXIT_CODE
SERVICE_COULD_NOT_IMPERSONATE
]
;
const
ERR_OLDER_VERSION_OR_SAME_BUILD
=
90
;
const
ERR_UPDATE_STATE_NONE
=
91
;
const
ERR_CHANNEL_CHANGE
=
92
;
const
INVALID_UPDATER_STATE_CODE
=
98
;
const
INVALID_UPDATER_STATUS_CODE
=
99
;
const
BACKGROUNDCHECK_MULTIPLE_FAILURES
=
110
;
const
NETWORK_ERROR_OFFLINE
=
111
;
const
HTTP_ERROR_OFFSET
=
1000
;
const
DOWNLOAD_CHUNK_SIZE
=
300000
;
const
UPDATE_WINDOW_NAME
=
"
Update
:
Wizard
"
;
const
DEFAULT_SERVICE_MAX_ERRORS
=
10
;
const
DEFAULT_SOCKET_MAX_ERRORS
=
10
;
const
DEFAULT_SOCKET_RETRYTIMEOUT
=
2000
;
const
DEFAULT_CANCELATIONS_OSX_MAX
=
3
;
const
APPID_TO_TOPIC
=
{
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
:
"
sessionstore
-
windows
-
restored
"
"
{
92650c4d
-
4b8e
-
4d2a
-
b7eb
-
24ecf4f6b63a
}
"
:
"
sessionstore
-
windows
-
restored
"
"
{
3550f703
-
e582
-
4d05
-
9a08
-
453d09bdfdc6
}
"
:
"
mail
-
startup
-
done
"
}
;
const
XML_SAVER_INTERVAL_MS
=
200
;
var
gUpdateFileWriteInfo
=
{
phase
:
null
failure
:
false
}
;
var
gUpdateMutexHandle
=
null
;
var
gUpdateDirPermissionFixAttempted
=
false
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gLogEnabled
"
function
aus_gLogEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gUpdateBundle
"
function
aus_gUpdateBundle
(
)
{
return
Services
.
strings
.
createBundle
(
URI_UPDATES_PROPERTIES
)
;
}
)
;
function
testWriteAccess
(
updateTestFile
createDirectory
)
{
const
NORMAL_FILE_TYPE
=
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
;
const
DIRECTORY_TYPE
=
Ci
.
nsIFile
.
DIRECTORY_TYPE
;
if
(
updateTestFile
.
exists
(
)
)
updateTestFile
.
remove
(
false
)
;
updateTestFile
.
create
(
createDirectory
?
DIRECTORY_TYPE
:
NORMAL_FILE_TYPE
createDirectory
?
FileUtils
.
PERMS_DIRECTORY
:
FileUtils
.
PERMS_FILE
)
;
updateTestFile
.
remove
(
false
)
;
}
function
closeHandle
(
handle
)
{
let
lib
=
ctypes
.
open
(
"
kernel32
.
dll
"
)
;
let
CloseHandle
=
lib
.
declare
(
"
CloseHandle
"
ctypes
.
winapi_abi
ctypes
.
int32_t
ctypes
.
void_t
.
ptr
)
;
CloseHandle
(
handle
)
;
lib
.
close
(
)
;
}
function
createMutex
(
aName
aAllowExisting
=
true
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
const
INITIAL_OWN
=
1
;
const
ERROR_ALREADY_EXISTS
=
0xB7
;
let
lib
=
ctypes
.
open
(
"
kernel32
.
dll
"
)
;
let
CreateMutexW
=
lib
.
declare
(
"
CreateMutexW
"
ctypes
.
winapi_abi
ctypes
.
void_t
.
ptr
ctypes
.
void_t
.
ptr
ctypes
.
int32_t
ctypes
.
char16_t
.
ptr
)
;
let
handle
=
CreateMutexW
(
null
INITIAL_OWN
aName
)
;
let
alreadyExists
=
ctypes
.
winLastError
=
=
ERROR_ALREADY_EXISTS
;
if
(
handle
&
&
!
handle
.
isNull
(
)
&
&
!
aAllowExisting
&
&
alreadyExists
)
{
closeHandle
(
handle
)
;
handle
=
null
;
}
lib
.
close
(
)
;
if
(
handle
&
&
handle
.
isNull
(
)
)
{
handle
=
null
;
}
return
handle
;
}
function
getPerInstallationMutexName
(
aGlobal
=
true
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA1
)
;
let
exeFile
=
Services
.
dirsvc
.
get
(
KEY_EXECUTABLE
Ci
.
nsIFile
)
;
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
var
data
=
converter
.
convertToByteArray
(
exeFile
.
path
.
toLowerCase
(
)
)
;
hasher
.
update
(
data
data
.
length
)
;
return
(
aGlobal
?
"
Global
\
\
"
:
"
"
)
+
"
MozillaUpdateMutex
-
"
+
hasher
.
finish
(
true
)
;
}
function
hasUpdateMutex
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
return
true
;
}
if
(
!
gUpdateMutexHandle
)
{
gUpdateMutexHandle
=
createMutex
(
getPerInstallationMutexName
(
true
)
false
)
;
}
return
!
!
gUpdateMutexHandle
;
}
function
areDirectoryEntriesWriteable
(
aDir
)
{
let
items
=
aDir
.
directoryEntries
;
while
(
items
.
hasMoreElements
(
)
)
{
let
item
=
items
.
nextFile
;
if
(
!
item
.
isWritable
(
)
)
{
LOG
(
"
areDirectoryEntriesWriteable
-
unable
to
write
to
"
+
item
.
path
)
;
return
false
;
}
if
(
item
.
isDirectory
(
)
&
&
!
areDirectoryEntriesWriteable
(
item
)
)
{
return
false
;
}
}
return
true
;
}
function
getElevationRequired
(
)
{
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
return
false
;
}
try
{
LOG
(
"
getElevationRequired
-
recursively
testing
write
access
on
"
+
getInstallDirRoot
(
)
.
path
)
;
if
(
!
getInstallDirRoot
(
)
.
isWritable
(
)
|
|
!
areDirectoryEntriesWriteable
(
getInstallDirRoot
(
)
)
)
{
LOG
(
"
getElevationRequired
-
unable
to
write
to
application
bundle
"
+
"
elevation
required
"
)
;
return
true
;
}
}
catch
(
ex
)
{
LOG
(
"
getElevationRequired
-
unable
to
write
to
application
bundle
"
+
"
elevation
required
.
Exception
:
"
+
ex
)
;
return
true
;
}
LOG
(
"
getElevationRequired
-
able
to
write
to
application
bundle
elevation
"
+
"
not
required
"
)
;
return
false
;
}
function
getCanApplyUpdates
(
)
{
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
LOG
(
"
getCanApplyUpdates
-
bypass
the
write
since
elevation
can
be
used
"
+
"
on
Mac
OS
X
"
)
;
return
true
;
}
if
(
shouldUseService
(
)
)
{
LOG
(
"
getCanApplyUpdates
-
bypass
the
write
checks
because
the
Windows
"
+
"
Maintenance
Service
can
be
used
"
)
;
return
true
;
}
try
{
let
updateTestFile
=
getUpdateFile
(
[
FILE_UPDATE_TEST
]
)
;
LOG
(
"
getCanApplyUpdates
-
testing
write
access
"
+
updateTestFile
.
path
)
;
testWriteAccess
(
updateTestFile
false
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
let
userCanElevate
=
Services
.
appinfo
.
QueryInterface
(
Ci
.
nsIWinAppHelper
)
.
userCanElevate
;
if
(
!
userCanElevate
)
{
let
appDirTestFile
=
getAppBaseDir
(
)
;
appDirTestFile
.
append
(
FILE_UPDATE_TEST
)
;
LOG
(
"
getCanApplyUpdates
-
testing
write
access
"
+
appDirTestFile
.
path
)
;
if
(
appDirTestFile
.
exists
(
)
)
{
appDirTestFile
.
remove
(
false
)
;
}
appDirTestFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
appDirTestFile
.
remove
(
false
)
;
}
}
}
catch
(
e
)
{
LOG
(
"
getCanApplyUpdates
-
unable
to
apply
updates
.
Exception
:
"
+
e
)
;
return
false
;
}
LOG
(
"
getCanApplyUpdates
-
able
to
apply
updates
"
)
;
return
true
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gCanStageUpdatesSession
"
function
aus_gCSUS
(
)
{
if
(
getElevationRequired
(
)
)
{
LOG
(
"
gCanStageUpdatesSession
-
unable
to
stage
updates
because
elevation
"
+
"
is
required
.
"
)
;
return
false
;
}
try
{
let
updateTestFile
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
updateTestFile
=
getUpdateFile
(
[
FILE_UPDATE_TEST
]
)
;
}
else
{
updateTestFile
=
getInstallDirRoot
(
)
;
updateTestFile
.
append
(
FILE_UPDATE_TEST
)
;
}
LOG
(
"
gCanStageUpdatesSession
-
testing
write
access
"
+
updateTestFile
.
path
)
;
testWriteAccess
(
updateTestFile
true
)
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
updateTestFile
=
getInstallDirRoot
(
)
.
parent
;
updateTestFile
.
append
(
FILE_UPDATE_TEST
)
;
LOG
(
"
gCanStageUpdatesSession
-
testing
write
access
"
+
updateTestFile
.
path
)
;
updateTestFile
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
FileUtils
.
PERMS_DIRECTORY
)
;
updateTestFile
.
remove
(
false
)
;
}
}
catch
(
e
)
{
LOG
(
"
gCanStageUpdatesSession
-
unable
to
stage
updates
.
Exception
:
"
+
e
)
;
return
false
;
}
LOG
(
"
gCanStageUpdatesSession
-
able
to
stage
updates
"
)
;
return
true
;
}
)
;
function
getCanStageUpdates
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_STAGING_ENABLED
false
)
)
{
LOG
(
"
getCanStageUpdates
-
staging
updates
is
disabled
by
preference
"
+
PREF_APP_UPDATE_STAGING_ENABLED
)
;
return
false
;
}
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
shouldUseService
(
)
)
{
LOG
(
"
getCanStageUpdates
-
able
to
stage
updates
using
the
service
"
)
;
return
true
;
}
if
(
!
hasUpdateMutex
(
)
)
{
LOG
(
"
getCanStageUpdates
-
unable
to
apply
updates
because
another
"
+
"
instance
of
the
application
is
already
handling
updates
for
this
"
+
"
installation
.
"
)
;
return
false
;
}
return
gCanStageUpdatesSession
;
}
function
LOG
(
string
)
{
if
(
gLogEnabled
)
{
dump
(
"
*
*
*
AUS
:
SVC
"
+
string
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
"
AUS
:
SVC
"
+
string
)
;
}
}
function
getUpdateDirCreate
(
pathArray
)
{
return
FileUtils
.
getDir
(
KEY_UPDROOT
pathArray
true
)
;
}
function
getAppBaseDir
(
)
{
return
Services
.
dirsvc
.
get
(
KEY_EXECUTABLE
Ci
.
nsIFile
)
.
parent
;
}
function
getInstallDirRoot
(
)
{
let
dir
=
getAppBaseDir
(
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
dir
=
dir
.
parent
.
parent
;
}
return
dir
;
}
function
getUpdateFile
(
pathArray
)
{
let
file
=
getUpdateDirCreate
(
pathArray
.
slice
(
0
-
1
)
)
;
file
.
append
(
pathArray
[
pathArray
.
length
-
1
]
)
;
return
file
;
}
function
getStatusTextFromCode
(
code
defaultCode
)
{
let
reason
;
try
{
reason
=
gUpdateBundle
.
GetStringFromName
(
"
check_error
-
"
+
code
)
;
LOG
(
"
getStatusTextFromCode
-
transfer
error
:
"
+
reason
+
"
code
:
"
+
code
)
;
}
catch
(
e
)
{
reason
=
gUpdateBundle
.
GetStringFromName
(
"
check_error
-
"
+
defaultCode
)
;
LOG
(
"
getStatusTextFromCode
-
transfer
error
:
"
+
reason
+
"
default
code
:
"
+
defaultCode
)
;
}
return
reason
;
}
function
getUpdatesDir
(
)
{
return
getUpdateDirCreate
(
[
DIR_UPDATES
"
0
"
]
)
;
}
function
readStatusFile
(
dir
)
{
let
statusFile
=
dir
.
clone
(
)
;
statusFile
.
append
(
FILE_UPDATE_STATUS
)
;
let
status
=
readStringFromFile
(
statusFile
)
|
|
STATE_NONE
;
LOG
(
"
readStatusFile
-
status
:
"
+
status
+
"
path
:
"
+
statusFile
.
path
)
;
return
status
;
}
function
readBinaryTransparencyResult
(
dir
)
{
let
binaryTransparencyResultFile
=
dir
.
clone
(
)
;
binaryTransparencyResultFile
.
append
(
FILE_BT_RESULT
)
;
let
result
=
readStringFromFile
(
binaryTransparencyResultFile
)
;
LOG
(
"
readBinaryTransparencyResult
-
result
:
"
+
result
+
"
path
:
"
+
binaryTransparencyResultFile
.
path
)
;
if
(
result
)
{
binaryTransparencyResultFile
.
remove
(
false
)
;
}
return
result
;
}
function
writeStatusFile
(
dir
state
)
{
let
statusFile
=
dir
.
clone
(
)
;
statusFile
.
append
(
FILE_UPDATE_STATUS
)
;
let
success
=
writeStringToFile
(
statusFile
state
)
;
if
(
!
success
)
{
handleCriticalWriteFailure
(
statusFile
.
path
)
;
}
}
function
writeVersionFile
(
dir
version
)
{
let
versionFile
=
dir
.
clone
(
)
;
versionFile
.
append
(
FILE_UPDATE_VERSION
)
;
let
success
=
writeStringToFile
(
versionFile
version
)
;
if
(
!
success
)
{
handleCriticalWriteFailure
(
versionFile
.
path
)
;
}
}
function
shouldUseService
(
)
{
if
(
!
AppConstants
.
MOZ_MAINTENANCE_SERVICE
|
|
!
isServiceInstalled
(
)
|
|
!
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
false
)
)
{
LOG
(
"
shouldUseService
-
returning
false
"
)
;
return
false
;
}
LOG
(
"
shouldUseService
-
returning
true
"
)
;
return
true
;
}
function
isServiceInstalled
(
)
{
if
(
!
AppConstants
.
MOZ_MAINTENANCE_SERVICE
|
|
AppConstants
.
platform
!
=
"
win
"
)
{
LOG
(
"
isServiceInstalled
-
returning
false
"
)
;
return
false
;
}
let
installed
=
0
;
try
{
let
wrk
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
wrk
.
open
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
"
SOFTWARE
\
\
Mozilla
\
\
MaintenanceService
"
wrk
.
ACCESS_READ
|
wrk
.
WOW64_64
)
;
installed
=
wrk
.
readIntValue
(
"
Installed
"
)
;
wrk
.
close
(
)
;
}
catch
(
e
)
{
}
installed
=
installed
=
=
1
;
LOG
(
"
isServiceInstalled
-
returning
"
+
installed
)
;
return
installed
;
}
function
cleanUpUpdatesDir
(
aRemovePatchFiles
=
true
)
{
let
updateDir
;
try
{
updateDir
=
getUpdatesDir
(
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpUpdatesDir
-
unable
to
get
the
updates
patch
directory
.
"
+
"
Exception
:
"
+
e
)
;
return
;
}
let
updateLogFile
=
updateDir
.
clone
(
)
;
updateLogFile
.
append
(
FILE_UPDATE_LOG
)
;
if
(
updateLogFile
.
exists
(
)
)
{
let
dir
=
updateDir
.
parent
;
let
logFile
=
dir
.
clone
(
)
;
logFile
.
append
(
FILE_LAST_UPDATE_LOG
)
;
if
(
logFile
.
exists
(
)
)
{
try
{
logFile
.
moveTo
(
dir
FILE_BACKUP_UPDATE_LOG
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpUpdatesDir
-
failed
to
rename
file
"
+
logFile
.
path
+
"
to
"
+
FILE_BACKUP_UPDATE_LOG
)
;
}
}
try
{
updateLogFile
.
moveTo
(
dir
FILE_LAST_UPDATE_LOG
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpUpdatesDir
-
failed
to
rename
file
"
+
updateLogFile
.
path
+
"
to
"
+
FILE_LAST_UPDATE_LOG
)
;
}
}
if
(
aRemovePatchFiles
)
{
let
dirEntries
=
updateDir
.
directoryEntries
;
while
(
dirEntries
.
hasMoreElements
(
)
)
{
let
file
=
dirEntries
.
nextFile
;
try
{
file
.
remove
(
true
)
;
}
catch
(
e
)
{
LOG
(
"
cleanUpUpdatesDir
-
failed
to
remove
file
"
+
file
.
path
)
;
}
}
}
}
function
cleanupActiveUpdate
(
)
{
var
um
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
;
um
.
activeUpdate
=
null
;
um
.
saveUpdates
(
)
;
cleanUpUpdatesDir
(
)
;
}
function
writeStringToFile
(
file
text
)
{
try
{
let
fos
=
FileUtils
.
openSafeFileOutputStream
(
file
)
;
text
+
=
"
\
n
"
;
fos
.
write
(
text
text
.
length
)
;
FileUtils
.
closeSafeFileOutputStream
(
fos
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
function
readStringFromInputStream
(
inputStream
)
{
var
sis
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableInputStream
)
;
sis
.
init
(
inputStream
)
;
var
text
=
sis
.
read
(
sis
.
available
(
)
)
;
sis
.
close
(
)
;
if
(
text
&
&
text
[
text
.
length
-
1
]
=
=
"
\
n
"
)
{
text
=
text
.
slice
(
0
-
1
)
;
}
return
text
;
}
function
readStringFromFile
(
file
)
{
if
(
!
file
.
exists
(
)
)
{
LOG
(
"
readStringFromFile
-
file
doesn
'
t
exist
:
"
+
file
.
path
)
;
return
null
;
}
var
fis
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fis
.
init
(
file
FileUtils
.
MODE_RDONLY
FileUtils
.
PERMS_FILE
0
)
;
return
readStringFromInputStream
(
fis
)
;
}
function
handleUpdateFailure
(
update
errorCode
)
{
update
.
errorCode
=
parseInt
(
errorCode
)
;
if
(
WRITE_ERRORS
.
includes
(
update
.
errorCode
)
)
{
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
.
showUpdateError
(
update
)
;
writeStatusFile
(
getUpdatesDir
(
)
update
.
state
=
STATE_PENDING
)
;
return
true
;
}
if
(
update
.
errorCode
=
=
ELEVATION_CANCELED
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_DOORHANGER
false
)
)
{
let
elevationAttempts
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_ELEVATE_ATTEMPTS
0
)
;
elevationAttempts
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_ELEVATE_ATTEMPTS
elevationAttempts
)
;
let
maxAttempts
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_ELEVATE_MAXATTEMPTS
2
)
10
)
;
if
(
elevationAttempts
>
maxAttempts
)
{
LOG
(
"
handleUpdateFailure
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
elevation
-
attempts
-
exceeded
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
elevation
-
attempts
-
exceeded
"
)
;
}
else
{
LOG
(
"
handleUpdateFailure
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
elevation
-
attempt
-
failed
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
elevation
-
attempt
-
failed
"
)
;
}
}
let
cancelations
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS
0
)
;
cancelations
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_CANCELATIONS
cancelations
)
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
let
osxCancelations
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
0
)
;
osxCancelations
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
osxCancelations
)
;
let
maxCancels
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX_MAX
DEFAULT_CANCELATIONS_OSX_MAX
)
;
maxCancels
=
Math
.
min
(
maxCancels
5
)
;
if
(
osxCancelations
>
=
maxCancels
)
{
cleanupActiveUpdate
(
)
;
}
else
{
writeStatusFile
(
getUpdatesDir
(
)
update
.
state
=
STATE_PENDING_ELEVATE
)
;
}
update
.
statusText
=
gUpdateBundle
.
GetStringFromName
(
"
elevationFailure
"
)
;
update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
update
.
setProperty
(
"
patchingFailed
"
"
elevationFailure
"
)
;
let
prompter
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
;
prompter
.
showUpdateError
(
update
)
;
}
else
{
writeStatusFile
(
getUpdatesDir
(
)
update
.
state
=
STATE_PENDING
)
;
}
return
true
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
SERVICE_ERRORS
.
includes
(
update
.
errorCode
)
)
{
var
failCount
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_SERVICE_ERRORS
0
)
;
var
maxFail
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_SERVICE_MAXERRORS
DEFAULT_SERVICE_MAX_ERRORS
)
;
maxFail
=
Math
.
min
(
maxFail
10
)
;
if
(
failCount
>
=
maxFail
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SERVICE_ENABLED
false
)
;
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_SERVICE_ERRORS
)
;
}
else
{
failCount
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_SERVICE_ERRORS
failCount
)
;
}
writeStatusFile
(
getUpdatesDir
(
)
update
.
state
=
STATE_PENDING
)
;
return
true
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_SERVICE_ERRORS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_SERVICE_ERRORS
)
;
}
return
false
;
}
function
handleFallbackToCompleteUpdate
(
update
postStaging
)
{
cleanupActiveUpdate
(
)
;
update
.
statusText
=
gUpdateBundle
.
GetStringFromName
(
"
patchApplyFailure
"
)
;
var
oldType
=
update
.
selectedPatch
?
update
.
selectedPatch
.
type
:
"
complete
"
;
if
(
update
.
selectedPatch
&
&
oldType
=
=
"
partial
"
&
&
update
.
patchCount
=
=
2
)
{
LOG
(
"
handleFallbackToCompleteUpdate
-
install
of
partial
patch
"
+
"
failed
downloading
complete
patch
"
)
;
var
status
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationUpdateService
)
.
downloadUpdate
(
update
!
postStaging
)
;
if
(
status
=
=
STATE_NONE
)
cleanupActiveUpdate
(
)
;
}
else
{
LOG
(
"
handleFallbackToCompleteUpdate
-
install
of
complete
or
"
+
"
only
one
patch
offered
failed
.
Notifying
observers
.
topic
:
"
+
"
update
-
error
status
:
unknown
"
+
"
update
.
patchCount
:
"
+
update
.
patchCount
+
"
"
+
"
oldType
:
"
+
oldType
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
unknown
"
)
;
}
update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
update
.
setProperty
(
"
patchingFailed
"
oldType
)
;
}
function
pingStateAndStatusCodes
(
aUpdate
aStartup
aStatus
)
{
let
patchType
=
AUSTLMY
.
PATCH_UNKNOWN
;
if
(
aUpdate
&
&
aUpdate
.
selectedPatch
&
&
aUpdate
.
selectedPatch
.
type
)
{
if
(
aUpdate
.
selectedPatch
.
type
=
=
"
complete
"
)
{
patchType
=
AUSTLMY
.
PATCH_COMPLETE
;
}
else
if
(
aUpdate
.
selectedPatch
.
type
=
=
"
partial
"
)
{
patchType
=
AUSTLMY
.
PATCH_PARTIAL
;
}
}
let
suffix
=
patchType
+
"
_
"
+
(
aStartup
?
AUSTLMY
.
STARTUP
:
AUSTLMY
.
STAGE
)
;
let
stateCode
=
0
;
let
parts
=
aStatus
.
split
(
"
:
"
)
;
if
(
parts
.
length
>
0
)
{
switch
(
parts
[
0
]
)
{
case
STATE_NONE
:
stateCode
=
2
;
break
;
case
STATE_DOWNLOADING
:
stateCode
=
3
;
break
;
case
STATE_PENDING
:
stateCode
=
4
;
break
;
case
STATE_PENDING_SERVICE
:
stateCode
=
5
;
break
;
case
STATE_APPLYING
:
stateCode
=
6
;
break
;
case
STATE_APPLIED
:
stateCode
=
7
;
break
;
case
STATE_APPLIED_SERVICE
:
stateCode
=
9
;
break
;
case
STATE_SUCCEEDED
:
stateCode
=
10
;
break
;
case
STATE_DOWNLOAD_FAILED
:
stateCode
=
11
;
break
;
case
STATE_FAILED
:
stateCode
=
12
;
break
;
case
STATE_PENDING_ELEVATE
:
stateCode
=
13
;
break
;
default
:
stateCode
=
1
;
}
if
(
parts
.
length
>
1
)
{
let
statusErrorCode
=
INVALID_UPDATER_STATE_CODE
;
if
(
parts
[
0
]
=
=
STATE_FAILED
)
{
statusErrorCode
=
parseInt
(
parts
[
1
]
)
|
|
INVALID_UPDATER_STATUS_CODE
;
}
AUSTLMY
.
pingStatusErrorCode
(
suffix
statusErrorCode
)
;
}
}
let
binaryTransparencyResult
=
readBinaryTransparencyResult
(
getUpdatesDir
(
)
)
;
if
(
binaryTransparencyResult
)
{
AUSTLMY
.
pingBinaryTransparencyResult
(
suffix
parseInt
(
binaryTransparencyResult
)
)
;
}
AUSTLMY
.
pingStateCode
(
suffix
stateCode
)
;
}
function
handleCriticalWriteFailure
(
path
)
{
LOG
(
"
handleCriticalWriteFailure
-
Unable
to
write
to
critical
update
file
:
"
+
path
)
;
if
(
!
gUpdateFileWriteInfo
.
failure
)
{
gUpdateFileWriteInfo
.
failure
=
true
;
let
patchType
=
AUSTLMY
.
PATCH_UNKNOWN
;
let
update
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
.
activeUpdate
;
if
(
update
)
{
let
patch
=
update
.
selectedPatch
;
if
(
patch
.
type
=
=
"
complete
"
)
{
patchType
=
AUSTLMY
.
PATCH_COMPLETE
;
}
else
if
(
patch
.
type
=
=
"
partial
"
)
{
patchType
=
AUSTLMY
.
PATCH_PARTIAL
;
}
}
if
(
gUpdateFileWriteInfo
.
phase
=
=
"
check
"
)
{
let
updateServiceInstance
=
UpdateServiceFactory
.
createInstance
(
)
;
let
pingSuffix
=
updateServiceInstance
.
_pingSuffix
;
if
(
!
pingSuffix
)
{
AUSTLMY
.
pingCheckCode
(
pingSuffix
AUSTLMY
.
CHK_ERR_WRITE_FAILURE
)
;
}
}
else
if
(
gUpdateFileWriteInfo
.
phase
=
=
"
download
"
)
{
AUSTLMY
.
pingDownloadCode
(
patchType
AUSTLMY
.
DWNLD_ERR_WRITE_FAILURE
)
;
}
else
if
(
gUpdateFileWriteInfo
.
phase
=
=
"
stage
"
)
{
let
suffix
=
patchType
+
"
_
"
+
AUSTLMY
.
STAGE
;
AUSTLMY
.
pingStateCode
(
suffix
AUSTLMY
.
STATE_WRITE_FAILURE
)
;
}
else
if
(
gUpdateFileWriteInfo
.
phase
=
=
"
startup
"
)
{
let
suffix
=
patchType
+
"
_
"
+
AUSTLMY
.
STARTUP
;
AUSTLMY
.
pingStateCode
(
suffix
AUSTLMY
.
STATE_WRITE_FAILURE
)
;
}
else
{
AUSTLMY
.
pingDownloadCode
(
patchType
AUSTLMY
.
DWNLD_UNKNOWN_PHASE_ERR_WRITE_FAILURE
)
;
}
}
if
(
!
gUpdateDirPermissionFixAttempted
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
LOG
(
"
There
is
currently
no
implementation
for
fixing
update
directory
"
+
"
permissions
on
this
platform
"
)
;
return
false
;
}
LOG
(
"
Attempting
to
fix
update
directory
permissions
"
)
;
try
{
Cc
[
"
mozilla
.
org
/
updates
/
update
-
processor
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdateProcessor
)
.
fixUpdateDirectoryPerms
(
shouldUseService
(
)
)
;
}
catch
(
e
)
{
LOG
(
"
Attempt
to
fix
update
directory
permissions
failed
.
Exception
:
"
+
e
)
;
return
false
;
}
gUpdateDirPermissionFixAttempted
=
true
;
return
true
;
}
return
false
;
}
function
handleCriticalWriteResult
(
wroteSuccessfully
path
)
{
if
(
!
wroteSuccessfully
)
{
handleCriticalWriteFailure
(
path
)
;
}
}
function
UpdatePatch
(
patch
)
{
this
.
_properties
=
{
}
;
this
.
errorCode
=
0
;
this
.
finalURL
=
null
;
this
.
state
=
STATE_NONE
;
for
(
let
i
=
0
;
i
<
patch
.
attributes
.
length
;
+
+
i
)
{
var
attr
=
patch
.
attributes
.
item
(
i
)
;
if
(
attr
.
value
=
=
"
undefined
"
)
{
continue
;
}
switch
(
attr
.
name
)
{
case
"
xmlns
"
:
break
;
case
"
selected
"
:
this
.
selected
=
attr
.
value
=
=
"
true
"
;
break
;
case
"
size
"
:
if
(
0
=
=
parseInt
(
attr
.
value
)
)
{
LOG
(
"
UpdatePatch
:
init
-
0
-
sized
patch
!
"
)
;
throw
Cr
.
NS_ERROR_ILLEGAL_VALUE
;
}
this
[
attr
.
name
]
=
attr
.
value
;
break
;
case
"
errorCode
"
:
if
(
attr
.
value
)
{
let
val
=
parseInt
(
attr
.
value
)
;
if
(
val
)
{
this
.
errorCode
=
val
;
}
}
break
;
case
"
finalURL
"
:
case
"
state
"
:
case
"
type
"
:
case
"
URL
"
:
this
[
attr
.
name
]
=
attr
.
value
;
break
;
default
:
if
(
!
this
.
_attrNames
.
includes
(
attr
.
name
)
)
{
this
.
setProperty
(
attr
.
name
attr
.
value
)
;
}
break
;
}
}
}
UpdatePatch
.
prototype
=
{
_attrNames
:
[
"
errorCode
"
"
finalURL
"
"
selected
"
"
size
"
"
state
"
"
type
"
"
URL
"
]
serialize
:
function
UpdatePatch_serialize
(
updates
)
{
var
patch
=
updates
.
createElementNS
(
URI_UPDATE_NS
"
patch
"
)
;
patch
.
setAttribute
(
"
size
"
this
.
size
)
;
patch
.
setAttribute
(
"
type
"
this
.
type
)
;
patch
.
setAttribute
(
"
URL
"
this
.
URL
)
;
if
(
this
.
errorCode
)
{
patch
.
setAttribute
(
"
errorCode
"
this
.
errorCode
)
;
}
if
(
this
.
finalURL
)
{
patch
.
setAttribute
(
"
finalURL
"
this
.
finalURL
)
;
}
if
(
this
.
selected
)
{
patch
.
setAttribute
(
"
selected
"
this
.
selected
)
;
}
if
(
this
.
state
!
=
STATE_NONE
)
{
patch
.
setAttribute
(
"
state
"
this
.
state
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
_properties
)
)
{
if
(
value
.
present
&
&
!
this
.
_attrNames
.
includes
(
name
)
)
{
patch
.
setAttribute
(
name
value
.
data
)
;
}
}
return
patch
;
}
setProperty
:
function
UpdatePatch_setProperty
(
name
value
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdatePatch
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
setProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
this
.
_properties
[
name
]
=
{
data
:
value
present
:
true
}
;
}
deleteProperty
:
function
UpdatePatch_deleteProperty
(
name
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdatePatch
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
deleteProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
name
in
this
.
_properties
)
{
this
.
_properties
[
name
]
.
present
=
false
;
}
else
{
throw
Cr
.
NS_ERROR_FAILURE
;
}
}
get
enumerator
(
)
{
return
this
.
enumerate
(
)
;
}
*
enumerate
(
)
{
let
ip
=
Cc
[
"
mozilla
.
org
/
supports
-
interface
-
pointer
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsInterfacePointer
)
;
let
qi
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIProperty
]
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
_properties
)
)
{
if
(
value
.
present
&
&
!
this
.
_attrNames
.
includes
(
name
)
)
{
ip
.
data
=
{
name
value
:
value
.
data
QueryInterface
:
qi
}
;
yield
ip
.
data
.
QueryInterface
(
Ci
.
nsIProperty
)
;
}
}
}
getProperty
:
function
UpdatePatch_getProperty
(
name
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdatePatch
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
getProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
name
in
this
.
_properties
&
&
this
.
_properties
[
name
]
.
present
)
{
return
this
.
_properties
[
name
]
.
data
;
}
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIUpdatePatch
Ci
.
nsIPropertyBag
Ci
.
nsIWritablePropertyBag
]
)
}
;
function
Update
(
update
)
{
this
.
_patches
=
[
]
;
this
.
_properties
=
{
}
;
this
.
isCompleteUpdate
=
false
;
this
.
channel
=
"
default
"
;
this
.
promptWaitTime
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_PROMPTWAITTIME
43200
)
;
this
.
unsupported
=
false
;
if
(
!
update
)
{
return
;
}
for
(
let
i
=
0
;
i
<
update
.
childNodes
.
length
;
+
+
i
)
{
let
patchElement
=
update
.
childNodes
.
item
(
i
)
;
if
(
patchElement
.
nodeType
!
=
patchElement
.
ELEMENT_NODE
|
|
patchElement
.
localName
!
=
"
patch
"
)
{
continue
;
}
let
patch
;
try
{
patch
=
new
UpdatePatch
(
patchElement
)
;
}
catch
(
e
)
{
continue
;
}
this
.
_patches
.
push
(
patch
)
;
}
if
(
this
.
_patches
.
length
=
=
0
&
&
!
update
.
hasAttribute
(
"
unsupported
"
)
)
{
throw
Cr
.
NS_ERROR_ILLEGAL_VALUE
;
}
this
.
installDate
=
(
new
Date
(
)
)
.
getTime
(
)
;
this
.
patchCount
=
this
.
_patches
.
length
;
for
(
let
i
=
0
;
i
<
update
.
attributes
.
length
;
+
+
i
)
{
let
attr
=
update
.
attributes
.
item
(
i
)
;
if
(
attr
.
name
=
=
"
xmlns
"
|
|
attr
.
value
=
=
"
undefined
"
)
{
continue
;
}
else
if
(
attr
.
name
=
=
"
detailsURL
"
)
{
this
.
detailsURL
=
attr
.
value
;
}
else
if
(
attr
.
name
=
=
"
installDate
"
&
&
attr
.
value
)
{
let
val
=
parseInt
(
attr
.
value
)
;
if
(
val
)
{
this
.
installDate
=
val
;
}
}
else
if
(
attr
.
name
=
=
"
errorCode
"
&
&
attr
.
value
)
{
let
val
=
parseInt
(
attr
.
value
)
;
if
(
val
)
{
this
.
_errorCode
=
val
;
}
}
else
if
(
attr
.
name
=
=
"
isCompleteUpdate
"
)
{
this
.
isCompleteUpdate
=
attr
.
value
=
=
"
true
"
;
}
else
if
(
attr
.
name
=
=
"
promptWaitTime
"
)
{
if
(
!
isNaN
(
attr
.
value
)
)
{
this
.
promptWaitTime
=
parseInt
(
attr
.
value
)
;
}
}
else
if
(
attr
.
name
=
=
"
unsupported
"
)
{
this
.
unsupported
=
attr
.
value
=
=
"
true
"
;
}
else
{
switch
(
attr
.
name
)
{
case
"
appVersion
"
:
case
"
buildID
"
:
case
"
channel
"
:
case
"
displayVersion
"
:
case
"
elevationFailure
"
:
case
"
name
"
:
case
"
previousAppVersion
"
:
case
"
serviceURL
"
:
case
"
statusText
"
:
case
"
type
"
:
this
[
attr
.
name
]
=
attr
.
value
;
break
;
default
:
if
(
!
this
.
_attrNames
.
includes
(
attr
.
name
)
)
{
this
.
setProperty
(
attr
.
name
attr
.
value
)
;
}
break
;
}
}
}
if
(
!
this
.
previousAppVersion
)
{
this
.
previousAppVersion
=
Services
.
appinfo
.
version
;
}
if
(
!
this
.
elevationFailure
)
{
this
.
elevationFailure
=
false
;
}
if
(
!
this
.
detailsURL
)
{
try
{
this
.
detailsURL
=
Services
.
urlFormatter
.
formatURLPref
(
PREF_APP_UPDATE_URL_DETAILS
)
;
}
catch
(
e
)
{
this
.
detailsURL
=
"
"
;
}
}
if
(
!
this
.
displayVersion
)
{
this
.
displayVersion
=
this
.
appVersion
;
}
if
(
!
this
.
name
)
{
let
brandBundle
=
Services
.
strings
.
createBundle
(
URI_BRAND_PROPERTIES
)
;
let
appName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
this
.
name
=
gUpdateBundle
.
formatStringFromName
(
"
updateName
"
[
appName
this
.
displayVersion
]
2
)
;
}
}
Update
.
prototype
=
{
_attrNames
:
[
"
appVersion
"
"
buildID
"
"
channel
"
"
detailsURL
"
"
displayVersion
"
"
elevationFailure
"
"
errorCode
"
"
installDate
"
"
isCompleteUpdate
"
"
name
"
"
previousAppVersion
"
"
promptWaitTime
"
"
serviceURL
"
"
state
"
"
statusText
"
"
type
"
"
unsupported
"
]
getPatchAt
:
function
Update_getPatchAt
(
index
)
{
return
this
.
_patches
[
index
]
;
}
_state
:
"
"
get
state
(
)
{
if
(
this
.
selectedPatch
)
return
this
.
selectedPatch
.
state
;
return
this
.
_state
;
}
set
state
(
state
)
{
if
(
this
.
selectedPatch
)
this
.
selectedPatch
.
state
=
state
;
this
.
_state
=
state
;
}
_errorCode
:
0
get
errorCode
(
)
{
if
(
this
.
selectedPatch
)
return
this
.
selectedPatch
.
errorCode
;
return
this
.
_errorCode
;
}
set
errorCode
(
errorCode
)
{
if
(
this
.
selectedPatch
)
this
.
selectedPatch
.
errorCode
=
errorCode
;
this
.
_errorCode
=
errorCode
;
}
get
selectedPatch
(
)
{
for
(
let
i
=
0
;
i
<
this
.
patchCount
;
+
+
i
)
{
if
(
this
.
_patches
[
i
]
.
selected
)
{
return
this
.
_patches
[
i
]
;
}
}
return
null
;
}
serialize
:
function
Update_serialize
(
updates
)
{
if
(
!
this
.
appVersion
)
{
return
null
;
}
let
update
=
updates
.
createElementNS
(
URI_UPDATE_NS
"
update
"
)
;
update
.
setAttribute
(
"
appVersion
"
this
.
appVersion
)
;
update
.
setAttribute
(
"
buildID
"
this
.
buildID
)
;
update
.
setAttribute
(
"
channel
"
this
.
channel
)
;
update
.
setAttribute
(
"
detailsURL
"
this
.
detailsURL
)
;
update
.
setAttribute
(
"
displayVersion
"
this
.
displayVersion
)
;
update
.
setAttribute
(
"
installDate
"
this
.
installDate
)
;
update
.
setAttribute
(
"
isCompleteUpdate
"
this
.
isCompleteUpdate
)
;
update
.
setAttribute
(
"
name
"
this
.
name
)
;
update
.
setAttribute
(
"
previousAppVersion
"
this
.
previousAppVersion
)
;
update
.
setAttribute
(
"
promptWaitTime
"
this
.
promptWaitTime
)
;
update
.
setAttribute
(
"
serviceURL
"
this
.
serviceURL
)
;
update
.
setAttribute
(
"
type
"
this
.
type
)
;
if
(
this
.
statusText
)
{
update
.
setAttribute
(
"
statusText
"
this
.
statusText
)
;
}
if
(
this
.
unsupported
)
{
update
.
setAttribute
(
"
unsupported
"
this
.
unsupported
)
;
}
if
(
this
.
elevationFailure
)
{
update
.
setAttribute
(
"
elevationFailure
"
this
.
elevationFailure
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
_properties
)
)
{
if
(
value
.
present
&
&
!
this
.
_attrNames
.
includes
(
name
)
)
{
update
.
setAttribute
(
name
value
.
data
)
;
}
}
for
(
let
i
=
0
;
i
<
this
.
patchCount
;
+
+
i
)
{
update
.
appendChild
(
this
.
getPatchAt
(
i
)
.
serialize
(
updates
)
)
;
}
updates
.
documentElement
.
appendChild
(
update
)
;
return
update
;
}
setProperty
:
function
Update_setProperty
(
name
value
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdate
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
setProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
this
.
_properties
[
name
]
=
{
data
:
value
present
:
true
}
;
}
deleteProperty
:
function
Update_deleteProperty
(
name
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdate
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
deleteProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
name
in
this
.
_properties
)
{
this
.
_properties
[
name
]
.
present
=
false
;
}
else
{
throw
Cr
.
NS_ERROR_FAILURE
;
}
}
get
enumerator
(
)
{
return
this
.
enumerate
(
)
;
}
*
enumerate
(
)
{
let
ip
=
Cc
[
"
mozilla
.
org
/
supports
-
interface
-
pointer
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsInterfacePointer
)
;
let
qi
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIProperty
]
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
_properties
)
)
{
if
(
value
.
present
&
&
!
this
.
_attrNames
.
includes
(
name
)
)
{
ip
.
data
=
{
name
value
:
value
.
data
QueryInterface
:
qi
}
;
yield
ip
.
data
.
QueryInterface
(
Ci
.
nsIProperty
)
;
}
}
}
getProperty
:
function
Update_getProperty
(
name
)
{
if
(
this
.
_attrNames
.
includes
(
name
)
)
{
throw
Components
.
Exception
(
"
Illegal
value
'
"
+
name
+
"
'
(
attribute
exists
on
nsIUpdate
)
"
+
"
when
calling
method
:
[
nsIWritablePropertyBag
:
:
getProperty
]
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
if
(
name
in
this
.
_properties
&
&
this
.
_properties
[
name
]
.
present
)
{
return
this
.
_properties
[
name
]
.
data
;
}
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIUpdate
Ci
.
nsIPropertyBag
Ci
.
nsIWritablePropertyBag
]
)
}
;
const
UpdateServiceFactory
=
{
_instance
:
null
createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
{
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
}
return
this
.
_instance
=
=
null
?
this
.
_instance
=
new
UpdateService
(
)
:
this
.
_instance
;
}
}
;
function
UpdateService
(
)
{
LOG
(
"
Creating
UpdateService
"
)
;
Services
.
obs
.
addObserver
(
this
"
quit
-
application
"
)
;
Services
.
prefs
.
addObserver
(
PREF_APP_UPDATE_LOG
this
)
;
}
UpdateService
.
prototype
=
{
_downloader
:
null
_registeredOnlineObserver
:
false
_consecutiveSocketErrors
:
0
_retryTimer
:
null
_isNotify
:
true
observe
:
function
AUS_observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
post
-
update
-
processing
"
:
Services
.
prefs
.
clearUserPref
(
"
app
.
update
.
enabled
"
)
;
if
(
readStatusFile
(
getUpdatesDir
(
)
)
=
=
STATE_SUCCEEDED
)
{
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_POSTUPDATE
true
)
;
}
if
(
Services
.
appinfo
.
ID
in
APPID_TO_TOPIC
)
{
Services
.
obs
.
addObserver
(
this
APPID_TO_TOPIC
[
Services
.
appinfo
.
ID
]
)
;
break
;
}
case
"
sessionstore
-
windows
-
restored
"
:
case
"
mail
-
startup
-
done
"
:
if
(
Services
.
appinfo
.
ID
in
APPID_TO_TOPIC
)
{
Services
.
obs
.
removeObserver
(
this
APPID_TO_TOPIC
[
Services
.
appinfo
.
ID
]
)
;
}
case
"
test
-
post
-
update
-
processing
"
:
this
.
_postUpdateProcessing
(
)
;
break
;
case
"
network
:
offline
-
status
-
changed
"
:
this
.
_offlineStatusChanged
(
data
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
data
=
=
PREF_APP_UPDATE_LOG
)
{
gLogEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
;
}
break
;
case
"
quit
-
application
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
Services
.
prefs
.
removeObserver
(
PREF_APP_UPDATE_LOG
this
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
gUpdateMutexHandle
)
{
closeHandle
(
gUpdateMutexHandle
)
;
}
if
(
this
.
_retryTimer
)
{
this
.
_retryTimer
.
cancel
(
)
;
}
this
.
pauseDownload
(
)
;
this
.
_downloader
=
null
;
Cc
[
"
mozilla
.
org
/
updates
/
update
-
checker
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdateChecker
)
.
stopCurrentCheck
(
)
;
break
;
case
"
test
-
close
-
handle
-
update
-
mutex
"
:
if
(
Cu
.
isInAutomation
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
gUpdateMutexHandle
)
{
LOG
(
"
UpdateService
:
observe
-
closing
mutex
handle
for
testing
"
)
;
closeHandle
(
gUpdateMutexHandle
)
;
gUpdateMutexHandle
=
null
;
}
}
break
;
}
}
_postUpdateProcessing
:
function
AUS__postUpdateProcessing
(
)
{
gUpdateFileWriteInfo
=
{
phase
:
"
startup
"
failure
:
false
}
;
if
(
!
this
.
canCheckForUpdates
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
unable
to
check
for
"
+
"
updates
.
.
.
returning
early
"
)
;
return
;
}
if
(
!
this
.
canApplyUpdates
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
unable
to
apply
"
+
"
updates
.
.
.
returning
early
"
)
;
cleanupActiveUpdate
(
)
;
return
;
}
var
um
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
;
var
update
=
um
.
activeUpdate
;
var
status
=
readStatusFile
(
getUpdatesDir
(
)
)
;
if
(
status
=
=
STATE_NONE
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
status
is
none
"
)
;
if
(
!
update
)
{
update
=
new
Update
(
null
)
;
}
update
.
state
=
STATE_FAILED
;
update
.
errorCode
=
ERR_UPDATE_STATE_NONE
;
update
.
statusText
=
gUpdateBundle
.
GetStringFromName
(
"
statusFailed
"
)
;
let
newStatus
=
STATE_FAILED
+
"
:
"
+
ERR_UPDATE_STATE_NONE
;
pingStateAndStatusCodes
(
update
true
newStatus
)
;
cleanupActiveUpdate
(
)
;
return
;
}
if
(
update
&
&
update
.
channel
!
=
UpdateUtils
.
UpdateChannel
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
channel
has
changed
"
+
"
reloading
default
preferences
to
workaround
bug
802022
"
)
;
let
prefSvc
=
Services
.
prefs
.
QueryInterface
(
Ci
.
nsIObserver
)
;
prefSvc
.
observe
(
null
"
reload
-
default
-
prefs
"
null
)
;
if
(
update
.
channel
!
=
UpdateUtils
.
UpdateChannel
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
update
channel
is
"
+
"
different
than
application
'
s
channel
removing
update
.
update
"
+
"
channel
:
"
+
update
.
channel
+
"
expected
channel
:
"
+
UpdateUtils
.
UpdateChannel
)
;
update
.
state
=
STATE_FAILED
;
update
.
errorCode
=
ERR_CHANNEL_CHANGE
;
update
.
statusText
=
gUpdateBundle
.
GetStringFromName
(
"
statusFailed
"
)
;
let
newStatus
=
STATE_FAILED
+
"
:
"
+
ERR_CHANNEL_CHANGE
;
pingStateAndStatusCodes
(
update
true
newStatus
)
;
cleanupActiveUpdate
(
)
;
return
;
}
}
if
(
update
&
&
update
.
appVersion
&
&
(
status
=
=
STATE_PENDING
|
|
status
=
=
STATE_PENDING_SERVICE
|
|
status
=
=
STATE_APPLIED
|
|
status
=
=
STATE_APPLIED_SERVICE
|
|
status
=
=
STATE_PENDING_ELEVATE
|
|
status
=
=
STATE_DOWNLOADING
)
)
{
if
(
Services
.
vc
.
compare
(
update
.
appVersion
Services
.
appinfo
.
version
)
<
0
|
|
Services
.
vc
.
compare
(
update
.
appVersion
Services
.
appinfo
.
version
)
=
=
0
&
&
update
.
buildID
=
=
Services
.
appinfo
.
appBuildID
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
removing
update
for
older
"
+
"
application
version
or
same
application
version
with
same
build
"
+
"
ID
.
update
application
version
:
"
+
update
.
appVersion
+
"
"
+
"
application
version
:
"
+
Services
.
appinfo
.
version
+
"
update
"
+
"
build
ID
:
"
+
update
.
buildID
+
"
application
build
ID
:
"
+
Services
.
appinfo
.
appBuildID
)
;
update
.
state
=
STATE_FAILED
;
update
.
statusText
=
gUpdateBundle
.
GetStringFromName
(
"
statusFailed
"
)
;
update
.
errorCode
=
ERR_OLDER_VERSION_OR_SAME_BUILD
;
let
newStatus
=
STATE_FAILED
+
"
:
"
+
ERR_OLDER_VERSION_OR_SAME_BUILD
;
pingStateAndStatusCodes
(
update
true
newStatus
)
;
cleanupActiveUpdate
(
)
;
return
;
}
}
pingStateAndStatusCodes
(
update
true
status
)
;
if
(
status
=
=
STATE_DOWNLOADING
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
patch
found
in
downloading
"
+
"
state
"
)
;
status
=
this
.
downloadUpdate
(
update
true
)
;
if
(
status
=
=
STATE_NONE
)
{
cleanupActiveUpdate
(
)
;
}
return
;
}
if
(
status
=
=
STATE_APPLYING
)
{
if
(
update
&
&
(
update
.
state
=
=
STATE_PENDING
|
|
update
.
state
=
=
STATE_PENDING_SERVICE
)
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
patch
found
in
applying
"
+
"
state
for
the
first
time
"
)
;
update
.
state
=
STATE_APPLYING
;
um
.
saveUpdates
(
)
;
}
else
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
patch
found
in
applying
"
+
"
state
for
the
second
time
"
)
;
cleanupActiveUpdate
(
)
;
}
return
;
}
if
(
!
update
)
{
if
(
status
!
=
STATE_SUCCEEDED
)
{
LOG
(
"
UpdateService
:
_postUpdateProcessing
-
previous
patch
failed
"
+
"
and
no
patch
available
"
)
;
cleanupActiveUpdate
(
)
;
return
;
}
update
=
new
Update
(
null
)
;
}
let
parts
=
status
.
split
(
"
:
"
)
;
update
.
state
=
parts
[
0
]
;
if
(
update
.
state
=
=
STATE_FAILED
&
&
parts
[
1
]
)
{
update
.
errorCode
=
parseInt
(
parts
[
1
]
)
;
}
if
(
status
!
=
STATE_SUCCEEDED
)
{
cleanUpUpdatesDir
(
false
)
;
}
if
(
status
=
=
STATE_SUCCEEDED
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS
)
;
}
update
.
statusText
=
gUpdateBundle
.
GetStringFromName
(
"
installSuccess
"
)
;
if
(
!
um
.
activeUpdate
)
{
um
.
activeUpdate
=
update
;
}
cleanupActiveUpdate
(
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_ELEVATE_ATTEMPTS
0
)
;
}
else
if
(
status
=
=
STATE_PENDING_ELEVATE
)
{
let
prompter
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
;
prompter
.
showUpdateElevationRequired
(
)
;
}
else
{
if
(
update
.
state
=
=
STATE_FAILED
&
&
update
.
errorCode
)
{
if
(
handleUpdateFailure
(
update
update
.
errorCode
)
)
{
return
;
}
}
handleFallbackToCompleteUpdate
(
update
false
)
;
let
prompter
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
;
prompter
.
showUpdateError
(
update
)
;
}
}
_registerOnlineObserver
:
function
AUS__registerOnlineObserver
(
)
{
if
(
this
.
_registeredOnlineObserver
)
{
LOG
(
"
UpdateService
:
_registerOnlineObserver
-
observer
already
registered
"
)
;
return
;
}
LOG
(
"
UpdateService
:
_registerOnlineObserver
-
waiting
for
the
network
to
"
+
"
be
online
then
forcing
another
check
"
)
;
Services
.
obs
.
addObserver
(
this
"
network
:
offline
-
status
-
changed
"
)
;
this
.
_registeredOnlineObserver
=
true
;
}
_offlineStatusChanged
:
function
AUS__offlineStatusChanged
(
status
)
{
if
(
status
!
=
=
"
online
"
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
"
network
:
offline
-
status
-
changed
"
)
;
this
.
_registeredOnlineObserver
=
false
;
LOG
(
"
UpdateService
:
_offlineStatusChanged
-
network
is
online
forcing
"
+
"
another
background
check
"
)
;
this
.
_attemptResume
(
)
;
}
onCheckComplete
:
function
AUS_onCheckComplete
(
request
updates
updateCount
)
{
this
.
_selectAndInstallUpdate
(
updates
)
;
}
onError
:
function
AUS_onError
(
request
update
)
{
LOG
(
"
UpdateService
:
onError
-
error
during
background
update
.
error
code
:
"
+
update
.
errorCode
+
"
status
text
:
"
+
update
.
statusText
)
;
if
(
update
.
errorCode
=
=
NETWORK_ERROR_OFFLINE
)
{
this
.
_registerOnlineObserver
(
)
;
if
(
this
.
_pingSuffix
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_OFFLINE
)
;
}
return
;
}
AUSTLMY
.
pingCheckExError
(
this
.
_pingSuffix
update
.
errorCode
)
;
update
.
errorCode
=
BACKGROUNDCHECK_MULTIPLE_FAILURES
;
let
errCount
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
0
)
;
errCount
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
errCount
)
;
let
maxErrors
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_BACKGROUNDMAXERRORS
10
)
20
)
;
if
(
errCount
>
=
maxErrors
)
{
let
prompter
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
;
LOG
(
"
UpdateService
:
onError
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
check
-
attempts
-
exceeded
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
check
-
attempts
-
exceeded
"
)
;
prompter
.
showUpdateError
(
update
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_GENERAL_ERROR_PROMPT
)
;
}
else
{
LOG
(
"
UpdateService
:
onError
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
check
-
attempt
-
failed
"
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
error
"
"
check
-
attempt
-
failed
"
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_GENERAL_ERROR_SILENT
)
;
}
}
_attemptResume
:
function
AUS_attemptResume
(
)
{
LOG
(
"
UpdateService
:
_attemptResume
"
)
;
if
(
this
.
_downloader
&
&
this
.
_downloader
.
_patch
&
&
this
.
_downloader
.
_patch
.
state
=
=
STATE_DOWNLOADING
&
&
this
.
_downloader
.
_update
)
{
LOG
(
"
UpdateService
:
_attemptResume
-
_patch
.
state
:
"
+
this
.
_downloader
.
_patch
.
state
)
;
writeStatusFile
(
getUpdatesDir
(
)
STATE_DOWNLOADING
)
;
var
status
=
this
.
downloadUpdate
(
this
.
_downloader
.
_update
this
.
_downloader
.
background
)
;
LOG
(
"
UpdateService
:
_attemptResume
-
downloadUpdate
status
:
"
+
status
)
;
if
(
status
=
=
STATE_NONE
)
{
cleanupActiveUpdate
(
)
;
}
return
;
}
this
.
backgroundChecker
.
checkForUpdates
(
this
false
)
;
}
notify
:
function
AUS_notify
(
timer
)
{
this
.
_checkForBackgroundUpdates
(
true
)
;
}
checkForBackgroundUpdates
:
function
AUS_checkForBackgroundUpdates
(
)
{
this
.
_checkForBackgroundUpdates
(
false
)
;
}
get
_pingSuffix
(
)
{
return
this
.
_isNotify
?
AUSTLMY
.
NOTIFY
:
AUSTLMY
.
EXTERNAL
;
}
_checkForBackgroundUpdates
:
function
AUS__checkForBackgroundUpdates
(
isNotify
)
{
this
.
_isNotify
=
isNotify
;
AUSTLMY
.
pingGeneric
(
"
UPDATE_PING_COUNT_
"
+
this
.
_pingSuffix
true
false
)
;
AUSTLMY
.
pingGeneric
(
"
UPDATE_UNABLE_TO_APPLY_
"
+
this
.
_pingSuffix
getCanApplyUpdates
(
)
true
)
;
AUSTLMY
.
pingGeneric
(
"
UPDATE_CANNOT_STAGE_
"
+
this
.
_pingSuffix
getCanStageUpdates
(
)
true
)
;
AUSTLMY
.
pingLastUpdateTime
(
this
.
_pingSuffix
)
;
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
.
then
(
enabled
=
>
{
AUSTLMY
.
pingGeneric
(
"
UPDATE_NOT_PREF_UPDATE_AUTO_
"
+
this
.
_pingSuffix
enabled
true
)
;
}
)
;
AUSTLMY
.
pingBoolPref
(
"
UPDATE_NOT_PREF_UPDATE_STAGING_ENABLED_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_STAGING_ENABLED
true
true
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
|
|
AppConstants
.
platform
=
=
"
macosx
"
)
{
AUSTLMY
.
pingIntPref
(
"
UPDATE_PREF_UPDATE_CANCELATIONS_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_CANCELATIONS
0
0
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
AUSTLMY
.
pingIntPref
(
"
UPDATE_PREF_UPDATE_CANCELATIONS_OSX_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_CANCELATIONS_OSX
0
0
)
;
}
if
(
AppConstants
.
MOZ_MAINTENANCE_SERVICE
)
{
AUSTLMY
.
pingBoolPref
(
"
UPDATE_NOT_PREF_UPDATE_SERVICE_ENABLED_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_SERVICE_ENABLED
true
)
;
AUSTLMY
.
pingIntPref
(
"
UPDATE_PREF_SERVICE_ERRORS_
"
+
this
.
_pingSuffix
PREF_APP_UPDATE_SERVICE_ERRORS
0
0
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
AUSTLMY
.
pingServiceInstallStatus
(
this
.
_pingSuffix
isServiceInstalled
(
)
)
;
}
}
if
(
this
.
isDownloading
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_IS_DOWNLOADING
)
;
return
;
}
if
(
this
.
_downloader
&
&
this
.
_downloader
.
patchIsStaged
)
{
let
readState
=
readStatusFile
(
getUpdatesDir
(
)
)
;
if
(
readState
=
=
STATE_PENDING
|
|
readState
=
=
STATE_PENDING_SERVICE
|
|
readState
=
=
STATE_PENDING_ELEVATE
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_IS_DOWNLOADED
)
;
}
else
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_IS_STAGED
)
;
}
return
;
}
let
validUpdateURL
=
true
;
this
.
backgroundChecker
.
getUpdateURL
(
false
)
.
catch
(
e
=
>
{
validUpdateURL
=
false
;
}
)
.
then
(
(
)
=
>
{
if
(
!
UpdateUtils
.
OSVersion
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_NO_OS_VERSION
)
;
}
else
if
(
!
UpdateUtils
.
ABI
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_NO_OS_ABI
)
;
}
else
if
(
!
validUpdateURL
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_INVALID_DEFAULT_URL
)
;
}
else
if
(
this
.
disabledByPolicy
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_DISABLED_BY_POLICY
)
;
}
else
if
(
!
hasUpdateMutex
(
)
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_NO_MUTEX
)
;
}
else
if
(
!
this
.
canCheckForUpdates
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_UNABLE_TO_CHECK
)
;
}
this
.
backgroundChecker
.
checkForUpdates
(
this
false
)
;
}
)
;
}
selectUpdate
:
function
AUS_selectUpdate
(
updates
)
{
if
(
updates
.
length
=
=
0
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_NO_UPDATE_FOUND
)
;
return
null
;
}
if
(
updates
.
length
=
=
1
&
&
updates
[
0
]
.
unsupported
)
{
return
updates
[
0
]
;
}
var
majorUpdate
=
null
;
var
minorUpdate
=
null
;
var
vc
=
Services
.
vc
;
let
lastCheckCode
=
AUSTLMY
.
CHK_NO_COMPAT_UPDATE_FOUND
;
updates
.
forEach
(
function
(
aUpdate
)
{
if
(
vc
.
compare
(
aUpdate
.
appVersion
Services
.
appinfo
.
version
)
<
0
|
|
vc
.
compare
(
aUpdate
.
appVersion
Services
.
appinfo
.
version
)
=
=
0
&
&
aUpdate
.
buildID
=
=
Services
.
appinfo
.
appBuildID
)
{
LOG
(
"
UpdateService
:
selectUpdate
-
skipping
update
because
the
"
+
"
update
'
s
application
version
is
less
than
the
current
"
+
"
application
version
"
)
;
lastCheckCode
=
AUSTLMY
.
CHK_UPDATE_PREVIOUS_VERSION
;
return
;
}
switch
(
aUpdate
.
type
)
{
case
"
major
"
:
if
(
!
majorUpdate
)
majorUpdate
=
aUpdate
;
else
if
(
vc
.
compare
(
majorUpdate
.
appVersion
aUpdate
.
appVersion
)
<
=
0
)
majorUpdate
=
aUpdate
;
break
;
case
"
minor
"
:
if
(
!
minorUpdate
)
minorUpdate
=
aUpdate
;
else
if
(
vc
.
compare
(
minorUpdate
.
appVersion
aUpdate
.
appVersion
)
<
=
0
)
minorUpdate
=
aUpdate
;
break
;
default
:
LOG
(
"
UpdateService
:
selectUpdate
-
skipping
unknown
update
type
:
"
+
aUpdate
.
type
)
;
lastCheckCode
=
AUSTLMY
.
CHK_UPDATE_INVALID_TYPE
;
break
;
}
}
)
;
let
update
=
minorUpdate
|
|
majorUpdate
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
&
&
update
)
{
if
(
getElevationRequired
(
)
)
{
let
installAttemptVersion
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_ELEVATE_VERSION
null
)
;
if
(
vc
.
compare
(
installAttemptVersion
update
.
appVersion
)
!
=
0
)
{
Services
.
prefs
.
setCharPref
(
PREF_APP_UPDATE_ELEVATE_VERSION
update
.
appVersion
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
}
else
{
let
numCancels
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
0
)
;
let
rejectedVersion
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
"
"
)
;
let
maxCancels
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX_MAX
DEFAULT_CANCELATIONS_OSX_MAX
)
;
if
(
numCancels
>
=
maxCancels
)
{
LOG
(
"
UpdateService
:
selectUpdate
-
the
user
requires
elevation
to
"
+
"
install
this
update
but
the
user
has
exceeded
the
max
"
+
"
number
of
elevation
attempts
.
"
)
;
update
.
elevationFailure
=
true
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_ELEVATION_DISABLED_FOR_VERSION
)
;
}
else
if
(
vc
.
compare
(
rejectedVersion
update
.
appVersion
)
=
=
0
)
{
LOG
(
"
UpdateService
:
selectUpdate
-
the
user
requires
elevation
to
"
+
"
install
this
update
but
elevation
is
disabled
for
this
"
+
"
version
.
"
)
;
update
.
elevationFailure
=
true
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_ELEVATION_OPTOUT_FOR_VERSION
)
;
}
else
{
LOG
(
"
UpdateService
:
selectUpdate
-
the
user
requires
elevation
to
"
+
"
install
the
update
.
"
)
;
}
}
}
else
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_VERSION
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_VERSION
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_CANCELATIONS_OSX
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_ELEVATE_NEVER
)
;
}
}
}
else
if
(
!
update
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
lastCheckCode
)
;
}
return
update
;
}
_selectAndInstallUpdate
:
async
function
AUS__selectAndInstallUpdate
(
updates
)
{
var
um
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
;
if
(
um
.
activeUpdate
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_HAS_ACTIVEUPDATE
)
;
return
;
}
if
(
this
.
disabledByPolicy
)
{
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_PREF_DISABLED
)
;
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
not
prompting
because
"
+
"
update
is
disabled
"
)
;
return
;
}
var
update
=
this
.
selectUpdate
(
updates
updates
.
length
)
;
if
(
!
update
|
|
update
.
elevationFailure
)
{
return
;
}
if
(
update
.
unsupported
)
{
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
update
not
supported
for
"
+
"
this
system
.
Notifying
observers
.
topic
:
update
-
available
"
+
"
status
:
unsupported
"
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_NOTIFIEDUNSUPPORTED
false
)
)
{
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
notifying
that
the
"
+
"
update
is
not
supported
for
this
system
"
)
;
this
.
_showPrompt
(
update
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
update
-
available
"
"
unsupported
"
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_UNSUPPORTED
)
;
return
;
}
if
(
!
getCanApplyUpdates
(
)
)
{
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
the
user
is
unable
to
"
+
"
apply
updates
.
.
.
prompting
.
Notifying
observers
.
"
+
"
topic
:
update
-
available
status
:
cant
-
apply
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
update
-
available
"
"
cant
-
apply
"
)
;
this
.
_showPrompt
(
update
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_UNABLE_TO_APPLY
)
;
return
;
}
let
updateAuto
=
await
UpdateUtils
.
getAppUpdateAutoEnabled
(
)
;
if
(
!
updateAuto
)
{
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
prompting
because
silent
"
+
"
install
is
disabled
.
Notifying
observers
.
topic
:
update
-
available
"
+
"
status
:
show
-
prompt
"
)
;
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_SHOWPROMPT_PREF
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
available
"
"
show
-
prompt
"
)
;
this
.
_showPrompt
(
update
)
;
return
;
}
LOG
(
"
UpdateService
:
_selectAndInstallUpdate
-
download
the
update
"
)
;
let
status
=
this
.
downloadUpdate
(
update
true
)
;
if
(
status
=
=
STATE_NONE
)
{
cleanupActiveUpdate
(
)
;
}
AUSTLMY
.
pingCheckCode
(
this
.
_pingSuffix
AUSTLMY
.
CHK_DOWNLOAD_UPDATE
)
;
}
_showPrompt
:
function
AUS__showPrompt
(
update
)
{
let
prompter
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
;
prompter
.
showUpdateAvailable
(
update
)
;
}
_backgroundChecker
:
null
get
backgroundChecker
(
)
{
if
(
!
this
.
_backgroundChecker
)
this
.
_backgroundChecker
=
new
Checker
(
)
;
return
this
.
_backgroundChecker
;
}
get
disabledForTesting
(
)
{
let
marionetteRunning
=
false
;
if
(
"
nsIMarionette
"
in
Ci
)
{
marionetteRunning
=
Cc
[
"
mozilla
.
org
/
remote
/
marionette
;
1
"
]
.
createInstance
(
Ci
.
nsIMarionette
)
.
running
;
}
return
(
Cu
.
isInAutomation
|
|
marionetteRunning
)
&
&
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_DISABLEDFORTESTING
false
)
;
}
get
disabledByPolicy
(
)
{
return
(
Services
.
policies
&
&
!
Services
.
policies
.
isAllowed
(
"
appUpdate
"
)
)
|
|
this
.
disabledForTesting
;
}
get
canCheckForUpdates
(
)
{
if
(
this
.
disabledByPolicy
)
{
LOG
(
"
UpdateService
.
canCheckForUpdates
-
unable
to
automatically
check
"
+
"
for
updates
the
option
has
been
disabled
by
the
administrator
.
"
)
;
return
false
;
}
if
(
!
UpdateUtils
.
ABI
)
{
LOG
(
"
UpdateService
.
canCheckForUpdates
-
unable
to
check
for
updates
"
+
"
unknown
ABI
"
)
;
return
false
;
}
if
(
!
UpdateUtils
.
OSVersion
)
{
LOG
(
"
UpdateService
.
canCheckForUpdates
-
unable
to
check
for
updates
"
+
"
unknown
OS
version
"
)
;
return
false
;
}
if
(
!
hasUpdateMutex
(
)
)
{
LOG
(
"
UpdateService
.
canCheckForUpdates
-
unable
to
check
for
updates
"
+
"
unable
to
acquire
update
mutex
"
)
;
return
false
;
}
LOG
(
"
UpdateService
.
canCheckForUpdates
-
able
to
check
for
updates
"
)
;
return
true
;
}
get
elevationRequired
(
)
{
return
getElevationRequired
(
)
;
}
get
canApplyUpdates
(
)
{
return
getCanApplyUpdates
(
)
&
&
hasUpdateMutex
(
)
;
}
get
canStageUpdates
(
)
{
return
getCanStageUpdates
(
)
;
}
get
isOtherInstanceHandlingUpdates
(
)
{
return
!
hasUpdateMutex
(
)
;
}
addDownloadListener
:
function
AUS_addDownloadListener
(
listener
)
{
if
(
!
this
.
_downloader
)
{
LOG
(
"
UpdateService
:
addDownloadListener
-
no
downloader
!
"
)
;
return
;
}
this
.
_downloader
.
addDownloadListener
(
listener
)
;
}
removeDownloadListener
:
function
AUS_removeDownloadListener
(
listener
)
{
if
(
!
this
.
_downloader
)
{
LOG
(
"
UpdateService
:
removeDownloadListener
-
no
downloader
!
"
)
;
return
;
}
this
.
_downloader
.
removeDownloadListener
(
listener
)
;
}
downloadUpdate
:
function
AUS_downloadUpdate
(
update
background
)
{
if
(
!
update
)
throw
Cr
.
NS_ERROR_NULL_POINTER
;
if
(
update
.
appVersion
&
&
(
Services
.
vc
.
compare
(
update
.
appVersion
Services
.
appinfo
.
version
)
<
0
|
|
update
.
buildID
&
&
update
.
buildID
=
=
Services
.
appinfo
.
appBuildID
&
&
update
.
appVersion
=
=
Services
.
appinfo
.
version
)
)
{
LOG
(
"
UpdateService
:
downloadUpdate
-
canceling
download
of
update
since
"
+
"
it
is
for
an
earlier
or
same
application
version
and
build
ID
.
\
n
"
+
"
current
application
version
:
"
+
Services
.
appinfo
.
version
+
"
\
n
"
+
"
update
application
version
:
"
+
update
.
appVersion
+
"
\
n
"
+
"
current
build
ID
:
"
+
Services
.
appinfo
.
appBuildID
+
"
\
n
"
+
"
update
build
ID
:
"
+
update
.
buildID
)
;
cleanupActiveUpdate
(
)
;
return
STATE_NONE
;
}
if
(
this
.
isDownloading
)
{
if
(
update
.
isCompleteUpdate
=
=
this
.
_downloader
.
isCompleteUpdate
&
&
background
=
=
this
.
_downloader
.
background
)
{
LOG
(
"
UpdateService
:
downloadUpdate
-
no
support
for
downloading
more
"
+
"
than
one
update
at
a
time
"
)
;
return
readStatusFile
(
getUpdatesDir
(
)
)
;
}
this
.
_downloader
.
cancel
(
)
;
}
this
.
_downloader
=
new
Downloader
(
background
this
)
;
return
this
.
_downloader
.
downloadUpdate
(
update
)
;
}
pauseDownload
:
function
AUS_pauseDownload
(
)
{
if
(
this
.
isDownloading
)
{
this
.
_downloader
.
cancel
(
)
;
}
else
if
(
this
.
_retryTimer
)
{
this
.
_retryTimer
.
cancel
(
)
;
this
.
_retryTimer
=
null
;
this
.
_downloader
.
cancel
(
)
;
}
}
getUpdatesDirectory
:
getUpdatesDir
get
isDownloading
(
)
{
return
this
.
_downloader
&
&
this
.
_downloader
.
isBusy
;
}
classID
:
UPDATESERVICE_CID
_xpcom_factory
:
UpdateServiceFactory
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIApplicationUpdateService
Ci
.
nsIUpdateCheckListener
Ci
.
nsITimerCallback
Ci
.
nsIObserver
]
)
}
;
function
UpdateManager
(
)
{
let
activeUpdates
=
this
.
_loadXMLFileIntoArray
(
FILE_ACTIVE_UPDATE_XML
)
;
if
(
activeUpdates
.
length
>
0
)
{
this
.
_activeUpdate
=
activeUpdates
[
0
]
;
if
(
readStatusFile
(
getUpdatesDir
(
)
)
=
=
STATE_NONE
)
{
this
.
_activeUpdate
.
state
=
STATE_FAILED
;
this
.
_activeUpdate
.
errorCode
=
ERR_UPDATE_STATE_NONE
;
this
.
_activeUpdate
.
statusText
=
gUpdateBundle
.
GetStringFromName
(
"
statusFailed
"
)
;
let
newStatus
=
STATE_FAILED
+
"
:
"
+
ERR_UPDATE_STATE_NONE
;
pingStateAndStatusCodes
(
this
.
_activeUpdate
true
newStatus
)
;
this
.
activeUpdate
=
null
;
this
.
saveUpdates
(
)
;
cleanUpUpdatesDir
(
)
;
}
}
}
UpdateManager
.
prototype
=
{
_activeUpdate
:
null
_updatesDirty
:
false
observe
:
function
UM_observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
um
-
reload
-
update
-
data
"
)
{
if
(
!
Cu
.
isInAutomation
)
{
return
;
}
if
(
this
.
_updatesXMLSaver
)
{
this
.
_updatesXMLSaver
.
disarm
(
)
;
}
let
updates
=
[
]
;
this
.
_updatesDirty
=
true
;
this
.
_activeUpdate
=
null
;
if
(
data
!
=
"
skip
-
files
"
)
{
let
activeUpdates
=
this
.
_loadXMLFileIntoArray
(
FILE_ACTIVE_UPDATE_XML
)
;
if
(
activeUpdates
.
length
>
0
)
{
this
.
_activeUpdate
=
activeUpdates
[
0
]
;
}
updates
=
this
.
_loadXMLFileIntoArray
(
FILE_UPDATES_XML
)
;
}
delete
this
.
_updates
;
Object
.
defineProperty
(
this
"
_updates
"
{
value
:
updates
writable
:
true
configurable
:
true
enumerable
:
true
}
)
;
}
}
_loadXMLFileIntoArray
:
function
UM__loadXMLFileIntoArray
(
fileName
)
{
let
updates
=
[
]
;
let
file
=
getUpdateFile
(
[
fileName
]
)
;
if
(
!
file
.
exists
(
)
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
XML
file
does
not
exist
.
"
+
"
path
:
"
+
file
.
path
)
;
return
updates
;
}
let
fileStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
try
{
fileStream
.
init
(
file
FileUtils
.
MODE_RDONLY
FileUtils
.
PERMS_FILE
0
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
error
initializing
file
"
+
"
stream
.
Exception
:
"
+
e
)
;
return
updates
;
}
try
{
var
parser
=
new
DOMParser
(
)
;
var
doc
=
parser
.
parseFromStream
(
fileStream
"
UTF
-
8
"
fileStream
.
available
(
)
"
text
/
xml
"
)
;
var
updateCount
=
doc
.
documentElement
.
childNodes
.
length
;
for
(
var
i
=
0
;
i
<
updateCount
;
+
+
i
)
{
var
updateElement
=
doc
.
documentElement
.
childNodes
.
item
(
i
)
;
if
(
updateElement
.
nodeType
!
=
updateElement
.
ELEMENT_NODE
|
|
updateElement
.
localName
!
=
"
update
"
)
continue
;
let
update
;
try
{
update
=
new
Update
(
updateElement
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
invalid
update
"
)
;
continue
;
}
updates
.
push
(
update
)
;
}
}
catch
(
ex
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
error
constructing
update
"
+
"
list
.
Exception
:
"
+
ex
)
;
}
fileStream
.
close
(
)
;
if
(
updates
.
length
=
=
0
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
update
xml
file
"
+
fileName
+
"
exists
but
doesn
'
t
contain
any
updates
"
)
;
try
{
file
.
remove
(
false
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_loadXMLFileIntoArray
-
error
removing
"
+
fileName
+
"
file
.
Exception
:
"
+
e
)
;
}
}
return
updates
;
}
get
_updates
(
)
{
delete
this
.
_updates
;
let
updates
=
this
.
_loadXMLFileIntoArray
(
FILE_UPDATES_XML
)
;
Object
.
defineProperty
(
this
"
_updates
"
{
value
:
updates
writable
:
true
configurable
:
true
enumerable
:
true
}
)
;
return
this
.
_updates
;
}
getUpdateAt
:
function
UM_getUpdateAt
(
aIndex
)
{
return
this
.
_updates
[
aIndex
]
;
}
get
updateCount
(
)
{
return
this
.
_updates
.
length
;
}
get
activeUpdate
(
)
{
return
this
.
_activeUpdate
;
}
set
activeUpdate
(
aActiveUpdate
)
{
if
(
!
aActiveUpdate
&
&
this
.
_activeUpdate
)
{
this
.
_updatesDirty
=
true
;
this
.
_updates
.
unshift
(
this
.
_activeUpdate
)
;
this
.
_updates
.
splice
(
10
)
;
}
this
.
_activeUpdate
=
aActiveUpdate
;
}
_writeUpdatesToXMLFile
:
async
function
UM__writeUpdatesToXMLFile
(
updates
fileName
)
{
let
file
;
try
{
file
=
getUpdateFile
(
[
fileName
]
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_writeUpdatesToXMLFile
-
Unable
to
get
XML
file
-
"
+
"
Exception
:
"
+
e
)
;
return
false
;
}
if
(
updates
.
length
=
=
0
)
{
LOG
(
"
UpdateManager
:
_writeUpdatesToXMLFile
-
no
updates
to
write
.
"
+
"
removing
file
:
"
+
file
.
path
)
;
try
{
await
OS
.
File
.
remove
(
file
.
path
{
ignoreAbsent
:
true
}
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_writeUpdatesToXMLFile
-
Delete
file
exception
:
"
+
e
)
;
return
false
;
}
return
true
;
}
const
EMPTY_UPDATES_DOCUMENT_OPEN
=
"
<
?
xml
version
=
\
"
1
.
0
\
"
?
>
<
updates
xmlns
=
\
"
"
+
URI_UPDATE_NS
+
"
\
"
>
"
;
const
EMPTY_UPDATES_DOCUMENT_CLOSE
=
"
<
/
updates
>
"
;
try
{
var
parser
=
new
DOMParser
(
)
;
var
doc
=
parser
.
parseFromString
(
EMPTY_UPDATES_DOCUMENT_OPEN
+
EMPTY_UPDATES_DOCUMENT_CLOSE
"
text
/
xml
"
)
;
for
(
var
i
=
0
;
i
<
updates
.
length
;
+
+
i
)
{
doc
.
documentElement
.
appendChild
(
updates
[
i
]
.
serialize
(
doc
)
)
;
}
var
xml
=
EMPTY_UPDATES_DOCUMENT_OPEN
+
doc
.
documentElement
.
innerHTML
+
EMPTY_UPDATES_DOCUMENT_CLOSE
;
await
OS
.
File
.
writeAtomic
(
file
.
path
xml
{
encoding
:
"
utf
-
8
"
tmpPath
:
file
.
path
+
"
.
tmp
"
}
)
;
await
OS
.
File
.
setPermissions
(
file
.
path
{
unixMode
:
FileUtils
.
PERMS_FILE
}
)
;
}
catch
(
e
)
{
LOG
(
"
UpdateManager
:
_writeUpdatesToXMLFile
-
Exception
:
"
+
e
)
;
return
false
;
}
return
true
;
}
_updatesXMLSaver
:
null
_updatesXMLSaverCallback
:
null
saveUpdates
:
function
UM_saveUpdates
(
)
{
if
(
!
this
.
_updatesXMLSaver
)
{
this
.
_updatesXMLSaverCallback
=
(
)
=
>
this
.
_updatesXMLSaver
.
finalize
(
)
;
this
.
_updatesXMLSaver
=
new
DeferredTask
(
(
)
=
>
this
.
_saveUpdatesXML
(
)
XML_SAVER_INTERVAL_MS
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
UpdateManager
:
writing
update
xml
data
"
this
.
_updatesXMLSaverCallback
)
;
}
else
{
this
.
_updatesXMLSaver
.
disarm
(
)
;
}
this
.
_updatesXMLSaver
.
arm
(
)
;
}
_saveUpdatesXML
:
function
UM__saveUpdatesXML
(
)
{
let
updates
=
this
.
_activeUpdate
?
[
this
.
_activeUpdate
]
:
[
]
;
let
promises
=
[
]
;
promises
[
0
]
=
this
.
_writeUpdatesToXMLFile
(
updates
FILE_ACTIVE_UPDATE_XML
)
.
then
(
wroteSuccessfully
=
>
handleCriticalWriteResult
(
wroteSuccessfully
FILE_ACTIVE_UPDATE_XML
)
)
;
if
(
this
.
_updatesDirty
)
{
this
.
_updatesDirty
=
false
;
promises
[
1
]
=
this
.
_writeUpdatesToXMLFile
(
this
.
_updates
FILE_UPDATES_XML
)
.
then
(
wroteSuccessfully
=
>
handleCriticalWriteResult
(
wroteSuccessfully
FILE_UPDATES_XML
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
refreshUpdateStatus
:
function
UM_refreshUpdateStatus
(
)
{
var
update
=
this
.
_activeUpdate
;
if
(
!
update
)
{
return
;
}
var
status
=
readStatusFile
(
getUpdatesDir
(
)
)
;
pingStateAndStatusCodes
(
update
false
status
)
;
var
parts
=
status
.
split
(
"
:
"
)
;
update
.
state
=
parts
[
0
]
;
if
(
update
.
state
=
=
STATE_FAILED
&
&
parts
[
1
]
)
{
update
.
errorCode
=
parseInt
(
parts
[
1
]
)
;
}
cleanUpUpdatesDir
(
false
)
;
if
(
update
.
state
=
=
STATE_FAILED
&
&
parts
[
1
]
)
{
if
(
!
handleUpdateFailure
(
update
parts
[
1
]
)
)
{
handleFallbackToCompleteUpdate
(
update
true
)
;
}
update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
update
.
setProperty
(
"
stagingFailed
"
"
true
"
)
;
}
if
(
update
.
state
=
=
STATE_APPLIED
&
&
shouldUseService
(
)
)
{
writeStatusFile
(
getUpdatesDir
(
)
update
.
state
=
STATE_APPLIED_SERVICE
)
;
}
this
.
saveUpdates
(
)
;
LOG
(
"
UpdateManager
:
refreshUpdateStatus
-
Notifying
observers
that
"
+
"
the
update
was
staged
.
topic
:
update
-
staged
status
:
"
+
update
.
state
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
staged
"
update
.
state
)
;
let
windowType
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_ALTWINDOWTYPE
null
)
;
if
(
Services
.
wm
.
getMostRecentWindow
(
UPDATE_WINDOW_NAME
)
|
|
windowType
&
&
Services
.
wm
.
getMostRecentWindow
(
windowType
)
)
{
return
;
}
if
(
update
.
state
=
=
STATE_APPLIED
|
|
update
.
state
=
=
STATE_APPLIED_SERVICE
|
|
update
.
state
=
=
STATE_PENDING
|
|
update
.
state
=
=
STATE_PENDING_SERVICE
|
|
update
.
state
=
=
STATE_PENDING_ELEVATE
)
{
let
prompter
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
;
prompter
.
showUpdateDownloaded
(
update
true
)
;
}
}
elevationOptedIn
:
function
UM_elevationOptedIn
(
)
{
let
update
=
this
.
_activeUpdate
;
if
(
!
update
)
{
return
;
}
let
status
=
readStatusFile
(
getUpdatesDir
(
)
)
;
let
parts
=
status
.
split
(
"
:
"
)
;
update
.
state
=
parts
[
0
]
;
if
(
update
.
state
=
=
STATE_PENDING_ELEVATE
)
{
writeStatusFile
(
getUpdatesDir
(
)
STATE_PENDING
)
;
}
}
cleanupActiveUpdate
:
function
UM_cleanupActiveUpdate
(
)
{
cleanupActiveUpdate
(
)
;
}
classID
:
Components
.
ID
(
"
{
093C2356
-
4843
-
4C65
-
8709
-
D7DBCBBE7DFB
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIUpdateManager
Ci
.
nsIObserver
]
)
}
;
function
Checker
(
)
{
}
Checker
.
prototype
=
{
_request
:
null
_callback
:
null
_getCanMigrate
:
function
UC__getCanMigrate
(
)
{
if
(
AppConstants
.
platform
!
=
"
win
"
)
{
return
false
;
}
let
aryABI
=
UpdateUtils
.
ABI
.
split
(
"
-
"
)
;
if
(
aryABI
[
0
]
!
=
"
x86
"
|
|
aryABI
[
2
]
!
=
"
x64
"
)
{
return
false
;
}
let
wrk
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
let
regPath
=
"
SOFTWARE
\
\
Mozilla
\
\
"
+
Services
.
appinfo
.
name
+
"
\
\
32to64DidMigrate
"
;
let
regValHKCU
=
WindowsRegistry
.
readRegKey
(
wrk
.
ROOT_KEY_CURRENT_USER
regPath
"
Never
"
wrk
.
WOW64_32
)
;
let
regValHKLM
=
WindowsRegistry
.
readRegKey
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
regPath
"
Never
"
wrk
.
WOW64_32
)
;
if
(
regValHKCU
=
=
=
1
|
|
regValHKLM
=
=
=
1
)
{
LOG
(
"
Checker
:
_getCanMigrate
-
all
installations
should
not
be
migrated
"
)
;
return
false
;
}
let
appBaseDirPath
=
getAppBaseDir
(
)
.
path
;
regValHKCU
=
WindowsRegistry
.
readRegKey
(
wrk
.
ROOT_KEY_CURRENT_USER
regPath
appBaseDirPath
wrk
.
WOW64_32
)
;
regValHKLM
=
WindowsRegistry
.
readRegKey
(
wrk
.
ROOT_KEY_LOCAL_MACHINE
regPath
appBaseDirPath
wrk
.
WOW64_32
)
;
if
(
regValHKCU
=
=
=
1
|
|
regValHKLM
=
=
=
1
)
{
LOG
(
"
Checker
:
_getCanMigrate
-
this
installation
should
not
be
migrated
"
)
;
return
false
;
}
if
(
regValHKCU
=
=
=
0
|
|
regValHKLM
=
=
=
0
)
{
LOG
(
"
Checker
:
_getCanMigrate
-
this
installation
can
be
migrated
"
)
;
return
true
;
}
LOG
(
"
Checker
:
_getCanMigrate
-
no
registry
entries
for
this
installation
"
)
;
return
false
;
}
getUpdateURL
:
async
function
UC_getUpdateURL
(
force
)
{
this
.
_forced
=
force
;
let
url
=
Services
.
prefs
.
getDefaultBranch
(
null
)
.
getCharPref
(
PREF_APP_UPDATE_URL
"
"
)
;
if
(
!
url
)
{
LOG
(
"
Checker
:
getUpdateURL
-
update
URL
not
defined
"
)
;
return
null
;
}
url
=
await
UpdateUtils
.
formatUpdateURL
(
url
)
;
if
(
force
)
{
url
+
=
(
url
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
)
+
"
force
=
1
"
;
}
if
(
this
.
_getCanMigrate
(
)
)
{
url
+
=
(
url
.
includes
(
"
?
"
)
?
"
&
"
:
"
?
"
)
+
"
mig64
=
1
"
;
}
LOG
(
"
Checker
:
getUpdateURL
-
update
URL
:
"
+
url
)
;
return
url
;
}
checkForUpdates
:
function
UC_checkForUpdates
(
listener
force
)
{
LOG
(
"
Checker
:
checkForUpdates
force
:
"
+
force
)
;
gUpdateFileWriteInfo
=
{
phase
:
"
check
"
failure
:
false
}
;
if
(
!
listener
)
{
throw
Cr
.
NS_ERROR_NULL_POINTER
;
}
let
UpdateServiceInstance
=
UpdateServiceFactory
.
createInstance
(
)
;
if
(
UpdateServiceInstance
.
disabledByPolicy
)
{
LOG
(
"
Checker
:
checkForUpdates
disabled
by
policy
"
)
;
return
;
}
if
(
!
UpdateServiceInstance
.
canCheckForUpdates
&
&
!
force
)
{
return
;
}
this
.
getUpdateURL
(
force
)
.
then
(
url
=
>
{
if
(
!
url
)
{
return
;
}
this
.
_request
=
new
XMLHttpRequest
(
)
;
this
.
_request
.
open
(
"
GET
"
url
true
)
;
this
.
_request
.
channel
.
notificationCallbacks
=
new
CertUtils
.
BadCertHandler
(
false
)
;
this
.
_request
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
;
this
.
_request
.
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
INHIBIT_CACHING
;
this
.
_request
.
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
.
beConservative
=
true
;
this
.
_request
.
overrideMimeType
(
"
text
/
xml
"
)
;
this
.
_request
.
setRequestHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
)
;
this
.
_request
.
setRequestHeader
(
"
Pragma
"
"
no
-
cache
"
)
;
var
self
=
this
;
this
.
_request
.
addEventListener
(
"
error
"
function
(
event
)
{
self
.
onError
(
event
)
;
}
)
;
this
.
_request
.
addEventListener
(
"
load
"
function
(
event
)
{
self
.
onLoad
(
event
)
;
}
)
;
LOG
(
"
Checker
:
checkForUpdates
-
sending
request
to
:
"
+
url
)
;
this
.
_request
.
send
(
null
)
;
this
.
_callback
=
listener
;
}
)
;
}
get
_updates
(
)
{
var
updatesElement
=
this
.
_request
.
responseXML
.
documentElement
;
if
(
!
updatesElement
)
{
LOG
(
"
Checker
:
_updates
get
-
empty
updates
document
?
!
"
)
;
return
[
]
;
}
if
(
updatesElement
.
nodeName
!
=
"
updates
"
)
{
LOG
(
"
Checker
:
_updates
get
-
unexpected
node
name
!
"
)
;
throw
new
Error
(
"
Unexpected
node
name
expected
:
updates
got
:
"
+
updatesElement
.
nodeName
)
;
}
var
updates
=
[
]
;
for
(
var
i
=
0
;
i
<
updatesElement
.
childNodes
.
length
;
+
+
i
)
{
var
updateElement
=
updatesElement
.
childNodes
.
item
(
i
)
;
if
(
updateElement
.
nodeType
!
=
updateElement
.
ELEMENT_NODE
|
|
updateElement
.
localName
!
=
"
update
"
)
continue
;
let
update
;
try
{
update
=
new
Update
(
updateElement
)
;
}
catch
(
e
)
{
LOG
(
"
Checker
:
_updates
get
-
invalid
<
update
/
>
ignoring
.
.
.
"
)
;
continue
;
}
update
.
serviceURL
=
this
.
_request
.
responseURL
;
update
.
channel
=
UpdateUtils
.
UpdateChannel
;
updates
.
push
(
update
)
;
}
return
updates
;
}
_getChannelStatus
:
function
UC__getChannelStatus
(
request
)
{
var
status
=
0
;
try
{
status
=
request
.
status
;
}
catch
(
e
)
{
}
if
(
status
=
=
0
)
status
=
request
.
channel
.
QueryInterface
(
Ci
.
nsIRequest
)
.
status
;
return
status
;
}
_isHttpStatusCode
:
function
UC__isHttpStatusCode
(
status
)
{
return
status
>
=
100
&
&
status
<
=
599
;
}
onLoad
:
function
UC_onLoad
(
event
)
{
LOG
(
"
Checker
:
onLoad
-
request
completed
downloading
document
"
)
;
Services
.
prefs
.
clearUserPref
(
"
security
.
pki
.
mitm_canary_issuer
"
)
;
try
{
let
sslStatus
=
request
.
channel
.
QueryInterface
(
Ci
.
nsIRequest
)
.
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
if
(
sslStatus
&
&
sslStatus
.
succeededCertChain
)
{
let
rootCert
=
null
;
for
(
rootCert
of
XPCOMUtils
.
IterSimpleEnumerator
(
sslStatus
.
succeededCertChain
.
getEnumerator
(
)
Ci
.
nsIX509Cert
)
)
;
if
(
rootCert
)
{
Services
.
prefs
.
setStringPref
(
"
security
.
pki
.
mitm_detected
"
!
rootCert
.
isBuiltInRoot
)
;
}
}
}
catch
(
e
)
{
LOG
(
"
Checker
:
onLoad
-
Getting
sslStatus
failed
.
"
)
;
}
try
{
var
updates
=
this
.
_updates
;
LOG
(
"
Checker
:
onLoad
-
number
of
updates
available
:
"
+
updates
.
length
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
)
{
Services
.
prefs
.
clearUserPref
(
PREF_APP_UPDATE_BACKGROUNDERRORS
)
;
}
this
.
_callback
.
onCheckComplete
(
event
.
target
updates
updates
.
length
)
;
}
catch
(
e
)
{
LOG
(
"
Checker
:
onLoad
-
there
was
a
problem
checking
for
updates
.
"
+
"
Exception
:
"
+
e
)
;
var
request
=
event
.
target
;
var
status
=
this
.
_getChannelStatus
(
request
)
;
LOG
(
"
Checker
:
onLoad
-
request
.
status
:
"
+
status
)
;
var
update
=
new
Update
(
null
)
;
update
.
errorCode
=
status
;
update
.
statusText
=
getStatusTextFromCode
(
status
404
)
;
if
(
this
.
_isHttpStatusCode
(
status
)
)
{
update
.
errorCode
=
HTTP_ERROR_OFFSET
+
status
;
}
this
.
_callback
.
onError
(
request
update
)
;
}
this
.
_callback
=
null
;
this
.
_request
=
null
;
}
onError
:
function
UC_onError
(
event
)
{
var
request
=
event
.
target
;
var
status
=
this
.
_getChannelStatus
(
request
)
;
LOG
(
"
Checker
:
onError
-
request
.
status
:
"
+
status
)
;
try
{
var
secInfo
=
request
.
channel
.
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
if
(
secInfo
.
serverCert
&
&
secInfo
.
serverCert
.
issuerName
)
{
Services
.
prefs
.
setStringPref
(
"
security
.
pki
.
mitm_canary_issuer
"
secInfo
.
serverCert
.
issuerName
)
;
}
}
catch
(
e
)
{
LOG
(
"
Checker
:
onError
-
Getting
secInfo
failed
.
"
)
;
}
var
update
=
new
Update
(
null
)
;
update
.
errorCode
=
status
;
update
.
statusText
=
getStatusTextFromCode
(
status
200
)
;
if
(
status
=
=
Cr
.
NS_ERROR_OFFLINE
)
{
update
.
errorCode
=
NETWORK_ERROR_OFFLINE
;
}
else
if
(
this
.
_isHttpStatusCode
(
status
)
)
{
update
.
errorCode
=
HTTP_ERROR_OFFSET
+
status
;
}
this
.
_callback
.
onError
(
request
update
)
;
this
.
_request
=
null
;
}
stopCurrentCheck
:
function
UC_stopCurrentCheck
(
)
{
if
(
this
.
_request
)
this
.
_request
.
abort
(
)
;
this
.
_callback
=
null
;
}
classID
:
Components
.
ID
(
"
{
898CDC9B
-
E43F
-
422F
-
9CC4
-
2F6291B415A3
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIUpdateChecker
]
)
}
;
function
Downloader
(
background
updateService
)
{
LOG
(
"
Creating
Downloader
"
)
;
this
.
background
=
background
;
this
.
updateService
=
updateService
;
}
Downloader
.
prototype
=
{
_patch
:
null
_update
:
null
_request
:
null
isCompleteUpdate
:
null
cancel
:
function
Downloader_cancel
(
cancelError
)
{
LOG
(
"
Downloader
:
cancel
"
)
;
if
(
cancelError
=
=
=
undefined
)
{
cancelError
=
Cr
.
NS_BINDING_ABORTED
;
}
if
(
this
.
_request
&
&
this
.
_request
instanceof
Ci
.
nsIRequest
)
{
this
.
_request
.
cancel
(
cancelError
)
;
}
}
get
patchIsStaged
(
)
{
var
readState
=
readStatusFile
(
getUpdatesDir
(
)
)
;
return
readState
=
=
STATE_PENDING
|
|
readState
=
=
STATE_PENDING_SERVICE
|
|
readState
=
=
STATE_PENDING_ELEVATE
|
|
readState
=
=
STATE_APPLIED
|
|
readState
=
=
STATE_APPLIED_SERVICE
;
}
_verifyDownload
:
function
Downloader__verifyDownload
(
)
{
LOG
(
"
Downloader
:
_verifyDownload
called
"
)
;
if
(
!
this
.
_request
)
{
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_ERR_VERIFY_NO_REQUEST
)
;
return
false
;
}
let
destination
=
this
.
_request
.
destination
;
if
(
destination
.
fileSize
!
=
this
.
_patch
.
size
)
{
LOG
(
"
Downloader
:
_verifyDownload
downloaded
size
!
=
expected
size
.
"
)
;
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_ERR_VERIFY_PATCH_SIZE_NOT_EQUAL
)
;
return
false
;
}
LOG
(
"
Downloader
:
_verifyDownload
downloaded
size
=
=
expected
size
.
"
)
;
return
true
;
}
_selectPatch
:
function
Downloader__selectPatch
(
update
updateDir
)
{
function
getPatchOfType
(
type
)
{
for
(
var
i
=
0
;
i
<
update
.
patchCount
;
+
+
i
)
{
var
patch
=
update
.
getPatchAt
(
i
)
;
if
(
patch
&
&
patch
.
type
=
=
type
)
return
patch
;
}
return
null
;
}
var
selectedPatch
=
update
.
selectedPatch
;
var
state
=
readStatusFile
(
updateDir
)
;
var
useComplete
=
false
;
if
(
selectedPatch
)
{
LOG
(
"
Downloader
:
_selectPatch
-
found
existing
patch
with
state
:
"
+
state
)
;
if
(
state
=
=
STATE_DOWNLOADING
)
{
LOG
(
"
Downloader
:
_selectPatch
-
resuming
download
"
)
;
return
selectedPatch
;
}
if
(
state
=
=
STATE_PENDING
|
|
state
=
=
STATE_PENDING_SERVICE
|
|
state
=
=
STATE_PENDING_ELEVATE
|
|
state
=
=
STATE_APPLIED
|
|
state
=
=
STATE_APPLIED_SERVICE
)
{
LOG
(
"
Downloader
:
_selectPatch
-
already
downloaded
"
)
;
return
null
;
}
if
(
update
&
&
selectedPatch
.
type
=
=
"
complete
"
)
{
LOG
(
"
Downloader
:
_selectPatch
-
failed
to
apply
complete
patch
!
"
)
;
writeStatusFile
(
updateDir
STATE_NONE
)
;
writeVersionFile
(
getUpdatesDir
(
)
null
)
;
return
null
;
}
useComplete
=
true
;
selectedPatch
=
null
;
}
var
partialPatch
=
getPatchOfType
(
"
partial
"
)
;
if
(
!
useComplete
)
selectedPatch
=
partialPatch
;
if
(
!
selectedPatch
)
{
if
(
partialPatch
)
partialPatch
.
selected
=
false
;
selectedPatch
=
getPatchOfType
(
"
complete
"
)
;
}
updateDir
=
getUpdatesDir
(
)
;
if
(
selectedPatch
)
selectedPatch
.
selected
=
true
;
update
.
isCompleteUpdate
=
useComplete
;
var
um
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
;
um
.
activeUpdate
=
update
;
return
selectedPatch
;
}
get
isBusy
(
)
{
return
this
.
_request
!
=
null
;
}
downloadUpdate
:
function
Downloader_downloadUpdate
(
update
)
{
LOG
(
"
UpdateService
:
_downloadUpdate
"
)
;
gUpdateFileWriteInfo
=
{
phase
:
"
download
"
failure
:
false
}
;
if
(
!
update
)
{
AUSTLMY
.
pingDownloadCode
(
undefined
AUSTLMY
.
DWNLD_ERR_NO_UPDATE
)
;
throw
Cr
.
NS_ERROR_NULL_POINTER
;
}
var
updateDir
=
getUpdatesDir
(
)
;
this
.
_update
=
update
;
this
.
_patch
=
this
.
_selectPatch
(
update
updateDir
)
;
if
(
!
this
.
_patch
)
{
LOG
(
"
Downloader
:
downloadUpdate
-
no
patch
to
download
"
)
;
AUSTLMY
.
pingDownloadCode
(
undefined
AUSTLMY
.
DWNLD_ERR_NO_UPDATE_PATCH
)
;
return
readStatusFile
(
updateDir
)
;
}
this
.
isCompleteUpdate
=
this
.
_patch
.
type
=
=
"
complete
"
;
let
patchFile
=
getUpdatesDir
(
)
.
clone
(
)
;
patchFile
.
append
(
FILE_UPDATE_MAR
)
;
let
interval
=
0
;
LOG
(
"
Downloader
:
downloadUpdate
-
url
:
"
+
this
.
_patch
.
URL
+
"
path
:
"
+
patchFile
.
path
+
"
interval
:
"
+
interval
)
;
var
uri
=
Services
.
io
.
newURI
(
this
.
_patch
.
URL
)
;
this
.
_request
=
Cc
[
"
mozilla
.
org
/
network
/
incremental
-
download
;
1
"
]
.
createInstance
(
Ci
.
nsIIncrementalDownload
)
;
this
.
_request
.
init
(
uri
patchFile
DOWNLOAD_CHUNK_SIZE
interval
)
;
this
.
_request
.
start
(
this
null
)
;
writeStatusFile
(
updateDir
STATE_DOWNLOADING
)
;
if
(
this
.
_patch
.
state
!
=
STATE_DOWNLOADING
)
{
this
.
_patch
.
state
=
STATE_DOWNLOADING
;
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
.
saveUpdates
(
)
;
}
return
STATE_DOWNLOADING
;
}
_listeners
:
[
]
addDownloadListener
:
function
Downloader_addDownloadListener
(
listener
)
{
for
(
var
i
=
0
;
i
<
this
.
_listeners
.
length
;
+
+
i
)
{
if
(
this
.
_listeners
[
i
]
=
=
listener
)
return
;
}
this
.
_listeners
.
push
(
listener
)
;
}
removeDownloadListener
:
function
Downloader_removeDownloadListener
(
listener
)
{
for
(
let
i
=
0
;
i
<
this
.
_listeners
.
length
;
+
+
i
)
{
if
(
this
.
_listeners
[
i
]
=
=
listener
)
{
this
.
_listeners
.
splice
(
i
1
)
;
return
;
}
}
}
onStartRequest
:
function
Downloader_onStartRequest
(
request
context
)
{
if
(
request
instanceof
Ci
.
nsIIncrementalDownload
)
LOG
(
"
Downloader
:
onStartRequest
-
original
URI
spec
:
"
+
request
.
URI
.
spec
+
"
final
URI
spec
:
"
+
request
.
finalURI
.
spec
)
;
if
(
this
.
_patch
.
finalURL
!
=
request
.
finalURI
.
spec
)
{
this
.
_patch
.
finalURL
=
request
.
finalURI
.
spec
;
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
.
saveUpdates
(
)
;
}
let
listeners
=
this
.
_listeners
.
concat
(
)
;
let
listenerCount
=
listeners
.
length
;
for
(
let
i
=
0
;
i
<
listenerCount
;
+
+
i
)
{
listeners
[
i
]
.
onStartRequest
(
request
context
)
;
}
}
onProgress
:
function
Downloader_onProgress
(
request
context
progress
maxProgress
)
{
LOG
(
"
Downloader
:
onProgress
-
progress
:
"
+
progress
+
"
/
"
+
maxProgress
)
;
if
(
progress
>
this
.
_patch
.
size
)
{
LOG
(
"
Downloader
:
onProgress
-
progress
:
"
+
progress
+
"
is
higher
than
patch
size
:
"
+
this
.
_patch
.
size
)
;
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_ERR_PATCH_SIZE_LARGER
)
;
this
.
cancel
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
maxProgress
!
=
this
.
_patch
.
size
)
{
LOG
(
"
Downloader
:
onProgress
-
maxProgress
:
"
+
maxProgress
+
"
is
not
equal
to
expected
patch
size
:
"
+
this
.
_patch
.
size
)
;
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_ERR_PATCH_SIZE_NOT_EQUAL
)
;
this
.
cancel
(
Cr
.
NS_ERROR_UNEXPECTED
)
;
return
;
}
var
listeners
=
this
.
_listeners
.
concat
(
)
;
var
listenerCount
=
listeners
.
length
;
for
(
var
i
=
0
;
i
<
listenerCount
;
+
+
i
)
{
var
listener
=
listeners
[
i
]
;
if
(
listener
instanceof
Ci
.
nsIProgressEventSink
)
listener
.
onProgress
(
request
context
progress
maxProgress
)
;
}
this
.
updateService
.
_consecutiveSocketErrors
=
0
;
}
onStatus
:
function
Downloader_onStatus
(
request
context
status
statusText
)
{
LOG
(
"
Downloader
:
onStatus
-
status
:
"
+
status
+
"
statusText
:
"
+
statusText
)
;
var
listeners
=
this
.
_listeners
.
concat
(
)
;
var
listenerCount
=
listeners
.
length
;
for
(
var
i
=
0
;
i
<
listenerCount
;
+
+
i
)
{
var
listener
=
listeners
[
i
]
;
if
(
listener
instanceof
Ci
.
nsIProgressEventSink
)
listener
.
onStatus
(
request
context
status
statusText
)
;
}
}
onStopRequest
:
function
Downloader_onStopRequest
(
request
context
status
)
{
if
(
request
instanceof
Ci
.
nsIIncrementalDownload
)
LOG
(
"
Downloader
:
onStopRequest
-
original
URI
spec
:
"
+
request
.
URI
.
spec
+
"
final
URI
spec
:
"
+
request
.
finalURI
.
spec
+
"
status
:
"
+
status
)
;
var
state
=
this
.
_patch
.
state
;
var
shouldShowPrompt
=
false
;
var
shouldRegisterOnlineObserver
=
false
;
var
shouldRetrySoon
=
false
;
var
deleteActiveUpdate
=
false
;
var
retryTimeout
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_SOCKET_RETRYTIMEOUT
DEFAULT_SOCKET_RETRYTIMEOUT
)
;
retryTimeout
=
Math
.
min
(
retryTimeout
10000
)
;
var
maxFail
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_SOCKET_MAXERRORS
DEFAULT_SOCKET_MAX_ERRORS
)
;
maxFail
=
Math
.
min
(
maxFail
20
)
;
let
permissionFixingInProgress
=
false
;
LOG
(
"
Downloader
:
onStopRequest
-
status
:
"
+
status
+
"
"
+
"
current
fail
:
"
+
this
.
updateService
.
_consecutiveSocketErrors
+
"
"
+
"
max
fail
:
"
+
maxFail
+
"
"
+
"
retryTimeout
:
"
+
retryTimeout
)
;
if
(
Components
.
isSuccessCode
(
status
)
)
{
if
(
this
.
_verifyDownload
(
)
)
{
if
(
shouldUseService
(
)
)
{
state
=
STATE_PENDING_SERVICE
;
}
else
if
(
getElevationRequired
(
)
)
{
state
=
STATE_PENDING_ELEVATE
;
}
else
{
state
=
STATE_PENDING
;
}
if
(
this
.
background
)
{
shouldShowPrompt
=
!
getCanStageUpdates
(
)
;
}
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_SUCCESS
)
;
writeStatusFile
(
getUpdatesDir
(
)
state
)
;
writeVersionFile
(
getUpdatesDir
(
)
this
.
_update
.
appVersion
)
;
this
.
_update
.
installDate
=
(
new
Date
(
)
)
.
getTime
(
)
;
this
.
_update
.
statusText
=
gUpdateBundle
.
GetStringFromName
(
"
installPending
"
)
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
0
)
;
}
else
{
LOG
(
"
Downloader
:
onStopRequest
-
download
verification
failed
"
)
;
state
=
STATE_DOWNLOAD_FAILED
;
status
=
Cr
.
NS_ERROR_CORRUPTED_CONTENT
;
const
vfCode
=
"
verification_failed
"
;
var
message
=
getStatusTextFromCode
(
vfCode
vfCode
)
;
this
.
_update
.
statusText
=
message
;
if
(
this
.
_update
.
isCompleteUpdate
|
|
this
.
_update
.
patchCount
!
=
2
)
deleteActiveUpdate
=
true
;
cleanUpUpdatesDir
(
)
;
}
}
else
if
(
status
=
=
Cr
.
NS_ERROR_OFFLINE
)
{
LOG
(
"
Downloader
:
onStopRequest
-
offline
register
online
observer
:
true
"
)
;
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
AUSTLMY
.
DWNLD_RETRY_OFFLINE
)
;
shouldRegisterOnlineObserver
=
true
;
deleteActiveUpdate
=
false
;
}
else
if
(
(
status
=
=
Cr
.
NS_ERROR_NET_TIMEOUT
|
|
status
=
=
Cr
.
NS_ERROR_CONNECTION_REFUSED
|
|
status
=
=
Cr
.
NS_ERROR_NET_RESET
|
|
status
=
=
Cr
.
NS_ERROR_DOCUMENT_NOT_CACHED
)
&
&
this
.
updateService
.
_consecutiveSocketErrors
<
maxFail
)
{
LOG
(
"
Downloader
:
onStopRequest
-
socket
error
shouldRetrySoon
:
true
"
)
;
let
dwnldCode
=
AUSTLMY
.
DWNLD_RETRY_CONNECTION_REFUSED
;
if
(
status
=
=
Cr
.
NS_ERROR_NET_TIMEOUT
)
{
dwnldCode
=
AUSTLMY
.
DWNLD_RETRY_NET_TIMEOUT
;
}
else
if
(
status
=
=
Cr
.
NS_ERROR_NET_RESET
)
{
dwnldCode
=
AUSTLMY
.
DWNLD_RETRY_NET_RESET
;
}
else
if
(
status
=
=
Cr
.
NS_ERROR_DOCUMENT_NOT_CACHED
)
{
dwnldCode
=
AUSTLMY
.
DWNLD_ERR_DOCUMENT_NOT_CACHED
;
}
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
dwnldCode
)
;
shouldRetrySoon
=
true
;
deleteActiveUpdate
=
false
;
}
else
if
(
status
!
=
Cr
.
NS_BINDING_ABORTED
&
&
status
!
=
Cr
.
NS_ERROR_ABORT
)
{
if
(
status
=
=
Cr
.
NS_ERROR_FILE_ACCESS_DENIED
|
|
status
=
=
Cr
.
NS_ERROR_FILE_READ_ONLY
)
{
LOG
(
"
Downloader
:
onStopRequest
-
permission
error
"
)
;
let
patchFile
=
getUpdatesDir
(
)
.
clone
(
)
;
patchFile
.
append
(
FILE_UPDATE_MAR
)
;
permissionFixingInProgress
=
handleCriticalWriteFailure
(
patchFile
.
path
)
;
}
else
{
LOG
(
"
Downloader
:
onStopRequest
-
non
-
verification
failure
"
)
;
}
let
dwnldCode
=
AUSTLMY
.
DWNLD_ERR_BINDING_ABORTED
;
if
(
status
=
=
Cr
.
NS_ERROR_ABORT
)
{
dwnldCode
=
AUSTLMY
.
DWNLD_ERR_ABORT
;
}
AUSTLMY
.
pingDownloadCode
(
this
.
isCompleteUpdate
dwnldCode
)
;
state
=
STATE_DOWNLOAD_FAILED
;
this
.
_update
.
statusText
=
getStatusTextFromCode
(
status
Cr
.
NS_BINDING_FAILED
)
;
cleanUpUpdatesDir
(
)
;
deleteActiveUpdate
=
true
;
}
let
saveUpdate
=
false
;
LOG
(
"
Downloader
:
onStopRequest
-
setting
state
to
:
"
+
state
)
;
if
(
this
.
_patch
.
state
!
=
state
)
{
saveUpdate
=
true
;
this
.
_patch
.
state
=
state
;
}
var
um
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
;
if
(
deleteActiveUpdate
)
{
saveUpdate
=
true
;
this
.
_update
.
installDate
=
(
new
Date
(
)
)
.
getTime
(
)
;
um
.
activeUpdate
=
null
;
}
else
if
(
um
.
activeUpdate
&
&
um
.
activeUpdate
.
state
!
=
state
)
{
saveUpdate
=
true
;
um
.
activeUpdate
.
state
=
state
;
}
if
(
saveUpdate
)
{
um
.
saveUpdates
(
)
;
}
if
(
!
shouldRetrySoon
&
&
!
shouldRegisterOnlineObserver
)
{
var
listeners
=
this
.
_listeners
.
concat
(
)
;
var
listenerCount
=
listeners
.
length
;
for
(
var
i
=
0
;
i
<
listenerCount
;
+
+
i
)
{
listeners
[
i
]
.
onStopRequest
(
request
context
status
)
;
}
}
this
.
_request
=
null
;
if
(
state
=
=
STATE_DOWNLOAD_FAILED
)
{
var
allFailed
=
true
;
if
(
!
this
.
_update
.
isCompleteUpdate
&
&
this
.
_update
.
patchCount
=
=
2
)
{
LOG
(
"
Downloader
:
onStopRequest
-
verification
of
patch
failed
"
+
"
downloading
complete
update
patch
"
)
;
this
.
_update
.
isCompleteUpdate
=
true
;
let
updateStatus
=
this
.
downloadUpdate
(
this
.
_update
)
;
if
(
updateStatus
=
=
STATE_NONE
)
{
cleanupActiveUpdate
(
)
;
}
else
{
allFailed
=
false
;
}
}
if
(
allFailed
&
&
!
permissionFixingInProgress
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_DOORHANGER
false
)
)
{
let
downloadAttempts
=
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
0
)
;
downloadAttempts
+
+
;
Services
.
prefs
.
setIntPref
(
PREF_APP_UPDATE_DOWNLOAD_ATTEMPTS
downloadAttempts
)
;
let
maxAttempts
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_DOWNLOAD_MAXATTEMPTS
2
)
10
)
;
if
(
downloadAttempts
>
maxAttempts
)
{
LOG
(
"
Downloader
:
onStopRequest
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
download
-
attempts
-
exceeded
"
+
"
downloadAttempts
:
"
+
downloadAttempts
+
"
"
+
"
maxAttempts
:
"
+
maxAttempts
)
;
Services
.
obs
.
notifyObservers
(
this
.
_update
"
update
-
error
"
"
download
-
attempts
-
exceeded
"
)
;
}
else
{
this
.
_update
.
selectedPatch
.
selected
=
false
;
LOG
(
"
Downloader
:
onStopRequest
-
notifying
observers
of
error
.
"
+
"
topic
:
update
-
error
status
:
download
-
attempt
-
failed
"
)
;
Services
.
obs
.
notifyObservers
(
this
.
_update
"
update
-
error
"
"
download
-
attempt
-
failed
"
)
;
}
}
this
.
_update
.
QueryInterface
(
Ci
.
nsIWritablePropertyBag
)
;
if
(
!
Services
.
wm
.
getMostRecentWindow
(
UPDATE_WINDOW_NAME
)
&
&
this
.
_update
.
getProperty
(
"
foregroundDownload
"
)
=
=
"
true
"
)
{
let
prompter
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
;
prompter
.
showUpdateError
(
this
.
_update
)
;
}
}
if
(
allFailed
)
{
this
.
_update
=
null
;
}
return
;
}
if
(
state
=
=
STATE_PENDING
|
|
state
=
=
STATE_PENDING_SERVICE
|
|
state
=
=
STATE_PENDING_ELEVATE
)
{
if
(
getCanStageUpdates
(
)
)
{
LOG
(
"
Downloader
:
onStopRequest
-
attempting
to
stage
update
:
"
+
this
.
_update
.
name
)
;
gUpdateFileWriteInfo
=
{
phase
:
"
stage
"
failure
:
false
}
;
try
{
Cc
[
"
mozilla
.
org
/
updates
/
update
-
processor
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdateProcessor
)
.
processUpdate
(
this
.
_update
)
;
}
catch
(
e
)
{
LOG
(
"
Downloader
:
onStopRequest
-
failed
to
stage
update
.
Exception
:
"
+
e
)
;
if
(
this
.
background
)
{
shouldShowPrompt
=
true
;
}
}
}
}
if
(
shouldShowPrompt
)
{
let
prompter
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
]
.
createInstance
(
Ci
.
nsIUpdatePrompt
)
;
prompter
.
showUpdateDownloaded
(
this
.
_update
true
)
;
}
if
(
shouldRegisterOnlineObserver
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Registering
online
observer
"
)
;
this
.
updateService
.
_registerOnlineObserver
(
)
;
}
else
if
(
shouldRetrySoon
)
{
LOG
(
"
Downloader
:
onStopRequest
-
Retrying
soon
"
)
;
this
.
updateService
.
_consecutiveSocketErrors
+
+
;
if
(
this
.
updateService
.
_retryTimer
)
{
this
.
updateService
.
_retryTimer
.
cancel
(
)
;
}
this
.
updateService
.
_retryTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
updateService
.
_retryTimer
.
initWithCallback
(
function
(
)
{
this
.
_attemptResume
(
)
;
}
.
bind
(
this
.
updateService
)
retryTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
else
{
this
.
_update
=
null
;
}
}
getInterface
:
function
Downloader_getInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIAuthPrompt
)
)
{
var
prompt
=
Cc
[
"
mozilla
.
org
/
network
/
default
-
auth
-
prompt
;
1
"
]
.
createInstance
(
)
;
return
prompt
.
QueryInterface
(
iid
)
;
}
throw
Cr
.
NS_NOINTERFACE
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIRequestObserver
Ci
.
nsIProgressEventSink
Ci
.
nsIInterfaceRequestor
]
)
}
;
function
UpdatePrompt
(
)
{
}
UpdatePrompt
.
prototype
=
{
checkForUpdates
:
function
UP_checkForUpdates
(
)
{
if
(
this
.
_getAltUpdateWindow
(
)
)
return
;
this
.
_showUI
(
null
URI_UPDATE_PROMPT_DIALOG
null
UPDATE_WINDOW_NAME
null
null
)
;
}
showUpdateAvailable
:
function
UP_showUpdateAvailable
(
update
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_SILENT
false
)
|
|
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_DOORHANGER
false
)
|
|
this
.
_getUpdateWindow
(
)
|
|
this
.
_getAltUpdateWindow
(
)
)
{
return
;
}
this
.
_showUnobtrusiveUI
(
null
URI_UPDATE_PROMPT_DIALOG
null
UPDATE_WINDOW_NAME
"
updatesavailable
"
update
)
;
}
showUpdateDownloaded
:
function
UP_showUpdateDownloaded
(
update
background
)
{
if
(
background
&
&
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_SILENT
false
)
)
{
return
;
}
LOG
(
"
showUpdateDownloaded
-
Notifying
observers
that
"
+
"
an
update
was
downloaded
.
topic
:
update
-
downloaded
status
:
"
+
update
.
state
)
;
Services
.
obs
.
notifyObservers
(
update
"
update
-
downloaded
"
update
.
state
)
;
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_DOORHANGER
false
)
)
{
return
;
}
if
(
this
.
_getAltUpdateWindow
(
)
)
return
;
if
(
background
)
{
this
.
_showUnobtrusiveUI
(
null
URI_UPDATE_PROMPT_DIALOG
null
UPDATE_WINDOW_NAME
"
finishedBackground
"
update
)
;
}
else
{
this
.
_showUI
(
null
URI_UPDATE_PROMPT_DIALOG
null
UPDATE_WINDOW_NAME
"
finishedBackground
"
update
)
;
}
}
showUpdateError
:
function
UP_showUpdateError
(
update
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_SILENT
false
)
|
|
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_DOORHANGER
false
)
|
|
this
.
_getAltUpdateWindow
(
)
)
return
;
if
(
update
.
state
=
=
STATE_FAILED
&
&
WRITE_ERRORS
.
includes
(
update
.
errorCode
)
)
{
var
title
=
gUpdateBundle
.
GetStringFromName
(
"
updaterIOErrorTitle
"
)
;
var
text
=
gUpdateBundle
.
formatStringFromName
(
"
updaterIOErrorMsg
"
[
Services
.
appinfo
.
name
Services
.
appinfo
.
name
]
2
)
;
Services
.
ww
.
getNewPrompter
(
null
)
.
alert
(
title
text
)
;
return
;
}
if
(
update
.
errorCode
=
=
BACKGROUNDCHECK_MULTIPLE_FAILURES
)
{
this
.
_showUIWhenIdle
(
null
URI_UPDATE_PROMPT_DIALOG
null
UPDATE_WINDOW_NAME
null
update
)
;
return
;
}
this
.
_showUI
(
null
URI_UPDATE_PROMPT_DIALOG
null
UPDATE_WINDOW_NAME
"
errors
"
update
)
;
}
showUpdateHistory
:
function
UP_showUpdateHistory
(
parent
)
{
this
.
_showUI
(
parent
URI_UPDATE_HISTORY_DIALOG
"
modal
dialog
=
yes
"
"
Update
:
History
"
null
null
)
;
}
showUpdateElevationRequired
:
function
UP_showUpdateElevationRequired
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_SILENT
false
)
|
|
this
.
_getAltUpdateWindow
(
)
)
{
return
;
}
let
um
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIUpdateManager
)
;
this
.
_showUI
(
null
URI_UPDATE_PROMPT_DIALOG
null
UPDATE_WINDOW_NAME
"
finishedBackground
"
um
.
activeUpdate
)
;
}
_getUpdateWindow
:
function
UP__getUpdateWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
UPDATE_WINDOW_NAME
)
;
}
_getAltUpdateWindow
:
function
UP__getAltUpdateWindow
(
)
{
let
windowType
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_ALTWINDOWTYPE
null
)
;
if
(
!
windowType
)
return
null
;
return
Services
.
wm
.
getMostRecentWindow
(
windowType
)
;
}
_showUnobtrusiveUI
:
function
UP__showUnobUI
(
parent
uri
features
name
page
update
)
{
var
observer
=
{
updatePrompt
:
this
service
:
null
timer
:
null
notify
(
)
{
this
.
service
.
removeObserver
(
this
"
quit
-
application
"
)
;
if
(
this
.
updatePrompt
.
_getUpdateWindow
(
)
)
return
;
this
.
updatePrompt
.
_showUIWhenIdle
(
parent
uri
features
name
page
update
)
;
}
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
quit
-
application
"
:
if
(
this
.
timer
)
this
.
timer
.
cancel
(
)
;
this
.
service
.
removeObserver
(
this
"
quit
-
application
"
)
;
break
;
}
}
}
;
if
(
page
=
=
"
updatesavailable
"
)
{
var
idleService
=
Cc
[
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
]
.
getService
(
Ci
.
nsIIdleService
)
;
const
IDLE_TIME
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_IDLETIME
60
)
600
)
;
if
(
idleService
.
idleTime
/
1000
>
=
IDLE_TIME
)
{
this
.
_showUI
(
parent
uri
features
name
page
update
)
;
return
;
}
}
observer
.
service
=
Services
.
obs
;
observer
.
service
.
addObserver
(
observer
"
quit
-
application
"
)
;
if
(
page
=
=
"
updatesavailable
"
)
{
this
.
_showUIWhenIdle
(
parent
uri
features
name
page
update
)
;
return
;
}
observer
.
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
observer
.
timer
.
initWithCallback
(
observer
update
.
promptWaitTime
*
1000
observer
.
timer
.
TYPE_ONE_SHOT
)
;
}
_showUIWhenIdle
:
function
UP__showUIWhenIdle
(
parent
uri
features
name
page
update
)
{
var
idleService
=
Cc
[
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
]
.
getService
(
Ci
.
nsIIdleService
)
;
const
IDLE_TIME
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
PREF_APP_UPDATE_IDLETIME
60
)
600
)
;
if
(
idleService
.
idleTime
/
1000
>
=
IDLE_TIME
)
{
this
.
_showUI
(
parent
uri
features
name
page
update
)
;
}
else
{
var
observer
=
{
updatePrompt
:
this
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
idle
"
:
if
(
!
this
.
updatePrompt
.
_getUpdateWindow
(
)
)
this
.
updatePrompt
.
_showUI
(
parent
uri
features
name
page
update
)
;
case
"
quit
-
application
"
:
idleService
.
removeIdleObserver
(
this
IDLE_TIME
)
;
Services
.
obs
.
removeObserver
(
this
"
quit
-
application
"
)
;
break
;
}
}
}
;
idleService
.
addIdleObserver
(
observer
IDLE_TIME
)
;
Services
.
obs
.
addObserver
(
observer
"
quit
-
application
"
)
;
}
}
_showUI
:
function
UP__showUI
(
parent
uri
features
name
page
update
)
{
var
ary
=
null
;
if
(
update
)
{
ary
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
ary
.
appendElement
(
update
)
;
}
var
win
=
this
.
_getUpdateWindow
(
)
;
if
(
win
)
{
if
(
page
&
&
"
setCurrentPage
"
in
win
)
win
.
setCurrentPage
(
page
)
;
win
.
focus
(
)
;
}
else
{
var
openFeatures
=
"
chrome
centerscreen
dialog
=
no
resizable
=
no
titlebar
toolbar
=
no
"
;
if
(
features
)
openFeatures
+
=
"
"
+
features
;
Services
.
ww
.
openWindow
(
parent
uri
"
"
openFeatures
ary
)
;
}
}
classDescription
:
"
Update
Prompt
"
contractID
:
"
mozilla
.
org
/
updates
/
update
-
prompt
;
1
"
classID
:
Components
.
ID
(
"
{
27ABA825
-
35B5
-
4018
-
9FDD
-
F99250A0E722
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIUpdatePrompt
]
)
}
;
var
components
=
[
UpdateService
Checker
UpdatePrompt
UpdateManager
]
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
components
)
;
