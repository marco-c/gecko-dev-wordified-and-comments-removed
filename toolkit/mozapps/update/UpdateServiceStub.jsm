const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
DIR_UPDATES
=
"
updates
"
;
const
FILE_UPDATE_STATUS
=
"
update
.
status
"
;
const
FILE_UPDATE_MESSAGES
=
"
update_messages
.
log
"
;
const
FILE_BACKUP_MESSAGES
=
"
update_messages_old
.
log
"
;
const
KEY_UPDROOT
=
"
UpdRootD
"
;
const
KEY_OLD_UPDROOT
=
"
OldUpdRootD
"
;
const
KEY_PROFILE_DIR
=
"
ProfD
"
;
const
PREF_PREFIX_UPDATE_DIR_MIGRATED
=
"
app
.
update
.
migrated
.
updateDir3
.
"
;
const
PREF_APP_UPDATE_ALTUPDATEDIRPATH
=
"
app
.
update
.
altUpdateDirPath
"
;
const
PREF_APP_UPDATE_LOG
=
"
app
.
update
.
log
"
;
const
PREF_APP_UPDATE_FILE_LOGGING
=
"
app
.
update
.
log
.
file
"
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gLogEnabled
"
function
aus_gLogEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_LOG
false
)
;
}
)
;
function
getUpdateBaseDirNoCreate
(
)
{
if
(
Cu
.
isInAutomation
)
{
const
MAGIC_TEST_ROOT_PREFIX
=
"
<
test
-
root
>
"
;
const
PREF_TEST_ROOT
=
"
mochitest
.
testRoot
"
;
let
alternatePath
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_ALTUPDATEDIRPATH
null
)
;
if
(
alternatePath
&
&
alternatePath
.
startsWith
(
MAGIC_TEST_ROOT_PREFIX
)
)
{
let
testRoot
=
Services
.
prefs
.
getCharPref
(
PREF_TEST_ROOT
)
;
let
relativePath
=
alternatePath
.
substring
(
MAGIC_TEST_ROOT_PREFIX
.
length
)
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
relativePath
=
relativePath
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
alternatePath
=
testRoot
+
relativePath
;
let
updateDir
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
updateDir
.
initWithPath
(
alternatePath
)
;
LOG
(
"
getUpdateBaseDirNoCreate
returning
test
directory
path
:
"
+
updateDir
.
path
)
;
return
updateDir
;
}
}
return
FileUtils
.
getDir
(
KEY_UPDROOT
[
]
false
)
;
}
function
UpdateServiceStub
(
)
{
let
updateDir
=
getUpdateBaseDirNoCreate
(
)
;
let
prefUpdateDirMigrated
=
PREF_PREFIX_UPDATE_DIR_MIGRATED
+
updateDir
.
leafName
;
let
statusFile
=
updateDir
;
statusFile
.
append
(
DIR_UPDATES
)
;
statusFile
.
append
(
"
0
"
)
;
statusFile
.
append
(
FILE_UPDATE_STATUS
)
;
updateDir
=
null
;
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
!
Services
.
prefs
.
getBoolPref
(
prefUpdateDirMigrated
false
)
)
{
Services
.
prefs
.
setBoolPref
(
prefUpdateDirMigrated
true
)
;
try
{
migrateUpdateDirectory
(
)
;
}
catch
(
ex
)
{
LOG
(
UpdateServiceStub
:
UpdateServiceStub
Failed
to
migrate
update
+
directory
.
Exception
:
{
ex
}
)
;
}
}
if
(
Services
.
prefs
.
getBoolPref
(
PREF_APP_UPDATE_FILE_LOGGING
false
)
)
{
deactivateUpdateLogFile
(
)
;
}
if
(
statusFile
.
exists
(
)
)
{
let
aus
=
Cc
[
"
mozilla
.
org
/
updates
/
update
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationUpdateService
)
.
QueryInterface
(
Ci
.
nsIObserver
)
;
aus
.
observe
(
null
"
post
-
update
-
processing
"
"
"
)
;
}
}
UpdateServiceStub
.
prototype
=
{
observe
(
)
{
}
classID
:
Components
.
ID
(
"
{
e43b0010
-
04ba
-
4da6
-
b523
-
1f92580bc150
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
}
;
var
EXPORTED_SYMBOLS
=
[
"
UpdateServiceStub
"
]
;
function
deactivateUpdateLogFile
(
)
{
LOG
(
"
Application
update
file
logging
being
automatically
turned
off
"
)
;
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_FILE_LOGGING
false
)
;
let
logFile
=
Services
.
dirsvc
.
get
(
KEY_PROFILE_DIR
Ci
.
nsIFile
)
;
logFile
.
append
(
FILE_UPDATE_MESSAGES
)
;
try
{
logFile
.
moveTo
(
null
FILE_BACKUP_MESSAGES
)
;
}
catch
(
e
)
{
LOG
(
"
Failed
to
backup
update
messages
log
(
"
+
e
+
"
)
.
Attempting
to
"
+
"
remove
it
.
"
)
;
try
{
logFile
.
remove
(
false
)
;
}
catch
(
e
)
{
LOG
(
"
Also
failed
to
remove
the
update
messages
log
:
"
+
e
)
;
}
}
}
function
migrateUpdateDirectory
(
)
{
LOG
(
"
UpdateServiceStub
:
migrateUpdateDirectory
Performing
migration
"
)
;
let
sourceRootDir
=
FileUtils
.
getDir
(
KEY_OLD_UPDROOT
[
]
false
)
;
let
destRootDir
=
FileUtils
.
getDir
(
KEY_UPDROOT
[
]
false
)
;
let
hash
=
destRootDir
.
leafName
;
if
(
!
sourceRootDir
.
exists
(
)
)
{
return
;
}
const
toMigrate
=
[
[
"
updates
.
xml
"
]
[
"
active
-
update
.
xml
"
]
[
"
update
-
config
.
json
"
]
[
"
updates
"
"
last
-
update
.
log
"
]
[
"
updates
"
"
backup
-
update
.
log
"
]
[
"
updates
"
"
downloading
"
FILE_UPDATE_STATUS
]
[
"
updates
"
"
downloading
"
"
update
.
mar
"
]
[
"
updates
"
"
0
"
FILE_UPDATE_STATUS
]
[
"
updates
"
"
0
"
"
update
.
mar
"
]
[
"
updates
"
"
0
"
"
update
.
version
"
]
[
"
updates
"
"
0
"
"
update
.
log
"
]
[
"
backgroundupdate
"
"
datareporting
"
"
glean
"
"
db
"
"
data
.
safe
.
bin
"
]
]
;
for
(
let
pathComponents
of
toMigrate
)
{
let
destFile
=
destRootDir
.
clone
(
)
;
for
(
let
pathComponent
of
pathComponents
)
{
destFile
.
append
(
pathComponent
)
;
}
if
(
destFile
.
exists
(
)
)
{
LOG
(
UpdateServiceStub
:
migrateUpdateDirectory
Aborting
migration
because
+
"
{
destFile
.
path
}
"
already
exists
.
)
;
return
;
}
}
let
sourceRootParent
=
sourceRootDir
.
parent
.
parent
;
let
destRootParent
=
destRootDir
.
parent
.
parent
;
let
profileCountFile
=
sourceRootParent
.
clone
(
)
;
profileCountFile
.
append
(
profile_count_
{
hash
}
.
json
)
;
migrateFile
(
profileCountFile
destRootParent
)
;
const
updatePingPrefix
=
uninstall_ping_
{
hash
}
_
;
const
updatePingSuffix
=
"
.
json
"
;
try
{
for
(
let
file
of
sourceRootParent
.
directoryEntries
)
{
if
(
file
.
leafName
.
startsWith
(
updatePingPrefix
)
&
&
file
.
leafName
.
endsWith
(
updatePingSuffix
)
)
{
migrateFile
(
file
destRootParent
)
;
}
}
}
catch
(
ex
)
{
LOG
(
UpdateServiceStub
:
migrateUpdateDirectory
Failed
to
migrate
uninstall
+
ping
.
Exception
:
{
ex
}
)
;
}
const
backgroundLogPrefix
=
backgroundupdate
;
const
backgroundLogSuffix
=
"
.
moz_log
"
;
try
{
for
(
let
file
of
sourceRootDir
.
directoryEntries
)
{
if
(
file
.
leafName
.
startsWith
(
backgroundLogPrefix
)
&
&
file
.
leafName
.
endsWith
(
backgroundLogSuffix
)
)
{
migrateFile
(
file
destRootDir
)
;
}
}
}
catch
(
ex
)
{
LOG
(
UpdateServiceStub
:
migrateUpdateDirectory
Failed
to
migrate
background
+
log
file
.
Exception
:
{
ex
}
)
;
}
const
pendingPingRelDir
=
"
backgroundupdate
\
\
datareporting
\
\
glean
\
\
pending_pings
"
;
let
pendingPingSourceDir
=
sourceRootDir
.
clone
(
)
;
pendingPingSourceDir
.
appendRelativePath
(
pendingPingRelDir
)
;
let
pendingPingDestDir
=
destRootDir
.
clone
(
)
;
pendingPingDestDir
.
appendRelativePath
(
pendingPingRelDir
)
;
const
pendingPingFilenameRegex
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
;
if
(
pendingPingSourceDir
.
exists
(
)
)
{
try
{
for
(
let
file
of
pendingPingSourceDir
.
directoryEntries
)
{
if
(
pendingPingFilenameRegex
.
test
(
file
.
leafName
)
)
{
migrateFile
(
file
pendingPingDestDir
)
;
}
}
}
catch
(
ex
)
{
LOG
(
UpdateServiceStub
:
migrateUpdateDirectory
Failed
to
migrate
+
pending
pings
.
Exception
:
{
ex
}
)
;
}
}
for
(
let
pathComponents
of
toMigrate
)
{
let
filename
=
pathComponents
.
pop
(
)
;
let
sourceFile
=
sourceRootDir
.
clone
(
)
;
let
destDir
=
destRootDir
.
clone
(
)
;
for
(
let
pathComponent
of
pathComponents
)
{
sourceFile
.
append
(
pathComponent
)
;
destDir
.
append
(
pathComponent
)
;
}
sourceFile
.
append
(
filename
)
;
migrateFile
(
sourceFile
destDir
)
;
}
let
updateLockFile
=
sourceRootParent
.
clone
(
)
;
updateLockFile
.
append
(
UpdateLock
-
{
hash
}
)
;
try
{
updateLockFile
.
remove
(
false
)
;
}
catch
(
ex
)
{
}
cleanupDir
(
sourceRootDir
true
)
;
cleanupDir
(
sourceRootDir
.
parent
false
)
;
cleanupDir
(
sourceRootParent
false
)
;
}
function
migrateFile
(
sourceFile
destDir
)
{
if
(
!
sourceFile
.
exists
(
)
)
{
return
;
}
if
(
sourceFile
.
isDirectory
(
)
)
{
LOG
(
UpdateServiceStub
:
migrateFile
Aborting
attempt
to
migrate
+
"
{
sourceFile
.
path
}
"
because
it
is
a
directory
.
)
;
return
;
}
try
{
destDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
{
LOG
(
UpdateServiceStub
:
migrateFile
Unable
to
create
destination
+
directory
"
{
destDir
.
path
}
"
:
{
ex
}
)
;
}
}
try
{
sourceFile
.
moveTo
(
destDir
null
)
;
return
;
}
catch
(
ex
)
{
}
try
{
sourceFile
.
copyTo
(
destDir
null
)
;
}
catch
(
ex
)
{
LOG
(
UpdateServiceStub
:
migrateFile
Failed
to
migrate
file
from
+
"
{
sourceFile
.
path
}
"
to
"
{
destDir
.
path
}
"
.
Exception
:
{
ex
}
)
;
return
;
}
try
{
sourceFile
.
remove
(
false
)
;
}
catch
(
ex
)
{
LOG
(
UpdateServiceStub
:
migrateFile
Successfully
migrated
file
from
+
"
{
sourceFile
.
path
}
"
to
"
{
destDir
.
path
}
"
but
was
unable
to
remove
+
the
original
.
Exception
:
{
ex
}
)
;
}
}
function
cleanupDir
(
dir
recurse
)
{
let
directoryEmpty
=
true
;
try
{
for
(
let
file
of
dir
.
directoryEntries
)
{
if
(
!
recurse
)
{
return
false
;
}
if
(
file
.
isDirectory
(
)
)
{
if
(
!
cleanupDir
(
file
recurse
)
)
{
directoryEmpty
=
false
;
}
}
else
{
directoryEmpty
=
false
;
}
}
}
catch
(
ex
)
{
return
false
;
}
if
(
directoryEmpty
)
{
try
{
dir
.
remove
(
false
)
;
return
true
;
}
catch
(
ex
)
{
}
}
return
false
;
}
function
LOG
(
string
)
{
if
(
lazy
.
gLogEnabled
)
{
dump
(
"
*
*
*
AUS
:
SVC
"
+
string
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
"
AUS
:
SVC
"
+
string
)
;
}
}
